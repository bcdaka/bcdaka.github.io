<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6368c631a6f7ff3b39fd6b13eae592f7/" rel="bookmark">
			ASCII码对照表【2024年汇总】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍺ASCII相关文章汇总如下🍺：
🎈ASCII码对照表（255个ascii字符汇总）🎈🎈ASCII码对照表（Unicode 字符集列表）🎈🎈ASCII码对照表（emoji表情符号）🎈🎈ASCII码对照表（Python代码实现打印）🎈🎈ASCII码对照表（C++17 实现ANSI、UTF8、Unicode编码互转）🎈🎈ASCII码对照表（HTML颜色代码表）🎈🎈ASCII码对照表（Matplotlib颜色对照表）🎈🎈ASCII码对照表【2024年汇总】🎈 文章目录 1、简介2、表格形式3、图片形式4、常用转义字符5、ASCII、Unicode 和 UTF-8 之间的关系5.1 ASCII 编码5.2 非 ASCII 编码5.3 Unicode5.4 UTF-85.5 Little endian 和 Big endian 结语 1、简介 ASCII（发音：，American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本延伸美国标准信息交换码则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。
ASCII 由电报码发展而来。第一版标准发布于1963年 ，1967年经历了一次主要修订[5][6]，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。
1、ASCII码 是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646 。在这个页面，你可以找到8位的256个字符、ASCII码表和Windows-1252 (code page 1252，它是国际标准ISO 8859-1的一个扩展字符集) 标准保持一致;2、ASCII码 是 American Standard Code for Information Interchange 的缩写，而不是ASCⅡ(罗马数字2)，有很多人在这个地方产生误解;3、ASCII码 规范于1967年第一次发布，最后一次更新是在1986年，它包含了33个控制字符（具有某些特殊功能但是无法显示的字符）和95个可显示字符; ASCII ，它的全称是"美国信息交换标准代码"。它设计于60年代早期，是计算机和诸如打印机、磁带驱动器之类的硬件设备的标准字符集。
ASCII 是 7 比特字符集，包含了 128 个不同的字符值。
ASCII 支持 0-9 的数字，A-Z大写和小写英文字母，以及一些特殊字符。
被广泛使用于现代计算机、HTML和因特网上的字符集都是基于 ASCII 。
ASCII英文全称：American Standard Code for Information Interchange，即：美国信息交换标准代码，是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，1986年定义了常用的128个字符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6368c631a6f7ff3b39fd6b13eae592f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c090fa8d66227e7c395134fdbacaf47/" rel="bookmark">
			MyBatis（27）如何配置 MyBatis 实现打印可执行的 SQL 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发过程中，打印可执行的SQL语句对于调试和性能优化是非常有帮助的。MyBatis提供了几种方式来实现SQL语句的打印。
1. 使用日志框架 MyBatis可以通过配置其内部使用的日志框架（如Log4j、Logback等）来打印SQL语句。这是最常用的方法。
Logback配置示例 如果你使用的是Logback，可以在logback.xml文件中添加以下配置：
&lt;configuration&gt; &lt;!-- 其他配置 --&gt; &lt;!-- 配置MyBatis日志级别 --&gt; &lt;logger name="org.apache.ibatis" level="DEBUG"/&gt; &lt;!-- 如果你想要更详细的输出，包括SQL语句、参数等 --&gt; &lt;logger name="java.sql.PreparedStatement" level="TRACE"/&gt; &lt;/configuration&gt; 这样配置后，MyBatis执行的SQL语句及其参数将会被打印到日志中。
Log4j配置示例 如果你使用的是Log4j，可以在log4j.properties文件中添加以下配置：
# 配置MyBatis日志级别 log4j.logger.org.apache.ibatis=DEBUG # 如果你想要更详细的输出，包括SQL语句、参数等 log4j.logger.java.sql.PreparedStatement=TRACE 2. 使用MyBatis提供的日志实现 MyBatis自身也提供了一个简单的日志实现，可以通过在MyBatis的配置文件mybatis-config.xml中设置来启用：
&lt;configuration&gt; &lt;settings&gt; &lt;!-- 启用日志 --&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt; &lt;/settings&gt; &lt;/configuration&gt; 这将会把日志输出到标准输出中。logImpl的值可以是STDOUT_LOGGING、LOG4J、LOG4J2、SLF4J等，根据你项目中使用的日志框架来选择。
3. 使用P6Spy P6Spy是一个数据库查询分析工具，它可以代理JDBC驱动程序，从而实现SQL语句的拦截和记录。使用P6Spy，你可以在不修改任何代码的情况下，记录所有通过JDBC执行的SQL语句。
要使用P6Spy，你需要：
添加P6Spy依赖到你的项目中。配置spy.properties文件，指定实际的JDBC驱动和日志文件路径等。修改数据库连接配置，使用P6Spy的代理驱动。 添加P6Spy依赖 以Maven为例：
&lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; 配置spy.properties 在src/main/resources目录下创建spy.properties文件，并配置如下：
driverlist=真实的数据库驱动类名 logfile=日志文件路径 修改数据库连接配置 将数据库连接的驱动类改为com.p6spy.engine.spy.P6SpyDriver，URL前缀改为jdbc:p6spy:。
总结 以上是实现MyBatis打印可执行SQL语句的几种方法。在实际开发中，可以根据项目的具体需求和使用的技术栈选择合适的方法。通常情况下，通过配置日志框架来实现是最简单也是最常用的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e708b1c1877438791a74b3d189c042/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(008)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
16、pandas.DataFrame.to_json函数
16-1、语法
16-2、参数
16-3、功能
16-4、返回值
16-5、说明
16-6、用法
16-6-1、数据准备
16-6-2、代码示例
16-6-3、结果输出
17、pandas.read_html函数
17-1、语法
17-2、参数
17-3、功能
17-4、返回值
17-5、说明
17-6、用法
17-6-1、数据准备
17-6-2、代码示例
17-6-3、结果输出 18、pandas.DataFrame.to_html函数
18-1、语法
18-2、参数
18-3、功能
18-4、返回值
18-5、说明
18-6、用法
18-6-1、数据准备
18-6-2、代码示例
18-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 16、pandas.DataFrame.to_json函数 16-1、语法 # 16、pandas.DataFrame.to_json函数 DataFrame.to_json(path_or_buf=None, *, orient=None, date_format=None, double_precision=10, force_ascii=True, date_unit='ms', default_handler=None, lines=False, compression='infer', index=None, indent=None, storage_options=None, mode='w') Convert the object to a JSON string. Note NaN’s and None will be converted to null and datetime objects will be converted to UNIX timestamps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e708b1c1877438791a74b3d189c042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0003276a5eb3c6b89d69002995b0f2de/" rel="bookmark">
			041基于SSM&#43;Jsp的高校校园点餐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：ssm技术：JSPJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
前台首页
用户注册
登录界面
食堂菜单界面
我的地址
管理员登录
用户管理
食堂管理
菜系分类管理
消息留言管理
留言板管理
美食资讯管理
订单管理
摘要
本文主要是对高校校园点餐系统进行了介绍，包括研究的现状，还有涉及的开发背景，然后还对系统的设计目标进行了论述，还有系统的需求，以及整个的设计方案，对系统的设计以及实现，也都论述的比较细致，最后对高校校园点餐系统进行了一些具体测试。
本文以Java为开发技术，实现了一个高校校园点餐系统。高校校园点餐系统的主要使用者分为管理员；个人中心、用户管理、食堂管理、食堂菜单管理、菜系分类管理、消息留言管理、留言板管理、系统管理、订单管理，用户；个人中心、消息留言管理、我的收藏管理、订单管理，食堂；个人中心、食堂菜单管理、菜系分类管理、消息留言管理、订单管理，前台首页；首页、食堂菜单、新闻资讯、留言反馈、我的、跳转到后台、购物车等功能。通过这些功能模块的设计，基本上实现了整个高校校园点餐系统的过程。
研究背景
以往的高校校园点餐系统相关信息管理，都是工作人员手工统计。这种方式不但时效性低，而且需要查找和变更的时候很不方便。随着科学的进步，技术的成熟，计算机信息化也日新月异的发展，社会也已经深刻的认识，计算机功能非常的强大，计算机已经进入了人类社会发展的各个领域，并且发挥着十分重要的作用。本系统利用网络沟通、计算机信息存储管理，有着与传统的方式所无法替代的优点。比如计算检索速度特别快、可靠性特别高、存储容量特别大、保密性特别好、可保存时间特别长、成本特别低等。在工作效率上，能够得到极大地提高，延伸至服务水平也会有好的收获，有了网络，在线高校校园点餐系统的各方面的管理更加科学和系统，更加规范和简便。
关键技术
JSP(Java脚本页面)是Sun和许多参与建立的公司所提倡的动态web技术。将Java程序添加到传统的web页面HTML文件(*)。htm,*。Html)。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
高校校园点餐系统，在系统首页可以查看首页、食堂菜单、新闻资讯、留言反馈、我的、跳转到后台、购物车等内容。管理员登录进入高校校园点餐系统可以查看个人中心、用户管理、食堂管理、食堂菜单管理、菜系分类管理、消息留言管理、留言板管理、系统管理、订单管理等信息。食堂登录进入高校校园点餐系统可以查看个人中心、食堂菜单管理、菜系分类管理、消息留言管理、订单管理等内容。用户登录进入高校校园点餐系统可以查看个人中心、消息留言管理、我的收藏管理、订单管理等内容。
系统测试
系统开发的最后一个步骤就是系统测试，系统测试也是整个系统十分重要的一个环节，测试的好坏关系到产品的发展。用户对系统的质量、性能和可靠性等需求就要通过测试来实现。测试过程要必须遵循严谨性、完善性、规范性的原则，测试的主要目的就是看看在系统运行中，是否会出现bug，然后对出现的bug进行调试，直到程序完美运行。但是系统的测试只能尽可能的减少bug，理论上来说是无法达到消除bug。但是bug越少，系统出错的几率就越低，用户使用起来也更方便、更安全。
结论
本系统通过对JSP和Mysql数据库的简介，从硬件和软件两反面说明了高校校园点餐系统的可行性，本文结论及研究成果如下：实现了JSP与Mysql相结合构建的高校校园点餐系统，网站可以响应式展示。通过本次高校校园点餐系统的研究与实现，我感到学海无涯，学习是没有终点的，而且实践出真知，只有多动手才能尽快掌握它，经验对系统的开发非常重要，经验不足，就难免会有许多考虑不周之处。比如要有美观的界面，更完善的功能，才能吸引更多的用户。
（可运行源码+sql文件+文档）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4614178e011cd3f83334ebdd9c9ed4f8/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(007)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
13、pandas.ExcelWriter类
13-1、语法
13-2、参数
13-3、功能
13-3-1、创建和写入Excel文件
13-3-2、自定义工作表
13-3-3、支持多种引擎
13-3-4、样式和格式化
13-3-5、处理已存在的工作表
13-4、返回值
13-5、说明
13-6、用法
13-6-1、数据准备
13-6-2、代码示例
13-6-3、结果输出
14、pandas.read_json函数
14-1、语法
14-2、参数
14-3、功能
14-4、返回值
14-5、说明
14-6、用法
14-6-1、数据准备
14-6-2、代码示例
14-6-3、结果输出 15、pandas.json_normalize函数
15-1、语法
15-2、参数
15-3、功能
15-4、返回值
15-5、说明
15-6、用法
15-6-1、数据准备
15-6-2、代码示例
15-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 13、pandas.ExcelWriter类 13-1、语法 # 13、pandas.ExcelWriter类 ExcelWriter(path: 'FilePath | WriteExcelBuffer | ExcelWriter', engine: 'str | None' = None, date_format: 'str | None' = None, datetime_format: 'str | None' = None, mode: 'str' = 'w', storage_options: 'StorageOptions | None' = None, if_sheet_exists: 'ExcelWriterIfSheetExists | None' = None, engine_kwargs: 'dict | None' = None) -&gt; 'Self' Class for writing DataFrame objects into excel sheets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4614178e011cd3f83334ebdd9c9ed4f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84bed7c213a39b9d8efe2dbbc324a29/" rel="bookmark">
			常见的Java运行时异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的Java运行时异常 1、ArithmeticException（算术异常）2、ClassCastException （类转换异常）3、IllegalArgumentException （非法参数异常）4、IndexOutOfBoundsException （下标越界异常）5、NullPointerException （空指针异常）6、SecurityException （安全异常） 💖The Begin💖点点关注，收藏不迷路💖 在Java编程中，异常处理是一个至关重要的部分。它允许我们在程序运行时检测和处理错误条件，以确保程序的稳定性和可靠性。在Java中，异常被分为两大类：检查异常（checked exceptions）和运行时异常（runtime exceptions）。运行时异常是那些不需要在代码中显式捕获的异常，它们通常在运行时由JVM自动抛出。
以下是几种常见的Java运行时异常：
1、ArithmeticException（算术异常） ArithmeticException是当算术运算发生错误时抛出的异常，比如除以零。
int a = 10; int b = 0; int c = a / b; // 这会抛出ArithmeticException，因为除数不能为零 2、ClassCastException （类转换异常） ClassCastException是当试图将对象强制转换为不兼容的类时抛出的异常。
Object obj = "Hello"; Integer i = (Integer) obj; // 这会抛出ClassCastException，因为obj不是Integer类型 3、IllegalArgumentException （非法参数异常） IllegalArgumentException是当向方法传递不合法或不适当的参数时抛出的异常。虽然这不是一个标准的运行时异常（它实际上是一个检查异常的超类RuntimeException的子类），但它通常在运行时被抛出，因此也经常被归类为运行时异常。
public void printNumber(int number) { if (number &lt; 0) { throw new IllegalArgumentException("Number cannot be negative"); } System.out.println(number); } 4、IndexOutOfBoundsException （下标越界异常） IndexOutOfBoundsException是当访问数组、字符串或集合的非法索引时抛出的异常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b84bed7c213a39b9d8efe2dbbc324a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97117035a4547065dd0ebc532c4e311/" rel="bookmark">
			mysql signed unsigned zerofill详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 灵感来源 mysql中有符号signed，无符号unsigned与零填充zerofill
UNSIGNED 无符号UNSIGNED是一个属性，你可以在创建或修改表时为整数类型的列指定它。无符号属性意味着该列只能存储非负整数（0和正整数），而不是默认的有符号整数，后者可以存储负数、零和正数。
例如，如果你定义一个列为INT UNSIGNED，那么这个列就不能存储负数。相比之下，一个普通的INT类型的列（默认是有符号的）可以存储从-2147483648到2147483647的整数。而INT UNSIGNED类型的列可以存储从0 到 4294967295的整数。
使用无符号类型的好处是它可以扩大正数的存储范围，因为它不需要为负数分配空间。这在某些情况下非常有用，比如当你知道数据永远不会是负数时（例如年龄、计数器或其他只能是正的度量）。
下面是一个创建无符号列的例子：
CREATE TABLE person ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, age TINYINT UNSIGNED NOT NULL ); 在这个例子中，id列是一个无符号整数，并且是自动递增的主键。age列是一个无符号的TINYINT，意味着它只能存储从0到255的整数。如果尝试插入一个负数到无符号列中，MySQL会产生一个错误或将负数转换为最接近的有效值（通常是0）。
类型大小无符号范围有符号范围TINYINT1 字节(-128，127)(0，255) 小整数值SMALLINT2 字节(-32 768，32 767)(0，65 535) 大整数值MEDIUMINT3 字节(-8 388 608，8 388 607)(0，16 777 215) 大整数值INT或INTEGER4 字节(-2 147 483 648，2 147 483 647)(0，4 294 967 295) 大整数值 zerofill 当插入mysql中该字段的值的长度小于定义的长度时，会在数值前面补全相应数据的0。
比较常用的应该是月份或日期前补0，还是整形数字不是字符串。
CREATE TABLE `t1` ( `year` year(4) DEFAULT NULL, `month` int(2) unsigned zerofill DEFAULT NULL, `day` int(2) unsigned zerofill DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8;``` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc9a53b6e0b696393eab954014571b4/" rel="bookmark">
			LeetCode热题100刷题8：54. 螺旋矩阵、73. 矩阵置零、48. 旋转图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		54. 螺旋矩阵 class Solution { public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; vec; if(matrix.empty()) return vec; int left=0; int right = matrix[0].size()-1; int up=0; int down = matrix.size()-1; while(true) { for(int i=left;i&lt;=right;++i) { vec.push_back(matrix[up][i]); } up++; if(up&gt;down) break; for(int i=up;i&lt;=down;i++) { vec.push_back(matrix[i][right]); } right--; if(right&lt;left)	break; for(int i=right;i&gt;=left;i--) { vec.push_back(matrix[down][i]); } down--; if(down&lt;up)	break; for(int i=down;i&gt;=up;i--) { vec.push_back(matrix[i][left]); } left++; if(left&gt;right)	break; } return vec; } }; 73. 矩阵置零 class Solution { public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int flag0 = 1; for(int i=0 ; i&lt;matrix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dc9a53b6e0b696393eab954014571b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86027297d0f8e26fd56a7ecc599a1310/" rel="bookmark">
			Camera Raw：编辑 - 校准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Camera Raw “编辑”模块中的校准 Calibration面板设计初衷是校准相机所采集的 R、G、B 色彩信息，使相机的 RGB 色域范围尽可能与标准 RGB 色域范围重合。不过，现在多用于创意调色。通过调整红、绿、蓝三个原色的色相和饱和度，以及阴影的色调，改变照片的整体色彩平衡和表现。
◆ ◆ ◆
使用方法与技巧
1、Camera Raw 的处理版本
不同的版本提供了不同的色调控制以及降噪功能，这可能会引起同一面板中的参数和功能有所不同。
一般选用有更多改进和更多功能的最新版本。
2、创意调色
现代相机采集色彩的能力基本上都可以达到指定的色域空间的要求，因此，“标准”面板可能失去了它纠正颜色偏差的功能。不过，我们可将其应用到后期调色上，比如增强图像的风格效果或者进行创意调整。
上图给出了原色色相条两端的颜色。
“色相”滑块滑向谁，颜色就偏向谁，此色就变多，它的互补色也变多。
指示条另一侧的颜色变少且饱和度降低。
“饱和度”滑块向右增加饱和度，其中该原色的饱和度增加最多，其它颜色的饱和度增加的量依次减少，该原色的互补色的饱和度增量最少。
“饱和度”滑块向左减少饱和度，其中该原色的饱和度减少最多，其它颜色的饱和度依次减少，该原色的互补色的饱和度变化最少。
请参阅：
《Camera Raw：校准面板（应用篇）》
◆ ◆ ◆
面板参数说明
处理版本
Process
选择 Camera Raw 调整和渲染照片的技术版本。
默认为已经安装好的最新版本。
阴影
Shadows
调整照片阴影部分的色调，使其偏向绿色或洋红色。
不同的镜头和传感器在拍摄时，可能会在阴影区域引入轻微的色偏，偏绿色或偏紫色。可以使用此项手动校正这些色偏，确保阴影部分的色彩更加准确。
在一些光照条件下，尤其是在混合光源环境中，阴影部分的颜色可能会受到影响，导致色偏。对阴影区域进行细微的色调校正，保证照片整体的色彩平衡。
除了技术校正，“阴影”参数还可以用于创造性的调色。
例如，通过故意使阴影区域偏绿或偏紫，可以实现特定的艺术效果，增强照片的氛围和情感表达。
红原色
Red Primary
调整红原色的色相 Hue和饱和度 Saturation。
绿原色
Green Primary
调整绿原色的色相 Hue和饱和度 Saturation。
蓝原色
Blue Primary
调整蓝原色的色相 Hue和饱和度 Saturation。
请参阅：
《Camera Raw：校准面板（原理篇）》
“点赞有美意，赞赏是鼓励”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d594e5667c94db998b3e8060f2801dc/" rel="bookmark">
			黑客技术大纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑客技术是一个广泛而复杂的领域，涵盖了众多的知识和技能。
首先，从攻击手段来看，常见的有以下几种：
1. 网络扫描与嗅探：使用工具扫描目标网络，以发现开放的端口、服务和潜在的漏洞。嗅探技术则用于捕获网络中的数据包，获取敏感信息。
2. 漏洞利用：通过发现软件、操作系统或网络协议中的安全漏洞，攻击者可以执行未经授权的操作，如获取系统控制权、窃取数据等。
3. 恶意软件编写：包括病毒、木马、蠕虫等的开发。这些恶意软件可以用于窃取信息、破坏系统、控制目标设备等。
4. 密码攻击：尝试破解用户的密码，方法包括暴力破解、字典攻击、社会工程学获取密码等。
5. SQL 注入攻击：针对网站数据库的攻击方式，通过在输入字段中插入恶意的 SQL 语句，获取或修改数据库中的数据。
6. DDoS 攻击：通过控制大量的傀儡机向目标服务器发送海量的请求，使其无法正常服务合法用户。
在技术层面，黑客需要掌握以下关键技术：
1. 编程语言：如 Python、C、C++等，用于编写攻击工具和脚本。
2. 操作系统：精通多种操作系统，如 Windows、Linux 等，了解其内核、系统服务、权限管理等。
3. 网络知识：包括网络拓扑、IP 地址分配、路由原理、各种网络协议等。
4. 数据库：熟悉常见的数据库系统，如 MySQL、Oracle 等，以便进行数据操作和攻击。
5. 加密与解密：理解加密算法，能够破解加密数据或绕过加密保护。
然而，需要明确的是，黑客技术并非仅仅用于非法活动。在合法合规的范畴内，黑客技术被称为“白帽黑客技术”，用于帮助企业和组织发现和修复安全漏洞，提高网络和系统的安全性。
总之，黑客技术是一把双刃剑，它的应用取决于使用者的意图和道德准则。在任何情况下，利用黑客技术进行非法活动都是不被允许的，会受到法律的制裁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d884eb939e815d8c061a92b95f58c6e/" rel="bookmark">
			kafka中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Kafka RocketMQ概述 RabbitMQ概述 ActiveMQ概述 ZeroMQ概述 MQ对比选型 适用场景-从公司基础建设力量角度出发 适用场景-从业务场景出发 Kafka配置介绍 运行Kafka 安装ELAK 配置EFAK EFAK界面 KAFKA常用术语 Kafka常用指令 Kafka中消息读取 单播消息 group.id 相同 多播消息 group.id不同 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a194a40b475f9b47ae2e1ddb09cc1b36/" rel="bookmark">
			贪心算法-以高校教师信息管理系统为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.贪心算法介绍 1.算法思路 贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一 步都要确保能获得局部最优解。每一步只考虑一 个数据，其选取应该满足局部优化的条件。若下 一个数据和部分最优解连在一起不再是可行解时， 就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。 贪心算法一般按如下步骤进行： ①建立数学模型来描述问题 。
②把求解的问题分成若干个子问题 。
③对每个子问题求解，得到子问题的局部最优解 。
④把子问题的解局部最优解合成原来解问题的一个解 。
贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解。虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪心算法不要回溯 [2]。
2.代码介绍 // 定义一个静态方法，用于分配教学任务，需要TeacherService, TitleService, PositionService三个服务层对象 private static void assignTeachingTasks(TeacherService teacherService, TitleService titleService, PositionService positionService) { // 从TeacherService获取所有教师的列表 List&lt;Teacher&gt; teachers = teacherService.getAllTeachers(); // 如果教师列表为空，打印消息并返回 if (teachers == null || teachers.isEmpty()) { System.out.println("没有教师信息！"); return; } // 创建一个优先队列，用于根据教师的职称和职务优先级排序 PriorityQueue&lt;Teacher&gt; priorityQueue = new PriorityQueue&lt;&gt;((t1, t2) -&gt; { // 通过TitleService获取教师1的职称 Title title1 = titleService.getTitleById(t1.getTitleId()); // 通过TitleService获取教师2的职称 Title title2 = titleService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a194a40b475f9b47ae2e1ddb09cc1b36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc2dbc6a63e460391ab8fb1100b8311/" rel="bookmark">
			C&#43;&#43;笔试强训2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、选择题二、编程题 一、选择题 和笔试强训1的知识点考的一样，因为输出的是double类型所以后缀为f,m.n对其30个字符所以m是30，精度是4所以n是4，不加符号默认是右对齐，左对齐的话前面加-号，所以答案是-30.4f，答案选c
%s：就是字符串的转换说明符%ms：输出字符串宽度为m，如果字符串本身实际宽度大于m，那么就用字符串的实际宽度。如果字符串的实际宽度小于m，则左补空格。可以理解成m前面有个省略了的＋号，所以字符串右对齐；%-ms：规则基本上面一样，不一样的是字符串左对齐，右补空格；%m.ns;输出宽度占m，但是只取字符串中左端的n个字符。这n个字符排列在m宽度的右侧，如果n小于m则左补空格，如果n大于m，那么m失效，字符的输出宽度就是n。%-m.ns;规则和上面基本一样，不一样的地方在于，如果n小于m那么需要左对齐，右补空格。 本题主要考察指针常量和常量指针的概念。可以通过观察const和*的位置来区分指针常量和常量指针
如果const在的左边比如：const int p或者int const p都表示常量指针
如果const在的右边比如：int* const p表示指针常量
对上述题目进行分析(1)是常量指针，不能修改它指向的数据，但能修改指向的地址。(2)也是常量指针，因为const在*的左边。(3)修改了p2的指向，常量指针可以修改指向。(4)是指针常量，不能修改指针的指向的地址，但可以修改指向的数据。(5)修改了指针常量p3指向的数据，没问题。(6)修改了常量指针p2指向的数据，错误。(7)修改了指针常量p3指向的地址，错误。
故（6）（7）错误，本题选C。
指针常量（Pointer to Constant）
指针常量指的是指针的值（即它所指向的地址）不能被修改，但是通过这个指针可以修改它所指向的数据。指针常量通常用const关键字来修饰指针本身，而不是指针所指向的数据类型。
int a = 10; int *const ptr = &amp;a; // ptr 是一个指针常量，指向整数 a // *ptr = 20; // 这是合法的，因为 ptr 指向的数据（a）是可以被修改的 // ptr = &amp;b; // 这是非法的，因为 ptr 是一个指针常量，它的值（即它所指向的地址）不能被修改 常量指针（Constant Pointer）
常量指针指的是通过该指针不能修改它所指向的数据，但是指针的值（即它所指向的地址）是可以被修改的。常量指针通常用const关键字来修饰指针所指向的数据类型，而不是指针本身。
int a = 10; const int *ptr = &amp;a; // ptr 是一个常量指针，指向整数 a //该语句等价与下面这条语句，都表示常量指针 //int const *ptr = &amp;a; // ptr = &amp;b; // 这是合法的，因为 ptr 的值（即它所指向的地址）是可以被修改的 // *ptr = 20; // 这是非法的，因为 ptr 是一个常量指针，不能通过它来修改它所指向的数据 两者结合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cc2dbc6a63e460391ab8fb1100b8311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730b4f3b4c2e16169ec51bc038a8428a/" rel="bookmark">
			[数据结构] 基于交换的排序 冒泡排序&amp;&amp;快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：[数据结构] 基于交换的排序 冒泡排序&amp;&amp;快速排序
@水墨不写bug
（图片来源于网络） 目录
（一）冒泡排序
优化后实现：
（二）快速排序
I、实现方法： （1）hoare法
hoare法实现快排：
（2）挖坑法
挖坑法实现：
（3）双指针法 双指针法实现： II、快速排序复杂度分析：
比较完备的快速排序实现如下：
正文开始：
（一）冒泡排序 时间复杂度：O（N^2）
空间复杂度：O（1）
特点：数组接近有序时，可通过优化来提高效率。
稳定性：稳定
冒泡排序：
基本思想：大数下沉，小数上浮。
实现思路：从内循环到外循环，从一趟到多趟。
冒泡排序通过两层循环来实现，内层循环实现其中的一趟遍历，在一趟的遍历中，需要注意要控制好左右区间边界，冒泡排序的实现方式是多样的，无论用何种实现方式，最主要的是控制好边界，以及内外层循环的衔接；以下是一种冒泡排序的写法：
void BubbleSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int j = 0; j &lt; n - 1; ++j) { for (int i = 0; i &lt; n - 1 - j; ++i) { if (nums[i] &gt; nums[i + 1]) { ::swap(nums[i], nums[i + 1]); } } } } 优化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730b4f3b4c2e16169ec51bc038a8428a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba699d79490d3b5416ac7977d4f94c6/" rel="bookmark">
			Linux多进程和多线程(七)进程间通信-信号量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程间通信之信号量 资源竞争 多个进程竞争同一资源时，会发生资源竞争。
资源竞争会导致进程的执行出现不可预测的结果。
临界资源 不允许同时有多个进程访问的资源, 包括硬件资源 (CPU、内存、存储器以及其他外
围设备) 与软件资源(共享代码段、共享数据结构)
临界区 多个进程共享的资源被称为临界资源，
这些资源被保护在一个临界区中，
只有进入临界区的进程才能访问临界资源。
信号量 信号量是一种进程间通信机制，用于协调对共享资源的访问。
多进程对stdout资源的竞争
//多进程对stdout资源的竞争 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; int main(){ pid_t cpid; cpid = fork();//创建子进程 if(cpid &lt; 0){ printf("fork error\n");//fork失败 exit(EXIT_FAILURE);//EXIT_FAILURE表示程序运行失败 } else if(cpid == 0){//子进程 while(1){ printf("------------------------\n"); printf("C Start.\n"); sleep(1); printf("C End.\n"); printf("------------------------\n"); } } else{//父进程 while(1){ printf("------------------------\n"); printf("P Start.\n"); sleep(1); printf("P End.\n"); printf("------------------------\n"); } wait(NULL); //等待子进程结束 } return 0; } 代码的输出混乱:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba699d79490d3b5416ac7977d4f94c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e11f46ce80a971ed77a8830e6e41b590/" rel="bookmark">
			用SpringBoot打造坚固防线：轻松实现XSS攻击防御
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇博客中，我们将深入探讨如何使用SpringBoot有效防御XSS攻击。通过结合注解和过滤器的方式，我们可以为应用程序构建一个强大的安全屏障，确保用户数据不被恶意脚本所侵害。
目录 什么是XSS攻击？SpringBoot中的XSS防御策略使用注解实现XSS防御使用过滤器实现XSS防御结合注解与过滤器的最佳实践总结与展望 1. 什么是XSS攻击？ 跨站脚本攻击（Cross-Site Scripting，简称XSS）是一种常见且危险的Web安全漏洞。在XSS攻击中，攻击者通过在网页中注入恶意脚本代码，使这些代码在其他用户的浏览器中执行，从而达到窃取用户信息、劫持用户会话、欺骗用户等目的。XSS攻击通常分为三种类型：存储型（Stored XSS）、反射型（Reflected XSS）和基于DOM的XSS（DOM-based XSS）。
1.1 存储型XSS 存储型XSS攻击发生在恶意脚本被永久存储在目标服务器上的情况下。例如，攻击者在一个社交媒体平台的评论区发布了一段包含恶意脚本的评论，这段评论会被存储在服务器的数据库中。当其他用户浏览该评论时，恶意脚本会在用户的浏览器中执行，导致用户信息泄露或其他恶意行为。存储型XSS通常被认为是最危险的一种XSS攻击，因为它可以影响到所有访问该页面的用户。
1.2 反射型XSS 反射型XSS攻击发生在恶意脚本通过URL参数立即反射回网页响应中。这类攻击通常通过诱导用户点击包含恶意脚本的链接来实现。例如，攻击者构造一个包含恶意脚本的URL，并通过电子邮件或社交媒体发送给受害者。当受害者点击链接时，恶意脚本会在用户的浏览器中执行。这种攻击只在用户点击链接时有效，因此其影响范围相对较小。
1.3 基于DOM的XSS 基于DOM的XSS攻击发生在客户端脚本通过修改页面的DOM（文档对象模型）来执行恶意代码，而不涉及服务器的响应。例如，攻击者可以通过操控JavaScript代码来改变页面中的某些元素，从而执行恶意脚本。与存储型和反射型XSS不同，基于DOM的XSS攻击不依赖于服务器端的响应，而是直接在浏览器中进行。
1.4 XSS攻击的危害 XSS攻击的危害主要包括但不限于以下几点：
盗取用户数据：攻击者可以窃取用户的Cookies、会话令牌等敏感信息，从而伪装成用户进行恶意操作。伪造用户请求：攻击者可以利用XSS脚本伪造用户的请求，进行未授权的操作，如转账、修改个人信息等。传播恶意软件：攻击者可以通过XSS脚本将恶意软件分发给访问网页的用户，进一步扩大攻击范围。欺骗用户：攻击者可以通过XSS脚本修改网页内容，欺骗用户输入敏感信息或下载恶意文件。 1.5 防御XSS攻击的必要性 由于XSS攻击的危害极大，防御XSS攻击是Web应用安全的重点之一。在实际开发中，我们需要采取多种措施来防御XSS攻击，包括但不限于：
输入验证和输出编码：对用户输入进行严格验证，并对输出进行适当的编码，防止恶意脚本执行。使用安全的库和框架：使用已经经过安全审计的库和框架，避免手动处理复杂的安全逻辑。内容安全策略（CSP）：通过配置内容安全策略，限制浏览器加载的资源类型和来源，减少攻击面。 在接下来的章节中，我们将详细介绍如何在SpringBoot中使用注解和过滤器来实现XSS攻击防御，为你的Web应用构建坚固的安全防线。
2. SpringBoot中的XSS防御策略 SpringBoot作为一个功能强大的微服务框架，不仅简化了Java应用的开发流程，还在安全方面提供了丰富的支持。防御XSS攻击是Web安全中的重要环节，SpringBoot通过多种方式帮助开发者构建安全的Web应用。下面，我们将探讨几种在SpringBoot中实现XSS防御的策略，包括输入验证、输出编码、自定义注解、过滤器、以及内容安全策略（CSP）。
2.1 输入验证 输入验证是防御XSS攻击的第一道防线。通过严格验证用户输入，确保其符合预期格式，可以有效防止恶意脚本的注入。SpringBoot提供了多种验证机制，包括注解和自定义验证逻辑。
示例代码：
java
import javax.validation.constraints.NotEmpty; import javax.validation.constraints.Pattern; public class UserInput { @NotEmpty(message = "Input cannot be empty") @Pattern(regexp = "^[a-zA-Z0-9]*$", message = "Input contains invalid characters") private String userInput; // getters and setters } 在控制器中，我们可以直接使用这些注解来验证输入参数：
java
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e11f46ce80a971ed77a8830e6e41b590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721b66d1143a6d54cf933e60f6f85317/" rel="bookmark">
			数据结构之“栈”（全方位认识）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌹个人主页🌹：喜欢草莓熊的bear
🌹专栏🌹：数据结构
前言 栈是一种数据结构，具有" 后进先出 "的特点 或者也可见说是 ” 先进后出 “。大家一起加油吧冲冲冲！！
目录
前言
一、栈
1.1栈的概念和结构
1.2栈的实现
1.2.1栈的结构体定义
1.2.2初始化和销毁
1.2.3入栈
1.2.4出栈
1.2.5获取栈顶元素
1.2.6获取栈中的有效个数
1.2.7判空
1.3 代码测试
1.4 头文件
总结
一、栈 1.1栈的概念和结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。 进行数据插入和删除操作的一端 称为栈顶，另一端称为栈底。 栈中的数据元素遵守后进先出 LIFO （ Last In First Out ）的原则。 这个栈的数据结构在我们生活中很像羽毛球桶
压栈：栈的插入操作叫做进栈 / 压栈 / 入栈， 入数据在栈顶 。 出栈：栈的删除操作叫做出栈。 出数据也在栈顶 。 除了" 先进后出 "这个特点还有" 入数据和出数据都在栈顶 " 下面是我画的简易图帮助大家理解栈是一个怎么样的数据结构。 1.2栈的实现 栈的实现一般可以使用 数组或者链表实现 ，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。 我们这里实现的是动态栈的结构，因为静态栈实际中一般运用不到。
先给大家看一下栈的结构体定义和一些功能。
//静态栈 typedef int STDataType; #define N 10 typedef struct Stack { STDataType _a[N]; int _top; // 栈顶 }Stack; typedef int STDataType; //动态栈 typedef struct Stack { STDataType* a; int top;//这里的top和顺序表的size相似的都是指有效元素的下一个数据。 int capacity; }ST; //栈的实现是通过数组所以只需要传一级指针。 //栈的初始化和销毁 void STInit(ST* pst); void STDestory(ST* pst); //入栈和出栈 void STPush(ST* pst, STDataType x); void STPop(ST* pst); //获取栈数据 STDataType STTop(ST* pst); //栈的判空 bool STEmpty(ST* pst); //栈的数据个数 int STSize(ST* pst); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/721b66d1143a6d54cf933e60f6f85317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87888de3b80b46ed24533dd47303702e/" rel="bookmark">
			如何在 PostgreSQL 中实现高效的分页查询，特别是在数据量巨大的情况下？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、常见的分页查询方法二、性能问题及分析三、解决方案四、示例代码及解释五、性能比较和测试六、总结 如何在 PostgreSQL 中实现高效的分页查询
在处理大型数据集时，高效的分页查询是数据库应用中常见的需求。PostgreSQL 提供了几种方法来实现分页查询，本文将详细探讨如何在 PostgreSQL 中实现高效的分页查询，特别是在数据量巨大的情况下，并提供相应的解决方案和示例代码。
一、常见的分页查询方法 使用 LIMIT 和 OFFSET
这是 PostgreSQL 中最基本的分页查询方式。LIMIT 用于指定每页返回的行数，OFFSET 用于指定跳过的行数。 SELECT * FROM your_table LIMIT 10 OFFSET 20; 上述查询将跳过前 20 行，然后返回接下来的 10 行数据。
然而，当 OFFSET 值较大时，这种方法的性能可能会变得很差，因为它需要扫描和丢弃前面所有的行。
使用索引优化
在分页查询中，为相关列创建索引可以显著提高性能。通常，对经常用于排序和筛选的列创建索引。 CREATE INDEX index_name ON your_table(column_name); 使用窗口函数 ROW_NUMBER()
通过 ROW_NUMBER() 函数为每行分配一个行号，然后根据行号进行分页查询。 WITH numbered_rows AS ( SELECT *, ROW_NUMBER() OVER (ORDER BY column_name) AS row_num FROM your_table ) SELECT * FROM numbered_rows WHERE row_num BETWEEN 21 AND 30; 这种方法在处理大型数据集的分页时，性能通常比直接使用 LIMIT 和 OFFSET 更好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87888de3b80b46ed24533dd47303702e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2524a6db10ab46c0836e871fe9059e0/" rel="bookmark">
			如何在 PostgreSQL 中实现跨数据库的关联查询？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引言二、PostgreSQL 中的数据库和模式三、实现跨数据库关联查询的方法四、`dblink` 示例详解五、设置 `search_path` 示例详解六、注意事项七、总结 如何在 PostgreSQL 中实现跨数据库的关联查询
一、引言 在 PostgreSQL 中，通常情况下的关联查询是在同一个数据库的不同表之间进行的。然而，在某些复杂的应用场景中，可能需要实现跨数据库的关联查询，以整合来自不同数据库的数据。本文将详细探讨如何在 PostgreSQL 中实现这一需求，并通过示例代码进行说明。
二、PostgreSQL 中的数据库和模式 在深入探讨跨数据库查询之前，有必要先了解 PostgreSQL 中的数据库和模式的概念。
一个 PostgreSQL 服务器可以包含多个数据库，每个数据库又是由多个模式组成。模式类似于一个命名空间，可以包含表、视图、函数等数据库对象。
三、实现跨数据库关联查询的方法 （一）使用 dblink 扩展
安装 dblink 扩展
dblink 是一个 PostgreSQL 扩展，用于在数据库之间建立连接并执行查询。可以使用以下命令安装：
CREATE EXTENSION dblink; 使用 dblink 进行跨数据库查询
下面是一个使用 dblink 进行跨数据库查询的示例：
假设我们有两个数据库：db1 和 db2 ，在 db1 中有表 table1 ，在 db2 中有表 table2 ，并且两个表都有 id 列。
在 db1 中执行以下查询：
SELECT * FROM dblink('dbname=db2', 'SELECT * FROM table2') AS t2(id INT) JOIN table1 t1 ON t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2524a6db10ab46c0836e871fe9059e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b179a751c1cc00a497b0d3b318428040/" rel="bookmark">
			【python 报错已解决】This error originates from a subprocess, and is likely not a problem with pip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬 鸽芷咕：个人主页 🔥 个人专栏: 《C++干货基地》《粉丝福利》 ⛺️生活的理想，就是为了理想的生活! 文章目录 引言一、问题描述1.1 报错示例1.2 报错分析1.3 解决思路 二、解决方法方法一：检查环境变量方法二：使用虚拟环境 三 总结： 引言 在开发过程中，我们经常会遇到来自子进程的错误，这些错误可能会让我们感到困惑，尤其是当它们看似与pip无关时。本文将带你深入探究这类错误的根源，并提供有效的解决方案。让我们一起看看如何解决这个特定的报错信息：“This error originates from a subprocess, and is likely not a problem with pip”。🔍
一、问题描述 当你在安装或更新Python包时，可能会遇到这样的错误信息。这通常发生在你的环境中有一些不兼容的依赖项或者你的pip版本不支持当前操作的时候。👩‍🔬
1.1 报错示例 $ pip install some-package Collecting some-package Downloading some_package-1.2.3-py2.py3-none-any.whl (123kB) |███████████████████████████████| 123kB 3.4MB/s Installing collected packages: some-package Successfully installed some-package-1.2.3 $ pip install some-package Collecting some-package Downloading some_package-1.2.3-py2.py3-none-any.whl (123kB) |███████████████████████████████| 123kB 3.4MB/s ERROR: This error originates from a subprocess, and is likely not a problem with pip.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b179a751c1cc00a497b0d3b318428040/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/186/">«</a>
	<span class="pagination__item pagination__item--current">187/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/188/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>