<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c95de40f113f9eee3a04a8294e9bd5/" rel="bookmark">
			汽车电子行业的“AUTOSAR”到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AUTOSAR (AUTomotive Open System ARchitecture) 是一种开放的软件架构标准，用于汽车电子系统的开发和管理。该标准旨在通过统一的硬件和软件接口，实现汽车电子系统的互操作性和可重用性，并促进不同的汽车制造商和零部件供应商之间的合作和交流。本文将介绍AUTOSAR标准的起源、结构和应用，并讨论它对于汽车行业的影响和前景。
一、AUTOSAR标准的起源 随着汽车电子系统的不断发展，越来越多的汽车制造商和零部件供应商开始意识到，需要一种通用的软件架构标准来规范汽车电子系统的开发和管理。在这种背景下，AUTOSAR标准应运而生。
AUTOSAR标准的起源可以追溯到2003年，当时德国汽车制造商宝马、戴姆勒-克莱斯勒和福特汽车公司联合发起了一个名为“ARTIST”的研究项目。该项目的目标是开发一种通用的汽车电子系统架构，以提高不同制造商之间的互操作性和合作性。
在ARTIST项目的基础上，欧洲联盟启动了一个名为“ARTEMIS”的大型研究计划，旨在推动欧洲汽车电子系统的创新和发展。AUTOSAR标准成为了ARTEMIS计划中的一个重要组成部分，并在2005年正式发布。
二、AUTOSAR标准的结构 AUTOSAR标准的结构包括以下三个层次：
1. 应用层 应用层是AUTOSAR标准中的最高层次，它定义了汽车电子系统的各种应用和功能，例如发动机控制、制动控制、车身电子系统和驾驶辅助系统等。应用层通过提供标准的API (Application Programming Interface) 接口，使得不同的应用程序能够互相连接和通信。
2. 基础软件层 基础软件层是AUTOSAR标准的中间层，它提供了一些通用的软件模块，用于处理与硬件和网络相关的底层操作。基础软件层包括以下几个模块：
（1）ECU (Electronic Control Unit) Abstraction：用于抽象不同的ECU硬件平台。
（2）Communication Stack：用于实现不同的通信协议，例如CAN (Controller Area Network)、FlexRay和Ethernet等。
（3）Memory Stack：用于管理不同类型的存储器，例如EEPROM (Electrically Erasable Programmable Read-Only Memory)和Flash等。
（4）Diagnostic Stack：用于实现诊断功能，例如故障码诊断和参数配置等。
（5）Operating System：用于管理多任务操作系统和内存管理等。
3. 基础设施层 基础设施层是AUTOSAR标准的最底层，它提供了一些基本的工具和功能，例如XML解析器、配置管理器和通用驱动器等。
AUTOSAR标准还定义了一些元模型和元模型元素，用于描述汽车电子系统的不同组件和模块之间的关系和依赖。元模型和元模型元素是AUTOSAR标准中的关键概念，用于实现不同汽车电子系统之间的互操作性和可重用性。
三、AUTOSAR标准的应用 AUTOSAR标准已经得到了广泛的应用，尤其是在汽车电子系统的开发和管理方面。AUTOSAR标准可以帮助汽车制造商和零部件供应商实现以下几个方面的优势：
1. 提高开发效率 AUTOSAR标准提供了一些通用的软件模块和工具，可以减少重复的开发工作，并提高开发效率。同时，AUTOSAR标准还提供了一些标准的接口和规范，可以帮助不同的汽车电子系统之间进行快速集成和测试。
2. 提高软件质量 AUTOSAR标准要求每个软件模块都必须经过严格的测试和验证，以确保其质量和可靠性。这有助于减少软件故障和缺陷，并提高汽车电子系统的稳定性和安全性。
3. 提高系统可重用性 AUTOSAR标准要求每个软件模块都必须具有良好的可重用性和兼容性，以便于不同的汽车电子系统之间进行共享和重用。这可以减少重复的开发工作，并降低系统的成本和复杂性。
4. 提高供应链协同性 AUTOSAR标准可以促进不同的汽车制造商和零部件供应商之间的合作和交流，以实现供应链的协同发展。AUTOSAR标准为汽车电子系统的开发和管理提供了统一的语言和规范，使得不同的汽车制造商和零部件供应商之间可以更加高效地合作和交流。
四、AUTOSAR标准的前景 随着汽车电子系统的不断发展和普及，AUTOSAR标准的应用前景也越来越广阔。未来，AUTOSAR标准将面临以下几个方面的发展：
1. 更加丰富的功能和应用场景 随着汽车电子系统的不断发展和普及，AUTOSAR标准将需要支持更加丰富的功能和应用场景，例如智能驾驶、车联网和智能交通等。AUTOSAR标准将需要不断更新和扩展，以适应不断变化的市场需求和技术发展。
2. 更加高效的开发和管理工具 AUTOSAR标准将需要更加高效的开发和管理工具，以提高开发效率和质量。未来，AUTOSAR标准将需要支持更加先进的开发和管理工具，例如云计算、人工智能和大数据分析等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5c95de40f113f9eee3a04a8294e9bd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5179f68ccbd6c7107c73dad038b61944/" rel="bookmark">
			BMS电池管理系统中的各种算法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BMS电池管理系统 是一种用于电池组中的单个电池管理的系统，以确保其安全性、寿命和性能。BMS系统通过采集电池信息并对其进行分析，以确保电池组的正常运行。在BMS电池管理系统中，涉及到了许多算法，包括最大功率点追踪算法、SOC计算算法、SOH评估算法等。在本文中，我们将详细探讨BMS电池管理系统中用到的算法。
在这里小猿只给大家做算法介绍，如果想要详细学习某种算法，可以自行百度。
1、最大功率点追踪算法 最大功率点追踪算法是一种用于优化太阳能电池板输出功率的算法。在BMS电池管理系统中，最大功率点追踪算法也被用于优化电池输出功率，以延长电池寿命和提高电池性能。该算法通常采用迭代法求解，在每次迭代中，计算当前电池组的输出功率并根据输出功率的变化调整电池组的工作状态，以找到最大功率点。
最大功率点追踪算法的核心是找到电池组输出功率与电池组工作状态之间的关系。在实际应用中，最大功率点追踪算法通常采用Perturb and Observe（P&amp;O）算法或Incremental Conductance（IC）算法。其中，P&amp;O算法是一种基于光强变化的算法，它通过改变电池电压并观察电池输出功率的变化，来寻找最大功率点。IC算法则是一种基于导数的算法，它通过计算电池电压和电池电流之间的导数来确定最大功率点。
2、SOC计算算法 SOC（State of Charge）是电池组中电池当前充电状态的指标。在BMS电池管理系统中，SOC计算算法被用于确定电池组的当前充电状态，以避免电池过充或欠充，延长电池寿命和提高电池性能。
在实际应用中，SOC计算算法通常采用开路电压法（OCV）或卡尔曼滤波器法进行计算。其中，OCV法是一种基于电池开路电压的计算方法，它通过测量电池组的开路电压来确定电池组的SOC。卡尔曼滤波器法则是一种基于状态估计的算法，它通过对电池组的充电和放电状态进行预测和校正，来估计电池组的SOC。
3、SOH评估算法 SOH（State of Health）是电池组的健康状况指标，它反映了电池组的寿命和性能。在BMS电池管理系统中，SOH评估算法被用于评估电池组的健康状况，以帮助用户了解电池组的剩余寿命和性能表现。
在实际应用中，SOH评估算法通常采用电化学阻抗谱法（EIS）或数学建模法进行评估。其中，EIS法是一种基于电化学阻抗谱的方法，它通过对电池组进行小信号扰动，测量电池组的电化学阻抗谱，并根据阻抗谱的变化来评估电池组的健康状况。数学建模法则是一种基于电池组的数学模型进行评估的方法，它通过建立电池组的数学模型，模拟电池组的工作过程，并根据模型的预测结果来评估电池组的健康状况。
4、充放电控制算法 充放电控制算法是BMS电池管理系统中的核心算法之一，它用于控制电池组的充放电过程，以确保电池组的安全性和寿命。在实际应用中，充放电控制算法通常采用PID控制器或模糊控制器进行控制。
其中，PID控制器是一种基于误差、积分和微分的控制器，它通过调整控制器的参数，使得电池组的充放电电流和电压稳定在设定值附近。模糊控制器则是一种基于模糊逻辑的控制器，它通过建立模糊规则和模糊推理，来实现电池组的充放电控制。
5、健康预警算法 健康预警算法是BMS电池管理系统中的另一种重要算法，它用于预测电池组的故障和寿命，以提前采取措施进行维护。在实际应用中，健康预警算法通常采用神经网络、遗传算法或支持向量机进行预测。
其中，神经网络是一种基于人工神经元的模型，它通过训练神经网络的权值和偏置，来实现电池组故障和寿命的预测。遗传算法则是一种基于自然选择适应度高的个体，不断迭代寻找最优解。支持向量机则是一种基于统计学习理论的模型，它通过构建最优的分类超平面，来实现电池组故障和寿命的预测。
6、优化算法 优化算法是BMS电池管理系统中的重要算法之一，它用于优化电池组的性能和寿命，以满足用户的需求。在实际应用中，优化算法通常采用遗传算法、粒子群算法或模拟退火算法进行优化。
其中，遗传算法是一种基于自然选择和遗传机制的优化算法，它通过模拟自然进化过程，不断迭代寻找最优解。粒子群算法则是一种基于群体智能的优化算法，它通过模拟鸟群飞行的过程，不断迭代寻找最优解。模拟退火算法则是一种基于模拟退火过程的优化算法，它通过模拟金属退火的过程，不断迭代寻找最优解。
7、数据处理算法 数据处理算法是BMS电池管理系统中的另一种重要算法，它用于处理电池组的数据，以提取有用的信息和特征。在实际应用中，数据处理算法通常采用滤波算法、降维算法或特征提取算法进行处理。
其中，滤波算法是一种基于数字信号处理的算法，它通过对电池组的信号进行滤波，去除噪声和干扰，提取有用的信息。降维算法则是一种基于数据挖掘的算法，它通过降低数据的维度，减少数据量和复杂度，提高数据的可处理性和效率。特征提取算法则是一种基于模式识别的算法，它通过提取数据的特征，识别出数据中的模式和规律，从而实现数据的分类和识别。
结论 BMS电池管理系统是一种重要的电池管理技术，它通过对电池组的监测、控制和管理，提高了电池组的安全性、可靠性和寿命。其中，BMS电池管理系统中所采用的各种算法，包括状态估计算法、SOC估计算法、SOH评估算法、充放电控制算法、健康预警算法、优化算法和数据处理算法等，都起着重要的作用。
在未来，随着电动汽车、储能系统和新能源的快速发展，BMS电池管理系统将会越来越受到关注和重视。因此，对于BMS电池管理系统中的各种算法，还需要不断地进行研究和优化，以适应不断变化的市场需求和技术趋势。
同时，还需要进一步完善BMS电池管理系统的硬件和软件，提高其性能和可靠性。在硬件方面，需要开发更加精密、稳定和可靠的电池监测和控制设备，以提高BMS电池管理系统的精度和可靠性。在软件方面，则需要进一步优化BMS电池管理系统的算法和数据处理能力，以提高其效率和性能。
总之，BMS电池管理系统是电池组管理的重要技术手段，它对于提高电池组的安全性、可靠性和寿命具有重要作用。通过对BMS电池管理系统中的各种算法进行深入研究和优化，可以不断提升其性能和可靠性，为电动汽车、储能系统和新能源的发展提供更加可靠和高效的电池管理方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57631f1c76b94c412dcc3d1ffe16d10b/" rel="bookmark">
			和日期相关的代码和bug——一道力扣题中的小发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Day of the Week
题目大意
常规方法
Python代码
Golang代码
C++代码
基姆拉尔森公式
Python代码
Golang代码
C++代码
使用库函数
Python代码
Golang代码
C++代码
Day of the Week Given a date, return the corresponding day of the week for that date.
The input is given as three integers representing the day , month and year respectively.
Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"} .
Example 1:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57631f1c76b94c412dcc3d1ffe16d10b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d5938ae03705a00b306513b4dfa7bd/" rel="bookmark">
			CSS字体样式（font）[详细]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS字体样式（font） 1. font-family2. font-style3. font-weight4. font-size5. font-variant6. font CSS 中提供了一系列用于设置文本字体样式的属性，比如更改字体，控制字体大小和粗细等等。 font-family：设置字体； font-style：设置字体的风格，例如倾斜、斜体等； font-weight：设置字体粗细；
font-size：设置字体尺寸； font-variant：将小写字母转换为小型大写字母；
font-stretch：对字体进行伸缩变形（使用较少，并且主流浏览器都不支持）；
font：字体属性的缩写，可以在一个声明中设置多个字体属性。
1. font-family font-family 属性用来设置元素内文本的字体。由于字体的种类成千上万，而且有些还不是免费的，因此我们的电脑上几乎不可能拥有所有的字体。为了最大程度的保证我们设置的字体能够正常显示，可以通过 font-family 属性定义一个由若干字体名称组成的列表，字体名称之间使用逗号,分隔，浏览器会首先尝试列表中的第一个字体，如果不支持则尝试下一个，以此类推。
font-family 属性的可选值如下：
值描述family-name、generic-family family-name：字体名称，一个字体名称就代表一种字体，比如“微软雅黑”就是一种字体；generic-family：字体族，也就是某种类型的字体组合，一个字体族代表一种类型的字体，其中包含很多相似但又不同的字体，比如“sans-serif”就是一种无衬线字体，其中包含很多种相似的字体。字体的默认值取决于浏览器设置inherit从父元素继承字体的设置 下表中列举了一些常用的字体族（generic-family）：
字体族说明字体serif有衬线字体，即在文字笔画的结尾添加特殊的装饰线或衬线“Lucida Bright”、“Lucida Fax”、Palatino、“Palatino Linotype”、Palladio、“URW Palladio”、serifsans-serif无衬线字体，即在文字笔画结尾处是平滑的“Open Sans”、“Fira Sans”、“Lucida Sans”、“Lucida Sans Unicode”、“Trebuchet MS”、“Liberation Sans”、“Nimbus Sans L”、sans-serifmonospace等宽字体，即每个文字的宽度都是相同的“Fira Mono”、“DejaVu Sans Mono”、Menlo、Consolas、“Liberation Mono”、Monaco、“Lucida Console”、monospacecursive草书字体，该字体有连笔或者特殊的斜体效果，会给人一种手写的感觉“Brush Script MT”、“Brush Script Std”、“Lucida Calligraphy”、“Lucida Handwriting”、“Apple Chancery”、cursivefantasy具有特殊艺术效果的字体Papyrus、Herculanum、“Party LET”、“Curlz MT”、Harrington、fantasy 使用 font-family 属性为 HTML 元素设置字体样式：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;CSS字体&lt;/title&gt; &lt;style&gt; body { font-family: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70d5938ae03705a00b306513b4dfa7bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a8a2c071699ed0e2df47396a88236f/" rel="bookmark">
			安装conda搭建python环境（保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Anaconda简介二、Anaconda安装2.1 Anaconda下载2.2 Anaconda安装2.3 配置环境变量 三、通过conda配置python环境3.1 创建并激活虚拟环境3.2 管理虚拟环境 一、Anaconda简介 Anaconda 是专门为了方便使用 Python 进行数据科学研究而建立的一组软件包，涵盖了数据科学领域常见的 Python 库，并且自带了专门用来解决软件环境依赖问题的 conda 包管理系统。主要是提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。
conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。
Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。其实还有Miniconda，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。
conda将几乎所有的工具、第三方包都当做package对待，甚至包括python和conda自身！因此，conda打破了包管理与环境管理的约束，能非常方便地安装各种版本python、各种package并方便地切换。
二、Anaconda安装 2.1 Anaconda下载 这里推荐两种下载方式一是官网下载，二是镜像下载；官网下载太慢可选用镜像下载
1、下载地址：官网（https://www.anaconda.com/products/distribution）
选择对应版本，点击Download进行下载
2、镜像下载：开源镜像站（https://mirrors.bfsu.edu.cn/anaconda/archive/）
选择对应版本，点击Download进行下载
2.2 Anaconda安装 1、点击下载的文件进行安装，这是欢迎页面，点击下一步，即Next
2、点击I Agree，即同意Anaconda的协议，才能使用Anaconda
3、选择为所有用户授权
4、选择安装路径，在这里我选择安装在E:\ANACONDA地址下，选择Next，注意这里的安装路径需要记一下，后面配置环境变量时会用到
5、不选择添加环境变量
6、等待程序安装，安装完成后，点击Next
7、图片上有两个选项建议不选，点击“Finish”,完成软件安装
到这里程序安装部分结束
2.3 配置环境变量 将如如下路径添加到系统path，这里的路径为前面anaconda的安装路径，我的安装路径为E:\Anaconda，如果不同替换为自己的安装路径即可
E:\ANACONDA
E:\ANACONDA\Scripts
E:\ANACONDA\Library\mingw-w64\bin
E:\ANACONDA\Library\bin
具体环境变量的的配置步骤如下：
1、进入环境变量配置页面
”我的电脑“右键，选择”属性“；打开页面后，选择”高级系统设置“；然后在“高级”下选择“环境变量”
2、编辑Path系统变量
选择系统变量path，点击编辑；点击新建
E:\ANACONDA
E:\ANACONDA\Scripts
E:\ANACONDA\Library\mingw-w64\bin
E:\ANACONDA\Library\bin
将以上四个地址填上之后，点击确定（注意每个人anaconda的安装不同地址不同，要填上anaconda安装路径下对应文件夹地址）
3、检查是否安装成功
打开cmd,在窗口中输入以下三个指令；
conda --version
conda info
python
如下图所示，这说明安装无问题
三、通过conda配置python环境 3.1 创建并激活虚拟环境 1、创建虚拟环境
按下win键+r，输入cmd打开命令行窗口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a8a2c071699ed0e2df47396a88236f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527b16aec3e271af96a0b3a1de80013a/" rel="bookmark">
			最全的Apache Doris教程（收藏版）共9万&#43;字【第一篇】由于是typora编写，有部分图片在本地，识别不出来，请细聊我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Doris 简介 1.1 Doris 概述 Apache Doris 由百度大数据部研发（之前叫百度 Palo，2018 年贡献到 Apache 社区后，
更名为 Doris ），在百度内部，有超过 200 个产品线在使用，部署机器超过 1000 台，单一
业务最大可达到上百 TB。
Apache Doris 是一个现代化的 MPP（Massively Parallel Processing，即大规模并行处理）
分析型（OLAP）数据库产品。仅需亚秒级响应时间即可获得查询结果，有效地支持实时数据分析。
Apache Doris 的分布式架构非常简洁，易于运维，并且可以支持 10PB 以上的超大数据集。
Apache Doris 可以满足多种数据分析需求，例如固定历史报表，实时数据分析，交互式数据分析和探索式数据分析等。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hvj6IaqO-1677043665246)(C:\Users\10575\AppData\Roaming\Typora\typora-user-images\image-20230222130351225.png)]
1.2OLAP和OLTP [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6ICur7Tt-1677043665247)(C:\Users\10575\AppData\Roaming\Typora\typora-user-images\image-20230221140509218.png)]
联机事务处理OLTP(On-Line Transaction Processing) 公司业务系统使用数据库的场景，针对业务系统数据库有大量随机的增删改查高并发速度要快支持事务 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pV8Ef3NE-1677043665247)(C:\Users\10575\AppData\Roaming\Typora\typora-user-images\image-20230222130420630.png)]
联机分析处理OLAP(On-Line Analytical Processing) 公司的数据分析使用数据库的场景，对已经生成好的数据进行统计分析一次操作都是针对的整个数据集，只有查这个动作，不会去增删改查询的响应速度相对慢点也能接受并发量要求不是太高 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QGK1jH3t-1677043665248)(C:\Users\10575\AppData\Roaming\Typora\typora-user-images\image-20230222130520084.png)]
OLAP和OLTP比较
OLTPOLAP数据源仅包含当前运行日常业务数据整合来自多个来源的数据，包括OLTP和外部来源目的面向应用,面向业务,支撑事务面向主题，面向分析，支持分析决策焦点当下主要面向过去，面向历史(实时数仓除外)任务增删改查主要是用于读，select查询，写操作很少响应时间毫秒秒，分钟，小时，天，这些取决于数据量和查询的复杂程度数据量小数据,MB,GB大数据，TP,PB 常见的开源OLAP引擎
开源OLAP引擎优点缺点技术融合成本易用性使用场景运维成本引擎类型ClickHouse列式存储单极性彪悍保留明细数据分布式集群在线扩展支持不佳运维成本极高高非标协议接口全面高纯列存OLAPDruid实时数据摄入列式存储和位图索引多租户和高并发OLAP性能分场景表现差异大使用门槛高仅支持聚合查询高非标协议接口局限高MOLAPTiDBHTAP混合数据库同时支持明细和聚合查询高度兼容mysql非列式存储OLAP能力不足低SQL标准全面低纯列存OLAPKylin与计算引擎，可以对数据一次聚合多次查询支持数据规模超大易用性强，支持标准sql性能强，查询数据快需要依赖hadoop生态仅支持聚合查·询不支持adhoc查询不支持join和对数据的更新高SQL标准局限高MOLAPDorisGooleMesa+Apache Impa+ORCFile/Parquet主键更新支持Rollup Table高并发和高通图的Ad-hoc查询支持聚合+明细数据查询无外部系统依赖成熟度不够低兼容mysql访问协议全面低HOLAP 1.3使用场景 报表分析 实时看板 （Dashboards） ==》rolap中我给过他一个sql，亚秒级的响应我想要的结果面向企业内部分析师和管理者的报表面向用户或者客户的高并发报表分析（Customer Facing Analytics）。比如面向网站主的站点分析、面向广告主的广告报表，并发通常要求成千上万的 QPS ，查询延时要求毫秒级响应。著名的电商公司京东在广告报表中使用 Apache Doris ，每天写入 100 亿行数据，查询并发 QPS 上万，99 分位的查询延时 150ms。 即席查询（Ad-hoc Query）：面向分析师的自助分析，查询模式不固定，要求较高的吞吐。小米公司基于 Doris 构建了增长分析平台（Growing Analytics，GA），利用用户行为数据对业务进行增长分析，平均查询延时 10s，95 分位的查询延时 30s 以内，每天的 SQL 查询量为数万条。统一数仓构建 ：一个平台满足统一的数据仓库建设需求，简化繁琐的大数据软件栈。海底捞基于 Doris 构建的统一数仓，替换了原来由 Spark、Hive、Hbase、Phoenix 组成的旧架构，架构大大简化。数据湖联邦查询：通过外表的方式联邦分析位于 Hive、Hudi 中的数据，在避免数据拷贝的前提下，查询性能大幅提升 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/527b16aec3e271af96a0b3a1de80013a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a7347cb3271ae951949b1c73e45f9a/" rel="bookmark">
			【python绘图（一）】Python数据分析和可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 绘制三维曲面图及其投影图
2. 绘制曲面图
3. 绘制曲面投影图
4. 同时绘制曲面图和投影图，用两个图展示
5. 绘制曲面图
6. 同时绘制曲面图及其二维填色图
数据分析包括探索、清理和转换数据以从中提取有用信息。Python有许多库可以使数据分析变得更容易，例如Pandas、NumPy和SciPy。以下是使用Python进行数据分析的基本步骤：
加载数据：您可以使用Pandas从各种来源加载数据，例如CSV、Excel文件、SQL数据库或API。
探索数据：使用Pandas查看数据及其结构。您可以检查空值、数据类型和摘要统计信息。此步骤有助于更好地了解数据并识别任何问题。
清理数据：您可以使用Pandas处理缺失值、重复值、异常值和不正确的数据。在分析数据之前，数据清理是必不可少的步骤。
转换数据：Pandas提供了一些转换数据的工具，包括筛选、分组、合并和透视。此步骤有助于为分析数据做准备。
分析数据：您可以使用Python库，例如NumPy、SciPy和Pandas进行各种类型的分析，包括统计分析、机器学习和数据建模。
可视化是传达数据洞察力和模式的强大工具。Python有许多数据可视化库，包括Matplotlib、Seaborn和Plotly。以下是使用Python创建可视化的基本步骤：
加载数据：您可以像上面描述的那样加载数据。
选择可视化：选择适当的可视化方式，例如散点图、条形图、热图等。
创建可视化：使用所选库创建可视化，包括选择数据、定义图表类型和自定义图表外观。
自定义可视化：您可以自定义图表的各种特征，包括轴标签、标题、颜色和注释。
保存或显示可视化：一旦您创建和自定义了可视化，可以将其保存到文件或在Jupyter笔记本或其他Python环境中显示。
使用Python进行数据分析和可视化是一个广阔的领域，这仅仅是一个概述。
1. 绘制三维曲面图及其等高线投影图 import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D import numpy as np # 创建三维图形 fig = plt.figure() ax = fig.add_subplot(111, projection='3d') # 生成数据 x = np.arange(-5, 5, 0.25) y = np.arange(-5, 5, 0.25) x, y = np.meshgrid(x, y) r = np.sqrt(x ** 2 + y ** 2) z = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9a7347cb3271ae951949b1c73e45f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d154f15f05a947fada04ce17049298d9/" rel="bookmark">
			PCA（主成分分析）的理解与应用（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCA
主成分分析（Principal Component Analysis, PCA）是一种线性降维算法，也是一种常用的数据预处理（Pre-Processing）方法。它的目标是是用方差（Variance）来衡量数据的差异性，并将差异性较大的高维数据投影到低维空间中进行表示。绝大多数情况下，我们希望获得两个主成分因子：分别是从数据差异性最大和次大的方向提取出来的，称为PC1(Principal Component 1) 和 PC2（Principal Component 2）。
PCA的具体实现
随机选取的六名学生的数学和语文考试成绩 student_id123456scores1927095737287scores2748770929774 制作为散点图：
图中每个点代表了一个学生，X轴代表语文成绩，Y轴代表数学成绩。然后分别取所有样本的X平均值和Y平均值，并将这两个值变为X、Y坐标，在图中画出这个点（用五角星表示）:
按照图中箭头所示方向，将整个坐标系平移，使原点与五角星重叠。这样就获得了一个新的平面直角坐标系：
尽管此时坐标系和每个点的值都发生了变化，点与点之间的相对位置仍保持一致。找到这些点的最优拟合线（Line of Best Fit），也就找到了PC1，再通过原点做PC1的垂线，就找到PC2：
处理三维数组时便会产生第三个因子（PC3），以此类推，数据的维度越大，因子的数量也就越多。当维度大于等于4的时候，我们是无法想象出图像的，但PC4确实存在；假设有x个维度，便可以做x-1条垂线，就能得到PCx。接下来要做的便是选取最能代表数据差异性的两个因子，作为PC1和PC2。
按照下图所示，将点A投影到PC1上（六角星的位置），并计算其与原点之间的距离称为d1：
其余的五个点也做同样操作，得出d2至d5，再求这六个距离的平方和，称为PC1的特征值（Eigenvalue）。然后将PC1的特征值除以总样本数量减一（n-1），就计算出了PC1的差异值（Variation）。 以此类推，并选择差异值最大的两个因子作为PC1 和 PC2。假设在某个三维数组中，获得了PC1、PC2和PC3的差异值分别为18，7，5。通过计算（18+7）/ (18+7+5) ≈ 83.3% 得到结论：PC1 和 PC2 代表了这个三维数组83.3%的差异性。在本次分析的13个因子中，PC1和PC2描述了整组数据约81%的差异性： 最后，再通过选中的PC1和PC2将样本映射回本身所在的坐标，就可以得到降维后的图像（PCA Plot）。
协方差矩阵基本知识点： 矩阵中的数据按行排列和按列排列求出的协方差矩阵是不同的，这里默认数据是按行排列。即每一行是一个observation（样本），那么每一列就是一个随机变量（特征）。
举个例子，矩阵X按行排列：
1.求每个维度的平均值
2.将X的每一列减去平均值
3.计算协方差矩阵
矩阵特征值和特征向量计算方法：
计算A的特征值和特征向量 计算行列式得
化简得：
得到特征值：
化简得：
令得到特征矩阵：
同理，当得：
令得到特征矩阵：
代码实现（依次由繁到简实现效果）
方法一：
# -*- coding: utf-8 -*- """ @author: 绯雨千叶 用PCA求样本矩阵X的K阶降维矩阵Z 请保证输入的样本矩阵X shape=(m, n)，m行样例，n个特征 """ import numpy as np class PCA(object): def __init__(self, X, K): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d154f15f05a947fada04ce17049298d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0107422918afbf88e47112a7c38189/" rel="bookmark">
			基于html&#43;js实现轮播图（自动轮播、左右按钮、小圆点点击及切换图片）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用html和js实现的一个简单小练习轮播图。大概功能主要是：
1、使用时间函数自动切换图片；
2、在图片及按钮及小圆点的父节点身上绑定事件代理，添加mouseenter及mouseleave事件类型，让鼠标移入，图片暂停，移出，图片恢复轮播；
3、在按钮的父节点身上绑定事件代理，事件类型为click，使用event.target判断点击的目标范围，让左右两个按钮，点击可以切换上一张或下一张；
4、给图片添加样式，让下面的四个小圆点会随图片变颜色；
5、在小圆点的父节点身上绑定事件代理，事件类型为click，同样使用event.target判断点击的目标范围，让小圆点可以点击并切换到对应的图片上。
依旧使用的是DOM2事件代理，详细的解释和代码步骤我都注释在下面的代码中的，请君一阅。
【注：仅作自己查看和分享学习之用】
效果图如下：
代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;link rel="stylesheet" href="https://at.alicdn.com/t/c/font_3881267_wfv3iyzbijg.css"&gt; &lt;/head&gt; &lt;style&gt; section { position: relative; height: 500px; width: 780px; border: 1px solid; margin: 100px auto; } #img { height: 100%; width: 100%; background-size: 100% 100%; } p { position: absolute; left: 50%; bottom: 0px; transform: translate(-50%, -50%); } i { height: 15px; width: 15px; background-color: gray; border-radius: 50%; display: inline-block; margin-right: 10px; } i:nth-child(1) { background-color: white; } i:nth-child(4) { margin-right: 0; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0107422918afbf88e47112a7c38189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e0decfb867ecc9eb5e7a00eae39178/" rel="bookmark">
			Python 之 Matplotlib 柱状图（竖直柱状图和水平柱状图）、直方图和饼状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、柱状图二、竖直柱状图1. 基本的柱状图2. 同位置多柱状图3. 堆叠柱状图 三、水平柱状图1. 基本的柱状图2. 同位置多柱状图3. 堆叠柱状图 四、直方图 plt.hist()1. 返回值2. 添加折线直方图3. 不等距分组4. 多类型直方图5. 堆叠直方图 五、饼状图 pie()1. 百分比显示 percentage2. 饼状图的分离3. 设置饼状图百分比和文本距离中心位置4. 图例 在开始，我们先引入 matplotlib 和 numpy 库。 from matplotlib import pyplot as plt import numpy as np 对基本配置进行设置，将中文字体设置为黑体，不包含中文负号，分辨率为 100，图像显示大小设置为 (5,3)。 plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus'] = False​ plt.rcParams['figure.dpi'] = 100​ plt.rcParams['figure.figsize'] = (5,3) 一、柱状图 柱状图是一种用矩形柱来表示数据分类的图表。柱状图可以垂直绘制，也可以水平绘制。它的高度与其所表示的数值成正比关系。柱状图显示了不同类别之间的比较关系，图表的水平轴 X 指定被比较的类别，垂直轴 Y 则表示具体的类别值 二、竖直柱状图 matplotlib.pyplot.bar(x, height, width: float = 0.8, bottom = None, *, align: str = ‘center’, data = None, **kwargs) 其参数具体如下含义：x 表示 x 坐标，数据类型为 float 类型，一般是通过 np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6e0decfb867ecc9eb5e7a00eae39178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b759724e869ab94cc8c0f77b25c590ea/" rel="bookmark">
			【yolov5】将标注好的数据集进行划分（附完整可运行python代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 准备使用yolov5训练自己的模型，自己将下载的开源数据集按照自己的要求重新标注了一下，然后现在对其进行划分。
问题分析 划分数据集主要的步骤就是，首先要将数据集打乱顺序，然后按照一定的比例将其分为训练集，验证集和测试集。
这里我定的比例是7：1：2。
步骤流程 1、将数据集打乱顺序 数据集有图片和标注文件，我们需要把两种文件绑定然后将其打乱顺序。
首先读取数据后，将两种文件通过zip函数绑定
each_class_image = [] each_class_label = [] for image in os.listdir(file_path): each_class_image.append(image) for label in os.listdir(xml_path): each_class_label.append(label) data=list(zip(each_class_image,each_class_label)) 然后打乱顺序，再将两个列表分开
random.shuffle(data) each_class_image,each_class_label=zip(*data) 2、按照确定好的比例将两个列表元素分割 分别用三个列表储存一下图片和标注文件的元素
train_images = each_class_image[0:int(train_rate * total)] val_images = each_class_image[int(train_rate * total):int((train_rate + val_rate) * total)] test_images = each_class_image[int((train_rate + val_rate) * total):] train_labels = each_class_label[0:int(train_rate * total)] val_labels = each_class_label[int(train_rate * total):int((train_rate + val_rate) * total)] test_labels = each_class_label[int((train_rate + val_rate) * total):] 3、在本地生成文件夹，将划分好的数据集分别保存 这样就保存好了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b759724e869ab94cc8c0f77b25c590ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403fe4f6a90b3721e9edb7197e48554f/" rel="bookmark">
			C语言经典游戏代码大全（珍藏版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 发现很多朋友都想要一些小项目来练手，却找不到从哪里寻找，给大家整理了游戏项目开发源代码汇总。
一、最经典游戏之俄罗斯方块 #include&lt;iostream&gt; #include&lt;math.h&gt; #include&lt;Windows.h&gt; #include&lt;conio.h&gt; #include&lt;ctime&gt; using namespace std; enum DIR { UP, RIGHT, DOWN, LEFT }; time_t start = 0, finish = 0; int _x = 6, _y = 1;//图形生成位置 int map[30][16] = { 0 }; int sharp[20][8] = { {0,0,0,0,0,0,0,0}, //I形 {0,0,0,1,0,2,0,3}, {0,0,1,0,2,0,3,0}, //■形 {0,0,1,0,0,1,1,1}, //L形 {0,0,0,1,0,2,1,2}, {0,0,0,1,1,0,2,0}, {0,0,1,0,1,1,1,2}, {0,1,1,1,2,0,2,1}, //J形 {0,2,1,0,1,1,1,2}, {0,0,0,1,1,1,2,1}, {0,0,0,1,0,2,1,0}, {0,0,1,0,2,0,2,1}, //Z形 {0,0,1,0,1,1,2,1}, {0,1,0,2,1,0,1,1}, //S形 {0,1,1,0,1,1,2,0}, {0,0,0,1,1,1,1,2}, //T形 {0,1,1,0,1,1,2,1}, {0,0,0,1,0,2,1,1}, {0,0,1,0,1,1,2,0}, {0,1,1,0,1,1,1,2} }; class Game { public: int score;//游戏分数 int _id;//图形编号 int top;//最高点高度 int speed;//下落速度 Game(); void showMenu();//显示菜单 void showGround();//显示游戏界面 void gameOver();//游戏结束界面 void Run();//运行游戏 void sharpDraw(int id, bool show = false);//绘制图形 void keyControl();//键盘控制 bool move(int dir, int id);//移动判断 bool downSet(int id);//下落 void Turn(int id);//旋转 void clean();//消行 }; void SetPos(int i, int j)//控制光标位置， 列， 行 { COORD pos = { i,j }; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } int main() { CONSOLE_CURSOR_INFO cursor; GetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor); cursor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/403fe4f6a90b3721e9edb7197e48554f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f848f3960840390271ee43e98b8d0d8/" rel="bookmark">
			Session详解，学习 Session对象一篇文章就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 Session概述
2 Session原理
3 Session使用
3.1 获取Session
3.2 Session保存数据
3.3 Session获取数据
3.4 Session移除数据
4 Session与Request应用区别
4.1 Session和request存储数据
4.2 获取session和request中的值
4.3 session和request区别效果
5 Session的声明周期
5.1 Session有效时间设置
5.2 session销毁
.6 浏览器禁用Cookie解决方案（了解）
6.1 浏览器禁用Cookie的后果
6.2 URL重写
6.3 实现URL重写
7 Session实战权限验证
7.1 创建管理员表manager并添加数据
7.2 创建Web项目
7.3 基础环境搭建
7.4 登录页面
7.5 LoginMgrController
7.6 ShowAllManagerController
7.7 ShowAllManagerJsp
8 Session实战保存验证码
8.1 创建验证码
8.2 登录页面
8.3 LoginMgrController
8.4 ShowAllManagerController
今天的分享就到此结束了
创作不易点赞评论互关三连
1 Session概述 （1）Session用于记录用户的状态。Session指的是一段时间内，单个客户端与Web服务器的一连串相关的交互过程。
（2）在一个Session中，客户可能会多次请求访问同一个资源，也有可能请求访问各种不同的服务器资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f848f3960840390271ee43e98b8d0d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56343e7dca68f7c9ce1a41aba50b0c52/" rel="bookmark">
			vue3 使用ref 获取 dom 元素的高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码实现：
&lt;template&gt; &lt;div ref="mains" class="search"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref, onMounted } from 'vue' const mains = ref() onMounted(() =&gt; { const height = mains.value.clientHeight console.log(height, 1234) }) &lt;/script&gt; &lt;style scoped lang="less"&gt; .search { width: 100px; height: 100px; margin: 0 auto; background-color: greenyellow; } &lt;/style&gt; 输出结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d791bbf133849680eec327da2da75d4/" rel="bookmark">
			在idea中使用mysql（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、连接mysql 在IDE开发工具中也是可以使用mysql的，这里以开发java常用的IntelliJ IDEA为例。
1. 打开idea，右上角有数据库侧边栏，打开侧边栏点击加号-&gt;数据源，可以看到支持很多数据库，选择mysql。
2. 首次使用需要下载驱动程序，不然连接数据库会报错。找到mysql，点击驱动程序文件下面的加号，点击提供的驱动程序，选择mysql驱动程序（mysql connector/J），然后选择驱动版本。如果安装的mysql是5版本，下载那个都可以，如果安装的8版本就下载8版本的驱动程序。
3. 驱动程序下载完成之后选择类，5版本mysql就选择图中的类com.mysql.jdbc.Driver。
4. 如果mysql是8版本就下载8版本驱动程序，选择图中com.mysql.cj.jdbc.Driver.
5. 输入主机、端口、用户、密码之后点击测试连接，没问题就可以看到连接成功，之后一路确定。连接失败的话检查输入的信息，看看mysql版本和驱动程序版本是否兼容。
6. 连接成功之后只显示默认架构（也就是数据库），可以切换要显示的数据库。
二、使用mysql 1. 鼠标右键数据库或者表唤出功能栏，点击跳转查询控制台之后就可以在控制台选项卡里编写执行SQL了。在控制台选项卡里面也是要选择数据库的，在图中test那个位置点开下拉框去选择切换数据库，tx自动那里可以选择事务提交方式和事务隔离级别。
三、快速生成实体、接口、sql文件 1. 在这里不仅可以操作mysql，还可以快速生成实体、接口和SQL文件方便进行java开发。如图所示新建了一个springboot的模块，在功能栏中选择一个或者多个表之后点击Mybatis-Generator弹出窗口，在这里编辑生成信息。model setting是设置实体的，file就是实体名，package就是包名。dao setting是设置映射接口，xml mapper setting里面设置SQL文件信息，设置完之后点击ok就可以了。
2. 如图所示就是生成的实体、接口、SQL文件。可以看到实体上面的@Data注解报错，这是因为这个注解是lombok的jar包提供的用来生成实体属性的get、set、toString等等这些方法，而项目中此时是没有这个jar包的，所以就报错了。可以直接点击“将lombok添加到类路径”，它会自动在pom文件中添加lombok的坐标，也可以手动在pom中添加lombok坐标。
如果不想使用lombok可以直接把@Data注解删除，也可以在步骤8编辑生成信息那里取消勾选options里面的Use-Lombox。不使用lombok就手动创建get、set、toString方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a397cfb866d6f8ee07ac2d9a5c097b7c/" rel="bookmark">
			Java面试题及答案整理汇总（2023最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 面试前还是很有必要针对性的刷一些题，很多朋友的实战能力很强，但是理论比较薄弱，面试前不做准备是很吃亏的。这里整理了很多面试常考的一些面试题，希望能帮助到你面试前的复习并且找到一个好的工作，也节省你在网上搜索资料的时间来学习。
第1-10期Java面试题整理 面试官：有了 for 循环 为什么还要 forEach ？
面试官：jwt 是什么？java-jwt 呢？懵逼了。。。
面试官：谈谈为什么要限流，有哪些限流方案？
面试官：HTTPS 是如何保证传输安全的？又被问了！
面试官：说说 WebSocket 和 Socket 及 Http 的区别？
面试官：RocketMQ 如何保证消息不丢失，如何保证消息不被重复消费？
面试官：ElasticSearch是什么？应用场景是什么？
面试官：说说Java并发运行中的一些安全问题
面试官：你了解 QPS、TPS、RT、吞吐量 这些高并发性能指标吗？
面试官：集群高并发环境下如何保证分布式唯一全局ID生成？
第11-20期Java面试题整理 面试官：思考Tomcat 类加载器为什么要违背双亲委派模型？
面试官：Java8 lambda 表达式 forEach 如何提前终止？
面试官：说一下SpringBoot的自动配置原理
面试官：线程池灵魂8连问，你挡的住吗？
面试官：熟悉设计模式吗？谈谈简单工厂模式和策略模式的区别
面试官：Kafka 为什么会丢消息？
面试官：单核 CPU 支持 Java 多线程吗？为什么？被问懵了！
面试官：Java 序列化和反序列化为什么要实现 Serializable 接口？
面试官：如何正确的停掉线程？
面试官：线程池执行过程中遇到异常会发生什么，怎样处理？
第21-30期Java面试题整理 面试官: 美团外卖的分库分表怎么设计？
面试官：MySQL 中 InnoDB 的索引结构以及使用 B+ 树实现索引的原因
面试官：JDK1.8 创建线程池有哪几种方式？
面试官：说说Java线程的状态及转换
面试官：Hash 碰撞是什么？如何解决？
面试官：说一下TCP和UDP协议的原理和区别？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a397cfb866d6f8ee07ac2d9a5c097b7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64bab3fd17c97ee82157fa132b62180e/" rel="bookmark">
			【链式二叉树】数据结构链式二叉树的（万字详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在上一篇博客中，我们已经详解学习了堆的基本知识，今天带大家进入的是二叉树的另外一种存储方式----“链式二叉树”的学习，主要用到的就是“递归思想”！！
本文目录 1.链式二叉树的实现1.1前置说明1.2结构体以及声明 2.遍历二叉树2.1算法描述2.2先序遍历2.3中序遍历2.4后序遍历2.5层序遍历2.6算法分析 3.接口功能的实现3.1二叉树节点个数3.2二叉树叶子节点个数3.3二叉树第k层节点个数3.4二叉树查找值为x的节点3.5二叉树的高度3.6二叉树的销毁3.7判断是否为完全二叉树 4.选择题练习5.OJ题练习5.1 单值二叉树（LeetCode 965题）5.2检查两颗树是否相同（LeetCode 100题）5.3 对称二叉树（LeetCode 101题）5.4另一颗树的子树（LeetCode 572题）5.5二叉树的前序遍历（LeetCode 144题）5.6 二叉树中序遍历（LeetCode 94题）5.7二叉树的后序遍历（LeetCode 145题） 6.总结 前情回顾：
再看二叉树基本操作前，再回顾下二叉树的概念，二叉树是：
空树非空：根节点，根节点的左子树、根节点的右子树组成的。
1.链式二叉树的实现 1.1前置说明 在学习二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。由于现在大家对二叉树结构掌握还不够深入，为了降低大家学习成本，此处手动快速创建一棵简单的二叉树，快速进入二叉树操作学习，等二叉树结构了解的差不多时，我们反过头再来研究二叉树真正的创建方式，代码如下：
typedef int BTDataType; typedef struct BinaryTreeNode { BTDataType _data; struct BinaryTreeNode* _left; struct BinaryTreeNode* _right; }BTNode; BTNode* CreatBinaryTree() { BTNode* node1 = BuyNode(1); BTNode* node2 = BuyNode(2); BTNode* node3 = BuyNode(3); BTNode* node4 = BuyNode(4); BTNode* node5 = BuyNode(5); BTNode* node6 = BuyNode(6); node1-&gt;_left = node2; node1-&gt;_right = node4; node2-&gt;_left = node3; node4-&gt;_left = node5; node4-&gt;_right = node6; return node1; } 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64bab3fd17c97ee82157fa132b62180e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c74ade5ecd0b48fd9cbeb83de329b34/" rel="bookmark">
			机器学习数据集----训练集、测试集以及验证集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、训练集
用来构建模型，通过训练拟合一些参数建立分类器。
2、验证集
用于确定网络结构以及调整模型的超参数。
使用验证集的目的就是为了快速调参（如网络层数、网络节点数、迭代次数等等），从而获得当前最优模型。
验证集是在训练集中划分出的一部分。
验证集不是必须要有的！
3、测试集
用来评估最终模型好坏。
4、是否需要划分验证集判断
4.1划分验证集
如果样本数量为万级以上，可以考虑划分为训练集（60%）、验证集（20%）、测试集（20%）；
如果样本数量达到百万级以上，验证集和测试集都留1W即可；
超参数越少或者容易调整，可以减少验证集比例，更多的分配给训练集。
4.2不需要划分验证集
如果样本数量少于1w，可以不用划分验证集，采用交叉验证训练优化选择模型。
5、交叉验证
5.1简单交叉验证
所谓简单是相对于其他交叉验证方法而言的。
随机将样本划分为训练集（70%）和测试集（30%），用训练集训练模型，用测试集验证模型及参数。接着再把样本打乱，重新选择训练集和测试集，继续训练模型和验证模型。最终选择损失函数评估最优模型和参数。
5.2 K折交叉验证
将样本随机划分为K个大小相同的互斥的子集，每次选K-1个作为训练集，剩的那个作为测试集。重复若干次（小于K）后，选择损失函数评估最优模型和参数。
这种方法评估结果的稳定性和保真性很大程度上取决于K的选择。
5.3留一交叉验证
是K折交叉验证的特例，适用于样本数量很少的情况。
该方法中，K等于样本数量N，每次选择N-1个样本进行训练，剩的1个样本进行测试。
5.4三种方法的选择
如果只是做个初步的模型建立，不是做深入分析的话，选择简单交叉验证，否则用K折交叉验证；在样本量少的情况下，使用留一交叉验证。
5.5交叉验证函数
cross_val_predict和cross_val_score都是交叉验证函数，区别主要是而这返回的评估结果不一样。
①、cross_val_predict：返回的是与样本数量个数一样的分类结果或者预测值。可以通过该预测输出与实际目标值做对比，准确定位到预测出错的地方，有利于参数优化和问题排查。输出的预测值可以用于计算PR曲线和ROC曲线。 其中，Ytrain为正确的标签，y_score为输出概率值，thresholds1为阈值，当 y_score&gt;thresholds1时预测为正样本；当 y_score&lt;thresholds1时预测为负样本。注意，输出的precision和recall最后一个值分别为1和0，并且没有对应的阈值。
②、cross_val_score：输出的是每一折的得分（准确率），K个得分取平均值就是模型的平均性能。最终输出的Accuracy可以由平均得分和95%置信区间共同得出。
cross_val_predict的输出结果不可以作为模型泛化性能参考；cross_val_score可以作为模型泛化性能的参考。
5.6置信区间
表示估计的准确度或精确度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82bb6294350cf7d69a1c1e6e4fdded2b/" rel="bookmark">
			vue坑集合笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、
Note that the development build is not optimized.
To create a production build, run npm run build.
解决办法 是因为axios和node版本不兼容 用nvm换一个低版本的node 然后删除依赖 重新install 问题解决了 https://blog.csdn.net/qq_46429858/article/details/124692371
https://blog.csdn.net/Zxiaobinggan/article/details/127531470
//到要nvm安装的文件夹下 d: cd nvm\nvm nvm list //选择nvm版本 nvm use 14.19.2 node -v npm install -g @vue/cli //安装vue 2、数据在浏览器不显示
//安装了浏览器VUE插件，然后再F12中点击vue插件 //莫名其妙数据就显示了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d848742e02a6654333085245431be6/" rel="bookmark">
			api接口详解大全（看这篇就足以了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		api接口详解大全?优秀的设计是产品变得卓越的原因设计API意味着提供有效的接口，可以帮助API使用者更好地了解、使用和集成，同时帮助人们有效地维护它每个产品都需要使用手册，API也不例外在API领域，可以将设计视为服务器和客户端之间的协议进行建模API协议可以帮助内部和外部的利益相关者理解应该做什么，以及如何更好地协同工作来构建一个出色的API，今天小编就来聊一聊关于api接口详解大全?接下来我们就一起去研究一下吧!
api接口详解大全 优秀的设计是产品变得卓越的原因。设计API意味着提供有效的接口，可以帮助API使用者更好地了解、使用和集成，同时帮助人们有效地维护它。每个产品都需要使用手册，API也不例外。在API领域，可以将设计视为服务器和客户端之间的协议进行建模。API协议可以帮助内部和外部的利益相关者理解应该做什么，以及如何更好地协同工作来构建一个出色的API。
一、API接口1.什么是API接口
应用程序编程接口（Application Programming Interface，API接口），是应用程序重要的组成部分，就是应用程序对外提供了一个操作数据的入口，这个入口可以是一个函数或类方法，也可以是一个url地址或者一个网络地址。当客户端调用这个入口，应用程序则会执行对应代码操作，给客户端完成相对应的功能。
2.API接口类型
目前市面上大部分公司开发人员使用的接口实现规范主要有：restful、RPC。
RPC（ Remote Procedure Call ）: 翻译成中文:远程过程调用[远程服务调用]. 从字面上理解就是访问/调用远程服务端提供的api接口。这种接口一般以服务或者过程式代码提供。
服务端提供一个唯一的访问入口地址：http://api.xxx.com/ 或 http://www.xx.com/api 客户端请求服务端的时候，所有的操作都理解为动作，一般web开发时，对应的就是HTTP请求的post请求 通过请求体参数，指定要调用的接口名称和接口所需的参数action=get_all_student&amp;class=301&amp;sex=1m=get_all_student&amp;sex=1&amp;age=22&amp;command=100&amp;sex=1&amp;age=22 接口多了,对应函数名和参数就多了,前端在请求api接口时难找.容易出现重复的接口
RESTful: 翻译成中文: 资源状态转换.(表征性状态转移)
把服务端提供的所有的数据/文件都看成资源， 那么通过api接口请求数据的操作，本质上来说就是对资源的操作了.因此，Restful中要求，我们把当前接口对外提供哪种资源进行操作，就把资源的名称写在url地址。
web开发中操作资源，最常见的最通用的无非就是增删查改，所以restful要求在地址栏中声明要操作的资源是什么。然后通过http请求动词来说明对该资源进行哪一种操作。POST http://www.xxx.com/api/students/ 添加学生数据GET http://www.xxx.com/api/students/ 获取所有学生DELETE http://www.xxx.com/api/students/&lt;pk&gt;/ 删除id=pk的一个学生PUT http://www.xxx.com/api/students/&lt;pk&gt;/ 修改一个学生的全部信息 [id,name,sex,age,]PATCH http://www.xxx.com/api/students/&lt;pk&gt;/ 修改一个学生的部分信息[age]
也就是说，我们仅需要通过url地址上的资源名称结合HTTP请求动作，就可以说明当前api接口的功能是什么了。
Restful是以资源为主的api接口规范，体现在地址上就是资源就是以名词表达。RPC则以动作为主的api接口规范，体现在接口名称上往往附带操作数据的动作。
3.为什么要编写接口文档 为了在团队内部形成共识、防止个人习惯差异引起的混乱，我们都需要找到一种大家都觉得很好的接口实现规范，而且这种规范能够让后端写的接口，用途一目了然，减少客户端和服务端双方之间的合作成本。由于接口所包含的内容比较细，在项目中常常需要使用接口文档。研发人员可以根据接口文档进行开发、协作，测试人员可以根据接口文档进行测试，系统也需要参照接口文档进行维护等。
二、API接口规范1.协议 API与客户端用户的通信协议，推荐使用http协议，同时兼容HTTP，以确保交互数据的传输安全。
2.域名 应该尽量将API部署在专用域名之下。http://api.xxx.com
如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。http://www.xxx.com/api/
3.版本（Versioning） 推荐将API的版本号放入URL。
http://api.xxx.com/app/v1.0/foohttp://api.xxx.com/app/v1.1/foohttp://api.xxx.com/app/v2.0/foo
另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。
版本号规范：1）采用多版本并存，增量发布的方式。2）版本号可以分为整型和浮点型整型：大功能版本，如v1、v2、v3 ...浮点型：补充功能版本，如v1.1、v1.2、v2.1、v2.2 ...
关于版本兼容性，小版本变化向下兼容的，只要大版本不变化。3）对于一个API或服务，应在生产中最多保留3个最详细的版本
4.路径（Endpoint） 路径又称"终点"（endpoint），表示API的具体网址，每个网址代表一种资源（resource）
接口命名应该是一个动宾结构，由动词 名词组成，采取驼峰式命名规范，例如：
product/v1.0/getProducts 获取产品order/v1.1/saveOrder 保存订单
接口命名常见通用动词可以参考如下：
动作
前缀
备注
获取
get
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d848742e02a6654333085245431be6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/615/">«</a>
	<span class="pagination__item pagination__item--current">616/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/617/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>