<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82de9a184c54d626d9e935995ea3612a/" rel="bookmark">
			阿里云ubuntu系统安装mysql8.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装mysql8.0 1.已安装其他版本的mysql，需要删除 若没有不需要此操作
1 #卸载MySQL5.7版本 2 apt remove -y mysql-client=5.7* mysql-community-server=5.7* 4 # 卸载5.7的仓库信息 5 dpkg-l | grep mysql | awk 'iprint $2}' | xargs dpkg -P 2.更新仓库 apt update 3.ubuntu内置mysql8.0可以直接安装 apt install -y mysql-server 4.mysql启动、停止、查看状态 查看状态：/etc/init.d/mysql status 停止：/etc/init.d/mysql start 启动：/etc/init.d/mysql stop 5.登录mysql设置密码 5.1登录初始安装不需要密码 #直接连接输入：mysql mysql 5.2重置密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password By '自己输入密码'; 5.3推出登录 exit 6.初始化mysql mysql_secure_installation 后面就是输入密码，以及一系列选择；
7.登录mysql #方式一 mysql -u用户名 -p密码 #方式二 mysql -u用户名 -p 后面在输入密码，安全性好一点 二、远程连接 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82de9a184c54d626d9e935995ea3612a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887de53c250c19a4c537eb0e0e42d7eb/" rel="bookmark">
			C#进阶-ASP.NET实现可以缩放和旋转的图片预览页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细介绍了如何在ASP.NET WebForms中实现一个功能丰富的图片预览页面。通过结合HTML、CSS和JavaScript，用户可以方便地对图片进行放大、缩小以及旋转操作。文章从页面的基本布局开始，逐步讲解了如何设置图片展示区、添加控制按钮、编写CSS样式以及实现JavaScript功能，最终展示了一个直观且易用的图片预览解决方案。通过这个项目，读者可以学会如何在Web应用中动态处理图片，提高用户交互体验。
一、实现思路 在现代Web应用中，用户对图片的操作需求日益增加，尤其是在图片展示时能够方便地进行放大、缩小以及旋转等操作。为了满足这些需求，本项目基于ASP.NET WebForms开发了一个图片预览页面，用户可以通过简单的按钮操作来调整图片的大小和角度。实现这一功能的核心在于使用HTML、CSS和JavaScript结合来动态调整图片的样式属性，以达到相应的效果。
二、实现步骤 1. 创建ASP.NET页面 首先，我们需要创建一个ASP.NET WebForms页面。在Visual Studio中，右键点击你的项目，选择添加 -&gt; 新建项。
选择Web 窗体，命名为 IMGShow.aspx。
2. 添加HTML布局 接下来，在 IMGShow.aspx 文件中添加基本的HTML结构。这包括设置页面的DOCTYPE、meta标签、title等，以及link标签导入所需的CSS文件。以下是页面的基本结构：
&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="IMGShow.aspx.cs" Inherits="WebForms.IMGShow" %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge" /&gt; &lt;title&gt;图片展示&lt;/title&gt; &lt;link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" type="text/css" /&gt; &lt;script src="https://code.jquery.com/jquery-3.5.1.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body class="easyui-layout" data-options="fit:true"&gt; &lt;/body&gt; &lt;/html&gt; 3. 设置图片展示区 在body标签中，添加一个div容器，用于展示图片。这个容器需要设定宽度和高度，以保证图片能在页面居中显示。然后，使用img标签加载图片。这里，我们设置图片初始宽度为60%。
HTML代码里创建一个放置图片的DIV：
&lt;div style="text-align: center; vertical-align: middle;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/887de53c250c19a4c537eb0e0e42d7eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f312e3de594c018c823db609d4354312/" rel="bookmark">
			【Java】如何使用jdbc连接并操作MySQL，一文读懂不迷路，小白也能轻松学会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC的原理 JDBC（Java Database Connectivity）是Java提供的用于连接和操作数据库的API。它允许Java应用程序与各种数据库进行交互，以下是JDBC的基本原理：
驱动程序管理：JDBC使用不同的数据库驱动程序来连接不同类型的数据库。每种数据库都有相应的JDBC驱动程序，负责处理Java应用程序与数据库之间的通信。常见的驱动程序类型包括：
JDBC-ODBC桥接驱动：将JDBC调用转换为ODBC调用。原生API驱动：通过特定数据库的API直接连接数据库。网络协议驱动：通过中间层（如应用服务器）以网络协议访问数据库。 建立连接：应用程序通过DriverManager获取数据库连接。一般步骤包括：
注册数据库驱动。使用DriverManager.getConnection()方法获取连接对象。 执行SQL语句：获取到连接后，可以通过Connection对象创建Statement或PreparedStatement对象，来执行SQL语句。在执行过程中，SQL语句会被发送到数据库，并返回结果集。
处理结果：执行完SQL语句后，结果通常会以ResultSet对象的形式返回。开发者可以通过ResultSet对象读取查询结果，并进行相应处理。
事务管理：JDBC支持对数据库的事务管理。可以通过Connection对象的方法来手动控制事务，比如提交、回滚等。
关闭资源：操作完成后，应该关闭ResultSet、Statement和Connection等资源，以防止内存泄漏。
总体来说，JDBC提供了一种与数据库进行交互的标准方式，使得Java程序能够高效地访问和操作各种数据库，同时保持良好的跨平台性。
JDBC优势：
Java语言访问数据库操作完全面向抽象接口编程。开发数据库应用不用限定在特定数据库厂商的API。程序的可移植性大大增强。 JDBC的使用 1.准备数据库驱动包，并添加到项目的依赖中 如何下载驱动包 我推荐一个官方网址：中央仓库
打开网址后在上方搜索 “mysql”
搜索完，出现以下选项，选择第二个进入。
进入该页面后，我们发现有各种版本的驱动包。
那么我们如何选择版本呢？这取决于你的MySQL版本 ，如果你的MySQL版本是8.0，那么选择8.0x系列的，如果你的MySQL版本是5.1，那么选择5.1x系列的。这里我的MySQL是5.1版本，我用5.1x系列做一个示例。
下滑找到你所需要的版本并点击，这里我下载的是5.1.49版本。
接着我们进入下一个界面，找到 “jar” 字样，点击即可下载。
将驱动包添加到项目依赖 我们下载好驱动包就要将其添加到项目依赖了，接下来跟着我的操作。
我们打开IDEA，右击项目文件，选择新建 "Directory" 模块。
我们一般将该模块名取为 “lib” ，用来存放第三方库。
接下来找到你的驱动包 “CTRL + C” 复制，接着到IDEA中选中 "lib" 模块 “CTRL + V” 粘贴，操作完后呈现以下状态。选择 ok 就好了。
接下来我们还有最后一步操作，右击该驱动包，选择 “Add as Library...”
最后操作完呈现以下状态既是成功了。
2.建立数据库连接 Connection接口实现类由数据库提供，获取Connection对象通常有两种方式：
一种是通过DriverManager（驱动管理类）的静态方法获取： //注册数据库驱动： 加载适当的数据库驱动程序，可以通过反射方式来加载。 try { Class.forName("com.mysql.cj.jdbc.Driver"); // MySQL数据库示例 } catch (ClassNotFoundException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f312e3de594c018c823db609d4354312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5886b57439e2de1f3f297572c8939d8b/" rel="bookmark">
			LearnOpenGL——几何着色器、实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LearnOpenGL——几何着色器、实例化 几何着色器一、一个例子二、建造几个房子三、爆破物体四、法向量可视化 实例化一、实例化数组二、小行星带 几何着色器 在顶点着色器和片元着色器之间还有一个可选的几何着色器，几何着色器输入的是一个图元（点或者三角形）的一组顶点，几何着色器可以在片元着色器之前对它们进行随意变化，可以变换为不同的图元，也可以生成更多的顶点
一、一个例子 这是一个几何着色器，它接受一个点图元作为输入，以这个点为中心，创建一条水平的线图元。
#version 330 core layout (points) in; layout (line_strip, max_vertices = 2) out; void main() { gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0); EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.1, 0.0, 0.0, 0.0); EmitVertex(); EndPrimitive(); } 我们需要声明从顶点着色器输入的图元类型——在in前面加一个布局修饰符（如下），如果我们要绘制三角形，就将修饰符修改为triangles，括号内的数字表示的是一个图元所包含的最小顶点数。
points：绘制GL_POINTS图元（1）lines：绘制GL_LINES或GL_LINE_STRIP（2）line_adjacency：GL_LINE_ADJACENCY或GL_LINE_STRIP_ADJACENCY（4）triangles：GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN（3）triangles_adjacency：GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY（6） 还需要制定几何着色器的输出的图元类型——在out关键字前加布局修饰符，如果要绘制三角形，就将输出定义为triangle_strip，我们还需要设置最大顶点数
pointsline_striptriangle_strip 为了获得前一着色器的输出变量，GLSL提供了一个接口块内建变量
in gl_Vertex { vec4 gl_Position; float gl_PointSize; float gl_ClipDistance[]; } gl_in[]; 使用EmitVertex和EndPrimitive函数来生成新数据
EmitVertex：gl_Position向量会被添加到图元中EndPrimitive：发射出的顶点都会合成为指定的输出渲染图元 二、建造几个房子 我们要绘制许多三角形，就需要把几何着色器的输出设置为triangle_strip（三角形带）。一个三角形带至少需要3个顶点，并会生成N-2个三角形（N为顶点数）
画房子我们需要三个三角形
首先添加Shader.h头文件中构造函数的重载函数，加入几何着色器
再修改points数据，加入颜色数据
float points[] = { -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5886b57439e2de1f3f297572c8939d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3256ee7729d2d18a08cf3449a6fb6c0b/" rel="bookmark">
			C&#43;&#43;第三十六弹---二叉搜索树的性能飞跃：AVL树原理与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1 AVL 树
1.1 AVL树的概念
1.2 AVL树节点的定义
1.3 AVL树的插入
1.4 AVL树的旋转
1.5 AVL树的验证
1 AVL 树 1.1 AVL树的概念 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查
找元素相当于在顺序表中搜索元素，效率低下。因此，两位俄罗斯的数学家G.M.Adelson-Velskii
和E.M.Landis在1962年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。
为什么保证每个结点的左右子树高度之差的绝对值不超过1，而不是高度差为0？
有些结点情况下，比如2/4，做不到平衡，因此退而求其次，左右的高度差不超过1。
一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：
它的左右子树都是AVL树左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1)高度之差 == 右树高度 - 左树高度(博主实现AVL树以这个为标准) 如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在
O(log2 n)，搜索时间复杂度O(log2 n)。
1.2 AVL树节点的定义 AVL树的节点定义的成员变量：
存储值：每个节点存储的值。左节点指针：指向当前节点的左节点的指针。右节点指针：指向当前节点的右节点的指针。双亲节点指针：指向当前节点的双亲节点的指针。根节点的双亲节点指针为空。平衡因子：表示当前节点的右子树高度和左子树高度之差。平衡因子可以为-1、0或1。 AVL树节点的定义： template&lt;class K,class V&gt; struct AVLTreeNode { AVLTreeNode&lt;K, V&gt;* _left;// 左孩子 AVLTreeNode&lt;K, V&gt;* _right;// 右孩子 AVLTreeNode&lt;K, V&gt;* _parent;// 双亲 pair&lt;K, V&gt; _kv; int _bf;// balance factor 平衡因子 AVLTreeNode(const pair&lt;K,V&gt;&amp; kv) :_left(nullptr) ,_right(nullptr) ,_parent(nullptr) ,_kv(kv) ,_bf(0) {} }; AVL树基本结构的定义：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3256ee7729d2d18a08cf3449a6fb6c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28b004ea005095e8449595a8c1282ce/" rel="bookmark">
			Langchain pandas agent - Azure OpenAI account
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：Langchain pandas代理 - Azure OpenAI账户
问题背景： I am trying to use Langchain for structured data using these steps from the official document.
我正在尝试使用 Langchain 处理结构化数据，按照官方文档中的这些步骤进行操作
I changed it a bit as I am using Azure OpenAI account referring this.
我稍作修改，因为我使用的是 Azure OpenAI 账户，并参考了这个。
Below is the snippet of my code - 下面是我的代码片段：
from langchain.agents import create_pandas_dataframe_agent from langchain.llms import AzureOpenAI import os import pandas as pd import openai df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b28b004ea005095e8449595a8c1282ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb66907416381a9d4e38c7acbe00e02a/" rel="bookmark">
			【Godot4自学手册】第四十五节用着色器（shader）制作水中效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节内容，主要学习利用着色器制作水波纹效果，效果如下：
一、搭建新的场景 首先我们新建场景，根节点选择Node2D，命名为Water，给根节点添加两个Tilemap节点，一个命名为Background主要用于绘制地形图，和水中物品；另一个命名为Water，主要用于绘制水波纹。目录结构如下：
Background绘制效果如下：
Water绘制水波纹，将水覆盖的部分全部填满，效果如下：
需要素材的可以在头部点击下载源代码。
二、制作水波纹 1.新建着色器。 选择Water节点，在属性检查器中中找到CanvasItem属性，并在Material-&gt;Material后方选择下拉按钮选择新建ShaderMaterial。然后选中新建的材质球，在Shader属性选择新建着色器，如下：
2.编写代码。 在着色器内编写如下代码：
shader_type canvas_item; uniform sampler2D screen_texture:hint_screen_texture; uniform sampler2D noise_texture:filter_nearest,repeat_enable; uniform float distortion =0.01; uniform vec2 speed = vec2(.5,.2); uniform float wave_strength =0.1; void vertex() { VERTEX.y += sin(TIME); } void fragment() { vec2 uv = UV+speed*TIME; vec2 noise =2.0 * texture(noise_texture,uv).rg - vec2(1,0); COLOR = texture(TEXTURE,UV + noise * wave_strength); COLOR *= texture(screen_texture,SCREEN_UV+noise * distortion); } 3.配置参数。 编写完成代码保存后，检查器中会出现一些参数，noise_texture表示水波纹噪声纹理；distortion表示波动距离；speed表示波动速度；wave_strength表示波动强度。我们主要设置noise_texture，其它默认值。
Noise Texturen 选择新建NoiseTexure2D，展开属性勾选Seamless启用，表示纹理无缝连接；Noise属性选择新建FastNoiseLite，在其属性中将frequency设置为）0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb66907416381a9d4e38c7acbe00e02a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67558561db8293b83006f434c09e9a9/" rel="bookmark">
			使用 nginx 搭建代理服务器（正向代理 https 网站）指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面
前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站
文章目录 简介正向代理 简介ngx_http_proxy_connect_module 介绍 详细步骤包准备Linux 编译并安装 nginx修改 nginx 配置文件nginx 启动与测试 拓展设置 nginx 开机自启动 简介 正向代理 简介 在企业开发环境中，局域网内的设备通常需要通过正向代理服务器访问互联网。正向代理服务器充当中介，帮助客户端请求外部资源并返回结果。局域网内也就是俗称的内网，局域网外的互联网就是外网，在一些特殊场景内，例如：医院。而局域网中的客户端要访问这些资源时，就需要通过代理服务器。这种通过代理服务器访问外部网络资源的方式，就是正向代理。正向代理不仅用于提升访问速度，还能提高网络安全性、管理访问权限和优化网络流量。
原生 nginx 可以作为 http 的正向代理服务器，但是不能用做 https 的正向代理服务器。因为 http 正向代理使用的是 get 请求，但是 https 使用的确实 connect 请求，而原生 nginx 不支持 connect 请求。所以需要第三方模块 ngx_http_proxy_connect_module 来支持 https 的正向代理，使用这个插件，意味着需要重新编译 nginx，在编译的过程中，将插件添加进去。本次编译以目前稳定版 1.24.0 为例。
ngx_http_proxy_connect_module 介绍 ngx_http_proxy_connect_module 项目地址：传送门（注：目标地址为 github，打不开则请科学上网）
ngx_http_proxy_connect_module 是 Nginx 的一个扩展模块，主要功能是允许 Nginx 作为代理服务器处理 CONNECT 方法。通过该模块，可以将 Nginx 作为 HTTP/HTTPS 代理服务器，甚至可以直接用作 WebSocket 服务器。
注：在 HTTP 协议中，CONNECT 方法主要用于建立隧道（即建立到远程服务器的端到端的加密连接），通常在代理服务器后面的客户端需要通过代理服务器与目标服务器建立安全连接，比如 WebSocket 连接和 HTTPS 的中间人代理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b67558561db8293b83006f434c09e9a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927f597bd33bd51367abc33f29486c1c/" rel="bookmark">
			屏幕适配方案——详细完整版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用框架：Vue2/Vue3
适用设备：pc端/移动端
适配策略：动态rem+动态scale
方案效果：可让页面在不同屏幕下、放大缩小时保持页面不变形
效果示例：
当屏幕变化时：
当放大缩小时：
安装屏幕适配插件
npm i screen-adapter-plugin 适配写法(推荐)：
写class样式时，使用px单位，class内的px单位编译后会转成rem；内联样式需要用px函数px(12)转为rem，px函数已经挂载在Vue的this上。
若想让class样式不被转为rem，可使用.norem-开头的class名称，其大括号范围内所有样式不会被转为rem，或使用大写的PX单位(需要按文档配置postcss.plugin)
rem只随视口的宽度动态调节，若想让元素高度随视口高度变化，可使用vh、%或其他单位
内部无法转为rem的插件，例如echarts、relation-graph等，可在元素上绑定v-scale。
v-scale适合内部没有rem单位的元素，通过transform的scale属性让该元素宽高随视口的宽度自适应。
它还可以传入一个监听函数，第一个参数为绑定该指令的元素dom，第二个参数为该元素被放大的倍数，其在视口变化时会自动执行
// 使用方法一，例如echarts元素 &lt;div ref="echartsRef" style="width: 500px;height: 400px;" v-scale&gt;&lt;/div&gt; // 使用方法二，传入监听函数 &lt;div ref="echartsRef" style="width: 500px;height: 400px;" v-scale=="handlerAdaptScale"&gt;&lt;/div&gt; methods: { handlerAdaptScale(el, scale) { // do sth... }, } typescript注解：
// px函数注解，可转换为rem，或在第二个入参传入true，获得动态number类型的px type PX = (px: number, real: boolean) =&gt; string | number // Vue.use时传入的options interface InstallOptions { rootValue: number } // 插件提供的方法 interface ScreenAdapter { rootFontSize: number // 根元素上动态的font-size init(): void // Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/927f597bd33bd51367abc33f29486c1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e85e1e9b95ffb3555bafa7679dc1e2/" rel="bookmark">
			手撕初阶数据结构之---排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.排序概念及运用 排序：所谓排序，就是使⼀串记录，按照其中的某个或某些关键字的⼤⼩，递增或递减的排列起来的操作。
常见的排序算法
直接插入排序的时间复杂度是O(N^2)
这个是最差的情况下，就是大的在前面，小的在后面
希尔排序就是直接插入排序的优化版本
将时间复杂度优化为O(N^1.3)
时间选择排序是雷打不动的O(N^2)
堆排序是O(N logN)
冒泡排序是O(N^2)
在数组有序的情况下我们能优化成O(N)，但是这种情况很少见
2.常见排序算法 1.插入排序 1.直接插入排序 当插⼊第 i(i&gt;=1) 个元素时，前⾯的 array[0],array[1],…,array[i-1] 已经排好序，此时⽤ array[i] 的排序码与 array[i-1],array[i-2],… 的排序码顺序进⾏⽐较，找到插⼊位置即将 array[i] 插⼊，原来位置上的元素顺序后移
现在我们有一堆的数字，现在我们一个一个进行比较，只要我们发现后面的值比前面的值大，那么我们就把前面的值放到当前的位置，继续往前进行比较,那么这么就会导致前面遍历过的内容都是有序的，将后面乱序的数字一个个插入到前面有序的序列中，使其变得有序
这种思想和打牌是一样的
给出一个数组10 9 8 7 6 5 4 3 2 1
现在我们要变为升序
我们创建变量tmp
先将9存在tmp中，将9与10进行比较，如果9比10小的话，那么就将10挪到9的位置
然后用tmp为第一个位置重新赋值，那么第一个数字就是9
然后我们前两个数字就是有序的数列
然后依次从后面拿数字到前面进行比较
//2 5 8 1 5 6 //直接插入排序 void InsertSort(int* arr, int n) { //i最后一次是n-2，对应数组中倒数第二个数字 for (int i = 0; i &lt; n-1; i++) { //i不能小于n，假设n=10 //那么i&lt;9 //当end=8时，那么tmp就是9，那么就存在越界行为了 int end = i;//end从0开始 int tmp = arr[end + 1];//有序区间的后一个数字 while (end&gt;=0) { //比较 if (arr[end] &gt; tmp)//end位置的数据大于tmp，那么tmp往前走 { arr[end + 1] = arr[end];//将end位置的数据往后挪 end--; } else//end位置的数小于tmp位置的，我们就跳出循环 { break; } } //此时的end就小于0，跳出循环 arr[end + 1] = tmp; } } 在内层循环中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e85e1e9b95ffb3555bafa7679dc1e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ec867813ce0205ff26aaa58e7e3620/" rel="bookmark">
			【国内超大型智能算力中心建设白皮书 2024】_智算中心算力规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末有福利！
智算中心建设通过领先的体系架构设计，以算力基建化为主体、以算法基建化为引领、以服务智件化为依托，以设施绿色化为支撑，从基建、硬件、软件、算法、服务等全环节开展关键技术落地与应用。
一、体系架构
（一）总体架构
图8 智算中心总体架构
智能算力中心建设白皮书，重点围绕基础、支撑、功能和目标四大部分，创新性地提出了智算中心总体架构。
其中，基础部分是支撑智算中心建设与应用的先进人工智能理论和计算架构；支撑部分围绕智算中心算力生产、聚合、调度、释放的作业逻辑展开；功能部分提供算力生产供应、数据开放共享、智能生态建设和产业创新聚集四大平台，以及数据、算力和算法三大服务；整体目标是促进AI产业化、产业AI化及政府治理智能化。
（二）技术演进
智算中心的发展基于最新人工智能理论和领先的人工智能计算架构，算力技术与算法模型是其中的关键核心技术，算力技术以AI芯片、AI服务器、AI集群为载体，而当前的算法模型发展趋势以AI大模型为代表。
在此基础上，通过智算中心操作系统作为智算中心的“神经中枢”对算力资源池进行高效管理和智能调度，使智算中心更好地对外提供算力、数据和算法等服务，支撑各类智慧应用场景落地。而软件生态则是智算中心“好用、用好”的关键支撑。
1．AI芯片
基于AI芯片的加速计算是当前AI计算的主流模式。AI芯片通过和AI算法的协同设计来满足AI计算对算力的超高需求。当前主流的AI加速计算主要是采用CPU系统搭载GPU、FPGA、ASIC等异构加速芯片。
AI计算加速芯片发端于GPU芯片，GPU芯片中原本为图形计算设计的大量算术逻辑单元（ALU）可对以张量计算为主的深度学习计算提供很好的加速效果。随着GPU芯片在AI计算加速中的应用逐步深入，GPU芯片本身也根据AI的计算特点，进行了针对性的创新设计，如张量计算单元、TF32/BF16数值精度、Transformer引擎（Transformer Engine）等。
近年来，国产AI加速芯片厂商持续发力，在该领域取得了快速进展，相关产品陆续发布，覆盖了AI推理和AI训练需求，其中既有基于通用GPU架构的芯片，也有基于ASIC架构的芯片，另外也出现了类脑架构芯片，总体上呈现出多元化的发展趋势。但是，当前国产AI芯片在产品性能和软件生态等方面与国际领先水平还存在差距，亟待进一步完善加强。总体而言，国产AI芯片正在努力从“可用”走向“好用”。
2．AI服务器
AI服务器是智算中心的算力机组。当前AI服务器主要采用CPU+AI加速芯片的异构架构，通过集成多颗AI加速芯片实现超高计算性能。
目前业界以NVLink和OAM两种高速互联架构为主，其中NVLink是NVIDIA开发并推出的一种私有通信协议，其采用点对点结构、串列传输，可以达到数百GB/s的P2P互联带宽，极大地提升了模型并行训练的效率和性能。
OAM是国际开放计算组织OCP定义的一种开放的、用于跨AI加速器间的高速通信互联协议，卡间互联聚合带宽可高达896GB/s。
浪潮信息基于开放OAM架构研发的AI服务器NF5498，率先完成与国际和国内多家AI芯片产品的开发适配，并已在多个智算中心实现大规模落地部署。
3．AI集群
**AI集群的构建主要采用低延迟、高带宽的网络互连。**为了满足大模型训练常用的数据并行、模型并行、流水线并行等混合并行策略的通信需求，需要为芯片间和节点间提供低延迟、高带宽的互联。另外，还要针对大模型的并行训练算法通信模式做出相应的组网拓扑上的优化，比如对于深度学习常用的全局梯度归约通信操作，可以使用全局环状网络设计，配置多块高速网卡，实现跨AI服务器节点的AI芯片间RDMA互联，消除混合并行算法的计算瓶颈。
**AI集群的构建需要配置面向AI优化的高速存储。**通过配置高性能、高扩展、多层级的智能存储，为各种数据访问需求提供优化性能。智能存储具备随需扩展功能，实现高IOPS处理能力，支持RDMA技术，同时实现高聚合带宽。
4．AI大模型
**超大规模智能模型，简称大模型，是近年兴起的一种新的人工智能计算范式。**和传统AI模型相比，大模型的训练使用了更多的数据，具有更好的泛化性，可以应用到更广泛的下游任务中。按照应用场景划分，AI大模型主要包括语言大模型、视觉大模型和多模态大模型等。
**自然语言处理是首个应用大模型的领域，BERT是大模型的早期代表。**随着大模型在自然语言的理解和生成领域成功应用，推动了语言大模型向更大的模型参数规模和更大训练数据规模的方向发展。当前，语言大模型的单体模型参数已经达到千亿级别，训练数据集规模也达到了TB级别，训练所需计算资源超过1000PetaFlop/s-day（PD）。业界典型的自然语言大模型有GPT-4、源、悟道和文心等。自然语言大模型已经广泛应用于个人知识管理、舆情检测、商业报告生成、金融反欺诈、智能客服、虚拟数字人等场景，同时也出现了一系列的创新应用场景，如剧本杀、反网络诈骗、公文写作等。
5．智算OS
智算OS，即智算中心操作系统，是以智算服务为对象，对智算中心基础设施资源池进行高效管理和智能调度的产品方案，可以使智算中心更好地对外提供算力、数据、算法、智件等服务，有效降低算力使用门槛，提升资源调度效率，支撑各类智慧应用场景落地，是智算中心的“中枢神经”。
智算OS主要由三层架构构成，分别为基础设施层、平台服务层、业务系统层。基础设施层主要实现将异构算力、数据存储、框架模型等转化为有效的算力与服务资源，算力资源池能够聚合并进行标准化和细粒度切分，以满足上层不同类型智能应用对算力的多元化需求，并通过异构资源管理和调度技术，提升可同时支撑的智算业务规模。
智算OS以智算中心为载体，通过建设多元、开放的智算平台，融合国际、国内先进人工智能技术，形成标准化、模块化的模型、中间件及应用软件，以开放接口、模型库、算法包等方式向用户提供如行业大模型、自动驾驶、元宇宙、智慧科研等人工智能服务，促进人工智能技术成果的开放与共享，构建开放的智算生态。
二、技术路线
智算中心建设的关键技术涉及与其建设和应用相关的各类基建、硬件、软件，体现在智算中心算力基建化、算法基建化、服务智件化、设施绿色化过程中。
（一）以算力基建化为主体
以智算中心为代表的算力基础设施能够有效促进AI产业化和产业AI化，是支撑数字经济发展的重要基础底座。为了让AI真正地赋能到千行百业，并推动产业数字化转型发展，智算中心要具备对外提供高性价比、普惠、安全算力资源的能力，使AI算力像水、电一样成为城市的公共基础资源，供政府、企业、公众自主取用。算力基建化供给成为支撑产业转型升级以及创新发展的刚性需求和必然选择。
面向潜在算力需求，适度超前规模化部署算力资源数据量的爆炸式增长以及万亿参数大模型的出现，使智能算力需求呈现高速增长态势，并为算力基础设施带来巨大挑战。**在数据量方面，IDC发布的《数据时代2025》预测，到2025年，全球数据量将达到175 ZB，而中国数据量的平均增速快于全球3%，预计到2025年将增至48.6 ZB，占全球数据圈的27.8%。在模型方面，当前1万亿参数的单体模型需要1EFLOPS级算力（FP16）计算约50天，10万亿参数的单体模型需要10 EFLOPS级算力（FP16）计算约50天。因此在智算中心的规划建设中，需要聚焦当前算力应用需求，同时面向未来数据量和大模型大参数量增长空间，适度超前，部署满足AI训练、AI推理等大规模计算需求的强大AI算力机组，构建算力集群，提供大规模弹性算力。
（二）以算法基建化为引领
建设适度超前的算力基础设施，不仅体现在算力层面，也体现在算法层面，这是释放算力环节的关键。人工智能算法正面临着丰富化、专业化和巨量化的挑战，智算中心通过提供预置行业算法、构建预训练大模型、推进算法模型持续升级、提供专业化数据和算法服务，让更多的用户享受普适普惠的智能计算服务。
**1．面向千行百业发展需求，提供多类型预置行业算法AI落地面临开发成本、技术门槛高的难题，算法模型平均构建时间为3个月，同时算法还需要快速的迭代，再加上AI新算法、新理论层出不穷，行业用户的智慧转型存在着巨大的技术壁垒。**智算中心应围绕政务服务、智慧城市、智能制造、自动驾驶、语言智能等重点领域，在AI平台内预置实例分割、目标检测、边缘检测、图像分类、人脸识别、视频感知、自动问答、机器翻译、舆情分析、情感分析、语音识别、协同过滤、交通路线规划等常用行业算法模型，并从硬、软件对行业算法做性能优化，从而帮助各行各业智慧应用加速落地，推动行业智能化转型加速。
**2．面向模型即服务应用需求，构建大规模预训练AI模型在产业AI化和数实融合的背景下，当前的行业做法是针对每一个场景都做一个模型，即“有1万个场景就有1万个模型”。**然而随着以BERT、GPT-3、DALL·E、源1.0等为代表的高泛化能力和高通用性的大模型的出现，一个模型可以覆盖众多场景。“预训练大模型+下游任务微调”的AI工程化模式已成为业内共识，层数、隐向量长度、前馈网络尺寸持续增长，参数规模迅速从亿级增长到百万亿级。
在充足数据和算力的支持下，大模型可以充分学习文本、图像等数据中的特征。智算中心应通过部署大模型所需要的训练、推理和数据处理系统，构建出不同功能、不同模态的大模型（如自然语言处理大模型、视觉大模型、多模态大模型等），从而更加快速地生产出专业的技能模型，并在更多专业场景中实现小型化、轻量化的落地运作。
（三）以服务智件化为依托
随着人工智能应用场景持续拓展和开发用户不断普及，对智能计算需求大幅提升、算法模型功能不断强化的同时，人工智能算法开发和模型训练正在从专业化、高门槛向泛在化、易用型转变，智算中心的发展将由传统的硬件、软件向“智件”升级拓展。“智件”是指智算中心提供人工智能推广应用的中间件产品和服务。
传统用户进行人工智能应用时，除了需要提供业务数据，还需提供算法模型并进行代码开发，“智件”的构建可以改变这种服务模式，通过可视化操作界面，以及低代码开发甚至无代码开发的模式，为用户提供功能丰富、使用便捷的人工智能算力调度、算法供给和个性化开发服务，实现“带着数据来、拿着成果走”的效果。
2．提供简便算法模型服务，实现算法供给“智件化”人工智能是一门极其复杂的学科，要求应用开发者不仅要有扎实的理论功底，还要有高超的编程技术，门槛极高。算法模型是人工智能应用的灵魂，也是智算中心提供服务的主要输出物。从计算智能到感知智能，再到认知智能，人工智能的应用模型越来越复杂，从公共服务到社会治理再到产业发展，人工智能的应用需求越来越广泛，对人工智能模型和算法的要求也越来越高。
为了缓解人工智能模型训练成本高、技术门槛高的问题，智算中心应加强算法供给服务模式的创新，开发可视化操作界面，用户通过API、模块化代码即可获得所需的人工智能应用效果，减轻代码开发压力，使用户无需关注算法和模型本身的复杂技术细节，只需聚焦相应业务领域的业务逻辑和数据就能实现人工智能应用。用户可以基于“智件化”的算法模型进行探索和创新，开发出适用于各种场景的新型智能应用。
3．提供开放生态环境服务，实现供需对接“智件化”人工智能场景日趋丰富，应用需求和技术供给个性化特征明显，为满足部分用户和场景对于人工智能算法优化、系统优化服务的个性化需求，智算中心应构建开放合作生态，加大数据资源供给，聚焦先进的技术并适配典型场景应用。一方面，加大数据供给，数据是人工智能应用的基础，智算中心应打造数据共享平台，推动计算机视觉、自然语言处理、重点行业领域等高质量公开数据集的汇聚，为用户人工智能应用提供增值性数据服务。另一方面，开放发展生态，围绕满足不同用户个性化人工智能应用需求，智算中心应将其计算平台、资源平台和算法平台对外开放，聚集行业内领先企业的力量，及时响应用户个性化需求，提升智算中心技术能力的同时形成新的产业和生产力。
（四）以设施绿色化为支撑
能耗是衡量智算中心发展水平的重要维度之一。“碳达峰、碳中和”目标背景下，国家和地方持续出台政策，进一步规范数据中心的能耗水平和平均电能利用效率（PUE）。为了进一步降低智算中心能耗，设施绿色化是智算中心建设的必然选择。设施绿色化主要包括设备节能化、能源供给绿色化等方面。
**1．采用先进节能技术，全面降低智算中心能耗制冷设备和IT设备是智算中心主要的能耗来源。**液冷技术采用冷却液和工作流体对发热设备进行冷却，利用高比热容的液体代替空气，提升了制冷效率，降低制冷能耗。液冷技术是智算中心制冷的主要发展趋势。数据中心采用全栈布局液冷，冷板式液冷、热管式液冷、浸没式液冷等先进液冷技术，构建包含一次侧二次侧液冷循环、CDU等的智算中心液冷整体解决方案，可以进一步降低能耗、降低PUE，实现绿色化。液冷智算中心采用余热回收技术，可以为智算中心自身以及邻近区域供暖，进一步提升能源利用效率。此外，智算中心采用高压直流、集中供电等高效供配电系统、能效环境集成检测等高效辅助系统、智能监控运维系统等绿色管理系统可以进一步降低能耗。
2．采用绿色清洁能源，从源头上实现绿色低碳
一方面，智算中心的大部分业务负载，特别是企业负载，在时间上主要集中于白天工作时段，与光伏、风电的主要发电时段匹配性较高，无需过多储能与调峰，使得智算中心在运用光伏、风电等绿色电力方面具有天然优势。采用绿色电力供给的智算中心综合运用线性规划、混合整数规划、启发式算法等多种能耗管理方法，可以在降低碳排放的同时也节约电价成本。智算中心采用优化调度与需求响应控制策略，还可作为需求侧可调载荷参与电力需求侧响应，不仅提升智算中心自身能源利用效率，而且提升新型电力系统需求侧资源优化配置效率。
另一方面，智算中心所在的建筑物、园区空间大，可以充分利用，发展屋顶光伏、园区风电等可再生能源发电设施，优化能源绿色供给格局。应用分布式光伏发电、分布式燃气供能等技术可以提升智算中心园区绿色化水平。小型智算中心还可以利用模块化氢燃料电池、太阳能板房等技术优化能源供给格局。
一、智算中心激发AI产业化创新活力
（一）自动驾驶
**自动驾驶是汽车智能化和自动化的高级形态，作为AI技术备受关注的重要落脚点，被公认是汽车出行产业的未来方向之一。**自动驾驶场景的实现，需要通过感知融合、虚拟路测（模拟仿真）、高精地图、车路协同等核心技术将数字世界与实体路况进行深度融合，基于人工智能技术，让车辆能够像人类驾驶员一样准确地识别车道、行人、障碍物等驾驶环境中的关键信息，并及时对周围运动单元的潜在轨迹做出预判。
（二）机器人
机器人是人工智能技术多领域应用的重要载体，主要分为工业机器人、服务机器人和特种机器人。作为一种重要的智能硬件，随着计算机视觉、机器学习、智能语音等多种智能算法技术的进步，机器人产业也将实现飞速的发展。
《中国机器人产业发展报告（2022年）》数据显示，2022年中国机器人市场规模约为174亿美元，五年年均增长率达到22%，其中工业机器人和服务机器人市场规模均保持增长，二者呈现出齐头并进、快速发展的态势。
虚拟数字人
随着AIGC等AI技术的应用，基于AI算法的自动建模将逐步替代手工建模，成为数字人建模的主要方式。与此同时，基于AI算法的数字人驱动也将逐步替代当前以“中之人”驱动为主的真人驱动方式。与此同时，视觉感知、语音识别和语音合成以及自然语言处理等多种AI算法在数字人中的应用，将推动数字人向“数智人”转变，也是虚拟数字人应用普及的关键。智算中心可以为虚拟数字人制作、感知交互提供强大的算力和算法支撑，加速虚拟数字人产业的商业化落地。
二、智算中心助力产业AI化走深向实
（一）智慧医疗
国家统计局《2021年国民经济和社会发展统计公报》显示，2021年全年总诊疗人次85.3亿人次，基本医疗保险覆盖13.6亿人。然而，各个地区医疗服务水平参差不齐，医疗服务资源不均等现象普遍存在，基层患者尤其是偏远地区的患者难以获得高质量的医疗救治。
AI辅助诊断助力解决诊疗“三大难题”当前，医疗诊断主要面临三大挑战：
一是数据量巨大。粗略估算诊疗人次所对应的就医环节及相应的医疗数据质量，加上血压、心率、体重、心电图等医疗监测数据，规模早已突破TB级，并且以“秒”为单位持续更新叠加，需要强有力的算力支撑平台。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ec867813ce0205ff26aaa58e7e3620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2d5d65d5e6c3788bcd2153c4d616ee/" rel="bookmark">
			【LeetCode：1702】修改后的最大二进制字符串（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接 1702. 修改后的最大二进制字符串 题目描述 给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：
操作 1 ：如果二进制串包含子字符串 “00” ，你可以用 “10” 将其替换。
比方说， “00010” -&gt; “10010”
操作 2 ：如果二进制串包含子字符串 “10” ，你可以用 “01” 将其替换。
比方说， “00010” -&gt; “00001”
请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。
示例 1：
输入：binary = “000110”
输出：“111011”
解释：一个可行的转换为：
“000110” -&gt; “000101”
“000101” -&gt; “100101”
“100101” -&gt; “110101”
“110101” -&gt; “110011”
“110011” -&gt; “111011”
示例 2：
输入：binary = “01”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b2d5d65d5e6c3788bcd2153c4d616ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56944bc6dd68ccd4d33b55d90791b634/" rel="bookmark">
			WPF中RenderTransform，LayoutTransform区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RenderTransform
RenderTransform 是在渲染阶段应用的变换。它不会影响控件的布局，只会影响控件的外观。常用于动画和视觉效果。
• 应用时机：在控件已经完成布局之后。
• 影响范围：仅影响控件的外观，不影响布局。
• 常见用途：旋转、缩放、平移、倾斜等视觉效果。
LayoutTransform
LayoutTransform 是在布局阶段应用的变换。它会影响控件的布局，并且会触发重新布局。常用于需要影响布局的变换。
• 应用时机：在控件布局之前。
• 影响范围：影响控件的布局和外观。
• 常见用途：旋转、缩放等需要影响布局的变换
案例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8bed6ce040cdd5884ebb40fe4fd3f9/" rel="bookmark">
			使用PAI × LLaMA Factory 微调 Llama3 模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动地址：使用 PAI × LLaMA Factory 微调 Llama3 模型实现角色扮演
活动时间：7月25日- 9月1日
活动任务：使用 PAI 平台及 LLaMA Factory 训练框架完成模型的中文化与角色扮演微调和评估，搭建专属“ AI 诸葛亮”问答机器人，7×24小时为你出谋划策！
活动玩法 1.热门任务 完成PAI × LaMA Factory 微调 Llama3 模型实验体验，搭建专属“ AI 诸葛亮”问答机器人，并上传对话截图，即可领取户外运动腰包（限量200个），先到先得。
2. 邀请挑战 邀请好友完成任务一场景体验，参与PK赢取大奖！
※ 详情可见活动规则
教程简述 LLaMA Factory是一款开源低代码大模型微调框架，集成了业界最广泛使用的微调技术，支持通过Web UI界面零代码微调大模型，目前已经成为开源社区内最受欢迎的微调框架，GitHub星标超过2万。本教程将基于Meta AI开源的Llama-3 8B模型，介绍如何使用PAI平台及LLaMA Factory训练框架完成模型的中文化与角色扮演微调和评估。
本教程使用PAI ×LLaMA Factory 微调 Llama3 模型后，问答机器人模仿诸葛亮的语气对话效果如下：
基于本教程可以体验：
👍新用户可免费领取价值万元的人工智能平台PAI试用资源
👍学会如何快速在阿里云上创建一个交互式训练开发环境
👍学会如何在DSW中基于LLaMA Factory训练框架完成模型的中文化与角色扮演微调和评估
👍学会如何在WebUI中进行知识问答
答疑交流群 如需技术支持，请在钉钉搜索群号「52485000325」，加入群聊
实验教程 准备环境和资源 领取交互式建模PAI-DSW免费试用权益，并准备PAI工作空间 前往活动页面，领取交互式建模PAI-DSW产品免费试用资源包
对于交互式建模 PAI-DSW 的新用户，阿里云提供了5000CUH 的免费试用资源，可以在活动页面中直接领取（试用规则请参照阿里云免费试用：https://free.aliyun.com/）；或可以购买交互式建模 PAI-DSW 资源包参与活动，购买链接：PAI-DSW 100CUH资源包，价格 59 元起；如不购买资源包，PAI-DSW 会按量进行计费，计费标准详见阿里云产品定价。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad8bed6ce040cdd5884ebb40fe4fd3f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40aec8cd24844834e081a6b42f3c9398/" rel="bookmark">
			大数据-84 Spark 集群 RDD创建 RDD-Transformation操作算子 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（已更完）Spark（正在更新！） 章节内容 上节我们完成了如下的内容：
RDD的介绍RDD的特点、特点介绍Spark 编程模型的介绍 RDD 的创建 SparkContext SparkContext是编写Spark程序用到的第一个类，是Spark的主要入口点，它负责和整个集群的交互。
如果把Spark集群当做服务端，那么Driver就是客户端，SparkContext是客户端的核心SparkContext是Spark对外的接口，负责向调用者提供Spark的各种功能SparkContext用于连接Spark集群、创建RDD、累加器、广播变量 从集合创建RDD 我们在集群的节点上启动 Spark-Shell 进行学习和测试
spark-shell --master local[*] 如果顺利启动，你就可以看到如下的画面：
尝试运行如下的指令，感受一下
Using Scala version 2.12.10 (OpenJDK 64-Bit Server VM, Java 1.8.0_412) Type in expressions to have them evaluated. Type :help for more information. scala&gt; val rdd1 = sc.parallelize(Array(1,2,3,4,5)) rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at &lt;console&gt;:24 scala&gt; rdd2.getNumPartitions res1: Int = 2 scala&gt; rdd2.partitions.length res2: Int = 2 scala&gt; val rdd3 = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40aec8cd24844834e081a6b42f3c9398/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b60fc68e17be3e8f4c6b893d3d5a0e/" rel="bookmark">
			【Qt】QWidget的windowIcon属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QWidget的windowIcon属性 windowIcon表示窗口的图标 当我们使用默认的windowIcon的时候，其窗口的图标如下：
API说明 windowIcon()
获取到控件的窗⼝图标. 返回 QIcon 对象.
setWindowIcon(const
QIcon&amp; icon)
设置控件的窗⼝图标.
在Qt中，Qt把涉及到的相关概念，都封装成了类，QIcon就表示一个图标。同样的，这俩个API类似于windowTitle，只能针对顶层窗口使用，这里主要使用setWindowIcon函数。
例子：设置窗口图标 首先需要先准备一张图片：
这里需要将QIcon设置在栈上。
之前在使用QPushButton这些控件的时候，推荐使用堆来创建对象，主要是因为要确保当前的控件的声明周期是足够的，需要通过Qt的对象数来释放对象。
而QIcon自身是一个比较小的对象，创建出来以后，就是要设置到某个QWidget里面，QIcon对象本身释放与否，并不影响图标最终的显示。
QIcon也不支持对象数，无法给它执行对象数。
然后给icon进行构造： 【注意】路径中不能带有中文，同时使用"/"作为路径之间的分隔，但是不能使用"\"，这个斜杠的意思在C++中表示转义字符，可以使用"\\"表示。
在C++11中，引入了raw string解决上述问题，其表示字符串中不包含任何转义字符（所有的字符都不会转义）。
r("d:/r");
使用setWindowIcon来设置widget的图标。
但是，通过绝对路径的方式引入图片是不科学的，咱们自己自己写的程序，最终是要发布到用户电脑上的，这里无法确保，开发机上图片的路径和用户电脑上图片的路径完全一致。
因此，相比于使用绝对路径的方式，使用相对路径是更好的。（相对路径，是以给定目录为基准，以.或者..的方式开头）。
但是这种方式也有弊端，就是用户可能将含有图片的文件删除，导致无法找到该图片。
在Qt中，有一个qrc机制：
这个机制就是从根本上解决上述的俩个问题，
1.确保图片所在的路径在目标用户的机器上存在。
2.确保图片不会被用户删除。
需要给Qt项目中引入一个额外的xml文件（后缀名使用.qrc），在这个xml中把要使用的图片资源导入进来，并且在xml中进行记录。后续Qt在编译项目的时候，就会根据qrc中描述的图片信息，找到图片内容，并且提取出图片的二进制数据，把这些二进制数据转成C++代码，最终编译到exe里面。
qrc的缺点：无法导入太大的资源文件。
就比如几个GB的视频文件。
qrc使用的方式 1.在项目中创建一个qrc文件（文件名不要带有中文和特殊符号）
2.把图片导入到qrc文件中
（1）先创建一个“前缀”（Prefix）
所谓的“前缀”可以理解成虚拟的目录，这个目录没有在电脑上真实存在，是Qt自己抽象出来的。（qrc机制本质上就是把图片的二进制数据转成C++代码，最终就会在代码中看到很大的char数组，里面就是图片的二进制数据，为了方便在Qt代码中访问到这个图片，Qt就自己抽象出了虚拟的目录）
直接将prefix的名字改成 / 即可。
（2）把使用的图片文件导入到资源文件中。
此按钮在创建prefix之前是禁用的，创建好prefix之后就可以使用了，添加的文件就是添加到prefix下面的。
点击add Files得到的目录就是当前代码所在的目录。
【注意】导入图片的时候，需要确保导入的图片必须在resource.qrc文件的同级目录，或者同级目录中的子目录里面。
因此，需要把图片文件拷贝到当前项目目录中即可。
看到这个效果，就说明导入成功了。
当代码中需要访问qrc中管理的文件的时候，就需要在路径上带有 : 前缀。
qrc中导入的图片资源，就会被转成qrc_resource.cpp这个C++代码。
这里的字节内容就是图片文件里面的每个字节的数据。
当Qt项目进行编译的时候，这个cpp文件就被一起编译到了exe文件中。当exe程序运行的时候，上述图片的数据也就被加载到内存中了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6cbe448e1c9d0f88445ad7185727ef/" rel="bookmark">
			React&#43;AntDesign做一个日历，Calendar自定义headerRender
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直接贴效果图😄
日历是用的AntDesign提供的Calendar组件，这个组件还是蛮强大的，可以自定义头部时间下拉；渲染每个时间段，或者重置时间段内容，玩的空间是很大的
直接贴代码
第一步：下载js-calendar-converter添加到项目中，用于获取节假日等信息，如果需求没要求 可以不用这个，并将代码中关乎它的相关代码去掉即可
yarn add js-calendar-converter 第二步：页面开发代码如下
import React, { PureComponent } from 'react'; import { Calendar, message, Icon } from 'antd'; import { Moment } from 'moment'; import moment from 'moment'; // @ts-ignore import calendar from 'js-calendar-converter'; import './index.less'; export interface MarketingCalendarPageSettingStates { /** * 开始渲染日历（在改变updateLocale之后渲染，周日才会展示在前面） */ isStartLoadingCalendar: boolean; /** * 目前的时间 */ value: Moment; } export class MarketingCalendarPageSetting extends PureComponent&lt; any, MarketingCalendarPageSettingStates &gt; { constructor(props: any) { super(props); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce6cbe448e1c9d0f88445ad7185727ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c214c0f24ccea3d89d7c5051cb88754/" rel="bookmark">
			使用Flask和Celery实现Python的每月定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每日自动更新各类学习教程及工具下载合集
​​https://pan.quark.cn/s/874c74e8040e​​
在现代Web应用中，定时任务是一个非常有用的功能，可以帮助我们自动执行周期性操作，比如数据备份、报告生成或发送定期通知。结合Flask和Celery，我们可以轻松实现这种定时任务。本文将详细介绍如何在Flask应用中使用Celery来创建一个每月定时执行的任务。
1. 环境准备 1.1 安装依赖 首先，确保你已经安装了Flask和Celery。你还需要一个消息代理（通常是RabbitMQ或Redis）。在这里，我们将使用Redis。同时，我们还需要​​Celery[redis]​​来支持Redis作为消息代理。
pip install Flask Celery redis 1.2 启动Redis 确保Redis服务正在运行。你可以使用Docker来启动Redis：
docker run -p 6379:6379 -d redis 2. 创建Flask应用与Celery配置 2.1 创建Flask应用 首先，创建一个名为​​app.py​​的文件，并设置Flask和Celery：
from flask import Flask from celery import Celery from celery.schedules import crontab app = Flask(__name__) # 配置Celery app.config['CELERY_BROKER_URL'] = 'redis://localhost:6379/0' app.config['CELERY_RESULT_BACKEND'] = 'redis://localhost:6379/0' celery = Celery(app.name, broker=app.config['CELERY_BROKER_URL']) celery.conf.update(app.config) @celery.task def monthly_task(): print("每月任务执行！") # 定义定时任务 @celery.on_after_configure.connect def setup_periodic_tasks(sender, **kwargs): # 每月的第一天的午夜执行任务 sender.add_periodic_task(crontab(day=1, hour=0, minute=0), monthly_task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c214c0f24ccea3d89d7c5051cb88754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6463395cac9dbd77849f8afd0830aed8/" rel="bookmark">
			数组与链表--python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组与链表 一、数组 (一)概述 数组是一种线性结构，将元素存储在连续的内存空间当中，在数组中的元素会有一个位置，我们用索引去记录该位置，这就是一个基本数组的构成。
在python中，数组的概念被列表所替代，内部可以存储不同数据类型的元素，不过实际工作当中，一个列表基本只存储一种数据类型。
(二)一维数组 1、定义数组 一维数组是最简单也是最常用的一种，一般是对一组数据进行存储，每个数据都有他的索引，可以快速的访问该数字。例如：
# 初始化数组(因为python中没有数组概念，所以用列表代替) list_1 = list(int) list_2 = [] list_3 = [1, 2, 3, 4, 5] 以上就是一维数组的正常创建格式，是不是很简单方便。如果我们想要访问某个数组，就可以**数组名[下标]**直接得到目标值。注意：首个元素的索引为0，因为其本质上是内存地址的偏移量，而首个元素的内存地址偏移量为0，所以他的索引为0也是非常合理的。如果对地址计算非常感兴趣，可以自行搜索下内存地址计算公式，本篇不做过多赘述。
2、操作数组 数组属于可变容器类型，这意味着我们可以对数组内的元素做操作，一般来说，我们对数组做的操作无非与增删改查和遍历五个动作。
首先是最简单的遍历：
# 一般采用for或者while来实现对数组的遍历 list_1 = [1, 2, 3, 4, 5] # 这就是一个最简单的遍历，会把所有的元素全部走一遍 for i in list_1: print(i) while i &lt; len(list_1): print(list_1[i]) i += 1 利用循环可以把整个数组都遍历一遍，这样的话我们就能得到数组中的每个元素了，接下来就是给数组增加元素
''' 增： append(要添加的元素) 将元素添加到列表的末尾, 一次只能添加1个元素. extend(容器类型) 将元素添加到列表的末尾, 一次可以添加多个元素. insert(索引, 元素) 在列表的指定位置(索引), 插入元素. ''' # 1. 定义列表 list1 = [10, 20, 30] # 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6463395cac9dbd77849f8afd0830aed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e68824e061208844a4b808a80b7fc7a/" rel="bookmark">
			C 开源库之cJSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cJSON简介 CJSON库是一个用于解析和生成JSON数据的C语言库。 它提供了一组函数，使得在C语言中操作JSON数据变得简单而高效。 您可以使用CJSON库来解析从服务器返回的JSON数据，或者将C语言数据结构转换为JSON格式以进行传输。
cJSON 使用 官网地址：https://sourceforge.net/projects/cjson/
cJSON只有一个cjson.h 和cjson.c 文件，可以很方便的集成到其他项目中。cJSON支持将JSON数据解析为cJSON对象，也支持将cJSON对象转换为JSON数据。cJSON的使用非常简单，只需要包含 cjson.h 头文件，然后调用相应的API即可完成JSON数据的解析和生成。
cJSON 数据生成 新增cjson_demo1.c 文件
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include "cJSON.h" /** * 目标：1、引入cjson 库依赖文件(cJSON.c/cJSON.h) * 2、cjson 库基本使用 */ int main(){ // 第一步：创建cJSON 对象 cJSON *jsonObject = cJSON_CreateObject(); // 第二步：输出cJSON 对象 char *content = cJSON_Print(jsonObject); printf("%s\n", content); // 第三步：cJSON 对象添加属性:基本属性之字符串 cJSON_AddItemToObject(jsonObject, "name", cJSON_CreateString("周志刚")); content = cJSON_Print(jsonObject); printf("%s\n", content); // 第三步：cJSON 对象添加属性:基本属性之整形 cJSON_AddItemToObject(jsonObject, "age", cJSON_CreateNumber(32)); content = cJSON_Print(jsonObject); printf("%s\n", content); // 第三步：cJSON 对象添加属性:基本属性之bool cJSON_AddItemToObject(jsonObject, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e68824e061208844a4b808a80b7fc7a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/47/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>