<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1438bf40a37c394cf3f6200f214350/" rel="bookmark">
			英伟达黄仁勋最新主题演讲：“机器人时代“已经到来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6月2日，英伟达联合创始人兼首席执行官黄仁勋在Computex 2024（2024台北国际电脑展）上发表主题演讲，分享了人工智能时代如何助推全球新产业革命。 黄仁勋表示，机器人时代已经到来，将来所有移动的物体都将实现自主运行。
物理人工智能正引领人工智能领域的新浪潮，它们深谙物理定律，并能自如地融入我们的日常生活。为此，物理人工智能不仅需要构建一个精准的世界模型，以理解如何解读和感知周围世界，更需具备卓越的认知能力，以深刻理解我们的需求并高效执行任务。
展望未来，机器人技术将不再是一个遥不可及的概念，而是日益融入我们的日常生活。当提及机器人技术时，人们往往会联想到人形机器人，但实际上，它的应用远不止于此。机械化将成为常态，工厂将全面实现自动化，机器人将协同工作，制造出一系列机械化产品。它们之间的互动将更加密切，共同创造出一个高度自动化的生产环境。
为了实现这一目标，我们需要克服一系列技术挑战。
这不仅仅是对未来的展望，它正逐步成为现实。
我们将通过多种方式服务市场。首先，我们致力于为不同类型的机器人系统打造平台：机器人工厂与仓库专用平台、物体操纵机器人平台、移动机器人平台，以及人形机器人平台。这些机器人平台与我们其他众多业务一样，依托于计算机加速库和预训练模型。
我们运用计算机加速库、预训练模型，并在Omniverse中进行全方位的测试、训练和集成。正如视频所示，Omniverse是机器人学习如何更好地适应现实世界的地方。当然，机器人仓库的生态系统极为复杂，需要众多公司、工具和技术来共同构建现代化的仓库。如今，仓库正逐步迈向全面机械化，终有一天将实现完全自动化。
在这样一个生态系统中，我们为软件行业、边缘人工智能行业和公司提供了SDK和API接口，同时也为PLC和机器人系统设计了专用系统，以满足国防部等特定领域的需求。这些系统通过集成商整合，最终为客户打造高效、智能的仓库。举个例子，Ken Mac正在为Giant Giant集团构建一座机器人仓库。
接下来，让我们聚焦工厂领域。工厂的生态系统截然不同。以富士康为例，他们正在建设世界上一些最先进的工厂。这些工厂的生态系统同样涵盖了边缘计算机、机器人软件，用于设计工厂布局、优化工作流程、编程机器人，以及用于协调数字工厂和人工智能工厂的PLC计算机。我们同样为这些生态系统中的每一个环节提供了SDK接口。
这样的变革正在全球范围内上演。富士康和Delta正为其工厂构建数字孪生设施，实现现实与数字的完美融合，而Omniverse在其中扮演了至关重要的角色。同样值得一提的是，和硕与Wistron也在紧随潮流，为各自的机器人工厂建立数字孪生设施。
机器人工厂由三个主要计算机系统组成，在NVIDIA AI平台上训练人工智能模型，我们确保机器人在本地系统上高效运行以编排工厂流程。同时，我们利用Omniverse这一模拟协作平台，对包括机械臂和AMR（自主移动机器人）在内的所有工厂元素进行模拟。值得一提的是，这些模拟系统均共享同一个虚拟空间，实现无缝的交互与协作。
当机械臂和AMR进入这个共享的虚拟空间时，它们能够在Omniverse中模拟出真实的工厂环境，确保在实际部署前进行充分的验证和优化。
为了进一步提升解决方案的集成度和应用范围，我们提供了三款高性能计算机，并配备了加速层和预训练人工智能模型。此外，我们已成功将NVIDIA Manipulator和Omniverse与西门子的工业自动化软件和系统相结合。这种合作使得西门子在全球各地的工厂中都能够实现更高效的机器人操作和自动化。
除了西门子，我们还与多家知名企业建立了合作关系。例如，Symantec Pick AI已经集成了NVIDIA Isaac Manipulator，而Somatic Pick AI则成功运行并操作了ABB、KUKA、Yaskawa Motoman等知名品牌的机器人。
机器人技术和物理人工智能的时代已经到来，它们正在各地被广泛应用，这并非科幻，而是现实，令人倍感振奋。展望未来，工厂内的机器人将成为主流，它们将制造所有的产品，其中两个高产量机器人产品尤为引人注目。首先是自动驾驶汽车或具备高度自主能力的汽车，英伟达再次凭借其全面的技术堆栈在这一领域发挥了核心作用。明年，我们计划与梅赛德斯-奔驰车队携手，随后在2026年与捷豹路虎（JLR）车队合作。我们提供完整的解决方案堆栈，但客户可根据需求选择其中的任何部分或层级，因为整个驱动堆栈都是开放和灵活的。
接下来，另一个可能由机器人工厂高产量制造的产品是人形机器人。近年来，在认知能力和世界理解能力方面取得了巨大突破，这一领域的发展前景令人期待。我对人形机器人特别兴奋，因为它们最有可能适应我们为人类所构建的世界。
与其他类型的机器人相比，训练人形机器人需要大量的数据。由于我们拥有相似的体型，通过演示和视频能力提供的大量训练数据将极具价值。因此，我们预计这一领域将取得显著的进步。
现在，让我们欢迎一些特别的机器人朋友。机器人时代已经来临，这是人工智能的下一波浪潮。中国台湾制造的计算机种类繁多，既有配备键盘的传统机型，也有小巧轻便、便于携带的移动设备，以及为云端数据中心提供强大算力的专业设备。但展望未来，我们将见证一个更为激动人心的时刻——制造会走路、四处滚动的计算机，即智能机器人。
这些智能机器人与我们所熟知的计算机在技术上有着惊人的相似性，它们都是基于先进的硬件和软件技术构建的。因此，我们有理由相信，这将是一段真正非凡的旅程！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377c2a158c602cb5c4f0ea10479aa53c/" rel="bookmark">
			从零入手人工智能（1）——卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 本人作为一名单片机工程师，近期对人工智能领域产生了浓厚的兴趣，并开始了我的探索之旅。人工智能是一个博大精深的领域，我相信有许多志同道合的朋友也希望涉足这个领域，因此我写下这篇文章，旨在详细记录我学习人工智能的每一个步骤和心得，希望能为想要入门人工智能的朋友们提供一份入门的指南。为了激发大家的兴趣，我将直接从卷积神经网络这一热门话题入手，带大家领略人工智能的魅力和乐趣。
我们不去深入探讨卷积神经网络底层是如何工作的，而是选择直接通过实践来体验人工智能是如何进行学习和训练的。在这个过程中，我们采取了一种“先上车，再买票”的学习策略，通过这种策略，我们能够通过实践快速上手，然后在后续的学习中逐步深化对知识的理解。
2.开发环境 本代码是在2024年基于当前的编程环境写的，随着技术的快速发展和官方API函数的不断更新，后期可能会出现因API函数修改而导致部分代码编译不通过的情况。
笔者也是借鉴了一位前辈的代码，由于技术的更新，即使是经过验证的代码也可能因为API函数的变化而出现报错。当我们遇到此类问题时，请保持冷静！首先我们可以阅读官方文档，了解API函数的最新变动和更新内容；同时我们可以利用互联网搜索相关的解决方案和修改建议。
我提供了当前代码的开发环境信息，开发环境如下：
python 3.12.2 ancand 2.5.2 jupyter 7.0.8 pandas 2.2.1 numpy 1.26.4 keras 3.3.3 3.准备工作 我们的目标是：对两种不同类型的图片进行识别分类。本代码用卷积神经网络实现了对猫和狗这两类图片的识别分类。为了识别这两类图片，我们需要建立卷积神经网络模型，并用若干张不同的猫和狗的图片训练模型。
在开始构建模型之前，我们需要一定的图片数据集来训练我们的卷积神经网络模型。为了识别猫和狗这两类图片，我们需要在网络上下载并整理这些图片数据。
在这个过程中下载猫和狗图片各35张，保存为JGP格式，我们将这些图片按照特定的组织方式存放到Jupyter工程对应的路径中
upyter 的默认工作目录为：C:\Users\Administrator
在“工程目录”文件夹内我们创建了一个dataset的文件夹，在dataset文件夹中有三个子文件夹：cats、dogs和test。cats文件夹中存放了30张猫的图片，dogs文件夹中存放了30张狗的图片，这些图片将作为训练数据用于模型的学习。而test文件夹则用于存放测试数据，我们存放了5张猫的图片和5张狗的图片，用于评估模型在未见过的数据上的表现。
4.代码实现流程 本代码的核心任务是利用VGG16（经典的卷积神经网络模型）对图片进行特征提取和转换，并将这些转换后的数据作为神经网络的输入进行训练。训练完成后，我们将使用测试图片来验证模型的准确性。
本代码有4个主要步骤：测试VGG16输出数据类型，批量数据预处理，建立模型及训练，测试模型。
4.1.测试VGG16输出数据类型 我们要用VGG16（经典的卷积神经网络模型）对图片进行特征提取和数据转换，随后将得到的转换数据输入到神经网络中。既然要把VGG16转换后的数据输入到神经网络中，那么我们首先需要搞清楚VGG16预处理后的数据格式是什么样的？只有这样我们才能定义数据接口匹配的神经网络模型。
首先加载一张训练图片，并对其进行缩放和归一化，以适应VGG16模型的输入要求。然后使用VGG16模型对图片进行特征提取，最终输出一个包含丰富特征信息的数据，我们查看这个预处理数据类型和大小，方便我们后面构建神经网络模型。
4.2.批量数据预处理 使用VGG16模型对保存不同路径下用于训练的猫和狗的图片进行预处理，并定义一个缓存储存预处理后的数据。
4.3.建立模型及训练 基于VGG16提取的特征向量构建一个神经网络模型，这个模型是一个的全连接网络。我们使用VGG16转换后的数据集来训练这个神经网络模型。在训练过程中，模型会学习从特征向量中识别出图片所属类别。训练完成后，我们会计算模型在训练集上的准确性，以评估其性能。
4.4.测试模型 我们准备了9张独立的测试图片，这些图片在训练过程中是未被使用过的的。使用这些测试图片来验证模型的准确性和泛化能力是非常重要的，因为它可以帮助我们了解模型在新数据上的表现。
将测试图片通过相同的VGG16预处理和特征提取流程，得到对应的特征向量。然后将这些特征向量输入到已经训练好的神经网络模型中，得到模型对每个测试图片的预测结果。
5.代码讲解 将测试我们使用jupyter编程工具，这个工具的最大优势是可以分段运行，下面的代码讲解也是分段描述的，废话不多说，直接上源码。
from matplotlib import pyplot as plt from keras.preprocessing.image import load_img,img_to_array %matplotlib inline #加载图片 转换图片成数组 img_path = 'dataset/test/1.jpg' debug_img = load_img(img_path,target_size=(224,224)) debug_img = img_to_array(debug_img) print(debug_img.shape) #显示图片 fig = plt.figure(figsize=(3,3)) show_img = load_img(img_path,target_size=(224,224)) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377c2a158c602cb5c4f0ea10479aa53c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b37d124d96b1c51379f2ee6e19d993/" rel="bookmark">
			C&#43;&#43; 20新特性之指定初始化器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💡 如果想阅读最新的文章，或者有技术问题需要交流和沟通，可搜索并关注微信公众号“希望睿智”。
聚合初始化 在介绍指定初始化器之前，我们先介绍下C++ 20之前的聚合初始化。聚合初始化允许我们直接在声明对象时以初始化列表的形式初始化所有成员变量，或者只初始化部分成员，其余成员默认初始化。如果我们只想要指定某些成员变量的值，则聚合初始化将无能为力。
#include &lt;iostream&gt; struct Point { int x; int y; int z; }; int main() { // 全部初始化 Point p1{0, 0, 0}; // 部分初始化 Point p2{66, 99}; return 0; } 什么是指定初始化器 为了解决聚合初始化无法指定某些成员变量进行初始化的问题，C++ 20中引入了指定初始化器。指定初始化器允许在初始化结构体、联合体或类的对象时，明确指定成员变量的初始化。这一特性比较适用于大型或复杂的结构体，当我们只想初始化部分成员，或者想明确指出每个成员的初始值时，非常有用。
注意：并非所有的类和结构体都能使用指定初始化器。为了使用该特性，类和结构体必须满足以下两个条件。
1、必须是聚合类型，这就意味着，没有自定义构造函数，没有私有或受保护的非静态数据成员，没有基类，也没有虚函数。
2、所有成员变量必须是公开的。
初始化结构体 结构体的指定初始化器使用.符号紧跟着成员名称，后面跟着=符号，然后是成员的初始值。在下面的示例代码中，我们只显式初始化了x和y。指定初始化器不仅让初始化的意图更加明确，也避免了因成员顺序错误而导致的潜在问题。
struct Point { int x; int y; int z; }; int main() { // 指定初始化器 Point p{.y = 99, .x = 66}; return 0; } 对于嵌套的结构体，指定初始化器也能轻松应对。通过下面示例代码中的指定初始化器，我们可以看到ComplexPoint中每个子结构体成员的具体初始化值，这在处理多层嵌套的数据结构时尤为有用。
struct Point { int x; int y; int z; }; struct Color { int r; int g; int b; }; struct ComplexPoint { Point pt; Color color; }; int main() { ComplexPoint cp{ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b37d124d96b1c51379f2ee6e19d993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f2bd02fddea6dc54ee0dcc3e7eee58/" rel="bookmark">
			oracle中varchar和varchar2的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Oracle数据库中，VARCHAR和VARCHAR2都是用于存储可变长度字符数据的数据类型，但它们之间有一些关键的区别。以下是这两者的主要区别：
数据类型来源：
VARCHAR：这是标准SQL提供的类型，具有广泛的数据库系统兼容性。
VARCHAR2：这是Oracle数据库提供的特定类型，尽管现在一些其他的数据库系统，如高斯和达梦，也支持这种类型。
空字符串处理：
VARCHAR：对空串不进行处理，也就是说，字段可能包含空字符串或真正的空值（NULL）。
VARCHAR2：将空串视为NULL来处理。
字符存储与内存占用：
VARCHAR：对于汉字、数字和英文字符的存储方式，取决于具体的数据库字符集。例如，在GBK字符集下，汉字占两个字节，英文和数字占一个字节。
VARCHAR2：在Oracle 11.2.x版本之前，通常将所有字符都视为两个字节。但从11.2.x版本开始，数字和英文字符改为占一个字节，而汉字的长度则取决于使用的字符集（例如，在UTF-8下，汉字通常占三个字节）。
长度限制：
VARCHAR：其长度限制可能因数据库设置而异，但在Oracle中通常不如VARCHAR2支持的长度长。
VARCHAR2：在Oracle 12版本之前，其最大长度限制为4000个字节；而从Oracle 12版本开始，这个限制增加到了32767个字节。
使用推荐：
如果你的项目不确定是否会一直使用Oracle数据库，那么使用VARCHAR类型可能具有更高的普适性。
如果你的项目确定将一直使用Oracle数据库，那么VARCHAR2类型通常是一个更好的选择，因为它提供了更多的功能和灵活性。
综上所述，VARCHAR和VARCHAR2在Oracle数据库中都有各自的特点和用途。在选择使用哪种类型时，应根据项目的具体需求和所使用的数据库系统来决定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6461aeaa95eec88a33ef02bef8a036ec/" rel="bookmark">
			【微信小程序开发】小程序中的上滑加载更多，下拉刷新是如何实现的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：微信小程序开发零基础教学，难点与应用实战总结
景天的主页：景天科技苑
文章目录 1.上滑加载更多2.下拉刷新3.scroll-view实现上拉加载更多，下拉刷新 1.上滑加载更多 结合上一章我们的项目，先在原来的基础上添加个goods页面
js代码
Page({ data: { good_list: [1, 2, 3] }, // 当滑动到底部还有100rpx时，就会触发这个函数执行---》发送请求获取数据 onReachBottom() { console.log('上拉了') // 发送请求获取数据 wx.request({ url: 'http://127.0.0.1:8000/app01/random/', method:'GET', success:(res)=&gt;{ this.setData({ good_list:this.data.good_list.concat(res.data) }) } }) }, }) ###wxml####
&lt;view wx:for="{{good_list}}" wx:key="*this"&gt;{{item}}&lt;/view&gt; 这样的123不好看没我们设置个样式
###wxss###
view{ height: 400rpx; display: flex; justify-content: center; align-items: center; } /* 奇数背景色是粉色 */ view:nth-child(odd){ background-color: pink; } /* 偶数背景色绿色 */ view:nth-child(even){ background-color: rgb(17, 133, 88); } 现在我们要实现，往上拉，拉到最底部时，显示更多的数字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6461aeaa95eec88a33ef02bef8a036ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6cdab68f7da96f2171658332cd279a6/" rel="bookmark">
			一文教你在k8s中部署单机版kafka（保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐇明明跟你说过：个人主页
🏅个人专栏：《洞察之眼：ELK监控与可视化》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、Kafka简介
2、为什么在Kubernetes中部署Kafka
3、单机版Kafka与集群版Kafka的对比
二、Kubernetes基础知识
1、Kubernetes简介
2、Pods、Deployments、Services等概念介绍
三、准备Kafka部署环境 1、选择Kubernetes集群与配置 2、获取Kafka镜像 四、部署单机版Kafka
1、部署zookeeper
2、部署Kafka
五、测试
1、访问Kafka服务
2、创建第一个Topic 3、kafka-topics.sh工具介绍
一、引言 1、Kafka简介 Kafka是一个分布式流处理平台，最初由LinkedIn开发，随后开源并捐献给了Apache基金会。Kafka的主要设计目标是处理和存储大规模的实时数据流。
Kafka的核心概念
Producer（生产者）：生产者是向Kafka主题（topic）发送消息的客户端应用程序。生产者发布的数据消息被称为记录（records）。Consumer（消费者）：消费者是从Kafka主题中读取消息的客户端应用程序。消费者从指定的主题订阅并消费消息。Topic（主题）：主题是Kafka中的一个逻辑通道，生产者将消息发布到主题，消费者从主题订阅和消费消息。每个主题可以有多个分区（partition），以实现更高的并行处理能力。Partition（分区）：主题中的数据分为多个分区，每个分区是一个有序的、不可变的记录序列。分区通过分布在集群中的不同Kafka代理（broker）上来实现负载均衡和并行处理。Broker（代理）：Kafka集群中的每个服务器节点被称为一个代理。代理负责存储分区数据，并处理来自生产者和消费者的请求。Consumer Group（消费者组）：消费者组是一组协同工作的消费者。每个消费者组订阅一个或多个主题，并分担消费这些主题中的消息。每条消息只会被消费者组中的一个消费者处理。ZooKeeper：Kafka使用Apache ZooKeeper来管理集群配置、选举代理领导以及进行分布式协调。ZooKeeper确保集群的高可用性和一致性。 Kafka的特点
高吞吐量：Kafka可以在低延迟下处理大量的数据流，适合实时大数据处理和流数据分析。可扩展性：Kafka通过添加更多的代理节点来水平扩展集群，支持大规模数据处理。容错性：Kafka通过数据复制机制保证消息的高可用性和容错能力，即使在代理节点故障的情况下，也能继续处理消息。持久化：Kafka将消息持久化到磁盘，确保数据的持久存储和可靠传递。流处理：Kafka Streams API提供了强大的流处理功能，可以在消息流上传输和处理数据，进行实时计算和分析。 Kafka的典型应用场景
日志收集：Kafka可以从不同的应用程序和系统中收集日志，并将它们统一存储和处理。实时分析：通过Kafka将数据实时传输到流处理系统或实时分析平台，进行实时数据分析和监控。事件源：使用Kafka构建事件源架构，实现事件驱动的微服务通信和数据同步。数据管道：Kafka作为数据管道的核心组件，可以将数据从源系统传输到目标系统，如数据库、数据仓库、数据湖等。消息传递：Kafka可以作为消息中间件，处理高吞吐量、低延迟的消息传递需求。 关于更多Kafka的介绍，请参考《大数据领域的重要基础设施——Kafka入门篇（诞生背景与主要特点介绍）》 这篇文章
2、为什么在Kubernetes中部署Kafka 1. 自动化管理和编排
Kubernetes 提供了自动化的部署、扩展和运维管理，这使得管理复杂的分布式系统如Kafka更加容易。Kubernetes可以自动处理容器的启动、停止和重启，确保Kafka集群的高可用性和稳定性。 2. 弹性扩展
Kubernetes具有强大的扩展能力，可以根据需要动态地增加或减少Kafka节点的数量。这种弹性扩展能力对于应对流量波动和负载变化非常重要，能够确保Kafka在高峰期仍然能够高效地处理数据。 3. 高可用性
Kubernetes的自愈功能可以自动检测和恢复故障节点，确保Kafka服务的高可用性。通过Pod的重启和重新调度，Kubernetes能有效应对节点故障和网络问题，保证Kafka集群的持续运行。 4. 资源隔离和管理
Kubernetes的资源管理能力能够确保Kafka集群的资源需求得到满足。通过使用Kubernetes的资源配额和限制，管理员可以确保Kafka实例拥有足够的CPU、内存和存储资源，从而提高系统的性能和稳定性。 5. 部署一致性
Kubernetes的声明式配置使得Kafka的部署变得更加一致和可重复。使用Kubernetes配置文件（YAML/JSON），可以定义Kafka集群的所需状态，Kubernetes会自动将系统调节到该状态。这种声明式配置简化了部署流程，减少了人为错误的可能性。 6. 便捷的服务发现和负载均衡
Kubernetes内置的服务发现和负载均衡功能可以简化Kafka集群的网络配置。Kubernetes服务（Service）可以为Kafka代理提供一个稳定的网络端点，消费者和生产者可以通过该端点访问Kafka集群，而不必关心具体的Pod IP地址。 3、单机版Kafka与集群版Kafka的对比 1. 可靠性
单机版Kafka：在单机环境下运行，如果这台机器发生故障或崩溃，那么Kafka服务将不可用，导致数据丢失或不可用。因此，单机版Kafka的可靠性相对较低。集群版Kafka：通过多台机器组成的集群来运行Kafka，数据会被复制到多个Broker上，实现数据的冗余存储。即使集群中的某个Broker发生故障，其他Broker仍然可以提供服务，确保数据的可靠性和服务的可用性。 2. 可扩展性
单机版Kafka：受限于单台机器的资源（如CPU、内存、磁盘等），单机版Kafka的可扩展性较差。当数据量或并发量增长时，可能会遇到性能瓶颈。集群版Kafka：集群版Kafka可以通过添加更多的Broker来扩展集群的容量和性能。当数据量或并发量增长时，可以通过水平扩展来应对这些挑战，保持系统的稳定性和性能。 3. 性能
单机版Kafka：虽然单机版Kafka在小型应用或测试环境中可能表现出较好的性能，但在处理大规模数据和高并发场景时，其性能可能会受到限制。集群版Kafka：集群版Kafka通过分布式处理和负载均衡来提高整体性能。多个Broker可以并行处理数据，从而提高吞吐量。此外，集群版Kafka还支持数据分区和复制，进一步提高数据处理能力和容错能力。 4. 容错能力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6cdab68f7da96f2171658332cd279a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c4e194ed437fa7f5d8bdb76ebb39e1/" rel="bookmark">
			Spring Boot中实现规则引擎源码教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件开发中，我们经常需要应用一组规则或条件来过滤和处理数据。使用传统的 if 和 else 条件管理这些规则可能会变得繁琐且难以维护。规则引擎提供了一种更灵活、更有条理的方法来定义和执行这些规则。在本文中，我们将探讨如何使用 Java 函数式编程原理在 Spring Boot 项目中构建一个简单的规则引擎。
什么是规则引擎？
规则引擎是一个专家系统程序，它对输入数据运行规则，如果任何条件匹配，则执行相应的操作。
规则引擎负责管理一组规则，并将它们应用于一组对象。它根据定义的规则过滤对象并返回过滤结果。
案例
在这个应用程序中，首先我将创建一个UserController.java类并创建一个返回用户列表的Rest端点。
import com.example.spring_boot_rule_engine_demo.model.User; import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.GetMapping;
import java.util.ArrayList;
import java.util.List;
@RestController
@RequestMapping("/user")
public class UserController {
@GetMapping
public List getAllUser(){ return userData(); } private List userData() { List users = new ArrayList&lt;&gt;(); User user1 = new User("sumit", 33); User user2 = new User("agam", 13); User user3 = new User("mohit", 23); User user4 = new User("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c4e194ed437fa7f5d8bdb76ebb39e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5977c852dc421de01230c8a80f8bf195/" rel="bookmark">
			AI智能体｜一分钟教你学会使用扣子Coze工作流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是无界生长，国内最大AI付费社群“AI破局俱乐部”初创合伙人。这是我的第 38 篇原创文章——《AI智能体｜一分钟教你学会使用扣子Coze工作流》
AI智能体｜一分钟教你学会使用扣子Coze工作流本文详细解释了Coze工作流的基本概念、重要性、优缺点以及如何使用，旨在帮助初学者理解并掌握工作流。如果看完还没学会的话，可以私信我。学会了的话，欢迎转发分享给你的朋友们。https://mp.weixin.qq.com/s?__biz=MzU1MjgyOTA5NQ==&amp;mid=2247484564&amp;idx=1&amp;sn=6ae3c20c89f8cc6cf5be6a0d78630a62&amp;chksm=fbfd6d5ccc8ae44a8a79469e11fc475f979ebe5fbe8091fd8fcef4032de7357b5e67428216de&amp;token=1599214523&amp;lang=zh_CN#rd
很多新手在刚接触Coze工作流的时候，被工作流里面的各种节点、专业术语搞得晕头转向，看不懂、学不会、跟不上成了很多人上手Coze智能体开发的拦路虎。本文尝试从新手小白的角度，由浅入深的讲解Coze工作流的原理及使用，如果你觉得我分享的内容对你有帮助，麻烦关注、点赞、分享、在看，你的支持是我创作的最大动力！
什么是工作流 在使用工作流之前，需要先对工作流有个基本的概念——什么是工作流？通俗点来说，工作流是一个完成预设目标的任务集合。为了更好的处理复杂任务，通常会对目标任务进行拆解，一个工作流中可能会包含多个子任务，每个子任务负责处理一个小的功能点，最后把这些子任务组合起来，就是一个完整的工作流了。
举个例子： 把大象装冰箱，总共三步
第一步，把冰箱门打开
第二步，把大象装进去
第三步，把冰箱门盖上
对应到工作流： 预设目标是把大象装进冰箱
子任务1：把冰箱门打开
子任务2：把大象装进去
子任务3：把冰箱门盖上
把所有子任务组合起来，依次执行子任务，就能把大象装进冰箱。
为什么要用工作流 提升输出结果的准确性、可靠性。
使用工作流其实是把大模型当“人”看，给模型下发任务，执行已有的标准流程，拿到符合预期的结果。
举个例子： 火锅蘸料
用到的调料有，盐，醋，味精，鸡粉，豆瓣酱，白酒，豆豉，醪糟，香料等， 火锅料碗用的有麻酱，蒜泥，豆腐乳，香油，红油，韭菜花，生抽，海鲜酱油，小米椒，香辣酱，花椒，芝麻等。这么多调料，每次调出来的口味可能都不一样，怎么样才能尽可能的保证口味一致呢？如果把各种用料配比记录下来，形成标准流程，是不是就能解决问题了？
工作流的原理类似，通过部署编排的方式，固化流程，从而提升模型输出结果的准确性、可靠性。
使用工作流的优缺点 优点： 处理复杂场景，把目标任务详细拆分，确保逻辑清晰易懂
缺点： 上手有一定难度，对开发者要求较高，需要熟悉各类工作流节点的使用
怎么用工作流 页面概览 使用工作流之前，需要工作流编排页面有个初步的认识，如下图所示
工作流默认包含了开始节点和结束节点。
开始节点：工作流的起始节点，可以包含用户输入信息
结束节点：工作流的末尾节点，用于返回工作流的运行结果
工作流通过在页面进行拖拉拽的方式进行编排，通过对不同节点进行组合来达成预设目标。工作流的编排可以简单理解为搭积木的过程，按需选择节点，插入到开始节点和结束节点之间，配置输入输出参数，通过连线的方式完成组合。
工作流编排完成后，可以通过试运行进行调试，如果不符合预期，可以再对工作流节点进行调整，符合预期就可以进行工作流发布了。
基本流程 使用工作流的基本流程如下：
创建工作流
配置工作流
调试工作流
发布工作流
调用工作流
学习工作流的快捷方式 工作流商店 Coze官方最近上了工作流商店的功能，有不少优质创作者（包括我）在工作流商店上架了自己的工作流，可以通过学习别人是怎么使用工作流的方式，快速上手。
进入工作流商店，点击任意工作流，即可查看对应工作流配置。
我的共创空间 我创建了一个“Coze开发指南”的团队空间，之前文章介绍的工作流会逐步迁移到我的共创空间，之后文章的工作流会直接在共创空间创建。受限于篇幅，工作流的详细使用，这里不过多介绍，可以翻阅文末的往期文章，后续我也会再更新一些工作流相关的文章，敬请关注！
总结 本文详细解释了Coze工作流的基本概念、重要性、优缺点以及如何使用，旨在帮助初学者理解并掌握工作流。如果看完还没学会的话，可以私信我。学会了的话，欢迎转发分享给你的朋友们。
我是无界生长，关注我，带你一起玩转AI！如果你觉得我分享的内容对你有帮助，麻烦点赞、分享、在看，你的支持是我创作的最大动力！
AI学习资料在微信公众号：无界生长，个人微信：wjsz2070
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955218105844c0913138978322ee6088/" rel="bookmark">
			Python 绿色版制作总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、版本 1. 版本分类 Python 版本分为两大流派，两个流派的版本是不通用的，不仅所使用的编码不同，语法上也发生了变化，因此要注意程序所支持的版本。
Python 2.x 版本，2020年1月1日，Python 官方终止了对 Python 2.7 版本（最后一个2.x版本）的支持。Python 3.x 版本，版本还在不断迭代更新。 在同一大版本下，基本通用，除非开发者做出特别说明所支持的最低版本，否则无需最新Python版本。本文的绿化方法适用于 3.x 版本。
3. 绿色便携版 Python 的绿色便携版有两种：官方 Embeddable 版本（嵌入式版）；安装版制作的绿色版。
Embeddable 版适用于需要将 Python 集成到其他应用程序或项目中的情况。它不包含图形界面的安装程序，只提供了 Python 解释器和必要的库文件。安装版包含了 Python 解释器、标准库和其他一些附加组件。它提供了一个图形化的安装界面，可以让用户选择安装的组件，并自动配置系统路径等设置。 Embeddable 版虽然也可以通过移植或安装库以支持正常或者更多的应用，但比较麻烦，因此并不适合普通用户以及日常使用。至少不移植Tkinter的话基于该库开发的GUI工具软件无法显示图形界面。
安装版则完整的多，支持更多使用场景，更适合普通用户及日常使用，因此适合制作普通用户使用的绿色版。
二、制作 1. 下载安装 官网下载：Python Releases for Windows | Python.org
选则 Stable Releases 下的 Windows installer (64-bit) （即稳定、64位安装版），具体版本根据需要选择，一般选最新版即可。
Python 的安装很简单，无需多说，但这里有一个大坑，强烈建议不安装 PIP（原因后面再说）。在功能选则界面取消 PIP 的勾选，如下图：
其他功能组件根据自己的需要选择安装，简单说明一下各组件的功能：
Documentation - 官方文档，全英文，不学习编程的话不用安装。pip - Python 的通用包管理工具，可以很方便地下载软件包。Tcl/TK and IDLE - GUI（图形用户界面）编程库和集成开发环境。这个一定要安装，GUI程序需要用到。Python test suite - Python 自带的测试套件。不编程的话无需安装。py launcher - Windows 的 Python 启动器。这个建议安装，可以双击 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/955218105844c0913138978322ee6088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da481d2261b45aaac96acc84f61c6a26/" rel="bookmark">
			【数据结构】图论中求最短路径——迪杰斯特拉算法（Dijkstra）、弗洛伊德算法（Floyd）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 最短路径 (*)迪杰斯特拉算法（Dijkstra）迪杰斯特拉算法（Dijkstra）的算法原理： 弗洛伊德算法（Floyd）弗洛伊德算法（Floyd）的算法原理：弗洛伊德算法的（c语言）完整实例： 最短路径 (*) 生活中最短路径问题例如：
交通网络：给定了该网内的n个城市以及这些市之间的相通公路的距离，能否找到城市A城市B之间一条最近的通路呢？
从A地到B地换车次数最少的路径从A地到B地最短的路径（距离最短，行驶时间最短，费用最低） 迪杰斯特拉(Dijkstra)算法–从一个源点到其它各点的最短路径弗洛伊德(Floyd)算法–每一对顶点之间的最短路径Bellman-Ford算法 迪杰斯特拉算法（Dijkstra） 该算法只适用于静态网络网络上边的权值不能为负数
基本思想：设集合S中存放已找到最短路径的顶点，集合 T ＝ V − S T ＝V-S T＝V−S存放当前还未找到最短路径的顶点。
1.初态: S中 只包含源点 v0，v0到其余 各点的弧 为各点当前各点的“最短”路径。
2.从T中选取当前各点的“最短”路径长度中最短的顶点u加入到S中。
3.S加入新的顶点u后，考察顶点 v 0 v_0 v0​到T中剩余顶点的最短路径长度是否可以优化更新：T中各顶点新的最短路径长度值为原来的最短路径长度值、顶点u的最短路径长度值加上u到该顶点的路径长度值中的较小值。
4.重复2，3，直到T的顶点全部加入到S中、或源点到剩余顶点的路径都是∞为止。
一、图的存储：邻接矩阵和邻接表都可以
#define max 100 typedef struct { int arcs[max][max]; int vexnum,arcnum; }AGraphs; Agraphs G；//定义图存储结构 邻接矩阵的存储形式 二、区分已经求出最短路径的点
方法一:设一个一维数组int final[max];
final[i]=1表示从源点到顶点i的最短路径已经求出，i在S中
final[i]=0表示从源点到顶点i的最短路径尚未求出，i在V-S中
方法二：利用邻接矩阵主对角线的位置G.arcs[i][i]表示i是否在S中
G.arcs[i][i]=1表示从源点到顶点i的最短路径已经求出，i在S中
G.arcs[i][i]=0表示从源点到顶点i的最短路径尚未求出，i在V-S中
三、表示源点到顶点i的最短路径
一维数组int D[max]表示最短路径的长度
D[i] ：从源点到点 v i v_i vi​的最短路径的长度
初态为：若从源点 到 v i v_i vi​有弧，则D[i]为弧上的权值；否则置 D[i]为∞ ，即：D[i]=G.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da481d2261b45aaac96acc84f61c6a26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d8e68ca1e98f5191d973664b49e7ba/" rel="bookmark">
			【数据结构与算法 经典例题】反转链表(图文详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 💓 博客主页：倔强的石头的CSDN主页 📝Gitee主页：倔强的石头的gitee主页
⏩ 文章专栏：《数据结构与算法 经典例题》C语言
期待您的关注
​
目录
一、问题描述
二、解题思路分析
三、代码实现
一、问题描述 二、解题思路分析 通过三个指针n1,n2,n3来实现链表的反转
1.首先初始化 n1为空 n2指向head n3指向head-＞next
2.然后 让n2的next指针指向n1 完成第一步反转 3. 接下来移动三个指针
n1指向n2
n2指向n3
n3指向n3的下一个节点
4.然后
让n2的next指针指向n1 完成反转 5.循环执行反转和移动指针的过程 直到
n3指向空
n2指向最后一个节点
n1指向倒数第二个节点
6.此时再执行最后一次反转 最后一个节点的next指针指向倒数第二个节点
7.最后一次移动节点 n1指向n2（最后一个节点）
n2指向n3（null）
n3此时已经为空，不能解引用
所以n3指针的移动，要加一个判空的条件
n2作为循环结束的条件
而循环结束时，n1刚好停留在原链表的尾节点，也就是新链表的首节点
三、代码实现 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL) return head;//对空链表做特殊处理 else { struct ListNode* n1, * n2, * n3; n1 = NULL; n2 = head; n3 = n2-&gt;next; while (n2)//当n2指向空时，链表节点已经遍历完成，next指针修改完成 { n2-&gt;next = n1; n1 = n2; n2 = n3; if (n3)//对n3判空，防止对空指针解引用 n3 = n3-&gt;next; } return n1;//当循环结束时，n1是原链表的尾节点，反转后的首节点 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d100b161837440ce227127e3e6c4423c/" rel="bookmark">
			Android音频架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android音频架构 前面《Android音频API》介绍了Android系统提供的四个层面的音频API：
Java层MediaRecorder&amp;MediaPlayer系列；Java层AudioTrack&amp;AudioRecorder系列；Jni层opensles；JNI层AAudio（Android O引入） 本文基于这些API介绍Android系统的音频架构。
下面先上这张经典的Android系统架构图：
从图上看Andorid整个系统层面从下到上分以下四层：
Linux Kernel硬件适配层Framework层（可分为Java层与C++层）APP层 我们上面介绍的四个层面的音频API实现均在Framework层，其他各层音频相关有哪些功能？当我们调用某一API时最终是怎么驱动硬件工作的呢？下面我们先看看系统各层音频相关模块及功能。
1. 各层音频模块 外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传
1.1 Java层 Java层提供了 android.media API 与音频硬件进行交互。在内部，此代码会调用相应的 JNI 类，以访问与音频硬件交互的原生代码。
源代码目录：frameworks/base/media/java/android/media/
AudioManager:音频管理器，包括音量管理、AudioFocus管理、音频设备管理、模式管理；
录音：AudioRecord、MediaRecorder；
播放：AudioTrack、MedaiPlayer、SoundPool、ToneGenerator;
编解码：MediaCodec，音视频数据 编解码接口。
1.2 JNI层 与 android.media 关联的 JNI 代码可调用较低级别的原生代码，以访问音频硬件。JNI 位于 frameworks/base/core/jni/ 和 frameworks/base/media/jni 中。
在这里可以调用我们上篇文章介绍的AAudio和OpenSLES接口。
1.3 Native framework 原生框架层 不管是Java层还是JNI层都只是对外提供的接口，真正的实现在原生框架层。原生框架可提供相当于 android.media 软件包的原生软件包，从而调用 Binder IPC 代理以访问媒体服务器的特定于音频的服务。原生框架代码位于 frameworks/av/media/libmedia 或frameworks/av/media/libaudioclient中（不同版本，位置有所改变）。
1.4 Binder IPC Binder IPC 代理用于促进跨越进程边界的通信。代理位于 frameworks/av/media/libmedia或frameworks/av/media/libaudioclient 中，并以字母“I”开头。
1.5 Audio Server Audio系统在Android中负责音频方面的数据流传输和控制功能，也负责音频设备的管理。这个部分作为Android的Audio系统的输入/输出层次，一般负责播放PCM声音输出和从外部获取PCM声音，以及管理声音设备和设置（注意：解码功能不在这里实现，在android系统里音频视频的解码是opencore或stagefright完成的，在解码之后才调用音频系统的接口，创建音频流并播放）。Audio服务在Android N(7.0)之前存在于mediaserver中，Android N开始以audioserver形式存在，这些音频服务是与HAL 实现进行交互的实际代码。媒体服务器位于 frameworks/av/services/audioflinger 和frameworks/av/services/audiopolicy中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d100b161837440ce227127e3e6c4423c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18231a84123811005f2c7f4b6a7485a/" rel="bookmark">
			计算机毕业设计Python&#43;Spark新能源汽车推荐系统 汽车大数据 汽车数据分析 汽车可视化 汽车爬虫 大数据毕业设计 大数据毕设 知识图谱 深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黄河交通学院本科毕业设计（论文）任务书
学院：智能工程学院
学生姓名
刘丹杰
专业班级
大数据20-1班
学号
2080910T01521
指导教师
炎士涛
职称
副教授
学位
硕士
题目名称
基于Hadoop的新能源汽车销售数据分析系统的设计与实现
起止时间
2024年1月2日 至 2024年6月15日
选题性质
□理论研究 √应用研究 □技术开发 □产品设计 □其他
是否在实践中完成
£是 √否
设计（研究）目标：
设计并实现一个可扩展、高性能的数据分析系统，能够处理大规模的新能源汽车销售数据，并提供多维度的数据分析功能，包括销售趋势分析、地域分布分析、车型偏好分析等。实现数据可视化功能，以图表、报表等形式直观展示分析结果，并构建友好的用户界面，方便用户进行数据查询、筛选和导出。
设计（研究）内容及具体要求：
1. 数据采集模块
数据源接入：支持多种数据源的接入，如销售平台、社交媒体、政府统计数据等。
数据预处理：对采集的数据进行清洗、去重、格式化等预处理操作，确保数据质量。
2.数据存储模块
Hadoop分布式文件系统（HDFS）：用于存储大规模的销售数据，提供高可靠性和高吞吐量。
数据仓库：构建基于Hadoop的数据仓库，对数据进行组织、索引和优化查询。
3. 数据处理与分析模块
MapReduce编程模型：用于处理大规模数据集，进行复杂的数据转换和聚合操作。Hive/Pig：提供SQL-like语言或脚本语言，用于数据的批处理和分析。
4. 实时数据处理模块
Spark Streaming：用于处理实时销售数据流，提供实时数据分析和处理能力。
Kafka：作为消息队列，支持高吞吐量的实时数据摄入。
5. 数据挖掘与机器学习模块
机器学习算法库：集成机器学习算法，用于预测销售趋势、客户偏好分析等。
数据挖掘工具：提供关联规则、聚类分析、分类等数据挖掘技术。
6. 数据可视化模块
图表生成工具：将分析结果通过图表、图形等形式直观展示。
仪表板：为用户提供实时数据监控和历史数据分析的仪表板。
7. 用户交互与报告模块
用户界面：提供友好的用户界面，支持数据查询、报告生成和下载。
报告自动生成：根据用户需求自动生成销售报告和分析报告。
8. 安全与权限管理模块
用户认证与授权：确保只有授权用户才能访问敏感数据。
数据加密：对存储和传输的数据进行加密，保障数据安全。
9. 系统监控与维护模块
日志管理：记录系统操作日志，便于问题追踪和性能分析。
性能监控：监控系统性能，确保数据处理的高效和稳定。
10. 扩展与集成模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f18231a84123811005f2c7f4b6a7485a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6595ff599c3eff68fb02b1af282d740a/" rel="bookmark">
			算法金 | 有史以来最详细的卷积神经网络(CNN)及其变体讲解！！！（多图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大侠幸会，在下全网同名[算法金]
0 基础转 AI 上岸，多个算法赛 Top
[日更万日，让更多人享受智能乐趣]
0. 前言 卷积神经网络（Convolutional Neural Networks，CNN）是人工智能领域中一种重要的深度学习模型，被广泛应用于图像识别、目标检测、自然语言处理等领域。它的出现标志着计算机视觉和模式识别领域的重大进步，也推动了人工智能技术的发展。在这个前言部分，我们将简要回顾卷积神经网络的发展历程，探讨它的重要性，并引入接下来文章的主题和目的。
卷积神经网络的发展可以追溯到上世纪80年代，但直到近年来随着计算能力的提升和大数据的普及，CNN才真正展现了其强大的能力。它模拟了人类视觉系统的工作原理，通过层层抽象和特征提取，实现了对复杂数据的高效处理和识别。在图像处理、语音识别、自然语言处理等领域，CNN已经成为了最常用、最有效的模型之一。
本文旨在对卷积神经网络及其变体进行详细的讲解，从基本原理到实际应用，帮助读者全面了解CNN的工作原理、优势和局限性，以及其在现实生活中的应用场景。接下来，让我们一起深入探索CNN的奥秘，走你！
1. 卷积神经网络(CNN)概述 1.1. CNN的定义和起源 卷积神经网络（CNN）是一种深度学习模型，最早由神经科学家Yann LeCun等人在上世纪80年代提出，用于解决图像识别问题。它是受到生物视觉系统结构的启发而设计的，模拟了人类视觉系统对视觉信息的处理方式。CNN的核心思想是通过一系列的卷积操作和池化操作，逐渐提取输入数据中的特征，并通过全连接层进行分类或回归。
1.2. CNN与传统神经网络的区别 传统的全连接神经网络将输入的每一个像素都连接到隐藏层的每一个神经元，导致参数量巨大，计算复杂度高，容易产生过拟合。而CNN采用局部感知性和参数共享的方式，通过卷积核的滑动和权值共享，可以有效减少参数数量和计算量，提高模型的泛化能力。
1.3. CNN在图像处理中的应用 CNN在图像处理领域有着广泛的应用，包括但不限于：
图像分类：通过训练CNN模型，可以实现对图像进行自动分类，如识别动物、车辆、人脸等。目标检测：CNN可以检测图像中的特定物体，并标注出其位置和边界框，如交通标识、行人等。图像分割：CNN可以将图像分割成多个语义区域，如分割出图像中的不同物体或者场景。 CNN在图像处理领域的应用不仅提高了图像处理的效率和准确性，也推动了人工智能技术在视觉领域的发展和应用。
2. CNN的基本原理 2.1. 卷积运算的数学基础 卷积运算是CNN中的核心操作之一，它模拟了生物视觉系统中的感受野（Receptive Field）机制，通过滑动一个卷积核（Filter）在输入数据上进行加权求和，从而得到输出特征图。数学上，卷积运算可以表示为：
其中，( I ) 是输入图像，( K ) 是卷积核，( C ) 是输出特征图，( (i, j) ) 是输出特征图的坐标，( (m, n) ) 是卷积核的坐标。通过不断调整卷积核的参数，可以提取输入数据中的不同特征，如边缘、纹理等。
2.2. 感受野(Receptive Field)的概念 感受野是指在神经网络中，一个神经元接收到的输入数据的区域大小。在CNN中，每一层的神经元只与上一层的部分神经元相连，这种局部连接的方式使得每个神经元的感受野被限制在一个较小的区域内，但通过多层卷积操作，可以扩大神经元的感受野，实现对整个输入数据的全局感知。
2.3. 权值共享的重要性 在CNN中，卷积核的参数是共享的，即同一个卷积核在整个输入数据上进行滑动时，参数保持不变。这种权值共享的方式大大减少了模型的参数数量，降低了过拟合的风险，同时也提高了模型的训练效率。此外，权值共享还增强了模型对平移不变性的学习能力，使得CNN在处理平移、旋转等变换时具有更好的性能。
上图是一个简单的卷积运算示意图。左侧为输入图像，右侧为卷积核。卷积核在输入图像上进行滑动，并与输入图像的对应位置进行加权求和，得到输出特征图。
（多通道可视化）
3. CNN的关键组件 3.1. 卷积层(Convolutional Layer) 卷积层是CNN中最重要的组件之一，它负责提取输入数据的特征。在卷积层中，通过定义一组卷积核，对输入数据进行卷积运算，从而得到一系列的特征图。卷积操作能够有效捕捉局部特征和空间结构，实现对输入数据的特征提取和表示。
3.2. 池化层(Pooling Layer) 池化层用于对卷积层输出的特征图进行降维和抽样，以减少模型参数数量和计算复杂度。常见的池化操作包括最大池化和平均池化，通过在特定区域内取最大值或平均值来保留重要信息并减少数据量。池化操作还能增强模型对于平移和尺度变化的鲁棒性，提高模型的泛化能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6595ff599c3eff68fb02b1af282d740a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef97b0d1d3e754307a2a643c184b3e96/" rel="bookmark">
			Flink端到端的精确一次（Exactly-Once）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
状态一致性
端到端的状态一致性
端到端精确一次（End-To-End Exactly-Once）
Flink内部的Exactly-Once
输入端保证
输出端保证
幂等写入
事务写入
Flink和Kafka连接时的精确一次保证
整体介绍
需要的配置
案例
状态一致性 流式计算本身就是一个一个进行的，所以正常处理的过程中结果肯定是正确的，但在发生故障、需要恢复回滚时就需要更多的保障机制。我们通过检查点的保存来保证状态恢复后计算结果的正确。
状态一致性其实就是结果的正确性，一般从数据丢失、数据重复来评估。
一般说来，状态一致性有三种级别：
最多一次（At-Most-Once）至少一次（At-Least-Once） 精确一次（Exactly-Once） 端到端的状态一致性 我们已经知道检查点可以保证Flink内部状态的一致性，而且可以做到精确一次。在实际应用中，不仅仅要确保Flink内部状态的正确性，我们需要确保整个应用处理流程从头到尾都应该是正确的，才能得到整体结果的正确性。
完整的流处理应用，包括数据源、流处理器和外部存储系统三个部分。这个完整应用的一致性，就叫做“端到端（end-to-end）的状态一致性”，它取决于三个组件中最弱的那一环。
一般来说，能否达到at-least-once一致性级别，主要看数据源能够重放数据，而能否达到exactly-once级别，流处理器内部、数据源、外部存储都要有相应的保证机制。
端到端精确一次（End-To-End Exactly-Once） 最难做到、也最希望做到的一致性语义就是端到端（end-to-end）的“精确一次”。
Flink内部的Exactly-Once 对于Flink内部来说，检查点机制可以保证故障恢复后数据不丢（在数据能够重放的前提下），已经可以做到exactly-once的一致性语义了。
所以端到端一致性的关键点，就在于输入的数据源端（Source）和输出的外部存储端（Sink）。
输入端保证 输入端主要指的就是Flink读取的外部数据源。对于一些数据源来说，并不提供数据的缓冲或是持久化保存，数据被消费之后就彻底不存在了，例如socket文本流。对于这样的数据源，故障后我们即使通过检查点恢复之前的状态，可保存检查点之后到发生故障期间的数据已经不能重发了，这就会导致数据丢失。所以就只能保证at-most-once的一致性语义，相当于没有保证。
想要在故障恢复后不丢数据，外部数据源就必须拥有重放数据的能力。常见的做法就是对数据进行持久化保存，并且可以重设数据的读取位置。一个最经典的应用就是Kafka。在Flink的Source任务中将数据读取的偏移量保存为状态，这样就可以在故障恢复时从检查点中读取出来，对数据源重置偏移量，重新获取数据。
数据源可重放数据，或者说可重置读取数据偏移量，加上Flink的Source算子将偏移量作为状态保存进检查点，就可以保证数据不丢。这是达到at-least-once一致性语义的基本要求，当然也是实现端到端exactly-once的基本要求。
输出端保证 有了Flink的检查点机制，以及可重放数据的外部数据源，我们已经能做到at-least-once了。但是想要实现exactly-once却还有更大的困难：数据有可能重复写入外部系统。
因为检查点保存之后，继续到来的数据也会一一处理，任务的状态也会更新，最终通过Sink任务将计算结果输出到外部系统；只是状态改变还没有存到下一个检查点中。这时如果出现故障，这些数据都会重新来一遍，就计算了两次。我们知道对Flink内部状态来说，重复计算的动作是没有影响的，因为状态已经回滚，最终改变只会发生一次；但对于外部系统来说，已经写入的结果已经无法收回了，再次执行写入就会把同一个数据写入两次。
所以这时，保证了端到端的at-least-once语义。
为了实现端到端exactly-once，我们还需要对外部存储系统、以及Sink连接器有额外的要求。能够保证exactly-once一致性的写入方式有两种：
幂等写入事务写入 幂等写入 所谓“幂等”操作，就是说一个操作可以重复执行很多次，但只导致一次结果更改。也就是说，后面再重复执行就不会对结果起作用了，或者说后面的结果和之前的结果保持一致。
对于幂等写入，遇到故障进行恢复时，有可能会出现短暂的不一致。不过当数据的重放逐渐超过发生故障的点的时候，最终的结果还是一致的。
事务写入 事务是应用程序中一系列的操作，事务中所有操作要么全部完成，要么全部不完成。
输出端最大的问题，就是写入到外部系统的数据难以撤回。而利用事务就可以实现对已写入数据的撤回。
事务写入的基本思想就是：用一个事务来进行数据向外部系统的写入，这个事务是与检查点绑定在一起的。当Sink任务遇到barrier时，开始保存状态的同时就开启一个事务，接下来所有数据的写入都在这个事务中；待到当前检查点保存完毕时，将事务提交，所有写入的数据就真正可用了。如果中间过程出现故障，状态会回退到上一个检查点，而当前事务没有正常关闭（因为当前检查点没有保存完），所以也会回滚，写入到外部的数据就被撤销了。
具体来说，又有两种实现方式：预写日志（WAL）和两阶段提交（2PC）
（1）预写日志（write-ahead-log，WAL）
事务提交是需要外部存储系统支持事务的，否则没有办法真正实现写入的回撤。
那对于一般不支持事务的存储系统，如何能够实现事务写入呢？ 预写日志（WAL）就是一种非常简单的方式。
具体步骤是：
①先把结果数据作为日志（log）状态保存起来，保持在状态后端中。
②进行检查点保存时，也会将这些结果数据一并做持久化存储。
③在收到检查点完成的通知时，将所有结果一次性写入外部系统。
④在成功写入所有数据后，在内部再次确认相应的检查点，将确认信息也进行持久化保存。这才代表着检查点的真正完成。
我们会发现，这种方式类似于检查点完成时做一个批处理，一次性的写入会带来一些性能上的问题；而优点就是比较简单，由于数据提前在状态后端中做了缓存，所以无论什么外部存储系统，理论上都能用这种方式一批搞定。
在Flink中DataStream API提供了一个模板类GenericWriteAheadSink，用来实现这种事务型的写入方式。
需要注意的是，预写日志这种一批写入的方式，有可能会写入失败；所以在执行写入动作之后，必须等待发送成功的返回确认消息。在成功写入所有数据后，在内部再次确认相应的检查点，这才代表着检查点的真正完成。这里需要将确认信息也进行持久化保存，在故障恢复时，只有存在对应的确认信息，才能保证这批数据已经写入，可以恢复到对应的检查点位置。
但这种“再次确认”的方式，也会有一些缺陷。如果我们的检查点已经成功保存、数据也成功地一批写入到了外部系统，但是最终保存确认信息时出现了故障，Flink最终还是会认为没有成功写入。于是发生故障时，不会使用这个检查点，而是需要回退到上一个；这样就会导致这批数据的重复写入。
（2）两阶段提交（two-phase-commit，2PC）
前面提到的各种实现exactly-once的方式，多少都有点缺陷；而更好的方法就是传说中的两阶段提交（2PC）。 顾名思义，它的想法是分成两个阶段：先做“预提交”，等检查点完成之后再正式提交。这种提交方式是真正基于事务的，它需要外部系统支持事务。
具体的实现步骤为：
①当第一条数据到来时，或者收到检查点的分界线时（第一条数据到达会启动一个事物，之后都是用分界线到达启动一个事物），Sink任务都会启动一个事务。
②接下来接收到的所有数据，都通过这个事务直接写入外部系统；这时由于事务没有提交，所以数据尽管写入了外部系统，但是不可用，是“预提交”的状态。
③当Sink任务收到JobManager发来检查点完成的通知时，正式提交事务，写入的结果就真正可用了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef97b0d1d3e754307a2a643c184b3e96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fdcafdb4cf96f9e060384b53c572a40/" rel="bookmark">
			新手教程之使用LLaMa-Factory微调LLaMa3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么要用LLaMa-Factory什么是LLaMa-FactoryLLaMa-Factory环境搭建微调LLaMA3参考博文 为什么要用LLaMa-Factory 如果你尝试过微调大模型，你就会知道，大模型的环境配置是非常繁琐的，需要安装大量的第三方库和依赖，甚至需要接入一些框架。
但是大模型微调的方法又是非常类似的，那有没有一种工具可以统一这些操作，让大模型微调变成一个简单易上手的事情，LLaMa-Factory就是为了解决这个问题应运而生
什么是LLaMa-Factory 本来不想说这么多废话的，想来想去还是简单介绍一下，也加深自己的了解：
LLaMA Factory是一款支持多种LLM微调方式的工具，包括预训练、指令监督微调和奖励模型训练等。它支持LoRA和QLoRA微调策略，广泛集成了业界前沿的微调方法。特点在于支持多种LLM模型，提供了WebUI页面，使非开发人员也能方便进行微调工作。
代码地址：LLaMA-Factory
LLaMa-Factory环境搭建 克隆项目 git clone https://github.com/hiyouga/LLaMA-Factory.git 创建环境 conda create -n llama_factory python=3.10 conda activate llama_factory 安装依赖 cd LLaMA-Factory pip install -e .[torch,metrics] 启动web UI界面 export CUDA_VISIBLE_DEVICES=0 python src/webui.py 启动成功之后，游览器会打开如下界面：
微调LLaMA3 准备模型 方法一：克隆我们要微调的模型到本地，然后将在web UI界面填入我们的模型名称和本地的模型地址
git clone https://www.modelscope.cn/LLM-Research/Meta-Llama-3-8B-Instruct.git 方法二：直接去魔塔Meta-Llama-3-8B-Instruct地址复制对应的文件名和路径，微调时，程序会自动​去魔搭下载模型！
（这个方法小编浅浅试了一下，没成功，还是下载到本地靠谱）
准备数据集 LLaMA-Factory项目内置了丰富的数据集，统一存储于data目录下。
如果你想基于自己的数据集微调，你需要
（1）将你的数据集也放到data目录下
注意：你需要将你的数据集改为一样的格式，具体可参考data下内置数据集的格式
这里提供一个小编基于LooksJuicy/ruozhiba数据集改好的一个数据集：
https://pan.baidu.com/s/1FYYlBIXWy697xdagrHiIeg
提取码：2333
（2）修改data下的dataset_info.json文件，添加如下内容：
其中my_data.json是我自己的数据集文件，my_data是对应的数据集文件名
"my_data": { "file_name": "my_data.json" }, 添加到第一层大括号内的第一个元素前，也就是identity前面
微调 这里我直接通过web ui界面进行微调
训练需要二十分钟左右，训练完成之后，会出现下述界面：
左下角会显示训练完毕，右边会出现训练过程中损失变化的一个可视化
与微调之后的模型对话 这样看来，使用LLaMa-Factory微调确实很简单方便！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fdcafdb4cf96f9e060384b53c572a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4daf71a12104ee498d770412f34b9889/" rel="bookmark">
			Web自动化测试-掌握selenium工具用法，使用WebDriver测试Chrome/FireFox网页(Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、在Eclipse中构建Maven项目
1.全局配置Maven
2.配置JDK路径
3.创建Maven项目
4.引入selenium-java依赖
二、Chrome自动化脚本编写
1.创建一个ChromeTest类
2.测试ChromeDriver
3.下载chromedriver驱动
4.在脚本中通过System.setProperty方法指定chromedriver的地址
5.测试学习通网址登录功能
三、FireFox自动化脚本编写
1.新建一个FireFoxTest类
2.指定firefox可执行文件路径: webdriver.firefox.bin
3.下载geckodriver驱动
4.在脚本中通过System.setProperty方法指定chromedriver的地址
工具：eclipse(2016)、chrome(v.125)
依赖：selenium-java(3.141.59)
驱动：chromedriver(win64 v125)
配置环境：jdk1.8.0、 maven3.5.2
一、在Eclipse中构建Maven项目 1.全局配置Maven 点击Windows-&gt;Preferences
注意：要先在settinfs.xml中配置阿里云镜像仓库，可参考该文章1~3步骤IDEA 使用自定义MAVEN（maven安装及IDEA配置）_idea 用自定义maven-CSDN博客
同时在installations中add maven路径
2.配置JDK路径 同样是在Preferences中，确认指向的是JDK的路径而不 是JRE的路径
3.创建Maven项目 点击File-&gt;New-&gt;Project...
勾选Create a simple...
填入组名和项目名，点击Finish
创建完项目列表如下：
4.引入selenium-java依赖 在Maven官网可以下载：Maven Repository: Search/Browse/Explore (mvnrepository.com)
搜索selenium，选择Selenium Java
选择使用度较高的版本，这里选择了4.18.1
拷贝对应的Maven依赖包
点击pom.xml粘贴进去，注意要放在&lt;dependencies&gt;&lt;/dependencies&gt;里面
保存后，后自动生成Maven Dependendies
二、Chrome自动化脚本编写 1.创建一个ChromeTest类 2.测试ChromeDriver 输入以下代码，点击运行
import org.openqa.selenium.chrome.ChromeDriver; public class ChromeTest { public static void main(String[] args) throws Exception{ ChromeDriver driver = new ChromeDriver(); } } 若报以下错，说明Selenium Java版本过高，需要下载较低版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4daf71a12104ee498d770412f34b9889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c280dab4e1208afb8cd44a2e3253e01/" rel="bookmark">
			【简单理解化】 内存函数及它的模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章谈论memcpy,memcmp,memmove,memset函数
目录
1.memcpy的使用和模拟实现
2.memmove的使用和模拟实现
3.memset的使用
4.memcmp函数的使用
1.memcpy的使用和模拟实现 该函数用于从源内存块复制指定数量的字节到目标内存块
1 void * memcpy ( void * destination, const void * source, size_t num );
dest：指向目标内存块的指针。src：指向源内存块的指针。n：要复制的字节数。这个函数在遇到 '\0' 的时候并不会停下来该函数不检查内存块重叠，如果强行叠加复制，结果未定义。 示例：
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;assert.h&gt; int main() { int arr1 [] = {0,1,2,3,4,5,6,7,8,9,10}; int arr2[20] = { 0 }; memcpy(arr2, arr1+2, 20);//字节的个数，返回的目标空间的起始地址，不在乎/0， //做不到的东西：不负责重叠内存的拷贝。，非要使用，结果未定义。用memmove return 0; } 结果：2 3 4 5 6
memcpy模拟实现：
//for循环 void* my_memcpy(void* dest, const void* src, size_t num) { int i = 0; void* ret = dest; assert(src &amp;&amp; dest); for (i = 0; i &lt; num; i++) { *(char*)dest = *(char*)src; dest = (char*)dest + 1; src = (char*)src + 1; } return ret; } //while循环 void* my_memcpy(void* dest, const void* src, size_t num) { int i = 0; void* ret = dest; assert(src &amp;&amp; dest); while (num--) { *(char*)dest = *(char*)src; dest = (char*)dest + 1; src = (char*)src + 1; } return ret; } int main() { int arr1[] = { 0,1,2,3,4,5,6,7,8,9,10 }; int arr2[20] = { 0 }; my_memcpy(arr2, arr1 + 2, 20); return 0; } for循坏和while循环选择一个即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c280dab4e1208afb8cd44a2e3253e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926f323bd97282e53600f181a4d143ef/" rel="bookmark">
			深入探讨分布式ID生成方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨谢谢大家捧场，祝屏幕前的小伙伴们每天都有好运相伴左右，一定要天天开心哦！✨✨ 🎈🎈作者主页： 喔的嘛呀🎈🎈 ✨✨ 帅哥美女们，我们共同加油！一起进步！✨✨ 目录
引言
一. UUID（Universally Unique Identifier）
二、数据库自增ID
三. 基于Redis的方案
四. Twitter的snowflake算法
五、百度UidGenerator
结语
引言 在分布式系统中，生成唯一标识符（ID）是一个常见的需求。在这篇博客中，我们将介绍几种常见的分布式ID生成方案，包括UUID、Snowflake算法、基于数据库的方案和基于Redis的方案。我们将深入探讨每种方案的原理、优缺点，并提供相应的代码示例。
一. UUID（Universally Unique Identifier） UUID（Universally Unique Identifier）是一种标准化的128位数字（16字节）格式，通常用32个十六进制数字表示。UUID的目的是让分布式系统中的多个节点生成的标识符在时间和空间上都是唯一的。
UUID通常由以下几部分组成：
时间戳：占据前32位，表示生成UUID的时间戳。时钟序列号：占据接下来的16位，保证在同一时刻生成的UUID的唯一性。全局唯一的节点标识符：占据最后的48位，通常是机器的MAC地址。 UUID的生成方法有多种，其中比较常见的是基于当前时间戳和随机数生成。Java中可以使用java.util.UUID类来生成UUID，示例如下：
import java.util.UUID; public class UUIDGenerator { public static void main(String[] args) { UUID uuid = UUID.randomUUID(); System.out.println("Generated UUID: " + uuid.toString()); } } 这段代码将生成一个类似于550e8400-e29b-41d4-a716-446655440000的UUID。由于UUID的唯一性和随机性，通常用于分布式系统中的唯一标识符，例如作为数据库表的主键。 二、数据库自增ID 使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同
步长，生成不重复ID的策略来实现高可用。
优点：数据库生成的ID绝对有序，高可用实现方式简单
缺点：需要独立部署数据库实例，成本高，有性能瓶颈
在许多关系型数据库中，自增ID是一种常见的用于唯一标识表中记录的方式。下面我将以MySQL为例，介绍如何在数据库中使用自增ID。
首先，我们需要创建一个带有自增ID的表。以下是一个简单的示例表的创建语句：
CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) NOT NULL, email VARCHAR(100) NOT NULL ); 在这个例子中，id 列被定义为自增列，并且被指定为主键。每次向表中插入一条记录时，id 列都会自动递增，确保每个记录都有唯一的ID。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/926f323bd97282e53600f181a4d143ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae242c0d5bee9cf61f5509e0f2d0db36/" rel="bookmark">
			在多支付渠道中这个设计模式无敌好用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设我们有一个电商平台，需要支持多种支付方式。
通过策略模式来实现，管理不同的支付方式，并根据需求快速添加新的支付方式。
定义支付策略接口及其实现类：
// 支付策略接口
public interface PaymentStrategy {
void pay(int amount);
}
// 支付宝支付策略的实现类
public class AlipayStrategy implements PaymentStrategy {
@Override
public void pay(int amount) {
System.out.println("使用支付宝支付" + amount + "元");
// 模拟支付逻辑
}
}
// 微信支付策略的实现类
public class WechatPayStrategy implements PaymentStrategy {
@Override
public void pay(int amount) {
System.out.println("使用微信支付" + amount + "元");
// 模拟支付逻辑
}
}
// 银联支付策略的实现类
public class UnionPayStrategy implements PaymentStrategy {
@Override
public void pay(int amount) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae242c0d5bee9cf61f5509e0f2d0db36/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/306/">«</a>
	<span class="pagination__item pagination__item--current">307/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/308/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>