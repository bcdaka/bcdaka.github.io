<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0bf3d0d2c0bea209854c74541c7c5f4/" rel="bookmark">
			uniapp转小程序，小程序转uniapp方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 作者：coderYYY
🧑 个人简介：前端程序媛，目前主攻web前端，后端辅助，其他技术知识也会偶尔分享🍀欢迎和我一起交流！🚀（评论和私信一般会回！！）
👉 个人专栏推荐：《前端项目教程以及代码》
uniapp和微信小程序互相转换
✨一、uniapp转换为小程序 这个简单，HubuilderX自带的发行就可以转
🚩二、小程序转换为uniapp 小程序转uniapp工具安装方式（任选一种）
🎉1. 安装 1. 命令行安装方式： npm install miniprogram-to-uniapp -g 2.HBuilderX插件： uniapp插件市场：miniprogram-to-uniapp v2
小程序与uniapp的语法并不能一一对应，因此，仍然会有一些语法问题是工具层面无法解决的
🔑2. 使用 这里用的是引入插件的方法打开插件链接：HBuilder X 插件 miniprogram-to-uniapp，点击右侧绿色按钮“使用HBuilderX导入插件”。
在HBuilder X左侧项目管理器里，在小程序项目上右键，点击弹出菜单里面的 “miniprogram to uniapp v2”，然后等待插件运行结束即可。
等待转换完成
转换完成后在小程序代码同源目录会有个uni结尾的文件夹，用Hbuilder打开即可，可能有部分bug需要自己手工改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26bbf80280e041c1c7167ceaa4da06e1/" rel="bookmark">
			如何轻松地将文件从Android传输到 PC | 7 种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件从手机传输到个人电脑已成为一种常态。人们出于各种原因转移文件。也许是为了备份，您想释放Android手机中的一些空间，或者您想从计算机上收听它们。
由于Android的透明和开放性，您会发现多种将文件从Android手机传输到计算机的方法。但是，您应该知道正确的方法，因为在此过程中可能会遇到数据丢失的情况。当然，你不会想要这样的。阅读本指南了解如何将文件从Android传输到 PC。
方法 1：如何通过蓝牙将文件从Android设备移动到 PC 您可以使用Android蓝牙连接将文件从手机传输到计算机。此方法适用于快速传输小文件。
使用步骤：
打开两台设备的蓝牙设置并确保它们在可发现模式下。配对设备并通过PIN码或自动配对进行连接。在Android设备上选择要传输的文件，选择“分享”并通过蓝牙发送。在PC上接受文件并选择保存位置。 方法 2：如何通过云服务将文件共享到PC 云同步是一种强大的文件传输方法，适用于大文件的传输。
使用步骤：
在Android设备上选择云服务应用，如百度云或腾讯微云，并登录账户。上传文件到云存储。在PC上登录相同的云服务账户并下载文件。 方法 3：如何通过电子邮件将文件从Android发送到个人计算机 使用电子邮件传输文件是一种简单直接的方法，尤其适用于传输小文件。
使用步骤：
在Android设备上打开电子邮件应用，如Gmail。撰写新邮件，添加收件人并附加要传输的文件。发送邮件并在PC上登录相同账户下载附件。 方法 4：如何通过QQ或微信将文件从Android发送到PC 在中国，QQ和微信是常用的社交平台，也可以用来传输文件。
使用步骤：
在Android设备上打开QQ或微信应用。选择“文件传输”或“我的文件”功能。上传文件到云端，然后在PC端登录相同的账号并下载文件。 方法 5：使用 Microsoft Phone Link 将数据从Android传输到 PC Microsoft Phone Link 是一个简单有用的工具，用于将文件从Android手机传输到 PC。
使用步骤：
在Android设备上安装Microsoft Phone Link应用。在PC上打开该应用，因为新的Windows版本已经预装了该应用程序。授予权限并将两个设备配对。通过将数据从Android设备拖放到 PC 来传输照片。 方法 6：使用 USB 数据线将文件从Android传输到 PC 通过 USB 将手机连接到 PC 是一个传统的传输方法。
使用步骤：
使用USB线将Android设备连接到PC，并启用USB调试。在PC上打开文件资源管理器，访问手机存储。找到要传输的文件并复制或拖动到PC上。 方法 7：如何使用Coolmuster Android Assistant将文件从Android移动到 PC Coolmuster Android Assistant是一款专为Android设备设计的电脑客户端软件，它提供了一个直观的界面来帮助用户轻松管理和传输数据。这款软件不仅支持文件传输，还能够备份和恢复Android设备上的数据，如联系人、短信、照片、视频、音乐和应用程序等。
适用于iPhone / iPad / iPod的强大数据管理器Coolmuster iOS Assistant 是一款多合一软件，可通过三种方式备份 iOS 设备，并在计算机上自由管理iPhone / iPad / iPod设备。https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26bbf80280e041c1c7167ceaa4da06e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5efafc3ced6634a3a4111df84905aa/" rel="bookmark">
			Android完整备份：备份Android手机数据的4种最佳方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今，人们每天都依赖手机，丢失数据对我们所有人来说都是一个大麻烦。由于生活是不可预测的，没有人知道什么时候他的数据可能会被意外删除或丢失。因此，仔细备份手机数据非常重要。大多数主要智能手机平台都具有将数据备份到计算机或互联网的功能。不过，如果你想自动创建Android完整备份，你仍然需要一些软件来实现。在这篇文章中，我将分享完整备份Android手机的最佳方法。
第 1 部分：如何使用Coolmuster Android Assistant完全备份您的Android 最好的方法是使用 Coolmuster Android Assistant完全备份您的Android数据。它几乎支持备份Android设备上的各种文件，例如联系人，短信，通话记录，音乐，视频，电影，照片，书籍，文档，应用程序等。此外，它还允许您备份和恢复整体Android手机的数据，一键保存在PC上并保持高质量，并且能够实现完整的Android备份到计算机。
更重要的是，它完全兼容几乎所有Android手机和平板电脑，包括最新的三星 Galaxy S23/S22/S21/S20/S20+/S20 Ultra/S10/S10 Plus/S10e、Galaxy Note 10/Note 9/Note 9 Plus、Sony Xperia XZ Premium、HUAWEI P80/P60/P40/P40 Pro/P30/P30 Pro/Mate X/Mate 20/Mate 10 Pro、HTC U12+/U11+/U11、LG G7/G6+ 等。现在让我们看看如何一步一步完整备份您的Android手机。
Coolmuster Android Assistant： 在计算机上管理 Android 数据Coolmuster Android Assistant 是一款专业的 Android 管理程序，供 Android 用户在 PC 上自由管理 Android 联系人、短信、媒体、应用程序等 Windows 。通过签到了解更多信息。https://www.coolmuster.cn/android-assistant.html
第 1 步：安装并启动Android Assistant。 在计算机上安装并启动该程序，然后使用 USB 数据线或通过 Wi-Fi 将设备连接到计算机。
第2步：检测Android上的数据。 当Android设备成功连接后，程序将扫描您的手机数据。您将看到计算机上出现主界面，其中包含所有手机数据。
第3步：选择“备份”选项。 进入“超级工具箱”，你会看到如下界面。选择“备份”选项继续。
第4步：选择需要备份的数据。 选择要备份的内容，然后选择 PC 上的输出位置来保存这些备份。然后单击“备份”按钮将它们保存到目的地。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de5efafc3ced6634a3a4111df84905aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6cb91b91971f8497f6dda1560cc408/" rel="bookmark">
			图书馆定位导航：RFID、VR与AR技术在图书馆中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图书馆作为知识的宝库，承载着无数求知者的梦想与期待，随着馆藏书籍数量的激增与图书馆布局的日益复杂，读者在寻找目标书籍往往有许多困难。传统的索引号查询方式虽能提供书籍的基本信息，但在寻找过程中，因不熟悉图书馆布局，读者常常需要耗费大量时间。维小帮图书馆定位导航利用位置定位技术，为读者打造了一个高效、便捷的找书体验，让每一本书籍都能轻松触手可及。
用户痛点分析
1. 图书馆布局复杂：图书馆内部结构复杂，不同功能区域划分不够清晰，导致读者难以快速找到阅读区、自习区、借阅区等特定区域，浪费了大量时间在寻找上。
2. 书籍种类繁多：书籍种类繁多、数量庞大，且摆放位置可能会因整理、借还等原因发生变化，读者仅依靠传统的分类标签和书架编号，很难准确找到目标图书。
3. 座位预约不便：在学习氛围浓厚的时期，自习区座位供不应求。读者无法提前预约座位，到达后可能面临没有空位的尴尬，只能在各个区域盲目寻找，不仅影响自己的阅读和学习计划，也容易干扰其他读者。
图书定位的技术构成
维小帮图书馆定位系统融合了多种先进技术，确保其精准、高效地为读者服务。
1.RFID 技术：通过在图书上安装射频识别标签（RFID），系统能够实时感知图书的位置信息。
2.室内定位技术：结合蓝牙、Wi-Fi 等信号，实现对读者和图书在馆内的精准定位。
3.大数据与云计算：处理和分析海量的图书位置数据以及读者的行为数据，为导航和推荐提供支持。
图书馆定位技术
图书定位系统的具体功能
图书馆电子地图 维小帮三维电子地图，能够1:1还原图书馆的室外建筑和室内布局，能帮助用户直观地了解图书馆的整体结构和各个区域的分布情况。这种地图支持缩放、旋转和拖动，使读者能够轻松找到目标位置。
多种地图模型
VR云览 通过虚拟现实（VR）技术，用户可以在其他地方通过手机进入虚拟的图书馆环境，这种体验不仅限于指定的路线，用户还可以根据自己的兴趣自由行走，感受图书馆的氛围和布局。
VR全景导航
AR实景导航 增强现实（AR）技术允许用户在真实环境中叠加虚拟信息，实现更直观的导航体验。当用户在图书馆内时，可以通过手机摄像头扫描周围环境，系统将在屏幕上显示出路径指示、图书位置标记或其他有用信息。
AR实景导航
图书位置导航 系统集成图书馆图书检索系统（OPAC）和图书定位系统（RFID），获 取图书实时位置。用户通过搜索图书名称，即可获取图书导航路线图， 通过手机蓝牙定位实现图书定位导航。
图书定位导航
位置预约 系统对接图书馆座位预约系统，读者预约座位后，可一键定位座位位置，通过手机蓝牙定位 导航可直达座位。
图书馆位置预约
效益综合分析
增强读者的阅读体验：图书定位系统极大提升了找书效率，减少盲目寻找时间，同时增强阅读体验，通过VR预览图书馆，确保座位预约，让学习之旅更加高效与舒适。
优化图书馆资源分配：优化了图书与座位资源分配，提高了图书馆的服务质量和运营效率，增强了图书馆的吸引力，助力图书馆在数字时代保持竞争力。
强化城市智慧化建设：系统展现了公共服务智能化升级的成果，为城市智慧化树立了典范，促进了信息共享与资源整合的深入发展。
文章来源于官网：https://www.3dwxb.com/solution/library.html?csdn023
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de45ad413245faed1012f25f65fe8d9e/" rel="bookmark">
			【Python】从基础到进阶（四）：深入了解Python中的控制流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 文章目录 一、引言二、条件语句1. if 语句2. if-else 语句3. if-elif-else 语句4. 嵌套条件语句5. 三元运算符 三、循环语句1. for 循环基本语法使用range() 函数遍历列表、字典和字符串 2. while 循环基本语法无限循环与终止条件 3. 循环控制语句break 语句continue 语句else 语句 四、异常处理1. 异常的概念2. try-except 语句基本语法 3. 多个 except 块4. try-except-else 语句基本语法 5. try-except-finally 语句基本语法 6. 自定义异常基本语法 五、案例：用户登录系统1. 需求分析2. 实现条件判断进行用户验证3. 使用循环处理多次尝试4. 异常处理确保程序健壮性5. 完整案例代码 六、总结1. 条件语句2. 循环语句3. 异常处理4. 案例应用5. 实际编程建议 一、引言 在前几篇文章中，我们已经学习了Python编程的基础知识，包括变量、数据类型、输入输出操作以及运算符和表达式。这些知识为编写简单的程序打下了坚实的基础。然而，在编写实际应用程序时，通常需要根据不同的条件执行不同的代码块，或重复执行某些操作。这就需要使用到控制流语句。
控制流是指程序中执行代码的顺序，掌握控制流语句可以使我们的程序更加灵活和强大。在本篇文章中，我们将深入探讨Python中的控制流，包括条件语句、循环语句和异常处理。通过学习这些内容，您将能够编写更复杂、更健壮的程序，并且能够处理各种可能出现的异常情况。希望通过本文的学习，您能全面掌握Python中的控制流，为编写高级应用程序打下坚实的基础。
二、条件语句 条件语句使程序能够根据不同的条件执行不同的代码块，从而实现更复杂的逻辑控制。在Python中，主要使用if、if-else和if-elif-else语句来实现条件判断。此外，还可以使用三元运算符进行简化的条件判断。
1. if 语句 if语句用于判断一个条件是否为真，如果条件为真，则执行相应的代码块。
示例代码：
x = 10 if x &gt; 5: print("x 大于 5"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de45ad413245faed1012f25f65fe8d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fedb3c9b58af02a3166fd2b7acec51f0/" rel="bookmark">
			分享 .NET EF6 查询并返回树形结构数据的 2 个思路和具体实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 树形结构是一种很常见的数据结构，类似于现实生活中的树的结构，具有根节点、父子关系和层级结构。
所谓根节点，就是整个树的起始节点。
节点则是树中的元素，每个节点可以有零个或多个子节点，节点按照层级排列，根节点属于第一层，其子节点属于第二层，以此类推，没有子节点的节点，则称为叶子，是最后一层。
父子关系就是节点之间的关系，每个节点都有父节点。
树形结构的应用非常广泛，例如在数据库中用来表示组织结构、目录结构，还用于实现树状菜单、文件系统等。
树形结构的灵活性和层次性使其成为处理具有层级关系数据的有力工具。
常见的树形结构包括二叉树、平衡树、B树等，它们在各个领域都有不同的应用场景和算法实现。
下面分享 EF6 查询并返回树形结构数据的 2 个思路和具体实现方法。
1. EF 生成数据表的实体类 /// &lt;summary&gt; /// HTFP14 表实体类 /// &lt;/summary&gt; public partial class HTFP14 { public string COMPHT14 { get; set; } public string ACDEHT14 { get; set; } public string PGRPHT14 { get; set; } public string PKEYHT14 { get; set; } public string DESCHT14 { get; set; } public Nullable&lt;decimal&gt; PVALHT14 { get; set; } public string PSTRHT14 { get; set; } public string GLNOHT14 { get; set; } public string PCDEHT14 { get; set; } public string ATLVHT14 { get; set; } public string USERHT14 { get; set; } public System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fedb3c9b58af02a3166fd2b7acec51f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/629a5d6c3c5af486db443f17dbb4bd5b/" rel="bookmark">
			【Python与GUI开发】事件处理与打包分发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、高级事件处理
1.自定义事件
2.拖放操作
3.复杂控件的事件处理
二、打包和分发 Tkinter 应用
1.PyInstaller
2.cx_Freeze
3.spec 文件
4.分发注意事项
三、实战示例：文件浏览器
总结
前言 在前面的讨论中，我们深入理解了 Tkinter 的布局管理和控件使用。这一期，我们将探讨如何通过事件处理来增强应用的交互性，同时学习如何将你的 Tkinter 应用打包和分发，以便用户可以在不同平台上运行你的程序。
一、高级事件处理 在 GUI 应用中，事件处理是实现用户与程序之间交互的关键。除了基础的事件处理，Tkinter 还支持更复杂的事件绑定和处理机制，包括自定义事件和拖放操作等。
1.自定义事件 你可以创建并触发自定义事件，这在需要执行特定的一系列操作时非常有用。自定义事件可以使用 Event 类创建，并通过 event_generate 方法触发。
custom_event = tk.Event(root, "&lt;&lt;CustomEvent&gt;&gt;") def handle_custom_event(event): print("Custom event triggered!") root.bind("&lt;&lt;CustomEvent&gt;&gt;", handle_custom_event) root.event_generate("&lt;&lt;CustomEvent&gt;&gt;") 2.拖放操作 实现拖放功能可以让你的应用更加直观和易用。Tkinter 提供了 dnd 模块来支持拖放操作，但需要额外安装（例如使用 pip install python-dnd）。
from tkinter import dnd dnd.DND_FILES_OR_URLS = True drag_source = dnd.DragSource(window, "text/plain;123") drop_target = dnd.DropTarget(window, dnd.DND_FILES, command=on_files_dropped) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/629a5d6c3c5af486db443f17dbb4bd5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17c32006a77e5b0c17d8c5af294ff3b/" rel="bookmark">
			Hive自定义函数编写方法（含源代码解读，超详细，易理解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Hive自定义函数介绍 1．内置函数 Hive 自带了一些函数。比如：max/min等，但是数量有限，自己可以通过自定义函数来方便的扩展。
2．自定义函数 当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。
3．用户自定义函数类别 用户自定义函数根据输入参数和输出结果的个数分为以下三类：
① UDF（User-Defined-Function） 一进一出
② UDAF（User-Defined Aggregation Function） 聚合函数，多进一出，如：count/max/min
③ UDTF（User-Defined Table-Generating Functions） 炸裂函数，一进多出，如：explode()
4．官方文档地址 HivePlugins - Apache Hive - Apache Software Foundationhttps://cwiki.apache.org/confluence/display/Hive/HivePlugins
5．编程实现步骤 ① 继承Hive提供的类：
org.apache.hadoop.hive.ql.udf.generic.GenericUDF ·org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;
② 实现类中的抽象方法
③ 在hive的命令行窗口创建函数
二、具体实现 为了能够更好地演示过程，本文以编写一个判断字符串长度的函数为例，函数命名为mystrlen()，具体实现效果如下图所示。
1.准备工作 ① 创建一个Maven工程Hive
② 在工程项目的pom.xml文件中导入依赖，具体代码如下。本文选用的是Hive3.1.2版本，大家可以根据自己的版本自行更改。
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-exec&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.继承Hive提供的类 经过分析不难发现，该函数应该以一个字符串为输入参数，最终输出一个int型的整数以表明该字符串的长度。其对应的自定义函数类别是UDF（一进一出）类型。所以我们应该继承前文所提到的GenericUDF类。
创建my_strlen类以继承GenericUDF类。由于GenericUDF类为抽象类，所以在继承后，我们必须实现其抽象方法，如下图所示。我们的主要任务便是对前两个函数进行重写。
import org.apache.hadoop.hive.ql.exec.UDFArgumentException; import org.apache.hadoop.hive.ql.metadata.HiveException; import org.apache.hadoop.hive.ql.udf.generic.GenericUDF; import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector; /** * 自定义UDF函数，需要继承GenericUDF类 * 需求: 计算指定字符串的长度 */ public class my_strlen extends GenericUDF { /** * * @param arguments 输入参数类型的鉴别器对象 * @return 返回值类型的鉴别器对象 * @throws UDFArgumentException */ @Override public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException { return null; } /** * 函数的逻辑处理 * @param arguments 输入的参数 * @return 返回值 * @throws HiveException */ @Override public Object evaluate(DeferredObject[] arguments) throws HiveException { return null; } @Override public String getDisplayString(String[] children) { return null; } } 看到上述idea自动生成的代码，可能大家有点慌了。ObjectInspector是什么？DeferredObject又是什么？这些函数具体是做啥的？让我们一步一步的来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c17c32006a77e5b0c17d8c5af294ff3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20c8c95dfb8eb6614af5ffd48a263fa/" rel="bookmark">
			from lxml import etree 的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入 etree 模块：
from lxml import etree 语句用于从 lxml 库中导入 etree 模块。etree 模块提供了一组功能，用于解析、构建和操作XML和HTML文档，提供了比标准库更高效的XML处理方法。 功能和用途：
etree 模块提供了类似于 ElementTree API 的简单和易于使用的接口，同时具有更高的性能。可以使用 etree 模块来解析XML或HTML文档，从中提取信息，对文档进行修改，并生成新的文档。etree 模块支持XPath表达式，使得在文档中定位和选择特定元素变得更加简单和灵活。与 BeautifulSoup 不同，lxml 的 etree 模块更专注于XML和HTML文档的解析和处理，提供了更多底层的操作方法。 示例用法：
解析XML文档：
from lxml import etree xml = "&lt;root&gt;&lt;element&gt;data&lt;/element&gt;&lt;/root&gt;" root = etree.fromstring(xml) 使用XPath表达式选择元素：
elements = root.xpath("//element") 修改文档并生成新的XML文档：
root.find("element").text = "new data" new_xml = etree.tostring(root) 总的来说，from lxml import etree 允许你使用 lxml 库中的 etree 模块，提供了强大的XML和HTML处理功能，特别适合需要高性能和灵活性的文档处理任务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da9162b8d4cc07c5a435aed7a11c285/" rel="bookmark">
			代码随想录学习 54day 图论 A star算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A * 算法精讲 （A star算法） 卡码网：126. 骑士的攻击 题目描述 在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。 棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界） 输入描述 第一行包含一个整数 n，表示测试用例的数量。 接下来的 n 行，每行包含四个整数 a1, a2, b1, b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。 输出描述 输出共 n 行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。 输入示例 6 5 2 5 4 1 1 2 2 1 1 8 8 1 1 8 7 2 1 3 3 4 6 4 6 输出示例 2 4 6 5 1 0 思路 我们看到这道题目的第一个想法就是广搜，这也是最经典的广搜类型题目。 这里我直接给出广搜的C++代码： code c++ 超时 #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8da9162b8d4cc07c5a435aed7a11c285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70997f45dd110daabd79a3e59ebe119/" rel="bookmark">
			AI 大事件：超级明星 Andrej Karpathy 创立AI教育公司 Eureka Labs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🧠 AI 大事件：超级明星 Andrej Karpathy 创立AI教育公司 Eureka Labs 摘要 Andrej Karpathy 作为前 OpenAI 联合创始人、Tesla AI 团队负责人，他的专业性和实力备受瞩目。Karpathy 对 AI 的普及和教育充满热情，从 YouTube 教程到斯坦福大学的在线课程，展现了他对技术民主化的理念。现在，Karpathy 创立了 Eureka Labs，致力于通过 AI 提升人类创造力。首款产品 LLM101n 是一个本科水平的课程，旨在鼓励人们创建自己的 AI。Eureka Labs 正在打造全新的 AI 支持的教育模式，引发业界极大关注。
猫头虎 🐯 建联猫头虎，商务合作，产品评测，产品推广，个人自媒体创作，超级个体，涨粉秘籍，一起探索编程世界的无限可能！
猫头虎是谁？ 大家好，我是 猫头虎，别名猫头虎博主，擅长的技术领域包括云原生、前端、后端、运维和AI。我的博客主要分享技术教程、bug解决思路、开发工具教程、前沿科技资讯、产品评测图文、产品使用体验图文、产品优点推广文稿、产品横测对比文稿，以及线下技术沙龙活动参会体验文稿。内容涵盖云服务产品评测、AI产品横测对比、开发板性能测试和技术报告评测等。
目前，我活跃在CSDN、51CTO、腾讯云开发者社区、阿里云开发者社区、知乎、微信公众号、视频号、抖音、B站和小红书等平台，全网拥有超过30万的粉丝，统一IP名称为 猫头虎 或者 猫头虎博主。希望通过我的分享，帮助大家更好地了解和使用各类技术产品。
原创作者 ✍️ 博主：猫头虎 全网搜索关键词：猫头虎作者微信号：Libin9iOak作者公众号：猫头虎技术团队更新日期：2024年6月16日🌟 欢迎来到猫头虎的博客 — 探索技术的无限可能！ 专栏链接 🔗 精选专栏： 《面试题大全》 — 面试准备的宝典！《IDEA开发秘籍》 — 提升你的IDEA技能！《100天精通鸿蒙》 — 从Web/安卓到鸿蒙大师！《100天精通Golang（基础入门篇）》 — 踏入Go语言世界的第一步！《100天精通Go语言（精品VIP版）》 — 踏入Go语言世界的第二步！ 领域矩阵 🌐 猫头虎技术领域矩阵： 猫头虎技术矩阵新矩阵备用链接 加入猫头虎的技术圈，一起探索编程世界的无限可能！ 🚀 文章目录 🧠 AI 大事件：超级明星 Andrej Karpathy 创立AI教育公司 Eureka Labs摘要 猫头虎 🐯猫头虎是谁？原创作者 ✍️专栏链接 🔗领域矩阵 🌐加入猫头虎的技术圈，一起探索编程世界的无限可能！ 🚀引言正文✨ Eureka Labs 的创立与愿景🧑‍🏫 LLM101n：首款产品的独特之处🎓 Eureka Labs 的未来展望Hans 的荐语 小结参考资料总结未来展望联系与版权声明 📩 引言 Andrej Karpathy 是 AI 领域的超级明星，曾任 OpenAI 联合创始人和 Tesla AI 团队负责人。他不仅在技术上有着卓越的成就，还在 AI 普及和教育方面表现出极大的热情。从制作魔方的 YouTube 教程，到斯坦福大学的 CS231n 课程，再到最近的 Zero-to-Hero AI 系列，Karpathy 一直致力于将复杂的 AI 知识传递给更多人。如今，他全身心投入 Eureka Labs 的建设，致力于通过 AI 技术提升人类的创造力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70997f45dd110daabd79a3e59ebe119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d646cc8bf2661d2b5bc41b98c9a3fa2d/" rel="bookmark">
			Flink底层原理解析：案例解析（第37天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 一、flink架构
二、Flink底层原理解析
三、Flink应用场景解析
四、fink入门案例解析
文章目录 系列文章目录前言一、flink架构1. 作业管理器（JobManager）2. 资源管理器（ResourceManager）3. 任务管理器（TaskManager）4. 分发器（Dispatcher） 二、Flink底层原理解析1. 数据流模型1.1 例1 2. 任务调度与执行2.1 例2 3. 内存管理3.1 例3 4. 容错机制4.1 例4 三、Flink应用场景解析1. 实时数据分析1.1 例子：网络流量监控 2. 社交媒体分析2.1 例子：实时用户行为分析 3. 交易监控3.1 例子：金融交易实时监控 4. 日志处理4.1 例子：大规模日志实时处理 5. 物联网（IoT）5.1 例子：设备数据实时收集和处理 四、fink入门案例解析1. 滚动窗口（tumble window）1.1 处理时间演示1.2 事件时间演示1.3 窗口的时间计算 2. 滑动窗口（hop）2.1阿里云: SQL-入门案例 3. 会话窗口（session）3.1 SQL案例实现 4. 聚合窗口（over）4.1. 根据时间聚合代码实现4.2. 根据行号聚合代码实现 前言 Apache Flink 是一个开源的流处理框架，用于处理无界和有界数据流。其底层原理复杂而精细，涉及到数据流模型、任务调度与执行、内存管理、容错机制等多个方面。本文是对 Flink 底层原理的详细分析，并尝试通过举例来说明这些原理。
提示：以下是本篇文章正文内容，下面案例可供参考
一、flink架构 Flink是一个用于有状态并行数据流处理的分布式计算引擎，其运行时架构主要包括四个核心组件：作业管理器（JobManager）、资源管理器（ResourceManager）、任务管理器（TaskManager）以及分发器（Dispatcher）。以下是这些组件的详细功能介绍：
1. 作业管理器（JobManager） 功能：作业管理器是单个应用程序的主线程，每个应用程序都有一个单独的JobManager进行控制。它负责接收并执行应用程序，这些应用程序通常包含作业图（JobGraph）、逻辑数据流图（logical dataflow graph）以及一个打包了所有类、库和其他资源的JAR包。作用：JobManager会将JobGraph转换成物理层面的数据流图，即执行图（Execution Graph），这个图包含了所有可以并发执行的任务。JobManager还会向ResourceManager请求执行任务所需的资源（即TaskManager中的插槽），一旦获取到足够的资源，就会将执行图分发到TaskManager上执行。同时，JobManager还负责所有需要中央协调的操作，如检查点（checkpoint）的协调。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d646cc8bf2661d2b5bc41b98c9a3fa2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac1b5455dc9f6e4b58e3c785651ee40/" rel="bookmark">
			【LeetCode:试题 16.06. 最小差 &#43; 双指针 &#43; 防止整型溢出】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 算法题 🚀 🌲 算法刷题专栏 | 面试必备算法 | 面试高频算法 🍀
🌲 越难的东西,越要努力坚持，因为它具有很高的价值，算法就是这样✨
🌲 作者简介：硕风和炜，CSDN-Java领域优质创作者🏆，保研|国家奖学金|高中学习JAVA|大学完善JAVA开发技术栈|面试刷题|面经八股文|经验分享|好用的网站工具分享💎💎💎
🌲 恭喜你发现一枚宝藏博主,赶快收入囊中吧🌻
🌲 人生如棋，我愿为卒，行动虽慢，可谁曾见我后退一步？🎯🎯
🚀 算法题 🚀 🍔 目录 🚩 题目链接⛲ 题目描述🌟 求解思路&amp;实现代码&amp;运行结果⚡ 双指针 + 防止整型溢出🥦 求解思路🥦 实现代码🥦 运行结果 💬 共勉 🚩 题目链接 试题 16.06. 最小差 ⛲ 题目描述 给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差
示例：
输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8}
输出：3，即数值对(11, 8)
提示：
1 &lt;= a.length, b.length &lt;= 100000
-2147483648 &lt;= a[i], b[i] &lt;= 2147483647
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac1b5455dc9f6e4b58e3c785651ee40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0299a82e780118315da65016c867f238/" rel="bookmark">
			数据结构-C语言-排序（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码位置：test-c-2024: 对C语言习题代码的练习 (gitee.com)
一、前言： 1.1-排序定义： 排序就是将一组杂乱无章的数据按照一定的规律（升序或降序）组织起来。(注：我们这里的排序采用的都为升序)
1.2-排序分类： 常见的排序算法： 插入排序
a. 直接插入排序
b. 希尔排序
选择排序
a. 选择排序
b. 堆排序交换排序
a. 冒泡排序
b. 快速排序归并排序
a. 归并排序非比较排序
a.计数排序
b.基数排序 1.3-算法比较： 1.4-目的： 今天，我们这里要实现的是快速排序。
1.5-快速排序定义： 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。
二、快速排序-key的选择： 2.1-直接在left和right中选择： 这种选择方法具有局限性如果排序的序列已经为升序的情况下，根据快速排序的定义，我们可知，快速排序的话，会确定一个值的位置也就是key，这个值的作用就是把数据分割成独立的两部分，一部分是比他大，一部分是比他小，而如果是升序的情况下直接选择left，选出的left的值是最小的，也就是说右面的部分是N-1个数据，而如果是用递归的方式实现的快排，那么就需要递归N次，也就是建立N个栈才能实现最终排序的操作，如果数据量大就很有可能出现栈溢出的情况。
该情况下递归的图片如图所示：
2.2-随机选择key: 随机选择key，也就是说，在数组下标范围内，随机生成一个下标，采用这个下标位置的数据值作为key这样的情况下，我们就大大降低了选出的key是最小值的情况。能有效地减少栈溢出的情况。
2.3-三数取中： 三数取中就是在left 、midi（(right+left)/2) 、right三个下标位置上的数据之间选择出这三个数据中的中间数。这样就避免了key为最小值的情况。
2.4-代码： void Swap(int* p, int* q)	//交换函数 { int tem = *p; *p = *q; *q = tem; } //直接选取法 int keyi = left; //随机选keyi int randi = left + (rand() % (right - left)); Swap(&amp;a[randi], &amp;a[left]); int keyi = left; //三数取中 int midi = GetMidNumi(a, left, right); if (midi !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0299a82e780118315da65016c867f238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d32e8367ee51a2206465a765d6f7da9b/" rel="bookmark">
			kafka-client如何打印连接日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Kafka客户端中打印连接日志，通常涉及配置日志框架来捕获和输出Kafka客户端在建立连接过程中的相关信息。由于Kafka客户端使用SLF4J（Simple Logging Facade for Java）作为日志门面，实际的日志实现（如Log4j2、Logback等）需要单独添加。以下是一个基于Log4j2的示例步骤，用于在Kafka客户端中打印连接日志：
步骤一：添加依赖
首先，确保你的项目中包含了Kafka客户端的依赖，以及SLF4J到Log4j2的桥接依赖和Log4j2的核心依赖。以下是一个Maven配置示例：
&lt;!-- Kafka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;你的Kafka客户端版本&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SLF4J到Log4j2的桥接 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;你的Log4j2版本&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Log4j2 API --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;你的Log4j2版本&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Log4j2 Core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;你的Log4j2版本&lt;/version&gt; &lt;/dependency&gt; 请注意，你需要将你的Kafka客户端版本和你的Log4j2版本替换为实际使用的版本号。
步骤二：配置Log4j2
在项目的resources目录下创建一个log4j2.xml文件，用于配置Log4j2。以下是一个简单的配置示例，它将日志输出到控制台，并设置日志级别为DEBUG或更低，以便捕获连接日志：
xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configuration status="WARN"&gt; &lt;Appenders&gt; &lt;Console name="Console" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level="debug"&gt; &lt;!-- 设置为debug以捕获更多信息 --&gt; &lt;AppenderRef ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d32e8367ee51a2206465a765d6f7da9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/734f78e951751b368117a2e00775cc3a/" rel="bookmark">
			uniapp小程序项目解决键盘问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 点击输入框，使页面不上移，并实现软键盘弹出。 步骤：
1. 使用adjust-position属性，禁止页面上移；
2. 但此时如果输入框在底部，当点击输入时，键盘会弹起，这时候需要动态移动输入框的位置，使输入框位于键盘的上面，所以页需要获取键盘的高度。
知识点：
1. input有一个adjust-position属性，控制当键盘弹起时，是否自动上推页面。
2. uni.onKeyboardHeightChange监听键盘高度变化，获取键盘高度。 获取键盘高度 input的adjust-position属性 2. 解决键盘弹出时和输入框是分开的，之间有空隙，显示出来感觉不流畅。 方法：动态改变输入框外面包裹的盒子的高度。
当最初，键盘没有弹出时，设置应该初始值；
当键盘弹出时，获取键盘的高度，设置盒子的高度=键盘的高度+最初盒子的高度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427cc081c46aa624ed3d9ff5b9c77119/" rel="bookmark">
			leetcode145. 二叉树的后序遍历，递归法&#43;迭代法，全过程图解&#43;步步解析，一点点教会你迭代法后序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode145. 二叉树的后序遍历，递归法+迭代法 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。
示例 1：
输入：root = [1,null,2,3]
输出：[3,2,1]
示例 2：
输入：root = []
输出：[]
示例 3：
输入：root = [1]
输出：[1]
递归法还是一如既往的简单。
postorder函数是递归函数，用于辅助实现后序遍历。它接收两个参数：一个指向当前节点的指针root和一个用于存储遍历结果的向量res。函数首先检查当前节点是否为空，如果是，则直接返回。如果不为空，则递归调用自身，先遍历左子树，再遍历右子树。在遍历完左右子树后，将当前节点的值添加到结果向量res中。
postorderTraversal函数是对外提供的公共接口，用于获取二叉树的后序遍历结果。它接收一个参数：一个指向二叉树根节点的指针root。函数首先初始化一个空的结果向量res，然后调用postorder函数进行后序遍历，并将遍历结果存储在res中。遍历完成后，返回这个结果向量。
整个实现过程是典型的递归方法，通过递归调用自身来遍历二叉树的每一个节点。递归的终止条件是当前节点为空，这时函数会返回而不执行任何操作。
class Solution { public: void postorder(TreeNode *root, vector&lt;int&gt; &amp;res) { if (root == nullptr) { return; } postorder(root-&gt;left, res); postorder(root-&gt;right, res); res.push_back(root-&gt;val); } vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; postorder(root, res); return res; } }; 二叉树后序遍历的迭代法相对前序和中序来说就要难一点了，
定义辅助栈：使用一个stack&lt;TreeNode *&gt;类型的栈stk来辅助遍历。
定义前一个访问节点：定义一个TreeNode *类型的指针prev，用来记录上一个被访问的节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/427cc081c46aa624ed3d9ff5b9c77119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d455dbf41d0f3157da7746b81c98fb30/" rel="bookmark">
			【香橙派AiPro】基于VGG16的火灾检测模型预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言开发板介绍开发板使用准备工作工具文档 拨码开关镜像烧录连接开发板下载MobaXterm网线-SSH连接开发板设置WIFI连接WIFI-SSH连接开发板确定开发板IP方法 Vnc可视化WindowsiPad 开发工具安装 散热风扇基于VGG16的火灾检测模型预测数据集准备目录结构代码操作 安装宝塔训练中的开发板表现负载方面散热方面 最后 引言 终于收到一款心仪已久的板子了，收到货后来不及吃灰就赶紧测试了，不得不说性价比很高，真不愧是Orange Pi AI Pro，对比其他板子性价比绝对第一！
开发板介绍 Orange Pi AI Pro开发板是一款香橙派和华为联合精心打造的高性能AI开发板，搭载了昇腾AI处理器，可实现图像、视频等多种数据分析处理
OrangePi AIpro(8-12T)采用昇腾AI技术路线，具体为4核64位处理器+AI处理器，集成图形处理器，支持8-12TOPS AI算力，拥有8GB/16GB LPDDR4X，可以外接32GB/64GB/128GB/256GB eMMC模块，支持双4K高清输出。
Orange Pi AIpro引用了相当丰富的接口，包括两个HDMI输出、GPIO接口、Type-C电源接口、支持SATA/NVMe SSD 2280的M.2插槽、TF插槽、千兆网口、两个USB3.0、一个USB Type-C 3.0、一个Micro USB（串口打印调试功能）、两个MIPI摄像头、一个MIPI屏等，预留电池接口，可广泛适用于AI边缘计算、深度视觉学习及视频流AI分析、视频图像分析、自然语言处理、智能小车、机械臂、人工智能、无人机、云计算、AR/VR、智能安防、智能家居等领域，覆盖 AIoT各个行业。 Orange Pi AIpro支持Ubuntu、openEuler操作系统，满足大多数AI算法原型验证、推理应用开发的需求。
接口详情图
开发板使用 准备工作 工具文档 官方工具：点我下载
用户手册：点我下载
ubuntu镜像：点我下载
本次用到：读卡器、网线
拨码开关 开发板支持从TF卡、eMMC和SSD（支持NVMeSSD和 SATASSD）启动。具体从哪个设备启动是由开发板背面的两个拨码（BOOT1和BOOT2）开关来控制的。
默认是通过TF卡启动的
体验评价：香橙派 AI Pro开发板通过其丰富的内置 API 和完善的文档支持，确实简化了开发流程并提高了易用性。这些特点使开发者能够更快速地进行应用程序的开发和调试，同时保证了开发过程的高效性和可靠性
镜像烧录 开发板出厂时，Sd卡已经有一个系统了，博主通电后发现SD卡上的小灯已亮了起来，官方原话给的是：
此绿灯由GPIO4_19控制其亮灭，可以作为SATA硬盘的指示灯或者其他需要的用途。目前发布的Linux系统默认在DTS中将其点亮。当看到此灯点亮后，至少可以说明Linux内核已经启动了。
由于没有读卡器，博主还未烧录过系统，不过很简单，可以参考这里
基于WindowsPC将Linux镜像烧写到TF卡的方法-11页
连接开发板 官方文档写明可通过多种方式连接开发板，这里使用了网线进行连接，连接后如下图所示：
下载MobaXterm 可以去官方提供的工具包里面下载，也可以 快速下载
网线-SSH连接开发板 网线连接这种方式，适合还未连接WIFI的板子 以及 没有显示屏的同学，将网线和开发板网口以及电脑连接后，可以通过共享网络使电脑为板子分配IP地址
查找到ip地址后，打开MobaXterm进行SSH连接
账号密码rootMind@123HwHiAiUserMind@123 输入账号和密码登录，注意：Linux密码是不显示的，输入完成回车即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d455dbf41d0f3157da7746b81c98fb30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d99835c8517c8bf2746665c2984473dc/" rel="bookmark">
			Apache Paimon 在蚂蚁的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 ：本文整理自 Apache Paimon Committer 闵文俊老师在5月16日 Streaming Lakehouse Meetup · Online 上的分享。内容主要分为以下四个部分：
什么是 Paimon蚂蚁 Paimon 应用场景蚂蚁 Paimon 功能改进未来规划 一、什么是 Paimon 1. 实时更新 Paimon 是一种面向流而设计的实时数据湖格式。主要有以下特点：
支持高效的实时更新，是基于 LSM Tree 结构，整个流程基于 Append + Compaction 模型。LSM Tree是业界经过很多DB系统采纳的一种存储结构，写入和更新的吞吐可以得到较好保障。Paimon 也支持多种不同的 Changelog Producer，Changelog 类似于数据库里面的Binglog，是流式增量计算的核心。Paimon 支持多种不同的生产模式，用于生成 Paimon 表的 Changelog， 基于此可构建出 Paimon 表作为中间层的流式处理 Pipeline。Paimon 支持多种 Merge Engine，用户可以使用去重、聚合、Partial Update 等做 Paimon 表的 Merge Engine，数据合并的方式很灵活，可以满足不同业务场景的需要。在最新的 0.8 版本也支持了Deletion Vector，可以极大的提升查询性能。
2. 流批一体 Paimon 是一个流批一体的存储，支持流读、批读、Time Travel 的方式查询、维表点查、全增量一体消费，也支持流式写入和批式导入。总的来说，流批场景里都有它适用的场景。
3. OLAP友好 Paimon 是 OLAP 比较友好的存储。首先，它支持列式存储，默认它是基于 ORC 的存储格式。其次，Paimon 也会有丰富的 Statistics 来帮助 Plan 阶段做好 Data Skipping 之类的 Plan 优化。第三，Paimon 支持各种 DataLayout 优化，比如 Zorder 和 Hilbert 排序和数据重分布的优化，加速查询过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d99835c8517c8bf2746665c2984473dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce32f66f93716ddc3b799bbd8fe097d9/" rel="bookmark">
			【数据结构】--- 顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言： 顺序表
动态顺序表的实现
代码总览：
前言：
数据结构是由“数据”和“结构”两词组合而来。
什么是数据？
常见的数值1、2、3、4.....、教务系统⾥保存的⽤⼾信息（姓名、性别、年龄、学历等
等）、网页里肉眼可以看到的信息（文字、图片、视频等等），这些都是数据
什么是结构？
当我们想要使⽤大量使⽤同⼀类型的数据时，通过⼿动定义⼤量的独立的变量对于程序来说，可读性非常差，我们可以借助数组这样的数据结构将⼤量的数据组织在⼀起，结构也可以理解为组织数据的方式
简而言之
能够存储数据（如顺序表、链表等结构） 存储的数据能够方便查找 那么为什么需要数据结构呢？
假定数组有10个空间，已经使用了5个，向数组中插入数据步骤：
求数组的长度，求数组的有效数据个数，向下标为数据有效个数的位置插入数据（注意：这里是
否要判断数组是否满了，满了还能继续插⼊吗）.....
假设数据量非常庞大，频繁的获取数组有效数据个数会影响程序执行效率。
结论：
最基础的数据结构能够提供的操作已经不能完全满⾜复杂算法实现。
顺序表 线性表
线性表是n个具有相同特性的数据元素的有限序列。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串等
线性表在了逻辑上是线性结构，也就是说是一条直线。但是在物理结构上并不一定是连续的，线性表在物理结构上存储时，通常以数组和链式结构的形式存储。
知识补充：
逻辑结构和物理结构
1.逻辑结构：
所谓逻辑结构就是数据与数据之间的关联关系，准确的说是数据元素之间的关联关系。
注：所有的数据都是由数据元素构成，数据元素是数据的基本构成单位。而数据元素由多个数据项构成。
逻辑结构有四种基本类型：集合结构、线性结构、树状结构和网络结构。也可以统一的分为线性结构和非线性结构。
2.物理结构：
数据的物理结构就是数据存储在磁盘中的方式。官方语言为：数据结构在计算机中的表示（又称映像）称为数据的物理结构，或称存储结构。它所研究的是数据结构在计算机中的实现方法，包括数据结构中元素的表示及元素间关系的表示。
而物理结构一般有四种：顺序存储，链式存储，散列，索引
顺序表
顺序表的底层结构就是数组，对数组的封装，实现了常用的增删改查等接口
顺序表可以分为静态顺序表和动态顺序表
静态顺序表
静态顺序表是使用定长的数组来存储元素
#define N 10 typedef int Type; //静态顺序表 struct SeqList { Type arr[N];//定长数组 int size;//有效数据个数 }; 使用动态顺序表缺陷：空间给小了不够用，空间给多了造成空间浪费
动态顺序表
动态顺序表的实现 静态顺序表是定长数组，而动态顺序表是可增容的，不会浪费空间也不会出现空间不够的场景，这里来实现动态顺序表存储整形数据：
首先就是顺序表的一些功能
这里将其写入SeqList.h 的头文件中
SeqList.h头文件
#pragma once #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int Type; typedef struct SeqList//动态顺序表 { Type* arr; int size; int num; }SL; //动态顺序表 // 初始化 void SLInit(SL* p); //销毁 void SLDesTroy(SL* p); //输出 void SLPrint(SL* p); //顺序表扩容 void SLExps(SL* p); //从头部插入数据 void SLAddHand(SL* p, Type x); //从头部删除数据 void SLDelHand(SL* p); //从尾部插入数据 void SLAddEnd(SL* p, Type x); //从尾部删除数据 void SLDelEnd(SL* p); //从任意位置插入数据 void SLAddeve(SL* p, Type x, int t); //从任意位置删除数据 void SLDeleve(SL* p, int t); //查找数据 int SLFind(SL* p, Type f); 要存储一些数据，顺序表具备以上功能（对于整型）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce32f66f93716ddc3b799bbd8fe097d9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/143/">«</a>
	<span class="pagination__item pagination__item--current">144/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/145/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>