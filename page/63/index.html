<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa414b9b000e278eedc72cd46898623/" rel="bookmark">
			Kali Linux——网络安全的瑞士军刀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 在网络安全的领域中，Kali Linux 宛如一把强大而全能的瑞士军刀，为安全研究人员和专业人士提供了丰富的工具和资源。本文将深入探讨 Kali Linux 的特点、优势、常用工具以及实际应用场景，带您领略这一强大操作系统的魅力。
二、Kali Linux 简介 Kali Linux 是基于 Debian 的 Linux 发行版，专门用于数字取证和渗透测试。它预装了数百种工具，涵盖了从信息收集、漏洞分析到网络攻击和防御等各个方面。
Kali Linux 的主要特点包括：
开源且免费：任何人都可以免费获取和使用，促进了安全技术的交流和发展。强大的工具集：集成了众多知名且实用的安全工具。频繁更新：确保工具的最新性和有效性，能够应对不断变化的安全威胁。 三、安装与启动 安装
可以通过官方网站下载镜像文件，然后选择适合您的安装方式，如虚拟机安装、双系统安装或直接安装在物理机上。启动
安装完成后，在启动菜单中选择 Kali Linux 即可进入系统。 四、Kali Linux 的工具分类 信息收集工具
Nmap：用于网络扫描和主机发现。Maltego：强大的信息收集和关联分析工具。 漏洞扫描工具
Nessus：全面的漏洞扫描器。OpenVAS：开源的漏洞评估系统。 密码攻击工具
John the Ripper：密码破解工具。Hashcat：高性能的哈希破解工具。 无线安全工具
Aircrack-ng：用于破解无线网络密码。Wifite：自动化的无线网络攻击工具。 取证工具
Autopsy：数字取证平台。Volatility：内存分析工具。 五、常用工具的使用示例 使用 Nmap 进行网络扫描
命令：nmap -sS 192.168.1.0/24 （对指定网段进行 SYN 扫描） 利用 Nessus 进行漏洞扫描
启动 Nessus，配置扫描策略，指定目标进行全面扫描。 使用 John the Ripper 破解密码
准备密码哈希文件，运行 John 并指定相关参数进行破解。 六、实际应用场景 企业网络安全评估
帮助企业发现网络中的安全漏洞和风险，提前采取防范措施。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aa414b9b000e278eedc72cd46898623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67609f7dcd23f04c98b3106e2fd86332/" rel="bookmark">
			二进制与其他进制整数部分的相互转换、原码、反码、补码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、进制的转换（二进制与其他进制） ① 二进制、八进制、十进制、十六进制均是数值的不同表示形式 2进制的数是由0、1组 ； 8进制的数是由0到7组成 10进制的数是由0到9组成 ；16进制的数是由0到9，以及a到f组成 ②10进制是逢10进1，2进制是逢2进1，依此类推可知n进制是逢n进1 ③二进制转十进制 ④ 十进制转二进制 除以2取余数，除到商为0为止，余数倒着排 ⑤ 二进制转八进制 从右往左，每3个二进制位转化为一个八进制位，剩余不够3个二进制位的之间转换。 ⑥ 八进制转二进制 从右往左，每一个8进制位转换为3个二进制位 ⑦二进制转十六进制 从右往左，每4个二进制位转换为1个二进制位，剩余不够4个二进制位的直接转换 转换原理：16进制的每一位（0到9以及a到f），每一个16进制位最多用4个二进制位就可以表示。 ⑧十六进制转二进制 从右往左，每一个16进制位转换为4个二进制位 二、原码、反码、补码 ①整数的2进制表⽰⽅法有三种，即原码、反码和补码。 整数分为有符号整数与无符号整数（0与正整数） a.有符号整数的二进制序列是由符号位与数值位组成，二进制序列的最高位是符号位（用0表示正数，1表示负数），其余位均是数值位。 b。无符号整数的二进制序列均由数值位组成 ②0与正整数的原、反、补码都相同，负整数的原、反、补码各不相同 ③原、反、补码之间的相互转换 a.原码：直接将数值按照正负数的形式，翻译成⼆进制序列得到的就是原码。 b.反码：在原码的基础上，符号位不变，其余位逐位取反得到的就是反码。 c.补码：反码加1就是补码。 总结：原码到补码、补码到原码，都是遵循取反加1的原则。其中取反是指符号位不变取余位逐位取反。 ④整数在内存中存储的是补码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ca680a6af7e40c8306a847de00a6ed/" rel="bookmark">
			【大模型从入门到精通15】openAI API 构建和评估大型语言模型（LLM）应用3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 设置评估前的准备工作先决条件获取LLM响应 根据评估标准评估响应构建详细的评估标准评估过程示例评估 设置评估前的准备工作 先决条件 在开始评估过程之前，请确保必要的工具和配置已经到位：
import os import openai from dotenv import load_dotenv # 从 .env 文件加载 OpenAI API 密钥 load_dotenv() openai.api_key = os.environ.get('OPENAI_API_KEY') 获取LLM响应 为了评估LLM的表现，首先需要根据用户的查询获取一个响应：
def fetch_llm_response(prompts, model="gpt-3.5-turbo", temperature=0, max_tokens=500): """ 根据一系列提示从LLM获取响应。 参数: prompts (list): 消息字典列表，其中每条消息都有一个'role'（系统或用户）和'content'。 model (str): 要使用的LLM模型标识符。 temperature (float): 控制输出的随机性，0是最确定性的。 max_tokens (int): 响应中的最大令牌数。 返回: str: LLM响应的内容。 """ response = openai.ChatCompletion.create( model=model, messages=prompts, temperature=temperature, max_tokens=max_tokens ) return response.choices[0].message["content"] 根据评估标准评估响应 构建详细的评估标准 评估标准作为评估LLM答案的指南，关注以下几个关键方面：
上下文相关性和事实准确性回答的完整性文本的连贯性和语法正确性 评估过程 在获取到LLM对查询的响应后，继续根据评估标准对其进行评估：
def evaluate_response_against_detailed_rubric(test_data, llm_response): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7ca680a6af7e40c8306a847de00a6ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc939bd9ca959317d730a3f71fb628e0/" rel="bookmark">
			UniTouch：开创性的多模态触觉模型引领零样本学习新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能咨询培训老师叶梓 转载标明出处
由于触觉数据收集过程昂贵且传感器输出标准化程度不高，多模态学习中触觉的融合一直是一个挑战。最近，一篇由耶鲁大学和密歇根大学的研究团队提出的论文《Binding Touch to Everything: Learning Unified Multimodal Tactile Representations》为这一难题提供了新的解决方案。研究团队提出了一个名为UniTouch的统一触觉模型，该模型能够将基于视觉的触觉传感器与多种模态连接起来。UniTouch通过将其嵌入与已经与其他模态相关联的预训练图像嵌入对齐来实现这一点。论文还提出了可学习的传感器特定标记，允许模型同时从一组异构的触觉传感器中学习。
如何将触觉与图像、文本和音频等多种模态相结合，用于解决触觉图像理解、图像合成等任务 方法 作者提出了一种新颖的方法来学习不同触觉传感器的统一触觉表征，这种表征能够捕捉触觉与其他模态（例如视觉、文本和音频）之间的关系。他们首先介绍了一种对比性视觉-触觉预训练方法，该方法能够实现触觉与其他模态之间的内在联系。
如图3所示，他们通过对比学习将触觉嵌入与大规模视觉语言数据预训练出的图像嵌入对齐。在这种方法中，图像嵌入已经与语言和音频等模态对齐。作者定义了视觉图像域 和触觉图像域​。给定一批视觉和触觉图像对，其中 和 ，他们通过最大化触觉嵌入和预训练的视觉嵌入 之间的余弦相似度来对齐它们。使用InfoNCE损失来优化这一目标，损失函数 如下所示： 其中 τ 是一个温度超参数，C 是特征维度。同样地，也可以从图像 到触觉 使用损失 ​。总的损失函数的和。
为了学习一个适用于不同触觉传感器的通用触觉表征，作者设计了触觉编码器来弥合由传感器设计差异导致的各种基于视觉的触觉传感器之间的域差距。具体来说，他们引入了一组可学习的传感器特定标记 ​，其中，用于捕获每个传感器的特定细节，例如触觉图像中的校准和背景颜色，以便模型的其余部分可以学习不同类型触觉传感器的共同知识，如纹理和几何形状。K 表示训练中使用的传感器数量，L 是每个传感器的传感器特定标记数量，D 是标记维度。
给定触觉图像 及其对应的触觉传感器标记，将这些传感器特定标记作为前缀添加到触觉图像块标记中，然后使用触觉编码器进行编码，得到最终的嵌入 。对于对比视觉-触觉预训练，他们优化了损失函数 ​，以及从另一个方向的 。
在批数据采样中，作者发现批采样策略在通过对比学习训练由多个触觉传感器获取的数据时非常重要。如果从每个数据源随机采样，会导致由于不同传感器之间的域差距而产生的大量简单负样本。因此，他们设计了一种批采样策略，以确保一批数据中有 σ 百分比的训练样本来自相同的数据集。数据集 D 是由不同触觉传感器收集的 N 个数据集的并集 ，选择给定数据集 进行采样的概率定义为 ​。表示所选数据集，从中进行均匀随机采样以产生 个样本；其余的 个样本则从其他数据集中均匀采样，其中 σ 是一个超参数，范围从0到1，代表批次中的比例。这种批采样策略显著有利于训练，因为它允许模型主要关注同一传感器的困难负样本，同时仍然暴露于不同的传感器以增强传感器间的区别。
在推理阶段，为了将学习到的表征泛化到看不见的传感器类型，他们从学习到的传感器集 中检索最近的邻居传感器特定标记。具体来说，首先计算每个传感器的原型，这是一个1D向量，平均所有由该传感器收集的触觉图像的原始像素，然后在训练后存储这些原型。在推理阶段，计算输入触觉图像与所有传感器原型之间的L1距离，并检索具有最小距离的传感器。
通过将触觉嵌入与联合潜在空间对齐，建立了触觉与其他模态之间的联系。这些对齐使我们能够在没有任何进一步训练的情况下执行各种零样本和跨模态应用。
零样本触觉理解：触觉和文本的紧急对齐使得零样本触觉理解成为可能，例如材料分类和抓取稳定性预测。遵循CLIP，作者使用模板和类名对触觉图像和文本提示进行编码。通过计算它们之间的相似度分数并进行排名，实现零样本分类。
触觉-LLM（Language Model）：使用现有的视觉-语言模型，该模型与对齐触觉嵌入的图像嵌入一致，可以通过切换到本触觉编码器来创建触觉-语言模型。给定触觉图像和语言输入，可以通过问答获得更全面的理解。
触觉图像合成：将触觉与文本绑定也为触觉图像合成开辟了更多潜在能力。作者利用预训练的文本到图像扩散模型，并使用触觉特征来条件化去噪过程，实现零样本触觉到图像生成[和触觉驱动的图像风格化。
X到触觉生成：作者还使用扩散模型将其他模态连接到触觉，以便实现X到触觉的生成，即通过视觉、描述或听觉来想象触觉。他们使用预训练的联合图像嵌入训练图像到触觉扩散模型，可以从文本和音频生成触觉。
实验 实验部分，作者展示了UniTouch模型在多个任务上的表现，这些任务覆盖了不同的应用领域，包括零样本触觉理解、跨模态检索、零样本图像合成、触觉语言模型（Touch-LLM）和从其他模态到触觉的生成（X-to-touch generation）。
实验基于ImageBind进行，使用AdamW优化器，基础学习率为1 × 10^−5，并且采用余弦衰减学习率调度器。模型在4个NVIDIA A40 GPU上，以每个批次大小48进行训练，共训练150个周期。温度参数τ设为0.07。触觉编码器采用Vision Transformer (ViT) 作为骨干网络，包含24个多头注意力块，每个块有16个头。特征维度C设为1024。在预训练数据集中，为每种传感器类型使用5个可学习的标记（L = 5），共训练了3种不同的传感器（K = 3）。批内采样策略中，σ设为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc939bd9ca959317d730a3f71fb628e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675001744628a40612906fa05a632dc7/" rel="bookmark">
			C语言指针详解-包过系列（二）目录版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言指针详解-包过系列（二）目录版 1、数组名的深入理解1.1、数组名的本质1.2、数组名本质的两个例外1.2.1、sizeof（数组名）1.2.2、&amp;数组名 2、使用指针访问数组3、一维数组传参本质4、二级指针4.1、二级指针介绍4.2、二级指针运算 5、指针数组（模拟实现二维数组） 1、数组名的深入理解 1.1、数组名的本质 数组名的本质其实就是数组首元素的地址。我们以下面的代码测试为例：
#include&lt;stdio.h&gt; int main() { int arr[10] = {1,2,3,4,5,6,7,8,9,10}; printf("&amp;arr[0] = %p\n ", &amp;arr[0]);//取数组首元素地址 printf("arr = %p\n ", arr);//取数组数组名 return 0; } 可见二者一模一样，故验证了数组名即为数组首元素地址。
但是可能会有读者提出以下质疑：
#include&lt;stdio.h&gt; int main() { int arr[10] = {1,2,3,4,5,6,7,8,9,10}; printf("%d", sizeof(arr)); return 0; } 若数组名 arr 表示的是数组首元素的地址的话，那么输出结果应当为一个地址的大小，也就是4/8字节。这就涉及到了数组名是数组首元素地址的两个例外了，请见 1.2 。
1.2、数组名本质的两个例外 1.2.1、sizeof（数组名） 在关键字 sizeof 中单独放入数组名时，这个数组名表示的是整个数组，计算的是整个数组的大小，单位是字节。如上 1.1 中所示。
注意：只有是单独放入数组名时，数组名才表示整个数组，其余情况下均是计算数据类型大小。
如下面代码所示：
#include&lt;stdio.h&gt; int main() { int arr[10] = {1,2,3,4,5,6,7,8,9,10}; printf("%d", sizeof(arr + 1));//此时 arr 就又恢复成数组首元素的地址了 return 0; } 在 x86 环境下的运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/675001744628a40612906fa05a632dc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4a0161dc52030cf7a1fd309705c86f/" rel="bookmark">
			请求转发（J2EE）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java Web开发中，请求转发（Forwarding）是一种常见的技术，用于将请求从一个Servlet发送到另一个Servlet、JSP页面或其他资源，而不直接向客户端浏览器返回响应。这种技术允许在同一个应用程序内部的不同组件之间共享请求信息和处理结果。
使用ServletRequest和ServletResponse实现请求转发
在Servlet中，可以使用ServletRequest和ServletResponse的 getRequestDispatcher() 方法来实现请求转发。基本请求转发示例：
import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ForwardServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 在 doGet 中获取请求参数或执行其他业务逻辑 // 获取转发目标的Servlet路径或JSP路径 String forwardPath = "/WEB-INF/showData.jsp"; // 例如，转发到位于 WEB-INF 目录下的 showData.jsp // 获取请求分派器，用于将请求转发到指定路径 request.getRequestDispatcher(forwardPath).forward(request, response); } } 详细说明：
在上述示例中，getRequestDispatcher(String path) 方法用于获取一个请求分派器，其参数是要转发的目标路径。这个路径可以是另一个Servlet的映射路径或者是JSP页面的路径。
转发路径可以是相对于当前Servlet上下文的路径，例如 /path/to/resource，也可以是相对于WEB-INF目录的路径（用于保护JSP文件），例如 /WEB-INF/showData.jsp。
forward(request, response) 方法将当前的ServletRequest和ServletResponse对象传递给目标资源，即被转发的Servlet或JSP页面，使得目标资源可以处理请求并生成响应。
注意事项：
请求属性的传递：使用转发时，可以在转发前将属性设置到request对象中，这些属性可以在目标Servlet或JSP中使用。
响应内容的生成：转发的目标页面或Servlet生成的内容会直接作为响应返回给客户端，因此客户端不知道请求是否被转发过程。
路径的正确性：确保目标路径的正确性和可访问性，特别是对于位于WEB-INF目录下的JSP页面，这些页面无法直接通过浏览器访问，只能通过请求转发来间接访问。
通过这种方式，可以在Java Web应用程序中实现灵活而高效的请求处理和页面跳转，保持代码整洁和逻辑清晰。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2147cb8dde5575b48ac87ecd14ded0e3/" rel="bookmark">
			如何从戴尔笔记本电脑硬盘恢复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“如何从坏掉的戴尔笔记本电脑硬盘中恢复数据？我无法访问硬盘，但我确实需要从硬盘中检索数据。我有很多重要文件被困在那里。”
人们学习如何从戴尔笔记本电脑硬盘恢复数据的原因有很多，例如有意或无意删除、硬盘格式化、安全警告隔离受病毒感染的文件、系统崩溃导致硬盘无法访问等等。无论您的戴尔笔记本电脑硬盘发生了什么，您必须做的第一件事就是从戴尔笔记本电脑硬盘中拯救您的文件。
是否可以从损坏的戴尔笔记本电脑硬盘中恢复数据？ 我想说的是，如果您的计算机可以识别戴尔笔记本电脑硬盘，您就有机会从戴尔笔记本电脑硬盘中恢复数据，即使它是一块坏掉的硬盘。如果您无法通过戴尔笔记本电脑访问它，您可以将其从坏掉的计算机中取出，将其连接到新计算机，尝试在新计算机上从坏掉的硬盘中恢复数据。为什么删除或丢失的数据可以恢复？无论您如何丢失戴尔笔记本电脑硬盘中的数据，它都必须遵守规则：所有存储设备（包括硬盘、外部硬盘、USB 闪存驱动器等）上删除的文件不会立即消失。它们隐藏在原始位置，等待被替换或技术覆盖。在这种情况下，如果您快点，您可以在覆盖发生之前从戴尔笔记本电脑硬盘中恢复数据。
如何从戴尔笔记本电脑硬盘恢复数据？ 戴尔笔记本电脑硬盘中丢失或删除的数据无法手动查看和恢复。它不是垃圾箱。如果您想恢复数据，必须使用硬盘数据恢复软件工具。它将帮助您扫描戴尔笔记本电脑硬盘以查找目标文件。在这里，我想向您推荐奇客数据恢复。
与其他软件不同，奇客数据恢复是为个人开发的，用于恢复计算机和硬盘上的各种数据。在这种情况下，没有行话，不需要任何技术。而且界面非常简单易用。人们只需按照内置向导操作，他们就知道如何从戴尔笔记本电脑硬盘恢复数据。它支持各种格式的所有最广泛使用的文件，包括视频、图片、音频文件、文档、电子邮件等。在下面，您可以看到如何使用它从戴尔笔记本电脑恢复已删除的文件或从戴尔笔记本电脑硬盘恢复数据。
步骤1.安装戴尔笔记本电脑数据恢复软件 单击下载获取软件安装包文件 .exe。将其保存在您的计算机上并双击进行安装。
奇客数据恢复: 支持1000+数据格式恢复免费下载软件扫描数据，支持文件、照片、视频、邮件、音频等1000+种文件的格式恢复更有电脑/笔记本、回收站、U盘、硬盘等各类存储设备数据丢失恢复https://www.geekersoft.cn/geekersoft-data-recovery.html它与所有 Windows 操作系统完全兼容。您甚至可以看到有一个 Mac 版本。如果您拆下坏掉的戴尔笔记本电脑硬盘并想从中恢复数据，请将其连接到您的计算机。确保您的计算机可以将其检测为外部硬盘。
步骤2.选择要从戴尔硬盘恢复的文件 启动软件，您可以看到已选择所有支持的文件类型，包括“其他”，并且软件已准备好从戴尔笔记本电脑硬盘恢复数据。如果要恢复所有文件，请保留它们并单击“下一步”。如果不是，请取消选择不需要的文件类型，只保留所需的文件类型，然后单击“下一步”。
步骤3.选择要扫描的戴尔笔记本电脑硬盘 接下来，您可以看到所有硬盘都列在那里供您选择，包括连接到计算机的硬盘（如果有）。请选择要恢复数据的硬盘，然后单击“扫描”。之后，您可以看到进度条告诉您扫描过程的进展情况。请耐心等待它完成整个扫描过程。
步骤4.从戴尔笔记本电脑硬盘恢复数据 默认情况下，扫描模式为快速扫描。从戴尔硬盘中查找数据不会花费太长时间。完成后，请在左侧筛选文件类型并查看右侧的详细信息。找到目标文件后，选择它们并单击“恢复”以将其再次保存到您的计算机上。
您可以在结果窗口中看到“深度扫描”选项。这是可选的。如果您想从戴尔笔记本电脑硬盘中恢复更多文件，请尝试一下。它会更深入、更仔细地扫描丢失的文件。即使部分文件属性被覆盖，此模型也可以找到文件。
提示：如何保证戴尔笔记本电脑硬盘中的数据安全？ 老实说，没有人能保证你的电脑不会出问题。最安全的方法是将重要文件保存在 C:/ 以外的其他磁盘分区中，因为这是数据丢失最容易和最常见的地方。另一个建议是定期备份你的电脑硬盘。我不是说你手动复制重要文件，而是使用备份软件，比如奇客数据恢复。有很多这样的工具，它用压缩文件备份你的电脑，确保你的文件在你需要副本时是安全的。最好将备份文件保存在外部硬盘上，比如 WD 硬盘、USB 闪存盘，甚至云存储服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772702d545db12e61020afc55883a4a2/" rel="bookmark">
			Zotero InfiniCloud WebDAV同步附件时的证书报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直使用TeraCloud（现更名为InfiniCloud）作为WebDAV网盘同步Zotero的文献附件资料。前几天同步时候突然报错：
toi.teracloud.jp uses an invalid security certificate.
The certificate is not trusted because the issuer certificate is unknown.
The server might not be sending the appropriate intermediate certificates.
An additional root certificate may need to be imported.
Error code: SEC_ERROR_UNKNOWN_ISSUER
我先是和InfiniCloud客服询问相关信息，获得的答复是Zotero的故障，相关回复如下。后在Zotero论坛发现了实际原因和解决方案，亲测有效。
InfiniCloud官方支援回复邮件节选
Unfortunately, this appears to be an issue from Zotero's side, not InfiniCLOUD.
This problem has been acknowledged and hopefully will be resolved in the near future.
The root certificate is not supported by Zotero6, which is causing the synchronization issue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772702d545db12e61020afc55883a4a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7340bb0247ba9501f1a17a2116298b58/" rel="bookmark">
			鸿蒙（API 12 Beta3版）【音频解码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发者可以调用本模块的Native API接口，完成音频解码，即将媒体数据解码为PCM码流。
当前支持的解码能力如下:
容器规格音频解码类型mp4AAC、MPEG(MP3)、Flac、Vorbis、AudioViVid11+m4aAACflacFlacoggVorbis、opusaacAACmp3MPEG(MP3)amrAMR(amrnb、amrwb)rawG711muapeAPE 适用场景
音频播放
在播放音频之前，需要先解码音频，再将数据输送到硬件扬声器播放。
音频渲染
在对音频文件进行音效处理之前，需要先解码再由音频处理模块进行音频渲染。
音频编辑
音频编辑（如调整单个声道的播放倍速等）需要基于PCM码流进行，所以需要先将音频文件解码。
开发指导 参考以下示例代码，完成音频解码的全流程，包括：创建解码器、设置解码参数（采样率/码率/声道数等）、开始、刷新、重置、销毁资源。
在应用开发过程中，开发者应按一定顺序调用方法，执行对应操作，否则系统可能会抛出异常或生成其他未定义的行为。具体顺序可参考下列开发步骤及对应说明。
如下为音频解码调用关系图：
在 CMake 脚本中链接动态库 target_link_libraries(sample PUBLIC libnative_media_codecbase.so) target_link_libraries(sample PUBLIC libnative_media_core.so) target_link_libraries(sample PUBLIC libnative_media_acodec.so) 开发步骤 添加头文件。 #include &lt;multimedia/player_framework/native_avcodec_audiocodec.h&gt; #include &lt;multimedia/native_audio_channel_layout.h&gt; #include &lt;multimedia/player_framework/native_avcapability.h&gt; #include &lt;multimedia/player_framework/native_avcodec_base.h&gt; #include &lt;multimedia/player_framework/native_avformat.h&gt; #include &lt;multimedia/player_framework/native_avbuffer.h&gt; 创建解码器实例对象，OH_AVCodec *为解码器实例指针。 //c++标准库命名空间 using namespace std; // 通过 codecname 创建解码器 OH_AVCapability *capability = OH_AVCodec_GetCapability(OH_AVCODEC_MIMETYPE_AUDIO_MPEG, false); const char *name = OH_AVCapability_GetName(capability); OH_AVCodec *audioDec_ = OH_AudioCodec_CreateByName(name); // 设置判定是否为编码；设置false表示当前是解码。 bool isEncoder = false; // 通过 Mimetype 创建解码器 OH_AVCodec *audioDec_ = OH_AudioCodec_CreateByMime(OH_AVCODEC_MIMETYPE_AUDIO_MPEG, isEncoder); // 初始化队列 class ADecBufferSignal { public: std::mutex inMutex_; std::mutex outMutex_; std::mutex startMutex_; std::condition_variable inCond_; std::condition_variable outCond_; std::condition_variable startCond_; std::queue&lt;uint32_t&gt; inQueue_; std::queue&lt;uint32_t&gt; outQueue_; std::queue&lt;OH_AVBuffer *&gt; inBufferQueue_; std::queue&lt;OH_AVBuffer *&gt; outBufferQueue_; }; ADecBufferSignal *signal_; 调用OH_AudioCodec_RegisterCallback()注册回调函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7340bb0247ba9501f1a17a2116298b58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5288da9c07bbb2e8c697f614fdc9e818/" rel="bookmark">
			SpringBoot-疫起买菜平台小程序-99212（免费领源码&#43;开发文档）可做计算机毕业设计JAVA、PHP、爬虫、APP、小程序、C#、C&#43;&#43;、python、数据可视化、大数据、全套文案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序+spring boot疫起买菜平台 摘 要 随着我国经济迅速发展，人们对手机的需求越来越大，各种手机软件也都在被广泛应用，但是对于手机进行数据信息管理，对于手机的各种软件也是备受用户的喜爱，疫起买菜平台小程序被用户普遍使用，为方便用户能够可以随时进行在线查看疫起买菜平台的数据信息管理，特开发了疫起买菜平台小程序。
疫起买菜平台小程序的设计主要是对系统所要实现的功能进行详细考虑，确定所要实现的功能后进行界面的设计，在这中间还要考虑如何可以更好的将功能及页面进行很好的结合，方便用户可以很容易明了的找到自己所需要的信息，还有系统平台后期的可操作性，通过对信息内容的详细了解进行技术的开发。
疫起买菜平台小程序的开发利用现有的成熟技术参考，以源代码为模板，分析功能调整与疫起买菜平台小程序管理的实际需求相结合，讨论了基于疫起买菜平台小程序管理的使用。 关键词：疫起买菜平台小程序；springboot Small program + spring boot Abstract With the rapid development of China's economy, people's demand for mobile phones is growing, and various mobile phone software are also widely used. However, for data information management of mobile phones, various software of mobile phones are also popular with users. The small program of the epidemic buying platform is widely used by users. In order to facilitate users to view the data information management of the epidemic buying platform online at any time, We have developed a small program for buying vegetables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5288da9c07bbb2e8c697f614fdc9e818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/322f3fb21782af08dd05673d77dbef10/" rel="bookmark">
			EasyExcel动态表头导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、封装方法 package com.skybird.iot.base.utils; import cn.hutool.core.util.StrUtil; import com.alibaba.excel.EasyExcel; import com.alibaba.excel.support.ExcelTypeEnum; import com.alibaba.excel.write.metadata.style.WriteCellStyle; import com.alibaba.excel.write.metadata.style.WriteFont; import com.alibaba.excel.write.style.HorizontalCellStyleStrategy; import com.skybird.iot.base.utils.bean.Custemhandler; import java.io.IOException; import java.io.OutputStream; import java.net.URLEncoder; import java.util.List; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.poi.ss.usermodel.HorizontalAlignment; import org.apache.poi.ss.usermodel.IndexedColors; import org.apache.poi.ss.usermodel.VerticalAlignment; public class EasyExcelUtil { /** * @param response * @param t 导出实体类 * @param list 数据集合 * @param name 文件名称 * @throws IOException * @throws IllegalAccessException * @throws InstantiationException */ public static void download( HttpServletRequest request, HttpServletResponse response, Class t, List list, String name) throws IOException, IllegalAccessException, InstantiationException { /*兼容IE和其他浏览器导出文件名乱码的问题*/ // name = downloadCommFileName(name, request); response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/322f3fb21782af08dd05673d77dbef10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e160c6490c0ac98f7a49d2a6ae8156/" rel="bookmark">
			保研考研机试攻略：第二章——入门经典（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍦🍦🍦由于代码都是我自己敲出来调试的，所以可能不能一次更新那么多，大家见谅，不过因为我最近在备考机试，所以会拿出大量的时间在这上边，更新的会比较勤的~~~
目录
🧊🧊🧊2.4 日期类问题
🥥题型总结：
🥥例题：DreamJudge 1051
🥥练习题目：
DreamJudge 1011 日期
DreamJudge 1290 日期差值
DreamJudge 1410 打印日期
DreamJudge 1437 日期类
DreamJudge 1446 日期累加 🍰
DreamJudge 1053 偷菜时间表
🧊🧊🧊2.5 字符串类问题
🥥题型总结：
🥥例题：DreamJudge 1014
🥥练习题目：
DreamJudge 1012 字符移动
DreamJudge 1292 字母统计
DreamJudge 1240 首字母大写 🍰
DreamJudge 1394 统计单词
DreamJudge 1027 删除字符串 2🍰
🧊🧊🧊2.6 排序类问题
🥥例题：DreamJudge 1151
🥥例题：DreamJudge 1010
🥥特殊排序题：
普通排序（适合n&lt;=2000的情况）：
快速排序（适合n&lt;=50W的情况）：
🥥练习题目：
DreamJudge 1106 排序 2 🍰
DreamJudge 1159 成绩排序 2.0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e160c6490c0ac98f7a49d2a6ae8156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69db44dcecddcd3fa47ce818d5f95de3/" rel="bookmark">
			【Python】PyWebIO 初体验：用 Python 写网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1 使用方法1.1 安装 Pywebio1.2 输出内容1.3 输入内容 2 示例程序2.1 BMI 计算器2.2 Markdown 编辑器2.3 聊天室2.4 五子棋 前言 前两天正在逛 Github，偶然看到一个很有意思的项目：PyWebIo。
这是一个 Python 第三方库，可以只用 Python 语言写出一个网页，而且支持 Flask，Django，Tornado 等 web 框架。
甚至，它可以支持数据可视化图表的绘制，还提供了一行函数渲染 Markdown 文本。
那么话不多说，正片开始——
仓库地址：https://github.com/pywebio/PyWebIO
1 使用方法 1.1 安装 Pywebio 打开 CMD，在里面输入以下代码：
pip install pywebio 如果速度太慢，建议使用国内镜像：
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pywebio 1.2 输出内容 put_text() 输出文字put_table() 输出表格put_markdown() 输出 markdown 内容put_file() 输出文件下载链接put_image() 输出图片put_button() 输出按钮 请看示例程序：
from pywebio.output import * def main(): # 文本输出 put_text("Hello world!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69db44dcecddcd3fa47ce818d5f95de3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9173cd4b4202848bf8ccc546da10874f/" rel="bookmark">
			Rust实现构建器模式和使用Bon库中的构建器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现构建器模式的一种方式 这里参考资料2的文章，修改部分代码后如下。这段代码的目的是使用构建器模式创建和初始化Person对象。以下是各部分的解释：
结构体定义
Person: 定义了一个结构体，包含name、age、address和sex四个字段。address和sex是可选的PersonBuilder: 用于逐步构建Person对象的构建器结构体 构建器实现
new: 创建一个新的PersonBuilder实例，初始化name和age，其他字段为Nonewith_address: 设置address字段，返回修改后的构建器with_sex: 设置sex字段，返回修改后的构建器build: 生成最终的Person对象 主函数
使用PersonBuilder构建一个Person对象，设置name、age、address和sex打印Person对象及其各个字段的值 目的
封装对象创建过程: 使用构建器模式来管理对象初始化的复杂性可选字段设置: 允许灵活地设置可选字段，而不必在创建对象时提供所有信息链式调用: 提供链式调用的接口，使代码更简洁易读 #[derive(Debug)] struct Person { name: String, age: u32, address: Option&lt;String&gt;, sex: Option&lt;String&gt;, } struct PersonBuilder { name: String, age: u32, address: Option&lt;String&gt;, sex: Option&lt;String&gt;, } impl PersonBuilder { fn new(name: String, age: u32) -&gt; Self { Self { name, age, address: None, sex: None, } } fn with_address(mut self, address: String) -&gt; Self { self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9173cd4b4202848bf8ccc546da10874f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13529b2bfcd0045d98403d27672598a9/" rel="bookmark">
			【IEEE独立出版】第四届计算机科学与区块链国际学术会议 (CCSB 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四届计算机科学与区块链国际学术会议 (CCSB 2024) 2024 4th International Conference on Computer Science and Blockchain 2024年9月6-8日 中国-深圳 老牌会议 | 涵盖计算机学科 | 往届均完成见刊、稳定检索 | 论文录用速度快 | 有ISBN号! *关于IEEE出版社
电气电子工程师学会（IEEE）的英文全称是the Institute of Electrical and Electronics Engineers。作为全球最大的专业技术组织，在电气及电子工程、计算机及其他技术领域中，IEEE出版了近三分之一的技术文献，其中包括每年出版的200本期刊和杂志，IEEEXplore数字图书馆文献已超过500万篇。配合各专业技术领域的学术交流活动，IEEE还提供学报、技术通讯、会议论文集和会刊等出版物。目前该出版社EI检索非常稳定！
CCSB 2024已成功申请IEEE出版！（ISBN号：979-8-3503-5650-2）
投稿录用缴费者可免费参与线下会议学术交流、晚宴活动
重要信息
会议官网：www.iccsb.net
会议时间：2024年9月6-8日
会议地点：中国-深圳
三轮截稿时间：2024年8月15日前
审稿回复时间：投稿后7个工作日内
提交检索类型：IEEE Xplore, EI Compendex，Scopus
【点击查看】
CCSB 2024已被IEEE收录进官方会议列表
大会简介
CCSB 2024会议由深圳大学主办，旨在探讨计算机科学的最新发展如何与区块链技术相结合，以及这一结合如何推动金融、供应链管理、数据安全和其他多个行业的革新，本次会议将提供一个多学科交流的平台，汇集来自相关领域学者的研究和思想，共同讨论计算机科学与区块链技术的交汇点，以及这些技术如何塑造我们的未来，推进计算机科学与区块链技术的研究和应用，为未来的技术进步奠定坚实的基础。
主办单位承办单位 深圳大学
深圳大学-计算机与软件学院
支持单位 大会检索历史
CCSB往届会议均已顺利完成EI, Scopus检索，会议历史良好
可点击图片查看详情（往届会后3-4个内月完成检索）
CCSB 2023 Proceedings
EI Compendex
Scopus
CCSB 2022 Proceedings
EI Compendex
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13529b2bfcd0045d98403d27672598a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186b4bb075a51cee924b55efc8061b07/" rel="bookmark">
			人工智能安全态势和趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 吴世忠
中工院士 国家保密科技委主任
重大风险隐患呼唤加强安全研究，人工智能面临未来担忧
1 总体态势 1.1 相对于技术发展，安全研究严重滞后 1.2 我国研究十分活跃，论文数量遥遥领先 1.3 影响力美国排名第一，大厂大学作用大 1.4 研究范围宽阔，安全内涵外延拓展 从传统在机密性、可靠性、完整性、逐步扩展到公平性、伦理性等
1.5 头部企业共识渐成，纷纷加大安全投入 1.6 大国博弈日益加剧，安全成为竞争售点 2 现状与趋势 2.1 学术研究的四大方向 2.1.1 理论研究 2.2 技术应用的五大领域 2.2.1 安全风险：验证技术机理，识别应用风险 虚假信息传播
有害内容
2.2.2 安全防护 2.2.3 安全攻击：立足以攻促防，强化积极防御 2.2.4 安全测评 2.2.5 安全治理：平衡发展安全，落实治理要求 2.3 未来展望九大问题 2.3.1 自身安全 更高水平的可解释性和透明性安全性和可靠性的增强公平性和伦理研究的深入 2.3.2 网络安全 更复杂和广泛的对抗性更加增强的隐私保护技术自动化攻击与防御对抗 2.3.3 发展安全 跨模态、多模态安全抗量子AI安全技术人机交互安全技术 3 启示 3.1 安全认知，日渐清晰 攻防安全+自身安全+伦理安全
3.2 安全研究，路阻且长 大模型解释性和透明性伦理和道德复杂性和多样性安全保障技术复杂性和多样性对象复杂性，标准多样，方法完备性，工具局限性 2.3 安全事业大有可为 安全产业迈入AI程度驱动的新时代
更及时的威胁感知 2.4 紧跟创新，保障发展 紧扣AI进化中的安全风险促进发展的治理策略更多采用跨学科研究方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e957f61aa777841c0fdeca2e852e8313/" rel="bookmark">
			Jenkins,Jupyter,NoteBook未授权访问漏洞（及修复方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Jenkins 默认情况下 Jenkins⾯板中⽤户可以选择执⾏脚本界⾯来操作⼀些系统层命令，攻击者可通过未授权访问漏洞或者暴⼒破解⽤户密码等进⼊后台管理服务，通过脚本执⾏界⾯从⽽获取服务器权限。
漏洞复现 首先我们利用如下语句在fofa中搜索
port="8080" &amp;&amp; app="JENKINS" &amp;&amp; title=="Dashboard [Jenkins]" 找到一个页面中有Manage Jenkins的，往下滑会有一个Scritp Console
点开之后我们就可以在里面执行命令了，这里我们执行一个println "whoami" .execute().text，发现成功执行
如何修复 1. 升级版本。
2. 添加认证，设置强密码复杂度及账号锁定。
3. 禁⽌把Jenkins直接暴露在公⽹。
二.Jupyter NoteBook Jupyter Notebook（此前被称为 IPython notebook）是⼀个交互式笔记本，⽀持运⾏ 40多种编程语⾔。如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建⼀个console并执⾏任意Python代码和命令，默认端⼝：8888。
漏洞复现 同样的，我们在fofa中搜索"Jupyter Notebook" &amp;&amp; port="8888"，如果存在未授权访问漏洞，那么点进去会直接跳转到web页面，否则就会到一个登陆页面
登陆页面
web页面
在web页面，我们可以直接创建一个终端来执行命令，点击new里的terminal即可
然后在这里可以直接执行命令
如何修复 1. 开启身份验证，防⽌未经授权⽤户访问。
2. 访问控制策略，限制IP访问，绑定固定IP。
三.Elasticsearch ElasticSearch是⼀个基于Lucene的搜索服务器。它提供了⼀个分布式多⽤户能⼒的全⽂搜索引擎，基于RESTful web接⼝。Elasticsearch是⽤Java开发的，并作为Apache许可条款下的开放源码发布，是当前流⾏的企业级搜索引擎。Elasticsearch的增删改查操作全部由http接⼝完成。由于Elasticsearch授权模块需要付费，所以免费开源的Elasticsearch可能存在未授权访问漏洞。该漏洞导致，攻击者可以拥有Elasticsearch的所有权限。可以对数据进⾏任意操作。业务系统将⾯临敏感数据泄露、数据丢失、数据遭到破坏甚⾄遭到攻击者的勒索。
复现步骤： 首先我们利用如下语法在fofa中进行搜索
"Elasticsearch" &amp;&amp; port="9200" 然后寻找能直接点进去查看到信息的ip
含有未授权访问漏洞则会出现如下页面
可以按照上面的查看节点信息，如访问ip的/_nodes 目录
如何修复 1. 访问控制策略，限制IP访问，绑定固定IP。
2. 在 config/elasticsearch.yml 中为9200端⼝设置认证等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526b231cb55002d7bec0c081339a842b/" rel="bookmark">
			三防平板助力MES系统，实现工厂移动式生产报工
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今竞争激烈的制造业环境中，提高生产效率、优化生产流程以及实现精准的生产管理已经成为企业生存和发展的关键。 MES系统作为连接企业计划层和控制层的桥梁，在实现生产过程的信息化、数字化和智能化方面发挥着重要作用。与此同时，三防平板的出现为 MES 系统的应用带来了新的突破，实现了工厂移动式生产报工，进一步提升了生产管理的灵活性和效率。
一、MES 系统在工厂生产管理中的重要性 MES 系统能够实时收集生产过程中的各种数据，包括生产进度、设备状态、质量检测结果等，并将这些数据与企业的 ERP 系统进行集成，为企业管理层提供准确、及时的生产信息，以便做出科学的决策。通过 MES 系统，企业可以实现生产计划的精确执行、生产过程的严格控制以及产品质量的有效追溯，从而提高生产效率、降低生产成本、提升产品质量。
二、三防平板在 MES 系统中的应用优势 三防平板具有防水、防尘、防震的特点，能够适应工厂恶劣的生产环境。与传统的台式电脑或笔记本电脑相比，三防平板更加便携、灵活，操作方便，能够让工人在生产现场随时随地进行生产报工、数据采集和设备巡检等操作。
1.便携性：工人可以手持三防平板在车间内自由移动，无需固定在某个工位上，大大提高了工作的灵活性。
2.实时性：三防平板通过无线网络与 MES 系统进行连接，能够实时上传和下载生产数据，确保生产信息的及时性和准确性。
3.操作简单：三防平板通常采用触摸屏操作，界面简洁直观，易于上手。工人无需经过复杂的培训，即可熟练使用三防平板进行生产报工等操作，降低了企业的培训成本。
三、三防平板助力工厂实现移动式生产报工的具体场景 1.生产线上的报工：工人在完成一道工序后，使用三防平板扫描产品上的条码或二维码，填写生产数量、质量情况等信息，然后点击提交，即可完成生产报工。MES 系统会实时更新生产进度，管理人员可以通过系统实时掌握生产情况。
2.设备巡检：设备维护人员携带三防平板，按照预设的巡检路线对设备进行巡检。在巡检过程中，使用三防平板记录设备的运行状态、故障信息等，并及时上传到 MES 系统。
3.质量检测：质量检测人员使用三防平板对产品进行抽检或全检，记录检测结果。如果发现质量问题，可以通过三防平板追溯到生产过程中的相关数据，找出问题的根源，并及时采取措施进行整改。
三防平板与 MES 系统的结合，为工厂带来了全新的生产管理模式，实现了移动式生产报工，提高了生产效率和管理水平。随着技术的不断发展和应用的不断深入，相信三防平板在制造业中的应用将会越来越广泛，为制造业的转型升级提供更强大的支持。
XF
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ba06536c4cc3994b7d7e924c0ec9ee/" rel="bookmark">
			【经验分享】ShardingSphere&#43;Springboot-03 : COMPLEX_INLINE 复杂行表达式分片算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3.3 复杂分片算法3.3.1 COMPLEX_INLINE 复杂行表达式分片算法 3.3 复杂分片算法 3.3.1 COMPLEX_INLINE 复杂行表达式分片算法 复合分片比较灵活，适合于分片的字段比较多，分片比较复杂的场景，使用这种分片的话必须对自己的业务比较明确
属性名称数据类型说明默认值sharding-columns (?)String分片列名称，多个列用逗号分隔。如不配置无法则不能校验algorithm-expressionString分片算法的行表达式allow-range-query-with-inline-sharding (?)boolean是否允许范围查询。注意：范围查询会无视分片策略，进行全路由false 这样看官方文档还是写的不够详细，举个例子，创建一个用户表结构如下，分别是数据源ds1/ds2中分别创建以下两张表
实现目标：根据用户类型user_type和部门dep_id进行复杂分库分表
配置yaml如下：
spring: shardingsphere: rules: sharding: tables: # 用户表 sys_user: actual-data-nodes: ds${0..1}.sys_user_${0..1} key-generate-strategy: column: id key-generator-name: snowflake database-strategy: standard: sharding-algorithm-name: id_db_algorithm sharding-column: id table-strategy: # 注意：声明为复杂算法 complex: # 指定参与复杂算法的分片列 sharding-columns: user_type,dep_id sharding-algorithm-name: user_type_dep_id_algorithm # 配置分片算法 sharding-algorithms: id_db_algorithm: type: INLINE props: algorithm-expression: ds$-&gt;{id % 2} user_type_dep_id_algorithm: # 指定类型为复杂行算法 type: COMPLEX_INLINE props: # 依然是使用groovy表达式 algorithm-expression: 'sys_user_$-&gt;{((user_type.isInteger() ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ba06536c4cc3994b7d7e924c0ec9ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5620587e02a47b86a5cef2248f0ec53b/" rel="bookmark">
			SpringBoot集成WebService(wsdl)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom.xml &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-spring-boot-starter-jaxws&lt;/artifactId&gt; &lt;!-- 对版本没要求，建议跟我一样 --&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; 创建入口 ApplicationContextUtils.java bean调用工具
import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.stereotype.Component; /** * 创建日期：2024-07-01 */ @Component public class ApplicationContextUtils implements ApplicationContextAware { //构造函数私有化，防止其它人实例化该对象 private ApplicationContextUtils() { } private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { ApplicationContextUtils.applicationContext = applicationContext; } //通过name获取 Bean.（推荐，因为bean的name是唯一的，出现重名的bean启动会报错。） public static Object getBean(String name) { return applicationContext.getBean(name); } //通过class获取Bean.（确保bean的name不会重复。因为可能会出现在不同包的同名bean导致获取到2个实例） public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) { return applicationContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5620587e02a47b86a5cef2248f0ec53b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/62/">«</a>
	<span class="pagination__item pagination__item--current">63/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/64/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>