<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4cf5c31a6794d949982122db30757f/" rel="bookmark">
			vscode 配置文件settings.json和c_cpp_properties.json的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在 Visual Studio Code (VSCode) 中，settings.json 和 c_cpp_properties.json 都是配置文件，它们分别用于不同的目的。
settings.json settings.json 文件是 VSCode 的用户或工作区设置文件。它允许你自定义 VSCode 的各种行为和外观。
用户设置 (User Settings): 这些设置会应用到你的所有 VSCode 项目和窗口。你可以在左侧的“设置”图标（通常是一个齿轮）中编辑这些设置，然后点击右上角的 ... 图标并选择“在 settings.json 中编辑”来查看或修改 settings.json 文件。工作区设置 (Workspace Settings): 这些设置仅应用于当前打开的工作区。它们通常存储在 .vscode/settings.json 文件中，位于你的工作区根目录下。 settings.json 文件中的设置可以覆盖 VSCode 的默认设置，或者添加新的设置来定制你的开发环境。例如，你可以更改字体大小、主题、自动保存选项等。
c_cpp_properties.json c_cpp_properties.json 文件是 C/C++ 扩展的配置文件，用于指定 C 和 C++ 项目的编译器路径、包含路径、定义和其他编译器选项。这个文件对于 IntelliSense（VSCode 中的代码智能感知功能）特别重要，因为它帮助 IntelliSense 理解你的项目结构和代码。
编译器路径: 指定用于解析代码的编译器路径。包含路径: 指定项目中使用的头文件所在的目录。可以在源文件跳转到包含的位置查看定义定义: 可以定义预处理器宏。编译命令: 可以指定完整的编译命令，以便从构建系统中获取更多信息。 c_cpp_properties.json 文件通常也存储在 .vscode 文件夹中，位于你的工作区根目录下。它允许你为每个工作区或项目配置不同的 C/C++ 设置。
示例：
{ "configurations": [ { "name": "Linux", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe4cf5c31a6794d949982122db30757f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b4ed2ad8cd591433d605c95babbe4b0/" rel="bookmark">
			Spring Cloud 集成 RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言步骤引入相关maven依赖添加相关配置 使用方法配置消息序列化创建第一个消息队列和交换机使用方法 总结 前言 在当今的微服务架构盛行的时代，消息队列作为一种重要的通信机制，在分布式系统中扮演着不可或缺的角色。RabbitMQ，作为一款开源的消息代理和队列服务器，以其高可用性、易扩展性、灵活的路由机制以及多协议支持等特点，深受开发者们的青睐。而Spring Cloud，作为Spring生态中针对微服务架构的一套集成解决方案，也提供了与RabbitMQ的集成支持，使得在Spring Cloud环境下使用RabbitMQ变得更加简单高效。
Spring Cloud集成RabbitMQ，不仅继承了RabbitMQ本身的诸多优点，还充分利用了Spring Cloud的自动配置和声明式编程特性，极大地简化了消息队列的配置和使用过程。开发者可以通过简单的配置和注解，轻松实现消息的发布、订阅、路由和持久化等功能，从而构建出稳定可靠、高性能的分布式系统。
此外，Spring Cloud集成RabbitMQ还提供了丰富的消息处理机制，如消息确认、死信队列、延迟队列等，这些机制可以帮助开发者更好地处理消息丢失、重复消费、消息堆积等问题，提升系统的健壮性和可靠性。
步骤 引入相关maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 添加相关配置 spring: rabbitmq: # RabbitMQ服务器的地址 host: 127.0.0.1 # RabbitMQ服务器的端口号 port: 5672 # RabbitMQ服务器的用户名 username: guest # RabbitMQ服务器的密码 password: guest # 消息监听器的配置 listener: simple: # 确认模式，这里设置为手动，意味着需要手动确认消息处理成功 acknowledge-mode: manual # 消息重试的配置 retry: # 是否启用重试机制 enabled: true # 最大重试次数 max-attempts: 5 # 最大重试间隔，单位是毫秒 max-interval: 20000ms # 初始重试间隔，单位是毫秒 initial-interval: 2000ms # 重试间隔的倍增系数 multiplier: 2 使用方法 配置消息序列化 // 定义一个Bean，返回一个MessageConverter实例，用于消息的序列化和反序列化 @Bean public MessageConverter messageConverter() { // 使用Jackson2JsonMessageConverter作为消息转换器，它基于Jackson库进行JSON格式转换 return new Jackson2JsonMessageConverter(); } // 定义一个Bean，返回一个RabbitTemplate实例，用于发送和接收消息 @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory, MessageConverter messageConverter) { // 创建一个RabbitTemplate实例，传入连接工厂，用于建立与RabbitMQ的连接 RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory); // 设置RabbitTemplate的消息转换器，用于将Java对象转换为消息，以及将消息转换为Java对象 rabbitTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b4ed2ad8cd591433d605c95babbe4b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cacd3e90fff1a6c5f59a18837a1bbec/" rel="bookmark">
			adb 截屏和录屏命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		###　开始录制命令:
adb shell screenrecord /sdcard/demo.mp4
说明:录制手机屏幕,视频格式为mp4,存放到手机sd卡里，默认录制时间为180s
限制录制时间: 参数: --time-limit
adb shell screenrecord --time-limit 10 /sdcard/demo.mp4
说明:限制视频录制时间为10s,如果不限制,默认180s
指定视频分辨率大小： 参数: --size
adb shell screenrecord --size 1280*720 /sdcard/demo.mp4
说明:录制视频，分辨率为1280*720，如果不指定默认使用手机的分辨率,为获得最佳效果，请使用设备上的高级视频编码（AVC）支持的大小
指定视频的比特率
参数: --bit-rate adb shell screenrecord --bit-rate 6000000 /sdcard/demo.mp4
说明:指定视频的比特率为6Mbps,如果不指定,默认为4Mbps. 你可以增加比特率以提高视频质量或为了让文件更小而降低比特率
在命令行显示log 参数: --verbose
adb shell screenrecord --time-limit 10 --verbose /sdcard/demo.mp4
输入以上命令，将可以看到这些信息。
Main display is 1080x1920 @59.16fps (orientation=0)
The max width/height supported by codec is 1920x1088
Configuring recorder for 1088x1920 video/avc at 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cacd3e90fff1a6c5f59a18837a1bbec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ec677d63b655d21f233f1cf45ea00a/" rel="bookmark">
			VSCode配置AI自动补全插件Tabnine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向软件开发人员的 AI 助手
使用 AI 代码完成更快地编写代码 什么是Tabnine Tabnine 是一款 AI 代码助手，可让您成为更好的开发人员。Tabnine 将通过所有最流行的编码语言和 IDE 的实时代码完成、聊天和代码生成来提高您的开发速度。
无论您将其称为 IntelliSense、intelliCode、自动完成、AI 辅助代码完成、AI 驱动的代码完成、AI copilot、AI 代码片段、代码建议、代码预测、代码提示、内容辅助、单元测试生成还是文档生成，使用 Tabnine 都可以极大地影响您的编码速度，从而显着缩短您的编码时间。
AI引擎 / Tabnine 技术 Tabnine 由多种语言专用的机器学习模型提供支持，这些模型从头开始对代码进行预训练。Tabnine 的所有 AI 模型都使用开源代码进行训练，并具有宽松的许可证。Tabnine 的 AI 完成可以在开发人员的笔记本电脑、防火墙后面的服务器或云中运行。
完整的代码隐私 您的代码始终保持私有。
Tabnine 从不存储或共享您的任何代码。出于私有代码模型（企业的一部分）的目的而与 Tabnine 服务器共享代码的任何操作都需要明确选择加入。Tabnine 不会保留任何超出训练模型所需的即时时间范围的用户代码。Tabnine Enterprise 创建的私有代码模型只能由您的团队成员访问。
使用宽松许可证接受开源代码培训 Tabnine 仅将开源代码与宽松的许可证用于我们的公共代码训练的 AI 模型（MIT、MIT-0、Apache-2.0、BSD-2-Clause、BSD-3-Clause、Unlicense、CC0-1.0、CC-BY-3.0、CC-BY-4.0、RSA-MD、0BSD、WTFPL、ISC）。无论您使用的是 Tabnine 的 Pro 计划还是我们的基本计划，您的代码和 AI 数据都不会用于训练私有代码模型以外的任何模型。
了解更多信息
Tabnine Pro - 全线、全功能和自然语言代码补全 一切尽在掌握 - 当您键入时，Tabnine Pro 会提供全行、全功能甚至自然语言来完成代码。您可以接受整行补全，也可以继续键入以获得更多实时替代方案，以不断适应您的代码上下文。
开始免费试用 Tabnine Pro 90 天
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ec677d63b655d21f233f1cf45ea00a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cfe20df26e62a8577b83a8c0e21d3f4/" rel="bookmark">
			JetBrains IDE(IDEA/WebStorm)配置GitHub Copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于 GitHub Copilot 和 JetBrains IDE GitHub Copilot 在编写代码时提供 AI 对程序员的自动完成样式的建议。 有关详细信息，请参阅“关于 GitHub Copilot Individual”。
如果使用 JetBrains IDE，可以直接在编辑器中查看并合并来自 GitHub Copilot 的建议。 本指南演示如何在适用于 macOS、Windows 或 Linux 的 JetBrains IDE 中使用 GitHub Copilot。
先决条件 若要使用 GitHub Copilot，必须拥有有效的 GitHub Copilot 订阅。 有关详细信息，请参阅“关于 GitHub Copilot 的计费”。
若要在 JetBrains 中使用 GitHub Copilot，必须安装兼容的 JetBrains IDE。 GitHub Copilot 与以下 IDE 兼容：
IntelliJ IDEA（旗舰版、社区版、教育版）Android StudioAppCodeCLionCode With Me GuestDataGripDataSpellGoLandJetBrains ClientMPSPhpStormPyCharm（专业版、社区版、教育版）RiderRubyMineRustRoverWebStorm有关详细信息，请参阅 JetBrains IDE 工具查找器。
在 JetBrains IDE 中安装 GitHub Copilot 插件 若要在 JetBrains IDE 中使用 GitHub Copilot，必须先安装 GitHub Copilot 扩展。 以下过程将指导你在 IntelliJ IDEA 中安装 GitHub Copilot 插件。 在另一个受支持的 IDE 中安装插件的步骤可能有所不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cfe20df26e62a8577b83a8c0e21d3f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef677a4256bdfdbbbd077d6179662f4/" rel="bookmark">
			8个国产全能型AI写作神器,给个标题就能自动生成全文 #科技#学习方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今信息爆炸的时代，写作成为了人们表达思想、分享知识和传递情感的重要方式之一。对于很多人来说，写作并非易事。我们会陷入困境，无法找到灵感，我们会苦恼于语言表达的准确性，还有时候我们可能遭遇到了创作瓶颈，随着科技的进步和人工智能技术的发展，AI写作工具成为了我们拓展创意思维和提升写作能力的新伙伴。下面就让我为大家介绍几款本人亲测实用的AI写作工具。以上介绍的几款国内的AI写作软件希望能够帮你提高写作质量，如果对大家有帮助别忘了点个赞哦。
1.元芳写作 这是一个微信公众号
面向专业写作领域的ai写作工具，写作助手包括，ai论文,ai开题报告、ai公文写作、ai商业计划书、文献综述、ai生成、ai文献推荐、AI论文摘要，帮助用户在线快速生成。
写作主打简单、易操作，200+写作模板，小白也能快速上手。只要输入简单的要求和描述，就能自动生成各种高质量文稿内容。
写作功能特色：
多场景写作模板，不限于某个领域， 12+ 种职位的 100+ 工作场景，10秒即可生成一篇专业文章。无论你需要修改简历、撰写公文，还是分享工作心得，我们都能让写作变得轻松无压力。
AI文档续写：策划活动方案卡壳，写小说灵感枯竭。只需上传你的文档，AI 就能帮你续写、修改、扩展和润色。笔灵AI写作轻松解决写作焦虑。
与AI对话：除了AI 改写、 AI续写，AI 一键生成文案，笔灵AI写作还支持 AI 聊天机器人、AI专家对话，全面满足你的 AI 使用需求。
ai写作生成器: 5秒一篇原创文章的AI写作工具。基于AI文章生成器、Al论文生成器、AI作文生成器、AI文案生成器、AI创作生成器、AI创作工具等的ai智能写作生成器
2.豆豆一键去水印工具 一个微信小程序
短视频一键去水印工具，无限次，抖音水印、快手水印、小红书水印等等一键去水印，全网通用，免费一键图集视频去水印222
3.七燕写作 这是一个微信公众号，可以进行AI对话、AI创作、AI绘画、AI训练，内置智能对话机器人、图片设计、AI模型训练、文案生成、方案创作、营销内容创作等数十项AIGC功能，并且包含海量提示词和AI模型库。
面向专业写作领域的ai写作工具，写作助手包括，ai论文,ai开题报告、ai公文写作、ai商业计划书、文献综述、ai生成、ai文献推荐、AI论文摘要，帮助用户在线快速生成。
写作主打简单、易操作，200+写作模板，小白也能快速上手。只要输入简单的要求和描述，就能自动生成各种高质量文稿内容。
写作功能特色：
多场景写作模板，不限于某个领域， 12+ 种职位的 100+ 工作场景，10秒即可生成一篇专业文章。无论你需要修改简历、撰写公文，还是分享工作心得，我们都能让写作变得轻松无压力。
AI文档续写：策划活动方案卡壳，写小说灵感枯竭。只需上传你的文档，AI 就能帮你续写、修改、扩展和润色。笔灵AI写作轻松解决写作焦虑。
与AI对话：除了AI 改写、 AI续写，AI 一键生成文案，笔灵AI写作还支持 AI 聊天机器人、AI专家对话，全面满足你的 AI 使用需求。
七燕写作支持一键智能快速写作，AI生成器一键伪原创，AI智能改写，续写，伪原创工具，原创文案生成器智能写作，智能创作，软文写作，文章生成工作报告等。
4.Unsplash Unsplash是一个高质量免版权图片素材网站,都是真实的摄影照片,照片分辨率也很大,速度快。
Unsplash是一个免费高质量免版权图片素材网站,该平台上面有超过100万张免费高分辨率图片，而且这些图片都具备CC0知识共享许可协议，也就是说所有在Unsplash上发布的照片都可以免费使用，无论是用于商业用途或者非商业用途。 Unsplash 不需要注册就可以直接下载图片，同时在下载的时候还可以根据自己的需求选择相应尺寸的图片。
Unsplash是英文的，如果不会英文，可以通过搜索引擎英译中再COPY进去。
Unsplash作为一个提供免费高分辨率图片的网站，由摄影师们从全世界上传他们的照片，并允许任何人免费使用。这个网站的目标是“赋予摄影师创作和分享的自由”。
Unsplash的图片质量非常高，每张图片都经过严格的筛选和编辑，确保提供给用户的是精美而专业的作品。Unsplash的图片库中包含了各种类型的照片，包括风景、建筑、人物、动物、食物等等。
用户可以通过关键词搜索来找到他们需要的图片，也可以通过浏览照片集合和主题来寻找灵感。此外，用户还可以关注他们喜欢的摄影师，以便及时查看他们的最新作品。
Unsplash也为开发者提供了API，使他们能够在自己的应用、网站或平台上集成Unsplash的图片库。
5.猫耳FM - M站 猫耳FM(M站)是一家广播剧弹幕音图站，同时也是中国声优基地。
猫耳FM(M站) - 让广播剧流行起来，猫耳FM(M站)是一家弹幕音图站，同时也是中国声优基地，在这里可以听电台，音乐,翻唱，小说和广播剧,用二次元声音连接三次元。M站(猫耳FM)目前有电台、有声漫画，娱乐，音乐、配音/广播剧、声优库6个板块。
猫耳FM(M站)由站长“魔王SK”于2010年7月12日创建。猫耳FM(M站)建站的初衷是为用户提供一个音频和图片的分享网站。现拥有有别于大陆其他网站的弹幕系统。
猫耳FM(M站)功能版块：
剧好听 - 你追的小说和漫画在这里都有声音剧，关灯上床躺着慢慢听。纯爱、悬疑、灵异、少女、治愈应有尽有。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef677a4256bdfdbbbd077d6179662f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb68912fe7d32f590e402b2d82b34226/" rel="bookmark">
			【SpringCloud】Nacos 配置管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 一.统一配置管理1. 在 nacos 中添加配置文件2. 从微服务拉取配置 二.配置热更新1. 方式一2. 方式二 三.配置共享1. 添加一个环境共享配置2. 在 user-service 中读取共享配置3. 运行两个 UserApplication，使用不同的 profile4. 配置共享的优先级5. 多服务共享配置 四.搭建 Nacos 集群1. 集群结构图2. 搭建集群2.1. 初始化数据库2.2. 下载 nacos2.3. 配置 Nacos2.4. 启动2.5. nginx 反向代理2.6.优化 Nacos 除了可以做注册中心，同样可以做配置管理来使用。
一.统一配置管理 当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。
Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新
1. 在 nacos 中添加配置文件 如何在 nacos 中管理配置呢？
然后在弹出的表单中，填写配置信息：
注意：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。
2. 从微服务拉取配置 微服务要拉取 nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。
但如果尚未读取 application.yml，又如何得知 nacos 地址呢？
因此 spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在application.yml 之前被读取，流程如下：
引入nacos-config依赖 首先，在user-service服务中，引入 nacos-config 的客户端依赖：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb68912fe7d32f590e402b2d82b34226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9656aa907ccfe74fa6f6ade1c1bf2ca5/" rel="bookmark">
			大数据分层存储架构：ODS、DWD、DWM与DWS详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大数据领域中，ODS、DWD、DWM和DWS代表了数据仓库的不同层次，它们共同构成了大数据的分层存储结构。这种结构的设计有助于提高数据查询效率，降低成本，并满足不同的业务需求。
ODS（Operational Data Store）：操作数据存储层，主要存放原始的业务数据，是数据仓库的源头。它负责收集、存储和管理从各种业务系统中抽取的原始数据，为后续的数据处理和分析提供基础。DWD（Data Warehouse Detail）：数据仓库明细层，位于数据仓库的底层。它主要对ODS层的数据进行清洗、规范化处理，去除空数据、脏数据、离群值等，以提高数据的质量和可用性。DWD层的数据保持了较高的细节粒度，支持数据的跨部门和跨系统共享和查询。DWM（Data Warehouse Middle）：数据中间层，位于DWD层之上。它对DWD层的数据进行轻微的聚合操作，生成一系列中间结果表，提升公共指标的复用性，减少重复加工的工作。DWM层通过对通用核心维度进行聚合操作，计算出相应的统计指标，为上层的数据服务层提供支持。DWS（Data Warehouse Summary）：数据仓库汇总层，位于数据仓库的顶层。它基于DWM层的基础数据，整合汇总成分析某一个主题域的数据服务层，用于提供业务汇总分析服务。DWS层的数据表数量相对较少，每张表涵盖较多的业务内容，字段较多，因此也称为宽表。它主要用于后续的业务查询、OLAP分析、数据分发等场景。 通过这种分层存储结构，大数据系统可以更好地满足不同层次的数据需求，提高数据处理和分析的效率。同时，各层之间的数据流动和交互也变得更加清晰和可控，有助于减少数据冗余和错误，提高数据质量。
需要注意的是，具体的分层结构和命名可能因不同的公司或项目而有所差异，但总体的设计思路和原则是一致的。在实际应用中，可以根据具体的业务需求和技术特点来选择和调整合适的分层存储方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f56205bf960e2220a3b334fa46b8f02/" rel="bookmark">
			【C&#43;&#43;】详解 Unique 函数 （小白一看就懂！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、去重函数 Unique() ✨头文件
✨用法与作用
✨注意点
三、常考面试题
四、共勉
一、前言 经常刷算法题的朋友，肯定会经常看到题目中提到 去重 这样的字眼，或者需要我们通过 去重 来解题，由于之前对 去重 了解的不太清楚，导致做题的时候总会卡住，所以收集了一些资料来详解Unique。
二、去重函数 Unique() ✨头文件 unique函数 是STL 中比较实用的函数之一
包含该函数的函数头文件为 #include &lt;algorithm&gt; ✨用法与作用 函数作用：“去除”容器或数组中相邻元素之间重复出现的元素（所以一般使用前需要排序）。函数参数：第一个参数是集合的起始地址，第二个参数是集合的最后一个元素的下一个元素的地址（其实还有第三个参数，比较函数，但是几乎不用，就不说了，其实和sort函数很像）。 int a[5]={1,4,2,7,2}; sort(a,a+5); unique(a,a+5); 去重后不相同元素的个数：就是函数返回值减去集合的初始位置。 int len=unique(a,a+5)-a;//去重后不相同元素的个数 ✨注意点 a 这里的删除不是真的delete，而是将重复的元素放到容器末尾c 一定要先对数组进行排序才可以使用unique函数b unique函数的返回值是去重之后的尾地址 int main() { int myints[] = { 10,20,20,20,30,30,20,20,10 }; vector&lt;int&gt; myvector(myints, myints + 9); cout &lt;&lt; "去重前" &lt;&lt; endl; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; myvector[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f56205bf960e2220a3b334fa46b8f02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431c70dc2a1133d54a06ab1a834a046c/" rel="bookmark">
			YOLOv5实战记录06 Gradio搭建Web GUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人打卡，慎看。
指路大佬：【手把手带你实战YOLOv5-入门篇】YOLOv5 Gradio搭建Web GUI_哔哩哔哩_bilibili
先放一张效果图：
零、虚拟环境激活 之前up说要激活环境时，我没当回事儿，今天突然想，激活环境然后安装包，和不激活环境安装包，有什么区别。conda activate yolov5，原来这个yolov5就是D:\anaconda\envs 下的文件夹所承载的环境。我尝试了这个文件夹下其他的名字。比如有个文件夹叫VIKI， conda activate VIKI，果然也激活了VIKI，我之前一直以为因为项目是关于yolov5的，所以这个参数才是Yolov5，原来这个就是一开始给环境的命名。激活环境后，不管当前目录是什么，安装包都会安装到那个位置。我尝试了import site print(site.getsitepackages()) ，在两种情况下，激活Yolov5环境时，输出了D:\anaconda\envs\yolov5，d:\anaconda\envs\yolov5\lib\site-packages ； 激活VIKI环境时，输出了D:\anaconda\envs\VIKI ，D:\anaconda\envs\VIKI\lib\site-packages所以如果激活了yolov5环境，那么下载的包会下载到d:\anaconda\envs\yolov5\lib\site-packages 这个位置。而我设置的python.exe是d:\anaconda\python.exe, 如果不激活环境，包会下载到d:\anaconda\lib\site-packages，又遇到了一个问题，既然anaconda\lib\site-packages里已经有很多包了，之后在这儿pip install不就行了吗，为什么还要新建一个虚拟环境。 主要解决的就是不同工程代码要求的包，版本可能不同。 可见，我对虚拟环境的概念还是不熟悉。于是学习了虚拟环境相关的知识。
conda虚拟环境 conda env list #列出conda所有的环境 conda activate mingzi #激活环境mingzi pip list #看该环境下的包 #每个环境的包都可以定制，这主要解决了不同工程对应包版本不同的问题。 conda create -n hahaha python=3.8 #创建一个叫做hahaha的环境,指定python版本为3.8 conda env remove -n hahaha --all # 删除叫做hahaha的环境。 如何更换环境？
打开settings，找到python interpreter ，点击add interpreter，点击add local interpreter；点击conda environment， 选择using existing environment, 选择yolov5 一、配置环境 pip install gradio 运行model=torch.hub.load("./","custom",path="runs/train/exp2/weights/best.pt",source="local")这句代码又遇到了问题。卡在了Downloading scipy-1.10.1-cp38-cp38-win_amd64.whl (42.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431c70dc2a1133d54a06ab1a834a046c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2910a591dd170ec7074e812695e08e99/" rel="bookmark">
			Python轴承故障诊断 (一)短时傅里叶变换STFT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1 短时傅里叶变换STFT原理介绍
1.1 傅里叶变换的本质
1.2 STFT概述
1.3 STFT的原理和过程
1.3.1 时间分割
1.3.2 傅里叶变换
1.3.3 时频图：
1.4 公式表示
2 基于Python的STFT实现与参数对比
2.1 代码示例
2.2 参数选择和对比
2.2.1 nperseg（窗口长度）：
2.2.2 noverlap（重叠长度）：
2.2.3 选择策略：
2.3 凯斯西储大学轴承数据的加载
2.4 STFT与参数选择
2.4.1 基于重叠比例为0.5，选择内圈数据比较 STFT 的不同尺度：16、32 、64、128
2.4.1 根据正常数据和三种故障数据，对比不同尺度的辨识度
3 基于时频图像的轴承故障诊断分类
3.1 生成时频图像数据集
3.2 定义数据加载器和VGG网络模型
3.3 设置参数，训练模型
往期精彩内容： Python-凯斯西储大学（CWRU）轴承数据解读与分类处理
Python轴承故障诊断 (一)短时傅里叶变换STFT
Python轴承故障诊断 (二)连续小波变换CWT_pyts 小波变换 故障-CSDN博客
Python轴承故障诊断 (三)经验模态分解EMD_轴承诊断 pytorch-CSDN博客
Pytorch-LSTM轴承故障一维信号分类(一)_cwru数据集pytorch训练-CSDN博客
Pytorch-CNN轴承故障一维信号分类(二)-CSDN博客
Pytorch-Transformer轴承故障一维信号分类(三)-CSDN博客
Python轴承故障诊断 (四)基于EMD-CNN的故障分类-CSDN博客
Python轴承故障诊断 (五)基于EMD-LSTM的故障分类-CSDN博客
Python轴承故障诊断 (六)基于EMD-Transformer的故障分类-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2910a591dd170ec7074e812695e08e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f14646ede3806390f2ba8baca5083fb/" rel="bookmark">
			在线视频教育平台|基于Springboot的在线视频教育平台系统设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线视频教育平台目录
基于Springboot的在线视频教育平台系统设计与实现
一、前言
二、系统设计
三、系统功能设计 1、前台：
2、后台
用户功能模块
教师功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于Springboot的在线视频教育平台系统设计与实现 一、前言 线视频教育平台，它彻底改变了过去传统的管理方式，不仅使服务管理难度变低了，还提升了管理的灵活性。这种个性化的平台特别注重交互协调与管理的相互配合，激发了管理人员的创造性与主动性，对在线视频教育平台而言非常有利。
本系统采用的数据库是Mysql，使用SpringBoot框架开发，运行环境使用Tomcat服务器，ECLIPSE 是本系统的开发平台。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
关键字：在线视频教育平台 Mysql数据库 SpringBoot框架
二、系统设计 系统功能结构如图
三、系统功能设计 1、前台： 在前台首页，在首页可以查看首页、课程信息、个人中心、后台管理、购物车等内容，如图5-15所示。
图5-15前台首页功能界面图
用户登录，在登录页面通过填写账号、密码、角色等信息完成登录，如图5-16所示。
图5-16用户登录界面图
在课程信息页面通过填写课程编号、课程名称、课程类型、关键字、课时、课程详情、教师工号、教师姓名、点击次数等信息进行添加到购物车、立即购买或点我收藏等操作，如图5-17所示。在购物车页面通过填写购买商品、价格、数量、总价等信息进行点击购买或删除等操作，如图5-18所示。
图5-17课程信息界面图
图5-18购物车界面图
2、后台 用户功能模块 用户点击进入到系统操作界面，可以对首页、个人中心、课程信息管理、我的收藏管理、订单管理等功能模块，个人信息：通过列表可以获取账号、密码、姓名、性别、手机、邮箱、照片、备注并进行修改操作，如图5-1所示。
图5-1个人信息界面图
课程信息管理：通过列表可以获取课程编号、课程名称、课程类型、关键字、课时、课程详情、封面、教师工号、教师姓名、价格、审核回复、审核状态等信息进行详情或查看评论操作，如图5-2所示。
图5-2课程信息管理界面图
我的收藏管理：通过列表可以获取收藏名称、收藏图片等信息，进行详情、修改及删除操作，如图5-3所示。
图5-3我的收藏管理界面图
订单管理：通过列表可以获取订单管理；订单编号、商品名称、商品图片、购买数量、价格/积分、折扣价格、总价格/总积分、折扣总价格、支付类型、状态、地址等信息，进行详情、修改、删除等操作，如图5-4所示。
图5-4订单管理界面图
教师功能模块 教师点击进入到系统操作界面，可以对首页、个人中心、课程信息管理、我的收藏管理等功能模块，课程信息管理页面通过列表可以获取课程编号、课程名称、课程类型、关键字、课时、课程详情、封面、教师工号、教师姓名、价格、审核回复、审核状态并进行详情、修改、查看评论或删除等操作，如图5-13所示。
图5-13课程信息管理界面图
我的收藏管理：通过列表可以获取删除名称、收藏图片等信息，进行详情、修改、删除操作，如图5-14所示。
图5-14我的收藏管理界面图
四、数据库设计 (1) 用户管理实体属性图如下所示：
(2) 教师管理实体属性图如下所示：
数据库表的设计，如下表：
表4-1：token表
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
userid
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f14646ede3806390f2ba8baca5083fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc18eaab6b1c4f74d5328f236618c582/" rel="bookmark">
			java.net.ConnectException: Connection refused: connect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个异常通常表示客户端尝试连接到服务器，但服务器拒绝了连接请求。主要原因可能包括：
服务器未运行或未启动服务： 如果您正在尝试连接到的服务器未运行或未启动相关的服务，就会导致连接被拒绝。 防火墙问题： 防火墙设置可能会阻止对特定端口的连接。您需要确保服务器上所需的端口未被防火墙屏蔽。sudo ufw status 错误的主机或端口： 确保您尝试连接的主机名或 IP 地址以及端口号是正确的。 要查看 Ubuntu 服务器上正在运行的端口，您可以使用一些命令来列出当前打开的网络连接或正在监听的端口。以下是几种常用的方法： netstat 命令：使用 netstat 命令可以列出当前系统上所有的网络连接、路由表信息以及网络接口统计信息。您可以使用以下命令来列出所有正在监听的端口： bashCopy code
sudo netstat -tuln 这将显示所有正在监听的 TCP (-t) 和 UDP (-u) 端口，以及端口号、协议和监听地址。
ss 命令： ss 是 netstat 的替代工具，更加强大和高效。您可以使用以下命令来列出所有正在监听的端口：
bashCopy code
sudo ss -tuln 这与上面的 netstat 命令类似，会列出所有正在监听的 TCP (-t) 和 UDP (-u) 端口。
lsof 命令： lsof 命令可以列出打开的文件和网络连接。您可以使用以下命令来查看哪些进程在监听哪些端口：
bashCopy code
sudo lsof -i -P -n 这将显示所有打开的网络连接，包括进程的 PID、监听地址和端口号。
并发连接限制： 某些服务器可能限制了同时处理的连接数，当达到限制时会拒绝新的连接请求。 检查服务器上特定端口是否正确打开并监听连接，您可以使用以下方法： 使用 telnet： telnet 是一种常用的网络调试工具，可以用来测试网络连接。您可以使用以下命令来尝试连接到服务器的特定端口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc18eaab6b1c4f74d5328f236618c582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b810b07f54bbd0ba35816b0d7c23d007/" rel="bookmark">
			DFS：记忆化搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​​ 一、记忆化搜索vs动态规划 . - 力扣（LeetCode）
class Solution { public: //记忆化搜索 //1、设置一个备忘录，要确保备忘录初始化的结果不能跟我们实际计算的结果相同 //2、添加备忘录，计算的时候，如果备忘录的位置是初始值，进行修改 //3、每次计算的时候，去备忘录瞅一瞅，找到的话，就可以不算了 int memory[31]; int fib(int n) { memset(memory,-1,sizeof(memory));//利用memset进行初始化成-1 return dfs(n); } int dfs(int n) { //递归进入前，去备忘录瞅瞅 if(memory[n]!=-1) return memory[n]; if(n==0||n==1) { memory[n]=n; return memory[n]; } else { memory[n]=dfs(n-1)+dfs(n-2); return memory[n]; } } }; 二、不同路径 class Solution { public: int uniquePaths(int m, int n) { //记忆化搜索 vector&lt;vector&lt;int&gt;&gt; memo(m+1,vector&lt;int&gt;(n+1,-1));//建立一个记忆数组 return dfs(m,n,memo);//dfs去帮我搜索 } int dfs(int i,int j,vector&lt;vector&lt;int&gt;&gt;&amp;memo) { if(memo[i][j]!=-1) return memo[i][j]; if(i==0||j==0) return 0; if(i==1&amp;&amp;j==1) return 1; memo[i][j]=dfs(i-1,j,memo)+dfs(i,j-1,memo); return memo[i][j]; } }; 三、最长的递增子序列 class Solution { public: //记忆化搜索 //不用记忆化搜索的话会超时，因为本身就是一个多叉树 int lengthOfLIS(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; memo(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b810b07f54bbd0ba35816b0d7c23d007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84844ac09011403824a628549ea756a/" rel="bookmark">
			【利器篇】前端40&#43;精选VSCode插件，总有几个你未拥有！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 姊妹篇：
【利器篇】35+精选chrome插件，含15+前端插件，总有一款值得你停留
关于关于 【前端工具系列】：
有句话，事半功倍，其必然是借助了某些思想和工具。
VSCode是我们前端开发的武器，本文40+精选插件，让其更加锋利，无坚不摧！！
多谢掘友在评论区的反馈，补充两款非常棒的插件
Tabnine AI 代码完成插Trailing Spaces 尾部空格删除插件 另外两款也不错，但是不太推荐
rong-notes 添加注释，下载量比较小，最后维护日期是2019年1月，就不推荐了。ClassTree 根据jsx，dom结构快速生成 jsx/vue class结构。还是比较有创意的，下载量太小。 必备的 下面这些必备的我就不说了
代码段 JavaScript (ES6) code snippets， ES7 React/Redux/GraphQL/React-Native snippetsvue, vetur, Vue 3 Snippets， Vue VSCode Snippets
代码段这玩意，你也可自定义，可以参见 VSCode创建自定义代码段 代码检查和格式化 ESLint, Prettier - Code formatter, Beautify 其他 open in browser 由于VSCode自身功能的增强，NPM-Scripts, Change Case等的插件就不需要特意安装了。
接下来更精彩！！！， 全程高能动图，请别分神！
实用高效工具 scode-js-debug debug利器 新版VSCode内置。
可用于调试Node.js、 Chrome、 Edge、 WebView2、 VS Code 扩展等等，替换 Debugger for Chrome 插件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a84844ac09011403824a628549ea756a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26dd60b3e4d325babc1e28250102cbe2/" rel="bookmark">
			大数据-kafka学习笔记_error while fetching metadata with correlation id
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由多个kafka消费者组成的一组消费者组，用于同时消费处理kafka中一个主题所有分区中的数据。只要在创建kafka消费者的时候将group id设置成一样的，那么就可以创建多个消费者构成消费者组了。
一个主题的一个分区只能由一个消费者组内的一个消费者处理，否则会导致数据重复消费。一个消费者组的每个消费者负责消费不同分区的数据。
消费者组的好处：加快消费处理数据的速度，横向提高整个消费能力。如下图，一开始就一个消费者c1，他要自己一个人消费处理来自topicA主题的四个分区的数据，而我们可以增加三个消费者c2、c3、c4和c1构成一个消费者组来同时消费处理topicA主题的四个分区的数据，这样消费处理数据的速度就提升了。（前提是有多个分区）
主题 上面那样肯定不好，各种消息的的生产者（生产圆蛋蛋、生产方框框、生产小心心）将消息都发给kafka，然后kafka将消息都分类，每种分类都有相应的主题，然后消费者根据需要订阅相应的主题。就能收到对应的消息。
分区 如果一个主题的消息比较多，就可以考虑分区，分区可以分布在不同的服务器上，所以主题也可以分布在不同的服务器上，这样比单服务器处理快。
如果生成者没有指定分区，分区器就会根据每条消息的键算出消息该去哪个分区。键：就是每条消息的一个标记，决定了消息该去哪个分区。分区器：就是一个算法，算消息该去哪个分区，输入是键，输出是消息去的分区。
偏移量 偏移量就是消息在每个分区中的位置，kafka在收到消息的时候，会为每个消息设置偏移量，然后将消息存到磁盘中。
消费者只能按顺序消费读取。消费者如果要分区0的第四个，kafka就会说第三个还没读取，不给第四个。
kafka集群 一个broker就是一个kafka服务器。下面有两个broker构成了kafka集群，他们的数据通过复制同步，当有一个kafka宕机了，另一台就可以先顶上，保证了kafka的可靠性。
监控kafka 这个前提得先安装jdk
1、修改kafka的启动脚本
vim bin/kafka-server-start.sh
if [ “x$KAFKA_HEAP_OPTS” = “x” ]; then
export KAFKA_HEAP_OPTS=“-Xmx1G -Xms1G”
fi
改为
if [ “x$KAFKA_HEAP_OPTS” = “x” ]; then
export KAFKA_HEAP_OPTS=“-server -Xms2G -Xmx2G
-XX:PermSize=128m -XX:+UseG1GC -XX:MaxGCPauseMillis=200
-XX:ParallelGCThreads=8 -XX:ConcGCThreads=5
-XX:InitiatingHeapOccupancyPercent=70”
export JMX_PORT=“9999”
#export KAFKA_HEAP_OPTS=“-Xmx1G -Xms1G”
fi
修改kafka进程信息：
-Xms2G：设置 Kafka 进程的初始堆内存大小为 2 GB。
-Xmx2G：设置 Kafka 进程的最大堆内存大小为 2 GB。
XX:PermSize=128m：设置持久代（PermGen）的初始大小为 128 MB。请注意，这个选项在 Java 8 和更新的版本中不再适用，因为 PermGen 已被 Metaspace 取代。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26dd60b3e4d325babc1e28250102cbe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5efd960fb2357385990413e737539450/" rel="bookmark">
			Unity 接入HybridCLR的点点滴滴，亲测三平台（PC、Android、WebGL）妥妥的。-问题分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一入热更深似海啊，没有热更是真恼火啊，干啥啥不方便，动不动就得重新发包；说实在的，也是工作之余研究这个，在原有框架基础上接入这个热更，既要保持原有功能，还要支持热更，实实在在、断断续续搞了这么久，终于是接入并测通了，这一路是坎坎坷坷，下面把走过的弯弯绕绕记录下，希望对后来想接入的小伙伴有帮助吧。
其实之前早就有动热更新的心，无奈现在没做游戏了，项目这块基本都是定制开发，所以这块一直搁置，不过之前有考虑过lua和xlua也看过ILRuntime，但是一直耿耿于怀，要用另外一种语言去搞，而且咱又是一直干C#的，而且这几个实现机制都是需要一个独立的vm，编译完在解释一套，而且有的还不能直接使用，需要特殊处理，看着看着就没心思搞了；这时看到了HybridCLR，说实话，一开始看到的是huatuo，这俩其实到后来了解到是一个东西，看了几天，发现这个的实现机制从根本上解决了独立vm的问题，具体的HybridCLR官网说的更清楚，使用了AOT + Interpreter混合运行方式，HybridCLR使得il2cpp变成一个全功能的runtime，原生（即通过System.Reflection.Assembly.Load）支持动态加载dll，这个就是亮点，在实现热更的路上，它占了绝对的分量。
看到这里的，默认你已经在接入HybridCLR的路上了，而且已经接入，遇到问题了，如果是还没接入的，可以查看Unity 热更新 之 huatuo（HybridCLR) 和 Unity 热更新 HybridCLR 对接到项目中 了解和接入。
这里使用的Unity版本是 2021.3.6f1 ， HybridCLR是 v2.3.0 ， il2cpp_plus版本是v2021-2.2.0一切准备就绪后，开始坎坷之路吧，Lz这里主要测试的平台有PC、Android、WebGL，感觉最明显的就是WebGL限制是真多，所以在这里爬坑也是绞尽脑汁了。
所有常见的问题HybridCLR常见错误（这里是链接，可以跳过去看）里其实也都有，只是有的指出了方向，但具体怎么解决人家也没细细说明，必经错误千奇百怪，遇到了至少人家有个指引方向，剩下的就得靠自己慢慢爬了。
别的不多说了，进入主题。
问题：项目已经进入热更新，可以使用，但是想进一步使用热更新，热更项目中原有的dll。 正常接入后，打包出来没问题，然后有要求，比如项目之前就有已经引用的dll或则框架要求，把已经统一的功能封装出去，最终形成dll在项目中引用使用，不管什么原因，你想实现已经引用的外部dll的热更新。
在HybridCLR中，是有这块的功能的，
这里需要配置外部搜索dll路径和需要热更dll的名称，注意：这里的设置一定是同时设置，这样热更新才能找到需要热更的dll在哪里，而且外部搜索dll路径是以Assets为父级（根目录）去找的，这里Lz直接放在了项目内，如果你放在项目外，就要填写项目外地址了。
确定配置完成后，真正的问题就从此开始了。
1.报错：Building Library/Bee/artifacts/xxxx failed with output: Fatalerror in Unitiy CIL Linker Mono.Cecil.AssemblyResolutionException: Failed to resolve assembly:'xxx'
这里Lz经历完爬坑后，总结先说下，他这里的配置，是将你选择的dll，在发布时，做了过滤，也就是不会打包到包中（AOT），也就意味着，你的AOT代码中，如果有对他们的引用，将会报错（Building Library/Bee/artifacts/xxxx failed with output: Fatalerror in Unitiy CIL Linker Mono.Cecil.AssemblyResolutionException: Failed to resolve assembly:'xxx'），或者你的AOT中没有引用，但是你外部热更的dll中有引用，同样会报这个错，根本原因是，热更（HybridCLR）把你要外部热更的dll过滤掉了（相当于删除），所以在打包时找不到引用，你说能不报错吗？这里爬坑了好久，希望对你有帮助，一定要冷静分析你要热更的dll中有没有其他地方在引用（如果是AOT那就必须分离掉那块功能，如果是外部dll，要么一起加入热更，要么把那块功能分离掉）。这个错误部分平台，都适用。
2.报错：WebGL平台打包时遇到 undefine symbol: send file 之类的错误
这个就纯属WebGL平台限制问题，一般主要是本地读取的一些问题，比如File操作，这里LZ建议都是用加载（UntyWebRequest）的方式（那个平台都适用，不会有问题），只是在这要注意的是，不同平台在使用网络加载的时候，要加入平台前缀，不然会加载失败 提示错误：Cannotconnect to destination host等（比如Android要加jar:file:// PC要加file://）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5efd960fb2357385990413e737539450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bd47983d1121608794367d8f34bee5/" rel="bookmark">
			小程序自建平台开发票保存到微信卡包（java篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 获取 Access token
2获取自身的开票平台识别码
3 获取授权页ticket
3.5 获取链接前需要先 设置商户联系方式
4 获取授权页链接
5 小程序打开授权页
6 收取授权完成事件推送
7 查询授权完成状态
8 创建发票卡券模板
9 上传PDF
10 将电子发票卡券插入用户卡包
1 获取 Access token 这里的appid 和 secret 是公众号的 不要写小程序的哦
https请求方式: GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET
参数说明
参数是否必须说明grant_type是获取access_token填写client_credentialappid是第三方用户唯一凭证secret是第三方用户唯一凭证密钥，即appsecret 这个获取代码我就不写了哈 应该都知道
2获取自身的开票平台识别码 这个地方代码我也不写 上面获取到的 Access token传入进来就行了 自己用postman调用一下 拿到invoice_url中的s_pappid存起来就行了
请求URL：https://api.weixin.qq.com/card/invoice/seturl?access_token={access_token}
请求方法：POST
请求参数
请求参数使用JSON格式，传入空值{}
返回结果
返回结果为JSON格式，字段如下：
参数类型是否必填描述errcodestring是错误码errmsgstring是错误信息invoice_urlstring否该开票平台专用的授权链接。开票平台须将 invoice_url 内的 s_pappid 给到服务的商户，商户在请求授权链接时会向微信传入该参数，标识所使用的开票平台是哪家 这个获取到账号请截取下来 只需要获取一次 保存到配置文件即可
3 获取授权页ticket ticket 的有效期，一般为 7200 秒
这个我也不写了 还是把上面获取的ACCESS_TOKEN传入 就能拿到ticket 记得写成一个方法 请求方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5bd47983d1121608794367d8f34bee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a889f24213a25607ee2c6706e76ed76/" rel="bookmark">
			Java 的几种文件拷贝方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、使用传统的FileInputStream和FileOutputStream实现文件的拷贝二、利用 java.nio 包下的库，使用 transferTo 或 transfFrom 方法实现三、使用Java 标准类库本身已经提供了 Files.copy 一、使用传统的FileInputStream和FileOutputStream实现文件的拷贝 使用传统的FileInputStream和FileOutputStream实现文件拷贝是Java I/O流操作中最基本的方法之一。这种方式使用字节流直接读取源文件内容，并写入目标文件，适用于文本文件和二进制文件
import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileCopyWithStreams { public static void main(String[] args) { String sourceFile = "source.txt"; // 源文件路径 String destinationFile = "destination.txt"; // 目标文件路径 FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(sourceFile); fos = new FileOutputStream(destinationFile); byte[] buffer = new byte[1024]; // 创建缓冲区 int length; while ((length = fis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a889f24213a25607ee2c6706e76ed76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6332b86da2119a3397931309be49251d/" rel="bookmark">
			如何将Unity WebGL项目上传至自己的云服务器上（图文详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在Unity上完成的小游戏项目成功导出了.exe文件，但同时又想把它以别的形式再进行导出，虽然Unity官方提供了专门的服务器来给用户上传他们的WebGL项目，但个人感觉那总有点寄人篱下，于是想自己租一个云服务器用来上传自己的项目。
上传的流程主要分三部分：
目录
1.Unity导出WebGL项目
2.云服务器的设置
3.将WebGL项目上传至云服务器
1.Unity导出WebGL项目 首先我们需要把Unity项目导出为WebGL。打开项目，点击File-&gt;Build Settings进入如下窗口，从左侧找到WebGL，如果它像如下一样是灰色的，右侧显示No WebGL module loaded。那说明你还没有下载相关的模块，需要点击Install with Unity Hub下载我们需要的模块。
下载时选中以下模块，点击安装等待下载完成。
下载完成后返回Unity，可以发现WebGL选项已经点亮，点击Switch Platform，等待Unity把项目转换成WebGL
转换完成后别着急点击Build导出Unity项目，我们要先进入Player Settings，这里还有些需要设置的地方，否则默认导出的项目上传至服务器后可能会出现无法运行的情况。
这里的的Compression Format要改成Gzip或者Disabled，指的是要把你的Unity项目进行何种方式的压缩。
这里可以修改导出网页的展示形式，按自己的需要修改就好，我一般选的都是Default默认。
设置完后就可以点击Build把我们的Unity项目导出成WebGL形式了。
完成后便可以在导出目录里得到以下文件夹与文件
至此，我们的WebGL项目已经准备完毕了，但是现在index.html是无法正常打开的，因为我们还没有给它配置相应的服务器，接下来我们要去设置自己的云服务器。
2.云服务器的设置 我这里选择的是阿里云作为我的云服务器，使用其它服务器的基本流程是相同的，但是具体的操作方法会有所不同。如果是学生党的话，租用服务器是会有各种各样的优惠的，可以自己去找找最实惠的一款，这里就不赘述服务器的购买过程了。
以下是我的服务器配置信息，我使用操作系统是CentOS7.6 64位。
在云服务器ECS界面，点击"远程连接"-&gt;"通过Workbench远程连接"进入我们的服务器界面
如果是第一次进入的话要设置用户名和密码，自己设置就好，之后便可进入我们的云服务器界面，在此界面里输入yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec 下载宝塔面板。
这里的宝塔面板是一个可视化的免费服务器运维面板，虽然一些功能还是要收费，但是其免费的功能就已经足够现在我们使用了。
输入指令后等待下载完成，其中有需要输入的地方就输入y，下载完成后，可以在命令行中输入bt检查下载是否成功。如若成功下载，便会显示以下提示
在这里我们输入14，查看面板的默认信息，他就会把当前的面板默认地址，用户名和密码如图显示出来
把这里的外网地址复制访问一下，我们就能进入自己云服务器的宝塔面板了，默认的用户名和密码是默认信息里的username和password,如果想修改的话在命令行中输入bt 5可以修改密码，bt 6可以修改用户名。现在我们由外网面板地址访问到我们的宝塔面板，登录后进入如下界面。
如果是第一次进入的话，会有弹窗要你安装一些基础的插件，选择推荐安装就可以了。接下来我们回到阿里云，进入安全组添加我们需要授权的端口。
在安全组中点击"创建安全组"进入创建页面，"网络"和"资源组"这两栏选择你当前的服务器，访问规则这里它会帮你配置好一些常见的端口，比如80、443、3389等。这里我们自己再手动添加一个端口范围是8868的端口，授权对象为0.0.0.0/0（对所有人开放），作为我们访问WebGL项目的端口。
至此，我们在云服务器上的准备就全部完成了，最后我们要把已经打包好的WebGL项目上传到我们的云服务器上。
3.将WebGL项目上传至云服务器 返回到宝塔面板中，点击"网站"-&gt;"PHP项目"-&gt;"添加站点"，会出现以下窗口
这里的域名我们直接把我们服务器的公网IP粘贴进去，其它的默认，选择提交就好
公网IP的位置
添加完成后我们就会发现已经成功的添加了一个网站到我们的服务器了，但是这时候网站的内容还是空白的，而且是用默认的端口访问的，所以我们需要把我们刚刚开放的端口添加进去，并把我们的WebGL项目部署过来。
点击我们新创建的网站名，在弹出的窗口内填上公网IP地址加上我们新开放的端口号。两者用":"隔开
再点击添加，就会发现域名管理这里多了一条新添加的数据，这就是我们刚才加上的可访问的端口号。
接着进入左侧的"文件"界面，点击"上传"，然后把我们当初打包好的WebGL项目中的两个文件夹，一个html文件全部放到一个新建文件夹里，再全部拖进来进行上传。我这里新建文件夹的名字叫"JumpingFrogWeb"
文件上传界面
上传后的文件
现在我们的WebGL项目已经成功上传到我们的服务器上了，最后我们要把它部署到刚部署的端口上。重新进入"网站"，打开我们刚部署的端口，点击"网站目录"，把这里的目录改为我们刚刚上传的WebGL项目的目录，便大功告成了。
修改目录
现在，我们再访问自己服务器的"公网IP:端口"，就可以成功访问我们在Unity上导出的WebGL项目了！
以上，我们已经成功的将Unity WebGL项目上传至自己的云服务器上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6332b86da2119a3397931309be49251d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/432/">«</a>
	<span class="pagination__item pagination__item--current">433/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/434/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>