<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd6553549ba38d6060d5f87dd27b2b3/" rel="bookmark">
			数据结构：为什么说链表是顺序表的升级版（c语言实现单向不带头单链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.链表
1.1 链表的概念及结构
1.2 链表的分类
1.3 单链表的实现
1.3.2 链表实现 （1）申请一个节点 （2）尾插 （3）头插 （4）查找
（5）指定位置之前插入 （6）指定位置之后插入
（7）尾删 （8）头删 （9）指定位置删除 （10）指定位置之后删除 (11)打印链表数据 （12）销毁链表
（13）测试
前言： 我们在之前的几篇文章中详细的讲解了顺序表的特点，增删改查操作和动态顺序表的优点，并使用顺序表的底层结构实现了通讯录项目，似乎顺序表是一个非常完美的数据结构，它可以实现按照需求实现增删查改，对内存的控制也较为合理，空间都是在需要时手动开辟的。但是顺序表真的完美吗？事实上它并不完美，经过我们思考，顺序表还是存在一些问题，例如：（1）顺序表中间/头部的插入删除，时间复杂度为O(N) （ 2） 增容需要申请新空间，拷贝数据，释放旧空间。会有不小的消耗。 （3）增容一般是呈2倍的增长，势必会有一定的空间浪费。例如当前容量为100，满了以后增容到200，我们 再继续插入了5个数据，后面没有数据插入了，那么就浪费了95个数据空间。这些问题都是我们应该考虑的，而我们接下来要介绍的另一种数据结构——链表，就能在实现属性表的各个功能的前提下很好的解决这些问题。
1.链表 1.1 链表的概念及结构 链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。换句话说，链表就是一块一块的空间由指针像链子一样将它们链接起来了，方便我们去访问链表的每一个节点。
它的结构像极了图中的小火车：
我们来看看真实链表的结构 ：
链表是由一个指针指向链表的头节点，每个节点分为两个部分，分别是数据部分和指针部分，数据部分负责存储我们要存储的数据，指针部分负责存储下一个节点的地址，链表的每一个节点都储存着下一个节点的地址，最后一个节点的指针存储的是空指针，这使我们能够很方便的访问整个链表。
链表的特点：
1.从图中可以看出，链表的的结构在逻辑上是连续的，但是在物理上不一定连续。
2.每一个节点一般都是从堆上申请的。
3.从堆上申请的空间，是按照一定的策略分配的，两次申请的空间可能连续，可能不连续
1.2 链表的分类 链表的实际分类种类多达八种：
链表分为单向和双向链表，带头和不带头链表，循环或者非循环链表，虽然由有这么多种链表，但是我们实际使用时最常用的只有两种：分别是无头单向非循环链表和带头双向循环链表。
1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。
1.3 单链表的实现 我们这一期用c语言代码来实现单链表。与顺序表相同，我们将实现链表的文件分成三个，分别是头文件SList.h文件,SLIst.c方法实现文件和测试文件test.c文件：
1.3.2 链表实现 链表由数据和指针两部分组成（前面已经详细解释），由于我们不确定会存储哪种类型的数据，使用typedef来作为我们的数据类型，要更数据类型时只需要更改typedef重命名的数据类型就可以：
1、无头+单向+非循环链表增删查改实现 typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SLTNode; 在这里我们使用的是int类型，最后将链表的名字改为SLTNode。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd6553549ba38d6060d5f87dd27b2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc417b261c6b6455f014062deb9c10a5/" rel="bookmark">
			快速上手 Spring Boot：基础使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速上手 Spring Boot：基础使用详解 文章目录 快速上手 Spring Boot：基础使用详解1、什么是SpringBoot2、Springboot快速入门搭建3、SpringBoot起步依赖4、SpringBoot自动配置：以tomcat启动为例5、SpringBoot基础配置6、yaml7、多环境开发配置 1、什么是SpringBoot Spring Boot 是一个基于 Spring 的框架，旨在简化 Spring 应用的配置和开发过程，通过自动配置和约定大于配置的原则，使开发者能够快速搭建独立、生产级别的应用程序。Spring程序缺点 配置繁琐依赖设置繁琐 SpringBoot程序优点 自动配置起步依赖（简化依赖配置）版本锁定内置tomcat服务器辅助功能（内置服务器，……） 2、Springboot快速入门搭建 新建项目选择Spring Initializr
因为官网网速会很慢，这边Server URL可以修改成国内阿里云地址：https://start.aliyun.com
在下一步之后，可以选择Springboot版本并添加Spring web依赖，最后点击完成就可以了
找到springboot启动类，点击运行测试
在日志中，我们可以看到java的版本，tomcat版本和端口，我们并没有配置tomcat，这也说明了Springboot是内置了tomcat的
可以写个代码进行测试一下,之后访问localhost:8080/user
@RestController @RequestMapping("/user") public class UserController { @GetMapping() public String getUser(){ return "hello springboot"; } } 3、SpringBoot起步依赖 starter SpringBoot中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-01-quickstart&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; &lt;project xmlns="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc417b261c6b6455f014062deb9c10a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c62a1025f0cfedf4e507c96b2abe26d/" rel="bookmark">
			华为eNSP模拟器下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、依赖程序
VirtualBox：https://cloud.rsecc.cn/softlink/VirtualBox-5.2.26-128414-Win.exe
WinPcap：https://cloud.rsecc.cn/softlink/WinPcap_4_1_3.exe
Wireshark：https://cloud.rsecc.cn/softlink/Wireshark-win64-3.0.6.exe
需要先安装依赖程序再安装eNSP才能安装成功
二、eNSP模拟器下载地址
eNSP:https://cloud.rsecc.cn/softlink/Wireshark-win64-3.0.6.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be8128177b15eaf6ee812947e6d940a9/" rel="bookmark">
			Windows 中 Chrome / Edge / Firefox 浏览器书签文件默认存储路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Chrome 浏览器 按组合键 Win + R，打开运行对话框，输入
%USERPROFILE%\AppData\Local\Google\Chrome\User Data\Default 或在Chrome 浏览器地址栏输入
chrome://version 查看【个人资料路径】
2. Edge 浏览器 按组合键 Win + R，打开运行对话框，输入
%USERPROFILE%\AppData\Local\Microsoft\Edge\User Data\Default 或在 Edge 浏览器地址栏输入
edge://version 查看【用户配置路径】
3. Firefox 浏览器 按组合键 Win + R，打开运行对话框，输入
%USERPROFILE%\AppData\Local\Mozilla\Firefox\Profiles 或在 Firefox 浏览器地址栏输入
about:support 从【配置文件夹】栏【打开文件夹】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f11dc8d9f85ad430cffe74b5323e647/" rel="bookmark">
			python篇-pywinauto使用-持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1- pywinauto 中的uia是什么意思？ 在pywinauto库中，uia指的是UI Automation，这是Windows操作系统提供的一种技术框架，用于实现用户界面(UI)的自动化测试和辅助功能访问。UI Automation是微软从Windows Vista开始引入的核心技术，旨在为所有UI元素提供一致的编程接口，无论这些元素是由何种技术（如Win32、WPF、UWP等）实现的。
在pywinauto中，通过指定backend="uia"，用户可以选择使用UI Automation作为底层引擎来与应用程序的UI元素进行交互。这为自动化测试提供了更广泛的支持，尤其是在处理现代Windows应用（尤其是使用WPF和UWP技术构建的应用）时更为有效。UI Automation后端相比传统的win32后端，提供了更丰富和高级的元素属性、控制模式（Control Patterns）以及事件支持，使得自动化脚本可以更加灵活和强大。
使用UI Automation后端，开发者可以更容易地定位和操作UI元素，如获取元素的属性、模拟鼠标和键盘操作、监听UI事件等，这对于创建复杂的自动化测试场景尤其有用。
2-pywinauto 中main_window.child_window()方法及参数详细介绍 在pywinauto中，child_window()方法是用于定位父窗口中的一个特定子窗口或控件。这对于自动化测试中准确地找到并操作特定的UI元素至关重要。下面是对child_window()方法及其参数的详细说明：
基本用法 child_window()方法属于窗口对象，用于在当前窗口的所有子窗口中搜索符合指定条件的第一个子窗口。基本语法如下：
Python
1parent_window.child_window(arguments) 其中，parent_window是你已经获取到的窗口对象，arguments是用于筛选子窗口的一系列关键字参数。
参数详解 child_window()方法接受多个关键字参数来精确地定位子窗口，常见的参数包括但不限于：
title: 字符串，控件的标题或文本。class_name: 字符串，控件的类名。control_type: 字符串，控件的类型（仅在UIA backend下有效）。auto_id: 字符串，控件的自动化ID（AutomationId）。name: 字符串，控件的名称属性，可能与标题或自动化ID不同。backend: 字符串，指定后端类型，如 'win32' 或 'uia'，默认自动选择。process: 整数，指定目标窗口所在的进程ID。enabled: 布尔值，是否只查找启用的控件。visible: 布尔值，是否只查找可见的控件。top_level_only: 布尔值，是否只在顶级窗口中查找。found_index: 整数，当找到多个匹配项时，可以选择特定索引的匹配项。control_id: 整数，控件的ID（Windows API中的控件ID）。handle: 整数或ctypes.c_void_p，直接指定控件的句柄。regex_title: 正则表达式对象或字符串，用于匹配标题的正则表达式。regex_class_name: 同上，但用于匹配类名的正则表达式。best_match: 字符串，用于best_match()逻辑，尝试匹配最接近的控件。 示例 假设你想在记事本应用的主窗口中找到名为“文件”（File）的菜单项，可以这样做：
Python
from pywinauto import Application app = Application(backend="uia").start("notepad.exe") main_window = app.window(title="无标题 - 记事本") # 使用class_name和title定位子窗口 menu_item = main_window.child_window(class_name="MenuItem", title="文件") 注意事项 参数组合：通常，为了精确匹配，你需要结合多个参数一起使用。比如，同时使用class_name和title可以更准确地定位目标控件。性能考量：如果条件设置得过于宽泛，可能会导致搜索缓慢或找到错误的控件。尽量使用具体的属性来缩小搜索范围。异常处理：如果找不到匹配的子窗口，child_window()会抛出异常。可以使用try-except结构来妥善处理这种情况。 通过灵活运用child_window()方法及其参数，你可以高效地定位并操作UI自动化中的各种元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f11dc8d9f85ad430cffe74b5323e647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb79a775e5d5f58d49de4a1abd0367c/" rel="bookmark">
			【C&#43;&#43;】继承（定义、菱形继承、虚拟继承）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
继承的概念
继承定义
定义格式
继承关系和访问限定符 继承基类成员访问方式的变化 基类和派生类对象赋值转换
继承中的作用域
派生类的默认成员函数
继承与友元 继承与静态成员 复杂的菱形继承及菱形虚拟继承 虚拟继承解决数据冗余和二义性的原理 继承的总结和反思
继承和组合 前言 💬 hello! 各位铁子们大家好哇。
今日更新了继承的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
继承的概念 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用。
继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。 继承定义 定义格式 Person是父类，也称作基类。Student是子类，也称作派生类。
继承关系和访问限定符 继承基类成员访问方式的变化 记忆方法：基类的私有成员，无论哪种方式继承，在派生类中都是不可见。基类其他成员在子类的访问方式，取基类成员的访问限定符和继承方式中小的一个。
在继承中，一般用公有和保护，少用私有。
总结： 基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私 有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面 都不能去访问它。基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在 派生类中能访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他 成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过 最好显示的写出继承方式。 在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承，也不提倡使用protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。 基类和派生类对象赋值转换 派生类对象可以赋值给基类对象。
注意：必须是公有继承才可以，保护和私有都不行。 public继承是is -a的关系，即每个子类对象都是一个特殊的父类对象。
派生类对象可以赋值给 基类的对象 / 基类的指针 / 基类的引用。这里有个形象的说法叫切片 或者切割。寓意把派生类中父类那部分切来赋值过去。 基类对象不能赋值给派生类对象。基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类 的指针是指向派生类对象时才是安全的。 切片有赋值兼容，在赋值的时候不会产生临时对象，就不需要加const。如下图，此时ref是直接指向派生类中基类的那一部分。
继承中的作用域 在继承体系中基类和派生类都有独立的作用域。子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏， 也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显示访问）需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。注意在实际中在继承体系里面最好不要定义同名的成员。 默认访问子类的，想要访问父类前面就得加上父类的类域。 B中的fun和A中的fun不是构成重载，因为不是在同一作用域 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb79a775e5d5f58d49de4a1abd0367c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba73c3b406f4ef21dad49bf5c7034229/" rel="bookmark">
			alibaba easyexcel 导出excel使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 传统导出，一般都是通过Workbook &gt; Sheet &gt; Row &gt; Cell 获取详细Cell 设置值，比较麻烦，偶然遇到alibaba easyexcel 直接通过注解设置哪些需要导出 哪些忽略，发现特别好用。
pom依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; 完整pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.demo&lt;/groupId&gt; &lt;artifactId&gt;tool-box-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;tool-box-export&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.demo&lt;/groupId&gt; &lt;artifactId&gt;tool-box-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;!-- 使用适合您项目的最新稳定版本 --&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 通常设置为provided，因为Servlet容器（如Tomcat）提供了实现 --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; Sheet1DataVo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba73c3b406f4ef21dad49bf5c7034229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f07e75b442f92a3a9b25c415e1069c61/" rel="bookmark">
			C# Web控件与数据感应之数据返写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于数据返写
准备视图
范例运行环境
ControlInducingFieldName 方法
设计与实现
如何根据 ID 查找控件
FindControlEx 方法
调用示例 小结
关于数据返写 数据感应也即数据捆绑，是一种动态的，Web控件与数据源之间的交互，数据返写 ，是指将查询出来的数据，通过可显示数据的UI控件进行数据输出，如查询详情页，见下图：
如图其中放置了一些标签（Label）控件用于查询输出，比如单位名称、项目名称、被测评人、总得分、手机号或账户等信息。
本文将介绍如何中通过 C# 实现查询并返写数据到服务器UI控件上。
准备视图 我们在 MS SQL Server 创建视图 v_es_project_persons（考试人员详情视图），其结构如下表：
序号字段名类型说明1ciduniqueidentifier项目唯一标识2wxmpciduniqueidentifier人员唯一标识3ProjectNamenvarchar项目名称4pubstatenvarchar项目发布状态5personsint项目允许考试人数上限6namenvarchar姓名7mobilenvarchar手机8scorenumeric考试成绩 执行定位项目及人员的查询SQL语句，如下：
​ select wxmpcid,ProjectName,pubstate,persons,name,mobile,score from v_es_project_persons where cid='960105b0-42b6-413a-a87a-f5fa338b2f2c' and wxmpcid='21f4c424-a1df-4161-be1b-ce441e058be6' 最后我们将数据填充到 DataReader ,并生成对应的二维数组。
范例运行环境 操作系统： Windows Server 2019 DataCenter
数据库：Microsoft SQL Server 2016
.net版本： .netFramework4.0 或以上
开发工具：VS2019 C#
ControlInducingFieldName 方法 设计与实现 ControlInducingFieldName 方法主要是通过 object[,] 二维对象数组数据源进行提取并根据字段名与控件ID进行匹配，查找匹配成功则根据控件的数据呈现属性进行赋值，其参数设置见下表：
序号参数名类型说明1HasTitlebool数据集是否包含列名，如果包含则数据输出从第2行开始2VerticalQueryModebool垂直字典查询模式，数据集第1列为要查找的ID值，第2列为要输出的值 GetReaderData 方法可以访问数据库数据表进行查询结果的提取，并转化为 object[,] 二维数组，具体实现请参考我的文章：《C# Web控件与数据感应之 填充 HtmlTable》中的GetReaderData 方法实现代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f07e75b442f92a3a9b25c415e1069c61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399d6f11420096487e20657eeebf2c11/" rel="bookmark">
			AI工具——Hedra：上传音频&#43;照片，一键创作口型匹配视频～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近，AI 圈刮起一股「让照片开口唱歌」的风潮。例如，让霉霉唱碧昂丝《Halo》的 Hallo、斯坦福创业团队的 Proteus、以及之前阿里出品的 EMO。
现在又有一家名为 Hedra 的公司前来踢馆，推出了基础模型 ——Character-1 。今天就带大家一起来了解一下这款工具。
# 工具介绍 Hedra 是一个专注于利用先进的AI技术将基础模型转化为创意产品的实验室，其核心产品Character-1支持根据任意人物照片和语音内容生成具有表现力和可控性的人类角色视频。这个工具允许用户上传照片和语音，实现人物说话或唱歌的效果,同时保持唇形、表情和姿态与语音内容相匹配。
# 功能优势 · 上传人物照片：你可以上传任意人物的照片，Hedra的AI技术能够识别并处理这些图像；
· 添加语音内容：你可以上传任何语音文件，系统将语音与人物照片结合，实现人物说话或唱歌的效果；
· 生成生动的视频：通过Character-1工具，你可以将静态照片和音频文件转化为生动的动画视频，生成表现丰富的人类角色。
· 无限时长生成：目前开放预览版支持30秒的视频生成，如果H100供应充足，每60秒可生成90秒的内容。
· 支持多种表达形式：Character-1不仅支持对话，还能处理歌唱和说唱等表达形式。
# 如何使用？ 官方地址：https://top.aibase.com/tool/hedra
用谷歌账号授权登录，点击Try beta按钮，即可进入体验，用户只需上传一张图片，再生成一段音频，就能让它开口说话或唱歌。
为了生成效果最佳，提示词中尽量包括风格、角色特征、相机视角、背景场景以及光线效果等内容，最后点击「Generate video」，稍等片刻即可生成一段视频。
Hedra还在试用beta版本阶段，目前免费提供给用户体验，感兴趣的小伙伴们快去试试吧～
*西安觉醒元宇宙AI，是专注线上AI培训、AI绘画辅导、AI开发服务的专业教育平台！
▍扫描下方二维码进入AI交流学习群，获取超多AI前沿知识！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7d475fa14275d342ac50019945baf4/" rel="bookmark">
			深入解析FTP：原理、架构与搭建方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今互联网世界中，文件传输是日常工作和生活中不可或缺的一部分。FTP（File Transfer Protocol，文件传输协议）作为一种老而弥坚的协议，一直在文件传输领域发挥着重要作用。本文将从技术人的角度，详细分析FTP的原理、架构、搭建方式以及常见的操作方式。
一、FTP的原理
FTP是用于在网络上进行文件传输的一套标准协议，它工作在OSI模型的第七层，TCP模型的第四层，即应用层。FTP使用TCP传输而不是UDP，客户和服务器建立连接前要经过一个“三次握手”的过程，保证客户与服务器之间的连接是可靠的，而且是面向连接的，为数据传输提供可靠保证。
FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而，用户并不真正登录到自己想要存取的计算机上面而成为完全用户，可用FTP程序访问远程资源，实现用户往返传输文件、目录管理以及访问电子邮件等等，即使双方计算机可能配有不同的操作系统和文件存储方式。
FTP的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。它能操作任何类型的文件而不需要进一步处理，就像MIME或Unicode一样。但是，FTP有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长。
二、FTP的架构
FTP是基于客户-服务器（C/S）模型而设计的，在客户端与FTP服务器之间建立两个连接。开发任何基于FTP的客户端软件都必须遵循FTP的工作原理，FTP的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条TCP连接，一条是数据连接，用于数据传送；另一条是控制连接，用于传送控制信息（命令和响应），这种将命令和数据分开传送的思想大大提高了FTP的效率，而其它客户服务器应用程序一般只有一条TCP连接。
FTP主要由三部分组成：FTP服务器、FTP客户端以及FTP协议。其中，FTP服务器是用来存储文件的，用户可以使用FTP客户端通过FTP协议与服务器进行文件传输。FTP协议包括两个组成部分：一个是FTP服务器，另一个是FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。
三、FTP服务器的搭建方式
搭建FTP服务器，首先需要选择合适的操作系统，如Windows或Linux。接下来，需要安装FTP服务器软件，如FileZilla Server或vsftpd。安装完成后，进行服务器的基本配置，包括设置端口号、用户权限和文件目录等。同时，需要确保防火墙允许FTP流量通过，设置防火墙规则以开放FTP服务器的端口。如果在局域网内，还需要在路由器上进行端口转发的设置。最后，启动FTP服务器并进行连接测试，确保一切设置都能正常运作。
在CentOS7.6上搭建FTP服务器，我们通常选择vsftpd作为服务器软件。以下是详细的搭建步骤：
1. 关闭防火墙和SELinux
为了避免搭建过程中可能出现的网络问题，首先暂时关闭防火墙。可以使用以下命令： systemctl stop firewalld.service systemctl disable firewalld.service 同时，为了确保FTP服务的正常运行，建议将SELinux设置为disabled。编辑/etc/selinux/config文件，将SELINUX=enforcing改为SELINUX=disabled。修改后需要重启系统。 注意：在FTP服务器搭建成功后，应重新配置防火墙以允许FTP流量通过。
2. 安装vsftpd
使用yum包管理器安装vsftpd： yum install -y vsftpd 3. 启动vsftpd服务
安装完成后，启动vsftpd服务，并设置为开机自启： systemctl start vsftpd.service systemctl enable vsftpd.service 4. 配置vsftpd
vsftpd的主要配置文件位于/etc/vsftpd/vsftpd.conf。使用文本编辑器（如vi）打开此文件进行配置： vi /etc/vsftpd/vsftpd.conf 根据需要修改配置选项。例如，为了安全起见，你可能想要关闭匿名访问（anonymous_enable=NO），允许本地用户登录（local_enable=YES），并允许用户进行写操作（write_enable=YES）。 5. 创建FTP用户并设置权限
创建一个新的系统用户，该用户将用作FTP登录： adduser ftpuser passwd ftpuser 根据需要，你可以配置用户的主目录、访问权限等。例如，你可以通过修改/etc/vsftpd/vsftpd.conf中的相关设置来限制用户只能访问其主目录。 6. 重新启动vsftpd服务
在对配置文件进行更改后，需要重新启动vsftpd服务以使更改生效： systemctl restart vsftpd.service 7. 测试FTP服务器
使用FTP客户端软件（如FileZilla、WinSCP等）连接到你的FTP服务器进行测试。确保你能够成功登录，并且能够上传、下载和管理文件。 8. 配置防火墙以允许FTP流量（可选）
如果你在搭建成功后重新启用了防火墙，你需要配置防火墙以允许FTP流量通过。这通常涉及到开放FTP服务的标准端口（21）以及被动模式所需的端口范围（如6000-6010）。你可以使用firewall-cmd命令来配置这些规则。 以上就是在CentOS7.6上搭建FTP服务器的详细步骤。请注意，根据你的具体需求和网络环境，你可能需要对这些步骤进行适当的调整。
四、FTP的常见操作方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7d475fa14275d342ac50019945baf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620c71790f6fd991748ed199891b99cc/" rel="bookmark">
			AI绘画Stable Diffussion 实操教程： 真人图片秒变动漫风，亲手绘制你的专属动漫头像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是向阳
你是否曾幻想过自己置身于动漫世界，拥有那些令人羡慕的二次元特征？随着人工智能技术的飞速发展，这一幻想已不再遥不可及。在本文中，我们将一起揭开Stable Diffusion技术的神秘面纱，探索如何利用这一技术将你的真实照片转换成充满魅力的动漫形象。我们将一步步引导你完成这个充满创意的过程。让我们一起开启这场视觉与想象的奇幻之旅吧！
前期准备 本文会使用到Tagger插件反推图片的提示词，如果还没有安装的可以使用如下方式进行安装：
点击 扩展 -&gt; 点击 从网址安装 -&gt;扩展的 GitHub仓库网址框输https://github.com/picobyte/stable-diffusion-webui-wd14-tagger -&gt; 点击 安装，安装完成后重启stable diffusion。
注意：该方法需要科学上网，如无法下载，请扫描获取插件安装包文件
风格转换步骤 1、反推提示词
点击Tag反推标签 -&gt; 上传图片-&gt; 点击 开始反推-&gt;点击 图生图 发送提示词
2、选择大模型/修改提示词
大模型选择：动漫风格的模型，这里使用Anything的模型
提示词：删除反推提示词中和真实风格相关关键词，比如realistic
3、修改图生图参数
设置完上图所示的参数后，我们直接点击图片生成看下效果。对于重绘幅度我们通过设置X/Y/Z脚本来看不同重绘幅度下生成的效果。
从图中可以看到，随着重绘幅度的增加，图片人物姿势与原图差异越来越大，所以我们新增ControlNet的OpenPose来控制人物姿势。
4、使用ControlNet的open pose预处理器和模型
主要设置如下图所示，设置完成后，我们再次生成图片。
图片效果如下所示：
从图中可以看到，随着重绘幅度的增加，图片人物姿势与原图基本一致。但是图片的整体质量感觉还不是特别清晰，所以我们再使用一个ControlNet的Tile（分块控制）来增加图片的整体细节。
5、使用ControlNet的tile预处理器和模型
主要设置如下图所示，设置完成后，我们再次生成图片。
图片效果如下所示，整体效果看起来是可以接受的了。
最后看下转换效果对比：
到这里真人转换动漫风格基本处理完了，如果在处理过程中对于脸部细节有要求，可以使用Adetailer面部修复插件进行处理。当然，如果在具体操作过程中有任何问题可以随时沟通讨论。
感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528f122187569b2bb69013b2dbee42da/" rel="bookmark">
			大数据智能风控：模型、平台与业务实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人行印发的《金融科技（FinTech）发展规划（2022一2025年）》明确指出金融科技成为防范化解金融风险的利器，运用大数据、人工智能等技术建立金融风控模型，有效甄别高风险交易，智能感知异常交易，实现风险早识别、早预警、早处置，提升金融风险技防能力，金融科技在风险控制上已经成为重要基石。
作为经营风险的金融机构，风险管理已成商业银行的核心竞争力，其能否适应数字化转型趋势，将决定银行数字化转型的成败，所以商业银行更应高度关注大数据智能风控体系的建设，充分发挥数据和技术等生产要素价值，全面推进数字化风控体系建设，以高质量风控助力高质量发展，这样才能保证数字银行模式下经营和发展成果的真正落地及实现。
金融科技的发展加速推动银行业进入风控3.0时代。商业银行充分借助先进信息技术，建立基于人工智能和数据挖掘的风险管理模型，推动智能风控体系的构建。这种智能风控体系让金融科技、风险管理和业务经营有效地融合在一起，并在实践中不断完善和优化，实现全程智能风险管控，在风险可控的基础上，全力推动业务发展，为银行高质量发展提供更为强劲的动能。
原文链接（经机械工业出版社授权转载）：
01 什么是大数据智能风控 商业银行作为金融中介机构，经营的本质是对风险的运营和管理。金融科技的高速发展和国家政策的扶持，驱动商业银行向数字化、信息化、智能化的更高阶段发展。在此背景下，商业银行更应抓住数字化转型机遇，建立覆盖风险识别、计量、分析、处置全流程的智能风控体系，全面提升银行风险防控能力。
传统的风控体系中定性风险管理占主体，以主观规则及客户评级为主，存在数据获取维度窄、定量分析能力偏弱、难以精确化用户特征等缺点。在数字化转型的背景下，传统的风险管控模式在风险管控时效性、模型有效性、监控范围等多个方面的短板日益凸显。
大数据智能风控利用不断完善的机器学习、自然语言处理、知识图谱等技术，结合持续提升的算法、数据、硬件处理能力，为解决风险领域的痛点问题提供了很好的契机。大数据智能风控利用多维数据，填补传统风控模式的缺口，从更全面的角度进行客户画像和风险评估，对客户的特征和行为进行全景分析展现，深入地理解、认识、分析和判断客户。
构建量化的、合理的、科学的风险评估模型和风控系统，建立覆盖全流程、全业务、全客户的风险管控措施，实现对反欺诈、授信、贷中监测和贷后管理的全方位一体化的智能防护体系，为各个渠道高风险交易提供实时的预警支持，将事后风险防控更好地推送到事前事中风险防控。
大数据智能风控利用数据、变量、模型、系统提高风险防控能力，已成为商业银行塑造互联网金融时代核心竞争力的重要举措。
02 数据：大数据智能风控的基石 大数据智能风控背后的力量就是大数据的技术和风险分析能力，对风控所提供数据的广度、深度、鲜活度都有较高的要求。然而数据虽然重要，但并不是所有的数据都有价值，只有经过治理、整合后的高质量数据才是大数据智能风控的基石。
大部分商业银行因为各种历史原因，导致数据不全、质量不高、应用不足等一系列问题持续存在，从而使风险数据利用效率不高，对风控决策支持造成制约。因此，建立完善的数据治理体系、数据标准和数据整合是风控平台建设的关键，如同城市建设修建下水道，数据治理是一项长期的、需要非常细致的脏活累活。因此需高度重视数据规范化管理，不仅要有采集海量数据的能力，更要有提炼整合各上下游系统数据统一存储能力，实现业务数据向数据资产的转化。
传统银行的数据使用常常局限在某个系统的业务流程中，却忽视与其他业务系统的关联数据，缺乏对大数据的深度理解。
相比之下，大数据智能风控能够存储海量数据并连通全域数据，建立统一规范的数据标准和质量体系，建设提纯加工后的标准数据资产体系，以满足银行对不同业务的数据需求。在对数据规范化处理后，大数据智能风控对数据进行资产化、服务化，提供数据服务，为业务赋能。
特别是对风险策略规则进行变量准备，创建用户画像体系、关系图谱，在线分析信贷业务跨系统数据查询能力，并为多部门任务协作等任务奠定数据基础，提供强大的分析工具和智能的数据可视化系统，为商业银行信贷各业务和各类分析提供支持和帮助。如见图1所示。
（图1 大数据智能风控的数据支持和服务）
03 特征变量：大数据智能风控的上限 风控领域常说的，“特征变量决定了模型的上限，而大数据智能风控只是逼近这个上限”。强大的特征工程能够显著提升风控的有效性，帮助风控更精准地识别欺诈行为、信用违约等风险事件。
风控特征变量体系的核心在于强化金融机构对风险的即时识别与高效应对能力，这一过程深入结合了多元化数据来源，通过精密的批流数据抽取机制、综合聚合技术以及深度衍生数据加工流程，构建出一个标准化、高度可拓展的特征变量统一平台。
该平台不仅确保了从原始数据摄取到特征生成、再到模型训练及最终决策实施的全链路畅通无阻，而且显著加快了风险事件的响应速率，同时提升了决策的精确性与灵敏度。如图2所示。
（图2 特征变量在智能风控中的定位）
在实时风控技术系架构中，特征变量计算包括了批计算、流计算及图计算。以流计算能力为例，相关技术栈提供了底层面向实时特征计算的能力，主要用于数据ETL、宽表加工、窗口计算等场景，通过预计算、状态聚合计算等能力实现原始特征变量、标准特征变量、衍生特征变量的加工，为决策模型提供特征支持。
模型引擎主要负责存储和管理经训练的各类模型，如信用评分模型、欺诈检测模型、流失预警模型等。决策引擎集中管理规则集、决策树、决策矩阵、评分卡等策略模型，规则集调用特征变量服务及模型引擎的模型服务参与决策流的逻辑运算。
特征变量引擎基于异构数据源，进行数据抽取、加工计算、标准化管理维护，实现风控人员自助查询，更加便捷、规范地进行业务取数和数据分析。具体见图3所述。
（图3 特征变量输出示意图）
04 模型：大数据智能风控的关键 风控的本质在于精准辨识、评估、监控各类潜在风险并采取有效应对措施，这要求我们具备高度敏感的风险雷达，及时发现任何可能撼动资金安全的隐患。大数据驱动的智能风控体系构建于一套精密的风险模型架构之上，该架构通过对数据的深度剖析实现风险的量化评估，揭示风险的本质及潜在影响。简言之，风控模型是将庞杂数据经由数学逻辑转化成未来趋势预测的桥梁，其中心逻辑围绕用户还款行为预测展开，实质上是对用户按时还款可能性的二元判断。
评分卡模型在此基础上更进一步，通过精密计算每位用户的个人信息，输出一个代表还款概率的数值。这一数值直接映射用户的信用等级——概率愈高，信用评分愈佳，意味着用户按时还款的可能性大增；反之，则预示着较高的违约风险及更低的信用评分。模型的核心价值，在于为策略规划提供科学依据，助力决策者精准施策。
实践操作中，智能风控模型深入挖掘用户数据，为每位用户绘制风险肖像，通过风险评分划分出如A、B、C、D等多个风险层级。根据不同层级特征，采取差异化策略：A级用户，凭借优良的信用背景，可享受更高信贷额度与优惠利率，成为我们服务的优先对象；相反，D级用户面临更为严格的条件，包括限制信贷额度与提高利率，以平衡风险敞口。
通过整合先进的模型体系至自动化信贷审批流程，借助大数据的广泛性、多元性和即时性优势，我们运用逻辑回归、支持向量机、自适应增强学习、决策树等多种算法（参见图4），全方位覆盖风险监测。
这些模型不仅融入设备指纹识别、复杂关系网络分析、图像与语音智能识别等前沿技术，还广泛应用于个人信贷的多样场景，深化信息挖掘与分析，形成闭环管理机制：从防御、识别、追踪、分析，到持续优化与实战反馈，确保信贷流程的每一步都配备风控的“智慧盔甲”，有效抵御欺诈行为，提前预警风险。
（图4 风控模型算法支持）
05 平台：大数据智能风控的支撑 风控模型怎么建，除了取决于模型团队对业务的理解、变量的挖掘、模型的开发，更重要的是风控平台的支撑。
风控平台作为风控平台的技术载体，是商业银行数字化转型的关键。传统建模工具通常缺乏对机器学习算法的直接支持，并且需要大量的人工编码。
这对于大部分银行建模人员来说，使用门槛比较高，导致以往商业银行使用传统建模工具建模时常常面临效率较低、模型迭代周期较长、操作烦琐、模型部署的位置不灵活等痛点，严重影响了模型效力的发挥。
大数据智能风控对平台的建设方向是基于灵活工作流引擎和决策规则引擎的信贷审批系统，可以将模型快速、灵活部署到运行环境，以便银行建模人员实现智能风控模型的便捷开发，智能风控系统架构可以支撑风控模型及时迭代优化，快速部署运行，保证模型的时效性，快速适应客群风险特征的变化，发挥智能风控的作用。具体如图5所示。
（图5 风控平台功能架构图）
06 大数据智能风控的内核 大数据智能风控如同一枚先进的火箭，驱使商业银行在风险管理领域实现腾跃。其中，风控数据如同燃料舱，为整个体系注入基础能量，覆盖广泛信息以供深入挖掘。
风控变量则好比引擎的火箭中枢，将海量数据转化为具体的风险评估指标，引导决策方向。风控模型作为火箭头，运用先进算法处理变量，精准预测风险，驱动高效决策制定。
而风控系统则是综合的火箭助推器，整合数据处理、模型应用及策略执行，确保贷前、贷中、贷后及反欺诈等各环节协调运作，形成从数据到决策的闭环管理。如图6所示。
（图6 大数据智能风控内核展示 ）
在大数据智能风控的框架下，数据扮演着基石角色，其质量和多样性直接关乎分析变量的有效性，而变量则构成了模型精准度的基石，界定着风险管理效能的理论边界。
模型作为这一系统的心脏，驱动着商业银行在复杂多变的风险环境中实现精准识别、精密评估与动态监控，进而采取针对性的防范策略。与此同时，高效稳定的平台架构是实施这一切的载体，确保风控策略与模型能够迅速响应市场变化，灵活适应客户群体风险特征的演化，维持智能风控机制的灵敏度与实用性。
四位一体——数据、变量、模型、平台，共同织就了大数据智能风控的内在核心，为信贷业务的全周期管理，即从贷前审查的严谨性、贷中监控的即时性、贷后管理的有效性，到反欺诈机制的前瞻性，提供了全方位、深层次的保障。
这一综合体系不仅是风险控制的坚固防线，也是信贷业务健康发展的助推器，确保在风险可控的前提下，促进金融资源的合理配置与服务效率的持续提升。如图7所示。
（图7：风控内核-四位一体）
07 《大数据智能风控：模型、平台与业务实践》 这是一本深入讲解智能风控理论体系和风控全生命周期业务实践的著作。作者基于在银行业10余年的风控经验，首先详细讲解了“大数据、模型、风控平台”三位一体的智能风控体系，能为风控实践提供扎实的理论指导；然后围绕风控的全生命周期，从贷前评估、贷中监控、贷后管理以及智能反欺诈、智能催收等角度全面讲解了智能风控的业务实践，深刻揭示了智能风控体系的精髓。
第1~2章全面而深入地探讨了智能风控的背景知识：首先对基础信贷业务进行了细致解析，读者可以从中了解其运作方式和重要性；然后，梳理了智能风控是如何随着技术的进步和市场的需求逐渐成熟和完善的。
第3~5章围绕“数据、模型、风控平台”三位一体的智能风控理论体系展开：首先介绍了内部数据、外部数据、个人征信数据在智能风控中的应用，以及智能数据体系的构建；然后深入探讨了智能风控模型的算法、评价指标、开发流程；最后讲解了风控平台的理论框架、设计原则、架构设计、建设流程以及决策引擎的建设。
第6~8章围绕风控的全生命周期探讨了风控策略在实际业务中的应用，包括贷前评估、贷中监控、贷后管理，以及智能反欺诈和智能催收体系的建设和业务实践，能帮助读者将理论知识转化为实际操作能力，更好地应对现实业务中的挑战。
第9章对智能风控的未来发展进行了展望，不仅为读者揭示了未来的机遇，也提供了对于如何应对未来挑战的思考。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528f122187569b2bb69013b2dbee42da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8029d4078b946d5d89cb90cf01af93/" rel="bookmark">
			C语言---数据结构（1）--时间复杂和空间复杂度计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是时间复杂度和空间复杂度 1.1算法效率 算法效率分为时间效率和空间效率
时间效率被称为时间复杂度，而空间效率被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度，现在主要关注的是空间效率
1.2时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运
行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机
器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻
烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比
例，算法中的基本操作的执行次数，为算法的时间复杂度。
1.3 空间复杂度的概念 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。空间复杂度不是程序占用
了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计
算规则基本跟实践复杂度类似，也使用大O渐进表示法。
2.如何计算常见算法的时间复杂度和空间复杂度 时间复杂度不算时间，算次数，空间复杂度不算空间，算变量个数
时间复杂度的计算 实际中我们在计算时间复杂度时，我们其实并不一定要计算精确的执行次数，只需要大概执行次数，那么我们这里就使用大O的渐进表示法
大O符号：是用于描述函数渐进行为的数学符号
推导大O阶方法：
1、用常数1取代运行时间中的所有加法常数。
2、在修改后的运行次数函数中，只保留最高阶项。
3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。
使用大O的渐进表示法以后，
另外有些算法的时间复杂度存在最好、平均和最坏情况：
最坏情况：任意输入规模的最大运行次数(上界)
平均情况：任意输入规模的期望运行次数
最好情况：任意输入规模的最小运行次数(下界)
例如：在一个长度为N数组中搜索一个数据x
最好情况：1次找到
最坏情况：N次找到
平均情况：N/2次找到
在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)
比如后面的计算strchr的时间复杂度
// 请计算一下Func1基本操作执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N; ++i) { for (int j = 0; j &lt; N; ++j) { ++count; } } //对于这个循环来说，因为这是一个嵌套的循环，两层循环，外面执行N次，里面执行N次 //所以这个循环总共执行N*N次 for (int k = 0; k &lt; 2 * N; ++k) { ++count; } //这个循环的循环次数是2*N int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a8029d4078b946d5d89cb90cf01af93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78974448ffd5eff50a1142d238ba4797/" rel="bookmark">
			揭秘未来艺术：AI绘画工具全面介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📑前言 随着科技的飞速发展，人工智能（AI）已经逐渐渗透到我们生活的方方面面。在艺术创作领域，AI技术同样展现出了其独特的魅力。今天，我们就来一起探索这个神秘而引人入胜的领域，深入了解AI绘画工具的奥秘及其为艺术创作带来的革命性变革。
一、AI绘画工具的崛起 1.1 颠覆传统绘画模式 在过去，绘画是艺术家们通过手中的画笔，蘸取颜料，在画布上自由挥洒的创造性过程。然而，随着AI绘画工具的出现，这一传统模式被彻底颠覆。AI绘画工具以强大的计算能力和深度学习能力为基础，能够自动生成具有艺术感的图像，极大地提高了绘画的效率和创作丰富性。
1.2 融合科技与艺术 AI绘画工具是科技与艺术完美融合的产物，它们不仅具备传统绘画工具的功能，如调整画笔大小、颜色、透明度等，还能通过先进的算法自动优化画面，显著提升作品的艺术效果。更为神奇的是，这些工具能根据用户的需求，自动生成符合特定风格或主题的图像，极大地拓展了艺术家的创作手段和可能性。
二、AI绘画工具的种类与特点 2.1 深度学习生成艺术 深度学习生成艺术是AI绘画工具中最具创新性的一类。这类工具通过训练海量的图像数据，学会了如何模仿人类艺术家的创作风格。以GAN（生成对抗网络）为代表的技术能够生成具有高度真实感和艺术感的图像，令人难以分辨其创作者是机器还是人类。这种技术的出现，不仅丰富了艺术创作手段，还为艺术家们提供了全新的创作视角和灵感来源。
2.2 风格迁移工具 风格迁移工具是另一种备受欢迎的AI绘画神器。它们能够将一幅图像的风格迅速迁移到另一幅图像上，从而创造出独具匠心的艺术作品。这类工具通常运用神经网络模型，如卷积神经网络（CNN），来实现风格的高效迁移。用户只需简单地上传两幅图像，便能轻松实现风格的融合与创新。这种工具极大地拓展了艺术家的创作空间，使得艺术风格的探索与创新变得触手可及。
2.3 智能草图生成器 智能草图生成器是专为设计师和艺术家量身打造的一款AI绘画利器。它能够根据用户的简短描述或关键词，迅速生成符合要求的精美草图。这类工具的出现，极大地缩短了设计师的创作周期，提高了工作效率。同时，它们还能够为艺术家提供源源不断的灵感，激发其深藏的创作潜能。
三、AI绘画工具的应用场景 3.1 创意设计领域 在创意设计领域，AI绘画工具的应用正逐渐变得不可或缺。设计师们可以利用这些工具迅速生成符合项目需求的图像素材，从而大幅提高工作效率。同时，这些工具还能够为设计师们提供别出心裁的创意灵感，帮助他们打破固有的思维定势，创作出更加出彩的作品。
3.2 游戏与动画产业 在游戏与动画产业中，AI绘画工具同样大放异彩。它们能够自动生成细节丰富、真实感十足的场景、角色和道具等图像素材。这不仅显著提升了游戏和动画的视觉效果，还大大降低了制作成本和时间投入。如今，越来越多的游戏和动画制作团队开始尝试引入AI绘画工具，以期在激烈的市场竞争中脱颖而出。
3.3 艺术教育领域 在艺术教育领域，AI绘画工具为初学者和爱好者提供了前所未有的学习和实践机会。通过这些工具，用户可以轻松地尝试并掌握各种绘画风格和技术，从而在短时间内迅速提升自己的绘画水平。同时，这些工具还能够为艺术教师提供丰富多样的教学资源和手段，帮助他们以更加生动有趣的方式教授学生，激发学生的学习兴趣和创造力。
四、AI绘画工具的未来展望 4.1 技术持续进步 随着技术的不断进步和创新，我们有理由相信，AI绘画工具的性能将会越来越强大。未来的AI绘画工具将具备更高的智能化水平和更广泛的应用场景。它们将能够更加精准地模仿人类艺术家的创作风格，甚至有望创造出前所未有的全新艺术风格。这将为艺术创作领域带来更加丰富多彩的视觉盛宴。
4.2 艺术与科技的深度融合 未来的艺术创作将更加注重艺术与科技的深度融合。AI绘画工具将成为艺术家们不可或缺的得力助手。它们将与传统的绘画工具相互补充、相互促进，共同推动艺术创作的创新和发展。在这种趋势下，我们有望见证更多令人惊叹的艺术佳作诞生。
4.3 拓展至更多领域 除了创意设计、游戏与动画产业和艺术教育等领域外，AI绘画工具还将进一步拓展至虚拟现实（VR）、增强现实（AR）以及影视制作等更多领域。这将为我们带来更加丰富、多样且精彩的视觉体验，让艺术的魅力渗透到生活的每一个角落。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3018082505b31bb4c81225244f60a6c6/" rel="bookmark">
			毕设成品 基于大数据人才岗位数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言1. 数据集说明2. 数据处理2.1 数据清洗2.2 数据导入 3. 数据分析可视化3.1 整体情况（招聘企业数、岗位数、招聘人数、平均工资）3.2 企业主题行业情况公司类型最缺人的公司 TOP平均薪资最高的公司 TOP工作时间工作地点福利词云 3.3 岗位主题工作经验要求学历要求性别要求年龄要求语言要求编程语言要求 4. 模型预测 1 前言 这里是毕设分享系列，学长分享优质毕业设计项目，今天要分享的是
🚩 基于大数据人才岗位数据分析
项目运行效果：
毕业设计 基于大数据人才岗位数据分析
项目获取：
https://gitee.com/assistant-a/project-sharing
1. 数据集说明 这是一份来自厦门人才网的企业招聘数据，采集日期为 2021-01-14，总计 100,077 条记录，大小为 122 M，包含 19 个字段。
2. 数据处理 2.1 数据清洗 使用 pandas 对数据进行清洗，主要包括：去重、缺失值填充、格式化、计算冗余字段。
# 数据重复处理: 删除重复值 # print(data[data.duplicated()]) data.drop_duplicates(inplace=True) data.reset_index(drop=True, inplace=True) # 缺失值查看、处理： data.isnull().sum() # 招聘人数处理：缺失值填 1 ，一般是一人; 若干人当成 3人 data['num'].unique() data['num'].fillna(1, inplace=True) data['num'].replace('若干', 3, inplace=True) # 年龄要求：缺失值填 无限；格式化 data['age'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3018082505b31bb4c81225244f60a6c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59702ce41ae386f480ab41620d917c39/" rel="bookmark">
			USB2.0学习3--USB传输和事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. USB帧和微帧
2. USB传输类型（Transfer）
2.1 控制传输（Control Transfer）
2.2 中断传输（Interrupt Transfer）
2.3 批量传输（Bulk Transfer）
2.4 同步传输（Isochronous Transfer）
3. USB事务(Transaction)
4. USB传输及事务组成
4.1 控制传输及事务组成
4.2 中断传输及事务组成
4.3 批量传输及事务组成
4.4 同步传输及事务组成
5. USB帧、微帧、传输、事务、包的关系
USB 通信由一系列帧构成（从时间角度来看）；在一帧数据内，可以划分为4种传输方式（从功能场景角度来看），每种传输方式都有各自的特点。再往下细分，每种传输又由3种基本的事务组成，一个事务由若干个数据包组成，包则是USB总线上数据传输的最小单位，所有的数据都是打包后再发送出去的。
1. USB帧和微帧 USB2.0协议中，帧和微帧属于时间上的概念。
由于USB总线上可能会存在多个从机，如果同一时间内，有多个从机同时要使用总线的话，会产生冲突，所以USB协议规定了帧/微帧的时间概念，USB主机每隔1帧/1微帧（即每1ms/125us），会将总线的使用权指定给某个USB从机，USB从机在这帧/微帧的时间内，可以通过总线进行数据传输的操作，如果没有数据传输操作需要执行，USB总线就会进入空闲状态，等这帧/微帧过后，USB总线的使用权会交给其他USB从机，周而复始。帧/微帧的间隔足够小，数据传输的操作就会频繁的在多个USB从机之间切换，看起来就好像是同时在进行数据传输一样。
USB低速模式，全速模式下，每个帧的长度为1ms；而高速模式下，每个微帧的长度为125us，即1帧=8微帧，帧的时间长度是固定的，如下图所示。
每一帧都有一个帧开始（SOF），随后才是数据传输，如下图所示。
2. USB传输类型（Transfer） 为了满足不同的应用场景需求，USB协议定义了4种数据传输方式，它们在数据格式、传输方向、数据包容量限制、总线访问限制等方面有着各自不同的特征。这4种传输分别是：
控制传输（Control Transfer）、中断传输（Interrupt Transfer）、批量传输（Bulk Transfer）、同步传输（Isochronous Transfer）。 2.1 控制传输（Control Transfer） 控制传输是 USB 最基本也是最重要的传输，所有的设备都会支持这种传输模式。 设备的配置，命令，状态都通过控制传输传递。控制传输主要有2个作用，一是USB主机对设备进行初始化，设备在正常工作之前必须先进行配置，比如分配设备地址，读取设备的各种描述符，配置管道、带宽等；另一个是在设备的工作过程中，主机希望能及时地获取设备的当前状态，或者设备出现问题时希望主机能及时做出补救措施，或者主机根据某些需求改变设备的当前配置等工作。
控制传输有如下特点：
控制传输是一种可靠的双向传输，即可以接收数据包又可以发送数据包，相应的控制传输的管道也是双向的；控制传输对于最大包长度有固定的要求，对于高速设备该值为64Byte；对于低速设备该值为8 Byte；全速设备可以是8或16或32或64 Byte；所有的设备必须有至少一个控制端点，且端点号为0；支持错误检测和数据重传。 2.2 中断传输（Interrupt Transfer） 这里的中断传输不是传统意义上的中断传输，而是指一种轮询的传输方式，HOST通过固定的间隔对中断端点进行查询，若有数据传输或可以接收数据则返回数据或发送数据，否则返回NAK，表示尚未准备好。中断传输对延迟要求严格，只发送或接收少量的数据。
中断传输有一个确定的传输周期，每隔一定的周期要求传输一次（但是并不是要求必须按固定周期发送一次数据，它的只会保证轮询的间隔小于我们设置的间隔）。系统在对进行中断传输的设备进行配置时，只要当前总线上用于周期性传输的空闲带宽能够容纳此设备，设备就可以工作。使用这种传输方式的设备有键盘、鼠标、游戏杆等。
中断传输有如下特点：
中断传输的最大服务周期（单位：毫秒）必须得到保证；是一种可靠的数据传输方式；由于错误而引起的数据重传将在下一服务周期进行；数据的结尾也是通过与包的最大传输字节数比较来确定；对于高速/全速/低速端点，最大包长度分别可以达到 1024/64/8 Bytes； 2.3 批量传输（Bulk Transfer） 批量传输是一种传输大量数据的可靠传输，对延迟要求宽松，常见的如打印机、扫描仪、硬盘、U盘等设备的数据传输都有这种特点。当一帧内的总线时间（带宽）有空余时，USB主机就会将剩余的时间（带宽）分配给等待使用总线的批量传输的USB设备，也就是说，批量传输可以利用任何可获得的总线带宽来进行数据传输。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59702ce41ae386f480ab41620d917c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/088447ab120298006e29022026812493/" rel="bookmark">
			vmware16 pro - ubuntu22.04，各种烂问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁盘空间不足导致启动失败
1.按住shift启动ubuntu
2.Advanced options-&gt;recovery...-&gt;root...-&gt;输入密码root，进入终端，删除一点文件。
3.找到回收站 “用户”/.local/share/Trash 删除文件。
4.df -m 看磁盘使用不是100%就行。
5.reboot启动试试。
6.启动成功后关闭ubuntu，扩展磁盘：vmware-&gt;虚拟机-设置-磁盘-扩展。
7.打开Ubuntu，找到disk工具，调整容量。
VMware能识别usb设备，但无法连接（灰色）
在你的虚拟机安装目录下找到（虚拟机名字）.vmx文件，用记事本打开，
找到 usb.restrictions.defaultAllow = "FALSE" 改成TRUE ，保存。
https://blog.csdn.net/lxhujinghui2011/article/details/124533017
​ubuntu设置共享文件夹后却不显示，/mnt/hgfs下为空
sudo gedit /etc/fstab
在最后添加一行：
.host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other 0 0
https://blog.csdn.net/weixin_61725973/article/details/128148695
搜索卡死
将默认输入法换成ibus
sudo apt install ibus-libpinyin
ibus-setup
https://blog.csdn.net/qq_38222947/article/details/131140492
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9ea39525743e3eecba20d825265299/" rel="bookmark">
			【C语言】函数执行背后的秘密：函数栈帧的创建和销毁超详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】
目录
1. 什么是函数栈帧
2. 理解函数栈帧能解决什么问题呢？
3. 函数栈帧的创建和销毁解析
3.1 什么是栈？
3.2 认识相关寄存器和汇编指令
3.3 解析函数栈帧的创建和销毁
3.3.1 预备知识
3.3.2 函数的调用堆栈
3.3.4 准备环境
3.3.5 转到反汇编
3.3.6 函数栈帧的创建
3.3.7 函数栈帧的销毁
4. 问题解答
总结
1. 什么是函数栈帧 我们在写C语言代码的时候，经常会把一个独立的功能抽象为函数，所以C程序是以函数为基本单位的。那函数是如何调用的？函数的返回值又是如何待会的？函数参数是如何传递的？这些问题都和函数栈帧有关系。
函数栈帧（stack frame）就是函数调用过程中在程序的调用栈（call stack）所开辟的空间，这些空间是用来存放：
函数参数和函数返回值临时变量（包括函数的非静态的局部变量以及编译器自动生产的其他临时变量）保存上下文信息（包括在函数调用前后需要保持不变的寄存器） 2. 理解函数栈帧能解决什么问题呢？ 理解函数栈帧有什么用呢？
只要理解了函数栈帧的创建和销毁，以下问题就能够很好的理解了：
局部变量是如何创建的？为什么局部变量不初始化内容是随机的？函数调用时参数时如何传递的？传参的顺序是怎样的？函数的形参和实参分别是怎样实例化的？函数的返回值是如何带会的？ 让我们一起走进函数栈帧的创建和销毁的过程中。
3. 函数栈帧的创建和销毁解析 3.1 什么是栈？ 栈（stack）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今看到的所有的计算机语言。
在经典的计算机科学中，栈被定义为一种特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将已经压入栈中的数据弹出（出栈，pop），但是栈这个容器必须遵守一条规则：先入栈的数据后出栈（First In Last Out， FIFO）。就像叠成一叠的术，先叠上去的书在最下面，因此要最后才能取出。
在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使得栈减小。
在经典的操作系统中，栈总是向下增长（由高地址向低地址）的。
在我们常见的i386或者x86-64下，栈顶由成为 esp 的寄存器进行定位的。
3.2 认识相关寄存器和汇编指令 相关寄存器
eax：通用寄存器，保留临时数据，常用于返回值ebx：通用寄存器，保留临时数据ebp：栈底寄存器esp：栈顶寄存器eip ：指令寄存器，保存当前指令的下一条指令的地址 相关汇编命令
mov ：数据转移指令push：数据入栈，同时esp栈顶寄存器也要发生改变pop ：数据弹出至指定位置，同时esp栈顶寄存器也要发生改变sub ：减法命令add ：加法命令call ：函数调用，1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9ea39525743e3eecba20d825265299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f1f86c807434f12c39f01cd32660b1/" rel="bookmark">
			# Kafka_深入探秘者（1）：初识 kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka_深入探秘者（1）：初识 kafka 一、kafka 特性 1、Kafka ：最初是由 Linkedln 公司采用 Scala 语言开发的一个多分区、多副本并且基于 ZooKeeper 协调的分布式消息系统，现在已经捐献给了 Apache 基金会。目前 Kafka 已经定位为一个分布式流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流处理等多种特性而被广泛应用。 2、Apache Kafka 是一个分布式的发布-订阅消,息系统，能够支撑海量数据的数据传递。在离线和实时的消息处理业务系统中，Kafka 都有广泛的应用。Kafka 将消息持久化到磁盘中，并对消息创建了备份保证了数据的安全。Kafka 在保证了较高的处理速度的同时，又能保证数据处理的低延迟和数据的零丢失。 3、示例图： 4、kafka 特性 (1)高吞吐量、低延迟: kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个主题可以分多个分区,消费组对分区进行消费操作;
(2)可扩展性: kafka 集群支持热扩展;
(3)持久性、可靠性: 消息被持久化到本地磁盘，并且支持数据备份防止数据丢失;
(4)容错性: 允许集群中节点失败(若副本数量为n,则允许n-1个节点失败);
(5)高并发: 支持数千个客户端同时读写;
5、kafka 使用场景 (1)日志收集: 一个公司可以用 Kafka 可以收集各种服务的 l0g，通过kafka以统一接口服务的方式开放给各种 consumer，例如 Hadoop、Hbase、Solr 等;
(2)消息系统: 解耦和生产者和消费者、缓存消息等:
(3)用户活动跟踪: Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动,这些活动信息被各个服务器发布到 kafka 的 topic 中，然后订阅者通过订阅这些 topic 来做实时的监控分析，或者装载到 Hadoop、数据仓库中做离线分析和挖掘;
(4)运营指标: Kafka 也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。
(5)流式处理: 比如 spark streaming 和 storm。
6、技术优势 1）可伸缩性: Kafka 的两个重要特性造就了它的可伸缩性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f1f86c807434f12c39f01cd32660b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8eb147bc5feedf442daca7bfe17809f/" rel="bookmark">
			什么野指针（c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		野指针定义 野指针（Wild Pointer）是指向不确定位置或者非法地址的指针。当一个指针指向的内存被释放后，如果没有将其设置为NULL，那么这个指针就变成了野指针。使用野指针会导致未定义行为，可能引发程序崩溃或数据损坏。
代码实例 假设我们有以下C++代码片段：
#include &lt;iostream&gt; int main() { int *ptr = new int(5); std::cout &lt;&lt; "Value at ptr: " &lt;&lt; *ptr &lt;&lt; std::endl; delete ptr; // 内存被释放，但ptr没有置空 std::cout &lt;&lt; "Value at ptr after deletion: " &lt;&lt; *ptr &lt;&lt; std::endl; // 使用野指针 return 0; } 在这个例子中，ptr在delete之后成为一个野指针。如果我们尝试访问它指向的内容，程序可能会崩溃，因为ptr现在指向的是已经释放的内存区域。
预防方案 为了防止野指针的产生，可以采取以下几种策略：
及时置空：在释放指针指向的内存后，立即将指针设为NULL。
修改上述代码：
#include &lt;iostream&gt; int main() { int *ptr = new int(5); std::cout &lt;&lt; "Value at ptr: " &lt;&lt; *ptr &lt;&lt; std::endl; delete ptr; ptr = nullptr; // 将指针置空，避免成为野指针 return 0; } 智能指针：使用C++中的智能指针（如std::unique_ptr或std::shared_ptr），这些指针会在超出作用域或不再需要时自动释放所指向的内存，从而避免野指针问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8eb147bc5feedf442daca7bfe17809f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/232/">«</a>
	<span class="pagination__item pagination__item--current">233/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/234/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>