<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d6d24048078208e61096d82f67eb01/" rel="bookmark">
			剑指Offer题集（力扣）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 剑指Offer题集（[力扣题单](https://leetcode.cn/problemset/all/?listId=lcof&amp;page=1)）[剑指 Offer 03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)[剑指 Offer 04. 二维数组中的查找](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)[剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)[剑指 Offer 06. 从尾到头打印链表](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)🎃[剑指 Offer 07. 重建二叉树[前序+中序]](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)106.重建二叉树[后序+中序][889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) [剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)[剑指 Offer 10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)[剑指 Offer 10- II. 青蛙跳台阶问题【爬楼梯】](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)[剑指 Offer 11. 旋转数组的最小数字](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)[剑指 Offer 12. 矩阵中的路径](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)[剑指 Offer 13. 机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)🎉[剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/)[剑指 Offer 14- II. 剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/)[剑指 Offer 15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)[剑指 Offer 16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)[剑指 Offer 17. 打印从1到最大的n位数](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)[剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)🎉[剑指 Offer 19. 正则表达式匹配](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)[剑指 Offer 20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)[剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)[剑指 Offer 22.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d6d24048078208e61096d82f67eb01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bef62e4d73c255995e9551d6cce2412/" rel="bookmark">
			Linux Ubuntu系统安装MySQL并实现公网连接本地数据库【内网穿透】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1 .安装Docker2. 使用Docker拉取MySQL镜像3. 创建并启动MySQL容器4. 本地连接测试4.1 安装MySQL图形化界面工具4.2 使用MySQL Workbench连接测试 5. 公网远程访问本地MySQL5.1 内网穿透工具安装5.2 创建远程连接公网地址5.3 使用固定TCP地址远程访问 前言 本文主要介绍如何使用Docker部署MySQL，并结合cpolar内网穿透工具实现远程访问本地数据库。
Docker提供了一个轻量级的容器化解决方案，可以更好的简化数据库的部署过程。让创建和管理MySQL数据库变得更简单快捷。下面就来分享一下具体的部署过程，并提出一些需要注意的事项，以及如何通过内网穿透工具实现无公网ip访问本地数据库。
1 .安装Docker 本教程操作环境为Linux Ubuntu系统，在开始之前，我们需要先安装Docker。
在终端中执行下方命令：
添加Docker源
# Add Docker's official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # Add the repository to Apt sources: echo \ "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bef62e4d73c255995e9551d6cce2412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/645b0d2f88154f76ea52f99d9c805856/" rel="bookmark">
			数据结构——lesson6二叉树基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 hellohello~这里是土土数据结构学习笔记🥳🥳
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：数据结构学习笔记
💥对于数据结构顺序表链表有疑问的都可以在上面数据结构的专栏进行学习哦~感谢大家的观看与支持🌹🌹🌹
有问题可以写在评论区或者私信我哦~
前面我们已经学习过了数据结构中顺序表和链表（都放在数据结构专栏了），今天我们将继续学习数据结构中二叉树有关的知识🥳🥳
💥1.树概念及结构 🎉1.1树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。
把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
类似于倒立的树：
✨有一个特殊的结点，称为根结点，如上图中的A，根节点没有前驱结点。（根节点在下面介绍）
✨除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i&lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继
✨因此，树是递归定义的。
🥳1.2与树有关的概念 如图是树形结构：
节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6；
叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I…等节点为叶节点；
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G…等节点为分支节点；
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点
孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点；
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点；
树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6；
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
树的高度或深度：树中节点的最大层次； 如上图：树的高度为4；
堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点；
节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先；
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙；
森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
以上节点的层次不同于数组下标从0开始，它是从1开始便于后续使用，不然不好区分一层节点和没有节点的情况，当然也可以从0开始，数组下标从0开始则是因为*（arr+i）便于计算。
注意：树形结构中，子树之间不能有交集，否则就不是树形结构
树可以理解为包括两个：一是父节点（前驱节点），另一个是子树。
而子树同样又可以分为父节点和子树
直到找到叶子节点
💫1.3 树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既然保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。
我们这里简单介绍一些方法：
（1）直接表示
这里我们需要知道树的度，然后直接定义
struct TreeNode { int data;//保存数据 struct TreeNode* child1;//保存孩子节点的指针 struct TreeNode* child2; //... } 如果树的度是7，我们则需要定义7个树的指针
（2）双亲表示法
存放双亲也就是父节点的指针或下标即可
struct TreeNode { int data; struct TreeNode* parent;//或者存放下标int parenti; } (3)最常用的孩子兄弟表示法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/645b0d2f88154f76ea52f99d9c805856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215ea53acb1763b90e1f46e71ce3fda6/" rel="bookmark">
			SQL 错误 [1722] [42000]: ORA-01722: 无效数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL 错误 [1722] [42000]: ORA-01722: 无效数字
ORACLE中该错误提示ORA-01722: 无效数字是一个SQL错误，通常发生在尝试将一个无效的字符串转换为数字类型时发生的
这可能是由以下原因之一引起的： 1.字符串包含非数字字符：在进行数字类型转换时，字符串中不能包含除数字以外的字符,请确保在进行转换之前，字符串中只包含有效的数字字符。
2.字符串为空或包含空格：空字符串或仅包含空格的字符串无法转换为数字类型,在进行转换之前，请确保字符串不为空，并且不包含额外的空格。
3.字符串的格式不正确：某些数据库要求数字字符串具有特定的格式，例如小数点、千位分隔符等,请检查字符串的格式是否符合数据库的要求。
该错误举例: 对tableName表中field字段进行排序,+1是转数字类型,或者是使用TO_NUMBER()转换的
SELECT * FROM tableName WHERE 1 = 1 ORDER BY field + 1 ASC; 解决方案:
SELECT * FROM tableName WHERE 1 = 1 ORDER BY TO_NUMBER(REGEXP_REPLACE(field, '[^0-9]+', '')) ASC; 解释:TO_NUMBER(REGEXP_REPLACE(field, ‘[^0-9]+’, ‘’))
TO_NUMBER(REGEXP_REPLACE(field, '[^0-9]+', ''))是一个SQL表达式，它的含义是将字段field中的非数字字符替换为空字符串，并将结果转换为数字类型。
下面是该表达式的细节解释：
REGEXP_REPLACE(field, '[^0-9]+', '')：这一部分将字段field中的非数字字符（[^0-9]+表示匹配除数字外的任意字符序列）替换为空字符串。TO_NUMBER(&lt;expression&gt;)：这一部分使用函数TO_NUMBER将前面得到的字符串结果转换为数字类型。 综合起来，该表达式的作用是从field字段中提取出所有的数字字符，并将其转换为数字类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b42c5829a5e7e8dfbd508043a36bac/" rel="bookmark">
			SpringBoot实现各种参数校验，写得太好了，建议收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前也写过一篇关于Spring Validation使用的文章，不过自我感觉还是浮于表面，本次打算彻底搞懂Spring Validation。本文会详细介绍Spring Validation各种场景下的最佳实践及其实现原理，死磕到底！
简单使用 Java API规范(JSR303)定义了Bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。接下来，我们以spring-boot项目为例，介绍Spring Validation的使用。
引入依赖 如果spring-boot版本小于2.3.x，spring-boot-starter-web会自动传入hibernate-validator依赖。如果spring-boot版本大于2.3.x，则需要手动引入依赖：
&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.1.Final&lt;/version&gt; &lt;/dependency&gt; 对于web服务来说，为防止非法参数对业务造成影响，在Controller层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：
POST、PUT请求，使用requestBody传递参数；
GET请求，使用requestParam/PathVariable传递参数。
下面我们简单介绍下requestBody和requestParam/PathVariable的参数校验实战！
requestBody参数校验 POST、PUT请求一般会使用requestBody传递参数，这种情况下，后端使用DTO对象进行接收。只要给DTO对象加上@Validated注解就能实现自动参数校验。比如，有一个保存User的接口，要求userName长度是2-10，account和password字段长度是6-20。如果校验失败，会抛出MethodArgumentNotValidException异常，Spring默认会将其转为400（Bad Request）请求。
DTO表示数据传输对象（Data Transfer Object），用于服务器和客户端之间交互传输使用的。在spring-web项目中可以表示用于接收请求参数的Bean对象。
在DTO字段上声明约束注解
@Data public class UserDTO { private Long userId; @NotNull @Length(min = 2, max = 10) private String userName; @NotNull @Length(min = 6, max = 20) private String account; @NotNull @Length(min = 6, max = 20) private String password; } 在方法参数上声明校验注解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b42c5829a5e7e8dfbd508043a36bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c5289799bfad82271ec9b56f4a26994/" rel="bookmark">
			Stable Diffusion WebUI安装报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人是一个AI新手，最近在研究文生图方面相关内容时看到Stable Diffusion WebUI这个项目，想在本地部署安装试用看下效果，安装过程中遇到了一些问题，此处记录一下
问题1：Python 3.12.1 (tags/v3.12.1:2305ca5, Dec 7 2023, 22:03:25) [MSC v.1937 64 bit (AMD64)] Version: 1.8.0-RC Commit hash: &lt;none&gt; Installing torch and torchvision Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple, https://download.pytorch.org/whl/cu121 ERROR: Could not find a version that satisfies the requirement torch==2.1.2 (from versions: 2.2.0, 2.2.0+cu121, 2.2.1, 2.2.1+cu121) ERROR: No matching distribution found for torch==2.1.2
解决方案：试用正确的python版本，我本地安装的python版本是3.12.1，而Stable Diffusion WebUI要求的python是3.10.6，必须使用这个版本，其他版本会出现上述这个问题。这点官方文档上也有说明
Install Python 3.10.6 (Newer version of Python does not support torch), checking "Add Python to PATH"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c5289799bfad82271ec9b56f4a26994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6fbb043077a7994561cf6cdd8bcc1e/" rel="bookmark">
			前端vue项目使用Decimal.js做加减乘除求余运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 vue项目安装Decimal npm install decimal.js 2 注意 运算结果是Decimal对象，需要使用.toNumber()转为数字
3 加 add const Decimal = require('decimal.js') const num1 = Decimal("5"); const num2 = Decimal("3"); const remainder = num1.add(num2); 4 减 sub const Decimal = require('decimal.js') const num1 = Decimal("5"); const num2 = Decimal("3"); const remainder = num1.sub(num2); 5 乘 mul const Decimal = require('decimal.js') const num1 = Decimal("5"); const num2 = Decimal("3"); const remainder = num1.mul(num2); 6 除 div const Decimal = require('decimal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b6fbb043077a7994561cf6cdd8bcc1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/759da53277cbd52bcc2a8192487567dd/" rel="bookmark">
			三步实现Java的SM2前端加密后端解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		秦医如毒，无药可解。
话不多说，先上需要用到的js文件下载链接 和 jsp前端代码。
第一步：下载两个必备的js文件—— crypto-js.js、sm2.js 。
它们的下载链接如下↓（该网页不魔法上网的话会很卡，毕竟github，建议卡的话就多重新加载几次，我差不多试了8次才进去）：
https://github.com/Saberization/SM2
进入网页，下载后拿取下方↓图片上的两个js就行：
然后，将这两js放到存放静态资源（static）的目录下，我放的是static中的sm2目录（sm2这个目录是我创的）
后面，在jsp的&lt;head&gt;&lt;/head&gt;中引入这两个js文件
&lt;!--jsp引入sm2，实现前端加密--&gt; &lt;script type="text/javascript" src="${pageContext.request.contextPath}/static/sm2/crypto-js.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="${pageContext.request.contextPath}/static/sm2/sm2.js" charset="utf-8"&gt;&lt;/script&gt; 第二步：前端jsp代码实现，下方的代码写在jsp页面的&lt;script type="text/javascript"&gt;&lt;/script&gt;中。
作用是，当调用下方↓函数的时候，会给你传入的值进行加密并返回。
注：【你生成的公钥】的生成方式可以在文章末尾的SM2Utils.java工具类中可以找到，是个main方法，一键生成，简单粗暴
&lt;!--sm2加密函数--&gt; function sm2EncryptPwd(data) { &lt;!--sm2公钥--&gt; var publicKey = '你生成的公钥'; return sm2Encrypt(data, publicKey, 1); } 至此，前端加密结束，进入后端解密环节——
后端需要的jar包是：bcprov-jdk15on-1.68.jar
注意！！！该jar包必须要1.60版本以上的，不然解密的时候会缺少必要的条件！！！并且我用的时候，本地环境是JDK1.8的，其他环境没试过，建议如有不同，先查一下。
&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.68&lt;/version&gt; &lt;/dependency&gt; 第三步：后端代码实现。
导入jar包后，就是必要的工具类实体类：SM2Utils.java
用工具类中我写的 getJieMiJieGuo() 方法解密。
该方法操作起来更简单些，只需要传入加密后的字符串，就可以返回解密的数据。
注: 除getJieMiJieGuo()方法外，其它方法都不是我所写，不保证能解密成功。
其中【你生成的公钥】和【你生成的私钥】可以通过工具类中的方法生成，生成完复制粘贴进去就行
注！后端和前端的公钥要保持一致！因为公钥私钥是配对使用的！
package com.test.common.utils; import org.apache.commons.net.util.Base64; import org.bouncycastle.asn1.gm.GMNamedCurves; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.InvalidCipherTextException; import org.bouncycastle.crypto.engines.SM2Engine; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/759da53277cbd52bcc2a8192487567dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa29c84f9c3b3f455660b31411088c8/" rel="bookmark">
			开源文生图大模型Playground v2.5发布：超越SD、DALL·E 3和 Midjourney
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在AI技术迅速发展的今天，文生图模型成为了艺术创作、设计创新等领域的重要工具。Playground v2.5的发布，不仅在技术上取得了突破，更在开源文化的推广与实践上迈出了重要一步。
Huggingface模型下载：https://huggingface.co/playgroundai
AI快站模型免费加速下载：https://aifasthub.com/models/playgroundai
技术创新：超越前辈 Playground v2.5由一支由Daiqing Li、Aleks Kamko、Ehsan Akhgari、Ali Sabet、Linmiao Xu、Suhail Doshi组成的跨国团队研发。这一最新版文生图生成模型，在美学质量、颜色与对比度增强、多宽高比生成以及人类中心细节的改进方面，都达到了行业领先水平。
美学质量的飞跃：相比于SDXL、Playground v2及PixArt-⍺等开源模型，Playground v2.5在用户研究中显示出了显著的优势。其输出的图像在美学质量上不仅超越了上述模型，甚至在多个方面超过了闭源模型如DALL·E 3和Midjourney v5.2。
色彩与对比度的提升：在传统上，文生图模型在生成带有鲜艳色彩和高对比度图像方面存在局限。Playground v2.5通过改进噪声调度流程，显著提高了图像的色彩饱和度和对比度，使得生成的图像更加生动、真实。
支持多宽高比生成：Playground v2.5在设计时考虑到了多宽高比图像的生成，有效解决了仅在正方形图像上训练带来的局限性，为用户提供了更灵活的创作工具。
人类中心细节的精细化改进：针对人类图像生成，Playground v2.5优化了人脸、手部及身体的细节表现，极大地提升了图像的自然度和真实感。
模型测评 Playground官方进行了用户调研数据研究分析，以衡量整体的审美质量，以及 Playground v2.5 旨在改进的多纵横比和人类偏好对齐功能的评估。
Playground v2.5 在审美质量方面显著超越当前最先进的开源模型 SDXL 和 PIXART-α，以及 Playground v2。由于 Playground V2.5 和 SDXL 之间存在较大的性能差距，因此官方还将它与当前闭源模型如 DALL-E 3 和 Midjourney 5.2 进行了审美质量比较，发现 Playground v2.5 也比这些闭源模型相比表现会更好。
在多纵横比绘图质量评估方面，Playground v2.5 也大幅度的超越了 SDXL。
同时也使用了在Playground v2 版本时开源提出的 MJHQ-30K 基准报告对应评估测试。在 1024x1024 分辨率下，进行了关于总体 FID 和每个类别的 FID的评估测试。评估测试结果显示，Playground v2.5 在总体 FID 和所有类别 FID（尤其是人物和时尚类别）上都超过了 Playground v2 和 SDXL。并且这项评估结果数据与用户调研得到的结果表现一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efa29c84f9c3b3f455660b31411088c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0f70e67b4df88a1a713de726260031/" rel="bookmark">
			毕业设计 基于大数据情感分析的网络舆情分析系统(源码&#43;论文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 简介
今天学长向大家介绍一个大数据毕设项目
毕设分享 基于大数据情感分析的网络舆情分析系统(源码+论文)
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 项目获取：
https://gitee.com/assistant-a/project-sharing
实现效果
毕业设计 基于大数据情感分析的网络舆情分析系统
1 课题背景 在文本挖掘领域，文本聚类是一类常见而又重要的数据挖掘手段，同时也是很多其他挖掘操作的前置工作。顾名思义，聚类即按照某些特征和规则将整个数据集分成若干组的过程，各个组内元素在某些特征方面具有较高的相似性，而组间元素则在这些特征方面具有较大的差异性，所得到的各个组即为一个聚类，也常称之为“簇”。聚类作为一种无监督的机器学习方法，无需人工对数据进行标注和训练，自动化程度高。目前已被广泛应用于计算机科学、情报学、社会学、生物学等多个领域。随着互联网的高速发展，文本聚类在Web数据处理相关方面应用尤其广泛，例如推荐系统、网络舆情、各类文本挖掘及相关应用。
本项目收集了微博相关热点文章数据，并对评论进行情感分析统计，建立web可视化系统。
2 实现效果 主界面
3 文本情感分析 在了解了基于统计方法的情感分析模型优缺点之后，我们看一下深度学习文本分类模型是如何进行文本情感分析分类的。深度学习的一个优势就是可以进行端到端的学习，而省略的中间每一步的人工干预步骤。基于预训练模型生成的词向量，深度学习首先可以解决的一个重要问题就是情感词典的构建。下面我们会以集中典型的文本分类模型为例，展示深度文本分类模型的演进方向和适用场景。
3 Django Django简介
Python下有多款不同的 Web 框架，Django是最有代表性的一种。许多成功的网站和APP都基于Django。
Django是一个开源的Web应用框架，由Python写成。
Django采用了MVC的软件设计模式，即模型M，视图V和控制器C。
Django的特点
强大的数据库功能：用python的类继承，几行代码就可以拥有一个动态的数据库操作API，如果需要也能执行SQL语句。
自带的强大的后台功能：几行代码就让网站拥有一个强大的后台，轻松管理内容。
优雅的网址：用正则匹配网址，传递到对应函数。
模板系统：强大，易扩展的模板系统，设计简易，代码和样式分开设计，更易管理。
缓存系统：与memcached或其它缓存系统联用，表现更出色，加载速度更快。
国际化：完全支持多语言应用，允许你定义翻译的字符，轻松翻译成不同国家的语言。
基本框架图
架构图介绍
生产部署环境一般用UWSGI和Gunicorn部署，两者的区别后面系列文章会讲到。
我将django架构分为 网络层，计算层，存储层。
网络层 由wsgi容器解析socket，转化成wsgi协议数据包；
计算层 也就是网上盛传的MVC结构，这同时也是一种设计模式；
存储层 框架对各种数据库服务器的封装；
安装
pip install django 使用
#!/usr/bin/env python '''Django's command-line utility for administrative tasks.''' import os import sys def main(): '''Run administrative tasks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0f70e67b4df88a1a713de726260031/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b673ed6dc3cd8af14d56af618316daa9/" rel="bookmark">
			数据结构-树的遍历和基本操作(Java实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 二叉树的遍历 二叉树的遍历分为以下三种: 前序遍历: 访问顺序为 根节点----&gt;左子树----&gt;右子树
中序遍历: 访问顺序为 左子树----&gt;根节点----&gt;右子树
后序遍历: 访问顺序为 左子树----&gt;右子树----&gt;根节点
接下来针对这3种遍历方式进行详细介绍:
(1) 前序遍历 上图前序遍历顺序为 1 2 3 4 5 6
(2) 中序遍历 上图中序遍历顺序为3 2 1 5 4 6 (3) 后序遍历 上图后序遍历顺序为 3 2 5 6 4 1
(4) 层序遍历原理 除了前序遍历,中序遍历,后序遍历外,还可以对二叉树进行层序遍历. 设二叉树的根节点所在层数为1, 层序遍历就是从所在二叉树的根节点出发,首先访问第一层的树的根节点,然后从左到右访问第2层上的结点,接着是第三层的结点,以此类推,自上而下,自左至右逐层访问树的结点的过程就是层序遍历. 上图的层序遍历为 1 2 4 3 5 6
二. 二叉树的基本操作 2.1 二叉树的创建 二叉树的存储结构分为: 顺序存储结构和类似于链表的链式存储。二叉树的链式存储是通过一个一个的结点引用起来的，常见的表示方式有二叉和三叉表示方式。在这里我们主要是使用二叉表示法来创建二叉树。
static class TreeNode { //定义好三个属性 public char val; public TreeNode left; //左节点 public TreeNode right; //右节点 public TreeNode(char val) { //提供一个结点的构造方法 new一个新结点的时候是不知道左右子树的,所以不用构造 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b673ed6dc3cd8af14d56af618316daa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32915128b951ebbc396b5c6af2d6d9e3/" rel="bookmark">
			信号特征之希尔伯特变换（Python、C&#43;&#43;、MATLAB实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		希尔伯特变换 1 特征描述 希尔伯特变换广泛使用于信号处理应用中，以获得信号的解析表示。其可以计算瞬时频率和相位，相位被定义为原始信号和信号的希尔伯特变换之间的角度。对于信号 x ( t ) x(t) x(t)，其希尔伯特变换定义如下。
x ^ ( t ) = H [ x ( t ) ] = 1 π ∫ − ∞ + ∞ x ( τ ) t − τ d τ \hat{x}(t)=H[x(t)]=\frac{1}{\pi}\int_{-\infty}^{+\infty}\frac{x(\tau)}{t-\tau}\,\text{d}\tau x^(t)=H[x(t)]=π1​∫−∞+∞​t−τx(τ)​dτ
由上式可知，随着变换的结果，自变量不变，因此输出 x ^ ( t ) \hat{x}(t) x^(t)也是与时间有关的函数。此外， x ^ ( t ) \hat{x}(t) x^(t)是 x ( t ) x(t) x(t)的线性函数。它是由 ( π t ) − 1 {({\pi}t)}^{-1} (πt)−1与 x ( t ) x(t) x(t)卷积获得的，如下关系所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32915128b951ebbc396b5c6af2d6d9e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ccedebc9ff0bceeb7af227abf27f06/" rel="bookmark">
			JDK 22 和 JDK 23：到目前为止我们所知道的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK 22 和 JDK 23：到目前为止我们所知道的 Oracle Java 平台组首席架构师Mark Reinhold宣布， JDK 22是自JDK 21以来的第一个非 LTS 版本，现已进入第二个候选版本阶段。主线源代码存储库于 2023 年 12 月中旬（Rampdown 第一阶段）分叉到 JDK稳定存储库，定义了 JDK 22 的功能集。可以解决诸如回归或严重功能问题之类的关键错误，但必须解决这些问题。通过修复请求流程获得批准。根据发布时间表，JDK 22将于2024年3月19日正式发布。
最终的 12 个新功能集（以JEP的形式）可分为四 (4) 类：核心 Java 库、Java 语言规范、HotSpot和Java 工具。
其中六 (6) 个新功能属于核心 Java 库：
JEP 454：外部函数和内存 APIJEP 457：类文件 API（预览版）JEP 460：Vector API（第七个孵化器）JEP 461：流收集器（预览）JEP 462：结构化并发（第二预览版）JEP 464：范围值（第二预览版） 其中四 (4) 个新功能属于Java 语言规范：
JEP 447：super(…) 之前的语句（预览）JEP 456：未命名变量和模式JEP 459：字符串模板（第二次预览）JEP 463：隐式声明的类和实例主要方法（第二预览版） 其中一 (1) 个新功能属于HotSpot类别：
JEP 423：G1 的区域固定 最后，其中一 (1) 个新功能被归类为Java 工具：
JEP 458：启动多文件源代码程序 我们研究了其中一些新功能，并包括它们在四个主要 Java 项目（ Amber、Loom、Panama和Valhalla ）支持下的位置，这些项目旨在孵化一系列组件，以便通过精心策划的合并最终包含在 JDK 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84ccedebc9ff0bceeb7af227abf27f06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3bd7f738ee9bbf2d2087e316f540a5c/" rel="bookmark">
			[动态规划]---part2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
作者：小蜗牛向前冲
专栏：小蜗牛算法之路
专栏介绍："蜗牛之道，攀登大厂高峰，让我们携手学习算法。在这个专栏中，将涵盖动态规划、贪心算法、回溯等高阶技巧，不定期为你奉上基础数据结构的精彩算法之旅。一同努力，追逐技术的星辰大海。"
目录
一、不同路径II（medium）
a、解题思路 b、代码
二、礼物的最⼤价值（medium）
a、解题思路 b、代码
三、 下降路径最⼩和（medium）
a、解题思路 b、代码
四、 最⼩路径和（medium）
a、解题思路 b、代码
五、地下城游戏（hard） a、解题思路 b、代码
本期：继续手撕动态规划：不同路径II（medium），礼物的最⼤价值（medium），下降路径最⼩和（medium），最⼩路径和（medium），地下城游戏（hard）
继续刷动态规划相关算法题，如果不清楚什么是动态规划的可以看这里：[动态规划]---part1
一、不同路径II（medium） 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。
示例 1：
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3bd7f738ee9bbf2d2087e316f540a5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27674254fd5d5a771d335f87608b5993/" rel="bookmark">
			Java | 字符串数组的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、声明字符串数组 在Java中，声明字符串数组时，需要指定数组的大小或使用new关键字分配内存。
demo:
public class StringArrayDeclaration { public static void main(String[] args) { // 声明一个字符串数组，未指定大小 String[] stringArray; // 声明并分配内存，例如创建一个长度为5的字符串数组 stringArray = new String[5]; } } 二、字符串数组的初始化 字符串数组可以在声明的同时进行初始化。可以分别初始化每个元素，也可以使用数组字面量初始化整个数组。
demo：
public class StringArrayInitialization { public static void main(String[] args) { // 使用数组字面量初始化一个字符串数组 String[] stringArray = {"Apple", "Banana", "Cherry"}; // 另一种初始化方式，每个元素单独初始化 String[] dynamicStringArray = new String[3]; dynamicStringArray[0] = "Apple"; dynamicStringArray[1] = "Banana"; dynamicStringArray[2] = "Cherry"; } } 三、字符串数组的默认值 如果创建字符串数组但没有初始化，每个元素都会默认初始化为null。
demo：
public class StringArrayDefaultValues { public static void main(String[] args) { String[] uninitializedArray = new String[5]; // 输出数组中的默认值 for (String value : uninitializedArray) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27674254fd5d5a771d335f87608b5993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3959db7aa84e82aadf499f9fd3c8e79/" rel="bookmark">
			python之eval函数使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eval() 是 Python 内置的一个函数，它可以将字符串当作有效的 Python 表达式进行求值并返回结果。它的作用是将字符串转换为相应的数据类型、执行计算和执行任意有效的 Python 代码。
然而，使用 eval() 函数需要谨慎，因为它可以执行任意的代码，可能导致安全风险和不受控制的行为。
1. eval() 函数的语法 eval() 函数的语法如下：
eval(expression, globals=None, locals=None)
参数： expression 是一个字符串，表示要求值的表达式或代码。
globals 是一个可选的全局命名空间字典。
locals 是一个可选的局部命名空间字典。
下面一些示例代码，展示了 eval() 函数的使用方法和功能。
1.1 默认参数使用 1.1.1 求值表达式 result = eval("2 + 3") print(result) # 输出：5 上述示例中，将字符串 "2 + 3" 作为表达式传递给 eval() 函数，它会求值这个表达式并返回结果。 1.1.2 字符串转换为数据类型 num = eval("42") print(type(num)) # 输出： &lt;class 'int'&gt; string = eval("'Hello, World!'") print(type(string)) # 输出： &lt;class 'str'&gt; 上述示例中，使用 eval() 将字符串转换为对应的数据类型，例如将字符串 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3959db7aa84e82aadf499f9fd3c8e79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3ec7d1ba8699d2d64eb6227ffbed82/" rel="bookmark">
			RabbitMQ、RocketMQ和Kafka全面对决，谁是最佳选择？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、应用场景 1.RabbitMQ：
适用于易用性和灵活性要求较高的场景
异步任务处理：RabbitMQ提供可靠的消息传递机制，适用于处理异步任务，例如将耗时的任务放入消息队列中，然后由消费者异步处理，提高系统的响应速度和可伸缩性。
解耦系统组件：通过使用RabbitMQ作为消息中间件，不同的系统组件可以通过消息进行解耦，实现松耦合的架构，提高系统的可维护性和灵活性。
事件驱动架构：RabbitMQ的发布-订阅模式可以用于构建事件驱动架构，将系统中的事件作为消息发布到相应的主题，不同的消费者可以订阅感兴趣的主题进行相应的处理。
2.RocketMQ：
适用于大规模数据处理和高吞吐量的场景
分布式事务：RocketMQ支持分布式事务消息，适用于涉及多个业务系统的分布式事务场景，确保消息的一致性和可靠性，同时提供高吞吐量的消息传递能力。
实时日志处理：由于RocketMQ具备高吞吐量和低延迟的特点，可以用于实时日志处理，例如日志收集和分析、日志聚合等场景。
流式处理：RocketMQ支持流式处理模式，可以将产生的数据流通过消息队列传递给流处理框架（如Flink、Spark Streaming），实现实时数据处理和分析。
3.Kafka：
适用于高吞吐量的实时数据流处理和流式处理场景
数据管道和实时数据处理：Kafka的高吞吐量和可持久化存储特性使其成为构建可靠的数据管道和实时数据处理系统的理想选择，用于流式数据的收集、传输和处理。
日志和事件流处理：Kafka的分区和有序性保证特性使其成为日志和事件流处理的理想解决方案，例如应用日志收集、事件溯源、业务监控等。
实时流分析和机器学习：Kafka与流处理框架（如Flink、Spark Streaming）结合使用，支持实时流分析和机器学习任务，处理实时数据流以获取实时的洞察和决策支持。
2、服务架构 RabbitMQ
Channel（通道）：Channel是RabbitMQ与应用程序之间的虚拟连接。通过在物理连接（connection）上创建多个通道，应用程序可以并发地进行消息传递操作。通道负责发送和接收消息，并执行一些与消息相关的操作，如声明队列、定义交换机和绑定等。通道可以看作是轻量级的会话，通过一个物理连接与RabbitMQ进行交互。
Exchange（交换机）：交换机是消息的接收和转发中心。当消息发送到RabbitMQ时，会通过交换机进行路由。交换机根据其类型和绑定规则，将消息路由到一个或多个队列中。常见的交换机类型包括直连交换机（direct）、主题交换机（topic）、扇形交换机（fanout）和头部交换机（headers）。
Queue（队列）：队列是RabbitMQ用于存储消息的缓冲区。当消息无法立即路由到消费者时，会被存储在队列中，等待消费者来获取和处理。每个队列都有一个唯一的名称，并且按照FIFO（先进先出）的顺序进行消息的投递和消费。
Virtual Host（虚拟主机）：虚拟主机是逻辑上的隔离环境，用于将RabbitMQ服务器划分为多个独立的部分。每个虚拟主机都有自己的交换机、队列、绑定和权限设置。虚拟主机可以帮助不同应用程序或服务之间进行隔离，并提供安全性和资源管理的控制。
Broker（代理）：Broker是RabbitMQ消息队列服务器的实例，负责接收、存储和路由消息。它充当中间人的角色，将生产者发送的消息传递给消费者。一个RabbitMQ实例可以包含多个Broker，每个Broker可以承载多个虚拟主机和队列。
RocketMQ
NameServer（命名服务器）：NameServer是RocketMQ的命名服务组件，用于管理和提供Broker的路由信息。它充当元数据的中心，负责维护Broker的注册信息、Topic的路由信息等。Producer和Consumer在发送和接收消息之前，需要与NameServer进行交互以获取正确的Broker信息。
Controller（控制器）：Controller是RocketMQ的控制器组件，负责协调和管理整个RocketMQ集群的工作。它监控Broker的状态变化，处理集群的扩容和缩容，进行负载均衡等操作。Controller是RocketMQ集群的核心组件之一，确保集群的可靠运行和自动化管理。
Broker（代理）：Broker是RocketMQ的消息存储和处理节点。它负责接收来自Producer的消息，并将其存储在磁盘上。Broker还负责处理Consumer的消息拉取请求，并将消息推送给Consumer进行消费。一个RocketMQ集群可以包含多个Broker，每个Broker负责存储一部分Topic的消息数据。
KafkaMQ
Broker（代理）：Broker是Kafka集群中的一个节点，负责存储和处理消息。每个Broker都是一个独立的Kafka服务器实例。它可以是单独的物理服务器、虚拟机或容器。一个Kafka集群可以包含多个Broker，它们共同协作来实现高可用、高吞吐量的消息传递。
Topic（主题）：Topic是消息的逻辑分类或主题。它是消息发布和订阅的单位。Producer将消息发布到指定的Topic，而Consumer则订阅感兴趣的Topic以接收消息。Topic可以被认为是一个消息的容器，用于将相关的消息进行归类和分组。
Partition（分区）：Topic可以分成一个或多个分区，每个分区是Topic的子集。分区是消息存储和传递的最小单位。每个分区在物理上对应一个独立的日志文件，它们分布在不同的Broker上。分区使得Kafka能够实现水平扩展和并行处理，同时提供更高的吞吐量。每个分区中的消息按照先入先出的顺序进行存储和传递。
3、持久化和可靠性： RabbitMQ：RabbitMQ采用消息持久化机制，消息被持久化到磁盘上，保证消息的可靠性。支持多种消息确认机制和事务，可以保证消息的可靠传递。
RocketMQ：RocketMQ具有强大的持久化和可靠性特性，支持同步刷盘和异步复制机制，能够提供高可靠性的消息传递保证。
Kafka：Kafka以持久化的方式存储消息，消息被写入磁盘上的日志文件。通过分区和复制机制，提供了高可靠性和持久化存储的能力。
4、吞吐量 RabbitMQ：RabbitMQ的吞吐量通常较低，适合中小规模的应用场景。RabbitMQ适用于中小规模的应用场景，通常能够处理万级到十万级的消息量级。它主要侧重于消息的可靠性传递和消息的持久化，对于高吞吐量的需求可能需要进行优化和调整。
RocketMQ：RocketMQ具有较高的吞吐量，可以达到百万级消息的处理能力。它在分布式事务和大规模消息传递场景下表现出色。
Kafka：Kafka是以高吞吐量而著称的消息队列系统，能够处理百万级甚至更高的消息量级。Kafka适用于大规模数据处理、实时流处理和日志处理等高吞吐量场景。
5、响应时间 6、社区及生态 RabbitMQ：RabbitMQ拥有丰富的插件和工具生态系统，具有广泛的开发者社区支持。
RocketMQ：RocketMQ在国内得到广泛应用，具有丰富的阿里巴巴生态系统和社区支持。
Kafka：Kafka拥有活跃的开源社区和广泛的生态系统，被许多大型公司广泛采用。
Github Star
Github Contributors
总的来说：rabbitmq&lt;rocketmq&lt;kafka
7、设计理念 RabbitMQ：RabbitMQ是一个基于AMQP（高级消息队列协议）的开源消息中间件，强调易用性和灵活性，支持多种消息模式和可靠的消息传递。
RocketMQ：RocketMQ是阿里巴巴开源的分布式消息中间件，最初是为了满足阿里巴巴内部的海量数据处理需求而设计的，具有高吞吐量和低延迟的特点。在2016年阿里巴巴将RocketMQ捐赠给了Apache软件基金会。
Kafka：Kafka是由LinkedIn开发的分布式流处理平台，主要用于高吞吐量的实时数据流处理，以持久化的方式存储和处理数据。在2011年Kafka成为Apache开源项目。
8、数据模型 RabbitMQ：RabbitMQ采用队列（Queue）模型，消息被发送到队列中，消费者从队列中接收消息并进行处理。
RocketMQ：RocketMQ采用主题（Topic）和标签（Tag）的模型，消息被发布到主题上，消费者可以根据主题和标签进行订阅和过滤消息。
Kafka：Kafka采用发布-订阅的模型，消息被发布到主题上，多个消费者可以订阅同一个主题并独立消费消息。
9、Web管理工具 RabbitMQ
RabbitMQ Web管理界面：RabbitMQ自带一个Web管理界面，可以通过浏览器访问。它提供了直观的用户界面，可以查看和管理RabbitMQ服务器的各个方面，包括队列、交换机、绑定、用户权限等。默认情况下，Web管理界面运行在15672端口。
RokcetMQ
RocketMQ Console：RocketMQ官方提供了一个Web控制台，称为RocketMQ Console。它提供了一个可视化界面，用于管理和监控RocketMQ集群的各个方面，包括Topic、消费者组、消息查询、性能统计等。你可以通过访问控制台的URL来使用该工具。
Kafka
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d3ec7d1ba8699d2d64eb6227ffbed82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a671ebac77bc285a22e5fb8b17c18c99/" rel="bookmark">
			Mysql案例之GROUP_CONCAT函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，大家好，我是灰小猿，一个超会写bug的程序员！
今天这篇文章记录一个最近开发中遇到的mysql实战场景，觉得还挺典型的，就在此做一下记录。
先看一下举例场景：
mysql中学生表与学科表通过关联表建立关联，学生和学科为多对多的关系，现要求查询学生的数据，并根据学生表引用的多个学科中名称排列在前的学科的名称进行排序，
数据库表结构如下：
CREATE DATABASE school; USE school; CREATE TABLE student ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50), age INT ); CREATE TABLE course ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50), description VARCHAR(128) ); CREATE TABLE student_subject_rel ( id INT AUTO_INCREMENT PRIMARY KEY, student_id INT, course_id INT ); 数据如下：
先来分析一下需求：首先是要求查询学生表中的数据，那么学生表就是作为主表，同时要求对查询结果进行排序，排序的要求是：以学生表中关联的多条学科数据中，学科名称排列在前的那个学科名称为依据对学生数据进行排序，
举个例子来说：
小王选了B课程和C课程
小李选了E课程和F课程
小张选了A课程和D课程
那么最终显示的结果就是：小张、小王、小李
对于这种情况，我们一般想到的是先根据学生表和关联表，找到每一个学生关联的所有学科，然后对每一个学生的学科进行排序，取到排列在第一位的学科，之后再根据第一次排序得到的学科名对学生进行排序，上面这种逻辑固然能够解决问题，但是使用不够简洁。
今天我们介绍一下另一种方法，采用GROUP_CONCAT 函数的方式来解决，只需要对学科完成一次排序即可。
首先我们来看一下GROUP_CONCAT 函数的含义：
GROUP_CONCAT函数 在 MySQL 中，GROUP_CONCAT 函数用于将查询结果按指定顺序连接成一个字符串。通常结合 GROUP BY 子句一起使用，可以将同一组的多个字段值连接成一个字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a671ebac77bc285a22e5fb8b17c18c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261dc07272a11d0561635e50faaae9c7/" rel="bookmark">
			SpringBoot中集成LiteFlow(轻量、快速、稳定可编排的组件式规则引擎)实现复杂业务解耦、动态编排、高可扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 在业务开发中，经常遇到一些串行或者并行的业务流程问题，而业务之间不必存在相关性。
使用策略和模板模式的结合可以解决这个问题，但是使用编码的方式会使得文件太多,
在业务的部分环节可以这样操作，在项目角度就无法一眼洞穿其中的环节和逻辑。
一些拥有复杂业务逻辑的系统，核心业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。
时间一长，维护的成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。
一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。
如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。
实时热变更业务流程，几乎很难实现 。
LiteFlow LiteFlow就是为解耦复杂逻辑而生，如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。
它是一个轻量，快速的组件式流程引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，
并支持热加载规则配置，实现即时修改。
使用LiteFlow，你需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。
这样，所有的组件，就能按照你的规则配置去进行复杂的流转。
LiteFlow官方网站：
LiteFlow
LiteFlow的Gitee地址:
liteFlow: 轻量，快速，稳定，可编排的组件式规则引擎/流程引擎。拥有全新设计的DSL规则表达式。组件复用，同步/异步编排，动态编排，支持超多语言脚本，复杂嵌套规则，热部署，平滑刷新规则等等功能，让你加快开发效率！
LiteFlow的特点：
注：
博客：
霸道流氓气质-CSDN博客
实现 1、SpringBoot中集成LiteFlow
LiteFlow要求的Springboot的最低的版本是2.0。
支持的范围是Springboot 2.X ~ Springboot 3.X。
LiteFlow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能
&lt;dependency&gt; &lt;groupId&gt;com.yomahub&lt;/groupId&gt; &lt;artifactId&gt;liteflow-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.11.4.2&lt;/version&gt; &lt;/dependency&gt; 2、SpringBoot中配置LiteFlow
在你的SpringBoot的application.properties或者application.yml里添加配置
#liteflow规则配置文件位置 liteflow: rule-source: config/flow.el.xml 规则文件的定义
在resources下的config/flow.el.xml中定义规则：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;flow&gt; &lt;chain name="chain1"&gt; THEN(acmp, bcmp, ccmp); &lt;/chain&gt; &lt;/flow&gt; 根据定义的规则，需要定义并实现一些组件，确保SpringBoot会扫描到这些组件并注册进上下文。
import com.yomahub.liteflow.core.NodeComponent; import org.springframework.stereotype.Component; @Component("acmp") public class ACmp extends NodeComponent { @Override public void process() { //do your business System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/261dc07272a11d0561635e50faaae9c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83f3bec44f2220a012149ea5de2c1dd/" rel="bookmark">
			ZooKeeper集群安装后显示ZooKeeper JMX enabled by defaultUsing config: /opt/app/zookeeper-3.4.13/bin/../conf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错显示：
二、解决方向：
从您提供的输出来看，zkServer.sh status 命令无法联系到 ZooKeeper 服务，提示“Error contacting service. It is probably not running.”，这意味着 ZooKeeper 服务可能没有在 master1 节点上启动。
以下是一些解决此问题的步骤：
1. 检查ZooKeeper是否正在运行 使用 ps 命令来检查 ZooKeeper 进程是否正在运行：
ps -ef | grep zookeeper 如果 ZooKeeper 正在运行，您应该能够看到与 ZooKeeper 相关的进程。如果没有任何输出，那么 ZooKeeper 可能没有运行。
2. 启动ZooKeeper服务 如果 ZooKeeper 没有运行，您可以使用以下命令来启动它：
/opt/app/zookeeper-3.4.13/bin/zkServer.sh start 启动后，再次运行 zkServer.sh status 来检查状态。
3. 检查日志文件 如果 ZooKeeper 无法启动，查看日志文件可能会提供有关问题的更多信息。日志文件通常位于您在 zoo.cfg 文件中指定的 dataDir 目录下，并且文件名为 zookeeper.out 或类似的名称。
4. 检查配置文件 确保 zoo.cfg 文件的配置是正确的，并且所有必要的端口和目录都是可访问的。
5. 检查防火墙和网络设置 确保没有防火墙或网络设置阻止 ZooKeeper 服务在集群节点之间通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c83f3bec44f2220a012149ea5de2c1dd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/483/">«</a>
	<span class="pagination__item pagination__item--current">484/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/485/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>