<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c11b3a9afd7ecd064990489db49b30e/" rel="bookmark">
			【redis的大key问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Redis 的过程中，如果未能及时发现并处理 Big keys（下文称为“大Key”），可能会导致服务性能下降、用户体验变差，甚至引发大面积故障。
本文将介绍大Key产生的原因、其可能引发的问题及如何快速找出大Key并将其优化的方案。
一、大Key的定义 在Redis中，大Key是指占用了较多内存空间的键值对。大Key的定义实际是相对的，通常以Key的大小和Key中成员的数量来综合判定，例如：
注意：上述例子中的具体数值仅供参考，在实际业务中，您需要根据Redis的实际业务场景进行综合判断。
二、大Key引发的问题 当Redis中存在大量的大键时，可能会对性能和内存使用产生负面影响，影响内容包括
客户端执行命令的时长变慢。
Redis内存达到maxmemory参数定义的上限引发操作阻塞或重要的Key被逐出，甚至引发内存溢出（Out Of Memory）。
集群架构下，某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡。
对大Key执行读请求，会使Redis实例的带宽使用率被占满，导致自身服务变慢，同时易波及相关的服务。
对大Key执行删除操作，易造成主库较长时间的阻塞，进而可能引发同步中断或主从切换。
上面的这些点总结起来可以分为三个方面：
三、大Key产生的原因 未正确使用Redis、业务规划不足、无效数据的堆积、访问量突增等都会产生大Key，如：
在不适用的场景下使用Redis，易造成Key的value过大，如使用String类型的Key存放大体积二进制文件型数据；
业务上线前规划设计不足，没有对Key中的成员进行合理的拆分，造成个别Key中的成员数量过多；
未定期清理无效数据，造成如HASH类型Key中的成员持续不断地增加；
使用LIST类型Key的业务消费侧发生代码故障，造成对应Key的成员只增不减。
上面的这些点总结起来可以分为五个方面：
四、如何快速找出大Key 要快速找出Redis中的大键，可以使用Redis的命令和工具进行扫描和分析。以下是一些方法：
使用Redis命令扫描键：Redis提供了SCAN命令，可以用于迭代遍历所有键。您可以使用该命令结合适当的模式匹配来扫描键，并在扫描过程中获取键的大小（使用MEMORY USAGE命令）。通过比较键的大小，您可以找出占用较多内存的大键。
使用Redis内存分析工具：有一些第三方工具可以帮助您分析Redis实例中的内存使用情况，并找出大键。其中一种常用的工具是Redis的官方工具Redis Memory Analyzer (RMA)。您可以使用该工具生成Redis实例的内存快照，然后分析快照中的键和它们的大小，以找出大键。
使用Redis命令和Lua脚本组合：您可以编写Lua脚本，结合Redis的命令和Lua的逻辑来扫描和分析键。通过编写适当的脚本，您可以扫描键并获取它们的大小，然后筛选出大键。
现在大部分都是使用的云Redis，其本身一般也提供了多种方案帮助我们轻松找出大Key，具体可以参考一下响应云Redis的官网使用文档。
五、大Key的优化方案 大Key会给我们的系统带来性能瓶颈，所以肯定是要进行优化的，那么下面来介绍一下大Key都可以怎么优化。
5.1 对大Key进行拆分 例如将含有数万成员的一个HASH Key拆分为多个HASH Key，并确保每个Key的成员数量在合理范围。在Redis集群架构中，拆分大Key能对数据分片间的内存平衡起到显著作用。
5.2 对大Key进行清理 将不适用Redis能力的数据存至其它存储，并在Redis中删除此类数据。
注意
Redis 4.0及之后版本：可以通过UNLINK命令安全地删除大Key甚至特大Key，该命令能够以非阻塞的方式，逐步地清理传入的Key。Redis 4.0之前的版本：建议先通过SCAN命令读取部分数据，然后进行删除，避免一次性删除大量key导致Redis阻塞。 5.3 对过期数据进行定期清理 堆积大量过期数据会造成大Key的产生，例如在HASH数据类型中以增量的形式不断写入大量数据而忽略了数据的时效性。可以通过定时任务的方式对失效数据进行清理。
注意：在清理HASH数据时，建议通过HSCAN命令配合HDEL命令对失效数据进行清理，避免清理大量数据造成Redis阻塞。
5.4 特别说明 如果你用的是云Redis服务，要注意云Redis本身带有的大key的优化方案
六、总结 本文介绍了大Key在Redis中的定义以及可能引发的问题。介绍了快速找出大Key的方法以及对于大Key的优化方案。通过合理的优化方案，可以提升Redis的性能和用户体验。
希望本文对您有所帮助。如果有任何错误或建议，请随时指正和提出。
同时，如果您觉得这篇文章有价值，请考虑点赞和收藏。这将激励我进一步改进和创作更多有用的内容。
感谢您的支持和理解！
AI 提问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf4de92de1a2d327bc9c67e1a87bc68/" rel="bookmark">
			基于Python&#43;大数据爬虫&#43;数据可视化大屏的耳机信息的爬取与分析平台设计和实现(2025最新优质项目-系统&#43;源码&#43;部署文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝50W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行前辈交流✌
技术范围：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
主要内容：免费功能设计、开题报告、任务书、中期检查PPT、系统功能实现、代码编写、论文编写和辅导、论文降重、长期答辩答疑辅导、腾讯会议一对一专业讲解辅导答辩、模拟答辩演练、和理解代码逻辑思路。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
大数据项目实战《100套》
Python项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人​
系统介绍： 耳机信息的爬取与分析是一个涉及数据采集、处理和洞察的多步骤过程。通过网络爬虫技术从电子商务网站、论坛和评测页面等来源抓取耳机相关数据，如品牌、价格、用户评分和评论等。利用Python进行数据清洗和预处理，以确保质量并转换为适合分析的格式。采用统计分析和机器学习方法来揭示消费者偏好、市场趋势以及价格与性能之间的关系。通过可视化工具展示分析结果，为制造商、零售商和消费者提供决策支持。整个过程不仅增强了对市场动态的理解，还有助于指导产品开发和营销策略。
本论文将总体对耳机信息的爬取与分析需求，再从不同角度分析具体功能需求，运用python相关技术，采用MySQL数据库，讨论如何设计并实现一个耳机信息的爬取与分析。设计主要从管理员和用户个角色上展开研究，介绍了各个功能模块的实现，并通过系统测试对耳机信息的爬取与分析进行调试，将各个功能的测试结果与期望设计进行逐一比对，找出BUG和欠缺之处，从而进一步优化改进系统。
本套基于python的耳机信息的爬取与分析，希望能让用户通过互联网得到方便而快捷的系统管理体验，在此基础的同时提高工作效益。
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​ 程序操作流程图
首先前端通过Vue和axios发送HTTP请求到后端的登录接口。在后端接收登录请求的Controller会使用`@RequestParam Map&lt;String, Object&gt; params`来接收前端传递的用户参数，用户名和密码。然后后端根据接收到的参数创建一个查询条件封装对象MyBatis的EntityWrapper用于构建查询条件。接着在业务层，调用相应的service方法来查询数据库中是否存在匹配的用户信息。这个查询方法Login()会将前端传递的对象参数传递到后台的DAO层，进行数据库的交互操作。如果存在符合条件的用户，则会返回相关的用户信息。最后在后端控制器中将查询结果封装成响应体，通过`return R.ok().put("data", userService.selecView(ew))`将用户信息返回给前端。前端收到响应后，可以通过调用Vue、ElementUI等组件来渲染登录结果，例如显示用户信息或者跳转到相应的页面。
系统架构设计 系统架构设计是软件开发过程中至关重要的一环。首先是模型层（Model），模型层通常对应着数据库或者其他数据源，它负责与数据库进行交互，执行各种数据操作，并将处理后的数据传递给控制器层。模型层的设计应该简洁清晰，尽可能减少与视图和控制器的耦合，以提高代码的可维护性和可重用性。
其次是视图层（View）通常是通过网页、移动应用界面或者其他用户界面来展示数据。视图层与用户交互，接受用户的输入，并将输入传递给控制器层进行处理。在MVC三层架构中，视图层应该尽量保持简单，只负责数据的展示和用户交互，不涉及业务逻辑的处理，以保持视图层的清晰度和可复用性，最后是控制器层（Controller），每个层都有特定的职责和功能，通过分层架构设计，实现代码模块化，为软件开发提供了一种有效的架构模式。系统架构如图4-1所示。
详细视频演示 请联系我获取更详细的演示视频
功能截图： 在系统前台首页，调用`$route(newValue)`方法监听路由变化，根据当前的路由地址来确定活动菜单的索引，并且根据路由的哈希部分（即URL的`#`后面的部分）来判断是否需要滚动页面到顶部或者某个特定元素的位置。如果不是首页，会将页面滚动到指定元素处，否则滚动到页面顶部。另外通过`headportrait()`方法用于更新组件渲染点前用户头像。在用户登录后，后端返回了新的用户信息，需要及时更新页面上的用户头像信息。
5.1前台功能实现 5.1.1 首页页面功能实现 当人们打开系统的网址后，在这里，人们能够看到系统的导航条，通过点击导航条上的耳机信息、公告资讯、个人中心等功能进入各详细页面进行操作；系统首页界面如图5-1所示：
图5-1 系统首页界面
在注册流程中，用户在Vue前端填写必要信息（如用户名、密码等）并提交。前端将这些信息通过HTTP请求发送到Python后端。后端处理这些信息，检查用户名是否唯一，并将新用户数据存入MySQL数据库。完成后，后端向前端发送注册成功的确认，前端随后通知用户完成注册。这个过程实现了新用户的数据收集、验证和存储；系统注册界面如图5-2所示：
图5-2 系统注册界面
耳机信息：在耳机信息页面的输入栏中输入标题和店名进行查询，可以查看到耳机详细信息，并根据需要进行评论或收藏等操作；如图5-3所示：
图5-3耳机信息详细页面
5.1.2个人中心页面 个人中心：在个人中心页面可以对个人中心、修改密码和我的收藏进行详细操作；如图5-4所示：
图5-4个人中心界面
5.2管理员功能实现 在登录流程中，用户首先在Vue前端界面输入用户名和密码。这些信息通过HTTP请求发送到Python后端。后端接收请求，通过与MySQL数据库交互验证用户凭证。如果认证成功，后端会返回给前端，允许用户访问系统。这个过程涵盖了从用户输入到系统验证和响应的全过程。系统登录界面如图5-5所示：
图5-5系统登录界面
管理员进入主页面，主要功能包括对系统首页、个人中心、用户管理、耳机信息管理、系统管理等进行操作；如图5-6所示：
图5-6管理员主界
用户管理功能实现是在Django后端部分，您需要创建一个新的应用，然后在该应用下创建一个模型（models.py）来定义用户的数据结构，使用Django的ORM来处理与MySQL数据库的交互，包括用户信息的查询、添加或删除等操作。接着，在views.py中编写视图逻辑来处理前端请求，使用Django的URL路由（urls.py）将请求映射到相应的视图函数。对于数据的验证和序列化，可以使用Django的表单或序列化器来实现。在前端Vue.js部分，将创建相应的Vue组件，在这些组件中使用axios或其他HTTP库与Django后端的API进行交互，实现用户信息的查看、修改或删除用户等功能。状态管理可以通过Vuex来维护，比如在store目录下定义用户模块的状态、突变、动作和获取器。如图5-7示：
图5-7用户界面
耳机信息功能实现是在Django后端部分，您需要创建一个新的应用，然后在该应用下创建一个模型（models.py）来定义耳机信息的数据结构，使用Django的ORM来处理与MySQL数据库的交互，包括耳机信息的查询、爬取数据、价格走势、优惠类型、商品评价或删除等操作。接着，在views.py中编写视图逻辑来处理前端请求，使用Django的URL路由（urls.py）将请求映射到相应的视图函数。对于数据的验证和序列化，可以使用Django的表单或序列化器来实现。在前端Vue.js部分，将创建相应的Vue组件，在这些组件中使用axios或其他HTTP库与Django后端的API进行交互，实现耳机信息的查看、修改、查看评论或删除耳机信息等功能。状态管理可以通过Vuex来维护，比如在store目录下定义耳机信息模块的状态、突变、动作和获取器。如图5-8示：
图5-8耳机信息界面
管理员进行爬取数据后可以在看板页面查看到系统简介、价格走势、优惠类型、商品评价、词云图、耳机信息总数等实时的分析图进行可视化管理；看板大屏选择了Echart作为数据可视化工具，它是一个使用JavaScript实现的开源可视化库，能够无缝集成到Java Web应用中。Echart的强大之处在于其丰富的图表类型和高度的定制化能力，使得管理人员可以通过直观的图表清晰地把握耳机的各项统计数据。
为了实现对耳机信息的自动化收集和更新，我们采用了Apache Spark作为爬虫技术的基础。Spark的分布式计算能力使得系统能够高效地处理大规模数据，无论是从互联网上抓取最新的耳机信息，还是对内部数据进行ETL（提取、转换、加载）操作，都能够保证数据的实时性和准确性。
在大数据分析方面，系统采用了Hadoop框架。Hadoop是一个能够处理大数据集的分布式存储和计算平台，它的核心是HDFS（Hadoop Distributed File System）和MapReduce计算模型。通过Hadoop，我们可以对收集到的大量数据进行存储和分析。看板页面如图5-9所示：
图5-9看板详细页面
管理员点击系统管理。在公告资讯页面输入标题进行查询、添加或删除公告资讯列表，并根据需要对公告资讯详细信息进行查看、修改或删除操作；还可以对系统简介、轮播图管理、公告资讯分类和关于我们进行相应操作，如图5-10所示：
图5-10系统管理界面
论文参考： 1 绪 论 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcf4de92de1a2d327bc9c67e1a87bc68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/860c5881a3527385609ec06279035435/" rel="bookmark">
			腾讯云 AI 代码助手攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言关于腾讯云AI代码助手开发环境介绍安装腾讯云AI代码助手vscode 安装插件 腾讯云AI代码助手使用实例案例一： 自定义右键菜单案例二： 代码优化案例三：对错误代码进行修改 获得的帮助与提升建议结语 前言 在人工智能技术的飞速发展下，大型模型和生成式AI应用如雨后春笋般涌现，AI编程助手亦在此浪潮中迅速成长和成熟。继腾讯、字节跳动相继宣布其AI智能开发工具正式上线之后，百度和阿里巴巴也于去年10月相继推出了AI编程助手的正式版本。至此，我国互联网行业的四大巨头——百度、阿里巴巴、腾讯、字节跳动——均已推出了各自的AI编程助手。本文将向您详细介绍并指导如何使用腾讯云AI代码助手，助您编写更加优雅的代码，轻松摆脱代码审查的困扰，显著降低bug发生率。
关于腾讯云AI代码助手 腾讯云自研的一款编程提效辅助工具，以插件形式安装到编辑器（VS Code 或者 JetBrains 系列 IDE）中辅助编程；可提供：自动补全代码、根据注释生成代码、代码解释、生成测试代码、转换代码语言、技术对话等能力。
开发环境介绍 在本次开发案例中，我使用的是mac操作系统，开发IDE为Visual Studio Code，编程语言为JavaScript，前端框架为Vue.js。腾讯云AI代码助手是基于混元代码大模型的辅助编码工具，腾讯云AI代码助手6大特性为开发进行保障护航，支持20多种开发语言，为开发提效增质。
安装腾讯云AI代码助手 点击链接 ， 在产品栏目或者开发者栏目中找到腾讯云 AI 代码助手，点击免费使用，即可查看产品文档，以及插件安装的不同方式，接下来我们以vscode 为例进行安装。
vscode 安装插件 打开vscode 开发工具在扩展栏中搜索 tencent 图腾讯ai助手
找到 图腾讯ai助手 中标识的 插件（Tencent Cloud AI Code Assistant）点击安装 安装成功之后，在IDE 的左侧栏目中会出现一个类似于对话框的icon , 我们可以直接将其点开， 进行AI 对话，下图分别是如何使用以及我提出的一个冒泡排序所给的答案。 从上图中我们可以了解到如和在ide 中安装腾讯AI助手，以及基础的问答使用， 接下来我们将会开启一个新的篇章–工作中如何使用腾讯云AI代码助手
腾讯云AI代码助手使用实例 接下来我们来编写几个小案例，深度的了解一下如何使用腾讯云AI代码助手
案例一： 自定义右键菜单 第一步我们在输入框中输入需求文案 ： vue3 中实现自定义右键菜单功能
步骤二：根据腾讯AI 给出的思路以及代码进行编写：
步骤三：效果实现， 根据ai给出的代码进行编写，效果如下图所示：
当我点击左侧画布的位置时，会将具体的位置打印出来，
同时提示的代码中也给出了如果想要展示菜单内容应该如何去做，详细的可以参考以下代码：
&lt;!-- * @Description: * @Author: 若城 * @Date: 2024-08-04 22:35:50 * @LastEditTime: 2024-08-04 23:02:29 --&gt; &lt;template&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/860c5881a3527385609ec06279035435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a7c5630cbf41f5b0dd3f3ceac917e8/" rel="bookmark">
			大数据-80 Spark 简要概述 系统架构 部署模式 与Hadoop MapReduce对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（已更完）Spark（新开的坑！正在更新！） 章节内容 上节我们完成了如下的内容：
Kafka集群监控方案JConsoleKafka EagleJavaAPI获取集群指标
简单介绍 在技术的不断迭代中，一路发展，三代技术引擎：
MapReduce 昨天Spark 今天Flink 未来 MapReduce和Spark都是类MR的处理引擎，底层原理非常相似。
什么是Spark Spark的发展历程如下图：
Spark特点 速度快，与MapReduce相比，Spark基于内存运算要快100倍以上，基于硬盘运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效的处理流数据使用简单，Spark支持Scala、Java、Python、R的API，还支持超过80种算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的Shell，可以非常方便的在这些Shell中使用Spark集群来验证解决问题的方法通用性好，Spark提供了统一的解决方案，Spark可以用于批处理、交互式查询（SparkSQL）、实时流处理（SparkStreaming）、机器学习（SparkMLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝衔接。Spark统一解决方案非常具有吸引力，企业想用统一的平台去处理遇到的问题，减少开发和维护人力的成本和部署平台的物力成本。兼容性好，Spark可以非常方便的和其他开源的产品进行融合，Spark可以使用YARN、Mesos作为它的资源管理和调度器。可以处理所有Hadoop支持的数据，包括HDFS、HBase、Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要任何的数据迁移就可以使用Spark。Spark也可以不依赖于其它第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人可以非常容器的部署和使用Spark。 Spark与Hadoop 狭义上 从狭义上看：Hadoop是一个分布式框架，由存储、资源调度、计算三部分组成
Spark是一个分布式计算引擎，是由Scala编写的计算框架，基于内存的快速、通用、可扩展的大数据分析引擎。
广义上 从广义上看：Spark是Hadoop生态中不可或缺的一部分。
MapReduce不足 表达能力有限磁盘IO开销大延迟高：任务之间有IO开销，在前一个任务完成之前，另一个任务无法开始。 相对于Spark，Spark的设计要更高效，Spark在借鉴MapReduce优点的同时，很好的解决了MapReduce所面临的问题：
两者对比 Spark的计算模式也属于MapReduce，是对MR框架的优化。
数据存储结构：MapReduce是磁盘HDFS，Spark是内存构建的弹性分布式数据集RDD编程范式：Map+Reduce表达力欠缺，Spark提供了丰富操作使数据处理代码很短运行速度：MapReduce计算中间结果存磁盘，Spark中间结果在内存中任务速度：MapReduce任务以进程，需要数秒启动，Spark是小数据集读取在亚秒级 实际应用 批量处理（离线处理）：通常时间跨度在分钟到小时交互式查询：通常时间跨度在十秒到数十分钟流处理（实时处理）：通常跨度在数百毫秒到数秒 在面对上述的三个场景中，我们通常的解决方案是：
MapReduceHiveImpala 或 Storm 但是对应的也带来一些新的问题：
不同场景之间输入输出数据无法做到无缝共享，通常需要进行数据格式的转换、不同的软件需要不同的开发和维护团队，带来了较高的维护和使用成本比较难以通一个集群中的各个系统进行统一的资源协调和分配 系统架构 Spark运行包括如下：
Cluster ManagerWorker NodeDriverExecutor ClusterManager ClusterManager 是集群资源的管理者，Spark支持3中集群部署模式：
StandaloneYARNMesos WorkerNode WorkerNode是工作节点，负责管理本地资源。
Driver Program 运行应用的 main() 方法并且创建了 SparkContext。由ClusterManager分配资源，SparkContext发送Task到Executor上执行。
Executor Executor在工作节点上运行，执行Driver发送的Task，并向Driver汇报计算结果。
部署模式 Standalone 独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖其他任何的资源管理系统，从一定程度上说，该模式是其他模式的基础Cluster Manager： MasterWorkerNode：Worker仅支持粗粒度的资源分配方式 SparkOnYARN YARN拥有强大的社区支持，且逐步成为大数据集群资源管理系统的标准在国内生产环境中运用最广泛的部署模式SparkOnYARN 支持的两种模式：yarn-cluster（生产环境），yarn-client（交互和调试）Cluster Manager：ResourceManagerWorkNode：NodeManager仅支持粗粒度的资源分配方式 SparkOnMesos 官方推荐模式，Spark开发之初就考虑到了支持MesosSpark运行在Mesos上会更加的灵活，更加自然ClusterManager：MesosMasterWorkNode: MesosSlave支持粗粒度、细粒度的资源分配方式 粗粒度模式 Coarse-grained Mode：每个程序的运行由一个Driver和若干个Executor组成，其中每个Executor占用若干资源，内部可以运行多个Task。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中需要一直占用着这些资源，即使不用，最后程序运行结束后，自动回收这些资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5a7c5630cbf41f5b0dd3f3ceac917e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f71dfb284059cae5f676c257333f81/" rel="bookmark">
			2024年第四届智慧城市与绿色能源国际会议（ICSCGE 2024）即将召开！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四届国际智慧城市与绿色能源会议（ICSCGE 2024）将于2024年12月10-13日在澳大利亚悉尼举行，会议旨在汇聚来自世界各地的专家学者，共同讨论智慧城市框架及其在可持续发展和绿色能源领域的最新进展和创新成就。ICSCGE是一个致力于探索智慧城市和绿色能源领域的创新技术和可持续解决方案的首要会议。会议为研究人员、学者、行业专业人士提供了一个交流思想、展示最新研究成果、讨论建设更智能、更可持续城市所面临挑战和机遇的平台。
ICSCGE 2024将包含大会报告、分论坛、专题讨论和研讨会，重点关注前沿技术、最佳实践和政策，旨在打造更环保、更高效的城市环境。诚邀您参与ICSCGE 2024，共同塑造智慧城市，展望绿色能源未来。
会议官网：www.icscge.orghttp://www.icscge.org
组织单位：
征稿主题：
包含但不限于以下主题：
1. 智慧城市规划与设计
2. 智能交通与物流管理
3. 绿色建筑与智慧区域
4. 环境监测与数据分析
5. 智能电网与智能能源系统
6. 可再生能源发电和储能技术
7. 电力和碳排放市场、创新商业机制、政策/法规方面
更多内容前往会议网站查看：ICSCGE 2024
投稿须知:
【全文投稿】
请根据以下要求准备全文：
▪文件必须为全英文，双栏且不超过五页（不包括参考文献）。
▪投稿文件需为pdf或doc格式.
▪论文必须至少有4页，包括正文、参考文献、表格和图表。请按照以下论文模板进行准备：https://icscge.org/conference-template-letter.docx
▪提交到ICSCGE 2024的论文不能已在其他存档会议或期刊上发表或审稿。（在arXiv上发布的论文不违反此规定，只要提交的论文没有引用）。
提交论文到会议意味着如果论文被接收，至少一名作者将完成常规注册并参加会议并进行报告。对于未出席的作者，论文将不被出版。
【摘要投稿】
若您想在会议上做口头报告或海报展示，但无出版意愿， 您可仅进行摘要投稿，但摘要不会出版。
【投稿链接】https://easychair.org/conferences/?conf=icscge2024
会议出版及检索：
投稿文章将经过严格的审稿过程，最终录用并完成注册和报告的文章将由IEEE出版至ICSCGE 2024会议论文集，由 IEEE Xplore收录，并送检Ei Compendex和Scopus。
会议组委会：
【Conference Chairs】
邱靖, 悉尼大学，澳大利亚
文福栓，浙江大学，中国
【Conference Co-chairs】
Ahmed Abu-Siada,，科廷大学，澳大利亚
S.N. Singh，印度理工学院坎普尔分校，印度
齐冬莲，浙江大学，中国
【Organizing Committee Chairs】
林振智，浙江大学，中国
赵俊华，香港中文大学（深圳），中国
Guo Chen，新南威尔士大学，澳大利亚
Farhad Shahnia,莫道克大学，澳大利亚
和萍，郑州轻工业大学，中国
【Technical Program Committee Chairs】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1f71dfb284059cae5f676c257333f81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36ccde6a2595e6506e1dac9391a8b77/" rel="bookmark">
			Python爬虫——爬取bilibili中的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取bilibili中的视频 本次爬取，还是运用的是requests方法
首先进入bilibili官网中，选取你想要爬取的视频，进入视频播放页面，按F12，将网络中的名称栏向上拉找到第一个并点击，可以在标头中，找到后续我们想要的一些信息。
爬取视频的步骤大致分为
1、UA伪装2、获取url3、发送请求4、获取响应的数据5、数据解析 获取存放视频和音频数据的"window.playinfo"文本内容分别获取视频和音频的url将获取到的视频和音频数据存放在两个不同的文件中 UA伪装
找到Cookie并复制—&gt;用户登陆此网站的个人Cookie信息，每个人的都不同找到Referer并复制—&gt;每个网站的防盗链找到User-Agent并复制—&gt;标头的最下面
# UA伪装 head = { "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0" # 防盗链子 , "Referer":"https://www.bilibili.com/" , "Cookie":"CURRENT_FNVAL=4048; buvid3=BE2D386A-BBCB-E06E-8C2B-F5223B4C8BC517591infoc; b_nut=1721567317; _uuid=67165DF10-7B77-BDE8-3C63-732C2FCAF4D520375infoc; enable_web_push=DISABLE; buvid4=0245F01B-6C4B-CD5A-2EC5-BC060EC0777D18433-024072113-zRTpkL0r94scQqxGfSYKhQ%3D%3D; home_feed_column=5; header_theme_version=CLOSE; rpdid=|(Y|RJRR)Y~0J'u~kulY~Rkk; DedeUserID=1611307689; DedeUserID__ckMd5=b0865dba0b3ced5b; buvid_fp_plain=undefined; is-2022-channel=1; b_lsid=D8542F24_191412D93C0; bsource=search_bing; bmg_af_switch=1; bmg_src_def_domain=i1.hdslb.com; browser_resolution=1659-943; bili_ticket=eyJhbGciOiJIUzI1NiIsImtpZCI6InMwMyIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MjM2MzQ1OTMsImlhdCI6MTcyMzM3NTMzMywicGx0IjotMX0.Ox8rnEpQH5i1H_wQfH2z5CzZC0y8PlqQCy1KVa8XEfQ; bili_ticket_expires=1723634533; SESSDATA=f567fef6%2C1738927393%2C5d207%2A82CjAh2pSUKwDLr1XiI6ncU5B6NXEfWKS7ES6mDC8yGxM6aT3-BTdvK0KAlYpMhCXtEXgSVkl2aTlQWUNacTZOZ0ZNXzJwZ21QT2ozMXFXcWtFc1FpNnBIWlNWbml2Y3BxNV80bUNMZTBVN1dyb3h0STU1ZklDM0MwckJvanRmTmNkeTBFcW5qYl9RIIEC; bili_jct=8d788bcb503d69ba2ded7dfbb53f6e58; sid=71po5kkf; fingerprint=0c7279b7c69b9542a76b8d9df9b7872a; buvid_fp=BE2D386A-BBCB-E06E-8C2B-F5223B4C8BC517591infoc; bp_t_offset_1611307689=964382000909647872" } 获取url
可以在标头中看到请求URL
# 指定url 自定义一个变量接收 url = "https://www.bilibili.com/video/BV17w4m1e7PT/?spm_id_from=333.1007.tianma.1-1-1.click&amp;vd_source=2a6e427465a2f829272f5863986dfa80" 发送请求
可以在标头中看到请求方式，这里的请求方式是GET方法
# 发送请求，这里的请求方式是get方法 response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36ccde6a2595e6506e1dac9391a8b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daeb468caa48eae7d003a0b258968ce4/" rel="bookmark">
			大数据-79 Kafka 集群模式 集群监控方案 JavaAPI获取集群指标 可视化监控集群方案： jconsole、Kafka Eagle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（正在更新…） 章节内容 上节我们完成了如下的内容：
Kafka 集群模式搭建Kafka 集群模式的应用场景实机云服务器搭建 监控度量指标 Kafka使用Yammer Metrics在服务器和Scala客户端中报告指标，Java客户端使用Kafka Metrics，它是一种内置的度量标准注册表，可最大程度的减少拉入客户端应用程序的传递依赖项。
两者都通过JMX公开指标，并且可以配置为使用可插拔的统计报告器报告统计信息，以连接到你的监控系统中。
JMX export KAFKA_JMX_OPTS="-Dcom.sun.management.jmxremote \ -Dcom.sun.management.jmxremote.port=9999 \ -Dcom.sun.management.jmxremote.authenticate=false \ -Dcom.sun.management.jmxremote.ssl=false \ -Djava.rmi.server.hostname=${服务器的IP,尽量写IP,不要hostname或者域名}" 接着我们启动Kafka：
kafka-server-start.sh /opt/servers/kafka_2.12-2.7.2/config/server.properties JConsole 在本机上启动 jconsole 服务，我们运行如下指令：（本机要有JDK）
启动窗口如下图所示：
我们输入Kafka的地址和端口：
连接成功之后页面如下图：
我们选择 MBean 选项卡：
可以看到对应的数据情况：
详细监控指标 http://kafka.apache.org/10/documentation.html#monitoring
OS监控项 Broker指标 Producer和Topic指标 Consumer指标 获取监控指标 我们可以通过编程的方式来获取到Kafka的指标信息：
编写代码 package icu.wzk.kafka; import javax.management.MBeanServerConnection; import javax.management.ObjectInstance; import javax.management.ObjectName; import javax.management.remote.JMXConnector; import javax.management.remote.JMXConnectorFactory; import javax.management.remote.JMXServiceURL; import java.util.Iterator; import java.util.Set; public class JMXMonitorDemo { public static void main(String[] args) throws Exception { String jmxServiceUrl = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daeb468caa48eae7d003a0b258968ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df9095e3cf53fa1b9ffe1bf8d793909/" rel="bookmark">
			【大数据】重塑时代的核心技术及其发展历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐇明明跟你说过：个人主页
🏅个人专栏：《大数据前沿：技术与应用并进》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、什么是大数据
2、大数据技术诞生的背景
二、大数据技术的发展历程
1、早期阶段（1960s-1980s）
2、互联网时代的到来（1990s-2000s）
3、大数据概念的提出与技术体系的形成（2000s-2010s）
4、大数据生态系统的扩展与成熟（2010s-至今）
5、关键技术的里程碑
三、大数据关键技术
1、数据采集
2、数据存储
3、数据分析
一、引言 1、什么是大数据 大数据（Big Data）是指无法通过传统的数据处理技术和工具在合理的时间范围内高效处理、存储和分析的数据集合。它通常具有以下几个核心特征，也被称为大数据的“5V”特征：
1. Volume（数据量）
规模巨大：大数据的核心特征之一是其数据量庞大，通常以TB（太字节）、PB（拍字节）甚至EB（艾字节）为单位。传统的数据管理工具和数据库难以处理如此规模的数据。 2. Velocity（速度）
生成和处理速度快：大数据不仅涉及庞大的数据量，还要求快速的数据生成、传输和处理。实时数据处理需求增加，例如实时流媒体、实时交易数据分析等，都要求能够在毫秒或秒级的时间内处理数据。 3. Variety（多样性）
数据类型多样：大数据不仅包括结构化数据（如表格数据），还包括大量的非结构化数据（如文本、图像、视频）和半结构化数据（如JSON、XML）。这些数据格式各异，来源广泛，需要不同的处理和分析技术。 4. Veracity（真实性）
数据真实性和准确性：大数据中包含的信息可能来源复杂，存在噪声、错误或不一致性，因此在处理大数据时，数据的质量、可信度和准确性是一个重要的挑战。 5. Value（价值）
数据潜在价值巨大：大数据本身并不意味着有价值，真正的价值在于通过对大数据的分析和挖掘，能够发现有意义的模式、趋势和相关性，从而为企业和组织提供决策支持、优化业务流程和创造新的商业机会。 2、大数据技术诞生的背景 大数据技术的诞生背景可以追溯到信息化时代的发展，特别是随着互联网、移动设备、社交媒体、物联网（IoT）等技术的普及，数据生成量呈现爆炸式增长。这种数据的爆炸性增长带来了巨大的挑战和机遇，推动了大数据技术的诞生。
1. 数据量的急剧增长
互联网普及：互联网的广泛应用使得全球各地的人们可以生成和访问大量的数据，包括网页、电子邮件、社交媒体内容、视频等。移动设备和物联网：智能手机、传感器、智能家居设备等不断生成数据，从位置数据、传感器数据到使用模式等。这些数据的数量远超传统数据源。 2. 数据类型的多样性
非结构化和半结构化数据：除了传统的结构化数据（如数据库中的表格数据），非结构化数据（如文本、图像、视频）和半结构化数据（如XML、JSON）成为重要的数据类型，需要新的技术来处理和分析。实时数据处理需求：许多应用场景要求对数据进行实时处理和分析，例如金融市场、网络安全监控、物联网设备管理等。 3. 传统数据处理技术的局限性
存储和处理能力不足：传统数据库技术和数据仓库在处理大规模数据（TB、PB级别）时遇到了瓶颈，无论是在存储、计算能力还是查询性能上，都难以应对新的需求。扩展性差：传统数据处理技术通常难以横向扩展，难以在多台机器上高效分布式处理大规模数据。 4. 计算能力和存储技术的进步
分布式计算框架：如Hadoop、Spark等分布式计算框架的出现，提供了处理海量数据的能力。这些框架能够在大规模集群上并行处理数据，显著提高了数据处理效率。云计算：云计算的兴起为大数据处理提供了弹性、高效的计算资源，用户可以根据需求动态调整计算和存储资源。 二、大数据技术的发展历程 1、早期阶段（1960s-1980s） 数据管理和数据库的诞生：20世纪60年代，计算机的普及促使数据量逐步增加，早期的数据库管理系统（DBMS）如IBM的IMS、Oracle的关系数据库开始发展。数据管理技术逐渐成熟，关系数据库成为数据存储和查询的主要方式。结构化数据的存储与管理：随着企业信息化的推进，结构化数据（如财务报表、库存管理等）成为数据库的主要处理对象。SQL（Structured Query Language）在20世纪70年代被开发出来，成为关系数据库操作的标准语言。 2、互联网时代的到来（1990s-2000s） 数据爆炸的开始：随着互联网的普及和电子商务的发展，数据量迅速增加。传统的关系数据库在处理海量数据时遇到了瓶颈，特别是在处理非结构化数据（如文本、图像、视频）方面。NoSQL数据库的兴起：为应对大规模数据和分布式存储需求，NoSQL数据库（如Cassandra、MongoDB、HBase）在2000年代逐渐兴起，这类数据库设计用于处理高并发读写和水平扩展。 3、大数据概念的提出与技术体系的形成（2000s-2010s） 大数据的定义与特征：在2000年代中期，“大数据”概念逐渐成形，通常用4V（Volume, Velocity, Variety, Veracity）来描述，即数据量巨大、速度快、种类多、真实性复杂。Hadoop的诞生：2006年，Apache Hadoop项目正式启动。Hadoop是基于Google的MapReduce论文的开源实现，提供了分布式存储（HDFS）和分布式计算（MapReduce）能力，成为大数据处理的基础框架。数据仓库与BI（商业智能）：传统数据仓库技术（如Teradata、Informatica）与BI工具（如Tableau、Power BI）开始与大数据技术结合，支持对大规模数据的深度分析和可视化。 4、大数据生态系统的扩展与成熟（2010s-至今） 实时数据处理与流计算：随着物联网、社交媒体和在线交易等实时数据源的普及，实时数据处理需求激增。Apache Kafka、Apache Storm、Apache Flink等流处理框架应运而生，支持实时数据的采集、传输和处理。云计算与大数据：云计算平台（如AWS、Google Cloud、Microsoft Azure）提供了大规模数据处理和存储的基础设施，极大地降低了企业部署大数据解决方案的门槛。Hadoop生态系统中的技术如Hive、Spark等在云环境中得到广泛应用。人工智能与机器学习的融合：大数据技术与AI/ML技术的结合成为新的趋势，通过大规模数据训练机器学习模型，从而实现精准预测和智能决策。深度学习框架（如TensorFlow、PyTorch）在处理大数据集方面展现出巨大潜力。数据湖和多模分析：为了处理结构化、半结构化和非结构化数据，数据湖（Data Lake）概念被提出，允许存储多种类型的数据并进行多模分析。 5、关键技术的里程碑 MapReduce（2004）：Google发表的MapReduce论文奠定了大规模分布式计算的基础。Hadoop 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7df9095e3cf53fa1b9ffe1bf8d793909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12144d63edd6162ee65aea783f46341b/" rel="bookmark">
			如何用Langchain封装自定义语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了将一个自定义的语言模型集成到 LangChain 中，你需要创建一个类来继承 langchain_core.language_models.llms.LLM 类，并实现特定的方法。下面是一些关键点，可以帮助你构思如何集成你的语言模型：
继承 LLM 类 你需要从 langchain_core.language_models.llms.LLM 类继承，并且至少实现 _call 方法。这个基类提供了一些通用的功能，比如回调管理等。
实现 _call 方法 这是最重要的方法，它定义了如何调用你的语言模型来生成文本。方法签名如下：
def _call( self, prompt: str, stop: Optional[List[str]] = None, run_manager: Optional[CallbackManagerForLLMRun] = None, **kwargs: Any, ) -&gt; str: prompt: 用户提供的文本提示。stop: 一个可选的字符串列表，这些字符串如果出现在生成的文本中，将会停止生成过程。run_manager: 一个可选的回调管理器，用于跟踪和报告生成过程中的状态。**kwargs: 其他可变的关键字参数，这些参数可能会被模型使用。 其他常用方法和属性 _llm_type 属性: 返回一个字符串标识你的语言模型的类型。_identifying_params 属性: 返回一个字典，其中包含识别该模型实例的重要参数。_check_validity_of_input 方法: 用于检查输入的有效性，这是一个可选的方法。 示例 这里是一个简化的示例，展示如何创建一个自定义的 LLM 类：
from langchain_core.language_models.llms import LLM from typing import Any, Optional, List, Mapping import requests class CustomLLM(LLM): """Custom LLM implementation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12144d63edd6162ee65aea783f46341b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5f28271f4f3f308b168e543c010bb9/" rel="bookmark">
			打造高效存储与访问体验：NFS共享携手Nginx负载均衡，赋能企业级数据流通与性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：我是团团儿，是一名专注于云计算领域的专业创作者，感谢大家的关注 座右铭： 云端筑梦，数据为翼，探索无限可能，引领云计算新纪元 个人主页：团团-CSDN博客 目录:
前言：
为什么会扩展服务器阵容？
实验目标：
实验拓扑：
Lb 192.168.8.5的配置
1.rpm安装nginx
2.进入到mnt下的nginx下，并进行安装
3.启动服务
4.删除默认配置文件
5.创建新的配置文件并写入内容
6.重启服务并查看端口
Web1 192.168.8.6的配置
1.rpm安装nginx
2.进入到mnt下的nginx下，并进行安装
3.启动服务
4.复制wordpress安装包，到虚拟机/，解压并赋权
5.删除默认配置文件并创建虚拟主机配置文件
6.重启服务，并将网页根目录拷贝到php8.8上
7.将/etc/nginx 及网页根目录拷贝到8.7上
8.将网页根目录拷贝到nfs8.10上
9.查看并挂载
Php 192.168.8.8的配置
1.192.168.8.6安装php
2.启动php服务，设置服务自启,并查看端口
3.修改php服务器的配置文件
4.重启php服务
Mysql 192.168.8.9的配置
1.192.168.8.9安装mysql
2.创建数据库和用户
客户端进行访问
Web2 192.168.8.7的配置
1.rpm 安装nginx
2.进入到mnt下的nginx下，并进行安装
3.安装完成后启动服务
4.删除默认配置文件
5.拷贝好之后重启服务
客户端进行访问
Nfs 192.168.8.10的配置
1.查看是否有nfs
2.创建共享目录，并设置永久权限
3.重启服务
前言： 随着业务的增长，公司需要更多的服务器来支持用户访问和应用程序的运行。 NFS共享可以解决文件存储的问题，而nginx负载均衡可以提高Web服务器的性能和可靠性。
在实际应用中，NFS共享和nginx负载均衡的组合可以带来很多好处。 比如，NFS共享可以实现跨主机的文件同步和备份，避免了因单点故障导致的数据丢失。 同时，nginx负载均衡可以应对高峰期的流量压力，保证网站的稳定访问。
为什么会扩展服务器阵容？ 通常来说，增加服务器是为了提升数据处理能力、支持更多用户访问以及确保服务的稳定性和可靠性。当业务不断增长、数据量激增时，现有的服务器可能无法满足需求。这时，就需要扩充硬件资源以维持高效的运营。
仅仅增加服务器并不能解决问题。 我们还需要通过实现NFS(Network File System)共享来提高文件访问效率。 NFS允许在不同主机之间通过网络共享文件系统，使得多台机器可以共享同一目录或文件。 这对于处理大量数据的企业来说非常有用，因为它可以提高文件访问效率并减少重复数据存储的需求。
我们还可以使用nginx进行负载均衡。nginx是一个高性能的HTTP和反向代理服务器，可以用来做负载均衡器。 它可以将请求分配到多个服务器上，从而增强Web服务器的处理能力和可靠性。 使用nginx负载均衡器后，即使某台服务器宕机，其他服务器也可以继续提供服务，保证了系统的高可用性和稳定性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5f28271f4f3f308b168e543c010bb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce99c4e7434922dc349310ac7f5b9746/" rel="bookmark">
			学习C语言第十五天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一项 C 字符串 字符串实际上是使用空字符 \0 结尾的一维字符数组，\0 是用于标记字符串的结束。
空字符（Null character）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。
以下是 C/C++ 中定义的字符串的内存表示：
不需要把 null 字符放在字符串常量的末尾。在初始化数组时，自动把 \0 放在字符串的末尾。
eg： #include &lt;stdio.h&gt;
int main ()
{
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
printf("ZH_edifier: %s\n", site );
return 0;
}
ZH_edifier: RUNOOB
有大量操作字符串的函数： 序号函数 &amp; 目的1strcpy(s1, s2);
复制字符串 s2 到字符串 s1。2strcat(s1, s2);
连接字符串 s2 到字符串 s1 的末尾。3strlen(s1);
返回字符串 s1 的长度。4strcmp(s1, s2);
如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。5strchr(s1, ch);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce99c4e7434922dc349310ac7f5b9746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915cdddfe413b6026d68b7acf69787f5/" rel="bookmark">
			代码规范 —— Redis 开发规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT-BLOG-CN
一、开发规范 【1】弱依赖检查与线下确认：Redis必须是弱依赖，即Redis宕机不影响业务。包括超时检查。
【2】是否当存储使用检查：Redis不能作为存储设备来使用，只能作为缓存或状态等场景来使用。存储优先使用本地缓存。
【3】超时时间检查与线下确认：Redis使用需要设置超时时间。如果超时，对应的策略和方案是什么。
【4】无状态检查：Redis同一个Key不能被不同的应用，不同的场景使用。谁生产，谁消费的原则。
【5】同步锁检查：优先使用集团框架提供的分布式锁。
【6】Key检查：Key的唯一性是否存在明显问题，与其他场景和应用的重名的可能。Key的长度，尽可能的小于128字节，禁止超过1024简洁性
保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视可读性和可管理性 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id不要包含特殊字符，反例：包含空格、换行、单双引号以及其他转义字符需要规范（car+应用名+业务名+具体id）
【7】审批记录检查：是否已经在审批记录conf完整记录，包括审批人。
二、场景使用 合理使用数据结构： Redis支持的数据库结构类型较多：字符串String，哈希Hash，列表List，集合Set，有序集合Sorted Set, Bitmap, HyperLogLog和地理空间索引geospatial redis命令
需要根据业务场景选择合适的类型，常见的如：
【1】String可以用作普通的K-V、计数类；
【2】Hash可以用作对象如商品、经纪人等，包含较多属性的信息；
【3】List可以用作消息队列(不推荐)、粉丝/关注列表等；
【4】Set可以用于推荐；
【5】Sorted Set可以用于排行榜等；
三、键值设计 key设计：
【1】可读性和可管理性【建议】
☑️ 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔。
☑️ 应用名:表名:id。
【2】简洁性，key长度适中【建议】
☑️ 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视。
eg：user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。
【3】不要包含特殊字符【强制】
☑️ 禁止包含特殊字符如空格，换行，单双引号，其他转义字符。
【4】Key个数限制【强制】
☑️ 由于Redis Rehash机制，实例Key数量达到一定值rehash操作时，需要有一定量空闲内存资源，如key达到134217728，rehash需要有2gb空闲内存资源，达到268435456时，rehash需要有4gb空闲内存资源。如果没有组够的内存资源rehash时会发生Key剔除（数据丢失/程序超时/甚至引起切换）。
单实例key个数达到134217728已经很大了，实例元素过大对于后续分析rdb遍历大key时会非常耗时。
四、value设计 【1】拒绝bigkey(防止网卡流量、慢查询)
☑️ 防止网卡流量、慢查询，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。
☑️ 非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会出现在慢查询中(latency可查))
☑️ credis页面，群集所有者可以通过unlink异步清理或小批量迭代清理（或提事件给DBA来处理)
【2】一定要设置过期时间，当实例写满，根据volatile-lru淘汰老的数据
☑️ redis只是缓存，不能当成数据库来用。不设置过期时间，redis实例大小会一直无限增长，会出现机器内存耗尽、故障恢复耗时特别长等问题。
☑️ 建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime(该命令返回的是当前键从上一次访问到现在经过的时间（单位，秒）)
☑️ DBA会定期对redis集群中过期时间超过1年的数据做告警处理。
五、命令使用 【1】禁用KEYS正则匹配，可用SCAN代替
☑️ 禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。
【2】O(N)命令关注N，控制集合元素尽可能小
☑️ hgetall/lrange/smembers/zrange等在集合包含元素个数较少的情况下使用。
☑️ 若规模较大，有遍历需求，可用HSCAN/SSCAN/ZSCAN渐进式遍历。
【3】合理使用select
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915cdddfe413b6026d68b7acf69787f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd8b7ece7b709ca38b581e25018cf79d/" rel="bookmark">
			【微服务】Spring Cloud Alibaba 的介绍以及和主要功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言主要功能1. **服务发现与注册**2. **分布式配置管理**3. **流量管理与熔断限流**4. **消息驱动**5. **分布式事务管理**6. **远程调用（RPC）**7. **服务网关**8. **对象存储**9. **全链路跟踪**10. **阿里巴巴中间件支持**11. **高可用与容错** Spring Cloud Alibaba 的应用场景1. **电商平台**2. **金融科技**3. **内容分发与媒体**4. **物联网 (IoT)**5. **在线教育**6. **企业级应用**7. **跨境电商与国际业务** 有了clund为什么还要alibaba?1. **特定于阿里巴巴生态系统的支持**2. **中国市场的适应性**3. **高级功能与增强**4. **更好的性能和扩展性**5. **社区与支持**6. **全栈云解决方案** 总结强烈推荐专栏集锦写在最后 引言 SpringCloud Alibaba 是 Spring Cloud 生态系统的一部分，提供了对阿里巴巴中间件的整合支持，帮助开发者在 Spring Cloud 微服务架构中更方便地使用阿里巴巴的基础设施和服务。
主要功能 SpringCloud Alibaba 提供了一系列强大的功能，帮助开发者在微服务架构中更轻松地使用阿里巴巴的中间件和云服务。以下是其主要功能：
1. 服务发现与注册 Nacos：
提供服务注册与发现的能力，支持 DNS 和 RPC 服务发现。Nacos 可以动态地管理服务实例，自动处理服务的上下线和负载均衡。
2. 分布式配置管理 Nacos：不仅支持服务发现，还提供配置管理功能。开发者可以通过 Nacos 集中管理和动态刷新应用配置，支持配置的分环境管理。 3. 流量管理与熔断限流 Sentinel：
用于微服务的流量控制，包括限流、熔断、隔离、系统负载保护等功能。Sentinel 可以帮助应对突发流量和保障服务的稳定性。
4. 消息驱动 RocketMQ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd8b7ece7b709ca38b581e25018cf79d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644dbd154d9b8cfb36cf8038adcb8373/" rel="bookmark">
			关键字 this
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this的使用案例 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; // 使用std命名空间 class Car { public: string brand; // 不需要使用std::string int year; // 有参函数 Car(string brand,int year) { this-&gt;brand = brand; this-&gt;year = year; cout &lt;&lt; "有参构造函数被调用" &lt;&lt; endl; // 不需要使用std::cout和std::endl } void display() const { cout &lt;&lt; "Brand: " &lt;&lt; brand &lt;&lt; ", Year: " &lt;&lt; year &lt;&lt; endl; } Car&amp; Setyear(int year){ this-&gt;year = year; return *this; } }; int main() { Car myCar("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/644dbd154d9b8cfb36cf8038adcb8373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051ee0d795883f59395f812c2a55650a/" rel="bookmark">
			超算互联网-Stable Diffusion 2.1文生图教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、名词简介 1. 超算互联网 超算互联网是一种基于云计算的高性能计算平台，用户可以通过互联网接入超级计算资源。它集成了大量的计算节点，提供强大的计算能力，适用于科学计算、深度学习、人工智能等领域。用户可以利用超算互联网平台运行复杂的模型和算法，显著提升计算效率和处理能力。
2. Stable Diffusion Stable Diffusion是一种基于扩散模型的生成技术，通过模拟扩散过程来生成图像。其基本原理是通过一系列的步骤，将初始的随机噪声逐渐转化为目标图像。整个过程可以分为两个阶段：前向扩散和反向扩散。
前向扩散：在训练过程中，模型从数据集中采样图像，并在每一步向这些图像添加随机噪声，直到这些图像变得完全模糊。这个过程模拟了图像从清晰到模糊的转变，形成了一系列带有不同噪声级别的图像。
反向扩散：生成阶段，模型从随机噪声开始，逐步去除噪声，直到生成高质量的图像。这个过程与前向扩散相反，通过学习到的反向扩散模型，模型能够逐步重建原始图像。
Stable Diffusion的核心优势在于其生成过程的稳定性和灵活性。由于采用了分阶段的噪声去除过程，模型在生成过程中可以更精确地控制图像的细节和风格。此外，Stable Diffusion 2.1版本引入了更高级的架构和优化算法，进一步提高了图像生成的质量和速度。Stable Diffusion的这种平衡使其在文生图应用中具有极高的实用性，特别是在艺术创作和广告设计领域，能够生成高质量且符合预期的图像。
3. 文生图 文生图（Text-to-Image Generation）是通过输入文本描述生成相应图像的技术。它将文本中的语义信息转换为视觉内容，使计算机能够根据文字生成符合描述的图像。这种技术在艺术创作、广告设计和游戏开发中应用广泛，能够快速生成所需的视觉元素，提升创作效率。文生图的核心是利用深度学习模型，将文本编码为语义向量，再解码为图像。尽管技术已经取得显著进展，但在文本理解的准确性和图像生成的多样性上仍面临挑战。
二、操作步骤 1. 开启Stable Diffusion 2.1 AI推理服务 在超算互联网平台上，首先需要开启Stable Diffusion 2.1的AI推理服务。登录平台后，选择Stable Diffusion 2.1 AI推理服务。
0元购买，点击去使用。
进入NoteBook。
NoteBook里我们可以直接点击启动键运行我们的代码。
2. 安装模型运行所需模块 在服务启动后，进入你的工作环境，安装Stable Diffusion运行所需的模块和依赖库。主要包括PyTorch、Transformers、Diffusers等库。
!sh ./install_requirements.sh 确保所有依赖库安装成功，并且环境配置正确。
3. 执行文生图命令 安装完成后，可以开始执行文生图命令，输入文本描述生成图像。
%run app.py "A beautiful sunset over the ocean" 我们可以使用一些复杂的提示词，绘制一篇更精确的图片，比如我想绘制一幅七夕节一家人在一起的画面。
%run app.py " A romantic Qixi Festival scene depicting the first date of a couple. They are in a beautiful park under the stars, with lanterns hanging from trees, creating a magical atmosphere.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051ee0d795883f59395f812c2a55650a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd539c1636216f29bbd2122c9333ab1b/" rel="bookmark">
			C:每日一题：单身狗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​
一、题目： 在一个整型数组中，只有一个数字出现一次，其他数组都是成对出现的，请找出那个只出现一次的数字。
整型数组 int arr[ ] = {1,1,2,2,3,4,4}
二、思路分析： 1.，明确目标，选择合适的算法
我们需要在数组中找出单个出现的数字；由于相同数字异或的结果为 0 ，而任何数字与 0 异或都得到其本身。可以通过对数组中所有数字进行异或操作，最终得到的结果就是只出现一次的数字。
2.考虑可能存在的bug
数组可能为空数组或者所求元素个数为负数的情况
if (sz &lt;= 0 || arr == NULL)
3.设计一个函数来完成计算数组中出现一次的元素
三、自定义函数number作用 int number(int arr[], int sz) { if (sz &lt;= 0 || arr == NULL)//防止数组为空或者非法的情况 { printf("输入错误！\n"); return -1; } int re = 0; int i = 0; for(i = 0;i&lt;sz;i++) { re ^= arr[i]; } return re; } number函数的作用是：
通过条件判断 sz &lt;= 0 || arr == NULL 来确保输入的数组不是空数组或者不存在的。如果是，就打印错误提示并返回 -1 。使用一个循环遍历数组的每个元素。通过异或操作 来计算。由于相同的数异或结果为 0 ，而任何数与 0 异或都得到其本身，所以最终异或操作 re ^= arr[i]; 的结果就是数组中只出现一次的元素。 四：主函数main的作用 int main() { int arr[] = {1,2,3,4,5,1,2,3,4,5,6}; int sz = sizeof arr / sizeof(arr[0]); int single = number(arr, sz); if (single !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd539c1636216f29bbd2122c9333ab1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0537c1c87fdeca28147eacfb9ade6f/" rel="bookmark">
			【MySQL】数据库约束和多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.数据库约束
2.1约束类型
2.2 NULL约束
2.3 NUIQUE：唯一约束
2.4 DEFAULT：默认值约束
2.5 PRIMARY KEY：主键约束
2.6 FOREIGN KEY：外键约束
1.7 CHECK约束
3.表的设计 3.1一对一
3.2一对多
3.3多对多
4.新增
5.查询
5.1聚合查询
5.1.1聚合函数
5.1.2 GROUP BY子句
5.1.3 HAVING
5.2联合查询
5.2.1内连接
5.2.2外连接
5.2.3自连接
5.2.4子查询
5.2.5合并查询
6.总结 1.前言 我们上一次介绍了MySQL数据库关于表的增删改查，在平时是用的过程还需要对数据库进行约束以及多表查询，因此今天跟大家分享并介绍数据库约束和多表查询的内容。
2.数据库约束 2.1约束类型 NOT NULL： 指示某列不能存储NULL值。
UNIQUE：保证某列的每行必须有唯一的值。
DEFAULT：规定没有给列赋值时的默认值。
PRIMARY KEY：确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
FOREIGN KEY：保证一个表中的数据匹配另一个表中的值的参照完整性。
CHECK：保证列中的值符合指定的条件。对于MySQL数据库，对CHECK子句进行分析，但是忽略CHECK子句。
2.2 NULL约束 我们在数据库创建表时，可以指定某列不为空，比如我们在创建一个学生表时，可以对表的结构进行设置。
-- 创建学生表并设置学生表结构 create table student ( id int not null, sn int, name varchar(20), qq_mail varchar(20) ); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a0537c1c87fdeca28147eacfb9ade6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590b51f2cb12090a8459fc5893dc679e/" rel="bookmark">
			Python图像背景去除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🎁库的导入
🎀库的安装
🎁rembg库去除背景
🎁效果
🎁文末彩蛋
今天来介绍一个特别有趣的python库，rembg库，全称是“Remove Background”的缩写，意为“去除背景”，是一个基于深度学习的图像背景去除工具。
🎁库的导入 from rembg import remove from PIL import Image 这两个库都是第三方库，需要自行下载安装。
🎀库的安装 清华镜像源地址:https://pypi.tuna.tsinghua.edu.cn/simple 这里建议使用清华镜像源进行安装，库不仅齐全而且安装速度很快。
打开PyCharm的终端，输入下列两行命令即可
🌸安装rembg
pip install rembg -i https://pypi.tuna.tsinghua.edu.cn/simple 🌸安装PIL
pip install Pillow -i https://pypi.tuna.tsinghua.edu.cn/simple 建议所有的库都用清华镜像源进行安装，毕竟速度快，一般不会超时，用自带的源容易超时。
🎁rembg库去除背景 from rembg import remove from PIL import Image # 指定输入和输出路径 input_path = r"test.png" # 替换为你的实际输入路径，这里直接去复制自己电脑上图片地址即可 output_path =r"output.png" # 替换为你想要的输出路径，可以把复制过来的地址的末尾的数字改一改就可以 # 打开输入图像 inp = Image.open(input_path) # 移除背景 out = remove(inp) # 保存输出图像 out.save(output_path) 这里要注意两个问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590b51f2cb12090a8459fc5893dc679e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a2971c528e76ab6501d1fdc63c6fdb6/" rel="bookmark">
			TCP/IP 协议及其协议号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		协议号十六进制协议号协议介绍10x1ICMP (Internet Control Message Protocol)20x2IGMP (Internet Group Management Protocol) 30x3GGP (Gateway-to-Gateway Protocol) 40x4IPv4 (encapsulation) 50x5ST (Stream Protocol) 60x6TCP (Transmission Control Protocol) 70x7CBT (CBT Multicast Protocol) 80x8EGP (Exterior Gateway Protocol)90x9IGP (any private interior gateway) 100xaBBN-RCC-MON (BBN RCC Monitoring) 110xbNVP-II (Network Voice Protocol) 120xcPUP (PUP Protocol) 130xdARGUS (ARGUS) 140xeEMCON (EMCON) 150xfXNET (Cross Net Debugger) 160x10CHAOS (Chaos Protocol) 170x11UDP (User Datagram Protocol) 180x12MUX (Multiplexing) 190x13DCN-MEAS (DCN Measurement Subsystems) 200x14HMP (Host Monitoring Protocol) 210x15PRM (Packet Radio Measurement) 220x16XNS-IDP (XEROX NS IDP) 230x17TRUNK-1 (Trunk-1) 240x18TRUNK-2 (Trunk-2) 250x19LEAF-1 (Leaf-1) 260x1aLEAF-2 (Leaf-2)270x1bRDP (Reliable Data Protocol) 280x1cIRTP (Internet Reliable Transaction Protocol) 290x1dISO-TP4 (ISO Transport Protocol Class 4) 300x1eNETBLT (Bulk Data Transfer Protocol) 310x1fMFE-NSP (MFE Network Services Protocol) 320x20MERIT-INP (MERIT Internodal Protocol) 330x21DCCP (Datagram Congestion Control Protocol) 340x223PC (Third Party Connect Protocol) 350x23IDPR (Inter-Domain Policy Routing Protocol) 360x24XTP (Xpress Transport Protocol) 370x25DDP (Datagram Delivery Protocol) 380x26IDPR-CMTP (IDPR Control Message Transport Protocol) 390x27TP++ (TP++ Transport Protocol) 400x28IL (IL Transport Protocol) 410x29IPv6 (encapsulation) 420x2aSDRP (Source Demand Routing Protocol) 430x2bIPv6-Route (Routing Header for IPv6) 440x2cIPv6-Frag (Fragment Header for IPv6) 450x2dIDRP (Inter-Domain Routing Protocol) 460x2eRSVP (Resource Reservation Protocol) 470x2fGRE (Generic Routing Encapsulation) 480x30DSR (Dynamic Source Routing Protocol) 490x31BNA (BNA) 500x32ESP (Encapsulating Security Payload) 510x33AH (Authentication Header) 520x34I-NLSP (Integrated Net Layer Security Protocol) 530x35SWIPE (IP with Encryption) 540x36NARP (NBMA Address Resolution Protocol) 550x37MOBILE (IP Mobility) 560x38TLSP (Transport Layer Security Protocol using Kryptonet key management) 570x39SKIP (Simple Key-Management for Internet Protocol) 580x3aICMPv6 (Internet Control Message Protocol for IPv6)590x3bIPv6-NoNxt (No Next Header for IPv6) 600x3cIPv6-Opts (Destination Options for IPv6) 610x3dAny host internal protocol 620x3eCFTP (CFTP) 630x3fAny local network 640x40SAT-EXPAK (SATNET and Backroom EXPAK) 650x41KRYPTOLAN (Kryptolan) 660x42RVD (MIT Remote Virtual Disk Protocol) 670x43IPPC (Internet Pluribus Packet Core) 680x44Any distributed file system 690x45SAT-MON (SATNET Monitoring) 700x46VISA (VISA Protocol) 710x47IPCV (Internet Packet Core Utility) 720x48CPNX (Computer Protocol Network Executive) 730x49CPHB (Computer Protocol Heart Beat) 740x4aWSN (Wang Span Network) 750x4bPVP (Packet Video Protocol) 760x4cBR-SAT-MON (Backroom SATNET Monitoring) 770x4dSUN-ND (SUN ND PROTOCOL-Temporary) 780x4eWB-MON (WIDEBAND Monitoring) 790x4fWB-EXPAK (WIDEBAND EXPAK) 800x50ISO-IP (ISO Internet Protocol) 810x51VMTP (VMTP) 820x52SECURE-VMTP (SECURE-VMTP) 830x53VINES (VINES)840x54TTP (TTP) 850x55NSFNET-IGP (NSFNET-IGP) 860x56DGP (Dissimilar Gateway Protocol) 870x57TCF (TCF) 880x58EIGRP (EIGRP) 890x59OSPFIGP (Open Shortest Path First) 900x5aSprite-RPC (Sprite RPC Protocol) 910x5bLARP (Locus Address Resolution Protocol) 920x5cMTP (Multicast Transport Protocol) 930x5dAX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a2971c528e76ab6501d1fdc63c6fdb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86c34603df3a494ad6ca781d9ec7bca/" rel="bookmark">
			【Python】基础语法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、标识符和关键字
二、注释
三、缩进
四、输入和输出
五、字符串操作
六、基本数据类型
七、复合数据类型
7.1 列表
7.2 元组
7.3 字典
7.4 集合
八、数据类型转换
九、运算符
8.1 算术运算符
8.2 比较运算符
8.3 赋值运算符
8.4 位运算符
8.5 逻辑运算符
8.6 成员运算符
8.7 身份运算符
十、分支和循环
10.1 if语句
10.2 for循环
10.3 while循环
十一、函数
十二、文件操作
提示：本文适合已经有编程基础的读者阅读，仅罗列Python中的语法，不对基础概念作讲解
一、标识符和关键字 标识符，即变量、方法、对象等的名字，由用户自己定义
Python中标识符不能以数字开头，由大小写字母、数字、下划线组成标识符对大小写敏感，A和a是两个不同的变量名在Python 3中，可以用中文作为变量名，同时允许非ASCII的标识符标识符不能和关键字相同 关键字，又称为保留字，是一个计算机语言中的预定义保留标识符
Python中一共有35个关键字，它们分别是：
FalseclassfromorNonecontinueglobalpassTruedefifraiseanddelimportreturnaselifintryassertelseiswhileasyncexceptlambdawithawaitfinallynonlocalyieldbreakfornot 二、注释 单行注释：以#开头，例如
# 这是单行注释 多行注释：以上下分别三个单引号或双引号包裹，例如
''' 这是多行注释 ''' """ 这也是多行注释 """ 三、缩进 Python不同于C++等语言，不需要用大括号括起来表示一个代码块
只要一段连续多行的代码有着相同的缩进空格数即为一个代码块，例如
如果在C++中的话，这三个print隶属于if语句下需要执行的代码，所以要用大括号括起来
但Python只需要保证这三条语句的缩进空格是一样的即可
四、输入和输出 Python中的 print 函数用于输出我们指定的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86c34603df3a494ad6ca781d9ec7bca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/54/">«</a>
	<span class="pagination__item pagination__item--current">55/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/56/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>