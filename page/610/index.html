<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e320d0c2f85b7cc135867ea51c5e33/" rel="bookmark">
			【C&#43;&#43;】C/C&#43;&#43;内存管理：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇的内存管理主要是动态内存管理。
1.C中的malloc、realloc、calloc和free函数： 【面试问题】
malloc、calloc和realloc的区别是什么？
malloc申请的内存值是不确定的 calloc却在申请后，对空间逐一进行初始化，并设置值为0 异地扩容的释放问题：
#include&lt;iostream&gt; using namespace std; int main() { int* p0 = (int*)calloc(4, 4); int* p2 = (int*)realloc(p0, sizeof(int) * 10); cout &lt;&lt; p0 &lt;&lt; endl; cout &lt;&lt; p2 &lt;&lt; endl; //free(p0); free(p2); return 0; } ❓请问这里p0需要free释放吗？
📚不需要，程序直接挂了，因为异地扩容的时候拷贝后会将原来的空间释放了
【问题】
int globalVar = 1; static int staticGlobalVar = 1; void Test() { static int staticVar = 1; int localVar = 1; int num1[10] = { 1, 2, 3, 4 }; char char2[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7e320d0c2f85b7cc135867ea51c5e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb85ebb670b6148e2c62468d8fb5287e/" rel="bookmark">
			如何免费使用ChatGPT进行学术润色？你需要这些指令...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 ChatGPT4.0上线2 中科院ChatGPT学术版3 学术润色Prompts 1 ChatGPT4.0上线 2023年3月14日，OpenAI发布ChatGPT4.0。ChatGPT4.0比3.5更大，拥有更多的参数。这意味着它可以更好地捕捉和理解语言的复杂性和细微差别，而且ChatGPT4.0是多模态的对话式大语言模型，已经可以接受图像输入了。
在在学术领域的应用，ChatGPT4.0可以用于更多自然语言处理任务，例如：
机器翻译：即从一种语言翻译成另一种语言，最直接的就是中英互译文本摘要：用于自动将大段的文本内容摘要成简短的概括，例如对新闻文章或学术论文进行摘要情感分析：用于自动识别和分类文本中的情感倾向——积极、消极、中立等，用于设计AI审稿、回复等功能代码解读：用于自动解析工程代码逻辑… ChatGPT的强大是否会带来新的科研范式尚未可知，但是，我们可以先体验一下它在学术润色方面的应用。
2 中科院ChatGPT学术版 近期，GitHub上有一个基于ChatGPT构建的热门开源项目——ChatGPT Academic上线，仅用了短短一两天，该项目 Star 数便增长到了1800+，目前已经达到24000+。这个项目相信大家都听过，就是中科院学术专业版ChatGPT。它基于ChatGPT为日常科研工作专属定制了一整套实用性功能，用于优化学术研究以及开发日常工作流程。
它提供的功能非常齐全，包括
功能描述一键润色支持一键润色、一键查找论文语法错误一键中英互译一键中英互译一键代码解释可以正确显示代码、解释代码自我程序剖析一键读懂本项目的源代码读论文一键解读latex论文全文并生成摘要批量注释生成一键批量生成函数注释arxiv小助手输入arxiv文章url即可一键翻译摘要+下载PDF………… 使用这个中科院学术版并不困难，这里我简单介绍下安装配置流程
下载仓库到本地git clone https://github.com/binary-husky/chatgpt_academic.git cd chatgpt_academic 配置API_KEY和代理
打开config.py设置API_KEY和代理API_KEY = "xxx" USE_PROXY = True if USE_PROXY: # 填写格式是 [协议]:// [地址] :[端口]，填写之前不要忘记把USE_PROXY改成True，如果直接在海外服务器部署，此处不修改 # 例如 "socks5h://localhost:11284" # [协议] 常见协议无非socks5h/http; 例如 v2**y 和 ss* 的默认本地协议是socks5h; 而cl**h 的默认本地协议是http # [地址] 懂的都懂，不懂就填localhost或者127.0.0.1肯定错不了（localhost意思是代理软件安装在本机上） # [端口] 在代理软件的设置里找。虽然不同的代理软件界面不一样，但端口号都应该在最显眼的位置上 proxies = { # [协议]:// [地址] :[端口] # "http": "socks5h://localhost:11284", # "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb85ebb670b6148e2c62468d8fb5287e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80341fcffb12c686c4358048695728ff/" rel="bookmark">
			Tomcat安装和配置（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Tomcat安装准备 1、tomcat下载 1.1、百度网盘链接下载 链接：https://pan.baidu.com/s/1uceOKe_QcpSQ6yhNxi4T5g?pwd=1234
提取码：1234 1.2、官网在线下载 Tomcat官网：https://tomcat.apache.org/download-80.cgi
1.2.1、打开官网，选择想安装的版本
1.2.2、根据自己的电脑配置进行选择
二、tomcat安装步骤 2、tomcat安装 解压下载完成的tomcat的压缩包
解压后的文件夹
解压完成后，把文件夹复制的任意盘
三、运行tomcat 3、运行 3.1打开tomcat安装目录 3.2、打开目录里面的bin文件 3.3、运行 bin目录的startup.bat文件（如果启动闪退，请到5.1目录） 3.4、点击允许访问（没有弹出则跳过） 3.5、出现以下界面，则tomcat运行成功 3.6、浏览器访问 localhost:8080,出现如下页面,即为成功 3.7、关闭tomcat运行（点击shutdown.bat文件） 3.8、再次浏览器访问 localhost:8080 四、tomcat配置环境变量（扩展） 4、环境变量 4.1、右键“此电脑”选择“属性” 4.2、点击“高级系统设置” 4.3、点击“环境变量” 4.4、找到系统变量 -&gt; 点击新建 4.5、打开新建系统变量页面，填入tomcat的系统变量信息 变量名：CATALINA_HOME
变量值：安装tomcat的路径（D:\Program Files\apache-tomcat-8.5.60）
4.6、在“系统变量”中选择“Path”，点击“编辑” 4.7、点击“新建”，增加两个变量地址如下： %CATALINA_HOME%\bin
4.8、按下“window+R”键 弹出运行框，输入“cmd”进入window命令行 4.9、输入“startup.bat”按下回车 4.10、出现下面界面则是tomcat已经配置成功 4.11、浏览器访问 localhost:8080,出现如下页面,即为成功 五、tomcat启动闪退问题 5、解决启动闪退 5.1、鼠标右键点击startup.bat，再点击编辑 5.2、往第一行添加以下内容 SET JAVA_HOME=C:\Program Files\Java\jdk1.8.0_271（Java-JDK路径）
SET TOMCAT_HOME=D:\Program Files\apache-tomcat-8.5.60（tomcat路径）
shutdown.bat跟startup.bat一样修改添加以下
六、修改tomcat端口号 6、修改端口 6.1、找到tomcat目录下的conf文件夹 6.2、右键点击server.xml，找到编辑 6.3、Ctrl+F 查找8080 后，修改端口号 6.4、再次运行startup.bat，访问浏览器的地址修改成： localhost:修改后的端口号 如：（localhost:9090） 制作不易，有帮助的话还希望能给个点赞和关注支持下，谢谢大家。🙏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1a933c033f2f20d64b15ea371d31fa/" rel="bookmark">
			AI绘画进军三次元，有人用它打造赛博女友？(diffusion)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 AI绘画技术飞跃2 效果展示3 环境配置3.1 下载基础模型3.2 更新.NET和模型3.3 下载绘画模型3.4 启动项目3.5 标签配置 4 结语 1 AI绘画技术飞跃 近期，人工智能技术的发展似乎反复出圈。AI绘画、AI编曲、AI写代码、AI对话等概念不断走入大众的视野，新一代科技革命似乎已然到来。
一些人对它嗤之以鼻，认为只是深度学习在计算机算力加持下进化为大模型罢了，本质原理上没有创新；有人认为这是一次里程碑事件——工业革命以来淘汰了大部分的重复性体力劳动，而ChatGPT等超级模型的诞生是否预示着大部分的重复性脑力劳动即将被终结？
你怎么看呢？
2022年10月，NovelAI流出stable-diffusion-webui模型，开启二次元AI绘画的时代，这也标志着一系列AIGC模型开始从学术界走入公众视角，甚至达到落地商业级别。
仅仅数月之后，AI开始向真人(三次元)绘画进军，大量打上AI绘图标签的、以假乱真的图片流入各个平台。一开始，人们还能通过AI绘画不擅长的手指、脚趾来分辨，但这个缺陷在不断地学习、迭代中逐渐改善。
2 效果展示 3 环境配置 3.1 下载基础模型 下载星空整合资源包，其中内置了基本的环境和启动助手。想想几个月前配置二次元AI绘画环境时，还需要安装显卡驱动和Pytorch，配置一堆依赖项，现在几乎一键部署了
3.2 更新.NET和模型 运行根目录下的启动助手.exe，可能会提示以下错误
进入官网https://dotnet.microsoft.com/zh-cn/download/dotnet/安装相应的补丁即可
安装完成后即可打开启动助手.exe
点击自动更新获取最新模型，选择自己设备的显卡配置
终端如下即可
3.3 下载绘画模型 进入civitai官网，可以看到有各种各样的主题模型
我们选择其中的真人绘画模型，比如可以选下面这个LORA模型，下载到本地即可
当然也不一定要选真人模型，选择艺术风格、动漫风格的都可以
3.4 启动项目 在启动助手.exe中点击运行，启动下面终端，可能会再配置一些依赖。启动好后，进入本地端口http://127.0.0.1:45001/
界面如下
3.5 标签配置 这里提供一组配置
prompt
&lt;lora:koreanDollLikeness_v10:0.66&gt;, best quality, ultra high res, (photorealistic:1.4), 1woman, sleeveless white button shirt, black skirt, black choker, ((glasses)), (Kpop idol), (aegyo sal:1), (platinum blonde grey hair:1), ((puffy eyes)), looking at viewer, full body paintings, sketches, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, glans, nsfw, nipples 采样方法：DPM++SDE Karras Sampling steps ：28
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1a933c033f2f20d64b15ea371d31fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb82b8beb90e1b80466ccf97e3f25d45/" rel="bookmark">
			干货分享 - MatLab || 与LaTeX的混合使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、Latex基础
3、Latex尝鲜
4、Latex在MatLab中换行
5、Latex在MatLab中小花招
6、附录1：Tex对照表
7、附录2：常用Tex字符
1、前言 LaTeX语言作为应用最广泛的Tex格式，Tex这种语言具有简单排版和程序设计的功能。
利用Latex，即使我们不会排版和程序设计也可以生成复杂的论文规格的表格和数学公式。
为了更加直观的感受LaTeX的排版作用，因此查看下图的红色方框区域部分。
Latex具有强大的显示数学公式的能力，能轻松表达出复杂的数学公式且非常美观。
f=@(x)exp(-2*x); x=0:0.1:2;plot(x,f(x),'.-k'); xlabel('{\itx}'); ylabel('{\ity=e^{-2x}}'); legend('f(x)=e^{-2x}'); latexf=['$$f(x)=e^{-2x}$$']; lgh=legend(latexf); set(lgh,'interpreter','latex'); 而Matlab在最新版本更新了对Tex/LaTeX的支持，使得我们在科学绘图中能够快捷方便的使用。
在用matlab对数据或模型进行计算处理之后，时常会需要输出结果呈现Latex的格式，或者能方便转换成Latex格式方便后续编辑。
可以提前给本文的内容做出一个总结：
MATLAB绘图时，可以使用LaTeX公式输入，前提是将相应的解释器从默认的'tex'改为'latex'，使用最多还是在编写公式上，无法对一些算法图和排版进行深入的使用。
无法自定义加载LaTeX的各种宏包，导致功能很受限，例如算法包，绘图包。
Matlab中使用Latex大体可分为两种类型：
使用Latex公式标注Matlab生成的各类图形
把Matlab的运行结果转换成Latex格式。
今天我们的内容就是好好盘点一下这些基础内容~
2、Latex基础 让我们先从基础的数学表达开始：
当我们在命令行键入： set(text,‘Interpreter’)
（部分低版本matlab为TickLabelInterpreter）
系统将返回'Interpreter'所包含的属性值：“none”||"tex"||"laTex"
可见默认值是：tex。我们可以将其设置为laTex。
在MatLab使用LaTex主要有这两种方式：
%格式一：'$ 表达式或值 $' % 一个公式只占一行当公式高度超过设定字符高度时会缩小公式中的字符 %格式二：'$$ 表达式或值 $$' % 一个公式能占多行公式中的每个字符都为设定的字符高度​​​​​​ 常见数学符号的表达方法
在新版本的matlab中，实时脚本的内容中有插入LaTex方程的选项。
我们利用该app进行基础的学习：
部分规则请查看附录~
单个字符：
希腊字母的变量名为“\”后面的字符串
求和符号：
卧氏大括号：
\overbrace{x+y+z+x+a+d} 上划线和下划线：
具体公式总结请看附录内容~
3、Latex尝鲜 编写MATLAB的绘图窗口时候，我们很多时候需要在图中制作公式图。
Matlab可以在title、xlabel、ylabel、zlabel...上插入LaTeX公式。
（部分代码来自csdn，感谢各位大佬的贡献）
值得注意的是，‘interpreter’ 表示所采用的解释器语法，此时需要设置为'latex'。
标题 title
% 标题中添加LaTeX格式公式 x = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb82b8beb90e1b80466ccf97e3f25d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ecf90c636b048bc67bcf5931ea18d3f/" rel="bookmark">
			如何看内存占用情况，vue反复刷新标签页导致面内存一直在涨，系统反应越来越慢，内存占用4个g。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、内存泄漏与内存溢出 内存泄漏(Memory Leak)： 不再用到的内存，没有及时释放；
内存溢出(Out Of Memory)： 应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。
2、泄漏原因 js写法（闭包、全局变量等）、dom事件监听、循环定时器等这些造成的泄漏；
组件的泄漏（DOM泄漏即DOM无法销毁）导致DOM上挂载的事件，对象数组等的数据也跟着无法释放。
3、chrome Memory 介绍 打开控制台上的Memory面板或者按住F12打开。
选择堆快照类型。我一般是使用前两种：Heap snapshot(JS堆快照)和Allocation instrumentation on timeline(JS堆分配时间线)。
开始录制前先点击下垃圾回收–&gt;点击开始录制。如果JS堆内存动态分配时间线，结束之前要再点击下垃圾回收，再结束录制。
4、解决办法 4.1、JS堆快照 Summary 总览视图： 按构造函数分组。用于捕捉对象及其使用的内存。对于定位DOM内存泄露特别有用。
Comparison 对比视图： 对比两个快照。用于对比不同操作之后的堆快照，查看内存的释放及引用计数，来分析内存是否泄露及其原因。
Containment 内容视图： 查看堆内容。更适合查看对象结构，有助于分析对象的引用情况。适用于分析闭包以及深入分析对象。
Statistics 统计视图： 总览堆的统计信息。
Summary总览视图 说明：
Constructor： 构造函数，节点下的对象都是由改构造函数创建而来。
Distance： 与根节点的距离。
Objects Count： 对象个数及百分占比。
Shallow size： 对象的直接内存总数，直接内存是指对象自身占用的内存大小。
Retained size： 对象的最大保留内存，保留内存是指对象被删除后可以释放的那部分内存。
点击展开构造函数，可以看到所有构造函数相关的对象实例，@后面的数字是该对象实例的唯一标识符。
常见的顶层构造函数：
(global property)： 全局对象和普通对象的中间对象，和常规思路不同。比如在Window上定义了一个Person对象，那么他们之间的关系就是[global] =&gt; (global property) =&gt; Person。之所以使用中间对象，是出于性能的考虑。(closure)： 使用函数闭包的对象。(array, string, number, regexp)： 一系列对象类型，其属性指向Array/String/Number/Regexp。HTMLDivElement/HTMLAnchorElement/DocumentFragment： 元素的引用或者代码引用的指定文档对象。
记住，黄色的对象实例表示它被JS代码引用，红色的对象实例表示被黄色节点引用的游离节点。新版本(测试过69)的好像不会有颜色标识。 JS堆快照可以用来发现DOM泄露。在Class filter(类过滤器)文本框中输入Detached可以搜索分离的DOM树。如果分离节点被JS引用，有可能就是泄露点。以下面这段代码为例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ecf90c636b048bc67bcf5931ea18d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00926be8e22af12d361004e0c6af9917/" rel="bookmark">
			GPU算力租用平台推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GPU算力租用平台推荐 对于一个准CVer的学生党，自己的电脑配置不高，组里的资源现在也缺少的情况下，只能去网上找GPU的租用平台来完成自己的毕业设计和科研。网上查看了很多关于GPU算力平台，自己也切身试了一些，总结如下：统一以RTX3090,以每小时作为单位。
平台价格优点缺点备注AutoDL￥1.58价格相对便宜难以租到尤其是上半年毕业季的时候，基本上都租完了智星云)￥4支持多种深度学习框架小贵OpenBayes￥1.9价格便宜暂时取消了自 2020 年上线的每人每周 10h RTX 3090 的资源赠送一注册就会送3h RTX3090的使用时间,点击我的链接双方都可以得到1h的使用时长九天毕昇体验版免费，收费版要￥7.5体验版免费，且支持多种框架体验版GPU一般都租不到Featurize￥3.6没有框架限制，价格还好服务器数量不够用MegStudio ,AIStudio平台提供了包括Bert、ResNet等常用模型的现成代码不支持安装主流tensorflow和pytorch框架Colab免费支持多种深度学习框架，不限制平台上运行的框架种类和版本需要科学上网，云端训练经常掉线，即使花钱也不能买到稳定的训练环境 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90c6845ac593316d9e66dcb23a1af55/" rel="bookmark">
			【Vue实验】实验一：设计并实现一个网页版的汇率计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 实验目标：源代码：实验步骤讲解：步骤一：先设计数据（==数据驱动视图==），设计数据与HTML的对应关系步骤二：实现“鼠标点击切换货币种类”的功能步骤三：实现“计算对应货币值”的功能 实验结果截图实验总结 实验目标： 一、	实验目标： 1.1	掌握vue中数据绑定、事件交互等基础语法，深刻理解vue的核心思想； 二、	实验条件： 2.1 硬件条件：CPU:i3处理器以上，内存4G以上，硬盘：128G以上 2.2 软件条件：VSCode、Google浏览器 三、	实验内容： 学习完Vue的基础知识之后，设计并实现一个网页版的汇率计算器，可以实现人民币、美元、港币、欧元、日元的相互兑换。大致功能如下： 1、引入vue.js框架后，定义一个json保存货币之间的汇率； 2、 通过点击鼠标切换需要兑换的币种； 3、利用监听器的方式监听币种的变化，从而根据定义的汇率计算。 4、 其它你想到的能尽量使得页面看起来美观。 源代码： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;汇率计算器&lt;/title&gt; &lt;!-- 样式 --&gt; &lt;style&gt; p.title { text-align: center; font-size: 18px; margin: 30px 0 10px 0; } p.intro { text-align: center; font-size: 14px; } ul { margin: 0 auto; width: 200px; list-style-type: none; border: 2px solid #999; border-radius: 10px; padding: 0; font-size: 16px; font-weight: bold; font-family: 'Courier New', Courier, monospace; } li { padding: 10px; } li:first-child { display: flex; border-bottom: 2px solid #999; } li:not(:first-child):hover { background-color: #ddd; } span { cursor: default; } span:last-child { float: right; } input { text-align: right; border: none; font-size: 16px; width: 100px; margin-left: auto; font-weight: bold; font-family: 'Courier New', Courier, monospace; outline: none; border-bottom: 1px solid #000; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c90c6845ac593316d9e66dcb23a1af55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f80eb11e83910a4d8b11c7a8306a669e/" rel="bookmark">
			多模态模型学习1——CLIP对比学习 语言-图像预训练模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多模态模型学习1——CLIP对比学习 语言-图像预训练模型 学习前言什么是CLIP模型代码下载CLIP实现思路一、网络结构介绍1、Image Encodera、Patch+Position Embeddingb、Transformer EncoderI、Self-attention结构解析II、Self-attention的矩阵运算III、MultiHead多头注意力机制IV、TransformerBlock的构建。 c、整个VIT模型的构建 2、Text Encoder 二、训练部分 训练自己的CLIP模型一、数据集的准备二、数据集的格式三、开始网络训练四、训练结果预测 学习前言 学了一些多模态的知识，CLIP算是其中最重要也是最通用的一环，一起来看一下吧。
什么是CLIP模型 CLIP的全称是Contrastive Language-Image Pre-Training，中文是对比语言-图像预训练，是一个预训练模型，简称为CLIP。
该模型是 OpenAI 在 2021 年发布的，最初用于匹配图像和文本的预训练神经网络模型，这个任务在多模态领域比较常见，可以用于文本图像检索，CLIP是近年来在多模态研究领域的经典之作。该模型大量的成对互联网数据进行预训练，在很多任务表现上达到了目前最佳表现（SOTA） 。
CLIP的思想非常简单，只需要看懂这幅图就可以了，左边是训练的原理，CLIP一共有两个模态，一个是文本模态，一个是视觉模态，分别对应了Text Encoder和Image Encoder。
Text Encoder用于对文本进行编码，获得其Embedding；
Image Encoder用于对图片编码，获得其Embedding。
两个Embedding均为一定长度的单一向量。
在训练时，假设一个批次中有64个文本图像对，此时我们会同时获得64个图片和64个文本，首先我们从64个文本图像对中取出一个文本图像对，成对的文本图像对是天然的正样本，它们是配对的。
而对于这个样本的文本来讲，其它63个图像都为负样本，它们是不配对的。
而对于这个样本的图像来讲，其它63个文本都为负样本，它们是不配对的。
在这个批次中，64个文本图像对，可以获得的图像embedding和文本embedding为：
visual_embedding [64, embedding_size] text_embedding	[64, embedding_size] visual_embedding的第x行和text_embedding的第x行是成对的。
我们使用visual_embedding 叉乘 text_embedding，得到一个[64, 64]的矩阵，那么对角线上的值便是成对特征内积得到的，如果visual_embedding和对应的text_embedding越相似，那么它的值便越大。
我们选取[64, 64]矩阵中的第一行，代表第1个图片与64个文本的相似程度，其中第1个文本是正样本，我们将这一行的标签设置为1，那么我们就可以使用交叉熵进行训练，尽量把第1个图片和第一个文本的内积变得更大，那么它们就越相似。
每一行都做同样的工作，那么[64, 64]的矩阵，它的标签就是[1,2,3,4,5,6……,64]，在计算机中，标签从0开始，所以实际标签为[0,1,2,3,4,5……,63]。
代码下载 Github源码下载地址为：
https://github.com/bubbliiiing/clip-pytorch
复制该路径到地址栏跳转。
CLIP实现思路 一、网络结构介绍 1、Image Encoder a、Patch+Position Embedding Patch+Position Embedding的作用主要是对输入进来的图片进行分块处理，每隔一定的区域大小划分图片块。然后将划分后的图片块组合成序列。
该部分首先对输入进来的图片进行分块处理，处理方式其实很简单，使用的是现成的卷积。由于卷积使用的是滑动窗口的思想，我们只需要设定特定的步长，就可以输入进来的图片进行分块处理了。
在VIT中，我们常设置这个卷积的卷积核大小为16x16，步长也为16x16，此时卷积就会每隔16个像素点进行一次特征提取，由于卷积核大小为16x16，两个图片区域的特征提取过程就不会有重叠。当我们输入的图片是224, 224, 3的时候，我们可以获得一个14, 14, 768的特征层。
下一步就是将这个特征层组合成序列，组合的方式非常简单，就是将高宽维度进行平铺，14, 14, 768在高宽维度平铺后，获得一个196, 768的特征层。平铺完成后，我们会在图片序列中添加上Cls Token，该Token会作为一个单位的序列信息一起进行特征提取，图中的这个0*就是Cls Token，我们此时获得一个197, 768的特征层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f80eb11e83910a4d8b11c7a8306a669e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1060c1acbbacdbceef0a9e2172a345/" rel="bookmark">
			数据清洗是什么？如何进行数据清洗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据清洗是数据治理过程中非常重要的一环，它指的是对数据进行清理、筛选、去重、格式化等操作，以确保数据质量和数据准确性。。在本文中，我们将围绕数据清洗展开讨论，并介绍一些数据清洗相关技术。
一、数据清洗的概念
数据清洗是指对数据进行处理和加工，以使其适合进行分析和建模。数据清洗包括去除重复数据、填补缺失值、处理异常值和转换数据格式等操作，以提高数据的准确性和可靠性。数据清洗通常是数据处理过程的一个必要步骤，它可以消除数据错误和噪声，并提高分析和建模的精度。
数据清洗的原理
二、数据清洗的技术
以下是一些常见的数据清洗技术：
数据去重：去除数据集中的重复记录。这可以通过比较记录中的唯一标识符或关键字段来实现。
缺失值处理：填补数据集中的缺失值。这可以使用插值、平均值、中位数、众数等方法进行处理。
异常值处理：检测和处理数据集中的异常值。异常值可以被删除或替换为可接受的值。
数据标准化：将数据格式标准化为一致的格式，以便于处理和分析。例如，可以将日期格式标准化为ISO格式。
数据转换：数据转换实质上是将数据的格式进行转换，其目的主要是为了便于处理和分析数据。例如，将文本格式的日期转换为日期格式。
数据验证：确保数据集中的数据准确性和完整性。例如，可以验证邮件地址是否符合标准格式，或验证电话号码是否正确。
总之，数据清洗是数据治理不可或缺的一环，它对于数据质量和准确性有着至关重要的影响。在实践中，数据清洗需要根据具体的数据集和业务需求进行调整和优化，以满足不同的数据处理和分析要求。因此，数据清洗需要进行不断的优化和改进，以适应不断变化的数据和业务环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4315e8c882e72477ede3c28cf78b03f0/" rel="bookmark">
			基于CNN的MINIST手写数字识别项目代码以及原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目简介项目下载地址项目开发软件环境项目开发硬件环境前言一、数据加载的作用二、Pytorch进行数据加载所需工具2.1 Dataset2.2 Dataloader2.3 Torchvision2.4 Torchtext2.5 加载项目需要使用的库 三、加载MINIST数据集3.1 数据集简介3.2 数据预处理3.3 加载数据集 四、模型构建五、CrossEntropyLoss5.1 Softmax5.2 Log5.3 NLLLoss 六、优化器七、模型训练八、加载模型九、模型测试十、自定义手写数字识别测试十一、项目结构图十二、全部代码总结 项目简介 本项目名为：基于CNN的MINIST手写数字识别项目。本项目完整的实现了MINIST手写数字的识别，模型的准确率高达 97 % 97\% 97%，损失率仅为 1 % 1\% 1%。利用训练好的模型去测试自定义手写数字，也可以准确识别！
项目下载地址 GitHub下载 项目开发软件环境 Windows 11PyCharm 2022.1Python 3.7.0Matplotlib 3.1.1Torch 1.13.0Torchvision 0.14.0Pillow 6.2.0Numpy 1.17.2 项目开发硬件环境 CPU：Intel® Core™ i7-8750H CPU @ 2.20GHz 2.20 GHzRAM：24GBGPU：NVIDIA GeForce GTX 1060 前言 本篇博文从整个项目数据集的导入到模型的构建以及最终的模型训练与测试和自定义手写数字识别，均进行了极为细致的代码分析。不仅如此，本文还将整个项目用到的所有技术以及知识点和原理都进行了极为详细的解释，利用图片以及公式力争将原理讲述的通俗易懂。通过本文，不仅可以学会手写数字识别项目的搭建过程，还可以搞懂CNN在手写数字识别项目中的应用以及背后的原理。当然，由于本人水平问题，可能有些问题解释的并不是很清晰，如有问题，还请读者与我反馈。最近也在学习这方面的知识点，读者感兴趣也可和我多交流！下面就正式开始本篇博文的内容！
一、数据加载的作用 因为在深度学习中，训练的数据通常数量十分巨大，不能一次性的把全部数据都传到模型中进行训练，所以要利用数据加载，将源数据的顺序打乱，进行分批和预处理后，最后将处理好的数据传给模型进行训练，这样才能保证模型训练的准确性。
通常情况下，加载好的数据一般每一行是一个训练样本，每一列为一个样本特征。
二、Pytorch进行数据加载所需工具 2.1 Dataset Dataset是用来创建数据集的函数（一般称为数据集类），一般情况下，我们的数据集首先传给Dataset，封装为数据集类。可以使用Dataset自定义数据集的内容和标签，如何使用Dataset呢？只需要使用如下语句引入即可：
from torch.utils.data import Dataset 引入Dataset后，我们就可以自定义我们数据集的数据了。其实Dataset没什么复杂的，说白了就是将我们的数据集给规范化的封装起来了，需要使用的时候调用Dataset返回相应的数据信息即可。如果我们要自定义一个Dataset供我们使用，通常要完成以下三个函数（也可以不重写，直接调用，也可以返回数据集相应的信息）：
__init__：初始化数据内容和标签 def __init__(self, Data, Label): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4315e8c882e72477ede3c28cf78b03f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8bad409578598995bac056368140f13/" rel="bookmark">
			最短路径算法（ Dijkstra &#43; Bellman-Ford &#43; SPFA &#43; Floyd）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
一、Dijkstra 算法
1、1 朴素版Dijkstra算法
1、1、1 Dijkstra求最短路 I
1、1、2 题解关键思路与与解答
1、2 堆优化版Dijkstra算法
1、2、1 Dijkstra求最短路 II
1、2、2 题解关键思路与答案
二、Bellman-Ford 算法
2、1 Bellman-Ford算法求有边数限制的最短路
2、1、1 题目描述
2、1、2 题解关键思路与解答
三、SPFA 算法
3、1 spfa求最短路
3、1、1 题目描述
3、1、2 题解关键思路与解答
四、Floyd 算法
4、1 Floyd求最短路
4、1、1 题目描述
4、1、2 题解关键思路与解答
五、总结
🙋‍♂️ 作者：@Ggggggtm 🙋‍♂️
👀 专栏：算法与竞赛 👀
💥 标题：最短路径算法 💥
❣️ 寄语：与其忙着诉苦，不如低头赶路，奋路前行，终将遇到一番好风景 ❣️
一、Dijkstra 算法 Dijkstra 算法是由荷兰计算机科学家 Edsger Wybe Dijkstra 在1956年发现的算法，戴克斯特拉算法使用类似广度优先搜索的方法解决赋权图的单源最短路径问题。Dijkstra 算法原始版本仅适用于找到两个顶点之间的最短路径，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树。Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法。本算法每次取出未访问结点中距离最小的，用该结点更新其他结点的距离，最终如果是连通的话，更新到第n个点的距离即为最短距离。需要注意的是Dijkstra 算法不能有效处理带有负权边的图。Dijkstra 算法是图论中一个较为重要的算法。其中存储所有路径的方式有两种：邻接矩阵（稠密图）、邻接表（稀疏图）。
当图中的路径较多（路径的个数为点数的平方级别的倍数）时，我们用邻接矩阵（二维数组）来存储所有路径，我们称它为朴素版的Dijkstra 算法。时间复杂度O（n^2）。
当图中的路径较少（路径的个数为点数为同一级别）时，我们用邻接表（多个单链表）来存储所有路径，我们称它为堆优化版的Dijkstra 算法。时间复杂度O（m*log n）。m为边数，n为点数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8bad409578598995bac056368140f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f629399f4718fe572c4003265aa656/" rel="bookmark">
			【数据结构专栏】动态扩容顺序栈详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💌 博客内容：顺序栈的原理详解
😀 作 者：陈大大陈
🚀 个人简介：一个正在努力学技术的准前段，专注基础和实战分享 ，欢迎私信！
💖 欢迎大家：这里是CSDN，我总结知识和写笔记的地方，喜欢的话请三连，有问题请私信 😘 😘 😘
目录
顺序栈的定义
结构体定义
顺序栈的初始化 判断顺序栈是否为空
求顺序栈的长度
清空顺序栈
销毁顺序栈
顺序栈的入栈
顺序栈的出栈
求栈顶元素
顺序栈的遍历
菜单的打印 顺序栈的代码实现
顺序栈的定义 栈（stack），是仅限在表尾进行插入或者删除操作的线性表，因此，对栈来说，表尾端有其特殊含义，称为栈顶，表头端则称为栈底，不含元素的空表称为空栈。栈的修改是按照后进先出的原则进行的，因此，栈也被称为后进先出的线性表。
结构体定义 我们定义一个栈顶指针top和一个栈底指针base，栈顶指针和栈顶指针一开始指向同一片空间。
所以top==base可以作为栈空的标记。
当插入一个新数据时，栈顶指针加一，删除一个元素时，栈顶指针减一。
所以当顺序栈非空时，栈顶指针永远在栈顶元素的下一位。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;errno.h&gt; #define maxsize 100 #define inc 10 typedef struct Sqstack { int* base;//栈顶指针 int* top;//栈底指针 int stacksize;//栈的容量 }stack; 顺序栈的初始化 上面也说了，顺序栈一开始栈顶指针和战地指针是指向一块空间的，因此这里就让栈顶指针和栈底指针相等。
我们使用动态内存开辟空间，先给栈一个默认的空间大小。
如果不够，后面的入栈会检测到并开辟空间。
如果空间开辟失败，就退出。
void InitStack(stack&amp; s) { s.base = (int*)malloc(sizeof(int) * maxsize); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f629399f4718fe572c4003265aa656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccc31b1ff04dafbcb9926e40dacb8306/" rel="bookmark">
			java经典选择题100例及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java经典选择题100例及答案 1．使用Java语言编写的源程序保存时的文件扩展名是（ ）。
（A）.class （B）.java （C）.cpp （D）.txt
2．设int a=-2，则表达式a&gt;&gt;&gt;3的值为（ ）。
（A）0 （B）3 （C）8 （D）-1
3．设有数组的定义int[] a = new int[3]，则下面对数组元素的引用错误的是（ ）。
（A）a[0]; （B）a[a.length-1];
（C）a[3]; （D）int i=1； a[i];
4．在类的定义中可以有两个同名函数，这种现象称为函数（ ）。
（A）封装 （B）继承
（C）覆盖 （D）重载
5．在类的定义中构造函数的作用是（ ）。
（A）保护成员变量 （B）读取类的成员变量
（C）描述类的特征 （D）初始化成员变量
6．下面关键字中，哪一个不是用于异常处理语句（ ）。
（A）try （B）break
（C）catch （D）finally
7．类与对象的关系是（ ）。
（A）类是对象的抽象 （B）对象是类的抽象
（C）对象是类的子类 （D）类是对象的具体实例
8．下面哪一个是Java中不合法的标识符（ ）。
（A）$persons （B）twoNum
（C）_myVar （D）point
9．为AB类的一个无形式参数无返回值的方法method书写方法头，使得使用类名AB作为前缀就可以调用它，该方法头的形式为( )。
（A）static void method( )
（B）public void method( )
（C）final void method( )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccc31b1ff04dafbcb9926e40dacb8306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed484abc00950d893fff20c49d741099/" rel="bookmark">
			Node.js安装教程及在vscode中的配置（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超详细的Node.js安装教程及在vscode中的配置
如果教程中出现了错误或者有其他问题，欢迎指正，我会积极改正的，希望能帮到你们。
一、Node.js下载安装教程
1、下载安装
进入nodejs官网，下载18.15.0长期维护版。
下载网址链接：Node.js (nodejs.org)​​​​​​
2、下载后双击打开，点击下一步
3、点击repair-&gt;next，一直点击下一步，直至设置安装路径，默认在C盘，建议更改安装路径到其他磁盘。
4、不用勾选，直接next
5、点击安装install ，完成finish
6、检测是否安装成功：win+R打开运行窗口，输入cmd，回车
7、输入node -v回车，npm -v 回车，若如图出现版本号，则说明安装成功。
8、打开node.js安装的文件夹，新建两个文件夹node_glabal和node_cache.。
(node_glabal是全局模块，node_cache。如没有node_modules文件夹，需要手动新建，用来配置环境变量，若有，就不用新建了。)
9、再次win+R打开运行窗口，输入cmd，回车，在输入下面这两条命令，若没有报错，就可以关闭此窗口。
npm config set prefix "刚才创建的 node_global文件夹的路径"
npm config set cache"刚才创建的 node_cache文件夹的路径"
(该路径可以手动输入，也可以打开所处文件夹直接拖入。)
9.1、此处只针对出现如下出错误的情况，如果上面的运行没有报错，请忽略这一步，直接进行第10步。
可能的原因是：（1）、之前你已经安装过一次node.js，但是这次安装路径和上次的不一样，请修改安装路径（进入到安装nodejs文件夹，找到npmrc文件，\node.js\node_modules\npm\npmrc），在重复第九步。
（2）、也有可能是之前安装nodejs配置的环境变量中路径与此次不同，需要去检查一下环境变量，具体操作看后面。（注意：后面操作中，需要添加路径的步骤，改成检查路径是否正确），然后在重复第9步。
10、打开设置，找到高级系统设置，点击环境变量。
11、在系统变量中，新建，变量名：NODE_PATH，变量值：node_modulesl文件夹的路径。
12、再修改或者直接添加用户变量中的path变量，点击编辑，为了防止修改到其他软件路径，在这里我们直接新建添加一个路径。
点击新建-&gt;浏览，找到node_global文件夹的路径，打开，然后确定。
然后点击确定，保存刚刚修改的。
二、Nodejs在vscode中的配置
1、在vscode的扩展中安装三个插件，Code Runner；JavaScript(ES6) code snippet；Live Server。
（在应用商店中搜索）
2、创建配置文件，打开代码文件夹，先创建一个test.js，随便写几句，然后运行测试代码。点击左边侧边栏的调试工具，选择创建launch.json文件，选择node.js调试环境。
3、此时配置文件会自动生成，注意将program属性修改为${file},这样可以识别当前调试的文件。然后运行文件。
4、在运行时报错
1、VScode调试中出现“没有可用的调试程序，无法发送‘variables’“问题。
在用node调试js的时候，是否遇到过这样的问题？当我第一次遇到这样的问题，我以为vscode调试只是捕捉node.js控制台的消息，不能像浏览器开发者工具一样能打印对象并且展开显示对象的各种属性。
然而，实质上是vscode用node调试完了，node.js已经运行此js文件已经结束了，因此vscode也已经打印完该打印的内容了，当用户想要展开某个对象的属性时需要让node在正在运行中。
2vscode中调试错误提示信息： Node process error: Error: spawn D:\����\node.exe ENOENT，或者说找不到对应的二进制文件。
报错原因：node安装路径有中文，导致vscode中的js调试报错。
解决方法：打开控制面板-&gt;时钟和区域，点击区域。
点击管理-&gt;更改系统区域设置。
选中Bata版：使用Unicode’ UTF-8提供全球语言支撑。点击确定，重启电脑即可。这样，vscode文件路径就支持中文了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2bea94c2a09e25901c366b865bc828/" rel="bookmark">
			Nginx到底能干嘛？！Nginx是做什么用的？通俗易懂，前端必看！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Nginx介绍 1. Nginx到底是什么，干什么用？ Nginx是一个 轻量级/高性能的反向代理Web服务器，它是由C语言写的，所以速度非常快、性能非常优秀。它的主要功能就是反向代理、负载均衡、配置SSL证书、防盗链、解决跨域问题、缓存、限流、动静资源分离等等。
上面介绍了Nginx是一台Web服务器，实际上，他并不是一台真正意义上的物理机服务器，并不是主观上真实存在的实体，它是运行在某一台服务器（电脑）上的软件。
那为什么还说它是一台Web服务器呢？我们先来理解一下什么是网关，大家都知道，从一个房间进入另一个房间内，必须经过一个门，就像经过一个“关口”，那从一个网络发送一个信息到另一个网络，也必须经过一个“关口”，这个关口就可以说是网关。这个关口并不是摆在那里那么简单，关口可以自行决定允不允许让你的消息通过，或者决定是否替你转发和接收消息、把消息分发给其他人，或者帮你的消息添加和预处理一些信息，或者替你回答消息等等功能。
而Nginx就相当于这个网关，转发和接收消息就相当于反向代理，把消息分发给其他人就相当于负载均衡。当我们的服务器（电脑）上安装了Nginx这个软件，通过一些简单的配置并运行这个软件，我们在服务器上运行的项目（例如Java程序）在接收Http请求的时候，这个请求就会被Nginx这个网关先拦截，经过一些上述的处理之后再交给Java程序，此时Nginx就充当了一个网关。因为外网用户的所有请求都会先经过Nginx，所以对于外网的用户来说，他们的请求都是发送给Nginx的，再由Nginx发送给Java程序处理后再发还给用户，那么从用户的角度来看，Nginx就相当于一台服务器在接收和回复用户发送的消息，所以也可以理解为Nginx是一台Web服务器。
2. 为什么要用Nginx？ Nginx跨平台，配置简单。我们可以在Linux系统和windows系统上都开启Nginx服务，配置也非常简单，在linux上，我们通常只需要修改三四行代码，既可以完成对项目的配置。当后端程序重构或者重新部署，例如由Java项目换成go项目，也不需要修改Nginx。
Nginx是由C语言写的，速度非常快，性能优越。目前公认的性能最高的后端语言就是C和C++，而Nginx就是由C写和编译的，其单机并发量非常高，可以达到5w+，而一般的后端Java程序并没有这么高的并发量，所以一般都会选择Nginx当网关放在Java程序之前，提高系统的整体性能。
动静资源分离。一般的前后端分离项目，用户想获取前端静态资源文件，都得先经过后端Java程序的接口再获取服务器上的静态资源文件，这样的效率并不是特别高，而且会占用正常程序接口的连接数量，这时候Nginx的动静资源分离功能就提供了很好的解决方法，一般静态资源文件都放在Nginx服务器中，当Nginx接收到了获取静态资源文件的请求，就直接在Nginx服务器中把放进去的静态资源返回了，而不用真正到达后端接口，这个效率是非常高的，比正常的访问速度会快一倍左右。
在并发量较大的项目中，后端往往会开启多个相同的Java服务，来缓解单服务的压力，我们知道，每一个Java服务程序都会占用一个端口，那前端在后端接口的时候，怎么知道该选用哪个接口呢？这时就可以在所有的Java程序前放置一个Nginx程序，所有的请求都经过Nginx，由Nginx决定分发到哪个端口程序上，这样，虽然后端有很多个Java程序，但对于前端来说，是无感知的，就好像后台只有一个项目在跑一样。
那这么多后端程序在跑，万一有一个程序挂了前端不知道怎么办？放心，Nginx还有一个Keepalive保活机制，Nginx会不断监听后端程序的接口，看该服务是不是在正常运行，万一有一个程序挂了，那么Nginx就不会把前端发来的请求转发给这个接口，确保后端服务的高可用性和稳定性。
二. 具体常见应用 1. 反向代理 (1). 正向代理 说到反向代理，我们常常会想到正向代理，那么两者有何区别呢？
正常情况下，我们访问一个网页、服务器，只需要在浏览器中输入相应的域名或ip地址和端口号，经过DNS解析后，就可以访问到服务器上的资源，这是最普通也是最直接的连接方式，也就是用户端和服务端的直接连接，我们可以直接访问服务器，但是这样有一个问题，我们用户端的ip地址就泄露给了对方，如果我们不想让服务端知道我们的ip地址呢？
这时候就需要正向代理了，不同于反向代理，正向代理的网关是用户端自己配置和搭建的，用户端和网关是一伙的，这样用户端每次要访问服务端的时候，就把请求发到自己配置的网关上，然后由网关转发用户的请求给服务端，服务端返回响应后就再发还给用户。对于服务器来说，具体用户是谁是无感知的，因为请求都来源于网关代理的转发，这样服务端就不知道真正发请求的用户到底是谁。
(2). 反向代理 拿nginx实现的反向代理来说，不同于正向代理，反向代理的网关和服务器是一伙的，用户端无法通过公网直接访问到后台服务器上的Java应用程序，但是可以直接访问nginx网关，再由nginx分发到不同的服务器（或者说应用程序）上，真正提供服务的服务器对于用户来说是无感知的，所有的请求都必须先发送到nginx网关上，再进行请求转发，用户端并不知道真正提供服务的服务器是谁，也不知道它的具体ip地址和端口，所以称之为反向代理。
拿nginx的常见配置来讲，server_name实际上就是本机的ip，listen就是监听这个ip下的某个端口。而location则可以理解要拦截哪个url进行处理，“/”表示拦截所有。proxy_pass则表示把这个拦截的url要转发到哪个服务器上，所以填的是ip+端口。这样就可以做到反向代理，把某个ip+端口+路径的请求给拦截下来，转发到另一个ip+端口+路径的资源上。
2. 负载均衡 通常后端项目并只会开启一个Java应用程序，一般都会开启多个，这时候就需要nginx来选择将所有的请求分发给不同的程序应用，这个过程就是负载均衡。
那我们怎么知道要按哪些规则去分发这些请求呢？nginx中已经提供了几种常见的负载均衡算法，例如默认的轮询算法，按顺序、平均地把每一条请求分发出去。
upstream backserver { server 192.168.1.1; server 192.168.1.2; } 或者按权重分配，权重值高的分配请求也越多。
upstream backserver { server 192.168.1.13 weight=2; server 192.168.1.14 weight=8; } 或者按用户端的ip进行hash运算分配。
upstream backserver { ip_hash; server 192.168.0.11:88; server 192.168.0.13:80; } 3. 解决跨域问题 location / { #允许跨域请求的域，* 代表所有 add_header 'Access-Control-Allow-Origin' *; #允许请求的header add_header 'Access-Control-Allow-Headers' *; #允许带上cookie请求 add_header 'Access-Control-Allow-Credentials' 'true'; #允许请求的方法，比如 GET,POST,PUT,DELETE add_header 'Access-Control-Allow-Methods' *; if ($request_method = 'OPTIONS') { return 204; } proxy_pass http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f2bea94c2a09e25901c366b865bc828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe8694230a39a30126c6b6f885b8970/" rel="bookmark">
			计算机图形学06：中点Bresenham画圆（并填充边界，例如：边界用红色，内部用绿色填充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：非妃是公主
专栏：《计算机图形学》
博客地址：https://blog.csdn.net/myf_666
个性签：顺境不惰，逆境不馁，以心制境，万事可成。——曾国藩
文章目录 专栏推荐专栏系列文章序一、算法原理二、OpenGL代码实现三、圆的内部填充四、效果展示the end…… 专栏推荐 专栏名称专栏地址软件工程专栏——软件工程计算机图形学 专栏——计算机图形学 操作系统专栏——操作系统软件测试专栏——软件测试机器学习专栏——机器学习数据库专栏——数据库算法专栏——算法 专栏系列文章 文章名称文章地址直线生成算法(DDA算法)计算机图形学01——DDA算法中点BH算法绘制直线计算机图形学02——中点BH算法改进的中点BH算法计算机图形学03——改进的中点BH算法中点Bresenham画椭圆计算机图形学04——中点BH绘制椭圆中点BH算法绘制任意斜率直线计算机图形学05——中点BH算法绘制任意斜率的直线中点Bresenham画圆计算机图形学06——中点BH算法画圆有效边表法的多边形扫描转换计算机图形学07——有效边表法绘制填充多边形中点BH算法绘制抛物线 100 x = y 2 100x = y^2 100x=y2计算机图形学08——中点BH绘制抛物线二维观察之点的裁剪计算机图形学09——二维观察之点裁剪二维观察之线的裁剪计算机图形学10——二维观察之线裁剪二维观察之多边形的裁剪计算机图形学11——二维观察之多边形裁剪二维图形的几何变换计算机图形学12——二维图形几何变换三维图形的几何变换计算机图形学13——三维图形几何变换三维图形的投影变换计算机图形学14——三维图形投影变换 序 计算机图形学（英语：computer graphics，缩写为CG）是研究计算机在硬件和软件的帮助下创建计算机图形的科学学科，是计算机科学的一个分支领域，主要关注数字合成与操作视觉的图形内容。虽然这个词通常被认为是指三维图形，事实上同时包括了二维图形以及影像处理。
一、算法原理 主要思路为：将圆分为8个部分，通过堆成就可以得到各个部分的坐标，这样我们只需要绘制圆的 1 8 \frac{1}{8} 81​ ，就可以实现对整个圆的绘制，如下：
由于，d中存在一个1.25这个小数，不利于硬件进行计算，故将模型进行优化，如下：
整体算法步骤如下：
二、OpenGL代码实现 OpenGL代码实现如下：
// 中点Bh算法绘制圆 void MidBhcircle(int r) { int x = 0, y = r, d = 1 - r; glBegin(GL_POINTS); while (x &lt;= y) { glVertex2i(x, y); glVertex2i(y, x); // 八分画圆 glVertex2i(-y, x); glVertex2i(-x, y); glVertex2i(-x, -y); glVertex2i(-y, -x); glVertex2i(y, -x); glVertex2i(x, -y); if (d &lt; 0)	// 根据d的值更新下一个点的坐标 d += 2 * x + 3; else {	// d&lt;0时要y--，即点在圆的内部 d += 2 * (x - y) + 5; y--; } x++;	// x默认+1 } glEnd(); } 三、圆的内部填充 主体思路：从原点向外扩充，利用一个队列作为数据结构，然后向外扩充(泛洪)。值得注意的是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe8694230a39a30126c6b6f885b8970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41fb906743a250494163835fdd3a8b35/" rel="bookmark">
			全网最详细的nodejs卸载和安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为项目需求，重装了3个版本的node.js，记录下完整过程，少走弯路少查资料。
一、卸载 1、Win菜单中找到Node.js的卸载程序，运行卸载程序。
2、点击是。
3、等待卸载完成。
4、删除C:\Users\用户名\AppData\Roaming目录下的npm和npm-cache；删除C:\Users\123\AppData\Local\目录下的npm-cache。
二、安装 我安装的版本是node-v14.17.3，各版本安装过程完全相同。 1、点击进入node.js各版本下载链接，下载node-v14.17.3-x64.msi。
2、运行msi安装程序，点击next。
3、勾选协议，next。
4、更换安装路径，非C盘原则。
5、不需要选择或更换，默认安装，直接next，它会自动添加系统变量。
6、直接next。
7、install。
8、Finish。
9、cmd进入命令行界面，输入node -v 显示node版本，输入npm -v显示npm版本，如果都能显示则安装成功。
10、到目前为止，node的环境已经安装完成，npm包管理器也有了。我猜大家还要安装Vue，命令行输入安装命令
npm install -g vue-cli 输入vue -V显示版本号
做有价值的事情，让生命变得有意义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6c2d48698c1bf2432f645cc754fabd/" rel="bookmark">
			yoloV5更换BiFPN结合小目标检测层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章纯属记录学习使用，我也不太明白是否为小目标检测层，不对的地方还希望一块交流
yolov5初始模型在特征融合时只对P3、P4、P5、三个特征层进行了融合，添加小目标检测层的目的是把P2（也就是yaml文件中第二个conv层得到的特征图）也加入到特征融合中。
P2位于低特征层，具有较强的位置信息，语义特征信息较弱，常用来进行小目标检测，这篇博客我觉得写的很好 高低特征层。
但并不是你觉得你所要检测的是小目标，就需要加入小目标检测层，当添加小目标检测层有时会适得其反，并不会有所改进。看论文对于小目标的定义为：小于32*32像素的目标为小目标。
（yaml能跑通但是有些不合理，等有时间会修改）
添加BiFPN 第一步： 在common.py 文件下添加下列代码
# BiFPN # 两个特征图add操作 class BiFPN_Add2(nn.Module): def __init__(self, c1, c2): super(BiFPN_Add2, self).__init__() # 设置可学习参数 nn.Parameter的作用是：将一个不可训练的类型Tensor转换成可以训练的类型parameter # 并且会向宿主模型注册该参数 成为其一部分 即model.parameters()会包含这个parameter # 从而在参数优化的时候可以自动一起优化 self.w = nn.Parameter(torch.ones(2, dtype=torch.float32), requires_grad=True) self.epsilon = 0.0001 self.conv = nn.Conv2d(c1, c2, kernel_size=1, stride=1, padding=0) self.silu = nn.SiLU() def forward(self, x): w = self.w weight = w / (torch.sum(w, dim=0) + self.epsilon) return self.conv(self.silu(weight[0] * x[0] + weight[1] * x[1])) # 三个特征图add操作 class BiFPN_Add3(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6c2d48698c1bf2432f645cc754fabd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f17e7b3fc1dc893714541d8f46f3265/" rel="bookmark">
			【蓝牙音频SoC】BES2700YP、BES2600YP、AB1565A、QCC3056芯片基本介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、BES2700YP是恒玄最新一代超低功耗、高集成度的蓝牙音频 SoC，采用 12nm 工艺制程，成双模蓝牙 5.3，支持 BT&amp;BLE，主处理器内置 Arm Cortex-M55 CPU 和 Tensilica HiFi 4 DSP，极大提升了芯片的运算性能，sensor hub 子系统内置 STAR-MC1 MCU 和恒玄自研的神经网络处理器 BECO NPU，在显著降低功耗的同时，实现丰富的应用处理能力。
2、BES2600YP是恒玄新一代超低功耗蓝牙音频SoC。采用了蓝牙+降噪+入耳检测三合一单芯片方案，支持双模蓝牙5.3和多点连接，内部集成双核ARM STAR-MC1 cpu和超低功耗Sensor Hub子系统，具备强大的应用处理能力，支持开放式自适应降噪和AI降噪，支持辅听功能和空间音频，支持语音唤醒和交互等功能。
3、Airoha（络达）AB1565A是蓝牙5.3和LE音频认证的单芯片解决方案，包含ARM®Cortex®-M4F应用处理器，可实现高性能和电源效率。
AB1565的I/O外设控制、协议栈和DSP处理功能采用Tensilica HiFi Mini处理器。它集成了混合有源噪声消除(ANC)、新一代回声消除和降噪方案，提高了耳机产品上语音通话的音频质量。
AB1565还支持Airoha MCSync(多播同步)技术，允许耳塞在左右耳塞之间无缝切换，以获得更平衡的声音和低延迟。典型应用包括：立体声耳机，TWS，扬声器，音箱和低音炮，BT发射器等设备。
特点：
车队联盟
语音助手支持
参考iOS、Android智能手机、PC APP
可编程软件开发工具包和工具支持
音频/ANC/语音调谐工具
4、高通QCC3056是一种超低功耗、单芯片解决方案，经过优化，可用于无线耳塞和耳戴式设备。它支持True Wireless Mirroring技术，并具有广泛的差异化功能。QCC3056集成了1x80MHz 32bit的Progremmable Apps CPU和2x120MHz的DSP programmable，在支持Adaptive ANC、aptX HD、aptX Adaptive、CVC的同时，也支持LE Audio标准。
QCC3056性能
蓝牙版本：蓝牙5.2
CPU速度：Up to 80 MHz
DSP速度：2x120 MHz
aptX音频解码：aptX Audio/ aptX Voice/ aptX Adaptive
通道输出：Mono
主要特点：
● 蓝牙5.2版本，连接更稳定，延时更小，功耗更低;
● 超小尺寸
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f17e7b3fc1dc893714541d8f46f3265/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/609/">«</a>
	<span class="pagination__item pagination__item--current">610/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/611/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>