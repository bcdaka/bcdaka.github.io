<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7312b440367374c9a9be2eedc57692b/" rel="bookmark">
			一文读懂「AIGC，AI Generated Content」AI生成内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先，让我们理解一下这两个概念。
AIGC，或者称之为人工智能生成内容，是指使用AI算法和模型来自动生成全新的、原创的内容。这种内容可以包括文本、图像、音频、视频等各种形式，甚至可以包括一些独特的形式，比如新颖的创意和设计。AIGC的应用领域非常广泛，包括但不限于写作、绘画、音乐创作、视频制作等。
生成式AI，则是一种更广泛的概念。它指的是使用AI算法和模型来生成或者模拟某种特定的数据或现象。这种AI模型的学习和训练过程通常是基于大量的数据，从而使其能够模拟出真实世界中的某种行为或者现象。生成式AI的应用领域也非常广泛，包括但不限于自然语言处理、图像识别、语音合成等。
一、什么是AIGC？ 二、市场规模 预计2024年436亿元，2028年，中国AIGC产业规模预计将达到7202亿元，中国AIGC产业生态日益稳固，完成重点领域、关键场景的技术价值兑现，逐步建立完善模型即服务产业生态，2030年中国AIGC产业规模有望突破万亿元，达到11441亿元
三、技术层面发展 Transformer类架构的发展带动多模态融合，为范式转变奠定基础 AIGC要素：算力 + 算法+ 数据 AIGC发展重点 AIGC产业图谱 AIGC产业链路 AIGC未来方向 三、产业层面发展 AIGC产业融资 AIGC场景应用 四、AIGC应用分析 AI+ 游戏 eg：网易伏羲
AI + 广告营销 eg：
AI + 影视媒体行业 eg：
AI+ 电商 eg：
AI+医疗 eg：
AI + 金融 eg：
AI+ 其他 五、AIGC落地方式与路径 目前企业/机构端在使用相关的AIGC能力时，主要有五种方式：直接使用、Prompt、LoRA、Finetune、Train。
直接使用：直接使用基础大模型厂商发布的产品服务，通过接口调用方式嵌入自身业务或系统当中。
Prompt：通过提示工程，通过微调少量参数，引导预训练语言模型做特定下游任务。利用文本对话方式操控语言大模型，引导生成结果。
LoRA：仅训练低秩矩阵（low rank matrics），使用时将LoRA模型的参数注入基础大模型，在不修改大模型的前提下，改变模型的生成风格。所需的训练资源比训练基础大模型要小很多，非常适合社区使用者和个人开发者。
FineTune：Finetune是应用或利用迁移学习的一种方式。对基础大模型进行微调，以适应特定任务。当数据集相似，但数据量又很少的情况下，微调省去大量计算资源和计算时间，提高了计算效率,甚至提高准确率。具体来说，微调是一个过程，它采用已经针对一项给定任务训练过的模型，然后调整或微调模型以使其执行第二个类似任务。
Train：调用数据、算力、算法从头训练大模型，从头开始训练大模型。除非特殊领域和特定要求，一般商业公司不会从头开始训练基础大模型。
六、AIGC营收模式 目前AIGC主要的商业模式为MaaS（Model as a service），MaaS是一种云与大模型深度绑定后的新商业模式，以云为基础、模型为中心，提供众多预训练基础模型，只需针对具体场景作调整优化，就能够快速投入使用。
六、机遇和挑战 七、标杆企业 阿里云 第四范式 云知声 中关村科金 软通动力 八、资源 艾瑞咨询：https://www.iresearch.com.cn/Detail/report?id=4294&amp;isfree=0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcdd97af8dd3f1ccfe4d08579f902fb2/" rel="bookmark">
			OpenAI 开源的免费 AI 语音转文字工具 - Whisper，一步一步本地部署运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Whisper 是 OpenAI 研发的一个通用的语音识别模型，可以把语音转为文本。它在大量多样化的音频数据集上进行训练，同时还是一个多任务模型，可以执行多语言语音识别、语音翻译和语言识别。
一、使用场景 语音 =&gt; 文字 是一个非常实用的功能，例如：
会议、讲座、法庭、医疗等等场景的记录
口述笔记，方便需要频繁记录思路、灵感的人，更快地记录想法
智能助手，例如智能音箱、导航等
文案提取，看到好的视频，可以把视频中的话转为文本文案
ChatGPT 的手机 APP 可以和我们语音对话聊天，就是使用 Whisper 把我们的语音转为的文本。
所以，Whisper 的强大能力不用多说。
现在市面上语音转文字的产品很多都是收费的，例如讯飞语记等等。
Whisper 是开源免费的，而且效果极佳，如果能在自己的电脑中运行，岂不是美事。
下面就以Windows11为例，介绍一下它的安装运行流程。
二、安装步骤 1）安装 ffmpeg 下载地址：
ffmpeg.org/download.html
安装后，打开cmd命令行，确定可以执行 ffmpeg 命令：
ffmpeg -version 如果无法执行，手动配置一下环境变量PATH。
2）安装 rust 下载地址：
rust-lang.org/tools/install
同样的，安装后需要确定命令行可以执行，测试命令：
rustc --version 如果无法执行，手动配置一下环境变量PATH。
rust 的默认安装位置是 ~/.cargo/bin。
3）安装 Whisper 配置python虚拟环境，因为 Whisper 需要特定版本的 python。
conda create --name whisper_env python=3.9.18 activate whisper_env 安装依赖库：
pip install setuptools-rust pip install -U openai-whisper 三、运行 命令行运行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcdd97af8dd3f1ccfe4d08579f902fb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa3981ec9744c178ad4c7c5501e60266/" rel="bookmark">
			鸿蒙打包Flutter为HAP流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙打包Flutter为HAP流程简介，官方文档可访问OpenHarmony-SIG / flutter_flutter
环境依赖 1.下载ohpm命令行工具，并配置环境变量ohpm与sdkmanager，下载完成后执行ohpm目录下bin/init初始化ohpm。参照指导文档：ohpm使用指导。 export OHPM_HOME=/home/&lt;user&gt;/ohos/oh-command-line-tools/ohpm/ export PATH= $PATH:$OHPM_HOME/bin:$OHPM_HOME/sdkmanager/bin 2.下载OpenHarmony SDK并配置环境变量，可直接参考官方文档 3.通过代码工具下载当前仓库代码git clone https://gitee.com/openharmony-sig/flutter_flutter.git，并配置环境 #这里的flutter sdk路径为你下载的鸿蒙的flutter sdk的路径，并且需要切换到最新分支代码 export PATH=&lt;flutter_flutter path&gt;/bin:$PATH export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 4.配置签名，可直接参考官方文档 5.应用构建依赖鸿蒙Flutter Engine构建产物，这里建议直接用官方已经构建好的产物，自己去构建费时费力还可能构建不成功，官方构建产物在Engine构建产物，下载好的产物为三个压缩包，分别为 debug profile release，对需要打包的类型进行解压，解压后的文件夹如下： 6.构建步骤 运行 flutter doctor -v 检查环境变量配置是否正确，Futter与OpenHarmony应都为ok标识，若两处提示缺少环境，按提示补上相应环境即可。创建工程与编译命令，编译产物在/ohos/entry/build/default/outputs/default/entry-default-signed.hap下。 创建工程,这里创建出来的project的compile sdk为API 11,目前并没有支持个人使用，需要企业申请，对应的开发工具和SDK可参考OpenHarmony文档版本分支说明 flutter create --platforms ohos &lt;projectName&gt; 进入工程根目录编译 cd /Users/kk/Desktop/develop/project/hmosdemo 这里对应的是你上一步解压出来的engine产物路径 flutter build hap --local-engine=/Users/kk/Desktop/develop/project/hm_demo/engine-mac-arm64/src/out/ohos_debug_unopt_arm64 通过flutter devices指令发现ohos设备之后，使用 hdc -t install 进行安装。也可直接使用下列指令运行： flutter run --local-engine=&lt;flutter_engine out path&gt; 7.自己构建engine 虽然非常不建议大家自己去构建Flutter Engine， 但是还是补充一下构建的步骤
准备个梯子，非常必要，而且梯子网速要快和稳定，不然很痛苦构建基础环境：可参照官网
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa3981ec9744c178ad4c7c5501e60266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899ef191a409a7a0a34c2ebd5d599e14/" rel="bookmark">
			成为高效Java工程师的干货笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 作为一名Java工程师，不仅需要具备扎实的编程基础和技能，还需要不断学习和提升自己，以应对日益复杂的软件开发挑战。本文将分享一些实用的干货笔记，帮助Java工程师提升效率、技术水平和职业发展。
一、Java基础知识 1. 深入理解Java核心概念 深入理解Java核心概念是成为优秀Java工程师的关键之一。在这方面，面向对象编程原理、Java集合框架和异常处理机制是非常重要的基础知识。让我们逐一展开：
1.1 面向对象编程原理 面向对象编程（OOP）是Java的核心思想之一，也是Java广泛应用于软件开发领域的重要原因之一。以下是面向对象编程原理的关键概念和特点：
类与对象：在Java中，一切皆为对象。类是对象的模板，定义了对象的属性和行为。对象是类的实例，具体表现出类定义的属性和行为。封装：封装是面向对象编程的重要特性之一，它将数据（属性）和行为（方法）封装在类中，外部只能通过类的接口来访问对象的数据和方法，提高了代码的安全性和可维护性。继承：继承允许一个类（子类）继承另一个类（父类）的属性和方法。通过继承，可以实现代码的重用，提高了代码的可扩展性和灵活性。多态：多态是面向对象编程的另一个重要特性，它允许不同类的对象对同一消息作出不同的响应。多态性提高了代码的灵活性和可扩展性。 1.2 Java集合框架 Java集合框架是Java编程中常用的数据结构和算法集合，提供了一组接口和类，用于存储和操作对象集合。Java集合框架主要包括以下几个核心接口和类：
List：有序集合，允许存储重复元素，常用的实现类有ArrayList、LinkedList。Set：不允许重复元素的集合，常用的实现类有HashSet、TreeSet。Map：键值对集合，每个键对应一个值，常用的实现类有HashMap、TreeMap。 Java集合框架提供了丰富的方法和功能，可以满足不同场景下的数据存储和操作需求，是Java程序员必须掌握的重要知识点。
1.3 异常处理机制 在Java编程中，异常是不可避免的，而良好的异常处理机制是保证程序稳定性和可靠性的关键。以下是Java中异常处理机制的重要内容：
异常分类：Java将异常分为受检异常（Checked Exception）和非受检异常（Unchecked Exception）。受检异常需要在方法签名中声明，或者使用try-catch块进行处理；非受检异常通常是编程错误导致的异常，不需要显式处理。try-catch块：在Java中，通过try-catch块可以捕获和处理异常。try块中包含可能抛出异常的代码，catch块中处理异常逻辑。可以通过多个catch块处理不同类型的异常。finally块：finally块中的代码无论是否发生异常都会执行，通常用于释放资源或清理操作，确保资源的正确释放。 2. 掌握Java多线程编程 掌握Java多线程编程是非常重要的，特别是在需要处理并发和异步任务的场景下。以下是关于Java多线程编程的几个重要方面：
2.1 线程的创建与管理： 线程的创建：在Java中，可以通过继承Thread类或实现Runnable接口来创建线程。通过重写run()方法定义线程的执行逻辑，然后调用start()方法启动线程。线程的管理：Java提供了一些方法来管理线程，比如sleep()方法可以让线程休眠一段时间，join()方法可以等待线程执行完成，interrupt()方法可以中断线程等。 2.2 同步与锁机制： 同步机制：在多线程环境下，多个线程同时访问共享资源可能导致数据不一致的问题，Java提供了synchronized关键字来实现同步，保证线程安全。锁机制：除了synchronized关键字外，Java还提供了Lock接口及其实现类（如ReentrantLock）来实现锁机制。通过锁机制可以更灵活地控制线程的访问顺序。 2.3 并发工具类的使用： Java并发工具包提供了丰富的工具类来帮助开发者处理多线程并发的情况，比如：
CountDownLatch：用于线程间的计数等待，一组线程等待所有线程完成某个操作后再继续执行。CyclicBarrier：用于线程间的互相等待，所有线程达到某个屏障点后再同时执行。Semaphore：用于控制同时访问某个资源的线程数量。ConcurrentHashMap：线程安全的HashMap实现，用于在多线程环境下安全地操作Map。 通过合理地使用并发工具类，可以简化多线程编程的复杂性，提高程序的并发性能和可靠性。
二、Java高级特性与框架应用
Lambda表达式 Lambda表达式是Java 8引入的一个重要特性，可以简化代码编写，提高代码的可读性和简洁性。Lambda表达式主要用于创建函数式接口的实例。
// 使用Lambda表达式实现一个简单的接口 interface MyInterface { void doSomething(); } public class LambdaExample { public static void main(String[] args) { // 使用Lambda表达式实现接口方法 MyInterface myInterface = () -&gt; System.out.println("Doing something"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/899ef191a409a7a0a34c2ebd5d599e14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe2a6ec9412bc3463e72ca7619a41f4/" rel="bookmark">
			一文教会你用Stable Diffusion做个性化头像丨使用ControlNet插件和IP-Adapter模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来看看这个简单有趣的指南吧，它会教你怎样给自己的头像加点儿创意，使用Stable Diffusion、ControlNet和IP-Adapter塑造风格化的头像，让你的头像更有特色，更有趣。
前置条件
验证ControlNet和IP-Adapter
创建个性化头像
比较不同风格的头像
个性化头像的示例
1. 前置条件 在我们踏上这趟激动人心的面部肖像塑形之旅之前，先来确保你已经准备好了所需的基本条件。下面就是使用ControlNet和IP-Adapter技术的一些关键要求：
ControlNet 开始之前，最重要的一点是您需安装ControlNet扩展，它是我们的核心。
IP-Adapter面部模型 为了有效地传输和操作你的面部特征，你需要一个专为面部设计的IP-Adapter模型。
这个模型在准确展现你的面部表情和特征方面非常关键。下载方式请看文末
注意:safetensors文件需要最新版本的ControlNet才能正常工作。确保您“检查更新”，并重新启动UI以更新ControlNet扩展到最新版本。
IP-Adapter的文件位置 下载“ip-adapter-plus-face_sd15.safetensors”后，您需要把它放到以下文件夹中：
stable-diffusion-webui\extensions\sd-webui-controlnet\models
完成以上这些，为顺畅地创造个性化头像奠定了基础。
2. 验证ControlNet和IP Face Adapter 现在，ControlNet扩展和IP-Adapter模型已成功安装，让我们继续验证它们在Stable Diffusion Web UI中的可见性。切换到“txt2img”或“img2img”选项卡，向下滚动时，您可以看到ControlNet扩展的展开面板。
ControlNet扩展和IP Face Adapter模型 打开此面板并选择“IP-Adapter”控制类型时，请确保可以选择“ip-adapter-plus-face_sd15”模型。
故障排除 如果由于任何原因您没有在选项中找到此模型，您可以尝试两件事:
点击右侧的蓝色刷新图标以更新模型。
如果模型仍然不可见，请仔细检查“ip-adapter-plus-face_sd15”文件的放置位置，以确保其位于第1节中提到的正确文件夹中。
当用户界面上的一切看起来都正确时，我们可以开始创建我们的第一张风格人像照了。让我们试一试!
3. 创建个性化头像 在本节中，我们将深入探讨使用ControlNet画布和IP-Adapter技术创建个性化头像的过程。
让我们执行以下操作:
ControlNet设置 从开始，将您首选的头像（面部的）放在ControlNet的Unit0画布上。
启用ControlNet，选中“Enable”复选框。
启用“Pixel Perfect”。
将“Control Type”选择为“IP-Adapter”。
选择“ip-adapter-plus-face_sd15”模型。
将ControlNet的其余设置保留为默认值。
在我们的初始示例中，我们将以安吉丽娜·朱莉为面部模特。
为了提升效果，创建一个反映传统摄影棚面部肖像的提示。
在这次的尝试中，我们继续采用ToonYou Checkpoint模型用于可爱的卡通效果。下载地址：
https://civitai.com/models/30240/toonyou
样式面部肖像示例 面部肖像提示和设置 正面提示 best quality, beautiful, 30 year old woman, (full face portrait:1.2), face portrait, detailed face, freckles, (facing camera), (looking into the camera), studio portrait, natural lightning, perfect shadows
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe2a6ec9412bc3463e72ca7619a41f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b171587cfb79cb0088a5cf96eca74a0/" rel="bookmark">
			探索SQLiteStudio：一款强大的SQLite数据库管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索SQLiteStudio：一款强大的SQLite数据库管理工具 项目地址:https://gitcode.com/pawelsalawa/sqlitestudio
SQLiteStudio是一款免费、开源且跨平台的SQLite数据库管理工具，它的链接是https://gitcode.com/pawelsalawa/sqlitestudio。本文将深入解析其功能、技术实现和应用场景，以期吸引更多用户了解并使用它。
项目概述 SQLiteStudio是由Paweł Salawa开发的一个直观且高效的数据库管理界面，支持Windows、Mac OS X及Linux等操作系统。它提供了一个图形化用户界面（GUI），使得数据库操作变得简单易行，适合开发者、数据分析师乃至普通用户进行数据存储和查询。
技术分析 图形化界面：SQLiteStudio采用了现代UI设计，提供了清晰的结构视图，便于用户浏览和管理表、视图及索引。
实时连接与编辑：它支持直接连接到本地或远程SQLite数据库，并允许用户实时创建、修改和删除数据记录，无需编写复杂的SQL语句。
SQL编辑器：内置的SQL编辑器支持自动完成、语法高亮和错误检查，提升了编写SQL脚本的效率。
数据导出导入：SQLiteStudio提供多种数据格式的导入/导出功能，如CSV、XML、JSON等，方便数据交换和备份。
加密支持：支持对数据库文件进行AES加密，保护敏感数据的安全。
版本控制集成：可以与Git等版本控制系统集成，方便团队协作和追踪数据库变更。
应用场景 快速原型开发：对于开发初期，使用SQLiteStudio可以快速搭建和测试数据库模型。
个人数据存储：作为轻量级的数据库解决方案，适用于个人项目或简单的数据存储需求。
教学与学习：初学者可以通过此工具熟悉SQL语言和数据库管理概念。
移动应用后端：许多移动应用使用SQLite作为本地数据库，SQLiteStudio可作为配套的管理工具。
数据分析：在对小规模数据集进行探索性数据分析时，SQLiteStudio是一个便捷的工具。
特点总结 易用性：界面简洁，操作直观，适合各层次用户。
功能性：提供全面的数据库管理功能，包括创建、查询、备份和恢复。
跨平台：支持Windows、macOS和Linux等多种操作系统。
开源免费：开放源代码，可自由使用和二次开发。
安全可靠：支持数据加密，保证数据安全性。
通过上述介绍，我们了解到SQLiteStudio是一个强大而实用的SQLite数据库管理工具。无论你是开发新手还是经验丰富的数据专家，都能从中受益。现在就访问给出的链接，开始你的SQLite之旅吧！
项目地址:https://gitcode.com/pawelsalawa/sqlitestudio
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414cb1d5f4d967911a51f337284a3039/" rel="bookmark">
			Python 中的 AttributeError: ‘module‘ object has no attribute 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中，当尝试访问不存在的模块属性时，可能会遇到 AttributeError: 'module' object has no attribute 错误。这个问题通常出现在以下情况：
试图访问一个尚未导入的模块。试图访问一个模块中不存在的属性。试图访问一个已导入模块的属性，但该属性尚未被初始化。
解决方案 解决 AttributeError: 'module' object has no attribute 错误的方法有很多，具体取决于错误发生的具体情况。
1. 导入所需的模块 如果错误是由于尚未导入所需的模块引起的，则只需使用 import 语句导入该模块即可。例如：
import my_module # 现在可以使用 my_module 中的属性和函数了 2. 确保模块中的属性已被初始化 如果错误是由于试图访问一个尚未被初始化的模块属性引起的，则需要确保在使用该属性之前对其进行初始化。例如：
# 定义一个名为 `my_attribute` 的属性 my_module.my_attribute = "Hello, world!" # 现在可以使用 my_module.my_attribute 了 3. 使用正确的模块属性名 如果错误是由于试图访问一个模块中不存在的属性引起的，则需要检查模块的文档或源代码以确保该属性确实存在。如果该属性不存在，则无法访问它。
4. 使用 from 语句导入模块 from 语句允许从模块中导入特定的属性或函数，而无需导入整个模块。这可以帮助避免意外导入不必要的属性或函数。例如：
from my_module import my_function # 现在可以使用 my_function 了 5. 使用 __init__.py 文件 在 Python 中，目录中的 __init__.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/414cb1d5f4d967911a51f337284a3039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f8e70c2661ef6e8e6aac168553cfd3/" rel="bookmark">
			探索FlareSolverr：一款强大的Web Scrapper 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索FlareSolverr：一款强大的Web Scrapper 解决方案 项目简介 是一个开源的、基于Docker的反爬虫代理服务器，旨在解决现代网站中复杂的JavaScript渲染和封锁问题，使得数据抓取更加高效和便捷。通过使用FlareSolverr，开发者可以绕过许多网站的反爬机制，轻松获取所需信息。
技术分析 基于Docker FlareSolverr的设计考虑到了可移植性和易部署性，它使用Docker容器化技术。这意味着您只需要一个支持Docker的环境，就可以快速启动并运行FlareSolverr，无需关心底层操作系统或依赖项冲突的问题。
Puppeteer 库 FlareSolverr的核心是Google的Puppeteer库，这是一个Node.js库，提供了高级API来控制Chromium或Chrome浏览器。通过Puppeteer，FlareSolverr能够模拟真实浏览器的行为，包括执行JavaScript、处理cookies、加载异步内容等，从而应对那些需要完整浏览器渲染才能显示的数据。
RESTful API 设计 该项目提供了一个简洁的RESTful API接口，允许与其他应用程序（如Scrapy, Python爬虫，甚至其他语言的应用）无缝集成。这种设计使得FlareSolverr易于集成到现有的工作流程中。
可配置的反检测策略 FlareSolverr内置了多种反检测策略，以适应不同网站的防爬规则。这些策略可以根据实际需求进行调整，确保在保持高效率的同时降低被封禁的风险。
应用场景 Web 数据抓取：无论是新闻聚合，电商比价，还是市场研究，FlareSolverr都能帮助开发者高效地提取所需数据。SEO 分析：通过对竞争对手的网页内容进行抓取，可以分析关键词分布，优化SEO策略。自动化测试：在需要模拟用户交互的测试场景中，FlareSolverr可以生成真实的浏览行为。数据备份与存档：对于在线内容，定期抓取可以作为长期存档和备份的手段。 特点 跨平台：由于采用Docker，FlareSolverr可在任何支持Docker的操作系统上运行。高速渲染：利用Puppeteer的强大功能，FlareSolverr能快速解析和执行JavaScript代码。易于扩展：开发者可以通过自定义插件或扩展功能来适应特定的抓取需求。社区支持：作为开源项目，FlareSolverr有活跃的社区，不断更新改进，并提供及时的技术支持。 结语 FlareSolverr是一个强大且灵活的工具，对于需要处理复杂网页抓取任务的开发者来说，无疑是一大利器。借助它的力量，您可以更有效地与动态网站互动，获取宝贵的信息。我们鼓励有兴趣的朋友们尝试并参与到FlareSolverr的社区中，共同推动其发展。
让我们一起探索Web抓取的新边界！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c87c1cd64ea36eb5c32a53da896769/" rel="bookmark">
			压缩神器：Compressor.js - 优化你的Web图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压缩神器：Compressor.js - 优化你的Web图像 是一个轻量级且强大的JavaScript库，它专为Web开发者设计，用于在浏览器端压缩图片和PNG、JPG、WEBP等文件。这个项目的目的是帮助我们减小网页加载时间，提高用户体验，尤其是在移动设备上的表现。
技术分析 Compressor.js 使用HTML5的FileReader API和Canvas元素来实现图片处理。它支持两种压缩算法：基于质量的压缩（quality-based compression）和基于WebP的无损压缩（lossless WebP compression）。通过动态调整图片质量和尺寸，Compressor.js可以在不影响视觉效果的前提下，显著降低图片的大小。
此外，该库还提供了一个易于使用的API，允许开发者自定义压缩参数，如最大宽度/高度、质量、目标类型等，并可以实时预览压缩结果。
const compressor = new Compressor(file, { quality: 0.8, maxWidth: 800, maxHeight: 600, success(result) { console.log(result.base64); // 压缩后的base64编码 }, error(err) { console.error(err); }, }); 应用场景 图片上传 - 在网站或应用程序中，当用户上传图片时，可以先使用Compressor.js进行压缩，然后再发送到服务器，减少网络传输的数据量。响应式设计 - 根据用户的设备屏幕尺寸，自动调整并压缩图片，确保快速加载。图像编辑工具 - 集成到在线图片编辑应用中，提供即时的图片压缩功能。数据存储优化 - 如果你的应用需要在本地存储大量图像，压缩图片可以节省大量的存储空间。 特点 跨平台：适用于所有现代浏览器，包括移动设备。简单易用：简洁的API设计，使得集成到现有项目中非常直观。高效：原生JavaScript实现，运行速度快。可定制性：支持多种压缩策略，满足不同需求。兼容性：支持各种常见的图片格式。 结语 Compressor.js 以其高效、灵活的特点，成为了前端开发者优化Web性能的得力助手。无论你是初学者还是经验丰富的开发人员，都可以轻松地将这个项目集成到你的项目中，提升用户体验。尝试一下 ，为你的Web应用带来更快的加载速度吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9205b20489787253436662eb4973d18d/" rel="bookmark">
			Java反应式框架Reactor中的Mono和Flux，2024年最新Java面试精讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于响应流的特点，我们不能再返回一个简单的POJO对象来表示结果了。必须返回一个类似Java中的Future的概念，在有结果可用时通知消费者进行消费响应。
Reactive Stream规范中这种被定义为Publisher&lt;T&gt; ，Publisher&lt;T&gt;是一个可以提供0-N个序列元素的提供者，并根据其订阅者Subscriber&lt;? super T&gt;的需求推送元素。一个Publisher&lt;T&gt;可以支持多个订阅者，并可以根据订阅者的逻辑进行推送序列元素。下面这个Excel计算就能说明一些Publisher&lt;T&gt;的特点。
A1-A9就可以看做Publisher&lt;T&gt;及其提供的元素序列。A10-A13分别是求和函数SUM(A1:A9)、平均函数AVERAGE(A1:A9)、最大值函数MAX(A1:A9)、最小值函数MIN(A1:A9)，可以看作订阅者Subscriber。假如说我们没有A10-A13，那么A1-A9就没有实际意义，它们并不产生计算。这也是响应式的一个重要特点：当没有订阅时发布者什么也不做。
而Flux和Mono都是Publisher&lt;T&gt;在Reactor 3实现。Publisher&lt;T&gt;提供了subscribe方法，允许消费者在有结果可用时进行消费。如果没有消费者Publisher&lt;T&gt;不会做任何事情，他根据消费情况进行响应。 Publisher&lt;T&gt;可能返回零或者多个，甚至可能是无限的，为了更加清晰表示期待的结果就引入了两个实现模型Mono和Flux。
4. Flux
Flux 是一个发出(emit)0-N个元素组成的异步序列的Publisher&lt;T&gt;,可以被onComplete信号或者onError信号所终止。在响应流规范中存在三种给下游消费者调用的方法 onNext, onComplete, 和onError。下面这张图表示了Flux的抽象模型：
以上的的讲解对于初次接触反应式编程的依然是难以理解的，所以这里有一个循序渐进的理解过程。
有些类比并不是很妥当，但是对于你循序渐进的理解这些新概念还是有帮助的。
传统数据处理 我们在平常是这么写的：
public List allUsers() {
return Arrays.asList(new ClientUser(“felord.cn”, “reactive”),
new ClientUser(“Felordcn”, “Reactor”));
}
我们通过迭代返回值List来get这些元素进行再处理（消费），这种方式有点类似厨师做了很多菜，吃不吃在于食客。需要食客主动去来吃就行了（pull的方式），至于喜欢吃什么不喜欢吃什么自己随意，怎么吃也自己随意。
流式数据处理 在Java 8中我们可以改写为流的表示：
public Stream allUsers() {
return Stream.of(new ClientUser(“felord.cn”, “reactive”),
new ClientUser(“Felordcn”, “Reactor”));
}
依然是厨师做了很多菜，但是这种就更加高级了一些，提供了菜品的搭配方式（不包含具体细节），食客可以按照说明根据自己的习惯搭配着去吃，一但开始概不退换，吃完为止，过期不候。
反应式数据处理 在Reactor中我们又可以改写为Flux表示：
public Flux allUsers(){
return Flux.just(new ClientUser(“felord.cn”, “reactive”),
new ClientUser(“Felordcn”, “Reactor”));
}
这时候食客只需要订餐就行了，做好了自然就呈上来，而且可以随时根据食客的饭量进行调整。如果没有食客订餐那么厨师就什么都不用做。当然不止有这么点特性，不过对于方便我们理解来说这就够了。
5. Mono
小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9205b20489787253436662eb4973d18d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3c0a99c74b408cdad6d5f39e15f21b3/" rel="bookmark">
			【C/C&#43;&#43;】详解 assert() 断言（什么是assert? assert有什么作用？）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、什么是 assert ? 三、assert 的用法
四、assert 案例解析
五、assert 断言的使用原则
六、共勉 一、前言 在编写程序过程中，尤其是调试代码时，往往需要一个提醒代码漏洞/Bug的小助手，以便于程序员及时修改和完善代码。那么assert关键字就可以成为这个小助手。
二、什么是 assert ? 概念：C/C++ 中的 assert 是一个宏，用于在运行时检查一个条件是否为真，如果条件不满足，则运行时将终止程序的执行并输出一条错误信息。
assert 宏定义在 &lt;assert.h&gt; 或 &lt;cassert&gt; 头文件中，并接受一个参数，通常为一个语句。如果这个语句的结果为 false，assert 宏就会以"Assertion failed: , file , line "的形式显示出错信息，然后使程序崩溃并终止运行。如果该语句的结果为 true，则 assert 宏不做任何操作。 作用： assert 宏的使用可以帮助程序员检查程序的正确性，并提供帮助定位错误的一种手段。通常在程序编写的测试与调试阶段使用 assert 来追踪程序执行中的错误，并在最终发布程序时关闭 assert 检查，以提升程序的运行效率。
三、assert 的用法 语法：
assert(condition);condition：要判断的条件 说明：
a、如果condition判断结果为false，则程序就会停止执行。b、当程序停止执行时，assert就会断言失败，并输出一条程序的错误信息到控制台或日志文件中。c、assert关键字常常用于调试程序阶段，可以用来帮助程序员在程序出现异常或错误时，快速定位问题所在，以便于检查和就修改完善。d、而在程序正常部署后，assert一般就会被自动关闭。 四、assert 案例解析 案例1 ： 比大小
#include &lt;cassert&gt; #include &lt;iostream&gt; using namespace std; int main() { int a = 10, b = 20; assert(a &gt; b); // 条件不成立，程序会终止 cout &lt;&lt; a + b &lt;&lt; endl; return 0; } 在这个例子中，条件 a &gt; b 不成立，程序就会在 assert 这个语句处崩溃，输出一条相应的错误信息。 案例2 ： 模拟 strlen() 函数 /*例程1*/ #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3c0a99c74b408cdad6d5f39e15f21b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0097de95b8ecf722eb14541fca815b96/" rel="bookmark">
			Flink RocksDB状态后端优化总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截至当前，Flink 作业的状态后端仍然只有 Memory、FileSystem 和 RocksDB 三种可选，且 RocksDB 是状态数据量较大（GB 到 TB 级别）时的唯一选择。RocksDB 的性能发挥非常仰赖调优，如果全部采用默认配置，读写性能有可能会很差。
但是，RocksDB 的配置也是极为复杂的，可调整的参数多达百个，没有放之四海而皆准的优化方案。如果仅考虑 Flink 状态存储这一方面，我们仍然可以总结出一些相对普适的优化思路。本文先介绍一些基础知识，再列举方法。
Note：本文的内容是基于我们在线上运行的 Flink 1.9 版本实践得出的。在1.10版本及以后，由于 TaskManager 内存模型重构，RocksDB 内存默认成为了堆外托管内存的一部分，可以免去一些手动调整的麻烦。如果性能仍然不佳，需要干预，则必须将 state.backend.rocksdb.memory.managed 参数设为 false 来禁用 RocksDB 内存托管。
Stae R/W on RocksDB RocksDB 作为 Flink 状态后端时的读写逻辑与一般情况略有不同，如下图所示。
Flink 作业中的每一个注册的状态都对应一个列族（column family），即包含自己独立的 memtable 和 sstable 集合。写操作会先将数据写入活动 memtable，写满之后则会转换为不可变 memtable，并 flush 到磁盘中形成 sstable。读操作则会依次在活动 memtable、不可变 memtable、block cache 和 sstable 中寻找目标数据。另外，sstable 也需要通过 compaction 策略进行合并，最终形成分层的 LSM Tree 存储结构，老生常谈了。
特别地，由于 Flink 在每个检查点周期都会将 RocksDB 的数据快照持久化到文件系统，所以自然也就不需要再写预写日志（WAL）了，可以安全地关闭WAL与fsync。
之前笔者已经详细讲解过 RocksDB compaction 策略，并且提到了读放大、写放大和空间放大的概念，对 RocksDB 的调优本质上就是在这三个因子之间取得平衡。而在 Flink 作业这种注重实时性的场合，则要重点考虑读放大和写放大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0097de95b8ecf722eb14541fca815b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac75bcdc12b7c54efa4839bf809724e/" rel="bookmark">
			AI学习笔记之七：探秘无监督学习的原理、常用算法及实现解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无监督学习也称为无监督机器学习，是机器学习领域中的重要分支之一，它使用机器学习算法来分析未标记的数据集并进行聚类。
与有监督学习和强化学习不同，无监督学习的数据集中不包含任何人工标注的目标值或反馈信号。
无监督学习算法需要从原始数据中自主发现内在结构、模式或知识。这种“自主学习”的范式更贴近人类自主学习的方式，使得无监督学习在许多应用场景都有独特的优势，这种方法能够发现信息的相似性和差异性，因而是探索性数据分析、交叉销售策略、客户细分和图像识别的理想解决方案。
1. 无监督学习的原理 无监督学习的核心思想是通过对数据的统计特征、相似度等进行分析和挖掘，利用密度估计、聚类和降维等技术来捕获和发现数据隐藏的内在结构和模式。
无监督学习的主要原理可以概括为:
密度估计(Density Estimation)
密度估计是无监督学习的一个基本问题。它旨在估计样本数据的概率密度函数，从而刻画数据的整体分布特征。常用的密度估计方法包括核密度估计、高斯混合模型、K-近邻等。掌握了数据分布，就能发现异常数据点、检测新观测值等。
聚类(Clustering)
聚类是将数据集中的样本划分为若干个类别的过程，使得同一类别内的样本相似度较高，不同类别之间的样本相似度较低。在聚类过程中，每个样本点都被视为一个向量，聚类算法通过计算样本之间的距离或相似度，将相似的样本归为同一类别。常见的聚类算法包括K均值聚类、层次聚类、DBSCAN、高斯混合模型等。聚类分析有助于发现数据的内在组织结构。
降维(Dimensionality Reduction)
数据常常存在维度灾难的问题，即特征空间过高导致计算复杂度和数据稀疏性增加。降维技术通过数学上的投影等方式将高维数据映射到一个低维空间，在减少数据的维度的同时保留数据的原始结构和特征关系，从而简化后续处理。主成分分析(PCA)、t-SNE等都是常用的无监督降维方法。
表示学习(Representation Learning)
表示学习旨在从原始数据中自动学习出良好的特征表示，使得表示空间中相似的样本更易于被区分和聚类。自编码器(AutoEncoder)就是一种常用的无监督神经网络模型，能够有效地学习出高质量的数据表示。
无监督学习算法通常会以无约束或少量约束的方式优化某些目标函数，如最大化数据对数似然、最小化重构误差等，从而捕获数据的本质结构和模式。得益于深度学习技术的发展，无监督表示学习逐渐成为研究的热点。
2. 无监督学习的常用核心算法 2.1. K-Means聚类算法（K均值聚类）
K-Means是最常用和最简单的聚类算法之一，它是一种基于中心点的聚类方法，它将样本分配给离其最近的K个中心点所对应的簇。该算法的核心步骤包括初始化中心点、分配样本到最近的中心点所在的簇、更新中心点位置，使得簇内样本间的平方和最小。K均值聚类适用于数据集中各个簇的形状近似球形、大小相似的情况。
一般算法步骤如下:
随机初始化k个聚类中心重复以下步骤直到收敛: 将每个样本分配到与之最近的聚类中心重新计算每个簇的聚类中心 K-Means具有简单高效的优点，但也存在一些缺陷,如对噪声和异常值敏感、需要预先指定簇数k等。
2.2 层次聚类算法
层次聚类算法通过逐步合并或分裂簇来构建一个层次化的聚类树状结构。主要分为两种策略:
凝聚层次聚类(底至顶)：从每个样本作为一个簇开始,逐步合并最相似的簇分裂层次聚类(顶至底)：从所有样本作为一个簇开始,逐步将离散程度最高的簇进行分裂 常用的相似性度量包括最小距离、最大距离、平均距离等。需要事先确定一个合理的terminated条件来决定最终的聚类数目。
2.3. 高斯混合模型(GMM)
GMM假设整个数据服从一个由多个高斯分布混合而成的概率分布模型。可以使用期望最大化(EM)算法来估计每个高斯分布的参数(均值、协方差)和所占的混合权重。模型估计完成后，每个样本可以基于后验概率被"软分配"到不同的高斯分布中。GMM广泛应用于聚类、密度估计等任务。
2.4. 主成分分析(PCA)
PCA是一种常用的无监督降维和数据表示技术。其主要思想是将原始数据通过线性变换投影到一组相互正交的低维空间中，使得投影后数据的方差最大化。PCA的主要思想是找到数据中最主要的特征，即主成分，以降低数据的维度。具体步骤包括:中心化数据、计算协方差矩阵、求解特征值和特征向量、选取方差贡献度最大的前k个主成分等。PCA常被用于数据可视化、压缩和特征提取的预处理步骤。
2.5. t-SNE
t-SNE(t-分布随机邻域嵌入)是一种较新的非线性降维技术，能够有效地保留原始高维数据的局部邻域结构。首先计算高维空间样本之间的相似度，然后在低维空间中最小化相似度与映射后距离之间的KL散度。t-SNE常用于可视化高维数据，辅助探索数据的内在分布和聚类结构。
2.6. 自编码器(AutoEncoder)
自编码器是一种基于人工神经网络的无监督表示学习模型。其由编码器和解码器组成，编码器将输入数据映射到隐含层的低维表示,解码器则试图重构原始输入。通过最小化输入和重构之间的损失函数，自编码器能够自动学习出对应问题的良好特征表示。堆叠自编码器、变分自编码器等都是基于这一思想的扩展。
3. 无监督学习的实现 3.1 K均值聚类的实现
下面我们通过一个基于Python的K-Means聚类算法实例，来更直观地理解无监督学习。
import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.datasets import make_blobs # 生成样本数据 X, y = make_blobs(n_samples=500, centers=4, n_features=2, random_state=0) # 初始化K-Means模型 kmeans = KMeans(n_clusters=4, random_state=0) # 训练K-Means模型 kmeans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac75bcdc12b7c54efa4839bf809724e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc1c50225666bd2f564454410a1246c/" rel="bookmark">
			彻底讲透：高并发场景下，MySQL处理并发修改同一行数据的安全方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在高并发场景下，MySQL处理并发修改同一行数据的安全方法主要有以下几种：
悲观锁（Pessimistic Locking）：
使用SELECT ... FOR UPDATE语句，在事务中锁定需要修改的行。这样其他事务在该行被解锁之前无法对其进行修改。 ```sql START TRANSACTION; SELECT * FROM table WHERE id = ? FOR UPDATE; 根据查询结果进行更新操作 UPDATE table SET column = value WHERE id = ?; COMMIT; 这种方式在并发环境下可以确保每次只有一个事务能修改特定的数据行，但可能造成大量的锁等待，从而影响并发性能。 乐观锁（Optimistic Locking）：
乐观锁不阻止并发访问，而是在更新时检查自上次读取以来数据是否已被修改。实现上通常通过一个额外的版本号字段或时间戳字段来完成。在MySQL中，可以通过在表中增加一个version字段，并在更新时判断version值是否未变来实现乐观锁。 CREATE TABLE my_table ( id INT PRIMARY KEY, data VARCHAR(50), version INT DEFAULT 0 ); -- 更新时使用版本号作为条件 UPDATE my_table SET data = 'new_value', version = version + 1 WHERE id = ? AND version = ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc1c50225666bd2f564454410a1246c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6c4424e2ff22ba52bba314c59ba131f/" rel="bookmark">
			vue系列——vscode,node.js vue开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode,node.js vue开发环境搭建 第一步安装node.js第二步 安装镜像cnpm第四步 安装vue/cli脚手架5.创建vue项目6.运行vue项目vscode vue插件安装集合如果 vue 文件中不能加断点，是由于 vscode 配置问题导致 第一步安装node.js 推荐使用nvm进行node.js 的安装
nvm(Node.js version manager) 是一个命令行应用，可以协助您快速地 更新、安装、使用、卸载 本机的全局 node.js 版本。
可以去网上查找相关版本
我这里使用
nvm-setu…
链接:https://pan.baidu.com/s/1UEUtmzw5xpyl6jlPMm3Xqw?pwd=12ow
提取码:12ow
点击安装好后
命令行
nvm ls 查看已安装node.js版本
nvm list available 查看可安装版本
nvm install 21.3.0 安装
nvm use 21.3.0 使用
第二步 安装镜像cnpm 命令行
npm install -g cnpm --registry=https://registry.npmmirror.com
如过报错
解决方案
清空相关代理，http-proxy 和 proxy
npm config delete https-proxy
npm config delete proxy
查看配置代理结果
npm config get proxy
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6c4424e2ff22ba52bba314c59ba131f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52cfb7e721f23056f58e30b3444e99f/" rel="bookmark">
			【MySQL】学习和总结使用列子查询查询员工工资信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: Aileen_0v0
🔥热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法
​💫个人格言:“没有罗马,那就自己创造罗马~”
ignorant of不知道 文章目录 `子查询``子查询类型``根据结果类型分类``列子查询``Exercises1``Exercises2``Exercises3` 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击👉跳转到网站 子查询 概念:SQL语句中嵌套SELECT语句,称为嵌套查询,又称子查询. SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM 12); 子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个. 子查询类型 根据结果类型分类 列子查询 子查询返回的结果是一列 (可以是多行),这种子查询称为:列子查询.常用操作符: IN , NOT IN , ANY , SOME , ALL 操作符描述IN在指定的集合范围内,多选一NOT IN 不在指定集合范围内ANY子查询返回列表中,有任意一个满足即可SOME与ANY等同,使用SOME的地方都可以使用ANYALL子查询返回列表的所有值都必须满足 Exercises1 -- 1.查询 "销售部" 和 "市场部" 的所有员工信息 -- a. 查询 '销售部' 和 '市场部' 的id select id from dept where name = '销售部' or name = '市场部'; -- b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52cfb7e721f23056f58e30b3444e99f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c08878b0d40f53dddaab843324a66a/" rel="bookmark">
			每日一看大模型新闻（2024.1.20-1.21）英伟达新对话QA模型准确度超GPT-4，却遭吐槽：无权重代码意义不大；Llama 2打败GPT-4！Meta让大模型自我奖励自迭代，再证合成数据是LL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.产品发布 1.1韩国Kakao：推出多模态大模型Honeybee 发布日期：2024.1.20
Kakao unveils multimodal large language model Honeybee - The Korea Times
主要内容：韩国科技巨头Kakao今天宣布他们已经开发了一种名为“蜜蜂”（Honeybee）的多模态大语言模型。据Kakao称，“蜜蜂”能够同时理解图像和文本，回复与图像和文本内容混合相关的咨询。该模型代码已在开源社区GitHub上发布。
2.技术更新 2.1英伟达新对话QA模型准确度超GPT-4，却遭吐槽：无权重代码意义不大 发布日期：2024.1.21
英伟达新对话QA模型准确度超GPT-4，却遭吐槽：无权重代码意义不大
主要内容：一年多来，ChatGPT及后续产品引领了问答（QA）模型的范式转变。它们能以对话方式交互、提出后续问题，并能在开放域或长文档中集成检索到的证据块。然而，构建一个与SOTA黑箱模型如GPT-4等效的对话QA模型仍是挑战。最近，英伟达的研究提出了具有GPT-4水平准确度的白箱对话QA模型ChatQA 70B。该模型采用了两阶段指令调优方法和用于对话QA的RAG增强检索器，以及严格的数据管理过程。研究显示，ChatQA-70B在10个对话QA数据集上的表现优于或接近GPT-3.5-turbo和GPT-4，且不依赖OpenAI的合成数据。尽管有这些成就，社区对英伟达不公开模型权重和代码持批评态度。
论文地址：https://huggingface.co/papers/2401.10225
2.2 AI看视频自动找“高能时刻” 发布日期：2024.1.21
AI看视频自动找“高能时刻”｜字节&amp;中科院自动化所@AAAI 2024
主要内容：字节跳动与中科院自动化研究所合作，开发了一种AI技术，能快速识别视频中的高光片段。这项研究的成果被AAAI 2024收录。他们创建了一个名为LiveFood的美食视频数据集用于训练，并提出了一种叫GPE的方法。GPE能够灵活地检测不同长度视频中的亮点部分，克服了传统方法的一些限制。通过在图像帧级别打分，GPE可以有效地定位到视频中的精彩瞬间。该技术在美食制作、展示和享用等场景中特别有用。研究人员收集了大量美食视频，并对高光时刻进行了标注以训练模型。GPE减少了深度学习中的遗忘问题，并在基准测试中展现了优异的性能。
2.3 Stability AI杀回来了：视频生成新Demo效果惊人 发布日期：2024.1.21
Stability AI杀回来了：视频生成新Demo效果惊人，网友：一致性超群
主要内容：Stability AI的CEO Emad Mostaque发布了一些视频，引发了网友对其新版本Stable Video Diffusion的猜测。这些视频展示了惊人的画面清晰度、一致性和流畅度：如一个毛绒熊在潜水，动作流畅，甚至还眨眼。此外，还有丰富的海水细节和一个动漫风格的夜晚街道。现在的Demo显示，机器人、杯子、灯盏和床被枕头的细节都更为丰富，机器人脸上也有光影映射。同时，Stability AI还发布了一个只有16亿参数的小语言模型StableLM2 1.6B，经过多语种训练。频繁的进展让人们怀疑Stability AI是否要翻身。
体验地址：Runway - Advancing creativity with artificial intelligence.
2.4 GPT-4V惨败！CV大神谢赛宁新作：V*重磅「视觉搜索」算法让LLM理解力逼近人类 发布日期：2024.1.20
GPT-4V惨败！CV大神谢赛宁新作：V*重磅「视觉搜索」算法让LLM理解力逼近人类
主要内容：Sam Altman在世界经济论坛上表示，人类级别的AI即将到来。然而，目前的AI模型在图像理解方面还存在问题，比如无法准确识别复杂场景中的特定物体。为此，研究人员提出了V*模型和SEAL框架，通过引导视觉搜索机制来提高多模态LLM的图像理解能力。实验结果显示，这些方法在处理高分辨率图像中具有优势，有助于推动AI向人类智能迈进。
参考资料：https://arxiv.org/abs/2312.14135
3.商业动态 3.1清华、小米、华为、 vivo、理想等多机构联合综述，首提个人LLM智能体、划分5级智能水平 发布日期：2024.1.21
清华、小米、华为、 vivo、理想等多机构联合综述，首提个人LLM智能体、划分5级智能水平
主要内容：该文总结了对常见问题的专家意见，包括部署个人LLM智能体的设计选择和潜在挑战。专家认为将LLM在边缘-云协同部署是首选，而纯云并不是一个被广泛接受的解决方案。在定制化方面，人们最接受的方法是组合使用微调和上下文学习。对于个人LLM智能体，最重要的能力是语言理解，而最不重要的能力是处理长上下文的能力。基于语音的交互是最受欢迎的方式，而理想智能体应具备高效的数据管理和搜索、工作和生活辅助、个性化服务和推荐、自动化任务规划和完成、情感支持和社交互动等关键功能。最紧迫的技术挑战包括智能、性能、安全和隐私、个性化和存储、传统操作系统支持等方面。个人LLM智能体需要具备任务执行、情境感知和记忆等基本能力，并需要针对效率进行优化。
论文地址：https://arxiv.org/abs/2401.05459
文献库：GitHub - MobileLLM/Personal_LLM_Agents_Survey: Paper list for Personal LLM Agents
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c08878b0d40f53dddaab843324a66a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c8247f35b7328f5d85222577a07503/" rel="bookmark">
			MacBook 安装多版本Python和版本切换详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac苹果电脑安装多版本Python和版本切换详解 文章概要：本文详细讲解了如何在macbook电脑上通过homebrew安装多版本python，以及如何切换多版本，在不同项目使用不同版本python。
本文内容来自：谷流仓AI - ai.guliucang.com
前提条件 使用电脑：苹果电脑MacOS需要安装好homebrew并设置好镜像源(具体如何安装homebrew参考这篇文章, 安装过程中会提示选择什么镜像源，选中科大镜像比较快) 安装python 搜索可用python
brew search python 可以看到python@3.7到python@3.12都有，确定自己需要版本， 比如python3.8, 输入如下命令安装：
# 安装 brew install python@3.8 # 查看安装结果： ls -l /opt/homebrew/bin | grep python3 # 或者可以用以下命令看一下目前python3的版本 python3 -V 可以看到python3各个版本指向的位置。
切换全局python版本 如果安装了多个版本的python，该如何切换版本呢？
可以通过以下步骤来操作， 以我的电脑目前状态为例：
查看python全局版本指向
which 命令会在你的环境变量 $PATH 中搜索给定命令的位置。所以我们通过which来找： 输入which python, 输出结果为 /usr/local/bin/python。
然后查看一下这个python的具体指向，输入ls -l /usr/local/bin/python, 输出结果为
/usr/local/bin/python -&gt; ../../../Library/Frameworks/Python.framework/Versions/2.7/bin/python 所以python命令最终指向上面的2.7版本的python。我们输入python -V, 输出结果为Python 2.7.13。所以这个指向链就是这样的。
输入which python3, 输出结果为/opt/homebrew/bin/python3；
查看/opt/homebrew/bin/python3文件的指向：
ls -l /opt/homebrew/bin/python3 # 输入出结果如下 # /opt/homebrew/bin/python3 -&gt; /opt/homebrew/bin/python3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83c8247f35b7328f5d85222577a07503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994e05553ac076d43d8bf9352bf9b340/" rel="bookmark">
			浅谈前端路由原理hash和history
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、认识前端路由 本质
前端路由的本质，是监听 url 地址或 hash 值的改变，来切换渲染对应的页面组件
前端路由分为两种模式 hash 模式history 模式 两种模式的对比
对比hash 模式history 模式url 显示url 中带"#"url 中不带"#"回车刷新（浏览器刷新按钮）页面正常显示后端未配置则页面显示404支持版本支持低版本浏览器和 IE 浏览器HTML5 新推出的 API 2、hash 模式 （1）hash 定义 hash 模式是一种把前端路由的路径用 # 拼接在真实 url 后面的模式
在hash模式下，本质上是修改window.location.href实现的。
前端路由的改变依托于#锚点，而锚点后边的值我们可以通过修改window.location.hash的值来修改，每一次hash值的变化都会导致触发hashchange这个事件，hash模式就是通过 hashchange 事件来 监听 hash 值的改变从而渲染页面对应的组件。
在hash模式下修改页面不会刷新，因此hash模式不会向后端发送http请求，不会导致浏览器向后端发送请求。
（2）location 使用 location.hash 获取 hash 值
location 是 window.location 或者 document.location 的简写模式，window.location 对象包含了当前 URL 的信息，并提供了一系列属性来访问和操作 URL。
（3）location 的常用属性 href：获取或设置完整的 URL。host：获取或设置主机名和端口号。hostname：获取或设置主机名。protocol：获取或设置协议部分（如 "http:" 或 "https:"）。pathname：获取或设置 URL 的路径部分。search：获取或设置 URL 的查询部分（即问号后面的部分，包括问号）。hash：获取或设置 URL 的片段标识部分（即井号后面的部分，包括井号）。origin：获取只读属性，表示 URL 的源部分（协议+主机+端口）。 通过访问 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/994e05553ac076d43d8bf9352bf9b340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6bc28274c2bf0a7ca04b748e2181f37/" rel="bookmark">
			Flink1.18.1在CentOS7下的安装和部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是Flink1.18.1在CenOS7下的安装和部署的学习笔记，记录了基本的安装步骤及参数配置，给初学者避坑用。
一，安装JDK11 Flink在1.13及其之前的版本，推荐用JDK8。从Flink 1.14开始，官方推荐使用的Java版本是JDK 11，并且从Flink 1.17开始，部分依赖于Flink的第三方库已经弃用了对JDK 8的支持。我们今天计划安装的是1.18，所以要先安装JDK11。
JDK的安装各位应该不是问题了，快速带过吧。所有的JDK安装都是三部曲：
1，下载、解压、安装
sudo rpm -ivh jdk-11-*.rpm 2，环境变量 sudo vi /etc/profile 在文件的末尾添加以下行，将JAVA_HOME设置为JDK 11的安装路径（通常rpm安装会自动设置到/usr/java/jdk-11）
export JAVA_HOME=/usr/java/jdk-11 export PATH=$JAVA_HOME/bin:$PATH 保存后编译新环境变量，使生效
source /etc/profile 3，验证
java -version 如果成功安装并配置了JDK 11，你应该能看到类似于“openjdk version "11.0.x"”的输出。 二，下载和安装Flink Flink官网下载地址是https://flink.apache.org/downloads/
下载好 flink-1.18.1-bin-scala_2.12.tgz 文件后，下一步通常是进行解压和配置 Flink 环境。以下是一般的步骤：
1，解压
你可以使用 tar 命令来解压下载的 .tgz 文件。假设你已经将文件下载到了 /opt 目录下，你可以执行以下命令来解压：
cd /opt tar -zxvf flink-1.18.1-bin-scala_2.12.tgz 解压后，你会得到一个名为 flink-1.18.1 的目录。
2，配置环境变量
为了方便使用 Flink 的命令行工具，你可以将 Flink 的 bin 目录添加到你的 PATH 环境变量中。编辑你的 shell 配置文件（如 .bashrc 或 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6bc28274c2bf0a7ca04b748e2181f37/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/463/">«</a>
	<span class="pagination__item pagination__item--current">464/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/465/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>