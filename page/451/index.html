<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62dd399ad5146d896f11cc902977d526/" rel="bookmark">
			人工智能中的数学计算和数学思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.人工智能中的数学计算 在人工智能（AI）领域，数学计算扮演着至关重要的角色，支撑着众多算法的设计与实现。以下是一些人工智能中常见的数学计算：
线性代数：
向量和矩阵运算：用于表示和处理高维数据，例如神经网络中的权重、输入输出向量、卷积运算等。特征值和特征向量：在主成分分析（PCA）、潜在语义分析（LSA）等降维技术中有广泛应用。矩阵分解：奇异值分解（SVD）、特征分解等在推荐系统、信号处理和机器学习模型初始化中有重要应用。 概率论与统计学：
概率分布：如高斯分布、伯努利分布、多项式分布等，用于建模不确定性。贝叶斯定理：在贝叶斯网络、概率编程等概率机器学习方法中，用于更新先验概率以获得后验概率。最大似然估计和最大后验估计：用于参数估计和模型拟合。假设检验：用于评估数据是否符合某种假设模型。 优化理论：
梯度下降法、牛顿法、拟牛顿法等最优化算法：用于神经网络及其他机器学习模型的训练，调整模型参数以最小化损失函数。约束优化：在某些机器学习和规划问题中，需考虑约束条件下的优化问题。 微积分与梯度计算：
微分和梯度计算是神经网络反向传播算法的基础，用于计算损失函数关于模型参数的梯度，进而更新模型参数。 数值计算：
解决非线性方程组和微分方程，以及在大规模数据集上的高效计算，如稀疏矩阵运算、快速傅里叶变换等。 离散数学与组合数学：
在算法设计、图论问题、编码理论和游戏树搜索等应用场景中发挥作用。 信息论：
信息熵、互信息、KL散度等在衡量信息量、衡量模型不确定性、构建损失函数等方面有重要应用。 深度学习中的数学：
卷积、池化等图像处理相关的数学计算；自注意力机制中的矩阵运算；张量运算在处理多维数据中的作用；以及变分自编码器、生成对抗网络等新型深度学习模型中的数学原理。 综上所述，数学计算在人工智能中几乎无处不在，从底层的数据预处理到顶层的模型构建、训练与评估，数学原理与方法贯穿始终，为AI的发展奠定了坚实的理论基础。
2.人工智能中的数学思想 人工智能（AI）中的数学思想体现在多个层面，它构成了AI算法设计、优化、分析和解决问题的基础。以下是一些关键的数学思想和工具，在人工智能尤其是机器学习和深度学习中扮演核心角色：
2.1 线性代数： 矩阵和向量运算构成了机器学习算法的基础，特别是在处理高维数据时，如图像、文本和其他结构化数据。矩阵乘法是神经网络中权重更新和前向传播的核心。
线性代数在机器学习和人工智能中的作用举足轻重，尤其体现在以下几个方面：
数据表示：高维数据，如图像、文本和语音信号等，都可以转化为向量或者矩阵的形式进行处理。例如，一张图像可以看作是一个像素值构成的矩阵，一段文本可以通过词嵌入技术转化为词向量组成的矩阵。
模型构建：机器学习和深度学习模型通常基于线性变换原理构建，其中权重参数通常用矩阵表示，输入数据用向量表示。例如，在神经网络中，每一层的输出都是输入经过权重矩阵变换后的结果。
矩阵乘法与前向传播：在神经网络的前向传播过程中，每层的输出就是其输入与权重矩阵的乘积加上偏置项，这个过程反复进行直至输出层，从而完成对输入数据的非线性变换和特征提取。
反向传播与梯度计算：在训练神经网络时，反向传播算法利用链式法则计算损失函数关于每个权重参数的梯度，这其中涉及大量的矩阵微分和矩阵乘法操作。
特征分解与降维：线性代数中的特征分解等方法常用于数据预处理阶段，如主成分分析（PCA）进行数据降维，奇异值分解（SVD）用于推荐系统等场景。
综上所述，线性代数为人工智能提供了强大而灵活的数据处理和模型构建工具，是实现人工智能诸多功能和技术的核心数学基石。
2.2 概率论与统计学： 概率模型被用来描述数据中的不确定性，统计推断用于从有限样本中得出一般性结论。贝叶斯定理、最大似然估计、最小二乘法等统计方法在监督学习中广泛使用，如朴素贝叶斯分类器、逻辑回归、高斯过程等。
概率论与统计学在人工智能和机器学习中扮演着至关重要的角色：
概率模型：在AI中，概率模型是量化不确定性的关键工具。它可以用来描述随机变量之间的关系，比如联合概率分布、条件概率分布等。这种模型可以帮助机器学习算法考虑数据内在的随机性和不确定性，从而做出更为稳健和适应变化环境的决策。
统计推断：统计推断是根据观测数据来估计未知参数或者预测未来事件的过程。在机器学习中，我们经常面对的是有限的训练数据，需要通过统计方法从有限样本中推断总体规律。例如，在参数估计中，我们会运用点估计（如最大似然估计）和区间估计来确定模型参数的值；而在假设检验中，则会判断某个假设是否成立。
贝叶斯定理：在贝叶斯统计中，先验知识结合新证据更新后形成后验概率。贝叶斯网络和贝叶斯推断在很多机器学习任务中都起着核心作用，如朴素贝叶斯分类器就直接利用了贝叶斯定理来进行分类。
最大似然估计（MLE）：这是一种常用参数估计方法，通过找到能使观测数据出现概率最大的参数值来估计模型参数。在监督学习中，诸如逻辑回归、线性回归等模型的参数训练常常采用MLE方法。
最小二乘法：主要用于线性回归分析，它寻求通过最小化残差平方和来确定最佳拟合直线或其他函数形式。这种方法在预测模型中广泛应用，旨在尽可能减小模型预测值与真实值之间的差异。
高斯过程：作为一种强大的非参数模型，高斯过程在回归和分类问题中提供了一种优雅的概率框架，允许对函数空间内的不确定性进行建模，非常适合于处理复杂的函数关系，并且可以给出预测的不确定性估计。
因此，无论是对数据进行描述性分析还是预测性分析，亦或是模型参数的估计与优化，概率论与统计学都为人工智能提供了坚实的理论基础和实用工具。
2.3 信息论： 信息熵和互信息等概念在衡量信息的内容、减少不确定性以及构建最优编码方案中有重要作用，同时也是评估模型性能和构建决策准则的基础。
信息论由克劳德·香农创立，其核心概念在人工智能中具有深远的影响：
信息熵（Entropy）：
信息熵（H(X)）是对随机变量不确定性的量化，表征了某个随机事件的信息量大小。在机器学习和模式识别中，熵被用来衡量数据集的纯度或者模型预测的不确定性。对于一个离散随机变量X，其熵定义为各个状态出现概率与其对应自信息的期望值之和，公式为 H(X) = -∑[p(x) * log(p(x))], 其中p(x) 是事件x发生的概率。 条件熵与联合熵：
条件熵（H(Y|X)）是在已知另一个随机变量X的情况下，随机变量Y的不确定性。联合熵（H(X,Y)）则是同时考虑两个随机变量时的总不确定性。 互信息（Mutual Information, MI）：
互信息是衡量两个随机变量之间相互依赖程度的一种量度，它反映了在知道一个随机变量的情况下另一个随机变量的不确定性减少的程度。互信息的计算公式为 MI(X;Y) = ∑∑[p(x,y) * log(p(x,y)/(p(x)p(y))]，其中p(x,y)是联合概率分布，p(x)和p(y)分别是X和Y的边缘概率分布。 在AI中的应用：
在特征选择中，互信息可用于度量特征与目标变量之间的相关性，选择那些与目标变量具有较大互信息的特征作为模型输入，有助于提高模型性能。在通信和数据压缩领域，信息熵被用来设计最优的编码方案，如哈夫曼编码，使得平均每个符号所需的比特数最小。在模型评估和比较中，交叉熵（Cross Entropy）是评估概率分布预测准确性的一个标准，尤其是在神经网络的损失函数中常见，如逻辑回归、softmax回归和变分自编码器（VAE）等模型的训练中。互信息也被用于理解和挖掘数据集中的潜在结构，例如在独立成分分析（ICA）、因果推断和相关性分析中。 总结来说，信息论的概念和工具为人工智能提供了量化信息价值、评估模型表现以及优化数据处理流程的有效途径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62dd399ad5146d896f11cc902977d526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd94b79f1671cbf198787e692215d90/" rel="bookmark">
			对话式AI助手的巅峰对决：ChatGPT与文心一言的实用价值探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的发展，对话式AI助手逐渐成为了人们生活中的一部分。其中，ChatGPT和文心一言更是备受关注的两款对话式AI助手。本文将探讨这两款AI助手的实用价值，并通过案例和数据的方式进行分析。
一、ChatGPT的实用价值 跨语言交流 ChatGPT是一款能够进行跨语言交流的对话式AI助手。据统计，ChatGPT支持的语言数量超过100种，用户可以通过它轻松地与不同国家和地区的人进行交流。例如，一名中国用户可以通过ChatGPT与美国的朋友进行实时交流，而无需担心语言障碍。
智能推荐 ChatGPT还具备智能推荐的功能。例如，当用户询问“附近有什么好吃的餐厅”时，ChatGPT会根据用户的地理位置和口味偏好推荐相应的餐厅。这种智能推荐功能不仅方便了用户的生活，也提升了用户的使用体验。
二、文心一言的实用价值 智能创作 文心一言是一款具有智能创作功能的对话式AI助手。通过学习大量的文本数据，文心一言能够生成高质量的文章和诗歌。例如，用户可以向文心一言提出“写一篇关于春天的诗歌”的要求，文心一言将根据用户的要求生成一首优美的诗歌。
语音识别 文心一言还具备语音识别功能。用户可以通过语音向文心一言发出指令，例如“打开音乐播放器”、“发送短信给某人”等。这种语音识别功能不仅方便了用户的使用，也提升了用户的使用体验。
三、案例分析 ChatGPT在教育领域的应用 ChatGPT在教育领域的应用已经逐渐得到认可。例如，美国一家名为“LingQ”的在线英语学习平台就采用了ChatGPT作为其教学助手。学生可以通过ChatGPT进行实时对话，提升自己的英语水平。据统计，使用ChatGPT的学生在英语学习方面的进步明显大于没有使用ChatGPT的学生。
文心一言在新闻行业的应用 文心一言在新闻行业的应用也得到了广泛的关注。例如，中国一家名为“财经网”的新闻网站就采用了文心一言作为其新闻生成助手。通过学习大量的新闻数据，文心一言能够生成高质量的新闻报道。据统计，使用文心一言生成的新闻报道的点击率和转发率明显高于人工编写的新闻报道。
四、总结 ChatGPT和文心一言都是对话式AI助手的代表，它们在实用价值方面有着不同的特点和优势。ChatGPT具备跨语言交流和智能推荐的功能，适合于需要进行跨语言交流和获取信息的用户。而文心一言具备智能创作和语音识别的功能，适合于需要进行创作和语音交互的用户。
综述篇：两大语言模型——ChatGPT与文心一言的对比 研发背景与技术支持 ChatGPT ChatGPT是美国人工智能研究实验室OpenAI在2022年11月30日推出的一款人工智能技术驱动的语言模型应用。ChatGPT是基于Transformer架构的预训练语言模型，采用了大量的自然语言处理技术和机器学习算法，包括深度学习、自然语言生成、自然语言理解等。
文心一言 文心一言是百度于2023年推出的一款AI预训练模型，其主要功能是生成与给定词语相关的高质量文本，以帮助用户提高创造力和创新能力。文心一言采用了深度学习算法和自然语言处理技术，包括词向量表示、注意力机制、双向循环神经网络等。
独特优势对比 ChatGPT ChatGPT的优势在于其强大的自然语言处理能力和人工智能技术。ChatGPT可以理解并生成自然语言，包括文字、语音、图像等多种形式。此外，ChatGPT还能够通过自我学习和自我优化不断提高其性能和准确性。
文心一言 文心一言的优势在于其优秀的文本生成能力。文心一言可以生成高质量的文本，包括文章、诗歌、故事等多种形式。此外，文心一言还能够根据用户的需求和偏好，生成个性化的文本内容。
市场接受度和发展趋势 全球市场 在全球市场上，ChatGPT和文心一言都受到了广泛关注和高度评价。ChatGPT在推出后短短几个月内就吸引了超过1亿用户，文心一言也在推出后迅速成为市场上的热门话题。
中国市场 在中国市场上，ChatGPT和文心一言也表现出了强大的市场潜力。根据统计，ChatGPT在推出后不久就在中国市场上获得了超过1000万的下载量，而文心一言在推出后也受到了广泛关注和好评。
案例与数据 ChatGPT案例 ChatGPT在推出后不久就被广泛应用在了多个领域，包括新闻写作、诗歌创作、游戏开发等。例如，一家美国新闻机构使用ChatGPT生成了大量的新闻报道，这些报道的准确性和可读性都非常高，受到了读者的高度评价。
文心一言案例 文心一言在推出后也被广泛应用在了多个领域，包括文本生成、自然语言处理、机器翻译等。例如，一家中国公司使用文心一言生成了大量的广告文案，这些文案的创新性和吸引力都非常高，为公司带来了良好的市场效果。
结论 ChatGPT和文心一言都是人工智能技术驱动的语言模型，它们各有优势和特点，也各有市场潜力。在未来，我们有理由相信，随着人工智能技术的不断发展，语言模型将在更多的领域得到应用，为人们的生活和工作带来更多便利和创新。
ChatGPT核心技术特点详解：引领未来AI潮流 一、GPT系列模型的发展历程 OpenAI的GPT系列模型是近年来人工智能领域最受关注的研究成果之一。从GPT-1到GPT-4，每一次迭代都为人工智能的发展带来了重大的突破。以下是GPT系列模型的发展历程：
GPT-1 2018年，OpenAI推出了GPT-1模型，这是第一个基于Transformer架构的语言模型。虽然GPT-1的性能在当时已经相当出色，但它只能生成有限的文本，并且准确率并不高。
GPT-2 2019年，OpenAI发布了GPT-2模型。与GPT-1相比，GPT-2的性能大幅提升，能够生成更加自然流畅的文本。这个模型的出现引起了广泛的关注，甚至被一些人称为“AI界的核武器”。
GPT-3 2020年，OpenAI发布了GPT-3模型。这个模型的规模达到了惊人的1750亿参数，是当时最大的预训练语言模型。GPT-3的出现再次引发了人工智能领域的热潮，它能够完成的任务种类和复杂程度都超过了之前的任何模型。
GPT-4 2023年，OpenAI发布了GPT-4模型。这个模型的规模进一步扩大，达到了惊人的10万亿参数，是目前最大的预训练语言模型。GPT-4的出现标志着人工智能领域进入了全新的阶段，它的性能和应用范围都超过了之前的任何模型。
二、ChatGPT的关键技术创新 ChatGPT是基于GPT-4模型构建的聊天机器人。以下是ChatGPT的关键技术创新：
语义理解能力 ChatGPT采用了先进的语义理解技术，能够理解用户的意图和情感，从而生成更加贴近用户需求的回复。
交互式对话 ChatGPT采用了交互式对话技术，能够根据用户的反馈调整自己的回复，从而实现更加自然的对话体验。
多语言支持 ChatGPT支持多种语言，能够为全球用户提供服务。这是之前的人工智能模型所不具备的功能。
三、ChatGPT的国际应用案例 ChatGPT已经在多个领域得到了广泛应用，并且收到了良好的反馈。以下是ChatGPT的几个国际应用案例：
金融服务 某国际银行采用了ChatGPT技术，构建了一个智能客服系统。该系统能够24小时为用户提供服务，解答各种问题，大大提高了银行的服务质量和效率。
医疗服务 某国际医疗机构采用了ChatGPT技术，构建了一个智能诊断系统。该系统能够根据患者的症状和病史，提供初步的诊断建议，帮助医生快速确定诊断方案。
教育服务 某国际教育机构采用了ChatGPT技术，构建了一个智能辅导系统。该系统能够根据学生的学习情况，提供个性化的辅导方案，帮助学生提高学习效率。
四、ChatGPT的广泛应用及反馈 ChatGPT已经在多个领域得到了广泛应用，并且收到了良好的反馈。以下是ChatGPT的广泛应用及反馈：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fd94b79f1671cbf198787e692215d90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2194228bc50b49f6d060571c1a5f63/" rel="bookmark">
			Stable Diffusion XL之使用Stable Diffusion XL训练自己的AI绘画模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 SDXL训练基本步骤二 从0到1上手使用Stable Diffusion XL训练自己的AI绘画模型2.1 配置训练环境与训练文件2.2 SDXL训练数据集制作(1) 数据筛选与清洗(2) 使用BLIP自动标注caption(3) 使用Waifu Diffusion 1.4自动标注tag(4) 补充标注特殊tag(5) 训练数据预处理(标注文件整合) 2.3 SDXL微调（finetune）训练(1 )SDXL 微调数据集要求(2) SDXL 微调训练参数配置2.1 训练参数配置(XL_config文件夹)2.1.1 config_file.toml2.1.2 sample_prompt.toml (3) SDXL关键参数详解(4) SDXL模型开始训练 2.4 基于SDXL训练LoRA模型(1) SDXL LoRA数据集制作(2) SDXL LoRA训练参数配置2.1 训练参数讲解(XL_LoRA_config文件夹)2.1.1 config_file.toml (3) SDXL LoRA关键参数详解(4) SDXL LoRA模型训练 一 SDXL训练基本步骤 Stable Diffusion XL系列模型的训练过程主要分成以下几个步骤，
训练集制作：数据质量评估，标签梳理，数据清洗，数据标注，标签清洗，数据增强等。训练文件配置：预训练模型选择，训练环境配置，训练步数设置，其他超参数设置等。模型训练：运行SDXL模型/LoRA模型训练脚本，使用TensorBoard监控模型训练等。模型测试：将训练好的自训练SDXL模型/LoRA模型用于效果评估与消融实验 二 从0到1上手使用Stable Diffusion XL训练自己的AI绘画模型 下面是SDXL的训练资源
链接：https://pan.quark.cn/s/5664c0de758d
提取码：LRZV
2.1 配置训练环境与训练文件 1. 首先进入SDXL-Train项目中，安装SDXL训练所需的依赖库
cd SDXL-Train pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple some-package # accelerate库的版本需要重新检查一遍，需要安装accelerate==0.16.0版本才能兼容SDXL的训练 pip install accelerate==0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2194228bc50b49f6d060571c1a5f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc1b4890ea714ec25e66a3866e26109/" rel="bookmark">
			微信小程序嵌入 H5 页面（webview）基本用法和父子传参数说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 最近实现一个功能需要在小程序嵌入其它系统内部的一个页面（用vue写的H5页面），但小程序是无法使用iframe的，所以最终选择小程序官方的webview实现，本文对基本用法和父子传参进行说明。所以下面将说明：
小程序官网配置业务域名标签的用法。父子传参数。H5 跳转回小程序。 一、 小程序官网配置业务域名 小程序官方要求配置，如果不配置在趁机上会无法打开，但在微信开发者工具正常
步骤： 在微信小程序后台，开发-&gt;开发管理-&gt;开发设置-&gt;业务域名 这里添加需要嵌入到小程序里面 H5 页面的合法域名（最多200个）；
二、标签的用法 web-view 承载网页的容器。会自动铺满整个小程序页面，不能像iframe那样能设置某个区域
直接使用标签即可 &lt;web-view src="xxxxxxxxxx"&gt;&lt;/web-view&gt; 三、父子传参数 父传子(本地系统传到被嵌入的H5页面)： //这是小程序页面 &lt;web-view src="{{webUrl}}"/&gt; //这是H5页面 created() { // H5获取token const wxobj = {} window.location.href.replace(/([^?&amp;=]+)=([^&amp;]+)/g, (_, k, v) =&gt; (wxobj[k] = v)) if ( wxobj.token) { store.commit( 'user/setToken', wxobj.token) } } 小程序用url拼接过去，H5页面通过window.location.href.replace获取到内容
子传父（H5传给小程序）： 注意： 在H5系统（被嵌入） 需要安装官方的weixin-js-sdk包，步骤如下：
(1)安装：
pnpm add weixin-js-sdk (2)使用的页面引入：
import wx from "weixin-js-sdk"; (3)使用传参给父：
wx.miniProgram.postMessage({ data: { token } }); 本地系统接收（小程序） &lt;web-view src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc1b4890ea714ec25e66a3866e26109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c3e035a321af5b7dcce700e209c7dd/" rel="bookmark">
			Hive 基本操作命令与介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive是一个基于Hadoop的数据仓库工具，它提供了类似于SQL的查询语言HiveQL来对存储在Hadoop集群中的数据进行查询和分析。
1常用的Hive操作命令及其功能： 1. **创建数据库**：
CREATE DATABASE [IF NOT EXISTS] database_name;
2. **切换数据库**：
USE database_name;
3. **创建表**：
CREATE TABLE [IF NOT EXISTS] table_name (
column1 data_type,
column2 data_type,
...
)
[PARTITIONED BY (partition_column data_type, ...)]
[ROW FORMAT ...]
[STORED AS ...];
4. **加载数据**：
LOAD DATA [LOCAL] INPATH 'input_path' [OVERWRITE] INTO TABLE table_name;
5. **查询表数据**：
SELECT * FROM table_name;
6. **插入数据**：
INSERT INTO TABLE table_name VALUES (value1, value2, ...);
7. **创建分区表**：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73c3e035a321af5b7dcce700e209c7dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729e0b32ccf0f4e69ee7a719ef80631e/" rel="bookmark">
			VSCode中6个AI顶级插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio Code (VSCode) 是通往一系列 AI 驱动的编码支持的门户。探索精心挑选的 VSCode 顶级扩展，这些扩展利用人工智能的强大功能，包括 GitHub Copilot、TabNine 等著名工具。
1. GitHub Copilot：你的强人工智能结对程序员
GitHub Copilot是由 GitHub 和 OpenAI 开发的突破性 AI 结对程序员。Copilot 作为您强大的人工智能协作者，在广泛的公共代码存储库数据集的支持下，为整行或代码块提供即时建议。Copilot 无缝集成到 VSCode 中，通过根据自然语言提示和上下文生成代码片段来加速您的编码过程。使用 GitHub Copilot 拥抱编码协作的未来。
2. TabNine：人工智能驱动的卓越代码完成
TabNine成为您编码中的 AI 副驾驶，根据上下文和编码模式为您的下一行代码提供强大的 AI 驱动预测。凭借对多种编程语言的强大支持，TabNine 无缝集成到 VSCode，在您键入时提供准确、直观的代码建议。告别体力劳动，借助 TabNine 强大的 AI 能力迎接更快、更高效的编码。
3. Codemium：释放人工智能驱动的代码完成的力量
Codemium是一款人工智能驱动的代码完成工具，旨在提高 VSCode 的工作效率。通过稳健地分析您的代码库并提供智能建议，Codemium 有助于更快、更准确的编码。Codemium 具有支持多种编程语言和框架的强大 AI 功能，可适应您的编码风格和偏好，巩固其作为开发人员不可或缺的工具的地位。
4. Visual Studio IntelliCode：个性化 AI 辅助代码完成
Visual Studio IntelliCode在通过基于流行编码模式和实践的 AI 辅助代码完成来提高编码效率方面脱颖而出。IntelliCode 不断从您的代码库和更广泛的社区中学习，提供个性化建议，帮助您更快地编写代码并减少错误。借助 IntelliCode 强大的 AI 功能拥抱编码的未来。
5. Bito：人工智能驱动的代码分析和优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/729e0b32ccf0f4e69ee7a719ef80631e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b22109d72f788c467c8b69507cbcb4/" rel="bookmark">
			【JAVAEE学习】探究Java中多线程的使用和重点及考点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶​
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏:xiaoxie的JAVAEE学习系列专栏——CSDN博客●'ᴗ'σσணღ
我的目标:"团团等我💪( ◡̀_◡́ ҂)" ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!
目录
​编辑一.线程
1.什么是线程
2.进程和线程的区别
1.在这里先解释一下最基础的定义
2.举个我们日常生活中的小例子
3.线程和进程的区别以及线程相比于进程的优点:(这个面试中也算是比较高频的问题)
二.编写多线程代码
1.定义线程类
1.说明
2.通过实现Runnadle接口创建线程
3.针对方法1使用匿名内部类
4.针对方法2使用匿名内部类
5.使用 lambda表达式
三.Thread类
1.构造方法
2.其他的方法
1.获取Id getid()
​编辑 2.获取名称 getName()
3.获取状态 getState()
4.是否为后台线程 isDaemon()
​编辑 5.是否存活 isAlive()
6.是否被中断 isInterrupted()
一.线程 1.什么是线程 线程（Thread）是程序中执行的最小单元，是操作系统能线程是计算机科学中的基本概念，指的是在同一进程中执行的单一执行流。线程是操作系统能够进行运算调度的最小单位。在多线程编程中，多个线程可以同时执行，共享进程的资源，但每个线程有自己的执行流程和栈空间。线程的引入可以提高程序的并发性和响应性，允许程序在同一时间处理多个任务。
在计算机系统中，线程是由操作系统调度和管理的，可以实现不同线程之间的切换和协同工作。线程之间可以共享进程的资源，如内存空间、文件描述符等，但也需要注意线程之间的同步和互斥，以避免竞态条件和数据不一致问题。
在编程中，线程可以用来实现并发编程，允许程序同时执行多个任务，提高程序的性能和效率。常见的多线程编程模型包括线程池、生产者-消费者模型等
2.进程和线程的区别 这个先解释一下线程和进程的区别,这个两个词虽然看起来相差不大,但意思却相差很大,当对于初学者来说还是比较容易混淆的
1.在这里先解释一下最基础的定义 进程：在计算机操作系统中，进程是对运行中程序的一个抽象，它是系统进行资源分配和调度的基本单位。每个进程都有自己独立的地址空间，包含了程序代码、数据、打开的文件描述符等资源。当一个程序开始执行时，操作系统会为其创建一个新的进程，使得程序可以占用系统资源并独立运行。
线程：线程是进程内的一个执行路径，也是CPU调度的最小单位。一个进程中可以有一个或多个线程(每个进程都有最基本的主线程)，这些线程共享进程的相同地址空间（包括代码、全局变量等资源）。每个线程都维护有自己的程序计数器、寄存器集合和栈，这样它们就可以在进程的上下文中并发执行各自的任务。相较于进程，线程之间的切换成本更低，而且由于资源共享的特性，线程间的通信和同步更为简便。
2.举个我们日常生活中的小例子 用日常生活的例子来解释进程和线程的区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b22109d72f788c467c8b69507cbcb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d234885154eeeac3bd064a6cf0c35c/" rel="bookmark">
			基于Spring Boot 3 &#43; Spring Security6 &#43; JWT &#43; Redis实现登录、token身份认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Spring Boot3实现Spring Security6 + JWT + Redis实现登录、token身份认证。
用户从数据库中获取。使用RESTFul风格的APi进行登录。使用JWT生成token。使用Redis进行登录过期判断。所有的工具类和数据结构在源码中都有。 系列文章指路👉
系列文章-基于SpringBoot3创建项目并配置常用的工具和一些常用的类
项目源码👉
/shijizhe/boot-test
文章目录 依赖版本原理代码结构security 配置用户登录、注册controller，用户服务用到的工具类 注册 AuthController.register登录1.登录API：AuthController.login2. 登录过滤器：继承UsernamePasswordAuthenticationFilter3.身份认证：实现AuthenticationProvider4.从数据库中查询用户信息：实现UserDetailsService5. Security配置: 使用注解@EnableWebSecurity token身份认证1. token身份认证过滤器： OncePerRequestFilter UserAuthUtilsgetUserId 用户登出实现LogoutSuccessHandler修改Security配置 : YaSecurityConfig 下一步的计划参考文章 依赖版本 Spring Boot 3.0.6Spring Security 6.0.3 原理 这张图大家已经估计已经看过很多次了。
实现登录认证的过程，其实就是对上述的类按照自己的需求进行自定义扩展的过程。具体不多讲了，别的文章里讲得比我透彻。
show you my code.
代码结构 security 配置 用户登录、注册controller，用户服务 用到的工具类 注册 AuthController.register 将用户密码使用BCrypt加密存储。
@PostMapping("/register") @Operation(summary = "register", description = "用户注册") public Object register(@RequestBody @Valid UserRegisterDTO userRegisterDTO) { YaUser userById = userService.getUserById(userRegisterDTO.getUserId()); if(Objects.nonNull(userById)){ return BaseResult.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d234885154eeeac3bd064a6cf0c35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8167b721f114e8d51377f546d0e93e73/" rel="bookmark">
			【热门话题】Yarn：新一代JavaScript包管理器的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 Yarn：新一代JavaScript包管理器的安装与使用引言一、Yarn的安装1. 系统要求2. 安装Yarn在Mac或Linux上安装在Windows上安装 3. 验证安装 二、Yarn的基本使用1. 初始化项目2. 安装依赖3. 使用依赖4. 查看和管理依赖5. 依赖锁定与缓存6. 工作区与工作流程 结语 Yarn：新一代JavaScript包管理器的安装与使用 引言 Yarn是Facebook、Google、Expo和Tilde等公司联合开发的一款高效、可靠的JavaScript包管理工具，它是npm（Node Package Manager）的一个有力替代品。Yarn通过引入锁定文件、离线模式、多并发请求等功能，提升了依赖管理和版本控制的效率与可靠性，为前端开发者提供了更优的开发体验。
一、Yarn的安装 1. 系统要求 确保您的系统已安装了Node.js环境，因为Yarn需要Node.js的runtime支持。可以通过访问Node.js官网下载并安装对应操作系统的最新稳定版Node.js。
2. 安装Yarn 在Mac或Linux上安装 对于Mac用户，可以使用Homebrew进行安装：
brew install yarn 对于Linux用户，可以直接从官方网站提供的安装脚本进行安装：
curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo "deb https://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update &amp;&amp; sudo apt-get install yarn 在Windows上安装 从Yarn官网下载.msi安装包并运行进行安装：Yarn Windows安装包
3. 验证安装 安装完成后，打开终端（或命令提示符），输入以下命令检查Yarn是否成功安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8167b721f114e8d51377f546d0e93e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e9ee7d65c36a2396a14a5f16403ffa/" rel="bookmark">
			Hbase和Clickhouse对比简单总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hbase和Clickhouse是两种不同的数据库系统，它们各自适用于不同的场景。以下是两者之间的对比：
数据模型：
HBase
HBase数据模型是一种面向列的分布式数据库模型，基于Hadoop的HDFS (Hadoop Distributed File System)平台。在HBase中，数据被组织为行(row)、列族(column family)、列(column)和单元格(cell)的层次结构，并存储在表(table)中。HBase的存储方式主要是基于HDFS的分布式存储。适合处理大规模的数据集，尤其擅长快速随机访问。其面向列的设计使得它能够在列级别上进行独立检索，为大数据处理提供了极大的灵活性。
ClickHouse： 数据模型的角度来看，ClickHouse采用了经典的表格存储模型，属于结构化数据存储系统。存储方式ClickHouse是基于列式存储的数据库管理系统。在列式存储中，数据是按照列而不是按行进行组织的。是一个用于联机分析处理(OLAP)的列式数据库管理系统(DBMS)，特别适用于大数据量的实时分析查询场景
数据处理能力：
HBase 支持实时更新和插入，但可能不是最佳的选择对于批量的数据加载或复杂的数据转换操作。ClickHouse 提供了一个高性能的分布式查询引擎，它可以执行复杂的聚合和分析操作，但它不支持事务处理和无服务器模式。 可扩展性和可靠性：
HBase 使用 Zookeeper 来存储元数据，并且每个集群都需要一个领导者节点。ClickHouse 没有中心化的领导节点，所有节点在逻辑上是平等的，这使得它在高可用性方面表现更好。 存储引擎：
HBase 的存储引擎可以自定义，但它默认使用的是 SSTable。ClickHouse 支持多种可插拔的存储引擎，包括 RocksDB 等，以及稀疏索引技术。 性能：
HBase 由于其设计用于快速随机访问，通常具有较好的读写性能。ClickHouse 虽然提供了高性能的分布式查询引擎，但在某些情况下可能会因为数据分布不均而影响性能。 总结:，
HBase 和 ClickHouse各有优势，选择哪一种取决于具体的应用需求。
HBase 适合需要快速随机访问的大规模数据集，而 ClickHouse 更适合 OLAP 工作负载和高可用性的环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebdb200317df22be2a24bedbc0f354e0/" rel="bookmark">
			大二Web期末作业课程设计（网页源码）——美食网站设计与实现（HTML&#43;CSS&#43;JavaScript）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓静态网站的编写主要是用HTML DIV+CSS JS等来完成页面的排版设计👩‍🎓,常用的网页设计软件有Dreamweaver、EditPlus、HBuilderX、VScode 、Webstorm、Animate等等，用的最多的还是DW，当然不同软件写出的前端Html5代码都是一致的，本网页适合修改成为各种类型的产品展示网页，比如美食、旅游、摄影、电影、音乐等等多种主题，希望对大家有所帮助。
🎀 精彩专栏推荐👇🏻👇🏻👇🏻 🧡 【作者主页——🔥获取更多优质源码】
🧡 【web前端期末大作业——🔥🔥毕设项目精品实战案例(1000套)】
文章目录📂 一、网站题目👨‍🎓二、网站描述✍️三、网站介绍📚四、网站效果🌐五、代码实现 🪓HTML结构代码🧱CSS样式代码💒 八、更多干货🎁 一、网站题目👨‍🎓 🥧 美食网页介绍、🍰甜品蛋糕、🦐地方美食小吃文化、🍺餐饮文化、等网站的设计与制作。
二、网站描述✍️ 🍧美食主题网站 主要对各种美食进行展示，让浏览者清晰地了解到各种美食的详细信息，便于浏览者进行选择。该模块的左侧有个美食分类，用户可以选择自己喜欢的种类，当点击种类后，就会在右侧出现该分类下的各种美食，用户可以点击自己感兴趣的食品，从而看到它的具体信息。它的具体信息包括配料、产地及它的一些功能，使用户对该食品有着全面的认识。
三、网站介绍📚 📔网站布局方面：计划采用目前主流的、能兼容各大主流浏览器、显示效果稳定的浮动网页布局结构。
📓网站程序方面：计划采用最新的网页编程语言HTML5+CSS3+JS程序语言完成网站的功能设计。并确保网站代码兼容目前市面上所有的主流浏览器，已达到打开后就能即时看到网站的效果。
📘网站素材方面：计划收集各大平台好看的图片素材，并精挑细选适合网页风格的图片，然后使用PS做出适合网页尺寸的图片。
📒网站文件方面：网站系统文件种类包含：html网页结构文件、css网页样式文件、js网页特效文件、images网页图片文件；
📙网页编辑方面：网页作品代码简单，可使用任意HTML编辑软件（如：Dreamweaver、HBuilder、Vscode 、Sublime 、Webstorm、Text 、Notepad++ 等任意html编辑软件进行运行及修改编辑等操作）。
其中：
（1）📜html文件包含：其中index.html是首页、其他html为二级页面；
（2）📑 css文件包含：css全部页面样式,文字滚动, 图片放大等；
（3）📄 js文件包含：js实现动态轮播特效, 表单提交, 点击事件等等（个别网页中运用到js代码）。
四、网站效果🌐 五、代码实现 🪓 HTML结构代码🧱 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;宽屏大气响应式特色农庄农家乐网站模板&lt;/title&gt; &lt;meta name="keywords" content="宽屏大气,响应式,特色农庄,农家乐,网站模板" /&gt; &lt;meta name="description" content="宽屏大气响应式特色农庄农家乐网站模板下载，自适应手机移动端，用户体验友好。" /&gt; &lt;meta name="author" content="js代码" /&gt; &lt;meta name="copyright" content="js代码" /&gt; &lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebdb200317df22be2a24bedbc0f354e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfc7bf20e636be9dc6842bb9792b13f/" rel="bookmark">
			HBase报错：Master is initializing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：org.apache.hadoop.hbase.PleaseHoldException: Master is initializing
描述：在启动HBase之后进入bin/hbase shell 命令行进行一些操作，比如建表或者添加数据到表中出现这种报错org.apache.hadoop.hbase.PleaseHoldException: Master is initializing
ERROR: org.apache.hadoop.hbase.PleaseHoldException: Master is initializing at org.apache.hadoop.hbase.master.HMaster.checkInitialized(HMaster.java:2739) at org.apache.hadoop.hbase.master.HMaster.disableTable(HMaster.java:2310) at org.apache.hadoop.hbase.master.MasterRpcServices.disableTable(MasterRpcServices.java:802) at org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos$MasterService$2.callBlockingMethod(MasterProtos.java) at org.apache.hadoop.hbase.ipc.RpcServer.call(RpcServer.java:395) at org.apache.hadoop.hbase.ipc.CallRunner.run(CallRunner.java:133) at org.apache.hadoop.hbase.ipc.RpcExecutor$Handler.run(RpcExecutor.java:338) at org.apache.hadoop.hbase.ipc.RpcExecutor$Handler.run(RpcExecutor.java:318) 分析：Master正在初始化
1、集群中的节点时间不同步，可以在启动的集群中使用命令行：date，查看各个节点的时间是否同步，如果不同步，可以参考这篇博客进行集群离线状态时间同步的修改https://blog.csdn.net/m0_46413065/article/details/116378004
2、如果以上方式仍然没有效果，可能报错的原因二是：HDFS中和Zookeeper中的HBase没有删除，所以这里需要将其进行删除，具体的命令如下：注意：删除Zookeeper中的 /hbase 目录，需要保证zookeeper已经开启，否则无法连接上。
方案：1.删除zookeeper中的所有的/hbase目录
# 切换到zookeeper的bin目录下 cd /opt/module/zookeeper/bin # 然后执行 ./zkCli.sh 命令 [XXhadoop102 bin]$ ./zkCli.sh # 输入 ls / 命令行查看所有的内容 [zk: localhost:2181(CONNECTED) 0] ls / [hbase, kafka, servers, spark, zookeeper] # 使用 rmr /hbase 或者 deleteall /hbase 删除zookeeper中的所有 hbase的目录 [zk: localhost:2181(CONNECTED) 3] deleteall /hbase Node does not exist: /hbase # 此时，可以看到Zookeeper中已经没有HBase了 [zk: localhost:2181(CONNECTED) 5] ls / [kafka, servers, spark, zookeeper] 然后重启HBase即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cfc7bf20e636be9dc6842bb9792b13f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82aea83d478dcc01365784eb7a583bb8/" rel="bookmark">
			Spring Boot与Redis深度整合：实战指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 整合 Redis 相当简单，它利用了 Spring Data Redis 项目，使得我们可以在 Spring Boot 应用中轻松地操作 Redis。以下是如何整合 Redis 到 Spring Boot 应用的基本步骤：
1. 添加依赖 首先，在你的 pom.xml 文件中添加 Spring Boot Data Redis 的依赖：
&lt;dependencies&gt; &lt;!-- 其他依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 如果使用Lettuce作为Redis客户端，需要添加此依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 如果使用Jedis作为Redis客户端，需要添加此依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 注意：Lettuce和Jedis是Spring Boot支持的两个主要的Redis客户端，你可以选择其中一个。在Spring Boot 2.x中，默认使用Lettuce。 2. 配置 Redis 在 application.properties 或 application.yml 文件中添加 Redis 的配置信息：
application.properties 示例
spring.redis.host=localhost spring.redis.port=6379 spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82aea83d478dcc01365784eb7a583bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db89bd4ec92d651bb44707a01dd04a4f/" rel="bookmark">
			UniApp中获取安卓设备的唯一标识符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在UniApp中获取安卓设备的唯一标识符时，尤其是针对安卓平板电脑，需要注意的是，为了保护用户隐私，从Android 10（API级别29）开始，Google进一步加强了对设备标识符的管理，许多传统的设备唯一标识（例如IMEI、MAC地址等）无法直接通过应用程序访问，除非用户明确授予相关权限。
以下是一些可能的替代方案来标识设备：
OAID（匿名广告标识符）： 对于广告跟踪和设备识别，在Android 10及以上版本，可以尝试使用开放匿名设备标识符（OAID），它是由某些广告服务提供商提供的，并遵循一定的隐私政策。不过，这并不是所有设备都支持，且用户可以选择重置此标识符。
ANDROID_ID： 虽然不保证永久不变或始终存在，但在一些情况下，仍然可以尝试获取ANDROID_ID，但请注意其行为在不同版本和厂商定制系统中可能有所不同
// 使用plus.android.runtimeExec执行原生代码获取ANDROID_ID var identifier = ""; try { identifier = plus.android.runtimeExec({ action: "com.example.getAndroidId", classPath: "com.example.GetAndroidIdActivity", }).result; } catch (e) { console.log('获取ANDROID_ID失败'); } 上述代码片段是一个示例，实际操作中你可能需要编写一个简单的原生插件来获取ANDROID_ID，并在Manifest中声明必要的权限。
3. UUID： UniApp框架可能会提供一个内部生成的UUID作为设备标识，但这不是一个持久不变的标识符，通常会在应用卸载后重新安装时发生变化。
const deviceId = uni.getSystemInfoSync().deviceId; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41281373e3fd590ae0dd07e4583fff05/" rel="bookmark">
			【动态规划】【广度优先搜索】【逆向思考】【单调向量】2617 网格图中最少访问的格子数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及的基础知识点 二分查找算法合集
动态规划汇总
作者推荐 视频算法专题
题目 给你一个下标从 0 开始的 m x n 整数矩阵 grid 。你一开始的位置在 左上角 格子 (0, 0) 。
当你在格子 (i, j) 的时候，你可以移动到以下格子之一：
满足 j &lt; k &lt;= grid[i][j] + j 的格子 (i, k) （向右移动），或者
满足 i &lt; k &lt;= grid[i][j] + i 的格子 (k, j) （向下移动）。
请你返回到达 右下角 格子 (m - 1, n - 1) 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 -1 。
示例 1：
输入：grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
输出：4
解释：上图展示了到达右下角格子经过的 4 个格子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41281373e3fd590ae0dd07e4583fff05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c8caa7796bcafaf45a241013ca155f/" rel="bookmark">
			算法基础——排队打水（贪心算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AcWing 913. 排队打水
有n个人排队到1个水龙头打水，他们装满水的时间为t1，t2，t3，…tn，为整数且各不相等，应如何安排他们的打水顺序才能使所有人的等待时间之和最小？求出最小的等待时间之和？
典型的贪心问题，根据我们的直觉判断就是，让装满水时间越短的人排在越靠前面的位置，那么所有人等待的时间之和就会最短!(因为越排前面打水的人，后面等待的人数就越多，即有更多的人需要等待【排前面打水人所用的时间t】，导致等待时间之和增加)。
证明猜想：
假设 t [ i ] &gt; t [ i + 1 ] t[i] &gt; t[i+1] t[i]&gt;t[i+1]
按照我们的贪心策略计算等待时间之和： t 贪 = t [ 1 ] ⋅ ( n − 1 ) . . . + t [ i ] ⋅ ( n − i ) + t [ i + 1 ] ⋅ ( n − i − 1 ) + . . . + t [ n − 1 ] ⋅ 1 + t [ n ] ⋅ 0 t_贪=t[1]\cdot(n-1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c8caa7796bcafaf45a241013ca155f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c61ea1664e325183e7ca3c9c124c0568/" rel="bookmark">
			Java学习九—常用包(类)之java.util包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于java.util包 1.1简介 java.util​ 包是Java标准类库中的一个非常重要的组成部分，它提供了一系列对程序开发非常有用的类和接口。这个包主要包含集合框架、日期时间类、事件模型、随机数生成器以及其他实用工具类。
1.2常用类及接口 集合框架 - 集合框架是java.util​包中最重要的部分之一，它提供了一系列的数据结构和算法，帮助开发者存储和操作数据集合。
Collection​ - 集合框架的根接口，代表一组对象，这些对象称为元素。List​ - 有序集合，每个元素都有其在集合中的特定位置。Set​ - 不允许重复元素的集合。Map​ - 键值对的集合，也称为字典或哈希表。ArrayList​ - 实现了List​接口的动态数组。LinkedList​ - 实现了List​接口的双向链表。HashSet​ - 实现了Set​接口的哈希表集合。LinkedHashSet​ - 继承自HashSet​，维护元素插入顺序的集合。TreeSet​ - 实现了Set​接口的基于红黑树的集合，元素按自然顺序或自定义顺序排序。HashMap​ - 实现了Map​接口的哈希表。LinkedHashMap​ - 继承自HashMap​，维护元素插入顺序或访问顺序的映射。TreeMap​ - 实现了Map​接口的基于红黑树的映射，键按自然顺序或自定义顺序排序。 日期时间类 - 提供了操作日期和时间的类。
Date​ - 表示特定的瞬间，精确到毫秒。Calendar​ - 可以用于日期的计算，比如添加或减少天数、获取星期等。TimeZone​ - 表示时区。Locale​ - 表示特定的语言、国家和区域的设置。 事件模型 - 用于处理事件和监听器模式。
EventObject​ - 所有事件的超类。EventListener​ - 所有事件监听器接口的标记接口。EventSource​ - 能够生成事件的对象。 随机数生成器 - 提供随机数生成的功能。
Random​ - 基于线性同余生成器的随机数生成器。java.security.SecureRandom​ - 提供更安全的随机数生成。 其他实用工具类 - 提供了一系列静态方法，用于执行各种任务。
Arrays​ - 提供静态方法来操作数组，如排序、搜索等。Collections​ - 提供静态方法来操作集合，如排序、搜索等。Objects​ - 提供静态方法来操作对象，如空安全的比较、计算哈希码等。Timer​ - 可以调度任务在将来的某个时间点执行。UUID​ - 用于生成UUID（通用唯一标识符）。 ‍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c61ea1664e325183e7ca3c9c124c0568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40cd469afceed342cfa1c53ea02e1141/" rel="bookmark">
			使用vm虚拟机搭建windows 服务器，并搭建DNS、web、ftp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、注意事项 1.注意：DNS、web、ftp服务器啥的安装好了（没安装的麻烦看一下博主之前写的安装步骤或者其他博主的），学习当中，我是按照自己的想法来的，要是想法不对的话，麻烦提出来，谢谢。
2.vm虚拟机上，我安装了两个不同版本的windows server，分别是2019和2022版本的，其中我将windows server 2019当做服务器，2022的当做客户端，因此在配置DNS、web、ftp只需要在windows server2019上配，windows server2022只需要访问它。
3.在虚拟机上，windows 2019和windows2022要处于同一个网段才能相互ping通
二.步骤 （1）第一步，关闭防火墙（2019和2022的都要） （2）给windows2019和windows2022配ip地址 windows server2019windows server 2022ip192.168.10.1192.168.10.2掩码255.255.255.0255.255.255.0DNS192.168.10.1192.168.10.1 （2.1）找到“网络和Internet”中的“网络和共享中心”，点击“Ethernet0”
（2.2）点击“属性”，出现下面这个页面后，点击Internet协议版本4（Tcp/IPv4），再点击“属性”
（2.3）配ip（因为待会要配置DNS，所以我先填上去了）
（2.4）在windows server2019和windows server2022互相ping通，下图为windows server2022的（同理在windows2019的，这里自己ping一下2022的ip）
（3）在windows server2019上配，它作为服务器端 1.DNS配置： （3.1）点击①-&gt;在②处单击右键-&gt;点击③
（3.2）单击右键①，选择②
（3.3）新建区域：一直点击“下一步”，直到出现下面页面，在区域名称填上“域名”，在这里我填的是“celien.cn”,然后点击下一步，一直到完成。
（3.4）新建主机：展开找到新建的区域，即“celien.cn”,在“celien.cn”单击右键,选择“新建主机”
（3.5）添加主机，名为“www”，ip地址为192.168.10.1，点击“确定”，如果要添加多台主机的话，这里自己添加上去吧。
2.web网站 （2.1）回到仪表板主页，看右边菜单，点击①-&gt;②
（2.2）添加网站
（2.3）①填写“网站名称”（任意取）；②“物理路径”为建立的网页所在的文件夹路径；③“ip地址”为windows server2019的ip（在这里选择未分配其实也行）；④主机名：就是建立DNS的时候的“主机名+域名”，端口号为“80”（如果还要在建立一个网站，则将端口号改为“81”，以此类推）
（2.4）如果web文件夹里的网页名不是“index.html”的话，如：下面为celien.html
（2.5）这时候我们就需要添加进去：点击web-&gt;点击默认文档-&gt;点击右边的“添加...”-&gt;将“celien.html”添加进去，点击确定。
（2.6）因为在celien.html上编辑了一些内容，如果出现中文乱码的情况，则用记事本打开，点击另存为，将保存类型和编码分别改成下面的，保存。
（2.7）接下来我们测试一下
#在windows server2019上
①点击右边的“浏览网站”，
②或者在浏览器输入“www.celien.cn”
③或者在浏览器输入“http://192.168.10.1”都能访问该网站。
#接下来我们在windows server2022上访问网站
①在浏览器上输入“www.celien.cn”,可以看到windows server2022上也可以访问。
3.ftp配置（匿名用户） （3.1）首先在磁盘建立一个文件夹，在这里我命名为“ftp”，再在文件夹放一些东西，啥都行
（3.2）添加ftp站点
（3.3）填写名称和路径
（3.4）如下图所示
（3.4）如下图所示：最后点完成就建立好了
（3.5）测试
#在windows server2019上测试
①输入“ftp://192.168.10.1”,访问结果如下
#在windows server2022上访问
①输入“ftp://192.168.10.1”,访问结果如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ad296479c5b51a24cc410069d5f62d/" rel="bookmark">
			主流后端开发语言：JAVA、C、C&#43;&#43;、GO、PYTHON对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件开发领域，语言本身在各自领域都有适用场景，有许多流行的编程语言可供选择，每种语言都有其独特的特点和适用场景。 Java、C、C++、Go 和 Python 这五种主流编程语言，从底层实现、效率、原理、国内外市场占有率、社区活跃度以及开源项目等方面进行分析比较。
1. Java语言 底层实现： Java 是一种跨平台的面向对象编程语言，通过 JVM（Java 虚拟机）实现跨平台性。效率： Java 的执行效率相对较低，但在大型企业应用和Web开发中得到广泛应用。原理特性： Java 基于类和对象的面向对象编程范式，具有自动内存管理和垃圾回收机制。学习成本： 中等。Java 的语法相对简单，但面向对象的概念需要时间理解。市场占有率： Java 在企业级应用和Android开发领域市场占有率高。社区活跃度： Java 拥有庞大的开发者社区和丰富的资源支持。开源项目： Spring Framework、Apache Struts 等。企业级应用开发： Java 在企业级应用开发中得到广泛应用，尤其在大型系统和企业级软件开发中具有优势。Android 开发： 作为 Android 应用的主要开发语言，Java 在移动应用领域占有重要地位。大型网络应用： 由于其稳定性和安全性，Java 适用于开发大型网络应用和分布式系统。 2. C语言 底层实现： C 是一种面向过程的编程语言，直接编译成机器码运行，具有高效的性能。效率： C 是高效的系统编程语言，适合开发操作系统和嵌入式系统等领域。原理特性： C 语言简洁高效，需要手动管理内存。学习成本： 较高。C 的指针等概念对初学者来说可能较难理解。市场占有率： C 在系统编程领域占有重要地位。社区活跃度： C 语言虽然古老但仍有庞大的开发者社区支持。开源项目： Linux 内核、MySQL 等。系统编程： C 语言适合用于操作系统、嵌入式系统等底层开发，因为它直接编译成机器码并具有高效的性能。硬件驱动程序开发： 由于 C 语言可以直接访问内存和硬件，因此适合编写硬件驱动程序。 3. C++语言 底层实现： C++ 继承了 C 语言的特性，支持面向对象编程和泛型编程。效率： C++ 是高效的系统编程语言，适合开发复杂系统和游戏引擎。原理特性： C++ 支持多重继承和运算符重载等特性。学习成本： 高。C++ 涉及更多的概念和特性，学习曲线较陡峭。市场占有率： C++ 在游戏开发、系统软件等领域有着广泛应用。社区活跃度： C++ 社区活跃度高，有许多优秀的开源项目和框架。开源项目： Boost、Qt 等。游戏开发： 由于其高性能和丰富的特性，C++ 在游戏开发领域具有显著优势。系统软件开发： C++ 适用于开发复杂的系统软件，如操作系统、数据库系统等。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ad296479c5b51a24cc410069d5f62d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba135bee43d969600dbe5be72998589/" rel="bookmark">
			hadoop 单节点模式安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要
hadoop 单节点模式安装
一、系统安装
1、工具环境
（1）虚拟机：VMware woekstation 16 Player
程序：VMware-player-full-16.2.3-19376536.exe
官网：https://www.vmware.com/
下载地址：https://www.vmware.com/cn/products/workstation-player.html
https://customerconnect.vmware.com/cn/downloads/info/slug/desktop_end_user_computing/vmware_workstation_player/16_0
https://www.vmware.com/cn/try-vmware.html
（2）操作系统
操作系统：ubuntu的桌面版
程序版本：ubuntu-20.04.4-desktop-amd64.iso
下载地址：https://ubuntu.com/#download
2、系统安装
（1）使用简易安装
账号：hadoopsingle
虚拟机名称：hadoopsingle
虚拟机位置选择D盘：D:\Virtual Machines\hadoopsingle
分配磁盘100G，内存8G，cpu8核，选择磁盘为单个磁盘，网络选择桥接模式，其他默认
（2）安装Ubuntu
使用笔记本安装的，使用无线网络上网，通过虚拟机软件将络连接选择桥接模式，勾选或不勾选复制物理网络连接都可以;
激活root账号并设置密码，sudo passwd root ，输入root密码即可；
更新所有软件
apt update
apt upgrade
如何在VMware虚拟机的Ubuntu下实现与windows系统的文件（文字）互相复制粘贴
1.sudo apt autoremove open-vm-tools
2.sudo apt install open-vm-tools-desktop
3.重启系统即可
若复制失效或者报错，可使用以下办法解决：
1.apt -f install
2.reboot
配置windows主机和ubuntu虚拟机文件通过ftp传输
安装查看虚拟机IP程序
sudo apt install net-tools
查看IP
ifconfig -a
查看ftp服务
ps -ef|grep ftp
安装ftp服务
sudo apt install vsftpd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cba135bee43d969600dbe5be72998589/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/450/">«</a>
	<span class="pagination__item pagination__item--current">451/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/452/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>