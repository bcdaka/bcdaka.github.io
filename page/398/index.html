<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926f70960e8b8bebb449eee23be0fcb0/" rel="bookmark">
			AI绘画神器ComfyUI 整合包：工作流界面，解压即用，快速入门AI绘画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周赛博佛祖秋葉 Aki 发布了针对 ComfyUI 的整合安装包，让这款原本偏专业的 AI 绘画工具对初学者来说更容易上手使用了，我也安装试用了一下，的确非常方便，今天就为大家详细介绍一下整合包的用法 ~
一、ComfyUI 简介 ComfyUI 和大家熟知的 WebUI 一样，都是 Stable Diffusion 的一种用户界面，可以实现文生图、图生图、图像处理、AI 视频生成等操作。但 ComfyUI 是节点式模块化的界面，需要用户自己搭建工作流，而且各方面的资源比较松散，需要自己安装部署，因此入门难度较高，不适合零基础的 AI 绘画小白，一般都推荐大家先掌握 Stable Diffusion WebUI 的用法，再学习 ComfyUI。
ComfyUI 越来越受欢迎，是因为用户可以按需要搭建自定义工作流，高效完成各种图像生成任务，很多最新的 AI 技术比如 SVD、InstantID 发布没多久就能在 ComfyUI 中用上，这点是 WebUI 做不到的；ComfyUI 会将图像生成流程保存为工作流（workflow）文件，下次使用时直接拖入界面加载就行，这样不仅方便自己复用已有工作流，还能轻松借用大神的生成作品；而且 ComfyUI 对低显存用户也更友好，在 WebUI 中容易爆显存生成任务在 ComfyUI 中可以顺利完成。
二、ComfyUI秋叶整合包 首先我们下载最并解压 v1.1 整合包，解压后找到里面的 “ A 绘世启动器” 程序文件并双击启动，等待程序验证后就能看到熟悉的绘世启动器界面了。启动器首页的 4 个按钮可以帮我们快速打开根目录、自定义节点（custom nodes）目录、图片储存等路径；右下角的 “一键启动” 用于开启网页操作界面。
正式使用前还需要查看「版本管理」版块的相关内容，里面包含内核管理、拓展管理和安装新扩展 3 项重要功能。
「内核」里面会显示 ComfyUI 本体的版本更新情况，一般都需要更新到最新版本，否则某些节点会使用不了。更新方法为先点击右上角的刷新按钮，然后点击最新版本一行末尾的 “切换”按钮，确定后系统会弹出绿色的提示框，末尾的方框也会变成勾选的状态，表示版本切换成功。
「拓展」里会显示自定义节点的更新状态。ComfyUI 里的自定义节点我们可以简单理解为 WebUI 里的拓展插件，安装后可以帮我们实现多种不同的功能。秋葉的整合包内预装了 20 多种常用自定义节点，包括 Manager、Conntrolnet、IPAdapter、Workspace 等，可以让新手更方便的使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/926f70960e8b8bebb449eee23be0fcb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e93bfc5c7c6625340d5222fbbd678f0/" rel="bookmark">
			【前端】vue数组去重的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、数组去重说明二、Vue数组去重的3种方法 前言 随着开发语言及人工智能工具的普及，使得越来越多的人会主动学习使用一些开发工具，本文主要介绍了Vue数组去重的几种方法。
一、数组去重说明 数组去重是将数组中的重复元素移除，仅保留唯一的元素。你可以使用多种方式来实现这一点，具体取决于编程语言和需求。
二、Vue数组去重的3种方法 Vue中常见的几种数组去重方法包括：
方法一
使用ES6 Set数据结构：Set是一种集合，它只存储唯一的值，因此可以用来去除数组中的重复元素。 let arr = [1, 2, 2, 3, 4, 4, 5]; let uniqueArr = [...new Set(arr)]; console.log(uniqueArr); 方法二
2. 使用Array.prototype.filter()方法：利用filter()方法遍历数组，筛选出第一次出现的元素。
let arr = [1, 2, 2, 3, 4, 4, 5, 5, 6, 7]; let uniqueArr = arr.filter((item, index, array) =&gt; { return array.indexOf(item) === index; }); console.log(uniqueArr); 方法三
3. 使用Array.prototype.reduce()方法：利用reduce()方法逐个将元素添加到一个新数组中，但仅当该元素在新数组中不存在时。
let arr = [1, 2, 2, 3, 4, 4, 5, 5, 9]; let uniqueArr = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e93bfc5c7c6625340d5222fbbd678f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99200e31ddcc5f23123c69c39d49a116/" rel="bookmark">
			若依ruoyi-ui执行npm run dev启动报错：esnext.set.difference.v2.js in ./src/utils/index.js 处理方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、错误现象： ERROR Failed to compile with 7 errors 09:05:43
These dependencies were not found:
* core-js/modules/esnext.set.difference.v2.js in ./src/utils/index.js
* core-js/modules/esnext.set.intersection.v2.js in ./src/utils/index.js
* core-js/modules/esnext.set.is-disjoint-from.v2.js in ./src/utils/index.js
* core-js/modules/esnext.set.is-subset-of.v2.js in ./src/utils/index.js
* core-js/modules/esnext.set.is-superset-of.v2.js in ./src/utils/index.js
* core-js/modules/esnext.set.symmetric-difference.v2.js in ./src/utils/index.js
* core-js/modules/esnext.set.union.v2.js in ./src/utils/index.js
二、问题描述： 提示：这里描述项目中遇到的问题：
vue项目启动报错：To install them, you can run: npm install --save core-js/modules/es.array.push.js core-js/modules/es.error.cause.js core-js/modules/es.object.proto.
三、原因分析：缺少core-js模块 删除node_modules，首先安装报错的core-js，然后再进行cnpm install，最后启动项目。
三、解决方案： 第一步： cnpm rm -rf node_modules
第二步：cnpm install --save core-js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99200e31ddcc5f23123c69c39d49a116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed26d39b417c21976d0b089e717a9513/" rel="bookmark">
			微信小程序webview和小程序通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 1.1需要在小程序嵌入vr页面，同时在vr页面添加操作按钮与小程序进行通信交互
1.2 开发工具：uniapp开发小程序
1.3原型图
功能：.点击体验官带看跳转小程序的体验官带看页面
功能：点击立即咨询唤起小程序弹窗打电话
2.组件及api介绍 uniapp官网：web-view | uni-app官网 (dcloud.net.cn)
web-view web-view 是一个 web 浏览器组件，可以用来承载网页的容器，会自动铺满整个页面（nvue 使用需要手动指定宽高）。
各小程序平台，web-view 加载的 url 需要在后台配置域名白名单，包括内部再次 iframe 内嵌的其他 url 。
属性说明
属性名类型说明平台差异说明srcStringwebview 指向网页的链接allowString用于为 iframe 指定其特征策略H5sandboxString该属性对呈现在 iframe 框架中的内容启用一些额外的限制条件。H5fullscreenBoolean是否铺满整个页面，默认值：true。H5 (HBuilder X 3.5.4+)webview-stylesObjectwebview 的样式App-vueupdate-titleBoolean是否自动更新当前页面标题。默认值：trueApp-vue (HBuilder X 3.3.8+)@messageEventHandler网页向应用 postMessage 时，会在特定时机（后退、组件销毁、分享）触发并收到消息。H5 暂不支持（可以直接使用 window.postMessage）@onPostMessageEventHandler网页向应用实时 postMessageApp-nvue@loadEventHandler网页加载成功时候触发此事件。微信小程序、支付宝小程序、抖音小程序、QQ小程序@errorEventHandler网页加载失败的时候触发此事件。微信小程序、支付宝小程序、抖音小程序、QQ小程序 在小程序端，用法和iframe类似，直接在src赋值在线地址
&lt;web-view src="https://uniapp.dcloud.io/static/web-view.html"&gt;&lt;/web-view&gt; 注意：
小程序仅支持加载网络网页，不支持本地html小程序端 web-view 组件一定有原生导航栏，下面一定是全屏的 web-view 组件，navigationStyle: custom 对 web-view 组件无效。小程序平台， src 指向的链接需登录小程序管理后台配置域名白名单。小程序平台，个人类型与海外类型的小程序使用 web-view 组件，提交审核时注意微信等平台是否允许使用小程序的web-view使用的是小程序自带的浏览器内核，不同厂商不一样，详见各小程序平台，web-view 加载的 url 需要在后台配置域名白名单，包括内部再次 iframe 内嵌的其他 url 。 &lt;web-view&gt; 加载的网页中支持调用部分 uni 接口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed26d39b417c21976d0b089e717a9513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d591b83ac083dca521612376c644b7d/" rel="bookmark">
			LeetCode的基础入门（非常详细）零基础入门到精通，收藏这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于LeetCode都需要了解哪些？一文带你详细了解，欢迎收藏！
Python语法
reduce(function, iterable[, initializer]) reduce(lambda x,y:x * y,ns) # 数组之乘积 (ns[0] * ns[1]) * ns[2] reduce(lambda x,y:x + y,ns) # 数组之和# 记忆化搜索@functools.lru_cache(None)res = helper(0,N,0)helper.cache_clear()tuple(ns) 可以hash做参数# 大根堆q = list(map(lambda x:-x,ns))heapq.heapify(q)key = -heapq.heappop(q)# 过滤函数filter(function, iterable)` `filter(lambda x: 2 &lt; x &lt; 10 and x % 2 == 0, range(18))` `filter(dfs, range(len(graph)))# 除数div, mod = divmod(sum(ns), 4)random.randint(i,len(self.ns)-1)#第一个降序，第二个升序sorted(pss,key = lambda x:[x[0],-x[1]]) # 不可变str 常见函数split(sep=None, maxsplit=-1) # 以sep来分割字符串strip([chars]) # 去除首末两端的字符, 默认是 \r,\n," "join(iterable) # 将iterable内的元素拼接成字符串,如','.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d591b83ac083dca521612376c644b7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a59ef530cd061bd4e87efad6f3d7e3/" rel="bookmark">
			【Flutter】webview_flutter使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、如何使用 前言 webview_flutter是Flutter官方推出的一款用于Flutter上的webview插件，该插件在 iOS 用的是WKWebView 支持； 在 Android 上用的是系统WebView。
插件地址：https://pub.dev/packages/webview_flutter
一、如何使用 第一步：在项目根目录下运行如下命令配置依赖
flutter pub add webview_flutter
第二步：导入
在需要使用WebView的页面添加：
import ‘package:webview_flutter/webview_flutter.dart’;
第三步：初始化一个WebViewController
@override void initState() { super.initState(); _initWebViewController(); } void _initWebViewController() { controller = WebViewController() ..setJavaScriptMode(JavaScriptMode.unrestricted) ..setBackgroundColor(const Color(0x00000000)) ..setNavigationDelegate( NavigationDelegate( onProgress: (int progress) { // Update loading bar. }, onPageStarted: (String url) {}, onPageFinished: (String url) { //页面加载完成后才能执行js _handleBackForbid(); }, onWebResourceError: (WebResourceError error) {}, onNavigationRequest: (NavigationRequest request) { return NavigationDecision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65a59ef530cd061bd4e87efad6f3d7e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abbc3158a1c1974ef3160166f52283da/" rel="bookmark">
			Spring AOP切面执行顺序深度解析：@Before, @After, @Around的协同作战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在现代的软件开发中，代码的可维护性、可扩展性和可读性是至关重要的。为了解决这些问题，Aspect-Oriented Programming（AOP，面向切面编程）应运而生，它允许开发者在不改变原有代码的情况下，增加横切关注点，如日志记录、事务管理和权限校验等。在Spring框架中，AOP是一项核心功能，被广泛应用于各种业务场景，从而使代码更加模块化和可维护。
AOP通过切面（Aspect）来实现横切关注点的模块化。切面是一组包含多个通知（Advice）和切点（Pointcut）的类，其中通知定义了在特定切点上执行的逻辑，而切点定义了何处应用该逻辑。
Spring框架提供了一系列的注解来简化AOP的实现，包括@Before、@After、@Around等。这些注解使得开发者可以更容易地定义切面的行为，并控制它们在目标方法执行过程中的调用时机。
在本文中，我们将深入探讨这些注解在切面中的作用，以及它们如何协同工作以优化代码逻辑。特别是，我们将关注这些注解在执行顺序方面的细节，探索它们如何协同作战，以及如何在实际开发中合理运用这些知识。
通过本文的学习，读者将能够更加深入地理解Spring AOP的工作机制，掌握不同注解的使用技巧，并能够在实际项目中有效地应用这些知识，从而提高代码的质量和效率。现在，让我们开始这次关于Spring AOP切面执行顺序的深度解析之旅吧！
AOP基础知识回顾 什么是AOP？ Aspect-Oriented Programming（AOP）是一种编程范式，它旨在解决传统面向对象编程（OOP）中难以处理的问题，特别是那些横跨多个模块或层的横切关注点。这些关注点，如日志记录、事务管理和安全检查，通常散布在应用程序的多个部分中，导致代码重复和难以维护。
AOP的核心思想是通过将这些横切关注点从业务逻辑中分离出来，封装成单独的模块，这些模块被称为“切面”（Aspect）。通过这种方式，我们可以将横切关注点的实现从核心业务逻辑中解耦，使得代码更加模块化、清晰和易于维护。
AOP在Spring中的作用 在Spring框架中，AOP是一个重要的组成部分，广泛应用于各种功能，包括但不限于：
事务管理：通过AOP，Spring能够自动管理数据库事务，确保数据的一致性和完整性。
权限校验：AOP可以用于实现权限检查，确保用户只能访问他们被授权的资源。
日志记录：AOP可以捕获方法的执行，记录日志信息，提供审计和调试信息。
性能监控：通过AOP，我们可以监控方法的执行时间、调用次数等，对系统的性能进行实时监控和优化。
这些功能都能够大大提高开发效率，减少重复代码，同时也增强了系统的可维护性和可扩展性。
AOP的关键术语 在理解AOP的基础知识时，以下几个术语是非常重要的：
切点（Pointcut）：切点定义了何处应用切面的逻辑。它是一个表达式，描述了哪些方法或者类需要被切面拦截。
连接点（Joinpoint）：连接点是程序执行过程中切面可以插入的点。通常，连接点是一个方法的执行。
通知（Advice）：通知是切面在连接点上执行的动作。在Spring AOP中，通知有多种类型，包括@Before、@After、@Around等。
切面（Aspect）：切面是切点和通知的结合，它定义了在何处应用通知的逻辑。一个切面可以包含多个切点和通知。
通过理解这些关键术语，我们可以更好地理解AOP的工作原理，以及如何在Spring框架中有效地应用它们来解决实际的编程问题。
Spring切面注解详解 Spring AOP 提供了一套强大的注解，以便开发者可以轻松地定义切面的行为。以下是对这些注解的详细解释和示例。
@Before注解 使用 @Before 注解的方法将在目标方法执行之前执行。这个通知可以用于设置前置条件、参数验证或者执行前的日志记录。
示例：
@Before("execution(* com.example.service.UserService.addUser(..))") public void beforeAddUser() { System.out.println("Before adding a user..."); } @After注解 @After 注解的方法将在目标方法执行完毕后执行，无论目标方法是否成功完成。通常，这里可以进行资源清理或者后续处理。
示例：
@After("execution(* com.example.service.UserService.addUser(..))") public void afterAddUser() { System.out.println("After adding a user..."); } @AfterReturning注解 @AfterReturning 注解的方法将在目标方法正常返回后执行。这是一个理想的地方来处理返回值，例如日志记录或者转换数据格式。
示例：
@AfterReturning(pointcut = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abbc3158a1c1974ef3160166f52283da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615d86e4b7558d14da00c6a66182941d/" rel="bookmark">
			【前端】什么是面包屑？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面包屑 面包屑是网站导航中的一种可视化路径提示，通常以层次结构显示用户当前页面的位置，帮助用户了解他们在网站上的位置和浏览历史。这个术语来源于童话故事《汉赛尔与格莱特》中的面包屑小径，代表着一种追踪轨迹的方法。
假设你在一个电子商务网站上搜索并点击了以下路径的商品：
首页 &gt; 服装 &gt; 男装 &gt; 外套
在这个例子中，面包屑导航可能会以如下形式显示：
首页 &gt; 服装 &gt; 男装 &gt; 外套
这样的面包屑就像一条路径，告诉你你是如何从网站的首页到达所浏览的特定外套商品页面的。
面包屑和标签页是网站导航中的两个不同元素。
面包屑：
用途： 提供了当前页面在网站层次结构中的位置，帮助用户了解其导航路径。外观： 通常呈现为一串链接，反映了用户访问页面的历史路径。示例： 首页 &gt; 产品类别 &gt; 具体产品。 标签页：
用途： 用于同时显示多个打开的页面，方便用户在它们之间快速切换。外观： 通常是一系列小标签，每个标签代表一个打开的页面。示例： 如果你在浏览器中打开了多个网页，每个网页通常都有一个标签，你可以点击标签来切换页面。 总体而言，面包屑主要用于显示导航路径，而标签页用于方便用户管理和切换多个打开的页面。
格林童话-《汉赛尔与格莱特》 ​ 在大森林的边上，住着一个贫穷的樵夫，他妻子和两个孩子与他相依为命。他的儿子名叫汉赛尔，女儿名叫格莱特。他们家里原本就缺吃少喝，而这一年正好遇上国内物价飞涨，樵夫一家更是吃了上顿没下顿，连每天的面包也无法保证。这天夜里，愁得辗转难眠的樵夫躺在床上大伤脑筋，他又是叹气，又是呻吟。终于他对妻子说：“咱们怎么办哪！自己都没有一点吃的，又拿什么去养咱们那可怜的孩子啊？”
​ “听我说，孩子他爹，”他老婆回答道：“明天大清早咱们就把孩子们带到远远的密林中去，在那儿给他们生一堆火，再给他们每人一小块面包，然后咱们就假装去干咱们的活，把他们单独留在那儿。他们不认识路，回不了家，咱们就不用再养他们啦。”
​ “不行啊，老婆，”樵夫说：“我不能这么干啊。我怎么忍心把我的孩子丢在丛林里喂野兽呢！”
​ “哎，你这个笨蛋，”他老婆说，“不这样的话，咱们四个全都得饿死！”接着她又叽哩呱啦、没完没了地劝他，最后，他也就只好默许了。
​ 那时两个孩子正饿得无法入睡，正好听见了继母与父亲的全部对话。听见继母对父亲的建议，格莱特伤心地哭了起来，对汉赛尔说：“这下咱俩可全完了。”
​ “别吱声，格莱特，”汉赛尔安慰她说，“放心吧，我会有办法的。”
​ 等两个大人睡熟后，他便穿上小外衣，打开后门偷偷溜到了房外。这时月色正明，皎洁的月光照得房前空地上的那些白色小石子闪闪发光，就像是一块块银币。汉赛尔蹲下身，尽力在外衣口袋里塞满白石子。然后他回屋对格莱特说：“放心吧，小妹，只管好好睡觉就是了，上帝会与我们同在的。”
​ 说完，他回到了他的小床上睡觉。
​ 天刚破晓，太阳还未跃出地平线，那个女人就叫醒了两个孩子，“快起来，快起来，你们这两个懒虫！”她嚷道，“我们要进山砍柴去了。”说着，她给一个孩子一小块面包，并告诫他们说：“这是你们的午饭，可别提前吃掉了，因为你们再也甭想得到任何东西了。”格莱特接过面包藏在她的围裙底下，因为汉赛尔的口袋里这时塞满了白石子。
​ 随后，他们全家就朝着森林进发了。汉赛尔总是走一会儿便停下来回头看看自己的家，走一会儿便停下来回头看自己的家。他的父亲见了便说：“汉赛尔，你老是回头瞅什么？
​ 专心走你的路。”
​ “哦，爸爸，”汉赛尔回答说：“我在看我的白猫呢，他高高地蹲在屋顶上，想跟我说‘再见’呢！”
​ “那不是你的小猫，小笨蛋，”继母讲，“那是早晨的阳光照在烟囱上。”其实汉赛尔并不是真的在看小猫，他是悄悄地把亮亮的白石子从口袋里掏出来，一粒一粒地丢在走过的路上。
​ 到了森林的深处，他们的父亲对他们说：“嗨，孩子们，去拾些柴火来，我给你们生一堆火。”
汉赛尔和格莱特拾来许多枯枝，把它们堆得像小山一样高。当枯枝点着了，火焰升得老高后，继母就对他们说：“你们两个躺到火堆边上去吧，好好呆着，我和你爸爸到林子里砍柴。等一干完活，我们就来接你们回家。”
​ 于是汉赛尔和格莱特坐在火堆旁边，等他们的父母干完活再来接他们。到了中午时分，他们就吃掉了自己的那一小块面包。因为一直能听见斧子砍树的嘭嘭声，他们相信自己的父亲就在近旁。其实他们听见的根本就不是斧子发出的声音，那是一根绑在一棵小树上的枯枝，在风的吹动下撞在树干上发出来的声音。兄妹俩坐了好久好久，疲倦得上眼皮和下眼皮都打起架来了。没多久，他们俩就呼呼睡着了，等他们从梦中醒来时，已是漆黑的夜晚。格莱特害怕得哭了起来，说： “这下咱们找不到出森林的路了！”
​ “别着急，”汉赛尔安慰她说，“等一会儿月亮出来了，咱们很快就会找到出森林的路。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/615d86e4b7558d14da00c6a66182941d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edcf17b306afecf95e03612b59db57af/" rel="bookmark">
			hive与idea的连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Hive介绍 Hive 是一个建立在 Hadoop 之上的数据仓库系统，提供了类似于 SQL 的查询语言 HiveQL，使用户能够方便地在 Hadoop 分布式存储中执行查询和分析。它将结构化数据映射到 Hadoop 的分布式文件系统（HDFS）中，并利用 MapReduce 处理数据。Hive 的主要目标是提供高效的数据查询和分析，使非技术用户也能轻松地利用 Hadoop 处理大规模数据。
二、使用idea连接hive数据库 获取 Hive JDBC 驱动程序：首先，你需要下载并获取 Hive JDBC 驱动程序。你可以从 Apache Hive 的官方网站或者 Maven 仓库中获取该驱动程序。
添加 JDBC 驱动程序到 IntelliJ IDEA 项目：将下载的 Hive JDBC 驱动程序添加到你的 IntelliJ IDEA 项目中。可以在项目设置中添加外部 JAR 文件或者将其添加为 Maven 依赖项。
在 IntelliJ IDEA 中配置数据源：在 IntelliJ IDEA 中打开 "Database" 工具窗口，然后选择 "View" -&gt; "Tool Windows" -&gt; "Database"。接下来，点击窗口顶部的加号图标，选择 "Data Source" -&gt; "Hive"。在弹出的窗口中，填写 Hive 数据库的连接信息，包括 JDBC URL、用户名和密码等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edcf17b306afecf95e03612b59db57af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd864851433d3df25206b85a4775bbcb/" rel="bookmark">
			Tuxera2023 NTFS for Mac 的安装、密钥下载与激活教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经是2024年了，截止目前Tuxera2024还没出来，今天仍然给大家分享的是Tuxera2023的破解版，希望大家能喜欢，更希望动动你的小手给我的文章分享和收藏。
一、安装教程
系统：macOS Monterey
具体安装教程如下：
1、首先下载Tuxera最新版2023（务必从本帖下载安装的Tuxera方可激活） Tuxera2023免费安装包下载：https://souurl.cn/LoLFxi
2、安装包下载完成之后打开，咱们点击【安装Tuxera NTFS】；
3、安装之前，会有个提示：此软件包将运行一个程序以确定该软件能否安装，点击【允许】，然后安装向导就会出现，在出现的介绍中，我们可以观察到这款读写软件所包含的组件，点击【继续】；
4、阅读一下软件许可协议，觉得没有问题就点击【继续】，在跳出来的询问窗口中点击【同意】，稍等片刻就会跳至安装类型，直接点击【安装】，输入密码来允许安装新软件；
5、先从百度网盘下载Tuxera2023最新密钥。
最新密钥百度网盘获取：https://pan.baidu.com/s/1t3VMxysgV4B9vwH2_uTWvw?pwd=2333 提取码：2333
6、接下来就会跳出提示：系统扩展已更新，需要我们手动批准，按照提示点击【打开安全性偏好设置】；
7、首先点击界面左下角的小锁标志进行解锁，然后点击【允许】按钮；
8、安装使用注册码开始激活，激活过程可能要等一会，要注意等待；
9、激活好之后会提示设置系统扩展权限，我们开锁点击允许，然后会提示重启，我们点击重启再进系统就可以使用了。
10、接下来会提醒我们需要重新启动才能使用新的系统扩展，点击重新启动即可。
以上就是安装教程的全部介绍了，在最后一步的安装成功提示中，告诉我们可以在系统偏好设置中找到已经安装好的软件，如果我们需要运行，则可以在此找到。
2、Tuxera2022软件下载与密钥获取 Tuxera2023下载： https://souurl.cn/LoLFxi
Tuxera 2023更多激活密钥获取 ：https://pan.baidu.com/s/1t3VMxysgV4B9vwH2_uTWvw?pwd=2333 提取码：2333
如果密钥地址失效了，欢迎留言反馈～
Tuxera2023永久使用入口：https://souurl.cn/QQuvxs，优惠码：LCUU1818（可抵扣10元）购买
的时候输入优惠码，可立减10元，具体如下图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3974d503979d6bd3ea8eb32139ef9726/" rel="bookmark">
			学生或教师免费申请copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm配置copilot–这篇文章详述了pycharm配置copilot的过程
pycharm安装及破解–这篇文章详述了pycharm安装及破解过程
1.Github对学生和老师提供免费的Copilot功能
2.首先需要有个github个人账号，自行注册
3.http://copilot.github.com/
打开上面的网址
点击Sign in，使用自己的github账号，进入登录界面后点击右上角头像
防止审核不通过，需要进行一些资料的补充
点击Your profile
点击Edit profile
在Name编辑框中填上自己的真实姓名（用拼音表示）
在Bio编辑框中，套用（我叫什么名字，在什么大学主修什么专业）这个模板，使用英文表达方式
最后点击 save 保存按钮
点击右上角头像，选择Settings选项
选择 Emails
在Add email address编辑框中添加edu邮箱，点击Add按钮，（此时，登录edu邮箱查看验证信息，根据验证信息进行操作）
等待添加成功之后，在Primary email address选择框中选择新添加的edu邮箱，然后点击save保存按钮（这里是为了后续的验证，不选择edu邮箱作为主邮箱会验证失败，等验证成功之后可以换回自己的邮箱）
4.打开Github学生包网址
https://education.github.com/discount_requests/application
5.点击Sign in 进行登录
6.选择你的身份
7.
在这里选择你的邮箱(选择的edu邮箱)，然后学校的名称，一切就绪之后，点击Continue按钮（因为我这里已经认证过了，所以点击continue按钮是无反应的）
后续的话！！！（因为当时验证的步骤没有截图，这里continue又不可以点击，所以只用简单的文字描述）
会让你提交一个验证，可以是学信网的学籍验证，也可以是学生证验证
学信网的地址：https://www.chsi.com.cn/
当你提供了验证的照片的时候，下面会出现一个进度条，当进度条结束的时候不要着急地去关闭页面，可能会出现验证失败的情况，看一下出错的原因，没关系，可以重新提交，但是这里需要更换图片，继续使用上次提供的图片是通过不了的
8.
当出现Approved的时候就是申请成功了，如果是Rejected则是未申请成功
9.申请Copilot
Copilot地址：https://github.com/features/preview/copilot-x
点击Copilot地址打开页面，再点击Get started with Copilot
点击Start free trial
在这里可以看到可使用Copilot插件的一些编译器
10.如果是在Pycharm编译器中使用Copilot,建议使用pycharm2021版本及以后的版本
根据copilot官网显示，pycharm2021之前版本不支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17528a68135e41db65651db57a66dd54/" rel="bookmark">
			Hadoop平台安装及运行————详细版搭建流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Hadoop平台安装
一、配置 Linux 系统基础环境
步骤一：查看服务器的 IP 地址 查看服务器的 IP 地址
步骤二：设置服务器的主机名称
步骤三：绑定主机名与 IP 地址
步骤四：查看 SSH 服务状态
步骤五：关闭防火墙
步骤六：创建 hadoop 用户
二：安装 JAVA 环境
步骤一：安装 JDK
步骤二：设置 JAVA 环境变量
二、安装 Hadoop 软件
一、安装 Hadoop 软件
步骤一：安装 Hadoop 软件
步骤二：配置 Hadoop 环境变量
步骤三：修改目录所有者和所有者组
三、安装单机版 Hadoop 系统
一：配置 Hadoop 配置文件
二：测试 Hadoop 本地模式的运行
步骤一: 切换到 hadoop 用户
步骤二: 创建输入数据存放目录
步骤三: 创建数据输入文件
步骤四: 测试 MapReduce 运行
四、Hadoop平台环境配置
一：实验环境下集群网络配置
二：SSH 无密码验证配置
一、生成 SSH 密钥
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17528a68135e41db65651db57a66dd54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806907b1b088d8ac707141e357dace64/" rel="bookmark">
			基于Java的物联网云平台完整源码及功能模块解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备远程控制物联网云平台全套源码
该物联网云平台使用 Java 语言、主流技术组合（MQTT、Spring Boot、Shiro、MyBatis、Druid、Ehcache、Thymeleaf、Bootstrap、Swagger）开发，支持多数据源，支持代码一键生成。
1、包含物联网云平台源码（源码全部开放，无任何加密，可二次开发）、MQTT服务、数据库设计、相关资料、相关工具软件等，可提供，可远程协助。
2、支持云固件升级、远程重启功能，支持音频播放、开关、普通灯、调色灯等各种用电设备控制。
3、云平台可对各类传感器（温度、湿度、光照、人体感应、电压、电流、电平状态等等）管理，对传感器数据有多种展示方式。
可设置阈值报警规则，符合报警规则的可执行自定义的动作、联动报警、报警通知等。
4、云端可存储各路开关状态，模块断电或重启后可自动同步云端各路开关状态，具有开关状态记忆功能。
5、使用基于发布/订阅模式的轻量级通讯协议 MQTT，具有自动重连 MQTT 服务机制，具有模块上下线提醒功能（平台消息提醒、邮件提醒）。
6、控制命令下达后有执行状态反馈，可确保设备控制命令执行成功。
7、具有可视化在线定时任务配置功能，可指定某一时刻执行、周期执行、自定义 Cron 表达式执行等操作。
8、可记录设备所有操作记录，模块、用户上下线记录等，并具有多种类型的数据统计展示。
9、云平台可对所有用户管理，每个用户可配置不同角色、不同权限，具有权限分配功能。
支持对人员进行菜单、按钮及数据权限控制，亦可自定义数据权限。
10、前端采用完全响应式布局，支持电脑、平板、手机等所有主流设备。
11、具有代码一键生成功能，方便快速开发。
支持多数据源、服务监控、数据监控、缓存监控功能。
12、具有完善的 XSS 防范及脚本过滤，彻底杜绝 XSS 攻击。
13、Maven 多项目依赖，模块及插件分项目，尽量松耦合，方便模块升级、增减模块。
等等……内容较多在此无法一一列举。
内含功能模块：
设备管理、开关管理、计划管理、传感器管理、传感器数据展示、报警规则管理、设备日志、用户管理、角色管理、菜单管理、部门管理、岗位管理、字典管理、参数管理、通知公告、操作日志、登录日志、在线用户、定时任务、数据监控、服务监控、缓存监控、表单构建、代码生成、系统接口等。
ID:94488673743429215
物联网云平台 设备远程控制物联网云平台全套源码
摘要：本文介绍了一个设备远程控制物联网云平台的全套源码，该平台使用Java语言以及主流技术组合开发，支持多数据源，支持代码一键生成。本文将分别介绍该平台的主要功能模块，并详细讨论其实现原理。通过本文，读者可以了解到该物联网云平台的开发框架以及各个功能模块的实现细节。
引言
随着物联网技术的快速发展，设备远程控制成为了实现智能家居和智能办公的关键技术之一。在传统的物联网应用中，设备控制往往需要通过物理接口进行操作，不仅操作繁琐，而且受到地理位置和时间的限制。为了解决这一问题，我们开发了一个设备远程控制物联网云平台，该平台可以实现对各类设备的远程控制和管理。本文将介绍该物联网云平台的设计、实现和部署等方面的内容。
设计概述
2.1 框架选择
该物联网云平台使用Java语言开发，并采用了一系列主流技术组合，包括MQTT、Spring Boot、Shiro、MyBatis、Druid、Ehcache、Thymeleaf、Bootstrap和Swagger等。这些技术组合的选择主要考虑了系统的稳定性、性能和易用性等方面的需求。
2.2 功能模块
该物联网云平台包含多个功能模块，包括设备管理、开关管理、计划管理、传感器管理、传感器数据展示、报警规则管理、设备日志、用户管理、角色管理、菜单管理、部门管理、岗位管理、字典管理、参数管理、通知公告、操作日志、登录日志、在线用户、定时任务、数据监控、服务监控、缓存监控、表单构建、代码生成和系统接口等。下面将对其中几个重要的功能模块进行详细介绍。
2.2.1 设备管理
设备管理模块提供了对各类设备的管理功能，用户可以添加、编辑和删除设备信息。每个设备都有唯一的标识符和名称，并可以关联到对应的传感器和开关。设备管理模块还提供了设备状态的监控和展示功能，用户可以实时查看设备的在线状态和各个开关的状态。
2.2.2 开关管理
开关管理模块提供了对各个设备开关的管理功能，用户可以通过该模块对设备开关进行控制。开关管理模块还支持开关状态的同步功能，即当设备断电或重启后，开关状态可以自动同步到云端。
2.2.3 传感器管理
传感器管理模块提供了对各类传感器的管理功能，用户可以添加、编辑和删除传感器信息。每个传感器都有唯一的标识符和名称，并可以设置传感器的阈值报警规则。传感器管理模块还提供了多种传感器数据的展示方式，用户可以选择合适的展示方式查看传感器数据。
2.2.4 报警规则管理
报警规则管理模块提供了对传感器报警规则的管理功能，用户可以设置传感器的报警阈值和触发动作。当传感器的数据达到报警阈值时，系统会执行相应的报警动作，包括自定义动作、联动报警和报警通知等。
实现原理
3.1 MQTT通讯协议
该物联网云平台使用基于发布订阅模式的轻量级通讯协议MQTT进行设备之间的通讯。MQTT具有自动重连机制和模块上下线提醒功能，保证了通讯的稳定性和可靠性。 3.2 Java开发框架
该物联网云平台使用Java开发，采用了Spring Boot框架，实现了代码的模块化和解耦。平台还支持多数据源、服务监控、数据监控和缓存监控等功能，提高了系统的可扩展性和可维护性。
3.3 前端展示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/806907b1b088d8ac707141e357dace64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cb7bb20e971c99a911bbe4930912b12/" rel="bookmark">
			C语言内存操控的艺术探索：踏足四大秘境，铸就内存管理之巅峰传奇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到白刘的领域 Miracle_86.-CSDN博客 系列专栏 C语言知识 先赞后看，已成习惯 创作不易，多多支持！ 在C语言的内存管理领域，四大秘境之一的内存操作函数无疑为程序员提供了强大的工具。这些函数——memcpy、memmove、memset、memcmp——各自拥有独特的用途和特性，它们在内存操控中扮演着至关重要的角色。
目录
一、memcpy——内存的拷贝艺术
1.1 memcpy的使用
1.2 memcpy的模拟实现
1.3 重叠问题
二、memmove——内存的移动魔法
2.1 memmove的使用
2.2 memmove的模拟实现
三、memset——内存的初始化神器
四、memcmp——内存的比较之术
一、memcpy——内存的拷贝艺术 在前面我们讲了许多字符串函数：
C语言字符函数与字符串函数：编织文字的舞会之梦（上）-CSDN博客
C语言字符函数与字符串函数：编织文字的舞会之梦（下）-CSDN博客
其中我们发现strcpy和memcpy非常相似，我们了解了str代表字符串，cpy代表copy，也就是拷贝，那mem是什么呢？其实它是memory的简写，memory我们都知道是记忆的意思，而它还有一个意思——内存。可以简单理解为计算机的记忆，那不就是内存嘛。那我们可以推断出来，memcpy，它的作用是用来拷贝内存的。
1.1 memcpy的使用 它的原型如下：
void* memcpy(void* destination, const void* source, size_t num); 不难看出，它和strncpy的参数是一模一样的，没错，正是如此，只不过它可以copy任意类型的，而strncpy只能拷贝字符串。
1.原理：memcpy从source的位置开始，向后复制num个字节，到destination指向的内存的位置。
2.与strncpy不同的是，mem在遇到'\0'时不会停止。
3.使用需要包含头文件&lt;string.h&gt;。
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; int arr2[10] = { 0 }; memcpy(arr2, arr1, 20); int i = 0; for (i = 0; i &lt; 10; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cb7bb20e971c99a911bbe4930912b12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4003066dd9fe397f9959f46f91f4ef68/" rel="bookmark">
			polarctf靶场 【web】签到题、简单 rce、蜜雪冰城吉警店、到底给不给flag呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[web]签到题 考点：Cookie伪造、php伪协议、双写绕 查看源代码
​
再用bp抓包，根据题目是弟弟，Cookie伪造，将no改为yes
​
​
发送
​
​
看到可能是base64编码，将其解码
​
​
访问其目录
​
​
php伪协议结合双写绕过，用伪协议以base64编码进行内容读取
?file=php://filter/convert.base64-encode/resource=..././..././..././..././flag ​
​
再进行base64解码
​
[web]简单 rce 考点：rce ​
​
&lt;?php highlight_file(__FILE__); //对文件进行语法高亮显示 function no($txt){	//定义一个no函数，并传入变量txt if(!preg_match("/cat|more|less|head|tac|tail|nl|od|vim|uniq|system|proc_open|shell_exec|popen| /i", $txt)){	//preg_match 函数用于执行一个正则表达式匹配 return $txt;	//返回参数值 }else{ die("what's up"); //输出一条消息，并退出当前脚本 } } $yyds=($_POST['yyds']);	//通过POST方式传递参数yyds if(isset($_GET['sys'])&amp;&amp;$yyds=='666'){ //通过GET方式传递参数sys；并判断 eval(no($_GET['sys']));	//调用no函数，并输出 }else{ echo "nonono";	//输出nonono	} ?&gt; 命令执行函数：
system() 输出并返回最后一行shell结果。 exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。 passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。（替换system） shell_exec() popen()/proc_open() 输出函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4003066dd9fe397f9959f46f91f4ef68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2018a637862b8a5e847bbbe878885bde/" rel="bookmark">
			支付宝无限实名技术（纯好奇），解决异地收款限制，解决无号可用的困境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突破支付宝同时实名3个的技术上线，纯好奇摸索出来的。
import requests import json # 替换为你的应用ID和应用私钥 APP_ID = 'your_app_id' APP_PRIVATE_KEY = 'your_private_key' # 请求支付宝实名认证接口 def alipay_realname_auth(real_name, id_card): url = 'https://openapi.alipay.com/gateway.do' # 构造请求参数 params = { 'app_id': APP_ID, 'method': 'alipay.user.certify.open.certify', 'charset': 'utf-8', 'sign_type': 'RSA2', 'timestamp': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'version': '1.0', 'biz_content': json.dumps({ 'cert_name': real_name, 'cert_no': id_card }) } # 生成签名 sign = generate_sign(params) params['sign'] = sign # 发送请求 response = requests.post(url, data=params) result = response.json() return result # 生成签名 def generate_sign(params): unsigned_items = sorted(params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2018a637862b8a5e847bbbe878885bde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50fb56c6b13f6c3ffe06bd181bfc419/" rel="bookmark">
			艾体宝案例 | 使用Redis和Spring Ai构建rag应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着AI技术的不断进步，开发者面临着如何有效利用现有工具和技术来加速开发过程的挑战。Redis与Spring AI的结合为Java开发者提供了一个强大的平台，以便快速构建并部署响应式AI应用。探索这一整合如何通过简化的开发流程，让开发者能够更专注于创新而非底层实现。
一、Spring AI简介 由大型语言模型（LLM）驱动的应用程序中，向量数据库常作为人工智能应用程序的核心存储技术。此类数据库需要支持语义搜索，并为LLM提供相关的上下文环境。
在此之前，通过Spring和Redis来构建人工智能应用程序的选项还相对有限。而最近，Redis作为一种高性能的向量数据库方案，现已引起广泛关注。Spring社区推出了一个名为Spring AI的新项目，旨在简化人工智能应用程序特别是那些涉及向量数据库的应用的开发流程。
下面将介绍如何使用Redis作为向量数据库构建一个Spring AI应用程序，实现检索增强生成（RAG）工作流。
二、检索增强生成 检索增强生成（RAG）是一种结合数据与人工智能模型的技术方法。在RAG工作流中，首先需要将数据加载入向量数据库（例如Redis）。接收到用户查询后，向量数据库会检索出一组与查询相似的文档。这些文档将作为解答用户问题的上下文，并结合用户的查询，通常通过人工智能模型来生成响应。
本例中，我们将利用一个包含各类啤酒信息的数据集进行演示，数据集中包含啤酒的名称、酒精含量（ABV）、国际苦味单位（IBU）和描述等属性。该数据集将被加载到Redis中，以展示RAG工作流的实际应用。
三、代码和依赖关系 可以在GitHub上找到Spring AI和Redis演示的全部代码。
本项目使用了Spring Boot作为Web应用程序的启动依赖项，并结合了Azure OpenAI和Spring AI Redis。
四、数据加载 我们的应用程序将采用提供啤酒信息的JSON文档作为数据来源。每个文档的结构如下：
{ "id": "00gkb9", "name": "Smoked Porter Ale", "description": "The Porter Pounder Smoked Porter is a dark rich flavored ale that is made with 5 malts that include smoked and chocolate roasted malts. It has coffee and mocha notes that create a long finish that ends clean with the use of just a bit of dry hopping"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d50fb56c6b13f6c3ffe06bd181bfc419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f6f1cd1f847c7d11bf89d66c9653b3/" rel="bookmark">
			Spring Boot整合Redisson的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景 Spring Boot整合Redisson的两种方式，方式一直接使用yml配置，方式二创建RedissonConfig配置类。
前言 redisson和redis区别：
Redis是一个开源的内存数据库，支持多种数据类型，如字符串、哈希、列表、集合和有序集合等，常用于缓存、消息队列、计数器、分布式锁和搜索等应用场景。Redisson则是一个基于Redis实现的Java驻内存数据网格，提供了一系列分布式的Java常用对象和多种锁机制，以及分布式服务，使开发者能更集中于处理业务逻辑。Redisson不支持字符串操作、排序、事务、管道、分区等Redis特性，但Redisson 提供了许多其他功能，如分布式闭锁、分布式计数器、分布式信号量等。 前提准备 版本：spring boot2.3.1.RELEASE，redisson3.21.1
maven依赖：
&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.21.1&lt;/version&gt; &lt;/dependency&gt; 集成方案： 方式一：使用yml配置 1.单节点配置 单节点配置可以兼容redis的配置方式
application.yml
# redis配置 spring: redis: database: 0 host: 127.0.0.1 password: redis@pass port: 6001 或者使用 redisson.yml文件的方式
application.yml这里引用了redisson.yml文件
spring: redis: # redisson配置 redisson: file: classpath:redisson.yml redisson.yml
# 单节点配置 singleServerConfig: # 数据库编号 database: 0 # 节点地址 address: redis://127.0.0.1:6001 # 密码 password: redis@pass application.yml与 redisson.yml在同级，目录结构如下：
2.集群模式配置 集群模式不能兼容redis之前的配置方式
application.yml没变
spring: redis: # redisson配置 redisson: file: classpath:redisson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f6f1cd1f847c7d11bf89d66c9653b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f2d8b1d3d4c45ab6e2468f782ef6cf/" rel="bookmark">
			SQL中PIVOT函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. SQL Server2. MySQL3. Oracle 前言 PIVOT 是 SQL Server 中的一个功能，用于将行转换为列。然而，MySQL 和 Oracle 不直接支持 PIVOT 语法。但是，你可以使用条件聚合或其他技术来模拟 PIVOT 的行为。
语法：
-- 从子查询中选择数据，子查询从源表中选择需要的数据 SELECT ... FROM ( -- 源查询，从源表中选取你希望进行PIVOT操作的列 SELECT ... FROM &lt;source_table&gt; -- 可以包含WHERE子句、GROUP BY子句等以筛选或组织数据 ) AS SourceTable -- PIVOT操作，将行数据转换为列数据 PIVOT ( -- 聚合函数，用于计算每个新列的值 aggregate_function(&lt;column_value&gt;) -- 指定要进行转换的列名 FOR &lt;column_name&gt; -- 指定转换后新列的名称列表 IN ([first_pivoted_column], [second_pivoted_column], ...) ) AS PivotTable; 以下是如何在 SQL Server、MySQL 和 Oracle 中实现类似 PIVOT 的操作的示例。
1. SQL Server 假设你有一个名为 sales 的表，其中包含 year, product, 和 amount 三个字段：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f2d8b1d3d4c45ab6e2468f782ef6cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2f68ece8ed46cb3e0cf54b7fc4d629/" rel="bookmark">
			【SQL】MySQL中的字符串处理函数：concat 函数拼接字符串，COALESCE函数处理NULL字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL中的字符串处理函数：concat 函数 一、concat （）函数1.1、基本语法1.2、示例1.3、特殊用途 二、COALESCE（）函数2.1、基本语法2.2、示例2.3、用途 三、进阶练习3.1 条件和 SQL 语句3.2、解释 一、concat （）函数 MySQL的 CONCAT 函数是一个非常实用的字符串函数，用于将两个或多个字符串参数连接成一个单一的字符串。如果任何一个参数为 NULL，则 CONCAT 函数的结果也会是 NULL。这一点在构建包含潜在NULL值的数据库查询时特别重要，因为它可能影响到你的查询结果。
1.1、基本语法 CONCAT(string1, string2, ..., stringN) 参数
string1, string2, …, stringN：这些是要连接的字符串。你可以连接任意数量的字符串。
1.2、示例 假设有一个数据库表 users，其中包含 first_name 和 last_name 两个字段，下面的例子展示了如何使用 CONCAT 来生成一个完整的姓名：
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users; 这将把 first_name 和 last_name 通过一个空格连接起来，形成一个 full_name。
1.3、特殊用途 与 LIKE 操作符结合使用：在需要进行模糊匹配的搜索查询中，CONCAT 可以用来包围搜索关键字，以实现任意位置的模糊匹配。
SELECT * FROM products WHERE name LIKE CONCAT('%', 'apple', '%'); 这个查询会返回所有产品名称中包含 "apple" 的记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2f68ece8ed46cb3e0cf54b7fc4d629/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/397/">«</a>
	<span class="pagination__item pagination__item--current">398/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/399/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>