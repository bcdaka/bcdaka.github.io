<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ddfd3d23b11b259fc4d7547913080a/" rel="bookmark">
			手撕Python之条件语句和循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.比较运算符 2.判断 单条件判断，我们就需要用到if
程序的正常执行流程是从上往下依次执行
我们可以使用流程控制语句中的if语句来根据不同的情况执行不同的代码
单个条件的判断使用if关键字
两个条件使用if…else
多个条件使用if…elif…else
if关键字判断后面的条件，如果为真，就进行下面代码的编译
如果为假，那么就直接跳过这串代码运行后面的代码
格式：if 判断条件:
这里的格式一定要有冒号
然后直接换行
如果没有冒号的话，那么这个代码就是错的
我们在写下if条件语句后回车会出现一个缩进，大小为一个Tab键
然后我们就写下我们的代码
那么我们写下的这个代码就是属于这个if条件语句的
如果条件为真，那么我们就运行这个条件语句里面的代码
但是如果条件是假的话，那么我们就不运行这个代码
if条件语句的用法：
#输入用户名，判断用户名是否正确 name=input("请输入用户名") if name=="huyunkai": print("输入正确") 上面的if是条件成立的情况
那么如果不成立呢？
那我们就用else
加上els:
#输入用户名，判断用户名是否正确 name=input("请输入用户名") if name=="huyunkai": print("输入正确") else: print("输入错误") 如果我们的条件不满足的话，那么编译器就会调用else里面的代码的
用户输入数学成绩，判断成绩是否及格（60分及以上为及格）
#用户输入数学成绩，判断成绩是否及格（60分及以上为及格） score=eval(input("请输入成绩"))#我们不能直接将我们输入的变量拿来比较，我们需要进行类型转换的操作 if score&gt;=60: print("成绩及格")#判断条件成立时执行的代码 else: print("成绩不及格")#判断条件不成立时执行的代码 当我们遇到多条件判断的时候
那么我们就要用到elif
这个elif是可以出现多个的
多种情况之下的写法：
#判断时有多个情况，那么我们就会使用到elif #只要if的条件为真的话，那么我们就不会执行后面的条件语句的 score=eval(input("请输入你的成绩")) if 90&lt;=score&lt;=100: print("成绩优秀") elif 80&lt;=score&lt;=89: print("成绩良好") elif 70&lt;=score&lt;=79: print("成绩中等") elif 60&lt;=score&lt;=69: print("成绩及格") else : print("成绩不及格") 3.三目运算 格式：表达式1 if 条件表达式 else 表达式2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51ddfd3d23b11b259fc4d7547913080a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee1727c449a55e21818a9e3c3b8a6c5/" rel="bookmark">
			Xml 映射文件中常见的标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、动态 SQL 标签 MyBatis 提供了一系列标签来处理动态 SQL，它们能够根据传入的参数生成不同的 SQL 语句。这些标签包括：
1. **`&lt;if&gt;` 标签** `&lt;if&gt;` 标签用于根据条件判断是否包含某段 SQL 语句。可以使用它来实现动态拼接 SQL。
```xml &lt;select id="findUsers" resultType="User"&gt; SELECT * FROM users WHERE 1=1 &lt;if test="name != null"&gt; AND name = #{name} &lt;/if&gt; &lt;if test="age != null"&gt; AND age = #{age} &lt;/if&gt; &lt;/select&gt; ``` 在上面的例子中，只有当 `name` 或 `age` 参数不为空时，相关的 SQL 片段才会被拼接到最终的查询语句中。
2. **`&lt;choose&gt;`、`&lt;when&gt;` 和 `&lt;otherwise&gt;` 标签** 这些标签用于实现类似于 `switch-case` 的逻辑选择。
&lt;select id="findUsersByCondition" resultType="User"&gt; SELECT * FROM users WHERE 1=1 &lt;choose&gt; &lt;when test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee1727c449a55e21818a9e3c3b8a6c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a9171f1e13d9a4fdcba6fe9e245c8b/" rel="bookmark">
			django外键表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django外键（ForeignKey）操作以及related_name的作用-CSDN博客
django模型中外键操作_django的model的contain外键-CSDN博客
通过基本表可以查外键表
删基本表可以删外键表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919996ff17381bf4c81ee6c45cc8a473/" rel="bookmark">
			html,css学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html,css学习记录 htmlcss盒子模型 html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;mykingdom&lt;/title&gt; &lt;link rel="stylesheet" href="1.css"&gt; &lt;/head&gt; &lt;body id="ceiling"&gt; &lt;h1&gt;我的王国&lt;/h1&gt; &lt;h2&gt;基础文本&lt;/h2&gt; &lt;p&gt;sada&lt;b&gt;adf&lt;/b&gt;fmkmklnkm &lt;br /&gt; &lt;br /&gt; klmmkoooji&lt;/p&gt; &lt;i&gt;fafaf&lt;/i&gt; &lt;strong&gt;affa&lt;/strong&gt; &lt;em class="blue"&gt;fagag&lt;/em&gt; &lt;s&gt;faag&lt;/s&gt; &lt;ins&gt;asfga&lt;/ins&gt; &lt;div id="green"&gt;我一个人占一行&lt;/div&gt; &lt;div&gt;我一个人占一行&lt;/div&gt; &lt;div&gt;我一个人占一行&lt;/div&gt; &lt;p&gt;adfklfjf&lt;/p&gt; &lt;h2 class="blue back-yellow"&gt;图片标签&lt;/h2&gt; &lt;h4&gt;皮卡丘&lt;/h4&gt; &lt;img src="img/ds.jpg" width="100"&gt; &lt;h4&gt;alt:图像显示不出来是显示的文字&lt;/h4&gt; &lt;img src="img1/ds.jpg" alt="哎呀，图片显示不出来啦~~" width="100"&gt; &lt;h4&gt;title:鼠标放到图片上显示的文字&lt;/h4&gt; &lt;img src="img/ds.jpg" title="皮卡丘" width="100"&gt; &lt;h4&gt;border:给图像设定边框&lt;/h4&gt; &lt;img src="img/ds.jpg" title="皮卡丘" width="100" border="5"&gt; &lt;h2&gt;超链接&lt;/h2&gt; &lt;h3&gt;外部链接&lt;/h3&gt; &lt;h4&gt;从本页面跳转&lt;/h4&gt; &lt;a href="https://blog.csdn.net/2301_79347603?spm=1000.2115.3001.5343" target="_self"&gt;欢迎关注我的博客&lt;/a&gt; &lt;h4&gt;另开一个页面&lt;/h4&gt; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/919996ff17381bf4c81ee6c45cc8a473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d695dd9171039801f69b7e94f8f475d/" rel="bookmark">
			AutoGen 检索增强生成（RAG）功能解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是检索增强（RAG） ？
二、AutoGen 检索增强（RAG）
三、实例
本文主要对 AutoGen 检索增强生成（RAG）功能进行解析，并通过两个实例来说明。
一、什么是检索增强（RAG） ？ 检索增强生成 (RAG) 是大模型的一种扩展技术，它将大模型与外部知识检索相结合，以提高生成的响应的质量和相关性，例如：FastGPT。
RAG架构图如下所示。
主要流程如下所示：
（1）用户（User）提出问题（Query）;
（2）在数据库（Data Source）中查询与问题（Query）相关的内容，这些内容将作为 LLM 的上下文（Text），将问题（Query）和上下文（Text）一起传给 LLM；
（3）LLM 根据 Data Source 中检索到的内容组织回答，最终生成回答，返回给用户；
这样就很大程度上避免了 LLM 幻觉问题，充分利用了 LLM 语言生成的能力。
二、AutoGen 检索增强（RAG） AutoGen 虽然是多代理协作的框架，AutoGen 同样也支持 RAG 功能，AutoGen 是通过 AssistantAgent 和 RetrieveUserProxyAgent 类构建代理聊天实现。
2.1 RetrieveUserProxyAgent 函数
RetrieveUserProxyAgent 根据问题的嵌入检索文档块，并将它们与问题一起发送给检索增强助手，该类继承自 UserProxyAgent。
class RetrieveUserProxyAgent(UserProxyAgent) 主要函数为 __init__，如下所示。
def __init__(name="RetrieveChatAgent", human_input_mode: Literal["ALWAYS", "NEVER", "TERMINATE"] = "ALWAYS", is_termination_msg: Optional[Callable[[Dict], bool]] = None, retrieve_config: Optional[Dict] = None, **kwargs) 参数介绍：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d695dd9171039801f69b7e94f8f475d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d89fb0f5a7759fb7600df84cb71644/" rel="bookmark">
			RabbitMQ简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		18. RabbitMQ 18.1. RabbitMQ简介 首先引入一个消息队列中间件概念： 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性[架构] 使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQRabbitMQ是一种消息中间件，用于处理来自客户端的异步消息。服务端将要发送的消息放入到队列池中。接收端可以根据RabbitMQ配置的转发机制接收服务端发来的消息。RabbitMQ依据指定的转发规则进行消息的转发、缓冲和持久化操作，主要用在多服务器间或单服务器的子系统间进行通信，是分布式系统标准的配置。RabbitMQ的使用场景： 服务解耦、流量削峰、异步调用 服务解耦： 假设有这样一个场景, 服务A产生数据, 而服务B,C,D需要这些数据, 那么我们可以在A服务中直接调用B,C,D服务,把数据传递到下游服务即可，但是,随着我们的应用规模不断扩大,会有更多的服务需要A的数据,如果有几十甚至几百个下游服务,而且会不断变更,再加上还要考虑下游服务出错的情况,那么A服务中调用代码的维护会极为困难，这是由于服务之间耦合度过于紧密A服务只需要向消息服务器发送消息,而不用考虑谁需要这些数据;下游服务如果需要数据,自行从消息服务器订阅消息,不再需要数据时则取消订阅即可 流量削峰： 假设我们有一个应用,平时访问量是每秒300请求,我们用一台服务器即可轻松应对而在高峰期,访问量瞬间翻了十倍,达到每秒3000次请求,那么单台服务器肯定无法应对,这时我们可以考虑增加到10台服务器,来分散访问压力，但如果这种瞬时高峰的情况每天只出现一次,每次只有半小时,那么我们10台服务器在多数时间都只分担每秒几十次请求,这样就有点浪费资源了流量削峰情况下,瞬间出现的大量请求数据,先发送到消息队列服务器,排队等待被处理,而我们的应用,可以慢慢的从消息队列接收请求数据进行处理,这样把数据处理时间拉长,以减轻瞬时压力 异步调用: 考虑定外卖支付成功的情况,支付后要发送支付成功的通知,再寻找外卖小哥来进行配送,而寻找外卖小哥的过程非常耗时,尤其是高峰期,可能要等待几十秒甚至更长。这样就造成整条调用链路响应非常缓慢引入RabbitMQ消息队列,订单数据可以发送到消息队列服务器,那么调用链路也就可以到此结束,订单系统则可以立即得到响应,整条链路的响应时间只有200毫秒左右，寻找外卖小哥的应用可以以异步的方式从消息队列接收订单消息,再执行耗时的寻找操作 原文链接：RabbitMQ_rabbitmq csdn-CSDN博客
18.2. 一些概念解析 RabbitMQ Server：也叫broker server，它是一种传输服务。他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。Producer：消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服务器然后将消息投递到Exchange。Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，多个消费者可以订阅同一个Queue，其中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则。 Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 Producer： 消息生产者，就是投递消息的程序 Consumer： 消息消费者，就是接受消息的程序 Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务 注 ：由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。 18.3. RabbitMQ的三种模式 18.3.1. 直接模式 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 消息一次发给一个队列
18.3.2. 分裂模式 任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。
可以理解为路由表的模式这种模式不需要RouteKey这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。 18.3.3. 主题模式 任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上。此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模糊匹配的意思，a.# #.b a.b注：交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上新建一个交换器，类型选择topic -- 点击新建的交换器topictest @RunWith(SpringRunner.class) @SpringBootTest(classes = RabbitMQApplication.class) public class RabbitTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void send1(){//给队列中放东西测试 String message = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d89fb0f5a7759fb7600df84cb71644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfbbf9a668b5efd3bde0a7c1da88fb10/" rel="bookmark">
			数据同步的艺术：探索PostgreSQL和Redis的一致性策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：后端小肥肠
🍇 我写过的文章中的相关代码放到了gitee，地址：xfc-fdw-cloud: 公共解决方案
🍊 有疑问可私信或评论区联系我。
🥑 创作不易未经允许严禁转载。
1. 前言 在当今高度数字化的世界中,应用程序需要处理海量数据并提供快速响应。为了应对这一挑战,使用Redis作为缓存来减少对数据库的直接访问已经成为一种广泛采用的策略。这种方法不仅能够显著提升应用性能,还能有效降低数据库负载。然而,当我们将PostgreSQL作为主数据库,Redis作为缓存层时,一个关键问题随之而来:如何确保这两个系统之间的数据保持一致?
本文将深入探讨PostgreSQL和Redis之间的数据同步策略,旨在帮助开发者和架构师构建既高效又可靠的数据架构。本文将:
分析导致数据不一致的根本原因探讨各种同步策略的优缺点提供实际可行的解决方案 通过本文,读者将获得设计和实现健壮的数据同步机制所需的相关知识,从而在高并发环境中构建更可靠的应用系统。
2. 数据为什么会不一致？ 在现代高并发应用中，确保数据的一致性是一个复杂而关键的挑战。让我们深入探讨导致数据不一致的主要原因，以及为什么在PostgreSQL和Redis之间同步数据如此重要。
2.1 数据库：并发访问的瓶颈 在高并发的业务场景下，数据库往往成为系统中最薄弱的环节：
连接限制：数据库能够同时处理的连接数是有限的，高并发下很容易达到这个限制。锁竞争：并发写操作可能导致严重的锁竞争，大幅降低系统吞吐量。资源消耗：每个数据库操作都消耗CPU和I/O资源，并发请求增加会导致资源迅速耗尽。查询性能：复杂查询在高并发下可能导致数据库响应时间显著增加。 这些因素综合导致数据库在高并发场景下性能急剧下降，成为整个系统的瓶颈。
2.2 Redis：缓解数据库压力的关键 为了应对数据库的局限性，引入Redis作为缓存层成为一种普遍策略：
减轻数据库负载：将热点数据存储在Redis中，大幅减少对数据库的直接访问。提高响应速度：Redis的内存存储特性使得数据访问速度远快于传统数据库。支持高并发：Redis的单线程模型和非阻塞I/O使其能够高效处理大量并发请求。数据结构多样性：Redis提供了多种数据结构，适用于不同的缓存场景。 使用Redis作为缓冲层，让请求首先访问Redis而不是直接访问PostgreSQL等数据库，可以显著提升系统的整体性能和并发处理能力。
2.3 数据一致性挑战 虽然引入Redis缓存解决了许多性能问题，但也带来了新的挑战，特别是在数据更新方面：
读取操作：从Redis缓存读取数据通常不会引发严重的一致性问题，因为它只涉及单一数据源。写入操作：当需要更新数据时，问题变得复杂。我们需要同时更新数据库（PostgreSQL）和缓存（Redis），这个过程中很容易出现数据不一致： 更新时序：数据库和缓存的更新顺序会影响数据一致性。部分失败：如果更新过程中发生错误，可能导致数据库和缓存状态不一致。并发更新：多个客户端同时更新同一数据可能导致意外的结果。缓存失效：决定何时使缓存中的数据失效也是一个挑战，过早失效会降低缓存效果，过晚失效则可能导致数据不一致。 2.4 典型的数据读取流程 为了更好地理解这个问题，让我们看一下典型的数据读取流程：
应用程序接收到数据读取请求。首先检查Redis缓存中是否存在所需数据。如果Redis中存在数据（缓存命中），直接返回缓存数据。如果Redis中不存在数据（缓存未命中），则从PostgreSQL数据库读取数据。将从数据库读取的数据写入Redis缓存，以便后续访问。返回数据给应用程序。 这个流程在处理读取操作时通常运作良好，但一旦涉及数据更新，就需要额外的机制来确保PostgreSQL和Redis之间的数据一致性。
在接下来的章节中，我们将深入探讨各种同步策略，以及如何在保证数据一致性的同时，维持系统的高性能和可扩展性。
3. redis与Postgres数据同步策略介绍 3.1 先删除缓存后更新数据库 在这种策略中，系统首先删除Redis中的缓存，然后更新数据库。这种方法可能引起如下问题：
读取过程中的数据不一致：如果在缓存被删除后、数据库更新之前，另一个线程尝试读取数据，它会发现缓存为空。此时，它可能会从数据库中读取旧数据并将其写回缓存，导致所谓的脏缓存。数据更新后的不一致性：当数据库最终更新后，缓存中的数据已经是旧数据，从而导致缓存与数据库之间的不一致。 3.2 先更新数据库后删除缓存 这种策略先对数据库进行更新，然后再删除缓存。这样做的潜在问题包括：
事务失败导致的缓存未删除：如果在数据库更新后、删除缓存之前，执行更新的线程出现故障，这会导致缓存未被及时删除。并发导致的数据不一致：由于数据库的写入和缓存的删除是两个独立操作，无法保证它们之间的执行顺序，可能会导致读取操作在缓存删除前读到旧缓存，进而出现数据不一致。 3.3 延时双删策略 为了解决上述提到的同步问题，可以采用延时双删策略：
删除缓存：首先删除Redis中的相关数据缓存。更新数据库：然后更新数据库，确保数据的准确性。休眠延迟：执行短暂的延时（例如500毫秒），确保所有相关数据库操作都已完成。再次删除缓存：最后再次删除缓存，确保在数据更新期间任何新生成的缓存也会被清除。 伪代码如下：
function delayDoubleDelete(key, updateStatement) // 第一步：删除Redis中的缓存 Redis.delete(key) // 第二步：更新数据库 Database.execute(updateStatement) // 第三步：执行短暂的延时，例如500毫秒 sleep(500) // 第四步：再次删除Redis中的缓存 Redis.delete(key) end function 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfbbf9a668b5efd3bde0a7c1da88fb10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8a03b65ba3f3ea354d1991a3afcb94/" rel="bookmark">
			【Redis】Redis 持久化 AOF、RDB—（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、AOF 日志二、RDB 内存快照 Redis 一旦服务器宕机，内存中的数据将全部丢失，从后端数据库恢复这些数据，对数据库压力很大，且性能肯定比不上从 Redis 中读取，会拖慢应用程序。所以，对 Redis 来说，实现数据的 持久化 ，避免从后端数据库中进行恢复，是至关重要的。 一、AOF 日志 AOF 日志是先执行命令，把数据写入内存，然后才记录日志以文本形式保存，如下图：“*3” 表示命令有三个部分组成，每部分由"$+数字"开头，“$3 set"表示这部分有三个字节，指"set"命令，”$7 testkey"表示该部分有七个字节，即"testkey"命令，以此类推。
AOF 写后日志只有命令能执行成功，才会被记录到日志中，避免额外的检查开销，也避免了出现记录错误命令的情况，而且不会阻塞当前的写操作。说完 优点 说 风险 ，如果刚执行完命令还没有来得及记日志就宕机了，就有丢失的风险。其次，AOF 日志在主线程中执行，如果在把日志文件写入磁盘压力过大，可能会带来阻塞风险。
AOF 风险与写回磁盘有关，针对这个问题提供了三种 写回策略 ，即配置项 appendfsync 的三个可选值：
（1）Always 同步写回：每个写命令执行完，立马同步地将日志写回磁盘（2）Everysec 每秒写回：每个写命令执行完，先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘（3）No 操作系统控制的写回：每个写命令执行完，先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 三种策略各有优劣，汇总如下：
选定写回策略，并非万事大吉，随着接收的写命令越来越多，AOF 文件会越来越大，带来性能问题。主要是以下三个方面：
（1）文件系统本身对文件大小有限制，无法保存过大的文件 （2）如果文件太大，之后再往里面追加命令记录的话，效率也会变低
（3）如果发生宕机，AOF 中记录的命令要一个个被重新执行，文件太大导致整个恢复过程就会非常缓慢，影响 Redis 正常使用 日志文件太大了怎么办呢？这个时候，AOF 重写机制 就登场了。当一个键值对被多条写命令反复修改时，AOF 文件会记录相应的多条命令，而重写时，只会根据这个键值对当前的最新状态，为它生成对应的写入命令，这样一来，一个键值对在重写日志中只用一条命令就行了，并且在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。举个栗子：
AOF 重写并不会阻塞主线程，重写过程是由后台线程 bgrewriteaof 来完成的，通过内存拷贝和两处日志保证数据的完整性。
二、RDB 内存快照 内存快照 RDB 就是 Redis DataBase 的缩写，和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。但同时也面临两个问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c8a03b65ba3f3ea354d1991a3afcb94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca78a3c053831ec3c83c73367071f86/" rel="bookmark">
			Unity面试：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Unity 中，当物体发生碰撞时，整个过程可以划分为多个阶段，每个阶段都有相应的回调函数来处理。这些阶段及其对应的函数通常包括：
1. 接触检测阶段 OnCollisionEnter 描述：当两个碰撞体首次接触时调用。此函数在碰撞发生的瞬间被触发。函数示例： void OnCollisionEnter(Collision collision) { // 处理碰撞开始的逻辑，比如播放声音、产生效果等 Debug.Log("Collision started with " + collision.gameObject.name); } 2. 持续碰撞阶段 OnCollisionStay 描述：当两个碰撞体保持接触时，每帧都会调用此函数。适合处理连续碰撞逻辑。函数示例： void OnCollisionStay(Collision collision) { // 持续处理碰撞中的逻辑，比如状态更新、动力学处理等 Debug.Log("Colliding with " + collision.gameObject.name); } 3. 分离阶段 OnCollisionExit 描述：当两个碰撞体分离时调用。此函数在碰撞结束后被触发。函数示例： void OnCollisionExit(Collision collision) { // 处理碰撞结束的逻辑，比如恢复状态、停止声音等 Debug.Log("Collision ended with " + collision.gameObject.name); } 4. 触发检测阶段（可选） 如果使用的是触发器而不是碰撞体，那么会调用以下触发器相关的函数：
OnTriggerEnter 描述：当碰撞体首次进入触发区时调用。函数示例： void OnTriggerEnter(Collider other) { // 当其他物体进入触发区时的处理逻辑 Debug.Log("Triggered with " + other.gameObject.name); } OnTriggerStay 描述：当物体在触发区内时，每帧都会调用此函数。函数示例： void OnTriggerStay(Collider other) { // 持续处理触发区内的逻辑 Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bca78a3c053831ec3c83c73367071f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81bf91751728bc2e9f4ff6a652cf9f6/" rel="bookmark">
			Kafka Connect 常用转换器：深入实践与快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Kafka Connect 常用转换器：深入实践与快速入门 kafka-connect-transform-commonCommon Transforms for Kafka Connect.项目地址:https://gitcode.com/gh_mirrors/ka/kafka-connect-transform-common 项目介绍 kafka-connect-transform-common 是一个为日常使用场景设计的Kafka Connect转换器集合。它提供了一系列强大的转换功能，如调整精度和比例尺、字节转字符串、更改大小写、提取嵌套字段等。这些转换对于数据清洗、标准化和适应不同数据存储需求至关重要。项目遵循Apache-2.0许可协议，由Java编写的，并且欢迎社区贡献。
项目快速启动 要迅速集成这个项目到你的Kafka Connect环境，可以采用以下步骤：
使用Confluent Hub安装（推荐） 安装Confluent Hub客户端，如果尚未安装。运行命令来安装最新版本的转换插件： confluent-hub install jcustenborder/kafka-connect-transform-common:latest 手动安装 编译源码：在项目根目录下执行 mvn clean package。在Kafka Connect的插件路径下创建子目录 kafka-connect-transform-common 并将构建得到的jar文件复制进去。 配置Kafka Connect时，在其配置文件中添加对应的转换器配置以启用所需的转换逻辑。
应用案例和最佳实践 示例：自动添加主题名称作为消息字段 假设我们想要在每一条消息中插入发送它的Kafka主题名称作为一个字段。我们可以使用TopicNameToField转换器。
配置示例 { "transforms": "addTopicField", "transforms.addTopicField.type": "com.github.jcustenborder.kafka.connect.transform.common.TopicNameToField", "transforms.addTopicField.field": "sourceTopic" } 这将确保每个记录都获得一个新的字段sourceTopic，其中包含该记录原来所在的主题名。
最佳实践 测试转换：在部署前，通过单元测试或Kafka Connect的单个任务模式验证转换逻辑。性能考量：高吞吐量场景下，优化转换逻辑以避免成为系统瓶颈。安全性管理：若转换涉及敏感数据处理，应考虑安全措施，如利用Kafka Connect的秘钥管理支持。 典型生态项目结合 这个项目广泛适用于多种数据流处理场景，常与其他Kafka Connect相关的组件共同工作，例如：
与Confluent Platform集成：用于增强Confluent的连接器能力，如配合MySQL connector进行数据清洗。结合Apache Flink或Spark Streaming：在复杂数据管道中作为数据预处理环节。数据治理：在数据进入持久化存储（如HDFS、ELasticsearch）之前应用规范化规则。微服务架构中的消息中间件处理：为跨服务的数据交换添加元数据上下文。 通过上述整合，kafka-connect-transform-common不仅简化了数据流的预处理，也为实现更复杂的业务逻辑提供了基础工具集。
以上就是对kafka-connect-transform-common项目的一个简明概览及实践指南，希望对您的数据处理流程优化有所帮助。
kafka-connect-transform-commonCommon Transforms for Kafka Connect.项目地址:https://gitcode.com/gh_mirrors/ka/kafka-connect-transform-common 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9a8d6eebefb134fd5b3c14c00f229f0/" rel="bookmark">
			数据结构：树形结构（树、堆）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构：树形结构（树、堆）详解 一、树（一）树的性质（二）树的种类二叉树多叉树满N叉树完全N叉树 （三）二叉树的实现1、二叉树结构定义2、二叉树功能实现（1）前序、中序、后序、层序遍历（2）二叉树结点个数（3） ⼆叉树叶⼦结点个数（4） 二叉树第k层结点个数（5）二叉树的深度/高度（6）⼆叉树查找值为x的结点（7）二叉树销毁（8）判断二叉树是否为完全二叉树 二、堆（一）堆的实现1、堆的结构定义2、堆的初始化3、向上调整操作4、向下调整操作5、入堆操作6、堆的扩容7、出堆操作8、堆的销毁9、堆的判空、查看堆顶元素 （二）哈夫曼编码实现结束语 一、树 树的物理结构和逻辑结构上都是树形结构
（一）树的性质 • ⼦树是不相交的
• 除了根结点外，每个结点有且仅有⼀个⽗结点
• ⼀棵N个结点的树有N-1条边
（二）树的种类 树按照根节点的分支来分，可以分为二叉树和多叉树。
二叉树 二叉树（Binary Tree）
定义：每个节点最多有两个子节点的树结构。可以是空树，或者由一个根节点和左、右子树组成。
多叉树 多叉树（Multiway Tree）
定义：每个节点可以有多个子节点的树结构，节点子节点的数量没有限制。
树按照结点的特性来观察，又可以有满N叉树和完全N叉树
满N叉树 满N叉树是一种深度为K的二叉树，其中每一层的节点数都达到了该层能有的最大节点数。
完全N叉树 除了最后一层外，每一层都被完全填满，并且最后一层所有节点都尽量靠左排列。
（三）二叉树的实现 1、二叉树结构定义 用 typedef 可以使得后面的使用范围更广
typedef int BTDataType; typedef struct BinaryTreeNode { BTDataType data; struct BinaryTreeNode* left; struct BinaryTreeNode* right; }BTNode; 2、二叉树功能实现 （1）前序、中序、后序、层序遍历 下面的层序遍历方式采用的是一层一层的处理方式
void PreOrder(BTNode* root) { if (root == NULL) return; printf("%d ", root-&gt;data); PreOrder(root-&gt;left); PreOrder(root-&gt;right); return; } void InOrder(BTNode* root) { if (root == NULL) return; InOrder(root-&gt;left); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9a8d6eebefb134fd5b3c14c00f229f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ccde1fd5b9e75488c52dc6ea951aeb/" rel="bookmark">
			C&#43;&#43;基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​​ 🌟个人主页：落叶​​​​​​​
目录
C++的第⼀个程序
命名空间
namespace的价值
namespace的定义
命名空间的使用
using将命名空间中某个成员展开
C++输⼊&amp;输出
std::cout标准输出流
std::endl换行
std::cin的标准输⼊流
缺省参数
全缺省
半缺省
函数重载
参数类型不同
参数个数不同
参数的顺序不同
返回函数不同不是函数重载
引⽤
引⽤的概念和定义
引⽤的特性
引⽤的使⽤
const引⽤
指针和引⽤的关系
inline展开
nullptr
C++的第⼀个程序 C++兼容C语⾔绝⼤多数的语法，所以C语⾔实现的helloworld依旧可以运⾏，C++中需要把定义⽂件 代码后缀改为.cpp，vs编译器看到是.cpp就会调⽤C++编译器编译，linux下要⽤g++编译，不再是gcc
// test.cpp #include&lt;stdio.h&gt; int main() { printf("hello world\n"); return 0; } 当然C++有⼀套⾃⼰的输⼊输出，严格说C++版本的helloworld应该是这样写的。
// test.cpp // 这⾥的std cout等我们都看不懂，没关系，下⾯我们会依次讲解 #include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "hello world\n" &lt;&lt; endl; return 0; } 命名空间 namespace的价值 在C/C++中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全 局作⽤域中，可能会导致很多冲突。使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名 冲突或名字污染，namespace关键字的出现就是针对这种问题的。 c语⾔项⽬类似下⾯程序这样的命名冲突是普遍存在的问题，C++引⼊namespace就是为了更好的解决 这样的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ccde1fd5b9e75488c52dc6ea951aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f770195faac0de3ca88a9c6a554296/" rel="bookmark">
			单一职责原则介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.概念介绍 单一职责原则(Single Responsibility Principle, SRP)是面向对象设计中的五大基本原则之一,它是指一个类或者模块应该仅有一个引起它变化的原因。
具体来说,单一职责原则有以下几个特点:
职责集中:一个类或模块应该专注于完成一种特定的功能或职责,而不应该承担过多的职责。
职责分离:如果一个类或模块承担了多个职责,那么当其中一个职责发生变化时,就会影响到其他职责,导致代码难以维护。
可测试性:单一职责的类或模块更容易编写单元测试,因为它们的功能更加集中和明确。
可复用性:单一职责的类或模块更容易被其他代码复用,因为它们的功能更加独立和通用。
可读性:单一职责的类或模块更容易被开发人员理解和修改,因为它们的功能更加清晰和简单。
遵循单一职责原则的好处包括:
提高代码的可维护性:当一个类或模块只负责一个职责时,代码的结构更加清晰,修改时不会影响到其他无关的功能。
提高代码的可测试性:单一职责的类或模块更容易编写单元测试,因为它们的功能更加集中和明确。
提高代码的可复用性:单一职责的类或模块更容易被其他代码复用,因为它们的功能更加独立和通用。
提高代码的可读性:单一职责的类或模块更容易被开发人员理解和修改,因为它们的功能更加清晰和简单。
总之,单一职责原则是面向对象设计中非常重要的一个原则,它可以帮助我们编写出更加高质量、可维护和可扩展的代码。在实际开发中,我们应该努力遵循这一原则,尽量将类或模块的职责划分得更加清晰和集中。
二.具体例子 假设我们有一个 Employee 类,它负责管理员工的基本信息,如姓名、工号、部门等。
不遵循单一职责原则的例子:
class Employee { public: Employee(const std::string&amp; name, int id, const std::string&amp; department) : m_name(name), m_id(id), m_department(department) {} void setName(const std::string&amp; name) { m_name = name; } void setId(int id) { m_id = id; } void setDepartment(const std::string&amp; department) { m_department = department; } std::string getName() const { return m_name; } int getId() const { return m_id; } std::string getDepartment() const { return m_department; } void giveRaise(double percentage) { /* 计算并更新工资 */ } void fireEmployee() { /* 执行解雇流程 */ } void printEmployeeInfo() { /* 打印员工信息 */ } private: std::string m_name; int m_id; std::string m_department; }; 在这个例子中,Employee 类承担了太多的职责,包括管理员工基本信息、计算工资、执行解雇流程、打印员工信息等。这违反了单一职责原则,因为当其中一个职责发生变化时,就会影响到其他职责,导致代码难以维护。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f770195faac0de3ca88a9c6a554296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f358d70ecd199022415747a347f8564/" rel="bookmark">
			数据仓库系列17：元数据管理在数据仓库中的作用是什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想象一下,你正在管理一个巨大的图书馆,里面存放着数以万计的书籍。但是,这个图书馆没有任何目录、索引或分类系统。你能想象找到特定的一本书会有多困难吗?这就是没有元数据管理的数据仓库的真实写照。
目录 什么是元数据?元数据管理的重要性元数据在数据仓库中的类型1. 技术元数据2. 业务元数据3. 操作元数据 元数据管理的核心功能1. 数据目录2. 数据血缘分析3. 数据质量管理4. 数据版本控制5. 数据访问控制 元数据管理的实践案例元数据管理工具介绍元数据管理的挑战与最佳实践结论 在这篇文章中,我们将深入探讨元数据管理在数据仓库中的关键作用,以及它如何成为现代大数据开发中不可或缺的一部分。
什么是元数据? 元数据,顾名思义,就是"关于数据的数据"。它是描述、解释和定位数据的结构化信息。在数据仓库环境中,元数据扮演着至关重要的角色,它就像是数据的"身份证",记录了数据的来源、格式、含义、关系和使用方法等信息。
让我们通过一个简单的例子来理解元数据:
假设我们有一个名为"sales_data"的数据表,其中包含以下列:
CREATE TABLE sales_data ( transaction_id INT, date DATE, product_id VARCHAR(10), quantity INT, price DECIMAL(10,2), customer_id INT ); 这个表的元数据可能包括:
表名: sales_data列名及其数据类型: transaction_id (INT)date (DATE)product_id (VARCHAR)quantity (INT)price (DECIMAL)customer_id (INT) 创建日期: 2024-03-15最后更新日期: 2024-08-31数据来源: POS系统更新频率: 每日负责人: John Doe描述: 该表存储了所有销售交易的详细信息 这些信息就构成了"sales_data"表的元数据,它们描述了这个数据集的结构、内容和上下文。
元数据管理的重要性 在数据仓库中,元数据管理的重要性怎么强调都不为过。它就像是数据仓库的"导航系统",没有它,我们就会在海量数据中迷失方向。以下是元数据管理的几个关键作用:
数据治理: 元数据是实现有效数据治理的基础。它helps确保数据的一致性、准确性和可靠性。
数据血缘追踪: 元数据可以帮助我们追踪数据的来源和流动路径,这对于理解数据的生命周期和影响分析至关重要。
提高效率: 通过元数据,数据工程师和分析师可以快速找到并理解他们需要的数据,大大提高工作效率。
促进协作: 元数据提供了一个共同的语言和参考点,有助于不同团队之间的沟通和协作。
支持自助服务: 良好的元数据管理可以支持自助式的数据发现和分析,让业务用户能够更自主地使用数据。
确保合规性: 元数据管理helps确保数据使用符合各种法规和公司政策。
优化性能: 通过元数据,我们可以识别数据访问模式,从而优化查询性能和存储策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f358d70ecd199022415747a347f8564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a94a5ad3c494923c360c64c32e0335d0/" rel="bookmark">
			沉浸式体验Stability AI文生图、图生图、图片PS功能（中篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天小李哥就来介绍亚马逊云科技推出的国际前沿人工智能模型平台Amazon Bedrock上的Stability Diffusion模型开发生成式AI图像生成应用！本系列共有3篇，在上篇中我们学习了如何在亚马逊云科技控制台上体验该模型的每个特色功能，如文生图、图生图、图像修复等。
接下来在中篇中我将带大家沉浸式实操通过API调用的方式访问Stability Difussion模型，体验该模型的特色功能。大家可以通过本博客中的实操项目自己学习AI技能，并应用到日常工作中。也欢迎大家继续关注本系列第三篇，通过Stability Difussion模型API调用的方式，开发一个属于自己的图片生成网页应用。
方案所需基础知识 什么是Amazon Bedrock Amazon Bedrock 是一项完全托管的服务，通过统一的 API 提供来自 AI21 Labs、Anthropic、Cohere、Meta、Mistral AI、Stability AI 和 Amazon 等领先 AI 公司的高性能基础模型（FMs），同时提供广泛的功能，让开发者能够在确保安全、隐私和负责任 AI 的前提下构建生成式 AI 应用。使用 Amazon Bedrock，开发者们可以：
轻松地测试、评估开发者的用例在不同基础模型下的表现；
使用微调和检索增强生成（RAG）等技术定制化开发应用程序；构建可以使用开发者的企业系统和数据源自动执行任务的智能 Agents。由于 Amazon Bedrock 是 Serverless 的服务，开发者无需管理任何基础设施，并且可以使用开发者已经熟悉其它的亚马逊云科技服务安全地集成和部署生成式 AI 功能到开发者的应用中。 什么是 Stability AI 模型？ Stability AI 是一家致力于开发和提供生成式人工智能模型的公司，其模型被广泛应用于图像生成领域。Stability AI 的模型中最著名的莫非是 Stable Diffusion 生成模型，能够根据用户输入的描述，自动生成高度逼真的图像和文本。这些模型以其卓越的生成能力和灵活性，在应用开发中管饭应用和认可。
Stability AI 模型的应用场景
创意设计： Stability AI 的生成模型广泛应用于创意设计领域，帮助设计师和美工快速生成高质量的图像、插画和视觉内容，可以用于产品展示、品牌推广，社交媒体内容创作。通过简单的文本描述，就可以快速生成符合特定主题或风格的视觉素材，大大提升了设计效率和创意表现力。
游戏开发： Stability AI 的图像生成技术也被广泛应用于游戏开发中。开发者可以利用这些模型快速生成游戏场景、角色设计和道具，节省大量的美术资源，并加速游戏开发。利用AI的图像生成能力，使得小型开发团队也能够制作出富有视觉冲击力的游戏内容。
教育和培训： 在教育和培训领域，Stability AI 模型能够根据教学需求生成个性化的学习材料和培训教案，帮助教师和培训师提高教学效果，特别是生成式AI相关的主题培训，提升学习者的参与度和学习体验。
本实践包括的内容 1. 通过Amazon Bedrock API调用的方式体验文生图功能 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a94a5ad3c494923c360c64c32e0335d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0090a66ada6f6a8e2936055540b879e5/" rel="bookmark">
			Nginx: 使用KeepAlived配置实现虚IP在多服务器节点漂移及Nginx高可用原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用KeepAlived配置实现虚IP在多服务器节点漂移 1 ）环境准备
2台 linux , 一主一备 节点1：192.168.184.30 CentOS 7 Master节点2：192.168.184.40 CentOS 7 BackupVIP 192.168.184.50 安装 KeepAlived, $ yum install keepalived 注意，安装好yum源，base 源就有这个软件两台都执行安装 关闭selinux 和 防火墙 $ setenforce 0 临时关闭 或 vim /etc/sysconfig/selinux 编辑 SELINUX=disabled 永久关闭 $ systemctl stop firewalld 关闭 systemctl disable firewalld 关闭自启动 这里非常重要，否则可能两台机器无法通信 2 ) 相关配置说明
查看软件生成了哪些文件, $ rpm -ql keepalived 可以选择其中一台去执行输出有一些比较重要的文件和目录，可以去看看，这里着重说明/etc/keepalived/keepalived.conf 主配置文件/etc/sysconfig/keepalived 更改默认属性配置文件/usr/bin/genhash 二进制程序/usr/lib/systemd/system/keepalived.service 使用systemctl 启动停止查看/usr/libexec/keepalived 这是lib包/usr/sbin/keepalived 这是主程序文件 查看相关配置文件 $ vim /etc/keepalived/keepalived.conf 可以先在一台上操作，比如 184.30 这台机器! Configuration File for keepalived 这一段是注释global_defs 块中，决定了全局属性，全局配置, 对整个 keepalived 生效global_defs { notification_email { # 这里可以写多个邮箱, 确保服务器在内网并且邮箱可收到当前服务器发送的邮件 admin@baidu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0090a66ada6f6a8e2936055540b879e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53adfb1d0df00f12e2f0f2c153d6cf4e/" rel="bookmark">
			反向迭代器：reverse_iterator的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
特点
注意事项
实现
构造函数
功能函数
在list与vector中的使用
vector
list
前言 反向迭代器是一种在序列容器的末尾开始，并向前移动至序列开始处的迭代器。在C++中，反向迭代器由标准库中的容器类提供，比如vector、list、deque等。它们允许程序员以逆序遍历容器中的元素。
以下是反向迭代器的一些特点：
特点 反向遍历：反向迭代器从序列的最后一个元素开始，逐步移动到第一个元素。操作符重载：C++中的反向迭代器重载了递增（++）和递减（--）操作符。递增操作使迭代器向序列的开始方向移动，而递减操作使其向序列的结束方向移动。类型：反向迭代器的类型通常由容器类型加上reverse_iterator后缀表示，例如vector&lt;int&gt;::reverse_iterator。 注意事项 反向迭代器不支持所有的普通迭代器的操作，例如算术操作（加、减）。使用反向迭代器时，递增操作实际上是向序列的开始方向移动。在C++标准库中，并不是所有容器都支持反向迭代器。只有那些支持双向迭代器（BidirectionalIterator）或随机访问迭代器（RandomAccessIterator）的容器才提供反向迭代器。这是因为反向迭代器需要能够向前和向后遍历容器，而这两种迭代器都支持这些操作。 需要逆序访问容器元素时，它们可以简化代码并提高效率
反向迭代器有const版本和非const版本，所以我们需要实现两个版本。
实现 反向迭代器由于与正向迭代器的行为相似，因此借鉴适配器的思想，用正向迭代器实现反向迭代器
同时我们增加两个模板参数Ref Ptr，作为const T&amp;和Const T*的区分
template&lt;class Iterator, class Ref, class Ptr&gt; class ReverseIterator 成员变量就是一个被适配的正向迭代器
private:
Iterator _it;
构造函数 ReverseIterator(Iterator it) :_it(it) {} 用传入的模板迭代器去初始化成员
功能函数 ++ --
Self&amp; operator++() { --_it; return *this; } Self&amp; operator--() { ++_it; return *this; } * -&gt;两种解引用
为了实现对称，解引用时，解引用的是当前位置的下一个数据
Ref operator*()	//内部去调用普通迭代器的解引用 { Iterator cur = _it; return *(--cur);	//返回数据的引用，不能--_it，防止迭代器错位 } //-&gt;也是一种解引用 Ptr operator-&gt;()	//返回的其实是一个指针 { return &amp;(operator*()); } == ！=
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53adfb1d0df00f12e2f0f2c153d6cf4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1cdcc1ecb61ee38d71336a995887c3/" rel="bookmark">
			力扣SQL仅数据库(196~569)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		196. 删除重复的电子邮箱 题目：编写解决方案 删除 所有重复的电子邮件，只保留一个具有最小 id 的唯一电子邮件。
（对于 SQL 用户，请注意你应该编写一个 DELETE 语句而不是 SELECT 语句。）
（对于 Pandas 用户，请注意你应该直接修改 Person 表。）
数据准备：
Create table If Not Exists Person (Id int, Email varchar(255)) Truncate table Person insert into Person (id, email) values ('1', 'john@example.com') insert into Person (id, email) values ('2', 'bob@example.com') insert into Person (id, email) values ('3', 'john@example.com') 代码实现：
delete from Person where id not in ( select a.id from (select min(id) id from Person group by email)a); 197.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1cdcc1ecb61ee38d71336a995887c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f823b8febb3e803495241404219bea/" rel="bookmark">
			基于FPGA的lz4解压缩仿真调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介
对于任意长度顺序呈现的输入数据流，通过对冗余byte的数据编码，完成数据压缩的问题。数据包格式
从数据包长度可知，最少需要5个字节才能压缩，否则压缩无意义，对于lz其他的介绍可以百度，本文只介绍实现。
通常我们使用fpga解压缩来解决数据过大无法存储，或者加载时间过长的问题，下面开始介绍实现过程
2 使用python处理
文本数据来生成二进制文件，这个数据要对fpga仿真输入源，不是普通的文本数据，否则要转化成asic码。
a.txt
00000000 00001234 00000000 00005678 00000000 0000abcd 00000000 00002345 文本转化成二进制文件b.bin
压缩后的文件c.bin
解压后的文件d.bin
python脚本
import lz4.frame file_a = "a.txt" file_b = "b.bin" file_c = "c.bin" file_d = "d.bin" with open(file_a, 'r') as hex_file: with open(file_b, 'wb') as bin_file: for line in hex_file: byte_data = bytes.fromhex(line.strip()) bin_file.write(byte_data) with open(file_b, 'rb') as file: binary_data = file.read() compressed = lz4.frame.compress(binary_data) with open(file_c, 'wb') as file: file.write(compressed) decompressed = lz4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f823b8febb3e803495241404219bea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2bb7dec66eb381ac677469056dcfd43/" rel="bookmark">
			Unity本地化id查找器，luaparser函数参数查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
适用范围：Unity 中需要查找所有预制体里面的某一个脚本的属性值，或者Lua脚本里面的某一个属性值
本文介绍如何查找预制体和Lua脚本里面调用的本地化id
下面首先介绍改插件的功能以及使用方法，然后对该插件的原理进行说明
使用说明 本插件能够查找到预制体和lua脚本里面那些地方调用了指定的本地化id。操作步骤：首先在LangID输入框中输入要查找的id（使用分号间隔），也可以直接从csv文件导入id。点击【查找】按钮，就可以找到对应的id被哪些预制体和lua代码调用了。
【打开】按钮会调用默认编辑器打开对应的文件
【更新Lua代码索引】按钮会运行python程序生成lua代码的索引文件
【设置】按钮用于设置本地化函数名
插件原理说明 首先需要确保工程已经安装了Odin Inspector插件，否则无法运行本插件。
因为是要查找指定的本地化id，那么可以按照功能模块将代码分为两部分——查找预制体和查找Lua代码。
查找Lua代码中的本地化id 假设获取本地化id的函数名为lang.Get。
那么，是不是使用正则匹配lang.Get这个字符串，然后就可以获取调用的id了呢？实际项目中情况可能更复杂。
通过总结实际项目中代码的编写格式，可以将函数调用分为一下几种情况
function test() print("function test") --参数为常量 lang.Get(10000) lang.Get(10000 + 10) --参数包含变量的情况 local id = 20 lang.Get(id) lang.Get(10000 + id) lang.Get(id + 10000) --参数包含table的情况 local LANG_ENUM = { id1 = 10000, id2 = 10001, id3 = 10002, } lang.Get(LANG_ENUM.id1) lang.Get(LANG_ENUM.id2) lang.Get(LANG_ENUM.id3) local LANG_ARRAY = {20000, 20001, 20002} lang.Get(LANG_ARRAY[1]) lang.Get(LANG_ARRAY[2]) end 面对这些情况，正则就不够用了。为了实现对以上情况的查找，所以lua代码部分的查找工作使用语法树来完成，这里使用基于python的luaparser（也有基于JS的）。luaparser的官方文档：https://pypi.org/project/luaparser/
这里使用python是为了方便将python程序打包，因为大部分人的电脑中没有python环境，而且我们不可能在插件中内嵌一个python环境，所有最后需要将python代码打包成exe程序。
上面是整套python代码的执行流程，简单来说就是首先找出差异文件，然后生成lua代码的语法树，然后找到所有的本地化id，最后将查找的结果进行序列化并以JSON格式保存在本地。C#层会读取该JSON文件，从而查找对应id。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2bb7dec66eb381ac677469056dcfd43/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/11/">«</a>
	<span class="pagination__item pagination__item--current">12/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/13/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>