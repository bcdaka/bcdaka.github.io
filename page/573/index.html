<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e73a44bda5e5c19366fba6a56052492/" rel="bookmark">
			【架构师】AI时代架构师必备技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉博__主👈：米码收割机
👉技__能👈：C++/Python语言
👉公众号👈：测试开发自动化【获取源码+商业合作】
👉荣__誉👈：阿里云博客专家博主、51CTO技术博主
👉专__注👈：专注主流机器人、人工智能等相关领域的开发、测试技术。
AI时代架构师必备技能 目录 AI时代架构师必备技能&lt;center&gt;本期好书推荐《AI时代架构师修炼之道：ChatGPT让架构师插上翅膀》关键点内容简介作者简介购买链接 技术深度：
学习各种AI框架，如TensorFlow, PyTorch, Keras等。了解常见的机器学习算法，如决策树、SVM、神经网络、深度学习结构等。对分布式计算、高性能计算有深入的了解。 持续学习：
定期参加研讨会、工作坊和培训课程。订阅AI和机器学习的相关期刊和博客。与行业专家进行交流和合作。 数据敏感性：
理解数据的价值并知道如何从原始数据中提取有价值的信息。了解数据处理、清洗、转换的最佳实践。能够为大数据设计和优化数据库架构。 计算资源管理：
了解不同的计算资源，如CPU、GPU、TPU的优势和局限性。设计系统时能有效地分配和管理这些资源。对容器技术如Docker和Kubernetes有深入了解。 系统整合能力：
能将AI模型和解决方案与企业的ERP、CRM等系统整合。了解API设计、微服务架构和其他系统整合技术。 伦理与责任：
理解AI偏见、决策透明性和隐私问题。在设计和实施AI解决方案时考虑伦理和法规。 业务敏锐度：
深入了解所在行业的业务流程和挑战。能从业务的角度评估AI解决方案的价值。 跨领域交流：
能够将复杂的技术问题解释给非技术人员听。与团队中的其他成员，如数据科学家、开发者、业务分析师等建立有效的沟通。 安全意识：
了解AI和机器学习的安全风险。实施安全最佳实践，如数据加密、模型保护等。 灵活性与适应性：
在不断变化的技术环境中快速学习新技术。对变化和不确定性保持开放的态度。 创新思维： 鼓励和支持团队的创新想法。持续寻找新的技术和方法来提高效率和效果。 团队合作： 建立团队的信任和尊重。能有效地管理和指导团队，确保目标的实现。 这些技能和特质不仅会帮助架构师在AI时代中取得成功，还能确保他们能为企业创造真正的价值。
本期好书推荐《AI时代架构师修炼之道：ChatGPT让架构师插上翅膀》 架构设计新模式 一本专注于帮助架构师在AI时代 实现晋级、提高效率的图书 书中介绍了如何使用 ChatGPT 来完成架构设计的各个环节 并通过实战案例展示了ChatGPT在实际架构设计中的应用方法 关键点 1.架构设计新模式：让架构设计更高效、更快捷、更完美。
2.全流程解析：涵盖架构设计的不同应用场景，介绍从编写各种文档，到应用图形图表与UML建模、设计模式、数据库设计，再到编写代码、开发软件架构等关键环节。
3.实战检验：ChatGPT结合多种架构设计工具及案例实操讲解，理解更加透彻。
4.100%提高架构设计效率：揭秘ChatGPT与架构设计高效融合的核心方法论和实践经验。
5.超值资源：赠送教学视频及配套工具，供读者下载学习。
内容简介 本书是一本旨在帮助架构师在人工智能时代展翅高飞的实用指南。全书以ChatGPT为核心工具，揭示了人工智能技术对架构师的角色和职责进行颠覆和重塑的关键点。本书通过共计 13 章的系统内容，深入探讨AI技术在架构
设计中的应用，以及AI对传统架构师工作方式的影响。通过学习，读者将了解如何利用ChatGPT这一强大的智能辅助工具，提升架构师的工作效率和创造力。
本书的读者主要是架构师及相关从业人员。无论你是初入职场的新手架构师还是经验丰富的专业人士，本书都将成为你的指南，帮助你在人工智能时代展现卓越的架构设计能力。通过本书的指导，你将学习如何运用ChatGPT等工具和技术，以创新的方式构建高效、可靠、可扩展的软件架构。
同时，本书也适用于对架构设计感兴趣的其他技术类从业人员，如软件工程师、系统分析师、技术顾问等。通过学习本书的内容，你可以深入了解人工智能对架构设计的影响和带来的挑战，拓展自己的技术视野，提升对软件系统整体架构的理解和把握能力。
作者简介 关东升，一个在IT领域摸爬滚打20多年的老程序员、知名培训专家、畅销书作家，精通多种信息技术。曾参与设计和开发北京市公交一卡通系统、国家农产品追溯系统、金融系统微博等移动客户端项目，并在App Store发布多款游戏和应用软件。长期为中国移动、中国联通、中国南方航空、中国工商银行和天津港务局等企事业单位提供培训服务。先后出版了50多部IT图书，广受读者欢迎。
购买链接 当当网链接：http://product.dangdang.com/29640582.html
京东的链接：https://item.jd.com/13897131.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070b94a440bdb5642b4c069075798445/" rel="bookmark">
			【AI绘画-stableDiffusion】图片放大；高清修复；重绘幅度调参讲解；SD upscale 放大脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总览 文章参考：https://www.bilibili.com/video/BV11m4y12727/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=38d6ea3466db371e6c07c24eed03219b
一、图生图（基于已有图片的高清修复） 1.提升整图分辨率（优点：对原图影响较小；缺点：显存占用较大）
· 1.1 使用自己生成出来的图片
· 1.2 使用别人的图片
2.SD upscale（SD放大）
· 区块重绘，再拼接（优点：效果更好。且占用显存小，但操作复杂。用于想对图片做点儿小改动或微小画风切换的时候）
二、文生图（用于提示词生成高清图片） 实际上是 文 -&gt; 生低分辨率图 -&gt; 生高清图
用于没有现有图片的时候，我们想要直接生成高分辨率版本的时候
一、图生图（基于已有图片的高清修复） 方法1：整图 1.1 使用自己的图片 1.可以在 图库浏览器 中打开我们生成过的图片（也可以直接图生图，但那就会丢失关键词了）
2.按比例调整 宽度、高度
3.重绘幅度 调参
重绘幅度调参说明：
重绘幅度的推荐区间为 0.25~0.7
· 重绘幅度越小，保留原本图像的细节就会越多
· 看起来这是好事，但若 &lt; 0.25，则可能发生图片边缘模糊的问题
· 生成和原本差不多的图片推荐值：0.3~0.45
· 生成更精密的图片，不保留原图过多的细节的推荐值：0.45~0.7
4.设置图生图使用的默认算法（如果以前设置过也可以不设置）
设置 -&gt; 放大 -&gt; 图生图的放大算法（推荐：R-ESRGAN 4X+ Anime、BSRGAN）
保存！
1.2 使用别人的图片 1.更多
2.放入想要放大的图片
3.等比缩放比例调节为 2~3 之间（或其他，自行尝试，这只是一个推荐值）
4.选择神经网络，推荐使用 BSRGAN，或者 SwinIR_4x。
我还是首推 BSRGAN，但如果你需要让画面更明亮一些，而非真实一些，那就使用后者。
下面是不同神经网络的放大效果：
方法2：SD upscale（SD 放大），分区块重绘 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/070b94a440bdb5642b4c069075798445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bb91c4094a41b9c315bbbda387efd0/" rel="bookmark">
			矩阵乘法可交换与可同时对角化的关系 —— Umeyama 算法推导的数学准备 (I)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Title: 矩阵乘法可交换与可同时对角化的关系 —— Umeyama 算法推导的数学准备 (I)
文章目录 引言定理证明1. 充分性情况一: 如果两个矩阵中有任一矩阵只具有单特征值情况二: 如果两个矩阵都有多重特征值A. 第一个矩阵的特征向量B. 第二个矩阵的特征向量C. 两个矩阵共同特征向量的性质 2. 必要性 参考文献 引言 之所以把这个矩阵乘法可交换充分必要条件的定理[1]的证明自己消化一下, 是因为在点云配准的奇异值算法 (Umeyama 算法) 中用到了. 我们先把一些数学基础准备好, 最后推导 Umeyama 算法. 本博客文章就是其中的一个数学准备.
当然这些数学定理在教科书中都能找到, 我只是学着用自己的语言很啰嗦地再推一遍, 减少了一点理解难度, 也为了自己后面查阅.
定理 定理[1]
A necessary and sufficient condition that there exist an orthogonal matrix T \mathbf{T} T with the property that
T ′ A T = [ λ 1 λ 2 0 0 ⋱ λ n ] T ′ B T = [ μ 1 μ 2 0 0 ⋱ μ n ] \mathbf{T}' \mathbf{A} \mathbf{T}=\begin{bmatrix} \begin{matrix}\lambda_1 &amp; \\ &amp;\lambda_2 \end{matrix} &amp; 0\\ 0 &amp;\begin{matrix}\ddots &amp; \\ &amp;\lambda_n \end{matrix} \end{bmatrix}\\ \mathbf{T}' \mathbf{B} \mathbf{T}=\begin{bmatrix} \begin{matrix}\mu_1 &amp; \\ &amp;\mu_2 \end{matrix} &amp; 0\\ 0 &amp;\begin{matrix}\ddots &amp; \\ &amp;\mu_n \end{matrix} \end{bmatrix} T′AT= ​λ1​​λ2​​0​0⋱​λn​​​ ​T′BT= ​μ1​​μ2​​0​0⋱​μn​​​ ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21bb91c4094a41b9c315bbbda387efd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ea53eb1e39e60c6ab318ab8c7ce5da/" rel="bookmark">
			Python 使用 pip 安装 matplotlib 模块（精华版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip 安装 matplotlib 模块 1.使用pip安装matplotlib(五步实现):2.使用下载的matplotlib画图: 1.使用pip安装matplotlib(五步实现): 长话短说：本人下载 matplotlib 花了大概三个半小时屡屡碰壁，险些暴走。为了不让新来的小伙伴走我的弯路，特意创作本片文章指明方向。
1.首先需要下载 python
我直接是在电脑自带的软件商店里下载的，图方便，当然在官网下完全没问题。
需要明白python 自带有 pip
2. win + R 输入cmd进入控制台，输入命令：pip --version 查看是否有pip，以下是有pip的情况:
不是这样就输入命令：python -m ensurepip --default-pip 下载一个，下载完后也可能要更新）
3. 更新一下 pip（我这个是最新版本）在cmd中输入命令：python.exe -m pip install --upgrade pip
(更新完后可以在cmd输入命令：pip --version 查查版本)
4.将 pip 从国外源改成国内源 （不改变的话下载 matplotlib 速度很慢，而且会断开连接，所以一直报错，这是重点!） (我就败在这里!)😭
第一种方法：在pycharm终端输入：
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ pip config set global.install.trusted-host mirrors.aliyun.com 再不行就(法2）：
跟着这个大哥改吧，真只需要两三分钟，亲测有效，救我于水生火热之中：1 分钟设置 pip 镜像源
5.在 cmd 中输入命令：python -m pip install matplotlib 下载matplotlib库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73ea53eb1e39e60c6ab318ab8c7ce5da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b39cde36d601a7b0987d72da1e4d975/" rel="bookmark">
			Elasticsearch7.x——spring-boot-starter-data-elasticsearch详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 spring-boot-starter-data-elasticsearch1、概述2、配置2.1、有密码2.1、无密码 3、实体4、Respository4.1、接口层次关系4.2、增删改查4.2.1、新增4.2.2、修改4.2.3、批量新增4.2.4、删除4.2.5、根据ID查询4.2.6、查询所有 4.3、自定义方法4.3.1、约定规则4.3.2、示例 4.4、QueryBuilder查询(4.0后废弃)4.4.1、分页查询4.4.2、排序查询4.4.3、桶聚合4.4.4、嵌套聚合4.4.5、其他查询 4.5、注解查询4.5.1、@Query4.5.2、@Highlight 5、ElasticsearchOperations接口5.1、ElasticsearchTemplate5.2、ElasticsearchRestTemplate5.3、返回值类型5.4、IndexOperations(索引操作)5.4.1、初始化索引5.4.2、删除索引5.4.3、获取索引信息5.4.4、别名操作5.4.5、索引模板操作 5.5、增删改查5.5.1、新增单个文档5.5.2、批量新增文档5.5.3、修改(全量替换)5.5.4、修改(部分修改)5.5.5、根据主键查询5.5.6、根据主键删除 6、Query接口6.1、CriteriaQuery6.1.1、简单查询6.1.2、组合查询6.1.3、嵌套查询6.1.4、GEO查询 6.2、StringQuery6.2.1、简单查询6.2.2、复杂查询6.2.3、分页查询6.2.4、排序查询6.2.5、高亮查询 6.3、NativeSearchQuery6.3.1、简单查询6.3.2、复杂查询6.3.3、分页查询6.3.4、排序查询6.3.5、高亮查询6.3.5、聚合查询 spring-boot-starter-data-elasticsearch 1、概述 Spring Data Elasticsearch是Spring Data项目下的一个子模块。
查看 Spring Data的官网：http://projects.spring.io/spring-data/
Spring Data 的使命是给各种数据访问提供统一的编程接口，不管是关系型数据库（如MySQL），还是非关系数据库（如Redis），或者类似Elasticsearch这样的索引数据库。从而简化开发人员的代码，提高开发效率。
Spring Boot与Elasticsearch的对应版本：
引入依赖：
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Elasticsearch的版本为7.16，所以选择2.4以上版本的SpringBoot。
2、配置 2.1、有密码 application.yml
es: address: 127.0.0.1 port: 9200 scheme: http username: elastic password: 123456 @Configuration public class ElasticSearchConfig extends AbstractElasticsearchConfiguration { @Value("${es.address}") String address; @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b39cde36d601a7b0987d72da1e4d975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ac45e7f6e833878e69a6321863fcd5/" rel="bookmark">
			hive插入动态分区数据时，return code 2报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、完整报错
二、原因
2.1、动态分区问题
2.2、语句占用内存问题
三、其他
一、完整报错 Error while processing statement: FAILED: Execution Error, return code 2 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask
二、原因 2.1、动态分区问题 大概率是因为没有开启或允许动态分区或单次动态分区个数太小了。
-- 动态分区前先运行如下语句 set hive.exec.dynamic.partition = true; set hive.exec.dynamic.partition.mode = nonstrict; set hive.exec.max.dynamic.partitions = 1000; set hive.exec.max.dynamic.partitions.pernode = 1000; 2.2、语句占用内存问题 还有可能就是你的sql语句执行时需要很大的内存，而配置文件要求单条内存不超过xxx内存时报错。设置下内存大小就可以了。
-- 1024的倍数 set mapreduce.map.memory.mb=5120; 三、其他 如果上面语句没有解决，可以看下yarn配置，或查看日志或后台配置等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146506e1ab5130ea93c47bcb36c19d12/" rel="bookmark">
			vue前端页面弹出红色报错遮罩层 Uncaught runtime errors:at handleError (webpack-internal:///./node_modules/webpack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息：
Uncaught runtime errors: × ERROR Unknown promise rejection reason at handleError (webpack-internal:///./node_modules/webpack-dev-server/client/overlay.js:296:58) at eval (webpack-internal:///./node_modules/webpack-dev-server/client/overlay.js:319:7) 原因：
当出现编译错误或警告时，在浏览器中显示全屏覆盖。
解决方法：
在vue.config.js中添加如下配置，重启项目即可
module.exports = defineConfig({ devServer: { client: { overlay: false, }, } }) https://webpack.docschina.org/configuration/dev-server/#overlay
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252f76bd70a14be339a144b4d72a9d19/" rel="bookmark">
			【MySQL】 复合查询 | 内外连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 复合查询多表笛卡尔积自连接在where子句使用子查询单行子查询多行子查询in关键字all关键字any关键字 多列子查询 在from子句中使用子查询合并查询unionunion all 2. 内连接3. 外连接左外连接右外连接 1. 复合查询 多表笛卡尔积 显示雇员名、雇员工资以及所在部门的名字
由于员工 信息属于 emp表 而所在部门名字属于 dept表
数据来自不同的表，所以需要进行多表查询
表示从 emp (员工表) 和dept (部门表) 中获取信息
分别用emp员工的信息 与 dept 部门表的信息 做 穷举 组合
就称 两张表 进行笛卡尔积
就把两张表 变成了 一张表 ，就可以进行单表查询
如 smith 本来是20号部门的，把10号部门的信息传过来 是没有意义的
输入 select * from emp,dept where emp.deptno =dept.deptno;
把对应的部门号 与部门信息 匹配上
输入 select ename ,sal,dname from emp,dept where emp.deptno =dept.deptno;
就可以显示雇员名、雇员工资以及所在部门的名字
自连接 自连接 指的是在同一张表连接查询
将同一张表单纯的写两次，是不可以一起查询的
可以把同一张表的表名通过重命名的方式 分别 进行不同命名 即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/252f76bd70a14be339a144b4d72a9d19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd1281192286c5dd3fb56b8357734c4/" rel="bookmark">
			【NLP】什么是语义搜索以及如何实现 [Python、BERT、Elasticsearch]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义搜索是一种先进的信息检索技术，旨在通过理解搜索查询和搜索内容的上下文和含义来提高搜索结果的准确性和相关性。与依赖于匹配特定单词或短语的传统基于关键字的搜索不同，语义搜索会考虑查询的意图、上下文和语义。
语义搜索在搜索结果的精度和相关性至关重要的应用中非常宝贵，例如从大型数据库中检索信息、电子商务产品搜索、企业搜索以及改善搜索引擎和虚拟助手中的用户体验。
传统的基于关键字的搜索依赖于匹配特定的单词或短语，而语义搜索则考虑查询的意图、上下文和语义。
NLP 中的语义搜索如何工作？ 自然语言处理（NLP）上下文中的语义搜索是指应用NLP技术通过理解搜索查询和正在搜索的内容的含义和上下文来增强搜索结果的准确性和相关性。以下是语义搜索与 NLP 的关系：
自然语言理解： NLP 分析和理解搜索查询中使用的自然语言以及搜索数据库中的内容。NLP 技术，例如词性标注、命名实体识别和句法分析，有助于从文本中提取含义。查询扩展： NLP 中的语义搜索通常涉及查询扩展，系统识别同义词、相关概念和上下文相关术语，以扩大搜索查询的范围。这确保了搜索结果不限于精确的关键字匹配，而是包括概念上相关的内容。实体识别：基于 NLP 的语义搜索系统可以识别文本中的实体（例如人、地点、组织），并使用此信息来提高搜索准确性。例如，认识到“苹果”指的是科技公司，而不是水果。概念匹配： NLP 支持的语义搜索超越了精确的关键字匹配，还考虑了单词和短语之间的基本概念和关系。它可以识别概念上与查询相关的内容，即使术语不存在。情感分析：在某些情况下，使用 NLP 技术的情感分析可以合并到语义搜索中，以确定内容的情感或情绪基调，这对于特定的搜索应用程序非常重要。上下文理解： NLP 有助于理解单词和短语的使用上下文，从而使搜索系统能够提供上下文相关的结果。多语言搜索： NLP通过理解语言的细微差别和特定于语言的上下文，使语义搜索能够在多种语言中工作。机器学习：机器学习模型可用于基于 NLP 的语义搜索系统，根据用户交互和反馈不断提高搜索结果的相关性。 总体而言，NLP 语义搜索提供了更复杂和上下文感知的搜索功能，使其在各种应用中都很有价值，包括网络搜索引擎、企业搜索、电子商务、聊天机器人和虚拟助理，在这些应用中，理解和满足用户的意图至关重要。
语义搜索的例子是什么？ 以下是语义搜索的示例，用于说明其工作原理：
场景：假设您正在使用语义搜索引擎为您的研究项目查找有关“替代能源”的信息。在传统的基于关键字的搜索中，您可以简单地输入查询“替代能源”，然后根据这些关键字的精确匹配获得结果列表。然而，通过语义搜索，结果更加上下文相关并且概念驱动。
语义搜索查询： 您输入查询“住宅用最环保的替代能源是什么？”
语义搜索过程：
自然语言理解：语义搜索系统使用 NLP 来分析您的查询。它了解您正在寻找适合住宅使用的环保替代能源。查询扩展：系统通过考虑同义词和相关术语来扩展您的查询。它可能包括“绿色能源”、“可再生能源”和“家庭能源解决方案”等概念。上下文理解：系统识别您查询的上下文，即住宅用途和环境友好性。它知道您对工业规模的能源解决方案不感兴趣，而是对适合家庭的能源解决方案感兴趣。概念匹配：语义搜索系统匹配概念和相关术语，而不是精确的关键字匹配。它搜索讨论环保且适用于住宅应用的可再生能源的内容。 什么是语义引擎？ 语义引擎是一种软件系统或组件，旨在理解、分析和处理人类语言的含义和上下文。它通常用于自然语言理解（NLU）、自然语言处理（NLP）和语义搜索。语义引擎使用各种技巧和技术来提取和处理文本和语音的语义，使它们能够执行广泛的任务，包括：
自然语言理解 (NLU)：语义引擎可以理解文本或语音的含义，使它们能够提取实体、识别意图并理解上下文。它们通常用于聊天机器人、虚拟助理和客户支持系统中，以与人类类似的方式与用户进行交互。语义搜索：语义引擎可以执行简单关键字匹配之外的高级搜索操作。他们了解搜索查询背后的上下文和意图，使搜索结果更加相关和准确。信息检索：语义引擎用于从大型数据库或文档集合中检索信息的系统。他们可以识别相关文档并提取有意义的内容。情绪分析：这些引擎可以确定文本的情绪或情绪基调，例如识别客户​​评论是正面还是负面。文档摘要：语义引擎可以通过识别基本信息和重要细节来简洁地总结冗长的文档。机器翻译：机器翻译系统使用语义分析来理解一种语言的句子含义，并生成另一种语言的语义准确的翻译。命名实体识别 (NER)：它们可以对文本中的人名、地名、组织等实体进行识别和分类。主题建模：语义引擎可以根据语义内容将文档或文本分组为主题或集群，有助于内容分类和组织。问答：它们用于问答系统，可以理解自然语言的问题，并通过从文档或知识库中提取信息来提供准确的答复。推荐系统：语义分析可以帮助根据用户的偏好和过去的行为向他们推荐产品、内容或服务。 为了构建语义引擎，开发人员通常使用自然语言处理 (NLP) 和机器学习技术，其中可能涉及大型数据集和预训练语言模型（如 BERT、GPT-3 或特定领域模型）的训练模型。这些引擎可以进行定制和微调，以增强特定应用程序、领域或语言的性能。
语义引擎对于改善人机交互、搜索和信息处理至关重要，使其成为许多现代应用程序和服务不可或缺的一部分。
如何用Python实现语义搜索 您可以结合使用自然语言处理 (NLP) 库和技术在 Python 中实现语义搜索。
旁注：在现实场景中，您通常会使用更广泛的数据集和可能的预训练模型以获得更好的结果。这个例子作为一个基本的介绍。
1.安装所需的库：
您将需要spaCy和 scikit-learn等 Python 库来执行语义搜索。您可以使用 pip 安装它们：
pip install spacy pip install scikit-learn 2. 预处理您的数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efd1281192286c5dd3fb56b8357734c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5023cf68ad33b5a8988018ba37ac5f60/" rel="bookmark">
			Kafka安装及快速入门教程_Kafka3.5.1_云峦操作系统[KOS]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概述
2 安装环境
2.1 操作系统环境
2.2 kafka版本
3 安装配置kafka
3.1 安装配置jdk1.8
3.2 安装配置Kafka
3.3 查看kafka版本
4 kafka基本使用
4.1 创建topic
4.2 查看topic
4.3 使用自带的脚本来进行测试
1 概述 Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。其中，Kafka最新版本内置了zookeeper，无需单独安装zookeeper。
浪潮信息KOS是浪潮信息基于Linux Kernel、OpenAnolis等开源技术自主研发的一款服务器操作系统，支持x86、ARM等主流架构处理器，性能和稳定性居于行业领先地位，具备成熟的 CentOS 迁移和替换能力，可满足云计算、大数据、分布式存储、人工智能、边缘计算等应用场景需求。详细介绍见官网链接浪潮信息KOS服务器操作系统-服务器操作系统-浪潮信息。
2 安装环境 2.1 操作系统环境 版本信息：KeyarchOS 5.8。
硬件平台：X86_64。
2.2 kafka版本 kafka 3.5.1（当前最新版本）。
3 安装配置kafka 3.1 安装配置jdk1.8 查询JDK可用版本：yum search java | grep -i --color JDK
安装JDK：yum install -y java-1.8.0-openjdk.x86_64
检测安装版本：java -version
3.2 安装配置Kafka 下载kafka3.5.1：
wget https://downloads.apache.org/kafka/3.5.1/kafka_2.13-3.5.1.tgz
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5023cf68ad33b5a8988018ba37ac5f60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a17f611f69b5c476fd2606684506067/" rel="bookmark">
			微信小程序期末大作业-花店小程序（附下载链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序期末大作业-花店小程序 花店小程序，2023年上半年期末大作业，有底部导航栏，轮播图等等
点我下载资源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78a544f01a9165480f0203247d44a92/" rel="bookmark">
			MAC安装stable diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑配置 基本安装 1. 安装python
2. 安装git
3. 下载stable diffusion的代码，地址：
git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui
执行命令 ./webui.sh --precision full --no-half-vae --disable-nan-check --api Command: "/Users/xxxx/aigc/stable-diffusion-webui/venv/bin/python3" -m pip install torch==2.0.1 torchvision==0.15.2
Error code: 2
执行命令：
pip install torch==2.0.1 torchvision==0.15.2 -i https://pypi.tuna.tsinghua.edu.cn/simple 设置pip源：
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 建议还是切换到：
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ 任意文本编辑器打开webui根目录下的launch.py找到下列代码
gfpgan_package = os.environ.get('GFPGAN_PACKAGE', "git+https://github.com/TencentARC/GFPGAN.git@8d2447a2d918f8eba5a4a01463fd48e45126a379")
clip_package = os.environ.get('CLIP_PACKAGE', "git+https://github.com/openai/CLIP.git@d50d76daa670286dd6cacf3bcd80b5e4823fc8e1")
openclip_package = os.environ.get('OPENCLIP_PACKAGE', "git+https://github.com/mlfoundations/open_clip.git@bb6e834e9c70d9c27d0dc3ecedeebeaeb1ffad6b")
把那几个GitHub的源改成国内码云搬运的
gfpgan_package = os.environ.get('GFPGAN_PACKAGE', "git+https://gitee.com/gavinss1/GFPGAN.git@8d2447a2d918f8eba5a4a01463fd48e45126a379")
clip_package = os.environ.get('CLIP_PACKAGE', "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b78a544f01a9165480f0203247d44a92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee156f4c424985a24b7c32b15669280/" rel="bookmark">
			【C语言】free()函数详解(动态内存释放函数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🦄个人主页:修修修也
🎏所属专栏:C语言
⚙️操作环境:Visual Studio 2022
目录
一.free()函数简介
1.函数功能
2.函数参数
void * ptr
3.函数返回值
4.函数头文件
二.free()函数的具体使用
1.使用free()函数完成malloc()开辟空间的释放
2.使用free()函数完成calloc()开辟空间的释放
3.使用free()函数完成realloc()开辟空间的释放
三.free()函数常见使用误区
1.对非动态开辟内存使用free释放
2.使用free释放一块动态内存的一部分
3.对同一块动态内存多次释放
4.动态开辟内存后忘记释放
结语
一.free()函数简介 我们先来看一下cplusplus.com - The C++ Resources Network网站上free()函数的基本信息：
1.函数功能 可以看到,free()函数的功能是:释放以前由malloc(),calloc(),realloc()函数动态开辟的内存空间.使其可以重新被分配.
2.函数参数 该函数有1个参数,是:
void free (void* ptr); void * ptr 该参数的类型是无类型指针(void*),它指向先前由malloc(),calloc(),realloc()动态分配的内存块,它的作用是告诉函数要释放的内存块的起始位置.
3.函数返回值 函数的返回值类型是空(void),它表示函数在运行结束后不需要返回值.
4.函数头文件 该函数包含在头文件&lt;stdlib.h&gt;中.
二.free()函数的具体使用 free()函数的使用场景是:当我们先前使用了malloc(),calloc(),realloc()函数开辟了动态内存空间,我们在不再使用这块空间时就应该及时使用free()函数将它释放掉,以免造成内存泄漏.
内存泄漏：如果动态开辟的内存没有被释放，那么这些内存就会一直占用系统资源，从而导致内存泄漏。内存泄漏会导致程序运行速度变慢，甚至崩溃。
1.使用free()函数完成malloc()开辟空间的释放 如下,我们使用free()函数将malloc()开辟空间的释放掉:
给free()函数传入:malloc()函数动态开辟的指针(即p).
int main() { int* p = (int*)malloc(sizeof(int)*10); //开辟10个整型大小空间 if (p == NULL) //如果开辟失败,则打印错误原因 { //打印错误原因的一个方式 printf("%s\n", strerror(errno)); } else { int i = 0; for (i = 0; i &lt; 10; i++) //遍历赋值并打印这10个整型空间 { *(p + i) = i; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dee156f4c424985a24b7c32b15669280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ca067afff5b7731974c0d0db7798b5/" rel="bookmark">
			java后端返回数据给前端时去除值为空或NULL的属性、忽略某些属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、使用场景
二、环境准备
1、引入依赖
2、实体类
三、示例
1、不返回空值
(1)方式
(2)测试
(3)说明
2、不返回部分属性
(1)方式
(2)测试
四、 Jackson常用注解
1、 @JsonProperty
2、@JsonPropertyOrder
3、@JsonInclude
4、@JsonIgnoreProperties
5、@JsonFormat
6、@JsonUnwrapped
一、使用场景 在开发过程中，有时候需要将后端数据返回前端，此时有些数据为空属性不需要返回，或者有些属性不需要返回，因此就需要处理。
二、环境准备 1、引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; 2、实体类 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.math.BigDecimal; import java.util.ArrayList; import java.util.List; @Data @NoArgsConstructor @AllArgsConstructor public class Student{ private Integer id; private String name; private Integer age; private String address; private BigDecimal score; private String className; private List&lt;String&gt; subjectList = new ArrayList&lt;&gt;(); } 三、示例 1、不返回空值 (1)方式 在实体类上面加上下面的注解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4ca067afff5b7731974c0d0db7798b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0dd6d472e0cc04b153330ca0b06bf7/" rel="bookmark">
			【Java 进阶篇】Java Request 请求转发详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java Web开发中，请求转发（Request Forwarding）是一种常见的技术，用于将请求从一个Servlet转发到另一个Servlet或JSP页面。这种技术在Web应用程序中起着非常重要的作用，可以用于实现模块化、重用代码以及构建更加灵活的应用程序。本文将详细解释什么是请求转发，为什么它重要，如何使用它，以及提供示例代码来说明其工作原理。
什么是请求转发？ 请求转发是指将一个HTTP请求从一个Servlet转发到另一个Servlet或JSP页面的过程。它允许在Web应用程序中的不同组件之间共享请求和响应对象，从而实现模块化的代码和更好的代码重用。
请求转发通常在以下情况下使用：
模块化开发：将Web应用程序划分为不同的模块或组件，每个模块负责不同的任务。请求转发可用于在这些模块之间传递控制。
代码重用：将一些常用的功能实现为Servlet或JSP页面，然后可以在不同的页面中重用这些功能。
URL隐藏：用户访问一个URL，但希望在不暴露实际资源的情况下提供响应。请求转发允许隐藏Servlet或JSP页面的实际URL。
请求处理流程：将请求传递给一个Servlet，由该Servlet负责处理请求的一部分，然后将请求传递给下一个Servlet，以便处理其他部分。
请求转发的工作原理 请求转发是在服务器端进行的，因此对客户端来说是透明的。当一个Servlet收到一个请求后，它可以使用getRequestDispatcher()方法获取RequestDispatcher对象，然后使用该对象执行请求转发。
以下是请求转发的工作原理：
客户端发送一个HTTP请求到Web服务器。
Web服务器将请求路由到相应的Servlet。
Servlet通过getRequestDispatcher()方法获取RequestDispatcher对象。
Servlet使用RequestDispatcher对象的forward()方法将请求转发到另一个Servlet或JSP页面。
目标Servlet或JSP页面处理请求并生成响应。
Web服务器将响应发送回客户端。
客户端收到响应并显示结果。
使用getRequestDispatcher()方法 要执行请求转发，首先需要获取RequestDispatcher对象。这可以通过getRequestDispatcher()方法来完成。该方法有两种重载形式：
getRequestDispatcher(String path)：传递一个字符串参数，表示目标Servlet或JSP页面的路径。这个路径可以是绝对路径或相对路径。
getRequestDispatcher(String path, ServletContext context)：传递两个参数，一个是目标Servlet或JSP页面的路径，另一个是ServletContext对象。这种形式的方法更适合在跨上下文的请求转发中使用。
以下是使用getRequestDispatcher()方法的示例：
RequestDispatcher dispatcher = request.getRequestDispatcher("/targetServlet"); dispatcher.forward(request, response); 示例：请求转发 让我们通过一个示例来演示如何使用请求转发。假设我们有一个Web应用程序，其中包含两个Servlet：SourceServlet和TargetServlet。SourceServlet接收来自客户端的请求，然后将请求转发到TargetServlet，TargetServlet处理请求并生成响应。
SourceServlet.java import javax.servlet.*; import java.io.IOException; public class SourceServlet extends GenericServlet { public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { // 设置响应内容类型 response.setContentType("text/html"); // 获取RequestDispatcher对象 RequestDispatcher dispatcher = request.getRequestDispatcher("/TargetServlet"); // 执行请求转发 dispatcher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0dd6d472e0cc04b153330ca0b06bf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a1fa82e2f014f319135c2e0888b850/" rel="bookmark">
			[计算机毕设]基于java的酒店管理系统系统设计与实现(项目报告&#43;答辩PPT&#43;源代码&#43;数据库)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目报告
酒店管理系统的设计与实现
摘 要
中国经济近几年来取得蓬勃飞速发展，使得人民生活水平的要求和生活的质量有了很高的要求。因此人们对外出旅游和就餐的需求也越来越大。同时，随着我国科技水平的兴起和对互联网+新时代的大力支持，酒店管理系统在现代人们的生活中扮演着不可或缺的角色。
酒店管理系统，不仅能够加大对酒店的有效管理，而且能够使顾客享受到更优质服务。这个酒店管理系统从实际的需求出发实现了管理员权限管理模块，餐饮信息管理模块，客房信息管理和餐饮预订模块，顾客消费情况管理，客房预订操作模块。
这个系统以jsp风格为主要的开发语言，使用现在比较流行的MVC框架作为辅助手段，运用于开源免费的小型tomcat服务器来进行对MYSQL操作，在Myeclipse企业版开发环境软件上运行，完成了一个酒店管理系统。本系统具有简单易懂的操作方式和显示详细的房间信息,用户可以方便的了解到本酒店的全面信息，节约时间和成本。
关键字：酒店管理， JSP， MYSQL， tomcat
目 录
摘要.................................................................................................................................. i
ABSTRACT..................................................................................................................... ii
1 .绪论............................................................................................................................. 1
1.1课题背景.............................................................................................................. 1
1.2目的和意义.......................................................................................................... 1
1.3开发工具及技术................................................................................................... 1
1.3.1开发工具.................................................................................................... 1
1.3.2 JSP............................................................................................................. 2
1.3.4 MVC简介.................................................................................................. 2
1.4软件和硬件需求................................................................................................... 3
1.5本章小结.............................................................................................................. 3
2 .需求分析...................................................................................................................... 4
2.1需求调研.............................................................................................................. 4
2.2可行性分析.......................................................................................................... 4
2.2.1技术的可行性............................................................................................. 4
2.2.2经济的可行性............................................................................................. 4
2.2.3操作可行性................................................................................................ 4
2.2.4法律的可行性............................................................................................. 4
2.3系统用户用例图................................................................................................... 5
2.3.1管理员用例图............................................................................................. 5
2.4功能模块需求分析................................................................................................ 5
2.5性能需求.............................................................................................................. 6
2.5.1系统的安全性............................................................................................. 6
2.5.2数据的完整性............................................................................................. 6
2.6本章小结.............................................................................................................. 6
3. 系统分析与设计........................................................................................................... 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37a1fa82e2f014f319135c2e0888b850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca1c63830964ed98262cca822f7f68a/" rel="bookmark">
			vue使用WEB自带TTS实现语音文字互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 时隔多日，自己已经好久没更新文章了；今年一直跟随公司的政策[BEI YA ZHA]中，做了一个又一个的需求，反而没有多少自己的时间，更别说突破自己
˚‧º·(˚ ˃̣̣̥᷄⌓˂̣̣̥᷅ )‧º·˚（雾）
然后最近，我朋友突然和我说有没有做过TTS，我第一反应是???
ʕ •ᴥ•ʔ……
一脸无辜
于是就出现我们今天主题的
什么是TTS？
去调查了一番，简单的说就是一种语音文本互转的技术
这里涉及到语音合成的概念.语音合成是通过机械的、电子的方法产生人造语音的技术。TTS技术（又称文语转换技术）隶属于语音合成而WEB，也就是我们的浏览器，已经给我们封装好了TTS，能够很方便的调用API，基本上，我们能够使用原生的前端元素直接实现文本转语音，语音转文字 因此任何前端框架都可以使用该套逻辑实现TTS
WEB自带TTS 它是有自己的官方文档的，我们可以很轻易的就通过该API文档来找到我们需要的实现的逻辑
WEB自带TTS官方中文文档API
基础事件 文字转语音基础事件 这里给大家列出几个常用的基础事件，更多可访问上面的API文档
// 创建 SpeechSynthesisUtterance 对象 var speechUtterance = new SpeechSynthesisUtterance('Hello, how are you?'); // 创建 SpeechSynthesis 对象 var synthesis = window.speechSynthesis; // 设置语音合成的事件处理函数 // 开始语音合成 speechUtterance.onstart = function(event) { console.log('Speech synthesis started.'); }; // 结束语音合成 speechUtterance.onend = function(event) { console.log('Speech synthesis ended.'); }; // 暂停语音合成 speechUtterance.onpause = function(event) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca1c63830964ed98262cca822f7f68a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c32baf18e8d0cdba15788e8a00326fc/" rel="bookmark">
			【项目实战】基于Spark大数据的餐饮外卖数据分析可视化系统hadoop项目hive计算机程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：该项目只展示部分功能，如需了解，评论区咨询即可。
本文目录 1 设计背景2设计意义3 系统展示3.1 页面展示3.2 视频展示 4 更多推荐5 部分功能代码 1 设计背景 随着互联网和移动技术的飞速发展，餐饮外卖行业已经成为现代生活中不可或缺的一部分。越来越多的人选择通过外卖平台点餐，享受美食的便利。这一行业的迅速崛起带来了大量的订单数据、用户信息和商家交易记录，为数据分析和可视化提供了丰富的资源。因此，基于Spark大数据的餐饮外卖数据分析可视化系统的开发已经成为一个关键的技术趋势，具有深远的背景和意义。
餐饮外卖行业在过去十年中取得了爆炸式增长。越来越多的人选择使用外卖平台订餐，促使了大量订单和数据的产生。这些数据的规模和复杂性迅速增加，需要强大的工具来处理和分析。外卖平台追求个性化服务，通过分析用户的点餐历史和偏好，可以为用户提供更符合口味的餐饮推荐，提高用户满意度。
2设计意义 随着数字化时代的到来，餐饮外卖行业已成为人们生活中不可或缺的一部分。这一行业发展迅猛，各类外卖平台竞争激烈，数据成为了餐饮外卖企业取得竞争优势的关键资源。因此，基于Spark大数据的餐饮外卖数据分析可视化系统的开发具有重要意义。
餐饮外卖市场竞争激烈，各平台之间竞争用户、商家和市场份额。通过数据分析，企业可以更好地了解市场需求、用户行为和竞争对手，制定更具竞争力的战略。外卖用户体验对于平台的成功至关重要。数据分析可以帮助企业了解用户的需求，改进订单处理流程、送餐速度和服务质量，提高用户满意度。餐饮外卖平台需要与众多餐馆和商家合作。通过数据分析，可以更好地管理合作伙伴关系，了解哪些商家受欢迎，哪些产品最畅销，以提供更好的支持和合作。分析用户的点餐偏好和销售数据可以帮助餐饮企业优化菜单，添加或调整菜品以满足市场需求。大数据分析可以帮助餐饮外卖平台更好地管理订单、调度配送员、优化路线，降低运营成本。基于历史数据和趋势，系统可以帮助预测不同时间段和地区的订单需求，有助于提前做好准备。
3 系统展示 3.1 页面展示 3.2 视频展示 hadoop餐饮外卖数据分析可视化系统Spark hive
4 更多推荐 计算机毕设选题精选汇总
基于Hadoop大数据电商平台用户行为分析与可视化系统
Django+Python数据分析岗位招聘信息爬取与分析
基于微信小程序铁路订票小程序
Android热销农产品商城app
5 部分功能代码 import requests # 定义API密钥 api_key = "your_api_key_here" # 设置API端点 api_endpoint = "https://api.example.com/orders" # 发送请求获取数据 headers = {"Authorization": f"Bearer {api_key}"} response = requests.get(api_endpoint, headers=headers) # 处理响应数据 if response.status_code == 200: data = response.json() # 对数据进行进一步处理和分析 else: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c32baf18e8d0cdba15788e8a00326fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7886d2b3367703bed33766652e29b0/" rel="bookmark">
			SQL-正则表达式和约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 主要内容一.正则表达式1.操作1代码如下（示例）: 2.操作2代码如下（示例）: 3.操作3代码如下（示例）: 4.操作4代码如下（示例）: 二.约束1.主键约束 2.自增长约束3.非空约束4.唯一约束代码如下（示例）: 5.默认约束6.零填充约束代码如下（示例）: 总结 主要内容 正则表达式约束 一.正则表达式 正则表达式是一种用来描述字符串模式的工具，它可以用于匹配、查找、替换等操作。正则表达式由字符和特殊字符组成，可以使用这些字符来定义匹配规则。
常用的正则表达式字符和特殊字符有：
普通字符：表示匹配该字符本身，如a表示匹配字母"a"。元字符：具有特殊含义的字符，如.表示匹配除换行符以外的任意字符。字符类：用[]表示，表示匹配括号内的任意一个字符，如[abc]表示匹配字符"a"、“b"或"c”。反义字符类：用[^]表示，表示匹配除括号内字符以外的任意字符，如[^abc]表示匹配除"a"、“b”、"c"以外的任意字符。重复字符：用*、+、?表示，分别表示匹配前一个字符0次或多次、1次或多次、0次或1次。边界匹配：用^、$表示，分别表示匹配字符串的开头和结尾。分组：用()表示，可以将多个字符组合为一个整体，如(ab)+表示匹配"ab"、“abab”、"ababab"等。转义字符：用\表示，可以将特殊字符转义为普通字符，如\.表示匹配字符"."。 正则表达式的用法有：
匹配：使用match()函数可以在字符串中查找匹配正则表达式的部分，并返回一个包含匹配结果的数组。查找：使用search()函数可以在字符串中查找匹配正则表达式的部分，并返回第一个匹配的位置。替换：使用replace()函数可以将字符串中匹配正则表达式的部分替换为指定的内容。分割：使用split()函数可以根据正则表达式将字符串分割为多个部分，并返回一个数组。 其他用法
量词：用来指定前面的字符或字符类的重复次数。常用的量词有：
*：匹配前一个字符0次或多次。+：匹配前一个字符1次或多次。?：匹配前一个字符0次或1次。{n}：匹配前一个字符恰好n次。{n,}：匹配前一个字符至少n次。{n,m}：匹配前一个字符至少n次，最多m次。 特殊字符：
.：匹配除换行符以外的任意字符。\d：匹配数字字符。\D：匹配非数字字符。\w：匹配字母、数字、下划线字符。\W：匹配非字母、数字、下划线字符。\s：匹配空白字符（空格、制表符、换行符等）。\S：匹配非空白字符。\b：匹配单词边界。\B：匹配非单词边界。 分组和引用：
()：将多个字符组合为一个整体。(?:)：非捕获分组，用于只匹配但不捕获。\1、\2、…：引用前面的分组，用于匹配相同的内容。 断言：
(?=...)：正向肯定前瞻，用于匹配满足某个条件的位置。(?!...)：正向否定前瞻，用于匹配不满足某个条件的位置。(?&lt;=...)：反向肯定后顾，用于匹配位于某个条件之后的位置。(?&lt;!...)：反向否定后顾，用于匹配不位于某个条件之后的位置。 正则表达式的用法非常灵活，可以根据具体的需求来选择合适的字符、特殊字符、量词、分组等来构建匹配规则。同时，正则表达式还支持一些高级的特性，如贪婪模式、非贪婪模式、修饰符等，可以进一步扩展正则表达式的功能。
正则表达式的详细用法还有很多，可以根据具体的需求来选择合适的正则表达式和相应的函数来进行操作。
1.操作1 代码如下（示例）: -- ^ 在字符串开始处进行匹配 SELECT 'abc' REGEXP '^a'; -- $ 在字符串末尾开始匹配 SELECT 'abc' REGEXP 'a$'; SELECT 'abc' REGEXP 'c$’; -- . 匹配任意字符 SELECT 'abc' REGEXP '.b'; SELECT 'abc' REGEXP '.c'; SELECT 'abc' REGEXP 'a.'; -- [...] 匹配括号内的任意单个字符 SELECT 'abc' REGEXP '[xyz]'; SELECT 'abc' REGEXP '[xaz]'; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7886d2b3367703bed33766652e29b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d5037221a1ec55eda2393b9dd099fd7/" rel="bookmark">
			【ETL工具】Datax-ETL-SqlServerToHDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🦄 个人主页——🎐个人主页 🎐✨🍁 🪁🍁🪁🍁🪁🍁🪁🍁 感谢点赞和关注 ，每天进步一点点！加油！🪁🍁🪁🍁🪁🍁🪁🍁
目录
🦄 个人主页——🎐个人主页 🎐✨🍁
一、DataX概览
1.1 DataX 简介
1.2 DataX框架
1.3 功能限制
1.4 Support Data Channels
二、配置样例
2.1 环境信息
2.2 SQLServer数据同步到HDFS
2.2 参数说明
一、DataX概览 1.1 DataX 简介 DataX 是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS 等各种异构数据源之间高效的数据同步功能。
GitHub - alibaba/DataX: DataX是阿里云DataWorks数据集成的开源版本。
1.2 DataX框架 DataX本身作为数据同步框架，将不同数据源的同步抽象为从源头数据源读取数据的Reader插件，以及向目标端写入数据的Writer插件，理论上DataX框架可以支持任意数据源类型的数据同步工作。同时DataX插件体系作为一套生态系统, 每接入一套新数据源该新加入的数据源即可实现和现有的数据源互通。
DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader/Writer插件，纳入到整个同步框架中。
角色
作用
Reader（采集模块）
负责采集数据源的数据，将数据发送给 Framework。
Writer（写入模块）
负责不断向 Framework 中取数据，并将数据写入到目的端。
Framework（中间商）
负责连接 Reader 和 Writer，作为两者的数据传输通道，并处理缓冲，流控，并发，数据转换等核心技术问题。
HdfsWriter 提供向 HDFS 文件系统指定路径中写入 TEXTFILE 文件和 ORCFile 文件，文件内容可与 Hive 表关联。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d5037221a1ec55eda2393b9dd099fd7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/572/">«</a>
	<span class="pagination__item pagination__item--current">573/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/574/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>