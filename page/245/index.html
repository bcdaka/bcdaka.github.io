<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6205d07765ab2b7267bbb8300f512b9c/" rel="bookmark">
			React的列表和Key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React的列表 如果我们要在React中把一个数组转化成为我们的列表要怎么转换呢？
你可以通过使用 {} 在 JSX 内构建一个元素集合。
//定义一个NumberList组件 function NumberList(props) { //使用组件需要传入一个number值 const numbers = props.numbers; //使用 map() 方法来遍历 numbers 数组。将数组中的每个元素变成 `&lt;li&gt;` 标签 const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); //然后我们把整个 `listItems` 插入到 `&lt;ul&gt;` 元素中 return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById('root') ); 我们使用 Javascript 中的 map() 方法来遍历 numbers 数组。将数组中的每个元素变成 &lt;li&gt; 标签，最后我们将得到的数组赋值给 listItems.然后我们把整个 listItems 插入到 &lt;ul&gt; 元素中，然后渲染进 DOM。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6205d07765ab2b7267bbb8300f512b9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b543b4fcc73fdfaf3c8a01b2ded7305a/" rel="bookmark">
			web应用程序配置服务端口，采用Nginx作反向代理时，访问网页出现404的问题解决的分析过程和解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题描述
1、背景
2、问题详细描述
二、问题分析
1、错误的多个可能因素
2、原因分析
三、问题解决
1、 查看原来的nginx反向代理
（1）分析nginx配置
（2）nginx的重定向跳转
2、修改nginx反向代理
四、结果验证
1、刷新前
2、刷新后
一、问题描述 1、背景 由于业务需要，需要再客户现场部署一套人脸系统，该系统原本使用8800端口作为网页访问端口，并通过该端口与监听在1212和3001端口的后端API进行交互。然而，由于客户方面因其他业务关系无法开放8800端口，转而提供了7200端口作为替代。
鉴于直接修改网页访问端口存在困难，我们采用了在nginx上设置反向代理的解决方案。通过配置nginx，使其监听7200端口，并将来自该端口的请求转发至原本由8800端口负责的API服务（即1212和3001端口上的API及其参数）。
这样，我们就实现了在不改变后端API配置的情况下，通过7200端口进行网页访问的功能。以下是相关的配置图：
2、问题详细描述 根据前面的设想，我们在完成配置之后，可以直接通过7200端口来访问网页，实现顺利登录并且页面加载正常。实际操作界面如下图所示：
然而，进行其他功能操作、或者使用CTRL+R刷新该页面后，无法正常加载并返回404错误。如下图所示。
经过多次测试，每次登录都会正常加载，但是刷新后都会出现该错误。
二、问题分析 1、错误的多个可能因素 404 Not Found错误是一个HTTP状态码，它表明客户端（如浏览器）尝试访问的服务器资源不存在。针对这个错误，我们可以从以下几个方面来分析和排查原因：
（1）资源确实不存在：首先，应检查请求的URL是否正确，以及服务器上是否确实存在该资源（文件或目录）。
（2）配置错误：其次，需要审查服务器配置，确保没有配置错误导致资源无法被正确路由或处理。
（3）权限问题：虽然nginx以高权限启动，但文件系统权限、SELinux或AppArmor等安全模块可能仍然会阻止nginx访问某些文件。
（4）代理配置问题：当使用nginx作为反向代理时，特别需要注意代理配置是否正确。比如，从8800端口代理到本地的7200端口时，需要确保代理规则涵盖了所有必要的路径，并且重定向规则也配置正确。
2、原因分析 结合实际情况，我们可以排除以下可能性：
（1）文件或目录不存在以及配置错误的情况，因为如果是这些问题，那么即便能够登录，用户也将无法访问任何资源，这与问题描述不符。
（2）权限问题也被排除，因为nginx是以高权限账号启动的。
因此，最有可能的原因是代理配置问题。为了验证这一假设，我们需要检查nginx的配置文件，特别是与代理和重定向相关的部分，以确保所有规则都已正确设置。
通过这一步的审查，就可以找到导致404 Not Found错误的具体原因，并采取相应的措施进行修复。
三、问题解决 1、 查看原来的nginx反向代理 （1）分析nginx配置 进入nginx的配置目录下，使用命令：
vi nginx.conf
可以查看nginx的配置，原来的配置如下：
由上面可以看出，Nginx配置中缺少了重定向跳转的设置。这导致用户通过反向代理访问网页时，Nginx无法正确地将请求重定向到相应的资源，由此可能引发404错误。
（2）nginx的重定向跳转 重定向跳转是Nginx服务器提供的一项功能，它允许管理员配置服务器，以便在客户端访问特定URL时，自动将其请求重定向到另一个URL。这一重定向过程实际上涉及URL的重写，它主要通过Nginx配置文件中的重写指令来实现，确保客户端能够无缝地访问到预期的资源。
2、修改nginx反向代理 接下来就是在nginx配置中增加nginx的重定向跳转，非常简单，就在nginx.conf里增加
try_files $uri $uri/ /index.html;
这个语句即可，如下图所示：
这个语句主要用于处理静态文件和目录的访问请求。它按照预设的顺序尝试查找指定的文件或目录，一旦找到就立即返回相应的资源。在这个过程中，$uri 变量被用来存储用户请求的 URL 路径部分。
由于我目前尚未设置特定的 URI 路径，系统无法直接根据请求的 URL 路径找到对应的文件或目录。因此，在无法找到匹配项的情况下，系统会默认执行一个 fallback 操作，即返回当前路径下的 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b543b4fcc73fdfaf3c8a01b2ded7305a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eccb49ef90b50afbc2240da00fadd233/" rel="bookmark">
			Zabbix 监控 Kubernetes 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zabbix 监控 Kubernetes 集群 Zabbix作为一个成熟且功能强大的监控系统，被许多企业广泛采用。它能够对各种IT基础设施进行全面的监控，包括服务器、网络设备、应用程序等。而将Zabbix与Kubernetes结合，可以实现对Kubernetes集群的全面监控，从而提高集群的可观察性和管理效率。
Zabbix 的最低标准是它在监控 Kubernetes 和云原生应用程序方面与 Prometheus 一样有效。
Zabbix 提供与 Prometheus、警报管理器和 Grafana for Kubernetes 类似的指标和触发器，因为它们都使用相同的后端工具来执行此操作。然而，Zabbix 可以在一个产品中做到这一点，同时仍然保持灵活性，并允许您监视几乎任何您可以编写代码来收集的内容。关于应用程序监控，Zabbix 可以转换 Prometheus 导出器和端点提供给它的 Prometheus 指标。此外，由于 Zabbix 可以调用任何 HTTP 端点，因此它可以监视没有专用 Prometheus 端点的应用程序，这与 Prometheus 不同。
准备kubernets集群
root@node40:~# kubectl get nodes -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME node40 Ready control-plane 60d v1.29.3 192.168.72.40 &lt;none&gt; Ubuntu 22.04.2 LTS 5.15.0-105-generic containerd://1.7.15 node41 Ready &lt;none&gt; 60d v1.29.3 192.168.72.41 &lt;none&gt; Ubuntu 22.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eccb49ef90b50afbc2240da00fadd233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde541efe36554547868b8394dd9cf94/" rel="bookmark">
			什么是网段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、A类地址的网段： 情况1：最小的网段就是xxx.0.0.0，直接使用第一段的网络地址做网段。
情况2：如果希望网段允许的主机数量的范围缩小，扩大网段值即可，xxx.xxz.zzz.zzz，比如xxx.xxx.xzz.zzz，具体由设置路由器的人决定。
网段最小时，所允许的主机数量就是最多的，比如xxx.0.0.0网段，允许的主机数量为xxx.0.0.0~xxx.255.255.255。
二、B类地址的网段： B类ip理论范围为128.0.0.0 ~ 191.255.255.255，B类IP的前两段为网络地址，假如网络地址位131.12。
在网络地址确定为131.12的情况下，主机地址的范围为131.12.0.0~131.12.255.255，此时131.12.0.0就是网段。
在131.12.0.0这个网段内，可以分配的ip地址为131.12.0.1、131.12.0.2、...、131.12.255.254，理论上上限是可以分配65534个设备IP。
但是如果你不需要在网段内连接这么多主机的话，可以通过扩大网段值来减少可分配的ip数量，从而控制接入网段内的计算机台数。
三、C类地址的网段： 情况1：最小的网段就是xxx.xxx.xxx.0，前三个网地址识直接表示网段
情况2：如果希望网段允许的主机范围缩小，可扩大网段值，比如xxx.xxx.xxx.xzz或者xxx.xxx.xxx.xzz，具体数字是多少，由设置路由器的人自己设定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66585bbbd8f1be5b241c78b1cacafaa0/" rel="bookmark">
			【机器学习】机器学习重要方法—— 半监督学习：理论、算法与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言第一章 半监督学习的基本概念1.1 什么是半监督学习1.2 半监督学习的优势 第二章 半监督学习的核心算法2.1 自训练（Self-Training）2.2 协同训练（Co-Training）2.3 图半监督学习（Graph-Based Semi-Supervised Learning） 第三章 半监督学习的应用实例3.1 图像分类3.2 文本分类 第四章 半监督学习的未来发展与挑战4.1 标签质量与模型鲁棒性4.2 多视角与多模态学习4.3 标注策略与主动学习 结论 引言 半监督学习（Semi-Supervised Learning）是一类机器学习方法，通过结合少量有标签数据和大量无标签数据来进行学习。相比于纯监督学习，半监督学习在标签数据稀缺的情况下能更有效地利用无标签数据，提高模型的泛化能力和预测准确性。本文将深入探讨半监督学习的基本原理、核心算法及其在实际中的应用，并提供代码示例以帮助读者更好地理解和掌握这一技术。
第一章 半监督学习的基本概念 1.1 什么是半监督学习 半监督学习是一种介于监督学习和无监督学习之间的方法，通过同时利用有标签和无标签数据进行训练。在许多实际应用中，获取大量有标签数据的成本高昂，而无标签数据通常比较丰富。半监督学习方法能够在这样的环境中有效发挥作用。
1.2 半监督学习的优势 半监督学习相比于纯监督学习具有以下优势：
减少标注成本：通过利用大量无标签数据，可以显著减少对有标签数据的依赖，从而降低数据标注成本。提高模型性能：在有标签数据稀缺的情况下，通过引入无标签数据，可以提高模型的泛化能力和预测准确性。更好地利用数据：充分利用已有的无标签数据，避免数据浪费，提升模型的整体表现。 第二章 半监督学习的核心算法 2.1 自训练（Self-Training） 自训练是一种简单但有效的半监督学习方法，通过使用有标签数据训练初始模型，然后利用该模型对无标签数据进行预测，将预测结果置信度高的无标签数据作为新的有标签数据，加入训练集中，反复迭代直到模型收敛。
import numpy as np from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score # 加载数据集 iris = load_iris() X, y = iris.data, iris.target # 划分有标签数据和无标签数据 X_train, X_unlabeled, y_train, _ = train_test_split(X, y, test_size=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66585bbbd8f1be5b241c78b1cacafaa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aee8077c174a316ff1337174c1475eee/" rel="bookmark">
			【Python日志模块全面指南】：记录每一行代码的呼吸，掌握应用程序的脉搏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀一、了解日志🌈二、日志作用🌈三、了解日志模块⭐四、日志级别💥五、记录日志-基础❤️六、记录日志-处理器handler🎬七、记录日志-格式化记录☔八、记录日志-配置logger👊九、流程梳理 🚀一、了解日志 日志是记录了一系列事件或活动的文件。在计算机领域，它通常用于记录程序或系统的运行状况和维护信息，以便在需要时进行故障排除或回溯。通过分析日志文件，管理员可以了解系统的使用情况、问题发生的原因以及如何解决这些问题。
日志通常包含时间戳、事件描述、错误消息、警报等信息。它们可以按照不同的标准来分类和过滤，例如按照事件类型、日志级别、时间戳范围等。常见的日志类型包括系统日志、安全日志、应用程序日志等。
🌈二、日志作用 调试和故障排除：通过分析日志文件可以了解系统崩溃或出现异常的原因，进而进行修复和调试。性能调优：通过记录系统性能指标和资源利用情况等信息，管理员可以了解系统的瓶颈所在，从而进行针对性的优化。安全审计：日志可以记录系统的安全事件、访问控制和行为审计等信息，以便于发现并防止潜在的安全问题。统计分析：管理员可以通过日志记录用户行为、系统使用情况、网络流量等信息进行统计分析，以便于优化服务和提高用户满意度。 🌈三、了解日志模块 logging 模块提供了一种灵活且易于使用的方式来记录应用程序的状态和调试信息。它允许将消息分发到多个处理程序（handlers），并支持不同级别的日志消息。 logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等； ⭐四、日志级别 在 logging 模块中，日志级别用于描述日志的重要程度。它们按照严重程度分为以下五个级别： DEBUG：最详细的日志信息，通常只在调试问题时使用； INFO：确认一切按预期运行； WARNING：表示发生了一些意外或异常情况，但是该软件还可以正常运行； ERROR：由于更严重的问题，软件已无法执行某些功能； CRITICAL：严重错误，表明程序本身可能无法继续运行。 默认情况下，logging 组件会关闭低级别的日志消息并仅记录 WARNING 级别及其以上的消息。如果需要记录更多详细信息，则需要将 Logger 的 level 属性设置为其他级别。
# DEBUG # 最详细的调试信息，通常只在开发阶段使用。通过记录变量值、函数参数、分支走向等信息帮助调试人员解决问题。 # INFO # INFO 级别的日志通常用于确认系统正在按预期运行。例如，记录请求的处理时间、数据库操作数量、任务的完成状态等。 # WARNING # WARNING 级别的日志表示出现了一些意外或异常情况，但是该软件还可以正常运行。例如，数据缺失或配置文件格式错误等。 # ERROR # ERROR 级别的日志表示由于更严重的问题，软件已无法执行某些功能。例如，数据库连接失败、文件无法打开等错误。 # CRITICAL # 最高级别的日志级别，用于记录严重错误，表明程序本身可能无法继续运行。例如，内存耗尽、服务器崩溃等。 在应用程序中，通常会使用多个不同的日志级别来记录不同类型的事件。这使得开发人员可以快速识别和排除问题，并加快故障排除的过程。
# 开发应用程序或部署开发环境时， # 可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试； # # # # 应用上线或部署生产环境时，应该使用WARNING或ERROR或CRITICAL级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。 # 日志级别的指定通常都是在应用程序的配置文件中进行指定的。 # # # # 说明： # # -上面列表中的日志等级是从上到下依次升高的， # 即：DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL， # 而日志的信息量是依次减少的； # # -当为某个应用程序指定一个日志级别后， # 应用程序会记录所有日志级别大于或等于指定日志级别的日志信息， # 而不是仅仅记录指定级别的日志信息， # nginx、php等应用程序以及这里的python的logging模块都是这样的。 # 同样，logging模块也可以指定日志记录器的日志级别， # 只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃。 💥五、记录日志-基础 logging.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aee8077c174a316ff1337174c1475eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c11416618218a803e5bedf1827d595/" rel="bookmark">
			MongoDB中自动增长ID详解：实现、应用及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MongoDB中，自动增长的功能主要通过使用数据库的ObjectId或自定义的序列来实现。ObjectId是MongoDB默认的主键类型，它是唯一的并且具有一定的排序特性。然而，在某些场景下，可能需要使用自定义的自动增长ID，例如在某些遗留系统中或者为了更好的用户体验。
基本语法和命令 使用ObjectId ObjectId是MongoDB默认的主键类型，它由12字节组成，包括时间戳、机器标识符、进程ID和计数器。每次插入新文档时，MongoDB会自动生成一个新的ObjectId。
插入新文档时，_id字段会自动生成：
db.collection.insertOne({name: "example"}) 自定义自动增长ID 如果需要自定义自动增长ID，可以使用以下方法：
创建计数器集合：
创建一个专门的集合来存储序列计数器。
db.createCollection("counters") db.counters.insertOne({_id: "productid", seq: 0}) 定义获取下一个序列值的函数：
使用findAndModify原子操作来获取并增加序列值。
function getNextSequence(name) { var ret = db.counters.findAndModify({ query: { _id: name }, update: { $inc: { seq: 1 } }, new: true }); return ret.seq; } 插入新文档并使用自定义ID：
在插入新文档时，调用该函数以生成新的ID。
db.products.insertOne({ _id: getNextSequence("productid"), name: "example" }) 示例 以下是完整的示例代码：
创建计数器集合并插入初始值：
db.counters.insertOne({_id: "userid", seq: 0}) 定义获取下一个序列值的函数：
function getNextSequence(name) { var ret = db.counters.findAndModify({ query: { _id: name }, update: { $inc: { seq: 1 } }, new: true }); return ret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c11416618218a803e5bedf1827d595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a39559e4fa63778f0a8f24f66b93c1/" rel="bookmark">
			pycharm到期激活--mac（附踩坑攻略）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刚开始学习python，pycharm30天的免费试用到期了，从网上找了很多方法，失败了很多次，记录一下最终成功的步骤～
一、Pycharm版本 我最初下载的是最新版2024.1.3，可能因为版本太高，激活方式不支持
成功的版本号：PyCharm 2023.2.7 (Professional Edition)
版本可自行从官网下载：下载 PyCharm：JetBrains 出品的用于数据科学和 Web 开发的 Python IDE
可在其他版本中找相应的版本～
二、激活步骤 1.下载脚本：链接: https://pan.baidu.com/s/1St9NA7nOo2HAp94X0kfs1w 提取码: z89m 下载后解压如下（可放在任意文件夹但最好是全英文路径）：
2.进入scripts文件夹（此时要确保pycharm是安装好并未启动的状态）： 在当前目录下打开终端，步骤如下：
1）首先在scripts文件夹中，点击顶部view按钮，勾选as icons和show path bar显示当前文件路径；
2）在下方文件路径scripts处点击右键-- 打开终端open in terminal，这样就是在当前文件夹下打开了；
3）先运行该文件夹下uninstall.sh文件，再运行install.sh文件；
命令：
sudo bash uninstall.sh sudo bash install.sh 或者：su root进入root权限，然后./uninstall.sh和./install.sh，两种方式均可。
当出现如下显示done，说明脚本执行成功。
如果运行时出现错误：Operation not permitted while System Integrity Protection is engaged，是因为mac系统整体保护（System Integrity Protection，SIP）被激活。 解决方案： 1. 重启电脑并按住Command + R键进入恢复模式；
2. 在菜单栏中选择Utilities &gt; Terminal；
3. 在终端中输入以下命令来禁用SIP：csrutil disable
4. 重启电脑后，重新回到scripts文件夹执行上面的两条操作
注意：禁用SIP可能会系统易受安全威胁，完成执行的操作，建议再次启用SIP，操作方法和上面步骤一致，只需将disable改为enable：csrutil enable
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a39559e4fa63778f0a8f24f66b93c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59ff77e0f230227397029a1d04c31b3/" rel="bookmark">
			微软Edge浏览器与WebRTC：实现下一代网络通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebRTC（Web Real-Time Communications）是一种支持网页浏览器进行实时语音、视频和数据通信的开放技术。作为微软开发的现代浏览器，Edge是否支持这项技术，对于希望在网页上实现实时通信功能的开发人员和用户来说至关重要。本文将探讨Edge浏览器对WebRTC技术的支持情况，以及WebRTC如何改变网络通信的格局。
1. WebRTC技术概述 WebRTC允许直接在浏览器中实现点对点的通信，无需安装额外的插件或软件。
2. Edge浏览器的发展背景 微软Edge浏览器是基于Chromium开源项目开发的，旨在提供更快、更安全且更兼容的网页浏览体验。
3. Edge对WebRTC的支持 自Edge的早期版本开始，就已经内建了对WebRTC的良好支持。
4. WebRTC在Edge中的实现方式 WebRTC在Edge中的实现依赖于底层的Chromium代码库，以及对相关API的实现。
5. 使用Edge进行WebRTC开发的优势 开发者可以利用Edge进行WebRTC应用的开发和测试，得益于其广泛的设备兼容性和性能优化。
6. Edge中的WebRTC API Edge支持多种WebRTC API，包括但不限于RTCPeerConnection、RTCDataChannel等。
7. Edge与WebRTC安全性 Edge提供了多层安全措施，确保WebRTC通信的安全性和用户隐私。
8. WebRTC在Edge中的性能表现 Edge浏览器针对WebRTC进行了优化，提供了高性能的实时通信体验。
9. Edge的WebRTC兼容性测试 开发者可以使用Edge的开发者工具进行WebRTC应用的兼容性测试。
10. 利用Edge进行WebRTC视频会议开发 WebRTC技术支持在Edge中实现视频会议功能，为远程协作提供可能。
11. 利用Edge进行WebRTC语音通话开发 除了视频，WebRTC也支持语音通话，Edge浏览器同样提供了良好的支持。
12. Edge中的WebRTC数据通道 WebRTC的数据通道功能允许在浏览器之间传输任意数据。
13. WebRTC在Edge中的跨平台支持 WebRTC应用在Edge浏览器中具有良好的跨平台特性，包括Windows、macOS等。
14. Edge对WebRTC新特性的支持 随着WebRTC标准的发展，Edge也在不断更新以支持新特性。
15. WebRTC在Edge中的性能调优 开发者可以通过多种方式调优WebRTC在Edge中的表现，如调整网络策略等。
16. Edge的WebRTC应用场景 WebRTC在Edge中的应用场景包括在线教育、远程医疗、游戏、社交网络等。
17. WebRTC在Edge中的用户体验 Edge提供了丰富的API和工具，帮助开发者优化WebRTC应用的用户体验。
18. Edge的WebRTC插件和扩展 虽然WebRTC内建于Edge，但开发者仍可以利用扩展增强WebRTC功能。
19. WebRTC在Edge中的未来展望 随着技术的发展，WebRTC在Edge中的应用将更加广泛和深入。
20. 结论 微软Edge浏览器对WebRTC技术的支持，为开发者提供了一个强大的平台，以构建下一代的网络通信应用。通过本文的介绍，读者应该能够了解Edge对WebRTC的支持程度，以及如何利用Edge进行WebRTC开发。
随着实时通信需求的增长，WebRTC技术在Edge浏览器中的应用将持续扩大。对于开发者来说，掌握在Edge中使用WebRTC的技巧，将有助于他们构建更加丰富和互动的网络应用。对于用户来说，Edge浏览器提供的WebRTC支持将带来更加流畅和安全的通信体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410eb93867844e62b210ba3f54e33b55/" rel="bookmark">
			眼见不一定为实之MySQL中的不可见字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、问题的由来
1、需求背景
2、数据表结构
二、定位问题
1、初步的问题
2、编码是否有问题
3、依然回到字符本身
三、深入字符本身
1、回归本质
2、数据库解决之道
3、代码层解决
四、总结
前言 在开始今天的博客内容之前，正在看博客的您先来看看以下这两条sql，如果您刚好还有MySQL的环境。不妨先猜测一下它输出的内容，然后看看是否有什么区别？第一条sql如下：
select length('G30L3B01') as l1; 接着再来看另一条sql，sql脚本如下：
select length('G30L3﻿B01') as l2; 各位不妨猜测一下，上面两条sql语句的执行结果l1和l2分别是多少？是不是在你的预料之中。 这里不卖关子了，相信执行过sql的朋友一定看到了结果。没有数据库客户端的朋友来看我的执行结果。在给出结果之前，首先把基础环境介绍一下。这里的服务器用的的个人的Windows 7 专业版开发机，数据库服务用的是MySQL5.7，打开的查询服务窗口所在的数据库编码是UTF-8。
上面这个结果有没有超出你的预想，这两个字符串“看”起来似乎是一模一样的。这里的“看”我打了引号，至于原因，后面会讲到。本文即以上述场景为例，讲解在MySQL中，为什么会有这种“看”起来一致，但实际上不一样的问题，通过现象找本质，通过一步一步的排查，找到问题的根源，最后在寻根溯源后，找解决的办法；从应用代码编程的角度和底层数据库的角度来解决上述问题。如果您现在也遇到了这种“看”起来不正常的值，不妨一起交流一下。
一、问题的由来 首先依然要介绍一下上述问题的出现场景，以便于其它的朋友在此情此景下，有更大的印象。因此本节首先将对问题的场景进行详细的描述。这里打算从两个方面讲述，第一个方面是讲述需求背景，即在什么情况下作这个事。第二个是讲述数据背景，把相关的表设计也说明一下。
1、需求背景 事情发生的背景是这样的，客户要求我们做一个功能，他们会提供一个数据的Excel模板，然后我们需要将这些数据批量导入到数据库中。这个需求咋一看起来，是一个非常简单的需求啊。读取Excel的依赖库，一大把。解析Excel的数据，然后批量插入到数据库中，对于MybatisPlus或者其它的ORM工具都是非常简单的事。当时我们选择的是阿里巴巴开源的读取Excel的组件。感兴趣的朋友可以自己上github搜索一下。然后也基于组件也已经将Excel没个表格都读取到了内存中，然后调用MP的批量插入方法，意外的是在进行批量插入的时候数据库报错了。下面还是将数据库的表先做一个介绍。
2、数据表结构 为了实现将数据导入到数据库中，根据面向对象的原则，我们将Excel表格中的每个单元格都设计成了一个字段，然后对字段的数据类型进行了设计，同时包括数据长度。其中有一个项是输入数据的编码，然后用户是有编码规则的，每一个数据都有一个对应的编码规则。我们简单的看了他们的编码规则，得知其长度大致为8位，因此我们在数据库中设计成了varchar(8)；这么设计其实是中规中矩的，非常合理。然而在上面的批量入库过程中就一直报对应的这个字段too long。这个异常看起来很奇怪，因为我们人工去“看”的时候，这个字符串的长度确实是8。于是陷入了沉思。
二、定位问题 既然在开发过程当中出现了问题，那么如何解决问题呢？在解决问题之前，首先要定位问题，只有正确的定位问题，才能对症下药，问题才能迎刃而解。因此本节将重点讲解怎么定位问题。
1、初步的问题 当看到上面问题的时候，第一感觉是懵的，刚开始都有点不敢相信自己的眼睛。因为肉眼根本“看”不出来这个字符串居然不是8位。最开始怀疑的是在字符串的前后可能存在空格，因此导致了其长度超出了8位。为此我们将数据进行去空，使用sql进行去空如下：
SELECT length('G30L3B01') AS VisibleLength, length(replace('G30L3﻿B01', '​', '')) AS CleanLength; 然后发现还是不对，经过替换后其长度还是11，说明还是超长了。 2、编码是否有问题 在进行空字符过滤之后还是没有解决问题。于是换了一个方向，想着有没有可能是字符集的问题。其实大家可以看看UTF-8的字符集规范，字符集虽然会有一定的影响，但是这里存储的都是英文和数字，其长度均是标准的1，因此不存在字符的问题。问题一下子没有了方向，不知道往哪个方面去排查。
3、依然回到字符本身 在第一次尝试了空字符替换无果，又排除了字符编码的问题后，再一次将目光投入到字符本身。这一次的想法是，虽然空字符本文替换后，长度还是11，但是这并不说明其内容一定是空格。有没有什么其它的东西在捣乱呢。有时候找问题就是这样，反反复复。
三、深入字符本身 上面从几个方面分析了可能存在的问题，尤其是第三点，我们从最开的字符又回到了起点。那么这次采用什么分析思路呢？本小节深入道来。
1、回归本质 为了来看看这个数据到底是什么？我们将字符串转为十六进制的字符串，通过比较原始字符串来看看区别。在MySQL中可以使用HEX(str)实现转换。相关的转换SQL如下所示：
SELECT HEX('G30L3B01') AS hex_representation,HEX('G30L3﻿B01') as n2; hex_representation	n2 4733304C33423031	4733304C33EFBBBF423031 不知道眼尖的你发现了问题没有，上面这条SQL执行完之后发现，其目标字符串似乎不一样啊。后面的字符串，也就是有问题的字符串其长度真的超长了。下面仔细对比这两个字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410eb93867844e62b210ba3f54e33b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7fa3e0bbbd1c7e075d28d9cff181d6/" rel="bookmark">
			C语言中的可变参数函数（如printf）是如何实现的。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，可变参数函数（variadic functions）是一种可以接受不确定数量参数的函数。这些函数通常使用stdarg.h（在某些系统中可能是varargs.h）头文件中定义的宏来处理可变参数。
printf函数就是一个典型的可变参数函数，它接受一个格式字符串，后面跟着任意数量的参数，这些参数根据格式字符串中的占位符进行格式化输出。
可变参数函数实现的基本原理如下：
函数原型中的省略号（ellipsis）：
可变参数函数在函数原型中使用省略号（...）来表示可以接受可变数量的参数。例如，printf函数的原型为：
c复制代码
int printf(const char *format, ...); va_list、va_start、va_arg 和 va_end：
这些是在stdarg.h中定义的宏，用于在函数内部处理可变参数。
va_list：这是一个类型，用于声明一个用于访问参数的变量。va_start：初始化va_list变量以访问参数列表。这个函数需要两个参数：一个是va_list变量，另一个是最后一个固定参数之后的下一个参数。va_arg：返回参数列表中的下一个参数，并使va_list变量指向下一个参数。va_end：清理va_list变量。 使用stdarg.h中的宏：
在函数内部，你可以使用上述宏来遍历参数列表。通常，你会先使用va_start来初始化va_list变量，然后使用va_arg来逐个访问参数，直到没有更多的参数为止。最后，使用va_end来清理va_list变量。
以下是一个简单的可变参数函数的例子，它类似于printf，但只支持整数和浮点数：
c复制代码
#include &lt;stdarg.h&gt; #include &lt;stdio.h&gt; void my_printf(const char *format, ...) { va_list args; va_start(args, format); while (*format != '\0') { if (*format == '%') { format++; switch (*format) { case 'd': { // 整数 int i = va_arg(args, int); printf("%d", i); break; } case 'f': { // 浮点数 double d = va_arg(args, double); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b7fa3e0bbbd1c7e075d28d9cff181d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683820e433f468376b909ee688b553cc/" rel="bookmark">
			从零开始搭建LLaMA-Factory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备写一个完整教程：
手动卸载原先驱动和cuda（英伟达自带的驱动升级程序闪退崩溃）官网下载驱动、cuda、cudnn逐一安装（系统装驱动，cuda与cudnn。然后anaconda虚拟环境装pytorch）安装llama factory微调
（一）卸载
https://www.wagnardsoft.com/blog
Display Driver Uninstaller (DDU) 的官网
进入安全模式的步骤：开始菜单的重启键（按住shift）
进入安全模式以后，双击运行ddu.exe，
选择 显卡–英伟达，并且选中“清理并重启” 重启后进入 控制面板–程序，把英伟达相关的统统卸载掉。
（二）下载
https://www.nvidia.cn/Download/index.aspx?lang=cn#
英伟达驱动下载的官网
https://developer.nvidia.com/cuda-toolkit-archive
cuda下载的官网
https://developer.nvidia.com/rdp/cudnn-archive
cudnn下载的官网
https://pytorch.org/get-started/previous-versions/
pytorch与cuda python cudnn对应版本的网站（鸡肋）（可略过）
https://pytorch.org/get-started/locally/
（三）安装
1.先是安装驱动，没什么好说的一路默认安装。安装完毕后在设备管理器查看：显示适配器—你的显卡型号—双击—该设备正常使用（驱动版本对应的上）
2.接着装cuda
也是一路无脑默认安装，安装完毕后在cmd输入nvcc -V，要出现一下信息：
接着在默认cuda安装目录C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.5\extras\demo_suite里，把busGrind.exe拖入cmd运行，要求出现一下画面：
接着把deviceQuery.exe拖入cmd运行：
至此，cuda安装完毕。
3.下面是安装cudnn：
打开C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.5目录，可看到以下文件夹：
官网下载的cudnn解压后，可看到以下文件夹：
注意：重点来了！
把cudnn的这三个文件夹各自里面的内容复制到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.5目录下对应的三个文件夹里面
上面这句话很绕，我就是想强调千万别搞成“替换掉”，而是“复制到”。（我猛然想起以前我安装cudnn就是直接替换掉…无语了）
至此，所有跟英伟达打交道的环节全部结束。（虽然理论上可以把cuda和cudnn安装在虚拟环境conda里，但不管是pip还是conda安装，不管怎么换源，速度奇慢无比，懒得折腾了。故统统装在操作系统层面，反正上文也阐述了彻底清除驱动的方法，问题不大。）
4.安装anaconda。无脑装就行了，完事后在anaconda navigator创建一个新的环境（下文内容别在base环境里操作…）
打开链接 https://pytorch.org/get-started/locally/
到这里的话，有两条路线：路线一： 手动一个个下载，一个个安装在操作系统，然后把目录一个个从操作系统复制到虚拟环境里
路线二：直接把pip3 install…这一整串命令复制到虚拟环境的终端执行。
为什么会有两种做法，因为之前的路线二是有bug，所以有一段时间只能走路线一。现在亲测可以使用路线二。
完事后在虚拟终端里输入
python import torch torch.cuda.is_available() 然而报错：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/683820e433f468376b909ee688b553cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2edb052f0b2cc6811031e3b9c0ce07b/" rel="bookmark">
			关于椭圆的方程（有Python画的动图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于椭圆的方程（有Python画的动图） flyfish
几何定义 椭圆是平面上所有到两个固定点（焦点）的距离之和为常数的点的集合。这两个固定点叫做焦点。
解析几何描述 设椭圆的两个焦点为 F 1 F_1 F1​ 和 F 2 F_2 F2​，焦距（两焦点之间的距离的一半）为 c c c，长轴的半长轴为 a a a，短轴的半短轴为 b b b，椭圆上任意一点到这两个焦点的距离之和是一个常数 2 a 2a 2a。如果椭圆的中心在原点，长轴平行于 x x x 轴，则椭圆的标准方程为： x 2 a 2 + y 2 b 2 = 1 \frac{x^2}{a^2} + \frac{y^2}{b^2} = 1 a2x2​+b2y2​=1如果长轴平行于 y y y 轴，只需交换 a a a 和 b b b 的位置： x 2 b 2 + y 2 a 2 = 1 \frac{x^2}{b^2} + \frac{y^2}{a^2} = 1 b2x2​+a2y2​=1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2edb052f0b2cc6811031e3b9c0ce07b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19084c70be69536acdac0f9c5074eaa5/" rel="bookmark">
			SwiftUI 6.0（iOS/iPadOS 18）中全新的 Tab 以及 Sidebar&#43;悬浮 TabView 样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概览 看来苹果一直对 iPadOS 中标签栏（TabView）不甚满意。这不，在 WWDC 2024 中苹果又对 TabView 外观做了大幅度的进化。
现在我们可以在顶部悬浮条和左侧的 Sidebar 两种不同布局之间恣意切换 TabView 的外观啦。而且，这在 SwiftUI 6.0 中显得尤为简单。
在本篇博文中，您将学到如下内容： 概览1. iPadOS 18 中全新的 Sidebar+悬浮 TabView 样式2. 新 TabView 样式在 iOS 18 中的表现3. SwiftUI 6.0 新的 Tab 和 TabSection 原生视图4. 让 Tab 懂你所选5. 调整 Tab 的显示位置总结 看来 iPadOS 18 对 TabView 外观和功能都做了重量级的升级，那小伙伴们还等什么呢？
Let‘s find out！！！😉
1. iPadOS 18 中全新的 Sidebar+悬浮 TabView 样式 为了最大化利用屏幕空间，从 iPadOS 18 开始苹果有史以来第一次将位于底部的 TabView：
神奇的变为悬浮条置于窗口的顶部：
从上面两张图中我们可以对比在 iPadOS 18 中系统默认的时钟 App 中标签栏的新外观。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19084c70be69536acdac0f9c5074eaa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d49b60b71ea0326da1fc268fe84cbbe3/" rel="bookmark">
			Matlab数学建模实战应用：案例1 - 股票价格预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、问题分析
二、模型选择
三、Matlab代码实现
完整代码示例
四、模型改进
1. 引入更多特征
2. 使用更复杂的模型
3. 模型参数优化
五、实例总结
总结
前言 股票价格预测是金融工程中的重要问题，利用数学建模可以帮助分析和预测股票价格的波动趋势，帮助投资者做出更明智的决策。本文将详细介绍股票价格预测的步骤，包括问题分析、模型选择、Matlab代码实现、模型验证和模型改进。
一、问题分析 股票价格的波动性： 股票价格具有高度的波动性，由多种因素（例如市场需求、公司业绩、经济形势等）共同作用导致。影响因素： 常见的影响股票价格的因素包括：公司财务报表、行业发展、国家政策、国际经济环境、投资者情绪等。预测目标： 短期预测：对未来几天或几周的股票价格进行预测，主要为日交易策略提供依据。中长期预测：对未来几个月或几年内的价格趋势进行预测，辅助长期投资决策。 二、模型选择 线性回归模型：
假设股票价格与某些因子（如技术指标）之间的关系是线性的。线性回归模型简单易用，但对复杂的股票价格波动可能无能为力。 时间序列模型：
自回归移动平均模型（ARMA）、自回归积分滑动平均模型（ARIMA）等，用于处理具有时间依赖性的序列数据。 机器学习模型：
支持向量机（SVM）、LSTM神经网络等，能够捕捉股票价格的非线性关系和复杂的波动模式。 本次实例将选择时间序列模型（ARIMA）进行股票价格预测。
三、Matlab代码实现 以下是一个使用ARIMA模型进行股票价格预测的完整代码示例。
导入数据： 我们假设股票数据（包含日期和收盘价）存储在stock_data.csv文件中。 % 读取股票数据 data = readtable('stock_data.csv'); dates = data.Date; prices = data.Close; % 将日期转换为 MATLAB 日期格式 dates = datetime(dates, 'InputFormat', 'yyyy-MM-dd'); % 绘制收盘价时序图 figure; plot(dates, prices); title('Stock Closing Prices'); xlabel('Date'); ylabel('Closing Price'); grid on; 数据预处理： 检查和处理缺失值，并拆分数据集为训练集和测试集。 % 检查缺失值 if any(ismissing(prices)) disp('存在缺失值，将其移除'); data = rmmissing(data); dates = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d49b60b71ea0326da1fc268fe84cbbe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577adedc864e2de4946cbc50d2bf1e61/" rel="bookmark">
			PyQt5中建立二级窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用qtdesigner创建两个窗口，在主窗口里面放置一个按钮，用pyuic解析为py文件。
主窗口文件名one.py，二级窗口文件名main_window_v1.py。 import sys import one import main_window_v1 from PyQt5.QtWidgets import * class SecondWindow(QMainWindow, main_window_v1.Ui_MainWindow): def __init__(self): super(SecondWindow, self).__init__() self.setupUi(self) def open(self): second.show() class MainWindow(QMainWindow, one.Ui_Form): def __init__(self): super(MainWindow, self).__init__() self.setupUi(self) self.pushButton.clicked.connect(SecondWindow.open) if __name__ == "__main__": app = QApplication(sys.argv) win = MainWindow() second = SecondWindow() win.show() sys.exit(app.exec_()) 参考：
PyQt5 + qtdesigner 多窗口设计/多页面显示_qtdesigner设计多窗口-CSDN博客
PyQt5-打开新窗口（多窗口）_哔哩哔哩_bilibili 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9a653564de481b7f841019259ec3385/" rel="bookmark">
			KVB:利率决议来袭！英国央行怎么样在安全的前提下调整货币政策？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
尽管英国5月CPI降至2%的目标水平，市场普遍认为英国央行（BOE）在即将召开的利率决议会议上不太可能降息。核心通胀和服务业通胀依然高企，这使得央行在政策调整上保持谨慎。
背景与市场预期
英国央行将于北京时间6月20日19:00公布利率决议。尽管最新数据显示英国5月CPI降至2%，交易员对降息的预期依旧不高，认为降息的可能性仅为5%。8月份降息的可能性也仅为30%左右。英国央行设定的通胀目标是2%，这一水平的实现本应是一个重要的政策转折点，但实际情况更加复杂。
荷兰国际集团（ING）的经济学家指出，虽然2%的通胀率达成了一个重要的里程碑，但这主要是由于能源价格的同比大幅下跌。在能源价格影响减弱后，通胀可能会再次波动。市场分析师Jenni Reid也表示，英国央行本周降息的可能性很小，主要原因在于核心通胀和服务业通胀依然较高。过去几个月，尽管整体通胀有所缓解，但核心商品和服务的价格仍在上涨，表明经济中的通胀压力尚未完全消退。
未来通胀预期与经济影响
KVB的首席经济学家James Sproule表示，即使5月通胀达标，英国央行自己也预计通胀将在秋季小幅上升。Sproule强调，服务业的通胀与工资和收入密切相关，这些数据比预期更有粘性，控制服务业通胀将是央行的重点目标。服务业通胀是央行关注的关键因素之一，因为它直接反映了国内需求和成本压力。如果工资持续增长，这将进一步推高服务业价格，使通胀更加难以控制。
由于即将到来的全国公投，英国央行的决策可能会更加谨慎。尽管英国央行表示会在必要时降息，但市场对其短期内降息的预期依旧不高。央行必须在应对经济疲软和避免刺激通胀之间找到平衡，尤其是在政治局势不稳定的背景下。
货币政策委员会的内部动态
在5月的会议上，两名货币政策委员会（MPC）成员投票支持降息，七名成员投票维持利率不变。荷兰国际的经济学家James Smith预计，本周的会议上可能再次出现这种分歧。Smith认为，尽管降息的可能性不大，但8月降息仍在谈判桌上。MPC内部的分歧反映了政策制定者在当前经济环境中的复杂选择。一方面，部分委员认为需要通过降息来支持经济增长，另一方面，多数委员担心降息可能会加剧通胀。
分析师将密切关注英国央行对流动性状况及其对经济影响的评估，以及最新数据是否动摇了央行信心的任何暗示。央行在决策过程中需要仔细权衡短期经济增长与长期通胀控制之间的关系，这将是未来政策走向的关键。
结论
综合以上分析，英国央行在本周降息的概率依然较低，市场普遍预计其将维持利率不变。这对英镑的短期影响有限，但由于核心通胀和服务业通胀依然较高，央行在未来几个月内可能仍需保持谨慎态度。尽管外部经济环境存在不确定性，英国央行在维持价格稳定与支持经济增长之间的平衡将决定其未来的政策方向。
关键词
英国央行降息预期、核心通胀、服务业通胀、货币政策委员会、英镑走势、经济数据。
KVB App#KVB官网#KVB安全吗#KVB怎么样
KVB外汇：英国央行利率周四决议，英镑跌破1.26支撑的可能性有多大？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc761abc85eba21483d9b2fd9405fee/" rel="bookmark">
			开发者上架ios系统iphone苹果xcode签名的封装应用ipa文件用于四个分类怎么选择打包方式？苹果App打包方式及其应用场景分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名代码研发工程师，在苹果应用开发过程中，我们需要了解和掌握各种打包方式。本文将详细介绍苹果App有哪些打包方式，以及每种方式的代表、作用、优势和应用场景。
1. iOS App Store Deployment（iOS应用程序商店部署）
iOS App Store Deployment是将开发好的应用发布到苹果官方的App Store上，供全球的iOS用户下载和使用。这是苹果官方推荐的一种发布方式。
作用：将应用发布到全球范围内，吸引各类用户下载和安装，获取市场份额。
优势：在App Store发布的应用可以接受苹果的审核，确保应用质量，并通过苹果官方的推广渠道，吸引更多用户下载。这样可以针对广大用户提升品牌知名度和收益。
注意事项：这是适用于将应用程序发布到App Store的方式。在选择此选项之前，确保应用程序已经经过了完整的测试，并符合苹果的开发者指南和审核要求。
建议和优势：如果您的应用程序已经准备好进行正式发布，并且满足苹果的审核要求，那么选择这种方式是最佳选择。这样，您可以通过App Store向全球用户分发应用程序，并从中获取更广泛的用户覆盖和收益。
2. Ad Hoc Deployment（保留adhoc部署）
Ad Hoc Deployment是一种将应用分发给指定用户的方法，通常用于测试和内部员工使用，适合有限的设备安装。
作用：通过Ad Hoc模式分发的应用可以控制用户范围，用于开发团队内部测试或者给特定用户体验。
优势：Ad Hoc Deployment能够方便地收集测试数据，快速部署新版本进行验证。对于涉及敏感信息或仅针对特定用户群体的应用，可以保护数据和知识产权。
注意事项：这种方式适用于限定数量的特定测试用户或企业内部分发。在选择此选项之前，确保您知道要分发的设备数量和目标用户，并将其纳入分发计划。
建议和优势：选择Ad Hoc Deployment可以允许您将应用程序分发给特定的用户或进行企业内部测试。这对于收集反馈和进行有限用户验证非常有用，例如内部员工使用或特定测试团队。
3. Enterprise Deployment（企业部署）
企业部署（Enterprise Deployment）主要针对公司内部使用的应用，一般需要企业开发者账号方可进行此类应用的开发和部署。
作用：企业级应用部署主要用于大中型企业对内部员工分发应用，解决公司内部业务需求。
优势：企业级应用跳过了苹果官方的审核流程，可以自由发布更新；同时避免了泄露公司敏感信息，保护企业知识产权。
注意事项：企业部署适用于在企业内部分发和管理应用程序。在选择此选项之前，确保应用程序的使用限制在企业内部，并有相应的权限和控制措施。
建议和优势：如果您需要在企业内部分发应用程序，例如内部工具或业务应用，那么企业部署是最佳选择。它允许您快速、轻松地将应用程序分发给企业员工，并进行集中的管理和控制。
4. Development Deployment（开发部署）
开发部署（Development Deployment）是在开发过程中使用的部署方式，主要用于开发者调试和测试应用。
作用：提供一种快速安装和试用已开发功能的方式，从而便于开发者及时发现问题并修复。
优势：可以实时在设备上查看和测试应用的表现，帮助开发者更好地了解应用的用户体验，不断优化改进。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7346ca80cacbfc93df5b7ada9dd1b0c/" rel="bookmark">
			环境配置04：Pytorch下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： 显存大于4G的建议使用GPU版本的pytorch，低于4G建议使用CPU版本pytorch，直接使用命令安装对应版本即可
GPU版本的pytorch的使用需要显卡支持，需要先安装CUDA，即需要完成以下安装
1.查看已安装CUDA版本 GPU对应的CUDA版本可以通过以下方法查看：
1.查看当前显卡驱动支持的CUDA版本 打开cmd，输入nvidia-smi
2.查看以安装的CUDA版本 可以通过命令“nvcc -V”或“nvcc --version”
3.如果nvidia-smi命令无效，则说明可能已经安装了cuda 有效解决：nvidia-smi报错Failed to initialize NVML: Unknown Error 且 print(torch.cuda.is_available())一直卡住_nvvm unknown error-CSDN博客
2.下载安装对应版本的cuda 配置显卡cuda与配置pytorch - 知乎 (zhihu.com)
3. python、torch、torchversion版本对应关系及安装 3.1 不建议使用pytorch官方的下载安装方式： 3.2 建议手动下载、手动安装： 1.在download.pytorch.org/whl/torch_stable.html 或download.pytorch.org/whl/torch/ 或阿里镜像源pytorch-wheels安装包下载_开源镜像站-阿里云 (aliyun.com) 中，
2.根据cuda版本、torch版本、python版本，下载对应的 torch.whl文件
3.根据torch与torchversion的对应关系，再下载对应的torchversion.whl文件 pytorch，torchvision与python版本对应关系及安装命令_pytorch python版本-CSDN博客
4.下载到本地文件夹，然后通过命令行的形式安装，这样安装可以避免官方安装中的错误
pip install ''xxx'' 5.测试GPU版本的pytorch是否成功安装使用
import torch print(torch.cuda.is_available()) 返回true则成功；
6. 如果返回false，则失败，需要优先检查cuda版本与torch版本是否对应，使用命令：pip list，查看torch是否为版本号+cuda版本号：
3.3 建议命令行安装（未亲自测试） pytorch，torchvision与python版本对应关系及安装命令_pytorch python版本-CSDN博客
3.4 其他博主 Anaconda/conda中安装torch（可部分参考） conda环境中cuda的安装 - white514 - 博客园 (cnblogs.com)
Anaconda虚拟环境中安装torch + cuda + cuDNN_anaconda安装cuda-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7346ca80cacbfc93df5b7ada9dd1b0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a30a010ca9980b7a3de74ee07adfe4/" rel="bookmark">
			T200HSA单路SDI/HDMI&#43;1路3.5音频高清万能采集卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品简介：
同三维T200HSA单路高清万能采集卡，可以采集1路SDI/HDMI高清信号+1路3.5音频信号，卡上有1个是HDMI接口+1个是SDI接口+1个3.5音频口，配件有： 1个小档板，PCI-E2.0 X1，分辨率最高可以达到1080P/60HZ,带SDK开发包：VC++、Delphi、C#，支持微软Directshow进行开发。
HDMI 输入，音频嵌入
3G SDI 输入，音频嵌入
模拟音频输入
采集录制：1080p60
PCIe x1，Gen2
产品特性：
1、接口
HDMI 输入
3G SDI 输入
模拟音频输入
输入最大分辨率 2048 x 1080
PCI Express 1 lane, Gen2
2、视频处理
信号源自动检测、切换
信号格式自动检测
颜色参数调整
去交织，消除锯齿
画面翻转、镜像、裁剪
独立多流输出
输出视频参数可设置
3、软件
支持OBS、AMCAP、POTPLAY等第三方软件
4、其他
LED 指示灯
板卡温度检测
多卡支持
拨码开关
高速 DDR
安装孔
高可靠性品质保证
产品应用：
1、教育课件录制、多媒体录播录像、会议录制、视频会议，远程教育培训;
2、医疗 X 光机、CT机、胃肠机、腹腔镜、B超机等医疗设备图像采集;
3、大屏幕拼接、电视墙行业、虚拟演播室、虚拟现实、工控机等设备;
4、安检 X 光机、雷达图像信号、VDR纪录仪;
5、网络电视直播、庭审现场录制采集，游戏设备（如PS4 Pro，XBOX One S）录像采集
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/244/">«</a>
	<span class="pagination__item pagination__item--current">245/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/246/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>