<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1bf134dee30f5e5ca5cdfb6a31a1112/" rel="bookmark">
			springboot在线订单管理系统设计与实现-附源码080941
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
第一章 摘要 1.1系统开发的目的与意义 1.2系统用户和功能 第二章 可行性分析 2.1业务流程分析 2.2经济可行性 2.3操作可行性 第三章 需求分析 3.1功能需求 3.2数据流程分析 第四章 总体设计 4.1结构设计 4.2数据库设计 4.2.1数据库物理设计 4.2.2数据库概念设计 4.2.3数据库逻辑设计 第五章 系统实现 5.1系统功能模块 5.2前台功能设计与实现 5.2.2订单管理设计与实现 5.2.3商品管理设计与实现 5.2.4订单售后的设计与实现 第六章 系统测试 6.1测试方法 6.2测试目的 6.3测试用例 6.3.1注册测试 6.3.2购买订单测试 6.3.3商品管理测试 第七章 总结 致谢 第一章 摘要 1.1系统开发的目的与意义 从上世纪末到目前，计算机科学技术已经被尝试应用在各个职业各个领域，在商业贸易上，使用比重较高。计算机科学技术包括软件技术、网络技术、硬件技术等，越来越多的商家使用计算机来进行营业，出售、收购、宣传各类商品，各类商业系统、软件解放了商家的双手，使商家把利益最大化，因此计算机技术在商业领域中占非常重要的地位。电子商务交易是卖家卖出东西，买家得到东西的过程，同时推广推销产品，为顾客提供购买服务。卖家不需要开店费用，节省了很多费用，从而将精力人力投入在销售质量和服务上。
在线订单管理系统采用Java编程语言，结合前段界面和MVVM技术，在Myeclipse编辑器和MySQL数据库上设计并实现的。目的在于呈现一个完整的交易系统，供各种用户使用，系统着重实现了商品发布、出售、交易、售后的功能。
1.2系统用户和功能 使用该系统，系统分为前台和后台，前台为普通用户，后台由管理员使用，但也可以用来登录普通用户，前台功能模块和后台功能模块可以细分为各种功能模块。
1．前台系统功能模块分为：
用户注册模块：要求新用户可以在系统前台注册，注册信息可以保存在数据库中，后台管理员审核注册的用户，防止一些违规注册，注册后即可登录系统前台。
商品展示模块：通过主要商品和商品类别展示系统的所有商品；
订单模块：要求购买商品的用户可以登录后在线购买，在线购买则需用户填写购买信息，并提交订单将信息展示在后台。
用户购买模块：跟淘宝、京东等大型电子商务网站一样，将商品放入用户购买记录，从而管理用户购买记录里的商品。
订单上交模块：跟淘宝、京东等大型电子商务网站一样，确认购买记录的商品后，提交用户订单，然后确认收货地址和收货人、联系电话等，方可付款。
付款模块：用户提交订单后，确认收货地址和收货人、联系电话等信息后，方可进入付款界面，付款。
2．后台系统功能模块分为：
用户管理模块：要求用户信息可以展示在后台中，用户管理分管理员和普通用户两部分，管理员可以修改管理员的名字和密码，用户管理可以显示用户注册的信息、修改用户个人资料和删除用户的操作。
订单管理模块：要求用户在线购买产生的订单信息可以展示在后台，卖家可以对订单信息进行标记审核，表示已接单，如果该订单过期或者迟迟没付款，也可以删除该订单的信息。
商品管理模块：要求商品信息可以展示在后台中，卖家可以对商品进行修改操作，修改后的商品替代原有的，并可以展示在前台中。
资讯管理模块：要求资讯信息可以在展示后台中，展示分二部分信息，分别购物需知和公告。可以进行增加、修改、删除、查看操作，然后更新到系统前台。
第二章 可行性分析 2.1业务流程分析 系统业务流程分析：
根据系统的功能需求，再分析该系统的业务流程，用户登录系统购买商品，先将商品加入至购买记录，然后对购买记录做调整，接着生成订单，订单生成后，在线支付金额，管理员管理商品，管理用户的订单。
系统前台业务流图如下图所示。
图2-1系统前台业务流图
系统后台业务流图如下图所示。
图2-2系统后台业务流图
2.2经济可行性 本系统最直接的目的就是让客户购买商品，为达到这一理念，首先设计了平台提供给用户购买商品，系统还提供清新的界面来吸引用户眼球。使用本系统可以直接为用户提供方便，不需要花太多的时间、精力、经费去宣传商品。系统直接向用户展示商品信息，让用户随心选购，放心使用。整个系统只需要后台管理员操作和配送员，比起传统的商品销售方便、简单、人员需求少，可以为企业节省开支，节省人力资源。系统为用户提供留言回馈让用户对商家服务满意，从而为商家增加客户，扩大市场。系统集多功能与一体，系统开发却不需要企业提供太多的人力物力资源，所以该系统投入市场，可以获得良好的口碑，为企业带来经济效益，绝对有经济可行性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1bf134dee30f5e5ca5cdfb6a31a1112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56ad771989840322d725113864f04c9/" rel="bookmark">
			若依项目(前端后分离版)整合百度(Ueditor)富文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Ueditor 资源下载
ueditor 官网：http://ueditor.baidu.com
ueditor API 文档：http://ueditor.baidu.com/doc
ueditor github 地址：http://github.com/fex-team/ueditor
2、资源下载之后的文件解压，改个名字，改为UEditor，复制放入项目public文件夹下
3、方便使用，形成组件，放入components文件夹下
ueditor.vue 代码，如果需要在headers中配置Authorization，在config中配置无效，需修改js文件，具体修改见下文
&lt;template&gt; &lt;div&gt; &lt;div :id="id" type="text/plain"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import '/public/static/Ueditor/ueditor.config.js' import '/public/static/Ueditor/ueditor.all.min.js' import '/public/static/Ueditor/lang/zh-cn/zh-cn.js' import '/public/static/Ueditor/ueditor.parse.min.js' import { getToken } from "@/utils/auth"; export default { name: 'UEditor', props: { /* 编辑器的内容 */ value: { type: String, default: "", }, /* 只读 */ readOnly: { type: Boolean, default: false, }, id: { type: String, default: 'editor' } }, data () { return { editor: null, defaultMsg:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e56ad771989840322d725113864f04c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23846fbb50ba51db660cc2bf65167fff/" rel="bookmark">
			如何使用web文件管理器Net2FTP搭建个人网盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言2. Net2FTP网站搭建2.1. Net2FTP下载和安装2.2. Net2FTP网页测试 3. cpolar内网穿透3.1.Cpolar云端设置3.2.Cpolar本地设置 4.公网访问测试5.结语 1.前言 文件传输可以说是互联网最主要的应用之一，特别是智能设备的大面积使用，无论是个人存储文件资料，还是商业文件流转，都有数据存储和传输的需求。有需求就有市场，相应的传输软件层出不穷，而这些软件也各有各的特色，在这些软件的加持下，我们可以轻松的将不方便携带的电脑转变成为数据存储中心，再配合cpolar内网穿透创建的数据隧道，就可以轻松构建专属的私有云盘。今天，笔者就为大家介绍，如何使用Cpolar内网穿透+Net2FTP，打造私人专属的文件共享网站。
2. Net2FTP网站搭建 Net2FTP算是比较出名的web文件管理器，经常在将资料上传服务器时使用。Net2FTP基于Web技术，因此可以使用各种浏览器打开，并通过网页页面进行数据传输操作，因此使用范围很广，用来搭建自己的私有云盘正合适。
2.1. Net2FTP下载和安装 首先我们需要下载Net2FTP的安装文件，可以在其官网（net2ftp.com/）找到，这里笔者下载的是完整版。下载完成后，将下载好的压缩包解压，并粘贴到网页运行环境中。
笔者使用的是PHPstudy，因此将net2ftp_v1.3文件夹粘贴到www文件夹下。
接着打开phpstudy，点击左侧的网站按钮。在“网站”页面下，点击左上角的创建网站，对本地的net2ftp网站进行设置。
具体需要设置的内容很少也很简单，具体为：
域名：本地访问net2ftp网页所使用的域名端口：即网页输出端口根目录：即net2ftp网页文件存放的位置，也就是files_to_upload文件夹的位置，需要注意的是，下载的net2ftp_v1.3没法安装网站，安装文件在files_to_upload文件夹，根目录也必须定在这里勾选FTP和数据库 完成各项设置后点击下方的确认，就能完成net2ftp网站的搭建。
接着点击网站条目右侧的管理按钮，选择弹出菜单中的打开网站按钮，就能访问到本地net2ftp网站。此处要注意的是，必须将php扩展栏目中的ftp项目勾选，否则可能导致网页出错。
2.2. Net2FTP网页测试 只要phpstudy中对net2ftp网站的设置正确，就能打开net2ftp的本地网页。
由于net2ftp是FTP客户端的网页化界面，因此我们需要设置好本地电脑上的ftp服务。笔者使用的是filezilla作为ftp管理软件，因此打开filezilla界面，点击左上方“文件”菜单下的“站点管理器”。
在站点管理器中，新建一个站点:
主机栏位设置为12.0.0.1端口选择21号输入用户名和密码（此处的密码仅在ftp使用） 完成设置后，点击页面下方的确认创建该站点。
接着，我们将filezilla创建的ftp主机信息（包括地址和端口），填入net2ftp页面中，再填入用户名、密码、邮箱等信息，就能登录net2ftp网页，进行文件的上传下载。
3. cpolar内网穿透 在本地电脑上安装net2ftp网页并成功进行访问测试后，就可以进行Cpolar内网穿透的安装。Cpolar的安装注册也很简便。可直接在cpolar的官网页面（www.cpolar.com）找到下载按钮。
笔者使用的是Windows操作系统，因此选择Windows版本进行下载。
Cpolar下载完成后，将下载的文件解压，双击解压后的.msi文件，即可自动执行安装程序，一路点击“Next”就能完成安装。
由于cpolar会为每个用户创建独立的数据隧道，并辅以用户密码和token码保证数据安全，因此我们在使用cpolar之前，需要进行用户注册。注册过程也非常简单，只要在cpolar主页右上角点击“用户注册”，在注册页面填入必要信息，就能完成注册。
到这一步，我们完成了net2ftp页面的本地访问测试，也在本地电脑上安装了cpolar内网穿透软件，接下来我们就可以创建一条能够连接本地net2ftp的内网穿透数据隧道，让我们能在公共互联网上访问到本地net2ftp网站。
3.1.Cpolar云端设置 数据访问并没有特定时间，也就是随时可能发生，因此需要我们的内网穿透数据隧道能够长期稳定在线。但cpolar免费版的数据隧道每24小时重置一次，笔者并不想每天进行重连设置，因此笔者将cpolar升级至vip版，以便能获得能长期稳定存在的内网穿透数据隧道。
要达到内网穿透的目的，需要先登录cpolar的官网，并在用户主页面左侧找到预留按钮，并点击进入cpolar的数据隧道预留页面。
在这里生成一个公共互联网地址（也可以看做数据隧道的入口），由于此时这个地址没有连接本地的软件输出端口，因此也可以看做是一条空白的数据隧道。
在预留页面，可以看到很多种可保留的数据隧道，这里我们选择保留二级子域名栏位。
在“保留二级子域名”栏位，需要进行几项信息的简单设置，即
地区：服务器所在区域，就近选择即可二级域名：会最终出现在生成的公共互联网地址中，作为网络地址的标识之一描述：可以看做这条数据隧道的描述，能够与其他隧道区分开即可）。 完成这几项设置后，就可以点击右侧的“保留”按钮，将这条数据隧道保留下来。
当然，如果这条数据隧道不打算再使用，还可以点击右侧的“x”将其轻松删除，节约宝贵的隧道名额。
3.2.Cpolar本地设置 完成cpolar云端的设置，并保留了空白数据隧道后，我们回到本地的cpolar客户端，将云端生成的空白数据隧道与本地的测试页面连接起来，让我们能在公共互联网上访问到本地的测试页面。
在本地打开并登录cpolar客户端（可以在浏览器中输入localhost:9200直接访问，也可以在开始菜单中点击cpolar客户端的快捷方式）。
点击客户端主界面左侧隧道管理项下的创建隧道按钮，进入本地隧道创建页面（如果要创建没24小时重置地址的临时数据隧道，可直接在此进行设置，不必再cpolar官网设置空白数据隧道）。
在这个页面，同样需要进行几项信息设置，这些信息设置包括：
1. 隧道名称 – 可以看做cpolar本地的隧道信息注释，只要方便我们分辨即可；
2. 协议 – 由于的测试页面是网页，因此选择http协议；
3. 本地地址 – 本地地址即为本地网站的输出端口号，而默认输出端口为，因此这里也填入81；
4. 域名类型 – 在这个例子中，我们已经在cpolar云端预留了二级子域名的数据隧道，因此勾选“二级子域名”（如果预留的是自定义域名，则勾选自定义域名），并在下一行“Sub Domain”栏中填入预留的二级子域名，该例子中为“net2ftpweb”。如果打算创建临时数据隧道，则直接勾选“随机域名”，由cpolar客户端自行生成网络地址；
5. 地区 – 与cpolar云端预留的信息一样，我们依照实际使用地填写即可；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23846fbb50ba51db660cc2bf65167fff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb8a98e783b5f1248b38404a176ac69/" rel="bookmark">
			一个Java的简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、人员分工 任务姓名计算、粘贴功能陈炜棋界面放置、按键监控林炳坚 二、系统功能架构图 三、系统描述 仿照Windows计算器,编写一具有GUI的计算器，能实现整数的加、减、乘、除四则运算，并且需要支持键盘快捷键，基本可取代windows计算器。支持复制、粘贴功能，方便输入长串数字。
四、功能说明 1.界面放置 代码中包括了创建清除按钮、数字和运算符按钮数组，并设置它们的位置、大小和样式。同时，还设置了计算式文本框和计算结果文本框的位置、大小和样式。清除按钮的功能是清空计算式和结果文本框的内容。数字和运算符按钮数组通过循环放置到窗口中，并设置了它们的位置、大小和样式。整个窗口的布局采用了自定义布局，即使用绝对位置和大小来布局组件。
2.按键监控 实现了为按钮添加动作监听器以及键盘事件监听器，从而实现了按钮点击和键盘输入的功能。
为每个按钮添加监听器：通过遍历按钮数组，为每个按钮添加动作监听器，以便在按钮被点击时执行相应的操作。
设置窗口相关属性：设置窗口大小、位置，窗口关闭操作为直接关闭，使窗口可见，并设置窗口获得焦点。
为粘贴按钮添加监听器：为“粘贴”按钮添加监听器，当按钮被点击时，从系统剪贴板获取内容，并将内容设置到计算式文本框中。
添加键盘事件监听器：通过添加键盘事件监听器，捕获键盘输入。在键盘输入时，根据输入的字符进行相应的处理，包括数字、小数点、运算符和等号的处理。具体功能包括：
追加数字或小数点到键盘输入缓冲区，并更新计算式文本框内容。处理运算符或等号的输入，根据当前的操作数和运算符状态更新计算式文本框，并调用result函数计算结果。 3.运算功能 主要包括以下功能：
result方法：根据传入的运算符z，对操作数num1和num2进行相应的加减乘除运算，并将结果显示在结果文本框中。同时清空操作数2和运算符。
actionPerformed方法：处理按钮的点击事件。根据按钮的动作命令字符串cmd，分别处理数字和小数点按钮的点击，以及加减乘除等号按钮的点击。
当点击数字和小数点按钮时，根据当前运算符状态，将数字追加到操作数1或操作数2，并在计算式文本框中显示完整的计算式。当点击加减乘除按钮时，根据当前操作数和运算符状态进行相应的运算，并更新计算式文本框的显示内容。当点击等号按钮时，调用result方法计算结果，并显示在结果文本框中。 4.粘贴功能 实现粘贴功能的方法。该方法首先获取系统剪贴板的内容，然后尝试将内容转换为字符串类型并返回。如果剪贴板的内容为空或不支持字符串类型，则返回空。
在实现过程中，使用了java.awt包中的Toolkit类和Clipboard类，以及java.awt.datatransfer包中的Transferable类和DataFlavor类来获取和处理系统剪贴板的内容。同时，还处理了可能出现的不支持的数据类型和输入输出异常，并进行了相应的异常处理。
五、关键代码 ​ package Ks; import javax.swing.JFrame;//创建和管理窗口框架的类。在这里，它用于创建计算器应用程序的主窗口 import javax.swing.JTextField;//一个用于输入或显示单行文本的文本框组件。在这里，它用于显示计算式和计算结果 import javax.swing.JButton;//提供了一个按钮组件，用户可以点击按钮执行相应的操作。在这里，它用于创建数字按钮和粘贴按钮 import javax.swing.SwingConstants;//提供了一些常量，用于指定文本或图标在组件中的对齐方式。在这里可能被用于设置文本框的对齐方式 import java.awt.event.ActionListener;//用于处理用户接口组件的动作事件（如按钮点击）。在这里，它用于监听按钮的点击事件 import java.awt.event.ActionEvent;//表示由用户界面组件（如按钮）生成的动作事件。在这里，它用于处理按钮的点击事件 import java.awt.Font;//表示字体。在这里，它用于设置文本框和按钮的字体样式 import java.awt.Toolkit;//提供了一种获取系统相关信息的途径。在这里，它用于获取系统剪贴板 import java.awt.datatransfer.Clipboard;//提供了访问剪贴板的类。在这里，它用于访问系统剪贴板 import java.awt.datatransfer.DataFlavor;//表示数据的类型，用于在剪贴板之间传输数据。在这里，它用于指定要获取的剪贴板数据的类型 import java.awt.datatransfer.Transferable;//表示可以传输的数据。在这里，它用于表示从剪贴板获取的数据 import java.awt.datatransfer.UnsupportedFlavorException;//表示不支持的数据类型。在这里，它用于处理不支持的剪贴板数据类型 import java.awt.Color;//表示颜色。在这里，它用于设置文本框和按钮的颜色 import java.awt.event.KeyEvent;//表示键盘事件。在这里，它用于处理键盘输入事件 import java.io.IOException;//表示输入或输出过程中出现的异常。在这里，它用于处理输入/输出异常 import java.awt.event.KeyAdapter;//提供了键盘事件的适配器类。在这里，它用于处理键盘事件的适配器 import java.util.regex.*;//提供了正则表达式的支持。在这里，它用于处理文本框中的输入 import java.math.BigDecimal;//提供了高精度的数学运算。在这里，它用于执行计算 public class Calculator extends JFrame implements ActionListener { private JTextField expText = new JTextField();// 第一行：计算式 private JTextField resultText = new JTextField("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fb8a98e783b5f1248b38404a176ac69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e579f3585403a0d2e92ead7628c586/" rel="bookmark">
			苹果手机IOS软件应用IPA砸壳包提取完整教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们有很多小伙伴可能想要获取到苹果手机软件的安装包但又不知该如何获取，本文就教你如何获取到IOS软件的IPA砸壳包
首先我们需要准备一台越狱的苹果IOS设备，如果不知如何越狱的可以参考这篇苹果手机越狱教程：https://www.hereitis.cn/articleDetails/2152
当我们准备齐全以后，我们就可以开始砸壳了，这里大概先简单说一下什么是砸壳包
我们平时是看不到苹果的安装包的，因为我们都是从 appStore 里直接下载安装的，不同于安卓的 apk 安装包，苹果的安装包文件后缀是IPA，而且当你从 appStore 下载软件时，该软件的安装文件是被签名加密过的，而且使用的是你登录的苹果ID的相关信息，所以从你手机上下载的软件安装包就算提取出来也是没有办法在其他手机上去使用的，所以我们需要获取解密过的安装包也叫砸壳包，是不包含签名信息的，这样的安装包就可以通过重新签名或者其他方式安装到任何苹果设备或供其他地方使用了
开始砸壳 1、首先打开我们越狱设备上的 Cydia 软件
2、然后点击软件源，点击右上角的编辑，然后再点击左上角的添加按钮，将软件源 https://cydia.iphonecake.com 添加进来
3、然后搜索一栏中分别搜索 AppSync unified、CrackerXI+ 和 Filza，将这些软件包安装上，其中 CrackerXI+ 就是我们砸壳的关键应用，Filza可以帮助我们把砸好的IPA文件发送到电脑上
4、然后我们打开刚刚安装好的软件 CrackerXI+
5、点击设置，然后将第一个按钮打开
6、然后回到 appList，里面有我们在该设备上安装的所有软件
7、我们选择需要砸壳的软件，然后选择第一项开始砸壳
8、砸壳完成后，我们通过 另外一个软件 Filza 来找到刚刚提取出来的 IPA砸壳包
9、然后选择进入目录 documents - CrackerXI，就可以看到刚刚提取出来的IPA砸壳包了
10、我们选择需要发送的砸壳包长按选择在APP中打开，然后就可以通过隔空投送等方式发送到电脑登其他设备上了
怎么样是不是还蛮简单的，感兴趣的朋友快来试一试吧，另外如果你在添加软件源的时候失败了，可以多重复试几次毕竟受网络环境等影响可能会失败，多添加几次就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5c118d5500c83b06fa7ab4800be697/" rel="bookmark">
			解决bad SQL grammar []； nested exception is java.sql.SQLSyntaxErrorException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Spring Boot中MySQL数据库报错“Bad SQL Grammar”的问题 目录 解决Spring Boot中MySQL数据库报错“Bad SQL Grammar”的问题问题描述解决步骤解决方案结论附：MySql常用配置参数及使用场景 在使用Spring Boot连接MySQL数据库时，有时候会遇到“Bad SQL Grammar”错误，这种错误通常在执行SQL语句时发生。本文针对的是对于执行多条SQL语句的情况。 问题描述 出现错误的SQL语句如下：
&lt;delete id="truncateUserInfo"&gt; truncate table sys_user; truncate table sys_user_info; truncate table sys_role_info; &lt;/delete&gt; 执行这个SQL语句时，可能会抛出BadSqlGrammarException，错误信息如下：
org.springframework.jdbc.BadSqlGrammarException: ### Error updating database. Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'truncate table sys_user_info; truncate table sys_role_info' at line 2 ### The error may exist in file [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb5c118d5500c83b06fa7ab4800be697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dec68c181b13d9ae878bd7d24d39c20/" rel="bookmark">
			AI聊天机器人，一个就够了：文心一言、讯飞星火、通义千问AI聊天机器人深度对比（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些结论 本次为第二部分的测评，第一部分的测评请点击这里。综合结论：：通义千问 &gt; 讯飞星火 &gt; 文心一言。
逻辑推理能力：讯飞星火 = 通义千问 &gt; 文心一言。对于基本的逻辑推理问题，三个AI聊天机器人都能通过测试。但对于稍高难度的逻辑推理问题，讯飞星火和通义千问的表现亮眼，文心一言则出现了AI幻觉。
知识问答能力：文心一言 = 讯飞星火 = 通义千问
语言理解能力：通义千问 &gt; 文心一言 = 讯飞星火
推荐与选择 如果重视文本生成能力和代码能力，讯飞星火可能是较好的选择。 对于需要强大的数学能力，讯飞星火同样占优。 在逻辑推理和语言理解方面，通义千问显示出更强的能力。 对于平衡各方面表现的需求，文心一言虽然在某些方面略显不足，但整体表现均衡。
逻辑推理能力 演绎推理 提示词：如果所有的程序员都会写代码，而阿里斯是一个程序员，那么阿里斯会写代码吗？
文心一言的回答 根据给出的逻辑：所有的程序员都会写代码。 因为阿里斯是一个程序员，所以阿里斯会写代码。
讯飞星火的回答 题目给出了两个前提：
所有的程序员都会写代码。 阿里斯是一个程序员。 基于上述两个前提，我们需要推断出阿里斯是否会写代码。
详细的分析如下：
根据第一个前提，如果一个人是程序员，那么这个人会写代码。 根据第二个前提，阿里斯是一个程序员。 因此，结合上述两个前提，我们可以得出结论：阿里斯会写代码。 答案：阿里斯会写代码。
通义千问的回答 是的，根据前提，如果所有的程序员都会写代码，而阿里斯是一个程序员，那么可以推断出阿里斯会写代码。
结论 文心一言 = 讯飞星火 = 通义千问
归纳推理 提示词：在过去的五年里，每年的夏天都很热。基于这个观察，你能推断出今年夏天也会很热吗？
文心一言的回答 这是一道基于时间序列的推理问题。首先，我们需要分析问题中给出的条件和结论，然后运用相关的逻辑推理原则来得出答案。 问题中给出的条件是：“在过去的五年里，每年的夏天都很热。”这个条件建立了时间序列中各事件之间的联系，即过去五年的夏天都是热的。 接下来，我们需要考虑这个条件是否足以支持结论：“今年夏天也会很热”。 根据时间序列的推理，如果已知过去的事件都以某种模式发生（例如，每年的夏天都很热），那么未来类似的事件也可能遵循同样的模式。然而，这种推理仅在模式持续不变的情况下有效。 由于问题中没有提供模式是否会改变的信息，我们不能确定今年夏天的天气情况。 综上所述，基于过去五年的数据，我们不能确定今年夏天一定会很热。天气变化有多种可能，包括保持高温、转凉或出现其他变化。因此，不能做出推断。
讯飞星火的回答 基于过去五年每年夏天都很热的观察，可以初步推测今年夏天可能也会很热。然而，这种推断并不绝对，因为气候和天气模式受到多种因素的影响，包括自然变化和人类活动等。例如，全球气候变化可能导致某些地区的气温波动，而局部的天气条件也可能与长期趋势不同。
为了更准确地预测今年的夏季气温，需要分析更多的数据和模型，如气象卫星数据、气候模型模拟以及历史气候记录等。这些信息可以帮助科学家了解当前的气候状况和潜在的变化趋势，从而作出更可靠的预测。
总之，虽然过去的观察可以提供一定的参考，但要准确预测今年夏天的气温还需要综合考虑多种因素和专业的气候分析。
通义千问的回答 基于过去的五年里每年夏天都很热这个观察，我们不能完全确定今年夏天也一定会很热。尽管这种连续高温的现象显示了一种趋势，但气候变化是复杂的，受到多种自然因素和人为因素的影响，包括但不限于大气环流、海洋温度变化、厄尔尼诺现象、全球气候变暖等。因此，对于今年夏天的气温情况，还需要考虑这些具体因素以及短期气候波动的影响，无法仅凭过去五年的数据做出准确预测。然而，从统计学角度看，连续高温确实增加了今年继续高温的可能性。
结论 文心一言 = 讯飞星火 = 通义千问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dec68c181b13d9ae878bd7d24d39c20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c3db3b80a5a383dad39c182eadb7f1/" rel="bookmark">
			【Java / Hutool / JSON】多层嵌套的JSON数据，如何优雅地put和get？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.示例JSON数据 给你一个形如下面的多层嵌套的JSON数据，你现在准备怎么put和get值其中的【content】字段的值呢？
{ "messages": [{ "role": "user", "content": "生成快速排序算法" }], "model": "ziya-coding-34b", "max_tokens": 8192, "stream": true } 2.用Hutool之前以前 我可能会如下操作，有的朋友看了可能会笑，但我真的这么干过：
public static void main(String[] args) { String jsonStr = "{\n" + " \"messages\": [{\n" + " \"role\": \"user\",\n" + " \"content\": \"生成快速排序算法\"\n" + " }],\n" + " \"model\": \"ziya-coding-34b\",\n" + " \"max_tokens\": 8192,\n" + " \"stream\": true\n" + "}"; Map jsonMap = JSONUtil.toBean(jsonStr, Map.class); List list = (List)jsonMap.get("messages"); Map o = (Map)list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c3db3b80a5a383dad39c182eadb7f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d8c77216d12d537cd37e38a126f167/" rel="bookmark">
			从无到有：AI绘画API在插画与游戏设计中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 随着人工智能技术的快速发展，AI绘画API已经逐渐成为插画和游戏设计领域的新宠。这些API能够将创意与技术完美结合，帮助设计师快速生成高质量的图像，为插画和游戏产业带来了巨大的变革。
AI绘画API的工作原理 AI绘画API基于深度学习和神经网络技术，通过对大量图像数据进行训练和学习，逐渐掌握图像生成的能力。这些API通常采用GAN（生成对抗网络）架构，由生成器和判别器两部分组成。生成器负责根据输入的文字描述或随机噪声生成图像，而判别器则负责对生成的图像进行评估和优化，使其更加真实和美观。
AI绘画API在插画设计中的应用 在插画设计中，AI绘画API已经成为了一种强大的辅助工具。设计师可以通过简单的文字描述或草图，快速生成出具有创意和艺术感的插画作品。这种技术不仅可以提高设计效率，还能为设计师提供更多灵感和可能性。
AI绘画API在游戏设计中的应用 游戏设计中，AI绘画API的应用同样广泛。在角色设计、场景渲染和特效制作等方面，AI绘画API都展现出了强大的实力。例如，一些游戏开发者使用AI绘画API来生成不同风格的游戏角色和场景，以丰富游戏的内容和视觉效果。此外，AI绘画API还可以用于游戏宣传和营销，快速生成吸引玩家的海报和宣传素材。
AI绘画API推荐 APISpace 的 AI绘画-Mid Journey，为大家提供了 Mid Journey 接口的调用能力，非常简单快速的就能得到 Mid Journey 为我们带来的各种绝美的图片。
图片案例：
图片描述词： 春日里的樱花树下，一位少女闭目沉思，周围是绽放的花朵和轻轻摇曳的绿叶。
同时 APISpace 还提供了 Stable Diffusion 绘画接口！感兴趣的小伙伴可以上去看看~
AI绘画API的优势与挑战 AI绘画API的优势在于其高效、便捷和创意性。这些技术能够帮助设计师快速生成高质量的图像，降低了创作的门槛和成本。然而，AI绘画API也存在一些挑战和限制。例如，它们生成的图像可能与设计师的预期存在偏差，需要进行调整和优化。此外，AI绘画API也需要更多的数据和训练才能不断改进和完善。
总结 AI绘画API在插画和游戏设计中已经成为了一种重要的工具和技术。它们能够帮助设计师快速生成高质量的图像，为创作提供了更多的可能性。然而，这些技术也需要不断改进和完善，以更好地满足设计师的需求和期望。未来，随着技术的进一步发展，AI绘画API将会在更多领域得到应用，为人们带来更多的创意和惊喜。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a7a5e6e3e338da53f1d8ff61e534de/" rel="bookmark">
			Python 与 PySpark数据分析实战指南：解锁数据洞见
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 海拥】【神级代码资源网站】【办公神器】🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流的小伙伴，请点击【全栈技术交流群】 数据分析是当今信息时代中至关重要的技能之一。Python和PySpark作为强大的工具，提供了丰富的库和功能，使得数据分析变得更加高效和灵活。在这篇文章中，我们将深入探讨如何使用Python和PySpark进行数据分析，包括以下主题：
1. 数据准备 在这一部分，我们将学习如何准备数据以便进行分析。包括数据清洗、处理缺失值、处理重复项等。
# 数据加载与清洗示例 import pandas as pd # 读取CSV文件 data = pd.read_csv('data.csv') # 处理缺失值 data = data.dropna() # 处理重复项 data = data.drop_duplicates() 2. 数据探索 通过Python和PySpark的强大功能，我们可以对数据进行初步的探索和分析，包括描述性统计、相关性分析等。
# 数据探索示例 import matplotlib.pyplot as plt # 描述性统计 print(data.describe()) # 可视化数据分布 plt.hist(data['column'], bins=20) plt.show() 3. 数据可视化 数据可视化是理解数据和发现趋势的重要手段。我们将介绍如何使用Matplotlib和Seaborn进行数据可视化。
# 数据可视化示例 import seaborn as sns # 绘制散点图 sns.scatterplot(x='column1', y='column2', data=data) plt.show() # 绘制箱线图 sns.boxplot(x='column', data=data) plt.show() 4. 常见数据分析任务 最后，我们将深入研究一些常见的数据分析任务，如聚类分析、回归分析或分类任务，并使用PySpark中的相关功能来完成这些任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a7a5e6e3e338da53f1d8ff61e534de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989fd26fe4f27cdee24521755b453d3d/" rel="bookmark">
			Hadoop 常用端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop生态系统中各个组件运行时会使用不同的端口号进行通信，以下是一些常用的服务和它们的默认端口号：
Hadoop HDFS (Hadoop Distributed File System)
NameNode:
Web UI：50070（Hadoop 2.x版本），9870（Hadoop 3.x版本）IPC通信端口：8020（用于内部节点间通信） DataNode：
数据传输端口：50010（数据输出）、50020（数据输入）心跳与块报告端口：50075 YARN (Yet Another Resource Negotiator)
ResourceManager (RM)：
Web UI：8088IPC通信端口：8030（服务端口）、8031（客户端RPC端口）、8032（应用程序管理器端口） NodeManager (NM)：
接受来自ResourceManager的心跳请求：8041接收容器启动命令：8042Web UI：8042 ApplicationMaster (AM)：
RPC端口由系统自动分配 MapReduce JobHistory Server
Web UI：19888（Hadoop 2.x版本） Hadoop HttpFS
Web UI: 14000 ZooKeeper
默认端口：2181（ZooKeeper服务器之间的选举、同步以及客户端连接） 请注意，这些是Hadoop组件的标准默认端口，实际部署过程中可以根据需要在配置文件中修改。同时，不同版本的Hadoop可能对某些端口有所调整，请以具体部署环境的实际配置为准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c611719149f1811bdf0f9a5e0d33695f/" rel="bookmark">
			AI大模型应用入门实战与进阶：大模型在知识图谱构建中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 知识图谱(Knowledge Graph, KG)是一种以实体(Entity)和关系(Relation)为核心的数据结构，用于表示实际世界的知识。知识图谱的应用范围广泛，包括信息检索、问答系统、推荐系统、语义搜索等。随着大规模机器学习(Deep Learning)和自然语言处理(Natural Language Processing, NLP)的发展，大模型(Large Model)在知识图谱构建中的应用也逐渐成为研究热点。
在本文中，我们将从以下几个方面进行探讨：
背景介绍核心概念与联系核心算法原理和具体操作步骤以及数学模型公式详细讲解具体代码实例和详细解释说明未来发展趋势与挑战附录常见问题与解答 1.1 知识图谱的发展历程 知识图谱的发展历程可以分为以下几个阶段：
早期知识表示(Early Knowledge Representation)：在这个阶段，知识主要通过规则和事实表示。例如，先进的知识表示语言(Knowledge Representation Language, KRL)和规则引擎。
基于向量空间的知识表示(Vector Space Knowledge Representation)：在这个阶段，知识主要通过向量空间表示。例如，Latent Semantic Analysis(LSA)和Latent Dirichlet Allocation(LDA)。
基于图的知识表示(Graph-based Knowledge Representation)：在这个阶段，知识主要通过图结构表示。例如，Resource Description Framework(RDF)和图数据库(Graph Database)。
大模型在知识图谱构建中的应用(Large Model in Knowledge Graph Construction)：在这个阶段，大模型成为知识图谱构建的核心技术。例如，Graph Convolutional Networks(GCN)和TransE。
1.2 大模型在知识图谱构建中的应用 大模型在知识图谱构建中的应用主要包括以下几个方面：
实体识别和链接(Entity Recognition and Linking, ER&amp;L)：大模型可以帮助识别文本中的实体，并将其链接到知识图谱中。例如，使用BERT模型对文本进行实体识别，然后将识别出的实体与知识图谱中的实体进行匹配。
实体关系预测(Entity Relation Prediction, ERP)：大模型可以预测实体之间的关系，从而构建知识图谱。例如，使用TransE模型预测实体之间的关系，然后将这些关系添加到知识图谱中。
知识图谱扩展(Knowledge Graph Expansion, KGE)：大模型可以帮助扩展知识图谱，从而增加知识图谱的规模和覆盖范围。例如，使用KG Embedding模型学习知识图谱中实体和关系的表示，然后使用这些表示来发现新的实体和关系。
知识图谱查询和推理(Knowledge Graph Querying and Reasoning, KGQR)：大模型可以帮助进行知识图谱查询和推理，从而提供更准确的答案。例如，使用Graph Convolutional Networks模型对知识图谱进行查询和推理。
2.核心概念与联系 在本节中，我们将介绍以下几个核心概念：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c611719149f1811bdf0f9a5e0d33695f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bde97aec4f28e4f0790f80c188ba074/" rel="bookmark">
			Android平板浏览器远程Ubuntu服务器使用code-server编程写代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.ubuntu本地安装code-server2. 安装cpolar内网穿透3. 创建隧道映射本地端口4. 安卓平板测试访问5.固定域名公网地址6.结语 1.ubuntu本地安装code-server 准备一台虚拟机,Ubuntu或者centos都可以，这里以VMwhere ubuntu系统为例
下载code server服务,浏览器访问:https://github.com/coder/code-server,复制下载链接
打开ubuntu命令行下载
出现需要输入ubuntu的登录账户密码,输入密码即可,然后等待安装完成
以下信息表示安装成功
接着输入以下命令设置code-server的登录密码
export PASSWORD=”000000” 查看IP地址,作局域网访问使用
code-server服务默认为8080端口号, 为了防止8080端口冲突,我们修改一下code-server端口号,输入以下命令,编辑配置文件
sudo vim ~/.config/code-server/config.yaml 把127.0.0.1改为0.0.0.0,8080端口改成自己喜欢的端口,本例子改为8077,修改完成保存
设置好密码后启动code-server服务,输入以下命令:
code-server 出现地址和端口号信息表示启动成功
接着打开浏览器通过局域网ip地址访问http://192.168.191.129:8077/,出现welcone code-server表示成功,输入我们设置的密码,登录即可.
2. 安装cpolar内网穿透 接着使用cpolar穿透本地code-server服务,使得android设备可以远程进行访问,随时随地写代码。cpolar支持http/https/tcp协议，不限制流量，操作简单，无需公网IP，也无需路由器。
cpolar官网：https://www.cpolar.com/
安装cpolar内网穿透(支持一键自动安装脚本)
cpolar 安装（国内使用） curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 或 cpolar短链接安装方式：(国外使用） curl -sL https://git.io/cpolar | sudo bash 查看版本号 cpolar version token认证 登录cpolar官网后台，点击左侧的验证，查看自己的认证token，之后将token贴在命令行里
cpolar authtoken xxxxxxx 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar 查看服务状态 sudo systemctl status cpolar 正常显示为active则表示服务为正常在线启动状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bde97aec4f28e4f0790f80c188ba074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc00859e66dca208e724f5f1b76b3de4/" rel="bookmark">
			优化改进YOLOv8算法之AKConv（可改变核卷积），即插即用的卷积，效果秒杀DSConv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 AKConv原理
1.1 Define the initial sampling position
1.2 Alterable convolutional operation
1.3 Extended AKConv
2 YOLOv8中加入AKConv模块
2.1 AKConv.py文件配置
2.2 task.py配置
2.3 创建添加优化点模块的yolov8-AKConv.yaml
2.4 训练 1 AKConv原理 AKConv: Convolutional Kernel with Arbitrary Sampled Shapes andArbitrary Number of Parameters
摘要：基于卷积运算的神经网络在深度学习领域取得了令人瞩目的成果，但标准卷积运算存在两个固有的缺陷。一方面，卷积运算仅限于局部窗口，无法捕获其他位置的信息， 并且它的采样形状是固定的。 另一方面，卷积核的大小固定为k×k，是一个固定的正方形，参数的数量往往随大小呈平方增长。 很明显，不同数据集和不同位置的目标的形状和大小是不同的。 具有固定样本形状和正方形的卷积核不能很好地适应不断变化的目标。 针对上述问题，本工作探索了可改变核卷积（AKConv），它赋予卷积核任意数量的参数和任意采样形状，为网络开销和性能之间的权衡提供更丰富的选择。 在 AKConv 中，我们通过新的坐标生成算法定义任意大小的卷积核的初始位置。 为了适应目标的变化，我们引入了偏移量来调整每个位置的样本形状。 此外，我们通过使用具有相同大小和不同初始采样形状的 AKConv 来探索神经网络的效果。 AKConv 通过不规则卷积运算完成高效特征提取的过程，为卷积采样形状带来更多探索选择。 在代表性数据集 COCO2017、VOC 7+12 和 VisDrone-DET2021 上进行的物体检测实验充分展示了 AKConv 的优势。 AKConv可以作为即插即用的卷积运算来替代卷积运算来提高网络性能。
1.1 Define the initial sampling position 定义初始采样位置卷积神经网络基于卷积运算，通过规则采样网格将特征定位在相应位置。在规则采样网格中给出了3×3卷积运算。设R表示采样网格，则R表示如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc00859e66dca208e724f5f1b76b3de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d58296506db2ffbce796e55b2c2cb87/" rel="bookmark">
			RabbitMQ（十二）Cannot deserialize value of type `java.lang.String` from Object value 报错整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.核心报错内容：2.完整报错内容：3.报错原因：4.解决方案： 消息接收类型错误
1.核心报错内容： Cannot deserialize value of type java.lang.String from Object value (token JsonToken.START_OBJECT)
2.完整报错内容： org.springframework.amqp.rabbit.listener.exception.FatalListenerExecutionException: Illegal null id in message. Failed to manage retry for message: (Body:'[B@7f8bf95d(byte[73])' MessageProperties [headers={spring_listener_return_correlation=459805f9-bf6a-4a2b-a060-404b38590dc4, x-first-death-exchange=ANYSIGN_DIRECT_EXCHANGE, x-death=[{reason=rejected, count=1, exchange=ANYSIGN_DIRECT_EXCHANGE, time=Tue Jan 09 15:16:37 CST 2024, routing-keys=[MY_ROUTING_KEY], queue=MY_QUEUE}], x-first-death-reason=rejected, x-first-death-queue=MY_QUEUE, __TypeId__=com.demo.config.mq.dto.MyMessageVO}, contentType=application/json, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=true, receivedExchange=ANYSIGN_DEAD_LETTER_EXCHANGE, receivedRoutingKey=DEAD_LETTER_ROUTING_KEY, deliveryTag=1, consumerTag=amq.ctag-DBuoqXo7Kr0tIR-3qCCEow, consumerQueue=DEAD_LETTER_QUEUE]) at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.checkStatefulRetry(AbstractMessageListenerContainer.java:1590) at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:1581) at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.doReceiveAndExecute(SimpleMessageListenerContainer.java:994) at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.receiveAndExecute(SimpleMessageListenerContainer.java:941) at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$1600(SimpleMessageListenerContainer.java:86) at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.mainLoop(SimpleMessageListenerContainer.java:1323) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d58296506db2ffbce796e55b2c2cb87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbbba2100bb6b66ad9d2e03df1430d3/" rel="bookmark">
			VSCode 安装 Copilot 详细过程和实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Copilot 是由 GitHub 和 OpenAI 合作开发的一款 AI 辅助编程工具，可以帮助开发者更高效地完成编程任务。在本文中，我将详细介绍如何在 VSCode 中安装 Copilot，并分享一些使用实例。
1、安装 Copilot 插件
要在 VSCode 中使用 Copilot，首先需要安装 Copilot 插件。步骤如下：
（1）打开 VSCode。
（2）点击左侧扩展视图按钮（或按 Ctrl+Shift+X 快捷键），进入扩展视图。
（3）在扩展视图的搜索框中输入“Copilot”，然后按 Enter 键。
（4）找到 GitHub Copilot 插件，点击安装按钮。
2、登录 GitHub 账户
安装完 Copilot 插件后，需要登录 GitHub 账户进行授权。步骤如下：
（1）点击 VSCode 左侧的 Copilot 图标，进入 Copilot 主页。
（2）点击页面上的“Login”按钮，登录 GitHub 账户。
（3）根据提示，完成授权操作。
3、使用 Copilot 编写代码
登录 GitHub 账户后，就可以开始使用 Copilot 编写代码了。下面分享几个实例：
实例 1：自动生成函数
在编写函数时，Copilot 可以根据函数名和参数生成合适的函数体。例如，输入以下代码：
def add(a, b): 然后按下 Tab 键，Copilot 会自动生成以下代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fbbba2100bb6b66ad9d2e03df1430d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958eef9c231e299a2f55993b393e25dd/" rel="bookmark">
			Mariadb和mysql数据库的区别和相同之处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目 录
一、maridb 和mysql在linux系统中广泛应用
二、MySQL数据库
三、MariaDB数据库
四、MariaDB和MySQL有哪些相同点
五、MariaDB和MySQL的不同点
一、mariadb 和mysql在linux系统中广泛应用 用linux（包括centos和Ubuntu）的都知道，经常会用到maridb 和mysql。实际上，MySQL/MariaDB是Linux上最流行的关系型数据库之一，它具有强大的性能、易用性和可扩展性。
关系型数据库就是把复杂的数据结构归结为简单的二元关系），如下图示：
许多网站和应用程序都使用MySQL作为后端数据库。有人会问我：这两个数据库是不是一样的？这两个数据库用哪个好呢？…等等问题，我们今天就谈一下这两个个数据库。
二、MySQL数据库 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的RDBMS（关系数据库管理系统）应用软件之一。
MySQL软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型和大型网站的开发都选择MySQL作为网站数据库。
MySQL具有功能强、使用简单、管理方便、运行速度快、可靠性高、安全保密性强等优点。MySQL用C和C++编写，它可以工作在许多平台（Unix，Linux，Windows）上，提供了针对不同编程语言(C,C++,JAVA等)的API函数；使用核心线程实现多线程，能够很好的支持多CPU；提供事务和非事务的存储机制；快速的基于线程的内存分配系统；MySQL采用双重许可，用户可以在GNU许可条款下以免费软件或开放源码软件的方式使用MySQL软件，也可以从MySQLAB公司获得正式的商业许可。
三、MariaDB数据库 MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区维护，并采用GPL授权许可。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的替代品。MariaDB基于事务的Maria存储引擎，替换了MySQL的MyISAM存储引擎，使用了Percona的XtraDB（英语：XtraDB），这是InnoDB的变体。MariaDB还包含PrimeBase XT (PBXT) 和 FederatedX存储引擎。
MariaDB名称来自Michael Widenius的女儿Maria的名字。开发这个分支的原因之一是甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。
MariaDB使用方法几乎与MySQL完全一致，包括命令、界面、使用等，根据官方介绍，在MariaDB 5.5版本之前，所欲的功能特性完全继承自MySQL，因此使用MariaDB 5.5的人会从MySQL 5.5中了解到MariaDB的所有功能。但是从2012年11月12日起发布的10.0.0版开始，MariaDB不再依照MySQL的版号，而是10.0.x版以5.5版为基础，加上移植自MySQL 5.6版的功能和自行开发的新功能。正因为是MySQL的一个分支和衍生版，因此各种特性与MySQL基本一致，所以用户在使用MariaDB时，几乎感觉不到其与MySQL的差异，这也是开发者开发MariaDB的初衷，那就是完全兼容并替代MySQL，包括API和命令行。
四、MariaDB和MySQL有哪些相同点 根据以往的经验，我总结如下相同之处：
数据类型：两者在数据类型方面有许多相似之处，如整数、日期、字符串等。语法和命令的兼容性：在MariaDB中执行的SQL语句和在MySQL中执行的SQL语句基本上是相同的，都支持使用SQL（Structured Query Language）语言进行数据库操作，这方面两者之间几乎没有什么不同。执行程序和实用工具的兼容性：MariaDB的执行程序、实用工具与MySQL同名且互相兼容。数据文件和表定义文件的兼容性：MySQL 5.x 的数据文件与 .FRM 文件（表定义文件）与 MariaDB 5.x 兼容。客户端 API 和通信协议的兼容性：MariaDB和MySQL都提供了一系列的API和连接器，所有客户端 API 与通信协议相互兼容，方便与其他应用程序进行交互。开发者可以使用相同的工具和库来与MariaDB和MySQL进行交互。文件、端口及文件路径的一致性：所有与复制相关的数据文件、套接字文件）、端口及文件路径一致。数据库驱动的兼容性：MySQL Connector（Java驱动程序及 C 客户端库文件）可以直接在 MariaDB中使用，而MySQL 客户端程序可以直接用于连接 MariaDB服务器。 因此，MariaDB和MySQL在执行程序、实用工具、数据文件、表定义文件、客户端 API 和通信协议、文件、端口及文件路径以及SQL语句等方面具有很好的兼容性。这些相同之处使得开发者可以轻松地从MySQL迁移到MariaDB，而无需对代码或配置进行大量更改。
五、MariaDB和MySQL的不同点 MariaDB和MySQL的不同点主要包括以下几个：
起源和开发目标：MariaDB是由MySQL的创始人主导开发的，旨在提供一个功能完善、完全兼容MySQL的替代品。MariaDB在MySQL的基础上进行了许多改进和扩展，以解决MySQL的已知问题并增加新的功能。许可证和开源政策：MariaDB遵循完全的GPL许可证，这意味着任何人都可以获取MariaDB的源代码，并对其进行修改、分发和共享。相比之下，MySQL则采用了双许可证策略，其社区版采用GPL许可证，而企业版则采用商业许可证。性能和优化：MariaDB在某些方面提供了优于MySQL的性能和功能。它修复了许多MySQL的错误，并且其代码库更干净、更易于理解，使得新的错误不太可能被引入。此外，MariaDB还针对多核处理和线程池进行了优化。存储引擎：MariaDB包含一些MySQL没有的存储引擎，例如Aria、ColumnStore和MyRocks。此外，MariaDB还包含一些MySQL没有的数据类型、函数和操作符、系统变量和选项。新功能及优化：MariaDB在MySQL的基础上增加了一些新功能及其优化，例如对JSON的支持、更好的复制功能、更快的查询等。社区和支持：尽管两者都有活跃的社区，但一些人认为MariaDB的社区更为开放和充满活力。这使得MariaDB在某些情况下更容易获得支持和交流经验。安全性和稳定性：经过长时间运行后，MySQL可能会出现一些问题，如性能下降和崩溃等。而MariaDB在这方面表现得更为稳定，并且在安全性方面提供了更多的功能和选项。 MariaDB和MySQL在开发目标、许可证、性能和优化、新功能和存储引擎、社区和支持以及安全性和稳定性等方面存在显著差异。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4bf266c7cc7d30d777f8a1ea33a4f6d/" rel="bookmark">
			MySQL优化：12种提升SQL执行效率的有效方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库管理和优化的世界里，MySQL作为一个流行的关系型数据库管理系统，其性能优化是任何数据密集型应用成功的关键。优化MySQL数据库不仅可以显著提高SQL查询的效率，还能确保数据的稳定性和可靠性。
在本文中，我将介绍12种提升SQL执行效率的有效方法，并通过实用的代码示例来具体展示如何实施这些优化策略。
本文，已收录于，我的技术网站 ddkk.com，有大厂完整面经，工作技术，架构师成长之路，等经验分享
1、使用索引优化查询 使用场景：当你的数据库表中有大量数据，而你需要频繁进行搜索查询时，索引是提高查询效率的关键。
代码示例：
-- 假设我们有一个员工表 employees CREATE TABLE employees ( id INT AUTO_INCREMENT, name VARCHAR(100), department_id INT, PRIMARY KEY (id) ); -- 为department_id字段创建索引 CREATE INDEX idx_department ON employees(department_id); -- 使用索引进行查询 SELECT * FROM employees WHERE department_id = 5; 代码解释：
第一步是创建一个包含id, name, department_id字段的employees表。
然后为department_id字段创建一个索引idx_department。这个操作会让基于department_id的查询更快。
最后，我们执行一个查询，利用创建的索引，从而提高查询效率。
最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。这是大佬写的， 七千页的BAT大佬写的刷题笔记，让我offer拿到手软
2、优化查询语句 使用场景：避免使用高成本的SQL操作，如**SELECT ***，尽量指定需要的列，减少数据传输和处理时间。
代码示例：
-- 不推荐的查询方式 SELECT * FROM employees; -- 推荐的查询方式 SELECT id, name FROM employees; 代码解释：
第一个查询语句使用了**SELECT ***，它会获取所有列，这在数据量大时非常低效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4bf266c7cc7d30d777f8a1ea33a4f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f35576b12ae8da8535c39d5b856e224/" rel="bookmark">
			JavaScript中实现页面跳转的多种方法【通俗易懂】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨前言✨
本篇文章主要在于如何使用JavaScript中的各种实现页面跳转的方式
🍒欢迎点赞 👍 收藏 ⭐留言评论 📝私信必回哟😁
🍒博主将持续更新学习记录收获，友友们有任何问题可以在评论区留言
在JavaScript中，实现页面跳转有以下几种方式：
1，直接跳转到目标页面：使用window.location.href属性可以实现直接跳转到目标页面。例如：
window.location.href = "https://www.baidu.com"; //网页链接路径 2，使用window.location对象：window.location对象提供了一系列方法，可以实现页面跳转。例如：
// 用新的URL替换当前页面的URL window.location.replace("https://www.baidu.com"); //网页链接路径 // 设置当前页面的URL window.location.assign("https://www.baidu.com"); //网页链接路径 3，使用 a 标签：使用 a 标签可以创建一个链接，用户点击该链接可以跳转到目标页面。例如：
&lt;a href="https://www.baidu.com"&gt;跳转到baidu.com&lt;/a&gt; 4，使用JavaScript函数：可以使用JavaScript函数来实现页面跳转，例如使用window.history.pushState方法。例如：
function goToPage(url) { window.history.pushState({}, "", url); } goToPage("https://www.baidu.com"); //网页链接路径 5，使用window.location.reload()方法：使用window.location.reload()方法可以重新加载当前页面，实现页面跳转。例如：
window.location.reload(); ✨最后✨
总结不易，希望uu们不要吝啬你们的👍哟(＾Ｕ＾)ノ~ＹＯ！！
如有问题，欢迎评论区批评指正😁
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4527ba18129fc7cff8d1d809f89a263c/" rel="bookmark">
			Java-URLDecoder、URLEncoder介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌺个人主页：杨永杰825_Spring,Mysql,多线程-CSDN博客
⭐每日一句：成为架构师路途遥远
📢欢迎大家：关注🔍+点赞👍+评论📝+收藏⭐️ 目录
前言
规则
URLEncoder
URLDecoder
方法
URLEncoder
URLDecoder
使用
案例
1.编码URL参数
2.解码URL参数
3.解析URL
前言 Java中的URLDecoder和URLEncoder是用于对URL进行编码和解码的类。URL编码是将URL中的特殊字符转换成特定的格式，以便于在URL中传递参数。URLDecoder类提供了decode()方法，可以将经过URL编码的字符串解码成原始字符串。URLEncoder类提供了encode()方法，可以将字符串编码成URL编码的格式。 规则 URLEncoder 在对字符串进行编码时，下列规则适用：
字母数字字符“a”通过“z”、“A”通过“Z”和“0”通过“9”保持不变。特殊字符.”、“-”、“*”、和“_”保持不变。空间性” ”转变为一个加号“+”。所有其他字符都是不安全的，并首先被转换成一个或多个字节，使用一些编码方案。然后每个字节表示的字符串“% XY”，xy是两位十六进制表示的字节。推荐使用UTF-8编码方案。然而，对于兼容性的原因，如果没有指定的编码，则使用该平台的默认编码。 例如使用UTF-8编码格式的字符串的字符串ü@ foo bar”会转化为“+字符串+ % % % C3前40foo吧”因为在UTF-8字符编码为字节ü两C3（HEX）和BC（HEX），和字符编码为一个@字节40（HEX）。
URLDecoder 转换过程是由urlencoder班采用反向。这是假设在编码的字符串的所有字符都是下列之一：“a”通过“z”、“A”通过“Z”、“0”通过“9”、和“-”、“_”、“.”、和“*”。字符“%”是允许的但被解释为一种特殊的序列开始逃跑。
下面的规则应用在转换中：
字母数字字符“a”通过“z”、“A”通过“Z”和“0”通过“9”保持不变。特殊字符.”、“-”、“*”、和“_”保持不变。加号“+”转换为空格字符“ ”。一个序列的形式“XY”将被视为代表一个字节xy是两位十六进制表示的8位。然后，包含一个或多个这些字节序列连续将由字符替换所有子串（S）的编码会导致那些连续字节。用于对这些字符进行解码的编码方案可以被指定，或者如果未指定，则该平台的默认编码将被使用。 有两种可能的方法，该解码器可以处理非法字符串。它可以把非法字符单独或可能引发IllegalArgumentException。该方法的解码器需要的执行。
方法 URLEncoder Modifier and TypeMethod and Descriptionstatic Stringencode(String s)过时的。 由此产生的字符串可能会有所不同，这取决于该平台的默认编码。相反，使用编码（字符串，字符串）方法来指定编码。
static Stringencode(String s, String enc) 翻译成 application/x-www-form-urlencoded格式字符串使用一个特定的编码方案。
​​​​​​​URLDecoder Modifier and TypeMethod and Descriptionstatic Stringdecode(String s)过时的。 由此产生的字符串可能会有所不同，这取决于该平台的默认编码。相反，使用解码（字符串，字符串）方法来指定编码。
static Stringdecode(String s, String enc) 解码使用特定的编码方案 application/x-www-form-urlencoded字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4527ba18129fc7cff8d1d809f89a263c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/534/">«</a>
	<span class="pagination__item pagination__item--current">535/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/536/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>