<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526551101a3bfdbc8b41e79c22f77e20/" rel="bookmark">
			白骑士的PyCharm教学进阶篇 2.2 高级调试技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列目录 上一篇：白骑士的PyCharm教学进阶篇 2.1 高效编码技巧
在Python开发中，调试是一个非常重要的环节。PyCharm作为一款功能强大的IDE，不仅提供了基本的调试功能，还包含了许多高级调试工具与技巧。本篇将详细介绍这些高级调试技术，并探讨如何进行远程调试与调试配置，以帮助你更高效地定位和解决问题。
高级调试工具与技巧 条件断点 条件断点允许你在满足特定条件时暂停程序执行，而不是每次运行到断点时都暂停。这在调试复杂逻辑或循环时非常有用。设置条件断点的方法如下：
在代码中设置一个普通断点，右键点击断点图标。选择“More” -&gt; “Edit Condition”。输入你希望满足的条件表达式，例如 ‘x &gt; 5‘ 或 ‘len(list) == 0‘。条件断点将在表达式为‘True‘时触发。 异步调试 在调试异步代码时，理解程序的执行流可能比较困难。PyCharm提供了对异步代码的调试支持，可以帮助你更好地理解和调试异步程序。使用异步调试的方法如下：
设置断点并启动调试模式。当程序运行到断点时，你可以在“Frames”窗口中查看当前线程和协程的调用栈。PyCharm会高亮显示当前正在执行的协程，帮助你追踪异步调用的执行流。 数据断点 数据断点用于监控变量的值变化，适用于调试内存相关问题或数据变化时的程序行为。设置数据断点的方法如下：
在“Debug”工具窗口中，选择“Watches”标签页。添加你希望监控的变量。右键点击变量，选择“New Data Breakpoint”。当变量的值发生变化时，程序会暂停执行，你可以查看变化前后的值。 调试多线程应用 多线程应用的调试往往比较复杂，PyCharm提供了对多线程调试的支持，可以帮助你追踪和调试多线程程序。调试多线程应用的方法如下：
设置断点并启动调试模式。当程序运行到断点时，你可以在“Threads”窗口中查看所有线程的状态。选择不同的线程，可以查看每个线程的调用栈和当前执行的位置。 远程调试与调试配置 远程调试 远程调试允许你在本地计算机上调试运行在远程服务器上的代码。PyCharm提供了简便的远程调试功能，使得调试远程环境中的程序变得容易。配置远程调试的方法如下：
在远程服务器上安装调试器包，例如 ‘pydevd-pycharm‘。在远程代码中添加以下代码来启动调试器： import pydevd_pycharm pydevd_pycharm.settrace('localhost', port=12345, stdoutToServer=True, stderrToServer=True) 然后进行以下步骤：
在PyCharm中，导航到“Run” -&gt; “Edit Configurations”。添加一个新的“Python Remote Debug”配置，设置‘localhost‘和相同的端口号（如‘12345‘）。启动远程调试配置，PyCharm会等待远程程序连接。当远程程序运行到调试器代码时，会自动连接到PyCharm，进入调试模式。 调试配置 为不同的调试场景配置不同的调试设置，可以提高调试的效率和灵活性。PyCharm允许你创建和管理多种调试配置。创建调试配置的方法如下：
在PyCharm中，导航到“Run” -&gt; “Edit Configurations”。点击左上角的“+”按钮，选择“Python”。配置调试配置的名称、脚本路径、工作目录和环境变量等参数。在“Configuration”标签页中，设置脚本参数、Python解释器等。在“Logs”标签页中，添加需要记录的日志文件。保存配置，点击“Debug”按钮启动调试。 配置环境变量 在调试过程中，配置正确的环境变量可以避免很多不必要的问题。你可以在调试配置中设置环境变量。设置环境变量的方法如下：
在调试配置界面，找到“Environment variables”字段。点击字段右侧的“...”按钮，打开环境变量设置窗口。添加需要的环境变量及其值，例如 ‘DEBUG=True‘ 或 ‘DATABASE_URL=postgres://user:password@localhost/db‘。保存配置，启动调试。 总结 通过掌握高级调试工具与技巧，你可以更加高效地定位和解决代码中的问题。条件断点、异步调试、数据断点和多线程调试等工具可以帮助你处理复杂的调试场景，而远程调试与调试配置则使得调试远程环境和复杂项目变得更加简单和高效。希望本文能够帮助你更好地利用PyCharm的高级调试功能，提高你的调试效率和代码质量。
下一篇：白骑士的PyCharm教学进阶篇 2.3 测试与自动化​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847c40b73a1e75b7cbb2215104955e3e/" rel="bookmark">
			深入理解SQL中的窗口函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在关系型数据库管理系统（RDBMS）中，SQL的窗口函数（Window Functions）是一种强大的数据分析工具，它能够在不破坏数据行的情况下进行聚合计算和排序操作。本文将深入探讨SQL中窗口函数的基本概念、语法结构以及实际应用场景，帮助读者更好地理解和运用这一高级SQL技术。
一. 窗口函数的基本概念 窗口函数是一种特殊的SQL函数，它能够根据指定的窗口（window）从查询结果集中计算值，而不会改变查询的行数。这些窗口通常与OVER子句一起使用，用于定义窗口的大小和位置。
二. 窗口函数的语法结构 SQL中窗口函数的一般语法结构如下：
sql
SELECT column1, column2, window_function(column3) OVER ( PARTITION BY column4 ORDER BY column5 ROWS/RANGE BETWEEN start AND end ) AS result FROM table_name; 其中，关键要点包括：
window_function：窗口函数的名称，如SUM、AVG、ROW_NUMBER等。PARTITION BY：可选的子句，按照指定列对结果集进行分区，每个分区将单独处理。ORDER BY：可选的子句，指定在分区内部的排序顺序。ROWS/RANGE BETWEEN：可选的子句，定义窗口的范围。 三. 常见的窗口函数 窗口函数在SQL中是非常强大且灵活的工具，能够处理复杂的数据分析需求，以下是一些常见的窗口函数及其具体功能：
ROW_NUMBER()：
功能：为结果集中的每一行分配一个唯一的序号。示例： sql
SELECT product_id, sale_date, sale_amount, ROW_NUMBER() OVER (ORDER BY sale_amount DESC) AS rank FROM sales_table; 应用：常用于排名和分组统计，可以根据指定列进行排序，计算出排名。 RANK()、DENSE_RANK()、NTILE()：
功能： RANK()：计算每个行的排名，如果有并列的值，则排名相同，下一个值跳过。DENSE_RANK()：计算每个行的排名，有并列值时排名相同，下一个值连续递增。NTILE()：将有序的数据划分为n个大小相等的组，并为每个行分配组号。示例： sql
SELECT product_category, sale_date, sale_amount, RANK() OVER (PARTITION BY product_category ORDER BY sale_amount DESC) AS category_rank, NTILE(4) OVER (ORDER BY sale_amount DESC) AS quartile FROM sales_table; 应用：用于分组内的排名和统计分析，快速划分数据组以进行分析。 SUM()、AVG()、MAX()、MIN()：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847c40b73a1e75b7cbb2215104955e3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92853856c84856c6ba10530267ba85d3/" rel="bookmark">
			【MySQL】索引——索引的引入、认识磁盘、磁盘的组成、扇区、磁盘访问、磁盘和MySQL交互、索引的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MySQL1. 索引的引入2. 认识磁盘2.1 磁盘的组成2.2 扇区2.3 磁盘访问 3. 磁盘和MySQL交互4. 索引的概念4.1 索引测试4.2 Page4.3 单页和多页情况 MySQL 1. 索引的引入 海量表在进行普通查询的时候，效率会非常的慢，但是索引可以解决这个问题。
--构建一个8000000条记录的数据 --构建的海量表数据需要有差异性，所以使用存储过程来创建 -- 产生随机字符串 delimiter $$ create function rand_string(n INT) returns varchar(255) begin declare chars_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'; declare return_str varchar(255) default ''; declare i int default 0; while i &lt; n do set return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1)); set i = i + 1; end while; return return_str; end $$ delimiter ; --产生随机数字 delimiter $$ create function rand_num() returns int(5) begin declare i int default 0; set i = floor(10+rand()*500); return i; end $$ delimiter ; --创建存储过程，向雇员表添加海量数据 delimiter $$ create procedure insert_emp(in start int(10),in max_num int(10)) begin declare i int default 0; set autocommit = 0; repeat set i = i + 1; insert into EMP values ((start+i) ,rand_string(6),'SALESMAN',0001,curdate(),2000,400,rand_num()); until i = max_num end repeat; commit; end $$ delimiter ; -- 执行存储过程，添加8000000条记录 call insert_emp(100001, 8000000); 查询员工编号为998877的员工
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92853856c84856c6ba10530267ba85d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778cb5c5b5e7656dbff9fddaa55e2ff8/" rel="bookmark">
			【MySQL进阶篇】管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、系统数据库 MySQL数据库安装完成之后，自带以下四个数据库，具体作用如下：
数据库含义mysql存储MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）information_schema提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等performance_schema为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数sys包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图 2、常用工具 · mysql mysql的客户端工具
#语法：
mysql [options] [database]
选项：
-u,--user=name #指定用户名
-p,--password[=name] #指定密码
-h,--host=name #指定服务器IP或域名
-P,--port=port #指定连接端口
-e,--execute=name #执行SQL语句并退出
-e选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤为方便。
mysql -h192.168.235.129 -P3306 -uroot -p0219423 test -e 'select * from course' · mysqladmin mysqladmin是一个执行管理操作的客户端程序，可以用它来检查服务器的配置和当前状态，创建并删除数据库等。
#通过帮助文档查看选项：
mysqladmin --help where command is a one or more of: (commands may be shortened) create databasename create a new database debug instruct server to write debug information to log drop databasename delete a database and all its tables extended-status gives an extended status message from the server flush-hosts flush all cached hosts flush-logs flush all logs flush-status clear status variables flush-tables flush all tables flush-threads flush the thread cache flush-privileges reload grant tables (same as reload) kill id,id,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/778cb5c5b5e7656dbff9fddaa55e2ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c544d8afa364ca8cef14d5f25a17d2/" rel="bookmark">
			详解高性能中间件Iceoryx在ROS2中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 概述1. 系统架构对比1.1 移除 Master 节点1.2 引入 DDS 系统1.3 跨平台支持 2. DDS 系统的引入2.1 RMW 概述2.2 QoS（质量服务策略）2.3 ROS2去中心化节点注册和订阅 3. ROS2安装与配置3.1 一键安装3.2 官网教程 4. [ROS2 底层切换 Iceoryx 官方实现](https://github.com/ros2/rmw_iceoryx/blob/iron/README.md)4.1 安装4.2 使用 rmw_iceoryx_cpp4.3 零拷贝传输 5. 不同负载下的Iceoryx、cycloneDDS和FastDDS延迟对比5.1 进程间延迟5.2 进程内延迟5.3 对比总结 0. 概述 本文将概述ROS2相比ROS中间件的改进和优势，重点推荐Iceoryx
1. 系统架构对比 1.1 移除 Master 节点 ROS1：依赖 roscore 作为 Master 节点，Master 节点崩溃会导致系统无法订阅和发布。ROS2：不再依赖 roscore，避免了 Master 节点崩溃导致的系统风险。 1.2 引入 DDS 系统 ROS1：使用 TCP/UDP 进行通信，存在延迟、数据丢失和无法加密的问题。ROS2：基于 Data Distribution Service（DDS）的通信架构，提高了网络安全性和实时性。 1.3 跨平台支持 ROS1：跨平台支持较弱。ROS2：提供了更好的跨平台兼容性，支持多种操作系统和硬件架构。 2. DDS 系统的引入 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38c544d8afa364ca8cef14d5f25a17d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382f0e5b05d67ca236d586c6ceda50e0/" rel="bookmark">
			【Web APIs】JavaScript 操作元素 ⑦ ( 多精灵图背景设置 | 核心要点 - 设置 backgroundPosition 属性 | 清除默认样式 | )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、案例需求二、案例核心要点分析1、清除元素的默认内外边距样式 ★ ( 重点 )2、清除 li 元素的默认样式3、ul 和 li 元素的块级元素本质4、为 li 元素设置浮动 ★ ( 重点 )5、精灵图设置要点 ★ ( 重点 ) - 设置 backgroundPosition 属性 三、完整代码示例1、代码示例2、执行效果 一、案例需求 给定一张精灵图 , 如下所示 :
将其设置到 Web 页面中 , 显示如下样式 :
二、案例核心要点分析 1、清除元素的默认内外边距样式 ★ ( 重点 ) HTML 标签元素 都有自己的 默认内边距 和 外边距 样式 , 如下所示 :
&lt;body&gt; 元素 : 默认外边距 常见为 8px 或 16px , 默认内边距 常为 0 ;&lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt; 元素 : 默认的 上边距和下边距可能都在 16px 到 24px 之间 , 内边距 通常为 0 ;&lt;p&gt; 元素 : 默认的上边距和下边距 为 16px 或 1em , 默认内边距 0 ;&lt;ul&gt;, &lt;ol&gt; 元素 : 默认的上边距和下边距 16px 或 1em , 默认的左内边距 40px 或 2em ;&lt;li&gt; 元素 : 默认外边距 0 , 默认的左内边距 20px 或 1em ;&lt;blockquote&gt; 引用块元素 : 上边距和下边距可能都在 16px 到 32px 之间 , 左内边距 为 40px 或 2em ; 本案例中 , 就 使用了 &lt;li&gt; 元素 进行页面结构布局 , 布局时需要使用到 浮动 样式 , 计算换行时 , 每个像素宽高都要精确计算 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/382f0e5b05d67ca236d586c6ceda50e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e640200c7a83a02f9bcea2ce1f70d8/" rel="bookmark">
			MySQL的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MySQL的基本使用什么是SQLSQL学习目标SQL的SELECT语句SQL的INSERT INTO语句 SQL的UPDATE语句SQL的DELETE语句 SQL的WHERE子句可在WHERE子句中使用的运算符SQL的AND和OR运算符SQL的ORDER BY子句SQL的COUNT(*)函数 在项目中操作数据库的步骤安装mysql模块配置mysql模块测试mysql模块能否正常工作查询数据库插入数据插入数据的便捷模式 更新数据更新数据的便捷方式 删除数据标记删除 MySQL的基本使用 什么是SQL SQL是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让我们以编程的形式，操作数据库里面的数据。
三个关键点：
SQL是一门数据库编程语言。使用SQL语言编写出来的代码，叫做SQL语句。SQL语言只能在关系型数据库中使用（例如MySQL、Oracle、SQL　Sever）。非关系型数据库不支持SQL语言。 SQL学习目标 重点掌握如何使用SQL从数据表中：查询数据
（select）、插入数据（insert into）、更新数据（update）、删除数据（delete）
额外需要掌握的4种SQL语法：
where条件、and和or运算符、order by排序、count(*)函数
SQL的SELECT语句 SELECT语句用于从表中查询数据。执行的结果被存储在一个表中（称为结果集）。语法格式如下：
-- 这是注释 -- 从FROM指定的【表中】，查询出【所有的】数据，*表示【所有的】 SELECT * FROM 表名称 -- 从FROM指定的【表中】，查询出指定列名称（字段）的数据 SELECT 列名称 FROM 表名称 注意：SQL语句中的关键字对大小写不敏感。SELECT等效于select。
SQL的INSERT INTO语句 INSERT INTO语句用于向数据表中插入新的数据行，语法格式如下：
-- 语法解读：向指定的表中，插入如下几列数据，列的值通过value一一指定 -- 注意：列和值要一一对应，多个列和多个值之间，使用英文的逗号分隔 SQL的UPDATE语句 Update语句用于修改的数据。语法如下
UPDATE 表名称 SET 列名称 WHERE 列名称 = 某值 -- 修改某行的多个列 UPDATE 表名称 SET 列名称1, 列名称2 WHERE 列名称 = 某值 SQL的DELETE语句 DELETE语句用于删除表中的行。语法如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e640200c7a83a02f9bcea2ce1f70d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a6c2d9af50246ea98a732466dcc78c/" rel="bookmark">
			Visual Studio 和 VSCode 哪个好?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
您好，我是程序员小羊！
前言 想要对Visual Studio 和 VSCode 进行比较，就要充分了解Visual Studio (VS) 和 Visual
Studio Code (VSCode) 各有其优势和适用场景进行分析。Visual Studio (VS) 和 Visual Studio Code (VSCode) 都是由微软开发的流行开发工具，但它们在设计理念、功能特性和使用场景上有明显的差异。
Visual Studio (VS) Visual Studio
是一个功能齐全的集成开发环境（IDE），专为大型复杂项目设计。它支持多种编程语言和平台，包括C#、C++、Python、JavaScript等。VS提供了丰富的工具和功能，如高级调试、代码分析、单元测试、版本控制集成（如Git）、代码重构等。它特别适合开发企业级应用程序、复杂的软件项目以及涉及多个子项目的大型解决方案。VisualStudio 的企业版和专业版提供了更多高级功能，例如性能分析、架构设计工具、数据库工具等，使其成为许多企业开发团队的首选。
Visual Studio Code (VSCode) Visual Studio Code 是一个轻量级的源代码编辑器，设计初衷是提供一个快速、高效、跨平台的编码工具。VSCode 支持 Windows、macOS 和 Linux，并且内置了对多种编程语言的支持，如JavaScript、TypeScript、Python、Go、C++ 等。VSCode 的核心功能包括智能代码补全、语法高亮、内置终端、调试工具、Git集成等。通过丰富的扩展市场，用户可以根据需要添加各种插件，以增强其功能和适应不同的开发需求。VSCode 的轻量级特性和高度可定制化使其成为许多开发者的日常编程工具，尤其是在前端开发、跨平台开发以及需要频繁切换项目的场景中。
比较与选择 项目规模与复杂度： 如果你正在开发一个大型的、复杂的企业级项目，Visual Studio
可能是更好的选择。它提供了更多的高级功能和工具，可以帮助你更高效地管理和开发复杂的软件项目。而对于较小的、单一项目或者需要频繁切换开发环境的场景，VSCode
的轻量级和高效特性更加适合。
资源占用：Visual Studio由于其丰富的功能，往往需要更多的系统资源。对于资源较为有限的计算机，使用VSCode可能会有更好的性能表现。
定制化与扩展性：VSCode 以其高度的可定制化和丰富的扩展市场著称。开发者可以根据自己的需求，通过安装各种插件来增强VSCode的功能。而 Visual Studio 虽然也支持扩展，但在灵活性和插件数量上稍逊于VSCode。
跨平台支持：VSCode 是一个跨平台的编辑器，支持在 Windows、macOS 和 Linux 上运行。而 Visual Studio 的完整功能主要在 Windows 上支持，虽然也有 macOS 版本，但功能上有所限制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a6c2d9af50246ea98a732466dcc78c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8087e28b06849e7cd95b6afe96e3960/" rel="bookmark">
			Java 并发编程：一文了解 synchronized 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 027 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
在当今的多核处理器时代，Java 并发编程变得尤为重要。为了充分利用计算资源，提高程序性能，编写高效、线程安全的并发代码成为每一个 Java 开发者的必修课。在 Java 的并发编程中，synchronized 关键字是最基础也是最常用的工具之一。
synchronized 关键字提供了一种简单且直接的方式来确保代码块或方法在多线程环境下的安全执行。通过对方法或代码块加锁，synchronized 可以防止多个线程同时访问共享资源，从而避免数据不一致的问题。然而，随着应用程序复杂性的增加和对高性能的需求，我们需要对 synchronized 有更深入的理解，以便在实际开发中灵活运用。
本篇文章将全面介绍 synchronized 的使用，从基本语法到锁的内部实现，再到锁的升级机制。无论你是并发编程的新手，还是有一定经验的开发者，这篇文章都将帮助你更好地理解和使用 synchronized，编写出更加高效和健壮的并发程序。
接下来，我们将从 synchronized 的基本概念和语法开始，逐步深入探讨其在 Java 并发编程中的重要角色。
文章目录 1、synchronized 关键字简介2、synchronized 的修饰对象2.1、synchronized 修饰静态方法2.2、synchronized 修饰实例方法2.3、synchronized 修饰代码块 3、对象的内存布局（64位）3.1、Mark Word3.2、Class Pointer3.3、Instance Data3.4、Padding Data 4、Synchronized 锁升级过程4.1、偏向锁4.2、轻量级锁4.3、重量级锁 1、synchronized 关键字简介 在 Java 中，synchronized 关键字用于实现线程之间的同步，以确保多个线程在访问共享资源时不会出现竞态条件。synchronized 可以确保在任何给定时刻，最多只有一个线程可以执行被标记的代码块或方法，从而实现并发安全。
Synchronized 主要有以下三个作用：
原子性（Atomicity）：通过互斥访问同步代码块或同步方法，保证同一时间只有一个线程能够执行这段代码，确保了操作的原子性。例如，两个线程同时执行一个同步方法时，只有一个线程能够获得锁并执行，另一个线程必须等待锁释放；
可见性（Visibility）：保证线程对共享变量的修改对其他线程是可见的。具体来说，synchronized 会通过 Java 内存模型来实现可见性：当一个线程对变量进行 unlock 操作时，这些操作会同步到主内存中；而当线程对变量进行 lock 操作时，会清空工作内存中的变量值，从主内存中重新加载。这保证了其他线程在访问该变量时能够看到最新的值；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8087e28b06849e7cd95b6afe96e3960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c44123edc0f9cddcfbbcd05ee7cf9c/" rel="bookmark">
			【百度面试算法题】2024-08-02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部门项目实际上也涉及到多种语言，有没有意愿去学习其他语言？你是如何利用数据结构来做技术的/项目中是如何解决高并发的？（没听懂问题…就直接开始介绍项目了…后来被打断说不进行发散了，开始问八股）说一下单例模式Redis在项目中的作用（管理验证码过期）说一下进程和线程死锁是什么？怎么避免死锁？TCP三次握手从两副牌中抽取5张牌，判断是否为顺子。A是1，J是10，Q是11，K是12，大小王可以充当赖子，是0（就是给你5个数，其中0可以充当1-12任意一个数，判断是不是顺序的）。
思路：5张牌先按顺序放好，然后从最小的开始看，如果是0，记录赖子的数量+1，如果当前牌和下一张之间缺牌，就用0补充上，最后看赖子的数量如果小于0说明缺牌（当然在遍历中途如果0的数量小于0了，那么就可以直接break，可以用一个bool变量flag实现），大于等于0说明是顺子。
给定一个数组A和一个四位数n，请用A中的元素组合成一个最大的小于n的整数（A中元素可以重复利用）
思路：组合，回溯就可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e475875eb6ad0cd763b4e650134b77a/" rel="bookmark">
			SQL Server数据库自定义分区方案：深入指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server数据库自定义分区方案：深入指南 引言 在大型企业级应用中，数据库的性能和可管理性至关重要。SQL Server提供了强大的数据库分区功能，允许开发者根据特定的业务规则来划分数据，从而优化查询性能和简化数据管理。本文将详细介绍如何在SQL Server中实现数据库的自定义分区方案。
什么是数据库分区？ 数据库分区是一种将大型表或索引水平分割成多个更小、更易于管理的部分的技术。每个部分称为一个分区。分区可以基于不同的策略，例如范围分区、列表分区或哈希分区。
为什么需要自定义分区方案？ 自定义分区方案可以帮助：
提高查询性能：通过将数据分散到多个分区，可以减少查询需要扫描的数据量。简化数据管理：例如，可以快速地添加或删除分区来管理数据的生命周期。实现数据的地理分布：根据地理位置对数据进行分区，以满足法规要求或优化访问速度。 实现自定义分区方案的步骤 步骤1：确定分区键 选择一个或多个列作为分区键，这些列的值将决定数据如何被分区。通常选择具有高基数（即不同值的数量多）的列。
步骤2：创建分区方案 使用CREATE PARTITION SCHEME语句来定义分区方案。
CREATE PARTITION SCHEME MyRangePS AS PARTITION MyRangeP1 TO (filegroup1, filegroup2, filegroup3); 步骤3：创建分区函数 使用CREATE PARTITION FUNCTION语句来定义分区函数，该函数将数据值映射到分区方案。
CREATE PARTITION FUNCTION MyRangePF (int) AS RANGE LEFT FOR VALUES (1, 100, 1000); 步骤4：创建分区表或索引 使用CREATE TABLE或CREATE INDEX语句，并指定分区方案。
CREATE TABLE MyPartitionedTable ( ID int NOT NULL, Data varchar(100) ) ON MyRangePS (ID); 步骤5：管理分区 添加分区：使用ALTER PARTITION SCHEME添加新的文件组和分区。切换分区：使用ALTER TABLE SPLIT PARTITION或SWITCH来重新分配数据。 ALTER PARTITION SCHEME MyRangePS NEXT USED filegroup4; 步骤6：查询优化 利用分区视图sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e475875eb6ad0cd763b4e650134b77a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e366f5ead275f5d39a44524cd379db01/" rel="bookmark">
			【Java】深度解析Java的反射机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反射（Reflection） 一、 反射的基本概念二、 获取类的信息三、 获取类的成员四、 动态创建对象五、 动态调用方法六、 动态访问和修改字段 总结 一、 反射的基本概念 反射是一种运行时机制，允许程序在运行时检查和操作类、方法、字段等。通过反射，你可以：
获取类的详细信息（类名、修饰符、父类、接口等）。获取类的方法、构造函数、字段等。动态调用方法或构造函数。动态访问和修改字段的值。 二、 获取类的信息 获取 Class 对象
有多种方法可以获取一个类的 Class 对象：
Class.forName(String className): 通过类的完全限定名获取 Class 对象。
ClassName.class: 通过类的字面常量获取 Class 对象。
object.getClass(): 通过对象实例获取 Class 对象。
// 获取 Class 对象的三种方式 Class&lt;?&gt; clazz1 = Class.forName("java.util.ArrayList"); Class&lt;?&gt; clazz2 = ArrayList.class; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Class&lt;?&gt; clazz3 = list.getClass(); 三、 获取类的成员 getDeclaredFields()： 获取类的所有字段（包括私有字段）。
getDeclaredMethods()： 获取类的所有方法（包括私有方法）。
getDeclaredConstructors()： 获取类的所有构造函数。
getField(String name)： 获取类的指定字段（不包括私有字段）。
getMethod(String name, Class&lt;?&gt;… parameterTypes)： 获取类的指定方法（不包括私有方法）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e366f5ead275f5d39a44524cd379db01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b69c8399a7d0af574873e9c081e4358/" rel="bookmark">
			Java 并发编程：volatile 关键字介绍与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 026 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
在现代多线程编程中，确保数据的一致性和正确性是至关重要的。Java 作为一种广泛使用的编程语言，为多线程编程提供了丰富的工具和机制，其中 volatile 关键字是一个关键的概念。volatile 关键字在 Java 中被用来修饰变量，以确保它们在多线程环境下的可见性和有序性，但它并不保证操作的原子性。
理解 volatile 的工作原理及其应用场景，对于编写高效和可靠的多线程程序至关重要。在本文中，我们将深入探讨 volatile 关键字的核心特性，解释它如何确保变量的可见性和有序性，以及它在解决多线程问题中的局限性。我们还将通过示例展示如何在实际编程中使用 volatile，以及如何通过其他同步机制来弥补 volatile 的不足。
通过对 volatile 的详细分析，我们希望读者能够更好地理解在多线程环境中变量访问的复杂性，并掌握在实际开发中如何正确使用 volatile 关键字，以编写出更加健壮和高效的并发程序。
文章目录 1、volatile 关键字简介2、volatile 保证可见性2.1、什么是可见性问题2.2、volatile 如何保证可见性 3、volatile 保证有序性3.1、什么是指令重排序3.2、volatile 如何保证有序性 4、volatile 不保证原子性的详细介绍4.1、什么是原子性问题4.2、volatile 的局限性4.3、解决方法 1、volatile 关键字简介 volatile 关键字在 Java 中用于修饰变量，使其具有可见性和有序性。
可见性：在多线程环境下，当一个线程修改了 volatile 变量的值，新值对于其他线程是立即可见的。通常情况下，线程之间对变量的读写操作是不可见的，这意味着一个线程修改了变量的值，另一个线程可能看不到这个修改，仍然使用旧值。使用 volatile 关键字可以确保所有线程看到的是变量的最新值；有序性：volatile 关键字还可以防止指令重排序优化。编译器和处理器通常会对指令进行重排序，以提高性能，但这种重排序可能会破坏多线程程序的正确性。volatile 变量的读写操作不会被重排序，也不会与前后的读写操作发生重排序。 需要注意的是 volatile 仅能保证可见性和有序性，不能保证原子性。例如，volatile int count 的递增操作 count++ 仍然不是线程安全的，因为它包含了读和写两个操作，可能会被其他线程打断。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b69c8399a7d0af574873e9c081e4358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de90057d5b6fb5d7ff241e6213407e6/" rel="bookmark">
			SQL Server中的CTE魔法：解锁公用表表达式的强大力量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server中的CTE魔法：解锁公用表表达式的强大力量 在SQL Server的数据处理中，公用表表达式（Common Table Expressions，简称CTE）是一种强大的工具，它允许开发者在查询中定义临时的结果集，这些结果集可以在一个或多个SELECT、INSERT、UPDATE或DELETE语句中被引用。本文将深入探讨如何在SQL Server中使用CTE，并通过代码示例展示其灵活性和强大功能。
1. CTE的基本概念 CTE提供了一种定义临时结果集的方法，这些结果集可以是简单的数据集，也可以是复杂的多步骤计算。
2. CTE的基本语法 CTE的基本语法如下：
WITH CTE_Name (Column1, Column2, ...) AS ( -- CTE查询定义 SELECT Column1, Column2, ... FROM SomeTable WHERE SomeCondition ) -- 使用CTE的查询 SELECT * FROM CTE_Name; 3. 使用CTE进行数据过滤 CTE可以用于数据过滤，创建复杂的过滤逻辑。
WITH FilteredData (EmployeeID, DepartmentID) AS ( SELECT EmployeeID, DepartmentID FROM Employees WHERE DepartmentID IN (1, 2, 5) ) SELECT * FROM FilteredData; 4. CTE在数据聚合中的应用 CTE也可以用于数据聚合，简化复杂的GROUP BY查询。
WITH DepartmentTotals (DepartmentID, TotalSales) AS ( SELECT DepartmentID, SUM(SalesAmount) FROM Sales GROUP BY DepartmentID ) SELECT DepartmentID, TotalSales FROM DepartmentTotals ORDER BY TotalSales DESC; 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de90057d5b6fb5d7ff241e6213407e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb423d12ad31b122d44788e18925d53d/" rel="bookmark">
			断电引起redo和数据文件不一致故障恢复---惜分飞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些时候故障总是来的让人非常意外,这个在准备停机迁移数据库之前的几分钟由于某种原因直接导致主机掉电,再次开机数据库无法启动
Sat Aug 03 23:10:37 2024
Successful mount of redo thread 1, with mount id 3696805928
Database mounted in Exclusive Mode
Lost write protection disabled
Completed: alter database mount
Sat Aug 03 23:10:43 2024
alter database open
Errors in file D:\APP\ADMINISTRATOR\diag\rdbms\xff\xff\trace\xff_ora_6808.trc:
ORA-01113: 文件 21 需要介质恢复
ORA-01110: 数据文件 21: 'D:\APP\ADMINISTRATOR\ORADATA\XFF\XIFENFEI.DBF'
ORA-1113 signalled during: alter database open...
尝试数据库恢复各种报错ORA-600 kdourp_inorder2,ORA-600 3020,ORA-7445 kdxlin等
ALTER DATABASE RECOVER CONTINUE DEFAULT Media Recovery Log D:\APP\ADMINISTRATOR\FAST_RECOVERY_AREA\XFF\ARCHIVELOG\2024_08_03\O1_MF_1_1159998_MBW605HP_.ARC
ORA-279 signalled during: ALTER DATABASE RECOVER CONTINUE DEFAULT .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb423d12ad31b122d44788e18925d53d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772e4bcd5c261b16ef37125d06d9186a/" rel="bookmark">
			启航前的风浪：在PyCharm中化解IDE启动错误的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启航前的风浪：在PyCharm中化解IDE启动错误的策略 PyCharm，作为开发者的得力助手，其启动错误可能会阻碍我们的开发进程。本文将深入探讨如何在PyCharm中解决IDE启动时出现的错误，确保你的开发环境能够顺畅运行。
1. PyCharm启动错误的常见类型 启动错误可能包括配置问题、插件冲突、系统兼容性问题等。
2. 诊断启动错误 首先，需要诊断启动错误的原因。
查看错误日志：PyCharm的日志文件通常包含有关启动错误的详细信息。使用命令行启动：通过命令行启动PyCharm，可以查看更多错误信息。 3. 检查JDK配置 PyCharm需要正确配置的JDK（Java Development Kit）。
检查JDK路径：确保PyCharm使用的JDK路径正确无误。 # 检查PyCharm使用的JDK路径 java -version 4. 检查PyCharm配置文件 配置文件损坏或不兼容可能导致启动错误。
重置PyCharm配置：删除或重命名PyCharm的配置文件夹（如.PyCharm&lt;version&gt;），然后重新启动PyCharm。 5. 禁用或更新插件 插件问题可能导致PyCharm启动失败。
禁用所有插件：通过命令行使用-no-plugin选项启动PyCharm，禁用所有插件。更新插件：确保所有插件都是最新版本。 6. 检查系统兼容性 确保PyCharm版本与操作系统兼容。
更新PyCharm：使用与你的操作系统兼容的最新版本的PyCharm。 7. 检查内存和CPU资源 资源不足可能导致PyCharm启动失败。
增加内存分配：调整PyCharm的内存分配参数（如-Xmx和-Xms）。 8. 使用自定义启动脚本 创建自定义启动脚本，设置合适的启动参数。
# Linux/Mac启动脚本示例 idea.sh -no-plugin=org.jetbrains.plugins.github :: Windows启动脚本示例 idea.bat -no-plugin=org.jetbrains.plugins.github 9. 联系技术支持 如果以上方法都无法解决问题，联系JetBrains技术支持。
提交问题报告：在JetBrains官方网站提交问题报告，并提供错误日志。 10. 结论 PyCharm启动错误虽然令人困扰，但通过一系列诊断和解决步骤，可以找到并解决问题。通过本文的详细介绍，你应该已经掌握了如何在PyCharm中解决IDE启动时出现错误的策略。
无论是检查JDK配置、重置PyCharm配置、禁用或更新插件、检查系统兼容性、增加内存分配，还是联系技术支持，这些方法都能帮助你恢复PyCharm的顺畅运行。
通过本文的深入分析和实践指导，我们不仅理解了启动错误的原因，还学会了如何一步步解决这一问题。现在，你可以自信地在PyCharm中进行高效的开发工作，享受稳定可靠的开发体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b98c28ce1587912ca78b2a934776cc/" rel="bookmark">
			【C&#43;&#43;深度探索】AVL树的底层实现机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：大耳朵土土垚 🔥 所属专栏：C++从入门至进阶 这里将会不定期更新有关C/C++的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 前言 AVL树就是在二叉搜索树的基础上引入了平衡因子，因此AVL树也可以看成是二叉搜索树.一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：它的左右子树都是AVL树，左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1).接下来我们继续学习AVL树底层实现的部分机制.
文章目录 前言1.AVL树结构2.AVL树的插入✨左单旋✨右单旋✨右左双旋✨左右双旋 3.中序遍历4. AVL树的验证5.验证用例6.结语 1.AVL树结构 //AVL树节点类 template&lt;class K, class V&gt; struct AVLTreeNode { pair&lt;K, V&gt; _kv; AVLTreeNode&lt;K, V&gt;* _pLeft; AVLTreeNode&lt;K, V&gt;* _pRight; AVLTreeNode&lt;K, V&gt;* _pParent; int _bf; // balance factor AVLTreeNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) , _pLeft(nullptr) , _pRight(nullptr) , _pParent(nullptr) , _bf(0) {} }; // AVL: 二叉搜索树 + 平衡因子的限制 template&lt;class K,class V&gt; class AVLTree { typedef AVLTreeNode&lt;K,V&gt; Node; public: AVLTree() : _pRoot(nullptr) {} // 在AVL树中插入值为kv的节点 bool Insert(const pair&lt;K, V&gt;&amp; kv); //中序遍历 void InOrder() { _InOrder(_pRoot); } //判断是否是平衡树 bool IsBalanceTree() { //嵌套一层函数 return _IsBalanceTree(_pRoot); } private: bool _IsBalanceTree(Node* pRoot); int _Height(Node* pRoot); void _InOrder(Node* root); // 右单旋 void RotateR(Node* parent); // 左单旋 void RotateL(Node* parent); // 右左双旋 void RotateRL(Node* parent); // 左右双旋 void RotateLR(Node* parent) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b98c28ce1587912ca78b2a934776cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147d70d7a5d48a7c99631745fea488ea/" rel="bookmark">
			Flink学习之Flink SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink SQL 1、SQL客户端 1.1 基本使用 启动yarn-session
yarn-session.sh -d 启动Flink SQL客户端
sql-client.sh --退出客户端 exit; 测试
重启SQL客户端之后，需要重新建表
-- 构建Kafka Source -- 无界流 drop table if exists students_kafka_source; CREATE TABLE if not exists students_kafka_source ( `id` BIGINT, `name` STRING, `age` INT, `gender` STRING, `clazz` STRING ) WITH ( 'connector' = 'kafka', 'topic' = 'students1000', 'properties.bootstrap.servers' = 'master:9092', 'properties.group.id' = 'grp1', 'scan.startup.mode' = 'earliest-offset', 'format' = 'csv', -- 以 ，分隔的数据 -- 是否忽略脏数据 'csv.ignore-parse-errors' = 'true' ); -- 执行查询，基于KafkaSource是无界流，所以查询时连续变化的 select * from students_kafka_source; select clazz,count(*) as cnt from students_kafka_source group by clazz; -- 向Kafka生产数据 kafka-console-producer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/147d70d7a5d48a7c99631745fea488ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f29a0fdfb09eae4c6ab2f8dd9f4e34/" rel="bookmark">
			【AI大模型】Prompt 提示词工程使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、Prompt 提示词工程介绍
2.1 Prompt提示词工程是什么
2.1.1 Prompt 构成要素
2.2 Prompt 提示词工程有什么作用
2.2.1 Prompt 提示词工程使用场景
2.3 为什么要学习Prompt 提示词工程
三、Prompt 提示词工程元素构成与操作实践
3.1 前置准备
3.2 Prompt 基本结构介绍与使用
3.2.1 明确指令
3.2.2 提供必要的原始内容
3.2.3 提供背景参考
四、Prompt 提示词工程编写原则与操作实践
4.1 Prompt 提示词工程编写的几个原则
4.2 Prompt 提示词编写中常用的分隔符
4.2.1 冒号
4.2.2 空格
4.2.3 箭头 (-&gt;)
4.2.4 竖线 (|)
4.2.5 逗号 (,)
4.2.6 横线 (-)
4.2.7 小括号 (())
4.2.8 大括号 ({})
4.2.9 方括号 ([])
4.2.10 等号 (=)
4.2.11 特殊字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f29a0fdfb09eae4c6ab2f8dd9f4e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c61aa62af001b9232c8af3d0eafc62/" rel="bookmark">
			c&#43;&#43;----内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		okk，大家好。我们大家学习了鄙人的前面前面几篇博客，并且还稍微使用了一些c++的基础知识。并且我们前面都说过，我们前面学习的知识都说过。我们前面的几篇博客都是我们以后使用c++基础。但是我们大家都知道现在代码都关注什么时间啊，内存啊。我们前面对于c++的时间，我们可以依据以前c的知识。我们前面说过时间复杂度嘛，就是计算基本算法的次数。这个在哪都可以通用。但是我们c++的内存管理却稍微有一点不同。比我们c讲的更加细致且深奥。哈哈。可能说的有点夸张了。但是我们已经引出了我们今天要讲的主题。内存管理了。
内存分布 大家应该还记得我们以前c学习的内存的内部吧。当时我们说c内存的时候就说了个栈区，堆区，静态区。然后就是这三个去分别存放临时变量，创建是数据和全局变量。
我们前面刚刚说过我们的c++内存是要复杂一些。我们c++的内存分布
大家可以看看上面的图片，我们可以看到我们对于内存的分布多了很多。除了我们在c中就见过的堆，栈，静态区以外。我们还写了一个明显的叫做：内存映射段。这个大家对这个应该很陌生吧。什么叫做内存映射段，起什么作用啊。
mmap是一种内存映射的方法，这一功能可以用在文件的处理上，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。在编程时可以使某个磁盘文件的内容看起来像是内存中的一个数组。如果文件由记录组成，而这些记录又能够用结构体来描述的话，可以通过访问结构数组来更新文件的内容。
实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如图所示：
进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。
内核为系统中的每个进程维护一个单独的任务结构（task_struct）。任务结构中的元素包含或者指向内核运行该进程所需的所有信息(PID、指向用户栈的指针、可执行目标文件的名字、程序计数器等)。Linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问。
反正这里是给大家稍微简绍一下。这个后面大家对知识有更多的了解之后，自然会学习更多的。这里我们就稍微给大家说明一下，大家有个了解：
1.栈 又叫堆栈 -- 非静态局部变量 / 函数参数 / 返回值等等，栈是向下增长的。 2. 内存映射段 是高效的 I/O 映射方式，用于装载一个共享的动态内存库。用户可使用系统接口 创建共享共享内存，做进程间通信。（ Linux 课程如果没学到这块，现在只需要了解一下） 3. 堆 用于程序运行时动态内存分配，堆是可以上增长的。 4. 数据段 -- 存储全局数据和静态数据。 5. 代码段 -- 可执行的代码 / 只读常量 注释：通常来说，我们创建的局部变量和函数中的参数就是放在栈中。而我们之前动态开辟的内存，其实就是开辟在了堆区中。而全局变量以及通过我们 static 设置为静态的数据都会放在数据段。
new 和 delete 大家对我们在c学习的动态内存开辟的几个关键词还记得吧。就是malloc/calloc/realloc/freed
这些知识对本篇博客是没有太多影响，但是如果我们大家如果想温习一下的话大家可以点击下面的链接：C语言----动态内存-CSDN博客。但是我们也说过了这些暂时对我们这篇博客没什么影响。我们今天讲的是这些的升级版。不仅使用方便而且更简洁。那么我们就废话少说先看看如何使用吧：
我们这里先是申请了4个字节就是int嘛。虽然我们并没有初始化。 但是我们可以明显的看到我们这里c++申请空间比我们在c中申请要简单很多吧，如我们的malloc： (int*)malloc(5*sizeof(int));
我们可以明显的看到如果我还是使用以前的方法的话就有点太牢了。
我们在c++中使用new很简单。就是前面写出申请空间的类型然后加上*和名字。后就是=加new和空间大小了。。正如我们图片上的第一个例子。我们简单的申请了一个int类型的空间。并且没有初始化。乍一看。我们都知道使用new会比我们使用malloc简单很多。然后就是申请的时候可以初始化。这个也是我们malloc没有的吧。我们图片中的第二个例子就是我们初始化我们如果初始化的话只需要在我们简单申请空间的结尾后加一个（）。然后在里面写出我们要初始化的内容即可。当然了我们上面写了三个例子。第三个例子就是我们的申请多个空间。我们只需要在第一种例子的基础上再最后加[]，然后再里面写出我们申请多少就可以了。但是对于这种多个空间初始化的话就不能像我们第二个例子那样加一个（）那样。要更特殊一些。加的是{}。在里面写我们要初始化内容。
我想大家应该差不多了解了new的使用方法了吧。并且我们知道我们动态内存开辟了的就应该释放吧。我们前面c中的释放是用free。但是我想大家应该也看到上面的图片我们申请的空间都是用的delete。效果与我们前面学的free差不多。都是释放空间的。用法稍有差异。我们前面的free是在后面加个（），括号里面写名字。然后下一行将空间置为null。不然的话可能导致栈溢出的风险。但是我们的delete却好很多。普通的空间我们只需要在其后面加上名字即可，不需要再置为null。但稍微有一点瑕疵就是在释放多数组空间的时候需要在名字前面加一个[]，虽括号中可不写数组个数。只是我们大多时可能忘却。然大家需谨记切莫忘却了。
上面给大家看的都是new和delete的基本使用方法，我相信大家都会很少使用的，更多的时候都是处理自己的事情，我们咧，下面我们是来举一些我们自定义的例子并且引出更多关于new和delete的相关知识：首先我们是来实时对比一下new与malloc申请自定义内存的区别：
我们可以看到我们这里前面写的都是一样的，区别在后面，我们malloc需确定类型后再确定空间大小，方可申请，但new却可直接申请，这便可看出new的方便之处。随之而来的便是我们释放空间。我们可以看到释放空间与前面的手法无异。很简单。并且对于内在类型也是一样的： 这个大家简单看一下如何使用就可以了，也不用很着急的。基本用法就是上面的这些，但是我们还是不能忘记申请了空间需要释放空间这一做法。
最后关于new和delete的一个知识点就是，这两个关键词使用了都会自动调用构造函数和析构函数。这就是与malloc的最大区别。也是创建出new和delete的初衷。 最后就是new/delete 和 malloc/free最大区别是 new/delete对于【自定义类型】除了开空间还会调用构造函数和析构函数。
operator new与operator delete函数 new和delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是 系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1c61aa62af001b9232c8af3d0eafc62/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/81/">«</a>
	<span class="pagination__item pagination__item--current">82/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/83/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>