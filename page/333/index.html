<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff58769a190b9ffc7628a28ef1a66c9/" rel="bookmark">
			【哈希】闭散列的线性探测和开散列的哈希桶解决哈希冲突（C&#43;&#43;两种方法模拟实现哈希表）（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉博主首页： 有趣的中国人 🎉专栏首页： C++进阶 🎉其它专栏： C++初阶 | Linux | 初阶数据结构 小伙伴们大家好，本片文章将会讲解 哈希函数与哈希 之 哈希桶解决哈希冲突 的相关内容。
如果看到最后您觉得这篇文章写得不错，有所收获，麻烦点赞👍、收藏🌟、留下评论📝。您的支持是我最大的动力，让我们一起努力，共同成长！
🎉系列文章： 1. 闭散列的线性探测实现哈希表
文章目录 `0. 前言``1. 何为开散列`==&lt;font color = blue&gt;&lt;b&gt;🎧1.1 开散列的概念🎧====&lt;font color = blue&gt;&lt;b&gt;🎧1.2 开散列哈希表图示🎧== `2. 开散列哈希表的实现`==&lt;font color = blue&gt;&lt;b&gt;🎧2.1 开散列哈希表的结构🎧====&lt;font color = blue&gt;&lt;b&gt;🎧2.2 哈希桶插入Insert🎧====&lt;font color = blue&gt;&lt;b&gt;🎧2.3 哈希桶查找Find🎧====&lt;font color = blue&gt;&lt;b&gt;🎧2.4 哈希桶删除Erase🎧== `3. 字符串哈希与仿函数``4.哈希桶实现哈希表完整代码` 0. 前言 在上一篇文章中我们详细描述了如何用 开放寻址法（闭散列）的线性探测 的方法来实现哈希表。此篇文章我们将用 开散列的哈希桶 来实现哈希表。
1. 何为开散列 🎧1.1 开散列的概念🎧 开散列法又叫链地址法(开链法)，首先对关键码集合用 散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。
🎧1.2 开散列哈希表图示🎧 插入元素44
从上图可以看出，开散列中每个桶中放的都是发生哈希冲突的元素。
2. 开散列哈希表的实现 🎧2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff58769a190b9ffc7628a28ef1a66c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ab985dbb6468ba045b428b38cfacf7/" rel="bookmark">
			新版IDEA没有办法选择Java8版本解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年11月27日后，spring.io 默认不再支持创建jdk1.8的项目
解决方法就是把 Spring的Server URL 改为阿里的。
阿里的Server URL https://start.aliyun.com/
默认的Server URL
https://start.spring.io
阿里的Server URL https://start.aliyun.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfa268afe7f36090e1ce31d4d8e70c9/" rel="bookmark">
			python爬虫爬取微博评论--完整版(超详细，大学生不骗大学生)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、找到页面
二、学会使用检查元素
2.1 打开检查元素界面
2.2 找到所有评论所在的位置
2.2.1 搜索评论
2.2.2 找到data表
三、基础部分代码实现 四、格式化输出
4.1 了解存储格式
4.2 单独取出内容
4.3 取出所有评论内容
4.4 格式化读取信息
五、导出成表格形式
六、了解分页
6.1 查看分页
6.2 寻找分页的规律
七、多页实现 八、完整代码
九、大多数报错原因
一、找到页面 首先你需要找到一个你想要爬取的页面
（这里我是随机找的一个微博帖子）
它的评论内容是这样的
然后我们今天的内容就是从这个页面的评论里面提取我们想要的
（其实学会了之后不只可以爬取评论的内容喔！！）
二、学会使用检查元素 2.1 打开检查元素界面 在你打开的页面-&gt;单机右键-&gt;检查元素(或者是审查元素)，然后我们就可以看到这个界面
这里你的上面一行表头可能会是英文嘟没关系(我会把英文界面该点的标在括号里)
我们主要用的是网络（network）这部分 点击网络（network） 如果点击小放大镜后界面和我这个差不多那就大概率是对的 如果你没有这小放大镜可以换个浏览器
(我目前用下来，苹果自带的Safari浏览器是不行的，我用的这个例子里是360浏览器，是OK嘟，大家可以参考一下)
2.2 找到所有评论所在的位置 2.2.1 搜索评论 这里我们在搜索的界面输入我们这个帖子里面随便一条评论的内容，点击搜索 如果你在这里黏贴了评论的内容但是，显示搜索不到结果你可以试一试
不关闭检查元素的界面-&gt;退出当前网页或者你随机点一个人的主页-&gt;再回到评论界面-&gt;搜索评论内容就会出现了！
2.2.2 找到data表 下一步我们 点击搜索出的结果
显示的界面是这样的
然后我们点击这个预览(preview)
再说一次喔，有可能大家的检查元素打开的是全英文的，但是没关系我会把英文该点的标在括号里
（后面的大部分操作都是在这个预览界面的） 点击data旁边的小三角，展开data
展现的结果是这样的 然后这个里面的0-19，就是0-19条评论的数据，包括一些评论内容，评论人的ID，评论被点赞的数量等等，我们一会要爬取的数据就是从这里来的
三、基础部分代码实现 首先我们要知道想要爬取一个网站的数据我们首先需要访问网站
我们的代码需要通过网站的url来找到网站
下面我们先将爬取网站的基础格式写出来
#requets是一个爬虫的第三方库，需要单独安装 import requests #url是一访问网站的地址(这个不是很了解，但是我们代码是需要通过url来找到你要爬取的网页) url = '' #1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdfa268afe7f36090e1ce31d4d8e70c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516438853795a5c04975d3c430a6192c/" rel="bookmark">
			前端canvas实现图片涂鸦(Vue2、Vue3都支持)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一下效果图吧
Gitee地址
代码组成：画笔大小、颜色、工具按钮都是组件，通俗易懂，可以按照自己的需求调整。
主要代码App.vue &lt;template&gt; &lt;div class="page"&gt; &lt;div class="main"&gt; &lt;div id="canvas_panel"&gt; &lt;canvas id="canvas" :style="{ backgroundImage: `url(${backgroundImage})`, backgroundSize: 'cover', backgroundPosition: 'center' }"&gt;当前浏览器不支持canvas。&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;BrushSize :size="brushSize" @change-size="onChangeSize" /&gt; &lt;ColorPicker :color="brushColor" @change-color="onChangeColor" /&gt; &lt;ToolBtns :tool="brushTool" @change-tool="onChangeTool" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, onMounted } from 'vue'; import BrushSize from './components/BrushSize.vue'; import ColorPicker from './components/ColorPicker.vue'; import ToolBtns from './components/ToolBtns.vue'; let canvas = null; let context = null; let painting = false; const historyData = []; // 存储历史数据，用于撤销 const brushSize = ref(5); // 笔刷大小 const brushColor = ref('#000000'); // 笔刷颜色 const brushTool = ref('brush'); // canvas相对于（0, 0）的偏移，用于计算鼠标相对于canvas的坐标 const canvasOffset = { left: 0, top: 0, }; const backgroundImage = ref('https://t7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516438853795a5c04975d3c430a6192c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5cf568d1a2e8f12a605bdef9762084/" rel="bookmark">
			人工智能和大模型的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 人工智能（AI）和大模型是两个相关但有区别的概念。理解它们之间的区别有助于更好地掌握现代科技的发展动态。
人工智能（AI） 人工智能（Artificial Intelligence, AI）是一个广义的概念，指的是通过计算机模拟人类智能的技术和方法。AI的目标是让计算机能够执行通常需要人类智能才能完成的任务。这些任务包括但不限于：
自然语言处理：理解和生成人类语言。计算机视觉：分析和理解图像和视频。语音识别：识别和处理人类的语音。机器人技术：自动化控制和操作物理设备。推荐系统：根据用户的行为和偏好提供个性化推荐。 大模型 大模型（Large Model）通常指的是大型的深度学习模型，特别是那些在大量数据上进行训练，具有数十亿到数千亿参数的模型。大模型是现代AI发展的一个重要成果，特别在自然语言处理（NLP）和生成式AI领域。典型的大模型包括：
GPT系列（如ChatGPT）：生成文本的语言模型，可以执行对话、翻译、写作等任务。BERT：用于自然语言理解的模型，在句子分类和问答系统中表现出色。DALL-E：可以根据文本描述生成图像的模型。CLIP：同时处理图像和文本的多模态模型。 大模型的特点包括：
规模庞大：参数数量巨大，通常需要大规模的计算资源和数据进行训练。通用性强：经过大规模数据训练后，可以应用于多种任务，具有很好的迁移学习能力。复杂性高：模型结构复杂，通常基于深度神经网络（如Transformer架构）。 区别 概念范围：
人工智能是一个广义概念，涵盖所有通过计算机实现智能行为的技术和方法。大模型是人工智能中的一个具体技术，指的是基于大量参数和数据训练的大型深度学习模型。 应用范围：
人工智能应用广泛，包括传统的机器学习方法（如决策树、支持向量机）以及现代的深度学习方法。大模型主要在自然语言处理、图像生成、语音识别等领域表现突出，特别是需要处理大规模数据的任务。 技术实现：
人工智能可以通过多种方法实现，包括基于规则的系统、统计学习方法、神经网络等。大模型通常指的是深度学习模型，尤其是基于Transformer等先进架构的大规模神经网络。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af624e7fb91b85bbdce9006799c9ca40/" rel="bookmark">
			idea&#43;tomcat&#43;mysql 从零开始部署Javaweb项目（保姆级别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 新建一个项目添加web支持配置tomcat优化tomcat的部署运行tomcatidea数据库连接java连接数据库 新建一个项目 new project；Java；选择jdk的版本；next；next；填写项目名字，选择保存的路径；Finish； 对于新建好的项目，第一个是项目的名称，.iml是项目的标识文件，标识一个独立的项目；
添加web支持 点击项目的名称，右键；Add Frameworks Support；web application；ok； 此时项目下多了一个web的目录，这是整个web项目的根目录。
整个项目结构如下：
test表示项目的名称；src用来存储代码；web是web项目的根目录，其中包含一个WEB-INF和index.jsp，其中index.jsp是项目启动后默认的进入的页面；test.iml是整个项目的标识文件。 配置tomcat 前提是成功下载好tomcat
add configuration；
+号；
选择tomcat server 下的local。
configure，选择tomcat下载的路径；
选择jdk依赖，一般默认就好；
fix——&gt;ok。
最后点击ok就成功部署tomcat了。
优化tomcat的部署 【还是tomcat的配置中】更新的操作可以选择update classes and resources，这样就不需要代码有更新的时候一直都重启，重启太慢，只需要刷新就好。
点击file；选择project structure；modules；dependencies；+号；library；选择tomcat的依赖包；add selected ——&gt;ok； 添加tomcat的依赖包，避免有的时候导包报错。
运行tomcat 点下面的标识就可以。
运行成功后会显示以下页面。
这里有一个需要注意的点就是网页启动后的的路径，我这里是http://localhost:8080/test_war_exploded/和我的tomcat的配置是对应的，比如端口号8080，以及在配置tomcat的fix之后添加的也是test_war_exploded，一句话就是要对应。
如果以上配置都正确的话，修改index.jsp并且保存后，点击绿色的标识，再刷新网页就可以得到修改后的内容
idea数据库连接 首先下载好mysql。
view;tool windows;database。 4. 侧边栏显示database标识，点击标识；
5. +号；
6. 选择自己的数据库；
7. 填写数据库的账号和密码；
8. 点击test connection。
显示successed表示成功。
点击+号；query console，调出控制台；编写相应的sql语句；点击绿色小标运行，即可在输出界面看到对应的运行结果。 按照上面的方法，快速建立好数据库，这里是新建了一个studentinfomanagement的数据库。
java连接数据库 编辑一个类似下面的代码，把自己的数据库账号，密码以及数据库的名称都更换成自己的。 package utils; import java.sql.DriverManager; import java.sql.SQLException; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af624e7fb91b85bbdce9006799c9ca40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b377c056032bea17ed31b86440211e/" rel="bookmark">
			【AI大模型】如何让大模型变得更聪明？基于时代背景的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【AI大模型】如何让大模型变得更聪明 前言 在以前，AI和大模型实际上界限较为清晰。但是随着人工智能技术的不断发展，基于大规模预训练模型的应用在基于AI人工智能的技术支持和帮助上，多个领域展现出了前所未有的能力。无论是自然语言处理、计算机视觉，还是语音识别，甚至是自动驾驶，AI模型的性能都取得了显著进步。然而，尽管大模型已经表现出令人惊叹的能力，它们在理解力、泛化能力和适应性等方面仍然面临挑战。有时候依旧还是会出现指鹿为马、画蛇添足、罢工不干的失误性行为。**那么在这个AI大时代，怎么才能让大模型变得更聪明呢？**本文将会给各位进行具体的介绍。
文章目录 【AI大模型】如何让大模型变得更聪明前言一、大模型的现状与挑战1.1 理解力的局限1.2 泛化能力的不足1.3 适应性的挑战 二、怎么让大模型变聪明呢？2.1 增强数据多样性和质量2.1.1 数据增强技术2.1.2 高质量数据集的构建 2.2 模型结构优化2.2.1 多任务学习2.2.2 模型架构创新 2.3 强化学习与自适应学习2.3.1 强化学习（Reinforcement Learning, RL）2.3.2 自适应学习（Adaptive Learning） 2.4 融合外部知识和常识推理2.4.1 知识图谱（Knowledge Graphs） 2.5 模型压缩与高效推理2.5.1 模型蒸馏（Model Distillation）2.5.2 量化（Quantization） 三、展望未来的大模型学习 一、大模型的现状与挑战 首先，我们需要知道大模型“不够聪明”的原因。
1.1 理解力的局限 大模型在特定任务上表现优异，但它们对于复杂问题和原理性问题的解答仍然有着理解力和想象力的局限。对于复杂的多轮对话，模型往往难以保持上下文一致性，容易出现语义理解偏差；而对于较为深层次的原理性问题，它可能会出现胡言乱语，也就是说大模型生成的内容在表面上看起来是合理的、有逻辑的，甚至可能与真实信息交织在一起， 但实际上却存在错误的内容、引用来源或陈述。这就是所谓“大模型幻觉”。
比如ChatGPT3.5大模型，当我问它“1+1为什么=2”时，它首先会这么说：
而当我继续追问它时：
我们仔细分析一下：从哲学角度来看，
一加一等于二这个问题当然体现了逻辑的必然性和普遍性。但是我们发现，一加二等于三也体现了逻辑的必然性和普遍性。这说明——GPT似乎在规避这个问题的本质，它并没有认识到一加一等于二这个问题的特殊性和单一性，它将其归类为普遍性问题去看待，而不是从最原始的角度求分析。并且针对它后续所说：”哲学家可以…“、”在哲学中，1+1等于2不仅仅…“，仔细看这些话术，它实际上并不是在回答我的问题，而是在告诉我别
人是如何回答这个问题的。这里已经脱离了问题的本质。
实际上，自然语言处理大模型只是为了表现得像人，但它并不能跟人一样。
1.2 泛化能力的不足 大模型在训练数据上的表现通常非常出色，但在面对未见过的数据时，其泛化能力仍有待提高。特别是当数据分布发生变化时，模型的性能可能会显著下降。
1.3 适应性的挑战 随着环境和需求的变化，AI模型需要不断适应新的任务和场景。然而，大模型的训练和微调过程通常耗时耗力，这使得模型的适应性成为一大挑战。大型公司在训练他们自己的大模型时，往往动用大量的人力和物力来进行训练，这基于他们庞大的公司运转机制；但是对于小型公司和个人来说，大模型的训练往往是极其吃力的一件事。而当训练效果不佳时，大模型就会变得迟钝和不够聪明——毕竟，时代瞬息万变，大模型也是以时代为背景的。
二、怎么让大模型变聪明呢？ 在介绍了现如今大模型陷入的挑战之后，我们该如何让大模型变得聪明呢？以下是具体方案和python的代码实现。
2.1 增强数据多样性和质量 2.1.1 数据增强技术 数据增强是一种通过对训练数据进行各种变换来生成新的数据样本的方法，可以有效提高模型的泛化能力。例如，在图像处理中，可以通过旋转、平移、缩放等操作来增强数据。在自然语言处理中，可以使用同义词替换、随机插入、删除等方法来扩展语料库。
下面示例展示了如何使用同义词替换进行数据增强，从而提高自然语言处理模型的泛化能力。
import random from nltk.corpus import wordnet def synonym_replacement(sentence, n): """ 使用同义词替换句子中的单词来进行数据增强。 参数: sentence (str): 输入的句子。 n (int): 要替换的单词数量。 返回: str: 经过同义词替换后的句子。 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b377c056032bea17ed31b86440211e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c89210a90801f97b332369ceac95fa35/" rel="bookmark">
			Eslint和Prettier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此前在最开始学代码的时候接触过这两个东西，在后边的日子里接触的就少了，今天突然发现在vue新建项目的时候其实有eslint的选配。其实要问我这两个东西是什么，有什么用，我也只能说出他们可以额额额额，规范代码，代码更好看emmm啊啊。对对~
今天就看宇宙超级无敌大帅越殿下一起看看这两个把。（把窗焊死都给我一起学!)
一.概念篇
1.Eslint是什么？
：是开源的javascript代码检查工具，可以检查代码错了没
2.Prettier是什么？
：代码格式化工具
小结：两个工具一个负责代码的排错，一个负责代码风格的编排，作用上是有差别的
二.官网篇
先看Eslint
npm init @eslint/config@latest eslint主要有如下三个特点：
1.发现问题
2.自动修复问题
3.完全可配置
prettier的特点：
1.按保存的时候代码就被格式化
2.几乎不需要设置参数
官网的信息有点杂多了。。简单工具应该暂时不用了解那么夸张，有点像买的吹风机给了我一大本说明书。。
三.配置
eslint的配置于.eslintrc.cjs
我下面新建两个vue，一个包含了eslint和prettier，还有一个不包含，可以发现有对应的配置文件生成
再看一下对应文件的当前配置
让我们逐行解析下~
root true表示eslint只会在当前目录下查找配置，不会再向上查询。
extends表示一系列规则 表示vue的 ts的 prettier的 使用的规范为最新的ecmaversion
schema指向的url用于验证和补全json文件的结构
semi false表示不用分号做结尾
缩进宽度为两格
使用单引号
每行最大为100字符
不在对象或者数组最后一个元素加逗号
下面试一下写个丑八怪试试
可以看到eslin已经给出了never used的报错提示~
点击保存后prettier也进行了格式化，比如双引号变为了单引号，
官方文档：Prettier 中文网 · Prettier 是一个“有态度”的代码格式化工具
官方文档：检测并修复 JavaScript 代码中的问题。 - ESLint - 插件化的 JavaScript 代码检查工具
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70b4891350a3dd69b660ccac585399a/" rel="bookmark">
			Llama 3-V: 比GPT4-V小100倍的SOTA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型技术论文不断，每个月总会新增上千篇。本专栏精选论文重点解读，主题还是围绕着行业实践和工程量产。若在某个环节出现卡点，可以回到大模型必备腔调重新阅读。而最新科技（Mamba，xLSTM,KAN）则提供了大模型领域最新技术跟踪。若对于如果构建生成级别的AI架构则可以关注AI架构设计专栏。技术宅麻烦死磕LLM背后的基础模型。
大模型领域风云变幻莫测。先是Llama3风靡全球，在几乎所有基准测试中都超越GPT-3.5，部分的基准测试超越了 GPT4。随后，GPT-4o横空出世，凭借其多模态重新夺回王位。而本文中的Llama3-v是研究人员带来新的惊喜，先看下图的统计。Llava是目前最先进的多模态理解模型，LLama3-V与Llava（多模态理解领域的SOTA）相比，提升了 10-20%。此外，除了MMMU之外，在其他指标的表现上和规模大于其 100 倍的闭源模型都毫不逊色。
基于Llama3 8B的LLama3-v与其他模型对比的基准指标数据：
模型架构 为了让Llama3理解视觉信息，因此研究人员将图像切块通过SigLIP模型获取图像的Embedding Vector，然后通过投影与输入文本Tokens对齐平面上。最后，投影块中的视觉Tokens添加到文本Tokens之前，并将联合表示传递到 Llama3。
SigLIP 模型由 Xiaohua Zhai、Basil Mustafa、Alexander Kolesnikov 和 Lucas Beyer在“Sigmoid Loss for Language Image Pre-Training”中提出。SigLIP 是一种与 CLIP 类似的图像嵌入模型。主要区别在于训练损失，SigLIP采用成对Sigmoid 损失，这允许模型独立地对每个图像-文本对进行操作，而无需对批次中的所有对进行全局查看，同时对 logits应用sigmoid激活函数，而不是softmax。
请看上图。换句大白话的说，sigLIP的损失函数是在文字Tokens和图像Tokens的两个序列的基础上计算出来。它指导着模型训练朝着这相同样本对（图，文）的点积值越大，而不同图文对的点积值越小的目标迈进。即矩阵对角线的越大，其余的各自越小。
上图为SigLIP的预训练过程，它在三个设备进行训练。每设备持有4幅图和文字，在单设备上各自运算。紧接着不同的设备交换文本计算损失，如此循环直到全部计算完毕。
SigLIP 的视觉编码器在高层次上将图像分割成一系列不重叠的图像块，并将它们投影到低维线性嵌入空间中，从而产生一系列块嵌入。然后，这些块嵌入经过视觉编码器，该编码器应用自注意力来捕获长距离依赖关系并提取更高级的视觉特征。
虽然为了节省计算资源，在LLama3-v中直接使用由Google DeepMind训练的原始SigLIP模型。然而为了与文本嵌入对齐，还是在SigLIP输出之后使用了额外的投影模块。这与将单个线性层应用于原始图像嵌入的Llava不同，这个模块被改为训练两个自注意力块以便于更好地捕获输入模式，从而生成最终的图像嵌入向量（Embedding Vector）。
对于文本输入，首先使用字节对编码 (BPE) 词汇表对文本进行Tokenizer，从而生成文本标记序列。这些标记（Token）会被包在特殊的 &lt;text&gt;和&lt;/text&gt;标签中来进行区分。对于来自投影层的图像输出将被视为单独的“视觉标记”，并使用&lt;image&gt;和&lt;/image&gt;标签划分它们。视觉标记序列前置到文本标记序列，形成新的序列成为Llama3的联合输入。
SigLIP SigLIP模型比Llama3小得多，而且在整个过程中是被冻结参数的。因此对于预训练和 SFT，我们直接传入这些预先计算好的图像嵌入（Embedding），而不是重新运行SigLIP。这使得训练能够增加批处理大小并最大限度地利用GPU来运行SigLIP，还为节省了训练/推理时间。
为了进一步的优化速度，由于SigLIP也适合运行在Macbook，因此采用MPS 优化过的SigLIP模型上进行运算，这样一来就能够实现每秒 32 张图像的吞吐量，让上个步骤得以实行。
MPS（Metal Performance Shaders）是Apple提供的一套框架，专门用于在Apple设备上加速机器学习和图形计算。
通过SigLIP预计算图像嵌入的步骤，目标是将图像传入SigLIP以获得图像的矢量表示或嵌入。
由于分辨率较高，研究人员遵循LLaVA-UHD采用的方法并执行图像分割。图像分割的目的是将图像分成可变大小的块或片段，以实现更高效的编码和批量处理。
细节分析 首先加载 SigLIP 模型和处理器/标记器，然后使用处理器预处理提供的输入图像。紧跟着将预处理后的图像传递给模型。之后获得模型的输出，将 S型激活函数应用于输出以获得概率。
通过 SigLIP 计算图像嵌入之后，我们现在开始学习投影矩阵——你也可以将其视为投影层，它通常是线性或前馈层。如上文成分部分所述，投影层将视觉嵌入从其原始空间映射到联合多模态嵌入空间。具体而言，投影层将学习到的权重矩阵 Wv 应用于视觉嵌入 v 以获得投影的多模态视觉嵌入 Wv * v（矩阵运算）。通过投影之后，视觉和文本嵌入基本上被对齐到一个共同的多模态嵌入空间，这样一来视觉和文本就融合了，可以运用到各种的多模态任务，如视觉问答、图像字幕等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b70b4891350a3dd69b660ccac585399a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b3ef03d72095741d36c99dbadfd633/" rel="bookmark">
			Python | 基础语法总结（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字面量 字面量：在代码中，被写下来的固定的值
1.1 Python常用的6种值（数据）的类型 1.2代码练习（输出字面量） &gt; print(666) # 整数 &gt; print(13.14) # 浮点数 &gt; print("HeyStar") # 字符串 2.注释 2.1 分类 单行注释：以#开头，#右边 的所有文字当作说明，一般用来对一行或一小部分的代码进行解释。 &lt;#和注释内容以一个空格隔开&gt;多行注释：以 一对三个双引号 引起来（“”“注释内容”“”）来解释说明，一般用来对Python文件、类或方法进行解释。 2.2 代码练习 使用单行注释和多行注释
&gt; print("Hello World") *# 单行注释:输出"Hello World"* &gt;""" &gt; 多行注释 &gt; 输出 &gt; 悯农 &gt; """ &gt; print("锄禾日当午") &gt; print("汗滴禾下土") &gt; print("谁知盘中餐") &gt; print("粒粒皆辛苦") 3.变量 在程序运行时，能储存计算结果或能表示值的抽象概念。 即在程序运行时，记录数据用的 变量的值可以发生改变！ 3.1 定义格式 变量名称 = 变量的值
变量名称：每一个变量都有自己的名称，称为：变量名，也就是变量本身= ：赋值，表示将等号右边的值，赋予左边的变量变量的值：每一个变量都有自己存储的值（内容），称为：变量值 3.2代码练习 3.2.1 定义一个变量，用来记录钱包余额，并输出 &gt; *#定义一个变量，用来记录钱包余额* &gt; money = 50&gt; &gt; *#输出变量的内容* &gt; print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b3ef03d72095741d36c99dbadfd633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b1bfe4aef452257e4eedfc40bb7c087/" rel="bookmark">
			GPT-4o：引领人工智能新时代的强大引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 GPT-4o的推出，让我们再次感受到了人工智能技术的魅力。它不仅在技术上取得了显著突破，还为我们带来了广泛的应用前景。下面，我将从几个方面来谈谈GPT-4o的魅力。
一、技术突破，令人惊叹 1. 多模态处理能力的飞跃： GPT-4o不再局限于文本处理，它能够轻松应对图像、音频等多种模态的数据。这种跨模态交流的能力，让GPT-4o在处理复杂任务时显得尤为出色。
2. 响应速度的提升： GPT-4o的响应速度之快，几乎可以媲美人类的反应时间。这种极快的响应速度，不仅让用户体验更加流畅，也为实时交互提供了可能。
3. 强大的语言生成与理解能力： GPT-4o能够生成连贯、通顺的文本，并且准确理解用户的意图和需求。这种能力使得GPT-4o在内容创作、问答系统等领域具有得天独厚的优势。
二、广泛应用，前景广阔 1. 教育领域的新助力： GPT-4o能够为学生提供个性化的学习辅导和答疑服务，帮助他们更好地掌握知识。想象一下，未来的教育将不再受时间和空间的限制，每个学生都能享受到定制化的教育服务。
2. 客服领域的革新者： GPT-4o能够自动处理大量的用户咨询和投诉，提高客服效率和服务质量。这将大大减轻客服人员的工作压力，让他们有更多的时间和精力去关注用户的真实需求。
3. 医疗领域的得力助手： GPT-4o可以辅助医生进行病情诊断和治疗方案制定，提高医疗水平和服务质量。它将为医生提供准确、全面的数据支持，帮助他们更好地服务患者。
三、面对挑战，共谋发展 1. 数据隐私与安全的守护： 在享受GPT-4o带来的便利时，我们也需要关注数据隐私和安全问题。我们需要共同努力，确保GPT-4o在处理用户数据时，能够严格遵守相关法律法规，保护用户的隐私和安全。
2. 算法偏差与错误的纠正： 虽然GPT-4o在算法上取得了显著进步，但仍可能存在偏差和错误。我们需要不断完善和优化算法，提高其准确性和可靠性。同时，我们也要学会包容和理解这些偏差和错误，因为它们是技术进步的必经之路。
3. 探索与创新的步伐： 面对GPT-4o带来的挑战和机遇，我们需要保持开放的心态和探索的精神。我们要敢于尝试新的想法和方法，不断推动GPT-4o技术的进步和应用。同时，我们也要学会分享和合作，共同为人工智能领域的发展贡献智慧和力量。
四、技术突破，引领新潮流 多模态处理能力的卓越表现：GPT-4o能够实时对音频、视觉和文本进行推理，这意味着它可以同时处理和理解来自不同模态的信息。这种跨模态处理能力使得GPT-4o在处理复杂任务时更具优势，能够为用户提供更加全面和精准的服务。惊人的响应速度：GPT-4o在处理速度上提升了高达200%，能够在232毫秒内对音频输入做出反应，平均为320毫秒。这种与人类相似的响应时间，使得GPT-4o在实时交互场景中表现出色，无论是语音聊天还是视频通话，都能保持流畅和自然的交流体验。强大的语言支持：GPT-4o能够处理50种不同的语言，这极大地拓宽了它的应用范围。无论用户来自哪个国家，使用哪种语言，GPT-4o都能提供准确、流畅的交流体验。
五、应用前景，潜力无限 教育行业的变革者：GPT-4o能够为教育行业带来革命性的变化。它可以根据学生的进度和兴趣点制定个性化学习计划，引入虚拟现实技术创建沉浸式学习体验，甚至可以作为在线导师帮助学生解题。这种个性化的教学方式将大大提高教育效率和学习效果。跨语言交流的桥梁：GPT-4o的多语言支持能力使得它在国际交流和会议同声传译等场景中具有广泛的应用前景。它可以实时翻译不同语言之间的对话内容，打破语言障碍，促进全球交流和合作。娱乐与创作的伙伴：GPT-4o在娱乐和创作领域也有着广泛的应用。它可以为游戏提供动态故事线，根据玩家的选择和行为调整剧情；在内容创作方面，GPT-4o可以辅助编剧创作剧本和角色对话，提高创作效率和质量。
六、挑战与机遇并存 数据隐私与安全的挑战：随着GPT-4o的广泛应用，数据隐私和安全问题也日益凸显。我们需要建立更加完善的数据保护机制，确保用户数据的安全和隐私。算法偏差与错误的纠正：尽管GPT-4o在算法上取得了显著进步，但仍可能存在偏差和错误。我们需要不断完善和优化算法，提高其准确性和可靠性。同时，我们也需要建立有效的反馈机制，及时发现和纠正算法中的错误。持续创新的机遇：GPT-4o的推出为我们提供了无限的创新机遇。我们可以探索更多基于GPT-4o的应用场景和解决方案，推动人工智能技术的不断发展和进步。同时，我们也需要加强跨学科的合作和交流，共同推动人工智能领域的创新和发展。
结语 总之，GPT-4o作为引领人工智能新时代的强大引擎，为我们带来了无限的可能和机遇。让我们携手共进，共同探索这个充满挑战和机遇的新世界吧！
当然，让我们继续深入探讨GPT-4o的魅力和特点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125a86035dbbb01fabb28a1d89b7ee73/" rel="bookmark">
			LEfSe分析：R语言一句代码轻松实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据和代码获取：请查看主页个人信息！！！ 大家好，今天我将介绍如何使用R语言进行LEfSe（Linear discriminant analysis Effect Size）分析及可视化。LEfSe是一种基于线性判别分析的算法，可以帮助我们鉴别和发现在不同组间具有显著差异的微生物特征。
目前大部分童鞋们进行LEfSe分析时会使用一些在线网站或者本地安装的软件，分析过程比较头疼~~
偶然看到一个微生物生态学中优质R包【microeco】，可以轻松实现LEfSe，在此分享给大家！
microeco包是一个功能极其强大的微生物管道包，几乎可以做所有常见的微生物组下游分析，并且最最最重要的一点是，可视化图都是【ggplot2对象】，可以充分的满足大家的图片的个性化需求。
话不多说，我们直接开始：
Step1：载入数据
rm(list=ls()) pacman::p_load(tidyverse,microeco,magrittr) feature_table &lt;- read.csv('feature_table.csv', row.names = 1) sample_table &lt;- read.csv('sample_table.csv', row.names = 1) tax_table &lt;- read.csv('tax_table.csv', row.names = 1) head(feature_table)[,1:6]; head(sample_table); head(tax_table)[,1:6] 使用microeco包进行所有分析之前，我们需要构建一个【microtable对象】，这是所有后续分析的基础；这也是大多数功能强大的R包所具有的的共同特点，第一步数据对象搞定之后，后续的分析往往很简单！
Step2：构建microtable对象
上述代码将使用样本信息、物种特征表和分类信息的CSV文件，并创建了一个microtable对象，为LEfSe分析做好准备。
Step3：执行LEfSe分析
lefse &lt;- trans_diff$new(dataset = dataset, method = "lefse", group = "Group", alpha = 0.01, lefse_subgroup = NULL) Step4：绘制差异柱状图
# we show 20 taxa with the highest LDA (log10) lefse$plot_diff_bar(use_number = 1:30, width = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/125a86035dbbb01fabb28a1d89b7ee73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e5b8b6e306a31a49affb44c061f09e4/" rel="bookmark">
			【C&#43;&#43;奇妙冒险】拷贝构造函数、运算符重载（赋值重载|const成员|取地址重载|const取地址重载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言🚩拷贝构造函数🫧概念🫧特征🫧默认生成的拷贝构造🫧default关键字（浅谈） 🚩运算符重载🫧概念🫧运算符重载注意事项🫧封装如何保证？ 🚩赋值运算符重载🫧赋值运算符重载格式🫧返回值引用和不加引用的区别🫧赋值运算符只能重载成类的成员函数不能重载成全局函数🫧编译器生成的默认赋值运算符重载 🚩const成员🫧const 成员🫧const修饰成员函数🔺小结 🫧思考 🚩取地址及const取地址重载🫧取地址重载🫧const取地址重载🫧取地址重载和const取地址重载一般不需要重载 前言 🚩拷贝构造函数 创建对象时，可否创建一个与已存在的对象一模一样的新对象呢？
可以的
用拷贝构造就能做到：
Date d1(2024, 5, 28); Date d2(d1); return 0; 什么原理？我们下面会讲，反正不是张力…
🫧概念 拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰），在已存在的类类型对象创建新对象时，由编译器自动调用。
🫧特征 拷贝构造函数也是特殊成员函数，特征如下：
拷贝构造函数是构造函数的一个重载形式拷贝构造的参数只有一个且必须是类类型对象的引用（必须使用引用）
注：使用传值方式编译器直接报错，因为会引发无穷递归调用若未显示定义，编译器会生成默认的拷贝构造
默认的拷贝构造函数对象按内存存储，按字节序完成拷贝（浅拷贝or值拷贝） 原型：类名 （const 类名&amp; 形参） 例如：Date（const Date&amp; d） 拷贝构造函数的用法：
代码：
#include&lt;iostream&gt; using namespace std; class Date { public: Date(int year = 2024, int month = 5, int day = 28) { _year = year; _month = month; _day = day; } // 拷贝构造函数 // Date d2(d1) Date(const Date&amp; d) // 不传引用会无限递归调用 { _year = d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e5b8b6e306a31a49affb44c061f09e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838bc62b1d75b185eedf783512726bc5/" rel="bookmark">
			让 AI 回答更精准 ◎ 来学学这些Prompt入门小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥前言 最近一直在研究各种 AI 提问相关的方法，一顿输入后，get到了好多有趣又好玩的提问小技巧。今天就来和小伙伴们安利下，平常在向AI提问时，最最基础，且最最实用的6种提示词方法。
那废话不多说，下面就跟随着周一的步伐，来一起一探究竟吧~👻
一、💡指令下达式提问 1、举个例子 想要有效地使用AI，就需要学会怎样灵活地与AI交流。这就好比是领导在给团队成员分配任务的过程一样。同一个任务，同样的下属，不同的领导分发任务的过程都还很不一样。在这个时候，会布置任务的领导，总是能够更好地带领下属，打胜仗。
我们来看下面这样一个案例。假如领导需要做一个宣传方案，下达了如下任务。那假如你是下属，你更可能完成哪个领导所布置的任务呢？
角色提示词普通的领导我们最近要和 xxx 品牌合作，需要出一个宣传方案，你来做一下，后天给我。优秀的领导最近 xxx 品牌要与我们合作，马上到五一劳动节了，他们想围绕这个节日和他们的新产品，让我们出一个节日宣传方案，以带动这款新产品的销量。这次活动主要面向 25~35岁 的女性人群，活动方案要求包含节日五天的每日宣传安排。方案需要用PPT呈现，不要超过10页。周五下午6点前将方案给我。 看完上面这两个例子，你会发现优秀的领导布置的任务往往更容易完成。
在上面的例子中，优秀的领导给出的信息完整且全面，要求清晰又明确。下属看了就知道工作任务是什么，否则下属就得花费大量时间和领导确认这个方案的具体要求。
当领导明确地指出期望的结果、工作标准以及截止时间时，下属能更好地理解任务要求，这不仅可以提高工作效率，还能避免不必要的误解和拖延。
因此，在向AI提问时，给出的指令越清晰和具体，得到的结果越接近自己的预期。
2、是什么？ 通过上面这个例子，我们来梳理下指令下达式提问的定义。
所谓指令下达式提问，就是提问者明确设定问题范围以及对回答的要求，通过精确、具体的指令来引导AI生成符合预期且更有针对性的信息。
3、如何定义好的指令？ （1）四大原则 了解完指令下达式提问的定义之后，那可能有的小伙伴就会有疑惑说：什么样的指令才是好的指令呢？下面这四大原则供大家参考👇🏻：
特点描述结构清晰下达指令前，可以借助一些经典的结构（比如我们经常使用的5W），让自己的表达更有逻辑，更顺畅，从而形成清晰的指令。重点突出清晰地表达需求，可能会导致指令的内容较多。指令复杂，不利于AI理解提问者的需求，这时可以通过换行，突出每一条重要的指令信息。语言简练多用短句，少用长句，有助于精简信息。易于理解尽量使用表示量化或具体场景的词汇，尤其是在表达期望达到某一种效果的时候。比如当希望控制篇幅时，比起“不要太长”这样的指令，你可以明确给出“控制在300字以内”更容易让AI理解。 （2）掌握5W方法 上面聊到了5W方法，这里再给大家介绍下5W方法在提问里面的应用。具体如下表所示：
英文单词中文解释提问启发Why何故做这件事的原因是什么What何事这件事具体是什么事Who何人这件事有哪些人参与或者面向谁When何时这件事什么时候做或者何时截止Where何地在哪里做这件事 了解了以上规则后，我们会发现掌握一些常用的结构化提问思路，是用好指令下达式提问的关键。接下来我们就结合实际场景，来看看指令下达式提问的魅力。
4、应用实践 这里给大家举一个职场工作中常见的场景：让AI协助你制定工作计划。
在日常工作中，你有时候会不会觉得，即使是明确了公司的工作目标和现状时，自己在制定工作计划时也总是觉得思路受限。那这个时候，就可以考虑让AI帮你出谋划策了。
我们来看看如何使用指令下达式提问，帮助我们制定工作计划。
（1）SCQA模型 首先给大家介绍一个SCQA模型，我们可以运用SCQA这个模型来梳理思路，将更清晰的指令给到AI。来看看SCQA模型的结构：
简要解释提问启发Situation（情景）：事情发生的背景信息任务背景是什么Complication（冲突）：理想与现实的差距有什么已有的素材或信息Question（疑问）：当前要解决的问题或要完成的任务现在要完成什么任务Answer（回答）：提供的的解决方案有哪些参考案例 （2）用SCQA模型提问 那如何用SCQA模型对AI进行提问呢？来看看下面的案例。
假设你是某公司的产品总监，现在已经明确第二季度的目标是产品中的10个模块，每个模块要至少产出8个需求方案。那应该如何制定产品方案呢？来看看下面的提问和回答。
指令提问👇🏻：
指令**（任务背景）我们目前要制定第二季度的工作计划，需要你根据以下信息，帮助我们拆解任务，制定详细的行动计划。
（已有信息）公司已经确定了第二季度的目标，即每个产品模块至少产出8个需求方案。整个产品包含10个模块，这意味着我们需要在规定时间内产出至少80个需求方案。
（当前任务）我们的任务：第二季度产出相关的需求方案，并顺利完成上线交付给客户。请你根据我们公司的现状制定几套可选择的方案，帮助我们完成任务。
（参考案例）**每套方案中需要提供一些参考案例。 AI生成结果👇🏻：
可以看到，当我们有非常清晰的任务信息或者需求时，通过指令下达式提问的方法向 AI 进行提问，能够获得更加全面和更加匹配的答案。
5、注意事项 讲完指令下达式提问，相信小伙伴们已经感受到清晰指令的魔力。下面我们来梳理一下注意事项：
指令越清晰、越具体，AI的回答越精准。想要进行好的指令下达式提问，可以多积累好的提问结构，帮助自己梳理真实需求，从而进行更清晰的表达。在工作中遇到自己不明确协作结构的情况，比如撰写会议记录、公文等，可以让 AI 提供写作框架，再让 AI 用这个框架生成相应的内容。 二、📩角色扮演式提问 继续，我们来聊聊今天的要讲的第二种提问方式：角色扮演式提问。
1、举个例子 试想一下，我们在遇到问题或者想要学习某一个领域的知识时，会更倾向于询问完全没有经验的小白，还是有丰富经验的专家？
比如，当想找人帮自己制定一个英语口语提升计划时，你会找下面哪个人？
A. 大学生
B. 资深的英语老师
相信你心里已经有了答案，自然是会选择有相关经验的资深英语老师啦。
如果说指令下达式提问适合很了解自己需求的专业用户，那么使用角色扮演式提问，就是让AI变成专家。
角色的转变，会使得AI极大地提升其回答问题的质量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/838bc62b1d75b185eedf783512726bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea2281c400fd5029364d8258f6b628be/" rel="bookmark">
			k8s学习--资源控制器StatefulSet详细解释与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 StatefulSet是什么？statefulset是什么k8s中常见的pod控制器类型有哪些statefulset与其他pod控制器的区别是什么有状态服务和无状态服务区别是什么StatefulSet作用statefulSet的特点statefulSet组成 部署statefulset应用部署storageclass（1）主机基础配置（2）配置 NFS:（3）创建配置storageclass 2.部署headless service3.Statefulset应用示例 一 StatefulSet是什么？ statefulset是什么 是k8s中常见的pod控制器类型之一
k8s中常见的pod控制器类型有哪些 ReplicaSet:即RS
Deployment
DaemonSet:即DS
StatefulSet
Job
Cronjob
statefulset与其他pod控制器的区别是什么 我们在生产中常用的副本(pod)控制器如Deployment,DaemonSet,RS都是使用于无状态服务，其所管理的Pod的启停顺序，IP，Pod名称都是随机的，被管理的Pod更新时,这些都会发生变化,而我们在管理如mysql,redis,kafka,consul这些集群是为了管理方便，就可以使用
有状态服务statefulSet
Kubernetes中StatefulSet是专为有状态服务如mysql、redis、kafka、consul等集群准备的集合，管理所有有状态服务。
注:无状态服务同样可以使用statefulset控制器
有状态服务和无状态服务区别是什么 简单理解（个人理解）
无状态服务里随机的参数(Pod的启停顺序、IP、Pod名称)在有状态服务里都不是随机的，有顺序的
详细解释
无状态服务（Stateless Services）：
1.在 Kubernetes 中，无状态服务通常以 Deployment 或者 ReplicaSet 的方式进行部署和管理。
2.无状态服务的实例可以随意扩展和收缩，因为它们之间是相互替换的，而且不需要关注特定实例的状态。
3.无状态服务可以使用水平扩展来应对高负载，Kubernetes 可以根据实际负载自动添加或移除实例。
有状态服务（Stateful Services）：
1.在 Kubernetes 中，有状态服务通常以 StatefulSet 的方式进行部署和管理。
2.StatefulSet 提供了稳定的网络标识和持久化存储的能力，确保每个实例都有唯一的标识并且可以使用持久化卷来保存状态数据。
3.有状态服务的实例通常需要按照确定的顺序部署和扩展，因为它们的状态数据可能会影响到服务的行为。
StatefulSet作用 主要用来管理有状态应用的控制器。
用来管理某Pod集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。
statefulSet的特点 1.稳定的网络标识：StatefulSet 中的每个 Pod 都有一个稳定的网络标识符（例如 hostname），这使得这些 Pod 可以有确定的网络身份，并且可以被其他应用程序依赖和访问。
2.有序部署和扩展：StatefulSet 保证 Pod 的部署和扩展是按照确定的顺序进行的，每个 Pod 都有一个唯一的标识符，这对于需要有序启动和停止的应用程序非常重要。
3.持久化存储：StatefulSet 支持使用持久卷（PersistentVolume）来存储 Pod 的状态数据，确保即使 Pod 被重新调度到其他节点，其状态数据也不会丢失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea2281c400fd5029364d8258f6b628be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290cdb4c5176ef4e519a8a0ccffe9632/" rel="bookmark">
			相机系列——相机标定简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：木一
对相机系列感兴趣还可看前文了解更多相关内容：
相机系列——透视投影：针孔相机模型
VR/AR/XR背后的逻辑？离不开三维引擎相机
引言 上文我们介绍了针孔相机模型，用来描述相机的透视投影成像过程，具体可以表示为：
其中P表示三维空间中的任意一点，p表示其在成像平面上的像素坐标，K表示相机内参，R、t表示相机外参。λ为尺度因子，可以取任意实数。
据此可以看出，给定相机内外参数，可以唯一确定三维空间到二维平面的投影转换过程，即确立三维空间点到二维图像点的对应关系。
PS：转换是单向的，只能由三维到二维，这是因为三维到二维的转换损失了一个维度，无法得到二维到三维的唯一映射关系。不难想象，二维图像上的任意一点对应到三维空间是一条射线，而不是一个点。
这一点从公式的尺度因子可以看出，对于一个三维点P，可以唯一确定图像点p，对于一个图像点p，当尺度因子取值不同时，对应的三维点也不同。关于尺度因子的物理含义，从前文的公式中可以看出，它其实表示的是三维点距离相机中心的深度 𝑍𝑐 。所以如果深度值 𝑍𝑐 确定，则可以实现二维到三维的转换。
什么是相机标定 针孔相机模型只是对相机成像过程的通用描述，相机的内参各不相同，外参对应拍摄时的相机位置和姿态，要准确还原一幅相片的成像过程，还需要对相机的内外参数进行准确求解，求解过程称之为相机标定。
标定什么 相机内参包括焦距f、像主点坐标（𝑢0，𝑣0）、像元尺寸（ 𝑑𝑥 ， 𝑑𝑦 ），相机外参包括相机位置t和相机姿态R。相机标定是对相机内参和外参的求解，通常情况下，只需要计算出相机内参矩阵K和外参矩阵[Rt]即可。
以上仅针对理想条件下的线性模型而言，而实际成像过程受物理因素、光学因素影响，成像过程是非线性的，即会导致相机畸变，因此相机标定还包括对畸变系数的求解，关于畸变系数求解本文暂不展开。
标定方法 相机标定最早应用于摄影测量学，但主要针对量测型相机。之后随着计算机视觉的发展与应用，学者们提出了更多相机标定方法。此外，随着人工智能技术的发展，近年来基于深度学习的标定技术也得到广泛研究。
总体来说，传统标定方法是基于预先设置的成像场景构建标定模型，在场景几何约束基础上选取最优算法求解相机参数。主要包括以下三类：
（1）基于标定物的方法：是在场景空间设置参照物，参照物具有便于识别的特征点，识别参照物特征点构建像素与空间坐标对应关系方程组，再利用优化算法求解参数，基于棋盘格的张正友标定法是这类方法的经典代表。
（2）主动视觉法：是通过人为精确控制相机或目标做特殊运动如纯旋转、平移等获取多幅图像，基于定量化的运动约束求解相机参数。
（3）自标定方法：不需要设置特定的控制条件，只根据多幅图像对应点之间的关系直接求解相机参数，如直接求解 Kruppa 方程、基于绝对二次曲线和绝对二次曲面方法等。
本文介绍两种应用最为广泛的标定方法：直线线性变换法（Direct Linear Transform，DLT）和张正友标定法。
（1）DLT
在不考虑相机畸变的情况下，相机成像过程可以抽象为线性变换过程，DLT方法是通过已知的三维点和其在图像中的对应点关系建立线性方程组，并通过求解方程组来获取相机投影矩阵。再对投影矩阵进行分解获取相机内参和外参矩阵。关于具体方法介绍已经有大佬们写的很清楚了，本文不再赘述。参照：立体视觉入门指南（4）：相机标定之DLT直接线性变换 - 知乎
图源：立体视觉入门指南（4）：相机标定之DLT直接线性变换 - 知乎
（2）张正友标定法
张正友标定法也就是我们经常见到的棋盘格法，是一种基于标定物的方法。标定物是已知尺寸的二维棋盘格平面，以棋盘格角点作为参照建立约束关系，求解相机内外参数。具体可参照：立体视觉入门指南（3）：相机标定之Zhang式标定法 - 知乎
图源：立体视觉入门指南（3）：相机标定之Zhang式标定法 - 知乎
拓展：理解相机参数 内参矩阵理解 在实际应用中，我们标定出来的内参矩阵通常像这样：
K = [[4675.63477897830, -5.165508791991464, 3025.473077235752], [0.000000000000000, 4666.3702576511423, 1986.696982476598], [0.000000000000000, 0.0000000000000000, 1.000000000000000]] fx = 4675.63477897830 fy = 4666.37025765114 u0 = 3025.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/290cdb4c5176ef4e519a8a0ccffe9632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794f0f0f2d1937b7057db74d21d96ecf/" rel="bookmark">
			mysql 查询语句的默认排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 判断查询条件中的字段有无索引, 如果没有索引, 则查询结果默认按主键的正序排序;
2. 如果查询条件中的字段有索引, 根据索引的不同, "主键索引" &gt; "唯一索引" &gt; "普通索引". 如果查询字段有多个, 则按照索引最先创建的顺序进行正序排序。
3. 在此之外, 针对于多字段的组合索引, 我发现这种索引被命中时, 会按组合索引的字段去排序. 我今天有一个页面逻辑就是触发了这种场景, 根据合同ID查询对应 的付款条件, 发现没有按付款条件的创建顺序来排序. 查完资料, 才发现是跟组合索引有关. 这里针对此种情况, 举例:
select * from test_score; 执行结果如下: select * from test_score where class_no ="A"; 执行结果如下: 通过两个语句的比较, 能看出 class_no字段命中了组合索引 "`idx_test` (`class_no`,`name`) "后,
优先按name字段的值默认排序了, 导致id值不是正序排序的.
后续再拿主键id参与条件查询, select * from test_score where id &gt; 0; 执行结果如下: select * from test_score where id &gt; 0 and class_no ="A" ; 执行结果如下: 此种情形下, 还是优先按组合索引的顺序来默认排序的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/794f0f0f2d1937b7057db74d21d96ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac67a301116d97064bd67fb08e17ab2/" rel="bookmark">
			Stable Diffusion云端部署安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1【推荐】：Autodl云端安装步骤 云端网址: 【点击直达】
注册并认证。
充值并租用云端电脑
部署云端请参考以下图片
选择你们喜欢的镜像，就可以直接租用了
推荐这个镜像
记得多看使用说明哦，好记性不如多实操~
方法2：SD官方云端部署 | 保姆级教程 部署的必备条件
1.1 需要稳定且不受限的网络环境
你需要一个稳定 (不卡) 的网络来保证代码可以在云端运行:你需要不受限制的网络环境 (科学上网，此处就不过多解释了哦~)
1.2 需要一个谷歌账号
谷歌邮箱现在已经支持大陆手机号注册，可以直接点击官网链接进行注册: https://mail.google.com/
一些概念的简介
2.1 StableDiffusion 和 StableDiffusion Web UI的简介
StableDiffusion是2022年发布的深度学习文本到图像生成模型。它主要用于根据文本的描述产生详细图像，也可以应用于其他任务，如内补绘制、外补绘制，以及在提示词(英语) 指导下产生图生图的翻译。它是一种潜在扩散模型，由慕尼黑大学的Compvis研究团体开发的各种生成性人工神经网络。它是由初创公司StabilityAl，CompVis与Runway合作开发的，并得到EleutherAl和LAION (英语) 的支持。Stable Diffusion的代码和模型权重已公开发布，可以在大多数配备有适度GPU的电脑硬件上运行。而以前的专有文生图模型(如DALL-E和Midjourney) 只能通过云计算服务访问。StableDiffusion可以在本地计算机上使用，也可以在云服务器上运行。
StableDiffusion Web UI是一个基于Web的用户男面，用于使用StableDiffusion进行图像生成和其他任务。由AUTOMATIC1111开发，并开源上传至Github，也是目前使用最多的WebUI版本。(Shout to AUTOMATIC1111)。WebUl提供了易于使用的图形界面，可以帮助用户更直观的了解和使用StableDiffusion的功能，并在基本不需要编写代码的情况下启动和监视训练过程。
对这些不感兴趣的朋友可以不管这些专业性术语直接跳过，对编程、算法感兴趣的朋友可以自行搜索去了解更多关于StableDiffusion的专业信息。
下文StableDiffusion简称为SD。
2.2 Google Colab简介
Google Colab是由谷歌提供的一个免费的云端计算机环境，用户可以在Gooale Colab中使用Python编程语言来访问谷歌云平台的资源，包括CPU、GPU等计算资源(这些也都可以不去理解，它的作用就相当于把电脑搬到了云端，我们只需要知道可以用它来渲染图片就好)，Google Colab可以通过浏览器直接访问，所以在使用时需要保证有网。下文中Google Colab简称为Colab。
🧐既然Colab听起来这么厉害，那么到底可以用它来做什么呢?
省个显卡钱:SD是基于GPU渲染的，众所周知现在GPU的价格昂贵，好一点的显卡动辄几千上万。如果我们没有高级的显卡，又想体验丝滑出图的效果，那么Colab就是非常好的选择，它可以为我们提供定的计算单元和GPU资源来运行代码，进行渲染。
不省显卡钱:但让显卡不那么忙: 如果你有好的显卡但是你又心疼自己的显卡在渲图时温度飙升、电脑2 .发出咆哮般的声音，或者你想在渲图的过程中继续开一把类似于荒野大镖客、GTA这种很吃显卡性能的游戏，那么Colab同样是一个很好的选择。
它是真的快: 如果你是Colab免费用户，默认会为你提供专业用于机器学习的NVIDIATeslaT4显卡以3供GPU运算使用;如果你是Pro用户，在更改运行时类型处打开Premium模式 (下面教程中会有更改运行时类型的选项)，你的显卡配置将会更换为NVIDIA A100!!当然在SD的日常使用中不建议长时间打开Premium模式，用默认模式就已经足够，如果是渲染视频等的话，可以开启。
有网的地方就可以运行:只要你满足使用的条件，且在云端部署好了SD，那么你在任何地方都可以运行SD，甚至使用你的手机也可以运行。
既然Colab听起来这么厉害，那么它到底是不是免费的?具体来说，Colab可以免费试用，类似于另一个Al绘图软件Midjourney (Mi)，Mi是使用一定次数后需要付费订阅，Colab是使用一定时长后需要订阅付费。
12小时试用免费:免费版中，我们能使用12个小时的计算资源，可以理解为能够连接12个小时的Colab，如果超过12个小时，将会断开连接。没错，相当于只能免费体验12个小时，如果你想一直白嫖，那就需要多准备几个谷歌账号了，而且需要重复进行部署操作。
升级为Pro版无限使用:付费版的Colab提供更多的计算资源和内存，并且没有时间限制(但是计算单元会慢慢用完，渲染速度会逐渐变慢变的和试用版一样)。Colab Pro的价格为每月$9.99美元(换算为人民币约为68元)。
3.3 Google Drive 简介
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac67a301116d97064bd67fb08e17ab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8d0d083a8b9d3831fff144f1171175/" rel="bookmark">
			【MySQL】——数据库设计概述与需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💻博主现有专栏：
C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯数据库设计概述
🎃数据库设计的特点
🎃数据库设计方法
🎃数据库设计的基本步骤
🎯需求分析
🎃需求分析的任务
🎃需求分析的方法
🎃数据字典
🎯数据库设计概述 在数据库系统中，最终用户通过数据库应用系统使用数据库。我们把使用数据库的各类信息系统称为数据库应用系统，比如图书借阅、人事管理等各类管理信息系统、办公自动化系统、决策支持系统等。广义地讲，是数据库及其应用系统的设计，即设计整个数据库应用系统。狭义地讲，是设计数据库本身，即设计数据库的各级模式并建立数据库，这是数据库应用系统设计的一部分。 什么是数据库设计？
数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。
信息管理要求：在数据库中应该存储和管理哪些数据对象 。数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。 数据库设计
数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境 。
高效率的运行环境
数据库数据的存取效率高数据库存储空间的利用率高 数据库系统运行管理的效率高 🎃数据库设计的特点 数据库建设的基本规律
三分技术，七分管理，十二分基础数据
管理
数据库建设项目管理企业（即应用部门）的业务管理 基础数据
数据的收集、整理、组织和不断更新 结构（数据）设计和行为（处理）设计相结合
将数据库结构设计和数据处理设计密切结合 结构（数据）和行为（处理）分离的设计
传统的软件工程：重 行为设计
忽视对应用中数据语义的分析和抽象，只要有可能就尽量推迟数据结构设计的决策 早期的数据库设计：重 结构设计
致力于数据模型和数据库建模方法研究，忽视了行为设计对结构设计的影响 🎃数据库设计方法 大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。
手工试凑法
设计质量与设计人员的经验和水平有直接关系缺乏科学理论和工程方法的支持，工程的质量难以保证数据库运行一段时间后常常又不同程度地发现各种问题，增加了维护代价 规范设计法
典型方法
新奥尔良（New Orleans）方法 将数据库设计分为若干阶段和步骤采用辅助手段实现每一过程按设计规程用工程化方法设计数据库基于E-R模型的数据库设计方法 概念设计阶段广泛采用3NF（第三范式）的设计方法 逻辑阶段可采用的有效方法 规范设计法
典型方法
ODL(Object Definition Language)方法 面向对象的数据库设计方法UML(Unified Modeling Language)方法 面向对象的建模方法 🎃数据库设计的基本步骤 数据库设计分6个阶段
需求分析概念结构设计逻辑结构设计物理结构设计数据库实施数据库运行和维护 设计一个完善的数据库应用系统 往往是上述6个阶段的不断反复 这个设计步骤既是数据库设计的过程，也包括了数据库应用系统的设计过程
🎯需求分析 🎃需求分析的任务 充分了解原系统（手工系统或计算机系统）工作概况 详细调查现实世界要处理的对象（组织、部门、企业等）明确用户的各种需求 调查的重点是“数据”和“处理”，获得用户对数据库的要求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad8d0d083a8b9d3831fff144f1171175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aab4879622a94454cae81f5c2f9bb46/" rel="bookmark">
			C语言/数据解构——每日一题（随即链表的复制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.前言
二.正文
1.1题目描述
1.2题目分析
（i）创建节点，并尾插到原节点后
（ii）将复制节点的random指针指向正确位置
​编辑（iii）将复制链表从原链表上剥离下来
1.3代码实现
三.前言
一.前言 嗨嗨嗨，大家好久不见。已经有好几天没更新了。今天我们就分享一道链表题吧——随即链表的复制https://leetcode.cn/problems/copy-list-with-random-pointer废话不多说，让我们直接开始今天的题目分享吧。
二.正文 1.1题目描述 他和单链表不同的是，结构体里还多一个random指针，指向随机节点。
这道题的意思就是想让我们将原链表完全复制下来，并且将复制好的链表返回到服务器上。
1.2题目分析 （i）创建节点，并尾插到原节点后 这道题我们可以通过遍历一个节点的同时，就穿插一个复制该节点数据的复制节点在该节点后面。
通过循环语句，我们最后会得到一个每一个原节点的后面尾插了一个新的复制节点。如图所示：
这里我们只是先处理了next指针，下面我们将处理random指针。让复制节点的random指针指向和原节点保持一致。
值得注意的是上面的这些节点是我们通过malloc函数自己手动创建的。红叉的地方意味着原来的next指向断掉了。
（ii）将复制节点的random指针指向正确位置 这里我们需要让复制节点的random指针和原节点指向一致，但不是指向原节点，而是指向复制节点。
如果原节点的random指针指向为NULL，那么与之对应的，该节点的复制节点也需要指向NULL。
如果该节点（假设l1）的random指针不指向NULL。而是指向另外一个节点（假设为l2）。那么与之对应的，l1的复制节点的random也应该指向l2的复制节点。那么这一步该如何实现呢？
我们假设一个指针pcur现在指向第三个节点13。pcur-&gt;next-&gt;random=pcur-&gt;random-&gt;next。
这样两个复制节点就可以通过pcur建立联系了。如图所示：
（iii）将复制链表从原链表上剥离下来 这里我们可以创建一个哨兵位，然后陆续从后面插入我们需要的复制节点即可。然后将哨兵位后面的有效节点存起来，在哨兵位free掉，归还给操作系统，将指向该哨兵位节点的指针置为NULL。最后返回之前存的有效节点即可
1.3代码实现 ** * Definition for a Node. * struct Node { * int val; * struct Node *next; * struct Node *random; * }; */ typedef struct Node ListNode; struct Node* copyRandomList(struct Node* head) { if(head==NULL) return head; ListNode* pcur = head; while (pcur) { ListNode* copy = (ListNode*)malloc(sizeof(ListNode)); copy-&gt;val = pcur-&gt;val; copy-&gt;next = pcur-&gt;next; pcur-&gt;next = copy; pcur = pcur-&gt;next-&gt;next; } pcur = head; while (pcur) { ListNode* copy = pcur-&gt;next; if (pcur-&gt;random == NULL) copy-&gt;random= NULL; else pcur-&gt;next-&gt;random = pcur-&gt;random-&gt;next; pcur = copy-&gt;next; } ListNode* newhead = (ListNode*)malloc(sizeof(ListNode)); ListNode* ppcur; ppcur = newhead; pcur = head-&gt;next; int count = 0; while (pcur) { if (count % 2 == 0) { ppcur-&gt;next = pcur; ppcur = ppcur-&gt;next; } pcur = pcur-&gt;next; count++; } ListNode* ret = newhead-&gt;next; free(newhead); newhead = NULL; return ret; } 值得注意的是上面的代码是在力扣环境上运行的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aab4879622a94454cae81f5c2f9bb46/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/332/">«</a>
	<span class="pagination__item pagination__item--current">333/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/334/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>