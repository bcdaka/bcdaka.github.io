<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a93b8151915ae03578564885496528b/" rel="bookmark">
			Oracle ORA-28547:connection to server failed,probable Oracle Net admin error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Navicat连接oracle数据库时报ORA-28547错误
因为Navicat自带的oci.dll并不支持oracle11g，需要去官网下载支持的版本。
1.去oracle下载对应的oci.dll文件
下载地址：Oracle Instant Client Downloads
可以用 11.2.0.4 2. 复制刚下载下来的instantclient_11_2文件夹中的所有文件，粘贴到Navicat的instantclient_11_2目录下.
打开工具-&gt;选项-&gt;选择下载的oci.dll文件
3.重启Navicat并连接Oracle
总结
下载的instantclient_11_2版本和oracle版本有关，和navicat版本无关。需要把下载的instantclient_11_2全部文件覆盖到navicat的目录，而不是单个oci.dll文件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2bbf49d96eab6068b14b45d4eb4f983/" rel="bookmark">
			【RabbitMQ】基于rabbitMQ 实现 MQTT server服务端 | 快速拉起mqtt服务 | docker 部署 RabbitMQ 配置 MQTT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于rabbitMq的MQTT rabbitmq的官方文档地址：https://www.rabbitmq.com/docs/mqtt
目前已经支持的MQTT版本如下：3.1、3.1.1、5.0
1、创建rabbitMQ 服务 一键拉起rabbitmq
&gt; docker run -d --name rabbitmq --restart always -p 15672:15672 -p 5672:5672 -p 1883:1883 rabbitmq:3-management 1.1、端口说明 在使用 Docker 部署 RabbitMQ 并开通 MQTT 服务时，你需要确保以下端口在安全组中是开放的：
AMQP 端口（默认端口：5672）： 这是 RabbitMQ 使用的端口，用于 AMQP 协议。确保你的安全组允许来自需要访问 RabbitMQ 的客户端的流量通过这个端口。
管理界面端口（默认端口：15672）： 如果你需要访问 RabbitMQ 的 Web 管理界面，你需要开放这个端口。
MQTT 端口（默认端口：1883）： 这是 MQTT 服务使用的端口。确保这个端口也被安全组允许通过，以便 MQTT 客户端可以连接到 RabbitMQ 的 MQTT 服务。
在我们启动docker container时，没有修改映射的端口，则可以直接使用如上端口
根据你的安全策略和网络配置，你可能还需要考虑其他端口或配置，例如 TLS 加密通信等。确保只开放必要的端口，并采取适当的安全措施来保护你的 RabbitMQ 服务。
1.2、dashboard - 检查 5672、1883 端口 使用telnet如果没有refused则说明端口放开且是通的
telnet 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2bbf49d96eab6068b14b45d4eb4f983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84845961d31d389f51df261e1ebbbc72/" rel="bookmark">
			初始SpringBoot：详解特性和结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡JAVA码农探花：
🔥 推荐专栏：《SSM笔记》《SpringBoot笔记》
🛸学无止境，不骄不躁，知行合一
目录
前言
一、SpringBoot项目结构
1.启动类的位置
2.pom文件
start
parent
打包
二、依赖管理特性
三、自动配置特性
总结
前言 SpringBoot项目结构，特性介绍（常用到的基本都讲解了，很详细，基于官方文档讲解）。
一、SpringBoot项目结构 IDEA创建非常简单，不是主要讲解，我使用的是IDEA2023.3（这里默认你Maven环境都配好了）
创建完成后的文件结构如下：
java：java包下存放的是开发创建的类、接口等。 这里restart是我的工程名，同时它就是项目工程文件夹，开发所创建的包、类基本都在这文件夹下。SpringBoot启动类（这里的启动类是RestartApplication，SpringBoot项目创建完成后默认的启动类名称是首字母大写的项目工程名+Application）放在工程文件夹下，即：工程文件夹 / 启动类。不在嵌套文件夹。resources 存放静态资源文件的地方：html、css、照片、配置文件（properties文件，yaml文件等）。pom.xml 引入依赖文件，用于引入你工程所需要的依赖。 1.启动类的位置 官方建议最佳实战就是将启动类放在工程文件夹下的第一层，不需要再嵌套文件夹。官方说：@SpringBootApplication 注解一般都是注解在启动类上的。它默认会扫描当前类下的所有子包（也就是与当前启动类同级文件夹的包及其下的所有包，如下图的customer、order包及其下的所有包）。例如，如果你正在编写一个JPA应用程序，你的 @Entity 类只有定义在启动类的子包下才能被扫描加载到。这样的好处也显而易见，@SpringBootApplication 默认只会扫描加载你项目工程中的组件。 &lt;span style="color:#000000"&gt;&lt;span style="background-color:#fafafa"&gt;&lt;code class="language-java"&gt;&lt;span style="color:#708090"&gt;//初始创建的SpringBoot项目的启动类都是如下代码：&lt;/span&gt; &lt;span style="color:#0077aa"&gt;import&lt;/span&gt; org&lt;span style="color:#999999"&gt;.&lt;/span&gt;springframework&lt;span style="color:#999999"&gt;.&lt;/span&gt;boot&lt;span style="color:#999999"&gt;.&lt;/span&gt;SpringApplication&lt;span style="color:#999999"&gt;;&lt;/span&gt; &lt;span style="color:#0077aa"&gt;import&lt;/span&gt; org&lt;span style="color:#999999"&gt;.&lt;/span&gt;springframework&lt;span style="color:#999999"&gt;.&lt;/span&gt;boot&lt;span style="color:#999999"&gt;.&lt;/span&gt;autoconfigure&lt;span style="color:#999999"&gt;.&lt;/span&gt;SpringBootApplication&lt;span style="color:#999999"&gt;;&lt;/span&gt; &lt;span style="color:#999999"&gt;@SpringBootApplication&lt;/span&gt; &lt;span style="color:#0077aa"&gt;public&lt;/span&gt; &lt;span style="color:#0077aa"&gt;class&lt;/span&gt; RestartApplication &lt;span style="color:#999999"&gt;{&lt;/span&gt; &lt;span style="color:#0077aa"&gt;public&lt;/span&gt; &lt;span style="color:#0077aa"&gt;static&lt;/span&gt; &lt;span style="color:#0077aa"&gt;void&lt;/span&gt; &lt;span style="color:#dd4a68"&gt;main&lt;/span&gt;&lt;span style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84845961d31d389f51df261e1ebbbc72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bf5f4a7972aa14940a2a37d7e293f2/" rel="bookmark">
			OpenDevin：人人可用的开源AI软件工程师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenDevin，这是一个开源项目，旨在复制 Devin，Devin 是一位自主的 AI 软件工程师，能够执行复杂的工程任务并与用户在软件开发项目上积极协作。该项目希望通过开源社区的力量复制、增强和创新 Devin。
官网：GitHub - skywalk163/OpenDevin: 🐚 OpenDevin: Code Less, Make More
镜像：skywalk163/OpenDevin: 开源Devin - OpenDevin - OpenI - 启智AI开源社区提供普惠算力！
安装 需要python3.11以上版本。是目前见过的对python版本要求最高的软件。Ubuntu下安装python3.11
sudo apt install python3.11 sudo apt install python3.11-venv python3.11 -m venv py311 source py311/bin/activate 不要忘记激活py311环境。
FreeBSD下安装 git clone https://openi.pcl.ac.cn/skywalk163/OpenDevin/ cd OpenDevin # 可以先尝试安装包poetry # pkg install devel/py-poetry 安装需要的库 pip install poetry make build 可惜还是需要docker，在FreeBSD下运行不下去了。若是有朋友有FreeBSD下运行docker的经验，欢迎传授经验。
在Ubunut下安装： git clone https://openi.pcl.ac.cn/skywalk163/OpenDevin/ cd OpenDevin # 安装需要的库 pip install poetry # 安装build时需要的库 pip install pydantic-core==2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21bf5f4a7972aa14940a2a37d7e293f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c1d63dbdd4e1184e7c0b1679851b6f/" rel="bookmark">
			小白必看，总结前端所有主流的构建工具，webpack / vite / roollup / esbuild，包含源码，建议关注&#43;收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章旨在总结前端常见的构建工具，构建工具是前端工程化中的重要的组成部分。
在实际项目中，我们初始化项目，一般是使用脚手架命令一键生成的，比如说使用 create-vue 初始化 vue 项目的时候，就会默认使用 vite 进行打包，同理使用 vue-cli 的时候就是默认使用webpack进行打包（现在vue已经不推荐使用这种方式了）
pnpm create vue@latest 使用脚手架初始化项目简单又方便，很多东西都是现成的，但是这就导致有的时候新手小白不会去认真看打包工具的官网，误以为诸如 webpack 和 vite 等打包工具只能和 vue/ react 等框架绑定使用。
所以我的建议是，可以跟着打包工具的官网，一步一步跟着来详细的学习一下，然后再看你用脚手架初始化的项目，有些东西和配置你才会豁然开朗。
还是需要强调一下，学习一个新的工具，首选的学习资料就是该工具的官网。官网的教程，系统而详细，不要一遇到问题就去百度/博客上搜，得到的结果往往是乱七八糟的。
一、准备工具 1.1 创建仓库 1.1.1 新建 gitee 仓库 我用 gitee 仓库纯粹是因为不方便科学上网，大家也可以使用 github
我的仓库地址是 learn-pack-build 1.1.2 克隆到本地 把你的项目克隆到本地，并新增 .gitignore 文件。
接下来我们就在这个项目中学习各种打包工具。
1.2 前端构建工具总结 前端的构建工具有很多，随着技术的发展有些已经不是主流使用的了，请参考这篇文章，我们还是主要学习主流用的工具比如 webapck。但是在面试的时候，会问你各种工具的区别，所以还是要学习一下现在已经不常用的构建工具比较好，这样方便理解，比如 grunt 和 gulp。多学习一点总是没错的。
我们把这些打包工具主要分为两类，一类是基于任务的打包工具（grunt 和 gulp），第二类是基于模块的打包工具（webpack、vite、esbuild、roollup、parcel、browserify），这 8 个的基础用法我们都要学习一下，才能够更好的理解。
注意，这些工具我们比较习惯称之为构建工具，而不是打包工具，因为打包工具听起来就只是一个简单的打包功能，但是构建工具有很多其他的功能，比如编译、测试、打包、优化、压缩等。还是称之为构建工具比较好。
二、基于任务的构建工具 对于基于任务的构建工具主要就了解以下两个就行，了解即可，知道它们为什么是基于任务的就行。
2.1 grunt Grunt 是一个基于任务的构建工具，通过配置任务列表，实现前端项目的自动化构建和优化。Grunt 的任务通常是串行执行的，但是可以使用一些插件实现并行执行。
Grunt 是一个 JavaScript 任务运行器，它使用配置文件（通常是一个名为 Gruntfile.js 的文件）来定义任务。任务通常是一些插件的集合，用于执行各种操作，如文件的合并、压缩、编译等。Grunt 使用相对较多的配置，因此有些开发者可能觉得其配置较为冗长。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44c1d63dbdd4e1184e7c0b1679851b6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913fa7363b6d7af7621441e05872adb9/" rel="bookmark">
			人工智能——大语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5. 大语言模型 5.1. 语言模型历史 20世纪90年代以前的语言模型都是基于语法分析这种方法，效果一直不佳。到了20世纪90年代，采用统计学方法分析语言，取得了重大进展。但是在庞大而复杂的语言信息上，基于传统统计的因为计算量巨大，难以进一步提升计算机语言分析的性能。2023年首度将基于神经网络的深度学习引入了语言分析模型中，计算机理解语言的准确性达到了前所未有的高度。依然是因为计算量巨大，基于深度学习的语言模型难以进一步提升准确性和普及应用。随着2018年，研究人员将Transformer引入神经网络，大幅缩减了计算量，而且提升了语言的前后关联度，再一次提升了自然语言处理的准确性，并且将计算机处理自然语言的成本大幅降低。
5.2. 概念 随着语言模型参数规模的提升，语言模型在各种任务中展现出惊人的能力(这种能力也称为“涌现能力”)，自此进入了大语言模型(Large Language Model, LLM)时代。大语言模型 (LLM) 指包含数百亿（或更多）参数的语言模型，这些模型在大量的文本数据上进行训练，例如国外的有GPT-3 、GPT-4、PaLM 、Galactica 和 LLaMA 等，国内的有ChatGLM、文心一言、通义千问、讯飞星火等。
早期的LLM多用于自然语言处理领域的问答、翻译，进一步延伸到写文章，编写代码等。随着多模态能力的增加，大语言模型逐步展现出统都一人工智能的趋势，做到真正的通用人工智能(AGI)。LLM逐步成为一个基础模型，人们可以在LLM的基础上做进一步的优化，完成更加专业精细的任务。
5.3. Transformer 5.3.1. 简介 Transformer模型是由谷歌团队在2017年发表的论文《Attention is All You Need》所提出。这篇论文的主体内容只有几页，主要就是对下面这个模型架构的讲解。
5.3.2. 自注意力机制 传输的RNN用于处理系列时，会增加一个隐藏状态用来记录上一个时刻的序列信息。在处理翻译文本时，一个字的意思可能和前面序列的内容相关，通过隐藏状态，RNN能够很好地翻译上下文相关性较大的文本。但是如果文本内容非常大的时候，隐藏状态无法完全包括之前的所有状态(如果包括，其计算量非常巨大，难以实现)。
自注意力机制(Self-Attention)是在注意力机制上优化得来的，其只注意输入信息本身。即输入向量中每一个成员都和其他成员经过一个注意力函数处理之后，形成一个相关性的权重向量表。如：
A
B
C
A
1.0
0.7
0.4
B
0.7
1
0.3
C
0.4
0.3
1
这样一张权重向量表的计算量相比在RNN中隐藏状态的计算量少很多。
通过这个权重向量表，无论需要翻译的原始文件多大，都能够很好地找到之前信息对当前翻译信息的影响，可以翻译得更加准确。
5.3.3. 多头注意力 自注意力机制默认是计算当前内容与上下单个内容的关联性，可以理解为单头注意力。多头注意力(Multi-Head Attention)机制，则是当前内容与前面多个内容同时存在的关联性，这样关联性计算会更加准确。这里的多头，一般为2到128个，这是一个超参数，可由训练者修改。这个超参数设置得越大，语义关注度会更好，但是相应地会增加更多计算力，所以需要综合考虑设置此参数。
5.3.4. 掩码多头注意力 掩码多头注意力(Masked Multi-Head Attention)提供掩码表。在解码器中，当生成第t个输出时,模型只应该关注t时刻之前的输入序列,而不应该关注未来的输入。这样不仅提升准确性，也减少计算量提升性能。
5.3.5. 残差与归一化 残差与归一化(Add &amp; Norm)，它通常出现在Transformer的各个子层之后。它包含两个主要操作:
Add (残差连接)，将当前子层的输出与该子层的输入相加，从而缓解深层网络训练过程中的容易出现的梯度消失问题。Norm (层归一化)，矩阵相乘容易变得越来越大，对上一步的结果进行归一化操作，可以降低数值的大小，在模型量化的时候，可以节省空间，另外归一化结果也可以加速模型收敛。 5.3.6. 前馈神经网络 前馈神经网络（Feed Forward ），最基础的神经网络，其由输入层、多个隐藏层和输出层组成的简单前馈结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913fa7363b6d7af7621441e05872adb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb1cf7dafa2ec27dc514b63a15c75aa/" rel="bookmark">
			【C&#43;&#43;】模版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、泛型编程二、函数模板2.1 函数模板概念2.2 函数模板格式2.3 函数模板的原理2.4 函数模板的实例化2.5 模板参数的匹配原则 三、类模板3.1 类模板的定义格式3.2 类模板的实例化 四、非类型模板参数五、模板的特化5.1 概念5.2 函数模板特化5.3 类模板特化5.3.1 全特化5.3.2 偏特化5.3.3 类模板特化应用示例 六、模板分离编译6.1 什么是分离编译6.2 模板的分离编译6.3 解决方法 七、模板总结结尾 一、泛型编程 如何实现一个通用的交换函数呢？
void Swap(int&amp; left, int&amp; right) { int temp = left; left = right; right = temp; } void Swap(double&amp; left, double&amp; right) { double temp = left; left = right; right = temp; } void Swap(char&amp; left, char&amp; right) { char temp = left; left = right; right = temp; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb1cf7dafa2ec27dc514b63a15c75aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0d1738bd26554c756f750d5888c908/" rel="bookmark">
			Chrome浏览器插件之 JSON View（json数据格式化显示)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享原因：
Java 开发过程中，我们在访问接口的过程中难免需要使用到浏览器来访问接口和查看返回数据，本文主要讲解返回的数据为json格式的时候，我们看到浏览器返回的数据是一长串json，没有任何的格式，不方便观看数据，今天我这里主要分享一个关于Google Chrome浏览器的插件。如果使用的方便记得给我分享这篇文章也来个三联哦，点赞，收藏，评论good
Google Chrome浏览器没有插件返回数据的样式
示例，请大家见谅，为了保证数据安全都涂鸦了
Google Chrome浏览器添加插件返回数据的样式
分享前先介绍大家两个网址，可以在线的查看json数据格式化数据，另外网站里面还有更多语言格式的功能，大家自行学习使用
https://www.json.cn/https://www.sojson.com/ JSON View简介
JSON View是Google Chrome浏览器中的一个针对json字符串的格式化插件，方便前后端开发人员以树形结构查看数据
版本说明
Google Chrome浏览器：108.0.5359.125（正式版本） （64 位）
JSONView插件版本：0.0.32.2
安装方式
A: 下载JSONView插件
B: 解压到你的熟悉的文件夹中，我这里是D盘
具体步骤
点击浏览器右上角的三个点，然后点击设置点击扩展程序打开右上角的开发者模式找到自己解压后的文件位置，我这里是放在D盘找到文件路径，点击WebContent这个文件夹就行，右下角点击选择文件夹添加成功，然后确认右下角的打开按钮是蓝色的就可以使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969265307548a645d847161fc8ab8d1b/" rel="bookmark">
			c# 开发串口调试助手 Visual Studio 2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、串口调试工具作用 串口调试助手是用于在开发、测试和调试串口通信应用程序时进行串口数据的监视和交互的工具。它通常具有以下功能：
1. 串口参数设置：允许用户设置串口的波特率、数据位、校验位、停止位等参数。
2. 串口连接管理：允许用户打开、关闭串口连接。
3. 数据发送：允许用户手动输入或从文件中加载数据，并通过串口发送到目标设备。
4. 数据接收：显示从串口接收到的数据，并支持数据的解析和显示。
5. 数据记录：允许用户将接收到的数据保存到文件中以供后续分析和查看。
6. 数据分析：提供数据格式化、解析和显示的功能，便于用户理解和分析串口通信数据。
7. 数据监视：实时监视串口通信数据，包括发送和接收的数据量、速率等信息。
8. 自定义操作：支持用户自定义脚本或命令，以便执行特定的串口操作或测试。
总的来说，串口调试助手是串口通信开发过程中的一个重要辅助工具，能够帮助开发人员进行串口通信的测试、调试和分析。
二、开发工具 语言：C# 开发环境：Visual Studio 2019
三、开发步骤 1. 界面设计
- 使用 Windows Forms 或 WPF 进行界面设计。
- 设计包含串口参数设置、数据发送、数据接收、数据显示等功能的用户界面。
2. 串口通信
- 使用 `System.IO.Ports` 命名空间中的 `SerialPort` 类进行串口通信。
- 实现串口的打开、关闭、参数设置等功能。
- 监听串口数据的接收事件，并进行相应的处理。
3. 数据发送
- 提供文本框或其他输入控件，允许用户手动输入待发送的数据。
- 实现发送按钮点击事件，将数据通过串口发送。
4. 数据接收与显示
- 使用串口的 DataReceived 事件来监听串口数据的接收。
- 将接收到的数据显示在界面上的文本框或数据显示控件中。
- 可以对接收到的数据进行解析、格式化，方便用户阅读。
5. 数据记录与保存
- 提供数据记录功能，允许用户将接收到的数据保存到文件中。
- 实现保存按钮点击事件，将接收到的数据写入到指定的文件中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/969265307548a645d847161fc8ab8d1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141582e897b7a6a61342cddf492eb894/" rel="bookmark">
			解决前端笔记本电脑屏幕显示缩放比例125%、150%对页面大小的影响问题--数据可视化大屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期在工作中遇到一个问题，记录一下，在项目上线之后，遇到一个问题，即缩放到90%时，页面字体比默认的100%字体大，一开始毫无头绪，经过一番的Google...Google...Google....，终于找到了解决方法，这是因为大多数笔记本电脑默认的缩放比例为125%或者是150%，所以就出现了在本身台式电脑（默认100%）上开发出来的页面都是按照100%比例来开发的，之后在笔记本电脑上打开缩放比例的时候会出现字体大小显示不合理的问题，这种问题主要是因为device-pixel-ratio导致的
原文链接：https://blog.csdn.net/m0_46318298/article/details/133786669 1.新建一个js文件
// detectZoom.js export const detectZoom = () =&gt; { let ratio = 0 const screen = window.screen const ua = navigator.userAgent.toLowerCase() if (window.devicePixelRatio !== undefined) { ratio = window.devicePixelRatio } else if (~ua.indexOf('msie')) { if (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) { ratio = screen.deviceXDPI / screen.logicalXDPI } } else if ( window.outerWidth !== undefined &amp;&amp; window.innerWidth !== undefined ) { ratio = window.outerWidth / window.innerWidth } if (ratio) { ratio = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141582e897b7a6a61342cddf492eb894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956542ddd5e4c021d32f61dde34d33bf/" rel="bookmark">
			长文干货！老程序员测评文心一言4.0模型代码能力！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：老程序员聊聊AI和国产大模型
第一关：代码质量和可用性——写个可运行的游戏代码
第二关：需求理解和记忆能力——多轮对话下的任务能力
总结
前言：老程序员聊聊AI和国产大模型 大家好，我是一名老程序员了，大模型出来后我算是一直在尝试各种AI工具，尤其是AI辅助研发的方向（可能有点焦虑？），包括上个月的AI程序员Devin发布我也在关注，大模型的能力发展太快了，我还是想努力跟上。
我个人一直支持国产大模型，也算文心一言的老用户啦，去年3月刚内测的时候就在用了，那时候特振奋，想着国内终于有一款大模型了，刚开始用的时候很坎坷啊，用起来一直达不到预期。
不过文心一言的模型能力还是在肉眼可见地变好，我现在的情况是付费使用文心一言4.0模型（免费的3.5模型基本不用了），我的感官是文心一言4.0模型对比3.5在各个方面是有明显提升的，迭代速度也更快（可能是商业化后会存在训练资源倾斜？），我看各大平台很少有一言4.0模型的测评，所以今天专门写一篇。
图片由文心一言4.0生成，图个乐 我平时用的最多的还是代码和文本生成（周报写文档你懂的），偶尔玩玩文生图，今天主要给大家测一测文心一言4.0模型的代码能力！
大模型的代码能力可以拆解的维度很多，我今天主要关注的是代码生成质量和可用性，需求理解能力和记忆能力2个方面。
第一关：代码质量和可用性——写个可运行的游戏代码 废话不多说，我们先看看代码的生成质量和可用性——写一个五子棋吧：
我去测试AI的代码能力的use case是——我会让AI写个小游戏，底层逻辑是AI需要理解游戏的规则，并且转译成代码，还必须是可运行的代码，这可能是程序员视角下的“多模态”能力吧，哈哈。
所以我让文心一言4.0模型帮我写一个能跑起来的【五子棋】游戏代码，我们看看生成的代码质量（对话截图参考下方）
那么关键来了，是否可以运行呢？
我们直接copy下来在开发环境中运行，运行起来没问题，定义好了2个棋手交替下棋，一方到5个棋子后游戏判定结束，可以看下方视频截屏。
五子棋
第一关，代码质量和可用性，文心一言4.0模型测试通过～
第二关：需求理解和记忆能力——多轮对话下的任务能力 下面我们看文心一言4.0模型的需求理解能力和记忆能力，测试开启：
很多时候我们在AI代码生成上不是一问一答就结束了，最常见的情况反而是——要求AI不断调整生成的代码，这对AI的记忆和需求理解能力提出要求，下面我会模拟这个情景：
我们看看4.0模型能不能帮我写一个【机器学习代码】，简单来说是对【单层感知机】做一个正负向分类的训练，prompt+回复截图参考下方截图：
我向大模型提问有没有更好的方式实现我的诉求，这考验4.0模型是否真的理解我在做什么，以及对机器学习的了解，我们接着往下看：
文心一言提出了有神经网络和支持向量机2种方法，给出的说明说明很具体很有信息量，说明对我的需求理解程度是在线的，以及展示了对复杂机器学习算法问题的解决能力。
那我们下面让4.0模型直接按照【支持向量机】再帮我写一个新的代码呢？4.0模型还会记得住我们在讨论什么吗？
代码基本可用，因为数据集太小，还专门提示我没必要拆分训练集和测试集（大数据集下通常会做拆分），算是比较贴心了。
所以第二关，需求理解和记忆能力，4.0模型通过！
总结 整体看下来，文心一言4.0模型在代码生成质量和可用性，需求理解能力和记忆能力2个方面表现不错，我自己用的时候基本能满足我的代码诉求，当然我自己还会用4.0模型帮我写一些工作汇报和其他工作文档，中文能力也很不错，中文能力也确实一直是文心一言的核心竞争力啦。
最近文心一言付费会员还上线了【工具版】，上线了Agent框架下的复杂任务的规划、调用工具的能力，算是一个亮点，下次再和大家分享。
如果大家也想快速使用文心一言4.0模型，可以👉👉点击开通文心一言4.0模型，或扫描下面这个二维码开通哦👇👇
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f296868b197bad83a7810dfac287ede3/" rel="bookmark">
			前端本地存储 cookie localStorage sessionStorage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、cookie
概念：
Cookie是一种在客户端存储数据的机制，它将数据以键值对的形式存储在用户的浏览器中。
通俗来说，客户端与服务端的交互存储的机制。Cookie 是不安全的，原因是它本身没有采用任何加密机制。通过 HTTPS 来传输 Cookie 数据是安全的，它与 Cookie 本身无关，与 HTTPS 协议相关。
作用：
标记一般来自服务端。
cookie的属性：
名称和值：每个Cookie都有一个名称和对应的值，以键值对的形式表示。域（Domain）：Cookie的域属性指定了可以访问Cookie的域名。默认情况下，Cookie的域属性设置为创建Cookie的页面的域名。路径（Path）：Cookie的路径属性指定了可以访问Cookie的路径。默认情况下，Cookie的路径属性设置为创建Cookie的页面的路径。过期时间（Expires/Max-Age）：Cookie的过期时间属性指定了Cookie的有效期限。可以通过设置Expires或Max-Age属性来定义过期时间。过期时间可以是一个具体的日期和时间，也可以是一个从当前时间开始的时间段。安全标志（Secure）：Cookie的安全标志属性指定了是否只在通过HTTPS协议发送请求时才发送Cookie。同站点标志（SameSite）：Cookie的同站点标志属性指定了是否限制Cookie只能在同一站点发送。可以设置为Strict（仅允许来自当前站点的请求携带Cookie）或Lax（允许部分跨站点请求携带Cookie） 应用场景
Cookie在Web开发中有多种应用场景，包括：
会话管理：Cookie常用于存储会话标识符，以便在用户访问不同页面时保持会话状态。
身份验证：Cookie可以用于存储用户的身份验证凭证或令牌，以便在用户下次访问时自动登录。
个性化设置：Cookie可以用于存储用户的个性化首选项，例如语言偏好、主题设置等。
追踪和分析：Cookie可以
用于追踪用户的行为和进行网站分析，例如记录用户访问的页面、点击的链接等
// 设置Cookie document.cookie = "username=John Doe; expires=Fri, 31 Dec 2023 23:59:59 GMT; path=/; secure; SameSite=Strict"; // 读取Cookie const cookies = document.cookie.split("; "); for (let i = 0; i &lt; cookies.length; i++) { const cookie = cookies[i].split("="); const name = cookie[0]; const value = cookie[1]; console.log(name + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f296868b197bad83a7810dfac287ede3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc6b27ae573c8ae41064b164e7cdf6c/" rel="bookmark">
			什么工具可以ai写作一键生成？毕业论文就靠它们来解决了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毕业季来临，撰写论文成为众多大学生的一大困扰。
幸而，ai写作论文软件崭露头角，凭借高效搜索、严谨架构和智能优化语言等特性，为学子们排忧解难，助力他们在论文撰写路上披荆斩棘，轻松应对学术挑战。
如果你还不知道有哪些ai写作工具可以帮我们撰写论文，那一定码住本文，下面，我来为你揭晓答案。
第一款——【AI创意生成家】
▷智能创作引擎：AI创意生成家利用先进的AI算法，实现主题理解和创意拓展，可根据我们提供的关键词或标题快速生成论文提纲和初步内容框架，大大缩短构思阶段的时间。
▷独特见解生成：其强项在于挖掘深层次关联和新颖观点，有助于我们在海量文献中提炼出独特的研究视角，丰富论文内涵，避免重复和陈词滥调。
▷免费生成使用：这款工具的AI写作功能可以免费尝试，简单易生成。
第二款——【Articoolo】
自动化内容创建：Articoolo的核心竞争力在于其自动化文章创作能力，只需输入相关主题，系统便能生成一篇结构完整、逻辑严密的文章，特别适用于论文初稿的快速构建。
高效资源整合：通过对网络资源的整合与智能解读，Articoolo能够结合学术背景资料，生成具有权威性和可信度的文本片段，为论文增色添彩。
第三款——【Writer】
▷实时协同编辑：Writer提供实时的语言修正和优化服务，可在我们撰写论文的同时提供详尽的语法、拼写及风格指导，有效提升论文的专业性与合规性。
▷内容优化功能：不仅能识别基本错误，还能深度分析文章的句式结构、用词多样性和可读性指标，引导我们提升文本质量，符合学术论文严谨而富有表达力的要求。
第四款——【JasperAI】
▷高性能内容生成：凭借前沿的自然语言处理技术，JasperAI能够根据我们的需求撰写高度定制化的学术内容，涵盖各种类型的论文部分，如引言、方法论、讨论等。
▷精准领域适应：JasperAI具备跨学科的知识库，能够在特定领域内提供精准的信息支持，帮助大家在撰写专业论文时保持学术严谨与深度。
第五款——【Grammarly】
▷全面的语言校验：Grammarly以其全面的语法和拼写检查闻名，尤其适合在论文写作过程中及时纠正错误，确保书面表达准确无误。
▷高级风格建议：除了基础纠错，Grammarly还提供进阶的写作建议，比如消除冗余、改善句子结构和提升词汇层次感，帮助我们达到学术论文应有的严谨和专业标准。
第六款——【ProWritingAid】
▷深度文本分析：ProWritingAid不仅包含基础的语法和拼写检查，更注重深层次的文本质量分析，如句子长度、冗余词汇、被动语态等，有利于我们精细化雕琢论文。
▷教育与提升：通过详细的报告和针对性改进建议，ProWritingAid扮演着写作教练的角色，帮助我们不断提升学术写作技能，养成良好的表达习惯。
第七款——【Hemingway Editor】
▷简洁化语言倡导者：Hemingway Editor专注于简化和澄清复杂句子，采用颜色编码系统直观地提示冗余、过长或难解的句子，促进论文语言的简洁易懂。
▷可读性提升工具：强调书面表达的清晰度和力度，通过降低阅读难度，确保读者能迅速抓住论文主旨，这对于学术交流和知识传播至关重要。
第八款——【Wordtune】
▷智能改写助手：Wordtune擅长根据上下文对现有句子进行智能改写，提供多种替换方案，方便大家在不改变原意的前提下优化论文中的表达，提高文章流畅性和一致性。
▷多元语境适配：灵活应对不同的学术语境和论述风格，无论是在正式论证、概念解释还是数据解读环节，Wordtune都能帮助我们找到最合适的话语表达，使论文更具说服力。
好了，关于ai写作论文软件的分享就到这里啦，上述这些工具是不是个顶个的好用呢？不过我在这里也要提醒大家，工具虽好，但它们也只能起到辅助作用，写论文的关键还是要靠自己，共勉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837c4961bf762ecf19887ea1fcb86297/" rel="bookmark">
			sd软件下载安装教程（Stable Diffusion绘画软件配置要求）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion（SD）是一款基于文本生成图像的AI绘画工具，它对电脑硬件有一定的要求。以下是SD绘画软件的配置要求：
1. 显卡（GPU）：
显卡是SD运行的关键，需要一张性能足够强大的独立显卡来提供算力进行绘制。
支持的显卡芯片有Nvidia/AMD/Intel Arc/Apple M。
最低配置建议为4GB以上显存的显卡，如RTX3050。
推荐配置为8GB显存或更高，以便处理更高分辨率的图像和进行模型训练。
对于更流畅的体验和更高效率的图像生成，建议使用如RTX4050、RTX3060、RTX4060等显卡。
2. 内存（RAM）：
至少需要8GB的内存，但为了更好的性能和更流畅的体验，建议使用16GB或更多。 3. 硬盘存储：
需要有足够的硬盘空间来保存程序、模型和生成的图像文件。
至少需要20GB的保存空间，且最好是SSD，以加快读写速度。
4. 处理器（CPU）：
x86架构的Intel或AMD处理器皆可，若为Mac电脑建议使用搭载M系列芯片的机型。 5. 操作系统（OS）：
支持主流的Linux发行版，如Ubuntu 18.04或更高版本，亦支持Windows 10/11和macOS Monterey (12.5)或更高版本。 6. 网络连接：
需要可以正常连接到GitHub和互联网的网络，以便下载和更新模型及依赖。 7. 前置应用：
对于Windows系统，需要安装Python、Git和CUDA。
对于Mac系统，需要安装相应的前置应用以确保SD的正常运行。
请注意，这些配置要求可能会随着SD软件的更新和优化而变化，建议在安装前查看最新的官方文档或社区指南以获取最准确的信息。
要下载和安装Stable Diffusion（SD）软件，你可以遵循以下步骤：
1. 选择合适的安装包：
根据你的操作系统和需求，你可以选择秋叶整合包，这是一个为零基础用户设计的一键安装包，它支持SDXL，预装了多种必须模型，无需安装git、python、cuda等任何内容，无需任何配置解压即用。 2. 下载启动器和依赖：
如果你的电脑是第一次安装，需要先下载启动器运行依赖。安装依赖后，再解压秋叶整合安装包。 3. 模型的选择和下载：
根据需求选择性下载推荐大模型文件夹中的模型，并将其放置在相应的目录下，例如：`\sd-webui-aki-v4\models\Stable-diffusion`。
同时，下载ControlNet模型，并将其内容放置在`\sd-webui-aki-v4\models\ControlNet`目录下。
4. 安装Python和Git：
尽管秋叶整合包内置了Python环境和Git，但某些情况下你可能仍需要单独安装Python 3.10.6版本和Git。 5. 下载SD源码：
你可以从GitHub上下载SD的源码，选择一个磁盘空间大一点的地方作为SD的存储目录。 6. CUDA和GPU的配置：
确保你的电脑配备至少8GB显存的GPU，最好是12GB显存的显卡。
根据你的显卡支持的最高CUDA版本，下载对应版本的CUDA安装包。
7. 运行启动器：
双击打开A启动器程序即可启动SD。如果遇到弹出窗口，则需要安装启动器运行依赖，点击Yes即可自动跳转下载。 8. 启动和使用SD：
启动成功后，SD会自动在浏览器中打开一个新的网页。你可以在网页中输入关键词，如“一个美女”，点击生成，即可得到效果图。 9. 汉化和双语对照：
如果需要中文界面，可以在Extensions中加载汉化插件，并在设置中更改为中文界面。 10. 下载和管理模型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/837c4961bf762ecf19887ea1fcb86297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cba2ee23ca1b7b4b73eb503c0f000c/" rel="bookmark">
			1.Flink1.19、Flink1.18源码编译及本地运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节课核心：教会大家如何编译flink以及本地运行Standalone 1.环境准备 本地需要安装
idea(intelliJ IDEA 2023.3.4)
git(Git-2.34.1-64-bit.exe)
maven(3.8.8)
jdk(1.8)
scala(2.12.7)
2.下载源码 2.1.1 命令行方式
下载代码请复制以下命令到终端执行(本地需要安装git)
git clone https://gitee.com/apache/flink.git
2.1.2 idea方式 1.点击idea File—&gt;New—&gt;Project from Version……
2.url：https://gitee.com/apache/flink.git
Directory:选择要存放的目录
点击clone
4.打开项目的时候勾选Trust projects
2.1.3修改jar下载路径
1.idea打开项目修改一下Maven下载路径，默认下载到C盘
注意：只需要修改maven 中的 Local repository，默认会在C盘，其他不用修改
2.1.4.修改分支地址为flink1.19 1.切换分支，首次需要Fetch一下
2.选择release-1.19分支
3.Checkout检出
2.1.5.设置jdk版本 1.点击File—&gt; Project Structure—&gt;Project设置Jdk版本（如下图）
注意：设置JDK版本1.8或者1.8以后
2.1.6.设置scala版本 1.点击File—&gt; Project Structure—&gt;Platfrom Settings —&gt; Global Libraries—&gt;ScalaSdk 设置scala版本（如下图）
2.Choose Modules中Ctrl+A选择所有的模块。
3.源码编译 1.跳过测试、勾选fast
2.clean 先清除一下
3.install 开始打包
4.如果每个模块都是Success,那就代表打包成功
4.启动StandaloneSession模式 4.1.环境配置 1.创建两个文件夹a_lib、a_conf，方便后面使用
2.源码编译完毕后在flink-dist下会有配置文件以及编译后的jar包
3.将F:\new\flink\flink-dist\target\flink-1.19-SNAPSHOT-bin\flink-1.19-SNAPSHOT\lib，lib下的jar拷贝到我们创建的a_lib下
将F:\new\flink\flink-dist\target\flink-1.19-SNAPSHOT-bin\flink-1.19-SNAPSHOT\conf下的配置文件拷贝到我们创建的a_conf下
4.修改config.yaml
操作步骤如下图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75cba2ee23ca1b7b4b73eb503c0f000c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b5a767e6018ce3459c154b9b9797de/" rel="bookmark">
			Java 实现自定义注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、@interface 关键字 我们想定义一个自己的注解 需要使用 @interface 关键字来定义。
如定义一个叫 MyAnnotation 的注解：
public @interface MyAnnotation { } 二、元注解 光加上 @interface 关键字 还不够，我们还需要了解5大元注解
@Retention@Target@Documented@Inherited（JDK8 引入）@Repeatable（JDK8 引入） 1) @Retention 指定注解的生命周期 @Retention(RetentionPolicy.SOURCE) 其中Retention是一个枚举类:
RetentionPolicy.SOURCE : 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃(.java文件)RetentionPolicy.CLASS :注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期(.class文件)RetentionPolicy.RUNTIME: 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在(内存中的字节码) 2) @Target指定注解可以修饰的元素类型
@Target(ElementType.Field) ElementType.ANNOTATION_TYPE - 标记的注解可以应用于注解类型。ElementType.CONSTRUCTOR - 标记的注解可以应用于构造函数。ElementType.FIELD - 标记的注解可以应用于字段或属性。ElementType.LOCAL_VARIABLE - 标记的注解可以应用于局部变量。ElementType.METHOD - 标记的注解可以应用于方法。ElementType.PACKAGE - 标记的注解可以应用于包声明。ElementType.PARAMETER - 标记的注解可以应用于方法的参数。ElementType.TYPE - 标记的注解可以应用于类的任何元素。 3）@Documented
指定注解会被JavaDoc工具提取成文档。默认情况下，JavaDoc是不包括文档的
4）@Inherited
表示该注解会被子类继承，注意，仅针对类，成员属性、方法并不受此注释的影响。
5）@Repeatable
表示注解可以重复使用，为了解决同一个注解不能重复在同一类/方法/属性上使用的问题。
其中最常用的就是 @Retention 跟 @Target。
三、简单实现 例如实现一个简单，在标记注解的地方打印一句日志。
定义一个 MyAnnotation 注解，并且定义一个属性 message 默认值是 ”aaa“。先将该注解加到字段上，看能不能获取到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b5a767e6018ce3459c154b9b9797de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e441474c2cb90b6fe09bdff7dfea31/" rel="bookmark">
			探索Spark-MovieLens：基于大数据的电影推荐系统实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索Spark-MovieLens：基于大数据的电影推荐系统实践 项目简介 是一个由Jaume Jadianes开发的开源项目，它利用Apache Spark和MovieLens数据集构建了一个实时的电影推荐系统。这个项目旨在展示如何在大规模数据处理中应用机器学习算法，特别是协同过滤，来提供个性化的用户体验。
技术分析 Apache Spark 该项目的核心是使用Apache Spark，这是一个用于大规模数据处理的快速、通用且可扩展的开源框架。Spark通过其内存计算能力，比传统的Hadoop MapReduce更快地处理数据，对于实时或流式数据分析尤其适用。
协同过滤 协同过滤是推荐系统中的经典算法，Spark-MovieLens利用它来挖掘用户与电影之间的隐含关系。通过找出具有相似观影口味的用户群体，系统可以预测用户可能对未观看的电影产生多大的兴趣，并据此进行个性化推荐。
MovieLens 数据集 MovieLens数据集是一个广泛使用的电影评分数据集，包含用户的电影评分、电影元信息等。在这个项目中，这些数据被用来训练和验证推荐模型。
应用场景 Spark-MovieLens项目可以被应用于各种需要个性化推荐服务的场景，如在线视频平台、电商网站、音乐或书籍推荐系统。不仅可以帮助用户发现他们可能喜欢的新内容，还能提高用户满意度和平台的用户黏性。
项目特点 实时性：系统能够处理实时评分并即时更新推荐结果。可扩展性：基于Spark的设计使得它可以轻松适应更大规模的数据和更复杂的模型。模块化：项目的结构清晰，易于理解，方便开发者对其进行修改和优化。教育价值：对于学习大数据处理和推荐系统的学生或者开发者，这是一个很好的实战项目，能够直观理解协同过滤算法及其在实际应用中的效果。 结语 Spark-MovieLens为大数据领域的实践者和学习者提供了一个有价值的参考案例。通过这个项目，你可以深入了解如何将Apache Spark与机器学习相结合，以创建高效、个性化的推荐系统。如果你正在寻找一个动手实践的大数据项目，或者想要提升你的Spark和推荐系统知识，那么这个项目无疑是一个绝佳的选择。现在就探索Spark-MovieLens，开启你的大数据推荐之旅吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d1e2de7fadcb11866b166f9d8e4871/" rel="bookmark">
			HTML&#43;CSS&#43;JS实现京东首页[web课设代码&#43;模块说明&#43;效果图]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Web前端大作业html+css静态页面–掌****有限公司
Web前端大作业起点小说静态页面
Web前端大作业网易云页面
Web前端大作业商城页面
Web前端大作业游戏官网页面
Web前端大作业网上商城页面
HTML+CSS淘宝首页[web课设代码+模块说明+效果图]
文章目录 系列文章目录前言一、HTML结构图二、CSS部分代码图三、每部分效果图展示3.1 导航栏、头部搜索栏效果图3.2 中心区域商品展示效果图3.3 秒杀区和特惠区域效果图3.4 页脚（底部导航、版权信息、技术支持等内容）效果图 总结 前言 用时差不多一个星期，抽空把前端课设做完了。html代码量800+行，css代码量1200+行，因为有轮播图(加了100多行js代码)。京东首页用了2000行代码。里面避免不了有冗余的代码。大多数的常见知识点均已运用。每个css样式修饰都有注释，阅读起来会很方便。
资源下载链接如下：京东首页web前端课设（HTML+css+js）
一、HTML结构图 每个部分都用div包裹布局，并且大部分div都会标明注释信息，易于阅读。
二、CSS部分代码图 单独文件index.css存放所有的css样式。开发时是一部分一部分进行在html页面修饰（易于调整数值），修饰完成后才会将这部分代码放到css文件中。
三、每部分效果图展示 3.1 导航栏、头部搜索栏效果图 3.2 中心区域商品展示效果图 3.3 秒杀区和特惠区域效果图 这里的京东秒杀大家熟悉吗？我在这篇博文里讲过哦~仿京东秒杀倒计时 JS[代码+详细讲解+效果图]
3.4 页脚（底部导航、版权信息、技术支持等内容）效果图 最底部，就是个商家的信息…
总结 自己写代码过程中也是把常见的知识点都运用了一遍，尤其是对于相对定位、绝对定位、样式布局方面有了很大的了解，基本把京东首页的布局分析的差不多了，主要还是div布局方面，其他的修饰也比较简单，仔细点看哪里鼠标经过会变颜色，鼠标变成小手等。感觉越写越熟练。。。过几天我会把完整代码+图片素材发上来供大家参考。每个模块都写了注释。。。用的最多的就是ul-li，今后的开发也会发现，列表是必不可少的。几乎每个页面都需要用到。对今后的学习会有很大的帮助！！！
资源下载链接：京东首页web前端课设（HTML+css+js）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fa09d7199608dc554f6dbc74cfe119/" rel="bookmark">
			算法中的时间复杂度logN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是对数 软件开发中通过合理的算法能减小计算的空间复杂度和时间复杂度，有的复杂度为logN，什么是logN？通过毕业后的努力工作基本都忘了。
对数 首先，logN被称为对数，是在幂函数的基础上衍生的。例如：3²=9，可以得到log以3为底的9的对数等于2，可以理解为3相乘等于9，这里是两个3相乘，所以结果就是2。
比较经典的二分查找法的时间复杂度就是O(logN)（以2为底），若是用迭代的方式时间复杂度是O（N），N是数据量的个数；我们可以假设若是个数有100个，每一次查询的时间用1毫秒，二分查找法最坏需要查询7毫秒，用迭代法最坏需要100毫秒。若是10亿次呢？二分查找法最坏只需要30毫秒，迭代法最坏需要277多个小时，这样一比较，高下立判，还是算法好。
平时开发中设计算法的时候大多是需要和业务强相关的场景，其他的例如排序和查找都已经有合适的工具类了，为了更好的应用指导算法原理是大有裨益的。
附一张《算法图解》中的截图。
电脑中计算机求对数 电脑中只有log（以10为底）和ln（以e为底），
根据换地公式计算：求以2为底8的对数，可以log8%log2=3
原文链接：https://blog.csdn.net/zhanwuguo8346/article/details/118499545
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8db3df5142030a087997d998b90c67a/" rel="bookmark">
			Postman测试金蝶云星空Webapi【协同开发云】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Postman测试金蝶云星空Webapi【协同开发云】环境说明业务背景大致流程具体操作请求登录接口请求标准接口查看保存提交审核反审核撤销 请求自定义接口参数是字符串参数是实体类单个实体类实体类是集合 其他 Postman测试金蝶云星空Webapi【协同开发云】 环境说明 金蝶协同开发云环境
工作目录空间：D:\WorkSpace\开发商码
协同账套映射到本机的1200端口
//本机K3网址 http://localhost:1200/k3cloud 业务背景 基于金蝶云星空提供的接口测试，交付之前或者联调之前开发者先自测，即使纠错，提高效率。
大致流程 先请求登录接口，获得token后再请求标准webapi或者自定义接口，这样上下文才不会空。
具体操作 请求类型： POST
地址格式：http://localhost:1200/k3cloud/对应的方法拼接结构体
请求登录接口 请求地址
http://localhost:1200/Kingdee.bos.webapi.ServicesStub.authservice.validateuser.common.kdsvc 请求json：
{ "acctid":"账套id", "userName":"账号", "password":"密码", "lcid":2052 } accid：账套ID
userName：用户名
password：密码
lcid：语言【2052代表中文】
请求头：
返回以上信息代表登录成功。
请求标准接口 查看 请求方式：POST
请求地址：
http://localhost:1200/Kingdee.BOS.WebApi.ServicesStub.DynamicFormService.View.common.kdsvc 请求体构建json：
{ "formid":"XXXX_AS_ProductLibrary", "data":{ "CreateOrgId": 0, "Number": "ZDY00000009HDC", "IsSortBySeq": "false" } } 响应结果：
保存 请求方式：POST
请求地址：
http://localhost:1200/Kingdee.BOS.WebApi.ServicesStub.DynamicFormService.Save.common.kdsvc 请求体构建json：
{ "formid":"XXXX_AS_ProductLibrary", "data":{ "NeedUpDateFields": [], "NeedReturnFields": [], "IsDeleteEntry": "true", "SubSystemId": "", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8db3df5142030a087997d998b90c67a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/427/">«</a>
	<span class="pagination__item pagination__item--current">428/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/429/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>