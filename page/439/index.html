<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c3079e46c2b5f11712037241b07458/" rel="bookmark">
			浅谈前端八大UI库，web开发基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是本博客所涉及到的八个UI库
Element UI
vuetify
Ant Design
Bottstrap
layui
Vant UI
Framework7
WEUI
这是我从前端的众多 ui 库中选出来了八个，但是并不是说没有被列出来的 UI 库都不好，没有这个意思，不要把我置身于水深火热之中哈。这里之所以选出这个八个，是因为咱们的一个篇幅关系，不可能把所有的好的前端UI库都拿出来说一遍，所以我就挑出来了我个人感觉八个比较有代表性的 UI 库。那么下面我们一个一个来看。
Element UI
开发团队：饿了么前端 官网：https://element.eleme.cn/#/zh-CN github（ star：44.1k ）：https://github.com/ElemeFE/element 特性： ​ Element-UI 是目前针对于 Vue 开发 PC 端项目的时候所使用到的一个主流 UI 库。在座的有学习 Vue 开发的同学或多或少应该都知道 Element-UI 。那我们就从它开始聊。
​ 大家有没有想过，对于一个 UI 库来说，它是如何被广大的开发者所接受的？或者说它是如何被用户所接受的？
​ 我认为，一个产品，具体到当前就是 Element-UI 这个库，这个库对于我们开发者来说就是产品，我们开发者就是它的用户。而一个产品之所以可以被用户所接受，所依赖的无非是三点：
**1. 产品的文档对于用户来说足够清晰
2. 产品的功能对于用户来说足够简单
3. 产品的 UI 对于用户来说足够友好**
​ 什么意思呢？我们一个一个来解释。
​ 首先我们来看第一个：产品的文档对于用户来说足够清晰。这是什么意思呢？大家想一下当我们买了一个东西的时候，最初我们不知道这个东西是怎么用的？那么我们一般都会去看一下它的说明书，或者直接去网上搜索一些这个产品的资料，对吧。那么这个时候如果它的说明书写的不清不楚，甚至有些地方写的根本就不对。那么你如果想要把这个东西使用熟练，是不是要花费特别大的精力。也就是我们开发者常说的，这个框架拥有了过高的学习成本，或者说这个框架学习曲线过于陡峭，不够平滑。那么这样的话无疑会劝退一部分用户。对吧。
​ 所以说如果一个框架如果想要被开发者广为接受，那么一个清晰的文档肯定是首要的条件。那么对于 Element-UI 来说，它的一个文档就比较清晰。在组件部分，从安装 Element-UI 到各个组件的效果描述的都是非常清楚的，每一步应该如何做，这样做会产生什么样的结果都在文档上描述的很清楚。这个就是一个清晰的产品文档。
​ 第二条：产品的功能对于用户来说足够简单。这一条也好理解。对于我们开发者来说，当我们使用一个框架的时候，我们想要的是什么？我们想要一个框架：你的功能要足够的复杂，但是你的接口要足够的简单。什么意思呢？大家可以参照一下自己的手机。现在智能手机的功能已经非常复杂了。可以打电话，可以玩游戏，可以看电影。但是一旦你熟悉了它之后，它使用起来确实非常简单的。你不会去关心它的功能是如何实现的，你关心的只是是否可以通过简单的操作来完成复杂的功能。就是这个道理放到我们开发者身上也一样。我不关心你组件封装的如何复杂，我所关心的只是你暴露出来的接口。
​ 第三条：产品的 UI 对于用户来说足够友好。这一点是什么意思呢？其实这一点主要是对于产品经理和设计师来说的。大家有过开发经验的同学，特别是有过在公司工作过的同学。应该很清楚，你的项目最终开发出来帐什么样子，不是你决定的。是产品经理和设计师来决定的。那设计项目的 UI 他们的依据是什么呢？他们会依据产品的特性、产品的定位等等，但是绝大部分的 UI 依据都是目前用户的一个普遍审美。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57c3079e46c2b5f11712037241b07458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412e0767215d435672094eeb521a6dbf/" rel="bookmark">
			Java Number类(详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，Number java.lang.Number 类是抽象类，用于表示各种数值类型的对象。它是 Java 中所有数值类型的包装类的超类。Number 类主要有以下几个特点和作用：
抽象类：Number 类是一个抽象类，不能直接实例化，但可以用作其他数值类型的基类。
超类：Number 类是整个数值类型包装类层次结构的超类。Java 中的所有数值包装类（Integer、Long、Float、Double、Byte 和 Short）都直接或间接继承自 Number 类。
提供常用方法：Number 类提供了一些抽象方法，用于获取不同数值类型的值，如 doubleValue()、floatValue()、intValue()、longValue() 等。这些方法允许将一个数值对象转换为对应的基本数据类型的值。
通用性：由于 Number 类是各种数值包装类的超类，因此它可以作为一个通用的引用类型，用于存储各种数值类型的对象。这种通用性使得在需要处理不同数值类型的场景中更加灵活。
自动装箱与拆箱：在 Java 中，基本数据类型可以自动装箱为对应的包装类型，而包装类型也可以自动拆箱为对应的基本数据类型。因此，Number 类的子类（如 Integer、Double 等）可以与基本数据类型之间自由转换，提供了更方便的数值处理方式。
总之，Number 类在 Java 中扮演着重要的角色，它为处理不同数值类型提供了一种统一的接口，使得数值操作更加灵活和方便。
原文介绍
这里有说到请阅读官网文档
官方文档
https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Number.html
我们得以看出Number还是有很多孩子的
AtomicInteger, AtomicLong, BigDecimal, BigInteger, Byte, Double, DoubleAccumulator, DoubleAdder, Float, Integer, Long, LongAccumulator, LongAdder, Short
接下来我来进行验证到底是真孩子还是假冒伪劣产品
果然，它的孩子还是挺多的。言归正传，开始介绍哈哈哈
二，Number的方法 当然，让我们从头开始逐个介绍java.lang.Number类中的方法。
byte byteValue()
返回值类型：byte方法说明：将Number对象转换为byte类型的值。用法示例：Number num = 10; byte b = num.byteValue(); System.out.println(b); // 输出 10 short shortValue()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412e0767215d435672094eeb521a6dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e439518d01d0856a89758e9f3664b72b/" rel="bookmark">
			AI帮你P图，它终于来了！ChatGPT P图初体验！附详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是木易，一个持续关注AI领域的互联网技术产品经理，国内Top2本科，美国Top10 CS研究生，MBA。我坚信AI是普通人变强的“外挂”，所以创建了“AI信息Gap”这个公众号，专注于分享AI全维度知识，包括但不限于AI科普，AI工具测评，AI效率提升，AI行业洞察。关注我，AI之路不迷路，2024我们一起变强。
在AI绘画领域，公认的高质量的AI绘图模型/产品有2个，一个是Midjourney，另一个就是OpenAI的DALL·E 3模型。其中，DALL·E 3模型除了正常的API调用外，在2023年10月被加入ChatGPT中，供ChatGP Plus付费用户使用。
稍微放几张DALL·E 3生成的图片，小伙伴们可以感受一下。
北美时间4月3日，OpenAI在国外社交媒体官宣了AI P图的功能，由DALL·E生成的图片可以继续对其进行编辑优化的操作，同时支持web网页端，iOS，和Android。
当然需要指出的是，和OpenAI一贯的调性一样，新功能都是优先付费用户的，由于只有ChatGPT Plus用户可以在ChatGPT生图，所以这个P图功能目前也只有付费用户能体验。
ChatGPT P图初体验 找到DALL·E 目前有两种方式让ChatGPT为你画图，一个是直接选择ChatGPT 4模型进行对话，用关键词“画”或者对应的英文直接生图即可，这样生成的图片也可以进行编辑。第二种方法是在GPT store里搜索“Dalle”，选择ChatGPT官方出的这个GPT（智能体），与其对话让它生成图片。
Dalle 3链接：https://chat.openai.com/g/g-2fkFE8rbu-dall-e
生图测试 这次生图我用的是第二种方式，在DALL·E GPT里使用。生图提示词我是让另一个GPT帮我生成了一段提示词，具体如下。
提示词：A cute cat dressed in a sharp human suit and tie, standing upright with a sophisticated pose, next to an adorable puppy looking up with big bright eyes. The scene is set in a cozy, well-lit living room filled with books and comfortable furniture, with the soft golden glow of sunset streaming through a large window, highlighting their textures and colors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e439518d01d0856a89758e9f3664b72b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3cfb7a22690d2390a309628662d328e/" rel="bookmark">
			Android Studio 模拟器卡慢、占内存解决方法，Android开发还会吃香吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.使用Genymotion模拟器 在我学习Android中，我尝试了几种模拟器的使用方法。希望在你选择和配置模拟器时有所帮助：
一. Android virtual device（自带模拟器Intel)
=====================================
这里讲一下Android Studio 原生模拟器的改善吧。为 Android 模拟器配置硬件加速，Android 模拟器可以使用硬件加速功能来提升性能，有时甚至可以大幅提升性能。
1.创建新的AVD时修改Graphics Rendering选项
创建新的 AVD 官方链接：
https://developer.android.google.cn/studio/run/managing-avds#createavd.
在 AVD 管理器中创建 Android 虚拟设备 (AVD) 时，你可以指定模拟器应使用硬件还是软件来模拟 AVD 的 GPU。
Graphics Rendering即图形渲染方式，如下有三种可选：自动选择、硬件、软件。右侧标注处解释了其优缺点：
硬件：使用你电脑的显卡得到更快的渲染。
软件：使用电脑中的软件来模拟图形，以此解决电脑显卡的问题。
模拟器将使用软件加速（使用计算机的 CPU）来模拟 GPU 处理。
默认情况下，模拟器会根据你的计算机设置来决定是使用硬件图形加速还是软件图形加速。建议使用硬件加速，因为硬件加速通常速度更快。
2.在 Windows 上使用 Intel HAXM 配置虚拟机加速
计算机必须满足以下要求，您才能安装和使用 Intel HAXM：
启用了虚拟化技术 (VT-x)、Intel EM64T (Intel 64) 功能和 Execute Disable (XD) Bit 功能的 Intel 处理器
64 位 Windows 10、Windows 8 或 Windows 7（或者 64 位处理器上的 32 位版本的操作系统）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3cfb7a22690d2390a309628662d328e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b7fe41dec8dfe9298e02c807f9c6e8/" rel="bookmark">
			Spring和Spring Boot的区别（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鱼弦：公众号：红尘灯塔，CSDN博客专家、内容合伙人、CSDN新星导师、51CTO(Top红人+专家博主) 、github开源爱好者（go-zero源码二次开发、游戏后端架构 https://github.com/Peakchen）
Spring和Spring Boot的区别
1. 简介
Spring和Spring Boot都是Java开发中常用的框架，用于构建企业级应用程序。它们提供了一套综合性的解决方案，简化了开发过程，并提供了丰富的功能和工具。
2. 原理详解
Spring：Spring是一个轻量级的开源框架，它的核心原则是面向切面编程（AOP）和控制反转（IoC）。Spring通过IoC容器管理和组织应用程序中的对象，通过AOP提供横切关注点的支持，如事务管理和日志记录等。Spring提供了一系列的模块，如Spring MVC用于Web开发，Spring Data用于数据库操作，Spring Security用于身份验证和授权等。Spring Boot：Spring Boot是基于Spring的快速开发框架，它旨在简化Spring应用程序的配置和部署。Spring Boot使用了约定大于配置的理念，通过自动配置和起步依赖简化了项目的搭建和配置过程。它集成了许多常用的开发工具和第三方库，提供了一个独立运行的可执行JAR包，可以快速构建独立的、可部署的Spring应用程序。 3. 应用场景解释
Spring：Spring适用于开发各种规模的企业级应用程序。它提供了广泛的功能和模块，可用于Web开发、数据库操作、事务管理、消息队列、安全认证等场景。Spring的灵活性和可扩展性使得它成为许多企业应用的首选框架。Spring Boot：Spring Boot适用于快速构建微服务和独立的应用程序。它简化了Spring的配置和部署，提供了自动配置和快速启动的特性。Spring Boot的约定大于配置的设计理念使得开发者可以更专注于业务逻辑的开发，而无需过多关注底层的技术细节。 4. 算法实现
Spring和Spring Boot并不直接涉及具体算法的实现，它们是基于Java语言的框架。具体的算法实现取决于开发者在应用程序中的具体需求和业务场景。
Spring 和 Spring Boot 使用以下算法来实现其功能：
依赖注入： 使用反射来注入依赖关系。面向切面编程： 使用代理来实现横向关注点。容器： 使用 IoC 容器来管理应用程序的组件。 5. 代码示例详细实现
以下是一个使用 Spring Boot 创建简单 Web 应用程序的示例：
创建一个新的 Spring Boot 项目。在 pom.xml 文件中添加以下依赖项： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 创建一个新的 Spring Boot 应用程序类： @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b7fe41dec8dfe9298e02c807f9c6e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d56b2a7ead97f160f3d0a0762e1bd95/" rel="bookmark">
			AI辅助自动驾驶技术在2024年的发展与趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
综述 2024 年 AI 辅助研发趋势
第一章：引言
1.1 背景介绍
1.2 AI在自动驾驶中的地位和作用
1.3 2024年自动驾驶技术的现状
1.4 论文结构
第二章：AI技术在自动驾驶中的应用
2.1 深度学习算法在自动驾驶中的应用
2.2 数据分析与模式识别
2.3 实时决策与路径规划
2.4 车辆控制与系统集成
第三章：2024年自动驾驶技术的现状与发展
3.1 硬件设备的进步与应用
3.2 软件系统的优化与创新
3.3 安全性能的提升与挑战
3.4 成本与商业化问题
3.5 社会接受度与法律法规
3.6 结论
第四章：AI辅助研发在自动驾驶中的应用
4.1 数据分析与模式识别
4.2 模拟仿真与系统优化
4.3 车辆设计与智能化
4.4 AI技术在软件开发中的应用
4.5 人机交互与用户体验
第五章：未来发展趋势与展望
5.1 智能化驾驶系统的演进
5.2 安全性与可靠性的提升
5.3 社会接受度和法律规范的挑战
5.4 共享经济与智慧城市的发展
5.5 科技创新与产业生态的协同发展
5.6 推动自动驾驶技术向全面普及迈进的策略
第六章：结论
综述 2024 年 AI 辅助研发趋势 随着人工智能技术的持续发展与突破，2024年AI辅助研发正成为科技界和工业界瞩目的焦点。从医药研发到汽车设计，从软件开发到材料科学，AI正逐渐渗透到研发的各个环节，变革着传统的研发模式。在这一背景下，AI辅助研发不仅提升了研发效率，降低了成本，更在某种程度上解决了复杂问题，推动了科技进步。2024年，随着AI技术的进一步成熟，AI辅助研发的趋势将更加明显，其潜力也将得到更广泛的挖掘和应用。
第一章：引言 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d56b2a7ead97f160f3d0a0762e1bd95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0862e335197c2b866e75ef8601c3fe3b/" rel="bookmark">
			【数据结构】--- 探索栈和队列的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注小庄 顿顿解馋૮(˶ᵔ ᵕ ᵔ˶)ა
💡个人主页：9ilk 💡专栏：数据结构之旅 上回我们学习了顺序表和链表，今天博主来讲解两个新的数据结构 — 栈和队列 ， 请放心食用
文章目录 🏠 栈📒 何为栈👿 栈后进先出是相对的 📒 栈的实现 🏠 队列📒 何为队列📒 队列的实现 🏠 栈 对于这么坨书，我们要拿到最下面的书是不是要最后才能拿到；而对于最上面的书它是最晚放上去的却能最先拿到，这样的一个场景就跟我们接下来要介绍的栈类似 — Last in First out(后进先出)
📒 何为栈 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈数据的插入操作叫做压栈/入栈/进栈，入数据在栈顶。
出栈：栈数据的删除操作叫做出栈，出数据也在栈顶。
👿 栈后进先出是相对的 由图中我们可知，栈的后进先出是对于同时在栈里的数据而言的
📒 栈的实现 通过前面的分析我们知道，我们需要一个栈顶来表示数据，这跟我们链表的头结点有点相似，但是对于单链表来说实现栈，尾部插入数据并不方便，因此我们选择数组实现栈
动态栈 typedef int Datatype; typedef struct Stack { Datatype* arr; int top; int capacity; }ST; 栈的初始化与销毁 //初始化 void StackInit(ST* ps) { assert(ps); ps-&gt;arr = NULL; ps-&gt;capacity = ps-&gt;top = 0; } 关于top的初始化：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0862e335197c2b866e75ef8601c3fe3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4761c5c66c5c756b4cf027948c4221c1/" rel="bookmark">
			C#文件夹基本操作（判断文件夹是否存在、创建文件夹、移动文件夹、删除文件夹以及遍历文件夹中的文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、判断文件夹是否存在
1.Directory类的Exists()方法
2. DirectoryInfo类的Exists属性 二、创建文件夹
1. Directory类的CreateDirectory()方法
2.DirectoryInfo类的Create()方法
三、移动文件夹
1. Directory类的Move()方法
2.DirectoryInfo类的MoveTo()方法
四、删除文件夹
1. Directory类的Delete()方法
2.DirectoryInfo类的Delete()方法
五、遍历文件夹 1.GetDirectories()方法
2.GetFiles()方法
3.GetFileSystemInfos()方法
4.示例
（1）源码
（2）生成效果 判断文件夹是否存在时，可以使用Directory类的Exists()方法或者DirectoryInfo类的Exists属性来实现。
一、判断文件夹是否存在 1.Directory类的Exists()方法 Exists()方法用于确定给定路径是否引用磁盘上的现有目录，语法如下。
public static bool Exists (string path) ☑ path：要测试的路径。 ☑ 返回值：如果path引用现有目录，则为true；否则为false。允许path参数指定相对或绝对路径信息。 相对路径信息被解释为相对于当前的工作目录。 //使用Directory类的Exists()方法判断C盘根目录下是否存在Test文件夹。 Directory.Exists("C:\\Test "); 2. DirectoryInfo类的Exists属性 获取指示目录是否存在的值，语法如下。
public override bool Exists{get;} 属性值：如果目录存在，则为true；否则为false。 //调用DirectoryInfo类中的Exists属性判断C盘根目录下是否存在Test文件夹 Directorylnfo dinfo =new Directorylnfo ("C:\\Test"); if (dinfo.Exists) {} 二、创建文件夹 创建文件夹可以使用Directory类的CreateDirectory()方法或者DirectoryInfo类的Create()方法来实现。
1. Directory类的CreateDirectory()方法 CreateDirectory()方法为可重载方法，它有以下两种重载形式。
public static DirectoryInfo CreateDirectory (string path) public static DirectoryInfo CreateDirectory (string path,DirectorySecurity directorySecurity) ☑ path：要创建的目录路径。 ☑ directorySecurity：要应用于此目录的访问控制。 ☑ 返回值：第一种重载形式的返回值为由path指定的DirectoryInfo；第二种重载形式的返回值为新创建的目录的DirectoryInfo对象。 当path参数中的目录已经存在或者path的某些部分无效时，将发生异常。path参数指定目录路径，而不是文件路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4761c5c66c5c756b4cf027948c4221c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d233035ae2709561ce3893b6694bce28/" rel="bookmark">
			Java @Data 注解详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Data 注解是 Lombok 提供的一个组合注解，它会为类自动生成一些常见方法的样板代码，包括 getter、setter、equals、hashCode 和 toString 方法。
引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 使用说明 假设我们有一个简单的 Java 类 Person，使用 @Data 注解可以简化代码编写，如下所示：
@Data public class Person { private String name; private int age; } 在上面的例子中，我们使用了 @Data 注解来修饰 Person 类。此时，Lombok 将会自动为 Person 类生成以下方法：
Getter 和 Setter 方法： public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d233035ae2709561ce3893b6694bce28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee6ac11d5823a433a52f035b64849f1/" rel="bookmark">
			最新ChatGPT4.0工具使用教程：GPTs，Midjourney绘画，AI换脸，GPT语音对话，文档分析一站式系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、前言 ChatGPT3.5、GPT4.0、相信对大家应该不感到陌生吧？简单来说，GPT-4技术比之前的GPT-3.5相对来说更加智能，会根据用户的要求生成多种内容甚至也可以和用户进行创作交流。 然而，GPT-4对普通用户来说都是需要额外付费才可以使用。所以今天小编就整理一个真正可免费的AI工具，可每天签到使用。
已支持GPT语音对话、GPT-4模型、DALL-E3文生图、图片对话能力上传图片，文档分析、Midjourney绘画动态全功能、AI换脸、垫图混图、插件功能、支持最近火爆的Suno-v3-AI音乐生成大模型。
国内可直接对话AI，也有各种提供工作效率的工具供大家使用。
1.1 核心功能 ①语音对话功能 支持电脑PC浏览器和手机端使用，具有”人的语气“
②GPTs ③文档分析 ④Suno-v3-AI音乐生成 1.2 程序核心功能 已支持 OpenAI GPT全模型 + 国内AI全模型 + 绘画池系统 +GPTs+ MJ局部编辑重绘功能+语音对话功能 + 文档分析功能 + Midjourney绘画动态全功能+插件功能！
二、上干货 官网：
https://ai.sparkaigf.com
系统详细文档：
《SparkAI系统介绍文档 - 渐进式AIGC系统》
三、支持AI绘画 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154d806fb11d2920aa2dd80734427214/" rel="bookmark">
			利用JS、CSS实现列表自动滑动滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零.业务需求 这几天在做大屏项目，对于大屏有很多信息需要实时滚动，废了点力气学的明明白白的，特来记录供大家学习。
0.1实现效果 一.逻辑分析 1.1滑动窗口和滚动条 当我们使用&lt;table&gt;或者&lt;ul&gt;标签时，我们可以制作一个滚动条，通过滚动条来实现我们想要查看的内容。
在滚动窗口内，“已经滚动过去”的区域我们称为：“scrollHeight”，“还未滚动到”的 区域我们称为：“scrollBottom”，“当前显示区域”称为：“scrollNow”。
我们再用一张图来描述一下，上面三个概念：
（可能有点丑...）
为方便，上面这一整个区域(scrollTop、scrollNow、scrollBottom)，我们统称为：“滑动窗口”
1.2逻辑构思 如果我们有：“两份一模一样的数据顺序排列在一起形成一份数据”，再将这一份数据中的“元素”挨个展示在我们的“scrollNow”区域中，当这份数据的最后一个“元素”被展示时，我们重新让一整份数据从头开始，这样就在视觉上实现了滚动的效果。
在这里，有一个关键性的问题：“两份数据的长度一定要大于显示区域的长度，否则将无法实现滑动”
至于为什么，大家思考一下就行，当我们的数据滑动时，滑动过去的数据被“隐藏”了，但并不是消失了！
如果我们的“可显示区域”大于“数据”的长度，那么就会出现下面的情况：
当显示区域的长度足够容纳：“所有的数据”，此时还有“滑动”的必要吗？？？
我们“滑动”的原因是因为：“数据量太大，展示区域有限，故让它滑动方便查看”
1.3伪代码实现 在js中，有几个属性：
“scrollTop”用来“设置或者获取”元素的已滚动的上部“不可见区域”的高度，这个概念就是我们上述讲的“scrollTop”(已经滚动过的区域)
“scrollHeight”用来“返回”元素所有内容的“总高度”(包括折叠不见的)，这个就是我们上述所说的(scrollTop+scrollNow+scrollBottom)
利用这几个属性，我们可以设定一个计时器用来计时，每次计时器加值时，scrollTop的值随之加值(向上滚动)，从而实现了滚动。
二.代码实现 2.1创建骨架 我们先创建一个div盒子，作为整个列表的骨架：
&lt;div id="review_box"&gt; &lt;ul id="comment1"&gt; &lt;li&gt;第一条&lt;/li&gt; &lt;li&gt;第二条&lt;/li&gt; &lt;li&gt;第三条&lt;/li&gt; &lt;li&gt;第四条&lt;/li&gt; &lt;li&gt;第五条&lt;/li&gt; &lt;li&gt;第六条&lt;/li&gt; &lt;/ul&gt; &lt;ul id="comment2"&gt;&lt;/ul&gt; &lt;/div&gt; 其中“comment1”&lt;ul&gt;是原数据，“comment2”&lt;ul&gt;是原数据的副本，这两部分数据组合在一起形成我们的“一整个数据”
而&lt;li&gt;就是我们的“元素”，方便起见我这里内置数据，后面根据需要可以自己再写一个函数添加数据。
2.2创建样式 只有骨架是不行的，没有用到CSS美观是很丑的，如果不使用CSS，那么就是下图这个样子：
为此我们使用如下代码：
&lt;style&gt; div { width: 100px; height: 100px; /*列表的长度*/ overflow: hidden;/* 必须 */ margin: 50px auto; border: 1px solid red; text-align: center; } ul { margin: 0; padding: 0; /*元素居中*/ list-style: none; /*去掉元素前面的标签*/ } li{ height: 20px; /*元素高度,数据的高度等于元素个数乘元素高度*/ } &lt;/style&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154d806fb11d2920aa2dd80734427214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5938f5ecf59951cfd8cbde60b21728/" rel="bookmark">
			【phpMyAdmin】关于无法登陆MySQL服务器的解决方案（且适用于之前已经安装过MySQL但无法登录的解决方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.问题再现
2.问题分析
这是一个PHP连接MySQL的认证方法问题。上面的红色部分提到了认证方法"caching_sha2_password"，这是MySQL 8.0版本引入的一种新的认证方式，而PHP环境可能不支持这种认证方式。
3.解决方案
3.1 解决这个问题的方法之一是在MySQL服务器上创建一个允许旧的认证方式的用户。这里因为其他帖子已经详细介绍，这里就不再赘述
3.2 由于之前安装过MySQL，此时的MySQL已经启动，我们手动关闭它：
3.2.1使用快捷键win + R 输入下面这行命令
services.msc 3.2.2 右键关闭服务
4.尾言：一般到这里就可以正常打开了，如果还是打不开，之前看到还有一条帖子可以解决，或许这个可以帮到你
php连接数据库失败(并提示：mysqli(): The server requested authentication method unknown to the client)_thinkphp the server requested authentication metho-CSDN博客
END 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8046ad9b7c496128fd7179ac0c9ef1f1/" rel="bookmark">
			前端的同学不会还在用VS Code吧，可以放弃了；小马带你认识前端开发神器WebStorm（WebStorm及Git的相关配置与使用）(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在 webstorm 中配置 Git
1.点击 File-&gt;Settings…；
2.输入 Git 进行搜索；
3.点击 GitHub-&gt;Add account，输入自己的 Git 账号和密码；
4.点击 Git，在 Path to Git executable 中选择自己电脑所安装的 Git 所在绝对路径；
5.点击 Apply，点击 ok，Git 配置完成；
二、克隆 Git 仓库上的项目至本地
1.打开软件，check out-&gt;GIT；
2.已经进入软件也可，点击 VCS-&gt;Git-&gt;Clone;
3. 出现以下弹框，填好目标地址和本地存储路径后点击 Clone 即可；
4.克隆之后记得先改变分支，进入到自己的分支；
5.分支命名；
6.选好分支后打开 Terminal，npm i / cnpm i 命令下载 node_modules 包；
7.下载完modules包之后就可以正常启动项目了；
三、更新项目代码
在使用 Git 协同开发的环境下，每次打开 webstorm 项目最好先更新代码，让自己的代码与 Git 仓库保持同步，以免出现一些不必要的冲突；
1.点击以下按钮拉取最新代码进行更新，也可用快捷键 Ctrl+T；
2.出现以下弹框，点击ok；
3.更新成功后会有如下提示；
四、WebStrom 中项目文件颜色详解
红色：本地新增文件，没有关联到git，直接提交无法提交到Git(提交时不显示该文件)，需要先Add添加至仓库后再提交；
绿色：红色文件Add至仓库后转变而成，ctrl + k 可以直接提交；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8046ad9b7c496128fd7179ac0c9ef1f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73259226744277ef2107afb5b2e8558/" rel="bookmark">
			JDK21 虚拟线程详解，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 1. 虚拟线程是什么 2. 虚拟线程缺点与潜在问题 3. 虚拟线程创建的几种方法 4. 虚拟线程使用场景 一、虚拟线程是什么 Java 虚拟线程（Virtual Threads）是一种在 Java 虚拟机（JVM）内部实现的轻量级线程机制，旨在为 Java 应用程序提供高效、易用且高度可扩展的并发模型。
核心特点 1.轻量化： 虚拟线程具有极低的创建和上下文切换成本，相比于传统的操作系统（OS）线程（也称作“平台线程”），它们占用更少的内存资源，使得应用程序能够轻松地创建和管理数千甚至数百万个并发线程。这种轻量化设计特别适用于处理大量并发请求、网络IO密集型应用或事件驱动编程场景，其中每个请求或事件可能对应一个独立的执行单元。 2.M:N 调度模型： 虚拟线程遵循 M:N 调度策略，即有 M 个虚拟线程被 JVM 内部的调度器映射到 N 个平台线程（通常是 OS 线程）上运行。JVM 负责虚拟线程的调度，将其有效地分发到有限数量的平台线程上。这样，即使有大量的虚拟线程，实际消耗的操作系统资源（如内核线程）仍然保持在一个可控范围。 3.连续传递样式 (CPS)： 实现虚拟线程的技术之一可能是连续传递样式（Continuation Passing Style, CPS）。这是一种编程范式，通过将程序控制流作为参数在函数间传递来支持非阻塞式的协同式多任务执行。使用 CPS 可以简化对异步操作的管理和编排，减少因等待IO操作完成而引起的阻塞，从而提升并发性能。 4.易于编程： 开发者可以像使用标准 Thread 类一样创建和管理虚拟线程，使用熟悉的同步原语（如 synchronized 关键字、Lock 接口等）进行线程间通信和同步。虽然底层实现有所不同，但在编程接口和体验上，虚拟线程力求与传统线程保持一致，降低学习和迁移成本。 工作原理概览 创建：开发者创建一个虚拟线程实例，如同创建普通 Java 线程一样，但底层创建的是轻量级的虚拟线程对象而非操作系统线程。调度：JVM 的调度器负责将这些虚拟线程分配到已有的平台线程上执行。当一个虚拟线程因等待 IO 操作或其他原因而阻塞时，JVM 能够透明地将其从当前平台线程上移除，释放平台线程去执行其他虚拟线程，从而避免了不必要的上下文切换开销。协作与抢占：虽然虚拟线程的设计倾向于避免显式的锁竞争和上下文切换，但在必要时，JVM 调度器也可以实现基于时间片的抢占式调度，确保所有虚拟线程公平地获得执行机会。线程本地存储：类似于传统线程，虚拟线程同样支持线程本地存储（ThreadLocal），以便在每个线程上下文中保存特定于线程的数据。 二、虚拟线程的缺点与潜在问题 三、创建虚拟线程的几种方法 1.Thread的静态方法 以下两种都是等效的
Thread.ofVirtual().start(Runnable task);
Thread.startVirtualThread(Runnable task)
都是使用ThreadBuilders的newVirtualThread方法来创建虚拟线程
由于Thread.startVirtualThread是在方法体里面直接帮我们填好了虚拟线程所需要的参数，所以无法给我们自己的虚拟线程命名
public static Thread startVirtualThread(Runnable task) { Objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73259226744277ef2107afb5b2e8558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a320003222eb4b17ec7202b3cb4fcce3/" rel="bookmark">
			【C&#43;&#43;学习】哈希的应用—位图与布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.位图1.1位图的概念1.2位图的实现3.位图的应用 2.布隆过滤器2.1 布隆过滤器提出2.2布隆过滤器概念2.3如何选择哈希函数个数和布隆过滤器长度2.4布隆过滤器的实现2.4.1布隆过滤器插入操作2.4.2布隆过滤器查找操作2.4.3 布隆过滤器删除 2.5 布隆过滤器优点2.6布隆过滤器缺陷 3.海量数据面试题3.1 哈希切割3.2 位图应用3.3 布隆过滤器 文章简介：
在这篇文章中，你会学习到关于哈希思想的最常见的两个应用，也就是 位图 与 布隆过滤器，
文章会讲解位图和布隆过滤器的概念，底层实现，对应的适应的场景，以及相关经典 海量数据面试题 及解析。
1.位图 1.1位图的概念 所谓位图，就是用每一位来存放某种状态，适用于海量数据，数据无重复的场景。通常是用来判断某个数据存不存在的。
比如这道 腾讯 的面试题目：
面试题目：给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。
解析：
40亿个整型数据所需内存大小：10亿字节约等于1G，那么40亿个整型，就是40亿*4（字节）=160亿字节≈16G。
遍历，时间复杂度O(N)排序(O(NlogN))，利用二分查找: logN 上面的两种做法都是不可行的，因为内存不够。
位图解决 数据是否在给定的整形数据中，结果是在或者不在，刚好是两种状态，那么可以使用一个二进制比特位（0/1）来代表数据是否存在的信息，如果二进制比特位为1，代表存在，为0代表不存在。 第三种方法，利用位图解决，因为是要在40亿个数中查找，数据的类型是一个整型，范围为0~UINT_MAX。所以我们只需要UINT_MAX个比特位，所需的内存也就是512M,然后将这40亿个整数利用这UINT_MAX个比特位就可以表示他们的存在状态；
图解：
假设有一个整型数组array（如下图），因为里面的数据范围为1~22，所以我们就可以开一个int大小的数组（有32个比特位，可以表示32个不同数的存在状态），映射地址的方法这里采用的是直接定址法；
计算：第i个整型中：i = （该数）/ 32；
该整形中第j个比特位：j = （该数）% 32；
1.2位图的实现 因为位图需要整型的连续的空间，所以这里我们用vactor 即可
所开空间的大小的计算：
这里开的是一个范围，假如上面的面试题，有40亿个整型数据，因为有40亿个数据，但是不能 只开40亿个比特位的空间，因为如果只开了40亿个比特位的话，就只能表示数据大小为0~40亿的数据，然而数据类型为int，数据最大值超过了40亿，这样超过了40亿的数据就表示不了了。
因为空间开的大小不一样，所以这里需要利用非类型模板参数
所开的空间是以整型为单位开辟，所以确认了所需的比特位后，还需计算是多少个int（32个比特位）大小，如果换算为int大小，有余数的话，就应该多开一个int大小
template&lt;size_t N&gt; //非类型模板参数 class bitset { public: bitset() { _bitset.resize(N/32+1, 0); //所需开的空间，因为空间都只能以整型为单位开，所以需要除以32 } void set(size_t x) //将x对应的比特位置1 { size_t i = x / 32; //确定是第几个int size_t j = x % 32; //确定是该int里面的第几个比特位 _bitset[i] |= (1 &lt;&lt; j); //将1左移j个比特位，在与该位置的数进行 或等操作（如下图有解析） } void reset(size_t x) //将x对应的比特位置0 { size_t i = x / 32; size_t j = x % 32; _bitset[i] &amp;= ~(1 &lt;&lt; j); //将1左移j个比特位，然后取反，再与该位置的数进行 与等操作（如下图有解析） } bool test(size_t x) //查找x是否存在 { size_t i = x / 32; size_t j = x % 32; return _bitset[i] &amp; (1 &lt;&lt; j); //将1左移j个比特位，再与该位置的数进行 与操作（如下图有解析） } private: vector&lt;int&gt; _bitset; }; 解析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a320003222eb4b17ec7202b3cb4fcce3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0657dd7ba6e7c8ed1405953abf0fe9/" rel="bookmark">
			AI绘画：使用ComfyUI结合LCM进行实时绘图：开启AI艺术创作新篇章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字艺术的世界里，ComfyUI和LCM（Latent Contextual Modulation）的结合为艺术家和设计师们提供了一个强大的实时绘图工具。LCM是一种先进的技术，它能够实时地将用户的输入和反馈融入到图像生成过程中，从而创造出动态变化的艺术作品。本文将作为一篇教程，引导你如何使用ComfyUI结合LCM进行实时绘图。
ComfyUI与LCM简介 ComfyUI ComfyUI是一个为Stable Diffusion模型设计的图形用户界面，它提供了丰富的功能和直观的操作方式，使得用户能够轻松地与AI进行交互，创造出独特的图像。
LCM LCM是一种基于深度学习的图像生成技术，它通过实时调整潜在空间中的向量来改变图像的生成过程。LCM允许用户在图像生成过程中提供连续的输入，从而实现实时绘图和动态图像修改。
准备工作 在使用ComfyUI结合LCM进行实时绘图之前，你需要确保已经安装了ComfyUI和相关的LCM插件。
下载并安装ComfyUI的最新版本。根据ComfyUI的文档，安装LCM插件。确保你的计算机满足运行ComfyUI和LCM的硬件要求。 实时绘图步骤 步骤1：启动ComfyUI并加载LCM插件 打开ComfyUI。在插件管理器中找到并加载LCM插件。 步骤2：设置初始参数 在LCM插件的设置中，输入你的初始提示词，这将作为图像生成的基础。调整LCM的参数，如温度、Top-K等，以控制图像的多样性和确定性。 步骤3：开始实时绘图 点击开始按钮，ComfyUI将根据你的设置开始生成图像。在图像生成过程中，你可以通过调整LCM的参数来实时改变图像的生成方向。 步骤4：反馈与调整 观察生成的图像，并根据需要提供实时反馈。使用LCM插件提供的滑块或输入框来调整图像的特定区域或整体风格。你的每一次调整都会立即反映在图像生成过程中，直到你满意为止。 步骤5：保存与分享 一旦你对生成的图像感到满意，可以将其保存到本地。分享你的作品到社交媒体或艺术社区，让更多人欣赏到AI艺术的魅力。 结语 ComfyUI结合LCM进行实时绘图为艺术创作带来了新的可能性。通过实时的交互和反馈，艺术家们可以更加直观和动态地探索AI的艺术潜力。无论你是经验丰富的艺术家还是AI艺术的新手，这种方法都能帮助你释放创造力，创作出独一无二的艺术作品。让我们拥抱这项技术，开启AI艺术创作的新篇章。
这边就不截步骤图了。相信大家到此时已经可以根据步骤自己拉起实时绘画的工作流了，最后给一个全图浏览。
关键一招：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148a77478b51fad45b658182b09be8d2/" rel="bookmark">
			从零搭建SpringBoot3&#43;Vue3前后端分离项目基座，中小项目可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 后端项目搭建1.1 环境准备1.2 数据表准备1.3 SpringBoot3项目创建1.4 MySql环境整合，使用druid连接池1.5 整合mybatis-plus1.5.1 引入mybatis-plus1.5.2 配置代码生成器1.5.3 配置分页插件 1.6 整合swagger3（knife4j）1.6.1 整合1.6.2 使用 1.7 数据交互处理1.7.1 响应数据封装（公共返回数据类）1.7.2 分页查询返回数据封装 1.8 全局异常处理1.9 整合JWT，生成token1.10 封装ThreadLocal 工具类1.11 MD5封装1.12登录验证拦截1.13 登录和获取当前用户信息接口处理 2. 前端项目搭建2.1 环境准备2.2 创建Vue3项目2.3 项目搭建准备2.4 Element Plus 安装使用2.5 axios 安装使用2.5.1 安装2.5.2 配置（创建实例，配置请求、响应拦截器）2.5.3 配置跨域 2.6 Vue Router 安装使用2.7 Pinia状态管理库2.7.1 Pinia持久化插件-persist2.8 搭建管理页面基础框架2.8.1 在src下创建api目录，次目录存放请求http方法的封装，创建user.js， 里边写封装请求方法2.8.2 登录页面2.8.3 布局页面 3.项目代码 项目使用SpringBoot3+Vue3， 后端使用springboot3, mybatisPlus, druid,knife4j(swagger3),Jwt; 前端 vue3 , element-plus, axios, pinia, vue-router; 项目前后端分离， 可持续扩展， 代码放到最后 1. 后端项目搭建 1.1 环境准备 - spring-boot3 最低支持jdk17, 所以需要准备jdk17环境 - Idea 版本IntelliJ IDEA 2021.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148a77478b51fad45b658182b09be8d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9696106ae5f21a7744e1e854de0f48/" rel="bookmark">
			【开发环境】Mac 安装 Visual Studio Code ② ( 装 C/C&#43;&#43; 扩展 | 安装配置 Code Runner 扩展插件 | 运行 C 语言程序 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Visual Studio Code 简介1、安装 C/C++ 扩展3、安装 Code Runner 扩展插件4、配置 Code Runner 扩展插件5、准备 C 语言程序6、处理 C 语言程序头文件报错问题7、运行 C 语言程序8、查看 Mac clang 编译器版本 一、Visual Studio Code 简介 1、安装 C/C++ 扩展 在 VSCode 中 , 点击 左侧 的 " 扩展 " 按键 , 在 扩展 面板中 , 默认显示之前已经安装过的 扩展 ;
在 扩展面板 中的 搜索栏 , 输入 " C " , 第一个就是 C/C++ 扩展 , 点击 " 安装 " 按钮 , 安装改 扩展插件 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae9696106ae5f21a7744e1e854de0f48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468cfd9cca1aca07650152e56f6f9aa1/" rel="bookmark">
			Java 将word转为PDF的三种方式和处理在服务器上下载后乱码的格式_java word转pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果这里找不到的话，可以使用命令 fc-list 查看一下有没有，如果没有或者出现该命令不可用的情况，那就需要先安装基础字体：使用命令：yum -y install fontconfig ，完成之后就能看到/user/share/fonts 了
2：找到Windows中的字体，将字体上传到这个 my-fonts中
这里面有很多字体，我们需要的是中文字体，可以选择性上传，选择需要的中文字体上传，比如宋体，要和你文件模板中字体一致就行。上传到my-fonts文件夹下
3：安装
接着根据当前目录下的字体建立scale文件,
切换到my-fonts目录下执行命令：mkfontscale
若提示mkfontscale command not found,则运行yum install mkfontscale
接着建立dir文件：mkfontdir
使用命令：vi /etc/fonts/fonts.conf 修改配置文件，添加：&lt;dir&gt;/usr/share/fonts/my-fonts&lt;/dir&gt;
添加后：
然后运行：fc-cache
fc-list #查看字体列表
4：赋予权限
chmod 777 /usr/share/fonts/my-fonts
chmod 755 /usr/share/fonts/my-fonts/*
使用命令查看： fc-list :lang=zh
2：Word转PDF实现的几种方式 1：使用POI的方式将word转换为PDF
引入依赖：
&lt;dependency&gt; &lt;groupId&gt;fr.opensagres.xdocreport&lt;/groupId&gt; &lt;artifactId&gt;fr.opensagres.poi.xwpf.converter.pdf-gae&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 在关闭流之前添加并修改reponse中.docx为.pdf
response.setHeader("Content-Disposition", "attachment; filename=" + java.net.URLEncoder.encode("日报-"+datetime+".pdf", "UTF-8")); //转为PDF PdfOptions options = PdfOptions.create(); PdfConverter.getInstance().convert(document, outStream, options); //下面再是转word里面最后的代码，关闭流 2：使用aspose.words的Document方式将word转换为PDF
1：下载jar包：jar包下载
2：将jar包放入项目中resources目录下的lib文件夹中：
3：将jar包转为library
转换后就会出现上面图中箭头处的样子可以打开。
4：引入jar包依赖：
&lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/468cfd9cca1aca07650152e56f6f9aa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e32aed36d196550ddad9b9287f68dc4/" rel="bookmark">
			【Python】无法将“pip”项识别为 cmdlet、函数、脚本文件或可运行程序的名称解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Python】无法将“pip”项识别为 cmdlet、函数、脚本文件或可运行程序的名称解决方案 大家好 我是寸铁👊
总结了一篇【Python】无法将“pip”项识别为 cmdlet、函数、脚本文件或可运行程序的名称解决方案✨
喜欢的小伙伴可以点点关注 💝
前言 今天寸铁在使用pip安装包时，报错如下：
具体如下：
无法将“pip”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。 请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。 所在位置 行:1 字符: 1 下面跟着寸铁一步步把问题解决吧！！！
解决方案 出现这种问题，一般来说是环境变量没有配置，导致计算机无法执行pip.exe。网上的解决方案是在pycharm中引入环境变量，且操作比较繁琐，寸铁给出的方案是直接在计算机中引入环境变量，这样的效果更好!
Step1 先打开pycharm，找到file –settings如下 Step2 再找到Python Interpreter
Step3 找到安装Python的地址 点击show All 复制如下地址 Step4 把后面的python.exe去掉，进行搜索。 双击Scripts文件夹 得到如下路径–复制
Step5 将上面复制的路径进行环境变量的配置
点击此电脑 – 找到属性 找到高级系统设置–点击环境变量 找到用户变量–点击Path
再把上面Step4的带有Scripts的路径复制并粘贴于此
逐步点击确定
Step6 现在重新启动Pycharm，并输入pip 配置成功！！！
再使用如下命令安装一下包，发现也是OK的
pip install keras 至此，成功解决问题！！！
看到这里的小伙伴，恭喜你又掌握了一个技能👊
希望大家能取得胜利，坚持就是胜利💪
我是寸铁！我们下期再见💕
往期好文💕 保姆级教程 【保姆级教程】Windows11下go-zero的etcd安装与初步使用
【保姆级教程】Windows11安装go-zero代码生成工具goctl、protoc、go-zero
【Go-Zero】手把手带你在goland中创建api文件并设置高亮
报错解决 【Go-Zero】Error: user.api 27:9 syntax error: expected ‘:‘ | ‘IDENT‘ | ‘INT‘, got ‘(‘ 报错解决方案及api路由注意事项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e32aed36d196550ddad9b9287f68dc4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/438/">«</a>
	<span class="pagination__item pagination__item--current">439/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/440/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>