<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fee5111f738da6017e22d14b1caa213/" rel="bookmark">
			AI作画工具介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.Stable Diffusion
2.1.诞生背景
2.2.版本历史
2.3.优点
2.4.缺点
2.5.应用场景
2.6.未来展望
3.Midjourney
3.1.诞生背景
3.2.版本历史
3.3.优点
3.4.缺点
3.5.应用场景
3.6.未来展望
4.总结
1.概述 AI作画工具是一种运用人工智能技术，特别是深度学习和生成对抗网络（GAN）等算法，自动生成或辅助创作视觉艺术作品的技术。通过机器学习，分析和模拟人类艺术家的创作风格和技巧，从而创作出具有艺术性的画作。
AI作画工具的主要特点包括：
1. 自动生成：用户只需提供一些关键词或描述性的提示，AI作画工具就能自动生成相应的图像，无需用户手动绘制。
2. 多样化的风格：AI作画工具能够模仿不同的艺术风格，从古典到现代，从写实到抽象，满足不同用户的需求。
3. 高效便捷：相较于传统的手绘和数字绘画，AI作画工具可以在短时间内生成大量创意作品，节省了创作时间和精力。
4. 个性化和定制化：部分AI作画工具可以根据用户的具体需求，定制化地生成个性化艺术作品。
5. 易用性：大多数AI作画工具操作简便，入门门槛较低，即便是非专业人士也能轻松上手。
6. 不断学习和进化：随着技术的不断发展，AI作画工具也在不断地学习和进化，能够更好地理解和实现用户的创意。
AI作画工具在艺术创作、设计、动画、影视等多个领域有着广泛的应用，为艺术家和设计师提供了全新的创作工具，拓展了艺术创作的边界。AI作画工具也在不断地推动人工智能在创意领域的应用和发展。我们来简单聊一聊Stable Diffusion和Midjourney。
2.Stable Diffusion 2.1.诞生背景 Stable Diffusion 是由 Stability AI 开发的一款深度学习图像生成模型，旨在提供高质量的图像生成能力。其开发目的是为了通过人工智能技术帮助用户生成逼真的图像，同时提高图像生成的效率和质量。
2.2.版本历史 初版发布：Stable Diffusion 的初版发布于 2021 年，它通过扩散模型（diffusion models）来生成图像，利用噪声逐渐减少的过程生成清晰的图像。
后续更新：随着技术的发展和用户需求的增加，Stable Diffusion 不断更新迭代，增强了图像生成的细节处理能力和多样性。
2.3.优点 高质量图像生成：能够生成非常逼真且细腻的图像。
多样性强：支持多种图像风格和内容生成。
高效：相较于传统的图像生成方法，速度更快，效率更高。
2.4.缺点 计算资源要求高：生成高质量图像需要大量的计算资源和时间。
复杂度高：对于普通用户而言，操作和参数调整较为复杂。
2.5.应用场景 1. 艺术创作：帮助艺术家创作独特的数字艺术作品。
2. 游戏设计：生成游戏中的角色和场景。
3. 广告设计：用于生成广告中的视觉元素。
4. 电影特效：为电影提供高质量的视觉效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fee5111f738da6017e22d14b1caa213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/538544a8158b714a8e4687e236f9ace1/" rel="bookmark">
			MySQL数据库的基础：逻辑集合数据库与表的基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
前言 在上一篇中，我们先如何学习数据库的 方法论 展开了激励的讨论， 而从本篇文章开始。小编将带着小伙伴们一起上满满的干货 ,本篇文章的目标主要是掌握对于 数据库 这个 逻辑集合 的 理解和基本的使用的重点详解 💖 💖 💖 💖
目录 数据库的基本操作
常用的数据类型
表的操作
一. 数据库的基本操作 在讲解数据库之前，小编在这里得解释一个概念
就是我们之前谈到的像 MySQL， Oracle 这样的 数据库 ，本质上来说他们都是一种 软件
而我们今天的谈及的 数据库 ，本质上是在数据库软件上 组织数据 的一种 “数据集合”
而我们要操作这些数据库，就需要用到我们 MySQL 中的 SQL 语句 ， 来进行对 数据库，数据库的表 ， 数据库的各种组成的属性 进行操作。
1. 查看当前数据库 &lt;1&gt;. SQL语句 show databases; &lt;2&gt;. 语句分析 就像这样，我们的 SQL 语句， 是每执行完 一条语句 ，就会出现 一个对应结果
这和我们的 学过的 C语言 ， Java这样的编程语言 ，画风是完全不相同的，他们是需要多条语句联合去搭配，才能实现我们的功能，但我们的 SQL 却不用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/538544a8158b714a8e4687e236f9ace1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c007c4e919660043722c782bcb7267f7/" rel="bookmark">
			Android Studio Jellyfish版本修改project使用特定jdk版本的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android studio总是把这些东西改来改去让人十分恼火，IDE本身改来改去就让人无法上手就立即工作，很多时间浪费在IDE和gradle的配置和奇奇怪怪现象的斗智斗勇上，搞Android是真的有点浪费生命。一入此坑深不见底
jellyfish版安卓studio已经无法通过SDK Location找到直接修改的位置了。
打开Settings,进入如下位置：
然后点击Gradle JDK
即可下载jdk或者自行配置jdk位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e8bda6eab690d8bc0644c02ddccec4/" rel="bookmark">
			网络安全在个人生活中具体有哪些常见的应用场景？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全在个人生活中的应用场景非常广泛，以下是一些常见的例子：
1. 个人隐私保护：网络安全可以帮助保护个人的隐私信息，如银行账户、身份证号、联系方式等，防止被黑客窃取或滥用。
2. 电子商务：在进行在线购物或支付时，网络安全可以确保交易过程的安全，防止信用卡欺诈、数据泄露等问题。
3. 社交媒体：网络安全可以保护用户在社交媒体上的信息不被恶意篡改或滥用，维护用户的社交环境。
4. 在线教育：网络安全可以保护在线教育平台的数据安全，防止学生信息泄露，确保教育质量。
5. 远程办公和学习：网络安全可以保障企业和学校网络系统的安全和稳定性，避免数据泄露和网络攻击。
6. 云存储和备份：网络安全可以保护云存储服务和备份数据的安全，防止黑客攻击和数据泄露。
7. 物联网设备安全：网络安全可以保护智能家居、智能设备等物联网设备的安全，避免网络攻击和数据泄露。
8. 移动设备安全：网络安全可以保护移动设备的安全和数据隐私，防止恶意软件和网络攻击。
9. 社交媒体安全：在使用社交媒体时，网络安全技术可以保护个人信息和隐私不被泄露。
10. 银行和金融安全：在进行网上银行、电子支付等金融交易时，网络安全技术可以确保交易的安全性和隐私性。
通过上述场景可以看出，网络安全在个人生活中扮演着至关重要的角色，它不仅关系到个人隐私和财产安全，也影响到日常生活的方方面面。因此，增强网络安全意识，采取适当的防护措施，对于每个网民来说都是非常必要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20b7842b473e0e65f3024a0366b3ba8/" rel="bookmark">
			【C&#43;&#43;初阶学习】第十三弹——优先级队列及容器适配器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言栈：数据结构——栈(C语言版)-CSDN博客
C语言队列：数据结构——队列（C语言版）-CSDN博客
C++栈与队列：【C++初阶学习】第十二弹——stack和queue的介绍和使用-CSDN博客
前言：
在前面，我们已经学习了用C++如何使用stack和queue，今天，我们来讲解一下它们两个底层实现的一些东西和一些扩展内容
目录
一、优先级队列
基本概念
常用成员函数
创建和使用优先级队列
创建小根堆
二、容器适配器
基本概念
deque容器（了解）
stack和queue的模拟实现
一、优先级队列 前面我们已经学习了队列的知识，队列就是先进先出，那么这里的优先级队列是什么呢？
C++中的优先级队列是一种基于容器适配器的抽象数据类型，它提供了队列接口，并允许按照元素的优先级进行排序
基本概念 优先级队列是一种特殊的队列，其中元素的出队顺序不是按照先进先出的原则，而是根据元素的优先级来确定。优先级高的元素先出队，优先级低的元素后出队（一般是按照升序，类似于堆的结构）
常用成员函数 以下是优先级队列的一些常用成员函数：
empty()：检查队列是否为空。size()：返回队列中的元素数量。top()：返回队列顶部（优先级最高）的元素，但不从队列中删除它。push()：将一个元素添加到队列中，并重新调整队列以保持排序。pop()：删除队列顶部（优先级最高）的元素。swap()：与另一个优先级队列交换内容 创建和使用优先级队列 以下是如何创建和使用一个优先级队列的示例：
#include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; int main() { // 创建一个存储int类型元素的优先级队列 priority_queue&lt;int&gt; pq; // 向队列中添加元素 pq.push(10); pq.push(30); pq.push(20); pq.push(5); pq.push(1); // 输出队列中的元素，并观察优先级 while (!pq.empty()) { cout &lt;&lt; pq.top() &lt;&lt; " "; pq.pop(); } cout &lt;&lt; endl; return 0; } 运行结果：
通过这个结果我们就可以看出所谓的优先级队列实际上与我们之前所学的堆很像，而且默认的是升序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e20b7842b473e0e65f3024a0366b3ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5236d94fae30288fd62b080c0273a4b1/" rel="bookmark">
			【Python核心数据结构探秘】：元组与字典的完美协奏曲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀一、元组⭐1. 元组查询的相关方法❤️2. 坑点🎬3. 修改元组 🌈二、集合⭐1. 集合踩坑❤️2. 集合特点💥无序性💥唯一性 ☔3. 集合（交，并，补）🎬4. 集合操作方法💥💥增💥💥删💥💥(增)💥💥查 🚀一、元组 元组：tuple 元组符号：() 元组属于不可变类型（不可变序列） 元组是序列类型（容器序列） 元组不提供方法修改，但是可以转类型进行操作 ⭐1. 元组查询的相关方法 index 查询指定元素第一次出现的下标 tuple1 = (1, 'hah', '帅') print(tuple1.index('帅')) # 2 注意：
如果元组中不存在你要查找的值，index() 方法会抛出一个 ValueError 异常。
由于元组是不可变的，找到索引通常是为了了解结构，而不是为了修改元组内容（因为无法修改）。
index() 方法只返回第一个匹配项的索引，即使该值在元组中出现了多次。
count 查询指定元素出现的次数
count() 方法，用于统计元组中某个元素出现的次数。
tuple.count(element) tuple：你想要在其内部计数的元组。element：你想要统计其出现次数的元素。 tuple2 = ('帅', 1, '帅', 'hah', '帅') print(tuple2.count('帅')) # 3 ❤️2. 坑点 在Python中，元组是一种不可变的序列类型。当定义一个只包含一个元素的元组时，确实会出现一些特殊情况。如果你直接写作(元素)，Python不会把它解析为一个元组，而是将其视为一个单纯的括号包围的表达式。为了明确表示这是一个只有一个元素的元组，你应该在元素后面加上一个逗号，即(元素,)。
不加逗号：single_item = (42)，这在Python中实际上被视为一个整数42，而不是一个元组。加逗号：single_tuple = (42,)，这样就明确地定义了一个只包含一个元素42的元组。 这是因为括号()在Python中还用于表示运算优先级，以及在函数调用时包围参数列表。为了消除歧义，当创建一个只有一个元素的元组时，添加逗号是必要的。
tuple3 = (1) print(type(tuple3)) # &lt;class 'int'&gt; tuple4 = (1,) print(type(tuple4)) # &lt;class 'tuple'&gt; # 当（）中只存在一个元素时， 其后没有 , 号， 那么其类型保持元素原类型 # 有 , 号 ---- 为元组类型 🎬3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5236d94fae30288fd62b080c0273a4b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6b9d516c4b77d2ae9aeb5f7af14951/" rel="bookmark">
			前端实现流文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代Web开发中，经常会遇到需要从服务器下载文件的情况。有时候这些文件是事先存储好的，可以通过简单的URL链接直接下载；但有时候，我们需要从数据流中动态生成文件并将其提供给用户。本篇博客将介绍如何在前端实现流文件下载的完整指南。
了解流文件下载 流文件下载是一种在前端从数据流中动态生成文件并下载的方法。这对于一些特殊的场景非常有用，比如生成PDF文档、导出Excel表格或下载服务器端生成的图像等。
基本原理 在前端实现流文件下载的基本原理如下：
从服务器获取数据流。
将数据流转换成Blob对象。
创建一个URL指向该Blob对象。
创建一个a标签，设置其href属性为该URL，download属性为文件名。
模拟点击a标签，触发文件下载。
完成下载后，释放URL对象。
代码实现
下面是一段简单的JavaScript代码，实现了从数据流中下载文件的功能：
/** * data: 下载文件 * fileName: 文件名 * type: 下载文件类型 */ export function downloadHandler(data, fileName, type) { // 匹配任意文件类型：type : "application/octet-stream" const blob = new Blob([data], { type: type || 'application/octet-stream' }); const downloadElement = document.createElement('a'); const href = window.URL.createObjectURL(blob); downloadElement.href = href; downloadElement.download = fileName; document.body.appendChild(downloadElement); downloadElement.click(); document.body.removeChild(downloadElement); window.URL.revokeObjectURL(href); } 这段代码中，我们首先将数据流转换成Blob对象，然后创建一个a标签，设置其href属性为Blob对象的URL，download属性为文件名。接着将a标签添加到页面中，模拟点击a标签实现文件下载。下载完成后，移除a标签，并释放URL对象。
示例 假设我们有一个后端接口 /api/download，用于提供文件下载服务。我们可以使用fetch API从该接口获取数据流，并通过我们实现的downloadHandler函数实现文件下载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6b9d516c4b77d2ae9aeb5f7af14951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0258911f7eea253177b605882d233030/" rel="bookmark">
			atcoder abc357
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A Sanitize Hands 问题：
思路：前缀和，暴力，你想咋做就咋做
代码：
#include &lt;iostream&gt; using namespace std; const int N = 2e5 + 10; int n, m; int a[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; a[i]; } int ans = 0; for(int i = 1; i &lt;= n; i ++ ) { m -= a[i]; ans = i; if(m &lt;= 0) break; } if(m &lt; 0) cout &lt;&lt; ans - 1; else cout &lt;&lt; ans; return 0; } B Uppercase and Lowercase
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0258911f7eea253177b605882d233030/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42abfea05e7147bef6ef19af1a405fc7/" rel="bookmark">
			Jmeter分布式、测试报告、并发数计算、插件添加方式、常用图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmeter分布式 应用场景
当单个测试机无法模拟用户要求的业务场景时，可以使用多台测试机进行模拟，就是Jmeter的分布
式测试。
Jmeter分布式执行原理
Jmeter分布测试时，选择其中一台作为控制机（Controller），其它机器作为代理机（Agent）
- 执行时，控制机会把脚本发送到每台代理机上
-代理机拿到脚本后就开始执行，代理机执行时不需要启动Jmeter界面，可以理解它是通过命令行模式执行的。
-执行完毕后，代理机会把结果传给控制机，控制机会收集所有代理机的信息并汇总。
分布式相关注意事项：
系统上的防火墙关闭或打开正确的端口
所有控制机、代理机、服务器都在同一网络上
所有机器的Jmeter和Java版本必须一致
关闭RMI SSL开关
Jmeter分布式配置和执行 配置 —修改bin/jmeter.properties文件：
代理机：
- 修改服务端口：保证每个代理机都能正常启动。如果是在同一台机器上演示需要使用不同的端口，多台机器可以不修改。例如：server_port=1999
- 将RMI SSL设置为禁用。例如 server.msi.ssl.disable=true
控制机
​ - 配置代理机远程地址：配置每个代理机的IP+port，多个代理机之间用’,'连接
​ 例如：remote_hosts=192.168.182.100:1099，192.168.182.101:2999
​ - 将RMI SSL设置为禁用。例如： server.msi.ssl.disable=true
执行
- 代理机（命令行启动）：
- 进入bin目录，运行jmeter-server.bat,启动jmeter
启动时如果显示的是上面这样的异常
原因：jmeter.properties的文件找到server.rmi.ssl.disable=false，改为true，并把前面的#去掉
重新启动：
- 控制机（界面方式启动）：
- 进入bin目录，运行jmeter.bat,启动jmeter
选择菜单：运行–&gt;远程启动/远程启动全部
案例：
1.请求：http://www.baidu.com
2.一台控制机和两台执行机，做分布式；要求控制机启动，两台执行机执行，反馈结果。
操作步骤：
1.配置代理机一，并启动
jmeter1：启动jmeter-server.bat文件
2.配置代理机二，并启动
jmeter2：启动jmeter-server.bat文件
3.配置控制机，并启动
主程序：启动jmeter.bat文件,启动jmeter，运行–&gt;远程启动/远程全部启动
4.添加线程组
5.添加HTTP请求-百度
6.添加查看结果树
Jmeter测试报告 聚合报告 作用：收集性能测试结束后，系统的各项性能指标。如：响应时间、并发数、吞吐量、错误率等。
位置：测试计划–&gt;右键–&gt;监听器–&gt;聚合报告
参数介绍：
- Label：每个请求的名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42abfea05e7147bef6ef19af1a405fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2076898b1d53819bf03cf11453a60e0/" rel="bookmark">
			Vue3【十五】标签的Ref属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3【十五】标签的Ref属性 标签的ref属性 用于注册模板引用
用在dom标签上，获取的是dom节点
用在组件上，获取的是组件实例对象
案例截图 目录结构 代码 app.vue &lt;template&gt; &lt;div class="app"&gt; &lt;h1 ref="title2"&gt;你好世界! 我是App根组件&lt;/h1&gt; &lt;button @click="showLog"&gt;点我输出h1标签&gt;&lt;/button&gt; &lt;Person ref="rrr" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup name="App"&gt; import Person from './components/Person.vue' import { ref } from 'vue' let title2 = ref() let rrr = ref() function showLog() { console.log(title2.value) console.log(rrr.value) } // export default { // name: 'App', //组件名字 // // 注册组件 // components: { // Person // } // } &lt;/script&gt; &lt;style&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2076898b1d53819bf03cf11453a60e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ecd450f8c39218256732823a2220c5/" rel="bookmark">
			CTE-6作文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一段 现象 引出原因 第二段 感受 举例 意义 危害 第三段 建议 展望 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08bb4dfc28922da50b838d763e2ce83/" rel="bookmark">
			Android ViewPager2 &#43; FragmentStateAdapter 的使用以及问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景介绍：在Android业务功能开发的过程中，需要使用到嵌套ViewPage2实现页面切换，这种场景在我们的开发过程中并不少见，大致结构为一个activity包含一个viewPage2，这个viewPage2中存在一个fragment A，fragment A中也包含了一个viewPage2。所有viewPage2都使用FragmentStateAdapter 适配器实现界面数据联动。
上述实现过程并不复杂，但是在我实际业务中需要实现activity调用fragmentA中viewPage2的一些方法，当然这个需求可以使用viewModel进行实现，但是由于初版使用了方法调用，遇到了bug所以针对该功能的实现进行初步研究。
FragmentStateAdapter 介绍及简单使用 FragmentStateAdapter 是 Android Jetpack 中提供的用于管理 Fragment 的适配器，它是 RecyclerView.Adapter 的子类。
FragmentStateAdapter 会在 ViewPager 中显示的每个 Fragment 的生命周期之间进行恰当的保存和恢复 Fragment 的状态，以确保内存占用较小。
当 Fragment 不再可见时，FragmentStateAdapter 会销毁该 Fragment 的视图，但会保留其实例状态，以便在需要时重新创建。
适用于大量 Fragment 的场景，特别是数据动态变化或数据量较大的情况。该适配器的最简单使用方式如下：
adapter = new FragmentStateAdapter(getChildFragmentManager(), getLifecycle()) { @NonNull @Override public Fragment createFragment(int position) { return fragments.get(position); } @Override public int getItemCount() { return fragments.size(); } }; fragment切换销毁 在默认情况下，viewPage2提供的性能优化实现了临近一个fragment预加载机制，及如果初始展示第0个fragment，viewPage2也会把第1个fragment进行创建视图但并不展示。也就是说viewPage2默认的缓存机制会缓存三个fragment，一旦需要缓存的实例超过三个，例如从第0个滑动到第2个，则会缓存123位置的fragment，响应的第0个fragment将被销毁，一直执行到onDestroy()生命周期。
值得说明的是：销毁仅仅代表了生命周期的结束，默认情况下该fragment的实例、其内部成员变量以及其绑定的视图都不一定会消失。 基于这一原因，为了防止内存溢出我们在onDestroy()生命周期一般会针对成员变量进行setNull操作。通过setNull可以将成员变量消除引用，以便触发GC。接触过java都清楚即便没有引用的变量也未必里面会触发GC，因此当我门将Binding设置成null后，其关联的view也未必会里面消失，在fragment在此展示时，依旧有可能调用上次绘制过的view进行显示。而且在通过viewPage2切换导致fragment销毁的过程中，其本质上是执行到了onDestroy()生命周期，并不见得会销毁视图，而且viewPage2还将保存一个该fragment的实例！根据上述内容可以总结下面几点：
进入onDestroy生命周期并不能一定是成员变量销毁。通过viewPage2切换导致fragment销毁本质上是让fragment执行到onDestroy()生命周期，但是viewPage2还保存了该fragment的实例如果在onDestroy()生命周期还没有把该fragment成员变量setNull，则viewPage2所持有的该fragment对象依旧保留着这些fragment成员变量在onDestroy()生命周期中将Binding设置成null后并不能将其view都进行清空 fragment展示 展示通常有三种，一种是viewPage2内缓存的fragment复现，一种是新的未展示过的fragment展示，还有一种是被销毁了的fragment的展示：他们对应一下过程：
缓存内fragment展示：执行onResume()后直接进行展示未展示过的fragment展示：调用构造方法初始化实例 – 调用onCreate一直执行到onResume生命周期销毁的fragment重新展示：调用onCreateView一直执行到onResume进行展示。 需要注意的是销毁的fragment重新展示的过程中并没有进行fragment实例创建，因此本质上viewPage2已经拥有该实例了，知识当时调用了onDestroy方法而已。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08bb4dfc28922da50b838d763e2ce83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144a58f0e9fb4bae074d2f925cac5183/" rel="bookmark">
			【AIGC】基于大模型&#43;知识库的Code Review实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景描述
二、技术原理
三、基于大模型与知识库的Code Review实践
1、选择合适的大模型与知识库
2、集成大模型与知识库到Code Review流程
3、结合人工审查
4、持续优化与改进
四、技术细节
1、gitlab配置mr的webhook
获得差异代码
2、请求通义千问获得review结果
前提条件
3、Gitlab调用代码review评论API
1. 获取私有令牌（Private Token）
2. 调用 API
3. 创建评论
4. 注意事项
参考资料
一、背景描述 一句话介绍就是：基于开源大模型 + 知识库的 Code Review 实践，类似一个代码评审助手（CR Copilot）。信息安全合规问题：公司内代码直接调 ChatGPT / Claude 会有安全/合规问题，为了使用 ChatGPT / Claude 需要对代码脱敏，只提供抽象逻辑，这往往更花时间。低质量代码耗费时间：业务每天至少 10~20 个 MR 需要 CR，虽然提交时 MR 经过 单测 + Lint 过滤了一些低级错误，但还有些问题（代码合理性、经验、MR 相关业务逻辑等）需要花费大量时间，最后可以先经过自动化 CR，再进行人工 CR，可大大提升 CR 效率！符合公司安全规范，所有代码数据不出内网，所有推理过程均在内网完成团队 Code Review 规范缺少执行：大部分团队的 Code Review 停留在文档纸面上，成员之间口口相传，并没有一个工具根据规范来严格执行。🌈 开箱即用：基于 Gitlab CI，仅 10 几行配置完成接入，即可对 MR 进行 CR。🔒 数据安全：基于开源大模型做私有化部署，隔离外网访问，确保代码 CR 过程仅在内网环境下完成。♾ 无调用次数限制：部署在内部平台，只有 GPU 租用成本。📚 自定义知识库：CR 助手基于提供的飞书文档进行学习，将匹配部分作为上下文，结合代码变更进行 CR，这将大大提升 CR 的准确度，也更符合团队自身的 CR 规范。🎯 评论到变更行：CR 助手将结果评论到变更代码行上，通过 Gitlab CI 通知，更及时获取 CR 助手给出的评论。 二、技术原理 三、基于大模型与知识库的Code Review实践 基于大模型与知识库的Code Review实践，具体实施细节可以归纳如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/144a58f0e9fb4bae074d2f925cac5183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df43ad4203293807036bf054d632bb7e/" rel="bookmark">
			2024华为OD机试题库-(A卷&#43;B卷&#43;C卷&#43;D卷)-(JAVA、Python、C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主是一名资深后端开发人员，精通C++，Python，Java，乐于分享面试经验，已帮助千余名同学通过OD机考，非常感谢大家长期以来的信任和支持！
2024年5月开始，考的都是D卷，题库已经整理好，三道全中概率95%以上，奉上C卷D卷链接：https://blog.csdn.net/goldarmour，祝大家考试顺利。
(免费试读) 2024华为OD机试真题C卷D卷100分-小朋友来自多少小区-(C++/Java/Python)
以下为历史真题，大家可拿来练手。
以下为OD统一考试(B卷)的题目：
OD统一考试(B卷)100分题目 序号 题目分数考点类型1补种未成活胡杨100滑动窗口OD统一考试 B卷2路灯照明问题100区间交并集OD统一考试 B卷3敏感字段加密100字符串处理OD统一考试 B卷4阿里巴巴找黄金宝箱(I)100单指针OD统一考试 B卷5喊7的次数重排100约瑟夫环OD统一考试 B卷6斗地主之顺子100逻辑分析OD统一考试 B卷7IPv4地址转换成整数100字符串处理OD统一考试 B卷8分苹果100位运算OD统一考试 B卷9组成最大数100自定义排序OD统一考试 B卷10最大花费金额100双指针OD统一考试 B卷11太阳能板最大面积100双指针OD统一考试 B卷12座位调整100逻辑分析OD统一考试 B卷13选修课100自定义排序，数据结构OD统一考试 B卷14分班100逻辑分析OD统一考试 B卷15分糖果100递归OD统一考试 B卷16最远足迹100字符串处理OD统一考试 B卷17需要打开多少监控器100逻辑分析OD统一考试 B卷18VLAN资源池100逻辑分析OD统一考试 B卷19求字符串中所有整数的最小和100字符串处理OD统一考试 B卷20求满足条件的最长子串长度100滑动窗口OD统一考试 B卷21TLV解析 Ⅰ100字符串分隔匹配OD统一考试 B卷22拼接URL100字符串处理OD统一考试 B卷23水仙花数 Ⅰ100数学运算OD统一考试 B卷24最大股票收益100贪心算法OD统一考试 B卷25找朋友100单调栈OD统一考试 B卷26找车位100逻辑分析OD统一考试 B卷27猴子爬山100动态规划OD统一考试 B卷28按身高和体重排队100自定义排序OD统一考试 B卷29阿里巴巴找黄金宝箱(Ⅱ)100贪心思维OD统一考试 B卷30玩牌高手100贪心思维OD统一考试 B卷31告警抑制100逻辑分析OD统一考试 B卷32寻找身高相近的小朋友100自定义排序OD统一考试 B卷33消消乐游戏100数据结构 栈OD统一考试 B卷34数组组成的最小数字100自定义排序OD统一考试 B卷35求最多可派出多少支团队100双指针OD统一考试 B卷36数组去重和排序100自定义排序，数据结构OD统一考试 B卷37快递运输100逻辑分析OD统一考试 B卷38停车场车辆统计100逻辑模拟OD统一考试 B卷39 查找众数及中位数
100数据结构OD统一考试 B卷40滑动窗口最大和100滑动窗口OD统一考试 B卷41连续字母长度100滑动窗口OD统一考试 B卷42寻找相同子串100字符串查找OD统一考试 B卷43阿里巴巴找黄金宝箱(Ⅲ)100数据结构OD统一考试 B卷44报文重排序100字符串分隔OD统一考试 B卷45 阿里巴巴找黄金宝箱(V)
100滑动窗口OD统一考试 B卷46五子棋迷100滑动窗口OD统一考试 B卷47字符串摘要100滑动窗口，自定义排序OD统一考试 B卷48数组拼接100逻辑分析OD统一考试 B卷49矩阵稀疏扫描100逻辑分析OD统一考试 B卷50文件目录大小100dfsOD统一考试 B卷51恢复数字序列100滑动窗口OD统一考试 B卷52分割数组的最大差值100逻辑分析OD统一考试 B卷53生日礼物100二分查找OD统一考试 B卷54乘坐保密电梯100逻辑分析OD统一考试 B卷55拔河比赛100自定义排序OD统一考试 B卷56计算最接近的数100滑动窗口OD统一考试 B卷57矩阵元素的边界值100数据结构OD统一考试 B卷58增强的strstr100正则表达式OD统一考试 B卷59最长公共后缀100字符串操作OD统一考试 B卷60支持优先级的队列100自定义排序OD统一考试 B卷61数字反转打印100逻辑分析OD统一考试 B卷62跳房子1100两数之和OD统一考试 B卷63数字涂色100逻辑分析OD统一考试 B卷64勾股数元组100数学知识OD统一考试 B卷65工号不够用了怎么办100数学知识OD统一考试 B卷66计算最大乘积100字符串处理OD统一考试 B卷67比赛的冠亚季军100逻辑分析OD统一考试 B卷68报文回路100逻辑分析OD统一考试 B卷69响应报文时间100字符串处理OD统一考试 B卷70食堂供餐100逻辑分析OD统一考试 B卷71经典屏保100数学运算OD统一考试 B卷72数据分类100位运算OD统一考试 B卷73按单词下标区间翻转文章内容100字符串处理OD统一考试 B卷74比赛100自定义排序OD统一考试 B卷75模拟消息队列100逻辑分析OD统一考试 B卷76荒岛求生100逻辑分析OD统一考试 B卷77奖牌榜排名100自定义排序OD统一考试 B卷78报数游戏100逻辑分析OD统一考试 B卷79数字最低位排序100自定义排序OD统一考试 B卷80GPU算力100逻辑分析OD统一考试 B卷81最长连续子序列100滑动窗口OD统一考试 B卷82最长元音子串100滑动窗口OD统一考试 B卷83 字符串子序列II
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df43ad4203293807036bf054d632bb7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e147330e8a12125b950d3b287bc9640/" rel="bookmark">
			【Golang】Go语言中defer与return的精妙交织：探索延迟执行与返回顺序的微妙关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Golang】Go语言中defer与return的精妙交织：探索延迟执行与返回顺序的微妙关系 大家好 我是寸铁👊
总结了一篇defer 和 return 返回值 的执行顺序探讨的文章✨
喜欢的小伙伴可以点点关注 💝
前言 在Go语言中，defer 和return是两个非常重要的关键字，它们在函数执行过程中起着至关重要的作用。defer 用于延迟执行一个函数调用，通常用于在函数执行结束后进行一些清理工作或资源释放操作。而return则用于从函数中返回结果并终止函数的执行。在Go语言中，defer 语句的执行时机和返回值的处理方式涉及到一些微妙的规则，特别是在 defer 和 return 同时出现时，其执行顺序可能会引发一些混淆和困惑。
本文将深入探讨Go语言中 defer 和return的执行顺序，并解释它们之间的关系。我们将详细讨论在不同情况下，defer 和 return 的执行顺序及其影响，以帮助读者更好地理解和使用这两个关键字，从而写出更加健壮、清晰的代码。
defer与return常考点 简述 defer 和 return 返回值 的执行顺序？如果要返回一个 defer 执行后的值, 可以通过哪些方式？
程序1 不返回具体变量 执行顺序：
进入test函数
先把返回的结果赋值执行defer函数如果说defer函数中存在打印输出的内容，则先输出defer语句的内容。
按照指定的顺序输出，后进先出的顺序输出再返回到主函数main中，把之前赋值的返回的结果输出来 注意：return的结果是不会受defer函数而影响的，但是假如在defer外 在return之前进行赋值
则会返回当前更新的值。
demo
func Test() int { a := 1 defer func() { fmt.Println("a", a) // a 1 a = 4 fmt.Println("2", a) // 2 4 }() return a // 1 } func main() { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e147330e8a12125b950d3b287bc9640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a3ffa92d48245eb8d82c31780cf04f/" rel="bookmark">
			Golang Context详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本介绍context源码剖析Context接口emptyCtxcancelCtxtimerCtxvalueCtx context使用案例协程取消超时控制数据共享 基本介绍 基本介绍
在Go 1.7版本中引入了上下文（context）包，用于在并发编程中管理请求范围的数据、控制生命周期、处理取消信号和超时等。context在Go中具有重要的作用，特别是在并发编程和网络编程中，因此context通常会作为各个函数和方法的首个入参。 context源码剖析 Context接口 Context接口
Context是context包中的一个接口类型，该接口提供了对上下文的基本操作和属性的访问方法，其定义如下：
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct{} Err() error Value(key any) any } Context接口中各方法说明：
Deadline方法：返回上下文的截止时间。其第一个返回值表示上下文的截止时间，第二个返回值表示上下文是否存在截止时间。Done方法：返回一个只读的channel，用于接收上下文的取消信号。当上下文被取消时，该channel将会被关闭，从而通知使用者上下文已经被取消。Err方法：返回与上下文关联的错误。当上下文被取消时，返回context.Canceled错误，当上下文到达截止时间时，返回context.DeadlineExceeded错误。Value方法：根据指定的键获取上下文中关联的值。如果找到与键相关的值，则返回该值，如果未找到，则返回nil。 说明一下：
Done方法返回的channel的类型是chan struct{}，而空struct中实际无法存储任何数据，因为该channel本就不是用作数据存储的，而是用作传递取消信号的。在context包中，有四个结构体类型实现了Context接口，分别是emptyCtx、cancelCtx、timerCtx和valueCtx。 emptyCtx emptyCtx
emptyCtx是context包中的一个自定义类型，用于表示一个空的上下文，它实现了Context接口，其定义如下：
type emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() &lt;-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key any) any { return nil } emptyCtx实现的四个方法说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a3ffa92d48245eb8d82c31780cf04f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4c6b4cda047a5dd220f1a0216e035c/" rel="bookmark">
			【C&#43;&#43;进阶】深入STL之 栈与队列：数据结构探索之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C++ “ 登神长阶 ”
🤡往期回顾🤡：模拟实现list与迭代器
🌹🌹期待您的关注 🌹🌹
❀stack和queue 📕1. stack和queue的基本概念🎩stack的基本概念🎈queue的基本概念 📙2. stack与queue的常用操作⛰️stack的常用操作🌄queue的常用操作 📚3. 容器适配器📒4. deque的简单介绍💧deque的原理介绍🌊deque的缺陷 📜5. stack和queue的模拟实现🍂stack的模拟实现🍁queue的模拟实现 📖6. priority_queue🌞priority_queue的基本概念🌙priority_queue的常用操作⭐priority_queue的模拟实现 🔥7. 总结 前言： 在编程的世界里，数据结构是构建高效、可靠程序的基础。它们就像是我们编程工具箱中的精密工具，帮助我们解决各种复杂的问题。而在C++的STL中，栈（Stack）和队列（Queue）是两种非常重要的数据结构，它们以不同的方式管理和操作数据，为我们的程序提供了极大的灵活性
为了真正掌握它们，我们需要深入学习它们在STL中的实现方式，理解它们背后的原理和机制，以及学习如何在实际编程中有效地使用它们，让我们一起踏上学习STL栈与队列的旅程吧！
📕1. stack和queue的基本概念 🎩stack的基本概念 栈（Stack）是一种后进先出（LIFO）的数据结构
它的操作特性使其在处理递归调用、函数调用栈以及撤销操作等问题时表现出色。通过栈，我们可以轻松地实现如括号匹配、表达式求值等算法。 🎈queue的基本概念 队列（Queue）则是一种先进先出（FIFO）的数据结构
它在处理需要按顺序处理的任务时非常有用。无论是操作系统中的任务调度，还是网络中的数据包传输，队列都扮演着不可或缺的角色。 📙2. stack与queue的常用操作 ⛰️stack的常用操作 函数说明接口说明stack()构造空的栈empty()检测stack是否为空size()返回stack中元素的个数top()返回栈顶元素push()将元素val压入stack中pop()将stack中尾部的元素弹出 void test_stack() { stack&lt;int, vector&lt;int&gt;&gt; st; // 构造栈 st.push(1); // 将元素val压入stack中 st.push(2); st.push(3); st.push(4); printf("栈中有效元素个数为：%d", st.size()); // 返回stack中元素的个数 while (!st.empty()) // 检测stack是否为空 { printf("%d ", st.top()); // 返回栈顶元素的引用 st.pop(); // 将stack中尾部的元素弹出 } } 相较于之前的栈的常用函数学习还是很简单的，在了解完基本用法后，这里推荐几个相关题目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4c6b4cda047a5dd220f1a0216e035c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183b2166bd7e44146288e51d98796b05/" rel="bookmark">
			AI大模型探索之路-实战篇16：优化决策流程：Agent智能数据分析平台中Planning功能实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-实战篇4：深入DB-GPT数据应用开发框架调研
AI大模型探索之路-实战篇5：探索Open Interpreter开放代码解释器调研
AI大模型探索之路-实战篇6：掌握Function Calling的详细流程
AI大模型探索之路-实战篇7：Function Calling技术实战自动生成函数
AI大模型探索之路-实战篇8：多轮对话与Function Calling技术应用
AI大模型探索之路-实战篇9：探究Agent智能数据分析平台的架构与功能
AI大模型探索之路-实战篇10：数据预处理的艺术：构建Agent智能数据分析平台的基础
AI大模型探索之路-实战篇11： Function Calling技术整合：强化Agent智能数据分析平台功能
AI大模型探索之路-实战篇12： 构建互动式Agent智能数据分析平台：实现多轮对话控制
AI大模型探索之路-实战篇13： 从对话到报告：打造能记录和分析的Agent智能数据分析平台
AI大模型探索之路-实战篇14： 集成本地Python代码解释器：强化Agent智能数据分析平台
AI大模型探索之路-实战篇15： Agent智能数据分析平台之整合封装Tools和Memory功能代码
目录 系列篇章💥一、前言二、人类意图挖掘三、增加Few-SHOT和COT思维链能力1、增加few-shot提示词2、添加思维链模版 四、大模型首次交互逻辑封装1、基本问答效果测试2、function call功能测试3、专家模式测试4、开发者模式测试5、专家模式下下用户意图探究能力测试6、开发者模式下下用户意图探究能力测试 五、function call执行结果消息封装六、完成用户一次的完整交互1、一次完整交互函数2、外层调用函数3、响应结果检查函数4、文本内容检查函数5、普通调用测试6、对比开发者模式7、带有Function Calling调用8、复杂问题拆解9、测试对比有代码调用的Function Calling10、测试开发者模式(不涉及代码执行)11、测试专家模式12、Agent对话封装调用 七、结语 一、前言 在前面篇章中我们实现了Agent智能数据分析平台中的Tools和Memory两大块，本文中我们将实现Agent智能数据分析平台中最核心的模块Plan，发掘探索人类意图，优化整个决策流程。
二、人类意图挖掘 msg_error_test = MessageManager(system_content_list=[data_dictionary], question="分析iquery数据库中的这四张表，帮我梳理一个数据分析的基本思路") second_response = client.chat.completions.create( model='gpt-3.5-turbo', messages=msg_error_test.messages, tools=af.functions, tool_choice="auto" ) second_response 输出：
ChatCompletion(id='chatcmpl-rtFBgtNzSwoMmJONpYdGjHIWTLmXE', choices=[Choice(finish_reason='tool_calls', index=0, logprobs=None, message=ChatCompletionMessage(content='', role='assistant', function_call=None, tool_calls=[ChatCompletionMessageToolCall(id='call_nu8zFoKl61VDF6yaCnWFRhpY', function=Function(arguments='{"g": "test", "sql_query": "DESC user_demographics;"}', name='sql_inter'), type='function'), ChatCompletionMessageToolCall(id='call_RaTHPfo93K3DWByG9n4gW7w1', function=Function(arguments='{"g": "test", "sql_query": "DESC user_services;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183b2166bd7e44146288e51d98796b05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f37861452f19d8910acd3e1f7c57777/" rel="bookmark">
			函数递归（C语言）（详细过程！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数递归 一. 递归是什么1.1 递归的思想1.2 递归的限制条件 二. 递归举例2.1 求n的阶乘2.2 按顺序打印一个整数的每一位 三. 递归与迭代3.1 求第n个斐波那契数 一. 递归是什么 递归是学习C语言很重要的一个知识，递归就是函数自己调用自己，是一种解决问题的方法，下面就使用一个简单的代码帮助大家理解：下面展示一些 内联代码片。
#include &lt;stdio.h&gt; int main() { printf("hehe\n"); main() //出现了main函数自己调用自己 return 0； 上图展示的代码就是一个简单的调用函数的例子，不断的调用main函数也就是要不断输出hehe，形成了一个循环，这就是一个简单的函数递归。
1.1 递归的思想 把一个大型问题转换成一个与原问题相似但是规模较小的子问题来解决，直到到子问题不能再被拆分，递归就结束了。递归中的递就是递推的意思，归就是回归的意思，下面会有详细的解释。
1.2 递归的限制条件 递归在书写的时候，有两个必要条件：
. 递归存在限制条件，当满足这个限制条件的时候，递归便不再继续
. 每次递归之后越来越接近这个限制条件
二. 递归举例 2.1 求n的阶乘 为了让大家更好理解递归是怎么回事，我们可以举几个例子，下面为大家展示第一个例子求n的阶乘的代码： 内联代码片。
int Fact(int n) { if (n == 0) return 1; else if (n &gt; 0) return n * Fact(n - 1);//相当于是多次调用这个函数，形成一个循环，不断地累乘 } int main() { int n = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f37861452f19d8910acd3e1f7c57777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f70600ecaa93f6f0e9cd51ce75406c/" rel="bookmark">
			MacOS升级ruby版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MacOS自带ruby版本是2.x，可以通过“ruby -v”查看版本号
$ ruby -v ruby 2.6.10p210 (2022-04-12 revision 67958) [universal.x86_64-darwin22] homebrew安装的ruby版本号可以通过“brew info ruby”命令参看
$ brew info ruby ==&gt; ruby: stable 3.3.2 (bottled), HEAD [keg-only] Powerful, clean, object-oriented scripting language https://www.ruby-lang.org/ 如果没有安装，可以“brew install ruby”进行安装
$ brew install ruby Warning: No remote 'origin' in /usr/local/Homebrew/Library/Taps/homebrew/homebrew-services, skipping update! Warning: ruby 3.3.2 is already installed and up-to-date. ... 或者通过“brew install ruby”进行升级
$ brew upgrade ruby Warning: No remote 'origin' in /usr/local/Homebrew/Library/Taps/homebrew/homebrew-services, skipping update!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85f70600ecaa93f6f0e9cd51ce75406c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/283/">«</a>
	<span class="pagination__item pagination__item--current">284/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/285/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>