<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53b51deb439bee331ed6571c4c95119/" rel="bookmark">
			python 10个自动化脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🌟 引言
📚 理论基础
🛠️ 使用场景与代码示例
场景一：批量重命名文件
场景二：自动下载网页内容
场景三：数据清洗
场景四：定时执行任务
场景五：自动化邮件发送
场景六：自动化测试
场景七：数据库操作
场景八：日志分析
场景九：文件压缩
场景十：自动化文档生成
🎉 结语
🌟 引言 在程序员的世界里，自动化是提升效率的金钥匙。Python，以其易读性和强大的库支持，成为了实现自动化任务的首选语言。本文精选了10个实用的Python自动化脚本，涵盖文件处理、网络请求、数据分析等多个领域，旨在帮你节省时间，减少重复劳动，提升工作效能。
📚 理论基础 Python的自动化脚本主要依赖于标准库和第三方库，如os、requests、pandas等。通过这些库，我们可以轻松实现文件操作、数据抓取、数据分析等功能。
🛠️ 使用场景与代码示例 场景一：批量重命名文件 在处理大量媒体文件时，统一命名规则非常必要。
代码示例 import os def batch_rename(directory, prefix): i = 1 for filename in os.listdir(directory): ext = os.path.splitext(filename)[1] new_name = f"{prefix}_{i}{ext}" os.rename(os.path.join(directory, filename), os.path.join(directory, new_name)) i += 1 batch_rename('/path/to/directory', 'file') 场景二：自动下载网页内容 对于研究者或数据分析师来说，自动抓取网络数据至关重要。​​​​​​​
代码示例 import requests def download_webpage(url, output_file): response = requests.get(url) with open(output_file, 'w') as file: file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53b51deb439bee331ed6571c4c95119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4446d5b74f3651123a16992c334fb29/" rel="bookmark">
			【手写数据库内核组件】0201 哈希表hashtable的实战演练，多种非加密算法，hash桶的冲突处理，查找插入删除操作的代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hash表原理与实战 ​专栏内容：
postgresql使用入门基础手写数据库toadb并发编程 个人主页：我的主页
管理社区：开源数据库
座右铭：天行健，君子以自强不息；地势坤，君子以厚德载物.
文章目录 hash表原理与实战一、概述 二、hash表整体介绍 2.1 hash表的应用场景 2.2 整体架构 三、hash算法选择 四、hash表操作 4.1 冲突处理 4.2 查找操作 4.3 插入操作 4.4 删除操作 五、总结 结尾 一、概述 hash表的应用非常广泛，在网上也可以看到分享的各种hash表的实现，都比较概念化。
本章节从实战的角度出发，以数据库内核中的应用为例，来看看hash表的原理与实现。
二、hash表整体介绍 哈希算法（Hash）又称摘要算法，它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。
哈希算法最重要的特点就是：
相同的输入一定得到相同的输出；不同的输入大概率得到不同的输出； 我们想利用hash算法的这一特性，将输入的一组数据，经过hash算法计算后，输出唯一的 32位或64位的整形值key。
当我们需要找到存储的数据时，通过这个key查找，而查找整型值的效率就很高了，可以用二分法进行查找。
这样一个存储数据的结构，我们叫它hash表，也就是通常说的key-value形式的存储，它的查找效率与数据的类型无关。
2.1 hash表的应用场景 hash表一般用于存储大量的数据，而数据的类型是字符串，或者更复杂的复合类型结构体，或者是更大的数据；
直接通过原始数据进行查找时，代价非常高，将它们转换为hash 值后，就可以通过恒定的效率进行查找。
在数据库中的应用有：
数据块缓存，某个数据块是否已经在缓存中，通过对数据块编号的hash值进行查找；系统字典的查找，某个表是否已经创建了，通过表的hash值进行查找；hash索引，记录数据的hash值，查找时按hash值进行查找； 2.2 整体架构 hash表的实现一般由几方面组成，hash算法，bucket计算，冲突处理，key-value对应形式，以及三种操作。
既然是一个table，那么内部基本存储结构是一个数组，数组的最大元素个数就是capacity；数组中的每个元索叫做bucket桶，来存储key-value对数据；bucket位置的计算，一般会采用 hash值 % capacity 来计算；hash值一般是一个32位，64位或者128位的整数，取余后得到数组中的下标，这就是当前key-value要存储的位置； 三、hash算法选择 查找主要依赖高效的hash值的计算，一个高效，碰撞少的算法，能让hashtable的效率大大提升。
常见的hash算法有，MD5, sha-256等，这些常用于加密，而hashtable并不需要对数据进行加密，更看重计算的效率。
由此出现了一些快速hash算法，比较有名的如：
murmurhash3, 这是第三个版本，速度公认的非常快，开源了各种语言实现；Spookyhash，这个目前支持128位；cityhash，是google发布的，会利用现代CPU的特性进行性能提升，对于低于64位的输入处理比较复杂； 建议使用murmurhash3，算法简单高效，对于较少的输入也能高效处理。
这些算法都可以在github上下载得到，加入.c,.h文件后就可以直接调用使用。
类似如下调用：
seed = 123456789 data = "example data" hash_value = murmur_hash(seed, data) 四、hash表操作 hash表的操作一般有插入，查找，删除三类基本操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4446d5b74f3651123a16992c334fb29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d2546c893e0f625decc4f00aa873ed8/" rel="bookmark">
			封装了一个仿照抖音效果的iOS评论弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景 开发一个类似抖音评论弹窗交互效果的弹窗，支持滑动消失，
滑动查看评论
效果如下图
思路 创建一个视图，该视图上面放置一个tableView, 该视图上添加一个滑动手势，同时设置代理，实现代理方法
(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
支持同时响应手势，就是为了我们tableView滚动到顶部的时候，继续滚动父亲视图，达到连续滑动的效果，如果不是设置同时响应的话，我们滚动到tableView顶部，继续向下滑动的话，整个弹窗是不会向下滑动的，同时，滚动到顶部的时候，要设置tableView.pangesture.enabled = NO,否则反复来回滑动的时候，会造成两个视图同时滚动的效果 代码 // // LBCommentPopView.m // TEXT // // Created by mac on 2024/7/7. // Copyright © 2024 刘博. All rights reserved. // #import "LBCommentPopView.h" #import "LBFunctionTestHeader.h" @interface LBCommentPopView () &lt;UIGestureRecognizerDelegate&gt; @property (nonatomic, strong) UITapGestureRecognizer *tapGesture; @property (nonatomic, strong) UIPanGestureRecognizer *panGesture; @property (nonatomic, weak) UIScrollView *scrollView; @property (nonatomic, assign) BOOL isDragScrollView; @property (nonatomic, assign) CGFloat lastTransitionY; @end @implementation LBCommentPopView - (instancetype)initWithFrame:(CGRect)frame { if (self = [super initWithFrame:frame]) { [self createRecognizer]; } return self; } - (void)createRecognizer { [self addGestureRecognizer:self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d2546c893e0f625decc4f00aa873ed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce536c9c27d72125a818c7b472afc3e8/" rel="bookmark">
			【Python】搭建属于自己 AI 机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1 准备工作
1.1 环境搭建
1.2 获取 API KEY
2 写代码
2.1 引用库
2.2 创建用户
2.3 创建对话
2.4 输出内容
2.5 调试
2.6 全部代码
2.7 简短的总结
3 优化代码
3.1 规范代码
3.1.1 引用库
3.1.2 创建提示词
3.1.3 创建模型
3.1.4 规范输出（非必须）
3.2 用户输入
3.3 连接步骤
3.4 循环输入
3.5 全部代码
4 总结
前言 现在，AI 已经进入了人们生活的每个角落，而 AI 大模型更是大火，诸如文心一言、Chatgpt、Kimi、清谱智言等等。
那为什么不能拥有一个自己的 AI 呢？于是我稍微研究了一下，本篇文章就将介绍如何搭建一个属于自己的 AI 机器人。话不多说，正片开始——
1 准备工作 1.1 环境搭建 自己训练一个 AI 机器人费时费力又费钱，所以搭建 AI 用的肯定是 API 接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce536c9c27d72125a818c7b472afc3e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e300747e52707ccc2525590360279f/" rel="bookmark">
			二叉树的链式结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Hello,友友们，小编将继续重新开始数据结构的学习，前面讲解了堆的部分知识，今天将讲解二叉树的链式结构的部分内容。
1.概念回顾与新增 二叉树是一种数据结构，其中每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树的链式结构表示是使用指针（或引用）来连接节点，形成树形结构。每个节点包含一个数据元素和两个指向子节点的指针。
2.简单创建二叉树 分为节点的定义，创建节点，创建树
下面我们将简单的手撕一个二叉树：
typedef struct BTnode { int val; struct BTnode* left; struct BTnode* right; }Node; //节点创建 Node* BuyNode(int x) { Node* node = (Node*)malloc(sizeof(Node)); if (node == NULL) { perror("node fail"); return NULL; } node-&gt;val = x; node-&gt;left = NULL; node-&gt;right = NULL; return node; } //树的创建 Node* CreatTree() { Node* node1 = BuyNode(1); Node* node2 = BuyNode(2); Node* node3 = BuyNode(3); Node* node4 = BuyNode(4); Node* node5 = BuyNode(5); Node* node6 = BuyNode(6); node1-&gt;left = node2; node1-&gt;right = node4; node2-&gt;left = node3; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } 注意：上述代码并不是创建二叉树的方式，真正创建二叉树方式后序详解重点讲解。 二叉树建立过后，接下来我们要进行二叉树的遍历操作 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e300747e52707ccc2525590360279f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3fb0f36c32c1610cf0205e418ea5a6d/" rel="bookmark">
			Could not install Gradle distribution from ‘https://services.gradle.org/distributions/gradle-8.7-bin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、报错信息 Could not install Gradle distribution from 'https://services.gradle.org/distributions/gradle-8.7-bin.zip'. Reason: java.net.ConnectException: Connection refused: no further information Please ensure gradle distribution url is correct. If you are behind an HTTP proxy, please configure the proxy settings. 2、问题解决 （1）手动下载配置
通过报错信息给出的下载链接 https://services.gradle.org/distributions/gradle-8.7-bin.zip，点击后即可进入下载，不过我测试后发现我需要科学上网才能下载。
下载完成后，解压到纯英文目录，然后配置环境变量，在系统变量的Path中新增一项，并粘贴gradle下的bin的目录
打开cmd，输入gradle -v，可以查看到下面的信息说明配置成功。
再去android studio 重新加载配置
（2）使用国内镜像源，找到该目录下的gradle-wrapper.properties文件
将distributionUrl后面的路径，更换为
https://mirrors.aliyun.com/macports/distfiles/gradle/gradle-8.7-bin.zip 此路径为阿里镜像源，国内可以快速下载
其他镜像源：
腾讯云镜像 Gradle下载地址：https://mirrors.cloud.tencent.com/gradle/
阿里云镜像 Gradle下载地址：https://mirrors.aliyun.com/macports/distfiles/gradle/
阿里云镜像 Gradle下载地址：https://mirrors.aliyun.com/gradle/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf482a59e15c7c3e3b389eae04dff80/" rel="bookmark">
			C语言牢大坠机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 开头程序程序的流程图《牢大坠机》结尾 开头 大家好，我叫这是我58，今天，我们要来看关于牢大坠机的一些东西。
程序 #define _CRT_SECURE_NO_WARNINGS 1 #define HIGH 66 #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; int main() { int i = 0; int ia = 0; for (i = 0; i &lt; HIGH; i++) { for (ia = 0; ia &lt; i; ia++) { printf("\n"); } printf("牢大的直升机"); for (ia = 0; ia &lt; HIGH - i; ia++) { printf("\n"); } printf("------------"); Sleep(100); system("cls"); } return 0; } 程序的流程图 是 是 否 是 否 等待0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cf482a59e15c7c3e3b389eae04dff80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e808b6fe45e0cc8ef3b24240f9a9773e/" rel="bookmark">
			分子性质AI预测挑战赛｜Datawahle AI夏令营｜代码分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		赛题背景
在当今科技日新月异的时代，人工智能（AI）技术正以前所未有的深度和广度渗透到科研领域，特别是在化学及药物研发中展现出了巨大潜力。精准预测分子性质有助于高效筛选出具有优异性能的候选药物。以PROTACs为例，它是一种三元复合物由目标蛋白配体、linker、E3连接酶配体组成，靶向降解目标蛋白质。本次大赛聚焦于运用先进的人工智能算法预测其降解效能，旨在激发参赛者创新思维，推动AI技术与化学生物学的深度融合，进一步提升药物研发效率与成功率，为人类健康事业贡献智慧力量。通过此次大赛，我们期待见证并孵化出更多精准、高效的分子性质预测模型，共同开启药物发现的新纪元。
赛事任务与数据
选手根据提供的demo数据集，可以基于demo数据集进行数据增强、自行搜集数据等方式扩充数据集，并自行划分数据。运用深度学习、强化学习或更加优秀人工智能的方法预测PROTACs的降解能力，若DC50&gt;100nM且Dmax&lt;80% ，则视为降解能力较差（demo数据集中Label=0）；若DC50&lt;=100nM或Dmax&gt;=80%，则视为降解能力好（demo数据集中Label=1）。
大白话解释：
【训练分子性质分类预测模型】运用深度学习、强化学习或更加优秀人工智能的方法预测PROTACs的降解能力，分类为 降解能力较差/降解能力好 两种结论
评价指标
本次竞赛的评价标准采用f1_score，分数越高，效果越好
解题思路
参赛选手的任务是基于训练集的样本数据，构建一个模型来预测测试集中分子的性质情况。这是一个二分类任务，其中目标是根据分析相关信息以及结构信息等特征，预测该分子的性质标签。具体来说，选手需要利用给定的数据集进行特征工程、模型选择和训练，然后使用训练好的模型对测试集中的用户进行预测，并生成相应的预测结果。
导入必要的库 import numpy as np import pandas as pd import joblib from catboost import CatBoostClassifier from sklearn.model_selection import StratifiedKFold, KFold, GroupKFold from sklearn.metrics import f1_score from rdkit import Chem from rdkit.Chem import Descriptors,rdMolDescriptors,GraphDescriptors,Lipinski from rdkit.Chem.rdMolDescriptors import CalcMolFormula, CalcTPSA from rdkit.Chem.Crippen import MolLogP from sklearn.feature_extraction.text import TfidfVectorizer from openfe import OpenFE, tree_to_formula, transform, TwoStageFeatureSelector from gensim.models import Word2Vec import tqdm, sys, os, gc, re, argparse, warnings warnings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e808b6fe45e0cc8ef3b24240f9a9773e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c92cd9b4279452b0c3f446b3641b6c/" rel="bookmark">
			AI是在帮助开发者还是取代他们？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空 🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 在软件开发领域，生成式人工智能（AIGC）正在以惊人的速度改变开发者的工作方式。如今，无论是代码生成、错误检测还是自动化测试，AI工具已经成为许多开发者的得力助手。然而，随着AI技术的不断进步，也引发了对开发者职业前景和技能需求变化的讨论。那么，AI究竟是在帮助开发者，还是在慢慢取代他们呢？让我们从多个角度深入探讨这个问题。
方向一：AI工具现状 📈🔧 主流的AI开发工具 目前，市场上有很多优秀的AI开发工具正在帮助开发者提高效率。其中一些著名的工具包括：
GitHub Copilot ✍️ 由OpenAI和GitHub合作开发的Copilot，基于GPT-3，为开发者提供智能的代码建议。无论是补全代码片段、生成函数，还是编写文档注释，Copilot都可以极大地提升编码速度。它能够学习并适应开发者的编码风格，提供个性化的建议。
TabNine 🔮 这是一款AI驱动的代码补全工具，支持多种编程语言。TabNine利用深度学习模型，为开发者提供快速且准确的代码补全建议。它的强大之处在于能够理解上下文，从而提供更符合开发者需求的建议。
DeepCode 🔍 这款工具专注于代码质量分析和错误检测。DeepCode利用AI技术扫描代码库，发现潜在的漏洞和代码质量问题，并提供修复建议。它不仅帮助开发者提升代码质量，还能加快代码审查过程。
AI工具的功能和局限性 这些AI工具的功能不仅限于简单的代码补全，它们还可以自动生成测试用例、优化代码性能，并进行语义分析。然而，它们也有一些局限性：
依赖上下文和数据质量 📚 AI工具的表现高度依赖于它们接受的训练数据和所提供的上下文信息。如果数据不完整或上下文不清晰，AI建议的准确性可能会受到影响。
需要开发者的监督和指导 👀 尽管AI工具可以生成代码或提供建议，但这些建议并不总是完美的。开发者需要具备足够的知识来判断和调整这些建议，以确保代码的正确性和高效性。
方向二：AI对开发者的影响 🌐⚙️ 日常工作的改变 AI工具正在重塑开发者的日常工作，使得一些重复性和低级的任务可以自动化处理。这不仅提高了开发效率，还让开发者有更多的时间专注于更高层次的问题，如架构设计和创新。
加速开发过程 🚀 AI工具可以自动补全代码、生成文档和测试用例，从而大大加快了开发过程。开发者可以更快地完成项目，并有更多时间进行创意和创新。
提升代码质量 🏅 通过自动化的错误检测和代码审查，AI工具可以帮助开发者在早期阶段发现和修复问题，提升代码的质量和稳定性。
降低入门门槛 📉 对于新手开发者，AI工具可以充当智能导师，帮助他们快速掌握编码技巧和最佳实践。这使得学习编程变得更加容易，吸引了更多人进入开发领域。
开发者需要掌握的新技能 随着AI工具的普及，开发者需要掌握一些新技能，以在AI辅助的环境中保持竞争力：
熟悉AI工具的使用 🧠 开发者需要了解如何高效地使用各种AI工具，并掌握它们的功能和局限性。这不仅包括技术上的熟悉，还需要理解如何在实际项目中灵活应用这些工具。
数据分析和处理能力 📊 AI模型依赖大量的数据进行训练和优化。开发者需要具备一定的数据分析和处理能力，以便更好地理解和利用这些AI工具。
加强软技能和创造力 🎨 随着重复性任务被AI工具取代，开发者的软技能和创造力变得尤为重要。沟通能力、团队合作和创新思维将成为未来开发者的重要竞争力。
方向三：AI开发的未来 🌟🔮 创造性和复杂性 🧩 超越代码的复杂性 软件开发不仅仅是编写代码。它涉及复杂的系统设计、架构决策和创新解决方案。这些任务需要深厚的领域知识和创造性思维，而这些正是当前AI系统所欠缺的。AI可以在特定的任务上表现出色，例如代码补全或错误检测，但在面对需要创新和系统性思考的任务时，它们的表现仍然有限。
系统设计：设计一个复杂的软件系统需要全面理解业务需求、技术约束和用户体验。这些设计决策常常需要考虑许多相互冲突的因素，而这些因素超出了AI目前的能力范围。
架构决策：在选择适当的架构模式和技术栈时，开发者需要权衡许多因素，如可扩展性、性能和安全性。AI虽然可以提供有价值的建议，但最终的决策仍需要开发者的判断和经验。
创意的不可替代性 开发过程中常常需要解决独特的问题，提出新颖的解决方案。这种创造力是AI目前无法模拟的。AI擅长从已有数据中学习并生成相似的输出，但它并不能真正“创新”或“创造”新的东西。这意味着在需要突破和创新的地方，开发者的角色仍然不可替代。
人类的判断和决策 🧠 道德和伦理的考量 软件开发中的许多决策不仅仅是技术性的，还涉及到道德和伦理的考量。例如，如何处理用户数据隐私，如何在系统设计中防止歧视，如何确保算法的公平性和透明度。这些问题需要人类的判断和价值观，而这正是AI无法胜任的领域。
数据隐私：在处理敏感用户数据时，开发者必须做出如何存储和保护这些数据的决定。AI工具可以帮助识别潜在的安全风险，但最终的隐私策略必须由人类来制定和实施。
算法公平性：在开发涉及自动决策的系统时，确保算法的公平性是一个复杂的挑战。AI可以帮助分析和改进算法，但它无法替代开发者在理解和解决偏见方面的角色。
决策背后的复杂考量 AI可以提供有价值的建议和支持，但在复杂的决策过程中，人类的经验和判断仍然至关重要。开发者必须综合考虑技术、业务和用户需求等多个方面，做出最佳的决策。这种综合考虑和权衡是AI难以实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c92cd9b4279452b0c3f446b3641b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f374421ea8601910e19a0bcaa5d373/" rel="bookmark">
			C&#43;&#43; STL 多线程库用法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：Atomic：
二：Thread
1. 创建线程 2. 小心移动(std::move)线程 3. 如何创建带参数的线程
4. 线程参数是引用类型时，要小心谨慎。
5. 获取线程ID
6. jthread
7. 如何在线程中使用中断 stop_token
三：如何解决数据竞争
1.有问题的代码 2.使用互斥 3.预防死锁
4. 自动释放锁
5. 延迟锁
6. 共享锁
7. 线程安全的初始化
四：线程局部存储
五：线程通信
1.条件变量
2. 防止虚假唤醒
3. 防止唤醒丢失
4.信号量
5. std::latch
六：任务
1. std::promise, std::future
2. 用std::promise, std::future进行线程同步
3. std::async
4. std::package_task
一：Atomic： #include &lt;atomic&gt; #include &lt;thread&gt; #include &lt;iostream&gt; using namespace std; std::atomic_int x, y; int r1, r2; void writeX() { x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7f374421ea8601910e19a0bcaa5d373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2487285cab72c8f7146da006f1a0576b/" rel="bookmark">
			图神经网络实战（16）——经典图生成算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图神经网络实战（16）——经典图生成算法 0. 前言1. 图生成技术2. Erdős–Rényi模型3. 小世界模型小结系列链接 0. 前言 图生成算法是指用于创建模拟图或网络结构的算法，这些算法可以根据特定的规则和概率分布生成具有特定属性的图，用于模拟各种复杂系统，如社交网络、生物网络、交通网络等。传统图生成技术已有数十年历史，并可用作各种应用的基准，但这些技术在生成的图类型上存在限制。这些方法大多数都专注于输出特定的拓扑结构，因此不能简单地模仿给定网络。在本节中，我们将介绍两种经典图生成技术：Erdős–Rényi 模型和小世界 (small-world) 模型。
1. 图生成技术 图生成是生成新图的技术，并且希望所生成的图具有真实世界中图的性质。作为一个研究领域，它为了解图如何工作和演化提供了新思路。它还可以直接应用于数据增强、异常检测、药物发现等领域。我们可以将图生成分为两种类型：一种是模仿给定图生成具有类似性质的逼真图数据 (例如，数据增强)，另一种是目标导向图生成，即创建优化特定指标的图(例如，分子生成)。
2. Erdős–Rényi模型 Erdős–Rényi 模型是最简单、最流行的随机图 (random graph model) 模型，由匈牙利数学家 Paul Erdős 和 Alfréd Rényi 于 1959 年提出，该模型有两个变体： G ( n , p ) G(n, p) G(n,p) 和 G ( n , M ) G(n, M) G(n,M)。
在 G ( n , p ) G(n, p) G(n,p) 模型中：给定节点数量和节点连接的概率，尝试随机地将每个节点与其他节点连接起来，以创建最终的图。这意味着存在 C 2 n C_2^n C2n​ 种可能的连接。另一种理解概率 p p p 的方式是将其视为改变网络密度的参数。使用 networkx 库可以直接实现 G ( n , p ) G(n, p) G(n,p) 模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2487285cab72c8f7146da006f1a0576b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc30d04f246bcfe70a4d1db70b709b7/" rel="bookmark">
			【Linux进阶】文件系统6——理解文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.文件的读取
1.1.目录
1.2.文件
1.3.目录树读取
1.4.文件系统大小与磁盘读取性能
2.增添文件
2.1.数据的不一致（Inconsistent）状态
2.2.日志式文件系统（Journaling filesystem）
3.Linux文件系统的运行
4、文件的删除
4.1. 删除文件
4.2.为什么拷贝文件的时候很慢，而删除文件的时候很快？
4.3.、文件误删后的解决方案
5、大文件存储
1.文件的读取 我们知道在Linux系统下，每个文件（不管是一般文件还是目录文件）都会占用一个inode，且可依据文件内容的大小来分配多个区块给该文件使用。
目录的内容在记录文件名，一般文件才是实际记录数据内容的地方。
我们现在已经了解了Linux的文件系统，那么Linux是如何对文件进行读取的呢？
1.1.目录 当我们在Linux下的文件系统建立一个目录时，文件系统会分配一个inode与至少一块区块给该目录。
其中，inode记录该目录的相关权限与属性，并可记录分配到的那块区块号码，而区块则是记录在这个目录下的文件名与该文件名占用的inode号码数据，也就是说目录所使用的区块记录如下的信息：
如果想要实际观察root 根目录内的文件所占用的inode号码时，可以使用Is-i这个选项来处理：
由于每个人所使用的计算机并不相同，系统安装时选择的项目与磁盘分区都不一样，因此你的环境不可能与我的inode号码一模一样，上表的左边所列出的inode仅是我的系统所显示的结果而已。
而由这个目录的区块结果我们现在就能够知道，当你使用【|| /】时，出现的目录几乎都是1024的倍数，为什么？因为每个区块的数量都是1K、2K、4K，看一下我的环境:
由于我的根目录使用的区块大小为4K，因此每个目录几乎都是4K的倍数，其中由于/usr/sbin的内容比较复杂因此占用了3个区块。
至于奇怪的/proc我们在讲过该目录不占磁盘容量所以当然使用的区块就是0。
由上面的结果我们知道目录并不只会占用一个区块而已，也就是说：在目录下面的文件数如果太多而导致一个区块无法记录得下所有的文件名与inode对照表时，Linux会多给该目录一个区块来继续记录相关的数据。
1.2.文件 当我们在Linux下的ext2建立一个一般文件时，ex2会分配一个inode与相对于该文件大小的区块数量给该文件。
例如：假设我的一个区块为4KB，而我要建立一个100KB的文件，那么Linux将分配一个inode与25个区块来存储该文件。但同时请注意，由于inode仅有12个直接指向，因此还要需要一个区块来记录区块号码。
1.3.目录树读取 好了，经过上面的说明你也应该要很清楚地知道inode本身并不记录文件名，文件名的记录是在目录的区块当中。
那么因为文件名是记录在目录的区块当中，因此当我们要读取某个文件时，就务必会经过目录的inode与区块，然后才能够找到那个待读取文件的inode号码，最终才会读取到该文件的区块中的数据。
由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的inode号码，此时就能够得到根目录的inode内容，并依据该inode 读取根目录的区块内的文件名数据，再一层一层的往下读到正确的文件名。
举例来说，如果我想要读取/etc/passwd这个文件时，系统是如何读取的呢？
在我系统上面与/etc/passwd有关的目录与文件数据如上表所示，该文件的读取流程为（假
设读取者身份为dmtsai 这个一般身份用户）：
1. /的inode： 通过挂载点的信息找到inode号码为2的根目录inode，且 inode 规范的权限让我们可以读取
该区块的内容（有r与x）；
2./ 的区块： 经过上个步骤取得区块的号码，并找到该内容有etc/目录的inode 号码（1310721);
3. etc/ 的inode: 读取1310721号inode 得知zs_108具有r与x的权限，因此可以读取etc/的区块内容；
4. etc/的区块： 经过上个步骤取得区块号码，并找到该内容有passwd 文件的inode 号码（1311648);
5. passwd 的 inode: 读取1311648号inode 得知zs_108具有r的权限，因此可以读取passwd的区块内容；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fc30d04f246bcfe70a4d1db70b709b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d401cb785315d56dadefa3164c8d2d0/" rel="bookmark">
			自动控制：前馈控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动控制：前馈控制 前馈控制是一种在控制系统中通过预先计算和调整输入来应对已知扰动或变化的方法。相比于反馈控制，前馈控制能够更快速地响应系统的变化，因为它不依赖于系统输出的反馈信号。前馈控制的应用在工业过程中尤为广泛，尤其是在需要迅速响应和高精度控制的场合。
前馈控制的优势 系统响应速度更快：前馈控制能够提前补偿系统中预知的干扰，减少系统的响应延迟。更好地处理非线性系统：前馈控制可以预测非线性系统引起的干扰，并提前在输入控制量中进行补偿，提高控制系统的响应准确度和稳定性。对系统的模型不确定性更为鲁棒：前馈控制基于被控对象的模型，适用于模型存在误差、摩擦或其他非理想状态的情况。 根据不同的控制目标，前馈控制器主要有两种类型：抗扰前馈控制器和跟踪前馈控制器。
抗扰前馈控制器 定义和原理 抗扰前馈控制器（Disturbance Rejection Feedforward Controller）主要用于抑制系统中的扰动。这种控制器在检测到扰动后，通过计算并施加一个与扰动相反的控制输入，来抵消扰动对系统的影响。其工作原理如下：
扰动检测：实时检测系统中的扰动源。扰动补偿计算：根据系统模型计算出所需的补偿量。施加补偿控制：将计算得到的补偿量施加到系统中，抵消扰动影响。 应用场景 抗扰前馈控制器广泛应用于化工、热控等过程中。例如，在化工过程中，反应温度的变化会影响产品的质量，通过检测温度扰动并实时补偿，可以保持温度的稳定性。
优点 快速响应扰动：抗扰前馈控制器能够在扰动发生时立即检测并进行补偿，使系统能够迅速恢复到稳定状态。提高系统稳定性：通过提前补偿扰动，减少了系统的振荡和不稳定现象。提高控制精度：减少了扰动对系统输出的影响，提高了控制精度。 实例 考虑一个化工反应器的温度控制问题，假设外界温度变化会影响反应器的温度。通过安装温度传感器，实时检测外界温度的变化，并计算出相应的补偿热量，施加到反应器中，保持反应器温度的稳定。
跟踪前馈控制器 定义和原理 跟踪前馈控制器（Tracking Feedforward Controller）主要用于精确跟踪系统的参考输入。它通过预测参考输入的变化，并提前计算和施加相应的控制输入，使系统能够快速、准确地跟踪参考信号。其工作原理如下：
参考信号预测：根据系统模型预测参考信号的变化。控制输入计算：计算出使系统输出跟踪参考信号的控制输入。施加控制输入：将计算得到的控制输入施加到系统中，实现精确跟踪。 应用场景 跟踪前馈控制器广泛应用于机器人控制、自动驾驶等领域。例如，在自动驾驶中，需要车辆能够精确跟踪预定的行驶路线，通过预测车辆位置和路径，提前计算转向角度和速度，可以实现高精度的路径跟踪。
优点 提高跟踪精度：跟踪前馈控制器能够使系统输出快速、准确地跟踪参考信号，提高跟踪精度。减少跟踪误差：通过提前补偿系统的动态变化，减少了跟踪误差。提高系统响应速度：能够快速响应参考信号的变化，提高系统的动态性能。 实例 考虑一个机器人臂的运动控制问题，假设机器人臂需要按照预定的轨迹运动。通过提前计算轨迹上的位置、速度和加速度，并相应调整关节的驱动力矩，可以使机器人臂精确地跟踪预定轨迹。
Python代码示例 下面我们通过一个简单的Python代码示例，演示前馈控制的基本原理。假设我们有一个简单的温度控制系统，目标是通过前馈控制来补偿外界温度的扰动，保持系统温度的稳定。
import numpy as np import matplotlib.pyplot as plt # 定义系统参数 dt = 0.1 # 时间步长 t = np.arange(0, 10, dt) # 时间数组 n = len(t) # 初始化状态变量 temperature = np.zeros(n) # 系统温度 desired_temperature = np.ones(n) * 0 # 期望温度 external_disturbance = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d401cb785315d56dadefa3164c8d2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9497912ee2c8f64da47a8f507fb6cb0/" rel="bookmark">
			【problem】解决“Cannot deserialize instance of `java.util.ArrayList` out of START_OBJECT token”错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
在开发Java应用时，尤其是在处理JSON数据反序列化过程中，您可能会遇到一个常见的错误提示：“Cannot deserialize instance of java.util.ArrayList out of START_OBJECT token”。本文将深入探讨这一错误的原因，并提供一系列解决方案帮助您顺利解决问题。
错误背景 此错误通常发生在使用诸如Jackson、Gson等流行的JSON处理库尝试将JSON字符串转换为Java对象集合（如ArrayList）时。当您的代码预期一个JSON数组，但实际上遇到了一个JSON对象的开始标记（{），该错误就会触发。
错误实例 假设您的Java代码准备接收一个类似下面的JSON数组：
[ {"name": "Alice"}, {"name": "Bob"} ] 但实际上，服务器响应或文件内容提供了一个JSON对象：
{"user": {"name": "Alice"}} 此时，如果您尝试将此响应直接反序列化为一个ArrayList&lt;User&gt;，就会引发上述错误。
解决方案 1. 检查并理解JSON结构 首要步骤是核实JSON数据的实际结构。确保您的数据源确实提供了预期的JSON数组格式。 2. 调整模型类 如果JSON数据结构本身就是一个对象包含数组的情况，如：
{"users": [{"name": "Alice"}, {"name": "Bob"}]} 那么，您应该在Java中定义相应的容器类来匹配这一结构：
public class UsersContainer { private List&lt;User&gt; users; // Getters and Setters } 3. 使用正确的反序列化方法 在使用如Jackson的库时，明确指定反序列化的类型是关键。例如，使用TypeReference来指定期望的集合类型：
ObjectMapper mapper = new ObjectMapper(); List&lt;User&gt; userList = mapper.readValue(jsonString, new TypeReference&lt;List&lt;User&gt;&gt;(){}); 或者，如果是嵌套结构：
UsersContainer container = mapper.readValue(jsonString, UsersContainer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9497912ee2c8f64da47a8f507fb6cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dadad881fefe8540d449c6e011b18b0/" rel="bookmark">
			Day05-04-持续集成总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Day05-04-持续集成总结 1. 持续集成2. 代码上线目标项目 1. 持续集成 git 基本使用, 拉取代码,上传代码,分支操作,tag标签
gitlab 用户 用户组 项目 , 备份,https,优化.
jenkins 工具平台,运维核心, 自由风格工程,maven风格项目,流水线项目, 流水线(pipeline)
mavenpom.xmltargetmvn clean package sonarqube 质检 owasp 安全检查 (OWASP Dependency-Check)
pipeline流水线
钉钉发送消息.
核心: 代码上线流程
Devops/ci/cd
未来:
jeesns
基于docker项目…
2. 代码上线目标项目 java或go语言为主.
java: https://gitee.com/jishenghua/JSH_ERPgo: https://gitee.com/mlogclub/bbs-go java前后端分离
job01：前端 拉取代码编译(yarn)分发与部署(docker) job02：后端 拉取代码编译(mvn) jar分发与部署(docker) 编译(mvn) jar 分发与部署(docker) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8af9b848da39fc9d9eb5066fb66c4f3/" rel="bookmark">
			word 使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		word 文档中如何将下行的指定文字退格到上行中 就像是这样的
编号：111
密码：222
编号：123
密码：321
编号：124
密码：331
变成
编号：111密码：222
编号：123密码：321
编号：124密码：331
替换 ^p密 为 密。
勾上使用通配符。
怎样在 word 的一些行的后面自动加上小括号？ 就像下面的题中，想在每小题的选项后面加上小括号，有什么好的快捷的办法吗？象这样的题目还很多，手动加括号的话太麻烦，可以用word自带功能完成吗？最好不用 vba，
请高手帮帮忙！谢谢！
1、你的性别是
男 （ ）
女 （ ）
2、你就读的年级为
一年级（ ）
二年级（ ）
三年级（ ）
四年级（ ）
五年级（ ）
六年级（ ）
3、你认为自己的成绩在班级里属于
优等生（ ）
中等偏上（ ）
中等生（ ）
中等偏下（ ）
学困生（ ）
刚才学习到“星星草”老师好的方法，把她贴在这里，与大家分享：
第一次替换： 查找：^P
替换：（ ）^P
第二次替换：查找框：([0-9]{1,}、*)（*）
替换框：\1
除了第二对小括号是全角，其它都是半角。查找框中还可以加上^13，替换框中还可以加上^P。不加也行，不影响。
利用 Word 的正则表达式替换特殊字符技巧 手头有几个 Word 文件，每个文件都有几百页，文件中诸多地方汉字与汉字之间有空格，又不能批量替换把空格去掉，因为文件中还有许多英文信息，英方单词之间的空格是需要的，所以就是要仅替换汉字中间的空格，如果一个一个地查找再人工决定是否替换，几百页的内容会累死人的，所以就想到了正则表达式，可是word的正则表达式并不是很完整，经过测试用下面的表达式实现了我需要的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8af9b848da39fc9d9eb5066fb66c4f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3258f1c229eab44eddc805cb07689a67/" rel="bookmark">
			在pycharm中使用jupyter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pycharm中使用jupyter 前置条件：你的环境中应该有juptyer ，没有的话 pip install jupyter
点击项目目录，右键-&gt;new-&gt;jupyter notebook
打开file settings 找到 jupyter server （按照默认的用代理服务器就行）
Pycharm有着丝般顺滑的代码补全功能，能大大提升效率，作为IDE的各种高级功能（比如变量预览，代码调试）也非常棒！你的notebook文件还能很方便地和.py文件联动开发，体验远超Jupyter Notebook加插件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca26cebbe536e2eb08c16dc1553333a/" rel="bookmark">
			高效开发：使用Spring Boot快速构建企业级应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔍 高效开发：使用Spring Boot快速构建企业级应用 🔍 高效开发：使用Spring Boot快速构建企业级应用摘要引言正文内容什么是Spring Boot？ 🧩Spring Boot的核心特性 如何使用Spring Boot构建企业级应用 🚀创建Spring Boot项目配置数据库构建RESTful API 性能优化与最佳实践 ⚙️使用缓存提升性能使用异步处理提升响应速度 🤔 QA环节 小结表格总结未来展望 🔮 参考资料 ) 博主 默语带您 Go to New World.
✍ 个人主页—— 默语 的博客👦🏻
《java 面试题大全》 《java 专栏》 🍩惟余辈才疏学浅，临摹之作或有不妥之处，还请读者海涵指正。☕🍭
《MYSQL从入门到精通》数据库是开发者必会基础之一~
🪁 吾期望此文有资助于尔，即使粗浅难及深广，亦备添少许微薄之助。苟未尽善尽美，敬请批评指正，以资改进。！💻⌨
🔍 高效开发：使用Spring Boot快速构建企业级应用 摘要 大家好，我是默语，擅长全栈开发、运维和人工智能技术。在本篇博客中，我将分享如何使用Spring Boot快速构建企业级应用。Spring Boot简化了Spring应用的开发和部署，提供了一套开箱即用的框架，帮助开发者更高效地构建高性能、高可用的企业级应用。关键词：Spring Boot、企业级应用、快速开发、Spring框架。
引言 在现代软件开发中，快速高效地构建稳定、可维护的企业级应用是每个开发者的目标。Spring Boot作为Spring生态系统的一部分，通过简化配置和提供自动化工具，使得构建复杂应用变得更加容易。本文将详细介绍Spring Boot的核心功能及其在企业级应用中的应用，并通过示例代码展示其强大之处。
正文内容 什么是Spring Boot？ 🧩 Spring Boot是Spring生态系统中的一个子项目，旨在简化Spring应用的开发和部署。它提供了一种快速搭建Spring应用的方法，通过约定优于配置的理念，减少了繁琐的配置工作。
Spring Boot的核心特性 自动配置：根据项目依赖自动配置Spring应用。内嵌服务器：无需外部服务器，支持Tomcat、Jetty等。生产就绪：提供健康检查、外部化配置等生产环境支持。Spring Initializr：提供在线项目生成器，快速创建Spring Boot项目。 如何使用Spring Boot构建企业级应用 🚀 创建Spring Boot项目 使用Spring Initializr可以快速生成Spring Boot项目，选择所需的依赖，下载项目即可开始开发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ca26cebbe536e2eb08c16dc1553333a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b21cdb401332efc33fb0bc03bcb3017/" rel="bookmark">
			文心一言最常用的20条指令及指令说明，含增强指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是20条文心一言的指令及其说明，每条指令尽量简洁明了，以便在有限的字数内提供尽可能多的信息。以下是这些指令及其说明：
1. 查询天气 指令：今天北京的天气怎么样？说明：此指令用于查询特定城市（如北京）的当前天气情况。 2. 设置提醒 指令：请在明天下午3点提醒我开会。说明：用于设置未来某个时间点的提醒事项（如开会）。 3. 文本创作 指令：帮我写一篇关于人工智能的科普文章。说明：要求文心一言生成一篇关于特定主题（如人工智能）的科普文章。 4. 知识问答 指令：文心一言，请问什么是深度学习？说明：通过提问方式获取特定概念或知识的解释。 5. 生成诗歌 指令：请为我写一首关于春天的诗歌。说明：要求文心一言创作一首以特定主题（如春天）为内容的诗歌。 6. 数学计算 指令：计算3加5等于多少？说明：执行基本的数学运算，返回计算结果。 7. 逻辑推理 指令：如果苹果比橙子重，橙子比香蕉重，那么这三种水果按重量如何排序？说明：根据给定的逻辑关系进行推理，并返回排序结果。 8. 情感分析 指令：分析这句话“我今天非常开心”表达的情感。说明：识别并分析文本所表达的情感倾向（如积极、消极）。 9. 调整语气语调 指令：文章的语气和语调可能需要调整，以更好地适应目标读者和传达所需的情感。说明：根据目标读者和情感需求，调整文本的语气和语调。 10. 提供解决方案 指令：如果文章提出了问题或挑战，请考虑在文章中提供解决方案或建议。说明：针对提出的问题或挑战，生成相应的解决方案或建议。 11. 增加论据支持 指令：文章需要更多的论据和支持来加强观点的可信度。说明：为文本中的观点增加相关的事实、数据或引用来增强说服力。 12. 改善段落开头 指令：段落的开头句子需要更具吸引力和引导性。说明：修改段落开头，使其更具吸引力，引导读者继续阅读。 13. 优化段落结构 指令：一些段落略平，缺少逻辑上的联系，请帮助强化段落结构。说明：调整段落结构，增强段落之间的逻辑联系，使整体更加连贯。 14. 替换过时词汇 指令：避免使用不常见或过时词汇，请替换为更现代的用法或词汇。说明：更新文本中的过时词汇，保持语言的新鲜度和准确性。 15. 修正拼写语法 指令：修正拼写错误和语法错误，提供改进建议。说明：检查并纠正文本中的拼写和语法错误，提高文本质量。 16. 简明扼要总结 指令：文章的总结部分过于冗长，请提供建议以简洁扼要地总结文章。说明：将长篇大论的总结简化为简洁明了的内容，便于读者快速理解。 17. 创造主动描写 指令：文章中的描写有改进空间，请提供改进建议以创造更主动、形象的描写。说明：通过增加具体的细节和生动的语言，使描写更加主动和形象。 18. 优化段落长度 指令：某些段落长度过长或过短，请提供建议以优化段落长度。说明：调整段落长度，使其更加平衡和易读，提高整体阅读体验。 19. 确保风格一致 指令：文章中风格和用词不够一致，请提供建议以确保风格统一。说明：保持文本在风格和用词上的一致性，提升整体的专业性和可读性。 20. 自定义指令 指令：无固定格式，根据用户需求自定义（如“以唐代诗人的身份，撰写一篇关于秋景的七言绝句”）。说明：用户可以根据自己的具体需求，构造复杂或特定的指令，文心一言将尽力理解和执行。 这些指令覆盖了文心一言在信息查询、文本创作、逻辑推理、情感分析等多个方面的功能，体现了其自然语言处理能力的广泛性和实用性。
如果想增强指令的引导性，请参考下方指令：
请详细描述一下今天北京的天气状况，包括温度、湿度以及是否有特殊天气现象。
我想设置一个提醒，内容是“下午3点开始会议”，时间是明天，请帮我设置一下。
能否帮我撰写一篇关于人工智能的科普文章，要求内容通俗易懂，适合非专业人士阅读。
请解释一下深度学习的概念，包括它的工作原理以及在实际应用中的一些例子。
我想让你创作一首诗歌，主题是春天，请尽量使用生动的描绘和形象的比喻。
请帮我计算一下3加5的结果，并解释一下这个简单的加法运算在数学中的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b21cdb401332efc33fb0bc03bcb3017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f837d9fd567f5e0b50e31b08fbf1dfb7/" rel="bookmark">
			VSCode, 请在windows下使用git bash终端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用vscode在windows下调测代码，运行时默认打开的终端是windows的cmd，很不受我待见。毕竟习惯了linux，习惯了windows下的git bash风格。怎么办？
search，search，research。
先确保windows上安装了git bash。
再在vscode中搜索git bash扩展安装上。
最后，设置 git bash为默认shell。
1 2 3 4 5 6 7 8 9 10 "terminal.integrated.profiles.windows": { "PowerShell": { "source": "PowerShell", "icon": "terminal-powershell" }, "Git-Bash": { "path": "C:\\Program Files\\Git\\bin\\bash.exe" }, }, "terminal.integrated.defaultProfile.windows": "Git-Bash", 更详细信息请参考下面文档
Windows 环境下在 VSCode 中使用 Git Bash 终端 | stevending1st
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/185/">«</a>
	<span class="pagination__item pagination__item--current">186/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/187/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>