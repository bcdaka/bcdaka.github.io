<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7229746d08bb57292d22946c33793a48/" rel="bookmark">
			【数据结构 | 哈希表】一文了解哈希表(散列表)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁博客主页😁：🚀https://blog.csdn.net/wkd_007🚀
🤑博客内容🤑：🍭嵌入式开发、Linux、C语言、C++、数据结构、音视频🍭
🤣本文内容🤣：🍭介绍哈希表 🍭
😎金句分享😎：🍭你不能选择最好的，但最好的会来选择你——泰戈尔🍭
⏰发布时间⏰： 2024-07-24 14:48:55
本文未经允许，不得转发！！！
目录 🎄一、概述🎄二、键值对(key-value pair)🎄三、哈希函数🎄四、哈希冲突(哈希碰撞)✨4.1 开发地址法✨4.2 链地址法 🎄五、哈希表的使用🎄六、总结 🎄一、概述 在学习过的简单数据结构当中，
数组的特点：访问(寻址)速度较快的、但插入、删除操作较慢；
链表的特点：访问(寻址)速度较慢的、但插入、删除操作很快；
所以，有些大牛就想着能不能结合这数组、链表的优点，造出一个 访问(寻址)速度较快的、插入、删除操作也很快 的数据结构，后面就造出来一个 哈希表。
哈希表（Hash Table）：也叫做散列表。是根据关键码值（Key Value）直接进行访问的数据结构。
哈希表存储的都是键值对（Key-Value），即一个关键字对应一个内容，给出关键字就可以在哈希表中找到对应内容。
哈希表的工作过程：哈希表通过键值对的 关键字(key) 和 哈希函数 计算出对应的一个位置，通常是数组下标，然后把整个 键值对(代码中叫Entry)存放到这个位置，以加快查找的速度。如果多个 关键字(key) 得到同一位置就会产生 哈希冲突，需要通过一个方法去解决。
这里面有好几个概念，会在后面的内容去介绍。
🎄二、键值对(key-value pair) 键值对(key-value pair)：就是一个关键字(key)对应一个值(value)的组合，要求每个键值对的 关键字(key) 不能重复。下面表格就是一些键值对。
KeyValuexia虾za匝zai栽zan赞zang脏 在代码里可以使用下面结构体去表现一个键值对：
struct table_entry{ const char* key; void *value; } 哈希表是存储 键值对 的，那它是怎样存储的呢？
哈希表要求每个键值对的 关键字(key) 不能重复，然后通过键值对的 关键字(key) 来定位每个键值对存放的位置，这个位置就是 哈希地址，而将 关键字(key) 映射成 哈希地址 的函数就是 哈希函数。
在哈希表中，会把 键值对(key-value) 的key称为键值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7229746d08bb57292d22946c33793a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807ff88dc3af876df9e550a38c77097e/" rel="bookmark">
			kotlin基础知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 想象一下，你走进一家餐馆，菜单上有你熟悉的老派Java汉堡，还有新推出的Kotlin牛排。Kotlin不仅看起来更美味，还附带了免费的甜点——更简洁的语法和更少的错误。学习Kotlin的必要性，就像是选择更健康、更美味的餐点一样，让你在编程的世界里更加游刃有余。而且，你不需要担心适应问题，因为Kotlin和Java一样，都是熟悉的味道。为什么不来一份Kotlin大餐，让你的编程生活更滋味呢？
学习Kotlin，是每一位追求技术进步的开发者不可忽视的一步。Kotlin以其简洁优雅的语法和强大的功能，正在迅速成为现代编程语言的翘楚。作为一种与Java完全兼容的语言，Kotlin不仅能够提高开发效率，还能大幅减少代码中的错误，提升代码的可读性和可维护性。这些特性使得Kotlin不仅适用于新项目的开发，更是优化和升级现有Java项目的理想选择。
在当今竞争激烈的技术领域，掌握Kotlin无疑会让你在职业发展中占据一席之地。Kotlin已经成为Android开发的首选语言，同时也在后端开发、数据分析和多平台开发中展现出强大的生命力。通过学习Kotlin，你不仅能紧跟技术发展的潮流，还能为自己打开更多职业发展的机会之门。
现在，正是你抓住机遇、迎接挑战的时刻。每一次新的学习，都是一次自我提升的机会。让我们一起投入到Kotlin的世界中，探索更多的可能性，拓宽我们的技术视野。相信在不久的将来，你会因为今天的选择而感到自豪。加油，未来因你而更加精彩！
话不多说，直接进入学习。 数组的创建及使用数组的建立： val a = intArrayof(1,2,3,4).或 val a = IntArray(5){it+1}.（第二种相当于是new了一个对象创建数组）
建立的数组是不可以修改的。
想要访问数组的内容可以通过遍历的方式、直接索引、或者把整体访问。
遍历 val a = intArratyof(1,2,3,4,5)
a.forEach{element-&gt;
println(element)
}
或
for(element in a){
println(element)
}
直接索引 val a = intArratyof(1,2,3,4,5)
a[0] 取出来的结果是1
3.整体访问
val a = intArratyof(1,2,3,4,5)
println(a.contentToString)
Kotlin数据类型和字符比较 在申明变量的时候，可以用val和var
val是申明一个不能被改变的变量，像java中给加上final
var是申明一个变量。
例如： var a=2
也可以补变量类型。var:int = 2 var:String = “hello world ”
申明Long类型的变量的时候，必须用大写的L，避免歧义。
var a =123456L
对于无符号类型，只用在类型的前面加上U，val a:Uint = 10u
字符串比较：
字符串的比较可以用 = = 和= = =。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/807ff88dc3af876df9e550a38c77097e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42907f7fc305b6f30948449b725491b7/" rel="bookmark">
			配置sublime的中的C&#43;&#43;编译器(.sublime-build)，实现C&#43;&#43;20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GCC 4.8: 支持 C++11 (部分)
GCC 4.9: 支持 C++11 和 C++14 (部分)
GCC 5: 完全支持 C++14
GCC 6: 支持 C++14 和 C++17 (部分)
GCC 7: 支持 C++17 (大部分)
GCC 8: 完全支持 C++17，部分支持 C++20
GCC 9: 支持更多的 C++20 特性
GCC 10: 支持大部分 C++20 特性
GCC 11: 更全面地支持 C++20
GCC 12: 支持几乎所有的 C++20 特性
GCC 13 及以后: 增加对 C++20 的完全支持并开始对 C++23 进行支持
如果您发现您并未配置好您的C++，或者说您觉得当前的版本不能支撑日常的学习，那么您需要下载一个
https://github.com/niXman/mingw-builds-binaries/releases
下载之后，解压到一个你知道的文件夹中，打开解压的文件路径，发现有一个bin文件打开他之后，复制上方的文件路径测试一下 g++ 的版本。
环境的配置 工具(tools)— &gt; 编译系统 -----&gt; 新建编译系统… ，将会生成一个*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42907f7fc305b6f30948449b725491b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdef8a99d1aa437ef3c7b9050940df88/" rel="bookmark">
			6.6 使用dashboard商城搜索导入模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本节重点介绍 : 模板商城中搜索模板导入模板修改模板 大盘模板商城地址 免费的 地址 https://grafana.com/grafana/dashboards 搜索模板技巧 详情 导入dashboard 两种导入模式 url导入id导入json文件导入 导入 node_exporter模板 https://grafana.com/grafana/dashboards/8919 导出模板 本节重点总结 : 模板商城中搜索模板导入模板修改模板 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce49bf736a3e3c3943f46ced6ad1039/" rel="bookmark">
			Java基础-JDBC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(创作不易，感谢有你，你的支持，就是我前行的最大动力，如果看完对你有帮助，请留下您的足迹）
目录
一、JDBC简介
1.1 什么是JDBC
1.2 JDBC的作用
1.3 JDBC的架构
二、JDBC核心接口与类
2.1 DriverManager
2.2 Connection
2.3 Statement
2.4 PreparedStatement
2.5 ResultSet
三、JDBC操作数据库的基本步骤
四、代码示例
五、深入JDBC的高级特性与性能优化 5.1 批处理（Batch Processing）
5.2 事务管理
5.3 类型安全的查询
5.4 性能优化
5.5 安全性
5.6 监控与日志
一、JDBC简介 1.1 什么是JDBC JDBC是Java数据库连接（Java Database Connectivity）的缩写，它为Java应用程序提供了一种标准的方法来访问数据库。通过JDBC，Java程序可以发送SQL语句到数据库，并处理来自数据库的响应。JDBC API是Java SE的一部分，它定义了一组用于与数据库交互的类和接口。
1.2 JDBC的作用 连接数据库：JDBC提供了与数据库建立连接的能力。执行SQL语句：通过JDBC，Java程序可以执行SQL语句来查询、更新、插入或删除数据库中的数据。处理结果集：JDBC允许Java程序处理数据库查询返回的结果集。 1.3 JDBC的架构 JDBC架构主要由两层组成：JDBC API和JDBC驱动管理器（DriverManager）。
JDBC API：提供了一组用于与数据库交互的接口和类。这些接口和类由Java平台定义，与具体的数据库无关。JDBC驱动管理器（DriverManager）：负责管理JDBC驱动程序的加载和注册，以及建立与数据库的连接。 二、JDBC核心接口与类 2.1 DriverManager DriverManager类管理一组JDBC驱动程序的基本服务。它不直接与数据库交互，而是用于建立与数据库的连接。主要方法包括：
getConnection(String url, String user, String password)：尝试建立到给定数据库URL的连接，使用指定的用户名和密码。 2.2 Connection Connection接口代表与特定数据库的连接。通过Connection对象，可以执行SQL语句、管理事务等。主要方法包括：
createStatement()：创建一个Statement对象，用于执行静态SQL语句并返回它所生成结果的对象。prepareStatement(String sql)：创建一个PreparedStatement对象，用于执行带参数的SQL语句。setAutoCommit(boolean autoCommit)：设置此连接是否自动提交事务。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ce49bf736a3e3c3943f46ced6ad1039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dabca060e885729a71059ce899c55be5/" rel="bookmark">
			【MySQL】：表操作语法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表内容的操作 增删改查
CRUD (create、retrieve、update、delete) 新增 基本语法 语法为： insert into 表名 values (值，值，值...); 这里的列数和类型，要和表结构匹配插入中文的话，要确保数据库创建的时候要设置字符集为 utf8 (charset) 隐式类型转换 上述这样就是“隐式类型转换” 类型系统
比较支持隐式类型转换，称为“弱类型系统”（Java）不太支持隐式类型转换，称为“强类型系统”（C 语言、mysql） 动静态类型
动态类型：程序运行中，变量类型可以改变
优势：非常灵活，表达能力更强
缺点：程序运行前，难以做丰富的检查静态类型：程序运行中，变量类型不能改变
优缺点：与动态相反 指定插入 1.指定列插入 语法为： insert into 表名(列名1，列名2...) value(值1，值2...); 2.多行插入 一次插入多行——&gt;高效，快速，低成本语法为： insert into 表名 value(),(),(); 3.时间插入 手动插入时间 自动插入时间：now()
查询 一、全列查询 语法为： select * from 表名; * 称为通配符（“赖子”），可以指代所有的类数据多的时候慎重使用 select *!!!
二、指定列查询 语法为： select 列名1，列名2... from 表名; 三、指定表达式 时列之间进行加减乘除运算因为数据库查询的是“临时表”，所以本体上的数据并没有变化
四、带别名的查询 给表达式取名字语法为： select 表达式 as 别名 from 表名; //as 可以省略 这也是只针对临时表进行修改，不会影响到表的本体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dabca060e885729a71059ce899c55be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0aa4ad5563320e693ced0e85d987c71/" rel="bookmark">
			SpringBoot集成Tomcat、DispatcherServlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过 SpringBoot 自动配置机制，导入配置类 利用 SpringBoot 自动配置机制，SpringBoot 会导入一个类型为 ServletWebServerFactoryAutoConfiguration 的配置类
ServletWebServerFactoryAutoConfiguration ServletWebServerFactoryAutoConfigurations 类上存在 @Import 注解，@Import 注解有以下几个特性：
继承 ImportSelector 接口：会在解析阶段执行 selectImports 方法，方法返回的类名数组，会被解析成 BeanDefinition 对象，即后期会被实例化成Bean继承 ImportBeanDefinitionRegistrar 接口：会在解析阶段执行 registerBeanDefinitions 方法，一般会注册 BeanDefinition 对象配置类 ServletWebServerFactoryAutoConfiguration 类属于第三种情况，我们继续分析
ServletWebServerFactoryConfiguration spring-boot-starter-web 默认包含依赖 spring-boot-starter-tomcat，因此 Spring 中存在类型为 EmbeddedTomcat 的配置类，EmbeddedJetty、EmbeddedUndertow 因为不满足 @ConditionalOnClass 注解的条件，所以默认情况下 web 容器是 Tomcat
如何修改默认 Web 容器 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.13&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;version&gt;2.6.13&lt;/version&gt; &lt;/dependency&gt; 此时项目是以 Jetty 为 Web 容器
SpringBoot集成Tomcat AbstractApplicationContext#refresh AbstractApplicationContext 的 refresh 方法是一个空壳方法，我们主要看它的实现类 ServletWebServerApplicationContext
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0aa4ad5563320e693ced0e85d987c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2cac9b6fed498c60edaae5be15906c9/" rel="bookmark">
			Air780EP模块 LuatOS开发-MQTT接入阿里云应用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文简单讲述了利用LuatOS-Air进行二次开发，采用一型一密、一机一密两种方式认证方式连接阿里云。整体结构如图 关联文档和使用工具：LuatOS库阿里云平台 准备工作 Air780EP_全IO开发板一套，包括天线SIM卡，USB线 PC电脑，串口工具
准备设备证书及产品证书
注意：下方证书信息仅为本教程使用，用户需要使用自己的证书信息
--设备证书 { "ProductKey": "k1hipglLdjU", "DeviceName": "868488076506128", "DeviceSecret": "fef32adf6dad46c2c7cbf335d3a7b021" } --产品证书 { "ProductSecret": "8LQwOYSZMwp3DFBd", "ProductKey": "k1hipglLdjU" } --公共实例ID { "InstanceId"："iot-06z00ipoepm2g97" } 阿里云介绍 物联网平台提供安全可靠的设备连接通信能力，支持设备数据采集上云，规则引擎流转数据和云端数据下发设备端。此外，也提供方便快捷的设备管理能力，支持物模型定义，数据结构化存储，和远程调试、监控、运维。阿里云物联网平台为设备提供安全可靠的连接通信能力，向下连接海量设备，支撑设备数据采集上云；向上提供云端API，服务端通过调用云端API将指令下发至设备端，实现远程控制。物联网平台消息通信流程图如下。 API说明 API接口功能描述aLiYun.setup()配置阿里云物联网套件的产品信息和设备信息aLiYun.setRegion()设置地域region idaLiYun.setConnectMode()设置连接方式aLiYun.subscribe()订阅主题aLiYun.publish()发布一条消息 详细的API介绍请参见aLiYun章节
实现流程 注册接入服务器结果回调函数
在收到true时表示连接成功，本demo中去发布一条QOS为1的消息给阿里云。
设置地域
配置为在阿里云创建项目时所用地区。每个地域完全独立。每个可用区完全隔离，但同一个地域内的可用区之间使用低时延链路相连。地域和可用区之间的关系如下图所示。
阿里云操作 产品操作 打开阿里云平台找到物联网平台，开通业务后进入控制台。
点开设备管理的产品页面，点击新建产品。根据需求和图示说明创建产品。
具体详细介绍见阿里云页面
设备操作 创建产品完成后就可以进入设备页面添加设备，在对应产品页面进入设备管理，按照提示添加设备
（在做正式产品时建议使用imei为devicename，方便后期维护）
阿里云设备创建
连接阿里云 LuatOS-Air方式连接概述 LuatOS-Air连接相比AT更为简单，只需要简单的配置即可连接，还可以灵活的对数据进行处理。需要从官网或者github下载aliyun的脚本包，或者使用luatoolsv2会自动下载脚本资源，在工具根目录的\Luatools\resource\soc_script\v2024.06.25.16\demo\aliyun中脚本资源会随官网同步更新，具体版本可能和本文不同，不过功能都是一致的。 文档中用到的API接口见aLiYun API章节。
一机一密LuatOS-Air方式连接 一机一密需要提前按照文档中阿里云操作章节事先建好产品并添加设备。
然后找到所使用的脚本版本进入demo目录找到aliyun文件夹打开main.lua，根据下方图示打开这三行的require（如果有被注释掉，将注释去掉），并将其他不相关的注释掉。
接着打开testYjym.lua，根据后面的操作修改三元组信息（DeviceName、ProductKey、DeviceSecret）和InstanceId信息。
首先将testYjym.lua中的三元组信息（DeviceName、ProductKey、DeviceSecret）修改为自己项目中的三元组信息。通过下方图示可找到自己项目中的三元组信息。
然后在实例详情页面，找到实例id并将其填写到代码中对应位置。
最后将代码保存，通过Luatools软件将固件+脚本烧录进设备后，便能连接上阿里云了。这是烧录教程。
一型一密LuatOS-Air方式连接（公共实例） 除了需要添加产品和设备外还需要在阿里云平台中打开对应产品的动态注册开关
先找到所使用的脚本版本进入demo目录找到aliyun文件夹打开main.lua，根据下方图示打开这两行的require（如果有被注释掉，将注释去掉），并将其他不相关的注释掉。
接着打开testYxym.lua，根据后面的操作修改DeviceName、ProductKey、ProductSecret和InstanceId信息。
其中DeviceName、ProductKey和InstanceId信息的位置在一机一密LuatOS-Air方式连接中已指出。下图为ProductSecret信息的位置。
接着将DeviceName、ProductKey、ProductSecret和InstanceId信息填写到testYxym.lua中对应位置。
最后将代码保存，通过Luatools软件将固件+脚本烧录进设备后，便能连接上阿里云了。这是烧录教程。
注意：第一次使用一型一密时，设备要处于未激活状态。
发布与订阅消息 发布消息 发布消息使用的是**aliyun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2cac9b6fed498c60edaae5be15906c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d491f8a14855c7cecd31ee8b586c15ad/" rel="bookmark">
			Codes 重新定义 SaaS 模式的研发项目管理平台开源版 4.5.6 发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：简介 Codes 重新定义 SaaS 模式 = 云端认证 + 程序及数据本地安装 + 不限功能 + 30 人免费 Codes 是一个 高效、简洁、轻量的一站式研发项目管理平台。包含需求管理，任务管理，测试管理，缺陷管理，自动化测试，cicd 等功能； Codes 帮助企业加速融合研发、测试、运维一体化进程。商业版不限功能，本地安装只限用户数，30 个用户免费 ; 社区版当前只开放了测试跟踪管理 (主要功能用例管理，缺陷管理)，后续接着分离其他功能代码出来。
官网 https://icodes.work/
gitee 代码仓库 Codes 研发项目管理软件: Codes 重新定义 SaaS 模式的一站式研发项目管理平台： 云端认证 + 程序及数据本地安装 + 不限功能 + 30 人免费；免费使用 、本地安装、研发管理、测试管理、数字大屏、CI CD、接口测试、缺陷管理、DevTestOps
本次发布 4.5.6 一共 11个更新 ，8 个优化更新，3 个 Bug fixed 详见 第三部分 二：图文简说 Codes Codes 的产品理念：让老板感知数据，让中层管理者感受先进，让基层员工感到舒心
理念在产品中的落地就是：以便捷的方式给管理人员抓手，使管理抓得住，抓得好；以不增加负担的方式让执行人员专注本职工作和高效协同。
好的工具，即要易用，又要方便管理：易用解决执行层面的协同问题，方便管理才能促进高效的执行，也就是说：协同仅是解决执行层面的问题，管理才是高效协同的抓手 功能架构
二、一 让老板感知数据 先来看 Codes 管理的抓手” 抓 “什么
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d491f8a14855c7cecd31ee8b586c15ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec6fde9ccdc84a81ddaf63f54e41bbb/" rel="bookmark">
			Meta 刚刚发布 Llama 3.1 ：在 AI 战斗中向 OpenAI 发起了大规模挑战｜TodayAI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		社交巨头 Facebook 母公司 Meta 公司近日发布了其 Llama 系列人工智能模型的最新版本 Llama 3.1，包括迄今为止最大的版本，容量达到 820GB。这一新版本标志着 Meta 在 AI 领域向 OpenAI 发起了大规模挑战，并宣称其用户数量将超过 ChatGPT。
Meta 表示，Llama 3.1 是对整个系列的全面升级，涵盖了小型和中型版本的推理能力提升。更重要的是，这些模型仍然保持开源，任何公司或组织都可以下载、微调并在自己的硬件上运行这些模型。
公司声称，Llama 3.1 405b 是系列中最大的版本，能够与 OpenAI 和 Google 的模型匹敌，包括在推理和编码能力方面。Meta 强调，这一版本可以在 Groq Cloud 推理平台、Meta 自己的 MetaAI 聊天机器人以及 AWS、IBM 和 Azure 等开发者云平台上使用。
Llama 3.1 405b 具备 4050 亿参数，是 Meta 和开源 AI 社区的重大进展。公司声称该版本在多个关键基准测试中击败了 Claude 3.5 Sonnet 和 GPT-4o。虽然 Meta 将在自己的 MetaAI 聊天机器人中使用这一模型，但它也将为其他公司提供先进的前沿智能，使其能够根据自身需求进行调整，并且无需向 OpenAI 支付每个 token 的费用。
在训练和随后的微调过程中，Meta 特别注重聊天机器人的 “有用性”。Meta 在一份声明中表示：“通过 Llama 3.1 405B，我们努力提高模型在响应用户指令时的有用性、质量和详细指令跟随能力，同时确保高水平的安全性。” 该版本还配备了更大的 128,000 token 上下文窗口，使其大致符合行业标准。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ec6fde9ccdc84a81ddaf63f54e41bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0d2668a2b00606b6feed8c0693e92b/" rel="bookmark">
			【数据结构】搜索二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉搜索树 二叉树的博客
在之前的数据结构的文章中已经基本对二叉树有一定的了解，二叉搜索树也是一种数据结构，下面将对二叉搜索树进行讲解。
二叉搜索树的概念 二叉搜索树又称为二叉排序树，它或者是一棵空树，或者是具有下面性质的二叉树：
若它的左子树不为空，则左子树上的所有节点的值都小于根节点的值。若它的右子树不为空，则右子树上的所有节点的值都大于根节点的值。它的左右子树也分别为二叉搜索树。 ​
​
​
二叉搜索树的特点是搜索数据比较快，最多高度次就可以找到所值，其高度最大就是O(N)
二叉搜索树的实现过程 基本框架 需要有一个struct的类（struct的类默认公开）来包含一个节点的所有特性，包括其可以指向左子树、右子树以及其包含的数据。然后使用class的类来对这棵二叉搜索树进行封装。 template&lt;class K&gt; struct BSTreeNode { BSTreeNode(const K&amp; key) :_left(nullptr) ,_right(nullptr) ,_key(key) {} BSTreeNode&lt;K&gt;* _left; BSTreeNode&lt;K&gt;* _right; K _key; }; template&lt;class K&gt; struct BSTree { typedef BSTreeNode&lt;K&gt; Node; public: private: Node* _root; }; 初始化二叉树： //初始化节点 BSTree() :_root(nullptr) {} 二叉搜索树的插入 插入过程：
当树为空的时候，直接新增节点，赋值给root指针。树不为空，按二叉搜索树的性质查找插入位置，插入新节点。 //插入数据 bool insert(const K&amp; key) { if (_root == nullptr) { _root = new Node(key); return true; } Node* cur = _root; Node* parent = nullptr; while (cur) { if (cur-&gt;_key &lt; key) { parent = cur; cur = cur-&gt;_right; } else if (cur-&gt;_key &gt; key) { parent = cur; cur = cur-&gt;_left; } else { return false; } } cur = new Node(key); if (cur-&gt;_key &gt; parent-&gt;_key) { parent-&gt;_right = cur; } else { parent-&gt;_left = cur; } return true; } 搜索二叉树的打印（使用中序遍历） 在这段代码中，使用_root作为参数传递给_InOrder函数，而不是直接在_InOrder函数中使用__root，主要是为了增加代码的灵活性和可复用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0d2668a2b00606b6feed8c0693e92b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de8ce4f2c3525d4c702f7c4687d2649/" rel="bookmark">
			写作新潮流：这五款AI写作工具，让你的作品脱颖而出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现实生活中，除了专业的文字工作者，各行各业都避免不了需要写一些东西，比如策划案、论文、公文、讲话稿、总结计划……等等。而随着科技的进步，数字化时代的深入发展，AI已经成为日常工作中必不可少的工具了，很多人都会借助AI来创作自己需要的文字稿。
自从GPT问世以后，国内的AI工具也如雨后春笋，纷纷面世。面对众多的AI工具，可能你会觉得无从下手，很难选择。笔者虽不能说把所有的AI工具都试用了一遍，但经过亲身实践，挑选了以下五款使用起来比较方便的AI写作工具，如果你是AI写作小白，正打算尝试用AI写作但是无从下手的话，可以考虑从中选择一款或几款试用。
一、笔灵AI写作：创意无限的文字生成器
入口：https://ibiling.cn/?from=csdn15
笔灵AI写作是一款全能型的AI写作工具，界面简洁，操作简单，海量的写作模板基本能满足你所有的写作需求。
它包含了论文大纲、公文写作、工作总结、撰写文案、述职报告、教学课件等在内的200+写作模板，覆盖了包括办公、机关单位、教育教学、自媒体等多个写作场景。
用户只需简单输入标题和描述，笔灵就能通过先进的AI技术，自动识别要求，几秒之内就能快速生成一篇优质的文稿内容。
此外，笔灵AI还具有智能续写、扩写、改写、简写等功能，无论是黔驴技穷还是灵感全无，它都能帮你解决写作难题。
而且这个改写功能，还能选择五种不同的语气，可以满足不同场合下的需求，是不是很棒？！
一起来看看同一段文字用不同语气改写后的效果吧：
还有续写的内容质量也是很高的：
所以这款工具是非常推荐使用的。
二、笔灵AI论文：学术写作的好帮手
入口：https://ibiling.cn/paper?from=csdnpaper10
笔灵论文写作是一款专业的AI论文生成工具，能够帮助学生和学者更高效地撰写论文。它基于大型语言模型，可以自动生成论文的各类内容，如开题报告、毕业论文、职称论文等。
用户只需进入笔灵论文写作官方网站，选择专业并输入论文题目，即可生成千字大纲目录。而且，大纲的生成速度是很快的，基本60秒以内就能搞定
然后，用户可以编辑大纲，生成全文模板，根据需要增加、删减章节，修改章节内容。
大纲确定以后，就可以生成论文初稿了。这个速度也是很棒的，大约五分钟之内就可以完成，而且查重率很低，你还可以先预览一下文稿，看看是不是自己想要的效果。最后，下载论文文件，即可得到初步的论文草稿。
这款工具覆盖了700+学科专业，可以满足不同用户的需求。
三、AIcheck：从选题到论文都可搞定
入口： https://www.aicheck.cc/
除了笔灵论文，推荐另一个论文写作的AI工具：AIcheck。
这个工具比较好用的也是区别于其他论文写作工具的地方，我觉得就是它可以生成论文选题。
因为很多人写论文，可能从选题开始就很头疼了对吧？所以这个生成选题的功能还是很友好的。
同样的，它还可以根据需求，单独生成开题报告、文献综述等不同的部分。
四、逐笔AI公文：专业公文写作神器
入口：https://zhubiai.com/template?from=csdn06
体制内可以说是人人羡慕的工作了，但是他们也有自己的烦恼：工作规范性强、工作量大又枯燥无味。有了公文写作AI工具可以轻松解决公文写作的烦恼。
逐笔就是一款专门针对公文写作的AI工具。一些常用的公文写作，例如心得体会、思想感悟、宣传演讲、计划方案、讲话发言等，它都能搞定：
逐笔AI的操作很简单，只需输入标题和关键词（关键词也可以不写），点击生成，即可产出你想要的内容。
公文格式要求严，写起来可能比较枯燥，引经据典、排比等这些写作手法就显得很重要了。但是“书到用时方恨少”，写作起来你经常会发现搜肠刮肚也难以找到合适的经典或句子。而逐笔AI有一个金句写作功能，排比、引用、双关、拟人化等都不在话下。
如果你有公文写作的需求，这款工具是一个不错的选择。
五、新华妙笔：大量范文可以学习
入口：https://miaobi.xinhuaskl.com/
新华妙笔也是一款专门针对公文写作的AI工具。作为新华社推出的AI公文写作平台，新华妙笔在公文写作方面是非常专业的。看下它的界面，公文类型非常地全面：
另外，它还提供了大量的各种类型的公文范文可以进行学习：
在这里还能找到大量的写作素材，能为你的工文写作提供非常有用的支持！
这五款AI写作工具各具特色，功能强大且实用。它们不仅提高了写作效率，还为创作者们带来了更多的创作灵感和可能性。当然，我们也要意识到，虽然AI工具在写作过程中起到了很大的辅助作用，但真正的创意和深度思考仍然需要人类来完成。希望这组AI工具组合能为你的创作之路增添一抹亮色！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020c1ac05cd329a2d995943e4d2ca53b/" rel="bookmark">
			SQL Server 数据误删的恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常的数据库管理中，数据的误删操作是难以避免的。为了确保数据的安全性和完整性，我们必须采取一些措施来进行数据的备份和恢复。本文将详细介绍如何在 SQL Server 中进行数据的备份和恢复操作，特别是在发生数据误删的情况下。假设我们已经开启了全量备份，并且在误操作之前有一个全量备份文件。
一、模拟误删 1. 创建表并插入测试数据 首先，我们需要创建一个名为 “Test” 的数据库，并在其中创建一个名为 “Student” 的表。该表将包含一些测试数据。
SSMS 连接本地 SQL Server。
创建新数据库 “Test”。
创建数据库 “Test”，并在该库内创建数据表 “Student”
-- 创建数据库 CREATE DATABASE Test; -- 使用 Test 数据库 USE Test; -- 创建 Student 表 CREATE TABLE Student ( id INT IDENTITY(1,1) PRIMARY KEY, name NVARCHAR(255) NOT NULL, phone NVARCHAR(50) NOT NULL, gender NVARCHAR(10) NOT NULL, created_at DATETIME DEFAULT GETDATE() ); -- 插入十条测试数据 INSERT INTO Student (name, phone, gender, created_at) VALUES ('Alice', '1234567890', 'Female', GETDATE()), ('Bob', '0987654321', 'Male', GETDATE()), ('Cathy', '1231231234', 'Female', GETDATE()), ('David', '3213214321', 'Male', GETDATE()), ('Eva', '5556667777', 'Female', GETDATE()), ('Frank', '8889990000', 'Male', GETDATE()), ('Grace', '2223334444', 'Female', GETDATE()), ('Henry', '4445556666', 'Male', GETDATE()), ('Ivy', '1112223333', 'Female', GETDATE()), ('Jack', '7778889999', 'Male', GETDATE()); 记录本次操作时间为：2024-07-23 17:30:45
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/020c1ac05cd329a2d995943e4d2ca53b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8277bf67823be2838c0946f2e00dc8c/" rel="bookmark">
			一些和颜色相关网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.中国传统色
2.网页颜色选择器
3.渐变色网站
4.多风格色卡生成
5.波浪生成
6.半透明磨砂框
7.色卡组合
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2544ff58d4e67205fc691aeee8418a8a/" rel="bookmark">
			在windows上使用Docker部署一个简易的web程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Docker部署一个python的web服务🚀 由于是从事算法相关工作，之前在项目中，需要将写完的代码服务，部署在docker上，以此是开始接触了Docker这个工具，由于之前也没系统学习过，之后应该可能还会用上，所以打算通过一遍博客的方式记录一下也学习一下，这篇博客主要记录一个基础过程，把整个流程简化，重在理解思路，如果有问题或者写的不对的地方，欢迎留言或私信交流。
Docker 是一个开源平台，利用容器技术将应用程序及其所有依赖打包到一个标准化的单元中，从而确保它们能够在任何计算环境中一致地运行。容器是轻量级的、可移植的，并且在不同的操作系统和云环境中运行时具有一致性，使得应用程序的开发、测试和部署过程更加高效和可靠。Docker 使开发人员和运维人员能够更容易地协作，简化了持续集成和持续部署（CI/CD）工作流程。
文章目录 使用Docker部署一个python的web服务🚀1.Docker 安装2.编写一个简单的web服务2.1 本地python环境配置安装2.1 使用Flask编写一个 hello_world 服务 3.编写一个doceker file3.1 使用FROM 命令导入一个基础镜像3.2 创建一个工作目录3.3拷贝项目根目录下的所有文件到工作目录3.4在镜像中安装Flask3.5运行服务程序app.py3.6完整的Dockerfile文件 4. 在命令控制台搭建Docker镜像4.1 使用Docker build 搭建docker镜像源4.2 使用Docker RUN 运行容器4.3 使用浏览器访问Docker镜像中运行的服务 结束 1.Docker 安装 首先到官网点击Download进行下载，由于我自己的电脑是windows所以这里下载了一个windows版本
https://www.docker.com/
下载完成之后，正常安装就一直点就行，打开应用，首先会出现启动引擎的加载动画，然后进入到如下界面。
然后打开电脑的powershell输入docker --version查看一下docker版本，检查一下通过powershell能不能使用docker命令，这也是检查docker安装成功的关键一步，如果打印出版本信息了，表示安装成功了。
docker --version 2.编写一个简单的web服务 安装好了docker之后可以先简单写一个python的服务程序，在写一个新的python项目之前先在anaconda中建一个虚拟环境。
2.1 本地python环境配置安装 新建环境命令，我这里起的名字是doceker_web（这个命令最后安装的python的具体版本为3.10.14）
conda create --name docker_web python=3.10 运行上述命令之后，输入y开始下载虚拟环境的各种文件。
输入激活虚拟环境的命令进入虚拟环境
conda activate docker_web 然后安装一个Flask框架,这里我由于我配置了全局清华镜像源，所以是从镜像源里下载的。
pip install Flask 之后新建一个项目然后选一下解释器，0基础的同学，可以找一下周围会做的让你帮着改一下，或者自己搜一下。
2.1 使用Flask编写一个 hello_world 服务 之后这里直接写一个最简单的服务代码，如果零基础的同学可移步在下之前的文章。
Flask框架初探-如何在本机发布一个web服务并通过requests访问自己发布的服务-简易入门版
from flask import Flask app = Flask(__name__) @app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2544ff58d4e67205fc691aeee8418a8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5912035d2a8743a65c761a263c1b0adf/" rel="bookmark">
			【笔记】Android Studio 版本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio Jellyfish | 2023.3.1 | Android Developers
Android Studio 是开发 Android 应用的官方 IDE，包含构建 Android 应用所需的所有功能。
AS与AGP版本适用关系 AGP(Android Gradle plugin) Android gradle插件
Androdi Studio versionRequired AGP versionKoala | 2024.1.13.2-8.5Jellyfish | 2023.3.13.2-8.4Iguana | 2023.2.13.2-8.3Hedgehog | 2023.1.13.2-8.2Giraffe | 2022.3.13.2-8.1Flamingo | 2022.2.13.2-8.0Electric Eel | 2022.1.1 (Jan 2023)Dolphin | 2021.3.1（Sep 2022）Chipmunk | 2021.2.1 (May 2022)Bumblebee | 2021.1.1（Jan 2022）Arctic Fox | 2020.3.1 (July 2021) 7.0.0
SDK版本关系 特定 Android API 级别所要求的最低工具版本
API 级别最低 Android Studio 版本最低 AGP 版本VanillaIceCream 预览Jellyfish | 2023.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5912035d2a8743a65c761a263c1b0adf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38623d6f794557a3348b10eec76d6edb/" rel="bookmark">
			安装 Android Studio 2024.1.1.6（Koala SDK35）和过程问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录更新Android Studio版本及适配Android V应用配置的一些过程问题。
安装包：android-studio-2024.1.1.6-windows.exe原版本：Android Studio23.2.1.23 Koala 安装过程 Uninstall old version 不会删除原本配置（左下角提示）
Uninstall old version Android Studio Setup Choose Component Configuration Settings 可自选路径 E:\SOFTWARE\Android\Android Studio 24.1.1.6
Configuration Settings Choose Start Menu Folder 配置桌面开始图标
Choose Start Menu Folder 安装完成 ，提示马上启动
Install Complete 【问题解决】启动报错 Operation not supported: bind Start fail
Internal error. Please refer to https://issuetracker.google.com/issues/new?component=192708
java.net.SocketException: Operation not supported: bind
at java.base/sun.nio.ch.UnixDomainSockets.bind0(Native Method)
at java.base/sun.nio.ch.UnixDomainSockets.bind(UnixDomainSockets.java:129)
at java.base/sun.nio.ch.ServerSocketChannelImpl.unixBind(ServerSocketChannelImpl.java:319)
at java.base/sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:292)
at java.base/java.nio.channels.ServerSocketChannel.bind(ServerSocketChannel.java:224)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38623d6f794557a3348b10eec76d6edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d4837ec7a2b16e20fa3789e5d4f043/" rel="bookmark">
			【区块链&#43;绿色低碳】基于区块链的碳排放管理系统 | FISCO BCOS应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前业内的碳排放核查方式主要依靠于第三方人工核查、手动填报数据，然后由具备有认证资质的机构进行核验 盖章。但在此过程中存在数据造假的情况，给碳排放量核算的准确性、可靠性带来挑战。
中科易云采用国产开源联盟链 FISCO BCOS，推出基于区块链建设碳排放数据核算管理系统。该系统将碳排数据 全部上链，并支持相关方的查阅和审计。区块链的共识机制、不可篡改性和非对称加密技术，保证了碳排数据的 安全可靠。此外，数据操作都在平台上进行，不仅节约了人工成本，也提升了核算的速度和准确率。
本系统在实际应用中，对企业电力消耗、能源消耗及其他消耗进行了实时监测，并通过对碳排放的核算，实现了 碳排放的全程智能化管理。企业和机构能据此制定减排方案，借此帮助其优化能源结构、提高能源效率、推广可 再生能源等，促进绿色低碳发展，实现可持续发展的目标。
在现行情况下，得益于诸多条件，此系统也具有良好的发展前景：
1. 政府和组织需求增加：政府对碳排放的监管和减排目标的设定，以及组织内部对于环保和可持续发展的要求， 将推动碳排放核算管理系统的需求持续增加。
2. 技术的不断进步：随着技术的不断发展，碳排放数据的获取和计算方法将更加精准和智能化。碳排放核算管理 系统将能够更准确地跟踪和计算碳排放量，提供更优质的数据分析和决策依据。
3. 碳市场的发展：随着碳交易市场的不断发展，一些国家和地区已经建立了碳市场体系，并引入碳排放配额交易 制度。碳排放核算管理系统可以帮助参与碳市场的组织进行碳排放量的监测、报告和验证，帮助其更好地管理碳 资产。
4. 可持续金融的兴起：可持续金融的兴起将进一步推动碳排放核算管理系统的发展。银行、投资机构和保险公司 等金融机构需要了解客户的碳排放情况，并据此评估其可持续性和风险。碳排放核算管理系统可以提供准确的数 据和报告，帮助金融机构进行风险评估和决策。
5. 公众参与意识的提高：公众对于环境保护和碳减排的参与意识不断提高。碳排放核算管理系统可以为个人提供 了解自身碳足迹的机会，并提供采取相应措施的建议，从而实现公众参与碳减排的目标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976116e2e0af96a7d7649e3e61641e76/" rel="bookmark">
			背单词工具(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能分析 生词本管理： 创建生词本文件：在构造函数中创建了“生词本.txt”“背词历史.log”“历史记录.txt”三个文件。添加单词：用户可以输入单词、词性和解释，将其添加到生词本中。查询所有单词：展示生词本中所有的单词、词性和翻译。精确查词：用户可以选择按照单词、词性或中文解释进行查词，并显示查询结果。删除单词：根据用户输入删除生词本中的特定单词。背词功能： 背生词：从生词本中读取单词进行背诵，背诵完成后将生词从生词本中删除，并将相关信息添加到背词历史中。历史记录查询： 根据时间查历史记录：用户输入年月日，查询该日期的背词历史记录，并将其保存到历史记录文件中。查询历史背词：展示历史记录文件中的内容。其他功能： 更新日志：输出新增功能的说明。总的服务界面：提供菜单界面，用户根据序号选择相应的服务。 详细代码 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;iomanip&gt; //输出控制头文件1 #include &lt;time.h&gt; #include &lt;windows.h&gt; using namespace std; class Recite { fstream file; fstream file1; public: Recite(); //创建生词本文件 void insert_word(); //添加单词 void query_all(); //查询所有单词 void query_by_time();//根据时间查历史记录 void query_history();//查询历史背词 void query_exact(); //精确查词 void delete_word(); //删除单词 int get_num(); //返回生词本中单词的数量 void recite_word(); //背生词 void update_log(); //更新日志 void run(); //总的服务界面 }; Recite::Recite() { file.open("生词本.txt"); file.close(); file.open("背词历史.log"); file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/976116e2e0af96a7d7649e3e61641e76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd514222f8090f48a2c53480c52db911/" rel="bookmark">
			用uniapp 及socket.io做一个简单聊天app 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里只有群聊，二个好友聊天，可以认为是建了一个二人的群聊。
const express = require('express'); const http = require('http'); const socketIo = require('socket.io'); const cors = require('cors'); // 引入 cors 中间件 const app = express(); const server = http.createServer(app); const io = socketIo(server, { cors: { origin: "*", // 允许所有来源 methods: ["GET", "POST"] } }); // 使用 cors 中间件 app.use(cors()); const port = 3000; const groups = {}; io.on('connection', (socket) =&gt; { console.log('New user connected'); // 用户加入群组 socket.on('joinGroup', ({ groupName, userName }) =&gt; { socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd514222f8090f48a2c53480c52db911/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/116/">«</a>
	<span class="pagination__item pagination__item--current">117/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/118/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>