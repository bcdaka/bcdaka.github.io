<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0364b74c810a7d0bc7de8b9687963c/" rel="bookmark">
			手把手带你搭建一个语音对话机器人，5分钟定制个人AI小助手（新手入门篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 如果你的身边有一个随时待命、聪明绝顶的AI小助手，能够听懂你的话，理解你的需求，用温暖的声音回应你，会是一种什么体验？
今天，带大家从0到1搭建一个语音对话机器人，分分钟拥有一个专属的个人AI小助手。
本文面向技术小白，以最通俗易懂的语言，最贴心的步骤指导，确保你能够轻松上手，快速掌握。
语音对话系统的基本组成有哪些？ 一个可以实现语音对话的机器人，通常需要由硬件和软件构成，硬件可以理解为机器人的躯体。
本篇主要来聊聊语音对话机器人的软件部分。
说到软件部分，通常又可以抽象为三个部分：
自动语音识别（Automatic Speech Recognition, 简称 ASR），相当于 机器人的耳朵，用于把我们的语音识别成文字；自然语言处理（Natural Language Processing, 简称 NLP），相当于 机器人的大脑，理解上一步得到的文字信息，并进行答复，当前主流的解决方案是大语言模型LLM；文本到语音合成（Text to Speech，简称 TTS），相当于 机器人的嘴巴，把上一步的答复用语音回答出来 如何快速搭建语音对话系统？ 为了帮助大家从0到1快速完成一个系统的搭建，本文将完全采用开源方案来实现。具体而言：
ASR 采用 FunASR，相比 OpenAI 开源的 Whisper，中文识别效果更好；
NLP 采用大语言模型（LLM）方案，比如我们这里可以采用 LLaMA3-8B，采用本地的 GPU 部署和运行，如果没有本地 GPU 资源，也可以调用云端 API 实现这一步；
TTS 采用 最新开源的 ChatTTS，它是专门为对话场景设计的文本转语音模型，支持英文和中文两种语言，效果非常惊艳。
1 语音识别 ASR ASR 采用阿里开源的 FunASR，相比 OpenAI 开源的 Whisper，中文识别效果更好。
GitHub地址：https://github.com/modelscope/FunASR
模型调用参考：https://modelscope.cn/studios/iic/funasr_app_clipvideo/summary
通过如下代码，我们简单测试一下返回结果和模型效果：
from funasr import AutoModel # asr model funasr_model = AutoModel(model="iic/speech_seaco_paraformer_large_asr_nat-zh-cn-16k-common-vocab8404-pytorch", vad_model="damo/speech_fsmn_vad_zh-cn-16k-common-pytorch", punc_model="damo/punc_ct-transformer_zh-cn-common-vocab272727-pytorch", spk_model="damo/speech_campplus_sv_zh-cn_16k-common", ) rec_result = funasr_model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c0364b74c810a7d0bc7de8b9687963c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e5d0b8398eb7134b752d69116c2b69/" rel="bookmark">
			AI 定位！GeoSpyAI上传一张图片分析具体位置 不可思议! ! !
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡作者主页：点击！ 🤖常见AI大模型部署：点击！
🤖Ollama部署LLM专栏：点击！
⏰️创作时间：2024年6月16日12点23分
🀄️文章质量：94分
目录
————前言————
GeoSpy.ai
工作原理
GeoGuessr
💯趣站💯
官网测试
中国十大风景名胜
1.北京故宫
相似图片
大概坐标位置
2.长城
3.杭州西湖
分析相似的位置
直接显示地图位置
1.埃及金字塔
2.巴黎埃菲尔铁塔
总结
————前言———— 想象一下一个如此强大的工具，只需一张图像，它就可以精确定位您的确切位置，精确到纬度和经度。 GeoSpy.ai 免费提供这种令人惊叹的功能，利用先进的人工智能和地理空间智能从任何照片中提供精确定位。无论您是对去过的地方感到好奇，还是出于专业目的需要准确的地理数据，这项突破性的技术都为以惊人的准确性了解我们的世界开辟了新的可能性。
GeoSpy.ai 结合先进的人工智能和地理空间分析技术来确定图像的位置。
工作原理 图像识别：人工智能算法分析图像的视觉内容，识别地标、自然特征和其他上下文线索。地理空间数据库：系统将这些视觉线索与包含卫星图像、地图和地理信息的广泛地理空间数据库进行交叉引用。机器学习：机器学习模型通过从大量已知位置的图像中学习，随着时间的推移完善其预测，从而提高准确性。 这种技术的集成可以通过单张照片进行精确的地理定位。
GeoGuessr GeoGuessr 是一款在线地理游戏，它使用 Google 街景图像来挑战玩家猜测世界各地的位置。玩家被投放到一个随机位置，必须使用环境中的视觉线索（例如路标、景观和建筑）来在地图上精确定位他们的位置。他们的猜测越接近实际位置，他们获得的积分就越多。该游戏提供不同的模式，包括单人游戏、多人挑战以及专注于特定区域或地标的主题地图。
大概的原理十分的相似
💯趣站💯 前些天发现了一个巨牛的🤖人工智能学习网站，通俗易懂，风趣幽默，忍不住粉香一下给大家,人工智能, 机器算法等...... 点击跳转！https://www.captainbed.cn/sis/
官网测试 首先我们进入官网之后
点击跳转！
上传几张图片来做测试
以下内容仅做参考!(AI模型并不是那么完美，处于发展阶段)
所以拿一些名胜古迹，世界著名景点来做为此次测试目标
中国十大风景名胜 我们选择几个景点来做测试
1.北京故宫 上传图片进行分析
给出的结果
Country: China City: Beijing Explanation: The photo was taken from Jingshan Park, looking north towards the Forbidden City.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e5d0b8398eb7134b752d69116c2b69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b90d7eff67e590fc1ee31d4ca7895e5/" rel="bookmark">
			【Go语言】Gin 框架教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gin 框架教程 1.第一个 Gin 程序 1.1 Gin 安装 # 执行执行如下操作即可，安装Gin前需要安装Go环境 go get -u -v github.com/gin-gonic/gin # -v：打印出被构建的代码包的名字 # -u：已存在相关的代码包，强行更新代码包及其依赖包 1.2 Gin 项目创建 在一个空文件夹里新建文件 main.go，参考如下代码编写一个 Gin 程序。
// blog.euansu.cn // main.go package main import "github.com/gin-gonic/gin" func main() { r := gin.Default() r.GET("/", func(c *gin.Context) { c.String(200, "Hello, EuanSu") }) r.Run() // listen and serve on 0.0.0.0:8080 } 运行 main.go 程序，如下图所示。
go run main.go 代码说明：
首先，r := gin.Default()这里生成了一个 Gin 引擎实例，用于处理 HTTP 请求，也即 WSGI 应用程序，这个实例会预先加载一些默认的中间件。r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b90d7eff67e590fc1ee31d4ca7895e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7f5fce1d587a9ee197a25f67d78d92/" rel="bookmark">
			微信 小程序应用，页面，组件的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件生命周期 组件的生命周期：指的是组件自身的一些钩子函数，这些函数在特定的时间节点时被自动触发
组件的生命周期函数需要在 lifetimes 字段内进行声明
最重要的生命周期是 created attached detached 包含一个组件生命周期流程的最主要时间点
定义段描述created在组件实例刚刚被创建时执行，注意此时不能调用 setData （还没有对模板解析）attached在组件实例进入页面节点树时执行 (模板已经解析完毕，并且挂载到页面上)ready在组件布局完成后执行moved在组件实例被移动到节点树另一个位置时执行detached在组件实例被从页面节点树移除时执行 (组件被销毁了) 【组件实例刚刚被创建好时】， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。 此时还不能调用 setData 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。
【在组件完全初始化完毕】、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
【在组件离开页面节点树后】， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。
Component({ lifetimes: { created: function () { // 在组件实例刚刚被创建时执行，注意此时不能调用 setData // 一般用来为组件添加一些自定义属性字段。 }, attached: function() { // attached 在组件完全初始化完毕、进入页面节点树后执行 // 模板已经解析完毕，并且挂载到页面上 // 一般都是在这里写对应的交互 }, detached: function() { // 在组件实例被从页面节点树移除时执行 }, // coding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e7f5fce1d587a9ee197a25f67d78d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101e20f54d476ad6a35b797992f73073/" rel="bookmark">
			【数据结构】初识集合&amp;深入剖析顺序表（Arraylist）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构】初识集合&amp;深入剖析顺序表（Arraylist） 集合体系结构集合的遍历迭代器增强for遍历lambda表达式 List接口中的增删查改List的5种遍历ArrayList详解ArrayList的创建ArrayList的增删查改ArrayList的遍历ArrayList的底层原理 🚀所属专栏：数据结构与算法学习⭐⭐
🚀欢迎光顾我的主页： 2的n次方_⭐⭐
集合体系结构 Java集合框架主要由以下几个部分组成：
接口：这是集合框架的基础，定义了各种集合的基本操作，如添加、删除、查找等。主要的接口有Collection、List、Set、Queue、Map等。
实现类：这些类实现了集合框架中的接口，提供了具体的集合实现。例如，ArrayList、LinkedList实现了List接口，HashSet、TreeSet实现了Set接口，HashMap、TreeMap实现了Map接口等。
迭代器：迭代器（Iterator）允许程序员遍历集合中的元素，而无需了解集合底层的实现细节
同时，集合在Java中确实分为单列集合（Collection）和双列集合（Map）两大类，单列集合就是下图中左边的部分，每次存储一个元素，双列集合是由键（key）和值（value）组成的集合，也称为键值对集合
List系列集合：添加的元素是有序的，可重复，有索引的
Set系列集合：添加的元素是无序的，不重复，无索引的
由于这个特性，在添加元素时List系列集合允许元素重复，add返回值为true，set系列集合不允许元素重复，元素重复时add返回值为false
Collection是所有单列集合的父类接口，也就是它的功能所有的单列集合都可以用
contains方法底层是依赖equals方法进行判断的，所以，如果集合中存储的类型是自定义类型，就要重写equals方法，否则会直接调用Object类的equals方法
集合的遍历 迭代器 就相当于c语言中的指针，通过迭代器就可以实现集合的遍历
public static void main(String[] args) { Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); c.add("hello"); c.add("world"); Iterator&lt;String&gt; it = c.iterator(); while(it.hasNext()){ System.out.println(it.next()); } } 注意：
如果已经遍历完最后一个元素，再强行往后遍历就会报错
迭代器遍历完毕，指针不会复位，如果要再遍历一遍，就要重新创建迭代器对象
循环中只能用一次next方法
迭代器遍历时，不会能用集合中的方法进行增加或者删除
增强for遍历 增强for底层就是迭代器，是为了简化迭代器的代码而出现的，所有的单列集合和数组才能用增强for来遍历
格式：
for(元素类型 变量名 ：数组或集合){
}
public static void main(String[] args) { Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); c.add("aa"); c.add("bb"); c.add("cc"); for(String s:c){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101e20f54d476ad6a35b797992f73073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35e20d9202b1cb2adff59d602e88332/" rel="bookmark">
			GitHub Copilot 登录账号激活，已经在IntellJ IDEA使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub Copilot 想必大家都是熟悉的，一款AI代码辅助神器，相信对编程界的诸位并不陌生。
今日特此分享一项便捷的工具，助您轻松激活GitHub Copilot，尽享智能编码之便利！
GitHub Copilot 是由 GitHub 和 OpenAI 共同开发的人工智能代码辅助工具，所以该插件是专门提供给程序员来写代码的，可以自动地生成高质量代码片段、上下文信息等。能够通过分析程序员编写的代码、注释和上下文信息，自动生成代码，减轻程序员的工作量,节省开发者的时间和精力。
获取copilot地址：https://web.52shizhan.cn/activity/copilot GitHub Copilot 支持五种代码编辑器：
同时，GitHub Copilot 为多种语言和各种框架提供建议，但尤其适用于Python、JavaScript、TypeScript、Ruby、Go、C# 和C++等。
这里以Pycharm 安装GitHub Copliot 为例，其他jetbrains系列产品类似，打开 Pycharm 找到左上角Settings点击打开
点击Plugins，搜索插件“「GitHub Copilot」” 直接install
安装好以后点击Restart IDE
接下来，我们开始授权激活GitHub Copliot。
重启之后，我们继续打开 Pycharm，开始登陆自己的GitHub 账号，点击右侧GitHub Copliot Chat -&gt;Sign in to GitHub
点击Copy and Open后就会跳转到浏览器（这里系统默认自动已经帮你复制设备码了）
登录授权你的GitHub 账号，没有登录账号的话首先需要登录你的GitHub 账号。
点击授权
授权成功后，返回你的IDE工具，点击ok
待授权成功跳转，底部copilot显示正常使用就可以使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4ecba862c024fde7f018d4d594d48a/" rel="bookmark">
			Python在SQLite中的应用：从入门到进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python在SQLite中的应用：从入门到进阶 Python作为一门高效、灵活的编程语言，广泛应用于各种数据处理和分析任务。而SQLite是一种轻量级的数据库管理系统，特别适合于嵌入式应用和小型项目。在本篇博文中，我们将深入探讨Python在SQLite中的应用，帮助读者从零开始，逐步掌握这项技能。
为什么选择SQLite？ SQLite是一种嵌入式的关系型数据库管理系统，具有以下几个显著特点：
轻量级：SQLite非常小巧，无需安装即可使用，适合嵌入到各种应用中。易于使用：SQLite的语法与标准SQL非常接近，对于有SQL基础的开发者来说，入门非常简单。高性能：虽然是轻量级数据库，但SQLite在处理小型和中型数据集时性能非常优越。跨平台：SQLite可以运行在各种操作系统上，包括Windows、Linux和macOS。 准备工作 在开始之前，请确保您的系统中已安装了Python。如果尚未安装，请访问Python官方网站进行下载和安装。接下来，我们需要安装SQLite的Python库，即sqlite3。幸运的是，sqlite3是Python标准库的一部分，无需额外安装。
基础操作 创建数据库和表 首先，我们需要创建一个SQLite数据库文件，并在其中创建一张表。例如，我们可以创建一个名为students.db的数据库，并在其中创建一个students表，存储学生的信息。
import sqlite3 # 连接到SQLite数据库（如果数据库不存在，会自动创建） conn = sqlite3.connect('students.db') # 创建一个游标对象 cur = conn.cursor() # 创建学生表 cur.execute(''' CREATE TABLE IF NOT EXISTS students ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER, grade TEXT ) ''') # 提交更改并关闭连接 conn.commit() conn.close() 插入数据 创建表后，我们可以向表中插入数据。以下示例展示了如何向students表中插入几条记录。
# 重新连接到数据库 conn = sqlite3.connect('students.db') cur = conn.cursor() # 插入数据 cur.execute('INSERT INTO students (name, age, grade) VALUES (?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e4ecba862c024fde7f018d4d594d48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be6bb66c8b0ef4e8038e4c7ec5c2296/" rel="bookmark">
			Parallelize your massive SHAP computations with MLlib and PySpark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://medium.com/towards-data-science/parallelize-your-massive-shap-computations-with-mllib-and-pyspark-b00accc8667c (能翻墙直接看原文） A stepwise guide for efficiently explaining your models using SHAP. Photo by Pietro Jeng on Unsplash
Introduction to MLlib Apache Spark’s Machine Learning Library (MLlib) is designed primarily for scalability and speed by leveraging the Spark runtime for common distributed use cases in supervised learning like classification and regression, unsupervised learning like clustering and collaborative filtering and in other cases like dimensionality reduction. In this article, I cover how we can use SHAP to explain a Gradient Boosted Trees (GBT) model that has fit our data at scale.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be6bb66c8b0ef4e8038e4c7ec5c2296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef42d1e46de7521cfa53fe496fbc8fb/" rel="bookmark">
			【JavaEE精炼宝库】多线程（6）线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、线程池的概念及优势
1.1 线程池的概念：
1.2 线程池的优势：
二、工厂模式
三、标准库中的线程池
3.1 标准库线程池参数解释：
3.1.1 corePoolSize | maximumPoolSize：
3.1.2 keepAliveTime | unit：
3.1.3 workQueue： 3.1.4 ThreadFactory： 3.1.5 handler：
3.2 创建线程池演示：
3.3 利用线程池的工厂类来创建线程池：
3.4 线程池的使用演示：
四、线程池的实现
一、线程池的概念及优势 1.1 线程池的概念： 线程池是一种并发编程的技术，它维护着一组预先创建的线程，以便在需要时重用它们来执行多个任务。这可以提高程序的性能和效率，因为线程的创建和销毁通常是昂贵的操作，通过重用线程，可以减少这种开销。
在我们前面已经介绍了线程比进程更加轻量，在频繁创建销毁的时候，线程更有优势。但是随着时代的发展，对于 “频繁” 有了新的定义（比如之前 1 万就认为是频繁，但是现在可能 1000 万才认为是频繁）。即使是线程，在如此频繁的创建和销毁的情况下，开销也变得难以接受。
那么要怎么优化呢？
答：我们可以通过线程池和协程进行优化。
协程这里我们暂且不进行描述，Go 语言主打的卖点就是使用协程处理并发编程。线程池的优化我们马上讲到。
1.2 线程池的优势： • 降低资源消耗：
减少线程的创建和销毁带来的性能开销。
• 提高响应速度：
当任务来时可以直接使用，不用等待线程创建
• 可管理性：
进行统一的分配，监控，避免大量的线程间因互相抢占系统资源导致的阻塞现象。
二、工厂模式 在下面即将介绍的线程池参数中，其中有一个参数是工厂类。所以在这里提前给大家解释一下什么是工厂模式。
工厂模式：也是一种设计模式，主要解决的问题是构造方法创建对象太坑了的问题。为什么说构造方法创建对象有坑呢？举个栗子：
因为在 Java 的语法中要求构造方法的命名必须是类名且参数类型和个数，排列顺序不能一样。这就导致遇到上面这种案例解决不了。就需要工厂模式，核心思路，不使用构造方法创建对象，给构造方法包装一层。例如下面这段代码：这只是个伪代码，看看思路就行，makePointByXY 这样的方法就叫 “工厂方法”，这样写代码的套路就叫做 “工厂模式”，没有什么特别的。
public class Point { public static Point makePointByXY(double x,double y){ Point p = new Point(); p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef42d1e46de7521cfa53fe496fbc8fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b5c9aed9fe7a2f698d271e0c48f70ed/" rel="bookmark">
			一些个人电脑用的小工具软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 个人电脑信息管理 如下；
整理自己的电脑信息；录入，保存，查询；添加和更新界面如下，
每次添加、更新之后重新点一下菜单的浏览；
下载，
https://download.csdn.net/download/bcbobo21cn/89440602 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94130ab3110d5926b01140e0e288e20a/" rel="bookmark">
			[Qt的学习日常]--常用控件1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
作者：小蜗牛向前冲
名言：我可以接受失败，但我不能接受放弃
如果觉的博主的文章还不错的话，还请点赞，收藏，关注👀支持博主。如果发现有问题的地方欢迎❀大家在评论区指正
目录
一、什么是控件
二、QWidget属性
1、什么是QWidget
2、Qwidget核心属性 2.1、enabled
2.2、geometry
2.3、windowTitle
2.4、windIcon 2.5、windowOpacity
本期学习：学习控件的基础常识，对部分Qwidget的核心部分进行学习enable,geometry,window-Tilte,windowIcom，windowOpacity。
一、什么是控件 Widget是Qt中的核⼼概念.英⽂原义是"⼩部件",我们此处也把它翻译为"控件"控件是构成⼀个图形化界⾯的基本要素
上面图中的标识，我们都可以称为控件，在QT中控件的学习是非常重要的，所以我们要学习和掌握它。
在下面我们会学习到上图的一些控件，大家可以结合上图，对应去理解，当我第一次看前面这张图的时候不大脑还是懵逼的，学完之后豁然开然。
当我们打开Qt Creator的时候会有一个Forms文件夹，里面会有我们的widget.ui文件存放我们的相关控件
理解控件可以从两个方面来考虑：
视觉方面：控件是用户界面上可见的元素，它们有各种不同的外观和样式，用于呈现信息、接收输入或执行操作。例如，按钮控件用于触发操作，文本框控件用于接收用户输入，标签控件用于显示文本等等。
功能方面：控件具有各种功能，例如响应用户输入、发出信号、执行操作等。通过连接控件的信号（例如点击按钮时发出的信号）和槽（用于处理信号的函数），可以实现控件之间的交互和应用程序逻辑。
二、QWidget属性 1、什么是QWidget 在Qt中，QWidget（窗口部件）是所有可视化控件的基类，它提供了基本的用户界面功能。QWidget本身可以作为一个容器，用于包含其他控件，也可以作为一个可视化控件直接显示在用户界面上。
因此，QWidget可以被看作是控件的基础，它提供了控件所需的基本功能，如绘制、事件处理、布局管理等。其他更具体的控件，如按钮、文本框、标签等，通常都是从QWidget派生出来的特定类。
因此，可以说QWidget是控件的基类，而其他各种控件则是从QWidget派生出来的具体实现。
2、Qwidget核心属性 2.1、enabled 从字面意思理解，有激活的意思，主要控制控件是否可以被使用。
相关API
API说明isEabled获取到控件的可⽤状态setEabled设置控件是否可使⽤ true 表⽰可⽤,false 表⽰禁⽤ 对于禁用其实非常好理解，就是该控件不在接收任何用户的输入，外观是灰色的，鼠标点击是没有任何反应的(如果点击控件本身可以触发信息的话)。 代码示例: 通过按钮2切换按钮1的禁⽤状态
核心代码：
Widget.cpp
void Widget::on_pushButton_clicked() { qDebug() &lt;&lt; "按下按钮"; } void Widget::on_pushButton_2_clicked() { bool flag = this-&gt;ui-&gt;pushButton-&gt;isEnabled(); this-&gt;ui-&gt;pushButton-&gt;setEnabled(!flag); } 其中 2.2、geometry 对于geometry控件，我们要理解其核心属性:
x：横做标
y：纵坐标
width：宽度
height：高度
这里我们要注意的是 对于Qt的坐标系,是"左⼿坐标系".其中坐标系的原点是当前元素的⽗元素的左上⻆。
在图形用户界面编程中，窗口通常作为父元素，而窗口中的控件（如按钮、文本框、标签等）作为子元素。父元素（窗口）负责管理和布局这些子元素
但是实际开发中,我们并不会直接使⽤这⼏个属性,⽽是通过⼀系列封装的⽅法来获取/修改.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94130ab3110d5926b01140e0e288e20a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9f12291003cd6a03d0bdc2b3fb1719/" rel="bookmark">
			鸿蒙解决JSON字段名和对象属性名之间的对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HarmonyOS 中使用三方包 class-transformer 来进行解决。
class-transformer 是一个在 JavaScript 和 TypeScript 中用于对象和类之间进行转换的库。它特别有用在处理从 API 返回的 JSON 数据和将其转换为类的实例时，或者在序列化类的实例为 JSON 字符串时。
class-transformer 提供了几个主要的方法来处理对象和类之间的转换：
plainToClass: 将普通 JavaScript 对象转换为类的实例。
instanceToPlain: 将类的实例转换回普通 JavaScript 对象。
下载class-transform
ohpm install class-transformer 导入包
import { classToPlain, Expose, plainToClass } from 'class-transformer'; 编写代码，定义类
class MyClass { @Expose({ name: 'auth-type' }) authType: number = 1; } 测试代码
let myClass: MyClass = new MyClass(); myClass.authType = 1; let serializedData = instanceToPlain(myClass); let jsonStr: string = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9f12291003cd6a03d0bdc2b3fb1719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d56376a912ee6d829733fcf0785287ce/" rel="bookmark">
			mybatis-plus使用拦截器实现sql完整打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shigen坚持更新文章的博客写手，擅长Java、python、vue、shell等编程语言和各种应用程序、脚本的开发。记录成长，分享认知，留住感动。
个人IP：shigen
在使用mybatis-plus（mybatis）的时候，往往需要打印完整的sql语句，然而输出的日志不是很理想：
因为sql语句中的关键字段信息都是用？来代替的。那有什么方法实现完整的sql打印呢？有是有的，我记得IDEA的插件市场有一款插件可以实现完整sql的打印，但是好像是要收费的。今天刷某音的时候看到了某博主分享了一下自己写了一个拦截器实现了sql完整的打印，以下是实现的效果：
可以看到了sql的执行时间和完整的sql语句。sql的执行时间没啥好说的，关键是sql语句的完整打印。现在先来分享一下代码吧。
代码 controller的设计 这里仅展示关键的代码，一个更新的操作，一个分页查询的操作。
@PostMapping(value = "update") public Result&lt;String&gt; update(@RequestBody @Validated(value = UpdateGroup.class) User user) { int update = userMapper.updateById(user); return update &gt; 0 ? Result.ok(null) : Result.err(null); } @GetMapping(value = "get") public Result&lt;List&lt;User&gt;&gt; get(@RequestParam(value = "id", required = false) Integer id, @RequestParam(value = "name", required = false) String name ) { LambdaQueryWrapper&lt;User&gt; queryChainWrapper = new LambdaQueryWrapper&lt;&gt;(); queryChainWrapper.eq(id != null, User::getId, id); queryChainWrapper.eq(name != null, User::getUsername, name); List&lt;User&gt; records = userMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d56376a912ee6d829733fcf0785287ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452bc679285b4ede8a3c99d72b0ddf56/" rel="bookmark">
			浏览器插件利器-allWebPluginV2.0.0.14测试版发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		allWebPlugin简介 allWebPlugin中间件是一款为用户提供安全、可靠、便捷的浏览器插件服务的中间件产品，致力于将浏览器插件重新应用到所有浏览器。它将现有ActiveX插件直接嵌入浏览器，实现插件加载、界面显示、接口调用、事件回调等。支持谷歌、火狐等浏览器，接口调用友好、集成方便。为用户提供“信息化系统 + allWebPlugin + 插件 + 浏览器”的解决方案。产品介绍详见我的博文《浏览器插件利器-allWebPlugin中间件产品介绍》。
下载地址 链接：https://pan.baidu.com/s/1xUyQDzOabh7mU7J7TYhtig?pwd=z3q0 提取码：z3q0 演示步骤 从上述步骤中下载allWebPlugin V2.0.0.14版本并安装。在浏览器中输入http://127.0.0.1:6651即可。欢迎大家体验，并反馈意见和建议。谢谢大家！
演示入口页面 allWebOffice演示效果 VLC插件效果 金格iWebOffice2015插件效果 金格iWebPDF2018效果 福昕OFD版式阅读器插件效果 数科阅读器插件效果 更新记录 1、优化插件容器关闭策略。
2、js增加定时器，检测WebSoket状态，WebSocket关闭时，需重新连接服务。（有效解决浏览器闲置时，WebSocket自动关闭的问题）
3、插件容器进程创建之前，检测插件容器进程是否存在，剔除不存在的插件容器进程。
4、插件容器窗口局部截图。
5、插件容器程序检测到页面canvas鼠标点击事件，自动显示插件容器窗口。
6、修改演示demo，index页面为总入口页面。
7、调整iWebOffice2015演示实例，alert之前隐藏插件，alert之后显示插件，不免了遮挡提示框。
8、处理allWebOffice中Word工具条偶尔展示空白的问题。
9、处理火狐、360老版浏览器定位细微偏差的问题。
10、处理allWebPlugin标题栏缩放时，存在残影的问题。
11、整理allWebOffice 、iWebOffice2015演示demo代码，allWebOffice Demo增加书签导入文件的功能。
12、调整allWebOffice 、allWebPlugin标题栏字体大小，解决显示缩放显示不全的问题。
13、解决360安全、欧朋等浏览器左侧存在侧边栏时，插件容器存在显示偏移的问题。
14、适配谷歌、Edge、火狐、360安全、360极速、360AI、Opera、QQ浏览器、微信内置等浏览器。
15、增加金格iWebPDF2018、数科阅读器、福昕阅读器插件演示实例。
16、修复已知BUG。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baef23f55c2bc55049f66a2939c1f557/" rel="bookmark">
			Unity 3D 物体的Inspector面板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Transform：位置、旋转、大小
2、Mesh Filter：物体的形状
3、Mesh Renderer：物体渲染（物体的衣服）
4、Collider：碰撞体
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1538f118ef12de52300210e74b1b8b7d/" rel="bookmark">
			Android Studio 4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多插件不兼容了…
上面他们给我提的就是这个问题，打开 AS 的时候报如下错误：
// 插件错误：插件 “xxx” 是不兼容的（仅在 IntelliJ IDEA 中支持）
Plugin Error: Plugin “xxx” is incompatible (supported only in IntelliJ IDEA)
可能是 AS 升级到 4.1 后插件不兼容的原因，那我想着去升级一下插件吧！然后进入 Settings–&gt;Plugins–&gt;Installed，发现已安装那里插件都找不到了。
那就重装吧，可是重装的时候又提示插件不兼容，如下图：
然后跑去 stackoverflow 搜索不兼容的原因，有人说是 AS 4.1 插件安装的位置发生了改变导致的。
解决方法 1（针对插件使用者）：
找到插件安装的位置，然后将有问题的插件删除，重启 AS，重新安装即可。插件安装的位置如下：
C:\Users\UserName\AppData\Roaming\Google\Andr
oidStudio4.1\plugins
AS 4.1 之前插件安装的位置为：C:\Users\UserName.AndroidStudio4.0\config\plugins
有时候你还会遇到删除后去重装的时候还提示不兼容，那么需要在 AS 中先卸载再重装，如下图： OK，这时候就可以重装插件正常使用了。但是，当你关掉 AS 再打开的时候，发现插件又神奇的消失了…
最终的解决方法是将插件直接复制到系统插件的安装路径（注意，这个是系统插件的安装路径，上面那个是用户插件的安装路径）即可，系统插件的安装路径如下：
C:\Program Files\Android\Android Studio\plugins
解决方法 2（针对插件开发者）：
方法 1 是针对插件使用者而言，这种方法虽然解决了问题，但是不可能每次装一个新的插件都用这种方法吧！那么只能让插件开发者重新改代码兼容 AS 4.1 了。解决方法也很简单，修改插件的配置文件 plugin.xml，增加如下依赖即可：
com.intellij.modules.java
然后生成新的插件上传到插件库其他用户就可以用了，关于插件开发可以看我另一篇文章 自己撸一个 Android Studio 插件 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1538f118ef12de52300210e74b1b8b7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e715d839d4cfa386d743ffe370c593/" rel="bookmark">
			2024最新！最全！面试必看！！！【Redis面经】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Redis是什么？为什么要使用它？Redis为什么这么快Redis的存储结构有哪些？有哪些应用场景？Redis分布式锁是什么？实现方式Redis分布式锁的特征 redis跳表是什么？为什么不用b树而选择跳表？Redis的底层原理数据结构内存管理持久化网络模式高可用和集群缓存淘汰策略（管理内存使用）内部实现细节管道和事务 redis的集群（Cluster）结构以及如何设置Cluster是什么？Cluster的优势Cluster的劣势 redis缓存穿透问题缓存穿透出现情况如何避免缓存穿透布隆过滤器原理： redis 持久化机制RDB：快照持久化RDB的优点RDB的缺点 AOF 日志持久化AOF的优点：AOF的缺点： Redis的缓存雪崩Redis的过期策略定时过期惰性过期定期过期 什么是热key问题，如何解决什么是热key热key是怎么产生的呢？如何识别热key如何解决热key 为什么Redis6.0之后改多线程聊聊Redis事务机制事务的执行流程 Redis的Hash冲突怎么办如何解决 Redis底层，使用的什么协议Redis的主从复制是什么主从复制如何实现主从复制的优势主从复制的缺点 哨兵机制原理哨兵机制（Sentinel）解决问题哨兵机制如何实现 Redis是什么？为什么要使用它？ Redis是key-value结构的NoSQL型数据库，由于它是存在内存中的，所以它的读写速度会很快，可以满足一些比较高频的访问。这也是我们选择使用它的原因之一。
Redis为什么这么快 基于内存实现高效的数据结构合理地数据编码合理的线程模型虚拟内存机制 Redis的存储结构有哪些？有哪些应用场景？ 字符串 String
解释：最基础的数据类型，可以存储任何形式的文本或二进制数据
应用场景：缓存、计数器、短信验证码
Hash
解释：存储键值对，类似于Java中的Map
应用场景：存储用户信息、对象
List列表
解释：相当于链表
应用场景：消息队列、任务队列
Set集合
解释：用于存储一些无序且唯一的元素集合
应用场景：用户关注列表，共同好友关注
ZSet集合
解释：有序、 不可重复，有权重参数
应用场景：排行榜
Redis分布式锁是什么？ 是一种机制，确保在分布式系统中，多个节点在同一时刻只能有一个节点对共享资源进行操作。
解决在分布式环境下并发控制和数据一致性问题的关键技术之一
秒杀下单、抢红包等等业务场景，都需要用到分布式锁，
实现方式 setnx + expire 先用setnx抢锁，如果抢到之后，再用expire给锁设置一个过期时间，防止锁忘记释放
缺点：加锁与设置过期时间是非原子操作，如果加锁后未来得及设置过期时间系统异常，会导致其他线程永远获取不到锁
setnx + value(系统过期时间 + 过期时间) 把过期时间放在setnx的value值里面，如果加锁失败，再拿出value值校验一下
优点：避免expire单独设置过期时间，把过期时间放到setnx的value值里面
缺点：
过期时间是客户端自己生成的，必须要求分布式情况下，每个客户端的时间必须同步如果锁过期的时候，并发多个客户端同时请求过来，都执行jedis.getSet()，最终只能有一个客户端加锁成功，但是该客户端的过期时间，可能被别的客户端覆盖该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁 使用lua脚本（包含setnx + expire两条指令） 将结果放在字符串里，用jedis提交
set的扩展命令（set ex px nx） NX：表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取
EX sends:设定key的过期时间，时间单位是秒
PX milliseconds:设定key的过期时间，时间单位是毫秒
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86e715d839d4cfa386d743ffe370c593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184422d5d75a9e83845ef003f7aba6f4/" rel="bookmark">
			2024年最新MacBook苹果电脑安装JDK8、JDK11教程，配置环境变量 &#43; 快速切换JDK版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本帖发布日期：2024年01月26日，全网最新教程整理。
2024年02月01日更新：环境变量新增jdk17配置代码。
2024年05月13日更新：记录解决添加maven后不能自动切换jdk版本。
2024年06月16日更新：友情提醒：如果是m芯片，推荐下载arm版本。
1、概述 本文主要为在MacBook苹果电脑系统下安装JDK及环境变量配置。
教程摘抄自互联网，本人作为更新+整理+亲测。（也算给自己记录一贴）
本帖分为四步：
在Oracle官网下载JDK安装JDk配置环境变量快速切换 JDK是Java开发工具包（Java Development Kit）。
JDK 8 版本于2014年3月18日发布。引入了一系列新功能，如Lambda表达式、函数式接口、Stream API和新的日期/时间API等。JDK 11 版本于2018年9月25日发布。提供了一些重要的改进，如模块化系统、增强的性能、新的HTTP客户端API和局部变量类型推断等。JDK 17 版本于2021年9月14日发布，是Oracle官方长期支持（LTS）版本，提供了一些性能优化、安全性改进、API 更新等方面的调整，以提高 Java 平台的稳定性和可靠性。 JavaSE、JavaEE和JavaME是Java平台的不同配置和规范。
JavaSE（Java Standard Edition）是Java平台的标准配置，提供了基本的Java编程环境和核心API，适用于通用的桌面、服务器和嵌入式应用程序开发。JavaEE（Java Enterprise Edition）是Java平台的企业级配置，提供了用于开发大型企业应用程序的扩展API和服务，包括Web应用程序开发、企业级数据库访问、消息队列和分布式计算等。JavaME（Java Micro Edition）是Java平台的微型配置，专门用于嵌入式设备和移动设备的应用程序开发，如手机、智能卡和小型传感器等。 Installer和Compressed Archive区别：
Installer下载的是一个.dmg可执行文档。
Compressed Archive压缩文档，下载的是一个.tar.gz压缩包。
另外，刚接触Mac的小伙伴你需要知道：
DMG文件通常用作Mac应用程序的安装包。是苹果电脑上常见的磁盘映像文件格式，全称为Disk Image。
2、下载JDK（官网） 2.1、官网下载dmg安装包 Java Archive | Oracle ​​​​​​Java Archive | Oracle 中国
选择需要安装的jdk版本，我需要的是JDK8版本，这里我选择Java SE 8 (8u211 and later)，点击进入下载页面。
2.2、根据对应系统选择下载安装包 我是Intel Core i9芯片，选择的是 macOS x64 DMG Installer 点击下载后面的dmg文件
这里友情提示：有时候网络延迟，可能不会立即响应下载，需要耐心等一会，或者刷新页面重复下载。
，弹出对话框 选择勾选同意协议即可。 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/184422d5d75a9e83845ef003f7aba6f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e17270b647f5e9d368dcb318ead77f7/" rel="bookmark">
			Python从0到100（三十二）：lxml模块的学习与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 掌握使用lxml库提取数据的方法。理解lxml在数据处理后提取的数据类型。学习将元素（element）转换为字符串的方法。 1. lxml的安装 通过以下命令安装lxml库：
pip install lxml 2. lxml的使用 2.1 基础使用 导入lxml的etree库：from lxml import etree 将字符串转换为Element对象，并使用xpath方法提取数据：html = etree.HTML(text) ret_list = html.xpath("xpath字符串") 将Element对象转换为字符串（bytes类型）：
etree.tostring(element) 示例 假设有以下HTML内容，我们将对其进行操作：
&lt;div&gt; &lt;ul&gt; &lt;li class="item-1"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;!-- 注意此处缺少闭合标签 --&gt; &lt;/ul&gt; &lt;/div&gt; 使用lxml进行操作的代码如下：
from lxml import etree text = """ &lt;div&gt; &lt;ul&gt; ... &lt;/ul&gt; &lt;/div&gt; """ html = etree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e17270b647f5e9d368dcb318ead77f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4279bcdf5daf31f58de8e4d8a89c81af/" rel="bookmark">
			【机器学习】人工智能与气候变化：利用深度学习与机器学习算法预测和缓解环境影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
🔥引言
1.1 背景介绍
1.2 人工智能与机器学习的崛起
1.3 本文内容概述
🔨气候变化的挑战
2.1 现今气候变化带来的影响和挑战
2.2 引发关注的气候变化趋势和数据
🤖人工智能在气候变化中的应用
3.1 深度学习和机器学习算法的基本原理
3.2 如何利用这些算法分析气候数据，预测气候变化趋势
💡机器学习在环境保护中的作用
4.1 利用机器学习算法监测环境变化
📕案例研究
5.1 气候预测
5.2 自然灾害预警
5.3 生态系统监测
5.4 能源管理
🌏未来展望
6.1 潜在发展方向
6.2 面临的挑战
🔥引言 1.1 背景介绍 全球气候变化已成为世界各国共同面对的重大挑战之一。气候变化带来的极端天气事件频发、海平面上升、生态系统退化等问题，严重影响着人类的生存和发展。因此，寻找有效的方法来预测气候变化趋势并采取相应的应对措施至关重要。
1.2 人工智能与机器学习的崛起 近年来，人工智能（AI）和机器学习（ML）等技术的快速发展为解决气候变化问题提供了新的思路和方法。AI和ML技术通过分析大量的气象数据和气候模型，能够更准确地预测未来的气候变化趋势，帮助我们更好地了解和应对气候变化的影响。
1.3 本文内容概述 本文将首先介绍AI和ML在气候变化领域的重要性和潜力，然后详细探讨如何利用深度学习和机器学习算法来预测气候变化。接着，我们将分析机器学习在环境保护中的作用，包括如何利用机器学习算法监测环境变化、优化资源利用、减少碳排放等。最后，我们将通过案例研究展示一些成功应用AI和ML的例子，探讨未来AI和ML在气候变化研究和环境保护中的发展前景。
通过本文的阐述，我们希望能够引起更多人对于利用AI和ML技术解决气候变化问题的关注，促进这一领域的研究和应用，为构建一个更加可持续的未来做出贡献。
🔨气候变化的挑战 2.1 现今气候变化带来的影响和挑战 随着全球气温持续上升，气候变化带来了一系列严重的影响和挑战。极端天气事件频发，如暴雨、干旱、飓风等，给人们的生命财产安全造成严重威胁。同时，海平面上升导致海岸线退缩，威胁着沿海城市和岛国的生存空间。气候变化还加剧了生态系统的退化，导致物种灭绝和生态平衡失调，影响着人类的粮食安全和生态环境稳定。因此，应对气候变化已成为全球各国共同面临的紧迫任务。
2.2 引发关注的气候变化趋势和数据 近年来，全球气温持续上升，极端天气事件频发，引发了人们对气候变化的关注。科学家们通过对气候数据的分析发现，气候变化已经对全球各地产生了显著影响，如极端高温事件的增多、降雨模式的改变等。这些数据表明，气候变化已经不再是遥远的未来问题，而是我们当前必须面对的现实挑战。
🤖人工智能在气候变化中的应用 3.1 深度学习和机器学习算法的基本原理 深度学习是一种机器学习技术，通过构建多层神经网络模拟人类大脑的工作原理。它可以自动学习从数据中提取特征，并进行复杂的模式识别和预测。
机器学习是一种人工智能的分支，通过让计算机从数据中学习模式和规律，从而实现任务的自动化处理。常见的机器学习算法包括支持向量机（SVM）、决策树、随机森林等。
3.2 如何利用这些算法分析气候数据，预测气候变化趋势 利用深度学习和机器学习算法分析气候数据，预测气候变化趋势的过程可以分为以下几个步骤：
数据收集和预处理：收集气象站、卫星观测等多源数据，并对数据进行清洗和预处理，包括去除异常值、填补缺失值等。
特征提取：通过特征工程提取气候数据中的特征，如温度、湿度、风速等，以及它们之间的关联性。
模型选择：根据问题的性质选择合适的深度学习或机器学习模型，如使用循环神经网络（RNN）处理时间序列数据，使用卷积神经网络（CNN）处理图像数据等。
模型训练：利用历史气候数据训练模型，并使用验证集验证模型的效果，调整超参数以提高模型的准确性和泛化能力。
模型应用：利用训练好的模型对未来的气候数据进行预测，得出气候变化的趋势和可能的影响。
下面是一个利用Python和TensorFlow实现的简单示例代码，用于利用LSTM模型预测气温变化趋势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4279bcdf5daf31f58de8e4d8a89c81af/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/262/">«</a>
	<span class="pagination__item pagination__item--current">263/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/264/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>