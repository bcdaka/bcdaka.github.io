<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c916e84581da9bf6ec0c5e020413efa5/" rel="bookmark">
			太酷了！手机上部署最新AI大模型！只需2步！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当前的AI革命中，大模型扮演着至关重要的角色，而这背后的基础便是Scaling Law。简而言之，随着数据、参数和计算能力的不断提升，大模型的能力也随之增强，展现出小规模模型所无法比拟的“涌现能力”。 越来越多的AI企业纷纷推出开源大模型，按照扩展定律实现指数级的增长，为AI领域的发展注入了新的活力和动力。
然而，另一个不可忽视的趋势是，大型模型的体积正在逐渐缩小，这为私有化部署提供了可能。这一趋势对于个人隐私保护要求较高的场景尤为重要。通过无需联网传输数据，直接在设备上运行的AI技术，我们可以增强用户的信任感。尽管云服务器上的AI可能具备更高的性能，但其安全性和可靠性却令人担忧。因此随着模型体积的减小，私有化部署将成为更加可行和受欢迎的选择。
本文介绍几个适合私有化部署的最新大模型，并提供部署指导，手把手部署到电脑及手机。
一、开源大模型 热门的大模型如ChatGPT和Bard受限于专有闭源技术，限制了其应用并模糊了技术透明度。相比之下，开源AI大型模型（LLMs）如Meta的Llama 3和微软的Phi3，不仅增强了数据安全和隐私保护，还降低了成本、减少了外部依赖，并实现了代码透明和模型定制。这些“小而美”的开源模型便于部署，预示着AI技术将更为开放、透明和灵活。
1、Llama 3 近期，Meta发布了开源Llama 3 8B和Llama 3 70B模型，Meta称它们是同体量下性能最佳的开源模型。基准测试显示，Llama 3 400B+实力与Claude和新版GPT-4 Turbo相当，在顶尖模型中占据重要地位。
模型链接：https://llama.meta.com/llama-downloads/
GitHub项目地址：https://github.com/meta-llama/llama3
2. Phi-3 Phi是微软AI研究院的新开源小型语言模型，专为商业环境设计，小巧高效。它包括Mini、Small和Medium三种规模。Phi-3-Mini虽有3.8B参数，但在关键测试中表现出色，与大型模型如Mixtral 8x7B和GPT-3.5相当。更大版本在扩展数据集下表现更佳。
Phi-3 技术报告：《一个能跑在手机上的大模型》https://arxiv.org/abs/2404.14219
小结 基准测试显示，Llama 3 8B和Phi3 3.8B小模型表现优异。在小规模参数的背后，还有相似的优化方法。由于大型模型性能的关键在于框架、数据和参数。小参数下使用MOE框架意义不大，因此这两个模型注重数据优化，提高数量和质量，这也为精简大型模型指明了方向。
二、电脑部署的流程 Ollama是部署大型语言模型的强大工具，兼容Llama 3、Mistral、Gemma等模型。部署过程简洁明了：**下载并安装Ollama，随后运行模型。
**
以Windows为例，轻松从官网或文末获取Ollama，一键安装即可。官网下载链接 https://github.com/ollama/ollama
安装好Ollama后，在命令行中输入【ollama run llama3】并运行，即可轻松下载并启动llama3大型模型（其他模型的运行命令同样适用）。初次下载模型可能需要一些时间，完成后，就可以开始与模型愉快地对话了。
Ollama还支持其他功能如，图片等多模态输入、传入提示词调教模型等，具体可以看下文档。
三、手机部署的流程 与电脑相比，手机在部署大模型方面展现出更大的意义。这是因为手机与我们的日常生活联系得更为紧密，且手机中储存着大量的个人数据，为后续交互提供了极大的便利。当前，许多人手头都有闲置的手机，如果其性能足够强大，那么运行大模型便成为了一个不错的选择。以我的旧手机小米8为例，可以应对这一需求。
要在手机上部署大模型，使用Termux+Ollama就成了。
尽管在手机上部署稍显繁琐，类似于电脑的安装配置过程，但需要搭建Linux环境。尽管安卓系统的底层建立在Linux内核之上，但重新装载Linux并非易事。然而，我偶然发现了一款名为Termux的出色工具，它能在Android设备上流畅运行众多Linux命令和应用程序。只需访问F-Droid官方网站，便能轻松下载安装Termux，为您的移动设备增添强大的Linux功能。
官网下载链接：https://github.com/termux/termux-app/releases 安装后打开Termux如下图。（如有要打开多个Linux窗口，左上角右滑点击New session就可以。）
第一步，利用Termux的proot-distro功能，可便捷安装Linux系统如Ubuntu、Debian或Arch Linux。
// 先来安装proot-distro``pkg install proot-distro`` ``//使用proot-distro安装一个debian``proot-distro install debian`` ``// 安装成功后通过login命令就直接进入debian，为发行版启动一个root shell``proot-distro login debian 第二步，同电脑的流程，安装Ollama，下载及运行大模型。
//进入之后再来安装ollama``curl -fsSL https://ollama.com/install.sh | sh`` ``// 安装完毕可以查看ollama版本进行验证，出现版本号之后就可以使用ollama``ollama -v`` `` ``// 后台开启ollama服务``nohup ollama serve &amp;`` ``//运行大模型（其他模型的命令如下图，可通过ollama list查看模型）` `ollama run phi3 第一次安装软件和大模型首次可能会花费较长时间，大约需要一小时。但安装完成后，后续使用便捷。只需运行debian系统的login、Ollama服务以及大模型，即可开始使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c916e84581da9bf6ec0c5e020413efa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2364e49998f5f11e5245bc7528202194/" rel="bookmark">
			Web前端JS通过getUserMedia API 获取 麦克风(话筒)、摄像头(相机) 等音视频多媒体数据（语音、录音、录屏、相机、视频对话、屏幕共享、流媒体）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@[TOC](🪟Web前端JS通过getUserMedia API 获取 麦克风、摄像头(相机) 音视频等多媒体数据（语音、录音、相机、视频对话、流媒体)
📊写在前面 随着人工智能的逐渐普及和广泛应用，不仅提高了设备的智能化水平，还为我们的日常生活带来了便利和新的可能，在各个应用领域中，通过多媒体设备如：麦克风、摄像头等多媒体设备，极大地丰富了我们的日常生活。而且随着技术的不断进步，未来还将在更多的领域中，如：智能家居、健康医疗、教育娱乐、交通运输 等多个领域发挥更大的作用，也将更进一步的提升我们生活和工作质量。
🏡前提条件 想要在Web浏览器（无论是PC端浏览器，还是移动端浏览器）中，获取麦克风、摄像头的音视频数据需要满以下几个基本条件：
硬件设备
麦克风：想要录音、获取音频数据，就一定要有音频采集设备 如 麦克风，而且要保证能正常使用。摄像头：想要画面、获取视频数据，就一定要有视频采集设备 如 摄像头，而且要保证能正常使用。 协议要求
由于Web安全策略为了保证安全，要求Web浏览器必须在HTTPS通信协议下，才允许使用getUserMedia API访问多媒体设备（如果是在本地开发环境 localhost 中是能正常访问的，但要在生产环境中使用必须是HTTPS才行）。 接口支持
在Web浏览器中 获取音频、视频数据一般都是调用 getUserMedia API来获取数据的。所以Web浏览器本身得支持这个API，但这点不用担心，因为到目前为止，几乎所有的Web浏览器都支持 getUserMedia API 这个接口。 用户权限
在满足以上两个必要条件以后，为了安全起见，在Web浏览器中 通过程序代码 来调用 getUserMedia API 之前还得用户的许可受权后才能调用。 🖼️API简介 在HTML5中提供了 navigator.mediaDevices.getUserMedia API为用户提供访问连接硬件设备多媒体设备，比如：麦克风（录音）、摄像头（相机 | 视频）、屏幕共享（录屏）等多媒体，可根据不同的设置轻松获取到对应的媒体数据资源，基于这个接口，Web应用程序开发者可以在不依赖任何浏览器插件的条件下访问硬件媒体设备。
在调用MediaDevices.getUserMedia() API时，首先会提示用户受权予使用媒体采集、输入的许可，媒体输入会产生一个MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等），也可能是其它轨道类型。
在用户通过提示受权允许的情况下，打开电脑上的相机、麦克风、屏幕共享等采集设备，并提供 MediaStream 包含多媒体如：视频轨道或音频轨道的输入。
MediaStream 接口是一个媒体内容的流.。一个流包含几个轨道，比如视频和音频轨道。
📚实例代码 Web前端JS通过getUserMedia API 获取 麦克风、摄像头 的音视频数据流，具体代码下如：
使用navigator.mediaDevices.enumerateDevices() API 获取当前可用的多媒体设备情况！
// 查看当前可用的媒体设备 function getMediaDevices() { try { navigator.mediaDevices.enumerateDevices().then(function (devices) { devices.forEach(function (device) { switch (device?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2364e49998f5f11e5245bc7528202194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00815f496695f6972ce3ece85c255d05/" rel="bookmark">
			【C&#43;&#43;】string类的使用③（修改器Modifiers || 非成员函数重载Non-member function overloads）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页： Forcible Bug Maker
🔥专栏： STL || C++
目录 前言🔥修改器（Modifiers）==**operator+=**====append====push_back和pop_back====assign====insert====erase====replace====swap== 🔥非成员函数重载（Non-member function overloads）==operator+====relation operators(string)====swap(string)====流插入和流提取重载====getline== 结语 前言 本篇博客主要内容：STL库中string的修改器（Modifiers）和非成员函数重载（Non-member function overloads）。
来到string类的使用第三篇，继续我们的内容，本篇博客将介绍如何使用STL库中string的成员函数修改串，以及重载给string的几个非成员函数。
🔥修改器（Modifiers） 顾名思义，就是一批能改动string串中内容的成员函数。
operator+= 这是一个成员函数的运算符重载。
简单说就是在串的末尾追加字符或字符串。
(1) string string对象
string&amp; operator+= (const string&amp; str);
(2) c-string 字符串指针
string&amp; operator+= (const char* s);
(3) character 字符
string&amp; operator+= (char c);
以上三个重载的功能用一句话概括：在当前string串的末尾追加字符或字符串。
共同的返回值：当前对象的引用（string&amp;）。
使用样例：
// string::operator+= #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string name("John"); string family("Smith"); name += "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00815f496695f6972ce3ece85c255d05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a895d8c844119eb58e174c69c56394d6/" rel="bookmark">
			【C语言】—— 动态内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C语言】——动态内存管理 一、动态内存管理概述1.1、动态内存的概念1.2、动态内存的必要性 二、 m a l l o c malloc malloc 函数2.1、函数介绍2.2、应用举例 三、 c a l l o c calloc calloc 函数四、 f r e e free free 函数4.1、函数介绍4.2、应用举例 五、 r e a l l o c realloc realloc 函数5.1、函数介绍5.2、应用举例 六、常见的动态内存错误6.1、对NULL指针进行解引用6.2、对动态开辟空间的越界访问6.3、对非动态开辟的内存使用 f r e e free free 释放6.4、使用 f r e e free free 释放一块动态开辟内存的一部分6.5、对同一块动态内存多重释放6.6、动态开辟内存忘记释放（内存泄漏） 七、动态内存经典笔试题分析7.1、题一7.2、题二7.3、题三7.4、题四 八、柔性数组8.1、什么是柔性数组8.2、柔性数组的特点8.2、柔性数组的使用8.3、柔性数组的优势 九、C/C++中内存区域划分 一、动态内存管理概述 1.1、动态内存的概念 在了解为什么要有动态内存管理之前，我们得先知道动态内存的定义。
动态内存是指动态的内存空间，意思就是：能动态开辟的内存空间，动态就是申请了这块空间后，可动态的修改这块空间的大小，根据需要，动态地释放和分配内存空间。
1.2、动态内存的必要性 为什么要有动态内存呢？
既然有动态内存，那与之相对的就是静态内存
什么是静态内存呢？其实静态内存我们天天都在用，只是不知道它是静态内存而已
下面两种内存开辟方式就是静态内存
int val = 20;//在栈空间上开辟四个字节 char arr[10] = { 0 };//在栈空间上开辟10个字节的连续空间 但是静态内存的开辟有两个缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a895d8c844119eb58e174c69c56394d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a86cf5f751d34170ebd3287d2f02c31/" rel="bookmark">
			C&#43;&#43;中的std::find_if函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++标准库中，std::find_if函数是一种强大的工具，用于在容器中查找满足特定条件的元素。它是STL（标准模板库）中的一部分，提供了一种简洁而高效的方式来搜索容器中的元素。本文将深入探讨std::find_if函数的用法、示例和一些实用技巧。
介绍 std::find_if函数位于头文件&lt;algorithm&gt;中，并接受三个参数：要搜索的容器的起始和结束迭代器以及表示要搜索的条件的谓词（predicate）。
template&lt; class InputIt, class UnaryPredicate &gt; InputIt find_if( InputIt first, InputIt last, UnaryPredicate p ); 其中：
first：容器的起始迭代器last：容器的结束迭代器p：用于检查每个元素的谓词 函数返回一个迭代器，指向第一个满足条件的元素，如果没有找到这样的元素，则返回last。
示例 假设我们有一个整数向量，我们想找到第一个大于10的元素：
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; numbers = {5, 12, 8, 15, 3, 20}; auto it = std::find_if(numbers.begin(), numbers.end(), [](int x) { return x &gt; 10; }); if (it != numbers.end()) { std::cout &lt;&lt; "第一个大于10的元素是：" &lt;&lt; *it &lt;&lt; std::endl; } else { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a86cf5f751d34170ebd3287d2f02c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124b6fdbf1cf1b1db4b09235f22cfdd2/" rel="bookmark">
			【Python单点知识】类成员汇总讲解——包含类方法、静态方法、私有成员说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 前言1. 属性（Attributes）1.1 类属性（Class Attributes）1.2 实例属性（Instance Attributes） 2. 方法（Methods）2.1 实例方法（Instance Methods）2.2 类方法（Class Methods）2.3 静态方法（Static Methods）2.4 魔术方法（Magic Methods） 3. 私有成员（Private Members）3.1 双下划线前缀 (`__`)3.2 单下划线前缀 (`_`) 0. 前言 按照国际惯例，首先声明：本文只是我自己学习的理解，虽然参考了他人的宝贵见解及成果，但是内容可能存在不准确的地方。如果发现文中错误，希望批评指正，共同进步。
本文通过实例介绍Python中的类的成员，包括各种常用和不太常用的属性、方法等。
1. 属性（Attributes） 1.1 类属性（Class Attributes） 在类级别定义的变量，所有类的实例共享同一个类变量的存储空间，修改其中一个实例的类变量会影响其他所有实例。
class MyClass: class_var = "This is a class variable" # 创建实例 instance1 = MyClass() instance2 = MyClass() print(instance1.class_var) # 输出: This is a class variable print(instance2.class_var) # 输出相同的值 # 改变类变量会影响到所有实例 MyClass.class_var = "New value" print(instance1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124b6fdbf1cf1b1db4b09235f22cfdd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3671f4427d8a524c8bb0f052c2531f/" rel="bookmark">
			链式思维提示是什么？Prompt 加上这一句就能让 AI 像你一样思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介链式思维提示的概念链式思维提示的优势链式思维提示的局限性链式思维提示与提示语链的对比总结 简介 在 AI 领域，尤其是在自然语言处理的子领域中，链式思维提示 (Chain of Thought prompting) 已经成为了一种重要的工具。它不仅提高了大型语言模型（LLM）的逻辑推理能力，而且还提升了模型在处理复杂任务时的准确性和效率。
本文将从 CoT 的概念、优势、局限性以及与提示语链的对比多个方面，并结合一些具体的案例来详细讲解链式思维提示。
链式思维提示的概念 我们在上学的时候，都做过数学题。无论是考试也好，还是日常做题也好，老师教给我们的习惯是，先写「解」字，然后分析题目，随后一步一步地推理和解答问题，最后得出答案。这个思维方式，也同样可以应用在 AI 上。
链式思维提示 (Chain of Thought prompting) 作为一种提示语工程（Prompt Engineering）技术，其核心在于通过精心构建输入提示，以模仿人类的推理过程，从而提升语言模型在处理逻辑、计算和决策任务时的性能和效率，也让模型输出的内容更直观易懂。
为了构建有效的链式思维提示，我们通常会在查询的末尾附加一条指令，比如 请描述你的推理步骤 或 请逐步解释你的答案，这样可以引导 LLM 进行深入的思考。这种方法要求 LLM 不能只是给出最终结果，还必须要详细阐述是如何形成这样的答案的，让 LLM 将中间步骤一并地回答出来。
Google Brain 研究团队有一篇论文展示了关于链式思维提示在多项算术、常识和符号推理的基准测试中，相较于标准提示技术，展现出了更优越的性能。
We explore how generating a chain of thought – a series of intermediate reasoning steps – significantly improves the ability of large language models to perform complex reasoning. In particular, we show how such reasoning abilities emerge naturally in sufficiently large language models via a simple method called chain of thought prompting, where a few chain of thought demonstrations are provided as exemplars in prompting.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e3671f4427d8a524c8bb0f052c2531f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e3c71bf9770fc37b5b997333ee7853/" rel="bookmark">
			【MySQL基础】章节4：MySQL的安装（8.4.0 LTS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		章节4：MySQL的安装（8.4.0 LTS） 【1】MySQL的版本【2】官方下载【3】安装【4】配置【5】配置环境变量 【1】MySQL的版本 近期主要历史版本有5.0/5.1/5.5/5.6/5.7，到了5.8直接改名为8.0了，目前最新版本是MySQL8。6.0曾经是个内部试验版本，已经取消了。
MySQL8.0的版本历史：
1）2016-09-12第一个DM（Development Milestone）版本8.0.0发布
2）2018-04-19第一个GA（General Availability）版本开始，8.0.11发布
…
3）本博客撰写时，最新社区版本是8.4.0 LTS
【2】官方下载 下载地址：https://dev.mysql.com/downloads/mysql/
【3】安装 1.双击
2.这一步是安装程序，选Typical则默认安装在C盘，大小大概五百多MB，如果想安装在别的盘，可以选择Custom。
【4】配置 1.next
2.Data Directory
如果点…默认只能在C盘里选择Data Directory
解决方法是把C改成D，它会自动在D盘创造文件夹
3.Type and Network
next即可
ps：MySQL默认端口号就是3306，不用改动（补充tips：Oracle默认端口号1521，Tomcat默认8080，不同的数据库管理系统有不同的默认端口号）
4.Accounts and Roles
Root Account两个都填了root（随便什么都行）
其他user不再添加
5.Windows Service
next
6.Server File Permissions
next
7.Sample Database
示例数据库，可以勾选，能够帮助初学者更好地理解和应用MySQL的各种功能和特性。我这里硬盘空间比较宽裕，就都选了（不需要的可以不选）
8.Apply Configuration
点Execute（如果有错误的话Log里会有报错，按照对应报错解决即可）
9.配置完成
【5】配置环境变量 本人操作系统是win11
1.右键桌面的“此电脑”，点击“属性”
2.点击“系统高级设置”
3.环境变量
4.
5.将C:\Program Files\MySQL\MySQL Server 8.4\bin添加到环境变量
6.确定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7f51b8702b2854be7e62ec1692a81c/" rel="bookmark">
			排查 stable-diffusion-webui 局域网访问问题：详细解析配置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排查 stable-diffusion-webui 局域网访问问题：详细解析配置步骤 引言：
在部署 stable-diffusion-webui 后，确保其在局域网内可访问是使用该工具的关键一步。如果您遇到了局域网无法访问的问题，本文将帮助您详细检查和配置 stable-diffusion-webui，以确保其在您的网络环境中正常工作。
一、理解 stable-diffusion-webui 的运行机制 stable-diffusion-webui 是一个基于 Flask 框架的 Web 应用，它允许用户通过浏览器与 stable-diffusion 模型进行交互。默认情况下，Flask 应用通常只监听本地回环地址（127.0.0.1），这意味着它只能在部署服务的同一台机器上访问。
二、检查监听地址和端口 stable-diffusion-webui 的启动脚本通常位于项目的根目录下，其完整名称可能因安装方式和操作系统不同而有所变化。以下是一些常见的完整文件名：
在 Windows 上，如果您使用的是 Anaconda 环境，启动脚本可能名为：
stable-diffusion-webui\webui.bat
在 macOS 或 Linux 上，启动脚本可能名为：
stable-diffusion-webui/launch.py
如果您在非特定环境（如直接从源代码编译）下，启动脚本可能名为：
launch.py
在某些情况下，启动脚本可能被创建为可执行文件，这时它的名称可能会有所不同，例如：
stable-diffusion-webui/webui.sh
请注意，这些文件名可能因您的具体安装环境和版本而有所不同。在启动 stable-diffusion-webui 之前，请确保您已经正确安装了所有必要的依赖项，并且您的环境变量设置正确。您可以通过在命令行中运行 which stable-diffusion-webui（在 Linux 或 macOS 上）或 where stable-diffusion-webui（在 Windows 上）来查找启动脚本的实际位置。
要使 stable-diffusi
on-webui 能够在局域网内被访问，您需要确保它监听的是正确的网络接口和端口。在 stable-diffusion-webui 的启动脚本中，通常会有一个参数来控制监听地址。例如，您可能会看到这样的参数：
parser.add_argument('--host', type=str, default='127.0.0.1', help='Host to bind to') 这个参数默认设置为 ‘127.0.0.1’，这意味着服务只监听本地连接。您需要将这个参数更改为 ‘0.0.0.0’，以使服务监听所有网络接口：
parser.add_argument('--host', type=str, default='0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a7f51b8702b2854be7e62ec1692a81c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28241c0a6e00f552b810bfee806b5363/" rel="bookmark">
			【漏洞防范与应对：从发现到修复的全攻略】Prometheus Pushgateway推送网关 存在未授权访问漏洞 ，处理过程详解！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟 欢迎来到【漏洞防范与应对：从发现到修复的全攻略】专栏！在这里，我将深入分享我的日常运维经验，特别是漏洞处理的过程与方法，同时记录每一次成功修复漏洞的历程。🛡️
🔍 运维，就像是站在网络安全的最前线。每一个新发现的漏洞，都是对我们专业能力的挑战。在本专栏中，我将引导你深入这个“战场”，共同体验从漏洞发现到彻底修复的完整旅程。
📝 我不仅会深入剖析技术细节，还会分享那些来自实战的宝贵经验。希望我的分享能让你更深入地理解漏洞处理的实际操作，并从中获得启发，提升你的运维技能。
💪 朋友们，让我们携手踏上这段探索之旅，共同捍卫网络的安全与稳定。期待在这个专栏中与你一同成长，共同见证每一次漏洞修复的成功！
文章目录 一、漏洞概述📖二、漏洞修复方法🛠️2.1 修复步骤 🔧2.2 验证修复效果 ✅ 三、经验与反思💡3.1 加密后Prometheus获取pushgateway数据也要添加账密才能获取数据 一、漏洞概述📖 漏洞名称
Prometheus Pushgateway推送网关 存在未授权访问漏洞 【原理扫描】
CVE编号
-
漏洞级别
中危
漏洞描述/危害
Prometheus Pushgateway（推送网关）是 Prometheus 监控系统的一个组件，主要用于解决一些短寿命任务（如批处理作业或临时服务）产生的指标数据无法通过 Prometheus 的传统拉取模型获取的问题。 Prometheus Pushgateway存在未授权访问漏洞，攻击者可通过该漏洞获取敏感信息，造成敏感信息泄露。
解决方案 ⚠️
建议根据官方配置身份验证： https://github.com/prometheus/pushgateway。
二、漏洞修复方法🛠️ 2.1 修复步骤 🔧 详细列出每一步的修复操作流程 📋 1、安装密码生成工具
yum -y install httpd-tools
2、生成密码
htpasswd -nBC 12 ‘’ | tr -d ‘:\n’
3、创建配置文件config.yml
注：/usr/local/pushgateway是我服务部署的路径 vi /usr/local/pushgateway/config.yml
basic_auth_users: admin: 第2步生成的token 4、配置pushgateway.service
新增–web.config.file=/usr/local/pushgateway/config.yml [Unit] Description=Pushgateway [Service] Type=simple User=root Group=root ExecStart=/usr/local/pushgateway/pushgateway \ --web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28241c0a6e00f552b810bfee806b5363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20c4ee204cefaf3debba572338630f0/" rel="bookmark">
			Android Studio连接MySQL8.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【序言】
移动平台这个课程要做一个app的课设，我打算后期增加功能改成毕设，就想要使用MySQL来作为数据库，相对于SQLlite来说，我更熟悉MySQL一点。
【遇到的问题】
一直无法连接上数据库，开始的时候查了很多资料，说是MySQL8.0版本比较高，密码验证插件是caching_sha2_password，Android Studio中的JDBC驱动可能不支持这种加密方式。（但我并不确定是否是这个原因，就是一直连不上）
我最开始用的是下面的代码（连接数据库）：
private static final String TAG="DBUtils";// 用于日志打印 private static Connection conn=null;// 定义连接变量conn //数据库连接函数 public static Connection getConnection(String dbname) {//定义connection类函数，需要返回一个connection对象，即在上面定义的conn String ip = "192.168.0.146";//ip地址，win+R，输入cmd打开控制台，输入ipconfig /all查看本机ipv4地址,最上面那个 int port = 3306;//MySQL安装时的默认端口号，无需更改 String user = "root";//打开Navicat，点击用户，如果显示root@localhost，请修改为root@%或新加一个root@%，%表示任意，任意ip地址都可以连接 String password = "123456";//密码 String url = "jdbc:mysql://172.19.221.130:3306/course_design?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true"; // "?useUnicode=true&amp;characterEncoding=UTF-8"添加中文信息时不会乱码 // 注册JDBC驱动的固定语句 try { Class.forName("com.mysql.jdbc.Driver");//这是一个目录，你可以找到这个目录点进去就懂了 Log.d(TAG, "加载JDBC驱动成功"); } catch (ClassNotFoundException e) { Log.d(TAG, "加载JDBC驱动失败"); } // 创建与mysql的连接对象conn,当然你也可以直接把上面定义的那些变量url的值直接写进去，就不用上面写一堆定义 try { conn = DriverManager.getConnection(url, user, password); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c20c4ee204cefaf3debba572338630f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352fad96faebefb6fe8b5978ee87e91c/" rel="bookmark">
			电子资源|基于SSM&#43;vue的电子资源管理系统(源码&#43;数据库&#43;文档)​
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子资源管理系统
目录
基于SSM+vue的电子资源管理系统
一、前言
二、系统设计
三、系统功能设计 1系统功能模块
2管理员功能模块
5.2.1管理员功能模块
5.2.2用户功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SSM+vue的电子资源管理系统 一、前言 随着互联网技术的高速发展，人们生活的各方面都受到互联网技术的影响。现在人们可以通过互联网技术就能实现不出家门就可以通过网络进行系统管理，交易等，而且过程简单、快捷。同样的，在人们的工作生活中，也就需要互联网技术来方便人们的日常工作生活，实现工作办公的自动化处理，实现信息化，无纸化办公。
本课题在充分研究了在Ssm框架基础上，采用B/S模式，以Java为开发语言，MyEclipse为开发工具，MySQL为数据管理平台，实现的内容主要包括首页，个人中心，用户管理，电子资源管理，资源列表管理，资源日志管理，我的收藏管理，系统管理等功能。
关键词：电子资源管理；Java；Ssm
二、系统设计 系统功能结构如图
三、系统功能设计 1系统功能模块 电子资源管理系统，在系统首页可以查看首页，电子资源，资源列表，个人中心，后台管理等内容，并进行详细操作；如图5-1所示。
图5-1系统首页界面图
用户注册，在用户注册页面通过填写用户账号，用户姓名，密码，确认密码，联系方式等信息进行注册操作，如图5-2所示。
图5-2用户注册界面图
2管理员功能模块 系统登录，用户进入系统前在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行登录操作，如图5-5所示。
图5-5系统登录界面图
5.2.1管理员功能模块 管理员登录系统后，可以对首页，个人中心，用户管理，电子资源管理，资源列表管理，资源日志管理，我的收藏管理，系统管理等功能进行相应的操作管理，如图5-6所示。
图5-6管理员功能界面图
5.2.2用户功能模块 用户登录进入电子资源管理系统可以对首页，个人中心，电子资源管理，资源列表管理，资源日志管理，我的收藏管理等功能进行相应操作，如图5-11所示。
图5-11用户功能界面图
四、数据库设计 用户注册实体图如图4-2所示：
图4-2用户注册实体图
数据库表的设计，如下表：
大学生智能消费记账系统的一些数据表。
表4-1：编目检查
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
wenjianmingcheng
varchar
200
文件名称
shujukubianma
varchar
200
数据库编码
shujukumingcheng
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/352fad96faebefb6fe8b5978ee87e91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f478fef4da71b201858fb7fed25aa3da/" rel="bookmark">
			有关Java读取Modbus协议连接PLC的示例（使用modbus4j）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关Java读取Modbus协议的Tcp/RTU示例（使用modbus4j） 我最近碰到一个项目，获取数据来方式很多，其中一种便是Modbus协议。这个协议分为Modbus-Tcp和Modbus-RTU两种，我是这么简单理解这个协议的，主要用于信息的采集与下发，而且信息的获取和下发需要对应硬件的物理地址。
下面先讲一下一些实用的知识点，看完之后说不定你就不用开发了。
Modbus-TCP
使用的是RJ45网口通讯，可以在连接网络交互设备通过ip获取Modbus-RTU
使用485串口通信，只能通过串口连接电脑， 网上也有卖集成485串口的类似交换机的东西，可以去某宝搜索一下。还可以把串口的Modbus协议转换为ModbusTCP协议，并实现双向通信，即可以获取数据，也可以下发指令。甚至可以把数据发送到消息队列中。价格也不是很贵，如果允许买一个能减轻不少工作量，甚至不用再读下去了。但是有些设备可能无法下发，买之前要问清楚。
我使用的modbus服务是下面这款西门子的PLC，开启Modbus-TCP和Modbus-RTU均需要往里面写程序才可以，这部分不是我做的所以我不做阐述。
下面直接上Modbus-TCP和ModbusRTU的数据获取与下发代码，如果有用请点赞哦！
modubus4j Github地址 https://github.com/MangoAutomation/modbus4j
Modbus-TCP Maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.infiniteautomation&lt;/groupId&gt; &lt;artifactId&gt;modbus4j&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; Java代码 import com.serotonin.modbus4j.ModbusFactory; import com.serotonin.modbus4j.ModbusMaster; import com.serotonin.modbus4j.code.DataType; import com.serotonin.modbus4j.exception.ErrorResponseException; import com.serotonin.modbus4j.exception.ModbusInitException; import com.serotonin.modbus4j.exception.ModbusTransportException; import com.serotonin.modbus4j.ip.IpParameters; import com.serotonin.modbus4j.locator.BaseLocator; import com.serotonin.modbus4j.locator.StringLocator; import com.serotonin.modbus4j.msg.*; public static void main(String[] args) throws ModbusInitException, ModbusTransportException, ErrorResponseException { IpParameters ipParameters = new IpParameters(); ipParameters.setHost("192.168.2.1"); // Modbus-Tcp所在Ip地址 ipParameters.setPort(502); // 502为默认端口 ModbusFactory modbusFactory = new ModbusFactory(); ModbusMaster modbusMaster = modbusFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f478fef4da71b201858fb7fed25aa3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bdb5995aedf715ffd35f9a46180f20e/" rel="bookmark">
			AI大模型系列之三：Swin Transformer 最强CV图解（深度好文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SwinTransformer之CV模型详解
第一代CV大模型：Vision Transformer
第二代CV大模型：Swin Transformer
两代模型PK(VIT和Swin Transformer)
Swin Transformer是什么CV模型？
Swin Transformer应用场景是什么？
Swin Transformer到底解决了什么问题？
Swin Transformer网络架构
Patch Embbeding介绍
window_partition介绍
W-MSA（Window Multi-head Self Attention）
Window_reverse
SW-MSA（Shifted Window Multi-head Self Attention）
模型参数
核心代码讲解
SwinTransformer视觉大模型详解 第一代CV大模型：Vision Transformer 温馨提示：如果您不了解Transformer的黑科技，请补一下原理：AI大模型的知识科普（深入浅出讲原理）-CSDN博客
一、Vision Transformer如何工作？
Transformer模型最开始是用于自然语言处理(NLP)领域的，NLP主要处理的是文本、句子、段落等，即序列数据。但是视觉领域处理的是图像数据，因此将Transformer模型应用到CV领域（图像数据处理）上面临着诸多挑战，分析如下：
1. 与单词、句子、段落等文本数据不同，图像中包含更多的信息，并且是以像素值的形式呈现。
2. 如果按照处理文本的方式来处理图像，即逐像素处理的话，即使是目前的硬件条件也很难。
3. Transformer缺少CNN的归纳偏差，比如平移不变性和局部受限感受野。
4. CNN是通过相似的卷积操作来提取特征，随着模型层数的加深，感受野也会逐步增加。但是由于Transformer的本质，其在计算量上会比CNN更大。
5. Transformer无法直接用于处理基于网格的数据，比如图像数据。
总结一下，Transformer与卷积神经网络(CNN)有许多不同之处，其主要优势包括：
1. 更好的处理序列数据能力：Transformer架构在序列数据建模方面表现非常出色，它通过自注意力机制对序列中的不同位置进行加权处理，从而实现了更好的序列建模能力。相比之下，CNN对于序列建模的能力较弱，主要用于图像等非序列数据的处理。
2. 并行计算能力：Transformer中的自注意力机制允许每个时间步进行并行计算，因此Transformer的训练速度相对于CNN要更快。相比之下，CNN需要在每个时间步上执行串行卷积操作，这使得CNN在处理较长的序列时计算效率较低。
3. 更好的处理长距离依赖关系的能力：Transformer中的自注意力机制允许模型从序列中任意位置获取信息，这使得Transformer能够更好地处理长距离依赖关系，而CNN则需要通过增加卷积层数来处理这种长距离依赖。
4. 更容易扩展到其他任务：由于Transformer在序列建模方面表现优异，它在许多NLP任务中表现出色，如机器翻译、语言模型等。相比之下，CNN主要用于计算机视觉领域，如图像分类、目标检测等。因此，Transformer更容易扩展到处理其他NLP任务，而CNN则需要进行更多的改进才能适用于NLP任务。
CNN的在处理VC大模型遇到了困境的原因分析：卷积进行中，越来越多的网络结构，必须堆叠多层卷积，逐层对特征图进行处理中，感受野才不断增大，慢慢才有了全局的信息提取；从小规模数据开始，进行模型训练。
Transfomer网络处理VC的大模型优势表现突出，是因为从第一层开始，就全局计算序列中各个向量的关联权重。但是需要足够多的数据，全局学习需要非常大量的数据才能表现卓越，这是所有论文中模型的测试效果好的前提条件。预训练模型开始，对其微调就可以适合个性化场景。
总之，Transformer和CNN在不同的任务中表现出色，但在处理序列数据方面，Transformer具有更好的建模能力和计算效率，可以处理更长的序列，更容易扩展到其他NLP任务。
二、Vision Transformer是第一代CV大模型
为了解决上述问题，Google的研究团队提出了ViT模型。ViT是谷歌提出的把Transformer应用到图像分类的模型，虽然不是第一篇将transformer应用在视觉任务的论文，但是因为其模型“简单”且效果好，可扩展性强（模型越大效果越好），成为了transformer在CV领域应用的里程碑著作。
ViT原论文中最核心的结论是，当拥有足够多的数据进行预训练的时候，ViT的表现就会超过CNN，突破transformer缺少归纳偏置的限制，可以在下游任务中获得较好的迁移效果。但是当训练数据集不够大的时候，ViT的表现通常比同等大小的ResNets要差一些，因为Transformer和CNN相比缺少归纳偏置（inductive bias），即一种先验知识，提前做好的假设。CNN具有两种归纳偏置，一种是局部性，即图片上相邻区域具有相似的特征，一种是平移不变性，CNN具有上面两种归纳偏置，就有了很多先验信息，需要相对少的数据就可以学习到一个比较好的模型。
对比CNN，ViT表现出更强的性能，这是由于以下几个原因：
1. 全局视野和长距离依赖：ViT引入了Transform模型的注意力机制，可以对整个图像的全局信息进行建模。相比之下，CNN在处理图像时使用局部感受野，只能捕捉图像的局部特征。ViT通过自注意力层可以建立全局关系，并学习图像中不同区域之间的长距离依赖关系，从而更好地理解图像的结构和语义。
2. 可学习的位置编码：ViT通过对输入图像块进行位置编码，将位置信息引入模型中。这使得ViT可以处理不同位置的图像块，并学习它们之间的位置关系。相比之下，CNN在卷积和池化过程中会导致空间信息的丢失，对位置不敏感。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bdb5995aedf715ffd35f9a46180f20e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653641bfc0015e477efd43568603b8f0/" rel="bookmark">
			前端怎么用 EventSource? EventSource怎么配置请求头及加参数？ EventSourcePolyfill使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EventSource EventSource 接口是 web 内容与服务器发送事件通信的接口。
一个 EventSource 实例会对 HTTP 服务器开启一个持久化的连接，以 text/event-stream 格式发送事件，此连接会一直保持开启直到通过调用 EventSource.close() 关闭。
EventSource 服务器发送事件是单向的。数据消息只能从服务端发送到客户端。
如果想了解更多请查看 EventSource 文档
EventSource使用方式 这里其实和webSocket 使用方式其实很像
这里需要注意 我在网上查了说参数可以配置headers(请求头) 实际使用的时候我这边传入请求头是没有生效（可能是我操作有误吧）
首先先安装EventSource npm install eventsource 示例代码
//创建一个新的 EventSource 对象的同时，你可以指定一个接受事件的 URI // 如果需要加参数的话是在url 后面拼接参数 sysm/user/1 const eventSource = new EventSource('url') //与事件源的连接刚打开时触发 eventSource.onopen = function (e) { console.log(e, "连接刚打开时触发"); }; /* * message：后端返回信息，格式可以和后端协商 */ eventSource.onmessage = function (e) { console.log(e,'后端返回信息，格式可以和后端协商'); }; /* * error：错误（可能是断开，可能是后端返回的信息） */ eventSource.onerror = function (e) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653641bfc0015e477efd43568603b8f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e77ebec2d7a24153873e8279bbfdebf/" rel="bookmark">
			[开源] 基于RF（随机森林）算法的时间序列预测模型python代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理了基于RF（随机森林）算法的时间序列预测模型python代码，免费分享给大家，记得点赞哦
预测指标如下：
RMSE为：0.066 MAE为：0.050 R2为：0.804 #!/usr/bin/env python # coding: utf-8 import numpy as np import matplotlib.pyplot as plt import pandas as pd from sklearn import preprocessing from math import sqrt from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_squared_error,mean_absolute_error,r2_score import math from numpy import concatenate feanum=1 window=5 Ra = 0.8 df1=pd.read_csv('shao - 单.csv', usecols=[1]) #读取数据 train_d, test_d = df1[0:int(len(df1)*Ra)], df1[int(len(df1)*Ra):] min_max_scaler = preprocessing.MinMaxScaler() df0=min_max_scaler.fit_transform(df1) df = pd.DataFrame(df0, columns=df1.columns) stock=df seq_len=window amount_of_features = len(stock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e77ebec2d7a24153873e8279bbfdebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11143301e83b4adb79fa71d2da90999c/" rel="bookmark">
			锂电池算法学习集合---基于matlab/simulink的电池参数辨识、充放电、SOC估计算法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理了锂电池的多种算法合集：涵盖电动汽车Simulink模型、电动汽车动力电池SOC估算模型、动力电池及电池管理系统BMS。
电动汽车动力电池SOC估算模型含有:电池参数辨识模型、电池的充放电数据、电池手册、卡尔曼滤波电池SOC文献、卡尔曼滤波算法的锂电池SOC估算模型。
电池参数辨识模型有10种:带遗忘因子最小二乘法电池参数辨识方法、递推最小二乘法参数辨识方法、电池测试辨识参数模型、二阶RC参数辨识方法、二阶RC参数辨识模型、二阶RC电池辨识参数模型、卡尔曼滤波参数电池参数辨识模型、无迹卡尔曼滤波参数辨识方法、遗传算法电池参数辨识、最小二乘法参数辨识方法。
电池充放电数据：15Ah锂电池充放电数据、24Ah锂电池充放电数据、26Ah磷酸铁锂电池充放电数据、27Ah锂电池充放电数据、18650锂电池充放电数据、DST工况放电数据、FUDS工况放电数据、NASA锂电池试验数据、UDDS工况放电数据、电池充放电数据、钴酸锂电池充放电数据、恒流放电数据、间隔恒流放电数据、磷酸铁锂电池充放电数据。
多种电池手册文件、多种卡尔曼滤波电池SOC文献。
14种卡尔曼滤波算法的锂电池SOC估算模型：改进扩展卡尔曼滤波算法估算SOC模型、基于卡尔曼滤波法电池参数辨识、基于无迹卡尔曼滤波的SOC估算、基于最小二乘法辨识卡尔曼滤波估算SOC模型、卡尔曼滤波估算SOC模型、扩展卡尔曼滤波估算SOC代码、扩展卡尔曼滤波估算SOC代码1、扩展卡尔曼滤波估算SOC模型、扩展卡尔曼滤波估算SOC模型1、扩展卡尔曼滤波估算SOC模型2、锂电池RC及PNGV模型、无迹卡尔曼滤波估算SOC模型及代码、系统自带锂电池模型、自适应卡尔曼滤波估算SOC模型。
电动汽车的Simulink模型包括：插电式混合动力汽车Simulnk模型、纯电动汽车Simulink模型、混合动力汽车SImulink模型、燃料电池电动汽车Simulink模型。
获取链接：锂电池算法学习集合---基于matlab/simulink
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15d520795760062ad957a2800d4fb8a/" rel="bookmark">
			2023年11月3日《广东省人民政府关于加快建设通用人工智能产业创新引领地的实施意见》发布，以下不属于其主要特色的是()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年11月3日《广东省人民政府关于加快建设通用人工智能产业创新引领地的实施意见》发布，以下不属于其主要特色的是()
点击查看答案广东公需答案查看
A.加强关键算法技术研究B.体系化布局政策C.突出粤港澳协调发展D.夯实自主算力底座基础
广东省至今共建成了三批()家重点实验室。 A.5B.10C.15D.20
推动人工智能发展的“三驾马车”是?
A.模型、训练、方法B.训练、推断、信息C.算法、算力、数据D.理论、技术、应用
加快发展新一代人工智能的重要性和紧迫性体现在()
A.新一代人工智能是引领这一轮科技革命和产业变革的战略性技术B.新一代人工智能是赢得全球科技竞争主动权的重要战略抓手C.新一代人工智能是推动我国科技跨越发展、产业优化升级、生产力整体跃升的重要战略资源D.新一代人工智能是研究使用计算机来模拟人的某些思维过程和智能行为的新兴学
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43825f31efd7781eeebb3615d59eea38/" rel="bookmark">
			大文件传输的好帮手Libarchive：功能强大的开源归档文件处理库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化时代，文件的存储和传输对于企业的日常运作至关重要。但是，服务器中的压缩文件往往无法直接查看或预览，这给用户带来了不便。为了解决这一问题，在线解压功能的开发变得尤为重要。接下来，小编将介绍一个能够实现在线解压功能的开源库——Libarchive。
什么是Libarchive？ Libarchive是一个开源的C语言库，它专门设计用于处理多种类型的归档文件。它支持的格式非常广泛，包括但不限于tar、zip、7zip以及ISO映像等。Libarchive的功能十分全面，它不仅能够读取和写入归档文件，还具备解压缩、压缩、加密和签名文件的能力。
此外，Libarchive的跨平台特性使其能够在包括Windows、Linux和Mac在内的多种操作系统上运行。得益于其高效的内部IO模型，Libarchive在处理大型归档文件时也能保持出色的性能。
如何编译Libarchive？ 要获取Libarchive的源代码，可以访问其在GitHub上的仓库（https://github.com/libarchive/libarchive）。在项目中，阅读Read.md文档可以了解到编译过程支持CMakeLists.txt文件。
使用CMAKE GUI工具，可以将CMakeLists.txt配置为Visual Studio工程。在这个过程中，可能需要配置一些依赖项，包括：
压缩算法依赖库：LZ4、LZO、LZMA、Zstandard、Bzip2
加密依赖库：Mbed TLS、GNU Nettle、OpenSSL
根据项目的具体需求，可以添加相应的依赖库。例如，如果需要支持zip格式，则添加ZLIB库；如果需要7zip格式，则添加LZMA库。另外，也可以在编译依赖库时使用make install命令进行安装，这样在CMAKE配置过程中就可以自动找到对应的库。
生成Visual Studio工程后，可以直接编译生成动态链接库(DLL)和静态链接库(.lib)。如果需要进行静态链接，可以在archive.h头文件中添加宏定义LZMA_API_STATIC。对于需要在Windows 8以下版本环境中运行的情况，需要在config.h文件中将_WIN32_WINNT和WINVER设置为相应的低版本值。
Libarchive的代码集成 在使用Libarchive时，需要使用到struct archive和struct archive_entry这两个基础类型的对象。struct archive代表原始压缩文件的实例，而struct archive_entry则代表压缩文件中的单个文件实例。在libarchive中的大致调用流程如下：
调用archive_xxx_new函数创建一个archive对象。
使用support或set函数对archive对象进行属性设置，并判断是否支持解压的格式。
调用open函数打开压缩文件。
循环读取archive内容：获取新的archive_entry，从archive_entry中提取压缩文件的数据。
在结束时，使用close和free函数释放archive对象。
注意事项 在使用Libarchive进行文件解压时，可能会遇到文件名获取为空或者出现乱码的问题。解决这个问题的方法是调用setlocale(LC_CTYPE,"")函数，以确保文件名正确显示。
通过上述介绍，我们可以看到Libarchive是一个功能强大且灵活的开源库，它为处理归档文件提供了极大的便利。无论是在开发过程中需要读取归档文件，还是为用户提供在线解压服务，Libarchive都是一个值得考虑的选择。
总结 镭速（私有化部署方案，也可接入公有云，企业、社会组织用户可申请免费试用）通过集成Libarchive，在Windows、Linux等多个平台上实现了在线解压功能，为企业提供了一个强大且安全的大文件传输系统在线解压解决方案。这不仅满足了企业在多样化场景下的数据处理需求，还为企业的长期发展提供了坚实的技术支持。在下一篇文章中，我们将进一步探讨镭速是如何利用Libarchive实现高效、智能的文件传输和管理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8c93409221424d29eb45a443985545a/" rel="bookmark">
			【记录】LangChain｜Ollama结合LangChain使用的速通版（包含代码以及切换各种模型的方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方教程非常长，我看了很认可，但是看完了之后呢就需要一些整理得当的笔记让我自己能更快地找到需求。所以有了这篇文章。【写给自己看的，里面半句废话的解释都没有，如果看不懂的话直接看官方教程再看我的】
ollama是个平台，里面一大堆开源模型，llama是ollama平台上的某个开源模型的名字。个人把llama理解成ollama平台抛砖引玉的砖。
我是不打算一开始就用OpenAI的，打算先用一下开源模型。之后我还会写一篇OpenAI的速通版。
文章目录 前置准备用Prompt模板增加context：自定义文档内容增加context：从网页中获取文档内容增加context：从PDF中获取文档内容用文档检索器 （RAG方法） 增加chat_history：利用MessagesPlaceholder切换LLM model后话 前置准备 pip install langchain curl -fsSL https://ollama.com/install.sh | sh # linux装llama2的指令 # 如果用的是Windows或者MacOS，前往这里下载：https://ollama.com/ 用Prompt模板 from langchain_community.llms import Ollama from langchain_core.prompts import ChatPromptTemplate from langchain_core.output_parsers import StrOutputParser output_parser = StrOutputParser() llm = Ollama(model="llama2") prompt = ChatPromptTemplate.from_messages([ ("system", "You are world class technical documentation writer."), ("user", "{input}") ]) chain = prompt | llm | output_parser print(chain.invoke({"input": "how can langsmith help with testing?"})) 增加context：自定义文档内容 from langchain_community.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8c93409221424d29eb45a443985545a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/369/">«</a>
	<span class="pagination__item pagination__item--current">370/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/371/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>