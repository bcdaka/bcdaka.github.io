<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a323c0d1333b90190a48150e3b2943b5/" rel="bookmark">
			Spark&#43;Kafka构建实时分析Dashboard案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境准备
Ubuntu安装
Hadoop安装
Spark安装
Kafka安装
Python安装
Python依赖库安装
vscode安装
Python工程目录结构
二、数据处理和Python操作Kafka
数据集
数据预处理
运行
三、 Structured Streaming实时处理数据
建立pyspark项目
运行
四、结果展示
环境准备
app.py文件源码
index.html文件源码
效果展示
五、补充说明
案例来自林子雨老师的团队案例网站
一、环境准备 Ubuntu: 22.10
Hadoop: 3.1.3
Spark: 3.3.1
Scala: 2.12.15
Kafka: 3.4.0
Python: 3.10.7
Flask: 2.3.2
Flask-SocketIO: 5.3.4
Kafka-python： 2.0.2
pyspark：3.4.0
Ubuntu安装 VMware官方下载地址 Ubuntu安装教程
Hadoop安装 apache软件下载地址 Hadoop安装教程
PS：在Apache软件下载地址里选择文件夹 hadoop -&gt; common -&gt; 所需版本 -&gt; 选择后缀仅有.tar.gz的文件
Spark安装 Spark官方下载地址 Spark安装教程
PS：在Spark官方下载地址选择所需版本后在Choose a package type选择栏里选择Pre-built with user-provided Apache Hadoop之后再点击下方链接下载即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a323c0d1333b90190a48150e3b2943b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca35625074cfbca3f8eb52c6ce72f7f/" rel="bookmark">
			使用Anomalib项目的padim无监督算法 进行自制工业缺陷数据集的模型训练和ONNX部署（一）——模型训练篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言 一、无监督学习缺陷检测 Anomalib介绍
二、Anomalib代码结构
三、任务描述和模型训练推理
四、总结与展望
前言 本文专注于padim算法在自制数据集上的训练过程，博主水平有限，对神经网络模型秉持能用就行的态度，所以文中不涉及网络结构和论文细节的解读，想看这些的同学请另寻资料哈~
一、无监督学习缺陷检测 Anomalib介绍 组里最近给的新任务，对金属材质表面的各种缺陷进行检测。之前使用的是有监督的yolov5网络，标数据集着实痛苦无比。而且工业缺陷数据有一个比较显著的特征：样本不平衡。绝大部分采集得到的工业数据都是没有缺陷的，这样一来，正样本的数据在模型训练中根本没有起到作用，负样本又太少，很难训练得到有效的模型。使用有监督学习的方法还有一个问题：负样本的出现是十分偶然的，可能在数据集中根本没有出现某一类型的负样本，如此训练得到的模型很有可能翻车，所以只能另寻他法。
查阅资料，发现无监督的算法更适合工业缺陷检测的场景。无监督算法只使用正样本进行训练，网络经过大量的正样本学习，在遇到负样本时，就会知道负样本和正样本“长得不一样”，然后输出和原图尺寸相同的一张概率分布图，来表示某处是异常区域的概率大小。
无监督学习方法虽好，但作为伸手党应该去哪里要代码呢？个人感觉最好的地方就是Anomalib，它使用Python实现，资料完备易懂，目前仍然在更新。链接如下：GitHub - openvinotoolkit/anomalib: An anomaly detection library comprising state-of-the-art algorithms and features such as experiment management, hyper-parameter optimization, and edge inference.https://github.com/openvinotoolkit/anomalib
看到英文名字就可以知道：这是一个异常检测（Abnormal）的库（library），里面的内容的确十分丰富，集成了十余种近年来准确率较高的缺陷（异常）检测算法，基本都是无监督学习的方法，诸如padim算法、fastflow算法等。
找到这个宝库，我们下一步需要探索它的代码结构和用法。
二、Anomalib代码结构 我在本地使用Pycharm编程，新建项目后Anomalib的代码结构如下：
若想理清楚该项目的代码结构，方便后面的训练和部署，需要一点点进行分析。其中，比较重要的几个部分是：
1. anomalib文件夹：事实上本文件夹就是该团队发布的库的源码，我们同样可以通过pip install的方法来进行安装，
1.1 该文件夹下的models子文件夹包含了十余种缺陷检测的算法，可供读者任意调用；
1.2 pre_processing和post_processing子文件夹分别是预处理和后处理功能，最终显示推理结果就使用了post_processing下的visualizer。
1.3 deploy文件夹中的inferencers则是各种推理器，想要使用pytorch的读者可以关注torch_inferencer，想要使用onnx推理的读者则应该使用openvino_inferencer。
2. datasets文件夹：顾名思义，该文件夹中应该存放待训练的数据集，如工业数据集MVTec，或者我们自制的数据集。
3. results文件夹：该文件夹存放的是训练和推理的结果，只有在完成了训练或推理任务后才会出现。
4. tools文件夹：该文件夹中的inference子文件夹存放了一系列推理代码，它们分别调用了anomalib.deploy中的不同inferencer（推理器）。该文件夹下的train.py是训练模型的入口。
总结：我们后面需要使用tools/train.py进行模型训练，使用tools/inference中的某个推理代码进行模型推理预测。有了以上预备知识，我们终于可以开始模型的训练了。
三、任务描述和模型训练推理 若读者只想在pycharm中看一个算法的效果，那么按照官方的示例，使用train.py训练后再使用lightning_inference.py进行推理即可，在新出现的result文件夹中便可以看到推理结果，十分方便，此处不予赘述。
但对于包括我在内，后续需要在其他平台部署的读者，我们需要训练自己的数据集并得到onnx模型，这样就需要对config.yaml文件进行修改，方法如下：
首先依然按照官方的方案，看Readme中训练Custom Dataset的方法：
这里我们使用的是padim算法，于是我们将anomalib/models/padim/config.yaml的dataset部分按以上部分修改后在终端运行以下训练命令：
python tools/train.py --model padim --config anomalib/models/padim/config.yaml 但会报错：找不到“normalization”等属性，此时不要着急，之前的config.yaml中实际上这些属性都是在的，这里官方竟然没有写进来，可能是疏忽了，我把自己的config.yaml的datasets部分放在这里，读者可以按照自己的自制数据集的路径进行改写，需要添加和注意的地方我都做了注释：
dataset: name: tube # 数据集的名字，如MVTec等，这个不重要 format: folder path: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca35625074cfbca3f8eb52c6ce72f7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03cf9ba5f98a5d3c5b7b76a0185606d8/" rel="bookmark">
			数据库课程设计——订餐系统（PowerBuilder&#43;SQL Sever）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、选题介绍
本系统要求学生对订餐系统进行设计，包括用户组设置（如餐厅管理员、顾客），订单管理（如增删改查）等功能，在此基础上对数据库进行设计，要求：符合数据库设计标准，减少冗余度
二、需求分析
（思维导图与系统功能图略，可根据以下文字自行绘制）
系统主要包含以下功能：
1. 用户管理：通过用户类型（餐厅管理员或顾客）实现不同权限的设置；用户可以登录系统，使用用户名和密码进行身份验证。
2. 餐厅管理：餐厅管理员可以创建与修改餐厅，提供餐厅名称和地址。
3. 菜单管理：餐厅管理员可以为餐厅添加、修改或删除菜单项，包括菜名、价格和描述。
4. 订单管理：用户可以浏览餐厅的菜单，并输入相应菜品信息下订单；餐厅管理员可以查看餐厅的订单。
5. 订单详情：订单详情将记录每个订单中的菜品信息，包括菜单ID和数量。
三、数据库设计
（一）E-R图（略，可根据以下文字自行绘制）
餐厅和用户之间的关系是多对多关系，一个餐厅可以有多个用户，一个用户可以选择多个餐厅。
用户和订单之间的关系为一对多关系，一个用户可以创建多个订单，而每个订单只属于一个用户。
订单和订单详情之间的关系是一对多关系，一个订单可以有多个订单详情，每个订单详情只属于一个订单。
菜单与订单详情之间的关系是多对多关系，一个订单详情可以对应一个或多个菜单项，而一个菜单项可以出现在多个订单详情中：一个订单可能包含多个菜品，每个菜品对应一个订单详情，而一个菜品可以在多个订单中出现。
餐厅与菜单之间的关系是一对多关系，一个餐厅可以有多个菜单，但每个菜单只属于一个餐厅。
（二）关系模型：
用户（用户ID，用户名，密码，用户类型）
餐厅（餐厅ID，餐厅名称，餐厅地址，餐厅管理员ID）
菜单(菜单ID，餐厅ID，菜名，价格，描述)
订单(订单ID，用户ID，订单日期，总价，状态)
订单详情（订单详情ID，订单ID，菜单ID，数量）
（三）表设计：
设计了五张表，分别是用户表，餐厅表，菜单表，订单表与订单详情表。
用户表（UUser）中包含了用户ID（UserID），用户名（Username），密码（Password），用户类型（UserType）：餐厅管理员或顾客，其中用户ID为主键。
用户表（UUser）
列名
数据类型
是否允许为空
描述
UserID
int
false
用户ID
Username
varchar(50)
true
用户名
Password
varchar(50)
true
密码
UserType
varchar(20)
true
用户类型
餐厅表（Restaurant）中包含了餐厅ID（RestaurantID），餐厅名称（RestaurantName），餐厅地址（RestaurantAddress），餐厅管理员ID（AdminID），其中餐厅管理员ID为外键，关联用户表中的用户ID。
餐厅表（Restaurant）
列名
数据类型
是否允许为空
描述
RestaurantID
int
false
餐厅ID
Restaurantname
varchar(50)
true
餐厅名称
RestaurantAddress
varchar(100)
true
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03cf9ba5f98a5d3c5b7b76a0185606d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3b812939c13b75177dc6123eaaea2e/" rel="bookmark">
			【大数据实验一 】熟悉常用的Linux操作和Hadoop操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据实验一 熟悉常用的Linux操作和Hadoop操作 1.实验目的
Hadoop运行在Linux系统上，因此，需要学习实践一些常用的Linux命令。本实验旨在熟悉常用的Linux操作和Hadoop操作，为顺利开展后续其他实验奠定基础。
2.实验平台
（1）操作系统：Linux（Ubuntu18.04）；
（2）Hadoop版本：3.1.3。
3.实验步骤
1.熟悉常用的Linux操作
1）cd命令：切换目录
（1）切换到目录“/usr/local”
（2）切换到当前目录的上一级目录
（3）切换到当前登录Linux系统的用户的自己的主文件夹
2）ls命令：查看文件与目录
查看目录“/usr”下的所有文件和目录
3）mkdir命令：新建目录
（1）进入“/tmp”目录，创建一个名为“a”的目录，并查看“/tmp”目录下已经存在哪些目录
（2）进入“/tmp”目录，创建目录“a1/a2/a3/a4”
4）rmdir命令：删除空的目录
（1）将上面创建的目录a（在“/tmp”目录下面）删除
（2）删除上面创建的目录“a1/a2/a3/a4” （在“/tmp”目录下面），然后查看“/tmp”目录下面存在哪些目录
5）cp命令：复制文件或目录
（1）将当前用户的主文件夹下的文件.bashrc复制到目录“/usr”下，并重命名为bashrc1
（2）在目录“/tmp”下新建目录test，再把这个目录复制到“/usr”目录下
6）mv命令：移动文件与目录，或更名
（1）将“/usr”目录下的文件bashrc1移动到“/usr/test”目录下
（2）将“/usr”目录下的test目录重命名为test2
7）rm命令：移除文件或目录
（1）将“/usr/test2”目录下的bashrc1文件删除
（2）将“/usr”目录下的test2目录删除
8）cat命令：查看文件内容
查看当前用户主文件夹下的.bashrc文件内容
9）tac命令：反向查看文件内容
反向查看当前用户主文件夹下的.bashrc文件的内容
10）more命令：一页一页翻动查看
翻页查看当前用户主文件夹下的.bashrc文件的内容
11）head命令：取出前面几行
（1）查看当前用户主文件夹下.bashrc文件内容前20行
（2）查看当前用户主文件夹下.bashrc文件内容，后面50行不显示，只显示前面几行
12）tail命令：取出后面几行
（1）查看当前用户主文件夹下.bashrc文件内容最后20行
（2）查看当前用户主文件夹下.bashrc文件内容，并且只列出50行以后的数据
13）touch命令：修改文件时间或创建新文件
（1）在“/tmp”目录下创建一个空文件hello，并查看文件时间
（2）修改hello文件，将文件时间整为5天前
14）chown命令：修改文件所有者权限
将hello文件所有者改为root帐号，并查看属性
15）find命令：文件查找
找出主文件夹下文件名为.bashrc的文件
16）tar命令：压缩命令
（1）在根目录“/”下新建文件夹test，然后在根目录“/”下打包成test.tar.gz
（2）把上面的test.tar.gz压缩包，解压缩到“/tmp”目录
17）grep命令：查找字符串
从“～/.bashrc”文件中查找字符串’examples’
18）配置环境变量
（1）请在“～/.bashrc”中设置，配置Java环境变量
（2）查看JAVA_HOME变量的值
2.熟悉常用的Hadoop操作
（1）使用hadoop用户登录Linux系统，启动Hadoop（Hadoop的安装目录为“/usr/local/hadoop”），为hadoop用户在HDFS中创建用户目录“/user/hadoop”
出现问题。
按照以上命令行解决问题。
（2）接着在HDFS的目录“/user/hadoop”下，创建test文件夹，并查看文件列表
(3) 将Linux系统本地的“～/.bashrc”文件上传到HDFS的test文件夹中，并查看test
（4）将HDFS文件夹test复制到Linux系统本地文件系统的“/usr/local/hadoop”目录下
4.实验出现的问题与解决
出现的问题：使用hadoop用户登录Linux系统，启动Hadoop时出现拒绝连接。
解决方案（列出遇到的问题和解决办法，列出没有解决的问题）：重启jsp。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3cab32efa07b4c4f1b5cd9ae99590d0/" rel="bookmark">
			C&#43;&#43;图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计一个图书信息管理系统，实现以下功能：系统以菜单方式工作，图书信息录入功能(图书信息用文件保存) ；图书信息包括：登录号、书名、作者名、分类号、出版单位、出版时间、价格等；图书信息浏览功能（输出所有图书信息）；查询和排序功能：按书名查询（显示所有同名的书），按作者名查询（显示所有该作者的书）； 图书信息的删除与修改。
以下是完整代码，仅供大家参考：
#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; // 定义图书信息类 class BookInfo { public: int ID; // 登录号 string name; // 书名 string author; // 作者名 int category; // 分类号 string publisher; // 出版单位 string publishDate; // 出版时间 double price; // 价格 // 构造函数 BookInfo(int id, string n, string a, int c, string p, string pd, double pr) { ID = id; name = n; author = a; category = c; publisher = p; publishDate = pd; price = pr; } // 打印图书信息 void print() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3cab32efa07b4c4f1b5cd9ae99590d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef68eac8fa987a8e47a3fb4fc695134/" rel="bookmark">
			【C&#43;&#43;】哈希表封装unordered系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、哈希表的封装总结 前言 在看本篇文章前大家尽量拿出上一篇文章的代码跟着一步步实现，否则很容易引出大量模板错误而无法解决。
一、哈希表的封装
首先我们要解决映射的问题，我们目前的代码只能映射整形，那么如何支撑浮点数等的映射呢？只需要多加一个模板参数就可以了：
template &lt;class K, class V&gt; struct HashNode { HashNode&lt;K, V&gt;* _next; pair&lt;K, V&gt; _kv; HashNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) , _next(nullptr) { } }; template&lt;class K&gt; struct HashFunc { size_t operator()(const K&amp; key) { return key; } }; template &lt;class K, class V, class Hash&gt; class HashTable { typedef HashNode&lt;K, V&gt; Node; 这个仿函数可以将任何支持隐式类型转换的key转换为size_t类型，比如double类型会被隐式转换为size_t类型，那么字符串该如何解决呢？我们直接用模板特化来解决：（模板的特化就是有特化就走特化，没有特化就走原类型）
template &lt;&gt; struct HashFunc&lt;string&gt; { size_t operator()(const string&amp; s) { size_t hashi = 0; for (auto&amp; e : s) { hashi += e; } return hashi; } }; 然后我们给Hash这个模板参数一个缺省参数，默认使用我们的仿函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ef68eac8fa987a8e47a3fb4fc695134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2304743cdd22bf09ffc8f54ff54b030d/" rel="bookmark">
			排序算法 —— 希尔排序（图文超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 希尔排序（直接插入排序的优化）1.分组思想2.缩小增量的过程3.排序步骤3.1 排序五组数据的情况3.2 排序两组数据的情况3.3 排序一组数据的情况 4.代码分析4.1 如何设置数据组数4.2 直接插入排序实现思路 5. 整体代码实现 排序算法： 1、直接插入排序
2、选择排序
3、堆排序
希尔排序（直接插入排序的优化） 希尔排序是将数据分组，将每一组进行插入排序。
每一组排成有序后，最后整体就变有序了。
1.分组思想 上图中gap为5，说明要分成5组。
这5组分别用了五种颜色的线条连接起来了。
第1组：9、4
第2组：1、8
第3组：2、6
第4组：5、3
第5组：7、5
为什么要采取上面的分组方法呢？换一种方法可以吗？
例如：挨着的元素分为一组。
如果是上面的这种分组方式的话，排序之后会变成下面的情况。
如果是最开始的分组方法的话
如果是按照最开始的分组思想分组的话，最后会排序成
可以发现左边都是叫小的数据，右边都是较大的数据。
更方便把分成的每一个组进行插入排序。
2.缩小增量的过程 前面gap为5的情况排序后会变成下面情况
按照gap把数据分成了两组。
当数据很大的时候，数据的间隔很大。
小的数据会往前方，大的数据会往后放。
gap会逐渐缩小，间隔也会逐渐缩小。
整体的数据会更加趋于有序，这个时候使用直接插入排序效率会更高。
gap为2的时候会排序成下面情况
此时分为了1组，再排序一次后变成下面情况
此时的数据即为有序的。
3.排序步骤 3.1 排序五组数据的情况 gap为5，将数据分为5组，图中红色线画中的为第一组。定义一个 i 变量指向这一组的第二个数据，定义一个 j 变量指向 i - gap 的位置。将 i 下标的值放到定义的 tmp 中，然后与 j下标 的值比较。
若 j 下标的值较大，将 j 下标的值放到 j + gap 的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2304743cdd22bf09ffc8f54ff54b030d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166e7b883d09310b8c6e4d213db45d93/" rel="bookmark">
			基于Java的界面开发【用户注册登录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要清楚一个界面由哪些部分组成：
1、可视化部分： 窗体、标签、菜单、选项卡、按钮......
2、元素规则部分： 颜色、尺寸、字体、布局
3、内容部分： 文字、图片
其次是所需代码库（java类库）： java.awt（元素规则类比较多）
javax.swing（可视化组件较多）
所需要使用的类有以下几种（ 使用这些类时需要在class前导入）：
javax.siwng.JFrame; //窗体类
javax.swing.JButton; //按钮类
javax.swing.JLabel; //标签类
javax.swing.JTextField; //文本框类
javax.swing.JPasswordField; //密码框类
javax.swing.ImageIcon; //图标类
java.awt.Dimension; //尺寸类
java.awt.FlowLayout; //流式布局类
开发步骤：定义类，创建对象，调用方法
1：创建一个类UserUI
2：在类中创建一个方法initUI()
2.1: 创建一个窗体对象 JFrame jf=new JFrame("用户入口界面");
2.2: 设置窗体相关属性：
2.2.1: 设置窗体大小： jf.setSize(400, 400);
2.2.2: 设置窗体位置： jf.setLocation(300, 200);
2.2.3: 设置窗体关闭方式： jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
2.2.4: 设置窗体不可改变大小： jf.setResizable(false);
2.2.5: 设置窗体内的布局方式为流式布局： jf.setLayout(new FlowLayout());
2.2.6: 设置窗体可视化： jf.setVisible(true);
2.3: 创建组件对象：图标、图标标签、账号标签、账号输入框、密码标签、密码文本输入框、登录按钮、注册按钮
2.3.1: 创建图标对象： ImageIcon icon=new ImageIcon("src/login/111.png");
2.3.2: 创建图标标签对象： JLabel iconLabel=new JLabel(icon);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166e7b883d09310b8c6e4d213db45d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684138e247aebba3b39822c811f62271/" rel="bookmark">
			多智能体强化学习 (MARL) 算法框架综述 (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。以何种形式怎么获取其他智能体的信息成为了研究焦点。
本文主要关注协作学习。
文章目录 前言一、基于值函数的方法：1. [Value-Decomposition Networks For Cooperative Multi-Agent Learning (VDN)](https://arxiv.org/pdf/1706.05296.pdf)2. [QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning](https://arxiv.org/pdf/1803.11485.pdf)3. [QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement learning](https://arxiv.org/pdf/1905.05408.pdf)4. [Multi-Agent Determinantal Q-Learning （Q-DPP，Deep Q-DPP）](https://arxiv.org/abs/2006.01482)5. [Mean Field Multi-Agent Reinforcement Learning（MFMARL）面向大规模智能体](https://arxiv.org/abs/1802.05438v4) 二、基于演员-评论家的方法1. [Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments (MADDPG)](https://proceedings.neurips.cc/paper_files/paper/2017/file/68a9750337a418a86fe06c1991a1d64c-Paper.pdf)2. [Counterfactual Multi-Agent Policy Gradients (COMA)](https://arxiv.org/abs/1705.08926)3. [Multiagent Soft Q-Learning (MASQL)](https://arxiv.org/abs/1804.09817)4. [Actor-Attention-Critic for Multi-Agent Reinforcement Learning (MAAC)](https://arxiv.org/pdf/1810.02912.pdf) 三、基于经验回放（ER）缓存的方法：1. [Stabilising experience replay for deep multi-agent reinforcement learning (concurrent experience replay trajectories 的概念)](https://arxiv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684138e247aebba3b39822c811f62271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1fb0bde196a8413c44b2f7799978eb9/" rel="bookmark">
			vscode配置flutter开发环境，不需要安装第三方安卓模拟器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.获取Flutter SDK2.配置Android环境3. 在Android Studio配置Android设备3.1 进入Device Manager配置安卓设备3.2 创建安卓虚拟机3.3 选择x86 镜像3.4 配置硬件加速3.5 启动模拟器 4.配置vscode1.安装 Flutter 和 Dart 插件 5. 新建flutter程序创建应用 6.启动程序1.选定启动哪个模拟器2. 启动 1.获取Flutter SDK 点击下方的安装包，获取 stable 发行通道的 Flutter SDK 最新版本：Flutter SDK
将压缩包解压，然后把其中的 flutter 目录整个放在你想放置 Flutter SDK 的路径中**（注意不要出现中文目录）**
配置Windows系统的环境变量，在用户变量一栏中，在Path中添加 flutter\bin 目录的完整路径。例如：
配置好环境变量后可打开电脑的cmd窗口，使用命令
flutter doctor
上述命令会检查你的现有环境，并将检测结果以报告形式呈现出来。仔细阅读它显示的内容，检查是否有尚未安装的软件或是有其他的步骤需要完成（通常会以粗体呈现）。
第一次安装一般会出现下面的问题
[-] Android toolchain - develop for Android devices • Android SDK at D:\Android\sdk ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ • Try re-installing or updating your Android SDK, visit https://flutter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1fb0bde196a8413c44b2f7799978eb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce9f64e6a0276bedc5f4e84c1acf057/" rel="bookmark">
			Oracle查询表占用空间大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Oracle查询表空间占用情况 Oracle是一种经典的关系型数据库管理系统，对于表占用空间大小的查询是数据库管理中的基本操作。查询表空间占用情况可以通过以下代码实现：
SELECT a.tablespace_name "表空间名", total "表空间大小", free "表空间剩余大小", (total - free) "表占用空间大小", ROUND((total - free) / total * 100, 2) || '%' "已使用空间百分比" FROM (SELECT tablespace_name, SUM(bytes) / 1024 / 1024 total FROM dba_data_files GROUP BY tablespace_name) a, (SELECT tablespace_name, SUM(bytes) / 1024 / 1024 free FROM dba_free_space GROUP BY tablespace_name) b WHERE a.tablespace_name = b.tablespace_name ORDER BY (total - free) DESC; 通过以上代码，可以得到数据库中所有表空间的大小信息，包括表空间名、表空间大小、表空间剩余空间、表占用空间大小和已使用空间百分比。
二、Oracle查询表占用的空间 查询单个表占用的空间大小可以通过以下代码实现：
SELECT segment_name "表名", segment_type "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce9f64e6a0276bedc5f4e84c1acf057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fdf72b0828ee10a415cafcd3e44f709/" rel="bookmark">
			【机器学习】关联规则挖掘算法 &#43; 三大案例实战 &#43; Apriori算法 &#43; Python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、关联规则概述1.1 关联规则引入1.2 关联规则相关概念介绍1.2.1 样本、事务、项集、规则1.2.2 支持度、置信度1.2.3 提升度1.2.4 所有指标的公式 二、Python实战关联规则2.1 使用 mlxtend 工具包得出频繁项集与规则2.1.1 安装 mlxtend 工具包2.1.2 引入相关库2.1.3 自定义一份数据集2.1.4 得到频繁项集2.1.5 计算规则2.1.6 挑选有用的规则进行分析 2.2 数据集制作2.3 电影数据集关联分析2.3.1 数据集获取2.3.2 引入相关库2.3.3 读取数据集2.3.4 标准化数据集2.3.5 获取频繁项集2.3.6 计算规则2.3.7 结果分析 三、Apriori 算法3.1 算法介绍3.2 Python代码实现 一、关联规则概述 1.1 关联规则引入 下面用一个故事来引出关联规则：
1.2 关联规则相关概念介绍 1.2.1 样本、事务、项集、规则 关联规则中的数据集结构一般如下所示：
关于项集（多个项组成的集合）：
{ 牛奶 } 是 1-项集{ 牛奶，果冻 } 是 2-项集；{ 啤酒，面包，牛奶 } 是 3-项集 X==&gt;Y含义（规则）：
X和Y是项集X称为规则前项Y称为规则后项 事务：即样本，一个样本称为一个事务。事务仅包含其涉及到的项目，而不包含项目的具体信息
在超级市场的关联规则挖掘问题中事务是顾客一次购物所购买的商品，但事务中并不包括这些商品的具体信息，如商品的数量、价格等 1.2.2 支持度、置信度 支持度(support)：一个项集或者规则在所有事务中出现的频率， σ ( X ) \sigma(\mathrm{X}) σ(X)：表示项集X的支持度计数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fdf72b0828ee10a415cafcd3e44f709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbc538df867164ef02ac96831632872/" rel="bookmark">
			三种用python进行线性/非线性拟合的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 简单线性回归2. 多项式回归3. 非线性回归总结 1. 简单线性回归 使用回归分析绘制拟合曲线是一种常见的方法，简单线性回归就是其中的一种。简单线性回归可以通过最小二乘法来计算回归系数。以下是一个使用简单线性回归来拟合数据的代码示例：
import numpy as np import matplotlib.pyplot as plt x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) y = np.array([2.5, 4.5, 4.8, 5.5, 6.0, 7.0, 7.8, 8.0, 9.0, 9.5]) # 计算回归系数 slope, intercept = np.polyfit(x, y, 1) # 绘制拟合曲线 plt.scatter(x, y) plt.plot(x, slope * x + intercept, color='red') plt.show() 在该代码中，np.polyfit函数可以用来计算简单线性回归的回归系数。plot函数用来绘制拟合曲线，scatter函数绘制原始数据点。
2. 多项式回归 使用多项式回归是一种常用方法，它可以用来拟合更加复杂的数据集。以下是一个使用多项式回归来拟合数据的代码示例：
import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbc538df867164ef02ac96831632872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa3287152dc90abe0a2959cc6b960ff/" rel="bookmark">
			【Java系列】深入解析枚举类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 即便平凡的日子仿佛毫无波澜，但在某个特定的时刻，执着的努力便会显现出它的价值和意义。
希望这篇文章能让你不仅有一定的收获，而且可以愉快的学习，如果有什么建议，都可以留言和我交流
问题 思考一下这寄个问题，我们将围绕这三个问题来开始学习：
什么是枚举怎么定义枚举枚举的使用场景 1 什么是枚举 Java 枚举（Enum）是一种特殊的数据类型，它是一组预定义的常量，每个常量都有一个名称和一个值。
枚举类型在 Java 中被广泛使用，它可以用来代替常量、标志位、状态码等，使代码更加清晰、易读和易维护。
下面是 Java 枚举的详细介绍。
2 枚举的使用 定义枚举类型 在 Java 中，可以通过关键字 enum 来定义枚举类型。枚举类型的定义格式如下：
enum EnumName { Constant1, Constant2, Constant3, ... } 其中 EnumName 是枚举类型的名称，Constant1、Constant2、Constant3 等是枚举类型的常量。每个枚举常量都有一个名称和一个值，枚举常量的名称通常采用大写字母命名，多个单词之间用下划线分隔。
访问枚举常量 在 Java 中，可以通过枚举类型的名称来访问枚举常量。例如，假设有一个名为 Weekday 的枚举类型，可以通过如下方式来访问枚举常量：
Weekday monday = Weekday.Monday; 这里的 Weekday.Monday 表示 Weekday 枚举类型中的 Monday 常量。
枚举方法 枚举类型可以定义方法，这些方法可以在枚举常量上调用。例如，可以在 Weekday 枚举类型中定义一个 isWeekend 方法来判断当前枚举常量是否为周末：
enum Weekday { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday; public boolean isWeekend() { return this == Saturday || this == Sunday; } } 在上面的例子中，通过在枚举常量后面定义方法，可以在每个枚举常量上调用这个方法。例如，可以通过 Weekday.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaa3287152dc90abe0a2959cc6b960ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd425ccaaa1847396298740e7846783/" rel="bookmark">
			基于java的超市管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着小型超市规模的发展不断扩大，商品数量急剧增加，有关商品的各种信息量也成倍增长，传统的人工记忆方式也慢慢的无法适应形势的变化。随着信息技术的发展，计算机已被广泛的用于社会的各个领域，成为推动社会发展的技术动力。而在计算机应用中，软件的作用十分突出，软件已经发展成为信息技术的核心，主导着信息产品的开发和信息技术市场的进一步的开拓。软件产业已成为社会信息化进程中的一个战略性产业。在软件技术的应用中软件的开发技术尤其是应用型软件产品的开发技术成了重中之重。不断开发适应用户需求、市场需要的新型软件产品。随着社会的发展，软件也在不断的更新换代。
由于有些超市里对商品的进货、售出及商品的基本信息等的一些繁琐处理都是通过手工进行记载并进行处理的，对商品信息的处理工作量特别大，不仅浪费大量的人力物力，而且还很容易出错，更重要的是为了方便顾客，超市需要时时刻刻对商品对各种信息进行统计分析。 一直以来人们使用传统人工的方式管理超市的各项工作, 这种管理方式存在着许多缺点, 如: 效率低、保密性差, 另外时间一长, 将产生大量的冗余文件和数据, 这给查找、统计、更新和维护工作都带来了很大的困难。然而大型的超市管理系统功能过于强大而造成操作繁琐降低了小超市的工作效率。如果有这样一套完整的小型超市管理系统软件，只需点击几下鼠标就可完成所需操作，那样就会大大的提高超市员工的工作效率和管理水平，并能进一步提高超市的工作效率并使超市实施规范化管理。鉴于小型超市管理中存在的诸多问题, 我们在此次课程设计中以小型超市管理系统为研究课题，对此系统进行了全面的设计。
超市管理系统由顾客、员工、管理员界面三部分组成。 超市管理系统应该能够为用户提供充足的信息和快捷的查询手段。一个完整系统的设计，当然就离不开后台环境的支持，在此次设计中，我们主要以MYSQL数据库作为基础，实行此系统的开发。
关键词：Idea；MySQL；数据库；表
第一章 设计目的 《面向对象程序设计》是一门实践性很强的计算机专业基础课程，课程设计是学习完该课程后进行的一次较全面的综合练习。其目的在于通过实践加深学生对面向对象程序设计的理论、方法和基础知识的理解，掌握使用Java语言进行面向对象设计的基本方法，提高运用面向对象知识分析实际问题、解决实际问题的能力。
随着现代科学技术的迅猛发展，计算机技术已经渗透到各个领域，成为各行业必不可少的工具，特别是Internet技术的推广和信息高速公路的建立，使IT产业在市场竞争中越发显示出其独特的优势，步入信息化时代，有巨大的数据信息等待加工处理和传输，这使得对数据库的进一步开发和利用显得尤为迫切。
作为国内市场的一些中小型超市，它们在信息化过程中的步伐要落后于大中型超市，而对于这些企业的资源管理，信息的存储和处理也显得迫切需要，要适应市场竞争，就需要有高效的处理方式和管理方法，因此加快超市的信息化进程是必不可少的。
我国的超市在20世纪90年代初期形成，现在已经成为我国零售业的一种重要形态，为国民经济的发展发挥了重要的作用。随着经济的快速发展，超市的经营管理也变得愈加复杂，早期的售货员站柜台的形式早已不能满足现有销售业的发展，这样就迫切地需要引入新的管理技术。
主要是中小型超市使用者，该消费群体具有以下特征：超市日常管理人工化居多，工作效率较低；超市日常交易额较小，货物流通较小，不愿花高价购进大型超市管理系统。因此，该消费群体对产品的功能性需求并不高，只需满足前台销售系统、后台货物管理即可。
第二章 设计任务与要求 课程设计可选用IDEA、MySQL等作为开发平台以提高开发效率，尽可能熟练掌握其中一种集成开发环境。建议采用UML建模技术进行系统的分析设计，在Visio中画出系统用例图和类图，并将UML图复制到设计报告中。
通过这次设计，要求掌握以下内容：
（1）面向对象技术中的继承与多态（重载和覆盖）机制、各种修饰符的使用
（2）类、包、接口的定义与使用
（3）常用工具类与算法的实现（数组、向量、字符串、链表）
（4）Java的异常处理机制
（5）Java的数据库连接技术
第三章 设计说明 3.1 需求分析 3.1.1功能分析 本平台是基于Java语言的一个超市管理系统，主要功能是为广大的中小型超市提供一些日常的琐碎工作的管理，使得超市管理员能够从琐碎的管理事物中抽身出来，节省不必要的精力，从而可以更高效更好地完成工作。根据超市管理的实际需要，将本系统划分为几个功能模块，分别是普通用户及VIP用户的登录注册操作，对商品信息的管理，对员工信息的管理，对用户购物的操作，对用户退货，用户积分积攒及用户基本查看、兑换等操作。
本系统主要实现以下基本功能：
(1) 注册模块：该模块能实现普通用户、VIP用户在该系统注册账号，成为该超市的用户。
登录模块：该模块能实现普通用户、VIP用户登录系统，从而在系统上进行相应的查看商品、下单、退货等一系列操作。
商品管理模块：主要供管理员管理商品信息，可新增、修改、查询、删除商品信息，并进行节日购物打折设置。购物管理模块： 为购物者提供方便的服务，将商品信息进行整理，展示，用户在登录系统后可查看商品、购买商品、退货的功能，VIP会员除此功能外，可查看个人积分并进行积分兑换。管理员管理模块：管理员可登录系统，对员工信息进行查看、添加、修改、删除操作，对员工进行统一管理。 3.1.2性能要求分析 (1) 系统易操作性：
所开发的系统就做到操作简单，尽量使系统操作不受用户对电脑知识水平的限制。
(2) 系统具有可维护性：
由于系统涉及的信息比较广，数据库中的数据需要定期修改，系统可利用的空间及性能也随之下降，为了使系统更好地运转。
(3) 系统具有开放性：
该系统能够在开放的硬件系结构中运行，并且能与其他系统顺利连接，不会因外部系统的不同面要做在量的修改工作。
3.2 概要设计 3.2.1功能模块图 图3-1 功能模块图
3.3 详细设计 3.3.1项目代码目录结构 controller:程序控制包，放的是说程序逻辑控制判断类。
dao:数据操作包，数据操作接口及其实现类。
db:数据库连接包，下面是数据库连接获取工具类。
view:系统菜单界面包。
po:实体类包。
main：程序启动包，程序启动需通过此包下面的Main.class里面的main方法。
3.3.2数据表设计 admin(管理员表)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcd425ccaaa1847396298740e7846783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da951fb7dd5cd2f9dadaf778c322df7/" rel="bookmark">
			在 Visual Studio 2022 中使用 GitHub Copilot chat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文通过实际应用场景和示例代码展示了 GitHub Copilot Chat 在 Visual Studio 2022 中的优势和特点。最后，鼓励读者在实际工作中尝试使用 Copilot Chat，以提升开发效率和代码质量。希望这些信息和经验能为你在使用GitHub Copilot时提供帮助和启发。
文章目录 1. 背景2. 活动回顾3. 启用 Copilot Chat3.1 确认权限3.2 安装插件 4. 使用体验4.1 如何交互4.2 分析当前异常4.3 简单的测试4.3.1 对话式编程4.3.2 代码解释4.3.3 问题解答4.3.4 提供优化建议 4.4 编写单元测试 5. 最后 1. 背景 近年来，GitHub Copilot 的问世为软件开发领域带来了新的可能性。作为一款智能编程工具，它极大地提高了开发者的编程效率。为了更深入了解和掌握 GitHub Copilot 的使用技巧，我参加了一场名为“GitHub Copilot开发者训练营”的活动。
2. 活动回顾 北京的线下场是在北京微软大厦故宫会议室，这也是我第一次到微软大厦。
本次活动可谓是收获满满，会议中几位老师，分享了 GitHub Copilot 使用技巧和最佳实践，并做了实操的演示。我们探讨了 GitHub Copilot 如何帮助开发者提高开发效率、助力创新以及弥补技能差距。通过使用 GitHub Copilot，开发者可以专注于解决关键和实际问题，加快原型创建，轻松学习新技术，从而提高生产力。此外，徐磊老师列举了 10 个 AI 在编程场景中表现出色的例子，展示了AI如何在各种编程任务中取得优异成果，包括正则表达式编写、编写测试代码、使用难以记忆的关键字等。GitHub Copilot 作为一款智能编程工具，具有很大的潜力，能够帮助开发者提升开发效率和代码质量。
当然，也有一些稍微的小遗憾。我们胖胖的卢老师竟然在上海，不过能在线下看到徐磊老师也是非常棒的。另一个遗憾，大概是没有赶上会前的拍照吧。因为上午帮我的大朋友抢六一儿童节的玩具，误入了美术馆，然后就看了一上午的美轮美奂的艺术品，流连忘返，误了饭点。等到会议地点，已是正式开始的时间了。看了会议相册，我猜是早到有单独拍照的环节。可惜了，上面只能单独放一个展板咯。
在会议中，主要介绍了 Copilot 的功能，并展示了如何在 VS Code 中使用 Copilot Chat。结合 GitHub 的 Codespaces，我们可以在完全云端的开发环境中体验到非常便捷和高效的编程过程。然而，如何在被誉为地表最强的IDE —— Visual Studio 中使用 Copilot chat 呢？接下来，就让我们一起探讨一番。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1da951fb7dd5cd2f9dadaf778c322df7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21f4517527b65cd370c1fe70d0b6dde/" rel="bookmark">
			Selenium自动化测试（基于Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 了解Selenium
✅1.1 概念
✅1.2 作用
✅1.3 特点
✅1.4 工作原理
二. Selenium + Java 环境搭建
✅2.1 下载 Chrome 浏览器
✅2.2 查看浏览器的版本
✅2.3 下载浏览器驱动
✅2.4 验证环境是否搭建成功
三. Selenium 常用 API
✅3.1 定位元素
✅3.2 操作对象
✅3.3 添加等待
✅3.4 打印信息
✅3.5 浏览器操作
✅3.6 键盘操作
✅3.7 鼠标操作
✅3.8 定位一组元素
✅3.9 下拉框处理
✅3.10 切换窗口句柄
✅3.11 截图操作
✅3.12 上传文件操作
✅面试题：quit 和 close的区别
一. 了解Selenium ✅1.1 概念 Selenium是一个免费的/开源自动化测试框架，是一个Web应用程序测试工具；
✅1.2 作用 用于测试Web应用程序在不同的浏览器和不同平台上是否能工作正常；
✅1.3 特点 可以使用多种编程语言来编写Selenium测试脚本，如java, C#, Python等编程语言。自动化测试工具Selenium内置有记录和回放功能，用于记录和回放Web应用程序测试过程，且可在不同的浏览器上运行多个脚本；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c21f4517527b65cd370c1fe70d0b6dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a634cafd45ead8746fb43ccc1268f11a/" rel="bookmark">
			Java 的简要介绍及开发环境的搭建（超级详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片来源于互联网 目录 | CONTENT
Java 简介
一、什么是 Java
二、认识 Java 版本
三、选择哪个版本比较好
搭建 Java 开发环境
一、下载 Java 软件开发工具包 JDK
二、配置环境变量
自动配置
手动配置
三、下载合适的 IDE
IntelliJ IDEA
Visual Studio Code
Eclipse
NetBeans​​​​​​
JDeveloper
Java 简介 一、什么是 Java Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的高级程序设计语言，它可运行于多个平台，如 Windows, Mac OS 及其他多种 UNIX 版本的系统。Java 语言具有功能强大和简单易用两个特征，具有简单性、面向对象、分布式等特点，可以编写桌面应用程序、Web 应用程序、分布式程序和嵌入式系统应用程序等。同时 Java 也是目前最受开发人员欢迎的编程语言之一。它有助于企业降低成本、缩短开发周期、推动创新以及改善应用服务。如今，Java 仍是企业和开发人员的首选开发平台，全球有数百万开发人员运行超过 60 亿台 Java 虚拟机。
二、认识 Java 版本 Java 和其他编程语言一样，有多个版本，但 Java 版本的命名规则是有点诡异的。有时候你会看到 jdk 1.8、J2SE 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a634cafd45ead8746fb43ccc1268f11a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88915f820c395bdb657ec08f58cdde37/" rel="bookmark">
			一种使用Java的快速将Web中表格转换成Excel的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 随着后疫情时代的到来，在过去的2022年，全国的经济情况，想必是很多学者和研究对象都非常关心的事。而这些数据在国家统计局网站上都有相应的记录。通过分析这些数据，可以从某一个角度来验证和观察当下的经济情况。
全国共计有1279个县级单位已经披露了2022年GDP和一般公共预算收入数据情况，企业预警通根据这些数据整理出中国百强县gdp排行榜和百强县一般公共预算收入排行榜。其中昆山市以5006.66亿元GDP蝉联榜单榜首，江阴市、晋江市位列百强县第二三位，长沙县是湖南省唯一进入全国前十的（Top7）。来源：2023中国县城GDP百强榜揭晓 2023中国百强县排行榜一览。
第一张图是以图片的形式发布的，第二种是采用Html的表格（table）形式展示的。在离线分析使用数据的时候非常不方便。作为程序猿，这一定难不倒您。我们可以采用网页抓取的技术对数据进行整理。本文将以Java语言为编程语言，讲解使用Jsoup对Web网页知识进行爬取，文中给出了详细的示例代码，希望对大家有帮助。
一、初识Jsoup抓取 1、网页结构分析 在使用Jsoup对页面进行抓取时，需要对网页的结构进行初步的分析，便于制定相对应的抓取策略。首先打开浏览器，输入目标网站的地址，同时打开F12进入调试，找到目标网页的元素。
打开上面gdp百强榜表格中的div下table表格，找到如下的数据
同理，对于一般公共预算收入的数据处理也是同样的处理办法，在此不再赘述。
二、Java开发Jsoup抓取 1、引用Jsoup相关依赖包 这里我们采用Maven的jar进行包的依赖处理管理。因此先定义Pom.xml,关键代码如下所示：
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yelang&lt;/groupId&gt; &lt;artifactId&gt;jsoupdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2、 信息实体类的处理 对比发现两个表格处理具体的指标不一样，前面的排名和县名称，所在省份名称都是一样的。因此我们采用面向对象的设计方法对信息处理的类进行开发。相应的类图如下所示：
3、数据采集实体 package com.yelang.entity; import java.io.Serializable; import com.alibaba.excel.annotation.ExcelProperty; public class CountyBase implements Serializable { private static final long serialVersionUID = -1760099890427975758L; @ExcelProperty(value= {"序号"},index = 1) private Integer index; @ExcelProperty(value= {"县级地区"},index = 2) private String name; @ExcelProperty(value= {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88915f820c395bdb657ec08f58cdde37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f154be2c8c1c7da67cb2fb77b789b601/" rel="bookmark">
			调用百度文心AI作画API实现中文-图像跨模态生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者介绍 乔冠华，女，西安工程大学电子信息学院，2020级硕士研究生，张宏伟人工智能课题组。
研究方向：机器视觉与人工智能。
电子邮件：1078914066@qq.com
一．文心AI作画API介绍 1. 文心AI作画 文心ERNIE-ViLG，一款适合中文的跨模态AI绘画大模型。
论文地址：https://arxiv.org/pdf/2112.15283.pdf
体验连接：https://wenxin.baidu.com/ernie-vilg
文心ERNIE-ViLG是一个大规模的中文跨模态生成模型，其参数规模达到100亿。该模型首次通过自回归算法将图像生成和文本生成统一建模，增强模型的跨模态语义对齐能力，显著提升图文生成效果。
ERNIE-ViLG生成的不同风格的图像如下：
利用AI技术生成图片的最终目的是要便捷地为人类创造美的作品，激发人的想象力和创作力。在艺术创作、虚拟现实、图像编辑、AI 辅助设计、虚拟数字人等领域，文心 ERNIE-ViLG 这类跨模态大模型有着广泛的应用前景，也为这些领域未来的发展提供了无限的创意和可能。作为百度“文心”大模型全景图中的重要一员，文心 ERNIE-ViLG 也代表着百度文心在跨模态大模型领域迈出坚实步伐，从技术自主创新和加速产业应用方面持续推动中国 AI 发展。
2.接口介绍 文心AI作画API基于文心ERNIE-ViLG大模型，可根据用户输入的中文文本，自动创作图片。
文心AI作画涉及2个接口，分别为：提交请求、查询结果。
提交请求：传入文本、分辨率、风格参数，创建ERNIE-ViLG AI作画任务，获得任务ID。查询结果：用于在任务创建后，查看图片生成状态。待图片生成完毕，通过查询接口即可查看生成图片的地址链接。 该接口通过自定义丰富的修饰词，生成不同风格、不同构图、不同流派的图片（每次可自定义生成1张至6张图片）。
二．注册账号并获取API Key 进入：百度智能云并创建应用获取API Key,Secret Key
1. 注册百度智能云账号 免费注册登录百度智能云账号进入下图界面，选择右上角 “控制台”模块：
选择“产品服务”中“人工之智能”模块的“智能创作平台”项目：
点击领取免费的接口资源（根据要求实名认证后可获取）：
2. 获取API 在“应用列表”中点击“创建应用”，免费创建个人文本-图像生成应用模块：
创建成功的应用模块如下，从中可以获取个人应用模块的API Key和Secret Key：
三．代码实现 完整代码 提交请求代码
创建“提交请求”接口文件，并根据申请的个人API Key和Secret Key，以及自定义输入的文本和参数信息，修改并运行以下代码。（该代码可得到图片生成任务ID——“taskId”） import requests import json API_KEY = "自己申请的API Key" SECRET_KEY = "自己申请的Secret Key" def main(): url = "https://aip.baidubce.com/rpc/2.0/ernievilg/v1/txt2img?access_token=" + get_access_token() payload = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f154be2c8c1c7da67cb2fb77b789b601/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/603/">«</a>
	<span class="pagination__item pagination__item--current">604/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/605/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>