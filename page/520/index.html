<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a6302b2daa71347cd86c1dddd238bc/" rel="bookmark">
			vue2中使用WebSDK_V3.3.0(231027)展示监控视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需要数据 { szIP: '192.168.1.X', //摄像头ip szPort: '80', //端口 szUsername: 'admin', //用户名 szPassword: 'xxxxxx' //密码 }, 2.下载内容 WEB3.3控件开发包 V3.3
下载地址：海康开放平台
3.安装插件，引入js文件 （1）双击HCWebSDKPlugin.exe，安装插件
（2）引入文件
把这两个文件放在public下static目录下，在public的index.html中引入
&lt;script src="/static/videojs/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script id="videonode" src="/static/videojs/webVideoCtrl.js"&gt;&lt;/script&gt; 4.vue代码--视频组件 &lt;template&gt; &lt;div&gt; &lt;div class="left"&gt; &lt;div ref="divPlugin" :id="divPlugin" class="plugin" style="width: 650px; height: 250px; z-index: 1" &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['sysParams'], data() { return { divPlugin: 'video_' + this.generateUUID(), g_iWndIndex: null, szDeviceIdentify: '' }; }, created() {}, mounted() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a6302b2daa71347cd86c1dddd238bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11970d8bf1f9d70565a58c7501366da7/" rel="bookmark">
			ChatGPT 和文心一言 | 两大AI助手哪个更胜一筹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到英杰社区：
https://bbs.csdn.net/topics/617804998
欢迎来到阿Q社区：
https://bbs.csdn.net/topics/617897397
📕作者简介：热爱跑步的恒川，致力于C/C++、Java、Python等多编程语言，热爱跑步，喜爱音乐的一位博主。
📗本文收录于恒川的日常汇报系列，大家有兴趣的可以看一看
📘相关专栏C语言初阶、C语言进阶系列、恒川等，大家有兴趣的可以看一看
📙Python零基础入门系列，Java入门篇系列、docker技术篇系列、Apollo的学习录系列正在发展中，喜欢Python、Java、docker的朋友们可以关注一下哦！
两大AI助手哪个更胜一筹 一、ChatGPT1. 用途2. 特点 二、文心一言1. 用途2. 特点 三、ChatGPT 和文心一言哪个更好用？ 一、ChatGPT 1. 用途 ChatGPT（全名：Chat Generative Pre-trained Transformer），美国OpenAI 研发的聊天机器人程序 ，于2022年11月30日发布 。ChatGPT是人工智能技术驱动的自然语言处理工具，它能够通过理解和学习人类的语言来进行对话，还能根据聊天的上下文进行互动，真正像人类一样来聊天交流，甚至能完成撰写邮件、视频脚本、文案、翻译、代码，写论文 等任务。
2. 特点 ChatGPT 在语言理解和生成方面表现出色，能够理解和生成复杂的文本。它是一个通用性的语言模型，可以适用于多种应用场景。
ChatGPT是一种通用性的语言模型，适用于各种自然语言处理任务。它能够处理对话生成、文本生成、问题回答等多种应用场景，使其在各个领域都有广泛的应用。模型训练使用了大规模的语料库，包括互联网上的文本数据。这使得ChatGPT具有深厚的语言理解和生成能力，可以处理丰富多样的语言结构和风格。
ChatGPT能够理解上下文，并在对话中保持一定的语境。它可以记住之前的对话内容，使得生成的回复更加连贯和有逻辑。模型在生成文本时展现了一定的灵活性和创造性。它可以生成多样化的回答，适应不同的输入和请求。
用户可以通过提供特定的提示或上下文，定制ChatGPT的生成结果。这使得模型更容易适应不同用户的需求和喜好。ChatGPT在处理多种语言上表现良好，可以应对全球范围内的多语言环境，为跨文化交流提供便利。ChatGPT可用于实时应用，例如在线聊天服务、虚拟助手等。其高效的生成速度和实时响应使其适用于与用户进行实时交互的场景。
ChatGPT是由OpenAI开发的，并且OpenAI团队会不断更新和改进模型，以提供更好的性能和用户体验。这使得ChatGPT始终保持在技术的前沿。
二、文心一言 文心一言（英文名：ERNIE Bot）是百度全新一代知识增强大语言模型，文心大模型家族的新成员，能够与人对话互动，回答问题，协助创作，高效便捷地帮助人们获取信息、知识和灵感。文心一言是知识增强的大语言模型，基于飞桨深度学习平台和文心知识增强大模型，持续从海量数据和大规模知识中融合学习具备知识增强、检索增强和对话增强的技术特色
2023年3月20日，百度官微消息文心一言云服务将于3月27日上线。
我在23年获得了文心一言的体验权，体验非常舒服! 百度「文心一言」是百度全新一代知识增强大语言模型，文心大模型家族的新成员，能够与人对话互动，回答问题，协助创作，高效便捷地帮助人们获取信息、知识和灵感。百度文心一言软件提供了良好的使用体验，用户很容易感受到各种话题的魅力。通过简单的逻辑对话来帮助用户完成一些历史、科学问题。根据不同的学习数据集，还可以自主搭建想要的机器人类型。以更贴近一般人的对话方式与使用者互动，还能编写代码等。
1. 用途 文心一言是一个用于生成古风文学风格的小段文字的工具。它主要用于创作古风风格的文字，让用户能够轻松生成具有特定风格的短文。
2. 特点 文心一言的主要特色是能够生成具有古风文学风格的文字。这包括古代汉语的词汇、句式和修辞，让生成的文本带有古代文学的韵味。
工具通过独特的算法和模型设计，生成的文字表达方式独特而富有创意。这有助于创作者在古风文学创作中获得新颖的灵感。
文心一言提供简单易用的接口，使用户能够轻松输入相关的提示或主题，即可获取生成的古风文学风格的小段文字。这使得使用过程十分便捷。
工具适用于创作者在文学创作中寻找灵感。生成的文字可以用作文学作品的片段、开篇语，或是用来激发创意和构思。
文心一言不仅关注语言形式，还能够表达深刻的情感。生成的文字往往富有情感色彩，有助于传达作者想要表达的情感和意境。
工具支持多样的主题和场景，包括爱情、离别、风景、哲理等，满足了不同创作者的需求，使其适用于多种文学创作场景。
文心一言生成的文字可以作为创作灵感的起点，为作者提供新的思路和构思，有助于创作更加丰富和深刻的文学作品。
三、ChatGPT 和文心一言哪个更好用？ 选择使用哪个工具取决于你的具体需求：
2023年的时候我写过两篇文章，一篇是有关 ChatGPT 的，还有一篇是关于 文心一言 的。
ChatGPT
【ChatGPT】中国支付清算协会倡议支付行业从业人员谨慎使用ChatGPT
文心一言
【文心一言】文心一言最近这么火，它到底是什么
如果你需要进行通用性的自然语言处理、对话生成等任务，ChatGPT 是一个更为全面的选择。
如果你希望专注于生成古风文学风格的短文，那么文心一言可能更符合你的需要。最终，取决于你的具体用途和喜好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11970d8bf1f9d70565a58c7501366da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe811f9d7e0a0ac9130eb69b6f3e608/" rel="bookmark">
			可解释性AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方向一：可解释性AI的定义与重要性 1. 什么是可解释人工智能 可解释人工智能（Explainable Artificial Intelligence, XAI）是指智能体以一种可解释、可理解、人机互动的方式，与人工智能系统的使用者、受影响者、决策者、开发者等，达成清晰有效的沟通，以取得人类信任，同时满足监管要求。
AI VS. XAI
简单而言，可解释性可用于两个阶段：模型之前(pre)和模型之后(post)。
算法的透明性和简单性（Algorithmic Transparency and Simplicity）表达的可解构性（Decomposability）模型的可担责性（Accountability）算法的适用边界因果分析和推理对黑盒模型的事后解释（Post-hoc Explanation）对模型表达能力的建模与解释 人们对于解释的评价与度量指对于特定的可解释性方法的评测。常见的测评角度包括以下几种：
可解释性方法的敏感度可解释性方法的对抗攻击鲁棒性可解释性方法的全面性可解释性方法的客观性解释结果的简单易懂性可解释性方法的互洽性可解释性方法的计算效率 2. 为什么需要可解释人工智能 了解人工智能模型的正确决策机制，是提升人类对人工智能模型信任度的重要方法。而现有人工智能可解释性的研究成果揭示，基于数据驱动的人工智能系统决策机制，离取得人类信任这一终极目标，至少还存在以下3个方面的差距：
机器学习决策机制的理论缺陷 现在的机器学习方法，通常就是在输入数据和预期结果之间建立关联（Association）, 而由于数据样本普遍存在局限和偏差，这种关联学习不可避免地学到一种虚假关系（Spurious Relationship）。为了发现出真正的因果关系，需要通过主动干预（intervention）实验来拓展观测现象，并运用反事实推理（Counterfactual Reasoning）去伪存真。
因果推理的三个认知层次
2. 机器学习的应用缺陷
数据样本的局限和偏见，会导致数据驱动的人工智能系统存在偏见；“黑盒“的深度学习网络存在安全性上的潜在风险；从决策机制来看，当前对深度学习的分析还处于不透明的摸索阶段。 3. 人工智能系统未能满足监管要求
可解释人工智能的全路径
3. 如何研究可解释性 可解释性可主要分为以下几个类别：
特定模型的可解释性(Model-Specific explainability) 严格限定于特定模型算法的可解释性，如决策树模型、贝叶斯网络等。
不限模型的可解释性(Model-Agnostic explainability) 这种类型的解释适用于任何类型的机器学习模型。通常，后分析方法将在机器学习模型训练之后使用，它不依赖于任何特定算法，并且不了解内部模型结构和权重。
模型中心的可解释性(Model-Centric explainability) 大多数解释方法都是以模型为中心的，因为这些方法用于解释如何调整特征和目标值，应用各种算法并提取特定的结果集。
数据中心的可解释性(Data-Centric explainability) 因为数据在模型训练和预测中有重要作用，这类方法主要用于理解数据的意义，常见的方法有：数据剖析(Data Profiling)、监控数据漂移(Monitoring Data-Drifts)和数据对抗(Data-Adversarial)。
可解释性技术的分类
模型可解释性的研究方法：
知识抽取 (Knowledge extraction) 探索性数据分析 (Exploratory Data Analysis, EDA)结果可视化 (Result visualization) 比较分析 (Comparison analysis)基于影响的方法 (Influence-based) 敏感性分析与特征重要性选择 (Sensitivity Analysis and Feature selection importance) 分享几个有用的可解释性分析工具：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efe811f9d7e0a0ac9130eb69b6f3e608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e89856c62dfc20ca8c10a9e131631f81/" rel="bookmark">
			Python 项目代码写完了，然后怎么打包和发布？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你把你的代码写完了，是不是要给别人使用下，怎么打包你的项目代码呢？
喂，开源么？
接下来小帅b就跟你说说，如何打包你的代码。
就拿我们上次演示的 todo 为例，写完代码之后，代码的目录是这样的：
在 todo 这个目录里面，文件都放在一起了，我们可以这样简单划分一下：
这里创建了一个 package 目录，将源码文件放进去，然后把模板文件和数据库文件分门别类的安排好。
在 package 中，还创建了一个 __init__.py 仪式感一下。
为了让别人知道你是认真对待这个项目的，你可以在项目文件中创建一个 tests 目录，在里面测试你的代码：
接着可以创建一个 LICENSE ，用来说明你的这个项目可以被怎么使用？是不是需要声明来源，是不是可以商用？别人用你的项目去搞事情如何避免被抓去吃牢饭等。
现成的开源协议有好几种，不太了解的可以看看我之前写的这个：那些 GitHub 所声明的开源协议都是什么意思？
接着再创建一个 README 文件，来说明你这个项目是干什么的，如何使用等描述。
现在你的项目文件目录就有点人模人样了：
接下来要创建一个比较重要的文件了 —— setup.py，这个文件主要用来描述你的项目信息，好让 setuptools 打包工具来帮你打包项目。
在根目录下创建一个 setup.py 文件，按以下的方式来写你的项目信息：
每个参数都是什么意思呢？我来给你说明一下：
long_description：对项目比较长的描述，我们可以直接从 你刚刚写的 README 文件读取。
name: 你定义的包名，可以用字母、数字、下划线，需要确保唯一性。
version: 项目的版本号。
author: 你（作者）的名称。
author_email: 你（作者） 的邮箱。
description: 项目的简要描述。
long_description_content_type：长描述内容的使用的标记类型，一般为 markdown 或者 rst。
url: 你这个项目的主页地址，也可以直接链接到你这个项目的Github 地址上面去。
include_package_data: 是否添加 py 以外的文件。
package_data: 需要添加 Python 的额外文件列表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e89856c62dfc20ca8c10a9e131631f81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9553f8cbf17423053cc0b7119c282065/" rel="bookmark">
			Python中读取Excel最快的6种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，比较了从 Python 读取 Excel 的几种方法：
1、使用 Pandas 读取 Excel
Pandas 是 Python 的数据分析库，是用 Python 处理与数据有关的任何问题的首选，因此是一个很好的开始。
import pandas
def iter_excel_pandas(file: IO[bytes]) -&gt; Iterator[dict[str, object]]:
yield from pandas.read_excel(file).to_dict(‘records’)
只需将两条命令串联起来，就能从 Excel 文件中获取字典列表。这是结果中的一行：
&gt;&gt;&gt; with open(‘file.xlsx’, ‘rb’) as f:
… rows = iter_excel_pandas(f)
… row = next(rows)
… print(row)
…
{‘boolean’: True,
‘date’: Timestamp(‘2000-01-01 00:00:00’),
‘decimal’: 1.1,
‘number’: 1,
‘text’: ‘CONTROL ROW’}
2、使用 Tablib 读取 Excel
Tablib是 Python 中最流行的库之一，用于导入和导出各种格式的数据。它最初是由流行requests库的创建者开发的，因此其特点是同样关注开发人员体验和人体工程学。
安装：
$ pip install tablib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9553f8cbf17423053cc0b7119c282065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a1bb210f6e7d2703d36fcceacf6f094/" rel="bookmark">
			Python用While求1到100的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一门广泛应用于科学计算、数据分析、人工智能等领域的编程语言。其中，循环语句是基础而重要的语法之一，在Python中，while循环可以很方便地实现对某个条件的反复执行，同时也可以用来求1到100的和。
一、while循环语句的基本语法 while 循环的语法格式如下：
while 条件： 代码块 其中，条件是一个布尔表达式，如果它的值为True，则执行代码块。执行完代码块后，再次判断条件是否为True，如果是，则继续执行代码块，直到条件不成立为止。
二、用while循环求1到100的和 在Python中，可以通过while循环实现对1到100的求和，具体实现如下：
# 初始化变量及和的值 i = 1 sum = 0 # while循环求1到100的和 while i&lt;=100: sum += i i += 1 # 输出结果 print("1到100的和为：", sum) 其中，变量sum保存1到100的和，变量i则用来遍历1到100的所有数字。在循环过程中，每次将i加入sum中，然后将i加1，直到i大于100，while循环结束，输出1到100的和sum。
三、while循环的使用注意事项 通过上面的例子，可以看出while循环在求1到100的和这个问题中的重要作用，但是在使用while循环时还需要注意以下几点：
1. 避免死循环 可能会因为条件判断错误，导致循环无法终止，从而出现死循环的情况。因此，在使用while循环时一定要注意，确保条件判断的准确性，并且能够正确地终止循环。
2. 控制循环次数 在某些情况下，需要控制循环的次数，例如，可以使用变量来控制循环次数，同时避免死循环。
3. 理解循环体和循环条件 循环体是指while循环内部的代码，循环条件是指while语句中的条件表达式。理解循环体和循环条件的关系，能够更好地帮助我们理解while循环的机制。
四、总结 本文介绍了Python循环语句中的while语句，并通过求1到100的和的例子，详细讲解了while循环语句的基本语法和使用注意事项。希望本文对初学Python的读者有所启发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b75799e658524b8f5bab5ae4f5a6feb/" rel="bookmark">
			vue前端部署webrtc-streamer访问摄像机视频流教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现摄像头的直播功能其实有许多方案，像是安装vlc插件、rtsp转rtmp然后使用videojs通过flash播放rtmp，以及hls .m3u8等方式
然而现今的浏览器对于vlc插件几乎都不再支持了，flash在2020年也将被chrome停止支持，而.m3u8的方案用来做直播的话似乎延迟很高
经过一番查找，最终决定使用B站（bilibili）开源的flvjs作为解决方案，其原理是后端用ffmpeg将rtsp视频流转换为flv，然后通过websocket传输flv视频流，然后前端通过websocket获取到视频流后，使用flvjs对视频流再一次处理并进行播放，这是一套无插件无flash免费的视频直播解决方案。
但是我们发现利用flv.js播放视频流会出现卡顿延迟的问题，特别是播放多路视频流时，延迟问题非常严重。后面我们又发现了通过webrtc-streamer播放视频流的方法，成功解决了延迟卡顿的问题。
1、webrtc-streamer的安装部署 下载地址：
https://github.com/mpromonet/webrtc-streamer/releases
根据需求进行下载安装即可，我们这里下载是windows版本。
2、部署运行 解压后文件如下所示，打开cmd命令
执行命令webrtc-streamer.exe -H 127.0.0.1:8010 -o，出现以下即表示运行成功。
再次强调-H后面是你要监听的地址端口， -o 为了不转码，使用GPU运行，从而降低CPU负荷。
3、vue前端设置 首先，在template里进行视频播放配置
然后在script里配置
mounted() { //player_0：需要绑定的video控件ID //127.0.0.1:8000：启动webrtc-streamer的设备IP和端口，默认8000 this.webRtcServer1 = new WebRtcStreamer('player_0', location.protocol + '//127.0.0.1:8010') // //需要查看的rtsp地址 this.webRtcServer1.connect(this.rtsp0) } 当然不要忘了在data里配置我们的rtsp视频流地址。
注：这里配置的webrtc-streamer设备IP和端口要和前面启动监听的地址一样才行。
rtsp可以根据我们的需求进行配置，内网摄像机rtsp地址、外网rtsp视频流地址均可正常播放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad1c6ca2c955020efb8019f460d93b4/" rel="bookmark">
			Flink将数据流导入Doris
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Maven依赖导入 &lt;dependency&gt; &lt;groupId&gt;org.apache.doris&lt;/groupId&gt; &lt;artifactId&gt;flink-doris-connector-1.16&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; 1.1版本兼容 Connector VersionFlink VersionDoris VersionJava VersionScala Version1.0.31.11+0.15+82.11,2.121.1.11.141.0+82.11,2.121.2.11.151.0+8-1.3.01.161.0+8-1.4.01.15,1.16,1.171.0+8- 2.代码实现（DataStream） DorisSink是通过StreamLoad向Doris写入数据，DataStream写入时，支持不同的序列化方法。这里以String 数据流为例。
2.1Doris表准备 CREATE TABLE IF NOT EXISTS demo.test ( `user_id` LARGEINT NOT NULL COMMENT "用户id", `cost` BIGINT SUM DEFAULT "0" COMMENT "用户总消费" ) AGGREGATE KEY(`user_id`) DISTRIBUTED BY HASH(`user_id`) BUCKETS 1 PROPERTIES ( "replication_allocation" = "tag.location.default: 1" ); 2.2 java实现 @Test public void test01() throws Exception { StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1); env.enableCheckpointing(10000); Properties properties = new Properties(); DorisSink&lt;String&gt; dorisSink = DorisSink.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad1c6ca2c955020efb8019f460d93b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7368c3b40031db603131e2dea0a83a4/" rel="bookmark">
			flink的常见的任务提交方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、以flinksql的方式直接提交任务 此方式使用起来相对比较简单，但是无法满足需要设置savepoint暂存点的流式任务需求。
使用此方式需要先创建Flink远方的执行环境，然后按序执行FlinkSql，流程如下：
java示例如下：
package com.xw.flink; import org.apache.flink.api.java.ExecutionEnvironment; import org.apache.flink.configuration.Configuration; import org.apache.flink.table.api.TableEnvironment; public class testSqlServer { public static void main(String[] args) throws Exception { ExecutionEnvironment env = ExecutionEnvironment.createRemoteEnvironment("192.168.1.88",18082); TableEnvironment tableEnv = TableEnvironment.create(env.getConfiguration()); Configuration configuration = tableEnv.getConfig().getConfiguration(); //任务名称设定 configuration.setString("pipeline.name","sqlserver"); String sourceDDL = "CREATE TABLE Orders (f1 STRING,f2 STRING,f3 STRING) WITH ( " + " 'connector' = 'jdbc', " + " 'driver'='com.microsoft.sqlserver.jdbc.SQLServerDriver', " + " 'url'='jdbc:sqlserver://192.168.1.40:1433;databaseName=test;useLOBs=false', " + " 'table-name'='test_czd1', " + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7368c3b40031db603131e2dea0a83a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dac9be5ebbef740dbeca0bb7fbd404a/" rel="bookmark">
			关于mac环境下的node版本管理工具n和nvm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.区别：node版本管理之n和nvm_n node-CSDN博客 1）n 是一个需要全局安装的 npm package，n会出现全局模块无法更新的问题，⚠️ 使用npm不要使用n
2）nvm 一个独立软件包
3）关于 node 路径。n 是万年不变的 /usr/local/bin； nvm 需要手动指定路径。
2.n的使用 1）常见命令 全局安装：npm install n -g 安装node最新版本：sudo n latest 安装node最新stable版本：sudo n lts 安装特定版本：sudo n 版本 切换版本：n 删除版本：sudo n rm &lt;版本号&gt; 删除当前使用版本外的所有版本：n prune 卸载n：n uninstall 列出可供下载的匹配远程版本：n ls-remote lts n ls-remote latest n lsr 10 n --all lsr 列出缓存中下载的版本：n ls 显示诊断信息以帮助解决问题：n doctor 2）为避免在 n 和 npm 全局安装时需要 sudo （1）第一种：获取系统目录的所有权
# make cache folder (if missing) and take ownership sudo mkdir -p /usr/local/n sudo chown -R $(whoami) /usr/local/n # make sure the required folders exist (safe to execute even if they already exist) sudo mkdir -p /usr/local/bin /usr/local/lib /usr/local/include /usr/local/share # take ownership of Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dac9be5ebbef740dbeca0bb7fbd404a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5090fc18b2dccf3a45cceddf19ee6650/" rel="bookmark">
			【Redis】利用 Redis List 实现 Java 数据库分页快速查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空
🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 前言 在大型应用中，数据库分页查询是日常开发中不可避免的需求之一。随着数据量的不断增加，传统的数据库分页方式可能会变得效率较低。为了解决这一问题，本文将介绍如何使用 Redis List 数据结构，结合 Java 编程语言，实现高效的数据库分页查询。
Redis List 简介 Redis 是一款高性能的键值存储系统，而 Redis List 是其提供的一种有序、可重复的数据结构。List 具有快速的读写操作，适用于存储大量有序数据，这使其成为处理数据库分页查询的理想选择。
Java 与 Redis 连接 在开始之前，首先需要确保你的 Java 项目中引入了 Redis 相关的依赖。可以使用 Jedis 或者 Lettuce 等 Redis 客户端库。以下是 Maven 依赖示例：
&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.11.2&lt;/version&gt; &lt;/dependency&gt; 使用 Redis List 实现数据库分页查询 1. 插入数据到 Redis List 首先，我们需要将数据库中的数据存储到 Redis List 中。使用 Jedis 客户端，可以通过以下方式实现：
Jedis jedis = new Jedis("localhost", 6379); for (int i = 1; i &lt;= 1000; i++) { jedis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5090fc18b2dccf3a45cceddf19ee6650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5754825dba31817b592103c41c206e18/" rel="bookmark">
			SQL Server 中，删除表数据有以下几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 SQL Server 中，删除表数据有以下几种方式：
DELETE 语句：可以使用 DELETE 语句删除表中的一条或多条数据。DELETE 语句不会删除表本身，只会删除表中的数据。示例如下：
DELETE FROM tablename WHERE condition; TRUNCATE TABLE 语句：TRUNCATE TABLE 语句会删除表中的所有数据，并且不会记录任何事务日志。因此，它比 DELETE 语句更快，并使用更少的系统和事务日志资源。示例如下：
TRUNCATE TABLE tablename; DROP TABLE 语句：DROP TABLE 语句将删除整个表，包括表的结构、索引、触发器等。示例如下：
DROP TABLE tablename; 请注意，使用 DELETE 和 TRUNCATE 语句删除表数据后，标识字段（如 ID）可能会被重新使用。这意味着如果你删除了一条数据并重新插入新数据，标识字段的值可能会与已删除的数据重复。而使用 DROP TABLE 语句删除表后，表将彻底从数据库中移除，所有数据和结构都将丢失。因此，在执行这些操作之前，务必备份数据库，并仔细考虑你的需求和后果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0c60b61280d2ff18bdd524fb1a6355/" rel="bookmark">
			Python 安装库报错 “python setup.py egg_info did not run successfully.“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Python 安装库报错2. 问题解决3. 参考 1. Python 安装库报错 有时 Python 用 pip install 安装库的时候会报错，python setup.py egg_info did not run successfully. ，我在安装 deepspeed 报错示例如下：
Preparing metadata (setup.py) ... error error: subprocess-exited-with-error × python setup.py egg_info did not run successfully. │ exit code: 1 ╰─&gt; [20 lines of output] Traceback (most recent call last): File "&lt;string&gt;", line 2, in &lt;module&gt; File "&lt;pip-setuptools-caller&gt;", line 34, in &lt;module&gt; File "/private/var/folders/hv/g_8qfj_56k98k8tnpf_58k980000gn/T/pip-install-r4m2v95f/deepspeed_bb04440e1d854d09a2dde2b5d62ad864/setup.py", line 38, in &lt;module&gt; from op_builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f0c60b61280d2ff18bdd524fb1a6355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89f55ec03f45fe0ac979b24cb9b276b5/" rel="bookmark">
			python对象操作数据库—SQLAlchemy的基本介绍与简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.SQLAlchemy介绍 1.1.SQLAlchemy定义与解释
1.2.为什么要有SQLAlchemy？
2.SQLAlchemy的基本用法
2.1.安装SQLAlchemy
2.2.连接数据库
2.3.定义数据模型
2.4.创建表
2.5.插入数据
2.6.查询数据
3.SQLAlchemy实战—创建一个简单的博客系统
3.1定义数据模型类
3.2.创建数据库引擎和会话
3.3.进行数据库操作
4.总结 1.SQLAlchemy介绍 1.1.SQLAlchemy定义与解释 数据库是一个网站的基础。 比如MySQL、MongoDB、SQLite、PostgreSQL等，这里我们以 MySQL为例进行讲解。 SQLAlchemy是一个ORM框架。SQLAlchemy是一个用于Python的SQL工具和对象关系映射（ORM）库。它允许你通过Python代码来与关系型数据库交互，而不必直接编写SQL语句。
简单介绍一下对象关系映射吧，对象关系映射（英语：Object Relational Mapping，简称 ORM，或O/RM，或O/R mapping），是一种程序设计技术， 用于实现面向对象编程语言里不同类型系统的数据之间的转换。 从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。大白话：对象模型与数据库表的映射。
1.2.为什么要有SQLAlchemy？ 随着项目的越来越大，采用写原生SQL的方式在代码中会出现大量重复的SQL语句，那么，问题就出现了：
1.SQL语句重复利用率不高，越复杂的SQL语句条件越多，代码越长，会出现很多相近的SQL语句。
2.很多SQL语句 是在业务逻辑中拼接出来的，如果数据库需要更改，就要去修改这些逻辑，这会容易漏掉对某些SQL语句的修改。
3.写SQL时容易忽略web安全问题，造成隐患。
而ORM可以通过类的方式去操作数据库而不用再写原生的SQL语 句，通过把表映射成类，把行作为实例(一条数据)，把字段作为属性，ORM在执行对象操作的时候最终还是会把对象的操作转换为数据库的原生语句，但使用ORM有许多优点：
1.易用性：使用ORM做数据库开发可以有效减少重复SQL语句的概率，写出来的模型也更加直观、清晰。
2.性能损耗小：ORM转换成底层数据库操作指令确实会有一些开销。但是从实际情况来看，这种性能损耗很少（不足5%），只要不是针对性能有严苛的要求，综合考虑开发效率、代码阅读性，带来的好处远大于性能损耗，而且项目越大作用越明显。
3.设计灵活：可以轻松的写出复杂的查询。可移植性：SQLAlchemy封装了底层的数据库实现，支持多个关系数据库引擎，包括流行的 Mysql、PostgreSQL和SQLite，可以非常轻松的切换数据库。
2.SQLAlchemy的基本用法 2.1.安装SQLAlchemy 在使用SQLAlchemy之前，首先需要安装它。可以使用以下命令使用pip安装：
pip install sqlalchemy 2.2.连接数据库 使用SQLAlchemy连接到数据库，需要提供数据库的连接字符串，其中包含有关数据库类型、用户名、密码、主机和数据库名称的信息。
from sqlalchemy import create_engine # 例如，连接到SQLite数据库 engine = create_engine('sqlite:///example.db') 2.3.定义数据模型 使用SQLAlchemy的ORM功能，可以定义Python类来映射数据库中的表。每个类对应数据库中的一张表，类的属性对应表中的列。
# 导入必要的模块 from sqlalchemy import Column, Integer, String, Sequence from sqlalchemy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89f55ec03f45fe0ac979b24cb9b276b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c740fcf21259430ea72e9f30cb92ba3f/" rel="bookmark">
			超详细的YOLO系列算法全家桶--YOLOv1-YOLOv8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、YOLO算法的核心思想1. YOLO系列算法的步骤 二、YOLO系列算法1.YOLOv11.1 YOLOv1核心思想1.2 网络结构（backbone）1.3 优势与不足 2.YOLOv22.1 YOLOv2网络结构（backbone）2.2 YOLOv2主要改进部分2.3 优势与不足 3.YOLOv33.1 YOLOv3网络结构3.2 YOLOv3主要改进部分3.3 优势与不足 4.YOLOv44.1 YOLOv4网络结构4.1 YOLOv4主要改进部分4.3 优势与不足 5.YOLOv55.1 YOLOv5网络结构5.2 YOLOv5主要改进部分5.3 优势与不足 6.YOLOv66.1 YOLOv6网络结构6.2 YOLOv6主要改进部分6.3 优势与不足 7.YOLOv77.1 YOLOv7网络结构7.2 YOLOv7主要改进部分7.3 优势与不足 8.YOLOv88.1 YOLOv8网络结构8.2 YOLOv8主要改进部分8.3 优势与不足 前言 YOLOv1-YOLOv8的对比图先给大家呈上，本文介绍了从YOLOv1一直到YOLOv8的网络结构，以及各个版本之间的迭代，非常适合研究生们汇报PPT的制作和cv面试。
一、YOLO算法的核心思想 YOLO系列的核心思想就是把目标检测转变为一个回归问题，利用整张图片作为网络的输入，通过神经网络，得到边界框的位置及其所属的类别。
1. YOLO系列算法的步骤 划分图像：YOLO将输入图像划分为一个固定大小的网格。预测边界框和类别：对于每个网格，YOLO预测出固定数量（通常为5或3个）的边界框。每个边界框由5个主要属性描述：边界框的位置（中心坐标和宽高）和边界框包含的目标的置信度（confidence）。此外，每个边界框还预测目标的类别。单次前向传递：YOLO通过一个卷积神经网络（CNN）进行单次前向传递，同时预测所有边界框的位置和类别。相比于其他目标检测算法，如基于滑动窗口或区域提议的方法，YOLO具有更快的速度，因为它只需要一次前向传递即可完成预测。损失函数：YOLO使用多任务损失函数来训练网络。该损失函数包括位置损失、置信度损失和类别损失。位置损失衡量预测边界框和真实边界框之间的位置差异。置信度损失衡量边界框是否正确地预测了目标，并惩罚背景框的置信度。类别损失衡量目标类别的预测准确性。非最大抑制（Non-Maximum Suppression）：在预测的边界框中，可能存在多个相互重叠的框，代表同一个目标。为了消除冗余的边界框，YOLO使用非最大抑制算法，根据置信度和重叠程度筛选出最佳的边界框。 二、YOLO系列算法 1.YOLOv1 1.1 YOLOv1核心思想 如图，YOLOv1算法将输入图片进行7×7的划分，划分之后就有很多小格子。我们再看图片中待检测物体的中心是落在哪个格子里面，落在哪个格子哪个格子就负责预测这个物体。每个格子形成 2 个预测框，同时预测 20 个类别（class）概率，每个预测框包含 5 个特征的预测结果(x,y,w,h,c)，其中(x,y)为预测框相对于格子的位置，(w,h)为预测框相对于图片的宽和高比例，c 为置信度，表示预测框内存在被检物体的概率及预测框的位置准确度。将预测到的类别概率与预测框的置信度相乘，即可获得每个预测框中各类别的概率，以概率最高的结果作为预测结果输出，通过非极大值抑制（Non-MaximumSuppression，NMS）得到预测结果。
1. 边界框的中心坐标（x, y）：
中心坐标（x, y）表示边界框在图像中的位置。这些坐标是相对于所在网格单元的位置而言的。中心坐标的值通常被限制在0和1之间，表示相对于网格单元的比例。 2. 边界框的宽度和高度（w, h）：
边界框的宽度和高度表示目标在图像中的尺寸大小。
这些值也是相对于所在网格单元的尺寸而言的。
宽度和高度的值通常被限制在0和1之间，表示相对于网格单元的比例。
3. 置信度（confidence）：
置信度表示边界框内是否存在目标以及预测的准确性。置信度是一个0到1之间的值，其中1表示高置信度，0表示低置信度。置信度可以用于筛选边界框，以便在后处理中选择具有高置信度的边界框。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c740fcf21259430ea72e9f30cb92ba3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba23fc69a1d1f1c313aa857051085e50/" rel="bookmark">
			常见错误：com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最常见错误：com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure，如下图:
定位报错位置： 从代码上看，前一步说明jdbc驱动加载成功了，到了这一步报错，无非是传进去的是参数问题，没报用户和密码错误那就是url参数的问题。 本例中原来的参数是 jdbc:mysql://xx.xx.xx.xx:3306/qyhua，改成以下参数，问题解决。
jdbc:mysql://xx.xx.xx.xx:3306/qyhua?timeZone=TMC&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useTimezone=true&amp;serverTimezone=GMT%2B8" 总结：这种小错误非常见，各种连接池底层也是使用jdbc加载,它们报错通过也是url参数问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e189542c9f4930bb9facfa8ef439680/" rel="bookmark">
			无公网IP实现远程访问MongoDB文件数据库【内网穿透】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，我发现了一个超级强大的人工智能学习网站。它以通俗易懂的方式呈现复杂的概念，而且内容风趣幽默。我觉得它对大家可能会有所帮助，所以我在此分享。点击这里跳转到网站。
文章目录 前言1. 安装数据库2. 内网穿透2.1 安装cpolar内网穿透2.2 创建隧道映射2.3 测试随机公网地址远程连接 3. 配置固定TCP端口地址3.1 保留一个固定的公网TCP端口地址3.2 配置固定公网TCP端口地址3.3 测试固定地址公网远程访问 前言 MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。
MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。
简单几步实现MongoDB远程访问。
1. 安装数据库 打开MongoDB官网https://www.mongodb.com/try/download/community,这里以windows版本为例。
下载好后,双击安装即可,安装到这一步,须点击complate设置账号密码
进入后可以设置一下密码,然后点击next,或者直接点击next安装即可
安装好后,我们使用连接工具测试连接,这里使用navicat连接
2. 内网穿透 本地连接没问题后,目前该数据库只能在局域网内被访问，不过我们可以使用cpolar内网穿透工具，将内网的MongoDB数据库映射到公网上，实现远程访问，不需要公网IP，也不用设置路由器。
2.1 安装cpolar内网穿透 进入cpolar官网下载页面,下载windows安装包到本地然后解压一路默认安装即可
cpolar官网：https://www.cpolar.com/
2.2 创建隧道映射 cpolar安装成功后，双击打开cpolar【或者在浏览器上访问本地9200端口：127.0.0.1:9200】，使用cpolar邮箱账号登录 web UI管理界面，如果还没有注册cpolar账号的话，点击免费注册，会跳到cpolar官网注册一个账号就可以了
登录成功后，点击左侧仪表盘的隧道管理——创建隧道，创建一个tcp协议的隧道指向本地27017端口:
隧道名称：可自定义，注意不要与已有的隧道名称重复协议：tcp本地地址：27017域名类型：免费选择随机域名地区：默认China top即可 点击创建
隧道创建成功后，点击左侧的状态——在线隧道列表，可以看到刚刚创建的隧道已经有生成了相应的公网地址，将其复制下来
2.3 测试随机公网地址远程连接 打开navicat,输入tcp公网地址:3.tcp.cpolar.top端口号11249,然后点击测试连接,出现连接成功即可。
3. 配置固定TCP端口地址 由于以上创建的隧道是随机地址隧道,地址会在24小时内变化,为了使连接更加稳定,我们可以为其配置一个固定的tcp连接地址。
需要注意，配置固定TCP端口地址需要将cpolar升级到专业版套餐或以上。
3.1 保留一个固定的公网TCP端口地址 登录cpolar官网，点击左侧的预留，选择保留的TCP地址，我们先来为远程MongoDB保留一个固定端口地址。
地区：选择China VIP描述：即备注，可自定义填写 点击保留
地址保留成功后，系统会生成相应的固定公网地址，将其复制下来
3.2 配置固定公网TCP端口地址 在浏览器上访问9200端口，http://127.0.0.1:9200/，登录cpolar web ui管理界面，点击左侧仪表盘的隧道管理——隧道列表，找到MongoDB隧道，点击右侧的编辑
修改隧道信息，将保留成功的固定tcp地址配置到隧道中:
端口类型：修改为固定tcp端口预留的tcp地址：填写保留成功的地址 点击更新
隧道更新成功后，点击左侧仪表盘的状态——在线隧道列表，找到需要编辑的隧道，可以看到公网地址已经更新成为了固定tcp地址。
3.3 测试固定地址公网远程访问 测试使用固定TCP端口地址远程MongoDB,再次打开navicat,使用固定tcp地址连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fcf42cbc5ae51c252a86ead6e390dc/" rel="bookmark">
			RabbitMQ-如何保证消息不丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ常用于 异步发送，mysql，redis，es之间的数据同步 ，分布式事务，削峰填谷等.....
在微服务中，rabbitmq是我们经常用到的消息中间件。它能够异步的在各个业务之中进行消息的接受和发送，那么如何保证rabbitmq的消息不丢失就显得尤为重要。
首先要分析问题，我们就要明确rabbitmq在什么时候可能会出现消息丢失的情况呢？
我们直接说结果
RabbitMQ在每个阶段都有可能使消息发生丢失
我们在这里把他们简单归结为三个层面
层面一 ：生产者发送消息没有到达交换机或者没有到达绑定的队列。
层面二：RabbitMQ宕机可能导致的消息的丢失。
层面三：消费者宕机导致消息丢失。
层面一的解决方法常见的是
1.生产者确认机制
RabbitMQ提供了publisher confirm机制来避免消息发送到Mq的过程中丢失，消息发送到Mq以后，会返回一个结果给发送者，表示消息的发送成功。
情况一：发送成功 生产者正常发送消息到队列之后会返回一个publish-confirm ack 这个意思是告诉生产者已经接收到消息了。
情况二：发送失败 这里的发送失败有两种，一种是生产者发送到交换机失败 此时返回 publish-confirm nack 。第二种是生产者发送到队列失败 返回 publish-return ack。
开启生产者确认机制的代码如下 ，在生产者的配置文件中加入以下配置
spring: rabbitmq: publisher-confirm-type: correlated #开启生产者确认机制 publisher-returns: true 这里的
publisher-confirm-type:有三种模式可以选择： 第一种是none：代表关闭confirm机制
第二种是 simple：表示同步阻塞并等待mq的回执消息，即发送完消息后不能干其他的事情，只能等待mq的回执，很显然这样效率很低。
第三种是correlated：MQ异步回调方式返回回执消息，即生产者发送完消息后可以干其他的事情，直到接收到mq的回执。很明显这种效率要优于第二种。
配置return callback的代码如下，每个RabbitTemplate只能配置一个 代码如下
package com.itheima.publisher.com.it.heima.config; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.ReturnedMessage; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.BeansException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.context.annotation.Configuration; /** * @Auther: QuJingChuan * @Date: 2024/1/13 10:34 * @Description: */ @Slf4j @Configuration public class MqConfirmConfig implements ApplicationContextAware { @Autowired private RabbitTemplate rabbitTemplate; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { //配置回调 rabbitTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68fcf42cbc5ae51c252a86ead6e390dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5e1952571754502a2ccf9ba2fc2c0a/" rel="bookmark">
			Spring Authorization Server入门 (十二) 实现授权码模式使用前后端分离的登录页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023-12-01修改：在session-data-redis(Github)分支中添加了基于spring-session-data-redis的实现，无需借助nonceId来保持认证状态，该分支已去除所有nonceId相关内容，需要注意的是axios在初始化时需要添加配置withCredentials: true，让请求携带cookie。当然一些响应json的处理还是使用下方的内容。
今天的主题就是使用单独部署的登录页面替换认证服务器默认的登录页面(前后端分离时使用前端的登录页面)，目前在网上能搜到的很多都是理论，没有很好的一个示例，我就按照我自己的想法写了一个实现，给大家提供一个思路，如果有什么问题或者更好的想法可以在评论区提出，谢谢。
实现思路分析 先看一下在默认情况下请求在框架中的跳转情况 Spring Authorization Server(Spring Security)框架默认使用session存储用户的认证信息，这样在登录以后重定向回请求授权接口时(/oauth2/authorize)处理该请求的过滤器可以从session中获取到认证信息，从而走后边的流程，但是当这一套放在单独部署的登录页面中就不行了，在请求授权时哪怕登录过也无法获取到认证信息，因为他们不再是同一个session中了；所以关键点就在于怎么存储、获取认证信息。
先查看下框架怎么获取认证信息 在处理/oauth2/authorize接口的过滤器OAuth2AuthorizationEndpointFilter中看一下实现逻辑，看一下对于认证信息的处理，如下图
先由converter处理，之后再由provider处理，之后判断认证信息是否已经认证过了，没认证过不处理，交给后边的过滤器处理，接下来看一下converter中的逻辑，如下图所示
如图所示，这里直接从SecurityContextHolder中获取的认证信息，那么接下来就需要找一下它是怎么获取认证信息并放入SecurityContextHolder中的。
在OAuth2AuthorizationEndpointFilter中打一个断点，请求一下/oauth2/authorize接口，
断点断住以后查看一下过滤器链，发现在OAuth2AuthorizationEndpointFilter之前有一个SecurityContextHolderFilter过滤器，名字表达的特征很明显，接下来看一下这个过滤器中的逻辑。
从断点截图中可以看出是从securityContextRepository中获取的认证信息，然后通过securityContextHolderStrategy保存，看一下是不是在这里设置的认证信息。
断点进入方法后发现将认证信息的context设置到了contextHolder中，那这里和SecurityContextHolder是同一个东西吗？请接着往下看
SecurityContextHolder的getContext方法是从当前类中的属性获取，接下来看一下securityContextHolderStrategy的定义
它是通过调用SecurityContextHolder的getContextHolderStrategy方法完成实例化的，看下这个方法
追踪到这里应该就差不多了，框架从securityContextRepository中获取认证信息，然后通过securityContextHolderStrategy放入SecurityContextHolder中，让后边的过滤器可以直接从SecurityContextHolder中获取认证信息。
获取认证信息的地方结束了，接下来看一下存储认证信息的地方，分析完获取的地方，存储的地方就很简单了。
存储认证信息 看过之前文章或者其它关于登录分析的文章应该知道，框架对于登录的处理是基于UsernamePasswordAuthenticationFilter和父类AbstractAuthenticationProcessingFilter，在父类中调用子类的校验，重点是认证成功后的处理，如下图
认证成功后调用了successfulAuthentication方法，看一下该方法的实现
其它的不是本篇文章的重点，主要是红框中的代码，这里将登陆后的认证信息存储在securityContextRepository中。
到这里逻辑就通了，登录后将认证信息存储在securityContextRepository中，访问时从securityContextRepository中取出认证信息并放在SecurityContextHolder中，这样就保持了登陆状态。
改造分析 使用前后端分离的登录页面，那么登录接口就需要响应json了，不能再使用默认的成功/失败处理了，所以要重写登录成功和失败的处理器；重定向也不能由认证服务来重定向了，应该由前端重定向；存储认证信息的容器也不能以session为主了，使用redis来替换session。
使用redis后没有session了，也就不能确定请求是哪一个，本人拙见是在登录时携带一个唯一字符串，请求成功后前端重定向至需要认证的请求时携带该唯一字符串，这样请求时可以根据这个唯一字符串获取到认证信息。
2023-07-11修改：
只要用户在浏览器中访问认证服务就会生成一个session，所以当请求授权时或者访问其它需要登录的接口时，通过未登录处理重定向至登录页面时获取当前请求的sessionId，放入重定向地址的参数中；浏览器中在登录页面输入账号密码提交时携带地址栏中的sessionId；存取认证信息时获取sessionId的顺序为：请求头 —&gt;&gt;&gt; 请求参数 —&gt;&gt;&gt; 当前session；这样一来就可以通过session将认证服务和单独部署的登录页面中的请求串联起来了，详细实现请看下方代码
主要就是重定向时将当前请求放入target参数中，当前sessionId放入nonceId参数中
2023-07-21修改内容：oauth协议中有nonce参数，为防止冲突，nonce参数改为nonceId
思路清晰以后编码就很快了
重写登录成功处理(响应json)。重写登录失败处理(响应json)。重写未登录处理，重定向到登录页面时携带当前请求url。重写认证信息存取逻辑，使用redis存储认证信息。将以上内容添加到Spring Authorization Server配置中，使其在过滤器链中生效前端代码编写，按照要求传递唯一字符串并在登录成功后重定向至参数中携带的地址 代码实现 1. 创建LoginSuccessHandler类并实现AuthenticationSuccessHandler接口 package com.example.authorization.handler; import com.example.model.Result; import com.example.util.JsonUtils; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.http.MediaType; import org.springframework.security.core.Authentication; import org.springframework.security.web.authentication.AuthenticationSuccessHandler; import java.io.IOException; import java.nio.charset.StandardCharsets; /** * 登录成功处理类 * * @author vains */ public class LoginSuccessHandler implements AuthenticationSuccessHandler { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException { Result&lt;String&gt; success = Result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a5e1952571754502a2ccf9ba2fc2c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c1299b8ede8d84d2c05056fbbf86e4/" rel="bookmark">
			Python 入门：如何在 MacOS 上安装 Python？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 欢迎迈出成为 Python 开发人员的第一步！在开始学习本 Python 教程并开始使用 Python 开发程序之前，您需要在计算机上进行 Python 设置。本文将指导您在 macOS 设备上安装 Python 并将其更新到最新版本。
先决条件：
macOS操作系统在终端上以管理员身份登录 在 Mac 计算机上安装 Python：
默认情况下，python 2.7.0 安装在 macOS 上;因此，我们将努力更新到最新版本的 Python，即 python 3。
如何在 Mac 上检查 Python 版本？ 通过以下命令检查计算机上最新版本的 Python：python --version 从上面的输出中我们可以看出，默认情况下，您的计算机安装了 Python 2.7.0;因此，我们将致力于安装 Python 3.0。 在 Mac 上安装 Python 的方法 有两种方法可以在计算机上安装官方 Python 发行版：
官方安装程序：这允许您从 python.org 下载官方安装程序包文件并在您的计算机上运行它。Homebrew 包管理器：此方法涉及下载并安装 Homebrew 包管理器（如果尚未安装），然后在终端应用程序中键入命令以安装 python 3.0。Homebrew 是一个免费的开源软件包管理系统，可简化 macOS 上的软件安装。 这两种方法都会为你安装 Python，但官方 Python 基金会只维护官方安装程序。
从 Homebrew 安装的局限性 Homebrew 附带的适用于 macOS 的 Python 包不包含 Tkinter 模块所需的 Tcl/Tk 依赖项。Tkinter 是用于在 Python 中开发 GUI（图形用户界面）的标准库，但它不是 Python 的一部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48c1299b8ede8d84d2c05056fbbf86e4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/519/">«</a>
	<span class="pagination__item pagination__item--current">520/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/521/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>