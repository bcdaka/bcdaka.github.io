<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4ac2bc6cded0ba7c6c5b3c1a05b63e/" rel="bookmark">
			Java语言程序设计——篇十一（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌿🌿🌿跟随博主脚步，从这里开始→博主主页🌿🌿🌿
欢迎大家：这里是我的学习笔记、总结知识的地方，喜欢的话请三连，有问题可以私信🌳🌳🌳
您的点赞👍、关注➕、收藏⭐️、评论📝、私信📧是我最大的支持与鼓舞！！！🌻🌻🌻 集合——Set Set接口及实现类HashSet类实战演练 用Set对象实现集合操作TreeSet类实战演练实战演练 对象顺序实战演练综合实例 Set接口及实现类 Set接口是Collection的子接口，其中不允许有重复的元素。Set接口没有定义新的方法，只包含从Collection接口继承的方法。Set接口的常用实现类有：HashSet类、TreeSet类。 HashSet类 HashSet类用散列方法存储元素，具有最好的存取性能，但元素没有顺序。HashSet类的构造方法有： HashSet(): 初始容量是16，默认装填因子是0.75。
HashSet(Collection c)
HashSet(int initialCapacity)
HashSet(int initialCapacity, float loadFactor)
实战演练 例：HashSetDemo.java
import java.util.*; public class HashSetDemo { public static void main(String[] args) { Set&lt;String&gt; words = new HashSet&lt;&gt;(); words.add("one"); words.add("two"); words.add("three"); words.add("one"); //不能将重复元素添加到集合中 for(String s:words) System.out.print(s+" "); } } 用Set对象实现集合操作 使用Set对象的批量操作方法，可以实现标准集合代数运算。假设s1和s2是Set对象，下面的操作可实现相关的集合运算。 s1.addAll(s2)：实现集合s1与s2的并运算。
s1.retainAll(s2)：实现集合s1与s2的交运算。
s1.removeAll(s2)：实现集合s1与s2的差运算。
s1.containAll(s2)：如果s2是s1的子集，该方法返回true。
TreeSet类 TreeSet实现一种树集合， 它使用红-黑树算法为元素排序，因此集合中的元素是有序存放的。添加到TreeSet中的元素必须是可比较的，即元素的类必须实现Comparable接口。构造方法如下： TreeSet()
TreeSet(Collection c)
TreeSet(Comparator c)
实战演练 例：TreeSetDemo.java
import java.util.*; public class TreeSetDemo{ public static void main(String[] args){ Set&lt;String&gt; ts = new TreeSet&lt;&gt;(); String[] s = new String[]{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c4ac2bc6cded0ba7c6c5b3c1a05b63e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d44478d456571fd8ea8cf4a635ced37/" rel="bookmark">
			JVM 运行时内存结构简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM 运行时内存结构简介 一、前言二、JVM 运行时内存结构2.1 线程隔离数据区：2.2 线程共享数据区： 三、JVM 内存区域划分1. 程序计数器（PC）2. 虚拟机栈3. 本地方法栈4. Java 堆5. 方法区6. 运行时常量池 附录 一、前言 JVM（Java 虚拟机）的运行时内存结构在 Java 程序的运行中起着关键支撑作用。而在 Android 系统中，虽然没有直接使用传统的 JVM，但 Android 运行时环境（AndroidRuntime）借鉴了许多 JVM 的设计理念和机制。了解 JVM 的运行时内存结构，不仅有助于 Java 开发者更好地理解 Java 程序的运行机制，对于 Android 开发者来说，也能更深入地理解 Android 系统中应用程序的运行原理，优化程序性能，以及排查内存相关的问题。
二、JVM 运行时内存结构 2.1 线程隔离数据区： 程序计数器：记录正在执行的虚拟机字节码的地址；虚拟机栈：方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；本地方法栈：虚拟机的Native方法执行的内存区； 2.2 线程共享数据区： Java堆：对象分配内存的区域；方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分。 三、JVM 内存区域划分 1. 程序计数器（PC） 程序计数器是当前线程所执行的字节码行号指示器。每个线程都拥有自己独立的程序计数器，属于私有内存空间，在整个内存中占比较小。当线程执行 Java 方法时，PC 计数器记录正在执行的虚拟机字节码地址；而当线程执行 Native 方法时，PC 计数器为空。 2. 虚拟机栈 虚拟机栈的生命周期与线程相同，是 Java 方法执行的内存模型。每个方法执行时都会创建一个栈帧，方法的执行过程对应着虚拟机栈的入栈到出栈过程。栈帧是支持虚拟机进行方法执行的数据结构，也是虚拟机栈的栈元素。栈帧包括局部变量表（容量以 slot 为最小单位，用于存储一组变量，其大小在编译期确定）、操作栈（操作栈元素的数据类型需与字节码指令序列严格匹配，大小同样在编译期确定）、动态连接（指向运行时常量池中该栈帧所属方法的引用，用于动态连接）、方法返回地址（正常退出时，执行引擎遇到方法返回的字节码，将返回值传递给调用者；异常退出时，若遇到未被捕捉的 Exception，则不会有任何返回值）以及可能的额外附加信息（由具体虚拟机实现，虚拟机规范未明确规定）。Java 虚拟机规范规定该区域可能出现两种异常：当线程请求栈深度超出虚拟机栈所允许的深度时抛出 StackOverFlowError；当 Java 虚拟机动态扩展到无法申请足够内存时抛出 OutOfMemoryError。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d44478d456571fd8ea8cf4a635ced37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85af3ef70b610711e657be68891945d2/" rel="bookmark">
			STM32——I2C通信外设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件只需要CR控制寄存器，DR数据寄存器，为实时监控状态，软件需要读取SR状态寄存器，好比：开车时CR是控制汽车方向，踩油门等，SR是仪表盘。
由于I2C是半双工，因此发送和接收数据都是在移位寄存器和DATA 寄存器中进行，发送数据时，在数据向移位寄存器转移时，新的数据就会进入到DATA寄存器中。
接收数据时先到移位寄存器，之后转移到DATA寄存器
简化如下：由于I2C是高位先行，因此发送数据是左移。
I2C的GPIO为开漏输出模式
此处时钟可以输入也可以输出
之后是主机发送部分：
首先是10位的帧头，11110+2位地址位+1位读写位，后边是剩余8位地址位
发送数据：数据写入DR中，之后当移位寄存器空时，将数据转入移位寄存器中进行发送，当DR中的一个数据被全部转移到移位寄存器时，就会有新的数据进入到DR中，等待进行下一次转移到移位寄存器中，当接收应答位后，数据就被转移到移位寄存器中
主机接收部分：以当前地址读的形式展示主机接收
起始条件——从机地址+读——应答——接收数据——应答——接收数据——非应答——终止
代码部分，在硬件中不需要用软件配制I2C协议的内容，全由硬件实现
首先是初始化部分，相对比与软件来说，硬件这部分初始化需要增加部分：1、开启I2C和GPIO口的时钟；2、对GPIO口进行设置并为复用开漏输出模式（复用：GPIO控制权交给外设）；3、对I2C进行设置；4、开启I2C使能
对MPU6050的配置保留。
时钟速度在100KHz下是标准模式，高低电平时间一致，占空比为1：1；超过100KHz后，进入快速模式，低/高近似=2：1；400KHz最大时钟速度
和软件一致。
之后是写寄存器的代码需要进行替换：
根据上面的主机发送图可得：
先设置起始条件——EV5事件——发送从机地址并应答——EV6（发送数据的代码）——发送寄存器地址并应答——EV8——发送数据（一个字节）——EV8_2——停止条件
为代码更加简便，增加了一个等待函数，当超时时就不再等待事件的发生，防止卡死
之后是主机接收的过程：
起始条件——EV5——发送从机地址并应答——EV6（发送数据的代码）——发送寄存器地址并应答——EV8_2/8——重新发送起始条件——EV5——发送从机地址并应答——EV6（接收数据的代码）—ACK=0失能(只读取一个字节时)——停止条件——EV7——接收数据——ACK=1使能（默认是1使能）——返回数据
实验结果与上一篇一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffcf314e638b290bb2fc2502092c485a/" rel="bookmark">
			LINUX环境中宝塔Python虚拟环境变量问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发和维护过程中，尤其是在处理Linux服务器环境的数据修复或执行其他Django命令时，通常需要手动导入环境变量，操作起来非常不安全和麻烦。这对于开发者来说，特别是通过SSH工具操作时，显得尤为麻烦。每次操作都需要先加载环境变量，然后再执行脚本。例如：
# 变量加载 export DJANGO_ENV=production export DJANGO_SETTINGS_MODULE=douniu.settings.production # 脚本执行 /www/server/pyporject_evn/xxxxx/bin/python3 manage.py crawl # 脚本执行
/www/server/pyporject_evn/xxxxx/bin/python3 manage.py crawl 为了解决这个问题，简化线上环境中的操作流程，我决定编写一个脚本，以实现Python虚拟环境的快速切换，并自动导入所需的环境变量。
问题分析
在编写脚本之前，我们需要了解一个关键点：当我们直接运行一个Bash脚本时，脚本会在一个新的子Shell中执行。任何在脚本中设置的环境变量或虚拟环境的激活状态都只会在这个子Shell中生效，而不会影响当前的Shell会话。这就解释了为什么每次运行脚本后，环境变量和虚拟环境的设置并没有在当前Shell中生效。
解决方案：使用source或.命令
为了解决这个问题，并确保环境变量和虚拟环境在当前Shell中生效，可以通过使用source命令或.命令来运行脚本。这样，脚本中的命令就会在当前Shell中执行，而不是在一个新的子Shell中。
实现步骤
1. 编写脚本
首先，在你的/root目录下创建一个名为 switch_env.sh 的脚本文件：
nano /root/switch_env.sh 然后，在文件中添加以下内容：
#!/bin/bash # 指定虚拟环境的 activate 脚本路径 VENV_ACTIVATE="/www/server/pyporject_evn/aihao100_venv/lib/python3.11/venv/scripts/common/activate" # 检查虚拟环境的 activate 脚本是否存在 if [ ! -f "$VENV_ACTIVATE" ]; then echo "Virtual environment activate script not found at $VENV_ACTIVATE" exit 1 fi # 激活虚拟环境 source "$VENV_ACTIVATE" # 导入环境变量 export DJANGO_ENV=production export DJANGO_SETTINGS_MODULE=douniu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffcf314e638b290bb2fc2502092c485a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead3f9e1f8a184f140551d4238ddddf2/" rel="bookmark">
			鸿蒙内核源码分析(ELF格式篇) | 应用程序入口并不是main
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读之前的说明 先说明，本篇很长，也很枯燥，若不是绝对的技术偏执狂是看不下去的.将通过一段简单代码去跟踪编译成ELF格式后的内容.看看ELF究竟长了怎样的一副花花肠子，用readelf命令去窥视ELF的全貌，最后用objdump命令反汇编ELF.找到了大家熟悉main函数.
开始之前先说结论:
ELF 分四块，其中三块是描述信息(也叫头信息)，另一块是内容，放的是所有段/区的内容. ELF头定义全局性信息 Segment(段)头，内容描述段的名字，开始位置，类型，偏移，大小及每段由哪些区组成. 内容区，ELF有两个重要概念 Segment(段) 和 Section(区)，段比区大，二者之间关系如下: 每个Segment可以包含多个Section每个Section可以属于多个SegmentSegment之间可以有重合的部分拿大家熟知的.text，.data，.bss举例，它们都叫区，但它们又属于LOAD段. Section(区)头，内容描述区的名字，开始位置，类型，偏移，大小等信息 ELF一体两面，面对不同的场景扮演不同的角色，这是理解ELF的关键，链接器只关注1，3(区)，4 的内容，加载器只关注1，2，3(段)的内容鸿蒙对EFL的定义在 kernel\extended\dynload\include\los_ld_elf_pri.h文件中 示例代码 在windows目录E:\harmony\docker\case_code_100下创建 main.c文件，如下:
#include &lt;stdio.h&gt; void say_hello(char *who) { printf("hello， %s!\n"， who); } char *my_name = "harmony os"; int main() { say_hello(my_name); return 0; } 做好了环境映射，所以文件会同时出现在docker中.编译生成ELF-&gt;运行-&gt;readelf -h查看app头部信息.
root@5e3abe332c5a:/home/docker/case_code_100# ls main.c root@5e3abe332c5a:/home/docker/case_code_100# gcc -o app main.c root@5e3abe332c5a:/home/docker/case_code_100# ls app main.c root@5e3abe332c5a:/home/docker/case_code_100# ./app hello， harmony os! 名正才言顺 一下是关于ELF的所有中英名词对照.建议先仔细看一篇再看系列篇部分.
可执行可连接格式 : ELF(Executable and Linking Format) ELF文件头:ELF header 基地址:base address 动态连接器: dynamic linker 动态连接: dynamic linking 全局偏移量表: got(global offset table) 进程链接表: plt(Procedure Linkage Table) 哈希表: hash table 初始化函数 : initialization function 连接编辑器 : link editor 目标文件 : object file 函数连接表 : procedure linkage table 程序头: program header 程序头表 : program header table 程序解析器 : program interpreter 重定位: relocation 共享目标 : shared object 区(节): section 区(节)头 : section header 区(节)表: section header table 段 : segment 字符串表 : string table 符号表: symbol table 终止函数 : termination function ELF历史 ELF(Executable and Linking Format)，即"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead3f9e1f8a184f140551d4238ddddf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195590bd803b31b766cae536f92ee15c/" rel="bookmark">
			游戏引擎详解——图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片 图片的格式 图片文件格式pngjpg 纹理压缩格式ETC1/2PVRTCASTC 图片的属性 图片属性解释分辨率宽高像素值（pt），如：1024*1024位深度用来存储像素颜色的值，如RGBA8888，红黄蓝透明度4个维度每个8bit，一共就是32位，一般使用的就是32位，也被称为真彩色文件大小文件所占用的存储大小 图片的优化 图片的优化分为两种：
文件大小优化：这种优化会影响到包大小，较小的图片大小对于手机存储容量和网络传输速度和时间会更友好。 一般的优化方式是使用压缩工具如pngquant、tinypng等，直接压缩文件大小。
图片纹理优化： 图片文件大小压缩，不意味着读到内存中的大小会减少。
一般情况下，以ARPG8888来说，计算一个1024*1024分辨率的图片读到内存中的大小，计算公式为：
1024 * 1024 * 4 * 8 = 33,554,432 bit = 4,194,304 byte ≈ 4 mb 理解起来就是 1024 * 1024 个像素，每个像素有 argb 4个通道，每个通道含有 8 bit数据用来存储颜色值。
png格式不能直接被GPU识别，需要在cpu把图片读进内存中解码后，再传递给gpu使用，这样做会造成一定的cpu消耗和很大的瞬时运行内存（RAM）占用。
因为大部分gpu对于压缩后的纹理有比较好的支持，无需cpu解码，占用内存小。于是我们要寻找一种合适的纹理压缩方式。
etc1不支持透明通道。etc2效果很差，容易出现色块。PVRTC仅能在ios上使用. 这时候astc格式就展露在我们眼前，IOS和安卓端都对astc有较好的支持率。
iPhone6及iPad mini 4以上iOS设备支持。大多数支持OpenGL ES 3.1或Vulkan的现代Android GPU也支持ASTC格式，其中包括：自Adreno 4xx / Snapdragon 415（2015年）起的高通GPU，自Mali T624（2012年）起的ARM GPU，自Tegra K1（2014年）起的NVIDIA GPU，以及自GX6250（2014年）起的PowerVR GPU。 在运行内存中来说，astc的内存使用能节省75%左右，提升巨大。
cocoscreator中源码理解 creator引擎在编译时会把选中的纹理压缩类型记录到import文件夹下的json文件中，多种图片格式以下划线‘_’区分开，下图演示里选择了astc6x6格式和webp格式，所以生成的类型就是
代码中在读取文件格式时，会根据列举的文件类型判断当前机器是否支持。由下面代码图里能够看到，7@34这里的7代表的就是第7个.astc，4代表的就是第4个.webp。若当前设备不支持astc就会去寻找webp格式。
cocoscreator中源码整个下载流程的理解（建议配合cocos2.4.11源码享用） 一切的一切都要从bundle.js这个类说起，类中的load函数会调用cc.assetManager.loadAny函数来下载相关资源并获取资源数据返回。
，传递的参数是资源名paths，类型type，进度回调函数onProgress，完成回调函数onComplete。
cc.assetManager是CCAssetManager类,这个类里有一个loadAny函数，此函数简单封装了一个Task并把task传递到pipeline中。这里的pipeline是定义在shared.js中的new Pipeline(‘normal load’, [])一个名字叫做normal load的管线,异步执行任务，管线填充在CCAssetManager类中pipeline.append(preprocess).append(load);包含一个preprocess和load方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195590bd803b31b766cae536f92ee15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cace383c717517250959fff4961671/" rel="bookmark">
			云手机解决了TikTok哪些账号运营难题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着社交媒体的蓬勃发展，TikTok作为一款风靡全球的短视频应用，成为许多个人和企业进行品牌推广、内容创作的首选平台。然而，随之而来的是TikTok账号运营的一系列难题。本文将深入探讨云手机是如何解决这些难题的。
1、多账号运营的便捷性：
云手机通过虚拟化技术，使用户可以同时运营多个TikTok账号，无需频繁切换设备或登录不同账号，大大提高了TikTok多账号运营的便捷性。对于个人创作者或数字营销人员而言，这意味着能够更高效地管理和推广多个账号。
2、全球网络规避地理位置限制：
在一些地区，TikTok可能存在地理位置限制，导致用户无法正常访问或发布内容。云手机通过提供连接全球的网络，可以规避这一限制，让用户仿佛身处于其他地区，解决了地理位置对账号运营的影响。
3、流量优化提升账号活跃度：
云手机服务商通常提供流量优化功能，通过合理规避监测点，减少被检测到的可能性，提高账号的活跃度。这对于避免账号被封或限制是至关重要的。
4、隐私保护与安全性：
云手机服务商对用户的隐私信息提供了相对较高的保护水平。用户可以更安心地进行账号运营，而不必担心敏感信息被泄露或滥用。
5、应对封号风险：
封号是许多TikTok用户担心的问题，而云手机通过降低被平台识别的风险，有效应对了封号的风险。用户在规避一些行为监测的同时，可以更好地保护账号的安全。
6、多地区活动支持：
对于需要在不同地区进行活动或推广的用户，云手机提供了多地区IP支持，使用户能够获取不同地区的当地IP，参与全球范围的活动。
综上所述，云手机通过多方面的优势，为TikTok账号运营者提供了强有力的支持。借助云手机，用户能够有效解决运营难题，事半功倍地进行账号管理和推广，更好地应对多样化的运营需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b7283cac9ce417d29bb62f75bccadb/" rel="bookmark">
			Elasticsearch 安全通信配置（SSL/TLS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网络安全威胁的日益增长，确保数据在传输过程中的安全性变得至关重要。Elasticsearch 作为一种分布式搜索和分析引擎，通常需要在不同节点之间传递数据，也需要与外部客户端进行通信。为了防止数据在传输过程中被窃取或篡改，必须为 Elasticsearch 配置安全通信机制。SSL/TLS（安全套接层/传输层安全协议）是实现安全通信的标准方法。本文将详细介绍如何为 Elasticsearch 配置 SSL/TLS，以确保集群节点之间和客户端与服务器之间的通信安全。
9.3 安全通信配置（SSL/TLS） Elasticsearch 提供了内置的 SSL/TLS 支持，通过配置传输层和 HTTP 层的加密，可以确保集群内部和外部通信的安全性。SSL/TLS 的配置涉及证书的生成和管理、配置文件的修改，以及客户端的配置。
1. 生成证书 配置 SSL/TLS 的第一步是生成和管理证书。Elasticsearch 提供了一个简单的工具 elasticsearch-certutil，可以用来生成证书。通常，我们需要生成一个证书颁发机构（CA）证书，并基于此 CA 签发节点证书。
1.1 生成 CA 证书 首先，使用 elasticsearch-certutil 生成 CA 证书：
bin/elasticsearch-certutil ca 该命令会生成一个 CA 证书文件（例如 elastic-stack-ca.p12），该文件将用于签发集群节点和客户端的证书。
1.2 生成节点证书 接下来，为 Elasticsearch 节点生成证书：
bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 该命令会生成一个 .p12 文件，包含节点的公钥和私钥以及 CA 证书。你可以为每个节点生成单独的证书，也可以为多个节点生成共享证书。
1.3 生成自签名证书 如果不使用 CA，可以直接生成自签名证书：
bin/elasticsearch-certutil cert --self-signed 这种方式适用于小型集群或测试环境，但生产环境中推荐使用 CA 签发的证书。
2. 配置 Elasticsearch 传输层加密 传输层加密用于保护 Elasticsearch 节点之间的通信。通过配置传输层加密，可以确保集群内部的数据传输不被窃听或篡改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b7283cac9ce417d29bb62f75bccadb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39cd9968cf53f7d7778eb327f617b94b/" rel="bookmark">
			企业级Web服务器性能优化实践指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
一、 Web服务器基础与发展历程
1.互联网与Web服务发展简史
2. Apache与Nginx的性能对比
2.1 Apache服务器
2.2 Nginx服务器
3. 用户访问体验的重要性
3.1 用户速度体验原则
3.2 影响用户体验的因素
4. 服务端I/O流程与性能
4.1 I/O基本概念
4.2 磁盘I/O
4.3 网络I/O
5. I/O模型详解
5.1 I/O模型相关概念
5.2 网络I/O模型
5.3 I/O模型的比较
6. 零拷贝
6.1零拷贝的概念
6.2零拷贝相关技术
二、 Nginx架构与安装
1.Nginx 架构概述
1.1 Nginx 简介
1.2 核心特性
1.3 进程模型
2.Nginx 安装 2.1 安装前的准备
2.2 编译安装Nginx
2.3.nginx启动文件编写
3平滑升级和回滚
3.1平滑升级流程
3.2.平滑升级
三、Nginx核心配置与优化
1. 配置文件结构
2. 全局配置
3.核心配置
3.1.新建一个 PC web 站点
3.2.root和alias
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39cd9968cf53f7d7778eb327f617b94b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295ac7776e57448a6fff7ebec52b6209/" rel="bookmark">
			tomcat相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、部署安装tomcat 在10和20上安装tomcat
[root@10 ~]# dnf install java-1.8.0-openjdk.x86_64 -y #安装java环境
[root@10 ~]# tar zxf apache-tomcat-9.0.93.tar.gz -C /usr/local/ #安装并启动tomcat
[root@10 ~]# ln -s /usr/local/apache-tomcat-9.0.93/ /usr/local/tomcat/ [root@10 ~]# /usr/local/tomcat/bin/startup.sh Using CATALINA_BASE: /usr/local/tomcat
Using CATALINA_HOME: /usr/local/tomcat
Using CATALINA_TMPDIR: /usr/local/tomcat/temp
Using JRE_HOME: /usr
Using CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar
Using CATALINA_OPTS: Tomcat started.
[root@10 ~]# netstat -antlupe | grep java #查看端口
tcp6 0 0 :::8080 :::* LISTEN 0 30431 3308/java tcp6 0 0 127.0.0.1:8005 :::* LISTEN 0 30443 3308/java tomcat相关目录和文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/295ac7776e57448a6fff7ebec52b6209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5899d9497b8dfe55d130f9cd231d4c15/" rel="bookmark">
			【机器学习】dense的用法以及如何用Numpy构建一个简单神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在TensorFlow和Keras中，Dense 层是全连接（fully connected）层的标准实现，其中每个输入都与每个输出有连接
文章目录 引言一、dense的用法1.1 步骤1.1.1 导入必要的库1.1.2 创建模型1.1.3 添加 `Dense` 层1.1.4 编译模型1.1.5 训练模型 1.2 代码示例1.3 代码解释1.4 总结 二、用Numpy构建一个简单神经网络2.1 导入第三方库2.2 数据集2.3 归一化数据2.4 Numpy模型2.5 预测2.6 网络功能2.7 总结 一、dense的用法 1.1 步骤 1.1.1 导入必要的库 通常，你需要从 tensorflow.keras 中导入 models 和 layers。
from tensorflow.keras import models, layers 1.1.2 创建模型 使用 models.Sequential() 创建一个顺序模型。
model = models.Sequential() 1.1.3 添加 Dense 层 使用 model.add() 方法添加 Dense 层到模型中。
model.add(layers.Dense(units, activation='activation_function')) 其中：
units 是层的输出维度，即该层中的神经元数量。activation 是激活函数，例如 ‘relu’、‘sigmoid’、‘softmax’ 等。 1.1.4 编译模型 选择损失函数、优化器，并定义评估指标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5899d9497b8dfe55d130f9cd231d4c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c705a468df66cb2ca4462d0b759acf/" rel="bookmark">
			云原生系列 - Nginx(高级篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习视频：尚硅谷Nginx教程（亿级流量nginx架构设计）本内容仅用于个人学习笔记，如有侵扰，联系删学习文档： 云原生系列 - Nginx(基础篇)云原生系列 - Nginx(高级篇) 一、扩容 通过扩容提升整体吞吐量
1、单机垂直扩容：硬件资源增加 云服务资源增加 整机：IBM、浪潮、DELL、HP等 CPU/主板：更新到主流 网卡：10G/40G网卡 磁盘：SAS(SCSI) HDD（机械）、HHD（混合）、SATA SSD、PCI-e SSD、 MVMe SSD SSD 多副本机制 系统盘/热点数据/数据库存储 HDD 冷数据存储 2、水平扩展：集群化 2.1、会话管理 2.1.1、Nginx高级负载均衡 ip_hash:
适用于中小型的项目，问题:
ip 集中后端转发的服务器宕机，关键数据的丢失，session) upstream httpds { ip_hash; server 192.168.119.128; server 192.168.119.129; } server { listen 80; server_name localhost; location / { proxy_pass http://httpds; # root html; } location ~*/(css|img|js) { root /usr/local/nginx/html; } hash $cookie_jsessionid;
登录系统，会下发一个文件-&gt;客户端客户端携带这个 cookie 去访问服务tomcat，java 才会下发 jsessionid，如果是其他服务，没有携带这个字段，所以没法进行hash upstream httpds { hash $cookie_jsessionid; server 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c705a468df66cb2ca4462d0b759acf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/561cf29cc9c601a031ee186eb43a12c9/" rel="bookmark">
			【自然语言处理】0821学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对于自然语言来讲，在自然语言处理的第一步，我们要面对的是各种各样以不同形式表现的文本数据，比如，有的是纯 txt 文档，有的是存储在 Excel 中的表格数据，还有的是无法直接打开的 pkl 文件等。
2.整体框架如下：
2.1 txt 文本的读写
(1) write()
(2) open()
(3) 参数mode
(4) readline() read read()不同点
2.2 CSV以及Excel的文本读写
2.3 data Frame的操作
获取某行某列
根据条件获取部分数据
进行数据可视化
2.4 数据规模太大怎么处理
（1）压缩文件
（2）使用精确度更低的数据类型
（3）拆分数据分成块
open() 函数用于打开一个文件，创建一个 file 对象，之后，相关的方法才可以调用它进行更多的操作。 对于 open() 函数，我们主要关注三个传入的参数：
file: 文件路径（相对或者绝对路径）。
mode: 文件打开模式。
encoding: 编码格式，一般使用 utf-8。
其中，mode 决定了打开文件的模式，也就是限定了可以对文件做什么样的操作，比如只读，写入，追加等，这个参数是非强制的，默认文件访问模式为只读 ®，以下是常用的模式：
r : 读取文件，若文件不存在则会报错。
w: 写入文件，若文件不存在则会先创建再写入，若存在则会覆盖原文件。
a : 写入文件，若文件不存在则会先创建再写入，若存在不会覆盖原文件，而是在文件中继续写入内容。
rb, wb：分别与 r, w 类似，但用于读写二进制文件。
r+ : 可读、可写，若文件不存在会报错，在写操作时会覆盖原文件。
w+ : 可读，可写，文件不存在先创建，若存在会覆盖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/561cf29cc9c601a031ee186eb43a12c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65263635dcdfda02c224fed9c14c873f/" rel="bookmark">
			Python知识点：如何使用SQLite，在Python开发中进行轻量级数据库操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python开发中，SQLite是一种非常适合轻量级数据库操作的工具，因为它是一个嵌入式数据库，不需要独立的服务器进程。Python内置了对SQLite的支持，使用标准库中的sqlite3模块即可进行数据库操作。下面是如何使用SQLite在Python中进行轻量级数据库操作的详细步骤。
1. 导入SQLite模块 首先，导入Python内置的sqlite3模块：
import sqlite3 2. 创建或连接到一个SQLite数据库 你可以使用sqlite3.connect()方法连接到一个SQLite数据库。如果数据库文件不存在，SQLite会自动创建它。
conn = sqlite3.connect('example.db') example.db是数据库的文件名。如果你想在内存中创建一个数据库（不保存到文件），可以使用:memory:作为数据库名：
conn = sqlite3.connect(':memory:') 3. 创建一个游标对象 游标（cursor）对象用于执行SQL命令和查询：
cursor = conn.cursor() 4. 创建表 使用SQL语句创建表，例如创建一个用户表：
cursor.execute(''' CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY, name TEXT, age INTEGER ) ''') CREATE TABLE IF NOT EXISTS 确保只有在表不存在时才会创建表。INTEGER PRIMARY KEY 定义了一个自增的主键。 5. 插入数据 使用INSERT INTO语句插入数据：
cursor.execute(''' INSERT INTO users (name, age) VALUES (?, ?) ''', ("Alice", 30)) cursor.execute(''' INSERT INTO users (name, age) VALUES (?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65263635dcdfda02c224fed9c14c873f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a9fdc8546d71a15fb5a05674bb4bff6/" rel="bookmark">
			使用Jmeter进行接口压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmeter是一款压力测试工具，广泛应用于测试后台接口在高并发情况下的响应耗时，这篇文章记录使用Jmeter测试后端接口的步骤
创建测试计划 点击name，修改名称，代表测试项目
配置线程组 点击 order-service - Add – Threads(Users) – Thread Group
需要配置如下几个关键的参数
Number of Threads (users)：代表模拟多少个用户同时请求，一个线程代表一个用户
Ramp-Up period(seconds)：设置启动全部线程耗时多少秒，截图填写了1，代表1秒模拟100个用户并发
Loop Count 代表循环访问的次数，每个用户循环访问10次
添加测试接口 创建一个下单的接口测试页面
配置如下参数
protocol：可以是HTTP或HTTPS，默认为HTTP。
服务器名称或IP ：HTTP请求发送的目标服务器名称或IP。
port number：目标服务器的端口号，默认值为80
http request ：发送HTTP请求的方法，可用方法包括GET、POST、HEAD、PUT、OPTIONS、TRACE、DELETE
path：去除ip之外的URL路径
content-encoding ：默认为ISO-8859-1编码，这里配置为utf-8。
parameters：根据请求类型配置请求参数
添加自定义变量 自定义变量配置在csv文件中，有两列，每一列代表什么意义配置在variable参数中，以空格作为分隔
配置一个get请求的查询接口，使用上文配置的参数
参数已经被成功截取出来
添加察看结果树 添加聚合报告 label：表示配置的Http接口名称
samples：表示总计发送了1000个请求
Average：平均响应时间，单位为毫秒
median：响应中位数时间
90%Line: %90用户的响应时间
95%Line: %95用户的响应时间
95%Line：99%用户的响应时间
min：最小响应时间
max：最大响应时间
error：错误率。有些请求在高并发情况下会响应超时，这个时候就会报错
Throughput：每秒吞吐量
receive kb：每秒从服务器收到的数据量
sent kb：每秒向服务器发送的数据量
这是我整理的《2024最新jmeter接口测试和jmeter接口自动化测试全套教程附带性能测试》，以及配套的接口文档/项目实战【网盘资源】，需要的朋友可以下方视频的置顶评论获取。肯定会给你带来帮助和方向。
b站最新最全的jmeter接口测试和jmeter接口自动化测试，jmeter性能测试保姆级全套教程！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7727b83a1f8d140cac4c4c752455eda9/" rel="bookmark">
			组合模式 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合模式 简介: 将对象组合成树形结构以表示"部分-整体"的层次结构, 使得用户对单个对象和组合对象的使用具有一致性.
组合模式也是一种结构类型的模式.看简介比较容易理解, 毕竟树形结构是数据结构必修的, 我们仍然举个例子方便理解
以公司的组织架构为例
公司 - 部门 - 员工
其中员工是叶子节点, 公司和部门是树枝节点
代码
class Node { private: string name; public: Node(string s) : name(s) {}; string get_name() { return name; }; virtual void display() = 0; virtual void add_node(Node* n) = 0; }; class Leaf : public Node { public: Leaf(string s) : Node(s) {}; void add_node(Node* n) override { cout &lt;&lt; "leaf node can not add node"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7727b83a1f8d140cac4c4c752455eda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baee4af018809c9439d069e41aaa7f35/" rel="bookmark">
			vue打包设置 自定义的NODE_ENV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认NODE_ENV 自定义process.env.NODE_ENV的值_process.node.env的值-CSDN博客
‌NODE_ENV开发环境下：NODE_ENV=development(默认)
生产环境下：NODE_ENV=production(默认)
NODE_ENV 除了默认的 development 和 production 以外，确实可以自定义设置。‌
在 Vue 项目中，可以通过修改 package.json 文件中的脚本命令来自定义 NODE_ENV 的值。
vue-cli3初始化的项目里，package.json中是这样的
"serve": "vue-cli-service serve", "build": "vue-cli-service build", "lint": "vue-cli-service lint" 如果实现刚才的需求，我们可以这样做：
"serve": "NODE_ENV='test' vue-cli-service serve", "serve:pro": "NODE_ENV='production' vue-cli-service serve", "build": "NODE_ENV='test' vue-cli-service build", "build:pro": "NODE_ENV='production' vue-cli-service build", "lint": "vue-cli-service lint" 然后配置api的地方
if( process.env.NODE_ENV === 'test' ){ apiUrl = '测试环境的url' }else{ apiUrl = '正式环境的url' } 然而报错了 NODE_ENV='test' vue-cli-service build 'NODE_ENV' 不是内部或外部命令，也不是可运行的程序 或批处理文件。
Vue-cli3 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baee4af018809c9439d069e41aaa7f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc86f1705984559793becca4f7d43466/" rel="bookmark">
			HTML对信息化大屏的像素适应解决方案autofit.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在政务信息化过程，各政务机关引入了信息化大屏设备，而大屏的像素设置往往受到安装场地的高宽限制，形成了不规则的像素；而系统软件往往是规则的1920*1080的分辨率；不管大屏怎么分屏显示，都很难占满整个大屏。
这种情况下，我们推荐两种方案，大屏分辨率是1920*1080的偶数倍，就利用大屏的分屏软件，将大屏划分为多各标准1920*1080分辨率标准平，再利用多个电脑他同时投屏。
另一种方案，在系统中引入autofit.js，根据大屏的分辨率设置分辨率，利用js代码自适应大屏分辨率。
下图是利用autofit.js自适应大屏分辨率后，在PC机上的显示；图示分辨率已经更改为3840*1080的分辨率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516ff4808d6bd0b6d1bb84d0ea45028a/" rel="bookmark">
			go中的并发处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		. Goroutines 概念：
Goroutines 是 Go 的核心并发机制。它们是由 Go 运行时管理的轻量级线程，具有比操作系统线程更少的开销。每个 goroutine 只需少量的内存（大约 2KB），并且由 Go 运行时负责调度和管理,哪怕是java发展到21的虚拟线程和go比也还是不够轻量
创建：
go func() { fmt.Println("Hello from goroutine") }() 使用 go 关键字前缀一个函数调用即可创建一个新的 goroutine。它将异步执行指定的函数。
调度模型：
Go 使用 M调度模型，其中 M 个用户级线程（goroutines）通过 N 个操作系统线程（OS threads）进行调度。Go 运行时会动态地将 goroutines 分配到操作系统线程上，减少了上下文切换的开销。
底层原理：
Go 的调度器使用协作式调度，依靠 goroutine 的堆栈跟踪（stack traces）和调度策略（如抢占式调度）来管理并发执行。调度器负责在 goroutines 和 OS threads 之间进行合理分配，以实现高效的并发执行。
###Channel
概念：
Channel 是用于 goroutine 之间通信的管道，可以安全地传递数据。它们实现了数据传递的同步机制，避免了传统的锁竞争问题。
创建：
ch := make(chan int) 发送和接收：
// 发送数据 ch &lt;- 42 // 接收数据 value := &lt;-ch //数据通过 &lt;- 操作符在 channel 中发送和接收。发送操作会阻塞直到有接收方，接收操作会阻塞直到有发送方。 这样就可以简单模拟java的join 操作 ,只有上一个任务执行完才允许接下来的线程执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516ff4808d6bd0b6d1bb84d0ea45028a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c661743e19c0c83ce9afe41d6657e3/" rel="bookmark">
			Django 后端架构开发：JWT 项目实践与Drf版本控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🛠️ Django 后端架构开发：JWT 项目实践与Drf版本控制 📌 JWT 项目实践：从理论到实战 JSON Web Token（JWT）是当前最流行的身份认证机制之一，在后端开发中被广泛使用。它基于Token的身份验证方式，避免了传统的Session认证在分布式系统中的局限性。在本节中，我们将通过一个实际的Django项目，详细解析JWT的应用场景和实现方式。
首先，在Django中使用JWT进行用户认证时，通常需要借助第三方库，如 djangorestframework-jwt 或 django-rest-framework-simplejwt。这些库提供了方便的工具和方法，帮助我们在Django REST Framework中集成JWT。
以下是一个简单的项目示例，我们将逐步解析其中的关键代码。
# settings.py 配置 INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework_simplejwt', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework_simplejwt.authentication.JWTAuthentication', ), } # 配置JWT的过期时间等参数 SIMPLE_JWT = { 'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5), 'REFRESH_TOKEN_LIFETIME': timedelta(days=1), 'ROTATE_REFRESH_TOKENS': True, 'BLACKLIST_AFTER_ROTATION': True, 'ALGORITHM': 'HS256', 'SIGNING_KEY': SECRET_KEY, 'VERIFYING_KEY': None, 'AUTH_HEADER_TYPES': ('Bearer',), ... } 在 settings.py 中，我们配置了JWT的认证方式，并设置了相关参数。ACCESS_TOKEN_LIFETIME 是访问令牌的有效时间，而 REFRESH_TOKEN_LIFETIME 则决定了刷新令牌的有效期。这些参数的设置直接影响了系统的安全性和用户体验。
接下来，我们在 views.py 中实现JWT的登录逻辑。
from rest_framework_simplejwt.views import TokenObtainPairView from rest_framework_simplejwt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c661743e19c0c83ce9afe41d6657e3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/31/">«</a>
	<span class="pagination__item pagination__item--current">32/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/33/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>