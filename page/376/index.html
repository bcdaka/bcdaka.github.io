<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30261f23c9bdbab1b6ecdc500398cdc3/" rel="bookmark">
			Stable Diffusion 老照片修复&#43;高清化&#43;一键抠图教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家有没有一些老旧，珍藏的照片因为岁月的侵蚀变得模糊而感到惋惜？有没有在做SD的时候生成的图片清晰度不够，过于模糊？但是不知道如何把它变得更清晰呢？
如果有，那你就来对了，本期课程就是教大家如何用SD的功能把照片放大变得超清，同时还教大家如何把破旧的老照片变得不再模糊。
好，马上开干！
我们进入到stable页面之后，今天就要讲高清化，我今天讲的分别是extra高清化和stable SR脚本。我们先讲extra高清化吧！点击图生图右边的高清化extras按钮，有的版本也把高清化翻译成附加功能或者后期处理，其实功能都一样，我们先看这一行，有单张图像，批量处理，批量处理目录下图像。是不是跟上节课讲的图生图的非常像？单张图像只能处理一张照片，我们不能框选好多图片。我们只能一张一张点，假如说我点CTRL多选呢？不行，只能选择一张图片。然后批量处理就是可以一次处理多张图片，就可以框选多张图片了，这就是批量处理。批量处理目录下图像，就是直接处理你文件夹内的所有图片。假如说我想把测试图文件夹全部复制到里边去，shift+鼠标右建测试图文件夹，点击复制文件地址粘贴进去，之后把双报号删掉，输出目录路径，就是你在电脑里边新建一个新的空文件夹，必须是空文件夹！一定是以英文作为名字，把这个新文件夹路径复制到输出栏就可以批量处理了。我们今天先以单张图像去作为例子，下面这个缩放比例，原图是512×512，如果缩放比例调成2的话，输出图片的像素就会变成1024 1024的尺寸如果调到4的话是多少？4096×4096对不对？这是缩放比例。那么指定分辨率缩放是干嘛的？就是说本来我原图是512×512的，我不想把它变成等比例缩放，我想让它变成比如说1328*1104，原图是512×512正方形，做完之后是长方形。就在这里调整你要值，当你输入的图片的指定分辨率时，一定要勾选裁剪，不勾选整体的图片就是会成为一个拉伸的效果，就是硬拉伸的图片，所以一定要勾选裁剪以适应宽高比。今天我们就以等比缩放作为例子给大家展示。在讲解下面的obscu放大算法模型之前呢，我想先让大家下载一个新的模型算法，叫做4x-UltraSharp.pth,这个就是一个万能的放大模型，用它就对了！
后边我再给大家讲怎么安装。首先我们要先到这篇图文底部点开我的下载网盘地址，点击这个文件4x-UltraSharp.pth，点击下载就OK。下载完成之后呢，放到我们的sty v u根目录之后呢，我们点击models，然后点开ESRGAN里边，然后右键粘贴，或者直接把它拉进来，就完成了，
好，下面就是Upscaler1,Upscaler2，这两个就是放大算法的模型一打开之后发现这么多模型？我应该选哪个？根本不用担心啊，因为这里边有一个模型可以战胜所有其他模型，无脑用那一个4x-UltraSharp.pth就行，你只要知道在什么情况下用哪种算法就好。简单讲一下，前两个Lanczos和Nearest都是很传统的数学运算缩放算法，这两种算法几乎不会把你的图片变高净化，感觉像变了，但是没有完全变，我们以Lanczos举个例子，我们看一下原图，打开现在是这个样子的，然后再看一下对比图，两张的效果其实差不多，
我一会给大家解释这个Upscaler2是干嘛的，下一个EST差不多都是一样的，我就不给大家测试了，下一个4x-UltraSharp，这个就是我说的无脑用它就行，在放大图片的时候，你选它准没错，它放大任何图片都是又快，细节保留的又多，而且能让人变得更真实，不会出现那种磨皮过度的效果，我点击放大比例4倍，大家看一下效果，在这里放大看是不是非常的清晰？然后整体的皮肤的一些表面组织啊，其实它还是有保留的，虽然和真实人类的皮肤表层并不是那么像，但是它把原本应该留在皮肤上的一些噪点给保留下来了，这就是sharp的一个效果，是不是非常清晰，
其实我们自己可以做对比的。不知道他们有什么功能，我们就一个一个试就好了，大家也可以用之前课程讲过的X y z plot这个脚本来试，这比一个一个给演示要直观，下面这几个我就不讲了，我只讲这个ANEIME6B Anime就是动漫的意思，当我们想要放大动漫图片的时候，就用这个，其他一律都不要用，动漫就用它就好了。
所以当我们在对比所有的模型之后，哪个最好用？是不是就是这个呀？4x-UltraSharp做真人放大无脑用就行。动漫用ANEIME6BOK，大家知道这个就好。下面这Upscaler2什么时候去运用呢？因为在al sharp出现之前呢，好多其他的算法会出现磨皮过重的感觉，我们就要想办法给它做一个权衡，就是当它磨皮过重的时候，给它加一个去噪能力很差的一个算法，比如说第一和第二这两个其中一个，然后把它权衡一下，然后这个UPSCULE2可见度就是使用UPSCULE2模型在渲染时候的总占比，假如这里是0.3，就是30%的leg，然后剩下70%是alltra sharpop的模型运算，但是现在你有UltraSharp了，你就不需要去用它了，因为UltraSharp已经把好多的缺点给过滤掉了。下面讲一下这个GFPGAN面部修复程度，这个是专门修复面部损失的，当我们在修改面部模糊的时候，我们就把这2个UPSCULE全部改成none，然后缩放比例，这个调整固定4就OK。下面给大家看一下它的强大之处，这张图片。模不模糊我们放大看一下这张图片?放大之后这个样子的是不是很模糊?
当我们只有头像的这个图片很模糊的时候，我们就可以用到GFPGAN了，我们给大家看一下效果啊，点击生成，我们看一下放大过后是不是整体的图片变得很清晰了，面部的一些细节整体的样子是不是表现出来了，这就是GFPGAN面部修复的一个效果，但是它只可以把面部的细节变清晰，我们举个例子啊，假如说这张图片整体也是很模糊啊，但是它出来图片只有面部会变清晰，因为它会自动识别你的面部信晰，下面该模糊还是模糊，它是不会管你的，只会把你的面部细节保留变得更清晰。下面这个CodeFormer面部重建程度还是用那张照片吧，它跟GFPGAN都是修复面部呢，但是你在用CodeFormer的时候，它会把你面部的一些特征做改变，我们看一下把它调成1，我们看一下这边，左边这个眼睛是和原图会有一些差别的，我们看一下对比，这个是GFPGAN做出来的眼睛是这个样子，这个是Co former做出来的，大家觉得哪个更像原图啊？我是觉得第一个GFPGAN是更像原图的，OK,这两个可以同时开启，然后这个也是一个权重，面部修复权重为0的时候，它的效果是最大，1的时候它的效果最小，当你这两个同时用的时候，就可以用这个，
我们看一下这个面部修复程度，其实它就是在用我们这个面部修复用的一个算法，那么在哪里看呢？到设置里边有一个面部修复，你可以选择Co former或者GFPGAN，那这里它用的这个former weight是0.5，当你在做面部修复的时候其实建议大家还是选GFPGAN，因为如果你调成这个Co form模式，你会发现本来原图的面部细节会有所更改，这就是为什么它翻译的时候叫做面部重建程度，下面我讲一下这个remove background，大家看看自己的里面有没有这个插件?如果没有我教大家怎么安装，我把课程上所有插件的下载地址都放到本课程的最后面，大家自己去下载。这个插件叫做future web UI re BG,就叫做remove background,我们把网址复制到从网址安装，然后点击安装就OK了，然后安装好后点击应用并重启web UI完成后我们回到高清化，这个REMBG是干嘛的？这个是非常强大的抠图功能，打开这里边有这么多算法，我们看一下官方怎么解释这些模型呢？OK,第一个U2NET，它就是一个预训练模型，For general use cases,就是大部分的图片都是可以用这个算法。第二个U2NETp,我试了几次，它在抠图的时候精细程度没有第一个好。第三个*u2net_human_seg就是在我们做人类分割的时候用这个模型比较好，这个U2net cloth seg是非常强大的，当我们在做模特换装的时候用的比较多，它就会自动把人物主体的上衣和下衣直接给抠出来。我一会儿给大家看一个例子，然后这个salutta c这个就和U2NET很像啊，那下面这个is enemy,这个是专门给动漫抠图的，我们在想抠动漫图的时候就用它就OK了，Sam这个是我们模型里面没有的，因为它呢是另外一个插件，后面给大家讲，那个也是很强大的，我们先做例子，就先拿这个U2NET做例子，GFPGAN这些我们可以不调，先做个测试，我们假如说用这张用U2NET做测试，大概也就两秒钟的时间，他就把整张图片给抠好了，我们看下效果整体还是相当不错的，我们把它换成白底看一下，就会发现边缘有黑边，黑边怎么调整？勾选用Alpha ma调整就可以了，我们再看一下return mask return MAS就是把它变成蒙版，是不是就是我上节课讲的局部重绘的那样子？做的蒙版就直接给抠出来了，如果你不会用PS把图片抠出来，就用这个。我们看一下这个Alpha里面的数值啊，ErodeSize翻译就叫做腐蚀尺寸，就是保留主体的边缘留下的一些像素，它这个可以避免边缘太生硬的一个效果啊，因为有的时候我们在抠图的时候，边缘是直的，非常生硬，在我们做重绘的时候就效果不是很好，就是类似于边缘模糊，数值越高，图片的边缘范围保留的细节就会越多，但是不建议开太高啊，越低越好，因为我们不想让图片保留细节太多，假如说我们把它调成40，出来的图周围的一些背景保留的非常多，整体效果就不是非常好，但是它把你的黑边给去掉了，虽然是没有黑边，但是这个抠图整体还需要调整，怎么去做调整呢？下面Foreground 和background这两个干嘛的？Foreground 就是保留主体的前景预值，前景预值越高，去除前景的元素就越多，背景预值越高，去除背景的元素就越多，但是调太高时主体的元素也会被抠掉。在我反复试验几个小时左右后，终于研究出了一个相当完美的预设，就是模型就用这个，然后e size调成6，然后Foreground 调成143 background调成187。我试了几张图片啊，整体是没有黑边，并且抠图效果比较不错，但是每张图片的测试都是不一样的，当大家在抠图的时候发现效果不好，或者黑边很严重，试一下我这个预设，这可是我花很长时间试验出来的一个不错的预设，我们看一下整体的人物是不是没有黑边，并且背景也几乎是没有保留的，整体是一个很完美，整体的效果是最不错了，所以大家可以试一下我这个预设啊，下面还有一个UN cloth c,看一下效果，它能把衣服给抠掉。我们看一下是不是把上衣还有裤子全部给抠掉了，这个什么时候用比较多呢？一般是用这些mask直接变成蒙版，只不过这个下边边缘是有一点瑕疵，还有一个缺点就是不知道为什么衣服这两张图片隔的那么远啊，当使用这种方式抠衣服蒙版的时候，我们还是需要去后期PS或者其他软件里边调整一下才行。有一点非常重要的事情要跟大家讲一下，如果你是用启动器打开了SD，安装了re BG这个插件，在你第一次生成的时候大概率会报错，报什么错呢？会报一个类似于这样runtime error,然后是provider library get on n n X runtime error,我用的时候也是报这个错了，我研究了一晚上，最后终于知道原因了，必须是在你的web UI这个文件夹，然后后边再输入一个斜杠，输入PY310，然后回车，回车之后进入到这个文件夹，然后你输入CMD，打开终端口，把这串命令输入上去，然后点击回车，回车之后如果你看到这个页面，就代表你安装成功。那完成之后，你把web UI重启一下，然后再用这个remove background就可以了，这个真的是研究了一晚上才研究明白，如果你也遇见了同样的问题，同时在我的帮助下解决了，请一定点赞转发。最后再顺便给大家讲一下图像信息，就是在我们做文声图或者图生图的时候，当我们只保留了图片，但是忘记了这些参数和关键词的时候，我们用这个图像信息比较不错，怎么用呢？假如说我们用一个图生图的作为例子啊，到图生图文件夹用一张照片，回到图像信息图片，我们把它拖过来，然后右边就会直接生成这张图的一些关键词，像正向提示词，反向提示词，然后你的采样部署，采样器，C fg skill，还有一些种子等细节都会保留在这里。OK,这就是我今天给大家讲的内容，如何通过SD把你的模糊图片变得高清。如果觉得我的教程对你非常有帮助，希望给我点赞转发，大家关注我，轻松掌控AI！
写在最后 AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
感兴趣的小伙伴，赠送全套AIGC学习资料和安装工具，包含AI绘画、AI人工智能等前沿科技教程，模型插件，具体看下方。
一、AIGC所有方向的学习路线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30261f23c9bdbab1b6ecdc500398cdc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74470efb56eb7afecba7806c33203606/" rel="bookmark">
			深度技术解读AlphaFold3: 谷歌第三代AI工具精准预测生物大分子四级结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然界每一种植物、动物和人类细胞内部，都包含有数以亿计的分子机器。这些分子机器由蛋白质、DNA、RNA及其他配体分子组成。正是这些由生物大分子组成的小型机器，维持着生命的运转和延续。从本质上来讲，生命就是建立在分子层面的结构支撑，以及分子之间的相互作用。因此，准确计算和预测我们体内的生物大分子的原子结构以及分子与分子之间的相互作用，是理解人体疾病机理、理性设计药物、改善人体健康的关键起点。
2024年5月9日，DeepMind与Isomorphic Labs的研究人员在国际顶级杂志《Nature》发表了题为“使用 AlphaFold 3 准确预测生物分子相互作用的结构” （Accurate structure prediction of biomolecular interactions with AlphaFold 3） 的研究论文（图1）。该研究开发了一款新的被称做AlphaFold 3的人工智能（AI）软件，以前所未有的精确度，成功预测了几乎所有生命大分子（蛋白质、DNA、RNA、配体等）的结构和相互作用。
图1. DeepMind和Isomorphic Labs团队在最新一期《Nature》发表AlphaFold3 论文截图。
这种用计算机精准预测和解析蛋白质与其他分子复杂相互作用的能力，有助于为疾病通路、基因组学、治疗靶点、蛋白质工程及合成生物学等领域带来新见解。更重要的是，AlphaFold3 为药物研发开辟了令人兴奋的可能性，有望颠覆传统的药物研发模式。
谷歌研究团队希望AlphaFold3能够帮助我们重新认识生物世界、重新思考药物发现。值得一提的是，科研工作者可以免费使用AlphaFold3的大部分功能(https://www.alphafoldserver.com/)。为了进一步挖掘AlphaFold3在药物开发和设计方面的潜力，Isomorphic Labs已经与制药公司合作，将它应用于现实世界的挑战，最终开发出治疗人类最致命疾病的新疗法。
DeepMind对结构生物学的颠覆史 过去10年来，谷歌DeepMind团队在生命科学（特别是结构生物学）领域不断创造新的奇迹。该团队创造这些奇迹的主要利器就是人工智能和深度学习。而这可能要从他们在围棋领域的开创性工作说起。
2016年1月，DeepMind团队在国际著名杂志《Nature》发表了基于人工智能的围棋新算法（AlphaGO）。同年3月，AlphaGO 以4:1的比分，击败韩国职业九段棋手李世石；次年5月，更新版的AlphaGO以3:0的比分，战胜当时世界排名第一的围棋棋手柯洁。这一系列胜利掀开了围棋历史的新篇章，彻底改变围棋训练和竞赛的模式（图2）。
图2. DeepMind开发的AlphaGo第一次战胜人类顶尖围棋棋手李世石九段。
随后，DeepMind转战生物科学领域。
2018年，DeepMind利用卷积神经网络技术，训练出第一代AlphaFold（俗称 AlphaFold1）。AlphaFold1于2018年5月参加第13届国际蛋白质结构预测（CASP）大赛，并且取得不俗战绩。此时的AlphaFold虽然超出了人们的预期，但是与其他顶级研究团队（包括密歇根大学张阳教授团队）相比，并没有明显的优势。在不同的评价指标和范畴下（比如基于模板的TBM蛋白组，图3），其他团队甚至超过AlphaFold1的成绩 (Groups Analysis: zscores - CASP13)。AlphaFold1论文于2020年1月在《Nature》上发表。
​
图3. DeepMind开发的AlphaFold1第一次参加国际蛋白质结构预测CASP13。此图是CASP13基于模版的TBM蛋白组预测结果，其中密歇根大学张阳团队（Zhang）的整体结构预测精度高于AlphaFold1 (A7D) 的预测精度。
2020年，DeepMind发布第二代AlphaFold（也称AlphaFold2），并参加2020年的第14届CASP大赛。AlphaFold2引进新的Transformer网络，首次实现端到端的机器模型训练。在CASP14上，AlphaFold2在所有的结构模型范畴，甚至是在几乎所有的单个蛋白目标，都遥遥领先于其他参赛团队。这也是DeepMind在生命科学领域，第一次惊艳所有科学家的眼睛，真正的显示了人工智能在解决复杂生命科学上的巨大威力。尽管如此，此时的AlphaFold仅限于蛋白质单链的结构预测，对更加复杂、也更加重要的生物大分子复合物的结构预测尚未涉足。AlphaFold2论文于2021年7月发表在《Nature》期刊上。
​
图4. DeepMind开发的AlphaFold2第二次参加国际蛋白质结构预测CASP14。AlphaFold2的结果预测精度远远超出所有其他参赛团队的预测结果。这是AI第一次在生命科学领域展现巨大威力。
2021年10月，DeepMind团队将AlphaFold2进一步推广到AlphaFold-Multimer，对蛋白质-蛋白质复合物的四级结构进行预测。尽管突破了该领域的传统，但是AlphaFold-Multimer在复合物的精度只达到了23%（即可以对23%的复合物产生高精度预测结构，改进后版本达到36%），比它在单链蛋白质上所创造的2/3左右的高精度蛋白预测成功率仍然逊色不少。显示出，蛋白质复合物的结构在当时仍然是一个远没有被解决的问题。AlphaFold-Multimer于同期发布在bioRxiv预印本网站上。
​
图5. 2021-2022年，DeepMind在未经同行审议的预印本网站bioRxiv发布AlphaFold-multimer，预测蛋白质-蛋白质相互作用的复合物结构。
2023 年11月，笔者曾撰文介绍DeepMind研究团队当时发布的最新一代 AlphaFold （论文称之为AlphaFold-last，但是考虑到该模型的进展我们称其为AlphaFold3）。该研究显示其最新的模型现在可以对蛋白质数据库 (PDB) 中的几乎所有分子类型进行预测，通常达到原子精度。
​
图6. 笔者于2023年11月在CSDN社区第一次介绍AlphaFold3的初步结果（原文链接：https://blog.csdn.net/weixin_4528312/article/details/134238052）。
鉴于AlphaFold的强大能力，谷歌从DeepMind拆分出了一家名为Isomorphic Labs的新药研发公司，致力于使用人工智能加速药物研发。
2024年5月9日（也就是今天），DeepMind与Isomorphic Labs的研究人员在 《Nature》 期刊发表了题为：Accurate structure prediction of biomolecular interactions with AlphaFold 3 的研究论文。该研究正式发布AlphaFold 3程序和研究算法，以前所未有的精确度成功预测了所有生命分子（蛋白质、DNA、RNA、配体等）的结构和相互作用。与现有的预测方法相比，AlphaFold 3 发现蛋白质与其他分子类型的相互作用至少提高了 50%，对于一些重要的相互作用类别，预测准确率甚至提高了一倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74470efb56eb7afecba7806c33203606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5bd0a989eff43f7ee7fed3e0110f43/" rel="bookmark">
			一文详解DCMM（数据管理能力成熟度评估模型）贯标评估全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，工信部组织中国电子信息行业联合会积极推进DCMM在各行业的贯标应用，2022年全年共完成企业贯标评估1040家。
各地方政府，进一步加快推动我国DCMM贯标评估，提升企业数据管理能力和数字化转型，进一步优化与夯实本地区数字经济发展环境与产业基础。目前已有20个省市及地区的政府出台了相关政策，支持本地区企业开展DCMM贯标活动，对获取DCMM贯标等级证书的企业给予不同程度的奖励，有力地推动了全国DCMM贯标活动的快速发展。
总的来看，DCMM贯标活动在全国范围内已初步形成一定社会影响力，并科学有效地帮助贯标企业掌握数据管理方法、提高数据管理能力，有效的促进数据要素价值释放。
关于DCMM常见相关问答，具体包含如下几项内容：
什么是DCMM？
如何开展DCMM贯标评估工作？
具体的流程、方法、步骤是什么？
DCMM的价值？
评估基础篇 1、DCMM是什么？
工信部信软司、国家市场监管总局标准技术管理司于2014年成立全国信标委大数据标准工作组，从事国家大数据领域标准化工作，负责对ISO/IEC JTC1／WG9国际标准归口工作。工作组成立当年，DCMM国家标准立项，正式启动研制工作，经过近4年的标准研制、试验验证，2018年3月15日正式发布，是我国数据管理领域最佳实践的总结和提升。
DCMM是《数据管理能力成熟度评估模型》（GB/T 36073-2018）国家标准，英文名称Data management Capability Maturity Model。
DCMM是我国首个数据管理领域正式发布的国家标准，旨在帮助企业利用先进的数据管理理念和方法，建立和评价自身数据管理能力，持续完善数据管理组织、程序和制度，充分发挥数据在促进企业向信息化、数字化、智能化发展方面的价值。
DCMM的定位和作用 2、DCMM的评估模型是怎样的？
DCMM国家标准结合数据生命周期管理各个阶段的特征，按照组织、制度、流程、技术对数据管理能力进行了分析、总结，提炼出组织数据管理的8大能力域，并对每项能力域进行了二级能力项（28个能力项）和发展等级的划分（5个等级）以及相关功能介绍和评定指标（441项指标）的制定。
3、DCMM的评估有哪几个等级？
DCMM将数据管理能力成熟度划分为五个等级，自低向高依次为初始级（1级）、受管理级（2级）、稳健级（3级）、量化管理级（4级）和优化级（5级），不同等级代表企业数据管理和应用的成熟度水平不同。
4、DCMM与其他常规体系相比有什么区别和不同
DCMM与ISO、CMMI相比，一是评估对象更加广泛和行业化；二是评估内容聚焦于企业和组织的数据管理能力；三是评估作用帮助企业和组织提升数字化转型的核心驱动力。
5、DCMM与国外的DAMA有什么区别和联系？
DAMA知识体系是对数据治理工作提出的一套理论框架。其体系结构与PMI的PMP类似，其内容非常详尽，DCMM在编制过程中，也充分吸收了DAMA的优点，并对其中不符合中国企业发展实际的内容进行了摒弃。
从企业自身管理角度来说，选择DAMA体系和DCMM体系都可以，但目前国内政府和企业对于DCMM的宣传力度更高一些，DCMM是全国信标委出台的标准，可以视作是官方出台，而DAMA是协会组织，其DAMA数据管理知识体系及其“数据管理专业人士认证”获行业广泛认可。
6、什么样的企业可以申请DCMM评估？
DCMM是针对一个企业数据管理和应用能力的评估框架，从标准本身来讲，任何企业都可以做相关的申请。从评估流程来说，可以分为两个方面：
数据拥有方（评估自身的数据管理和应用能力）：可以评估数据拥有方在数据管理方面存在的问题并给出针对性的建议，帮助其提升数据治理能力水平。（比如金融与保险机构、互联网企业、电信运营商、工业企业）数据解决方案提供方（评估对外提供的产品及服务的数据管理和应用能力）：通过该标准的实施落地，可以帮助数据解决方案提供方完善自身解决方案的完备度。（比如软件开发/运营商、信息系统建设和服务提供商、信息技术服务提供商等） 7、DCMM评估机构有哪些？
当前，中国电子信息行业联合会在全国范围内遴选了7家评估机构，都是工信部直属事业单位：
赛迪检测认证中心有限公司、北京赛西科技发展有限责任公司、北京赛昇科技有限公司、北京工联科技有限公司、广州赛宝认证中心服务有限公司、南京新一代人工智能研究院有限公司、威海神舟信息技术研究院。
8、DCMM评估的价格如何？ 目前来说，市场上并没有统一价格。通过查看部分公示企业的招标文件，一般2级企业在15~20万，3级企业在30万左右，4级企业在50万左右，根据企业的能力情况和人员匹配情况略有浮动。
评估流程篇 9、DCMM的评估流程是怎样的？周期需要多久？
整个流程因为等级申请在时间周期上有所差异，基本上在1~2个月时间，主要依据DCMM专家委员会审核周期来确定。
具体评估流程图如下：
DCMM评估流程
（1）评估准备阶段：被评估方参照DCMM标准建立、健全数据管理体系，内部运行开展自评估，也可以通过贯标咨询机构协助对标，并向第三方评估机构提交有效的申请材料。
（2）正式评估阶段：评估机构受理评估申请后，组织现场评审并出具评估报告，给予评估等级的推荐意见，并报评估工作部备案。
（3）结果评议阶段：评估工作部对评估机构报送的评估结果进行合规性审查，对于合规性审查中发现存在较大问题的评估结果有权驳回。对于评估机构推荐的优化级、量化管理级和优化级的评估结论，评估工作部需组织专家对评估结果进行评议。评估工作部对通过审查、复核或评议的，进行为期一周的公示。对公示后无异议的，由评估机构颁发数据管理能力成熟度评估证书。
10、在评估的过程中，主要通过哪些方式进行？
（1）审查文件和记录：包括公司层面及部门层面的规章、制度、规范和管理规定等，以及公司在管理过程中的过程文档，如会议纪要、会签记录等。
（2）观察数据管理过程和活动：重点了解数据管理系统/平台/工具的相关功能和使用记录。
（3）人员访谈：对公司的规章制度执行以及数据管理平台使用情况进行核验，确认其实施过程与客观证据是否保持一致。
11、企业想申请评估，如何初步判断评估等级？
DCMM评估包含的内容也较多，且向下兼容，所以申请高等级评估同时需要满足低等级的要求。简易评估要点主要包含企业规模、数据管理人员、数据管理制度和数据管理工具与平台等维度：
12、企业目前制度标准还不够规范，如何能够获得比较高等级的证书？
与其他的资质认证一样，企业可以选择通过贯标咨询来提升能力，但是由于整个DCMM工作开展时间不久，所以很多咨询机构只是在尝试性开展业务，评估能力良莠不齐，需要做好甄别。
通常DCMM贯标流程主要分为三个阶段：
Step1：差距分析：贯标启动，进行差距分析。Step2：能力建设：建立数据管理组织，完善制度，内部运行并开展自评估。Step3：测量评估：组建评估队伍，开展第三方评估，获取评估报告和能力证书。 DCMM贯标流程
13、在评估过程中，企业主要有哪些人参与？
从企业评估过程中来看，一般来说，数据战略和治理需要的是管理人员，其余6个能力域需要的是技术人员，从实际评估角度来说，企业匹配人员一般在3-8个，在申请比较低的等级过程中，一个人可以覆盖2~3个能力域。
能力域
参与人员
数据战略
组织负责人、数据管理负责人、数据管理执行官等
数据治理
数据管理负责人、数据管理执行官等
数据架构
数据架构师、数据仓库架构师、数据模型管理员等
数据应用
应用架构师、BI架构师、报表开发人员等
数据标准
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b5bd0a989eff43f7ee7fed3e0110f43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6559a04df237e3b19b988695266de42d/" rel="bookmark">
			【高阶数据结构(二)】初识图论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:高阶数据结构专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多Go语言知识
🔝🔝
高阶数据结构 1. 前言2. 图的基本概念3. 关于图的专业名词4. 图的存储结构4.1 邻接矩阵4.2 邻接表4.3 优缺点分析 5. 图的模拟实现6. 总结以及拓展 1. 前言 相信在大学中学过离散数学这门课的同学一定对图比较熟悉. 为了照顾没有学习过图的同学,本系列文章会当作无基础来讲解
本章重点:
本篇文章着重讲解图的基本概念,关于图的一些专业名词,以及图的两个存储结构: 邻接矩阵和邻接表. 期间会带大家模拟实现邻接矩阵版本的图
2. 图的基本概念 图是由顶点集合,以及边集合组成的一种数据结构: G = (V,E).
概念很抽象,可以简化为下图:
G1中的顶点就是结点0,1,2,3.记作v1,v2…,两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中的第k条边记作ek，ek = (vi，vj)或&lt;vi，vj&gt;. 再看G2,这不是一颗二叉树吗?是的,可以将二叉想象为图的一种表现形式. 除此之外, 图还分为有向图和无向图, 有向图代表顶点之间的边是有方向的, 无向图代表边是无方向的,如下图所示:
3. 关于图的专业名词 完全图: 在有n个顶点的无向图中，若有n * (n-1)/2条边，即任意两个顶点之间有且仅有一条边,则称此图为无向完全图. 上图的G1就是无向完全图, G4为有向完全图邻接顶点: 若顶点u和v有直接的边相连, 那么它们这两个顶点就称为邻接顶点顶点的度: 顶点v的度是它相关联的边的条数，记作deg(v)。在有向图中，顶点的度等于该顶点的入度与出度之和，其中顶点v的入度是以v为终点的有向边的条数，记作indev(v);顶点v的出度是以v为起始点的有向边的条数，记作outdev(v)。因此：dev(v) = indev(v) + outdev(v)。注意：对于无向图，顶点的度等于该顶点的入度和出度，即dev(v) = indev(v) = outdev(v)。 路径: 若顶点A可以到达顶点B, 则从A到B经过的所有顶点就是A到B的路径. 对于不带权图,路径长度等于边数之和,带权图则是权值之和 简单路径与回路: 一条路径中如果没有重复的点,那么就是简单路径,有重复的点证明有回路连通图: 连通图：在无向图中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。如果图中任意一对顶点都是连通的，则称此图为连通图 这些概念很多,很杂,不用全部背下来, 有个印象,后面使用时不至于听不懂就好了.可以联想到, 微信,QQ等社交平台一定是无向图,因为我是你好友的同时你必须也得是我好友.像抖音,快手,微博这种弱社交平台, 用的是有向图, 因为我关注了一个博主并不代表这个博主也要关注我
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6559a04df237e3b19b988695266de42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bbd6368491c1a02a150856d2f72f12b/" rel="bookmark">
			[C&#43;&#43;] 类和对象：运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在C++中，运算符重载是一种强大的特性，它允许我们重新定义已有的运算符，以便用于用户自定义的数据类型。通过运算符重载，我们可以使得我们自定义的类对象像内置类型一样进行运算，这为编写清晰、简洁且易于理解的代码提供了便利。
为什么要进行运算符重载？ 在学习运算符重载之前：
我们对于内置类型的运算是这样的：int = int + int;
但是我们对于自定义类型的类无法使用简单的运算符进行运算，我们需要特别得去写一个函数或者一段过程性代码来实现这个功能。
使用重载运算符：
比如说在一个日期类内有该重载 bool operator==(const Date&amp; d2) { return _year == d2._year; &amp;&amp; _month == d2._month &amp;&amp; _day == d2._day;	} 该代码就是对“”运算符的重载，之后通过使用”“就可以对比日期类的两个对象（根据该运算是否有意义来决定）。
使用时的代码就是如此：d1 == d2。
运算符重载的语法 函数原型：**返回值类型 operator操作符(参数列表)** 注意：
不能通过连接其他符号来创建新的操作符：比如operator@重载操作符必须有一个类类型参数用于内置类型的运算符，其含义不能改变，例如：内置的整型+，不能改变其含义作为类成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐 藏的this
. * :: sizeof ? : . 注意以上5个运算符不能重载。这个经常在笔试选择题中出 现。
以日期类进行举例：
①非成员函数重载：
bool operator==(const Date&amp; d1, const Date&amp; d2) { return d1._year == d2._year &amp;&amp; d1._month == d2._month &amp;&amp; d1._day == d2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bbd6368491c1a02a150856d2f72f12b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7b37b7ec353cc0f3bcb071857bbbbd/" rel="bookmark">
			Oracle SQL Developer导出数据库表结构，表数据，索引以及序列号等对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、业务需求
三、环境说明
三、数据导出
四、数据导入
一、业务需求
通过Oracle SQL Developer软件将指定oracle数据库中的表结构，表数据，索引以及序列号等对象导出成SQL文件。
三、环境说明
数据库版本：Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production
软件版本：Oracle SQL Developer Version 21.4.3.063
操作系统：Windows 11 三、数据导出
在左侧多选中需要导出的对象(表，索引，序列号等都可以)，右键选择Export
勾选导出的设置项，一般默认即可，其中Encoding编码一定要选择UTF-8，否则数据如果有问题会出现乱码的情况，重新导入后是???这种
File这里是指定导出的SQL保存路径和名字
Next后可以看到导出的信息汇总，需要确认清楚再点finish开始
开始导出...
sqlplus username/password@database @your_script.sql &gt; output.log 导出成功后会有弹窗
这里就导出完成了
另外啰嗦两句：如果导入时表空间跟导出时表空间不一样，可以编辑.sql文件替换里面表空间名字再执行导入
四、数据导入
使用SQL*Plus工具来执行SQL脚本并将输出重定向到日志文件
# 利用sqlplus工具导入 sqlplus username/password@database @your_script.sql &gt; output.log 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4911e7ea503506ef066156d08f33f078/" rel="bookmark">
			【大数据】分布式数据库HBase下载安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.下载安装
2.配置
2.1.启动hadoop
2.2.单机模式
2.3.伪分布式集群
1.下载安装 HBase和Hadoop之间有版本对应关系，之前用的hadoop是3.1.3，选择的HBase的版本是2.2.X。
下载地址：
Index of /dist/hbase
配置环境变量：
之前在PATH中已经配置了JAVA的环境变量，直接用:隔开，追加一个hbase的环境变量
export JAVA_HOME=/jdk/jdk8 export PATH=$JAVA_HOME/bin:$PATH:/hbase/hbase-2.2.2/bin export CLASSPATH="." 刷新环境变量：
source /etc/profile 查看是否生效：
hbase version 2.配置 HBASE有三种模式：
单机模式
伪分布式模式
分布式模式
分布式模式太吃机器性能了，学习来说的话伪分布式模式就够了。本文将会讲解单机模式和伪分布式模式的配置。
运行HBase的前置环境：
JDK
对应版本的Hadoop
SSH
以上环境在我们之前安装hadoop的时候就已经安装过了，此处不再赘述。
2.1.启动hadoop 我用的Windows的wsl版本的ubuntu，所以没有用systemctl命令，而是用service命令来直接启动服务。
hbase依赖于hdfs，所以要先启动hdfs，hdfs依赖于ssh，所以最先启动ssh。
service start ssh ./sbin/start-dfs.sh 2.2.单机模式 在HBase的单机模式下，所有HBase组件（包括HMaster、HRegionServer以及ZooKeeper）都运行在一个JVM进程中，且不依赖于Hadoop的HDFS，而是直接使用本地文件系统来存储数据。
HBase的配置文件所在位置：
vi /hbase/hbase-2.2.2/conf/hbase-env.sh 配置如下内容：
export JAVA_HOME=/jdk/jdk8/ #设置JDK路径 export HBASE_MANAGES_ZK=true #HBASE本身自带一个zookeeper，设置使用自带的zookeeper，而不是外界的 配置
vi /hbase/hbase-2.2.2/conf/hbase-site.xml 设置rootdir，用来存储hbase的数据，不设置数据的存储路径的话，每次重启hbase都会丢数据。
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;file:///usr/local/hbase/hbase-tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 启动HBase：
./bin/start-hbase.sh 进入交互式界面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4911e7ea503506ef066156d08f33f078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2611f490a9bb8f5f9caad8489734ea/" rel="bookmark">
			【c&#43;&#43;】继承学习（三）菱形继承的挑战与虚拟继承的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页：Quitecoder
🔥专栏：c++笔记仓
朋友们大家好，本篇文章来讲解继承的第三部分，有关多继承和菱形继承的内容
目录 `1.菱形继承``2.虚拟继承``3.虚拟继承解决数据冗余和二义性的原理``4.继承的总结和反思``继承和组合` 1.菱形继承 单继承：一个子类只有一个直接父类时称这个继承关系为单继承
多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承
菱形继承：菱形继承是多继承的一种特殊情况
菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。
在Assistant的对象中Person成员会有两份
class Person { public: string _name; // 姓名 }; class Student : public Person { protected: int _num; //学号 }; class Teacher : public Person { protected: int _id; // 职工编号 }; class Assistant : public Student, public Teacher { protected: string _majorCourse; // 主修课程 }; void Test() { Assistant a; a._name = "a"; } 这样会有二义性无法明确知道访问的是哪一个
需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决
a.Student::_name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2611f490a9bb8f5f9caad8489734ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ca702d75475c29f115ba3e15877baa/" rel="bookmark">
			链表带环问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在链表的学习中，我们有时候会遇到环形链表，那么环形链表是什么呢？下面由我为大家讲解！
一，什么是环形链表 哈哈哈~~其实也就是带环的链表啦~~
如图所示
又或者是这样
所以带环链表有一个特性，进入就会出不来，进入了死循环~~！
二.关于环形链表的经典问题 1.下面有一道例题
这一题的最好想象的思路便是快慢指针，那么什么是快慢指针呢？
（1）快慢指针
首先，对链表的操作基本都是靠指针去完成的，因此肯定需要一个指针去维护这个链表，但环形链表有一个很重要的特性：就是由于有环状结构，因此指针一旦进入环状，就会在一直在链表里面，永远走不出来。因此我们应该用两个指针，一个遍历速度快一点，另一个遍历速度慢一点，简称“快慢指针”。
（2）思路
引用快慢指针之后，一旦慢指针进入环，通过快慢指针的速度差，当快指针追上慢指针的时候，就代表链表是环状的，否则快指针一旦为空，就说明链表不是环状链表。
即快慢指针相遇的时候，就可以表示它们带环！
我们这边先假设快指针比慢指针多走1步，即快指针走两步，慢指针走一步~
我们这样就容易得出代码
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ bool hasCycle(struct ListNode *head) { struct ListNode * slow=head,*fast=head; while(fast&amp;&amp;fast-&gt;next) { fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; if(slow==fast) return true; } return false; } 三.其中存在的问题 这样就可以得出代码~~~
但是爱思考的人都会想
1. 为什么一定会相遇？有没有可能错过或者永远的追不上？
2. 满指针走1步，快指针走3步，4步，5步或者n步是否能解决问题?
下面我们先解决第一个问题~ 首先我们假设slow(慢指针）进入环的时候与fast（快指针）的距离为n
这样就解决了第一个问题~！
再来第二个问题 首先fast先走3步
我们还是假设slow进入fast时距离为N（下面都是如此）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ca702d75475c29f115ba3e15877baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60924188a4bfdf98581fb9b2eaf004b5/" rel="bookmark">
			node:internal/modules/cjs/loader:1148 throw err； Error: Cannot find module ‘C:\Users\用户\AppData\Roa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装完nodejs，vscode中执行 npm -v 报错
报错信息
node:internal/modules/cjs/loader:1148 throw err;
Error: Cannot find module ‘C:\Users\用户\AppData\Roaming\npm\node_modules\npm\bin\npm-cli.js’
**1.**先在 cmd中执行
where node 找到你的node路径
**2.**执行下面命令显示全局 npm 包安装的根目录路径
npm root -g **3.**重新设置node路径
npm config set prefix "C:\Program Files\nodej" **4.**检查下是否成功
where node
路径正确后，再次在vscode中执行npm -v 命令执行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a7492f5d0e2be44931eddf018ea510/" rel="bookmark">
			数据结构（c）：队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🍺0.前言
1.什么是队列
2. 队列的实现
2.1定义队列节点
2.2定义队列
2.3队尾入队列
2.4判断队列是否为空
2.5队头出队列
2.6 队列首元素
2.7队尾元素
2.8队列内的元素个数
2.9销毁队列
3.试运行
💎4.结束语
🍺0.前言 言C之言，聊C之识，以C会友，共向远方。各位博友的各位你们好啊，这里是持续分享数据结构知识的小赵同学，今天要分享的数据结构知识是队列，在这一章，小赵将会向大家展开聊聊队列。✊
1.什么是队列 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 队列：进行插入操作的一端称为队尾 出队列：进行删除操作的一端称为队头 队列图片
​
其实上面说了很多，但其实队列很简单，正如它的名字一样，队列就是排队。
​
总结一下规律就是先进先出，就跟我们排队一样，谁排第一，谁的请求就可以先被执行。 2. 队列的实现 那么队列该怎么实现呢，其实也就前面两个方式，一个数组，一个链表，这里小赵并不推荐用数组，因为如果我们用数组的话，一直出头元素，会让我们很难确定这个时候我们的对头在哪里。所以这里小赵更推荐使用链表，因为链表可以使用我们的next的指针去找到下一个头。
2.1定义队列节点 typedef int	QDataType; //创建一个节点 typedef struct QNode { QDataType data; struct QNode* next; }QNode; //队列 typedef struct Queue { QNode* front;//队头 QNode* rear;//队尾 int capacity;//队列中的元素 }Queue; 2.2定义队列 //定义队列 void Queueinit(Queue*Qhead) { Qhead-&gt;front=NULL； Qhead-&gt;rear = Qhead-&gt;front; Qhead-&gt;capacity = 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a7492f5d0e2be44931eddf018ea510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e982f59d4292d0b6017556ec781a5d/" rel="bookmark">
			mac电脑装双系统的利弊 mac装双系统对电脑影响大吗 macbook装双系统会降低安全性吗 mac电脑安装windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		macbook是一款稳定性高，性能强的笔记本电脑，在办公场景中被广泛使用。但可以在macbook安装的应用程序相较于windows笔记本电脑要少很多，通常会通过在macbook中安装双系统的方式来解决应用程序少的问题。下面就让我们来看macbook装双系统有什么影响，以及macbook装双系统会不会降低安全性等的问题。
mac电脑装双系统的利 在macbook中装双系统有着双面的影响，好的方面是可以在macbook中正常打开windows专属文件，以及安装windows应用程序。
1、互相切换，使用方便：
可以在保留原来的系统上再安装一个新系统，两个系统互不干扰，可以互相切换，使用方便。
2、操作逻辑适应：
苹果系统的操作逻辑可能与用户习惯不同，例如关闭程序的按钮位置和鼠标滚轮方向等。安装Windows系统可能更符合用户的操作习惯。
3、测试兼容性和杀毒方便：
安装双系统可以在不同环境下测试软件的兼容性，同时也方便杀毒和数据备份。
4、玩游戏的兼容性好：
苹果系统在游戏的兼容性方面不如Windows，许多国内游戏可能无法在苹果系统上安装。安装Windows系统后，游戏体验可能会有所提升。
5、用来办公更加方便：
苹果系统功能也是很强大的，但是用来办公非常不方便，是由于一些常用的exe软件无法在苹果系统上安装，在苹果系统上安装windows系统就就显得非常必要。
mac电脑装双系统的弊 1、开机速度变慢：
安装双系统后，每次开机都需要选择运行哪个系统，这可能会增加开机时间，每次开机都要重启。
2、电脑发热问题：
苹果电脑的硬件和主板是针对Mac系统设计的，安装双系统后可能会导致电脑发热量增加。
3、硬盘容量占用：
安装双系统需要占用一定的硬盘空间，如果硬盘空间本身较小，这可能成为一个负担。
4、系统菜单可能出现问题：
使用过程中，如果有一个系统崩溃，那么另一个系统也会崩溃。
MacBook装双系统会降低安全性吗 安装双系统的原理是在同一块磁盘中划分出一块装载windows系统的空间，那么如果在使用windows系统过程中感染了计算机病毒，同样会感染macOS系统。也意味着，安装双系统后macbook的安全系数会降低。
同样，使用杀毒软件对windows系统进行查杀，也会将macOS系统内的病毒查杀干净。
如何在Mac系统运行exe程序 exe文件是windows系统中专属的执行文件，那么我们怎么在macOS系统中打开呢？
MacBook装双系统是会降低安全性的，如果你想在Mac系统运行exe程序，或者想在Mac电脑上玩更多的Windows游戏，那我们推荐你在MacBook使用类虚拟机软件CrossOver。
它的核心功能是在Mac和Linux系统上无缝运行Windows应用程序。与传统的虚拟机软件不同，CrossOver不需要模拟整个Windows操作系统，而是通过直接在宿主系统上运行Windows应用程序的二进制代码来实现高效兼容。这种方式不仅提高了运行效率，还减少了资源占用。
无需重启或双系统：用户可以在不重启计算机或安装双系统的情况下，直接在Mac或Linux上使用Windows软件。
一键安装：CrossOver内置了海量的应用程序兼容中心，用户只需点击一下即可自动下载、安装和配置所需的Windows软件。
无缝集成：Windows应用程序在CrossOver中运行时，可以与Mac或Linux系统的文件、剪贴板等无缝集成，实现跨平台的数据共享和交换。
高性能：由于CrossOver直接运行Windows应用程序的二进制代码，而不是模拟整个Windows系统，因此其性能远高于传统的虚拟机软件。
优秀的游戏支持：特别是对于Mac用户，CrossOver提供了对DirectX和EA等游戏平台的支持，让Mac用户也能享受到丰富的Windows游戏资源。
CrossOver通过在Mac和Linux之间创建一个虚拟文件系统，实现了两套操作系统之间的文件共享和传输。安装过程简单，只需下载对应版本的软件包并按照提示进行安装即可。
1.我们以在MacBook安装windows版的微信为例，首先在微信官网下载exe文件。
2.安装路径
启动CrossOver后，单击主界面内【安装一个不在列表里的应用程序】，然后将上面下载exe格式文件导入CrossOver便可进行安装了。
3.安装软件
在CrossOver中创建一个新容器，将exe文件通过【访达】导入容器中，进行安装即可。
软件安装成功后，可以像MacBook自身的软件一样正常启动。是不是很简单？
感兴趣的朋友可以免费下载使用。
CrossOver24 Mac安装包一键安装：https://souurl.cn/mWK48N
CrossOver中文网站激活码获取地址：https://souurl.cn/xneFDq
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1437ac8c26aeb2d57f787544de36b5/" rel="bookmark">
			2024年强大macbook的虚拟机工具Parallels Desktop 19 for Mac v19.3.0.54924中文破解版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Parallels Desktop 19 for Mac v19.3.0.54924中文破解版是一款强大的虚拟机软件，支持多操作系统，提供卓越的虚拟化技术，确保流畅稳定的运行。新增特色功能如共享打印、TouchID集成等，提供便捷高效的虚拟机体验。界面美观现代，值得推荐。摘要由作者通过智能技术生成
Parallels Desktop 19 for Mac v19.3.0.54924中文破解版是一款适用于Mac的虚拟化软件，parallels desktop 19中文版允许您在Mac计算机上同时运行多个操作系统。它使您能够创建虚拟机并在这些虚拟机中安装不同的操作系统，如Windows、Linux或macOS。使用Parallels Desktop 19 mac版，您可以在Mac和虚拟机之间无缝切换，同时运行两个操作系统。这使您可以直接从Mac访问Windows应用程序和文件，而无需重新启动或切换设备。Parallels Desktop 19旨在提供高性能的虚拟化体验，具有优化内存使用的动态内存控制和增强安全性的虚拟可信平台模块（vTPM）支持等功能。另外Parallels Desktop 19支持DirectX 11和OpenGL 3.3，使您能够在Mac上玩性能良好的Windows游戏。
Parallels Desktop 19 for Mac v19.3.0.54924中文破解版，这款虚拟机软件如同一位多才多艺的舞台演员，既能在Mac的舞台上翩翩起舞，又能完美演绎Windows、Linux等其他操作系统的精彩。它赋予了用户更广阔的舞台，实现了跨平台的自由穿梭，让每一个操作、每一个应用都尽在掌控。
在性能方面，Parallels Desktop 19 for Mac v19.3.0.54924中文破解版的虚拟化技术如同一位魔术师，将性能优化到了极致。Parallels引擎如同一位优雅的舞者，在Mac上轻盈起舞，无论是应用程序还是游戏，都能流畅运行，无卡顿、无延迟，给用户带来无与伦比的体验。
而在稳定性和用户体验方面，Parallels Desktop 19更是经受了严格的质量控制和兼容性测试的考验，如同一位经验丰富的演员，确保在任何情况下都能稳定发挥，为用户保驾护航。用户无需担心数据丢失，也无需担心系统不兼容带来的困扰，只需享受工作的流畅与高效。
功能方面，Parallels Desktop 19如同一位多才多艺的艺术家，提供了丰富的控制选项，让用户可以根据需要进行个性化的配置和管理。同时，它还支持一键式安装和配置，让用户在几分钟内就能轻松完成虚拟机的设置和启动，为用户节省宝贵的时间。
Parallels Desktop 19下载地址: https://souurl.cn/Zc5IZf
Parallels Desktop 19破解版补丁链接: https://pan.baidu.com/s/1YZrtZ8zIu-Ftq9purZA2Lw 提取码: j5s4
Parallels Desktop Mac破解版安装说明
打开下载好的安装包，双击 开始安装PD
软件许可界面，取消左下角勾选，点击【接受】，如图：
输入用户密码后确认，开始安装虚拟机
安装完成后，Parallels Desktop 19自动启动
自动打开应用界面可以在线下载安装推荐的Windows系统，或者选择”其他选项“自定义安装
在线安装，虚拟机会自动下载并安装win11镜像无需任何操作
选择”其他选项“，可以安装自己下载好的离线win镜像，点击【安装Windows】，点击”继续“如图：
系统会自动为您识别本次Windows系统，点击【继续】，如图：
点击【继续】，如图:
选择您需要安装的系统版本，
需要选择足够空间的磁盘，然后点击”创建“进行安装，如图：
正在创建系统，如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c1437ac8c26aeb2d57f787544de36b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98acdfb73ba16df5897285b9342bcf2/" rel="bookmark">
			数据结构——实现通讯录（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观学习，乐观生活，才能不断前进啊！！！
我的主页：optimistic_chen
我的专栏：c语言
点击主页：optimistic_chen和专栏：c语言，
创作不易，大佬们点赞鼓励下吧~
前言 顺序表作为线性表的一种，他满足增删查改的基本操作，我们之前已经写过一篇 ，这篇博客我将基于顺序表的内容完成通讯录的实现，也是顺序表的一种应用方式之一。
文章目录 前言实现准备实现通讯录的各种操作 开始通讯录实现记录原始数据通讯录的初始化通讯录的销毁添加通讯录数据删除通讯录数据通讯录的查找通讯录的展示通讯录的修改通讯录页面 完整代码完结 实现准备 · 经过之前的博客我们知道顺序表的底层就是数组，而通讯录就是顺序表通过封装过后的产物~
所以我们可以说通讯录的底层其实就是顺序表啦~
· 我们知道之前实现顺序表的时候，每个数组中存放的是内置类型int，但是通讯录内容数据类型可不只有int哦 ~* 而我们如果想要将各种联系人的数据存放并管理起来，那么我们就必须先自定义一个结构体类型来存放每个联系人的数据。然后将每个联系人的数据存放到数组中统计管理起来~
· 我们用宏定义来表示数组的大小方便以后的调整~
#pragma once #define NAME_MAX 20 #define GENDER_MAX 10 #define TEL_MAX 20 #define ADDR_MAX 100 //定义联系人的数据类型 typedef struct personInfo { char name[NAME_MAX];//联系人姓名 char gender[GENDER_MAX];//联系人性别 int age;///联系人年龄 char tel[TEL_MAX];//联系人电话 char addr[ADDR_MAX];//联系人地址 }peoInfo;//对结构体的重命名 这样我们自定义了一个数据类型，实现了数组中每一个元素都是我们自定义的类型。
· 接下来就是基于顺序表来实现通讯录
顺序表的定义：
typedef struct SeqList { SLDataType* arr; int size; int capacity;//空间大小 }SL; //给顺序表改个名字，叫做通讯录 typedef struct SeqList Contact; 这里我只是给顺序表重新取了一个名字（contact）！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98acdfb73ba16df5897285b9342bcf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf38a3145745b5e6f675e0c4eefb458/" rel="bookmark">
			数据结构——顺序表专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观学习，乐观生活，才能不断前进啊！！！
我的主页：optimistic_chen
我的专栏：c语言
点击主页：optimistic_chen和专栏：c语言，
创作不易，大佬们点赞鼓励下吧~
前言 什么是数据结构呢?
· 数据结构是由“数据”和“结构”两词组合⽽来。
· 概念：数据结构是计算机存储、组织数据的⽅式。
· 数据结构是指相互之间存在⼀种或多种特定关系的数据元素的集合。数据结构反映数据的内部构成，即数据由那部分构成，以什么⽅式构成，以及数据元素之间呈现的结构。
总结：
1）能够存储数据（如顺序表、链表等结构）
2）存储的数据能够⽅便查找
文章目录 前言顺序表概念顺序表的分类静态顺序表动态顺序表对比 顺序表的实现一、顺序表的初始化二、顺序表的销毁三、顺序表的打印四、顺序表容量的检查五、顺序表的头插六、顺序表的尾插七、 顺序表的头删八、顺序表的尾删九、顺序表指定位置之前插入数据十、顺序表指定位置之前删除数据十一、顺序表的数据查找 完整代码完结 顺序表概念 线性表（ linear list ）是n个具有相同特性的数据元素的有限序列。线性表是⼀种在实际中⼴泛使⽤的数据结构，常⻅的线性表：顺序表、链表、栈、队列、字符串…
线性表在逻辑上是线性结构，也就说是连续的⼀条直线。但是在物理结构上并不⼀定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。
顺序表的分类 顺序表的底层结构是数组，对数组的封装，实现了常⽤的增删改查等接⼝
静态顺序表 struct SeqList { int arr[100];//开少了不够，开多了浪费 int size;//有效数据个数 }; typedef int SLDataType; 静态顺序表是一种在数据结构中常见的线性表实现方式，它使用定长数组来存储数据元素。这种数据结构在初始化时就确定了存储空间的大小，并在运行期间保持不变。
动态顺序表 typedef struct SeqList { SLDataType* arr;//按需申请空间 int size;//有效数据个数 int capacity;//空间大小 }SL; 动态顺序表是一种可以动态调整其大小的顺序表，它克服了静态顺序表在大小固定方面的限制。
对比 分类静态顺序表动态顺序表空间分配创建时就分配了固定的内存空间，这避免了在运行时频繁地申请或释放内存根据数据的实际需求动态地扩展或缩小存储空间，从而避免了静态顺序表在存储空间分配上可能出现的浪费或不足的问题灵活性不灵活灵活性强效率由于数据元素在内存中是连续存放的，因此可以通过下标直接计算出元素在内存中的位置，实现快速存取尽管动态顺序表能够动态调整大小，但在插入或删除元素时，仍可能需要移动其他元素以保持数据的连续性。这尤其在元素数量较大或需要频繁进行插入/删除操作时可能导致效率降低管理静态顺序表的实现相对简单，因为数组的操作是基础的编程技能，所以理解和使用都比较容易动态顺序表需要维护额外的元数据（如当前大小、最大容量等），并需要实现相应的内存管理操作（如分配、释放等）。这增加了实现的复杂性和出错的可能性 总结：
静态顺序表在数据规模确定且不需要频繁改变的情况下表现良好，但在面对动态变化的数据规模时，其缺点就显得尤为突出。动态顺序表在处理动态变化的数据规模时具有较大的优势，但也需要考虑其带来的额外开销和实现的复杂性。在选择使用顺序表时，需要根据具体的应用场景和需求进行权衡。
顺序表的实现 我们以动态顺序表为例，完成顺序表的实现：
我们首先将顺序表的所有需求定义在一个头文件SeqList.h中。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int SLDataType #define INIT_CAPACITY 4 /动态顺序表 typedef struct SeqList { SLDataType* arr; int size; int capacity;//空间大小 }SL; //顺序表初始化 void SLInit(SL* ps); //顺序表的销毁 void SLDestroy(SL* ps); //顺序表的扩容 void SLCheckCapacity(SL* ps); //顺序表的打印 void SLPrintf(SL* ps); //头部插入 / 尾部插入 void SLPushBack(SL* ps, SLDataType x); void SLPushPront(SL* ps, SLDataType x); //头部删除 / 尾部删除 void SLPopBack(SL* ps); void SLPopPront(SL* ps); //在指定位置之前插入/删除数据 void SLInsert(SL* ps, int pos, SLDataType x); void SLFrase(SL* ps, int pos); //查找数据 int SLFind(SL* ps, SLDataType x); 我们后期的一系列操作都是根据头文件中的需求实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf38a3145745b5e6f675e0c4eefb458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603ea7b21cd4a7e2a0791871fea86073/" rel="bookmark">
			嵌入式数据库SQLite 3配置使用详细笔记教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、惨痛教训 随着管理开发的项目体积越来越庞大，产品系统涉及的数据量也越来越多，并且伴随着项目不久就要交付给甲方了。如果项目的数据信息没有被妥善管理，后期设备的运行状态、操作状况等数据流信息不能被溯源，当出现了一些特殊意外时，就会导致对于故障信息不能迅速准确的追踪，甚至会被甩锅、推卸责任，白白当了冤大头。因此对于嵌入式项目中，其产品运行时的数据库建立非常有必要，且是迫在眉睫！！！
目前常用的数据库系统有：MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server、SQLite等。在嵌入式项目中，前面几个数据库显然是不合适的，而SQLite是一个轻量级的数据库管理系统，它包含在一个C库中，提供了零配置、无服务器、事务性的SQL数据库引擎。所以SQLite的特点使其非常适合嵌入式系统、移动设备、小型项目或者作为应用程序的本地数据库使用。本文选用了嵌入式数据库SQLite3进行配置和讲解。
1、Sqlite3环境配置 （1）、下载安装SQLite库 根据目标系统平台，下载sqlite源码，或下载官方提供的已经编译好的库。本文目标平台是Windows11 64位平台，进入SQLite Download Page的主页，选择需要的库版本（Windows）。
下载的压缩包一共有如下所示的三个：
sqlite-dll-win-x64-3450300.zip
sqlite-dll-win-x86-3450300.zip
sqlite-tools-win-x64-3450300.zip
（2）、解压下载的文件 本文中将对应的Sqlite库文件解压到了，C:\Program Files\sqlite路径下。
（3）、添加库路径到环境变量 根据下图所示的步骤，进入系统属性--&gt;环境变量--&gt;系统变量--&gt;编辑环境变量，将路径加入到环境变量中。
（4）、检查数据库安装状态 打开Windows的命令行，输入sqlite3，有类似如下的数据信息说明库安装成功，后续只需在程序代码中，将库加入到工程代码中即可。
（5）、SQLiteStudio工具 如果有可视化分析数据需求、推荐使用下载：SQLiteStudiohttps://sqlitestudio.pl/
2、SQLite3基础 SQL（Structured Query Language）是一种结构化查询语言，SQL 是一种专门用来与数据库通信的语言。
不同的数据库管理系统在其实践过程中都对 SOL 规范作了某些改编和扩充。故不同数据库管理系统之间的 SOL语言不能完全相互通用。
以下是SQLite的一些关键特点：
零配置: SQLite不需要安装或者管理服务器进程。启动一个使用SQLite的应用程序时，数据库文件会自动创建（如果尚不存在），并且直接通过程序访问。轻量级: SQLite的代码量小，资源消耗少，对硬件要求很低。这使得它非常适合资源有限的环境，如手机、平板电脑或微型设备。跨平台: SQLite兼容几乎所有主流的操作系统，包括Windows、Linux、Unix、Android、iOS等。服务器less: 由于SQLite是嵌入式的，没有单独运行的数据库服务器进程，数据直接存储在文件中。这简化了部署和维护过程。事务处理: SQLite支持ACID（原子性、一致性、隔离性、持久性）事务，确保数据的完整性。SQL标准兼容: 虽然SQLite有自己的SQL方言，但它大体上遵循ANSI SQL标准，支持大多数标准SQL语句。单一文件存储: SQLite数据库完全存储在一个磁盘文件中，这使得备份和迁移数据库变得非常简单，只需复制该文件即可。动态类型: SQLite具有弱类型特性，允许更灵活的数据存储，但也可能需要开发者更加注意数据类型的处理。广泛使用: SQLite被许多应用程序和操作系统采用，包括浏览器（如Firefox）、操作系统组件、手机应用等，是世界上最广泛部署的数据库引擎之一。 有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。一般数据采用固定的静态数据类型，而 SOLite 采用的是动态数据类型，会根据存入值自动判断。
SQLite 存储类：SOLite 具有以下五种基本数据类型
（1）integer：带符号的整型(最多64位)。
（2）real：8字节表示的浮点类型。
（3）text：字符类型，支持多种编码(如 UTF-8、UTF-16)，大小无限制。
（4）blob：任意类型的数据，大小无限制。 BLOB(binary large obiect)二进制大对象，使用二进制保存数据。
（5）null：表示空值
SQLite 亲和类型(Affinity)及类型名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603ea7b21cd4a7e2a0791871fea86073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8afa8cad9cbaf3c2334b2aae7d98a638/" rel="bookmark">
			Python中合并列表(list)的六种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表是Python中强大的数据结构，很多时候我们要对它进行增、删、改、查，其中增是常见的操作，一般通过合并列表的方法来实现。那么，如何把2个列表合并成多个列表呢？今天我们就来学习一下六种不同的方法。
一、直接用 + 合并列表 最简单的办法就是用 +，把两个列表加起来，实际上就是合并在了一起。
list1 = [1, 2, 3] list2 = [4, 5, 6] merged_list = list1 + list2 print(merged_list) # 输出：[1, 2, 3, 4, 5, 6] 这种办法很直接,也很容易记，但是效率并不高，适合初学者直接连接两个元素不是特别多的列表。
二、用 extend() 方法 与append()进行元素追加的方法不同，extend() 方法可以把一个列表的内容追加加到另一个列表的末尾，就像这样：
list1 = [1, 2, 3] list2 = [4, 5, 6] list1.extend(list2) print(list1) # 输出：[1, 2, 3, 4, 5, 6] 注意哦，extend() 会改变原来的列表，不会创建一个新的。
三、用 zip() 函数交叉合并 如果你想交叉着合并两个列表，可以这么做：
lst1 = [1, 2, 3] lst2 = [4, 5, 6] merged_lst = [item for pair in zip(lst1, lst2) for item in pair] print(merged_lst) # 输出：[1, 4, 2, 5, 3, 6] 这样会把两个列表里对应位置的元素交叉合并到一起，注意这里的列表没有按照原来的顺利进行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8afa8cad9cbaf3c2334b2aae7d98a638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a0d6cbacd24a5fd4e78c1ff7c574a4/" rel="bookmark">
			实验五 Spark Streaming编程初级实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 实验目的 （1）通过实验学习使用Scala编程实现文件和数据的生成。
（2）掌握使用文件作为Spark Streaming数据源的编程方法。
2 实验平台 操作系统：Ubuntu16.04及以上。
Spark版本：3.4.0。
Scala版本：2.12.17。
3 实验要求 产生一系列字符串的程序，会产生随机的整数序列，每个整数被当做一个单词，提供给KafkaWordCount程序去进行词频统计
4 实验内容和步骤（操作结果要附图） Kafka准备工作（执行如下命令完成Kafka的安装：） 这里使用的软件版本是：kafka_2.12-2.6.0，Spark3.4.0（Scala版本是2.12.17）
链接: https://pan.baidu.com/s/1RS42IvXxtTVvIL24IwcjTA?pwd=1234 提取码: 1234 安装kafka cd ~/Downloads sudo tar -zxf kafka_2.12-2.6.0.tgz -C /usr/local cd /usr/local sudo mv kafka_2.12-2.6.0 kafka sudo chown -R hadoop ./kafka 启动Kafka
第一个终端
cd /usr/local/kafka ./bin/zookeeper-server-start.sh config/zookeeper.properties 行上面命令以后，终端窗口会返回一堆信息，然后就停住不动了，是Zookeeper服务器启动了，正在处于服务状态。所以，千万不要关闭这个终端窗口，一旦关闭，zookeeper服务就停止了，所以，不能关闭这个终端窗口
再打开第二个（不能关闭）
​cd /usr/local/kafka bin/kafka-server-start.sh config/server.properties 再打开第三个终端，然后输入下面命令创建一个自定义名称为“wordsender”的Topic：
​cd /usr/local/kafka ./bin/kafka-topics.sh --create --zookeeper localhost:2181 \ &gt; --replication-factor 1 --partitions 1 \ &gt; --topic wordsender 查看名称为“wordsender”的Topic是否已经成功创建：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a0d6cbacd24a5fd4e78c1ff7c574a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7862eb789bab45b4a179a7b63c27b1a2/" rel="bookmark">
			mac rime鼠须管配置,自用输入法皮肤,相关问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac rime鼠须管配置,自用输入法皮肤,相关问题解决 下载配置\`等符号反查关闭(〔筆畫〕)关闭中英文切换按钮VScode, Spotlight/聚焦搜索, Xcode等软件默认英文输入 输入法皮肤乱码解决自用配置汇总default.custom.yamlsquirrel.custom.yamlluna_custom.schema.yaml 官方指南 下载 https://rime.im/
https://github.com/rime/squirrel
目前最新的版本是0.18, 也就是我现在正在用的
我的自用配置贴在后面自用配置汇总了
配置 将鼠须管加入输入法后, 在右上角状态栏可以找到配置文件夹
鼠须管-&gt;用户设定
$ tree -L 3 . ├── build │ ├── default.yaml │ ├── luna_custom.schema.yaml │ ├── luna_pinyin.prism.bin │ ├── luna_pinyin.schema.yaml │ ├── squirrel.yaml │ ├── stroke.prism.bin │ ├── stroke.reverse.bin │ ├── stroke.schema.yaml │ └── stroke.table.bin ├── default.custom.yaml ├── installation.yaml ├── luna_pinyin.userdb │ ├── 000335.log │ ├── 000336.ldb │ ├── CURRENT │ ├── LOCK │ ├── LOG │ ├── LOG.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7862eb789bab45b4a179a7b63c27b1a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326e6f88de2fb0842b80cf3385cfc3bd/" rel="bookmark">
			hive中复杂数据类型(array，map，struct)讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、array数组类型 1、建表语句：
目录
一、array数组类型
二、map集合类型
三、struct结构类型
create table t1(f1 类型,...arrs array&lt;类型&gt;)
row format delimited
fields terminated by '\t' ----列之间的分隔符
collection items terminated by ','; ----数组arrs内元素分隔符（一般为逗号）
在limux下创建文件：
vim array
输入一些内容：
张三,男,12|13|14|15
李四,男,21|22|23|24
王五,女,31|32|33|34
建表语句：
create table t1( name string, sex string, score array&lt;int&gt;) row format delimited fields terminated by ',' collection items terminated by '|'; 这里可以看到创建成功了
2、导入数据
load data local inpath '本地文件路径' overwrite into table t1;
load data local inpath '/root/aaa/array' overwrite into table t1; 3、显示数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/326e6f88de2fb0842b80cf3385cfc3bd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/375/">«</a>
	<span class="pagination__item pagination__item--current">376/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/377/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>