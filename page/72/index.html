<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7059c8a590cba6dc0480587cd2430714/" rel="bookmark">
			【时时三省】C语言之运算符的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1，赋值运算
2，算术运算符
常见算术运算符如下：
3，逗号运算符
4，逻辑运算符
&amp;&amp; 和 || 是有短路效果的。
代码解析：
5，自增自减运算符
山不在高，有仙则名。水不在深，有龙则灵。
----CSDN 时时三省
1，赋值运算 代码如下：
int FuZhi(void) { float b = 56.7; int a; float c; a = b; // a = 56 c = a; // c = 56.000000 printf("a = %d, c = %f\n", a, c); b = 56.3; a = b; // a = 56 c = a; // c = 56.000000 printf("a = %d, c = %f\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7059c8a590cba6dc0480587cd2430714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4ec77eaf80e11dbec2e38f8467013c/" rel="bookmark">
			Java 中的 ArrayList 和 LinkedList 在性能上有什么不同？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中的 ArrayList 和 LinkedList 由于其内部数据结构的不同，在性能上也存在显著差异。以下是一些关键的性能比较点：
内存占用：
ArrayList 基于动态数组实现，内存分配是连续的，因此它的内存利用率较高。LinkedList 基于双向链表实现，每个元素都需要额外的内存来存储指向前后元素的引用，因此它的内存占用相对较高。 访问元素：
ArrayList 支持快速随机访问，即通过索引访问元素的时间复杂度为 O(1)。LinkedList 访问特定位置的元素需要从头开始遍历链表，时间复杂度为 O(n)。 插入和删除元素：
ArrayList 在数组中间插入或删除元素时，需要移动后续所有元素以维持数组的连续性，这可能导致较高的性能开销，时间复杂度为 O(n)。LinkedList 在任何位置插入或删除元素都只需要改变几个节点的引用，时间复杂度为 O(1)，但需要找到插入点，这可能需要 O(n) 的时间。 性能优化：
ArrayList 通常在随机访问和缓存中表现更好，适合读取操作多于写入操作的场景。LinkedList 适合插入和删除操作频繁的场景，尤其是在列表的中间或开始位置。 迭代器：
ArrayList 的迭代器是快速失败的，这意味着在迭代过程中如果检测到集合被修改，迭代器会立即抛出 ConcurrentModificationException。LinkedList 的迭代器也是快速失败的，但由于其链表结构，迭代器在遍历时可能稍微慢一些。 性能总结：
如果你的应用场景中需要频繁的随机访问元素，ArrayList 是更好的选择。如果你的应用场景中需要频繁的插入和删除操作，尤其是在列表的中间，LinkedList 是更好的选择。 在实际应用中，选择哪种数据结构取决于具体的使用场景和性能需求。了解每种数据结构的特点和性能特性，可以帮助你做出更合适的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ad4d01a28e15d7d3f9bfb972012453/" rel="bookmark">
			Maven私服Docker的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven私服Docker的搭建 参考：https://blog.csdn.net/sdgfafg_25/article/details/135146668
要在Docker中安装Maven私服，通常推荐使用Sonatype Nexus，它是一个强大的Maven仓库管理器。以下是使用Docker安装Nexus Maven私服的基本步骤：
拉取Nexus Docker镜像：
docker pull sonatype/nexus3 创建数据存储目录（如果需要数据持久化）：
mkdir -p /usr/local/nexus3/nexus-data chmod -R 777 /usr/local/nexus3/nexus-data 运行Nexus容器：
docker run -d -p 8081:8081 --name nexus -v /usr/local/nexus3/nexus-data:/nexus-data sonatype/nexus3 这将把Nexus容器的8081端口映射到宿主机的8081端口，并挂载数据卷以保持数据。
访问Nexus Web界面：
在浏览器中输入 http://localhost:8081 或者对应的服务器IP地址和端口，访问Nexus的Web界面。
​ http://192.168.1.57:8081
登录和配置：
首次登录时，你可能需要根据提示设置初始密码。密码通常存储在 /nexus-data/admin.password 文件中。你可以通过以下命令进入容器并查看密码：
docker exec -it nexus cat /nexus-data/admin.password 116874b7-4bde-4d11-a68c-7c29fc6fc659 修改密码
admin dx2024 登录后，你可以修改密码，并根据需要配置仓库。
创建Maven仓库：
在Nexus的Web界面中，你可以创建不同类型的仓库，比如Hosted、Proxy或Group仓库。Hosted仓库用于存储你的项目构建生成的构件，Proxy仓库作为对外部仓库的缓存，而Group仓库可以组合多个仓库。
配置Maven项目：
在你的Maven项目中，需要配置pom.xml文件和settings.xml文件，以便项目知道如何使用Nexus私服。在pom.xml中配置distributionManagement，指定你的私服仓库地址。在settings.xml中添加服务器配置，包括仓库的ID和认证信息。
上传和使用构件：
使用Maven命令（如mvn deploy）将你的构件上传到Nexus私服。在项目的pom.xml中声明依赖项，Maven将从配置的私服仓库中获取这些依赖。
请注意，具体的配置和使用步骤可能会根据你的具体需求和环境有所不同。以上步骤提供了一个基本的指南，帮助你开始使用Docker搭建Maven私服。
仓库需要注意，建一个maven-aliyun，放入maven-public.
在新建两个，host宿主仓库，专门存放公司自己的jar
setting的xml配置 可以参考 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;settings xmlns="http://maven.apache.org/SETTINGS/1.2.0" xmlns:xsi="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ad4d01a28e15d7d3f9bfb972012453/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182481897a2d143316759fde895844ef/" rel="bookmark">
			Pycharm 常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 快捷键作用描述Ctrl + Space基本的代码自动完成Ctrl + Shift + Space选择代码自动完成Ctrl + D复制当前行或符号Ctrl + X剪切当前行或符号Ctrl + C复制当前行或符号Ctrl + V粘贴剪贴板内容Ctrl + Y删除当前行Ctrl + A全选当前文件内容Ctrl + Z撤销操作Ctrl + Shift + Z重做操作Ctrl + F查找文本Ctrl + Shift + F在项目中查找文本Ctrl + R替换文本Ctrl + Shift + R在项目中替换文本Ctrl + G跳转到指定行号Ctrl + P显示参数信息Ctrl + Shift + P显示光标处的参数信息F2 / Shift + F2跳转到问题所在行Ctrl + [跳转到上一个编辑位置Ctrl + ]跳转到下一个编辑位置Ctrl + /行注释/取消注释Ctrl + Shift + /块注释/取消注释Ctrl + O重写方法Ctrl + Alt + L格式化代码Ctrl + Enter插入新行Ctrl + Backspace删除到单词开始Ctrl + Delete删除到单词结束Ctrl + Shift + Enter在当前行上方插入新行Alt + Shift + Up/Down移动当前行到上/下方Ctrl + Shift + J智能代码补全F4 / Ctrl + Click跳转到声明Alt + F7找到变量的用法Ctrl + F7显示变量的声明Ctrl + Shift + F7显示结构Ctrl + Shift + U大小写转换Ctrl + Alt + F显示文件结构Ctrl + Shift + Backspace跳转到最后编辑的位置Ctrl + Shift + F12显示当前文件结构Ctrl + Tab在打开的标签页之间切换Ctrl + Shift + Tab反向在打开的标签页之间切换Ctrl + W增加选中范围到括号内Ctrl + Shift + W减少选中范围到括号外F11 / Ctrl + Shift + F11书签切换Ctrl + NumPad+/-增加/减少缩进Ctrl + NumPad0重置缩进Alt + Shift + Insert插入代码片段Ctrl + Shift + Insert生成代码（例如getter和setter方法）Ctrl + Alt + B跳转到实现/接口Ctrl + Alt + O优化导入Ctrl + F12显示当前文件的文档结构Ctrl + Shift + F12显示当前项目的所有文档结构 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853cae635f7c48ed89233ad74834c436/" rel="bookmark">
			2024牛客多校7 D-Interval Selection，数字哈希&#43;状态记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定一个数组和一个整数 k，我们要找到所有的子数组 [l, r]，其中每个元素在子数组中恰好出现 k 次。这个类型的子数组被称为“良好的”子数组。询问整个数组里能找出几个良好子数组。
输入描述 链接：登录—专业IT笔试面试备考平台_牛客网
来源：牛客网
The first line contains an integer T(), indicating the number of test cases.
For each test case:
The first line contains two integers The second line contains nnn integers , --- each element of the array.
It is guaranteed that the total sum of nnn for all test cases does not exceed Sample input: 4
3 2
1 2 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/853cae635f7c48ed89233ad74834c436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936fba1a9dc3e815b432ee254b5d677b/" rel="bookmark">
			【用Java学习数据结构系列】探索顺序表和链表的无尽秘密（附带练习唔）pro
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
前言 今天给大家带来一篇有关Java顺序表和链表的文章，顺序表和链表我之前的专栏也是写过的，是用C语言实现的，也是模仿实现了顺序表和链表里的方法了。
下面是传送门：
顺序表：
你真的了解线性表中的顺序表了吗？（静态与动态顺序）-CSDN博客
链表：
数据结构对链表的初步认识（一）-CSDN博客
数据结构的带头，双向，循环链表来咯-CSDN博客
但是呢，学习了新语言Java那么就在用新语言在巩固一下了。
认识List Java中的List是java.util包下的一个接口，它是Collection接口的一个子接口，表示一个有序的集合，可以包含重复的元素。List接口提供了一些独特的方法来插入、访问、删除元素以及搜索列表中的元素。以下是List接口的一些关键特性和常用实现：
特性 有序性：List中的元素按照添加的顺序进行排序。允许重复：可以包含重复的元素。动态数组：大多数List实现（如ArrayList）使用动态数组来存储元素，这使得随机访问非常高效。 常用方法 add(E e)：向列表末尾添加一个元素。add(int index, E element)：在指定位置插入一个元素。remove(int index)：移除指定位置的元素并返回被移除的元素。remove(Object o)：移除列表中第一次出现的指定元素。get(int index)：返回指定位置的元素。set(int index, E element)：用指定元素替换列表中指定位置的元素。size()：返回列表中的元素数量。indexOf(Object o)：返回第一次出现的指定元素的索引。lastIndexOf(Object o)：返回最后一次出现的指定元素的索引。clear()：移除列表中的所有元素。 常用实现 ArrayList：基于动态数组实现，支持快速随机访问。但插入和删除操作可能需要数组复制，效率较低。LinkedList：基于双向链表实现，适合频繁的插入和删除操作。但随机访问效率较低。Vector：和ArrayList类似，但它是同步的。Stack：继承自Vector，实现栈的功能，后进先出（LIFO）。CopyOnWriteArrayList：线程安全的变体，在读多写少的场景下性能较好。 泛型 从Java 5开始，List接口支持泛型，允许开发者指定列表中元素的类型，提高类型安全。
使用场景 当你需要有序集合并且频繁进行随机访问时，选择ArrayList。当你需要频繁在列表中插入或删除元素，并且对随机访问的需求不高时，选择LinkedList。 注意事项 List的实现不是线程安全的。如果需要线程安全，可以使用Collections.synchronizedList()方法或CopyOnWriteArrayList。选择合适的List实现对于性能至关重要，因为不同的实现在不同的操作下表现不同。 List接口是Java集合框架中非常重要的一部分，合理选择和使用List可以提高程序的性能和可读性。
认识ArrayList（顺序表） 顺序表一个用数组实现的一个结构，他和数组不同的就是它是一个类，数组是一个引用类型，顺序表还扩展了一些方法
像增，删，查，改等是最基本的，还有一些其它方法，像List里的接口方法也实现了。
ArrayList是Java集合框架中的一种实现，属于List接口的实现类之一，同时也实现了RandomAccess接口，表明它支持快速的随机访问。
基本特性 基于数组：ArrayList内部使用一个动态数组（Object数组）来存储元素。动态扩容：当添加元素导致数组容量不足时，ArrayList会自动扩容，通常是将现有容量增加到原来的1.5倍（或根据需要调整）。允许空元素：可以包含null值。非同步：ArrayList不是线程安全的。 性能特点 随机访问：由于基于数组实现，ArrayList提供了快速的随机访问能力，即get(int index)操作的时间复杂度为O(1)。添加和删除：在列表末尾添加元素（add(E e)）是高效的，时间复杂度为O(1)。但是，如果需要在列表中间或开始位置添加或删除元素，可能需要移动其他元素以维持数组的连续性，这会导致时间复杂度为O(n)。 常用方法 代码演示：
import java.util.ArrayList; public class T { public static void main(String[] args) { ArrayList&lt;Integer&gt; arrayList1=new ArrayList&lt;&gt;(); //创建一个存储整数的顺序表 ArrayList&lt;Character&gt; arrayList2=new ArrayList&lt;&gt;(); //创建一个存储字符的顺序表 ArrayList&lt;String&gt; arrayList3=new ArrayList&lt;&gt;(); //创建一个存储字符串的顺序表 //给整形顺序表添加数据 arrayList1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/936fba1a9dc3e815b432ee254b5d677b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48cc43d67b0ed4279f3341c977f05644/" rel="bookmark">
			贪心算法的初涉（双指针 &#43; “过山车思想”）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“过山车”思想 首先我们用一道力扣的题目，来简单了解一下“过山车思想”
3228. 将 1 移动到末尾的最大操作次数 - 力扣（LeetCode）
给你一个 二进制字符串
s。
你可以对这个字符串执行 任意次 下述操作：
选择字符串中的任一下标 i（ i + 1 &lt; s.length ），该下标满足 s[i] == '1' 且 s[i + 1] == '0'。将字符 s[i] 向 右移 直到它到达字符串的末端或另一个 '1'。例如，对于 s = "010010"，如果我们选择 i = 1，结果字符串将会是 s = "000110"。 返回你能执行的 最大 操作次数。
示例 1：
输入： s = "1001101"
输出： 4
解释：
可以执行以下操作：
选择下标 i = 0。结果字符串为 s = "0011101"。选择下标 i = 4。结果字符串为 s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48cc43d67b0ed4279f3341c977f05644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80a6a0edc1f1f3cc3f456381be496f3/" rel="bookmark">
			【计算机网络——internet结构和ISP】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 internet结构：网络的网络
端系统通过ISP接入internet，ISP提供有线或者无线接入方式，接入ISP不一定是当地电信局，电缆公司，也可以是大学为老师学生或者公司为雇员……。
ISP，internet and 端系统关系：
所以比如学校的网络就是一个容器，把很多用户的端系统接入进去，大家通过这个网络可以访问internet，比如买东西，看外国的网站，或者学校里面和别的同学发信息，至于这个网络怎么来，就是要通过ISP来构建，ISP 会为学校提供所需的网络基础设施，包括网络线路的铺设、路由器、交换机等设备的配置，以及分配 IP 地址等服务。
谁提供ISP？
电信服务商（中国电信，联通，移动）等网络服务公司。
用户的移动网络也是通过 ISP 接入的：
无论是 4G 还是 5G 网络，都是由您所选择的移动运营商（如中国移动、中国联通、中国电信等）作为 ISP 来提供接入服务的。这些运营商通过建设和维护大量的基站、核心网设备等基础设施，使得您的手机能够连接到他们的网络，从而实现访问互联网、发送短信、进行语音通话等功能。
比如百万端系统接入ISP，怎么把他们互联到一起？
1
每个端系统和其他端系统连接，代价太大了，规模是N^2。理论上可以实现快速通信，不需要转来转去。
2
每个端系统（如个人电脑、手机等）通过各种方式接入本地的 ISP（可能是一个小型的社区网络提供商或本地的电信运营商分支）。然后这些本地的 ISP 再连接到更上层的区域 ISP ，比如市级、省级甚至是跨国的区域。
在同一区域内，通常会存在多家 ISP ，它们之间存在竞争关系。为了确保用户之间能够通信，无论用户 A 和用户 B 接入的是哪家区域 ISP ，这些区域 ISP 会通过互联网交换点（IXP）或者骨干网络进行互联互通。
并非所有的区域 ISP 直接接入全球 ISP ，而是通过多层级的连接和交换，逐步实现全球范围内的通信。
例如，一个位于中国某个小城市的用户通过本地电信运营商接入网络，该运营商与省级运营商连接，省级运营商又与国家级的骨干网相连，最终实现与全球互联网的连通。
这样的多层级结构和互联互通机制，使得全球互联网能够高效运转，同时也促进了竞争和创新，以提供更好的网络服务。
这些ISP公司就会建基站，路由器链路，链路等实现区域互通。
谷歌，百度这种互联网内容提供商（ICP）也需要向区域或者全球ISP支付费用，获取服务，连接用户。
但是会有问题：比如谷歌南非的客户，但是服务器在美国，进行信息互通要很多跳。所以这种龙头公司就会在全球建立很多服务器基站，然后自己拉光纤，实现连接。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0706e8cfd1835087183ee43346b9deba/" rel="bookmark">
			智能编程新纪元：腾讯AI代码助手的高效编程体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能编程新纪元：腾讯AI代码助手的高效编程体验 智能编程新纪元：腾讯AI代码助手的高效编程体验引言一、配置开发环境二、AI助手实现高效编程2.1 AI助手自动补全2.2 AI助手实现编程思维2.3 AI助手高效注解2.4 AI助手打破语言壁垒 三、帮助和提升四、优化和改进空间 总结 引言 Al代码助手的概念源于人工智能领域，它代表了一系列能够理解、学习并执行任务的智能软件或硬件系统。它们的设计初衷是简化人们的日常生活和提高程序员工作效率，同时为用户提供个性化、智能化的服务体验。
腾讯云AI代码助手，是一款定位代码智能补全和生成的数字化工具，是辅助编码工具，基于腾讯混元代码大模型，可以为开发者、开发团队及企业客户提供安全合规、高粘度体验的编码场景AIGC服务，具备代码补全、技术对话、代码诊断、单元测试等功能，支持 Python、Java、C/C++、Go等数十种编程语言或框架，以及VS Code、JetBrains 等主流集成开发环境
一、配置开发环境 腾讯云AI vscode插件下载地址
安装腾讯云AI代码助手可以从腾讯云官网上进行下载，根据腾讯云首页提供的辅助文档，定位到AI助手下载手册，根据不同的编译器来下载不同的AI版本，这里我选用的是Visual Studio Code (VSCode)代码编辑器。
安装步骤如下：
同时调整自己的开发环境，可能需要额外的环境变量的配置，必须确保所有软件和库都是最新版本，以兼容最新的AI研究和技术，同时我们还需要考虑到数据安全和隐私保护，合理配置网络安全设置和数据加密措施。
如何使用AI代码助手
登录腾讯云账号：访问腾讯云官网，使用你的账号登录。如果你还没有账号，需要先注册。
访问AI代码助手：在腾讯云的控制台中找到AI相关服务，或者直接在搜索框中输入“AI代码助手”找到对应的服务。
选择或创建项目：在AI代码助手页面中，你可能需要选择一个项目，或者创建一个新的项目来开始使用
输入描述或代码提示：在代码编辑器或相应的输入框中，输入描述你想要的代码功能，例如生成Java冒泡排序代码
二、AI助手实现高效编程 2.1 AI助手自动补全 在程序员编程中有一大难题就是代码思路突然间的忘记，这常常困扰着很多程序员，那么现在AI助手能够完美的帮助我们解决这一大难题。
如下图所示：
可以看到当我想要利用AI助手生成冒泡排序时，仅仅输入一个for循环，根据AI助手提示，已经把冒泡排序的最优代码提示了出来，方便了我们的快速上手操作，有了AI代码助手，我们在编写简单代码时只需要按住Tab键即可自能生成我们想要的代码。
2.2 AI助手实现编程思维 大家都知道在接手一个新项目的最让人头疼的问题就是如何去梳理他人代码中的思维逻辑，在这里腾讯AI助手能够帮你解决这个问题，仅仅需要按住shift+Alt+X即可解决。
请看下图：
可以看到哈，在AI助手的帮助下能够自能生成我们想要的代码，同时AI助手提供了代码思路等智能功能，我们在编写完代码下如果思路不够清楚，或者刚接手一个新项目下，借助于AI助手能够快速帮助我们分析所写代码的逻辑思路，极大的提高了程序员对代码的理解程度，以及加快了对新项目的入手程度。
2.3 AI助手高效注解 总所周知，在企业中为了能让团队更好的合作配合，默认的标准就是写的一手好注解，既能方便自己检查代码，也能方便同事进行后续的代码操作，但是并不是所有的程序员都能写的一手好注解来观看，那么该如何解决这个问题呢？
请看下图所示：
在上图的注解下，我们可以清晰的看到，这个注解是多么的清晰可靠，你可能以为这个程序员有一个极好的编码习惯，no no no大错特错啦，以上完美的注解是来自腾讯AI助手的一键生成，只需要按一下就能生成如此完美的注解，你还不快来试试吧~~
2.4 AI助手打破语言壁垒 遇到我们所不熟悉的语言该怎么办，很简单，快来试试腾讯AI助手，它能理解你的需求，提供解决方案，让技术难题迎刃而解。
三、帮助和提升 AI代码助手通过集成先进的机器学习和自然语言处理技术，为程序员提供了一系列的辅助功能，旨在提高开发效率、减少错误、促进学习和优化代码质量。以下是AI代码助手能够给予程序员的主要帮助和提升：
AI代码助手能够根据程序员的编码习惯和上下文智能地提供代码补全和建议，加快编码速度并减少错误。
根据开发者的需求，AI可以自动生成代码片段或完整的代码，减少重复劳动，提高编程效率
AI能够分析代码并提供优化建议，帮助改善代码质量、性能和可维护性。
通过智能代码建议和错误检测，AI编程助手可以帮助开发者减少代码中的错误，提高代码质量。
AI代码助手能够作为程序员的开发辅助工具，帮助我提升工作效率和质量，随着AI技术的不断进步，我要尽可能需要适应新的工作方式，学会利用这些工具来优化工作流程，腾讯Ai助手无疑是在我编程路上的一大助力伙伴，帮助我解决了多数难题。
四、优化和改进空间 在使用AI代码助手中，我认为还有以下几点需要提升和优化。
图形界面框：AI助手应该配置更加鲜明的色彩来帮助使用者能够清晰的识别出来。
上下文感知：助手应能够根据当前代码的上下文提供更相关的建议。这包括理解变量的作用域、函数调用的上下文以及类的继承关系。
代码优化建议：可能腾讯AI助手有着优秀的代码提示功能，但如果用户自己书写代码难免会有系统空间上浪费以及时间的浪费，这一点我认为可以提供一个代码优化建议，比如性能改进、减少内存使用或代码简化，帮助开发者写出更高效、更简洁的代码。
实时反馈：提供即时的代码建议和反馈，帮助开发者在编写代码时就能纠正错误，而不是在编译或运行时才发现问题。
以上几点是我作为一名用户在实际体验中感觉可以进一步提升和改进的地方。
腾讯云ai编程助手目前还出于小流量测试，正所谓真人能够反馈出真实的用户体验，用户能够反馈出更好的改进方向，经历多轮修改，目前可以很好的嵌入编辑器，而且模型经过多轮优化，准确率、美观化都能得到很大的提升。
总结 总结下来，我相信随着技术的不断进步，腾讯Al代码助手将更加智能，能够理解复杂的情感和语境，提供更加精准和个性化的服务。
同时腾讯云AI代码助手是一款极其高效的编程工具，借助于它的智能功能，能够为程序员带来极大的便利和编程上的帮助，我认为，在未来的一天，这款AI自能工具将会成为更多程序员的辅助工具，便利于更多、更广阔的用户群体。
腾讯云 AI 官网：腾讯云AI 官网链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0706e8cfd1835087183ee43346b9deba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98bd44ffcb27da944ea1ec4258051a5/" rel="bookmark">
			2024年最新免费AI大模型API汇总及国内大模型使用教程（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免费大模型API一览 大模型免费版本免费限制控制台（api_key等）API文档讯飞星火大模型spark-lite tokens：总量无限；
QPS：2；(每秒发送的请求数)
有效期：不限
访问链接访问链接百度千帆大模型平台ERNIE-Speed-8K RPM = 300，TPM = 300000
（RPM是每分钟请求数（Requests Per Minute），TPM是指每分钟处理的tokens数量）
访问链接访问链接ERNIE-Speed-128KRPM = 60，TPM = 300000ERNIE-Lite-8K-0922RPM = 300，TPM = 300000ERNIE-Lite-8KRPM = 300，TPM = 300000ERNIE-Tiny-8KRPM = 300，TPM = 300000腾讯混元大模型hunyuan-lite限制并发数为 5 路访问链接访问链接字节扣子(coze.cn)豆包·Function call模型(32K)当前扣子 API 免费供开发者使用，每个空间的 API 请求限额如下：
QPS (每秒发送的请求数)：2
QPM (每分钟发送的请求数)：60
QPD (每天发送的请求数)：3000访问链接访问链接通义千问-Max(8K)MiniMax 6.5s(245K)Moonshot（8K）Moonshot（32K）Moonshot（128K）Llama FamilyAtom-13B-Chat1.每天 8-22 点：接口限速每分钟 20 次并发
2.每天 22-次日 8 点：接口限速每分钟 50 次并发访问链接访问链接Atom-7B-ChatAtom-1B-ChatLlama3-Chinese-8B-Instructgroqgemma-7b-it rpm为30，
rpd为14400，
TOKENS PER MINUTE也有限制
访问链接访问链接mixtral-8x7b-32768llama3-70b-8192llama3-8b-8192Google Geminigemini-1.5-pro 15RPM（每分钟请求数）;
100万 TPM（每分钟tokens）;
1500 RPD（每天请求数）
访问链接访问链接gemini-1.5-flashgemini-1.0-progemini-pro-vision硅基流动Qwen2-7B-Instruct RPM限制为100，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98bd44ffcb27da944ea1ec4258051a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4328632b10b318b0fea3d9c4ac5064c/" rel="bookmark">
			数据仓库怎么建设？一文详解数仓的建设过程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息技术的飞速发展，企业不仅需要存储和管理海量数据，更迫切需要从这些数据中提取有价值的信息，以支持复杂的决策制定过程。数据仓库不仅是存储数据的场所，更是支持复杂查询、报告和数据分析的强有力工具，其建设已成为企业信息化战略中不可或缺的一环。数据仓库建设是一个系统化、多阶段的过程，涉及需求分析、数据抽取、转换和加载（ETL）、数据建模等多个环节。它要求企业不仅要有清晰的业务目标和技术路线图，还需要跨部门的协作和精细的项目管理工作。
本文将分析数据仓库的益处，深入探讨数据仓库的建设过程，并重点分析数据仓库各层级的技术要点，为企业提供数据仓库建设的实用性建议，支持企业构建一个坚实、高效的数据支持系统，帮助企业在数字化转型的进程中步伐更加坚实。
文章中提到的数据集成工具分享给大家——
https://s.fanruan.com/8j9is
高效ETL数据集成，打破企业数据壁垒，释放数据价值！
一、建设数据仓库有什么用？ 数据仓库作为一种关键的数据管理解决方案，其设计宗旨在于集中存储来自多样化源头的数据，经过整合和优化，以服务于企业的决策制定过程。其操作涉及将数据从原始系统提取、转换为统一格式，并加载至中央数据存储设施。数据仓库的架构允许数据以一种预定义的模式和结构化形态存在，从而简化了数据的理解和分析过程。对于有具体分析目标、数据结构规范且易于解析的企业而言，数据仓库提供了一种高效的数据利用途径。
具体来说，数据仓库包括以下优势：
主题导向的数据组织 数据仓库内的数据依照特定主题进行分类，每个主题均对应一个特定的分析维度，例如销售、库存、客户服务等。这种主题化的组织结构优化了数据仓库对决策分析的支持能力，使用户能够依据特定需求迅速提取相关数据。数据的稳定性 存储于数据仓库的数据具有非易失性特点，即数据一旦被加载，将被静态保存，不会频繁变动。这一特性支持了企业对历史数据的长期存储，为决策者开展趋势分析和历史数据挖掘提供了便利。高效的查询性能 数据仓库具备支持快速查询和处理大量数据的能力。其高效的查询响应和数据处理能力使用户能够对数据进行细分，执行更为深入的数据分析，同时保持了数据处理的灵活性。 数据仓库的这些优势使其成为企业在数据驱动决策过程中不可或缺的工具，特别是在需要处理和分析大量数据以获取有价值洞察的场景中。
二、数据仓库怎么建设？ 1、数据仓库建设流程 进行数仓项目，通常会从三个核心维度出发：数据、业务和数据治理，以及项目的整体视角。从项目角度来看，这包括调研、设计、实施、测试和上线等全生命周期的管理。在调研初期，我们会从数据库层面入手，评估数据质量，并设计整体平台架构。进入实施阶段后，我们会在业务层
面进行数据的验证和校对。接下来让我们一起来了解这些过程中的关键步骤。
调研 首先需要确定业务对接人和关键用户，然后收集相关资料，深入分析业务需求，评估现有数据资源，明确项目目标和预期成果，制定调研策略，进行实地调研，并最终确认业务蓝图，以确保项目后期开发者和业务人员的目标一致。
模型设计 通常会构建概念模型、逻辑数据模型和物理模型，以确保业务人员和技术人员之间的顺畅沟通。以供应链主题中的采购退货模型为例，需要先对主题域进行划分，根据业务部门、业务系统和业务过程的需求进行分类。接着，需要选择业务场景下的关键指标，并声明其粒度。例如，确定时间维度、组织或部门维度等，并最终确认退货事实表的维度建模方式。这样，我们就能将模型落地为维度表和事实表，以满足业务需求。
建表建库 这个阶段包括ETL开发、数据验证、前端应用开发和数据核对等。在测试上线阶段，需要将每个模块拆解到具体的上线步骤，并与相关业务确认人紧密配合，以确保数仓项目的顺利上线。此外，整个数仓项目还需要业务人员提供业务主题需求和确认最终结果表的通用性和数据质量。为了避免项目过程中可能会出现的问题，企业需要明确对接人、责任和响应措施。
从数据仓库全链路上来说，数据将从业务系统起始，经历离线处理与实时同步步骤，最终汇总至接近源数据的层级，即操作数据存储（ODS）层，并流向数据仓库的基础层以进行一致性处理。在该阶段，将清除源自业务数据的错误信息和不规范数据，执行一次性清洗工作。随后，数据传输至数据仓库服务层（DWS），进行主题相关的加工处理，例如构建面向应用的宽表、销售宽表或业务处理宽表。应用层（ADS）通常存储便于前端直接调用的数据，如用于可视化大屏展示的数据，可直接从ADS层获取所需信息。公共维度层则负责为各层级提供统一的公共维度数据表支持。
跟随完整的数据仓库处理链路，我们一起来探讨数仓建设中各层级的技术要点。
2、数仓建设各层级功能介绍/技术要点 1、ODS层
在这一层级，业务数据将被同步并备份至数据仓库中，且此过程对原有业务系统的运行不产生影响，所有随后的数据计算工作均从操作数据存储（ODS）层开始。因此，ODS层需应对的挑战包括处理来自不同来源的数据以及多样的数据结构，包括但不限于JSON格式的接口数据、电子邮件格式数据、Excel格式的文件数据、TRT数据以及半结构化数据类型。
2、DWD层
从 DWD 层开始将面向业务进行建设。 DWD 是数仓的建设核心，我们需要将 ODS 层的原样数据按照主题去建立相应的数据模型，对数据进行统一的清洗和一致性的处理。例如，跨表、跨库的一些格式规范统一，或者说脏数据的一些清洗，都会在 DWD 层完成，或和 DMI 层去进行一个关联匹配维度增加。
3、DWS层：
DWS层（数据服务层）的构建以业务分析为目标，将DWD层清洗后的数据表进行跨关联，创建面向业务主题的大宽表模型。这一层面为应用层提供统一的计算口径和数据标准，整合不同结构的数据，形成新的数据集合，并存储至数据仓库中。在企业实践中，DWSS和DWD层的工作往往紧密相连，清洗后的数据迅速进入关联和应用阶段。
帆软是国内领先的数据软件服务商，深耕数字行业十八年，能够依托于自身数字化产品，为各行业企业提供数字化转型解决方案。借助帆软的数据集成产品FineDataLink，IT部门可将数据集成至该FineBI，业务部门再通过FineBI访问公共数据层做好的大宽表，并利用这些宽表进行自助的分析，快速搭建分析看板。在这一过程中，无需担心数据质量问题或数据一致性，因为在DWS和DWD处理过程中，数据清洗和筛选工作已经完成。
4、DIM层
DIM层作为公共维度的存储层，存放了所有公共维度表，供ODS、DW、DM等各层在需要维度关联补充时使用。这种设计确保了数据的一致性和可访问性，支持业务人员进行高效的数据分析和决策。
5、ADS层
ADS层即应用数据层。在某些企业中，这一层也被称为数据集市层或DM层。ADS层主要根据业务需求存储个性化的数据结果表，直接为前端报表提供查询和展示服务。与DWD和DWS层不同，DWS层主要汇总数据的共性，形成大业务、大宽表，而在前端使用时可能还需要进行条件筛选或维度匹配。而ADS层则直接存储结果数据，前端无需任何数据处理即可直接读取和使用。通常，ADS层的数据会应用于大屏或移动端报表看板。
综上所述，首先，数仓的分层设计非常清晰，每一层都承担着特定的数据处理任务，如数据抽取、清洗、转换和加载。这样的设计使得企业在使用表时能够更快地定位和理解每一层级的内容。其次，在数据清洗和转换阶段，针对共性业务进行大宽表处理不仅规范了数据分层，还减少了不必要的重复计算工作，这样的处理能够使中间层数据管理更加高效。
最后，将复杂业务流程拆解成多个处理单一任务步骤的设计使得企业在回溯问题或交接信息时更加容易理解，同时也便于维护数据的准确性。
三、总结 总的来说，数据仓库建设是企业信息化战略的关键组成部分，它通过整合来自不同源的数据，提供一个统一的、历史性的数据分析平台。建设过程包括需求分析、数据抽取与加载（ETL工具）、数据建模、系统部署及测试等环节。数据仓库的实施不仅优化了数据管理，还提高了决策效率，支持了业务的深入洞察。随着技术的不断进步，数据仓库正向更加灵活、高效的方向发展，为企业提供更强大的数据支持能力。
帆软软件深耕数字行业，能够基于强大的底层数据技术，为企业打破数据孤岛，搭建数据仓库，梳理指标体系。并企业提供数据仓库的上层应用生产力，结合强大的数据产品，打造全面、易用、直观的报表系统和数据分析平台，涵盖了经营、财务、绩效、风险和监管等多个方面。此外，帆软软件还为为各业务部门人员及领导提供PC端、移动端等可视化大屏查看方式，这种灵活的数据展示方式显著提升了企业工作效率和对业务需求的响应速度。
文章中提到的数据集成工具分享给大家——
https://s.fanruan.com/8j9is
高效ETL数据集成，打破企业数据壁垒，释放数据价值！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7bcf784a9de232d8f0822b375e851e0/" rel="bookmark">
			腾讯云AI代码助手：智能编程的未来之窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云AI代码助手：智能编程的未来之窗
智能编程的未来之窗 引言配置环境介绍腾讯云 AI 代码助手使用实例生成文档功能解释代码功能生成测试功能精准修复错误功能技术对话功能 智能编程获得的帮助与提升对腾讯云AI代码助手的建议结语 引言 今天七七给大家带来一款非常好用的辅助编程工具，“腾讯云 AI 代码助手”，它是一款定位代码智能补全和生成的工具，基于自研代码大模型，实现技术沟通、代码补全、自动补全单元测试等功能。在当今数字化高速发展的时代，编程领域也迎来了一场深刻的变革。腾讯云 AI 代码助手的出现，无疑为开发者们开启了智能编程的未来之窗。
配置环境介绍 首先我们进入AI代码助手官网，界面会有一个免费使用和在线体验的选择，接下来七七都会讲一下。
我们点击免费使用，然后会弹出两个插件的安装，根据自己选择。
Visual Studio Code ，从 Visual Studio Code 插件市场直接安装 腾讯云 AI 代码助手插件，安装后重启IDE，即可开始智能编码之旅。
JetBrains IDEs ，打开 JetBrains IDEs 浏览器插件市场，选择对应的插件版本进行下载安装，安装成功重启后即可开启智能编码之旅。
然后我们再看看官网的在线体验。
点进去不需要下载任何插件就可以体验腾讯云的AI代码助手啦！
腾讯云 AI 代码助手使用实例 我想做一道接雨水的题目，这是力扣上的一道难题，就是给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。当我把这道题结合AI代码助手去使用，究竟会擦出怎样的效果，让我们拭目以待吧！
下面开始代码展示（Java为例）：
class Solution { public int trap(int[] height) { int n = height.length; if (n == 0) { return 0; } int[] leftMax = new int[n]; leftMax[0] = height[0]; for (int i = 1; i &lt; n; ++i) { leftMax[i] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7bcf784a9de232d8f0822b375e851e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781a8fab6e6846cce28b3b5ac2bb107d/" rel="bookmark">
			探索腾讯云AI代码助手：智能编程的新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能编程的新时代 前言开发环境介绍腾讯云 AI 代码助手使用实例生成文档解释代码生成测试修复代码人工智能技术对话 智能编程获得的帮助与提升对腾讯云AI代码助手的建议结语 前言 hello，大家好我是恒川，今天我来给大家安利一款非常好用的AI 代码助手，它是由腾讯云自研的一款开发编程提效辅助工具，开发者可以通过插件的方式将 AI 代码助手安装到编辑器中辅助编程工作（VS Code 或者 JetBrians 系列 IDE）；而 AI 代码助手插件将提供：自动补全代码、根据注释生成代码、代码解释、生成测试代码、转换代码语言、技术对话等能力。通过腾讯云 AI 代码助手，开发者可以更高效地解决实际编程问题，提高编程效率和代码质量。
开发环境介绍 进入腾讯云AI代码助手官网，点击免费使用。
此时会弹出来两款插件供大家选择。
首先是Visual Studio Code，从 Visual Studio Code 插件市场直接安装 腾讯云 AI 代码助手插件，安装后重启IDE，即可开始智能编码之旅。
然后就是JetBrains IDEs，打开 JetBrains IDEs 浏览器插件市场，选择对应的插件版本进行下载安装，安装成功重启后即可开启智能编码之旅。
还有一个在线体验，在不下载任何插件的情况下，就可以轻松体验。
腾讯云 AI 代码助手使用实例 就比如我要设计一个算法来实现二叉树的序列化与反序列化。这里不限定序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构，来看看 AI 代码助手能帮助我做些什么。
下面开始代码展示（我以Java为例）：
public class Codec { public String serialize(TreeNode root) { return rserialize(root, ""); } public TreeNode deserialize(String data) { String[] dataArray = data.split(","); List&lt;String&gt; dataList = new LinkedList&lt;String&gt;(Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781a8fab6e6846cce28b3b5ac2bb107d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76575d91d5ccbf836b788bb2b242a9a2/" rel="bookmark">
			【开端】JAVA Mono＜Void＞向前端返回没有登陆或登录超时 暂无权限访问信息组装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、绪论
JAVA接口返回信息ServerHttpResponse response
等登录接口token过期时需要给前端返回相关状态码和状态信息
二、Mono&lt;Void&gt;向前端返回没有登陆或登录超时 暂无权限访问信息组装
返回Mono对象
public abstract class Mono&lt;T&gt; implements CorePublisher&lt;T&gt;
/** * 无权限 * * @param response * @return */ private Mono&lt;Void&gt; noLogin(ServerHttpResponse response) { log.info("没有登陆或登录超时 暂无权限访问==========="); String responseDataStr = JSON .toJSON(ResponseData.error(HttpStatus.UNAUTHORIZED.value(), "The Token has expired")).toString(); byte[] bytes = responseDataStr.getBytes(StandardCharsets.UTF_8); DataBuffer buffer = response.bufferFactory().wrap(bytes); response.setStatusCode(HttpStatus.UNAUTHORIZED); return response.writeWith(Mono.just(buffer)); } 信息组装。
1、返回ResponseData对象，输出状态码和状态信息：The Token has expired
ResponseData.error(HttpStatus.UNAUTHORIZED.value(), "The Token has expired")
转换成json信息
byte[] bytes = responseDataStr.getBytes(StandardCharsets.UTF_8);
转换成字节流
输出：
response.writeWith(Mono.just(buffer));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76575d91d5ccbf836b788bb2b242a9a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85dfd4358d59dc3da2f5c904e37ca204/" rel="bookmark">
			如何通过【腾讯云 AI 代码助手】快速解决商城项目难题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言开发环境介绍从 IDE 插件市场安装 腾讯云AI代码助手实战问题一：如何使用RabbitMQ的死信队列来实现关闭订单的操作？并编写java代码问题二：在解决库存问题时，如何使用Redis的分布式锁来实现呢？ 获得的帮助与提升建议总结 引言 在当今快速发展的技术环境中，编程已经成为推动创新的核心力量。然而，面对日益复杂的代码编写和优化需求，程序猿们常常感到力不从心。腾讯云 AI 代码助手应运而生，为开发者提供智能化的支持和帮助。
腾讯云 AI 代码助手，是一款辅助编码工具，基于混元代码大模型，提供技术对话、代码补全、代码诊断和优化等能力。能为我们生成优质代码，解决技术难题，提升编码效率。
开发环境介绍 大家都知道阿Q是搞 java 的，所以平时使用最多的工具就是 IntelliJ IDEA 了。接下来，请跟随阿Q的脚步，带大家在 IntelliJ IDEA 中集成一下腾讯云AI代码助手。
先跟大家说一下我本地的环境：
操作系统版本：Windows10.0.19045.4291
JetBrains版本：IntelliJ IDEA 2023.1.2
从 IDE 插件市场安装 打开插件市场：在顶部导航中单击 IntelliJ IDEA &gt; Settings。
搜索腾讯云 AI 代码助手进行安装。
安装完之后重启IntelliJ IDEA 即可看到。
腾讯云登录完之后即可使用了。
注意：支持的版本号最低为 IntelliJ IDEA 2022.2
腾讯云AI代码助手实战 正好阿Q最近正在参与商城项目的开发，目前遇到了两个小问题：
如何使用RabbitMQ的死信队列来实现关闭订单的操作？在解决库存问题时，如何使用Redis的分布式锁来实现呢？ 接下来我们带着这俩问题来寻求下腾讯云AI代码助手的帮助
问题一：如何使用RabbitMQ的死信队列来实现关闭订单的操作？并编写java代码 通过gif图我们可以看出，他不仅为我们准备了使用 RabbitMQ 的死信队列来实现关闭订单操作的步骤，还贴心的为我们准备了java 实现的代码，我们只需要修改里边自己业务相关的关闭订单的逻辑即可，这也太贴心了，简直就是爸爸的贴心小棉袄呀！
问题二：在解决库存问题时，如何使用Redis的分布式锁来实现呢？ 我们也是直接将问题抛给了小助手，通过上图的gif来看，它首先给我们解释了分布式锁的实现原理，然后又同样以代码的形式告诉我们改如何使用它。
通过它最后的提示，我们看到分布式锁还可以用 Redission 提供的可重入式分布式锁实现，于是我又这样进行描述：请基于Redission 的可重入式分布式锁帮我解决上边的库存问题。
接着它又给出了基于Redission的分布式锁的解决方案。如果我们想直接使用它生成的代码逻辑，我们可以在直接点击代码旁边的【复制】或者【插入代码】按钮直接将其引入到代码中。
不知道大家有没有注意到，每次回答完我们的问题后，他会在左下角出现一个【闪电】的标识，会帮我们联想到一些问题，如下图
有了这个提示，我们在编写代码或者编写逻辑的过程中应该可以适当的规避掉一些问题了，给这个小功能点赞！
至于开头我们说到的代码补全、代码诊断和优化能力，希望大家可以亲自去安装下插件，自我体验一下它的强大功能。此处我们就以注释生成代码为例来简单体验下：
看到这儿，阿Q不得不感叹于腾讯云 AI 代码助手的强大呀！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85dfd4358d59dc3da2f5c904e37ca204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9026c48934bf78c3d15ecdfcb5f6767c/" rel="bookmark">
			腾讯云AI代码助手：AI辅助编写测试用例，测试从此不求人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
开发环境介绍
实例：编写测试用例
帮助与提升
建议
结语
引言 在软件开发过程中，编写测试用例是确保代码质量的重要环节。然而，对于新手编程学习者来说，撰写高质量的测试用例可能是一个巨大的挑战。AI 代码助手作为一个智能编程辅助工具，正是为了解决这一难题而设计的。
目前市面上类似产品也不少，例如蚂蚁CodeFuse、百度文心快码Comate、华为云Astro等，相比这些产品，腾讯云AI代码助手有如下优势：
语言和框架支持：腾讯云AI代码助手支持广泛的编程语言和框架，与市场上其他AI助手相比，具有更广泛的适用性。集成开发环境（IDE）支持：腾讯云AI代码助手特别强调了对VS Code和JetBrains IDE的支持，这可能对使用这些IDE的开发者更有吸引力。内部使用情况：腾讯云AI代码助手在腾讯内部有超过50%的研发在使用，这表明它在实际应用中得到了验证和信赖。研发效率提升：所有AI助手都强调了提升研发效率，但腾讯云AI代码助手特别提到了技术对话和代码补全，这可能意味着它在交互性和代码生成方面有特别的优势。安全性和隐私：腾讯云AI代码助手的介绍中没有明确提到安全性和隐私保护措施，这是在选择AI助手时需要考虑的一个重要因素。 腾讯云 AI 代码助手利用先进的自然语言处理和机器学习技术，能够自动生成代码片段和测试用例。这一工具不仅能帮助开发者节省时间，还能提升代码的规范性和可读性。对于编程新手来说，腾讯云 AI 代码助手提供的测试用例生成功能尤为有用，它可以帮助新手快速了解如何撰写有效的测试用例，避免常见的错误，并在学习过程中逐步提高测试能力。因此，腾讯云 AI 代码助手不仅是编程学习者的良师益友，更是提升编程效率和质量的重要工具。
开发环境介绍 首先需要我们在IDE中安装腾讯云AI代码助手的插件，现已支持JetBrains、VS Code和Android Studio。这里我们选用VS Code，打开插件市场，搜索腾讯云AI代码助手便可找到对应插件。
安装完成后需要跳转到腾讯云网页登录授权。实名验证完毕后即可正常使用。腾讯云AI代码助手有两种交互方式，一种是直接在左侧打开问答窗口通过对话获得帮助。
另一种是通过代码提示的方式提供建议，例如根据注释描述以及上下文，生成业务逻辑代码与函数；补全内容包含常见的特征、对象判空、循环定义、异常捕捉、日志定义等；根据光标前后的上下文代码或注释生成代码建议或是函数定义描述，根据上下文补合理的业务逻辑。只需要按TAB键即可接受建议。
实例：编写测试用例 目前腾讯云AI代码助手已支持C/C++、HTML、Java、Python、Node.js、TypeScript、Go、Rust、Swift、Dart，这里我们尝试在Python环境下编写测试用例。首先我们点击左侧的问答窗口，让AI为我们生成一个测试框架。
按照AI的提示，我们首先安装unittest和pytest包。只需要将命令复制到终端即可完成安装。安装完毕后将代码区的代码复制到空白py文件中，这就是我们的模板文件。
这段代码使用Python的unittest框架定义了一个简单的单元测试。首先导入 unittest 模块，提供了创建和运行单元测试的类和方法。之后定义了TestExample 类，这个类继承自 unittest.TestCase，表示它是一个可以被 unittest 框架运行的测试用例。test_addition和test_subtraction都是测试方法，我们自己编写的测试方法也应该有类似的格式。assertEqual() 用于检查实际结果和预期结果是否一致。要运行这个测试脚本，需要使用pytest test_example.py而不是使用python命令。最后的输出将显示测试是否成功通过，或者是否存在失败或错误。
接下来我们需要针对指定程序进行单元测试。现在打开我们被测程序，将刚才的py文件放入其目录下。现在我们想要测试mapper文件下的find_admin()这个函数，于是我们在刚才的测试文件中编写单元测试。
首先必须要在测试文件中调用被测程序的文件。之后在TestExample类中通过注释要求AI生成测试函数。换行之后，AI的提示就出现了，这里只需要一直按TAB持续生成。很轻易地就获得了测试用例，并且还按照等价类划分成了正负两个测试用例。第一个测试方法代表运行正确的情形，第二个代表运行错误的情形。self.assertEqual(mapper.find_admin("admin"), 1)表示使用 self.assertEqual() 断言方法，检查 mapper.find_admin("admin") 的返回值是否等于 1。同样地，self.assertEqual(mapper.find_admin("admin1"), -1)表示检查 mapper.find_admin("admin1") 的返回值是否等于 -1。
不过这里需要注意的是AI助手并不能主动读取文件内容，特别是非代码内容，所以并不能一味依赖AI助手完成所有的工作。当find_admin()运行正确的时候会返回Admin对象而不是1，所以我们还要进行一定的修改。显然mapper.find_admin(“admin”)的结果是一个Admin对象，那么我们就需要比较它的密码是否和约定的一致。查看数据可以发现admin的密码是123456，所以这里改成self.assertEqual(mapper.find_admin(“admin”).password, “123456”)
接下来按照之前的提示运行pytest testcase.py即可获得结果
完整代码如下：
import unittest import mapper class TestExample(unittest.TestCase): #为mapper.find_admin()添加测试用例 def test_find_admin(self): self.assertEqual(mapper.find_admin("admin"), 1) self.assertEqual(mapper.find_admin("admin1"), -1) if __name__=="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9026c48934bf78c3d15ecdfcb5f6767c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161f9e264cfef7aab0d5d317c5eb0bb8/" rel="bookmark">
			【IEEE出版 | 往届会后三个月检索】第五届大数据、人工智能与软件工程国际研讨会（ICBASE 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【IEEE出版 | 往届会后三个月检索】 第五届大数据、人工智能与软件工程国际研讨会（ICBASE 2024） 2024 5th International Conference on Big Data &amp; Artificial Intelligence &amp; Software Engineering
2024年09月20-22日 | 中国温州
*会议官网：www.icbase.org 三轮截稿时间：2024年8月31日
ICBASE 2024已上线至IEEE官网：点击查看 大会简介
第五届大数据、人工智能与软件工程国际研讨会（ICBASE 2024）将于2024年09月20-22日在中国温州隆重举行。会议主要围绕大数据、人工智能与软件工程等研究领域展开讨论。会议旨在为从事大数据、人工智能与软件工程研究的专家学者、工程技术人员、技术研发人员提供一个共享科研成果和前沿技术，了解学术发展趋势，拓宽研究思路，加强学术研究和探讨，促进学术成果产业化合作的平台。大会诚邀国内外高校、科研机构专家、学者，企业界人士及其他相关人员参会交流。
组织单位
主办单位：温州理工学院、加拿大圭尔夫大学
承办单位：温州理工学院数据科学与人工智能学院、加拿大圭尔夫大学工程学院
协办单位：广东省艾思信息化学术交流研究院、AEIC学术交流中心
支持单位：加拿大圭尔夫大学工程学院高级机器人与智能系统实验室
征稿主题
大数据分析、深度学习、机器学习、人工智能、模式识别、数据挖掘、云计算技术、物联网、AI应用于物联网、聚类和分类、软件技术、自然语言处理、电子商务和电子学习、无线网络、网络安全、大数据联网技术、在线数据分析、序列数据处理、基于图像数据分析、信号处理；其他相关主题均可
论文出版
EI会议论文
ICBASE 2024所有的投稿都必须经过2-3位组委会专家审稿，经过严格的审稿之后，最终所有录用的论文将由IEEE出版（ISBN：979-8-3315-0661-2），见刊后由出版社提交至IEEE Xplore, EI, Scopus检索。
参会方式
1. 口头报告：论文一经录用即可注册参会报名口头报告，时间为15分钟，含问答环节。无投稿亦可报名
2. 海报展示：论文一经录用即可注册参会展示海报，海报尺寸为A1竖版（宽*高：594mm*841mm）。无投稿亦可报名
（*注：提交海报至会议邮箱：contact@icbase.org，邮件主题：海报展示+姓名+论文编号+现场参会/线上参会）
3. 听众参会：无需提交稿件，直接注册听众参会即可 *本会议由艾思科蓝支持在线报名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d306a5ca189a358d686a73777d4c47/" rel="bookmark">
			大数据与人工智能：数据隐私与安全的挑战_ai 和 数据隐私
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 1.背景介绍 随着人工智能(AI)和大数据技术的不断发展，我们的生活、工作和社会都在不断变化。这些技术为我们提供了许多好处，但同时也带来了一系列挑战，其中数据隐私和安全是最为关键的之一。数据隐私和安全问题的出现，主要是因为大数据技术的特点和人工智能算法的运行过程。
大数据技术的特点包括数据量的庞大、数据类型的多样性、数据来源的多样性和数据更新的快速性。这些特点使得大数据技术具有强大的计算和分析能力，可以帮助我们发现隐藏在海量数据中的模式和关系，从而为我们的决策提供有力支持。然而，这些特点同时也为数据隐私和安全问题创造了挑战。
人工智能算法的运行过程，主要包括数据收集、数据预处理、算法训练和算法应用。在这个过程中，数据隐私和安全问题主要表现在以下几个方面：
数据收集阶段：数据收集过程中，个人信息可能会泄露，导致用户隐私泄露。数据预处理阶段：数据预处理过程中，数据可能会被篡改、滥用或泄露，导致数据安全问题。算法训练阶段：算法训练过程中，个人信息可能会被泄露，导致用户隐私被侵犯。算法应用阶段：算法应用过程中，个人信息可能会被滥用，导致用户隐私被侵犯。 因此，在大数据与人工智能技术的应用过程中，我们需要关注数据隐私和安全问题，并采取相应的措施来保护用户隐私和数据安全。在接下来的内容中，我们将深入探讨大数据与人工智能技术中的数据隐私和安全问题，并提出一些解决方案。
2. 核心概念与联系 2.1 大数据 大数据是指通过各种设备和渠道收集的海量、多样化、高速增长的数据。大数据具有以下特点：
数据量庞大：大数据的数据量可以达到百万甚至千万级别，甚至更大。数据类型多样化：大数据包括结构化数据、非结构化数据和半结构化数据。数据来源多样化：大数据可以来自各种不同的来源，如传感器、社交媒体、网络日志等。数据更新快速：大数据的更新速度非常快，需要实时处理和分析。 2.2 人工智能 人工智能是指机器具有人类智能水平的能力，可以理解、学习和应用自然语言、图像、声音等人类智能的能力。人工智能的主要技术包括机器学习、深度学习、自然语言处理、计算机视觉、语音识别等。
2.3 数据隐私与安全 数据隐私是指个人信息在收集、存储、传输和使用过程中的保护。数据安全是指保护数据和信息系统免受未经授权的访问、篡改、披露和损失等风险的过程。
2.4 联系 大数据与人工智能技术的发展，对数据隐私和安全问题产生了重要的影响。在大数据与人工智能技术的应用过程中，我们需要关注数据隐私和安全问题，并采取相应的措施来保护用户隐私和数据安全。
3. 核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1 数据掩码 数据掩码是一种用于保护数据隐私的方法，它通过在原始数据上添加噪声来掩盖个人信息。数据掩码的主要思想是在保持数据的统计特性不变的情况下，增加数据的噪声度，从而保护用户隐私。
数据掩码的具体操作步骤如下：
对原始数据进行分类，将其划分为多个不同的类别。为每个类别生成一组随机噪声。将噪声添加到原始数据上，得到掩码后的数据。 数据掩码的数学模型公式为：
D m a s k e d = D o r i g i n a l + N D _{masked} = D_{original} + N Dmasked​=Doriginal​+N
其中， D m a s k e d D _{masked} Dmasked​ 表示掩码后的数据， D o r i g i n a l D_{original} Doriginal​ 表示原始数据， N N N 表示噪声。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90d306a5ca189a358d686a73777d4c47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/805c32528c5c82ee1af6feae300a6a73/" rel="bookmark">
			【Python机器学习】回归——局部加权线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归有一个问题就是有可能出现过拟合现象，因为它求的是具有最小均方误差的无偏估计。如果模型欠拟合将不能取得最好的预测效果。所以有些方法允许在估计中引入一些偏差，从而降低预测的均方误差。
其中一个方法就是局部加权线性回归（LWLR），在该算法中，我们给待预测点附近的每个点赋予一定的权重，然后在这个子集上基于最小均方差来进行普通的回归，与kNN一样，这种算法每次预测均需要事先选取出对应的数据子集。
该算法解出回归系数w的形式如下：
其中w是一个矩阵，用来给每个数据点赋予权重。
LWLR使用“核”来对附近的点赋予更高的权重。核的类型可以自由选择，最常用的核是高斯核，高斯核对应的权重如下：
这样就构建了一个只包含对角元素的权重矩阵w，并且点x与x(i)越近，w(i,i)将会越大。上述工时包含一个需要用户指定的参数k，它决定了对附近的点赋予多大的权重，这也是使用LWLR时唯一需要考虑的参数。
下面是具体的代码实现：
def lwlr(testPoint,xArr,yArr,k=1.0): xMat=mat(xArr) yMat=mat(yArr).T m=shape(xMat)[0] #创建对角矩阵 weights=mat(eye((m))) for j in range(m): diffMat=testPoint-xMat[j,:] weights[j,j]=exp(diffMat*diffMat.T/(-2.0*k**2)) xTx=xMat.T*(weights*xMat) if linalg.det(xTx)==0.0: print('行列式为0') return ws=xTx.I*(xMat.T*(weights*yMat)) return testPoint*ws def lwlrTest(testArr,xArr,yArr,k=1.0): m=shape(testArr)[0] yHat=zeros(m) for i in range(m): yHat[i]=lwlr(testArr[i],xArr,yArr,k) return yHat 上述代码的作用是给定x空间中的任意一点，计算出对应的预测值yHat。函数lwlr()的开头读入数据并创建所需矩阵，之后创建对角权重矩阵weights。权重矩阵时一个方针，阶数等于样本点个数。也就是说，该矩阵为每个样本点初始化了一个权重，接着算法将遍历数据集，计算每个样本点对应的权重值：随着样本点与待预测点距离的递增，权重将以指数级衰减。输入参数k控制衰减的速度。在权重矩阵计算完毕后，就可以得到对回归系数ws的一个估计。
另一个函数是lwlrTest()，用于为数据集中每个点调用lwlr()，这有助于求解k的大小。
载入数据并对单点进行估计：
xArr,yArr=loadDataSet('ex0.txt') print(lwlr(xArr[0],xArr,yArr,1.0)) print(lwlr(xArr[0],xArr,yArr,0.001)) 计算拟合曲线并绘图
yHat=lwlrTest(xArr,xArr,yArr,0.003) xMat=mat(xArr) srtInd=xMat[:,1].argsort(0) xSort=xMat[srtInd][:,0,:] import matplotlib.pyplot as plt fig=plt.figure() ax=fig.add_subplot(111) ax.plot(xSort[:,1],yHat[srtInd]) ax.scatter(xMat[:,1].flatten().A[0],mat(yArr).T.flatten().A[0],s=2,c='red') plt.show() 可以观察上图的效果。
局部加权线性回归也存在一个问题，那就是增加了计算了，因为它对每个点做预测时都必须使用整个数据集。如果避免这些计算就可以减少程序运行时间，从而环节因计算了增加带来的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0deecdf539b64b39714685e0e355dc8/" rel="bookmark">
			结合傅里叶变换和传统特征提取方法，通过XGBoost检测计算机生成图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型的发展让CGI有了飞速的发展。一个好的艺术家可以创造出与现实几乎无法区分的产品。而如何检测AI生成的图片变得越来越困难，大多数模型的准确率只有70%左右，直到最近，模型突然能够以超过90%的准确率及逆行分辨。我们看看能否使用简单的方法也达到类似的检测指标。
我们这里要介绍的很多过程是特征工程而不是分类。这个过程包括几个步骤，看起来很复杂，但实际上他们的核心很简单。
1、将图像大小调整为256 * 256。2、应用傅里叶变换将图像转换为其频率表示。3、训练嵌入模型对图像进行分类并保留嵌入。4、应用梯度增强方法，如XGBoost，根据嵌入将图像分类为CGI或非CGI。
我们用的数据集是从ArtStation和Unsplash获得的真实照片和CGI图像，训练集中有大约630张图像，测试集中有158张图像。使用像XGBoost和嵌入这样的模型，CGI分类是困难的，但并非不可能。为什么要应用傅里叶变换?空间域图像将包含有关艺术作品主题的内容信息，但我们对此不感兴趣。我们只对噪声模式、风格和细微的美学差异感兴趣，这些可能会出现在频域，而不是空间域。
傅里叶变换本身有点复杂但总的来说，它是一系列不同频率的不同波的求和来形成原始图像。傅里叶变换将揭示噪声模式和其他频率信息被图像遮挡。嵌入模型将决定CGI和真实照片之间的差异。
我们这首先通过应用FFT算法提取一系列特征，FFT是Numpy中傅里叶变换的一种变体，然后应用Scikit-learn中的PCA。
import numpy as np from PIL import Image from scipy.fftpack import fft2 from tensorflow.keras.models import load_model, Model # Function to apply Fourier transform def apply_fourier_transform(image): image = np.array(image) fft_image = fft2(image) return np.abs(fft_image) # Function to preprocess image def preprocess_image(image_path): image = Image.open(image_path).convert('L') image = image.resize((256, 256)) image = apply_fourier_transform(image) image = np.expand_dims(image, axis=-1) # Expand dimensions to match model input shape image = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0deecdf539b64b39714685e0e355dc8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/71/">«</a>
	<span class="pagination__item pagination__item--current">72/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/73/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>