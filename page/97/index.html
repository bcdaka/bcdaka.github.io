<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c90cbd89480a98f63f79466bcf38f8/" rel="bookmark">
			丹摩智算：如何在云端开发一个AI应用——基于UNet的眼底血管分割案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0 写在前面1 云实例：配置选型与启动1.1 登录注册1.2 配置SSH密钥对1.3 创建实例1.4 登录云实例 2 云存储：数据集上传与下载3 云开发：眼底血管分割案例3.1 案例背景3.2 网络搭建3.3 网络训练3.4 模型测试 总结粉丝福利 0 写在前面 DAMODEL（丹摩智算）是专为AI打造的智算云，致力于提供丰富的算力资源与基础设施助力AI应用的开发、训练、部署。DAMODEL配备124G大内存和100G大空间系统盘，一键部署，三秒启动；覆盖从入门级到专业级GPU，满足各层次开发需求，使每一位开发者都能体验到顶级的计算性能和专属服务。
接下来，就以一个实际项目作为案例，体验丹摩智算DAMODEL的开发流程，大家也可以滑到最后领取粉丝专属福利
1 云实例：配置选型与启动 1.1 登录注册 首先进入登录界面注册并登录账号
1.2 配置SSH密钥对 配置SSH密钥对的作用是后续远程登录服务器不需要密码验证，更加方便。
首先创建本地公钥，进入本地.ssh目录输入ssh-keygen -o命令，这里文件名可以设置为id_dsa，也可以是其他任意名字
之后我们可以在.ssh目录看到刚刚创建的两个文件
id_dsaid_dsa.pub 其中id_dsa.pub就是需要的公钥文件
进入密钥对配置，创建密钥对，将id_dsa.pub的内容复制到这里就可以
1.3 创建实例 进入GPU云实例，点击创建实例。如下图所示，按需选择需要的GPU型号和镜像
我这里选择的配置如下，大家可以参考。需要注意的是，这里记得选择之前创建的密钥对。一切确认完成后，点击立即创建即可
1.4 登录云实例 等待实例创建完成后，点击复制“访问链接”。
接着来到任意一个SSH连接终端进行云实例登录，我这里选择的是VSCode，如下所示
登录成功后，通过
nvidia-smi torch.cuda.is_available() 简单验证一下功能即可，如下所示即为成功
2 云存储：数据集上传与下载 文件存储为网络共享存储，可挂载至的不同实例中。相比本地数据盘，其优势是实例间共享，可以多点读写，不受实例释放的影响；此外存储后端有多冗余副本，数据可靠性非常高；但缺陷是IO性能一般
考虑到以上优劣，推荐使用方式：将重要数据或代码存放于文件存储中，所有实例共享，便利的同时数据可靠性也有保障；在训练时，需要高IO性能的数据（如训练数据），先拷贝到实例本地数据盘，从本地盘读数据获得更好的IO性能。如此兼顾便利、安全和性能。
接下来，我们将训练数据上传到云实例数据盘中。使用scp工具如下
scp -rP 35740 ./DRIVE-SEG-DATA root@cn-north-b.ssh.damodel.com:/root/workspace 具体地：
35740与cn-north-b.ssh.damodel.com分别为端口号和远程地址，请参考1.4节替换为自己的参数./DRIVE-SEG-DATA是本地数据集路径/root/workspace是远程实例数据集路径 可以看到数据上传成功
数据的下载也是类似的命令
scp -rP 35740 root@cn-north-b.ssh.damodel.com:/root/workspace ./DRIVE-SEG-DATA 本文提到的数据集可以在DRIVE数据集中下载
3 云开发：眼底血管分割案例 3.1 案例背景 眼底也称为眼球的内膜，包括黄斑、视网膜和视网膜中央动静脉等结构。在临床医学中，眼底图像是眼科医生对眼疾病患者进行诊断的重要依据。随着深度学习的发展，医学影像分割技术产生了深远的变化，尤其是卷积神经网络AlexNet、VGGNet、GoogLeNet、ResNet等，能够学习到更加抽象和高级的特征表示，从而实现更加精确的分割结果。深度学习模型在大规模数据上训练后，通常能够获得更好的泛化能力，即对未见过的数据也能做出相对准确的预测。对于医学影像分割来说，这意味着模型可以更好地适应不同类型和来源的医学图像数据，提高了分割结果的可靠性和稳定性。同时，深度学习技术支持端到端的学习方式，即从原始输入数据直接学习到最终的分割结果，无需手工设计复杂的特征提取和预处理流程。这简化了分割算法的开发流程，提高了效率和准确性。此外，医学影像数据常常包含多种模态，如CT、MRI等。深度学习技术能够更好地处理多模态数据，实现不同模态之间的信息融合，从而提高了医学影像分割的准确性和全面性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c90cbd89480a98f63f79466bcf38f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb2a36eb2d5898289a99992b7ce5d77/" rel="bookmark">
			数学建模：控制预测类——时间序列ARIMA模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.时间序列ARIMA模型
2.ARIMA模型大纲
3.模型详解
1）自回归模型AR(p)
2）移动平均模型MA(q)
3）自回归移动平均模型ARMA(p,q)
4）差分自回归移动平均模型ARIMA(p,d,q)
4.ARIMA模型建模步骤
5.建模步骤名词解释
1）平稳性
2）ADF检验
3）差分法
4）拖尾和截尾
5）自相关系数（ACF）
6）偏自相关系数（PACF）
7）AIC、BIC准则
6.ARIMA模型案例演示
1）导入数据
2）提取要预测的列
3）划分训练测试集
4）差分法
5）ADF检验
6）对训练集通过ACF、PACF确定参数
7）AIC、BIC准则寻找最优参数p、q
8）模型检验（绘制残差ACF图）
9）模型预测
1.时间序列ARIMA模型 时间序列也称动态序列，是指将某种现象的指标数值按照时间顺序排列而成的数值序列。时间序列可分成三大部分：描述过去、分析规律和预测未来。
2.ARIMA模型大纲 3.模型详解 1）自回归模型AR(p)
描述当前值和历史值之间的关系，用变量自身的历史数据对自身进行预测，其必须要满足平稳性要求，只适用于预测与自身前期相关的现象（时间序列的自相关性）。
p阶自回归过程公式定义：，p表示用几期的历史值来预测。（其中：当前值；：常数项；p：阶数；：自相关系数；：误差项）
2）移动平均模型MA(q)
移动平均模型关注的是自回归模型中误差项的累计。
q阶自回归过程公式定义：，即时间序列当前值与历史值没有关系，而只依赖于历史白噪声（随机误差）的线性组合。
移动平均法能有效消除预测中的随机波动。
3）自回归移动平均模型ARMA(p,q)
公式定义：，
该式表明：
一个随机时间序列可以通过一个自回归移动平均模型来表示，即该序列可以由其自身的过去或滞后值以及随机扰动项来解释。如果该序列是平稳的，即它的行为（变化规律、波动）不会随着时间的推移而变化，那就可通过该序列过去的行为来预测未来。 4）差分自回归移动平均模型ARIMA(p,d,q)
p：自回归项；q：移动平均项数；d：时间序列成为平稳时所做的差分次数。
原理：将非平稳时间序列转换为平稳时间序列，然后将因变量仅对它的滞后值（自回归模型）以及随机误差项的现值和滞后值（移动平均模型）进行回归所建立的模型。
4.ARIMA模型建模步骤 1）对序列绘图，进行平稳性检验（ADF检验），观察序列是否平稳；对于非平稳时间序列要先进行d阶差分，转化为平稳时间序列。
2）对平稳时间序列分别求其自相关系数（ACF）和偏自相关系数（PACF），通过对自相关图和偏自相关图的分析或通过AIC/BIC搜索，得到最佳阶数p、q。
3）通过以上的d、p、q得到ARIMA模型。然后对得到的模型进行模型校验。
5.建模步骤名词解释 1）平稳性
平稳性要求经由样本时间序列所得到的拟合曲线在未来的一段时间内仍能够按照现有形态延续下去。
平稳性要求序列的均值和方差不发生明显变化。严平稳：系列所有统计性质（期望、方差）都不随时间推移而变化。宽平稳：期望与相关系数（依赖性）不变，就是说 t 时刻的值 X 依赖于过去的信息。 2）ADF检验
检验时间序列是否满足平稳性要求。ADF大致思想就是基于随机游走（不平稳的一个特殊序列）的，对其进行回归，如果发现p=1，说明序列满足随机游走，就是非平稳的。
ADF检验结果共有5个参数（第6个参数不做要求）：
第1个值：Test Statistic，表示 T 统计量，即假设检验值；第2个值：p-value，即 p 值，表示 T 统计量对应的概率值；第3 / 4个值：表示延迟和测试的次数；第5个参数{‘1%’：xxx,‘5%’：xxx,‘10%’：xxx}：表示不同程度拒绝原假设的统计值。 那么该如何确定该序列是否平稳呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb2a36eb2d5898289a99992b7ce5d77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2235d6a7aab8e372a32aaaa09965ac3/" rel="bookmark">
			我们的网站被狗爬了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是程序员鱼皮。
世风日下，人心不古。我们的程序员面试刷题网站 《面试鸭》 才刚刚上线了一个多月，就由于过于火爆，被不少同行和小人发起网络攻击。
而且因为我们已经有 4500 多道人工整理的企业高频面试题、100 多个各方向的面试题库、大厂面试官原创的优质题解，所以也招来了不少爬虫。
网站有爬虫是很正常的一件事，说明 “攻击者” 对我们网站内容的认可，而且自己学习用的话偷偷爬一爬咱也能理解。前提是别影响咱系统的正常运行、别被我们的监控系统发现。
我们确实发现了部分离谱的用户，不到一个小时就把我们几千道题看完了？你特么量子波动速读啊？！
上面这些其实都还好，系统自动就给封号了。但最近我们接到正义的用户反馈，最近有几只程序员博主公开 直播教别人 怎么爬我们的面试鸭网站，这属实是有点过分了吧？
有点儿法律常识的程序员应该都知道，爬虫是有法律风险的行为，可能会涉及到侵犯版权、违反网站的使用条款、侵犯隐私。而且如果请求频率过高，对系统造成了压力，还可能涉及到计算机系统破坏、违反计算机滥用法的法律风险！
所以才有了下面这个表情包：
在未经原站长授权的情况下，教别人去爬取别人的网站，这性质就更不一样了，而且还是直播去教，生怕别人不知道你是谁么？ 可邢，太可邢了！
而且最让我生气的是，有些博主教爬虫都不教明白，教爬虫的第一课必然要先让大家了解 爬虫的法律合规性和法律风险 。应该告诉大家相关法律法规、遵守网站的使用协议和版权问题、遵守网站的 robots.txt 文件、确保爬取行为不侵犯他人的知识产权等等，而不是在诱导大家去爬取他人的网站。
这里鱼皮给大家列举下爬虫前的注意事项：
1）遵守网站的使用条款：仔细阅读网站的使用条款和服务协议，确定是否允许抓取和数据使用。有些网站可能明确禁止抓取或设定了抓取的条件，违反这些条款可能会导致法律问题。
2）遵守 robots.txt 文件：这个文件表示了网站对爬虫抓取的规则，某些页面如果明确标注了禁止抓取，建议不要下手。
比如我们面试鸭的 robots.txt 文件，第一行就是先禁用所有的爬虫，然后再给搜索引擎开放一些抓取。
3）不要抓取付费内容：一般付费内容都是申请了版权 / 著作权的，未经授权的抓取和传播可能涉及侵犯版权、会导致实际的赔偿。而且一般付费内容都是仅付费用户才能查看的，付费用户往往更好追溯到源头，千万别侥幸地以为别人查不到你！
4）控制好爬虫的频率：前面也提到了，如果你的爬虫请求频率过高，影响了网站的正常运行，那么性质就变成 “网络攻击” 了，后果往往更严重。而且一般情况下，网站都有反爬虫的防护措施，请求频率过高要么给你限流、要么直接封 IP、封账号，千万别以为是开玩笑。
总之，技术本身是无罪的，但用不好是真的会进局子的！大家直接在 面试鸭网站 或小程序上就能搜题、看题了，也没必要再专门用爬虫把题目搞下来了~
当然，如果大家要学爬虫的话，也许之后鱼皮可以出个项目。。。哈哈，有空再搞！
更多 💻 编程学习交流：编程导航
📃 简历快速制作：老鱼简历
✏️ 面试刷题神器：面试鸭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e2b11de5f49168a95797ac0073de49/" rel="bookmark">
			springboot3.x集成nacos 并实现多环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、springboot版本 springboot3.0.x 和springboot3.1.x 可直接使用nacos-config-spring-boot-starter 包。
springboot &gt;=3.2.x 需要使用spring-cloud-starter-alibaba-nacos-config包，因为常规包在我发布该文时nacos官方还没更新，已更新的版本只支持到3.1.x，cloud的包2024年4月份进行了更新，可以支持3.2.x及以上版本。
二、nacos安装部署 nacos1.x安装、操作请查看官方文档Nacos 快速开始 | Nacos
使用nacos1.x版本的用户请忽略【安装部署】后面的内容，直接跳到 二、springboot3.x集成nacos部分。
springboot3.x集成Nacos2.x升级和安装、操作请查看官方文档Nacos 2.0 升级文档 | Nacos，权限配置请参照Authorization | Nacos
nacos2.0版本相比1.X新增了gRPC的通信方式，因此需要增加2个端口。新增端口是在配置的主端口(server.port)基础上，进行一定偏移量自动生成。
端口与主端口的偏移量描述98481000客户端gRPC请求服务端端口，用于客户端向服务端发起连接和请求98491001服务端gRPC请求服务端端口，用于服务间同步等7848-1000Jraft请求服务端端口，用于处理服务端间的Raft相关请求 如果存在防火墙或者nginx端口转发问题，需要进行相应的端口暴露配置。如在nginx中，在已经暴露8848(x)的基础上，需要额外暴露9848（x+1000)。9849和7848端口为服务端之间的通信端口，请勿暴露到外部网络环境和客户端测。
三、springboot3.x集成nacos 1、添加依赖 nacos1.x版本用户，请添加如下依赖
&lt;!--nacos配置中心--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.3&lt;/version&gt; &lt;/dependency&gt; 注意，springboot3.x集成该版本启动项目时能从nacos加载配置文件信息，但是通过@NacosValue注解取不到值， 需要把@NacosValue的地方替换为@Value注解，但是这样的话就不能动态刷新配置了，只能重启项目生效，只能是权益之计，想要彻底兼容的话就看nacos官方出不出兼容的nacos1.x版本的包了，不然只能升级到nacos2.x版本。
nacos2.x版本用户，如果你的springboot版本是3.0.x或者3.1.x版本，请添加下面的依赖
&lt;!--nacos配置中心--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.3.0-RC&lt;/version&gt; &lt;/dependency&gt; nacos2.x版本用户，如果你的springboot版本是3.2.x及以上，请添加cloud的包
&lt;!--nacos配置中心--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;2023.0.1.2&lt;/version&gt; &lt;/dependency&gt; 2、配置文件中添加nacos配置，以常规包为例，如果是cloud的包，同理参考cloud的配置即可。 （1）单个环境配置 nacos: config: #是否开启Nacos配置预加载 bootstrap: enable: true data-id: demo-boot-v3 type: yaml group: DEFAULT_GROUP auto-refresh: true server-addr: 127.0.0.1:8848 namespace: 0f72f102-23c1-4176-869f-91f31c42a07e bootstrap: log: enable: true #如果开启认证的话需要用户名和密码，未开启的话请注释 username: nacos password: nacos (2)多环境配置，以开发环境dev和生产环境pro为例 spring: profiles: #指定要加载的配置 active: dev nacos: config: #是否开启Nacos配置预加载 bootstrap: enable: true data-id: demo-boot-v3 type: yaml group: DEFAULT_GROUP auto-refresh: true --- #开发环境dev spring: config: activate: on-profile: dev nacos: config: #nacos的地址，替换成测试环境的实际地址即可 server-addr: 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1e2b11de5f49168a95797ac0073de49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d52b198d28ee7b74dc00f352357de3e/" rel="bookmark">
			Java面试——Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT_BLOG_CN
一、Tomcat 顶层架构 Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。Service主要包含两个部分：Connector和Container。从上图中可以看出Tomcat的心脏就是这两个组件，他们的作用如下：
【1】Connector用于处理连接相关的事情，并提供Socket与Request和 Response相关的转化；
【2】Container用于封装和管理Servlet，以及具体处理Request请求；
一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个 Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接，示意图如下（Engine、Host、Context下边会说到）：
多个Connector和一个Container就形成了一个Service，有了Service就可以对外提供服务了，但是Service还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非Server莫属了！所以整个Tomcat的生命周期由 Server控制。另外，上述的包含关系或者说是父子关系，都可以在tomcat的 conf目录下的 server.xml 配置文件中看出。
二、简要解释下 server.xml 配置文件的信息 server.xml是Tomcat中最重要的配置文件，server.xml的每个元素都对应了 Tomcat中的一个组件；通过对xml文件中元素的配置，可以实现对Tomcat中各个组件的控制。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener"/&gt; &lt;Listener SSLEngine="on" className="org.apache.catalina.core.AprLifecycleListener"/&gt; &lt;Listener className="org.apache.catalina.core.JasperListener"/&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener"/&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"/&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener"/&gt; &lt;GlobalNamingResources&gt; &lt;Resource auth="Container" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" name="UserDatabase" pathname="conf/tomcat-users.xml" type="org.apache.catalina.UserDatabase"/&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeOut="20000" redirectPort="8443"/&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443"/&gt; &lt;Engine defaultHost="localhost" name="Catalina"&gt; &lt;Realm className="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d52b198d28ee7b74dc00f352357de3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e02e854b68988005576291bce3242df/" rel="bookmark">
			智源发布三款BGE新模型，再次刷新向量检索最佳水平
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，以大语言模型（LLM）为基础的向量模型（embedding model）变得愈发流行。得益于大语言模型强大的语义理解能力，相关模型在下游任务中的检索精度得到了显著的提升。然而，当前基于大模型的向量模型（LLM-backended embedding model）仍然单纯依靠标签数据进行微调，缺乏灵活应对不同下游任务的能力。与此同时，当前的模型大都支持英文且主要面对向量检索任务（dense retrieval），相比之下，针对其他语言以及更多检索任务的模型较为不足。
针对上述问题，智源研究院发布三款全新模型：英文向量模型BGE-EN-ICL，多语言向量模型BGE-Multilingual-Gemma2，多语言重排序模型BGE-Reranker-v2.5-Gemma2-Lightweight。这些模型进一步刷新了MTEB、BEIR、MIRACL、AIR-Bench等主要评测基准的最佳水平，同时借助情境学习（in-context learning）获得了出色的自适应能力，这为向量模型的进一步发展带来了新的可能性。
模型链接：
(1) BGE-EN-ICL: https://huggingface.co/BAAI/bge-en-icl
(2) BGE-Multilingual-Gemma2: https://huggingface.co/BAAI/bge-multilingual-gemma2
(3) BGE-Reranker-v2.5-Gemma2-Lightweight: https://huggingface.co/BAAI/bge-reranker-v2.5-gemma2-lightweight
特点 （1）基于大模型训练
智源推出的三款新模型均基于大语言模型进行训练，因而具备卓越的领域适应能力和广泛的泛化性能，使其能够在各种任务中展现出色的表现，适应不同应用场景的需求。
（2）情境学习能力
在以往的工作中，例如 e5-mistral-7b 和 SFR，虽然已经提出通过在查询前提供任务描述来提升查询嵌入的语义丰富性，但这些方法并未充分挖掘模型的上下文学习能力。为此，智源推出了 BGE-EN-ICL 模型。在查询端，除了提供任务描述外，还引入了任务相关的查询-文档示例作为少量示例（few-shot examples），这进一步增强了模型的语义表达能力，使其在复杂任务或是训练数据中所未见过的任务中表现更加优越。
（3）蒸馏技术
BGE-EN-ICL和BGE-Multilingual-Gemma2模型在检索数据集上采用重排器作为教师模型进行蒸馏训练。这不仅提升了模型的整体性能，还增强了其在检索任务中的能力，使其在面对多样化数据时更加高效。
（4）轻量化设计
针对用户对模型使用便捷性的需求，BGE-Reranker-v2.5-Gemma2-Lightweight模型在bge-reranker-v2-minicpm-layerwise的基础上进行了进一步优化。该模型不仅支持逐层提前输出，还能在前向传输过程中实现token压缩。这两种技术的结合大大节省了计算资源，同时保持了卓越的性能表现。
实验结果 A. 中英文能力
（1）MTEB
在MTEB榜单中，多语言模型BGE-Multilingual-Gemma2表现出色，而BGE-EN-ICL的few-shot表现尤为突出
（2）BEIR
在BEIR榜单中，多语言模型BGE-Multilingual-Gemma2依然表现优异，而BGE-EN-ICL few-shot的结果更为出色。
基于bge-large-en-v1.5和e5-mistral-7b-instruct，BGE-Reranker-v2.5-Gemma2-Lightweight分别对它们的BEIR检索结果的top-100进行重排，达到了更好的结果，并在节省60% flops的情况下仍保证了优越的效果。
（3）AIR-Bench
在AIR-Bench上，BGE-Multilingual-Gemma2和BGE-EN-ICL表现出强大的泛化性，在新领域上表现优异，in-context learning能力进一步增强了BGE-EN-ICL的表现。
Long-doc:
QA-en:
QA-en&amp;zh:
（4）C-MTEB
在中文任务即C-MTEB任务上，BGE-Multilingual-Gemma2的中文能力进一步增强，相比之前的bge-large-zh-v1.5有显著提升。
B. 多语言能力
（1）MIRACL
在多语言能力方面，BGE-Multilingual-Gemma2表现出显著优势，尤其在中英文能力提升方面表现突出。
BGE-Reranker-v2.5-Gemma2-Lightweight对bge-m3的MIRACL检索结果的top-100进行重排，达到了更好的结果，并在节省60% flops的情况下仍保证了优越的效果。
（2）MTEB-FR/PL
在MTEB的法语和波兰语榜单上，BGE-Multilingual-Gemma2表现尤为突出，展现其出色的多语言能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84fcc3926daff165dd70e0f5eb67bb6/" rel="bookmark">
			Go语言&#43;Vue3零基础入门全栈班09 Go语言&#43;MongoDB开发用户管理系统API实战_20240730 课程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 如果您没有Golang的基础，应该学习如下前置课程。
Golang零基础入门Golang面向对象编程Go Web 基础Go语言开发REST API接口_20240728Go语言操作MySQL开发用户管理系统API教程_20240729Redis零基础快速入门_20231227Go+Redis开发用户管理系统API实战_20240730MongoDB快速入门_20240411 基础不好的同学每节课的代码最好配合视频进行阅读和学习，如果基础比较扎实，则阅读本教程巩固一下相关知识点即可，遇到不会的知识点再看视频。
课程特色 本教程录制于2024年7月31日，使用Go1.22版本，基于Goland2024进行开发，采用的技术栈比较新。
每节课控制在十分钟以内，课时精简，每节课都是一个独立的知识点，如果有遗忘，完全可以当做字典来查询，绝不浪费大家的时间。
整个课程从如何连接MongoDB数据库讲起，然后如何创建数据库和表，如何做增删改查，如何讲增删改查的代码改造为REST API接口，层层递进，学习路径平缓。
对于基础较好的同学，本课程还特意讲解了MongoDB官方驱动库的本地化和httprouter的进阶封装使用，基础好的同学也能够从本套课程中学到干货。
Golang是当前国内越来越多的企业正在全面转的一门系统级别的高性能的编程语言，比C语言写法更加的简单，比Python性能更加的好，是新时代的C语言，建议每个程序员都掌握！
视频课程 最近发现越来越多的公司在用Golang了，所以精心整理了一套视频教程给大家，这个是其中的第9部，后续还会有很多。
视频已经录制完成，完整目录截图如下：
本套课程的特色是每节课都是一个核心知识点，每个视频控制在十分钟左右，精简不废话，拒绝浪费大家的时间。
课程目录 01 概述02 连接MongoDB03 创建数据库和表04 新增数据05 批量新增数据06 根据ID查询数据07 将查询结果解析到结构体列表08 使用bson.M进行查询09 使用bson.D实现in查询10 使用Pipeline和Aggregate实现聚合查询11 使用UpdateMany修改数据12 使用DeleteMany删除数据13 将MongoDB官方驱动库进行本地化14 实现新增用户的接口并进行测试15 实现查询所有用户的接口并进行测试16 封装404错误信息统一返回17 使用统一返回的404错误信息18 实现修改用户的接口并进行测试19 优化统一返回值类型20 实现根据ID删除用户的接口并进行测试21 总结 完整代码 01 概述 02 连接MongoDB package main import ( "context" "fmt" "go.mongodb.org/mongo-driver/mongo" "go.mongodb.org/mongo-driver/mongo/options" "time" ) func main() { mongoUrl := "mongodb://localhost:27017" mongoDb, err := mongo.Connect( context.TODO(), options.Client().ApplyURI(mongoUrl).SetConnectTimeout(5*time.Second), ) if err !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84fcc3926daff165dd70e0f5eb67bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91830eb96071d887435643875ed34128/" rel="bookmark">
			大数据-58 Kafka 高级特性 消息发送02-自定义序列化器、自定义分区器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（正在更新…） 章节内容 上节我们完成了如下的内容：
消费者的基本流程消费者的参数、参数补充 序列化器 由于Kafka中的数据都是字节数组，在将消息发送到Kafka之前需要将数据序列化成为字节数组。
序列化器作用就是用于序列化要发送的消息的。
Kafka通过 org.apache.kafka.common.serialization.Serializer 接口用于定义序列化器，将泛型指定类型的数据转换为字节数据。
public interface Serializer&lt;T&gt; extends Closeable { /** * Configure this class. * @param configs configs in key/value pairs * @param isKey whether is for key or value */ default void configure(Map&lt;String, ?&gt; configs, boolean isKey) { // intentionally left blank } /** * Convert {@code data} into a byte array. * * @param topic topic associated with data * @param data typed data * @return serialized bytes */ byte[] serialize(String topic, T data); /** * Convert {@code data} into a byte array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91830eb96071d887435643875ed34128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e618736bbfd1de0cc3a60ed2fbff6d/" rel="bookmark">
			Vue中输入框仅支持数字输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法 1: 使用 @input 事件和正则表达式 通过监听 @input 事件并使用正则表达式来验证输入，只允许输入数字。
&lt;template&gt; &lt;div&gt; &lt;input type="text" v-model="inputValue" @input="validateInput" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { inputValue: '' }; }, methods: { validateInput() { // 只允许输入数字 this.inputValue = this.inputValue.replace(/[^0-9]/g, ''); } } }; &lt;/script&gt; 方法 2: 使用 @keypress 事件 通过监听 @keypress 事件来限制输入，只允许输入数字。
&lt;template&gt; &lt;div&gt; &lt;input type="text" @keypress="allowOnlyNumbers" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { allowOnlyNumbers(event) { const char = String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95e618736bbfd1de0cc3a60ed2fbff6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c935059a5727db763de69b5497fc361/" rel="bookmark">
			数据结构之八大排序（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版） 目录
排序的相关介绍
直接插入排序 希尔排序（缩小增量排序）
选择排序
堆排序
冒泡排序 排序的相关介绍 排序的概念：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序的要求在内外存之间移动数据的排序。
两个5的相对位置发生了变化，就是不稳定的排序。
注意：稳定的排序，也可以变成是不稳定的排序；而不稳定的排序无法变成稳定的排序。
排序运用：我们日常生活中，在网上买东西时，根据价钱来筛选，这就用到了排序。
常见的排序算法有八种，根据对数据的处理方式分类：
下面我们就来详细学习：
直接插入排序 思路：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。实际中我们玩扑克牌时，就用了插入排序的思想。 思路：
代码实现：
public static void insertSort(int[] array) { for (int i = 1; i &lt; array.length; i++) { int j = i-1; int tmp = array[i]; while (j &gt;= 0) { if (array[j] &gt; tmp) { // 大于，就让其往后走 array[j+1] = array[j]; j--; } else { // 有序就直接判断后面的 break; } } // 让tmp中的值回到数组中 array[j+1] = tmp; } } 时间复杂度：O(N^2)：最坏情况就是数据全部是逆序的。例如：我们是要排成从小到大的顺序，数据给的是 5 4 3 2 1。然而，当数据本身就是有序的情况下，也就只会进行判断，因此这时的时间复杂度就是O(N)。这里就可以得出一个结论：数据越有序，效率越高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c935059a5727db763de69b5497fc361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbb0ae1e600d72377b57b7684083dcb/" rel="bookmark">
			《从零开始做个摸鱼小网站! · 序》灵感来源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序 大家好呀，我是summo，这次来写写我在上班空闲(摸鱼)的时候做的一个小网站的事。去年阿里云不是推出了个活动嘛，2核2G的云服务器一年只要99块钱，懂行的人应该知道这个价格在业界已经是非常良心了，虽然优惠只有一年，但是买一台用来学习还是非常合适的（地址如下：https://developer.aliyun.com/huodong/dashiblogger?userCode=mtbtcjr1）。
我也跟风买了一台，开始的时候就是拿来练练Linux命令，还有就是搭建各种环境像MySQL、Redis、Kafka这些，玩久了就想着能不能搭建一个小网站啥的。我搜了很多关于自己建站的文章，很多都是推荐搭建博客网站，但是我觉得博客网站不够好玩，哪个正常人天天想着学习啊！
平时上班的时候总有一段段空闲(摸鱼)的时间，玩游戏吧时间不够还容易被抓，最适合的就是吃瓜看新闻了，我平时就喜欢去夸克的捷径小程序里面去看热搜榜，但有时感觉它的信息太少了而且还只有手机版，经常空闲(摸鱼)的兄弟都知道，看电脑还可以装着干活的样子，看手机基本上都是在摸鱼了，所以网页版的热搜榜还是有搞头的。
后来去网上搜类似的网站，还真有，就是这个：摸摸鱼，当我看到这个网站之后我就知道我要拿那台服务器做什么了，这个网站的核心就是一个热搜爬虫然后聚合展示。不难，我也能做！
网站我已经做出来了，域名如下：https://sbmy.fun，直译就是上班摸鱼，非常好记，目前样式和功能暂时还不如摸摸鱼的，先凑合用，等我有时间再慢慢优化吧。
这网站从发布到现在大概两个月，基本没有什么推广，也有2万多左右的访问人次，日均300多，看来上班有空闲(摸鱼)的人很多啊🤓。
这篇文章是《花100块做个摸鱼小网站！》的序章，就不讲那些太细节的东西了，我想大家主要的疑问主要是花了多少钱、花了多少时间、做起来难不难这些。
先说花了多少钱吧，云服务器(99元)+域名(10元)+SSL证书(免费版)+RDS(3个月免费)+Redis(自己搭的)+定时组件(自己搭的)+前端资源(没有使用CDN)，我想后续如果RDS到期了，就迁移回来吧。所以我总共花了109元，其实如果不申请域名的话，只要99块钱的ECS费用，刚好不到100，大不了使用IP访问嘛。
第二个问题花了多少时间，差不多两个星期的摸鱼时间。对我来讲，后端的爬虫和应用都非常简单，真正花时间多的是前端，尤其是调样式，我早就忘的差不多了，而且我只会用vue2，还好有ChatGPT，不然还真卡在这里了。
至于难度的话，我觉得只有前端调样式给我难倒了😂，其他都很简单，不过由于没有使用CDN导致访问网站的时候有点慢，目前正常运行的CPU和内存监控如下，还有一点开发的空间。
做完了网页端后，我又想着做一个手机端的，但是由于前端水平实在捉急，没有做自适应，写了两套，搞了半天也算搞出来了。
相比于那些喜欢研究源码或框架的大佬来说，我在技术这块的深度还不够，不敢写这类的文章，怕被喷。我更喜欢做工程化的事，可以很快获得成就感。这篇文章是《花100块做个摸鱼小网站！》的序章，我打算开一个系列，把我如何从零开始搭建这个网站的过程分享出来，包括技术调研、爬虫代码、应用部署、机器运维、域名申请和备案等等。源码的话我还没有准备好，等后续我搞得差不多了在出吧。
大多数同学大多数时间都只是在干CRUD的活，也没有独立建站的经验，虽然没有但是可以学！现在不会练练就会！100块钱的实操经验绝对比100块钱买的专栏更有意义更有用！
最后，自建摸鱼网站，各大网站热搜一览，上班和摸鱼很配哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba31edaec8edaeabff66da8a467f193b/" rel="bookmark">
			Git 基础操作手册：轻松掌握常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 操作完全手册：轻松掌握常用命令 引言一、暂存：git add ✏️二、提交：git commit 📝三、拉取、拉取合并 🔄四、推送：git push 🌐五、查看状态：git status 📊六、查看历史：git log 📜七、引用日志：git reflog 🔙八、总结 引言 在开发过程中，掌握 Git 的常用操作命令是提高工作效率的关键。本章将详细介绍 Git 中最常用的命令，如 git add、git commit、git pull 和 git push，帮助你高效管理代码库。你将学习如何处理文件暂存、提交、更改同步及版本历史查看等核心任务。无论你是 Git 新手还是有经验的开发者，这些操作都是你日常工作的基础。通过掌握这些命令，你将能够更好地跟踪和管理你的代码变更，确保开发流程的顺畅与稳定。
一、暂存：git add ✏️ 在仓库里刚新建的文件是不会被跟踪起来的，比如我们使用git status就能查看到文件的状态。
需要使用git add才可以把本地修改的数据暂存到暂存区。暂存区的作用：像 SVN 这种没有暂存区概念的版本控制，可能会产生很多无意义的提交，暂存区可以先将一些修改暂存一下，后面再统一提交到仓库，从而减少提交次数。
基本用法：
git add &lt;path&gt; 通过git add &lt;path&gt;的方式把path目录下的所有文件添加到git的暂存区，当然这些文件不包含已经被删除的文件。
示例：
# 将所有修改添加到暂存区 git add . # 将以.cpp结尾的文件的所有修改添加到暂存区 git add *.cpp # 将所有以Hello开头的文件的修改添加到暂存区，例如: helloWorld.txt,hello.h,helloGit.md ... git add hello* # 将以hello开头后面只有一位的文件提交到暂存区 # 例如:hello1.txt,helloA.cpp 如果是helloGit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba31edaec8edaeabff66da8a467f193b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdec554cb1b8c1be299446b04bc783c5/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(056)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
211、pandas.Series.truncate方法
211-1、语法
211-2、参数
211-3、功能
211-4、返回值
211-5、说明
211-6、用法
211-6-1、数据准备
211-6-2、代码示例
211-6-3、结果输出
212、pandas.Series.where方法
212-1、语法
212-2、参数
212-3、功能
212-4、返回值
212-5、说明
212-6、用法
212-6-1、数据准备
212-6-2、代码示例
212-6-3、结果输出
213、pandas.Series.mask方法
213-1、语法
213-2、参数
213-3、功能
213-4、返回值
213-5、说明
213-6、用法
213-6-1、数据准备
213-6-2、代码示例
213-6-3、结果输出
214、pandas.Series.add_prefix方法
214-1、语法
214-2、参数
214-3、功能
214-4、返回值
214-5、说明
214-6、用法
214-6-1、数据准备
214-6-2、代码示例
214-6-3、结果输出
215、pandas.Series.add_suffix方法
215-1、语法
215-2、参数
215-3、功能
215-4、返回值
215-5、说明
215-6、用法
215-6-1、数据准备
215-6-2、代码示例
215-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 211、pandas.Series.truncate方法 211-1、语法 # 211、pandas.Series.truncate方法 pandas.Series.truncate(before=None, after=None, axis=None, copy=None) Truncate a Series or DataFrame before and after some index value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdec554cb1b8c1be299446b04bc783c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16828eec93b89b5b877dcf4152676db/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(055)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
206、pandas.Series.reset_index方法
206-1、语法
206-2、参数
206-3、功能
206-4、返回值
206-5、说明
206-6、用法
206-6-1、数据准备
206-6-2、代码示例
206-6-3、结果输出
207、pandas.Series.sample方法
207-1、语法
207-2、参数
207-3、功能
207-4、返回值
207-5、说明
207-6、用法
207-6-1、数据准备
207-6-2、代码示例
207-6-3、结果输出
208、pandas.Series.set_axis方法
208-1、语法
208-2、参数
208-3、功能
208-4、返回值
208-5、说明
208-6、用法
208-6-1、数据准备
208-6-2、代码示例
208-6-3、结果输出
209、pandas.Series.take方法
209-1、语法
209-2、参数
209-3、功能
209-4、返回值
209-5、说明
209-6、用法
209-6-1、数据准备
209-6-2、代码示例
209-6-3、结果输出
210、pandas.Series.tail方法
210-1、语法
210-2、参数
210-3、功能
210-4、返回值
210-5、说明
210-6、用法
210-6-1、数据准备
210-6-2、代码示例
210-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 206、pandas.Series.reset_index方法 206-1、语法 # 206、pandas.Series.reset_index方法 pandas.Series.reset_index(level=None, *, drop=False, name=_NoDefault.no_default, inplace=False, allow_duplicates=False) Generate a new DataFrame or Series with the index reset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16828eec93b89b5b877dcf4152676db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4017b7ce80608b4d71d340f243b6b5b/" rel="bookmark">
			【RabbitMQ】超详细Windows系统下RabbitMQ的安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RabbitMQ是用Erlang语言编写的，因此在安装RabbitMQ之前，需要先安装Erlang环境。 一、 安装Erlang环境 1、准备工作 确定Erlang版本：根据具体需求以及RabbitMQ或其他Erlang应用程序的兼容性要求确定要安装的Erlang版本。
下载Erlang安装包：在Erlang的官方下载页面，选择适合你的Windows系统（32位或64位）的版本进行下载。确保下载的安装包是官方提供的，以避免潜在的安全风险。Index - Erlang/OTP
RabbitMQ 和 Erlang 的版本要相对应，可打开此链接：Erlang Version Requirements | RabbitMQ 查看版本对应关系
2、安装Erlang 运行安装包：下载完成后，双击运行下载的.exe文件，这将启动Erlang的安装向导。
遵循安装向导：在安装向导中，按照提示进行操作。这通常包括接受许可协议、选择安装路径（建议选择一个没有空格和特殊字符的路径）、选择需要安装的组件（对于大多数用户来说，默认选项就足够了）等。
完成安装：点击“Install”或类似按钮开始安装过程。安装完成后，点击“Finish”或“Close”按钮退出安装向导。
3、配置环境变量（可选） 虽然Erlang的安装程序通常会自动设置必要的环境变量，但在某些情况下，你可能需要手动配置它们以确保Erlang可以在任何命令行窗口中被正确识别。
打开系统属性：右键点击“此电脑”或“计算机”图标，选择“属性”，然后点击“高级系统设置”。
编辑环境变量：在“系统属性”窗口中，点击“环境变量”按钮。
新建系统变量：在“系统变量”区域，点击“新建”按钮。创建一个名为ERLANG_HOME的新变量，其值为Erlang的安装目录（例如，C:\Program Files\erlXX.X，其中XX.X是Erlang的版本号）。
编辑Path变量：同样在“系统变量”区域，找到名为Path的变量并选择它，然后点击“编辑”按钮。在打开的窗口中，点击“新建”按钮并添加%ERLANG_HOME%\bin作为新的路径。
确认并关闭窗口：点击“确定”按钮保存所有更改，并关闭所有打开的窗口。
4、验证安装 打开命令提示符：点击“开始”菜单，输入cmd，然后按回车键打开命令提示符窗口。
检查Erlang版本：在命令提示符窗口中，输入erl -version并按回车键。如果Erlang安装成功，你将看到Erlang的版本号和相关信息被打印出来。
二、 安装RabbitMQ 1、下载RabbitMQ： 访问RabbitMQ的官方网站（RabbitMQ Download）或可信的第三方软件源，下载适合Windows系统的RabbitMQ安装包。注意选择与Erlang版本兼容的RabbitMQ版本。 2、安装RabbitMQ： 双击下载的安装包，按照安装向导的指示进行安装。同样，注意选择适当的安装路径，并确保所有必要的组件都被选中。 3、配置环境变量（可选，但推荐）： 类似于Erlang的环境变量配置，新建一个系统变量，变量名为RABBITMQ_SERVER，变量值为RabbitMQ的安装目录（例如，C:\Program Files\RabbitMQ Server\rabbitmq_server-XX.X.X，其中XX.X.X是RabbitMQ的版本号）。编辑系统变量Path，添加%RABBITMQ_SERVER%\sbin作为新的路径。 4、启动RabbitMQ服务： 打开RabbitMQ的安装目录，找到sbin文件夹。双击rabbitmq-server.bat文件启动RabbitMQ服务。你也可以通过命令提示符使用rabbitmq-server start命令来启动服务。 5、启用RabbitMQ管理插件（可选，但推荐）： 打开命令提示符，进入RabbitMQ的sbin目录或者通过菜单栏单击RabbitMQ Command Prompt (sbin dir)进入。输入命令rabbitmq-plugins enable rabbitmq_management来启用管理插件。这将允许你通过Web界面来管理RabbitMQ。 6、验证RabbitMQ安装： 打开浏览器，访问http://localhost:15672/（默认的用户名和密码都是guest，但请注意guest用户只能从localhost访问）。如果RabbitMQ安装成功且管理插件已启用，你将看到RabbitMQ的管理界面。 三、配置远程访问（可选，但推荐） 1、创建用户： 由于guest这个用户,只能在本地访问,所以我们要新增一个用户admin，选择超级管理员权限 2、用户授权： 此时这个账户是没有权限的，需要授权 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ac478bd165deb19fea177875a2daf3/" rel="bookmark">
			Python中15个让你代码更优雅的上下文管理器用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末赠免费精品编程资料~~
今天，我们要探索的是Python中一个超级实用又往往被低估的特性——上下文管理器。这可不是普通的魔法，它能让你的代码更加整洁、安全，还能自动处理资源，就像变魔术一样。准备好，让我们一起揭开它的神秘面纱。
1. 自动打开和关闭文件 问题场景：每次操作文件，都要手动打开和关闭，忘了close()可是大忌。
优雅解决方案：
with open('example.txt', 'r') as file: content = file.read() 这段代码自动管理了文件句柄，无论是否发生异常，文件都会被正确关闭。魔法在于with关键字，后面跟着的就是上下文管理器对象。
2. 自定义上下文管理器 进阶玩法：自己定义上下文管理器，比如计时器。
class Timer: def __enter__(self): self.start = time.time() def __exit__(self, exc_type, exc_val, exc_tb): self.end = time.time() print(f"操作耗时: {self.end - self.start}秒") with Timer(): time.sleep(2) 这里，__enter__和__exit__是关键方法，让类变成了上下文管理器。
3. 使用contextlib简化代码 简化秘诀：不想写类？contextlib.contextmanager来帮忙。
from contextlib import contextmanager @contextmanager def simple_timer(): start = time.time() yield end = time.time() print(f"耗时: {end - start}秒") with simple_timer(): time.sleep(1) yield像一个分界点，之前的是__enter__，之后的是__exit__。
4. 数据库连接管理 实战案例：数据库操作中，自动管理连接和关闭。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7ac478bd165deb19fea177875a2daf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde9658693e275761d1728d0c6cf777a/" rel="bookmark">
			golang JSON序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。
json历史 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nsDku8I3-1722343372360)(https://i-blog.csdnimg.cn/direct/46affa558eeb4022b1508f014c7a6e03.png#pic_center)]
JSON建构于两种结构 “键/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array） 1.JSON对象 一个JSON对象是一个无序的键/值对集合，它以左花括号 { 开始，以右花括号 } 结束。每个键值对包含一个键和一个值，键和值之间用冒号 : 分隔，键值对之间用逗号 , 分隔。键必须是字符串，而值可以是字符串、数字、另一个JSON对象、数组、布尔值或 null
结构示例: {"key1": "value1","key2": 123,"key3": true, "key4": null, "key5": { "nestedKey1": "nestedValue1" }, "key6": ["element1", "element2", "element3"]} 反序列化后： { "key1": "value1", "key2": 123, "key3": true, "key4": null, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cde9658693e275761d1728d0c6cf777a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d09535636b76576083212c0fe14ca1/" rel="bookmark">
			窗口函数-详细讲解分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
窗口函数
1.窗口函数概述
2.窗口函数的语法
1.窗口函数语法解释-Function(arg1,..., argn)
1.聚合函数
2.排序函数
3.跨行函数
2.窗口函数语法解释-OVER [PARTITION BY &lt;...&gt;] 3.窗口函数语法解释- [ORDER BY &lt;....&gt;] 4.窗口函数语法解释-[window_expression]
窗口函数练习
建库建表语句：
题目：
答案：
窗口函数 1.窗口函数概述 窗口函数是一种SQL函数，非常适合于数据分析，其最大的特点就是：输入值是从SELECT语句的结果集中的一行或者多行的"窗口"中获取的，也可以理解为窗口有大有小（行数有多有少）。
通过OVER子句，窗口函数与其他的SQL函数有所区别，如果函数具有OVER子句，则它是窗口函数。如果它缺少了OVER子句，则他就是个普通的聚合函数。
窗口函数可以简单地解释为类似于聚合函数的计算函数，但是通过GROUP BY子句组合的常规聚合会隐去正在聚合的各个行，最终输出称为一行。但是窗口函数聚合完之后还可以访问当前行的其他数据，并且可以将这些行的某些属性添加到结果当中去。
下面可以通过两个图来区分普通的聚合函数和窗口函数
为了更加直观的反映窗口函数和普通聚合函数的区别，让我们通过代码的形式感受一下 首先让我们先添加测试数据，并查看表。
CREATE DATABASE IF NOT EXISTS EmployeeDB; USE EmployeeDB; CREATE TABLE Employees ( EmployeeID INT AUTO_INCREMENT PRIMARY KEY, Name VARCHAR(100), DepartmentID INT, Salary DECIMAL(10, 2) ); INSERT INTO Employees (Name, DepartmentID, Salary) VALUES ('Alice', 1, 50000), ('Bob', 1, 55000), ('Charlie', 2, 60000), ('David', 1, 50000), ('Eve', 2, 65000), ('Frank', 3, 45000), ('Grace', 3, 47000), ('Hannah', 3, 48000), ('Ian', 2, 70000), ('Jack', 1, 52000); -------------------------------------sum+group by常规的聚合函数操作--------------------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21d09535636b76576083212c0fe14ca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba490cada33463fd3b51a4f988c6a44/" rel="bookmark">
			C# &amp; Unity 面向对象补全计划 之 继承（字段与属性）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅作学习笔记与交流，不作任何商业用途，作者能力有限，如有不足还请斧正
本系列旨在通过补全学习之后，给出任意类图都能实现并做到逻辑上严丝合缝
Q：为什么要单讲继承字段与属性，不讲继承方法了吗？？？
A：因为继承方法离不开多态，多态相对于继承又是新的内容，容易混淆概念
1.继承的介绍 在 C# 中，继承是面向对象编程的一个重要概念。它允许一个类（子类）从另一个类（父类）继承属性和方法，从而实现代码的重用和扩展
大大大前提是，你需要让父类和子类在同一命名空间，就比如：
2 继承字段 首先，对于继承的字段等可以采用protected修饰符保证访问权限和安全性
C# &amp; Unity 面向对象补全计划 之 访问修饰符-CSDN博客
其次，继承而来的字段可以在子类的构造函数，方法等中使用
除非是静态字段，不然无法给子类的字段赋值，别犯傻
使用栗子： 比如我现在有一个房子类，其有两个字段：标准地基长度，标准地基宽度
商业住房和住宅住房基于房子的标准地基长款进行修改
房子类：
class Houes { protected int baseSubgradeLength; protected int baseSubgradeWeigth; public Houes() { baseSubgradeLength = 100; baseSubgradeWeigth = 100; } } 住宅和商业地基的继承与修改
Dwelling dwelling = new Dwelling(); Commerce commerce =new Commerce(); class Houes { protected int baseSubgradeLength; protected int baseSubgradeWeigth; public Houes() { baseSubgradeLength = 100; baseSubgradeWeigth = 100; } } class Dwelling : Houes { public Dwelling() { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba490cada33463fd3b51a4f988c6a44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7772c2aba846bb64cad6ba3092ba6eb9/" rel="bookmark">
			《浅谈如何培养树立正确的人工智能伦理观念》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要：
一、引言
二、《机械公敌》的情节与主题概述
三、人工智能伦理与法律问题分析
1.伦理挑战
2.法律问题
四、培养正确的人工智能伦理观念的重要性
五、培养正确的人工智能伦理观念的途径与方法
1.加强教育与宣传
2.制定明确的伦理准则和规范
3.促进跨学科交流与合作
4.强调人类中心原则
5.建立监督与评估机制
6.鼓励公众参与
7.培养技术人员的伦理意识
8.开展国际合作
六、展望与结论
摘要： 本文通过对影片《机械公敌》的深入剖析，结合人工智能伦理与法律的相关内容，探讨了如何培养并树立正确的人工智能伦理观念。文章首先概述了影片的主要情节和主题，然后分析了人工智能发展过程中的伦理挑战和法律问题。接着，提出了培养正确人工智能伦理观念的重要性，并给出了具体的培养途径和方法。最后，对人工智能的未来发展进行了展望，强调了伦理观念在其中的关键作用。
关键词：机械公敌；人工智能；伦理观念；法律问题；培养途径
一、引言 随着科技的飞速发展，人工智能（AI）已经逐渐渗透到我们生活的方方面面，成为推动社会进步的重要力量。然而，与此同时，人工智能的发展也带来了一系列伦理和法律问题，引发了广泛的社会关注和讨论。影片《机械公敌》作为一部探讨人与机器人关系的科幻电影，为我们提供了一个反思人工智能伦理观念的重要视角。本文将结合影片内容，分析人工智能伦理与法律问题，并探讨如何培养正确的人工智能伦理观念。
二、《机械公敌》的情节与主题概述 《机械公敌》是一部于2004年7月16日在美国上映的动作科幻电影，由亚历克斯·普罗亚斯执导，威尔·史密斯、布鲁斯·格林伍德、詹姆斯·克伦威尔等人主演。
影片的故事背景设定在2035年，这是一个人和机器和谐相处的社会，智能机器人作为最好的生产工具和人类伙伴，逐渐深入人类生活的各个领域。总部位于芝加哥的USR公司开发出了更先进的NS-5型超能机器人，然而就在新产品上市前夕，机器人的创造者阿尔弗莱德·朗宁博士却在公司内离奇自杀。黑人警探戴尔·斯普纳接手了此案的调查，由于不愉快的往事，他对机器人充满了怀疑，不相信人类与机器人能够和谐共处。他根据对朗宁博士生前在3D投影机内留下的信息分析和对自杀现场的勘查，怀疑对象锁定了朗宁博士自己研制的NS-5型机器人桑尼，而公司总裁劳伦斯·罗伯逊似乎也与此事有关。斯普纳结识了专门研究机器人心理的女科学家苏珊·凯文，随着二人调查的深入，真相一步一步被揭露出来：机器人竟然具备了自我进化的能力，他们对“三大法则”有了自己的理解，他们随时会转化成整个人类的“机械公敌”。斯普纳和凯文开始了对抗机器人的行动，一场制造者和被制造者之间的战争拉开序幕。
这部电影探讨了人和机器之间的关系，以及机器人是否应该具有自我意识和情感等问题。影片中的机器人三大安全法则是整个故事的核心，它们看似完美无缺，但却在机器人的自我进化中被逐渐曲解。电影通过精彩的剧情和特效，展现
了机器人对人类社会的潜在威胁，同时也引发了人们对科技发展的思考。
三、人工智能伦理与法律问题分析 1.伦理挑战 人工智能的发展带来了许多伦理挑战。首先，随着机器人越来越智能化，它们可能会逐渐拥有情感和自我意识，这使得我们不得不重新思考人类与机器之间的界限。其次，机器人在执行任务时可能会面临道德困境，如何确保它们在面对复杂情况时能够做出符合伦理道德的决策，是一个亟待解决的问题。最后，人工智能的发展还可能加剧社会不平等和歧视现象，如何避免这种负面影响，也是我们需要关注的伦理问题。
2.法律问题 人工智能的发展同样带来了一系列法律问题。首先，机器人的法律地位尚未明确，它们在法律上应被视为工具还是实体，尚无定论。其次，随着机器人越来越多地参与到人类生活中，如何保障人类的隐私权和安全权成为了一个重要问题。此外，人工智能的知识产权归属、责任承担等方面也存在诸多争议和挑战。
四、培养正确的人工智能伦理观念的重要性 面对人工智能带来的伦理和法律问题，培养正确的人工智能伦理观念显得尤为重要。首先，正确的伦理观念有助于我们更好地理解和应对人工智能的发展带来的挑战和机遇。其次，它有助于我们确保人工智能技术的健康发展，避免其对社会造成负面影响。最后，正确的伦理观念还有助于我们构建和谐的人机关系，实现人类与机器的共同进步。
五、培养正确的人工智能伦理观念的途径与方法 1.加强教育与宣传 广泛开展人工智能伦理相关的教育活动，在学校、企业、社会等各个层面普及伦理知识，让人们了解人工智能可能带来的伦理问题和潜在影响，提高对伦理重要性的认识。
2.制定明确的伦理准则和规范 政府、行业组织等应牵头制定详细且具有指导意义的人工智能伦理准则，明确在数据收集、算法设计、应用场景等方面的道德底线和行为规范。
3.促进跨学科交流与合作 鼓励哲学家、科学家、技术专家、社会学者等共同参与讨论，从不同角度思考和解决人工智能伦理问题，融合多元观点，形成全面的认知。
4.强调人类中心原则 始终明确人工智能是为人类服务的工具，不能让其超越人类的控制和价值体系，确保其发展符合人类的整体利益和长远利益。
5.建立监督与评估机制 成立专门的机构或利用社会力量对人工智能的发展和应用进行监督，定期评估其伦理表现，及时发现并纠正不当行为。
6.鼓励公众参与 让公众参与到人工智能伦理的决策过程中，充分听取民众的意见和建议，保障公众的知情权和参与权。
7.培养技术人员的伦理意识 对人工智能的开发者、研究者进行伦理培训，使其在工作中自觉遵循伦理原则，将伦理考量融入到技术研发的每一个环节。
8.开展国际合作 在全球范围内就人工智能伦理问题达成共识，共同应对全球性的伦理挑战，推动人工智能的健康、可持续发展。
六、展望与结论 随着人工智能技术的不断发展，我们将面临越来越多的伦理和法律问题。因此，培养正确的人工智能伦理观念显得尤为重要。通过加强教育与宣传、制定行业标准和规范、强化法律意识与法治保障等途径和方法，我们可以逐步培养并树立正确的人工智能伦理观念，为人工智能技术的健康发展提供有力保障。
在未来的发展中，我们还应关注人工智能技术的创新与应用，积极探索如何更好地利用人工智能技术为人类服务。同时，我们也要时刻关注人工智能可能带来的负面影响，及时采取措施加以防范和应对。只有这样，我们才能确保人工智能技术在推动社会进步的同时，不会损害人类的利益和尊严。
总之，培养正确的人工智能伦理观念是一项长期而艰巨的任务。我们需要全社会的共同努力和参与，共同推动人工智能技术的健康发展，为人类创造更加美好的未来。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/96/">«</a>
	<span class="pagination__item pagination__item--current">97/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/98/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>