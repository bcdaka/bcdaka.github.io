<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e889814c0294f42d9377024366ad86ae/" rel="bookmark">
			Java 集合框架：Java 中的 Set 集合（HashSet &amp; LinkedHashSet &amp; TreeSet）特点与实现解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 017 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
相较于 List 集合与 Map 集合，Set 集合可以讨论的点其实很少，这主要的原因是因为无论是哪一种 Set 集合的实现类其实都是基于 Map 集合的，而如果深究其原理，其实就是去深究 Map 的实现，而我不打算对 Map 的解读放在 Set 的章节…
当然除了主要实现之外，Set 也是有很多值得我们关注的特点的，比如他的无序性，对并发流、序列化以及非序列化的实现，以及主要实现类 HashSet、TreeSet、LinkedHashSet 三者的区别，只是由于可能真正值得关注的点不是很多，所以我在本系列中将整个 Set 压缩为了一篇文章。
文章目录 1、Set 集合介绍1.1、Set 接口概述1.2、实现类 HashSet1.3、实现类 TreeSet1.4、实现类 LinkedHashSet1.5、三种 Set 集合对比 2、HashSet 底层实现2.1、HashSet 构造函数实现2.2、HashSet 主要方法实现 3、TreeSet 底层实现3.1、TreeSet 构造方法实现3.2、TreeSet 特色方法实现 1、Set 集合介绍 1.1、Set 接口概述 Set 是 java.util 包下集合框架中一个接口，它是 Collection 接口的一个子接口，表示不允许包含重复元素的集合。Set 集合的特点是集合内的元素无序，且每个元素都是唯一的。这意味着即使试图添加两个相等的对象（依据 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e889814c0294f42d9377024366ad86ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fceba71971702bc990f350043150d5f2/" rel="bookmark">
			【前端从入门到精通：第九课：CSS3新增属性及伸缩盒布局】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		弹性盒模型 介绍
伸缩盒模型也叫弹性盒模型，或flex。它决定一个盒子在其它盒子中的分布，以及如何处理可用的空间。使用该模型，可以轻松的创建“自适应”浏览器窗口的流动布局。
flexbox是一个很新的东西，在w3c希望可以使用flexbox实现一些更复杂的布局和应用。传统盒模型基于HTML文档流排列，使用弹性盒模型可以规定特定的顺序。要开启弹性盒模型，只需要设置display的属性值 flex，因为它是CSS3中为display新添加的值类型。
目的
在浏览器窗口变化时，盒子相应改变大小。 设置了弹性盒模型后，float，clear和vertical-align在flex中不起作用。
display:flex 定义父容器是一个弹性盒。
案例
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;flex&lt;/title&gt; &lt;style&gt; .one{ width:980px; height: 500px; border:1px solid #ddd; margin: 20px auto; /*伸缩盒属性需要给容器设置*/ display: flex; } .one&gt;div{ width: 400px; height: 300px; border:1px solid tomato;; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--父容器--&gt; &lt;div class="one"&gt; &lt;!--每一个被包含的就是一个项目--&gt; &lt;div&gt;左&lt;/div&gt; &lt;div&gt;中&lt;/div&gt; &lt;div&gt;右&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; display:inline-flex 定义父容器时行内弹性盒
案例
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;flex&lt;/title&gt; &lt;style&gt; .one{ width:980px; height: 500px; border:1px solid #ddd; margin: 20px auto; /*伸缩盒属性需要给容器设置*/ display: inline-flex; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fceba71971702bc990f350043150d5f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23352932e6b3cd301775a870f8dbdbcd/" rel="bookmark">
			【AI大模型】赋能儿童安全：楼层与室内定位实践与未来发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言第一章：AI与室内定位技术1.1 AI技术概述1.2 室内定位技术概述1.3 楼层定位的挑战与解决方案 第二章：儿童定位与安全监控的需求2.1 儿童安全问题的现状2.2 智能穿戴设备的兴起 第三章：技术实现细节3.1 硬件设计与选择传感器选择与布局 3.2 软件架构与开发系统架构设计数据采集与处理 3.3 定位算法的实现与优化3.4 数据处理与分析数据预处理模型训练与优化 3.5 系统集成与测试硬件与软件的集成系统测试与验证用户体验与反馈优化 第四章：技术实现深入分析4.1 硬件设计与优化气压传感器蓝牙模块与信标 4.2 定位算法的实现与优化基于Wi-Fi的定位算法基于UWB的高精度定位 4.3 数据处理与分析数据清洗与特征提取 4.4 行为分析与异常检测4.5 系统集成与测试系统集成系统测试 第五章：案例研究与实际应用案例一：学校中的儿童定位与安全监控案例二：商场中的儿童定位与找回系统 第六章 楼层定位具体实现方案6.1. Python代码示例6.2 多传感器融合示例6.3. 未来发展与改进方向 第七章：未来研究方向7.1 多模态传感器融合7.2 深度学习与智能分析7.3 边缘计算与实时处理7.4 数据隐私与安全保护7.5 低功耗与长续航设计 第八章：总结 引言 随着人工智能（AI）和物联网（IoT）技术的快速发展，智能穿戴设备在儿童安全领域的应用正日益广泛。尤其是楼层与室内定位技术，为儿童安全监控提供了精确的技术支撑。本文将深入探讨AI技术在儿童定位与安全监控中的应用，详细介绍相关技术的实现方法，并展望未来的发展趋势。
第一章：AI与室内定位技术 1.1 AI技术概述 人工智能（AI）技术通过模拟人类智能，能够处理复杂的任务，如图像识别、自然语言处理和决策制定等。近年来，AI技术在各个领域的应用都取得了显著进展，特别是在定位和监控方面。
1.2 室内定位技术概述 室内定位技术通过使用各种传感器和算法，实现对物体或人的精确定位。常用的室内定位技术包括Wi-Fi定位、蓝牙定位、超宽带（UWB）定位和视觉定位等。相比于GPS在室外环境中的应用，室内定位技术解决了在复杂室内环境中的定位难题。
1.3 楼层定位的挑战与解决方案 楼层定位在室内定位中具有特殊的挑战，主要因为楼层之间的高度差较小，信号干扰较多。气压传感器、Wi-Fi信号强度指纹、蓝牙信标和UWB技术的结合，可以有效解决楼层定位的问题。
第二章：儿童定位与安全监控的需求 2.1 儿童安全问题的现状 儿童走失和意外伤害是全球关注的重大问题。无论是在学校、商场还是公共场所，儿童都面临走失的风险。如何利用先进技术实时监控儿童的位置，是解决这一问题的关键。
2.2 智能穿戴设备的兴起 智能穿戴设备如智能手表、定位手环和安全背包等，逐渐成为儿童安全监控的重要工具。这些设备通过集成多种传感器和通信模块，可以实时采集儿童的位置信息，并通过AI算法进行分析，提供准确的安全监控。
第三章：技术实现细节 3.1 硬件设计与选择 传感器选择与布局 实现儿童定位与安全监控系统需要选择合适的传感器：
气压传感器：用于楼层定位，通过测量大气压力来判断高度和楼层位置。Wi-Fi模块：用于采集Wi-Fi信号强度，构建楼层的Wi-Fi指纹库。蓝牙模块：用于与低功耗蓝牙信标通信，实现小范围高精度的定位。UWB模块：提供高精度的室内定位。摄像头：用于视觉定位和行为分析，识别儿童的位置和动态行为。 3.2 软件架构与开发 系统架构设计 系统软件架构应包括以下几个关键模块：
数据采集模块：从传感器和通信模块中采集数据。数据处理模块：进行预处理、特征提取和数据清洗。定位算法模块：实现基于传感器数据的定位和基于AI模型的定位算法。安全监控模块：分析儿童的行为数据，识别异常行为并发出警报。用户界面模块：提供用户交互界面，显示儿童位置、安全状态和报警信息。 数据采集与处理 以下是一个基本的数据采集与预处理示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23352932e6b3cd301775a870f8dbdbcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f208b0091a87e8939bd7215d869bc38/" rel="bookmark">
			【C/C&#43;&#43;】VSCode 插件支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++基础 C/C++（包括C/C++ IntelliSense, debugging, and code browsing.）C/C++ Theme：UI Themes for C/C++ extension.Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code llVM增强 CodeLLDB：这个插件就是安装llvm，如果你已经安装了就无所谓了,如果没有安装,这个插件会自己安装一个.clangd：这个插件是C++ 主要插件 ,比下面的C/C++插件好用,需配置安装llvmClang-Format 智能提示 &amp; 代码生成 CodeGeeX （zhipu ai）Tabnine AICopilot Refernce https://blog.csdn.net/m0_38036750/article/details/138889172
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6225715e861530c74de3431cfa52faaf/" rel="bookmark">
			分享一个进阶版的钓鱼宏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 钓鱼，设置鼠标左键的宏命令
2. 收竿，恢复默认模式的宏命令
功能1. 聊天框输出文字提醒
功能2. 自动装配自定义的鱼竿(需修改自定义鱼竿，这个部分 /equip )
功能3. 钓鱼模式下，再点一次宏命令装配鱼饵 (需修改自定义鱼饵 ， 这个部分 /use 水下诱鱼器 )
功能4. 恢复默认时，自动装配自定义的武器(需自定义武器，主副手这个部分 /equip )
功能5. 语音播报(鱼竿，武器装配情况)，这个就可以用来判断宏命令是否正常运行
钓鱼，设置鼠标左键的宏命令：
#showtooltip 钓鱼
/run print("[钓鱼] 已设置鼠标左键钓鱼：已自动装配鱼竿，开始钓鱼！")SetBindingSpell("BUTTON1","钓鱼")
/run C_VoiceChat.SpeakText(0, "钓鱼模式，已装配鱼竿", Enum.VoiceTtsDestination.LocalPlayback, 0, 100)
/equip 精致的卡鲁亚克鱼竿
/use 水下诱鱼器
/use 16
/click staticPopup1Button2
/stopspelltarget
收竿，恢复默认模式的宏命令：
#showtooltip 钓鱼
/script print("[收竿] 已恢复默认鼠标左键：已自动装配主副手武器！")SetBinding("BUTTON1","CAMERAORSELECTORMOVE")
/run C_VoiceChat.SpeakText(0, "默认模式，已装配武器", Enum.VoiceTtsDestination.LocalPlayback, 0, 100)
/script SaveBindings(1)
/equip 断骨权杖
/equip 无尽寒冬
/equip 这个是武器切换，/equip 精致的卡鲁亚克鱼竿 这个是你的鱼竿，其他都可不用动，还有语音提示哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33003e3c392a7337d7e32bef51170cc9/" rel="bookmark">
			2024华为OD机试题库-(C卷&#43;D卷)-(JAVA、Python、C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一名资深后端开发人员，精通C++，Python，Java，机考经验丰富，已帮助千余名同学通过OD机考！
2024年5月-10月，考的都是 OD统一考试(D卷)，题库已经准备好，三道全中概率95%以上。
据参加D卷考试的同学反馈，D卷和C卷是相同的题目。如果发现新题，会及时更新。祝大家考试顺利！如发现解法不全的题目，请私信我！
(免费试读) 2024华为OD机试真题-小朋友来自多少小区-(C++/Java/Python)-C卷D卷-100分
(免费试读)2024华为OD机试真题-找数字-(C++/Java/Python)-C卷D卷-200分
2024华为OD机试题库-(A卷+B卷+C卷+D卷)-(JAVA、Python、C++)_华为机考题库2023-CSDN博客
以下是 C卷+D卷 100分题目： 序号题目分数考点语言1 密码输入检测
100栈结构C++、Python、JAVA2 内存冷热标记
100多条件排序C++、Python、JAVA3 找座位
100逻辑分析C++、Python、JAVA4 转盘寿司
100数据结构，单调栈C++、Python、JAVA5 最多购买宝石数目
100滑动窗口，双指针C++、Python、JAVA6最富裕的小康家庭100逻辑分析C++、Python、JAVA7精准核酸检测100逻辑分析C++、Python、JAVA8最长字符串的长度(一)100逻辑分析C++、Python、JAVA9螺旋数字矩阵100逻辑分析C++、Python、JAVA10分配土地100数据结构，几何知识C++、Python、JAVA11智能成绩表100自定义排序C++、Python、JAVA12来自异国的客人100进制转换C++、Python、JAVA13CPU算力分配100逻辑分析C++、Python、JAVA14去重求和100数据结构C++、Python、JAVA15英文输入法100字符串处理C++、Python、JAVA16小明找位置100二分查找C++、Python、JAVA17素数之积100数学知识C++、Python、JAVA18寻找连续区间100逻辑分析C++、Python、JAVA19绘图机器100逻辑分析C++、Python、JAVA20悄悄话花费的时间100二叉树层序遍历C++、Python、JAVA21用连续自然数之和来表达整数100逻辑分析C++、Python、JAVA22机场航班调度100自定义排序C++、Python、JAVA23剩余银饰的重量100逻辑分析C++、Python、JAVA24Family Day/园区参观路径100动态规划C++、Python、JAVA25查找接口成功率最优时间段100滑动窗口C++、Python、JAVA26整型数组按个位数值排序100自定义排序C++、Python、JAVA27考勤信息100字符串处理C++、Python、JAVA28机器人搬砖100二分查找C++、Python、JAVA29全量和已占用字符集100数据结构C++、Python、JAVA30出租车计费、靠谱的车100逻辑分析C++、Python、JAVA31山脉个数、攀登者100数据结构、栈C++、Python、JAVA32游戏分组、王者荣耀100排列组合C++、Python、JAVA33分割均衡字符串100逻辑分析C++、Python、JAVA34找出作弊的人100多条件排序C++、Python、JAVA35整数对最小和100逻辑分析C++、Python、JAVA36最长指定瑕疵度的元音子串100滑动窗口C++、Python、JAVA37字符串序列判定100字符串处理C++、Python、JAVA38虚拟理财游戏100暴力枚举C++、Python、JAVA39查找众数及中位数100数学知识C++、Python、JAVA40停车场车辆统计100逻辑分析C++、Python、JAVA41求最多可以派出多少支团队100双指针C++、Python、JAVA42找朋友100单调栈C++、Python、JAVA43数组去重和排序100自定义排序C++、Python、JAVA44按身高和体重排序100自定义排序C++、Python、JAVA45围棋的气100逻辑分析C++、Python、JAVA46万能字符单词拼写、掌握单词的个数100字符串处理C++、Python、JAVA47小华地图寻宝100深度优先搜索C++、Python、JAVA48执行任务赚积分100数据结构C++、Python、JAVA49计算三叉搜索树的高度100树结构C++、Python、JAVA50API集群负载统计100数据结构C++、Python、JAVA51小明的幸运数字100逻辑分析C++、Python、JAVA52学生重新排队100逻辑分析C++、Python、JAVA53字符串分割（二）100字符串处理C++、Python、JAVA54字符串变换最小字符串100逻辑分析C++、Python、JAVA55分披萨100递归+缓存优化C++、Python、JAVA56生成哈夫曼树100哈弗曼树构建+中序遍历C++、Python、JAVA57求幸存数之和100动态数组C++、Python、JAVA58会议室占用时间100区间合并C++、Python、JAVA59手机App防沉迷系统100逻辑分析C++、Python、JAVA60堆内存申请100逻辑分析C++、Python、JAVA61小朋友来自多少小区100贪心思维C++、Python、JAVA62字符串筛选排序100字符串处理C++、Python、JAVA63多段线数据压缩100逻辑分析C++、Python、JAVA64测试用例执行计划100多条件排序C++、Python、JAVA65灰度图存储100逻辑分析C++、Python、JAVA66火星文计算2100字符串处理C++、Python、JAVA67求字符串中所有整数的最小和100逻辑分析C++、Python、JAVA68求满足条件的最长子串长度100滑动窗口C++、Python、JAVA69连续字母长度100字符串处理C++、Python、JAVA70拼接URL100正则匹配C++、Python、JAVA71GPU任务调度100逻辑分析C++、Python、JAVA72寻找身高相近的小朋友100逻辑分析C++、Python、JAVA73数组连续和100动态规划C++、Python、JAVA 以下是 C卷+D卷 200分题目： 序号题目分数考点语言1爱吃蟠桃的孙悟空200二分查找C++、Python、JAVA2石头剪刀布游戏200数据结构C++、Python、JAVA3快递员的烦恼200全排列C++、Python、JAVA4最小矩阵宽度200逻辑分析C++、Python、JAVA5园区参观路径200动态规划C++、Python、JAVA6考古学家200dfs深度优先搜索C++、Python、JAVA7欢乐的周末200dfsC++、Python、JAVA8员工派遣200二分查找C++、Python、JAVA9高效货运200完全背包C++、Python、JAVA10贪吃的猴子200逻辑分析C++、Python、JAVA11信道分配200逻辑分析C++、Python、JAVA12最大社交距离200逻辑分析C++、Python、JAVA13两个字符串间的最短距离200动态规划C++、Python、JAVA14字符串拼接200回溯算法C++、Python、JAVA15跳马200广度优先搜索C++、Python、JAVA16解密犯罪时间200全排列、dfsC++、Python、JAVA17电脑病毒感染200dijkstra算法C++、Python、JAVA18二叉树计算200二叉树前序中序遍历C++、Python、JAVA19分月饼200递归C++、Python、JAVA20最长连续手牌200回溯算法C++、Python、JAVA215G网络建设200最小生成树C++、Python、JAVA22Wonderland200动态规划C++、Python、JAVA23攀登者2200逻辑分析C++、Python、JAVA24部门人力分配200双指针C++、Python、JAVA25数据单元的变化替换200递归C++、Python、JAVA26找数字200逻辑分析C++、Python、JAVA27中文分词模拟器200逻辑分析C++、Python、JAVA28符号运算200数据结构C++、Python、JAVA29根据IP查找城市200逻辑分析C++、Python、JAVA30文件缓存系统200逻辑分析C++、Python、JAVA31学生重新排队200逻辑分析C++、Python、JAVA32抢7游戏200动态规划C++、Python、JAVA33寻找最优的路测线路200dijkstra算法C++、Python、JAVA34篮球游戏200双端队列C++、Python、JAVA35项目排期200二分法+回溯C++、Python、JAVA36最长连续手牌200回溯算法C++、Python、JAVA37启动多任务排序200拓扑排序C++、Python、JAVA38贪心歌手200贪心算法C++、Python、JAVA39反射计数200数学问题C++、Python、JAVA40模拟目录管理功能200树形结构C++、Python、JAVA41加密算法、特殊的加密算法200dfsC++、Python、JAVA42田忌赛马200回溯算法C++、Python、JAVA43最长子字符串的长度(二)200前缀和C++、Python、JAVA44运输时间200逻辑分析C++、Python、JAVA45推荐多样性200逻辑分析C++、Python、JAVA46查找一个有向网络的头节点和尾节点200拓扑排序C++、Python、JAVA47快递员的烦恼200全排列C++、Python、JAVA48伐木工200动态规划C++、Python、JAVA49最大社交距离200逻辑分析C++、Python、JAVA50文本统计分析200正则表达式C++、Python、JAVA51信道分配200C++、Python、JAVA52欢乐的周末200dfsC++、Python、JAVA53二叉树的广度优先遍历200bfsC++、Python、JAVA54图像物体的边界200并查集C++、Python、JAVA55找单词200dfsC++、Python、JAVA56找城市200并查集C++、Python、JAVA57可以组成网络的服务器200dfs/bfsC++、Python、JAVA58简易内存池200区间交集C++、Python、JAVA59数字排列200回溯算法C++、Python、JAVA60模拟数据序列化传输200字符串C++、Python、JAVA 2024华为OD机试经验分享-华为OD上岸攻略-CSDN博客
每年5，6月份是找工作的黄金季节，这期间的工作机会多，面试比较容易，也较容易获得不错的薪资。
华为OD机试题库每半年更新一次，也就是一直到2024年10月都是考C卷D卷，大家有充足的时间准备和复习！
希望大家抓住机会，好好复习，预祝大家都能取得满意的成绩！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d4834929cb73818913e262c2f0d7f0/" rel="bookmark">
			Java项目：基于SSM框架实现的健康综合咨询问诊平台【ssm&#43;B/S架构&#43;源码&#43;数据库&#43;毕业论文】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介 本项目是一套基于SSM框架实现的健康综合咨询问诊平台
包含：项目源码、数据库脚本等，该项目附带全部源码可作为毕设使用。
项目都经过严格调试，eclipse或者idea 确保可以运行！
该系统功能完善、界面美观、操作简单、功能齐全、管理便捷，具有很高的实际应用价值
二、技术实现 jdk版本：1.8 及以上
ide工具：IDEA或者eclipse
数据库: mysql5.7
后端：spring+springmvc+mybatis+maven+mysql
前端：jsp，css，jquery
三、系统功能 系统用户包括有管理员、医生、用户
主要功能如下：
用户登录
用户注册
首页
个人中心
修改密码
个人信息
科室管理
医生管理
医生坐诊管理
用户咨询管理
用户管理
拉黑用户
预约挂号管理
用户病例管理
用户病例附件下载
健康资讯管理
系统管理
轮播图管理
客服管理
预约挂号
点我收藏
评价
四、页面 五、文档 六、数据库 七、源码地址 https://download.csdn.net/download/weixin_43860634/89525981
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f5431fb3005e65f785f3a9b28ad876/" rel="bookmark">
			拓扑学习系列（9）计算代数拓扑中的复形COMPLEXES
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复形 在代数拓扑学中，复形（complexes）是一种重要的代数结构，用于研究拓扑空间的代数性质和同调理论。复形由一系列的单纯形（simplices）以特定方式组合而成，形成一个复杂的结构，通过这种结构可以描述空间的拓扑性质。
复形的计算涉及到构建不同维度的单纯形，并确定它们之间的边界关系。具体步骤包括：
构建单纯形：首先，需要确定构建复形所需的各个维度的单纯形。单纯形是一个几何概念，可以看作是几何空间中的简单形状，如点、线段、三角形等。
确定边界映射：对于每个单纯形，需要确定其边界。边界映射描述了单纯形边界上的点如何组合成边和面。这些边界映射构成了复形的边界算子，是计算同调群的关键。
构建复形：将这些单纯形按照一定规则组合成复形。根据单纯形之间的边界关系，可以构建一个复杂的拓扑结构，用于研究空间的代数性质。
计算同调群：通过应用边界算子，可以计算复形的同调群。同调群是一种代数不变量，描述了拓扑空间的“洞”的结构，有助于理解空间的拓扑特征。
计算代数拓扑中的复形涉及到代数结构和拓扑空间的深入理解，通常需要一定的数学知识和技巧。通过对复形的构建和同调群的计算，我们可以揭示拓扑空间的结构和性质，从代数的角度深入理解空间的几何特征。
单纯形（simplices） 单纯形（simplices）是代数拓扑学和几何学中的基本概念，用于描述多维空间中的简单几何形状。单纯形是构建复形（complexes）和进行同调理论的基本构建块，其具有简单而清晰的几何特征，便于研究空间的拓扑性质。
一个 nn 维单纯形是一个几何对象，可以被视为 n+1n+1 个顶点及其所确定的凸包（convex hull）。具体来说：
0 维单纯形是一个点，由一个顶点确定。1 维单纯形是线段，由两个顶点确定。2 维单纯形是三角形，由三个顶点确定。3 维单纯形是四面体，由四个顶点确定。以此类推，nn 维单纯形是由 n+1n+1 个顶点确定的凸多面体。 单纯形的名称来源于数学术语“单纯”（simplex），表示它们是构成更高维结构的基本构建单元。在复形中，单纯形可以按照一定规则组合成更复杂的结构，形成一个代数结构，用于研究空间的拓扑性质。
在代数拓扑学中，单纯形的概念是非常重要的，通过对单纯形的组合和边界关系的研究，我们可以构建复形并计算同调群，从而深入了解空间的几何和代数结构。
边界映射 确定单纯形的边界映射是计算代数拓扑学中复形同调的关键步骤之一。边界映射描述了单纯形边界上的点如何组合成边和面，从而形成复形的边界算子。以下是确定边界映射的一般步骤：
定义单纯形的顶点和边：首先，对于给定的 nn 维单纯形，标记它的 n+1n+1 个顶点。然后确定单纯形的边，即单纯形的各个顶点之间的连接关系。
确定边界方向：对于每个 nn 维单纯形，需要确定一个边界方向。在一般情况下，可以使用右手法则或者固定顺序的方式来确定边界方向。
定义边界映射：边界映射将 nn 维单纯形映射到其 (n-1)(n−1) 维边界上。对于 nn 维单纯形，其边界映射将会包含 n+1n+1 个 (n-1)(n−1) 维单纯形，分别对应单纯形的各个边。这些边界映射的组合构成了边界算子。
使用符号表示边界映射：一种常见的方式是使用符号表示边界映射，例如使用加减号来表示边界方向。通过符号表示，可以清晰地展示单纯形之间的边界关系。
计算边界映射：最后，根据定义的边界映射规则，计算每个单纯形的边界映射，并将其组合成边界算子。这个边界算子可以用来计算复形的同调群，从而研究空间的拓扑性质。
确定边界映射需要一定的几何直觉和代数技巧，同时也需要理解单纯形的结构和边界关系。通过仔细定义和计算边界映射，可以有效地分析复形的结构和计算同调群。
构建复形 构建复形（complexes）是代数拓扑学中的重要任务之一，通过将单纯形（simplices）按照一定规则组合而成，形成一个复杂的代数结构，用于研究空间的拓扑性质和进行同调理论。以下是构建复形的一般步骤：
确定单纯形：首先，确定构建复形所需的各个维度的单纯形。单纯形是代数拓扑学中的基本构建块，可以是点、线段、三角形、四面体等几何形状。
定义单纯形之间的连接关系：对于每个单纯形，定义它与其他单纯形之间的连接关系。根据单纯形的维度，确定它们之间的共享边、面或顶点关系。
遵循组合规则：根据单纯形的连接关系，遵循一定的组合规则将单纯形组合成复形。通常，复形是通过将单纯形沿着它们的边界连接而成的。
验证复形的性质：构建复形后，需要验证复形是否满足一些基本性质，例如闭合性、连通性和单连通性等。这些性质对于研究空间的拓扑特征非常重要。
计算同调群：一旦构建了复形，可以利用边界算子计算复形的同调群。同调群是一种代数不变量，描述了复形的拓扑结构，有助于理解空间的几何性质。
通过构建复形，我们可以将空间的几何性质转化为代数结构，深入研究空间的拓扑性质和进行同调理论的计算。对于复杂的空间，构建复形是一种有效的方法，使得我们可以通过代数方法来理解和分析空间的结构。
组合规则 在代数拓扑学中，构建复形时需要遵循一些组合规则，以确保复形的结构良好并适用于同调理论的研究。以下是构建复形时常用的一些组合规则：
封闭性（Closure）：复形是由单纯形按照一定规则组合而成的，每个单纯形的边界都包含在复形中。这保证了复形的封闭性，即复形的每个面都是复形的一部分。
无重复边界（No duplicate boundaries）：在复形中，每个单纯形的边界只能在复形中出现一次。这意味着任何两个单纯形之间最多只有一个共享的边界。
单连通性（Simply connectedness）：复形应该是单连通的，即对于任意两点，可以通过复形内的路径连通。这保证了复形的连通性，使得同调理论能够有效地应用。
合适的连接方式：单纯形之间的连接方式应该符合拓扑空间的要求。例如，对于一个复形中的 nn 维单纯形，它们应该沿着 n-1n−1 维单纯形的边界连接。这样的连接方式有利于计算复形的同调群。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80f5431fb3005e65f785f3a9b28ad876/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e2b7ee676789ce95e0e1d195d48e27/" rel="bookmark">
			消防认证-防火窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、消防认证
消防认证是指消防产品符合国家相关技术要求和标准，且通过了国家认证认可监督管理委员会审批，获得消防认证资质的认证机构颁发的证书，消防产品具有完好的防火功能，是住房和城乡建设领域验收的重要指标。
二、认证依据
GB 16809-2008 防火窗
三、认证单元
认证单元
钢质防火窗
木质防火窗
钢木复合防火窗
四、认证申请所需资料
1. 基本信息：
① 认证申请书
② 认证委托人、制造人和生产厂的营业执照
③ 商标或品牌证明文件
④ 认证委托人、制造商和生产厂的委托关系证明
2.审核相关资料：
① OEM/ODM的知识产权关系证明
② 产品工艺流程图
③ 生产厂组织机构图
④ 型式检验报告
⑤ 常规检测仪器
⑥ 生产场地
3.型式检验内容
序号
测试要求
测试标准
1
外观质量
GB 16809
2
防火玻璃
GB 16809
3
尺寸偏差
GB 16809
4
抗风压性能
GB 16809
5
气密性能
GB 16809
6
耐火性能
GB 16809
7
热敏感元件的静态动作温度
GB 16809
8
活动窗扇尺寸允许偏差
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e2b7ee676789ce95e0e1d195d48e27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afeca5376746c69be3e13a9ddf220f62/" rel="bookmark">
			在Java中使用OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 前言 最近工作上有个项目，涉及到一些有关图像的操作，正好得知有OpenCV这一个开源库。在网上查找了一些资料，发现OpenCV有很多妙用，例如人脸识别、车牌识别等，甚至有大佬能用它来做自动驾驶。感觉挺有意思的，小记一下。
# 一 、OpenCV 1.简介 OpenCV (开源计算机视觉库) 是一个开源的BSD许可库，其中包含数百种计算机视觉算法。它为开发者提供了Java、C++和Python接口，支持Windows、Linux和Android。
OpenCV被广泛应用于各种领域，例如安防监控、智能驾驶、机器人视觉、虚拟现实等。
官网文档地址：OpenCV: OpenCV Tutorials
参考教程：OpenCV官方文档_w3cschool
2.下载与安装 下载地址：Releases - OpenCV
根据自己需要，选择版本以及对应的平台，这里版本选4.10.0，平台选Windows。
下载后是一个exe，双击安装即可。
3.目录说明 安装完成后的目录如下：
build为构建后的文件，sources是OpenCV的源代码，我们进入build：
因为我们是java开发，所以进入java文件夹，其中有个opencv-4100.jar,这个是我们开发中需要用到的jar包。x64与x86代表不同的系统，我们是在x64系统中使用，所以选择x64,打开文件夹后里面有一个dll文件，这也是我们开发中需要调用的库文件。
# 二、在Java项目中使用 我使用的开发软件是 IntelliJ IDEA，因此这里将展示在IDEA中集成OpenCV。
1.打开或新建一个项目
2.使用快捷键 Shift + Ctrl + Alt + S 打开项目设置，或鼠标右击项目，选择 “打开项目设置”
3.选择 “模块” → 选中项目 → “依赖” → “+(添加)” → “1.JAR或目录...” → 找到下载的OpenCV-4100.jar → "确定"
4.找到刚刚添加进来的jar包，"右建" → "编辑" → "+(添加)" → 找到下载的opencv_java4100.dll → "确定"
以上步骤完成后，就可以开始编码了。
需要注意的是，如果maven依赖有变更，OpenCV需要重新导入,目前我还没发现解决方法，若有大佬能解决这个问题，恳请告知，小弟不胜感激！
# 三 、测试 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afeca5376746c69be3e13a9ddf220f62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193e649f760983346652ed3bc169f541/" rel="bookmark">
			【Java]认识泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包装类 在Java中，由于基本类型不是继承自Object，为了在泛型代码中可以支持基本类型，Java给每个基本类型都对应了一个包装类型。
除了 Integer 和 Character， 其余基本类型的包装类都是首字母大写。
泛型 泛型是在JDK1.5引入的新的语法，通俗讲，泛型：就是适用于许多许多类型。
泛型语法规则：
class 泛型类名称&lt;类型形参列表&gt; {
// 这里可以使用类型参数
}
class ClassName&lt;T1, T2, ..., Tn&gt; { }
class 泛型类名称&lt;类型形参列表&gt; extends 继承类/* 这里可以使用类型参数 */ {
// 这里可以使用类型参数
}
class ClassName&lt;T1, T2, ..., Tn&gt; extends ParentClass&lt;T1&gt; {
// 可以只使用部分类型参数
}
我们来简单实现一个泛型：
class MyArray&lt;T&gt;{ public T[] array = (T[]) new Object[10]; public void setArray(int pos,T val ){ this.array[pos] = val; } public T getArray(int pos){ return array[pos]; } } public class Test1 { public static void main(String[] args) { MyArray&lt;Integer&gt; myArray = new MyArray&lt;&gt;(); myArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/193e649f760983346652ed3bc169f541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ab31bab8b382668fc364ff62929f28/" rel="bookmark">
			【LLM】二、python调用本地的ollama部署的大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 往期文章：
【LLM】一、利用ollama本地部署大模型
目录
文章目录
前言
一、ollama库调用
二、langchain调用 三、requests调用
四、相关参数说明：
总结
前言 本地部署了大模型，下一步任务便是如何调用的问题，实际场景中个人感觉用http请求的方式较为合理，本篇文章也将通过http请求的方式来调用我们本地部署的大模型，正文开始。
一、ollama库调用 参考文档：ollama的python库调用
注意，这里的ollama不是我们第一篇安装的那个Ollama！！！！不要搞混
1、环境准备：
pip install ollama 2、调用示例：
如果你都是按照默认设置安装的Ollama，即host和port等均未设置，那执行以下代码即可 import ollama res=ollama.chat(model="phi3",stream=False,messages=[{"role": "user","content": "你是谁"}],options={"temperature":0}) print(res) 返回结果如：
如果你更改了Ollama的配置，比如更改了监听端口，则执行下边代码： import ollama host="xxx" port="xxx" client= ollama.Client(host=f"http://{host}:{port}") res=client.chat(model="qwen2:1.5b",messages=[{"role": "user","content": "你是谁"}],options={"temperature":0}) print(res) 返回结果如：
其中，host和port改为你自己的即可
二、langchain调用 参考链接：langchain调用ollama
1、安装依赖：
pip install langchain pip install langchain_community 2、调用示例
from langchain_community.llms import Ollama host="xxx" port="xxx" #默认的端口号为11434 llm=Ollama(base_url=f"http://{host}:{port}", model="qwen2:1.5b",temperature=0) res=llm.invoke("你是谁") print(res) 其中，host和port改为你自己的即可
结果如：
三、requests调用 1、安装依赖
pip install requests 2、调用示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3ab31bab8b382668fc364ff62929f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3238e49c6dfe583e27785a2a1c26c3b/" rel="bookmark">
			初识Java（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观学习，乐观生活，才能不断前进啊！！！
我的主页：optimistic_chen
我的专栏：c语言
创作不易，大佬们点赞鼓励下吧~
前言 Java语法有部分是和C语言中是相似的，所以两者可以在熟悉的部分可以相互借鉴学习。本篇博客就从运算符和逻辑控制来学习Java的语法。
文章目录 前言运算符算数运算符关系运算符逻辑运算符逻辑与&amp;&amp;逻辑或||逻辑非！短路求值 位运算符移位运算符条件运算符 逻辑控制完结 运算符 Java也提供了一套丰富的运算符来操纵变量。Java中运算符可分为以下：算术运算符(+ - */)、关系运算符(&lt; &gt; ==)、逻辑运算符、位运算符、移位运算符以及条件运算符等
算数运算符 +、-、*、/
注意：
都是二元运算符，使用时必须要有左右两个操作数
int / int 结果还是int类型，而且会向下取整
int a = 3; int b = 2; // 在数学中应该是1.5 但是在Java中输出结果为1 会向下取整，即小数点之后全部舍弃掉了 System.out.println(a / b); 根据上一篇博客中所提到的数据类型不同时的情况，当两侧操作数类型不一致时，向类型大的提升。
关系运算符 关系运算符主要有六个: == != &lt; &gt; &lt;= &gt;= ，其计算结果是 true 或者 false 。
int a = 1; int b = 2; // 注意：在Java中 = 表示赋值，要与数学中的含义区分 // 在Java中 == 表示相等 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3238e49c6dfe583e27785a2a1c26c3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c95bcc2ebb9cfe6104b2d890af13f9/" rel="bookmark">
			iOS 开发者的 Flutter 入门课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名 iOS 开发者，入门 Flutter 需要了解一些新的工具和概念，但也能利用你已有的知识和技能。以下是一个详细的入门指南，帮助你快速上手 Flutter：
1. 环境设置 首先，你需要设置开发环境。
安装 Flutter SDK 前往 Flutter 官方网站 下载 Flutter SDK。解压下载的文件并将 flutter/bin 目录添加到系统的 PATH 环境变量中。 安装开发工具 Visual Studio Code（推荐） 或 Android Studio：这两个都是不错的 Flutter 开发 IDE 选择。安装 Flutter 和 Dart 插件：在你的 IDE 中安装相应的插件，以支持 Flutter 开发。 安装 Xcode 作为 iOS 开发者，你应该已经安装了 Xcode。确保你有最新版本，并在 Xcode 中安装必要的命令行工具。
2. 创建第一个 Flutter 项目 打开你的终端（Terminal）并运行以下命令创建一个新项目：flutter create my_first_flutter_app 进入项目目录：cd my_first_flutter_app 启动你的代码编辑器（如 VS Code）：code . 3. 运行项目 连接你的 iOS 设备或启动模拟器。在终端中运行以下命令启动应用：flutter run 4. 理解 Flutter 基础 Flutter 的核心概念与 iOS 开发有一些相似之处，但也有其独特的地方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c95bcc2ebb9cfe6104b2d890af13f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5175cf0c961ff7d5b83212cfae7e61a/" rel="bookmark">
			技术速递｜使用默认 lambda 参数重构代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：David Pine
排版：Alan Wang
本文是探讨 C# 12的各种功能的四篇系列文章中的最后一篇。在这篇文章中，我们将探讨“默认 lambda 参数”功能，使开发人员能够在 lambda 表达式中使用默认参数值。本系列涵盖了很多内容：
使用主构造函数重构 C# 代码使用集合表达式重构 C# 代码使用任意类型别名重构 C#代码使用默认 lambda 参数重构代码（本篇文章） 这些功能是我们不断努力提高代码可读性和可维护性的一部分。让我们详细探索它们！
默认 Lambda 参数 默认 lambda 参数是 C# 12 中的一项新功能，允许开发人员在 lambda 中表达默认参数值。此功能是 C# 方法中现有默认参数功能的自然扩展。
C# 12 之前 在 C# 12 之前，当您定义需要提供某种默认行为的 lambda 表达式时，您必须使用空合并运算符 (??) 或条件运算符 (?😃。请查看以下示例：
var IncrementBy = static (int source, int? increment) =&gt; { // Same as source + (increment.HasValue ? increment.Value : 1) return source + (increment ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5175cf0c961ff7d5b83212cfae7e61a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b147ca9b23e7da9f434614e2c3f182/" rel="bookmark">
			【C&#43;&#43; STL】模拟实现 vector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：【C++ STL】模拟实现 vector
@水墨不写bug
（图片来源于网络）
正文开始：
STL中的vector是一个动态数组，支持随机访问，可以根据需要来扩展数组空间。
本项目将实现vector的部分常用功能，以增强对vector的熟悉程度，了解STL容器的工作原理，积累项目经验，也为将来自主实现和改造容器奠定坚实的基础。
STL内实现的vector是一个类模板，也就是vector的数据类型理论上可以是任意的数据类型，本文力求与STl采取类似的方法，通过类模板来实现vector。更接近于STL的实现方法，自然会让你对STL有更深的理解。
一、明确方式，铺平道路 1.文件问题 以前我们在实现string的时候，采用分文件操作：
string.h
string.cpp
这是一个非常好的习惯，无疑为在项目进展，和后期维护时提供了便利。但是我们要实现的vector是通过类模板来实现的，如果还将vector类内部的函数的声明与定义分离，就会出现问题：
由于类模板在编译时不会实例化，所以当我们想要调用这个类的成员函数的时候，就会发现没有匹配的成员函数，没有办法调用成员函数。于是，在用类模板实现vector时，我们不再分为vector.h和vector.cpp两个文件，而是将h和cpp文件合并为一个h文件，这样在同一个类模板中就可以调用成员函数了。
二、vector功能简介 I、构造函数和析构函数 默认构造函数：创建一个空的vector对象。带大小和初始值的构造函数：创建一个包含指定数量元素的vector，每个元素都被初始化为相同的值。范围构造函数：通过迭代器或指针的范围来初始化vector。拷贝构造函数：使用另一个vector对象来初始化新的vector对象。移动构造函数（C++11及以后）：使用另一个vector对象的资源来初始化新的vector对象，同时使原对象变为空。初始化列表构造函数（C++11及以后）：使用初始化列表来初始化vector。析构函数：销毁vector对象，释放其占用的内存。 II、迭代器 begin()：返回指向vector第一个元素的迭代器。end()：返回指向vector最后一个元素之后位置的迭代器（不是最后一个元素）。rbegin()：返回指向vector最后一个元素的反向迭代器。rend()：返回指向vector第一个元素之前位置的反向迭代器。cbegin() 和 cend()：与begin()和end()类似，但返回的迭代器是const类型，不能用于修改元素。 III、容量操作 size()：返回vector中元素的当前数量。max_size()：返回vector能够容纳的最大元素数量（通常是一个很大的值，但具体取决于系统和编译器的实现）。capacity()：返回vector当前分配的存储容量，可能大于或等于size()返回的值。reserve(n)：请求vector的存储容量至少为n，如果当前容量小于n，则重新分配内存。shrink_to_fit()（C++11及以后）：尝试将vector的capacity减少为其当前size的大小，但不一定成功，因为释放内存是可选的。 IV、修改容器 push_back(value)：在vector的末尾添加一个元素。pop_back()：移除vector的最后一个元素。insert(pos, value)：在指定位置pos之前插入一个元素value。erase(pos)：移除指定位置pos的元素，并返回指向被移除元素之后位置的迭代器。clear()：移除vector中的所有元素，使其变为空。assign(first, last)：用范围[first, last)内的元素替换vector的内容。assign(n, value)：用n个值为value的元素替换vector的内容。 V、元素访问 operator[]：通过下标访问vector中的元素。at(pos)：通过位置pos访问vector中的元素，并进行范围检查。front()：返回vector中第一个元素的引用。back()：返回vector中最后一个元素的引用。data()：返回指向vector中第一个元素的指针（C++11及以后）。 VI、其他操作 swap(other)：交换两个vector的内容。find(value)：在vector中查找值为value的第一个元素，并返回指向该元素的迭代器，如果未找到则返回end()。sort()：对vector中的元素进行排序。reverse()：颠倒vector中元素的顺序。 三、实现 通过本文，你可以跟随我的思路来了解实现 vector 的底层思路，以及实现的原理。
由于我们将vector实现在一个 .h 文件，并且要实现类模板vector，于是我们先写出框架： 先定义模板参数；
template&lt;typename T&gt; class vector { private: T* _start;//数组的开始位置 T* _finish;//数组内最后一个数据的下一个位置，finish-start表示数组内元素个数 T* _end_of_storage; //数组最后一个能存储元素的下一个位置，end_of_storage - start 表示数组的容量 }; 一个类，想要创建一个对象，必须要有构造函数：
STL的vector在实例化之后，默认是已经开辟好了空间，只不过size == 0 ，及内部没有数据而已。
这里我们化繁为简，在构造函数内部不开辟空间，而是在使用或者说对vector对象进行操作的时候再开辟动态空间，于是我们可以直接在变量声明时给默认值并且使用不传参的默认构造函数：
template&lt;typename T&gt; class vector { vector() = default; private: T* _start = nullptr; T* _finish = nullptr; T* _end_of_storage = nullptr; }; push_back是对vector进行最基本的操作，想要实现push_back，则需要考虑扩容逻辑：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b147ca9b23e7da9f434614e2c3f182/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83c018329bb93a1321559f6046c47f0/" rel="bookmark">
			世界商用飞机机型大全-使用Java抓取FlightAware后的答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、数据说明
1、实时航班飞机机型数据
2、网页结构分析
二、使用Java进行信息抓取
1、定义页面PageVO对象
2、爬取属性定义
3、启动信息抓取组件
三、成果分析
1、商业飞行的飞机机型的种类
2、飞机种类排名前十名
3、航班数排名后十名
4、看中国国产大飞机C919
四、总结
前言 随着现在航空业的发达以及人们物质生活水平的提升，乘坐飞机出行一定是很多朋友们出行的一种方式，不要说远距离的跨国航线，连我们的祖国的天南海北，乘坐飞机出行，也是相当便利出行的。不知道各位朋友在平时的出行过程当中有没有注意观察，或者说有没有留意自己乘坐的飞机到底是什么机型呢？更往大的范围来说，在当前世界上的商业飞行活动中，一共有多少种飞机机型呢？飞行航班数最多的机型是哪一种？而飞行航班数最少的又是哪一种呢？哪种飞机的机龄最年轻，哪种飞机是飞行器界的老人呢？想想这些问题，是不是很有意思。当下次您在出行的时候，在值机或者购买机票的时候，可以统计以下您乘坐的飞机的机型。也看看我们国家主要的商业飞机机型是什么？主要的飞行航线是哪几条。
带着上述的问题开启本篇的内容讲解。本文主要讲解如何采用Java语言和XxlCrawler进行flightaware网的所有商用飞机机型的信息爬取，首先介绍在flightaware网上的所有飞行器数据，然后使用Java语言结合XxlCrawler进行信息抓取，最后得到完整的飞行器数据表格。通过本文，您可以掌握如何获取全球执飞的商用飞机的机型信息，同时掌握在使用XxlCrawler进行信息爬取时，如何获取超链接中Href属性，掌握属性值的正确处理方式。最后对成果进行充分展示，本文的结果是Excel表格，但是我们为了可以在后续的分析中继续使用，我们可以将这些数据持久化到数据库中，本文暂且不表。
一、数据说明 本节将主要对数据的来源进行说明，文中涉及到的飞行轨迹及全球飞机机型数据均参考flightaware飞行网。以飞机机型为例，局限于数据采集时获取的是实时的在线航班的数据，因此导致可能会遗漏部分已经降落的飞行飞机，但对于常用航空器，应该是包含在里面了。如果您需要最准确的数据，可以设置一个频率高的采集周期，定时从网站上采集，通过覆盖24小时甚至72小时的采集，来实现全覆盖（当然这个频率也不一定，有的航线可能一周才开通一次）。当然，您也可以购买会员，这样可以得到一些官方提供的数据。
1、实时航班飞机机型数据 对飞行轨迹感兴趣的朋友可以在flightaware网站上看到飞机的轨迹，这里需要注意的是，这里的航班都是实时航班，就是正在飞行的。已经到达的航班则不在列表中展示。具体如下图所示：
当我们想搜索航班时，可以有多种搜索模式，这里就分享一种，同时引出本博客的信息来源，飞机的机型列表。 第一步点击导航条中的“航班跟踪”，然后点击“按机型浏览”的超链接。 然后在新的界面中就打开所有的机型选择页面，如下图所示：
没有，上面的页面就是我们的目标，我们需要将上面的数据进行抓取到本地来。 2、网页结构分析 上面的飞机机型访问地址如下：飞机机型列表。为了实现使用Java语言来进行页面信息爬取，我们首先要分析网页的结构，便于在后续的抓取脚本设置中设置好xpath配置。如果使用的是谷歌浏览器，那么我们直接按F12或者右键检查，即可打开网页监控，在监控页面查看网页结构，尤其是xpath的规则。
通过观察上述的网页，我们不难发现，它的网页结构非常有规律，因此特别使用进行循环批量爬取。其网页内容格式均如下所示：
&lt;tr class="smallrow1"&gt; &lt;td&gt;2084&lt;/td&gt; &lt;td&gt;&lt;a href="/live/aircrafttype/A320"&gt;A320&lt;/a&gt;&lt;/td&gt; &lt;td&gt;Airbus A320&lt;/td&gt; &lt;/tr&gt; 上面的每一行包含四个主要的信息，第一个是实时航班的数量，第二个单元格的超链接是访问当前机型的实时航航的连接，后面是飞行机器的code，第四个是当前飞机的具体类型名称。在了解以上的信息以后我们就可以编写xpath脚本来获取相关的信息。
二、使用Java进行信息抓取 本节将重点展示如何使用Java语言来爬取这些航空器的信息，通过本节的知识，可以掌握使用Java语言来爬取相关知识的内容。同时这里将重点讲解如何在XxlCrawler框架中爬取超链接的Href属性，如果您在平时的工作中也要涉及网页属性的爬取，可以看看这里的处理方式。
1、定义页面PageVO对象 在博主的个人博客当中，大多都是介绍XxlCralwer这个组件。这个组件非常好用，这里依然采用这个组件来进行信息的抓取。在信息抓取之前，我们需要先通过xpath来定义html页面上的元素与我们抓取对象的一个映射关系，这个映射关系的配置就是通过pageVo这个对象来实现的。在上一节的内容介绍中，我们讲解了网页的结构，这里仅将pageVo对象的代码贴出来，对重点部分进行讲解。
/** * 请注意合理Xpath的配置，一定要配置到tr，配置到tr，会自动循环获取并赋值，方便于集合操作 * @author 夜郎king * */ @PageSelect(cssQuery = ".indent .prettyTable &gt;tbody &gt;tr") @Data @AllArgsConstructor @NoArgsConstructor public static class PageVo { /** * 实时航班数 */ @Excel(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d83c018329bb93a1321559f6046c47f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9657b75a04392b666a833c02439386a4/" rel="bookmark">
			【LabVIEW学习篇 - 5】：数据类型——数值、字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数值枚举下拉列表控件 字符串字符串与十六进制截取字符串连接字符串 字符串与数值间的转换字符串转为数值数值转为字符串 数值 如下图所示，各种数值型数据的不同之处在于存储和表示数据时所使用的位置不同。
浮点型
整型
在LabVIEW中，想要改变数值控件的类型或其他操作，可将鼠标移到控件的位置，然后鼠标右键，即可进行相关的操作。
案例：使用无符号单字节整型实现加法，230+30，观察输出结果。
在前面板中创建两个数值输入控件，并在表示法中设置两个数值输入的类型为无符号单字节整型。
然后在程序框图中，选择加字节，鼠标移动到加字节的输出连接位置，鼠标右键，选择创建显示控件。
运行结果如下图所示，结果为4，原因是无符号单字节整型的数值范围为0—255，所示最大值为255，而加的结果是260，比255大，所以多出来的值从0开始，即多出5，则从0开始即为4。
注意：由于浮点算术运算可能存在四舍五入误差，因此浮点数不能作为条件结构选择器标签值。如果将一个浮点数连接到分支选择器，LabVIEW将对其进行舍入到最近整数值。如果在选择器标签中输入浮点值，数值将变成红色，表示在执行结构前必须删除或编辑该值。
枚举 使用枚举控件，向用户提供一个可供选择的项列表。枚举型控件。也称枚举控件，类似于一个文本或菜单下拉列表控件。用户可轮流选中控件中的列表。
案例：使用枚举控件与条件结构连接，并设置分支分别为AA、BB、CC，并在这三个分支中设置三个不同的字符串表达。
在前面板中，鼠标右键，在下拉列表与枚举模块中选择枚举，然后鼠标移动到枚举控件位置，鼠标右键，选择编辑项，在其中编辑值。
在程序框图中放置条件结构，将枚举控件与条件结构连接，连接后即条件选择其的标签值会自动改变，变为设置的枚举值，但是没有CC的条件分支。
选中条件结构，鼠标右键，选择在后面添加分支，即出现CC条件分支。
在这三个分支中分别设置不同的字符串表达，并让枚举控件连接一个数值显示控件，可查看其值。
运行结果，在前面板中选择枚举控件的BB值，运行程序。
下拉列表控件 下拉列表控件是将数值与字符串或图片建立关联的数值对象。下拉列表控件以下拉菜单的形式出现，用户可在循环浏览的过程中作出选择。
下拉列表控件的使用方法与枚举控件相同，不同的是下拉列表控件可以自定义值。
案例：创建下拉列表控件，设置其项为AA、BB、CC，值分别为100、50、300，设置好后与条件结构相连，每个分支中设置不同的字符串表达。
在前面板中，鼠标右键，在下拉列表和枚举模块中选择文本下拉列表，并在编辑项中设置项为AA、BB、CC，值分别为100、50、300。
在程序框图中放置条件结构，添加条件分支，并设置条件选择器的标签值分别为100、500、300，并在每个分支设置好不同的字符串表达。
在前面板中设置文本下拉列表的值为BB，运行程序，观察结果。
字符串 在LabVIEW中，字符串是一种重要的数据类型，用于存储和处理文本信息。以下是关于LabVIEW中字符串的一些重要信息：
字符串数据类型：
字符串在LabVIEW中被表示为一组字符序列，通常用来存储和操作文本数据。
字符串的性质：
字符串可以包含任意字符，包括字母、数字、符号和空格。
LabVIEW中的字符串是不可变的（immutable），这意味着一旦创建，它们的内容不能被更改。任何对字符串的修改操作实际上都是创建一个新的字符串。
字符串操作：
LabVIEW提供了丰富的字符串操作函数和方法，包括连接、截取、替换、搜索、比较等，使得对字符串的处理变得更加方便和灵活。
字符串显示和格式化：
字符串可以直接显示在LabVIEW的前面板（Front Panel）上，也可以通过格式化函数（如Format Into String函数）将数值或其他数据类型转换为字符串。
字符串与其他数据类型的转换：
可以通过将数值、布尔值或其他类型的数据转换为字符串，以便于输出到文件、显示在用户界面中或者进行网络通信等操作。
字符串与十六进制 可以将字符串转换为对应的16进制表示。例如，字符串 “ABCD” 可以转换为 16进制的形式 “41424344”，其中每个字符在ASCII码中对应一个16进制数。
以下列举相关案例，观察数值类型的十六进制如何转为字符串。
案例：将16进制的整型数值转换成字符串。
在程序框图中，鼠标右键，在字符串模块选择字符串常量，然后输入街三仔，接着选中字符串常量控件，鼠标右键，选择十六进制显示，即可查看该字符串对应的十六进制。
在程序框图中，鼠标右键，在数值模块中选择数值常量，接着鼠标右键，选择基数，然后鼠标移动到出现的d位置，点击鼠标左键，选择十六进制，接着将数值常量的类型设置为I64，最后把字符串街三仔对应的十六进制的值，写到数值常量中。
在程序框图中，鼠标右键，选择数值-数据操作-强制类型转换，然后将数值常量与强制类型转换的控件连接，并在其上方创建常量，在输出端，鼠标右键，选择创建-显示控件，然后运行程序，下图为运行结果。
截取字符串 如下图所示，左边从上到下，第一个接口为输入的字符串，第二个接口为偏移量，第三个接口为长度。若长度不设置，则默认截取偏移量往后所有字符串。
注意：一个汉字的偏移量为2（字节），一字母和数字的偏移量为1（字节）。
案例：对字符串"街三仔在写Python"，截取"三仔在写Pyt"。
在程序框图中，创建字符串常量，输入街三仔在写Python，接着鼠标右键，在字符串模块选择截取字符串，然后进行相关设置，如下图所示。
其中2为偏移量，11为截取的长度。
运行结果如下图所示：
连接字符串 如下图所示，为连接字符串，左边部分从上到下为要连接的字符串，右边为输入连接完成后的字符串。
若想连接多个字符串，可将鼠标移动到连接字符串控件的中下部分，往下拉，即可增加字符串的连接端口。
案例：连接"街三仔"、“喜欢”、"敲代码"这三个字符串，并在其中间加上换行。
在程序框图中，创建三个字符串常量，并分别输入"街三仔"、“喜欢”、“敲代码”，然后鼠标右键，在字符串模块中选择连接字符串，接着在字符串模块中选择换行符常量，并进行相关的连接，如下图所示。
运行结果如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9657b75a04392b666a833c02439386a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05c2ade2a4200487c3689c08fc0ad85/" rel="bookmark">
			Sleuth--链路追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 链路追踪介绍 在大型系统的微服务化构建中，一个系统被拆分成了许多模块。这些模块负责不同的功能，组合成 系统，最终可以提供丰富的功能。在这种架构中，一次请求往往需要涉及到多个服务。互联网应用构建 在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实 现、有可能布在了几千台服务器，横跨多个不同的数据中心，也就意味着这种架构形式也会存在一些问题：
如何快速发现问题？ 如何判断故障影响范围？ 如何梳理服务依赖以及依赖的合理性？ 如何分析链路性能问题以及实时容量规划？ 分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。 常见的链路追踪技术有下面这些： cat 由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成方案是通过代码埋点的方式来实现监控，比如： 拦截器，过滤器等。 对代码的侵入性很大，集成成本较高。风险较大。 zipkin 由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微服务架构中的延迟问题，包括：数据的收集、存储、查找和展现。该产品结合spring-cloud-sleuth使用较为简单， 集成很方便， 但是功能较简单。 pinpoint Pinpoint是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能强大，接入端无代码侵入。 skywalking SkyWalking是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能较强，接入端无代码侵入。目前已加入Apache孵化器。 Sleuth SpringCloud 提供的分布式系统中链路追踪解决方案。 注意： SpringCloud alibaba 技术栈中并没有提供自己的链路追踪技术的，我们可以采用 Sleuth + Zinkin 来做链路追踪解决方案 2 Sleuth入门 2.1 Sleuth介绍 SpringCloud Sleuth主要功能就是在分布式系统中提供追踪解决方案。它大量借用了 Google Dapper 的设计， 先来了解一下 Sleuth 中的术语和相关概念。 Trace 由一组Trace Id相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该唯一标识将所有的请求串联起来，形成一条完整的请求链路。 Span 代表了一组基本的工作单元。为了统计各处理单元的延迟，当请求到达各个服务组件的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的调用时间，除此之外，我们还可以获取如事件的名称。请求信息等元数据。 Annotation 用它记录一段时间内的事件，内部使用的重要注释： cs（Client Send）客户端发出请求，开始一个请求的生命 sr（Server Received）服务端接受到请求开始进行处理， sr－cs = 网络延迟（服务调用的时间） ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr = 服务器上的请求处理时间 cr（Client Reveived）客户端接受到服务端的响应，请求结束。 cr - sr = 请求的总时间 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f05c2ade2a4200487c3689c08fc0ad85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2f73e59a98321dbff4ec93e5d58892/" rel="bookmark">
			Leetcode2542-最大子序列的分数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题转换 首先明确题意，要选取的值和num1，num2两个数组都有关，但是num1中选取的是k个数，num2中选取的是1个数，显然num2中的数所占的权重较大（对结果影响较大），所以我们就可以对num2进行排序（也可以对nums1进行排序，就是对nums1排列以后枚举时获取nums2最小值特麻烦，就不再赘述了，有兴趣的读者可以思考一下），枚举num2中的每个数，然后确定num1中对应的k个数，但是选取元素时 num1 和 num2 对应的索引要一样，所以不能对num2直接排序，那么就对num2所对应的索引进行排序即可，对num2的索引，按照num2的值从大到小进行排序，为什么从大到小，因为要过滤在num2中前k-1个数，在第k个数进行计算，看到下文便可知
int len = nums1.length; Integer[] ids = new Integer[len]; for (int i = 0; i &lt; len; i++) { ids[i] = i; } //按照nums2[] 数组元素降序后排列的下标 Arrays.sort(ids, (i, j) -&gt; nums2[j] - nums2[i]); 进行这样的排序之后，所得到的效果就是 nums2[ids[0]] 就是nums2中最大的元素，nums2[ids[1]]就是num2中第二大的元素... 要设计一个小顶堆，确保这k个数在遍历时，是遍历到的最大值，如果每次遇到一个值比堆顶元素大，那么就替换堆顶元素，并且定义一个变量 sum 记录堆中元素的总和，便于计算
2. 要理解的三个点 A. nums2[ids[i]] i 从 0 -&gt; len - 1 遍历 nums2[ids[i]] 就是降序的
B. 要从nums2[] 中第k大的元素 x 开始遍历，如果选了前面的数(比x大的数)，那么nums1[] 就凑不出k个数满足配件，例如图片中的例子，如果选了nums2中最大的数4，对应的下标只有一个3，就凑不出3个下标，因为4在nums2中就是最大的，不存在两个比4小的数
C. nums1[] nums2[] 中选取的下标都是一样的，nums2[ids[i]] 选取的下标是 ids[i] 那么nums1[] 选取的下标也得是ids[i], 所以先把 前k个 ids[i] 所以对应的nums1[] 的元素入小顶堆
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2f73e59a98321dbff4ec93e5d58892/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/179/">«</a>
	<span class="pagination__item pagination__item--current">180/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/181/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>