<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007fa2800d10ab7a15b6de2c6de8e993/" rel="bookmark">
			jmeter实战（2）- 入门使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、运行Jmeter 参考上一篇博客：jmeter实战（1）- Mac环境安装
二、创建线程组 JMeter的线程组是进行负载测试的基本构建单元，它用于模拟多个用户对目标系统进行并发访问。线程组中的属性允许你控制测试的并发级别和执行模式。
1. 右键点击测试计划 &gt; 添加 &gt; 线程（用户）&gt; 线程组
2. 线程组属性介绍：
线程数 (Number of Threads (users)):
这个值定义了线程组中并发执行的线程数量，每个线程模拟一个虚拟用户。例如，如果你设置线程数为100，那么JMeter将同时模拟100个用户并发访问。Ramp-Up Period (in seconds):
这个属性定义了所有线程完全启动并开始执行测试所需的时间。例如，如果线程数为100，Ramp-Up时间为10秒，那么JMeter将在10秒内逐渐启动所有100个线程，意味着大约每秒启动10个线程。Same user on each iteration:
每次迭代使用同一用户, 同一个线程将使用相同的用户身份进行操作.循环次数 (Loop count):
定义了每个线程重复执行测试计划中HTTP请求或其他采样器的次数。如果设置为1，则每个线程只执行一次测试计划；如果设置为更大的数字，比如10，那么每个线程将执行10次测试计划；如果选择“永远”（Forever），则线程将无限循环执行，直到测试被手动停止。调度器 (Scheduler):
如果启用，你可以设置线程组的持续时间或延迟启动时间。这允许你控制线程组何时开始执行以及执行多长时间。 持续时间 (Duration):
当启用调度器时，你可以指定线程组的持续时间。这意味着线程组将在指定的时间段内运行。延迟启动 (Start time):
同样，当启用调度器时，可以设置线程组的延迟启动时间，即线程组将在测试开始后多久才开始执行。
三、创建 HTTP 请求 JMeter的HTTP Request取样器是用于模拟HTTP请求的核心组件之一，它允许你向目标服务器发送各种类型的HTTP请求，包括GET、POST、PUT、DELETE等，以便测试Web应用程序的性能和功能。
1. 右键点击线程组 &gt; 添加 &gt; 取样器 &gt; HTTP请求
2. HTTP请求属性介绍
协议 (Protocol)
HTTP或HTTPS协议的选择。服务器名称或IP (Server Name or IP)
指定目标服务器的域名或IP地址。端口 (Port)
目标服务器的端口号。默认情况下，对于HTTP请求是80，HTTPS请求是443。方法 (Method)
发送请求的方法，如GET、POST、PUT、DELETE等。路径 (Path)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/007fa2800d10ab7a15b6de2c6de8e993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fdb635f762cfc52606f4460dd94c68c/" rel="bookmark">
			MiniExcel：.NET中处理Excel的高效方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在.NET开发环境中，处理Excel文件是一项常见的任务，无论是数据导入、导出还是报表生成。传统的解决方案可能存在性能瓶颈或功能限制。MiniExcel作为一个现代、高效的库，为.NET开发者提供了一个强大的工具来简化Excel操作。本文将介绍MiniExcel的主要特点、使用方法以及它如何帮助提高开发效率。
MiniExcel简介 MiniExcel是一个开源的.NET库，用于简化读写Excel文件的过程。它支持.NET Standard，因此可以在多种平台上运行，包括.NET Core、.NET Framework、Xamarin、MAUI等。
MiniExcel的主要优势 高性能：相比传统的解决方案，MiniExcel在处理大型Excel文件时表现出更快的速度。易用性：提供了简洁的API，使得读写Excel变得简单直观。灵活性：支持多种数据格式的导入导出，包括但不限于CSV、XLSX等。跨平台：兼容多个.NET平台，包括桌面和移动应用。社区支持：作为一个开源项目，MiniExcel拥有活跃的社区，不断更新和维护。 MiniExcel的使用方法 安装MiniExcel 首先，通过NuGet包管理器安装MiniExcel：
shell
dotnet add package MiniExcel
读取Excel文件 使用MiniExcel读取Excel文件非常简单：
csharp
using MiniExcelLibs; var rows = await MiniExcel.QueryAsync("path-to-file.xlsx", "Sheet1"); foreach (var row in rows) { Console.WriteLine($"ID: {row.ID}, Name: {row.Name}"); }
写入Excel文件 写入Excel同样直观：
csharp
var datas = new List&lt;YourDataModel&gt; { new YourDataModel { ID = 1, Name = "Alice" }, new YourDataModel { ID = 2, Name = "Bob" } }; await MiniExcel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fdb635f762cfc52606f4460dd94c68c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8c2460e1c4ac9eb0ee59246bef3c5d4/" rel="bookmark">
			消息队列RabbitMQ在Windows中安装与配置完全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容导读 RabbitMq简介安装准备RabbitMQ安装与配置安装过程中的出错解决 RabbitMQ云端配置参考
一、RabbitMQ简介 1.1 消息队列MQ简介 消息队列中间件是微服务分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性。
常用的消息队列：ActiveMQ(安全)，RabbitMQ(高效)，RocketMQ，Kafka(大数据中应用广泛)。
1.2 什么是RabbitMQ RabbitMQ是一个由Erlang语言开发的基于AMQP协议的开源中间件。
RabbitMQ最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。
AMQP：Advanced Message Queue高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。
RabbitMQ具体特点包括：
（1）可靠性(Reliability)
RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。
（2）灵活的路由(Flexible Routing)
在消息进入队列之前，通过Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。
针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。
（3）消息集群(Clustering)
多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker。
（4）高可用(Highly Available Queues)
队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。
（5）多种协议(Multi-protocol)
RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等。
（6）多语言客户端(Many Clients)
​ RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等。
（7）管理界面(Management UI)
​ RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。
（8）跟踪机制(Tracing)
​ 如果消息异常，RabbitMQ提供了消息跟踪机制，使用者可以找出发生了什么。
（9）插件机制(Plugin System)
​ RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。
二、安装准备 1.下载Eralng20.0，用于支持RabbitMQ的运行与编程
Downloads - Erlang/OTP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8c2460e1c4ac9eb0ee59246bef3c5d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8602384ac594d725d57c82a947399846/" rel="bookmark">
			JAVA用框架SpringAI实现人工智能（一）配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring AI 是 Spring 官方社区项目，旨在简化 Java AI 应用程序开发，让 Java 开发者像使用 Spring 开发普通应用一样开发 AI 应用。 一、Spring AI 简介 据 Spring AI 官网描述，该项目的灵感来自著名的 Python 项目，如 LangChain 和 LlamaIndex，但 Spring AI 并不是这些项目的直接复制。Spring AI 相信下一波 Generative AI 生成式应用程序将不仅面向 Python 开发人员，而且将在许多编程语言中广泛应用。 Spring AI 的核心是提供抽象，作为开发 Java AI 应用程序的基础，提供以下功能：
1、提供多种大模型服务对接能力，包括业界大多数主流大模型服务，如 OpenAI、微软、亚马逊、谷歌和 Huggingface等；
2、支持灵活的 Prompt Template 和模型输出解析 Output Parsing 能力;
3、支持多模态的生成式 AI 能力，如对话，文生图、文生语音等；
4、提供通用的可移植的 API 以访问各类模型服务和 Embedding 服务，支持同步和流式调用，同时也支持传递特定模型的定制参数；
5、支持 RAG 能力的基础组件，包括 DocumentLoader、TextSpillter、EmobeddingClient、VectorStore 等；
6、支持 AI Spring Boot Starter 实现配置自动装配。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8602384ac594d725d57c82a947399846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f303adbcb7a7909ea88aae547966c713/" rel="bookmark">
			Linux：传输层(1) -- UDP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 端口号 同一台主机的不同端口号(Port)标记了主机上不同的进程，如下图所示：
在 TCP/IP 协议中 , 用 " 源IP", "源端口号", "目的IP", "目的端口号", "协议号" 这样一个五元组来标识一个通信 ( 可以通过netstat -n查看 ); 1.1 端口号划分 0 - 1023: 知名端口号, HTTP, FTP, SSH等这些广为使用的应用层协议, 他们的端口号都是固定的. 1024 - 65535: 操作系统动态分配的端口号. 客户端程序的端口号, 就是由操作系统从这个范围分配的 1.2 知名端口号 ssh服务器, 使用22端口 ftp服务器, 使用21端口 telnet服务器, 使用23端口 http服务器, 使用80端口 https服务器, 使用443执行下面的命令, 可以看到知名端口号：cat /etc/services 那么此时就会有 两个问题： 一个端口号是否能被多个进程bind？-- 默认情况下，一个端口号在同一时间不能被多个进程绑定到同一个IP地址，当然会有写特殊的处理。一个进程能否bind、多个端口号？-- 是可以的，一个进程可以创建多个套接字，每个套接字绑定到不同的端口上。 2. netstat netstat是一个用来查看网络状态的重要工具. 语法：netstat [选项] 功能：查看网络状态 常用选项： n 拒绝显示别名，能显示数字的全部转化成数字 l 仅列出有在 Listen (监听) 的服務状态 p 显示建立相关链接的程序名 t (tcp)仅显示tcp相关选项 u (udp)仅显示udp相关选项 a (all)显示所有选项，默认不显示LISTEN相关 pidof 在查看服务器的进程 id 时非常方便 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f303adbcb7a7909ea88aae547966c713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f794350ff7004a2a319960d977cbeb/" rel="bookmark">
			数字信号||快速傅里叶变换(FFT)（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验四 快速傅里叶变换(FFT) 一、实验目的 (1)加深对快速傅里叶变换(FFT)基本理论的理解。
(2)了解使用快速傅里叶变换(FFT)计算有限长序列和无限长序列信号频谱的方法。
(3)掌握用MATLAB语言进行快速傅里叶变换时常用的子函数。
二、实验涉及的MATLAB子函数
1.fft
功能：一维快速傅里叶变换(FFT)。
调用格式：y＝fft(x)；利用FFT算法计算矢量x的离散傅里叶变换，当x为矩阵时，y为矩阵x每一列的FFT。当x的长度为2的幂次方时，则fft函数采用基2的FFT算法，否则采用稍慢的混合基算法。
y＝fft(x，n)；采用n点FFT。当x的长度小于n时，fft函数在x的尾部补零，以构成n点数据；当x的长度大于n时，fft函数会截断序列x。当x为矩阵时，fft函数按类似的方式处理列长度。
三、实验原理 1.用MATLAB提供的子函数进行快速傅里叶变换
从理论学习可知，DFT是唯一在时域和频域均为离散序列的变换方法，它适用于有限长序列。尽管这种变换方法是可以用于数值计算的，但如果只是简单的按照定义进行数据处理，当序列长度很大时，则将占用很大的内存空间，运算时间将很长。
快速傅里叶变换是用于DFT运算的高效运算方法的统称，FFT只是其中的一种。FFT主要有时域抽取算法和频域抽取算法，基本思想是将一个长度为N的序列分解成多个短序列，如基2算法、基4算法等，大大缩短了运算的时间。
MATLAB中提供了进行快速傅里叶变换(FFT)的子函数，用fft计算DFT，用ifft计算IDFT。
四、实验任务 (1) 认真阅读实验原理，明确本次实验任务，读懂例题程序，了解实验方法，结合基本原理理解每一条语句的含义。
(2) 运行例题程序，编写实验程序。
(3)列写调试通过的实验程序，打印或描绘实验程序产生的图形和数据。
例14-1 已知一个长度为8点的时域离散信号，n1＝0，n2＝7，在n0＝4前为0，n0以后为1。对其进行FFT变换，作时域信号及DFT、IDFT的图形。
解 程序如下：
n1＝0；n2＝7；n0＝4；
n＝n1：n2；N＝length(n)；
xn＝［(n－n0)&gt;＝0］； %建立时域信号
subplot(2，2，1)；stem(n，xn)；
title(¢x(n)¢)；
k＝0：N－1；
Xk＝fft(xn，N)；%用FFT计算信号的DFT
subplot(2，1，2)；stem(k，abs(Xk))；
title(¢Xk＝DFT(x(n))¢)；
xn1＝ifft(Xk，N)；%用IFFT计算信号的IDFT
subplot(2，2，2)；stem(n，xn1)；
title(¢x(n)＝IDFT(Xk)¢)；
运行结果如图14-1所示。
n1=0;n2=7;n0=4; n=n1:n2;N=length(n); xn=[(n-n0)&gt;=0]; %建立时域信号 subplot(2,2,1);stem(n,xn) title('x(n)'); k=0:N-1; Xk=fft(xn,N);%用FFT计算信号的DFT subplot(2,1,2);stem(k,abs(Xk)); title('Xk＝DFT(x(n))'); xn1=ifft(Xk,N);%用IFFT计算信号的IDFT subplot(2,2,2);stem(n,xn1); title('x(n)＝IDFT(Xk)'); 图14-1 例14-1用FFT求有限长序列的傅里叶变换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d71af7cc54175995f95ac7604c891fe1/" rel="bookmark">
			用uniapp 及socket.io做一个简单聊天app1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		####相关的表结构，用的是mysql
用户表（Users）
存储用户的基本信息。 CREATE TABLE Users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50) NOT NULL UNIQUE, password VARCHAR(100) NOT NULL, email VARCHAR(100) UNIQUE, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); 好友关系表（Friends）
存储用户之间的好友关系。 CREATE TABLE Friends ( user_id INT, friend_id INT, status ENUM('pending', 'accepted', 'blocked') DEFAULT 'pending', created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (user_id, friend_id), FOREIGN KEY (user_id) REFERENCES Users(id), FOREIGN KEY (friend_id) REFERENCES Users(id) ); 群组表（Groups）
存储群组的信息。 CREATE TABLE Groups ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100) NOT NULL, description TEXT, owner_id INT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (owner_id) REFERENCES Users(id) ); 群组成员表（GroupMembers）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d71af7cc54175995f95ac7604c891fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8790c61d09db35a53bb04dd0138ff81f/" rel="bookmark">
			苹果解锁工具iToolab UnlockGo 中文安装版(附教程&#43;补丁) 2024年6月ios17.4.1可用（记得点赞）解压密码请看文章！！！ 评论区获取最新链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UnlockGo 允许您非常轻松地绕过 iPhone 的密码并获得对设备的完全访问权限。它在以下场景中很有用。
在几分钟内删除 iPhone/iPad 上的各种锁定。
解锁 4 位/6 位密码、Touch ID 和 Face ID
删除没有密码的 iCloud 免费锁
无需密码即可从 iPhone/iPad/iPod 中删除 Apple ID
无需密码即可轻松关闭“查找我的 [设备]” MDM 绕过和删除 MDM 配置文件
在 iOS 设备上重置屏幕时间密码
安装免费教程 （本人设备为企业监管锁，购于4.29号，刷机时出现该情况特制作该教程，希望有所帮助） 1.将获得fix文件夹和Setup.exe安装程序；
双击Setup.exe开始安装软件，如图:
2.勾选我同意此协议，点击下一步，如图:
3.选择软件安装目录，默认目录：C:\Program Files (x86)\UnlockGo ；如图
4.等待安装完成,去掉运行unlockgo，等待安装软件补丁，如图:
5.在安装免费文件前，首先要打开软件的安装目录，如果忘记软件的安装目录，请返回到桌面，找到软件的桌面快捷图标，并右键点击图标，出现弹窗后选择“打开文件位置”即可获得文件安装目录。如图:
6.打开Crack文件夹，将里面的"UnlockGo.exe"文件复制到软件安装目录替换即可，如图:
7.安装完成，以管理员身份运行快捷键，如图:
8.成功如图；
9.链接设备绕过MDM
10.下图为重置及解锁步骤
网盘链接：https://pan.baidu.com/s/1-UYOSlas2X2aH3xiZSlLsA?pwd=366u 提取码：366u 有效期至6月1号，评论区查看最新链接地址不定时更新，过期私聊，文件密码 " ufvyct.test "
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0357dd8712c91fcaa28db5036aa410/" rel="bookmark">
			ts一些解决vscode飘红的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看是否有些ts的数据类型定义问题，属性缺少或者属性类型不对
把对应属性加上即可
2、在飘红的代码前面设置// @ts-ignore忽略此行校验（不过一般不建议用这个方法）
3、移除高版本不用的属性（版本属性兼容问题）
原因：高版本的的ts对某些低版本的属性不兼容或者不使用对应属性了
处理：鼠标放到飘红的地方，根据提示处理，比如有些属性已经不使用了
4、清除缓存
有时候新安装了vscode的插件，然后没有重启vscode，那么插件不生效，还是很多飘红，然后写新的也飘红。
原因：VSCode可能会缓存一些编译结果或类型检查信息。
解决：尝试清除VSCode的缓存(例如,通过重启VSCode或删除.vscode目录中的某些文件)解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4f9fbea37840acd6a60ed6b429b26f/" rel="bookmark">
			基于JAVA&#43;SpringBoot&#43;Vue&#43;uniApp的校园日常作品商品分享小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✌全网粉丝20W+,csdn特邀作者、博客专家、CSDN新星计划导师、java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
技术范围：SpringBoot、Vue、SSM、HLMT、Jsp、SpringCloud、Layui、Echarts图表、Nodejs、爬虫、微信小程序、机器学习等设计与开发。
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
一、项目背景介绍： 基于JAVA+SpringBoot+Vue+uniApp的校园日常作品商品分享小程序是一款专为校园内的学生和教师设计的移动应用程序。该小程序旨在提供一个便捷的平台，让学生和教师能够轻松地分享自己的手工制作、设计作品或二手物品，同时也方便其他用户浏览和购买这些商品。通过这款小程序，校园内的学生们可以轻松地将自己的作品分享给其他同学，增加彼此之间的交流和合作机会；同时，教师们也可以借此平台推广自己的教学成果或者寻找合适的教学资源。此外，该小程序还有助于减少校园内的浪费现象，提高资源的利用率。
二、项目技术简介： JAVA：Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。Vue：Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的JavaScript框架。它基于标准HTML、CSS和JavaScript构建，并提供了一套声明式的、组件化的编程模型，帮助开发者高效地开发用户界面。
Vue是一个独立的社区驱动的项目，它是由尤雨溪在2014年作为其个人项目创建， 是一个成熟的、经历了无数实战考验的框架，它是目前生产环境中使用最广泛的JavaScript框架之一，可以轻松处理大多数web应用的场景，并且几乎不需要手动优化，并且Vue完全有能力处理大规模的应用。Element-UI：Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。SpringBoot：Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。Mybatis-Plus：MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为 简化开发、提高效率而生。smart：微信小程序，小程序的一种，英文名Wechat Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。
全面开放申请后，主体类型为企业、政府、媒体、其他组织或个人的开发者，均可申请注册小程序。微信小程序、微信订阅号、微信服务号、微信企业号是并行的体系。
微信小程序是一种不用下载就能使用的应用，也是一项创新，经过将近两年的发展，已经构造了新的微信小程序开发环境和开发者生态。微信小程序也是这么多年来中国IT行业里一个真正能够影响到普通程序员的创新成果，已经有超过150万的开发者加入到了微信小程序的开发，与我们一起共同发力推动微信小程序的发展，微信小程序应用数量超过了一百万，覆盖200多个细分的行业，日活用户达到两个亿，微信小程序还在许多城市实现了支持地铁、公交服务。微信小程序发展带来更多的就业机会，2017年小程序带动就业104万人，社会效应不断提升。 三、系统功能模块介绍： 四、数据库设计： 1：‘评论’（comment）
字段名类型默认值列注释idbigintNULL评论编号contentvarcharNULL评论内容themes_idbigintNULL文章编号painter_idbigintNULL画家编号parent_idbigintNULL父评论编号create_timedatetimeNULL创建时间 2：‘管理员表’（manage）
字段名类型默认值列注释idbigintNULLIDuser_namevarcharNULL用户名pass_wordvarcharNULL密码photo_imgvarcharNULL图片namevarcharNULL名称 3：‘画家管理’（painter）
字段名类型默认值列注释idbigintNULL作者编号avatarvarcharNULL头像accountvarcharNULL账号passwordvarcharNULL密码namevarcharNULL姓名sexintNULL性别[0:男,1:女]ageintNULL年龄infotextNULL简介create_timedatetimeNULL创建时间 4：‘收藏商品’（painter_collect）
字段名类型默认值列注释idbigintNULL主键portfolio_idbigintNULL作品商品编号painter_idbigintNULL画家编号create_timedatetimeNULL创建时间 5：‘场所’（place）
字段名类型默认值列注释idbigintNULL服务编号locationtextNULL地址详情titlevarcharNULL服务标题latitudevarcharNULL经度longitudevarcharNULL纬度create_timedatetimeNULL创建时间infovarcharNULL介绍imagevarcharNULL图片 6：‘作品集商品’（portfolio）
字段名类型默认值列注释idbigintNULL商品编号painter_idbigintNULL所属画家portfolio_namevarcharNULL商品名称pricevarcharNULL价格contenttextNULL详细介绍portfolio_imgtextNULL作品图集addressvarcharNULL所处位置infovarcharNULL简介create_timedatetimeNULL创建时间telvarcharNULL联系方式cover_imgvarcharNULL封面图片statusintNULL状态[0:上架,1:下架] 7：‘记录表’（records）
字段名类型默认值列注释idbigintNULL主键themes_idbigintNULL主题/作品编号painter_idbigintNULL画家编号typeintNULL类型[0:点赞,1:收藏]create_timedatetimeNULL创建时间 8：‘主题/作品’（themes）
字段名类型默认值列注释idbigintNULL作品编号titlevarcharNULL标题painter_idbigintNULL所属画家imgvarcharNULL封面图片infotextNULL简介imagestextNULL介绍图集create_timedatetimeNULL发布时间statusintNULL状态[0:审核中,1:通过,2:不通过]themes_typeintNULL类型[0:主题,1:作品]case_infovarcharNULL拒绝理由addressvarcharNULL地址 五、功能模块： 首页：作品/主题首页
作品主题详情页：详细介绍和评论
商品列表页：用户分享的商品列表
周边服务页：周边游玩服务地址
服务详情页：服务地址详细介绍
个人中心页：包含个人信息，收藏记录，发布记录，密码管理等
管理员后台管理：管理员管理网站的事宜
六、代码示例： @PostMapping public ReturnMsg manageLogin(@RequestBody Map&lt;String, String&gt; param) { if (StrUtil.isEmpty(param.get("username")) || StrUtil.isEmpty(param.get("password"))) { return ReturnMsg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db4f9fbea37840acd6a60ed6b429b26f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7586748e7a2a7f10833951868db7aa04/" rel="bookmark">
			【豆包Marscode体验官】揭秘MarsCode AI编辑助手：高效智能编辑新纪元之入门指导与最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概述2. 工具使用过程2.1 MarsCode插件简介2.2 安装和配置2.2.1 安装MarsCode插件2.2.2 配置MarsCode插件 2.3 各个功能的使用2.3.1 代码补全2.3.2 代码补全 Pro【操作提示，`No suggestion from Model`，不知道是不是版本的问题】2.3.3 代码生成2.3.4 代码编辑2.3.5 代码解释2.3.6 代码注释生成2.3.7 单元测试生成2.3.8 智能修复2.3.9 智能问答 3. 项目的功能和逻辑3.1 项目概述3.2 项目结构3.3 主要功能和实现3.3.1 Flask应用部分`app/__init__.py``app/models.py``app/routes.py``app/static/css/styles.css``app/static/js/main.js``app/templates/index.html``app/templates/login.html``app/templates/register.html` 3.3.2 C代码部分`c_library/geometry.c``c_library/geometry.h``c_library/setup.py` 3.3.3 项目入口和配置`app.py``config.py``run.py` 4. 代码库与跨语言集成的实现细节Python与C语言的集成编写C语言库编译C语言库使用Python调用C语言库 5. 项目技术说明5.1 项目技术实现5.2 关键代码实现5.2.1 C语言几何计算库（geometry.c）5.2.2 Flask应用（run.py）5.2.3 模板文件（index.html）5.2.4 样式文件（styles.css） 5.3 项目运行及效果展示 6. 商业化场景及项目完善6.1 场景6.2 完善 7. 结论8. MarsCode AI助手的未来展望1. **增强的智能编码功能**2. **更广泛的语言支持**3. **深度集成的跨语言开发能力**4. **智能调试和错误修复**5. **更强大的项目管理和协作功能**6. **机器学习驱动的智能问答**7. **更友好的用户界面和用户体验** 1. 概述 在AI时代软件开发中，跨语言项目开发是一项复杂且具有挑战性的任务。特别是当涉及到多语言组合开发时，如何高效地进行开发、调试和维护成为了关键。 MarsCode AI插件是一款强大的VSCode扩展，利用AI技术提供智能代码补全、代码生成、代码编辑、代码解释等多种功能，大大提升了开发效率。本篇文章将详细介绍如何使用MarsCode AI插件在VSCode中开发一个跨语言项目，帮助开发者快速上手并充分利用这款工具的强大功能。
2. 工具使用过程 2.1 MarsCode插件简介 MarsCode是一款集成了AI技术的VSCode插件，提供了多种智能开发功能，如代码补全、代码生成、代码编辑、代码解释、代码注释生成、单元测试生成、智能修复和智能问答等。这些功能可以显著提升开发效率，减少代码错误，并加快项目的开发进度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7586748e7a2a7f10833951868db7aa04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c1f482e33ca5c758b167067fb57a2b0/" rel="bookmark">
			微信小程序实现聊天界面，发送功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.wxml &lt;scroll-view scroll-y="true" style="height: {{windowHeight}}px;"&gt; &lt;view wx:for="{{chatList}}" wx:for-index="index" wx:for-item="item" style="padding-top:{{index==0?30:0}}rpx"&gt; &lt;!-- 左边：对方用户 --&gt; &lt;view style="display: flex; align-items: flex-start; margin-bottom: 10px;padding: 10rpx 20rpx;" wx:if="{{item.id != userInfo.id}}"&gt; &lt;view&gt; &lt;image src="{{item.url}}" style="width: 35px; height: 35px; border-radius: 10px;"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view style="padding: 15rpx 20rpx;border-radius: 0 10px 10px 10px;background-color: #ffffff; margin-left: 10rpx; display: inline-block;"&gt; &lt;text&gt;{{item.content}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 右边：当前用户 --&gt; &lt;view style="display: flex; align-items: flex-start; justify-content: flex-end;padding: 10rpx 20rpx;" wx:else&gt; &lt;view style="padding: 15rpx 20rpx; background-color: #7e66f6; border-radius: 10px 0 10px 10px; margin-right: 10rpx;color: #ffffff;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c1f482e33ca5c758b167067fb57a2b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07d264cfc614e3c335d9d23b5a34f8a/" rel="bookmark">
			uniapp本地打包到Android Studio生成APK文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）安装 Android Studio 软件； 下载地址：官方下载地址，英文环境
安装：如下之外，其他一键 next
（2）配置java环境； 下载：jdk17-windows
安装：一键 next
环境变量：
在cmd中输入指令：java -version
可查看到对应的安装版本信息。
（3）下载 uniapp 官方提供的 SDK；
Android 离线SDK - 正式版
对于用来打包项目的HbuilderX版本是有要求的，其版本需与Android 离线SDK的版本相对应！！！！！！
将下载的 HBuilder-Integrate-AS 项目导入 Android Studio
等待其构建完成就可以了
（4）创建 Android ID，登录 Dcloud 后台
应用列表 (dcloud.net.cn)
路径如下：应用管理 - 我的应用，点击右上角创建应用，应用类型选择uni-app，填写名称点击创建即可在列表中看到刚刚创建的一项，然后在列表中点击蓝色的应用名称进入配置
（5）HbuilderX打包Uniapp项目
生成本地打包App资源
将生成的资源放入 simpleDemo ：
（6）配置
将.jks后缀删除，我们需要的后缀是.keystore
key已生成，点击取消就好：
先将项目结构更改为Project这样子更好找文件，找到simpleDemo文件夹下的build.gradle，并修改以下配置，修改完成后点击右上角重新构建
接下来就是查看自己签名的SHA1、SHA256、MD5信息：
进入到simpleDemo项目目录里输入cmd打开命令面板：
输入以下命令，mykey.keystore是刚才创建的签名
keytool -list -v -keystore mykey.keystore
然后输入签名密码可以查看到自己签名的SHA1、SHA256、MD5等信息：
将上述获取的信息填入”新增“ 平台信息：
获取 ”离线打包Key“
配置信息：
将下列代码放入下一张截图位置
android.applicationVariants.all { variant -&gt; variant.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d07d264cfc614e3c335d9d23b5a34f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7ef85a823a30e84a46a277a5d2ae99/" rel="bookmark">
			excel中的时间格式通过js转化为正常时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中，如果有一个类似44419.40592592592这样的数字，它通常不代表直接可用于Date对象的格式，因为JavaScript的Date对象期望的是从1970年1月1日UTC开始的毫秒数（时间戳）。
但是，如果知道这个数字是基于某个特定的起点（比如Excel中的1900年1月1日或1904年1月1日，因为Excel有一个关于1900年是否为闰年的错误），可以通过计算将其转换为JavaScript中的Date对象。
然而，由于44419.40592592592看起来更像是从某个日期开始的天数加上一天中的时间比例，我们可以假设它是从某个特定日期（比如Excel的基准日期）开始的。但在这个例子中，我将使用1900年1月1日作为起点（尽管这不是Excel的默认行为，因为Excel实际上在日期计算上有其复杂性，特别是关于1900年的处理）。
注意：以下示例仅用于说明如何将这种格式转换为JavaScript日期，并且它假设了一个不常见的起点（1900年1月1日）。在实际应用中，可能需要调整这个起点。
function convertToJSDate(daysSinceEpoch, epochYear = 1900) { // 创建一个从epochYear年1月1日开始的日期 const epochDate = new Date(epochYear, 0, 1); // 月份从0开始计数，所以0代表1月 // 计算总毫秒数 // 一天有 24 * 60 * 60 * 1000 毫秒 // daysSinceEpoch的整数部分是天数，小数部分是当天的时间比例 const totalMilliseconds = daysSinceEpoch * 24 * 60 * 60 * 1000; const dayMilliseconds = Math.floor(daysSinceEpoch) * 24 * 60 * 60 * 1000; const timeFraction = daysSinceEpoch - Math.floor(daysSinceEpoch); const timeMilliseconds = timeFraction * 24 * 60 * 60 * 1000; // 使用epochDate和计算出的毫秒数来创建新的日期对象 const resultDate = new Date(epochDate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7ef85a823a30e84a46a277a5d2ae99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32cd86c2c403211c36be60b55ecb9f2/" rel="bookmark">
			大数据-45 Redis 持久化概念 RDB AOF机制 持久化原因和对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （正在更新…） 章节内容 上节完成了的内容如下：
Redis慢查询日志Redis监视器Redis慢查询定位和处理 持久化原因 Redis 是内存数据库，宕机后数据消失Redis 重启后快速恢复数据 需要提供持久化机制Redis 持久化是为了快速恢复 持久化方式 Redis 的持久化不保证数据的完整性！
RDBAOF 我们可以通过 INFO 指令查看Redis当前持久化的信息：
./redis-cli info RDB（Redis Database） RDB 持久化是通过生成内存快照的方式，将 Redis 数据写入到磁盘上的二进制文件中。
RDB 文件可以在指定的时间间隔内进行创建（快照方式），例如每隔一段时间或者每达到一定数量的写操作时。
具体特性如下：
自动备份：RDB 文件可以设置在特定时间间隔自动生成，用于数据备份和恢复。高效恢复：由于 RDB 文件是紧凑的二进制格式，恢复数据时速度非常快。性能开销低：在持久化的过程中，Redis 仍然可以处理客户端请求，只是在生成 RDB 文件时会稍微影响性能。数据丢失风险：如果 Redis 意外崩溃，最后一次 RDB 快照之后的数据会丢失，因为快照是周期性的而不是实时的。 AOF（Append Only File） AOF 持久化是将每一个写操作记录到日志文件中。
AOF 文件以文本形式记录了每一条修改命令，通过不断追加的方式来保证数据持久化。
具体特性如下：
实时性更高：AOF 可以设置为每次写操作都进行持久化（always），或者每秒持久化一次（every second），因此数据丢失的可能性较低。可重写：随着时间推移，AOF 文件会越来越大，但可以通过 AOF 重写机制将文件压缩，保持较小的文件大小。日志冗长：由于每个写操作都被记录，AOF 文件比 RDB 文件要大，而且恢复速度相对较慢，因为需要逐条执行日志命令。安全性高：AOF 更适合需要最大化数据持久性的场景，例如金融数据处理。 如何选择 RDB 和 AOF 选择 RDB 还是 AOF 取决于你的具体需求：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c32cd86c2c403211c36be60b55ecb9f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf63e80b8a57cb54187f726a5caef04/" rel="bookmark">
			Boost搜索引擎：如何建立 用户搜索内容 与 网页文件内容 之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果想使“用户搜索内容”和“网页文件内容”之间产生联系，就应该将“用户搜索内容”和“网页文件”分为很小的单元 （这个单元就是关键词），寻找用户搜索单元是否出现在这个文档之中，如果出现就证明这个网页文件和用户搜索内容有关系，如果该搜索单元在这篇文章中出现的次数较高，也就证明：这篇文章与搜索内容有很强的相关性，这就是权值(weight)。
权值可以自己定义：比如标题出现一次对应的权值为10，内容出现一次对应的权值为5，再分别统计标题和文档内容中该搜素单元出现的次数。总权值（该搜索单元）= 标题出现的次数*10 +文档内容出现的次数*5；再将用户所有的搜索单元的总权值加在一起就是这篇文章与用户搜索内容的相关性。我们可以通过每一篇文档的权值去进行排序，给用户呈现出最想要的文档内容。
如何去存储这些网页文档内容呢？
网页文档内容有 标题，网页文档内容 url网址三个部分。所以就需要结构体将他们组织在一起。我们可以选择线性容器进行存储，因为线性容器存储的位置就可以代表这篇文章的 文档ID。
那么现在面临的问题就是，用户搜索单元(用户搜索关键词)和文档单元(文档关键词)之间如何建立联系。下面采用正排索引和倒排索引去建立它们之间的关系。
建立索引： 什么是正排索引？ 正排索引就是文档ID与文档之间的关系。
正排索引 文档ID文档内容0文档11文档2 正排索引的建立，就是将文档ID与文档内容之间进行直接关联。如上表所示。
那问题来了，该如何关联呢？我们可以利用线性表，如数组，数组下标与文档ID正好是对应的，我们将解析出来的数据进行提取，存放到一个包含 标题（title)，内容(content)，url(网址信息)的结构体，再将结构体放到数组中，这样就建立好了正排索引。
什么是倒排索引？ 比如用户搜索 菜鸡爱玩，分词工具将菜鸡爱玩分为 菜鸡和爱玩，分别用菜鸡和爱玩去文档中找对应的关键词。再将关键词存在的 文档ID 与 搜索关键词 之间建立关系。
关键词（唯一性）（关键词）文档ID,权重weigh（倒排索引拉链）菜鸡文档2，文档1爱玩文档2 首先将处理好的数据进行关键词分割，用inverted_index（是map容器，map&lt;关键词,倒排索引拉链&gt;）统计关键词都出现在那些文档中，将关键词出现的这些文档放进倒排索引拉链中，这就行形成了关键词与文档ID之间的对应关系。从上面表可以看出，同一个文档ID是可以出现在不同的倒排索引拉链中的。
然而，刚开始建立索引的过程是有些慢的，很吃系统资源，所以关于网页文档内容太大并且服务器资源比较少的话，就会建立失败，因此前面才会下载Boost库的部分文件，也就是网络文件，而不是全部文件。虽然这个过程慢，但是带来的好处，还是不小的，因为索引建立过程是不会进行搜索的，当建立好之后，只要你有搜索内容，我就去inverted_index的map容器中进行查找，找到对应的倒排索引拉链，再返回。
当搜索关键词到来时，我就在inverted_index中利用关键词去找，如果存在这个关键词，那所有与这个关键词相关的文档我都找到了，如果不存在，那真就不存在。
这里的搜索关键词可能不止一个，搜索者会输入一段搜索语句，比如"菜鸡爱玩"可能会被分成“菜”“鸡”“菜鸡“”爱"“玩""爱玩”等。
正排索引代码： DocInfo *BuildForwardIndex(const std::string &amp;line) { //1. 解析line，字符串切分 //line -&gt; 3 string, title, content, url std::vector&lt;std::string&gt; results; const std::string sep = "\3"; //行内分隔符 ns_util::StringUtil::Split(line, &amp;results, sep); //ns_util::StringUtil::CutString(line, &amp;results, sep); if(results.size() != 3){ return nullptr; } //2. 字符串进行填充到DocIinfo DocInfo doc; doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf63e80b8a57cb54187f726a5caef04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6302e95864fd1b4fccb9bb6e30a301a6/" rel="bookmark">
			Java 实现分页的几种方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 分页概述Java实现分页的几种方式 手动分页基于JDBC的分页基于Hibernate的分页基于MyBatis的分页[基于Spring Data JPA的分页](#基于Spring Data JPA的分页)使用PageHelper插件的分页 分页中的注意事项总结 分页概述 分页是指将大量数据分成若干小块，每次只显示其中一部分，以减少系统负载并提升用户体验。实现分页的关键在于控制每页显示的数据量，以及用户请求的当前页数。
Java实现分页的几种方式 手动分页 手动分页是最基本的分页方式，通过Java代码手动控制数据的分页。以下是一个简单的例子：
import java.util.ArrayList; import java.util.List; public class ManualPagination { public static void main(String[] args) { List&lt;Integer&gt; data = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 100; i++) { data.add(i); } int pageSize = 10; int currentPage = 3; List&lt;Integer&gt; pagedData = paginate(data, pageSize, currentPage); System.out.println(pagedData); } public static &lt;T&gt; List&lt;T&gt; paginate(List&lt;T&gt; data, int pageSize, int currentPage) { int startIndex = (currentPage - 1) * pageSize; int endIndex = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6302e95864fd1b4fccb9bb6e30a301a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32dc05fd636904f4e9ab9e41633bbe9/" rel="bookmark">
			【数据结构】——双链表的实现（赋源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双链表的概念和结构 双链表的全称叫做：带头双向循环链表
它的结构示意图如下
注意：这⾥的“带头”跟前⾯我们说的单链表的“头结点”是两个概念，实际前⾯的在单链表阶段称呼不严谨，但是为了读者们更好的理解就直接称为单链表的头结点。 带头链表⾥的头结点，实际为“哨兵位”，哨兵位结点不存储任何有效元素，只是站在这⾥“放哨的”也可以认为是用来占位置滴！！！
双链表的实现 首先先在结构体当中输入需要的数据，则有如下的数据是需要的
结构体中的数据 typedef int LTDataType;//方便对数据类型进行统一的替换 typedef struct ListNode ListNode;//对结构体的名称重新命名交ListNode struct ListNode { LTDataType data; ListNode* next; ListNode* prev; }; 则上面的图可以变成这样
双链表新结点的创建及双链表的初始化 ListNode* LTBuyNode(LTDataType x) { ListNode* newnode = (ListNode*)malloc(sizeof(ListNode));//一个结构体的大小 if (newnode == NULL) { perror("malloc fail!"); exit(1); } newnode-&gt;data = x; newnode-&gt;next = newnode-&gt;prev = newnode; return newnode;//返回头结点 } 链表的初始化需要一个创建的新的结点作为哨兵位
//void LTInit(ListNode** pphead) //{ //	//创建一个头结点即“哨兵位” //	*pphead = LTBuyNode(-1); //} ListNode* LTInit() { ListNode* phead = LTBuyNode(-1); return phead; } //上面是两种初始化的方法 //第一种需要传递一个二级指针 在上面的代码当中，我们只需要创建一个头结点来保证第一个“头”存在即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f32dc05fd636904f4e9ab9e41633bbe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6916d15a800e9ca7e032e06aa788bf93/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(042)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
141、pandas.Series.agg(regate)方法
141-1、语法
141-2、参数
141-3、功能
141-4、返回值
141-5、说明
141-6、用法
141-6-1、数据准备
141-6-2、代码示例
141-6-3、结果输出
142、pandas.Series.transform方法
142-1、语法
142-2、参数
142-3、功能
142-4、返回值
142-5、说明
142-6、用法
142-6-1、数据准备
142-6-2、代码示例
142-6-3、结果输出
143、pandas.Series.map方法
143-1、语法
143-2、参数
143-3、功能
143-4、返回值
143-5、说明
143-6、用法
143-6-1、数据准备
143-6-2、代码示例
143-6-3、结果输出
144、pandas.Series.groupby方法
144-1、语法
144-2、参数
144-3、功能
144-4、返回值
144-5、说明
144-6、用法
144-6-1、数据准备
144-6-2、代码示例
144-6-3、结果输出
145、pandas.Series.rolling方法
145-1、语法
145-2、参数
145-3、功能
145-4、返回值
145-5、说明
145-6、用法
145-6-1、数据准备
145-6-2、代码示例
145-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 141、pandas.Series.agg(regate)方法 141-1、语法 # 141、pandas.Series.agg(regate)方法 pandas.Series.agg(func=None, axis=0, *args, **kwargs) Aggregate using one or more operations over the specified axis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6916d15a800e9ca7e032e06aa788bf93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23d7f1a30011086e46274485cc9edaf1/" rel="bookmark">
			【初阶数据结构篇】时间（空间）复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 算法复杂度时间复杂度1. 定义2. 表示方法3. 常见时间复杂度4.案例计算分析冒泡排序二分查找斐波那契数列（递归法）斐波那契数列（迭代法） 空间复杂度案例分析冒泡排序斐波那契数列（递归法）斐波那契数列(迭代法) 时间复杂度对比 正文
算法 ​ 算法(Algorithm):就是定义良好的计算过程，他取⼀个或⼀组的值为输⼊，并产⽣出⼀个或⼀组值作为输出。简单来说算法就是⼀系列的计算步骤，⽤来将输⼊数据转化成输出结果。
​ 程序=数据结构+算法，一个好的程序需要有一个好的算法，那如何去衡量一种算法的好坏呢？这就需要我们计算算法的复杂度。
复杂度 ​ 复杂度是计算机科学中的一个基础概念，它帮助我们理解和评估算法的效率，对于算法设计和优化至关重要。算法的复杂度通常分为时间和空间复杂度两个方面。
时间复杂度 1. 定义 ​ 在计算机科学中，算法的时间复杂度是⼀个函数式T(N)，它定量描述了该算法的运⾏时间。时间复杂度是衡量程序的时间效率，那么为什么不去计算程序的运⾏时间呢？
​ 1.因为程序运⾏时间和编译环境和运⾏机器的配置都有关系，⽐如同⼀个算法程序，⽤⼀个⽼编译器进⾏编译和新编译器编译，在同样机器下运⾏时间不同。
​ 2.同⼀个算法程序，⽤⼀个⽼低配置机器和新⾼配置机器，运⾏时间也不同。
​ 3.并且时间只能程序写好后测试，不能写程序前通过理论思想计算评估。
2. 表示方法 ​ 如定义所示，时间复杂度是一个函数式T(N)，T(N)通过表示程序的指令的执行次数来定量描述程序的运行时间。
​ 例如，T(N)=10，T(N)=2N+10，T(N)=N2等等等，都是描述一个程序指令的执行次数
​ 但是，设想一下，采用这样的表示方法，如果两种算法一种T(N)=N2，另一种T(N)=N2+100，当N越大时二者差距就可以忽略不计，如果我们仍然这样表示，不免缺乏简洁性和统一性。
大O渐进表示法
​ 在这基础上，我们联想数学中所学的等阶无穷大概念，数学中使用小o来表示高阶无穷小，而采用大O来表示等阶无穷大。具体的来说，对于函数T(N)，当N趋于无穷时，我们能否找到这样一个函数f(N)，使得 T ( N ) f ( N ) \frac{T(N)}{f(N)} f(N)T(N)​为一个常数，答案是可以的。
3. 常见时间复杂度 下面列出了一些常见时间复杂度O(N)的表示法，即f(N)的常见形式。
常数时间复杂度：O(1)，表示算法的执行时间不随输入规模的增长而变化，是最理想的情况。对数时间复杂度：O(log n)，通常出现在二分查找等分治算法中。线性时间复杂度：O(n)，表示算法的执行时间与输入规模成正比。线性对数时间复杂度：O(n log n)，通常出现在快速排序、归并排序等分治算法中。平方时间复杂度：O(n2)，通常出现在嵌套循环的算法中。指数时间复杂度：O(2n)，通常出现在递归算法中。多项式时间复杂度：O(nk)，k可能是大于 2 的正整数，这意味着算法在大规模数据上的性能下降较快。 4.案例计算分析 冒泡排序 // 计算BubbleSort的时间复杂度？ void BubbleSort(int* a, int n) { assert(a); for (size_t end = n; end &gt; 0; --end) { int exchange = 0; for (size_t i = 1; i &lt; end; ++i) { if (a[i-1] &gt; a[i]) { Swap(&amp;a[i-1], &amp;a[i]); exchange = 1; } } if (exchange == 0) break; } } 最好情况，若数组有序 ​ T(N) =N
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23d7f1a30011086e46274485cc9edaf1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/119/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>