<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7025ee834b9bae55b3b8159d5d7cd576/" rel="bookmark">
			【Sass警告】 Sass‘s behavior for declarations that appear after nestedrules will be changing to match t
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行项目时sass会出现这种警告 虽然不影响代码运行 ，但是看着很不舒服
警告内容解释
Deprecation Warning: 表示这是一个废弃警告，意味着在未来的版本中，某些行为将会改变。
Sass's behavior for declarations that appear after nested rules: 这指的是在嵌套规则之后出现的声明。
will be changing to match the behavior specified by CSS: 表示Sass将改变其行为，以匹配CSS规范中的行为。
To keep the existing behavior: 如果你希望保持当前的行为，需要将声明移动到嵌套规则之前。
To opt into the new behavior: 如果你希望采用新的行为，可以将声明用&amp; {}包裹起来。
方案一 版本是在1.77.7开始的。 可以固定sass的版本在1.77.6之前。
npm install sass@1.32.13
方案二 声明移动到嵌套规则之前
.line-box { &amp;.right-box{ position: absolute; top: 70px; right: 0; } width: 40%; height: 50px; display: flex; line-height: 50px; } 将声明用&amp; {}包裹起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7025ee834b9bae55b3b8159d5d7cd576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc6f82f8c89adec3b9f1f157657ebd65/" rel="bookmark">
			JDK 8 升级 17 及 springboot 2.x 升级 3.x 指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK 8 升级 17 简介 从 JDK 8 升级到 JDK 17 的过程中，有几个主要的变化，特别是 Java Platform Module System (JPMS) 的引入，以及一些包路径的调整。以下是与 JDK 17 相关的一些重要变化：
Java Platform Module System (JPMS)
模块化：JDK 9 引入了模块系统，将标准 Java 库划分为多个模块。这影响了 JDK 17 中的包结构和类的组织方式。模块路径：JDK 11 引入了 --module-path 和 --add-modules 选项，允许用户指定模块路径和加载特定模块。 Java EE APIs 移除
JAX-RS：javax.ws.rs.* 包现在不在标准 Java SE 平台上。JAX-WS：javax.xml.ws.* 包现在不在标准 Java SE 平台上。JAX-B：javax.xml.bind.* 包现在不在标准 Java SE 平台上。 其他变化
JavaFX：JavaFX 已经从标准 Java SE 平台中移除，现在作为一个独立的模块存在。
如果应用使用了 JavaFX，确保已经添加了 JavaFX 模块到应用中
JSR 355：JSR 355 定义了一些与 JavaFX 相关的包，这些包也不再包含在标准 Java SE 平台上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc6f82f8c89adec3b9f1f157657ebd65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b3761ed567f8848dd8fa2a73af2856/" rel="bookmark">
			c&#43;&#43;----日期类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天这篇博客是对我们上面的两篇博客的一个小小的检验。我们今天来实现一下我们手机上的一个小功能。对日期的实现。那么如何实现以及使用哪些知识，我们马上来看看吧。
思想概括 其实实现日期类并不是什么难事。如果用c语言的话大家可能会觉得很简单，主要是我们现在初学c++对于c++的一些使用和逻辑还不是很熟悉，所以会感觉很难搞。
那么言归正传我们实现日期类，无非就是输入日期，然后进行一些加减乘除的运算，然后的醋结果再打印出来就可以了。虽然这么讲是很简单，但是实施起来却还是有点小麻烦的。就不如说我们想想我们的日期类哪些功能是不用写的。什么功能在我们手机上是一体的，但是实际实施起来却是要分开的，这就与我们上一篇博客中提及过的需要思考重载的运算符是否有意义一样。好了那么接下里我们就一步一步的实现一下。
实现日期类 创建项目 我们依据以往的经验来看，实现一个稍微大一点的项目肯定是先分别建立几个项目的。那么我们在c++中同样适用的。只是我们现在是c++了，所以我们的后缀名不在是.c而是.cpp了。
头文件内容 当我们创建好了项目后我们就要思考我们实现日期类的前提了。我们想想我们实现日期类，那么肯定得有日期吧，那么日期就是年月日。这个我们得定义。然后就是一些其他的功能了是吧。毕竟我们只是一个简单的日期类实现，并不会造成更多的项目成果。然后大家思考一下，我们居然在c+加里面，我们在头文件里面定义，那么我们肯定会用c++的相关知识吧？那么我们是像以前一样直接定义出来呢还是用其他的方法呢？
这个答案肯定显而易见了，我们肯定要使用我们在c加加里面的知识，那么我们不可采水，如果进行类的定义，这些也刚刚好方便我们使用，因为我们可以在里面直接定义了变量之后，然后再在公开的定义出我们的项目名称，然后一些其他的需要的功能
大家先看一下，上面的图片最下面是我们的变量定义， 然后最上面的我们的初始化，但是大家也看到了，我们这里使用的全却省参数，大家还记得吧。就是当我们不主动传参的话，我们的日期就会是这个了。然后上面也解释过，我们为什么将日期的比较分卡。这是因为我们这个日期比较结果又很多，如果堆在一个函数里面的话，就太臃肿了。所以我们分开来写。接下里的一部分就是我们日期对天数的修改。最好一个函数就是我们的日期减日期。最后的结果的两个日期的结果所以这是由必要的。那么我为什么会用有必要这个词咧。这是因为大家想想日期加日期有意义嘛？有啥意义啊。我们有日期加天数啊。再说了我们日期加日期，我前面还要写年份啊。这么一节不是好多个世纪过去了，就没有呀了，是吧。这也就是开始讲的我们重载要有意义。
随后就是我们看看+=和-=，前置++以及前置--。这些为什么有一个&amp;啊。这是什么意思啊。
函数实现 那么当我们实现了前置条件后，我们就来实现函数了。首先我们来写第一个函数是对参数初始化，这个简单吧，不就是接收的日期给我们要改变的日期嘛。但是大家可能会问，那你这个定义的时候，怎么没有接收的参数啊。如果大家有这个疑问的话，大家可能需要回去看看我的c++入门的博客了，因为我在里面写过this指针啊。这个包含了一个隐形的this指针，在这里this指针就指向我们的接收参数。
大家看看，这个写法大家是否理解。因为我们这里是函数实现项目，没在类里面所以我们需要确定我们来源正确，就用上我们以前学习的引用表示：：并且我们需要在前面写出出自类的名字。 但大家想想我们只需要库库一顿写就可以了吗？我们正常情况下，是不会乱写的，但是架不住有些时候啊。我们来写个2023,11,35。这不明显的有问题吗?哪个月有35天啊。所以我们是不是还要在前面写一个判断日期是否合理的函数啊。那么我们就要在头文件中定义一个判断日期正确性的函数。
这里我就不写出来了，反正大家思考一下，我们这里只是判断一下他的日期是否正确，所以说呢我们只需要段月份和日份就可以了。如果要传值呢，因为我们前面也说过，隐含的我们this指针写不出来，所以我们只需要一个括号就可以了，那样就定义好了。
同时我们也牵扯出了另外一个问题，我们说在这前面说我们需要获取他这个月的日期有多少天。我们知道我们大部分日期是确定好了的，但唯独一个二月他有平闰年的区分。所以这个我们需要单独分出来写，那么这就是我们接下来要写的第三个函数获取每个月的天数。
但是大家想一想，我们这个获取每个月的天数是不是很多呀？要调用很多次啊。们加加减减和加多少天减多少天都需要用到这个，那么如果我们再写在函数实现的项目里面是不是就有一点很烦呀？因为我们每次都要调在这里面调用。那么我们要不我直接写在头文件里面，因为我们直接在全局定义了，这相当于我们直接在这里面，而且我们在那里面写的话，这样会调用更加方便快捷。
大家可以看到我们这里在头文件里面，这样我们获得每个月的日期写出来了。前我们在定义这个日期的时候，我们想一想，我们写了一个static它定义为静态变量。那这样他就可以大家一起使用了。大家可以看到我们这个数组为什么是初始化的为13个月的。我们思考一下我们这月份没有零月吧，所以但是我们数组下标是从零开始的呀，所以我们这里就将零用随便的一个值代替，然后后面我们判断的时候就刻意避开下边为零的这个下标数就可以了。最后就是我们需要判断2月的准确天数，我们在c前面也写过。判断闰年就是看他是否被四整除和被100整除为不为零，或者被400整除为零。这样就可以判断二月要准确天数了。然后当每次调用之后，我们就将这个数组的值返回给他就可以了。
其次是我们看d1是否&lt;d2那么我们思考一下。我们日期比较吧。是不是应该先比较年份啊，大家看看嘛，如果我们的年份都比你大，那么你后面怎么都会比我们小是吧。然后依次比较下去。
并且我们在前面已经写过了获得每天的日期。那么我们就以此来比较，首先我们需要判断年份。如果连很得出结果，那么我们就可以不再判断了。我们年份无法区分大小的时候，在区分月份，然后月份之后再判断多少号。但这里我们还需要再区分一下的就是只有当年份相同的时候，我们再判断月份，当月份相同的时候再判断多少号。并且因为我们这是分开的，所以这是必须要有的步骤。
日期对比
我们前面写过了是否&lt;，接下来的是写是否&lt;=，因为我们是区分开来的吧，如果我们小于等于的话，可以简单的理解为就是小于或者等于这个就相当于是两个式子。大家思考一下，是不是这个道理？我们小于等于嘛？区分开来就是小于和等于并且因为我们前面已经写过了小于的式子那我再补一个是否相等的式子就可以了呀，大家思考一下，是不是这个道理？所以我们就暂时先不写小于等于我们就先来写判断他们是否相等。判断相等的话就很简单了，是吧？需要用我们的隐含指针的年月份与我们传递过去的年月份相比较就可以了。我们也不用在函数里面一个一个对比，我们只需要在返回值那里直接比较就可以了。
好，那我们写过了判断小于和判断相等有两个函数之后，我们再来实现小于等于不是就很简单了吗？因为我们小于等于嘛就只是需要判断他们两个其中一个成立，那么这个事情就成立了。记住大家千万不要用和有或。因为如果用核的话，那么是两个都成立才成立
那么以此类推。实现大于的话就是小于等于的相反数，大家思考一下是不是这样的？我们就不需要像开始的判断小于那样写出来完了。
然后就是大于等于的话，那岂不是就是小于的相反数了？大家思考一下，不要乱了，这个很简单，很容易理解的，大家只需要将每个试纸的符号写出来，然后思考一下就可以得出这个很简单的理论了。
最后一个呢就是判断是否不等。那么这个就是显而易见的是判断是否相等的取反了
日期加减
我们上面的一些函数实现都是判断两个日期的大小。接下来就是我们的日期的加减了。但是在实现这些函数之前，我们要现实考虑一下。为什么我们在定义的时候有一些定义是有取地址符号的，而有一些是没有的？
因为我们这几个函数都会改变我们的实参啊。是吧，其他的都不会立马改变实参，比如后置++，先使用后加，我都已经把值传回来了，虽然都是要改变的，但是我并不会立马使用啊，而且，对于我们来说，后置++是不是没啥用太大的用啊。但是我们为了区分开来还是写出来。
好，接下来我们就按照上面的顺序来依次实现一下日期加减天数的函数了。首先呢就是我们最常见的加日期加天数。对于我们的加呢我们很简单。因为我们加等是要改变原值的，并且马上返回所以我们需要使用取地址符。
但是我们还需要留意一下的就是我们首先要判断这个日期他是不是乱写，是吧？明明加的话我们要是写一个负的话，那是不是就有问题？怎么能加一个负数呢？对吧？我们就将这个值改为正值。或者将他送给减。这里我们就是将这个值送给减等。
然后就是我们去判断一下我们这个家的话不可能永远不超过这个月吧。如果没超过这个月很简单，我们只需要加就可以了，但是如果超的话，我们就需要往前月份加一。甚至我们的年也要向上加一。是吧？这个就是简单的，如果我们家的超出了月份或者年份就要向上加一。
那我们写了加等之后就是该我们写加了。但是我们需要思考一下，我们如果只是加的话会改变我们的原值吗？不会吧？那么我们这儿就只需要写一个临时变量。，然后把这个临时变量返回出来。
然后就是我们的减这样反倒很简单，那么我们减肯定就是依葫芦画瓢。 那么对于减来说，我们的减等就是至关重要的了。我们前面写过加等的减等就也很简单了。我们还是需要判断它输入的天数是否正确，然后将它送给加等。然后就是呢如果我们的这个天数它小于零是一个负数的话，那么我们是不是要借月，给这个号数相加啊，因为我们现在谁都没见过，都为负多少多少号的吧。
Ok，我们现在写了加减和加等减等的。现在就剩一些前置加加和前置减减，后置加加减减了，以及日期减日期了。我们先来写后置加加。那如果看到我刚刚的那篇博客中的话，就应该知道这家为了区分前置加加和后置加加，专门规定在后置加加的括号中写一个int。尽管我们这里是不需要传参数的，因为我们加加嘛就只是加一就可以了。你在这个括号的参数里面你可以写任何数无所谓，反正你必须是int，你才能表明这是后置加加。而且我们也说过这里面有隐含的this指针，所以我们写的参数无所谓是没问题的。
相较于后置加加，前置加加就简单很多了。也就只是加一，但只是前置加，因为我们需要将加加号的值返回过去，所以我们这里需要他的实际值 然后就是我们依葫芦画瓢的前减减和前后减减。
最后一个就是我们这里稍微有一点的难度的日期减日期了。首先呢我们日期减日期我们可以先区分出哪个大，哪个小，然后用小的一直加加加加到与大的相同，并且在途中我们在建立一个变量来记录他们相加的次数，那么这个次数不就是他们两个相差之间的天数了吗？ 还有一点就是如果只遇见这个情况来讲的话，我们只能得出一个正数。如果d1小于d2的话，我们减出的数为一个负数啊，所以我们需要再确立一个判断它为正为负的值。也可以用到我们c中学到的假设法。我们假设d1是最大的，d2是小的，然后再判断是否假设正确。如果我们假设正确的话，那么他们得出的值就是正数，这个没问题，但如果他们假设错误的话，那么他们的最后的值为负。再用我们中途创建的变量的结果乘以一个-1，那么就可以得出正确的天数了。
总结 那么上面呢就是我们的这些结果了。其实仔细思考一下其实是不难的，无非就是大家刚开始对c++的知识不熟悉，所以有时候会思考很多。其中对于天数对比的有快捷方式的时候，大家需要多思考一下，在我们实现快捷方式之前至少要写出两个式子才能进行快捷方法，你至少要写一个等于和一个大于或者小于，这样才能快捷的写出其他的。大家如果想要我的博客代码的话，可以点击下面的链接。
7月29号博客: 博客的代码以及日常练习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef34060385294ee3fcff22f9b3adcebf/" rel="bookmark">
			NSSRound#4 Team
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NSSRound#4 SWPU]1zweb 考察：phar的反序列化 1.打开环境，审计代码
1.非预期解
直接用file伪协议读取flag,或直接读取flag
file:///flag /flag 2.正常解法
用读取文件读取index.php,upload.php的源码 index.php:
&lt;?php class LoveNss{ public $ljt; public $dky; public $cmd; public function __construct(){ $this-&gt;ljt="ljt"; $this-&gt;dky="dky"; phpinfo(); } public function __destruct(){ if($this-&gt;ljt==="Misc"&amp;&amp;$this-&gt;dky==="Re") eval($this-&gt;cmd); } public function __wakeup(){ $this-&gt;ljt="Re"; $this-&gt;dky="Misc"; } } $file=$_POST['file']; if(isset($_POST['file'])){ echo file_get_contents($file); } upload.php
&lt;?php if ($_FILES["file"]["error"] &gt; 0){ echo "上传异常"; } else{ $allowedExts = array("gif", "jpeg", "jpg", "png"); $temp = explode(".", $_FILES["file"]["name"]); $extension = end($temp); if (($_FILES["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef34060385294ee3fcff22f9b3adcebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba45cd8e47ca67a6c480263fb1a4c1d5/" rel="bookmark">
			02 Go语言开发REST API接口_20240728 课程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 如果您没有Golang的基础，应该学习如下前置课程。
Golang零基础入门Golang面向对象编程Go Web 基础 基础不好的同学每节课的代码最好配合视频进行阅读和学习，如果基础比较扎实，则阅读本教程巩固一下相关知识点即可，遇到不会的知识点再看视频。
视频课程 最近发现越来越多的公司在用Golang了，所以精心整理了一套视频教程给大家，这个是其中的第4部，后续还会有很多。
视频已经录制完成，完整目录截图如下：
打个小广告，目前处于特价阶段，一节课只需要1块钱，24节课只需要24元哦。如果有需要，请前往我的淘宝店铺“Python私教”下单。
课程目录 01 环境搭建02 关于年月日版本不被支持的说明03 返回JSON字典04 Go语言通过replace查找本地库的用法05 封装JsonMap方法06 使用封装的JsonMap方法07 优化JsonMap方法08 返回JSON数组09 封装ResponseJsonArr方法10 返回JSON结构体11 封装ResponseJsonStruct方法12 统一返回格式13 封装ResponseSuccess方法14 发送GET请求15 获取查询参数16 封装GetQuery和GetQueryInt方法17 获取获取查询参数的方式18 发送和获取表单参数19 封装GetForm方法20 封装SendForm方法21 发送和获取JSON22 获取路径参数23 发送PUT请求24 发送DELETE请求 完整代码 01 环境搭建 package main import ( "fmt" "github.com/zhangdapeng520/zdpgo_httprouter" "net/http" "time" ) func Index(w http.ResponseWriter, r *http.Request, _ zdpgo_httprouter.Params) { fmt.Fprint(w, "Welcome!\n") } func main() { router := zdpgo_httprouter.New() router.GET("/", Index) server := &amp;http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba45cd8e47ca67a6c480263fb1a4c1d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31a683bb671cac9c77bd2cc60dd4906/" rel="bookmark">
			项目实战_表白墙（简易版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你能学到什么 一个比较简单的项目：表白墙（简易版），浏览器：谷歌升级版将在下个博客发布 效果如下
正文 说明 我们是从0开始一步一步做这个项目的，里面的各种问题，我也会以第一人称视角来解决，希望你们看了能感同身受，有所收获。
第一步：把项目建起来 注意： 你所创建的所有package或者class 必须和启动类在同一个路径上，启动类是什么：就是一开始就自动生成的，并且以Application结尾的那个类。
所以我们必须在leavemessage_blogs下面建包，或者建类。
对于测试代码和开发的规则也是一样的，要在 leavemessage_blogs下面建包或者建类。
第二步：配置文件 由于文件不能导入，所以前端的代码直接自己新建就行了，然后复制我的代码到你的前端html文件里。注意：你新建的文件可能有一些自动生成的代码，复制我的代码直接覆盖就行了。
代码如下 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;留言板&lt;/title&gt; &lt;style&gt; .container { width: 350px; height: 300px; margin: 0 auto; /* border: 1px black solid; */ text-align: center; } .grey { color: grey; } .container .row { width: 350px; height: 40px; display: flex; justify-content: space-between; align-items: center; } .container .row input { width: 260px; height: 30px; } #submit { width: 350px; height: 40px; background-color: orange; color: white; border: none; margin: 10px; border-radius: 5px; font-size: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b31a683bb671cac9c77bd2cc60dd4906/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d151927e4460bb1e529be77d67554a1/" rel="bookmark">
			【C&#43;&#43;】如何巧妙运用C&#43;&#43;命名空间：初学者必备指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++语法相关知识点可以通过点击以下链接进行学习一起加油！ 本篇将带领大家走进C++的旅途，为了更好地学习C++这门语言，我们需要了解它的前世今生。在了解完C++如何诞生后，将开始我们C++之旅第一站"命名空间"。(老早说是C/C++博主，现在才更C++，哈哈哈哈哈~）
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈Linux笔记专栏： Linux笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、C++诞生二、C++发展史三、命名空间3.1 命名空间定义3.2 命名空间相关特点及说明 四、编译器搜索原则五、命名空间三种使用方式六、简单了解:C++输入与输出六、std命名空间的使用惯例 一、C++诞生 由于C语言是结构化和模块化的语言，适合处理较小规模的程序。对于复杂、规模较大的程序、需要高度的抽象和建模时，C语言不能满足需求。为了解决软件危机， 20世纪80年代， 计算机界提出了OOP(object oriented programming：面向对象)思想，支持面向对象的程序设计语言应运而生。
1982年，Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与C语言的渊源关系，命名为C++(C++基于C语言而产生)它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。
二、C++发展史 1979年，贝尔实验室的本贾尼等人试图分析unix内核时候，试图将内核模块化，于是在C语言的基础上进行扩展，增加了类的机制，完成了一个可以运行的预处理程序，称之为C with classes。
C++基于C语言进一步扩充和完善，容纳进去了面向对象编程思想，并增加了许多有用的库，以及编程范式等。
我们先来看下C++的历史版本： 阶段内容C with classes类及派生类、公有和私有成员、类的构造和析构、友元、内联函数、赋值运算符 重载等C++1.0添加虚函数概念，函数和运算符重载，引用、常量等C++2.0更加完善支持面向对象，新增保护成员、多重继承、对象的初始化、抽象类、静 态成员以及const成员函数C++3.0进一步完善，引入模板，解决多重继承产生的二义性问题和相应构造和析构的处 理C++98C++标准第一个版本，绝大多数编译器都支持，得到了国际标准化组织(ISO)和美 国标准化协会认可，以模板方式重写C++标准库，引入了STL(标准模板库)C++03C++标准第二个版本，语言特性无大改变，主要：修订错误、减少多异性C++05C++标准委员会发布了一份计数报告(Technical Report，TR1)，正式更名 C++0x，即：计划在本世纪第一个10年的某个时间发布C++11增加了许多特性，使得C++更像一种新语言，比如：正则表达式、基于范围for循 环、auto关键字、新容器、列表初始化、标准线程库等C++14对C++11的扩展，主要是修复C++11中漏洞以及改进，比如：泛型的lambda表 达式，auto的返回值类型推导，二进制字面常量等C++17在C++11上做了一些小幅改进，增加了19个新特性，比如：static_assert()的文 本信息可选，Fold表达式用于可变的模板，if和switch语句中的初始化器等C++20自C++11以来最大的发行版，引入了许多新的特性，比如：模块(Modules)、协 程(Coroutines)、范围(Ranges)、概念(Constraints)等重大特性，还有对已有 特性的更新：比如Lambda支持模板、范围for支持初始化等C++23制定ing C++还在不断的向后发展。但是：现在公司主流使用还是C++98和C++11，所有大家不用追求最新，重点将C++98和C++11掌握好。等工作后，随着对C++理解不断加深，有时间可以去琢磨下更新的特性。
三、命名空间 对于C++中符号常量、变量、函数、类和对象等。在工程中会频繁地对对象取名称，可能导致名称冲突(程序员间或者程序员和头文件间)。为了避免这种问题出现，C++引入了命名空间来对标识符的名称进行本地化，以避免命名冲突或名字污染
命名空间关键字:namespace
具体名称冲突用例:
报错理由:创建一个整型变量名称为rand，而rand是stdlib.h声明的库函数，在预编译阶段头文件会展开，会导致rand重命名
3.1 命名空间定义 定义命名空间格式 namespace 命名空间名字 { 命名空间成员 } 3.2 命名空间相关特点及说明 第一点:一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中
说明:C++具有域的概念，目前先阶段所接触到的域有全局、局部作用域、命名空间域。对于命名空间可以看成一个被圈起来的私人空间。
第二点:命名空间中可以定义变量/函数/类型
namespace N { int a; int b=10; int Add(int x,int y) { return x+y; } struct N { int c; }; } 第三点:命名空间可以嵌套命名空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d151927e4460bb1e529be77d67554a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56382e548d890855cbcb623d8c996719/" rel="bookmark">
			我们的前端开发逆天了！1 小时搞定了新网站，还跟我说 “不要钱”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是程序员鱼皮。前段时间我们上线了一个新软件 剪切助手 ，并且针对该项目做了一个官网：
很多同学表示官网很好看，还好奇是怎么做的，其实这个网站的背后还有个有趣的小故事。。。
鱼皮：我们要做个官网，能下载应用就行，一周时间怎么样？
我们的前端开发 - 多喝热水同学：一周？太小瞧我了吧，1 小时给你搞定！
鱼皮：唔嘈，你很勇哦？
本来以为他是开玩笑的，没想到，1 小时后，他真的给我看了网站效果，而且比预期的好太多了。我的评价是：逆天。
他给我解释道：其实我用了一个新框架，基本不用自己写代码，而且还可以白票平台来免费部署网站~
鱼皮：不错不错，回头给我的读者们也分享一下！
于是，就有了下面这篇文章：
对于前端同学来说，用的最多的 Web 框架无非就是 React/Vue/Angular 这三大件了，那本文将带你了解一个新的 Web 框架 Astro，并手把手带你使用 Astro 搭建一个属于自己的站点，用过的都说真香！
关于技术栈的选择 假如现在有这样一个需求，公司需要你去做一个官网落地页，没什么别的要求，界面美观且能介绍公司就行，你会怎么选技术栈？
如果是以前，我可能会挑一个自己熟悉的语言去快速开发，但是现在你问我选什么技术栈，我可能会选择 Astro，为什么？且听我娓娓道来～
首先如果是自己花时间去开发的话，我们需要搭建网站的整体布局，如导航栏、logo、页脚等等，还需要考虑移动端的适配、网站 SEO 优化等等…
我不知道你们会不会觉得有点烦？反正我是有点烦了，且自己做出来的可能还没那么好看…
如果布局、适配、SEO 这些都配好了，只需要改改文字的话那该多好！
没错，依靠 Astro 强大的主题生态就可以帮助我们快速完成这些事情！像我们公司的产品 剪切助手（https://jianqiezhushou.com） 的官网就是用 Astro 搭建的，如下：
还是很好看的有木有，且移动端的响应式适配、SEO 通通都搞定，一举多得！
接下来我们就简单了解一下 Astro 这个框架，然后使用 Astro 快速生成一个自己的站点！
Astro 框架介绍 关于 Astro 的介绍，官方文档（https://docs.astro.build/zh-cn/concepts/why-astro）给出了很明确的定位：“最适合构建像博客、营销网站、电子商务网站这样的以内容驱动的网站的 Web 框架”
它默认就支持服务端渲染，且支持 React、Preact、Svelte、Vue、Solid、Lit、HTMX、Web 组件，这意味着你可以用任意框架的写法来编写 Astro，这一特性在 Astro 中被称为 “群岛”。
快速拥有一个 Astro 应用 这里我们不会从零到一的去介绍 Astro 的写法，感兴趣的同学可以简单从官网过一遍入门指南（https://docs.astro.build/zh-cn/getting-started），我们要做的就是依靠 Astro 强大的主题模板，实现只需要改改文字、写一写 Markdown 就能轻松搭建一个漂亮的博客网站！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56382e548d890855cbcb623d8c996719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f54c923a935e842efdda4127d0a5872/" rel="bookmark">
			51单片机嵌入式开发：21、STC89C52R控制抢答器&#43;数码管&#43;后台显示&#43;LCD1602x显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配套程序
STC89C52R控制抢答器+数码管+后台显示+LCD1602x显示 STC89C52R控制抢答器+数码管+后台显示+LCD1602x显示1 概述1.1 项目概述1.2 项目组成部分1.3 功能描述 2 开发环境2.1 支持设备2.2 硬件电路 3 软件代码工程4 演示Proteus仿真5 总结 配套程序
STC89C52R控制抢答器+数码管+后台显示+LCD1602x显示 1 概述 1.1 项目概述 该项目旨在利用STC89C52R单片机构建一个多功能抢答器显示系统，涵盖LCD1602x显示屏、数码管和后台数码显示器。通过串口通信，单片机能够与后台数码显示器进行数据交换和控制，实现更加灵活和多样化的显示功能。
1.2 项目组成部分 （1）STC89C52R单片机：
（2）LCD1602显示：
（3）数码管：
（4）后台数码显示器（通过串口通信）：
（5）按键：
（6）Proteus：
1.3 功能描述 （1）LCD1602:
LCD1602显示屏用于展示文字信息，能够显示实时数据如日期、时间、温度等。
（2）数码管:
数码管用于呈现数字信息，例如计数器数值、计时器时间等。
后台数码显示器（通过串口通信）:
借助串口通信，单片机与后台数码显示器相连，实现双向数据传输和控制，扩展显示功能。
（3）按键:
通过4个按键实现抢答器按钮功能。
（4）Proteus:
使用实物演示和Proteus仿真方式展示系统功能。
2 开发环境 2.1 支持设备 我们采用华晴51开发板、Keil开发工具和PROTEUS仿真软件。结合这三者，开发人员得以进行完整的嵌入式系统开发流程。他们可以利用Keil开发工具编写、编译和调试8051单片机程序，接着通过PROTEUS仿真软件验证程序正确性和系统功能。一旦验证通过，程序可下载至华晴51开发板进行实际硬件调试和测试，完成嵌入式系统的开发。这些工具的综合运用使得开发人员能够全面开发和验证嵌入式系统，提升开发效率、降低成本，并确保系统的稳定性和可靠性。
（1）华晴51开发板：
华晴51开发板是一款基于8051系列单片机的专用开发板，主要用于嵌入式系统的学习、开发和测试。该开发板拥有多样的外设接口，包括LED、按键、数码管、LCD显示屏、通信接口等，使用户能够轻松进行各种实验和项目开发。此外，华晴51开发板支持多种编程方式，如汇编语言、C语言等，适用于各类用户，无论是初学者还是专业开发人员。
（2）Keil开发工具：
Keil开发工具是一套专业的嵌入式系统开发工具，主要针对ARM和8051等处理器的嵌入式软件开发。其中，Keil C51是专为8051系列单片机设计的C语言集成开发环境，提供编译、调试、仿真等功能，使开发人员能够高效进行嵌入式软件开发。该工具配备了强大的调试功能，可帮助开发人员快速定位和解决程序中的问题，提升开发效率。
（3）PROTEUS仿真软件：
PROTEUS是一款被广泛应用于电子电路设计和仿真的软件。在嵌入式系统开发领域，PROTEUS通常用于对电路设计和单片机程序进行仿真，以验证系统功能、调试程序并检测潜在问题。该软件提供了丰富的元件库和仿真功能，使用户能够轻松搭建电路原理图、加载单片机程序，并进行实时仿真。
2.2 硬件电路 （1）STC89C52R单片机：
晶振使用11.0592Mhz
（2）LCD1602码表：
（3）数码管：
（4）后台数码显示器（通过串口通信）：
（5）按键：
按键使用独立按键形式，P34 P35 P36 P37引脚
（6）实物与Proteus：
3 软件代码工程 //main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f54c923a935e842efdda4127d0a5872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83a94b4ba2e15a422333228acdcd27cb/" rel="bookmark">
			T-Eval：大模型智能体能力评测基准解读 | ACL 2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI Agent（智能体）作为大模型的重要应用模式，能够通过使用外部工具来执行复杂任务，完成多步骤的工作流程。为了更全面地评估模型的工具使用能力，司南及合作伙伴团队推出了T-Eval评测基准，相关成果论文已被ACL 2024主会录用，点击链接可查看原文：https://arxiv.org/abs/2312.14033。
T-Eval评测基准 使用了工具的大语言模型有着惊艳的问题解决能力，但是如何评估模型的工具使用能力还有很大的探索空间。现有评估方法通常只关注模型处理单步骤任务时的工具调用表现，缺少在多步骤复杂任务场景下模型使用工具能力的评估。
因此，为了更全面地评估大语言模型的工具使用能力，司南及合作伙伴团队推出了 T-Eval (a step-by-step Tool Evaluation benchmark for LLMs) 评测基准，相较于之前整体评估模型的方式，论文中将大模型的工具使用分解为多个子过程，包括规划、推理、检索、理解、指令跟随和审查。
规划（PLAN）：制定工具调用策略。
推理（REASON）：理解工具使用环境和自身功能，生成逻辑思考内容。
检索（RETRIEVE）：从给定的工具列表中选择合适的工具。
理解（UNDERSTAND）：正确理解工具使用的参考文档和所需参数。
指令跟随（INSTRUCT）：生成指定格式的工具调用请求。
审查（REVIEW）：评估每个工具调用执行的结果，确保回答满足预期目标。
这种分解方法不仅能够帮助我们更全面地理解大模型在工具使用方面的能力，还能够识别出模型在工具使用过程中的主要瓶颈。我们在T-Eval上进行了广泛的实验，并进行了深入分析。实验结果表明，T-Eval对模型的单过程能力和综合能力具有一致评价，即单个能力得分越高，在复杂任务中的表现就越好。
T-Eval构建过程 T-Eval 的构建主要包括 3 个阶段：工具收集、指令生成和黄金方案标注。首先，我们根据可用性和使用率，挑选了15种基本工具，涵盖了研究、旅行、娱乐、网络、生活和金融等多个领域。此外，还为每个工具生成了详细的API文档，以减少因工具描述不充分而导致的工具调用失败案例。
然后，我们利用 GPT-3.5 生成了初始问题，并通过 GPT-4 进一步完善问题。之后，我们开发了一个多智能体框架，利用所提供的工具解决问题，同时收集解决方案路径和工具响应。最后，我们使用人类专家来挑选高质量样本。
T-Eval主要贡献 （1）细粒度评测：T-Eval将评测过程分解为多个子任务，分别评估模型在工具使用上的细粒度能力。
（2）多智能体数据生成：使用了由人类专家验证的多智能体数据生成流程，显著减少了外部因素的影响，使评测结果更加稳定、公平。
（3）广泛实验：通过在各种大模型上的广泛实验，验证了T-Eval的有效性和普适性，为当前大语言模型的工具使用能力瓶颈提供了宝贵的见解，并为改进工具使用能力提供了新的视角。
评测结果 我们在 T-Eval 上对 20 种大语言模型进行了评测，包括基于API的商业模型和开源模型。结果显示，GPT-4在整体评分上取得了最高分，显示出其卓越的工具使用能力。对于开源模型，我们对三种不同规模的模型进行了实验，它们的尺寸大约是7B、13B和70B，可以发现，随着模型参数的增加，其表现也更加优秀。特别是Qwen-72B模型，其总得分已接近API模型水平。
T-Eval 现已加入 OpenCompass 评测平台，更多详细内容可参考以下链接！
GitHub：https://github.com/open-compass/T-EvalOpenCompass官网：https://hub.opencompass.org.cn/dataset-detail/T-Eval联系我们：opencompass@pjlab.org.cn 欢迎大家关注“司南评测体系”微信公众号，获取更多大模型评测相关知识~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9722ae1499a86a6373045738698b9a27/" rel="bookmark">
			Linux初学基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux文件目录 1、bin-&gt;usr/bin	binary存放命令	所有账户可以使用	Linux可以执行的文件，我们称之为命令command 2、boot	存放系统启动文件 3、dev	device存放设备文件 4、etc	存放配置文件的目录 configration files 5、home	home家目录 存放普通用户个人文件 6、root	root账户家目录，普通用户的文件不能存放这里 7、lib	library 32库文件 8、lib64	64位库文件 9、proc	虚拟文件系统 内存里面的东西 10、sbin	supper存放命令 只有root能使用 11、tmp	用来存放临时文件 12、usr	文件安装目录 比如编译 13、var	variable 变化 可变的 存放一些经常变化的文件 such as:日志 ftp服务发布文件的目录 14、run	存放pid文件 15、sys	虚拟文件系统 linux模板虚拟机centros基础配置 1、确认是否联网
# ping www.baidu.com PING www.a.shifen.com (110.242.68.3) 56(84) bytes of data. 64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=1 ttl=128 time=10.8 ms 64 bytes from 110.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9722ae1499a86a6373045738698b9a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f020de462793ef4490c4923b68090b/" rel="bookmark">
			五个优秀的免费 Ollama WebUI 客户端推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识 Ollama 本地模型框架，并简单了解它的优势和不足，以及推荐了 5 款开源免费的 Ollama WebUI 客户端，以提高使用体验。
什么是 Ollama？ Ollama 是一款强大的本地运行大型语言模型（LLM）的框架，它允许用户在自己的设备上直接运行各种大型语言模型，包括 Llama 2、Mistral、Dolphin Phi 等多种模型，无需依赖网络连接。此外，Ollama 还提供跨平台的支持，包括 macOS、Windows、Linux 以及 Docker， 几乎覆盖了所有主流操作系统。详细信息请访问 [Ollama 官方开源社区]
Ollama 的使用 你可访问 [Ollama 官方网站] 下载 Ollama 运行框架，并利用命令行启动本地模型。以下以运行 llama2 模型为例：
ollama run llama2 基于您的计算机配置，各种模型可能呈现出不同的性能特征。
Ollama 的优势 Ollama 的模型运行在本地，以及用户产生的所有数据均存储在本地，因此可以不受审查，并且足够安全和私密，能够有效地满足数据隐私保护的需求。此外，对于在本地运行的应用程序而言，这种方式不仅可以提高效率，而且还能够消除对网络环境的依赖。
Ollama 的不足 尽管 Ollama 能够在本地部署模型服务，以供其他程序调用，但其原生的对话界面是在命令行中进行的，用户无法方便与 AI 模型进行交互，因此，通常推荐利用第三方的 WebUI 应用来使用 Ollama， 以获得更好的体验。
五款开源 Ollama GUI 客户端推荐 1. LobeChat [Github 链接]
LobeChat 作为一款开源的 LLMs WebUI 框架，支持全球主流的大型语言模型，并提供精美的用户界面及卓越的用户体验。该框架支持通过本地 Docker 运行，亦可在 Vercel、Zeabur 等多个平台上进行部署。用户可通过配置本地 Ollama 接口地址，轻松实现 Ollama 以及其他本地模型的集成。查看 [在 LobeChat 中如何使用 Ollama]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f020de462793ef4490c4923b68090b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177ba9aa462fed4ad50b88bd84bd5a6a/" rel="bookmark">
			C&#43;&#43; --＞ string类模拟实现（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的Blog，点击关注哦💕
前言： C++中STL扮演着极其重要的角色，学习C++重中之重的就是学习STL，虽然string不作为containers的其中一员，但是也是值得学习的le类。下面就进行string的模拟实现
string的模拟实现和顺序表是差不多，就是增加了C++的特性。
string 模拟实现 存储结构 结构上使用命名空间mystr进行封装，防止与库冲突，使用class封装成为对象string:
定义 _size 方便记录string的大小。定义 _capacity方便记录string的容量大小定义 char* _str是存储数据，进行动态new出空间nops：npos用于表示在字符串中未找到所查找的子串，或者表示一个超出字符串长度的有效索引位置。npos的值通常被定义为std::size_t类型的最大值，这是一个无符号整数类型，因此npos实际上是一个非常大的正整数，用于表示没有找到匹配项或字符串的结束位置. namespace mystr { class string { public: static const size_t npos = -1; private:	size_t _size; size_t _capacity; char* _str; }; } 默认构造函数 构造函数 全缺省的构造函数也是默认构造函数，结尾给""常量字符串末尾存在\0; 默认构造函数：全缺省、无参、编译器默认生成的构造函数称之为默认构造函数 采取初始化列表，对于常量引用可以进行初始化。strlen计算出大小，初始化_size
2. 注意：初始化顺序就是声明的顺序，这个也是为什么将char* _str放在最后；_capacoty初始化容量+1的目的是给\0开辟空间；最后将str进行拷贝，这里采用memcpy不采用strcpy
3. memcpy可以将全部内容拷贝，strcpy会识别\0停止，假使字符串hello\0 world构造就不会得到我们想要的结果 string(const char* str = "") :_size(strlen(str)) , _capacity(_size) , _str(new char[_capacity + 1]) {	memcpy(_str, str, _capacity + 1); } 拷贝构造函数 众所周知的是当不存在拷贝构造函数，编译器会自动生成拷贝构造函数； 编译器生成的仅仅会实现数值上的拷贝（浅拷贝）_strnew出空间，要实现内容上的拷贝（深拷贝） _capacoty初始化容量+1的目的是给\0开辟空间； string(const string&amp; s) { _capacity = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177ba9aa462fed4ad50b88bd84bd5a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332e897a82e224a6cbab8ff6fc264d62/" rel="bookmark">
			打造一篇完美的【数学建模竞赛论文】：从准备到撰写的全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、赛前准备
1.1 报名与纪律要求
1.2 MD5码上传
1.3 竞赛准备
1.4 时间分配
二、论文格式规范
2.1 摘要
2.2 参考文献
2.3 排版要求
三、建模过程与方法
3.1 问题分析与模型假设
3.2 模型构建与求解
3.3 结果分析与检验
四、论文撰写技巧
4.1 论文结构
4.2 写作注意事项
五、常见问题与建议
5.1 数据处理
5.2 模型验证
5.3 创新性
六、附录
6.1 示例论文格式
6.2 常见建模方法
6.3 常用软件工具
6.4 论文撰写模板
七、总结
专栏：数学建模学习笔记
参加数学建模竞赛不仅需要扎实的数学功底和良好的团队协作能力，更需要一篇逻辑清晰、内容详实的论文来呈现你的研究成果。
一、赛前准备 1.1 报名与纪律要求 全国组委会对竞赛期间的纪律要求非常严格。参赛队员不得加入或留在涉及赛题讨论的互联网交流平台，如贴吧、QQ群和微信群等。无论是主动参与讨论还是被动接收讨论信息，均视为严重违反竞赛纪律，这将导致参赛队被无条件取消评奖资格，并视情节给予相应的通报。为了避免这种情况，建议在报名时使用家长的电话和邮箱注册，可以有效避免被监控，从而防止在竞赛期间因网上查找资料而被误判。
具体建议如下：
使用父母的联系方式和邮箱进行报名：这种方式可以有效规避网络监控，确保在竞赛期间不会因误会而受到处罚。严格遵守竞赛纪律：在竞赛期间，避免主动或被动参与任何形式的讨论平台，专注于自己的研究和论文撰写。 1.2 MD5码上传 MD5码上传是确保竞赛作品真实性和完整性的重要步骤。国家组委会规定，竞赛第三天晚上8:00之前可以多次上传MD5码，只要对电子文件进行了任何保存操作，作品的MD5码就会发生改变，需重新上传。在竞赛结束的晚上8:00至10:00之间，最多只允许上传一次MD5码。因此，安排专人负责MD5码上传工作是非常必要的，每次上传MD5码对应的论文都要备份，以确保数据的安全和完整。
具体操作建议：
安排专人负责MD5码上传工作：确保每次上传的MD5码都对应论文的最新版本，并进行备份，避免因误操作导致数据丢失。合理安排上传时间：在规定时间内多次上传MD5码，确保每次修改后的论文都能及时上传。 1.3 竞赛准备 在竞赛前，需要做好各种竞赛准备工作。这包括布置好场地，借好相关的书籍、论文格式要求等资料，还需要准备夹子、稿纸、方便面、面包、牛奶、水果等生活必需品，以及厚点的衣服。同时，安装好竞赛需要的软件，并调试好打印机，确保一切设备正常运行。在竞赛前一天晚上，参赛队员应该确保充足的睡眠，以便以最佳状态迎接竞赛。
具体准备工作包括：
布置好竞赛场地：确保竞赛环境安静、舒适，避免外界干扰。准备相关资料：包括竞赛所需的书籍、论文格式要求等，确保随时查阅。生活物资准备：竞赛期间可能会较为紧张，准备好生活物资如方便面、面包、牛奶、水果等，确保充足的体力和精力。设备调试：安装好所需的软件，调试打印机等设备，确保一切正常运行。 1.4 时间分配 根据PPT中的建议，合理的时间分配对于竞赛的成功至关重要。以下是一个合理的时间安排：
第1天（周四）：
下午5:40：坐在电脑前等待下载赛题。下午6:00：复印赛题，每人一份，分工查找资料，各自独立阅读赛题至少1-2个小时，并记录自己的想法，然后再进行讨论。讨论时，有一人负责记录，确保弄清题意，深入查找资料，并确定题目。晚上12点左右休息，确保第二天有足够的精力继续竞赛。 第2天（周五）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332e897a82e224a6cbab8ff6fc264d62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fded7acf599154a920a5e8a4218aef8/" rel="bookmark">
			Blocked aria-hidden on a ＜input＞ element because the element that just received focus must not be...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，我们使用element-ui的单选框radio，点击的时候报错如下图的错，究其原因是访问ibility问题：这个错误可能是因为HTML元素&lt;input&gt;上的aria-hidden属性被错误地使用了。aria-hidden属性是一个用于指示元素是否对屏幕阅读器等辅助技术隐藏的属性。如果一个&lt;input&gt;元素被设置为aria-hidden="true"，这可能违反了无障碍性web的最佳实践，因为屏幕阅读器用户依赖这类元素来理解应用的结构和内容
2.解决方案一（生命周期里面修改）
&lt;el-radio-group v-model="formData.dimension" @input="changeHandle" ref="radio" &gt; &lt;el-radio :label="1"&gt;同一报告&lt;/el-radio&gt; &lt;el-radio :label="2"&gt;同一就诊&lt;/el-radio&gt; &lt;el-radio :label="3"&gt;同一患者&lt;/el-radio&gt; &lt;/el-radio-group&gt; mounted() { this.$refs.radio.$children.forEach((item) =&gt; { item.$refs.radio.removeAttribute("aria-hidden"); }); } 3.解决方案二（注册指令）
export default { bind(el, binding) { // 获取节点 let ariaEls = el.querySelectorAll(".el-radio__original"); ariaEls.forEach((item) =&gt; { item.removeAttribute("aria-hidden"); }); } }; import Vue from "vue"; import removeAria from "./moudle/removeAria"; //全局注册 Vue.directive("removeAria", removeAria); Vue.use(rightmenu); &lt;!--使用指令--&gt; &lt;el-radio-group v-model="formData.radio" @input="changeHandle" ref="radio2" v-removeAria &gt; &lt;el-radio :label="'1'"&gt; 条件树设置 &lt;/el-radio&gt; &lt;el-radio :label="'2'"&gt; 满足所有变量 &lt;/el-radio&gt; &lt;el-radio :label="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fded7acf599154a920a5e8a4218aef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3672b18e6460d0fa6f67bf1cf3c3766a/" rel="bookmark">
			一文速览Llama 3.1——对其92页paper的全面细致解读：涵盖语言、视觉、语音的架构、原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 按我原本的计划，我是依次写这些文章：解读mamba2、解读open-television、我司7方面review微调gemma2，再接下来是TTT、nature审稿微调、序列并行、Flash Attention3..
然TTT还没写完，7.23日，Meta突然发布了llama3.1..
其实，llama3 刚出来时，其长度只有8K对于包括我司在内的大模型开发者是个小小的缺憾，而此次Meta发布llama3.1的意义在于
很明显，随着llama的影响力越来越大，Meta想让llama类似Linux一样，成为开发者的行业标准(毕竟，正如Zuckerberg所说，Linux 已成为云计算和运行大多数移动设备的操作系统的行业标准基础)长度终于达到了128K，这个长度使得可以直接通过我司的paper-review数据集去微调了 如此，便有了本文：解读下llama3.1的paper (结果一看92页，好在昨天我司上线了基于大模型的翻译系统，​那先翻译一下 快速看下大概 然后慢慢抠，顺带说一句，其实正文就70页，但致谢和参考文献占了不少篇幅），且会尽可能全面细致，毕竟绝大多数的文章只会阐述本文第一部分的内容，一般都不会涉及本文第二部分、第三部分所分别对应的其视觉、语音的架构与原理
更多，见我司官网首页的「大模型项目开发线上营 第二期」
第一部分 Meta推出llama3.1：8B和70B版本都均超越同等尺寸的其他开源模型 7月23日，Meta推出了llama3.1，其405B的版本可以与GPT4正面干(可能是目前唯一一个可以与GPT4全方位分庭抗礼的开源模型)，而其8B和70B版本都均超越同等尺寸的其他开源模型
1.1 模型架构、指令微调 1.1.1 模型架构：仅解码器的transformer、直接偏好优化、GQA 为了更好的理解llama3.1，我们先来回顾下我之前介绍过的llama3(来自此文一文速览Llama 3：从Llama 3的模型架构到如何把长度扩展到100万的第一部分)
和Llama 2一样，Llama 3 继续采用相对标准的decoder-only transformer架构，但做了如下几个关键的改进
Llama 3 使用具有 128K tokens的tokenizer
相当于，一方面，分词器由 SentencePiece 换为了 Tiktoken，与 GPT4 保持一致，可以更有效地对语言进行编码
二方面，Token词表从LLAMA 2的32K拓展到了128K
基准测试显示，Tiktoken提高了token效率，与 Llama 2 相比，生成的token最多减少了 15%「正由于llama3具有更大的词表，比llama2的tokenizer具有更大的文本压缩率，所以你会看到在此文《从提升大模型数据质量的三大要素(含审稿GPT第4.6版、第4.8版、第5版)到Reviewer2的实现》中，我司七月审稿项目组发现，在统计同样的paper-review数据集时，llama3统计到的token数更少」为了提高推理效率，Llama 3在 8B 和 70B 都采用了分组查询注意力(GQA)，根据相关实验可以观察到，尽管与 Llama 2 7B 相比，模型的参数多了 1B，但改进的分词器效率和 GQA 有助于保持与 Llama 2 7B 相同的推理效率 值得指出的是，上一个版本的llama 2的34B和70B才用到了GQA「详见LLaMA的解读与其微调(含LLaMA 2)：Alpaca-LoRA/Vicuna/BELLE/中文LLaMA/姜子牙的第3.2节LLaMA2之分组查询注意力——Grouped-Query Attention」 在 8,192 个token的序列上训练模型，且通过掩码操作以确保自注意力不会跨越文档边界 本次的llama3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3672b18e6460d0fa6f67bf1cf3c3766a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5e33edb6dea515d8593d77458e4224/" rel="bookmark">
			【TS】TypeScript中的接口(Interface):对象类型的强大工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 TypeScript中的接口(Interface):对象类型的强大工具引言1. 接口的基本概念1.1 什么是接口?1.2 为什么使用接口? 2. 接口的基本语法2.1 定义接口2.2 使用接口 3. 接口的高级特性3.1 可选属性3.2 只读属性3.3 函数类型3.4 可索引类型 4. 接口的继承和实现4.1 接口继承4.2 类实现接口 5. 接口的高级用法5.1 混合类型5.2 接口合并 6. 接口vs类型别名6.1 相似之处6.2 不同之处6.3 选择建议 7. 最佳实践和注意事项7.1 命名规范7.2 保持接口简单7.3 利用接口提高代码质量7.4 接口vs抽象类 结论 TypeScript中的接口(Interface):对象类型的强大工具 引言 在TypeScript中,接口(Interface)是一种强大的工具,用于定义对象的结构和类型。它不仅能够帮助我们更好地组织和描述代码,还能提供更强的类型检查,从而提高代码的可靠性和可维护性。本文将深入探讨TypeScript中接口的概念、语法和应用,帮助您更好地理解和使用这一重要特性。
1. 接口的基本概念 1.1 什么是接口? 在TypeScript中,接口是一种用于定义对象类型的方式。它描述了一个对象应该具有的属性和方法,但不包含实现细节。接口可以看作是一种"契约",定义了对象应该遵守的规则。
1.2 为什么使用接口? 使用接口有以下几个主要优点:
提供更强的类型检查提高代码的可读性和可维护性支持代码重用和模块化便于团队协作和API设计 2. 接口的基本语法 2.1 定义接口 使用interface关键字来定义接口:
interface Person { name: string; age: number; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe5e33edb6dea515d8593d77458e4224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6996efc9f4031e42785f5d69712e73/" rel="bookmark">
			Android 性能之刷新率设置和管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 刷新率和帧率
2. 多种刷新率
3. 基本原理
3.1 屏幕 &amp; 显示控制器
3.2 Composer Service
4. Framework 策略
4.1基本架构
4.2 刷新率设置项的定义
4.2.1 最低刷新率
4.2.2 默认刷新率 &amp; 默认的用户设置刷新率
4.2.2.1 设置入口
4.2.2.2 设置场景
4.2.2.3 DisplayDeviceConfig
4.2.3 用户设置的刷新率
4.2.4 应用刷新率 &amp; 应用期望的 base mode 刷新率
4.3 刷新率更新 &amp; 应用流程
4.3.1 入口
4.3.1.1 system settings "peak_refresh_rate"
4.3.1.2 device_config &lt;"display_manager", "peak_refresh_rate_default"&gt;
4.3.1.3 setDefaultRefreshRate 方法设置 "默认刷新率"（Just for test）
4.3.1.4 窗口切换
4.3.1.5 小结
4.3.2 Vote &amp; VotesStorage
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6996efc9f4031e42785f5d69712e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c42ac5bfc7fc0b9a4ba174d03e6da9/" rel="bookmark">
			这两个大龄程序员，打算搞垮一个世界软件巨头！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道，Adobe是多媒体和数字内容创作者的绝对王者，它的旗下有众多大家耳熟能详的软件：Photoshop、Illustrator、Premiere Pro、After Effects、InDegign、Acrobat、Animate等等。
这些软件使用门槛很高，价格昂贵，安装繁琐，并且非常“吃”硬件配置。
有些程序员就不爽了，他们决定“揭竿而起”，给大家提供免费版的软件。
1
年入百万的网页版PS
Photopea是捷克小伙儿Ivan Kutskir（今年34岁了，按国内标准快要被裁了）开发了Photoshop的替代品，它的界面长得和Photoshop几乎一模一样。
不同的是，你不需要掏钱购买昂贵的软件，也不需要安装什么东西，只需要打开网站https://www.photopea.com/，就可以像Photoshop那样去处理图像。
由于无需注册，完全免费，Photopea受到了全世界的欢迎。
有流量就会有生意，Ivan Kutskir也通过广告等方式，早在2021年就年入百万美元。
更牛的是，在运营上Photopea几乎没有什么成本，一台普通的服务器就够了，因为代码都是下载到用户的浏览器中执行的。
它不需要后端，不需要支持高并发，不需要数据库。
所以单打独斗的Ivan Kutskir只需要专注开发就好，过得非常滋润。
2
网页版AE
看到Photopea，很多人就会想了，图象处理被搞定了，那么视频处理呢？
在Adobe的武器库中，有个大杀器叫AE(After Effects)，可用于2D和3D合成、动画制作和视觉特效，通常用于影片制作、电视演播和视频游戏的后期处理工作。
能不能把AE也搬到浏览器中？
今年1月份，法国人Clément Cordier就萌发了这个念头。
作为一名每天在 Linux 机器上工作的创意开发人员，他经常需要做一些视频合成、图层、关键帧、蒙版等操作，但是Adobe 的AE却无法在Linux上运行。
于是在业余时间，他开发了一个叫做Pikimov的软件，理念和Photopea非常像，无需注册、无需下载、完全免费，在浏览器中使用AE的替代品。
Pikimov尽可能地实现了AE的界面和使用体验：
基于图层的编辑系统
支持关键帧和动画功能
支持导入图像、视频、音频文件和GLB格式的3D模型
提供各种视频效果，色彩校正、模糊、蒙版
Pikimov还有一个响亮的口号：No AI ，就是说文件都保留用户的本地机器上，不用被厂商用来训练AI模型。
Pikimov非常小，只有5M，下载到浏览器中就可以运行了，完全不需要高速网络。
唯一可惜的是Pikimov现在只支持Chrome、Edge，不支持Firefox和Safari，因为它们缺乏一些Pikimov的Web API。
Pikimov用到了这些技术：
Threejs：2D/3D 组合渲染引擎
Emberjs：UI框架
WebGL GLSL：渲染视频效果
jQuery : 管理一些零零碎碎的东西
没有什么高大上的东西。语言、框架、类库都是工具，能做出什么样的产品，能发挥多大的威力，完全取决于使用工具的人。所以不要随随便便Dis这个Dis那个。
Clément Cordier是个什么样的高手？能用看起来普通的工具开发出这么复杂的Web程序？
其实他大学学的是数字艺术，2005年毕业于历史悠久的卡昂瑟堡艺术与媒体学院，获得硕士学位。
所以他的计算机编程知识，全部来自自学。
在LinkedIn上他的个人描述是“Web全栈程序员”，擅长JavaScript、HTML5、Three.js、Ember.js和PHP。
值得注意的是，在开发Pikimov之前，他已经创立了一个叫做XR+的工作室，自任CTO，开发AR/VR相关的产品，看起来更加惊艳：
但是销售也许并不好，要不然，他就不会Pikimov网站上找工作了：
如果Pikimov能快速发展起来，Clément Cordier也许就能像Photopea的Ivan Kutskir那样，光靠广告费就过得非常滋润了，根本不需要找工作了。
3
写在最后
网页版PS有了，AE有了，PR呢？Illustrator呢? Acrobat呢？
也许就在路上吧！
这是个艰难的路程，因为无论是网页版PS还是网页版AE，靠一个人单打独斗，工作量是极其吓人的。
如果不是真的热爱这个东西，并且也在这个领域有经验（PhotoPea是图像处理，Pikimov是视频处理），想做出网页版的XXX，是很难的，漫长的开发过程，根本坚持不下来。
不过世界很大，总会有某个地方的程序员突然冒头儿，带给我们惊喜。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c42ac5bfc7fc0b9a4ba174d03e6da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/077c30c77a92ada8f378dc1d6bc0ed05/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(051)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
186、pandas.Series.is_monotonic_increasing属性
186-1、语法
186-2、参数
186-3、功能
186-4、返回值
186-5、说明
186-6、用法
186-6-1、数据准备
186-6-2、代码示例
186-6-3、结果输出
187、pandas.Series.is_monotonic_decreasing属性
187-1、语法
187-2、参数
187-3、功能
187-4、返回值
187-5、说明
187-6、用法
187-6-1、数据准备
187-6-2、代码示例
187-6-3、结果输出
188、pandas.Series.value_counts方法
188-1、语法
188-2、参数
188-3、功能
188-4、返回值
188-5、说明
188-6、用法
188-6-1、数据准备
188-6-2、代码示例
188-6-3、结果输出
189、pandas.Series.align方法
189-1、语法
189-2、参数
189-3、功能
189-4、返回值
189-5、说明
189-6、用法
189-6-1、数据准备
189-6-2、代码示例
189-6-3、结果输出
190、pandas.Series.case_when方法
190-1、语法
190-2、参数
190-3、功能
190-4、返回值
190-5、说明
190-6、用法
190-6-1、数据准备
190-6-2、代码示例
190-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 186、pandas.Series.is_monotonic_increasing属性 186-1、语法 # 186、pandas.Series.is_monotonic_increasing属性 property pandas.Series.is_monotonic_increasing Return boolean if values in the object are monotonically increasing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/077c30c77a92ada8f378dc1d6bc0ed05/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/100/">«</a>
	<span class="pagination__item pagination__item--current">101/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/102/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>