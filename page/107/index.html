<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c5d76015b70d94b1d69f54534bcc40/" rel="bookmark">
			lua 游戏架构 之 游戏 AI （八）ai_tbl 行为和优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一系列的AI行为类型和它们的优先级，以及一个映射表`ai_tbl`来关联每种AI行为类型与对应的脚本文件和优先级。以下是对代码的详细解释：
lua 游戏架构 之 游戏 AI （一）ai_base-CSDN博客https://blog.csdn.net/heyuchang666/article/details/140624481?spm=1001.2014.3001.5501lua 游戏架构 之 游戏 AI （二）ai_base_move_base-CSDN博客https://blog.csdn.net/heyuchang666/article/details/140624583?spm=1001.2014.3001.5501
lua 游戏架构 之 游戏 AI （三）ai_attack-CSDN博客https://blog.csdn.net/heyuchang666/article/details/140625113?spm=1001.2014.3001.5501
定义AI行为类型
代码中首先定义了一系列的AI行为类型，使用枚举的方式表示不同的AI行为。例如：
- `eAType_BASE` 表示基础AI行为，数值为0。- `eAType_IDLE` 表示空闲状态，数值为5。- `eAType_ATTACK` 表示攻击行为，数值为50。- `eAType_DEAD` 表示死亡状态，数值为130。 这些类型用于区分不同的AI行为模式，每个类型都有一个唯一的数值标识。
定义优先级
接着定义了两个优先级常量：
- `eAI_Priority_Low` 表示低优先级，数值为0。- `eAI_Priority_High` 表示高优先级，数值为1。 优先级用于控制AI行为的执行顺序，高优先级的行为会优先执行。
AI行为映射表 `ai_tbl`
`ai_tbl` 是一个Lua表，用于映射AI行为类型到具体的脚本文件和它们的优先级。表中的每个元素是一个表，包含`script`和`priority`两个字段：- `script` 字段是一个字符串，表示实现该AI行为的脚本文件名。- `priority` 字段是一个数值，表示该AI行为的优先级。 例如：
[ eAType_BASE ] = { script = "ai_base", priority = eAI_Priority_High }, [ eAType_IDLE ] = { script = "ai_idle", priority = eAI_Priority_High }, [ eAType_ATTACK ] = { script = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c5d76015b70d94b1d69f54534bcc40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7461c33b21142ceacc044eb792d238f3/" rel="bookmark">
			【数据结构初阶】单链表经典算法题十二道——得道飞升（上篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、移除元素
2、反转链表
3、链表的中间节点
4、合并两个有序链表
Relaxing Time！！！
———————————————— 天气之子·幻 ————————————————
1、移除元素 思路：
创建一个新链表（newhead，newtail），遍历原链表，把不等于 val 的结点尾插到新链表中。
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ typedef struct ListNode ListNode; struct ListNode* removeElements(struct ListNode* head, int val) { //创建新链表 ListNode* newhead;ListNode* newtail; newhead=newtail=NULL; //遍历数组 ListNode* pcur=head; while(pcur) { if(pcur-&gt;val!=val) { //又分两种情况，链表为空，不为空 if(newhead==NULL) { newtail=newhead=pcur; } else { newtail-&gt;next=pcur; newtail=newtail-&gt;next; } } pcur=pcur-&gt;next; } //[7,7,7,7,7]，val=7 ，这种情况下，newtail=NULL，newtail-&gt;next=NULL，此时newtail不能解引用，所以加上if条件 if(newtail) newtail-&gt;next=NULL; return newhead; } 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7461c33b21142ceacc044eb792d238f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f9bf5d23cf266c49f6aa5a44b5502b3/" rel="bookmark">
			前端三大主流框架Vue React Angular有何不同？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端主流框架，Vue React Angular，大家可能都经常在使用，Vue React，国内用的较多，Angualr相对用的少一点。但是大家有思考过这三大框架的不同吗？
一、项目的选型上
中小型项目：Vue2、React居多
中大型项目：Vue3、React居多、Angular次之（出于维护等方面考虑，国内使用的相对少一点）
首先在做项目的选型上，Vue3没出来以前（即vue2的时候）大型项目更多的考虑选选择React，Angular也有一些（相对较少，这是因为Angular在国内用的人相对来说少一点，而且维护相对来说没有react和vue方便，angular的UI框架相对没那么丰富，不过最近几年也开始慢慢地更多UI框架也兼容了支持angular）,因为Vue2的双向绑定比较耗性能，但是现在出了vue3后，Vue3在vue2的基础上做了很多的改进，目前大型项目也可以选vue3了。Angular用的是typescript语法。
二：双向绑定的不同
（1）其中vue2与vue3的大家可看看以下这篇，就不再赘述了
Vue2与Vue3的区别-CSDN博客
（2）React
使用的是虚拟DOM和事件监听来实现。它相当于创建复制了一棵DOM树，一旦数据发生变化，会通过diff算法去一一比较修改。React 中的双向绑定通常是通过状态(state)和设置状态的函数(setState)来实现的，而不是直接操作 DOM 元素的值。双向绑定意味着数据可以从用户界面流向状态，同时状态的变化也能立即反映到用户界面上。
（3）Angular则是用的脏值检测，就是一旦数据发生了变化，所有的数据会从上到下整个一一检测，比较耗费性能
三、UI框架支持
各自都有不同的UI框架支持，除了以下的，还有其他的，目前用的比较多的有以下几个：
（1）Vue: element-ui 、element plus 、antdesign vue...等
(2) React: antdesign、antdesignPro...
（3) Angular: material、boostrap...
四、全局状态管理
（1）Vue:Vuex、Pinia
其中：a)Vuex是 Vue.js 的状态管理模式和库，‌它采用集中式存储管理应用的所有组件的状态，‌并以相应的规则保证状态以一种可预测的方式发生变化,Vuex 需要额外的配置来支持 TypeScript。
b)Pinia:是 Vue 的存储库，Pinia 基于更加原子的设计，每个 store 都是完全独立的，它允许您跨组件/页面共享状态,它比Vuex会更小一点，类似 Vuex, 是 Vue 的另一种状态管理方案。
Pinia 原生支持 TypeScript。
(2) React:Redux、Redux Toolkit
其中：a）Redux :是一个不可变状态容器，‌用于 JavaScript 应用的可预测状态管理。‌它提供了一个单一的全局存储来管理应用的状态
b)Redux Toolkit :是 Redux 的一个增强工具集，‌集成了 Redux 的核心功能，‌并提供了一系列的工具和方法，‌以帮助开发者更高效地进行状态管理
(3) Angular:NgRx（NgRx 是一个基于 RxJs 构建的状态管理库，‌它利用 TypeScript 的类型特性来简化实现，‌例如 reducer 的创建和促进类型安全编程。‌NgRx 提供了对状态管理的全面支持，‌包括数据的持久化、‌中间件支持等，‌适合构建大型、‌复杂的应用程序）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f9bf5d23cf266c49f6aa5a44b5502b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6645c8567811cb149332ab5c0497e057/" rel="bookmark">
			C&#43;&#43; —— 关于类和对象（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.类的定义格式 1. class为定义类的关键字，Stack为类的名字，{}中为类的主体，注意类定义结束时后⾯分号不能省略。
class Stack { } 类体中内容称为类的成员：类中的变量称为类的属性或成员变量; 类中的函数称为类的方法或者成员函数，class关键字定义与结构体非常类似，只不过是比结构体能多定义一个方法 / 成员函数
2. 为了区分成员变量，⼀般习惯上成员变量会加一个特殊标识，如成员变量前面或者后面加_ 或者 m开头，注意C++中这个并不是强制的，看个人习惯或者要求
class zjh { public: void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } }; class zjh { private: int _year; // year_ m_year int _month; int _day; }; 成员变量只要定义在类里面就可以，没有其他限制
3. C++中struct也可以定义类，C++兼容C中struct的用法，同时struct升级成了类，明显的变化是
struct中可以定义函数，⼀般情况下我们还是推荐用class定义类
Struct zjh { public: void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } }; class与struct的区别是 ：class的默认访问限定符是私有的，而struct的默认访问限定符是公有的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6645c8567811cb149332ab5c0497e057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd1677460c9c39107bfa8530395b488/" rel="bookmark">
			C&#43;&#43; --＞ string类的使用（详细介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 说完STL的重要性，我们就要接触第一个string，虽然string不在容器内，但是仍然有很重要的地位，简单陈述string常用的操作。
basic_string C++的std::basic_string类是一个模板类，它支持多种字符类型。
char：用于表示单个字节的字符，通常用于ASCII编码。wchar_t：用于表示宽字符，可以用来支持更广泛的字符集，如Unicode。char16_t：用于表示16位的Unicode字符（UTF-16编码）。char32_t：用于表示32位的Unicode字符（UTF-32编码）。char8_t：用于表示UTF-8编码的字符。 basic_srring实例化出来4中类型
string wstring u16string u32string string 就是basic_string实例化出来的类型
Unicode是什么 统一码（Unicode），也叫万国码、单一码，由统一码联盟开发，是计算机科学领域里的一项业界标准，包括字符集、编码方案等。统一码是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 解释：
Unicode的出现就为了解决世界多样化的语言问题，Unicode的目的是为了解决传统字符编码方案的局限，满足跨语言、跨平台进行文本转换、处理的要求。Unicode能够表示世界上几乎所有的字符系统，包括汉字、拉丁字母、希腊字母、阿拉伯字母等，并为每个字符提供一个唯一的编号，称为码点。
Unicode是一个字符集，而不是编码方式。实际的编码方式有多种，其中最常见的是UTF-8``UTF-16``UTF-32 UTF-8是一种变长编码方式，可以使用1到4个字节来表示每个Unicode字符，它完全兼容ASCII编码，使得英文字符只需要一个字节就可以表示
string介绍 在C++编程中，string类是标准模板库（STL）中的一个核心组成部分，它提供了一种安全、便捷的方式来处理文本数据。string类封装了字符数组，并提供了一系列成员函数来执行字符串的创建、修改、连接、查找、替换等操作。
一、string默认成员函数 string出现的时间实际是早于STL的，是后来划分进STL库的，所以string开始的设计比较冗余，有许多没有必要的接口(共100多个)这也是被广大C++程序员吐槽的一个槽点，我们无需将每一个接口都记住，我们需要将核心接口记住并熟练使用，遇见一些默认的接口查看文档就可以啦！
构造函数（constructor） 截取C++官网
default (1)string();copy (2)string(const string &amp; str);from c-string (4)string (const char* s);from sequence (5)string(const char* s, size_t n);fill (6)string(size_t n, char c); int main() { //1.无参数构造函数 //string(); string s1; //2.拷贝构造 //string(const string &amp; str); string s2(s1); //3.字符串常量初始化 //string(const char* s); string s3("hello world"); //4.字符串前n个字符初始化 //string(const char* s, size_t n); string s4("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd1677460c9c39107bfa8530395b488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b9ad173f09762aa7186d7eb0dd60832/" rel="bookmark">
			不可思议的效率提升！Zotero GPT打造个人专属文献助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zotero是一款免费且开源的文献管理软件，能够帮助用户收集、整理、引用并分享研究资料。Zotero支持多种文件格式，并与常见的文字处理软件如Microsoft Word和LibreOffice等无缝集成，是学术研究和文献管理的得力助手。
在信息爆炸的时代，高效管理和阅读海量文献资料已成为一项挑战。作为一款专业的免费文献管理工具，Zotero结合了强大的人工智能助手ChatGPT，可以显著提升我们的工作效率。
Zotero 安装指南 1. 下载 Zotero 客户端及 GPT 插件 在 NineBot Ai 公众号回复：zotero，获取下载链接
2. 安装客户端 Windows 操作系统 双击下载的 Zotero-6.0.36_setup.exe 文件。
按照屏幕上的提示完成安装。
macOS 操作系统 双击下载的 Zotero-6.0.37.dmg 文件。
在打开的窗口中，将 Zotero 图标拖动到应用程序文件夹中。
打开应用程序文件夹，双击 Zotero 图标启动程序。
3. 安装 GPT 插件 Windows 操作系统 安装好 Zotero 后，打开软件，在菜单栏中选择“工具” -&gt; “附件组件”。
在弹出的窗口中，点击右上角的齿轮图标，并在弹出的菜单中选择“Install Add-on From File…”。
选择已下载的 zotero-gpt 插件，注意插件文件的后缀为“.xpi”。
在弹窗窗口中点击“Install Now”（立即安装）。
插件安装完成。
macOS 操作系统 安装好 Zotero 后，打开软件，在菜单栏中选择“工具” -&gt; “附件组件”。
在弹出的窗口中，点击右上角的齿轮图标，并在弹出的菜单中选择“Install Add-on From File…”。
选择已下载的 zotero-gpt 插件，注意插件文件的后缀为“.xpi”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b9ad173f09762aa7186d7eb0dd60832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77580a5ecfabe189f959141cc3e75189/" rel="bookmark">
			Qt自定义MessageToast
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果： 文字长度自适应，自动居中到parent，会透明渐变消失。
CustomToast::MessageToast(QS("最多添加50张图片"),this); 1. CustomToast.h #pragma once #include &lt;QFrame&gt; class CustomToast : public QFrame { Q_OBJECT public: static void MessageToast(const QString &amp;text, QWidget *parent = nullptr, int timeout = 1500); private: CustomToast(QWidget *parent = nullptr, int timeout = 1500); void setText(const QString &amp;text); private: class Impl; std::shared_ptr&lt;Impl&gt; m_impl = nullptr; class Ui; std::shared_ptr&lt;Ui&gt; ui = nullptr; }; 2. CustomToast.cpp #include "CustomToast.h" #include &lt;QGraphicsOpacityEffect&gt; #include &lt;QHBoxLayout&gt; #include &lt;QLabel&gt; #include &lt;QPropertyAnimation&gt; #include &lt;QTimer&gt; #define STR(arg) #arg class CustomToast::Ui { public: void setupUi(QWidget *parent) { layout = new QHBoxLayout(parent); parent-&gt;setLayout(layout); parent-&gt;setContentsMargins(0, 0, 0, 0); layout-&gt;setContentsMargins(0, 0, 0, 0); layout-&gt;setContentsMargins(16, 8, 16, 8); labelIcon = new QLabel(parent); labelText = new QLabel(parent); auto iconLayout = new QHBoxLayout(parent); iconLayout-&gt;addWidget(labelIcon); iconLayout-&gt;setContentsMargins(0, 2, 0, 2); layout-&gt;addLayout(iconLayout); layout-&gt;addWidget(labelText); layout-&gt;setSpacing(3); labelIcon-&gt;setFixedSize(16, 16); labelText-&gt;setMinimumHeight(20); labelText-&gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed); parent-&gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed); parent-&gt;setObjectName(STR(CustomToast)); labelIcon-&gt;setObjectName(STR(labelIcon)); labelText-&gt;setObjectName(STR(labelText)); } QHBoxLayout *layout = nullptr; QLabel *labelIcon	= nullptr; QLabel *labelText	= nullptr; }; class CustomToast::Impl { public: Impl(CustomToast *parent, int timeout) : m_parent(parent), m_timeout(timeout) { } void startOpacityAnimation() { auto graphicsOpacityEffect = new QGraphicsOpacityEffect(m_parent); graphicsOpacityEffect-&gt;setOpacity(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77580a5ecfabe189f959141cc3e75189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcae92c90240e0161646b744191ec38/" rel="bookmark">
			nvm-desktop window安装，支持动态切换nodejs版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 nvm-desktop 概述 1 、卸载干净笔记的nodejs 和nodejs的环境变量 2、安装 nvm-desktop 软件 3、配置环境变量 4、测试功能 # 此时已安装完成 其他：常见nodejs的问题解决 参考：官网 mac 安装教程
https://github.com/1111mp/nvm-desktop/blob/main/README-zh_CN.md#下载 1、卸载干净笔记的nodejs 1、卸载nodejs 软件 2、删除电脑下载的npm 和 C:\Users\用户 下的 nodejs 相关的文件 3、删除 电脑环境变量的 NODE_HOME 或 NODE_PATH 的 ，删除 环境变量 “Path” 与 nodejs 相关 4、用电脑软件清理一下注册表并重启电脑（mac 教程写的需要） 2 、安装 nvm-desktop window 1）下载 访问地址 ：https://github.com/1111mp/nvm-desktop/releases
下载window x64版本 (当前3.3 - 2024-06-26， 网上说不要低于 2.6)
2）安装 选择安装位置，并点击安装
点击完成，此时先不要对软件任何操作，配置完环境变量再操作
3 配置环境变量 安装后 c 盘 用户下会存在 .nvmd 文件夹 ，且下面的bin文件夹会存在 npm.exe
1）配置变量 新增 NVMD_DIR ，配置 Path 添加 node
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdcae92c90240e0161646b744191ec38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203b2c00a7096697c542c228a61ae6c5/" rel="bookmark">
			在WPF中使用WebView2详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Edge WebView2 Microsoft Edge WebView2 控件允许在本机应用中嵌入 web 技术(HTML、CSS 以及 JavaScript)。 WebView2 控件使用 Microsoft Edge 作为绘制引擎，以在本机应用中显示 web 内容。
使用 WebView2 可以在本机应用的不同部分嵌入 Web 代码，或在单个 WebView2 实例中生成所有本机应用。
现在使用混合技术开发桌面客户端已经变得越来越常见了，如网易云音乐、QQ音乐等，因为可以嵌入现有的网页端页面，开发成本是比较低的，而且还可以实现跨平台。
使用混合技术开发的桌面客户端占用资源相对较多，反应速度也会慢点，如果需要对操作系统有较多的功能交互，推荐使用原生API开发。
WebView2已经出来好几年了，我一直没怎么使用过，前面一直使用的是CEFSharp，CEF是基于Google Chromium项目的开源Web browser控件，和CEFSharp一样，WebView2也支持winform和wpf。
简单来说，WebView2就是一个浏览器控件，类似WPF里自带的WebBrowser，只是WebView2的内核Chrome，WebBrowser的内核是IE，而且WebView2提供的可编程接口更多。
对于桌面开发开说，我们可以使用WebView2来实现以下功能
1、爬虫
对于动态网页，可以嵌入WebView2来进行抓取。
2、自制浏览器
使用WebView2可以自己开发简单的浏览器
3、嵌入本地网页
有时候要展示一些简单的网页内容，如报告、图表等，都可以使用WebView2进行加载显示 4、开发混合应用
借助WebView2的本机和Web互操作功能，开发混合应用，例如：网易云音乐。
最近我们有一个需求是需要绘制大量的图表，使用WPF的免费控件都不能很好的满足需求，后面就选择使用Echarts（Echarts是一款基于JavaScript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表），然后嵌入网页到WPF中来实现。
本来是准备使用CEF的，同事在前期使用了WebView2，所以就继续使用WebView2。
这里我写篇文章做个记录，以便以后需要时查看。注意：本文仅介绍了WebView2中的常用功能，全部功能的使用和介绍可以访问WebView2的官方文档。
WebView2的优点 本机功能。 访问完整的本机 API 集。
代码共享。 向代码库添加 web 代码可以增加跨多个平台的重用。
Microsoft 支持。 Microsoft 在受支持的平台上提供支持并添加新功能请求。
定期发布更新和安全修补的最新版 Chromium。
已修复版本分布。 也可以在应用中打包特定版本的 Chromium 位。
支持Windows10/11
WebView2支持的平台 编程语言
Win32 C/C++.NET Framework 4.6.2 +.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203b2c00a7096697c542c228a61ae6c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068f1c76d8558f7355dc42cd04c96471/" rel="bookmark">
			大数据-50 Redis 分布式锁 乐观锁 Watch SETNX Lua Redisson分布式锁 Java实现分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （正在更新…） 章节内容 上节我们完成了：
Redis缓存相关的概念缓存穿透、缓存击穿、数据不一致性等HotKey、BigKey等问题针对上述问题提出一些解决方案 分乐观锁介绍 乐观锁基于CAS（Compare And Swap）思想，比较和替换，是不具有互斥性，不会产生锁等待而消耗资源，但需要反复的重试，能比较快的响应。
Watch实现 watch介绍 我们可以使用 Redis 来实现乐观锁：
利用 Redis 的 watch 功能，监控 Redis-Key的状态值获取 RedisKey 的值创建 Redis 事务给这个Key的值+1然后去执行这个事务，如果 key 的值被修改过则修改，key不加1 wacth实现 暂时就先忽略编码规范的内容，就先实现即可。
具体编写逻辑如下：
public class Test02 { public static void main(String[] args) { String redisKey = "lock"; ExecutorService executor = Executors.newFixedThreadPool(20); try { Jedis jedis = new Jedis("h121.wzk.icu", 6379); jedis.del(redisKey); jedis.set(redisKey, "0"); jedis.close(); } catch (Exception e) { e.printStackTrace(); } for (int i = 0; i &lt; 300; i ++) { executor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/068f1c76d8558f7355dc42cd04c96471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d34db407b6706ce9045582fb0e556994/" rel="bookmark">
			直面 AI 裁员危机：未来工程师的需求有增无减，但只有 10% 的 AI 老手能生存下来...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【导读】本文作者是大名鼎鼎的「可汗学院」创始人萨尔曼·可汗，是比尔·盖茨最欣赏的老师。当我们忧虑于人工智能是否会取代人类、导致大规模裁员之时，萨尔曼·可汗深入分析了 AGI 时代的就业需求，尤其与程序员相关的是，他认为，未来工程师的需求有增无减，但能够生存下来的一定是深度依赖于 AI 工具提高效率的人。
投稿 | 中信出版集团，摘自《教育新语》
作者 | 萨尔曼·可汗
责编 | Echo Tang
出品丨AI 科技大本营（ID：rgznai100）
许多人担心人工智能会导致大规模裁员，而人工智能驱动的新工具能比人类更快、更便宜、更高效地完成工作。一些公司已经暂停招聘他们认为人工智能将在未来几年取代的岗位。2023 年，IBM（国际商业机器公司）宣布将在五年内暂停或放缓 30% 的后台招聘，以应对最终可能由人工智能完成的工作。IBM 的这一消息表明，未来的工作将以不同的方式展开，后台或中台的工作将消失，非直接面对客户的工作也将消失，这些工作包括编制预算、管理数据、完成办公室维修和整理记录等。通过解读这些信息，我们可以看到未来的发展方向。
在人工智能充斥的市场中，工作将会是什么样子？我们该如何让学习者做好准备？自从 ChatGPT 问世以来，许多知情人士一直在说，你不会被人工智能取代，但你可能会被其他使用人工智能的人取代。
使用人工智能的作家和撰稿人的工作效率可能会提高三到五倍。软件工程师也将如此，他们正在使用人工智能助手来调试和编写他们的大部分代码。平面设计师将能够通过调整一系列基于文本的提示，制作出 50 种不同的徽标。鉴于生产力的提高，我们还需要那么多文案人员、工程师和平面设计师吗？
我认为这将是一个喜忧参半的局面。因为我们正处于这样一个技术逻辑拐点，它让我们能够利用生成式人工智能做更多的事情，所以对工程师的需求，尤其是对那些生产力高出 5~10 倍的工程师的需求，只会有增无减。
我们在过去就看到过这种情况。21 世纪初，全球化加速，大量软件工程工作被外包给印度等地。当时，作为一名年轻的工程师，我认为自己必须去商学院学习，转而从事金融行业，以免被国外的低成本劳动力所干扰。
我错了。从那时起，软件工程师工资的增长速度远远超过了通货膨胀率。这是因为智能手机和互联网的兴起为新的软件解决方案创造了有利环境。生成式人工智能为未来创新营造了更加成熟的环境。在我看来，因为有了生成式人工智能，工程师们可以创造性地应用这些技术来解决几乎所有行业的新问题，他们的工作机会将无处不在。
另一方面，我并不看好目前撰写每日股市动态的人。尽管现在还未发生，但这类任务很快就会由生成式人工智能来完成。能够生存下来的文案和技术撰稿人将是那些深度依赖人工智能来提高工作效率的人。其他 90% 的人将不得不另谋出路。
好消息是，生成式人工智能将需要新的类型的工作。当今最热门的工作之一是提示语撰写人或提示工程师。两年前，没有人知道这些工作是什么。事实证明，思想开放、富有创造力的文案撰稿人可以很好地胜任其中的一些职位。生成式人工智能还让我们看到了安全、安保和反偏见方面的全新机遇。我相信，随着越来越多的企业开始研究如何应用这项技术，新的机遇将会不断涌现。
就像教师利用人工智能来帮助他们完成更多机械、烦琐的工作一样，从人力资源到管理等各个岗位都将开始让人工智能负责制作招聘信或会议报告。从表面上看，这很不错，也很有帮助，但我也不禁考虑到了更大的后果。
这不仅仅是个人工作的问题。人工智能引发的自然选择也将在企业层面发生。如果我们有两家公司，一家规模更小、更精简、自动化程度更高，另一家规模更大、速度更慢、更依赖人力，随着时间的推移，小公司将能够以更低的价格提供同等或更好的产品，并开始从大公司那里获得更多的市场份额，最终导致工作岗位的净流失。这是我们在许多行业看到的共同趋势，随着自动化和技术的飞速发展，这种趋势还将继续。一方面，小公司能够更高效、更便宜地提供商品或服务，这对消费者是有利的。另一方面，对直接受影响的人来说，工作岗位的减少可能会使他们变得困难。
这个进程已经开始以戏剧性的方式展开。2006 年，教育技术公司 Chegg 推出了一项服务，为近 300 万客户提供家庭作业、数字教科书和实体教科书租赁以及在线辅导等方面的帮助。就在 ChatGPT 诞生的前两年，它还被《福布斯》誉为美国最有价值的教育科技企业。ChatGPT 一经推出，Chegg 就转向人工智能并开始将其纳入平台，但仍无法与 ChatGPT 匹敌。2023 年 5 月，Chegg 公布季度收益时，首席执行官承认，平台服务一直在努力追赶 OpenAI 的产品，因为有太多的学生在使用大语言模型来帮助他们做作业。Chegg 承认，由于 ChatGPT 的影响，公司已经不能预测当年能赚多少钱了。这一爆炸性的言论导致 Chegg 的股价暴跌近 50%。自从生成式人工智能出现以来，许多人担心这些工具会颠覆老牌企业。尽管这种担心曾经很遥远，但它一直是一种猜测，直到它突然变得有点过于真实，出现了这样的故事。
这并非我一个人的感受。 沃顿商学院的伊桑 · 莫里克说：“人工智能对每个行业、每个人、每份工作的影响都会不同。”“根据我们的早期研究，受人工智能影响最小的工作是屋顶工程，但我和几个瓦工聊过，他们说，‘实际上，屋顶工程也会发生变化，因为我们现在可以在人工智能的帮助下完成所有提案’。” 当你开发出能够理解语言、识别模式和解决问题的人工智能，以及能够诊断疾病、进行股市交易、谱曲、打官司、理解情绪、分析遗传密码、处理保险理赔、喷洒杀虫剂、进行工程设计和撰写文章的人工智能时，不难相信，更多的变化即将到来。成功的策略不是抵制，而是适应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d34db407b6706ce9045582fb0e556994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47dfaba8da9a00d6d7fd7c09264956ae/" rel="bookmark">
			Linux中MySQL 双主复制(互为主从)配置指南(详细过程)！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡作者主页：点击！ 🐧Linux基础知识(初学)：点击！
🐧Linux高级管理防护和群集专栏：点击！
🔐Linux中firewalld防火墙：点击！
⏰️创作时间：2024年7月24日15点48分
🀄️文章质量：95分
​
目录
前言——
配置基于GTID的复制模式
第一台主服务器配置
主服务器配置
创建具有复制权限的用户
启动从服务
第二台主服务器配置
主服务器配置
创建具有复制权限的用户
启动从服务
测试双主复制配置
第一台主服务器测试
第二台主服务器测试
总结
前言—— 在数据驱动的时代，数据库的高可用性和数据一致性是每个企业必须考虑的重要问题。MySQL 双主复制（Master-Master Replication）提供了一种有效的解决方案，通过配置两台服务器互为主从，保证数据的实时同步和高可用性。本文将详细介绍如何配置基于 GTID 的 MySQL 双主复制，并进行测试验证。
配置基于GTID的复制模式 GTID（全局事务标识符）是 MySQL 提供的一种新型复制方式，它简化了主从复制的配置和管理，确保数据的一致性和完整性。在配置 MySQL 双主复制之前，我们需要确保两台主服务器都启用了 GTID 模式。
第一台主服务器配置 主服务器配置 首先，我们需要修改第一台主服务器的配置文件 /etc/my.cnf，添加以下内容：
server-id = 100 log_bin = mysql-bin gtid_mode = ON enforce_gtid_consistency = true 这些配置项的作用如下：
server-id：设置服务器的唯一标识符。log_bin：启用二进制日志记录。gtid_mode：启用 GTID 模式。enforce_gtid_consistency：强制 GTID 一致性。 修改完配置文件后，重启 MySQL 服务使配置生效：
systemctl restart mysqld 创建具有复制权限的用户 接下来，我们需要创建一个具有复制权限的用户，用于两台服务器之间的同步：
grant replication slave on *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47dfaba8da9a00d6d7fd7c09264956ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eda8b887fe4a44a2ee6de7936a01397/" rel="bookmark">
			【Java版数据结构】初识泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
br /&gt;个人主页：Gu Gu Study
专栏：Java版数据结构
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
前言 好久没有更新文章了，大概断更了20天，想着今天就写一下文章吧！最近也是又温习了一下数据结构，其实之前我写过关于数据结构的一个专栏那个专栏是写了顺序表，链表，栈和队列，但是那时是用C语言实现的，虽然数据结构不局限于语言，但是总归在语言的使用上有所不同，毕竟面向不同，一个是面向过程的C语言，一个是面向对象的Java。所以这次我打算起一个数据结构的Java专栏，当然由于之前已经写过有些地方会写得简洁一点，模糊的话大家可以去看一下前面得文章哦。今天是关于泛型的哦！只是简单的认识一下基础，为了更好的理解后面Java使用数据结构的代码。
认识包装类 Java中，包装类（Wrapper Classes）是用来包装原始数据类型的类。Java是一种面向对象的语言，所有的对象都是类的实例，包括基本数据类型。但是基本数据类型并不是对象，它们是Java语言的一部分，而不是Java类。为了将基本数据类型当作对象来处理，Java提供了对应的包装类。
以下是Java中的基本数据类型及其对应的包装类：
boolean - Booleanbyte - Byteshort - Shortint - Integerlong - Longfloat - Floadouble - Doublechar - Characte 很容易看出来除了int和char的包装类有些特殊其它基本数据的包装类就是大写其第一个字幕。
包装类的主要作用包括：
自动装箱和拆箱：Java 5 引入了自动装箱（Autoboxing）和拆箱（Unboxing）的概念，允许自动将基本数据类型转换为对应的包装类对象，反之亦然。使用对象的方法：包装类提供了一些有用的方法，比如toString()、equals()、hashCode()等，这些在基本数据类型中是不可用的。集合框架：Java的集合框架只能存储对象，不能直接存储基本数据类型。通过包装类，可以将基本数据类型作为对象存储在集合中。方法参数：在定义方法时，如果需要一个可变参数，可以使用包装类，因为基本数据类型是不可变的。 在数据结构中我们主要运用第三点集合框架，集合框架，后面的文章会给大家讲到。
自动装箱和拆箱的使用 以下就是自动装箱和拆箱的使用方法：
如果将num1和num2打印出来，都是一样的值----5。
public class Test { public static void main(String[] args) { Integer num1 = 5; // 自动装箱 int num2 = num1; // 自动拆箱 System.out.println(num1); System.out.println(num2); } } 包装类还提供了一些静态方法，比如Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eda8b887fe4a44a2ee6de7936a01397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03852927083e88529111ab4f3698b6b2/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(045)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
156、pandas.Series.count方法
156-1、语法
156-2、参数
156-3、功能
156-4、返回值
156-5、说明
156-6、用法
156-6-1、数据准备
156-6-2、代码示例
156-6-3、结果输出
157、pandas.Series.cov方法
157-1、语法
157-2、参数
157-3、功能
157-4、返回值
157-5、说明
157-6、用法
157-6-1、数据准备
157-6-2、代码示例
157-6-3、结果输出
158、pandas.Series.cummax方法
158-1、语法
158-2、参数
158-3、功能
158-4、返回值
158-5、说明
158-6、用法
158-6-1、数据准备
158-6-2、代码示例
158-6-3、结果输出
159、pandas.Series.cummin方法
159-1、语法
159-2、参数
159-3、功能
159-4、返回值
159-5、说明
159-6、用法
159-6-1、数据准备
159-6-2、代码示例
159-6-3、结果输出
160、pandas.Series.cumprod方法
160-1、语法
160-2、参数
160-3、功能
160-4、返回值
160-5、说明
160-6、用法
160-6-1、数据准备
160-6-2、代码示例
160-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 156、pandas.Series.count方法 156-1、语法 # 156、pandas.Series.count方法 pandas.Series.count() Return number of non-NA/null observations in the Series.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03852927083e88529111ab4f3698b6b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84aaff66a9f5e07c7fe80a71f87b8e4d/" rel="bookmark">
			深度模型中的优化 - 基本算法篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 在深度学习中，模型优化是提升模型性能与训练效率的关键环节。深度模型通过优化算法不断调整其内部参数，以最小化损失函数，从而实现对复杂数据的有效拟合与预测。本篇章将简要概述深度模型中的几种基本优化算法，包括梯度下降法及其变种，这些算法在推动深度学习领域的发展中起到了至关重要的作用。
概述 梯度下降法（Gradient Descent, GD） 作为最基础的优化算法，梯度下降法通过计算损失函数关于模型参数的梯度，并沿着梯度的反方向更新参数，从而逐步逼近损失函数的最小值。然而，标准梯度下降法需要计算整个数据集的梯度，计算量大且不适合大数据集。
随机梯度下降法（Stochastic Gradient Descent, SGD） 为了克服标准梯度下降法的缺点，SGD每次随机选取一个样本计算梯度并更新参数，显著提高了计算效率。但SGD的梯度估计存在噪声，可能导致收敛过程震荡。
小批量梯度下降法（Mini-batch Gradient Descent） 作为GD与SGD的折中方案，小批量梯度下降法每次选取一小批样本计算梯度并更新参数，既保持了计算效率，又相对稳定了梯度估计。
动量法（Momentum） 在SGD基础上引入动量项，利用历史梯度信息加速收敛并减少震荡。
自适应学习率算法（如Adam） 结合了动量法和 RMSprop \text{RMSprop} RMSprop算法的优点，通过维护梯度的一阶矩和二阶矩估计来动态调整学习率，具有较快的收敛速度和较强的适应性。
基本算法 之前我们已经介绍了梯度下降（基于梯度的优化方法），即沿着整个训练集梯度下降的方向。这可以使用随机梯度下降很大程度地加速，沿着随机挑选的 minibatch \text{minibatch} minibatch数据的梯度下降方向，请参阅随机梯度下降算法篇和批算法和 minibatch \text{minibatch} minibatch算法。 随机梯度下降 随机梯度下降（ SGD \text{SGD} SGD）及其变种很可能是一般机器学习中用得最多的优化算法，特别是在深度学习中。如批算法和 minibatch \text{minibatch} minibatch算法中讨论，通过计算独立同分布地从数据生成分布中抽取的 m m m个 minibatch \text{minibatch} minibatch样本的梯度均值，我们可以得到梯度的无偏估计。
算法1：展示了如何使用这个下降梯度的估计。
算法1描述：随机梯度下降( SGD \text{SGD} SGD)在第 k k k个训练迭代的更新
伪代码：
R e q u i r e \bold{Require} Require: 学习速率 ϵ k \epsilon_k ϵk​
R e q u i r e \bold{Require} Require: 初始参数 θ \boldsymbol{\theta} θ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84aaff66a9f5e07c7fe80a71f87b8e4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceeab73504d1874949c51ddc47fa3bab/" rel="bookmark">
			如何在 Debian 8 上安装和使用 PostgreSQL 9.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
简介 关系型数据库是满足多种需求的数据组织的基石。它们支持从在线购物到火箭发射等各种应用。PostgreSQL 是一种历史悠久但仍然活跃的数据库，它遵循大部分 SQL 标准，支持 ACID 事务，支持外键和视图，并且仍在积极开发中。
如果你运行的应用程序需要稳定性、软件包质量和简单的管理，Debian 8（代号“Jessie”）是 Linux 发行版中最佳的选择之一。它的更新速度比其他“发行版”慢一些，但其稳定性和质量得到了广泛认可。如果你的应用程序或服务需要数据库，Debian 8 和 PostgreSQL 的组合是最佳选择之一。
本文将向您展示如何在新的 Debian 8 Stable 实例上安装 PostgreSQL 并开始使用。
先决条件 首先要做的是启动 Debian 8 Stable 系统。你可以按照《使用 Debian 8 进行初始服务器设置》中的说明进行操作。本教程假设你已经准备好了一个 Debian 8 Stable Droplet。
除非另有说明，本教程中的所有命令都应该以具有 sudo 权限的非 root 用户身份运行。要了解如何创建用户并授予他们 sudo 权限，请查看《使用 Debian 8 进行初始服务器设置》。
安装 PostgreSQL 在安装 PostgreSQL 之前，请确保通过以下命令更新 apt 软件包列表，以获取来自 Debian 软件仓库的最新信息：
sudo apt-get update 你应该看到软件包列表正在更新，并出现以下消息：
Reading package lists... Done. 有几个以 postgresql 开头的软件包：
postgresql-9.4：PostgreSQL 服务器软件包postgresql-client-9.4：PostgreSQL 客户端postgresql：Debian 手册或 Debian 新维护者指南中更好解释的“元软件包” 要直接安装 postgresql-9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceeab73504d1874949c51ddc47fa3bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf1fdf56faf1359da5eb75a2f42b36a/" rel="bookmark">
			【数据结构初阶】一篇文章带你超深度理解【单链表】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hi ！
目录
前言：
1、链表的概念和结构
2、单链表（Single List，简写SList）的实现
2.1 定义链表（结点）的结构
2.2 创建一个链表
2.3 打印链表
2.4 尾插
2.5 头插
2.6 尾删
2.7 头删
2.8 查找
2.9 在指定位置之前插入数据
2.10 在指定位置之后插入数据
2.11 删除pos结点
2.12 删除pos之后的结点
2.13 销毁链表
———————————————— 《 你的名字 》 ————————————————
正文开始——
前言： 前面我们学习了顺序表，实现了对数组内容增删查改等操作，但是顺序表仍然存在一些缺陷。
中间/头部的插入删除，时间复杂度为O(N)；增容需要申请新空间，拷贝数据，释放旧空间，这是不小的消耗；增容一般是成2倍的增长，大概率会有一些空间的浪费。 那我们该如何解决上面的问题呢？下面我们来学习一下链表 。
1、链表的概念和结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现。
2、单链表（Single List，简写SList）的实现 上面我们了解了链表的概念和结构，链表又分为很多种，今天我们先学习链表之一单链表。
2.1 定义链表（结点）的结构 //定义链表（结点）的结构 typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SLTNode; 2.2 创建一个链表 这里申请空间使用 malloc，在链表里面不存在增容的操作，想插入数据直接申请一个新的结点即可！用 calloc 也可以，calloc会让申请空间的内容初始化为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf1fdf56faf1359da5eb75a2f42b36a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9e3d248d94f4968dd0d88e23034025/" rel="bookmark">
			【数据结构初阶】顺序表三道经典算法题（详解&#43;图例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello！很高兴又见到你了~~~
看看今天要学点什么来充实大脑吧——
目录
1、移除元素
【思路+图解】 【总结】
2、删除有序数组中的重复项
【思路+图解】
【总结】
3、合并两个有序数组
【思路+图解】
【总结】
至此结束，Show Time！
1、移除元素 【思路+图解】 上面的例子第一个数是等于val，当不等于val 时可以自己试一下。新思路的时间复杂度为O(N)，空间复杂度为O(N)，结合思路我们尝试上代码：
int removeElement(int* nums, int numsSize, int val) { int src=0; int dst=0; while(src&lt;numsSize) { if(nums[src]==val) { src++; } else { nums[dst++]=nums[src++]; //src++; //dst++; } } return dst; } 【总结】 通过把 src 指向的不等于 val 的数赋给 dst 指向的位置，实现把不等于 val 的数放到前面，而且刚好 dst 的值就是数组中不等于 val 的数据的个数，同时要注意循环的条件。
2、删除有序数组中的重复项 【思路+图解】 咱们直接上代码：
在图解第一个步骤中出现了重复赋值的情况。经过 dst +1 后，dst 指向的数据等于2，src 指向的数据也等于2，再把 src 指向数据的值赋给dst，这里出现了重复赋值，我们优化一下代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9e3d248d94f4968dd0d88e23034025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36a0b35f56819d6b2bd635bf9b21b79/" rel="bookmark">
			DVWA中命令执行漏洞细说
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在攻击中，命令注入是比较常见的方式，今天我们细说在软件开发中如何避免命令执行漏洞
我们通过DVWA中不同的安全等级来细说命令执行漏洞
1、先调整DVWA的安全等级为Lower,调整等级在DVWA Security页面调整
2、在Command Injection页面输入127.0.0.1&amp;whoami 点击提交
这里返回是ping Ip的响应时间和当前登录系统的用户，说明后面的whoami命令已经执行了，这样就是存在命令执行漏洞，我们看看这个地方源码是怎么写的，
我们点击View Source，获取源代码，进行代码分析
代码分析：
&lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a36a0b35f56819d6b2bd635bf9b21b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152859ab2c81de08c73f68a021a8b5f8/" rel="bookmark">
			基于springboot&#43;vue&#43;uniapp的居民健康监测小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：springboot+uniappJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
用户信息管理
健康科普管理
公告类型管理
论坛信息管理
摘要
居民健康监测使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理居民健康监测信息，查看居民健康监测信息，管理居民健康监测。
总之，居民健康监测集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
研究背景
针对高校教师成果信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题，经过分析和考虑，在目前的情况下，可以引进一款居民健康监测这样的现代化管理工具，这个工具就是解决上述问题的最好的解决方案。它不仅可以实时完成信息处理，还缩短高校教师成果信息管理流程，使其系统化和规范化。同时还可以减少工作量，节约高校教师成果信息管理需要的人力和资金。所以居民健康监测是信息管理环节中不可缺少的工具，它对管理者来说非常重要。
关键技术
SpringBoot是一个全新开源的轻量级框架。基于Spring4.0设计，其不仅继承了Spring框架原来有的优秀特性，而且还通过简化配置文件来进一步简化了Spring应用的整个搭建以及开发过程。另外在原本的Spring中由于随着项目的扩大导入的jar包数量越来越大，随之出现了jar包版本之间的兼容性问题，而此时SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性问题得到了很好的解决。
JS-SDK是对之前的 WeixinJSBrige 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放，在很短的时间内获得了极大的关注。从数据监控来看，绝大部分在微信内传播的移动网页都使用到了相关的接口。
JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 微信小程序 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。我们团队把很多技术精力放置在如何帮助平台上的微信小程序开发者解决这个问题。因此我们设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 微信小程序 资源离线存储”。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
Vue是一款流行的开源JavaScript框架，用于构建用户界面和单页面应用程序。Vue的核心库只关注视图层，易于上手并且可以与其他库或现有项目轻松整合。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
用户信息管理页面，此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，还进行了对用户名称的模糊查询的条件。健康科普管理页面，此页面提供给管理员的功能有：查看已发布的健康科普数据，修改健康科普，健康科普作废，即可删除，还进行了对健康科普名称的模糊查询 健康科普信息的类型查询等等一些条件。公告类型管理页面，此页面提供给管理员的功能有：根据公告类型进行条件查询，还可以对公告类型进行新增、修改、查询操作等等。论坛信息管理页面，此页面提供给管理员的功能有：根据论坛信息进行新增、修改、查询操作等等。
系统测试
在系统编码完成之后，完成对本系统的测试工作，其主要的任务还是找出本系统可能出现的错误，而且是发现的错误越多越好，因为每发现一个程序错误，都需要进行文档记载，然后根据这些记载程序错误的文档，采取各种措施去解决这些程序问题，逐渐完善程序。所以，测试并不是去证明开发的系统是正确的，而是通过各种各样的方式去寻找系统中的缺陷，并针对性的完善系统。这样才能保证系统在实际运行中，可以保质保量的进行工作。
结论
采用Java+Mysql的方式设计制作的居民健康监测，在功能上可以满足管理人员对于信息的管理需求；在界面的设计上，尽最大努力用自身的美工知识做到界面美观简洁。在操作方面上，让系统可以方便操作，同时对用户常见的误操作行为进行分析总结，并尽力在系统中避免同样的由于用户的误操作所带来的错误现象。
（可运行源码+sql文件+文档）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/106/">«</a>
	<span class="pagination__item pagination__item--current">107/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/108/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>