<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95c7a4aeb9b38486a6de89bb84a4594/" rel="bookmark">
			【Linux】make/Makefile &amp; 进度条小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，认识 make/makefile
二，实例代码
1，依赖关系
2，原理
3，项目清理
4，测试讲解
三，Linux第一个小程序－进度条
game.h
game.c
test.c
程序详解
一，认识 make/makefile 会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力
一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的 规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作
makefile 带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。
make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命 令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一 种在工程方面的编译方法。
make是一条命令，makefile是一个文件，两个搭配使用，完成项目自动化构建。
二，实例代码 一般我们形成可执行程序都是这样的：
今天我们用make/makefile 来实施；
创建文件的名称一定要是 makefile 第一个字母大小写都可以；
像这样直接输入指令 make 可执行文件就会自动形成，非常的方便；
1，依赖关系 上面的文件 mybin,它依赖 game.o
game.o , 它依赖 game.s
game.s , 它依赖 game.i
game.i , 它依赖 game.c
2，原理 make是如何工作的,在默认的方式下，也就是我们只输入make命令。那么
1，make 会在当前目录下找名字叫 “Makefile” 或 “makefile” 的文件。
2，如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“mybin”这个文件， 并把这个文件作为最终的目标文件。
3，如果mybin文件不存在，或是mybin所依赖的后面的game.o文件的文件修改时间要比mybin这 个文件新（可以用 touch 测试），那么他就会执行后面所定义的命令来生成mybin这个文件。
4，如果如果hello所依赖的game.o文件不存在，那么make会在当前文件中找目标为game.o文件的依赖性，如果找到则再根据那一个规则生成game.o文件。（这有点像一个堆栈的过程）所依赖的game.o文件不存在，那么make会在当前文件中找目标为game.o文件的依赖性，如果找到则再根据那一个规则生成game.o文件。（这有点像一个堆栈的过程）
5，当然，你的C文件和H文件是存在的啦，于是make会生成game.o 文件，然后再用 game.o 文件声明 make的终极任务，也就是执行文件mybin了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95c7a4aeb9b38486a6de89bb84a4594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0355ccd4c4938d1d4a1047eaea86395/" rel="bookmark">
			.NET WebApi 发布到服务器(windows)并开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.发布前的准备
3.打包发布（交叉编译）
3.1更改生成xml文件的设置
3.2进入WebApi项目，右键发布
3.3发布设置------勾选在发布前删除现有文件
4.发送件至服务器
5.服务器安装对应环境
5.1安装IIS
5.2安装Hosting Bundle
6.发布
7.配置端口
8.各类报错
8.1 500.19 Internal Server Error
8.2 500.19 Internal Server Error
8.3找不到页面
8.4找不到页面
8.5显示500.31/32
1.前言 第一次接触确实很迷茫
在朋友、老师与多篇文章帮助下最终还是完成了测试。相当感谢。
​​​​​​发布.net6 WebApi项目到IIS会踩到的坑（500、404） - 简书 (jianshu.com)
这一篇总结了很多错误类型，可以查阅。
aps.net core 6.0 web API &amp; SwaggerUI &amp; IIS部署-CSDN博客
没有服务器的可以选择这篇，直接内网穿透。
.net 6 Core 发布项目 并且部署IIS_专注开发岗位的小白的博客-CSDN博客
这一篇帮忙解决了ASP.NET Core Runtime 6.0.24与让swagger显示出来(这里我也不知道有没有用到，不过我是照着敲得)。
配置过程中可能会有报错，可以翻阅第八部分. 2.发布前的准备 1.服务器（Windows）（后续会出Linux，等等吧）（windows图形化确实方便，但是占用资源太高，而且也没有docker里面运行安全）。
2.可供调试的项目，新建的都可以。
3.打包发布（交叉编译） 3.1更改生成xml文件的设置 首先右键项目点击属性
生成里面勾选生成api文档的文件
这里也是一个坑，不生成运行不起来。
3.2进入WebApi项目，右键发布 3.3发布设置------勾选在发布前删除现有文件 哥们就是在这里踩的大雷，整了半天，之前发布的没有删除，三百多个文件我还很懵逼，最后其实只有33个。文件的多少是根据项目的大小与项目本身的文件的数量决定的。
显示所有设置里面勾选在发布前删除现有文件，第一次发布以前里面应该是空的，如果多次发布还是推荐勾选上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0355ccd4c4938d1d4a1047eaea86395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f31925f6d9b65078f7fa2338b00c217/" rel="bookmark">
			Flutter开发实践：用一套代码构建多端精美应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介，黑夜开发者，CSDN领军人物，全栈领域优质创作者✌，CSDN博客专家，阿里云社区专家博主，2023年6月CSDN上海赛道top4。
🏆数年电商行业从业经验，历任核心研发工程师，项目技术负责人。
🎉欢迎 👍点赞✍评论⭐收藏
文章目录 🚀一、背景🚀二、开始开发多端应用🔎2.1 安装Flutter🔎2.2 创建Flutter项目🔎2.3 编写共享代码🔎2.4 编写平台特定代码🔎2.5 运行应用 🚀三、Flutter书籍推荐🔎3.1 书籍介绍🔎3.2 核心内容🔎3.3 特色🔎3.4 主要内容截图🔎3.5 如何领书 🚀四、总结 🚀一、背景 在移动应用开发中，为了在不同平台上提供一致的用户体验，我们通常需要编写不同的代码来适应不同的操作系统和设备。但是有了Flutter，我们可以使用一套代码构建多个平台的应用，包括iOS、Android、Web和桌面。
本文将介绍如何使用Flutter来构建一套代码适配多端应用，并给出具体的步骤和示例代码。
🚀二、开始开发多端应用 🔎2.1 安装Flutter 首先，需要在您的计算机上安装Flutter。请按照Flutter官方文档的指引进行安装，并确保配置好Flutter环境变量。
🔎2.2 创建Flutter项目 使用命令行工具或者您喜欢的集成开发环境（IDE），创建一个新的Flutter项目。
$ flutter create multiplatform_app 这将在您的当前目录下创建一个名为multiplatform_app的Flutter项目。
🔎2.3 编写共享代码 在Flutter中，我们可以使用Dart语言编写共享代码，包括界面布局、业务逻辑等。创建一个名为shared的文件夹，并在其中创建一个名为shared.dart的文件。
该文件将包含我们要共享的代码。例如，以下是一个简单的计数器应用的示例：
class Counter { int _count = 0; int get count =&gt; _count; void increment() { _count++; } void decrement() { _count--; } } 🔎2.4 编写平台特定代码 接下来，我们需要为每个目标平台编写特定的代码。在lib文件夹下，为不同的平台创建对应的文件夹，例如ios、android、web和desktop。
在各自的文件夹中，创建一个名为main.dart的文件，并编写平台特定的代码。以下是一个简单的示例：
// ios/main.dart import 'package:flutter/cupertino.dart'; import 'package:multiplatform_app/shared/shared.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f31925f6d9b65078f7fa2338b00c217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02574ac0b4196e865ba2d18915cae77/" rel="bookmark">
			汽车架构解析：python解析Autosar架构的ARXML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Container-I-PDU概念引入二、以文本形式读取ARXML文件三、解析Frame的基本参数四、解析Frame中的PDU五、解析PDU中的Signals六、解析Signal中的初始值和长度七、解析Signal中的起始位置八、解析Signal中的枚举值或公式九、解析ARXML总结 前言 Autosar架构下arxml文件作为通用数据库文件，在数据传输和存储中起到关键作用。行业上其实有一些arxml的工具可以将arxml转换成dbc，再将dbc转换成自己想要的数据，但是拿到的数据是不完整的，arxml有一些数据dbc是没有的，也根据缺少的数据直接到ARXML拿，不用硬解ARXML。想要解析ARXML的最好的方法就是对原始数据进行处理。网上有一些python的库推荐，如xml.etree.ElementTree等，我试用了下，arxml的层级关系太多了感觉处理起来不太自由。于是我决定用python的正则表达式来解析，因为知道了所需数据存放的结构体，就可以通过正则表达式快速定位获取数据，而且可以自由的获取arxml的任意数据片段，按照自己的规则解析。 正则表达式相关学习点这里
一、Container-I-PDU概念引入 1、下图为autosar的协议栈，可以看出具备多种类型的PDU：Dcm-I-PDU、General-Purpose-PDU、General-Purpose-I-PDU、I-Signal-I-PDU、Multiplexed-I-PDU、NM-PDU、N-PDU、User-Defined-PDU、User-Defined-I-PDU、XCP-PDU、J1939-Dcm-I-PDU 和 Secured-I-PDU。
2、而Container-I-PDU 是一种在 AUTOSAR 中使用的数据单元，用于封装其他类型的 PDU（Protocol Data Unit）。它是一种容器，可以包含不同类型的 PDU 作为其成员。Container-I-PDU 的主要目的是将多个 PDU 组合成一个逻辑单元进行传输。通过将多个 PDU 打包到一个 Container-I-PDU 中，可以减少通信开销，并提高通信效率。
3、虽然有Container-I-PDU的概念，但是不代表I-PDU就一定需要通过Container-I-PDU去传输，因此也有两种传输方式。
1）通过Container-I-PDU打包传输：
如果是通过Container-I-PDU打包发出则需要先找到Container-I-PDU，再找到I-PDU，最后才能找到Signal。
2）不通过Container-I-PDU打包传输：
如果是直接通过I-PDU发出，则直接找到I-PDU,再找到Signal。
二、以文本形式读取ARXML文件 import re file_path = r'C:\Users\Desktop\Demo.arxml' # ============读取Arxml文件============ with open(file_path, 'r') as file: # 读取文件内容 arxml_data = file.read() 三、解析Frame的基本参数 1、下面是arxml的片段其中就包括了CAN报文的名称DMS_ADCANFD_FrP01，寻址模式STANDARD，通讯协议CAN-FD，以及报文ID554；
2、我们查找报文相关的参数就可以通过查找&lt;CAN-FRAME-TRIGGERING...&gt;数据片段&lt;/CAN-FRAME-TRIGGERING&gt;来获取arxml中的数据片段，再进行更详细的匹配获取其余数据。
匹配片段中的&lt;FRAME-REF DEST="CAN-FRAME"&gt;../报文名称&lt;/FRAME-REF&gt;来获得报文名称；匹配片段中的&lt;CAN-ADDRESSING-MODE&gt;帧类型&lt;/CAN-ADDRESSING-MODE&gt;来获得帧类型；匹配片段中的&lt;CAN-FRAME-TX-BEHAVIOR&gt;报文类型&lt;/CAN-FRAME-TX-BEHAVIOR&gt;来获得报文类型；匹配片段中的&lt;IDENTIFIER&gt;报文ID&lt;/IDENTIFIER&gt;来获得报文ID； &lt;CAN-FRAME-TRIGGERING UUID="09816ea3-a46c-3b48-97f8-d9f3f92799e8"&gt; &lt;SHORT-NAME&gt;FrTrDMS_ADCANFD_FrP01&lt;/SHORT-NAME&gt; &lt;FRAME-PORT-REFS&gt; &lt;FRAME-PORT-REF DEST="FRAME-PORT"&gt;/ECUSystem/DMS/DMSC/DMSCCfg/DMSCCfg/ADCANFD/FramePort_Out&lt;/FRAME-PORT-REF&gt; &lt;FRAME-PORT-REF DEST="FRAME-PORT"&gt;/VectorAutosarExplorerGeneratedObjects/ECU_INSTANCES/OtherNodes/Connector_OtherNodes_64e0f3f0db5999fe/framePort_ac33e765d8d23aa9&lt;/FRAME-PORT-REF&gt; &lt;/FRAME-PORT-REFS&gt; &lt;FRAME-REF DEST="CAN-FRAME"&gt;/Communication/Frame/DMS_ADCANFD_FrP01&lt;/FRAME-REF&gt; &lt;PDU-TRIGGERINGS&gt; &lt;PDU-TRIGGERING-REF-CONDITIONAL&gt; &lt;PDU-TRIGGERING-REF DEST="PDU-TRIGGERING"&gt;/VehicleTopology/ADCANFD/PhCnADCANFD/PduTrDMS_ADCANFD_050ms_Container01&lt;/PDU-TRIGGERING-REF&gt; &lt;/PDU-TRIGGERING-REF-CONDITIONAL&gt; &lt;/PDU-TRIGGERINGS&gt; &lt;CAN-ADDRESSING-MODE&gt;STANDARD&lt;/CAN-ADDRESSING-MODE&gt; &lt;CAN-FRAME-TX-BEHAVIOR&gt;CAN-FD&lt;/CAN-FRAME-TX-BEHAVIOR&gt; &lt;IDENTIFIER&gt;554&lt;/IDENTIFIER&gt; &lt;/CAN-FRAME-TRIGGERING&gt; 3、正则表达式处理数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d02574ac0b4196e865ba2d18915cae77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44964f8e9e51219e01ad245e30fe06bb/" rel="bookmark">
			【Vue】生命周期一文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
生命周期
钩子函数使用方法
​编辑
周期-----创建阶段
创建阶段做了些什么事
该阶段可以干什么
周期----挂载阶段
挂载阶段做了什么事
该阶段适合干什么
周期----更新阶段
更新阶段做了什么事
该阶段适合做什么
周期----销毁阶段
销毁阶段做了什么事
该阶段适合做什么
前言 Vue生命周期分为四个周期：创建、挂载、更新、销毁
生命周期 每个周期对应两个函数，对应的函数又叫钩子函数
创建：
beforeCreate() ------ 创建前
created() ------ 创建后
挂载：
beforeMount() ------ 挂载前
mounted() ------ 挂载后
更新：
beforeUpdate() ------ 更新前
updated() ----- 更新后
销毁：
beforeDestroy() ------- 销毁前
destroyed() ------ 销毁后
钩子函数使用方法 &lt;div class="app"&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt; {{num}} &lt;button @click="add()"&gt;+1&lt;/button&gt; &lt;button @click="destroy()"&gt;销毁&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el:'.app', data:{ msg:'Vue的生命周期', num:1 }, methods:{ add(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44964f8e9e51219e01ad245e30fe06bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95e0cefe0483b9b3f8b678899f518bc/" rel="bookmark">
			【送书福利-第二十八期】《AIGC：让生成式AI成为自己的外脑》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😎 作者介绍：我是程序员洲洲，一个热爱写作的非著名程序员。CSDN全栈优质领域创作者、华为云博客社区云享专家、阿里云博客社区专家博主、前后端开发、人工智能研究生。公粽号：程序员洲洲。
🎈 本文专栏：本文收录于洲洲的《送书福利》系列专栏，该专栏福利多多，只需 关注+点赞+收藏 三连即可参与送书活动！欢迎大家关注本专栏~专栏一键跳转
🤓 同时欢迎大家关注其他专栏，我将分享Web前后端开发、人工智能、机器学习、深度学习从0到1系列文章。
🌼 同时洲洲已经建立了程序员技术交流群，如果您感兴趣，可以私信我加入我的社群~社群中将不定时分享各类福利
🖥 随时欢迎您跟我沟通，一起交流，一起成长、进步！点此即可获得联系方式~
本文目录 一、前言二、内容介绍三、作者介绍四、本书特色五、抽奖方式总结 一、前言 今天给大家推荐一本清华出版社的好书：《AIGC：让生成式AI成为自己的外脑》
二、内容介绍 《AIGC：让生成式AI成为自己的外脑》针对近期较为火热的AIGC技术及其相关话题，介绍AIGC的技术原理、专业知识和应用。
全书共分为九章。第一章介绍AIGC技术的基本概念和发展历程；第二、三章介绍AIGC的基础技术栈和拓展技术栈；第四、五章分别讨论了AIGC技术在文本生成和图像生成两个领域的现状和前景；第六章列举了目前较为热门的AIGC技术应用；第七章描述了AIGC的上、中、下游产业链及未来前景；第八章主要关注AIGC在法律和道德上可能存在的争议与问题；第九章对AIGC技术进行了总结与展望。全书运用可视化的表达方式，对较为复杂的概念进行了生动易懂的阐述。
AIGC：让生成式AI成为自己的外脑适合AIGC从业人员、相关技术人员以及相关专业的学生参考和学习。
三、作者介绍 成生辉博士现任西湖大学西湖学者，智能可视化实验室负责人。他于纽约州立大学石溪分校获得计算机科学博士学位，并在美国布鲁克海文国家实验室、哈佛医学院进行研究，曾任世界银行（总部）数字经济组顾问。他的主要研究对象为元宇宙、可视化、可视分析等。他曾任大数据高峰论坛执行主席，国际可视化年会、太平洋可视化大会、中国可视化大会等项目委员会委员。发表论文30多篇，专著6部，包括《元宇宙：概念、技术及生态》等，入选深圳和杭州市海外高层次人才，浙江省高校领军人才培养计划。
四、本书特色 AIGC，即生成式人工智能，正推动着人工智能掀开新的一页，以前所未有的速度崛起并席卷全球。无论是学术界还是产业界，都在积极布局AIGC领域，准备迎接一个新时代的到来。
在学术界，研究人员不断探索新的算法和技术，以改进 AIGC 的生成质量和效率。同时，各大高校也推出了相关的课程和研究项目，培养和支持 AIGC 领域的专业人才。
在产业界，许多公司和组织积极应用 AIGC 技术，以提高业务效率和产品质量。例如，新闻媒体、广告公司、内容创作平台等，都在使用 AIGC 技术生成各种类型的内容，以满足不同用户的需求。一些大型科技公司也在积极布局 AIGC 领域，推出各种与 AIGC 相关的工具和平台，以支持 AIGC 应用的开发和部署。
AIGC的发展还面临许多挑战和问题，例如算法可解释性、数据隐私保护等。因此，我们需要持续关注和研究AIGC，以便更好地挖掘它的潜力，同时避免其潜在的风险和影响。
本书理论结合实践，旨在帮助读者全面掌握 AIGC 的基础知识，为应对未来的技术挑战做好准备。让我们一起探索这个迅速发展的领域，发现其中的无限可能性！
五、抽奖方式 抽奖送书老规矩（不点赞收藏中奖无效）：注意记得关注博主及时获取中奖通知。
1. 点赞+收藏 文章 2. 评论区留言：我要成为架构师（留言才能进入奖池，每人最多留言三条） 3. 周日晚（2023年11月26日）八点随机抽奖3人 4. 京东自营购买链接：https://item.jd.com/13914487.html#none 总结 Hello，各位看官老爷们好，洲洲已经建立了CSDN技术交流群，如果你很感兴趣，可以私信我加入我的社群。
📝社群中不定时会有很多活动，例如每周都会包邮免费送一些技术书籍及精美礼品、学习资料分享、大厂面经分享、技术讨论、行业大佬创业杂谈等等。
📝社群方向很多，相关领域有Web全栈（前后端）、人工智能、机器学习、自媒体变现、前沿科技文章分享、论文精读等等。
📝不管你是多新手的小白，都欢迎你加入社群中讨论、聊天、分享，加速助力你成为下一个技术大佬！也随时欢迎您跟我沟通，一起交流，一起成长。变现、进步、技术、资料、项目、你想要的这里都会有
📝网络的风口只会越来越大，风浪越大，鱼越贵！欢迎您加入社群~一个人可以或许可以走的很快，但一群人将走的更远！
📝关注我的公众号（与CSDN同ID：程序员洲洲）可以获得一份Java 10万字面试宝典及相关资料！~
📝想都是问题，做都是答案！行动起来吧！欢迎评论区or后台与我沟通交流，也欢迎您点击下方的链接直接加入到我的交流社群！~ 跳转链接社区~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd1a0380349fe5351aba2a9d026f6ac/" rel="bookmark">
			【Redis篇】简述Redis | 详解Redis命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🎍什么是Redis🎍Redis特点🎍Redis应用场景🍔Windows安装Redis⭐启动Redis 🌺Redis数据类型🌺Redis常用命令⭐字符串string操作命令⭐哈希hash操作命令⭐列表list操作命令⭐集合set操作命令⭐有序集合sorted set 操作命令 🛸Redis常用命令 🎍什么是Redis Redis是一个基于内存的key-value结构数据库
🎍Redis特点 基于内存处理，读写性能高适合存储热点数据(热点商品，资讯，新闻)企业应用广泛 🎍Redis应用场景 缓存系统：Redis最基本的用法是作为缓存，用来缓存数据库查询的结果，减轻数据库的压力。用户在下一次请求相同数据时，可以直接从Redis获取，以此提高性能和响应速度。
会话缓存（Session Cache）：由于Redis非常适合构建缓存系统，所以在处理用户会话数据（如用户的详细信息，用户的状态等）时也非常有用。这种方式可以避免频繁的数据库操作，提高性能。
发布/订阅（Pub/Sub）消息系统：Redis支持发布/订阅模式，可以用作实时消息系统。例如在社交网络、实时分析、实时通知等场景下，Redis可以创建多个发布者和订阅者，实现消息的实时传输。
排行榜或计数器：Redis的Sorted Set可以存储权重和值，非常适用于实现排行榜。同时，Redis的incr/decr等操作可以方便地实现计数功能。
处理任务队列：Redis的List数据结构可以用于实现队列（Queue）来处理任务。例如，在网络服务中，大量的任务可以放入Redis，然后由多个工作线程进行处理。
实时分析：Redis具有高性能和灵活的数据结构，非常适合用来处理实时分析。例如，可以通过Redis记录网站的访问量、点击率等数据，进行实时的数据分析。
地理空间数据处理：Redis提供了一系列的地理空间数据处理功能，能够存储和操作地理空间数据，可以使用它来开发如地理位置搜索、移动应用中的位置服务等功能。
🍔Windows安装Redis Redis是一款绿色软件，解压压缩包，就相当于安装成功
安装包在下面的网盘链接中，需要的友友们请自取
我用夸克网盘分享了「Redis-x64-3.2.100.zip」，点击链接即可保存。 链接：https://pan.quark.cn/s/ad1748b37535
解压后
⭐启动Redis 双击Redis服务端
会弹出下面的界面，默认端口号是6379
这个时候我们的Redis就已经启动了
🌺Redis数据类型 🌺Redis常用命令 我们继续打开Redis客户端(不要关闭服务端)
⭐字符串string操作命令 ⭐哈希hash操作命令 ⭐列表list操作命令 ⭐集合set操作命令 ⭐有序集合sorted set 操作命令 🛸Redis常用命令 总结起来，Redis作为一种高性能内存数据库，已经成为众多应用程序和系统的首选解决方案。它不仅提供了基础的键值存储功能，还支持丰富的数据结构和功能，如哈希表、列表、集合和有序集合。通过将数据存储在内存中，Redis可以实现快速的读写操作，适用于高并发和低延迟的应用场景。
在本文中，我们深入探讨了Redis的核心概念，介绍了Java中操作Redis的方法，并展示了Redis在各种应用场景中的优势。无论是构建高性能的缓存系统、实现实时分析、构建消息队列还是处理大规模数据集，Redis都是一个强大而灵活的选择。
随着越来越多的开发人员和企业意识到Redis的价值，我们相信它将在未来继续发挥重要作用。希望本文能够为您提供有关Redis的深入了解，并激发您进一步探索和应用Redis的动力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6810132a69c5246221c96c210d2baf6/" rel="bookmark">
			AIGC系列之：ControlNet原理及论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Adding Conditional Control to Text-to-Image Diffusion Models》
目录
1.背景介绍
2.原理详解
2.1 Controlnet
2.2 用于Stable Diffusion的ControlNet
2.3 训练
2.4 推理
3.实验结果
3.1 定性结果
3.2 消融实验
3.3 和之前结果比较 3.4 数据集大小的影响
4.结论
1.背景介绍 Stable Diffusion大模型的开源，使得AI绘画的应用变得空前火热。虽然Stable Diffusion生成的图片质量远超以往的GAN，VAE等，但还达不到精细化可控生成的目的。文本到图像模型在控制图像的空间构图方面是有限的；仅仅通过文本提示很难精确地表达复杂的布局、姿势、形状和形式。ControlNet在Stable Diffusion的基础上加入了更多可控生成方式，在AI绘图大规模商用上成为可能。此外，ControlNet和SAM同时获得了ICCV2023的最佳论文。让我们一起来看一看它的魔力~
下面是ControlNet相关的一些资料，本文参考了几位博主的文章，已经在下面提供了链接。
论文链接：https://arxiv.org/pdf/2302.05543.pdf
代码地址：GitHub - lllyasviel/ControlNet: Let us control diffusion models!
GitHub - Mikubill/sd-webui-controlnet: WebUI extension for ControlNet
论文解读：https://zhuanlan.zhihu.com/p/664595339
ControlNet 是一种神经网络架构，旨在将空间条件控制添加到大型预训练的文本到图像扩散模型中。 ControlNet 将锁定生产就绪的大型扩散模型，并重用由数十亿图像预先训练的强大主干中的深层和鲁棒编码层，以学习多样化的条件控制集。神经架构通过“零卷积”（零初始化的卷积层）连接，使参数逐渐从零增长，并确保不会有有害噪声影响微调过程。使用Stable Diffusion测试各种条件控制例如边缘、深度、分割、人体姿态等，具有单个或多个条件，带有或不带有提示。 表明 ControlNet 的训练过程对于小型（&lt;50k）和大型（&gt;1m）数据集都具有很强的鲁棒性。大量的实验结果表明，ControlNet 有助于更广泛的应用于控制图像扩散模型。
通过让用户提供额外的图像来直接指定所需图像的组成，实现更精细的空间控制呢。这些额外的图像（例如边缘图、人体姿态骨架、分割图、深度、法线等）通常被视为对图像生成过程的条件约束。特定条件下的训练数据量显著小于可用于一般文本到图像训练的数据量。直接微调或继续训练具有有限数据的大型预训练模型可能会导致过拟合和灾难性遗忘。因此，通过限制可训练参数的数量或等级，可以缓解这种遗忘。
ControlNet 通过锁定大型预训练模型的参数并复制其编码层，保留了该大型模型的质量和能力。这种架构将大型预训练模型视为学习各种条件控制的强大主干网络。可训练的副本和原始锁定的模型通过零卷积层连接，权重初始化为零，以便在训练过程中逐渐增长。这种架构确保在训练开始时不会向大型扩散模型的深层特征添加有害噪声，并保护可训练副本中的大型预训练主干网络免受此类噪声的破坏。
ControlNet 是一种神经网络架构，旨在将空间条件控制添加到大型预训练的文本到图像扩散模型中。 ControlNet 将锁定生产就绪的大型扩散模型，并重用由数十亿图像预先训练的强大主干中的深层和鲁棒编码层，以学习多样化的条件控制集。神经架构通过“零卷积”（零初始化的卷积层）连接，使参数逐渐从零增长，并确保不会有有害噪声影响微调过程。使用Stable Diffusion测试各种条件控制例如边缘、深度、分割、人体姿态等，具有单个或多个条件，带有或不带有提示。 表明 ControlNet 的训练过程对于小型（&lt;50k）和大型（&gt;1m）数据集都具有很强的鲁棒性。大量的实验结果表明，ControlNet 有助于更广泛的应用于控制图像扩散模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6810132a69c5246221c96c210d2baf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372dff15ececf7cf56f207ddef796394/" rel="bookmark">
			whisper large-v3 模型文件下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#源码里找到的 _MODELS = { "tiny.en": "https://openaipublic.azureedge.net/main/whisper/models/d3dd57d32accea0b295c96e26691aa14d8822fac7d9d27d5dc00b4ca2826dd03/tiny.en.pt", "tiny": "https://openaipublic.azureedge.net/main/whisper/models/65147644a518d12f04e32d6f3b26facc3f8dd46e5390956a9424a650c0ce22b9/tiny.pt", "base.en": "https://openaipublic.azureedge.net/main/whisper/models/25a8566e1d0c1e2231d1c762132cd20e0f96a85d16145c3a00adf5d1ac670ead/base.en.pt", "base": "https://openaipublic.azureedge.net/main/whisper/models/ed3a0b6b1c0edf879ad9b11b1af5a0e6ab5db9205f891f668f8b0e6c6326e34e/base.pt", "small.en": "https://openaipublic.azureedge.net/main/whisper/models/f953ad0fd29cacd07d5a9eda5624af0f6bcf2258be67c92b79389873d91e0872/small.en.pt", "small": "https://openaipublic.azureedge.net/main/whisper/models/9ecf779972d90ba49c06d968637d720dd632c55bbf19d441fb42bf17a411e794/small.pt", "medium.en": "https://openaipublic.azureedge.net/main/whisper/models/d7440d1dc186f76616474e0ff0b3b6b879abc9d1a4926b7adfa41db2d497ab4f/medium.en.pt", "medium": "https://openaipublic.azureedge.net/main/whisper/models/345ae4da62f9b3d59415adc60127b97c714f32e89e936602e85993674d08dcb1/medium.pt", "large-v1": "https://openaipublic.azureedge.net/main/whisper/models/e4b87e7e0bf463eb8e6956e646f1e277e901512310def2c24bf0e11bd3c28e9a/large-v1.pt", "large-v2": "https://openaipublic.azureedge.net/main/whisper/models/81f7c96c852ee8fc832187b0132e569d6c3065a3252ed18e56effd0b6a73e524/large-v2.pt", "large-v3": "https://openaipublic.azureedge.net/main/whisper/models/e5b1a55b89c1367dacf97e3e19bfd829a01529dbfdeefa8caeb59b3f1b81dadb/large-v3.pt", "large": "https://openaipublic.azureedge.net/main/whisper/models/e5b1a55b89c1367dacf97e3e19bfd829a01529dbfdeefa8caeb59b3f1b81dadb/large-v3.pt", } 加速下载
apt install aria2
aria2c -x 16 https://openaipublic.azureedge.net/main/whisper/models/e5b1a55b89c1367dacf97e3e19bfd829a01529dbfdeefa8caeb59b3f1b81dadb/large-v3.pt --all-proxy=http://host.docker.internal:7890
我这是在容器里用代理，代理选项可去除
这是gpt4给我的代码：
我想写一个python程序，在我发出“过”的语音时，打印“过”（实际上是执行某种操作，我会将它嵌入到其他程序中，目前只打印字符串），在我发出“下一个”的语音时，打印“下一个”，我想使用https://huggingface.co/openai/whisper-large-v3实现
import whisper import sounddevice as sd import numpy as np # 录音设置 duration = 5 # 录音时长（秒） samplerate = 16000 # 采样率 def record_audio(duration, samplerate): """录制音频""" recording = sd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/372dff15ececf7cf56f207ddef796394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14b4141139abc1fa8a74560c2ba0fe34/" rel="bookmark">
			java通过url下载图片保存到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每天一个小方法 import java.io.BufferedInputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; public class DownloadPicture { public static void main(String[] args) { String imageUrl = "https://example.com/path/to/image.jpg"; String savePath = "path/to/save/image.jpg"; try { downloadPicture(imageUrl, savePath); } catch (IOException e) { e.printStackTrace(); } } public static void downloadPicture(String imageUrl, String savePath) throws IOException { URL url = new URL(imageUrl); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.connect(); int responseCode = connection.getResponseCode(); if (responseCode == HttpURLConnection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14b4141139abc1fa8a74560c2ba0fe34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703d51d2e8483c6cb6990e43a9e011fa/" rel="bookmark">
			力扣每日一道系列 --- LeetCode 88. 合并两个有序数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📷 江池俊： 个人主页 🔥个人专栏： ✅数据结构探索 ✅LeetCode每日一道 🌅 有航道的人，再渺小也不会迷途。 文章目录 思路1：暴力求解思路2：原地合并 LeetCode 88. 合并两个有序数组
思路1：暴力求解 首先创建一个临时数组，其大小为第一个数组的大小（即nums1Size），其作用主要是。通过循环遍历两个数组，将两个数组元素比较后较小的元素依次加入到临时数组中，直到有一个数组遍历完即可（注意：这里遍历完是只有效元素被遍历完，因为nums1中有无效元素0）。将未遍历完的数组剩下的元素依次加入到临时数组中。将临时数组中的元素依次拷贝到nums1数组中。释放临时数组的空间。
时间复杂度：O(m+n)
空间复杂度：O(m+n) 值得注意的是： 这里需要考略到两种特殊情况需要单独处理
nums2 数组为空时，nums1 数组就是两个数组排序后的结果，函数不需要执行任何操作，直接 return 即可nums1 数组中有效的元素个数为 0（即 m = 0 ） 时，此时 nums2 数组中的元素就是两个数组排序后的结果，此时只需要将 nums2 中的数组元素拷贝到 nums1 数组即可。 void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){ if(nums2==NULL) { return; } else if(m==0) { for(int i=0;i&lt;nums1Size;i++) { nums1[i]=nums2[i]; } } //创建一个数组来临时存放排序之后的元素，元素个数为m+n = nums1Size int *arr = (int*)malloc((nums1Size)*sizeof(int)); int index = 0,dest = 0,src = 0; //dest和src分别标记访问当前数组元素的下标 //index标记临时数组加入元素的下标位置 //依次遍历两个数组，直到有一个数组遍历完为止 while(dest &lt; m &amp;&amp; src &lt; n) { if(nums1[dest]&lt;=nums2[src]) { arr[index++] = nums1[dest++]; } else { arr[index++] = nums2[src++]; } } //将未遍历完的数组剩下的元素加入到临时数组中 if(src&gt;=n) { while(dest&lt;m) { arr[index++] = nums1[dest++]; } } else if(dest&gt;=m) { while(src&lt;n) { arr[index++] = nums2[src++]; } } //将临时数组中的元素依次赋值给nums1数组中对应位置的元素 for(int i = 0;i&lt;nums1Size;i++) { nums1[i] = arr[i]; } free(arr);//将创建的数组空间释放 } 思路2：原地合并 从后往前遍历数组，将 nums1 和 nums2 中的元素逐个比较，将较大的元素往 nums1 末尾进行搬移第一步结束后，nums2 中可能会有数据没有搬移完，将 nums2 中剩余的元素逐个搬移到 nums1如果 num1 中剩余元素没有搬移完，就不需要进行任何操作，因为 num1 中剩余的元素本来就在 num1 中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/703d51d2e8483c6cb6990e43a9e011fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a578a4a007d81f199e60c9622e928ae7/" rel="bookmark">
			力扣每日一道系列 --- LeetCode 138. 随机链表的复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📷 江池俊： 个人主页 🔥个人专栏： ✅数据结构探索 ✅LeetCode每日一道 🌅 有航道的人，再渺小也不会迷途。 LeetCode 138. 随机链表的复制
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。
返回复制链表的头节点。
用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
val：一个表示 Node.val 的整数。random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。
迭代 + 节点拆分 思路及算法:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a578a4a007d81f199e60c9622e928ae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac8860a2bbf026eb01c7201e6a631c82/" rel="bookmark">
			MySQL的IF语句详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库中，IF语句是一种条件控制语句，用于根据某些条件的真假来执行不同的代码逻辑。IF语句可以帮助我们在SQL查询中实现更复杂的逻辑操作。
1、IF语句的基本用法
IF(condition, true_statement, false_statement);
condition: 条件表达式，可以是任何返回布尔值的表达式。
true_statement: 如果条件为真，则执行的语句。
false_statement: 如果条件为假，则执行的语句。
在普通的查询中，如果需要根据查询的值做代码的转化：
SELECT id, name, score, IF(score &gt;= 90, 'A', IF(score &gt;= 80, 'B', 'C')) AS grade FROM students; 2、IF语句的进阶用法
除了基本的IF语句外，MySQL还提供了一些其他用于处理条件逻辑的语句和函数，例如：CASE语句、IFNULL函数等。下面我们将介绍一些常见的进阶用法。
CASE语句
CASE expression WHEN value1 THEN result1 WHEN value2 THEN result2 ... ELSE result END; expression: 表达式，用于进行比较的值。
WHEN value THEN result: 当expression等于value时，返回result。
ELSE result: 如果没有匹配的条件，则返回result。
SELECT id, name, price, CASE WHEN price &gt; 1000 THEN '高价' WHEN price &gt; 500 THEN '中价' ELSE '低价' END AS price_range FROM products; IFNULL函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac8860a2bbf026eb01c7201e6a631c82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36eb0c25402afbee57b044738d7119f/" rel="bookmark">
			最新版Android studio没有layout文件解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在最新版的Android studio中，创建一个空的活动发生了变化，旧版中可以直接选择empty activity,如 但在新版，empty activity的图标发生了变化
而在最新版的empty activity上我们创建项目后是没有layout文件的，下面的empty views activity才和旧版的empty activity相同。
这表明官方推荐使用Compose这种声明式的编程方式来描述UI，命令式的View即将成为过去式
2.layout文件夹创建。
由于缺少布局文件，所以我们要在app文件夹中创建一个layout文件。
首先我们在project项目中的new文件上右键，点击new，然后创建一个Android resource file,接下来会有一个弹窗，在其中可以命名文件并选择文件类型
注意：默认类型并不是layout，请仔细查看。
在点击ok创建完成后，layout文件及其布局代码便自动生成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed0b137301166a25d3efd41c0508a09/" rel="bookmark">
			【数据结构与算法】Kadane‘s算法（动态规划、最大子数组和）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、算法原理二、例题2.1 最大子数组和2.2 环形子数组的最大和 一、算法原理 Kadane's算法是一种用于解决最大子数组和问题的动态规划算法。这类问题的目标是在给定整数数组中找到一个连续的子数组，使其元素之和最大（数组含有负数）。
算法的核心思想是通过迭代数组的每个元素，维护两个变量来跟踪局部最优解和全局最优解。
以下是Kadane’s算法的详细步骤：
初始化：
令 maxEndingHere 表示在当前位置结束的最大子数组和，初始值为数组的第一个元素。令 maxSoFar 表示全局最大子数组和，初始值也为数组的第一个元素。 迭代：
从数组的第二个元素开始迭代。
对于每个元素，计算在当前位置结束的最大子数组和：
maxEndingHere = max(nums[i], maxEndingHere + nums[i]);
这表示要么继续当前子数组，要么从当前位置开始一个新的子数组。
更新全局最大子数组和：
maxSoFar = max(maxSoFar, maxEndingHere);
如果在当前位置结束的子数组和大于全局最大和，更新全局最大和。
返回结果：
当迭代完成后，maxSoFar 中存储的即为最大子数组和。 复杂度：
时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。空间复杂度：O(1)。我们只需要常数空间存放若干变量。 图例：
简要说明：（如过当前值比前面的局部最大值+当前值还大，那么就从当前值开始继续计算局部最大值）
i=0,maxEndingHere 、maxSoFar 初始值都为数组第一个元素，-2；开始循环，i=1，maxEndingHere = max(nums[1], maxEndingHere + nums[1])，即maxEndingHere = max(1, -2 + 1)=1，maxSoFar=1；i=2， maxEndingHere = max(nums[2], maxEndingHere + nums[2])，即maxEndingHere = max(-3, 1 - 3)=-2，maxSoFar=1；i=3，maxEndingHere = max(nums[3], maxEndingHere + nums[3])，即maxEndingHere = max(4, -2 + 4)=4，maxSoFar=4；… 二、例题 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed0b137301166a25d3efd41c0508a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b696f8029228dcc48842ecc18c9c5c/" rel="bookmark">
			2023全网最详细的银河麒麟操作系统,Java运行环境【jdk】安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📚📚 🏅我是默，一个在CSDN分享笔记的博主。📚📚 ​​
🌟在这里，我要推荐给大家我的专栏《Linux》。🎯🎯
🚀无论你是编程小白，还是有一定基础的程序员，这个专栏都能满足你的需求。我会用最简单易懂的语言，带你走进代码的世界，让你从零开始，一步步成为编程大师。🚀🏆
🌈让我们在代码的世界里畅游吧！🌈
🎁如果感觉还不错的话请记得给我点赞哦！🎁🎁
💖期待你的加入，一起学习，一起进步💖💖
目录
一.安装jdk 1.下载jdk
2.安装 2.1.将安装包加载进入银河麒麟中
2.2通过终端进行安装
授权
创建文件夹解压文件
查看解压包路径修改环境变量
测试jdk环境
一.安装jdk 1.下载jdk 下载小编就不多说了，可以陈查看小编以前的博客
下载jdk就看这一篇https://blog.csdn.net/lz17267861157/article/details/130635442
2.安装 2.1.将安装包加载进入银河麒麟中 2.2通过终端进行安装 授权 首页通过 输入以下指令，让当前用户有root权限
su 创建文件夹解压文件 然后创建文件夹用于压缩包的解压
mkdir java
在通过指定的质量进行解压
tar -zxvf jdk-8u151-linux-x64.tar.gz 查看解压包路径修改环境变量 解压后通过 cd 解压包 进入到解压的包中查看解压包的路径
然后在修改环境变量
vim /etc/profile 在指定的地方添加环境变量配置代码
环境变量代码如下
#java environment
export JAVA_HOME=/home/zx/sofware/jdk1.8.0_151
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
在其中JAVA_HOME后面的路径就是前面需要copy的路径
测试jdk环境 然后在设置环境变量生效，在测试即可
source /etc/profile
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d555404b4b1c358a7ee0775bda2787b/" rel="bookmark">
			Android Termux安装MySQL，内网穿透实现公网远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.安装MariaDB2.安装cpolar内网穿透工具3. 创建安全隧道映射mysql4. 公网远程连接5. 固定远程连接地址 前言 Android作为移动设备，尽管最初并非设计为服务器，但是随着技术的进步我们可以将Android配置为生产力工具，变成一个随身Linux。
MariaDB是MySQL关系数据库管理系统的一个复刻，由社区开发，有商业支持，旨在继续保持在 GNU GPL 下开源。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。
接下来我们通过简单几步操作，在安卓手机termux上安装MariaDB(mysql) 数据库，并结合cpolar内网穿透，来实现公网环境下的远程连接访问。
1.安装MariaDB Termux 官方也封装了 MariaDB，所以安装起来很方便：
pkg install mariadb 验证是否安装成功,查看一下版本信息
mysql --version 出现版本信息表示安装成功
启动数据库,使用 Linux 自带的 nohup 命令将其放到后台启动
nohup mysqld &amp; 启动后可以看到进程PID号
如果想要关闭mysql,可以执行:
kill -9 PID 2.安装cpolar内网穿透工具 在Android termux上成功安装MySQL数据库后，我们继续在termux上安装cpolar，做内网穿透创建安全隧道将MySQL暴露到公网上，实现在不同网络下也可以远程连接termux上的MySQL数据库。
cpolar使用不需要公网IP，也不用设置路由器，亦不需要买云服务器。它支持http/https/tcp协议，可以免费使用也不限制流量。
cpolar官网：https://www.cpolar.com/
创建一个sources.list.d的文件夹:
mkdir -p $PREFIX/etc/apt/sources.list.d 添加cpolar下载源文件
echo "deb [trusted=yes] http://termux.cpolar.com termux extras" &gt;&gt; $PREFIX/etc/apt/sources.list.d/cpolar.list 更新仓库
pkg update 安装cpolar
pkg install cpolar 安装termux服务,注意: 安装完成后记得关闭重启一下termux 才生效!!
pkg install termux-services 重启完termux后,然后启动cpolar内网穿透
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d555404b4b1c358a7ee0775bda2787b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6512b59c418a34aea51ce113de32d38/" rel="bookmark">
			【MySQL】细谈SQL高级查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言 &amp; 准备工作二、简易高级查询⚙ 准备工作1、查询每一门课程及其先修课程2、查询和“刘涛”在一个班级的学生的信息3、查询选修了‘计算机基础’课的学生的学号、姓名③ 连接方式④ 子查询嵌套方式 4、查询没有选修课程的学生的信息① 子查询in方式② 子查询exists方式 5、查询每个学生超过该门课程平均成绩的学号, 课号6、查询既选修了“计算机基础”又选修了“C语言基础”的学生的学号① 自连接② 求交集③ 子查询 三、复杂高级查询⚙ 准备工作1、查询选修了全部课程的学生号码2、查询被全部学生选修的课程号码3、查询至少选修了学号是2号的学生所选修的全部课程的学生号码【⭐】Way1：exists表双重否定Way2：优先筛选group统计Way3：最牛的简易除法🐂 四、SQL数据展示（自取）五、总结与提炼 一、前言 &amp; 准备工作 Hello大家好，本文要为大家带来的是有关SQL的高级查询，在上一文学习了一些 基础语法 后，我们应该更进一步地去学习一些复杂性的SQL查询语句，提升自己写SQL的能力💪
二、简易高级查询 ⚙ 准备工作 在做高级查询之前，我们先来做一些准备工作
我们来新建一个教学管理jxgl数据库 create database jxgl; 然后为了简易起见，就不创建教师表了，主要涉及以下的三个表，SQL语句供读者使用： -- Table: Course CREATE TABLE Course ( cno char(7) NOT NULL, cname char(40) NULL, cpno char(7) NULL, ccredit smallint NULL, PRIMARY KEY ( cno )	); -- Table: Student CREATE TABLE Student ( sno char(7) NOT NULL, sname char(8) NOT NULL, class char(20) NULL, ssex char(2) NULL, bday datetime NULL, bplace char(10) NULL, mgrade smallint NULL, photo char(50) NULL, sfzh char(18) NULL, zxf smallint NULL, PRIMARY KEY ( sno ) ) ; -- Table: SC CREATE TABLE SC ( term smallint NOT NULL, sno char(7) NOT NULL , cno char(7) NOT NULL , grade smallint NULL, point decimal(2, 1) NULL, PRIMARY KEY (term,sno,cno), FOREIGN KEY (sno) REFERENCES Student (sno), FOREIGN KEY (cno) REFERENCES Course (cno) ON UPDATE CASCADE ); ⇒ 然后我们还需要再去插入一些数据（具体见文末的整体SQL代码）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6512b59c418a34aea51ce113de32d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091be55d8c5fe4b0c525babe0f751d4d/" rel="bookmark">
			【cpolar】搭建我的世界Java版服务器，公网远程联机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥 个人主页：深鱼~🔥收录专栏：cpolar🌄欢迎 👍点赞✍评论⭐收藏 目录
前言：
1. 搭建我的世界服务器
1.1 服务器安装java环境
1.2 配置服务端
2. 测试局域网联机
3. 公网远程联机
3.1 安装cpolar内网穿透
3.1.1 windows系统
3.1.2 linux系统（支持一键自动安装脚本）
3.2 创建隧道映射内网端口
3.3 测试公网远程联机
4. 配置固定TCP端口地址
4.1 保留一个固定tcp地址
4.2 配置固定tcp地址
前言： 本次教程将在windows本地搭建java版的MC服务器，并用cpolar内网穿透突破局域网限制，实现在公网环境下跟小伙伴远程联机，超简单配置，无需公网IP，也不用设置路由器。
如果你的服务器已经搭建成功，并可以正常在局域网内联机，可以直接跳到第三步，在本地配置cpolar内网穿透，创建隧道映射25565端口，实现异地远程联机。
1. 搭建我的世界服务器 以windows10系统为例，配置java环境，搭建服务器。
1.1 服务器安装java环境 下载java17
Java Downloads | Oracle
选择exe文件，下载完成后双击安装包一路默认安装即可。
java安装完成后，打开文件夹，找到java，将jdk安装路径复制下来，本例中为C:\Program Files\Java\jdk-17.0.5、
在开始菜单栏搜索高级系统设置并打开系统属性，点击环境变量
点击新建一个系统环境变量
变量名：JAVA_HOME变量值：JDK的安装路径，本例中为C:\Program Files\Java\jdk-17.0.5 在系统变量列表中，双击Path变量
点击右侧的新建，在变量名值前面加%JAVA_HOME%\bin，点击确认
校验是否成功：开始菜单栏搜索cmd，打开命令提示符，输入javac，出现以下内容则说明配置成功。
1.2 配置服务端 下载MC服务端，最新版的服务器端可以官网下载
Download server for Minecraft | Minecraft
下载完成后，在文件所在的文件夹新建一个文本文档
然后打开这个文本文档输入以下信息
java -Xms1G -Xmx2G -jar server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091be55d8c5fe4b0c525babe0f751d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af09d3ad8d7eacfcc504ea08eb60c49b/" rel="bookmark">
			语音识别神器 Whisper 的几个小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 OpenAI开源的免费离线语音识别神器Whisper，我在安装使用后发现一些问题，于是搜了半天最终汇总了这几个主要的小技巧，希望对大家有帮助，不用满世界再搜了。
我主要用于中文的识别，所以就只说中文相关的了，我的环境是：
系统：Ubuntu22.04Python:3.9.9(conda) 具体怎么正常使用或者怎么安装，官方MD很详细了，不行再搜搜也就有了，我就没记录。
官方github：GitHub - openai/whisper: Robust Speech Recognition via Large-Scale Weak Supervision
2、模型选哪个 whisper提供了5个模型，见下表：
每个模型具体要求都在表里了，我试过前4个，对于中文识别，我的体会是，必须得medium，前3个中文识别有点差。medium足够用，虽然也会有错误的情况，但不多了。我推测large肯定会更上一层楼，然而large有点大且显存占得大就没下载。
所以，medium性价比最高。
3、whisper 加标点符号的问题 我使用时，发现输出的文件里中文完全没有标点符号哎，这可咋整 ，找了半天程序里也没这参数啊。不断大海捞针地搜了搜，发现有篇文章写了个方法说要通过prompt，告诉程序个例子。于是通过测试，总结了一个成功的方法是这样的：
运行时加这个参数 initial_prompt，它的值要写上对当前识别音频的内容总结（自己提前知道），最后还要加上句号，效果最佳。比如我要识别一段会议的录音，所以这个参数就这么写：
initial_prompt = "这是一段会议记录。"
哦对了，我是在程序里调接口用，如果用命令号，就直接加 --initial_prompt "这是一段会议记录。" （应该是这么写，不对的话再调整调整格式）
于是标点符号的问题解决了。
4、whisper 中文简体繁体字的问题 标点符号问题解决了，结果有时候识别出来的内容突然有一段变成了繁体字，于是又开始一顿搜寻，最终解决方法还是要在initial_prompt里给出例子。
就是要在prompt里加上这句：“以下是普通话的句子。”，注意，这里要全部用简体中文写，程序就造了。
所以如果想输出繁体字，那这句话就用繁体写：“以下是普通話的句子。”
5、总结 综述所述，最后就固定一个prompt的写法，就能解决这俩问题。
initial_prompt = "以下是普通话的句子，这是一段会议记录。"
如果想输出繁体字，上面内容就全用繁体字写。 后半句写语音的内容概括，并且一定要加上句号。 祝大家成功！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/564/">«</a>
	<span class="pagination__item pagination__item--current">565/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/566/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>