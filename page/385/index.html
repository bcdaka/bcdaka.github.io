<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93480f62c9690e34f688476dff95894/" rel="bookmark">
			Java--方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1什么是方法 方法顾名思义就是解决问题的办法，在程序员写代码的时候，会遇到很多逻辑结构一样，解决相同问题时，每次都写一样的代码，这会使代码看起来比较绒余，代码量也比较多，为了解决这个问题，我们把代码逻辑相同的代码写成一个方法，当我们解决相同问题时，直接调用这个方法，这会使代码看起来简洁明了。
方法：在Java中就是一个代码片段，与C语言中的函数类似。
方法存在的意义:
1. 是能够模块化的组织代码(当代码规模比较复杂的时候 ).
2. 做到代码被重复使用, 一份代码可以在多个位置使用.
3. 让代码更好理解更简单.
4. 直接调用现有方法开发, 不必重复造轮子.
举个列子：当我们需要求一个数的阶乘时
public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int x= scanner.nextInt(); for (int i = x-1; i &gt;=1 ; i--) { x*=i; } System.out.println(x); } 你可能会写出这样的代码，是不是看见循环就烦，当我们学会方法就会写出下面这种简洁的代码
public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int x= scanner.nextInt(); System.out.println(fac1(x)); } 是不是看着简洁多了
2.方法的基本格式 // 方法定义 public static 方法返回值 方法名称（[参数类型 形参 ...]){ 方法体代码; [return 返回值]; } // 方法调用 返回值变量 = 方法名称(实参.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c93480f62c9690e34f688476dff95894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db865fca4001fcf13d4ad75809810c0/" rel="bookmark">
			【Hadoop】--基于hadoop和hive实现聊天数据统计分析，构建聊天数据分析报表[17]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、需求分析
1、背景介绍
2、目标
3、需求
4、数据内容
5、建库建表
二、ETL数据清洗
1、数据问题
2、需求
3、实现
4、扩展概念：ETL
三、指标计算
1、指标1：统计今日消息总量
2、指标2：统计每小时消息量、发送量和接收用户数
3、指标3：统计今日各地区发送消息总量
4、指标4：统计今日发送和接收用户人数
5、指标5：统计发送消息条数最多的top10用户
6、指标6：统计接收消息条数最多的top10用户
7、指标7：统计发送人的手机型号分布情况
8、指标8：统计发送人的设备操作系统分布情况
四、可视化展示
1、BI概述
2、可视化展示
2.1、step1：创建报表
2.2、step2：选择仪表板样式
2.3、step3：添加标题
2.4、step4：编辑标题文本框（注意字体大小、居中、文本框位置可调整）
2.5、step5：添加文本内容
2.6、step6：添加地图
2.7、step7：添加雷达图
2.8、step8：添加柱状图
2.9、step9：添加环饼状图
2.10、step10：添加词汇云图
2.11、step11：添加趋势曲线图
2.12、step12：报表预览
一、需求分析 1、背景介绍 聊天平台每天都会有大量的用户在线，会出现大量的聊天数据，通过对聊天数据的统计分析，可以更好的对用户构建精准的用户画像，为用户提供更好的服务以及实现高ROI的平台运营推广，给公司的发展决策提供精确的数据支撑。 我们将基于一个社交平台App的用户数据，完成相关指标的统计分析并结合BI工具对指标进行可视化展现。
2、目标 基于hadoop和hive实现聊天数据统计分析，构建聊天数据分析报表。
3、需求 统计今日总消息量统计今日每小时消息量、发送和接收用户数统计今日各地区发送消息数据量统计今日发送消息和接收消息的用户数统计今日发送消息最多的Top10用户统计今日接收消息最多的Top10用户统计发送人的手机型号分布情况统计发送人的设备操作系统分布情况 4、数据内容 数据大小：30万条数据列分隔符：Hive默认分隔符’\001’数据字典及样例数据 5、建库建表 create table db_msg.tb_msg_source( msg_time string comment "消息发送时间", sender_name string comment "发送人昵称", sender_account string comment "发送人账号", sender_sex string comment "发送人性别", sender_ip string comment "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db865fca4001fcf13d4ad75809810c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765dacd3dc5420e76514b50321159c72/" rel="bookmark">
			Java中字符串替换的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java编程中，字符串的替换操作是非常常见的，尤其是当我们需要处理文本数据时。本文将介绍Java中实现字符串替换的四种常用方法，并通过代码示例来展示每种方法的用法。
1. 使用String类的replace()方法 String类提供了一个replace()方法，可以直接替换字符串中的字符或字符序列。
String original = "Hello World!"; String replaced = original.replace("World", "Java"); System.out.println(replaced); // 输出: Hello Java! 使用场景：当需要替换字符串中的某个特定字符或字符序列时，且不需要考虑正则表达式的复杂匹配。
优点：
简单易用，代码直观。直接在String对象上操作，无需创建额外对象。 缺点：
返回的是新的String对象，原字符串不变（String对象是不可变的）。不支持正则表达式的替换。 2. 使用String类的replaceAll()和replaceFirst()方法 这两个方法都可以用来替换匹配正则表达式的子字符串。replaceAll()替换所有匹配的子字符串，而replaceFirst()只替换第一次匹配的子字符串。
String text = "Java is great. Java is also fun."; String resultAll = text.replaceAll("Java", "Kotlin"); String resultFirst = text.replaceFirst("Java", "Kotlin"); System.out.println(resultAll); // 输出: Kotlin is great. Kotlin is also fun. System.out.println(resultFirst); // 输出: Kotlin is great. Java is also fun. 使用场景：当需要根据正则表达式进行替换时，replaceAll()适合替换所有匹配项，而replaceFirst()适合替换首次匹配项。
优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/765dacd3dc5420e76514b50321159c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac0f083485d16f192ccea2208fca7a2/" rel="bookmark">
			几个好用的AI网站（视频/图片/论文/PPT生成）直接给链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入 随着人工智能技术的飞速发展，越来越多的AI创作工具开始涌现，它们不仅能够帮助我们提升写作效率，更能激发创作灵感。今天，就让我们一起来探索十个值得一试的AI网站，它们分别是sora、mused.org、英伟达本地AI、瑞达写作、度加创作工具、天工AI、Dreamina、krea、讯飞智文和TME Studio。
涵盖视频/图片/论文/PPT生成等等内容！！
AI赋能创作 一、sora sorahttps://openai.com/sora
界面完全由sora生成 sora是OpenAI推出的强大的视频生成模型，支持文本描述生成视频，最长可生成1分钟的视频。不得不说发展很快，前两个月还只能生成几秒的视频。
网站研究报告原话这样说：“在可变持续时间、分辨率和纵横比的视频和图像上联合训练文本条件扩散模型。我们利用一种 transformer 架构，该架构在视频和图像潜在代码的时空补丁上运行。我们最大的型号 Sora 能够生成一分钟的高保真视频。我们的结果表明，扩展视频生成模型是构建物理世界通用模拟器的一条有前途的途径。”
不同计算倍数下的生成结果 二、mused.org musedhttps://mused.org
mused.org是一个专注于支持游览世界名胜古迹的AI，可以利用导游模式一步步探索古迹。全方位无死角，还可以查看3D视图和平面图等。
三、天工AI 天工AIhttps://search.tiangong.cn/
天工AI是一个综合性的AI服务平台，它提供了包括写作在内的多种AI应用。天工AI的写作功能可以根据用户的需求生成各种类型的文章，还支持多语言翻译和校对功能，为你的写作提供全方位的支持。定位标签是AI搜索引擎，与bing的搜索相似，在生成答案是还会标注参考链接和进行追问。还可开启个性化搜索，还可上传文档或链接进行内容分析！甚至可以根据图片进行搜索来源和内容。
四、度加创作工具 度加https://aigc.baidu.com/home
度加创作工具是百度推出的一款AI写作助手，它结合了百度强大的搜索技术和自然语言处理技术，为用户提供智能的写作建议和灵感。无论是写作新手还是专业人士，度加创作工具都能帮助你提升写作水平和效率。主要特点是描述成片，还有一个戏称名号AI成片“营销号生成器”，一些文案与视觉相结合的视频可以根据这个生成。
五、讯飞智文 讯飞智文https://zhiwen.xfyun.cn/home
讯飞智文是科大讯飞推出的一款智能写作工具，定位标签是免费的PPT生成网站，也可word写作辅助，可选择4种生成方式。十分良心，可以直接在线编辑，完成后可直接点击右上角导出保存到本地。
六、Dreamina Dreaminahttps://www.capcut.cn/ai-tool/platform?ref=ai-bot.cn
Dreamina是一款字节跳动公司上线的AI图像生成网站，支持同风格生成，图像细化、扩图等操作，点击即可下载图片，完全免费。每日可以领取积分。
七、krea Kreahttps://www.krea.ai/home
krea是一个面向创意产业的AI平台，它提供了包括写作在内的多种创意工具。krea的写作功能可以帮助用户快速生成创意文案，还支持与其他创意工具的无缝衔接，让你的创意想法得以快速实现。定位标签是AI图片实时生成，根据描述词的变化实时改变图像，还可选择风格。甚至可以上传图片、描绘线条等形式生成图像，甚至可以打开摄像头根据拍摄到的内容进行图像实时改变。
八、英伟达本地AI 英伟达本地AIhttps://www.nvidia.cn/ai-on-rtx/chat-with-rtx-generative-ai/
英伟达本地AI是英伟达公司推出的一款基于RTX显卡的生成式AI工具，它可以在定位标签是可以在电脑本地进行高效的AI计算，为用户提供实时的写作辅助。还支持对本地的文件进行管理，还可分析部分视频内容等等。
这款工具不仅支持多种语言，还能根据用户的写作风格进行个性化推荐。但对配置有一定要求，安装前一定要调查清楚。
九、瑞达写作 瑞达写作https://www.ipapers.net/
瑞达写作是一款集内容创作、管理、分发于一体的AI写作平台，它可以帮助用户快速生成高质量的内容，并自动优化发布渠道。无论是自媒体人还是企业营销人员，瑞达写作都能帮助你轻松应对内容创作的挑战。最重要的生成论文论文！（价格相对合适）
十、TME Studio TMEhttps://y.qq.com/tme_studio/index.html
TME Studio是腾讯音乐娱乐集团推出的一款AI音乐创作工具，它可以帮助用户快速生成个性化的音乐作品。虽然TME Studio主要面向音乐创作领域，但其背后的AI技术同样可以为写作提供灵感和辅助。
定位标签是音频/音乐处理，支持人声、伴奏、甚至乐器的分离，分离后可直接导出，不用再被小网站小工具割韭菜了！！除此之外还可智能生成曲谱，上传音乐即可生成适合吉他、钢琴等乐器演奏的曲谱，是音乐爱好者或创作者的天堂！！尤其自己剪辑也会用到一些人声的分离！！
感谢您花时间浏览这篇关于AI写作工具的博客。在这个信息爆炸的时代，能够找到一份有价值的资源实属不易。如果您觉得这篇文章对您有帮助，或者对其中提到的某个网站产生了兴趣，不妨轻轻一点，给它点个赞，或者将它收藏起来，以便日后随时查阅。
同时，也欢迎您在评论区留下您的宝贵意见和看法，让我们一起交流学习，共同进步。再次感谢您的阅读和支持，期待与您下次再见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31d1a08fc9880bb156395213b63ce5e/" rel="bookmark">
			【AIGC】本地部署 ollama &#43; open-webui
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的篇章《【AIGC】本地部署 ollama(gguf) 与项目整合》中我们已经使用 ollama 部署了一个基于预量化（gguf）的 Qwen1.5 模型，这个模型除了提供研发使用外，我还想提供给公司内部使用，因此还需要一个 ui 交互界面。
显然，这对于我们开发人员来说不是什么难事（毕竟 ollama 已经提供了相对比较完善的 API 接口了），但都 2024 年了与其自己开发还不如先找个开箱即用的…你看，这不已经有大神开发出 open-webui 了吗，我们开箱即用即可。
本文将记录部署过程中遇到的问题以及解决方式，希望对你有所帮助（open-webui 采用 docker 进行部署）。
1. 无法访问 huggingface 官网问题 由于 open-webui 有提供模型下载功能，因此需要在 docker 启动命令中添加 HF_ENDPOINT 环境变量：
sudo docker run -d \ ... -e HF_ENDPOINT=https://hf-mirror.com \ ... ghcr.io/open-webui/open-webui:main HF_ENDPOINT 将指向国内 hf-mirror 镜像站。
2. docker host 模式（ollama 宿主机直接部署的话） open-webui 容器采用 host 模式是最方便的的做法。由于我的 ollama 是宿主机直接部署的，open-webui 容器host 模式能够直接通过 127.0.0.1 进行通讯。如果你的 ollama 是 docker 容器，那么你可以将 open-webui 部署在与 ollama 同一个网络中，然后通过桥接只公开 open-webui 访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c31d1a08fc9880bb156395213b63ce5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417c53ea3738e4b6d3c3485329f30393/" rel="bookmark">
			大数据ELK（二）：Elasticsearch简单介绍_elk是什么时候开始流行的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍 Elasticsearch是一个基于Lucene的搜索服务器、提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。 2、创始人 Shay Banon （谢巴农）
二、Elasticsearch可以做什么 1、信息检索 电商 / 门户 / 论坛
2、企业内部系统搜索 关系型数据库使用like进行模糊检索，会导致索引失效，效率低下可以基于Elasticsearch来进行检索，效率杠杠的 OA / CRM / ERP
3、数据分析引擎 Elasticsearch 聚合可以对数十亿行日志数据进行聚合分析，探索数据的趋势和规律。
三、Elasticsearch特点 1、海量数据处理 大型分布式集群（数百台规模服务器）处理PB级数据小公司也可以进行单机部署 2、开箱即用 简单易用，操作非常简单快速部署生产环境 3、作为传统数据库的补充 传统关系型数据库排名、海量数据存储、分析等功能Elasticsearch可以作为传统关系数据库的补充，提供RDBM无法提供的功能 四、哪些公司在使用Elasticsearch 京东携程去哪儿58同城滴滴今日头条小米哔哩哔哩联想思科Airbusebay暴雪德国大众微软SymantecFacebookBBC英伟达UberIBMGithubDocker 五、ElasticSearch使用案例 2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”维基百科：启动以elasticsearch为基础的核心搜索架构SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据新浪使用ES 分析处理32亿条实时日志阿里使用ES 构建挖财自己的日志采集和分析体系 六、ElasticSearch对比Solr Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch 既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
需要这份系统化资料的朋友，可以戳这里获取
点，真正体系化！**
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
需要这份系统化资料的朋友，可以戳这里获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23dc207695389dc0950cf20679a6006b/" rel="bookmark">
			给所有开发者的React Native详细入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照RN中文社区的指导就可以了。不过过程中会遇到一些坑，我也附上我的踩坑记录。我建议大家可以先看一下踩坑记录，然后再开始安装环境。
2.1） 环境搭建踩坑指南:《一起学》安卓 React Native 开发–踩坑大全（持续更新…）
2.2）环境搭建中文教程，点击跳转RN中文社区
2.3）开发工具安装和配置 :
本文中使用 WebStorm 进行开发，也有人用 Atom 或 Sublime，对此我想说：赶快换 WebStrom 吧。为了不牵扯什么不必要的问题，下载地址我就不贴了，自行破*解吧。我最多只能说一下我用的是下面这个版本的。
安装好 WebStorm 后，为了更便捷的去开发，我们需要安装一些插件，以及进行一些常用配置。比如RN组件库的安装，添加一些常用的Live Templates等，下图是我添加的两个比较常用的，给大家参考一下，至于如何添加 Live Template 大家可以自行百度一下，比较简单，我就不过多赘述了。
《[React Native]去掉WebStorm中黄色警告》——于连林520wcf
配置Live Templates
3.Hello World（预计用时：0.5天） 不教大家写 Hello World 的教程,不是好教程！千万注意！【要看注释】哈！不然会很坑！
import React, { Component } from ‘react’;
import { AppRegistry, Text } from ‘react-native’;
class HelloWorldApp extends Component {
render() {
return (
Hello World! );
}
}
// 注意，这里用引号括起来的 ‘HelloWorldApp’ 必须和你 init 时创建的项目名一致
AppRegistry.registerComponent(‘HelloWorldApp’, () =&gt; HelloWorldApp);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23dc207695389dc0950cf20679a6006b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ee261187d4a7896740806962146e2c/" rel="bookmark">
			Mac 环境变量配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 环境变量配置 1. 环境变量配置截图2.我的Mac电脑环境变量配置3. Mac 安装 Homebrew3.1 Homebrew安装Redis3.2 安装nvm 4. Mac终端上Homebrew的常用命令 1. 环境变量配置截图 2.我的Mac电脑环境变量配置 👆🏻图是我同事配置的环境变量。
因为我的iterm用的是zsh,所以环境变量都尽可能保存在~/.zshrc
vim ~/.zshrc # apache-maven-3.6.2 export MAVEN_HOME=/Users/fanzhen/Documents/apache-maven-3.6.2 export PATH=$MAVEN_HOME/bin:$PATH # mysql export PATH=$PATH:/usr/local/mysql/bin # Nodejs -14 export PATH=/opt/homebrew/opt/node@14/bin:$PATH # nvm export NVM_DIR="$HOME/.nvm" [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] &amp;&amp; \. "/opt/homebrew/opt/nvm/nvm.sh" # This loads nvm [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] &amp;&amp; \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" # This loads nvm bash_completion fanzhen@fanzhendembp-2 opt % pwd /opt/homebrew/opt fanzhen@fanzhendembp-2 opt % ls -lh total 0 lrwxr-xr-x@ 1 fanzhen admin 22B 11 12 17:24 brotli -&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ee261187d4a7896740806962146e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1621128bbbfdbc2bc4f069e3fa103af3/" rel="bookmark">
			超详细！AI 绘画神器 Stable Diffusion 基础教程_stable diffusion ai怎么用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HED 边缘检测
跟 Canny 类似，但自由发挥程度更高。HED 边界保留了输入图像中的细节，绘制的人物明暗对比明显，轮廓感更强，适合在保持原来构图的基础上对画面风格进行改变时使用。
Scribble 黑白稿提取
涂鸦成图，比 HED 和 Canny 的自由发挥程度更高，也可以用于对手绘线稿进行着色处理。
Mlsd 直线检测
通过分析图片的线条结构和几何形状来构建出建筑外框，适合建筑设计的使用。
Seg 区块标注
通过对原图内容进行语义分割，可以区分画面色块，适用于大场景的画风更改。
Normal Map 法线贴图
适用于三维立体图，通过提取用户输入图片中的 3D 物体的法线向量，以法线为参考绘制出一副新图，此图与原图的光影效果完全相同。
Depth 深度检测
通过提取原始图片中的深度信息，可以生成具有同样深度结构的图。还可以通过 3D 建模软件直接搭建出一个简单的场景，再用 Depth 模型渲染出图。
ControlNet 还有项关键技术是可以开启多个 ControlNet 的组合使用，对图像进行多条件控制。例如：你想对一张图像的背景和人物姿态分别进行控制，那我们可以配置 2 个 ControlNet，第 1 个 ControlNet 使用 Depth 模型对背景进行结构提取并重新风格化，第 2 个 ControlNet 使用 OpenPose 模型对人物进行姿态控制。此外在保持 Seed 种子数相同的情况下，固定出画面结构和风格，然后定义人物不同姿态，渲染后进行多帧图像拼接，就能生成一段动画。
以上通过 ControlNet 的 8 个主要模型，我们解决了图像结构的控制问题。接下来就是对图像风格进行控制。
3. 图像风格控制
Stable Diffusion 实现图像风格化的途径主要有以下几种：Artist 艺术家风格、Checkpoint 预训练大模型、LoRA 微调模型、Textual Inversion 文本反转模型。
Artist 艺术家风格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1621128bbbfdbc2bc4f069e3fa103af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e55d04900a97c24a0d75cd8f1b57786/" rel="bookmark">
			《Mask2Former》算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章地址：《Masked-attention Mask Transformer for Universal Image Segmentation》
代码地址：https://github.com/facebookresearch/Mask2Former
文章为发表在CVPR2022的一篇文章。从名字可以看出文章像提出一个可以统一处理各种分割任务（全景分割、语义分割、实例分割）的网络。
这里稍微通俗的解释一下上述的几个分割任务：
全景分割：分割的结果有背景概念（天空、大海），有实例概念（person1、person2、person2）。
语义分割：只有类别概念，比如上述的person1、person2、person3都属于people这一类，不区分每个实例。且包含背景类别的识别。
实例分割：只有前景类别的概念，例如只有人、猫、狗等类别，没有天空大海这一类背景类别。且前景类别是有实例概念的。
更详细一点的说，在coco数据集里面定义，背景类称为stuff类别，这一类类别是没有边界的概念，例如一张图只有一片天空。前景类别称为things类别。
本文提出的网络就是可以一次性处理上述几个分割任务，而不用向之前的网络，一个任务去处理特定的一种任务。如下图所示
上图不仅可以看出不同任务的示意，还可以看出文章的网络在各个任务上表现都是SOTA的。
一、网络结构 文章采用的网络架构与MaskFormer 一致的。该类架构由三部分组成，一个backbone用于提取图片的特征，一个pixel decoder用于将主干网络提前的特征进行上采样生成高分辨率的图像特征，一个transformer decoder用于根据图像特征来处理object queries。最终网络根据pixel decoder输出的高分辨率的图像特征和transformer decoder输出的object queries生成最终的预测mask。
该结构能够很好的处理各种分割任务，原因就是输出对每个mask预测一个类别，这样不同的任务只是定义的不同类别而已。
具体的Mask2Former的示意图如下图所示，左边为整体的框架，右边为Transformer decoder with masked attention结构:
1.1 Transformer decoder with masked attention 有文章研究全局的特征信息对图像分割任务是非常重要的，但是也有文章证明对于transformer-based的结构来说，全局的特征信息会导致cross-attention收敛变慢，因为cross-attention需要很多轮的训练才能关注到需要关注的对应的物体区域上。
文章假设局部特征已经可以很好的去更新query feature了，而全局特征可以通过self-attention结构来学习。基于这假设，文章提出了masked attetion结构。
标准的cross-attetion结构用公式表示如下所示：
X l = s o f t m a x ( Q l K l T ) V l + X l − 1 X_l = softmax(Q_lK^T_l)V_l + X_{l-1} Xl​=softmax(Ql​KlT​)Vl​+Xl−1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e55d04900a97c24a0d75cd8f1b57786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e77292f30a81f979db51032035e1a5a/" rel="bookmark">
			【c&#43;&#43;】继承学习(一)：继承机制与基类派生类转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页：Quitecoder
🔥专栏：c++笔记仓
朋友们大家好，本篇文章我们来学习继承部分
目录 `1.继承的概念和定义``继承的定义``继承基类成员的访问方式变化` `2.基类和派生类对象赋值转换``3.继承中的作用域` 1.继承的概念和定义 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用
通过继承，子类可以重用父类的代码，这有助于减少代码冗余和复杂性，并增加代码的可复用性
子类和父类是继承关系中的两个基本概念：
父类/ 基类:
父类是一个更一般的类，它定义了一种通用的数据类型和方法，这些可以被其他类继承。它是继承关系中处于较高层次的类，其特性（属性和方法）可以传递到派生的类中。其他从父类继承的类会自动获得父类定义的所有公共和受保护的成员。
子类/ 派生类:
子类是从一个或多个父类继承特性的类。它是继承关系中处于较低层次的类，可以继承其一或多个父类的属性和方法。子类通常会添加一些特有的属性和方法，或者重写某些从父类继承的方法来改变行为。子类集成了父类的特征，并可以拥有自己的特征。
简单来说，父类是派生过程的起点，提供了基础的属性和方法，而子类是继承的结果，它可以扩展和定制继承来的属性和方法。通过这种方式，子类和父类形成了一种层次结构，允许更高层次的代码重用和泛化
例如下面的例子：
父类包含一些通用的属性，人名和年龄，派生类继承自父类但具有不同的额外特性或方法
class Person { public: void Print() { cout &lt;&lt; "name:" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; "age:" &lt;&lt; _age &lt;&lt; endl; } protected: string _name = "jason"; // 姓名 int _age = 18; // 年龄 }; class Student : public Person { protected: int _stuid; // 学号 }; class Teacher : public Person { protected: int _jobid; // 工号 }; 继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。这里体现出了Student和Teacher复用了Person的成员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e77292f30a81f979db51032035e1a5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8233f793e89ce03925c63a15fb362e50/" rel="bookmark">
			C语言/数据结构——每日一题（环形链表的约瑟夫问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 今天在牛客网上面看到了一道环形链表题，想着和大家们分享一下。可能我有点笨，那道题的链接我没搞好，所以很抱歉，只能麻烦大家们看一下截屏的题目信息了。废话不多数，让我们开始今天的题目分享吧。
二.正文 1.1题目描述 1.2题目解析 这是一道环形链表题。
本体虽然没有明确指出但是它默认结构体是:
struct ListNode { int val; ListNode* next; }; 1. 而且这道题没有给你设置好哪怕一个节点，因此我们只能先通过先通过malloc函数自己创建节点。而创建一个环形链表就需要多个节点，为了方便后面使用，因此我写了一个函数BuyNode专门来创建节点。
newnode是我为了接受malloc开辟的那块节点空间的地址。
2. 上面提到我们想要创建一个环形，链表，因此需要多个节点做到首尾相连。为此我定义了一个BuyList函数来创建环形链表。
phead是我们一开始就建立的指向头节点的指针，ptail代表的是尾节点。因为开始ptai=phead（这代表着ptail和phead都指向头节点）
上面右边是左边代码的具现图。
值得注意的是如果没有把最后的尾节点ptail和我们的头节点phead相链接的话，最后具线图将会变成下面这个样子。（下面这个图是错误示范，上面的图才是我们想要的效果）
且该函数返回的是尾节点的地址，即节点5而不是1。这一点很重要！！！
3. 主函数ysf函数中：我们用prev来接受BuyList传递的5节点指针。pcur是prev的下一个节点，初始pcur指向1节点。count是我们的计数变量，什么时候count==m，pcur代表的这个人就死掉了（代码中是free掉了）
如果count！=m，我们仅仅需要让prev指向pcur所在节点，以及pcur指向下一个节点，并让count++。
否则，即（count==m）那么prev将会指向pcur指向的下一个指针，并且pcur所指向的指针会被free掉，然后pcur指向prev指向的下一个节点。最后不要忘了让count=1重新计数。
依次循环直到不满足条件（pcur-&gt;next!=pcur）后，退出循环。
1.3代码实现 /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param n int整型 * @param m int整型 * @return int整型 */ typedef struct ListNode ListNode; ListNode* BuyNode(int x) { ListNode* newnode=(ListNode*)malloc(sizeof(ListNode)); if(newnode==NULL) { return NULL; } else { newnode-&gt;next=NULL; newnode-&gt;val=x; return newnode; } } ListNode* BuyList(int n) { ListNode* phead=BuyNode(1); ListNode* ptail=phead; for(int i=2;i&lt;=n;i++) { ptail-&gt;next=BuyNode(i); ptail=ptail-&gt;next; } ptail-&gt;next=phead; return ptail; } int ysf(int n, int m ) { ListNode* prev=BuyList(n); ListNode* pcur=prev-&gt;next; int count=1; while((pcur-&gt;next)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8233f793e89ce03925c63a15fb362e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a7652eb725cf4b12b1bcfb0c1d3ce6/" rel="bookmark">
			MIMO天线的ECC计算脚本(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MIMO（Multiple Input Multiple Output，多输入多输出）技术是现代无线通信系统中的一项关键技术，它通过在发送端和接收端使用多个天线来提高数据传输速率和信号质量。在MIMO系统中，天线的设计和配置对系统性能有着至关重要的影响。其中，一个重要的性能指标是包络相关系数（Envelope Correlation Coefficient，ECC）。
MIMO天线的ECC简介 ECC是用来衡量MIMO天线系统中各个天线之间独立性的指标。理想情况下，为了实现最佳的MIMO性能，每个天线元素应该是完全独立的，即它们的辐射模式不应该相互关联。ECC的值范围从0到1，其中0表示天线之间完全独立，1表示天线之间完全相关。在实际应用中，ECC的值应尽可能低，通常认为ECC值低于0.5是可以接受的。
ECC的计算 ECC的计算涉及到天线的辐射模式，可以通过以下公式得出：
​
其中，(E_{\theta1}) 和 (E_{\theta2}) 分别代表两个天线在θ方向的电场分量，(E_{\phi1}) 和 (E_{\phi2}) 分别代表两个天线在φ方向的电场分量。这个公式通过积分计算两个天线的辐射模式的相关性，并通过天线的辐射功率进行归一化处理。
ECC在天线设计中的应用 在设计MIMO天线时，工程师会通过模拟和实验来测量ECC值，以确保天线布局和设计能够满足性能要求。通过优化天线的位置、方向和极化，可以降低ECC值，从而提高MIMO系统的性能。
ECC的计算
以hfss仿真结果为例，导出mag_rETheta，ang_rad_rETheta，mag_rEPhi，ang_rad_rEPhi
import numpy as np import pandas as pd # Set display format for floating point numbers np.set_printoptions(precision=15) # Read CSV files Em_th1 = pd.read_csv('mag_rETheta_1.csv', skiprows=1, header=None).values Em_th2 = pd.read_csv('mag_rETheta_2.csv', skiprows=1, header=None).values Ep_th1 = pd.read_csv('ang_rad_rETheta_1.csv', skiprows=1, header=None).values Ep_th2 = pd.read_csv('ang_rad_rETheta_2.csv', skiprows=1, header=None).values # Calculate E_theta E_th1 = Em_th1[:, 2] * np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29a7652eb725cf4b12b1bcfb0c1d3ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18173122237e8d182be53d770144c27/" rel="bookmark">
			【数据结构】如何创建一棵红黑树（附动图讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
二、红黑树的概念
三、红黑树的性质
四、红黑树节点的定义
五、红黑树的插入
5.1 节点的初始颜色 5.2 红黑树的调整
六、红黑树的验证
6.1 验证有序
6.2 验证红黑树性质
七、红黑树与AVL树的比较
一、前言 在前面AVL树的学习中，我们知道了如何通过对平衡因子的调整、判断和旋转得到一棵严格平衡的二叉搜索树，虽然AVL树能够降低搜索树的高度，加快搜索效率，但是频繁的旋转导致创建一棵AVL树的代价并不小，因此，红黑树诞生了。
二、红黑树的概念 红黑树是一种自平衡的二叉搜索树，相对于AVL树的严格平衡，它遵循一种相对平衡，即最长路径不超过最短路径的二倍。红黑树由 Rudolf Bayer 于1972年发明，在当时被称为对称二叉B树（symmetric binary B-trees）。后来在1978年被 Leo J.Guibas 和 Robert Sedgewick 修改为如今的红黑树。
红黑树的应用十分广泛，它能够在O(logN)的时间复杂度内完成搜索、查找和删除操作，后面要学习的C++容器map和set，其底层就是用红黑树实现的
三、红黑树的性质 红黑树之所以叫这个名字，是因为其每个节点中都增加了一个颜色变量，该变量不是红色就是黑色
红黑树的以下几个性质，是必须严格遵守的，否则就不能被称为红黑树： 性质1：每个节点不是红色就是黑色性质2：根节点必须是黑色的 这里的根节点不包括子树的根节点，而是整棵树唯一的_root节点
所以红黑树的左右子树不是红黑树（区分：AVL树的左右子树也是AVL树） 性质3：可以存在两个或多个连续的黑色节点，但是不能存在连续的红色节点性质4：每条路径上的黑色节点数量必须相同 性质2、3和性质4就决定了红黑树的最长路径不超过最短路径的二倍，例如：
图中的红黑树已省略其他节点，只保留最长路径和最短路径
可以看到此时路径中的黑色节点数量相同，因此无法在最长路径中再添加一个黑色节点；又因为不能存在连续的红色节点，而最长路径中的最后一个节点为红色，因此也无法在最长路径中添加红色节点。
通过观察可以发现，在红黑树中全黑的路径必然是最短路径，而一黑一红交替的路径是最长路径
性质5：红黑树的空节点（NIL节点）默认为黑色 四、红黑树节点的定义 红黑树的节点与AVL树的节点大致相同，只是没有了平衡因子，取而代之的是颜色
每个新节点的初始颜色都设置为红色，原因会在后面的插入操作中讲 我们可以用一个枚举来列举颜色
enum Colour { RED, BLACK }; template&lt;class T&gt; struct RBTreeNode { RBTreeNode&lt;T&gt;* _left; RBTreeNode&lt;T&gt;* _right; RBTreeNode&lt;T&gt;* _parent; T _data; Colour _col; RBTreeNode(const T&amp; data) :_left(nullptr) , _right(nullptr) , _parent(nullptr) , _data(data) , _col(RED) //初始颜色为红色 {} }; 五、红黑树的插入 红黑树本质上也是一棵二叉搜索树，因此在插入节点时也需要遵循二叉搜索树的规则。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c18173122237e8d182be53d770144c27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97bccccfac26a2cfe8988a52ec840e0b/" rel="bookmark">
			Java InputStream实战指南：轻松读取、操作文件流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，各位小伙伴们，你们好呀，我是喵手。运营社区：C站/掘金/腾讯云；欢迎大家常来逛逛
今天我要给大家分享一些自己日常学习到的一些知识点，并以文字的形式跟大家一起交流，互相学习，一个人虽可以走的更快，但一群人可以走的更远。
我是一名后端开发爱好者，工作日常接触到最多的就是Java语言啦，所以我都尽量抽业余时间把自己所学到所会的，通过文章的形式进行输出，希望以这种方式帮助到更多的初学者或者想入门的小伙伴们，同时也能对自己的技术进行沉淀，加以复盘，查缺补漏。
小伙伴们在批阅的过程中，如果觉得文章不错，欢迎点赞、收藏、关注哦。三连即是对作者我写作道路上最好的鼓励与支持！
前言 Java是一门非常流行的编程语言，广泛应用于各种应用程序的开发。在Java中，输入输出是非常重要的基础功能。其中，InputStream是Java中的一个重要输入流类，用于从输入源读取数据。
摘要 本文将介绍InputStream类的源代码解析、应用场景案例、优缺点分析、类代码方法介绍以及测试用例。
InputStream类 简介 InputStream是Java中的一个抽象类，用于从输入源读取数据。它提供了以下基本方法：
int read()：从输入流中读取一个字节的数据。如果已经到达输入流的末尾，则返回-1。int read(byte[] b)：从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。返回实际读取的字节数。int read(byte[] b, int off, int len)：从输入流中读取最多len个字节，并将其存储在缓冲区数组b中，从偏移量off开始存储。返回实际读取的字节数。long skip(long n)：从输入流中跳过并丢弃n个字节的数据，并返回实际跳过的字节数。int available()：返回可从输入流中读取的估计字节数。void close()：关闭输入流并释放与之相关的任何系统资源。 InputStream类是一个抽象类，不能直接实例化。它有几个具体的子类，如FileInputStream、ByteArrayInputStream、PipedInputStream等。这些子类提供了实际的方法来从特定类型的输入源中读取数据。
源代码解析 InputStream类的源代码可以在JDK中找到。以下是该类的部分源代码：
public abstract class InputStream implements Closeable { // ... public abstract int read() throws IOException; public int read(byte[] b) throws IOException { return read(b, 0, b.length); } public int read(byte[] b, int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (off &lt; 0 || len &lt; 0 || len &gt; b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97bccccfac26a2cfe8988a52ec840e0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495b923f91edade2c9a9fda22953c873/" rel="bookmark">
			Java 【数据结构】常见排序算法实用详解（上） 插入排序/希尔排序/选择排序/堆排序【贤者的庇护】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登神长阶
上古神器-常见排序算法
插入排序/选择排序/堆排序 📔 一.排序算法 📕1.排序的概念 排序 ：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳 定的；否则称为不稳定的。 内部排序：数据元素全部放在内存中的排序。 外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。 📗2.排序算法 在Java中，排序算法是一种对数据集合中的元素按照特定顺序进行排列的算法。排序算法通常用于将数据按照升序或者降序排列，以便于后续的查找、插入、删除等操作。排序算法在Java中是非常常见和重要的，因为数据的排序是计算机科学中的基本问题之一，几乎所有的应用场景都需要对数据进行排序。
在Java中，排序算法可以针对不同的数据结构实现，例如针对数组、链表、树等。常见的排序算法包括冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序等。每种排序算法都有其特定的实现方式、时间复杂度和空间复杂度，不同的算法在不同的场景下有着各自的优劣势。
Java提供了丰富的API和工具类来支持排序操作。比如，可以使用 java.util.Arrays 类的 sort() 方法对数组进行排序，该方法内部使用了优化的快速排序算法或归并排序算法；另外，Java中的集合类如 ArrayList、LinkedList 等也提供了 Collections.sort() 方法来对集合进行排序，同样利用了内部的排序算法来实现。
总之，在Java中，排序算法是程序员必须掌握的基本知识之一，对排序算法的理解和掌握有助于编写出高效、可靠的Java程序。 在本次chapter1我们先对插入排序，希尔排序，选择排序，堆排序进行一个深度理解。
📘3.排序的运用 排序算法在Java项目中有着广泛的应用，主要体现在以下几个方面：
数据存储与检索：在实际项目中，经常需要对大量数据进行存储和检索，而这些数据可能需要按照某种顺序进行排列。例如，对于电子商务网站，商品列表需要按照价格、销量等指标进行排序，以便用户浏览和筛选。在这种情况下，可以利用Java提供的排序算法对数据进行排序，以便更高效地进行检索和展示。
数据分析与统计：在数据分析和统计领域，经常需要对大量数据进行排序以便进行分析和计算。例如，在金融领域，对交易数据进行排序可以帮助识别交易模式和规律；在科学研究中，对实验数据进行排序可以帮助找到数据的规律和趋势。Java中的排序算法可以帮助开发人员快速对数据进行排序，从而支持数据分析和统计的工作。
搜索与查找：在搜索和查找功能中，排序算法也发挥着重要作用。例如，在搜索引擎中，对搜索结果进行排序可以根据相关度、权重等指标进行排序，提高搜索结果的质量和用户体验；在数据库系统中，对数据库中的记录进行排序可以提高查询效率，加快数据检索的速度。Java中的排序算法可以帮助开发人员实现这些功能，从而提升系统的性能和用户体验。
任务调度与优先级管理：在任务调度和优先级管理中，排序算法可以帮助开发人员对任务进行排序和调度，以提高系统的响应速度和效率。例如，在操作系统中，可以利用排序算法对进程进行优先级调度，从而保证系统的稳定性和效率；在分布式系统中，可以利用排序算法对任务进行分配和调度，以实现负载均衡和资源优化。Java中的排序算法可以为开发人员提供实现这些功能的工具和方法。
总之，排序算法在Java项目中具有广泛的应用场景，可以帮助开发人员解决各种实际问题，提高系统的性能和效率，提升用户体验。通过灵活运用各种排序算法，开发人员可以实现更加高效、稳定和可靠的Java应用程序。
📙二.插入排序 插入排序（Insertion Sort）是一种简单直观的排序算法，在实际应用中也是比较常见的一种。它的基本思想是将一个待排序的元素逐个插入到已经排序好的子序列中，直到所有元素都插入完毕。插入排序通常采用在原地排序的方式进行，不需要额外的存储空间，因此空间复杂度为 O(1)。
基本思想
把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到 一个新的有序序列 。实际中我们玩扑克牌时，就用了插入排序的思想。 基本原理
从第二个元素开始，将其视为已排序的子序列：初始时，将第一个元素视为已排序的子序列。
逐个将未排序的元素插入已排序的子序列中：从第二个元素开始，依次将每个元素与已排序的子序列中的元素比较，找到合适的位置插入。
重复直到所有元素都插入完毕：重复以上步骤，直到所有元素都插入到已排序的子序列中，排序完成。
算法步骤
从第二个元素开始遍历数组。对于当前遍历到的元素，从后往前遍历已排序的子序列，找到合适的位置插入。插入元素后，继续遍历下一个未排序的元素，重复以上步骤直到所有元素都插入完毕。 时间复杂度
插入排序的时间复杂度取决于待排序数组的初始状态。在最好情况下，即数组已经有序，插入排序的时间复杂度为 O(n)，每个元素只需要与前面的有序序列比较一次。在最坏情况下，即数组完全逆序，插入排序的时间复杂度为 O(n^2)，每个元素需要与前面的有序序列比较 n-1 次。平均情况下，插入排序的时间复杂度也为 O(n^2)。
稳定性
插入排序是一种稳定的排序算法，即相等元素的相对顺序在排序前后保持不变。
适用性
小规模数组：对于小规模数组，插入排序是一个不错的选择，因为它的实现简单且性能较好。
部分有序的数组：如果数组已经部分有序，插入排序的效率会更高，因为大部分元素都在正确的位置上，只需少量的比较和移动。
稳定性要求：如果需要保持相等元素的相对顺序不变，插入排序是一个合适的选择。
链表结构：插入排序在链表结构中也适用，因为它只需要在链表中移动指针，不需要像数组一样进行元素的移动。
源代码
/** * 插入排序 * 时间复杂度：O(N^2) * 空间复杂度：O(1) * 稳定性：稳定 * 场景：当前有一组数据 基本上趋于有序 那么就可以使用直接插入排序 * 优点：越有序越快 * @param array */ public static void insertSort(int[] array){ for (int i = 1; i &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495b923f91edade2c9a9fda22953c873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be7911b140e853eee2bc9ff98fdf2aa/" rel="bookmark">
			【探索】文字游侠AI新时代，每天5分钟自动化创作图文月入1万&#43;，十分适合新手小白，附上渠道和教程（全面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个信息爆炸的时代，内容创作者面临着空前的竞争。为了在今日头条这样的平台上脱颖而出并获取稳定收入，他们需要找到更高效、更创新的方法。而今，一款全新的AI工具正引领着一场革命，彻底改变了内容创作的生态。
自从GPT问世以来，AI话题的热度急剧攀升，随之而来的AI工具也如雨后春笋般涌现，这无疑为我们的日常工作和生活带来了诸多便利。近期，小编发现了一款名为“文字游侠”的出色AI文章生成工具，它能将我们的自媒体文章创作效率提升高达20倍，实属神器。
话不多说，先来看看大体的介绍把！一定要看到最后！！！
利用’文字游侠‘在今日头条上发布图文，每天10分钟迅速爆款！
但经过团队测试，单号单日小爆款就能突破两三百，要想取得更大的成果，可以进行矩阵操作。
这款文字游侠APP工具的使用体验相当流畅，特别是与爆文选文网站相结合时，效果更佳。令人惊叹的是，仅需一分多钟，就能生成一篇高质量的原创文章，这样的创作效率可谓空前绝后。
因为工具刚出来目前不久正在公测，若您有意尝试，文字游侠需要专属渠道码才能完成使用，关于文字游侠的具体用法和使用渠道请先看看下面这一篇文章，里面都有详细的教程说明：
【爆】揭秘：利用AI文字游侠傻瓜式一键创作轻松挣米！附渠道码和教程（超详细）
当然，也可以直接关注宫中号【追梦好彩头】领取即可。
一、全自动AI工具带来的变革 这款全新的文字游侠AI工具不仅具备了文章生成的功能，更能一键完成排版、配图等繁琐步骤。只需简单操作，一分钟内即可生成一篇高质量的、原创的今日头条文章。这无疑是内容创作者们的福音。
二、轻松上手，操作无忧 这款名为“文字游侠”的AI工具，界面简洁易懂，操作便捷。用户只需从预设的模板库中选择热点内容，即可一键生成独一无二的文章。每篇文章都配有合适的图片和优化的SEO标题，让你的内容更具吸引力。
三、实现收益增长，轻松月入过万 “文字游侠”内置的热点分析系统能自动筛选热门内容，让你无需深入研究热点，也能轻松吸引大量读者。同时，你可以管理多个头条账号，同步发布文章，从而极大增加收益潜力。通过提高发布频率和管理多个账号，你的收入将实现稳定增长，轻松月入过万不再是梦想。
四、抢占先机，领跑蓝海市场 目前市场上同类产品稀缺，采用全自动化工具将让你在竞争中脱颖而出。现在就行动吧，抢占这个蓝海市场的先机，实现收益的快速增长。
随着AI技术的不断进步，全自动化的内容创作工具为创作者们带来了前所未有的便利。如果你渴望从繁琐的内容创作中解脱出来，那么“文字游侠”将是你的最佳选择。让智能科技成为你的得力助手，助你轻松实现收益增长。
目前这款工具尚未被大众广泛知晓，这是个抢占先机的时刻。赶快行动起来吧，让我们的文章创作过程变得更加高效，轻松提升内容生产力！
五、头条收益 今日头条与抖音，快手等短视频平台不同。短视频不能通过播放量赚钱，而今日头条则可以。
有阅读，有播放就有收益。所以今日头条合适所有人，发作品就可以赚收益。
有很多小伙伴在私信，说自己发作品发从下手，使用手机怎么操作等。
接下来给大家详细一步一步解析，建议收藏。
5.1 开通创作收益功能 一定要注意，发作品之前要把收益功能开通，否则发再多作品也是没有收益的。
点击【我的】-【创作首页】-【创作权益】，进入页面。
开通文章视频原创权益。开通后发布作品有阅读，有播放就可以获得收益。
文章和视频收益0粉丝也是可以开通的，微头条，问答收益是100粉丝以上可以开通。
5.2 发布作品 以发布文章为例，点击【发布】-【文章】-进入编辑页面。编辑完就可以发布了。
文章的标题决定点击率，内容决定阅读时间，两个方面做好文章就容易成为爆文。
关于更多作品的创作技巧后期重点分享。
【最后重点】 为啥要用【文字游侠】生成文章发今日头条？
之前要是想写篇文章，从构思到列出大纲到最后写出来，
要花费2、3个小时，写作路上枯燥无味，自身写作水平又有限，这让好多人都望而却步了。
但是现在有了【文字游侠】
就可以直接用它批量自动生成爆款文章
整个过程你不需要亲自写文章，只需复制别人文章的链接黏贴到【文字游侠】就可以生成一篇全新的原创度百分百的文章，真的超级简单。
这个项目大大缩短了我们创作的时间，生成一篇全新文章只需几十秒，提高了创作的效率。
而且可以放大批量操作，一个头条号一月最低给你创造300-2500收益，假如有5个10个头条号呢，收益可想而知！
重点说明：在使用文字游侠工具以后一定找我进裙，会分享运营技巧、经验心得等。并且裙内会有高额奖励活动。
如果你对这个项目感兴趣，想要获取平台工具入口和更多的挣米重技巧，可以关注宫中号【追梦好彩头】免费领取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634ccceff4e97e76a06a8283394c8623/" rel="bookmark">
			Python中无法pip的解决办法和pip的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是pip？ PIP是通用的Python包管理工具，提供了对 Python 包的查找、下载、安装、卸载、更新等功能。安装诸如Pygame、Pymysql、requests、Django等Python包时，都要用到pip。
注意：在Python3.4（一说是3.6）及更新的版本中，PIP已经捆绑安装了，不需要再单独安装（应该需要更新）。
初次使用pip出错 许多人在第一次使用pip的时候都会出现'pip' 不是内部或外部命令，也不是可运行的程序或批处理文件。
这是因为直接在Administrator目录下面直接执行pip命令的时候 会在这个目录下面找pip的可执行文件。
而pip是在python目录下面的scripts目录下面的 所以就出现了上面的错误。
所以当我们cd（切换目录）到python的scripts目录下面的时候 在运行pip命令就不会出错了。
而这个问题的产生大多是我们安装时没有勾选以下选项：
解决方法 方法一：卸载重新安装Python
方法二：Windows下配置pip环境变量
首先找到我们Python的安装路径，默认是c盘。找到其中的Scripts路径。
将这个路径复制下来。
D:\Python\Scripts
然后进入高级系统设置。
再点击环境变量在系统变量里面有个path打开他。
然后把刚刚复制的路径粘贴进去，然后一直保存就可以了 。 看图：
验证 接下来我们验证一下是否有效。
打开命令行，输入pip。
可以看见如下图所示，接下来就可以安装我们的第三方库了。
但是有时候我们明明这样做了，为什么还是在我们的环境中无法使用第三方库呢?
那是因为电脑中安装了多个Python版本，而刚才添加进去的路径并不是我们现在使用的这个版本的路径。只需要将相应路径添加进去就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cf16214df2fd8f2cd7280e29302dec/" rel="bookmark">
			[新人向]MySQL和Navicat下载、安装及使用详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Java全套进阶之路大厂面经、学习笔记、源码讲义、实战项目、讲解视频 》 浏览器打开 完整开源： docs.qq.com/doc/DUmliVmhNQ0t0Yndh MySQL和Navicat下载和安装及使用详细教程 因为这些软件的安装很多都是纯英文，作为新手安装真的需要摸索好久，包括我自己，所以Pipi酱就把自己的经验分享给大家~
MySQL的安装教程 一、下载安装包链接：
1.下载MySQL：https://dev.mysql.com/downloads/windows/installer/8.0.html
这里我们直接下载第一个（24.4M），下载到任意目录即可。
2、安装MySQL
二、安装
1、这里我们安装点击Yes
2、选择Custom，然后Next
3、这里我们选择最新的，然后点击中间三个箭头中第一个把所选两个（MySQL Serve和MySQL Workbench）添加到右侧
如果这里显示为灰色即为已安装过，正常情况下为黑色
4、点击Execute等待安装
5、安装完成后点击Next
6、点击Excute等待安装（时间可能较长）
7、安装完成后点击Next
8、此处一直Next
如果port参数后打叉说明3306这个参数已经设置过，你可能曾经安装过MySQL且并未删除干净
9、设置数据库密码：123456（密码随机，在使用Navicat会用到密码，别忘了）
10、设置服务名称，然后Next
11、Execute等待安装
如果曾经安装过SQL，这里会停在第四步Initializing database（may take a long time）,解决方法见后文
12、以下都是Next最后Finish即可
注：如果无法正常安装，可能是曾经安装过MySQL
这时候需要将以下三个文件家中的MySQL文件夹删除（ProgramData是隐藏文件夹，需要打开显示隐藏文件才能看到），同时在控制面板中卸载有关MySQL的所有程序
二、MySQL环境变量的配置
为了能让Windows命令行操作MySQL数据库，需要配置一下系统的环境变量。
打开“控制面板”–&gt;“系统和安全”–&gt;“系统”–&gt;“高级系统设置”–&gt;“环境变量”，在打开的窗口中选择 “系统变量” 下的 “新建” 按钮创建环境变量。
1.创建 MYSQL_HOME 环境变量
（1）变量名：MYSQL_HOME
（2）变量值：C:Program FilesMySQLMySQL Server 8.0（MySQL的安装目录，一般情况下都是这个默认路径）
2.配置 path 环境变量
在系统变量中，选择 “path” 并单击 “编辑” 按钮，然后点击“新建”，输入：%MYSQL_HOME%in，确定。
3、在命令提示符下启动、停止MySQL服务器
“Windows+R”–&gt;输入“cmd”–&gt;Enter，在DOS窗口命令提示符下
输入：net start mysql启动MySQL服务器（mysql是服务名）
输入：net stop mysql56 停止MySQL服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9cf16214df2fd8f2cd7280e29302dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0d98da26be0b4b980be57cb0f5cb9e/" rel="bookmark">
			【大语言模型LLM】- AI工具收录集合，一篇就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页：西瓜WiFi
🎥系列专栏：《大语言模型》
很多非常有趣的模型，值得收藏，满足大家的收集癖！ 如果觉得有用，请三连👍⭐❤️，谢谢！
长期不定时更新，欢迎watch和fork！❤️❤️❤️
❤️感谢大家点赞👍 收藏⭐ 评论⭐
🎥大语言模型LLM基础-系列文章：
【大语言模型LLM】-大语言模型如何编写Prompt? 【大语言模型LLM】-如何使用大语言模型提高工作效率？
【大语言模型LLM】-使用大语言模型搭建点餐机器人
【大语言模型LLM】-基础语言模型和指令微调的语言模型
【大语言模型LLM】-基于ChatGPT搭建客服助手（1）
⭐持续更新中…
第一部分 热门大模型推荐 国外
🔥ChatGPT，OpenAI开发的一种基于GPT架构的对话生成模型。🔥Claude，美国人工智能初创公司Anthropic发布的大型语言模型。🔥Grok-1， Grok-1是由马斯克旗下的人工智能初创公司xAI发布的大语言模型。 国内
🔥文心一言，百度全新一代知识增强大语言模型。🔥豆包，字节跳动公司基于云雀模型开发的AI工具。🔥Kimi，月之暗面开发的国产人工智能大模型。 AI绘图
🔥Midjourney，人工智能研究实验室Midjourney, Inc.开发的Al图像生成工具。🔥Stable Diffusion，Stable Diffusion是2022年发布的深度学习文本到图像生成模型。🔥Microsoft Designer，强烈推荐👍，免费绘图+设计，Microsoft Designer是一款基于生成式AI技术的设计工具，它搭载了由OpenAI开发的AI绘画工具DALL-E 2。 AI写作
🔥火山写作，字节跳动旗下的火山引擎团队推出的AI中英文写作助手。🔥新华秒笔，新华通讯社与博特智能共同研发推出，集成了案例参考、材料查找、AI写作、修改润色色、审核校对、文件学习等功能，全方位地辅助公职人员提高创作效率,节省人工编写的时间和精力。🔥星火内容运营大师，星火内容运营大师是一款由科大讯飞推出的AI智能写作软件，旨在帮助内容运营者提高工作效率和质量。🔥Paperpal，Paperpal正是以此为发想而研发的学术专项AI工具，旨在提升研究者的英语写作体验。 第二部分 通用类大模型集合 资源名（Name）公司描述（Description）链接ChatGPTOpenAIOpenAI开发的一种基于GPT架构的对话生成模型。它使用大规模的文本数据进行预训练，具有生成自然、流畅的文本对话的能力。ChatGPT可以用于各种对话场景，包括问答、闲聊、客服等，能够与用户进行智能对话，并提供相关信息和建议。ChatGPT在语言理解和生成方面取得了显著的进展，为人机交互提供了更加智能和自然的体验。ChatGPTGrok-1xAIGrok-1是由马斯克旗下的人工智能初创公司xAI发布的大语言模型，是Grok系列的第一代产品。Grok-1以其3140亿的参数量在人工智能领域中脱颖而出，这一数字远超OpenAI的GPT-3.5模型的1750亿参数量。Grok-1的设计基于混合专家(MoE)架构，拥有8个专家，其中2个始终活跃，采用旋转位置嵌入(RoPE)而非传统的固定位置嵌入。模型的参数规模庞大，包括860亿激活参数，并使用JAX和Rust进行自定义训练。Grok-1CopilotMicrosoftCopilot是一个多功能的AI助手，由微软开发并集成在Windows 11操作系统中。它利用大语言模型(LLM)技术，能够理解和执行人类的指令，完成各种任务。Copilot可以在不同的应用程序中使用，例如Word、Excel、Outlook、PowerPoint等，帮助用户编写文本、分析数据、管理邮件、创建演示文稿等。它还可以通过BusinessChat功能访问用户的邮件、文档和演示文稿，以提供更个性化的服务。CopilotLLaMAMetaLLaMA 是 Meta AI 发布的包含 7B、13B、33B 和 65B 四种参数规模的基础语言模型集合，LLaMA-13B 仅以 1/10 规模的参数在多数的 benchmarks 上性能优于 GPT-3(175B)，LLaMA-65B 与业内最好的模型 Chinchilla-70B 和 PaLM-540B 比较也具有竞争力。LLaMA ChatGLM智普AIChatGLM-6B 是一个开源的、支持中英双语问答的对话语言模型，基于 General Language Model (GLM) 架构，具有 62 亿参数。结合模型量化技术，用户可以在消费级的显卡上进行本地部署（INT4 量化级别下最低只需 6GB 显存）。ChatGLM-6B 使用了和 ChatGLM 相同的技术，针对中文问答和对话进行了优化。经过约 1T 标识符的中英双语训练，辅以监督微调、反馈自助、人类反馈强化学习等技术的加持，62 亿参数的 ChatGLM-6B 已经能生成相当符合人类偏好的回答。 ChatGLM-6B 权重对学术研究完全开放，在填写问卷进行登记后亦允许免费商业使用。ChatGLM 文心一言百度文心一言（英文名：ERNIE Bot）是百度全新一代知识增强大语言模型，文心大模型家族的新成员，能够与人对话互动、回答问题、协助创作，高效便捷地帮助人们获取信息、知识和灵感。文心一言从数万亿数据和数千亿知识中融合学习，得到预训练大模型，在此基础上采用有监督精调、人类反馈强化学习、提示等技术，具备知识增强、检索增强和对话增强的技术优势。文心一言通义千问阿里巴巴通义千问，是阿里云推出的一个超大规模的语言模型。于2023年9月13日正式向公众开放。属于(AI Generated Content，AIGC)领域。是一个MaaS（模型即服务）的底座。通义，取自《汉书》中的“天地之常经，古今之通义也”，有“普遍适用的道理与法则”之意。通义千问功能包括多轮对话、文案创作、逻辑推理、多模态理解、多语言支持。通义千问盘古大模型华为盘古大模型是华为旗下的一系列AI大模型，包括自然语言处理（NLP）大模型、计算机视觉（CV）大模型和科学计算大模型。盘古大模型混元大模型腾讯由腾讯研发的大语言模型，具备强大的中文创作能力，复杂语境下的逻辑推理能力，以及可靠的任务执行能力 。混元大模型豆包字节跳动豆包是字节跳动公司基于云雀模型开发的AI工具，提供聊天机器人、写作助手以及英语学习助手等功能，它可以回答各种问题并进行对话，帮助人们获取信息，支持网页 Web 平台，iOS 以及安卓平台，但 iOS 需要使用 TestFlight 安装。豆包360 智脑360360智脑是360自研认知型通用大模型，依托360多年积累的大算力、大数据、工程化等关键优势，集成360GPT大模型、360CV大模型、360多模态大模型技术能力，具备生成创作、多轮对话、逻辑推理等十大核心能力、数百项细分功能，重塑人机协作新范式。为服务产业数字化，360发布企业级AI大模型战略，以人为本，构建安全可信大模型。360 智脑星火认知科大讯飞讯飞星火认知大模型是科大讯飞发布的大模型。该模型具有7大核心能力，即文本生成、语言理解、知识问答、逻辑推理、数学能力、代码能力、多模交互，该模型对标ChatGPT 。星火认知商量SenseChat商汤科技商汤科技旗下的中文语言大模型，“商量SenseChat”在活动现场展示了多轮对话和超长文本的理解能力。包括：编程助手，可帮助开发者更高效地编写和调试代码；健康咨询助手，为用户提供个性化的医疗建议；PDF文件阅读助手，能轻松从复杂文档中提取和概括信息。商量SenseChat紫东太初中国科学院“紫东太初”是由中国科学院自动化研究所研发的跨模态通用人工智能平台。这个平台的特点是它的全球首个图文音（视觉-文本-语音）三模态预训练模型，具备跨模态理解与生成能力。它基于全栈国产化基础软硬件平台，旨在支持全场景AI应用。紫东太初百川大模型百川智能Baichuan3 超千亿模型，基础能力全面跃升，在众多权威通用及医疗评测中的中文表现超越GPT-4。突破“迭代式强化学习”技术，大幅提升语义理解和生成能力，融汇古今智慧，展现卓越文采。百川大模型天工AI昆仑万维和奇点智源“天工 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0d98da26be0b4b980be57cb0f5cb9e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/384/">«</a>
	<span class="pagination__item pagination__item--current">385/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/386/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>