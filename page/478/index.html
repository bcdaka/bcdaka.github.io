<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa55493d630c2132fc2840678ba18bfc/" rel="bookmark">
			Java各种规则引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Drools规则引擎 1.简介： Drools就是为了解决业务代码和业务规则分离的引擎。 Drools 规则是在 Java 应用程序上运行的，其要执行的步骤顺序由代码确定 ，为了实现这一点，Drools 规则引擎将业务规则转换成执行树。 2.特性： 优点： 1、简化系统架构，优化应用 2、提高系统的可维护性和维护成本 3、方便系统的整合 4、减少编写“硬代码”业务规则的成本和风险 3.原理: 4.使用方式： (1)Maven 依赖： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.kie&lt;/groupId&gt; &lt;artifactId&gt;kie-api&lt;/artifactId&gt; &lt;version&gt;6.5.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt; &lt;version&gt;6.5.0.Final&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; （2）新建配置文件/src/resources/META-INF/kmodule.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;kmodule xmlns="http://jboss.org/kie/6.0.0/kmodule"&gt; &lt;kbase name="rules" packages="rules"&gt; &lt;ksession name="myAgeSession"/&gt; &lt;/kbase&gt; &lt;/kmodule&gt; （3）新建drools规则文件/src/resources/rules/age.drl import com.lrq.wechatDemo.domain.User // 导入类 dialect "mvel" rule "age" // 规则名，唯一 when $user : User(age&lt;15 || age&gt;60) //规则的条件部分 then System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa55493d630c2132fc2840678ba18bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee1f84f68453c27a030a564c6cac9bf/" rel="bookmark">
			Ubuntu介绍、与centos的区别、基于VMware安装Ubuntu Server 22.04、配置远程连接、安装jdk&#43;Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
一、Ubuntu22.04介绍
二、Ubuntu与Centos的区别
三、基于VMware安装Ubuntu Server 22.04
下载
VMware安装
1.创建新的虚拟机
2.选择类型配置
3.虚拟机硬件兼容性
4.安装客户机操作系统
5.选择客户机操作系统
6.命名虚拟机
7.处理器配置
8.虚拟机内存
9.网络类型
10. 选择I/O控制器类型
11.选择磁盘类型
12.选择磁盘
13.指定磁盘容量
14. 自定义硬件
15.指定映像文件
配置Ubuntu22.04 1.运行Ubuntu
2.安装操作系统
3.选择操作系统语言
4.选择键盘布局
5.选择安装类型 6.网络配置
7.代理地址配置
8.设置系统默认镜像源
9.引导式存储布局配置
10.存储配置
11.弹出框
12.配置用户名，密码
13.升级到Ubnutu pro
14.下载OpenSSH服务 15.第三方软件服务包
16.配置完成
17.重新启动
四、配置远程连接 配置root用户
1.设置root用户及密码
2.切换root用户
3.设置root用户远程连接
五、安装jdk+Tomcat
1.Jdk
2.Tomcat 一、Ubuntu22.04介绍 Ubuntu官网地址：
https://ubuntu.com/ Ubuntu 22.04（也称为Ubuntu Jammy Jellyfish） 是 Ubuntu 操作系统的一个版本，于 2022 年 4 月发布。Ubuntu 是一种基于 Debian 的开源操作系统，它使用 Linux 内核，并且拥有庞大的社区支持。Ubuntu 22.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ee1f84f68453c27a030a564c6cac9bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d9e59f8cecb079663acc0a271437ea/" rel="bookmark">
			【计算机视觉】目标跟踪任务概述和算法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 1.1：目标跟踪VS目标检测：区别和联系 区别：
任务目标
目标跟踪任务的目标是在视频序列中跟踪一个特定目标的位置，即给定第一帧中的目标位置后，在后续帧中确定目标的位置。而目标检测任务的目标是在静态图像中检测和定位出现的目标，即在给定图像中找到所有目标的边界框。 数据输入
目标跟踪任务通常涉及处理视频序列，需要在连续的帧之间跟踪特定的目标。而目标检测任务则处理静态图像，每个图像都是独立的输入。 上下文信息利用
在目标跟踪任务中，由于连续帧之间存在时间和空间上的相关性，可以利用先前帧中的信息来帮助确定目标的位置。(前面所讲的限制区域搜索策略,就是利用这种连续帧之间的相关性,来确定下一帧的搜索区间)而目标检测任务通常只使用单个图像，缺乏时间上的上下文信息。(联系之前做的安全帽视频检测,虽然也是对视频进行处理,但是本质还是每一帧都是一个单独的处理对象,无任何联系) 联系
目标表示
目标跟踪任务和目标检测任务都需要对目标进行有效的表示，通常使用边界框来表示目标的位置和大小。 特征提取
两个任务都需要从输入数据中提取特征以表示目标。常见的特征提取方法包括使用卷积神经网络（CNN）提取图像特征或使用光流等方法提取视频序列中的运动特征。 目标类别识别
虽然目标跟踪任务的主要目标是确定目标的位置，但有时也需要对目标进行类别识别，即确定目标属于哪个类别。在目标检测任务中，类别识别是一个重要的子任务，需要确定每个检测到的目标的类别标签。 1.2：目标跟踪任务分类 单目标跟踪：给定一个目标，追踪这个目标的位置
单目标，单摄像头
无模型的，只有第一帧指定的 框
短期跟踪，不支持重新检测，丢失后，就跟踪失败
跟踪器不使用任何未来帧。主要逻辑 启动跟踪器 Setup tracker 设置目标区域 Read initial object region and first image 初始化跟踪器 Initialize tracker with provided region and image 循环 loop 读取下一张图像 Read next image 图像为空 if image is empty then 跳出循环 Break the tracking loop end if 更新跟踪器 Update tracker with provided image 记录目标区域 Write region to file 结束循环 end loop 清理跟踪器 Cleanup tracker 多目标跟踪：追踪多个目标的位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d9e59f8cecb079663acc0a271437ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04691902d582942256565d1c2fcc6c35/" rel="bookmark">
			初级爬虫实战——巴黎圣母院新闻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发现宝藏一、 目标二、简单分析网页1. 寻找所有新闻2. 分析模块、版面和文章 三、爬取新闻1. 爬取模块2. 爬取版面3. 爬取文章 四、完整代码五、效果展示 发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
一、 目标 爬取https://news.nd.edu/的字段,包含标题、内容，作者，发布时间，链接地址，文章快照 (可能需要翻墙才能访问)
二、简单分析网页 1. 寻找所有新闻 点击查看更多最新新闻&gt;&gt;点击查看档案
我们发现有两种方式查看所有新闻，一种是按照类别，一种是按照时间，经过进一步的观察我们发现按照时间查看新闻会更全，所以我们选择按照年份（按照月份和按照年份一样的效果）爬取
2. 分析模块、版面和文章 为了规范爬取的命名与逻辑，我们分别用模块、版面、文章三部分来进行爬取，具体如下
一个网站的全部新闻由数个模块组成，只要我们遍历爬取了所有模块就获得的该网站的所有新闻
一个模块由数页版面组成，只要遍历了所有版面，我们就爬取了一个模块 一个版面里有数页文章，由于该网站模块下的列表同时也是一篇文章，所以一个版面里只有一篇文章 一篇文章有标题、出版时间和作者信息、文章正文和文章图片等信息 三、爬取新闻 1. 爬取模块 按照如下步骤找到包含模块的dom结构并发送request请求并用bs4库去解析 class MitnewsScraper: def __init__(self, root_url, model_url, img_output_dir): self.root_url = root_url self.model_url = model_url self.img_output_dir = img_output_dir self.headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/122.0.0.0 Safari/537.36', 'Cookie': '替换成你自己的', } ... def run(): # 网站根路径 root_url = 'https://news.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04691902d582942256565d1c2fcc6c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a556d3140eb599db948e83553dfbb5e7/" rel="bookmark">
			ubuntu官方存档库目录结构说明(archive)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://archive.ubuntu.com/是Ubuntu操作系统的官方软件存档库，用户可以通过该网站下载与更新Ubuntu操作系统及其相关软件。它存储了各种 Ubuntu 软件包和更新，用户可以从这个网站获取最新版本的软件包以及安全性更新。
注意
目录 /ubuntu//ubuntu/dists其中以bionic为例bionic-backportsbionic-proposedbionic-securitybionic-updates /ubuntu/dists/bionic延申 /ubuntu/dists/bionic/main/ubuntu/dists/bionic/main/binary-amd64 /ubuntu/indices/ubuntu/pool/ubuntu/project延申阅读 /ubuntu/ dists：包含了每个Ubuntu发行版的目录indices： 存储了软件包的索引信息ls-lR.gz: 存储了整个目录结构的列表和压缩文件，用于方便查看和搜索。pool:存储了所有软件包的二进制数据，子目录按照软件包名的首字母进行分类存储project:包含Ubuntu项目管理信息，子目录可能包括团队联系、邮件归档等 ubuntu:包含Ubuntu发行版的具体信息，可能包含子目录 /ubuntu/dists 各个发行版的发布信息和软件包索引
其中以bionic为例 bionic是指Ubuntu 18.04 LTS版本（代号Bionic Beaver）的稳定软件存档库。这是包含Ubuntu操作系统及其应用程序的主要软件存档库，用户可以从这个存档库中获取并安装Ubuntu操作系统及其软件包。bionic存档库中的软件包经过充分测试和验证，是稳定版本的软件，适合大多数用户进行安装和使用。用户可以通过bionic存档库获取Ubuntu 18.04 LTS版本的主要更新和软件包。
bionic-backports 是Ubuntu操作系统中一个特殊的软件存档库，用于存储针对Ubuntu 18.04 LTS版本（代号为Bionic Beaver）的后期更新或较新版本的软件包。这些软件包可能包括最新的功能特性或改进，但可能会带来一些风险，因此它们不作为默认提供，而是作为backports的方式提供。用户可以选择手动启用bionic-backports源以获取这些软件包
bionic-proposed 用于存储预提案阶段的软件包。这些软件包是为了进行测试和验证，以便最终确定是否应该推送到正式的Ubuntu更新中。bionic-proposed中的软件包通常经过一定程度的测试，但仍可能包含一些问题或bug。用户可以选择手动启用bionic-proposed源，并帮助测试这些软件包以提供反馈，从而帮助改进他们并确保其质量。
bionic-security 是Ubuntu的一个特殊软件存档库，专门用于存储针对Ubuntu 18.04 LTS版本（代号为Bionic Beaver）的安全性更新。这些安全性更新包括修复已知的漏洞和安全问题的软件包。用户可以通过bionic-security源获取这些更新，以确保系统的安全性和稳定性。在这个存档库中，主要提供了修复安全漏洞和漏洞的软件包。
请注意，安全性更新对于保护系统免受恶意攻击和数据泄露非常重要，因此建议用户定期更新系统以获得最新的安全性更新。
bionic-updates bionic-updates是Ubuntu的一个特殊软件存档库，用于存储针对Ubuntu 18.04 LTS版本（代号为Bionic Beaver）的更新软件包。这些更新软件包包括修复已知问题、改进功能、提供新功能或增强性能的软件包。用户可以通过bionic-updates源获取这些更新，以确保他们的系统具有最新的软件功能和性能优化。 更新是为了保持系统的稳定性和可靠性，同时为用户提供更好的用户体验。建议用户定期检查和安装系统更新，包括bionic-updates中的更新，以确保系统保持最新和安全。
其他版本以此类推
Ubuntu 22.04 LTS （Jammy Jellyfish）Ubuntu 20.04 LTS（代号Focal Fossa）：维护期至2025年4月Ubuntu 18.04 LTS（代号Bionic Beaver）：维护期至2023年4月Ubuntu 16.04 LTS（Xenial Xerus） - 维护期至2024年4月
等等，具体所有的版本信息可以访问 https://wiki.ubuntu.com/Releases。 /ubuntu/dists/bionic 包含Ubuntu操作系统及其应用程序的主要软件存档库，用户可以从这个存档库中获取并安装Ubuntu操作系统及其软件包
main/：包含了Ubuntu操作系统的主要软件包，其中有各种软件和工具。restricted/：包含一些受限软件包，这些软件包可能包含专有或受版权保护的组件。universe/：包含了Ubuntu社区维护的软件包，这些软件包不属于官方维护的范围。multiverse/：包含非免费或受限制的软件包，这些软件包可能包含专有技术或受限制的功能。Release 文件：包含了有关Ubuntu 18.04 LTS版本（Bionic Beaver）的发布信息，例如软件包清单、版本号等。Packages 文件：包含了包含在每个子目录中的软件包的列表及其相关信息。其他相关文件和目录：还可能包括其他子目录和文件，用于存放更新、安全性补丁、元数据等。by-hash/：包含根据软件包哈希值组织的软件包文件。Contents-amd64.gz：amd64架构软件包内容索引文件。Contents-i386.gz：i386架构软件包内容索引文件。InRelease：用于数字签名和验证的文件。Release：包含有关发行版的信息和软件包清单的文件。 延申 Release"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a556d3140eb599db948e83553dfbb5e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0182f055623eb2a44abbc14ddb082c/" rel="bookmark">
			分享10个ai人工智能ppt生成软件，一键轻松搞定PPT制作！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ai 人工智能发展至今，已经诞生了各式各样的 AI 软件，最常见的如 AI 写作软件、AI 绘画软件、AI 人工智能 ppt 生成器、AI 人工智能抠图软件等等。对每天要面对各类文档、演示文稿（PPT）的职场人来说，最被需要的 AI 软件莫过于 ai 人工智能 ppt 生成器。
想象一个日常办公的场景，你正要准备一个重要的演讲，但却被繁琐的 PPT 制作过程困扰。现在，有了 AI 人工智能 ppt 生成器，这些问题都将一去不复返。这些 AI 生成 PPT 工具以其高效、便捷和用户友好的特性，为我们节省了大量宝贵的时间。它们能够理解我们的 PPT 制作需求，提供定制化的解决方案，让生成的 PPT 富有表现力，更加吸引人！
那么，这些 AI 人工智能 ppt 生成器是如何轻松搞定 PPT 制作的呢？是什么使它们如此出色呢？接下来让我们一起深入探索！
ai 人工智能 ppt 生成软件是什么？ ai 人工智能 ppt 生成器，也叫 ai 生成 ppt 软件，是一种利用 AI 人工智能技术帮助用户创建 PPT 的工具。ai 人工智能 ppt 生成器的核心功能是根据用户输入的 PPT 主题或文本内容，自动分析、识别主题和关键词，然后从预设的 PPT 模板库中选取合适的设计元素和布局，自动生成专业级别的 PPT。
一般来说，AI 人工智能 PPT 生成器的工作流程如下：
用户提供内容：用户将他们想要在 PPT 中展示的内容输入或粘贴到 ai 人工智能 ppt 生成器中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0182f055623eb2a44abbc14ddb082c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153128f1f7e182ee7fd56b184914f3b3/" rel="bookmark">
			RabbitMQ 安装登陆 提示：User can only log in via localhost
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RabbitMQ默认提供了一个guest/guest用户，但是从3.3.0 版本以后该账号只能localhost登陆（User can only log in via localhost）
解决办法：通过命令行创建一个管理员账号
通过以下命令创建一个用户user，密码为user123456
rabbitmqctl add_user user user123456 创建完成之后通过以下命令设置用户标签为administrator
rabbitmqctl set_user_tags user administrator 给用户user赋予权限，授予user用户可访问虚拟主机 /，并在所有的资源上具备可配置、可写及可读的权限
rabbitmqctl set_permissions -p / user ".*" ".*" ".*" 最后，通过以下命令可以看出当前的所有用户
rabbitmqctl list_users 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee700da56a9968cd5cc49f7b9293fc2/" rel="bookmark">
			python note: This error originates from a subprocess, and is likely not a problem with pip.error:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误通常表示在尝试构建Python软件包时出现了问题。请按照以下步骤进行排除：
1. 检查错误输出： 首先，检查错误输出以获取有关问题的更多详细信息。在你的错误消息中，关键的信息可能在 "Getting requirements to build wheel did not run successfully" 部分。
2. 确认依赖项： 确保你的项目中的依赖项已正确安装。可以尝试手动安装项目的依赖项，看看是否会出现任何其他错误。
bash pip install -r requirements.txt 3. 查看环境： 确保你的Python环境设置正确，并且安装了构建工具（如`setuptools`和`wheel`）。你可以尝试更新这些工具：
bash pip install --upgrade setuptools wheel 4. 检查Python版本： 有时，特定的Python版本可能与某些软件包不兼容。确保你使用的Python版本与软件包的要求相匹配。
5. 尝试清理缓存： 有时，pip缓存可能会导致问题。尝试清理缓存并重新运行安装命令：
bash pip cache purge 6. 查找特定软件包的问题： 如果问题似乎与特定软件包相关，请查看该软件包的GitHub存储库或其他社区支持页面，看看是否有其他人遇到相似的问题，或者软件包的文档是否提供了解决方案。
7. 升级pip： 确保你使用的是最新版本的pip：
bash pip install --upgrade pip 8. 操作系统权限： 在某些情况下，特定的系统权限问题可能导致此类错误。确保你有足够的权限执行pip安装。
如果你仍然无法解决问题，提供更多的错误输出可能有助于找到问题的根本原因。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cbb6e4d1d2faf1d70f5ea2a4a5c39bc/" rel="bookmark">
			记spring boot启动出现Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天拉下了一个新的springboot工程，启动时出现了Unable to start web server; nested exception is org.springframework.context.ApplicationContextException: Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean.这个异常。在网上搜索这个错误，有几种说法。
说法一：是因为缺少一个spring-boot-starter-web依赖。检查pom文件，发现这个依赖已经被引入了，所以不是这个问题。
说法二：是没有添加@EnableAutoConfiguration这个注解。但是在启动类中已经有@SpringBootApplication这个注解了，这个注解已经包含了@EnableAutoConfiguration注解，所以也不是这个原因，那么到底是什么原因呢。
检查异常发生地点
点进去抛出异常的代码
可见是在调用getWebServerFactory（）方法时候发生错误，没有找到ServletWebServerFactory这个bean，说明在sping容器启动时没有将其注册进去，缺少相关依赖。没有对应的servelt容器，工程当然也就启动不起来。这里多讲一下，springboot工程会通过@EnableAutoConfiguration这个注解去拉去默认配置，该注解通过@Import注解导入了AutoConfigurationImportSelector类。其实这个类，就是导入通过加载配置文件，加载了很多工厂方法的配置类。最终会加载 META-INF/spring.factories这些文件，通过这些文件完成自动装配。@Import注解加载了tomcat，jetty，undertow三个web服务器的配置类。由于没有导入jetty和undertow的相关jar包，这两个类实例的不会真正的加载。到这里分析，为什么会缺少相应的servlet容器？springboot不默认加载了tomcat容器吗，因为tomcat的相关jar包已经在spring-boot-starter-web中引入了，按照之前我们的分析，实际上被加载的容器应该是tomcat，为什么还会找不到呢？
那么此时我们要分析一下整个工程的依赖情况，看tomcat相关jar包是否被真实的引入。使用mvn dependency:tree命令，对工程进行依赖分析，定位到tomcat相关依赖。
此时可以发现，tomcat相关依赖的scope类型是provied的，provide类型不会只会参与编译和测试，并不会参与运行，所以在工程启动运行是找不到相关依赖，所以就会报错。
将pom中的&lt;scope&gt;provided&lt;/scope&gt;或者整个依赖注释掉，默认的scope类型是compile，参与编译测试和运行。重新启动工程，启动OK。
参考文章：
https://blog.csdn.net/qq_29551611/article/details/119268637
https://baijiahao.baidu.com/s?id=1719114849179396100&amp;wfr=spider&amp;for=pc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff218e66610b57bdd1f0354519a16a3/" rel="bookmark">
			Python中无法使用Selenium，显示ValueError: Timeout value connect was ……, but it must be an int, float or None
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期重装了系统，需要做个爬虫，最初想用Selenium和Msedge模拟浏览器操作，但总是不成功，即使是用webdriver打开网页这样最简单的操作，也无法做到，总是显示ValueError: Timeout value connect was &lt;object object at 0x……&gt;, but it must be an int, float or None。
怀疑是设置问题，将对应浏览器的webdriver版本核对一遍，包括路径，均没有问题，但就是出错。以前曾用Selenium和Chrome浏览器做过爬虫，于是又改用Chrome试了试，但结果还是出现一样的错误。
查了许多资料，始终没有提到如何解决。最后直接搜索错误信息，终于在csdn.net某大神博客上找到了解决办法。python selenium报错ValueError: Timeout value connect was ＜...＞, but it must be an int, float or None._流势的博客-CSDN博客
方案一：
文章指出，出现这一问题，是selenium库和urllib3库版本不兼容所致。我最初安装的Selenium版本是3.141.0，Urllib3的版本是2.0.3，这两个版本的库是不兼容的，如果安装的是这两个库，那么在使用selenium时，就会显示上述错误。
在Pycharm中，选择File—Setting——Project：…——Python Interpreter，点“+”
输入urllib3，找到后，勾选Specify version指定库的版本为1.26.2，点击Install Package。把urllib3版本降级到1.26.2后，错误全部消失 。
方案二：根据文末BH4EOD的评论，将selenium降为3.3.1，也可以解决问题。没自己试验过，如果方法一解决不了，也可以试下这个方法。
方案三：因python版本不对应，导致出错。根据weixin_38686363在文末评论，他直接调用conda虚拟环境用的python3.10会出错，后来换成python 3.8.10，问题就解决了。
方案二和三，我没亲身体验过，不过是别的网友成功过的。如果方案一解决不了，可以试一下二和三。希望遇到问题的网友把解决这一问题的办法能在留言里写一下。我会把留言中的问题解决办法归集在一起，让大家的经验帮助更多的人。
其他问题及解决方案：
1、urllib3版本无法降到1.26.2。根据网友Th3Shine在文末的评论，把python版本降到3.10可顺利将urllib3版本降到1.262。
2、显示错误‘No module named 'urllib3.packages.six.moves'。根据网友tomniu8998和weixin_46250057在文末的回复，把selenium版本调整到3.3.1配合urllib3版本1.26.2，这一问题基本都能解决。若仍无法解决，可更换selenium版本：pip install urllib3==2.1.0
pip install selenium==4.8.0
两点心得：
一是编程遇到难以解决的问题时，不妨试着直接查找一下错误信息。这样也许你能直接找到答案，往往比自己去想快的多，比如这次的问题，如果不知道两个包不兼容的话，很自己解决这一问题。
二是发现编程问题解决办法后，应该在博客上做好记录，这样不仅便于自己总结和查找，而且不一定什么时候就能帮助别人解决问题，节省其它网友的大量时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8bc2be80b216902d944907d1fb6300d/" rel="bookmark">
			python 常用保留字（关键字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的保留字（也称为关键字）是那些被编程语言语法赋予了特殊意义的单词。这些词不能用作标识符，例如变量名、函数名或任何其他用户定义的名字。每个保留字都有其特定的用途和规则。
截至Python 3.8版本，Python的保留字有以下这些：
False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield 以下是一些保留字的示例及其说明：
False, True: 布尔值False和True。None: 表示null值。and, or, not: 逻辑运算符。if, elif, else: 条件语句。for, while: 循环控制语句。break, continue: 在循环中使用，分别用于退出当前循环和跳过当前循环的剩余部分，继续下一次循环。def: 用于定义函数。return: 在函数中用来返回值。class: 用于定义类。try, except, finally, raise: 异常处理语句。import, from, as: 用于模块导入。lambda: 定义匿名函数。with: 简化异常处理，同时自动处理资源清理工作。async, await: 用于定义和处理异步操作。 你可以通过Python的内置模块keyword来查看当前Python版本的所有保留字：
import keyword print(keyword.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8bc2be80b216902d944907d1fb6300d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c92a64e3e6cd56d3f612c249ed9d17/" rel="bookmark">
			在使用idea时java: 程序包jakarta.servlet.http不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在创建servlet工程时，出现jakarta的包找不到，Servlet无法导入，很有可能是Tomcat的版本问题，Tomcat10相较于Tomcat9和8，在Servlet方面，对于javax.servlet包名改为了jakarta.servlet。
这时我们需要在项目下面寻找Tomcat下面的lib包，lib里面找到servlet-api-jar，复制，然后导入到
WEB-INF里面的lib包下即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef7993b39470c3671627d071cb2fbb69/" rel="bookmark">
			python3ide手机安卓版下载,python安卓版下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈python3ide手机安卓版下载，以及python安卓版下载安装，希望对各位有所帮助，不要忘了收藏本站喔。
这篇文章主要介绍了python3下载手机安卓版，具有一定借鉴价值，需要的朋友可以参考下。希望大家阅读完这篇文章后大有收获，下面让小编带着大家一起了解一下python有趣作品。
Source code download: 本文相关源码
官网地址：Welcome to Python.orgThe official home of the Python Programming Languagehttps://www.python.org/https://www.python.org/https://www.python.org/
目录
1、首页下载：
2、下载页面下载：
3、历史版本下载：
2、Python3.12版本的安装：
1、双击打开安装包，开始进行安装。
​2、自定义安装：
3、下一步：
4、修改安装目录，选择使用权限：
5、安装ing：
​6、安装完成：
7、安装成功验证：
1、Python的下载 1、首页下载： 打开官网，找到Downloads标签点击弹出的下载标签页中如下图所示的灰色按钮或者直接下载：
2、下载页面下载： 或者点击下载按钮跳转到下载标签页，点击如下图的Download Python 3.12.0按钮也可下载最新的安装包：
3、历史版本下载： 如有需要下载历史安装包的，也可在此页面中下拉找到如下所示区域进行下载：
2、Python的安装： 1、双击打开安装包，开始进行安装适合练手的python项目。 2、自定义安装： 第一步勾选如下图中的两个框，通常我们选择自定义安装即点击第二步中的Customize installation 按钮安装，下面我们选择自定义安装
Use admin privileges when installing py.exe
在windows系统中，管理员账户Administrator具有最高的访问权限，有访问其它账户的权限，而个人账户之间是没有互相访问权限的。
该项勾选，以管理员权限安装python的可执行程序。以管理员权限安装python，其它windows
账户(User)登录系统后都可以使用python。
若该项不勾选，且当前账户是个人账户，安装python后，其它非管理员账户登录到windows系统不能使用这个账户安装的python。
Add python.exe to PATH
该项勾选，添加python到windows的系统路径，方便操作系统自动识别。
3、下一步： 4、修改安装目录，选择使用权限： Install Python 3.12 for all users
为所有windows账户都可用，该项是否勾选可根据需求而定。
Associate files with Python(requires the 'py'launcher)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef7993b39470c3671627d071cb2fbb69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e56adadb2d5d9a2840b4ebe3e613f7/" rel="bookmark">
			专业认知 | 用 Python 制作 13 个小游戏，边玩边学！(含源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		119
（给Python开发精选加星标，修炼Python技术）
经常听到有朋友说，学习编程是一件非常枯燥无味的事情。其实，大家有没有认真想过，可能是我们的学习方法不对？
比方说，你有没有想过，可以通过打游戏来学编程？
今天我想跟大家分享几个Python小游戏，教你如何通过边打游戏边学编程！
1、吃金币 源码分享：
import os import cfg import sys import pygame import random from modules import * '''游戏初始化''' def initGame(): # 初始化pygame, 设置展示窗口 pygame.init() screen = pygame.display.set_mode(cfg.SCREENSIZE) pygame.display.set_caption('catch coins —— 九歌') # 加载必要的游戏素材 game_images = {} for key, value in cfg.IMAGE_PATHS.items(): if isinstance(value, list): images = [] for item in value: images.append(pygame.image.load(item)) game_images[key] = images else: game_images[key] = pygame.image.load(value) game_sounds = {} for key, value in cfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e56adadb2d5d9a2840b4ebe3e613f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c950e3402d2770f773652ebcde6b7e/" rel="bookmark">
			GitHub Copilot 登录失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人最近常用的开发软件是PyCharm和Visual Studio，最近临近期末，代码最强辅助GitHub Copilot却出现了登录失败的问题，让人非常头疼
1. 我遇到的登录失败长什么样 据说GitHub Copilot的登录失败千奇百怪，这次我有幸遇到的是无法登陆
在PyCharm中，点击Log In To GitHub后，页面就一直显示在获取设备验证码
过了一会儿，右下角弹出错误提示框，显示connect timeout，悲
2. 解决方案——伟大的手动代理 查阅网友的解决方案之后发现，error code: -32603 应该是由于代理出错导致的问题（应该跟我的小猫咪Clash脱不了关系hhhh），所以解决方案就是给IDE设置一个手动代理~
Step1 如下图，对于JetBrains全家桶，打开Settings，香泽System Settings - HTTP Proxy，选择Manual proxy configuration，输入下图中的主机名和端口号
Step 2 重启IDE！重启IDE！重启IDE！重要的事情说三遍！一定要重启保证设置的手动代理生效！
Step 3 接下来就是登录的常规操作，login，然后在登录验证界面输入设备验证码，通过验证即可~
如果打开GitHub有困难，记得挂梯子
验证成功之后，就可以继续享用香香的GitHub Copilot学生优惠~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b598af1842b1ca1c4fe0f0f9968d0b94/" rel="bookmark">
			前端删除node-module和清除缓存的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、删除node modules文件 前端删除node_modules包，可以右键一键删除，但是当包体积很大时，就会要删除很久，这时候可以使用命令行进行删除，可以跟快删掉node_modules包。命令如下：
先安装： npm install -g rimraf 再执行： rimraf node_modules 2、清除npm缓存 (1) 直接删除缓存文件，删除C:\Users\用户名.npmrc 这个文件。 (2) 执行：npm cache clean --force，同样达到清除缓存文件的目的。 3.rm -f /node_modules
4.Remove-item -Force -Recurse node_modules
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f77aa109a08e89fb42227036a00883/" rel="bookmark">
			RabbitMQ介绍&#43;使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、rabbitmq介绍二、rabbitmq服务器安装及环境配置1.下载并安装rabbitmq服务器2.下载并编译rabbitmq-c静态库 三、rabbitmq使用1.rabbitmq架构及各组件功能2.rabbitmq通信方式2.1扇出模式（fanout）2.2直连模式（direct）2.3主题模式（topic） 3.接口函数介绍3.1通用函数3.2接收端函数3.3发送端函数 四、参考网站 一、rabbitmq介绍 ​ RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。
​ RabbitMQ优势：
可靠性(Reliablity)：使用了一些机制来保证可靠性，比如持久化、传输确认、发布确认。灵活的路由(Flexible Routing)：在消息进入队列之前，通过Exchange来路由消息。对于典型的路由功能，Rabbit已经提供了一些内置的Exchange来实现。针对更复杂的路由功能，可以将多个Exchange绑定在一起，也通过插件机制实现自己的Exchange。消息集群(Clustering)：多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。高可用(Highly Avaliable Queues)：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。多种协议(Multi-protocol)：支持多种消息队列协议，如STOMP、MQTT等。多种语言客户端(Many Clients)：几乎支持所有常用语言，比如Java、.NET、Ruby等。管理界面(Management UI)：提供了易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。跟踪机制(Tracing)：如果消息异常，RabbitMQ提供了消息的跟踪机制，使用者可以找出发生了什么。插件机制(Plugin System)：提供了许多插件，来从多方面进行扩展，也可以编辑自己的插件。 二、rabbitmq服务器安装及环境配置 1.下载并安装rabbitmq服务器 ​ 首先进入rabbitmq官网（rabbitmq.com)
​ 向下滑动滚轮找到Download+Installation,点击进入
​ 点击Install Windows安装windows版本
​ 向下滑动滚轮找到下图框住的两个下载链接
​ 下载的软件位置，先安装otp.exe，鼠标右键以管理员方式运行。接着选取要安装的路径，然后一路傻瓜式安装 next 下一步，安装即可。不要安装在中文或带空格的文件路径下。
​ 配置系统环境变量：右键此电脑 - 属性 - 高级系统设置 - 环境变量。
​ 接着打开 - 此电脑（文件资源管理器） 找到刚刚我们安装的文件 bin 目录下，复制路径 ctrl+c 切换窗口到环境变量，找到系统变量 path - 编辑
​ 新建 - ctrl + v 粘贴刚才我们复制的路径，然后三次确定，关闭环境变量窗口
​ 安装 RabbitMQ：右键管理员运行，然后选择安装路径，接着一路 next 下一步，遇到弹窗点允许，没有弹窗则无视（不要安装在中文或带空格的文件路径下）。安装完成后也要配置系统环境变量：配置的方法和上面一致，路径是安装的文件下的sbin下。
​ ​ 安装完成后找到安装文件路径，找到 sbin 目录下，全选路径 输入 cmd，打开cmd命令窗口，运行下面命令（这个指令是为了启动web界面）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f77aa109a08e89fb42227036a00883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056b3f64ef0f14b9976b9de5125745c4/" rel="bookmark">
			【JAVA】Collections.sort()方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Collections.sort() 是 Java 集合框架（Java Collections Framework）中的一个静态方法，用于对列表（List）中的元素进行排序。此方法利用了 Java 的泛型机制，可以很方便地对各种类型的列表进行排序。
源码方法体：
参数 list：需要排序的列表。列表中的元素必须实现了 Comparable 接口，以便能够比较它们的大小。 二、使用示例 1、普通使用 假设你有一个 Integer 类型的列表，你可以使用 Collections.sort() 方法对它进行排序：
import java.util.ArrayList; import java.util.Collections; import java.util.List; public class SortExample { public static void main(String[] args) { List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); numbers.add(3); numbers.add(1); numbers.add(4); numbers.add(1); numbers.add(5); numbers.add(9); numbers.add(2); numbers.add(6); numbers.add(5); numbers.add(3); numbers.add(5); System.out.println("Before sorting:"); for (int number : numbers) { System.out.print(number + " "); } System.out.println(); Collections.sort(numbers); System.out.println("After sorting:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/056b3f64ef0f14b9976b9de5125745c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e29df8b3c3c802f505a71bc302bf7e/" rel="bookmark">
			前端如何上传图片给后台？如何传递 multipart/form-data 类型的数据？图片大小、格式检查?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 如何上传图片？ 图片上传需要传二进制流，请求头的 content-type 类型需为 multipart/form-data，传递的格式如下图所示
前后端交互通常为：
先调用接口上传二进制流图片然后再上传表单其他内容（第一步通常会返回后台存储的图片id，第二步会将图片id传递给后台） 注：目前我只用过以上这种方法，我能想到的另一种方法是表单及其图片都用 multipart/form-data 格式传递过去，但我和后台目前没用过这种方法
2. 如何传递 multipart/form-data 类型的数据？ 方法 1： 显式的设置 content-type：multipart/form-data；（没直接用这个是由于工作的项目封装了 http 方法，不支持我直接设置）
方法 2： new formData()，使用 for 遍历对象，调用 formDataObj.append() 方法添加键值对；（此处可在 http 公共函数直接新增一个这样的方法，避免每次都需要写）
var formData = new FormData() for (var key in data) { formData.append(key, data[key]) } return formData 方法 3： axios 自带 transformRequest 方法，在发送请求前对 data 做预处理，transformRequest接受一个数组，第二个函数将处理上一个函数的结果。类似的函数还有 transformResponse 。
axios.create({ transformRequest: [function (data, headers) { if (data instanceof Object) { const formData = new FormData(); for (const key in data) { formData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4e29df8b3c3c802f505a71bc302bf7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/236802a1f7be9c5ed1d38d882d729353/" rel="bookmark">
			javacv FFmpegFrameGrabber 阻塞问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacv&lt;/artifactId&gt; &lt;version&gt;1.5.7&lt;/version&gt; &lt;/dependency&gt; 修改org.bytedeco.javacv.FFmpegFrameGrabber.java源码 //1、在createDefault方法后添加 以下代码 /** * 读流超时时间 : 20秒 */ private static final int FRAME_READ_TIMEOUT = 20 * 1000; // 增加监听 private final AtomicLong lastFrameTime = new AtomicLong(System.currentTimeMillis()); private boolean interrupt_grab = false; public boolean isInterrupt_grab() { return interrupt_grab; } private final org.bytedeco.ffmpeg.avformat.AVIOInterruptCB.Callback_Pointer cp = new org.bytedeco.ffmpeg.avformat.AVIOInterruptCB.Callback_Pointer() { @Override public int call(Pointer pointer) { // 0:continue, 1:exit if (lastFrameTime.get() + FRAME_READ_TIMEOUT &lt; System.currentTimeMillis()) { interrupt_grab = true; try { // 读流时使用了Process p = Runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/236802a1f7be9c5ed1d38d882d729353/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/477/">«</a>
	<span class="pagination__item pagination__item--current">478/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/479/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>