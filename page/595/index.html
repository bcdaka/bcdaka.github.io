<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ee2714344c3b7e0c5f1635d696e510/" rel="bookmark">
			数据之海 — 探索大数据的无尽可能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据之海 — 探索大数据的无尽可能 💘 💘1. 什么是大数据？💘 💘2. 大数据的应用领域💖 💖2.1 商业决策💖 💖2.2 医疗保健💖 💖2.3 城市规划💖 💖2.4 金融风控 💘 💘3. 数据之海中的宝藏💖 💖3.1 数据清洗与预处理💖 💖3.2 数据可视化💖 💖3.3 数据分析与机器学习 💘 💘4. 结语 博主 默语带您 Go to New World.
✍ 个人主页—— 默语 的博客👦🏻
《java 面试题大全》 🍩惟余辈才疏学浅，临摹之作或有不妥之处，还请读者海涵指正。☕🍭
《MYSQL从入门到精通》数据库是开发者必会基础之一~
🪁 吾期望此文有资助于尔，即使粗浅难及深广，亦备添少许微薄之助。苟未尽善尽美，敬请批评指正，以资改进。！💻⌨
💘 💘 💖 💖
摘要：
在信息爆炸的时代，大数据已经成为当今社会的瑰宝，而数据科学的发展为我们揭开了一个神秘而广阔的世界 —— 数据之海。本文将带领读者踏上一段奇妙的探索之旅，深入了解大数据的定义、应用领域以及对未来的巨大影响。我们将揭示数据之海中隐藏的宝藏，并通过精心设计的实例演示，帮助新手更好地理解和学习数据科学的精髓。
💘 💘1. 什么是大数据？ 大数据，这个词汇如今无处不在，但它究竟意味着什么呢？大数据是指规模庞大、种类繁多、增长迅速的数据集合。这些数据涵盖了各个领域，包括社交媒体、传感器信息、在线交易记录等。它们以前所未有的速度和量级产生，并成为数据科学家和决策者的宝贵资源。
在当今信息爆炸的时代，大数据已成为一颗璀璨的明星，高挂在科技与商业的天空中。大数据是由海量、多样和迅速增长的数据集合组成。它们涵盖了各个领域，包括社交媒体的用户行为、传感器产生的物理信息、在线交易记录等。这些数据以前所未有的速度和数量不断涌现，给我们带来了前所未有的机遇和挑战。
就像一片广阔的汪洋，大数据蕴藏着丰富的信息和潜在的价值，它是洞察商机的宝藏，也是指导决策的智慧之源。数据科学家和决策者们正在积极探索这片未知的数据之海，以期在波涛汹涌的数据浪潮中寻找着宝贵的财富。
这些海量数据的产生源源不断，如今几乎所有活动都会产生数据，无论是购物、搜索、社交还是日常生活中的各类传感器。这些数据像无穷的海浪一样汹涌而来，对我们的技术和处理能力提出了极大的挑战。因此，处理大数据需要采用先进的技术和方法，以快速、高效地从这片数据之海中提取出有价值的信息。
大数据的意义不仅在于它们的数量庞大，更重要的是蕴含其中的信息和洞察力。在这片数据之海中，我们可以发现用户的喜好趋势、市场的需求演变，甚至是自然界的规律。通过对大数据的深度分析，我们能够更好地了解客户需求、优化产品设计，甚至是预测未来的趋势，为企业的发展和决策提供强大的支持。
在这片充满机遇的数据之海中，数据科学家和决策者需要具备一颗勇敢的心和锐利的洞察力，他们必须拥有挖掘数据的技能，从数据中发现问题，找到解决方案，开拓新的商业机会。而对于新手来说，学习大数据技术可能会显得有些陌生和困难，但只要拥有好奇心和持之以恒的学习态度，就一定能在这片数据之海中找到属于自己的宝藏。
无论是企业家、学者、还是普通大众，每个人都可以成为这片数据之海的探险者。只要我们学会驾驭数据的船桨，掌握数据的方向，就能在这片海洋中遨游自如，发现无限的可能性，为社会进步和个人成长贡献一份力量。让我们携手共航，探索这片充满激情和未知的数据之海！
💘 💘2. 大数据的应用领域 数据之海孕育着无尽的应用领域，其中一些令人瞩目的应用包括：
💖 💖2.1 商业决策 在商业领域，大数据应用的最为显著。海量的数据可以被挖掘、分析，从中提取出市场趋势、客户偏好和产品研发方向。企业可以借助大数据洞察市场需求，了解客户的消费习惯，并根据数据分析结果做出更加明智的决策。例如，电商平台可以通过大数据分析实时跟踪用户的购物行为，然后根据这些数据为用户推荐个性化的商品和广告。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ee2714344c3b7e0c5f1635d696e510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d692d573eab10b673786abb47a0adb7c/" rel="bookmark">
			【Python】Anaconda以及Pip配置清华镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Python】Anaconda以及Pip配置清华镜像源 文章目录 【Python】Anaconda以及Pip配置清华镜像源前言一、Conda配置清华镜像源1. 查看镜像源2. 删除添加源，恢复默认源3. 添加清华镜像源 二、Pip配置清华镜像源1. 临时使用清华镜像源2.永久配置 三、国内常用的镜像源 前言 提示：
最近换了新电脑，在使用Anaconda安装Python包时，系统会自动从默认源下载安装包，但是由于网络访问限制或网络连接速度较慢等原因，会导致安装失败或安装速度较慢。
因此，为了提高安装速度和稳定性，一些用户选择使用国内的镜像源，如清华镜像源。配置清华镜像源可以让用户从国内的服务器上下载Python包，这可以加快下载速度，并减少由于网络访问限制导致的下载失败等问题。
一、Conda配置清华镜像源 1. 查看镜像源 conda config --show channels 2. 删除添加源，恢复默认源 conda config --remove-key channels 3. 添加清华镜像源 #添加镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 #终端显示包从哪个channel下载，以及下载地址是什么 conda config --set show_channel_urls yes 二、Pip配置清华镜像源 1. 临时使用清华镜像源 代码如下（示例）：
# some-package代表你需要安装的包 pip install -i https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d692d573eab10b673786abb47a0adb7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2856e5080dee7d45aa71a305dd9e925/" rel="bookmark">
			Android Studio 所有历史版本下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 所有历史版本下载 本篇文章将给大家讲解如何下载Android Studio的过往历史版本，以及解决看到的历史版本不完整的问题。
第1步： 打开历史版本的Android Studio官网下载地址：下载地址
第2步： 点击我同意按钮
这时候就可以看到历史版本了
第3步： 我们会发现这里的历史版本并不完整，这时我们切换一下语言为英文
切换语言后可以看到完整的历史版本，实际上URL也是发生了改变的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e2db2c82658884d056e97d752448c7/" rel="bookmark">
			JSON parse error: Cannot deserialize value of type `java.util.ArrayList＜java.lang.Long＞` from Object
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON parse error: Cannot deserialize value of type `java.util.ArrayList&lt;java.lang.Long&gt;` from Object value (token `JsonToken.START_OBJECT`); nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize value of type `java.util.ArrayList&lt;java.lang.Long&gt;` from Object value (token `JsonToken.START_OBJECT`)\n at [Source: (org.springframework.util.StreamUtils$NonClosingInputStream); line: 1, column: 1]
接口:
public AjaxResult editList( String unit, String ruleValue, @RequestBody List&lt;Long&gt; ids){} 第一次写后端接口 前端传过来三个参数, 其中一个参数类型为id组成的数组, 后端对这个ID数组的类型设置成List&lt;Long&gt;类型, 请求接口报上面的错误,后来给ids前面加了个@RequestBody注解 再次请求又报下面这个错:
Uncaught (in promise) Error: Required request parameter 'ruleIds' for method parameter type List is not present
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e2db2c82658884d056e97d752448c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8d759e4ab90ab70452ed782ff623ab/" rel="bookmark">
			python Pandas.rank() 排名函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Pandas.rank() 函数详解一、参数解析二、案例分享默认排名`降序: ascending = False``method = 'min'``method = 'max'``method = 'first'``method = 'dense'``na_option='bottom'``pct = True` Pandas.rank() 函数详解 一、参数解析 method：指定排名时的策略。 默认值为 'average'，表示相同值的项将会获得平均排名。可选的取值还包括 'min'：相同值的项将获得最小排名；'max'：相同值的项将获得最大排名；'first'：相同值的项将获得第一次出现时的排名；'dense'。相同值的项将获得连续排名。 ascending：指定排名的顺序。 默认值为 True，升序。设置为 False 降序。 na_option：指定如何处理缺失值（NaN）。 默认值为 'keep'，缺失值不参与排名。设置为 'top' 则将缺失值放在排名结果的顶部。设置为 'bottom' 则将缺失值放在排名结果的底部。 pct：指定是否返回百分比排名。 默认值为 False 表示返回实际的排名值。设置为 True 则返回相对于总项数的百分比排名值。 二、案例分享 import pandas as pd data = {'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Emma', 'Frank'], 'Score': [90, 85, 85, 75, None, 78]} df = pd.DataFrame(data) 默认排名 升序、忽略缺失值；遇到相同数值（如score=85），排名会平分 df['Rank'] = df['Score'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee8d759e4ab90ab70452ed782ff623ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b0495da620374aed675531fc663b0e6/" rel="bookmark">
			深入理解 Java Bean 的生命周期及各个阶段解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言：一、什么是Java Bean二、Bean的生命周期概述三、Bean的创建阶段四、属性设置阶段初始化阶段六、使用阶段七、销毁阶段 引言： Java Bean是Java编程中经常使用的重要概念，它是可重用、可移植、可序列化的组件。在Java开发中，我们常常会遇到Bean对象，但是对于Bean的生命周期和各个阶段可能并不完全了解。本文将深入探讨Java Bean的生命周期，逐步解析Bean对象从创建到销毁的各个重要阶段。
一、什么是Java Bean Java Bean是一个符合特定规范的Java类，通常具有私有的成员变量、公共的getter和setter方法，以及一个无参构造函数。这些特性使得Bean对象易于序列化和反序列化，并且被广泛应用于Java开发中，尤其在框架和应用程序中经常被用作数据封装和组件复用。
二、Bean的生命周期概述 Java Bean的生命周期从创建到销毁可以分为以下五个关键阶段：
创建阶段（实例化 Bean）：当使用构造函数或者工厂方法创建Bean对象时，就进入了创建阶段。
属性设置阶段：在Bean对象创建后，通过setter方法设置Bean的各个属性。
初始化阶段：当Bean的属性设置完成后，会触发初始化回调方法，进行一些额外的初始化工作。
实现了各种 Aware 通知的⽅法，如 BeanNameAware、BeanFactoryAware、
ApplicationContextAware 的接⼝⽅法执⾏ BeanPostProcessor 初始化前置⽅法执⾏ @PostConstruct 初始化⽅法，依赖注⼊操作之后被执⾏执⾏⾃⼰指定的 init-method ⽅法执⾏ BeanPostProcessor 初始化后置⽅法 使用阶段：在初始化完成后，Bean对象处于可用状态，可以供应用程序使用。
销毁阶段：当Bean对象不再需要时，会触发销毁回调方法，进行资源释放等清理工作，销毁容器的各种⽅法，如 @PreDestroy、DisposableBean 接⼝⽅法、destroy-method
@PostConstruct 用于在 bean 初始化之后执行特定的方法。标记了 @PostConstruct 注解的方法会在 bean 的依赖注入完成后立即执行。通常在这个方法内进行一些初始化操作，例如数据库连接的建立或资源的加载。
@PreDestroy 用于在 bean 销毁之前执行特定的方法。
标记了 @PreDestroy 注解的方法会在容器或应用程序关闭或 bean 被销毁前调用，用于清理资源，例如关闭数据库连接或释放文件句柄等。
流程如下图：
我们可以以生活中的场景来理解Bean的生命周期
比如我们现在结婚都需要买新房，那么从买房子到使用还需要这样一段流程：
先交钱买房子（实例化）装修 （设置属性）给家里添置各种家具（初始化）进行入住（使用Bean）用够70年然后交还（销毁）
通过这样的案例我们应该能更好的理解Bean的生命周期 三、Bean的创建阶段 在Bean的创建阶段，可以通过构造函数或者工厂方法来创建Bean对象。构造函数用于创建对象的实例，而工厂方法则通过调用静态方法来获取Bean的实例。在创建阶段，还可以利用依赖注入(DI)等技术，将依赖的对象传递给Bean。
// 示例1：使用构造函数创建Bean对象 public class Person { private String name; private int age; public Person(String name, int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b0495da620374aed675531fc663b0e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7a7d58e739f2f35920e182e34745e6/" rel="bookmark">
			Spring-Kafka如何实现批量消费消息并且不丢失数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring-Kafka如何实现批量消费消息并且不丢失数据 先给答案：
// 批量消费配置: 1批量, 2手动提交 factory.setBatchListener(true); factory.getContainerProperties().setAckMode(AbstractMessageListenerContainer.AckMode.MANUAL_IMMEDIATE); // 调大fetch的相关参数, 以便于提升吞吐量, 但会增大延时 // 一次poll操作最大获取的记录数量 propsMap.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords); // max.poll.records, 缺省是500 // 一次fetch操作最小的字节数, 如果低于这个字节数, 就会等待, 直到超时后才返回给消费者. 这里给100kB, 缺省是1B propsMap.put(ConsumerConfig.FETCH_MIN_BYTES_CONFIG, 1024 * 100); // fetch.min.bytes // 一次fetch操作的最大等待时间，“最大等待时间”与“最小字节”任何一个先满足了就立即返回给消费者 // 需要注意：“最大等待时间”不能超过 session.timeout.ms 和 request.timeout.ms propsMap.put(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG, 10000); // fetch.max.wait.ms, 缺省是500 // 在消费者方法中注入acknowledgment并在执行完业务逻辑后手动调用确认方法 acknowledgment.acknowledge(); 1、背景： 某个业务对象由多张表关联而成，要创建该对象需要向多张表插入数据，基于canal的监控就会有多次该对象的变更记录，而Kafka消费的时候也会多次处理同一个对象（虽然不同表，但是同一个对象的不同部分），原有的Kafka消费者是一次处理一条，这将造成重复对同一个对象的处理。其实只需要所有表插入完毕后，一次处理该对象即可。
2、现有技术架构： mysql --&gt; canal --&gt; Kafka --&gt; Spring-Kafka消费者 --&gt; 下游接口
3、解决方案： 优化Spring-Kafka消费者，从单条处理改为多条处理，然后在消费者中合并相同的对象，从而达到一个对象只处理一次（最多两次）的目的。为什么有可能是两次，因为分批的时候很容易将同一个对象的多条消息分到上下两批，这样这个对象将会被处理两次；那为什么不会处理三次？其实也能够制造出来上次的情况，就是分批的大小如果很小就容易出现三次，甚至更多次。所以通常情况我们将分批大小设置得要比表数量多。
举个例子：一个对象的创建有10张表的插入消息，而分批大小设置成4，此时10条消息就被4这个批大小拆分成3批，每批处理一次该对象，那么该对象就会被处理3次。所以分批大小是一个重要的参数，其值的设定通常要大，但再大也不可避免被分成两批的情况。
4、实现步骤 Spring-kafka从1.1版本开始就支持了批量消费，需要在ContainerFactory中设置batchListener=true
同时设置消费者参数 max.poll.records 来控制一批的最大记录数量，该参数的缺省值为500。
AbstractKafkaListenerContainerFactory类的源码如下：
/** * Set to true if this endpoint should create a batch listener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7a7d58e739f2f35920e182e34745e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca516e83f25a8e4cf9ae7f442b674d85/" rel="bookmark">
			经纬度转换 | 基于Python的经纬度与xy坐标(屏幕坐标)相互转换(可批量)，并在平面坐标系上以特定点为坐标原点重新建立坐标系，输出各点新坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景——为什么要转换 用的更多的场景是把经纬度转化为xy平面坐标，因为经纬度是方便我们确定地理位置的，我们可以很容易的从地图数据（可利用高德开放平台）上获取某一个地址它的经纬度，但是我们看到的地图是平面的，所以要利用各种投影把经纬度转换为平面坐标便于我们自己分析~
xy平面坐标转化为经纬度的使用场景不多，但我们可以作为一个验证来运用。
关于如何从一串地址，如“重庆市沙坪坝区沙正街174号”这样的一个文本地址得出它的经纬度，我在之前发在微信的文章里有过介绍，可见：https://mp.weixin.qq.com/s/Z2I2ufb-AB_gQcfTBD6vmg 也可点此跳转
2. 我的操作环境 python3.8
我习惯在jupyter里运行python，大家的pycharm、vs code都可
3. 经纬度和xy平面坐标相互转换----实战 import math import pandas as pd #定义经纬度转换为米勒坐标的方法 def millerToXY(lon, lat): xy_coordinate = [] L = 6381372 * math.pi * 2 #地球周长 W = L #平面展开，将周长视为X轴 H = L / 2 #Y轴约等于周长一半 mill = 2.3 #米勒投影中的一个常数，范围大约在正负2.3之间 #循环，因为要批量转换 for x, y in zip(lon, lat): x = x * math.pi / 180 # 将经度从度数转换为弧度 y = y * math.pi / 180 # 将纬度从度数转换为弧度 y = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca516e83f25a8e4cf9ae7f442b674d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99083a46c8a13a5e7a3b66f0c37f3a2d/" rel="bookmark">
			【Android】SDK安装及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载SDK Tools 地址：AndroidDevTools - Android开发工具 Android SDK下载 Android Studio下载 Gradle下载 SDK Tools下载
以windows10系统为例，下载压缩版直接解压即可。
二、安装SDK Tools 解压后双击运行SDK Manager.exe
如果无法打开SDK Manager，可以参考：https://blog.csdn.net/Yocczy/article/details/130917909
一般根据默认推荐安装即可。
如果自选，必选项：
Android SDK Tools：基础工具包，版本号带rc字样的是预览版。Android SDK Platform-tools：从android2.3开始划出此目录，存放公用开发工具，比如adb、sqlite3等，被划分到了这里。Android SDK Build-tools：Android项目构建工具。SDK Platform：对应平台的开发工具，需要下载Android xxx（API xx）的版本里面已经包含了。Android xxx（API xx） ：可选的各平台开发工具，一般选择最新版本即可。 Extras目录：
Android Support Repository：主要是方便在gradle中使用Android Support Libraries，因为Google并没有把这些库发布到maven center或者jcenter去，而是使用了Google自己的maven仓库。Google Web Driver：被测APP里有用到H5的话就需要勾选。Intel x86 Emulator Accelerator(HAXM installer)：windows平台的Intel x86模拟器加速工具，配合Intel x86 atom/atom_64 System Image使用可加快模拟器的运行速度。 选择完毕后，点击install进入下一步
确认所有下载的文件，点击Accept License
所有文件均点击接受后（如图，文件名前都变为绿色对勾），此时点击install进行安装
三、配置环境变量 1.ANDROID_HOME 设置 鼠标右击此电脑-属性-高级系统设置-环境变量，打开环境变量页面。
在系统变量中选择新建，填写变量名和变量值，点击确定完成添加。
变量名：ANDROID_HOME。变量值：sdk安装路径。
2.Path 设置 同样在环境变量页面，系统变量中，找到Path，点击编辑。
分别添加tools安装路径、platform-tools安装路径、Android新版API安装路径，均在SDK目录下。
四、验证安装是否成功 使用快捷键win+R，打开运行，输入cmd，点击确定后打开cmd。
在cmd中输入adb，验证sdk是否安装配置成功。 出现图示为安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6427c0f525b3a8a061c8e543b5f8f6dc/" rel="bookmark">
			常见AI模型参数量-以及算力需求评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 token和byte有换算关系吗？大模型开源链接和大模型套件大模型对推理算力需求4-bit Model Requirements for LLaMA昇思和业界开源大模型关于算力、训练时长不同参数量下算力需求典型大模型下算力需求常见小模型参数量推理训练算力需求分析训练推理 参考 token和byte有换算关系吗？ 盘古一个token=0.75个单词，1token相当于1.5个汉字；
以中文为例：token和byte的关系
1GB=0.5G token=0.25B token；
Token 设计原则理解：英文中有些单词会根据语义拆分，如overweight会被设计为2个token，over和weight；
中文中有些汉语会根据语义被整合，如“等于”、“王者荣耀”；
大模型开源链接和大模型套件 大模型应用方向开源链接悟空画画文生图https://github.com/mindspore-lab/minddiffusion/tree/main/vision/wukong-huahuaTaichu-GLIDE文生图https://github.com/mindspore-lab/minddiffusion/tree/main/vision/Taichu-GLIDECodeGeex代码生成https://github.com/THUDM/CodeGeeX鹏城盘古文本生成预训练https://gitee.com/mindspore/models/tree/master/official/nlp/Pangu_alpha紫东太初图文音三模型https://gitee.com/mindspore/zidongtaichuLuojiaNet遥感框架https://github.com/WHULuoJiaTeam/luojianet空天灵眸多模态遥感（当前为10亿级别参数）https://gitee.com/mindspore/ringmo-framework大模型套件套件内容开源链接mindformerstransformer大模型套件https://gitee.com/mindspore/mindformersminddiffusiondiffusion模型套件https://github.com/mindspore-lab/minddiffusionMindPet微调套件https://github.com/mindspore-lab/mindpet 大模型对推理算力需求 4-bit Model Requirements for LLaMA ModelModel SizeMinimum Total VRAMCard examplesRAM/Swap to Load*LLaMA-7B3.5GB6GBRTX 1660, 2060, AMD 5700xt, RTX 3050, 306016 GBLLaMA-13B6.5GB10GBAMD 6900xt, RTX 2060 12GB, 3060 12GB, 3080, A200032 GBLLaMA-30B15.8GB20GBRTX 3080 20GB, A4500, A5000, 3090, 4090, 6000, Tesla V10064 GBLLaMA-65B31.2GB40GBA100 40GB, 2x3090, 2x4090, A40, RTX A6000, 8000, Titan Ada128 GB 来源：https://gist.github.com/cedrickchee/255f121a991e75d271035d8a659ae44d
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6427c0f525b3a8a061c8e543b5f8f6dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ad9a2c359bad4b3a027cee7c9359b9/" rel="bookmark">
			【Python系列】Python基础语法轻松入门—从变量到循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写在前面 语法介绍
变量
数据类型
整数
浮点数
字符串
列表
元组
字典
运算符
算术运算符
比较运算符
逻辑运算符
条件语句
循环语句
图书推荐
图书介绍
参与方式
中奖名单 写在前面 Python 是一种高级、解释型的编程语言，具有简单易学、可读性强、开发效率高等特点。本文将介绍 Python 的基础语法，包括变量、数据类型、运算符、条件语句、循环语句等，并提供相应的示例代码。
语法介绍 变量 在 Python 中，变量是用于存储值的容器。变量的命名规则和其他编程语言类似，必须以字母或下划线开头，可以包含字母、数字和下划线。Python 是一种动态类型语言，变量的类型是根据值自动推导出来的。
示例代码：
# 定义变量 age = 18 name = 'Tom' is_male = True # 输出变量的值 print(age) print(name) print(is_male) 数据类型 Python 支持多种数据类型，包括整数、浮点数、字符串、列表、元组、字典等。
整数 整数是不带小数部分的数字，可以进行加、减、乘、除等运算。
示例代码：
# 定义整数 a = 5 b = 2 # 整数运算 print(a + b) # 加法 print(a - b) # 减法 print(a * b) # 乘法 print(a / b) # 除法 print(a // b) # 整数除法 print(a % b) # 取余数 print(a ** b) # 指数运算 浮点数 浮点数是带有小数部分的数字，可以进行与整数相同的运算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7ad9a2c359bad4b3a027cee7c9359b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f929973983ad87e9eed20feade719e4/" rel="bookmark">
			Mac 安装配置adb命令环境（详细步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、注意：前提要安装java环境。 因为android sdk里边开发的一些包都是依赖java语言的，所以，首先要确保已经配置了java环境。
二、在Mac下配置android adb命令环境，配置方式如下： 1、下载并安装IDE （android studio） Android Studio官网下载链接
注意区分：本机Mac是Inter芯片还是apple的M系列芯片，别选错了版本。 详细的安装连接请参考 Mac 安装Android studio
2、配置环境 在安装完成之后，将android的adb工具所在目录加入环境变量里面。
(1) 修改.bash_profile文件中的内容 在终端中输入 vim ~/.bash_profile ，打开 .bash_profile文件。　按 i 进入输入模式，
在文件内容的末尾加入以下内容：
export ANDROID_HOME=/Users/xxx/Library export PATH=${PATH}:/Users/xxx/Library/Android/sdk/platform-tools export PATH=${PATH}:/Users/xxx/Library/Android/sdk/tools 注意：xxx代表用户名，根据自己实际的用户名称进行修改 点击 esc ，输入 :wq 回车（保存并退出文本）。
(2) 使变更生效 在终端中输入： source ~/.bash_profile ，使得变更生效。
3、测试 在终端中输入： adb version
输出：
Android Debug Bridge version 1.0.41 Version 31.0.0-7110759 Installed as /Users/xxx/Library/Android/sdk/platform-tools/adb 在终端中输入：adb devices
输出：
List of devices attached 到这里说明android adb命令已经可以正常使用了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f929973983ad87e9eed20feade719e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d736e64c6c168eaa201d69b7515dfa13/" rel="bookmark">
			C&#43;&#43; 哈希的应用【布隆过滤器】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 北 海
🎉所属专栏： C++修行之路
🎃操作环境： Visual Studio 2022 版本 17.6.5
文章目录 🌇前言🏙️正文1、字符串比较2、布隆过滤器的概念3、布隆过滤器的实现3.1、基本结构3.2、插入3.3、查找3.4、删除3.5、测试3.6、优化方案 4、布隆过滤器小结5、海量数据面试题（哈希切割）5.1、题目一5.2、题目二 🌆总结 🌇前言 注册账号是进行网络冲浪的第一步操作，而拥有一个具有个性且独一无二的用户昵称是非常重要的，很多人在填写昵称时，常常会看到 此昵称已存在 的提示，系统是如何快速知道当前昵称是否存在呢？总不能挨个去遍历对比吧，这时候就需要我们本文中的主角： 布隆过滤器
🏙️正文 1、字符串比较 常见的字符串比较方法是 按 ASCII 码值进行比较，直到两个字符串同时结束，说明两者一致
比如字符串1 abcdef 和字符串2 azbmcy
显然两个字符串不一样
这种比较方法很直接，也很可靠，但缺点也很明显：需要对字符串进行遍历
一个字符串还好，如果是几千万个字符串呢？不但需要消耗大量存储空间，查找效率也很低，此时填写个昵称，服务器都要跑一会才有反映，这是用户所无法容忍的
因此人们想出了另一个方法，利用哈希映射 的思想，计算出 哈希值，存储这个值即可，可以借此 标识字符串是否存在
在进行字符串（昵称）比较时，只需要计算出对应的 哈希值，然后看看该位置是否存在即可
哈希值 也是一个整数啊，可以利用 位图 进行 设置，查找字符串时，本质上是在 查找哈希值是否在位图中存在
字符串有千万种组合，但字符是有限的，难免会出现 误判 的情况（此处的 哈希函数 为每个字符相加）
为了尽可能降低 误判率，在 位图 的基础之上设计出了 布隆过滤器
接下来看看什么是 布隆过滤器 吧
2、布隆过滤器的概念 这里是 布隆 可不是 英雄联盟中的 弗雷尔卓德之心 布隆，毕竟他也不能解决字符串比较问题，他只是 召唤师峡谷 中的一个坦克，主要负责 过滤（吸收） 敌方的伤害
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d736e64c6c168eaa201d69b7515dfa13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307962170ba4af85404159ba4c04e4f1/" rel="bookmark">
			Python 日志记录：6大日志记录库的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 日志记录：6大日志记录库的比较 文章目录 Python 日志记录：6大日志记录库的比较前言一些日志框架建议1. logging - 内置的标准日志模块默认日志记录器自定义日志记录器生成结构化日志 2. Loguru - 最流行的Python第三方日志框架默认日志记录器自定义日志记录器 3. Structlog4. Eliot5. Logbook6. Picologging最后的想法 前言 日志记录框架是一种工具，可帮助您标准化应用程序中的日志记录过程。虽然某些编程语言提供内置日志记录模块作为其标准库的一部分，但大多数日志记录框架都是第三方库，例如logging (Python)、Log4j (Java)、 Zerolog (Go) 或 Winston (Node.js)。有时，组织会选择开发自定义日志记录解决方案，但这通常仅限于具有高度专业化需求的大型公司。
虽然 Python 在其标准库中提供了强大且功能丰富的日志记录解决方案，但第三方日志记录生态系统也提供了一系列引人注目的替代方案。根据您的需求，这些外部库可能更适合您的日志记录需求。
因此，本文将介绍 Python 用于跟踪应用程序和库行为的六大日志解决方案。我们将首先讨论标准logging模块，然后研究 Python 社区创建的其他五个logging frameworks。
一些日志框架建议 Pino (Node.js)
Zerolog, Zap, or Slog (Go)
Monolog (PHP)
SLF4J with Log4J2 or Logback (Java)
Loguru (Python)
Semantic Logger (Ruby)
1. logging - 内置的标准日志模块 默认日志记录器 与大多数编程语言不同，Python 在其标准库中包含了一个功能齐全的日志框架。该日志记录解决方案有效地满足了库和应用程序开发人员的需求，并包含了以下严重性级别：DEBUG、INFO、WARNING、ERROR 和 CRITICAL。有了默认日志记录器，无需任何前期设置，您就可以立即开始记录日志。
import logging logging.debug("A debug message"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/307962170ba4af85404159ba4c04e4f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c932f75cd830b01c4c160514b1db11/" rel="bookmark">
			支持向量机(SVM)的回归拟合(matlab实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与传统的神经网络相比，SVM具有以下几个优点： (1)SVM是专门针对小样本问题而提出的，可以在有限样本的情况下获得最优解。 (2)SVM算法最终将转化为一个二次规划问题，从理论上讲可以得到全局最优解，从而解决了传统神经网络无法避免局部最优的问题。 (3)SVM的拓扑结构由支持向量决定，避免了传统神经网络需要反复试凑确定网络结构的问题。 (4)SVM利用非线性变换将原始变量映射到高维特征空间，在高维特征空间中构造线性分类函数，这既保证了模型具有良好的泛化能力，又解决了“维数灾难”问题。 同时，SVM不仅可以解决分类、模式识别等问题，还可以解决回归、拟合等问题。因此，其在各个领域中都得到了非常广泛的应用。 本章将详细介绍SVM回归拟合的基本思想和原理，并以实例的形式阐述其在混凝土抗压强度预测中的应用。 1 理论基础 1.1 SVR基本思想 为了利用SVM解决回归拟合方面的问题，Vapnik等人在SVM分类的基础上引入了ε不敏感损失函数，从而得到了回归型支持向量机(support vector machine for regression, SVR),且取得了很好的性能和效果。下面将详细阐述SVR的基本思想并进行算法推导。 SVM应用于回归拟合分析时，其基本思想不再是寻找一个最优分类面使得两类样本分开，而是寻找一个最优分类面使得所有训练样本离该最优分类面的误差最小，如图29-1所示。 其中，只有部分参数(ai-ai*)不为零，其对应的样本xi即为问题中的支持向量。 从式(29-7)可以看出，SVR最终的函数形式与SVM相同，其结构与神经网络的结构较为类似，如图29-3所示。输出是中间节点的线性组合，每个中间节点对应一个支持向量。 1.2 支持向量机的训练算法 支持向量机的求解问题最终将转化为一个带约束的二次规划(quadratic programming, QP) 问题，当训练样本较少时，可以利用传统的牛顿法、共轭梯度法、内点法等进行求解。然而，当训练样本数目较大时，传统算法的复杂度会急剧增加，且会占用大量的内存资源。因此，为了减小算法的复杂度，提升算法的效率，不少专家和学者提出了许多解决大规模训练样本的支持向量机训练算法，下面简要介绍几种常用的典型训练算法。 1.分块算法 分块算法(chunking)的理论依据是支持向量机的最优解只与支持向量有关，而与非支持向量无关。该算法的基本步骤如下： (1)将原始优化问题分解为一系列规模较小的QP子集，首先随机选择一个QP子集，利用其中的训练样本进行训练，剔除其中的非支持向量，保留支持向量。 (2)将提取出的支持向量加入另一个QP子集中，并对新的QP子集进行求解，同时提取出其中的支持向量。 (3)逐步求解，直至所有的QP子集计算完毕。 2.Osuna算法 Osuna算法最先是由Osuna等人提出的，其基本思路是将训练样本划分为工作样本集B和非工作样本集N,迭代过程中保持工作样本集B的规模固定。在求解时，先计算工作样本集B的QP问题，然后采取一些替换策略，用非工作样本集N中的样本替换工作样本集B中的一些样本，同时保证工作样本集B的规模不变，并重新进行求解。如此循环，直到满足一定的终止条件。 3.序列最小优化算法 与分块算法和Osuna算法相同，序列最小优化算法(sequential minimal optimization,SMO)的基本思想也是把一个大规模的QP问题分解为一系列小规模的QP子集优化问题。SMO算法可以看做是Osuna算法的一个特例，即将工作样本集B的规模固定为2,每次只求解两个训练样本的QP问题，其最优解可以直接采用解析方法获得，而无需采用反复迭代的数值解法，这在很大程度上提高了算法的求解速度。 4.增量学习算法 上述3种训练算法的实现均是离线完成的，若训练样本是在线实时采集的，则需要用到增量学习算法(incremental learning)。增量学习算法将训练样本逐个加入进来，训练时只对与新加入的训练样本有关的部分结果进行修改和调整，而保持其他部分的结果不变。其最大的特点是可以在线实时地对训练样本进行学习，从而获得动态的模型。 简而言之，分块算法可以减小算法占用的系统内存，然而当训练样本的规模很大时，其算法复杂度仍然较大。Osuna算法的关键在于如何划分工作样本集与非工作样本集、如何确定工作样本集的大小、如何选择替换策略以及如何设定迭代终止条件等。SMO算法采用解析的方法对QP问题进行求解，从而避免了数值解法的反复迭代过程以及由数值解法引起的误差积累问题，这大大提高了求解的速度和精度。同时，SMO算法占用的内存资源与训练样本的规模呈线性增长，因此其占用的系统内存亦较小。增量学习算法适用于在线实时训练学习。 2 案例背景 2.1 问题描述 近年来，随着房屋建筑、水利、交通等土木工程的大力发展，我国的混凝土年用量逐年攀升。相关统计数据表明，目前我国的混凝土年用量约为24～30亿立方米，混凝土结构约占全部工程结构的90%上，可以预见，混凝土将是现阶段及未来一段时间内我国主导的工程结构材料。
混凝土是由水泥、砂、石、飞灰和水等构成的混合物，且在使用时往往需要添加增塑剂等。 因此，与其他结构材料相比，混凝土具有更复杂的力学性能。混凝土的强度是决定混凝土结构和性能的关键因素，也是评价混凝土结构和性能的重要指标。其中，混凝土的立方米抗压强度是其各种性能指标的综合反映，与混凝土轴心抗拉强度、轴心抗压强度、弯曲抗压强度、疲劳强度等有良好的相关性，因此混凝土的立方米抗压强度是评价混凝土强度的最基本指标。 随着技术的不断发展，混凝土抗压强度检测手段也愈来愈多，基本上可以分为局部破损法和非破损法两类，其中局部破损法主要是钻芯法，非破损法主要包括回弹法和超声法。工程上常采用钻芯法、修正回弹法，并结合《回弹法检测混凝土抗压强度技术规程》、《建筑结构检测技术标准》等规定的方法来推定混凝土的抗压强度。按照传统的方法，通常需要先对混凝土试件进行28天标准养护，然后再进行测试。若能够提前预测出混凝土的28天抗压强度，则对于提高施工质量和进度都具有重要的参考意义和实用价值。 此外，不少专家和学者将投影寻踪回归、神经网络、灰色理论等方法引入混凝土结构工程领域，取得了不错的效果，对混凝土抗压强度的预测有着一定的指导意义。相关研究成果表明，混凝土的28天立方米抗压强度与混凝土的组成有很大的关系，即与每立方米混凝土中水泥、炉石、飞灰、水、超增塑剂、碎石及砂用量的多少有显著的关系。现采集到103组混凝土样本的立方米抗压强度及其中上述7种成分的含量大小，要求利用支持向量机建立混凝土的28天立方米抗压强度与其组成间的回归数学模型，并对模型的性能进行评价。 2.2 解题思路及步骤 依据问题描述中的要求，实现支持向量机回归模型的建立及性能评价，大体上可以分为以下几个步骤，如图29-4所示。 1.产生训练集/测试集 与SVM分类中类似，为了满足libsvm软件包相关函数调用格式的要求，产生的训练集和测试集应进行相应的转换。训练集样本的数量及代表性要求与其他方法相同，此处不再赘述。 2.创建/训练SVR回归模型 利用libsvm软件包中的函数svmtrain可以实现SVR回归模型的创建和训练，区别是其中的相关参数设置有所不同。同时，考虑到归一化、核函数的类型、参数的取值对回归模型的性能影响较大，因此，需要在设计时综合衡量，具体参见第3节及第4节，此处不再赘述。 3.仿真测试 利用libsvm软件包中的函数svmpredict可以实现SVR回归模型的仿真测试，返回的第1个参数为对应的预测值，第2个参数中记录了测试集的均方误差E和决定系数R2,具体的计算公式分别如下： 4.性能评价 利用函数svmpredict返回的均方误差E和决定系数R2,可以对所建立的SVR回归模型的性能进行评价。若性能没有达到要求，则可以通过修改模型参数、核函数类型等方法重新建立回归模型，直到满足要求为止。 3 MATLAB程序实现 利用MATLAB及libsvm软件包中提供的函数，可以方便地在MATLAB环境下实现上述步骤。 %% 清空环境变量 clear all clc %% 导入数据 load concrete_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c932f75cd830b01c4c160514b1db11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ed9d45e0fb7dec120d852a19f1339d/" rel="bookmark">
			数据结构入门指南：链表（新手避坑指南）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.链表
1.1链表的概念
1.2链表的分类
1.2.1单向或双向
1.2.2.带头或者不带头
1.2.33. 循环或者非循环
1.3链表的实现
定义链表
总结
前言 前边我们学习了顺序表，顺序表是数据结构中最简单的一种线性数据结构，今天我们来学习链表，难度相较于顺序表会大幅增加，非常考验大家对结构体、指针的理解。但是也不要害怕，我会一一向大家解答疑惑，本期的内容先给初学者预预热，主要介绍在刚开始学习链表时需要注意的点、涉及的基础知识以及逻辑基础，下期会将功能接口具体实现。
1.链表 1.1链表的概念 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
逻辑图：
而现实中的链表是这样的：
通过图我们可以观察到，链式数据结构在逻辑上是连续的，在物理上不一定连续。链表的好处在于对内存更高效的使用（加入一个节点就开辟一个节点的空间）。
注意：
链表的节点是在堆上开辟的，程序不结束就不会主动释放。从堆上申请的空间是按照一定策略分配的，两次申请的空间可能连续，也可能不连续。 1.2链表的分类 链表主要分为以下几种：
1.2.1单向或双向 单向的链表简称为单链表，单链表只可以进行单向遍历，而双向链表完美的弥补了这个缺陷，可以向前遍历也可以向后遍历
1.2.2带头或者不带头 它们本质上并没有太大的区别，在链表功能实现过程中，有头节点的不需要对特殊节点进行特殊操作，相对简单，但对于大部分的刷题网站上链表的题目都是默认为无头节点的，所以对于无头节点链表的理解更为重要。
1.2.3 循环或者非循环 循环链表可以用于解决一些特定的问题，非循环链表一般用于普通的链表操作，例如插入、删除、查找等。
虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：
无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结
构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都
是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带
来很多优势，实现反而简单了，后面我们代码实现了就知道了。
1.3链表的实现 对于初学者来说，我个人建议先从无头单向非循环链表学起，因为在很多的刷题场景中都是单项无头非循环链表，理解了它也可以帮助你更快的适应链表的刷题。今天我们主要从这种单链表讲起。
单链表的实现过程中会存在很多的坑，对于初学者来说是很困难的，我会一一列举帮助大家避免这些错误，刚开始我会从基础知识层面进行逐个分析，当然内容也会很多，我会分期进行讲解。
定义链表 typedef int Datatype; typedef struct SLNode { Datatype data; SLNode* next; }SLNode; 定义链表这里就迎来了第一个坑，上述的这种形式很常见，对于初学者来说这里就有一个坑，这个链表定义的是否正确呢？
这种方式是不正确的，为什么？typedef是重命名，结构体是我们自定义类型，SLNode是重命名后的名字，但是这里需要注意，这个重命名是从上述代码第六行结束后才开始生效，在结构体中提前使用是不允许的。
正确的定义：
typedef int Datatype; typedef struct SLNode { Datatype data; struct SLNode* next; }SLNode; 定义之后就需要创建节点，创建节点这里我们要明白：我们是通过函数的形式来创建节点，创建时顺便赋值，初学者或许会有这样的疑问：那为什么函数的类型是结构体指针类型？例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26ed9d45e0fb7dec120d852a19f1339d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217215649b03f915e91f908bb03abaae/" rel="bookmark">
			【Python】PySpark 数据处理 ② ( 安装 PySpark | PySpark 数据处理步骤 | 构建 PySpark 执行环境入口对象 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装 PySpark1、使用 pip 安装 PySpark2、国内代理镜像3、PyCharm 中安装 PySpark 二、PySpark 数据处理步骤三、构建 PySpark 执行环境入口对象四、代码示例 一、安装 PySpark 1、使用 pip 安装 PySpark 执行 Windows + R , 运行 cmd 命令行提示符 ,
在命令行提示符终端中 , 执行
pip install pyspark 命令 , 安装 PySpark , 安装过程中 , 需要下载 310 M 的安装包 , 耐心等待 ;
安装完毕 :
命令行输出 :
C:\Users\octop&gt;pip install pyspark Collecting pyspark Downloading pyspark-3.4.1.tar.gz (310.8 MB) |████████████████████████████████| 310.8 MB 126 kB/s Collecting py4j==0.10.9.7 WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProtocolError('Connection aborted.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217215649b03f915e91f908bb03abaae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb36a4739d52e309ca40f8e68e338ae9/" rel="bookmark">
			三行命令切换Node.js版本，如何
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在Windows上更新Node.js版本呢？有没有那种不需要重新安装软件再修改配置文件和环境变量的方法？
你是否还在为可能要重新安装Node然后配置文件修改环境变量困扰？
有一种方式可以免重新配置node的环境变量
没错，确实有这种方式，那就是大名鼎鼎的nvm（Node Version Manager），一看名字就知道可以管理Node版本
下面就来介绍一下nvm更换node版本的步骤
nvm概述及下载 Node.js支持多版本共存，有多种方式切换Node.js版本。
其中最简单、最基本的切换方式就是使用Node.js官方工具-nvm（Node Version Manager），它可以在同一台电脑上轻松管理和切换多个Node.js版本。
nvm是一个跨平台的命令行工具，可以在Mac、Linux、Windows等各种操作系统上使用。 nvm下载地址：https://github.com/coreybutler/nvm-windows/
进入之后在右边选择合适的版本下载：
一般就选择.exe和.zip下载，我是下载的.exe版本然后安装
注意：如果选择的.exe版本，在安装时会让选择目前你电脑上Node.js的安装路径，这样安装nvm之后你电脑上的Node.js版本就被nvm管理了
配置nvm 安装之后检查nvm是否已经安装好了，打开cmd窗口：
输入nvm -v
像这样，如果有版本就是安装成功了，如果显示不是命令那就是环境变量没有配置好
配置nvm的环境变量：
打开电脑的高级系统设置，找到环境变量，修改系统变量的PATH选项，新增nvm的安装路径，这样nvm就配置在电脑中了
配置好重新打开cmd窗口就应该可以查看nvm版本了
nvm更换Node.js版本 首先使用nvm list available 命令可以查看电脑上可以安装的Node.js版本
// 查看可安装的Node.js版本 nvm list available 然后安装你要更换的的Node.js版本（可能要几分钟，请耐心等待，如果超过10分钟还没反应就管理员运行cmd重新安装）
// 安装16.14.0版本的Node.js nvm install 16.14.0 如果出现successfully就是安装新版本安装成功了，现在你可以使用nvm更换Node.js版本了
// 切换使用指定版本的Node.js nvm use 16.14.0 出现下面的信息就是更换node版本成功了
C:\Windows\system32&gt;nvm use 16.14.0 Now using node v16.14.0 (64-bit) 你还可以查看此时你电脑上的node版本有哪些本nvm管理了
// 查看已安装的Node.js版本 nvm list 写在最后 原文章在此：Node版本切换全攻略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ca9b87f0a5ed979f250d300cd571de/" rel="bookmark">
			Kafka延迟队列的实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代的分布式系统中，延迟队列是一种常见的解决方案，用于处理具有延迟要求的任务或消息。Apache Kafka是一个高性能、可扩展的分布式消息队列，可以作为延迟队列的基础设施。本文将介绍如何使用Kafka实现延迟队列，并提供详细的Java示例。
什么是延迟队列？ 延迟队列是一种特殊的消息队列，可以将消息或任务推迟到指定的时间再进行处理。它通常用于处理需要在未来某个时间点执行的任务，如定时任务、延迟通知等。延迟队列允许开发人员根据任务的延迟要求进行灵活的调度和处理。
使用Kafka实现延迟队列的方式 Kafka本身并没有提供原生的延迟队列功能，但我们可以通过一些技术手段来实现延迟队列的功能。下面介绍两种常见的实现方式。
方式一：使用消息的时间戳和消费者组 Kafka消息具有时间戳（timestamp）属性，我们可以利用这个属性来实现延迟队列。具体步骤如下：
生产者发送消息时，设置消息的时间戳为需要延迟的时间点。消费者以消费者组的方式订阅主题，并设置适当的消费者偏移量（offset）。消费者定期拉取消息，并根据消息的时间戳判断是否达到处理时间。如果消息的时间戳大于当前时间，则将消息重新发送到延迟队列的主题中。延迟队列的消费者订阅延迟队列的主题，并在延迟时间到达后处理消息。 下面是一个使用Java编写的示例代码：
// 生产者发送延迟消息 ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;("my_topic", "my_key", "my_value"); long delay = System.currentTimeMillis() + 5000; // 5秒延迟 record.headers().add("delay", String.valueOf(delay).getBytes()); producer.send(record); // 消费者处理延迟消息 ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord&lt;String, String&gt; record : records) { long delay = Long.parseLong(record.headers().lastHeader("delay").value()); if (delay &lt;= System.currentTimeMillis()) { // 处理消息 processMessage(record); } else { // 将消息重新发送到延迟队列 producer.send(record); } } 方式二：使用Kafka Streams的事件时间（event time） Kafka Streams是Kafka提供的一种流处理框架，可以用于实时处理和转换数据。我们可以利用Kafka Streams的事件时间功能来实现延迟队列。具体步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ca9b87f0a5ed979f250d300cd571de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e13bb6cd24acf366d94c63f4ccd386/" rel="bookmark">
			【大虾送书第四期】《Python之光：Python编程入门与实战》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
✨写在前面
✨本书亮点
✨强力推荐
✨文末福利 🦐博客主页：大虾好吃吗的博客
🦐专栏地址：免费送书活动专栏地址
写在前面 作为一种极其流行的编程语言，Python已经成为了当今最为重要的生产力工具之一。无论小学生还是各行各业的从业人员，都开始学习Python编程。这种编程语言在许多领域中都有广泛的应用，因此Python编程已经成为了许多职业的必备能力或者加分项。
然而，在市面上的Python入门书籍中，存在着许多通病：如知识点堆砌、杂乱无章、学习曲线陡峭、案例过于炫技等问题，这让许多新入门的朋友感到无从下手，不知道该如何选择一本好的入门书籍。
针对这个问题，我向大家推荐《python之光》这本书，它以通俗易懂的方式，帮助读者快速掌握Python语言的最新特性、最新编程方法和最佳实践。
通过学习这本书，读者将具备项目实战能力，能够运用Python解决实际的工作问题。与其他的入门书籍不同的是，《Python之光》不仅仅是简单的知识堆积，而是从总到分，从原理到细节，从理论到实践，按照读者的学习心理层层递进。
同时，该书的应用案例也非常有代表性，包括数据科学（数据处理、数据分析、数据可视化）、办公自动化（Word、Excel的操作）、图形及界面、Web开发等领域，并且附有详细的代码讲解。
《Python之光》将重新定义Python的学习方式，帮助读者更好地应用Python进入实际工作中。
本书亮点 零基础，尽量不使用专业词汇，不需要任何背景知识；
语言通俗易懂，讲解深入浅出，内容详略得当；
代码简洁，变量命名尽量使用简单单词；
知识全面，讲解精练，涵盖最新的语言特性；
知识结构设计合理，学习曲线平滑；
面向应用，讲解必备的第三方库，配有经典、实用的案例。
另外，本书不堆砌知识，而是合理编排内容，从总到分，从原理到细节，从理论到实例，根据读者的学习心智模型层层递进。在应用部分，本书选取了数据科学（数据处理、数据分析、数据可视化）、办公自动化（对Word、Excel的操作）、图形及界面、Web开发等领域的案例，引导读者在实践中应用Python。这些案例非常有代表性，且均有详细的代码讲解。
《Python之光》提供海量免费配套资源，包括100个视频、1600个实战案例、源代码下载、高品质练习题、作者提供全程辅导、思维导图呈现全书知识精华、配套完整教学PPT，让学习过程直观易懂。
无论学习者的年龄、职业或行业，都能轻松入门Python编程。《Python之光》为初学者提供了极简的入门之路，是入门Python编程的不二之选。
适配版本：本书基于Python 3.11（本书代码最低适配版本Python3.10）
强力推荐 文末福利 本次送书三本活动时间：截止到2023-08-03 10:00京东自购：https://item.jd.com/14065766.html参与方式：关注博主文章下方公众号，编辑发送信息（第四期）点击链接即可抽奖 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/594/">«</a>
	<span class="pagination__item pagination__item--current">595/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/596/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>