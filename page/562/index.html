<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9814ebc7bd199cf1803948af0133829/" rel="bookmark">
			【springboot】Spring 官方抛弃了 Java 8！新idea如何创建java8项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决idea至少创建jdk17项目 问题idea现在只能创建最少jdk17，不能创建java8了吗?解决 问题 idea现在只能创建最少jdk17，不能创建java8了吗? 我本来以为是 IDEA 版本更新导致的 Bug，开始还没在意。
直到我今天自己初始化项目时才发现：卧槽，Java 8 真没了？！
具体一点，应该是使用 IDEA 内置的 Spring Initializr 创建 Spring Boot 新项目时，没有 Java 8 的选项了，只剩下了 &gt;= 17 的版本
解决 去网上搜了一圈，原来这是因为 Spring Boot 官方不再支持 Spring Boot 的 2.x 版本了，之后全力维护 3.x；而 Spring Boot 3.x 对 JDK 版本的最低要求是 17！
那就是不要用官方提供的 Spring Initializr 来初始化项目了，我们可以使用阿里云提供的脚手架镜像（https://start.aliyun.com/），一样愉快地使用 Java 8~
在 IDEA 里更改 Server URL 即可：https://start.aliyun.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f4c3b3ed627e4cc49f9df7cbe16b47/" rel="bookmark">
			微信小程序-JAVA Springboot项目-小程序搭建-项目搭建01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、序言
二、小程序搭建
一、序言 本文主要讲述一个微信小程序前后端项目搭建的过程，主要内容包括小程序（前端）搭建和后端搭建，其中会描述可能遇到的问题以及解决措施，文章将会分为几个部分进行讲述，这章将讲述前端小程序搭建的内容，其中包括软件下载、客户端向服务端发送数据，接收并处理来自服务端的数据等内容；本项目的前端运用的框架是uni-app，后端运用的框架是Springboot，如各位需求满足，可继续往下看；
关于前后端分离的好处，个人认为是可以增加代码可维护性，降低了许多后期维护成本，更容易发现问题，解决问题；其次项目可以分工给团队，减少开发难度。对于新手或者想要独立完成一个总体项目的同志是个不错的练习。
二、小程序搭建 1、开发语言
本项目运用的框架是uni-app，uni-app是一个使用 Vue.js 开发所有前端应用的框架，该框架的开发语言类似于vue.js，语法的规则有些变化（具体变化查看以下链接）；
白话uni-app | uni-app官网 (dcloud.net.cn)https://uniapp.dcloud.net.cn/vernacular.html# vue建立在标准 HTML、CSS 和 JavaScript 之上，所以涉及的开发语言要了解：vue、CSS、JavaScript、HTML；如果是新手莫慌张，语法较简单，看一看例子就能简单上手，以下是uni-app官方的教程链接；
常使用的主要三个语言板块：html、css、javascript，查看其中的一些格式变化即可。
uni-app组成和跨端原理 | uni-app官网 (dcloud.net.cn)https://uniapp.dcloud.net.cn/tutorial/
2、开发工具
HBuilderX（下载地址如下） HBuilderX-高效极客技巧 (dcloud.io)https://www.dcloud.io/hbuilderx.html
微信开发者工具（下载地址如下） 微信开发者工具下载地址与更新日志 | 微信开放文档 (qq.com)https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 下载稳定版本即可
3、平台注册或登录，获取小程序APPID
微信公众平台 (qq.com)https://mp.weixin.qq.com/ 小程序开发需要APPID才能发布或发行，这个步骤需要进入平台，注册登录后，填写小程序信息，然后获取APPID即可；
4、创建uni-app项目（这部分属于项目的前端部分）
选择uni-app项目，选择默认版本，vue选择版本2即可，如果选择vue3，那么根据官方教程学习即可；本项目选择的是vue2；
创建后项目的目录如图所示：
5、编写项目
这里编写一个小demo，实现前端接口向后端传输数据，以及接收后端传来的数据；
打开index页面，编写代码：
&lt;template&gt; &lt;view class="content"&gt; &lt;image class="logo" src="/static/logo.png"&gt;&lt;/image&gt; &lt;view class="text-area"&gt; &lt;text class="title"&gt;名称：{{title}}&lt;/text&gt; &lt;/view&gt; &lt;input class="input-box" placeholder="请输入修改的名称" @input="setTitle" /&gt; &lt;button @click="postData"&gt; 修改&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { title: 'Hello', tempTitle: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97f4c3b3ed627e4cc49f9df7cbe16b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7615e1ea77fb46b6085c22d8e5552617/" rel="bookmark">
			【AI模型部署】基于gradio和python的网页交互界面（web-ui）——简易使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用gradio，只需在原有的代码中增加几行,快速部署机器学习模型，就能自动化生成交互式web页面，并支持多种输入输出格式，比如图像分类中的图&gt;&gt;标签，超分辨率中的图&gt;&gt;图等。
同时还支持生成能外部网络访问的链接，能够迅速让你的朋友，同事体验你的算法。
参考 https://gradio.app/demos/https://www.machinelearningnuggets.com/gradio-tutorial/https://gradio.app/quickstart/ 文章目录 参考安装一、简单的欢迎界面分析——（输入文字UI+ 函数处理+输出文字）UI操作效果分析使用控件函数设置控件的参数多UI控件输入、输出 二、简单界面控件组合2.1 多个tags界面，（不同输入输出功能）多tags代码 2.2 进度条显示函数处理时间（process）2.2 进度条代码 三、`图像`相关操作、`模型部署`3.1 对上传图片，直接处理3.2 分类模型UI部署 （需要安装pytorch环境）下载模型界面（可手动）代码 附录端口被占用 [Errno 10048] error while attempting to bind on address解决方法1 （指定打开的端口）解决方法2找到占用端口+杀死 安装 注意，不要把python文件与
pip install gradio 一、简单的欢迎界面分析——（输入文字UI+ 函数处理+输出文字） 逻辑：输入UI中的参数，提交后自动传入绑定的函数，
其中 “text” 表示输入输出UI控件是文本框。
import gradio as gr def greet(name): return "Hello " + name + "!" demo = gr.Interface(fn=greet,inputs="text", outputs="text") demo.launch() ''' 如果需要在服务器部署后，局域网访问, 修改为： ''' # demo.queue().launch( server_name="0.0.0.0"） UI操作效果 默认启动 ，如果7860已经占用，自动变为7861，如果端口无法启动 。。 端口被占用时，可指定端口
demo.launch(server_port=30001)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7615e1ea77fb46b6085c22d8e5552617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36565e26ae2c9652022b2c6f42e92d3/" rel="bookmark">
			MACOS 适配 EXT4 文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 问题概述：通过u盘将部署包从mac传送到目标linux服务器后，在服务器对镜像文件进行sha256校验，发现结果和预期结果不一致。
原因定位：通过将服务器文件和mac上的文件分别用mac的sha256计算，发现文件发生了改动，最后定位到u盘的文件系统类型不是ext4（和服务器不一致），导致文件放到u盘后发生了变动。
解决方案：将u盘格式化成ext4的格式，重新传送部署包。
2.格式化u盘为ext4 通过brew安装e2fsprogs： brew install e2fsprogs
通过diskutil查看盘符： diskutil list
推出想要格式化的盘：diskutil unmountdisk /dev/disk4
格式化u盘为ext4格式：sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext4 /dev/disk4
3.macos读写ext4插件 macos默认是不只是ext4文件系统类型的磁盘的读写的，无法识别。
需要通过安装支持第三方文件系统拓展工具的方式，使macos可以读写ext4格式的磁盘。
安装macFUSE（安装完，需要重启才能开始生效），官网地址：Home - macFUSE
安装完成后，设置里有对应的设置项，如图：
安装ext4拓展插件FUSE-EXT2（FUSE-EXT2 使得 OSXFUSE 支持 ext2/ext3/ext4 文件系统的挂载），github主页有对应的安装过程，需要通过一个shell脚本安装，参考官方文档即可。
安装完成后，在设置页面也有对应的配置项，如图：
4.macos读写ext4文件系统的u盘 插入u盘，并通过diskutil list查看盘符，如 /dev/disk4
挂载u盘到自定义目录（关键：sudo）：sudo fuse-ext2 /dev/disk4 ~/mnt/u-ext4-128 -o rw+
确认磁盘挂载情况：
可以通过finder找到对应目录进行读写，也可以通过终端进行读写。
推出u盘：sudo umount ~/t7
参考：
macOS下如何将U盘格式化为ext4格式 | 陶熔鼓铸
Mac OS挂载ext4硬盘_macfuse_日敲三万行代码的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e2c8065826d832872c906b83de47b6/" rel="bookmark">
			MySQL远程连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【0】数据库的安装及配置 Windows安装MySQL - 知乎 (zhihu.com)
【1】mysql远程连接数据库 1. 首先打开打开cmd窗口：win+r ---------- cmd
2.输入用户名和密码进入数据库：mysql -u root -p
3.打开use mysql表：use mysql
4.执行远程连接(授权法)
1、设置所有的地址都可以进行远程连接
GANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; '''第一个root代表用户名，第二个root代表密码，% 代表IP地址''' # 刷新权限 flush privileges; # 重新查看权限 select host,user from user; 2、设置特定的ip地址和密码可以远程连接
# 增加远程连接权限 GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.1.%' IDENTIFIED BY *** WITH GRANT OPTION; # 刷新权限 flush privileges; # 重新查看权限 select host,user from user; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67e2c8065826d832872c906b83de47b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adaceab83c34647bb2dd06b0ca9760e6/" rel="bookmark">
			【Python】torch.exp（）和 torch.sigmoid（）函数详解和示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文对torch.exp（）和 torch.sigmoid（）函数进行原理和示例讲解，以帮助大家理解和使用。
目录 torch.exp函数原理运行示例 torch.sigmoid（）函数原理运行示例torch.sigmoid相关知识 结合运行 torch.exp 函数原理 torch.exp是PyTorch库中的一个函数，它的作用是对输入的张量进行按元素指数运算。
指数运算是将基数的指数次幂的结果，例如，计算e的x次幂，其中e是自然对数的底数。torch.exp返回一个新的张量，张量的形状和输入张量相同，但是每个元素都是输入元素的指数运算结果1。
函数原型：
torch.exp(input) 参数：input：输入张量。 返回值：返回一个包含指数运算结果的张量。 运行示例 import torch # 创建张量x x = torch.tensor([-2.0, -4.0, 0.0, 6.0, 8.0]) # 使用exp函数计算x y = torch.exp(x) #打印计算结果y print(y) 输出结果：
tensor([1.3534e-01, 1.8316e-02, 1.0000e+00, 4.0343e+02, 2.9810e+03]) torch.sigmoid（） 函数原理 torch.sigmoid是一个在PyTorch库中提供的函数，用于将任何实数映射到介于0和1之间的值。具体来说，torch.sigmoid接受一个张量作为输入，然后应用sigmoid函数到每个元素上。sigmoid函数的定义如下：
sigmoid(x) = 1 / (1 + exp(-x)) 这意味着对于任何输入x，输出将是0和1之间的值。
函数原型：
torch.sigmoid(input) 参数： input：一个Tensor或者是张量。 返回值： 返回一个Tensor，其值在0和1之间。 运行示例 import torch # 创建张量x x = torch.tensor([-2.0, -4.0, 0.0, 6.0, 8.0]) # 使用sigmoid函数计算x y = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adaceab83c34647bb2dd06b0ca9760e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c121630de33feee121e3d79b9a6357f1/" rel="bookmark">
			贪心算法(c&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、贪心算法介绍 基本原理：每一步都选择局部最优解，而尽量不考虑对后续的影响，最终达到全局最优解。
局限性：贪心算法不能保证获得全局最优解，但在某些问题上具有高效性。
特征：贪心选择性质、最优子结构性质(根据我的观察，很多贪心的题目会出现“不同的操作产生的贡献相同”的特征，在此特征下我们每次选择代价最小的。)
贪心类型多且杂，需要积累联系。
二、贪心算法实现步骤 1、确定问题的最优子结构（贪心往往跟排序、优先队列等一起出现）。
2、构建贪心选择的策略，可能通过“分类讨论”、“最小代价”、“最大价值”等方式来思考贪心策略。简单验证贪心的正确性，采用句式一般是：这样做一定不会使得结果变差、不存在比当前方案更好的方案等等。
3、通过贪心选择逐步求解问题，直到得到最终解。
三、例题 1、蓝桥OJ3412 最小化战斗力差距 https://www.lanqiao.cn/problems/3412/learning/?page=1&amp;first_category_id=1&amp;problem_id=3412
思路：
简单排序模型。
要将战斗力分为两部分，假设有一个a数组，一个b数组。将战斗力排序后进行划分，左边的在a数组中，右边的在b数组中，a数组的最后一个和b数组第一个元素的差距即战斗力差距，其他元素都可以忽略，故枚举即可。找间隙最小。
#include&lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5 + 9; int a[N]; int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a+1,a+1+n); int ans = a[2] - a[1]; for (int i = 1; i &lt; n; i++) ans = min(ans,a[i+1]-a[i]);//有i+1故&lt;n cout &lt;&lt; ans &lt;&lt; '\n'; } 体会：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c121630de33feee121e3d79b9a6357f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac2dbda0474a735f2fec9abbe8670ad/" rel="bookmark">
			前端常用算法（一）：防抖&#43;节流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一章 防抖
1.1 防抖（debounce）简介
1.2 应用场景
1.3 实现思路
1.4 手撕防抖代码
第二章 节流
2.1 节流（throttle）简介
2.2 应用场景
2.3 实现思路
2.4 手撕节流代码（方法：时间戳和计时器）
2.5 时间戳与计时器实现的区别
第三章 总结
第一章 防抖 1.1 防抖（debounce）简介 场景：用户在一段时间频繁点击执行某个函数/事件，那么在这段时间，用户点击一次，计时器重新计时，当在这段时间内用户没有触发该函数/事件时，该函数/事件会在这段时间结束时执行，只执行最后一次。应用示例理解：回城被打断，玩家残血准备回城，需要3s回城成功，但是在这个3s的过程中，玩家又重新点击了回城，导致3s回城重新计算，再等3s。 1.2 应用场景 登录、发短信、发送post请求等按钮/事件避免用户点击太快，以致于发送了多次请求，需要防抖，最后一次发送请求即可；调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖；input输入框获取到value值不需要输入一个字符就获取一次，可以使用防抖，让其输入结束之后再获取其值文本编辑器实时保存，当无任何更改操作一秒后进行保存。…… 1.3 实现思路 1.4 手撕防抖代码 function debounce(func,delay) { // 定义一个定时器timer let timer = null return function() { const that = this const args = arguments // 防抖核心：每次触发事件计时器都会重新计时 clearTimeout(timer) timer = setTimeout(()=&gt;{ func.apply(that,args) },delay) } } 例子： 未调用防抖函数时：用户每在input输入/删除一个值，都会输出一个值；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac2dbda0474a735f2fec9abbe8670ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db14e80e81c46d1a94939a7660d47517/" rel="bookmark">
			MPPT工作流程及算法和硬件的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MPPT算法选择 目前，MPPT算法有开路电压比率(离线)、短路电流比率(离线)、观察调节(在线)、极限追踪控制法(在线)。
在光伏控制系统中，因为日照、温度等条件的变化，光伏电池的输出功率也是在不断变化的，为保证使得光伏电池的输出功率保持在最大点，需要调整光伏电池输出电压(日照强度发生变化时，短路电流变化大，开路电压受影响小;环境温度发生变化时，短路电流受影响小，开路电压变化大)。另外，光伏电池的输出电压和电流也和负载有很大关系，负载大，输出电压大，输出电流小;负载小，输出电压小，输出电流大。光伏电池的MPP中的电压是指光伏电池的输出电压。
开路电压比率法——这可以说是非常经典也相当古老的方法了，又名“固定电压法”。简单来说，算法基于最大功率电压和开路电压的线性关系式 ，系数 取值由设计师决定，一般介于0.71到0.78之间，大多数设定为0.76。
MPPT在追踪时，首先开路DC端来测量开路电压，然后通过算法来计算最大功率电压并且定位最大功率点。MPPT会保持在该功率点一段时间，然后重复开路测算并且重新定位。
固定电压法的最大优点就是制作便宜并且应用简单。相反，缺点也十分明显：精确值和追踪效率较低。尽管固定电压法被称之为“追踪”算法，事实上它依然是在整个工作循环中的一个计算设定值而非即时追踪值。
其次，此方法完全且单纯依赖于组串的开路电压值而放弃了对于工作电流的追踪。当局部阴影出现在阵列时，实际最大功率点和MPPT设定功率点就会出现相当大的偏差，偏差范围取决于阴影遮盖程度。最后，每次机器进行开路电压测量时，太阳能系统是无法输出功率的，随着时间和次数累计此算法会造成一定量的能量流失。总体来说，差评。
短路电流比率法——和固定电压法的算法相似，可以表述为 ， 是一个变量系数，通常变化范围在0.78至0.92。
和固定电压法不同的是，短路电流比率法要求在转换器内置一个高频开关来测量短路电流。比较推荐的是在组串和DC link的电容之间安装一个FET(field-effect transistor)。由于电流受到光照强度的影响非常大，通常机器还需要一个DSP(digital signal processor)来保证IV曲线的全扫描和数据的准确度。这也让短路电流比率法设计更加复杂且难以应用。差评。
观察调节法——站在巨人肩头发展出来的算法你敢不服?目前，P&amp;O依然应用在世界各大主流的逆变器中也是最广泛的被应用的算法，没有之一。
相比于ESC，P&amp;O可以在更短的时间内追踪时触碰更大的区域，扫描更多地数据。这进一步提高了P&amp;O的追踪效率和准确率。由于它在短时间内可以处理大量的数据，这也一定程度抵制了突变光照强度对于追踪精确度的影响。
缺点的话，由于它扫描的范围较大，会一定程度的导致输出功率缺乏稳定性，但是抖动程度基本都在±4%以内。所以我还要给它32个赞!P&amp;O还有一个姐妹版本，还是“爬山”逻辑，但是并入了“试错”法(trial and error)。处理器会根据下一刻追踪点的移动趋势，比较功率的正增量或负增量。如果功率持续增加，处理器将会继续同方向移动追踪点，不停比较直到功率达到峰值。
极限追踪控制法——该算法第一次提出在19世纪20年代，也是目前全球最流行的“观测调节法”(Perturb and Observe)的前身。算法的创新点是引入了向量在P-V曲线中。处理器根据电压的增量或减量来比较对应的功率增减量，进而确定追踪功率点的移动方向。具体判定方法请参照图二，一目了然。
ESC算法的巨大成功是相比于之前的固定电压法,通过渐进向量引入了“爬山法”的概念，进而开启了动态追踪的算法。
ESC极大地拓宽了MPPT对于DC端输入能量的捕捉，显著地提高了追踪效率。由于ESC对于后代MPPT算法的影响深远，导致它的短板也一并被继承下来并至今“祸害”众多一线品牌的逆变器。ESC对于陡然变化的光照反应强烈，举个通俗例子，MPPT正专注的比较着功率和电压的变量，“嗯，正向移动的电压同步伴随着功率的增加，明显最大功率点还在正向(右边)，那我继续向右移动”。
此时云层挡住了阳光，稍稍影响了输入的直流功率，使之略微下降，“慢着!正向移动的电压竟然导致功率减小了!我肯定错过了最大功率点，快掉头!”
于是，追踪点就离它的归宿越来越远的地方飘去。。。我在实验室模拟测试时，亲眼看到最多达到70%左右的偏差。基于ESC这种一级(first stage)追踪的设计理念，这种现象，无解。但是欣赏它对后世的正面影响以及理念创新，还是好评!
综合考虑，MPPT的算法采用极限追踪控制法来进行软件实现，即采集PN侧电压、流向PN侧的电流数据，计算 和 判断 与 的关系， 大于 ，此时应按 减小PN侧的目标电压;若 小于 ，此时应按 增加PN侧的目标电压。
MPPT硬件选择
MPPT的实现是通过调节光伏电池输出电压来实现的，若光伏电池输出电压直接连接到DC/AC的PN侧，那么光伏电池输出电压波动就会直接影响PN侧电压，最好是在光伏电池和DC/AC之间加一个中间环节，通过这个中间环节来调整输入电压，保持输出电压稳定，增加或减小输出电流。这个功能一般有BUCK、BOOST、BUCK-BOOST、CUK电路和开关电路可以选择，但BUCK电路是连续向负载供电、间接从电源取电;BOOST电路时间接向负载供电、连续从电源取电，为保证光伏电池板的发电效率得到较好使用，一般选择BOOST电路来实现MPPT。
选择BOOST电路来实现MPPT算法，其结构拓扑如下图。
考虑成本问题，再加上光伏电池输出的所有最大功率点对应的输出电压差别不是很大，MPPT不使用DC/DC电路来实现，在现有的DC/AC平台上进行实现。
MPPT程序实现
变流器的工作流程为：
启动——预充电——PN侧抬压——接入光伏电池——输出(MPPT)。
可以确定，MPPT的作用是在电压环上作用，并且是在变流器进入工作状态后开始工作。
采用现有的DC/AC平台来实现MPPT，存在两个问题：控制步长(时间间隔)问题、扰动步长 问题、判断精度问题。
控制步长问题——PN侧电压在MPPT过程中会产生一定的波动，但因为对于光伏电池来说(结合下面两图)，其最大功率点对应的电压大致都在一个不大的范围内，并且都接近开路电压，所以，对于在DC/AC上实现MPPT，要考虑多长时间对PN侧目标电压进行一次更新。目前State Manage函数是0.1ms进入一次，可以考虑MPPT的控制步长为0.2~0.5ms，步长暂定为0.3ms。
相同光照、不同温度
相同温度，不同光照
扰动步长问题——考虑在变流器进入工作状态后，其PN侧电压为较稳定的值，即使光照强度、环境温度发生变化，光伏电池的最大功率点电压的变动范围不会很大。根据其采集回来的PN侧电压和光伏电池输出电流，并计算和前一时刻的功率差值 ，根据电导增量法进行判断，然后在目标跟踪电压上增加或减小一定的步长 。因为在光伏电池开始工作后，PN侧电压不是从0开始的，而是在光伏电池最大功率点对应电压附近，所以 的值会比较小，K值的设置通过调试程序获得，K暂定为5。
判断精度问题——由导纳法的工作流程图(下图)可以知道，在流程中存在 、 与0的关系的判断，程序中总是会存在误差，并且检测中也会存在，如果以0为判断准值，考虑实际应用中的误差因素，用一个小的阀值来替代0。阀值暂定为0.1V和0.1A。
MPPT算法C程序实现
#include "16F877.h"
#device ADC = 8 // 一个8位寄存器ADC模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db14e80e81c46d1a94939a7660d47517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665b9fb85ddb6764296696091b9048c3/" rel="bookmark">
			uniapp框架下实现小程序图片上传或拍照上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp框架下微信小程序实现相册图片上传或拍照上传 业务场景 实现一个小程序访问相册或手机拍照上传图片的功能
核心API-uni.chooseImage与uni.uploadFile 1、先使用uni.chooseImage API实现对用户手机相册或摄像头的访问
2、由于需要将图片资源上传至指定第三方服务器存储，因此需要调用uni.uploadFile API实现
具体实现 简单说明 此处仅仅展示了利用uniapp框架中的两个内置API来实现单张图片的简单上传操作，操作比较简单，后续如果需要支持多张图片上传、已上传图片大图预览以及图片删除等操作可自行根据需要编写逻辑即可，大图预览可直接调用uni.previewImage API即可，具体用法可直接参考uniapp官网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27dcca07249a7b74e5e42a9193a574b4/" rel="bookmark">
			Docker 安装kafka 并创建topic 进行消息通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Kafka是一个分布式流处理平台，用于构建高性能、可扩展的实时数据流应用程序。本文将介绍如何使用Docker容器化技术来安装和配置Apache Kafka。
一、使用镜像安装 1、kafka安装必须先安装Zookpper 2、下载镜像 docker pull wurstmeister/kafka 3、查看下载好的镜像 docker images 4、启动Kafka docker run -d --name kafka --publish 9092:9092 \ --link zookeeper \ --env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \ --env KAFKA_ADVERTISED_HOST_NAME=127.0.0.1 \ --env KAFKA_ADVERTISED_PORT=9092 \ wurstmeister/kafka 5、查看是否创建好Kafka容器 docker ps 6、进入到Kafka容器内 sudo docker exec -it kafka /bin/bash 7、创建topic cd opt/kafka_2.13-2.6.0/bin 创建topic
./kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 8 --topic test Created topic test. 8、创建成功之后发送消息 ./kafka-console-producer.sh --broker-list localhost:9092 --topic test 9、重新打开一个终端，创建消费者 sudo docker exec -it kafka /bin/bash cd opt/kafka_2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27dcca07249a7b74e5e42a9193a574b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383a17f5f0daf01e659ad1009fd59b22/" rel="bookmark">
			JavaEE(SpringMVC)期末复习（选择&#43;填空&#43;解答）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JavaEE期末复习一、单选题：二、多选题三、填空题四、解答 JavaEE期末复习 一、单选题： 1.Spring的核⼼技术是（ A ）？
A依赖注入
B.JdbcTmplate
C.声明式事务
D.资源访问
Spring的核心技术包括依赖注入（Dependency Injection）、面向切面编程（Aspect-Oriented
Programming）、控制反转（Inversion of
Control）等。其中，依赖注入是Spring最为重要的特性之一，它通过将对象之间的依赖关系交由Spring容器管理，实现了松耦合、可扩展、可维护性高的应用程序开发
。
2.下面关于&lt;load-on-startup＞元素说法错误的是？（c ）
A.如果&lt;load-on-startup＞元素的值为1,则在应用程序启动时会立即加载该Servlet
B.如果&lt;load-on-startup-元素不存在,则应用程序会在第—个servlet清求时加载该Servlet
C.如果&lt;load-on-startup-元素的值为1,则在应用程序启动时会延迟加载该Servlet
D.&lt;load-on-startup-元素是可选的
如果&lt; load-on-startup&gt;元素的值为1，则在应用程序启动时会立即加载该Servlet
3.在spring的配置文件中有一个类型的两个实例,如果按照类型去获取,结果是（A）
A.开发工具报错
B.获得需要的实例
C.获得两个不同的实例
D.获得两个不同的实例,让程序员根据项目需求去选择所需要的实例
当Spring容器中存在多个同一类型的实例时，如果没有指定具体的实例名称或其他条件进行区分，无法确定要获取的是哪个实例，这将导致开发工具报错或者运行时异常
4.通过继承可以快速实现bean的配置,那么是通过以下哪个属性实现的。（c）
A.id
B.class
C. parent
D abstract
parent。通过在bean配置中指定parent属性，可以实现bean之间的继承关系，子bean会继承父bean的配置。
5.在Spring中,用于产生Bean工厂的是（D）
A.Spring的核心库
B.Spring的AOP
C.Spring的资源
D.Spring的BeanFactory
spring的BeanFactory是用于产生和管理Bean的工厂类。它是Spring框架的核心部分，负责实例化、配置和管理Bean对象
6. MyBatis框架下载并解压后,有关mybatis-3.x的文件夹内容说明正确的是。（C）
A.lib文件下就属于MyBatis框架开发的所有JAR包，
B.mybatis-3.xword属于MyBatis使用手册
C.其中mybatis-3.xjar属于MyBatis核心包
D.以上说发都错误
.
7. 当有多个选择的情况是,值需要从多个选项中选择一个去执行时,可以使用的动态SQL元素是。（B）
A. &lt; if&gt;
B.&lt; choose&gt;、&lt; when&gt;、&lt; otherwise&gt;
C.&lt; when&gt;
D. &lt; set&gt;
&lt; choose&gt;元素表示多个选择，内部可以包含多个&lt; when&gt;元素和一个&lt; otherwise&gt;元素。每个&lt; when&gt;元素表示一个条件，如果满足条件，则执行对应的SQL语句块；&lt; otherwise&gt;元素表示默认情况下执行的语句块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/383a17f5f0daf01e659ad1009fd59b22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12dc5638cde0b7ceb72dffef5a326269/" rel="bookmark">
			大数据实验 实验五：MapReduce 初级编程实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据实验 实验五：MapReduce 初级编程实践 实验环境 操作系统 centos7Hadoop版本:3,3,0 实验内容与完成情况 （一）编程实现文件合并和去重操作 对于两个输入文件，即文件 A 和文件 B，请编写 MapReduce 程序，对两个文件进行合并，
并剔除其中重复的内容，得到一个新的输出文件 C。下面是输入文件和输出文件的一个样例 供参考。
输入文件 A 的样例如下：
20170101 x
20170102 y
20170103 x
20170104 y
20170105 z
20170106 x
输入文件 B 的样例如下：
20170101 y
20170102 y
20170103 x
20170104 z
20170105 y
根据输入文件 A 和 B 合并得到的输出文件 C 的样例如下：
20170101 x
20170101 y
20170102 y
20170103 x
20170104 y
20170104 z
20170105 y
20170105 z
20170106 x
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12dc5638cde0b7ceb72dffef5a326269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9506441f5cc5fdc204783ba7d68a742/" rel="bookmark">
			【Linux — 安装 Go】Linux 系统安装 Go 过程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面记录在Linux环境中安装Go的过程，整个过程使用了FinalShell终端工具与Linux进行交互。
Linux系统用户在终端执行【uname -a】先查看系统信息：
64位系统显示如下：
x86_64 x86_64 x86_64：这是你的机器的架构（这里是64位x86架构）。GNU/Linux：表示这是一个使用 GNU 工具的 Linux 系统。 下面开始下载
1.下载GO安装包 先在Windows环境中访问Go官网，接着找到Linux版本go的64位安装包，下载链接：
https://dl.google.com/go/go1.21.4.linux-amd64.tar.gz
方式①可在Windows环境中直接下载，下载后通过FinalShell终端工具拷贝到Linux环境中。
方式②也可以在Linux环境中，选择一个目录（用于存储下载文件）后，运行【wget + 下载链接】命令（wget命令如果未安装，可查百度），即可下载。
ls命令查看已下载的文件
2.解压安装包 安装包下载完成后，需要使用【sudo tar -C /usr/local -xzf + 安装包文件名】命令，将其解压到【/usr/local】目录下
sudo tar -C /usr/local -xzf go1.21.4.linux-amd64.tar.gz 该命令会将程序解压至【/usr/local/go】目录中。
3.设置环境变量 要使用go，还需要设置环境变量。通过编辑【/etc/profile】文件，可以让系统在启动时自动设置环境变量。
打开并编辑【profile】文件还需要先了解 vim，并掌握一些命令（可自行百度学习）。
vim /etc/profile 打开文件并在底部添加以下内容：
export PATH=$PATH:/usr/local/go/bin （在vim模式下，输入i，进入插入模式，把光标调整到底部，输入上面的内容）
按下Esc，然后输入【:wq】保存并退出。
使用 source 命令重新加载 【/etc/profile】文件，以便使修改后的环境变量立即生效。
source /etc/profile 4.测试已安装的Go 选择自己平常保存项目的目录，运行命令创建go文件。
vim hello.go 然后在编辑器中输入以下内容：
package main import "fmt" func main(){ fmt.Println("Hello, world!") } 保存并退出编辑器后，就可以使用go命令编译刚才的程序了。
go build hello.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9506441f5cc5fdc204783ba7d68a742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba98e1b945177f284cf3b61f360eeb8d/" rel="bookmark">
			连接Sql Server时报错:无法通过使用安全套接字层加密与 SQL Server 建立安全连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC连接Sql Server时报错:无法通过使用安全套接字层加密与 SQL Server 建立安全连接 前言解决办法一解决办法二总结 前言 今天使用jdbc连接sql server突然报错为：SQLServerException: “Encrypt”属性设置为“true”且 “trustServerCertificate”属性设置为“false”，但驱动程序无法使用安全套接字层 (SSL) 加密与 SQL Server 建立安全连接
解决办法一 首先是网上寻找到的第一种办法，就是在自己安装的JDK目录下找到java.security文件，然后打开这个文件。查询jdk.tls.disabledAlgorithms，然后将里面的3DES_EDE_CBC去掉，使用旧的算法。
下面是我的电脑上的例子：
但是遗憾的是，这个解决办法没有解决我的问题。 解决办法二 在连接数据库时，在我们使用的url后面加上一个encrypt=false或者encrypt=true;trustServerCertificate=true
String dbURL="jdbc:sqlserver://localhost:1433;databaseName=TestDB;encrypt=false"; String dbURL="jdbc:sqlserver://localhost:1433;databaseName=TestDB;encrypt=true;trustServerCertificate=true"; 现在也还不了解具体原理，麻烦各位不吝赐教。 总结 修改java.secrity文件在url后面加上encrypt=false或者encrypt=true;trustServerCertificate=true 如果你在阅读本文中发现描述不够准确或有误的地方，还请给予我一定的反馈，大家一起学习进步！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4436c04ebe27db3922864fac95850d2/" rel="bookmark">
			一、Go基础知识20、go.mod文件、go mod命令、私有仓库、导入版本管理、Vendor目录详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go.mod 文件是Go语言中的模块文件，用于管理项目的依赖关系和版本信息。go.mod 文件通常位于项目的根目录下，用于定义模块的名称、依赖关系和版本信息。
一、go.mod文件及go mod命令 1、go.mod 文件的基本结构 module example.com/mymodule go 1.17 require ( github.com/example/package v1.2.3 // additional dependencies ) replace ( // replacement rules ) module: 定义模块的名称，通常是项目的导入路径。该路径也用于唯一标识模块。go: 指定项目的最小Go语言版本，确保项目在指定版本及以上的Go环境中可以正确构建。require: 列出模块的直接依赖关系及其版本。这里 github.com/example/package 是一个示例依赖，指定了版本 v1.2.3。replace: 指定替代或替换规则，用于本地调试或使用自定义的包。 2、初始化模块 使用 go mod init 命令初始化一个新的模块。这会创建一个 go.mod 文件，记录项目的模块路径和依赖项。
go mod init example.com/myproject 这将创建一个 go.mod 文件，其中包含模块声明：
module example.com/myproject 3、添加依赖项 使用 go get 命令添加新的依赖项，并自动更新 go.mod 文件。例如，go get github.com/example/package@v1.2.3 将添加 github.com/example/package 作为依赖，并指定版本为 v1.2.3。
go get github.com/example/pkg@v1.2.3 这会在 go.mod 中添加如下条目：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4436c04ebe27db3922864fac95850d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7cdc414bcddb640c113ad5f3e24e32/" rel="bookmark">
			【JDK21】详解虚拟线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.虚拟线程是为了解决哪些问题
2.1.线程切换的巨大代价
2.2.哪些情况会造成线程的切换
2.3.线程资源是有限的
3.虚拟线程
4.适用场景
1.概述 你发任你发，我用JAVA8？JDK21可能要对这句话say no了。
现在Oracle JDK是每4个版本，推出一个长期支持版本，JDK21就是前段时间发布的最新的长期支持版JDK。作为最新的长期支持版JDK，JDK21中集合了非常多的重要新特性，其中最为重要，最有意义，最吸引人的莫过于——虚拟线程。虚拟线程虽然不是JDK21才引入的，但是是在该版本中才得以稳定的，所以我们建议要用虚拟线程的话，最好还是使用JDK21。
本文将用一个清晰的思路抽丝剥茧，层层递进的去探讨：
1.虚拟线程是为了解决哪些问题
在虚拟线程出现之前，传统线程模型中线程切换存在的问题，即线程切换的代价。
然后去思考哪些情况下线程会切换？有哪些可以优化的地方？
2.虚拟线程是怎么解决这些问题的
然后是虚拟线程是怎样工作的？是怎样进行任务调度的？
3.虚拟线程的实际应用价值
虚拟线程的适用场景。
2.虚拟线程是为了解决哪些问题 2.1.线程切换的巨大代价 虚拟线程是为了解决哪些问题？自然是为了解决之前传统线程模型存在的一些问题。如果对计算机的线程模型不是很熟悉的同学博主之前有一篇文章，有兴趣可以看一下：
【进程与线程】最好懂的讲解-CSDN博客
所以传统的线程模型存在哪些问题喃？这就要从线程切换的巨大代价聊起。
先给出结论——线程的切换可能会引起CPU上下文的切换，从而造成巨大的CPU资源的浪费。接下来我们聊聊具体原因。
CPU的读写速率是要远远高于内存的读写速率的，为了配平CPU和内存之间速率的差距，CPU和内存之间存在着一个由寄存器组成的中间层，寄存器种会存放着CPU接下来要执行的指令，以及后续可能要执行到的指令以及可能要用到的数据。只有预先装载进去这部分可能要用到的东西才能抹平CPU和内存之间的速率差距，不然每次都要去内存取内容，可能是会拉低CPU的效率的。
但该预先装载哪些内容进寄存器种喃？这里遵循了程序的局部性原理。
程序的局部性原理：
程序在执行的时候呈现出局部性规律，在一段时间内，整个程序的执行仅限于程序中的某一个部分，相应的，执行所访问的存储空间也局限于某个内存区域。局部性又分为时间局部性和空间局部性。时间局部性指的是，如果程序中的某条指令一旦执行，则不久后可能会被再次执行，执行指令时访问的数据单元在不久后会被再次访问。空间局部性指的是，一旦访问了某个存储单元，不久后，其附近的存储单元也将被访问。
CPU上下文切换：
寄存器中存储着当前执行的指令、数据、以及下一条指令在内存中的地址等等事关程序正常运行的关键信息。所以寄存器中存储的内容合称为CPU的上下文。
线程切换就可能会存在这样的问题：CPU上下文中存放的是当前线程的要的东西，可能不是下个线程要用的东西。下个线程被执行的时候，可能CPU的上下文就要换一套。CPU上下文的内容本来就是来自于内存，也就是说切换上下文就是去内存中读取要的东西。CPU的读写速度是远远高于内存的读写速度的，在这个切换过程中CPU没啥事儿可干了，就会造成CPU的浪费。
2.2.哪些情况会造成线程的切换 前面我们已经说了线程切换的巨大代价，接下来我们就要想想，什么情况下线程会切换喃？常见的无非两种情况：
分给当前线程的时间片到了线程阻塞了 我们分情况来讨论，首先是分给当前线程的时间片到了造成的线程切换。这类线程切换有问题吗？能被优化吗？很显然没问题，也不能去动它，因为进程和线程的出现本质上就是为了让多个程序能被交替执行，提升CPU的利用率，所以当前线程时间片到了，它就应该把CPU交出来，其它线程才有机会被执行。
至于第二种，线程阻塞引起的线程切换，就是值得我们进行优化的了。线程阻塞了，只是当前任务阻塞了，线程只是任务的载体，完全可以换个任务在上面继续执行。同理还有一种情况，就是时间片还没有用完，线程上面的任务跑完了，其实也该这样处理。
2.3.线程资源是有限的 除了上面线程切换的问题外，还有一点是值得注意的，就是线程资源是有限的，一台计算机上能开出来的线程是有上限的。
操作系统能够同时开启的线程数量是有限的主要有以下几个原因：
有限的系统资源：每个线程需要占用一定的系统资源，包括内存、CPU时间片、文件描述符等。系统的资源是有限的，因此开启过多的线程会消耗大量资源，可能导致资源耗尽或者性能下降。
调度开销：操作系统需要花费时间来管理和调度线程，包括线程的创建、销毁、切换等操作。如果线程数量过多，操作系统的调度开销会增加，降低系统的效率。
总结起来说人话就是，用来描述进程和线程的描述符（PCB或者TCP等）要存在内存中、内存是有限的，所以理论上线程自然是有上限的。
3.虚拟线程 前面罗嗦了这么多，总结起来无非就是计算机的线程资源是有限的，线程的切换会造成CPU资源的浪费。所以如果能复用线程资源，会提升多任务执行的效率。虚拟线程其实就是对线程资源的一种复用。
传统的JDK线程是每一条对应一条操作系统的线程，而虚拟线程是多个虚拟线程对应一条JDK的线程：
虚拟线程体系其实就是依赖于fork join pool来实现的，线程池中的每个JDK线程会对应一个任务列表，列表中会有多个虚拟线程，其实就是多个任务，由fork join pool的调度器来调度虚拟线程（任务）到各条平台线程上去。当有虚拟线程（任务）阻塞或者在时间片内提前执行完了等情况发生，调度器会去调度任务队列中的虚拟线程（任务）到这条平台线程上去继续执行：
ok，终于到虚拟线程的使用了，其实虚拟线程的使用本身反而还没有啥很多要说的。API的设计使用，当然是具有越极致的开闭性越好，所以作为线程的一个补充，虚拟线程的使用，在API层面是很简单的，和传统JDK线程的API语法几乎是一样的。
前置条件就不多说了，肯定是下载安装配置好JDK21，都在看JDK新特性的同学，这个肯定都是小问题，不赘述了。
手动开启虚拟线程：
Thread thread=Thread.ofVirtual().name("vittualThread").unstarted(new Task()); thread.start(); 自动开启虚拟线程：
Thread thread=Thread.ofVirtual().name("virtualThread").start(new Task()); 线程池：
ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor(); executorService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7cdc414bcddb640c113ad5f3e24e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b2df7c390d967137111dd18c76145c/" rel="bookmark">
			Java - Stream Filter 多条件筛选过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Stream流中Filter用于通过设置的条件过滤出元素 ，示例如下：
List strings = Arrays.asList(“abc”, “”, “bc”, “efg”, “abcd”,"", “jkl”); List filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); 如果需要进行多条件过滤
我们可以对这些参数进行处理，我们只是需要做一下判断，即：
让所有参数默认为 false，然后对传进来的值进行取值判断，若满足该条件为true，多个条件进行多次判断
判断完成之后 会拿到所有的boolean值 通过 &amp;&amp; 拼接返回，即 有一个为false，即返回值为false
通过该方法会对一个对象进行多条件过滤
public static List&lt;BidListVo&gt; checkOperationv1(List&lt;BidListVo&gt; list, BidProgressEnum progressEnum){ Integer progress = Integer.valueOf(progressEnum.getCode()); String nodeId = progressEnum.getNode(); List&lt;BidListVo&gt; collect = list.stream().filter(bidListVo -&gt; filterProgress(bidListVo,progress) ) .collect(Collectors.toList()); return collect; } private static boolean filterProgress(BidListVo bidListVo, Integer progress) { //副流程未开始 只判断主流程 if(StringUtils.isEmpty(bidListVo.getReviewProgress())){ return Integer.valueOf(bidListVo.getProgress()) &gt;= progress ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b2df7c390d967137111dd18c76145c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d1fef3a2736620629f455cc0e795ac/" rel="bookmark">
			python——Django 框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django 框架 1、 简介 Django 是用python语言写的开源web开发框架，并遵循MVC设计。
Django的主要目的是简便、快速的开发数据库驱动的网站。它强调代码复用，多个组件可以很方便的以"插件"形式服务于整个框架，Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发和DRY(DoNotRepeatYourself)原则。
2、特点 1） 重量级框架 对比Flask框架，Django原生提供了众多的功能组件，让开发更简便快速。
提供项目工程管理的自动化脚本工具
数据库ORM支持（对象关系映射，英语：Object Relational Mapping）
模板
表单
Admin管理站点
文件管理
认证权限
session机制
缓存 2）MVT模式 有一种程序设计模式叫MVC，其核心思想是分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容。
MVC的全拼为Model-View-Controller，最早由TrygveReenskaug在1978年提出，是施乐帕罗奥多研究中心(Xerox PARC)在20世纪80年代为程序语言Smalltalk发明的一种软件设计模式，是为了将传统的输入（input）、处理（processing）、输出（output）任务运用到图形化用户交互模型中而设计的。随着标准输入输出设备的出现，开发人员只需要将精力集中在业务逻辑的分析与实现上。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。现在虽然不再使用原来的分工方式，但是这种分工的思想被沿用下来，广泛应用于软件工程中，是一种典型并且应用广泛的软件架构模式。后来，MVC的思想被应用在了Ｗeb开发方面，被称为Ｗeb MVC框架。
Django的MVT
3、搭建虚拟环境 Django框架（入门超细笔记 创建项目步骤 ）_django创建项目-CSDN博客
3.1、在cmd中输入命令 pip install virtualenv
3.2、创建虚拟环境 3.2.1、新建文件夹 DjangoSpace 3.2.2、执行命令 virtualenv venv(虚拟环境目录名称可以任意) 3.2.3 、在虚拟环境中安装Django框架 进入到DjangoSpace\venv\Scripts目录下执行：pip install Django
安装成功后
4、创建Django项目 cmd中创建Django 4.1、首先将路径切换到要创建Django项目的路径下 4.2、执行创建工程的命令 django-admin startproject （项目名称）
例如：创建一个学生管理系统
django-admin startproject studentsystem
4.3、工程目录说明
查看创建的工程目录，结构如下： 与项目同名的目录，此处为studentsystem。
settings.py 是项目的整体配置文件。
urls.py是项目的URL配置文件。
wsgi.py是项目与WSGI兼容的Web服务器入口。
manage.py是项目管理文件，通过它管理项目
4.4、 运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d1fef3a2736620629f455cc0e795ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66d955a64ca9e06570b895af43087fc/" rel="bookmark">
			Git的原理与使用(一):Git的基本操作(包含:版本回退)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git原理与使用一 一.Git的初识与安装1.什么是Git2.如何安装Git1.git命令与git help(Git下的"man手册")2.centos下安装Git3.ubantu下安装Git 二.Git的前置操作与前置知识1.创建Git本地仓库2.配置Git3.理解Git的分区1.工作区2.暂存区3.版本库4.分区关系总结 三.添加文件1.git add2.git commit3.git log查看历史提交记录4.git log --pretty=oneline 四.初步认识.git目录1.初步介绍2.HEAD跟master分支3.object和commit id4.总结 五.git diff查看修改六.版本回退1.git reset2.演示1.--soft2.--mixed3.--hard4.版本回退的实质5.版本回退中的后悔药 七.撤销修改1.未add2.已经add,还未commit3.已经commit了,但是还没有push4.已经push了 八.删除文件1.能否直接rm呢?2.误删3.的确要删除 一.Git的初识与安装 1.什么是Git Git是一个版本控制器
在这里我们重点介绍Linux操作系统下的Git的使用
因为在未来的开发过程中Linux操作系统的使用更为频繁
而且Git最初就是在Linux操作系统下面开发的
2.如何安装Git 1.git命令与git help(Git下的"man手册") 首先我们可以使用git命令来查看我们有没有安装Git
git 如果结果中有: command not found:说明我们还没有安装Git 如果结果是这样的
说明我们已经安装过Git了
在这里我们可以使用
git help Git下的具体命令/概念 来查看对应命令/概念的使用文档
跟man手册类似,按q键退出
2.centos下安装Git 安装git命令: sudo yum install -y git 查看git安装的版本: git --version 3.ubantu下安装Git 安装git命令: sudo apt-get install -y git 查看git安装的版本: git --version 二.Git的前置操作与前置知识 我们要想对文件进行版本控制
就必须先创建出一个仓库出来
仓库:进行版本控制的一个文件目录
1.创建Git本地仓库 我们目前在gitblog目录下面,我们想在这个目录下面创建一个git的本地仓库
使用命令:
git init 这个.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b66d955a64ca9e06570b895af43087fc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/561/">«</a>
	<span class="pagination__item pagination__item--current">562/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/563/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>