<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb569c65eebf27ed3b53cf6ff5c2087/" rel="bookmark">
			引领未来的智能革命：深度解析【人工智能】前沿技术与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天偶然发现了一个超棒的人工智能学习网站，内容通俗易懂，讲解风趣幽默，简直让人欲罢不能。忍不住分享给大家，点击这里立刻跳转，开启你的AI学习之旅吧！
前言 – 人工智能教程https://www.captainbed.cn/lzx
1. 人工智能基础 1.1 简介 人工智能（Artificial Intelligence, AI）是通过计算机模拟人类智能的技术。它的目标是让计算机能够执行通常需要人类智能才能完成的任务，如视觉识别、语音识别、决策制定和语言翻译等。AI 技术的核心在于利用算法和模型来处理和分析大量数据，从中学习和推断，从而完成复杂任务。
1.2 历史 早期发展 图灵测试：由 Alan Turing 在1950年提出，旨在评估机器是否具有人类智能。如果机器能与人类进行对话而不被识别为机器，则认为它具有人类智能。这一测试为AI的研究奠定了基础。Dartmouth会议：1956年在美国达特茅斯学院召开，标志着人工智能作为一个独立研究领域的正式诞生。此次会议提出了许多AI研究的基本问题和方法。 符号主义AI 逻辑推理：利用逻辑公式和规则进行推理和决策。早期的AI系统主要依赖符号和逻辑规则进行推理，如专家系统。专家系统：模拟人类专家的知识和经验，通过规则系统进行推理和决策。例如，MYCIN系统用于医学诊断，展示了专家系统在特定领域的强大能力。 机器学习的兴起 统计模型：如回归分析、贝叶斯网络，通过统计方法分析和预测数据。统计学习方法在处理大量数据时表现出色。神经网络：模拟生物神经元结构的计算模型，可以自动学习和调整权重以解决复杂问题。随着计算能力的提升，神经网络在图像识别、语音识别等领域取得了显著进展。 1.3 核心概念 机器学习 监督学习：利用带标签的数据进行训练，目的是学习从输入到输出的映射，如分类和回归任务。常见算法包括线性回归、逻辑回归、支持向量机和神经网络。无监督学习：利用未标注的数据进行模式发现，如聚类和降维。常见算法包括K-means聚类和主成分分析（PCA）。强化学习：通过与环境交互学习最优策略，以最大化累积奖励。常见算法包括Q学习和深度Q网络（DQN）。 深度学习 神经网络：由多层神经元组成的计算模型，用于模拟复杂函数。深度神经网络通过增加隐藏层数，可以处理更复杂的任务。卷积神经网络（CNN）：特别适用于图像处理，通过卷积层提取图像特征。CNN在图像分类、目标检测等任务中表现出色。循环神经网络（RNN）：特别适用于序列数据处理，通过循环结构捕捉序列中的时间依赖关系。RNN在自然语言处理、语音识别等领域有广泛应用。 1.4 主要算法 线性回归 线性回归是一种基本的回归分析方法，用于预测连续值。它假设输入变量和输出变量之间存在线性关系，通过最小化误差来拟合最优直线。
import numpy as np import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression # 数据准备 X = np.array([[1], [2], [3], [4], [5]]) y = np.array([1, 3, 2, 3, 5]) # 线性回归模型 model = LinearRegression() model.fit(X, y) # 预测 y_pred = model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb569c65eebf27ed3b53cf6ff5c2087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08cdec4e151e8e7d78eff3bae3237b9d/" rel="bookmark">
			校园课程助手【3】-使用枚举类封装异常优雅处理全局异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着2中登录模块补充一个点：
//可以看到这里返回给前端控制器的是一个类而不是html页面 public RespBean doLogin(@Valid LoginVo loginVo, HttpServletRequest request,HttpServletResponse response){ return userService.doLogin(loginVo, request, response); } 首先：在本项目中，所有的Controller类返回给前端控制器的都是ResBean对象，下面是这个类的实现，属性包括返回代码，提示信息以及一个Object类。
package com.example.seckilldemo.vo; import lombok.Data; /** * @Author wuyifan * @Date 2024/4/22 16:17 * @Version 1.0 */ @Data public class RespBean { private long code; private String message; private Object object; public static RespBean success() { return new RespBean(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), null); } public static RespBean success(Object object) { return new RespBean(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), object); } public static RespBean error(RespBeanEnum respBeanEnum) { return new RespBean(respBeanEnum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08cdec4e151e8e7d78eff3bae3237b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707666d5828682f959f2b3fe00547a38/" rel="bookmark">
			AI/机器学习（计算机视觉/NLP）方向面试复习3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Pooling 有哪些方式？pytorch的实现？ Pooling可以分成：最大池化，平均池化，全局平均池化，随机池化，空间金字塔池化。
1. 最大池化（Max Pooling） 最大池化是最常用的池化技术之一。它将输入图像划分为若干非重叠的矩形区域，然后对每个区域输出最大值。这种方法在实践中非常有效，能够很好地捕捉图像中的显著特征。
2. 平均池化（Average Pooling） 平均池化也将输入划分为多个区域，但它输出的是这些区域内的平均值。相较于最大池化，平均池化更平滑，但可能会丢失一些细节信息，因为它不像最大池化那样能突出显著特征。
3. 全局平均池化（Global Average Pooling） 全局平均池化是一种极端形式的平均池化，它计算整个特征图的平均值，通常用于卷积神经网络的最后阶段，直接输出用于分类的特征。这种方法能够显著减少模型的参数数量。
4. 随机池化（Stochastic Pooling） 随机池化是一种概率论的池化方法，不是简单地取最大值或平均值，而是根据预定义的概率分布（通常基于输入特征的大小）来选择池化区域内的元素。这种方法有助于增加模型的泛化能力，因为它引入了随机性。
6. 空间金字塔池化（Spatial Pyramid Pooling） 空间金字塔池化（SPP）是一种灵活的池化策略，它可以保持空间层次结构，允许网络接收任意大小的输入。SPP 通过在多个尺度上实现池化来捕获多层次的特征，这在一些特定的场景中非常有用，比如在需要处理不同分辨率的图像时。
2. attention的各种变形 self-attention里存在的问题是，当序列长度N非常大时，通过query(N,S) key(S,N) 相乘得到的Attention matrix(N,N)矩阵非常大。这里的计算过程非常复杂，就需要对self-attention进行简化。
而且这种简化经常会用在图像处理上，因为图像输入256×256的patch时，按像素为1个单位，N=256*256，过于大了。
一个方法是用感受野。把Attention matrix除了感受野以外的值设为0：（local attention）
但是这样设置感受野后，就和CNN没什么区别了。所以不太好。
Stride Attention：类似空洞卷积。每次看多几格的内容，例如空两格看三格以外的内容。
Local Attention：在原来的sequence里加上一个特殊的token。只有global token能获取所有的信息，其他token之间就不有attention了。Longformer用到了Global attention和striding attention， Big Bird用了global attention+striding attention和random attention。
Reformer：如何在Attention Matrix里，判断哪些地方有比较大的attention value，哪些地方的attention value比较小？然后把value比较大的取出来，当成attention。
这样做的方式是对query和key进行clustering聚类。clustering的加速方法有很多，可以快速将相近的query和key放在一起。只计算同类的query和key的attention，不同类的query和key的attention位为0，可以加速。
但这样是人类判断方式，根据任务判断两者之间是否相近。同样，也可以实现一个神经网络来判断key，value之间是否相近：Sinkhorn Sorting Network。
Linformer：本质在说attention matrix是一个低秩矩阵，列之间相关性很大，根本不需要构建这么大的attention matrix。就对列进行压缩。具体做法是从key中找到representative keys。
具体的压缩方法有：（1）对key做卷积进行压缩，（2）key是N维的，直接乘一个(N×K)的矩阵
k,q first -&gt; v,k first 最后一个点是，当matrix相乘的顺序不同时，计算的效率也不一样。KQ先相乘再乘V比下面：先V乘K再乘Q的效率大很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707666d5828682f959f2b3fe00547a38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b26dc84a8f497b75b58cca1fe4d4e90/" rel="bookmark">
			数据结构与算法——矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 数据结构与算法中，矩阵是一个重要的概念，它既是数据结构的一种，也是算法中经常需要处理的对象。以下是对矩阵的详细介绍：
一、矩阵的定义 矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合，它是一个二维的数据结构，由行和列组成，通常用来表示二维的数据集合。在数学中，矩阵最早来自于方程组的系数及常数所构成的方阵，这一概念由19世纪英国数学家凯利首先提出。在数据结构中，矩阵主要讨论如何在节省存储空间的前提下，正确高效地运算矩阵。
二、矩阵的特征 二维数组：矩阵也可以看作是一个二维数组，即“数组的数组”。元素类型：矩阵的元素可以是数字、字符、布尔值等类型。非线性结构：虽然矩阵表面上看似不符合线性表的特征（如首结点不唯一、尾结点不唯一、中间结点有两个直接前驱和两个直接后驱），但实质上，我们可以把每行（或每列）数据看成一个整体，作为一个数据元素，那么矩阵就符合线性表的特征，只是每个数据元素的类型又是一个线性表。 三、矩阵的存储方式 按行优先顺序存储：即将数组元素按行排序，第i+1行的第一个元素紧接在第i行的最后一个元素的后面。按列优先顺序存储：即将数组元素按列排序，第j+1列的第一个元素紧接在第j列的最后一个元素的后面。 四、矩阵的运算 矩阵的运算包括加法、减法、乘法、转置等。
加法与减法：矩阵的加法和减法要求两个矩阵的维数相同，即行数和列数都必须相等，然后对应位置的元素进行加或减运算。乘法：矩阵的乘法不是简单的对应位置元素相乘，而是按照矩阵乘法规则进行计算，即第一个矩阵的行向量与第二个矩阵的列向量进行点积运算。转置：矩阵的转置是将矩阵的行和列互换，即原矩阵的第i行第j列元素在转置矩阵中变为第j行第i列元素。 五、矩阵的应用 矩阵在计算机科学中有着广泛的应用，比如在机器学习和人工智能领域中，矩阵被用来表示数据集合和模型参数，进行数据处理和计算。在图形学中，矩阵被用来表示图像的像素值和进行图像处理操作。在网络编程中，矩阵也被用来表示网络拓扑结构和进行数据传输。此外，在物理学、工程学、经济学等多个领域，矩阵也有着重要的应用。
六、特殊矩阵 对称矩阵：在一个n阶方阵中，如果满足aij=aji（1≤i,j≤n），则称该矩阵为对称矩阵。对称矩阵关于主对角线对称，因此可以压缩存储，节省存储空间。稀疏矩阵：如果矩阵中数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律，则称该矩阵为稀疏矩阵。稀疏矩阵常使用三元组存储法，即存储非零元的同时，存储该元素所对应的行下标和列下标。 经典例题 1. 螺旋矩阵 题目描述：
给定一个正整数n，生成一个包含1到n^2所有元素，且元素按顺时针顺序螺旋排列的n x n正方形矩阵。
解题思路：
使用四个变量表示当前遍历的上下左右边界。按照右、下、左、上的顺序遍历矩阵，每次遍历到边界时更新边界值。当所有元素都被遍历时，结束循环。 #include &lt;vector&gt; using namespace std; vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 0)); int num = 1, left = 0, right = n - 1, top = 0, bottom = n - 1; while (num &lt;= n * n) { // Traverse right for (int i = left; i &lt;= right &amp;&amp; num &lt;= n * n; ++i) { matrix[top][i] = num++; } top++; // Traverse down for (int i = top; i &lt;= bottom &amp;&amp; num &lt;= n * n; ++i) { matrix[i][right] = num++; } right--; // If not the last element if (top &lt;= bottom) { // Traverse left for (int i = right; i &gt;= left &amp;&amp; num &lt;= n * n; --i) { matrix[bottom][i] = num++; } bottom--; } if (left &lt;= right) { // Traverse up for (int i = bottom; i &gt;= top &amp;&amp; num &lt;= n * n; --i) { matrix[i][left] = num++; } left++; } } return matrix; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b26dc84a8f497b75b58cca1fe4d4e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902fcf22c345deb6f2bc8aea751c2821/" rel="bookmark">
			趋动科技助力中国移动新型智算中心AI算力池化商用实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由中国通信标准化协会、中国通信学会指导，CCSA TC610 SDN /NFV /AI标准与产业推进委员会主办的2024年云网智联大会于4月10日-11日在北京召开。
趋动科技联合申报的“中国移动新型智算中心AI算力池化商用实践”，获得2023年度SDN、NFV、网络AI优秀案例征集最佳实践案例。
趋动科技助力中国移动新型智算中心AI算力池化商用实践
由中国移动提出并由趋动科技参与的新型智算中心智算资源池化平台方案，借鉴云计算的思路，对GPU、AI芯片等AI加速器资源进行聚合池化，利用先进的资源管理技术进行切分、调度和分配，使能资源可按任务实际需求进行有序供给，以充分利用稀缺、昂贵的算力资源，降低其不可分配的碎片概率。
智算资源池化平台以“软件定义”的方式，提供四大资源敏捷管理核心功能，优化资源效率，降低总体购置成本。
● 化整为零：改变传统的整卡分配、一虚多的粗放式分配方式，使能精细化分配能力，根据AI任务需求做到1%算力和1MB显存的细粒度资源按需供给；
● 隔空取物：基于高速无损网络，跨节点调取智算资源，使CPU及AI加速器高度解耦，进一步降低碎片化率；
● 化零为整：整合分布在多机上的零散资源，汇聚成为大模型业务可使用的资源，使资源可高效分配；
● 变静为动：改变传统的资源静态绑定的机制，使能资源可以根据负载变化动态分配、回收，多任务间可以峰谷互补，全局资源可以适度超分，促进资源效率提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4001183a827990cc7cd99da23bee41/" rel="bookmark">
			【TS】TypeScript声明文件：打通JavaScript和TypeScript的桥梁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 TypeScript声明文件：打通JavaScript和TypeScript的桥梁1. 引言2. 什么是声明文件？3. 声明文件的作用4. 声明文件的基本语法4.1 声明变量4.2 声明函数4.3 声明类4.4 声明模块 5. 创建声明文件5.1 为全局库创建声明文件5.2 为模块库创建声明文件5.3 使用命名空间 6. 声明文件的查找机制7. 使用第三方声明文件8. 编写高质量的声明文件8.1 使用接口描述对象形状8.2 使用函数重载描述多态行为8.3 使用泛型增加灵活性8.4 使用联合类型和交叉类型 9. 声明合并10. 模块扩充11. 声明文件中的特殊类型11.1 any11.2 unknown11.3 never 12. 条件类型在声明文件中的应用13. 声明文件的最佳实践14. 声明文件的测试15. 发布声明文件16. 实际应用示例17. 结论 TypeScript声明文件：打通JavaScript和TypeScript的桥梁 1. 引言 在TypeScript的世界中，声明文件扮演着至关重要的角色。它们是连接TypeScript和JavaScript的桥梁，使得TypeScript能够理解并检查JavaScript代码。本文将深入探讨TypeScript声明文件的概念、用途、编写方法以及最佳实践，帮助您更好地理解和运用这一重要工具。
2. 什么是声明文件？ 声明文件是以.d.ts为扩展名的文件，它们不包含实现代码，而是包含了TypeScript的类型声明。这些文件的主要目的是为JavaScript库提供类型信息，使TypeScript能够进行类型检查和提供智能提示。
3. 声明文件的作用 类型检查：让TypeScript编译器能够检查JavaScript代码的使用是否符合类型定义。代码提示：为IDE提供智能提示和自动完成功能。文档：作为一种文档形式，描述JavaScript库的API。兼容性：允许TypeScript项目使用JavaScript库。 4. 声明文件的基本语法 4.1 声明变量 declare var myLibrary: { name: string; version: number; }; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca4001183a827990cc7cd99da23bee41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb86eedb76dabbe09e3bfd734dc4991/" rel="bookmark">
			vue&#43;elementui实现下拉表格多选&#43;搜索&#43;分页&#43;回显&#43;全选2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue+elementui实现下拉表格多选+搜索1.0 二、vue+elementui实现下拉表格多选+搜索+分页+回显+全选2.0 在1.0的基础上，终于可以实现在下拉框表格分页的前提下不同页码的回显辣，分页是前端来分页的（代码略乱且没有封装还很长，随便看看吧）
1、在使用之前首先要安装Element-ui 1-1、template &lt;template&gt; &lt;div class="goodsindex"&gt; &lt;div class="allBox" v-loading="isloading"&gt; &lt;el-select id="equBox" ref="select" clearable multiple v-model="group.equIdList" placeholder="请选择设备" @change="handleEquId" @click.native="deptogglePanel($event)" &gt; &lt;el-option v-for="(item, i) in group.pageAllList" :key="i" :label="item.equNumber" :value="item.equId" &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;div v-if="group.showTree" class="treeDiv" id="treeDiv" ref="tableList" :style="{ top: group.equBoxTop + 'px' }" &gt; &lt;div class="equSElect"&gt; &lt;el-input v-model="group.name" clearable size="mini" style="margin-right: 15px; width: 50%" placeholder="设备编码/名称" @keyup.enter.native="select" &gt;&lt;/el-input&gt; &lt;el-button type="primary" size="mini" @click="select"&gt;搜索&lt;/el-button&gt; &lt;/div&gt; &lt;!-- 检索结果 --&gt; &lt;el-table :data="group.pageList" border size="mini" style="margin: 10px 0"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb86eedb76dabbe09e3bfd734dc4991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84aecee618e4f524b74a4dd6a2220a62/" rel="bookmark">
			【海贼王航海日志：前端技术探索】HTML你学会了吗？(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 -&gt; HTML常见标签
1.1 -&gt; 表格标签
1.1.1 -&gt; 基本使用
1.1.2 -&gt; 合并单元格
1.2 -&gt; 列表标签
1.3 -&gt; 表单标签
1.3.1 -&gt; form标签
1.3.2 -&gt; input标签
1.4 -&gt; label标签
1.5 -&gt; select标签
1.6 -&gt; textarea标签
1.7 -&gt; 无语义标签：div &amp; span
2 -&gt; Emmet快捷键
3 -&gt; HTML特殊字符
4 -&gt; 小结
1 -&gt; HTML常见标签 1.1 -&gt; 表格标签 1.1.1 -&gt; 基本使用 &lt;table&gt;标签：表示整个表格。&lt;tr&gt;标签：表示表格的一行。&lt;td&gt;标签：表示一个单元格。&lt;th&gt;标签：表示表头单元格。会居中加粗。&lt;thead&gt;标签：表格的头部区域(注意和&lt;th&gt;标签区分，范围比&lt;th&gt;标签要大)。&lt;tbody&gt;标签：表格得到主体区域。 &lt;table&gt;标签包含&lt;tr&gt;标签，&lt;tr&gt;标签包含&lt;td&gt;标签或者&lt;th&gt;标签。
表格标签有一些属性，可以用于设置大小边框等。但是一般使用CSS方式来设置。
这些属性都要放到&lt;table&gt;标签中。
align是表格相对于周围元素的对齐方式。align="center" (不是内部元素的对齐方式)。border表示边框。1表示有边框(数字越大，边框越粗)，"" 表示没边框。cellpadding表示内容距离边框的距离，默认1像素。cellspacing表示单元格之间的距离。默认为2像素。width/height：设置尺寸。 注意，这几个属性，在vscode都提示不出来。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84aecee618e4f524b74a4dd6a2220a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3037c183075934699c60aaaae9b9bd6/" rel="bookmark">
			MySQL学习（17）：SQL编程：存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是存储过程 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合。
存储过程的特点：
（1）封装，复用
（2）可以接收参数，可以返回数据
2.存储过程语法 2.1创建 create procedure 存储过程名([参数列表]) #小括号必须要有，参数列表可以没有 begin SQL语句 end; 2.2调用 call 存储过程名([参数列表]); 2.3查询 （1）查询指定数据库的存储过程及状态信息
select * from information_schema.routines where routine_schema='数据库名'; （2）查询某个存储过程的定义
show create procedure 存储过程名; 查询结果出现的root是创建存储过程的用户
2.4删除 drop procedure 存储过程名; 2.5结束符号问题 在存储过程的SQL语句部分中，需要分号切分语句，而分号是mysql识别一条命令完结的标识，所以会造成使用分号后，SQL语句直接执行，无法创建存储过程。
要解决此问题，可以通过delimiter命令更改结束符，来规避此问题：
delimiter $$ #属于这条命令后，mysql所有语句的结束符就由分号变为$$了 #$$不是固定的，可以自行设置结束符 使用实例如下图：
创建完存储过程后，还可以再用delimiter命令把结束标志改回分号
3.存储过程变量 3.1系统变量 系统变量是mysql服务器提供的，分为全局变量（global）、会话变量（session）
（1）查看系统变量
show [global] variables; #查看所有变量 #不写global是检索当前会话的变量，写global是检索mysql全局的变量 show [global] variables like '匹配内容'; #通过like模糊匹配查找变量，_匹配单字符，%匹配多字符 select @@[global] 系统变量名; #查看指定变量 （2）设置系统变量
set [global] 系统变量名=值； 或 set @@[global]系统变量名=值； 变量值设置完后（无论是全局还是会话），只要重启数据库，系统变量名就都会恢复成默认值。如果想永久更改，需要在配置文件/etc/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3037c183075934699c60aaaae9b9bd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d772498708a6efd04be0693b4695639/" rel="bookmark">
			第三届Apache Flink 极客挑战赛暨AAIG CUP比赛攻略_大浪813团队
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关联比赛: 第三届 Apache Flink 极客挑战赛暨AAIG CUP——电商推荐“抱大腿”攻击识别
第三届Apache Flink 极客挑战赛暨AAIG CUP比赛攻略_大浪813团队 第三届Apache Flink 极客挑战赛暨AAIG CUP 自2021年8月17日上线以来已有 4537 个参赛队伍报名。11月09号，大赛复赛结束，我们团队（队伍名称：大浪813）最终取得了初赛第7名，复赛第8名的成绩。下面就将我们团队的比赛心得和攻略分享一下，与各位参赛小伙伴共勉。
1.1 赛题说明 1.1.1 赛题背景 随着互联网的发展，网购成为越来越多人的选择，据阿里巴巴财报显示，2020财年阿里巴巴网站成交总额突破一万亿美元，全球年度活跃消费者达9.60亿。
为了满足不同用户的个性化需求，电商平台会根据用户的兴趣爱好推荐合适的商品，从而实现商品排序的千人千面需求。推荐系统常见的召回路径有U2I（User-Item）、I2I（Item-Item）等。其中，user-to-item是指通过用户的 profile信息为用户进行商品的推荐，而item-to-item推荐策略则根据用户的商品点击列表为用户推荐关联的商品。
推荐系统的目的是基于不同用户的偏好进行千人千面的推荐。传统的离线推荐系统基于用户历史的行为数据进行加工处理，形成特征样本，然后离线训练模型，并且在线部署进行服务。然而用户的偏好是多元的、用户的行为分布会随着时间而变化，离线的模型无法刻画这种动态的用户偏好，因此需要进行实时的特征更新与模型参数更新，从而能够更好的捕获用户的行为偏好。在推荐场景中，为了更好的提升推荐的时效性与准确性，平台会基于全网的用户行为信息进行实时的 U2I 及 I2I 的更新，并且基于用户最近的行为信息进行相关性的推荐。
为了获取更多的平台流量曝光，将自己的商品展现在更多的消费者面前，部分商家通过HACK平台的推荐机制从而增加商品的曝光机会。其中一种典型的手法为“抱大腿”攻击，该方法通过雇佣一批恶意用户协同点击目标商品和爆款商品，从而建立目标商品与爆款商品之间的关联关系，提升目标商品与爆款商品之间的I2I关联分。商家通过这种方式诱导用户以爆款的心理预期购买名不符实的商品，不仅损害了消费者的利益，降低其购物体验，还影响了平台和其他商家的信誉，严重扰乱了平台的公平性。因此，我们需要用一个风控系统来过滤掉这些可能的恶意流量，避免它们对推荐系统的模型造成干扰。
由于所有用户行为在输入推荐系统之前，都会首先经过风控系统的过滤，所以如果想要做到推荐系统的实时性，风控系统就必须同样做到实时性。实时拦截此类行为，有助于在保证推荐的时效性的同时，保护实时推荐系统不受恶意攻击影响。
实时风控系统对数据安全的要求较高，如果系统的拦截算法意外泄漏，HACK平台将得以针对性地加强恶意流量的伪装能力，增大平台监控恶意流量的难度，因此，此类系统有必要部署在加密的可信环境中。
综上所述，为了保障实时推荐系统的准确性，比赛要求选手实现一个保证了数据安全的实时风控系统。本次大赛要求选手基于Flink，Analytics Zoo/BigDL 等组件，在Occlum环境中搭建保护数据安全的PPML（Privacy Preserving Machine Learning）应用，实现对恶意流量的实时识别。
1.1.2 技术介绍 Apache Flink 是一个在无界和有界数据流上进行状态计算的框架和分布式处理引擎。Flink 已经可以在所有常见的集群环境中运行，并以 in-memory 的速度和任意的规模进行计算。
在Flink的基础上，Flink AI Flow作为兼顾流计算的大数据 + AI 顶层工作流抽象和配套服务，提供了机器学习的端到端解决方案。
Analytics Zoo及BigDL是英特尔®开源的统一大数据分析和AI平台，支持分布式TensorFlow及PyTorch的训练和推理，通过OpenVINO工具套件和DL Boost指令集等，提升深度学习工作负载的性能。Cluster Serving是Analytics Zoo/BigDL的分布式推理解决方案，可以部署在Apache Flink集群上进行分布式运算。
Occlum是蚂蚁集团基于Intel SGX的开源LibOS，使得 Linux 应用程序在只修改少量代码或者完全不修改代码的情况下运行于 Enclave 安全环境中，保证数据处于加密和强隔离状态，确保数据安全与用户隐私。
1.1.3 数据说明 给定恶意点击、正常点击及对应的“商品”、“用户”相关的属性信息（用户本地调试可以从网上下载），选手实现实时的恶意点击识别分类算法，包括模型训练和模型预测。在大赛评测系统中，系统使用100万条数据用于模型训练、10万条数据用于模型预测。另外，比赛提供给选手50万条数据的数据集用于算法的本地调试。
比赛提供如下格式的数据用于训练与预测。所有数据均采用csv格式保存在文件中，即以下数据格式的各列之间以逗号分隔。每条数据代表一次用户点击商品的行为，它的特征主要来源于其所关联的用户与商品。
· uuid：每条数据的id。该id在数据集内具有唯一性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d772498708a6efd04be0693b4695639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2d5c5c3eb725e4476cdc0d856fb043/" rel="bookmark">
			基于扩展卡尔曼滤波的SOC估计（附MATLAB代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取同款资料：2629471989 1.卡尔曼滤波原理 原理可以参考我之前学习的笔记，使用goodnote完成的。
我认为，对于公式的推导不需要做太多深入的了解，我之前也对公式进行推导的理解，但是没过几天就忘了，只需要掌握住那重要的5个步骤即可，能够熟练运用才是王道。
2.扩展卡尔曼滤波的MATLAB代码实现 下面介绍一下如何通过MATLAB，使用扩展卡尔曼滤波完成SOC的估计，我会将代码里面需要修改的地方进行讲解，当你辨识完参数要进行SOC估计时，只需要修改我所说的就能够实现。
2.1 电池参数的修改 Cn=18*3600;%电池容量，单位As delta_t=1;%采样时间 R1=-9.015*socc.^6+20.64*socc.^5-15*socc.^4+2.196*socc.^3+1.747*socc.^2-0.7141*socc+0.09635; R2=38.17*socc.^6-106.5*socc.^5+115.7*socc.^4-61.8*socc.^3+16.93*socc.^2-2.263*socc+0.1285; C1=-6.037e+06*socc.^6+1.697e+07*socc.^5-1.81e+07*socc.^4+9.097e+06*socc.^3-2.189e+06*socc.^2+2.367e+05*socc-7963; C2=1.82e+08*socc.^6-4.243e+08*socc.^5+3.83e+08*socc.^4-1.75e+08*socc.^3+4.456e+07*socc.^2-5.862e+06*socc+3.205e+05; ro=0.05;%电池内阻 Cn就是电池容量，你自己的电池容量是多少就写多少，18代表时间Ah，注意单位是Ah。
采样时间可以不用改，；
R1：就写拟合得到的R1与SOC的多项式，也可以是常数；
R2：就写拟合得到的R2与SOC的多项式，也可以是常数；
C1：就写拟合得到的C1与SOC的多项式，也可以是常数；
C2：就写拟合得到的C2与SOC的多项式，也可以是常数；
R0：就写拟合得到的R0与SOC的多项式，也可以是常数；
2.2 电流数据以及SOC-OCV曲线 i=I1; i(1)=0;%放电电流矩阵 fn=@(x) -189.5*x^6+696.7*x^5-1007*x^4+727.8*x^3-275.4*x^2+51.63*x+9.562;%拟合soc-ocv表达式 syms t1; g=fn(t1); g=matlabFunction(diff(g));%fn对soc的偏导 A=[1 0 0;0 rp1*cp1/(delta_t+rp1*cp1) 0;0 0 rp2*cp2/(delta_t+rp2*cp2)]; B=[-delta_t/Cn;delta_t*rp1/(delta_t+rp1*cp1);delta_t*rp2/(delta_t+rp2*cp2)];%A，B矩阵 t=0:delta_t:14000;%仿真序列时间 电流要导入自己的电流数据；
要注意仿真序列时间不要超过电流数据的长度；
3.扩展卡尔曼算法迭代 Xekf=zeros(size);%EKF下的状态变量 P0=eye(3);%协方差矩阵初值 Xekf(:,1)=[1;0;0];%EKF状态变量初值，可更改 for k=2:N Xn=A*Xekf(:,k-1)+B*i(k);%计算先验估计 P1=A*P0*A'+Q;%更新协方差矩阵 dd=Xn(1)-Soc(k);%计算先验估计值与真值的差 Zm=g(Soc(k))*dd+fn(Soc(k))-Xn(2)-Xn(3)-i(k)*ro;%计算观测值 H=[g(Xn(1)) 0 0];%雅克比矩阵计算 K=P1*H'*inv(H*P1*H'+R);%计算卡尔曼增益 Xekf(:,k)=Xn+K*(Uoc(k)-Zm);%更新状态 P0=(eye(3)-K*H)*P1;%更新协方差方程 end Socekf=zeros(1,N);%Ekf下的soc Uocekf=zeros(1,N);%Ekf下的端电压 Eekf=zeros(1,N);%EKF下的电池电压 for k=1:N Socekf(k)=Xekf(1,k); Eekf(k)=fn(Socekf(k)); Uocekf(k)=fn(Socekf(k))-i(k)*ro-Xekf(2,k)-Xekf(3,k); end%计算三个值 完整代码点赞评论关注后吗，私信我获取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2d5c5c3eb725e4476cdc0d856fb043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc6510005bdd50ad895ccbe6adc857b/" rel="bookmark">
			什么是接口？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前后端开发的语境中，接口（Interface）是一个非常重要的概念，它充当了前端（通常是浏览器端或移动端应用）与后端（通常是服务器端的应用程序）之间进行数据交换的桥梁。接口定义了双方交互的方式，包括数据的格式、请求的方法（如GET、POST、PUT、DELETE等）、请求的路径（URL）、请求和响应时携带的参数等。
接口的作用 数据传递：接口允许前端从后端获取数据或向后端提交数据，实现数据的动态交互。解耦：通过定义明确的接口，前端和后端可以独立开发，只要双方遵守接口协议，就可以实现无缝对接。这有助于提高开发效率，降低维护成本。安全性：接口可以通过身份验证、权限控制等手段保护数据的安全性。 接口的类型 RESTful接口：基于REST（Representational State Transfer，表述性状态转移）原则设计的接口，是目前最流行的接口设计风格之一。RESTful接口通常使用HTTP协议，通过不同的请求方法（GET、POST、PUT、DELETE等）和URL路径来表示不同的操作。RPC（远程过程调用）接口：允许一个程序调用另一个地址空间（通常是网络上的另一台机器）的过程或函数，就像调用本地程序一样。RPC接口不局限于HTTP协议，可以基于多种协议实现。GraphQL接口：GraphQL是一种用于API的查询语言，它允许客户端精确地指定它们需要的数据，而不是像REST那样返回整个数据集。GraphQL接口提供了一种更高效、更灵活的数据获取方式。 前后端接口的开发流程 需求分析：明确需要哪些数据交互，确定接口的功能和用途。接口设计：根据需求分析的结果，设计接口的URL路径、请求方法、请求参数、响应格式等。后端开发：后端开发人员根据接口设计文档实现接口逻辑，包括数据的获取、处理和返回。前端调用：前端开发人员根据接口设计文档，使用Ajax、Fetch等技术调用后端接口，获取或提交数据。接口测试：对接口进行测试，确保接口的功能、性能、安全性等方面符合需求。文档编写：编写接口文档，包括接口的描述、请求参数、响应格式、错误码等信息，供前端开发人员和后端开发人员参考。 总之，接口是前后端开发中不可或缺的一部分，它使得前后端可以独立开发、协同工作，共同构建出优秀的应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1608f06db255f9d9192107fe7b35b5c1/" rel="bookmark">
			springboot系列教程（三十一）：springboot整合Nacos组件，环境搭建和入门案例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Nacos基础简介 1、概念简介 Nacos 是构建以“服务”为中心的现代应用架构，如微服务范式、云原生范式等服务基础设施。聚焦于发现、配置和管理微服务。Nacos提供一组简单易用的特性集，帮助开发者快速实现动态服务发现、服务配置、服务元数据及流量管理。敏捷构建、交付和管理微服务平台。
2、关键特性 动态配置服务服务发现和服务健康监测动态 DNS 服务服务及其元数据管理 3、专业术语解释 命名空间 用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。
配置集 一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。
配置集 ID Nacos 中的某个配置集的ID。配置集ID是组织划分配置的维度之一。DataID通常用于组织划分系统的配置集。
配置分组 Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串对配置集进行（Group）分组，从而区分 Data ID 相同的配置集。
配置快照 Nacos 的客户端 SDK 会在本地生成配置的快照。当客户端无法连接到 Nacos Server 时，可以使用配置快照显示系统的整体容灾能力。
服务注册 存储服务实例和服务负载均衡策略的数据库。
服务发现 使用服务名对服务下的实例的地址和元数据进行探测，并以预先定义的接口提供给客户端进行查询。
元数据 Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略等。
4、Nacos生态圈 Nacos 无缝支持一些主流的开源框架生态：
Spring Cloud 微服务框架 ;Dubbo RPC框架 ;Kubernetes 容器应用 ; 二、Nacos环境搭建 1、环境版本 这里在Windos环境下搭建Nacos单个服务。
Nacos版本：官方推荐的稳定版本为1.1.4。基础环境：JDK 1.8+；Maven 3.2.x 2、环境包下载 这里直接下载打包好的文件，也可以下载源码自己打包。
https://github.com/alibaba/nacos/releases
下载文件：nacos-server-1.1.4.zip
3、启动环境 启动文件地址：nacos\bin启动文件：startup.cmd关闭文件：shutdown.cmd 启动后登陆，账户密码默认：nacos/nacos ;首页效果如下：
三、整合SpringBoot2 注意：版本 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1608f06db255f9d9192107fe7b35b5c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53a24897c79fce0e0ef54915575abf9/" rel="bookmark">
			三品PDM系统在零部件标准化中的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今快速发展的制造业中，标准化已成为企业提升竞争力的关键。零部件物料信息的标准化不仅关系到产品质量，还直接影响到企业运营的效率和成本。本文将探讨标准化的重要性，并以产品数据管理PDM系统为例，分析其在零部件标准化管理中的应用和效益。
标准化：制造业的基石 标准化工作是制造业企业技术进步和提升管理水平的基石。它对提高产品质量、降低运营成本、增强市场竞争力和扩大产品市场占有率具有不可替代的作用。零部件标准化作为标准化工作的核心，对工艺、采购、生产、品质和售后管理等多个环节的提升至关重要。
传统标准化的局限 尽管标准化的重要性已被广泛认识，但在实际操作中，许多企业仍面临挑战。传统的标准化管理模式往往难以适应现代企业复杂的产品设计需求和激烈的市场竞争。"一物多码"和"一物多图"的问题普遍存在，导致管理混乱和资源浪费。
PDM系统：标准化管理的利器 为了解决这些问题，越来越多的企业开始采用PDM系统来完善零部件的标准化管理。三品PDM系统通过前期规划、分类、编码规则和关键信息定义，帮助企业建立起一套有效的标准化管理体系。
三品PDM系统实施步骤
1. 前期规划：对零部件进行分类，制定编码规则，定义关键信息。
2. 分类与编码：根据生产方式、结构形式、功能等对零部件进行分类，并制定相应的编码规则。
3. 关键信息定义：为不同类型零部件定义关键信息，如轴套的内径、外径和长度。
三品PDM系统优势
避免重复：通过系统自动生成编码和文件名称，确保零部件的唯一性，避免"一物多码"的问题。
提升通用率：通过模糊检索功能，提高零部件的通用性，减少不必要的设计和生产。
降低成本：减少零部件数量，降低仓库备货种类和数量，减轻运营压力。
信息流转：统一标准化的信息流转，减少信息不对称和错误造成的损失。
结语 零部件物料信息标准化是提升制造业竞争力的重要途径。通过PDM系统的有效实施，企业不仅能够解决传统标准化过程中的问题，还能够在激烈的市场竞争中占据优势。标准化不再是纸上谈兵，而是企业实现可持续发展的有力工具。
在制造业的未来发展中，标准化将继续扮演着核心角色。企业需要不断探索和创新，以适应不断变化的市场需求和技术进步。通过实施有效的标准化管理，企业将能够以更高的效率、更低的成本和更优的质量，迎接未来的挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357300a39041a27a55524238574d4678/" rel="bookmark">
			JavaScript中的Array
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript中的Array 数组的创建 创建数组 const colors = new Array(); const colors = new Array(20); const colors = new Array("red", "blue", "yellow"); 不使用new关键字 const colors = Array(20); const colors = Array("red", "blue", "yellow"); 这些数组创建等价于[]
数组的转换 map集合转换 const map = new Map(); map.set(1, 2); map.set("Bunny", 16); console.log(Array.from(map));// [ [ 1, 2 ], [ 'Bunny', 16 ] ] 使用set转换 const set = new Set(); set.add(1); set.add("bunny"); set.add(16); console.log(Array.from(set));// [ 1, 'bunny', 16 ] Array是浅复制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/357300a39041a27a55524238574d4678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a380e06d4bc699dc2d15a0e1825ba587/" rel="bookmark">
			大学新生编程入门最佳攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 编程的重要性：简述编程在当今社会的地位，为何它是大学生的必备技能。目标设定：明确文章旨在帮助新生从零基础开始，逐步成长为编程高手。 方向一：编程语言选择 1. 编程语言概览 介绍几种流行语言：如Python、JavaScript、Java、C++等。特点对比： Python：简单易学，语法清晰，适合入门，广泛应用于数据分析、AI、Web开发等。JavaScript：网页开发的基石，前端必备，也可用于Node.js后端开发。Java：企业级应用开发常用，跨平台性强，学习曲线较陡。C++：性能强大，适合系统级编程和游戏开发，但学习难度较大。 2. 如何选择 兴趣导向：根据个人兴趣选择，比如喜欢Web开发可选JavaScript。职业规划：考虑未来职业方向，如数据科学选Python。社区支持：查看各语言的社区活跃度和学习资源。 方向二：学习资源推荐 1. 在线课程 MOOC平台：推荐Coursera、edX、Udemy等平台上的优质编程课程。免费资源：如Codecademy、FreeCodeCamp等提供免费编程学习路径。 2. 书籍推荐 入门书籍：《Python编程：从入门到实践》、《JavaScript权威指南》等。进阶书籍：根据学习进展推荐更专业的书籍。 3. 编程社区 Stack Overflow：提问和解答编程问题。GitHub：参与开源项目，学习他人代码。Reddit、Hacker News：获取行业动态和最新技术信息。 4. 有效利用资源的建议 系统学习：按照课程或书籍的顺序逐步深入。实践为主：多做练习，尝试解决实际问题。定期复习：巩固已学知识，避免遗忘。 方向三：学习方法与技巧 1. 制定学习计划 SMART原则：具体（Specific）、可测量（Measurable）、可达成（Achievable）、相关性（Relevant）、时限性（Time-bound）。分阶段目标：设置短期和长期目标，如每周完成一个章节学习。 2. 项目实践 从简到难：开始时选择简单的项目，逐步增加难度。动手做：不要害怕失败，通过实践加深理解。分享作品：在GitHub等平台分享你的项目，接受反馈。 3. 解决问题 主动搜索：遇到问题时先自己搜索解决方案。寻求帮助：在编程社区提问，向他人请教。记录笔记：将问题和解决方法记录下来，便于复习。 4. 持续学习 跟进新技术：编程领域发展迅速，保持对新技术的关注。阅读博客和文档：定期阅读行业博客和官方文档，拓宽视野。参加技术会议：有机会的话，参加线上或线下的技术会议，与同行交流。 编程语言选择 深入Python和JavaScript Python
案例分享：分享一些使用Python实现的有趣项目，如使用Pandas进行数据分析、使用TensorFlow或PyTorch构建简单的机器学习模型、或者使用Django或Flask创建Web应用。这些案例能激发新生的学习兴趣，并让他们看到Python的广泛应用。
学习路径：提供一个从基础语法到进阶应用的Python学习路线图，包括安装Python环境、学习基本数据类型、控制流、函数、面向对象编程、标准库的使用，再到第三方库（如NumPy、Pandas、Matplotlib）的引入。
JavaScript
前端基础：强调JavaScript作为前端开发的基石，介绍HTML和CSS的基础知识，因为它们是构建网页界面的基础。然后，详细讲解JavaScript的DOM操作和事件处理，这是与用户交互的关键。
现代JavaScript：介绍ES6及以后版本的新特性，如箭头函数、模板字符串、Promise、async/await等，这些是现代JavaScript开发中不可或缺的部分。
Node.js：简要介绍Node.js，它是JavaScript在服务器端的运行环境，可以让JavaScript开发者实现全栈开发。可以分享一些使用Node.js和Express框架创建RESTful API的简单示例。
学习资源推荐 精选在线课程 Coursera：推荐几门高分评价的Python或JavaScript入门课程，如“Python for Everybody”和“Introduction to JavaScript: Developing Interactive Web Pages”。
Udemy：介绍一些由知名讲师录制的、内容详实且价格亲民的编程课程，鼓励学生利用优惠券或促销时机购买。
书籍与教程 进阶推荐：对于已经有一定基础的学生，推荐更深入的书籍，如《Effective Python》、《Eloquent JavaScript》等，这些书籍不仅讲解语法，还深入探讨编程的最佳实践和思维模式。
官方文档：强调阅读官方文档的重要性，尤其是当你需要深入了解某个库或框架时。鼓励学生养成查阅官方文档的习惯。
学习方法与技巧 高效学习技巧 番茄工作法：介绍这种方法，即将工作时间划分为25分钟的学习时间和5分钟的短暂休息，每完成四个“番茄”后，可以休息更长的时间。这种方法有助于提高集中力和效率。
代码复审：鼓励学生定期回顾自己的代码，或者与同伴进行代码复审，这有助于发现潜在的问题，学习他人的编程风格，并提升代码质量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a380e06d4bc699dc2d15a0e1825ba587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77197a03e43cf97d191df1ad8fe0236/" rel="bookmark">
			笔记小结：《利用Python进行数据分析》之读取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
读取文本格式的数据
基本操作
指定分隔符
指定标题行
层次化索引
使用正则表达式分隔
跳过某些行
缺失值处理
逐块读取文本文件
设置显示的最大行数
只读取几行
逐块读取文件
将数据写出到文本格式
基本操作
使用其它分隔符
使用其它标记符标记空白字符串
禁用标签
只显示部分列
处理分隔符格式
JSON数据
基本介绍
与python中数据结构的转化
读取文本格式的数据 基本操作 首先我们来看一个以逗号分隔的（CSV）文本文件：
In [8]: !cat examples/ex1.csv a,b,c,d,message 1,2,3,4,hello 5,6,7,8,world 9,10,11,12,foo 由于该文件以逗号分隔，所以我们可以使用read_csv将其读入一个DataFrame：
In [9]: df = pd.read_csv('examples/ex1.csv') In [10]: df Out[10]: a b c d message 0 1 2 3 4 hello 1 5 6 7 8 world 2 9 10 11 12 foo 指定分隔符 我们还可以使用read_table，并指定分隔符。这是个很好的方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77197a03e43cf97d191df1ad8fe0236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839b49a8b6915a6d2904604866165350/" rel="bookmark">
			​十个常见的 Python 脚本 (详细介绍 &#43; 代码举例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 批量重命名文件 介绍: 该脚本用于批量重命名指定目录下的文件，例如将所有 ".txt" 文件重命名为 ".md" 文件。
import os def batch_rename(directory, old_ext, new_ext): """批量重命名文件扩展名。 Args: directory: 要处理的目录路径。 old_ext: 要替换的旧扩展名。 new_ext: 要替换的新扩展名。 """ for filename in os.listdir(directory): if filename.endswith(old_ext): base_name = os.path.splitext(filename)[0] new_filename = base_name + new_ext old_path = os.path.join(directory, filename) new_path = os.path.join(directory, new_filename) os.rename(old_path, new_path) # 示例用法：将当前目录下所有 ".txt" 文件重命名为 ".md" 文件 batch_rename(".", ".txt", ".md") 2. 下载网页图片 介绍: 该脚本用于下载指定网页上的所有图片，并保存到本地目录。
import requests from bs4 import BeautifulSoup import os def download_images(url, save_dir): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/839b49a8b6915a6d2904604866165350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2f9a81b4147a2c942ae1943eec5c83/" rel="bookmark">
			（24）(24.1) FPV和仿真的机载OSD（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
1 参数
2 第二OSD
3 屏幕和屏幕切换
4 面板项目
5 呼号面板
6 用户可编程警告
7 使用SITL测试OSD
8 OSD面板列表
前言 使用 MAX7456 型芯片的板载操作系统和基于 MSP 的外部操作系统（包括 DJI 护目镜和使用DisplayPort 的护目镜）提供 OSD 功能。
使用 MAX7456 型芯片的板载操作系统和基于 MSP 的外部操作系统（包括 DJI 护目镜和使用DisplayPort 的护目镜）提供 OSD 功能。这使得 FC 数据能够叠加在视频上。启用后，它使用各种面板项目，这些项目可以单独设置为活动状态，并使用相应的参数在屏幕上定位。它允许设置多个屏幕布局，并使用备用 RC 通道在这些布局之间切换。在某些情况下，它还允许使用摇杆手势或RC 发射器显示和更改参数集。
！Note
作为 ArduPilot 固件的集成库，OSD 代码提供了重定向到 MAX 型芯片组以外的各种后端的先决条件，包括在不需要实际自动驾驶仪或视频硬件的情况下在 SITL 设置上进行测试。
1 参数 要在 MAX7456 型芯片上启用 OSD 覆盖，请将参数 OSD_type 设置为 1，重新启动并重新加载参数。这将显示整个 OSD 参数组。
要设置屏幕切换的RC通道，请使用参数 OSD_CHAN。
要设置用于显示的单位，请使用参数 OSD_units：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff2f9a81b4147a2c942ae1943eec5c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a6e36be66a1139e690fd4dfbb18fa7e/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(060)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
231、pandas.Series.reorder_levels方法
231-1、语法
231-2、参数
231-3、功能
231-4、返回值
231-5、说明
231-6、用法
231-6-1、数据准备
231-6-2、代码示例
231-6-3、结果输出
232、pandas.Series.sort_values方法
232-1、语法
232-2、参数
232-3、功能
232-4、返回值
232-5、说明
232-6、用法
232-6-1、数据准备
232-6-2、代码示例
232-6-3、结果输出
233、pandas.Series.sort_index方法
233-1、语法
233-2、参数
233-3、功能
233-4、返回值
233-5、说明
233-6、用法
233-6-1、数据准备
233-6-2、代码示例
233-6-3、结果输出
234、pandas.Series.swaplevel方法
234-1、语法
234-2、参数
234-3、功能
234-4、返回值
234-5、说明
234-6、用法
234-6-1、数据准备
234-6-2、代码示例
234-6-3、结果输出
235、pandas.Series.unstack方法
235-1、语法
235-2、参数
235-3、功能
235-4、返回值
235-5、说明
235-6、用法
235-6-1、数据准备
235-6-2、代码示例
235-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 231、pandas.Series.reorder_levels方法 231-1、语法 # 231、pandas.Series.reorder_levels方法 pandas.Series.reorder_levels(order) Rearrange index levels using input order.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a6e36be66a1139e690fd4dfbb18fa7e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/91/">«</a>
	<span class="pagination__item pagination__item--current">92/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/93/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>