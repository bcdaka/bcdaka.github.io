<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43748eae948aee853a52b1d04896f6f/" rel="bookmark">
			Android WebView详解和调用JS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Override
public void onProgressChanged(WebView view, int newProgress) {
super.onProgressChanged(view, newProgress);
if (newProgress == 100) {
mProgressBar.setVisibility(View.GONE);
} else {
mProgressBar.setVisibility(View.VISIBLE);
mProgressBar.setProgress(newProgress);
}
}
});
（2）如果希望浏览的网页后退而不是退出浏览器，需要WebView覆盖URL加载，让它自动生成历史访问记录，那样就可以通过前进或后退访问已访问过的站点。
/**
在onKeyDown中设置webView在返回的时候
自动记录浏览记录
@param keyCode
@param event
@return
*/
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
if (keyCode == KeyEvent.KEYCODE_BACK){
if (mWebView.canGoBack()){
mWebView.goBack();
return true;
}else {
finish();
}
}
return super.onKeyDown(keyCode, event);
}
（3）创建一个自己的WebViewClient，通过setWebViewClient关联
//覆盖WebView默认使用第三方或系统默认浏览器打开网页的行为，使网页用WebView打开
mWebView.setWebViewClient(new WebViewClient() {
@Override
public boolean shouldOverrideUrlLoading(WebView view, String url) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d43748eae948aee853a52b1d04896f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7507cba82ba164d64810ee0ba166f6be/" rel="bookmark">
			vue elementUI form组件动态添加el-form-item并且动态添加rules必填项校验方法_el-form-item 必填项校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一下效果图（想在表单里动态的增删 form-item，然后添加rules，校验其必填项； ）:
html部分 &lt;div v-for="(item, index) in form.labels" :key="index" class="label"&gt; &lt;el-form-item label="名称:" :prop="'labels.' + index + '.name'" :rules="{ required: true, message: '请输入', trigger: 'blur' }" class="middleInput"&gt; &lt;el-input v-model.trim="item.name" maxlength="30" placeholder="请输入"&gt;&lt;/el-input&gt; &lt;i class="el-icon-circle-plus-outline icon" v-if="(index === (form.labels.length - 1))" @click.prevent="addKey(item)"&gt;&lt;/i&gt; &lt;i class="el-icon-remove-outline icon" v-if="(form.labels.length &gt; 1)" @click.prevent="removeKey(item, index)"&gt;&lt;/i&gt; &lt;/el-form-item&gt; &lt;el-form-item label="值:" :prop="'labels.' + index + '.value'" :rules="{ required: true, message: '请输入', trigger: 'blur' }" class="middleInput"&gt; &lt;el-input maxlength="100" show-word-limit type="textarea" :rows="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7507cba82ba164d64810ee0ba166f6be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7b0adfc8d813ff6643ba89034c1c38b/" rel="bookmark">
			Vue 3使用 Iconify 作为图标库与图标离线加载的方法、 Icones 开源在线图标浏览库的使用_iconify 图标库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与FontAwesome不同的是，Iconify配合Icones相当于是一个合集，Iconify提供了快捷引入图标的方式，而Icones是一个大的图标库，收集了大量MIT协议、Apache 2.0开源的图标文件。
Iconify 支持的框架很多，本文以 Vue 3 作为介绍。
官网地址： https://icones.js.org/
Iconify Design: All popular icon sets, one framework.
一、安装 npm install --save-dev @iconify/vue 如果使用yarn作为依赖管理，则使用
yarn add --dev @iconify/vue 二、在 Icones 查找所需的图标 选择一个准备使用的图标套装，找到需要的图标后，点击复制：
三、插入图标 import { Icon } from '@iconify/vue'; // template中插入 &lt;Icon icon="mdi-light:home" /&gt; 效果：
四、离线加载 默认Iconify是在线加载的，访问有可能不稳定，很多时候私有化部署不能加载外网数据，因此我们需要离线加载，所幸的是Iconify并不是在线加载图标，而是在线加载元数据，因此，我们可以改为本地自动引入。
安装完整的图标集合（300MB左右）
npm install --save @iconify/json 然后，安装Vite的图标自动引入插件
import Icons from 'unplugin-icons/vite' export default defineConfig({ plugins: [ Icons({}), ], }) 然后需要通过以下方式使用：
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数大数据工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年大数据全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上大数据开发知识点，真正体系化！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7b0adfc8d813ff6643ba89034c1c38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82de25a81e1ba038f59efecea5481eb8/" rel="bookmark">
			SpringBoot项目集成kafka及常规配置_springboot集成kafka配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Data @Configuration public class KafkaListenerConfiguration { /** * 启用线程数（提高并发） */ @Value("${iot.kafka.listener.concurrency:3}") private Integer concurrency; /** * 手动提交的方式，当enable-auto-commit: false时起作用 * manual:手动调用Acknowledgment.acknowledge()后立即提交 * record:当每一条记录被消费者监听器（ListenerConsumer）处理之后提交 * batch:当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交 * time: 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交 * count:当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交 * count_time:当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后, 手动调用Acknowledgment.acknowledge()后提交 */ @Value("${iot.kafka.listener.ack-mode:manual_immediate}") private String ackMode; /** * 消费超时时间 */ @Value("${iot.kafka.listener.poll-timeout:3000}") private Long pollTimeout; /** * 是否开启批量处理 */ @Value("${iot.kafka.listener.batch_listener:#{true}}") private Boolean batchListener; } 1.4 KafkaProducerConfiguration 生产者配置 @Data @Configuration public class KafkaProducerConfiguration { /** * 重试次数 默认值0 */ @Value("${iot.kafka.producer.retries:0}") private Integer retries; /** * acks = 0 如果设置为零，则生产者将不会等待来自服务器的任何确认，该记录将立即添加到套接字缓冲区并视为已发送。在这种情况下，无法保证服务器已收到记录，并且重试配置将不会生效（因为客户端通常不会知道任何故障），为每条记录返回的偏移量始终设置为 - 1。 * acks = 1 这意味着leader会将记录写入其本地日志，但无需等待所有副本服务器的完全确认即可做出回应，在这种情况下，如果leader在确认记录后立即失败，但在将数据复制到所有的副本服务器之前，则记录将会丢失。 * acks = all 这意味着leader将等待完整的同步副本集以确认记录，这保证了只要至少一个同步副本服务器仍然存活，记录就不会丢失，这是最强有力的保证，这相当于acks = -1 的设置。 */ @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82de25a81e1ba038f59efecea5481eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30aafe5260c1afb9b17a4f663e6eecee/" rel="bookmark">
			RocketMQ与Kafka架构深度对比_kafka与rocketmq多方面剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、系统设计与组件构成 1.1 RocketMQ 1.2 Kafka 二、数据流向与扩展性 2.1 RocketMQ 2.2 Kafka 三、容错性与一致性 3.1 RocketMQ 3.1 Kafka 四、总结与展望 一、系统设计与组件构成 1.1 RocketMQ RocketMQ的系统设计更偏向于队列模型，提供了丰富的消息队列语义，如顺序消息、事务消息和定时消息等。它主要由NameServer、Broker、Producer和Consumer组成。NameServer负责服务注册与发现，Broker负责存储消息，Producer和Consumer分别负责发送和消费消息。此外，RocketMQ还支持Filter Server组件，用于支持消息过滤功能。这种设计使得RocketMQ在处理复杂业务逻辑时更加灵活。 1.2 Kafka 相比之下，Kafka的系统设计更偏向于日志模型，强调数据的顺序性和持久性。它主要由Producer、Consumer、Broker和ZooKeeper（或KRaft）组成。Producer和Consumer分别负责发送和消费消息，Broker负责存储消息，ZooKeeper（或KRaft）负责协调管理。Kafka的Broker是无状态的，可以独立处理请求，并通过ZooKeeper（或KRaft）进行协调管理。这种设计使得Kafka在处理高吞吐量日志数据时更加高效。 二、数据流向与扩展性 2.1 RocketMQ 在RocketMQ中，数据从Producer发送到Broker，Consumer从Broker拉取数据进行消费。RocketMQ支持消息的Tag过滤和SQL过滤，可以在Broker端进行消息过滤。此外，RocketMQ还支持事务消息和顺序消息，可以确保数据的强一致性和有序性。在扩展性方面，RocketMQ支持Broker的横向扩展，通过增加Broker节点来提高系统的吞吐量和可用性。同时，RocketMQ还支持Topic和Queue的灵活配置，可以根据业务需求进行动态调整。
2.2 Kafka 在Kafka中，数据从Producer发送到Broker的特定Partition，Consumer从Broker的Partition拉取数据进行消费。Kafka支持按照Key进行消息分区，确保相同Key的消息发送到同一个Partition。在扩展性方面，Kafka的Broker是无状态的，可以方便地进行横向扩展，提高系统的吞吐量和可用性。同时，Kafka支持Partition的动态调整，可以通过增加Partition数量来提高系统的并行处理能力。 三、容错性与一致性 3.1 RocketMQ RocketMQ采用主从复制机制来提高容错性。当Master出现故障时，Slave可以自动升级为Master继续提供服务。同时支持Dledger多副本机制，进一步提高系统的容错性。在一致性方面，RocketMQ通过主从复制和顺序消息机制保证数据的一致性和有序性。此外，RocketMQ还支持消息的幂等性处理，避免重复消费导致的数据不一致问题。 3.1 Kafka Kafka则通过ISR机制保证数据的可靠性和一致性。当Leader出现故障时，Follower可以通过选举成为新的Leader继续提供服务。Kafka还支持多副本存储和Min.ISR配置，确保数据的可靠性和容错性。在一致性方面，Kafka通过ISR机制和分区顺序性保证数据的一致性和有序性。同时支持Exactly-Once语义，确保分布式环境下的消息幂等性。此外，Kafka还通过日志压缩功能减少存储空间占用并提高查询效率。 四、总结与展望 通过对RocketMQ与Kafka在架构设计、组件构成、数据流向、扩展性、容错性和一致性等方面的深入对比分析，我们可以发现这两款消息中间件各有千秋。RocketMQ更适合需要丰富队列语义和灵活消费模式的场景；而Kafka则更适合强调数据顺序性、持久性和高吞吐量的日志处理场景。在实际应用中，我们需要根据具体业务需求和系统特点进行选择和配置。
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数大数据工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年大数据全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上大数据开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新
如果你觉得这些内容对你有帮助，可以添加VX：vip204888 （备注大数据获取）
、源码讲义、实战项目、讲解视频，并且后续会持续更新**
如果你觉得这些内容对你有帮助，可以添加VX：vip204888 （备注大数据获取）
[外链图片转存中…(img-fUKvaciY-1712860067270)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0261e33a3a7b537f8ced9632ca5c9768/" rel="bookmark">
			RabbitMQ重复消费_rabbitmq重复消费问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言重复消费问题方法一：消息幂等性方法二：消息去重 前言 解决 RabbitMQ 重复消费问题是消息队列应用中非常重要的一部分。在实际应用中，可能会出现消费者因某种原因（例如网络问题、应用崩溃等）在处理消息时失败，然后重新开始处理相同的消息，导致消息的重复消费。为了解决这个问题，我们可以采用一些方法和策略来确保消息不会被重复消费。
重复消费问题 RabbitMQ 会出现重复消费问题的主要原因是分布式系统中的网络通信和消息传递可能会面临一系列不可避免的问题，这些问题可能导致消息在传递过程中丢失、重复传递或乱序传递。以下是一些常见的导致 RabbitMQ 重复消费问题的原因：
网络问题： 在分布式系统中，网络通信是不稳定的因素之一。如果生产者发送一条消息到 RabbitMQ 但尚未收到确认（acknowledgment），可能会导致 RabbitMQ 认为消息未被正确处理并重新发送。消费者故障： 消费者在处理消息时可能会发生故障，例如应用程序崩溃或因某种原因终止。如果 RabbitMQ 未收到消费者的确认消息，它可能会认为消息未被消费并重新发送。网络分区： 当分布式系统中的网络发生分区（网络隔离）时，可能会导致消息在不同部分之间重复传递。这是因为每个分区可能都会独立处理消息。消息重复传递策略： RabbitMQ 提供了不同的消息传递策略，例如“至少一次传递”和“最多一次传递”。这些策略可能会导致消息的重复传递，尤其在异常情况下。消费者超时设置不当： 如果消费者设置了较长的超时时间，在消费者未确认消息的情况下，RabbitMQ 可能会认为消息未被处理并重新发送。 为了解决 RabbitMQ 的重复消费问题，通常需要采取一些措施，包括：
消息幂等性： 消费者的处理逻辑应该具备幂等性，即多次处理相同的消息不会产生额外的影响。这可以确保即使消息被重复消费，也不会导致不一致状态。消息去重： 使用消息去重机制来检查已经处理过的消息，避免重复处理。消息确认机制： 使用消息确认机制，确保消息在被消费者成功处理后才被标记为已消费。这可以减少消息的重复传递。事务性消费： 在处理消息时使用事务性操作，以确保消息只有在完全处理完成后才会被确认。消息状态追踪： 使用消息状态追踪机制来记录消息的处理状态，以避免重复处理。 总之，RabbitMQ 的重复消费问题是分布式系统中常见的挑战之一，但可以通过合理的设计和实施来有效地解决。确保消费者的处理逻辑具备幂等性并采取适当的消息确认和去重策略，可以减少或避免重复消费问题的发生。
本文将介绍几种解决 RabbitMQ 重复消费问题的常见方法，并附带 Java 代码示例。
方法一：消息幂等性 消息幂等性是一种处理重复消息的有效方法。它要求消息的处理逻辑保持幂等性，即多次处理相同消息的效果与处理一次相同。这意味着如果消息已经成功处理过一次，再次处理相同消息时不会产生副作用。
以下是一个示例，展示如何在 Java 中实现消息的幂等性：
import com.rabbitmq.client.\*; public class MessageConsumer { private static final String QUEUE\_NAME = "my\_queue"; public static void main(String[] args) throws Exception { ConnectionFactory factory = new ConnectionFactory(); factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0261e33a3a7b537f8ced9632ca5c9768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45038edb3bc95e86afc88c29f83e07ad/" rel="bookmark">
			RabbitMQ 部署及配置详解(集群部署)_rabbitmq集群部署详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仲裁队列是 RabbitMQ 实现持久、 基于Raft共识算法的复制FIFO队列。 它从 RabbitMQ 3.8.0 开始可用。
仲裁队列和流取代了持久镜像队列，即原始队列 复制的队列类型，现已弃用并计划删除。
仲裁队列针对数据安全性为 重中之重。这在动机中有所介绍。 仲裁队列应被视为复制队列类型的默认选项。
与传统镜像队列相比，仲裁队列在行为上也存在重要差异和一些限制， 包括特定于工作负载的，例如，当使用者重复对同一消息重新排队时。另外仲裁队列支持死信交换 （DLX）。
仲裁队列和镜像队列差异
2、节点名称 RabbitMQ 节点由节点名称标识。节点名称由两部分组成， 前缀（通常是兔子）和主机名。例如，rabbit@node1.messaging.svc.local 是一个节点名称，前缀为 rabbit，主机名为 node1.messaging.svc.local。
群集中的节点名称必须是唯一的。如果给定主机上正在运行多个节点 （这通常在开发和 QA 环境中），他们必须使用 不同的前缀，例如rabbit1@hostname和rabbit2@hostname。
在群集中，节点使用节点名称相互标识和联系。这意味着 必须解析每个节点名称的主机名部分。CLI 工具还使用节点名称识别和寻址节点。
当节点启动时，它会检查是否已为其分配节点名称。这是完成的 通过RABBITMQ_NODENAME环境变量。 如果未显式配置任何值， 节点解析其主机名，并将 Rabbit 附加到它以计算其节点名称。
如果系统使用完全限定域名 （FQDN） 作为主机名，RabbitMQ 节点 并且必须将 CLI 工具配置为使用所谓的长节点名称。 对于服务器节点，这是通过将RABBITMQ_USE_LONGNAME环境变量设置为 true 来完成的。
对于 CLI 工具，必须设置 RABBITMQ_USE_LONGNAME 或 --longnames 选项 必须指定。
3、集群形成要求 主机名解析
RabbitMQ 节点使用节点名称（组合）相互寻址 前缀和域名，可以是短的还是完全限定的 （FQDN）。因此，每个集群成员都必须能够解析主机名 对于所有其他集群成员，其自己的主机名也是如此 作为可能使用 RabbitMQCTL 等命令行工具的计算机。节点将在节点引导时尽早执行主机名解析。 在基于容器的环境中，主机名很重要 在容器启动之前，解决方案已准备就绪。 对于 Kubernetes 用户来说，这意味着 CoreDNS 的 DNS 缓存间隔值在 5-10 秒范围内。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45038edb3bc95e86afc88c29f83e07ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583255541f2533784a4dd68904b2ac3a/" rel="bookmark">
			Prometheus监控Kafka（三种方法JMX Kafka_exporter KMINION监控Kafka）_kafka exporter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司需要监控kafka消息队列的消费情况，强调需查看当前Topic中的message的数量。 一句话说明解决：
像Kafka这样的Java进程可以先通过JMX Agent或者第三方Agent（kafka_exporter\KMINION等）获取监控数据，再通过Prometheus采集数据、通过Grafana模板展示数据即可。另外具体的message数量需要通过PromQL语句查询得到。 多说几句：
kafka应用的具体指标和JVM虚拟机的指标都可以通过JMX监控得到。Zabbix也可以监控kafka，也是通过JMX实现。Prometheus对自定义监控项更友好，相关的Grafana模板更多。建议同时使用JMX和kminion，同时使用两者的Grafana模板（具体性能损耗的评估稍后有时间我再详细说明，有时间折腾也可以只装一个）三种方式获取的都是kafka监控指标，最终都通过grafana集成显示。 2024.02.12补充注意：好几张截图里的第二个messages per sec值其实是all messages 的值，查看grafana模板promsql 可以确定。编辑配置可以修改，应该是模版作者的小疏漏。 监控效果截图 参考链接 【Grafana模板库：搜索Kafka】
【阿里云官方文档：如何部署和配置Kafka JMX Agent】
实际操作 方式一：使用JMX监控 操作要点
下载jmx程序包。修改kafka启动参数重启kafka访问JMX-Agent端口验证监控指标5.修改配置文件，并重启Prometheus访问Prometheus，验证target是否监控成功。配置Grafana：导入模板、配置数据源、查看监控数据。 1.下载jmx程序包 使用阿里云提供的jmx-agent包，比较稳定靠谱，就不故意选择最新版本了。
下载链接：【阿里云JMX-Agent下载】
下载后需传输到kafka所在服务器上，如：
[sysma@kafka-0001 jmx_agent]$ ls kafka-jmx_prometheus_javaagent-1.18.1.jar [sysma@kafka-0001 jmx_agent]$ pwd /ilw/jmx_agent [sysma@kafka-0001 jmx_agent]$ 2.修改kafka启动参数。 修改kafka启动脚本的配置参数，可参考阿里云【阿里云官方文档：如何部署和配置Kafka JMX Agent】
也可参考我的示例文件，对比阿里云文档截图，我的示例文件更为简单直观：
在EXTRA_ARGS=${EXTRA_ARGS-'-name kafkaServer -loggc '}这一行之后，新增JMX-agent内容-javaagent:/ilw/jmx_agent/kafka-jmx_prometheus_javaagent-1.18.1.jar=5506，目的是下次启动kafka进程的同时，运行一个jmx-agent并指定agent的端口。
完整示例文件如下：
[sysma@kafka-0001 bin]$ pwd /ilw/kafka_2.12-3.5.0/bin [sysma@kafka-0001 bin]$ cat kafka-server-start.sh #!/bin/bash # Licensed to the Apache Software Foundation (ASF) under one or more # contributor license agreements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583255541f2533784a4dd68904b2ac3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de43d0cbcc9c8c8c0bc0362ce43a2673/" rel="bookmark">
			Android 14 抓包、安装系统证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fiddler/Charles安卓14抓包问题解决，系统根证书安装 准备阶段Magisk 安装扩展将.cre格式证书转换为.pem格式证书提权特殊情况结语 准备阶段 一台已经 ROOT 的安卓手机手机安装 Masgisk APK MT管理器 APK(应用市场下载)电脑安装 OpenSSL，将C:\Program Files\OpenSSL-Win64\bin 配置为环境变量电脑 安装 android ADB Magisk 安装扩展 下载插件 Magisk-MoveCACerts.zip打开 Magisk -&gt; 扩展 -&gt; 从本地安装 -&gt; 选择Magisk-MoveCACerts.zip 即可安装启用插件 将.cre格式证书转换为.pem格式 如果已经导出 .PEM 文件则跳过
# 下面两个选择一个执行得到 .pem 文件即可 openssl x509 -in 你的证书名称.cer -inform DER -out 导出名称.pem -outform PEM openssl x509 -inform DER -in 你的证书名称.cer -outform PEM -out 导出名称.pem # 执行拿到文件名 openssl x509 -subject_hash_old -in 导出名称.pem # 运行上面的命令就会得到如下结果 269953fb 就是我们要的文件名 269953fb -----BEGIN CERTIFICATE----- MIIDsjCCApqgAwIBAgIQb/tq6VqiEIVHT5A/hQ0JIzANBgkqhkiG9w0BAQsFADBn MSswKQYDVQQLDCJDcmVhdGVkIGJ5IGh0dHA6Ly93d3cuZmlkZGxlcjIuY29tMRUw EwYDVQQKDAxET19OT1RfVFJVU1QxITAfBgNVBAMMGERPX05PVF9UUlVTVF9GaWRk bGVyUm9vdDAeFw0yMDExMDUyMjUwNThaFw0yNDAyMDQyMjUwNThaMGcxKzApBgNV BAsMIkNyZWF0ZWQgYnkgaHR0cDovL3d3dy5maWRkbGVyMi5jb20xFTATBgNVBAoM DERPX05PVF9UUlVTVDEhMB8GA1UEAwwYRE9fTk9UX1RSVVNUX0ZpZGRsZXJSb290 MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr56FARMvcx5avQIUSm/5 FjSfrG+5q7rSrwXXh9C7c/2Rcbl5qzybtaXLYqOml7w2hGQB4zoT2bB3hxXa/kgM 2VJOEKNRxpIp5wpbcwetC+7keqPnnAAdkK8zX7fG+t94GR9JQHLYQZ6rolUgpmaC zqHY3OCBbmykMXJEoM+RRhNiYb4wFH6yV5XxOYrigne4wAvfrMdHpdzPpOQYcRLV AL2DvDC9XAmIMLdJGp5KebU7cX6S3r1bBj03OZkSafvyLOTgS12ABCN1fzr5azsq sU4aZiHQB3JnB66J2y4TkcxuSffaOkMeNOd060jYnaSYc1cmxH7FkC3+nE/bEdb/ tQIDAQABo1owWDATBgNVHSUEDDAKBggrBgEFBQcDATASBgNVHRMBAf8ECDAGAQH/ AgEAMB0GA1UdDgQWBBQAHc9JtuJEm6bzwNIvOTR9vVcHkzAOBgNVHQ8BAf8EBAMC AQYwDQYJKoZIhvcNAQELBQADggEBAE232n06TExQDR7fsuZPrwZFL5Eqk6BhUuD6 3al5gTbcGO1opCZMz7zKqaAH1iqn0Ip3clYen6GsVVa8gEbw0u/En7A+5CeMpL7y dg4tyNHv3iiubzGU1980GcG2kziBV6roNGISkOXtMbMM0IJoshzG9f4YKvWSZnmw PLnYjWpaiBBtehZ2g4OAjCQBAgqSp9IIQsm5YbYNgtEn1aBWkrVrgZ54HesZKQM5 np7Fgzcms4320f+SIzY+XAJ4oUYI4vHvRdRszvTdZQjmTInTcwiyBLvPpl0kawg8 MUKqgAsxI0rWIH0mc+PkLmOENpfkglJO2Ko/BEWBpeIJxBg+Sv8= -----END CERTIFICATE----- 通过上面的命令会拿到一个ID 269953fb
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de43d0cbcc9c8c8c0bc0362ce43a2673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3c6de0d50f9f6666de83d887c514e2/" rel="bookmark">
			JavaScript中GET和POST对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前后端交互的过程中，使用频率最高的莫过于 GET 和 POST 这两个方法，并且这也是面试中被问到频率很高的知识点。
GET和POST方法只是 HTTP 协议为了不同分工而规定的两种请求方式。
一、什么是HTTP？ HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。
HTTP 的工作方式是客户端与服务器之间的请求-应答协议。
二、GET和POST的对比 在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。
GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据。 GET 提交参数一般显示在 URL 上，POST 通过表单提交不会显示在 URL 上，POST 更具隐蔽性
1、相同点 HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET 和 POST 都是 TCP 链接。所以说，它们的本质是相同的。
GET 和 POST 之所以产生，要通过HTTP的规则和浏览器/服务器的限制进行区分，使它们在应用过程中体现出不同。 请求过程是：
客户端 IP 发出请求。发出的请求数据包会通过 TCP ，经网络传输给远程服务端 IP。服务端 IP 收到请求包之后，解析并处理请求包最后服务端会通过 TCP 将处理结果返回给客户端。用户便可以查看到想要的响应数据。 2、区别 （1）安全性不同 GET的所有参数全部包装在URL中，明文显示，且服务器的访问日志会记录，非常不安全POST的URL中只有资源路径，不包含参数，参数封装在二进制的数据体中，服务器也不会记录参数，相对安全。所有涉及用户隐私的数据都要用POST传输 （2）参数长度限制不同 GET 和 POST 传递参数的长度不同：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3c6de0d50f9f6666de83d887c514e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e04edb80dbe2f7e7a996b8adc9af39/" rel="bookmark">
			Java生成exe可执行文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、生产jar文件
在将写好的Java程序转换为EXE程序前，需要先将Java程序导出为jar包，然后才能通过EXE4J生成想要的EXE程序。在这里，笔者使用的工具为eclipse，具体步骤如下：
1.打开一个含有main方法且已调试可运行的Java工程，右键点击后选择export，再选择Java选项下的JAR file选项。
2.选择要导出的Java工程，并填写jar包的导出路径。点击finish即可在对应路径下看到生成的jar包。
三、将jar文件转化为EXE文件
1. 打开exe4j Wizard.exe，在首页先进行License注册，否则生成的exe文件在运行时会提示：“this executable was create with an evaluation exe4j”。注册时可以使用如下的注册号：
A-XVK258563F-1p4lv7mg7sav
A-XVK209982F-1y0i3h4ywx2h1
A-XVK267351F-dpurrhnyarva
A-XVK204432F-1kkoilo1jy2h3r
A-XVK246130F-1l7msieqiwqnq
A-XVK249554F-pllh351kcke50
A-XVK238729F-25yn13iea25i
A-XVK222711F-134h5ta8yxbm0
A-XVK275016F-15wjjcbn4tpj
A-XVK275016F-15wjjcbn4tpj
2. 点击next，选择”JAR in EXE” mode。
3.点击next，填写生成的应用名和输出目录。
4.点击next，根据自己的应用类别进行选择，并填入可执行文件的名称。其余选项可根据自己的需要进行设置。
生成的EXE默认是在32位的JDK环境先运行。如果是目标计算机的运行环境为64位，则还应勾选如下选项：
5. 点击next，添加需要生成EXE的jar包并设置好它的mainclass。
6.根据自己应用对Java API的使用情况，设定运行时jre的最小版本和最大版本限定。
7. 接着设定生成EXE文件时所需要依赖的JDK。如果已将Java正确配置到系统环境变量中，该步骤一般可跳过。
8. 接着一路next，看到如下界面时说明已经将jar包转换为对应的exe文件。这时便可以打开对应的exe文件看是否正常运行。
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Java开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Java开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新
如果你觉得这些内容对你有帮助，可以添加V获取：vip1024b （备注Java）
最后 总而言之，面试官问来问去，问的那些Redis知识点也就这么多吧，复习的不够到位，知识点掌握不够熟练，所以面试才会卡壳。将这些Redis面试知识解析以及我整理的一些学习笔记分享出来给大家参考学习
还有更多学习笔记面试资料也分享如下：
一个人可以走的很快，但一群人才能走的更远。不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎扫码加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
转存中…(img-rK1RJrTn-1712853679147)]
一个人可以走的很快，但一群人才能走的更远。不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎扫码加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
[外链图片转存中…(img-rWRmQOCz-1712853679147)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/567c6f9d746f7c274bed6a123659e6fc/" rel="bookmark">
			MySQL一共有多少个版本？每个版本的特点是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL是一个开源的关系型数据库管理系统，自诞生以来，经历了许多版本的迭代和发展。在回答这个问题之前，需要说明一下，MySQL的版本非常多，而且每个版本都有不同的特点和变化，因此无法在这个问题的回答中详细列举每个版本的特点和变化。因此，我将提供MySQL的一些重要版本的介绍和主要特点，希望对你有所帮助。
以下是MySQL的一些重要版本和主要特点：
MySQL 3.23：这是MySQL的第一个稳定版本，发布于2001年。该版本引入了许多新功能，包括存储过程、触发器、子查询等。MySQL 4.0：该版本发布于2003年，引入了多种新功能，包括视图、游标、外键等。MySQL 5.0：该版本发布于2005年，引入了许多新功能，包括存储过程、触发器、视图的更新等。此外，该版本还引入了InnoDB存储引擎，这是一个支持事务处理和行级锁定的高性能存储引擎。MySQL 5.1：该版本发布于2008年，引入了多种新功能，包括分区表、事件调度器等。MySQL 5.5：该版本发布于2010年，引入了多种新功能，包括半同步复制、内存引擎等。此外，该版本还对性能进行了优化，使其比之前的版本更快。MySQL 5.6：该版本发布于2013年，引入了多种新功能，包括GTID复制、InnoDB引擎的更改、优化查询执行计划等。此外，该版本还对性能进行了优化，使其比之前的版本更快。MySQL 5.7：该版本发布于2015年，引入了多种新功能，包括JSON数据类型、多源复制、更好的性能优化等。此外，该版本还引入了一些新的安全功能，如密码过期、密码复杂性等。MySQL 8.0：该版本发布于2018年，引入了多种新功能，包括窗口函数、公共表表达式、函数默认值、全文搜索等。此外，该版本还引入了更好的安全功能，如加密连接、安全用户管理等。 每个版本之间的主要区别和特点取决于许多因素，包括功能的改变、性能的提高、bug修复、安全性改进等。在底层原理方面，MySQL使用了许多不同的技术和算法，包括B+树索引、哈希索引、排序算法、查询优化器、事务处理器等。在数据存储方面，MySQL使用了多种存储引擎，包括InnoDB、MyISAM、Memory、CSV等，每种存储引擎有不同的特点和用途。
InnoDB是MySQL的默认存储引擎，支持事务处理、行级锁定等功能，适用于高并发、高可靠性的应用场景。MyISAM是另一种常用的存储引擎，它不支持事务处理和行级锁定，但速度快、简单易用，适用于低并发、读写分离的应用场景。Memory存储引擎将数据存储在内存中，速度非常快，但容易丢失数据，适用于缓存等场景。CSV存储引擎将数据存储在CSV文件中，适用于导入和导出数据等场景。
总的来说，MySQL是一个功能强大、可靠性高、性能优秀的关系型数据库管理系统，其不断演进的版本提供了更好的功能和性能，并为开发者和企业提供了更好的数据管理和存储解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f4e0efb2ae0d0b18ae17a209a805a2/" rel="bookmark">
			mysql 如何查看用户权限_mysql查看用户权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是查看MySQL用户权限最直接的方法。这个命令显示了指定用户的所有权限。
语法：
SHOW GRANTS FOR 'username'@'hostname'; 这里的username是用户名，hostname是用户连接的主机名。
例如：
SHOW GRANTS FOR 'root'@'localhost'; 这将显示root用户在localhost主机上的所有权限。
2. 查询 mysql 数据库中的表 MySQL的权限信息存储在mysql数据库的几个表中，如user, db, tables_priv等。
查看用户级别权限： SELECT \* FROM mysql.user WHERE User='username' AND Host='hostname'; 查看数据库级别权限： SELECT \* FROM mysql.db WHERE User='username' AND Host='hostname'; 查看表级别权限： SELECT \* FROM mysql.tables_priv WHERE User='username' AND Host='hostname'; 3. 使用图形界面工具 自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数Linux运维工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Linux运维全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Linux运维知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新
如果你觉得这些内容对你有帮助，可以添加VX：vip1024b （备注Linux运维获取）
为了做好运维面试路上的助攻手，特整理了上百道 【运维技术栈面试题集锦】 ，让你面试不慌心不跳，高薪offer怀里抱！
这次整理的面试题，小到shell、MySQL，大到K8s等云原生技术栈，不仅适合运维新人入行面试需要，还适用于想提升进阶跳槽加薪的运维朋友。
本份面试集锦涵盖了
174 道运维工程师面试题128道k8s面试题108道shell脚本面试题200道Linux面试题51道docker面试题35道Jenkis面试题78道MongoDB面试题17道ansible面试题60道dubbo面试题53道kafka面试18道mysql面试题40道nginx面试题77道redis面试题28道zookeeper 总计 1000+ 道面试题， 内容 又全含金量又高
174道运维工程师面试题 1、什么是运维?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f4e0efb2ae0d0b18ae17a209a805a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fc9b5e29f7ba93dfb2a645234059c8/" rel="bookmark">
			iPhone手机使用：微信提示“运行内存不足导致该小程序无法使用“解决方法_苹果手机微信内存不足
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过iPhone XR打开微信小程序的时候，微信突然提示“运行内存不足导致该小程序无法使用”，然后点击“确定”按钮之后，就关闭了，而且查看手机内存128G的还剩下70G没有使用，后来回想一下，一直没有清理微信的缓存，造成微信总的占用空间达到7G左右，最后直接清理了微信缓存，清理了3G左右的缓存，删除了一下不需要的聊天记录，结果就可以正常打开微信小程序。最后总结，不要懒，隔一段时间就要清理一下微信缓存，养成正确的用机习惯，这样才不会遇到不可抗拒的问题。。。
然后再分享一下清理iPhone手机内存的步骤方法，仅供参考，不喜勿喷。具体如下所示：
1、打开iPhone手机，进入手机首页，找到”设置“选项；
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Java开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Java开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新
如果你觉得这些内容对你有帮助，可以添加V获取：vip1024b （备注Java）
最后 面试题文档来啦，内容很多，485页！
由于笔记的内容太多，没办法全部展示出来，下面只截取部分内容展示。
1111道Java工程师必问面试题 MyBatis 27题 + ZooKeeper 25题 + Dubbo 30题：
Elasticsearch 24 题 +Memcached + Redis 40题：
Spring 26 题+ 微服务 27题+ Linux 45题：
Java面试题合集：
一个人可以走的很快，但一群人才能走的更远。不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎扫码加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
、大厂内推、面试辅导），让我们一起学习成长！**
[外链图片转存中…(img-qHVm7cSr-1712848199591)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafc148f5df248a68dedad41cfab2acd/" rel="bookmark">
			在Mac上安装Spark apache-spark-3.5.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装spark的步骤较为简单，前提是要安装好Hadoop哦。
这里我使用brew来安装，如果你安装了homebrew直接在终端里输入brew install apache-spark然后等着就可以了（如果没有安装过brew的参考其他博主的内容去安装哦）
brew install apache-spark ==&gt; Auto-updating Homebrew... Adjust how often this is run with HOMEBREW_AUTO_UPDATE_SECS or disable with HOMEBREW_NO_AUTO_UPDATE. Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`). ==&gt; Auto-updated Homebrew! Updated 2 taps (homebrew/core and homebrew/cask). ==&gt; New Formulae ffmpeg@6 ==&gt; New Casks boltai You have 5 outdated formulae installed. ==&gt; Fetching dependencies for apache-spark: libx11 and openjdk@17 ==&gt; Fetching libx11 ==&gt; Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/libx11-1.8.9.arm64_ ######################################################################### 100.0% ==&gt; Fetching openjdk@17 ==&gt; Downloading https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dafc148f5df248a68dedad41cfab2acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223806e7297f5ac0511a4114bea19142/" rel="bookmark">
			文生图——python调用stable diffusionAPI生成有趣的图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将介绍如何使用Python调用Stable Diffusion API进行图像生成，实现文生图的功能。通过详细的步骤说明和示例代码，读者将能够轻松掌握这一技术，并运用它生成独特而富有创意的图像作品。无论你是编程爱好者还是设计师，都能从中获得启发和乐趣。
stable diffusion本地的部署方法可参考文章：文生图——stable diffusion生成有趣的动漫图像
part1：文生图概念及API简介 在数字艺术和创意设计的交汇点上，文生图（Text-to-Image）技术正以其独特的魅力吸引着无数创作者。这项技术允许用户通过输入文字描述，生成与之相对应的图像，从而打破了传统图像创作的界限，为艺术家和设计师们提供了全新的创作手段。
文生图技术的核心在于深度学习和自然语言处理。通过训练大量的图像和文字数据，模型能够理解文字与图像之间的关联，进而根据文字描述生成相应的图像。这种技术的出现，不仅降低了图像创作的门槛，还极大地丰富了图像创作的可能性和多样性。
在众多文生图技术中，Stable Diffusion以其出色的图像生成质量和稳定的性能脱颖而出。Stable Diffusion是一个基于扩散模型的文本到图像生成系统，它能够根据用户提供的文本提示，生成高质量、高分辨率的图像。而Stable Diffusion API则是这一强大功能的桥梁，它允许开发者通过编程方式调用Stable Diffusion模型，实现自定义的图像生成任务。
Stable Diffusion API的设计简洁而高效，用户只需通过API接口发送包含文本描述的请求，即可获得与之对应的图像输出。这种即插即用的方式，不仅方便了开发者的集成和应用，还大大降低了技术门槛，使得更多创作者能够轻松体验到文生图的魅力。
要获得stable Diffusion API 首先，我们进入stable diffusion官网：Stable Diffusion 3 — Stability AI
进入Stability AI Developer Platform ，如左图，点击Platform API即可。进入网页后，我们首先登录自己的SD账号，点击账号，即可看到下方画面：
使用个人的API Keys，即可调用API进行创作了。在Billing界面，可以看到自己的API调用余额，调用不同的模型消耗不同
使用不同模型消耗的Credits可以通过Stability AI - Developer Platform查看。
part2：python调用stable diffusionAPI进行绘图 我们可以通过以下代码实现文生图的API调用：
import base64 import os import requests engine_id = "stable-diffusion-v1-6" api_host = os.getenv('API_HOST', 'https://api.stability.ai') api_key = "skxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxWdIc" if api_key is None: raise Exception("Missing Stability API key.") response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/223806e7297f5ac0511a4114bea19142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea3cc65e7e106021ba13c30a2525735/" rel="bookmark">
			关于keil软件中手动添加.c和.h文件，.h文件不显示的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Keil中创建的头文件（.h 文件）通常应该显示在与其相关联的源文件（.c 文件）下面。如果头文件没有显示在对应的源文件下面，可能是由于以下几个原因之一：
1.未添加到项目中： 确保头文件已经添加到了你的项目中。在Keil中，你可以在项目资源管理器中看到项目的文件结构。如果头文件没有出现在其中，你需要将其添加到项目中。
2.未正确链接到源文件： 确保头文件在源文件中正确引用。在源文件中使用 #include 指令来包含头文件，例如：#include "your_header_file.h"。如果头文件路径不正确或者文件名拼写错误，头文件可能不会显示在源文件下面。
3.是否点击勾选了Show include File Dependencies
在尝试完上面几种方法之后，用方法1手动加入解决了问题，具体操作如下
1.再需要添加的文件夹单击右键
2.选择.h文件的文件夹
3.类型选择所有类型
4.手动加入你需要添加的头文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af9873086d78fcf6b7d2709509e8516/" rel="bookmark">
			AIGC时代 可演进的私有云将蔚然成风
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC时代，IT基础设施如何兼顾原有资源和能力又能拥抱新技术应用，企业如何从资源上云到架构用云、从粗犷使用到精细治理？新旧相融难题已经成为了业界讨论的焦点。“以可演进的IT云敏捷支撑行业数字化转型”，浪潮数据云计算方案总监刘健一抛出此观点，便立刻引发了与会者的强烈共鸣。
企业上云用云步入全新发展周期，其实各行各业在上云和云化方面都面临着相同的考验——如何继承，又如何演进？
可演进是云的DNA
在IDC提出“云已经进入‘深水区’”的论断之下，其实还有很多企业的数据中心依然存在着大量没有云化的基础设施。在企业中，稳态业务与敏态业务将长期共存，从虚拟化到云化再到云原生，既要兼顾原有的架构、应用和各项能力，更重要的是面向人工智能的未来，继续一步一个脚印，在私有云的建设上步步为营。
对于很多企业的IT人员来说，最怕听到的一个词可能就是“升级”。由于历史的原因，硬件平台的不兼容、软件不同版本之间的断代，造成了很多升级时的困惑甚至是障碍。铲车式的升级，还是渐进式的升级？如果你是企业IT的负责人，将会做出怎样的选择？
这时，相信大家对于刘健提出的“可演进”一词都会感同身受。所谓可演进，即回归IT和私有云的本质来考虑IT基础设施的扩展与升级，既要无缝继承企业过去的IT资产和运维能力，又可以提供面向未来的架构与服务能力，其核心是实现平滑演进。
对于可演进，人们并不陌生。面对AIGC时代的诸多新挑战，重申可演进重要性的现实意义在于：一方面，从虚拟化到轻量级云平台、大规模私有云平台，再到当前炙手可热的AIGC大模型基础设施平台，这本身就是一个自然、平滑的技术演进过程，同时也是客户真实的业务需求，而未来面对多元异构算力、多技术栈等更多挑战时，可演进仍然是最值得信赖的路径；另一方面，由于上云周期漫长且实施复杂，从企业实操的角度来看，边成长边投资，对于设备和资产的利旧、现有技术能力的复用、专业技术人员欠缺等问题的解决也是十分有效的，可继承的能力不可或缺。
“大约从两年前开始，我们已经在各种场合下宣讲‘可演进的金融云’‘可演进的行业云’等概念。”刘健表示，“云作为一种得到广泛认同的基础设施，和建住房一样，不能在建成后又推倒重来。从信息化到数字化再到智能化，技术浪潮一波又一波，伴随着技术的快速创新与发展，基础设施必须具备可演进的能力。可演进就是云的DNA之一。”
今年政府工作报告中提出“人工智能+”行动与打造新质生产力，作为关键的支撑点，数字化、网络化与智能化是始终不变的。但从另一个角度来看，从数字化转型到智能化升级，再到布局新质生产力，这又是一脉相承、逐步向前演进的。可演进的战略、可演进的业务，需要可演进的架构和平台来支撑和保障。这就是可演进的私有云的理论基础。
私有云可演进的“门道”
可演进的私有云，为什么企业需要的是“私有云”？浪潮数据云计算产品总监庞慷宇讲了一段他的亲身经历：“我们曾经针对香港当地的客户进行过深度调研，发现企业IT经过二三十年的发展，其运维体系已十分稳定，计算、存储、网络乃至云的运维人员都各司其职，‘空降’一套大型公有云的私有化部署，用户接受起来比较困难。”
无独有偶，国内某轨道交通公司也曾经采用了公有云的私有化部署方式，但是“强加”的PaaS服务干扰了其业务，导致原来负载均衡的那些设备无法使用。而且，该轨道交通公司的原有运维人员，没有能力实施公有云式的运维，造成了“水土不服”，对人力、物力和财力都是一种浪费。
而浪潮云海14年一路走来，服务过大大小小数千家中国IT基础设施私有云化的用户。从虚拟化到私有云，一脉相承的操作习惯、运维方式，让企业的运维人员得心应手；从架构解耦到“一云多芯”，再到智算融合，下一代私有云数据中心的建设思路和模式更加清晰，完全有能力支撑企业的数智化转型升级。
“非技术主导型的企业，需要的是一套私有云架构。”庞慷宇表示，“如果将客户分成以运维为主和以开发为主，面向这两种典型的场景，需要有两套不同的私有云架构来承载。浪潮云海致力于打造面向运维场景的私有云平台。”
为满足可演进的私有云部署需求，浪潮云海努力做好三件事：分层解耦、一云多芯、开放标准。
所谓分层解耦，本质上就是要求基础架构中的每一层都可以独立演进、独立迭代。高效的软硬协同，以及广泛的软硬件解耦，是浪潮云海一直坚持的理念。分层解耦对于用户来说意义重大，它意味着用户可以将主动权掌握在自己手里，而不会被某一个平台所绑定。比如硬件可以采用任意厂家，浪潮云海软件提供全面兼容支持。这是一种能力的体现。
所谓一云多芯，核心就是要满足对异构算力的需求，确保业务可以在不同架构的处理器之间实现低成本的自由切换。刘健解释说：“自由切换是一个业务目标，它需要借助整个产业生态来实现。其中的一项关键任务就是实现算力的标准化。客户购买的是算力，而不是某一个CPU，这就要依靠算力标准化的评价体系和相关标准。”
所谓开放标准，就是建立健全行业标准，实现标准引领，从而带动整个行业的发展。
可演进的私有云，并不是浪潮云海的一家之言，而是整个业界越来越明确的共识，其落地的声势也越来越浩大。虽然“分层解耦、一云多芯、开放标准”是所有致力于推动私有云可演进的厂商共同努力的目标，但是在细节能力上的强弱、技术厚度与实现深度上却千差万别。刘健举例说：“虽然所有的云厂商都说能支持一云多芯，但是支持的能力、意愿是完全不一样的。为了真正实现一云多芯，我们与业内权威机构一起制定标准、进行评测。分层解耦的情况也类似。我们严格遵循不同行业对分层解耦的测试标准，浪潮云海高分的表现说明了一切。生态与标准是我们业务的重点，也是强项。”
继承中创新
InCloud OS V8开启新篇章
浪潮云海“可演进的私有云”参考架构主要包括四层——存储层、计算层、服务层、应用层。最新发布的浪潮云海InCloud OS V8，其增强的产品能力与四层可参考架构一一对应，能够更好地满足可演进的需求。
具体来看，在存储层，要实现多协议融合，不仅广泛兼容iSCSI、iSER、NVME over RoCE、FC、FC-NVMe等主流存储协议，而且支持同品牌或不同品牌、集中式存储或分布式存储间的跨站点容灾。InCloud OS V8可以有效支持不同的文件系统、存储协议，以及私有协议、容灾、备份、安全等，屏蔽底层存储的差异化。
在计算层，要更好地支持一云多芯，包括同时支持多类型的计算资源，不同的应用匹配不同的计算资源，建立跨算力共享的存储池和网络池，减少网络转发路径，降低建设成本与维护成本。InCloud OS V8具备了一云多芯管理、等价算力调度、AI智算能力、算力标准化、资源可扩展性等诸多能力。
在服务层，要实现分层共建。比如，PaaS分层的通用能力要下沉，以容器技术为核心构建敏捷的云原生iPaaS底座，满足服务标准化和多样性的需求；个性化能力要上移，强行业属性的应用交给专业公司，双方共建，更好地实现一云多库、一云多服。InCloud OS V8的优势体现在：在底层资源上实现了便捷供给；在云平台上基于标准模板发布PaaS服务，快速嵌入云平台，实现能力工具化；基于上层管理平台，对日志、监控、运维、用户进行统一管理。
在应用层，要打造开放的生态技术框架与商业理念，从规划到方案、集成、交付、售后，全面联合各类生态伙伴，推动行业数字化转型。InCloud OS V8将为第三方伙伴服务提供强有力的支撑。
InCloud OS V8是浪潮云海在可演进的私有云旅程中一个重要的里程碑，相比之前的版本，从设计理念、架构到功能都有革命性的改变。按照庞慷宇的话说，浪潮云海不仅要将多年来助力头部行业私有云建设的经验复制到更多其他行业和领域，而且还要走出国门，服务企业“出海”。从这个角度说，InCloud OS V8重任在肩。
与之前的V5、V6架构相比，InCloud OS V8的基础算力单元更加原子化。原来，InCloud OS平台基于OpenStack、Kubernetes实现了高度整合，而现在则将OpenStack组件进行拆分，不需要一次性部署所有的OpenStack组件，旨在去繁就简、去芜存菁，同时提升了自研组件的比例，并且加固了OpenStack底层、重构了网络。庞慷宇打比方说：“原来，我们的产品由很多小水泡组成，现在从架构上将很多小水泡融合成大水泡，并且统一部署在最核心的节点上，同时在边缘又保留了很多小水泡，很好地继承了OpenStack整体的架构能力。”
以InCloud OS V8为底座，浪潮云海可演进化的私有云将主要面向分布式云、容灾备份、安全云、云替换、智算中心、云原生等典型场景，助力企业下一代私有云数据中心建设。
迈向数智融合
对于那些注重运维，并且持续进行研发投入的虚拟化和私有云客户来说，私有云建设是渐进式的，可演进的私有云是一条可靠，又能实现成本节约的上云路线。
驾驭可演进的私有云，只要做好“可继承与可演进”。概括来说，可继承，即私有云建设要更好地继承过去的IT资产、运维能力，特别是过往的能力体系，包括知识经验、人员组织和流程体系等；可演进，即面向日趋增强的技术不确定性，构建具备持续进化能力的私有云，实现架构、服务和能力的平滑演进，小规模扩展到大规模，单中心扩大到多中心统一管理，单一CPU架构扩展到多CPU架构，以人工操作为主演进到自动化、智能化。可演进的私有云提供了另一条兼顾可靠性和低成本的上云之路——应用IT技术构建具有容灾、备份、高性能的云基础设施，减小上云过程中业务转型的侵入性。
未来，私有云数据中心还要支撑数智融合。可演进的私有云作为基石，能够更好地实现平台云化、效率提升、成本节省和数智业务创新。
往/期/回/顾
从科技赋能到价值引领，东莞证券可进化的信创云建设启示录“智算”雄起 | 智算操作系统要“顶天立地”
艾玛，浪潮云海OS的“加法”算得不错哟
计算力就是生产力 浅析浪潮智算中心的多维价值
三年登顶，浪潮新一代超融合开始冲刺
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95f9b8d66414f2d8e6f552f8c6173e6/" rel="bookmark">
			AIGC革新浪潮：大语言模型如何优化企业运营
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今快速发展的商业环境中，企业对于有效管理知识资产的需求日益增长。知识管理作为企业核心竞争力的关键组成部分，对于提高决策质量、增强创新能力和优化运营流程起着至关重要的作用。随着数字化转型的推进，企业对知识管理系统提出了新的要求，期望其能够更加智能化、高效化。在这一背景下，大语言模型作为一种前沿的人工智能技术，展现出在企业知识管理领域的巨大潜力。
大语言模型技术概览 大语言模型是一种基于深度学习的自然语言处理技术，它通过对大量文本数据的学习，能够理解和生成自然语言。这种模型的核心在于其强大的语义理解和生成能力，使其能够在多种应用场景中发挥作用。随着技术的不断进步，大语言模型在企业内部部署的可行性得到了显著提高，为知识管理带来了新的解决方案。
企业知识管理的挑战与需求 企业在知识管理过程中常常面临知识孤岛、信息更新维护困难以及员工获取知识效率低下等问题。这些问题不仅影响了知识的传播和应用，也限制了企业的创新和发展。因此，企业迫切需要一种能够整合分散的知识资源、实时更新知识内容并提供高效检索和学习的系统。
大语言模型在企业内部的应用场景 1. 智能文档管理
自动文档分类与标签生成：大语言模型可以自动识别文档内容的主题和关键信息，为文档生成准确的分类和标签，从而简化文档管理流程。
知识内容的智能检索与推荐：通过理解员工的查询意图和历史行为，大语言模型能够提供更加精准的搜索结果和个性化的知识推荐。
2. 企业内部培训与知识传递
定制化培训材料的自动生成：大语言模型能够根据员工的角色和需求，自动生成定制化的培训材料，提高培训内容的相关性和有效性。
模拟对话与虚拟助手在培训中的应用：通过模拟真实工作场景中的对话，大语言模型可以帮助员工在虚拟环境中练习和提高专业技能。
3. 项目管理与协作
项目文档的自动摘要与信息提取：大语言模型可以从项目文档中提取关键信息，生成摘要，帮助团队成员快速把握项目的核心内容。
协作平台中的智能问答系统：集成在协作平台中的大语言模型可以即时解答团队成员的疑问，提高团队的协作效率。
4. 客户支持与服务
客户服务中的智能响应系统：大语言模型能够理解客户的问题并提供快速准确的响应，提升客户服务的质量。
客户反馈的分析与知识提取：通过对客户反馈的分析，大语言模型可以帮助企业提取有价值的知识，用于产品和服务的改进。
实施策略与挑战应对 在实施大语言模型的过程中，企业需要考虑技术部署与集成、人员培训与变革管理以及性能评估与持续优化等多方面的挑战。
1. 技术部署与集成
&amp;nbsp;选择合适的大语言模型平台：企业应根据自身需求和资源情况，选择适合的大语言模型平台，并考虑与现有系统的兼容性。
与现有系统的集成策略：制定详细的集成计划，确保大语言模型能够无缝集成到企业的知识管理系统中。
2. 人员培训与变革管理
员工对新系统的适应与培训：通过培训和支持，帮助员工熟悉新系统的操作，确保技术的顺利应用。
组织文化与变革管理策略：建立积极的组织文化，鼓励员工接受和利用新技术，以促进变革的顺利进行。
3. 性能评估与持续优化
设定评估指标与监控系统：通过设定关键绩效指标（KPI）和建立监控系统，评估大语言模型的性能和效果。
收集反馈与系统迭代：积极收集用户反馈，根据反馈进行系统的迭代和优化，不断提升大语言模型在知识管理中的应用效果。
通过上述分析，我们可以看到大语言模型在企业知识管理系统中具有广泛的应用前景。通过合理规划和有效实施，企业可以充分利用这一技术，提升知识管理的效率和质量，从而在激烈的市场竞争中占据优势。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d922e6c138094e4d8a4d8ec4e3dff031/" rel="bookmark">
			【数据结构】哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 哈希概念2. 哈希冲突3. 哈希函数4. 哈希冲突解决4.1 闭散列4.2 开散列 unordered 系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。
1. 哈希概念 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为 O(N)，平衡树中为树的高度，即 O( l o g 2 N log_2 N log2​N)，搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。
如果构造一种存储结构，通过某种函数（hashFunc）使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
当向该结构中：
插入元素
根据待插入元素的关键码，以此函数计算出该元素的存储位置，并按此位置进行存放；
搜索元素
对元素的关键码进行同样的计算，把求得的函数值当作元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。
该方式即为哈希（散列）方法，哈希方法中使用的转换函数称为哈希（散列）函数，构造出来的结构称为哈希表（Hash Table）（或者散列表）。
例如：数据集合 { 1, 7, 6, 4, 5, 9 }；
哈希函数设置为：hash(key) = key % capacity; capacity 为存储元素底层空间总的大小。
用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快。
问题：按照上述哈希方式，向集合中插入元素 44，会出现什么问题？
2. 哈希冲突 对于两个数据元素的关键字 k i k_i ki​ 和 k j k_j kj​（i != j），有 k i k_i ki​ !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d922e6c138094e4d8a4d8ec4e3dff031/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/425/">«</a>
	<span class="pagination__item pagination__item--current">426/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/427/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>