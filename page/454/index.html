<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/483cd6984b6e9bfd7dfd5f59100843a6/" rel="bookmark">
			【C&#43;&#43;初阶】第七站：string类的初识(万字详解、细节拉满)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
📍本文知识点：string的初识
💨个人博客:Dream_Chaser～-CSDN博客
🚩本专栏：C++
目录
一、什么是STL
二、STL的六大组件
三、STL的缺陷
四、为什么学习string类？
五、标准库中的string类
1、string类(了解)
2、string类的常用接口说明（最常用的接口）
A. string类对象的常见构造
B.string类的成员函数的使用
1、for+operator [ ]
2、范围for遍历
3、迭代器遍历
反向迭代器
const修饰的迭代器
4.💥取字符串💥
C.string类对象的容量操作
size、length、capacity、clear 、max_size,:
❓来写一道题：387. 字符串中的第一个唯一字符
reserve resize at 下标自增
D.string类对象的修改操作 push_back、append、+=、+：
assgin
insert
erase
replace
swap
c_str
find、rfind、substr
find
rfind
substr
取出协议、域名、资源名：
find_first_of 和 find_first_not_of
一、什么是STL STL(standard template libaray-标准模板库)：是C++标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个包罗数据结构与算法的软件框架。
二、STL的六大组件 三、STL的缺陷 1. STL库的更新太慢了。这个得严重吐槽，上一版靠谱是C++98，中间的C++03基本一些修订。C++11出来已经相隔了13年，STL才进一步更新。 2. STL现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。 3. STL极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。 4. STL的使用会有代码膨胀的问题，比如使用vector/vector/vector这样会生成多份代码，当然这是模板语法本身导致的。
四、为什么学习string类？ 1、C语言中的字符串
C语言中，字符串是以'\0'结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。
2、面试题 ( 暂不做讲解) 字符串相加 在OJ中，有关字符串的题目基本以string类的形式出现，而且在常规工作中，为了简单、方便、快捷，基本都使用string类，很少有人去使用C库中的字符串操作函数 五、标准库中的string类 1、string类(了解) string类的文档介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/483cd6984b6e9bfd7dfd5f59100843a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/572f1a1d2b07a4a5855e6d7b636eaf5e/" rel="bookmark">
			高阶数据结构 ＜红黑树＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已收录至《数据结构(C/C++语言)》专栏！
作者：ARMCSKGT 目录 前言正文红黑树简介红黑树整体结构红黑树节点的定义红黑树主体类设计红黑树的插入函数情况一：变色情况二：变色+旋转单旋情况双旋情况 完整插入代码 关于红黑树红黑树检验红黑树 vs AVL树 最后 前言 红黑树是二叉搜索树的一种，但是红黑树是性能最均衡应用场景最广的一种二叉搜索树，相对于AVL树来说，红黑树在旋转条件上并不是很严格，但是依然可以有非常出色的查找性能，这得益于红黑树的性质，本节将为大家介绍红黑树的基本性质。
正文 本文相关知识点：二叉搜索树(搜索树性质)，AVL树(旋转相关)
如果大家对二叉搜索树性质不熟悉或者对树的旋转调整不熟悉，可以先移步这两篇文章就行了解！
红黑树简介 红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。
红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
前面我们介绍了AVL树，AVL树有着极其严格的平衡标准，这使得AVL树在某些极端情况下可能会频繁旋转导致插入和删除性能下降，而红黑树只有在极度不平衡下才会调整，对于红黑树来说，极度不平衡就是最长路径大于最短路径的两倍！
红黑树的性质：
每个节点不是黑色就是红色根节点是黑色如果一个节点是红色的，则它的两个孩子结点是黑色的（不存在连续的红色节点，例如父子节点都是红色）每条路径上叶子节点都是黑色的（红黑树中空节点NIL可以理解为叶子节点，这个叶节点没有特殊意思，方便判断）每条路径上的黑色节点数量相同 按照红黑树的性质，可以知道： 上图中，如果是AVL树就需要进行左单旋降低高度，而红黑树则不需要调整。
可以说，最短路径是全黑节点，最长路径是红黑相间。
因为最长路径的节点数量不能超过最短路径节点数量的两倍，所以 黑节点数量大于等于红节点数量。
我们一般在使用容器时，增删查改是都会出现的，如果使用AVL树，查找性能非常好，但是插入性能就一般了，所以一般语言标准中的容器都会使用红黑树，性能比较均衡，而AVL树则时候那些只读的静态数据，专门用于查询！
关于实际的性能差距，假设二叉树有n个节点，AVL树查询的时间复杂度为O( l o g 2 n log_2n log2​n)；红黑树查询的最优效率为O( l o g 2 n log_2n log2​n)，最差效率为O( 2 l o g 2 n 2log_2n 2log2​n)。 l o g 2 n log_2n log2​n和 2 l o g 2 n 2log_2n 2log2​n这两个数值的差距，对于计算机来说可以忽略不计，假设有10亿，也仅仅是30和60次查找的差别！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/572f1a1d2b07a4a5855e6d7b636eaf5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38a6af81a98b2f60b34c6cd348ef8f0/" rel="bookmark">
			灵神笔记(1)----动态规划篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍动态规划入门：从记忆化搜索到递推打家劫舍递归记忆化递归递推滚动变量 背包0-1 背包递归写法记忆化递归 目标和记忆化搜索递推两个数组一个数组 完全背包记忆化递归搜索 零钱兑换记忆化递归递推 背包问题变形[至多|恰好|至少] 最长公共子序列记忆化搜索递推两个一维数组一维数组 编辑距离记忆化搜索递推一个数组 介绍 本篇文章主要是观看"灵茶山艾府"动态规划篇视频后，做出的笔记。
视频链接如下
[动态规划入门：从记忆化搜索到递推]
[0-1背包，完全背包]
[最长公共子序列，编辑距离]
动态规划入门：从记忆化搜索到递推 打家劫舍 对于第i间房有两种抉择，选或者不选。选的话对应的子问题就是前i-2间房，不选的话对应的子问题就是前i-1间房。从第一间房子或者最后一间房子考虑受到的约束最小。假设从最后一间房子开始考虑，形成的递归树如下
上述思考过程可以抽象为：
当前操作?枚举第i个房子选或者不选。子问题?从前i个房子中得到的最大金额和下一个子问题：
不选，从前i-1个房子中得到的最大金额和
选，从前i-2个房子中得到的最大金额和 dfs(i) = max(dfs(i-1),dfs(i-1)+nums[i])
在定义dfs或者dp数组时，无法从单个元素中获取结果，而是从某一些元素中获取结果。
递归 class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { //i表示第i件物品选还是不选 //dfs(i)表示偷取前i家获得的最大金额 int n=nums.size(); return dfs(nums,n-1); } private: int dfs(const vector&lt;int&gt;&amp;nums,int i){ if(i&lt;0) return 0; return max(dfs(nums,i-1),dfs(nums,i-2)+nums[i]); } }; 这份代码会超出时间限制。时间复杂度是指数级别的为O(2n)仔细观察上述的递归树就会发现有很多重复计算的地方，所以可以用一个数组用来存储计算过的值，这样下次直接拿来用即可。 记忆化递归 class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { //i表示第i件物品选还是不选 //dfs(i)表示偷取前i家获得的最大金额 int n=nums.size(); vector&lt;int&gt;cache(n,-1); return dfs(nums,n-1,cache); } private: int dfs(const vector&lt;int&gt;&amp;nums,int i,vector&lt;int&gt;&amp;cache){ if(i&lt;0) return 0; //记忆化 if(cache[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a38a6af81a98b2f60b34c6cd348ef8f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0de64bc3c32140fa5b744a9054ff70/" rel="bookmark">
			【保姆级教程】使用SeaTunnel同步Kafka的数据到ClickHouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Apache SeaTunnel依赖地址
2.SeaTunnel官网的Source/Sink模板
3.SeaTunnel的GitHub地址
在官网下载安装包之后，（注意：别下载apache-seatunnel-incubating-2.1.0-bin.tar.gz版本，依赖和功能都没有。)要使用apache-seatunnel-2.3.3-bin.tar.gz，但还需要配置环境和jar包，jar包需要联网。
从2.2.0-beta开始，二进制包默认不提供Connectors的依赖，因此在第一次使用它时，需要执行以下命令来安装连接器。当然，您也可以从Apache Maven Repository\[https://repo.maven.apache.org/maven2/org/apache/seatunnel/\]手动下载连接器，然后移动到Connectors/SeaTunnel目录)
sh bin/install-plugin.sh 如果需要指定connector的版本，以2.3.3版本为例，需要执行
sh bin/install-plugin.sh 2.3.3 也可以手动导入依赖
1.这个目录下放连接器
apache-seatunnel-2.3.3/connectors/seatunnel 2.这个目录下放MySQL和clickhouse连接驱动和SeaTunnel的Source包
/usr/local/mysql/module/seatunnel/apache-seatunnel-2.3.3/lib 3.这个目录下放配置文件
/usr/local/mysql/module/seatunnel/apache-seatunnel-2.3.3/config 注意这里有一个seatunnel-env.sh文件，是配置Flink或者Spark环境变量的文件需要配置
执行命令
注意这里bin目录下的启动脚本选择，启动先最好先看一下flink -v、环境变量文件seatunnel-env.sh的配置、脚本选择(Flink版本不同，启动脚本不同)，确保Flink的jobmannean和taskman都启动，然后再执行任务.
example08.conf配置文件中
env { execution.parallelism = 1 job.mode = "STREAMING" checkpoint.interval = 2000 } 这里使用flink一定要是STREAMING，不能是BATCH 具体配置格式参考上面的第2点——SeaTunnel官网的Source/Sink模板，最后注意执行任务可能需要几十分钟，但数据一定要等任务运行完毕后才能过去。
‘ 附件是Apache SeaTunnel2.3.3版本的完整目录，包含MySQL、clickhouse的连接驱动和配置文件，包括seatunnel-env.sh环境变量文件，根据数据同步链路和服务器参数改动 。
附件2是配置文件,从MySQL到ClickHouse，从MySQL到Kafka，从Kafka到ClickHouse。
执行一次命令同步一次。在数据同步过程中，确保目标表和源表都存在，并且源表内有数据是非常重要的，这样才能够在执行同步命令后在目标表中看到同步效果
java [root@172-xx-xxx-x bin]# ./start-seatunnel-flink-15-connector-v2.sh --config ../config/example07.conf SeaTunnel配置中的env {j:ob.mode = "STREAMING"}的STREAMING和BATCH的区别
本文由 白鲸开源科技 提供发布支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be53a0203487a5d098808bb345c1c8b3/" rel="bookmark">
			从根本上优雅地解决 VSCode 中的 Python 模块导入问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体概述：
在我尝试运行 test_deal_file.py 时，我遇到了一个 ModuleNotFoundError 错误，Python告诉我找不到名为 controllers 的模块。这意味着我无法从 deal_file.py 中导入 read_excel 函数。
为了解决这个问题，我尝试了几种方法。
首先，我使用了相对导入，这在不改变当前工作目录的情况下是有效的，但一旦我切换了目录，这个方法就不行了。
接着，我尝试动态地将当前工作目录添加到 sys.path 中。
这样做虽然有效，但我觉得这种方法不够优雅。
所以，我决定采取一种更彻底的解决方案。
我通过修改 VSCode 的 settings.json 文件，设置了 PYTHONPATH 环境变量，确保了我的项目路径 my_project 被加入到模块搜索路径中。
我在settings.json中为不同的操作系统配置了terminal.integrated.env` 部分，然后重启了虚拟环境和集成终端。重新运行我的文件后，问题终于解决了。
通过这篇文章，我想和大家分享如何以一种更优雅的方式解决 Python 项目中的模块导入问题。
同时，我也介绍了如何在 VSCode 中管理项目环境变量和运行路径，这对于解决开发过程中的环境配置问题非常有帮助。希望我的经验能成为其他开发者在面对类似问题时的宝贵资源。
我的问题解决过程 （想直接看解决教程的直接跳到下一个标题内容）
我的项目结构是这样的
my_project/ ├── controllers/ │ ├── __init__.py │ └── deal_file.py └── tests/ ├── __init__.py └── test_deal_file.py 结果运行test_deal_file.py会出现报错信息：
# 报错信息 from controllers.deal_file import read_excel ModuleNotFoundError: No module named 'controllers' 我尝试了引用改成from ..controllers.deal_file import read_excel，terminal不切换目录可以运行成功，但切换目录后还是运行失败
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be53a0203487a5d098808bb345c1c8b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a6d9d1e9c6a717cb6bbddc5d273e6b/" rel="bookmark">
			Modbus报文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus是一种串行通信协议，最初由Modicon公司（现为施耐德电气的一部分）在1979年为使用其PLC（可编程逻辑控制器）而开发。Modbus已成为工业领域内广泛使用的一种通信协议，特别是对于监控和控制系统。Modbus协议支持多种通信方式，包括RTU（Remote Terminal Unit，远程终端单元模式）、TCP/IP和ASCII（美国标准信息交换码）等。
本文主要介绍Modbus RTU、Modbus TCP和Modbus ASCII的报文结构。
1.Modbus RTU 1.1简介 Modbus RTU（Remote Terminal Unit）是一种在串行通讯中广泛使用的协议，主要应用于工业领域的设备之间。这个协议是基于主/从（或客户端/服务器）架构，允许主机（通常称为Master）与多个从机（通常称为Slave）进行通信。在Modbus RTU协议中，数据通过二进制形式传输，使得通信更加高效。
1.2报文格式 一个典型的Modbus RTU报文结构如下：
用途设备地址功能码数据CRC校验长度8bit8bit可变（0到252个8bit）16bit描述每个从机都有一个唯一的地址。地址范围从0到247。地址0是广播地址，向所有从机发送消息，但从机不会对广播信息进行应答。用于指定主机要求从机执行的操作类型数据部分的长度可变，包含了命令的具体参数，确切格式和长度取决于功能码。用于检查数据在传输过程中是否有错误。 1.3报文详解 1.3.1设备地址 1.3.1.1地址范围 在Modbus RTU中，每个从机被分配一个唯一的地址，用于在网络上标识。这个地址是一个8位的数值，范围从0到247。通常情况下，地址0是保留的，用于广播命令，即发送给网络上所有设备的命令。地址248到255通常是保留给特殊功能或未来使用的。 1.3.1.2地址配置 设备地址通常需要在设备接入Modbus网络之前就进行配置。不同的设备制造商可能会提供不同的方法来设置这些地址，例如通过拨码开关、软件界面或者直接通过Modbus命令。 1.3.1.3通信过程 当主机向从机发送命令时，主机会在消息的开始部分包含从机的地址。从机收到消息后，会先检查消息地址，如果消息是发给自己的，则会执行，否则会抛弃。对广播地址（0），所有设备都会执行该命令。 1.3.1.4地址冲突 如果两个或更多的设备被设置成相同的地址，会导致地址冲突，进而导致通信失败。 1.3.2 功能码 在 Modbus 标准协议中，功能码总共分为三类：公用功能码、自定义功能码、保留功能码。
公用功能码即经过Modbus协会确认，并提供了公开文档的功能码。在文档中被明确定义，确保唯一。自定义功能码为各厂家（用户）自定义的功能码，不保证唯一性。保留功能码是在报文格式不给范的时候使用的一些功能码，现在已经不作为公共使用了。
（公用功能码和自定义功能码的区别可以近似对比计算机的熟知端口和注册端口） 1.3.2.1 读取功能码 01 (0x01): 读线圈状态（Read Coils）- 用于读取一组逻辑线圈的当前状态（ON/OFF）。02 (0x02): 读离散输入状态（Read Discrete Inputs）- 用于读取一组离散输入的状态（ON/OFF）。03 (0x03): 读保持寄存器（Read Holding Registers）- 用于读取一组保持寄存器中的二进制内容。04 (0x04): 读输入寄存器（Read Input Registers）- 用于读取一组输入寄存器中的二进制内容。 1.3.2.2 写入功能码 05 (0x05): 写单个线圈（Write Single Coil）- 用于写入单个逻辑线圈的状态（ON/OFF）。06 (0x06): 写单个寄存器（Write Single Register）- 用于写入单个保持寄存器的数据。15 (0x0F): 写多个线圈（Write Multiple Coils）- 用于写入一组逻辑线圈的状态。16 (0x10): 写多个寄存器（Write Multiple Registers）- 用于写入一组保持寄存器的数据。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64a6d9d1e9c6a717cb6bbddc5d273e6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83640b7c9dfcc9e2c10199cc485157df/" rel="bookmark">
			web 技术中前端和后端交互过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、客户端服务器交互过程 客户端:上网过程中,负责浏览资源的电脑,叫客户端
服务器:在因特网中,负责存放和对外提供资源的电脑叫服务器
服务器的本质: 就是一台电脑,只不过相比个人电脑它的性能高很多,个人电脑中可以通过安装浏览器的形式,访问服务器对外提供的各种资源。
个人电脑也可以配置环境，使能对外提供资源，也是一台服务器。
web 应用的一个基本框架：
微服务就是单个应用程序拆分成许多个小型服务的一种开发方法。举个例子：
支付宝上有订购火车票的服务，现在阿里巴巴又开发了一个微信小程序，上面也可以订购火车票，那么订购火车票的代码只需要开发一份就行了，谁需要它就去找它（请求调用）就行啦。
客户端服务器的交互过程：
访问本机服务器和访问互联网中的服务器的区别：
环境配置：
本机作为服务器：需要配置适当的软件和服务来充当服务器，例如安装和配置Web服务器（如Apache、Nginx）、数据库服务器（如MySQL、MongoDB）、应用服务器（如Tomcat、Node.js）等。
而访问其他服务器资源则不需要这样的配置。网络访问:
本机作为服务器：通常情况下，你需要确保你的网络设置、防火墙配置等允许其他用户通过网络访问你的服务。
而访问其他服务器资源时：只需要通过普通的网络连接即可。资源地址:
本机作为服务器：你可以使用本地主机地址（如localhost或者127.0.0.1）来访问你的服务器资源。
而访问其他服务器资源时：你需要使用对应服务器的地址或域名。权限和安全性:
本机作为服务器，需要考虑到权限和安全性的问题，确保你的服务对外界的访问是安全可控的。
而访问其他服务器资源时：你可能需要提供相应的凭证（如用户名和密码、API密钥等）来获取授权访问。 2、前端的功能 前端开发中常见的三种主要技术。
HTML：HTML 被认为是网页的骨架。它用于构建网页的内容，并且还告诉Web浏览器如何显示它。
CSS：CSS为浏览器提供了有关显示内容的更具体信息，例如文本的大小和颜色。
JavaScript：网站不仅仅是文本。JavaScript允许我们创建更复杂的元素，如交互式地图和动画图形。它能够让我们的网页具有更多功能。
3、后端的功能 根据不同的请求信息做出不同的响应。具体来说，当用户触发某个行为后，客户端会通过 http/https 请求，和服务器建立连接、发送请求，往往这个请求首先会被连接到 LB（负载均衡上），LB 根据配置，将请求转发到内部的 API 服务上。这些 API 服务，根据不同的业务逻辑请求其他服务（service），这些服务各司其职，例如读写某 Mysql 表、读写缓存、甚至请求搜索引擎来完成相应的任务。而 API 服务在完成相应的流程后，也会将数据返回给客户端，客户端根据前端逻辑完成相关的展示。
4、web 前后端是如何交互的 在本地开发Angular前端和Spring Boot后端时，他们之间的交互基于http协议。
前端发送HTTP请求：Angular前端通过Angular框架提供的HttpClient模块或其他HTTP客户端库发送HTTP请求到后端。
后端接收HTTP请求：Spring Boot后端应用程序通过Spring MVC或Spring Webflux等Web框架接收HTTP请求。这些框架提供了用于处理不同HTTP方法和路径的注解和工具。
后端处理HTTP请求：后端应用程序根据收到的HTTP请求执行相应的业务逻辑。这可能包括从数据库中检索数据、执行业务逻辑、对数据进行处理等。
后端发送HTTP响应：一旦后端完成处理，它将生成HTTP响应并将其发送回前端。响应通常包括HTTP状态码、响应头和响应体。响应体中可以包含请求的结果数据或者其他信息。
前端接收HTTP响应：Angular前端接收到后端发送的HTTP响应。它根据响应中的数据进行相应的操作，例如更新界面、显示数据、处理错误等。
5、后端的MVC框架 Model（模型层）：提供/保存数据
Controller（控制层）：数据处理，实现业务逻辑
View（视图层）：展示数据，提供用户界面
前端只是后端 MVC 的 V（视图层），从数据与逻辑代码中分离出来。
认识开发中的工具 Web服务器 ：
常见的Web服务器软件包括Apache、Nginx、Microsoft IIS等。这些服务器软件通常运行在服务器操作系统上，如Linux、Windows Server等。
apache 是最原始的 web 服务器，使用 C 语言开发的，非常稳定。只支持普通网页（html）的静态解析，但可以通过插件支持 php。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83640b7c9dfcc9e2c10199cc485157df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d294015c15094643b8741e79335369c/" rel="bookmark">
			H5获取手机相机或相册图片两种方式-Android通过webview传递多张照片给H5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求目的： 手机机通过webView展示H5网页，在特殊场景下，需要使用相机拍照或者从相册获取照片，上传后台。
完整流程效果： 如下图
一、H5界面样例代码 使用html文件格式，文件直接打开就可以展示布局；一会在andriod webview中直接加载
&lt;!DOCTYPE html&gt; &lt;html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;div id="app"&gt; &lt;h1&gt;alllalalallalal 默认会被覆盖&lt;/h1&gt; &lt;/div&gt; &lt;template id="why"&gt; &lt;div&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2&gt;{{counter}}&lt;/h2&gt; &lt;button @click="increment"&gt;+1&lt;/button&gt; &lt;button @click="decrement"&gt;-1&lt;/button&gt; &lt;h1 style="text-align: center;"&gt;{{ title }}&lt;/h1&gt; &lt;div&gt; &lt;h2 style="text-align: center;"&gt;android选中照片H5展示&lt;/h2&gt; &lt;!--HTML5提供了&lt;input type="file"&gt;元素来实现选取文件的功能,在WebView表现为调用onShowFileChooser--&gt; &lt;input accept="image/*" capture="camera" ref="imgFile" type="file" multiple @change="previewFiles"&gt; &lt;div id="preview"&gt; &lt;img v-for="imgSrc in imageSources" :src="imgSrc" :key="imgSrc" style="max-width: 100px; max-height: 100px; margin: 10px;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d294015c15094643b8741e79335369c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5260e0e41c8cea79859831965458fea/" rel="bookmark">
			ClickHouse10-ClickHouse中Kafka表引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka表引擎也是一种常见的表引擎，在很多大数据量的场景下，会从源通过Kafka将数据输送到ClickHouse，Kafka作为输送的方式，ClickHouse作为存储引擎与查询引擎，大数据量的数据可以得到快速的、高压缩的存储。
Kafka大家肯定不陌生：
它可以用于发布和订阅数据流，是常见的队列使用方式它可以组织容错存储，是常见的容错存储的使用方式它可以在流可用时对其进行处理，是常见的大数据处理的使用方式 全文概览：
基本语法从 Kafka 写入到 ClickHouse从 ClickHouse 写入到 Kafka 测试1：queue-&gt;ck-&gt;queue测试2：ck-&gt;queue 基本语法 分为定义表结构和定义Kafka的接入参数，Kafka的接入参数都是常见的字段
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster] ( name1 [type1] [ALIAS expr1], name2 [type2] [ALIAS expr2], ... ) ENGINE = Kafka() SETTINGS kafka_broker_list = 'host:port', kafka_topic_list = 'topic1,topic2,...', kafka_group_name = 'group_name', kafka_format = 'data_format'[,] [kafka_schema = '',] [kafka_num_consumers = N,] [kafka_max_block_size = 0,] [kafka_skip_broken_messages = N,] [kafka_commit_every_batch = 0,] [kafka_client_id = '',] [kafka_poll_timeout_ms = 0,] [kafka_poll_max_batch_size = 0,] [kafka_flush_interval_ms = 0,] [kafka_thread_per_consumer = 0,] [kafka_handle_error_mode = 'default',] [kafka_commit_on_select = false,] [kafka_max_rows_per_message = 1]; 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5260e0e41c8cea79859831965458fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a117916bb636c4d55a5377f2681e85/" rel="bookmark">
			高级数据结构 ＜AVL树＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已收录至《数据结构(C/C++语言)》专栏！
作者：ARMCSKGT 目录 前言正文AVL树的性质AVL树的定义AVL树的插入函数左单旋右单旋右左双旋左右双旋 检验AVL树的合法性关于AVL树 最后 前言 前面我们学习了二叉树，普通的二叉树没有任何特殊性质，所以后面我们又学习了二叉搜索树，这种有序的结构一定程度上优化了二叉树的性能，但是普通的二叉搜索树在特殊情况下，例如插入序列从大到小有序时，二叉搜索树会退化成类似于链表的单支数，此时性能变为O(n)，为了解决这个问题，科学家在二叉搜索树的基础上再次进行升级，而有了我们现在常见的 AVL树 和 红黑树 ，本节我们将介绍AVL树的基础性质。
正文 在介绍AVL树之前，如果你没有了解过 二叉搜索树 或 二叉树，请移步先了解前置知识！
本节介绍AVL树默认中序遍历为升序序列
AVL树的性质 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。
因此，两位俄罗斯的数学家 G.M.Adelson-Velskii 和 E.M.Landis 在1962年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。
简而言之，AVL树通过一个 平衡因子bf(右子树深度减去左子树深度) 来记录根节点左右子树深度的差，一般情况下，平衡因子只会有五种情况：
左子树比右子树深度高两层，此时平衡因子为 -2 ，此时需要对树进行旋转调整左子树比右子树深度高一层，此时平衡因子为 -1左子树与右子树深度相等，此时平衡因子为 0左子树比右子树深度低一层，此时平衡因子为 1左子树比右子树深度低两层，此时平衡因子为 2 ，此时需要对树进行旋转调整 综上，如果二叉搜索树具备以下性质，则为AVL树：
左右子树的高度之差（平衡因子）的绝对值不超过 1它的左右子树都是 AVL 树 AVL树结构（节点上的数字就是平衡因子）：
这颗树没有出现不平衡的情况，每个节点的平衡因子的绝对值不超过2。
这样看来，AVL树是一颗高度平衡的二叉搜索树，如果AVL树有N个节点，则AVL树的高度为 log ⁡ n \log_n logn​，此时找到任意节点的时间复杂度都是O( log ⁡ 2 N \log_2N log2​N)。
我们学习AVL树主要是研究其插入节点后如何保持平衡的思想！
AVL树的定义 AVL树在二叉树的基础上，增加了一个指针指向了父节点以及一个平衡因子，所以AVL树是三叉链结构！
节点定义代码：
#include &lt;iostream&gt; template&lt;class K,class V&gt; struct TreeNode { TreeNode&lt;K, V&gt;* _left; // 左子树 TreeNode&lt;K, V&gt;* _right;	// 右子树 TreeNode&lt;K, V&gt;* _parent; // 父节点 std::pair&lt;K, V&gt; _val; // 节点键值对(节点值) int _bf;	// 平衡因子 TreeNode() :_left (nullptr) ,_right (nullptr) ,_parent(nullptr) ,_val(pair&lt;K,V&gt;()) ,_bf(0) {} TreeNode(const pair&lt;K,V&gt;&amp; val) :_left (nullptr) , _right (nullptr) , _parent(nullptr) , _val(val) , _bf(0) {} TreeNode(const K&amp; key,const V&amp; val) :_left(nullptr) , _right(nullptr) , _parent(nullptr) , _val({key,val}) , _bf(0) {} }; AVL树的定义比较简单，只需要一个根节点_root记录即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89a117916bb636c4d55a5377f2681e85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dce0d004e72c6ca4f59d2d3869fb4eb/" rel="bookmark">
			【深度学习】最强算法模型之：潜在狄利克雷分配(LDA)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		潜在狄利克雷分配 1、引言2、潜在狄利克雷分配2.1 定义2.2 原理2.3 算法公式2.4 代码示例 3、总结 1、引言 小屌丝：鱼哥， 给我讲一讲LDA
小鱼：LDA？ 你指的是？
小屌丝：就是算法模型的LDA啊， 你想啥？
小鱼：哦，哦， 那就好，
小屌丝：你告诉我，你想啥了？
小鱼：不滴， 我就不
小屌丝：…你就说吧，我又不是外人
小鱼：…把耳朵凑过来，这只能悄悄说
小屌丝：鱼哥，你这… 咱不开车行不
小鱼：… 最近健身，骑自行车呢
小屌丝： … 我差点信了
小鱼：… 不扯了，咱还是开始 LDA吧。
小屌丝：那可不。
2、潜在狄利克雷分配 2.1 定义 潜在狄利克雷分配（LDA）是一种生成概率模型，用于集合（如文档集合或语料库）的离散数据（如文档中的单词）的集合中发现潜在的结构。
在LDA中，每个文档被视为由多个主题的混合生成，而每个主题又是由词汇表中单词的特定概率分布所定义。
2.2 原理 LDA的核心原理在于假设文档是由潜在的主题混合而成的，而每个主题则由一组单词的概率分布来定义。
LDA通过最大化文档的似然性来估计这些主题和它们的单词分布。
在文档生成过程中，首先根据主题分布选择一个主题，然后根据该主题的单词分布生成一个单词。
这个过程在文档中重复进行，直到生成完整的文档。
2.3 算法公式 LDA的数学表达涉及概率图模型中的节点和边，以及相应的条件概率分布。
具体来说，LDA定义了一个文档集合中每篇文档的主题分布 （ θ ） （θ） （θ），每个主题的单词分布 （ φ ） （φ） （φ），以及文档的生成过程。
LDA的主要公式包括：
主题分布θ的先验分布： D i r i c h l e t ( α ) Dirichlet(α) Dirichlet(α)单词分布φ的先验分布： D i r i c h l e t ( β ) Dirichlet(β) Dirichlet(β)文档中第n个词的主题分布： z n M u l t i n o m i a l ( θ ) z_n ~ Multinomial(θ) zn​ Multinomial(θ)给定主题z_n，文档中第n个词的单词分布：KaTeX parse error: Double subscript at position 22: …Multinomial(φ_z_̲n) 其中， α α α和 β β β是超参数，分别控制主题分布和单词分布的稀疏性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dce0d004e72c6ca4f59d2d3869fb4eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1daaf2fcae8bd6478badb1856703c178/" rel="bookmark">
			PyWebIO，一个非常好用的 Python 库！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多资料获取 📚 个人网站：ipengtao.com
大家好，今天为大家分享一个非常好用的 Python 库 - PyWebIO。
Github地址：https://github.com/pywebio/PyWebIO
在Web应用开发领域，交互式界面是用户与应用程序进行沟通和交互的重要方式。而Python的PyWebIO库为开发人员提供了一种简单高效的方式来构建交互式Web应用，无需繁琐的前端代码，只需使用Python即可实现丰富的交互功能。本文将深入探讨PyWebIO库的各个方面，包括其基本概念、功能特性、用法示例以及应用场景。
什么是PyWebIO库？ PyWebIO是一个基于Python的Web交互式应用开发库，旨在简化Web应用的开发流程，使开发人员能够使用Python语言快速构建交互式Web应用，无需深入了解前端技术。PyWebIO提供了丰富的组件和API接口，支持多种交互方式，包括文本输入、按钮、下拉菜单、文件上传等，以及与前端JavaScript的交互功能。
安装PyWebIO库 在开始使用PyWebIO之前，需要先安装它。
可以使用pip来安装PyWebIO：
pip install pywebio 安装完成后，就可以开始使用PyWebIO库了。
基本功能 1. 使用put_text()显示文本 使用put_text()函数可以在页面上显示文本内容，这是构建Web交互式应用的基础。
from pywebio import put_text put_text("Hello, PyWebIO!") 2. 使用input()获取用户输入 使用input()函数可以获取用户输入的文本内容，从而实现与用户的交互。
from pywebio.input import input user_name = input("Please enter your name:") put_text("Hello, %s!" % user_name) 3. 使用put_buttons()显示按钮 使用put_buttons()函数可以在页面上显示按钮，用户点击按钮后可以触发相应的操作。
from pywebio.input import input, BUTTONS button = input("Please select an option:", buttons=['Option 1', 'Option 2', 'Option 3']) put_text("You selected: %s" % button) 高级特性 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1daaf2fcae8bd6478badb1856703c178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09221450b9f29e29fb67bc8c4ac53430/" rel="bookmark">
			springMVC访问controller报错404解决办法（总结超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述:
纯注解配置SpringMVC程序，使用tomcat8.5.95版本启动，能启动成功并且访问index.jsp页面，但是访问/save时出现404无法访问，程序如下
解决办法:
一.更换高版本tomcat 以下的所有方法我全部都尝试过，但还是访问controller 404，最后更换了最新版本的tomcat才解决，所以在此把该方法列到第一个
二.检查jdk与spring版本是否兼容 Spring 框架的不同版本对于 JDK 的要求是有所区别的。一般来说，每个 Spring 框架版本都会声明它所支持的 JDK 版本范围。以下是一些常见的 Spring 框架版本对 JDK 的要求：
1. Spring Framework 5.x:
- Spring 5.x 支持 JDK 8 及以上版本。这意味着你可以在 JDK 8、9、10、11、12、13、14、15 和 16 上运行 Spring Framework 5.x
2. Spring Framework 6.x:
- Spring Framework 6基于JDK 17构建。换句话讲，若想使用Spring Framework 6那么你的JDK环境最低要求JDK 17
因此，如果你在使用 Spring MVC 6.x 版本，需要确保你的 JDK 版本符合其要求。当然，具体的兼容性要求最好还是查阅官方文档或者发布说明，以确保 JDK 和 Spring 版本之间的兼容性。
三.删项目重写一个 这一步骤是一种常见的排查问题的方法，通常用于排除项目中可能存在的难以定位的问题。通过删除并重新编写项目，你可以确保项目的结构和配置是干净的，并且可以排除一些潜在的问题
操作起来很简单，文件夹里找到项目直接删除即可
四.WEB-INF中导入lib 在传统的基于 Servlet 的 Web 应用中，通常会将项目所需的第三方库（JAR 文件）放置在 WEB-INF/lib 目录下。这些 JAR 文件包含了项目所需的各种依赖库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09221450b9f29e29fb67bc8c4ac53430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5941a5ba4095b065c99e777bc4f906b3/" rel="bookmark">
			Llama模型下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近llama模型下载的方式又又变了，所以今天简单更新一篇文章，关于下载的，首先上官网，不管在哪里下载你都要去官网登记一下信息：https://llama.meta.com/llama2
然后会出现下面的信息登记网页：
我这里因为待业所以organization那一栏写的是no organization。。哈哈，反正也给通过了。在这个页面你可以选择需要下载的模型，一般大家估计直接llama2了：
然后拉到底，勾选I accept就可以继续了。估计等一会儿你就会收到邮件：
然后邮件里会有一个很详细的介绍：
How to download the models:
Visit the Llama repository in GitHub and follow the instructions in the README to run the download.sh script.When asked for your unique custom URL, please insert the following: 你的URL信息！！！！！！Select which model weights to download 然后大家直接去llama的GitHub网页上：llama/download.sh at main · meta-llama/llama · GitHub，把这个download.sh下载下来或者直接新建个bash文件，然后把download.sh复制到咱们的文件里。然后终端运行bash，就会出现以下界面：
接着你就输入你邮件里的那个url信息，选择要下载的模型就可以啦！llama-2-7b这个文件大概14个G。所以大家下载前可以看下自己的盘够不够这个空间。如果出现403的错误，那就重新申请！！！
LLama2的简介
Llama 2是Meta最新的大语言模型（LLM），应用广泛，影响力大。在模型架构方面，Llama 2 采用了 Llama 1 的大部分预训练设置和模型架构。它使用标准 Transformer 架构，应用 RMSNorm 进行预归一化，使用 SwiGLU 激活函数，并采用旋转位置嵌入 (RoPE)。 与 Llama 1 相比，架构的主要区别包括将上下文长度从 2048 扩展到 4096 以及利用分组查询注意力 (GQA)。Llama2 有 4 种不同的大小的模型：7B、13B、34B 和 70B（34B 版本尚未发布，下载选项里确实也没有）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70067b4048953ac4776eafdb1729152/" rel="bookmark">
			Python抓取抖音直播间数据：技术探索与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、技术准备
三、分析抖音直播间网页结构
四、编写爬虫代码
五、处理反爬虫机制
六、数据清洗与存储
七、总结
一、引言 随着互联网的快速发展，直播行业已成为当下的热门领域。抖音作为其中的佼佼者，吸引了大量的用户和主播。对于数据分析师、市场研究人员或是对抖音直播感兴趣的普通用户来说，获取抖音直播间的数据显得尤为重要。本文将介绍如何使用Python来抓取抖音直播间数据，并提供相应的代码示例和注释，以帮助初学者理解和实践这一技术。
二、技术准备 在开始之前，我们需要确保已经安装了必要的Python库。这里我们将使用requests库来发送HTTP请求，BeautifulSoup库来解析HTML内容，以及pandas库来处理和分析抓取到的数据。如果尚未安装这些库，可以通过以下命令进行安装：
pip install requests beautifulsoup4 pandas
三、分析抖音直播间网页结构 首先，我们需要分析抖音直播间网页的结构，以确定目标数据的来源。这通常可以通过浏览器的开发者工具来完成。打开抖音直播间页面，右键点击页面元素，选择“检查”或“审查元素”，即可查看该元素的HTML代码。通过观察和分析，我们可以确定需要提取的数据对应的HTML标签和属性。
四、编写爬虫代码 接下来，我们将编写Python代码来实现抖音直播间数据的抓取。首先，我们需要发送HTTP请求获取直播间的网页内容。这里以抓取直播间标题为例：
import requests from bs4 import BeautifulSoup # 抖音直播间URL live_room_url = 'https://www.douyin.com/some_live_room_id' # 设置请求头，模拟浏览器访问 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' } # 发送GET请求 response = requests.get(live_room_url, headers=headers) # 检查请求是否成功 if response.status_code == 200: # 解析HTML内容 soup = BeautifulSoup(response.text, 'html.parser') # 查找直播间标题，假设它在&lt;h1&gt;标签中，具体根据实际情况调整 title_tag = soup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f70067b4048953ac4776eafdb1729152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e952919188f25e4944429ccce01ab950/" rel="bookmark">
			Intellij IDEA安装配置Spark与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Scala配置教程
配置Spark运行环境
编写Spark程序
1、包和导入
2、定义对象
3、主函数
4、创建Spark配置和上下文
5、定义输入文件路径
6、单词计数逻辑
7、输出结果
8、完整代码：
Scala配置教程 IDEA配置Scala：教程
配置Spark运行环境 添加Spark开发依赖包（快捷键：Ctrl+Alt+Shift+S）
找到Spark安装目录下的jars文件夹，将整个文件夹导入 Spark编程环境配置完成 在com.tipdm.sparkDemo包下新建WordCount类并指定类型为object，编写spark程序实现单词计数器。
选择Dependencies勾选Scala-sdk-2.12.15和jars
添加Add Content root Root
选择jars点击ok
编写Spark程序 在Scala的基础上（教程）
1、包和导入 package com.tipdm.sparkDemo import org.apache.spark.{SparkConf, SparkContext} 这里定义了一个包（com.tipdm.sparkDemo），并导入了SparkConf和SparkContext这两个类，它们都是Apache Spark的核心组件。
2、定义对象 object WordCount { 这里定义了一个单例对象WordCount。在Scala中，对象可以包含方法和字段，并且可以作为程序的入口点。
3、主函数 def main(args: Array[String]): Unit = { 这是程序的入口点，main函数。它接收一个字符串数组作为参数（通常用于命令行参数），并返回Unit（在Scala中，这相当于Java中的void）。
4、创建Spark配置和上下文 val conf = new SparkConf().setAppName("WordCount").setMaster("local") val sc = new SparkContext(conf) 首先，创建一个SparkConf对象并设置应用程序的名称为"WordCount"。然后，使用这个配置创建一个SparkContext对象，它是Spark应用程序的入口点。
5、定义输入文件路径 val input = "C:\\Users\\John\\Desktop\\words.txt" 这里定义了一个字符串变量input，它包含了要读取的文件的路径。
6、单词计数逻辑 val count = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e952919188f25e4944429ccce01ab950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347d988917c6a05f928d8ee3fd213770/" rel="bookmark">
			MySQL中使用distinct单、多字段去重方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、distinct
1.1 只对一个字段查重
1.2多个字段去重
1.3针对null处理
1.4与distinctrow同义
二、聚合函数中使用distinct
三、CONCAT_WS函数
多个字段拼接去重是指将多个字段的值按照一定的规则进行拼接，并去除重复的拼接结果。这样可以生成唯一标识符或者进行数据统计。
一、distinct distinct用来查询不重复记录的条数,即distinct来返回不重复字段的条数（count(distinct id)）,其原因是distinct只能返回他的目标字段，而无法返回其他字段
用法注意：
distinct【查询字段】，必须放在要查询字段的开头，即放在第一个参数；只能在SELECT 语句中使用，不能在 INSERT, DELETE, UPDATE 中使用；DISTINCT 表示对后面的所有参数的拼接取不重复的记录，即查出的参数拼接每行记录都是唯一的不能与all同时使用，默认情况下，查询时返回的就是所有的结果。 1.1 只对一个字段查重 对一个字段查重，表示选取该字段一列不重复的数据。
示例表：psur_list
PLAN_NUMBER字段去重，语句：
SELECT DISTINCT PLAN_NUMBER FROM psur_list; 1.2多个字段去重 对多个字段去重，表示选取多个字段拼接的一条记录，不重复的所有记录
PLAN_NUMBER和PRODUCT_NAME字段去重，语句：
SELECT DISTINCT PLAN_NUMBER,PRODUCT_NAME FROM psur_list; 期望结果：只对第一个参数PLAN_NUMBER取唯一值
解决办法一：使用group_concat 函数
语句：
SELECT GROUP_CONCAT(DISTINCT PLAN_NUMBER) AS PLAN_NUMBER,PRODUCT_NAME from psur_list GROUP BY PLAN_NUMBER 解决办法二：使用group by
语句：
SELECT PLAN_NUMBER,PRODUCT_NAME FROM psur_list GROUP BY PLAN_NUMBER 1.3针对null处理 distinct不会过滤掉null值，返回结果包含null值
表psur_list如下：
对COUNTRY单字段去重，语句：
SELECT DISTINCT COUNTRY FROM psur_list 对COUNTRY多字段去重，语句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/347d988917c6a05f928d8ee3fd213770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb3393dc1f73ddc460d82ab6809798d/" rel="bookmark">
			第十三届蓝桥杯省赛真题 Java 研究生 组【原卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发现宝藏【考生须知】试题 A: 排列字母试题 B: 灭鼠先锋试题 C: 质因数个数试题 D: 数位排序试题 E: 蜂巢试题 F : \mathrm{F}: F: 爬树的甲壳虫试题 G: 重新排序试题 H \mathrm{H} H : 技能升级试题 I: 最优清零方案试题 J : \mathrm{J}: J: 推导部分和 发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
第十三届蓝桥杯大赛软件赛省赛 Java 研究生 组 【考生须知】 考试开始后, 选手首先下载题目, 并使用考场现场公布的解压密码解压试题。
考试时间为 4 小时。考试期间选手可浏览自己已经提交的答案, 被浏览的答案允许拷贝。时间截止后，将无法继续提交或浏览答案。
对同一题目, 选手可多次提交答案, 以最后一次提交的答案为准。
选手必须通过浏览器方式提交自己的答案。选手在其它位置的作答或其它方式提交的答案无效。
试题包含 “结果填空” 和 “程序设计” 两种题型。
结果填空题: 要求选手根据题目描述直接填写结果。求解方式不限。不要求源代码。把结果填空的答案直接通过网页提交即可, 不要书写多余的内容。
程序设计题: 要求选手设计的程序对于给定的输入能给出正确的输出结果。考生的程序只有能运行出正确结果才有机会得分。
注意: 在评卷时使用的输入数据与试卷中给出的示例数据可能是不同的。选手的程序必须是通用的, 不能只对试卷中给定的数据有效。
所有源码必须在同一文件中。调试通过后，拷贝提交。
注意: 不要使用 package 语句。
注意：选手代码的主类名必须为: Main, 否则会被判为无效代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb3393dc1f73ddc460d82ab6809798d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157d8d72dfc2cd1bac986417f1f9be55/" rel="bookmark">
			【SQL】COUNT()函数 用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		COUNT()函数 COUNT函数用法：COUNT ( [ALL | DISTINCT] column | expression | *)
ALL关键字指示统计所有值，而DISTINCT关键字强制函数仅对不同的值进行操作。 默认情况下，使用ALL选项。条件表达式 COUNT()函数中条件表达式加 OR null。例如，SELECT COUNT(number &gt; 200 OR null) FROM vf;COUNT()函数中条件表达式使用 if。例如，SELECT COUNT(if(number &gt; 200, 1, null)) FROM vf;COUNT()函数中条件表达式使用 case when。例如，SELECT COUNT(case when number &gt; 200 then 1 end) FROM vf; 解析：sql 语句中count()有条件的时候为什么要加上or null? 例如count(sex= ‘男生’ or NULL) ，为什么要加上or NULL，直接count(sex=‘男生’)有什么问题吗？不就是要找sex= '男生’的数据吗，为什么要计算NULL的数据。 答案： 因为当 sex不是男生时 sex=‘男生’ 结果false。不是 NULL， count在值是NULL是不统计数,（count(‘任意内容’)都会统计出所有记录数，因为count只有在遇见null时不计数，即count(null)==0，因此前者单引号内不管输入什么值都会统计出所有记录数），至于加上or NULL ， 很像其他编程里的or运算符，第一个表达式是true就是不执行or后面的表达式，第一个表达式是false 执行or后面的表达式 。当sex不为男生时，sex= ‘男生’ or NULL 的结果是NULL，Count才不会统计上这条记录数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/157d8d72dfc2cd1bac986417f1f9be55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc3595e05147e0743868ba94bd046b5/" rel="bookmark">
			C# 快速将数据写入 Excel 单元格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
性能问题
Excel元素结构及写入原理
范例运行环境
配置Office DCOM
实现代码
组件库引入
核心代码
WriteArrayToExcel
神奇的 911 事件
小结
性能问题 将生成或查询到的数据，导出到 Excel 是应用中常用的一项功能。其中一些标准的写入单元格的方法如下：
Worksheet worksheet = (Worksheet) excel.Worksheets[1]; //引用坐标对Cells集合进行写入 worksheet.Cells[1, 1] = "test"; //还可以引用地址进行写入 worksheet.Cells["A1",Type.Missing]="test"; 请注意，office 元素大多的起始序号均从 1 开始，而不是 0，如 worksheet，cells等。
现在我们假设有二维数组 object[,] dataobj ，遍历式的写法如下：
int arraywidth=dataobj.GetLength(1); int arrayheight=dataobj.GetLength(0); Worksheet worksheet = (Worksheet) excel.Worksheets[1]; for(int j=0;j&lt;arrayheight;j++) { for(int k=0;k&lt;arraywidth;k++) { worksheet.Cells[j+1,k+1]=dataobj[j,k]; }//end columns }// end rows 此种写法在数据较少的时候在写入速度方面没有明显差异，但当大数据量的情况，多次的读写CELL单元格 IO 是一项非常耗时的操作，甚至会无法完成应用的预期目标。
Excel元素结构及写入原理 元素结构如下图：
其中Range对象，代表了Excel单元格集合的指定区域。
如图选中的Range范围起始的单元格是第5行第3列，结束于第17行第8列。它相当于object[13,6] 的一个二维数组，Excel的Range提供了get_Resize方法并通过Value2可以一次性的设置它们。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc3595e05147e0743868ba94bd046b5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/453/">«</a>
	<span class="pagination__item pagination__item--current">454/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/455/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>