<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afd076038be1cca4317579a6d0d64f1/" rel="bookmark">
			apex安装常见的三个报错并成功解决（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前三个方法我都遇到了错误，直到方法4才成功解决，建议看完全文后再决定使用哪种方法，或者直接使用方法4。
方法1 一开始我使用如下命令进行安装，
pip install apex 安装成功后，进入python，执行语句import apex进行验证是否安装成功，得到报错
TypeError: Class advice impossible in Python3. Use the @implementer class decorator instead. 方法2 于是在网上找了方法如下，遂将刚才安装的apex卸载，卸载命令为pip uninstall apex，然后根据如下的网上方法安装
git clone https://www.github.com/nvidia/apex cd apex python setup.py install 安装好后再次进行验证，得到报错如下
TypeError: unsupported operand type(s) for +: ‘NoneType‘ and ‘str‘ 方法3 再次卸载，然后参考https://blog.csdn.net/qq_37844044/article/details/122625442，得到方法如下，相当于把方法2的第三行改为pip install -v --no-cache-dir ./
git clone https://github.com/NVIDIA/apex.git cd apex pip install -v --no-cache-dir ./ 安装好后再次验证，得到报错
AttributeError: module 'torch.distributed' has no attribute '_all_gather_base' 方法4 再次卸载，然后参考这篇博文https://blog.csdn.net/weixin_44438120/article/details/112526744，方法如下
git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0afd076038be1cca4317579a6d0d64f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0c3bc015e834d7a7e09895f3661ccc/" rel="bookmark">
			Requested bean is currently in creation: Is there an unresolvable circular reference? 原因之一（java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 更新新的工作插件，工作空间 启动项目报错
Error creating bean with name 'xxxxxx': Requested bean is currently in creation: Is there an unresolvable circular reference?
原因之一（占比大多数）：
service 实现自己注入了自己的接口导致的，例如：
正常代码是实现接口后直接重新或者方法名称直调就行不用再次注入直接的接口这种错误的写法
解决办法我这边粗浅的有两种
1. 把循环依赖的注入给去掉（因为人家Srping 不推荐使用，现在是直接拒绝，之前还能用，让你启动都启动不起来）
2. 如果是项目比较老旧而且循环依赖比较多改起来头皮发麻，那就直接在配置文件application.yml 配置添加 allow-circular-references: true 属性位置上代码
spring: main: allow-circular-references: true application: name: app 粗暴的解决循环依赖的问题（这种解决方式用起来很爽，我才不管什么饮鸩止渴）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af505237f4af8861f35174cd50e72cc/" rel="bookmark">
			解决：ENOTEMPTY: directory not empty, rename ‘node_modules/webpack‘ -＞ ‘node_modules/.webpack-E4nb的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题描述： 其一、报错为： npm ERR! ENOTEMPTY: directory not empty, rename '/usr/local/lib/node_modules/webpack' -&gt; '/usr/local/lib/node_modules/.webpack-ENG41nb9'
// 报错的整体代码为：
npm ERR! code ENOTEMPTY npm ERR! syscall rename npm ERR! path /usr/local/lib/node_modules/webpack npm ERR! dest /usr/local/lib/node_modules/.webpack-ENG41nb9 npm ERR! errno -66 npm ERR! ENOTEMPTY: directory not empty, rename '/usr/local/lib/node_modules/webpack' -&gt; '/usr/local/lib/node_modules/.webpack-ENG41nb9' npm ERR! A complete log of this run can be found in: 中文为：
npm 错误！ ENOTEMPTY：目录不为空，重命名 '/usr/local/lib/node_modules/webpack' -&gt; '/usr/local/lib/node_modules/.webpack-ENG41nb9
其二、问题描述为： 在用 npm 工具来管理 vue 项目时，突然报了一个这样的错误，想简单的删除 node_modules 文件，然后再重新 npm i 来建立新的 node_module 文件，却发现一直解决不了;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3af505237f4af8861f35174cd50e72cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a75178cbcba3efcfd3b42b62410cb737/" rel="bookmark">
			数据库课程设计（医院数据库系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅供参考
我们数据库老师让我们设计的数据库最少要20个实体集，所以有几个实体集有一点重复
参考了csdn上面的很多大佬，感谢！！！！！！！！！！！！！！！！！！！！！！！！！
医院管理系统数据库，课程设计，SQLserver，纯代码设计_医院信息管理系统数据库_普通网友的博客-CSDN博客
数据库课程设计 医院管理系统 SQL_医院数据库管理系统_硝酸童不酸的博客-CSDN博客 医院管理数据库课程设计_医院管理系统数据库设计_呆萌小新@渊洁的博客-CSDN博客 一、数据库设计 1.1 设计目的 医院信息管理系统的开发目的是为了提高医院的信息化水平，实现医疗信息的数字化、网络化和智能化管理，提高医疗服务的质量和效率，满足患者的需求和期望，达到以下5个目的。
1.提高医疗服务的质量和效率：通过建立完善的医院信息管理系统，实现医疗信息的数字化、网络化和智能化管理，提高医疗服务的质量和效率，减少医疗事故和误诊率，提高患者的满意度和信任度。
2. 优化医院的管理和运营：通过医院信息管理系统，实现医院各个部门之间的信息共享和协作，优化医院的管理和运营，提高医院的效益和竞争力，降低医院的管理成本和风险。
3. 提高医生和护士的工作效率：通过医院信息管理系统，实现医生和护士的工作流程的数字化和自动化，减少繁琐的手工操作，提高工作效率和医疗服务的质量。
4. 保障医疗信息的安全和隐私：通过医院信息管理系统，实现医疗信息的安全和隐私保护，保护患者的个人隐私和医疗信息的安全，提高患者对医院的信任度和满意度。
5. 推动医疗信息化建设：通过医院信息管理系统，推动医疗信息化建设，促进医疗行业的信息化发展，提高医疗服务的质量和效率，推动医疗行业的可持续发展
1.2需求分析 医院数据库管理系统涉及到很多方面的内容，这主要是因为来自医院所需管理的内容十分庞大。根据政策调整，也对数据库的相关需求做出了对应的调整。
与一般的医院数据库管理系统相比，根据调研增加了一些功能。首先增加了基金会对患者的资助功能。一个基金会可以资助多名患者，一名患者也可以接受多个基金会的资助。还有医院的转运功能，由于医院的擅长领域不同，面临着转院的需求，一个患者可能面临着多次转院。除此以外，医院手术众多，一个医生会做多台手术，一名患者也可能接受多台手术，一间手术室也会进行不同的手术。
医院除了医生和护士之外还有护工这一职业，但是护工与医生护士有着不同的属性，并且一名护工可以护理多名患者，一名患者也可以由名护工进行护理。这些不同的具体需求都将影响着数据库的设计。
本课程设计模拟一般医院的信息管理情况，方便对医院信息的查询。本系统主要要求为：
能够全面的管理各种信息
本系统可以方便维护各种信息。
本系统能够方便查询各个信息表的基本信息。
能够方便实现多个信息表的连接查询、嵌套查询。
本系统能够实现有用信息的查询统计。
本系统能够实现有用信息的输出。
1.3 功能模块 1.3.1主要功能模块介绍 本管理系统主要对病人基本信息、科室基本信息、医生基本信息、病房基本信息、护士基本信息、护工基本信息、大楼基本信息、手术室基本信息、基金会基本信息、护士的分配情况等进行管理。
1.3.2主要功能模块图 功能模块图
1.4数据流程图 数据流程图1
数据流程图2
1.5数据字典 1.患者
2.护士
3.手术室
4.处方
5.休息室
6.科室
7.转运
8.探视
9.病房
10.查房
11.护工
12.手术
13.药品
14.器械
15.资助
16.家属
17.医生
18.基金会
19.病历
20.看护
21.大楼
1.6 E-R图 1.6.1局部E-R图 1.6.2全局E-R图 带属性E-R图
由于实体集较多以致带属性的E-R图不太清楚，所以将属性去掉制作了简化的E-R图。如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a75178cbcba3efcfd3b42b62410cb737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a2605aa7895a1fcc549bb9b9de02b8/" rel="bookmark">
			mysql 存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql存储过程：事先经过编译并且存储在数据库中的一段SQL语句集合。调用存储过程可以减少数据库和应用程序间传输的网络性能消耗
目录
1、创建存储过程和调用
1.1、无参存储过程
1.2、有参存储过程
1.3、mysql变量
1.3.1、系统变量
1.3.2、用户自定义变量
1.3.3、局部变量
2、存储过程中条件判断 if 的使用
3、存储过程中case的使用
4、存储过程中循环的使用
4.1、while 循环
4.2、repeat 循环
4.3、loop 循环
5、存储过程-游标 CURSOR
1、创建存储过程和调用 创建存储过程语句
CREATE PROCEDURE 存储过程名称([参数])
BEGIN
内容
END;
调用存储过程使用CALL
调用存储过程语句
CALL 存储过程名称([参数])
1.1、无参存储过程 示例
创建无参存储过程，查看数据库版本
CREATE PROCEDURE p_version() BEGIN SELECT VERSION(); END; 注意：笔者这里使用的是 navicat 和 mysql5.7.25 版本，如果读者使用的是 mysql 命令行客户端，需要使用 DELIMITER $$ 定义结束符，因为上边语句中的 "；" 会被mysql 命令行客户端识别为结束符，因此在有"；"的函数体中，需要读者额外定义结束符，如下面代码
DELIMITER $$ CREATE PROCEDURE p_version() BEGIN SELECT VERSION(); END $$ 后面的代码笔者都是直接在navicat上执行，因此不再重复说明 DELIMITER $$ 定义结束符的事
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a2605aa7895a1fcc549bb9b9de02b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e06f5633e7eda42df3ecbae481ff9f/" rel="bookmark">
			超详细Hadoop安装教程（单机版、伪分布式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超详细Hadoop安装教程（单机版、伪分布式） 1.Hadoop分布式系统基础架构介绍1.1.Hadoop核心 2.Hadoop安装教程2.1.环境准备2.2.配置用户ssh 免密登录2.3.JAVA环境的安装和配置2.4.Hadoop安装2.5.单机版Hadoop配置2.6.伪分布式Hadoop配置2.7Hadoop初始化 1.Hadoop分布式系统基础架构介绍 Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。
1.1.Hadoop核心 Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算 。
2.Hadoop安装教程 2.1.环境准备 此次我们选择的是通过在VMware虚拟机上面进行Hadoop的安装和配置，需要准备的东西如下：
系统环境：Ubtun20.04
JAVA jdk：jdk-8u11-linux-x64.tar
Hadoop：hadoop-2.7.1.tar
上面所需的环境准备，我已经打包整理好全部放在了网盘，有需要的同学可以自行下载
下载链接: 环境准备.提取码:phmr
2.2.配置用户ssh 免密登录 集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令）
Ubuntu 默认已安装了 SSH client，我们还需要安装 SSH server，才可以实现ssh免密登录利用 ssh-keygen 生成密钥，并将密钥加入到授权中，让用户实现免密登录
//Linux命令---安装SSH server sudo apt-get install openssh-server 安装完成后，可以通过下面的命令来进行SSH登录
//Linux命令---SSH登录 ssh localhost 输入后有如下提示，我们输入yes，在输入用户的密码，就可以实现登录了
但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便，所以我们需要执行以下代码，来实现SSH免密登录：
//Linux命令---实现SSH免密登录 exit # 退出前面的登录 cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 回车后，一直回车直到出现图形化界面 cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权 出现上面的图形化界面则表示我们的SSH已经配置成功了
做到这一步的小伙伴恭喜你，已经距离终点又近了一步！
2.3.JAVA环境的安装和配置 在配置JAVA环境之前
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e06f5633e7eda42df3ecbae481ff9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36832d1cf6666caec9f331921ca08e1a/" rel="bookmark">
			解决达梦（DM）数据库报错：无法解析的成员访问表达式[IF]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 前些时负责公司国产化项目数据库迁移工作。将MySQL迁移到DM后，执行原sql报错，有不少函数和关键字不兼容问题。"IF"是其中之一。
原SQL语句 SELECT IF(a.CC LIKE '自助%', a.BB, NULL) AS ZZ FROM ACC a WHERE 1 = 1; 报错信息 原因分析 后来将IF参数NULL改为字段值或实参，并且得保证两个结果参数必须同为字段值或实参，SQL语句即可执行成功。
但显然这满足不了需求，于是想到了CASE WHEN THEN语句，试了试能用。
解决方式 使用CASE WHEN THEN语句
SELECT (CASE WHEN a.CC LIKE '自助%' THEN a.BB ELSE NULL END) AS ZZ FROM ACC a WHERE 1 = 1; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fadae30ab484f56469bd05ad165681/" rel="bookmark">
			Redis实现分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着时代的发展，分布式系统的运用越来越多，而在分布式系统中，本地锁已经无法解决数据安全问题，分布式锁能够很好的解决这个问题.
一、分布式锁是什么？ 在分布式系统中，由于多个节点同时访问一个资源，可能会出现脏数据、数据冲突等问题，分布式锁通过加锁、解锁的方式，保证在同一时刻只有一个节点能够访问该资源，从而避免了数据冲突和错误操作。分布式锁的实现方式有很多种，常见的包括基于Redis、Zookeeper、数据库等分布式系统的实现方式。这里主要介绍Redis的方式
二、本地锁示例 1.本地锁代码示例：
//controller层 @GetMapping("/testLock") public Result testLock(){ testService.testLock1(); return Result.ok(); } //service层 public synchronized void testLock1(){ String num = redisTemplate.opsForValue().get("num").toString(); if (!StringUtils.isEmpty(num)){ int i = Integer.parseInt(num); redisTemplate.opsForValue().set("num",String.valueOf(++i)); } } 2.开启两个相同的服务 模拟分布式（代码一致，端口号不一致）开启网关作为统一访问路径
进行负载均衡
3.利用ab进行网关压力测试
4.拿到redis中num的值
从上述实验可以发现：我们进行了1000次请求发送给网关，而num最终的值等于613，而不是我们想要看到的1000，因此可以发现，在分布式系统里，本地锁无法解决数据安全问题，这主要是由于分布式系统中存在多个节点，每个节点拥有自己的本地资源和本地锁。当多个请求同时访问同一份数据时，就会出现数据的并发访问和修改，而本地锁只能控制本地的并发访问，无法控制分布式系统中其他节点的并发访问
三、分布式锁的使用 1.前言：因为分布式集群系统微服务多分布在不同的机器上，这使得原来单机部署下的并发控制锁失效，单纯的javaAPI无法实现分布式锁，因此我们需要一种可以跨JVM的方式来控制共享数据的访问
可以利用Redis中的setnx操作来实现分布式锁
2.setnx有如下优点
2.1.setnx是一个原子性操作，只有一个客户端设置键值能成功，其他客户端再来设置，均会失效
2.2.在分布式环境下可以把setnx这个操作当作锁，如果一个客户端已经获取到锁，那么它将会返回true，就可以往下执行业务逻辑，在这个时候其他客户端又想来获取这把锁就会返回false
3.使用步骤
3.1.导入依赖 写配置文件
&lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring2.X集成redis所需common-pool2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; spring: redis: host: 192.168.72.166 port: 6379 database: 0 timeout: 1800000 password: lettuce: pool: max-active: 20 #最大连接数 max-wait: -1 #最大阻塞等待时间(负数表示没限制) max-idle: 5 #最大空闲 min-idle: 0 #最小空闲 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39fadae30ab484f56469bd05ad165681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1029e3884be229d8f517ed8944edf90/" rel="bookmark">
			【Python入门系列】第八篇：Python中GUI编程和图形界面设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Tkinter、PyQt和wxPython库简单使用1、Tkinter简单使用2、PyQt简单使用3、wxPython简单使用 二、Tkinter、PyQt和wxPython库实现计算器1、Tkinter实现计算器2、PyQt实现计算器3、wxPython实现计算器 三、Tkinter、PyQt和wxPython库简单QQ聊天1、Tkinter实现QQ聊天2、PyQt实现QQ聊天3、wxPython实现QQ聊天 四、Tkinter、PyQt和wxPython库贪吃蛇游戏1、Tkinter实现贪吃蛇游戏2、PyQt实现贪吃蛇游戏 总结 前言 Python中的GUI编程是指使用Python语言创建图形用户界面（GUI）的过程。通过GUI，用户可以与程序进行交互，通过按钮、菜单、文本框等控件来操作程序。
Python提供了多个库和框架来实现GUI编程，其中最常用的是Tkinter、wxPython、PyQt和PyGTK等。这些库提供了丰富的控件和功能，使开发者能够轻松地创建各种类型的图形界面。
在GUI编程中，通常使用窗口（Window）作为程序的主要界面。可以在窗口中添加各种控件，如按钮、标签、文本框、复选框等，用于与用户进行交互。通过事件处理机制，可以对用户的操作进行响应，执行相应的函数或方法。
图形界面设计是指创建具有良好用户体验的界面。在设计过程中，需要考虑界面布局、颜色搭配、控件的摆放位置等因素，以确保用户能够方便地使用程序。
一、Tkinter、PyQt和wxPython库简单使用 1、Tkinter简单使用 Tkinter 是 Python 中常用的 GUI 编程库，用于创建图形用户界面。下面是 Tkinter 的简单使用说明：
导入 Tkinter 模块： import tkinter as tk 创建主窗口： root = tk.Tk() 添加控件：
可以添加各种控件，如标签、按钮、文本框等。例如，添加一个标签和一个按钮： label = tk.Label(root, text="Hello, Tkinter!") button = tk.Button(root, text="Click me!") 布局控件：
使用网格布局（grid）或包装布局（pack）来安排控件的位置。例如，使用网格布局将标签和按钮放置在窗口中： label.grid(row=0, column=0) button.grid(row=1, column=0) 运行主循环： root.mainloop() 完整代码：
import tkinter as tk # 创建主窗口 window = tk.Tk() window.title("GUI编程示例") # 创建标签 label = tk.Label(window, text="欢迎来到GUI编程！", font=("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1029e3884be229d8f517ed8944edf90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aadce827165a26ba702269e82fe59473/" rel="bookmark">
			基于Hadoop的MapReduce网站日志大数据分析（含预处理MapReduce程序、hdfs、flume、sqoop、hive、mysql、hbase组件、echarts）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要本项目的可以私信博主！！！
本项目包含：PPT，可视化代码，项目源码，配套Hadoop环境（解压可视化），shell脚本，MapReduce代码，文档以及相关说明教程，大数据集！
本文介绍了一种基于Hadoop的网站日志大数据分析方法。本项目首先将网站日志上传到HDFS分布式文件系统，然后使用MapReduce进行数据预处理。通过使用Hive进行大数据分析，我们能够对网站的PV、独立IP、用户注册数和跳出用户数等重要指标进行统计分析。最后，我们使用Sqoop将分析结果导出到MySQL数据库，并使用Python搭建可视化界面，以方便用户对分析结果进行更直观的理解。
通过使用Hadoop分布式计算框架，本项目可以高效地处理大量的网站日志数据。使用MapReduce进行预处理能够有效地减少数据量，并进行初步的数据清洗和筛选。在使用Hive进行大数据分析时，我们可以通过编写复杂的SQL查询语句，快速地获取需要的数据，并对这些数据进行深入的统计分析。
通过本项目，我们可以快速准确地获取网站的关键指标数据，帮助企业更好地了解用户行为，优化网站运营策略，提升用户体验。同时，本项目的数据导出和可视化功能也为用户提供了更方便、直观的数据展示方式，使得数据分析结果更易于理解和使用。
此处省略......
1.1 研究背景
随着互联网技术的发展，越来越多的企业将其业务转移到了线上。网站是企业展示自身品牌形象，提供产品或服务的重要平台，而网站日志是记录网站活动的重要数据源。
此处省略......
1.2 研究目的
本文旨在探讨基于Hadoop对网站日志进行大数据分析的研究目的。随着互联网的普及，网站的流量日益增大，大量的网站日志数据被生成。这些数据包含了大量的信息，可以帮助网站管理者了解用户的行为和需求，为网站的优化和改进提供有价值的参考。
此处省略......
1.3 研究意义
本文旨在探讨基于Hadoop对网站日志进行大数据分析的研究意义。随着互联网的不断发展，越来越多的网站日志数据被生成，这些数据包含了大量的信息，可以为网站的优化和改进提供有价值的参考。因此，本文研究的意义在于：
此处省略......
1.4 国内外研究现状分析
随着大数据时代的到来，越来越多的企业开始关注如何利用大数据进行网站日志分析，以从中获得商业价值。而Hadoop作为一种分布式计算框架，可以用于对大规模数据进行处理和分析。本文将对基于Hadoop对网站日志进行大数据分析的国内外研究现状进行分析。
一、国内研究现状：
此处省略......
二、国外研究现状：
此处省略......
2 研究过程
2.1 总体研究路线
本文基于Hadoop对网站日志大数据集进行离线分析，最初首先必须要搭建一个Hadoop分布式系统，安装好本研究所需要的各类组件。在部署好Hadoop之后，首先将日志数据上传到hdfs分布式文件系统上，采用MapReduce的思想，利用Python编写Map和Reduce脚本程序，对原始数据进行清洗。
将网站日志数据清洗为结构化的数据之后，然后保存在hdfs中，之后在hive里面进行建表和数据导入操作，借助大数据分析组件hive对其进行统计学分析，挖掘出常用的一些业务指标，其次利用Hadoop中的sqoop组件将hive中的分析结果表导入到mysql中，或者将结果存入到hbase中。最终通过Python的Pyecharts的可视化库对其进行可视化，在web页面展示出统计出来的业务指标。
图1.1 总体研究路线图
如下图所示，通过这样一系列的操作和流程，可以将大数据分析展现到决策者的眼前。
图1.2 技术开发流程图
2.2 搭建Hadoop环境系统
本研究通过搭建Hadoop伪分布式系统，对其进行大数据分析。可以学习Hadoop的基本原理和架构，对Hadoop的运行机制有更深入的了解。能够在单机上模拟多节点的分布式环境，可以更好地测试和开发分布式应用程序。可以充分利用自己的计算资源，提高数据处理效率。
2.2.1 Hadoop部署及各类组件安装
由于Hadoop的部署和安装各类组件比较繁琐，这里就不作具体的详细的安装部署描述了。本研究通过前期花费时间对其进行各类组件安装，并将其结果图展示如下所示：
图2.1 Hadoop安装展示
图2.2 Hadoop集群启动及hive安装展示
Hadoop中的各类结点特点及解释如下：
（1）NameNode它是Hadoop中的主服务器，管理文件系统名称空间和对集群中存储的文件的访问。
（2）Secondary NameNode是一个用来监控HDFS状态的辅助后台程序。
（3）DataNode它负责管理连接到节点的存储（一个集群中可以有多个节点）。每个存储数据的节点运行一个 datanode守护进程。
（4）NodeManager：YARN中每个节点上的代理，它管理Hadoop集群中单个计算节点，包括与ResourceManger保持通信，监督Container的生命周期管理，监控每个Container的资源使用（内存、CPU等）情况，追踪节点健康状况，管理日志和不同应用程序用到的附属服务（auxiliary service）。
（5）ResourceManager：在YARN中，ResourceManager负责集群中所有资源的统一管理和分配，它接收来自各个节点（NodeManager）的资源汇报信息，并把这些信息按照一定的策略分配给各个应用程序（实际上是ApplicationManager）RM与每个节点的NodeManagers (NMs)和每个应用的ApplicationMasters (AMs)一起工作。
图2.3 mysql及sqoop安装展示
Hadoop是一个分布式计算框架，可以存储和处理大规模数据集。Sqoop和MySQL是两个常用于Hadoop生态系统中的组件。
Sqoop是一个用于将关系型数据库中的数据导入到Hadoop生态系统中的工具。它支持多种关系型数据库（如MySQL、Oracle、PostgreSQL等），可以将关系型数据库中的数据转换为Hadoop生态系统中的数据格式（如HDFS、Hive、HBase等）。Sqoop还支持增量导入和导出，以及自定义导入查询。
MySQL是一种开源的关系型数据库管理系统，被广泛应用于Web应用程序的开发。在Hadoop生态系统中，MySQL通常用于存储与Hadoop数据相关的元数据和其他信息。MySQL可以通过Hadoop的MapReduce作业来查询和处理数据，也可以与Sqoop一起使用，将关系型数据导入到Hadoop生态系统中。
上述就已经对本次研究所需要的基本组件完成了安装和部署，旨在为后续的研究过程准备良好的环境基础。
2.3 数据集介绍
本次研究的数据日志来源于国内某技术学习论坛，该论坛由某培训机构主办，汇聚了众多技术学习者，每天都有人发帖、回帖。通过获取开源的数据集日志，其中包括2013-05-30和2013-05-31这两天的网站日志数据，其中每行记录有5部分组成：访问者IP、访问时间、访问资源、访问状态（HTTP状态码）、本次访问流量。
图3.1 日志数据展示
该数据字段具有不规则的特点，基于Hadoop大数据分析hive进行结构化统计分析，需要进一步对数据进行预处理，由于本数据量非常大，从数据的容量来看两天的日志文件大小一共是200MB，30号的数据量约是55W左右，31号的数据量是140W左右，总数据量约接近200W的数据，从大数据的角度来看，已经符合了大数据模拟分析的要求，传统的分析软件对其进行处理已经达不到高效率的特点了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aadce827165a26ba702269e82fe59473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9e4b82e5806e81e527ae2c5eb864bc/" rel="bookmark">
			WPS Office AI实战：一键生成PPT幻灯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天WPS Office AI放出来内测申请，相信不少小伙伴都拿到了体验资格，不知道体验到国产AI的魅力没有？作为写作中的重头戏，一张PPT的制作让不少小伙伴面露难色，单排版布局这一项就足以让人望而却步。 AI 在写作中的应用，大大减轻了大家这方面的痛苦，节省出很多时间。由AI 提供提供专业外观，进行自动化内容创作，同时提供灵感和创意，使用AI生成 PPT 可以提高演示文稿制作的效率和质量，为你节省时间和精力，再稍加人工审核和编辑，基本上就达标了。
使用WPS AI前准备 https://ai.wps.cn/ 官方网站
按以下步骤进行使用WPS Office AI前的准备工作：
拿到WPS Office AI 内测体验资格（还没有拿到的小伙伴，公众号回复 WPSAI 即可获取内测申请地址）
到官网下载安装支持 WPS Office AI的 WPS客户端，目前支持Windows、Android、iOS以及网页版几种渠道（本例以Windows系统为例）
安装完成后，打开WPS Office，登陆自己的账号（前面申请过AI的账号），AI就位，下一步就可以进行我们的AI创作之旅行
AI 创作 PPT 可以清晰的看到【智能创作】选项，以及顶部的【WPS AI】按钮，这两种迹像表明已经可以AI进行生成PPT了。
目前提供了三大块的 AI 辅助写作功能：
智能创作，一键生成演示文稿、单页，进行文字的扩写改写
排版美化，快速更改文稿主题、配色、字体等
快速生成演讲备注，助力轻松表达
一键生成 PPT 点击顶部的【WPS AI】按钮，右侧出现AI对话框，鼠标点击后，可以看到目前预置好的一些常见功能点。
下面我们进行一键生成幻灯片创作，操作过程也比较简单：1、点击对话框，选中【一键生成幻灯片】按钮2、在后面的输入区填写我们要生成PPT的主题，相当于我们生成 PPT的提示语：越详细越精确越好3、填写完提示语，点击发送按钮，可以看到AI开始工作。4、生成完成后，可以看到PPT大纲已经罗列出来，下面3个按钮，我们选择【生成完整幻灯片】按钮，（生成框架：只有PPT的框架，内容缺少；取消：取消此次操作）5、AI推荐适合的主题，开始生成并配置PPT，同时提供了主题供选择。6、看看最终的生成效果，生成了19页的PPT文稿。
调整配色方案 如果想调整 PPT 整体的配色方案，同样可以在 AI 对话框区域，找到【更换配色方案】的功能：
输入提示语：换一套科技感很足的主题颜色
选择一套颜色方案，应用后就可以看到所有的演示文稿主题颜色变成相应的方案。
变换主题 觉得主题不合适，生成后还可以进行变更主题操作。
输入提示语：更换一个科技感十足的风格主题
系统提供一系列文案供你选择，选择一个主题后，点击【应用】挖掘，新主题全部会应用到所有页面中去，如果是原始手动调整的话，一个19页的PPT，不花费1小时估计搞不定。
生成演讲备注 演讲备注是演讲者进行讲述时辅助手段，如果你对着PPT也不知道怎么讲，演进备注就是绝佳的搭档，提前生成好，对着念就可以。
在AI对话框，直接选择【生成全文演讲备注】，AI就会自动给每个页演示文稿，生成演讲备注。演讲备注位于幻灯片的备注区域，PPT播放时并不会出现。
扩写与改写 扩写：基于原有文字，进行更多内容编写。改写：基于原有文字，进行文字替换。在特定场景下会有需求。
增加单页 PPT生成后，如果觉得缺少部分内容，可以选中一页文稿，在对话框区域选择【创作单页】，输入提示语即可。依据上页的提示语，AI进行创作，创造完成后生成新的单页，插入到选中页数的下面。【本示例单页是没问题，不过内容是错误的。WPS AI 背后的技术支撑是MiniMax公司，在国内比较低调。】
以上示例都是典型 PPT 生成操作，使用频率比较高，还有一些功能等待大家在实际应用中发掘使用，比如更改字体、更换背景图片、更换插图等等，很多操作都可以交给AI来做，解放自己的时间，我们把时间花在更美好的事情上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c9e4b82e5806e81e527ae2c5eb864bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75475f514959b87f865c7f78616b76d5/" rel="bookmark">
			算法总结-深度优先遍历和广度优先遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度优先遍历(Depth First Search，简称DFS) 与广度优先遍历(Breath First Search，简称BFS)是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路(走迷宫)，搜索引擎，爬虫等。
一、深度优先遍历
深度优先遍历的思路是从图的一个未访问的顶点V开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底，不断递归重复此过程…直到所有的顶点都遍历完成。它的特点说通俗了就是不撞南墙不回头，走完了一条路，再换一条路继续走。
树是图的一种特例（ 联通无环的图就是树），接下来我们来看树用深度优先遍历该怎么遍历。
1、深度优先遍历过程
（1）、我们从根节点1开始深度优先遍历，它相邻的节点有2、3、4，依先遍历节点2，再遍历2的右边节点5，再遍历9，至此便无可遍历的节点。
（2）、上图中一条路径已经遍历到底，此时从叶子节点9回退到上一节点5，，看下节点 5 是否还有除 9 以外的节点，没有继续回退到 2，2 也没有除 5 以外的节点，回退到 1，1 有除 2 以外的节点 3，所以从节点 3 开始进行深度优先遍历，如下：
（3）、同理从 10 开始往上回溯到 6, 6 没有除 10 以外的子节点，再往上回溯，发现3有除 6 以外的子节点 7，所以此时会遍历 7。
（4）、从 7 往上回溯到 3， 1，发现 1 还有节点 4 未遍历，所以此时沿着 4， 8 进行遍历，这样就完成了整个遍历过程。
完整的节点的遍历顺序如下(节点上的的蓝色数字代表)：
相信大家看到以上的遍历不难发现这就是树的前序遍历，实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。
那么深度优先遍历该怎么实现呢，有递归和非递归两种表现形式，接下来我们以二叉树为例来看下如何分别用递归和非递归来实现深度优先遍历。
2、深度优先遍历实现
（1）、递归
递归实现比较简单，由于是前序遍历，所以我们依次遍历当前节点，左节点，右节点即可，对于左右节点来说，依次遍历它们的左右节点即可，依此不断递归下去，直到叶节点(递归终止条件)，代码如下：
public class Solution { private static class Node { public int value; // 节点值 public Node left; // 左节点 public Node right; // 右节点 public Node(int value, Node left, Node right) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75475f514959b87f865c7f78616b76d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cf20d751ec2bc8ca1c7a5b559907e08/" rel="bookmark">
			【海量数据挖掘/数据分析】 之 关联规则挖掘 Apriori 算法 （数据集、事务、频繁项集、关联规则、支持度、置信度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【海量数据挖掘/数据分析】 之 关联规则挖掘 Apriori 算法 （数据集、事务、频繁项集、关联规则、支持度、置信度） 目录
【海量数据挖掘/数据分析】 之 关联规则挖掘 Apriori 算法 （数据集、事务、频繁项集、关联规则、支持度、置信度）
一、 关联规则挖掘简介
二、 数据集 与 事务 ( Transaction ) 概念
三、项 ( Item ) 概念
四、项集 ( Item Set ) 概念
五、频繁项集
六、数据集、事物、项、项集合、项集 示例
七、关联规则 是指 :
八、 数据项支持度
九、关联规则支持度
十、置信度
十一、 频繁项集
十二、 非频繁项集
十三、 强关联规则
十四、 弱关联规则
十五、 发现关联规则
十六、 非频繁项集超集性质
十七、 频繁项集子集性质
十八、 项集与超集支持度性质
十九、 Apriori 算法过程
二十、 Apriori 算法示例 求 频繁项集
二十一、使用 Apriori 算法，求 频繁项集 和 关联规则
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cf20d751ec2bc8ca1c7a5b559907e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9598dddf619a6895ce0c4ba21e9aecc/" rel="bookmark">
			springboot&#43;echarts &#43;mysql制作数据可视化大屏（四图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者水平低，如有错误，恳请指正！谢谢！！！！！
项目简单，适合大学生参考
分类专栏还有其它的可视化博客哦！
专栏地址：https://blog.csdn.net/qq_55906442/category_11906804.html?spm=1001.2014.3001.5482
成果展示：
一、数据源 1）可以使用自己的MySQL数据库；
2）使用我提供的数据。（要数据私信/留言——&gt;留下邮箱即可）
二、所需工具 MySQL、IDEA、jdk1.8、Maven等等，总之编写工具要准备好，环境要搭建好
三、项目框架搭建 参考我博客的项目框架搭建，从3.1看到4.3即可springboot+mybatis+echarts +mysql制作数据可视化大屏_spring + 可视化大屏_一个人的牛牛的博客-CSDN博客
四、代码编写 代码简单，后端代码都写在一起了，没有区分controller等等，前端也是一样，没有单独写js等等。
4.1 区域销量统计条形图 4.1.1 后端
import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController public class Big1 { private final JdbcTemplate jdbcTemplate; @Autowired public Big1(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @GetMapping("/chart-data") public Map&lt;String, Object&gt; getChartData() { String query = "SELECT region_name, COUNT(*) AS count FROM ads_area_topic GROUP BY region_name"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9598dddf619a6895ce0c4ba21e9aecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f910bbc6779faf8aac893ef4e303b3af/" rel="bookmark">
			Android studio中文汉化详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android studio在之前实现中文汉化比较简单，只需要在Plugins中搜索chinese下载插件安装即可实现汉化，但是现在已经搜不到插件了，新的方法和之前的类似，只不过插件的获取方式改变了。
最新中文汉化教程 一、确认版本号 需要确认android studio软件版本，根据版本下载对应的中文汉化包，如果安装的汉化包版本不对应，可能会导致安装失败。
面板选择Help→About，在弹出框中查看当前版本号，我们只需要关心版本号前面的222即可。
二、下载汉化包 打开汉化包下载地址 ，根据刚才查看的版本号选择所对应的汉化包进行下载。
三、安装汉化包 下载完毕后，打开Settings
选择Plugins，在右侧面板选择 Install Plugin from Disk…
选择刚才下载的中文汉化包点击OK安装
安装完成点击Restart IDE重启软件，重启后汉化完毕
四、中英文切换 如果汉化后想要切换回英文，只需要进行几步简单操作
1.关闭汉化插件 在插件里面找到中文汉化包，将后面的对钩去掉，然后点击应用→确定
2.重启软件 弹出重启提示框选择重启，重启完毕后改为英文。用此方法可实现中英文切换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78008cbacaf0f3b4430342ce5a34ed1e/" rel="bookmark">
			随机采样一致性（RANSAC）三维点云的平面拟合算法（含C&#43;&#43;代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 随机采样一致性（Random sample consensus，RANSAC）：RANSAC是一种鲁棒的模型拟合方法，它可以处理存在大量噪声和异常值的数据。在进行平面拟合时，RANSAC会随机选择三个点，然后计算这三个点确定的平面模型。然后，RANSAC会计算其他所有点到这个平面的距离，并根据一个预设的阈值来判断这些点是否符合这个平面模型。这个过程会重复多次，最后选择符合点最多的平面模型作为最终的结果。
原理 随机采样一致性（RANSAC）是一种迭代的模型估计方法，它的主要目标是从一组包含大量异常值的观测数据中估计出数学模型的参数。在进行平面拟合时，RANSAC的工作原理如下：
随机选择最小样本集：在进行平面拟合时，RANSAC首先会随机选择三个点作为最小样本集。这是因为在三维空间中，三个非共线的点可以确定一个平面。构建模型：然后，RANSAC会根据这三个点计算出一个平面模型。这个模型就是通过这三个点的平面。计算误差：接着，RANSAC会计算其他所有点到这个平面的距离，这个距离就是每个点的误差。确定内点：然后，RANSAC会根据一个预设的阈值来判断每个点是否为内点，也就是说，如果一个点的误差小于这个阈值，那么就认为这个点符合平面模型，将其标记为内点。更新模型：如果内点的数量超过了之前的最大内点数量，那么就用所有的内点来更新平面模型。迭代：以上的过程会重复多次。在每次迭代中，RANSAC都会随机选择一个新的最小样本集，然后构建模型，计算误差，确定内点，更新模型。这个过程会一直进行，直到达到预设的迭代次数。计算最佳模型：最后，RANSAC会选择内点数量最多的样本，再用这些内点进行求解最终的方程，作为最终的结果。通过这种方式，RANSAC可以有效地处理存在大量噪声和异常值的数据，从而得到鲁棒的模型估计结果。 C++代码 CMakeLists.txt
cmake_minimum_required(VERSION 2.8 FATAL_ERROR) project(ransac_example) find_package(PCL 1.8 REQUIRED) include_directories(${PCL_INCLUDE_DIRS}) link_directories(${PCL_LIBRARY_DIRS}) add_definitions(${PCL_DEFINITIONS}) add_executable (ransac_example ransac_example.cpp) target_link_libraries (ransac_example ${PCL_LIBRARIES}) ransac_example.cpp
在这段代码中，我们首先读取一个PCD文件，并将数据存储到一个PointCloud对象中。然后，我们创建一个表示平面模型的SampleConsensusModelPlane对象，并使用RANSAC算法来估计模型。我们设置RANSAC算法的距离阈值为0.01，然后执行算法并获取平面模型的内点的索引。
#include &lt;pcl/ModelCoefficients.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/filters/extract_indices.h&gt; #include &lt;pcl/features/normal_3d.h&gt; #include &lt;pcl/sample_consensus/method_types.h&gt; #include &lt;pcl/sample_consensus/model_types.h&gt; #include &lt;pcl/segmentation/sac_segmentation.h&gt; #include &lt;pcl/sample_consensus/sac_model_plane.h&gt; #include &lt;pcl/sample_consensus/ransac.h&gt; // Add this line #include &lt;Eigen/Dense&gt; // Add this line int main(int argc, char** argv) { // 创建一个PointCloud对象，用于存储输入的点云数据 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); // 创建一个PCDReader对象，用于读取PCD文件 pcl::PCDReader reader; // 使用PCDReader对象读取PCD文件，并将数据存储到PointCloud对象中 reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78008cbacaf0f3b4430342ce5a34ed1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab29768572a491e759204e79fb4692d5/" rel="bookmark">
			2023年最新IDEA中 Java程序 | Java&#43;Kotlin混合开发的程序如何打包成jar包和exe文件(gradle版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章内容： 一. JAVA | JAVA和Kotlin混开开发的程序打包成jar方法
1.1 方法一 ：IDEA中手动打包
1.2 方法二 ：build.gradle中配置后编译时打包
二. JAVA | JAVA和Kotlin混合开发的程序打包成exe的方法
一. JAVA | JAVA和Kotlin混开开发的程序打包成jar方法 纯JAVA | 纯Kotlin | JAVA和Kotlin混合开发打包其实都一样的，因为jar包中主要还是class文件，而kotlin在编译后生成的也是class文件，因此不影响打包,因此以下打包jar方法适用于上述所有情况
1.1 方法一 ：IDEA中手动打包 步骤1：File --&gt; Project Structure 步骤二： 步骤三：按以下操作后点Ok 说明：
Module：这里选择要打包的模块，一般用gradle构建的项目可以选择ALL Moudules（我就是），也可以选择main模块，根据需要选择Main Class： 这里需要选中入口函数（也就是带有main方法的函数）
JAR Files From librarys：这里选中第一个（extract to the target JAR — 表示把额外用到的jar包都打进我们想要打包的jar包，即打包完之后只有一个jar包） 如果选择第二个（copy to the output directory and link via manifest）则打包后会有多个jar包，如图是选择第二个打包
Directory for META-INF/MANIFESTMF: 这里不要选择IDEA默认是，而是要自定义（C盘 D盘任意） 否则在运行jar包时会报找不到主清单文件的错误 步骤四：操作完点击apply 再点击ok 步骤五：点击最上面的build --&gt; Build Artifacts 点击后会弹出以下窗口： 选择Build即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab29768572a491e759204e79fb4692d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65bc61f30c074f0fd8c3f2911c5d9075/" rel="bookmark">
			十大基础算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、选择排序 过程简单描述：
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为选择排序。
为方便理解我还准备了动图：
.
public class SelectionSort { public static void main(String[] args) { int[] arr = {5, 3, 6, 8, 1, 7, 9, 4, 2}; //定义内外两层循环，从最外层循环第一个值开始匹配，内层循环从外层循环加以开始向后匹配 //如果遇到小的值就进行交换 //外层循环到倒数第二为止，内层循环到倒数第一为止 for (int i = 0; i &lt; arr.length-1; i++) { int min = i; for (int j = i+1; j &lt; arr.length; j++) { if(arr[i]&gt;=arr[j]){ min = j; int temp = arr[i]; arr[i] = arr[min]; arr[j] = temp; } } } CommonUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65bc61f30c074f0fd8c3f2911c5d9075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e13a0ef90ea69c6fbb95e37f73aab8/" rel="bookmark">
			数据湖Iceberg介绍和使用(集成Hive、SparkSQL、FlinkSQL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介概述作用特性数据存储、计算引擎插件化实时流批一体数据表演化（Table Evolution）模式演化（Schema Evolution）分区演化（Partition Evolution）列顺序演化（Sort Order Evolution）隐藏分区（Hidden Partition）镜像数据查询（Time Travel）支持事务（ACID）基于乐观锁的并发支持文件级数据剪裁 其他数据湖框架的对比 存储结构数据文件 data files表快照 Snapshot清单列表 Manifest list清单文件 Manifest file 与 Hive集成环境准备创建和管理 Catalog默认使用 HiveCatalog指定 Catalog 类型指定路径加载 基本操作创建表修改表插入表删除表 与 Spark SQL集成环境准备Spark 配置 CatalogHive CatalogHadoop Catalog SQL 操作创建表删除表修改表插入数据查询数据存储过程 DataFrame 操作环境准备读取表检查表写入表维护表 与 Flink SQL 集成环境准备创建和使用 Catalog语法说明Hive CatalogHadoop Catalog配置sql-client初始化文件 DDL 语句创建数据库创建表修改表删除表 插入语句INSERT INTOINSERT OVERWRITEUPSERT 查询语句Batch模式Streaming模式 与Flink集成的不足 与 Flink DataStream 集成环境准备读取数据常规Source写法FLIP-27 Source写法 写入数据合并小文件 简介 概述 为了解决数据存储和计算引擎之间的适配的问题，Netflix开发了Iceberg，2018年11月16日进入Apache孵化器，2020 年5月19日从孵化器毕业，成为Apache的顶级项目。
Iceberg是一个面向海量数据分析场景的开放表格式（Table Format）。表格式（Table Format）可以理解为元数据以及数据文件的一种组织方式，处于计算框架（Flink，Spark…）之下，数据文件之上。
作用 大数据领域发展至今已经经历了相当长时间的发展和探索，虽然大数据技术的出现和迭代降低了用户处理海量数据的门槛，但是有一个问题不能忽视，数据格式对不同引擎适配的对接。
也就是说我们在使用不同的引擎进行计算时，需要将数据根据引擎进行适配。这是相当棘手的问题。
为此出现了一种新的解决方案：介于上层计算引擎和底层存储格式之间的一个中间层。这个中间层不是数据存储的方式，只是定义了数据的元数据组织方式，并且向引擎层面提供统一的类似传统数据库中"表"的语义。它的底层仍然是Parquet、ORC等存储格式。基于此，Netflix开发了Iceberg，目前已经是Apache的顶级项目。
特性 数据存储、计算引擎插件化 Iceberg提供一个开放通用的表格式（Table Format）实现方案，不和特定的数据存储、计算引擎绑定。目前大数据领域的常见数据存储（HDFS、S3…），计算引擎（Flink、Spark…）都可以接入Iceberg。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e13a0ef90ea69c6fbb95e37f73aab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb230e6d7d0a1e2a9a0c555e9c6b7cd4/" rel="bookmark">
			开发Android原生插件，引入自己打的jar报，编译报 Unsupported class file major version 61
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Unsupported class file major version 61” 错误的原因是由于你自己大的jar包当时是用的Java 17打包的，因为在 Java 中，每个主要版本都有一个对应的 major version 值。例如，Java 8 的 major version 值为 52，Java 9 的 major version 值为 53，以此类推。Java 17 的 major version 值为 61。
解决这个问题，可以修改Android Studio的Java编译器版本 android { compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 // 使用适当的版本，例如 Java 8 或 Java 11 targetCompatibility JavaVersion.VERSION_1_8 } } 注意：如果你的项目需要使用 Java 17 特性，那么你需要升级你的 Java 运行时环境和 Android Gradle 插件，以及确认你的 Android Studio 支持 Java 17。 第二种方法 切换Java 8 重新打包你的哪个jar，然后再引入到Android Studio 因为我的Android Studio使用的Java编译器版本是1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb230e6d7d0a1e2a9a0c555e9c6b7cd4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/598/">«</a>
	<span class="pagination__item pagination__item--current">599/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/600/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>