<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e72750da74b7af127affda3fa1aede3/" rel="bookmark">
			【面试干货】Java中==和equals()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【面试干货】Java中==和equals（）的区别 1、==操作符2、equals()方法3、总结 💖The Begin💖点点关注，收藏不迷路💖 在Java中，==和equals()是两个常用的比较操作符和方法，但它们之间的用法和含义却有着本质的区别。本文将详细解释这两个操作符/方法之间的区别。
1、==操作符 ==操作符 在Java中 主要用于比较两个变量的值是否相等。但是，这个“值”的含义取决于变量的类型：
1、于基本数据类型（如int, char, boolean等）：== 比较的是两个变量的值是否相等。
2、对于引用类型（如对象、数组等）：== 比较的是两个引用是否指向内存中的同一个对象（即地址是否相同）。
示例：
int a = 5; int b = 5; System.out.println(a == b); // 输出true，因为a和b的值相等 Integer c = new Integer(5); Integer d = new Integer(5); System.out.println(c == d); // 输出false，因为c和d指向的是不同的对象 2、equals()方法 equals()方法是Java Object 类的一个方法，用于比较两个对象的内容是否相等。
需要注意的是，默认的 equals() 方法 实现其实就是 == 操作符对于引用类型的比较，即比较的是两个引用是否指向同一个对象。
但是，很多Java类（如String, Integer等）都重写了 equals() 方法，以提供基于内容的比较。
示例：
String str1 = new String("hello"); String str2 = new String("hello"); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e72750da74b7af127affda3fa1aede3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5850cc302de4d50983cc7ee3109e94b/" rel="bookmark">
			elasticsearch 聚合 : 指标聚合、桶聚合、管道聚合解析使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 目录 一、聚合查询概述二、聚合查询类型Metric Aggregations（指标聚合）Bucket Aggregations（桶聚合）Pipeline Aggregations（管道聚合） 三、聚合查询应用四、doc_values 与 fielddataexact value字段分词字段doc_values与fielddata的性能权衡Doc ValuesFielddata 五、multi-fields（多字段）六、聚合查询示例Terms 分桶聚合Date Histogram 直方图聚合Range 范围聚合Nested 嵌套聚合Pipeline 管道聚合Derivative（导数聚合）Cumulative Sum（累计和聚合）Moving Average（移动平均聚合）Bucket Script（桶脚本聚合）Filters 过滤器聚合 七、聚合排序八、优化建议 一、聚合查询概述 Elasticsearch中的聚合查询是一种功能强大的数据分析工具，它能够提供从索引中提取和计算有关数据的复杂统计信息的能力。聚合查询不仅可以帮助用户理解和分析数据中的趋势和模式，还能在业务决策中发挥关键作用。聚合查询支持多种类型，包括指标聚合、桶聚合和管道聚合，每一种都有其特定的应用场景和使用方法。
二、聚合查询类型 Metric Aggregations（指标聚合） 概述：指标聚合返回基于字段值的度量结果，如总和、平均值、最小值、最大值等。这些度量结果可以直接用于分析数据中的特定指标。
常用类型：
Sum：计算字段的总和。
Avg：计算字段的平均值。
Min/Max：查找字段的最小值和最大值。
Stats：提供包括count、sum、min、max和avg在内的多种统计信息。
应用场景举例：销售数据的总销售额和平均订单金额分析、用户行为的平均访问时长和最大访问深度分析等。
Bucket Aggregations（桶聚合） 概述：桶聚合类似于SQL中的GROUP BY操作，它将文档分组到不同的桶中，并对每个桶中的文档进行聚合计算。桶聚合可以基于字段值、时间间隔或数值范围进行分组。
常用类型：
Terms：根据字段的值将文档分配到不同的桶中，常用于分析文本字段的不同取值及其分布情况。
Date Histogram：根据日期字段的值，将文档按时间间隔（如天、周、月等）分组到桶中，适用于时间序列数据的分析。
Range：根据定义的范围将文档分配到不同的桶中，适用于分析数值字段在特定范围内的文档数量。
应用场景举例：按作者分组的博客文章数量统计、按月份统计的销售记录分析、按价格区间统计的产品数量等。
Pipeline Aggregations（管道聚合） 概述：管道聚合以其他聚合的结果作为输入，并对其进行进一步的处理或计算。这种聚合类型允许用户对聚合结果进行复杂的转换和分析。
常用类型：
Avg Bucket：计算每个桶的平均值，通常用于对分组数据进行平均值分析。
Sum Bucket：计算每个桶的总和，适用于对分组数据进行求和操作。
Max/Min Bucket：找出所有桶中的最大值或最小值，有助于识别分组数据中的极端情况。
应用场景举例：在按月份统计的销售记录中找出平均销售额最高的月份、分析不同价格区间产品的销售额总和等。
三、聚合查询应用 与查询语句结合：聚合查询通常与查询语句结合使用，可以在满足特定条件的文档集合上进行聚合操作。通过查询语句过滤出符合条件的文档集合，然后对这些文档进行聚合分析，可以得到更加准确和有用的结果。嵌套聚合：Elasticsearch支持嵌套聚合，即在一个聚合内部可以包含其他聚合。通过嵌套聚合，用户可以构建复杂的查询和分析逻辑，满足各种复杂的数据分析和统计需求。 四、doc_values 与 fielddata 在 Elasticsearch 中，聚合操作主要依赖于 doc_values 或 fielddata 来进行。用于聚合的字段可以是精确值字段（如keyword类型）或分词字段（如text类型）。这两类字段在聚合查询时的处理方式有所不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5850cc302de4d50983cc7ee3109e94b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832596c474759b06bb40d9b09378aed8/" rel="bookmark">
			NPM 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NPM 常用命令 NPM（Node Package Manager）是 JavaScript 生态系统中最流行的包管理工具，它不仅可以管理 Node.js 项目的依赖，还提供了丰富的命令来管理和发布你的代码。本文将从不同角度，深入浅出地介绍 NPM 的常用命令和实际应用。
目录 NPM 基础 什么是 NPM安装 NPM初始化项目 (npm init) 管理依赖 安装依赖 (npm install)升级和卸载依赖 (npm update, npm uninstall)保存依赖 (--save, --save-dev) 运行脚本 定义脚本 (scripts 字段)运行脚本 (npm run)常见脚本示例 包管理 发布包 (npm publish)版本控制 (npm version)标记和发布标签 (npm tag) 配置和调试 配置 NPM (npm config)查看和设置参数 (npm get, npm set)调试 NPM (npm audit, npm cache) 1. NPM 基础 什么是 NPM NPM 是 Node.js 的包管理工具和默认的包管理器，它用于管理 JavaScript 代码包。NPM 仓库是全球最大的开源库，包含了数百万个 JavaScript 包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/832596c474759b06bb40d9b09378aed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca66d3654e472099e42f319f915c822c/" rel="bookmark">
			RabbitMQ实践——超时消息的处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 准备工作整个队列的消息都有相同的时效性抛弃超时消息新建带x-message-ttl的队列新建绑定关系实验 超时消息路由到死信队列新建带死信和ttl的队列新建绑定关系实验 消息指定自己的超时时间新建带死信的队列绑定实验 消息自带TTL和队列TTL的关系消息TTL &lt; 队列指定TTL消息TTL &gt; 队列指定TTL总结 代码工程 在项目中，我们往往会遇到消息具有时效性：在一定时间内的消息需要处理，其他消息则不用处理。RabbitMQ提供了两种功能来满足这种需求：
整个队列的消息都有相同的时效性。消息可以指定自己的超时时间。 对于超时的消息，我们可以选择抛弃，或者让其进入死信。本文我们将实验这些场景。
准备工作 我们先新建一个交换器direct.ttl。后续不同场景我们再设定其不同路由。
然后再创建一个死信队列queue.dead.letter
最后新建交换器direct.ttl和队列queue.dead.letter的路由绑定关系
后续我们将根据不同场景新建不同的队列和绑定关系。
整个队列的消息都有相同的时效性 抛弃超时消息 新建带x-message-ttl的队列 如果队列设置了x-message-ttl，则其全部消息的最大ttl就是其值。它的单位是毫秒。下图中，队列消息如果30秒没有处理，就会从队列中移除。
新建绑定关系 我们让交换器中Routing key是to.queue.all.message.ttl的消息路由到上面创建的队列中。
实验 向该交换器发送一条消息
消息出现在队列queue.all.message.ttl中。
半分钟后，该条消息从队列中消失。
超时消息路由到死信队列 不同于上例，只是设置了x-message-ttl，还要设置死信相关参数。本例我们将使用“重写Routing key”的方案，节省一次交换器的创建。
新建带死信和ttl的队列 新建名字是queue.all.msg.ttl.dead.letter的队列。这个队列中的所有消息的最大超时时间（x-message-ttl）是30秒；超时消息会被修改Routing key为to.queue.dead.letter后，使用direct.ttl交换器来路由。
新建绑定关系 将这个队列和之前新建的交换器direct.ttl关联。
实验 可以看到消息在过了30秒后，被从原来的队列queue.all.msg.ttl.dead.letter中移除，然后路由到死信队列queue.dead.letter中。
消息指定自己的超时时间 本例我们只实验相对复杂的场景，即将超时消息路由到死信。
新建带死信的队列 这个队列我们没有设置ttl相关数据，只是设置了死信相关配置：死信消息交由交换器direct.ttl处理，其Routing key被修改成to.queue.dead.letter。
绑定 实验 这次我们不能使用后台来发送消息，而是通过Java代码来发送。
public void sendWithTTL(String exchangeName, String routingKey, String message, int ttl) { String msgId = UUID.randomUUID().toString(); Message msg = MessageBuilder.withBody(message.getBytes()) .setContentType("text/plain") .setCorrelationId(msgId) .setMessageId(msgId) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca66d3654e472099e42f319f915c822c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f13f1ee49d72452aafd46aa70e9f0d6/" rel="bookmark">
			Websocket在实时视频监控行业中的应用，以及如何应用于视频监控平台及其web客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、WebSocket的定义与标准
1、背景
2、定义
3、标准化：
二、WebSocket的核心特性与优势
1、全双工通信
2、长连接
3、轻量级头部
4、实时性
5、跨域支持
三、WebSocket的工作原理与流程
1、握手阶段
2、数据传输阶段
3、websocket连接和http连接
（1）HTTP连接
（2）WebSocket连接
四、WebSocket的使用场景
1、即时聊天
2、实时数据更新
3、游戏开发
4、实时监控
五、WebSocket的优缺点
1、优点
（1）实时性
（2）减少网络流量
（3）较少的开销
（4）跨平台支持
2、缺点
（1）兼容性问题
（2）服务器资源占用
（3）安全性问题
六、在视频监控领域中的应用
1、实时视频流传输
2、监控数据推送
3、远程控制与管理
4、实时分析与预警
5、多用户并发访问
6、安全性与稳定性
七、在视频监控平台中的实际应用
1、AS-V1000视频监控平台介绍
2、websocket可以实现的交互应用
（1）实时状态显示
（2）语音对讲
（3）告警联动
3、websocket实现的方法
（1）建立WebSocket连接：
（2）应用系统的数据交互和控制：
（3）错误处理和重连机制：
4、websocket接口示例
一、WebSocket的定义与标准 1、背景 WebSocket 通信协议2008年诞生，于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准；是HTML5认可的一种协议，本质上是一个基于TCP的协议。它实现了浏览器与服务器全双工通信，旨在更好地节省服务器资源和带宽，并达到实时通讯的目的。
2、定义 WebSocket是一种在单个TCP连接上进行全双工通信的协议，它允许客户端和服务器之间进行双向、实时、低延迟的数据交换。它使得客户端和服务器之间的数据交换变得更加简单，并允许服务端主动向客户端推送数据。
3、标准化： WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。
二、WebSocket的核心特性与优势 1、全双工通信 不同于传统的HTTP请求-响应模式，WebSocket实现了双向通信。服务器可以主动推送数据到客户端，而无需客户端发起请求。
2、长连接 一旦WebSocket握手成功，连接将保持打开状态，直到显式关闭。这减少了频繁建立和销毁连接带来的开销，尤其适合需要持续通信的场景。
3、轻量级头部 WebSocket数据帧采用紧凑的二进制格式，减少了不必要的头部信息，提高了数据传输效率。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f13f1ee49d72452aafd46aa70e9f0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21643e54a04959044ead8c193a755cd/" rel="bookmark">
			⭐最新版!SpringBoot正确集成PageHelper姿势，不再被误导！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GGBond🔈 CSDN的朋友们大家好哇，我是新来的Java练习生 CodeCodeBond！
什么是PageHelper？ 这里给不知道的人儿说明一下~~ 知道的xdm可以跳过了！
PageHelper顾名思义是一个 页面 帮手。也就是分页查询的一个好用的工具。他是集成Mybatis开发的时候才能使用的，也就是说他是基于Mybatis的（拦截Mybatis的Excutor，详细可以自行冲浪）大家如果有过写分页查询的需求的时候，其实就会感受过写分页查询sql时候的不便性。
要思考sql分页，条数的拓展性，如何优化。分页逻辑看似简单，但实际操作中涉及多个参数（页码、每页条数、总记录数等），处理不当容易导致分页错误，如计算偏移量出错、页码越界等问题。维护成本高，且多人开发时每个人分页逻辑不同很难统一。 但是！ 使用PageHelper这个工具帮我们解决了以上问题，（当然生产中得好好掂量这个开源工具的兼容稳定性了）当使用PageHelper，你的分页逻辑代码将会变成以下如此简单 👇
@RestController public class IssueController { @Resource private IssueService issueService; @GetMapping("/get/user/issues") public R&lt;IssuesPageVo&gt; getIssues(@RequestParam(defaultValue = "1") Integer pageNum, @RequestParam(defaultValue = "10") Integer pageSize){ return R.success(issueService.getIssues(pageNum, pageSize)); } } 其中的issueService其实实际你写的sql就只是一个select * 。 然后把页数、页条数放进去，PageHelper就会自动帮你分好页了！！这样子的接口，前端的coding自由度更高，可以随意做拉取加载等等节流操作，再也不怕前端来找茬了。（不是
SpringBoot集成PageHelper正确姿势 开始学习这个插件的时候，可能是网上课程较老的原因，网路上搜索到的各种配置操作基本都是坑，导致我看别人博客学习踩了很多坑，现在我将它们分享出来，希望学习的朋友们及时从坑里爬出来。
坑1： 在风雨交加的一天，CodeCodeBond在学习PageHelper时候，开始谷歌SpringBoot配置PageHelper，看了看文章标题也没错。进去发现它教我在一个SSM项目中写一个配置类，甚至还有文章Maven导入的依赖也是高度重复！真是让人头晕。
在SpringBoot项目究竟要导入什么依赖 网上最常见的就是这样导依赖了
虽然版本兼容的话，也能跑，但是这不是乱导一通吗。
来看看右边的Maven大哥怎么说：
不懂英文没关系，跟着我念 Omi踢 for 丢普立kei te。
其实导入pagehelper-spring-boot-starter的时候，就已经包含了这些依赖项了。所以我们的SpringBoot项目也只需要导入这个依赖即可！
对于一个轻度代码洁癖的CRUD boy，我选择优雅导入依赖~删除冗余
在SpringBoot项目中究竟如何配置 SpringBoot中是可以直接在yml配置文件配置PageHelper的，简单方便可读性高
pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql pageSizeZero: true 我们只需要在你对应的application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c21643e54a04959044ead8c193a755cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66078c54098b6fb398dea46b0868c2ea/" rel="bookmark">
			Flink CDC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. CDC与Flink CDC区别： CDC（Change Data Capture）：这是一种技术，用于捕获数据库中的数据变更（例如插入、更新、删除操作），将这些变更按发生的顺序完整记录下来，写入到消息中间件中以供其他服务进行订阅及消费。CDC通常是通过轮询数据库事务日志或使用数据库特定的触发器来实现的。
Flink CDC（Apache Flink Change Data Capture）：Flink是一个流处理引擎，Flink CDC是指利用Apache Flink框架来实现数据变更捕获的技术（即用Apache Flink这个流处理框架来实现CDC的技术）。FlinkCDC是一个开源的数据库变更日志捕获和处理框架，它可以实时地从各种数据库(如MySQL、PostgreSQL、Oracle、MongoDB等)中捕获数据变更并将其转换为流式数据,FlinkCDC 可以帮助实时应用程序实时地处理和分析这些流数据，从而实现数据同步、数据管道、实时分析和实时应用等功能。它可以实时地捕获数据源中的变更，并将这些变更推送到目标系统或进行实时分析处理。Flink 社区开发了 flink-cdc-connectors 组件，这是一个可以直接从 MySQL、PostgreSQl等数据库直接读取全量数据和增量变更数据的source 组件。开源地址：https://github.com/ververica/flink-cdc-connectors
主要区别：在于实现的方式和技术栈。CDC是一种通用的数据管理技术，而Flink CDC是特定利用Apache Flink框架实现的数据变更捕获技术。 Flink CDC提供了更高级的功能，如实时处理和流式数据分析，适用于需要处理大规模实时数据的场景。
二.CDC实现方式： 基于触发器的CDC：在表上创建触发器，当数据发生更改时，触发器会将更改的数据记录到其他系统或表中。基于事务日志的CDC：通过读取数据库事务日志，将日志中的更改记录解析为可操作的数据。这种方法通常用于增量备份和恢复。基于游标的CDC：在数据库中使用游标，逐行处理数据更改，并将这些更改应用于其他系统或表。基于时间戳的CDC：为表中的每个数据行分配一个时间戳，当数据发生更改时，更新相应的时间戳。然后，可以使用时间戳来识别和处理数据更改。基于消息队列的CDC：将数据更改作为事件发送到消息队列，以便其他系统或应用程序可以订阅和处理这些事件。 CDC主要分为基于查询和基于Binlog两种方式：
三.CDC原理与机制： Debezium 和 Canal 是目前最流行使用的 CDC 工具，这些 CDC 工具的核心原理是抽取数据库日志获取变更。目前 Debezium (支持全量、增量同步，同时支持 MySQL、PostgreSQL、Oracle 等数据库)，使用较为广泛。Flink SQL CDC 内置了 Debezium 引擎，利用其抽取日志获取变更的能力，将changelog 转换为 Flink SQL 认识的 RowData 数据。Debezium的数据格式如下： 通过 Debezium 采集的数据，包含了旧数据(before)和新数据行(after)以及原数据信息(source)，op 的 u 表示是update 更新操作标识符（op 字段的值 c，u，d，r 分别对应 create，update，delete，reade），ts_ms 表示同步的时间戳。
四. Flink CDC 主要特点:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66078c54098b6fb398dea46b0868c2ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655cf270d212441b343fd1249d1a2734/" rel="bookmark">
			Python 全栈体系【四阶】（六十一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 深度学习 十三、自然语言处理（NLP） 5. NLP应用 5.2 文本情感分析 目标：利用训练数据集，对模型训练，从而实现对中文评论语句情感分析。情绪分为正面、负面两种
数据集：中文关于酒店的评论，5265笔用户评论数据，其中2822笔正面评价、其余为负面评价
步骤：同上一案例
模型选择：
代码：
【数据预处理】
# 中文情绪分析：数据预处理部分 import paddle import paddle.dataset.imdb as imdb import paddle.fluid as fluid import numpy as np import os import random from multiprocessing import cpu_count # 数据预处理，将中文文字解析出来，并进行编码转换为数字，每一行文字存入数组 mydict = {} # 存放出现的字及编码，格式： 好,1 code = 1 data_file = "data/hotel_discuss2.csv" # 原始样本路径 dict_file = "data/hotel_dict.txt" # 字典文件路径 encoding_file = "data/hotel_encoding.txt" # 编码后的样本文件路径 puncts = " \n" # 要剔除的标点符号列表 with open(data_file, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/655cf270d212441b343fd1249d1a2734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669aa6203a2d5cf95a11e56ed1742239/" rel="bookmark">
			Java三层框架的解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：欢迎各位点击收看本篇博客，在历经很多的艰辛，我也是成功由小白浅浅进入了入门行列，也是收货到很多的知识，每次看黑马的JavaWeb课程视频，才使一个小菜鸡见识到了Java前后端是如何进行交互访问的，话不多说，进入正题。
目录
一.三层框架：
二.前后端交互过程：
三.如何进行接口测试：
四.三层架构的设计模式：
五.正式入门三层框架：
1.首先要写controller层：
2.service层的写法：
3.dao层的写法：
一.三层框架： 我们在进行程序开发时，应该遵守单一职责原则，意思就是尽可能让每个接口、类、方法的职责更单一，如果我们将整个后端代码放在一个包一个类中，不仅仅是代码的可阅读性差，而且代码冗杂，耦合度很高。
1. controller：控制层，负责接受前端发送来的请求，对请求进行处理，并相应数据。
2. service：业务逻辑层，处理具体实现的业务逻辑。
3. dao：数据访问层（持久层），负责数据访问操作，包括数据的增删改查。
二.前后端交互过程： 首先通过浏览器发起请求，经过DispatcherServlet（称为核心控制器或者前端控制器）将请求信息封装到HttpServletRequest这个对象内，然后再将这个请求转给后面的每个Controller程序，由Controller程序对其进行处理（Controller程序通过调用Service程序，然后再Service程序中调用Mapper程序，最后Mapper程序处理完返回给Service然后再返回给Controller），随后Controller程序将处理完的响应信息返回给DispatcherServlet的HttpServletResponse对象中，然后DispatcherServlet再给浏览器响应数据。这也就是BS架构，浏览器/服务器架构模式。
三.如何进行接口测试： 我们在写完后端程序肯定需要进行测试来判断代码的准确性，但是如果我们没有前端页面进行测试，我们如何进行接口测试呢？这个时候就需要使用Postman或者Apifox来进行接口测试。
四.三层架构的设计模式： 根据第一与第二点，我们初步理解了三层框架的进行顺序，那么三层框架该是什么样的创建形式呢？
根据上图，我们可以看到这个是基于Springboot来开发的，在java.com.itheima包下创建了四个包以及运行类，而这四个包分别装有其分别对应的类与接口。 我们都知道接口是Java程序对类定义其规则，所以一般我们在开发的时候会现在接口内写入想要实现的方法名，然后再实现类中写出实现方法。 五.正式入门三层框架： 在学习三层框架，我们都知道三层框架有controller，service，dao三层，所以咱们在写接口的过程要按照其实现顺序依次写入。
我们先在pom.xml导入依赖以及在application.properties中写入MySQL的驱动以及配置文件的相关信息，，然后在tlias数据库下创建一个Dept部门类和一个Emp员工类。
pom.xml文件导入依赖：1.Springboot 2.MySQL 3.Lombok 4.pagehelper（分页插件）
application.properties配置文件写法：
spring.application.name=tlias spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/tlias spring.datasource.username=root spring.datasource.password=lxs15241690479 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl mybatis.configuration.map-underscore-to-camel-case=true 1.首先要写controller层： 我们在写controller层之前要知道SpringBoot对注解的使用：
1. @ResponseBody:放在开头代表每个方法的返回值都会作为响应数据，如果是对象或者集合会先转为json格式然后再来响应。
2. @Controller：控制器组件
3. @RestController：主要由ResponseBody+Controller两个注解组成，也就会有这两个注解的作用。
4. @RequestMapping("url")：一个用来处理请求地址映射的注解，可用于映射一个请求或一个方法，可以用在类或方法上。
5. @***Mapping：这***是代表其有很多的样式，也就是要填入请求方式，如：Get,Post,Delete等。跟@RequestMapping差不多，但是使用这个注解就要跟随该注解前的请求方式才能够请求。
6. @RequestParam：
用于将指定的请求参数赋值给方法中的形参。
有三个属性：
（1）value：请求参数名（必须配置）
（2）required：是否必需，默认为 true，即 请求中必须包含该参数，如果没有包含，将会抛出异常（可选配置）
（3）defaultValue：设置默认值，如果设置了该值，required 将自动设为 false，无论你是否配置了required，配置了什么值，都是 false（可选配置）
7.@PathVariable：
@PathVariable是Rest风格衍生出的占位符，只支持一个属性value，类型是为String，代表绑定的属性名称。默认不传递时，绑定为同名的形参。 用来便捷地提取URL中的动态参数。应用时，在@RequestMapping请求路径中，将需要传递的参数用花括号{}括起来，然后，通过@PathVariable("参数名称")获取URL中对应的参数值。如果@PathVariable标明参数名称，则参数名称必须和URL中参数名称一致。
8. @Autowired：自动注入，上一篇Mybatis讲过，这里不细说。有需要了解请跳转：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/669aa6203a2d5cf95a11e56ed1742239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d5186b61dae888f139ad9c92003c62/" rel="bookmark">
			【C&#43;&#43;进阶学习】第四弹——多态——迈向C&#43;&#43;更深处的关键一步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在前面我们已经学习了C++中继承的相关知识，已经体会到C++在与C语言的对比中的便捷性，但是有一些问题并没有被解决，比如继承中如何使不同的派生类公用基类的一个函数，这就需要多态的知识，而且，有一个很重要的点要知道，多态是以后找工作的时候经常经常被问到的一个知识
目录
一、多态的概念
二、多态的实现
2.1 多态的构成条件
2.2 override 和 final 关键字（C++11）
2.3 重载、覆盖(重写)、隐藏(重定义)的对比
三、抽象类
四、总结
一、多态的概念 C++中多态的概念通俗来讲就是多种形态，同样的东西，在不同场景下发挥着不同的作用；体现在代码上其实就是同一个虚函数，在不同的派生类中可能发挥着不同的作用，就比如一把雨伞既可以用来挡雨，也可以用来遮阳
二、多态的实现 2.1 多态的构成条件 在C++中，要实现多态，需要满足以下几个条件：
1、基类中必须包含至少一个虚函数： 虚函数是在基类中声明的，并在派生类中重写的函数。通过在函数声明前加上virtual关键字来声明虚函数。虚函数是实现动态多态的关键，因为它允许在运行时根据对象的实际类型来调用相应的函数。
2、通过基类指针或引用调用虚函数： 多态通常通过基类的指针或引用来实现。当使用基类指针或引用指向派生类对象时，调用虚函数将根据对象的实际类型（而不是指针或引用的类型）来决定调用哪个函数。
3、派生类必须重写（override）基类的虚函数： 派生类需要重写基类中的虚函数，以提供特定于派生类的实现。重写时，函数签名（包括返回类型、函数名和参数列表）必须与基类中的虚函数完全匹配。在C++11及以后的版本中，可以使用override关键字显式声明派生类中的函数是重写基类的虚函数，这有助于编译器检查是否正确重写了虚函数。
4、使用虚析构函数： 如果基类中使用了虚函数，通常建议也将析构函数声明为虚函数。这是因为当通过基类指针删除派生类对象时，如果析构函数不是虚函数，将只会调用基类的析构函数，而不会调用派生类的析构函数，这可能导致资源泄漏。
下面是一个简单的示例，展示了多态的构成条件：
#include &lt;iostream&gt; class Base { public: virtual void show() { // 虚函数 std::cout &lt;&lt; "Base show()" &lt;&lt; std::endl; } virtual ~Base() {} // 虚析构函数 }; class Derived : public Base { public: void show() override { // 重写基类的虚函数 std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62d5186b61dae888f139ad9c92003c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c3ec28a2d64525f715736398f89fe8/" rel="bookmark">
			Android Studio运行报错解决集锦（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错一：java.net.SocketTimeoutException: Connect timed out （连接超时）
解决方法：修改项目下gradle\wrapper\gradle-wrapper.properties
#distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip
更换连接地址
distributionUrl=https://mirrors.cloud.tencent.com/gradle/gradle-8.7-bin.zip
报错二： Using dependency catalogs requires the activation of the matching feature preview.（使用依赖项目录需要激活匹配的功能预览。）
解决方法：项目下settings.gradle.kts文件首行添加
enableFeaturePreview("VERSION_CATALOGS")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e8dfc30e4f6bcdcf7884abef9001a79/" rel="bookmark">
			基于SpringBoot和PostGIS的某国基地可视化实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Java后台开发设计与实现
1、模型层实现
2、控制层设计
二、WebGIS界面实现
1、列表界面的定义
2、全球基地可视化
三、成果展示
1、全球部署情况
2、亚太地区
3、欧洲基地分布
4、中东的部署
四、总结
前言 在之前的博客中，我们曾经对漂亮国的基地信息进行了采集，包括其国内的基地和海外的基地。关注最近的世界新闻的朋友应该注意到了，就是最近中东小霸王被周边的国家群殴了。今天我们结合上次搜集的数据来对其全球的基地信息进行空间可视化，看看它的空间部署方位图。
本文以Java开发语言为例，使用SpringBoot框架来进行后台开发，详细讲解如何使用Leaflet对PostGIS的全球基地信息进行Web可视化，最后分享Web可视化结果。从国内基地，到海外不同国家的具体的驻扎分布。让您对其在世界各地的分布有直观的感受。通过本文，您可以学习如何使用Java来开发WebGIS系统，对于空间数据的可视化有了更深的掌握。
一、Java后台开发设计与实现 作为标准的web程序，这里采用MVC的设计架构，后台采用Springboot来进行开发。本节将从模型层、业务层、控制层三层的具体设计与实现来详细讲解。
1、模型层实现 模型层主要包含业务实体层和Mapper的数据库操作层。其中模型层主要用来做数据库和真实基地对象的关系映射，与数据库表是逐一对应的。Mapper是实现空间对象到数据库对应持久化的对象，来实现基地信息的查询、新增、修改和删除操作。
实体层对象的代码如下：
package com.yelang.project.extend.militarytopics.domain; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import com.yelang.framework.handler.PgGeometryTypeHandler; import com.yelang.framework.web.domain.BaseEntity; import lombok.AllArgsConstructor; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import lombok.ToString; /** * 美军军事基地实体类 * @author 夜郎king */ @TableName(value ="biz_usa_military_base",autoResultMap = true) @NoArgsConstructor @AllArgsConstructor @Setter @Getter @ToString public class UsaMilitaryBase extends BaseEntity{ private static final long serialVersionUID = 9052078556566456025L; @TableId private Long id;//主键 @TableField(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e8dfc30e4f6bcdcf7884abef9001a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b93dd234e03d8781d153d0b90c273edc/" rel="bookmark">
			浔川AI五子棋（改进（完整）版1.3）——浔川python社
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 浔川AI五子棋是一种使用人工智能技术来进行五子棋对弈的游戏。它采用了先进的算法和模型，在对弈过程中能够实时分析棋局并进行决策，使得游戏更具挑战性和趣味性。
浔川AI五子棋的核心技术是人工智能算法。它使用深度学习模型对大量的五子棋对局进行训练，从而学习到了不同棋局下的最优解策略。通过不断的优化和迭代，浔川AI五子棋的对弈水平逐渐提高。
浔川AI五子棋还具有一些其他的特性。它可以提供不同难度的对手选择，从初级到高级，以满足不同水平玩家的需求。此外，游戏还提供了多种游戏模式和主题，使得玩家能够体验到不同的游戏风格和乐趣。
总的来说，浔川AI五子棋是一款结合了人工智能技术的棋类游戏，通过对局分析和决策，提供了更具挑战性和趣味性的游戏体验。
本代码由浔川python社、浔川AI社联合创作。
下次更新： 2024/07/06 更新：v1.3 → v1.4
浔川AI五子棋 v1.0链接：浔川AI五子棋——浔川AI社_ai五子棋人工智能对弈-CSDN博客
正式代码： -*- coding: utf-8 -*- import tkinter as tk import tkinter.messagebox import pickle import random # 窗口 window = tk.Tk() window.title('欢迎进入python') window.geometry('450x200') # 画布放置图片 # canvas=tk.Canvas(window,height=300,width=500) # imagefile=tk.PhotoImage(file='qm.png') # image=canvas.create_image(0,0,anchor='nw',image=imagefile) # canvas.pack(side='top') # 标签 用户名密码 Verification_Code = random.randint(1000, 9999)#设置一个随机的四位数 Verification_Code = str(Verification_Code)#把类型转换为str型 print(type(Verification_Code)) tk.Label(window, text='用户名:').place(x=100, y=30) tk.Label(window, text='密码:').place(x=100, y=70) tk.Label(window, text='验证码').place(x=100, y=110) tk.Label(window, text=Verification_Code).place(x=320, y=110) # 用户名输入框 var_usr_name = tk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b93dd234e03d8781d153d0b90c273edc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b868cebc7548abcd1db7b9ea24516d/" rel="bookmark">
			一文2000字记录基于jmeter&#43;perfmon的稳定性测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01、任务情况 1、任务总览 本次平台稳定性测试的目的在于：在服务器压力处于较饱和（达到80%系统最大TPS）压力之下，在较长时间（&gt;8小时）之内观测服务器稳定性问题，以及资源使用情况和异常。
2、接口情况 本次测试不调用上下游接口，只压测创建订单接口。订单表存量数据19万，接口请求方式为PUT。
3、服务器配置 网关服务器 16核CPU、内存16G 应用服务器 16核CPU、内存16G 02、测试过程 1、测试机及工具选择 由于在前序的测试过程中，可以确定本机jmeter运行可以驱动200线程数，达到接近系统极限吞吐量的情况。因此本次稳定性测试决定延续使用本地PC使用jmeter仍以200线程进行测试，测试重点在于较长时间段内的稳定情况。
涉及到服务器资源的监控，将决定使用Jmeter插件perfmon配合serverAgent进行采集，以nmon作为实时监控工具。
具体工具选择如下：
2、工具安装配置 由于在前序的测试过程中，可以确定本机jmeter运行可以驱动200线程数，达到接近系统极限吞吐量的情况。
Jmeter
下载地址：建议使用3系列版本，原因后面说明
安装配置：JDK以及环境配置等网上有大量教程，本文不再复述
ServerAgent
ServerAgent需要部署在服务器上，他会以service的形式将服务器资源使用信息进行收集和发送。
安装配置：将工具包解压至服务器，赋予755权限，直接使用./startAgent.sh启动服务。
启动成功后应该看到如下信息：
默认绑定端口为4444
Perfmon
Perfmon是Jmeter插件，配合ServerAgent进行服务器资源监听。
安装配置：需要下载Jmeter plugin manager：
将jar包放至JMeter安装目录下的lib/ext子目录下，重启jmeter即可生效。
同样将perfMon jar包放至相同路径即可启用perfmon插件。
也可以通过GUI界面中的plugin manager 搜索安装，如下图所示：
nmon
下载地址：找支持服务器系统的版本下载，或者通过wget下载
安装配置：将压缩包解压至自选目录，赋予755权限，直接运行相应系统的.sh文件运行。（如果下载的文件不是.sh格式，可以直接更改后缀名）
本例中运行的就是如下脚本文件：
运行成功后可以看到如下界面：
可以通过键入c/m/d/n等调出相关资源监控，如下图，分别列出了CPU，Memory及磁盘IO：
Perfmon插件配置
在jmeter测试计划中添加perfmon监听器：
在配置界面中，添加所需要的监控项，如本例中监听了CPU/Memory/磁盘IO三项：
注意箭头标出的按钮，为监听具体度量的选择，本例中选择的分别是：
CPU：combined ：综合CPU使用情况
Memory：usedperc：内存使用比例
DIsk IO：usedperc：磁盘IO占用比例
保持ServerAgent开启，那么在线程组运行开始，perfmon插件就将按照配置开始采集服务器资源数据。
03、测试结果 1、聚合报告
总体样本数达到68676639个，平均响应时间299，吞吐量667.5/s，错误率0，总体比较稳定。
2、TPS及资源对比
TPS：
CPU：
内存：
可以看到：
TPS稳定在700-800之间，偶有波动，与实验室网络环境有关。CPU在TPS峰值时处于高占用状态，基本维持在70%左右。内存占用稳定在20%。
3、结论
经过本轮初步测试，在系统TPS保持在700以上的条件下，系统表现稳定，事务成功率达100%。测试过程中，CPU保持高位占用，其它系统资源未见明显瓶颈。
04、问题 在测试的过程中发现了部分明显的问题，在此进行记录：
Q：压测过程中曾遇系统内存被大量缓存并无法自动释放的情况？
A：建立定时任务，定时清理内存缓存。
Q：压测过程中曾遇系统磁盘被占100%情况，导致TPS降至200左右，经查是由于应用日志写入导致。
A：建立定时任务，定时清理应用日志。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06b868cebc7548abcd1db7b9ea24516d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61577b51cfe6a202684b8558dc3b9bad/" rel="bookmark">
			20240626 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌍警告！OpenAI宣布全面封锁中国API接入！
- 7月9号开始封锁不支持的国家API
- 如果在OpenAI不允许的国家使用其 API 将面临封杀
🔗 警告！OpenAI 宣布全面封锁中国 API 接入-CSDN博客
🎵索尼、环球音乐、华纳起诉 Suno 和 Udio！1 首歌索赔 15 万美元
- 唱片公司提交了包含具体的提示词和生成的音乐样本的USB数据盘，称这些样本直接抄袭了原作。
- 唱片公司要求法院判处每首歌 15 万美元（约 109.4 万元人民币）的法定赔偿金，并指控 Suno 复制了 662 首歌曲，Udio 复制了 1670 首。
💻240万亿巨量数据被洗出，足够训出18个GPT-4！
- DCLM团队从CommonCrawl里，清洗出了240T的数据。
- 后Scaling Law时代：不要Scale Up，要Scale Down
🔗 240万亿巨量数据被洗出，足够训出18个GPT-4！-CSDN博客
📱Streamer-Sales：一个直播卖货大模型 - 能自动卖货 同时实时回答客户任何问题
- 能根据商品特点自动生成吸引用户的解说文案，支持将语音输入转换为文字，便于主播在直播过程中与观众互动。
- 同时还能生成带有情感的语音输出，使解说更加生动自然。还能一键生成数字人。
- 甚至支持 Agent 通过网络查询快递信息。
- Streamer-Sales 项目通过多个模块和技术的集成，模型用 xtuner 在 InternLM2 的基础上指令微调而来，部署集成了 LMDeploy 加速推理
🔗GitHub: https://github.com/PeterH0323/Streamer-Sales
🔗在线体验: https://openxlab.org.cn/apps/detail/HinGwenWong/Streamer-Sales
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61577b51cfe6a202684b8558dc3b9bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0733f906cfa6fd5a94f1c7c192d5870b/" rel="bookmark">
			【Mac】iTerm for mac（终端工具）软件介绍及安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件介绍 iTerm 是 macOS 上一个非常受欢迎的终端仿真器，提供了比默认的 Terminal 应用更多的功能和定制选项。它是一款开源软件，主要用于命令行界面的操作和开发者工具。
主要特点和功能： 分页和标签： iTerm 允许用户在单个窗口中使用多个标签页和分页。这使得在多个终端会话之间轻松切换和管理任务变得更加方便。 多窗口管理： 用户可以创建多个独立的窗口，并自由调整它们的大小和位置。这种灵活性使得可以同时查看多个终端会话或执行并行操作。 丰富的定制选项： iTerm 提供了大量的定制选项，包括颜色主题、字体、窗口外观等。用户可以根据个人喜好调整界面的外观和操作习惯。 强大的搜索和回放功能： 支持文本搜索、历史命令回放和自动完成功能，帮助用户快速找到之前执行的命令并进行修改或重新执行。 集成的 Shell 配置： 支持多种 Shell（如 Bash、Zsh 等）以及各种 Shell 配置文件（如 .bashrc、.zshrc），可以根据个人偏好进行配置和扩展。 分屏功能： iTerm 支持将终端窗口分割成多个面板，每个面板可以执行不同的命令或者在同一窗口内进行多任务操作。 智能高亮显示和注释： iTerm 可以根据用户设置智能地高亮显示不同类型的文本，比如文件路径、命令等，同时也支持为命令添加注释，方便理解和管理。 脚本和自动化： 可以通过 AppleScript 和 Shell 脚本来自动化 iTerm 的操作，比如批量执行命令、自动打开特定的终端会话等。 使用场景： 开发者工具：适用于开发者进行代码编写、版本控制和服务器管理。系统管理：用于系统管理员执行维护和监控任务。数据分析：支持数据科学家和分析师使用命令行工具进行数据处理和分析。远程登录：适用于 SSH 和 Telnet 连接，进行远程服务器管理和操作。 总体而言，iTerm 是一款功能强大且高度可定制的终端仿真器，广泛应用于开发和系统管理领域，提供了比 macOS 默认终端更多的工具和便利功能。
安装教程 1.打开安装包，拖动「iTerm.app」到应用程序中即可。
2.选中脚本_1，鼠标右键点击，选择「打开」。
3.输入自己电脑的开机密码，输入密码时，密码是看不见的。
温馨提示：先尝试打开一遍软件，遇到软件损坏打不开的问题，再运行脚本_2。
4.【可选】选中脚本_2，鼠标右键点击，选择「打开」。
5.【可选】输入自己电脑的开机密码，输入密码时，密码是看不见的。
获取方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0734664894af58712fba1111645f679e/" rel="bookmark">
			eslint版本9.0之后配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在eslint9.0之后，迎来版本大更新。首先是抛弃了自带的规则（没了我喜欢的git standard风格），其次是配置又更新了，改动有点大，重新捋了一遍之后，附上最新的eslint配置过程。
初始化命令 此次试验的版本是9.5.0，官方推荐执行命令是：
npm init @eslint/config@latest 或者我比较喜欢的初始化命令：
npx eslint --init 两者结果一样，并无区别。
或者也可以使用如下命令，这样就可以愉快的使用git standard风格，同时eslint的版本是8.57.0。
npm init @eslint/config@latest -- --config eslint-config-standard 执行过程省略，可参考之前我写的vscode中使用eslint+prettier的配置，或者翻译一下就明白了。
√ How would you like to use ESLint? · problems √ What type of modules does your project use? · esm √ Which framework does your project use? · vue √ Does your project use TypeScript? · javascript √ Where does your code run? · browser, node The config that you've selected requires the following dependencies: eslint@9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0734664894af58712fba1111645f679e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1def8d3c66adb8e0f4fa6efe640fd4fc/" rel="bookmark">
			还不到6个月，GPTs黄了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相比起来，人们还不如使用一个足够强大、灵活且通用的AI助手来满足各类复杂需求。更严重的是一些独立GPTs显露出的安全隐患。除此之外，最大的问题在于OpenAI模糊不清的货币化政策。
文章正文 上周，不少人发现微软官网忽然更新了一条“GPT Builder 即将停用”的通知。宣布将从7月10日起终止对Copilot GPT的支持，并会在四天内把平台上所有已创建的GPT连同相关数据全部删除。
如此猝不及防，因为就在仅仅3个月前， GPT Builder 才被微软打包进Copilot Pro服务正式推出。每月付费20美元的订阅用户可以根据特定需求，创建定制化的GPT聊天机器人来自用或分享。
对于刚上线就遭遇光速“停服”，官方给出的解释是：“正在继续评估针对消费者Copilot的可扩展策略，并优先考虑核心产品体验，同时仍然致力于为开发者提供机会。为此，我们将把GPT的重心转移到商业和企业应用场景，并停止消费级Copilot方面的GPT工作。”
简言之，试验了几个月，微软现在得出结论，GPT Builder在消费端并不算一个可行的产品。尽管公司全力推进Copilot等AI项目，也只会在其具有现实商业意义时予以支持。
处境一样尴尬的还有Copilot GPTs的“本体”、相同产品逻辑的ChatGPT 版GPTs和GPT Store。
随着GPT-4、Sora、Voice Engine、GPT-4o引发一轮又一轮的讨论热潮， OpenAI百宝箱内爆款频出， GPTs逐渐成了那个隐身在后，极少被人提及的名字。但人们也还依稀记得它的盛大出场——那个被视为具有划时代意义，可能改写整个AI行业的硅谷的冬天 。
出道即巅峰，却是昙花一现？ 去年11月6日的OpenAI开发者大会上，奥特曼首次向全世界介绍了GPTs的概念。用户无需任何编程知识，仅通过自然语言指令和上传知识库，就能轻松定制自己的个性化GPT。
GPTs具备多模态功能，支持外部数据源扩展和API集成，还可以发布到即将上线的GPT Store参与社区共享和营利。奥特曼信心满满地描述着GPT Store类似App Store的搜索、分类和推荐机制，并亲自演示了如何在几分钟内构建一个完全版的「创业导师」聊天机器人。
一夕之间，挡在普通人面前的技术壁垒被推翻，「开发者」一词被重新定义，更有无数AI创业公司惨遭血洗。人们看到了OpenAI试图效仿苹果和谷歌，打造一套完整开发者和用户生态的野心。彼时“变天”、“炸裂”、“颠覆”还未成为常见词汇，那场发布会被江湖形容为 “OpenAI的iPhone时刻”。
始料未及的是，一出狗血宫斗风波打乱了GPT Store的发布节奏。导致原定去年11月末上线的GPT Store今年1月10日才终于对Plus用户开放。与此同时， GPTs使用过程中暴露的问题也接踵而至。
使用大翻车，开发者不满，GPTs凉了 凭着亲民的技术要求，GPTs迅速吸引全球大量AI爱好者涌入。截至今年1月底，用户创建的GPTs已超过300万个。
但也正是由于创建门槛低，大家发现只用简单prompts调出来的定制GPT，体验其实和直接对话GPT-4没太大差别，甚至还是个“低配版”：它不能适应知识库、容易分心和产生幻觉；不能100%遵循自定义指令，反而 “在ChatGPT界面得到的回答效果要好5倍”；本质相当于基础RAG平台，却最多只能传10个文件，未能提供向量数据库调用等功能。而且容易实现也就意味着容易被替代，几百万个GPTs同质化严重、良莠不齐，真正优秀的却少之又少。
相比起来，人们还不如使用一个足够强大、灵活且通用的AI助手来满足各类复杂需求。据Sametime Web数据显示，2月份GPTs访问量仅占ChatGPT网页端的1.5%。自GPT Store开业以来，每周用户流量也已趋于平稳。
更严重的是一些独立GPTs显露出的安全隐患。许多用户都在X表示，自己仅通过几轮对话诱导，就能从GPTs下载原始知识文件，存在数据泄露风险。
比如有人从薪酬比较网站Levels.fyi的GPT轻松获取了作者上传的「2021年美国各大科技公司岗位薪酬」数据表格。还有人直接套出OpenAI 16个官方GPT的源提示。普通用户复制粘贴prompts，再搭配几个知识库文件，就能瞬间复刻。
来到开发者这边，也是怨声载道。
一方面直至5月13日OpenAI春季发布会前，都只有付费用户才能访问GPT Store，很大程度上限制了 GPTs的用户增长潜力。而且由于OpenAI后台提供的用户数据分析功能不足，在一个数据驱动决策的世界里，创作者们无法得到充分洞察，很难吸引到新用户。
Hintloop创始人Kirill Demochkin说，在他分析的超过36000个定制聊天机器人中，只有5%的GPTs每天有150到500个活跃用户，绝大多数每天只能吸引一到两个用户。
另一方面是新创作者在GPT Store的可见性问题。虽说全民可参与，但其实商店的当前设置令GPTs的新人创作者们很难获得关注。每个类别下只能展示OpenAI的官方推荐排列。社区纷纷喊话OpenAI可以学学 TikTok，采用类似的大数据推送或发现方式，让新创作者有更多机会展现自己。
除此之外，最大的问题在于OpenAI模糊不清的货币化政策。早在开发者大会上，奥特曼就承诺发布GPTs会产生实际收入，却一直停留在画饼阶段，没有公布任何支付规则。大家分不到钱，自然就缺乏动力构建高质量应用。
到3月底，眼看GPTs快要“凉凉”，OpenAI不得不紧急决定与小部分美国开发者合作，基于GPTs的使用情况发放相应奖励。目标是“创建一个充满活力的生态系统，让开发者的创造力和影响力得到回报”。至于更具体的奖励细节，OpenAI并未披露。
与之形成鲜明对比的是OpenAI 董事Adam D'Angelo打造的AI 聊天平台Poe。同样的创作者经济模式，Poe不仅更早付诸行动，发展出一套清晰完善的「变现计划」，还将适用范围扩展到包括中国香港在内的23个国家和地区。
在Poe，创作者可以通过设定聊天机器人付费墙和每条信息的价格来获取收益，也能靠拉新把每份订阅多达50美元的激励收入囊中。Poe贴心地讲解了收益计算方式、如何设置收款和获取更多转化的攻略。当初传言Adam D'Angelo因为被奥特曼端了饭碗而大怒，谁成想Poe大路越跑越通，GPTs倒是跪了。
尽管后来为了力挽狂澜，OpenAI推出直接在对话框中艾特GPTs的炫酷功能，让300万聊天机器人“为你打工”，但先找到特定GPTs对话，下次再艾特，从下拉菜单选取，再输入指令——明明一个ChatGPT就能办的事儿，非要把操作线程折腾得更冗长，恐怕真正使用的人寥寥无几。上个月，OpenAI宣布对所有免费用户开放访问权限，但这似乎也救不动了。
为啥GPT Store成不了App Store 承载着奥特曼和OpenAI的野望，从惊世骇俗的登场，到光环褪去的落寞。起码到目前为止，GPTs 并未成为它预想中的样子。
OpenAI的顶级研究人员曾表示，LLM可能成为一种操作系统，类似于苹果的iOS。然而无论是iOS还是安卓，它们早期的热门应用包括视频游戏、导航地图、社交媒体、浏览器工具等等，都是功能鲜明且易于使用和理解的服务。但早期生成式AI驱动的应用通常没有那么直观，大多数人也并未形成依赖聊天机器人来创建图表、计划旅行、解数学题的习惯。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1def8d3c66adb8e0f4fa6efe640fd4fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b3edc26a0d181c121d843af0a3da88/" rel="bookmark">
			网络黑客入门级工具：netwox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 netwox 是由 lauconstantin 开发的一款网络工具集，适用群体为网络管理员和网络黑客，它可以创造任意的 TCP、UDP 和 IP 数据报文，以实现网络欺骗，并且可以在 Linux 和 Windows 系统中运行。 可以说，对平时我们用来测试网络的性能和网站压力测试很有帮助了。它不仅仅只是一个工具包，而是很多个工具集的集中体现，所以，有了它，基本你可以少下载很多软件了。 【一一帮助安全学习，所有资源获取处一一】
①网络安全学习路线
②20份渗透测试电子书
③安全攻防357页笔记
④50份安全攻防面试指南
⑤安全红队渗透工具包
⑥网络安全必备书籍
⑦100个漏洞实战案例
⑧安全大厂内部视频资源
⑨历年CTF夺旗赛题解析
具体用法 下面就来具体说说它的用法： 首先我们现在netwox，地址： https://590m.com/file/7715018-442548444 下载完毕之后我们点击里面的exe文件进行安装即可，全程在命令提示符里操作，全程选择y 即可，安装好后，会显示这样的画面：
这就是这款强大工具的主菜单了，看到这么多英文想必大家都蒙圈了吧，那小编就给大家翻译下吧。 0：退出netwox工具。 3：搜索工具，用来搜索与指定信息相关的模块。 4：显示指定模块的帮助信息。 5：在命令行中输入指定模块的参数选项并运行。运行命令行工具选择参数 6：从键盘输入指定模块的参数选项并运行。运行工具选择参数 a：显示信息。 b：显示网络协议模块。 c：显示应用程序协议模块。 d：显示与嗅探数据包相关的模块。(捕获网络数据包) e：显示与创建和发送数据包相关的模块。(创建和发送数据包) f：显示与进行数据包记录相关的模块。记录(包含数据包捕获的文件) g：显示与客户端相关的模块。 h：显示与服务器相关的模块。 i：显示与检测主机连通性相关的模块。ping j：显示与路由跟踪相关的模块。traceroute(获得网关列表) k：显示与扫描计算机和端口相关的模块。扫描(计算机和港口发现) l：显示网络审计模块。 m：显示与暴力破解相关的模块。(检查密码是否弱) n：显示与远程管理相关的模块。 o：显示工具与网络模块。 大致就是这么个意思，可以看出命令还是蛮友好，起码小编第一眼看就觉得很亲切。
查看创建和发送数据包的模块:
然后我们在查看arp创建和发送数据包的模块:
那么它有那些作用呢？当然它的作用是不容小觑的：
工具箱netwox有助于发现和解决网络问题:　——嗅探,恶搞`　`——客户端、服务器`　`——DNS、FTP、HTTP、IRC NNTP, SMTP, SNMP, SYSLOG, TELNET, TFTP`　`——扫描,ping,路由跟踪`　`——等等。 下面我们来看看netwox到底有那些强大的工具：
1:Display network configuration` `2:Display debugging information` `3:Display information about an IP address or a hostname` `4:Display information about an Ethernet address` `5:Obtain Ethernet addresses of computers in an IP list` `6:Display how to reach an IP address` `7:Sniff` `8:Sniff and display open ports` `9:Sniff and display Ethernet addresses` `10:Sniff and display network statistics` `11:Sniff and verify checksums` `12:Display which values to use for netwox parameters` `13:Obtain DLT type for sniff and spoof for each device` `14:Spoof a record` `15:Display content of a record` `16:Convert a record` `17:Recompute checksums of packets in a record` `18:Reassemble IP packets of a record, and reorder TCP flow` `19:Extract a range of packets from a record` `20:Search for strings in packets from a record` `21:Convert a number` `22:Convert a string` `23:Display ASCII table` `24:Convert IP addresses ranges` `25:Test if a directory is secure` `26:Dump a file` `27:Compute MD5 of a file` `28:Convert a binary file to readable and editable file` `29:Convert a readable and editable file to a binary file` `30:Convert a file from unix to dos` `31:Convert a file from dos to unix` `32:Spoof Ethernet packet` `33:Spoof EthernetArp packet` `34:Spoof EthernetIp4 packet` `35:Spoof EthernetIp4Udp packet` `36:Spoof EthernetIp4Tcp packet` `37:Spoof EthernetIp4Icmp4 packet` `38:Spoof Ip4 packet` `39:Spoof Ip4Udp packet` `40:Spoof Ip4Tcp packet` `41:Spoof Ip4Icmp4 packet` `42:Spoof of packet samples : fragment` `43:Spoof of packet samples : fragment, ip4opt:noop` `44:Spoof of packet samples : fragment, ip4opt:rr` `45:Spoof of packet samples : fragment, ip4opt:lsrr` `46:Spoof of packet samples : fragment, ip4opt:ts` `47:Spoof of packet samples : fragment, ip4opt:ipts` `48:Spoof of packet samples : fragment, ip4opt:ippts` `49:Ping ICMP` `50:Ping ICMP (EthIP spoof)` `51:Ping TCP` `52:Ping TCP (EthIp spoof)` `53:Ping UDP` `54:Ping UDP (EthIp spoof)` `55:Ping ARP` `56:Ping ARP (EthIp spoof)` `57:Traceroute ICMP` `58:Traceroute ICMP (EthIP spoof)` `59:Traceroute TCP` `60:Traceroute TCP (EthIp spoof)` `61:Traceroute UDP` `62:Traceroute UDP (EthIp spoof)` `63:Traceroute on a specified IP protocol` `64:Traceroute on a specified IP protocol (EthIp spoof)` `65:Scan ICMP` `66:Scan ICMP (EthIP spoof)` `67:Scan TCP` `68:Scan TCP (EthIp spoof)` `69:Scan UDP` `70:Scan UDP (EthIp spoof)` `71:Scan ARP` `72:Scan ARP (EthIp spoof)` `73:Simulate presence of a/several computer/s (arp and ping)` `74:Flood a host with random fragments` `75:Fill table of a switch using a flood of Ethernet packets` `76:Synflood` `77:Check if seqnum are predictible` `78:Reset every TCP packet` `79:Acknowledge every TCP SYN` `80:Periodically send ARP replies` `81:Send an ICMP4 timestamp` `82:Sniff and send ICMP4/ICMP6 destination unreachable` `83:Sniff and send ICMP4/ICMP6 time exceeded` `84:Sniff and send ICMP4/ICMP6 parameter problem` `85:Sniff and send ICMP4 source quench` `86:Sniff and send ICMP4/ICMP6 redirect` `87:TCP client` `88:UDP client` `89:TCP server` `90:UDP server` `91:TCP server multiclients` `92:UDP server multiclients` `93:TCP remote administration server` `94:TCP remote administration client (exec)` `95:TCP remote administration client (get file)` `96:TCP remote administration client (put file)` `97:SYSLOG client` `98:Flood a host with syslog messages` `99:TELNET client` `100:TELNET client executing one or several commands` `101:Brute force telnet client` `102:Query a DNS server` `103:Obtain version of a Bind DNS server` `104:DNS server always answering same values` `105:Sniff and send DNS answers` `106:Send an email` `107:Post a newsgroup message` `108:List newsgroups available on a server` `109:Download one, or more, newsgroup messages` `110:Ethernet bridge limiting flow` `111:FTP listing a directory` `112:FTP client : get a file` `113:FTP client : put a file` `114:FTP client : del a file` `115:FTP client : get a directory recursively` `116:FTP client : put a directory recursively` `117:FTP client : del a directory recursively` `118:HTTP GET` `119:HTTP HEAD` `120:HTTP POST` `121:HTTP PUT` `122:HTTP DELETE` `123:HTTP TRACE` `124:HTTP OPTIONS` `125:HTTP server` `126:HTTP remote administration server` `127:Cypher/decypher a file using a xor` `128:Split a file in smaller chunks` `129:Reassemble chunks of a file` `130:Brute force ftp client` `131:Brute force http client (site password)` `132:Brute force http client (proxy password)` `133:Convert an url/uri` `134:Obtain urls/uris in a HMTL file` `135:Convert urls/uris in a HMTL file to absolute urls` `136:Web download (http://.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b3edc26a0d181c121d843af0a3da88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc11a8ff1a93b9fdede0e6480b6a582d/" rel="bookmark">
			5 秒生成高质量文章，Llama 3-Chinese-Chat Demo 一键启动！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Llama 3 自发布以来备受关注，并被誉为「迄今为止最好的开源大模型」，但 Llama 3 在支持中文方面仍然存在一些问题，比如在使用中文提问时，经常发生英文回复或者中英混合回复的情况，非常不方便。
使用中文向 Llama 3-8B-Instruct 进行提问
针对于此，河南工业大学人工智能系来新璐同学开发了首个 Llama 3 中文版本 Llama 3-Chinese-Chat 模型，能够实现流畅的中文对话，拥有超高中文理解能力。
目前，「一键部署 Llama 3-Chinese-Chat-8B Demo」已经同步上线至 HyperAI超神经官网，无需输入任何命令、只需一键即可开启对话。
使用中文向 Llama 3-Chinese-Chat-8B 进行提问
教程地址：
https://go.hyper.ai/ocpwC
Demo 运行
登录 hyper.ai，在「公共教程」页面，选择「一键部署 Llama 3-Chinese-Chat-8B Demo」。点击「在线运行此教程」。 页面跳转后，点击右上角「克隆」，将该教程克隆至自己的容器中。 点击右下角「下一步：选择算力」。 页面跳转后，选择「NVIDIA GeForce RTX 4090」，点击「下一步：审核」。新用户使用下方邀请链接注册，可获得 4 小时 RTX 4090 + 5 小时 CPU 的免费时长！ HyperAI超神经专属邀请链接（直接复制到浏览器打开）：https://openbayes.com/console/signup?r=6bJ0ljLFsFh_Vvej
点击「继续执行」，等待分配资源，首次克隆需等待 3 分钟左右的时间。当状态变为「运行中」后，将鼠标移动至「API 地址」后，复制该地址并在新标签页打开，即可跳转至 Llama 3-Chinese-Chat-8B Demo 页面。请注意，用户需在实名认证后才能使用 API 地址访问功能。 若超过 10 分钟仍处于「正在分配资源」状态，可尝试停止并重启容器；若重启仍无法解决，请在官网联系平台客服。
效果演示
打开 Llama 3-Chinese-Chat-8B Demo 页面，在对话框内容输入文本，点击发送，即可开始对话。 将今年高考作文（全国卷）的题目与要求发送给它，它可以十分快速的输出一篇符合要求的作文。 左侧的超参数面板分别表示： Maximum length： 模型最大输出文字的数量；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc11a8ff1a93b9fdede0e6480b6a582d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/227/">«</a>
	<span class="pagination__item pagination__item--current">228/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/229/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>