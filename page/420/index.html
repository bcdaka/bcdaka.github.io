<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389deabea5408cee9e0d0df4f0ea7063/" rel="bookmark">
			Tesseract4Android：一款强大的OCR识别库，助力移动应用开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tesseract4Android：一款强大的OCR识别库，助力移动应用开发 项目地址:https://gitcode.com/adaptech-cz/Tesseract4Android
Tesseract4Android 是一个专为 Android 平台打造的光学字符识别（Optical Character Recognition, OCR）库。它是 Google 的开源项目 Tesseract 的 Android 版本，经过 Adaptech-CZ 团队精心优化和封装，旨在为移动开发者提供高效、易用的文字识别解决方案。
技术分析 Tesseract4Android 基于 Tesseract v4，支持现代的 LSTM 网络模型，这使得它在文字识别的准确性和复杂场景适应性上有了显著提升。LSTM 模型训练了大量的文本数据，使其能够处理多种字体、大小和方向的文字，并且对多语言的支持也十分出色。此外，Tesseract4Android 还集成了 Leptonica 图像处理库，以进一步增强图像预处理能力，提高识别效果。
该项目采用了 Java 和 C++ 双重编程语言，通过JNI接口与 Android 应用层交互，确保了性能的同时提供了易于集成的特点。开发者可以简单地通过调用 API 来实现 OCR 功能，而无需深入理解复杂的机器学习或图像处理技术。
使用场景 Tesseract4Android 可广泛应用于各种需要文字识别的 Android 应用中：
文档扫描 - 能够快速将纸质文档转化为电子文本，方便编辑和存储。图片转文字 - 用户可以从照片中提取文字，例如菜单、名片或者海报等。实时翻译 - 结合其他翻译服务，可以实现实时图像中的文字翻译。无障碍辅助 - 对视障用户读取屏幕上的文字提供帮助。 特点 高效识别 - 借助 LSTM 模型，提供了高精度的文字识别。多语言支持 - 支持超过 100 种语言，满足全球化需求。灵活集成 - 通过简单的 API 调用即可集成到任何 Android 项目中。高度可定制 - 开发者可以根据需要调整图像预处理参数，优化特定场景的识别效果。轻量级 - 相对于完整的 Tesseract 实现，Tesseract4Android 更加轻量化，减少了对设备资源的需求。 推荐使用 如果你是一名 Android 开发者，正在寻找一个强大、易于使用的 OCR 解决方案，那么 Tesseract4Android 绝对值得尝试。无论是快速原型设计还是大型商业项目的实施，它都能为你节省大量的时间和精力，让你的应用具备识别并处理文字的能力。立即加入社区，开始利用 Tesseract4Android 打造你的创新应用吧！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389deabea5408cee9e0d0df4f0ea7063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a9559f50a624946b2ee421db434ce1/" rel="bookmark">
			18 张图手把手教你使用 Canal Adapter 同步 MySQL 数据到 ES8，建议收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将 MySQL 的数据同步到 ES8 中总共有如下几个配置，每一个都是必须的
1.MySQL 开启 binlog 日志，并且选择 ROW 模式；
2.初始化 Canal 数据库，并且增加对应的数据库账号和开启 slave 权限；
3.启动 Canal Server 和 Canal Adapter 并配置对应 ES8 的适配器；
4.安装 ES8 并且提前创建对应的数据索引，否则同步不成功。
MySQL 相关配置 检查 MySQL 当前是否开启 binlog，执行如下命令
mysql&gt; show variables like '%log_bin%'; 如果没有开启，则通过修改 my.cnf 配置文件来进行开启，并且配置成 ROW 模式。
开启 binlog cat /etc/my.cnf # log_bin [mysqld] log-bin = /var/lib/mysql/binlogs/mysql-bin #开启binlog binlog-format = ROW #选择row模式 server_id = 1 #配置mysql replication需要定义，不能和canal的slaveId重复 配置 Canal 专属账号 创建一个独立的 canal 账号，并且授权查询和 SLAVE 以及 REPLICATION 权限，账号密码可以自定义，这里都设置成了 canal，这个账号密码后续配置 canal 的时候都会用到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9a9559f50a624946b2ee421db434ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5fcb83b1d2a4c4e7df3890402da03cb/" rel="bookmark">
			如何直接给AI程序代码？拯救毕设流程图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝 前言 作为一名程序员、博客文章书写者、学术垃圾制造者，总是要根据代码绘制程序流程图，然后转化为文字叙述，这着实让我苦恼。流程图不就是复制代码注释，然后根据程序进行流程图绘制就可以了嘛。为了不想再次文字叙述流程图，还是借助AI工具。特此将笔记分享给大家！ 一、示例方法步骤 1、给AI源代码，并根据指令生成Flowchart流程图代码 命令：根据我给的代码，给出 【XXXXXXXX】无线通信模块子程序设计的逻辑和步骤，代码如下：
2、根据Ai给出的程序设计逻辑和步骤，生成Flowchart流程图代码 在能识别MarkDowm语法的软件中，填入代码生成Flowchart流程图 3、代码生成Flowchart流程图 3.1 代码转化为文字叙述 命令：根据我给的程序设计逻辑，给出 【XXXXXXXX】模块子程序设计的MarkDown语法的Flowchart流程图代码程序设计逻辑如下：
AI生成内容
3.2 文字转化的marmaid流程图代码 命令：这是一段【XXXX】源代码，你需要根据源代码生成专业的Mermaid流程图代码：
3.3 使用MarkDown绘图软件，插入代码绘图 最终代码结果
4、 语法备注 （1）内容中的、语法不能正确识别，用‘，’分隔。
（2）基础语法识别，符号，边框，内容，条件语句 。
二、流程图代码示例 1、流程图代码示例 1.1 Flowchart语法代码 flowchart TB A([颜色传感器初始化]) B[调用Color_Sensor_Init函数] C[配置I2C总线GPIO引脚] D[设置传感器的工作模式、采样率、增益等参数] E[自定义配置传感器的阈值、滤波器、校准参数] F[检查传感器是否正常响应、配置是否成功] G([返回配置结果]) A --&gt; B B --&gt; C C --&gt; D D --&gt; E E --&gt; F F --&gt; G 1.2 代码生成流程图 三、工具介绍 1、 Ai工具 文心一言（百度）
阿水AI（聚合性付费AI）
通义千问（阿里产品）
OpenAi-charGPT（需要科学）
智谱（强烈推荐）
秘塔AI（信息网络检索归纳，写文章，论文推荐使用）
2、支持MarkDowm语法的工具或者网站 （1）“有道云笔记”的MarkDowm文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5fcb83b1d2a4c4e7df3890402da03cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bacbf901885cb2fb92d7db7ba6cf4af4/" rel="bookmark">
			hive表新增字段，指定新增字段位置，删除字段_hive 新增字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新大数据全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip204888 （备注大数据）
正文 alter table database.table_name change col_type col_type1 string comment '类型' cascade; alter table database.table_name change col_type1 col_type string comment '类型' cascade; 或者使用如下sql修复
msck repair table database.table_name; 总结：
对Hive表新增字段时，官方给出的语法结构如下：
ALTER TABLE table_name [PARTITION partition_spec] ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...) [CASCADE|RESTRICT] 其中CASCADE选项为选填的字段，但是对于分区表，一定要加上，否则其历史分区的元数据信息(metadata)将无法正常更新，导致访问历史分区时会报莫名的错误 cascade的中文翻译为“级联”，也就是不仅变更新分区的表结构（metadata），同时也变更旧分区的表结构。
二、调整字段顺序
注意：新增字段,默认添加在字段最后,分区字段之前。
1、hive表中指定位置增加一个字段，分两步：
第一步：先添加字段到最后（add columns）；
第二步：然后再移动到指定位置（change）
alter table 表名 add columns (列名 string comment '注释'); alter table 表名 change 要移动的列名 移动后的列名 string after 指定位置的列名; 经验证，hive中修改字段顺序并没有将字段对应的值移动，只是单纯的修改字段名，如果是空表（没有数据），可以使用以上两步；如果表中已经有数据了不推荐这么做，如果想增加字段只能往最后一个字段后添加字段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bacbf901885cb2fb92d7db7ba6cf4af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8778d47364cc6be2683ac07daf6e43f7/" rel="bookmark">
			[python]gurobi安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是gurobipy gurobipy是一种Python接口，用于与商业数学软件Gurobi中的C ++库进行通信。gurobipy通过提供高层次的Python方法，使得使用gurobipy更加容易，并且在遵循Gurobi许可证条款的前提下可以免费使用。
二、安装gurobipy 1. 未完成配置的报错 2. 安装配置步骤 第一步 下载 在官网注册学术版账号并根据电脑操作系统下载gurobi。
第二步 安装 点击下载的.msi文件，进行安装，点击下一步即可，安装位置可以根据需要修改，最后注意是否重启。
第三步 获取许可证 可参考Gurobi 免IP验证学术许可申请方法。
材料有两个：
其一， 个人申请表；其二，学信网的学籍在线验证报告，个人申请表需要自行填写并电子签名，学籍验证报告申请一个即可。
准备好材料之后发送到help@gurobi.cn。
官方邮件回复很快，在邮件中获取激活码即可：安装软件后，在计算机连接互联网的情况下，输入 cmd 进入到命令提示符窗口。在命令行下使用 cd 命令进入到 Gurobi 安装目录/win64/bin 目录下，使用激活码。
第四步 激活 直接进入目录输入cmd即可，输入激活码。
最终提示：info : License XXXXXX written to file C:\Users\...，即为激活成功。
第五步 Python配置 将Gurobi安装到python库中，先进入安装目录：
输入cmd进入命令提示符窗口，输入 python setup.py install 安装即可。
三、使用gurobipy 1. 导入gurobipy import gurobipy as gb 2. 创建模型 可以将模型的名称作为参数传递给Model()方法。
m = gb.Model("优化问题") 3. 定义变量 lb：变量的下限（如果存在）ub：变量的上限（如果存在）vtype：变量类型（GB.GRB.CONTINUOUS，GB.GRB.BINARY，或GB.GRB.INTEGER）name：为变量设置名称 x = m.addVar(lb=0, ub=1, vtype=gb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8778d47364cc6be2683ac07daf6e43f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a1fe3f4a0b70f2d5dd4c135f74a9db/" rel="bookmark">
			Java之集合类详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		·5：集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率
二、Java集合主要由两个接口派生：Collection和Map，是集合框架的根接口。
1. collection的子接口：Set:接口 —实现类： HashSet、LinkedHashSet
set的子接口SortedSet接口—实现类：TreeSet 3. List:接口—实现类： LinkedList,Vector,ArrayList
4. List:有序列表，允许存放重复的元素；
实现类：
ArrayList：数组实现，查询快，增删慢，轻量级；(线程不安全)
LinkedList：双向链表实现，增删快，查询慢 (线程不安全)
Vector：数组实现，重量级 (线程安全、使用少)
5. Set:无序集合，不允许存放重复的元素；允许使用null元素
HashSet 的后台有一个HashMap;初始化后台容量；只不过生成一个HashSet的话，系统只提供key的访问； 如果有两个Key重 复，那么会覆盖之前的；
实现类
HashSet：equals返回true，hashCode返回相同的整数；哈希表；存储的数据是无序的。
LinkedHashSet：此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有序的。
哈希表详解：
http://www.bianceng.cn/Programming/sjjg/200705/1126.htm
http://blog.csdn.net/feixiaoxing/article/details/6885657
http://blog.csdn.net/jdh99/article/details/8490704
6. 子接口SortedSet,对Set排序实现类 :TreeSet：使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序；二叉树实现的；
二叉树详解：
http://blog.csdn.net/luckyxiaoqiang/article/details/7518888/
http://blog.csdn.net/pony_maggie/article/details/38390513
7. Map的实现类：HashMap、TreeMap、LinkedHashMap、Hashtable等
HashMap：键值对，key不能重复，但是value可以重复；key的实现就是HashSet；value对应着放；允许null的键或值；
Hashtable：线程安全的，不允许null的键或值；
Properties:：key和value都是String类型，用来读配置文件；
TreeMap：对key排好序的Map; key 就是TreeSet, value对应每个key; key要实现Comparable接口或TreeMap有自己的构造器；
LinkedHashMap： 此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。存储的数
据是有序的。
接口
简述
实现
操作特性
成员要求
Set
成员不能重复
HashSet
外部无序地遍历成员
成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法。
TreeSet
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57a1fe3f4a0b70f2d5dd4c135f74a9db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd02c8f07f0c289578b24de22f581e3/" rel="bookmark">
			git在macOS环境下的安装与配置（小白版）_apple git 设置(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新大数据全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip204888 （备注大数据）
正文 git help credentials libidn has the following notes:
GNU libidn2 is the successor of GNU libidn. It comes with IDNA 2008 and TR46
implementations and also provides a compatibility layer for GNU libidn.
libpsl has the following notes:
libpsl API documentation is provided by the port ‘libpsl-docs’.
rsync has the following notes:
To use the rsyncd server you must copy /opt/local/etc/rsyncd.conf.example to
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dd02c8f07f0c289578b24de22f581e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28c1530eddda1f458eaf591c9cbbdf8/" rel="bookmark">
			最新AI创作系统ChatGPT网站源码AI绘画，GPTs，AI换脸支持，GPT联网提问、DALL-E3文生图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 SparkAi创作系统是基于ChatGPT进行开发的Ai智能问答系统和Midjourney绘画系统，支持OpenAI-GPT全模型+国内AI全模型。本期针对源码系统整体测试下来非常完美，那么如何搭建部署AI创作ChatGPT？小编这里写一个详细图文教程吧。已支持GPTs、GPT语音对话、GPT-4模型、GPT联网提问、DALL-E3文生图、图片对话能力上传图片，GPT4-All联网搜索模型、文档分析、Midjourney绘画动态全功能、AI换脸、垫图混图、插件功能、支持最近火爆的Suno-v3-AI音乐生成大模型。
《SparkAI系统介绍文档 - 渐进式AIGC系统》:
SparkAI系统介绍文档 - 渐进式AIGC系统
1.1 系统架构技术栈 前端： Vite + vue3 + ts + NaiveUI + Tailwindcss
管理端：Vite4 + Vue3 + Element-Plus
服务端（后端）：Nodejs + NestJs
数据支持： Mysql5.7(+) + Redis
运行环境：Linux、Windows、MacOs（推荐使用Linux）
数据存储：本地存储 | 阿里云oss | 腾讯云cos | chevereto图床
1.2 特色功能 ①GPT语音对话功能 支持电脑PC浏览器和手机端使用，具有”人的语气“
​
②GPTs应用 ​
③GPT4-All联网搜索模型 ​
④文档分析 ​
⑤Suno-v3-AI音乐生成 ​
⑥Midjourney局部编辑重绘 ​
⑦说图解文 ​
1.3 程序核心功能 已支持 OpenAI GPT全模型 + 国内AI全模型 + 绘画系统 +GPTs+ MJ局部编辑重绘功能+语音对话功能 + 文档分析功能 + Midjourney绘画动态全功能+插件功能！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d28c1530eddda1f458eaf591c9cbbdf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff9f1348be813d2b9c2bad55e79abf0/" rel="bookmark">
			探索数据结构：顺序串与链式串的深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：数据结构与算法
贝蒂的主页：Betty’s blog
1. 串的定义 串是一种特殊的顺序表，即每一个元素都是单独一个字符。在C语言中我们学习的字符串便是串的一种，它在我们的数据搜索与文本编译中起着不可或缺的作用。
特别注意：空格也是一个字符！！
下面是与串相关概念：
串的长度：指串中有效元素的个数(不包括字符\0)。空串：不含任何元素的串，即长度为0。子序列：抽取串的一些字符，按照原字符串的顺序进行放置的新串。子串：串中任意连续字符组成的子序列称为该串的子串，其中空串是任意串的子串。主串：包含子串的串称为该子串的主串。 2. 串的实现方式 串是一种特殊的顺序表，所以实现方式也与顺序表类似，分别以顺序表和链表来实现。
顺序实现 链式实现 3. 串的功能 串的初始化串的生成。串的复制。判断两个串是否相等。返回串的长度。链接两个串。取子串。在串1的指定位置插入串2。删除指定位置长度为n的某个子串。 4. 串的声明 4.1. 顺序串 顺序串的存储自然是以顺序表的形式，但是在定义其长度有三种实现方式，如下：
初始化一个头结点作为长度的存储。 但是这种存储有一个明显的缺点就是char类型的最大表示范围为255，所以这种方式并不可取。
以字符\0作为结束标志。 C/C++中的字符串就是以这种实现方式，但是这种实现方式每次求长度都需要遍历整个顺序表。所以在这里也不是特别好。
添加为结构体成员。 这种实现方式相较于前两种更加合理，后续我们也将以这种方式实现。
同时为了方便扩容，我们可以再增加一个结构体成员capacity。
#define MAXSIZE 50 typedef struct string { char *data; int length; int capacity; }Sstring; 4.2. 链式串 链式串我们使用单链表来实现，为了方便操作我们可以添加一个头节点。
typedef struct snode { char data; struct snode* next; }LinkStrNode; 5. 串的初始化 5.1. 顺序串 void StrInit(Sstring* s)//初始化串 { char *arr = (char*)malloc(sizeof(char) * MAXSIZE); if (arr == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ff9f1348be813d2b9c2bad55e79abf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c8e62dfede85631702fd99e8e0cc286/" rel="bookmark">
			AIGC重塑金融：AI大模型驱动的金融变革与实践，面试必会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新HarmonyOS鸿蒙全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上鸿蒙开发知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip204888 （备注鸿蒙）
正文 anything but 根本不
文章目录 01 大模型在金融领域的 5 个典型应用场景 02 大模型在金融领域应用所面临的风险及其防范 2. 大模型时代的 AI 风险03 AIGC 技术的科林格里奇困境**1. 负责任的 AI：欧美实践与启示****2. 中国的规则与治理策略思考****04 金融机构使用 AIGC 技术的 4 条可能路径**1. 全球金融机构踊跃试水 AIGC2. 金融机构使用AIGC 大模型的难点3. 金融机构使用 AIGC 技术的 4 条可能路径 🎊粉丝福利参与规则🎊 这是最好的时代，也是最坏的时代。尽管大模型技术在金融领域具有巨大的应用潜力，但其应用也面临不容忽视的风险和挑战。本文将深入研究大模型在金融领域的数据隐私和安全风险、模型可解释性和透明度、监管和合 规要求，梳理中国、美国、欧洲等地 AIGC 技术的应用规则，探索对应的风险管理和应对策略。
01 大模型在金融领域的 5 个典型应用场景 当前，金融科技已经从“立柱架梁”迈入了“积厚成势”新阶段，越来越多的金融机构积极使用数字技术来为金融血脉注入全新能量。人工智能技术正加速与金融产业深度融合，以 ChatGPT 为代表的大模型技术不断进化，为金融业带来深刻变革，驱动金融服务更加高效、便捷、有温度。
ChatGPT 拥有持续的多轮对话能力，并具备一定逻辑推理能力，在生成文章、生成代码、翻译等方面展现出令人惊叹的水平。ChatGPT 的问世，意味着人工智能从 1.0 时代迈入了 2.0 时代。ChatGPT 背后的 GPT 大模型技术是下一代 AI 技术竞争的核心，将重新定义包括金融在内的众多行业，重塑全球科技竞争格局。
金融行业属于信息密集型行业，是大模型技术的最佳应用场景之一。未来，具有通用能力的大模型将成为信息处理的基础设施，大幅降低中小银行应用人工智能技术的门槛。由于在数字资源、科技能力、业务场景等方面的天然劣势，中小银行与大银行相比，在数字化转型方面相对落后，且差距越拉越大，“智能化鸿沟”也越来越明显。在大模型时代，各类银行重新站在同一条起跑线上，都可以便捷地使用 AI 技术，插上一双数智化“翅膀”，曾经再“阳春白雪”的复杂数据，也能飞入“寻常人家”。
如果将大模型的能力放在金融行业中去处理原有的任务，会对很多工作产生颠覆性的影响。相比现有的 AI 技术，大模型技术在众多金融场景具有广泛的应用潜力和影响力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c8e62dfede85631702fd99e8e0cc286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686c99d986197df29dbafa0acc871c79/" rel="bookmark">
			Java常见限流用法介绍和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、现象
二、工具
​​​​​​1、AtomicInteger,AtomicLong 原子类操作
​​​​​​2、Redis+Lua
​​​​​​3、Google Guava的RateLimiter
1） 使用
2） Demo
3） 优化demo
4、阿里开源的Sentinel
三、算法
1、计数限流
（1）原理
（2）实现
（3）优缺点
2、固定窗口限流
（1）原理
（2）实现
（3）优缺点
3、滑动窗口限流
（1）原理
（2）实现
（3）优缺点
4、漏桶算法
（1）原理
（2）实现
（3）优缺点
5、令牌桶算法
（1）原理
（2）实现
（3）优缺点
一、现象 为什么要限流：用于在高并发环境中保护系统资源,避免因过多请求导致系统崩溃
线上服务运行中，偶尔会遇见如Api服务瞬时请求流量过高，服务被压垮；数据处理服务处理消息队列数据，消费速度过快，导致处理性能下降甚至崩溃。
限流前：数据推送给服务处理时，速度过快，服务未限流，导致CPU突然暴涨达到临界值，处理性能底下
限流后：消费速度平稳，CPU平稳，未超限，内存上涨也未超限
可见限流是非常重要的！
二、工具 ​​​​​​1、AtomicInteger,AtomicLong 原子类操作 优点：
性能高：AtomicInteger 和 AtomicLong 基于 CAS（Compare-And-Swap）操作，能够实现高效的并发访问，适用于高并发场景。轻量级：这些类作为 Java 标准库的一部分，无需引入额外的依赖，使用简单方便。内存操作：AtomicInteger 和 AtomicLong 的操作都在内存中完成，避免了网络开销。 缺点：
单机限流：AtomicInteger 和 AtomicLong 主要适用于单机环境下的限流，对于分布式系统或微服务架构来说，可能需要额外的机制来实现全局限流。功能相对单一：AtomicInteger 和 AtomicLong 的功能较为单一，可能无法满足复杂的限流需求。CAS 的潜在问题：在高并发场景下，CAS 操作可能导致自旋等待，增加 CPU 开销。此外，如果多个线程同时修改同一个值，可能导致性能下降。 ​​​​​​2、Redis+Lua 优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/686c99d986197df29dbafa0acc871c79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ad66ec529d7cb4526cfe451bb46c7c/" rel="bookmark">
			AI克隆语音（基于GPT-SoVITS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 使用GPT-SoVITS训练声音模型，实现文本转语音功能。可以模拟出语气，语速。如果数据质量足够高，可以达到非常相似的结果。相比于So-VITS-SVC需要的显卡配置更低，数据集更小（我的笔记本NVIDIA GeForce RTX 4050 Laptop GPU跑起来毫无压力。）
使用 GPT-SoVITS项目地址（https://github.com/RVC-Project/Retrieval-based-Voice-Conversion-WebUI）
项目集成了干声提取工具，声音剪切工具，语音文本校对工具等工具，你只需要一段高质量的语音即可在本地克隆声音。
下载项目 下载项目到本地，解压并打开，双击go-webui.bat,会打开控制台，稍等片刻会打开浏览器
有两个标签页（前两个，第三个还没做好），一个是数据处理，得到干声数据集和语音文本。
一个是模型训练和推理。
数据处理所有参数都默认，只需要选择对应的数据文件路径即可。
数据处理 输入文件路径为绝对路径，输出的文件路径默认在该项目文件夹目录下。数据处理目标是得到一个语音文本文件和一个声音数据集。
分离干声 这一步用于分离干声，选中该选项稍等一会会打开一个网页用于分离干声，输出格式选择wav。选择输入输出目录点击转换即可。
音频切分 语音降噪 如果是自己的录音可能会有噪音需要降噪处理，如果是网上下载的歌曲干声不用进行该操作。
语音文本识别 识别处理好的声音数据，并得到对应的文本文件。
语音文本校对 注意输入路径是文件的路径，不是文件夹的路径。选中后会打开一个页面用于校对语音文本。
有些识别的字可能有问题，需要手动去修改一下，以及一些停顿处需要增加或删除标点符号。修改后需要点击Submit Text保存。
训练和推理 训练集格式化 填写三个打星号的文本框即可，其他不用管。然后点击最下方的开启一键三连，等待完成之后就可以进行训练。
模型训练 batch_size：计算一次更新梯度的样本数量，影响训练速度。
total_epoch:训练轮次，影响模型质量，理论上来说越大越好。
GPT模型对结果影响不大，训练个10-15轮即可。SoVITS可以多训练一些。
其他保持默认即可。
推理 刷新一下模型路径，选择训练好的模型。选择数字最大的即可。选中开启TTS推理页面。
刷新模型路径，选择匹配的GPT和SoVITS模型。
需要上传说话者一段3-10秒内的声音片段。这个声音片段会影响生成结果的语速和情绪（这个声音片段对结果影响很大）。
上传的音频文本和语言类型。
需要生成的语音文本 标点符号会影响生成结果的停顿。把文本粘贴进去，选择语言和文本切割方式，参数默认，点击合成语音等待生成结果。即使训练的数据没有英文和日文，也可以生成英文和日文音频。
文本切割工具 和上面的文本切割功能一样。将大段文字切割。
注意 模型训练过程中GPU会发热，请在有人监控的情况下进行，温度过高及时停止（在控制台输入CTRL+C）以防发生意外。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b86d7cf66ede99914fb40f58ba8b9de/" rel="bookmark">
			Redis报错：CROSSSLOT Keys in request don‘t hash to the same slot的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，项目上线的时候，出现了一个Redis的报错：CROSSSLOT Keys in request don't hash to the same slot，这个在内网环境下无法复现，因为正式环境的Redis是cluster集群模式，而我们内网环境是单机模式。(后面我在内网也部署了一个Redis集群，具体见我这一篇文章 《使用Docker搭建Redis Cluster集群》）
Redis集群的slot概念 Redis的插槽(Slot)是用于实现集群分片(Cluster Sharding)的一种机制。Redis集群至少需要三个结点，每个结点处理一部分数据。那么怎样分配这些数据到各个结点呢？Redis Cluster 采用的是虚拟槽分区算法，其中提到了槽（Slot）的概念。这个槽是用来存放缓存信息的单位，在 Redis 中将存储空间分成了 16384 （ 2 14 {2}^{14} 214）个槽，也就是说 Redis Cluster 槽的范围是 0 -16383。
在存储数据的时候，集群会对 Key 进行 CRC16 校验并对 16384 取模：
slot = CRC16(key) % 16384
得到的结果就是 Key-Value 所放入的槽，从而实现自动分割数据到不同的节点上
为什么会是16384个插槽呢？Redis作者是这么说的：传送门
什么情况下会报这个错 在集群模式下，所有涉及到多个 key的Redis指令，都要求所有的 key处于同一个 slot，如果 slot不同，哪怕实际上这些 slot都在同一个结点上，也会报这个错：
CROSSSLOT Keys in request don't hash to the same slot
例如以下这些操作：
SUNIONSTORE destination key [key ...] SDIFF key [key .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b86d7cf66ede99914fb40f58ba8b9de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f2309a74edf185c9d4cf4c039995cd/" rel="bookmark">
			python用ffmpeg合并大量ts文件为mp4视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用于在本地需要拼接大量的.ts文件
代码如下：
# /usr/bin/env python # -*- coding: utf-8 -*- import datetime import os def test(path, save_path): """path是需要合并的路径, save_path是保存路径""" # 首先获取当前路径下的文件名列表，并判断是否存在一个名为 file_list.txt 的文件，如果存在则删除 file_names = os.listdir(path) if 'file_list.txt' in file_names: os.remove(path+'file_list.txt') # 定义一个输出文件名，并判断输出文件名是否已经存在，如果存在则添加“新”前缀 out_file_name = 'output.mp4' while out_file_name in os.listdir(save_path): out_file_name = '新' + out_file_name # 读取当前路径下所有 ts 文件，并对 ts 文件名进行排序，根据文件名的数字部分进行排序 ts_files = [f for f in os.listdir(path) if f.endswith('.ts')] sorted_files = sorted(ts_files, key=lambda x: int(x.split('.')[0])) # 打开一个名为 file_list.txt 的文件，并将合并后的 ts 文件路径写入文件 with open(path+'file_list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f2309a74edf185c9d4cf4c039995cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24bcb7216c3d603bd85c77c926ec44b5/" rel="bookmark">
			使用新一代一站式 AI Bot 开发平台扣子coze，搭建我的第一个AI Bot(前端魔法师) ,
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述​
2.功能与优势
3.使用扣子
4.人设与回复逻辑
5.添加插件
6.预览与调试
7.发布bot Store
8.环境大家体验（给大家内置了比较屌的插件） 9.推荐阅读：
1.概述​ 扣子是新一代一站式 AI Bot 开发平台。无论你是否有编程基础，都可以在扣子平台上快速搭建基于 AI 模型的各类问答 Bot，从解决简单的问答到处理复杂逻辑的对话。而且你可以将搭建的 Bot 发布到各类社交平台和通讯软件上，让更多的用户与你搭建的 Bot 聊天。
2.功能与优势 无限拓展的能力集 扣子集成了丰富的插件工具，可以极大地拓展 Bot 的能力边界。
内置插件：目前平台已经集成了超过 60 款各类型的插件，包括资讯阅读、旅游出行、效率办公、图片理解等 API 及多模态模型。 你可以直接将这些插件添加到 Bot 中，丰富 Bot 能力。例如使用新闻插件，打造一个可以播报最新时事新闻的 AI 新闻播音员。自定义插件：扣子平台也支持创建自定义插件。 你可以将已有的 API 能力通过参数配置的方式快速创建一个插件让 Bot 调用。丰富的数据源 扣子提供了简单易用的知识库功能来管理和存储数据，支持 Bot 与你自己的数据进行交互。无论是内容量巨大的本地文件还是某个网站的实时信息，都可以上传到知识库中。这样，Bot 就可以使用知识库中的内容回答问题了。
内容格式：知识库支持添加文本格式、表格格式的数据。内容上传： 你可以将本地 TXT、PDF、DOCX、Excel、CSV 格式的文档上传至知识库，也可以基于 URL 获取在线网页内容和 API JSON 数据。同时支持直接在知识库内添加自定义数据。持久化的记忆能力 扣子提供了方便 AI 交互的数据库记忆能力，可持久记住用户对话的重要参数或内容。
例如，创建一个数据库来记录阅读笔记，包括书名、阅读进度和个人注释。有了数据库，Bot 就可以通过查询数据库中的数据来提供更准确的答案。
灵活的工作流设计 扣子的工作流功能可以用来处理逻辑复杂，且有较高稳定性要求的任务流。扣子提供了大量灵活可组合的节点包括大语言模型 LLM、自定义代码、判断逻辑等，无论你是否有编程基础，都可以通过拖拉拽的方式快速搭建一个工作流，例如：
创建一个搜集电影评论的工作流，快速查看一部最新电影的评论与评分。创建一个撰写行业研究报告的工作流，让 Bot 写一份 20 页的报告。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24bcb7216c3d603bd85c77c926ec44b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1196f0446dd9990e10f13eeb2ff6c26a/" rel="bookmark">
			mac 卸载node
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先查看本地node安装 node -v 如果出现版本号说明安装了node
使用命令行卸载node
1、打开终端，输入which node 查看node的安装路径
：/usr/local/bin/node
2、第二步：输入以下命令删除 Node.js 相关的文件：
sudo rm -rf /usr/local/bin/npm
sudo rm -rf /usr/local/share/man/man1/node.1
sudo rm -rf /usr/local/lib/dtrace/node.d
sudo rm -rf ~/.npm
sudo rm -rf ~/.node-gyp
sudo rm /usr/local/bin/node
3、再次输入node -v查看版本好，不出现版本号说明卸载成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2689d89daa548bc110790d838a21df2/" rel="bookmark">
			Spark-机器学习（1）什么是机器学习与MLlib算法库的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从这一系列开始，我会带着大家一起了解我们的机器学习，了解我们spark机器学习中的MLIib算法库，知道它大概的模型，熟悉并认识它。同时，本篇文章为个人spark免费专栏的系列文章，有兴趣的可以收藏关注一下，谢谢。同时，希望我的文章能帮助到每一个正在学习的你们。
Spark-大数据技术与应用https://blog.csdn.net/qq_49513817/category_12641739.html
目录
一、什么是机器学习
机器学习 发展历史 机器学习模型
监督模型
无监督模型
概率模型 二、MLlib算法库
什么是MLlib算法库
MLlib的方法：
一、什么是机器学习 个人认为，机器学习是一个非常庞大的概念，不论是它本身的模型，运用它是产生的海量数据与决策，还是它那涵盖了众多的模型、算法和技术。并且随着技术的不断进步和应用领域的不断拓展，机器学习的影响力和重要性也将继续提升，所以，机器学习目前的热度高，未来很长时间内也不会衰减甚至更值得学习。
机器学习 机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能核心，是使计算机具有智能的根本途径。
机器学习算法通过从数据中自动分析和学习规律，使计算机能够自动获取新知识和能力。它可以处理大量的复杂数据并从中提取出有用的信息，并根据不断的经验来改善自身的性能。机器学习算法构建一个基于样本数据的数学模型，即“训练数据”，以便在没有明确编程来执行任务的情况下进行预测或决策。
发展历史 机器学习的发展可以追溯到上世纪50年代。1952年，Arthur Samuel在IBM开发了第一个自我学习程序，这标志着机器学习的起步。此后，随着技术的发展，机器学习领域不断取得突破，包括感知机、最近邻算法、决策树、随机森林等算法的提出，以及深度学习的兴起。这些创新推动了机器学习在各个领域的应用和发展。 有监督学习： 聚类：
概率图模型：
深度学习： 强化学习：
机器学习模型 机器学习模型图
监督模型 工作原理：
数据标注：在监督学习中，训练数据集中的每个样本都被标注了一个目标值或标签。这些标签可以是分类标签（如类别名称）或回归值（如连续的数字）。模型训练：算法使用这些带有标签的数据来训练模型。它学习如何根据输入特征预测目标值。预测与评估：一旦模型训练完成，它就可以用于对新的、未标注的数据进行预测。预测的准确性通常通过评估指标（如准确率、召回率、F1分数等）来衡量。 在监督模型中，我们常用的算法有：
线性回归：用于预测一个连续的目标值，基于输入特征与目标值之间的线性关系。逻辑回归：虽然名字中有“回归”，但实际上是一种分类算法，用于预测二分类或多分类问题。支持向量机（SVM）：通过找到一个超平面来最大化不同类别之间的间隔，从而进行分类。决策树：通过一系列的问题和答案来进行预测，每个问题都基于一个输入特征。随机森林：由多个决策树组成，通过集成多个树的预测结果来提高准确性。神经网络：模拟人脑中的神经元结构，通过多层网络进行学习和预测。 广泛应用在：
图像识别：识别图像中的物体或场景。自然语言处理：情感分析、文本分类、机器翻译等。金融领域：信用风险评估、股票价格预测等。医疗诊断：基于医疗图像或患者数据预测疾病。 监督学习模型是机器学习中的核心组成部分，它通过学习带有标签的数据来建立预测模型，并在各种实际应用中发挥着重要作用。
无监督模型 工作原理：
无监督学习模型通过对大量无标签数据进行迭代计算，自动地发现数据的结构和模式。这些模型通常基于数据的相似性、距离或其他度量来构建，从而将数据分组或降维。
在无监督模型中，我们常用的算法有：
聚类算法：如K-均值聚类（K-means）和层次聚类。这些算法将数据点划分为不同的组或簇，使得同一簇内的数据点尽可能相似，而不同簇之间的数据点尽可能不同。降维算法：如主成分分析（PCA）和自编码器。这些算法用于减少数据的维度，同时保留数据中的主要特征或结构。降维有助于减少计算复杂性、消除噪声并可视化高维数据。 广泛应用在：
图像处理：用于图像分割、特征提取和异常检测。社交网络分析：识别社区、用户群体和社交模式。市场分析：通过聚类分析消费者行为和市场趋势。自然语言处理：用于文本聚类和主题建模。 无监督学习模型为处理未标记数据提供了强大的工具，能够发现数据中的结构和模式，为各种实际应用提供了有力支持。 概率模型 工作原理：
在机器学习中，概率模型通过给定的数据来估计和计算不同事件或结果发生的概率。这通常涉及到数据的统计分析和概率推断，以确定模型参数的最优值。一旦模型建立完成，它就可以用于预测新数据的行为或结果，并根据概率分布给出相应的预测概率。
常用的算法有：
朴素贝叶斯算法：这是一种基于贝叶斯定理和特征条件独立假设的分类方法。它常用于文本分类、垃圾邮件过滤等任务。朴素贝叶斯算法根据先验概率和特征条件概率来计算后验概率，从而进行分类。根据应用场景的不同，朴素贝叶斯算法可以分为GaussianNB、MultinomialNB和BernoulliNB等变种。
隐马尔可夫模型（Hidden Markov Model, HMM）：HMM是一种统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。HMM常被用于时序数据的建模，如语音识别、自然语言处理等。
最大熵模型：最大熵原理是一种选择概率模型的原则，它认为在满足约束条件的模型集合中，选择熵最大的模型是最好的模型。最大熵模型可以用于各种分类和回归任务。
概率图模型：包括一系列基于图结构的概率模型，如马尔可夫随机场、信念网络等。这些模型通过图来表示变量之间的关系，并利用图论和概率论的方法来进行推理和学习。
混合高斯模型（Gaussian Mixture Model, GMM）：GMM是一种概率模型，它假设所有数据都是由有限个高斯分布混合而成的。GMM常用于聚类分析和密度估计。
期望最大化算法（Expectation-Maximization, EM）：EM算法是一种迭代方法，常用于概率模型中的参数估计。它通过在E步（期望步）计算期望，然后在M步（最大化步）最大化这个期望，来找到参数的最优估计。
变分推断（Variational Inference）：这是一种在概率图模型中进行近似推断的方法。它通过优化一个易于处理的分布来近似难以处理的真实后验分布。
蒙特卡洛方法：这是一种基于随机抽样的统计方法，用于估计复杂函数的积分和解决各种概率问题。在机器学习中，蒙特卡洛方法常用于模型参数的估计和复杂概率分布的计算。
二、MLlib算法库 什么是MLlib算法库 MLlib是Spark的机器学习库，旨在简化机器学习的工程实践工作，并方便扩展到更大规模的数据集。它提供了一组丰富的机器学习算法和工具，用于数据预处理、特征提取、模型训练和评估等任务。MLlib是基于Spark的分布式计算引擎构建的，可以处理大规模数据集，并利用分布式计算的优势来加速机器学习任务的执行。
MLlib提供了丰富的算法实现，包括线性回归、逻辑回归、决策树、随机森林、梯度提升树、K-means聚类等，以及用于特征提取、转换和选择的工具。此外，MLlib还支持使用管道（Pipeline）API将多个机器学习步骤组合成一个统一的流程，从而简化模型训练和调优的过程。
MLlib的方法： 方法作用使用方式分类用于预测离散型目标变量使用MLlib的分类算法（如逻辑回归、决策树、随机森林等）训练模型，然后对新的数据进行预测。回归用于预测连续型目标变量使用MLlib的回归算法（如线性回归、决策树回归等）训练模型，用于预测数值型结果。聚类用于将数据划分为具有相似性的不同簇利用MLlib的聚类算法（如K-means）对数据进行分组，发现数据中的结构和模式。协同过滤用于推荐系统中的用户或物品的相似度计算应用MLlib的协同过滤算法，根据用户的历史行为和其他用户的相似性生成推荐。特征工程提取、转换和选择特征，提高模型性能使用MLlib的特征化工具进行特征提取、降维、转换和选择，优化特征表示。管道(Pipeline)构建、评估和调整机器学习管道利用MLlib的管道API，将多个机器学习步骤组合成一个统一的流程，方便管理和调优。模型持久化保存和加载模型，以便复用和部署使用MLlib的持久化功能，将训练好的模型保存到文件或数据库中，方便后续的预测和部署。 最后，MLlib是基于Spark的分布式计算引擎构建的，因此在使用MLlib时，我们需要熟悉Spark的基本概念和编程模型，如RDD（弹性分布式数据集）和DataFrame等。通过编写Spark应用程序，我们可以利用MLlib提供的算法和工具来处理大规模数据集，并进行高效的机器学习任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2689d89daa548bc110790d838a21df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c213ae1c9c3b45d1d8d9f4640f1dbe6e/" rel="bookmark">
			【SpringCloud】Eureka基于Ribbon负载均衡的调用链路流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.调用形式2.LoadBalancerInterceptor3.负载均衡流程分析3.1 调用流程图3.2 intercept（）方法3.3 execute（）方法3.4 getServer()方法3.4 子类的chooseServer（）方法3.5 getLoadBalancerStats().getAvailableZones().size() &lt;= 13.6 父类的chooseServer()方法3.7 IRule接口下的实例3.8 最终的choose()方法—return server3.9 choose()方法内部分析 4. 彩蛋 前言 微服务间相互调用的基础上，服务间的调用更多是以调用某多实例服务下的某个实例的形式。而这就需要用到负载均衡技术。对于开发者而言，只要通过@LoadBalance注解就开启了负载均衡。如此简单的操作底层究竟是什么样的，我想你也很想知道。
1.调用形式 在《SpringCloud集成Eureka并实现负载均衡》的基础之上，我们可以进行一个小小的实验，debug运行程序，通过postman发起一个请求，A服务会去远程调用B服务，debug发现发送的url为：http://user-service/user/1，毫无疑问的是，这就是A调用B的途径
同样地，拿到这个url我们去postman里发送请求：
发现请求无法发送出去，路径出了问题。观察路径中的参数user-service发现他是B服务的服务名称，那为什么在A服务里向B服务发送“服务名称-接口路径-参数”形式的请求就能够正常响应？
结合集成负载均衡的过程，这一定是Ribbon在发挥作用
2.LoadBalancerInterceptor 负载均衡的前提不是传递一个具体的url，肯定是Ribbon做了某种解析，通过服务名称得到了服务下的实例列表，从而拉取Eureka-Server中的服务注册表来将请求映射到指定的某个实例上。
结合曾经前后端分离的web开发经验，后端经常会在拦截器中拦截前端发来的请求来对请求做一些操作，比如校验、拼接、鉴权…调用方发送请求和接收方收到的请求并不一致，这其中会不会也是有一个类似于拦截器的东西拦截了请求，并且转换了请求呢？
答案是必然的，那是谁——LoadBalancerInterceptor
可以看到的是，他实现了ClientHttpRequestInterceptor接口，具体用法细节直接去看接口中声明的方法
直观的看出接口中声明了一个intercept()方法并且接受了HttpRequest参数来拦截了客户端的http请求，并且修改的请求体！这么一看URL更改的谜底就在此处揭晓了，那么方法底层具体是怎么实现的呢：
3.负载均衡流程分析 3.1 调用流程图 Debug源码之前先来看一下源码中的调用链路总体流程图（手图）：
概括来看则是：拦截请求—读取服务—拉取服务列表—选择规则—返回服务实例
3.2 intercept（）方法 下面我们开始Debug:
1.当发送请求使得服务间发生调用关系，调用请求会先传递到拦截器中的intercept方法，可以看到的是目前还和发送是保持一致
2.继续向下执行，开始解析请求，拿到了请求中的URI——通过getHost()方法拿到了主机地址（服务的名称）
3.3 execute（）方法 3.Ribbon开始做负载均衡处理
4.两次步入之后进入到execute（）方法内部，发现传递进来的服务名称作为服务Id进入到了getLoadBalance（）方法，并且得到了一个ILoadbalance接口对象，而在该对象中封装了很多的信息：
这里记住服务实例id的值：host.docker.internal:8084，这就是Eureka客户端接收到的实例信息
3.4 getServer()方法 5.接口对象作为参数传递到了getServer()方法,得到了一个server对象进入到方法内部。发现与此同时传递了一个Object类型的对象用于指定服务器的规则或条件，不过到目前为止，这个参数一直都是null作为传递，即loadBalancer.chooseServer（）方法采用的是‘default’的方式进行选择
3.4 子类的chooseServer（）方法 6.再次步入到chooseServer（）方法，发现是在一个名为BaseLoadBalancer类（这个类是负载均衡器的具体实现后面会具体分析）下重写的父类方法
此时：可以判断的是getLoadBalancerStats().getAvailableZones().size() &lt;= 1为TRUE
3.5 getLoadBalancerStats().getAvailableZones().size() &lt;= 1 对于表达式：getLoadBalancerStats().getAvailableZones().size() &lt;= 1进行分析
发现在BaseLoadBalancer类中通过继承抽象类AbstractLoadBalancer并重写getLoadBalancerStats()抽象方法，获取到了一个loadbalancer统计信息集合LoadBalancerStats
而封装在LoadBalancerStats中的信息里有一个ConcurrentHashMap类型的集合属性，即
volatile Map&lt;String, List&lt;? extends Server&gt;&gt; upServerListZoneMap = new ConcurrentHashMap&lt;String, List&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c213ae1c9c3b45d1d8d9f4640f1dbe6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee4c6d587580182ebc350e6910ff177/" rel="bookmark">
			【Spring Boot】深入解密Spring Boot日志：最佳实践与策略解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓 博客主页：从零开始的-CodeNinja之路
⏩ 收录文章：【Spring Boot】深入解密Spring Boot日志：最佳实践与策略解析
🎉欢迎大家点赞👍评论📝收藏⭐文章
目录 Spring Boot 日志一. 日志的概念?二. 日志2.1 日志的格式2.2 日志级别2.3 日志的使用 三. 门面模式(外观模式)四. SLF4J框架总结 Spring Boot 日志 一. 日志的概念? 日志对我们来说并不陌⽣,通过打印日志来发现和定位问题,或者根据日志来分析程序的运行过程.
日志的用途
Spring Boot中的日志管理是非常重要的，它可以帮助开发人员在应用程序运行时跟踪问题、监控性能并记录关键信息。通过配置适当的日志级别和输出格式，开发人员可以更好地理解应用程序的行为并快速定位和解决问题。Spring Boot提供了灵活且强大的日志管理功能，使开发人员能够轻松地集成和配置各种日志框架，如Logback、Log4j2等，以满足不同项目的需求。
二. 日志 2.1 日志的格式 从上图可以看到，日志输出内容元素具体如下：
时间日期：精确到毫秒日志级别：ERROR,WARN,INFO,DEBUG或TRACE进程ID线程名Logger名(通常使用源代码的类名)日志内容 2.2 日志级别 日志级别代表着日志信息对应问题的严重性,为了更快的筛选符合⽬标的日志信息.
日志的级别从高到低依次为:FATAL、ERROR、WARN、INFO、DEBUG、TRACE
FATAL:致命信息，表示需要立即被处理的系统级错误.ERROR:错误信息,级别较⾼的错误日志信息,但仍然不影响系统的继续运行WARN:警告信息,不影响使用,但需要注意的问题INFO:普通信息,用于记录应用程序正常运行时的⼀些信息,例如系统启动完成、请求处理完成等.DEBUG:调试信息,需要调试时候的关键信息打印.TRACE:追踪信息,比DEBUG更细粒度的信息事件(除非有特殊⽤意，否则请使用DEBUG级别替代) 日志级别的顺序：
级别越高,收到的消息越少
2.3 日志的使用 SpringBoot内置了日志框架 Slf4j ,我们可以直接调用 Slf4j 来输出日志
添加lombok依赖
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 输出⽇志
lombok提供的 @Slf4j 会帮我们提供⼀个日志对象log,我们直接使用就可以.
import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.RestController; @Slf4j @RestController public class LogController { public void log(){ log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cee4c6d587580182ebc350e6910ff177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfbf37fb24204c7df9956965a2761fd/" rel="bookmark">
			【C&#43;&#43;庖丁解牛】哈希表/散列表的设计原理 | 哈希函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍁你好，我是 RO-BERRY 📗 致力于C、C++、数据结构、TCP/IP、数据库等等一系列知识 🎄感谢你的陪伴与支持 ，故事既有了开头，就要画上一个完美的句号，让我们一起加油 目录 前言1.哈希概念2.哈希冲突3.哈希函数4.哈希冲突解决4.1闭散列4.2 开散列 前言 unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。
1.哈希概念 哈希又称为散列，有些书上对于哈希取名为散列表，其本质就是一个存储的值和存储的位置的映射
顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O( l o g 2 N log_2 N log2​N)，搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。
如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
当向该结构中：
插入元素
根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放搜索元素
对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功 该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)
例如：数据集合{1，7，6，4，5，9}；
哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。
用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快
问题：按照上述哈希方式，向集合中插入元素44，会出现什么问题？
使用上面这个方法就可以发现44 % 10 = 4，就会出现哈希冲突/哈希碰撞，不同的值可能会映射到相同的位置，一个空间只能存储一个值，就会出现冲突
2.哈希冲突 对于两个数据元素的关键字 k i k_i ki​和 k j k_j kj​(i != j)，有 k i k_i ki​ != k j k_j kj​，但有：Hash( k i k_i ki​) == Hash( k j k_j kj​)，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfbf37fb24204c7df9956965a2761fd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/419/">«</a>
	<span class="pagination__item pagination__item--current">420/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/421/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>