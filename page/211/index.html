<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3916e08f18461d0edada87083a01e9fe/" rel="bookmark">
			独辟蹊径：我是如何用Java自创一套工作流引擎的（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：后端小肥肠
创作不易，未经允许严禁转载。
姊妹篇：独辟蹊径：我是如何用Java自创一套工作流引擎的（上）_java工作流引擎-CSDN博客
1. 前言 在上一篇博客中，我们详细介绍了如何利用Java语言从零开始打造一套工作流引擎的基础架构。通过设计核心表结构和实现基础代码框架，我们建立了一个坚实的理论基础。今天，我们迈入《独辟蹊径：我是如何用Java自创一套工作流引擎的（下）》，将深入探讨这一引擎在实际项目中的应用和效果。
2. 项目场景模拟 本章我们将以实际项目场景来模拟自研工作流引擎的使用，分别是申请数据资源的流程和请假申请流程。
2.1. 申请数据资源流程 2.1.1. 技术流程 假设申请数据的审批级数为2级。申请数据资源的流程图如下：
在上述流程图中，从普通用户，一级审批人员，二级审批人员视角呈现了申请数据资源的整体流程；
1. 用户提交审批数据表单，填入申请人信息（姓名、电话），申请理由和需要申请的数资源；
2. 一级审批人员收到用户提交的申请后进行审批，如果驳回则整个流程结束，如果通过则进入下一审批环节；
3. 一级审批通过后二级审批人员可进行审批，如果驳回则整个流程结束，如何通过则开放数据下载链接，用户可根据链接下载申请的数据。
2.2. 请假申请流程 2.2.1. 技术流程 请假流程如下：
在上述流程中，从用户和一级审批人员的角度呈现了整个请假流程：
1. 用户提交审批数据表单，填入申请人信息（姓名、电话）、申请理由、请假天数；
2. 一级审批人员收到用户提交的申请后进行审批，如果驳回则整个流程结束，同时通知用户流程未通过，如果通过则结束流程。
2.3. 技术实现 要在工作流中集成以上两套流程，需要基于一下几个步骤实现：
1. 设计流程定义，在business_approval_workflow新建数据审批流程和请假流程。
2. 设计流程细节，设计数据审批流程和请假流程的节点细节。
上图中，申请业务数据包含两个流程节点，第一个节点审批人为admin，第二个节点审批人为super；请假流程包含一个流程节点，审批人为admin。
3. 编写提交申请接口。
提交申请业务数据流程接口直接使用《独辟蹊径：我是如何用Java自创一套工作流引擎的（上）》中提交申请接口就行：
public Boolean addRequest(RequestDTO requestDTO) { Request request= BeanCopyUtils.copyBean(requestDTO,Request.class); request.setStatus("1");//设置整个流程状态为正在审核 // 1. 插入数据到 request 表 baseMapper.insert(request); // 2. 根据 workflow_id 查询业务流程的节点信息，找到 serial_number 为 1 的节点,即流程开始时的第一个节点 BusinessApprovalWorkflowDetail firstNode = workflowDetaiSlService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3916e08f18461d0edada87083a01e9fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f73721e9e6db331e374932afeea13f/" rel="bookmark">
			RPC远程过程调用--Thrift
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPC远程过程调用–Thrift 简介 Thrift是一个由Facebook开发的轻量级、跨语言的远程服务调用框架，后进入Apache开源项目。支持通过自身接口定义语言IDL定义RPC接口和数据类型，然后通过编译器生成不同语言代码，用于构建抽象易用、可互操作的RPC客户端和服务器。Thrift软件栈分层从下向上分别为：传输层(Transport Layer)、协议层(Protocol Layer)、处理层(Processor Layer)和服务层(Server Layer)。具有开发速度快、易维护、高效、跨语言（C++、 Java、Python、PHP、Ruby、C#、、JavaScript、Node.js、等）优点应用广泛：hadFacebook和 安装（源码编译安装） 下载源码
https://github.com/apache/thrift
安装编译工具和依赖项
sudo apt install build-essential automake bison flex libtool pkg-config 解压后配置和编译 ./bootstrap.sh ./configure make 安装 sudo make instal 配置环境变量和映射库 echo 'export PATH="/usr/local/bin:$PATH"' &gt;&gt; ~/.bashrc source ~/.bashrc 更新库缓存
sudo ldconfig
查看安装结果
thrift --version Thrift version 0.21.0 远程过程调用服务器客户端Demo 编写Thrift IDL 文件&lt;calculator.thrift&gt;定义服务或数据类型 namespace cpp tutorial service Calculator { i32 add(1:i32 num1, 2:i32 num2) } 使用thrift编译器生成C++代码 thrift --gen cpp test.thrift - 编写服务器和客户端应用代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f73721e9e6db331e374932afeea13f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/484fc565bb5a9e4072cab1484b2dc80d/" rel="bookmark">
			python教程---网络爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7.1 urllib Urllib是Python内置的一个用于读取来自Web的数据的库。它是一个请求库，可以用来发送HTTP请求，获取网页内容，支持多种HTTP方法，如GET和POST等。
使用Urllib读取网页内容的步骤如下：
导入Urllib库中的request模块。 import urllib.request 使用urlopen()函数发送HTTP请求，获取网页内容。 response = urllib.request.urlopen('http://www.example.com') 读取获取到的内容。可以使用read()、readline()和readlines()方法。 html = response.read() 对获取到的内容进行解码，以便得到字符串形式的内容。 html = html.decode('utf-8') 关闭响应对象。 response.close() 示例：
import urllib.request url = 'http://www.example.com' response = urllib.request.urlopen(url) html = response.read() html = html.decode('utf-8') print(html) response.close() 以上代码使用Urllib读取了http://www.example.com网站的内容，并将其打印出来。
7.2 正则表达式 正则表达式（Regular Expression，简称RegEx）是一种用于匹配字符串中字符组合的模式。在Python中，re模块提供了正则表达式的支持。正则表达式在网络爬虫中常用于解析网页内容，提取需要的数据。
使用正则表达式的基本步骤如下：
导入re模块。 import re 编写正则表达式模式。正则表达式的语法规则包括字符匹配、量词、分组等。使用re模块提供的方法进行匹配。常见的方法有： re.search(pattern, string): 在字符串中搜索模式，返回第一个匹配项的匹配对象。re.match(pattern, string): 从字符串的起始位置匹配模式，返回匹配对象。re.findall(pattern, string): 在字符串中找到所有匹配项，返回一个列表。re.finditer(pattern, string): 在字符串中找到所有匹配项，返回一个迭代器。re.sub(pattern, repl, string): 替换字符串中所有匹配的子串。
示例： import re # 示例文本 text = "Hello, my phone number is 123-456-7890.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/484fc565bb5a9e4072cab1484b2dc80d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7d3c623bc9ece22ec6b4cfb9c07ce7/" rel="bookmark">
			【深度学习】扫描全能王的AI驱动创新与智能高清滤镜技术解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言1、扫描全能王2、智能高清滤镜黑科技2.1、图像视觉矫正2.2、去干扰技术 3、实际应用案例3.1、打印文稿褶皱检测3.2、试卷擦除手写3.3、老旧文件处理3.4、收银小票3.5、从不同角度扫描文档 4、用户体验结论与未来展望 引言 在数字化时代背景下，文档扫描功能正逐渐成为企业和个人提高工作效率、确保信息安全、实现远程协作的重要工具。随着技术的发展，文档扫描不再局限于传统的扫描仪，而是通过人工智能技术如AI的融合，实现了更为高效、精准的图像处理能力。
1、扫描全能王 今天给朋友们介绍一款很实用的扫描软件“扫描全能王”，它是合合信息旗下的产品。主打智能扫描和多设备同步，其内置的“智能高清滤镜”功能十分强大，可以自动切边、图像美化、自动矫正等，客户端支持iOS、Android、macOS，Web版本。
朋友们可以从苹果官方商店进去，搜搜“扫描全能王”，图标带CS的就是正品。而且“扫描全能王”产品一直在升级更新中，看看版本历史记录，AI功能越来越强大了。
2、智能高清滤镜黑科技 扫描全能王的“智能高清滤镜”功能是其在文档扫描应用中的一大创新，它利用AI技术为用户带来了前所未有的便捷体验。 “智能高清滤镜”通过先进的图像处理算法，能够自动检测图像中的多种问题，如模糊、阴暗、手指遮挡等。AI算法对这些问题进行智能识别，并应用相应的优化策略，无需用户手动调整，即可一键获得高质量的扫描结果。
2.1、图像视觉矫正 曲面矫正是基于深度学习的曲面检测和矫正技术，它通过深度学习网络对文档图像进行曲面矫正和透视变换，有效解决了文档形状不规则和拍摄角度导致的视觉变形问题。
图像视觉矫正技术使得扫描全能王在处理复杂的扫描任务上具有独特的优势。它不仅可以处理平面文档的扫描，还可以处理各种曲面文档的扫描，甚至能够处理在极端角度下拍摄的文档。
下图的书籍页面就是个曲面，并且光线不足，但是通过图像视觉矫正技术处理后，文档不仅解决了阴暗的问题，曲面也得到了矫正，最后得到了一张非常完美的文稿。
2.2、去干扰技术 文档在拍摄中受光照、环境影响，经常会有阴影、手指、摩尔纹（屏幕纹）等干扰，扫描全能王去干扰技术可以很好地处理这些降低图片质量的因素。
在阴影去除方面，扫描全能王采用了深度学习网络来检测和消除文档中的阴影。它采用了类似于U-Net的网络结构，该网络可以在识别出阴影的同时，保存原有文档的细节信息。
在去手指部分，扫描全能王可以精确地识别和分割出图像中的手指。然后，通过图像修复技术，基于深度学习的图像修复技术，替换掉图像中的手指部分，使得整个文档看起来就像从未被手指遮挡过一样。
3、实际应用案例 3.1、打印文稿褶皱检测 有些打印文稿由于时间久，加上保管不当，出现了褶皱。这时我们可以用上扫描全能王的“智能高清滤镜”功能，会帮助我们去除打印文稿上的褶皱。
3.2、试卷擦除手写 现在进行是试卷的测试，最初的试卷有大片的阴影，折痕、边角弯曲等，而且试卷已经是写过答案并批改过的状态，我们现在想要把手写部分包括批改，都给自动处理掉，还原试卷最初的模样。
可以看到下图，试卷上弯曲、折痕、手写都非常明显，但在扫描全能王的“智能高清滤镜”功能下，文档秒变干净，图上的答题痕迹和批改痕迹，全都神奇的消失了。
3.3、老旧文件处理 这次我们再来测试下旧文件的处理，这里是一张1963年的奖状，我们使用扫描全能王的“智能高清滤镜”功能来处理。
处理过程中在APP上的截图：
处理高清结果：
3.4、收银小票 这是很久以前的一张小票，小票上的瑕疵比较多，褶皱比较多、光线不均匀、小票边缘弯曲。
我们在使用扫描全能王扫描小票，处理后的小票，很明显的褶皱不见了，整体背景呈白色，边缘弯曲也矫正了。而且处理后的小票，字迹也非常清晰，菜品、价格等都清晰可见。
3.5、从不同角度扫描文档 这一次我们使用扫描全能王扫描书籍，认为制造难度，从倾斜的角度拍。
扫描全能王扫描书籍后，会用AI矫正技术，把文档变为了字迹排列整齐的平面文档。
4、用户体验 在上述操作过程中，结果一次比一次惊艳，不仅仅能处理褶皱、曲面等不规则版面，而且对于透字处理非常干净利索。但最令人难忘的是老旧文件的处理，第一是字处理的很好，第二也是奖状画框都给处理的非常完美，扫描全能王的“智能高清滤镜”功能不仅能还原色彩，而且还增强了清晰度，文档处理效果更加，颜色保留效果更佳。
这些也都是扫描全能王的“智能高清滤镜”功能，其基于深度学习技术自适应感知文档图像中的不同元素（透字、颜色区域、文字区域），通过像素值回归学习，抑制透字噪声、恢复文字笔迹，保留颜色。
在操作过程中，几乎遇不到任何阻碍，上述功能都是一键生成，通过AI把处理好的结果呈现在我们面前。当然喜欢自己动手的朋友也不会失望，APP里也提供滤镜功能，对处理好的文件，有提供原图、智能高清、去阴影、增强并锐化、增亮、黑白等多种滤镜效果，以满足不同用户的需求。
结论与未来展望 扫描全能王“智能高清滤镜”功能，把文件处理和AI技术结合，使得文件处理不再是难事。产品图像视觉矫正、去干扰技术两项技术含金量十足，放在市场上也是称霸的地位。
今天在操作过后，只有一个感想：扫描全能王文档处理+AI，真的是划时代的产品。
以往我们需要专业人员用3、4个软件花费2天做的事情，现在使用扫描全能王，只需要几分钟就能搞定了。以往需要找专业领域人才来做的事情，普通人安装扫描全能王APP,也可以处理好。
总结来说，扫描全能王“智能高清滤镜”功能划时代的革新，给用户带来了十分完美的使用体验，提供了相关领域从业者的效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc37ff6bc246920e29c20bc37766a97c/" rel="bookmark">
			C&#43;&#43;程序实现加密和解密算法的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件 #include&lt;bits/stdc++.h&gt; #include&lt;windows.h&gt; #define GetGoTo(A) A: #define GoTo(A) goto A #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,"Ofast","inline") using namespace std; const string VERSION="V3.2.2"; bool EncryptionLock,DecryptionLock,NumberLock; long long Bin[]={128,64,32,16,8,4,2,1}; long long ProblemNumber; struct ProblemList{ string Problem; string Types; string Source; long long data; }ProblemList_One[500]; void Initialization(bool EncryptionLock,bool DecryptionLock,bool NumberLock){ srand(time(NULL)); ::EncryptionLock=EncryptionLock; ::DecryptionLock=DecryptionLock; ::NumberLock=NumberLock; return; } string Encryption(string strk,string &amp;keyt){ if(!EncryptionLock){ ProblemList_One[ProblemNumber].Problem="You haven't opened EncryptionLock."; ProblemList_One[ProblemNumber].Types="Error"; ProblemList_One[ProblemNumber].Source="&lt;Encryption And Decryption "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc37ff6bc246920e29c20bc37766a97c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb22b328e57ca4827d9bfc9d689c365/" rel="bookmark">
			【大数据导论】大数据序言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位大佬好 ，这里是阿川的博客，祝您变得更强 个人主页：在线OJ的阿川
大佬的支持和鼓励，将是我成长路上最大的动力
阿川水平有限，如有错误，欢迎大佬指正
目录 数据概念及类型及可用及组织形式数据概念数据类型数据的可用数据组织形式 大数据的时代大数据技术 中国大数据未来 数据概念及类型及可用及组织形式 数据概念 数据
对客观事件进行记录并可以鉴别的符号是构成信息的基本单位 数据类型 数据类型
文本（字符型数据） 文本文件常见格式：
图片 图片常见格式：
音频 音频常见格式：
视频 视频常见格式：
数据的可用 step1.数据清洗
将脏乱数据进行清洗；将数据缺失和语义模糊等数据进行处理；数据类型不符合可进行转换及解析
其中转换及解析常用工具和脚本语言：
step2.数据管理
将第1步后的数据放入数据库系统中进行管理和使用 step3.数据分析
将第2步后的数据利用数据挖掘和机器学习算法和构建统计模型（其中首选R语言及它的CRAN综合类库）及大数据处理技术（主要为谷歌的分布式编程模型MapReduce，Hadoop对其进行开源实现）进行分析 补充环节
step3.1 数据可视化
用图像等可视化，帮助人们进行直观理解数据 数据组织形式 文件
文件由文件系统进行管理
数据库（软件开发的基础与核心）
其中，关系数据库是之前主流的数据库，具有三种特性：
提供SQL语句进行各种查询操作支持事务一致性功能满足各种商业应用需求 其中，NoSQL数据库主要处理非结构化数据，而目前海量数据中90%都属于非结构化数据。
在现在及未来的时代中，NoSQL数据库的使用将是大势所趋
大数据的时代 在如今的时代，数据的产生正处于爆炸式的增长
如今不管是移动端还是PC端、Mac端，甚至传感器、摄像头亦或是各种设备（家用电器电视汽车等等）无时无刻不在产生着大量的数据
大数据的时代已经来临，随着时代的发展越加迅猛
与此同时，对数据的储存、处理与分析提出了更高的要求
与之所对应的 物联网、云计算和大数据孕育而生。
大数据的四个特性
数据量大 （PB级别甚至到EP、ZP级别） 数据类型繁多 （可以是文本、图片、视频、音频等非结构化类型）处理速度快 （每秒钟处理GB数据甚至更高）价值密度低 （海量数据中，符合条件的单点数据价值密度高）
大数据技术 大数据技术的 前提要求
储存设备的容量需要强CPU处理能力需要强网络宽带传输需要强
（抖个包袱：所以说搞大数据的电脑设备还是要有要求的） 大数据技术 四个流程
数据采集与预处理数据储存与管理数据处理与分析数据可视化 中国大数据未来 大数据它是 赋能型专业 （可从大量的已知数据中进行计算，推出未知的理论）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adb22b328e57ca4827d9bfc9d689c365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6211b32f1de4750c4eb02161157655a7/" rel="bookmark">
			SAAS多租户系统的详细设计方案，后台数据库及各类框架详细设计方案-程序员必被的技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAAS多租户系统的详细设计方案 多租户（Multi-Tenant）架构是一种在单个软件实例中服务多个客户（租户）的设计方式。每个租户的数据和配置是独立的，但共享同一个应用程序和基础设施。设计一个高效的SAAS多租户系统需要考虑以下几个方面：架构设计、后台数据库设计、框架选择、数据隔离、安全性、可扩展性和性能优化。
1. 架构设计 1.1 多租户架构模式 单实例多租户（Single Instance, Multiple Tenants）：
共享数据库，独立表：所有租户共享同一个数据库，但每个租户有独立的数据表。共享数据库，共享表：所有租户共享同一个数据库和数据表，通过租户ID来区分数据。 多实例多租户（Multiple Instances, Multiple Tenants）：
每个租户有独立的应用实例和数据库实例。这种模式最能隔离租户，但成本较高。 1.2 基础架构 负载均衡器（Load Balancer）：分配用户请求到不同的应用服务器，确保系统的高可用性和性能。应用服务器（Application Server）：运行SAAS应用的业务逻辑。数据库服务器（Database Server）：存储和管理租户数据。缓存服务器（Cache Server）：如Redis，用于缓存数据，提高访问速度。文件存储（File Storage）：如Amazon S3，用于存储静态文件和用户上传的文件。 2. 后台数据库设计 2.1 数据库选择 关系型数据库：如MySQL、PostgreSQL，适合结构化数据存储。NoSQL数据库：如MongoDB、Cassandra，适合非结构化数据和高并发场景。 2.2 数据库模式 共享数据库，共享表：
表设计：所有租户的数据存储在相同的表中，通过租户ID区分。优点：资源利用率高，易于管理和维护。缺点：数据隔离性较差，安全性要求高。 CREATE TABLE users ( user_id INT AUTO_INCREMENT PRIMARY KEY, tenant_id INT, username VARCHAR(255), email VARCHAR(255), password VARCHAR(255), ... INDEX (tenant_id) ); 共享数据库，独立表：
表设计：每个租户有独立的数据表。优点：较好的数据隔离性。缺点：数据库管理复杂。 CREATE TABLE tenant1_users ( user_id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(255), email VARCHAR(255), password VARCHAR(255), .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6211b32f1de4750c4eb02161157655a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da216c2c16e1d4fefb2f40c44fdf3a3/" rel="bookmark">
			Java报错Unsupported or unrecognized SSL message解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错原因 客户端和服务器使用的 SSL/TLS 协议版本不兼容。例如,客户端使用 TLS 1.2,而服务器只支持 TLS 1.0。这种情况下,两者无法建立安全连接。
解决方法 禁用 SSL/TLS 加密连接，配置文件中数据库连接url属性加入useSSL=false
spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/数据库名称?serverTimezone=UTC&amp;useSSL=false username: 用户名 password: 密码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e14664be824a90dad23e2c73c6fdbb/" rel="bookmark">
			python等级考试——一级知识点汇总（不包含turtle画图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本篇文章是针对中国电子学会青少年编程等级考试的，适合初学者以及青少年编程学习者）
首先，python一级考试都是比较基础的知识，大概包括python的一些常识知识，以及简单的数据类型，类型转换，输入输出函数，运算符，turtle画图等等，难度小，甚至根本不会考循环，判断之类的。废话不多说，上干货，文章可能有点长。表格都比较重要，除了表格之外，考点都用深红色做了标记，只想知道考点的可以快速浏览。
目录
一. 常识知识：
1.1 常见的几种编程环境：
1.2 IDLE操作以及两种模式
1.2.1 交互模式
1.2.2 文件模式
1.2.3 IDLE基本操作
二. 输入输出函数：
2.1 输出函数： print（ ）
2.2 输入函数： input（ ）
三. 变量：
3.1 声明变量并赋值：
3.2 变量的命名规则：
四. 简单的数据类型：
4.1 字符串（str）：
4.1.1 字符串的拼接
4.2 布尔型（bool)：
4.3 数字型（number）：
4.3.1 整数型（int）：
4.3.2 浮点数 (float):
五、简单数据类型的转换：
六. 运算符：
6.1 算数运算符：
6.2 比较运算符：
6.3 赋值运算符：
6.4 逻辑运算符：
6.5 运算符的优先级：
一. 常识知识： 1.1 常见的几种编程环境： 说简单点，焖饭起码得需要电饭锅，那写代码肯定需要一个编辑器，这里主要是考察孩子是否了解python编程能用的编辑器，考察形式基本上如下所示：
错误非常明显，肯定是D，Scratch是图形化编程。那python常见的编辑环境有哪些呢（考点）
Python常见的几种编程环境IDLE python自带，实际开发几乎不用这个。Visual Studio Code（VScode） 本人一般用这个写前端代码Jupyter Notebook 是一款web应用，在浏览器打开pyCharm 我最常用，也是最顺手的编辑器 除此之外，有个非常简单的考点，就是python2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e14664be824a90dad23e2c73c6fdbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9a5a4700a4a06f28374f64dbd6a67d/" rel="bookmark">
			顺序表应用——通讯录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本篇之前的顺序表专题我们已经学习的顺序表的实现，了解了如何实现顺序表的插入和删除等功能，那么在本篇当中就要学习基于顺序表来实现通讯录，在通讯录当中能实现联系人的增、删、查改等功能，接下来就让我们一起来实现通讯录吧！
1.实现通讯录前的分析 在实现通讯录的代码前我们要先思考在通讯录项目中能实现什么样的功能
（1）至少能够存储100个人的通讯信息
（2）能够保存用户信息：名字、性别、年龄、电话、地址等
（3）增加联系人信息
（4）删除指定联系人
（5）查找制定联系人
（6）修改指定联系人
（7）显示联系人信息
同时由于在之前的顺序表中使用的是动态顺序表，所以在实现通讯录项目中也基于的是动态顺序表
以下是该通讯录项目的程序文件设置以及各文件中所实现的内容
2.通讯录的实现 2.1 联系人信息的设置以及顺序表内要做出的更改 由于顺序表的底层就是数组，所以我们就是要利用数组来实现如以下所示的结构
在通讯录中由于我们要存储的是多个联系人的信息，因此要定义一个结构体来存储联系人的信息
以下定义结构体struct PersonIfon来存储联系人的信息，并且使用typedef将该结构体重命名为Persondef
并且在PersonIfon中的每个数组的大小用#define来定义
#define MAX_NAME 20 #define MAX_GENDER 10 #define MAX_TELE 20 #define MAX_ADRESS 50 typedef struct PersonIfon//联系人信息 { char name[MAX_NAME];//姓名 char Gender[MAX_GENDER];//性别 int age;//年龄 char Tele[MAX_TELE];//电话 char Adress[MAX_ADRESS];//地址 }PersonIfon; 同时由于要通讯录所以之前顺序表的Sqelist.h的数组类型也要更改，由用来的整型改变为PersonIfon,要实现该改变就需要在Seqlist.h内代码的头加上#define“contact.h”
这时Seqlist.h就变为以下形式
#pragma once #define _CRT_SECURE_NO_WARNINGS 1 #include"contact.h" #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; #include&lt;string.h&gt; typedef struct PersonIfon SLDataType; typedef struct Seqlist { SLDataType* arr; int size;//有效的数据个数 int capacity;//空间大小 }SL;//将struct Seqlist重命名为SL 在之前的顺序表的结构体struct Seqlist被重命名为SL，但现在我们要实现的是通讯录这时这个名字就不太合适与直观，那该如何来在contact.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d9a5a4700a4a06f28374f64dbd6a67d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880aff8c6240fec9475ce82296010544/" rel="bookmark">
			未来已来？国内10家AI大模型盘点（附体验网址）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名人说：莫道桑榆晚，为霞尚满天。——刘禹锡（刘梦得，诗豪）
创作者：Code_流苏(CSDN)（一个喜欢古诗词和编程的Coder😊）
目录 1、阿里云——通义千问2、科大讯飞——星火大模型3、百度——文心一言4、字节跳动——豆包5、智谱华章——智谱清言6、华为云——盘古7、百川智能——百川大模型8、腾讯——混元9、商汤——商量SenseChat10、MiniMax——abab6 很高兴你打开了这篇博客，更多好用的AIGC工具，请关注我与专栏《实用软件与高效工具》，内容持续更新中…
大家好，今天我们来盘点一下国内主流的10个AI大模型，看看它们各自的特点和体验网址。
使用方法：只需要在输入框中输入你想问的问题、想知道的信息等，即可快速上手使用。
1、阿里云——通义千问 网址：https://tongyi.aliyun.com/简介：阿里达摩院推出的大模型，拥有千亿参数，可用于智能问答、知识检索、文案创作等场景。 演示：写一首赞美春天的诗歌
2、科大讯飞——星火大模型 网址：https://xinghuo.xfyun.cn/desk简介：科大讯飞推出的AI大模型，支持对话、写作、编程等功能，还能提供语音交互方式。 演示：鲁迅和周树人有什么区别？
3、百度——文心一言 网址：https://yiyan.baidu.com/welcome简介：百度推出的知识增强型对话语言模型，千亿级参数量，在知识问答、创意生成等任务上表现出色。 演示：使用python获取excel中sheet的样式
4、字节跳动——豆包 网址：https://www.doubao.com/简介：字节跳动为创作者打造的AI助手，支持视频脚本撰写、文案生成、营销策划等，大大提高创作效率。 演示：简要讲一下三体第一部的故事
5、智谱华章——智谱清言 网址：https://chatglm.cn/main/alltoolsdetail简介：智谱华章自研的AI大模型，融合海量知识，可用于商业分析、决策辅助、客户服务等领域。 演示：什么是压岁钱？压岁钱的由来
商务推广：想学人工智能的同学可以关注一位朋友在做的这个训练营：AI训练营
6、华为云——盘古 网址：https://pangu.huaweicloud.com/简介：华为诺亚方舟实验室研发的大模型，在中英文理解、多轮对话、常识推理等方面有优异表现。 目前仅对企业用户申请开放，尚未开启公测，大家如果在公司就职，可以去申请体验一下。
7、百川智能——百川大模型 网址：https://www.baichuan-ai.com/chat简介：前搜狗公司CEO王小川创立，发布了Baichuan-7B、Baichuan-13B两款开源可免费商用的中文大模型，且在多个权威评测榜单均名列前茅，下载量突破百万。 演示：写一部科幻主题的小说，寻求建议
8、腾讯——混元 网址：https://hunyuan.tencent.com/bot/chat简介：腾讯AI Lab自研的大规模预训练生成语言模型，擅长开放域聊天、内容创作、知识问答等。 演示：列举登山必备品并制成表格
9、商汤——商量SenseChat 网址：https://sensechat.sensetime.com/简介：商汤科技推出的多模态对话交互平台，利用视觉、语言等技术，提供沉浸式人机交互体验。 演示：母亲节祝福短信
10、MiniMax——abab6 网址：https://minimax.chat/简介：MiniMax打造的实验性AI伙伴，拥有强大的对话能力和广泛的知识储备，适合开放性探索和创意激发。 演示：帮我写一下关于春天的文案
这一个大模型相比于前面的使用稍有不同，偏向于定制助手，不过也是在框中输入信息获取回答。
以上就是国内目前主流AI大模型的简要介绍，它们各具特色，在不同领域发挥着重要作用。随着人工智能的不断发展，相信未来会有更多优秀的大模型涌现，为我们的生活和工作带来更多便利和惊喜，让我们共同期待AI技术的进一步突破和应用！
很感谢你能看到这里，如果你有哪些值得推荐的AI模型，欢迎在评论区分享你正在使用的AIGC！
创作者：Code_流苏(CSDN)（一个喜欢古诗词和编程的Coder😊）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571f89da304d5cb60318ddf7be79ad86/" rel="bookmark">
			Python | 基于支持向量机（SVM）的图像分类案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持向量机（SVM）是一种监督机器学习算法，可用于分类和回归任务。在本文中，我们将重点关注使用SVM进行图像分类。
当计算机处理图像时，它将其视为二维像素阵列。数组的大小对应于图像的分辨率，例如，如果图像是200像素宽和200像素高，则数组的尺寸为200 x 200 x 3。前两个维度分别表示图像的宽度和高度，而第三个维度表示RGB颜色通道。数组中的值范围为0到255，表示每个点处像素的强度。
为了使用SVM对图像进行分类，我们首先需要从图像中提取特征。这些特征可以是像素的颜色值、边缘检测，甚至是图像中存在的纹理。一旦提取了特征，我们就可以将它们用作SVM算法的输入。
SVM算法通过寻找在特征空间中分离不同类的超平面来工作。支持向量机背后的关键思想是找到最大化边缘的超平面，边缘是不同类的最近点之间的距离。最接近超平面的点称为支持向量。
使用SVM进行图像分类的主要优点之一是它们可以有效地处理高维数据，例如图像。此外，SVM比其他算法（如神经网络）更不容易过拟合。
在机器学习中，模型由输入数据和预期输出数据训练。
步骤1：导入所需的库 import pandas as pd import os from skimage.transform import resize from skimage.io import imread import numpy as np import matplotlib.pyplot as plt from sklearn import svm from sklearn.model_selection import GridSearchCV from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score from sklearn.metrics import classification_report 步骤2：加载图像并将其转换为数据帧 Categories=['cats','dogs'] flat_data_arr=[] #input array target_arr=[] #output array datadir='IMAGES/' #path which contains all the categories of images for i in Categories: print(f'loading.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/571f89da304d5cb60318ddf7be79ad86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ba965607d4b5b0466f781b3c28b6bc9/" rel="bookmark">
			【前端】-【前端文件操作与文件上传】-【前端接受后端传输文件指南】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前端文件操作与文件上传前端接受后端传输文件指南前端excel、word操作指南excelword 前端文件操作与文件上传 一、前端文件上传有两种思路：
二进制blob传输：典型案例是formData传输，相当于用formData搭载二进制的blob传给后端base64传输：转为base64传输，后端再将base64转回来。简便、耗时 二、与文件相关的对象
files：通过input标签读过来的文件对象，是blob的子类。blob：不可变的二进制内容，包含很多操作方法，切片上传、断点续传都是基于blob的formData：用于后端传输的对象。files是一个前端的对象，不能直接传给后端，所以我们需要一个前后端都认可的载体来传递文件，这个载体就是formData。formData就像一辆汽车用来搭载files，这样才能让文件以二进制的形式传到后端fileReader：多用于把文件读取为某种形式（如base64、text文件）直接传给后端 三、file参数、blob切割文件、FileReader将文件转成base64，浓缩图/文本预览：
&lt;template&gt; &lt;div&gt; &lt;input type="file" name="file" @change="fileChange" /&gt; &lt;!-- 缩略图，文本预览 --&gt; &lt;img style="width:200px;" :src="imgbase64" /&gt; &lt;button @click="submit"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from "axios" import { fstat } from "fs"; let _fileObj; export default { name: 'HelloWorld', data() { return { imgbase64: "", } }, methods: { fileChange(e) { let file = e.target.files[0]// files是个数组 _fileObj = file; // file常用属性：size（大小）、type（类型）、name（文件名） if (file.size &gt; 10 * 24 * 24) { alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ba965607d4b5b0466f781b3c28b6bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ff386716d4473994a89204cff89cf4/" rel="bookmark">
			Java后端架构设计：从单体到微服务的演进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java后端架构设计：从单体到微服务的演进
大家好，我是免费搭建查券返利机器人省钱赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！今天我们将深入探讨Java后端架构设计的演进过程，从传统的单体架构到现代的微服务架构，以及如何进行这一演进过程中的设计与实现。
单体架构的特点与挑战 传统的单体架构将所有功能和服务打包在一个应用程序中，通常使用Java EE或Spring等框架。这种架构有以下特点：
集中式管理：所有功能模块在同一个代码库和部署单元中，便于开发和部署。单一数据库：通常使用单一数据库管理所有数据。扩展困难：随着业务增长，单体应用的扩展性和灵活性变得有限。部署复杂性：大规模单体应用的部署和维护复杂度高。 为什么需要微服务架构？ 随着互联网应用的复杂性和用户需求的多样化增加，微服务架构应运而生，它能够解决单体架构所面临的各种挑战：
松耦合：将应用拆分为小型服务，每个服务专注于特定的业务功能，各服务之间通过API进行通信。独立部署：每个微服务可以独立部署和扩展，提高了灵活性和可靠性。技术多样性：每个微服务可以选择适合自身需求的最佳技术栈和数据库。容错性：单个微服务的故障不会影响整个应用的稳定性。 从单体到微服务的演进 拆分单体应用 首先，需要识别和拆分现有的单体应用，根据业务边界和功能模块进行拆分。例如，一个传统的电子商务应用可以按照用户管理、订单管理、支付处理等功能模块进行拆分。
引入服务治理 在微服务架构中，服务发现、负载均衡、熔断器等是至关重要的组件。Spring Cloud等框架提供了各种微服务治理工具，帮助实现这些功能。
设计分布式数据管理策略 单体应用通常使用单一数据库进行数据管理，而在微服务架构中，每个微服务可能需要自己的数据库或数据存储。因此，需要设计合适的数据管理策略，如使用分布式事务、事件驱动等方式来保证数据一致性和可靠性。
实现服务间通信 微服务架构中，服务之间通过API进行通信。这要求设计清晰的API接口和通信协议，如RESTful API、消息队列等，确保各个微服务可以相互调用和交互。
示例代码：使用Spring Boot实现微服务之间的RESTful通信 以下是一个简单的示例，展示了如何使用Spring Boot实现两个微服务之间的RESTful通信，符合cn.juwatech.*的包名要求：
服务提供者 package cn.juwatech.provider; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class ProductService { @GetMapping("/products") public String getProducts() { return "List of products"; } public static void main(String[] args) { SpringApplication.run(ProductService.class, args); } } 服务消费者 package cn.juwatech.consumer; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ff386716d4473994a89204cff89cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceac7a304913014dccf236b788bdd2f5/" rel="bookmark">
			Tensorflow安装教程说明，不知道如何选择Tensorflow版本？快来看看经过官方测试验证好的Tensorflow与Python、CUDA、cuDNN的版本对应表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何选择Tensorflow版本？快来看看经过官方测试验证好的Tensorflow与Python、CUDA、cuDNN的版本对应表
🧑 博主简介：现任阿里巴巴嵌入式技术专家，15年工作经验，深耕嵌入式+人工智能领域，精通嵌入式领域开发、技术管理、简历招聘面试。CSDN优质创作者，提供产品测评、学习辅导、简历面试辅导、毕设辅导、项目开发、C/C++/Java/Python/Linux/AI等方面的服务，如有需要请站内私信或者联系任意文章底部的的VX名片（ID：gylzbk）
💬 博主粉丝群介绍：① 群内初中生、高中生、本科生、研究生、博士生遍布，可互相学习，交流困惑。② 热榜top10的常客也在群里，也有数不清的万粉大佬，可以交流写作技巧，上榜经验，涨粉秘籍。③ 群内也有职场精英，大厂大佬，可交流技术、面试、找工作的经验。④ 进群免费赠送写作秘籍一份，助你由写作小白晋升为创作大佬。⑤ 进群赠送CSDN评论防封脚本，送真活跃粉丝，助你提升文章热度。有兴趣的加文末联系方式，备注自己的CSDN昵称，拉你进群，互相学习共同进步。
如何选择Tensorflow版本？快来看看经过官方测试验证好的Tensorflow与Python、CUDA、cuDNN的版本对应表 🗒️安装说明🗒️使用 pip 安装 TensorFlow📄TensorFlow 2 软件包现已推出📄旧版 TensorFlow📄系统要求📄硬件要求📄相关pip安装包地址Linux x86Linux Arm64（仅支持 CPU）📄macOS x86（仅支持 CPU）📄macOS Arm64（仅支持 CPU）📄Windows系统（仅支持 CPU） 🗒️ Tensorflow与Python、CUDA、cuDNN的版本对应表📄1. Windows系统📃1.1 CPU版本📃1.2 GPU版本 📄2. Linux/Ubuntu系统📃2.1 CPU版本📃2.2 GPU版本 📄3. macOS系统📃3.1 CPU版本📃3.2 GPU版本 🗒️安装说明 除了通过源码构建方式安装使用Tensorflow之外，Tensorflow官方还提供了针对Windows、Linux/Ubuntu 和 macOS系统上，经过充分测试的预构建TensorFlow包。所以，我们可以直接使用pip来安装，省去很多构建过程中的麻烦。
🗒️使用 pip 安装 TensorFlow 📄TensorFlow 2 软件包现已推出 tensorflow：支持 CPU 和 GPU 的最新稳定版（适用于 Ubuntu 和 Windows）tf-nightly：预览 build（不稳定）。Ubuntu 和 Windows 均包含 GPU 支持。 📄旧版 TensorFlow 对于 TensorFlow 1.x，CPU 和 GPU 软件包是分开的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceac7a304913014dccf236b788bdd2f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5ae311f195f8a239286f7c0e4a2f59/" rel="bookmark">
			Python酷库之旅-第三方库openpyxl(02)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 openpyxl库的由来
1、背景
2、起源
3、发展
4、特点
4-1、支持.xlsx格式
4-2、读写Excel文件
4-3、操作单元格
4-4、创建和修改工作表
4-5、样式设置
4-6、图表和公式
4-7、支持数字和日期格式
二、openpyxl库的优缺点
1、优点
1-1、支持现代Excel格式
1-2、功能丰富
1-3、易于使用
1-4、与Excel兼容性
1-5、性能良好
1-6、社区支持
1-7、跨平台
2、缺点
2-1、不支持旧版格式
2-2、某些特性支持有限
2-3、内存占用
2-4、文档和示例可能不足
2-5、依赖关系
2-6、学习曲线
三、openpyxl库的用途
1、读取Excel文件
2、写入Excel文件
3、修改Excel文件
4、自动化
5、与Excel交互
6、数据迁移和转换
7、创建模板化的报告
四、如何学好openpyxl库？
1、获取openpyxl库的属性和方法
2、获取openpyxl库的帮助信息
3、用法精讲
3-6、openpyxl.Workbook.get_index方法
3-6-1、语法
3-6-2、参数
3-6-3、功能
3-6-4、返回值
3-6-5、说明
3-6-6、用法
3-7、openpyxl.Workbook.get_sheet_by_name方法
3-7-1、语法
3-7-2、参数
3-7-3、功能
3-7-4、返回值
3-7-5、说明
3-7-6、用法 3-8、openpyxl.Workbook.get_sheet_names方法
3-8-1、语法
3-8-2、参数
3-8-3、功能
3-8-4、返回值
3-8-5、说明
3-8-6、用法 3-9、openpyxl.Workbook.index方法
3-9-1、语法
3-9-2、参数
3-9-3、功能
3-9-4、返回值
3-9-5、说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f5ae311f195f8a239286f7c0e4a2f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2abb0d66d05679ec78652f25a501c32c/" rel="bookmark">
			Python酷库之旅-第三方库openpyxl(15)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 openpyxl库的由来
1、背景
2、起源
3、发展
4、特点
4-1、支持.xlsx格式
4-2、读写Excel文件
4-3、操作单元格
4-4、创建和修改工作表
4-5、样式设置
4-6、图表和公式
4-7、支持数字和日期格式
二、openpyxl库的优缺点
1、优点
1-1、支持现代Excel格式
1-2、功能丰富
1-3、易于使用
1-4、与Excel兼容性
1-5、性能良好
1-6、社区支持
1-7、跨平台
2、缺点
2-1、不支持旧版格式
2-2、某些特性支持有限
2-3、内存占用
2-4、文档和示例可能不足
2-5、依赖关系
2-6、学习曲线
三、openpyxl库的用途
1、读取Excel文件
2、写入Excel文件
3、修改Excel文件
4、自动化
5、与Excel交互
6、数据迁移和转换
7、创建模板化的报告
四、如何学好openpyxl库？
1、获取openpyxl库的属性和方法
2、获取openpyxl库的帮助信息
3、实战案例
3-141、引用输入了文本的全部单元格
3-142、引用输入了逻辑值的全部单元格
3-143、引用输入了批注的全部单元格
3-144、引用没有输入任何数据和公式的空单元格
3-145、引用所有可见的单元格
3-146、引用输入了日期的单元格
3-147、引用含有相同计算公式的所有单元格
3-148、引用合并单元格区域
3-149、引用定义名称所指定的单元格区域
3-150、引用输入了任何内容的最后一行单元格
3-151、引用多个非连续单元格区域集合(类似Union方法)
3-152、引用多个非连续单元格区域集合(循环处理)
3-153、引用多个单元格区域的交叉区域
3-154、获取计算公式的所有引用单元格
3-155、获取计算公式中引用的其他工作表单元格
3-156、获取某个单元格的从属单元格
3-157、引用某个单元格所在的整个行
3-158、引用某个单元格所在的整个列
3-159、引用单元格区域所在的行范围
3-160、引用单元格区域所在的列范围
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、 openpyxl库的由来 openpyxl库的由来可以总结为以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2abb0d66d05679ec78652f25a501c32c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d51f22512d907ef451f2f25372e3711/" rel="bookmark">
			探索WebKit的插件帝国：深入插件系统的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌐 探索WebKit的插件帝国：深入插件系统的奥秘 WebKit作为现代浏览器的核心，其插件系统是扩展浏览器功能、增强用户体验的关键机制。通过插件，开发者可以为浏览器添加各种新特性，从视频播放到3D图形，无所不包。本文将带你深入WebKit的插件系统，揭示其工作原理，并展示如何通过代码实现自定义插件。
🌟 一、WebKit插件系统概述 WebKit的插件系统允许第三方开发者扩展浏览器的功能。插件可以拦截网页中的特定资源请求，执行自定义的代码，并以各种形式与用户交互。
🏗️ 二、插件的工作原理 WebKit插件通过实现特定的接口与浏览器引擎交互。核心的工作流程包括：
拦截请求：插件需要能够拦截对特定类型资源的请求。资源处理：插件对拦截到的资源进行处理，可能包括数据的下载、解码、渲染等。用户交互：插件可能需要提供用户界面，与用户进行交互。 🛠️ 三、创建一个简单的插件 创建一个WebKit插件通常涉及以下步骤：
定义插件类：实现必要的接口，如WKPlugin。实现初始化方法：在插件被创建时进行初始化。处理请求：实现方法以处理网页发起的请求。绘制内容：如果需要，实现绘制方法来自定义内容的显示。 📜 四、插件示例代码 以下是一个简单的示例，展示如何创建一个WebKit插件来拦截图片请求：
class MyImagePlugin : public WKPlugin { public: MyImagePlugin() { // 初始化插件 } virtual ~MyImagePlugin() { // 清理插件资源 } virtual bool initialize(WKContextRef context, WKStringRef pluginPath) { // 注册插件到上下文 return true; } virtual bool canLoadRequest(WKURLRequestRef request) { // 检查是否可以加载请求 WKURLRef url = WKURLRequestCopyURL(request); // 这里可以添加逻辑来决定是否拦截请求 return WKURLIsImageURL(url); } virtual WKPluginLoadPolicy loadRequest(WKURLRequestRef request, WKTypeRef* userData, WKFramePolicyListenerRef listener) { // 加载请求并返回策略 // 例如，可以在这里下载图片并绘制到自定义视图上 return kWKPluginLoadPolicyAllow; } }; // 插件注册 extern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d51f22512d907ef451f2f25372e3711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76cec5d9c87a331aef89f0d4d3fe6973/" rel="bookmark">
			Jetson系列机载电脑创建热点模式配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetson nano为例—— 创建热点模式配置方法 1.1、新建一个 WiFi 在屏幕右上角找到网络图标，点击后选择“Edit Connections”选项，进入选择网络连接页面，然后点击左下角加号，新建一个连接，类型选择 WiFi 后点击 “create” 创建
1.2、设置相关参数 ①、分别设置 WiFi 名、模式、密码、静态 IP 地址：
首先是 Wi-Fi 选项卡，WiFi 名是在 SSID 处进行设置，如需修改也是在
SSID 这一栏进行修改（注：此处 connection name 仅为连接名，并不是 WiFi 名），
Mode 选择 Hotspot 选项（主机模式）
②、接下来是 Wi-Fi Security 选项卡，安全性选择 WPA&amp;WPA2 Personal 选项，
在 Password 处输入要设置的密码
③、下一个是 IPv4 选项卡，点击 Add 后进行配置，分别输入静态 IP 地址、
子网掩码和网关
④、最后是 IPv6 选项卡，选择忽略就可以，四个选项卡的内容均配置完毕即可
保存
⑤、在刚刚的弹窗中，就可以看到刚刚新建好的 WiFi 了
2、热点模式与 WiFi 模式的互相切换 ①、我们的 Jetson nano 均默认为热点模式，即外部可通过搜寻 NANO 发出的热点来连接Jetson nano，如果要用 nano 来连接 WiFi 需要进行模式切换。首先依旧选择网络图标，点击 disconnect 选项，这样就切换到了 WiFi 模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76cec5d9c87a331aef89f0d4d3fe6973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b585364b3505fd84f2dca245815915/" rel="bookmark">
			FastAPI教程III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考FastAPI教程https://fastapi.tiangolo.com/zh/tutorial
这部分暂无需求的没有记录，仅放置标题。
依赖项 安全性 中间件 你可以向FastAPI应用添加中间件。
”中间件“是一个函数，它在每个请求被特定的路径操作处理之前，以及在每个响应返回之前工作。
它接收你的应用程序的每一个请求。然后它可以对这个请求做一些事情或者执行任何需要的代码。然后它将请求传递给应用程序的其他部分（通过某种路径操作）。然后它获取应用程序生产的响应（通过某种路径操作）。它可以对该响应做些什么或者执行任何需要的代码。然后它返回这个响应。 创建中间件 要创建中间件你可以在函数的顶部使用装饰器@app.middleware("http")。
中间件参数接收如下参数：
request。一个函数call_next，它将接收request作为参数。这个函数将request传递给相应的路径操作。然后它将返回由相应的路径操作生成的response。然后你可以在返回response前进一步修改它。 import time from fastapi import FastAPI, Request app = FastAPI() @app.middleware("http") async def add_process_time_header(request: Request, call_next): start_time = time.time() response = await call_next(request) process_time = time.time() - start_time response.headers["X-Process-Time"] = str(process_time) return response 在response的前和后 在任何路径操作收到request前，可以添加要和请求一起运行的代码。
也可以在响应生成但是返回之前添加代码。
例如你可以添加自定义请求头X-Process-Time包含以秒为单位的接收请求和生成响应的时间。
import time from fastapi import FastAPI, Request app = FastAPI() @app.middleware("http") async def add_process_time_header(request: Request, call_next): start_time = time.time() response = await call_next(request) process_time = time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b585364b3505fd84f2dca245815915/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/210/">«</a>
	<span class="pagination__item pagination__item--current">211/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/212/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>