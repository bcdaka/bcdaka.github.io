<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80832585638cfc49e828ca9689d14423/" rel="bookmark">
			MAMBA介绍：一种新的可能超过Transformer的AI架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有人说，“理解了人类的语言，就理解了世界”。一直以来，人工智能领域的学者和工程师们都试图让机器学习人类的语言和说话方式，但进展始终不大。因为人类的语言太复杂，太多样，而组成它背后的机制，往往又充满着不可名状的规律。
过去人们在自然语言处理中多采用 RNN 循环神经网络，它十分类似于人类逻辑上对语言的理解，即：强调上下文顺序、前后文逻辑关系。但是这种顺序方式让 RNN 无法实现并行计算，也就是说，它的速度十分缓慢，而规模也很难扩大。
直到 2017 年 6 月 12 日，一篇名为“Attention is All You Need”的论文被提交到预印论文平台 arXiv 上。一切从此改变。Transformer 的提出直接导致了现在的生成式 AI 风暴。机器好像在一瞬间就学会了如何与人类自如交流。Transformer点石成金的魔力，主要在于它彻底抛弃了前面提到的 RNN 循环神经网络这套逻辑，它完全由自注意力机制组成。大家都有过这样的经验，打乱一个句子中字词序顺，很多时候不并响影你对句子的解理。这是因为人脑在处理信息时会区分权重，也就是说，我们的注意力总是被最重要的东西吸引走，次要的细节则被忽略。Transformer 正是模仿了这一点，使它能够自动学习输入的序列中不同位置之间的依赖关系，并计算其相关性（而不是对整个输入进行编码）。这让针对序列的建模变得更加容易和精准。
尽管如此，随着模型规模的扩展和需要处理的序列不断变长，Transformer 的局限性也逐渐凸显。一个很明显的缺陷是：Transformer 模型中自注意力机制的计算量会随着上下文长度的增加呈平方级增长，比如上下文增加 32 倍时，计算量可能会增长 1000 倍，计算效率非常低。现在如日中天的ChatGPT大模型就有一大痛点：处理长文本算力消耗巨大。背后原因其实就是Transformer架构中注意力机制的二次复杂度。为了克服这些缺陷，研究者们开发出了很多注意力机制的高效变体，但这往往以牺牲其有效性特为代价。到目前为止，这些变体都还没有被证明能在不同领域发挥有效作用。
最近，卡内基梅隆大学机器学习系助理教授 Albert Gu和普林斯顿大学计算机科学系即将上任的助理教授Tri Dao，联合提出一项名为「MAMBA」的研究似乎打破了这一局面。这篇论文的预印本本月初分布在arXiv网站上：
图一: MAMBA预印本论文截图
论文的第一作者Albert Gu表示，这项研究的一个重要创新是引入了一个名为「选择性 SSM」的架构，该架构是 Albert Gu 此前主导研发的 S4 架构（Structured State Spaces for Sequence Modeling ，用于序列建模的结构化状态空间）的一个简单泛化，可以有选择地决定关注还是忽略传入的输入。一个「小小的改变」—— 让某些参数成为输入的函数，结果却非常有效。
值得一提的是，S4 是一个非常成功的架构。此前，它成功地对 Long Range Arena (LRA) 中的长程依赖进行了建模，并成为首个在 Path-X 上获得高于平均性能的模型。更具体地说，S4 是一类用于深度学习的序列模型，与 RNN、CNN 和经典的状态空间模型（State Space Model，SSM）广泛相关。SSM 是独立的序列转换，可被整合到端到端神经网络架构中（ SSM 架构有时也称 SSNN，它与 SSM 层的关系就像 CNN 与线性卷积层的关系一样）。MAMBA论文也讨论了一些著名的 SSM 架构，比如 Linear attention、H3、Hyena、RetNet、RWKV，其中许多也将作为论文研究的基线。MAMBA 的成功让 Albert Gu 对 SSM 的未来充满了信心。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80832585638cfc49e828ca9689d14423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bad32599e248b290bb90c0924d811ef/" rel="bookmark">
			简单易懂：Axios 如何取消请求的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发中，网络请求是非常常见的操作。而有时候，我们可能需要在发送请求后取消它，比如用户在请求还未完成时离开了当前页面或者执行了其他操作，本文将介绍如何在使用 Axios 发送请求时取消这些请求。
基本概念 在 Axios 中，取消请求的基本思路是创建一个用于取消的标记（cancel token），并将其与特定请求关联。当需要取消请求时，我们可以使用这个标记通知 Axios 取消发送该请求。
取消请求的写法 1. 使用 Cancel Token Axios 提供了 CancelToken 类来创建取消标记。取消标记实际上是一个包含 cancel 方法的对象。以下是取消请求的一般步骤：
// 在首先需要引入相关库和模块 import axios from 'axios'; // 创建取消标记 const source = axios.CancelToken.source(); // 发送请求并关联取消标记 axios.get('/api/data', { cancelToken: source.token }).then(response =&gt; { // 请求成功处理 }).catch(error =&gt; { if (axios.isCancel(error)) { console.log('请求被取消', error.message); } else { console.log('请求出错', error.message); } }); // 取消请求 source.cancel('请求取消的原因'); 2. 使用请求配置 除了使用 CancelToken，你也可以在请求配置中直接提供 cancelToken 属性来关联取消标记：
const source = axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bad32599e248b290bb90c0924d811ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739fb9be64e33b898bf25401ef99b1a0/" rel="bookmark">
			Python版本与opencv版本的对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python版本要和opencv版本相对应，否则安装的时候会报错。
可以到Links for opencv-python上面查看python版本和opencv版本的对应关系，如图，红框内是python版本，绿框内是opencv版本。
查看自己的python版本后，使用下面命令进行opencv安装：
pip install opencv-python==3.4.9.33 # 此处 opencv 版本要和 python 版本对应，否则报错 安装 opencv-contrib-python，相当于加了一些额外拓展，比如一些特征提取的算法，在直接的 opencv 中是没有的，需要额外装这个扩展包。
pip install opencv-contrib-python==3.4.9.33 # 版本号要与opencv 版本号一致 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08d8d973bc9785d0e2eb11c0ff6fd65/" rel="bookmark">
			RabbitMQ创建新用户,并给用户添加角色和授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进入容器 1.1 查看运行容器的详细信息 docker ps -a 1.2 进入容器命令 docker exec -it 容器ID /bin/bash 或
docker exec -it 容器name bash 1.3 退出容器命令 exit 或者 Ctrl+Q+P 二、操作RabbitMQ 2.1 查看用户列表 注:先进入到容器内部
rabbitmqctl list_users 2.2 创建用户 rabbitmqctl add_user 「用户名」 「密码」 // 设置用户角色 rabbitmqctl set_user_tags 「用户名」 「角色」 注:此处的角色只是一个标签(角色有administrator、monitoring、policymaker、management等等),也可以自己自定义
RabbitMQ角色释义 administrator policymaker和monitoring可以做的任何事外加:
创建和删除virtual hosts
查看、创建和删除users
查看创建和删除permissions
关闭其他用户的connections management 仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对policies进行管理。用户可以通过AMQP做的任何事外加：
列出自己可以通过AMQP登入的virtual hosts
查看自己的virtual hosts中的queues, exchanges 和 bindings
查看和关闭自己的channels 和 connections
查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。 policymaker management可以做的任何事外加：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08d8d973bc9785d0e2eb11c0ff6fd65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e8b57b8117b6d7307f8c5f506a7a91/" rel="bookmark">
			25道Python练手题（附详细答案），赶紧收藏！Python入门|Python学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 1：水仙花数 水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number）
水仙花数是指一个 3 位数，它的每个位上的数字的 3 次幂之和等于它本身。例如：1^3 + 5^3+ 3^3 = 153。
for i in range(100, 1000): i1 = i // 100 # 取百位数字 123//100=1 i2 = i // 10 % 10 # 取十位数字 123//10=12 12%10=2 i3 = i % 10 # 取个位数字 123%10=3 if i1 ** 3 + i2 ** 3 + i3 ** 3 == i: print(f"{i}是水仙花数") # 153 是水仙花数 # 370 是水仙花数 # 371 是水仙花数 # 407 是水仙花数 题目 2：四叶玫瑰数 四叶玫瑰数是 4 位数的自幂数。自幂数是指一个 n 位数，它的每个位上的数字的 n 次幂之和等于它本身。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e8b57b8117b6d7307f8c5f506a7a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff34b0b47f8605cbcc5c5376fef9e6f6/" rel="bookmark">
			一文带你了解如何在Java中操作Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言发现宝藏一、 Redis客户端简介1. Redis客户端分类2. Spring 整合 Redis 的两种方式 二、 使用 Jedis 操作 Redis1. Jedis的maven坐标2. 使用Jedis操作Redis的步骤3. Jedis 操作 Redis 示例 三、 使用 Spring Data Redis 操作 Redis1. Spring Data Redis 的 maven 坐标2. spring Data Redis 中 operation 接口的分类3. Spring Data Redis 操作 Redis String 类型示例（ValueOperations ---- 简单K-V操作）4. Spring Data Redis 操作 Redis hash 类型示例（HashOperations ---- 针对map类型的数据操作）5. Spring Data Redis 操作 Redis list 类型示例（ListOperations ---- 针对list类型的数据操作）6. Spring Data Redis 操作 Redis set 类型示例（ SetOperations ---- set类型数据操作）7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff34b0b47f8605cbcc5c5376fef9e6f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d3ee2a2cd44125cae28670a09ae376/" rel="bookmark">
			MySQL库的操作『增删改查 ‖ 编码问题 ‖ 备份与恢复』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 北 海
🎉所属专栏： MySQL 学习
🎃操作环境： CentOS 7.6 阿里云远程服务器
🎁软件版本： MySQL 5.7.44
文章目录 1.创建数据库2.数据库中的编码问题2.1.字符集与校验集2.3.支持的字符集与校验集2.4.自由设置字符集与校验集2.2.校验集对查询的影响 3.查看数据库4.修改数据库5.删除数据库6.数据库的备份与恢复7.查看数据库的连接情况 1.创建数据库 创建数据库的语法为
CREATE DATABASE [IF NOT EXISTS] database_name; [ ] 中的关键字可以选择不加，IF NOT EXISTS 的意思是如果不存在才创建 数据库
登录 MySQL 后输入指令进行创建
mysql&gt; create database if not exists db1; MySQL 中的语法不区分大小写，语法中通常 将关键字写成大写，方便学习和查看
注意： 如果数据库已存在，再次创建会报错，可以通过 if not exists 关键字将报错降低为警告
在 Linux 中创建数据库的本质就是 在 /var/lib/mysql 目录下创建了一个目录
进入 db1 目录，可以看到里面只有一个后缀为 .opt 的配置文件
通过 cat 指令查看其中的类型，可以发现默认只有 字符 character 和 校对 collation 相关的配置信息，这俩其实就是 字符集 和 检验集，用于设置 数据库 中的编码规则
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d3ee2a2cd44125cae28670a09ae376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f159909362646789309c1fe6747423/" rel="bookmark">
			Java LeetCode篇-深入了解二叉树经典解法（三种方式实现：获取二叉树的最大深度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 对称二叉树
1.1 判断对称二叉树实现思路
1.2 代码实现：判断对称二叉树
2.0 二叉树的最大深度
2.1 使用递归实现获取二叉树的最大深度思路
2.2 代码实现：使用递归实现获取二叉树的最大深度
2.3 使用非递归实现获取二叉树的最大深度思路
2.4 代码实现：使用非递归实现获取二叉树的最大深度
2.5 使用层序遍历实现获取二叉树的最大深度
2.6 代码实现：使用层序遍历实现获取二叉树的最大深度
3.0 二叉树的最小深度
3.1 使用递归实现获取二叉树的最小深度思路
3.2 代码实现：使用递归实现获取二叉树最小深度
3.3 使用层序遍历实现获取二叉树的最小深度思路
3.4 代码实现：使用层序遍历实现获取二叉树的最小深度
4.0 翻转二叉树
4.1 使用实现递归翻转二叉树思路
4.2 代码实现：使用递归翻转二叉树
5.0 二叉树经典解法的完整代码
1.0 对称二叉树 题目：
给你一个二叉树的根节点 root ， 检查它是否轴对称。
示例 1：
输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：
输入：root = [1,2,2,null,3,null,3] 输出：false OJ链接：
101. 对称二叉树
1.1 判断对称二叉树实现思路 假设该树的图： 具体思路为：如果当前节点的左子树的值等于当前节点的右子树时，可以说目前为止还是对称的，不能直接下结论，因为不能保证之后的节点是否对称。比如：当前节点的值为 1 ，它的左孩子的值为 2 ，它的右孩子的值为 2，此时可以说暂时是对称的，还需要接着向下判断。它的左孩子的左孩子的值为 3，它的右孩子的右孩子为 3 ，同理，现在还不能说明该树是否对称，当递归到底的时候，当前的节点的左右孩子都是 null ，此时可以返回 true ，不能足以证明该树对称，因为单单只是判断完外侧的节点，在外层回归的过程中，需要判断内层的节点是否对称，回归到节点值都为 2 的节点，接着进行内层递归，对于在外层判断完左孩子，那么接下来需要判断右孩子，同样，对于在外层判断完右孩子，那么接下来需要判断左孩子。如，刚刚的外层结束递出之后，开始回归，到节点为 2 的节点，对于左边的节点值为 2 的节点的右孩子，与右边的节点值为 2 的节点的左孩子进行比较，如果相同，由于说明不了什么，还得继续往下递出，直到该节点的左右孩子都为 null 时，可以返回 true 。最后返回到节点值为 1 的根节点中，可以得到该树是对称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8f159909362646789309c1fe6747423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31371133e1b4a4a97e372870e803c292/" rel="bookmark">
			Nodejs使用mysql2操作数据库【完整讲解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql2 相比于 mysql 的优势 mysql2 是一个基于 Node.js 的 MySQL 客户端库，相比于 mysql 库，它具有以下几个优势：
性能更好：mysql2 库在性能方面进行了优化，使用了更高效的底层实现。它使用了更快的连接池管理和查询执行机制，可以处理更高的并发请求，提供更好的性能表现。
支持 Promise 和 async/await：mysql2 库原生支持 Promise 和 async/await，使得编写异步代码更加方便和直观。您可以使用 promise().query() 方法执行查询，并使用 await 关键字等待查询结果。
支持流式查询：mysql2 库支持流式查询，可以通过创建可读流来处理大型查询结果集。这对于处理大量数据或需要逐行处理结果的情况非常有用，可以减少内存占用并提高性能。
更好的错误处理：mysql2 库提供了更好的错误处理机制，可以更详细地捕获和处理数据库操作中的错误。它返回的错误对象包含更多有用的信息，如 SQL 语句、错误代码和错误堆栈等，有助于更好地调试和排查问题。
支持预处理语句：mysql2 库支持预处理语句，可以使用占位符来安全地构建和执行 SQL 查询。这可以防止 SQL 注入攻击，并提高应用程序的安全性。
安装 npm install mysql2 连接数据库 要使用 mysql2 连接到 MySQL 数据库，您需要安装 mysql2 包，并使用适当的连接参数来创建连接。以下是一个示例，展示了如何使用 mysql2 连接到 MySQL 数据库：
const mysql = require("mysql2"); // 创建数据库连接 const connection = mysql.createConnection({ host: "localhost", // 主机地址 user: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31371133e1b4a4a97e372870e803c292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9abf1d1b9b50b4d73d760c1b478d8eb/" rel="bookmark">
			【算法系列篇】递归、搜索与回溯（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是递归、搜索与回溯算法1. 汉诺塔1.1 题目要求1.2 做题思路1.3 代码实现 2. 合并两个有序链表2.1 题目要求2.2 做题思路2.3 代码实现 3. 反转链表3.2 题目要求3.2 做题思路3.3 代码实现 什么是递归、搜索与回溯算法 递归算法是一种通过重复将问题分解为同类的子问题而解决问题的方法。递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念。绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归。
搜索算法是利用计算机的高性能来有目的地穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。主要包括枚举算法、深度优先搜索、广度优先搜索、A*算法、回溯算法、蒙特卡洛树搜索和散列函数等算法。
回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。
那么，为什么会将这三个算法放在一起呢？其实搜索算法和回溯算法本质上都是递归算法，只是搜索决定了递归的方式，而回溯则是在递归搜索的时候，在函数返回值的时候将改变的量给还原回来。
在本系列算法中，我将为大家一步一步、一个阶段一个阶段的为大家分享涉及到相关知识的题目。
1. 汉诺塔 https://leetcode.cn/problems/hanota-lcci/
1.1 题目要求 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。
请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
你需要原地修改栈。
示例1:
输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2:
输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9abf1d1b9b50b4d73d760c1b478d8eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3957f3f1b7e2fa1bc11d27eaf2a02d/" rel="bookmark">
			python&#43;paddleocr 进行图像识别、找到文字在屏幕中的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1、安装paddleocr
2、安装PIL
3、安装numpy
4、 安装pyautogui
5、进行文本识别
6、识别结果
7、获取文字在图片/屏幕中的位置
8、pyautogui+paddleocr鼠标操作
9、完整代码
前言 最近在做自动化测试，因为是处理过的界面，所以使用pywinauto,LDTP获取控件进行操作的方法不可行，于是选择使用pyautogui进行图像识别与键盘鼠标控制。
但是单独使用pyautogui测试效率很低，并且pyautogui图片识别并没有opencv识别率高，所以需要结合其他图像库使用。
在使用的过程中发现，仅仅使用图像识别有时匹配度比较低，使用opencv进行图像识别定位，是图像像素太小查找成功的几率大大降低，于是想到使用OCR文本识别的方法对其进行查找，结合在一起使用，大大提高了工作效率。 OCR图像识别我试过Tessract-ocr和paddleocr，发现Tessract-ocr识别正确率太低了，实在不推荐使用。
有关paddleocr的信息可以去github上查看：https://github.com/PaddlePaddle/PaddleOCR
于是想要记录一下，也提供给大家参考学习。
1、安装paddleocr 使用以下命令进行安装：
pip install paddleocr 2、安装PIL PythonPIL（Python Image Library）是一款用来处理图像的开源库，可实现图像的读取、格式转换、简单编辑、保存等功能。在Python中使用PIL库可以很方便地对图像进行操作。
与 Pillow 相比，OpenCV 和 Scikit-image 的功能更为丰富，所以使用起来也更为复杂，主要应用于机器视觉、图像分析等领域，比如众所周知的“人脸识别”应用 。
在这里我们使用PIL对图像进行处理。
使用以下命令进行安装：
pip install pillow 3、安装numpy NumPy（Numerical Python）是Python的一种开源的数值计算扩展。这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure）结构要高效的多（该结构也可以用来表示矩阵（matrix）），支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。
我们使用numpy用来处理屏幕截图，把其转换为矩阵，再进行下一步处理。
使用以下命令进行安装：
pip install numpy 4、 安装pyautogui pyautogui是一个Python模块，可以模拟用户在屏幕上的鼠标和键盘操作。它可以自动化鼠标和键盘输入，可以用于各种自动化任务，例如GUI测试、自动化数据输入、自动化游戏玩法等。pyautogui提供了一组函数来控制鼠标和键盘，例如移动鼠标、单击、双击、右键单击、按下和释放键等。它还提供了一些额外的功能，例如捕捉屏幕截图、识别颜色和图像等，以及其他一些实用工具，例如获取屏幕尺寸和鼠标位置。
使用以下命令进行安装：
pip install pyautogui 5、进行文本识别 安装好库之后，在脚本文件开头导入
import numpy from pyautogui import * from PIL import Image import numpy as np from paddleocr import PaddleOCR, draw_ocr def get_curtime(time_format="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be3957f3f1b7e2fa1bc11d27eaf2a02d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c6ae6560416ab118233f172ea7a4ea/" rel="bookmark">
			前端必备技能！一文读懂如何调试node_module内源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 在项目开发中发现有一个bug问题可能原因出现在node_module内的包问题，但是发现直接调试该包源码是无法正常console的，这对于开发定位问题来说十分不友好。本文仅介绍如何定位npm包的问题和调试方法，但是要注意修改后再npm i 又会覆盖掉修改，如何避免这个问题网上有相关文章，笔者暂未实践。
方法： 其实大概思路就是通过npx命令建立一个项目代码下的npm包和node_module内的同名npm包链接，使得调用转向本地调用
1。首先，确保你的本地包的 package.json 文件中已经设置了 “name” 属性，且与 node_modules 中的包名相同。
2.在本地包的目录中运行 npm link 命令。这将在全局 node_modules 目录中创建一个符号链接（symlink）指向你的本地包。例如，如果你的本地包名为 my-package，则运行：
cd path/to/my-package npm link 3.接下来，转到使用该包的项目目录，并运行 npm link my-package，将项目中的 my-package 替换为指向本地包的符号链接。例如：
cd path/to/my-project npm link my-package 4.现在，当你在项目中使用 my-package 时，实际上是在使用本地的 my-package。这样，你可以在本地对 my-package 进行修改并实时看到项目中的更改。
5.完成本地调试后，可以使用 npm unlink my-package 命令取消链接，然后重新安装原始的 node_modules 包：
cd path/to/my-project npm unlink my-package npm install my-package 注意：在进行本地调试时，需要重新启动项目或使用热更新功能，以便在项目中看到本地包的更改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab975ab24aeb36b42e69cb6f835181a/" rel="bookmark">
			mac连接easyconnnect显示“本地环境出现异常”。亲测已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种解决方法亲测都可以用 第一种：打开电脑的登录项，打开如下服务，然后重启软件 第二种：mac连接easyconnnect显示“本地环境出现异常” 解决方法：
终端下输入：vim ~/.zprofile文件内加入如下内容，如下图： ####解决连接easyconnnect显示“本地环境出现异常问题 function EC_start(){ /Applications/EasyConnect.app/Contents/Resources/bin/EasyMonitor &gt; /dev/null 2&gt;&amp;1 &amp; /Applications/EasyConnect.app/Contents/MacOS/EasyConnect &gt; /dev/null 2&gt;&amp;1 &amp; open /Applications/EasyConnect.app } function EC_kill(){ pkill EasyMonitor pkill ECAgent pkill ECAgentProxy pkill EasyConnect } 3. 终端输入：source ~/.zprofile
4. 命令行启动：EC_start
5. 命令行结束：EC_kill
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63665e0a667185b7b96ee3902990852f/" rel="bookmark">
			实操解决Navicat连接postgresql时出现‘datlastsysoid does not exist‘报错的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 column “datlastsysoid“ does not exist 2 Line1:SELECT DISTINCT datalastsysoid FROM pg_database 问题分析
Postgres 15 从pg_database表中删除了 datlastsysoid 字段引发此错误。
决绝方案
解决方法1：升级navicat
解决方法2：降级pgsql
解决方法3：修改dll
实操演示
1、 打开 Navicat 安装目录，找到libcc.dll文件
2、备份libcc.dll文件，将其复制并粘贴为“libcc.dll.bak”或任何其他名称 3、在任何十六进制编辑器中打开此文件，如果需要，您可以使用在线工具，例如 https://hexed.it。
4、在文件中搜索“SELECT DISTINCT datlastsysoid”，并将其替换为“SELECT DISTINCT dattablespace”
修改
5、将文件保存在原始位置。如果遇到任何安全问题，请将其另存为“.txt”文件，然后还原备份文件
6、重启navicat，可以发现，无论老和新版本的pgsql，都可以正常访问了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa025a19ecbe93cbaa79c7e40332e8f/" rel="bookmark">
			Java&#43;Swing&#43;Mysql实现超市管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统介绍 1.开发环境 操作系统：Win10
开发工具 ：IDEA2018
JDK版本：jdk1.8
数据库：Mysql8.0
2.技术选型 Java+Swing+Mysql
3.功能模块 4.系统功能 1.系统登录登出 管理员可以登录、退出系统
2.商品信息管理 管理员可以对商品信息进行查询、添加、修改、删除等操作。
3.出库信息管理 管理员可以对出库信息进行查询、添加、修改、删除等操作。
4.入库信息管理 管理员可以对入库信息进行查询、添加、修改、删除等操作。
5.客户信息管理 管理员可以对客户信息进行查询、添加、修改、删除等操作。
6.供应商信息管理 管理员可以对供应商信息进行查询、添加、修改、删除等操作。
5.工程结构 二、系统展示 1.登录页面 2.主页面 3.商品展示 4.商品新增 5.出库展示 6.出库新增 7.入库展示 8.入库新增 9.客户展示 10.客户新增 11.供应商展示 12.供应商新增 13.关于我们 三、部分代码 AdminDao package com.sjsq.dao; import java.util.ArrayList; import java.util.List; import com.sjsq.model.Admin; import com.sjsq.utils.DBUtil; /** * 管理员登录 */ public class AdminDao { /** * 登录 * * @param username * @param password * @return * @throws Exception */ public boolean login(String username, String password) throws Exception { List&lt;Object&gt; paramList = new ArrayList&lt;&gt;(); paramList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fa025a19ecbe93cbaa79c7e40332e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f10c52c886f8d9c43b6a5fdfaa64b7/" rel="bookmark">
			python绘制雷达图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		雷达图定义与应用场景 雷达图（Radar Chart），也被称为蛛网图（Spider Chart）或极坐标图，是一种用于展示多个维度的数据分布的图表。它的主要特点是在一个圆形的坐标系上，通过多个半径相连的数据点来表示不同的数据维度，形成一种类似蜘蛛网的图形。每个维度对应一个角度，而半径的长度表示该维度的数值。
应用场景：
1、比较多个维度： 雷达图适用于比较多个维度的数据，特别是在各个维度上的数据差异较大时，可以直观地看出各维度之间的差异。
2、综合评价： 用于综合评价多个因素对一个目标的影响，例如产品的各个性能指标综合评估。
3、团队能力分析： 在团队管理中，可以使用雷达图来展示团队成员在不同技能维度上的水平，帮助发现团队的整体优势和薄弱之处。
4、市场份额分析： 用于比较不同品牌或产品在市场上的表现，可以清晰地看出各个品牌在不同维度上的竞争优势。
5、个人能力展示： 个人发展规划中，可以使用雷达图来展示个人在各个技能维度上的水平，有助于制定个人提升计划。
总的来说，雷达图是一种直观、可视化的工具，适用于展示多个维度的数据关系，帮助人们更好地理解和分析复杂的多维数据。
示例代码 import matplotlib.pyplot as plt import numpy as np # 数据准备 categories = ['Category 1', 'Category 2', 'Category 3', 'Category 4', 'Category 5', 'Category6'] values = [4, 3, 5, 2.5, 4, 1] # 计算角度 num_categories = len(categories) angles = np.linspace(0, 2 * np.pi, num_categories, endpoint=False).tolist() # 绘制雷达图 fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True)) values += values[:1] # 保持values的长度与angles一致 angles += angles[:1] ax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2f10c52c886f8d9c43b6a5fdfaa64b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7146c99f2c56ad4c98d622b775864e7/" rel="bookmark">
			oracle数据库连接错误ORA-12514, TNS:listener does not currently know of service requested in connect descrip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORA-12514, TNS:listener does not currently know of service requested in connect descriptor 问题排查 数据库连接不上，我们直接服务器进入命令行 无法进入命令行，报错：Oracle 数据库尝试创建审计追踪文件，由于没有空间无法创建。
审计追踪文件的作用：
Oracle 数据库审计追踪文件用于记录数据库中发生的安全相关事件和活动，以提供有关数据库的详细审计信息。这些文件有助于监视和追踪数据库的使用情况，以确保数据库的安全性、合规性和可追溯性。以下是审计追踪文件的一些主要作用：
安全监控： 审计追踪文件记录了数据库中的登录、注销、授权、权限更改等安全相关事件。通过审计文件，数据库管理员可以检查是否有未经授权的访问尝试，以及数据库用户的活动是否符合预期。
合规性： 许多行业和法规要求数据库系统实施严格的安全审计和监控。审计追踪文件可以用于满足这些合规性要求，例如，PCI DSS（支付卡行业数据安全标准）要求对数据库的访问和操作进行详细的审计记录。
问题排查： 当出现数据库性能或安全性问题时，审计追踪文件可用于进行问题排查。通过查看文件，管理员可以了解在特定时间数据库发生了什么，有助于快速定位和解决问题。
用户行为分析： 审计追踪文件记录了用户的活动，包括 SQL 语句的执行、表的访问等。这些信息对于分析用户行为、优化查询以及进行容量规划等方面都是有用的。
数据库性能优化： 通过审计追踪文件，可以了解数据库中哪些查询经常被执行，哪些表被频繁访问，从而帮助优化数据库性能。
在 Oracle 数据库中，可以通过配置审计选项和参数来控制审计追踪文件的生成。审计追踪文件通常包含详细的事件信息，如时间戳、事件类型、用户、主机信息、SQL 语句等。
查询剩余空间 可以看到我们的根目录已经全部占用了，应该就是因为我们的审计追踪文件创建在这个目录之下，所以没有足够的空间继续创建了
解决问题 查看我们的初始化配置文件，看一下审计追踪文件的默认创建位置 一般是在这个路径下的 init.ora 文件
cd $ORACLE_HOME/dbs/ 可以看到我们的 audit_file_dest 路径就是我们的审计追踪文件的位置
audit_trail 是我们审计追踪文件的策略
NONE（默认）：不进行审计。OS：使用操作系统级别的审计功能。这种情况下，审计追踪文件的管理由操作系统处理。DB：审计信息存储在数据库中，可以通过 SQL 查询来检索。数据库管理员需要定期清理过时的审计数据。 定期清理sql
DBMS_AUDIT_MGMT.CLEAN_AUDIT_TRAIL( audit_trail_type =&gt; DBMS_AUDIT_MGMT.AUDIT_TRAIL_AUD_STD, use_last_arch_timestamp =&gt; TRUE ); 找到审计追踪文件并删除 查看环境变量
cat /etc/profile 进入 $ORACLE_BASE/admin/orcl/adump
直接删除这个文件夹下所有文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7146c99f2c56ad4c98d622b775864e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc34dc328dc82421d6d5c6ee70d852c/" rel="bookmark">
			【数据结构】链表OJ题（顺序表）（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅
✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨
🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿
🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟
🌟🌟 追风赶月莫停留 🌟🌟
🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀
🌟🌟 平芜尽处是春山🌟🌟
🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟
🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿
✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨
✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅
📝数据结构OJ题 ✏️移除元素✏️ 删除重复项✏️ 合并两个数组 ✏️移除元素 题目链接：原地移除数组中所有的元素val，要求时间复杂度为O(N)，空间复杂度为O(1)
我在这里给大家提供了常规的三种解法，第一种解法是错误示范
解法一:大家首先肯定想到的是边遍历边删除，当然这也是常用的方法，但是实际上这个解法一是错误的
int removeElement(int* nums, int numsSize, int val) { for (int i = 0; i &lt; numsSize; i++) { if (nums[i] == val) { for (int j = i; j &lt; numsSize - 1; j++) { nums[j] = nums[j + 1]; } numsSize--; } } for (int i = 0; i &lt; numsSize; i++) { if (nums[i] == val) { for (int j = i; j &lt; numsSize - 1; j++) { nums[j] = nums[j + 1]; } numsSize--; } } return numsSize; } 大家可以看到在这里我用到了两次for循环进行遍历和删除而且是一模一样的，大家可以看下面的图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc34dc328dc82421d6d5c6ee70d852c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62a507c541b676b624f0bc72a3736a2/" rel="bookmark">
			jar中没有主清单属性 java -jar xxx-0.0.1-SNAPSHOT.jar 没有主清单属性(解决 全程图解 windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 成功解决
解决方法一 查看pom.xml
打包文件是否有这行
正确的打包文件
&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.6.13&lt;/version&gt;&lt;!-- 自己的SpingBoot版本 --&gt; &lt;configuration&gt; &lt;!-- 自己的启动类地址 --&gt; &lt;mainClass&gt;com.example.knowledgebase.KnowledgeBaseApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; 为什么&lt;skip&gt;true&lt;/skip&gt;会导致找不到主清单属性?
在spring-boot-maven-plugin的配置中设置 &lt;skip&gt;true&lt;/skip&gt; 时，实际上你告诉Maven在执行构建生命周期时跳过这个插件的运行。此插件负责将你的项目打包成一个可执行的JAR文件，其中包含了一个正确的清单文件（MANIFEST.MF）以及所有的项目依赖项。
在清单文件中，主类（Main Class）的信息是一个关键的元素，它告诉JVM运行哪一个类的main方法作为程序的入口点。如果spring-boot-maven-plugin被跳过了，那么这个清单文件可能不会被正确地生成，主类的信息也就不会被加入到清单文件中。这就是为什么当你尝试运行JAR文件时，你会看到 "没有主清单属性" 的错误。
所以，为了正确生成可执行的JAR文件，需要移除 &lt;skip&gt;true&lt;/skip&gt; 配置，或者将其设置为 false。这样，在执行 mvn package 或者 mvn install 时，spring-boot-maven-plugin就会被执行，它会生成一个正确的可执行的JAR文件，包含了主类的信息以及所有的项目依赖项。
按照正确替换依赖后
如若还没有解决,可能是你项目中有其他主类影响了依赖的判断
那么我们可能需要第二种方法
解决方法二 选取存放地址
最后结果
哈，谢谢各位同志的阅读，然后呢如果觉得本文对您有所帮助的话，还给个免费的赞捏
Thanks♪(･ω･)ﾉ喵
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b453adb7765d6dfdf708daacc1e893/" rel="bookmark">
			conda升级python版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开终端或命令提示符，并激活你要使用的conda环境。你可以使用以下命令来激活环境：
conda activate &lt;环境名称&gt; 确认当前环境中已安装的Python版本。可以使用以下命令来查看：
conda list python 更新conda本身。可以使用以下命令来更新conda：
conda update conda 确认是否有可用的Python版本可以升级。可以使用以下命令来查看可用的Python版本：
conda search python 选择要升级的Python版本。可以使用以下命令来安装指定的Python版本：
conda install python=&lt;版本号&gt; 请注意，将&lt;版本号&gt;替换为你想要安装的具体版本号。如果你不确定要安装哪个版本，可以选择最新的稳定版本。
等待安装完成。conda将自动下载并安装所选的Python版本及其依赖项。
验证Python版本是否成功升级。可以使用以下命令来确认：
python --version 这将显示当前正在使用的Python版本号。
通过以上步骤，你可以使用conda来升级Python版本。请确保在操作之前备份重要的数据，并谨慎选择要升级的版本，以避免可能的兼容性问题。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/557/">«</a>
	<span class="pagination__item pagination__item--current">558/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/559/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>