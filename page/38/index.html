<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b760eececa89679791bb2f18c0f200/" rel="bookmark">
			leetcode322. 零钱兑换,完全背包最值问题，附背包问题模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode322. 零钱兑换 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
示例 2：
输入：coins = [2], amount = 3
输出：-1
示例 3：
输入：coins = [1], amount = 0
输出：0
提示：
1 &lt;= coins.length &lt;= 12
1 &lt;= coins[i] &lt;= 231 - 1
0 &lt;= amount &lt;= 104
目录 leetcode322. 零钱兑换题目描述算法分析算法步骤算法流程具体代码算法分析复杂度分析易错点注意事项 相似题目背包问题模板 题目描述 给定一组货币面额和一个总金额，计算可以凑出该总金额的硬币组合数。如果没有任何一种组合可以凑出该金额，则返回 -1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b760eececa89679791bb2f18c0f200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c94e871e6b7bbc71b3d72cd79a11a8/" rel="bookmark">
			一文学会本地部署可视化应用JSONCrack并配置公网地址实现远程协作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. Docker安装JSONCrack2. 安装Cpolar内网穿透工具3. 配置JSON Crack界面公网地址4. 远程访问 JSONCrack 界面5. 固定 JSONCrack公网地址 前言 本文主要介绍如何在Linux环境使用Docker安装数据可视化工具JSONCrack，并结合cpolar内网穿透工具实现团队在公网进行远程协作，更好的提高工作效率！
JSON Crack 是一款免费的开源数据可视化应用程序，能够将 JSON、YAML、XML、CSV 等数据格式可视化为交互式图表。凭借其直观且用户友好的界面，JSON Crack 可以轻松探索、分析和理解即使是最复杂的数据结构。
1. Docker安装JSONCrack 下载JSONCrack源代码：
wget https://github.com/AykutSarac/jsoncrack.com/archive/refs/tags/v3.2.0.zip 进行解压缩
unzip v3.2.0.zip 本地编译容器
sudo docker build -t jsoncrack . 在本地运行端口号为8888的 JSONCrack
docker-compose up -d 浏览器访问 http://localhost:8888
我们运行 JSON Crack 后,在浏览器输入Linux局域网IP加8888端口,即可成功访问 JSON Crack 管理界面,下面安装介绍安装Cpolar内网穿透工具,实现无公网也可以远程访问本地 JSON Crack 界面
PS:如果拉取不到镜像，可以在终端执行 nano /etc/docker/daemon.json
输入：
{
“registry-mirrors”: [
“https://do.nark.eu.org”,
“https://dc.j8.work”,
“https://docker.m.daocloud.io”,
“https://dockerproxy.com”,
“https://docker.mirrors.ustc.edu.cn”,
“https://docker.nju.edu.cn”
]
}
保存退出
然后执行：systemctl restart docker
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c94e871e6b7bbc71b3d72cd79a11a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4fc04ef07673559dc458c1ee7b8c3f/" rel="bookmark">
			Scikit-learn：用于数据挖掘和数据分析的简单而有效的工具，建立在 NumPy, SciPy 和 Matplotlib 上。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Scikit-learn 是一个基于 Python 的机器学习库，旨在为数据挖掘和数据分析提供简单而有效的工具。它建立在强大的科学计算库之上，包括 NumPy、SciPy 和 Matplotlib，提供了丰富的机器学习算法和工具，如分类、回归、聚类、降维、模型选择和数据预处理等。Scikit-learn 的 API 设计简洁，使用方便，且拥有高效的实现，因此在学术研究和工业界中得到了广泛应用。无论是数据科学家还是机器学习工程师，Scikit-learn 都是他们的重要工具。
Scikit-learn 的设计遵循了几个重要的原则：
易于使用：Scikit-learn 的 API 非常直观，用户可以快速上手并构建强大的机器学习模型。文档完善：Scikit-learn 拥有详细的文档和丰富的教程，帮助用户理解每个算法的原理及其应用场景。高效：Scikit-learn 的实现经过优化，可以高效地处理大规模数据集。可扩展：Scikit-learn 可以轻松扩展，以适应不同的机器学习任务，并能与其他 Python 数据科学库（如 Pandas、Seaborn）无缝集成。 无论是初学者还是有经验的专业人士，Scikit-learn 都为机器学习模型的构建、评估和部署提供了强大的支持。
核心特性 1. 丰富的机器学习算法 Scikit-learn 提供了多种机器学习算法，涵盖了分类、回归、聚类、降维等任务。
分类算法： k-近邻（K-Nearest Neighbors, KNN）：用于根据最近的邻居对新数据点进行分类，适合于样本较少且分布均匀的数据。支持向量机（Support Vector Machine, SVM）：通过寻找最佳分隔超平面将数据点分开，适用于高维空间的分类任务。决策树（Decision Tree）：基于特征的层次结构对数据进行分类，易于理解和解释。随机森林（Random Forest）：通过构建多个决策树并结合其预测结果来提高分类准确率，减小过拟合风险。朴素贝叶斯（Naive Bayes）：基于贝叶斯定理的简单且高效的分类算法，适合文本分类等高维稀疏数据。逻辑回归（Logistic Regression）：用于二元分类任务，通过学习数据的线性关系来进行分类。 回归算法： 线性回归（Linear Regression）：通过线性模型来预测连续目标值，适合处理线性关系明确的数据。岭回归（Ridge Regression）：在线性回归的基础上加入 L2 正则化项，防止过拟合。套索回归（Lasso Regression）：在回归模型中引入 L1 正则化，促进特征选择，生成稀疏模型。弹性网回归（Elastic Net Regression）：结合 L1 和 L2 正则化的回归模型，适用于具有高度相关特征的数据集。支持向量回归（Support Vector Regression, SVR）：与 SVM 类似，但用于回归任务，适合处理高维数据。 聚类算法： K-means 聚类：通过迭代优化将数据点划分为 K 个簇，每个簇由其质心（中心点）表示，适用于大规模数据集的聚类任务。层次聚类（Hierarchical Clustering）：通过构建树状的层次结构对数据进行聚类，适合分析数据的内在结构。DBSCAN：基于密度的聚类算法，可以识别任意形状的簇，并自动识别噪声点，适用于具有噪声的非均匀数据。 降维算法： 主成分分析（Principal Component Analysis, PCA）：通过线性变换将数据投影到低维空间，保持数据的最大方差，用于数据压缩和降噪。线性判别分析（Linear Discriminant Analysis, LDA）：通过最大化类间距离与最小化类内距离来提高分类性能，同时实现降维。奇异值分解（Singular Value Decomposition, SVD）：通过矩阵分解来进行数据降维和特征提取，常用于推荐系统和文本分析。 模型选择与评估： 交叉验证（Cross-Validation）：通过将数据集分为多个折叠，并轮流进行训练和测试，评估模型的泛化能力。网格搜索（Grid Search）：在指定的参数网格上进行穷举搜索，找到最佳的超参数组合。随机搜索（Random Search）：在参数空间中随机采样，寻找最优超参数，相比网格搜索更适用于高维参数空间。评分指标：Scikit-learn 提供多种评分指标，如准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1 分数（F1 Score）等，用于评估分类模型的性能。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a4fc04ef07673559dc458c1ee7b8c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d44cca493d6e777ac12cd3303c082731/" rel="bookmark">
			Linux服务器（CentOS）安装redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载reids
sudo yum install epel-release sudo yum install redis 编辑配置文件，放开远程链接
vim /etc/redis.conf 将bind 127.0.0.1 改为 bind 0.0.0.0
禁用保护模式: protected-mode no
增加密码:
requirepass yourpassword 重启redis:
sudo systemctl restart redis 测试
redis-cli -h localhost -p 6379 -p paasword 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1392cbc4923d4e4c1483d577402c28/" rel="bookmark">
			深入探讨视频美颜SDK：直播美颜工具的核心技术与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章，笔者将深入探讨视频美颜SDK的核心技术及其在直播美颜工具中的实现。
一、视频美颜SDK的核心技术
视频美颜SDK通过一系列复杂的算法和技术，实时处理视频流并应用各种美颜效果。这些核心技术主要包括以下几个方面：
1.人脸识别与追踪技术
人脸识别是视频美颜的基础。通过先进的计算机视觉算法，SDK能够在视频流中准确识别人脸并进行实时追踪。这项技术不仅要识别面部轮廓，还要识别面部的细微特征，如眼睛、鼻子、嘴巴等，从而为后续的美颜处理提供基础。
2.美颜算法
美颜算法是视频美颜SDK的核心。常见的美颜功能包括皮肤磨皮、美白、瘦脸、放大眼睛等。这些算法通过调节图像中的像素值来实现。例如，磨皮算法通过去除图像中的高频噪声来平滑皮肤，而瘦脸算法则通过调整面部轮廓的像素位置来实现。
3.增强现实（AR）技术
除了基本的美颜功能，许多视频美颜SDK还支持AR特效。AR技术能够在用户面部添加动态的虚拟元素，如耳朵、眼镜或化妆效果。这些特效通常与人脸识别技术相结合，使得特效能够随着用户面部的移动而变化，增强了互动性。
4.实时渲染与优化
由于视频美颜需要在直播过程中实时应用，SDK的性能优化显得尤为重要。通过GPU加速、优化算法以及减少延迟等手段，SDK能够在不影响直播流畅度的情况下，实现高质量的美颜效果。
二、直播美颜工具的实现
在实现直播美颜工具时，开发者需要将视频美颜SDK与直播平台进行深度集成。以下是实现过程中需要考虑的几个关键因素：
1.视频流的获取与处理
2.多平台兼容性
3.用户交互与控制
4.安全与隐私
小编认为，通过不断优化和创新，视频美颜技术将在未来为用户带来更加自然、流畅的美颜体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c38e3c519a99c35846e5690a17d0a3a9/" rel="bookmark">
			python-爬虫实例（4）：获取某站的某某的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
道路千万条，安全第一条
爬虫不谨慎，亲人两行泪
获取b站的章若楠的视频
一、话不多说，先上代码
二、爬虫四步走
1.UA伪装
2.获取url
3.发送请求
4.获取响应数据进行解析并保存
总结
前言 道路千万条，安全第一条 爬虫不谨慎，亲人两行泪 获取b站的章若楠的视频 不要问，问就是博主喜欢，嘿嘿嘿嘿（流口水）
图片转载自Sina Visitor System
一、话不多说，先上代码 # 请求b站视频 import json import requests from lxml import etree if __name__ == '__main__': head = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0" , # 防盗链 "Referer": "https://www.bilibili.com/" , "Cookie": "buvid3=3EEF3EE1-472C-F430-105F-0E4F321F331C25161infoc; b_nut=1720613925; _uuid=46847D108-EFD1-9828-99910-32119EADB6EB26022infoc; enable_web_push=DISABLE; buvid4=E9918A3A-008D-2748-2B1F-78B04E8CCA5825688-024071012-IYJQtQw8DTdtrI0uY1UGvQ%3D%3D; buvid_fp=adf3cfaf35396cd4f051041d58ea252d; DedeUserID=455536180; DedeUserID__ckMd5=ece5cba51b3582b0; header_theme_version=CLOSE; rpdid=|(Y|RJRRJ~m0J'u~k|YuR|k); hit-dyn-v2=1; CURRENT_BLACKGAP=0; CURRENT_FNVAL=4048; CURRENT_QUALITY=80; b_lsid=FA4254F2_190DA67F5A6; bmg_af_switch=1; bmg_src_def_domain=i0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c38e3c519a99c35846e5690a17d0a3a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0877fb9168f67eb8608cdbcfe0699846/" rel="bookmark">
			centos7突然掉电后启动报错/dev/mapper/centos-root does not exist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象 物理服务器SR588已安装centos7，突然掉电后系统进不去，提示/dev/mapper/centos-root does not exist
问题解决过程 网上搜索相关的解决方法
1、
用此方法不行
2、
用此方法也是不行
3、
分析查看ls /dev/mapper，目录底下没有centos-root路径，/dev目录底下也没有centos路径，但是ls /dev/查看到sda、sdb、sdc、sdd四块物理盘，理应配置完阵列后，正常应该显示一块sda，怀疑阵列卡配置有问题。
服务器重启按F1，进入阵列卡配置界面，发现是软阵列，阵列5是降级状态，1槽位硬盘被踢出阵列处于offline状态。
选中1槽位硬盘，设置为non-raid模式，再设置为热备盘，自动加入到已有阵列5里面，查看阵列5状态为正在重构状态，重启服务器后可以正常进入系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddfe7070ab70a52fe813e3881084f070/" rel="bookmark">
			4. kafka消息监控客户端工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 KafkaKing官网地址 : https://github.com/Bronya0/Kafka-King
github下载地址 : Releases · Bronya0/Kafka-King (github.com) (windows、macos、linux版本)
云盘下载地址 : https://pan.baidu.com/s/1dzxTPYBcNjCTSsLuHc1TZw?pwd=276i (仅windows版本)
连接kafka 输入本地地址后，点击“连接测试”按钮。如果显示绿色“连接成功”，则表示Kafka连接已建立。
测试消息发送 点击“模拟”按钮，选择相应的主题，填写消息内容，最后点击“发送”。
最后，回到 IDEA 控制台，我们就能看到刚刚发送的那条消息了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84e5dc2d92c7149cb334c1e7182888a/" rel="bookmark">
			【轻松拿捏】Java中ArrayList 和 LinkedList 的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ArrayList 和 LinkedList 的区别是什么？
1. ArrayList
2. LinkedList
3.总结
🎈边走、边悟🎈迟早会好
ArrayList 和 LinkedList 都是 Java 中常用的 List 接口的实现类，但它们在内部结构和操作性能上有所不同。
1. ArrayList 内部实现：底层使用动态数组实现。它的元素存储在一个连续的数组中，当数组容量不足时，会自动扩容（通常是原容量的1.5倍）访问元素：由于底层是数组，因此可以通过索引快速访问元素，时间复杂度为 O(1)。插入和删除元素：如果是在末尾插入或删除元素，性能较好，时间复杂度为 O(1)。但如果是在中间或开头插入或删除元素，由于需要移动大量元素，时间复杂度为 O(n)。内存消耗：由于是基于数组的结构，所以除了存储元素本身外，还需要额外的内存来存储数组的容量（可能大于实际元素的个数）。适用场景：适合需要频繁读取元素、较少插入和删除操作的场景，如需要通过索引快速访问元素。 2. LinkedList 内部实现：底层使用双向链表实现。每个元素都包含一个指向前一个元素和后一个元素的指针，所以插入和删除操作不涉及大量元素的移动。访问元素：需要遍历链表找到指定位置的元素，时间复杂度为 O(n)。插入和删除元素：由于是链表结构，插入和删除元素只需要调整指针，不需要移动其他元素，时间复杂度为 O(1)。但如果要在中间或开头插入，仍需要先遍历到指定位置，因此整体复杂度为 O(n)。内存消耗：每个元素除了存储数据本身外，还需要额外的内存来存储指向前后元素的指针。适用场景：适合插入和删除操作频繁的场景，尤其是在中间插入或删除元素。 3.总结 如果主要是进行随机访问和遍历操作，ArrayList 更合适；如果需要频繁地在列表中间插入或删除元素，LinkedList 更加高效。
🌟感谢支持 听忆.-CSDN博客
🎈众口难调🎈从心就好 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec8232bd2282ef71d1721ed2be9f856/" rel="bookmark">
			迪杰斯特拉(Dijkstra)算法（C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迪杰斯特拉（Dijkstra）算法是一种用于在加权图中找到单个源点到所有其他顶点的最短路径的算法。它是由荷兰计算机科学家艾兹格·迪科斯彻（Edsger Dijkstra）在1956年提出的。Dijkstra算法适用于处理带有非负权重的图。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。适用的是单源路径最短路问题，对于多源则采用弗洛伊德（Floyd）算法。
基本思想： 1. 创建一个集合S，用于存储已经找到最短路径的顶点。
2. 将所有顶点的最短路径估计值初始化为无穷大（或一个非常大的数），除了源点其值为0。
3. 不断从未加入S的顶点中选择一个具有最小估计值的顶点u，加入到S中。
4. 更新u的所有邻接顶点v的最短路径估计值。如果通过u到达v的路径比当前已知的路径更短，则更新v的估计值。
5. 重复步骤3和4，直到所有顶点都被加入到S中。
Dijkstra算法的时间复杂度为O(n^2)
下面介绍Dijkstra算法最重要的思想，如果A-&gt;B的代价为10，A-&gt;C的代价为1，C-&gt;B的代价为2，那么我们可以采用绕路的方式，把C点当作中转点，路线为ACB，这样代价为3小于A直接到B的代价10。
图解算法： 下面放一张Dijkstra算法的动态实现图，方便大家理解一下Dijkstra算法的主要思想。没有看懂没有关系，下面我会一步一步的详解。图片来自全栈程序员站长。
下面我们将以此图为例子进行一步一步讲解。
初始： 我们初始设有6个点，起点为a，终点为b，每个点到另一个点的距离如图所示，如果不能到达则为inf，Dis数组为起点到任意一点的最短距离，vis为标记数组，每次寻找最短距离。起点到起点不需要任何代价，所以为0，标记为true。
第一步： 从起点到能够到达的点更新最小距离，与6号点相邻能到达的有1、3、5号点，距离分别为9、2、9，在Dis数组里面都比inf要小，所以更新其值。我们寻找其中最小的距离为2（3号结点），那么我们就更新vis数组标记为true。
第二步： 由3号点可以到达2、4号点，我们发现起点到2号点的距离为2+10=12&lt;inf，所以更新Dis数组，起点到4号点为2+11=13&lt;inf，所以更新Dis数组。此时Dis数组中的最短距离为9，对应5号点。把5号点标记为true。
第三步： 由5号点可以到达4号点，那么由5号点作为中转点，起点到达4号点的距离为9+6=15&gt;13，所以不更新Dis数组，此时Dis数组中最小的为12（2号点），把2号点vis标记为true。
第四步： 由2号点可以到达4号点，2号点作为中转点，起点到达4号点的距离为2+10+15=27&lt;13，所以Dis数组不更新。此时Dis数组中最小值为13（4号结点），标记vis数组。
第五步： 此时没有被标记的点且Dis数组中最小的值为1号点，那么标记1号点，1号点可以到达2、3号点，把1号点作为中转点，起点到达2号点的距离为14+7=21&lt;12，不更新，起点到达2号点的距离为14+9=23&lt;2不更新，此时vis数组都标记完成，算法结束，起点到每个点的最小距离为Dis数组。
视频讲解可以看一下这意味B站up主的，博主觉得他讲的非常好，通俗易懂，--&gt;点击直达&lt;-- C++实现示例： #include&lt;iostream&gt; using namespace std; int n,e,s;//n个顶点，e条边，s是起点 const int inf=0x7fffff; int dis[101];//dis[i]起点到i的最短距离 int cheak[101];//标记是否找到 int graph[101][101];//记录路径i-&gt;j有路径 int main(){ for(int i=1;i&lt;=100;i++){//初始无穷大 dis[i]=inf; } cin&gt;&gt;n&gt;&gt;e; for(int i=1;i&lt;=e;i++){//邻接矩阵存储 int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; graph[a][b]=c; } cin&gt;&gt;s; dis[s]=0;//起点到起点不需要带价 for(int i=1;i&lt;=n;i++){ int minn=inf,minx; for(int j=1;j&lt;=n;j++){ if(dis[j]&lt;minn&amp;&amp;cheak[j]==0){//寻找此点到其他点的最小距离 minn=dis[j]; minx=j; } } cheak[minx]=1;//标记到达的最小点 for(int j=1;j&lt;=n;j++){//更新以最小距离点最为中转点的最小距离 if(graph[minx][j]&gt;0){ if(minn+graph[minx][j]&lt;dis[j]){ dis[j]=minn+graph[minx][j]; } } } } for(int i=1;i&lt;=n;i++){//打印最短距离 cout&lt;&lt;dis[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ec8232bd2282ef71d1721ed2be9f856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31266de849ecff0dc36e4c80bd9088d5/" rel="bookmark">
			C &#43;&#43;初阶：C&#43;&#43;入门级知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🌞0.前言
🚈1.C++输入输出
🚈2.缺省参数
🚝2.1全缺省参数
🚝2.2半缺省参数
🚈3.函数重载
🚝3.1参数类型不同
🚝 3.2参数个数不同
🚝3.3参数类型顺序不同 ​编辑🚝 3.4为什么C++支持，C语言不支持（底层）
🚈4.引用
🚝4.1引用特性
✈️4.1.1引用在定义时必须初始化
✈️4.1.2引用在定义时必须初始化 ✈️4.1.3.引用一旦引用一个实体，再不能引用其他实体
🚝4.2常引用
🚝4.3使用场景
🚝 4.4传引用和传值效率对比
🚝4.5加餐：不同变量的传值传引用经历了一个什么过程
✈️4.5.1传值
✈️4.5.2传引用
🚈5.内联函数
🚝5.1特性：
🚈6.auto
🚝6.1一些注意点
🚈7.for 🚈8.nullptr（空指针）
​编辑
💎9.结束语
🌞0.前言 言C++之言，聊C++之识，以C++会友，共向远方。各位博友的各位你们好啊，这里是持续分享C++知识的小赵同学，今天要分享的C++知识是C++入门知识点，在这一章，小赵将会向大家展开聊聊C++入门知识点。✊
在上一章，我们算是初步入门了C++的基础知识，知道了C++中有命名空间，域等新东西的引入，那么这一章我们继续去学习C++的一些基础知识。
🚈1.C++输入输出 任何一门编程语言的最开始，一般都是从HELLO WORLD开始的，象征着这门语言的诞生，而每门语言的输出HELLO WORLD的方式也是不同的，正如C语言的printf(),python的print(),java的System.out.println()，我们C++也有自己的输出方式就是cout，与之相对应的还有cin输入，这个输入输出和原本的C语言的scanf和printf有什么区别呢？
C++写HELLO WORLD
在这里我们看到我们的C++在输出的时候和C语言的输出是有着极大的不同的，不用像之前那样加括号，写这是什么类型便直接可以输出出来。与之相对应的输入也是如此。
C++的输入输出
它都会在底层为大家展开。但这里我们也要写一下头文件，就和C语言一样，C++的输入输出是在头文件的#include&lt;iostream&gt;里面的。同时C++在输出方面引入了新的换行符。
C++的换行endl
🚈2.缺省参数 相比较C语言，C++做出的一大创新便是缺省参数的引入，什么叫缺省参数呢？缺省参数这个概念其实在函数中引入的。例如我们之前的函数。
int ADD(int a,int b) { return a + b; } 这里我们要调用的话就必须手动输入两个值给a和b；
而缺省参数是什么，是即使你不输入值，我也可以运行。那这是怎么做到的呢？就是你先给他值。
这个给人的感觉就有点像替补的队员，主队员不再时候，这个时候我们的替补就可以上场了。（除了这个，我一个朋友的比方也很有意思，说这个就是备胎，现在的没有了就用备用的，也是蛮有意思的一个比方）。 缺省参数有两种，一种叫全缺省，一种叫半缺省。
🚝2.1全缺省参数 全缺省参数比较好理解就像我们上面的ADD函数一样每个值都有一个替补，随时准备上场。
int ADD(int a=1,int b=5)//全缺省参数 { return a+b; } int main() { cout&lt;&lt;ADD(3, 5)&lt;&lt;endl;//输出3+5 cout &lt;&lt; ADD(2) &lt;&lt; endl;//输出2+5 cout&lt;&lt;ADD();//输出1+5 } 在这里要注意的是 我们不能省略第一个参数的输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31266de849ecff0dc36e4c80bd9088d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9ba6948bf3979ae0fad84033703473/" rel="bookmark">
			从【人工智能】到【计算机视觉】，【深度学习】引领的未来科技创新与变革
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天偶然发现了一个超棒的人工智能学习网站，内容通俗易懂，讲解风趣幽默，简直让人欲罢不能。忍不住分享给大家，点击这里立刻跳转，开启你的AI学习之旅吧！
前言 – 人工智能教程https://www.captainbed.cn/lzx
1. 引言 1.1 文章目的 本文旨在为读者提供一个全面的人工智能学习指南，涵盖从基础概念到高级技术的方方面面。我们将通过理论讲解、代码示例和应用场景分析，帮助读者深刻理解人工智能、机器学习、算法、深度学习和计算机视觉的基本原理和实际应用。
1.2 人工智能的定义 人工智能（AI）是指通过计算机系统来模拟人类的智能行为，如学习、推理、规划、理解自然语言、感知视觉和执行复杂任务等。AI的核心在于通过算法和模型使机器能够自主决策，从而替代或辅助人类进行各类复杂任务。
1.3 人工智能的重要性 人工智能的重要性日益显著。它不仅在提高生产力、优化资源配置方面发挥了关键作用，还在医疗、金融、制造业、教育等领域带来了深远的变革。AI正在改变我们生活和工作的方式，使得许多曾经不可能实现的任务成为现实。
2. 人工智能的基础 2.1 人工智能的起源与发展 起源
人工智能的起源可以追溯到20世纪50年代，当时的研究者开始探索如何让计算机执行复杂的认知任务。图灵提出的“图灵测试”是早期AI发展的一个里程碑，用于评估机器是否能够表现出与人类相似的智能。
发展历程
人工智能的发展经历了几个阶段：
规则系统和专家系统时代（1950-1970）：AI的早期发展主要依赖于明确的规则和专家系统，用于特定领域的问题求解。机器学习时代（1980-2000）：随着计算能力的提升和数据量的增加，AI开始转向机器学习，通过数据驱动的方法进行学习和预测。深度学习时代（2010至今）：深度学习的兴起带来了AI的巨大突破，特别是在图像识别、自然语言处理等领域，表现出超越传统方法的性能。 2.2 人工智能的关键领域 计算机视觉
计算机视觉是AI的重要领域，涉及如何让机器“看懂”图像和视频。它的应用包括自动驾驶、医学影像分析、安防监控等。
自然语言处理（NLP）
NLP致力于让机器理解和生成自然语言。它的应用范围广泛，包括语音识别、机器翻译、聊天机器人等。
机器人技术
机器人技术结合了机械工程、电子工程和计算机科学，通过AI赋予机器人自主学习和执行任务的能力，应用于制造业、医疗和服务领域。
强化学习
强化学习是一种通过奖励和惩罚机制让智能体学习如何在环境中进行决策的技术。它在游戏AI、自动驾驶、金融交易等领域有着广泛的应用。
2.3 人工智能的应用领域 人工智能的应用已经渗透到各个行业。以下是一些典型的应用场景：
医疗保健：AI用于疾病诊断、个性化治疗方案的制定、药物研发和医疗影像分析。通过AI的帮助，医疗效率得到了显著提升。
金融服务：在金融领域，AI用于风险管理、欺诈检测、自动交易和客户服务。它帮助金融机构更快地处理数据和做出决策。
制造业：AI促进了智能制造的发展，如生产自动化、预测性维护和质量控制。通过AI的引入，制造过程变得更加高效和精准。
零售业：AI用于推荐系统、客户行为分析、库存管理和供应链优化。它帮助零售商更好地了解客户需求，提高销售和运营效率。
2.4 人工智能的伦理与社会影响 随着AI技术的普及，伦理问题和社会影响变得愈发重要。以下是一些关键的伦理和社会问题：
数据隐私：AI系统通常依赖于大量的个人数据，这带来了隐私泄露的风险。如何在使用数据的同时保护个人隐私是一个重大挑战。
算法偏见：由于数据和算法的固有偏见，AI系统可能会产生不公平的结果。这对社会公平性和公正性提出了挑战。
工作岗位的影响：AI的自动化能力可能会取代某些工作岗位，这对劳动力市场和社会结构产生深远影响。
AI的可解释性：许多AI系统，特别是深度学习模型，被视为“黑箱”，其决策过程难以解释。提高AI的可解释性是增强信任和透明度的重要途径。
3. 机器学习的概述 3.1 机器学习的定义与历史 定义
机器学习是人工智能的一个分支，指的是通过数据驱动的方法让计算机系统能够自动学习和改进。这种学习过程不依赖于明确的编程指令，而是通过算法从数据中提取模式，从而进行预测或决策。
历史
机器学习的发展与人工智能紧密相关。最早的机器学习算法出现在20世纪50年代，但由于计算资源的限制，其应用范围有限。随着计算能力的提升和大数据时代的到来，机器学习成为AI领域的核心技术。
3.2 机器学习的基本概念 特征与标签
特征是用于描述数据的变量或属性，而标签是指示目标值的变量。在监督学习中，模型通过学习特征和标签之间的关系来进行预测。
模型与训练
模型是一个数学表示，用于描述特征和标签之间的关系。训练过程是通过数据输入模型，并调整模型参数，使其能够准确预测输出的过程。
过拟合与欠拟合
过拟合是指模型在训练数据上表现很好，但在新数据上表现不佳的情况。欠拟合则是指模型在训练数据和新数据上都表现不佳的情况。这两种现象都表明模型的泛化能力不足。
交叉验证
交叉验证是一种评估模型性能的技术，通过将数据分成多个子集，并在不同的子集上训练和测试模型，来获得模型的稳定性和泛化能力。
3.3 机器学习的分类 监督学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c9ba6948bf3979ae0fad84033703473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042aaa1d2202eb36d54adc4c3527e236/" rel="bookmark">
			如何一键删除iPhone相册所有照片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拍照已成为我们记录日常生活的常态。但是，大量照片便会积累在设备上，这不仅占用了大量存储空间，而且随着时间的推移，管理这些照片也变得越来越困难。如果你决定清理旧照片，或者出于隐私考虑需要删除所有照片，本文将为你提供如何一键删除iPhone相册所有照片的方法。
使用“照片”应用删除所有照片 虽然iOS没有提供直接的“如何一键删除iPhone相册所有照片”的解决方案，但你可以通过以下步骤高效地完成这一任务：
步骤1: 打开照片应用
解锁你的iPhone并打开“照片”应用。
步骤2: 访问所有照片
点击屏幕底部的“照片”标签，确保你处于“所有照片”视图。这里显示了设备上的所有照片和视频。
步骤3: 开始选择照片
点击右上角的“选择”按钮，然后从最近的照片开始，轻触并向左滑动，选择行中的所有照片。继续这种操作，直至所有照片被选中。
步骤4: 删除照片
在选择所有照片后，点击屏幕底部的垃圾桶图标，确认要删除这些照片。这将把它们移动到“最近删除”相册。
步骤5: 清空最近删除相册
要彻底删除这些照片并释放存储空间，转到“相册”视图，滚动到底部找到“最近删除”相册。打开它，点击“选择”，然后选择“删除全部”。确认后，这些照片将被永久删除。
使用设置清理所有照片 如果你觉得上述方法操作太多，还有另一种更快速清除所有照片的方法：
步骤1: 打开设置
在你的iPhone上打开“设置”应用。
步骤2: 重置手机
下滑到“通用”，找到并选择“传输或还原iPhone”，然后选择“抹掉所有内容和设置”。这个选项会将你的iPhone恢复到出厂设置，包括删除所有的照片和视频。
请注意，使用“抹掉所有内容和设置”功能将删除你手机上的所有数据和设置，不仅仅是照片。确保在执行此操作前备份所有重要数据。
使用第三方应用：CleanMyPhone 对于希望更精确控制删除照片的用户，CleanMyPhone提供了更多选项和功能。
CleanMyPhone的清理功能：
智能识别重复的照片、屏幕截图、模糊图片和屏幕录制允许你快速选择并删除它们。
一键清理功能，可以快速安全地删除所有选定的照片。
CleanMyPhone的整理功能：
根据照片的元数据和主题，智能给照片分类，如宠物、旅行、人像...使照片更有条理的同时，快速筛选照片删除。
如果你正在寻找真正的“如何一键删除iPhone相册所有照片”的方法，也可以在CleanMyPhone的“设置”页面找到“删除照片图库中的所有媒体”这一选项，这就是真正的一键清空所有照片的方法，最后去本机的“照片”应用找到“最近删除”项目，清空照片即可。
总结 通过上述任一方法，你可以快速有效地解决“如何一键删除iPhone相册所有照片”这个困扰很多人的问题，帮助你管理设备存储空间，保护个人隐私。无论是直接通过“照片”应用删除，使用设备的设置彻底还原，还是通过第三方应用如CleanMyPhone进行更细致的管理，每种方法都有其优势，可根据个人需要选择最适合的方式。
免费试用链接
‎CleanMy®Phone: Careful Cleaner on the App Store
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772b57ba0800b7054eab9567e6b3e972/" rel="bookmark">
			优维「架构可视化(视图)」：能力联动让系统架构看得见摸得着
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		撰文：鹿小U / 制图：脾气超好
在优维的产品方法论中，在探讨架构视图的管理时，我们首先需要理解架构视图的整体目标。我们在服务的过程中发现，很多客户目前仍然采用手动绘制架构视图的方式，这种方式存在几个明显的问题：
首先，手动绘制的架构图往往比较零散，难以进行统一管理。这种手工架构图难以支撑一些特定的消费场景，例如在监控发现故障时，需要通过架构视图排查是哪个资源或服务出现问题。手绘图很难与线上监控数据实现有效联动。
其次，随着客户应用系统的增多，针对每个系统手动梳理架构的工作量变得极为庞大。
此外，架构本身会经历频繁的变化，手动梳理无法及时更新架构变化，也无法有效记录架构的历史版本。
针对这些或棘手或鸡肋的问题，优维推出了「架构可视化（视图）」细分化产品，并将产品目标聚焦如下：
首先，这是一个线上视图库，能有效支撑上层数据消费。我们可以将这个视图库嵌入到需要的页面中进行展示。
其次，我们结合CMDB的资源和资源关系数据基础，支撑架构图的快速生成，从而免去了手动绘制的繁琐工作。
最后，我们基于CMDB数据实现了自动更新和变化检查的逻辑，确保视图能够实时反映系统的最新状态。
优维架构可视化（视图）产品能力主要可以分为四大板块：
我们来看一下产品在绘图方面的能力。
首先，我们提供了一种直观的可视化绘制方式。在界面的左侧，用户可以找到各种元素，这些元素可以直接拖动到图表中。这些元素包括但不限于资源元素和一些额外的绘制元素。此外，我们也支持常见的绘制操作。
其次，我们的产品具备与CMDB绑定的能力。用户可以将拖出的资源元素绑定到对应的CMDB实例上，既可以是单个实例，也可以是一组实例，充分满足不同的绑定需求。同时，我们还提供了配置的跳转、图表布局等辅助功能，以增强绘制体验。
对于视图绘制产品能力，我们可以短平快地理解如下：
直观的拖拽式可视化绘制
丰富的元素库供用户选择和拖动
支持快速绘图操作，如一键添加线条和删除元素
CMDB实例的灵活绑定，支持单个或批量绑定
提供配置跳转和图表布局等辅助功能
为了减轻手动绘制图表的工作量，我们为架构可视化（视图）设计了一些小亮点：
首先，我们引入了架构模板功能。目前，系统已内置了四种模板，用户可以通过选择合适的模板来简化绘图过程；接下来，用户只需填写模板所需的一些参数，这些参数通常来源于CMDB的数据。例如，如果需要绘制一个系统的运行架构，用户需要指定要绘制的系统以及该系统所在的环境。通过这种仅需少量参数定义的方式，用户可以快速生成系统运行架构视图。
使用模板的好处在于，用户无需逐一将资源拖入视图，并手动进行服务之间的关联的繁琐操作。只需在系统自动生成的视图基础上，进行手动微调即可。这样，就避免了繁琐的操作，大大提高了绘图效率。
在视图快速生成能力的使用上，我们也做到了极简的“三步走”：
选择合适的内置架构模版；
根据模板要求填写相关参数，如系统名称和环境等；
点击确认，一键生成系统运行架构视图。
除了使用内置模板来生成视图外，优维架构可视化（视图）还支持通过CMDB关系快速添加相关的点。具体操作如下：
用户可以先将一个点拖入图表中；
在这个点上，用户会看到一个小的加号图标。如果这个点是一个与CMDB关联的实例，用户可以通过点击这个加号图标来添加其相关的关联资源和关系；
例如，用户可以选择添加系统下的所有应用，平台将自动在视图中添加应用的资源点，并且自动连线；
通过这种方式，用户可以一键快速选择和绘制大量点，无需额外确认资源数据直接的关系，从而简化了绘图过程。
接下来，我们讨论视图的检查逻辑。优维架构可视化（视图）的一个重要功能特点是与CMDB数据的联动。在进行视图检查时，我们也是基于CMDB数据来执行检查操作，其逻辑流程是：
视图检查是自动触发的，无需用户进行任何配置；
只要视图中的点与CMDB数据建立了关联，系统就会自动执行检查；
检查的过程是对比现网CMDB数据与图中绘制的点，以识别两者之间的差异。
这样的自动化检查确保了视图与CMDB数据的实时同步，维护了视图的准确性和时效性。
支持对多种变化进行检查，包括：
①图中的资源与CMDB数据之间的变化。②相关的关联关系的变化。③支持配置变化的识别。例如，原本在CMDB中关联的某个实例被删除了，我们也能够识别这种配置异常，并将其展示在配置异常列表中。
前面我们讨论了视图的检查逻辑。我们的检查机制仅会暴露出异常或差异信息，而不会自动修改图表。这是因为某些架构视图可能需要人工确认后，才能被认为是可靠和可消费的。因此，在默认情况下，我们不会执行自动更新的操作。
然而，有些情况下，用户可能不希望每次都手动维护图表，而是希望完全依赖于CMDB的数据。对于这种情况，我们提供了自动更新的功能。例如，通过加号关联到图中的点，实际上是来源于该节点的关联关系。我们可以利用这种关联关系来设置自动更新。
以系统关联的应用为例，如果从CMDB中，系统下的应用从四个增加到五个，在设置了自动更新后，图中的应用也将根据CMDB实例的变化而更新，从而在图表上从四个应用变为五个。同样，如果CMDB中删除了某个实例，图中相应的关联也会被自动移除。
什么是视图版本控制？
在平台上，我们有两个主要的菜单项：架构广场和工作台。
架构广场的场景是针对架构消费的，因此在这里用户只能看到可消费的视图版本。而在工作台中，用户可以看到并维护自己绘制过的所有视图版本，这是一个全量的视图版本展示。
那么，架构视图版本何时会从维护状态转变为可消费状态呢？我们默认采用一个审批逻辑。可以配置架构视图平台的管理人员，当视图版本在个人工作台中发布后，它会进入审批页面。管理人员审批通过后，该视图版本就被认为是一个符合标准规范的、可消费的架构视图，并会出现在架构广场中。
两边平台都支持回溯历史视图版本。特别是当系统视图发生变更时，这通常源于系统能力的变更，可能确实涉及到架构的变动。如果发现新的视图版本存在问题或bug，我们可以通过回溯比较与之前版本的差异，来进一步分析。
这可能涉及到检查新版本中有差异的点是否存在异常。这就是我们经常提到的历史版本在消费场景中的应用。
优维架构可视化（视图）还支持更多种类的架构视图消费场景。
架构视图本身的小产品页面主要专注于架构视图的绘制、维护，以及将其识别为可消费版本进行简单的视图展示。然而，架构视图的实际消费场景不仅仅局限在产品内部进行视图查看，更支持上层场景的消费。
目前，我们有以下四个场景的支持：
▎低代码构件：
我们已经将可消费的视图封装成低代码构件，允许通过低代码开发使用这些视图。其特点是能够对视图进行数据渲染，例如监控数据和告警数据，并进行二次加工后嵌入第三方平台。
▎数字化架构自定义视图：
我们考虑在数字化架构平台中增加一个自定义视图的入口，以便不仅维护既定视图，还能根据需求自定义网络架构视图，并将其集成到数字化架构中进行查看。
▎系统态势感知与监控：
系统态势感知和监控平台将支持渲染架构视图，并在图上的资源点展示指标信息和告警信息。这一块已有初步的demo能力，并将进一步支持更灵活的配置和展示。
▎Dashboard集成：
将架构视图封装成构建，以便在我们的Dashboard中直接消费。
对于如何使用低代码构件，我们来看一个简单的示例：
首先，架构视图将提供一份绘制好的图的数据，包括点、边和拓扑布局。其次，需要接入额外的待渲染数据，如指标数据或告警数据。将这些指标数据与视图数据结合，基于视图上的关联资源，根据资源实例的ID进行匹配。这样，在渲染构件上，我们能够展示视图的点边布局，并在这些点边上渲染样式效果，如颜色变化和数字展示，甚至可以自定义点击事件。这样的整个渲染构件可以灵活地嵌入到各个页面，包括第三方平台的页面，或者用于低代码开发的微应用中。
以上是对架构视图能力的介绍。接下来，我们将简要说明架构视图与数字化架构这两者的关系。
在架构视图和数字化架构中，你会发现同时存在的关键架构：系统运行架构、系统逻辑架构以及相关的应用部署架构。这些图在两个产品中都可以绘制，但我们应该如何理解这两个产品在绘制能力上的差异，以及它们各自支持的产品能力呢？
我们的定位如下：
架构视图：
这是一个在线的视图库，主要支持视图的绘制和管理。通过绘制出的视图，它可以支撑一些上层消费场景。在架构视图中，即使是绘制系统逻辑架构或系统运行架构，也是基于CMDB关系进行首次视图绘制。后续，用户可以灵活地绘制图表，不会限制图中内容。例如，如果用户希望将所有主机放入图表中，也是允许的。
数字化架构：
这个产品不仅包含这两张图的维护，而是涵盖了整个系统架构的全生命周期的管理能力。数字化架构中包含了对这两张图的绘制能力，但在此基础上，它会进一步叠加基于架构管理的小能力点。因此，数字化架构中的视图会有一定的绘制限制。例如，逻辑架构中只能展示应用及其调用关系，运行架构中只能展示服务及其调用关系。如果用户想要查看主机，则只能通过下钻方式跳转到服务的部署架构进行查看。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772b57ba0800b7054eab9567e6b3e972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2115290cd437037d1941b3f30b267a06/" rel="bookmark">
			Spring/Spring Boot/微服务/Spring Cloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot可以同时处理多少个请求 待写
SpringBoot为什么默认使用Cglib动态代理 待写
SpringBoot中有几种定义Bean的方式？ 待写
SpringCloud核心组件有哪些，分别有什么作用 服务注册与发现：
客户端负载均衡：
服务熔断：
服务网关：
服务接口调用：
链路追踪：
聚合Hystrix监控数据：
监控中心：
配置中心：
微服务架构原理是什么 主要是面向SOA理念，更细小粒度的拆分，将功能分解到各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。
注册中心的原理是什么？ 以Eureka为例，服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中获取服务列表来完成服务调用。
配置中心的原理是什么？ 在服务运行之前，将所需的配置信息从配置仓库摘取到本地服务，达到统一化配置管理的目的。
配置中心是如何实现自动刷新的？ 1、配置中心Server端承担起配置刷新的职责
2、提交配置触发post请求给server端的bus/refresh接口
3、server端接收到请求并发送给Spring Cloud Bus总线
4、Spring Cloud bus接到消息并通知给其它连接到总线的客户端
5、其它客户端接收到通知，请求Server端获取最新配置
6、全部客户端均获取到最新的配置
配置中心是如何保证数据安全的？ 1.保证容器文件访问的安全性，即保证所有的网络资源请求都需要登录
2.将配置中心里所有配置文件中的密码进行加密，保证其密文性
3.开发环境禁止拉取生产环境的配置文件
用zookeeper和eureka做注册中心有什么区别？ zookeeper保证的是CP(一致性，容错性)，而eureka则是AP(可用性，容错性)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb4daeaa7b367f602f87b450863ad960/" rel="bookmark">
			计算机毕业设计pyspark&#43;django&#43;scrapy租房推荐系统 租房大屏可视化 租房爬虫 hadoop 58同城租房爬虫 房源推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用到的技术:
1. python
2. django后端框架
3. django-simpleui，Django后台
4. vue前端
5. element-plus，vue的前端组件库
6. echarts前端可视化库
7. scrapy爬虫框架
基于大数据的租房信息推荐系统包括以下功能：
数据爬取和清洗
实现方法：使用Scrapy框架进行数据爬取，通过Python进行数据清洗。首先，定义网页解析器，利用XPath语法获取租房信息的相关数据（如房源价格、房屋类型、朝向、楼层等数据），再使用正则表达式对数据进行清洗。
数据库设计与管理
实现方法：使用MySQL数据库存储租房信息数据，设计表结构包括租房信息、用户信息、常用搜索关键词、用户历史搜索记录等，通过Django ORM实现对数据库的数据操作。
推荐算法实现
实现方法：使用基于协同过滤的推荐算法，根据用户过去的租房行为和喜好，从租房信息数据库中寻找类似的房屋信息，然后根据用户的个性化需求和偏好进行推荐。
前后端架构设计与实现
实现方法：使用Vue.js作为前端框架，实现网站界面的交互效果；使用Django作为后端框架，实现网站后台的功能逻辑。采用RESTful API实现前后端数据交互。
可视化展示
实现方法：使用Echarts工具实现数据可视化，并将推荐结果展示在大屏幕上，以便用户能够更直观地了解推荐信息。
统计和分析
实现方法：对租房类型、房屋朝向、楼层类型、房源价格和数量等进行统计和分析，以便为用户提供更全面、准确的租房信息。通过Python的数据分析库（如pandas等）实现数据的处理和分析。
论文可能的摘要：
随着信息化水平的高速发展，租房市场越来越受到人们的青睐。然而，在庞大的租房信息中，如何让用户快速并准确地找到适合自己的房源，成为了当前市场上亟待解决的问题。
本文提出了基于大数据的租房信息推荐系统的实现方案，通过利用 python、django、vue、scrapy、echarts 等技术，搭建一个全面的租房信息平台。
该系统主要分为如下几个模块：信息爬取、数据处理、协同过滤算法、数据可视化以及租房信息推荐等。
在信息爬取方面，本系统采用 scrapy 爬虫框架，对贝壳租房网站进行爬取，获得大量的租房信息。在数据处理方面，本系统通过对爬取的数据进行清洗、去重、筛选等操作，使其更加符合用户需求。
在算法方面，本系统引入协同过滤算法，根据用户在平台上的行为、历史租房记录等因素，为用户推荐有可能满足需求的房源。
在数据可视化方面，本系统利用 echarts 技术，将整合后的数据以图表形式展示在大屏幕上，帮助用户更好地了解市场情况。
通过该租房信息推荐系统的实际应用效果，本文得出结论：该系统能够对租房市场进行有效的数据分析和方便的房源搜索，并且可以根据用户的行为和历史租房记录，向用户推荐更加合适的房源。同时，数据可视化也使得用户更加容易理解市场趋势，更好地做出租房决策。
本文的创新点在于：将 scrapy 与协同过滤算法有机结合，并采用数据可视化的方式展示数据，从而使用户更加直观地了解市场情况。本文还指出了一些改进方向：针对租房市场的特点，可以探索一些更加精准的算法；同时，可以将推荐算法与用户购房意愿、财务状况等个人因素进行结合，提高推荐准确度。
综上所述，本文提出的基于大数据的租房信息推荐系统为租房市场的进一步发展提供了有益的参考。
以下是基于大数据的租房信息推荐系统的论文目录框架：
绪论
1.1 研究背景和意义
1.2 国内外研究现状与进展
1.3 研究内容和目的
1.4 研究方法和技术路线
相关技术介绍
2.1 大数据技术概述
2.2 数据爬取和清洗技术
2.3 协同过滤算法
2.4 可视化技术及工具
系统设计与实现
3.1 系统需求分析与功能模块设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb4daeaa7b367f602f87b450863ad960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ece005b236ecbc90dc5f23a4d1596c/" rel="bookmark">
			【C&#43;&#43;】unordered_set和unordered_map的封装（哈希）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
key和pair 仿函数hash
迭代器
operator++
HashTable.h
my_unordered_map.h
my_unordered_set.h
前言 💬 hello! 各位铁子们大家好哇。
今日更新了unordered_map和unordered_set封装的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
key和pair 前面已经实现了哈希的底层，现用哈希进行封装。
unordered_set和unordered_map的封装和map、set大体思路一样。hash是底层，他并不知道传入的是k还是pair，但是上层的unordered_set和unordered_map知道。所以在hash多传入一个模板参数KeyOfT，这样再在map和set中分别实现取出key的逻辑即可。
仿函数hash 由于hash现在是底层，我们的仿函数不可能直接传给hash底层，所以得在unordered_set和unordered_map上传多一个模板参数，这样取模的仿函数就可以在外面传了。
迭代器 当遍历完一个桶后，准备找下一个桶时，就需要有哈希表，不然就找不到下一个桶，所以iterator需要传第二个参数：哈希表的指针。
operator++ 当当前桶走完了，就要找下一个不为空的桶的第一个节点。循环结束有两种可能，一：所有桶都走完了。二：找到下一个不为空的桶。
HashTable.h #pragma once #include&lt;vector&gt; template&lt;class K&gt; struct HashFunc { size_t operator()(const K&amp; key) { return (size_t)key; //负数、指针都能转 } }; //特化 template&lt;&gt; struct HashFunc&lt;string&gt; { size_t operator()(const string&amp; key) { size_t hash = 0; for (auto ch : key) { hash *= 131; hash += ch; } return hash; } }; namespace open_address { enum State { EMPTY, EXIST, DELETE }; template&lt;class K, class V&gt; struct HashData { pair&lt;K, V&gt; _kv; State _state = EMPTY; }; template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt; class HashTable { public: HashTable() { _tables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ece005b236ecbc90dc5f23a4d1596c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0359d1f50d198e17375cce258bef6cec/" rel="bookmark">
			【高阶数据结构】图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图 1. 图的基本概念2. 图的存储结构2.1 邻接矩阵2.2 邻接表2.3 邻接矩阵的实现2.4 邻接表的实现 3. 图的遍历3.1 图的广度优先遍历3.2 图的深度优先遍历 4. 最小生成树4.1 Kruskal算法4.2 Prim算法 5. 最短路径5.1 单源最短路径--Dijkstra算法5.2 单源最短路径--Bellman-Ford算法5.3 多源最短路径--Floyd-Warshall算法 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1. 图的基本概念 图是由顶点集合及顶点间的关系组成的一种数据结构：G = (V， E)，其中：
顶点集合V = {x|x属于某个数据对象集}是有穷非空集合；
E = {(x,y)|x,y属于V}或者E = {&lt;x, y&gt;|x,y属于V &amp;&amp; Path(x, y)}是顶点间关系的有穷集合，也叫做边的集合。
(x, y)表示x到y的一条双向通路，即(x, y)是无方向的；Path(x, y)表示从x到y的一条单向通路，即Path(x, y)是有方向的。
顶点和边：图中结点称为顶点，第i个顶点记作vi。两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中的第k条边记作ek，ek = (vi，vj)或&lt;vi，vj&gt;。
有向图和无向图：在有向图中，顶点对&lt;x, y&gt;是有序的，顶点对&lt;x，y&gt;称为顶点x到顶点y的一条边(弧)，&lt;x, y&gt;和&lt;y, x&gt;是两条不同的边，比如下图G3和G4为有向图。在无向图中，顶点对(x, y)是无序的，顶点对(x,y)称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，比如下图G1和G2为无向图。注意：无向边(x, y)等于有向边&lt;x, y&gt;和&lt;y, x&gt;。
下面是一些常见的图，G2看着是一颗二叉树为什么也说是图呢？
可以这样理解，树是一种特殊(无环连通)的图，图不一定是树。树关注的节点(顶点)中存的值以及连通关系，图关注的是顶点及边的权值。（边由三部分组成：两个顶点、权值）
树是一种存储式数据结构，节点内存值，然后构成二叉搜索树，AVL树，红黑树。
图是一种表示型数据结构，表示某种场景。
比如说下面的图，顶点可能表示城市，边表示城市之间一个关系（高铁距离、高铁价格、高铁时间。。。）
有了这个东西，提出DFS，BFS遍历，最小生成树（最小代价把图连图），最短路径(一个顶点到其他顶点 或者 多个顶点之间 最短路径)的问题。
图还可以用来表示社交关系
顶点：人
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0359d1f50d198e17375cce258bef6cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/039dfab3f6f0fcd539d822de73b41ecf/" rel="bookmark">
			ee trade：黄金投资与股票投资的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黄金和股票， 是金融市场中两种常见的投资工具， 它们拥有截然不同的特点和风险， 了解它们的差异， 可以帮助投资者制定更合理的投资策略。
一、 投资性质： 避险与成长， 两种投资方向
黄金： 被视为避险资产和保值工具， 在经济不稳定或通货膨胀时期， 黄金通常能够保持其价值， 甚至增值。
股票： 代表的是对一家公司的所有权， 其价值与公司的业绩紧密相关。 股票投资更多地与公司的成长潜力和市场表现挂钩， 风险较高， 但收益也可能更高。
二、 价格波动： 稳定与剧烈， 风险与收益并存
黄金： 价格波动相对较小， 尤其是在短期内。 它更多地受到全球经济状况、 政治事件和货币政策的影响。
股票： 价格波动更为剧烈， 受到公司业绩、 行业动态、 市场情绪等多种因素的影响。
三、 流动性： 易于交易 vs 资金锁定
股票： 通常具有较高的流动性， 投资者可以快速买卖股票， 实现资金的快速周转。
黄金： 流动性相对较低， 尤其是实物黄金， 可能需要考虑存储和运输的问题。
四、 投资门槛： 灵活投资 vs 资金限制
股票： 投资门槛相对较低， 投资者可以根据自己的资金状况选择不同价格的股票， 进行灵活的投资。
黄金： 尤其是实物黄金， 可能需要较高的初始投资， 且存在一定的保管成本。
五、 税务影响： 不同政策， 影响投资收益
股票： 根据不同国家和地区的税务政策， 股票交易的资本利得税可能会影响投资者的最终收益。
黄金： 黄金投资的税务处理可能更为复杂， 需要根据具体的交易形式和持有期限来确定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/039dfab3f6f0fcd539d822de73b41ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46c1573d321d12979e3bf12711aa650/" rel="bookmark">
			【AI 大模型】RAG 检索增强生成 ③ ( 文本向量 | Word2Vec 词汇映射向量空间模型 - 算法原理、训练步骤、应用场景、实现细节 | Python 代码示例 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Word2Vec 词汇映射向量空间模型1、Word2Vec 模型简介2、连续词袋模型 CBOW - 算法原理3、连续词袋模型 CBOW - 模型训练步骤4、跳字模型 Skip-gram - 算法原理5、跳字模型 Skip-gram - 模型训练步骤6、文本向量表示7、Word2Vec 文本向量的应用场景 二、Word2Vec 完整代码示例1、Python 中实现 Word2Vec 模型的库2、安装 tensorflow 软件包3、代码示例4、执行结果 一、Word2Vec 词汇映射向量空间模型 1、Word2Vec 模型简介 Word2Vec 是一个 将 词汇 映射 到 高维向量空间 的模型 , 其 核心思想 是 通过大量的文本数据来学习每个词的向量表示 , 使得 语义相似 的 单词 或 汉字 在向量空间中彼此接近 ;
Word2Vec 的 训练模型 :
连续词袋模型 CBOW跳字模型 Skip-gram 下面介绍上述两种模型的 算法原理 ;
2、连续词袋模型 CBOW - 算法原理 连续词袋模型 CBOW 算法的目的 : 预测 给定上下文词汇 的 中心词 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e46c1573d321d12979e3bf12711aa650/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/37/">«</a>
	<span class="pagination__item pagination__item--current">38/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/39/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>