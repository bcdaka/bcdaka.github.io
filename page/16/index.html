<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd1754c5ea2d2e5e1755a63d2772a27/" rel="bookmark">
			static关键字与单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以修饰属性变量，方法和代码段
static修饰的属性称为静态属性或类属性， 在类加载时就在方法区为属性开辟存储空间，无论创建多少个对象，静态属性在内存中只有一份。
可以使用 类名.静态属性 的方式引用
static修饰的方法称为静态方法或类方法，在类加载时就在方法区中开辟存储空间，存储方法中信息，在调用静态方法时，不会默认传递this参数。static修饰的属性和方法会在类加载的时候在内存中开辟空间
可以使用 类名.方法() 的方式引用
static修饰的代码段称为静态代码段，在类加载时就自动执行，且仅执行一次。
一般初始化操作可以写在静态代码段中。
1.1 对象属性与静态属性 class A{ int i ; static int j ; } class Test{ main(){ A a= new A(); a.i = 10 ; A.j = 20 ; a.j = 20 ; } } 对象属性：只有创建对象，才能引用。
静态属性：可以通过类名直接引用。不需要创建对象。 通过对象也可以引用。
类加载时开辟存储空间， 只有一份， 可以数据共享。
1.2 对象方法与静态方法 特点1
无论是静态方法还是对象方法，都是在类加载的时候，就在方法区中分配了存储空间
无论创建多少个对象，方法在内存中只存储一次。
特点2
在使用上， 对象方法的使用，必须先创建对象，才能调用。
而静态方法，可以通过类名直接调用
特点3
尽然对象方法在内存中只有1份，怎么做到不同对象调用，可以访问不同对象的属性呢？
当通过对象调用对象方法时，会默认传递一个参数，这个实参就是当前对象的地址。这个形参就是this
当通过类调用类方法时，就不会传递对象地址（此时没有对象），静态方法也没有this这个默认参数
简单来说，对象方法和静态方法的区别就在于是否需要引用对象自己的属性变量。
扩展1
静态方法中，不能使用this关键字。（压根就没有）
静态方法中只能直接使用静态成员（属性和方法），不能直接使用非静态成员。
在对象方法中，可以使用对象成员，也可以使用静态成员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd1754c5ea2d2e5e1755a63d2772a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8a8845471b8eac52a66e6405574341/" rel="bookmark">
			20240830 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPTEngineer：AI 开发工程师 几秒钟内创建一个网站
- 并可一键部署发布
- 只需输入简单的文本提示，应用程序便能在几秒钟内生成网页应用的原型。
- 支持与 GitHub 的双向同步。并且支持一键将程序部署到生产环境中。
- 可以在开发过程中即时修改和调整代码。AI 会自动检测并修正开发中的错误。
🔗网站：https://gptengineer.app/
🔗GitHub：https://github.com/gpt-engineer-org/gptengineer.app
🔗 GPTEngineer：AI开发工程师几秒钟内创建一个网站并-CSDN blink-领先的开发者技术社区 Notion发布公告：将禁止俄罗斯用户访问，关闭一切和俄罗斯计费关联的Workspace
- 受美国政府引入了限制措施，禁止向俄罗斯境内的任何个人提供某些软件产品和服务。
- 9月9日起，Notion 将不再向俄罗斯境内的用户提供平台访问权限。
- 任何当前或曾经有与俄罗斯关联的计费信息的Workspace将被终止。
- 所有与俄罗斯关联的订阅计划将被取消。
- 也就是任何与俄罗斯有关联的账号都将收到影响，如果你的Workspace有俄罗斯用户或者和俄罗斯发生关系也会被关闭。
🔗详细公告：https://notion.so/help/restrictions-for-customers-based-in-russia
Google 又发布了三个实验性模型：
※ 一个新的小型变体，Gemini 1.5 Flash-8B
※ 更强大的Gemini 1.5 Pro模型（在编码和复杂提示方面更好）
※ 显著改进的Gemini 1.5 Flash模型
- 这些模型包括全面的改进，尤其是在1.5 Flash模型的许多内部基准测试中性能显著提升，同时在复杂提示和编码方面，1.5 Pro模型的改进也很强。
- 可通过 Gemini API 和 Google AI Studio 访问，名称分别为 Gemini-1.5-pro-exp-0827 和 Gemini-1.5-flash-exp-0827
- Gemini 1.5 Flash-8B是一个小型的80亿参数变体，适用于多模态用例和长文本总结。
- 新的实验性模型可通过Google AI Studio和Gemini API进行测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d8a8845471b8eac52a66e6405574341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297c372186f86ab491a2d7973dd039c2/" rel="bookmark">
			【rk3588】环境搭建及系统编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发板：ROC-RK3588S-PC
官方链接：Welcome to ROC-RK3588S-PC Manual — Firefly Wiki (t-firefly.com)
串口调试配置 一、产品介绍 — Firefly Wiki (t-firefly.com)，可以按照官方链接的说明在个人PC上使用串口。这个串口会输出rk3588的日志信息，同时也可以允许用户输入shell命令进行调试。但是还不能互相传文件。
我们使用串口可以查询到包括内核名称、节点名称、内核发行版本、内核版本、机器类型、处理器类型、硬件平台和操作系统。aarch64是ARMv8架构下的64位指令集架构的官方名称，有时也被人们称为ARM64。
注：作者在使用过程中碰到过串口不能输入shell命令的情况，只能查看日志信息。最终发现是USB转串口模块的问题，更换一个就好了。作者使用的是CH340型号的，不是开发板随带的。
ADB调式配置 除了上述使用串口调试外，我们还可以使用ADB，它是Android的命令行调试工具，但是我们编译的是buildroot系统，其实也可以使用ADB，这一点后面再解释。
连接OTG端口，也就是Type-C的USB口，这一个端口在烧录固件的时候也会用到
安装RK-USB驱动。注意，如果正确进入loader模式但一直找不到设备，可以尝试更换USB线。下载安装ADB工具。
打开命令行窗口，进入ADB根目录。执行adb shell命令，即可输入shell命令了。
交叉编译环境 通常情况下，我们会把编译环境搭建在Linux服务器或者虚拟机上，在那个上面进行编译，然后把编译的文件用在RK3588平台上。显然，Linux服务器或者虚拟机肯定不是和RK3399平台使用相同的架构。例如我们使用的服务器为：
服务器上是x86架构，RK3588是ARM64架构。这个时候就需要交叉编译，其实就是在x86机器上编译的东西放在arm64机器上用。所以，后需的代码工作都是在x86服务器上展开的。（关于怎么登录访问服务器这里就不展开了。。。）
服务器环境啥的都提前配置好了，这里暂时不介绍。
获取SDK 1. 编译 Linux 固件 — Firefly Wiki (t-firefly.com)
我们的计划是编译buildroot系统，那么需要厂商的Linuxsdk，压缩包文件为：rk3588_firefly-1.4.0b.tar.gz，我们使用的是方式一，首先获取的是SDK repo压缩包，将该包解压后再使用命令 .repo/repo/repo sync -l导出源代码。
解压之后其实就一个 .repo的隐藏文件夹。然后执行导出源代码命令。
最后还需要同步代码
以后，我们就可以使用第二个命令进行代码更新了。
Linux SDK 配置介绍 配置文件介绍 在 device/rockchip/rk3588/ 目录下，有不同板型的配置文件(xxxx.mk)，用于管理 SDK 每个环节的编译配置，可以查看一下
显然，根据名称，我们要使用的是roc-rk3588s-pc-buildroot.mk，因为我们要编译buildroot系统。
#**roc-rk3588s-pc-buildroot.mk**文件内容如下 CMD=`realpath $BASH_SOURCE` CUR_DIR=`dirname $CMD` source $CUR_DIR/itx-3588j-buildroot.mk # Kernel dts export RK_KERNEL_DTS=roc-rk3588s-pc-mipi101-M101014-BE45-A1 # PRODUCT MODEL export RK_PRODUCT_MODEL=ROC_RK3588S_PC 前3行代码使用 source 命令来执行位于当前脚本同一目录下的 itx-3588j-buildroot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297c372186f86ab491a2d7973dd039c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103fca9d0616dac63410e95a339f594d/" rel="bookmark">
			从 7000 余项目脱颖而出，飞轮科技《新一代实时分析数据仓库解决方案》荣获 HICOOL 2024 全球创业大赛二等奖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HICOOL 2024 全球创业者峰会于 2024 年 8 月 23 日 -25 日 在中国国际展览中心（顺义馆）成功举行，峰会以“新质引领 创新共融”为主题，聚焦技术创新、产业融合、新质共享与国际合作四大要素。
在 8 月 23 日晚的峰会开幕式上，举行 HICOOL 2024 全球创业大赛颁奖盛典，共颁发一等奖 12 个、二等奖 36 个、三等奖 68 个、优胜奖 84 个。北京飞轮数据科技有限公司（简称：飞轮科技）所申报的 《新一代实时分析数据仓库解决方案》项目，经过 200 余天的激烈比拼，从全球 124 个国家和地区的 7406 个创业项目中脱颖而出，荣获二等奖。
从 7000 余项目脱颖而出 HICOOL 全球创业大赛创办五年以来，共汇聚了全球 145 个国家和地区的 24171 个创业项目、32001 名创业者热情参与，至今已诞生 720 个获奖项目，覆盖人工智能、虚拟现实、医药健康、新一代信息技术、高端装备、新能源、新材料、文化创意、农业科技和食品科技等赛道，培育孵化 16 家独角兽企业、127 家专精特新企业，获奖项目赛后新融资额超 360 亿元人民币，持续引领新质生产力发展。
HICOOL 2024 全球创业大赛热度未减，共吸引来自 124 个国家和地区的 7406 个参赛项目和 9700 名人才报名参赛，报名数量较去年相比增长近 30%。今年大赛获奖席位也从 140 个增加至 200 个，设置一等奖名额 12 个，单个项目奖金为 200 万元；二等奖名额 36 个，单个项目奖金为 100 万元；三等奖名额 68 个，单个项目奖金为 50 万元；优胜奖名额 84 个，单个项目奖金为 20 万元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103fca9d0616dac63410e95a339f594d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e04b20c50cfd26b1a374f857846f8de/" rel="bookmark">
			微信小程序引入unocss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天刚新建一个微信小程序，之前写过一篇《原子化CSS：Unocss的使用》，想着“偷懒”不想定义各种css样式类，于是准备把unocss引入进来使用。
安装与配置 1.安装依赖
npm add -D unocss unocss-preset-weapp 2.配置unocss.config.ts
import { defineConfig } from "unocss"; import presetWeapp from 'unocss-preset-weapp' const include = [/\.wxml$/] export default defineConfig({ content:{ pipeline:{ include } }, presets: [ presetWeapp(), ], // 自定义规则 rules: [], separators:'__' }) 3.在 package.json 中添加脚本命令，用于监听 wxml 文件并生成 wxss 文件：
"scripts": { "unocss": "unocss pages/**/*.wxml -c unocss.config.js --watch -o unocss.wxss" } 4.插入app.wxss中：
@import '/unocss.wxss'; 5.自定义组件中如果需要的话还得再配置一下，否则写了也不生效：
Component({ options: { addGlobalClass: true }, }) 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e04b20c50cfd26b1a374f857846f8de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77769e8b2cb9e2a797e2d7f4d783fb5f/" rel="bookmark">
			深度理解指针（5）----指针完结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，各位小伙伴们我们现在已经对指针有了深刻的理解，指针来到了收尾环节！让我们来做几题例题来复习之前学习的内容吧！
最近爆火的黑神话悟空不知道小伙伴们体验了没有，小编对八戒还有蜘蛛精的凄惨爱情深深打动特意找了一张他们的动漫合影！
一、sizeof和strlen的对比 1、sizeof sizeof 计算变量所占内存内存空间大小的，单位是字节，如果操作数是类型的话，计算的是使用类型创建的变量所占内存空间的大小。sizeof 只关注占用内存空间的大小，不在乎内存中存放什么数据。
例如：
#include&lt;stdio.h&gt; int main () { int a = 10; printf("%d\n", sizeof(a)); printf("%d\n",sizeof(int)); return 0; } sizeof是一个操作数！
2、strlen strlen是C语言库函数，是用来求字符串的长度的·。格式：
size_t strlen (const char*str); strlen统计的是字符串中\0之前的个数。
#include&lt;stdio.h&gt; int main () { char arr1[3] = {'a','b','c'}; char arr2[] = "abcdef"; printf("%d\n",strlen(arr1)); printf("%d\n",strlen(arr2)); return 0; } 在字符数组中不包含\0而在字符串数组中末尾包含\0，同时要注意strlen只能用来统计字符数组的元素个数，不能统计整型数组元素个数！
二、数组和指针笔试题解析​ 1、一维数组​ #include&lt;stdio.h&gt; int main () { int a[] = {1,2,3,4}; printf("%d\n",sizeof(a));// 16 此时传递的是整个数组,所以大小为4*sizeof(int) printf("%d\n",sizeof(a+0));// 4或8 a没有单独的放在sizeof中，所以a是数组首元素地址!,地址的大小为4或8 printf("%d\n",sizeof(*a));// 4 同样a没有单独的放在sizeof中,a是数组首元素地址,解引用后为数组首元素！ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77769e8b2cb9e2a797e2d7f4d783fb5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa101a96b284c193c7e52a0cf4664ec7/" rel="bookmark">
			智能合约漏洞（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在前面的文章中，我们讨论了整数溢出/下溢和时间依赖漏洞。今天，我们将继续探讨智能合约中两种常见的安全问题：拒绝服务（Denial of Service, DoS）和恶意合约依赖漏洞。这些漏洞可能导致合约功能的中断或意外的恶意行为，了解这些问题有助于开发更加健壮的智能合约。
7. 拒绝服务漏洞（Denial of Service, DoS） 定义与解释 拒绝服务（DoS）漏洞是一种攻击形式，旨在通过消耗目标系统的资源（如计算力、内存、Gas等），使目标系统无法正常提供服务。在智能合约中，DoS攻击可能导致合约函数被阻塞，无法执行，甚至导致整个合约失效。
代码案例及分析 contract Auction { address public highestBidder; uint public highestBid; mapping(address =&gt; uint) public refunds; function bid() public payable { require(msg.value &gt; highestBid, "Bid is not high enough"); if (highestBidder != address(0)) { // 退还之前的出价人 refunds[highestBidder] += highestBid; } highestBidder = msg.sender; highestBid = msg.value; } function withdrawRefund() public { uint refund = refunds[msg.sender]; require(refund &gt; 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa101a96b284c193c7e52a0cf4664ec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3cab147494924a7595f4932fdfcb972/" rel="bookmark">
			sqlite3 数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.sqlite3 相关命令：
.tables 查看数据库中的表
.headers on/off 开启或者关闭表头
.width 设置列宽
.mode column 对齐
.schema 查询表头类型
2.sqlite3 的sql语句：
插入数据：insert into + 表名 + values;
查询表：select * from + 表名；
条件查找：select * from 表名 where 列表头 + 关系运算符 + “某一个值”；
模糊查找：select * from 表名 where 列表头 + like + “值的部分”；
按照某个表头顺序排列查找：
select * from 表名 order by 列表头 asc（升序）/desc（降序）；
删除某一行：
delete from 表名 where 表头 = “某值”；
删表：
drop + 表名；
修改：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3cab147494924a7595f4932fdfcb972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3463281066896c1989a111b96c3e40ad/" rel="bookmark">
			C语言---编译和链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编译环境和运行环境 在ANSI C的任何一种实现中，存在两个不同的环境：
第一种：翻译环境，在这个环境下，源代码被转换为可执行的机器指令（二进制指令）；
第二种：执行环境，它用于实际执行代码。
2、翻译环境 翻译环境是由编译和链接两个大的过程组成的，而编译又可以分解为：预处理（预编 译）、编译、汇编三个过程。
2.1、预处理（预编译） 在预处理阶段，源文件（.c）和头文件（.h）会被处理成为 .i 的文件。
命令：
2.2、编译 编译的过程就是将预处理后的文件进行一系列：词法分析、语法分析、语义分析及优化，生 成相应的汇编代码文件。
命令：
例子分析：
（1）词法分析 将源代码程序被输入扫描仪，扫描仪的任务是简单的进行词法分析，把代码中的字符分割 成一系列的记号（关键词、标识符、字面量、特殊字符等）。
16个字符：
（2）语法分析 语法分析器是对扫描产生的记号进行语法分析，从而产生语法树，这些语法树是以表达式 为节点的数。
（3）语义分析 语义分析器来完成语义分析，即对表达式的语法层面分析。编译器所能做的分析是语义的静 态分析。静态语义分析通常包括声明和类型的匹配，类型的转换等。
2.3、汇编 汇编器是将汇编代码转变成机器可执行代码（二进制指令），每一个汇编语句几乎都对应一条机器指令。
命令：
2.4、链接 链接的过程主要包括：地址和空间分配，符号决议和重定位等这些步骤。
链接解决的是一个项目中多文件、多模块之间相互调用的问题。
3、运行环境 多多指教啦！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b298c701c6056962d9cc3cac5ff47c/" rel="bookmark">
			养老小程序源码家政服务小程序开发方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预约上门养老小程序，是php开发预约，前端是uniapp，有开发好的小程序案例，可源码，也可以二开，也可以定制开发。
一 用户端：服务分类、服务内容详情介绍、在线下单支付，管理我的订单。
图1 首页
二 护工端
在接单大厅接单，接单后查看自己的订单，查看收益和提现。
三 管理后台：管理平台的用户、护工、服务分类设置、服务内容设置、订单、提现审核等功能模块。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120749873ce309e090c90a90b4e966b1/" rel="bookmark">
			Kafka 到数据仓库：使用 bend-ingest-kafka 将消息加载到 Databend
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将消息从 Apache Kafka 导入到像 Databend 这样的云数据仓库可能是一项艰巨的任务。bend-ingest-kafka 工具简化了这一过程，使您能够轻松地将 Kafka 消息导入到 Databend 表中。
什么是 bend-ingest-kafka？ bend-ingest-kafka 工具是一个专门为从 Apache Kafka 到 Databend 进行消息加载的命令行工具，支持以下模式：
JSON 模式：此模式解析 JSON 消息并将每个字段加载到目标表的相应列中。它将 Kafka 消息转换为与表模式直接映射的结构化格式。
RAW 模式：在此模式下，该工具会创建一个包含 uuid、koffset、kpartition、raw_data、record_metadata 和 add_time 等列的表。Kafka 消息存储在 raw_data 列中，并将其他元数据注入到其他列中，从而保留原始消息格式并提供有用的上下文。
有关 bend-ingest-kafka 的更多详细信息，请查看 README。要安装 bend-ingest-kafka，请运行以下命令：
go install github.com/databendcloud/bend-ingest-kafka@latest 如何使用 bend-ingest-kafka 在这里中，我们将安装一个本地 Kafka 实例，创建一个主题，并生成一些示例消息。然后，我们将分别以 JSON 和 RAW 模式将这些消息加载到 Databend Cloud 中。
安装 Kafka 在开始之前，请确保您已运行 Kafka 并创建了一个主题。以下是使用 Docker 的快速部署：
使用 Docker 运行 Kafka 容器：
docker run -d \ - name kafka \ -p 9092:9092 \ apache/kafka:latest 创建一个名为 “test-topic” 的主题并生成一些消息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/120749873ce309e090c90a90b4e966b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a703daf65e21dc588e85ba02dfa8fb54/" rel="bookmark">
			模拟登录页，华为账号一键登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍
基于鸿蒙Next模拟账号一键登录，免去账号注册环节
二、场景需求
1. 用户场景
新用户： 需要快速注册并登录，以体验华为的服务。
老用户： 希望快速登录，不用每次输入用户名和密码。
2. 界面设计
Logo和标题： 页面顶部展示华为的Logo及"一键登录"或"华为账号登录"的标题。
3. 功能需求：短信/邮箱验证码：
4. 安全性
二次验证： 可选启用二次验证，如在高风险环境下（新设备登录等），要求用户通过邮件或短信进行确认。
5. 适应性
响应式设计： 确保在不同设备（手机、平板、电脑）上的良好展示。
多语言支持： 提供多种语言选项，方便不同地区用户使用。
6. 用户反馈
操作反馈： 无论是按钮点击还是输入错误，都需要及时反馈用户操作状态。
常见问题解答链接： 用户如果在登录时遇到问题，可以快速找到帮助。
三、业务步骤
第一步：点击“一键登录”，获取登录信息
第二步：拉起授权弹窗
第三步：获取授权，获取用户信息
第四步：展示用户信息，显示功能选项
四、效果展示
五：代码展示：
import { authentication } from '@kit.AccountKit'; import { hilog } from '@kit.PerformanceAnalysisKit'; import { util } from '@kit.ArkTS'; import { BusinessError } from '@kit.BasicServicesKit'; //自定义 import { Mine_SystemItem_Type,CommonConstants } from "../common/CommonConstant" @Entry @Component struct Index06 { @State tabMineItem:Mine_SystemItem_Type[] = CommonConstants.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a703daf65e21dc588e85ba02dfa8fb54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7c08493555d8eccb9b6a1ef8b1719d/" rel="bookmark">
			npm登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm 登录问题 npm login --auth-type=legacy 报错 原因 npm源非npm本身源，需要切换：
查看源 nrm ls 切换为npm源 nrm use npm 重新登录 输入OTP验证后登录成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4acac60df8b9c909bfff5b1f069f68d1/" rel="bookmark">
			IntelliJ IDEA使用内网穿透工具配置的公网地址远程连接本地MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 本地连接测试2. Windows安装Cpolar3. 配置Mysql公网地址4. IDEA远程连接Mysql5. 固定连接公网地址6. 固定地址连接测试 前言 本教程主要介绍如何使用Cpolar内网穿透工具实现在IDEA中也可以远程访问家里或者公司的数据库，提高开发效率！无需公网IP，也不用设置路由器那么麻烦。
IDEA作为Java开发最主力的工具，在开发过程中需要经常用到数据库，如Mysql数据库，但是在IDEA中只能连接本地数据库，有时候需要访问其他地方如家里或者公司的数据库，将无法访问，内网的局限性导致我们只能在同一网络访问，无法跨网络访问，所以，本例将介绍如何在异地也可以实现远程连接本地的数据库，这里我们需要用到一个工具，叫Cpolar.
Cpolar是一种安全的内网穿透的服务，可以将内网下的本地服务器通过安全隧道暴露至公网，使得公网用户可以正常访问内网服务，是一款内网穿透软件。
1. 本地连接测试 首先我们需要确保本地环境下可以通过IDEA正常进行数据库连接，这样方便在公网配置连接的时候减少许多问题，首先打开IDEA，点击右上角Database，然后点击那个加号。
然后选择数据库类型，里面支持非常多数据库，我们选择Mysql数据库。
打开后，输入本地数据库的用户名和密码，点击下面测试连接。
点击后，我们可以看到，提示这个表示测试连接成功，本地连接测试无误，下面我们安装cpolar内网穿透工具，实现无公网远程访问！
2. Windows安装Cpolar cpolar官网：https://www.cpolar.com/
访问cpolar官网，注册一个账号，然后下载并安装客户端，具体安装教程可以参考官网文档教程。
windows系统：在官网下载安装包后，双击安装包一路默认安装即可。linux系统：支持一键自动安装脚本，详细请参考官网文档——入门指南 cpolar安装成功后，在浏览器上访问本地9200端口【http://localhost:9200】，使用cpolar账号登录。
3. 配置Mysql公网地址 登录进去后，点击左侧仪表盘的隧道管理——创建隧道，创建一个Mysql的隧道
隧道名称：可自定义命名，注意不要与已有的隧道名称重复协议：选择TCP本地地址：3306域名类型：随机临时TCP端口地区：选择China 点击创建
隧道创建成功后，点击左侧的状态——在线隧道列表，查看所生成的公网TCP协议的地址，该地址就是公网地址，我们可以在任何设备中的IDEA中都可以访问
4. IDEA远程连接Mysql 上面我们创建好Cpolar的公网地址后，现在开始进行远程连接测试，打开IDEA中数据库的连接界面，输入cpolar的公网地址和对应的端口，注意此处将不是输入3306端口了，然后点击测试连接
可以看到，同样提示连接成功，点击下面OK按钮保存
保存后，我们同样可以测试输入sql语句进行查询，选择数据库，输入查询语句，左上角执行，下面即可显示我们的表数据，这样公网连接就完成了
小结
为了方便演示，我们在前述过程中使用了Cpolar生成的TCP地址隧道，其公网地址是随机生成的。
这种随机地址的优势在于建立速度快，可以立即使用。然而，它的缺点是网址是随机生成，这个地址在24小时内会发生随机变化，更适合于临时使用。
我一般会使用固定TCP域名，原因是我希望将地址发送给同事或客户时，它是一个固定、易记的公网地址，这样更显正式，便于流交协作。
5. 固定连接公网地址 接下来为其配置固定的远程TCP端口地址，该地址不会变化，设置后将无需每天重复修改地址。
配置固定tcp端口地址需要将cpolar升级到专业版套餐或以上。
保留一个固定tcp地址，登录cpolar官网，点击左侧的预留，找到保留的tcp地址，为Mysql隧道保留一个固定tcp地址：
地区：选择China描述：即备注，可自定义 点击保留
地址保留成功后，系统会生成相应的固定公网地址，将其复制下来
打开cpolar web ui管理界面，点击左侧仪表盘的隧道管理——隧道列表，找到我们上面创建的TCP隧道，点击右侧的编辑
修改隧道信息，将保留成功的固定tcp地址配置到隧道中
端口类型：修改为固定TCP端口预留的tcp地址：填写官网保留成功的地址， 点击更新
隧道更新成功后，点击左侧仪表盘的状态——在线隧道列表，可以看到公网地址已经更新成为了固定TCP地址。
6. 固定地址连接测试 固定好后，我们使用固定的公网地址进行连接测试，新建一个连接，输入我们固定的cpolar公网地址和端口号，再输入用户名密码，点击测试连接
同样我们可以看到，测试连接成功，这样一个固定的公网远程本地Mysql数据库的tcp公网地址就配置好了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdc1752861abae65406dee525d5b6087/" rel="bookmark">
			搭建自己的金融数据源和量化分析平台（八）：解析PDF财报中的资产负债表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到了最复杂也是最扯淡的部分：从pdf中解析三大报表
前面下载到了PDF格式的财报。现在根据PDF格式的财报来解析资产负债表的会计项并入库。
这里经过研究发现，诸如三大报表之类的公开数据都受困于各种pdf，无法得到很好的利用，不得不说是一种散户和某某的悲哀。
至于某花顺，某得等大公司，他们就有强大的解析能力或者直接从交易所拿到格式化的三大报表的数据吗？并不是，请看下面的一段引用的话：
“ 这些最原始的数据源主要就是各大金融市场的交易所，这些交易所绝大部分是政府机构运营管理。
它们只提供raw data，也就是最原始的数据。譬如行情数据（market data）都是数据串流，基本面数据（reference data）要么是原始的公告PDF，要么是非常非常简单的基础数据。这些数据往往无法直接使用。
所以最主流的数据供应商都有自己至少100人以上（多则有500人）的数据编辑团队，从事大量的数据加工处理工作，数据采编可以说是高科技行业中的劳动密集型。把那些raw data最终变成可供统计分析使用的结构化数据。”
因此，某花顺的财务数据也是牛马们手打的啊，这也是一种讽刺了。
但我们还是要有点梦想，尽量设计一个能够尽可能多地自动化解析财务数据的系统出来，至于解析不出来和解析错误的股票怎么办？我能想到的办法只有自己手动补全无法解析的结果，此外还是得写爬虫白嫖某花顺，将爬虫结果与解析结果作对比。（这里不得不向某花顺妥协，唉）
首先设计资产负债表的数据库字段如下：
stock_code	str	股票代码 report_year	str	所属年度（2023、2024等） report_type	str	报表类型（一季报、中报、三季报、年报） comp_type	str	公司类型(1一般工商业2银行3保险4证券) total_share	str	期末总股本 cap_rese	str	资本公积 undistr_porfit	str	未分配利润 surplus_rese	str	盈余公积 special_rese	str	专项储备 money_cap	str	货币资金 trad_asset	str	交易性金融资产 notes_receiv	str	应收票据 accounts_receiv	str	应收账款 oth_receiv	str	其他应收款 prepayment	str	预付款项 div_receiv	str	应收股利 int_receiv	str	应收利息 inventories	str	存货 amor_exp	str	待摊费用 nca_within_1y	str	一年内到期的非流动资产 sett_rsrv	str	结算备付金 loanto_oth_bank_fi	str	拆出资金 premium_receiv	str	应收保费 reinsur_receiv	str	应收分保账款 reinsur_res_receiv	str	应收分保合同准备金 pur_resale_fa	str	买入返售金融资产 oth_cur_assets	str	其他流动资产 total_cur_assets	str	流动资产合计 fa_avail_for_sale	str	可供出售金融资产 htm_invest	str	持有至到期投资 lt_eqt_invest	str	长期股权投资 invest_real_estate	str	投资性房地产 time_deposits	str	定期存款 oth_assets	str	其他资产 lt_rec	str	长期应收款 fix_assets	str	固定资产 cip	str	在建工程 const_materials	str	工程物资 fixed_assets_disp	str	固定资产清理 produc_bio_assets	str	生产性生物资产 oil_and_gas_assets	str	油气资产 intan_assets	str	无形资产 r_and_d	str	研发支出 goodwill	str	商誉 lt_amor_exp	str	长期待摊费用 defer_tax_assets	str	递延所得税资产 decr_in_disbur	str	发放贷款及垫款 oth_nca	str	其他非流动资产 total_nca	str	非流动资产合计 cash_reser_cb	str	现金及存放中央银行款项 depos_in_oth_bfi	str	存放同业和其它金融机构款项 prec_metals	str	贵金属 deriv_assets	str	衍生金融资产 rr_reins_une_prem	str	应收分保未到期责任准备金 rr_reins_outstd_cla	str	应收分保未决赔款准备金 rr_reins_lins_liab	str	应收分保寿险责任准备金 rr_reins_lthins_liab	str	应收分保长期健康险责任准备金 refund_depos	str	存出保证金 ph_pledge_loans	str	保户质押贷款 refund_cap_depos	str	存出资本保证金 indep_acct_assets	str	独立账户资产 client_depos	str	其中：客户资金存款 client_prov	str	其中：客户备付金 transac_seat_fee	str	其中:交易席位费 invest_as_receiv	str	应收款项类投资 total_assets	str	资产总计 lt_borr	str	长期借款 st_borr	str	短期借款 cb_borr	str	向中央银行借款 depos_ib_deposits	str	吸收存款及同业存放 loan_oth_bank	str	拆入资金 trading_fl	str	交易性金融负债 notes_payable	str	应付票据 acct_payable	str	应付账款 adv_receipts	str	预收款项 sold_for_repur_fa	str	卖出回购金融资产款 comm_payable	str	应付手续费及佣金 payroll_payable	str	应付职工薪酬 taxes_payable	str	应交税费 int_payable	str	应付利息 div_payable	str	应付股利 oth_payable	str	其他应付款 acc_exp	str	预提费用 deferred_inc	str	递延收益 st_bonds_payable	str	应付短期债券 payable_to_reinsurer	str	应付分保账款 rsrv_insur_cont	str	保险合同准备金 acting_trading_sec	str	代理买卖证券款 acting_uw_sec	str	代理承销证券款 non_cur_liab_due_1y	str	一年内到期的非流动负债 oth_cur_liab	str	其他流动负债 total_cur_liab	str	流动负债合计 bond_payable	str	应付债券 lt_payable	str	长期应付款 specific_payables	str	专项应付款 estimated_liab	str	预计负债 defer_tax_liab	str	递延所得税负债 defer_inc_non_cur_liab	str	递延收益-非流动负债 oth_ncl	str	其他非流动负债 total_ncl	str	非流动负债合计 depos_oth_bfi	str	同业和其它金融机构存放款项 deriv_liab	str	衍生金融负债 depos	str	吸收存款 agency_bus_liab	str	代理业务负债 oth_liab	str	其他负债 prem_receiv_adva	str	预收保费 depos_received	str	存入保证金 ph_invest	str	保户储金及投资款 reser_une_prem	str	未到期责任准备金 reser_outstd_claims	str	未决赔款准备金 reser_lins_liab	str	寿险责任准备金 reser_lthins_liab	str	长期健康险责任准备金 indept_acc_liab	str	独立账户负债 pledge_borr	str	其中:质押借款 indem_payable	str	应付赔付款 policy_div_payable	str	应付保单红利 total_liab	str	负债合计 treasury_share	str	减:库存股 ordin_risk_reser	str	一般风险准备 forex_differ	str	外币报表折算差额 invest_loss_unconf	str	未确认的投资损失 minority_int	str	少数股东权益 total_hldr_eqy_exc_min_int	str	股东权益合计(不含少数股东权益) total_hldr_eqy_inc_min_int	str	股东权益合计(含少数股东权益) total_liab_hldr_eqy	str	负债及股东权益总计 lt_payroll_payable	str	长期应付职工薪酬 oth_comp_income	str	其他综合收益 oth_eqt_tools	str	其他权益工具 oth_eqt_tools_p_shr	str	其他权益工具(优先股) lending_funds	str	融出资金 acc_receivable	str	应收款项 st_fin_payable	str	应付短期融资款 payables	str	应付款项 hfs_assets	str	持有待售的资产 hfs_sales	str	持有待售的负债 cost_fin_assets	str	以摊余成本计量的金融资产 fair_value_fin_assets	str	以公允价值计量且其变动计入其他综合收益的金融资产 cip_total	str	在建工程(合计)(元) oth_pay_total	str	其他应付款(合计)(元) long_pay_total	str	长期应付款(合计)(元) debt_invest	str	债权投资(元) oth_debt_invest	str	其他债权投资(元) oth_eq_invest	str	其他权益工具投资(元) oth_illiq_fin_assets	str	其他非流动金融资产(元) oth_eq_ppbond	str	其他权益工具:永续债(元) receiv_financing	str	应收款项融资 use_right_assets	str	使用权资产 lease_liab	str	租赁负债 contract_assets	str	合同资产 contract_liab	str	合同负债 accounts_receiv_bill	str	应收票据及应收账款 accounts_pay	str	应付票据及应付账款 oth_rcv_total	str	其他应收款(合计)（元） fix_assets_total	str	固定资产(合计)(元) 然后上解析pdf的代码（该代码尚不完善，后期完善了也不会再在博客更新这部分代码，CSDN不配）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdc1752861abae65406dee525d5b6087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb7515f9243b6d3d2036ee1014183570/" rel="bookmark">
			如何利用智能文档处理技术，搭建供应链金融智能审单系统?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		供应链金融业务的风控逻辑在于业务流、信息流、物流、现金流的数据整合及交叉验证，在产业端数字化水平有限以及合规审核要求严格的背景下，审单人员需要对合同、物流单证、财务单证、权属证明文件等文档的关键信息进行细致的审核校验。这些单证是确保交易真实性、评估融资风险，以及进行资金流转的重要依据。
AI审单难点：
供应链金融涉及单证普遍存在文档质量参差、版面复杂的情况，信息抽取的内容包含Key-Value对抽取、无Key的Value抽取、表格内容还原及抽取、关系型抽取等，传统OCR识别结合自然语言处理NLP技术，在应对此类复杂场景时，存在语义能力生硬、依赖规则实现上下文对话、泛化能力差等痛点，并且二次训练依赖大量的数据标注，无法快速进行针对性调优。
合合信息TextIn平台重磅推出“智能文档抽取”产品，彻底解决上述难点！依托合合信息自研的垂直领域语义模型，结合文字识别、文档解析、文档检索和文本生成四项关键技术，实现了开箱即用的“零样本”抽取，具备处理能力强、高精度预测性能、强大的迁移学习能力等多重特点。
下述各类合同单证，仅需在系统中直接配置抽取字段，无需标注训练，即可完成准确的结构化抽取。
01 合同 购销合同：供应链金融中最基本的单证之一，用于明确买卖双方的权利和义务，包括货物描述、价格、数量、交货时间、付款方式等关键条款。
同时还支持抽取仓单质押合同、订单质押合同、应收账款质押合同、担保合同、融资合同等多类型合同中的关键信息。
02 物流单证 仓单：仓单是仓库保管人签发的，证明存货人已经交付仓储物并有权提取该仓储物的凭证。在存货质押融资中，仓单是重要的质押物凭证。
运输单据：用于证明货物的运输情况，包括装运日期、运输路线、货物状态等信息。
03 财务单证 发票：作为交易的真实性和金额的依据，发票在供应链金融中起到至关重要的作用。合合信息「国内通用票据识别」，可识别包含增值税普通发票、增值税专用发票、数电票等在内的23大类、30小类国内通用票据，自动分类票种，支持混贴切分。
04 权属证明文件 产权证书：如房产证、土地使用权证等，用于证明资产的所有权归属。在固定资产抵押融资中，产权证书是必不可少的单证。
知识产权证书：如专利证书、商标证书等，在知识产权质押融资中，用于证明融资方拥有的知识产权价值。
05 承兑汇票 银行承兑汇票&amp;商业承兑汇票：基于银行信用或商业信用的短期金融工具，具有支付结算、信用及融资等多种功能。
06 其他单证 保险单：在涉及货物运输的供应链金融业务中，保险单用于证明货物已经投保，一旦发生损失可以获得赔偿。
海关单据：在国际贸易中，海关单据如报关单、进口许可证等用于证明货物的合法进出口手续。
AI智能审单典型实践 目前，合合信息智能文档抽取技术，已成功应用落地于商业银行、保理公司、物流仓储公司、供应链票据平台等多家供应链金融参与方。
· 上市城商行
某上市城商行与合合信息合作，以智能文档抽取技术为底座，打造了针对供应链金融业务的AI智能审核系统，能够将供应链金融业务中的纸质合同、单据以及资产清单等影像件数字化、结构化，并通过审核规则模型自动完成合规性审查以及关键信息的比对校验，确保合同要素的完整性、交易背景的真实性、应收账款的有效性、单据间数据的一致性，同时大幅降低人力投入成本，显著提升审核效率。
除了常规的文档审核外，智能审核系统同样能够将中登网上的登记资产进行全面数字化处理，包括标准的登记文件以及非标的附件信息，审核人员不用再受困于海量的登记资产去大海捞针，而是能够快速检索和匹配中登网文件中的资产登记信息，及时发现重复登记，实现资产风险的快速排查，从而确保己方登记资产的优先受偿权。
· 央企保理公司
某央企保理公司与合合信息达成合作，实现对供应链贸易场景下的各类票证、合同的智能场景识别、关键信息抽取与智能审核，提升审单业务效率，打造审单新模式。基于智能文档抽取技术，可对合同票证进行智能处理与审阅，自动分类供应链贸易场景，并根据不同场景文档对应的抽取字段，进行关键要素的自动核查、合同支付条款自动识别与动态提取，并智能判断文档页码是否完整、多文档间主体是否一致、金额是否一致等，从而有效提升了公司运营团队的审核效率。
该系统上线三个月，已累计审单超1000笔。平均审核提速1.06小时/单，整体审单效率较系统上线前提升31%。
· 头部供应链票据平台
某头部供应链票据平台提供易流转、可拆分、快速融资的应收账款电子债权凭证，依托合合信息智能文档抽取技术，对购销合同、担保合同、质押合同中的买方、卖方、合同金额、有效期等关键字段信息抽取，并自动校验合同完整性，识别印章，实现智能化审核与数字化确权，提升电子债权凭证开立效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72229f6276b62fad4f6eda7e07121600/" rel="bookmark">
			redis的zset底层数据结构，你真的懂了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、zset的基本功能1.1 zset基本功能描述1.2 zset的常用命令 二、zset的底层数据结构2.1 紧凑列表2.2 跳表 三、什么是跳表3.1 跳表定义3.2 跳表详解3.2.1 跳表的演进3.2.1 跳表高效的动态插入和删除3.2.2 跳表索引动态更新 3.3 zset中的跳表3.3.1 skiplist数据结构 四、hash、B+树、跳表的比较五、Redis 为什么使用跳表而不是B+树参考文章 前言 本文总结了众多文章中最精华的部分，将从以下几点剖析redis中zset数据类型：
zset的基本功能；zset的底层数据结构；什么是跳表；hash、B+树、跳表的比较。 一、zset的基本功能 1.1 zset基本功能描述 redis的zset是一个自动根据元素score排序的有序集合，和普通集合set非常相似，是一个没有重复元素的字符串集合。
1.2 zset的常用命令 #返回按score从大到小排序后且索引在[start,stop]区间的元素，从0开始 zrevrange key start stop [WITHSCORES] #返回按score从大到小排序后且分数在[min,max]区间的元素 zrevrangebyscore key max min[WITHSCORES]- #通过字典区间返回有序集合的成员 zrangebylex key min max[LIMIT offset count] #返回元素member的索引，不存在nil zrank key member- #返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 zrevrank key member #返回有序集合中，元素member分数 zscore key memberr #迭代有序集合中的元素（包括元素的分值） zscan key cursor [MATCH pattern] [COUNT count] #计算给定的一个或多个有序集的并集，并存储在新的 key 中 zunionstore destination numkeys key [key …]- #计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 zinterstore destination numkeys key [key …] #有序集合中对指定元素的分数加上增量 increment zincrby key increment member #移除有序集合中的一个或多个元素 zrem key member[member…] #移除有序集合中给定的字典区间的所有成员 zremrangebylex key min max #移除有序集合中给定的排名区间的所有成员 zremrangebyrank key start stop #移除有序集合中给定的分数区间的所有成员 zremrangebyscore key min max 二、zset的底层数据结构 zset有两种不同的实现方式：紧凑列表和跳表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72229f6276b62fad4f6eda7e07121600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/657cef9fb76b1bf2f0849575ade305f1/" rel="bookmark">
			【Python】--- 基础语法(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Welcome to 9ilk's Code World (๑•́ ₃ •̀๑) 个人主页: 9ilk (๑•́ ₃ •̀๑) 文章专栏： Python 本篇博客博主将分享一些python的基础语法。
🏠 常量和表达式 我们可以把Python当成一个计算器,进行一些简单的算术运算
print(1 + 2 - 3) print(1 + 2 * 3) print(1 + 2 / 3) #输出结果: #0 #7 #1.6666666666665 形如1 + 2 - 3这样的算式,被称为表达式,算式的运算结果称为表达式的返回值.其中1,2,3这种称为字面值常量,+,-,*,/这种称为运算符或着操作符.
注意:
print是Python一个内置函数,用于打印。运算符和数字之间,可以没有空格,也可以有多个空格,但一般为了美观习惯写上一个空格。 可以使用 + - * / ( ) 等运算符进行算术运算. 先算乘除, 后算加减。 在Python中类似2/3整数除整数结果得到的可能是个小数，而C++/Java等语言结果会发生截断结果为0. 🏠 变量和类型 📌 变量 📒 变量是什么 变量可以视为是一块能够容纳数据的空间 . 这个空间往往对应到 " 内存 " 这样的硬件设备上. avg = (67.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/657cef9fb76b1bf2f0849575ade305f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4be5d1dc7957ec276c5ed16744c8bc/" rel="bookmark">
			[Day 66] 區塊鏈與人工智能的聯動應用：理論、技術與實踐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI在客戶服務中的應用案例 隨著人工智能（AI）技術的飛速發展，企業越來越多地將AI應用於客戶服務，以提高效率、降低成本並改善客戶體驗。AI技術使得企業能夠提供24/7的支持，自動處理客戶查詢，並通過分析客戶數據來預測需求和優化服務。在這篇文章中，我們將探討AI在客戶服務中的應用，並通過一些代碼示例來展示如何實現這些技術。
1. 客戶服務中的AI技術概述 AI技術在客戶服務中的應用主要包括以下幾個方面：
聊天機器人（Chatbots）：自動回應客戶查詢，提供即時幫助。語音識別與自然語言處理（NLP）：理解和分析客戶語音和文本信息。情感分析：識別客戶情緒，提供個性化服務。推薦系統：根據客戶的歷史行為推薦產品或服務。自動化數據分析：分析客戶反饋，優化服務流程。 接下來，我們將通過一些代碼示例來展示如何實現這些AI技術。
2. 聊天機器人的實現 聊天機器人是客戶服務中最常見的AI應用之一。它可以自動回應客戶查詢，提供即時幫助。以下是一個簡單的聊天機器人實現示例，使用了Python和Rasa框架。
from rasa.core.agent import Agent from rasa.core.interpreter import RasaNLUInterpreter from rasa.core.policies import MemoizationPolicy, KerasPolicy # 創建Rasa代理 interpreter = RasaNLUInterpreter('./models/nlu/default/current') agent = Agent('domain.yml', policies=[MemoizationPolicy(), KerasPolicy()], interpreter=interpreter) # 加載訓練數據 training_data = agent.load_data('./data/stories.md') # 訓練模型 agent.train(training_data) # 保存模型 agent.persist('./models/dialogue') # 處理用戶輸入 response = agent.handle_text("我想了解更多產品信息") print(response) 代碼解釋：
Agent：Rasa代理對象，用於管理對話流程。RasaNLUInterpreter：NLU（自然語言理解）解釋器，用於理解用戶輸入的文本。MemoizationPolicy和KerasPolicy：Rasa的策略，用於確定對話的響應方式。load_data：加載對話訓練數據，用於訓練聊天機器人模型。train：訓練聊天機器人模型，使其能夠處理對話。persist：保存訓練好的模型。handle_text：處理用戶輸入並返回相應的回應。 3. 語音識別與自然語言處理 語音識別和自然語言處理（NLP）技術使得聊天機器人能夠理解並回應用戶的語音或文本查詢。下面是一個使用Python和SpeechRecognition庫進行語音識別的示例。
import speech_recognition as sr # 創建語音識別對象 recognizer = sr.Recognizer() # 從麥克風獲取音頻數據 with sr.Microphone() as source: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4be5d1dc7957ec276c5ed16744c8bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc00c64f1601bb8ae04882f68004d2d/" rel="bookmark">
			React中实现antd自定义图标，鼠标悬浮变色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借助 antd 的 tooltip 组件来实现 hover 时变色的效果
1.新建组件 自定义图标一般在iconfont上面获取，复制下来的svg代码，切记要删除 fill 属性后添加到组件中
import { Tooltip } from "antd"; import React from "react"; const HoverableSvg = () =&gt; { return ( &lt;Tooltip className="hover-icon"&gt; {/* &lt;svg&gt; ...&lt;/svg&gt; */} &lt;/Tooltip&gt; ); }; export default HoverableSvg; 2.修改样式 在全局样式文件或组件的局部样式中，添加：
.hover-icon { fill: #8a8a8a; } .hover-icon:hover { fill: #faad14; } 3.使用组件 import HoverableSvg from "../components/HoverableSvg"; &lt;HoverableSvg className="com-icon" /&gt; 4.效果 没有错，我在copy某绒，哈哈哈哈
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/17/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>