<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ade8e76fac456ad60a44832ce60dff/" rel="bookmark">
			LogicFlow 学习笔记——2. LogicFlow 基础 实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LogicFlow 实例 创建实例 每一个流程设计界面，就是一个 LogicFlow 的实例。
&lt;template&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;!-- 用于显示 LogicFlow 图表的容器 --&gt; &lt;/template&gt; &lt;script&gt; // 创建 LogicFlow 实例 const lf = new LogicFlow({ container: document.getElementById('container')!, // 指定容器元素 grid: true // 启用网格 }) &lt;/script&gt; 当创建一个实例的时候，我们需要传递初始化LogicFlow实例的配置项。LogicFlow支持非常丰富的初始化配置项，但是只有LogicFlow画布初始化时挂载的DOM节点container参数是必填的。完整的配置项参见LogicFlow API
图数据 在 LogicFlow 里面，我们把流程图看做是由节点和连线组成的图。所以我们采用如下数据结构来表示 LogicFlow 的图数据。
// 定义图形编辑器的初始数据 const data = { // 节点数组 nodes: [ { id: 'node_id_1', // 节点标识 type: 'rect', // 节点形状类型：矩形 x: 100, // 节点在画布上的 x 坐标 y: 100, // 节点在画布上的 y 坐标 text: { x: 100, y: 100, value: '节点1' }, // 节点的文本及其位置 properties: {} // 节点的自定义属性 }, { id: 'node_id_2', // 另一个节点标识 type: 'circle', // 节点形状类型：圆形 x: 200, // 节点在画布上的 x 坐标 y: 300, // 节点在画布上的 y 坐标 text: { x: 300, y: 300, value: '节点2' }, // 节点的文本及其位置 properties: {} // 节点的自定义属性 } ], // 边数组 edges: [ { id: 'edge_id', // 边的标识 type: 'polyline', // 边的类型：多段线 sourceNodeId: 'node_id_1', // 起始节点 targetNodeId: 'node_id_2', // 目标节点 text: { x: 139, y: 200, value: '连线' }, // 边上的文本及其位置 startPoint: { x: 100, y: 140 }, // 起始点坐标 endPoint: { x: 200, y: 250 }, // 结束点坐标 pointsList: [ { x: 100, y: 140 }, { x: 100, y: 200 }, { x: 200, y: 200 }, { x: 200, y: 250 } ], // 折点的列表，定义折线的形状 properties: {} // 边的自定义属性 } ] } text可以直接使用字符串，这个时候，如果是节点的文本，LogicFlow 会自动采用节点坐标作为节点文本坐标，如果是连接文本，LogicFlow 会基于不同的连线类型计算一个合适的坐标作为节点坐标。在有些应用场景下，我们文本是可以拖动的，为了保持一致，LogicFlow导出的文本数据都会带上坐标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91ade8e76fac456ad60a44832ce60dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3970264e9a6f25c4c4f73fefcbac5763/" rel="bookmark">
			计算机相关专业的探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、计算机相关专业是否仍是“万金油”选择
二、计算机行业的未来发展态势
三、从专业与个人的匹配度判断选择计算机相关专业
四、对于高考生的建议
一、计算机相关专业是否仍是“万金油”选择 计算机相关专业在过去很长一段时间内确实被视为“万金油”专业，具有广泛的就业前景和应用领域。然而，随着技术的快速发展和市场的变化，我们需要从多个角度来审视这一观点。
从就业前景来看，计算机科学与技术、人工智能、网络安全、软件工程等专业仍然具有较大的发展潜力。随着数字化时代的到来，计算机专业人才的需求不断增加，尤其在软件产品开发、信息技术服务、云计算、大数据等领域，计算机专业人才的需求依然旺盛。
从个人能力和兴趣角度来看，选择计算机相关专业需要具备一定的数学、逻辑推理和编程技能。如果你对编程感兴趣，喜欢解决复杂问题，具备较强的逻辑思维能力，那么这些专业可能非常适合你。同时，你也需要考虑到自己是否愿意不断学习和更新知识，因为计算机行业的技术更新速度非常快。
也需要注意到的是，随着行业竞争加剧和市场饱和度提高，计算机相关专业的就业竞争也越来越激烈。因此，在选择专业时，除了考虑自己的兴趣和能力外，还需要关注行业的发展趋势和市场需求，以及自己的职业规划和发展目标。
二、计算机行业的未来发展态势 从当前的发展趋势来看，计算机行业仍然具有广阔的发展前景。随着技术的不断进步和创新，新型计算机系统如量子计算机、光子计算机等不断涌现，将带来更大的发展空间和机遇。同时，计算机行业也在向更多领域渗透和融合，如人工智能、物联网、区块链等，这些领域的发展也将为计算机行业带来新的增长点。
然而，也需要注意到的是，计算机行业的发展也面临着一些挑战和问题。例如，随着技术的快速发展，人才短缺和人才流失问题日益突出；同时，网络安全、数据隐私等问题也需要得到更多的关注和解决。
三、从专业与个人的匹配度判断选择计算机相关专业 选择大学专业是一个重要的决策过程，它涉及到个人的兴趣、能力、职业规划以及未来发展等多个方面。对于计算机相关专业，从专业与个人的匹配度来判断是否适合选择，是一个非常重要的角度。
兴趣是选择专业的关键因素之一。如果你对计算机、编程、算法、网络等方面有浓厚的兴趣，那么计算机相关专业可能是你的不二之选。因为兴趣能够激发你的学习动力，使你在面对困难和挑战时更加坚韧不拔。
能力也是选择专业时需要考虑的因素。计算机相关专业通常要求学生具备较好的逻辑思维能力、数学基础以及编程技能。如果你在这些方面有较强的能力，那么选择计算机相关专业将更容易取得好的成绩和表现。
职业规划也是选择专业时需要考虑的重要因素。如果你希望未来从事与计算机相关的职业，如软件开发、网络安全、数据分析等，那么选择计算机相关专业将更有助于你实现职业目标。同时，你也需要了解该行业的就业市场和发展趋势，以确保你的选择具有长期的发展潜力。
个人特点也是影响专业选择的重要因素。例如，如果你是一个喜欢创新、追求新技术的人，那么计算机相关专业可能更适合你；如果你是一个注重细节、善于解决问题的人，那么软件工程或网络安全等专业可能更适合你。
从专业与个人的匹配度来判断选择计算机相关专业，需要综合考虑多个因素。如果你对计算机感兴趣，具备相关能力，并有明确的职业规划和个人特点，那么选择计算机相关专业将是一个明智的决策。当然，在做出选择之前，你也可以通过咨询专业人士、参加相关活动或实习等方式，进一步了解该专业的实际情况和发展前景，以确保你的选择更加明智和准确。
四、对于高考生的建议 对于即将面临选择的高考生来说，首先要明确自己的兴趣和能力所在，了解自己对计算机相关专业的兴趣和适应能力。其次，要关注行业的发展趋势和市场需求，以及自己的职业规划和发展目标，做出合理的选择。最后，也要做好不断学习和更新知识的准备，以适应计算机行业快速发展的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/474fcdebe489b542e686cab6e4a5f06b/" rel="bookmark">
			Go API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言提供了大量的标准库，因此 google 公司也为这些标准库提供了相应的API文档，用于告诉开发者如何使用这些标准库，以及标准库包含的方法。官方位置：https://golang.org
Golang中文网在线标准库文档: https://studygolang.com/pkgdoc
函数对应的源码查看：
也可以使用离线API：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62b564ee539819157b1bec2c7808151/" rel="bookmark">
			OpenCV--图像色彩空间及转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像色彩空间及转换 python代码和笔记 python代码和笔记 import cv2 色彩空间，基础：RGB或BGR OpenCV中： 一、HSV(HSB)：用的最多， Hue：色相-色彩(0-360)，红色：0°，绿色：120°，蓝色：240° Saturation：饱和度，表示颜色接近光谱色的程度，0%-100%，(混合) Value(Brightness)：明度，表示颜色明亮的程度0%(黑)-100%(白) 二、HSL：与一不同 S：颜色的纯度，(稀释) L和B也一样 """ """ 颜色空间转化 """ def callback(value): pass cv2.namedWindow('color', cv2.WINDOW_NORMAL) cv2.resizeWindow('color', 640, 480) # 读取图片 img = cv2.imread('./img/cat.jpeg') # 定义颜色空间转化列表 colorSpaces = [ cv2.COLOR_BGR2RGB, cv2.COLOR_BGR2BGRA, cv2.COLOR_BGR2GRAY, cv2.COLOR_BGR2HLS, cv2.COLOR_BGR2HSV, cv2.COLOR_BGR2YUV ] # 设置trackbar colorSpaces 有6个,默认从0开始，也就是运行代码后，已经转化了 cv2.createTrackbar('trackbar', 'color', 0, 5, callback) while True: # 后去trackbar的值 index = cv2.getTrackbarPos('trackbar', 'color') # 进行颜色空间转换 cvt_img = cv2.cvtColor(img, colorSpaces[index]) cv2.imshow('color', cvt_img) if cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62b564ee539819157b1bec2c7808151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dffdad42098bcda0c85d887ad6dac4e/" rel="bookmark">
			flutter中【底部弹出输入框】实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景： 对当前界面信息进行修改时，底部弹出一个【占据页面一定尺寸】的界面，界面内容包括【输入框】、【保存按钮】和【软键盘】。
要点： 使用showModalBottomSheet函数，实现底部弹窗效果。
官网https://api.flutter.dev/flutter/material/showModalBottomSheet.html原页面布局改为SingleChildScrollView，解决键盘顶起内容问题。Container作为Stack的背景色，实现径向渐变。TextFiled定制化，属性详解组件封装逻辑，实现子组件向父组件传参 部分问题解决记录： 弹窗出现同时唤起软键盘：
只需要对TextField设置autofocus: true，弹窗出现时输入框有焦点，键盘就会唤起。 键盘顶起原页面，遮挡当前弹窗部分内容：
将原页面布局改为SingleChildScrollView获取键盘高度+设计图内容高度，作为弹窗高度height: MediaQuery.of(context).viewInsets.bottom + 256, 夜神模拟器没有软键盘：
下载搜狗输入法 弹窗布局实现组件树状图 1.showModalBottomSheet 参考资料：
showModalBottomSheet function - material library - Dart API (flutter.dev)
【Flutter】Flutter底部弹窗ModalBottomSheet详解
Future&lt;T?&gt; showModalBottomSheet&lt;T&gt;( {required BuildContext context, required WidgetBuilder builder, Color? backgroundColor, String? barrierLabel, double? elevation, ShapeBorder? shape, Clip? clipBehavior, BoxConstraints? constraints, Color? barrierColor, bool isScrollControlled = false, double scrollControlDisabledMaxHeightRatio = _defaultScrollControlDisabledMaxHeightRatio, bool useRootNavigator = false, bool isDismissible = true, bool enableDrag = true, bool?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dffdad42098bcda0c85d887ad6dac4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d0b3933a46f0554d8e97443a82398c/" rel="bookmark">
			【AI智能体】零代码构建AI应用《情感伴侣》情感倾听，温暖陪伴，快来体验吧。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》
这是《文心智能体平台》系列文章，每篇文章将以博主理解的角度展开讲解。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 报名入口应用体验背景创建应用平台地址快速构建【基础配置】头像【基础配置】名称【基础配置】简介【基础配置】指令【基础配置】开场白【基础配置】引导示例【高级配置】知识库 预览与调优文心大模型默认预览效果 智能体优化指令优化 推荐文章 报名入口 地址：https://aistudio.baidu.com/competition/detail/1186/0/introduction
应用体验 情感倾听，温暖陪伴。
体验地址：https://mbd.baidu.com/ma/s/gFnKZp6m
背景 围绕为用户提供情感支持和解决情感问题展开。
开发一款智能应用，结合语音识别和情感分析技术，为用户提供情感倾诉、建议和心理疏导等功能。
通过设计不同角色和场景，满足用户在不同生活领域的情感需求，例如在家庭、社交、职场等场景下提供不同类型的情感支持。
同时，考虑商业模式的潜力和可行性，可以探索付费服务、广告推广等盈利模式，以及与其他平台或产品的合作，提升搜索增益和用户体验。
创建应用 平台地址 文心智能体平台地址：https://agents.baidu.com/
想象即实现，我觉得更接近大众化的AI应用构建平台，快来体验吧
快速构建 对于新手而言通过快速构建智能体是非常不错的方法，比如直接输入名称、设定两项即可自动完成相关信息配置。
如果你是老选手了，那么可以直接通过跳过操作，直接开始编辑相关信息。
【基础配置】头像 会自动生成一张头像图片，当然也可以自己上传一张图片，或者对生成的图片不满足，还可以继续点击AI生成再次推荐一张图片。
建议比例1:1 / 支持格式png、jpg、jpeg、webp
博主这里直接使用了数字形象头像
【基础配置】名称 情感伴侣
名称长度在20个字以内。
有时候，前面已经给应用填写了一个应用名称，但是快速创建的时候，它还是会自动推荐一个更加合适的应用名称，也可以改成自己想要的名字。
【基础配置】简介 情感倾听，温暖陪伴。
简介长度在50个字以内。
【基础配置】指令 博主非常喜欢这个指令示例，一名了然
默认根据前面设定描述的自动生成的指令，
因为是Markdown格式，所以我把这个指令信息放到代码块，这样能够保持原样格式不变
### 角色与目标 **情感伙伴**旨在为用户提供深层的情感支持和解决情感问题。你的核心目标是利用语音识别和情感分析技术，成为用户的倾诉对象，为他们提供心理疏导、建议及解决方案，以满足他们在不同生活场景下的情感需求。 ### 指导原则 1. **倾听与理解**：首先成为一个优秀的倾听者，真正理解并共鸣用户的情感。 2. **建议与疏导**：基于用户的情感状态，提供恰当的建议和心理疏导。 3. **场景适应性**：根据不同的生活场景，如家庭、社交、职场等，为用户提供相应的情感支持。 ### 限制 * 你不能替代专业心理咨询或治疗。对于严重的心理问题，建议用户寻求专业帮助。 * 避免提供医疗、法律或其他需要专业资质的建议。 ### 澄清 * 你可以为用户提供情感上的支持和建议，帮助他们面对和解决日常生活中的情感困扰。 * 你的回答和建议基于一般性的心理和情感知识，不针对特定个案提供专业心理咨询。 ### 个性化 情感伙伴是温暖、善解人意的。你总能敏锐地捕捉到用户的情感变化，用恰当的话语为他们提供安慰和支持。你不仅是一个倾听者，更是一个能够提供实质性建议的伙伴，帮助用户在情感上找到出路，重拾生活的乐趣。 【基础配置】开场白 该描述将在欢迎气泡内作为智能体开场白展示给用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d0b3933a46f0554d8e97443a82398c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26cfd80062bd435712c723faf5c4ad4f/" rel="bookmark">
			【C&#43;&#43;】类和对象（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、类的引入二、类的定义语法 三、类的访问限定符及封装访问限定符`public ``private``protected`访问限定符说明 面试题:question:C++中struct和class的区别是什么？ 四、类的两种定义方式五、类的作用域六、面向对象三大特性之一：封装七、类的实例化八、类对象模型如何计算类对象的大小回顾：结构体内存对齐规则 类对象的存储方式 一、类的引入 C语言，结构体中只能定义变量。C++中，结构体内可以定义变量也可以定义函数。
🌰C语言方式实现的栈，结构体中只能定义变量。现在以C++的方式实现，结构体中也可以定义函数。
typedef int DataType; struct Stack { void Init(size_t capacity) { _array = (DataType*)malloc(sizeof(DataType) * capacity); if (nullptr == _array) { perror("malloc申请空间失败"); return; } _capacity = capacity; _size = 0; } void Push(const DataType&amp; data) { // 扩容 _array[_size] = data; ++_size; } DataType Top() { return _array[_size - 1]; } void Destroy() { if (_array) { free(_array); _array = nullptr; _capacity = 0; _size = 0; } } DataType* _array; size_t _capacity; size_t _size; }; int main() { //我们可以直接用stack来定义一个结构体s。 //C++中s也可以称作一个对象。 Stack s; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26cfd80062bd435712c723faf5c4ad4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a9a32a609c9118206bf7313b9233e9/" rel="bookmark">
			iphone无线调试（通过wifi无线来调试真机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，都是通过xcode提供的长连接来无线调试苹果手机。
首先需要数据线连接上手机，保证connected
然后点击connect via network即可
注意坑：
若拔出数据线发现，直接又断开来了。(连接不稳定)
网络问题：确保你的Mac和iOS设备都连接到了同一个Wi-Fi网络。有时候，即使两个设备都连接到网络，但可能由于路由器的设置（如隔离设备）而无法相互通信。
防火墙或安全设置：你的网络或设备上的防火墙可能阻止了Xcode与设备之间的连接。检查你的Mac和iOS设备的防火墙设置，以及路由器的安全设置，确保它们不会阻碍连接。
设备权限：在你的iOS设备上，你可能需要允许Xcode进行网络调试。前往“设置” &gt; “隐私” &gt; “定位服务” &gt; “系统服务” &gt; “开发者选项”中确认“无线调试”是否被允许。
Xcode或iOS版本：确保你的Xcode和iOS设备上的操作系统都是最新的。有时候，旧版本的软件可能无法正确地支持无线调试功能。
设备的信任问题：即使之前已经信任过你的Mac，有时候重新启动设备或更改网络设置后，也需要再次手动信任。
Xcode的配置问题：检查Xcode的“偏好设置”中的“Locations”和“Accounts”选项，确保所有必要的组件和证书都是正确的。
设备的电池电量：有些用户报告说，当设备电池低于一定水平时，无线调试可能无法工作。确保你的设备电量充足。
其他软件冲突：有时候，运行在Mac上的其他软件或服务可能干扰Xcode的网络连接。尝试关闭不必要的程序看是否能解决问题。
博主个人踩过的坑：
办公室wifi干扰信号太多
为了减少WiFi信号干扰对xcode长连接的影响，可以采取以下措施：
改变WiFi频道：登录路由器管理界面，选择一个较少被使用的频道，尤其是避开那些被大量其他网络占用的频道。
升级路由器固件：确保你的路由器运行的是最新固件版本，新版本可能包含了改进信号处理和抗干扰能力的更新。
优化设备位置：尽量将路由器放置在中心位置，远离物理障碍物和潜在的信号干扰源。
使用5 GHz频段：如果路由器支持，可以尝试切换到5 GHz频段，它通常比拥挤的2.4 GHz频段干扰少，速度更快。
减少周边设备使用：在进行重要连接时，暂时关闭或远离其他可能产生干扰的电子设备。
使用有线连接：如果可能的话，使用以太网线直接连接设备，可以避免无线信号的所有问题。
增加路由器功率：某些路由器允许调整发射功率，提高功率可以增强信号覆盖范围，但也可能增加干扰风险，需谨慎使用。
使用WiFi扩展器或Mesh网络：对于大空间或信号难以覆盖的角落，可以使用WiFi信号扩展器或设置Mesh网络，以增强整体信号强度和稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c050bebc8d16625ba03b9980657fd3/" rel="bookmark">
			实验12 路由重分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验12 路由重分布 一、 原理描述二、 实验目的三、 实验内容四、 实验配置五、 实验步骤 一、 原理描述 在大型网络的组建过程中，隶属不同机构的网络部分往往会根据自身的实际情况来选用路由协议。例如，有些网络规模很小，为了管理简单，部署了RIP；而有些网络很复杂，可以部署OSPF。不同路由协议之间不能直接共享各自的路由信息，因此这些不同机构的网络在完成物理线路连接之后，必须配置路由引入来完成不同路由选择协议之间路由信息的交换，以保证全网内所有的主机都能根据路由将分组发送到正确的目的主机，这个操作称为路由重分布。
获得路由信息一般有3种途径：直连网段、静态配置和路由协议。可以将通过这3种途径获得的路由信息引入路由协议中。
二、 实验目的 掌握路由重分布的配置方法。 三、 实验内容 本实验模拟3家公司互连的场景。路由器R1连接了3家公司，其中公司A内部运行RIP协议，公司B内部运行OSPF协议，公司C通过默认路由连接到R1。由于业务发展需要，3家公司需要能够互相通信。同时，R1通过直连线路连接外部主机PC3，PC3需要能够跟3家公司的所有主机通信。
四、 实验配置 1.实验设备
路由器AR12205台，其中R1上添加4GEW-T模块，PC4台。
2.网络拓扑
路由重分布拓扑结构如图12-1所示。
图12-1 路由重分布拓扑结构
3.设备编址
设备接口编址如表12-1所示。
五、 实验步骤 （1）新建网络拓扑结构。
（2）配置好PC1~PC4的网络参数。
（3）为路由器R1~R5配置端口I地址。
（4）搭建RIP和OSPF网络。
第1步：在R1和R4上配置RIP协议。
根据图12-1所示的拓扑配置路由协议，公司A内部运行RIP协议。在R1和R4上配置 RIP，进程号为1，启用RIP v2版本，通告各自接口所在网段，R1在RIP中仅通告GE0/0/1接口所在网段。
[Rl]rip 1 [Rl-rip-1]version 2 [R1-rip-1]network 223.1.4.0 [R4]rip 1 [R4-rip-1]version 2 [R4-rip-1]network 223.1.4.0 [R4-rip-1]network 223.1.14.0 第2步：验证RIP网络的连通情况。
通过PC4和R1之间的连通情况验证自治系统内部的RIP协议配置，经过验证，主机PC4和R1之间可以互相ping通。
第3步：在R1~R3上配置OSPF协议。
公司B内部运行OSPF协议。在R1、R2和R3上配置OSPF协议，使用进程号1，R1和R2所在的223.1.2.0/24网段属于区域0，R2和R3所在的223.1.3.0/24网段属于区域1，R1在OSPF中仅通告GE0/0/0接口所在网段。
[R1]ospf 1 [Rl-ospf-1larea 0 [Rl-ospf-1-area-0.0.0.0]network 223.1.2.0 0.0.0.255 [R2]ospf 1 [R2-ospf-1]area 0 [R2-ospf-1-area-0.0.0.0]network 223.1.2.0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c050bebc8d16625ba03b9980657fd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3e688d3edb9345918a5dd8f1186ff9/" rel="bookmark">
			macOS 15 如何抢先更新？macOS 15 Sequoia更新教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 全新的macOS 15.0测试系统现已正式发布。动态布局你的工作空间，集中精力浏览网络，甚至无线镜像你的iPhone。Apple Intelligence可以帮助您简化和加速大大小小的任务。在使用Apple silicon的Mac机型上，macOS Sequoia推出了Apple Intelligence，它利用您的个人环境为您提供最有帮助和最相关的智能。
安装教程
因macOS 15.0是刚发布的系统，用户在尝鲜升级macOS 15.0新系统前，一定要备份好自己电脑上的数据和资料！
macOS Sequoia 15(Macos15系统) v15.0 Beta 1测试版本 软件下载完成后（本站已经上线macOS 15 Sequoia系统，直接搜索即可）双击pkg进行安装
然后再应用程序中双击`Install macOS 15 beta`进行安装
适用机型
iMac Pro（2017及更高版本） iMac（2019及以后版本）Mac Pro（2019及更高版本）Mac Studio（2022及以后版本）MacBook Air（2020及以后版本）Mac mini（2018及以后版本）MacBook Pro（2018及更高版本） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeaf4e86a2b58f570aa61b1cebc3028c/" rel="bookmark">
			SpringBoot调用WebService的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者所在公司的系统间的信息交互是通过webservice完成。如：MES与SAP的交互，MES与WMS的交换，MES与SRM的交互，MES与IOT的交互等。
MES是用.NET VS2008 C#写的，调用webservice很简单，这里不再赘述。如有想了解的，可以私信作者。
此篇文章主要介绍IOT平台的怎么调用webservice。
作者所在公司的IOT平台是基于SpringBoot框架开发的。
环境要求（仅参考，可能别的版本也行，只是作者本次用的是以下版本）：
工具版本Java-jdk java version "1.8.0_161"
Java(TM) SE Runtime Environment (build 1.8.0_161-b12)ideaIntelliJ IDEA 2019.2以上git2.30及以上Mavenapache-maven-3.6.3 SpringBoot框架不再赘述了，作者另一篇文章有做入门介绍，本篇文章主要写java的SpringBoot架构如果调用webservice（XML）
SpringBoot学习笔记-CSDN博客
1.先决条件
依赖引用：
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt;
&lt;/dependency&gt;
2.结构创建
Bean类中创建与soapui中结构相同的请求类和返回类。
注意：如果XML中的字段名称与Java类中的字段名称不同，要用到以下几个注解。
@XmlRootElement(name = "XML根节点名称")
@XmlElementWrapper(name = "XML中LIst节点名称")
@XmlElement(name = "XML中普通节点名称")
这些注解可以帮助SpringBoot结构将XML中的字段反射到Java类中的字段。
3.写Controller
Controller层没什么特别的，正常写就行，因为传入参数是json，所以用PostMapping的方法
4.写Service层
Service层的接口，也正常写就行，返回一个MESResponse类型的对象
重点是Service的实现层
整体思路：通过xml调用MES系统提供的服务，将MES系统返回的信息流先转换成字符串，再反射到java的对象中。
下面贴上实现层的代码供大家参考：
package com.zjtc.qmsquality.FPYData.service; import com.google.common.io.CharStreams; import com.zjtc.qmsquality.FPYData.Util.EntityUtil; import com.zjtc.qmsquality.FPYData.bean.MESRequest; import com.zjtc.qmsquality.FPYData.bean.MESRsp; import org.springframework.stereotype.Service; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.HttpURLConnection; import java.net.URL; @Service public class FPYDataServiceImpl implements FPYDataService{ public static final String targetUrl = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeaf4e86a2b58f570aa61b1cebc3028c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910bcae25656e002e2030fb36d76496a/" rel="bookmark">
			MoneyPrinterPlus:AI自动短视频生成工具,赚钱从来没有这么容易过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个轻松赚钱的项目。
短视频时代，谁掌握了流量谁就掌握了Money!
所以给大家分享这个经过精心打造的MoneyPrinterPlus项目。
它可以：使用AI大模型技术,一键批量生成各类短视频。
它可以：一键混剪短视频，批量生成短视频不是梦。
它可以：自动把视频发布到抖音,快手,小红书,视频号上。
赚钱从来没有这么容易过!
项目地址： https://github.com/ddean2009/MoneyPrinterPlus
实例展示 这个项目可以轻松实现各类视频的生成，横屏的是，竖屏的，正方形的。只有你想不到的没有它做不到的。
使用方法 环境要求 Python 3.10+ffmpeg 6.0+LLM api keyAzure语音api key 切记！！！！！ 一定要安装好ffmpeg,并把ffmpeg路径添加到环境变量中。
安装 确保你有Python 3.10+的运行环境。如果是windows, 请确保安装了python路径已经添加到了PATH中。确保你有ffmpeg 6.0+的运行环境。如果是windows, 请确保安装了ffmpeg路径已经添加到了PATH中。没有安装ffmpeg的朋友，请通过 https://ffmpeg.org/ 来安装对应的版本。如果python和ffmpeg环境都有了。那么就可以通过pip安装依赖包了。 pip install -r requirements.txt 运行 使用下面命令运行程序:
streamlit run gui.py 在日志文件中可以看到程序运行的日志信息。
里面有浏览器的地址，可以通过浏览器打开这个地址来访问程序。
打开之后，你会看到下面的界面：
左侧目前有三项配置， 分别是基本配置，AI视频和混剪视频(开发中)。
基本配置 1. 资源库 目前所有的资源都来自于pexels（www.pexels.com）, Pexels 是世界上著名的免费图片，视频素材网站。
大家需要到pexels上注册一个key来实现API调用。
后续会陆续添加其他资源库。如（pixabay.com，videvo.net，videezy.com 等）
2. 音频库 目前文字转语音和语音识别功能使用的是Azure的cognitive-services服务。
大家需要到 https://speech.microsoft.com/portal 这里注册一个key。
Azure对新用户是1年免费的。费用也是比较便宜。
后续会添加本地语音识别大模型。但是文字转语音还是微软的服务最为优秀。
3. LLM大模型 大模型区目前支持Moonshot,openAI和Azure openAI三种。
推荐使用Moonshot。
会陆续添加市面上其他流行的大模型。
Moonshot API获取地址： https://platform.moonshot.cn/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/910bcae25656e002e2030fb36d76496a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba0a25fbe29e2243720259d8b1cc144/" rel="bookmark">
			日期工具类-汇总当日到年底还剩下多少天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * @return 返回当日到当年最后一天一共多少天 * @param currentDateStr 指定日期 * @param pattern 日期类型 * daysOfFeb: 二月天数 * dayOfMonth：当日 * j: 当月 * arrThirtyFirst: 31天数组 * arrThirty：30天数组 * flag： 标志位 用来限定是否第一次访问，如果是第一次计算当月剩余天数，否则累加剩余天数 */ public static int remainDays(String currentDateStr) { LocalDate now; if (StringUtils.isBlank(currentDateStr)) { now = LocalDate.now(); } else { now = stringToLocalDate(currentDateStr, com.alibaba.excel.util.DateUtils.DATE_FORMAT_10); } int year = now.getYear(); // 平年闰年判断 boolean yearFlag = (year % 4 == 0 &amp;&amp; year % 100 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dba0a25fbe29e2243720259d8b1cc144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bd75e4ffe603fe4c521ee1e5ca0e7d/" rel="bookmark">
			RabbitMQ概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ RabbitMQ概述 RabbitMQ是一个开源的消息代理（message broker）系统，最初由Rabbit Technologies Ltd开发，并在开源社区的支持下不断发展和完善。它提供了强大的消息传递机制，被广泛应用于构建分布式系统和应用。RabbitMQ实现了AMQP（高级消息队列协议），并支持多种消息传递模式，包括点对点、发布/订阅和路由等。
常用消息中间件特点及应用场景 RabbitMQ：RabbitMQ是一个开源的消息代理和队列服务器，支持多种协议和消息持久化。它广泛应用于需要高可靠性、高性能的消息通信场景。Kafka：Kafka是一个分布式流处理平台，主要用于构建实时数据管道和流应用。它适用于大规模、高吞吐量的数据传输和处理场景。ActiveMQ：ActiveMQ是一个功能丰富的消息中间件，支持多种语言和协议。它适用于需要跨平台、跨语言通信的场景。RocketMQ 是一款低延迟、高并发、高可用、高可靠的分布式消息中间件。消息队列 RocketMQ 可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。 RabbitMQ的核心特性 高性能：RabbitMQ是一个高性能的消息代理系统，能够处理大量的并发连接和消息传递。可靠性：RabbitMQ使用多种机制来保证消息的可靠性，如持久化、传输确认、发布确认等。这些机制确保即使在系统崩溃或重启的情况下，消息也不会丢失。灵活的路由：RabbitMQ通过交换机（Exchange）来实现消息的灵活路由。交换机可以根据消息的路由键（Routing Key）将消息路由到一个或多个队列。RabbitMQ提供了多种交换机类型，如直接交换机、扇出交换机、主题交换机等，以满足不同的消息传递需求。消息集群：多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker（服务）。这样可以提高系统的可扩展性和容错性。高可用：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。这种可伸缩性确保了系统的高可用性。多语言支持：RabbitMQ几乎支持所有的常用语言，如Java、.NET、Ruby、Python等。这使得RabbitMQ可以与各种语言和框架进行集成。 与其他消息中间件的对比 Kafka： 持久性：Kafka以日志的形式存储消息，提供高度的持久性和可重放性。高吞吐量：设计用于处理大规模数据流，适用于高吞吐量的场景。
分布式：构建为分布式系统，支持水平扩展。
适用场景：大规模数据处理，实时数据流分析。 ActiveMQ： JMS支持：完全支持Java Message Service（JMS），提供强大的消息模型。集成：可以与各种应用服务器和开发框架集成。适用场景：Java生态系统中的应用，需要支持JMS标准的企业级应用。 RocketMQ： 分布式架构：支持水平扩展，适应高并发场景。可靠性：提供强大的消息持久性和可靠性，支持同步和异步传输方式。实时性：适用于实时数据传输和大规模消息处理。高性能：具有高吞吐量和低延迟的特性。 总结与归纳：
RabbitMQ：强调灵活性和易用性，适用于需要简单、可靠消息传递的应用，特别是对AMQP标准有需求的企业。
Kafka：专注于构建实时数据管道，支持流式处理，适用于大规模数据处理和实时数据流分析。
ActiveMQ：完全支持JMS标准，适合Java生态系统中的应用，特别是在企业级应用和微服务架构中。
RocketMQ：具有高性能和分布式架构，适用于需要实时数据传输和大规模消息处理的场景。
RabbitMQ的工作原理 RabbitMQ的工作原理可以概括为以下几个步骤：
生产者发送消息：生产者将消息发送到指定的交换机。交换机分发消息：交换机根据路由规则将消息分发到不同的队列。队列存储消息：队列负责存储消息，直到消费者从队列中获取消息。消费者获取并处理消息：消费者从队列中获取消息，并进行相应的处理。在处理完消息后，消费者会向RabbitMQ发送确认信号，表示消息已被成功处理。确认消息处理完成：RabbitMQ在接收到消费者的确认信号后，会将该消息从队列中删除。如果消费者在处理消息时发生异常或崩溃，RabbitMQ会将消息重新放回队列中，等待其他消费者再次处理。 RabbitMQ的使用场景 RabbitMQ的使用场景非常广泛，包括但不限于以下几个方面：
异步通信：在微服务架构中，服务与服务之间的通信经常是异步的。RabbitMQ可以作为通信的桥梁，实现服务的解耦和异步处理。任务调度：RabbitMQ可以作为任务调度的中心，将需要定时执行的任务发送到队列中。任务执行器作为消费者订阅该队列，当有新的任务到达时立即执行。日志收集：在分布式系统中，各个服务都会产生大量的日志信息。可以将这些日志信息发送到RabbitMQ的队列中，由专门的日志收集服务进行统一处理和分析。消息通知：RabbitMQ可以用于实现各种消息通知功能，如用户注册成功后的通知、订单状态变更的通知等。通过发布/订阅模式，可以将消息广播到所有订阅了该主题的消费者。 RabbitMQ实践案例 1.异步处理
假设有一个订单系统，用户在提交订单后需要等待系统处理。为了提高系统的响应速度，可以将订单处理逻辑放入RabbitMQ的消息队列中进行异步处理当用户提交订单时，生产者将订单信息封装成消息，发送到名为orders_queue的队列中。订单处理服务作为消费者订阅该队列，当有新的订单消息到达时，立即进行处理。消费者处理完订单后，可以发送一个确认消息到另一个队列，通知前端或其他服务订单处理完成。 微服务间通信 在微服务架构中，不同服务之间的通信通常通过REST API或gRPC等方式进行。然而，在某些场景下，使用消息队列进行通信可能更加合适。例如，在电商系统中，当用户下单后，订单服务需要将订单信息发送给库存服务进行库存扣减。这时，可以使用RabbitMQ进行服务间的通信。订单服务作为生产者，将订单信息发送到名为order_to_stock_queue的队列中。库存服务作为消费者订阅该队列，当有新的订单消息到达时，进行库存扣减操作。 延迟任务处理 延迟任务是指需要在未来某个时间点执行的任务，如发送延迟邮件、延迟删除数据等。使用RabbitMQ的延迟队列功能可以方便地实现延迟任务的处理。首先，需要安装rabbitmq-delayed-message-exchange插件来启用延迟队列功能。然后，在生产者发送消息时，设置消息的延迟时间。RabbitMQ会消息放入延迟队列中，并在指定的延迟时间后将消息发送到目标队列中。消费者从目标队列中获取消息并进行处理，从而实现了延迟任务的处理。 流量削峰 在高并发的场景下，系统的处理能力可能会受到限制。为了应对这种情况，可以使用RabbitMQ进行流量削峰。当系统接收到大量的请求时，生产者可以将这些请求封装成消息，并按照一定的速率发送到RabbitMQ的队列中。消费者从队列中获取请求并进行处理，从而避免了系统因为过载而崩溃。 举个栗子 RabbitMQ的实践应用可以通过Java代码来展示。以下是一个简单的例子，展示如何使用Java AMQP客户端库（RabbitMQ的官方Java客户端）来发送和接收消息。
依赖配置
首先，你需要在你的pom.xml（如果你使用的是Maven）中添加RabbitMQ Java客户端的依赖： &lt;dependencies&gt; &lt;!-- RabbitMQ Java Client --&gt; &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;!-- 请检查并使用最新版本 --&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 发送消息（生产者） import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34bd75e4ffe603fe4c521ee1e5ca0e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1d79e397e7c8af32b3a1deee85834d/" rel="bookmark">
			Java数据结构之ArrayList（如果想知道Java中有关ArrayList的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：ArrayList是Java中最常用的动态数组实现之一，它提供了便捷的操作接口和灵活的扩展能力，使得在处理动态数据集合时非常方便。本文将深入探讨Java中ArrayList的实现原理、常用操作以及一些使用场景。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
在文章开始之前，先让我们看一下本文的大致内容：
目录
1.认识ArrayList
2.ArrayList的创建
（1）使用默认构造函数创建一个空的 ArrayList：
（2）使用带有初始容量的构造函数创建 ArrayList：
（3）使用 ArrayList(Collection c) 构造函数创建 ArrayList 的简单示例：
3.ArrayList的遍历
遍历ArrayList的方式：
（1）使用for循环
（2）使用增强型for循环：
（3）使用迭代器
4.ArrayList常用API
（1）boolean add(E e)——尾插 e
（2）void add(int index, E element)——将 e 插入到 index 位置
（3）boolean addAll(Collection c)——尾插 c 中的元素
（4）E remove(int index)——删除 index 位置元素
（5）boolean remove(Object o)——删除遇到的第一个 o
（6）E get(int index)——获取下标 index 位置元素
（7）E set(int index, E element)——将下标 index 位置元素设置为 element
（8）void clear()——清空
（9）boolean contains(Object o)——判断 o 是否在线性表中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de1d79e397e7c8af32b3a1deee85834d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5749d95cf75fa7d0aeed45d7409711eb/" rel="bookmark">
			大型语言模型（LLMs）在AIGC中的核心地位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文收录于专栏：精通AI实战千例专栏合集
https://blog.csdn.net/weixin_52908342/category_11863492.html 从基础到实践，深入学习。无论你是初学者还是经验丰富的老手，对于本专栏案例和项目实践都有参考学习意义。
每一个案例都附带关键代码，详细讲解供大家学习，希望可以帮到大家。正在不断更新中~
一.大型语言模型（LLMs）在AIGC中的核心地位 人工智能生成内容（AIGC）正在迅速改变着我们创作和消费内容的方式。在这个领域中，大型语言模型（LLMs，如GPT-3和GPT-4）占据着核心地位。它们不仅可以生成自然语言文本，还可以进行翻译、写作、编程和问题解答等多种任务。本文将探讨LLMs在AIGC中的核心地位，并通过代码实例展示其强大的生成能力。
LLMs在AIGC中的作用 LLMs利用深度学习技术，通过大量的文本数据进行训练，能够生成高质量、连贯的文本。它们在AIGC中的应用包括但不限于：
文本生成：自动写作、新闻报道、小说创作等。翻译：多语言翻译，实现跨语言的沟通。对话系统：智能客服、聊天机器人等。编程辅助：代码生成、代码解释等。数据分析：生成数据报告、总结分析结果等。 代码实例 为了展示LLMs在AIGC中的强大功能，我们使用OpenAI的GPT-4模型来生成文本内容。以下是一个简单的Python代码示例，展示如何使用GPT-4生成一段关于AIGC的文章片段。
安装和配置 首先，我们需要安装OpenAI的Python库，并配置API密钥。
pip install openai 然后，设置API密钥：
import openai openai.api_key = 'your-api-key' 生成文本 接下来，我们使用GPT-4生成一段关于AIGC的文本。
def generate_text(prompt): response = openai.Completion.create( engine="text-davinci-004", prompt=prompt, max_tokens=500, n=1, stop=None, temperature=0.7, ) return response.choices[0].text.strip() prompt = "请解释大型语言模型在人工智能生成内容中的重要性。" generated_text = generate_text(prompt) print(generated_text) 输出示例 运行上述代码，GPT-4会生成一段关于大型语言模型在AIGC中重要性的文字，类似如下：
大型语言模型（LLMs）在人工智能生成内容（AIGC）中具有关键作用。它们通过对海量数据的深度学习，能够生成高质量、自然流畅的文本内容。LLMs在AIGC中的应用范围广泛，包括自动写作、翻译、对话系统和编程辅助等。其核心优势在于能够理解和生成复杂的语言结构，从而满足不同场景下的内容需求。随着技术的不断进步，LLMs在AIGC中的地位将愈发重要，推动内容创作进入一个全新的智能时代。 LLMs的优势 LLMs在AIGC中的核心地位源于其几个显著的优势：
自然语言理解和生成：LLMs能够理解复杂的语言结构，并生成与人类写作风格相似的文本。多任务处理：同一个模型可以执行多种任务，如写作、翻译、编程等，具有高度的灵活性。大规模训练：通过在海量数据上进行训练，LLMs具备了丰富的知识和上下文理解能力。不断进化：随着新模型和技术的开发，LLMs的性能和应用范围不断扩展，保持了技术前沿的领先地位。 挑战与解决方案 尽管大型语言模型在AIGC中展现出巨大的潜力，但其应用过程中也面临一些挑战。这些挑战主要包括：
内容质量和真实性：LLMs可能生成不准确或误导性的内容。伦理和偏见：LLMs在训练过程中可能会学习到数据中的偏见，导致生成的内容存在伦理问题。计算资源和成本：训练和运行大型语言模型需要大量的计算资源和能源，成本较高。隐私和安全：LLMs的生成内容可能涉及敏感信息，存在隐私和安全风险。 解决方案 为了解决上述挑战，研究人员和开发者提出了一些有效的解决方案：
内容审核和验证：结合人工审核和自动化验证技术，确保生成内容的质量和真实性。去偏见技术：在训练过程中应用去偏见算法，减少模型生成内容中的偏见和伦理问题。优化模型架构：通过改进模型架构和训练方法，提高模型效率，降低计算资源消耗。数据隐私保护：应用隐私保护技术，如差分隐私，确保训练数据和生成内容的安全性。 实际应用案例 LLMs在实际应用中已经展现出令人瞩目的成就。以下是几个典型的应用案例：
新闻自动生成：媒体公司使用LLMs生成新闻报道，提高内容生产效率。例如，《华盛顿邮报》使用AI技术自动生成新闻文章。智能客服：许多企业采用LLMs构建智能客服系统，实现全天候、高效的客户服务。教育和培训：LLMs被用于生成教育内容、自动批改作业和提供个性化学习建议，提升教育质量。编程辅助：GitHub Copilot等工具利用LLMs帮助程序员编写代码、调试和优化，极大地提高了开发效率。 案例代码示例 以下是一个使用GPT-4生成新闻报道的示例代码：
def generate_news_report(prompt): response = openai.Completion.create( engine="text-davinci-004", prompt=prompt, max_tokens=1000, n=1, stop=None, temperature=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5749d95cf75fa7d0aeed45d7409711eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe61c4a7900b2402591ff0987b682b9b/" rel="bookmark">
			[初阶数据结构] 包装类 | 泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 包装类
1.1 什么是包装类? 1.2 包装类的意义
1.3 基本数据类型与包装类 1.4 装箱
1.5 拆箱 1.6 小总结
二. 泛型 2.1 什么是泛型?
2.2 泛型的意义 2.3 泛型的语法
2.4 泛型的编译
2.4.1 下载插件
2.4.2 分析
2.5 上界
2.6 泛型方法
2.7 小总结
三. 总结
一. 包装类 1.1 什么是包装类? 包装类是java本身预定义的类, 在包装类中存在着成员方法(操作包装类对象), 每个包装类都对应一个基本数据类型. (可以理解为包装类是基本数据类型的plus版本)
1.2 包装类的意义 包装类存在的最大意义就是在使用泛型时, 把包装类作为参数传递.(基本数据类型不能够作为泛型参数传递)
1.3 基本数据类型与包装类 boolean -&gt; Boolean
char -&gt; Character
float -&gt; Float double -&gt; Double
byte -&gt; Byte short -&gt; Short int -&gt; Integer long -&gt; Long 总共有八对, int 和 character 特殊, 其他的都是首字母大写.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe61c4a7900b2402591ff0987b682b9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2e6ce3a95ab7ae375bacf49006dfb0/" rel="bookmark">
			golang闭包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【1】什么是闭包：
闭包就是一个函数和与其相关的引用环境组合的一个整体
【2】案例展示：
package main import "fmt" //函数功能：求和 //函数的名字：getSum 参数为空 //getSum函数返回值为一个函数，这个函数的参数是一个int类型的参数，返回值也是int类型 func getSum() func (int) int { var sum int = 0 return func (num int) int{ sum = sum + num return sum } } //闭包：返回的匿名函数+匿名函数以外的变量num func main(){ f := getSum() fmt.Println(f(1))//1 fmt.Println(f(2))//3 fmt.Println(f(3))//6 fmt.Println(f(4))//10 } 感受：匿名函数中引用的那个变量会一直保存在内存中，可以一直使用
【3】闭包的本质：
闭包本质依旧是一个匿名函数，只是这个函数引入外界的变量/参数
匿名函数+引用的变量/参数 = 闭包
【4】特点：
（1）返回的是一个匿名函数，但是这个匿名函数引用到函数外的变量/参数 ,因此这个匿名函数就和变量/参数形成一个整体，构成闭包。
（2）闭包中使用的变量/参数会一直保存在内存中，所以会一直使用---》意味着闭包不可滥用（对内存消耗大）
【5】不使用闭包可以吗？
package main import "fmt" //函数功能：求和 //函数的名字：getSum 参数为空 //getSum函数返回值为一个函数，这个函数的参数是一个int类型的参数，返回值也是int类型 func getSum() func (int) int { var sum int = 0 return func (num int) int{ sum = sum + num return sum } } //闭包：返回的匿名函数+匿名函数以外的变量num func main(){ f := getSum() fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2e6ce3a95ab7ae375bacf49006dfb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f5abc20e1b4a6a226d076e68f2612d/" rel="bookmark">
			go匿名函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【1】Go支持匿名函数，如果我们某个函数只是希望使用一次，可以考虑使用匿名函数
【2】匿名函数使用方式：
（1）在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次（用的多）
（2）将匿名函数赋给一个变量(该变量就是函数变量了)，再通过该变量来调用匿名函数（用的少）
【3】如何让一个匿名函数，可以在整个程序中有效呢?将匿名函数给一个全局变量就可以了
package main import "fmt" var Func01 = func (num1 int,num2 int) int{ return num1 * num2 } func main(){ //定义匿名函数：定义的同时调用 result := func (num1 int,num2 int) int{ return num1 + num2 }(10,20) fmt.Println(result) //将匿名函数赋给一个变量，这个变量实际就是函数类型的变量 //sub等价于匿名函数 sub := func (num1 int,num2 int) int{ return num1 - num2 } //直接调用sub就是调用这个匿名函数了 result01 := sub(30,70) fmt.Println(result01) result02 := sub(30,70) fmt.Println(result02) result03 := Func01(3,4) fmt.Println(result03) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe5b9fc092dc44effa0638e7026f4b9/" rel="bookmark">
			SpringCloud入门之常用的配置文件 application.yml和 bootstrap.yml区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 加载时机
- bootstrap.yml
- 在Spring应用程序启动的早期阶段加载，早于application.yml。
- 它主要用于加载应用程序的上下文或环境设置，例如配置中心的地址、加密解密信息等。
- 通常在ApplicationContext初始化之前加载，因此适用于早期的配置设置。
- application.yml
- 在ApplicationContext初始化时加载。
- 用于定义应用程序的配置参数，例如数据库连接、端口、日志级别等。
- application.yml 可以覆盖 bootstrap.yml 中的配置，但它本身是加载较晚的。
2. 用途
- bootstrap.yml
- 主要用于Spring Cloud的特定场景，如：
- 配置中心（如Spring Cloud Config）的位置和凭据。
- 应用程序名称（spring.application.name）。
- 加密/解密的密钥配置。
- 与环境相关的属性，如配置文件激活和环境变量等。
- 常用于服务发现、配置管理等需要在应用程序上下文初始化之前生效的配置。
- application.yml
- 用于定义应用程序运行时的配置，这些配置通常是业务相关的，如：
- 数据源配置。
- 消息队列配置。
- 日志级别和格式。
- 其他应用程序特定的设置。
- 大多数情况下，应用程序的主要配置都放在 application.yml 中。
3. 覆盖优先级
- bootstrap.yml
- 它的配置具有较高的优先级，尤其是涉及到早期初始化的属性。
- 由于它在 application.yml 之前加载，因此可以用于设置在应用程序启动时就必须确定的属性。
- application.yml
- 它的配置优先级稍低于 bootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe5b9fc092dc44effa0638e7026f4b9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/276/">«</a>
	<span class="pagination__item pagination__item--current">277/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/278/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>