<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8e014ece0f9846ee5e17e63ac3c898/" rel="bookmark">
			人工智能在软件工程中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 人工智能(Artificial Intelligence, AI)是一门研究如何让计算机模拟人类智能行为的科学。在过去的几十年里，人工智能技术已经取得了显著的进展，包括自然语言处理、计算机视觉、机器学习等领域。随着数据量和计算能力的增长，人工智能技术在各个领域的应用也逐渐成为可能。
软件工程是一门研究如何有效地开发和维护软件的学科。随着软件系统的复杂性和规模的增加，软件工程师们需要更有效地利用人工智能技术来提高开发效率、提高软件质量和降低维护成本。
在这篇文章中，我们将讨论人工智能在软件工程中的应用，包括以下几个方面：
背景介绍核心概念与联系核心算法原理和具体操作步骤以及数学模型公式详细讲解具体代码实例和详细解释说明未来发展趋势与挑战附录常见问题与解答 2. 核心概念与联系 在软件工程中，人工智能可以应用于多个领域，包括但不限于：
代码自动化：使用机器学习算法自动生成代码，提高开发效率。代码审查：使用自然语言处理技术对代码进行审查，提高代码质量。软件测试：使用机器学习算法自动生成测试用例，提高软件测试效率。软件维护：使用自然语言处理技术对软件bug报告进行分类，提高维护效率。软件架构设计：使用机器学习算法自动生成软件架构设计，提高设计效率。 3. 核心算法原理和具体操作步骤以及数学模型公式详细讲解 在本节中，我们将详细讲解以下几个人工智能算法的原理和步骤：
支持向量机(Support Vector Machine, SVM)决策树(Decision Tree)随机森林(Random Forest)卷积神经网络(Convolutional Neural Network, CNN)递归神经网络(Recurrent Neural Network, RNN) 3.1 支持向量机(SVM) 支持向量机是一种用于解决小样本学习、高维空间和非线性分类问题的算法。支持向量机的核心思想是通过寻找支持向量(即与类别边界距离最近的数据点)来构建分类模型。
3.1.1 原理与步骤 输入数据集：包括输入特征向量和对应的类别标签。数据预处理：对输入数据进行标准化、归一化和缺失值填充等处理。选择核函数：常见的核函数包括径向基函数(Radial Basis Function, RBF)、多项式函数(Polynomial)和线性函数(Linear)等。训练支持向量机：根据选定的核函数和参数设置(如正则化参数、学习率等)，使用梯度下降或其他优化算法训练模型。模型评估：使用独立的测试数据集评估模型的性能，并计算准确率、召回率、F1分数等指标。 3.1.2 数学模型公式 支持向量机的数学模型可以表示为：
$$ f(x) = \text{sgn} \left( \sum{i=1}^{n} \alphai yi K(xi, x) + b \right) $$
其中，$f(x)$ 是输出函数，$x$ 是输入特征向量，$yi$ 是类别标签，$K(xi, x)$ 是核函数，$\alpha_i$ 是支持向量权重，$b$ 是偏置项。
3.2 决策树(Decision Tree) 决策树是一种用于解决分类和回归问题的算法，通过递归地构建条件判断树来将数据划分为多个子集。
3.2.1 原理与步骤 输入数据集：包括输入特征向量和对应的类别标签。数据预处理：对输入数据进行标准化、归一化和缺失值填充等处理。选择特征：根据信息增益、基尼指数等评估标准选择最佳特征。构建决策树：递归地为每个特征构建条件判断，直到满足停止条件(如最大深度、最小样本数等)。模型评估：使用独立的测试数据集评估模型的性能，并计算准确率、召回率、F1分数等指标。 3.2.2 数学模型公式 决策树的数学模型可以表示为一棵有向无环图(DAG)，每个结点表示一个条件判断，每个边表示一个特征值。给定一个输入特征向量，可以从根结点开始，递归地按照条件判断穿越结点，直到到达叶结点，得到对应的类别标签。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c8e014ece0f9846ee5e17e63ac3c898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e9498d81545bf87e32505673fe8633f/" rel="bookmark">
			使用宝塔面板部署node项目、数据库及react项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前置准备 a.数据库文件 .sql文件
没有的可以参考我的:
链接: https://pan.baidu.com/s/1l23nNmkSt4JtQ7aRqPgpZw 提取码: 6d64 复制这段内容后打开百度网盘手机App，操作更方便哦
b.完整的node项目
没有的可以参考我的：https://github.com/rui-rui-an/hkzf_node
c.react项目/vue项目
没有可以参考我的：https://github.com/rui-rui-an/cityRent
d.前置知识：知道怎么安装宝塔，不懂怎么在服务器上安装宝塔的可以看我这篇文章 e.已经有云服务器且安装了宝塔，不懂的可以看这篇文章
2.使用宝塔面板建数据库 a.打开宝塔面板的数据库 b.添加数据库 tips：注意这里的访问权限要打开，不然你本地去连线上数据库时连不上
这里建立的数据库要与你的node项目中的完全一致
c.可选步骤（sql文件过大时(大于50mb)需要设置，否则会导入不成功） 到软件商店里去设置php
把下面4个都选择成500
重启php
d.导入hkzf.sql文件 点击管理
这里的密码就是你刚才设置的
上传sql文件
如果你的数据库表里有数据，那么就是正确的
e.开放端口 这里特别要注意，需要开放两个地方的端口
1.需要开放宝塔面板的3306端口
2.需要把阿里云安全组的3306端口开放
f.修改node项目host地址，检验线上数据库是否部署成功 tips:这里的ip地址不要带有http!!!
运行node项目，能正常访问就说明我们线上的数据库部署成功了！
2.部署node项目 a.新建文件夹并将node项目（不需要打包）放到该文件夹下 将我们的node项目中的node_modules删除掉，然后再压缩，把这个压缩包上传上去，再解压，然后删除这个安装包即可
上传：
解压：
最后删除zip文件
b.开启宝塔面包中node项目的服务 到网站的node项目中去，安装node版本管理器
接着会提示你安装node,npm（node版本的选择看你的项目），同时它也会自动安装pm2
c.将我们的node项目文件放到node服务中 点击添加node项目，选择项目路径
tips：
项目目录：选择刚才a步骤的文件夹
项目名称和启动选项：会在你选了项目目录之后自动带入进去
项目端口号：很重要，这边我会解释的多一点！！！！！！！！！！这个要与你node项目中配置的端口号一致！！！后面去访问接口也是使用这个端口号！！
这个项目端口号可以随便填，但是一定要与node项目中配置的端口号一致，并且与vue项目中axios的base_url（项目基地址）的端口号一致，并且整个vue项目中的地址，你都是使用的base_url变量，而不是写死的常量。有一个不一致，都会导致网络请求错误。
（下图是我的node项目中的端口号，没写8080是因为我这个服务器的8080端口已经被另一个项目使用了，一定要注意不要和前端项目使用同一个端口，会导致端口占用！！！）
（vue项目的生产环境base_usl配置）
（封装的axios中的baseURL（项目基地址）使用的也是这个）
（平常的vue项目访问的图片和接口一定要用base_url，否则会出现请求错误的情况，我部署的时候就出现了，接口访问出错，找了很久，发现是vue项目里面写死了！！！）
（这里的图片也是，不能使用写死的）
d.开放接口端口 这里特别要注意，需要开放两个地方的端口
1.开放宝塔面板的9999端口
2.开放阿里云的安全组9999端口
e.测试项目接口 这里我使用的是在线的postman测试的
接口测试的没问题，那么说明我们的node项目已经在服务器上跑起来了
3.部署vue项目 a.修改线上环境的ip和端口 b.检查项目中有没有写死的地址，如果有，替换成变量process.env.REACT_APP_URL c.打包 d.到宝塔面板的网站中建立站点 tips:这里的域名随便填一个（后面还要删掉），主要是为了创建第三行的目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e9498d81545bf87e32505673fe8633f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e31c6b5f15208960365b819194d0af/" rel="bookmark">
			ONNX格式模型 学习笔记 (onnxRuntime部署)---用java调用yolov8模型来举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ONNX（Open Neural Network Exchange）是一个开源项目，旨在建立一个开放的标准，使深度学习模型可以在不同的软件平台和工具之间轻松移动和重用。
ONNX模型可以用于各种应用场景，例如机器翻译、图像识别、语音识别、自然语言处理等。
由于ONNX模型的互操作性，开发人员可以使用不同的框架来训练，模型可以更容易地在不同的框架之间转换，例如从PyTorch转换到TensorFlow，或从TensorFlow转换到MXNet等。然后将其部署到不同的环境中，例如云端、边缘设备或移动设备等。
ONNX还提供了一组工具和库，帮助开发人员更容易地创建、训练和部署深度学习模型。
ONNX模型是由多个节点（node）组成的图（graph），每个节点代表一个操作或一个张量（tensor）。ONNX模型还包含了一些元数据，例如模型的版本、输入和输出张量的名称等。
onnx官网 ONNX | Home
pytorch官方使用onnx模型格式举例 (optional) Exporting a Model from PyTorch to ONNX and Running it using ONNX Runtime — PyTorch Tutorials 2.2.0+cu121 documentation
TensorFlow官方使用onnx模型格式举例 https://github.com/onnx/tutorials/blob/master/tutorials/TensorflowToOnnx-1.ipynb
Netron可视化模型结构工具 Netron
你可通过该工具看到onnx具体的模型结构，点击每层都能看到其对应的内容信息
onnxRuntime | 提供各种编程语言推导onnx格式模型的接口 ONNX Runtime | Home
比如我需要在java环境下调用一个onnx模型，我可以先导入onnxRuntime的依赖，对数据预处理后，调用onnx格式模型正向传播导出数据，然后将数据处理成我要的数据。 onnxRuntime也提供了其他编程语言的接口，如C++、C#、JavaScript、python等等。
实际案例举例 python部分 python下利用ultralytics从网上下载并导出yolov8的onnx格式模型，用java调用onnxruntim接口，正向传播推导模型数据。
pip install ultralytics from ultralytics import YOLO # 加载模型 model = YOLO('yolov8n.pt') # 加载官方模型 #加载自定义训练的模型 #model = YOLO('F:\\File\\AI\\Object\\yolov8_test\\runs\\detect\\train\\weights\\best.pt') # 导出模型 model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e31c6b5f15208960365b819194d0af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802c136cff89d033261bb52d2605b0e1/" rel="bookmark">
			Text-to-SQL小白入门（十）RLHF在Text2SQL领域的探索实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容主要基于以下开源项目探索实践，
Awesome-Text2SQL:GitHub - eosphoros-ai/Awesome-Text2SQL: Curated tutorials and resources for Large Language Models, Text2SQL, Text2DSL、Text2API、Text2Vis and more.DB-GPT-Hub：GitHub - eosphoros-ai/DB-GPT-Hub: A repository that contains models, datasets, and fine-tuning techniques for DB-GPT, with the purpose of enhancing model performance in Text-to-SQLDB-GPT：GitHub - eosphoros-ai/DB-GPT: Revolutionizing Database Interactions with Private LLM TechnologyDeepSpeedExamples:GitHub - microsoft/DeepSpeedExamples: Example models using DeepSpeed 开源不易，希望大家给个star支持一下，感谢！
Text2SQL简介 本章主要对Text2SQL的基本定义、使用的开源数据集和评测指标做了介绍，同时也介绍了一些实践项目，供大家参考。
定义 Text-to-SQL（简写为Text2SQL），顾名思义就是把文本转化为SQL语言，更学术一点的定义是：把数据库领域下的自然语言（Natural Language，简写为NL）问题，转化为在关系型数据库中可以执行的结构化查询语言（Structured Query Language，简写为SQL），因此Text2SQL也可以被简写为NL2SQL。
举个例子比较直观：
输入：自然语言问题。 查询表t_user的所有信息，结果按id降序排序，只保留前10个数据 输出：SQL语句。 SELECT * FROM t_user ORDER BY id DESC LIMIT 10 实验：如图1所示，在DB-GPT项目中，直接使用原生对话，使用Proxy LLM（GPT-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802c136cff89d033261bb52d2605b0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3744b9a7c2fbcde2d80baa3b59338786/" rel="bookmark">
			【大数据毕设】基于Hadoop的招聘网站可视化的设计与实现(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝6W+,csdn特邀作者、博客专家、大数据领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于大数据技术领域和毕业项目实战✌
🍅文末获取项目联系🍅
基于Hadoop的招聘网站可视化的设计与实现
摘要：现在，随着互联网网络的飞速发展，人们获取信息的最重要来源也由报纸、电视转变为了互联网。互联网的广泛应用使网络的数据量呈指数增长，让人们得到了更新、更完整的海量信息的同时，也使得人们在提取自己最想要的信息，过滤掉对自己无用的信息时变得不那么容易，对于应聘者也是如此。由于招聘网站的日益流行，也使得应聘网站成为了应聘者找工作的主要平台。在面对着大量的招聘信息时，就业者不能一目了然的获取自己想要的招聘信息，因此我们需要对海量的招聘数据进行处理，做出一种招聘信息的分析系统。在此基础上本文介绍了基于Hadoop的招聘网站的可视化的设计与分析过程中的技术线路。
本招聘网站的可视化使用Hadoop语言编写，使用基于SpringBoot的Web应用框架，数据库使用MySQL，使用ECharts进行数据可视化部分的显示。对数据的爬取使用的Requests进行爬取数据，本次爬取的招聘网站为拉勾网搜索关键词为Java、Hadoop、大数据的招聘信息，拉勾网具有较强的反爬虫机制，采用Cookie形式进行封装，再进行数据的获取。在MySQL数据库中存储爬取的招聘信息，用Pymysql包连接MySQL数据库将查询的数据使用ECharts框架展示到网页。
通过本系统可以用户可以了解到职位的信息概况、薪资分布情况、企业主要招聘城市情况和企业的规模分布、职位的福利待遇和对应聘者的学历要求，工作经验的要求。
关键词：Hadoop；数据可视化；招聘网站
Design and Implementation of Recruitment Website Crawler and Visualization Based on Hadoop
Abstract: Nowadays, with the rapid development of the Internet, the most important source for people to obtain information has been changed from newspapers and TV to the Internet. The extensive application of the Internet makes the amount of data on the Network grow exponentially, and makes it difficult for people to extract the information they want most and filter out the useless information, even for the applicants.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3744b9a7c2fbcde2d80baa3b59338786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94adb7c3eecb26509b916a3928561d56/" rel="bookmark">
			Vue3路由配置createRouter、createWebHistory、useRouter,useRoute
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3和Vue2基本差不多，只不过需要将createRouter、createWebHistory从vue-router中引入，再进行使用。
手动配置Vue-router环境： 1、下载包： npm i vue-router --save或者 npm i vue-router --S 或者用cdn引入
2、创建路由的js文件（路由、子路由、重定向、开启history模式）
createRouter、createWebHistory
//路由文件 import { createRouter, createWebHistory } from 'vue-router' //将createRouter、createWebHistory引入vue const routes = [ { path: '/', //配置默认路由 name: 'home', //路由名 component: () =&gt; import("../views/home.vue"), //引入该路由使用的组件 }, { path: '/a', name: 'a', component: () =&gt; import('../views/a.vue'), redirect: '/a/son1', children:[ //配置子路由 { path: '/a/son1', //子路由路径前边必须写父路由路径 name: 'ason1', component: ()=&gt;import("../views/a-son1.vue")	} ] }, { path: '/b', name: 'b', component: () =&gt; import('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94adb7c3eecb26509b916a3928561d56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9142f720d32f57cf5df45bda71758ac/" rel="bookmark">
			yolov8实战第三天——yolov8TensorRT部署（python推理）（保姆教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇中我们使用自己的数据集训练了一个yolov8检测模型，best.py。
yolov8实战第一天——yolov8部署并训练自己的数据集（保姆式教程）-CSDN博客
yolov8实战第二天——yolov8训练结果分析（保姆式解读）-CSDN博客
接下要对best.py进行TensorRT优化并部署。
TensorRT是一种高性能深度学习推理优化器和运行时加速库，可以为深度学习应用提供低延迟、高吞吐率的部署推理。
TensorRT可用于对超大规模数据中心、嵌入式平台或自动驾驶平台进行推理加速。
TensorRT现已能支持TensorFlow、Caffe、Mxnet、Pytorch等几乎所有的深度学习框架，将TensorRT和NVIDIA的GPU结合起来，能在几乎所有的框架中进行快速和高效的部署推理。
一般的深度学习项目，训练时为了加快速度，会使用多GPU分布式训练。但在部署推理时，为了降低成本，往往使用单个GPU机器甚至嵌入式平台（比如 NVIDIA Jetson）进行部署，部署端也要有与训练时相同的深度学习环境，如caffe，TensorFlow等。
由于训练的网络模型可能会很大（比如，inception，resnet等），参数很多，而且部署端的机器性能存在差异，就会导致推理速度慢，延迟高。这对于那些高实时性的应用场合是致命的，比如自动驾驶要求实时目标检测，目标追踪等。
为了提高部署推理的速度，出现了很多模型优化的方法，如：模型压缩、剪枝、量化、知识蒸馏等，这些一般都是在训练阶段实现优化。
而TensorRT 则是对训练好的模型进行优化，通过优化网络计算图提高模型效率。
一、安装TensorRT Log in | NVIDIA Developer
下载TensorRT 。
我下载的是8.6里画黑线的那个。 将 TensorRT-8.6.1.6\include中头文件 copy 到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\include
将TensorRT-8.6.1.6\lib 中所有lib文件 copy 到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\lib\x64
将TensorRT-8.6.1.6\lib 中所有dll文件copy 到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\bin
在python文件夹中找到适合自己的。
pip install tensorrt-8.6.1-cp310-none-win_amd64.whl 至此TensorRT安装完成。
二、pt转onnx： GitHub - triple-Mu/YOLOv8-TensorRT: YOLOv8 using TensorRT accelerate !
参考着这个，下载，安装环境后。
安装onnx：
pip install onnx -i https://pypi.tuna.tsinghua.edu.cn/simple pip install onnxsim -i https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9142f720d32f57cf5df45bda71758ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d621c5441bbea1231e3b152e49c600/" rel="bookmark">
			【数据结构初阶】二叉树（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树顺序结构 1.二叉树的顺序结构及实现1.1二叉树的顺序结构 1.2 堆的概念及结构1.3 堆的实现1.3.1向上调整1.3.2向下调整1.3.3交换函数1.3.4打印1.3.5初始化1.3.6销毁1.3.7插入1.3.8删除1.3.9获得堆顶元素1.3.10判断是否为空1.3.6 堆的代码实现 1.3.2堆的创建1.3.3 建堆时间复杂度1.4 堆的应用1.4.1 堆排序 1.二叉树的顺序结构及实现 1.1二叉树的顺序结构 普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结构存储。现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。
1.2 堆的概念及结构 堆的性质：
堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。
练习题：
1.下列关键字序列为堆的是：（）
A 100,60,70,50,32,65
B 60,70,65,50,32,100
C 65,100,70,32,50,60
D 70,65,100,32,50,60
E 32,50,100,70,65,60
F 50,100,70,65,60,32
2.已知小根堆为8,15,10,21,34,16,12，删除关键字 8 之后需重建堆，在此过程中，关键字之间的比较次
数是（）。
A 1
B 2
C 3
D 4
3.一组记录排序码为(5 11 7 2 3 17),则利用堆排序方法建立的初始堆为
A(11 5 7 2 3 17)
B(11 5 7 2 17 3)
C(17 11 7 2 3 5)
D(17 11 7 5 3 2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8d621c5441bbea1231e3b152e49c600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d01d3ad024f7447897367f533b990d3/" rel="bookmark">
			java 中MultipartFile类型转为File类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		multipartfile转为file Java 是一个常见的需求，特别是在上传文件和处理文件的场景中。在Java中，MultipartFile是Spring框架提供的一种用于表示上传的文件的数据结构，而File是Java标准库中用于表示文件的类。开发过程中遇到此问题，特意留个简单的笔记。
MultipartFile和File的区别 MultipartFile是Spring框架中的一个接口，用于表示HTTP请求中上传的文件。它提供了访问文件内容、文件名称、文件大小等方法。
File是Java标准库中的一个类，用于表示文件。它提供了文件路径、文件是否可读、文件是否可写等方法。
MultipartFile和File的最主要的区别在于它们的数据来源和操作方式。
MultipartFile表示的文件是通过HTTP请求上传的，而File表示的文件是本地文件系统中的文件。因此，我们通常需要将MultipartFile转换为File，以便在后续的操作中使用。
MultipartFile转为File的方法 在Java中，我们可以通过以下两种方法将MultipartFile转换为File。
方法一：将MultipartFile保存为临时文件 首先，我们可以将MultipartFile保存为临时文件，然后再将临时文件转换为File。
import org.springframework.util.FileCopyUtils; public File convertMultipartFileToFile(MultipartFile multipartFile) throws IOException { File file = File.createTempFile(multipartFile.getOriginalFilename(), null); FileCopyUtils.copy(multipartFile.getBytes(), file); return file; } 这个方法的实现非常简单。我们首先创建一个临时文件，使用MultipartFile的getOriginalFilename方法获取文件名，并使用File.createTempFile方法创建文件。然后，我们使用FileCopyUtils.copy方法将MultipartFile的内容复制到临时文件中。最后，我们返回这个临时文件。
方法二：使用Commons IO库 import org.apache.commons.io.FileUtils; import org.springframework.util.FileCopyUtils; public File convertMultipartFileToFile(MultipartFile multipartFile) throws IOException { File file = new File(multipartFile.getOriginalFilename()); FileUtils.writeByteArrayToFile(file, multipartFile.getBytes()); return file; } 这个方法的实现也很简单。我们首先创建一个File对象，使用MultipartFile的getOriginalFilename方法获取文件名，并作为参数传递给File的构造函数。然后，我们使用FileUtils.writeByteArrayToFile方法将MultipartFile的内容写入到File对象中。最后，我们返回这个File对象。
方法三：创建一个临时路径，转换之后得到File，然后再将其删除 File file = new File(path); FileUtils.copyInputStreamToFile(multipartFile.getInputStream(), file); 方法四 public File transferToFile(MultipartFile multipartFile) { // 选择用缓冲区来实现这个转换即使用java 创建的临时文件 使用 MultipartFile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d01d3ad024f7447897367f533b990d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50020651a93a3c0fcfc63ac77353454/" rel="bookmark">
			WAVE SUMMIT&#43; 2023倒计时2天，传文心一言将曝最新进展！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10句话2分钟，挑战成功说服宿管阿姨开门，这个人群中的“显眼包”是一个接入文心大模型4.0游戏里的NPC，妥妥 “工具人”实锤～
尝试用AI一键自动识别好坏咖啡豆，看一眼便知好坏，真正“颜值即正义”，让咖啡星人狂喜～
借助AI在任何平面上模拟的钢琴，即兴“弹奏”世界名曲，开一场科技感满满的专属演奏会～
在虚拟世界的神奇办公室，输入你的创业方向，智慧打工人们将为你的项目勤劳奔走，并在过程中，把日报、周报写好，让你随时掌握项目进度和最终成果……
这些听起来新奇而有趣的AI应用，都将在两天后举行的WAVE SUMMIT+深度学习开发者大会2023开发者市集亮相。作为业界影响力最大的深度学习与大模型开发者大会，WAVE SUMMIT+ 2023定于12月28日在北京开启。
现场大咖云集，百度首席技术官、深度学习技术及应用国家工程研究中心主任王海峰及数百位产业大咖、知名学者、技术大牛、顶尖开源项目发起人等重磅嘉宾，从大模型技术、开源开放、产业护航、软硬一体等议题出发，为开发者奉上大模型时代低门槛开发和创建应用的硬核干货。
倒计时2天，大会的五大亮点带大家抢鲜看。
亮点一：趋势引领，“扛把子”文心一言将曝新进展
今年10月17日，迄今为止综合实力最强的文心大模型4.0重磅面世，理解、生成、逻辑、记忆四大能力得到显著提升，大语言模型正在为通用人工智能带来曙光。截至11月初，文心一言用户数达到7000万，场景达4300个。这得益于飞桨与文心的协同优化，文心大模型4.0的模型周均训练有效率超过98%，相比于3月份，训练算法效率提升至3.6倍，推理性能提升至50倍。
本次大会，文心一言以及飞桨将披露技术和生态层面的最新进展，更关乎千万开发者的切身使用体验和权益～第十届WAVE SUMMIT，值得期待。
亮点二：干货十足，硬核低门槛开发秘籍大放送
当今，技术圈万众瞩目的Agent到底是何方神圣，应该怎么打造Agent？大模型与开发工具链相结合，为开发提效提供了哪些新可能？硬件-框架-模型到底怎样协同优化发挥最大效能？开发者们的“趁手利器”Comate还能怎么用？你想了解的各类技术干货，前沿的科技圈热点，来WAVE SUMMIT+2023，不容错过！
亮点三：蓄势待发，大模型赋能产业正当时
大会主论坛之后，聚焦前沿、产业、硬件、开发应用等主题的五大平行论坛同步举行，将大模型前沿技术分享与产业落地的心法一一奉上。科学启智、AI赋能，AI for Science塑造多学科研究新范式，跨界融合创新展现巨大应用潜能；大模型产业应用中的标杆先行者放大招：华晨宝马将带来企业级大模型Agent服务平台、东方电科新能源功率准确性提升实现能效优化……主流硬件厂商悉数亮相：NVIDIA、Intel、中科曙光、昇腾、燧原科技、太初……飞桨硬件生态朋友圈再扩大，生态势能贯通产业链。
亮点四：群星闪耀，AI产业生态星河万里
开源开放、众行致远。为持续引导探索产业AI关键场景，大会还从开源开放、产业创新等多个维度，评选出 “星河产业应用创新奖”，“文心x飞桨最具影响力开发者”等大奖，并将于大会现场颁奖，激发开源创新活力，赋能产业繁荣生态，助推产业智能化。
WAVE SUMMIT 五年十届，这也是中国AI技术生态繁荣与崛起的关键时期。开发者作为中坚力量，为智能世界贡献出自己的智慧；飞桨星河社区以开源开放的姿态，汇聚了开发者们最聪明的大脑。大会将设有开发者相关环节，让大家看到群像背后的一个个故事，感受一点点星光、见证科技让世界更有温度。
亮点五：应用繁荣，创意市集与AI原生Workshop尽显极客范
这次WAVE SUMMIT+ 2023为开发者专设多个体验互动环节，前面提到的开发者市集就是其中之一。本次开发者市集上，几十款开发者打造的AI互动小应用，带你沉浸式感受技术的魅力，现场还有开发者亲自讲解、示范，零距离接触那些开发者大神。
此外，大会还为开发者们精心准备了三场Workshop，现场手把手教你打造自己的AI原生应用。星河探索，智能应用，志在推进高质量、高可用的AI原生应用落地的最后一公里，现场将带来星河社区ERNIE Bot SDK的能力讲解与实战，帮你解锁文心一言无限可能，还有更多AI原生应用落地和开发实战，玩转原生应用，感受AI原生应用魅力。
在经历过下午一系列酣畅的技术烧脑与极客碰撞后，晚上，开发者们可以到“AI开发者之夜”好好放松一下，在这不仅可以挑战AI原生小游戏，观看精彩表演，也能“以AI会友”，共同奔赴AI时代的“诗与远方”。
随着大模型的爆发，人工智能的风已经吹到社会的各个角落。WAVE SUMMIT+ 2023这场 AI开发者的“嘉年华”，让每位参会者深入探索基于大模型的AI应用，了解技术发展前沿信息和应用风向，在新时代新机遇来临之际，抓住先机，创造更多可能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8875cbca060b0b7fc1fbf90e7cb654/" rel="bookmark">
			java获取两个List集合之间的交集、差集、并集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 方式一、jdk8 Stream求交集、并集、差集方式二、求交集方式三、collections4.CollectionUtils求交集、差集、并集 本文总结一下java中获取两个List之间的交集、补集、并集的几种方式。 最常用的通过for循环遍历两个集合的方式在这里就不整理了，主要整理一些已经封装或提供出来的方法。
方式一、jdk8 Stream求交集、并集、差集 利用jdk8的新特性Stream流进行求交集、并集、差集。
import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Test { public static void main(String[] args) { List&lt;String&gt; list1 = new ArrayList&lt;&gt;(Arrays.asList("a","b","c")); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(Arrays.asList("b","c","d")); System.out.println("交集："+intersect(list1,list2)); System.out.println("差集："+minus(list1,list2)); System.out.println("并集："+union(list1,list2)); } /** * 交集 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; intersect(List&lt;String&gt; list1, List&lt;String&gt; list2) { List&lt;String&gt; intersect = list1.stream().filter(item -&gt; list2.contains(item)).collect(Collectors.toList()); return intersect; } /** * 差集（list1-list2） * @param list1 * @param list2 * @return */ private static List&lt;String&gt; minus(List&lt;String&gt; list1, List&lt;String&gt; list2) { List&lt;String&gt; minus = list1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8875cbca060b0b7fc1fbf90e7cb654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea627b1ce39a2c725a70f3b34dcf824/" rel="bookmark">
			【Java原理系列】Java中ClassLoader原理用法示例中文源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中ClassLoader原理用法示例中文源码分析 文章目录 Java中ClassLoader原理用法示例中文源码分析必看原理用法示例中文源码 必看 类加载器是负责加载类的对象。ClassLoader类是一个抽象类。 给定类的二进制名称，类加载器应该尝试定位或生成构成该类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。
每个Class对象都包含指向定义它的ClassLoader的引用。
数组类的Class对象不是由类加载器创建的，而是在Java运行时根据需要自动创建的。通过getClassLoader()返回的数组类的类加载器与其元素类型的类加载器相同； 如果元素类型是原始类型，则数组类没有类加载器。
应用程序可以实现ClassLoader的子类以扩展Java虚拟机动态加载类的方式。
类加载器通常由安全管理器用于指示安全域。
ClassLoader类使用委托模型来搜索类和资源。每个ClassLoader实例都有一个关联的父类加载器。在请求查找类或资源时，ClassLoader实例将在尝试自己查找类或资源之前将类或资源的查找委托给其父类加载器。虚拟机内置的类加载器称为“引导类加载器”，它本身没有父类加载器，但可以作为ClassLoader实例的父类。
支持并发加载类的类加载器称为并行可加载类加载器， 它们需要在其类初始化时通过调用ClassLoader.registerAsParallelCapable()方法进行自我注册。 请注意，默认情况下，ClassLoader类已经注册为并行可加载。 然而，如果子类是并行可加载的，则仍然需要注册自己。在非严格层次结构的环境中，类加载器需要具备并行可加载的能力，否则类加载可能会导致死锁，
因为在整个类加载过程中保持了加载器锁（参见loadClass方法）。
通常，Java虚拟机以平台相关的方式从本地文件系统加载类。 例如，在UNIX系统上，虚拟机从CLASSPATH环境变量定义的目录加载类。但是，有些类可能不来自文件；它们可能来自其他来源，如网络，或者可以由应用程序构造。 defineClass方法将字节数组转换为Class实例。 可以使用这个新定义的类的实例来创建对象。
类加载器创建的对象的方法和构造函数可能引用其他类。 为了确定所引用的类，Java虚拟机会调用最初创建该类的类加载器的loadClass方法。
例如，一个应用程序可以创建一个网络类加载器来从服务器下载类文件。 示例代码如下：
ClassLoader loader = new NetworkClassLoader(host, port); Object main = loader.loadClass("Main", true).newInstance(); 网络类加载器子类必须定义findClass方法和loadClassData方法来从网络中加载类。 下载组成该类的字节后，应使用defineClass方法创建一个类实例。示例实现如下：
class NetworkClassLoader extends ClassLoader { String host; int port; public Class findClass(String name) { byte[] b = loadClassData(name); return defineClass(name, b, 0, b.length); } private byte[] loadClassData(String name) { // 从连接中加载类数据 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ea627b1ce39a2c725a70f3b34dcf824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d2041ac1b2b550e794bbb9d866fc5c/" rel="bookmark">
			【数据结构】 链表 - 单链表（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B.最简单结构的链表——不带哨兵位单链表的实现 （关于哨兵位结点） 一、不带哨兵位单链表结点的创建1.1 typedef 链表的数据类型 1.2 结点的结构体创建 二、单链表要实现的功能 三、需要包含的头文件四、函数接口一览为什么有些函数参数传递的是二级指针，有些是一级指针？ 五、功能的实现1）打印单链表 2）创建新节点3）尾插 4）尾删 5）头插 6）头删 7）查找 8）删除 9）插入结点 10）销毁 （关于哨兵位结点） 哨兵位结点也叫哑节点。哨兵位结点也是头结点 。该节点不存储有效数据，只是为了方便操作 （如尾插时用带哨兵位的头结点很爽，不需要判空）。
有哨兵位结点的链表，第一个元素应该是链表第二个节点（head -&gt; next，head为哨兵位结点）对应的元素。
有哨兵位结点的链表永不为空 （因为至少有一个结点——哨兵位结点），这样可以避免判断头是否为空，起到简化代码、减少出错的作用。
一、不带哨兵位单链表结点的创建 🚩
下面的自定义类型、函数名里SLT：
来源于单链表的英文：Single Linked List
1.1 typedef 链表的数据类型 typedef 一下链表数据域的数据类型，目的 是如果以后需要改变链表数据类型直接在typedef后改一下即可，否则要在程序中一个个的改，麻烦并且易出错
typedef int SLTDataType; 1.2 结点的结构体创建 凡是有多个数据的 → 创建结构体。
数据域： 存储的数据data，类型是SLTDataType。
指针域： 存下一个结点的地址next，类型是结构体指针 struct SListNode*。
typedef struct SListNode	//line1 {	//line2 SLTDataType data;//数据域	//line3 struct SListNode* next;//指针域	//line4 }SLTNode;	//line5 🔺 注意：指针域的结构体指针不可以是SLTNode* 编译器的查找规则：编译的时候，如果要用到一个函数或者一个类型，它不会向下查找，只能向上查找。具体来说，SLTNode*在第五行以后才起作用，在第四行的时候还没有定义“SLTNode* ”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19d2041ac1b2b550e794bbb9d866fc5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994274a8822fbc4828b7062ff4702e06/" rel="bookmark">
			利DBeaver 导出mysql数据为csv文件乱码解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用默认文件导出方式导出文件为乱码：
使用mysql导出数据默认编码规则为utf-8，而excel默认编码格式是GBK所以出现乱码。解决方法：使用mysql导出数据时更改编码格式为GBK。
结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a7b0e92d0421468c72cd8e9af58f71/" rel="bookmark">
			基于强化学习的智能机器人路径规划算法研究（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.摘要
二.路径规划技术的研究进展
1.研究现状
2.算法分类
2.1 全局路径规划算法
2.2 局部路径规划算法
三.本文采用的路径规划算法——强化学习
1. 概念
2. 与其他机器学习方式的区别
3. 强化学习模型
4.马尔可夫决策过程
5. Q-learning算法
四．算法设计及代码实现
1.UI设计
2.机器人路径规划算法设计
2.1 机器人行进方式
2.2 变量设置：
2.3 算法步骤
五． 算法训练结果分析
1.训练参数
2.训练结果
六．实践过程、体会与反思
七．算法改进和研究展望
1.基于Q-learning算法改进研究现状
2.本文算法的后期改进展望
一.摘要 移动机器人路径规划一直是热门的研究领域，相关的算法丰富多样。本实践前期对机器人路径规划算法做了详细调研，检索并阅读了相关文献，了解了可视图法、人工势场法、启发式算法、神经网络算法等算法在机器人路径规划中的具体应用，本文采用强化学习中的 Q-learning 算法规划机器人的运动路径，做了算 法概念学习、算法代码设计、算法参数调优、算法训练测试等具体工作，查阅相 关开发资料后，决定应用 QT Creator 5.0.2 作为开发环境，采用栅格建模作为算 法应用情景、开发语言为 C++语言。
在完成上述算法设计和算法应用情景开发后，对算法进行仿真验证，训练次 数分别为 200、1000、5000 次，障碍物比例分别设置为 0.2、0.3、0.5，仿真后导 出数据绘制出普通折线图和堆积折线图，呈现结果，也发现了算法收敛速度慢、 初始次数搜索效率低等特点。 最后对本次实践做出总结和反思，对算法改进的方向做了描述，检索并阅读 了大量有关改进强化学习算法规划机器人运动路径的文献，对这些文献一一做了 简要概括。并且对本文算法的未来改进计划做出了初步设想。 关键词：移动机器人 路径规划 强化学习 Q-learning
二.路径规划技术的研究进展 1.研究现状 路径规划是指在规定区域内规划出一条从起始点到目标点的最优解路径，且 要保证与障碍物无碰撞。机器人路径规划存在的难点问题主要有环境建模问题、 算法收敛速度慢以及容易陷入局部最优解问题。[1]
2.算法分类 路径规划可以分为传统算法路径规划和智能仿生算法路径规划两类，其中传统路径规划算法又可以分为全局路径规划算法和局部路径规划算法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a7b0e92d0421468c72cd8e9af58f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f230b6dc9f9a291bee2167e7f07c9575/" rel="bookmark">
			Java 中函数 Function 的使用和定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、函数的基本使用 1、UnaryOperator&lt;T&gt; 单个泛型的函数 //UnaryOperator 只有一个泛型类，表示参数类型和返回值类型都为此泛型 UnaryOperator&lt;Integer&gt; squareFunction = new UnaryOperator&lt;Integer&gt;() { @Override public Integer apply(Integer integer) { return integer * integer; } }; //使用 Lambda 表达式简化 UnaryOperator&lt;Integer&gt; squareFunction = num -&gt; num * num; //调用函数 Integer num = squareFunction.apply(5); 2、Function&lt;T,R&gt; 两个泛型的函数 //Function 有两个泛型类，前一个为参数类型，后一个为返回值类型 Function&lt;Date, String&gt; convertFunction = new Function&lt;Date, String&gt;() { @Override public String apply(Date date) { // 使用 hutool 工具类中的日期工具类 return DateUtil.format(date, DatePattern.NORM_DATETIME_PATTERN); } }; //使用 Lambda 表达式简化 Function&lt;Date, String&gt; convertFunction = date -&gt; DateUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f230b6dc9f9a291bee2167e7f07c9575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758ec221d5db044470297e393617741a/" rel="bookmark">
			利用决策树进行预测分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 随着数据的大规模生成和存储，数据挖掘技术在各个领域得到了广泛应用。预测分析是数据挖掘的一个重要方面，旨在根据历史数据预测未来事件的发展趋势。决策树是一种常用的预测分析方法，它可以将复杂的决策规则表示为一棵树形结构，从而使得复杂的决策过程变得简单易懂。
在本文中，我们将介绍决策树的核心概念、算法原理和具体操作步骤，以及如何通过编程实现决策树的预测分析。此外，我们还将讨论决策树在未来发展方向和挑战中的地位。
2.核心概念与联系 2.1 决策树的基本概念 决策树是一种用于解决决策问题的图形模型，它将问题分解为一系列较小的子问题，直到可以使用简单的决策规则解决为止。决策树由节点和边组成，其中节点表示决策点，边表示决策选项。
2.2 决策树的类型 根据决策树的构建方法，可以分为以下几类：
ID3：基于信息熵的决策树构建算法，用于离散型特征的决策树构建。C4.5：基于信息增益率的决策树构建算法，是ID3算法的改进版，可以处理连续型特征。CART：基于Gini索引的决策树构建算法，用于处理连续型特征的决策树构建。CHAID：基于卡方统计检验的决策树构建算法，用于连续型特征的决策树构建。 2.3 决策树与其他预测分析方法的关系 决策树是一种简单易懂的预测分析方法，它可以直观地表示决策规则。与其他预测分析方法(如支持向量机、随机森林、回归分析等)相比，决策树具有以下优缺点：
优点：
易于理解和解释，具有良好的可解释性。对于非线性关系的数据，决策树可以找到较好的分割方案。对于缺失值的处理，决策树可以通过设置默认值进行处理。 缺点：
决策树可能过拟合数据，导致预测准确性较低。决策树的构建过程可能受到特征选择和训练集大小的影响。决策树的构建过程可能需要大量的计算资源。 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1 决策树构建的基本思想 决策树构建的基本思想是通过递归地选择最佳决策点，将问题分解为较小的子问题。具体步骤如下：
选择一个特征作为根节点。对于每个特征，找到使目标函数达到最大值的决策点。对于每个决策点，递归地构建子节点。当所有特征都被选择或者所有决策点都被选择时，停止递归。 3.2 ID3算法 ID3算法是一种基于信息熵的决策树构建算法，其主要步骤如下：
计算特征的信息熵。对于每个特征，计算条件信息熵。选择使得信息熵最小化的特征作为决策点。递归地构建子节点。当所有特征都被选择或者所有决策点都被选择时，停止递归。 信息熵的计算公式为：
$$ I(S) = -\sum{i=1}^{n} P(ci) \log2 P(ci) $$
条件信息熵的计算公式为：
$$ I(S|A) = I(S) - \sum{v \in A} \frac{|Sv|}{|S|} I(S_v) $$
3.3 C4.5算法 C4.5算法是ID3算法的改进版，其主要步骤如下：
计算特征的信息增益率。对于每个特征，计算条件信息增益率。选择使得信息增益率最大化的特征作为决策点。递归地构建子节点。当所有特征都被选择或者所有决策点都被选择时，停止递归。 信息增益率的计算公式为：
$$ Gain(S, A) = I(S) - \frac{|SL|}{|S|} I(SL) - \frac{|SR|}{|S|} I(SR) $$
3.4 CART算法 CART算法是一种基于Gini索引的决策树构建算法，其主要步骤如下：
计算特征的Gini索引。对于每个特征，计算条件Gini索引。选择使得Gini索引最小化的特征作为决策点。递归地构建子节点。当所有特征都被选择或者所有决策点都被选择时，停止递归。 Gini索引的计算公式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/758ec221d5db044470297e393617741a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcba8ea2120aa55ddd5664165c6f9fe8/" rel="bookmark">
			Python错题集-问题2：invalid escape sequence（无效的转义序列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1问题描述： 今日在学习绘制多组直方图过程中，遇到"SyntaxWarning: invalid escape sequence"
SyntaxWarning: invalid escape sequence '\s'
label=r'$\mu = $ ' + str(mu1) + ', $\sigma = $ ' + str(sigma1))
绘图仍然能够显示，但是程序报错。
2代码详情： #导入相关库 import numpy as np #导入numpy库 import matplotlib.pyplot as plt #导入matplotlib的绘图模块 #准备相关数据 N = 1000 mu1 = 5 mu2 = 10 mu3 = 15 sigma1 = 5 sigma2 = 3 sigma3 = 2 x1 = np.random.randn(N) * sigma1 + mu1 x2 = np.random.randn(N) * sigma2 + mu2 x3 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcba8ea2120aa55ddd5664165c6f9fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0d95daa694ed35a019c57eeb524546d/" rel="bookmark">
			在Python中使用pyecharts图形画可视化大屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
一.Pyecharts的基本用法
1.语法结构​编辑
二.绘制4个pyecharts图形
1.需要注意的问题
2.绘制散点图
​编辑3.绘制饼图
4.雷达图
5. 柱形图代码展示
三.制作大屏标题 1.代码解释
1.图表结果展示
2.使用pyecharts库创建Page对象
3.使用Python的BeautifulSoup库来读取和修改一个HTML文件
大总结
引言 pyecharts 是一个用于生成 ECharts 图表的类库，可以方便地在 Python 中进行数据可视化。ECharts 是一种使用 JavaScript 实现的，功能丰富的图表库。通过 pyecharts，我们可以在 Python 中创建各种类型的图表，包括折线图、柱状图、饼图、散点图等。使用pyecharts进行可视化大屏的优点有很多，比如：
丰富的图表类型：pyecharts支持多种类型的图表，可以满足不同的数据可视化需求。
高效的性能：pyecharts的性能非常好，可以快速生成大量的图表。
易用性：pyecharts的API设计简洁易用，可以快速上手。
可扩展性：pyecharts支持自定义主题和与其他Python库的集成，方便用户扩展功能。
一.Pyecharts的基本用法 1.语法结构 Pyecharts的语法结构包括以下部分：
图表类型：Pyecharts支持多种图表类型，如柱状图、折线图、饼图、散点图等。每种图表类型都有自己的方法和属性，用于设置图表的外观和数据。数据：Pyecharts图表的数据以列表形式给出，每个列表代表一个系列的数据。每个系列可以包含多个数据点，每个数据点包含x轴和y轴的值。配置项：Pyecharts图表支持多种配置项，如标题、图例、提示框、工具栏等。这些配置项可以用于设置图表的外观和交互方式。方法链：Pyecharts图表的方法可以链式调用，例如add_xaxis().add_yaxis()。这种链式调用方式使得代码更加简洁和易读。 总之，Pyecharts的语法结构基于ECharts的语法结构，通过Python类库的方式实现。使用Pyecharts可以方便地在Python中创建各种类型的图表，并对其进行配置和定制。
二.绘制4个pyecharts图形 pyecharts是一个基于Python语言的数据可视化库，可以用来创建各种类型的图形，如折线图、柱状图、散点图、饼图、地图等。它基于Echarts库，通过Python语言提供了更简单、更便捷的方式来创建图形，无需编写复杂的JavaScript代码。使用pyecharts，用户可以通过简单的Python代码来定义图形的数据、样式、布局等，然后生成HTML文件，从而实现图形的展示和交互。通过pyecharts，用户可以在Python环境下灵活、高效地进行数据可视化工作。
1.需要注意的问题 （1）.绘制pyecharts图形需要导入库的相关类和函数：在Python文件中导入pyecharts库的相关类和函数：
import pandas as pd from pyecharts.charts import Scatter from pyecharts import options as opts （2）.安装pyecharts库：通过pip安装pyecharts库，可以使用以下命令进行安装：
pip install pyecharts 2.绘制散点图 1.安装pyecharts库，导入必要的包：
# 绘制一个散点图 import pandas as pd from pyecharts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0d95daa694ed35a019c57eeb524546d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9ac449be79de6bd4e0013e5b24fb30/" rel="bookmark">
			【知识点随笔分享 | 第九篇】常见的限流算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.固定窗口限流： 缺点： 2.滑动窗口限流：
优点：
滴桶限流：
缺点：
令牌桶限流： 优点：
总结:
前言： 当今互联网时代，随着网络流量的快速增长和系统负载的不断加重，限流算法作为一种重要的网络管理工具变得愈发重要。限流算法通过控制系统的输入和输出流量，有效地保护系统不受过载的影响，确保系统能够稳定可靠地运行。本文将介绍几种常见的限流算法及其应用场景，旨在帮助读者更好地理解限流算法的原理和实际应用，从而为网络性能优化提供有力支持。限流算法的研究和应用对于保障网络安全、提升系统稳定性具有重要意义，在当前信息化社会具有广泛的应用前景。 1.固定窗口限流： 固定窗口限流 就是在单位时间（时间窗口）内，只能接收指定数量的请求。
在固定窗口限流算法中，时间被划分为固定大小的窗口，并且每个窗口内允许通过的请求数是固定的。算法步骤： 统计当前窗口内的请求数；如果请求数超过了限制值，则拒绝该请求；重置新的窗口开始计数。 用汉堡店举例：固定窗口限流就是 在固定的时间内只能接待指定数量的顾客。比如一个小时只能接待10个顾客。
固定窗口限流的思路比较简单，代码实现为：
import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; public class FixedWindowRateLimiter { private final int limit; // 限制的请求数 private final long windowSizeInMillis; // 窗口大小（毫秒） private final AtomicInteger counter; private long windowStartTime; public FixedWindowRateLimiter(int limit, long windowSizeInMillis) { this.limit = limit; this.windowSizeInMillis = windowSizeInMillis; this.counter = new AtomicInteger(0); this.windowStartTime = System.currentTimeMillis(); } public boolean allowRequest() { long currentTime = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c9ac449be79de6bd4e0013e5b24fb30/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/544/">«</a>
	<span class="pagination__item pagination__item--current">545/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/546/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>