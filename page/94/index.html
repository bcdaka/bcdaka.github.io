<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae705049b1ef3944efd50d48d352d4c/" rel="bookmark">
			云计算学习——5G网络技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 ` 提示：仅用于个人学习，进行查漏补缺使用。
Day1 网络参考模型
Day2 网络综合布线与应用
Day3 IP地址
Day4 华为eNSP网络设备模拟器的基础安装及简单使用
Day5 交换机的基本原理与配置
Day6 路由器的原理与配置
Day7 网络层协议介绍一
Day8 传输层协议
Day9 (一)虚拟局域网VLAN与Trunk技术
Day9 (二)单臂路由
Day9 (三)三层交换技术
Day10 链路聚合技术
Day11 NAT技术（一）
Day11 VRRP技术（二）
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、VRRP基本概述二、VRRP基本结构三、VRRP术语四、工作原理选举算法：配置参数： 五、优势：六、应用场景：七、VRRP配置实例：八、小结：九、补充： 前言 本章大概内容有：
VLAN的介绍、概念、优势、分类、配置实验
Trunk的介绍、配置、实验
提示：以下是本篇文章正文内容，下面案例可供参考
一、VRRP基本概述 VRRP（Virtual Router Redundancy Protocol，虚拟路由器冗余协议）是一种用于提高网络可靠性和可扩展性的协议。它允许多个路由器协同工作，共同提供虚拟路由器功能，对外表现为一个虚拟路由器。VRRP通过虚拟路由器ID（VRID）来区分不同的虚拟路由器实例。VRRP的主要功能是实现路由器的高可用性和负载均衡。当网络中的某个路由器发生故障时，其他路由器可以接替其工作，保证网络的连通性。VRRP通过选举机制来确定哪个路由器作为主路由器（Master），负责处理虚拟路由器的所有网络流量，其他路由器作为备份路由器（Backup）。 VRRP的关键知识点包括：
二、VRRP基本结构 虚拟路由器（VR）： VRRP通过虚拟路由器来实现多台路由器的冗余。虚拟路由器是一个抽象的概念，它代表了一个虚拟的IP路由器，对外表现为一个虚拟的IP地址。虚拟IP地址（VIP）： 虚拟路由器有一个虚拟IP地址，这个地址是由参与VRRP的各台路由器共享的。所有发往这个虚拟IP地址的数据都会被VRRP选定的主路由器处理。路由器ID（Router ID）： 参与VRRP的路由器都有一个唯一的ID，用来区分不同的路由器。路由器ID通常是一个32位的整数，也可以是路由器的物理地址（如MAC地址）。虚拟路由器接口（Virtual Router Interface）： 每个参与VRRP的路由器都需要配置一个虚拟接口，这个与虚拟路由器相对应，用来发送和接收VRRP消息。VRRP状态： 每个路由器参与VRRP时，都会处于不同的状态，如初始状态（Init）、主状态（Master）、备状态（Backup）等。路由器根据VRRP协议的规定，通过交换VRRP消息来维护这些状态。优先级（Priority）： 参与VRRP的路由器都有一个优先级，优先级高的路由器更有可能成为主路由器。如果所有参与VRRP的路由器的优先级相同，那么将通过比较路由器ID来决定主路由器。VRRP消息： VRRP路由器通过交换特定的VRRP消息来协调它们之间的行为。这些消息包括advertisement（广告）消息和hello消息，主要用于维护VRRP状态和选举主路由器。 三、VRRP术语 VRID：虚拟路由器ID，用于区分不同的虚拟路由器实例。Master：主路由器，负责处理虚拟路由器的所有网络流量。Backup：备份路由器，当主路由器发生故障时，可以接替其工作。Advertisement：路由器发送的VRRP信息，用于通知其他路由器其状态。 四、工作原理 VRRP路由器通过发送 Advertisement 包来交换状态信息。路由器根据收到的 Advertisement 包中的优先级（Priority）和虚拟路由器ID来确定自己的角色。优先级高的路由器成为主路由器，负责处理虚拟路由器的所有网络流量。主路由器定期发送 Advertisement 包，备份路由器收到这些包后，知道主路由器仍然正常工作。如果主路由器发生故障，停止发送 Advertisement 包，备份路由器会根据预定的选举算法选出新的主路由器。 选举算法： VRRP使用预设的选举算法来确定新的主路由器。常见的选举算法包括：最高优先级、最长接入路径、随机选择。 配置参数： 虚拟路由器ID：用于区分不同的虚拟路由器实例。优先级：用于确定路由器在选举中的地位，优先级高的路由器成为主路由器。通告时间间隔：主路由器发送 Advertisement 包的时间间隔。虚拟MAC地址：用于在二层网络中唯一标识虚拟路由器。 五、优势： 提高网络可靠性：当主路由器发生故障时，备份路由器可以自动接替其工作。支持负载均衡：多个路由器可以分担网络流量，提高网络性能。简化网络管理：无需手动切换默认网关，提高网络运维效率。 六、应用场景： 在大型网络中，多个路由器共同提供服务，提高网络可靠性。数据中心、企业网络等场景，需要高可用性和负载均衡。 七、VRRP配置实例： 八、小结： VRRP（Virtual Router Redundancy Protocol，虚拟路由冗余协议）是一种局域网内的冗余协议，它可以提高网络的可靠性。它的基本思想是多个路由器协同工作，共享一个虚拟路由器IP地址，对外表现为一个虚拟的路由器。当网络中的某个路由器发生故障时，其他路由器可以接管故障路由器的任务，从而保证网络的连续性和稳定性。VRRP是一个有效的网络冗余解决方案，适用于需要高可用性和故障切换能力的网络环境。但在部署时，需要注意合理规划VRRP组，避免单点故障，并确保网络的安全性。 九、补充： 本章的Xmind导图与笔记如下，需要自取： 链接：https://pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ae705049b1ef3944efd50d48d352d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2589afd90d60b9729e9de616d4eeda/" rel="bookmark">
			UDP网络通信（发送端&#43;接收端）实例 —— Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
在网络通信编程中，用的最多的就是UDP和TCP通信了，原理这里就不分析了，网上介绍也很多，这里简单列举一下各自的优缺点和使用场景
通信方式优点缺点适用场景UDP及时性好，快速视网络情况，存在丢包 与嵌入式设备通信，实时控制
场景
TCP丢包会自动重发，理论上不用担心丢包问题延时相对大一些 通信可靠性场景，比如IoT设备
控制，状态同步
一、socket
我们要进行网络通信，那么就要用到socket，socket即网络套接字，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。
在 Python 中，使用socket 模块的函数 socket 就可以创建一个socket对象，socket()函数的参数分别有family, type, proto。
1.其中family参数是指协议域，又称为协议族（family），常用的协议族有，AF_INET、AF_INET6、...等等，AF_INET指ipv4，AF_INET6即为ipv6；
2.然后是type，type指定socket类型，有SOCK_STREAM（流式套接字，主要用于 TCP 协议）和SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）等等；
3.proto就是指定的协议，常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议，但是type和proto不可以随意组合，当proto参数为0或者不填时，会自动选择type类型对应的默认协议。
二、UDP发送数据
首先我们要导入socket包
import socket 创建一个udp套接字，ipv4协议，使用SOCK_DGRAM参数，不填proto，就会默认自动选择udp协议；
# 1、创建一个UDP套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 然后我们把要接收数据的那一端的ip地址和端口号放在一个元组里准备好
​​​# 2. 准备接收方的地址和端口，'127.0.0.1:9999'表示目的ip地址，9999表示目的端口号 udp_addr = ('127.0.0.1', 9999) # 注意这是一个元组，其中ip地址是字符串，端口号是数字​ 准备好后就可以使用sendto函数进行发送了，要注意，需要对字符串进行编码才可以发送
# 3. 发送数据到指定的ip和端口 udp_socket.sendto("Hello,I am a UDP socket.".encode('utf-8'), dest_addr) 发送完就可以关闭套接字了
# 4. 关闭套接字 udp_socket.close() 例程一：UDP server端，UDP数据接收
​ ​ #!/usr/bin/python3 # -*- coding: utf-8 -*- "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f2589afd90d60b9729e9de616d4eeda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc0a5f38b4ee3f8b255af2ec3cc6091/" rel="bookmark">
			注册中心--Eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥 个人主页：Dikz12🔥个人专栏：Spring Cloud实战📕格言：吾愚多不敏，而愿加学欢迎大家👍点赞✍评论⭐收藏 目录
1.项目问题
2.解决URL问题 2.1解决思路 2.2注册中心
2.3 CAP理论
3.Eureka
3.1搭建Eureka Server
​4.服务注册
1.项目问题 url是写死的，如果IP地址发生变化，需要修改代码；如果多机部署，怎么处理？返回结果如何共用，url非常容易写错； 2.解决URL问题 当更换机器，或者新增机器时，这个URL就需要跟着变更，就需要去通知所有的相关服务去修改.
2.1解决思路 试想⽣活中的场景:
我们⽣活中，避免不了和各个机构(医院,学校,政府部⻔等)打交道，就需要保存各个机构的电话号码.如果机构换了电话号码，就需要通知各个使⽤⽅，但是这些机构的使⽤⽅群体是巨⼤的,没办法做到⼀⼀通知,怎么处理呢?
机构电话如果发⽣变化，通知114.⽤⼾需要联系机构时，先打114查询电话，然后再联系各个机构.
114查号台的作⽤主要有两个:
号码注册：服务⽅把电话上报给114.
号码查询：使⽤⽅通过114可以查到对应的号码.
同样的，微服务开发时，也可以采⽤类似的⽅案.
服务启动/变更时，向注册中⼼报道.注册中⼼记录应⽤和IP的关系.
调⽤⽅调⽤时，先去注册中⼼获取服务⽅的IP，再去服务⽅进⾏调⽤.
2.2注册中心 注册中⼼主要有三种⻆⾊：
服务提供者(Server)：⼀次业务中,被其它微服务调⽤的服务.也就是提供接⼝给其它微服务.服务消费者(Client)：⼀次业务中,调⽤其它微服务的服务.也就是调⽤其它微服务提供的接⼝.服务注册中⼼(Registry):⽤于保存Server的注册信息,当Server节点发⽣变更时,Registry会同步变更.服务与注册中⼼使⽤⼀定机制通信,如果注册中⼼与某服务⻓时间⽆法通信,就会注销该实例. 服务提供者和服务消费者是相对的.
服务注册：服务提供者在启动时,向Registry注册⾃⾝服务,并向Registry定期发送⼼跳汇报存活状态.
服务发现：服务消费者从注册中⼼查询服务提供者的地址，并通过该地址调⽤服务提供者的接⼝.服务发现的⼀个重要作⽤就是提供给服务消费者⼀个可⽤的服务列表.
2.3 CAP理论 谈到注册中⼼，就避不开CAP理论.
CAP理论是分布式系统设计中最基础，也是最为关键的理论.
⼀致性(Consistency)：CAP理论中的⼀致性,指的是强⼀致性.所有节点在同⼀时间具有相同的数据.可⽤性(Availability)：保证每个请求都有响应(响应结果可能不对)分区容错性(Partition Tolerance)：当出现⽹络分区后，系统仍然能够对外提供服务. 以生活中的场景举例：银行利率下调，这个通知需要下发到各个银行的工作人员.
一致性：所有的银行工作人员，对客户讲的利率都是一样的.
可用性：不论何时，银行人员对客户咨询利率的请求，都是有答案的.(答案可能是旧的）
分区容错性：如果一个工作人员请假了，银行依然可以对外提供服务.
P是必须要保证的，所以C和A只能选一个.我们的架构就是CP架构或者AP架构。
CP架构：为了保证分布式系统对外的数据⼀致性,于是选择不返回任何数据
AP架构：为了保证分布式系统的可⽤性,节点返回旧版本的数据(即使这个数据不正确)
3.Eureka Eureka是Netflix OSS套件中关于服务注册和发现的解决⽅案.Spring Cloud对ureka进⾏了集成，并作为优先推荐⽅案进⾏宣传，虽然⽬前Eureka 2.0已经停⽌维护，新的微服务架构设计中,也不再建议使⽤，但是⽬前依然有⼤量公司的微服务系统使⽤Eureka作为注册中⼼.
官⽅⽂档:https://github.com/Netflix/eureka/wiki
Eureka的学习,主要包含以下三个部分:
搭建Eureka Server将order-service,product-service都注册到Eurekaorder-service远程调⽤时,从Eureka中获取product-service的服务列表,然后进⾏交互 3.1搭建Eureka Server 创建Eureka-server⼦模块
引⼊eureka-server依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 项目构建插件 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbc0a5f38b4ee3f8b255af2ec3cc6091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19562f6a1fd33071cb380a81c5312d2f/" rel="bookmark">
			创新食堂管理：采购系统源码与供应链APP开发详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，笔者将从食堂采购系统源码与供应链管理APP开发的角度，探讨如何利用技术创新提升食堂管理效率，并为企业带来更大的价值。
一、食堂采购系统的核心功能与优势
食堂采购系统是指用于管理食堂物资采购流程的软件系统，其核心功能包括采购计划制定、供应商管理、采购订单处理、库存管理、财务结算等。通过这样的系统，食堂管理人员能够更加高效地控制食材采购流程，减少浪费，并确保食材的新鲜与安全。
1.1采购计划制定
系统可以根据食堂每日的餐饮需求、库存情况和供应商的供货能力，自动生成采购订单，从而大幅度提升采购效率。
1.2供应商管理
系统提供了完善的供应商管理模块，允许管理者记录并分析各个供应商的价格、交货时间和质量等关键数据。
1.3库存管理
库存管理功能帮助食堂实时监控库存情况，避免因库存过剩或短缺导致的食材浪费和供应不足。系统还可以自动提醒管理人员补充库存，确保食材供应的稳定性。
1.4财务结算
食堂采购系统通常集成了财务管理功能，可以自动生成采购发票，进行对账和支付管理。这种功能不仅减少了手工对账的错误率，还使得财务流程更加透明、合规。
二、供应链管理APP的开发与实现
供应链管理APP是食堂采购系统的延伸，旨在将整个供应链流程从供应商到食堂的各个环节实现数字化、移动化管理。通过供应链管理APP，管理者可以随时随地掌握采购和供应链的最新动态，做出及时有效的决策。
2.1供应链可视化
供应链管理APP允许用户通过手机或平板设备实时查看整个供应链的运行情况，包括供应商的交货状态、运输进度以及仓库的库存水平。这种可视化的管理方式大大提高了供应链的透明度，使得管理者能够及时发现和解决潜在问题。
2.2实时沟通与协作
供应链管理APP还提供了实时沟通的功能，使得食堂管理人员、供应商和物流公司能够通过APP进行高效的沟通和协作。无论是订单变更、物流跟踪还是紧急采购需求，都可以通过APP及时处理，避免信息滞后导致的决策失误。
2.3数据分析与决策支持
通过APP集成的数据分析模块，管理者可以随时查看供应链各环节的关键绩效指标（KPI），如采购成本、交货时间、库存周转率等。基于这些数据，系统可以提供智能化的决策支持，帮助管理者优化采购策略和供应链流程。
三、技术实现与开发策略
在开发食堂采购系统和供应链管理APP时，企业应根据自身需求和业务规模，选择合适的开发语言、框架和数据库系统。常用的技术栈包括Java、Python、Node.js等语言，以及MySQL、MongoDB等数据库系统。前端开发可以采用React或Vue.js框架，以提升用户体验。
3.1系统架构设计
在系统架构设计方面，建议采用微服务架构，这样可以提高系统的可扩展性和维护性。每个功能模块（如采购管理、库存管理、供应链跟踪）可以作为独立的服务进行开发和部署，方便后期的功能升级和性能优化。
3.2用户体验与界面设计
用户体验是系统成功与否的关键因素。开发人员应注重界面设计的简洁性与易用性，通过直观的操作流程和清晰的界面布局，使得管理人员能够轻松上手使用系统。特别是在移动端应用开发中，需要考虑不同设备屏幕大小和分辨率的适配问题，确保用户在任何设备上都能获得良好的体验。
四、总结
食堂采购系统源码与供应链管理APP的开发，不仅是食堂管理数字化的重要组成部分，更是提升企业运营效率、降低管理成本的关键。通过合理的系统设计和技术实现，食堂管理人员可以更加高效地管理采购流程、优化供应链，从而为企业带来更大的市场竞争力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafda5271965c96a493868777f413f5e/" rel="bookmark">
			使用Python做一个微信机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目功能介绍
现在我们用小程序做一个模拟的应用，智能聊天机器人。发送文字它可以回复一段话，或一张图片，是不是有点小酷！
下面是小程序开发的一个智能聊天机器人的应用界面：
当然，这种智能回复的算法和数据库我们自己肯定是没有的，所以我们借助于gewe框架的开放API接口来完成我们的功能。
gewe框架接口：开发前必读 - GeWe开放平台
智能聊天机器人的开发步骤
1、整体框架
很简单，两个页面。两个tab，并修改window标题栏和tabBar的颜色等属性就好。这个全部在app.json中完成。
2、form表单的使用
表单，将组件内的用户输入的&lt;switch/&gt; &lt;input/&gt; &lt;checkbox/&gt; &lt;slider/&gt; &lt;radio/&gt; &lt;picker/&gt; 提交。
属性名 类型 说明 report-submit Boolean 是否返回formId用于发送模板消息 bindsubmit EventHandle 携带form中的数据触发submit事件，event.detail = {value : {‘name’: ‘value’} , formId: ”} bindreset EventHandle 表单重置时会触发reset事件 当点击 表单中 formType 为 submit 的 &lt;button/&gt; 组件时，会将表单组件中的 value 值进行提交，需要在表单组件中加上 name 来作为 key。 表单提交的要点：
在form内的表单组件必须有name属性。
在form内的button的 formType 属性为 submit 。
form的属性bindsubmit即为数据提交事件绑定的响应函数。
4、wx.request接口的使用
wx.request发起的是 HTTPS 请求。一个微信小程序，同时只能有5个网络请求连接。
在开发调试模式开发工具没有做安全检查，因此是可以请求http的。
wx.request({
url: 'test.php', //仅为示例，并非真实的接口地址
data: { x: '' , y: '' }, header: { 'content-type': 'application/json' }, method: 'GET', success: function(res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cafda5271965c96a493868777f413f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb17ab004c9b202ce7137b398538a54c/" rel="bookmark">
			类和对象(下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和对象 下 再探构造函数之初始化列表（详解）：static成员匿名对象 再探构造函数 之初始化列表（详解）： 特点1、:
实现：
class Date { public: Date(int year,int month,int day) :_year(year)//以冒号开始，逗号为分隔 ,_month(month) ,_day(day) {} private： int _year; int _month; int _day; } 2、
每个成员变量在初始化列表中只能出现⼀次，语法理解上初始化列表可以认为是每个成员变量定义
初始化的地⽅。
3、
引⽤成员变量，const成员变量，没有默认构造的类类型变量，必须放在初始化列表位置进⾏初始
化，否则会编译报错。
引用也同理。
class Date { public: Date(int year,int month,int day,int&amp; xx) :_year(year)//以冒号开始，逗号为分隔 ,_month(month) ,_day(day) ,_n(1) ,_ref(xx) {} private： int _year;//可以初始化,也可以不初始化 int _month;//可以初始化,也可以不初始化（这些可以初始化,也可以不初始化称为普通成员） int _day;//可以初始化,也可以不初始化 const int _n;//但是对于const与引用成员可以不初始化一定不行， int&amp; _ref } 4、
C++11⽀持在成员变量声明的位置给缺省值，这个缺省值主要是给没有显⽰在初始化列表初始化的
成员使⽤的。
class Date { public: Date(int year,int month,int day,int&amp; xx) :_year(year)//以冒号开始，逗号为分隔 ,_month(month) ,_day(day) ,_n(1) ,_ref(xx) {} private： int _year=1; int _month=1; int _day=1; const int _n=1; } 5、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb17ab004c9b202ce7137b398538a54c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00380514de80c9724b14931f6964070/" rel="bookmark">
			SpringBoot项目中，根据数据中的表结构生成后端代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求来源/背景：
每次都根据表去新建表的各个类，存在重复的工作，所以使用代码生成生成相关基础类。
具体实现如下：
添加相关依赖 &lt;!-- 1-mybatis plus generator --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 2-模板引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--3-freemarker模板--&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加 mybatis-plus 的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4-测试模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 添加对应的数据库依赖 &lt;!-- 1 Postgresql包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 2-sqlite相关包--&gt; &lt;!-- https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.xerial&lt;/groupId&gt; &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt; &lt;version&gt;3.45.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2-sqlite 方言--&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00380514de80c9724b14931f6964070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45b917d3325cc7d0ca22d4ca4bb702c/" rel="bookmark">
			Python机器学习实战：分类算法之支持向量机-垃圾邮件识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了解决特定问题而进行的学习是提高效率的最佳途径。这种方法能够使我们专注于最相关的知识和技能，从而更快地掌握解决问题所需的能力。
目录
支持向量机算法介绍
练习题
Python代码与分析
支持向量机和朴素贝叶斯的联系
支持向量机算法介绍 支持向量机（Support Vector Machine, SVM）是一种监督学习算法，主要用于分类和回归问题。它是一种非常强大的模型，因其在高维空间中进行线性和非线性分类的能力而受到广泛欢迎。以下是SVM的一些基本概念和特点：
线性可分性：SVM最初设计用于解决线性可分问题，即数据点可以通过一个超平面清晰地分开成不同的类别。
最大间隔：SVM试图找到一个超平面，使得它与最近的数据点（支持向量）之间的距离最大化。这个距离被称为间隔（margin），最大化间隔可以提高模型的泛化能力。
核技巧：SVM通过核函数将数据映射到更高维的空间，以解决非线性问题。常用的核函数包括线性核、多项式核、径向基函数（RBF）核等。
优化问题：SVM的训练过程可以看作是一个凸优化问题，目标是找到最大化间隔的同时最小化分类误差的解。这保证了找到的解是全局最优解。
软间隔和正则化：在实际应用中，数据可能不是完全线性可分的。SVM通过引入软间隔和正则化参数（如C）来允许一定量的误差，以避免过拟合。
多类分类：SVM最初是为二分类问题设计的，但可以通过多种策略扩展到多类分类问题，如一对一（OvR）、一对余（OvO）等。
回归问题：SVM也可以用于回归问题，称为支持向量回归（SVR），它尝试找到一条曲线，使得实际值和预测值之间的误差在一定阈值内。
模型评估：SVM模型的性能通常通过准确率、召回率、F1分数等指标来评估。
SVM是一种非常灵活且强大的算法，适用于许多不同的问题，但它也有一些局限性，比如对核函数和正则化参数的选择敏感，以及在处理大规模数据集时可能需要较长的训练时间。
练习题 对已标注出垃圾邮件和正常邮件的csv文件实现支持向量机算法分类。
Python代码与分析 前6步骤和我们在朴素贝叶斯分类算法介绍的过程一样，主要是数据处理部分。为了分析的完整性，我们将前6步骤再展示一遍。
1、加载必要的Python库。
此时要导入的是sklearn.svm库中的SVC类。
import pandas as pd from sklearn.model_selection import train_test_split from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.svm import SVC # 导入支持向量机的类 from sklearn import metrics from sklearn.metrics import classification_report, confusion_matrix import matplotlib.pyplot as plt 2、读取csv文件，把csv文件读入到一个pandas的DataFrame对象里。
然后对数据里面的NULL值，用空字符串（即''）代替。
df1 = pd.read_csv('spamham.csv') df = df1.where(pd.notnull(df1)) df.head() # 查看数据前5行 3、对Category列进行变换，将取值ham和spam分别改成1或者0，以便进行后续机器学习的训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f45b917d3325cc7d0ca22d4ca4bb702c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b095479cdb82ebe2b12f5983aa2122d7/" rel="bookmark">
			【Spring Boot】Spring Boot解决循环依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 循环依赖一、前言二、Bean的创建过程三、 循环依赖检测机制3.1 实例化阶段3.2 属性填充阶段3.3 依赖注入 循环依赖 一、前言 环依赖是指两个或者多个bean互相依赖对方，从而形成一个闭环。例如：Bean A依赖于Bean B，而Bean B又依赖于Bean A。可能会导致Spring在尝试创建这些bean实例时出现问题，因为他们互相等待对方被创建，最终导致应用程序无法启动。
Spring是如何发现这种循环依赖的问题的呢？
通过依赖图来检测和发现循环依赖问题。如下步骤：
二、Bean的创建过程 Spring容器在启动时，会扫描配置文件（appliactionContext.xml）或者注解定义的bean，并且尝试创建这些bean的实例。创建bean实例的过程如下
实例化：创建bean的实例。属性填充：为bean注入依赖其他的bean。初始化：执行自定义的初始化方法。依赖注入过程 在属性填充阶段，Spring会为每个bean注入他所依赖的bean。在这个过程中，Spring会跟踪哪些bean正在被创建，以便检测循环依赖。
三、 循环依赖检测机制 Spring通过一个名为“DefaultSingletonBeanRegistry”的类来跟踪单例bean的创建状态。该类维护了三个主要的缓存来管理bean的创建过程。
singletonObjects：一级缓存（存储完全初始化好的bean）earlySingletonObjects：二级缓存（存储早期暴露的单例bean，用于解决循环依赖）singletonFactories：三级缓存（存储用于创建bean实例的工厂） 具体的检测步骤
3.1 实例化阶段 当Spring开始实例化一个bean时，它会将这个bean标记为正在创建。这一步是通过将bean名称添加到一个“正在创建中的bean”集合（‘singletonCurrentlyInCreaontion’）中来实现的。
3.2 属性填充阶段 在属性填充阶段，Sping会为该bean注入其依赖的其他的bean。此时Spring会检查这个“其他的bean”是否已经在创建过程中。
如果依赖的bean已经在创建中，Spring会检测到循环依赖，并根据不同的注入方式采取不同的处理方式。
如果是构造函数注入，Spring会抛出‘BeanCurrentlyInCreationException’,因为无法解决构造函数中注入的循环依赖。
如果是Setter注入，Spring会从‘earlySingletonObjects’或‘singletonFactories’中获取依赖的bean，提前暴露一个部分创建的bean引用来解决循环依赖。
举例：
如Bean A和Bean B循环依赖
@Component public class A { @Autowired private B b; public A() { System.out.println("A is created"); } } @Component public class B { @Autowired private A a; public B() { System.out.println("B is created"); } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b095479cdb82ebe2b12f5983aa2122d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cbe88433569269e76432c7dc4c95957/" rel="bookmark">
			【Java】解决线程本地变量导致的缓存问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、基本逻辑三、测试代码四、解决锁问题五、 解决ThreadLocal问题 一、前言 前些时间看别人写的一段关于锁的（对象缓存+线程本地变量）的一段代码，这段代码大致描述了这么一个功能：
外部传入一个key，需要根据这个key去全局变量里面找是否存在，如有有则表示有人对这个key加锁了，往下就不执行具体业务代码，同时，同时哦 还要判断这个key是不是当前线程持有的，如果不是当前线程持有的也不能往下执行业务代码～
然后哦 还要在业务代码执行完成后释放这个key锁，也就是要从 ThreadLocal 里面移除这个key。
当然需求不仅于此，就是业务的特殊性需要 ThreadLocal 同时持有多个不同的key，这就表明 ThreadLocal 的泛型肯定是个List或Set。
然后再说下代码，为了演示问题代码写的比较简略，以下我再一一说明可能存在的问题🎈
二、基本逻辑 功能大致包含两个函数:
lock : 主要是查找公共缓存还有线程本地变量是否包含传入的指定key，若无则尝试写入全局变量及 ThreadLocal 并返回true以示获取到锁
release ： 业务逻辑处理完成后调用此，此函数内主要是做全局缓存以及 ThreadLocal 内的key的移除并返回状态(true/false)
contains : 公共方法，供以上两个方法使用，逻辑：判断全局变量或 ThreadLocal 里面有否有指定的key，此方法用 private 修饰
好了，准备看代码 😂
代码如下：
public class CacheObjectLock { // 全局对象缓存 private static List&lt;Object&gt; GLOBAL_CACHE = new ArrayList&lt;Object&gt;(8); // 线程本地变量 private static ThreadLocal&lt;List&lt;Object&gt;&gt; THREAD_CACHE = new ThreadLocal&lt;List&lt;Object&gt;&gt;(); // 尝试加锁 public synchronized boolean lock(Object obj){ if(this.contains(obj)){ return false; } List al = null; if((al=THREAD_CACHE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cbe88433569269e76432c7dc4c95957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf2aa9f34c9f0cd036597e968d90b91/" rel="bookmark">
			提前批测开三面，已OC！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是洋子
近期百度提前批已经开始有一段时间了，甚至已经有不少 25 届的同学 oc 了，这里分享一位已经顺利 oc 百度提前批测开岗位同学的三轮面试面经
整个三轮技术面试总体难度不高，但考察知识广度比较广，如果有觉得后端竞争比较激烈的同学，也可以试一试测开岗位，选择大于努力，结合自身情况趋利避害选择最适合自己的并不是什么丢脸的事，找到工作才是最重要的
面经链接：https://www.nowcoder.com/feed/main/detail/0550f6a83d424223a8a7c41c0335b758
作者：哈球池扶手包包
7.10 投递简历
7.12 电话一面 20min 为什么转码呀，当时怎么考虑的？有哪些offer了？测开方面了解哪些内容呀？现在有个招聘系统，它只有接口没有页面，对添加候选人模块设计一个测试用例？（这问题答的一般，没回答到点上）测试用例设计方法有哪些？其实刚才第3个问题问的是纯粹的接口，可以用jemter进行测试吗？那用jemter怎么进行操作呢？断言需要断言哪些内容？MySQL的事务特性？ACID4个隔离性解决了什么问题？（好像答错了，答4个隔离级别解决的问题了，复盘才听到…）MySQL的默认隔离级别是什么？ 7.17 二面 60min 自我介绍Redis持久化Redis用于什么场景？业务里加了Redis，然后怎么对其中的一些数据点进行测试？输入URL从键入到显示发生了什么？对网页当中的错误，怎么区分是前端还是后端的？可以用什么工具区分？Linux命令了解过吗？查看Nginx错误日志的linux命令？筛选包含500这种错误关键字的命令？SQL语句，学生表、成绩表，查出三年级里英语成绩第三的人的学生名和英语成绩？SQL语句再简化一下算法手撕：两个栈实现一个队列对接口测试的了解？有哪些测试工具了解过吗？反问 7.19 三面 45min 自我介绍一个web网页的页面展示错误了，如何定位是前端代码还是服务端代码的问题（二面问过了，又问了一次）如果是后端的问题，怎么判断是哪个后端哪个模块呢？场景：一个推荐接口，类似于手机百度和小红书，它们都有个推荐列表，这个推荐列表会根据用户的历史访问信息，比如他可能比较喜欢访问历史、娱乐类的信息，会为他推荐感兴趣的内容。为这个推荐接口设计一个测试用例。你刚刚说用户历史访问数据为空，应该返回什么？（前面测试用例说了7个case，说太多我有点忘了，后面看录音是第二个case，所以这里卡了一段时间…后面还是回答上了，说我答得有点不自信…难绷）测试行业里“线上问题”的定义是什么？如果遇到线上问题，完整的处理流程是怎么样的？逻辑思维题：3个封闭箱子，分别是全为苹果、全为橙子、苹果和橙子混装，标签贴的都是错的。现打开其中一个箱子，拿出一个水果。能否根据选择的这一个箱子拿出来的水果，来为3个箱子贴上正确的标签？回到刚刚的测试用例，你说的多样性是什么？（我直接蒙了，我感觉我没说过啊…我看录屏发现不是我说的那7个case里的，就是最后提了一嘴，我说除了这7个主要的case，别的可能还包括异常情况处理、接口规范检查、用户体验测试这样，我在用户体验测试这里随口说了一句：从用户的角度出发检查一下推荐内容的多样性。…又是多嘴引发的问题…所以这个问题我直接就卡住了哈哈哈）
所以这个问题我胡乱答了，当时真记不住了，我一直以为说的是用户体验层面，其实后来我觉得应该想问的推荐内容的多样性怎么保证？比如说推荐内容类型、主题、推荐内容的更新频率、推荐内容的时效性这些角度。这个问题答得稀烂哈哈哈你的优点和缺点是什么？实习时长多久？你对转正的需求的程度是怎么样的呢？反问 7.22 电话oc，最迟24号前可收到offer
7.23 offer
面试分析 接下来洋子带大家看几道面试题目，整场面试八股文部分偏简单，面试题答案在学习圈子里面已经覆盖，想要获取测开高频面试题答案，欢迎加入我的学习圈子
我这里选择3道比较有价值的面试题目：
网页报错，前后端Bug如何定位线上问题的定义和处理流程测试场景题：设计推荐信息接口的测试用例 第一道：网页报错了如何定位是前端还是后端问题 这个问题之前写了一篇文章来分析解答《这到底是前端Bug还是后端Bug》，问题答案参考这篇文章即可。这个面试官还追问了一下，如果是后端的问题，怎么判断是哪个后端哪个模块？
现在互联网大厂普遍采用的是微服务架构，要精准定位到问题出现在后端的哪个模块上面，需要结合基建来看
如果是后端日志打印比较规范，可以直接通过log id结合日志trace平台或者登录对应线上机器进行查看warning log报错信息定位分析，有的日志能还能记录接口的调用链信息，通过调用链能知道对应的模块
如果日志打印不规范，则很难直接通过日志得出问题的服务在哪个模块，这个时候我们可以通过结合日志信息以及看具体的后端代码逻辑进行定位出问题的模块
另外，如果业务建设了线上系统监控，还可以使用监控工具（如Prometheus、Grafana等）查看系统性能指标，是否有某个模块出现了异常的CPU、内存或响应时间。结合告警系统，设置关键指标的阈值，当超出阈值时会触发告警，这样可以迅速识别出问题模块
第二道：线上问题的定义和处理流程 线上问题的定义简单来说，影响功能，用户体验的问题等都可归结为线上问题，详细定义如下
在互联网产品研发、运维、迭代及服务提供的全过程中，由于技术缺陷、流程不畅、资源配置不当、系统设计不合理或外部因素干扰等原因，导致的阻碍产品功能实现、用户体验下降、服务效率减低、安全性受损或业务目标受阻的一系列问题。
这些问题涵盖了从软件开发的前端、后端、数据处理、系统架构到运维管理、用户体验、市场适应性等多个层面，需要通过系统化的管理和技术手段，包括但不限于敏捷开发、持续集成与交付(CI/CD)、自动化测试、DevOps文化、项目管理工具的应用、以及细致的用户反馈循环机制等，进行预防、识别、分析和解决，以保障互联网产品与服务的高质量持续发展
至于线上问题的处理流程，在大厂一般都有线上问题处理规范以及线上问题定级标准，发生线上问题后，并不是先去定位问题的原因，第一时间一定是先想办法止损，特别是出现资损的时候，先解决问题再去定位原因
止损后再定位问题原因，定位原因后进行排期修复（这里一般指长期的修复方案，不是短期的止损手段），测试通过后重新上线（服务端Bug）或者发版（客户端Bug）
最后进行Case Study复盘，避免再出现相同线上问题
第三道：场景题–设计推荐信息接口的测试用例 这道题目挺有意思的，咱们来分析一下，首先设计接口测试用例一般从接口的功能（入参、返回值）考虑，被测接口如果涉及高并发场景，需要考虑进行性能测试，若涉及敏感数据传输，还需要进行安全测试
但这道题赋予了一个具体的业务场景，这是一个推荐接口，类似于手机百度和小红书，它们都有个推荐列表，这个推荐列表会根据用户的历史访问信息，比如他可能比较喜欢访问历史、娱乐类的信息，会为他推荐感兴趣的内容
那我们回答就需要结合业务场景去回答，否则答案就会显得很空，这道题也可以进行举一反三，个性化推荐大家也许并不陌生，像刷抖音短视频，淘宝的购物列表，小红书展示内容，背后都涉及推荐算法
测试用例 1：推荐内容的准确性 测试目标：验证推荐内容是否符合用户的历史访问偏好。前置条件：
用户A有明确的内容偏好，频繁访问历史类文章。
用户B喜欢娱乐和科技类内容。测试步骤：
登录用户A，调用推荐接口。
检查返回的推荐列表，记录推荐的内容类别。
登录用户B，调用推荐接口。
检查返回的推荐列表，记录推荐的内容类别。预期结果：
用户A的推荐内容应主要集中在历史类。
用户B的推荐内容应包含娱乐和科技类内容。 测试用例 2：推荐接口的响应时间（性能测试） 测试目标：验证推荐接口在不同并发条件下的响应时间是否在合理范围内。前置条件：正常网络环境。测试步骤：
单次调用推荐接口，记录响应时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf2aa9f34c9f0cd036597e968d90b91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd67aafaf4ea0eab14f96ba700f40f3/" rel="bookmark">
			【C&#43;&#43;高阶】：C&#43;&#43;11的深度解析下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 彼方尚有荣光在，何须悲叹少年轻 🌏
📃个人主页：island1314
🔥个人专栏：C++学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
🚀前言 若没有了解C++11前面一部分知识的读者朋友们，可以看一下这篇文章：
【C++高阶】：C++11的深度解析上-CSDN博客
1、可变参数模板 1.1 概念 C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比C++98，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。
可变模版参数参数类型可变参数个数可变打印参数包内容 下面就是一个基本可变参数的函数模板：
// Args是一个模板参数包，args是一个函数形参参数包 // 声明一个参数包Args...args，这个参数包中可以包含0到任意个模板参数。 //参数类型可变，参数个数可变 template &lt;class ...Args&gt; void ShowList(Args... args) {} //以前的模板写法，固定了参数个数，类型不确定 template &lt;class ...T&gt; void ShowList1(T... x) {} //对于Show调用 int main(){ ShowList(); ShowList(1); ShowList(1, "xxxxx"); } 其对sizeof的使用方法（不常见）
template &lt;class ...Args&gt; void ShowList(Args... args){ // 可变参数模版编译时解析 // 下面是运行获取和解析，所以不支持这样用 cout &lt;&lt; sizeof...(args) &lt;&lt; endl; for (size_t i = 0; i &lt; sizeof.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd67aafaf4ea0eab14f96ba700f40f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b7b23d0e78429ede68c6f443e5733a/" rel="bookmark">
			C语言 数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数组初始化
数组越界
数组作为函数参数
数组初始化 数组的初始化：数组分一维二维等都需要对相应的数组进行初始化，在创建数组的同时给数组的内容一些合理初始值（初始化）。
数组在创建的时候如果想不指定数组的确定的大小就得初始化。数组的元素个数根据初始化的内容来确定。 数组是使用下标来访问的，下标从0开始。
数组的元素个数需根据初始化内容来确定，且数组通过找'\0'作为结束的标志。例：对于arr1来说：因为内存是连续的，abc后面的字符是随机值直到遇见'\0'则结束，所以abc后面跟着一堆的随机值。对arr2来看：双引号代表字符串，字符末尾自带'\0'。
数组大小可以用sizeof计算，int整型占4个字节。在一维二维数组中内存存储数组是连续存放的，且地址随数组下标的增长而增长（低—&gt;高）。
数组越界 数组下标有范围限制的，n个数组元素的话从0开始且最后一个下标是n-1 ，当不在这个范围（0—n-1）就属于数组越界访问超出数组合法空间，在这过程中编译器可能不会报错需要自己做好检查。
数组作为函数参数 数组名是首元素的地址，有两个例外：一是sizeof求数组名时则代表的是整个数组；二是&amp;数组名也代表整个数组 ；除了这两种情况外，数组名表示都是首元素的意思。
接着下面讲函数参数：
对比下面发现数组传参与变量传参不同，想要改变变量的值需要将变量地址传入通过地址找到变量并改变变量。然而数组传参不一样的就是传入数组名即首元素地址，知道首元素就可以找到数组其他元素。
下面这两张图比较：不用指针是为了让还没学懂指针的同学们更清楚了解数组，其实将鼠标放置在函数上可以发现本身就是指针，数组和临时变量的区别就体现出来了。数组传参不需要指针就可以改变元素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b3e1b912f050b6b3e45a7ef213d859/" rel="bookmark">
			排序算法：堆排序，golang实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
堆排序
代码示例
1. 算法包
2. 堆排序代码
3. 模拟程序
4. 运行程序
5. 从大到小排序
堆排序的思想
堆排序的实现逻辑
1. 构建最大堆
2. 排序
循环次数测试
假如 10 条数据进行排序
假如 20 条数据进行排序
假如 30 条数据进行排序
假设 5000 条数据，对比 冒泡、选择、插入、快速、归并
堆排序的适用场景
1. 大数据集排序
2. 外部排序
3. 优先级队列
4. 动态数据排序
前言 在实际场景中，选择合适的排序算法对于提高程序的效率和性能至关重要，本节课主要讲解"堆排序"的适用场景及代码实现。
堆排序 堆排序（Heap Sort）是一种基于比较的排序算法，它利用堆这种数据结构所设计。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。在堆排序算法中，我们通常采用最大堆（每个父节点的值都大于或等于其子节点的值）来进行排序。
代码示例 下面我们使用Go语言实现一个堆排序
1. 算法包 创建一个 pkg/algorithm.go
touch pkg/algorithm.go （如果看过上节课的快速排序，则已存在该文件，我们就不需要再创建了）
2. 堆排序代码 打开 pkg/algorithm.go 文件，代码如下
从小到大 排序
package pkg // BubbleSort 冒泡排序 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b3e1b912f050b6b3e45a7ef213d859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588f3f26160ec0b08902e4b5ed742e2f/" rel="bookmark">
			使用langchain4j调用大模型写个聊天助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LangChain4j是一款基于Java的高效、灵活的AI大模型应用框架，专为简化Java应用程序与LLMs（大语言模型）的集成而设计。它提供统一API和模块化设计，支持多种LLM提供商和嵌入模型，以及丰富的工具箱，如AI服务和RAG（检索增强生成）。LangChain4j通过简化集成过程，降低开发成本，助力开发者快速构建和部署AI应用。langchain4j还提供了openAI部分接口免费测试的能力，可以在没有key的情况下学习使用大模型。
UI代码在文末
1、导入相关包 &lt;!-- openai包 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-open-ai&lt;/artifactId&gt; &lt;version&gt;0.32.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 高级工具包，如ai service --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j&lt;/artifactId&gt; &lt;version&gt;0.32.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.tinylog&lt;/groupId&gt; &lt;artifactId&gt;tinylog-impl&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.tinylog&lt;/groupId&gt; &lt;artifactId&gt;slf4j-tinylog&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; langchain4j是一个还在完善的库，最新版本请查看官网： Get Started | LangChain4j
jdk版本最好使用17，因为它还有一个基于 Spring Boot 3.2 版本，它最低支持jdk17
2、helloword入门 import dev.langchain4j.model.chat.ChatLanguageModel; import dev.langchain4j.model.openai.OpenAiChatModel; .... public static void main(String[] args) { ChatLanguageModel model = OpenAiChatModel.withApiKey("demo"); String answer = model.generate("你是谁"); System.out.println("answer:" + answer); } 控制台会输出：
answer:我是一个智能助手，可以回答您的问题并提供帮助。您有什么需要我帮忙的吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588f3f26160ec0b08902e4b5ed742e2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e032d9607747aa816b18ee2c426b7169/" rel="bookmark">
			银河麒麟桌面操作系统V10 SP1 x86_x64架构 断网离线安装Java8/Mysql5.7/Tomcat8/nginx/php/node.js 图文详解版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、系统环境准备1.更改登录账户，获取最高权限root账户，并用root登录系统。1.1 修改root账户密码1.2 修改“95-ukui-greeter.conf” 配置文件1.3 修改“ .profile ” 配置文件1.4 重启系统并使用root登录 二、软件包安装1.Java安装1.1 检查当前系统是否有安装jdk（java）1.2 解压java安装包至桌面，移动解压文件至 “ /usr/local/ ” 中，并改名为 java 。1.3 编辑环境变量配置文件。1.4 测试，确认java安装完成。 2.Mysql安装2.1 创建mysql用户、mysql用户组2.2 解压mysql安装包并移动至 “ /usr/local/ ”下。2.3 创建data数据文件夹，并更改mysql文件夹权属。2.4 创建socket链接文件夹，并更改权属2.5 在 “ /etc/ ” 下创建mysql配置文件my.cnf2.6 安装mysql2.7 设置mysql服务2.8 添加mysql命令到环境变量2.9 查看mysql初始密码，并用root用户尝试登录。2.10 修改mysql初始密码，并添加远程访问权限。 3.Tomcat安装3.1 解压tomcat安装包3.2 移动解压包至“/usr/local/java/”下，并改名为tomcat83.3 进入tomcat8下的bin目录，启动tomcat3.4 测试tomcat3.5 tomcat端口号更改3.6 tomcat服务设置开机自启 4.nginx、php、node.js安装4.1 给安装包添加可执行权限4.2 右键打开安装包，打开deb包安装器。点击安装，等待安装完成即可。4.3 验证nginx4.4 php、node.js安装方式同nginx一样，安装集成包即可。4.5 node.js可能出现的错误。4.6 nginx、php配置文件地址 三、安装包下载地址总结 前言 本文详细描述了银河麒麟桌面操作系统V10 SP1， 六大常用开发环境软件Java 、Mysql 、Tomcat 、nginx 、 php 、 node.js离线安装的步骤。
其中，Java、Mysql、Tomcat采用常规命令行离线安装，nginx、php、node.js已经分别打包为一键安装包，可直接右键安装。
因芯片架构不同，本安装手册仅适用于X86_X64芯片架构参考安装。
arm64架构请参考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e032d9607747aa816b18ee2c426b7169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28abeddda358f7d693a4985be4c355db/" rel="bookmark">
			ONLYOFFICE8.0部署集成(vue&#43;java)并配置存储为minio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、使用docker安装onlyoffice8安装使用DockerDesktop方式命令行方式使用 HTTPS 运行展示 二、项目集成前端集成-vue3html方式后端集成-java 三、onlyoffice基础原理四、配置存储为minio1.onlyoffice配置文件挂载问题2.配置存储为minio3.验证切换minio存储是否生效1.测试方式一2.测试方式二 前言 之前也写过一个关于onlyoffice的文章，在上一篇中介绍了onlyoffice7.2版本的安装、简单的集成、和社区版、企业版、开发者版本的差异。
文章地址：https://blog.csdn.net/qq_43548590/article/details/129948103
本次则记录onlyoffice8.1.0基础环境搭建+Java+Vue3的集成使用
一、使用docker安装onlyoffice8安装 我这里使用的是443端口为演示，不想弄证书的可以映射80端口。如果是80端口则不要放置证书否则会出问题！
官网地址
使用DockerDesktop方式 1.首先我们拉取docker镜像
2.等着镜像拉取完成，我们来启动它，点击右边的启动按钮
宿主机的目录或文件挂载到 Docker
我这里的挂载地址为
/Users/mac/Desktop/tools/docker/onlyoffice/documentServer/xxxx这里根据自己的地址选择
命令行方式 docker run -i -t -d -p 10086:80 --name=test-onlyoffice-8.0 --restart=always --privileged=true -v /Users/mac/Desktop/tools/docker/onlyoffice/documentServer/logs:/var/log/onlyoffice -v /Users/mac/Desktop/tools/docker/onlyoffice/documentServer/data:/var/www/onlyoffice/Data -v /Users/mac/Desktop/tools/docker/onlyoffice/documentServer/postgresql:/var/lib/postgresql -v /Users/mac/Desktop/tools/docker/onlyoffice/documentServer/lib:/var/lib/onlyoffice -e JWT_ENABLED=false onlyoffice/documentserver:8.0 10086端口是访问端口，10087端口是info端口，查看方式为http协议（http://ip:10087/info）
关于镜像的相关信息自行查看
使用 HTTPS 运行 可以使用 SSL 保护对 onlyoffice 应用程序的访问，以防止未经授权的访问。虽然 CA 认证的 SSL 证书允许通过 CA 验证信任，但自签名证书也可以提供同等级别的信任验证，只要每个客户端采取一些额外步骤来验证您网站的身份。
sudo docker run -i -t -d -p 443:443 --restart=always \ -v /app/onlyoffice/DocumentServer/data:/var/www/onlyoffice/Data -e JWT_ENABLED=false onlyoffice/documentserver 要通过 SSL 保护应用程序的安全，基本上需要做两件事：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28abeddda358f7d693a4985be4c355db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d080d32feba5b33e06641b94e16d2289/" rel="bookmark">
			人工智能会越来越闭源——对话东北大学副教授王言治 | Open AGI Forum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | Annie Xu
责编、采访 | Echo Tang
出品丨GOSIM 开源创新汇
在读期间研究方向为并不“火”的模式识别与深度学习，毕业却刚好踩上人工智能计算研究的风口……来自美国东北大学的王言治副教授深耕深度学习与大模型，前瞻性地探索大模型的本地化部署，打造可供用户个人大模型运行的本地化平台。
在风景宜人的荷兰代尔夫特小镇，GOSIM 独家对话栏目 Open AGI Forum 特别邀请到王言治教授，为我们带来了他的真知灼见。
王教授在专访中为我们分享了他的职业生涯以及他对开源与人工智能发展的精彩观点：
大模型在云端服务的提供与用户实际需求之间存在鸿沟。如何实现大模型和用户自定义大模型的匹配，实现用户数据的本地化部署、本地化训练、本地化微调是我们目前的研究重点。
手机端能否运行大模型取决于手机内存的大小。千元级别的手机运行如 Stable Diffusion 这样的大模型是没有问题的。内存的管理与分配是其中的痛点，需要编译的不断调试和优化。
评 TVM 和 Llama.cpp：TVM 是传统上非常标准的编译，但它们并不适合大模型，它在小模型的可扩展性方面存在一些问题。而 Llama.cpp 属于异军突起，编译效果比较好。
人工智能的趋势是越来越闭源的，然而开源所面临的危机并不仅仅在模型侧，大模型的差距还是小的，在其他具体应用方面，闭源的效果是远远强于开源的，这个差距比大模型要大得多。
视频生成在国内外都被认为是AIGC的“高地”，但当前所生成的视频时间比较有限，且不够连贯，在生成娱乐或者生成非常短的视频上比较有用，我暂时还不看好它的商业前景。
其他架构对 Transformer 不构成挑战，学术界也非常清楚这一点。
在美国，工业界是领先于学术界的，几个里程碑的进展都是由工业界实现的。
以下是本次采访的主要内容：
模型本地化部署是发展的必然趋势？ GOSIM：大家好，欢迎来到 Open AGI Forum！我是来自 CSDN 的 Echo Tang。今天我们很荣幸地邀请到了东北大学王言治副教授，请王教授给大家打声招呼，简单介绍一下自己。
王言治：大家好，我主要的研究方向是深度学习与大模型。我们主要研究大模型如何在本地进行有效部署，包括模型的压缩和对应模型的编译。我们认为现在云端的大模型很难完全满足用户需求，但未来，用户个人大模型也可以在本地端进行有效部署。
GOSIM：首先请王教授分享一下您是如何走上人工智能之路的？为什么会选择深度学习与大模型作为研究方向，您是看到了哪些问题与痛点？
王言治：我在本科时的研究就是这个方向。当时还没有深度学习，还是“模式识别”，“大模型”并不火。读博的时候，研究这个方向的老师也非常少，所以我们当时主要研究的是计算。我的导师想让我们运用人工智能解决计算方面的一些问题，主要研究强化学习（Reinforcement Learning）。
随后，神经网络、深度学习发展起来了。我毕业后想研究用人工智能解决计算方面存在的问题，但我发现人工智能本身的计算也是一个问题，所以我就转为研究这个方向了。其实我们并不是研究人工智能最早的一波人，也是被人工智能带动起来的，但是我们所做的事情现来回过头来看，算是比较重要的。
GOSIM：您当前正在集中精力做哪些事情，这些事情因何而重要？
王言治：我们目前主要研究的是视频生成、图像生成，以及大模型的本地化部署。我们进行这项研究的原因是：第一，不同模型以后都会使用自己的数据，每个用户也都可能拥有自己的应用和个人大模型。第二，现在国外的一些网站已经有逐渐成型的社区。大家都会用不同的基础模型、不同的 checkpoint、不同的微调模型等等，所涉及的模型可能有几千、几万个。
然而真正对这些模型有使用需求的人不太可能在云端使用。另外，能够在云端运转的模型数量也不多，可能只有10到20个。我们发现，云端模型所提供的服务与用户的实际需求之间存在一个较大的鸿沟。我们想要弥补这个鸿沟，所以目前的主要工作是让大模型和用户自定义的大模型相适配，实现用户数据的本地化部署、训练、微调，从而减少用户的开销，满足用户的实际需求。
GOSIM：您可以展开讲讲您目前主要的研究项目 Ominix 吗？
王言治：Ominix 项目是实现大模型定义的统一化。假设我们要实现 Stable Diffusion、大语言模型，或者 Sora 等视频生成模型，底层需要哪些基础算子呢？我们将所涉及到的算子定义清楚，从而构建起一个算子库。在支持算子库前端的情况下，我们就可以运转各种各样的大模型。同时，我们优化了后端在不同平台上的性能。我们可以在 Mac、高通、英特尔、英伟达等不同平台之间，实现跨平台的最高性能。
基于这套系统，对给定的任何一个基于 Transformer 所构建的大模型，用户可以在对应平台上加载后直接运转。可以立即输出一个类似于 GPT 的 API ，并直接与其进行交互。也就是说，我们不用非常复杂的编译或者经历繁复的云端的过程，用户下载模型后可以立即运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d080d32feba5b33e06641b94e16d2289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90fac6ccb4c466434a3af227916c09c7/" rel="bookmark">
			Hive中分区（Partition）和分桶（Bucket）区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Hive中，分区（Partition）和分桶（Bucket）是两种不同的数据组织方式，它们有各自的特点和适用场景：
目录
1. 分区（Partition）：
2. 分桶（Bucket）：
3.区别总结：
1. 分区（Partition）： 定义：分区是基于数据集中的某个列（通常是一个或多个列）进行分割，使得数据能够以子目录的形式存储在文件系统中。这些子目录对应于分区列的不同取值。
作用：通过分区，可以将数据物理上组织成更易管理和查询的单元。当查询中包含分区列的筛选条件时，Hive 可以仅仅扫描与查询条件匹配的分区，从而提高查询效率。
例子：假设有一个表按照日期分区存储，如 `year=2023/month=01/`，`year=2023/month=02/` 等，这样查询特定年份或月份的数据时，可以避免扫描整个表，而是只需访问相应的分区目录。
2. 分桶（Bucket）： 定义：分桶是在数据加载时根据某列的哈希值进行数据划分，将数据均匀地分散到指定数量的桶中。
作用：分桶可以在表中创建固定数量的桶，数据会被分发到这些桶中。当查询时，Hive 可以通过桶的映射关系迅速定位到特定的桶，从而提高数据查询的效率。
例子：如果一个表按照用户ID进行了100个分桶，当你执行查询时，Hive会根据用户ID的哈希值定位到具体的桶，只需在少量桶中查找数据，而不是整个表。
3.区别总结： 存储结构：分区是通过文件系统的目录来组织数据；分桶是通过哈希函数将数据分散到指定数量的桶中。
查询优化：分区适用于按特定列过滤的查询优化；分桶适用于均匀分布数据，提高等值连接和抽样查询的性能。
使用场景：分区适合于按照常用查询条件（如时间、地区等）分割数据；分桶适合于均匀分布数据以提升查询性能。
在实际应用中，有时候也会同时使用分区和分桶，以达到更好的查询性能优化效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c0f6151212446d47f881f46402341c/" rel="bookmark">
			【TS】TypeScript类型断言：掌握类型转换的艺术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 TypeScript类型断言：掌握类型转换的艺术1. 引言2. 什么是类型断言？3. 类型断言的基本语法3.1 尖括号语法3.2 as语法 4. 类型断言的常见用途4.1 处理any类型4.2 处理联合类型4.3 在类型收窄中使用 5. 双重断言6. const断言7. 非空断言8. 类型断言与类型转换的区别9. 类型断言的最佳实践10. 类型断言的潜在风险11. 高级用例：类型断言在泛型中的应用12. 类型断言与接口13. 实际应用示例14. 结论 TypeScript类型断言：掌握类型转换的艺术 1. 引言 在TypeScript的类型系统中，类型断言是一个强大而有用的特性。它允许开发者告诉编译器某个值的具体类型，即使TypeScript无法自动推断出这个类型。本文将深入探讨TypeScript中的类型断言，包括其定义、使用方法、最佳实践以及注意事项，帮助您更好地理解和应用这一重要概念。
2. 什么是类型断言？ 类型断言是一种告诉编译器"相信我，我知道我在做什么"的方式。它类似于其他语言中的类型转换，但不进行特殊的数据检查和重构。类型断言纯粹是一个编译时语法，不会影响程序的运行时行为。
3. 类型断言的基本语法 TypeScript提供了两种语法来进行类型断言：
3.1 尖括号语法 let someValue: any = "this is a string"; let strLength: number = (&lt;string&gt;someValue).length; 3.2 as语法 let someValue: any = "this is a string"; let strLength: number = (someValue as string).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3c0f6151212446d47f881f46402341c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/93/">«</a>
	<span class="pagination__item pagination__item--current">94/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/95/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>