<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a40d7e0e9d734c9328f9edbde2120a1/" rel="bookmark">
			安卓 onActivityResult 废弃，registerForActivityResult 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 onActivityResult 存在的问题registerForActivityResult 有哪些改进registerForActivityResult 实战registerForActivityResult 自定义使用registerForActivityResult 开箱即用StartActivityForResultGetContent 后记注意事项附录 安卓的兼容性是出了名的低，原因就在于它经常喜欢出一个版本就换一个 API。终于，连 Activity 之间数据回传的方法 onActivityResult 也废弃了。安卓官方给出的解决方案是使用 registerForActivityResult 来代替 onActivityResult。
registerForActivityResult 的使用流程比原先的 onActivityResult 要复杂很多，但理解了之后，发现这种新的方式确实更优雅。
为了能让读者理解，这里先回顾原来 onActivityResult 的使用方式，然后再来对比讲解 registerForActivityResult。
onActivityResult 存在的问题 为了便于说明，这里假设 活动 A 调用了 活动 B，然后活动 B 生命结束，将结果回传至活动 A。
在这个过程中，A 需要在调用时向 B 传递一个 请求码，这样在 B 返回时就会自动携带那个请求码。同时 B 需要提供一个 返回码，来代表 B 中返回的具体数据 Intent 作一个分类。
活动 A Intent intent = new Intent(AActivity.this, BActivity.class); startActivityForResult(intent, requestCode); @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a40d7e0e9d734c9328f9edbde2120a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf213fb9d179646dc9ee8aea5e78a9c9/" rel="bookmark">
			Questflow借助MongoDB Atlas以AI重新定义未来工作方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB客户案例导读 Questflow借助MongoDB Atlas赋能AI员工，助力中小型初创企业自动化工作流程，简化数据分析，提升客户体验，推动AI与员工的协作，重新定义未来工作方式。
协作式AI自动化平台 无需编码即可拥有自己的AI员工 在Questflow首席执行官许博约（Bob Xu）看来，人类的工作方式正在发生着天翻地覆的变化。过去以人为主，未来将是人与AI共生，甚至出现1+N的情况，即1个人类员工与多个AI员工。大量的工作将会安排给AI员工自动化完成，人类员工则负责必要的衔接、审批、复核等工作。
Questflow是一家由奇绩创坛投资的专注于多AI智能体调度的初创公司，搭建了一个去中心化的自动化AI智能体网络，通过分发真实世界的需求和激励给到多个AI智能体来完成任务。与注重传统机器人自动化（RPA）的竞争对手相比，Questflow提供了全新的多AI智能体调度体系，允许人为介入工作流进行任务或交易的审批，打通新一代的工作流协作方式。
Questflow：去中心化AI智能体网络 Questflow目前主要面向资源有限、团队规模较小的中小型初创企业，让他们能够轻松拥有自己的AI员工，快速实现某些工作流程的自动化，如市场信息的收集与分析、新媒体内容的发布、邮件回复、会议记录与摘要等等，而无需自己开发一套自动化体系，在Questflow平台上就即可完成一系列智能工作和服务。
业务挑战 AI员工需要更个性化、动态化 数据支撑需要更灵活、更有效 AI时代，拥有AI员工已成为一个趋势。AI员工可以执行重复性、繁琐或需要大量数据处理的工作，如数据分析、客户服务、文档处理等，可以集成到网站、移动应用程序或消息应用程序等各种平台中，为用户提供实时帮助和支持。
而AI员工作为Questflow的主推产品，Questflow更多思考的是如何使AI员工不只是像真人一样灵活，而且要比真人还更加高效。这就要求实现以下三个方面：
● 每一个AI员工都应是动态延展的，而不是静态的。例如一个员工初到一个公司，可能拥有基本教育背景和对行业、公司的基本了解，但随着工作开展，他不断将自身知识储备与工作实践相结合，不断记忆与学习。AI员工更应如此。
● 每一个AI员工都应是个性化的，而不是整齐划一的。每一个团队都会自己去创建一些专属的AI员工，从零去搭建，就需要赋予每个AI员工以不同的记忆能力、不同的分析能力、协调能力等等。
● 每一个AI员工的工作路径都应是顺畅的，而不是卡顿的。Questflow最核心的业务是可以通过自然语言描述帮助AI员工自动化完成任务，但是在执行的过程中，需要有推理、理解、执行等多个环节。基于AI模型的限制或是数据分析的限制，目前各个环节之间衔接还不够顺畅。
AI员工越智能，就需要越强大的数据库软件作为背后的支撑。当今社会正在同时经历“非结构化数据”与“人工智能”两场变革，AI员工要想变得动态化、个性化以及其工作路径变得顺畅，都需要后台处理大量非结构化数据。各类人工智能技术为人们提供了理解非结构化数据的途径，也就是将文本、图像、音频等非结构化数据嵌入为向量表示，并存储在向量数据库中，以便进行快速的相似度搜索和数据分析。
面对更高的工作标准，Questflow采用MongoDB Atlas，并将其应用于其数据管理服务。
解决方案 简化数据分析和程序开发 开创客户体验服务新局面 MongoDB Atlas是一个开创性的开发者数据平台，集成了操作、分析和生成AI数据服务，简化了智能应用程序的开发。
Questflow联合创始人兼首席技术官储奎（Carney Chu）表示：“要重新定义未来的工作方式，首先要重新定义我们自己的工作方式，即以出色的数据存储和处理能力提升我们AI员工的工作能力。MongoDB的适配性很强，尤其MongoDB Atlas作为针对AI量身打造的数据库解决方案，与我们的业务方向高度契合。”
向量数据存储 Questflow的产品形态都是通过类似ChatGpt的对话方式，针对用户提出的问题，帮助自动化解决，后台需要做大量向量数据存储和处理的工作。将向量数据存储在MongoDB Atlas中，客户将在平台中利用Atlas向量搜索，进而提供高精度的GenAI内容。MongoDB可以从知识库嵌入的角度支持客户传统数据和支持向量数据。在这种情况下，客户可以在不需要开发人员任何努力的情况下就地进行混合搜索。
弹性扩容 虽然Questflow在初创阶段并未将数据库的升降级考虑进去，但当公司运营至2年左右，随着数据量的增加，MongoDB自动将其数据库进行了升级。MongoDB所具有的这种弹性扩容能力很适合Questflow这类初创公司，能够使开发人员专注于业务数据收集和分类服务，而无需为日常运维分配时间与精力。
云端部署 Questflow选择在亚马逊云科技云上用MongDB Atlas，以此实现开箱即用，点点按钮，通过后台配置一下即可。如果是本地部署，将要配备运维人员和一整套机器环境，所以，在成本控制、便捷程度、安全管理等方面，云端部署都具有明显的优势。
客户价值 为真正的人工智能合作打开大门 为突破性创新提供更多时间和资金 AI员工某种程度上就是用更少的资源实现更多的新工作方式。基于MongoDB Atlas的数据解决方案，Questflow已帮助多家中小初创企业的创新提供了更多“时间和资金”。
如AI思维导图公司iMindMap，通过Questflow实现了博客发布的自动化
开源VC数据库公司OpenVC，通过Questflow实现了抓取、筛选和更新数据的自动化
在谈及未来创想时，许博约（Bob Xu）谈到：希望可以尽快超越与AI对话的模式。例如，目前要创建一张海报，用户可以通过与AI聊天，让AI将海报创建完成，但后续的修改还需在其他平台上完成，用户体验被前后割裂。Questflow下一步要实现的就是可以多人对于AI产生的内容去进行协作修改、优化。
Questflow相信，人类工作者和人工智能工作者之间将会有更多的合作，并将为真正的人工智能合作打开大门，最重要的是，这种合作将为更多突破性创新提供时间和资金。
基于这一创想，Questflow也正在涉足为大中企业提供自动化服务，从日常邮件回复、社交媒体运营、市场营销等服务领域，朝着为客户提供更深入、更全面的系统性服务迈进。如正在接触的某家国际知名奢侈品牌。在现有的社交媒体运营中，该奢侈品牌往往是通过几百个不同社交账号进行新品的图文发布和客户维护，每一个社交账号背后都是一个真人在实际操作。在未来，Questflow完全可以为这类需求提供一整套的人工智能服务，即多名AI员工团队协作的自动化。
在AI服务与用户体验共同提升的同时，是数据库中数据量、数据复杂程度的几何式增长。在数据变得更为庞杂的过程中，Questflow期待与MongoDB之间建立起的是一种共同应对挑战、共同解决问题的关系。
客户证言 Questflow联合创始人兼首席执行官许博约（Bob Xu） “未来世界必定是一个人类与AI共生的世界。我们在努力让AI员工变得近在眼前而且能够不断学习和成长，早日实现人类员工在Questflow平台上的多人协作，共同对AI员工生成的内容或完成的工作进行修改或优化。这是我们的愿景，即重新定义一种未来的工作方式。”
Questflow联合创始人兼首席技术官储奎（Carney Chu） “早期创业公司一般都会面临人力、资金、人员梯度等方面的压力。通过MongoDB Atlas，我们能够在一个统一的平台中存储和管理文档和向量数据，而且无需考虑服务器和运维等因素。简化的逻辑处理管道降低了成本、提高了效率。作为一家初创公司，这是一个巨大的优势。”
MongoDB Atlas MongoDB Atlas 是 MongoDB 公司提供的 MongoDB 云服务，由 MongoDB 数据库的开发团队构建和运维，可以在亚马逊云科技、Microsoft Azure、Google Cloud Platform 云平台上轻松部署、运营和扩展。MongoDB Atlas 内建了 MongoDB 安全和运维最佳实践，可自动完成基础设施的部署、数据库的构建、高可用部署、数据的全球分发、备份等即费时又需要大量经验运维工作。让您通过简单的界面和 API 就可以完成这些工作，由此您可以将更多宝贵的时间花在构建您的应用上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0bafa7fdee54106bc92e71c1079f970/" rel="bookmark">
			Mysql 常用命令 详细大全【分步详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动和停止MySQL服务 // 暂停服务 默认 80 net stop mysql80 // 启动服务 net start mysql80 // 任意地方启动 mysql 客户端的连接 mysql -u root -p 2、输入密码 3、数据库 4、DDL（Data Definition Language ）数据 定义语言, 用来定义数据库对象(数据库, 表, 字段) 1、查询所有数据库
show databases; 2、 新建数据库
create database 库名； // 没有当前的数据库名的情况下创建 create if not exists database 库名; 3、查询当前数据库
select database(); 4、使用数据库
use 库名； 5、删除数据库
drop database 库名； 5、DDL 表结构 1、查询当前数据库所有的表 (如果没有创建表，我们可以先使用系统的表，然后载查询)
show tables; 2、创建表结构
2.1 创建之前先回到我们自己需要创建表格的库
2.2 创建表的结构
create table 表名( 字段1 字段1类型 [约束] [comment 字段1注释 ], 字段2 字段2类型 [约束] [comment 字段2注释 ], .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0bafa7fdee54106bc92e71c1079f970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0bc5cfc462bd1fe39b396d4f1f3c157/" rel="bookmark">
			基于Python&#43;FFMPEG环境下载B站歌曲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题主环境
WSL on Windows10
命令如下
# python3.9 pip install --pre yutto yutto --batch https://www.bilibili.com/video/BV168411o7Bh --audio-only ls | grep aac | xargs -I {} ffmpeg -i {} -acodec libmp3lame {}.mp3 WinAmp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccc72d88e44bdca326064745c76a0232/" rel="bookmark">
			docker 命令 port，stats，events，cp详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker常用命令教程-5
1. docker port 命令用途: docker port 用于查看容器的端口映射情况，即宿主机端口与容器内部端口之间的对应关系。
命令语法:
docker port CONTAINER [PRIVATE_PORT[/PROTO]] CONTAINER: 容器的ID或名称。[PRIVATE_PORT[/PROTO]]: 可选参数，指定想要查询的容器内部端口及协议（默认为TCP）。如果不指定，则显示容器的所有端口映射信息。 示例:
# 查询名为 web_server 的容器所有端口映射 docker port my-nginx # 查询名为 web_server 容器内部 8080 端口映射到宿主机的端口 docker port my-nginx 80 2. docker stats 命令用途: docker stats 用于显示容器的资源使用统计信息，包括CPU、内存、网络IO等。
命令语法:
docker stats [OPTIONS] [CONTAINER...] [OPTIONS]: 可选参数，目前主要有一个 -a, --all 选项，用于显示所有容器（包括未运行的容器）的统计信息。[CONTAINER…]: 指定要查看统计信息的容器ID或名称。如果不指定，则默认显示所有正在运行的容器统计信息。 显示所有正在运行的容器的资源使用统计 docker stats 指定容器 docker stats my-nginx 3. docker events 命令用途: docker events 监听并实时显示Docker守护进程的各种事件流，如容器创建、启动、停止、删除等。
命令语法:
docker events [OPTIONS] [OPTIONS]: 可以指定过滤条件，如 --filter event=delete 仅显示删除事件。 示例:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccc72d88e44bdca326064745c76a0232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a454dfd879386dd4354efa44a558febe/" rel="bookmark">
			Activity-＞Activity中动态添加Fragment-＞add和replace方式添加的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XML文件 Activity布局文件R.layout.activity_main &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/root_ll" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/add_child_ll" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="@android:color/holo_green_light" android:gravity="center" android:orientation="vertical"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/replace_child_ll" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="@android:color/holo_red_light" android:gravity="center" android:orientation="vertical"&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 第一次添加的MyFragmentA布局R.layout.inflate_layout_a &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/inflate_tv_a" android:layout_width="match_parent" android:layout_height="100dp" android:background="@android:color/holo_blue_light" /&gt; 第二次添加的MyFragmentB布局R.layout.inflate_layout_b &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/inflate_tv_b" android:layout_width="match_parent" android:layout_height="100dp" android:background="@android:color/holo_orange_light"/&gt; Activtiy代码和Fragment代码 -MyFragmentA代码
class MyFragmentA : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a454dfd879386dd4354efa44a558febe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ffa2e4c8dae0fb708b28312e46c1755/" rel="bookmark">
			正则表达式三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算符的优先级 相同优先级的从左到右计算，不同优先级，优先级高得先运算。从高到低为：
转义字符：
圆括号或方括号：(),[]
限定符：指限定前面元素的次数如：*，+,?,{n},{n,},{n,m}
字符类：用方括号表示例：[aeiou]
位置和顺序：^,$,\任何字符，任何字符
连接：在没有其他运算符的情况下表示字符之间的简单连接abc匹配“abc”
或：|表示或关系例：a|b 匹配 “a”或“b”
模式匹配 基本模式 正则表达式最基本的元素，是一组描述字符串特征的字符。例：
^one表示只匹配以one开头的字符串
up$表示只匹配以up结尾的字符串
^one $:表示精确匹配，字符串必须与 ^, $中间的一摸一样
one：匹配任何包含one的字符串
字符簇 可以有效判断点火号码，地址，EMAIL，信用卡号码等是否有效的模式，叫做字符簇。例
[A-Z]:匹配所有大写字母
[a-z]:匹配所有小写字母
[0-9]:匹配所有数字
[\f\r\t\n]:匹配所有白字符
[ ^a-z ]:匹配除了小写字母以外的所有字符。^在方括号内表示非，剔除的意思
点：匹配除换行符意外的任何字符
当确定重复出现时可以使用：
^ [a-z]{2} $:匹配三个字母
^ [a-z]{2,} $:匹配三个或三个以上字母
^ [a-z]{2,5} $：匹配三到五个字母
例：匹配手机号码 手机号码以1开头，后面跟十位数字
/^1[0-9]{10}$/g
手机号以1开头，第二位通常是3，4，5，6，7，8，9，后面跟九位数字
/^1[3-9][0-9]{9} $/g
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee43f28510dd20954e14d65b5bd0bf66/" rel="bookmark">
			创意SQL，高考祝福！一起为学子们加油助威！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢📢📢📣📣📣
作者：IT邦德
中国DBA联盟(ACDU)成员，10余年DBA工作经验，
Oracle、PostgreSQL ACE
CSDN博客专家及B站知名UP主，全网粉丝10万+
擅长主流Oracle、MySQL、PG、高斯及Greenplum备份恢复，
安装迁移，性能优化、故障应急处理
文章目录 前言1.第72个高考🚩 1.1 Oracle实现🚩 1.2 MySQL实现🚩 1.3 postgreSQL实现 2.高考倒计时3.SQL写福4.总结 前言 你是否有些祝福要讲，有些经验要谈，有些过往要忆，有些美好要述，这里小编用SQL为高考学子们加油助威！
1.第72个高考 🚩 1.1 Oracle实现 SELECT BANNER_FULL FROM v$version;
col 倒计时 for a30
select
to_char(sysdate, ‘yyyy’) 年份,
to_char(sysdate, ‘MM’) 本年月,
to_char(sysdate,‘iw’) 本年周,
to_char(sysdate,‘DDD’) 本年天,
to_char(sysdate, ‘yyyy-mm-dd’) 日期,
trunc(months_between(sysdate,to_date(‘1952’,‘yyyy’))/12) 多少个高考,
F_DAYS2STR(TO_DATE(‘2024-06-07 09:00’,‘yyyy-MM-dd hh24:mi’)-sysdate) 倒计时
from dual;
🚩 1.2 MySQL实现 select version();
select
year(curdate()) ‘年份’,
month(curdate()) ‘月份’,
weekofyear(curdate()) ‘周’,
dayofyear(curdate()) ‘天’,
DATE_FORMAT(now(), ‘%Y-%m-%d’) ‘日期’,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee43f28510dd20954e14d65b5bd0bf66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161e3923f62beff11fa54eec8e9cfc2b/" rel="bookmark">
			Activity-＞Activity中动态添加Fragment-＞Fragment回退栈BackStack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fragment回退栈 Fragment回退栈用于管理Fragment的导航历史(添加、删除、替换)。每个Activity都有一个包含其所有Fragment的FragmentManager，调用其addToBackStack方法时，这个事务就会被添加到FragmentManager的回退栈中当用户按下返回键时，系统就会从回退栈中弹出并反向执行最近的事务。如果你替换了一个Fragment，并将这个操作添加到了回退栈，那么按下返回键时，原来的Fragment会再次出现commitNow()方法不能和addToBackStack()方法一起使用 XML文件 Activity 布局文件R.layout.activity_main &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/replace_child_ll" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@android:color/holo_green_light" android:gravity="center" android:orientation="vertical"&gt; &lt;/LinearLayout&gt; 第一次添加的MyFragmentA布局R.layout.inflate_layout_a &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/inflate_tv_a" android:layout_width="match_parent" android:layout_height="100dp" android:background="@android:color/holo_blue_light" /&gt; 第二次添加的MyFragmentB布局R.layout.inflate_layout_b &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/inflate_tv_b" android:layout_width="match_parent" android:layout_height="100dp" android:background="@android:color/holo_orange_light"/&gt; Activity代码和Fragment代码 MyFragmentA代码 class MyFragmentA : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.inflate_layout_a, container, false) } } MyFragmentB代码 class MyFragmentB : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/161e3923f62beff11fa54eec8e9cfc2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3ef7063c5806ebd187db7f34957839/" rel="bookmark">
			flutter3-os：基于flutter3.x&#43;dart3&#43;getx手机版os管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter3-os-admin跨平台手机后台OS系统。 原创Flutter3.22+Dart3.4+Getx+fl_chart等技术开发仿ios手机桌面OA管理系统。自研栅格化布局引擎、自定义桌面壁纸、小部件、底部Dock菜单、可拖拽悬浮球等功能。
全新自研栅格化OS菜单布局引擎。
使用技术 编辑器：VScode技术框架：Flutter3.22.1+Dart3.4.1路由/状态管理：get^4.6.6本地存储：get_storage^2.1.1svg图片插件：flutter_svg^2.0.10+1图表组件：fl_chart^0.68.0国际化时间：intl^0.19.0 之前有分享一款uniapp+vue3跨端仿ios手机桌面系统。
https://blog.csdn.net/yanxinyun1990/article/details/139103578
编译到windows端效果依然完美显示。
项目结构 采用最新版flutter3.22+dart3.4构建项目，探索全新的手机OA后台管理系统新模式。
目前该项目已经发布到我的原创作品集，如果有需要，欢迎去下载使用。
https://gf.bilibili.com/item/detail/1106107011
main.js配置 import 'dart:io'; import 'package:flutter/material.dart'; import 'package:get/get.dart'; import 'package:get_storage/get_storage.dart'; import 'package:intl/date_symbol_data_local.dart'; import 'utils/index.dart'; // 栅格模板 import 'layouts/desk.dart'; // 路由管理 import 'router/index.dart'; void main() async { // 初始化get_storage存储 await GetStorage.init(); initializeDateFormatting(); runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return GetMaterialApp( title: 'Flutter WeOS', debugShowCheckedModeBanner: false, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue), useMaterial3: true, // 修复windows端字体粗细不一致 fontFamily: Platform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3ef7063c5806ebd187db7f34957839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05cb5d6db0d763658022055f8cdacb5c/" rel="bookmark">
			非常可靠，手把手教你本地部署AI大模型-llama3:70b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Meta公司一直致力于这样一个理念：“ that open source not only provides great technology for developers, but also brings the best out in people”，翻译过来就是开源不仅为开发人员提供了出色的技术，而且还将给人们带来更好的。但是前几天李彦宏说开源模型没有未来？我们的红衣大叔安全专家周总也提倡大家开源。
所以，到底开源好还是闭源好呢？
今天通过一个大模型案例来简单思考下这个问题。
下面主要介绍如何在本地部署llama3大模型，本次介绍拥有80亿参数的llama3:8B版本的部署。
大模型排名情况
简单介绍llama3大模型 Llama 3是Meta 公司开发的Llama系列模型的第三个版本，本次提供 8B 和 70B 参数大小的版本。Llama3拥有改进的推理能力。
llama3大模型的版本 模型版本参数大小模型大小发布时间llama3:70b700亿40GB2024-4-18llama3:8b80亿4.7GB2024-4-18 预告了正在训练中的400B+模型，性能追赶GPT4
指令微调模型
预训练模型
开始部署 技术栈组成 系统：linux系统（内存16GB 、CPU4C、 存储100GB、 无显卡）
大模型运行框架：ollama
使用模型：llama3:8b
web项目：open-webui
[本次使用8b模型，节省下载时间，如需使用其他模型，方法步骤相同，切换下载的模型即可]
第一步：安装ollama linux上安装很简单,官网：https://ollama.com/ curl -fsSL https://ollama.com/install.sh | sh 修改ollama服务启动脚本 vim /etc/systemd/system/ollama.service ... [Service] #增加,（不修改，后续如果其他主机调用api接口会报无法连接错） Environment="OLLAMA_HOST=0.0.0.0:11434" ... 启动ollama服务 systemctl daemon-reload systemctl restart ollama 测试ollama接口是否可以访问 直接浏览器访问http://服务器ip:11434，如返回 ollama in runninng,表示正常，可以继续下面的步骤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05cb5d6db0d763658022055f8cdacb5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77fbf90b00733d76da3cf656bf91684/" rel="bookmark">
			【蓝桥杯2025备赛】分巧克力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【蓝桥杯2025备赛】分巧克力 [蓝桥杯 2017 省 AB] 分巧克力 题目描述 儿童节那天有 K K K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。
小明一共有 N N N 块巧克力，其中第 i i i 块是 H i × W i H_i \times W_i Hi​×Wi​ 的方格组成的长方形。
为了公平起见，小明需要从这 N N N 块巧克力中切出 K K K 块巧克力分给小朋友们。切出的巧克力需要满足：
形状是正方形，边长是整数。
大小相同。
例如一块 6 × 5 6 \times 5 6×5 的巧克力可以切出 6 6 6 块 2 × 2 2 \times 2 2×2 的巧克力或者 2 2 2 块 3 × 3 3 \times 3 3×3 的巧克力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e77fbf90b00733d76da3cf656bf91684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd02bbdaa845590df8cb4eb853f7faf/" rel="bookmark">
			AIGC降重：如何2分钟降低论文AI率和查重率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确保学术论文的独立性与诚信性，对于学业的成就及学位的获取至关重要，其中，论文的人工智能查重与降低AIGC相似度扮演着核心角色。
常规的查重手段主要围绕查重软件的运用和个体的自行审查；而降重则通常通过语句重组、同义替换、内容丰富化以及精准引注等手段来提升文章的独创性。
但这些传统方法往往效率低下、劳动强度大，且难以确保达到预期的降重成效。在这种背景下，我们自然会思考：能否借助人工智能工具实现高效降重？幸运的是，目前已有一些AIGC降重工具，凭借其高级算法，为学者和研究人员提供了极大的便利，有效节约时间并提升降重工作的品质。接下来，我将会推介一款实用的AIGC降重工具，它能在维护学术诚信的基础上，大大简化论文的编写流程。
SpeedAI科研小助手 SpeedAI科研小助手
2分钟一篇论文，提供了片段修改和全文修改两个功能，可以选择降重修改、降AIGC修改，以及学术润色修改三种修改模式，这里推荐使用降AIGC修改，因为同时也降了AI，重复率也下去了，非常适合既要查重率又要AIGC率的情况
使用测试可以发现，基本可以直接到0%，这里给一个案例：
从54%降到了2%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef39b4f753cd0e94106a46e9f5ccc0df/" rel="bookmark">
			【研发日记】Matlab/Simulink软件优化(二)——通信负载柔性均衡算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言
背景介绍
初始代码
优化代码
分析和应用
总结
前言 见《【研发日记】Matlab/Simulink软件优化(一)——动态内存负荷压缩》
背景介绍 在一个嵌入式软件开发项目中，需要设计一个ECU节点的CAN网路数据发送，需求是在500k的通信波特率上，动态发送10到40帧报文，发送一轮的时间最长不能超过50ms。示例如下：
初始代码 一开始算法开发的思路非常简单，就是设置一个50ms的任务，用for循环把要发送的数据装入CAN发送Buffer。示例如下：
以上模型生成的代码如下：
#include "untitled.h" #include "untitled_private.h" /* Block signals (default storage) */ B_untitled_T untitled_B; /* Block states (default storage) */ DW_untitled_T untitled_DW; /* Real-time model */ static RT_MODEL_untitled_T untitled_M_; RT_MODEL_untitled_T *const untitled_M = &amp;untitled_M_; /* Model step function */ void untitled_step(void) { int32_T i; int32_T rtb_Gain; int32_T s6_iter; char_T *sErr; void *inputMsgRef; /* Outputs for Enabled SubSystem: '&lt;Root&gt;/Subsystem' incorporates: * EnablePort: '&lt;S3&gt;/Enable' */ /* RelationalOperator: '&lt;S1&gt;/Compare' incorporates: * Constant: '&lt;S1&gt;/Constant' * UnitDelay: '&lt;S2&gt;/Output' */ if (untitled_DW.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef39b4f753cd0e94106a46e9f5ccc0df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d309d555da5b60009fb9e3a0d70a47b/" rel="bookmark">
			OpenCV的小部件最基本范例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV也有与PYQT类似的小部件，例如滑块slider。OpenCV可以用与PYQT类似的“信号与槽”方法，也可以在函数中直接查询小部件的值。
import cv2 import numpy as np cv2.namedWindow('Show1') image = np.zeros((100, 400, 3), np.uint8) # 创建一个空白内容的图像 def slot(Slider_value): # 类似于PYQT的“槽函数” image[:] = [0, 0, 0] # 清空图像 cv2.putText(image, str(Slider_value), (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2) cv2.imshow('Show1', image) querying() def querying(): # 查询的方式 image[:] = [0, 0, 0] # 清空图像 Slider_value = cv2.getTrackbarPos('Slider', 'Show1') * 2 cv2.putText(image, str(Slider_value), (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2) cv2.imshow('Show2', image) cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d309d555da5b60009fb9e3a0d70a47b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1931d8961079ad1b15284d11f4e51e/" rel="bookmark">
			『哈哥赠书 - 54期』-『架构思维：从程序员到CTO』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 ⭐️ 架构思维：从程序员到CTO⭐️ 本书简介⭐️ 作者简介⭐️ 编辑推荐⭐️ 不想成为架构师的程序员不是好CTO 在程序员的职业规划中，成为软件架构师是一个非常有吸引力的选择。但是对于如何才能成为一名架构师，不少同学认为只要代码写得好，就能得到公司提拔，晋升为架构师。
还真不是这样的，如果不具备架构思维，即使代码能写到极致，在开展工作时也将不可避免地掉到坑里去。例如，看起来面面俱到的设计，但因为太复杂而无法落地；错估需求，导致高射炮打蚊子，浪费资源；实现方案总想毕其功于一役，结果需求变化就要推倒重来。
所以程序员要清醒地认识到，写好代码仅是软件开发过程中的一个环节，把代码写到极致也不会自动成为架构师。架构工作贯穿了软件生命周期，做好架构一定要学会架构思维。
⭐️ 架构思维：从程序员到CTO ⭐️ 本书简介 本书以架构师工作中的痛点问题为导向，结合大量真实、复杂的案例，帮助架构师提高架构设计能力，规划职业成长路径。
本书共4部分：
第一部分 “架构师的思维模式” ，介绍3种架构师的思维定式和4种架构活动中常见的思维模式；第二部分 “架构师的生存法则” 介绍影响架构活动成败的6个要素，以及由其引出的架构师的6条生存法则；第三部分 “架构活动中的挑战、根因和应对” 介绍架构师在整个架构活动中持续发挥的作用以及架构活动不同阶段常见的问题；第四部分 “架构师的职业规划和能力成长” 介绍架构师的成长地图和对应角色的关键能力，以及提升思考力的方法。 ⭐️ 作者简介 郭东白，布朗大学博士，当前担任Coupang副总裁，兼任浙江大学计算机学院兼职教授和博导。
他先后在甲骨文、微软、Amazon、阿里巴巴、车好多等公司任职。他是云计算和国际化电商平台领域的资深专家，分别为Amazon、阿里巴巴和Lazada搭建每秒上万次成交、年成交额超百亿美金的大型电商平台，使平台覆盖数字、跨境和本地3种电商商业模式，支持内容化、社交化、游戏化、私域化等一系列创新技术，为企业带来了巨大的商业成功和生存优势。
他是云计算和国际化电商平台领域的资深专家，分别为亚马逊、阿里巴巴和 Lazada 搭建每秒上万次成交，年成交额超百亿美金的大型电商平台，覆盖数字、跨境和本地三种电商商业模式，同时支持内容化、社交化、游戏化、私域化等一系列创新技术。跟着大佬学，成为顶级架构师绝非奢望。
⭐️ 编辑推荐 适读人群 ：本书对所有IT从业人员都有益，尤其适合想成为架构师的研发人员和想提升自己架构能力的架构师。架构设计不只是技术维度的广泛认知，更是商业维度的全局把控。
本书是Coupang副总裁郭东白10多年架构师和CTO工作的经验总结。在本书中，你可以了解互联网行业进化的本质，架构师的工作内容、所需能力等，你熟知的每一个互联网案例背后的架构设计原则和逻辑。
阅读本书，你将掌握：
架构思维，架构设计的3种思维定式和4种思维模式；生存法则，影响架构活动成败的6个要素及对应的生存法则；实践挑战，架构活动中必然或可能遇到的技术/场景挑战及应对思路；成长规划，从程序员到CTO的职业能力跃迁。 当你学完本书时，你将了解行业发展脉络，理解架构师工作的底层逻辑，掌握架构设计的思维原则，从而梳理出自己的清晰的成长地图，实现职业角色的跃迁。
编辑的话：这不是一本架构师速成书，本书中除了有对架构设计中的技术选型的分析，还有对架构活动中的环境、人性、经济等的洞察。在这个不断变化的环境中，郭东白老师从自己亲身经历的诸多案例出发，将丰富的经验和开阔的视野提炼出一名优异的架构师应有的能力和战略目标，本书对所有IT从业人员都有益，尤其适合想成为架构师的研发人员和想提升自己架构能力的架构师。
我很荣幸参与本书的出版工作，书中讲解的思考方法和战略思路对我有很大的启发，衷心希望读者通过阅读本书有所收获！
⭐️ 不想成为架构师的程序员不是好CTO 程序员在走向架构师的成长之路上，需要有一个“战略意图”。所以作者对本书的定位是“假设你有做一个全球顶尖架构师的战略意图，那么我希望能帮你提高一点成功概率” 。
可能在现实中不是每个人最后都能成为全球五百强的 CTO，但的确有很多人不满足于现状，努力地想要突破职场天花板，一番动作下来却是徒劳无功，这是因为思考没有跟上行动所致。
《架构思维：从程序员到CTO》最大的特点，就是为程序员提供了一套思维模型，并且给出了切实可行的建议，帮助大家意识到自己的问题，找准定位，从而实现能力跃迁。
所以作者的根本目的是授人以渔，结合自己多年工作中踩过的坑，以丰富的案例说明架构思维是如何用于工作的最佳实践，从而启发读者对自身的思考，进而做出正确的行动。
许多非程序员专业的读者同样也可以从本书获益，因为它提供的思考框架尤其适用于当下变化快、竞争压力大、充满不确定性的环境。
当然，成长之路注定是坎坷而痛苦的，这也是我们对抗职业风险的最好选择。不要在遭遇职场瓶颈时抱怨大环境和年龄因素，翻开《架构思维：从程序员到CTO》开始学习，突破天花板，成为架构师，走向 CTO！
本次送书 3 本 评论区抽三位小伙伴送书 活动时间：截止到 2024-06-10 20:00:00 抽奖方式：利用网络公开的在线抽奖工具进行抽奖 评论 "易编橙 · 终身成长社群，相遇已是上上签！" 随机抽取的3位小伙伴将免费获得此书！ 小伙伴也可以点击链接进行自主购买哦~ 【架构思维：从程序员到CTO】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7dd51fae1fe7f74ee884c2d57dddec5/" rel="bookmark">
			使用 OKhttp3 实现 智普AI ChatGLM HTTP 调用(SSE、异步、同步)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSE 调用 SSE（Sever-Sent Event），就是浏览器向服务器发送一个HTTP请求，保持长连接，服务器不断单向地向浏览器推送“信息”（message），这么做是为了节约网络资源，不用一直发请求，建立新连接。
// 创建请求对象 Request request = new Request.Builder() .url(String.format(sseApi, seeId)) // .post(requestBody) // 请求体 // .addHeader("Authorization", "Bearer " + token) .addHeader("Accept", "text/event-stream") // .addHeader("Content-Type", "text/event-stream;charset=UTF-8") .addHeader("Connection", "keep-alive") .build(); OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) // 建立连接的超时时间 .readTimeout(30, TimeUnit.SECONDS) // 建立连接后读取数据的超时时间 .build(); // 创建一个 CountDownLatch 对象，其初始计数为1，表示需要等待一个事件发生后才能继续执行。 CountDownLatch eventLatch = new CountDownLatch(1); // 实例化EventSource，注册EventSource监听器 -- 创建一个用于处理服务器发送事件的实例，并定义处理事件的回调逻辑 final String[] finalMessage = {""}; RealEventSource realEventSource = new RealEventSource(request, new EventSourceListener() { @Override public void onEvent(EventSource eventSource, String id, String type, String data) { if ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7dd51fae1fe7f74ee884c2d57dddec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83fb160ae67850545b2434e39dc10348/" rel="bookmark">
			爬山算法详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬山算法详细介绍
一、引言
爬山算法（Hill Climbing Algorithm）是一种启发式搜索算法，它通过模拟自然界中生物体寻找食物或栖息地的过程来寻找问题的最优解。爬山算法在解决优化问题、路径规划、机器学习等领域有着广泛的应用。本文将详细介绍爬山算法的基本概念、工作原理、优缺点以及实际应用案例，帮助读者更好地理解和运用这一算法。
二、爬山算法的基本概念
爬山算法是一种基于梯度上升的优化算法。它通过迭代过程从一个初始解出发，逐步寻找更好的邻域解，直到达到局部最优解或满足停止条件为止。爬山算法的核心思想是“沿着山坡向上爬”，即不断寻找梯度最大的方向，以期达到山顶（全局最优解）。在爬山算法中，梯度表示当前状态向更好状态转变的方向和程度。
三、爬山算法的工作原理
初始化解：选择一个合适的初始解作为起始点。这个初始解可以是随机生成的，也可以是根据问题特性预先设定的。
梯度评估：计算当前解的梯度，梯度是指函数在当前点处的一阶导数。梯度的方向指向函数值增加最快的方向，而梯度的大小则表示增加的速率。
选择方向：根据梯度的方向，选择一个方向进行搜索。这个方向是函数值增加最快的方向，即梯度的反方向。
移动到新解：沿着选定的方向，移动到一个新的解。这个新解是当前解加上梯度方向的一个步长得到的。步长的大小可以根据问题的特性和算法的要求进行调整。
判断是否停止：检查新解是否满足停止条件。停止条件可以是梯度的大小小于某个阈值、达到最大迭代次数、新解的函数值不再提高等。如果满足停止条件，算法结束；否则，返回步骤2继续迭代。
四、爬山算法的优缺点
优点：
实现简单：爬山算法的实现相对简单，只需要计算梯度和更新解即可。
适应性强：爬山算法可以应用于多种优化问题，不需要对问题的数学性质有过多的假设。
灵活性高：可以通过调整参数（如步长、温度等）来适应不同的问题和优化需求。
缺点：
容易陷入局部最优解：由于爬山算法是基于梯度上升的，它容易在局部最优解附近停滞，难以找到全局最优解。
缺乏全局搜索能力：爬山算法缺乏全局搜索能力，对于具有多个局部最优解的问题，可能无法找到全局最优解。
参数敏感性：爬山算法的性能受参数设置的影响较大，如步长的选择不当可能导致算法收敛速度慢或提前停止。
五、爬山算法的改进版本
模拟退火算法（Simulated Annealing）：通过引入随机性和退火机制，允许算法在一定概率下接受比当前解差的解，从而增加了跳出局部最优解的机会。
遗传算法（Genetic Algorithm）：借鉴自然选择的原理，通过选择、交叉和变异操作生成新的个体，具有较好的全局搜索能力。
粒子群优化算法（Particle Swarm Optimization, PSO）：通过模拟鸟群觅食行为，利用粒子的速度和位置更新规则来搜索最优解，具有较好的收敛性能和鲁棒性。
六、总结
爬山算法作为一种启发式搜索算法，在解决优化问题、路径规划、机器学习等领域具有广泛的应用。通过本文的介绍，我们了解了爬山算法的基本概念、工作原理、优缺点以及改进版本。然而，爬山算法在实际应用中仍面临一些挑战，如如何选择合适的参数、如何避免陷入局部最优解等。未来的研究可以进一步探索爬山算法的改进和优化，以提高其在实际问题中的应用效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c3ba114536ca382bcc57b8ef10c892/" rel="bookmark">
			【数据结构】栈的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你内心肯定有有着某种火焰，能把你和其他人区别开来。 --库切
目录 🚗一.栈的概念及结构
🚒二.栈的基本操作 🍗1.栈的初始化
🥩2.入栈
🍊3.栈顶的元素
🍒4.出栈
🍓5.判断栈是否为空
🍌6.栈中的元素个数
​🌶️7.销毁栈
🚙三.栈的全部代码
🍍1.Stack.h：
🥔2.Stack.c：
🍎3.test.c：
🚗一.栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除操作，进行数据的插入和删除操作的一端称为栈顶。另一端称为栈底。栈中数据元素遵循后进先出LIFO(last in first out)。
栈最基本的两个操作就是压栈和出栈。
1.压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
2.出栈：栈的删除操作叫做出栈，出数据也在栈顶。 通俗的理解其实就是我们之前学习的尾插和尾删，尾插对应的就是压栈，尾删对应的就是出栈。
但是对于尾插，尾删，我们学习了三种结构：顺序表(数组)，单链表，双链表。所以这里我们选用哪一种结构来实现栈呢？
对于单链表尾插，尾删，我们每次都需要遍历整个数组，来找到尾，再进行操作，时间复杂度是O(N)，所以我们不会使用单链表来实现栈，我们可以选择顺序表(数组)或者双链表来实现。
这里我们选择的是顺序表(数组)。
和之前一样,我们使用结构体来实现:
typedef int STDataType; typedef struct Stack { STDataType* a;//动态数组 STDataType top;//栈顶 int Capacity;//容量 }ST; 🚒二.栈的基本操作 🍗1.栈的初始化 对于栈的初始化，我们可以先使用malloc动态的给数组开辟几个空间，容量也栈初始化几个。
//初始化栈 void StackInit(ST* ps) { assert(ps); ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);//动态的开辟空间 if (ps-&gt;a == NULL) { perror("malloc\n"); return; } ps-&gt;top = 0; ps-&gt;Capacity = 4;//初始化容量为4 } 🥩2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c3ba114536ca382bcc57b8ef10c892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00121ba44346d7d211410b1746c6e8a1/" rel="bookmark">
			IP质量不够好，可以使用高质量的代理IP吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今互联网时代，IP代理是一个不可或缺的工具，但许多人可能对它的原理和应用感到困惑。IP代理涉及IP地址的使用和切换，旨在提供更好的隐私保护和访问控制。本文将介绍IP代理的工作原理以及为什么选择高质量的代理IP。
一、IP代理的基本原理 IP代理实际上是一个位于用户和目标服务器之间的中继服务器。当用户请求访问某个网站时，请求不会直接发送到目标服务器。相反，它首先传递给代理服务器，然后由代理服务器代表用户发送到目标服务器。这使得用户的真实IP地址不会直接暴露在互联网上，从而提供了一定程度的隐私和匿名性。
二、IP代理的工作方式为用户提供了多个好处 首先，它可以绕过地理位置限制。许多网站和在线服务会根据用户的地理位置提供不同的内容或功能。通过切换到不同地理位置的代理IP，用户可以访问地理位置受限的内容，扩大其在线体验。
其次，IP代理可以用于爬虫和数据采集。在进行网络爬虫操作时，频繁的请求可能导致IP被目标网站封锁。通过使用代理IP，用户可以分散请求，降低被封锁的风险。这对于市场调研、竞争情报和网页抓取等任务非常有用。
然而，选择合适的代理IP至关重要。绝大多数代理IP都是共享IP，这意味着多个用户共享同一组IP地址。共享IP的一个显著缺点是，如果一个用户不当使用IP，导致IP被封锁，其他用户也会受到影响。
这就是为什么高质量的代理IP如此重要。高质量的代理IP通常是独享IP，只供单个用户使用，不与其他用户共享。这降低了IP被滥用的风险，提供了更高的性能和隐私保护。
如果您想确保IP的高质量，您可以选择专属IP定制服务。这种服务提供了独享IP的选择，用户可以根据自己的需求来定制IP，以满足特定的目标和应用。这些专属IP通常具有更高的稳定性和更快的速度，适合需要高质量代理IP的用户。
三、如何选择IP代理？ 在选择代理IP供应商时，务必选择一个可靠的供应商，以确保提供的IP质量和服务质量，专注于提供高质量的代理IP服务，为用户提供了更好的解决方案，保护隐私、绕过限制并提高网络安全性的供应商。
IP代理是一个强大的工具，可以提供隐私保护、绕过地理位置限制和用于数据采集等多个用途。选择高质量的代理IP是关键，因为它可以提供更好的性能和保护，使得用户能够充分利用互联网资源。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/297/">«</a>
	<span class="pagination__item pagination__item--current">298/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/299/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>