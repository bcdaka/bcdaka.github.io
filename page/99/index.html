<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741b3701103f736a40f8ed46fcbcefa8/" rel="bookmark">
			Java二十三种设计模式-代理模式（8/23）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理模式：为对象访问提供灵活的控制 引言 代理模式（Proxy Pattern）是一种结构型设计模式，它为其他对象提供一个代替或占位符，以控制对它的访问。
基础知识，java设计模式总体来说设计模式分为三大类：
（1）创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
（2）结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
（3）行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
第一部分：代理模式概述 1.1 定义与用途 代理模式的基本定义 代理模式是一种结构型设计模式，其核心思想是为一个对象提供一种代理，以控制对这个对象的访问。代理模式可以在不修改目标对象的基础上，通过引入一个代理层来间接操作实际对象，从而实现对目标对象的访问控制、延迟初始化、日志记录、权限校验等功能。
解释为何需要代理模式 访问控制：在某些情况下，我们可能需要对某些对象的访问进行控制，比如限制访问频率、权限验证等。代理模式可以为实际对象提供一个访问控制层，从而实现这些需求。
延迟初始化：有些对象的创建可能是资源密集型的，比如涉及到复杂的计算或者I/O操作。通过代理模式，我们可以延迟对象的初始化，直到真正需要使用时才创建实际对象。
增加额外功能：代理模式可以在不修改实际对象的情况下，为其增加额外的功能，比如日志记录、性能监控、事务处理等。这种方式比修改原有对象的代码更加灵活和安全。
远程代理：在分布式系统中，对象可能位于不同的地址空间。远程代理可以隐藏对象所在的远程地址，并在本地提供一个代理对象，使得客户端感觉就像在访问一个本地对象。
虚拟代理：对于一些需要大量资源来创建的对象，可以使用虚拟代理来提供一个轻量级的替代品。只有当真正需要完整对象时，才会创建实际对象。
保护代理：代理模式还可以用于实现访问保护。通过代理对象，可以控制对实际对象的访问权限，确保只有符合条件的操作才能执行。
智能引用：在某些语言中，代理模式可以用于实现智能引用，比如引用计数、自动内存管理等。
代理模式通过引入一个代理层，提供了一种灵活的方式来增强和控制对象的行为，同时保持了系统的灵活性和可扩展性。在下一部分中，我们将详细介绍代理模式的组成部分和实现方式。
第二部分：代理模式的组成与实现 2.1 角色定义 主题（Subject） 定义：定义了真实对象和代理对象的共同接口，这样代理可以代替真实对象被使用。角色：充当代理和真实对象的契约。 代理（Proxy） 定义：代理对象内部含有对真实对象的引用，从而可以控制对真实对象的访问。角色：提供与真实对象相同的接口，并在访问真实对象前或访问后增加额外的处理。 客户端（Client） 角色：通过代理对象来间接访问真实对象，客户端并不直接与真实对象交互。职责：客户端通过代理对象发送请求，由代理对象来决定如何将请求转发给真实对象。 2.2 Java实现示例 以下是使用Java语言实现代理模式的一个简单示例。我们将创建一个计算资源密集型的对象，并通过代理来控制对该对象的访问。
// 主题接口 interface Subject { void request(); } // 真实对象 class RealSubject implements Subject { @Override public void request() { System.out.println("RealSubject: Handling request."); // 模拟资源密集型操作 } } // 代理类 class Proxy implements Subject { private RealSubject realSubject; public Proxy() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741b3701103f736a40f8ed46fcbcefa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d274f3c6c4ee9bdf005227dff638318e/" rel="bookmark">
			Web-vue框架应用（p5r网站）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 vue介绍配置环境基本概念 网站完成介绍首页对战页面用户列表页面个人中心页面登录和注册页面 vue介绍 配置环境 Vue官网
终端
Linux和Mac上可以用自带的终端。
Windows上推荐用powershell或者cmd。Git Bash有些指令不兼容。
安装Nodejs
安装地址
安装@vue/cli
打开Git Bash，执行：
npm i -g @vue/cli 如果执行后面的操作有bug，可能是最新版有问题，可以尝试安装早期版本，比如：npm i -g @vue/cli@4
启动vue自带的图形化项目管理界面
vue ui 常见问题1：Windows上运行vue，提示无法加载文件，表示用户权限不足。
解决方案：用管理员身份打开终端，输入set-ExecutionPolicy RemoteSigned，然后输入y
基本概念 script部分
export default对象的属性：
name：组件的名称components：存储&lt;template&gt;中用到的所有组件props：存储父组件传递给子组件的数据watch()：当某个数据发生变化时触发computed：动态计算某个数据setup(props, context)：初始化变量、函数 ref定义变量，可以用.value属性重新赋值reactive定义对象，不可重新赋值props存储父组件传递过来的数据context.emit()：触发父组件绑定的函数 template部分
&lt;slot&gt;&lt;/slot&gt;：存放父组件传过来的children。v-on:click或@click属性：绑定事件v-if、v-else、v-else-if属性：判断v-for属性：循环，:key循环的每个元素需要有唯一的keyv-bind:或:：绑定属性 style部分
&lt;style&gt;标签添加`属性后，不同组件间的css不会相互影响。 第三方组件
view-router包：实现路由功能。vuex：存储全局状态，全局唯一。 state: 存储所有数据，可以用modules属性划分成若干模块getters：根据state中的值计算新的值mutations：所有对state的修改操作都需要定义在这里，不支持异步，可以通过$store.commit()触发actions：定义对state的复杂修改操作，支持异步，可以通过$store.dispatch()触发。注意不能直接修改state，只能通过mutations修改state。modules：定义state的子模块 网站完成介绍 项目地址：Github
p5素材都是用ps抠的，喜欢还请点个star
首页 进入网站是p5剪影图做海报
主页自动播放背景音乐(Take Over it)
网页正中间有播放按钮，点击播放按钮后会弹出op
当播放视频时，整个页面是被禁止滚动的，只能操作视频，此时背景音乐将被禁用掉
当首页向下滑动一个窗口距离后将会出现右侧的卡片，可以点击箭头使其收回
poster下面的区域为新闻区，通过banner和对应的文字说明板块构成，banner的图片每隔5秒更换
下方的暴击横条可是设置跳转链接，当鼠标放上之后的hover状况下会有特殊动画，和人物出现效果
对战页面 传统格斗游戏，目前没有实现匹配功能
这有移动，跳跃，攻击功能，全部有JavaScript类继承实现，好扩展
自动播放背景音乐Life Will Change
没有p5素材，自己肝太多了，只能先用拳皇的了
用户列表页面 返回服务器上注册的前十位用户，对接的acapp的api
点击用户图像，如果未登录会跳转到登录页面，登录后才能跳转到对应用户的页面，可以查看对应用户的发帖和信息，存在服务器中
个人中心页面 在这个页面可以发帖和删除帖子，上传到服务器，别人可以看见，别人和自己公用一个模板，只有自己进入自己页面时才能发帖和删帖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d274f3c6c4ee9bdf005227dff638318e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95bbb4262a9799847b1eec299baac19/" rel="bookmark">
			ExcelJS：轻松实现Excel文件的读取、操作与写入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发现宝藏1. 简介2. 安装3. 创建工作簿4. 设置工作簿属性5. 添加工作表6.删除工作表7.访问工作表8. 列操作9. 行操作10. 单元格操作 发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
ExcelJS 是一个强大的 JavaScript 库，它允许你在 Node.js 和浏览器环境中读取、操作和写入 Excel 文件。本文将带你了解 ExcelJS 的基本用法，帮助你快速上手这个强大的工具。
1. 简介 ExcelJS 是一个开源的 JavaScript 库，支持读写 XLSX 和 CSV 格式的 Excel 文件。它具有以下特点：
支持丰富的 Excel 功能，如单元格样式、公式、图表等。良好的文档和社区支持。跨平台，可在 Node.js 和浏览器环境中使用。 2. 安装 在开始使用 ExcelJS 之前，需要先进行安装。以下是在 Node.js 环境中的安装方法：
npm install exceljs 如果你在浏览器环境中使用，可以直接从 GitHub 仓库下载 exceljs.js 文件。
3. 创建工作簿 首先，我们需要创建一个工作簿（Workbook）对象，然后才能进行其他操作。
const workbook = new ExcelJS.Workbook(); 4. 设置工作簿属性 可以为工作簿设置一些基本属性，如创建者、最后修改者、创建时间等。
workbook.creator = 'Me'; workbook.lastModifiedBy = 'Her'; workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95bbb4262a9799847b1eec299baac19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80689dc84fe4cb2df4d7f94bc3ace8d/" rel="bookmark">
			本地部署 Llama 3.1：Ollama、OpenWeb UI 和 Spring AI 的综合指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		、
本文介绍如何使用 Ollama 在本地部署 Llama 3.1:8B 模型，并通过 OpenWeb UI 和 Spring AI 来增强模型交互体验和简化 API 的调用过程。
Ollama Ollama 是一个开源的大语言模型服务工具，旨在简化大模型的本地部署和运行过程。用户只需要输入一行命令（如： ollama run llama3.1 ），即可在本地硬件环境中部署和使用大语言模型。Ollama 还提供了 REST API 接口，下文中会介绍如何使用 Spring AI 集成 Ollama，实现与大模型 API 接口的交互。
Ollama 支持下载 Llama、Gemma、qwen 和 glm4 等多种主流大语言模型和代码语言模型，我们可以在 官网 查看 Ollama 支持的所有模型及其相关信息和使用命令。 本机运行 7B 参数量的模型至少需要 8GB 内存，运行 13B 参数量的模型至少需要 16GB 内存，运行 33B 参数量的模型至少需要 32GB 内存。
模型参数大小使用命令Llama 3.18B4.7GBollama run llama3.1Llama 3.170B40GBollama run llama3.1:70bLlama 3.1405B231GBollama run llama3.1:405bGemma 29B5.5GBollama run gemma2Gemma 227B16GBollama run gemma2:27bqwen27B4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80689dc84fe4cb2df4d7f94bc3ace8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b580837c71f6c53db90a49de21b2352/" rel="bookmark">
			我出一道面试题，看看你能拿 3k 还是 30k！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是程序员鱼皮。欢迎屏幕前的各位来到今天的模拟面试现场，接下来我会出一道经典的后端面试题，你只需要进行 4 个简单的选择，就能判断出来你的水平是新手（3k）、初级（10k）、中级（15k）还是高级（30k）！
请听题：
题目 MySQL 数据库中的 count(1)、count(*)、count(字段）有什么区别？
在面试鸭上查看
请回答 1、它们在功能上有区别么？ A：有区别
B：没区别
答案 有区别。虽然在 MySQL 中，count(*)、count(1) 和 count(字段名) 都是用来 统计行数的聚合函数 。
但 count(*) 和 count(1) 会统计表中所有行的数量，包括 null 值（不会忽略任何一行数据）；而 count(字段名) 只会统计指定字段不为 null 的行数。
恭喜答对的朋友，3k 的 offer 到手啦！
2、count(*) 和 count(1) 谁更快？ A：count(*)
B：count(1)
C：没区别
答案 效率一致，没区别。
关于 count(1) 和 count(*) 谁更快的问题，网上众说纷纭，如果背了不专业的八股文，可能答案就选错咯~
有点经验的程序员，在遇到不确定的问题时，当然要去源头亲自求证，得去看官网怎么说。如图：
官网表示 There is no performance difference ，即二者没有性能上的区别！
对于 count(字段) 的查询就是全表扫描，正常情况下它还需要判断字段是否是 null 值，因此理论上会比 count(1) 和 count(*) 慢。
但是如果字段不为 null，例如是主键或具有非空约束，那么理论上性能也差不多。而且本质上它们的统计功能不一样，在需要统计 null 的时候，只能用 count(1) 和 count(*)，不需要统计 null 的时候只能用 count(字段)，所以也不用太纠结性能问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b580837c71f6c53db90a49de21b2352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f304c00763cf264dc92a7f8c35bdab5b/" rel="bookmark">
			设计模式 之 —— 抽象工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是抽象工厂模式？
定义
特点
抽象工厂模式（java代码示例）
首先定义第一个接口 实现第一个接口的类
定义第二个接口
实现第二个接口的类
* 创建抽象工厂类
创建扩展了 AbstractFactory 的工厂类
饮料工厂
食物工厂
* 创建一个工厂生成器类
测试类：
运行结果：
抽象工厂模式的优缺点
优点：
缺点:
总结：
什么是抽象工厂模式？ 定义 抽象工厂模式（Abstract Factory Pattern），它围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。它也是一种创建型设计模式，提供了一种创建对象的最佳方式。
特点 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。
抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体实现类。通过使用抽象工厂模式，可以将客户端与具体产品的创建过程解耦，使得客户端可以通过工厂接口来创建一族产品。
抽象工厂模式（java代码示例） 首先定义第一个接口 （饮料：Drinks）
public interface Drinks { void product(); } 实现第一个接口的类 （类：茶、可乐、矿泉水)
public class Tea implements Drinks { @Override public void product(){ System.out.println("饮料——茶"); } } public class Cola implements Drinks { @Override public void product(){ System.out.println("饮料——可乐"); } } public class MineralWater implements Drinks { @Override public void product(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f304c00763cf264dc92a7f8c35bdab5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c619e1d62c978a906e59662abcd6d5/" rel="bookmark">
			Codeforces Round 962 (Div. 3) 题解 A-F
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. Legs Problem - A - Codeforces
1.1翻译 农夫约翰的农场又迎来了美好的一天。
农夫约翰来到农场后，数了数 n条腿。众所周知，农场里只住着鸡和牛，一只鸡有 2 条腿，而一头牛有 4 条腿。
假设约翰农场主数清了所有动物的腿，那么他的农场里最少有多少动物？
1.2思路 求最少有几只动物，n先除4再除2就行。
1.3代码 void solve() { cin &gt;&gt; n; int k = n / 4; n -= k * 4; int p = n / 2; cout &lt;&lt; p + k &lt;&lt; "\n"; } B. Scale ​​​​​​Problem - B - Codeforces
2.1翻译 就是说，给你一个n*n的01网格，网格中每个01块都是相同的长宽，让你缩小k倍，例如：
8 2
00001111
00001111 00001111 --&gt; 0011
00001111 --&gt; 0011 11110000 --&gt; 1100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c619e1d62c978a906e59662abcd6d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ec739ec90b6fee8bc766437ed3ce24/" rel="bookmark">
			六小龄童评价《黑神话悟空》 黑神话悟空是什么游戏 苹果电脑能玩黑神话悟空吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要论近期关注度最高的国产游戏，《黑神话：悟空》绝对稳坐头把交椅。从首段预告片公布的那一刻起，它就承载起了无数中国单机玩家的期望。《黑神话悟空》是一款以中国神话为背景的动作角色扮演游戏。故事取材于中国古典小说“四大名著”之一的《西游记》。游戏定于2024年8月20日登陆 Windows PC / PlayStation 5 平台。
《黑神话悟空》是什么游戏 你将扮演一位“天命人”，为了探寻昔日传说的真相，踏上一条充满危险与惊奇的西游之路。该游戏由游戏科学（深圳市游科互动科技有限公司）开发，使用虚幻5引擎。现在即可在PS5、Steam、Epic、WeGame的数字商店预购《黑神话：悟空》数字版。采用一次性买断制的经典单机付费模式，可能会推出 DLC。
根据个人上手试玩，《黑神话：悟空》的推进节奏比较接近魂类游戏，Boss战也更像是「二人转」的体验。不过本作在战斗系统上有很多独有的特色，和市面上已售的知名作品风格都有所差别。
综合来看，《黑神话：悟空》测试版的完成度颇高，整体展现出的优良水准让许多对游戏素质怀抱疑虑的玩家心里多少有了底。
六小龄童评价《黑神话悟空》 关于‌六小龄童对‌《黑神话：悟空》的评价，虽然没有直接的官方声明或详细访谈记录，但可以从相关讨论和推测中得出一些可能的观点。
对游戏质量的认可： 考虑到六小龄童对孙悟空角色的深厚理解和表演经验，他可能会对《黑神话：悟空》中孙悟空形象的塑造和动作设计给予一定的认可，尤其是如果游戏能够真实还原孙悟空的特质和气息。‌ 对游戏改编的态度： 六小龄童曾公开表示过对《西游记》改编作品的看法，强调“戏说不是胡说，改编不是乱编”。因此，他可能会关注《黑神话：悟空》在改编过程中是否尊重原著精神，以及是否保持了孙悟空角色的核心特质。‌ 对游戏市场的看法： 虽然六小龄童本人可能不直接涉及游戏市场，但从一般公众人物的角度，他可能会关注《黑神话：悟空》的市场表现，包括其是否能够成功吸引玩家、推动国产游戏的发展等。 对游戏氛围和风格的接受度： 《黑神话：悟空》以其黑暗阴沉的氛围和严肃的基调著称。对于六小龄童来说，这种风格可能与他所熟悉的央视版《西游记》的轻松幽默有所不同，但他也可能会欣赏游戏在视觉和氛围上的创新尝试。‌ 综上所述，虽然没有直接的证据表明六小龄童对《黑神话：悟空》有具体的评价，但根据他的过往言论和对孙悟空角色的理解，可以推测他可能会对该游戏在角色塑造、改编尊重度以及市场表现等方面给予一定的关注和认可。如果游戏受到广泛好评和期待，六小龄童可能会更加关注并可能给予正面评价。
此外，值得注意的是，《黑神话：悟空》作为一款备受瞩目的国产游戏，其质量和市场表现都将成为衡量其成功与否的重要标准。无论六小龄童或其他公众人物如何看待这款游戏，最终的评价权还是掌握在广大玩家和市场的手中。
黑神话悟空苹果电脑可以玩吗 在苹果电脑上玩游戏可能会遇到一些限制，例如缺乏官方的Mac版本支持。为了在Mac上运行游戏，用户可能需要采用一些间接的方法，如使用虚拟机或兼容层来运行Windows版本。
一、使用虚拟机 借助 Parallels Desktop (PD虚拟机)可在Mac上流畅的运行 2000+的 Windows 应用程序，可用于工作、开发、学习、测试和玩游戏等。畅享 Windows 完全集成到 Mac 环境中所带来的绝佳性能，体验 macOS 和 Windows 的最优性能，解锁强大性能和无缝交互。
如果你想要运行大量或复杂的Windows应用程序和游戏，而且不介意安装Windows系统和占用更多的资源，那么虚拟机可能是一个更方便的选择。
你可以通过下方链接免费体验Parallels Desktop
Parallels Desktop19中文免费安装包（标准版）：https://souurl.cn/xmgwMz
Parallels Desktop19激活码：
6J9QPJ-EV13PZ-KKNMBP-NTTFHT-4TZSJK
3V7MQH-KX7E9H-32P7F3-YCK9DJ-ZWCWFD
二、使用CrossOver CrossOver（CrossOver Mac）是一种在Mac上直接运行Windows应用程序而不需要安装Windows系统的方法。CrossOver利用了Wine这个开源项目，可以模拟Windows API来执行Windows应用程序。CrossOver的优点是可以节省硬盘空间、内存和CPU资源，不需要购买Windows许可证，而且可以与Mac OS更好地集成。
事实上，CrossOver是一种非常轻便和高效的方法，它可以让你在Mac上享受Windows的优势，同时也不失去Mac的特色。只需要你下载并安装CrossOver本身，然后在其界面上选择你想要运行的Windows应用程序。CrossOver会自动为你配置好所需的环境，并且在Mac上打开一个窗口来运行该应用程序。
你可以通过下方链接免费体验CrossOver：
CrossOver24 Mac中文免费安装包：https://souurl.cn/mWK48N
CrossOver24激活码：
86V-CKVB-YT6V-JBEDFWHW
87A-VS6H-GTUC-6ZXM4JMK
以上阐述了在苹果电脑玩《黑神话：悟空》的两种方法。因《黑神话：悟空》还未正式发售，以上方法仅作为理论支持，苹果电脑的性能和硬件兼容性也是需要考虑的因素。尽管如此，通过适当的配置和努力，玩家仍然可以在Mac上体验到《黑神话：悟空》这款备受期待的游戏。‌
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6bad76bb80eb7d65a2aa25cc904629/" rel="bookmark">
			GaussDB关键技术原理|高可用：逻辑复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GaussDB关键技术原理|高可用：DCF&amp;双集群容灾从DCF与双集群容灾技术两方面对GaussDB的高可用能力进行了介绍，本篇将从逻辑复制方面继续解读GaussDB高可用能力。
目录
3 逻辑复制
3.1 基本概念
3.2 逻辑解码
3.3 备机解码
3.4 并行解码
3.5 一致性解码
3.6 分布式解码
3 逻辑复制 逻辑复制属于数据复制服务（Data Replication Service，简称DRS）一种，是一种易用、稳定、高效的数据库迁移和数据库同步。逻辑复制由逻辑解码和数据复制两部分组成，逻辑解码输出以事务为单位组织的逻辑日志，业务或数据库中间件对逻辑日志进行解析回放并最终实现数据复制。逻辑复制对目标数据库的形态限制较少，支持异构数据库、同构异形数据库，且同步期间目标库可读可写。另一方面，相比数据迁移工具定期同步数据逻辑复制数据同步时延低，提供实时数据复制的能力。
众所周知，在不同选型数据库或数据库不同版本间，通常在物理日志、数据存储格式等方面存在差异，差异导致无法在物理层面实现数据复制。逻辑复制解析事务物理日志（数据及其操作记录）抽取具有类SQL的逻辑日志，通过逻辑日志重放屏蔽源和目标数据库物理差异从而实现数据同步。例如 GaussDB 解析WAL日志，通过DRS工具转为SQL发送到 Oracle 执行，完成GaussDB和Oracle这种异构数据库之间数据备份，如图所示。
端到端的逻辑复制分成三部分：
解码源端事务物理日志从中抽取业务操作对应的逻辑日志。
DRS工具将逻辑日志转换/变型成目标端支持的SQL/调用。
目标端接收DRS转换的SQL/调用并高效执行实现数据复制。
值的注意的是，逻辑复制不是“SQL”复制，而是复制SQL操作的结果。异构数据库的逻辑复制一般都通过SQL标准语法作为中间桥梁（共同理解的语言），从而实现异构数据库间的等价语义传递。
物理复制和逻辑复制各有优劣，分别有其适用的业务场景。逻辑复制使用场景和优点主要体现在灵活、细粒度、双向、异构等，适用场景但不限于：关键数据备份（细粒度复制）、数据分发/合聚复制、异构数据在线迁移、大版本滚动升级、数据抢救找回、数据异地容灾等。但在低时延、低损耗、读写分离等一致性要求非常严格的场景，建议选择物理复制。
对于逻辑复制特性，GaussDB聚焦于物理日志到逻辑日志的解码转换(提供CDC所需要的基础设施)，提供多种逻辑日志格式以便于二次开发，以及提升逻辑解码和日志重放性能来降低复制时延，保证数据同步的时效性和一致性。如图所示，GaussDB针对异构数据库间逻辑复制（蓝色链路）仅提供“逻辑解码”基础能力，DRS等数据库中间件处理逻辑日志并适配目标数据库回放，协同构建完整的逻辑复制。而同构的GaussDB之间通过发布订阅（黄色链路）特性承载，消除逻辑日志中转和翻译等，实现更高效更低时延的逻辑复制。
3.1 基本概念 复制行标识（Replica ID）
数据库复制技术进行数据同步时用于标识数据库中复制的行或记录的唯一标识符。该标识可以是一个自增数字、全局唯一的UUID或其他形式，例如：逻辑日志主键列集或者唯一索引列集。
复制行标识的主要作用包括：
数据一致性：通过复制行标识确保不同的数据库实例之间复制的行唯一性和一致性，避免数据冲突和重复复制。
冲突解决：复制行标识定位冲突行，依据行不同内容识别正确的版本。
同步跟踪：根据行标识确定哪些行已经被复制，哪些行还未被复制。
GaussDB逻辑复制的行标识通过ALTER TABLE .. REPLICA IDENTITY指定四种复制行标识：
DEFAULT记录主键列的旧值，没有主键则不记录。
USING INDEX记录索引列的旧值，索引必须是全局唯一的、不可延迟的，并且索引列含有NOT NULL约束。
FULL记录该行中所有列的旧值。
NOTHING不记录有关旧行的信息。
逻辑复制源
逻辑复制源是逻辑复制中同步的数据库实例、库或表，通过解析和重放逻辑日志，将源数据库的数据变更复制到目标数据库。逻辑复制的源与目标之间可以是主从关系，也可以是多对多的关系；多对多关系意味着源和目标之间可以相互复制。通过给逻辑复制源赋予一个标识，重放设置逻辑日志来自的逻辑复制源标识，解码过滤重放物理日志的逻辑日志，从而避免循环无限复制。
GaussDB逻辑复制源使用流程：
pg_replication_origin_create()创建复制源。
pg_replication_origin_session_setup()设置会话重放逻辑日志的复制源。
逻辑解码指定启动选项only-local过滤重放会话的逻辑日志。
补充日志
解码补充日志(Supplemental Logging)并不是独立的一种日志，它是对重做记录中变更内容的补充，增加的信息量以满足逻辑解码的基本要求或增强功能。若缺少解码补充日志，逻辑解码将无法正常工作。补充日志通常有：行标识、版本信息、事务用户等。GaussDB通过GUC参数WAL_LEVEL=logical调整物理日志记录级别，配置系统记录解码补充日志(重启生效) 。同时,该参数生效时阻塞AUTO VACCUM提前回收系统表中逻辑解码依赖的旧版本对象信息(被删除行)。
增量复制
相对全量复制，增量复制仅仅处理全量后被修改的增量(插、删、改)数据。逻辑解码通过解析增量的物理日志提取逻辑操作，提供一套完整的全量和增量数据的衔接,保证逻辑复制的数据完整性。GaussDB创建逻辑复制槽用于新建一个逻辑解码任务，返回的查询快照可以用于构建解码相关的全量复制数据。
3.2 逻辑解码 逻辑解码是一项数据库技术，用于将数据库的事务日志解析为易于理解和处理的格式。它允许用户对数据库操作进行实时监控、数据变更跟踪和数据复制等应用。当启用逻辑解码时，GaussDB将每个事务的基本操作和解码辅助信息记录到事务日志中，并以一种结构化的方式存储。这些事务(物理)日志包含数据库中发生的所有数据变更的细节，包括插入、更新和删除等操作，同时包含了诸多用户理解不友好的数据库内部细节和特有实现。逻辑解码通过输出格式插件形式将这些事务日志解析为易于理解的格式，例如JSON或自定义二进制格式等多种更高级别的事件或操作，使得用户可以根据自身需求来解析和处理这些数据变更事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6bad76bb80eb7d65a2aa25cc904629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81678829387a9d04c835aa687887358/" rel="bookmark">
			Minio多主机分布式 docker-compose 集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 docker-compose搭建多主机分布式minio - 会bk的鱼 - 博客园 (cnblogs.com)
【运维】docker-compose安装minio集群-CSDN博客
Minio 是个基于 Golang 编写的开源对象存储套件，虽然轻量，却拥有着不错的性能
中文地址：MinIO | 用于AI的S3 &amp; Kubernetes原生对象存储
官网地址：MinIO | High Performance, Kubernetes Native Object Storage
对象存储服务（Object Storage Service，OSS）是一种海量、安全、低成本、高可靠的云存储服务，适合存放任意类型的文件。容量和处理能力弹性扩展，多种存储类型供选择，全面优化存储成本。当然 Minio 除了直接作为对象存储使用，还可以作为云上对象存储服务的网关层，无缝对接到 Amazon S3、MicroSoft Azure。
一 准备工作
1、三台机器 配置 vim /etc/hosts
192.168.1.244 minio4
192.168.1.243 minio3
192.168.1.242 minio2
验证
查看docker
查看 docker-compose -v
如果没有则安装 sudo yum install docker-compose
二、编写docker-compose.yml 文件
整体目录结构如下：
希望 nginx 在243上
有两个类型的docker-compose.yml （带nginx和不带nginx的），具体如下
1、不带nginx（242和244）
version: "3" services: minio: image: quay.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e81678829387a9d04c835aa687887358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e340ba2b17550bdc160b284cb088b12d/" rel="bookmark">
			黑马头条Day09-用户行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、课前准备 1. long类型精度丢失问题 解决方案：
当后端响应给前端的数据中包含了id或者特殊标识（可自定义）的时候，把当前数据进行转换为String类型当前端传递给后端的dto中有id或者特殊标识（可自定义）的时候，把当前数据转为Integer或Long类型。 解决步骤：
①把课前资料里的jackson包拷贝放到heima-leadnews-common模块下
序列化和反序列化说明：
ConfusionSerializer：用于序列化自增数字的混淆 public class ConfusionSerializer extends JsonSerializer&lt;Object&gt; { @Override public void serialize(Object value, JsonGenerator jsonGenerator, SerializerProvider serializers) throws IOException { try { if (value != null) { jsonGenerator.writeString(value.toString()); return; } }catch (Exception e){ e.printStackTrace(); } serializers.defaultSerializeValue(value, jsonGenerator); } } ConfusionDeserializer：永续反序列化自增数字的混淆解密 public class ConfusionDeserializer extends JsonDeserializer&lt;Object&gt; { JsonDeserializer&lt;Object&gt; deserializer = null; JavaType type =null; public ConfusionDeserializer(JsonDeserializer&lt;Object&gt; deserializer, JavaType type){ this.deserializer = deserializer; this.type = type; } @Override public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException{ try { if(type!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e340ba2b17550bdc160b284cb088b12d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8b57ca4dd0e8d7dd96c906489c125e/" rel="bookmark">
			【保姆级教程】免费域名注册 &amp; Cloudflare 域名解析 &amp; Ngnix端口转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间，带大家搞了两台云服务器：
玩转云服务：Oracle Cloud甲骨文永久免费云服务器注册及配置指南玩转云服务：手把手带你薅一台腾讯云服务器，公网 IP 基于这两台云服务器，我们玩转了很多有趣的开源项目：
手把手带你搭建免费的人脸检测/识别系统本地部署大模型？Ollama 部署和实战，看这篇就够了 不过上述这些应用都是通过 IP +端口号的方式访问的，非常不利于传播~
这时你需要的就是一个域名，以及把域名翻译成 IP 的服务。
通常各大云厂商都提供域名注册服务，不过域名注册是需要付费的。
如果你只是想搞个来玩玩，又不想花这个钱？
好在有一些二级域名可以白嫖~
本文将带大家：注册一个免费域名，并通过 Cloudflare 实现免费的域名解析，让小伙伴们通过域名就能访问你的网站！。
1.免费域名注册 免费的域名网站有不少，不过随着大家将白嫖进行到底的精神，很多都不能用了。
最常见的就是 eu.org，由Paul Mockapetris 在1996年创建，是为了给没有资金买域名的个人或组织提供永久免费的域名。不过，状态一直处于审核中 == 没通过~
传送门：https://nic.eu.org/，感兴趣的小伙伴可以去试试，有成功的评论区告诉我哦~
接下来介绍的这个，亲测注册成功，带着大家走一遍流程。
传送门：https://nic.us.kg/
首先，测试一下你想要注册的域名，是否已被占用，然后点击下面的立即注册，用邮箱创建一个账号（国内邮箱即可）。
账号注册有几种方式，我这里选择的是填写 github issue 申请，大概不到 1 小时就通过了，邮件名称为 GitHub KYC Approved，通过后即可前往申请域名。
注册成功后，点击域名注册。
如果没被注册过，它会提示你，你只需要180天后续订下一年，就可以一直使用下去。
下面两个必填的 Name Server 是什么鬼？
这里是让你填：用于 域名解析 的域名服务器。
什么是域名解析：通过将域名映射到特定的IP地址，使得用户能够通过域名轻松访问你的网站 or 服务。而域名解析，需要由域名服务器来执行。
Cloudflare 是一个知名的云服务提供商，提供免费的域名解析服务，同时也提供域名注册服务，不过需要付费。
所以，我们就以 Cloudflare 为例，给大家展示如下如何拿到域名服务器。
2.免费域名解析 2.1 获取域名服务器 首先，前往 https://www.cloudflare.com 注册一个账号。
然后，点击最上方的 添加站点。
输入你刚注册的域名，点击 继续。
选择这里的 free 计划（付费的服务暂时还用不到），点击 快速扫描。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8b57ca4dd0e8d7dd96c906489c125e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaef56f4c926fea8b821eb6af5881910/" rel="bookmark">
			从分布式存储到持久卷：【Cloud Native】存储的进化与实战策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐇明明跟你说过：个人主页
🏅个人专栏：《未来已来：云原生之旅》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、云原生概念简述
2、存储在云原生环境中的重要性 二、云原生存储概述
1、云原生存储的定义与特性 2、与传统存储架构的对比 三、云原生存储的解决方案
1、持久卷（Persistent Volumes）
1.1、概念与工作原理
1.2、在Kubernetes中的应用案例 1.2.1、PV创建
1.2.2、PVC创建
1.2.3、在Pod中调用
1.2.4、工作原理
2、分布式存储系统
2.1、Ceph、GlusterFS、Rook等
2.2、分布式存储的优势与挑战
一、引言 1、云原生概念简述 云原生（Cloud Native）是一个近年来在云计算领域备受关注的概念，它代表了一种构建和运行应用程序的新型技术体系和方法论。
定义：
云原生是一种将应用程序设计、开发、部署和管理与云计算环境紧密结合的理念。它强调应用程序从设计之初就应当考虑到云的环境，充分利用云平台的弹性、分布式和自动化优势。云原生不仅仅是简单地将应用迁移到云上，而是利用云原生技术重新构思和设计应用，使其能够更高效地运行和扩展。
核心特点：
容器化：云原生应用通常采用容器化技术，如Docker，将应用程序及其所有依赖打包到一个独立的运行环境中，保证应用在不同环境中运行的一致性。容器化技术提高了应用的可移植性、可部署性和隔离性。微服务架构：云原生应用倾向于采用微服务架构，将应用拆分为一系列小的、独立的服务单元，每个服务专注于独立的业务功能。这种架构提高了应用的灵活性、可扩展性和可维护性。DevOps与持续交付：云原生应用强调DevOps文化和持续交付方法，通过自动化构建、测试和部署流程，实现快速迭代和频繁更新。这种敏捷的开发和交付方式使得应用能够更快地响应市场需求和用户反馈。 2、存储在云原生环境中的重要性 1. 数据持久性和一致性：
应用程序的容器可以快速启动和销毁，但数据需要持久保存。云原生环境中的存储解决方案（如持久卷）确保数据不会因容器的生命周期而丢失，并且在多节点、多区域中保持一致性。 2. 高可用性和灾备：
云原生存储通常具有内置的高可用性和灾难恢复机制。通过多副本、数据分片和地理分布，确保数据在硬件故障、网络中断或其他灾难情况下仍能被快速恢复和访问。 3. 扩展性：
随着应用程序和数据量的增长，存储解决方案需要具备横向扩展能力。云原生存储利用云平台的弹性资源，实现无缝扩展，满足动态的存储需求。 4. 性能优化：
云原生存储系统通常提供多种存储类型（如对象存储、块存储、文件存储）和不同的性能等级，以满足不同应用的需求。根据具体的工作负载特性，可以选择合适的存储类型和优化策略，提高数据访问和处理的效率。 二、云原生存储概述 1、云原生存储的定义与特性 定义
云原生存储是一种存储架构，专门为在容器化、微服务和动态编排环境中运行的应用程序而设计。它支持自动化管理和动态扩展，能够满足云原生应用的高性能、高可用性和高弹性的需求。
特性
1. 弹性和可扩展性：
支持根据需求动态扩展和缩减存储容量和性能，适应应用负载的变化。能够在多租户环境中隔离资源，确保资源分配的公平性和效率。 2. 自动化管理：
提供自动化的存储配置、管理和优化功能，减少手动干预。支持通过API进行存储资源的动态管理，便于与DevOps流程和工具集成。 3. 高性能：
支持不同的存储类型（如块存储、文件存储、对象存储）和性能层次，以满足不同应用的需求。提供低延迟、高吞吐量的数据访问性能，适应高并发的访问请求。 4. 可编排性：
深度集成容器编排系统（如Kubernetes），支持持久卷（Persistent Volumes, PV）和持久卷声明（Persistent Volume Claims, PVC）等资源类型的管理。支持存储类（StorageClass）定义，简化不同存储配置的使用。 5. 成本优化：
提供按需付费模式，帮助企业优化存储成本。支持数据生命周期管理，将不常用的数据转移到成本更低的存储层。 2、与传统存储架构的对比 云原生存储：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaef56f4c926fea8b821eb6af5881910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6202b56dcc3318de861c87d9172e1b/" rel="bookmark">
			Java中的网络编程：从Socket到NIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的网络编程：从Socket到NIO
大家好，我是微赚淘客系统3.0的小编，是个冬天不穿秋裤，天冷也要风度的程序猿！今天我们来探讨Java中的网络编程，从基础的Socket编程到更高级的NIO（New Input/Output）编程。
一、Socket编程
Socket是Java网络编程的基础，它提供了连接两个节点之间通信的机制。使用Socket，我们可以实现客户端和服务器之间的数据传输。
服务器端代码示例 package cn.juwatech.networking; import java.io.IOException; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8080)) { System.out.println("Server is listening on port 8080"); while (true) { Socket socket = serverSocket.accept(); System.out.println("New client connected"); OutputStream output = socket.getOutputStream(); output.write("Hello, client!".getBytes()); socket.close(); } } catch (IOException e) { e.printStackTrace(); } } } 客户端代码示例 package cn.juwatech.networking; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c6202b56dcc3318de861c87d9172e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4887f7aec0ffd103cfb83e5c42044a4d/" rel="bookmark">
			使用Micronaut构建高性能微服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Micronaut构建高性能微服务
大家好，我是微赚淘客系统3.0的小编，是个冬天不穿秋裤，天冷也要风度的程序猿！Micronaut是一个现代化的Java框架，用于构建高性能、易于维护的微服务。它在设计时考虑了低内存消耗和快速启动时间，非常适合构建高效的微服务架构。本文将介绍如何使用Micronaut构建高性能的微服务，涵盖从基本配置到实际编码的各个方面。
一、Micronaut简介
Micronaut是一个全栈微服务框架，支持Java、Kotlin和Groovy。它提供了依赖注入、AOP（面向切面编程）和配置管理等功能，旨在解决传统Java框架中的性能瓶颈。Micronaut的主要特点包括：
快速启动时间：与Spring Boot等框架相比，Micronaut启动更快。低内存消耗：通过编译时依赖注入减少了运行时开销。支持微服务架构：内置支持服务发现、配置管理等功能。 二、创建Micronaut项目
你可以使用Micronaut CLI或Micronaut Launch来创建新的项目。以下是使用Micronaut CLI创建项目的步骤：
mn create-app com.example.demo --build=maven --lang=java 这将生成一个包含基本配置的Micronaut项目。接下来，我们将实现一个简单的微服务应用。
三、编写基本的微服务
创建控制器
在Micronaut中，控制器用于处理HTTP请求。创建一个名为HelloController的控制器类，示例代码如下：
package cn.juwatech.example; import io.micronaut.http.annotation.Get; import io.micronaut.http.annotation.Controller; @Controller("/hello") public class HelloController { @Get("/") public String index() { return "Hello, Micronaut!"; } } 这个控制器将处理/hello路径上的GET请求，并返回一个简单的字符串。
配置应用程序
Micronaut的配置文件位于src/main/resources/application.yml。你可以在这里设置应用程序的各种配置项。例如：
micronaut: application: name: demo server: port: 8080 上述配置将应用程序的端口设置为8080。
四、实现服务注册和发现
Micronaut支持与服务注册和发现工具（如Consul和Eureka）集成。下面是如何将Micronaut应用程序注册到Eureka服务器的示例。
添加Eureka依赖
在pom.xml中添加Eureka客户端的依赖：
&lt;dependency&gt; &lt;groupId&gt;io.micronaut.discovery&lt;/groupId&gt; &lt;artifactId&gt;micronaut-discovery-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.micronaut.eureka&lt;/groupId&gt; &lt;artifactId&gt;micronaut-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; 配置Eureka
在application.yml中配置Eureka客户端：
micronaut: application: name: demo-service eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 以上配置将应用程序注册到本地运行的Eureka服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4887f7aec0ffd103cfb83e5c42044a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b6cce7b10f9db91efe34efa766ffa42/" rel="bookmark">
			在一系列图像中搜索局部可变形模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dev_update_off ()
read_image (ModelImage, ‘food/cocoa_package_model’)
dev_close_window ()
dev_open_window_fit_image (ModelImage, 0, 0, -1, -1, WindowHandle)
set_display_font (WindowHandle, 16, ‘mono’, ‘true’, ‘false’)
*
Create and display the local deformable model
create_local_deformable_model (ModelImage, ‘auto’, rad(-15), rad(30), ‘auto’, 1, 1, ‘auto’, 1, 1, ‘auto’, ‘none’, ‘use_polarity’, [40,60], ‘auto’, [], [], ModelID)
get_deformable_model_contours (ModelContours, ModelID, 1)
area_center (ModelImage, Area, Row, Column)
hom_mat2d_identity (HomMat2DIdentity)
hom_mat2d_translate (HomMat2DIdentity, Row, Column, HomMat2DTranslate)
affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)
dev_set_line_width (2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b6cce7b10f9db91efe34efa766ffa42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc21cee0f7ee44cadb017aa4ae85566/" rel="bookmark">
			科普文：深入理解ElasticSearch体系结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概叙 Elasticsearch是什么？ Elasticsearch（简称ES）是一个分布式、可扩展、实时的搜索与数据分析引擎。ES不仅仅只是全文搜索，还支持结构化搜索、数据分析、复杂的语言处理、地理位置和对象间关联关系等。
官网地址：Elastic — The Search AI Company | Elastic
ES具有如下特点：
一个分布式的实时文档存储引擎，每个字段都可以被索引与搜索一个分布式实时分析搜索引擎，支持各种查询和聚合操作能胜任上百个服务节点的扩展，并可以支持PB级别的结构化或者非结构化数据 ElasticSearch（弹性搜索）：是一款开源的分布式、RESTful 风格的搜索和数据分析引擎，它底层基于 Apache Lucene 开源库进行封装，其不仅仅提供分布式多用户能力的全文搜索引擎。
ElasticSearch 搜索整体架构如下图所示：
ElasticSearch特点 优点：
1、天生分片，天生集群，从ES出生开始就天然的支持分布式的特征，且无需第三方组件，自带。
2、天生索引，ES 所有数据都是默认进行索引的，这点和mysql正好相反，mysql是默认不加索引，要加索引必须特别说明，ES只有不加索引才需要说明。
3、支持PB级海量数据实时全文搜索。
4、支持多语言访问，支持TCP和RESTful API两种方式访问。
缺点
1、不适合做复杂聚合，会影响ES集群性能。
2、不支持高并发写入数据。
3、ES耗CPU和内存资源，需要用高配置的机器来搭建集群，使用成本比较高。
elasticsearch的作用 elasticsearch（es）是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容。例如在以下的应用场景中，都会使用到es
在Github上搜索代码在电商网站搜索商品在百度搜索答案在打车软件搜索附近的车（具体这个为什么后续系列会详细说明的） ES 的版本问题 在决定使用 Elasticsearch 的时候首先要考虑的是版本问题，Elasticsearch (排除 0.x 和 1.x)目前有如下常用的稳定的主版本：2.x，5.x，6.x，7.x(current)。
你可能会发现没有 3.x 和 4.x，ES 从 2.4.6 直接跳到了 5.0.0。其实是为了 ELK(ElasticSearch，Logstash，Kibana)技术栈的版本统一，免的给用户带来混乱。
在 Elasticsearch 是 2.x (2.x 的最后一版 2.4.6 的发布时间是 July 25, 2017) 的情况下，Kibana 已经是 4.x(Kibana 4.6.5 的发布时间是 July 25, 2017)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc21cee0f7ee44cadb017aa4ae85566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3377d40bab102ff52abcd29f56a55602/" rel="bookmark">
			Bugku-ctf-web-eval
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__); ?&gt; include "flag.php"; 这行代码尝试包含一个名为flag.php的文件。这个文件可能包含一些配置信息或其他代码，但是没有提供这个文件的内容，所以无法确定它的作用。
$a = @$_REQUEST['hello']; - 这行代码尝试从$_REQUEST全局数组中获取名为hello的变量。@符号用来抑制错误报告，即使hello参数不存在，也不会显示错误信息。
eval("var_dump($a);"); - 这是最危险的部分。eval函数执行字符串作为PHP代码。在这个例子中，它执行了var_dump($a);，这将打印变量$a的内容。然而，如果$a是由用户输入的，那么用户可以提交任何PHP代码作为hello参数，这将被eval执行，可能导致严重的安全问题。
show_source(__FILE__); - 这行代码显示当前文件的源代码。
isset() 函数在 PHP 中用于检查变量是否已设置并且非 NULL。如果变量存在并且不是 NULL，isset() 会返回 true；否则，返回 false。这个函数常用于确保在尝试使用变量之前，该变量已经被定义。
var_dump() 是 PHP 中一个非常有用的函数，用于输出一个或多个表达式的类型和值。当你想要调试或检查变量的内容时，var_dump() 可以提供详细的信息。以下是 var_dump() 函数的一些关键点：
输出信息：var_dump() 会输出变量的类型和值。如果变量是数组或对象，它还会递归地显示其内部结构。
多参数：var_dump() 可以接受多个参数，并且会依次输出每个参数的类型和值。
返回值：尽管 var_dump() 主要用于调试，但它实际上也会返回输出的字符串，但通常这个返回值被忽略了。
输出格式：var_dump() 的输出通常是易读的，但不是格式化的 HTML。如果你想要格式化的输出，可以使用 var_export() 函数。
调试工具：var_dump() 是开发者在开发过程中常用的调试工具之一，尤其是在不确定变量内容时。
$a = array(1, 2, 3); $b = null; $c = "Hello, World!"; var_dump($a); // 输出：array(3) { [0]=&gt; int(1) [1]=&gt; int(2) [2]=&gt; int(3) } var_dump($b); // 输出：NULL var_dump($c); // 输出：string(13) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3377d40bab102ff52abcd29f56a55602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2fdb24424dd940656b9db797115f89/" rel="bookmark">
			【Python数值分析】革命：引领【数学建模】新时代的插值与拟合前沿技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
第一部分：插值的基本原理及应用
1. 插值的基本原理
1.1 插值多项式
1.2 拉格朗日插值 1.3 牛顿插值 1.4 样条插值
2. 插值的Python实现
2.1 使用 NumPy 进行插值
2.2 使用 SciPy 进行插值
2.2.1 一维插值
​编辑
2.2.2 二维插值
3. 插值的应用场景
3.1 数据平滑和填补
3.2 图像处理
​编辑
3.3 数值模拟
4. 实例分析
实例1：空气质量数据的校准
​编辑
实例2：波浪能最大输出功率设计
第二部分：拟合的基本原理及应用
1. 拟合的基本原理
1.1 线性拟合
1.2 多项式拟合
1.3 指数拟合
​编辑
1.4 对数拟合
​编辑
1.5 幂函数拟合
2. 拟合的Python实现
2.1 使用 SciPy 进行拟合
2.1.1 线性拟合
2.1.2 多项式拟合
2.1.3 指数拟合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2fdb24424dd940656b9db797115f89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8b7f2686a2dd20f2ae5e60a93198bb/" rel="bookmark">
			CSV表格拆分指南：让你的数据管理更高效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否曾经面对过一堆庞大的CSV文件，不知道如何快速有效地管理和拆分？在这篇文章中，我将为你详细讲解几种有效的CSV表格拆分方法，帮助你更高效地管理数据。无论你是数据分析小白还是经验丰富的从业者，都可以找到适合自己的解决方案。
方法一：使用一键表格合并助手 一键表格合并助手是一款由“勤学道人”开发的高性能工具，专为需要快速合并和拆分表格的用户设计。这款工具的界面非常友好，即使是数据处理的新手也能轻松上手。
优势： 可视化界面，操作简单，只需选择表格文件后，一键转码。多线程快速合并，表越多优势越明显。支持Python处理大表，可处理千万条数据的大表，表越大优势越明显。 劣势： 需要下载安装特定软件。可能对系统配置有一定要求。 特色功能： 支持单表千万量级拆分。支持批量拆分。支持带表头拆分。高性能：基于Python应用，支持多线程。 使用演示：视频最后又领取方法 可以参考我之前发布的视频，详细了解操作步骤。
csv拆分
想要玩一下这个工具，点点赞、点点关注找我要一下哦。
图文演示：
方法二：使用Excel进行CSV拆分 Excel是大家非常熟悉的办公软件，虽然它并不专门为处理大数据而设计，但在处理中小规模的CSV文件时，Excel依然是一个非常方便的工具。
优势： 界面友好，操作简单，适合数据处理小白。功能丰富，支持多种数据处理操作。无需编写代码，直接使用鼠标操作即可。 劣势： 处理大表时性能较差，可能会因为数据量过大而崩溃。不支持多线程，速度较慢。 步骤： 打开Excel，导入CSV文件。使用分列功能将数据拆分到不同的列。根据需要将数据复制到新的工作表或工作簿中。 方法三：使用Python编写脚本进行CSV拆分 对于需要处理大量数据的用户，使用编程语言Python编写脚本是一个高效的解决方案。Python拥有丰富的数据处理库，如Pandas，可以轻松实现CSV文件的拆分。
优势： 高性能，支持处理千万条数据的大表。灵活性高，可以根据需求自定义拆分规则。支持多线程，提高处理速度。 劣势： 需要具备一定的编程基础，不太适合数据处理小白。需要安装Python环境和相关库。 示例代码： python
复制
import pandas as pd # 读取CSV文件 df = pd.read_csv('data.csv') # 根据某一列的值拆分成多个文件 unique_values = df['column_name'].unique() for value in unique_values: df_subset = df[df['column_name'] == value] df_subset.to_csv(f'data_{value}.csv', index=False) 方法四：使用VBA宏在Excel中拆分CSV 如果你习惯使用Excel，又希望实现自动化处理，可以使用VBA宏来拆分CSV文件。VBA宏能够在Excel中运行自动化操作，适合不想编写Python代码的用户。
优势： 可以在Excel中直接运行，无需安装额外的软件。自动化操作，提高工作效率。适合中小规模数据处理。 劣势： 需要编写VBA代码，虽然简单但依然需要学习。处理大表时性能较差，速度较慢。 示例代码： vba
复制
Sub SplitCSV() Dim ws As Worksheet Dim wsNew As Worksheet Dim lastRow As Long Dim i As Long Dim uniqueValues As Collection Dim value As Variant Set ws = ThisWorkbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8b7f2686a2dd20f2ae5e60a93198bb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/98/">«</a>
	<span class="pagination__item pagination__item--current">99/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/100/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>