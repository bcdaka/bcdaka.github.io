<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d0434b812c2bb24096f48a65d509ec/" rel="bookmark">
			【error】找不到或无法加载主类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 报错信息问题分析解决方案 报错信息 重新拉取代码后，运行时报错：找不到或无法加载主类
问题分析 找不到或无法加载主类的问题通常是因为Java虚拟机无法找到或加载主类。这个问题的原因可能有很多种，以下几种情况较为常见：
主类文件不存在：如果主类文件不存在或文件名不正确，Java虚拟机就无法找到或加载该主类。
主类不在类路径中：如果主类所在的路径不在类路径中，Java虚拟机也无法找到或加载该主类。可以尝试将主类所在路径加入类路径中。
编译错误：如果在编译主类时有错误，那么编译后的.class文件可能无法被Java虚拟机正确加载。
类名不匹配：Java中类名和文件名要求一致，如果文件名和类名不匹配，Java虚拟机也无法正确加载主类。
以上仅是一些常见情况，具体原因需要具体分析。如果你遇到了这个问题，可以首先确认主类文件是否存在并且文件名和类名是否匹配。如果仍无法解决问题，可以提供更具体的报错信息和相关代码，以便更好的排查问题。
解决方案 本人是清理了一下缓存就解决了，更多可参考：https://blog.csdn.net/l_mloveforever/article/details/112725753
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdb1f2276fa6c2e0129efc54ba3beaa/" rel="bookmark">
			java课程设计（学生信息管理系统设计）&#43;数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔍 🔎 本期带领大家一起来学习java课程设计（学生信息管理系统设计）+数据库的实现思路 🔍 🔎
文章目录 题目要求+数据库🌍一 、环境搭建🌍二 、功能实现 🌎 🌍1.学生信息类的创建✅2.学生信息的添加功能✅✅3.学生信息的删除功能✅✅✅4.学生信息的修改功能 ✅✅✅✅5.学生信息的查看功能✅✅✅✅✅ 三、主类的调用🌍 🌎 🌏1、 登录界面🛸2、 界面搭建🛸🛸 四、 Extents的相关善后操作🌎 🌏 🌎 🌏五、 数据库的连接🌍 🌎🌏 🌍 🌎 🌏六 、感谢与交流🌍 🌎 🌏 🌍 🌎 🌏 题目要求+数据库🌍 学生信息包括：学号，姓名，年龄，性别，出生年月，地址，电话，E-mail等。试设计学生信息管理系统，使之能提供以下功能：
1、系统以菜单方式工作
2、学生信息录入功能－－输入
3、学生信息浏览功能－－输出
4、学生信息查询功能－－算法
按学号查询
按姓名查询
5、学生信息的删除与修改(可选项)
一 、环境搭建🌍 在idea创建一个工程文件，在工程文件下创建一个model模块，在model模块下创建一个classSystem包，然后再存放对应的类，如下图所示
需要注意是因为连接了数据库，所以需要导入相应的jar包
二 、功能实现 🌎 🌍 1.学生信息类的创建✅ 首先实现这个学生信息管理系统，我们需要先创建一个学生信息类
，包括学生的学号，姓名，年龄，地址，电话，邮箱，出生日期，具体代码如下✈️ 🛫 🛬
package classSystem; public class Student { private int stuId; private String name; private int age; private String sex; private String birth; private String address; private String tel; private String Email; public Student() { } public Student(int stuId, String name, int age, String sex, String birth, String address, String tel, String email) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccdb1f2276fa6c2e0129efc54ba3beaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0594ab32b3749b746b65a950bd035a5/" rel="bookmark">
			【数据结构】——归并排序和计数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌇个人主页：_麦麦_
📚今日名言：繁华落尽，我心中仍有花落的声音。一朵，一朵，在无人的山间轻轻飘落。——席慕蓉《桐花》
目录
一、前言
二、正文
1.归并排序
1.1 基本思想
1.2【递归版】具体实现 1.3【递归版】代码部分 1.4【非递归版】具体实现 1.5【非递归版】代码部分 1.6特性总结
2.计数排序
2.1基本思路
2.2具体实现
2.3代码部分
2.4特性总结
三、结语
一、前言 在本篇文章中，将会为小伙伴们详细的讲解“归并排序”。不过说到这里，有的小伙伴可能就会说了标题中不是还有“计数排序”嘛，这到底是什么呢？其实在前文中我们所展现的关于排序的思维导图是属于比较排序的，而除了比较排序之外，另一类排序就是非比较排序。而计数排序恰恰是非比较排序中一类相对常见的排序，所以也拿出来向小伙伴们介绍啦！
那么比较排序和非比较排序的区别在什么地方呢？顾名思义，比较排序需要对元素进行比较从而得出符合预期的排序，而非比较排序则无须对元素进行比较就能够得到预期的排序。至于如何实现归并排序和计数排序，那么就好好往下看叭！
二、正文 1.归并排序 1.1 基本思想 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有 序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
简单来说，就是相比于直接让一个无序的序列变得有序，合并两个有序的序列要更为简单一些，因此我们就可以逐渐细分，将一个无序的序列分为两个序列，使这两个序列有序后再进行合并。但是这两个序列要如何有序呢，再将这两个序列分为四个序列，使这四个序列有序后，再进行合并……直至分解后的序列无法进行再分解，这时的序列中就只有一个元素了，与其余序列比较以及后面的合并也最为简单，这也是递归版的归并排序的大致思路。
下面就分别用动态图和分解图来帮助小伙伴们更好的理解叭！ 1.2【递归版】具体实现 那么这种思路体现在代码中，该如何实现呢。接下来我们就来讲讲递归版归并排序的代码思路。
在代码的书写中，大致分为两个模块，第一步是”归”，将大序列不断细分成两个小序列，第二个则是“并”，将小序列排好序后再将其合并。
那么具体该如何做呢？
在“归”这一步中，我们可以将这个序列不断对半分开，可以不是严谨的对半，由于我们本文是对数组进行归并排序，因此只需要将数组首元素和末尾元素的下标相加除以2即可作为分隔序列的边界。那么不断切分到什么时候为止呢？相信小伙伴们很容易答出当这个序列只有一个元素的时候就无须再切分了，因为此时它已经是“有序”了。
在“并”这一步中，大致有两步。首先是让两个序列有序，然后就是将两个有序序列合并。我们先来讲讲合并这一步，在两个序列已经有序的前提下，我们只需对两个序列从头一一比较即可，以升序为例，当序列一的首元素较小时，我们就将该元素取出，反之则取出序列而的元素，接下来重复以上操作即可，最后当两个序列的元素全部取出后，我们就会发现这个由两个序列的元素组成的新序列也是有序的。不过这都是建立要合并的两个序列是有序的前提下，那么要如何做到呢。其实是很简单的，由于我们将序列不断切分至只有一个元素，那么此时的序列就是有序的，而这些最小单位的序列合并后由上面可以知道定然也是有序了呀，这也就是归并排序的奥妙所在。
下面我们就以升序的代码为例：
1.3【递归版】代码部分 //归并排序[递归] void _MergeSort(int* arr, int begin, int end, int* tmp) { //区间只有一个元素 if (begin == end) return; int mid = (begin + end)/2; //左区间归并 _MergeSort(arr, begin,mid, tmp); //右区间归并 _MergeSort(arr, mid+1, end, tmp); //排序 int begin1=begin; int end1 = mid; int begin2 = mid+1; int end2 = end; int i = begin; while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { if (arr[begin1] &lt; arr[begin2]) tmp[i++] = arr[begin1++]; else tmp[i++] = arr[begin2++]; } while(begin1 &lt;= end1) tmp[i++] = arr[begin1++]; while (begin2 &lt;= end2) tmp[i++] = arr[begin2++]; //拷贝 memcpy(&amp;arr[begin], &amp;tmp[begin], sizeof(int) * (end-begin+1)); } void MergeSort(int* arr, int n) { //申请一个数组用于归并排序 int* tmp = (int*)malloc(sizeof(int) * n); if (tmp == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0594ab32b3749b746b65a950bd035a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89efbeb5a6315752744d807d05005a26/" rel="bookmark">
			如何用SPSS做logistic回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考教程：B站教程👈课讲的挺垃圾的，主要还是看pdf👈pdf其实也蛮垃圾的，主要还是看文献1和2
通过该例，我们尝试用年龄、肿瘤大小、肿瘤扩散等级来预测癌变部位的淋巴结是否含有癌细胞。
无法使用多元线性回归模型的原因，老师在这里提到“因为残差不满足正态性、无偏性、共方差性等假设”。（←也是一种思路，可以与之前从吴恩达老师那里学的思路进行比较。）
步骤1 步骤2 因变量自然就是癌变部位xxx，协变量在这里就相当于自变量的意思？通过百度的搜索，协变量应该是控制变量的感觉，但这里似乎就直接看作自变量了，暂且先这么认为。
可以通过该按钮将两个变量处理为交互项，放入该协变量组，不过本例中不涉及交互项。
如果想设立多个协变量组，可以通过上一页、下一页进行切换（应该就是设置自变量不同的模型？）
方法这里有7种不同的方法，其中输入就是协变量全部进入模型；向前/向后分别代表着向前/向后逐步法（应该涉及到逐步回归的方法），有条件/LR/瓦尔德，分别代表着将变量剔除出模型的不同依据（老师有进行简单说明但暂时听不懂，之后学了逐步回归相关的知识再回来看看）←记得参考pdf教程进行学习，老师解释的内容大多是pdf教程中的
下面的选择变量，应该就是可以选择一个变量来设置样本入选的规则，例如年龄小于50才可入选（但好像只能选择一个规则，假如说我要20&lt;年龄&lt;50就做不到？需要通过外部的选择个案来筛选？）
步骤3 之后点击右侧第一个按钮：分类，弹出上图所示的对话框，该对话框的作用在于能将一个多分类变量转换成多个二分类变量，也就是转换成哑变量（或称之为虚拟变量）。为什么要这么做呢？假如一个多分类变量的编码分别为0、1、2、3，放在同一个变量中进行回归，得到的回归系数是没有意义的（比如回归系数是10，那就代表1分类比0分类多了10，2分类比1分类多了10…实际情况中，每个分类的区别不会是像这样相同的，甚至正负都有可能不一样）。因此我们要将其转化为哑变量，才能放入回归模型中。不只是在logistic回归中，在其他回归例如多重线性回归里，遇到多分类变量也需要设置哑变量。更多拓展可见：文献1
下方更改对比的意思就是不同的哑变量的编码方式，不同编码方式的区别具体可见文献2，一般来说似乎用默认的“指示符”就可以了：
Indicator（指示对比）：用于指定某一分类为参照，指定的参照取决于Reference Category中选择Last还是First，即只能以该变量的第一类或者最后一类作为参照。Indicator为默认方法，也是我们最常用的设置参照类的方法。
假如说想要更改编码方式，就选中要更改的新方式后，点击“变化量”按钮（其实应该是变化change，软件的翻译出错了）
参考类别的意思是，在输出结果后以哑变量中哪个种类作为参照系。我们先来看一下这个变量：
那么在参考类别中选中“最后一个”的意思是，以“&gt;5厘米”作为参照系。后续输出结果时，我们能看到各个变量是否是显著的，而这种多分类变量则是进行分类变量内部水平的比较，例如“≤2cm”与“&gt;5cm”相比是否有显著差异，“2-5cm”与“&gt;5cm”是否有显著差异。这可以在结果观测中的块1——⑤方程中的变量 处看到。
设置完哑变量后点击“继续”
步骤4 接下来打开保存这一选项，预测值的框如上图所示，较好理解就不解释了，一般来说概率和组成员都可以勾起来，功能都很实用。
—————————————————————————————————————————————
接下来讲解“影响”这一框。
在PDF线性回归的章节中，对于cook距离和杠杆值的解释是：
百度百科对cook距离的解释是：
也就是说，cook距离是一个用于诊断个案中异常数据的指标，较大的cook距离表示该个案对回归模型（系数）的影响较大。（但影响较大就一定是异常值吗？）不过话又说回来，logistic回归模型中，回归系数的数学意义是什么呢？后续需要再研究一下→见本文结果观测3.⑤或《例解回归分析》P253
杠杆值的作用看起来似乎和cook距离相似，不过后者是测量对回归系数的影响，前者是测量对整体拟合效果的影响？这只是我自己的解读，暂未经过证实，有待后续考证。
DfBeta同样在线性回归的章节中有解释：
这看起来也就很好理解了。
————————————————————————————————————————————————————
接下来讲解“残差”这一框。
这里面的各个选项同样在PDF线性回归章节中有解释：
相当好理解。不过偏差是啥？对应的是删除吗？
根据视频演示，一般来说只需勾选如下几个：
步骤5 接下来打开选项，看“统计和图”这一栏：
根据PDF：
其中PDF的P434页解释了该拟合度/统计量的含义，也就是用来检测整个模型的拟合优度（注意该统计量的适用情况！！！）：
个案残差列表也相对好理解：
即输出离群值个案，还是所有个案的上述统计量
估值的相关性、迭代历史记录我不太理解，但看了各种文章似乎都没解释，也没勾上，就先不管了；而exp(B)就是置信区间，很好理解：
————————————————————————————————————————————————————————————
接下来看“输出”这一栏：
很好理解，一般是按默认的勾选“在每个步骤中”，但这真的不会输出太多表吗？
————————————————————————————————————————————————————————————
接下来看“步进概率”这一栏：
查了一下别的文章：
还是不太能很好地理解什么叫做“进入模型和从模型中剔除的依据”，在选择变量，还没有开始跑模型的时候已经做了一次显著性检验了吗？还是说只是单纯地，在跑完模型之后，看看各个自变量是否对因变量有显著影响，以p≤0.05作为有显著影响的标准，以p＞0.10作为没有显著影响的标准？←有待后续验证←已解决，见结果观测的第二个表
后续的几项相对好理解：
一般来说只要勾选以下这些，看别的文章也有多勾个置信区间的（本PDF也勾了）：
结果观测 文献1：完整的二元logistic回归spss教学
文献2：与文献1相互补充，使用同一数据集
↑以上两篇文献相当重要，之后的说明很大程度上也以它们为主，以PDF为辅（因为感觉PDF很多表都没说清楚）
1.输出表格的第一部分：回归前的情况概览 输出的表可以分为三大部分，第一大部分有三个表：
可以理解为在回归前进行的各种处理，其中第三个表就是解释虚拟变量设置的，总共分为三组，小于等于2cm的编为为(1,0)，有739个样本，其余如表所示同理可得。
——————————————————————————————————————————————————————————
2.输出表格的第二部分：起始块 块0：起始块，指的是模型中未纳入任何自变量，只有常数项时的输出结果。也可以称之为基线模型或无效模型。在起始块中一般我们只需要看第三个表，不过来都来了还是全介绍下。
①分类表 模型中只有常数项时，预测结果的正确率，本例为81.8%
②方程中的变量 解释第二个表之前我们需要先来了解一个瓦尔德统计量：
如图中所述，该统计量是用来检验各自变量与因变量之间是否存在显著的线性关系，这让我联想到了线性回归中要进行的两个检验——T检验与F检验，其中，F检验是检验整个模型的，而T检验则与此处的利用wald统计量进行的检验相似，用来检验各回归系数是否显著。
回到第二个表中来，由于P&lt;0.05，因此拒绝原假设，即β≠0，常数项不等于0。（不过由于未纳入其他变量，该表也是无意义的）
但要注意的是，除了PDF中所说的解释变量的系数绝对值较大时不适合用wald检验外，文献2还提到了存在共线性时同样不适合适用wald检验：
联想了一下T检验，听起来似乎确实如此。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89efbeb5a6315752744d807d05005a26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc51f1bb3bd0946fe385d7d31b6c50eb/" rel="bookmark">
			解决在Windows安装stable diffusion遇到“Torch is not able to use GPU”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决在Windows安装stable diffusion遇到“Torch is not able to use GPU”的问题 遇到的问题解决方法参考链接 遇到的问题 在Windows上安装stable diffusion的最后一步执行webui-user.bat时，提示了错误信息AssertionError: Torch is not able to use GPU; add --skip-torch-cuda-test to COMMANDLINE_ARGS variable to disable this check
具体错误代码如下：
venv "C:\Users\giray\stable-diffusion-webui\venv\Scripts\Python.exe" Python 3.10.6 (tags/v3.10.6:9c7b4bd, Aug 1 2022, 21:53:49) [MSC v.1932 64 bit (AMD64)] Commit hash: 67d011b Traceback (most recent call last): File "C:\Users\giray\stable-diffusion-webui\launch.py", line 110, in run_python("import torch; assert torch.cuda.is_available(), 'Torch is not able to use GPU; add --skip-torch-cuda-test to COMMANDLINE_ARGS variable to disable this check'"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc51f1bb3bd0946fe385d7d31b6c50eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9f6b51cd79c742a34f9713f1afe8e8/" rel="bookmark">
			’sass_binary_site‘ is not a valid npm option问题的产生原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‘sass_binary_site’ is not a valid npm option问题的产生原因及解决办法 问题背景： 在vscode终端进行node的install的时候会执行以下命令
npm config set registry https://registry.npm.taobao.org npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ npm config set phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/ 当执行到
npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ 的时候，控制台爆出这个错误
找了很多解决办法都不行，然后就麻爪了
问题原因： node版本和sass版本不符导致的，我用的node版本过高，安装后执行
node -v 可以查看node的安装版本
当时用的是18.16.0
解决办法： 把已安装node卸载，去Download | Node.js (nodejs.org)下载安装以前的版本
我下载的是14.21.3版本的，安装好后在cmd查看一下node版本，显示14.21.3就说明安装成功
回到vscode执行文章开始的三个命令，显示以下页面就是成功
问题完美解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e900e680a2f22ee97f94a0592cf9456/" rel="bookmark">
			Java 使用multipartFile对象解析Execl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需要使用 multipartFile 包 package org.springframework.web.multipart;
2.数据校验
public String exportVehicleViol(MultipartFile multipartFile) { try { //对前端传递的文件进行校验 if (multipartFile == null &amp;&amp; multipartFile.getSize() == 0) { return "文件上传错误，重新上传"; } //获取文件名称 判断文件是否为 Execl String filename = multipartFile.getOriginalFilename(); if (!(filename.endsWith(".xls") || filename.endsWith(".xlsx"))) { return "文件上传格式有误，请重新上传"; } List&lt;EhicleViolation&gt; ehicleViolations = null; InputStream inputStream = multipartFile.getInputStream(); //根据文件格式 对应不同的api解析 if (filename.endsWith(".xlsx")) { ehicleViolations = readXlsx(inputStream); } else { ehicleViolations = readXls(inputStream); } //数据保存 saveBatch(ehicleViolations); } catch (IOException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e900e680a2f22ee97f94a0592cf9456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee60a5301cf0d64fd9854763794f9cd/" rel="bookmark">
			从YOLOv1到YOLOv8的YOLO系列最新综述【2023年4月】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Juan R. Terven 、Diana M. Cordova-Esparaza 摘要：YOLO已经成为机器人、无人驾驶汽车和视频监控应用的核心实时物体检测系统。我们对YOLO的演变进行了全面的分析，研究了从最初的YOLO到YOLOv8每次迭代的创新和贡献。我们首先描述了标准指标和后处理；然后，我们讨论了每个模型的网络结构和训练技巧的主要变化。最后，我们总结了YOLO发展的基本经验，并提供了对其未来的看法，强调了提高实时物体检测系统的潜在研究方向。
1. 简介 实时物体检测已经成为众多应用中的一个重要组成部分，横跨自主车辆、机器人、视频监控和增强现实等各个领域。在各种物体检测算法中，YOLO（You Only Look Once）框架因其在速度和准确性方面的显著平衡而脱颖而出，能够快速、可靠地识别图像中的物体。自成立以来，YOLO系列已经经历了多次迭代，每次都是在以前的版本基础上解决局限性并提高性能（见图1）。本文旨在全面回顾YOLO框架的发展，从最初的YOLOv1到最新的YOLOv8，阐释每个版本的关键创新、差异和改进。
本文首先探讨了原始YOLO模型的基本概念和架构，这为YOLO系列的后续进展奠定了基础。随后，我们深入探讨了从YOLOv2到YOLOv8每个版本中引入的改进和提高。这些改进包括各个方面，如网络设计、损失函数的修改、锚框的调整和输入分辨率的扩展。通过研究这些发展，对YOLO框架的演变及其对物体检测的影响有一个整体的理解。
除了讨论每个YOLO版本的具体进展外，本文还强调了在整个框架的发展过程中出现的速度和准确性之间的权衡问题。这强调了在选择最合适的YOLO模型时，考虑具体应用的背景和要求的重要性。最后，我们设想了YOLO框架的未来方向，触及了进一步研究和发展的潜在途径，这将塑造实时物体检测系统的持续进展。
2. YOLO在不同领域的应用 YOLO的实时物体检测能力在自主车辆系统中是非常宝贵的，能够快速识别和跟踪各种物体，如车辆、行人[1, 2]、自行车和其他障碍物[3, 4, 5, 6]。这些能力已被应用于许多领域，包括用于监控的视频序列中的动作识别[7][8]、体育分析[9]和人机交互[10]。
YOLO模型已被用于农业，以检测和分类作物[11, 12]、害虫和疾病[13]，协助精准农业技术和自动化耕作过程。它们还被用于生物识别、安全和面部识别系统中的面部检测任务[14, 15]。
在医学领域，YOLO已被用于癌症检测[16, 17]、皮肤分割[18]和药片识别[19]，从而提高诊断的准确性和更有效的治疗过程。在遥感领域，它已被用于卫星和航空图像中的物体检测和分类，有助于土地利用绘图、城市规划和环境监测[20, 21, 22, 23]。
安防系统已经将YOLO模型整合到视频资料的实时监控和分析中，允许快速检测可疑活动[24]、社会距离和脸部面具检测[25]。这些模型还被应用于表面检测，以检测缺陷和异常，加强制造和生产过程的质量控制[26, 27, 28]。
在交通应用中，YOLO模型已被用于车牌检测[29]和交通标志识别[30]等任务，促进了智能交通系统和交通管理解决方案的发展。它们已被用于野生动物检测和监测，以识别濒危物种，用于生物多样性保护和生态系统管理[31]。最后，YOLO已被广泛用于机器人应用[32, 33]和无人机的物体检测[34, 35]。
3. 物体检测指标和非极大值抑制（NMS） 平均精度（AP），传统上称为平均精度（mAP），是评价物体检测模型性能的常用指标。它测量所有类别的平均精度，提供一个单一的数值来比较不同的模型。COCO数据集没有对AP和AP进行区分。在本文的其余部分，我们将把这个指标称为AP。
在YOLOv1和YOLOv2中，用于训练和基准测试的数据集是PASCAL VOC 2007和VOC 2012[36]。然而，从YOLOv3开始，使用的数据集是微软COCO（Common Objects in Context）[37]。对于这些数据集，AP的计算方法是不同的。以下各节将讨论AP背后的原理，并解释它是如何计算的。
3.1 AP AP指标是基于精度-召回指标，处理多个对象类别，并使用Intersection over Union（IoU）定义一个积极的预测。
Precision和Recall：精确率衡量的是模型正面预测的准确性，而召回率衡量的是模型正确识别的实际正面案例的比例。精确率和召回率之间通常有一个权衡；例如，增加检测到的对象的数量（更高的召回率）会导致更多的假阳性（更低的精确率）。为了考虑到这种权衡，AP指标包含了精度-召回曲线，该曲线将精度与不同置信度阈值的召回率作了对比。这个指标通过考虑精度-召回曲线下的面积，对精度和召回进行了平衡的评估。
处理多个物体类别：物体检测模型必须识别和定位图像中的多个物体类别。AP指标通过单独计算每个类别的平均精度（AP），然后取所有类别中这些AP的平均值来解决这个问题（这就是为什么它也被称为平均平均精度）。这种方法确保了对每个类别的模型性能进行单独评估，从而对模型的整体性能提供了更全面的评估。
IoU：物体检测的目的是通过预测边界框来准确定位图像中的物体。AP指标包含了 "联合体上的交集"（IoU）措施，以评估预测的边界盒的质量。IoU是预测界线盒和地面真实界线盒的交集面积与联合面积之比（见图2）。它衡量的是地面实况和预测边界盒之间的重叠程度。COCO基准考虑了多个IoU阈值，以评估模型在不同定位精度水平上的表现。
3.2 计算AP 在VOC和COCO数据集中，AP的计算方法是不同的。在这一节中，我们将描述它是如何在每个数据集上计算的。
VOC数据集
这个数据集包括20个物体类别。为了计算VOC中的AP，我们遵循以下步骤：
对于每个类别，通过改变模型预测的置信度阈值，计算出精确-召回曲线使用精度-召回曲线的内插11点抽样，计算每个类别的平均精度（AP）通过取所有20个类别中的AP的平均值来计算最终的平均精度（AP） COCO数据集
这个数据集包括80个对象类别，并使用更复杂的方法来计算AP。它没有使用11点插值，而是使用101点插值，也就是说，它计算了从0到1的101个召回阈值的精度，增量为0.01。另外，AP是通过对多个IoU值进行平均而不是只对一个IoU值进行平均得到的，除了一个常见的AP指标，即AP50 ，它是单个IoU阈值为0.5的AP。COCO中计算AP的步骤如下：
对于每个类别，通过改变模型预测的置信度阈值，计算出精确-召回曲线使用101-recall阈值计算每个类别的平均精度（AP）在不同的交叉联合（IoU）阈值下计算AP，通常从0.5到0.95，步长为0.05。更高的IoU阈值需要更准确的预测才能被认为是真阳性对于每个IoU阈值，取所有80个类别的AP的平均值最后，通过平均每个IoU阈值计算的AP值来计算总体AP AP计算的差异使得我们很难直接比较两个数据集的物体检测模型的性能。目前的标准使用COCO AP，因为它对一个模型在不同的IoU阈值下的表现有更精细的评估。
3.3 非极大值抑制 (NMS) 非极大值抑制（NMS）是物体检测算法中使用的一种后处理技术，用于减少重叠边界盒的数量，提高整体检测质量。物体检测算法通常会在同一物体周围产生多个具有不同置信度分数的边界框。NMS过滤掉多余的和不相关的边界盒，只保留最准确的边界盒。算法1描述了该程序。图3显示了一个包含多个重叠边界框的物体检测模型的典型输出和NMS之后的输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee60a5301cf0d64fd9854763794f9cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c528770a4e0415f8a55d074d4d183e/" rel="bookmark">
			HTML引入css文件（四种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.内嵌样式表 在HTML的&lt;head&gt;标签中的&lt;style&gt;标签中添加css样式，使用内嵌样式表定义的 CSS 样式只能在当前网页内使用。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;内嵌样式&lt;/title&gt; &lt;style&gt; body { background-color: linen; } h1 { color: maroon; margin-left: 40px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;样式&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 因为内嵌样式表需要将 CSS 样式定义在 HTML 文档的内部，所以会导致文档的体积变大，而且当有其它文档也需要使用内嵌样式表中同样的样式时，无法引入到其他文档，必须在其它文档中重新定义，会导致代码冗余，不利于后期维护。
二.内联样式 内联样式就是将样式信息直接定义在 HTML 标签的 style 属性中，由于内联样式定义在标签内部，所以它只对所在的标签有效。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;内联式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 style="color: maroon; margin-left: 40px"&gt;内联式&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 内联样式虽然可以很方便的为 HTML 标签赋予 CSS 样式，但它的缺点也非常明显，不推荐过多使用。
定义内联样式需要在每个 HTML 标签中定义 style 属性，很不方便；在内联样式中使用双引号或单引号时要特别小心，因为 HTML 标签的属性通常都会使用双引号来包裹属性的值，例如&lt;input type="text"&gt;；在内联样式中定义的样式不能再其它任何地方重用；内联样式在后期维护时很不方便，因为一个网站通常有很多页面组成，当修改页面样式时需要对页面逐个修改；添加过多的内联样式会导致 HTML 文档的体积增大。 三.外部样式表 外部样式表是最常见也是最推荐的引用 CSS 的方式，您只需要将 CSS 样式定义在一个 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c528770a4e0415f8a55d074d4d183e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826db780e8bd09d7d3c9293b5791c53e/" rel="bookmark">
			数据结构——插入排序与希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌇个人主页：_麦麦_
📚今日名言：喜你成疾，药石无医。——《玫瑰与鹿》
一、前言 在本篇文章，我们将为小伙伴们进行排序概念的基本讲解并具体讲解其中的两种基础排序：插入排序和希尔排序，希望小伙伴们能够从中有所收获！！！
二、正文 1.排序的概念及其运用 1.1排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
1.2排序运用 看过排序的基础概念，可能有的小伙伴会问就算我学会了排序，但是在实际生活中有什么用吗？其实排序在生活中无处不在，比如说对一件商品不同维度的选择，又或者是对高校的排名，其实背后都存在着排序的思想，学好排序，能够帮助我们以另一种维度来观察生活中的方方面面并帮助我们更好地解决生活中的问题。 1.3常见的排序算法 在数据结构这一块，我们常见的排序算法共有四种：
①插入排序：直接插入排序、希尔排序
②选择排序：选择排序、堆排序
③交换排序：冒泡排序、快速排序
④归并排序：归并排序
2.插入排序算法的实现 由于篇幅的关系，本篇我们主要介绍的是插入排序中的直接插入排序和希尔排序，而直接插入排序又常常被称为插入排序。 2.1插入排序 2.1.1基本思想 直接插入排序是一种简单的插入排序法
其基本思想是把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 实际中我们玩扑克牌时，就用了插入排序的思想。当你摸了一张新牌，自然而然地就会与手上已有的牌堆进行一一比较，在比较之后将其放入其应该所处的位置。所以我们可能并不知道插入排序是什么，但我们潜意识的做法恰恰就符合了插入排序。
2.1.2直接插入排序 用比较书面的语言来描述直接插入排序：当插入第i(i&gt;=1)个元素时，前面的 array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移
但这么说可能有的小伙伴会不太理解，那么通俗地来讲吧。现在在你面前有一个乱序的数组，我们的目的是要将这个乱序的数组调整为升序或者降序。
以升序为例叭，由于数组是无序的，因此我们需要从数组的第二个元素开始排序。为什么不是第一个呢，因为只有一个数字的的时候，你无法与其余元素比较，自然也就没有乱序一说，因此只有一个元素的时候我们就默认它是有序的。
在理解完为什么要从第二个元素开始排序后，现在我们就要进行元素的依次插入和排序了。先是第二个元素的插入和排序，在下图中我们会发现第二个元素是44，44大于第一个元素3，因此不需要挪动第二个元素。紧接着就是第三个元素的插入和排序，我们发现第三个元素38小于第二个元素44，不符合我们升序的预期，因此将44挪动到38的位置，在第二、三个元素有序后，我们发现38大于3，也就是第一、二个元素也是有序的，因此就无需再挪动第一个元素的位置，这时候我们已经确认38应该所处的是数组中第二个元素的位置，因此我们只需将38插入到第二个元素的位置即可。相信看到这里的小伙伴对后续元素的插入与排序应该是信手拈来了，
接下来就是代码的书写了。在代码上，我们该如何实现上述元素的插入与排序呢？我们采取了两个主要的变量“des”和“end”，des就是我们所要插入的元素的初识下标，而end代表的是插入之前的序列的最后一个元素的下标，随着des的比较，end要不断向前移动，那么什么时候end的移动才会停止呢，也就是比较的结束，大致分为两种情况：①des所代表的元素大于end所代表的的元素 ②end已经来到序列的第一个元素，这时候des要么是第一个元素，或者是第二个元素。
具体图片和代码如下：
//插入排序[升序] int* InsertSort(int* arr, int n) { //整体排序 for (int i = 1; i &lt; n; i++) { int end = i - 1; int des = arr[i]; //单趟排序 while (end &gt;= 0) { if (des &gt;= arr[end]) break; if (des &lt; arr[end]) { arr[end + 1] = arr[end]; end--; } arr[end+1] = des; } } } 注：直接插入排序特性总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826db780e8bd09d7d3c9293b5791c53e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae5e539596a4ab18e32f314c205bf292/" rel="bookmark">
			文心一言眼里的Java世界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Java基础教程系列二、先听听文心一言怎么说？三、话不多说，开干。1、要有一个正确的Java学习路线，做一个细致的Java学习规划。2、学习资料推荐3、书中自有黄金屋，书中自有颜如玉4、自学周期推荐5、效率为先6、哪吒的学习方式 大家好，我是哪吒。
很多小伙伴反馈：
空有一腔热血，每天学习20个小时，坚持了两个月，还停在Java基础，感觉什么都会了，又感觉什么都不会，迷迷糊糊；每天都想着要好好学习Java，两个月过去了，还没开始；三天打鱼，两天晒网，哎，一地鸡毛；… 一、Java基础教程系列 之前我写了一个🏆Java基础教程系列。
目前已经700+订阅，自认为是CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
结果呢，果断打脸，很多小伙伴表示，讲的”太简单了“，纳尼？那可是集哪吒多年工作之所成啊，耗时一年才编制的经典巨作。
今天，我打算进阶一下，正式推出🏆Java基础教程（进阶篇）。
包含Java高并发、Spring、MySQL等Java进阶技术栈。
二、先听听文心一言怎么说？ 文心一言，还是懂我的。
三、话不多说，开干。 自学成才，说起来好听，其实还是略带苦涩的，天天夜里挑灯看码，跟着视频、瞧着代码、一步一个坎、一步错、步步错，推到重新再来，哎，苦逼。
每天看似很努力，结果呢？乱学一气，毫无章法，下面根据我的多年工作经验，总结一套适合大多数人的自学打法。
1、要有一个正确的Java学习路线，做一个细致的Java学习规划。 🏆Java学习路线总结（思维导图篇）
2、学习资料推荐 看看文心一言有没有?
说的还是很全的，我来补充一点。
哪吒在CSDN的集大成之作，数十万人阅读、收藏。
🏆Java学习路线总结，搬砖工逆袭Java架构师
包含Java基础、java集合、Java高并发、Java8新特性、数据库、Spring + SpringMVC + MyBatis、Spring Boot、Redis、Netty、数据结构与算法、JVM、设计模式、Linux、SpringCloud、JavaScript、Vue、计算机网络等所有的Java知识点。
3、书中自有黄金屋，书中自有颜如玉 前两本没看过~~，我推荐一下我读过的，觉得还不错的几本书。
🏆Java学习路线总结（书籍、视频推荐篇）
4、自学周期推荐 自学的话，一般都是全职自学，也就是，除了吃喝拉撒，就是学习。
一天高效学习12个小时就够了，太多了，身体会受不了的。
下面推荐一下Java从入门到就业的具体安排。
4个月差不多过去了，此时的你，放在3年前，就可以出去找工作了，现在还不行。
再花费一个月，背面试题，融会贯通。
推荐一个，目前595867阅读， 28458收藏的，既有颜又能打的Java面试题。10万字208道Java经典面试题总结(附答案)。
毫不夸张的说，面试题里的知识，比你学的知识还要多，还要深刻。为了找到更好的工作，背就对了。
面试官，问你啥，你能对答如流，就完了。
5、效率为先 学习一定要追求效率，而不是时间。
6、哪吒的学习方式 文心一言说的还是很有道理的，我来简化一下~~
哪吒的学习方式，先看视频过一遍，了解个大概过一遍，然后可以看看博客，看看经典书籍，比如《Java核心技术》、《Java编程思想》（目前已经出新版了，叫《On Java中文版》），然后就是通过项目实战进行实操。
🏆本文收录于，Java基础教程系列。
目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆哪吒多年工作总结：Java学习路线总结，搬砖工逆袭Java架构师。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45daf1f769a6bfd82446f11c14af923/" rel="bookmark">
			分享一下基于若依的二开经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下基于若依的二开经验 一、前言二、搭建环境1.基础环境2.开发环境 三、克隆项目四、运行项目1.后端工作A．application.ymlB．application-druid.ymlC．导入项目中sql目录下的两个sql文件。 2.前端工作 五、二次开发1.新建模块2.绕过验证3.代码生成4.增加链接 六、总结 一、前言 若依后台管理框架是github和码云上优秀的开源项目，基于它进行二次开发，教程多资料详细，非常适合练手。
二、搭建环境 想要基于若依进行二次开发，基础环境要先搭好
1.基础环境 这里罗列一下需要的基础环境：
1、 数据库服务器mysql或mariadb，最好再配上navicat数据库工具。
2、 redis。这个非必要，如果没有，则将配置文件中关于redis的部分注释掉。
数据库和redis，搞起来比较简单，方法也多。
比较快速的方法有2个，
一个是用docker（当然docker搞起来又要一番折腾）另一个是装一个小皮面板phpstudy。 关于具体怎么配置基础环境，就不再啰嗦了。
2.开发环境 搞定基础环境，就要搞好开发环境。需要东西有：
1、 jdk8
2、 node.js
3、 开发IDE，推荐jetbrains出品的IDEA（后端）和WebStorm（前端）
4、 Maven，下载一个，不用IDEA内嵌的，我用的3.8.6版。
三、克隆项目 从github或码云上克隆ruoyi-vue（前后端分离版本），我用的是3.8.5版。
克隆好之后，项目目录如下：
四、运行项目 运行前要做一些准备工作
1.后端工作 主要是修改ruoyi-admin模块中的两个配置文件以及导入数据库
A．application.yml 两个地方：ruoyi配置和redis配置。
ruoyi配置中，要修改profile为自己指定的路径；另外增加一个test: true，这个是为了调试用（可以以后再改）。
B．application-druid.yml 这个是为了修改数据配置。这个也是根据实际修改：
C．导入项目中sql目录下的两个sql文件。 至此，后端应该可以跑起来了，不防运行一下试试。
2.前端工作 用webstorm打开前端目录ruoyi-ui，执行两个命令：
npm i # 安装依赖 npm run dev # 运行项目 正常情况下都是一次通过的。跑起来后，就可以用浏览器打开了
五、二次开发 我们用若依的主要目的就是二次开发，因此我们现在进入二次开发环节。
1.新建模块 新建一个maven管理的模块，按规范取名，比如为ruoyi-demo。
我们的目标是自己的controller、entity、mapper、service等都存放在我们自己的模块中。
因此需要修改一下两个pom文件，这个很重要！
本模块的pom文件增加对ruoyi-common的依赖
admin模块的pom文件增加对本模块的依赖。
然后在本模块的controller包中新建一个TestOk类，看看是否正常
@RestController @RequestMapping("/qx") public class TestOk { @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45daf1f769a6bfd82446f11c14af923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c5e304d9af0b652b292a05813b0dc5/" rel="bookmark">
			【机器学习】决策树（实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树（实战） 目录 一、准备工作（设置 jupyter notebook 中的字体大小样式等）二、树模型的可视化展示1、通过鸢尾花数据集构建一个决策树模型2、对决策树进行可视化展示的具体步骤3、概率估计 三、决策边界展示四、决策树的正则化（预剪枝）五、实验：探究树模型对数据的敏感程度六、实验：用决策树解决回归问题七、实验：探究决策树的深度对其拟合能力的影响 实战部分将结合着 理论部分 进行，旨在帮助理解和强化实操（以下代码将基于 jupyter notebook 进行）。
一、准备工作（设置 jupyter notebook 中的字体大小样式等） import numpy as np import os %matplotlib inline import matplotlib import matplotlib.pyplot as plt plt.rcParams['axes.labelsize'] = 14 plt.rcParams['xtick.labelsize'] = 12 plt.rcParams['ytick.labelsize'] = 12 import warnings warnings.filterwarnings('ignore') 二、树模型的可视化展示 决策树不仅在理论上很容易理解（机器学习“最友好”的算法），实现时还能对构建过程进行可视化（诸如神经网络等算法本身就是黑盒模型，更难可视化展示模型的构建）。因此，决策树的另一大优势就是能利用相关包来查看构建的树模型。下面介绍一个可以对决策树进行可视化展示的包：
下载链接：Graphviz 。
注：为了能在 cmd 中调用指令，在安装时需配置环境变量（下载exe文件，在安装过程中勾选 Add PATH）。
1、通过鸢尾花数据集构建一个决策树模型 # 导入鸢尾花数据集 和 决策树的相关包 from sklearn.datasets import load_iris from sklearn.tree import DecisionTreeClassifier # 加载鸢尾花数据集 iris = load_iris() # 选用鸢尾花数据集的特征 # 尾花数据集的 4 个特征分别为：sepal length:、sepal width、petal length:、petal width # 下面选用 petal length、petal width 作为实验用的特征 X= iris.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c5e304d9af0b652b292a05813b0dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55bbdf80bef24e6cb462765505998f7a/" rel="bookmark">
			你理解了for-in 和 for-of 吗？他们有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】
在 JavaScript 中，for 循环语句是编写复杂程序时经常使用的一种工具。其中，for-in 和 for-of 是两个最常用的变体。尽管这两者非常相似，但它们在迭代对象方面有所不同。在本文中，我们将探讨 for-in 和 for-of 的不同之处，以及如何正确使用它们。
【正文】
一、for-in 循环
for-in 循环是一种迭代对象属性的方法。它可以用于遍历对象中的所有可枚举属性，包括从原型链继承的属性。通常，我们使用 for-in 循环来遍历对象的键名。
下面是一个简单的例子：
const person = { name: 'John', age: 30, gender: 'male' }; for (const key in person) { console.log(key, person[key]); } 在这个例子中，我们使用 for-in 循环遍历了 person 对象的所有键名。输出结果如下：
name John age 30 gender male 需要注意的是，for-in 循环并不是按照对象属性在对象中的顺序迭代的。这是因为 JavaScript 中的对象属性没有固定的顺序。因此，我们在使用 for-in 循环迭代对象时，不能保证它们的顺序。
另外，由于 for-in 循环会遍历对象的原型链，因此可能会迭代到不是自身属性的属性。为了避免这种情况，我们可以使用 hasOwnProperty 方法来检查属性是否为对象自身的属性。
下面是一个使用 hasOwnProperty 的例子：
const person = { name: 'John', age: 30, gender: 'male' }; for (const key in person) { if (person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55bbdf80bef24e6cb462765505998f7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24c12d1a1ed3ca714dfd1f49df92191/" rel="bookmark">
			kaggle（白嫖免费GPU，新手必看！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跑深度学习代码的时候电脑GPU太垃圾了，batch-size设置的很小，训练时间长？kaggle提供免费GPU啦！！！跟着我一起来白嫖吧
1、第一步：注册登录 kaggle可以使用Google、雅虎、Facebook账号登录，如果你已经有了这些账号直接登录即可。这些账号博主都没有，所以通过邮箱注册登录。
首先进入kaggle主页Kaggle: Your Machine Learning and Data Science Community，点击右上角的register，即可进入下方注册页面。
点击第二个register with your email，进入注册页面，如下：
当你填完邮箱密码等信息，点击next后，会发现如下提示：
红色提示显示需要输入验证，但是并没有发现有输入验证的地方，别急，仅需安装一个header editor插件即可。
在浏览器上方找到扩展图标，如下：
点击该扩展图标，点击管理扩展，在寻找更多附加组件处输入header editor
找到Header Editor并添加。添加后再次点击扩展图标可以看到该扩展已经被添加进来了。
点击header editor 会出现以下界面：
点击管理， 选择导入和导出。
将https://github.azurezeng.com/static/HE-GoogleRedirect.json输入下载规则中，点击下载。
接下来可以看到导入了相关规则：
点击保存即可。
再次返回kaggle注册界面
可以看到有了人机注册模块。再依次填写相关信息，并进行人机注册即可。
点击next。
打开邮箱，将验证码填入，填入验证码后即注册成功啦。
2、在notebook中写入自己的代码并使用GPU训练 想要使用GPU需要先验证自己的手机号，点击头像---&gt;account---&gt;Phone Verification，输入手机号验证即可。
验证完手机后就可以使用GPU跑我们自己的深度学习代码啦
点击create创建新的notebook，这里notebook的使用和jupyter notebook很类似。
notebook界面如下：左边的就是编辑代码的文本框，右边提供上传数据，结果保存，以及使用GPU的功能。
写入自己的代码 我通常是将代码直接复制到代码框，避免导入自定义的文件和类。
上传自己的数据集 在右边功能框的data中找见upload data，如下图：
将需要上传的文件压缩成压缩文件，上传压缩文件即可，kaggle会自动将压缩文件进行预处理，解压到Input中。
使用GPU训练 同样是在右边的功能框找见Notebook options---&gt;accelerator---&gt;选择GPU P100，如下图所示：
可以看到，kaggle为每位用户提供每周30h的免费GPU使用时间。
调好代码，上传好数据，就可以使用GPU进行训练啦
3、离线训练自己的代码 由于深度学习代码往往需要很长的训练时间，长时间线上训练可能会出现内核挂掉的情况，所以我们可以选择离线训练自己的模型，最后下载相关模型参数文件即可。
将自己的代码调试无错后，点击右上角save version
点击保存，代码就可以离线训练了。
点击左下角离线运行的代码，我们可以随时查看他的log信息，查看训练过程中的输出信息。
至此，我们就用上了白嫖的GPU啦
推荐博客：reCaptcha人机验证无法显示和CSP问题解决方案 – Azure Zeng Blog
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a9cecbacc735e855bda32c71b3ddd8/" rel="bookmark">
			内网穿透实现在外远程连接RabbitMQ服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.安装erlang 语言2.安装rabbitMQ3. 内网穿透3.1 安装cpolar内网穿透(支持一键自动安装脚本)3.2 创建HTTP隧道 4. 公网远程连接5.固定公网TCP地址5.1 保留一个固定的公网TCP端口地址5.2 配置固定公网TCP端口地址 转载自远控源码文章：无公网IP，在外公网远程访问RabbitMQ服务「内网穿透」
前言 RabbitMQ是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。
由erlang开发的AMQP（Advanced Message Queue 高级消息队列协议 ）的开源实现，由于erlang 语言的高并发特性，性能较好，本质是个队列，FIFO 先入先出，里面存放的内容是message,下面介绍通过在ubuntu+cpolar+rabbitMQ环境下，实现mq服务端远程访问。
1.安装erlang 语言 由于rabbitMQ是erlang语言实现的,所以我们需要安装erlang
sudo apt-get install erlang-nox 2.安装rabbitMQ 安装最新版rabbitMQ
sudo apt-get install rabbitmq-server 查看rabbitMQ状态,active(running)表示在线
sudo systemctl status rabbitmq-server 设置访问MQ用户名账号和密码，admin表示账号（可自定义），123456表示密码（可自定义）
sudo rabbitmqctl add_user admin 123456 设置上面admin用户的角色,administrator表示是最高管理员
sudo rabbitmqctl set_user_tags admin administrator 设置admin角色权限
sudo rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*" 以上信息设置好后，我们往下走。
3. 内网穿透 接着我们使用cpolar穿透本地MQ服务,使得远程可以进行访问连接，cpolar支持http/https/tcp协议，不限制流量，操作简单，无需公网IP，也无需路由器。
cpolar官网：https://www.cpolar.com/
3.1 安装cpolar内网穿透(支持一键自动安装脚本) cpolar 安装（国内使用） curl -L https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a9cecbacc735e855bda32c71b3ddd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af272119b59278b9f881120b99037ed2/" rel="bookmark">
			CSS实现三角形的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：使用 border (常见) 【解释】不设置宽高，用边框大小控制三角型大小
【分解步骤】
设置一个div不设宽高
【示例】
&lt;style&gt; #triangle{ width: 0; height: 0; border: 100px solid; border-color: orangered skyblue gold yellowgreen; } &lt;/style&gt; 2. 设置透明
留下想要指向方向相反的边框设定，其他方向的边框设为transparent透明 【示例】实现指向向上的三角形
&lt;style&gt; .Up{ width: 0; height: 0; border-top: 100px solid transparent; border-right: 100px solid transparent; border-left: 100px solid transparent; border-bottom: 100px solid orangered; } &lt;/style&gt; 【效果图】指向上，指向下，指向左，指向右
如何设置不同的三角形 可以通过调整不同方向边框的值来实现不同方向和大小的三角形 方法二：使用 linear-gradient 【解释】两色渐变，调为实色，一色透明
【分解步骤】
两色渐变 &lt;style&gt; .first{ background: linear-gradient(45deg, deeppink, yellowgreen); } &lt;/style&gt; 调为实色 &lt;style&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af272119b59278b9f881120b99037ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f439edf181b04afbc82bc7f51106bdc5/" rel="bookmark">
			【CV大模型SAM（Segment-Anything）】真是太强大了，分割一切的SAM大模型使用方法:可通过不同的提示得到想要的分割目标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言安装运行环境SAM模型的使用方法导入相关库并定义显示函数导入待分割图片使用不同提示方法进行目标分割方法一：使用单个提示点进行目标分割方法二：使用多个提示点进行目标分割方法三：用方框指定一个目标进行分割方式四：将点与方框结合，进行目标分割方法五：多个方框同时输入，进行多目标分割 总结 本文主要介绍SAM模型的使用方法：如何使用不同的提示进行目标分割。而且该模型在CPU的环境下就可以快速运行，真心不错~,赶紧来试试吧
关于Segment-Anything模型的相关代码、论文PDF、预训练模型、使用方法等，我都已打包好，供需要的小伙伴交流研究，获取方式如下：
关注文末名片GZH：阿旭算法与机器学习，回复：【SAM】即可获取SAM相关代码、论文、预训练模型、使用方法文档等
前言 最近GPT一直都被炒的火热，没想到这么快就见到了CV的大模型，而且拥有新数据集+新范式+超强零样本泛化能力。
虽然此次出现的CV大模型没有NLP中的GPT那么强大的效果：用一个模型就可以处理N多下游任务。但这也是一个很好的开始，也应该是CV未来的发展趋势。
SAM（Segment-Anything Model）的出现统一了分割这个任务（CV任务的一个子集）的下流应用，说明了CV的大模型是可能存在的。其肯定会对CV的研究带来巨大的变革，很多任务会被统一处理，可能再过不久，检测、分割和追踪也会被all in one了。
项目地址：https://github.com/facebookresearch/segment-anything
Demo：https://segment-anything.com/
安装运行环境 运行需要python&gt;=3.8, 以及pytorch&gt;=1.7和torchvision&gt;=0.8。
安装依赖库：
pip install git+https://github.com/facebookresearch/segment-anything.git SAM模型的使用方法 导入相关库并定义显示函数 下面导入了运行所需的第三方库，以及定义了用于展示点、方框以及分割目标的函数。
import numpy as np import torch import matplotlib.pyplot as plt import cv2 def show_mask(mask, ax, random_color=False): if random_color: color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0) else: color = np.array([30/255, 144/255, 255/255, 0.6]) h, w = mask.shape[-2:] mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1) ax.imshow(mask_image) def show_points(coords, labels, ax, marker_size=375): pos_points = coords[labels==1] neg_points = coords[labels==0] ax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f439edf181b04afbc82bc7f51106bdc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d53e6f5fbfed67dd027d23ae8ef026/" rel="bookmark">
			C&#43;&#43;实现：学生管理系统（详细解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.题目要求
2.需求分析
3.整体设计
4.详细设计
主函数设计
学科科目类
主菜单
读取文件与写入文件
效果如下
添加学生信息
删除学生信息
​编辑
修改学生信息
显示信息列表
显示学生列表
将学生列表按学号升序排列
将学生列表按平均分降序排列，平均分相同的再按学号升序排列
统计学生数据
清空系统数据
5.总结
1.题目要求 学生成绩管理系统
（1）增加记录：要求可以连续增加多条记录。
（2）查找：可以根据姓名（或学号）查找某个学生的课程成绩，查找某门课程成绩处于指定分数段内的学生名单等等。可以实现模糊查询，即输入名字的一部
分，可以列出满足条件的所有记录。再从这个记录中进行二次选择。
（3）删除一个学生的记录：要求可以先查找，再删除。删除前，要求用户确认。
（4）成绩修改：若输入错误可进行修改；要求可以先查找，再修改。
（5）统计分析：对某个班级学生的单科成绩进行统计，求出平均成绩；求平均成绩要求实现函数的重载，既能求单科的平均成绩，又能求三科总分的平均成绩。
求出一门课程标准差和合格率；
（6）排序功能：要求按总分进行排序（从高到低），若总分相同，则按数学排序；
若总分和数学相同，则按物理排序；若总分和各科成绩都相同，则按学号排
序；
（7）文件操作：可以打开文件，显示班级的所有学生信息；可以将增加或修改后的成绩重新写入文件；可以将排序好的信息写入新的文件；
2.需求分析 基本思路
设计一个学生的类。类的设计测试数据的记录和将要实现的功能。学生成绩
管理系统有若干学生成绩记录组成，学生一条记录包括：学号、姓名、数学
成绩、物理成绩和英语成绩。主函数显示功能菜单，供用户选择操作。每步操
作之前，都要显示菜单。在主函数中调用类的方法
编译环境
在DEV-C++上运行通过
3.整体设计 【1】录入学生信息
【2】显示学生信息
【3】修改学生信息
【4】查找学生信息
【5】删除学生信息
【6】学生信息文件
【7】成绩排序功能
【8】存入新文件
【9】统计分析成绩
4.详细设计 主函数设计 int main() { StudentList stuList; stuList.init(); //读入文件数据初始化 stuList.menu(); //打开主菜单 return 0; } 效果如下
学科科目类 class Subject { public: string proName; //学科名 double proScore; //分数 void showCpInfo() { cout &lt;&lt; left &lt;&lt; setw(45) &lt;&lt; proName; cout &lt;&lt; left &lt;&lt; setw(6) &lt;&lt; proScore &lt;&lt; endl; } //输出属性名，只显示总积分 static void showHeader() { cout &lt;&lt; left &lt;&lt; setw(45) &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d53e6f5fbfed67dd027d23ae8ef026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f0e946289f6646d91b28bcdaa7d8f9/" rel="bookmark">
			python基于opencv和tkinter实现人脸识别【内附完整代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 人脸识别技术已经在许多领域得到了广泛应用，例如安防、金融、医疗等等。人脸识别可以帮助我们识别和验证一个人的身份，这是一项非常重要的任务。本篇博客将介绍如何使用Python和OpenCV库进行人脸识别。我们将学习如何使用OpenCV中的人脸检测器检测图像中的人脸，如何与一个人的图像进行比较以检测是否属于该人，以及如何在GUI中显示识别结果。你可以嵌入到你的程序、机器上。现在，让我们开始学习人脸识别技术吧！
如果你已有python环境和opencv库可直接跳转到代码解读哦
目录
前言：
环境搭建：
安装Python
安装pip
安装OpenCV
配置环境变量
代码解读
程序的大体流程如下：
加载 Haar Cascade 分类器用于人脸检测。
打开摄像头并捕获实时图像。
循环处理捕获的图像：
关闭摄像头并销毁窗口。
代码解析
与person文件夹中的图像进行比较以检测人脸
cv2AddChineseText方法
完整代码
环境搭建： 安装Python 首先，你需要下载和安装Python。可以在Python官方网站上下载最新版本的Python安装程序：https://www.python.org/downloads/windows/请务必下载并安装3.x版本的Python，因为OpenCV不支持Python 2.x。
安装pip pip是Python的包管理器，可以轻松地安装、升级和删除Python软件包。可以使用以下命令检查是否已经安装了pip：
pip --version 如果pip没有安装，可以在终端中输入以下命令进行安装：
python -m ensurepip --default-pip 安装OpenCV 可以使用pip来安装OpenCV：
pip install opencv-python 配置环境变量 为了让Python能够找到OpenCV，需要将OpenCV的路径添加到系统的环境变量中。
首先，找到OpenCV安装的路径，一般在Python的安装目录下的Lib\site-packages目录中。例如，在我的电脑上，OpenCV安装在以下目录下：
C:\Users\username\AppData\Local\Programs\Python\Python39\Lib\site-packages\cv2
然后，将这个路径添加到系统的环境变量中。在Windows 10中，可以按以下步骤进行操作：
在Windows搜索栏中输入“环境变量”，并点击“编辑系统环境变量”；在“高级”选项卡下，点击“环境变量”按钮；在“系统变量”下方找到“Path”变量，点击“编辑”按钮；在“编辑环境变量”对话框中，点击“新建”按钮，并将OpenCV的路径添加进去。测试OpenCV最后，可以测试一下OpenCV是否已经正确安装。可以在终端中输入以下代码： import cv2 print(cv2.__version__) 如果OpenCV已经成功安装，应该会显示OpenCV的版本号。
希望这个简要的教程可以帮助你在Windows上成功安装和配置OpenCV和Python。
代码解读 这是一个基于 OpenCV 库和 tkinter 库开发的人脸识别程序。它可以从摄像头实时获取视频，并在视频中检测人脸并显示其姓名。
程序的大体流程如下： 加载 Haar Cascade 分类器用于人脸检测。 打开摄像头并捕获实时图像。 循环处理捕获的图像： 将图像转换为灰度图像。使用 Haar Cascade 分类器检测人脸。如果检测到人脸，则查找是否存在与 person 文件夹中的某个人匹配的图像。如果找到匹配的人脸，则在图像中框出人脸并显示姓名。如果未找到匹配的人脸，则在图像中框出人脸但不显示姓名。将图像转换为 PIL Image 格式以在 GUI 中显示。更新标签以显示图像。处理 GUI 事件以避免程序挂起。 关闭摄像头并销毁窗口。 代码中的函数 cv2AddChineseText 用于在图像上添加中文文本。函数 cv2AddChineseText 接受四个参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f0e946289f6646d91b28bcdaa7d8f9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/608/">«</a>
	<span class="pagination__item pagination__item--current">609/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/610/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>