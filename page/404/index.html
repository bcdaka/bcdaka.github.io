<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc6b688069cd6574a8831257d556c5db/" rel="bookmark">
			基于美日 627 例患者的临床数据，谷歌证实 AI 辅助肺癌筛查的群体有效性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024 年 2 月，国家癌症中心基于肿瘤登记及随访监测最新数据，形成了《2022年中国癌症发病率和死亡率》报告。报告显示，在我国，肺癌仍是恶性肿瘤发病和死亡的首位原因。尽管医学界对于肺癌的关注度与日俱增，但在肺癌诊疗领域仍存在大量诊断延误、过度治疗等临床难题。 在过去的十年中，由于算法的改进、计算能力的增加、可用数据的扩展和应用范围大幅增长，AI 正以前所未有的成长速度引领科技发展方向。
作为在 AI 研发领域最为前沿的世界级科技巨头之一，谷歌在 AI 与医学应用的研究方面成就颇丰。近期，谷歌研究中心的软件工程师 Atilla Kiraly 和产品经理 Rory Pilgrim 研究了机器学习模型如何有效地将研究结果传达给放射科医生，评估了广义人工智能辅助系统在特定工作流程环境、设备和国家特定指南和评分/管理协议下对肺癌筛查 (LCS) 工作流程的影响。 研究论文已经发表于《Radiology AI》期刊。
研究亮点：
开发并优化了人工智能辅助肺癌筛查的工作流程，并在美国和日本进行测试人工智能辅助下，可将特异性提高 5%-7%，而敏感性没有明显下降人工智能辅助下，平均每位病例筛查时间可减少 14 秒，并且大大增强了医生的诊断信心 论文地址：
https://doi.org/10.1148/ryai.230079
关注公众号，后台回复「谷歌肺癌」获取完整 PDF
研究范围：人工智能辅助筛查，美国和日本的回顾性跨国研究 该研究共使用了 5 个独立的数据集 (DS_CA, DS_NLST, DS_US, DS_JPN)，分析了美国和日本合计 627 例（含 141 例癌症阳性）低剂量胸部 CT 病例。 其中，美国的研究涉及 330 例患者，包含 191 名男性和 139 名女性，年龄中位数为 63 岁。日本的研究涉及 297 例患者，包含 217 名男性和 80 名女性，年龄中位数为 58 岁。阳性病例被定义为在两年内通过病理确诊肺癌，阴性病例被定义为至少两年内没有任何确诊癌症的诊断。
最终设计与读者研究概览
同时，该研究还邀请到了 6 位获得美国委员会认证的胸科放射科医生，以及 6 位具有阅读 CT 胸部检查经验的日本委员会认证放射科医生。 在研究中，所有病例的 CT 分别由 12 名医生在有人工智能辅助和无人工智能辅助的情况下，各审阅 1 次，共计获得了 7,254 次解释。对于特定国家的评分系统，来自美国的放射科医生采用美国放射学会指南中的肺-rads 评分 (1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc6b688069cd6574a8831257d556c5db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7935b4478690dc4cbda8699a37d0e3/" rel="bookmark">
			有什么AI自动生成PPT的方法？看着这七款软件如何生成PPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五一节假日快到了，打工人是不是已经按捺不住内心的激动，准备开启放飞自我的模式了？
不过，在享受假期之前，还有一项重要任务需要完成——那就是假期前的会议！但没有一份精美的PPT怎么能在同事面前秀出你的风采呢？
好在，我这里有七款超好用的AI自动生成PPT免费下载的神器，让你轻松搞定演示文稿，从此告别加班熬夜的烦恼！
1.迅捷PPT
这款软件简直是打工人的福音啊！它的AI技术简直强大到“没朋友”，只要选对合适的模板，就能自动生成专业又美观的PPT。
更牛的是，它还能根据你的需求进行个性化定制模板，让你的演示文稿独具特色。操作起来也超简单，就像玩手机一样轻松，简直是PPT制作小白的救星！
【它的功能优势体现在哪里】
（1）AI智能生成：我们只需输入PPT的标题，软件即可智能识别并生成相应的PPT内容，大大节省了制作时间。
（2）精美模板库：内置多种类型的精美模板，我们可根据需求一键下载使用，并轻松编辑模板中的文本和图片。
（3）高效排版功能：在线制作的PPT在下载后，依然能够保持原有的专业排版设计。
2.Decktopus
Decktopus就像是一个魔法师，总能给你带来意想不到的惊喜。它的一键生成功能简直不要太方便，只需几秒钟，就能将你的文字内容转化成精美的PPT。
而且，它还提供了丰富的模板和素材库，你可以根据自己的喜好进行选择和定制，让你的演示文稿更加出彩。
【它的功能优势体现在哪里】
（1）个性化定制：提供即时幻灯片生成器、主题更改器等功能，我们可根据需求定制个性化的演示文稿。
（2）实时反馈：具备强大的实时反馈功能，能够收集观众的信息和反馈，帮助我们调整演示内容。
（3）简化工作流程：支持与其他工具集成，自动执行操作，简化工作流程，提高工作效率。
3.Beautiful.ai
Beautiful.ai，这款软件如其名，注重设计和美感。它不仅可以根据模板为你自动生成PPT，还能根据你的演讲风格进行个性化定制。
它的模板设计都非常精美，色彩搭配和排版布局都堪称一流。使用它，你的演示文稿定能成为会议中的亮点。
【它的功能优势体现在哪里】
（1）丰富的视觉效果：提供动态图形、动画和互动元素等，使演示文稿更加生动有趣。
（2）数据可视化：支持将数据自动转化为图表和图形，直观展示数据，便于观众理解。
（3）在线协作：支持多人在线协作编辑演示文稿，提高团队协作效率。
4.ClassPoint AI
“ClassPoint AI”也是一款值得一试的软件。它的AI技术非常先进，能够准确识别你的需求，并为你生成最符合你风格的PPT。
无论是商务场合还是教育领域，这款软件都能为你提供高效、专业的PPT制作功能，让你时时刻刻享受到PPT定制服务。
【它的功能优势体现在哪里】
（1）内容优化建议：通过AI技术分析内容，提供布局、设计和内容结构的优化建议，确保演示文稿的准确性和相关性。
（2）自动调整设计：根据我们的演讲风格和模板自动调整幻灯片设计，使演示更加个性化和吸引人。
（3）语音识别功能：支持将语音输入转换为文稿文本，提高制作效率。
5.SendstepsAi
再来说说“SendstepsAi”，这款软件的特点在于其强大的交互性和动态效果。它不仅可以选择合适的模板，为你自动生成专业级的PPT，还能在演示过程中添加各种动态效果和交互元素，让你的演示更加生动有趣。
另外，这款软件可以随时更改PPT中的内容，还支持多种格式的导入和导出，方便你与其他软件进行无缝对接。
【它的功能优势体现在哪里】
（1）一键生成：支持一键将文本内容转化为精美的PPT，操作简便快捷。
（2）交互与动态效果：在演示过程中可添加各种交互元素和动态效果，提升演示的吸引力和参与度。
（3）格式兼容性：支持多种格式的导入和导出，方便与其他软件的无缝对接。
6.AutoSlide
“AutoSlide”则是一款注重高效和精准的PPT制作工具。它的生成速度快如闪电，只需输入内容，几秒钟就能生成一份高质量的PPT。
而且，这款软件还支持实时修改和调整，可以根据自己的需求随时添加不同的元素，让你的演示文稿随时保持最新状态。
【它的功能优势体现在哪里】
（1）高效生成：只需输入文本内容，软件即可迅速生成相应的幻灯片，满足我们快速制作PPT的需求。
（2）模板与布局多样：提供多种模板和布局选择，大家可根据需求轻松创建专业的演示文稿。
（3）自定义样式：支持自定义幻灯片的样式和布局，满足个性化需求。
7.PowerMode AI
PowerMode AI可谓是PPT制作的终极利器，它不仅拥有强大的AI技术，还提供了丰富的模板和素材库，让你可以轻松打造出独具特色的演示文稿。
同时，它还支持多人协作和云端存储，方便你与团队成员共同完成PPT的制作和分享。
【它的功能优势体现在哪里】
（1）文本转幻灯片：能够将文本内容快速转换为幻灯片，提高制作效率。
（2）视觉元素分配：识别关键信息，并为其分配相应的视觉元素，创造出引人入胜的PPT。
（3）创意与参与度提升：适合希望在演示中加入创意元素、提升观众参与度的演讲者使用。
总的来说，以上七款超好用的AI自动生成PPT免费下载软件都是打工人必备的神器。它们不仅能够帮助你快速制作精美的演示文稿，还能让你的演示更加生动有趣。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571ad1d1d21c02bc39f30b9e1142ed6c/" rel="bookmark">
			AI绘画专栏之statble diffusion SDXL 1.0 更加精细的OpenPose DW Openpose(23)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更为精细的DW openpose
https://pan.quark.cn/s/8e66ada8a434
SD启动器2024最新版本下载
链接：https://pan.quark.cn/s/eea6375642fd
百度网盘复制到vx打开:
#小程序://百度网盘/QLGKUjisbuziV4B
OpenPose代表了第一个在单张图像上联合检测人体、手部、面部和足部关键点（共 135 个关键点）的实时多人系统。
全身（身体、脚部、面部和手部）2D 姿势估计 测试 OpenPose：（左）悉尼视频中的 Crazy Uptown Funk 快闪族。（中和右）作者吉内斯·伊达尔戈（Ginés Hidalgo）和托马斯·西蒙（Tomas Simon）测试面部和手部
全身 3D 姿态重建和估计 运行时分析 我们展示了 3 个可用的姿态估计库（相同的硬件和条件）之间的推理时间比较：OpenPose、Alpha-Pose（快速 Pytorch 版本）和 Mask R-CNN。OpenPose 的运行时间是恒定的，而 Alpha-Pose 和 Mask R-CNN 的运行时间随人数线性增长。更多细节在这里。
特征 主要功能：
2D实时多人关键点检测： 15、18 或 **25 个关键点身体/**脚部关键点估计，包括 6 个脚部关键点。运行时与检测到的人数不变。2x21 关键点手部关键点估计。运行时间取决于检测到的人数。请参阅 OpenPose Training，了解运行时不变的替代方案。70 个关键点人脸关键点估计。运行时间取决于检测到的人数。请参阅 OpenPose Training，了解运行时不变的替代方案。 3D实时单人关键点检测： 来自多个单个视图的 3D 三角测量。处理Flir热像仪的同步。兼容 Flir/Point Grey 相机。 校准工具箱：估计畸变、固有和外在相机参数。单人跟踪，可进一步加速或视觉平滑。 输入：图像、视频、网络摄像头、Flir/Point Grey、IP 摄像头，并支持添加您自己的自定义输入源（例如，深度摄像头）。
输出：基本图像+关键点显示/保存（PNG、JPG、AVI等），关键点保存（JSON、XML、YML等），KEY点作为数组类，并支持添加自己的自定义输出代码（例如，一些花哨的UI）。
操作系统： Ubuntu （20， 18， 16， 14）， Windows （10， 8）， Mac OSX， Nvidia TX2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/571ad1d1d21c02bc39f30b9e1142ed6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d359eec42bba243ce0b50c2d5867865/" rel="bookmark">
			前端大屏尺寸实现自适应屏幕大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说在前面 目前很多业主在使用系统的时候都会有大屏的需求，很多屏幕并不会像我们开发的屏幕一样标准，比如1920*1080，这样我们就需要根据业主的屏幕尺寸进行适配，避免一些图表或文字在大屏中出现偏移，影响视觉观感。
方案比选 方案一： 如果希望在大屏中实现最佳的展示效果，应该由设计人员针对大屏的尺寸进行单独设计，然后开发人员使用如下监听方式：
@media screen and (max-width: 2560px) {} @media screen and (min-width: 2561px) {} 以2561px为分界线，在屏幕尺寸大于分界线时来让不同的样式代码生效。
这种方案可以保证最好的展示效果，完美适配大屏，问题就是如果屏幕发生变化，或者需要适配其他尺寸的屏幕时，需要针对性的进行调整。
方案二： 使用vw和vh属性来表示dom节点的长宽。
举个例子：我们手里的设计稿是1920*1080，此时使用vw和vh,这样就可以适配大屏。
比如某个dom节点宽度为200px,高度为100px,此时设置他的宽高为：
.dom { width: (200 / 1920) * 100vw; height: (100 / 1080) * 100vh; } 原理也比较简单，对所有dom节点的宽高根据屏幕大小进行等比缩放，这样做的麻烦点是，代码中会有很多涉及到需要px单位的地方，每一处都需要写成这种形式，从操作上烦琐了不少。
方案三： 使用rem来实现响应式的布局，rem是相对于根元素的字体大小来计算的单位，配合引入相应的postcss相关插件，免去了设计稿中的px到rem的计算。
引入：postcss-plugin-px2rem,还有很多其他类似插件或者loader，引入一个即可。
.dom { width: 200px; height: 100px; } 编译以后的代码为： .dom { width: ..rem; height: ..rem; } 这样做的优势就是可以安全按照设计稿给出的尺寸来完成css布局，不需要操心转换等问题。
使用过程中的一些小坑 一些echarts图表是独立设置尺寸的 echarts总的大小会根据容器的大小调整，但是字体，间距等需要在代码中设置大小。
由于postcss-plugin-px2rem只能检测到css文件中的样式，所以需要单独处理，方案也比较简单，选中宽或者高为参考，进行等比缩放即可。
getSize(size) { // 这里是以高度为参考进行等比缩放 return size * (window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d359eec42bba243ce0b50c2d5867865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2740542d1dc29921efc23472a4736384/" rel="bookmark">
			Python爬虫(selenium)从网站获取信息并存入数据库(mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 在本篇博客中，我们将介绍如何使用Python编写一个简单的网络爬虫，从指定网站上获取图书信息，并将这些信息存入数据库。这个项目涉及到Python编程、selenium爬虫技术以及数据库操作等内容，适合对这些领域感兴趣的初学者。
1. 什么是网络爬虫？ 网络爬虫（也称为网络蜘蛛、网络机器人）是一种自动获取网页内容的程序，它模拟人的行为去各个网站抓取数据或返回数据。通过网络爬虫技术，我们可以从互联网中获取丰富的数据，为后续的数据分析和处理提供支持。
2. 项目概述： 本次项目爬取的是一个图书网站：scrape book，我们的项目包括四个主要部分：
CONN.py：连接数据库模块，负责与MySQL数据库建立连接。create_table.py：创建数据表模块，创建一个名为book_info的数据表，用于存储图书信息。insert_info.py：插入数据模块，向数据表中插入图书信息。main.py：主程序模块，负责爬取网页数据，并调用插入数据模块将信息存入数据库。 3. 项目详解：
具体爬取内容：
爬取一个网站的前提是了解这个网站的内容，以及网页布局，最后确定自己需要爬取的内容等。
首先准备工作：
工具（主要是方便查看数据库内容）：Navicat Premium 是一款功能强大的数据库管理工具，提供了用户友好的图形用户界面，使数据库管理变得更加简单和直观。为了更直观的查看数据库里面各种信息，建议安装这个软件，连接也很简单，点新建连接，就会弹出如下页面，连接名随意，其他都不用改，密码就是你安装mysql时设置的密码，我的就是123456，之后的连接数据库等的password也都是这个
然后，如果没有数据库需要先创建一个数据库，具体方法有很多，可以直接用navicat premium，直接右键连接，再点新建数据库，便创建好了，也可以用代码连接并创建数据库。
#此代码为数据库的创建，如果已经有数据库，则可忽略 import pymysql conn = pymysql.connect( host='localhost', port=3306, user='root', password='123456', charset='utf8mb4', ) # 创建数据库test create_db_sql = "CREATE DATABASE IF NOT EXISTS Scrape_book;"#此处创建了名为：Scrape_book的数据库 cursor = conn.cursor() cursor.execute(create_db_sql) # 关闭游标 cursor.close() # 关闭连接 conn.close() 接下来便是主要的代码：
CONN.py：这个模块定义了一个函数connect_mysql()，用于连接MySQL数据库，并返回连接对象。我们需要提供数据库的主机地址、用户名、密码、数据库名以及字符集等信息。注意：此处是Scrape_book这个数据库是已经存在的，如果没有数据库的请先创建数据库。 import pymysql def connect_mysql(): #建立与MySQL数据库的连接 conn = pymysql.connect( host='localhost', user='root', password='123456', db='Scrape_book', charset='utf8mb4' ) return conn create_table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2740542d1dc29921efc23472a4736384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f449cf06c3f16739f79ec356a4f31a49/" rel="bookmark">
			Python 中删除文件夹下文件的方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在编写和维护 Python 脚本时，经常会遇到需要删除文件夹中特定文件的情况。Python 提供了多种方法来实现这一目标，本文将介绍几种常用的方法，以及它们的优缺点和适用场景。
方法一：使用 os 模块 Python 的 os 模块提供了操作文件系统的功能，可以轻松实现删除文件夹下的文件。下面是一个简单的示例：
import os def delete_files_in_folder(folder_path): for filename in os.listdir(folder_path): file_path = os.path.join(folder_path, filename) if os.path.isfile(file_path): os.remove(file_path) # 使用示例 folder_to_clean = '/path/to/your/folder' delete_files_in_folder(folder_to_clean) 上面的代码首先列出指定文件夹下的所有文件和子文件夹，然后判断每个项目是文件还是文件夹。对于文件，使用 os.remove() 函数删除。
优点：
使用标准库，无需安装额外模块。简单直接，适用于基本的文件操作需求。 缺点：
不支持递归删除子文件夹中的文件。删除文件时无法处理权限问题或者文件被占用的情况。 方法二：使用第三方库 shutil shutil 是 Python 标准库中提供的高级文件操作模块，提供了更多文件操作的功能，包括递归删除文件夹及其内容。
import shutil def delete_files_in_folder(folder_path): shutil.rmtree(folder_path) # 使用示例 folder_to_clean = '/path/to/your/folder' delete_files_in_folder(folder_to_clean) 上面的代码使用 shutil.rmtree() 函数递归地删除文件夹及其所有内容。
优点：
支持递归删除，可以删除文件夹及其所有子文件夹和文件。简洁高效。 缺点：
一次性删除整个文件夹及其内容，请慎用，可能造成数据丢失。 方法三：使用 glob 模块 如果只需要删除特定类型的文件（例如某个后缀的文件），可以结合 glob 模块进行文件匹配和删除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f449cf06c3f16739f79ec356a4f31a49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d138269a77775487708cf55940901a12/" rel="bookmark">
			【技术】Spring Boot 将 Word 转换为 PDF 2.0 版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇 Spring Boot 将 Word 转换为 PDF 的文章，但是有评论说导入依赖有问题，还存在依赖冲突的问题。索性再来一个完整版的代码，之前的完整版代码找不到了，又重新整理了一下，依赖导入和之前不太一样，代码写法类似。
1、导入依赖
核心依赖：
&lt;!-- Apache POI --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- PdfConverter --&gt; &lt;dependency&gt; &lt;groupId&gt;fr.opensagres.xdocreport&lt;/groupId&gt; &lt;artifactId&gt;org.apache.poi.xwpf.converter.pdf&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt; 完整 pom.xml 文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.18&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.riu&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-demo&lt;/name&gt; &lt;description&gt;spring-boot-demo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Web 启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Thymeleaf 启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d138269a77775487708cf55940901a12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6d0efa937d313975ff179a1af476a8/" rel="bookmark">
			熵权法和topsis算法的综合应用：详解代码及注释，实现修正熵权法和自定义权重的topsis算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熵权法+topsis 代码 topsis 熵权法
一个代码可以四用，熵权法 topsis 基于熵权法修正的topsis 基于自己给定权重的topsis 都可以用！
代码有详细注释，有matlab即可运行
注释详细，一个按键运行即可
ID:2720677579783983
柚子的精神世界 熵权法和topsis是两种被广泛应用于数据分析和决策支持的方法。它们能够帮助我们在众多的选择中进行评估和排序，以找到最佳的解决方案。本文将围绕熵权法和topsis展开讨论，介绍它们的原理和应用，以及一个便捷的代码示例。
首先，我们来了解一下熵权法。熵权法是一种利用信息熵和权重分配原则来确定指标权重的方法。在实际决策问题中，不同的指标对结果的影响程度是不同的，而熵权法可以通过计算信息熵来确定指标的重要性，并给予其相应的权重。熵权法的优点在于能够充分考虑指标之间的相互关系，并且不需要事先给定权重，从而避免了主观性和随意性。
接下来，我们来介绍topsis。topsis是一种多指标决策方法，可以用于评估一系列选择方案的优劣。topsis的核心思想是，选择方案的最优解应该具有“最接近理想解”和“最远离负理想解”两个特性。具体来说，topsis通过计算每个方案到理想解和负理想解的距离，然后对这两个距离进行综合评估，从而确定每个方案的排名。topsis的优点在于能够同时考虑多个指标，并且具有稳健性和可解释性。
在实际应用中，我们经常会遇到需要同时使用熵权法和topsis的情况。例如，我们需要对一组供应商进行评估和排序，以确定最合适的供应商合作。我们可以先使用熵权法确定各个评估指标的权重，然后将这些权重带入topsis方法中，对每个供应商进行评估和排名。这样，我们就能够找到最佳的供应商，从而提升采购决策的质量和效率。
为了方便大家使用熵权法和topsis，我们提供了一个代码示例，并附有详细的注释。这个代码可以在Matlab环境中运行，并且只需要按下一个按键即可完成评估和排序过程。代码中的注释详细地解释了每个步骤的含义和实现方法，方便大家理解和使用。通过这个代码示例，你可以快速掌握熵权法和topsis的实际操作，并将其应用到自己的问题中。
总之，熵权法和topsis是两种实用的数据分析和决策支持方法。它们能够帮助我们在众多选择中进行评估和排序，并找到最佳的解决方案。本文介绍了熵权法和topsis的原理和应用，并提供了一个方便实用的代码示例。希望本文能够对你在实际工作中的决策问题有所帮助，让你能够更加高效和准确地做出决策。
以上相关代码,程序地址：http://coupd.cn/677579783983.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ca1a2a814023564587d0b21a999dd1/" rel="bookmark">
			若依前后端分离前端部署nginx反向代理后刷新页面失效及用户登录后404问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题背景nginx配置（解决页面刷新失效问题）注意点 用户登录后出现404问题描述问题解决 问题背景 项目需要部署到服务器之后由第三方进行了反向代理，所以我们必须适配第三方的url。由于第一次部署固定好路由格式的前端项目，途中遇到了比较多的问题。
nginx配置（解决页面刷新失效问题） 首先nginx.conf要配置正确，核心配置如下：
server { listen 前端端口; server_name 服务器ip; #charset koi8-r; #access_log logs/host.access.log main; location / { root dist所在目录/dist; try_files $uri $uri/ /index.html; index index.html index.htm; } location /prod-api/{ proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass 后端访问url; } } 注意点 服务器ip可以是代理之后的urltry_files $uri $uri/ /index.html;可以让页面刷新后重新定向，加上就能解决刷新页面失效问题若依前后端分离部署时带后缀/prod-api，定向时需要加上后端访问url即在前端vue.config.js中，proxy里的[process.env.VUE_APP_BASE_API]中target后填写的url 用户登录后出现404 问题描述 用户登录后页面重定向到404页面，点击返回首页后才能进入到正常页面
问题解决 前端需要增设子路径，如：/app（参考若依文档-&gt;前端手册-&gt;应用路径）一定要看文档！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9785c015ec0e3d7355c363bf2d4256/" rel="bookmark">
			Midjourney和stable diffusion到底有什么区别？要怎么选？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 目前AIGC领域里最强的两款软件，Midjourney（MJ）和stable diffusion（SD）到底有什么区别？我们应该怎么选择呢？这是很多新手朋友经常问的问题，这篇文章对此问题专门进行解释说明。
在aigc界的地位
MJ和SD在aigc界都算是“顶流”的存在。基本上没有能与之抗衡的其他主流产品。
四个门槛型问题 在了解两者的功能之前，我们先来看看4个门槛型的问题。分别是：如何收费、设备要求、安装部署、学习成本。
MJ是收费的，按年或者按月收取会员费。最低一个月10美金，最高一个月120元美金。有4个不同的档位，对应着不同的套餐。最低套餐一个月大概70元，多人拼车，价格更低。而SD是完全开源免费的，非常良心。
其次，是对设备的要求。MJ对设备没有任何要求，因为它本质是一个网站、或者说是一个APP。所有只要是能打开网站的设备，都可以使用MJ，包括电脑、pad甚至是手机，没有任何限制。而SD只能在电脑上使用，并且对电脑的性能有一定要求，尤其是对显卡，要求比较高。最低也要6GB，而且随着使用的深入，对显卡的要求会逐步提升。
第三，安装部署。如上文所说，MJ不需要所谓的安装，打开discord即可使用。而SD则需要手动安装部署，才能开始使用，有一定的使用门槛。
最后，是学习成本。MJ是一款收费不低的成熟商业产品，它的UI界面、交互操作，都是在一定水准之上的，上手难度低，新人友好。而SD由于是开源免费的，更加极客风格，界面复杂，参数插件很多。从使用感上来说，确实比不上MJ，不过毕竟是开源免费的，也不能要求太高。
两者的优势侧重不同 知道了两款工具的使用门槛之后，我们再来看它们的优势侧重。首先，MJ是更加发散灵活的，能轻松驾驭各种画风，图片审美成熟稳定。而SD在审美上处于劣势，但是非常适合精细控制局部细节，这点是MJ的短板。
MJ的灵活发散体现在对各种画风的驾驭能力，随着版本的不断更新迭代，MJ的画风库越来越丰富，学习能力在肉眼可见地不断提升。
同时，MJ的出图效率也非常高。在打开turbo模式的情况下，一分钟大概可以出图12-16张左右。效率非常惊人。
虽说MJ的控制性比较差，但是也可以在电商设计中，进行提效辅助。比如生成各种类型的场景图，来高效更换产品的视觉风格。
当然了，MJ还是最适合用来做创意灵感图片素材。从画面整体的表现力和审美上来说，都找不到什么短板。
而SD的强项是控制。非常适合用来做线稿上色、线稿转立体等效果。SD可以保证，线稿的元素保持一致，不被扭曲变形，这点MJ是没有办法完全达到的。
包括上方这种汉字效果，都只能用SD实现。本质上，SD能在确定“骨架”的基础上做延展，而MJ有着很难避免的随机性，对于“骨架”会有一定程度的破坏。不过未来MJ应该也会不断提升可控性。前阵子MJ推出的“–sref（风格参考）”和“–cref（角色参考）”就展示了MJ对于“可控性”提升的目标方向。
总结
收费：MJ要花钱，SD免费。 操作：MJ简单易用，SD操作复杂。
优势：MJ灵活高效风格众多，SD精细可控。
MJ本质上收取了会员费，提供了云端算力，解放了用户的设备限制。同时也提供了更好的使用体验，界面操作更加人性化。
我们可以根据不同的实际需求，来选择，使用哪一款产品。
所有的AI设计工具安装包和实操教程，模型和插件，魔法词都已经整理好了，文末扫码即可免费获取噢~
写在最后 AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
感兴趣的小伙伴，赠送全套AIGC学习资料和安装工具，包含AI绘画、AI人工智能等前沿科技教程，模型插件，具体看下方。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b890b9d192830a9619094ee182b7e888/" rel="bookmark">
			从零开始的vscode配置及安装rust教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置vscode的rust环境 下载安装vscodemac 环境1. 下载安装rust2. 配置 mac vscode环境3. 创建一个测试项目 windows 环境1. 安装c++运行环境2. 安装配置rustup3. 配置windows vscode环境4. 创建一个测试项目 下载安装vscode 1.官网应用程序下载 vscode：https://code.visualstudio.com(根据电脑操作系统选择对应版本)
2.安装教程可查阅：转自vscode保姆级安装配置
mac下载：
windows下载
mac 环境 1. 下载安装rust 输入命令
// 打开mac终端执行如下代码： curl https://sh.rustup.rs -sSf | sh 终端会自动进入安装状态，提示你是否安装，选用默认安装（直接Enter）即可。然后稍等一会就会提示安装完成。
重启一个新的终端应用rust的环境变量或者直接在终端执行以下命令让环境变量生效：
// 在mac终端执行如下代码： source $HOME/.cargo/env 检测rust是否安装成功，安装成功会显示类似如下信息，不成功则重新走一遍安装rust流程。
~ rustc --version rustc 1.32.0 (25efde3d8 2024-04-09) 2. 配置 mac vscode环境 安装插件
Rust
Rust-analyzer
crates
CodeLLDB
Rust Syntax
Rust Test Lens
Better TOML
使用vscode终端执行如下命令（快捷键：ctrl+ `）://安装rust的一些拓展插件 rustup component add rls rust-analysis rust-src 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b890b9d192830a9619094ee182b7e888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7d6d9d993107baa34d4b6c1bce2760/" rel="bookmark">
			nginx偶发报错：【502】 upstream prematurely closed connection while reading response header from upstream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户端反馈接口报错502，然后在服务端没有找到相关的请求日志。在nginx的error.log和access.log中确实发现了对应的日志。access.log记录的是502，error.log记录了原因：upstream prematurely closed connection while reading response header from upstream。想起了之前用httpclient调微信接口时也报过类似的错误，原因是用http线程池，服务端关闭了连接，而连接池不知道，发请求时触发，后续httpclient有升级进行相关检查。所以想是不是也是因为开启了keepalive的原因？
问了运维nginx确实开启了keepalive。但这个错误并不是客户端到nginx之间的，而是nginx到upstream之间。我给运维的建议是1、设置upstream的keepalive_timeout小于tomcat的connectTimeOut值，2、把max_fails设置为3。运维只同意修改max_fails=3。
一段时间后又查看了nginx日志，error.log中依然有错误日志，但是access.log中没有了502，因为重试后都成功了。可以看到access.log日志中的upstreamhost和upstreamtime里有了多个值，正常情况只有一个值。第一个是第一次请求时的情况，第二个值是重试的情况。
当然修改max_fails还有一些需要注意的地方。因为nginx可能根据请求方法的不同比如是post还是get、方法返回的状态不同而决定是否进行重试。而有的重试可能会导致一些负面作用，所以对接口是否幂等需要关注下。
参考文档：
Nginx upstream长连接报错问题排查过程
Nginx+Tomcat偶现502分析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc083b35f37de5e95c9f65e66141f9a6/" rel="bookmark">
			一文搞懂策略梯度（Policy gradient）算法（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在强化学习的过程中，从 Sarsa 到 Q-learning 再到 DQN，本质上都是值函数近似算法。
值函数近似算法都是先学习动作价值函数，然后根据估计的动作价值函数选择动作。如果没有动作价值函数的估计，策略也就不会存在。 例如，DQN的神经网络结构可以表示为如下图所示：
图中，输入是状态 s s s，输出是每个动作的 Q Q Q 值，即对每个动作的评分，分数越高意味着动作越好。通过对值函数的近似，我们可以知道回报最大的路径，从而指导智能体进行动作的选取。
但是，强化学习的目标，是学习最优策略。那么有没有一种可能，我们可以跳过动作价值的评估环节，直接从输入状态，到输出策略呢？
——策略梯度算法
在策略梯度算法中，策略函数的输入是状态 s s s 和动作 a a a，输出是一个0到1之间的概率值，当前最有效的方法是用神经网络近似策略函数。给出一个策略网络结构图：
如图，在策略网络结构中，输入是状态 s s s，输出是动作空间中每个动作的概率值。
两个关键 现在我们已经有了想法——直接从输入得到最优策略，那么随之而来
两个问题：
1、如何来衡量一个策略的好与坏？
2、如何搜索最优策略？
先来看看《强化学习》中关于策略梯度算法的定义：
策略梯度方法基于某种性能度量 J ( θ ) J(\theta) J(θ) 的梯度，这些梯度是标量 J ( θ ) J(\theta) J(θ) 对策略参数的梯度。这些方法的目标是最大化性能指标，所以它们的更新近似于 J J J 的梯度上升
梯度上升： θ t + 1 = θ t + α ∇ J ( θ t ) ^ \theta_{t+1}=\theta_t+\alpha\widehat{\nabla{J(\theta_t)}} θt+1​=θt​+α∇J(θt​) ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc083b35f37de5e95c9f65e66141f9a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59cf7d2d286f69ce89950a2122aedd4/" rel="bookmark">
			【Spring Security系列】Spring Security整合JWT：构建安全的Web应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在企业级开发或者我们自己的课程设计中，确保用户数据的安全性和访问控制非常重要。而Spring Security和JWT是都两个强大的工具，它俩结合可以帮助我们实现这一目标。
Spring Security提供了全面的安全功能，而JWT则是一种用于身份验证的令牌机制。
JWT简单介绍 前面两个章节介绍过了Spring Security，这里就不再赘述了！！！
JWT是一种轻量级的身份验证和授权机制，通过发送包含用户信息的加密令牌来实现身份验证。这个工具我们在前面的文章中也提起过。
整合步骤与代码实现 目前大部分项目，大多数是使用前后端分离的模式。前后端分离的情况下，我们使用SpringSecurity解决权限问题的最常见的方案就是SpringSecurity+JWT 。
添加依赖
首先，我们需要在项目的pom.xml文件中添加Spring Security和JWT的依赖：
&lt;!--JWT--&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.0.M3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt; &lt;/dependency&gt; 接下来配置Spring Security，在Spring Security配置类中，我们自定义用户详情服务和认证管理器，并配置HTTP安全策略：
@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint; @Autowired private JwtRequestFilter jwtRequestFilter; @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService()).passwordEncoder(passwordEncoder()); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a59cf7d2d286f69ce89950a2122aedd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95045a9857c4ad586455df52fbc8a400/" rel="bookmark">
			Vue-Web-Portal: 一款高效、灵活的企业级门户框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue-Web-Portal: 一款高效、灵活的企业级门户框架 是一个基于 Vue.js 的强大企业级门户网站构建框架，它为开发者提供了构建现代化、响应式且易于维护的Web应用的工具和模板。本文将深入探讨该项目的核心技术、应用场景及特点，以便让更多开发者了解并加入到Vue-Web-Portal的社区中。
技术分析 基础架构：
Vue.js：Vue-Web-Portal是建立在Vue.js 2.x之上的，利用Vue的组件化特性，使得代码结构清晰，易于扩展。Vuex：用于管理全局状态，提供了一个集中式的存储机制，帮助维护复杂应用的状态流。Vue Router：强大的路由管理系统，支持动态路由和命名视图，方便页面间的跳转与导航。 开发工具：
Webpack：集成的Webpack配置，优化了资源加载和打包过程。ES6/7：使用现代JavaScript语法，提升代码可读性和开发效率。Prettier &amp; ESLint：代码风格和质量检查工具，确保代码规范统一。 API封装：
使用axios进行HTTP请求，内置拦截器，方便处理请求和响应错误。提供通用接口封装，简化后端API调用。 多语言支持：
集成i18n国际化插件，轻松实现多语言切换。 主题定制：
支持自定义主题样式，通过scss变量进行全局颜色和样式的调整。 应用场景 Vue-Web-Portal特别适合需要构建以下类型的应用：
大型企业内部的信息门户个性化的工作台多模块、多业务线的Web应用数据展示丰富的后台管理系统 项目特点 快速启动：预设的工程结构和配置，让开发者可以立即开始编写业务代码，缩短项目初始化时间。易扩展性：模块化的组件设计，使得添加新功能或整合第三方库变得简单。良好的性能：通过懒加载和按需引入，减少首屏加载时间，提升用户体验。强大的文档：详尽的文档和示例，有助于快速理解和上手。活跃的社区支持：项目有持续的更新和维护，社区活跃，问题能得到及时解决。 Vue-Web-Portal不仅是一个框架，更是一整套解决方案，致力于帮助企业快速搭建稳定、高效的Web应用。如果你正在寻找一个能够提高开发效率并且具有高度灵活性的前端框架，那么Vue-Web-Portal无疑是一个值得尝试的选择。赶快加入社区，开启你的高效开发之旅吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb00a058f6c99ed53a6c74b874f02f09/" rel="bookmark">
			报错：ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full c
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 pip install 安装包时拨错：
ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.
解决：
pip install --upgrade setuptools &amp;&amp; python -m pip install --upgrade pip 然后再使用 pip install 安装需要的包，就可以成功安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac079fee61a97f327164abb8a933afaf/" rel="bookmark">
			人工智能小白必读：一份超详细的AI学习路线图！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能学习路线1.0 前言 哈喽~ 大家好！
今天为大家带来一份史无前例的人工智能学习路线。大家都喜欢看修仙小说吧，修仙小说中的修仙等级：炼气、筑基、金丹等各种境界，更是引人入胜。今天，小编将AI学习路线和修仙故事巧妙地融合在一起，通过修仙等级来形象地展示人工智能在不同阶段的学习和成长。
不过本人能力有限，如果存在不足之处，欢迎大家在评论区进行沟通交流。共同学习，共同进步。
学习大纲 一、炼气期：人工智能入门 AI基本知识
编程知识
学习建议
Python知识点
Python常用库
推荐书籍
数学知识
学习建议
数学知识
推荐书籍
二、筑基期：机器学习小成 学习建议
知识点
推荐书籍
三、金丹期：深度学习大成 学习建议
知识点
推荐书籍
四、元婴期：人工智能圆满 五、化神期：人工智能大圆满 一、炼气期：人工智能入门 炼气期，此乃入门之始，习者需调息吐纳，采日月精华，聚天地灵气于己身，以为根基。
对于AI修行者，在这个境界需要通过各种基础知识来夯实自己的“AI道基”，如，AI知识、编程知识、数学知识等，只有AI道基圆满的修行者，才能在人工智能领域越走越远。
AI基本知识 学习建议：对于这一块内容的学习，大家不用花太多的时间（建议：1~2h）。
通过“花书”和“西瓜书”的前言可以快速了解AI基本知识、发展历程和应用领域
至于行业应用和岗位薪资等，大家可以通过互联网资源进行检索，或者问一下AI，如，天工AI、Kimi.ai（现在还是免费的哦，嘻嘻~）。
通过对这些知识的了解，能帮助大家建立对AI的整体的认知，并明确自己的学习目标和方向。
大家先眼熟一下：
机器学习
监督学习
无监督学习
半监督学习
强化学习
线性回归
决策树
深度学习
神经网络
卷积神经网络(CNNs)
循环神经网络(RNNs)
PyTorch
自然语言处理(NLP)
计算机视觉(CV)
编程知识 学习建议：目前，主流的AI学习的编程语言——Python，而选择Python作为AI学习的编程语言主要有以下几个原因：
丰富的库和框架：Python拥有大量的第三方库和框架，这些库和框架使得Python在处理各种任务时都非常高效，尤其是在数据分析和机器学习方面。例如，NumPy、Pandas、Scikit-learn、TensorFlow、Keras、PyTorch等都是非常流行的数据科学和机器学习库。
简洁易读：Python的语法简单明了，可读性强，这使得初学者更容易上手。它的设计哲学强调代码的可读性和简洁性，这使得编写代码变得相对容易，并且易于维护和协作。
社区支持强大：Python有一个庞大的开发者社区，这意味着你可以轻松找到解决问题的帮助和指导。当你遇到困难时，可以在Stack Overflow或其他论坛上提问并获得答案。
跨平台兼容：Python可以在多个操作系统（如Windows、Linux和Mac OS）上运行，这对于希望在不同平台上工作的人来说非常重要。
广泛的应用范围：Python不仅可以用于Web开发和桌面应用程序，还可以用于游戏开发、科学计算等领域。这使得Python成为一个多功能的语言，适用于多种应用场景。
强大的数据分析和可视化工具：除了机器学习外，Python还有强大的数据分析和可视化工具，如Pandas、Matplotlib、Seaborn等，这些工具对于数据分析和数据可视化非常有用。
综上所述，Python因其易用性、灵活性和强大的生态系统成为了人工智能领域的首选编程语言之一。
Python知识点：
变量和数据类型：Python中的变量可以直接赋值，不需要声明类型。常用的数据类型包括整数（int）、浮点数（float）、字符串（str）、布尔值（bool）、列表（list）、元组（tuple）、字典（dict）等。
流程语句：if语句、for循环、while循环以及try/except语句用于控制程序执行流程。
函数：定义函数的关键字是def，后跟函数名和括号内的参数。使用return返回值。
类和对象：Python是面向对象的编程语言，一切皆对象。类使用class关键字定义，可以通过构造函数__init__()初始化对象。
模块和包：Python允许导入其他文件中的代码，每个文件都可以作为一个独立的模块。使用import语句导入模块，然后调用其中的函数和变量。
异常处理：使用try/except语句捕获并处理可能发生的错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac079fee61a97f327164abb8a933afaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9725404a1ca54743415cf4faf968e1/" rel="bookmark">
			mysql把查询结果按逗号分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL如何把查询结果按逗号分割 在实际的数据库查询中，有时候我们需要将查询结果按逗号分割成一个字符串，以便于在应用程序中进一步处理或展示。本文将介绍如何使用MySQL数据库来实现将查询结果按逗号分割的方法。
步骤一：使用GROUP_CONCAT函数 MySQL提供了一个非常便捷的函数GROUP_CONCAT，可以将查询结果按指定的分隔符连接起来，从而实现将查询结果按逗号分割的效果。 以下是一个示例：
sqlCopy code SELECT GROUP_CONCAT(column_name SEPARATOR ',') AS concatenated_result FROM table_name; 在上述示例中，column_name是你想要进行连接的列名，table_name是你要查询的表名。SEPARATOR ','表示使用逗号作为分隔符，你可以根据需要选择其他分隔符。
示例 假设有一个名为student的表，包含id和name两列，我们希望将所有学生的姓名按逗号分割成一个字符串。以下是一个示例查询：
sqlCopy code SELECT GROUP_CONCAT(name SEPARATOR ',') AS all_names FROM student; 执行以上查询后，将会得到一个包含所有学生姓名，用逗号分割的字符串。
注意事项 GROUP_CONCAT函数的默认最大长度是1024个字符，如果你的结果超过这个长度，可以通过设置group_concat_max_len参数来调整。当结果集比较大时，可能需要考虑性能问题，可以根据具体情况进行优化。 通过上述方法，你可以方便地在MySQL中将查询结果按逗号分割，适用于各种需要汇总数据并以字符串形式呈现的场景。希朿这篇文章对你有所帮助！ 一个名为orders的表，存储了订单信息，包括订单号order_id和商品名称product_name。现在，我们希望查询出每个订单对应的所有商品名称，并将其按逗号分割成一个字符串。 以下是一个结合实际应用场景的示例代码：
sqlCopy code -- 创建示例表orders CREATE TABLE orders ( order_id INT, product_name VARCHAR(50) ); -- 插入示例数据 INSERT INTO orders (order_id, product_name) VALUES (1, 'Apple'), (1, 'Banana'), (1, 'Orange'), (2, 'Laptop'), (2, 'Mouse'), (3, 'Book'), (3, 'Pen'); -- 查询每个订单的商品名称，并按逗号分割成一个字符串 SELECT order_id, GROUP_CONCAT(product_name SEPARATOR ', ') AS all_products FROM orders GROUP BY order_id; 在上述示例中，首先创建了一个名为orders的表，插入了一些示例数据。然后，通过查询将每个订单对应的商品名称按逗号分割成一个字符串，并使用GROUP_CONCAT函数实现了这一功能。最后，按订单号进行分组，得到了每个订单的商品名称列表。 通过这个示例，可以看到如何结合实际场景使用MySQL的GROUP_CONCAT函数将查询结果按逗号分割，并提取出有用的信息。在实际开发中，可以根据具体需求灵活运用这一技术，以满足不同的数据处理和展示需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9725404a1ca54743415cf4faf968e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0a68c198b4db65d3effbf58dcace45/" rel="bookmark">
			AI大模型量化格式介绍（GPTQ，GGML，GGUF，FP16/INT8/INT4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 HuggingFace 上下载模型时，经常会看到模型的名称会带有fp16、GPTQ，GGML等字样，对不熟悉模型量化的同学来说，这些字样可能会让人摸不着头脑，我开始也是一头雾水，后来通过查阅资料，总算有了一些了解，本文将介绍一些常见的模型量化格式，因为我也不是机器学习专家，所以本文只是对这些格式进行简单的介绍，如果有错误的地方，欢迎指正。
What 量化 量化在 AI 模型中，特别是在深度学习模型中，通常指的是将模型中的参数（例如权重和偏置）从浮点数转换为低位宽度的整数，例如从 32 位的浮点数转换为 8 位整数。通俗地说，量化就像是把一本详细的、用高级词汇写的书简化为一个简短的摘要或儿童版故事。这个摘要或儿童版故事占用的空间更小，更容易传播，但可能会丢失一些原始书中的细节。
Why 量化 量化的目的主要有以下几点：
减少存储需求：量化后的模型大小会显著减小，这使得模型更容易部署在存储资源有限的设备上，如移动设备或嵌入式系统。加速计算：整数运算通常比浮点运算更快，尤其在没有专门的浮点硬件支持的设备上。减少能耗：在某些硬件上，整数运算消耗的能量更少。 但是，量化也有一个缺点：它可能会导致模型的精度下降。因为你实际上是在用较低的精度来表示原始的浮点数，可能会损失一些信息，这意味着模型的能力会变差。为了平衡这种精度损失，研究者们开发了各种量化策略和技术，如动态量化、权重共享等，可以在尽量少降低模型能力的情况下，尽可能多地降低模型所需的损耗。打个比方，如果我们一个模型的完整能力是 100，模型大小和推理所需内存也是 100，我们将这个模型量化后，模型的能力可能会降低到 90，但模型大小和推理所需内存可能会降低到 50，这个就是量化的目的。
FP16/INT8/INT4 HuggingFace 上模型名称如果没有特别标识，比如Llama-2-7b-chat、chatglm2-6b，那么说明这些模型一般是全精度的(FP32，但也有些是半精度 FP16)，而如果模型名称中带有fp16、int8、int4等字样，比如Llama-2-7B-fp16、chatglm-6b-int8、chatglm2-6b-int4，那么说明这些模型是量化后的模型，其中fp16、int8、int4字样表示模型的量化精度。
量化精度从高到低排列顺序是：fp16&gt;int8&gt;int4，量化的精度越低，模型的大小和推理所需的显存就越小，但模型的能力也会越差。
以ChatGLM2-6B为例，该模型全精度版本(FP32)的大小为 12G，推理所需用到的显存为 12~13G，而量化后的 INT4 版本模型大小为 3.7G，推理所需显存为 5G，可以看到量化后的模型大小和显存需求都大大减小了。
FP32 和 FP16 精度的模型需要在 GPU 服务器上运行，而 INT8 和 INT4 精度的模型可以在 CPU 上运行。
GPTQ GPTQ 是一种模型量化的方法，可以将语言模型量化成 INT8、INT4、INT3 甚至 INT2 的精度而不会出现较大的性能损失，在 HuggingFace 上如果看到模型名称带有GPTQ字样的，比如Llama-2-13B-chat-GPTQ，说明这些模型是经过 GPTQ 量化的。以Llama-2-13B-chat为例，该模型全精度版本的大小为 26G，使用 GPTQ 进行量化成 INT4 精度后的模型大小为 7.26G。
如果你用的是开源模型LLama，可以使用GPTQ-for-LLaMA这个库来进行 GPTQ 量化，它可以将相关的Llama模型量化成 INT4 精度的模型。
但现在更流行的一个 GPTQ 量化工具是AutoGPTQ，它可以量化任何 Transformer 模型而不仅仅是Llama，现在 Huggingface 已经将 AutoGPTQ 集成到了 Transformers 中，具体的使用方法可以参考这里。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc0a68c198b4db65d3effbf58dcace45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb43d7abb0ebc9606588667396a953ef/" rel="bookmark">
			【论文阅读】Retrieval-Augmented Generation for AI-Generated Content: A Survey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Retrieval-Augmented Generation for AI-Generated Content: A Survey 论文地址：https://arxiv.org/abs/2402.19473
项目存储库：https://github.com/hymie122/RAG-Survey
Penghao Zhao, Hailin Zhang, Qinhan Yu, Zhengren Wang, Yunteng Geng, Fangcheng Fu, Ling Yang, Wentao Zhang, Bin Cui, Fellow, IEEE
摘要—人工智能生成内容（AIGC）的发展得益于模型算法的进步、基础模型规模的增加以及大量高质量数据集的可用性。虽然AIGC取得了显著的性能，但仍面临一些挑战，如难以保持最新和长尾知识、数据泄露的风险以及与训练和推理相关的高成本。检索增强生成（RAG）最近出现作为一种范式来解决这些挑战。具体而言，RAG引入信息检索过程，通过从可用数据存储中检索相关对象来增强生成过程，从而提高准确性和鲁棒性。本文全面审查了将RAG技术整合到AIGC场景中的现有努力。我们首先根据检索器如何增强生成器对RAG基础进行分类，梳理各种检索器和生成器的增强方法的基本抽象。这种统一的视角涵盖了所有RAG场景，阐明了有助于潜在未来进展的进步和关键技术。我们还总结了RAG的其他增强方法，促进了RAG系统的有效工程和实施。然后，从另一个角度，我们调查了RAG在不同模态和任务中的实际应用，为研究人员和从业者提供了有价值的参考。此外，我们介绍了RAG的基准，讨论了当前RAG系统的局限性，并提出了未来研究的潜在方向。
arXiv:2402.19473v2 [cs.CV] 2024年3月27日
关键词—检索增强生成，人工智能生成内容，生成模型，信息检索。
引言 背景 近年来，人工智能生成内容（AIGC）引起了广泛关注。各种内容生成工具被精心设计，以在各种模态下产生多样化的输出，例如大型语言模型（LLM），包括GPT系列[1]–[3]和LLAMA系列[4]–[6]用于文本和代码，DALL-E[7]–[9]和Stable Diffusion[10]用于图像，以及Sora[11]用于视频。术语“AIGC”强调这些内容是由先进的生成模型而不是人类或基于规则的方法产生的。这些生成模型由于采用了新颖的模型算法、庞大的基础模型规模和大量高质量数据集而取得了显著的性能。具体而言，序列到序列任务已经从使用长短期记忆（LSTM）网络[12]转变为基于Transformer模型[13]，图像生成任务也已从生成对抗网络（GANs）[14]转变为潜在扩散模型（LDMs）[10]。值得注意的是，基础模型的架构，最初由数百万参数构成，现在已经增长到数十亿甚至数万亿的参数。这些进展进一步得到了丰富高质量数据集的支持，这些数据集提供了丰富的训练样本，以充分优化模型参数。
信息检索是计算机科学领域的另一个关键应用。与生成不同，检索旨在从大量资源中定位相关的现有对象。检索最常见的应用在于网络搜索引擎，主要关注文档检索任务。在当前时代，高效的信息检索系统可以处理数十亿级别的文档集合。除了文档，检索还被应用于许多其他模态。
尽管先进的生成模型取得了显著进展，AIGC仍然面临一些众所周知的挑战，包括难以保持最新知识、无法整合长尾知识和泄露私人训练数据的风险。检索增强生成（RAG）被提出来缓解，如果不是完全解决，上述挑战，通过其可适应的数据存储库。存储的知识可以被构想为非参数化记忆。这种形式的记忆易于修改，能够容纳广泛的长尾知识，并且还能够编码机密数据。此外，检索还可以用于降低生成成本。例如，RAG可以减小大型生成模型的大小，为长上下文提供支持，并消除某些生成步骤。
典型的RAG过程如图1所示。给定一个输入查询，检索器定位并查找相关数据源，然后检索结果与生成器互动以增强整个生成过程。检索结果可以以不同方式与生成过程互动：它们可以作为生成器的增强输入；它们可以在生成的中间阶段作为潜在表示加入；它们可以以logits的形式对最终生成结果做出贡献；它们甚至可以影响或省略某些生成步骤。此外，在典型的基础RAG过程基础上，还提出了许多增强方法来提高整体质量。这些增强方法涵盖了特定组件的方法以及针对整个流程的优化。
图1. 通用的RAG架构。用户的查询，可能是不同的模态，作为检索器和生成器的输入。检索器在存储中搜索相关数据源，而生成器与检索结果互动，最终产生各种模态的结果。
此外，尽管RAG的概念最初出现在文本到文本生成中，但它也已经适应到各个领域，包括代码、音频、图像、视频、3D、知识和科学人工智能。特别是，RAG的基本思想和过程在各种模态下基本一致。然而，它需要在增强技术上进行特定的微调，并且检索器和生成器的选择因特定模态和/或应用而异。
尽管最近对RAG的研究迅速增长，但缺乏涵盖所有基础、增强和应用的系统性审查。对RAG基础缺乏讨论显著削弱了该领域研究的实际价值，使RAG的潜力没有得到充分探索。尽管大多数研究兴趣，特别是在LLM研究人员中，集中在基于查询的文本生成任务上，但必须承认，其他RAG基础范式也是有效的技术，具有重要的用途和进一步发展的潜力。对RAG应用缺乏概述导致研究人员和从业者忽视了RAG在多个模态中的进展，并且不了解如何有效应用RAG。尽管文本生成通常被认为是RAG的主要应用，但我们强调RAG在其他模态中的发展也在早期阶段开始，并取得了令人期待的进展。某些模态与检索技术有着丰富的历史联系，为RAG注入了独特的特征。尽管已经提出了一些关于RAG的调查，但它们主要集中在部分方面，如特定方法和任务。在本文中，我们的目标是提供一项全面的调查，以系统概述RAG。
贡献 本调查全面概述了RAG，涵盖了基础、增强、应用、基准、局限性和潜在未来方向。虽然检索器和生成器在不同模态和任务中存在差异，但我们从这些基础中提炼了RAG基础的基本抽象，考虑到应用是从这些抽象中衍生出来的。我们旨在为研究人员和从业者提供参考和指导，为推进RAG方法和相关应用提供有价值的见解。总之，我们列出我们的贡献如下：
我们对 RAG 进行了全面的回顾，并提炼了适用于各种检索器和生成器的 RAG 基础抽象。我们总结了对现有 RAG 流程的增强，详细阐述了用于实现更有效 RAG 系统的技术。对于各种模态和任务，我们调查了融合了 RAG 技术的现有 AIGC 方法，展示了 RAG 如何对当前的生成模型做出贡献。我们讨论了 RAG 的局限性和有前途的研究方向，揭示了其潜在的未来发展。 *相关工作* 随着对 RAG 的研究不断深入，提出了几篇关注 RAG 的综述论文。Li 等人 [56] 对文本生成的 RAG 进行了调查。由于该综述覆盖了截至 2022 年的论文，许多新的 AIGC 中 RAG 的进展并未包含在内。Asai 等人 [57] 提供了关于基于检索的语言模型的教程，介绍了架构和训练范式。Gao 等人 [58] 对 LLMs 中的 RAG 进行了调查，特别是研究了基于查询的 RAG 的增强。上述调查主要考虑了由 LLMs 支持的文本相关任务中的 RAG，将其他模态作为潜在扩展。然而，RAG 的概念在早期阶段就涉及到所有模态，使其更适合在整个 AIGC 的更广泛背景下讨论。Zhao 等人 [59] 提出了一项关于多种模态的 RAG 应用的调查，但忽略了对 RAG 基础的讨论。这些调查要么专注于单一的 RAG 基础范式，要么仅对有限情景下的 RAG 增强方法论进行简要概述。因此，虽然现有研究已经探讨了 RAG 的各个方面，但仍然需要全面概述系统地涵盖 RAG 的基础、增强以及其在不同领域中的适用性。在本文中，我们旨在提供一份系统性的 RAG 概述，以填补这些空白。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb43d7abb0ebc9606588667396a953ef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/403/">«</a>
	<span class="pagination__item pagination__item--current">404/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/405/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>