<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9696c0d1eb531a971edd3bc300f388af/" rel="bookmark">
			[C&#43;&#43;][设计模式][访问器]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.动机2.模式定义3.要点总结4.代码感受1.代码一2.代码二 1.动机 在软件构件过程中，由于需求的变化，某些类层次结构中常常需要增加新的行为(方法)，如果直接在基类中做这样的更改， 将会给子类带来很繁重的变更负担，甚至破坏原有设计如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上面的问题？ 2.模式定义 定义：表示一个作用与某对象结构中的各元素的操作功能：使得可以在不改变(稳定)各元素的类的前提下定义(扩展)作用于这些元素的新操作(变化)结构
3.要点总结 Visitor模式通过所谓的双重分发(double dispatch)来实现在不更改(编译时)Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作(支持变化)所谓双重分发Visitor模式中间包括了两个多态分发 第一个为accept方法的多态辨析第二个为visitElement方法的多态辨析 Visitor模式的最大缺点在于扩展类层次结构(添加新的Element子类)，会导致Visitor类的改变 因此Visitor模式适用于“Element类层次结构稳定，而其中的操作却经常面临频繁改动” 4.代码感受 1.代码一 class Visitor; class Element { public: virtual void Func1() = 0; virtual void Func2(int data) = 0; virtual void Func3(int data) = 0; //... virtual ~Element(){} }; class ElementA : public Element { public: void Func1() override {} void Func2(int data) override {} }; class ElementB : public Element { public: void Func1() override {} void Func2(int data) override {} }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9696c0d1eb531a971edd3bc300f388af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7b10b3348055c7be4b83a474ac0621/" rel="bookmark">
			JAVA开发环境的搭建（JDK下载与安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是JDK、JRE JDK（Java Development Kit）：是Java程序开发工具包，包含JRE和开发人员使用的工具。
JRE（Java Runtime Environment）：是Java程序的运行时环境，包含JVM和运行时所需要的核心类库。
小结：
JDK = JRE + 开发工具集（例如Javac编译工具等）
JRE = JVM + Java SE标准类库
二、JDK版本的选择 自java8版本之后，每三个版本就是一个长期支持版(即会长期更新支持用户)，目前有统计数据显示java8和java11市场占比相同，但是java之父喊话“java17的各种能力都有很大提升，希望我们使用java17。也就是java17的的占比会越来越高”。
由于版本迭代向下兼容，所以目前的学习最好将java8和java17都安装一下。
三、JDK的下载 官网：www.oracle.com，如图所示，在官网底部选择Developers开发者在Developers页面中间的技术分类部分，选择Java，单击进入，如图所示：这里展示的是最新Java版本，例如Java17。单击Download Java，然后选择具体的版本下载。选择Download Java按钮后，界面如下如果想安装Java8 可以选择如下位置：选择Accept License Agreement需要注册或登录后下载如果需要安装其它版本，可以选择Java archive接着进行选择下载即可： 四、JDK的安装 安装说明 傻瓜式安装，下一步即可。建议：安装路径不要有中文或者空格等特殊符号。本套课程会同时安装JDK8 和 JDK17，并以JDK17为默认版本进行讲解。 安装步骤 1.双击jdk-8u271-windows-x64_bin.exe文件，并单击下一步，如图所示：
2.修改安装路径，单击更改，如图所示：
3.将安装路径修改为D:\develop_tools\jdk\jdk-1.8.0_271\，并单击下一步，如图所示：
4.稍后几秒，安装完成，如图所示：(如果有新窗口跳出请往下看)
当有窗口跳出提醒你安装JRE的时候，可安装可不安装，因为JDK中包含JRE。我们示例一下安装。如下：
1.先新建目录
2.更改安装目录至新建目录，稍等片刻即可安装成功。
五、JDK目录结构功能 六、配置PATH环境变量 path环境变量是windows操作系统在执行命令时要搜寻的路径。我们想在命令行使用javac.exe等工具时，就要使用cd命令进入该工具所在目录，如果想当前工作目录为任意目录时均能找到javac.exe这个工具，就需要配置环境变量。
如图：
（以下步骤windows8和windows10界面不同，请仔细查找）
步骤一：右键点击此电脑，选择属性
步骤二：选择高级系统设置，如图所示
步骤三： 在高级选项卡，单击环境变量，如图所示
步骤四：在系统变量中，单击新建 ，创建新的环境变量，如图所示：
步骤五：变量名输入JAVA_HOME，变量值输入 D:\develop_tools\jdk\jdk1.8.0_271 ，单击确定，如图所示（需要注意的是，变量名一定是JAVA_HOME，变量值为你安装的JDK的根目录）
步骤六： 选中Path 环境变量，双击或者点击编辑 ，如图所示：
步骤七：在变量值的最前面，键入%JAVA_HOME%\bin。如图所示：
注意：位置其实无所谓，但强烈建议将%JAVA_HOME%\bin声明在path环境变量中所有变量的最前面！ 因为系统检索PATH变量时，从上到下检索。
步骤八：环境变量配置完成，重启DOS命令行，在任意目录下输入javac 或java命令或java -version，运行成功。
注意： 有的书籍、论坛、视频上还提到配置classpath，用于指名class文件识别的路径。其实是没必要的，反而建议大家如果配置了classpath环境变量，要删除。对于初学者，反而不友好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d7b10b3348055c7be4b83a474ac0621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdf9c71edcee76d7c79dd208f57fc0d/" rel="bookmark">
			人工智能--循环神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：欢迎来到 Papicatch的博客
课设专栏 ：学生成绩管理系统
专业知识专栏： 专业知识 文章目录
🍉引言
🍉概述
🍈基本概念
🍍定义
🍍结构 🍌输入层
🍌隐藏层
🍌输出层
🍌扩展结构
🍈工作原理
🍍基本流程
🍍隐藏状态的计算
🍍输出的生成
🍍处理长序列时的挑战
🍍解决长期依赖问题的改进
🍈优势与局限
🍍优势
🍍局限
🍈面临的挑战
🍍长期依赖问题
🍍梯度消失和梯度爆炸
🍍计算效率低下
🍍内存占用 🍍过拟合风险
🍈改进与变体
🍍长短期记忆网络（Long Short-Term Memory，LSTM）
🍍门控循环单元（Gate Recurrent Unit，GRU）
🍍双向循环神经网络（Bidirectional RNN）
🍍深度循环神经网络（Deep RNN）
🍈应用领域
🍍自然语言处理（NLP）
🍍语音处理
🍍金融预测
🍍 医学
🍍工业控制
🍍视频处理
🍍交通预测
🍉理论基础
🍈神经网络理论
🍈 信息处理理论
🍈动态系统理论
🍈概率论与统计学
🍈优化理论
🍉长短期记忆网络
🍈结构与原理
🍈优势
🍈应用
🍉示例（股票预测）
🍈方法解析
🍍数据准备
🍍特征工程
🍍RNN 模型构建
🍍训练模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bdf9c71edcee76d7c79dd208f57fc0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d40f1bfac882633b3d56052312598a/" rel="bookmark">
			周周星分享7.3—基于气象大数据的自动站实况联合预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		赛题 2024中国高校计算机大赛 — 大数据挑战赛
经验分享 大家好，我是扫地僧团队的队长，以前参加这样打榜的比赛比较少，了解的打榜技巧不是太多，所以想从科研的角度给大家一点分享。
这次比赛主要从以下五个步骤进行：数据集构造👉Baseline选择👉模型优化👉模型调参👉模型集成
1. 数据集构造 官方已经给了数据集，可以尝试根据温度筛选出与中国温度类似的场站，但是不确定是否会有效果：
import numpy as np import pandas as pd import os import matplotlib.pyplot as plt root_path = '../dataset/global' data_path = 'temp.npy' data = np.load(os.path.join(root_path, data_path)) data_oneyear = data[:365*24,:,0] df = pd.DataFrame(data_oneyear) # 夏天平均温度大于15摄氏度 summer_df = df.iloc[4000:5500] print(summer_df.shape) summer_index = summer_df.mean(axis=0).apply(lambda x: x &gt; 15) summer_index = summer_index[summer_index].index.to_list() print(len(summer_index)) # 冬天平均温度小于20摄氏度 winter_df = df.iloc[0:500] print(winter_df.shape) winter_index = winter_df.mean(axis=0).apply(lambda x: x &lt; 20) winter_index = winter_index[winter_index].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d40f1bfac882633b3d56052312598a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12be63121323d444dc7042b842672fc/" rel="bookmark">
			计算机网络——数据链路层（点对点协议PPP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点对点协议PPP的概述 对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。
它主要应用于两个场景：
用户计算机与ISP之间的链路层协议就是点对点协议 PPP，1999年公布了回以在以太网上运行的PPP协议，即PPPOE。
PPPOE：它可以使数字用户线路，电路调制解调器以及以太网等宽带接入技术，利用以太网接口的形式，为用户提供服务。
他还广泛用于广域网路由器之间的专用线路
点对点协议PPP的要求 • 简单：这是首要的要求（最复杂的功能TCP实现， IP也简单且不可可靠），因此数据链路层的PPP没有必要比 IP复杂；
PPP的简单： 每收到一个帧，进行CRC检验，如果CRC检验正确， 就收下这个帧，反之，就丢弃这个帧，其他什么也不做。
• 封装成帧：必须规定特殊的字符作为帧定界符；
• 透明性：必须保证数据传输的透明性；
• 多种网络层协议：支持多种网络层协议（IP/IPX）；
• 多种类型链路：能够在多种类型的链路上运行；
串行的、并行的；同步链路、异步链路；低速链路、高速链路；交换的（动态的）、非交换的（静态的）；电的、光的；PPPoE （ PPP over Ethernet） • 差错检测：对收到的帧进行检测，并丢弃有差错的帧
• 检测连接状态：能够及时自动检测出链路是否处于正常工作状态。
• 最大传送单元：必须对每一种类型的点对点链路设置最大传送单元MTU 的标准默认值，促进各种实现之间的互操作性。
需要强调的是，MTU是数据链路层的帧可以载荷的数据部分的最大长度，而不是帧的总长度
• 网络层地址协商： 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。
• 数据压缩协商：必须提供一种方法来协商使用数据压缩算法
在 TCP/IP协议族中，可靠传输由运输层的TCP协议负责，因此数据链路层的PPP协议不需要进行纠错，不需要设置序号，也不需要进行流量控制。
PPP协议不支持多点线路(即一个主站轮流和链路上的多个从站进行通信)，而只支持点对点的链路通信。此外，PPP协议只支持全双工链路。
ppp协议的组成 PPP协议有三个组成部分:
1. 一个将IP数据报封装到串行链路的方法：PPP既支持异步链路（无奇偶检验的8比特数据)，也支持面向比特的同步链路。IP 数据报在PPP帧中就是其信息部分。这个信息部分的长度受最大传送单元MTU的限制。 2.链路控制协议 LCP(Link ControlProtocol)：用来建立、配置和测试数据链路连接，通信的双方可协商一些选项。
3.网络控制协议NCP (Network Control Protocol)：其中的每一个协议支持不同的网络层协议，如IP、OSl的网络层、DECnet和 AppleTalk等。
ppp的帧格式 由上图所示，你可以看到协议不同，其帧的数据载荷所表达类型也有所不同。 PPP帧的透明传输——面向字节的异步链路 数据帧中出现帧定界
数据帧中出现转义字符
数据帧中出现ASCLL码控制字符
接收方的处理就完全与发送方相反即可： PPP帧的透明传输——面向比特的同步链路
PPP帧的差错检测 PPP的工作状态 LCP如何配置协调：LCP开始协商一些配置选项，即发送LCP的配置请求帧。这是个PPP帧，其协议字段置为LCP对应的代码，而信息字段包含特定的配置请求。链路的另端可以发送以下几种响应中的一种: (1)配置确认帧(Configure-Ack):所有选项都接受。 (2)配置否认帧(Configure-Nak):所有选项都理解但不能接受。 (3)配置拒绝帧(Configure-Reject):选项有的无法识别或不能接受，需要协商。 LCP配置选项包括链路上的最大帧长、所使用的鉴别协议的规约（如果有的话)，以及不使用PPP帧中的地址和控制字段（因为这两个字段的值是固定的,没有任何信息量，可以在 PPP帧的首部中省略这两个字节)。 鉴别状态：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a12be63121323d444dc7042b842672fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0971fe9d8b23e33d4185eba0761cea/" rel="bookmark">
			springboot 整合 mybatis-plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 1. mybatis-plus是什么
mybatis-plus是一个对mybati框架的拓展框架，它在mybatis框架基础上做了许多的增强，帮助我们快速的进行代码开发。目前企业开发中，使用mybati的项目基本会选择使用mybatis-plus来提升开发效率。
2.官网地址：MyBatis-Plus 🚀 为简化开发而生
二.项目集成 1. 项目中集成(示例用的springboot2.x+mysql)
step1.引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; step2.配置数据源
spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.**.**:3306/rui username: root password: ****** step3.启动类添加注解 @MapperScan 指向mapper接口所在包
@SpringBootApplication @MapperScan("com.rui.mapper") @EnableFeignClients(defaultConfiguration = MyFeignConfiguration.class) public class AdminServerApplication { public static void main(String[] args) { SpringApplication.run(AdminServerApplication.class, args); } } step4.定义实体类
step5.编码测试：
（编码测试演示比较接近实际开发的代码，如果只是简单验证，用baseMapper就行了）
以下代码均为mybatis-plus提供的代码生成器生成的，如何使用在后续段落会讲，这里先看一下代码样子，眼熟以下
代码结构：
controller层：
@Slf4j @RestController @RequestMapping("/configInfo") public class ConfigInfoController { @Autowired private IConfigInfoService configInfoService; @GetMapping("/list") public List&lt;ConfigInfo&gt; listConfigs () { return configInfoService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f0971fe9d8b23e33d4185eba0761cea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06dc10ea1332a1ea1a59f3f40e78e56/" rel="bookmark">
			优先级队列（堆）学的好，头发掉的少(Java版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
我们深知，在这个多元化的时代，每个人的兴趣与偏好都独一无二。
因此，我们精心挑选了各类题材，从深邃的宇宙奥秘到细腻的日常生活琐事，从古老的文明遗迹到未来的科技幻想，力求满足每一位读者的好奇心与求知欲。
我们相信，每一个有趣的灵魂都能在这里找到属于自己的那片天空，与作者进行跨越时空的对话，享受阅读带来的纯粹快乐。
前言 提及优先级队列，就会 回忆起我们之前学习过的队列
并且我们提及过 队列 ，队列是一种 先入先出 的数据结构， 但是不能考虑数据本身优先级的高低，那该怎么办呢？
在上篇文章中我们主要讲解了传说中 地狱级别难 其实 也没有那么难 的的二叉树， 而在本篇中也是讲解和二叉树相同的 树状的结构 的 优先级队列，我们也称之为 堆 的一种 数据结构 。
提及难度的话，小伙伴这点可以放心， 当然是不及 二叉树 的 💖 💖 💖 💖
关于 堆 的定义和特性，如何创建 堆 并通过调整维护好这个 堆 的各种方法，小编都会在本篇文章中重点讲解。
目录 堆的初识
堆的调整
堆的数据插入和删除
堆实现优先级队列
一. 堆的初识 是否有以一种 数据结构 是可以考虑优先级的，就是说当我们需要对某个数据或某个事务进行考虑，就可以做到优先执行
比如当小伙伴打游戏时，把优先级设置为最大的，如果有电话过来，就会优先选择电话接听的提示
、
比如小伙伴正在上课， 不想有消息发过来，就会把消息通知设置为优先级最小的， 这样即使有消息发送过来，也不会受到提示消息。
那么就是它了 ， 我们的 优先级队列（堆） 就可以在我们的根节点表示优先级最大或最小的，就可以进行优先级最大或最小的数据的管理。
1. 堆的简介 &lt;1&gt;. 概念 像上面这种能够有 优先级特性 的，并且 返回 优先级对象 ，并且能够 插入新对象 的我们称之为 优先级队列（堆） 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b06dc10ea1332a1ea1a59f3f40e78e56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4640b96507ce17e66192db50853ddae/" rel="bookmark">
			Python爬取国家医保平台公开数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 国家医保服务平台数据爬取python爬虫数据爬取医疗公开数据 定点医疗机构查询定点零售药店查询医保机构查询药品分类与代码查询 等等，数据都能爬
接口地址：/ebus/fuwu/api/nthl/api/CommQuery/queryFixedHospital
签名参数：signData
{'data': {'appCode': 'T98HPCGN5ZVVQBS8LZQNOAEXVI9GYHKQ', 'data': {'encData': '3DFBCA4667B978F639BB23B95DCE4CC71A278C9F2533C757FF5C03CBCC34E3D4372E092B58986D599C85DA9915C624D2FBFD0D98566B145EADF0C9106ECE55D6BEAC91552AB64588918CC021A62262DE4C6A559867CD3AE9A5DF64A17BAA6A90C3FE3802BC6FCFE8B95970F44559B7DFE1BBE20CAA2D10345141125E12E158A15E58FF8C94DF27497848B3EA62F053188D3B5EDF3BF0FDC04F771CA76552C7D7D7E571CFE97F232CF816A37F7E1DEB89'}, 'encType': 'SM4', 'signData': 'I89tOk4GVN0QBDCoxsYnaC66WfPmSpLybhYk3XIZ+d34V1JUXuOvDNAaHLfjACSY+WEh372C1CDNeFyU9VYOaQ==', 'signType': 'SM2', 'timestamp': 1720010645100, 'version': '1.0.0'}} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974e47307e0c20d83cd64a0847def090/" rel="bookmark">
			golang写的自动更新器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件自动更新器，这个很多端游和软件都有用到的。
golang的rpc通信，是非常好用的一个东西，可以跟调用本地函数一样，调用远程服务端的函数，直接从远程服务端上拉取数据下来，简单便捷。
唯一的遗憾就是，不能实时显示当前文件的下载百分比。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b71e5442f4d369d3ab4da3c8fef137/" rel="bookmark">
			不是大厂云用不起，而是五洛云更有性价比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明月代维的一个客户的大厂云境外云服务器再有几天就到期了，续费提醒那是提前一周准时到来，但是看到客户发来的续费价格截图，我是真的没忍住。这不就是在杀熟吗？就这配置续费竟然如此昂贵？说实话这个客户的服务器代维是很有些麻烦的，IP 都已经免费更换三次了，因为被攻击黑洞封禁过 24 小时，远程 SSH 链接自动断线让我是受尽了折磨。
反正，我是忍不了了，果断跟客户建议更换云服务器，因为本来就是境外云服务器也不用考虑备案迁移的影响，就让客户去【五洛云】里看看有没有合适的，没想到随便选个配置性价比都完虐大厂云，那配置让我看了都惊叹，这要用上了那不鸟枪换炮了都！
大厂云这可怜兮兮的配置，都要 1000 多，也是没谁了
【五洛云】这直接翻了 N 倍的配置和几乎腰斩的价格，不香吗？
客户几乎没考虑直接就下单拿下了，明月第一时间远程 SSH 登录进行部署体验，搭建一个 LNMP 环境（Debian Linux 12+Nginx 1.27.0+PHP 8.3+MariaDB 10.4）下来（全是源码编译安装）耗时 72 分钟就完成了，再借助 rsync 直接镜像复制客户 N 个网站到新服务器来，虽然慢了一点，但好在是安全的丝滑迁移，对于前端来说没有丝毫影响，镜像复制完成后直接修改 CloudFlare 里 DNS 回源 IP 为新服务器 IP 就可以了。
系统盘+数据盘又让我直接部署 LNMP 的时候做好数据分割，以后重置系统更加方便了。唯一的瑕疵就是受限于大厂云 1M 带宽的限制，迁移网站数据耗时有点儿长，好在是 IP 对 IP 间的镜像复制，无人值守式自动完成的。
这次选择【五洛云】客户满意、访客满意、运维满意，绝对完美，不是大厂云用不起，而是五洛云更有性价比！现在，明月代维的跨境电商客户几乎都已经转到【五洛云】了，还有几个因为购买时限过长，还在其他云上苦苦坚守着，明月也是只能深表遗憾了，还得跟他们一起遭受着、痛苦着、郁闷着。这年月购买云服务器，尤其是商业化需求的，切记不要因为贪便宜被套路了，一次买三年、五年的，那都是妥妥的智商税了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28dbf545e0902e200c11835de39c6301/" rel="bookmark">
			被裁了(9年)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		那年（2015年）我刚毕业有一年多（20出头），阴差阳错来到了现在的单位。
那时互联网腾起，单位也迅速发展，部门从起初的不到30号人发展到500人；A轮、B轮.....D轮，一轮轮的融资，业务发展越来越广。也有了要上市的风声了（2018年）。作为员工的我干的也热火朝天。
天天只顾干活的我，不清楚是怎么回事，18年底有同事陆陆续续的离职，而且都是资历还可以的。19年初，做了大批裁员，而我却做了一次大幅提薪（好开心啊）。裁过之后又有一大波资历很不错的同事走了。
19年底，公司出事了。加上20年初，疫情四起，公司又做了大量裁员，那波裁员是很凄惨的，没有什么补偿。我又顺利的留下了（幸运的我）。望眼看去，我那起初的战友，都不在了。
20年公司渐渐存活下来了，发展的还不错。21年又过了平稳的一年。22年底，又开始裁员了。我默默的又留了下来。23年底是血腥的，裁了一大批，几乎对半砍的，前端那是一半以上。24年初，三波了。这第3波，我收到了大礼包，9年。
我的一段9年的职业生涯就这样结束了。
其实是一件好事，因为这个年纪也不是很大（32岁），但是市场行情已经发生了翻天覆地的变化（找工作没有那么容易）。而我之前那些早早离开的同事，都已经在阿里系、恒生等不错的大单位里。而我早早的，可能要失业了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05981e117394e92b914a6c731627b5c7/" rel="bookmark">
			Android集成Unity的两种方案实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android平台常见动效 现在市面上的形形色色Android客户端，为了更优的用户体验，我们开发的上游产品和交互往往会在界面里设计很多动效。传统的一页页的静态展示页面已经不足以满足用户的审美需求了。
而动效的分类也是花样百出的，以播放时机来说有点击触发，打开页面触发，还有可跟随手指的交互持续触发的等等。有时候一些和数据耦合性较大的动效甚至需要我们自己来手写复杂的自定义View，比如曲线图、图表类型。
而我日常碰到的大部分的动效需求，还是依赖UI设计的同时来制作提供的，像那些短时间单次的展示类动效，往往实现方式比较随意，对资源的格式要求也不太严苛。一般有以下几种方案:
帧动画 在Android中，帧动画是通过Drawable动画实现的。你可以创建一个AnimationDrawable对象，然后在XML中定义一系列的帧（frames），每帧可以是一个Drawable资源。然后在代码中启动这个动画。
以下是两个简单的例子：
1. 在res/drawable目录下创建一个名为frame_animation.xml的文件，并定义动画的帧：
&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/frame1" android:duration="100" /&gt; &lt;item android:drawable="@drawable/frame2" android:duration="100" /&gt; &lt;item android:drawable="@drawable/frame3" android:duration="100" /&gt; &lt;!-- 更多帧 --&gt; &lt;/animation-list&gt; 这里android:oneshot="false"表示动画会循环播放，如果设置为true则播放一次。android:duration表示每帧显示的时间。
2. 在你的布局文件中（例如activity_main.xml），添加一个ImageView来展示动画：
&lt;ImageView android:id="@+id/imageView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/frame_animation" /&gt; 然后在调用处启动动画：
ImageView imageView = (ImageView) findViewById(R.id.imageView); // 获取AnimationDrawable final AnimationDrawable frameAnimation = (AnimationDrawable) imageView.getDrawable(); // 在UI线程之外启动动画 imageView.post(new Runnable() { @Override public void run() { frameAnimation.start(); } }); 注意确保你的每个Drawable资源的尺寸是一致的，以便在动画过程中保持帧的正确显示。这样就创建了一个简单的帧动画，当Activity加载时，动画会自动开始循环播放。
PAG动画 pag相较于上面的帧动画对性能更加友好。PAG是腾讯公司自主研发的一套完整动画工作流解决方案。 PAG诞生于2016年，最初的原因是为了解决更为复杂的视频编辑场景下动画渲染问题，同时又覆盖了UI动画和直播场景，于2022年1月在Github开源。
其使用方法可以说相当简单，只需要先从github主页确定版本，到gradle里引入依赖，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05981e117394e92b914a6c731627b5c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef5a24099ef97367b76c23b4798f2ec4/" rel="bookmark">
			AIGC对设计行业的影响与启发：AIGC设计能替代真正的设计师吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的飞速发展，人工智能生成内容（AIGC）技术在设计行业的应用日益广泛，引发了广泛的讨论和关注。AIGC以其高效、多样化的生成能力，为设计行业带来了前所未有的变革。然而，关于AIGC是否能替代真正的设计师，这一话题至今仍存争议。本文将从多个维度，深入探讨这一话题。
AIGC对设计行业的影响 AIGC技术的出现，无疑为设计行业带来了深远的影响。它极大地提高了设计效率。传统的设计过程中，设计师需要花费大量时间在绘图、修改和完善设计方案上，而AIGC技术则能够迅速生成多种设计方案，通过算法的优化和迭代，帮助设计师快速找到最佳设计方向。这种高效的设计方式不仅节省了时间成本，还使得设计师能够更专注于创意的构思和实现。
AIGC技术拓宽了设计的边界。传统的设计思维往往受限于设计师个人的经验和想象力，而AIGC技术则通过机器学习和大数据分析，为设计师提供了全新的灵感来源。设计师可以与AIGC进行互动，探索不同的设计元素和风格组合，从而创造出独特而富有创意的设计作品。这种人机协作的设计模式，不仅激发了设计师的创造力，还推动了设计行业的创新发展。
AIGC技术还改善了设计呈现的效果。借助先进的图像处理和渲染技术，AIGC能够生成逼真的设计效果图，帮助客户更直观地理解设计方案。这种高质量的呈现方式不仅提升了客户的满意度，还加强了设计师与客户之间的沟通效果。设计师可以利用AIGC生成的设计效果图与客户进行更深入的讨论和反馈，从而达成更好的设计共识。
AIGC设计能替代真正的设计师吗 尽管AIGC技术在设计领域展现出了强大的潜力，但要完全替代真正的设计师，目前看来还存在诸多挑战。
设计师的创造力和审美能力是AIGC难以企及的。设计师具备独特的审美视角和创意灵感，能够根据文化背景、情感需求、产品特性和用户需求，创作出具有深刻内涵和高度个性化的设计作品。而AIGC虽然能够快速生成大量设计内容，但其生成结果往往缺乏真正的独创性和创造力。AIGC生成的作品更多是基于已有数据和算法的模拟，难以真正替代设计师的创意灵感和审美判断。
设计师的情感共鸣和业务理解能力也是AIGC所缺乏的。设计师能够深入理解用户需求，通过设计作品与用户产生情感共鸣。同时，设计师还具备丰富的业务知识和市场洞察力，能够根据业务目标设计出符合市场需求的作品。而AIGC虽然可以模拟一些设计元素和风格，但难以真正理解用户的情感需求和业务背景，因此其生成的设计作品往往缺乏针对性和实用性。
再者，版权和道德伦理问题也是AIGC替代设计师的障碍之一。目前，关于AIGC生成作品的版权归属和道德伦理规范尚存争议。由于AIGC是通过学习已有数据生成内容，其生成结果可能涉及版权侵权问题。此外，AIGC的滥用还可能引发道德和伦理风险，如制造虚假信息、侵犯隐私等。这些问题都需要得到妥善解决，才能确保AIGC在设计领域的健康应用。
因此，尽管AIGC技术在设计领域展现出了强大的潜力，但它并不能完全替代真正的设计师。相反，AIGC更应该被视为设计师的辅助工具，帮助设计师提高工作效率和创作质量。设计师可以通过学习和掌握AIGC技术，将其融入自己的设计流程中，从而创作出更加优秀的设计作品。
此外，值得一提的是：在探讨AIGC（人工智能生成内容）技术对设计行业带来的变革时，Adobe国际认证作为行业内的权威标杆，其重要性也不容忽视。它不仅在AIGC与设计行业的深度融合中扮演了桥梁角色，还为设计师的专业成长与行业发展铺设了坚实的基石。
①AIGC技术的启航点
Adobe国际认证，这一业界公认的权威认证体系，正逐步成为设计师掌握AIGC技术的理想起点。通过精心设计的培训课程，设计师能够系统地深入AIGC技术的核心，从理论知识的构建到实践应用的掌握，每一个环节都力求精准高效。这种全面而专业的培训模式，不仅迅速提升了设计师的技术水平，更赋予了他们利用AIGC技术进行创新设计的自信与能力。设计师获得Adobe国际认证证书，不仅是对其专业能力的官方认可，更是其在设计领域脱颖而出的有力证明。
②标准化与规范化的推动者
随着AIGC技术的广泛应用，设计行业面临着前所未有的标准化与规范化挑战。Adobe国际认证以其深厚的行业积淀和前瞻性的视野，积极承担起制定和完善相关标准的重任。通过明确的技术规范和操作指南，Adobe国际认证为设计行业树立了清晰的标杆，确保了AIGC技术在设计领域的健康、有序发展。这一举措不仅有效避免了技术的滥用和侵权问题，更为设计师提供了一个公平、透明的竞争环境，促进了整个行业的繁荣与进步。
③职业发展的加速器
对于设计师而言，Adobe国际认证无疑是他们职业道路上的重要加速器。拥有这一认证的设计师，在求职市场上无疑更具竞争力。他们不仅具备扎实的设计功底，还掌握了前沿的AIGC技术，这使得他们在面对复杂多变的设计需求时能够游刃有余。此外，Adobe国际认证还为设计师的职业晋升开辟了更广阔的道路。随着技术的不断升级和行业的持续发展，掌握AIGC技术的设计师将拥有更多的发展机会和空间，成为推动设计行业前行的中坚力量。
总体而言，AIGC技术与设计行业的融合已是大势所趋。尽管AIGC在提高效率、拓展创意方面展现出巨大潜力，但它无法替代设计师独特的审美眼光、情感共鸣和深度思考。相反，AIGC更应被视为设计师手中的一把利剑，助力他们在设计领域开辟新的天地。而Adobe国际认证则在这一过程中发挥着不可或缺的作用，为设计师提供了学习成长的平台、行业规范的引导以及职业发展的助力。随着技术的不断进步和应用的深入探索，我们有理由相信AIGC与设计行业将在共生共荣的道路上携手前行，共同创造更加辉煌的未来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9818044cfc52c4c68bdd6d2319c0a3/" rel="bookmark">
			【计算机网络——1.2网络边缘】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络边缘其实就是端系统/主机，上面运行着分布式系统，那么这些运行的网络应用就是网络存在的理由，应用由端系统的基础设施（操作系统，硬件，实体协议，网络核心，包括对方主机的应用层下面的基础设施）支撑。网络核心就是一些交换节点，交换节点间的通信链路，连接各个端系统（自然的也就有几个交换机和路由器构成的网络的网络），可以让几个主机通信。接入网就是把我们的主机连接到网络核心，从而和其他主机通信；形式可以有线和无线。
客户端和服务器只是一种抽象，本质上是请求方和资源方进行互通；
客户端/服务器模式：
要先服务器启动，然后响应客户端的需求，比如订单信息，web服务器打开对应网页；（主从模式）；这个模式中服务器是服务器，客户端就是客户端
但是会存在一个问题：客户端数量太多，请求就会很多，服务器顾不过来，于是就是有“服务器农村”，也就是增加服务器数量；可靠性差，可能宕机。
P2P对等体模式：
每个主机即使服务器也是客户端（会话角度不同），地位平等；需求方很多，同时资源方也很多，分布式通信。
面向连接通信方式（TCP）：
两个端系统进行互通前，先“握手”，双方都准备好，配置缓冲区，控制变量归位，然后通信。
和"有连接还是有差别的（网络也知道）"，双方端系统都知道按照TCP通信，但是网络核心不知道；通信状态只是在端系统之间维护。
TCP特性：
可靠性：保证信息传输正确，保序。
流量控制：TCP会自我调整，比如发送方设备先进，速度快，接受方慢，TCP就会控制发送方速率，实现基本平衡。
流量阻塞控制：比如A和B互通，会走某条线路，C和D也会经过这条路，或者这条路的一部分，就很有可能阻塞，当信息量太大时，交换节点就会丢东西，信息就不完整，TCP检测线路阻塞情况，从而限值发送速率。
无连接通信方式（UDP）：
不需要握手，直接发送，直接回应，不可靠（TCP的特性一个不占），但是效率高，应用一些不需要数据太准确方面(视频，语音)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d289d6d4a49c4c09eedf9640142db963/" rel="bookmark">
			深入Java腹地：序列化与反序列化的奥秘探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java的广阔天地中，序列化与反序列化机制如同桥梁，连接着程序运行时的对象状态与持久化存储或网络传输之间的鸿沟。它们不仅是Java对象持久化、网络通信以及远程方法调用（RMI）等关键技术的基础，也是理解Java语言深层次特性的重要窗口。本文将带您一探Java序列化与反序列化的究竟，揭开其神秘面纱。
序列化：对象的数字之旅 想象一下，您精心设计的Java对象，包含了复杂的属性结构和业务逻辑，它们如何在不运行Java虚拟机（JVM）的环境下被保存、传输或恢复？这就是序列化的用武之地。序列化，简而言之，就是将Java对象的状态信息转换为可以存储或传输的形式的过程，通常是一个字节序列。这个过程保留了对象的类型信息和数据，使得在需要时能够完全重建对象。
在Java中，实现序列化的关键是让类实现java.io.Serializable接口。这个接口是一个标记接口，不包含任何方法，它的作用仅仅是告知JVM这个类的对象可以被序列化。当对象被序列化时，JVM会遍历对象的所有属性（包括通过继承得到的属性），并将它们的状态信息转换为字节序列。对于非瞬态（transient）和静态（static）字段，它们默认不会被序列化，因为它们要么是与特定对象实例无关的全局数据，要么是被明确标记为不需要序列化的。
反序列化：从数字回归对象 如果说序列化是将对象转化为字节序列的“编码”过程，那么反序列化就是这一过程的逆操作——“解码”。反序列化将存储在文件、数据库或通过网络接收到的字节序列重新构造回Java对象。这一过程同样依赖于Serializable接口，以及对象类定义中的信息，以确保重建的对象与原始对象在结构和数据上保持一致。
在反序列化过程中，JVM会根据字节序列中的类型信息和数据，动态地创建对象，并为其属性赋值。需要注意的是，反序列化时创建的对象并不是原有对象的简单复制，而是一个全新的对象实例，它们拥有相同的属性值和类型，但在JVM中的内存地址是不同的。
序列化的应用与挑战 序列化机制在Java中扮演着举足轻重的角色，广泛应用于对象持久化、网络通信、远程对象传输等多个领域。然而，它并非没有缺陷。首先，序列化过程可能涉及性能开销，特别是对于大型对象或复杂对象图；其次，安全性问题也不容忽视，恶意构造的序列化数据可能导致代码执行漏洞（如反序列化漏洞），对系统安全构成威胁；最后，随着Java版本的更新，序列化格式也可能发生变化，导致不同版本间的兼容性问题。
结语 Java的序列化与反序列化机制，作为连接对象世界与字节世界的桥梁，不仅为Java程序提供了强大的数据持久化和网络通信能力，也让我们见证了Java语言在面向对象设计上的深刻思考。然而，正如任何强大的工具一样，它们的使用也需要谨慎和智慧。通过深入理解其原理、应用场景及潜在风险，我们可以更好地利用这一机制，为Java应用程序的构建和运行保驾护航。在Java的广阔天地间，序列化与反序列化的奥秘等待着每一位开发者去探索与发现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807937e5a98add84680f4675bb8dc011/" rel="bookmark">
			数据库完整性约束：确保数据准确性的关键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🎗一、实体完整性
示例：定义主键
🎊二、参照完整性
示例：定义外键
🎀三、域完整性
示例：定义非空和唯一约束
🎁四、用户定义的完整性
示例：定义自定义约束
🎟五、级联更新和级联删除
示例：定义级联更新和级联删除
六、总结
七、注意事项
在数据库管理中，数据的准确性和可靠性至关重要。数据库完整性约束是一组规则，用于强制执行数据的准确性和可靠性。本文将详细介绍数据库中的四种主要完整性约束：实体完整性、参照完整性、域完整性和用户定义的完整性。
🎗一、实体完整性 实体完整性确保表中的每行都是唯一的，通常通过主键来实现。
示例：定义主键 CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, FirstName VARCHAR(50), LastName VARCHAR(50), BirthDate DATE ); 🎊二、参照完整性 参照完整性确保一个表中的外键与另一个表中的主键相关联，从而维护数据之间的关系。
示例：定义外键 CREATE TABLE Orders ( OrderID INT PRIMARY KEY, OrderDate DATE, EmployeeID INT, FOREIGN KEY (EmployeeID) REFERENCES Employees(EmployeeID) ); 🎀三、域完整性 域完整性确保列中的值满足特定的约束条件，如非空（NOT NULL）、唯一（UNIQUE）或检查（CHECK）。
示例：定义非空和唯一约束 CREATE TABLE Products ( ProductID INT PRIMARY KEY, ProductName VARCHAR(100) NOT NULL UNIQUE, Price DECIMAL(10, 2) CHECK (Price &gt; 0) ); 🎁四、用户定义的完整性 用户定义的完整性是针对特定应用需求的约束，可以包括各种业务规则。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/807937e5a98add84680f4675bb8dc011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e610512bbd51f92b163e018eacc28d/" rel="bookmark">
			BLACKBOX.AI：解锁编程学习新纪元，加速开发的AI得力助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 💯BLACKBOX.AI 官网🍁1 BLACKBOX.AI 工具使用教程🍁2 BLACKBOX.AI工具使用界面介绍🍁3 Chat(聊天)功能🍁4 Explore (探索)功能💎4.1 Terminal(终端)功能💎4.2 Discover(发现)功能💎4.3 AI Code Docs (AI代码文档)功能💎4.5 AI Model Page (AI模型页面) 🍁5 Create Agent(创建代理)功能🍁6 Playground(广场)功能💎6.1 选择对应的编程语言💎6.2 Comment(评论)功能💎6.3 Explain(解释)功能💎6.3 Find Bugs (查找错误)功能💎6.4 Run(运行)功能 🍁7 Code Translation Agent(代码翻译代理)功能🍁8 Code Comment Agent(代码注释代理)功能🍁9 Android App (安卓应用程序)功能🍁10 Multiplayer Editor (多人编辑)功能🍁11 View History(查看历史记录)功能🍁12 BLACKBOX.AI插件(兼容VSCode)介绍 💯推荐配合使用的浏览器在线翻译插件💯个人使用体验总结 💯BLACKBOX.AI 官网 BLACKBOX.AI 官网(附使用手册)：由此进→https://www.blackbox.ai/
BLACKBOX.AI是一款专为开发者和IT学习者设计的AI平台，旨在助力编码任务的高效完成和学习过程的加速。它提供了一系列强大的功能，包括代码生成、代码补全以及实时编码支持，这些功能对于加速开发过程和学习新编程语言极具价值。BLACKBOX.AI现已支持20多种编程语言，如Python、JavaScript、TypeScript、Go、Ruby等，通过提供智能的代码建议和解答编码问题，极大地提升了开发效率和学习的便利性，使IT学习者能够更加轻松地掌握编程技能。
BLACKBOX.AI的主要功能包括：
代码聊天：通过智能对话模式，帮助开发者解决编码问题、修复错误、开发新功能和重构代码，提供即时的编码支持和建议。实时知识：平台能够回答关于最近事件、技术突破等问题，并显示信息来源，帮助开发者保持对行业动态和技术发展的敏锐洞察。视觉功能：允许分析图像输入，如代码截图或产品草图，为开发者提供便捷的可视化辅助，提升代码理解和设计效率。GitHub 集成：平台支持直接与GitHub仓库集成，允许开发者在仓库上执行任务，如从错误报告生成问题或对代码进行评论，实现更加高效的工作流程。 🍁1 BLACKBOX.AI 工具使用教程 相信通过阅读BLACKBOX.AI 官网的使用手册后，你一定对BLACKBOX.AI功能有一定了解啦，接下来让我以一个使用者的角度来具体介绍一下。
🍁2 BLACKBOX.AI工具使用界面介绍 BLACKBOX.AI工具进入方式:
由此进入：BLACKBOX.AI工具使用网站:https://www.blackbox.ai/
这里我们可以看到BLACKBOX.AI工具的使用界面是纯英文的，当前暂不支持切换中文，对于英文看的有些吃力的uu可以安装合适的浏览器翻译插件(最后我会在下面介绍我使用的翻译插件，先介绍AI工具功能)，接下来的介绍我会围绕官方使用手册进行展开，并且搭配翻译插件方便uu们观看。 打开翻译插件后，内容瞬间变得清晰易理解啦，BLACKBOX.AI官方这边推荐使用谷歌浏览器，在使用前我们最好进行一下登录操作，方便存储我们的历史记录，同时BLACKBOX.AI工具也提供了与VScode编译器兼容的AI插件，可以搭配使用提高我们的编程开发效率。左边是其功能区，我这里就不先一一列举啦，下面会逐个进行详细介绍！
还有值得一提的是BLACKBOX.AI在左下角提供了白天/夜间切换模式,用户可以根据需要进行设置，这点考虑到了用户使用体验，确实很不错！
接下来，我们就可以开始探索BLACKBOX.AI工具的丰富功能啦。从基础的操作界面到高级的分析功能，我都会一一介绍，确保你能够充分利用这个强大的工具。如果你在使用过程中遇到任何问题或疑问，也欢迎提问。
🍁3 Chat(聊天)功能 和市面上大多数AI工具一样，BLACKBOX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e610512bbd51f92b163e018eacc28d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162248ff49a08f6a545dd3dbb45e5b75/" rel="bookmark">
			数据恢复篇：5 款最佳 Mac 数据恢复软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到保护我们的数字生活，数据恢复软件的重要性怎么强调都不为过。无论您是意外删除了假期照片的普通用户，还是面临硬盘损坏的专业人士，随之而来的恐慌都是普遍存在的。幸运的是，数据恢复工具可以缓解这些压力。在Mac用户可用的众多选项中，我发现某些工具在可靠性、用户体验和有效性方面脱颖而出。在这次详尽的探索中，我将深入研究五大数据恢复软件解决方案——从多次拯救我的个人救星奇客数据恢复开始。
5 款最佳 Mac 数据恢复软件 1.奇客数据恢复 奇客数据恢复已成为 Mac 用户最可靠、最易用的工具之一。我个人认为，其用户友好界面和强大的扫描功能在数据丢失的棘手情况下可以起到关键作用。奇客数据恢复拥有多种功能，既能满足简单文件恢复的需求，也能满足复杂数据恢复的需求。
奇客数据恢复: 支持1000+数据格式恢复免费下载软件扫描数据，支持文件、照片、视频、邮件、音频等1000+种文件的格式恢复更有电脑/笔记本、回收站、U盘、硬盘等各类存储设备数据丢失恢复https://www.geekersoft.cn/geekersoft-data-recovery.html
优点
直观的用户界面
先进的扫描算法
支持多种文件系统
恢复前提供免费文件预览
缺点
免费版本有数据恢复限制
深度扫描可能非常耗时
2. EaseUS Data Recovery Wizard for Mac 在我的列表中排名第二的是EaseUS Data Recovery Wizard for Mac — 数据恢复领域的有力竞争者。我发现它可以非常有效地从不同设备（包括外部驱动器）检索各种文件类型。其简单的流程非常适合那些可能不太懂技术的用户的需求。
优点
易于导航的界面
高效恢复多种文件格式
可以从时间机器备份中恢复数据
技术支持随时可用
缺点
免费试用期间恢复有限
高级功能的许可成本可能很高
3. Stellar Data Recovery Professional for Mac Stellar Data Recovery Professional for Mac在数据恢复行业享有盛誉，它提供了一套强大的工具，可帮助您全面恢复数据。这款软件因其能够从逻辑和物理数据丢失情况中恢复数据的能力而广受好评，其精确度值得称赞。
优点
数据恢复成功率高
可以为崩溃的系统创建恢复驱动器
支持各种文件类型和格式
从加密驱动器恢复的选项
缺点
用户界面可能感觉过时
全面恢复可能需要付费升级
4. Mac 版 Data Rescue 5 提到 Mac 数据恢复工具，Data Rescue 5 for Mac值得上榜。这款软件在修复崩溃、损坏或无法启动的硬盘时特别有效，它有一套专门的实用程序，可以在危急情况下发挥重要作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/162248ff49a08f6a545dd3dbb45e5b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea8858836d8e62219683d22f483a525/" rel="bookmark">
			飞书机器人：企业级自动化办公的智能助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化转型的浪潮中，企业办公自动化成为提升工作效率的关键。飞书机器人以其强大的自动化功能，为企业提供了一个智能、高效的办公管理解决方案。
引言 随着企业规模的扩大和业务的复杂化，传统的办公方式逐渐显得力不从心。飞书机器人通过集成自然语言处理和机器学习技术，实现了办公流程的自动化和智能化。
飞书机器人的核心功能 飞书机器人通过以下核心功能，助力企业实现自动化办公：
自动化日程管理：智能安排会议和提醒，优化时间管理。智能文档处理：自动整理和分类文档，提高资料检索效率。会议摘要生成：自动记录会议内容并生成摘要，方便快速回顾。 伪代码示例：自动化日程管理 class FeiShuBot: def manage_schedule(self, event_details): event_time = event_details['time'] participants = event_details['participants'] # 自动安排会议时间，避免参与者时间冲突 available_time = self.find_available_time(participants) if available_time: return self.schedule_meeting(event_time, participants, available_time) else: return "No available time found." def find_available_time(self, participants): # 检查参与者日程，找到合适的会议时间 # 这里是模拟逻辑 return "14:00-15:00" def schedule_meeting(self, event_time, participants, available_time): # 根据找到的时间安排会议 return f"Meeting scheduled at {available_time} with {participants}." # 使用示例 bot = FeiShuBot() event = {"time": "2023-07-10", "participants": ["Alice", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea8858836d8e62219683d22f483a525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4361e69dd668c3afba208e5dc59b946d/" rel="bookmark">
			在鸿蒙ArkTS中使用Three.js实现3D模型渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言 鸿蒙操作系统作为华为自主研发的分布式操作系统,正在迅速发展并获得越来越多开发者的关注。ArkTS作为鸿蒙原生开发语言,提供了强大的声明式UI框架和丰富的系统能力。然而,在复杂的3D图形渲染方面,ArkTS还缺乏原生的支持。
Three.js是一个流行的JavaScript 3D库,它简化了WebGL的使用,使得创建3D图形变得更加容易。通过将Three.js与ArkTS结合,我们可以在鸿蒙应用中实现高质量的3D模型渲染,为用户提供更加丰富和交互的体验。
在本文中,我们将探讨如何在鸿蒙ArkTS应用中集成Three.js,实现3D模型的加载、渲染和交互。这种结合不仅能够扩展鸿蒙应用的功能,还能为开发者提供更多创新的可能性。
2.环境准备 在开始之前,我们需要准备好开发环境:
a) 安装鸿蒙开发环境:
下载并安装DevEco Studio (鸿蒙官方IDE)安装鸿蒙SDK和必要的开发工具 b) 创建新的鸿蒙项目:
打开DevEco Studio,创建一个新的"ArkTS Empty Ability"项目选择适当的API版本(建议选择最新的稳定版本) c) 安装依赖: 由于Three.js是一个JavaScript库,我们需要一种方法在ArkTS中使用它。我们可以使用鸿蒙的Web组件来实现这一点。
在项目的oh-package.json5文件中添加以下依赖:
{ "dependencies": { "three": "^0.137.0" } } 然后运行 npm install 安装依赖。
3.在ArkTS中集成Three.js a) 创建Web组件: 在ArkTS中,我们可以使用Web组件来加载和运行JavaScript代码。创建一个新的ets文件,命名为ThreeJSRenderer.ets:
@Component export struct ThreeJSRenderer { private controller: WebController = new WebController() build() { Web({ src: $rawfile('three_renderer.html'), controller: this.controller }) .width('100%') .height('100%') } } b) 创建HTML文件: 在项目的resources/rawfile目录下创建three_renderer.html文件:
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Three.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4361e69dd668c3afba208e5dc59b946d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/197/">«</a>
	<span class="pagination__item pagination__item--current">198/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/199/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>