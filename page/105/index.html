<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544f5eae6e0464d5aacfc10d4a76993e/" rel="bookmark">
			Laravel视图渲染封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种 app/Helpers/ViewHelper.php 创建一个辅助函数，用于动态确定视图路径：
&lt;?php if (!function_exists('fetchView')) { function fetchView($data = []) { $currentAction = \Route::currentRouteAction(); list($controller, $method) = explode('@', $currentAction); $viewPath = 'admin.' . strtolower(str_replace('Controller', '', class_basename($controller))) . '.' . $method; return view($viewPath, $data); // 将数据传递给视图 } } 接下来，在控制器中使用这个辅助函数来自动定位视图文件：
public function index(Request $request) { $data = [ 'title' =&gt; '首页', 'content' =&gt; '欢迎来到首页！' ]; return fetchView($data); // 将数据传递给视图 } 在视图中使用参数 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;{{ $title }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;{{ $title }}&lt;/h1&gt; &lt;p&gt;{{ $content }}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 第二种 protected function view($data) { $currentAction = \Route::currentRouteAction(); // 获取当前路由的控制器方法名 list($controller, $method) = explode('@', $currentAction); // 根据控制器和方法名确定视图路径 $viewPath = 'admin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544f5eae6e0464d5aacfc10d4a76993e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d97318ff535b4658220a54c3b31524/" rel="bookmark">
			skynet热更新之inject
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏服务器的热更新是一种常见的需求，skynet可以通过inject的方式，来修改一个服务的消息处理函数，达到热更新的效果。
skynet内置服务debug_console skynet自带了一个调试控制台服务。inject注入代码需要先启动这个服务。
skynet.newservice("debug_console", "127.0.0.1", "9666") 启动之后，我们可以用telnet或者nc等指令来登录调试控制台。
&gt; nc 127.0.0.1 9666 输入list指令，可以得到当前系统中所有服务的地址：
list :00000004 snlua cdummy :00000006 snlua datacenterd :00000007 snlua service_mgr :00000008 snlua main :00000009 snlua debug_console 127.0.0.1 9666 :0000000a snlua serviceA &lt;CMD OK&gt; 输入inject指令，我们可以将某个代码文件，注入到指定的服务中：
inject :0000000a service/hotfix.lua &lt;CMD OK&gt; 更多的debug_console指令可以参考这里
inject实例 我们在系统启动时，打开debug_console，然后启动服务serviceA，接着设置每隔5秒给serviceA发送两个lua消息，一个参数bar，一个参数foo，代码如下：
--main.lua local skynet = require "skynet" skynet.start(function() skynet.newservice("debug_console", "127.0.0.1", "9666") local addr = skynet.newservice("serviceA") local function tick() skynet.send(addr, "lua", "foo") skynet.send(addr, "lua", "bar") skynet.timeout(500, tick) end skynet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d97318ff535b4658220a54c3b31524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b1b0c3764c3d533d4fef27146d87a9/" rel="bookmark">
			SpringcloudAlibaba详解---超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Spring Cloud Alibaba是阿里巴巴结合自身的微服务实践开源的微服务全家桶，我个人觉得其组件比Spring Cloud 中的组件更加好用和强大。并且对的Spring Cloud组件做了很好的兼容。比如在Spirng Cloud Alibaba中依然可以使用Feign作为服务调用方式，使用Eureak做服务注册发现等等。
主要功能 1.服务注册和发现(nacos)：可以注册服务，并且客户可以使用Spring托管的bean（自动集成功能区）发现实例。注册中心。
2.分布式配置（nacos）：支持分布式系统中的外部配置，配置更改时自动刷新。 配置中心
3.流控制和服务降级(Sentinel )：支持WebServlet，WebFlux--&gt;(比Springmvc更高级)OpenFeign，RestTemplate，Dubbo访问限制和降级流的功能。它可以在运行时通过控制台实时修改限制和降级流的规则，并且还支持监视限制和降级度量标准。 - 服务熔断限流hystrix
4.Rpc服务：扩展Spring Cloud客户端RestTemplate(ribbon)和OpenFeign以支持调用Dubbo RPC服务。
5.分布式事务（seata）：支持高性能且易于使用的分布式事务解决方案。
6.事件驱动：支持构建与共享消息系统连接的高度可扩展的事件驱动微服务。
7.阿里云对象存储：大规模，安全，低成本，高度可靠的云存储服务。支持随时随地在任何应用程序中存储和访问任何类型的数据。
8.阿里云SchedulerX：准确，高度可靠，高可用性的计划作业调度服务，响应时间在几秒钟内。
9.阿里云短信：阿里云短信服务覆盖全球，提供便捷，高效，智能的通信功能，帮助企业快速联系客户。
与奈飞对比 注册中心nacos 什么是nacos Nacos致力于帮助您发现，配置和管理微服务。它提供了一组简单有用的功能，使您能够实现动态服务发现，服务配置，服务元数据和流量管理。Nacos使构建，交付和管理微服务平台变得更容易，更快捷。它是通过微服务或云原生方法支持以服务为中心的现代应用程序体系结构的基础架构。说的通俗一些，就是承担了奈飞框架中的Eureka的功能，相当于注册中心，但比Eureka更加智能与便捷。
如何安装nacos 官方提供了Nacos的服务端供我们下载使用，我们启动Nacos后将我们的微服务注册进入Nacos即可。
下载地址：[https://github.com/alibaba/nacos/releases]
启动nacos
nacos的启动也十分方便，在下载好的jar包目录下执行
- windows执行bin目录下的startup命令 ：startup.cmd -m standalone - linux 执行 ：sh startup.sh -m standalone
启动成功页面如下所示
nacos的默认端口为8848，在启动成功后，用户即可访问nacos，访问地址为:(本地单机模式)http://127.0.0.1:8848/nacos/index.html
登录的账号和密码均为:nacos
登录成功页面如图所示(笔者这里已经注册好了几个服务，故会有信息，第一次登录且未将服务注册到nacos的话，这里是没有信息的)
服务架构简单搭建 举例服务项目结构 微服务调用流程 Order-Service-20010提供订单的查询服务，Order-Client-30010调用Order-Service-20010提供的服务查询自身的订单信息，Order-Common作为公共服务，提供了相关实体类以及对应的无参有参构造方法
项目搭建 父工程的pom.xml
&lt;!--公共的一些配置--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;!--SpringBoot--&gt; &lt;parent&gt; &lt;groupId&gt; org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b1b0c3764c3d533d4fef27146d87a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ef151d5bf3bff21401474c2c115fc6/" rel="bookmark">
			【机器学习】解开反向传播算法的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 解开反向传播算法的奥秘反向传播算法的概述反向传播算法的数学推导1. 前向传播2. 计算损失函数3. 计算梯度4. 更新参数 反向传播算法在深度神经网络中的应用反向传播算法的局限性和发展总结 解开反向传播算法的奥秘 在深度学习领域,反向传播算法(Back Propagation)是训练神经网络的核心算法之一。它通过计算损失函数关于网络权重的梯度,并利用梯度下降法更新权重,从而实现了神经网络的有效训练。反向传播算法的出现,解决了传统神经网络难以训练的瓶颈,推动了深度学习的蓬勃发展。本文将深入探讨反向传播算法的原理、数学推导,以及在实践中的应用,帮助读者更好地理解和掌握这一重要算法。
反向传播算法的概述 在训练神经网络时,我们需要不断调整网络的权重和偏置参数,使得网络在训练数据上的输出值尽可能接近期望的目标值。这个过程可以看作是一个优化问题,目标是最小化一个损失函数(Loss Function)。
反向传播算法就是用于计算损失函数关于网络参数的梯度的算法。它由两个核心步骤组成:
前向传播(Forward Propagation):输入数据经过神经网络的层层传递,计算出网络的输出值。反向传播(Back Propagation):根据网络输出值和目标值计算损失函数,并计算损失函数关于网络参数的梯度,用于更新参数。 通过不断重复这两个步骤,神经网络的参数就会不断被优化,使得网络在训练数据上的输出值逐渐接近期望的目标值。
反向传播算法的数学推导 为了更好地理解反向传播算法,让我们通过数学推导来深入探讨其原理。我们将以一个简单的单层神经网络为例,推导反向传播算法的具体计算过程。
假设我们有一个单层神经网络,输入为 x = ( x 1 , x 2 , … , x n ) \mathbf{x} = (x_1, x_2, \ldots, x_n) x=(x1​,x2​,…,xn​),权重为 W = ( w 1 , w 2 , … , w n ) \mathbf{W} = (w_1, w_2, \ldots, w_n) W=(w1​,w2​,…,wn​),偏置为 b b b,激活函数为 f f f,输出为 y y y。我们的目标是最小化损失函数 L ( y , t ) L(y, t) L(y,t),其中 t t t是期望的目标值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ef151d5bf3bff21401474c2c115fc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c464beec3c55c6d6a4847872d997d390/" rel="bookmark">
			江科大/江协科技 STM32学习笔记P14
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、定时器定时中断与定时器有关的库函数1、Timer.c2、main.c 二、定时器外部时钟1、Timer.c外部时钟模式1和外部时钟模式2的区别 2、main.c 一、定时器定时中断 第一步，RCC开启时钟，定时器的基准时钟和整个外设的工作时钟都会同时打开，第二步，选择时基单元的时钟源，对于定时中断选内部时钟源，第三步，配置时基单元，包括这里的预分频器、自动重装器、计数模式等等，这些参数用一个结构体就可以配置好了，第四步，配置输出中断控制，允许更新中断输出到NVIC，第五步，配置NVIC，在NVIC中打开定时器中断的通道，并分配一个优先级，第六步，运行控制，整个模块配置完后使能一下计数器，当定时器使能后计数器开始计数，计数器更新触发中断，最后再写一个定时器的中断函数，中断函数每隔一段时间自动执行一次。
与定时器有关的库函数 void TIM_DeInit(TIM_TypeDef* TIMx); //恢复缺省配置，缺省就是默认 void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct); //时基单元初始化，第一个参数选择某个定时器，第二个结构体包含配置时基单元的一些参数 void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct); void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct); void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct); void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct); void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct); void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct); void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct); void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct); //把结构体变量赋默认值 void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct); void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct); void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct); void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState); //使能计数器，第一个参数选择定时器，第二个参数使能或失能 void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState); void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState); //使能中断输出信号，第二个选择要配置哪个中断输出 void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource); void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength); void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState); void TIM_InternalClockConfig(TIM_TypeDef* TIMx); //选择内部时钟 void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource); //选择ITRX其他定时器的时钟 void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource, uint16_t TIM_ICPolarity, uint16_t ICFilter); //选择TIx捕获通道的时钟，第二个参数选择TIx具体的某个引脚，第三个输入的极性，第四个滤波器 void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter); //选择ETR通过外部时钟模式1输入的时钟，第二个参数外部触发预分频器，三四极性和滤波器 void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter); //选择ETR通过外部时钟模式2输入的时钟，第二个参数外部触发预分频器，三四极性和滤波器 void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter); //单独用来配置ETR引脚的预分频器、极性、滤波器 void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode); //在初始化结构体里有很多关键的参数，比如自动重装值和预分频值等等，这些参数可能在初始化后还需要更改 //如果为了改某个参数重新调用初始化参数太麻烦，用一些单独的函数方便更改关键参数 //单独写预分频值，第一个参数写入的预分频值，第二个写入的模式 void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode); //改变计数器的计数模式 void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource); void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode, uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity); void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction); void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction); void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction); void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction); void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState); //自动重装器预装功能配置 void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState); void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState); void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState); void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload); void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload); void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload); void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload); void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast); void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast); void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast); void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast); void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear); void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear); void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear); void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear); void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity); void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity); void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity); void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity); void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity); void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity); void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity); void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx); void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN); void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode); void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState); void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource); void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState); void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode); void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource); void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode); void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter); //给计数器写入一个值 void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload); //给自动重装器写入一个值 void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1); void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2); void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3); void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4); void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC); void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC); void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC); void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC); void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD); uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx); uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx); uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx); uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx); uint16_t TIM_GetCounter(TIM_TypeDef* TIMx); //查看当前计数器计到哪里了 uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx); //获取当前预分频器的值 FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG); void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG); ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT); void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT); //上4获取标志位和清除标志位 1、Timer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c464beec3c55c6d6a4847872d997d390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70bde2562d5419322c67295dc3e4382d/" rel="bookmark">
			【机器学习】-9.十大算法之一朴素贝叶斯（Naive Bayes）算法案例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9.机器学习-十大算法之一朴素贝叶斯（Naive Bayes）算法案例讲解 一·摘要二·个人简介三·3种贝叶斯模型3.1 高斯分布朴素贝叶斯1. 高斯分布（正态分布）：2. 朴素贝叶斯原理：3. 朴素假设：4. 高斯分布朴素贝叶斯的应用：5. 计算过程：6. 优点：7. 缺点： 3.2 多项式分布朴素贝叶斯1. 多项式分布：2. 朴素贝叶斯原理：3. 朴素假设：4. 参数估计：5. 分类决策：6. 拉普拉斯平滑：7. 优点：8. 缺点： 3.3 伯努利分布朴素贝叶斯1. 伯努利分布：2. 朴素贝叶斯原理：3. 朴素假设：4. 参数估计：5. 分类决策：6. 拉普拉斯平滑：7. 优点：8. 缺点： 四·文本分类实战高斯分布贝叶斯多项式分布贝叶斯伯努利分布贝叶斯 一·摘要 机器学习中的朴素贝叶斯（Naive Bayes）算法是一种基于贝叶斯定理和特征条件独立假设的分类算法。该算法通过计算给定特征下各个类别的概率，并选择概率最大的类别作为预测结果。朴素贝叶斯算法因其简单、高效且易于实现的特点，在文本分类、垃圾邮件过滤、情感分析等领域得到广泛应用。以下案例将详细讲解朴素贝叶斯算法的原理、应用及其实践过程中的注意事项。
二·个人简介 🏘️🏘️个人主页：以山河作礼。
🎖️🎖️:Python领域新星创作者，CSDN实力新星认证，CSDN内容合伙人，阿里云社区专家博主，新星计划导师，在职数据分析师。 💕💕悲索之人烈焰加身，堕落者不可饶恕。永恒燃烧的羽翼，带我脱离凡间的沉沦。
🐘 希望大家能持续支持，共同向前迈进！😁 如果您觉得文章有价值， 欢迎留言💬，点赞👍，收藏🔖并关注我们➕🤝。 🪐💫💫💫💫💫💫💫热门专栏💫💫💫💫💫💫💫🪐 类型专栏Python基础Python基础入门—详解版Python进阶Python基础入门—模块版Python高级Python网络爬虫从入门到精通🔥🔥🔥Web全栈开发Django基础入门Web全栈开发HTML与CSS基础入门Web全栈开发JavaScript基础入门Python数据分析Python数据分析项目🔥🔥机器学习机器学习算法🔥🔥人工智能人工智能 三·3种贝叶斯模型 朴素贝叶斯（Naive Bayes）是一种基于贝叶斯定理的分类算法，它假设特征之间相互独立（即朴素的假设）。根据特征的分布类型，朴素贝叶斯可以采用不同的分布模型来描述特征的概率分布。
高斯分布朴素贝叶斯（Gaussian Naive Bayes）：
当特征值是连续的并且近似正态分布时，可以使用高斯分布（正态分布）来建模。在这种情况下，我们假设每个特征的值都服从一个高斯分布，其参数（均值和方差）由训练数据估计。高斯朴素贝叶斯适用于特征值近似正态分布的情况，例如身高、体重等。
多项式分布朴素贝叶斯（Multinomial Naive Bayes）：
当特征值是离散的并且每个特征可以取多个值时，可以使用多项式分布来建模。例如，文本分类中，每个单词的出现与否可以看作一个特征，每个特征可以取0或1的值（出现或不出现）。多项式分布朴素贝叶斯适用于文本数据或计数数据，其中特征的分布可以用多项式概率质量函数来描述。
伯努利分布朴素贝叶斯（Bernoulli Naive Bayes）：
当特征值是二元的（即每个特征只能取0或1的值）时，可以使用伯努利分布来建模。伯努利朴素贝叶斯适用于二元特征，例如垃圾邮件分类中，每个特征可能表示某个特定单词是否出现在邮件中。伯努利分布是二项分布的特例，其中试验次数为1。
导入相关库
import numpy as np import pandas as pd import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70bde2562d5419322c67295dc3e4382d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18bbe51a89780d19b394db4c994e1e72/" rel="bookmark">
			【2024版】超详细Python&#43;Pycharm安装保姆级教程，Python&#43;Pycharm环境配置和使用指南，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Python开发环境配置1.Python下载与安装二、PyCharm安装+运行测试+汉化1.PyCharm下载及安装2.解释器配置及项目测试3.PyCharm汉化 本文将从 Python解释器安装到Pycharm专业版安装和配置汉化等使用都进行了详细介绍，希望能够帮助到大家。
Python解释器&amp;Pycharm安装包&amp;Pycharm破姐插件我都打包好了。
这份完整版的Python安装包已经上传至CSDN官方，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费获取【保证100%免费】。
CSDN大礼包：《2024年最新全套学习资料包》免费分享
一、Python开发环境配置 1.Python下载与安装 真实在Windows上安装过Python的小伙伴会发现在 Windows 上安装Python真的和安装普通软件一样简单，我们只需要在官网下载个安装包，然后猛击“下一步”就可以了（真的秒~）！
Python 安装包官网下载地址：https://www.python.org/downloads/
第一步：点击首页的Downloads，并在下拉框中选择Windows
第二步：选择指定版本
此处我选择的是最3.11.4版本，但是如果你因为项目对Python版本有特定要求的话，可以此界面下滑选择需要的版本下载！
需要插一嘴的是，为了防止你们下错而死在了安装上，简单对此界面一些前缀后缀进行说明（认真看看你下的是不是你想要的）：
前后缀含义64-bit64位的Python安装程序（现在的电脑一般都是64bit的）32-bit32位的Python安装程序Windows embeddable package.zip格式的绿色免安装版本，可直接嵌入（集成）到其他的应用程序中Windows installer.exe格式的可执行程序，这是完整的离线安装包（就选这个，别想了！） 第三步：下拉到最下面然后点击就在下载了哦
第四步：双击下载的.exe文件就正式开始安装Python了
Install now 默认安装和默认安装路径（一般默认安装在C盘，不建议）Customize installation 自定义安装 （友情提示：一定要勾选Add Python.exe to PATH，这样的话Python命令工具所在的目录就会自动添加到系统环境变量中，就不需要你手动添加python系统环境变量啦，在执行Python命令时也不需要指定完整路径了！）
Python 支持两种安装方式，默认安装和自定义安装：
默认安装会勾选所有组件，并安装在 C 盘；自定义安装可以手动选择要安装的组件，并可自定义其安装位置。（正经人肯定选这个，我也推荐选这个，不然你啥东西都安C盘里，电脑会变卡哦~而且大家以后不管安装啥都看一眼安装路径，建议自定义哦！） ①点击Customize installation进入下一步，选择要安装的组件，建议保持默认即可，也就是全部勾选；
②点击“Next”，选择安装目录（这就是自定义Python的安装路径，自己找个盘放哦~）
③最后点击“Install”，静候一会就安装好啦！
In the end：测试是否安装OK
“win+r”打开Windows的命令行程序，输入python命令，如果出现下图所示则证明安装OK哦！
二、PyCharm安装+运行测试+汉化 1.PyCharm下载及安装 1.点击蓝色链接----&gt;PyCharm官网，进入之后是这个界面。
2.点击"Download"进入下载页面
以专业版为例，继续进行安装（安装内容没啥太大区别，所以两版本都适用）
3.下载好后，放到桌面，双击点开
4.双击点开后，如图所示，点击右下角"下一步"
选择安装路径，继续下一步
5.之后进入如下界面，勾选如图，勾选好之后点击右下角"下一步"
6.紧接着点击”安装“
7.安装完毕后，点击"完成"
8.安装完毕，如图：
安装到这里基本就完成了，可以选择先重启，也可以先继续先往下看，进行操作。
2.解释器配置及项目测试 1.双击点开安装好的PyCharm
2.打开后如图所示，左下角后勾选，然后右下角点击"继续"
3.选择"不发送"
4.之后进入如图界面，点击"New Project"
5.点击后，如图进行选择操作，选择自己项目路径，以及自己安装的解释器，完成后点击右下角"Create"
6.完成后如图
7.创建一个test.py文件，进行测试，在右边框栏里进行编程（以求1+2的和为例）。
a = 1 b = 2 print(a+b) 到这呢，如果没有汉化需求，那安装配置就结束了，如有汉化需求，请继续往下看。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18bbe51a89780d19b394db4c994e1e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a81295ae1a1099a22c79259635a856/" rel="bookmark">
			图像生成中图像质量评估指标—FID介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 背景介绍2. 实际应用3. 总结和讨论 1. 背景介绍 Fréchet Inception Distance（\textbf{FID}）是一种衡量生成模型性能的指标，它基于Inception网络提取的特征来计算模型生成的图像与真实图像集合之间的距离。
FID利用了Inception模型（通常指的是InceptionV3）来提取图像的特征表示。然后，它计算了两组特征（真实图像和生成图像）的Fréchet距离，即均值和协方差之间的距离。
FID的计算公式如下：
FID = ∥ μ real − μ fake ∥ 2 2 + Tr ( Σ real + Σ fake − 2 ( Σ real Σ fake ) 1 2 ) \text{FID} = \|\mu_{\text{real}} - \mu_{\text{fake}}\|_2^2 + \text{Tr}(\Sigma_{\text{real}} + \Sigma_{\text{fake}} - 2(\Sigma_{\text{real}}\Sigma_{\text{fake}})^{\frac{1}{2}}) FID=∥μreal​−μfake​∥22​+Tr(Σreal​+Σfake​−2(Σreal​Σfake​)21​)
其中：
μ real \mu_{\text{real}} μreal​ 和 μ fake \mu_{\text{fake}} μfake​ 分别是真实图像和生成图像特征的均值。 Σ real \Sigma_{\text{real}} Σreal​ 和 Σ fake \Sigma_{\text{fake}} Σfake​ 分别是真实图像和生成图像特征的协方差矩阵。 Tr \text{Tr} Tr 表示矩阵的迹（即对角线元素的和）。 FID的核心思想是量化两组图像在特征空间中的分布差异。较小的FID值表示生成图像的特征分布更接近真实图像的分布，这意味着生成图像的质量更高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a81295ae1a1099a22c79259635a856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e36a0ec1c3e306fb0c8f3a475caab19/" rel="bookmark">
			GPT-4o mini：AI技术的平民化革命
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言一、GPT-4o mini简介二、性能表现三、技术特点四、价格与市场定位五、应用场景六、安全性与可靠性七、未来展望八、代码示例结语 引言 在人工智能的浪潮中，大模型技术一直是研究和应用的热点。然而，高昂的成本和复杂的部署常常让许多企业和开发者望而却步。2024年7月19日，OpenAI推出了一款全新的AI模型——GPT-4o mini，这不仅是技术进步的体现，更是AI技术平民化的一次重要尝试。本文将详细介绍GPT-4o mini的特点、性能、应用场景以及其在市场中的定位，带你深入了解这款具有里程碑意义的AI模型。
一、GPT-4o mini简介 GPT-4o mini 是 OpenAI 推出的一款小型智能模型，它是 GPT-4o 的简化版本，具有更小的参数量和更高的性价比。这款模型在功能上非常强大，性能接近原版 GPT-4，同时成本相比 GPT-3.5 Turbo 降低了超过 60%。GPT-4o mini 支持多达 50 种不同语言，能够处理大量的上下文信息，支持文本和视觉输入输出，未来还计划扩展到图像、视频和音频的输入输出。
二、性能表现 GPT-4o Mini 在多个学术基准上都表现出色，超越了 GPT-3.5 Turbo 和其他小型模型。以下是一些关键数据：
1.MMLU 基准：在文本智能和推理基准 MMLU 上得分为 82.0%，优于 Gemini Flash（77.9%）和 Claude Haiku（73.8%）。
2.数学和编码能力：在 MGSM 上得分为 87.0%，HumanEval 上得分为 87.2%，均优于市场上的其他小型模型。
3.多模态推理：在多模态推理评估 MMMU 上表现出色，得分为 59.4%，优于 Gemini Flash 和 Claude Haiku。
三、技术特点 多模态能力：GPT-4o mini 支持文本和视觉输入输出，未来将扩展到图像、视频和音频。这种多模态能力使得 GPT-4o mini 能够处理更复杂的任务，提供更丰富的交互体验。上下文窗口：具有 128K tokens 的上下文窗口，每个请求支持最多 16K 输出 tokens。这使得 GPT-4o mini 能够处理长文本和复杂对话，提供更连贯和准确的响应。知识截止日期：知识截止日期为 2023 年 10 月，能够处理非英语文本。这使得 GPT-4o mini 在多语言环境中表现出色，满足全球用户的需求。安全性：内置安全措施，通过预训练和后训练的过滤和对齐技术，确保模型行为符合政策。这使得 GPT-4o mini 在提供高性能的同时，也保障了用户的安全和隐私。 四、价格与市场定位 GPT-4o mini 的 API 定价极具竞争力，每百万输入 tokens 为 15 美分（约 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e36a0ec1c3e306fb0c8f3a475caab19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee4ff2641b604e605e5fdfef6108cd5/" rel="bookmark">
			在CentOS 7上安装和使用PostgreSQL的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
简介 关系数据库管理系统是许多网站和应用程序的关键组成部分。它们提供了一种结构化的方式来存储、组织和访问信息。
PostgreSQL，或者简称为 Postgres，是一个关系数据库管理系统，提供了 SQL 查询语言的实现。它是许多小型和大型项目的热门选择，并且具有符合标准和可靠的事务以及无读锁并发等许多高级功能的优势。
在本指南中，您将在 CentOS 7 服务器上安装 Postgres，并学习一些基本的使用方法。
先决条件 要按照本教程进行操作，您需要：
通过遵循我们的《在 CentOS 7 上进行初始服务器设置》和《新 CentOS 7 服务器的其他推荐步骤》教程对 CentOS 7 服务器进行配置，包括具有 sudo 权限的非根用户和使用 firewalld 设置防火墙。要设置 firewalld，请按照《新 CentOS 7 服务器的其他推荐步骤》教程中的 配置基本防火墙 部分进行操作。如果数据库非常活跃并且在内部记录中有时间戳，那么数据库可能对系统时间更改特别敏感。为了防止由于时钟不同步而导致的一些不一致行为，确保按照《新 CentOS 7 服务器的其他推荐步骤》教程中的 配置时区和网络时间协议同步 部分设置网络时间协议（NTP）同步。 步骤 1 — 安装 PostgreSQL Postgres 可以使用默认的 CentOS 软件仓库进行安装。但是在撰写本教程时，CentOS 7 Base 软件仓库中提供的版本已经过时。因此，本教程将使用官方的 Postgres 软件仓库。
在继续设置新软件仓库之前，从 CentOS-Base 软件仓库中排除对 postgresql 软件包的搜索。否则，依赖关系可能会解析为基础软件仓库提供的 postgresql。
使用您喜欢的文本编辑器打开软件仓库配置文件。本教程将使用 vim：
sudo vi /etc/yum.repos.d/CentOS-Base.repo 找到 [base] 和 [updates] 部分，按 i 进入插入模式，并在这两个部分中插入 exclude=postgresql* 行。结果，您的文件将如下所示，新行已突出显示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ee4ff2641b604e605e5fdfef6108cd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb2d9d4757832be34fc1e4ad6cb1110/" rel="bookmark">
			css -- box-shadow阴影属性的复合写法及高级用法，超详细！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：最近又叕看到了一个好看的特效，随后整理了一下，发现实现起来主要靠一个css属性就实现了，有一次刷新了我对css强大的认知😎，这个属性就是box-shadow，平常我们用到的比较少，但是针对于C端可能使用就多了，但是你们真正掌握了它的使用吗？让我这一文带你深度了解box-shadow🧐
🌈🌈文章目录
box-shadow属性介绍及用法 基本使用
高级使用
五个值
inset（六个值）
多个阴影
关键字
加个动画
box-shadow属性介绍及用法 box-shadow可以为元素的框架添加阴影效果，这个属性可以设置多个阴影效果，每个阴影效果之间用逗号分隔。box-shadow属性可以设置的值包括阴影的X轴偏移量、Y轴偏移量、模糊半径、扩散半径和颜色
基本使用 平常使用我们都是box-shadow：第一个值 第二个值 第三个值 第四个值；每个值后面用空格隔开
第一个值：阴影往X轴的偏移距离第二个值：阴影往Y轴偏移的距离第三个值：阴影模糊的半径，值越大阴影越模糊第四个值：阴影的颜色可以使用十六进制也可以使用rgba()写法 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; // box盒子阴影X轴便宜10像素Y轴偏移10像素，模糊半径为20像素，颜色为#ccc .box{ margin: 100px auto; width: 200px; height: 200px; border-radius: 50%; border: none; background-color: rgb(151, 211, 151); box-shadow: 10px 10px 20px #ccc; } &lt;/style&gt; &lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 高级使用 五个值 box-shadow其实有五个值，如果有五个值的情况，那第四个值就不再是颜色了，而第五个值是颜色，第四个值表示的是阴影的半径大小，值越大阴影越大
&lt;style&gt; .box{ width: 200px; height: 200px; border-radius: 50%; border: none; background-color: rgb(77, 255, 0); box-shadow: 10px 10px 20px 30px #ccc; } &lt;/style&gt; inset（六个值） 当使用了inset的时候变成了六个值，阴影将不再是对外扩散，相反是网内出现内阴影，而且第五个值（五个值时的第四个值）数值越大阴影往内扩散越大，直到铺满盒子，数值在变大阴影也不会出现变化了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcb2d9d4757832be34fc1e4ad6cb1110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b66d337d45ae694c049d4facc5d03a1/" rel="bookmark">
			【C&#43;&#43;】：红黑树深度剖析 --- 手撕红黑树！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 💡前言一，红黑树的概念二，红黑树的性质三，红黑树节点的定义四，红黑树的插入操作4.1 第一步4.2 第二步4.3 插入操作的完整代码 五，红黑树的验证六，实现红黑树的完整代码五，红黑树与AVL树的比较 点击跳转至上一篇文章： 【C++】：AVL树的深度解析及其实现 点击跳转至文章：【C++】：二叉树进阶 — 搜索二叉树 💡前言 上一篇文章介绍了什么是AVL树和AVL树的实现，AVL树也有它的缺点：就是太过追求绝对平衡，比如在插入时要维护其绝对平衡，旋转次数太多，在删除时甚至有可能要一直旋转到根位置，使之性能低下。
本篇文章介绍的红黑树也是一种平衡树，是通过改变节点颜色以及旋转操作，使之接近平衡。
红黑树比AVL树的用途更加广泛，在一些方面效率甚至要优于AVL树，并且 map/set 的底层封装用的也是红黑树。
一，红黑树的概念 红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。
二，红黑树的性质 (1) 每个结点不是红色就是黑色 ；
(2) 根节点是黑色的 ；
(3) 如果一个节点是红色的，则它的两个孩子结点是黑色的（重点）；
(4) 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（重点） ；
(5) 每个叶子结点都是黑色的(此处的叶子结点指的是空结点，这条性质可有可无，平时不关注)。
三，红黑树节点的定义 红黑树的节点结构与AVL树的大致相同，只是AVL树中有节点的颜色，没有平衡因子。
//枚举颜色 enum Colour { RED, BLACK }; template &lt;class K, class V&gt; struct RBTreeNode { RBTreeNode&lt;K, V&gt;* _left; RBTreeNode&lt;K, V&gt;* _right; RBTreeNode&lt;K, V&gt;* _parent; pair&lt;K, V&gt; _kv; Colour _col; RBTreeNode(const pair&lt;K, V&gt;&amp; kv) :_left(nullptr) ,_right(nullptr) ,_parent(nullptr) ,_kv(kv) ,_col(BLACK) {} }; 四，红黑树的插入操作 首先我们要思考一个问题，插入节点时，到底是插入红色节点还是黑色节点？为什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b66d337d45ae694c049d4facc5d03a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b57c14fd5199da26f63a49811e409585/" rel="bookmark">
			TCP粘包问题详解和解决方案【C语言】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是TCP粘包 TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输协议，它保证了数据的可靠性和顺序性。然而，由于TCP是基于字节流而不是消息的，因此在传输过程中可能会出现粘包（Packing）和拆包（Unpacking）问题。
**粘包问题（TCP粘包现象）**指的是发送方在传输数据时，TCP协议把多个发送的小数据包“粘”在一起，形成一个大的数据包发送；或者接收方在接收数据时，多个小的数据包被“粘”在一起，形成一个大的数据包接收。这种现象的发生是由于TCP协议的工作机制导致的。
原因和机制 TCP工作方式：TCP是基于字节流的协议，它并不了解上层应用发送的消息边界（Message Boundary）。它只负责把接收到的字节流按照顺序交给应用层，因此多个发送的小数据包在传输过程中有可能会被合并成一个大的数据包发送，或者一个大的数据包被拆分成多个小数据包接收。
发送端的粘包：
发送端应用程序往往会先把数据放入TCP发送缓冲区，然后TCP根据自身的发送策略（如Nagle算法等）进行发送，可能会合并多个数据包一起发送，以提高网络利用率和性能。如果发送端应用程序发送的消息比较小，并且发送速率较快，这些小消息在TCP层可能会被合并成一个大的数据包发送，导致接收方接收到的数据出现粘包现象。 接收端的粘包：
接收端应用程序从TCP接收缓冲区中读取数据时，由于TCP层不了解应用层的消息边界，可能一次性把多个发送的小数据包“粘”在一起交给应用层处理。如果接收端应用程序处理消息的速度跟不上数据的接收速度，会导致接收到的数据出现粘包现象。 例如：
客户端和服务器之间要进行基于TCP的套接字通信通信过程中客户端会每次会不定期给服务器发送一个不定长度的有特定含义的字符串。通信的服务器端每次都需要接收到客户端这个不定长度的字符串，并对其进行解析 根据上面的描述，服务器在接收数据的时候有如下几种情况：
一次接收到了客户端发送过来的一个完整的数据包一次接收到了客户端发送过来的N个数据包，由于每个包的长度不定，无法将各个数据包拆开一次接收到了一个或者N个数据包 + 下一个数据包的一部分，还是很悲剧，无法将数据包拆开一次收到了半个数据包，下一次接收数据的时候收到了剩下的一部分+下个数据包的一部分，更悲剧，头大了另外，还有一些不可抗拒的因素：比如客户端和服务器端的网速不一样，发送和接收的数据量也会不一致 解决方案 粘包问题在实际的网络编程中是常见的，需要采取一些策略来解决或者减少其影响：
消息边界标记：在发送的消息中加入特定的消息边界标记（如换行符 \n），接收端根据消息边界标记来分割接收到的数据，从而识别出完整的消息。有缺陷: 效率低, 需要一个字节一个字节接收, 接收一个字节判断一次, 判断是不是那个特殊字符串
消息长度固定：发送端将每个消息的长度固定，接收端根据固定长度来分割接收到的数据，从而确保每个接收到的数据包含完整的消息。缺点：容易造成空间浪费
消息头部长度字段：发送端在每个消息前加入一个固定长度的消息头部，包含消息的长度信息，接收端根据头部长度字段来读取对应长度的消息数据。这时候数据由两部分组成：数据头+数据块，数据头：存储当前数据包的总字节数，接收端先接收数据头，然后在根据数据头接收对应大小的字节，数据块：当前数据包的内容
使用标准的应用层协议（比如：http、https）来封装要传输的不定长的数据包
2.解决方案具体实现 这里我们使用消息头+数据块的解决方案，如果使用TCP进行套接字通信，如果发送的数据包粘连到一起导致接收端无法解析，我们通常使用添加包头的方式轻松地解决掉这个问题。关于数据包的包头大小可以根据自己的实际需求进行设定，这里没有啥特殊需求，因此规定包头的固定大小为4个字节，用于存储当前数据块的总字节数。
发送端设计 对于发送端来说，数据的发送分为以下四步：
动态申请内存： 根据待发送的数据长度 N申请一块大小为 N+4 的内存，其中4个字节用于存储包头信息。
写入包头： 将待发送数据的总长度（N）写入申请的内存的前四个字节中，并将其转换为网络字节序（大端序）。
拷贝数据并发送： 将待发送的数据拷贝到包头后面的地址空间中，然后将整个数据包发送出去。这里需要确保数据包能够完整发送，因此可以设计一个发送函数，确保当前数据包中的数据全部发送完毕。
释放内存： 发送完毕后，释放申请的堆内存。
示例代码： /* 函数描述: 发送指定的字节数 函数参数: - fd: 通信的文件描述符(套接字) - msg: 待发送的原始数据 - size: 待发送的原始数据的总字节数 函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1 */ int writen(int fd, const char* msg, int size) { const char* buf = msg; // 指向待发送数据的指针 int count = size; // 记录剩余待发送的数据字节数 while (count &gt; 0) { // 尝试发送剩余数据 int len = send(fd, buf, count, 0); if (len == -1) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b57c14fd5199da26f63a49811e409585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3afcd3db91ea9bb00e2dedd1d4bf2f3/" rel="bookmark">
			Docker安装 OpenResty详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OpenResty 是一个基于 Nginx 的高性能 Web 平台，它集成了 Lua 脚本语言，使得开发者可以在 Nginx 服务器上轻松地进行动态 Web 应用开发。OpenResty 的核心目标是通过将 Nginx 的高性能与 Lua 的灵活性结合起来，提供一个强大且高效的 Web 开发环境。
OpenResty 官网地址：https://openresty.org/
一、拉取镜像 docker pull openresty/openresty:latest 二、启动容器 docker run -d -p 8080:80 openresty/openresty:latest 三、访问测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8c3ba77a3d43f2317fb7e940c4a071/" rel="bookmark">
			数据结构之队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列 概念 概念：只允许在⼀端进⾏插⼊数据操作，在另⼀端进⾏删除数据操作的特殊线性表，队列具有先进先 出FIFO(First In First Out)
⼊队列：进⾏插⼊操作的⼀端称为队尾
出队列：进⾏删除操作的⼀端称为队头
队列底层结构选型
队列也可以数组和链表的结构实现，使⽤链表的结构实现更优⼀些，因为如果使⽤数组的结构，出队 列在数组头上出数据，效率会⽐较低。
原因如下：
结构 //定义队列节点结构 struct	QueueNode { int data; struct QueueNode*next; } struct Queue { struct QueueNode*phead; struct QueueNode*tail; } 队列的底层是链表，但是这里和单链表不同的是要写两个结构体，因为一个是确认底层的，还有一个是确定队列的结构的，因为队列要有队头和队尾
入队列 需要进行分类讨论：队列不为空和队列为空两种情况
如果队列不为空我们需要尾插一个新元素，然后让ptail指向新元素，如果队列为空，让phead=ptail指向新的元素
代码如下：
// ⼊队列，队尾 void QueuePush(Queue* pq, QDataType x) { assert(pq); //申请新节点 QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode)); if (newnode == NULL) { perror("malloc fail!"); exit(1); } newnode-&gt;data = x; newnode-&gt;next = NULL; //ptail newnode if (pq-&gt;phead == NULL) { //队列为空 pq-&gt;phead = pq-&gt;ptail = newnode; } else { //队列不为空 pq-&gt;ptail-&gt;next = newnode; pq-&gt;ptail = newnode; } pq-&gt;size++; } 出队列 和栈出数据非常的相似都需要判断队列是否为空 队列为空，不可出队列；队列不为空，可以出队列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8c3ba77a3d43f2317fb7e940c4a071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58c71e1622273409a34e14b80b0ae3e7/" rel="bookmark">
			Blackbox AI-跨时代AI产物，你的私人编程助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引言 随着人工智能技术的飞速发展，我们的生活方式正在经历前所未有的变革。从智能家居到自动驾驶，AI已经渗透到我们生活的方方面面。而在这场科技革命中，Blackbox 网站凭借其先进的技术和全面的功能，成为了众多AI产品中的佼佼者。Blackbox 不仅集成了最新的AI技术，还致力于为用户提供最个性化、最贴心的智能助手服务。
Blackbox 是一款多功能的私人智能助手，旨在为用户提供高效的服务和个性化的建议。无论是在日常生活中还是在工作场景中，Blackbox 都能通过其强大的语音识别、自然语言处理和数据分析功能，帮助用户轻松应对各种任务。它不仅能提高你的生活质量，还能大幅提升工作效率。
在接下来的文章中，我们将深入探讨Blackbox 的主要功能、实际应用场景、技术优势……帮助你全面了解这款跨时代的AI产物。
希望大家可以喜欢这个不需要登陆、不需要充值，点开即可使用的优秀 AI ！
官方网站：www.blackbox.ai
2. 实力描述 Blackbox 是专门为程序员量身定制的语言大模型，它针对 20 多种编程语言进行了特别训练和深度优化，在 AI 代码编写和辅助开发的效率上远超其他大模型。在过去 12 个月超越了所有其他的语言模型，在 HumanEval 测试任务中达到了 85.36%的完成度，位列第一。
注：Human Eval - HumanEval是一个用于评估代码生成模型性能的数据集，由OpenAI在2021年推出。这个数据集包含164个手工编写的编程问题，每个问题都包括一个函数签名、文档字符串（docstring）、函数体以及几个单元测试。这些问题涵盖了语言理解、推理、算法和简单数学等方面。这些问题的难度也各不相同，有些甚至与简单的软件面试问题相当。 这个数据集的一个重要特点是，它不仅仅依赖于代码的语法正确性，还依赖于功能正确性。也就是说，生成的代码需要通过所有相关的单元测试才能被认为是正确的。这种方法更接近于实际编程任务，因为在实际编程中，代码不仅需要语法正确，还需要能够正确执行预定任务。结果通过pass@k表示，其中k表示模型一次性生成多少种不同的答案中，至少包含1个正确的结果。例如Pass@1就是只生成一个答案，准确的比例。如果是Pass@10表示一次性生成10个答案其中至少有一个准确的比例。目前，收集的包含Pass@1、Pass@10和Pass@100
3. 主要功能 代码聊天 — BLACKBOX AI 旨在回答编码问题并帮助您更快地编写代码。无论您是在修复错误、构建新功能还是重构代码，请向 BLACKBOX 寻求帮助。实时知识 — BLACKBOX AI 拥有对世界的实时了解，使其能够回答有关最近事件、技术突破、产品发布、API 文档等以及最重要的 BLACKBOX 节目来源的问题。视觉 — BLACKBOX AI VISION 使用户能够指示 BLACKBOX 分析图像输入，例如代码或产品草图的屏幕截图。AI 代理 — BLACKBOX AI 提供了多种 AI 代理选择，他们都是各自领域的专家！自定义聊天机器人— 您可以根据您的数据创建自己的聊天机器人！Github 集成 — BLACKBOX AI 可以直接在您的存储库上执行任务，例如从错误报告生成问题或对代码进行注释 4. 使用流程 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58c71e1622273409a34e14b80b0ae3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/214ae641b7cfd905e4cdcbcd784efd4d/" rel="bookmark">
			鸿蒙小案例-图片预览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简单的图片预览器
效果
鸿蒙图片放大demo
核心为使用CustomDialogController实现
使用方法：
当做变量引入即可
defDialog: CustomDialogController = new CustomDialogController({ builder: ImgToUp({ url: this.url }), autoCancel: true, alignment: DialogAlignment.Center, customStyle: true }) 放大后 添加了 下载至相册功能，不需要获取权限
使用时网络图片需添加网络权限
基于API12
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81543bb048dff7b55e1fd6dda480073a/" rel="bookmark">
			大疆创新2025校招内推
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大疆2025校招-内推 一、我们是谁？ 大疆研发软件团队，致力于把大疆的硬件设备和大疆用户紧密连接在一起，我们的使命是“让机器有温度，让数据会说话”。
在消费和手持团队，我们的温度来自于激发用户灵感并助力用户创作，目前的核心产品是航拍应用DJI FLY和手持应用DJI Mimo，他们能让小白用户轻松上手并拍出有大片质感的作品，不管是拍摄教学、畅爽的飞行体验、富有创意的组合运镜，还是剪辑与分享，你想要的这里都有；
在行业和农业团队，我们的温度来自于提升社会生产力，这里有行业和农业应用，搭配司空云平台、大疆农服，轻松搞定安防、测绘、植保等工作。
二、客户端开发工程师做什么？ 在研发软件团队，客户端岗位负责的业务方向包括但不限于：DJI FLY、DJI Mimo、行业Pilot、司空2、行业生态SDK、DJI Agras、大疆农服等；可以参与到软件在手机、Pad、PC或自研终端设备上的应用程序开发和技术实现，负责DJI移动终端SDK的开发和优化。
三、前端开发工程师在做什么？ 持续建设司空/无人机云平台，追求极致低延时的远程控制，实现所见即所得的航线规划，提供高效调度的任务管理。将世界装入浏览器的三维 GIS 作业平台，每一行前端代码都与无人机硬件能力紧密联动。
四、加入我们之后您可以获得什么？ 1.迅速提升技术能力的机会
业务场景复杂度高：大疆软件客户端开发的业务场景比较复杂，如FPV界面，布局复杂，对分层、懒加载、机型隔离的要求高，比起一般的业务APP更具挑战
性能挑战大：业务场景性能要求高，实时类工具应用比较消耗CPU、GPU资源，为了获得低延迟等良好的用户体验，自然对于性能有更大的挑战
技术面广：开发中涉及到的技术面比较广，既有常规的UI开发，也有多媒体、3D、通讯协议、硬件通信(USB、WIFI、BLE)、数据安全与隐私等技术领域。
2.优渥的工作回报&amp;轻松务实的工作氛围
业界领先的薪酬福利：包括但不限于丰厚薪资、舒适公寓、文化周边、产品优惠、带薪假期、年节礼盒、弹性打卡、网红零食…
轻松务实的工作氛围：人际关系简单纯粹，团队结构扁平化；团队内及跨团队沟通实事求是、不论资排辈。追求共同目标——为了更好的产品及用户体验。
3.快乐工作、持续成长的平台
自我成长的丰沃土壤：获得定制化培训课程、mentor辅导、内部晋升、横向发展的多样机会。
结交同频伙伴：通过丰富多彩的公司内部社团、团建活动、社交活动等，收获更多优秀的职场挚友。一起成长，共同收获进步！
P.S.今年研发团队软件方向校招中，客户端开发（研发部-深圳）、前端开发工程师（研发部-深圳）HC较多，投递成功概率更大哦！
划重点：投递方式
(以下仅列举部分岗位，具体可以看大疆创新校招官网)
客户端开发工程师（研发部-深圳）
前端开发工程师（研发部-深圳）
测试工程师（研发部-深圳）
测试开发工程师（研发部-深圳）
如有意向投递，私戳楼主可获得【内推码】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4713daf0f0a0cea72e26c346c35ca0/" rel="bookmark">
			数据结构与算法--顺序表(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：誓则盟约
⏩收录专栏⏪：Java SE
🤡往期回顾🤡：Java SE--基本数据类型（详细讲解）
🌹🌹期待您的关注 🌹🌹
什么是顺序表？ 顺序表是一种线性表的数据结构。顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素。 顺序表的主要特点： 逻辑上相邻的元素在物理位置上也相邻。可以随机访问表中的任意元素，通过元素的位置序号可以在 O(1) 的时间复杂度内直接获取对应元素。插入和删除操作的效率相对较低。例如，在顺序表的中间位置插入一个元素，需要移动大量后续元素，时间复杂度为 O(n) ；删除操作同理。 顺序表的优点： 随机访问速度快，能够快速获取指定位置的元素。存储密度高，不需要额外的指针来链接元素。 顺序表的缺点： 长度固定，不易扩展。插入和删除操作可能涉及大量元素的移动，效率较低。 举个例子，如果有一个顺序表存储了学生的成绩 [85, 90, 78, 95, 88] ，如果要获取第三个学生的成绩，直接通过索引 2 就能快速得到 78 。但如果要在第二个位置插入一个新成绩 80 ，就需要将后面的元素 90, 78, 95, 88 依次向后移动一位，然后再插入 80 。
顺序表在很多程序设计中都有应用，比如简单的数组实现、一些对随机访问要求较高而插入删除操作较少的场景等，今天我们用java来简单实现一下顺序表。
构造方法： 首先，构造一个顺序表，需要int capacity 表示顺序表的内存大小(这里先传入一个值作为参数，后面内存不够用我们会有专门申请内存的方法)、int size表示表里面元素的个数、Object [] array 来命名这个顺序表，这时候一个最基本的顺序表就被构造出来了，以下是代码实现：
public class Linear_List&lt;E&gt; { private int capacity = 10; private int size=0; private Object [] array = new Object [capacity]; 添加方法： 要对顺序表array进行添加操作，需要传入两个参数 泛型 element 以及 int index，代表在index下标插入 泛型 element。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4713daf0f0a0cea72e26c346c35ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8614afb07b63191b17760b9791f3788f/" rel="bookmark">
			【AI人工智能】文心智能体，00后疯感工牌生成器，低代码工作流的简单应用以及图片快速响应解决方案，干货满满，不容错过哦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 文心智能体平台，开启新一轮活动，超级创造营持续百日活动。
在AI 浪潮席卷的今天，如雨后春笋般丛生的 AI 应用，昭告着时代风口显然已随之到来。
如何能把握住时代红利，占据风口，甚至打造新风向，成为了热点的话题。
为了能够帮助大家丝滑突破智能体创作瓶颈和开发卡点，助力大家打造属于自己的超级智能体， 共创 AI 应用新风向！超级智能体创造营应运而生！
超级智能体创造营旨在帮助有创意有能力的潜能开发者获取更多的资源和帮助，突破能力边界，实现超级智能体创意想法。
活动将百日持续开启，趣味赛题持续更新，只要你想，随时可以“参战”！
创作灵感 前阵子在百度热搜看到一个标题，00后职场疯感工牌火了。
然后就想到使用文心智能体低代码的方式去实现，毕竟需要图片。
百度直接搜索，会发现非常有意思的姓氏谐音梗和疯狂一句话。
姓陈，叫陈住气（谐音沉住气）
姓赵，叫赵不到（谐音找不到）
Prompt提示词 prompt的编写过程也是一波三折，前后改了不少版本。
并且prompt内容写的越来越多，刚开始测试效果还不错，等多人用就发现问题。
最后通过精简，达到现在线上这版还不错的效果。
可见，prompt提示词不是越多越好，重点是尽量表达清楚是干什么即可。
变量_input_的值就是用户输入的原始值
根据用户输入的【{_input_}】提取【姓氏】和【职位岗位】信息。 先根据【姓氏】输出姓氏谐音梗名字，比如：【周】姓，输出谐音梗名字【八宝粥】 再根据【职位岗位】输出一句疯狂的、幽默的、搞笑的，并且和【职位岗位】信息相关的一句话 最后组合输出疯感工牌信息，包含四部分：姓氏、谐音名字、职位岗位信息、一句话。 # 思考路径 姓氏谐音梗名字：搞笑、搞笑、再搞笑一点的名字，每次都不一样 职位岗位信息：原样输出用输入的职位岗位名字 一句话：疯狂、疯狂、再疯狂一点的句子，每次都不一样 # 内容校验 1、校验用户输入的内容必须合法合规 2、校验用户输入的内容不能包含政治、医疗等敏感信息 # 输出参考示例 ## 用户输入 梁，品牌部 ## 输出信息 姓名：薪尽自然梁同学 职位：品牌部 一句话：就这点钱，我很难帮你办事啊 prompt提示词最多时超过了2048个字符，后面精简到了300多个字符，效果反而更加好。
工作流 这里博主要说下，官方文档还是需要看下，非常有助于理解和开发，否则就会像博主一样，
一开始对工作流编排开发比较懵逼或者使用不恰当的情况，这个还被小小说了下，也非常多谢小伙伴的指正。
基本信息 详细信息可查看官方文档：https://agents.baidu.com/docs/intelligent-agent/visual-development/Kit/
使用工作流创建智能体，属于低代码创建智能体，工作流通过套件组合方式进行编排开发。
套件是可视化编排流程的构建块。它们由定义其功能的输入、输出和参数组成，为构建智能体提供了一种方便、直接的方法。
套件类型：
链： 用于编排主流程，智能体将遵循链的顺序执行后输出结果； 平台提供大模型链、分支链等多种类型，用于表达智能体的业务逻辑。
普通套件： 除链外所有套件均为普通套件，可以与对应的链连接，连接后将生效为链的基础属性。
完整套件 博主这里使用了大模型和工具套件，大模型链具有提示词和模型输入类型，工具链具有HTTP请求工具输入类型。
成语提示词模板 这个可以理解为零代码里的人物设定，具体需要模型做什么，尽量表达清晰明了。
这里要说的就是变量{input}，这个前面也说了，也有对应的官方文档说明。
这个变量刚开始时博主自己猜的，然后百度搜素看到的，其实官方文档就有说明，说明博主没认真看文章，
这个习惯不太好，说明博主有点偷懒了，哈哈哈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8614afb07b63191b17760b9791f3788f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/104/">«</a>
	<span class="pagination__item pagination__item--current">105/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/106/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>