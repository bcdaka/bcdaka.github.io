<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f51f0681055c4870a131fbc9304baa9/" rel="bookmark">
			最火前端 Web 组态软件 (可视化)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 随着物联网、大数据等技术高速发展，我们逐步向数字化、可视化的人工智能（AI）时代的方向不断迈进。智能时代是工业 4.0 时代，我国工业领域正努力从“制造”迈向“智造”的新跨越。
正文： 1.mxgraph： 介绍：开源免费，但是需要解决的问题很多，国内学习参考资料少。但是，可视化组态的实现基本都是借助于这个框架来实现的。
演示 demo：https://jgraph.github.io/mxgraph/javascript/examples/grapheditor/www/index.html
mxgraph 官方文档 API：http://jgraph.github.io/mxgraph/docs/js-api/files/model/mxCell-js.html
最大的交流社区：https://forum.jgraph.com/tags/swimlane/index.html
交流社区 2：https://stackoverflow.com/questions/tagged/mxgraph
github：https://github.com/jgraph/mxgrap​
2. by组态： 介绍：BY组态软件,应用于能源电力、工业互联网、智能制造、原型设计等领域的大屏可视化、工艺流程监控、后台管理、手机平板多终端的"拖拽式"在线web组态开发平台
软件架构
· 开发语言：原生js，html，css
· 使用类库：jquery，layui，konva，echart
· 后台请求：Ajax，Http请求
· 实时数据：websocket技术
官网：http://www.hcy-soft.com
演示 demo：by组态[web组态插件]
效果：
功能清单
3.le5le-topology： 介绍：A diagram (topology, UML) framework uses canvas and typescript. 一个用 canvas+typescript 写的绘图【核心库，不依赖框架】（微服务架构图、拓扑图、流程图、类图等 ULM 图，动画、视频支持）。本框架目前已经实现了拖拽、缩放、旋转、自定义属性等基础操作，开发者只用关心图表绘画实现即可。其次，流畅、高性能 - 使用 canvas 和多个场景离屏，操作过程流畅；完全不用担心 SVG 方式 dom 元素过多，性能高效。其三，自带部分动画效果，能满足基本的需求。使用 TypeScript 语言。chrome、firefox、ie11 等浏览器是没有问题的。IE9 以下版本没有测试，仅仅是绘图引擎，只需要支持 canvas+html5 标准即可
演示 demo：http://topology.le5le.com/
github：https://github.com/le5le-com/topology
gitee：https://gitee.com/mirrors/topology
4.draw.io 介绍：和 mxgraph 相比，在其基础上加了一些东西，更加完善。但是都是出自同一家公司之手。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f51f0681055c4870a131fbc9304baa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bacfa7bfe6fc816c21ba769ad4ce9ef4/" rel="bookmark">
			【C&#43;&#43;学习】哈希表的底层实现及其在unordered_set与unordered_map中的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. unordered系列关联式容器1.1 unordered_map1.2 unordered_set1.3.底层结构 2.哈希2.1哈希概念2.2哈希冲突2.3 哈希函数2.4 哈希冲突解决2.4.1闭散列2.4.1开散列2.5开散列与闭散列比较 3.哈希的模拟实现1. 模板参数列表2. 迭代器的实现3. 增加通过key获取value操作4. 哈希实现总代码： 4.用实现的哈希封装unordered_map与unordered_set前的模板参数的梳理及相关联系的梳理5.unordered_map的封装实现6.unordered_set的封装实现 🎉个人名片： 🐼作者简介：一名乐于分享在学习道路上收获的大二在校生
🙈个人主页🎉：GOTXX
🐼个人WeChat：ILXOXVJE
🐼本文由GOTXX原创，首发CSDN🎉🎉🎉
🐵系列专栏：零基础学习C语言----- 数据结构的学习之路----C++的学习之路
🐓每日一句：如果没有特别幸运，那就请特别努力！🎉🎉🎉
————————————————
文章简介：
本篇博文主要会涉及到STL关联式容器，unordered系列关联式容器，unordered_set和unordered_map的底层数据结构，哈希表的底层及迭代器实现，以及在其上对unordered_set****和unordered_map的封装。
1. unordered系列关联式容器 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到 l o g 2 N log_2 N log2​N，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，分别为：unordered_map与unordered_set和unordered_multimap与unordered_multiset 这四个容器，他们与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同。
unordered_map和unordered_set与map与set类似，map与set是有序的，但是unordered系列都不是有序的，但是也不允许出现重复值。unordered_multimap和unordered_multiset与unordered_map和unordered_set类似，unordered_map和unordered_set不允许重复值出现，但是multi系列是允许重复值出现的。只要是前缀带了unordered的就是无序，后缀带了multi的就是允许键值重复。他们在使用方面上与set与map非常类似，这里不作详解。 1.1 unordered_map unordered_map的文档介绍链接: link
文档说明：
unordered_map是存储&lt;key, value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部,unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。unordered_maps实现了直接访问操作符(operator[ ])，它允许使用key作为参数直接访问value。它的迭代器至少是前向迭代器。 1.2 unordered_set unordered_mset的文档介绍链接: link
1.3.底层结构 STL关联式容器中：
set和map的底层数据结构为红黑树，因为map和set要求是自动排序的，红黑树能够实现这一功能，并且各个操作的时间复杂度都较低，而unordered_set和unordered_map的底层数据结构为哈希表，查找时间复杂度为常数级。
2.哈希 2.1哈希概念 顺序结构以及平衡树中，元素 关键码 与其 存储位置 之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O( l o g 2 N log_2 N log2​N)，搜索的效率取决于搜索过程中元素的比较次数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bacfa7bfe6fc816c21ba769ad4ce9ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337cd48104cc982df3141ac410f5d24f/" rel="bookmark">
			【MySQL】跟着示例学 SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面所有示例均来自 SQL之母 - SQL自学网站
-- 查询所有学生 -- 请编写 SQL 查询语句，从名为 `student` 的数据表中查询出所有学生的信息。 select * from student; -- 查询学生的姓名和年龄 -- 请编写一条 SQL 查询语句，从名为 `student` 的数据表中选择出所有学生的姓名（name）和年龄（age）信息。 select name, age from student; -- 查询 - 别名 -- 请编写一条 SQL 查询语句，从名为 `student` 的数据表中选择出所有学生的姓名（name）和年龄（age）信息，并为它们取别名为 `学生姓名` 和 `学生年龄`。 select name as 学生姓名, age as 学生年龄 from student; -- 查询 - 常量和运算 -- 请编写一条 SQL 查询语句，从名为`student`的数据表中选择出所有学生的姓名（name）和分数（score），并且额外计算出分数的 2 倍（double_score）。 select name, score, 2 * score as double_score from student; -- 条件查询 - where -- 请编写一条 SQL 查询语句，从名为`student` 的数据表中选择出所有学生的姓名（name）和成绩（score），要求学生姓名为 '鱼皮'。 select name, score from student where name = '鱼皮' -- 条件查询 - 运算符 -- 请编写一条 SQL 查询语句，从名为 `student` 的数据表中选择出所有学生的姓名（name）和年龄（age），要求学生姓名不等于 '热dog' 。 select name, age from student where name !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337cd48104cc982df3141ac410f5d24f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d726abd5b88b2d1eb291d126819984c8/" rel="bookmark">
			【数据仓库】血缘关系分析工具适用场景、常见产品、功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		血缘关系分析工具是用于跟踪数据在系统中的流动和转换过程，帮助用户理解数据的来源、去向以及数据之间的关系。以下是关于血缘关系分析工具的详细介绍：
适用场景： 数据治理和合规性： 帮助组织跟踪敏感数据的流动，确保数据的合规性和安全性，以满足监管要求。数据质量管理： 通过跟踪数据的血缘关系，识别数据质量问题的根源，帮助改进数据质量和准确性。数据仓库和数据湖管理： 管理大型数据仓库或数据湖中的数据流动，帮助优化数据存储和查询性能。数据分析和洞察： 了解数据在分析过程中的转换和处理过程，帮助分析师理解数据的真实含义和价值。 常见产品： Apache Atlas： 一个开源的数据治理和元数据管理平台，提供了丰富的血缘关系分析功能，支持Hadoop生态系统和其他数据存储系统。Informatica Enterprise Data Catalog： 提供了全面的数据目录和元数据管理功能，包括血缘关系分析、数据发现和数据分级等。Collibra Data Governance Center： 一个企业级的数据治理平台，提供了血缘关系分析、数据地图和数据资产管理等功能。Waterline Data： 提供了自动化的数据发现和血缘关系分析功能，帮助用户理解数据的流动和关系。IBM InfoSphere Information Governance Catalog： 提供了全面的数据治理和元数据管理功能，包括血缘关系分析、数据血缘可视化和数据血缘查询等。 功能介绍： 血缘关系跟踪： 跟踪数据在系统中的流动和转换过程，记录数据的来源、去向以及数据之间的关系。数据血缘可视化： 提供直观的图形界面，展示数据的血缘关系，帮助用户理解数据的流动和关系。血缘关系查询： 支持灵活的查询功能，帮助用户快速定位数据的血缘关系，解决数据相关的问题。数据血缘分析： 分析数据的血缘关系，识别数据流动中的瓶颈和风险，帮助优化数据流程和数据管理策略。 举例说明：一家金融机构使用血缘关系分析工具来管理其数据湖中的数据流动。他们使用Apache Atlas来跟踪数据的血缘关系，包括交易数据的来源、数据处理过程以及最终的数据存储位置。通过血缘关系分析，他们能够及时发现数据质量问题和数据安全风险，确保数据的可靠性和合规性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44f0e6ec3ed4da2877de8cf6f2782e1/" rel="bookmark">
			AIGC还是二刺猿会玩：捏娃社区爆火，有脑洞就能当同人大佬
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		衡宇 西风 发自 凹非寺
量子位 | 公众号 QbitAI 原来现在的二刺猿都是这样玩的——
AIGC辅助下，0绘画基础也能轻松捏崽展开幻想，没有喜欢的角色粮，根本没在怕的！
青山刚昌28年没有让《名侦探柯南》新兰党如愿，这就速速安排俩人结婚：
《鬼灭之刃》《间谍过家家》《咒术回战》……自己动手丰衣足食：
好家伙，这个名为捏Ta的“游戏”，让二刺猿们玩嗨了：有人去年一年用它捏了几百个自己的娃（震惊脸）。
打听了一圈，它不仅是个小程序，更是个AI驱动的UGC共创社区，平均每次活动都有数万次的UGC投稿。
重度二次元人士对它认可度很高，而且背后创始人也是个老二刺猿了（doge）。
穿越进幻想世界 说回捏Ta，它的主要功能很聚焦，就是捏图。
因为用上了AIGC能力，还有现成提示词供人选择，所以哪怕是画画小白+Prompt小白，也能轻轻松松秒秒钟把脑海里的二次元娃捏出来（而且还不OOC）。
而且可较好地保持角色一致性，覆盖了角色方方面面的细节特征，所以捏出来的图可用来自制连环画：
甚至还能打造一整个家族的故事：
只要脑洞够大，啥都能捏出来：
至于具体怎么操作，总的来说有文字捏、图片捏、CP图三种捏法。
还有上百种角色、上百种风格以及“魔咒词典”里各种设定可以挑选，选中的不同“魔咒”都会像程序员的编码器一样高亮区分。
从我们的体验效果来看，控制性强如可爱的弥豆子的肱二头肌：
图片捏，可以选择上传手机相册里的图片也可以选择此前生成的图片进行“二创”，可调节捏的力度。同文字捏一样可以自己设计prompt，也可以直接挑选。
CP图，需要分别描述两个角色，而且还有CP模版可选择。
让心中CP牵手成功不是问题：
好的脑洞当然不满足于同人创作，自定义自己的专属原创角色——捏宝也行，然后就可以在捏图中捏自己的宝宝，俗称“养娃”：
如果你什么灵感都没有，建议重点体验“奇旅”的神奇玩法，玩家可以选择已有角色或是自己创造的角色作为“探员”，体验剧情故事，培养个性人设。
（椰树就是咱自己起名、自己捏的专属探员）
简单来说，奇旅玩法就是系统描述剧情，玩家根据剧情捏对应的图，角色还会给你评价：
把图和剧情文字搭配起来，一个属于你和你的捏宝的连环漫画就诞生了。
敲黑板！从角色到台词，到剧情，再到最后的生图，整个奇旅全都是AIGC的功劳。
根据八卦来的消息，捏Ta背后基于Stable Diffusion开源框架，同时将基础模型重新训练，持续微调对齐迭代——团队也透露，之后会推出一个开源二次元模型。
此外，模型使用了多个专家微调网络的MoE来固定角色，而不仅仅是使用一张参考图的特征提取。这样的角色建模覆盖了方方面面的角色细节特征，而不是一个单角度或者只是脸部的特征。
因此在细节更一致的前提下角色的表现力更强，更能做出跟一张参考图片上完全不一样的样子。
而这样的固定也不需要任何模型训练时间，有很强的批量能力，所以用户一年做500个角色也不是问题。
做“AI时代的米哈游+小红书” 一通体验，捏Ta的特点就呼之欲出了。
首先，它是一个踩着时代热点而生的AI创作社区。
利用底层AI大模型的多模态生成能力，为用户提供了新一代UGC创作的基础元素：角色和故事。
其次，它能带给用户个性化体验。
因为全流程的AIGC参与，加上储备的角色库和事件库，捏出的任何娃，都可以用捏图推进剧情，就像在异世界摆好了机位，只等按下快门。
好，接下来就是一个保留项目了——这个AI社区背后是什么样一支团队？
量子位获悉，捏Ta背后的公司在2022年12月成立，名叫看见概念，团队目前有15名成员。
创始人兼CEO是胡修涵，本人就是个二次元爱好者——故而他能get二次元用户自发玩梗的热情和对好的创作平台的渴望。“捏Ta”这个名字不仅生动形象让人手痒（想捏），还是日语“梗”（Neta）的读音。
胡修涵与看见概念的合伙人在Meta工作时相识。那时候，胡修涵担任技术组长负责Facebook、WhatsApp、Instagram三个平台的视频相关全套技术方案，包括发布的内容工具、内容管理，以及版权数据分析、广告系统对接等等。在最早的Pix2Pix、StyleGAN时代，就成功将AI功能落入覆盖了全球十几亿人的创作者生态。
归国后，胡又在内容科技独角兽特赞工作过一段时间。
2022年年底，ChatGPT打响第一枪，胡修涵觉得这一波AI浪潮是一次对UGC生态带来核心影响的机会。
我们瞄准的可能是最大的一个机会，类似于“米哈游+小红书”的机会。
每个人都有自己的新的Avatar，在社区和其他人交换“标签”共创，这是原来虚拟人技术没有C端化时做不到的，即便能够设计角色，也无法让角色有自己的故事成长。
此外，看见概念团队还是有技术本钱在身上的。
团队成员深入参与过多个开源社区项目，参与开发ComfyUI插件生态、使用最多的SD安装镜像，也为AnimateDiff、二次元的最好的开源模型之一AIDXL、Chat凉宫春日等有所贡献。
这些项目不限于文生图，也包括动画、语言生成。
过往的技术积累，能够最大限度保障捏Ta背后的AI多模态技术不会掉队。
我们希望做的是用最小的成本同时能支持文字、语音、漫画、视频等多个方向的技术能力积累，同时获得大量真实的需求反馈。
与此同时，一直以来团队成员拥有的开源精神，也成为了目前捏Ta社区的基因。
胡修涵聊到：“二次元有很好内容协作基因，字幕组、动画组、鬼畜二创都是曾经的内容协作组织，对拥抱一个开放的共创环境至关重要。”
毕竟，“为爱发电”意味着能够尽可能降低人才和社区组织的成本。
“如果未来世界每个人一生都有几个AI伙伴，那我们希望它们是精彩的、有温度的、有记忆的。”胡修涵表示，团队希望的就是打造塑造AI伙伴的工具，让每个人的故事里有更多人生延展性。
“能够有一个在短暂的时间内体验到瞬息全宇宙的机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f881430f6ea537caa0ca82a543558fed/" rel="bookmark">
			VS2022配置C&#43;&#43; connector连接mysql(保姆级教学)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++连接MySQL数据库的方法介绍 C++连接数据库mysql一般来说有三种方式，一种是通过传统的C Connector，一种是用基于JDBC的充满面向对象思路的C++ Connector，还有一种则是通过ODBC。
C Connector这种大家应该都比较熟悉，很多C++的mysql入门视频都是使用这种方式连接mysql的，这种方式提供了底层的数据库操作接口，更接近数据库的原生操作，相比较高级接口，更自由地控制数据库的细节和流程，可能在执行速度和内存管理方面更高效一些，但是对于面向对象编程来说其实不算友好。
#include &lt;stdio.h&gt; #include &lt;mysql/mysql.h&gt; int main() { MYSQL *conn; MYSQL_RES *res; MYSQL_ROW row; conn = mysql_init(NULL); if (conn == NULL) { fprintf(stderr, "mysql_init failed\n"); return 1; } if (mysql_real_connect(conn, "localhost", "username", "password", "database_name", 0, NULL, 0) == NULL) { fprintf(stderr, "mysql_real_connect failed: %s\n", mysql_error(conn)); mysql_close(conn); return 1; } if (mysql_query(conn, "SELECT * FROM table_name")) { fprintf(stderr, "mysql_query failed: %s\n", mysql_error(conn)); mysql_close(conn); return 1; } res = mysql_store_result(conn); while ((row = mysql_fetch_row(res)) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f881430f6ea537caa0ca82a543558fed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784eb98b6609acde0053973f87097305/" rel="bookmark">
			【Java集合进阶】list常见的方法和五种遍历方式&amp;数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍬 博主介绍 👨‍🎓 博主介绍：大家好，我是 hacker-routing ，很高兴认识大家~ ✨主攻领域：【渗透领域】【应急响应】 【python】 【VulnHub靶场复现】【面试分析】 🎉点赞➕评论➕收藏 == 养成习惯（一键三连）😋 🎉欢迎关注💗一起学习👍一起讨论⭐️一起进步📝文末有彩蛋 🙏作者水平有限，欢迎各位大佬指点，相互学习进步！ 目录
list集合
list集合的特点：
list集合特有的方法：
list集合的遍历方式
hasNext()和next()方法分析
list五种遍历方式代码学习
五种遍历方式对比
数据结构（栈）
数据结构（队列）
数据结构（数组）
数据结构（链表）
总结
list集合 list集合的特点： 有序：存和取的元素顺序一致有索引：可以通过索引操作元素可重复：存储的元素可以重复 list集合特有的方法： list方法的使用：
package list; import org.w3c.dom.ls.LSInput; import java.util.ArrayList; import java.util.List; public class list_demon1 { public static void main(String[] args) { /* List系列集合独有的方法： void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 */ //1、创建一个list集合 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //2、添加元素 list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/784eb98b6609acde0053973f87097305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e9bcfd528269a029dc428126866e2c/" rel="bookmark">
			基于 Docker 搭建 RabbitMQ 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
一、集群分类 在RabbitMQ中，有不同的集群模式，包括普通模式、镜像模式和仲裁队列。每种模式具有不同的特点和应用场景。
1.1 普通模式 普通集群，也称为标准集群（classic cluster），具备以下特征：
在集群的各个节点之间共享部分数据，包括交换机和队列的元信息，但不包括队列中的消息。当访问集群中的某个节点时，如果队列不在该节点上，请求会从数据所在节点传递到当前节点并返回响应。如果队列所在节点宕机，队列中的消息将会丢失。 这种模式适用于一些不需要消息高可用性的场景，或者对于消息丢失不是很敏感的应用。
1.2 镜像模式 镜像集群，本质上是一种主从模式，具备以下特征：
交换机、队列以及队列中的消息会在集群的各个节点之间进行同步备份。创建队列的节点被称为该队列的主节点，而备份节点被称为该队列的镜像节点。一个队列的主节点也可能是另一个队列的镜像节点，这样可以实现主节点的复用。所有的操作都是由主节点执行，然后同步给镜像节点，确保数据的一致性。如果主节点宕机，镜像节点将会接替成为新的主节点，确保高可用性。 这种模式适用于需要消息高可用性的应用场景，因为数据会在主节点和镜像节点之间进行同步备份，即使主节点宕机，数据仍然可用。
1.3 仲裁队列 仲裁队列是 RabbitMQ 3.8 版本以后引入的新功能，用来替代镜像队列，具备以下特征：
仲裁队列同样采用主从模式，支持主从数据同步。仲裁队列的配置非常简单，没有复杂的设置和配置项。主从数据同步基于Raft协议，实现强一致性，确保数据的可靠性和一致性。 仲裁队列是一种更现代化和可靠的集群模式，适用于要求高可用性和数据强一致性的应用场景。
二、普通集群 2.1 目标集群 下面，我将详细描述如何设置普通模式集群。在本示例中，计划在 Docker 容器上部署一个由3个节点组成的RabbitMQ集群。每个节点都具有特定的主机名和端口设置，如下所示：
主机名控制台端口（HTTP）AMQP 通信端口mq18081 —&gt; 156728071 —&gt; 5672mq28082 —&gt; 156728072 —&gt; 5672mq38083 —&gt; 156728073 —&gt; 5672 每个节点的标识默认为：rabbit@[主机名]，因此，上述三个节点的名称分别为：
rabbit@mq1rabbit@mq2rabbit@mq3 在接下来的步骤中，我将介绍如何在 Docker 容器中配置和启动这三个节点，从而创建一个 RabbitMQ 集群。这将使它们能够协同工作，共享队列和数据。
2.2 获取 Erlang Cookie RabbitMQ 底层依赖于 Erlang，Erlang 虚拟机是一种面向分布式系统的编程语言，它默认支持集群模式。在集群模式中，每个 RabbitMQ 节点使用一个称为Erlang cookie的共享秘钥来确定它们是否允许相互通信。
为了使两个节点能够互相通信，它们必须具有相同的共享秘密，即Erlang cookie。Cookie只是一个包含最多255个字母数字字符的字符串。每个集群节点必须具有相同的cookie，以确保它们可以相互通信。RabbitMQ实例之间也需要共享相同的cookie以实现相互通信。
首先，在之前启动的MQ容器中获取一个cookie值，然后将其用作集群的cookie。执行以下命令来获取cookie值：
docker exec -it mq cat /var/lib/rabbitmq/.erlang.cookie 执行此命令后，将获得一个类似下面的Erlang cookie值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e9bcfd528269a029dc428126866e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b55d70c3e4ef91f09ca4e935cf75f5/" rel="bookmark">
			基于Spark的淘宝数据分析学习案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​cx​​​​​​​https://dblab.xmu.edu.cn/blog/3525/ 参考地址​​​​​​​
一，下载数据集 数据集
数据集的介绍
数据集大小
二，数据预处理 使用python对数据进行预处理，由于数据量比较大，选取前一百万条数据
import csv import time print("执行") start_time = time.mktime(time.strptime('2017-11-25', '%Y-%m-%d')) end_time = time.mktime(time.strptime('2017-12-03', '%Y-%m-%d')) i = 0 with open("D:\\UserBehavior.csv\\UserBehavior.csv", 'r') as fr: reader = csv.reader(fr) for row in reader: if row[3] != "pv": if start_time &lt; int(row[4]) &lt; end_time: str_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(int(row[4]))) info = [row[0], row[1], row[3], str_time] i += 1 if i &gt; 10000: break with open("D:\\UserBehavior.csv\\processed2.csv", "a+", newline='') as fw: writer = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b55d70c3e4ef91f09ca4e935cf75f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a4d53efd63d08f7d30408e384838aeb/" rel="bookmark">
			前端同学必备：教你如何安装、使用Chrome的vue-devtools插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I. 介绍vue-devtools插件 Vue-devtools是一个Chrome浏览器插件，它是一个浏览器调试工具，用于开发Vue.js应用程序。它可以用于Vue.js应用程序的调试，可以更好地了解应用程序的结构和状态，以及帮助快速修复代码错误。
Vue-devtools插件的作用和优势如下：
1. 调试Vue.js应用程序：Vue-devtools是一个强大的调试工具，可以帮助开发人员正确地调试应用程序并快速找到问题所在。
2. 明确了解应用程序的状态和结构：Vue-devtools插件可以帮助开发人员更好地了解应用程序的运行状态和架构。
3. 查看和更改Vue.js应用程序的数据和状态：可以使用该插件来实时更改Vue.js应用程序的数据和状态，以确保应用程序正常运行。
4. 易于安装和使用：Vue-devtools插件非常易于安装和使用，使它成为任何级别的开发人员的最佳选择。
为什么前端开发人员需要使用它？
Vue-devtools插件对于前端开发人员来说是非常有用的，它可以帮助开发人员更轻松地调试和开发Vue.js应用程序。Vue-devtools插件提供了大量的功能，可以帮助开发人员更快地修复代码错误，并更好地了解应用程序的结构和状态。此外，它还提供了数据状态、调试、面板管理等许多功能。这些功能使Vue-devtools成为许多前端开发人员最喜欢的工具之一。
II. 安装vue-devtools插件 Vue-devtools是一个Chrome浏览器的扩展程序，如果您使用的是Chrome浏览器，则可以通过官方Chrome商店下载和安装该扩展程序。要安装vue-devtools插件，需要满足以下前提条件：
1. 使用Chrome浏览器：vue-devtools插件只能在Chrome浏览器中使用。
2. 安装最新版本的Chrome浏览器：确保您使用的是最新版本，以免插件与浏览器不兼容。
3. 安装Vue.js：确保您已经安装了Vue.js，因为该插件只能用于Vue.js应用程序。
安装步骤及部署方式如下：
1. 打开Chrome浏览器；
2. 在Chrome浏览器的地址栏中输入: https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd，并访问该网址；
3. 点击"添加到Chrome"，确认安装提示窗口；
4. 等待一段时间，安装完成后，您可以在Chrome浏览器的地址栏右侧看到vue-devtools插件图标。
注： 如果是在Chrome外部浏览器中开发，可以使用Electron自带的DevTools即可debug Vue.js应用程序。
总之，vue-devtools是一款非常实用的Chrome插件，采用上述简单步骤安装即可在Chrome浏览器中快速地实时调试和查看Vue.js应用程序的状态和结构。通过该插件，您可以更好地了解应用程序的结构和状态，并轻松检查和更正代码错误。
III. 使用vue-devtools插件 vue-devtools是一款非常实用的Chrome浏览器插件，它可以用于开发Vue.js应用程序并提供了丰富的功能，例如导航Vue组件树和数据状态、研究Vuex状态管理器、调试Vue组件等等。以下是关于使用vue-devtools插件的详细说明：
1. 在Chrome中如何打开vue-devtools插件
要使用vue-devtools插件，在Chrome浏览器中首先需要打开该插件。您可以使用以下步骤在Chrome中打开vue-devtools插件：
- 点击浏览器窗口右上角的vue-devtools插件图标；
- 这会打开vue-devtools插件窗口；
- 在这里，您可以导航Vue组件树和数据状态，并研究Vuex状态管理器。
2. 导航Vue组件树和数据状态
vue-devtools插件窗口中最重要的功能之一是“Components”面板，该面板显示所有Vue组件的列表。您可以使用该面板导航Vue组件树和数据状态，并且可以定位代码错误，注入虚拟事件。例如，您可以显示或隐藏某些组件、查看组件的props和state、获取组件的实时状态等。
3. 研究Vuex状态管理器
如果您的Vue.js应用程序使用了Vuex状态管理器，vue-devtools插件可以帮助您更好地了解您的代码。使用vue-devtools注入Vue应用程序并打开“vuex”选项卡，您可以快速查看和更改您的状态，查看mutation、actions、getters、modules等的内容，以及以可视化的方式查看状态更新。
4. 调试Vue组件
vue-devtools插件还可以帮助开发人员调试Vue.js应用程序中的组件。当您的应用程序出现问题时，您可以使用vue-devtools面板轻松地找到问题。您可以在Components选项卡中定位组件，并检查其状态和属性，或使用Events选项卡检查虚拟事件，以帮助确定问题所在。
总之，Vue-devtools插件提供了许多有用的功能，可以帮助您更快地开发、调试和测试Vue.js应用程序。您可以使用该插件导航Vue组件树和数据状态、研究Vuex状态管理器以及调试Vue组件，以便解决问题并提高应用程序的性能和质量。
IV. vue-devtools的高级用法 Vue-devtools插件提供了许多高级用法，例如导入和导出数据、添加自定义面板和支持其他浏览器的vue-devtools插件。以下是每个高级用法的详细说明：
1. 导入和导出数据
Vue-devtools插件可以轻松地导出任何Vue.js应用程序的状态和数据，以便在不同的环境中共享、存储或协作。您可以使用以下步骤导入和导出数据：
- 在vue-devtools面板上，点击“Settings”按钮；
- 选择“Advanced”选项卡，然后点击“Export”按钮来导出数据；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a4d53efd63d08f7d30408e384838aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c035a27423c770d11d3208466d967e0f/" rel="bookmark">
			flink1.18源码本地调试环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 源码本地调试环境搭建 1. 从github拉取源码创建本地项⽬ https://github.com/apache/flink.git 可以拉取github上官⽅代码 https://github.com/apache/flink.git GitHub - apache/flink: Apache Flink 2. 配置编译环境 ctrl+alt+shift+s （或菜单）打开项⽬结构，确保jdk版本为1.8，scala版本最好为2.12.73. 源码编译 跳过调试 4、准备运⾏环境 • 在项⽬根⽬录下，创建如下两个⽂件夹： 找到如下⼦模块，并展开如图 • 将上图中conf下的⽂件，拷⻉到项⽬根⽬录下创建的conf下 • 将上图中的lib下的jar包，拷⻉到项⽬根⽬录下创建的distlib下 5、编译中遇到的问题 5.1flink 1.18 源码编译 shader 19 编译 Flink Shaded：
进入 Flink 源码目录，并切换到相应的 Shaded 版本分支，例如 flink-shaded-193。执行 Maven 命令来编译 Flink Shaded 19 版本： mvn clean package -DskipTests
这将编译 Flink Shaded 19 并生成相应的构建产物 5.2 Failed to execute goal org.apache.maven.plugins:maven-checkstyle-plugin:3.1.2:check (validate) on project flink-runtime: You have 3 Checkstyle violations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c035a27423c770d11d3208466d967e0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d9c9e3590024b7faae6d050ceb5056/" rel="bookmark">
			波士顿房价预测案例（python scikit-learn）---多元线性回归(多角度实验分析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		波士顿房价预测案例（python scikit-learn）—多元线性回归(多角度实验分析) 这次实验，我们主要从以下几个方面介绍：
一、相关框架介绍 二、数据集介绍 三、实验结果-优化算法对比实验，数据标准化对比实验，正则化对比试验，多项式回归degree对比实验，岭回归alpha敏感度实验 一、相关框架介绍 Scikit-learn（全称：Simple and Efficient Tools for Machine Learning，意为“简单高效的机器学习工具”）是一个开源的Python机器学习库，它提供了简单而高效的工具，用于数据挖掘和数据分析。
Scikit-learn主要特点包括：丰富的算法库、易于使用、高效的性能、数据预处理和特征选择、模型评估和选择、可扩展性、社区支持。
二、数据集介绍 2.1数据集来源 波士顿房价数据集是一个著名的数据集，它在机器学习和统计分析领域中被广泛用于回归问题的实践和研究。这个数据集包含了美国马萨诸塞州波士顿郊区的房价信息，这些信息是由美国人口普查局收集的。
该数据集共包括507行数据，十三列特征，外加一列标签。
2.2数据集特征 数据集的特征：
CRIM: 城镇人均犯罪率 ZN: 占地面积超过25,000平方英尺的住宅用地比例
INDUS: 每个城镇非零售业务的比例 CHAS: 查尔斯河虚拟变量（如果是河道，则为1;否则为0）
NOX: 一氧化氮浓度（每千万份） RM: 每间住宅的平均房间数
AGE: 1940年以前建造的自住单位比例 DIS: 波士顿的五个就业中心加权距离
RAD: 径向高速公路的可达性指数 TAX: 每10,000美元的全额物业税率
PTRATIO: 城镇的学生与教师比例 B: 1000（Bk - 0.63）^ 2，其中Bk是城镇黑人的比例
LSTAT: 人口状况下降％ MEDV: 自有住房的中位数报价, 单位1000美元
三、实验结果-优化算法对比实验，数据标准化对比实验，正则化对比试验，多项式回归degree对比实验，岭回归alpha敏感度实验 3.1 优化算法对比实验 # 从 sklearn.datasets 导入波士顿房价数据读取器。 from sklearn.datasets import load_boston # 从读取房价数据存储在变量 boston 中。 boston = load_boston() # 输出数据描述。 from matplotlib import pyplot as plt from matplotlib import font_manager from matplotlib import pyplot as plt import numpy as np import matplotlib # 参数设置 import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d9c9e3590024b7faae6d050ceb5056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa4f6ad0147ff9035a462e397fa4a9b/" rel="bookmark">
			如何在本地搭建集成大语言模型Llama 2的聊天机器人并实现无公网IP远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 拉取相关的Docker镜像2. 运行Ollama 镜像3. 运行Chatbot Ollama镜像4. 本地访问5. 群晖安装Cpolar6. 配置公网地址7. 公网访问8. 固定公网地址 随着ChatGPT 和open Sora 的热度剧增,大语言模型时代,开启了AI新篇章,大语言模型的应用非常广泛，包括聊天机器人、智能客服、自动翻译、写作助手等。它们可以根据用户输入的文本生成相应的响应，提供个性化的建议和服务,目前大部分大语言模型的产品都是基于网络线上的,如果我们本地想自己部署一个自己的大语言模型,该如何操作呢,下面介绍一款可以在自己本地部署运行的大语言模型Llama 2 Llama 2是一款开源的大语言模型,其中训练的数据目前已经达到7B级别,在上下文长度为4K下的单轮与多轮对话中表现出色,部署运行Llama 2同时需要借助一个框架Ollama.
Ollama是一个强大的框架，设计用于在Docker容器中部署大型语言模型（LLM）。它的主要功能是简化在Docker容器内部署和管理LLM的过程。Ollama通过提供简单的安装指令，使用户能够轻松地在本地运行大型开源语言模型.
借助Ollama 框架可以很方便运行Llama2大语言模型,同时,为了方便与模型进行交互,还需要部署一个web交互 界面Chatbot-Ollama.
Chatbot-Ollama是一个基于Ollama框架的聊天机器人前端应用。它利用Ollama框架提供的接口和功能，将大型语言模型（LLM）集成到聊天机器人中，使其能够与用户进行交互，并提供各种聊天机器人服务。
Chatbot-Ollama 接入本地Ollama框架运行的Llama2大语言模型,使我们可以很轻松简便在本地创建一个聊天机器人.Chatbot-Ollama 同时也是基于docker本地部署的,本地部署,只能局限于本地访问,无法做到提供远程给其他人访问,下面我们还需要安装一个内网穿透工具cpolar,使得本地聊天机器人可以被远程访问.
Cpolar是一款强大的内网穿透软件，它能够在多个操作系统上无缝运行，包括Windows、MacOS和Linux，因此无论您使用哪种操作系统，都可以轻松将本地内网服务器的HTTP、HTTPS、TCP协议端口映射为公网地址端口，使得公网用户可以轻松访问您的内网服务，无需部署至公网服务器.
下面我们通过群晖Docker来演示如何结合上面介绍的技术来运行一个自己的本地聊天机器人并且发布到公网访问.本地部署,对设备配置要求高一些,如果想要拥有比较好的体验,可以使用高配置的服务器设备.
1. 拉取相关的Docker镜像 运行Llama 2需要借助Ollama镜像,对语言模型进行交互需要用到Chatbot-Ollama前端界面,所以我们需要拉取这两个docker镜像,本例群晖版本由于无法直接在群晖控制面板docker界面搜索下载镜像,所以采用命令行方式进行镜像下载,首先开启群晖ssh连接,然后使用工具通过ssh连接上群晖,分别执行下面docker命令 拉取
*拉取Ollama镜像命令
sudo docker pull ollama/ollama:latest *拉取Chatbot-Ollama镜像命令
sudo docker pull ghcr.io/ivanfioravanti/chatbot-ollama:main 拉取成功后,我们可以在Docker界面看到拉取的两个镜像,下面开始运行两个镜像,首先运行ollama
2. 运行Ollama 镜像 选中镜像,点击运行进入配置界面,名称无需设置,默认即可,然后点击下一步
输入外部访问的端口,和容器内部端口一致,填写11434即可,然后点击下一步
然后点击完成即可运行ollama
运行后,打开容器界面,可以看到运行的服务,下面开始下载运行Llama 2模型,点击选中ollama容器,点击操作
然后打开终端机,进入终端命令界面
然后选择左边新增一个bash命令界面
然后在bash命令界面,执行ollama run llama2命令,接着等待下载即可,最后出现success,表示下载运行Llama 2模型成功,下载完成后可以关闭掉窗口.这样ollama 容器启动,并运行Llama 2模型就成功了,下面运行chatbot-ollama镜像,配置前端交互界面
3. 运行Chatbot Ollama镜像 选中我们下载的镜像,点击运行,开始进行设置
名称可以默认,直接点击下一步
设置对外端口,本例设置3001,具体可以自己自定义,这个端口也是我们浏览器上web访问的端口
然后设置一个环境变量,该变量就是连接我们上面运行Ollama框架服务的地址,我们设置本地地址:http://群晖局域网IP:11434即可,设置完成点击下一步,然后直接点击完成即可,chatbot Ollama镜像就运行成功了,接下来我们进行本地访问.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fa4f6ad0147ff9035a462e397fa4a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53cc90cd13c7e1482c4ebfbf7eb6eb1/" rel="bookmark">
			网上商城购物系统设计与实现（Java&#43;Web&#43;SSM&#43;MySQL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1 绪论 1
1.1 研究背景 1
1.2 目的和意义 1
1.3 开发工具及技术 1
2 需求分析 3
2.1 功能需求分析 3
2.1.1 网站前台功能 3
2.1.2 网站后台功能 3
2.2 性能分析 3
2.3 系统用户用例图 4
3 系统设计 5
3.1 系统的总体设计 5
3.2 数据库的分析与设计 5
3.2.1数据库概念设计 6
3.2.2数据库物理结构 7
4 系统主要功能实现 11
4.1 系统注册页面实现 11
4.2 系统登录页面实现 12
4.3系统前台功能实现 14
4.3.1一级分类模块 14
4.3.2商品模块 16
4.3.3购物模块 22
4.3.4订单模块 24
4.3.5留言模块 26
4.4系统后台功能实现 27
4.4.1用户模块 27
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a53cc90cd13c7e1482c4ebfbf7eb6eb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dedc289a882cf1b43f044c5a80664542/" rel="bookmark">
			新人程序员必备在线工具推荐（cron、加解密、JSON、AI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员必备在线工具推荐 俗话说的好，工欲善其事必先利其器，下面我就来给大家分享一下我个人常用的工具。也欢迎大家在评论区分享自己喜欢的工具。✈️
1 在线cron表达式：cron 在日常开发中，我们难免会遇到一些定时任务的场景，这时基本就会用到cron表达式。
cron：Cron表达式是一种用于指定定时任务执行时间的字符串表达式，由6个字段组成，分别表示秒、分钟、小时、天数、月份和星期几 地址：https://www.bejson.com/othertools/cron
2 正则表达式：regexgenerate 对于匹配邮箱📮、手机号等场景，我们一般会用到正则。用于校验用户的输入是否合法，防止数据库存储不合法数据。
正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。 正则表达式可以在文本中查找、替换、提取和验证特定的模式。
工具地址：http://tool.chinaz.com/tools/regexgenerate
3 在线比对：diffchecker diffchecker可对文本内容、图片、文档、Excel、文件夹进行多维度对比。
工具地址：https://www.diffchecker.com/
4 格式转换：aconvert 我们构造数据时，比如要构造各种格式的图片，如果每次上网搜索下载未免太过繁琐，并且有些图片还可能收费。
aconvert：可以不仅可以支持各种图像转换，如：jpg、bmp、webp、gif等格式，还支持视频、音频以及文档之间转换，比如pdf转换为doc。保最关键的是该在线工具完全免费。 工具地址：https://www.aconvert.com/cn/image/
5 加解密平台：chacuo 企业开发中，不免会接触到各种编码（Base64、URLEncode…）、加解密（SM2、AES、DES、等）
chacuo提供了各类常见的编码和加解密，帮助我们在线实现加解密。 官网地址：http://tool.chacuo.net/cryptaes
6 JSON格式化：bejson 不管是前端后端，大部分程序员接触到最多的数据传输格式应该就是JSON。有时，我们从日志里拷贝出来的JSON没有进行美化，不方便我们查看。
bejson：可帮助我们在线美化，以及校验JSON是否合法。 官网地址：https://www.bejson.com/
7 grok表达式：grok GROK是一种采用组合多个预定义的正则表达式，用来匹配分割文本并映射到关键字的工具。通常用来对日志数据进行处理。
官网地址：https://www.5axxw.com/tools/v2/grok.html#google_vignette
8 工具箱 除了上面专业的几个工具，我们还可能涉及到其他场景，比如：查询Linux命令、加解密、生成二维码等。
toolnb 官网地址：https://www.toolnb.com/
toolhelper 官网地址：https://www.toolhelper.cn/
9 AI导航栏：biemoyu 作为‘猩’一代AI浪潮下的程序员，不拿AI帮忙干点活，属实有点说不过去。
biemoyu汇集了各类常用AI大模型地址，帮助我们一键跳转，直接使用。 官网地址：https://biemoyu.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5085d8a06394ac7779a359580f4268d/" rel="bookmark">
			【C语言】预处理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
上篇博客我们总结了编译与链接，有说过编译里第一步是预处理，那本篇博客将对预处理进行进一步的详细的总结
个人主页：小张同学zkf
若有问题 评论区见
感兴趣就关注一下吧
目录
1. 预定义符号
2. #define 定义常量
3. #define定义宏
4. 带有副作用的宏参数
5. 宏替换的规则
6. 宏和函数的对比
7. #和##
7.1 #运算符
7.2 ## 运算符
8. 命名约定
9. #undef
10. 命令行定义
11. 条件编译
12. 头文件的包含
12.1 头文件被包含的方式
12.1.1 本地文件包含
12.1.2 库文件包含
12.2 嵌套文件包含
13. 其他预处理指令
1. 预定义符号 C语言设置了一些预定义符号， 可以直接使用 ，预定义符号也是在 预处理期间 处理的。 __FILE__ // 进行编译的源文件 __LINE__ //文 件当前的行号 __DATE__ //文 件被编译的日期 __TIME__ //文 件被编译的时间 __STDC__ // 如果编译器遵循 ANSI C ，其值为 1 ，否则未定义 我们来看一下，在vs2022中是否遵循ANSI C（标准C）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5085d8a06394ac7779a359580f4268d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7127a1b9139aa2852b574ef858d69e/" rel="bookmark">
			【人工智能】保姆级波士顿房价预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验背景 波士顿房价预测是一个经典的机器学习任务，类似于程序员世界的“Hello World”。和大家对房价的普遍认知相同，波士顿地区的房价是由诸多因素影响的。该数据集统计了13种可能影响房价的因素和该类型房屋的均价，期望构建一个基于13个因素进行房价预测的模型，如 图1 所示。
图1：波士顿房价影响因素示意图 对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。
二、实验内容 2.1 假设空间 影响波士顿房价的因素：
feature_names = [ ‘CRIM’, ‘ZN’, ‘INDUS’, ‘CHAS’, ‘NOX’, ‘RM’,‘AGE’,‘DIS’, ‘RAD’, ‘TAX’, ‘PTRATIO’, ‘B’, ‘LSTAT’, ‘MEDV’ ]
假设多个影响房价的因素和房价之间是线性关系，可用线性方程表示
y i = x 1 w 1 + x 2 w 2 + ⋯ + x n w n + b y_{i}= x_{1}w_ {1}+ x_ {2}w_ {2}+\cdots+x_ {n}w_ {n}+b yi​=x1​w1​+x2​w2​+⋯+xn​wn​+b
y = ∑ i = 1 n x i w i + b y= \sum _ {i=1}^ {n}x_ {i} w_ {i} +b y=i=1∑n​xi​wi​+b
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d7127a1b9139aa2852b574ef858d69e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f447ba412040d61fbbb757f2e8b136f/" rel="bookmark">
			Java Web实验八：按照JSP Model2思想实现注册功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验八 按照JSP Model2思想实现注册功能
一、实验目的 1. 熟悉JavaBean的应用；
2. 熟悉MVC设计模式的原理，并能在实际案例中应用；
3. 熟悉JSP Model2模型。
二、实验内容
按照JSP Model2模型思想编写一个用户注册程序，浏览器的显示结果如图所示：
在上图所示的表单中填写用户信息进行注册，如果注册的信息不符合表单验证规则，那么当单击“注册”按钮后，程序会再次跳回到注册页面，提示注册信息错误。例如，用户填写注册信息时，如果两次填写的密码不一致，并且邮箱格式错误，那么当单击“注册”按钮后，页面的显示结果如下图所示：
重新填写用户信息，如果用户信息全部填写正确，当单击“注册”按钮后，页面会自动跳转到用户成功登录页面，并显示出用户信息，如下图所示：
提示实验步骤如下：
创建两个JSP页面，注册页面register.jsp和注册成功提示信息页面loginSuccess.jsp；负责处理用户注册的请求的Servlet类ControllerServlet；两个JavaBean类，封装注册表单信息的JavaBean类RegisterFormBean和封装用户信息的JavaBean类UserBean；一个访问模拟数据库的辅助类DBUtil，这些组件的关系如下图所示： 三、实验结果（源代码、运行截图）
ControllerServlet.java
package xxx; import javax.servlet.*; import javax.servlet.http.*; import java.io.IOException; import java.util.Arrays; import java.util.List; public class ControllerServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.sendRedirect("register.jsp"); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding("UTF-8"); String username = request.getParameter("username"); String password = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f447ba412040d61fbbb757f2e8b136f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49583b59bb3351385a12a0f26c88eef3/" rel="bookmark">
			八数码问题——A*算法的应用（A-Star）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 问题描述2 启发式搜索3 A*算法3.1 参考网址3.2 是什么3.3 为什么A*算法适用于八数码问题3.4 A* 算法的基本框架 4 A* 算法如何解决八数码问题4.1 八数码状态的存储4.2 启发式函数4.3 构造目标状态元素位置的字典4.4 在二维列表中查找目标元素4.5 A* 算法主体4.6 路径构造函数4.7 函数调用4.8 全部代码4.9 运行结果 5 拓展：八数码问题有无解的讨论5.1 逆序5.2 逆序奇偶性与可解性5.3 逆序不变性 1 问题描述 八数码问题是经典的启发式搜索问题，其目标是将一个3x3的九宫格中的数字1-8以及一个空格，按照规定的移动规则，通过移动操作，最终达到特定的顺序状态，通常是按照数字顺序排列，如下：
1 2 3
4 5 6
7 8 _
八数码问题的变种包括：
15 数码问题：与八数码类似，但是在4x4的九宫格中利用数字1-15及一个空格进行移动n 数码问题：可以扩展到更大规模，例如n×n的九宫格，其中包含数字1至n×n-1以及一个空格，玩家需要重新排列数字以达到特定的状态 2 启发式搜索 传统搜索算法通常不考虑启发信息，仅仅依赖于逐步尝试可能的方案，逐渐扩展搜索空间，直到找到解决方案或最优解，比如BFS、DFS等等。在大规模问题或者复杂问题中，这些传统搜索算法可能会因为搜索空间过大而导致效率低下启发式搜索是一种问题求解的方法，它结合了传统的搜索方法和一定的启发信息（heuristic information）来指导搜索方向。启发函数可以评估当前状态与目标状态的相似度，从而指导搜索方向。通过启发式函数的帮助，搜索可以更加偏向于朝着可能更接近最优解的方向前进，而不是盲目地扩展所有可能的搜索路径。 3 A*算法 3.1 参考网址 一个讲A*算法讲得很好的网站：
a-star
3.2 是什么 A*算法是一种启发式搜索算法，常用于寻找图中的最短路径或最优解。它结合了广度优先搜索和启发信息，在搜索过程中能够有效地减少搜索空间，从而提高搜索效率。
A* 算法的核心思想是综合考虑两个方面的信息：从起始节点到当前节点的实际代价（通常是已经走过的路径的代价），以及从当前节点到目标节点的估计代价（启发式函数）。这两方面的信息通过综合起来选择估计代价最小的节点进行搜索，朝着目标节点前进。
A*算法同时考虑了从起始节点到当前节点的实际代价，以及从当前节点到目标节点的估计代价（上图）
3.3 为什么A*算法适用于八数码问题 A* 算法适用于图搜索问题，本质上，八数码问题的每一种状态都可以看成是图中的一个节点，所以可以使用A* 算法求解在这里，从起始节点到当前节点的实际代价为从起始状态到当前状态的步骤数，而从当前节点到目标节点的估计代价我们使用当前状态到目标状态的曼哈顿距离来估计 在二维坐标系中，两点 (x1, y1) 和 (x2, y2) 之间的曼哈顿距离可以用以下公式表示： Manhattandistance = ∣x2−x1∣+∣y2−y1∣
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49583b59bb3351385a12a0f26c88eef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f09285930f62a125d2c5af09f19544b/" rel="bookmark">
			深度学习之详解常见梯度算法(概念、公式、原理、算法实现过程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、如何实现梯度下降？
二、梯度计算
三、常见的梯度公式及梯度算法
常见的梯度公式：
1.标量对向量的梯度：
2. 标量对矩阵的梯度：
3. 向量对标量的梯度：
常见梯度算法：
四、常见梯度算法实现 1、批量梯度下降算法实现函数
2、随机梯度下降算法实现函数
3、小批量梯度下降算法实现函数
4、Adam优化算法实现函数
5、简单应用案列demo
五、总结 博主介绍：✌专注于前后端、机器学习、人工智能应用领域开发的优质创作者、秉着互联网精神开源贡献精神，答疑解惑、坚持优质作品共享。本人是掘金/腾讯云/阿里云等平台优质作者、擅长前后端项目开发和毕业项目实战，深受全网粉丝喜爱与支持✌有需要可以联系作者我哦！
🍅文末三连哦🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
前言 梯度下降（Gradient Descent）是一种优化算法，用于寻找最小化损失函数（或成本函数）的参数值。在机器学习和深度学习的背景下，损失函数衡量了模型预测值与真实值之间的差异，而梯度下降则是用于更新模型的参数（例如权重和偏置），以最小化这个差异。
梯度下降的工作原理是，通过计算损失函数关于模型参数的梯度，然后沿着梯度的反方向（即最陡峭的下降方向）更新参数。这样，每次迭代都会使损失函数值减小（至少在局部上是这样的），从而逐渐接近损失函数的最小值。
具体来说，梯度下降算法的步骤通常如下：
初始化参数：随机初始化模型的参数（例如权重和偏置）。
计算梯度：使用当前参数计算损失函数关于这些参数的梯度。梯度是一个向量，指示了损失函数在每个参数上的局部变化率。
更新参数：将每个参数沿着梯度的反方向移动一小步，步长由学习率控制。学习率是一个超参数，决定了参数更新的幅度。
重复迭代：重复步骤2和3，直到满足某个停止条件（例如达到最大迭代次数、损失函数值足够小或梯度足够小）。
常见的梯度下降算法：
批量梯度下降（Batch Gradient Descent）：在每次迭代中使用整个数据集来计算梯度并更新参数。这种方法计算量大，但通常能保证收敛到全局最小值（对于凸损失函数）。
随机梯度下降（Stochastic Gradient Descent, SGD）：在每次迭代中只使用一个样本来计算梯度并更新参数。这种方法计算量小，收敛速度快，但可能会引入噪声，导致在最小值附近震荡。
小批量梯度下降（Mini-batch Gradient Descent）：在每次迭代中使用一小批样本来计算梯度并更新参数。这种方法是批量梯度下降和随机梯度下降的折中，结合了它们的优点。
梯度下降是机器学习和深度学习中最常用的优化算法之一，但它也有其局限性。例如，对于非凸损失函数，梯度下降可能只能找到局部最小值而不是全局最小值。此外，学习率的选择对算法的性能至关重要，过大或过小的学习率都可能导致算法表现不佳。因此，在实践中，常常使用更先进的优化算法，如动量（Momentum）、Adam、RMSprop等，它们是对梯度下降算法的改进和扩展。
一、如何实现梯度下降？ 深度学习中的自动求梯度，主要依赖于反向传播（Backpropagation）算法和计算图（Computational Graph）的概念。下面，我们将简要解释这两个概念如何共同作用以实现自动求梯度：
计算图：
深度学习模型中的计算可以看作是一系列的操作（如加法、乘法、激活函数等）的组合。这些操作可以表示为计算图中的节点，而节点之间的连接则代表数据依赖关系。每个节点都有一个或多个输入（来自其他节点的输出）和一个输出。
前向传播：
在前向传播过程中，数据从输入层流向输出层，经过计算图中的每个节点，并产生相应的输出。这些输出将作为后续节点的输入，直到最终得到模型的预测结果。
损失函数：
为了评估模型的预测结果与真实结果之间的差距，我们使用损失函数。损失函数是一个量化这种差距的指标，其目标是在训练过程中最小化。
反向传播：
反向传播是自动求梯度的关键步骤。它开始于损失函数节点，并沿着计算图反向传播。在反向传播过程中，我们计算每个节点的梯度，即损失函数对该节点输入的偏导数。这些梯度表示了如何调整节点的输入以最小化损失函数。
梯度下降：
有了每个参数的梯度后，我们就可以使用梯度下降（或其变种，如Adam、RMSprop等）来更新模型的参数。通过反复进行前向传播、计算损失、反向传播和参数更新，模型逐渐学会从输入数据中提取有用的特征，并产生准确的预测。
具体来说，反向传播利用链式法则来计算梯度。链式法则允许我们将复杂的复合函数的导数分解为更简单的子函数的导数的乘积。这样，我们可以从输出层开始，逐层计算梯度，直到达到输入层。
二、梯度计算 梯度下降的核心思想是通过迭代地调整模型参数的值，使得损失函数逐渐减小。具体来说，它的步骤如下：
初始化参数：选择一个初始的模型参数向量。计算梯度：计算损失函数对参数的梯度（或者称为导数），表示损失函数在当前参数值处的变化率。更新参数：沿着梯度的反方向，以一定的步长（学习率）更新参数的值，使得损失函数逐渐减小。迭代：重复步骤2和步骤3，直到满足终止条件（如达到最大迭代次数、损失函数收敛等）。 公式：
假设损失函数为，是待优化的模型参数向量。梯度下降的更新规则如下：
其中，是学习率，用来控制参数更新的步长；是损失函数对参数的梯度。
实现过程：
下面是梯度下降的实现过程的伪代码：
1. 初始化参数 theta
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f09285930f62a125d2c5af09f19544b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/440/">«</a>
	<span class="pagination__item pagination__item--current">441/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/442/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>