<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfc7558d7dc14d20488873eed8cbd2e/" rel="bookmark">
			解决Java --add-opens java.base/java.lang=ALL-UNNAMED的具体操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java --add-opens java.base/java.lang=ALL-UNNAMED 在Java 9及以后的版本中，引入了模块化系统，它允许将代码和资源划分为多个模块以提高代码的可维护性和安全性。然而，由于模块的隔离性，某些代码可能无法在模块之间进行正常的交互。这时，我们可以使用Java --add-opens选项来解决此类问题。
什么是--add-opens选项？ --add-opens是Java 9引入的一个命令行选项，它允许我们在模块之间打开指定的包，以便其他模块可以访问这些包中的类和成员。特别地，--add-opens选项用于在指定的模块中打开指定的包，并将其对所有模块的访问权限设置为“ALL-UNNAMED”，这意味着所有模块都可以访问这些包。
如何使用--add-opens选项？ 我们通过一个简单的代码示例来演示如何使用--add-opens选项。假设我们有两个模块：com.example.moduleA和com.example.moduleB，并且moduleA需要访问moduleB中的一个受限包com.example.moduleB.internal。在正常情况下，由于模块的隔离性，moduleA无法访问com.example.moduleB.internal包中的类和成员。
让我们先来创建moduleB模块。我们创建一个名为com.example.moduleB的文件夹，并在该文件夹中创建一个模块描述文件module-info.java，其内容如下：
module com.example.moduleB { exports com.example.moduleB; // 公开com.example.moduleB包 // 不公开com.example.moduleB.internal包 } 接下来，我们在com.example.moduleB包中创建一个简单的类MyClass，其代码如下：
package com.example.moduleB; public class MyClass { public void sayHello() { System.out.println("Hello from moduleB!"); } } 现在，我们创建moduleA模块。同样地，我们创建一个名为com.example.moduleA的文件夹，并在该文件夹中创建一个模块描述文件module-info.java，其内容如下：
module com.example.moduleA { // 不公开任何包 } 我们在com.example.moduleA模块中创建一个类Main，尝试访问moduleB模块中的MyClass类，其代码如下：
package com.example.moduleA; import com.example.moduleB.MyClass; public class Main { public static void main(String[] args) { MyClass myClass = new MyClass(); myClass.sayHello(); } } 如果我们尝试编译并运行上述代码，将会得到一个编译错误，提示无法访问com.example.moduleB.internal包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfc7558d7dc14d20488873eed8cbd2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802ed515c5698ac9be2242e77e54b509/" rel="bookmark">
			接收Kafka数据并消费至Hive表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Hive客户端方案 将Kafka中的数据消费到Hive可以通过以下简单而稳定的步骤来实现。这里假设的数据是以字符串格式存储在Kafka中的。
步骤： 创建Hive表：
使用Hive的DDL语句创建一个表，该表的结构应该与Kafka中的数据格式相匹配。例如，如果数据是JSON格式的字符串，你可以创建一个包含对应字段的表。 CREATE TABLE my_kafka_table ( id INT, name STRING, age INT ) STORED AS ORC; -- 你可以选择其他存储格式 编写Kafka消费者脚本：
使用Kafka的Java客户端（Kafka Consumer API）编写一个简单的消费者脚本。这个脚本从Kafka订阅消息，将消息解析为对应的字段，然后将字段值插入到Hive表中。 Properties properties = new Properties(); properties.setProperty("bootstrap.servers", "your.kafka.server:9092"); properties.setProperty("group.id", "your-consumer-group"); properties.setProperty("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); properties.setProperty("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(properties); consumer.subscribe(Collections.singletonList("your-kafka-topic")); HiveJdbcClient hiveJdbcClient = new HiveJdbcClient(); // 假设有一个Hive JDBC客户端 while (true) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord&lt;String, String&gt; record : records) { // 解析Kafka消息 String[] fields = record.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802ed515c5698ac9be2242e77e54b509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eee3fe1d940dc48e13cca505b4adb5f/" rel="bookmark">
			WEB 3D技术 three.js通过 GLTFLoader 导入并应用 gltf/glb 3D资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上文 WEB 3D技术 three.js 雾 基础使用讲解我们讲了雾的基本使用方法
但是 如果我们要做一个树林 一颗一颗树去加 那真的是要累死了
我们一定是在建模软件上 建模好这样的模型 然后将模型导入到场景中
官网中搜索 GLTFLoader
在我们日常WEB开发中 用的最多的3D格式 就是 GLTF
这里 我们需要一个glb 或者 gltf 文件
可以直接访问 https://www.webvrmodel.com/php/static/model-1666.html
或者下载我的资源
three.js GLTFLoader学习案例
首先 我们需要在代码中 带入 gltf加载器
//导入gltf加载器 import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js"; 然后 我们编写代码如下
import './style.css' import * as THREE from "three"; import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js"; //导入gltf加载器 import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js"; //创建场景 const scene = new THREE.Scene(); scene.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eee3fe1d940dc48e13cca505b4adb5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb6b4d7c2fd3e2fc0bc5315341363e2/" rel="bookmark">
			纯前端 文件预览方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是通过javaScript的方法实现文件预览的方法汇总：
1.使用HTML5的File API和Canvas来预览图片文件：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Image Preview&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="file" id="fileInput"&gt; &lt;img id="previewImage"&gt; &lt;script&gt; document.getElementById('fileInput').addEventListener('change', function() { var file = this.files[0]; var reader = new FileReader(); reader.onload = function(e) { document.getElementById('previewImage').src = e.target.result; }; reader.readAsDataURL(file); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.使用HTML5的File API和Video标签来预览视频文件：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Video Preview&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="file" id="fileInput"&gt; &lt;video id="previewVideo" controls&gt;&lt;/video&gt; &lt;script&gt; document.getElementById('fileInput').addEventListener('change', function() { var file = this.files[0]; var reader = new FileReader(); reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fb6b4d7c2fd3e2fc0bc5315341363e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a967fc775e3f7448657a12fe64739c2/" rel="bookmark">
			人工智能与医疗诊断：AI在医学影像诊断中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 人工智能(AI)已经成为医疗诊断领域的一个热门话题。随着数据量的增加和计算能力的提高，人工智能技术在医学影像诊断中的应用也逐渐成为可能。这篇文章将探讨人工智能在医学影像诊断中的应用，以及其背后的核心概念、算法原理、具体实例和未来发展趋势。
1.1 医疗诊断的挑战 医疗诊断面临的挑战主要有以下几点：
数据量巨大：医学影像数据量非常大，包括CT、MRI、X光等不同类型的图像。每年世界范围内产生的医学影像数据量达到了几十亿张图像。
专业知识：医学影像诊断需要医生具备丰富的专业知识和经验，这需要长期的培训和学习。
人工不可能完成：医学影像诊断需要人工检查大量的图像数据，这对医生来说是一项巨大的负担。
诊断不准确：由于医生的经验和专业知识有限，诊断可能不准确。
人工智能技术在医疗诊断领域的应用可以帮助解决以上问题，提高诊断准确率和效率。
1.2 AI在医学影像诊断中的应用 人工智能在医学影像诊断中的应用主要包括以下几个方面：
图像识别和分类：人工智能可以帮助自动识别和分类医学影像，提高诊断效率。
诊断支持：人工智能可以作为诊断支持工具，帮助医生更准确地诊断疾病。
预测分析：人工智能可以帮助预测患者疾病发展的趋势，为医生提供更好的治疗建议。
个性化治疗：人工智能可以根据患者的个人信息和医学影像数据，提供个性化的治疗方案。
在以下部分，我们将详细介绍人工智能在医学影像诊断中的应用，以及其背后的核心概念、算法原理、具体实例和未来发展趋势。
2.核心概念与联系 2.1 人工智能与机器学习 人工智能(AI)是一种计算机科学的分支，旨在模拟人类智能的行为和决策过程。机器学习(ML)是人工智能的一个子领域，旨在帮助计算机从数据中学习出模式和规律，以便进行自主决策。在医学影像诊断中，机器学习技术可以帮助计算机自动识别和分类医学影像，从而提高诊断效率和准确率。
2.2 医学影像诊断 医学影像诊断是一种使用医学影像技术来诊断疾病的方法。医学影像技术包括CT、MRI、X光等，可以帮助医生更好地了解患者的内脏结构和功能。医学影像诊断是医疗诊断的一个重要组成部分，人工智能技术在这一领域的应用可以帮助提高诊断效率和准确率。
2.3 人工智能与医学影像诊断的联系 人工智能与医学影像诊断的联系主要表现在以下几个方面：
图像处理：人工智能可以帮助进行医学影像的预处理、增强、减噪等操作，提高图像质量，便于医生进行诊断。
图像识别：人工智能可以帮助自动识别医学影像中的关键特征，如肿瘤、骨节等，提高诊断效率。
诊断支持：人工智能可以作为诊断支持工具，帮助医生更准确地诊断疾病。
预测分析：人工智能可以帮助预测患者疾病发展的趋势，为医生提供更好的治疗建议。
在以下部分，我们将详细介绍人工智能在医学影像诊断中的具体应用，以及其背后的算法原理和实例。
3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1 核心算法原理 在医学影像诊断中，人工智能主要采用机器学习技术，包括监督学习、无监督学习和强化学习等。这些技术可以帮助计算机从医学影像数据中学习出模式和规律，以便进行自主决策。
3.1.1 监督学习 监督学习是一种机器学习技术，需要预先标记的数据集。在医学影像诊断中，监督学习可以帮助计算机从标记的医学影像数据中学习出诊断规则，以便进行自主决策。常见的监督学习算法有逻辑回归、支持向量机、决策树等。
3.1.2 无监督学习 无监督学习是一种机器学习技术，不需要预先标记的数据集。在医学影像诊断中，无监督学习可以帮助计算机从未标记的医学影像数据中发现隐藏的模式和规律，以便进行自主决策。常见的无监督学习算法有聚类分析、主成分分析、自组织特征分析等。
3.1.3 强化学习 强化学习是一种机器学习技术，通过与环境的互动来学习。在医学影像诊断中，强化学习可以帮助计算机从医学影像数据中学习出诊断策略，以便进行自主决策。强化学习的核心思想是通过奖励和惩罚来指导计算机学习，以便最大化奖励。
3.2 具体操作步骤 在医学影像诊断中，人工智能的具体操作步骤如下：
数据收集：收集医学影像数据，包括CT、MRI、X光等。
数据预处理：对医学影像数据进行预处理，包括图像增强、减噪、分段等。
特征提取：从医学影像数据中提取特征，如边缘检测、纹理分析、形状描述等。
模型训练：根据不同的算法原理，训练模型，如逻辑回归、支持向量机、决策树等。
模型验证：验证模型的效果，通过交叉验证、留出验证等方法。
模型优化：根据验证结果，优化模型，如调整参数、增加特征等。
模型应用：将优化后的模型应用于实际医学影像诊断，提高诊断效率和准确率。
3.3 数学模型公式详细讲解 在医学影像诊断中，人工智能的数学模型公式主要包括以下几种：
3.3.1 逻辑回归 逻辑回归是一种分类模型，可以用来预测二分类问题。逻辑回归的目标是最大化似然函数，公式为：
$$ L(w) = \prod{i=1}^{n} p(yi|xi)^ {t{i}} (1-p(yi|xi))^{1-t_{i}} $$
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a967fc775e3f7448657a12fe64739c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47a020251da18af9c6685494086b6a8/" rel="bookmark">
			简单爬虫：东方财富网股票数据爬取(20231230)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标网站：https://quote.eastmoney.com/center/gridlist.html#hs_a_board
需求：将东方财富网行情中心不同板块的股票数据爬取下来
目标是将各个选项卡的股票数据全部爬取并以excel文件保存在本地。
查看网页源代码发现并没有目标数据，因此需要对网页进行抓包分析，查看哪个文件里包含目标数据，打开开发者模式（F12），找到目标文件
首先查看url，获取沪京深A股的第一页数据
# 沪深京A股 url = "https://62.push2.eastmoney.com/api/qt/clist/get?cb=jQuery1124007675389012158473_1703949729655&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=|0|0|0|web&amp;fid=f3&amp;fs=m:0+t:6,m:0+t:80,m:1+t:2,m:1+t:23,m:0+t:81+s:2048&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152&amp;_=1703949729656" 访问形式为GET
查看预览，发现需要爬取的数据在文件的‘data’中的'diff'里面，对应的文件数据如下图所示：
通过观察发现，该数据无法直接转换成json文件，需要删除上图中的红框内容，需要用正则表达式替换成空字符串
data = response.text # 找到开头到第一个'('的部分 left_data = re.search(r'^.*?(?=\()', data).group() # 将匹配到的内容加上'('替换成空字符串 data = re.sub(left_data + '\(', '', data) # 将结尾的');'替换成空字符串 data = re.sub('\);', '', data) # 用eval将data转换成字典 data = eval(data) 注意：这里在匹配开头内容时，如果使用下面的语句直接匹配到'jQuery1124007675389012158473_1703949729655('再进行替换的话会出现错误
left_data = re.search(r'^.*?\(', data).group() print(left_data) data = re.sub(left_data, '', data) 出现这个错误的原因是出现了圆括号但是没有转义，导致被当成捕获组，将括号转义（前面加上斜杠）即可解决。因此需要先匹配出'('之前的部分，在替代文本里拼接上'\('才能进行成功替换。
将目标数据转换成字典类型后，我们需要提取出其中data下面diff的内容，并通过定义一个字典来存储我们需要的数据，通过观察网页表头和文件代码对应关系，定义以下的字典：
df = data['data']['diff'] for index in df: dict = { "代码": index["f12"], "名称": index['f14'], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a47a020251da18af9c6685494086b6a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd194209730261864669050a1e0c29e/" rel="bookmark">
			Python face-recognition库，dlib库安装方法（附下载文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		face_recognition是一个基于dlib的Python库，用于实现人脸识别功能。它提供了简单易用的API，使得开发者可以方便地进行人脸识别的开发，而无需深入了解算法细节。
该库主要封装了dlib这个C++图形库，通过Python语言将其封装为一个简洁的人脸识别库。dlib是一个功能强大的计算机视觉库，提供了许多常用的图像处理和特征提取算法。face_recognition利用了dlib中的人脸识别算法，并将其简化为易于使用的函数和方法。
使用face_recognition库，你可以加载已知人脸图像并获取其编码（特征向量），加载待识别的人脸图像，比较已知人脸和待识别人脸的编码以找到匹配的人脸，添加新的人脸到已知人脸列表等操作。这些操作都可以通过简单的函数调用完成，大大简化了人脸识别功能的开发过程。
想要安装face-recognition库需要先安装dlib库，但是常用的pip安装通常都会报错，不能正常安装，这里我先大家介绍我的安装方法，我在python的3.8，3.9，3.10版本都试过，只要找到位置，都是可以成功安装的。
目录
1.安装dlib库
1.1下载dlib的whl文件
1.2安装dlib库（将下载的whl文件放到相应的位置）
1.2.1 位置一
1.2.2 位置二
1.2.3 报错
2.安装face-recognition库
1.安装dlib库 1.1下载dlib的whl文件 dlib-19.19.0-cp37-cp37m-win_amd64.whl
dlib-19.19.0-cp38-cp38-win_amd64.whl
dlib-19.22.99-cp39-cp39-win_amd64.whl
dlib-19.22.99-cp310-cp310-win_amd64.whl
文件名解释(以python 3.10版本dlib的whl文件为例)
(1)19.22.99-----版本号
(3)cp310-cp310-----Python版本-cp310就是Python3.10
(3)win_amd64-----64就是Win64位操作系统
下面这是我在网上找到的Python 3.7,3.8,3.9,3.10 版本的dlib库的whl文件，分享给大家。大家也可以自行在网上寻找下载 。
链接：https://pan.baidu.com/s/1GmVGISkjOSo15086fNdGuw?pwd=3bf7 提取码：3bf7
1.2安装dlib库（将下载的whl文件放到相应的位置） whl文件我存放的位置有两个，下面分别介绍。
1.2.1 位置一 放在c盘下面(以我自己的电脑命名为例，对应自己的电脑将whl文件放在那里)
之后，win+r 输入 cmd 输入
pip install dlib-19.22.99-cp310-cp30-win_amd64.whl
(将install后面换成自己下载对应的文件名)
这里如果报错的话就请移步位置二，要有耐心。
1.2.2 位置二 找到自己Python安装的位置，我的是放在D盘，Scripts文件夹下（我有一点忘了，是放在Scripts文件夹里面还是外面了，如果不成功的话，两个位置都是试一试，真的可以安装成功）
然后在Scripts后面输入cmd敲回车进入
pip install dlib-19.22.99-cp310-cp30-win_amd64.whl
(将install后面换成自己下载对应的文件名)
(这张是我跟我同学安装3.10版本的dlib库的照片)安装好dlib库之后就可以很快速的下载face-recognition库了。
1.2.3 报错 真正安装时会发生很多报错
这个报错就是因为whl文件没有放到正确的位置
这个报错可能是因为Python的镜像没有设置好(可能是，具体我也不清楚，不过可以试试，我就是这样解决的)
命令如下:
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
2.安装face-recognition库 pip install face-recognition
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdd194209730261864669050a1e0c29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f764888cea85678144f4a694133bf2/" rel="bookmark">
			（头哥）HBase的安装与简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第1关：Hbase数据库的安装 wget https://gitee.com/tianzhen2647/bash/raw/master/HBase%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/h1.sh chmod +x h1.sh ./h1.sh 第2关（略） 启动
hbase shell 建表 # 创建表 test create 'test', 'data' # 创建表 dept create 'dept', 'data' # 创建表 emp create 'emp', 'data' 第3关：添加数据、删除数据、删除表 启动
hbase shell 建表插数据
create 'mytable', 'data' put 'mytable', 'row1', 'data:1', 'zhangsan' put 'mytable', 'row2', 'data:2', 'zhangsanfeng' put 'mytable', 'row3', 'data:3', 'zhangwuji' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64641949db48afb1d6a545ebff48731/" rel="bookmark">
			AndroidStudio调用第三方so库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近公司设备换了新的触摸屏（为I2C接口），该触摸屏有个app，app中可以显示触摸屏固件的版本。我需要做的是在自己的app中读取到触摸屏固件版本。
反编译了apk，得到了源码，发现对方app是通过jni调用so库的方式获取到的触摸屏固件版本。所以我可以从apk中拿到这个第三方so库，然后用我们自己的app去调用so库中的方法得到固件版本。这里记录一下在实现过程中遇到的问题和解决方案。
1.导入so库 第三方so库的文件名为libegalaxapijni.so，将该文件放在libs目录下，如果没有该文件夹，需要手动创建。
并在app的build.gradle中设置
android { ... defaultConfig { ... ndk { // 设置支持的SO库架构 abiFilters 'armeabi-v7a' } } } 2.调用jni方法 创建一个工具类如图，用来调用jni方法
public class TouchScreenJNIUtil { // 加载库文件 static { System.loadLibrary("egalaxapijni"); } static native int getFWVersion(byte[] paramArrayOfbyte); } （1）找不到引用的so库问题解决方案1 当我调用TouchScreenJNIUtil.getFWVersion()时报错
System.err: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.example.logdemo-2/base.apk"],nativeLibraryDirectories=[/data/app/com.example.logdemo-2/lib/arm, /vendor/lib, /system/lib]]] couldn't find "libegalaxapijni.so" 这是由于找不到引用的so库导致的。 解决方法
android { ... defaultConfig { ... ndk { // 设置支持的SO库架构 abiFilters 'armeabi-v7a' } } sourceSets { main { jniLibs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64641949db48afb1d6a545ebff48731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca95b52fb5825f233e590e9ac22e4fcb/" rel="bookmark">
			一个项目，用十款数据库？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是豆小匠。
关于数据库，大学的时候只知道MySQL，学习深入点也就是用到了Redis、MongoDB等非关系型数据库。
然而，工作中用到的数据库实在太多，每种数据库都有自身的优势和局限性。所以在这里梳理下日常常用数据库和适用场景，走起！
1. 常用数据库 1.1. 关系型数据库 关系型数据库通常是业务型项目的主力数据库，原因以下：
方便业务建模，表的关系和业务之间的关联是类似的。数据一致性，关系型数据库一般支持ACID特性，可用于核心业务场景的数据持久化。 关系型数据库的基本单位是表，表与表之间通过键关联，比如学生表和班级表，可以通过班级ID，把学生和班级关联起来。
关系型数据库的经典代表：MySQL、Orcle、PostgreSQL、SQLite等。
1.2. 非关系型数据库 非关系型数据库其实只是一个比较笼统的叫法，实际分类下有非常多，这里只介绍键值对、文档、列式存储、图形结构等几种。
1.2.1. KV数据库 KV数据库以键值对的形式存储数据，常见底层数据结构实现是哈希表，读数据复杂度是O(1)。
keyvaluebeangoodmilkbad key-value存储的数据通常单个key-value就是一个条独立的数据，很方便水平扩展，可以根据key散列到不同的分片，且读的性能极好，因此常用于做缓存。
经典的代表有Redis、Memcached和LevelDB等。
1.2.2. 文档型数据库 文档型数据库的数据以文档的形式存储数据，每个文档类似一个JSON对象。
相比于KV存储，文档型数据库同样对水平扩展友好，且具有更好的查询性能，支持复杂查询，而KV存储几乎只通过key来读取数据。
经典的文档型数据库有MongoDB，CouchDB和Elasticsearch等。
1.2.3. 列式存储数据库 经典的列式存储数据库有HBase、Druid、ClickHouse等，不同列式数据库的底层实现差别挺大的，它们的共同点是按列存储。
比如说MySQL存一个学生信息，有学号和姓名等，这两个字段在同一行，存放也是在一起的；但是列式数据库会按列划分存储，把学号和姓名分开存储，相同的数据类型有利于进行数据压缩、聚合操作等。
下面是HBase的一条数据组成解析，一个Row Key（行键）下有多个Column Family（列族），列族下面有Column Qualifier（列限定符），最后会根据设置保存若干个版本，形成Timestamp/version: Cell Value的键值对。这里我们只需要知道不同的列族是分开存储的就行了。
1.2.4. 图数据库 图数据库的基本单元是点和边，经典的图数据库包括Neo4j、OrientDB、TigerGraph等。
简单来说点表示实体，而边则表示实体间的关系，组成一个整体后，可以形成知识图谱、社交网络、金融风控网络等。
比如存储了上图关系，可以直接查询关注了豆小匠Coding的用户：
MATCH (user:User {name: '豆小匠Coding'})&lt;-[:FOLLOWS]-(follower:User) RETURN follower.name 上述查询使用了 Neo4j 的图查询语言 Cypher。它首先通过 MATCH 子句找到名为豆小匠的用户节点 user，然后通过 -[:FOLLOWS]-&gt; 关系查找所有关注了该用户的节点 follower。最后，通过 RETURN 子句返回关注者的姓名。
2. 场景下的数据库 2.1. Demo项目 SQLite，一个轻量级的数据库，不需要独立服务器或者系统级别的配置，只需要一个文件，就可以存储数据库所有数据，适用于小型设备或者嵌入式系统等。
如果你只是做一个demo级别的项目，也可以使用SQLite，然后使用ORM框架来操作数据，后面切换MySQL也只需要修改数据库连接逻辑。
2.2. MySQL遇到瓶颈 如果是单机MySQL遭遇性能瓶颈，可以通过主从架构读写分离，堆机器的方式解决，另一个方向是增加缓存，如Redis等，减少打到物理存储的请求量。
如果是数据量太大，单表查询性能下降，可以考虑分库分表，但是分库分表在开发时需要考虑更多分布式事务、水平扩展等因素，对研发效率有影响。因此，这个时候可以考虑使用分布式数据库，如TiDB等。
2.3. 场景专用数据库 随着业务的复杂，我们会发现不同场景下对数据库的要求差异会很大：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca95b52fb5825f233e590e9ac22e4fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd8db8ca81c6488db04e8637bc1827a/" rel="bookmark">
			深入探索AIGC技术：原理、应用与未来发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入探索AIGC技术：原理、应用与未来发展
摘要：随着人工智能技术的飞速发展，AIGC（人工智能生成内容）已成为当今科技领域的前沿话题。本文将深入探讨AIGC的原理、技术应用以及未来发展趋势，并分析其对计算机科学和整个社会的影响。
一、AIGC的基本原理
AIGC，即人工智能生成内容，是一种基于人工智能技术的内容生成方式。它利用机器学习和深度学习技术，使计算机能够自主地生成具有创新性和个性化的内容。其核心在于通过训练模型，使计算机具备了从数据中学习和提取知识的能力，进而生成全新的、真实感强的内容。
在AIGC的生成过程中，数据预处理是第一步。这一步骤涉及数据清洗、特征提取等环节，旨在为模型训练提供高质量的数据集。预处理后的数据被输入到深度学习模型中进行训练，模型通过不断地调整参数，以更好地理解和预测数据的内在规律。经过大量数据的训练，模型逐渐学会了如何生成与数据集类似的、具有特定目标的内容。
二、AIGC的技术应用
AIGC技术的应用场景十分广泛，涵盖了自然语言处理、图像识别与生成、语音合成等多个领域。以下是几个具体的应用案例：
1.自然语言处理：自然语言处理是AIGC技术应用的重要领域之一。通过训练自然语言处理模型，计算机可以理解和生成人类语言，实现机器翻译、文本摘要、对话系统等功能。例如，在机器翻译方面，AIGC技术可以将一种语言的文本自动翻译成另一种语言，极大地提高了翻译的效率和准确性。
2.图像识别与生成：图像识别是AIGC技术的另一个关键应用领域。通过训练图像识别模型，计算机可以自动识别图片中的物体、场景等。此外，利用图像生成技术，我们可以利用AIGC生成逼真的图片、插画等视觉内容。这种技术可以应用于虚拟现实、游戏设计等领域。例如，在游戏设计中，AIGC技术可以根据游戏规则和角色设定等要求，自主生成具有高度真实感的图像和场景。
3.语音合成：语音合成是AIGC技术的又一重要应用方向。通过训练语音合成模型，计算机可以生成逼真的语音。这种技术可以应用于语音助手、虚拟主持人等领域，提供更加智能化的语音交互体验。例如，在智能客服领域，AIGC技术可以通过分析用户的语音输入，自动生成相应的回答或解决方案，提高了客户服务的质量和效率。
三、AIGC对计算机科学的影响
AIGC的发展对计算机科学产生了深远的影响。首先，AIGC技术推动了计算机科学的创新发展。由于AIGC技术需要大量的算法和模型支持，这促使计算机科学家不断探索新的算法和模型，推动了计算机科学领域的技术进步。其次，AIGC技术对计算机硬件设备提出了更高的要求。为了满足AIGC技术的计算需求，需要更强大的计算能力和存储设备支持，这促使计算机硬件设备不断升级和发展。最后，AIGC技术也对计算机科学的教育和人才培养产生了影响。随着AIGC技术的普及和应用，需要更多的专业人才来研究和应用这一技术，这促使计算机科学教育机构加强了对人工智能相关课程的教学和研究。
四、AIGC的未来发展趋势
随着技术的不断进步和应用场景的不断拓展，AIGC的发展前景十分广阔。未来，AIGC技术将朝着更加智能化、个性化和高效化的方向发展。同时，随着5G、物联网等新兴技术的普及和应用，AIGC技术的应用场景将进一步拓展，涵盖智能家居、智能交通等领域。此外，随着人工智能技术的不断发展，AIGC技术将与机器学习、计算机视觉等技术进一步融合，形成更加智能化的解决方案，为人类的生活和工作带来更加便捷和高效的服务。
在智能化方面，未来的AIGC技术将更加注重个性化和智能化。通过深度学习技术，模型将能够更好地理解用户的偏好和需求，并根据个体差异生成个性化的内容。此外，随着技术的不断发展，AIGC将逐渐具备自适应学习和进化的能力，能够根据不同的任务和场景进行自我调整和优化。
在应用场景方面，随着5G、物联网等新兴技术的普及和应用，AIGC技术的应用场景将进一步拓展。5G技术的低延迟和高带宽特性为AIGC提供了更好的实时性支持，使得AIGC在智能家居、智能交通等领域有着广泛的应用前景。物联网技术则使得万物互联成为可能，为AIGC提供了海量的数据和多样化的应用场景。
在技术与融合方面，未来的AIGC技术将与机器学习、计算机视觉等技术进一步融合。机器学习技术的发展将为AIGC提供更加强大的算法支持；计算机视觉技术的发展则将为AIGC提供更加丰富的视觉内容生成能力。这种技术与技术的融合将使得AIGIGC在各个领域的应用更加广泛和深入，能够更好地满足人类的多样化需求。
五、AIGC的挑战与问题
虽然AIGC技术带来了巨大的潜力和机会，但也伴随着一系列的挑战和问题。
1.数据隐私与伦理问题：AIGC技术需要大量的数据进行训练，这可能导致数据隐私的泄露。此外，如果使用不当，AIGC技术可能产生不准确或具有偏见的内容，对社会造成负面影响。例如，在生成图像或视频时，可能会出现假新闻或误导性信息，对人们的认知和判断造成干扰。因此，如何在利用数据的同时保护个人隐私，以及如何确保AIGC技术的公正性和准确性，是亟待解决的问题。
2.生成内容的可控性与可解释性：当前的AIGC技术生成的内容往往缺乏可解释性，即人们很难理解生成内容的内在逻辑和原因。这可能导致人们对生成的内容产生不信任感，甚至引发误解和偏见。因此，如何提高AIGC技术的可控性和可解释性，是AIGC技术发展中需要解决的重要问题。
3.技术与法律的冲突：随着AIGC技术的发展，可能会产生一些新的法律问题。例如，如果AIGC技术生成的文本、图像或音频被用于非法目的，那么应该如何追究法律责任？此外，对于AIGC技术生成的成果，其版权归属也是一个需要解决的问题。例如，如果AIGC技术生成的图像或视频侵犯了他人的版权，那么应该如何处理版权纠纷。
六、结论与展望
AIGC技术作为人工智能领域的前沿技术，其发展将对计算机科学和社会产生深远的影响。在面对AIGC技术的挑战和问题时，我们需要不断探索和研究，以充分发挥其潜力，并确保其可持续发展。同时，我们也需要关注其对社会和个人带来的影响，努力实现技术与社会的和谐共生。
未来，随着技术的不断进步和应用场景的不断拓展，AIGC技术将进一步发展壮大。我们期待着AIGC技术在更多领域的应用，为人类的生活和工作带来更多的便利和创新。同时，我们也希望在技术和伦理的平衡中，实现AIGC技术的可持续发展，为人类创造一个更加美好的未来。
七、结语
总的来说，AIGC技术正在改变我们的生活和工作方式，为我们提供了前所未有的机会和可能性。然而，随着技术的进步，我们也必须面对和解决一系列的挑战和问题。只有通过深入研究和探索，我们才能充分利用AIGC技术的潜力，为人类创造更加美好的未来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fcf9cd978386342662a27d6e2e421cb/" rel="bookmark">
			python写学生信息管理系统,python学生管理系统报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈基于python的学生信息管理系统参考文献，以及基于python的学生信息管理系统毕业论文，希望对各位有所帮助，不要忘了收藏本站喔。
目录
一、需求分析
1、学生管理系统应具备的功能
二、系统设计
1、系统功能结构
2、系统业务流程
三、系统开发必备工具 1、系统开发环境
2、项目目录结构
四、主函数设计
1、系统主界面运行效果图
2、主函数的业务流程
3、实现主函数
4、代码与结果演示及讲解
五、学生信息维护模式设计
1、录入学生信息功能
1、1实现录入学生信息功能
1、2业务流程
1、3具体实现 1、4代码与结果演示及讲解
2、删除学生信息功能
2、1实现删除学生信息功能
2、2业务流程
2、3具体实现 2、4代码与结果演示及讲解
3、修改学生信息功能
3、1实现学生信息修改功能
3、2业务流程
3、3具体实现
3、4代码与结果演示及讲解
六、查询/统计模块设计
1、查找学生信息功能
1、1实现查询学生信息功能
1、2业务流程
​ 1、3具体实现 1、4代码与结果演示及讲解
2、统计学生总人数
2、1实现统计学生总人数功能
2、2业务流程
2、3具体实现
2、4 代码与结果演示及讲解
3、显示所有学生信息功能
3、1实现显示所有学生信息功能
3、2业务流程
3、3具体实现
3、4代码与结果演示及讲解
七、排序模块设计
1、排序模块的设计
1、1实现按学生成绩排序功能
1、2业务流程
1、3具体实现
1、4代码与结果演示及讲解
八、总结
一、需求分析 1、学生管理系统应具备的功能 ①添加学生及成绩信息
②将学生信息保存到文件中
③修改和删除学生信息
④查询学生信息
⑤根据学生成绩进行排序
⑥统计学生的总分
二、系统设计 1、系统功能结构 1.1学生信息管理系统的7大模块
①录入学生信息模块（insert()）
②查找学生信息模块(search())
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fcf9cd978386342662a27d6e2e421cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771fae7c585ef29f6d2ada925b8cbe44/" rel="bookmark">
			Spark编程实验四：Spark Streaming编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、目的与要求
二、实验内容
三、实验步骤
1、利用Spark Streaming对三种类型的基本数据源的数据进行处理
2、利用Spark Streaming对Kafka高级数据源的数据进行处理
3、完成DStream的两种有状态转换操作
4、把DStream的数据输出保存到文本文件或MySQL数据库中
四、结果分析与实验体会
一、目的与要求 1、通过实验掌握Spark Streaming的基本编程方法；
2、熟悉利用Spark Streaming处理来自不同数据源的数据。
3、熟悉DStream的各种转换操作。
4、熟悉把DStream的数据输出保存到文本文件或MySQL数据库中。
二、实验内容 1、参照教材示例，利用Spark Streaming对三种类型的基本数据源的数据进行处理。 2、参照教材示例，完成kafka集群的配置，利用Spark Streaming对Kafka高级数据源的数据进行处理，注意topic为你的姓名全拼。
3、参照教材示例，完成DStream的两种有状态转换操作。
4、参照教材示例，完成把DStream的数据输出保存到文本文件或MySQL数据库中。
三、实验步骤 1、利用Spark Streaming对三种类型的基本数据源的数据进行处理 （1）文件流
首先打开第一个终端作为数据流终端，创建一个logfile目录：
[root@bigdata zhc]# cd /home/zhc/mycode/sparkstreaming [root@bigdata sparkstreaming]# mkdir logfile [root@bigdata sparkstreaming]# cd logfile 然后打开第二个终端作为流计算终端，在“/logfile/”目录下面新建一个py程序：
[root@bigdata logfile]# vim FileStreaming.py 输入如下代码：
#/home/zhc/mycode/sparkstreaming/logfile/FileStreaming.py from pyspark import SparkContext, SparkConf from pyspark.streaming import StreamingContext conf = SparkConf() conf.setAppName('TestDStream') conf.setMaster('local[2]') sc = SparkContext(conf = conf) ssc = StreamingContext(sc, 10) lines = ssc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/771fae7c585ef29f6d2ada925b8cbe44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ac9c6fa0728c49206a0ec74db2666e/" rel="bookmark">
			Flink 内容分享(一)：Fink原理、实战与性能优化(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
什么是Flink
Flink 部署
Flink快速应用
Flink分布式架构与核心组件
前言 Flink是一个分布式流处理引擎，可以处理实时数据流和批处理数据。它支持多种数据源和数据目的地，并且提供了丰富的流处理操作，如窗口化、聚合、过滤、连接和转换等。Flink还支持多种语言编写的应用程序，如Java、Scala和Python等。
Flink的核心特性包括：
高吞吐量和低延迟：Flink采用了基于内存的流处理方式，可以实现毫秒级别的低延迟和高吞吐量处理。
精确一次性处理（Exactly-once processing）：Flink的流式处理引擎可以确保每条数据仅被处理一次，从而避免数据重复和丢失等问题。
支持多种数据源和数据目的地：Flink能够从多种数据源中读取数据，并将处理结果输出到多种数据目的地中，如Kafka、Hadoop、Cassandra、ElasticSearch等。
灵活的数据分析方式：Flink支持多种数据分析方式，包括流式处理、窗口化聚合、流式SQL查询和机器学习等。
Flink的架构由JobManager和TaskManager两个组件组成。JobManager负责接收和调度应用程序，并协调TaskManager的执行。TaskManager负责执行具体的任务，如数据处理、窗口化、聚合等。
Flink的优化包括优化数据倾斜、调整并行度、合并算子、使用状态后端、调整内存管理等。这些优化手段可以提高Flink的性能和稳定性，保证Flink的高吞吐量和低延迟处理。
什么是Flink 大数据 大数据（Big Data）是指规模庞大、结构多样且速度快速增长的数据集合。这些数据集合通常包含传统数据库管理系统无法有效处理的数据，具有高度的复杂性和挑战性。大数据的主要特点包括三个维度：三V，即Volume（数据量大）、Variety（数据多样性）、Velocity（数据速度）。
数据量大（Volume）：大数据的最明显特征之一是其庞大的数据量。传统的数据处理方法和工具在处理这种规模的数据时可能会变得低效或不可行。
数据多样性（Variety）：大数据不仅包括结构化数据（如表格数据），还包括半结构化数据（如JSON、XML）和非结构化数据（如文本、图像、音频、视频等）。这些数据可能来自不同的源头和不同的格式。
数据速度快（Velocity）：大数据往往以高速率产生、流动和累积。这要求数据处理系统能够实时或近实时地处理数据，以便从中获取有价值的信息。
分布式计算 随着计算机技术的发展和数据规模的增大，单台计算机的处理能力和存储容量逐渐变得有限，无法满足大数据处理的要求。为了应对这一挑战，分布式计算应运而生，它利用多台计算机组成集群，将计算任务分割成多个子任务并在不同的计算节点上并行执行，从而提高计算效率和处理能力。
分布式计算的核心思想是将大问题划分为小问题，将任务分发给多个计算节点并行执行，最后将结果合并得到最终的解。这种方式有效地解决了单台计算机无法处理大规模数据和高并发计算的问题。同时，分布式计算还具有良好的可扩展性，可以根据数据量的增加灵活地扩展集群规模，以应对不断增长的数据挑战。
分布式计算的概念听起来很高深，其背后的思想却十分朴素，即分而治之，又称为分治法（Divide and Conquer）。分治法是一种解决问题的算法设计策略，它将一个问题分解成多个相同或相似的子问题，然后分别解决这些子问题，最后将子问题的解合并起来得到原问题的解。分治法常用于解决复杂问题，尤其是在大数据处理中，可以将大规模的数据集合分割成更小的部分，然后分别处理这些部分，最后合并结果。
在处理大数据问题时，可以使用分治法的思想来提高效率和可扩展性，以下是一些应用分治法处理大数据问题的示例：
MapReduce 模式：分治法的经典应用是 MapReduce 模式，它将大规模的数据集合分为多个小块，每个小块由不同的计算节点进行处理，然后将结果合并。这种方法适用于批处理任务，如数据清洗、转换、聚合等。
并行计算：将大规模的计算任务分解成多个小任务，分配给不同的计算节点并行处理，最后合并结果。这适用于需要大量计算的问题，如数值模拟、图算法等。
分布式排序：将大规模数据集合分割成多个部分，每个部分在不同的计算节点上进行排序，然后使用合并排序算法将这些有序部分合并为整体有序的数据集合。
分区和分片：在分布式存储系统中，可以将数据分区和分片存储在不同的节点上，通过分区键或哈希函数将数据分配到不同的存储节点上，从而实现数据的分布式存储和管理。
分布式机器学习：将大规模的机器学习任务分解成多个子任务，在分布式计算环境中分别进行训练，然后合并模型参数，如分布式随机梯度下降算法。
数据分割和合并：对于需要频繁访问的大数据集合，可以将数据分割成多个小块，每个小块存储在不同的存储节点上，然后根据需要进行合并，以减少数据访问的开销。
分治法在大数据处理中的应用不仅有助于提高处理效率，还可以充分利用分布式计算和存储资源，从而更好地应对大数据量和复杂性。然而，在应用分治法时需要考虑合适的数据分割策略、任务调度、结果合并等问题，以确保分治法的正确性和性能。
然而，分布式计算也带来了一些挑战，如数据一致性、通信开销、任务调度等问题，需要综合考虑各种因素来设计和优化分布式系统。同时，分布式计算也需要开发者具备分布式系统设计和调优的知识和技能，以确保系统的性能和稳定性。
分布式存储 当数据量巨大且单机存储已无法满足需求时，分布式存储和分布式文件系统成为处理大数据的关键技术。下面我会详细介绍分布式存储和分布式文件系统的概念、特点和常见的实现。
分布式存储： 分布式存储是将数据分散存储在多个节点上，以提供高容量、高性能、高可靠性和可扩展性的数据存储解决方案。每个节点都可以通过网络访问数据，并且多个节点协同工作来处理数据请求。分布式存储的核心目标是解决单机存储的瓶颈，同时提供高可靠性和可用性。
分布式存储的特点包括：
横向扩展性： 可以通过增加节点来扩展存储容量和性能，适应不断增长的数据量和负载。
高可靠性和容错性： 数据在多个节点上冗余存储，当某个节点出现故障时，数据依然可用，不会丢失。
数据分布和复制： 数据按照一定策略分布在不同节点上，数据的复制确保了数据的可用性和容错性。
并发访问和高性能： 支持多个客户端同时访问数据，实现高并发和更好的性能。
灵活的数据模型： 支持多种数据类型和访问方式，如文件系统、对象存储、键值存储等。
分布式文件系统： 分布式文件系统是一种特殊类型的分布式存储，主要用于存储和管理文件数据。它提供了类似于传统单机文件系统的接口，但是在底层实现上，数据被分散存储在多个节点上。分布式文件系统能够自动处理数据的分布、复制、一致性和故障恢复等问题。
常见的分布式文件系统特点包括：
命名空间和路径： 分布式文件系统通过路径来访问文件，类似于传统文件系统的目录结构。
数据分布和复制： 文件被切分成块并分散存储在多个节点上，同时进行数据复制以实现冗余和高可用性。
一致性和数据一致性模型： 分布式文件系统需要保证数据的一致性，不同节点上的数据副本需要保持同步。
访问控制和权限管理： 提供用户和应用程序访问控制和权限管理功能，确保数据安全性。
高性能： 分布式文件系统通常优化了数据的读写性能，以满足大数据场景的需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ac9c6fa0728c49206a0ec74db2666e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbfd7677d1b020c41e25f1f972ae03f7/" rel="bookmark">
			AIGC时代下，结合ChatGPT谈谈儿童教育
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 都2024年了，谈到儿童教育，各位有什么新奇的想法嘛
我觉得第一要务，要注重习惯养成，我觉得聊习惯养成这件事情范围有点太大了，我想把习惯归纳于底层逻辑，我们大家都知道，在中国式教育下，一般习惯于分为文理科，我觉得文科注重感性理解，理科注重理性逻辑。但相信在看文章的各位都是理科生居多吧，我要以逻辑思维分析一下习惯养成
语言逻辑习惯 首先我觉得是语言逻辑，做一道题，看一段话，与人交谈，都离不开语言逻辑，相信也有不少刚刚经历过高考的大学生，都知道不光语文，数学或者是物理化学这些，篇文都很长，或者作为一个程序员，其实过了初级阶段，发现最好不要依赖视频。学习编程，遇到错误，检索错误，验证方案，解决错误。这样才能形成自己的知识结构。那检索错误，也要看大量的文档，锁定内容，排除大量的垃圾内容的文字，我们平常在使用AI助手，比如很火的ChatGPT，还有文心一言，清华推出的智谱AI，还有抖音上出现的大量的AI，我觉得我们也离不开语言逻辑
话说回来，你小时候写作文可能不发愁，但你教一个小孩写作文，真的不发愁么？
所以语言逻辑的养成尤为重要。儿童教育在语言逻辑的养成上首先应该让孩子接触句子成分，其实就是主谓宾，定状补，
先聊聊写作 我觉得写作的思维，大家应该都有，总结一下就是定方向，讲内容，升华主题，所以我可以把这个思路分成三步，取题意，扩句子，联想补充，那我们习惯的养成就有了目标，如何取题意，如何扩句子，如果联想补充，
我觉得看图写话就是一个很好的积累实战，孩子拿到一幅图，我们让他取出图中的全部内容进行列举，然后将想到的再进行列举。这样的做法我认为有如下几点好处
不跑题对于联想内容进行了积累把图中内容的名词进行了积累，在未来写作时可以自拟场景 可以实战一下
我总结了一部分看图写话常见，常使用的名词：
周末	太阳	池塘	花朵	小草	小鸟	小鱼 我问了问AI助手，我让它把每个词串联起一篇文章，并能保证，每句话都可以单单领出来修饰自己的文章
输出结果为：
沐浴在周末的夏日暖阳中，我来到池塘边。烁烁波光的水面倒映着朦胧的光影，轻风徐徐吹拂，带来一丝清凉。花朵默默绽放着，等待着太阳的拥抱，时刻准备将绚丽的色彩献给大自然；婷婷青草，在微风中舒展着修长的身姿，轻轻摇曳，如同在品味生命的美妙旋律。 突然间，一声悦耳的鸟儿歌唱打破了这恬静的局面。翅膀划过高空，美妙的歌声轻盈飘绕，仿佛以音符编织一幅娴静和谐的画卷。它们展翅翱翔，尽情享受这片天地的美好与自由。 不远处，池塘中的鱼儿嬉戏游弋。它们在水中穿梭纵跃，欢乐追逐，乍现水中的一道道闪亮波光。鱼儿们纷纷跃出水面，舞动出一幕幕生动活泼的水中舞蹈，将这个微观奇境装点得更加美妙。它们的身姿优雅而灵动，如同展示着水中的柔美艺术。这幅景象真可谓是天然之境，引人入胜，宛如"鱼翔浅底，鸟飞低枝"，将我完全融入自然的怀抱，让我感受到平和与宁静的氛围。 我觉得对于一个3-7岁的儿童写下这样的内容是一个不错的积累和提升。
光靠记忆的积累对于语言的功底提高是远远不够的
扩句能力：多带孩子进行拆句的过程。体会主谓宾 定状补的各个成分，多拿身边的例子进行举例，就比如说
我在吃饭 这是一个主谓宾结构
扩展一下
什么样的我怎么样吃什么样的饭，然后怎么样 就比如
放学到家的我狼吞虎咽地吃妈妈刚端上桌的佳肴，心里美极了 再聊聊数学题 大家在学生时代，做一些题，都有粗心大意的时候，或者是面对题目的无从下手，这极度考察了文字的提取信息能力，当然这也是语言逻辑
就比如拿到一道题，我们首先要做到的就是找准目标，然后分析问题，再带着分析结果找答案，在提取题目的关键信息，对关键信息进行逻辑上的补充拓展，找到最后的答案。
那我们把学习数学，学习知识，就有了明确的目标，也就是对关键信息进行逻辑上的补充，这个我们放到后面来说，这里主要说语言逻辑，其实很简单，就是对于题目的读题顺序，读题目标，对孩子进行从小培养
把做题分为四步
分析问题 也就是先读问题和空位分析问题 其实也就是对于问题进行自己的阐述总结找题目信息 根据问题分析题目的有用信息对有用信息进行分析解决，拓展 其实就是教孩子如何读题，如何分析。
知识梳理习惯 其实就是，做笔记嘛，但是我这里想说做笔记其实也不一定是照抄，而是建立起孩子的底层逻辑——思维导图
我往往把学习分为四步，第一步，构图。也就是说我们拿到一个知识点，我们学了一遍之后呢，我们这一个知识点包括了123条内容，当我们逐渐积累，成长，我们会对一个或一块内容，进行查漏补缺，我把它称为第二步，补图。第三步我把它称为拆图，逐渐灵活掌握，我们不会把知识的运用局限于某一块内容，通常会形成一个思维定势，我把这个思维定势称为自我高度片面化总结，其实从这里开始，你会发现书本上的知识进入大脑中，都是干货。但是往往发现，你会有总结不完的内容。最后一步，我把它称为挖图，你自己高度片面化总结的知识，进行底层逻辑的深挖，也就是从广度到深度的过程。
想让孩子快速达到这一步我感觉其实并不容易，我认为家长要做的就是，让孩子养成构图，补图的习惯。作为家长应该以更高一层的思路，带孩子完成最后两部，拿到一道问题，不应该直接交孩子怎么做，应该以最后一步挖图的角度去引导他，这道题首先是什么知识点，根据这个知识点的什么内容推理出下一个知识点。而对于第三步，对知识点进行高度片面化的总结，实际上可以交给AI助手进行完成，帮助自己提炼升华。
数学思维养成 在这里给大家推荐一本书
以思维探险游戏培养3~7岁儿童的数学与逻辑思维能力 北大学霸作者、数学名师傲德 用漫画带孩子一起踏上这场奇妙的数学思维探险之旅 在书中孩子们将跟随勇敢的小主人公 穿越神秘的数学森林 解开一个又一个令人兴奋的谜题 轻松进入美妙、神奇的数学世界 内容介绍 本书侧重于对孩子数学思维的引导，数学学科认知的建立。涵盖的知识点包括：一、量的特点与100以内的数字；二、加法与减法；三、凑十法的应用与立体图形的认识；四、图形与顺序、规律；五、方向与位置；六、数学基础思维建立等。本书将数学思维与生动有趣的漫画结合，为孩子们创作出一本“既有益，又有趣”的数学思维书籍。
本书重点开发3~7岁儿童的数学与逻辑思维能力，通过游戏引发孩子对数学、逻辑思维的兴趣，同时融入有助于数学启蒙的各种知识点，更容易被该年龄段的儿童接受。
当当网链接：http://product.dangdang.com/29658176.html
京东的链接：https://item.jd.com/13953825.html
🎁本次送书1~3本【取决于阅读量，阅读量越多，送的越多】👈⌛️活动时间：截止到2024-1月2号✳️参与方式：关注博主+三连（点赞、收藏、评论）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd8981aedec6f589c5a4c22e6a8c40a/" rel="bookmark">
			是时候将javax替换为Jakarta了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始 相信很多朋友在使用新版本的Spring的时候，发现了一些叫jakarta的包，看起来有点陌生。
很多时候，比较纠结不知道该导入哪一个包。
jakarta其实就是之前的javax。
主要JavaEE相关的，从之前javax名字也可以看出来，主要是扩展部分，最典型的就是Servlet。
Oracle已经将JavaEE捐献给了Eclipse基金会，从JavaEE 8开始就被正式被改名为jakarta EE
jakarta EE官网
eclipse Jakarta组
javax这个包是Oracle的，涉及商标和版权原因，所以改名也很正常。
新版本的除了包含在JDK包中的除了javax.sql部分的，其他的javax部分基本都会替换为jakarta。
&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;6.1.0-M1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; javax.servlet在2018年之后就没有更新了，因为2018年Oracle把JavaEE捐赠给Eclipse基金会之后项目就迁移了。
&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 新版本的Spring已经使用的是Jakarta了：
Druid也添加了相应的支持：
下面我们就以Druid为例，来看一看。
Druid starter方式 可以使用druid的starter
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.20&lt;/version&gt; &lt;/dependency&gt; spring.datasource.initial-size=5 spring.datasource.min-idle=5 spring.datasource.max-active=25 spring.datasource.max-wait=1000 spring.datasource.time-between-eviction-runs-millis=60000 spring.datasource.validation-query=SELECT 1 as nums spring.datasource.test-while-idle=true spring.datasource.test-on-borrow=false spring.datasource.test-on-return=false spring.datasource.pool-prepared-statements=true spring.datasource.max-pool-prepared-statement-per-connection-size=20 spring.datasource.druid.filters=stat,wall,slf4j spring.druid.stat-view-servlet.enabled=true spring.druid.stat-view-servlet.url-pattern=/druid/* spring.druid.stat-view-servlet.login-username=tim spring.druid.stat-view-servlet.login-password=123456 spring.druid.web-stat-filter.enabled=true spring.druid.web-stat-filter.url-pattern=/* spring.druid.web-stat-filter.exclusions='*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' spring.druid.filter.stat.slow-sql-millis=1000 spring.druid.filter.stat.log-slow-sql=true spring.druid.filter.stat.enabled=true spring.druid.filter.wall.enabled=true spring.druid.filter.wall.config.drop-table-allow=false spring.druid.filter.wall.config.select-all-column-allow=false 自定义Config 也可以直接使用druid
&lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd8981aedec6f589c5a4c22e6a8c40a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b2efd191015f9a5691c20843698364/" rel="bookmark">
			Python 读取PDF文档内容 提取PDF文本和图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、介绍
二、安装Python库
三、Python 实现PDF文本和图片提取/读取PDF文档内容
1、从整个PDF文档提取文本
2、从特定PDF页面提取文本
3、从特定PDF页面区域提取文本
4、从整个PDF文档提取图片
5、从特定PDF页面提取图片
一、介绍 在当今的工作和生活中，PDF文档已经成为无处不在的文件格式。许多企业和机构选择将重要文件，如合同、报告等，保存为PDF格式以进行存储和管理。有时候，我们需要读取这些文档中的内容，包括文字和图片等，以便进一步分析文档内容、提取关键信息或将其集成到其他系统中。这篇文章将探讨如何通过Python实现PDF文本和图片的提取。
二、安装Python库 Python中有许多可以处理PDF的库，这篇文章使用的库是Spire.PDF for Python，它支持在多种场景下提取PDF文档中的文本和图片。此外还支持文档格式转换，例如PDF与图片互转，PDF转Word或Excel等。可以使用pip命令来安装它：
pip install Spire.PDF 下面我们来看如何借助这个库提取PDF文档中的文本和图片。
三、Python 实现PDF文本和图片提取/读取PDF文档内容 提取PDF文本和图片可以有多种场景，这里介绍一些常见的场景：
从整个PDF文档提取文本从特定PDF页面提取文本从特定PDF页面区域提取文本从整个PDF文档提取图片从特定PDF页面提取图片 1、从整个PDF文档提取文本 从整个PDF文档中提取文本，大致步骤如下：
加载PDF文档。遍历每个页面并提取页面的文本内容。将提取的文本保存到文本文件中。 代码：
from spire.pdf.common import * from spire.pdf import * # 定义一个从PDF文档提取文本的函数，参数分别为输入PDF文档的路径，存放提取文本的文本文档的路径 def extract_text_from_pdf(file_path, output_file): # 创建PdfDocument类的实例 doc = PdfDocument() # 加载PDF文档 doc.LoadFromFile(file_path) # 创建list来存储提取的文本 extracted_text = [] # 遍历文档的页面 for i in range(doc.Pages.Count): page = doc.Pages.get_Item(i) # 从页面提取文本并存储到list text = page.ExtractText(True) extracted_text.append(text) # 将提取的文本保存到文本文档 with open(output_file, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b2efd191015f9a5691c20843698364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9de8c1d6870a2d5989f3cfa6e7c730/" rel="bookmark">
			推荐一个重量级的APP软件——聚合集网站整合APP=海阔视界小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次分享一款应用叫做海阔视界， 海阔视界只是一个应用容器，或者说是一个转码工具，它不提供内容，但是你可以通过简单的规则实现复杂的功能，可以把原来需要在浏览器中浏览的网页都能变成原生界面，让浏览更顺畅，可以自己导入或者编写小程序，这里的“小程序”其实是海阔视界里面的一种规则。 通过规则你可以把任何网站导入到这个应用，导入的同时你可以对这些网站进行提取编辑，比如去掉广告，提取源地址，提取关键内容等等，可以让浏览更便捷干净清爽，也可以把你搜集的网站一起整合便于记忆和使用。
2024海阔视界app最新版本(道长仓库pro)需要导入规则合集或者小程序口令才可以使用，集影视、资讯、浏览器等功能为一体，聚焦全网资源内容，内置多个标签，支持在线一键搜索浏览、快速查找，随你自由编辑，添加导入源，各种资源可以轻松找到，操作简单易上手，满足不同用户的需求！
海阔视界怎么用？
海阔视界怎么导入规则？
道长仓库pro：￥home_rule_url￥http://hiker.nokia.press/hikerule/rulelist.json?id=1094
风影：https://pasteme.tyrantg.com/xxxxxx/hsxtrxjraddsw3jt
阅动漫：￥home_rule_url￥http://hiker.nokia.press/hikerule/rulelist.json?id=6526
无忧小说：https://pasteme.tyrantg.com/xxxxxx/nh7dkdufljgckgnr
随机音乐：https://pasteme.tyrantg.com/xxxxxx/0tszeszarxsoxduv
阿里云盘搜索：https://pasteme.tyrantg.com/xxxxxx/5wpde4qpashqjej9
云盘汇影：https://pasteme.tyrantg.com/xxxxxx/rs518xtb2rxfstbd
天天听书：https://pasteme.tyrantg.com/xxxxxx/ygnro7ckhx0l8onb
爱上你听书：https://pasteme.tyrantg.com/xxxxxx/6ne4cdcwptz7kn34
海伦DJ：https://pasteme.tyrantg.com/xxxxxx/sfdbiypqng9emrxa
biu二次元：https://pasteme.tyrantg.com/xxxxxx/u5xdhlrbawj8isn0
触站：https://pasteme.tyrantg.com/xxxxxx/oqjcrl3u1yokmdlb
YINRSS：https://pasteme.tyrantg.com/xxxxxx/2tcpvlggg6dw9nuu
简单RSS订阅：https://pasteme.tyrantg.com/xxxxxx/fag5expgmhhrooj2
魔RSS：https://pasteme.tyrantg.com/xxxxxx/lqmbof1f2qusopsa
uckk云：https://pasteme.tyrantg.com/xxxxxx/rs4qv6uhwym8ae3u
源使用方法：
复制源→打开软件→软件弹出提示框→立即导入。
若软件没有弹出提示框→打开右下方设置→点击“剪贴板口令导入”。
然后复制上面其中一个源，粘贴进去，确定即可！
确定后，就会弹出“温馨提示”，点击“立即导入”。
最后就会生成下图所示的小程序信息，点击“导入”，就会提示小程序导入成功。
在首页“我的小程序”中，可以找到导入的小程序，如下图所示。
如何无广告播放（导入源之后）？
打开软件→点击悬浮款“搜索该频道”→输入要搜索的东西→点击搜索结果→选择集数→点击下方“嗅探到视频或音乐”→如果出现“嗅探到的视频或者音乐”→随便选一个，不能播放跳出来再选一次即可去广告播放了。
海阔视界官网介绍：
海阔视界里面整合了各方面的优质资源——电影、IT技术，做到一应俱全！可自行编辑添加影视源、直播源、图片源等等，功能全面的强大APP，软件自带社区有超详细使用教程，源规则制作教程等，如果不会制作规则也可以直接用社区里其他大神分享的规则，一键导入即可开始使用。
强大观影工具，不光除了可以追剧，甚至连刷微博以及看知乎等，整个资源的分类也是超级详细的，可以方便你随时去搜索，海量的影视资源可以随时播放，还有热点直播以及资讯等，看知乎也是非常方便的。
和阅读同一个开发者，功能都是靠手动安装，点一下右上角就能看到一些插件，安装方式都有。
海阔视界app特色：
1、聚合性的多功能播放器工具，不仅可以追剧还能掌握各大平台的热门资讯
2、支持多种不同的搜索方式进行资源查找，各大影视频道分类也是超级的细致
3、丰富的资源获取让你一应俱全，全部搞定，并且都是免费实用的，快速又方便
应用亮点：
1、聚合性的多功能播放器工具，不仅可以追剧还能掌握各大平台的热门资讯
2、智能化云播放引擎，云端解码，云端转码，在线云播放高清流畅
3、采用目前最先进的p2p网络资源搜索技术，资源更多，资源结果更精准
4、支持多种不同的搜索方式进行资源查找，各大影视频道分类也是超级的细致
软件优势：
1、史上最全的资源细分标签，看片只需一键；
2、相关影片推荐功能，看电影更便捷；
3、支持加载本地视频，精彩内容一键传输；
4、个性化视频分类体系，多种清晰度的选择让看片更自主；
5、离线缓存模式，没网络一样想看随时能看；
6、多种手势操作功能，大大提升手机观影体验；
更新日志：
v8.9更新内容：
新增：新窗口打开小程序右上角菜单增加清除缓存、分享规则、编辑规则选项。
新增：增加搜索记录显示样式自定义。
新增：支持来电话时自动暂停播放。
新增：支持蓝牙连接断开时自动暂停播放。
新增：小程序搜索界面也支持发送到主页。
优化：嗅探规则支持仅单一网站生效。
优化：修复浏览器代理替换规则偶发不生效的问题。
优化：浏览器代理替换规则增加快捷替换域名语法。
优化：修复云剪贴板2分享功能。
优化：修复一些已知问题，提升稳定性。
特别说明
海阔视界源仓库口令：
道长仓库pro：￥home_rule_url￥http://hiker.nokia.press/hikerule/rulelist.json?id=1094
风影：https://pasteme.tyrantg.com/xxxxxx/hsxtrxjraddsw3jt
阅动漫：￥home_rule_url￥http://hiker.nokia.press/hikerule/rulelist.json?id=6526
无忧小说：https://pasteme.tyrantg.com/xxxxxx/nh7dkdufljgckgnr
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae9de8c1d6870a2d5989f3cfa6e7c730/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a167367171ca93c02c7356c87ca4255d/" rel="bookmark">
			GitHub Copilot 终极详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写代码通常是一项乏味且耗时的任务。现代开发人员一直在寻找新的方法来提高编程的生产力、准确性和效率。
像 GitHub Copilot 这样的自动代码生成工具可以使这成为可能。
GitHub Copilot 到底是什么？ GitHub Copilot 于 2021 年 10 月推出，是 GitHub 的较新工具之一。Copilot 被称为“人工智能结对程序员”，它使用人工智能在编辑器中自动生成代码。它可作为 Visual Studio Code、JetBrains IDE 套件和 Neovim 的扩展。
但 GitHub Copilot 不仅仅是一个自动完成解决方案。根据您正在编写的代码中的上下文线索，Copilot 会建议行甚至整个函数。对于开发人员来说，这是一种更快、更轻松的方式来创建测试、探索 API 和解决问题，而无需不断地在其他地方寻找答案。
一旦您开始使用 GitHub Copilot 插件，该工具就会自动适应您编写代码的方式。
Copilot 速度非常快，并且在您编写代码时与您的工作流程无缝配合。当您开始掌握它的窍门时，只需单击键盘即可自动完成您需要的代码。
与市场上类似的解决方案不同，GitHub Copilot 为您提供完全的控制权——因此得名。您可以接受或拒绝代码、手动编辑建议以及循环选择替代建议。由于该工具会适应您的编码风格，因此它将来为您提供的建议将继续变得更加智能。
GitHub Copilot 的工作原理 GitHub Copilot 由 OpenAI Codex 提供支持。自动生成的建议来自文件中的上下文，例如函数名称、代码注释、文档字符串、文件名、光标位置等。根据这些信息，Copilot 建议开发人员只需按键盘上的 Tab 键即可接受的代码片段。
该人工智能工具可以理解 TypeScript、Python、JavaScript、Ruby 和数十种其他常见语言。
这是因为人工智能建议来自 GitHub 公共存储库中的开源代码。它会分析这些信息，然后尝试根据您所写的内容找到最佳的解决方案。
与其他解决方案相比，GitHub Copilot 的独特之处在于它理解自然语言的能力。这包括编程语言和人类语言。
值得注意的是，GitHub Copilot 并没有编写完美的代码。该工具尽力尝试理解开发人员的意图。但是，您会注意到有些建议并不总是有效，甚至没有意义。
GitHub Copilot 不会测试它向您建议的任何代码。这些建议可能实际上无法编译或运行。因此，在认为代码可用之前，您仍然需要仔细检查和测试代码。
为了充分利用 GitHub Copilot，您应该将代码分割成更小的函数。确保您在工作时编写了良好的注释和文档字符串。始终为函数参数使用有意义的名称，因为这将使 Copilot 更容易理解您的意图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a167367171ca93c02c7356c87ca4255d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c820694782907453988aef0b79a05a5/" rel="bookmark">
			$2a$10$-bcrypt哈希算法生成的密码哈希值-Python脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 $2a$10$rt8K954aZldXxmuf3AXkgecWvO0Zdmi6FM.uKd.2nJmcoeKVYCOPK 使用bcrypt哈希算法生成的密码哈希值。 bcrypt是一种密码哈希函数，通常用于存储用户密码的安全散列值。 这个字符串的格式是由几个部分组成的：
$2a$: 这是指明使用的哈希算法的标识符，对于bcrypt来说，表示使用的是bcrypt版本 2a。$2a$10$: 这是指明用于加密的工作因子，这里是10，表示加密过程的迭代次数。 剩下的部分就是经过哈希后的密码散列值。 请注意，这个字符串本身并不包含密码信息，只是密码的哈希值。 哈希函数是单向的，因此从哈希值中无法还原出原始密码。
如果想验证一个给定的密码是否匹配这个哈希值，可以使用bcrypt库或相应的编程语言中提供的bcrypt库进行比较。
bcrypt版2a生成哈希算法 如将密码123456生成2a版本bcrypt哈希算法生成的密码哈希值，python代码如下：
1、 安装库：bcrypt
pip install bcrypt 2、在Python中，可以使用库生成bcrypt哈希算法版本2a的密码哈希值
import bcrypt # 要哈希的密码 password = "123456" # 生成哈希值，版本2a hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(rounds=10, prefix=b'2a')) # 打印哈希值 print(hashed_password.decode('utf-8')) 在这个示例中，参数设置为10，表示加密过程的迭代次数，参数设置为表示使用bcrypt版本2a。 生成的哈希值会打印到控制台。roundsprefixb'2a'
可通过这段脚本验证一个给定的密码是否匹配这个哈希值，反向破解。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/541/">«</a>
	<span class="pagination__item pagination__item--current">542/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/543/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>