<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9d9ac12b746512c0ed2bad7eafe668/" rel="bookmark">
			【python 实用性】浅谈subprocess中 Popen() 和 run()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 run() 和 Popen() 介绍run() 和 Popen() 用法分享一波 提示：以下仅为本人个人观点，仅供参考，不足之处欢迎评论，共勉 run() 和 Popen() 介绍 subprocess 的 run() 和 Popen() 都是子进程管理的方法, 启动新的子进程并执行外部命令的方法.
Popen ： 更底层、更灵活的接口。创建一个新的进程并根据给定的参数执行命令，不会因等待这个命令执行完成而阻塞别的子进程的执行。这使得你可以在子进程执行的同时，主进程可以继续执行其他任务，提供了异步执行的能力
特点:
非阻塞式命令提供了更多的参数，可以实时读取输出、向子进程发送数据或在子进程执行期间做其他事情适合需要与子进程进行复杂交互或需要细粒度控制的场景 run : 作为一个简单的接口来替代许多常见情况下的 Popen 调用， run()会执行给定的命令，等待命令完成
特点：
阻塞式命令：需要等待命令执行完自动处理标准输入、输出和错误流 run() 和 Popen() 用法 run() 方法：
单一执行命令：
[command]: 字符串、字符串参数列表 import subprocess subprocess.run([command]) # ex: command = 'ls' subprocess.run([command]) 设置超时时间：
使用timeout参数来设置命令超时时间，如果命令执行时间超时，将杀死子进程，并弹出 TimeoutExpired 异常，单位：秒 import subprocess command = 'adb shell top' try: res = subprocess.run(command, timeout=5) except TimeoutError as e: print(e) # 触发异常则会报 subprocess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9d9ac12b746512c0ed2bad7eafe668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea97241839955414b0fe77f386cc190/" rel="bookmark">
			力扣每日一题 6/18 字符串/模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 2288.价格减免 【中等】 题目： 句子 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 '$' 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个 价格 。
例如 "$100"、"$23" 和 "$6" 表示价格，而 "100"、"$" 和 "$1e5 不是。 给你一个字符串 sentence 表示一个句子和一个整数 discount 。对于每个表示价格的单词，都在价格的基础上减免 discount% ，并 更新 该单词到句子中。所有更新后的价格应该表示为一个 恰好保留小数点后两位 的数字。
返回表示修改后句子的字符串。
注意：所有价格 最多 为 10 位数字。
示例 1：
输入：sentence = "there are $1 $2 and 5$ candies in the shop", discount = 50 输出："there are $0.50 $1.00 and 5$ candies in the shop" 解释： 表示价格的单词是 "$1" 和 "$2" 。 - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea97241839955414b0fe77f386cc190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d8c2e6a52657fd7be6fb12026df6d3/" rel="bookmark">
			【AI基础】租用云GPU之autoDL部署大模型ollama&#43;llama3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个显卡昂贵的年代，很多想要尝试一下AI的人可能都止步于第一步。这个时候我们可以租用在线的GPU资源来使用AI。autoDL就是这样的一个云平台。
一、创建服务器 1.1 注册账号 官网：https://www.autodl.com/ | 租GPU就上AutoDL
帮助文档：https://www.autodl.com/docs/ | AutoDL帮助文档 登录官网，注册账号。
1.2 创建服务器 注册后会跳转到创建实例页面，也可以通过控制台进入：
进入后可以选择新实例的配置：付费方式/GPU型号等：
选择好硬件后，选择系统镜像： 默认镜像还是比较全的，这里选择miniconda：
点击“立即创建”后，稍等一下，跳转到“容器实例”页面，等状态变为“运行中”时，代表已经可以远程登录：
1.3 登录服务器 复制上图中的ssh账号密码，登录服务器： 登陆后显示了服务器的相关配置。
二、配置服务器 2.1 配置加速器 为了加快下载速度，aotuDL提供了学术资源加速：https://www.autodl.com/docs/network_turbo/ | 学术资源加速
从文档了解，当我们需要下载大模型的时候可以打开，下载完成后最好关闭加速。 执行加速命令：
&gt; source /etc/network_turbo 2.2 安装ollama ollama的介绍请参考：【AI基础】大模型部署工具之ollama的安装部署。
官网：https://ollama.com/
快速入门：https://github.com/ollama/ollama/blob/main/README.md#quickstart
快速入门的部署界面，
因为autoDL对应的服务器是ubuntu，我们找到linux的命令：
&gt; curl -fsSL https://ollama.com/install.sh | sh 从上图可以看出，有个依赖需要安装，这个要看部署的服务器情况，有时候缺少有时候又是ok的，缺少什么就安装什么，安装对应的依赖后重新安装ollama就好了。
这里执行命令安装lshw：
&gt; sudo apt-get update &gt; sudo apt-get install lshw 然后重新执行ollama安装命令：
安装成功。 2.3 检验ollama ollama安装成功后默认以服务形式运行，运行命令检查状态：
&gt; systemctl status ollama.service 结果发现出现错误：
System has not been booted with systemd as init system (PID 1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d8c2e6a52657fd7be6fb12026df6d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde80f559709da6e51f597b058767bc0/" rel="bookmark">
			【向量检索】之向量数据库Milvus,Faiss详解及应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reference https://www.modb.pro/db/509268
笔记︱几款多模态向量检索引擎：Faiss 、milvus、Proxima、vearch、Jina等 - 知乎 (zhihu.com)
向量数据库入坑指南：聊聊来自元宇宙大厂 Meta 的相似度检索技术 Faiss - 苏洋的文章 - 知乎
常用的三种索引方式及原理-CSDN
向量搜索应用 向量检索技术，其主要的应用领域如人脸识别、推荐系统、图片搜索、视频指纹、语音处理、自然语言处理、文件搜索
背景 向量检索需要用到向量数据库，而普通的关系型数据库（如 MySQL、PostgreSQL）通常不适合处理向量检索任务。这是因为**【向量检索有其特殊的需求和性能要求】**。
原因如下：
1、向量检索的特性
高维度数据：向量通常是高维数据，可能有数百到数千个维度。处理高维数据需要特殊的数据结构和算法，以确保检索的效率。相似性度量：向量检索基于相似性度量（如欧氏距离、余弦相似度等）来查找相似向量。计算高维向量之间的相似性需要高效的算法，而普通数据库没有优化这些操作。近似最近邻搜索（ANN）：在大规模数据集上，精确最近邻搜索的计算开销非常大，因此通常使用近似最近邻搜索算法（如 LSH、HNSW、IVF 等）来提高检索效率。向量数据库通常内置了这些算法。 2、普通数据库的限制
索引结构：普通数据库的索引（如 B 树、哈希索引等）设计用于处理标量数据（如整数、字符串等），而不是高维向量。它们无法有效地支持高维相似性检索。查询优化：普通数据库的查询优化器针对 SQL 查询进行了优化，但对高维向量相似性检索的优化有限，可能导致查询性能低下。扩展性：处理大规模向量数据需要分布式存储和计算能力，普通数据库在这方面的支持不如专门设计的向量数据库。 3、向量数据库的优势
向量数据库（如 FAISS、Milvus、Annoy、Weaviate 等）专门为向量检索设计，具备以下优势：
高效的索引结构：支持多种高效的索引结构（如 HNSW、IVF、PQ 等），能够快速处理高维向量的相似性检索。优化的相似性计算：针对高维向量的相似性计算进行了优化，能够在大规模数据集上高效执行最近邻搜索。扩展性和分布式支持：许多向量数据库支持分布式存储和计算，能够处理海量向量数据，并在多个节点之间均衡负载。 4、结论
向量数据库通过专门的索引结构、优化的相似性计算以及分布式支持，显著提高了高维向量相似性检索的效率和扩展性。因此，对于需要处理大规模向量数据的应用场景（如推荐系统、图像搜索、自然语言处理等），使用向量数据库是更好的选择。
索引类型 索引类型原理特点适用场景优点缺点FLAT线性扫描: 直接对所有向量进行线性扫描，计算每个向量与查询向量之间的距离。精确度高，速度较慢。小规模数据集或对精度要求非常高的场景。精度高，因为计算了每个可能的距离。对于大数据集，速度非常慢。IVF簇划分: 将向量数据集分为多个簇（clusters），然后在这些簇内搜索。
【Inverted File Index】通过缩小搜索范围加速查询。搜索分两步：先找到最相关的簇，再在簇内搜索。中大规模数据集，平衡速度和精度。加速搜索速度，平衡速度和精度。精度稍低于 FLAT。PQ子空间划分: 将向量分成多个子空间
量化: 每个子空间独立量化，减少存储和计算复杂度。
【Product Quantization】存储效率高，查询速度快。精度有损，但通常可接受。大规模数据集，对存储和查询速度要求高的场景。存储效率高，查询速度快。量化带来精度损失。HNSW多层图结构: 构建一个包含多个层次的小世界图
导航搜索: 从高层次开始，逐层向下搜索，直到找到最近邻。
【Hierarchical Navigable Small World】高查询效率和精度，支持动态更新。高效查询，动态更新的大规模数据集。高效的查询速度和高精度。构建和维护图结构复杂，内存消耗较大。LSH哈希映射: 将相似的向量映射到相同的哈希桶。
【Locality-Sensitive Hashing】适用于高维数据，但精度相对较低。高维数据的近似最近邻搜索。适用于高维数据，查询速度快。精度相对较低。ANNOY随机投影树: 构建多棵树，每棵树基于不同的随机投影。
【Approximate Nearest Neighbors Oh Yeah】平衡了搜索速度和精度。大规模数据集。平衡速度和精度。构建时间较长。IVF-PQ簇划分和量化: 结合 IVF 和 PQ，将向量数据集分为多个簇，并在每个簇内进行量化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fde80f559709da6e51f597b058767bc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa145d997b9d99ff3d09acdc4a79a12/" rel="bookmark">
			Python for循环中的引用传递和值传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上代码：
a = [[1],[2],[3]] b = [[4,5],[6,7],[7,8]] for i,j in zip(a,b): print(i,j) i = [9] #i[0] = 8 j[:2]=[1,2] print(i, j) print(a) print(b) 运行的结果：
[1] [4, 5] [9] [1, 2] [2] [6, 7] [9] [1, 2] [3] [7, 8] [9] [1, 2] [[1], [2], [3]] [[1, 2], [1, 2], [1, 2]] 可以看到修改i的值不会造成数组a的值的修改，而修改j的值会造成数组b的值的修改，这是为什么呢？
引用传递和值传递 引用传递(Pass by Reference) 在引用传递中,函数接收的是变量的地址,也就是对象的引用。
当你把一个可变对象(如列表、字典等)传递给函数时,函数内部对该对象的修改会影响到原始的对象。
这是因为函数接收的是对象的引用,而不是对象的副本。
示例:
def modify_list(lst): lst[0] = 'changed' my_list = [1, 2, 3] modify_list(my_list) print(my_list) # 输出 ['changed', 2, 3] 值传递(Pass by Value) 在值传递中,函数接收的是变量的值的副本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faa145d997b9d99ff3d09acdc4a79a12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a5b753e4a2ca91942056ad1fe9f3b49/" rel="bookmark">
			计算机网络（谢希仁第六版）| 课后习题与答案 | 物理层 | 题目知识点详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络（谢希仁第六版）课后习题与答案 物理层 博客只对老师给的重点进行整理，完整的课后习题答案见Gitee下载：《计算机网络教程（第6版）（微课版）》习题答案
2-5 请画出数据流1 0 1 0 0 0 1 1的不归零编码、曼彻斯特编码和差分曼彻斯特编码的波形（从高电平开始）。
图2-1 题2-5图 非归零编码（NRZ）：高1低0，编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。比如，发了一长串相同的电平，就无法看出1或0的个数了。归零编码（RZ）：信号电平在一个码元之内都要恢复到零，导致处于低电平的时间非常多，不推荐使用。反向不归零编码（NRZI）：信号电平翻转表示0，信号电平不变表示1。如果对于全0的信号，那么电平会一直反转，接收端很好接收；但如果是全为1的信号，电平就不会反转了。曼彻斯特编码：将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1；码元0则正好相反。可以记忆为：前高后低表示1，前低后高表示0。也可以采用相反的规定该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号（可用于同步）又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平，所以数据传输速率只有调制速率的二分之一。差分曼彻斯特编码：同1异0。常用于局域网传输，其规则是：**若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。**该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。4B/5B编码**（了解即可）**：比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B。编码效率为80%。只采用16种对应16种不同的4位码其他的16种作为控制码（帧的开始和结束，线路的状态信息等）或保留。 2-9 试解释以下名词：数据、信号、模拟数据、模拟信号、基带信号、带通信号、数字数据、数字信号、码元、单工通信、半双工通信、全双工通信、串行传输、并行传输。
数据：通信的目的是传送消息。语音、文字、图像、视频等都是消息。数据是运送消息的实体，数据是使用特定方式表示的信息，通常是有意义的符号序列，这种信息的表示可以用计算机或人处理产生。
信号：信号是数据的电气或电磁的表现。
模拟数据：模拟数据也称为模拟量，相对于数字量而言，指的是取值范围是连续的变量或数值。模拟数据是指在某个区间产生的连续值，例如声音、图像、温度和压力等，模拟数据一般采用模拟信号，例如用一系列变化的电磁波，或电压信号表示。
模拟信号：模拟信号也称为连续信号，代表消息的参数的取值是连续的，例如用户家中的调制解调器到电话端局之间的用户线上传送的就是模拟信号。
基带信号：来自信源的信号称为基带信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。
带通信号：经过载波调制后的信号称为带通信号。
数字数据：在数据通信中也称为数字量，相对于模拟量而言，指的是取值范围是离散的变量或者数值。
数字信号：数字信号也称离散信号。代表消息的参数的取值是离散的。例如，用户家中的计算机到调制解调器之间或在电话网中继线上传送的就是数字信号。(编码指的是将数据变成数字信号，而调制指的是将数据变成模拟信号)
码元：指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为** k k k进制码元**，而该时长称为码元宽度。当码元的离散状态有M个时（M大于2），此时码元为** M M M进制码元**。通俗来讲，比如 2 2 2进制码元，就代表信号有两种波形，那么需要 l o g 2 2 = 1 log_{2}2=1 log2​2=1个比特位来表示（0和1）。如果是 4 4 4进制码元，就代表信号有四种波形，那么需要 l o g 2 4 = 2 log_{2}4=2 log2​4=2个比特位来表示（00、01、10、11）。
单工通信：只有一个方向的通信而没有反方向的交互，因此仅需要一条信道。类比广播站。
半双工通信：通信的双方都可以发送或接收信息，但任何一方都不能同时发送或接收，需要两条信道。类比对讲机。
全双工通信：又通信双方可以同时发送和接收信息，也需要两条信道。类比电话。
串行传输：表示一个字符的8位二进制数按由低到高位的顺序依次发送。速度慢、费用低、适合远距离。
并行传输：表示一个字符的8位二进制数同时通过8条信道发送。速度快、费用高、适合近距离。
图2-2 三种通信方式示意图 2-10 常用的传输媒体有哪几种？各有何特点？
传输媒体分为导引型传输媒体和非导引型传输媒体。导引型传输媒体分为双绞线、同轴电缆、光光纤；非导引型传输媒体主要是无线电波。
双绞线是古老、但又是最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。绞合可以减少对相邻导线的电磁干扰。为了进一步提高电磁干扰能力，可以在双绞线的外面加一个由金属丝编制成的屏蔽层，这就是屏蔽双绞线（STP），无屏蔽层的双绞线就称为非屏蔽双绞线（UTP）。
双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。距离太远时，对于模拟传输要用放大器放大衰减的信号；对于数字传输，要用中继器将失的信号整形。
同轴电缆由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层构成。按特性阻抗数值的不同，通常将同轴电缆分为两类:50Q同轴电缆和75Q同轴电缆。其中，50Q同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆，它在局域网中得到广泛应用：75Q同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a5b753e4a2ca91942056ad1fe9f3b49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e0a04172e8e3f54d87b4ce0d9297ebb/" rel="bookmark">
			论文研读｜以真实图像为参考依据的AIGC检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：这篇文章介绍几篇AIGC检测的相关工作，均是以真实图像的特征作为标准进行检测。
目录 Detecting Generated Images by Real Images Only (202311 arXiv)Let Real Images be as a Judger, Spotting Fake Images Synthesized with Generative Models (202403 arXiv)DRCT: Diffusion Reconstruction Contrastive Training towards Universal Detection of Diffusion Generated Images (ICML 2024) Detecting Generated Images by Real Images Only (202311 arXiv) 作者团队：Xiuli Bi, et al. 重庆邮电大学
论文链接：https://arxiv.org/abs/2311.00962
核心思想：仅仅使用真实图像作为训练数据，基于真实图像的潜在噪声模式，训练一个单分类器，进行AIGC的检测。
这篇文章其实是他们组另一篇文章 Detecting Generated Images by Real Images (ECCV 2022) 的改进版。ECCV 2022 那篇论文中提出来的 LNP 应用到了这篇文章中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e0a04172e8e3f54d87b4ce0d9297ebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b03273c2719924ddfa86fb722aa643/" rel="bookmark">
			Python热涨落流体力学求解算法和英伟达人工智能核评估模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎯要点 🎯平流扩散简单离散微分算子 | 🎯相场模拟：简单旋节线分解、枝晶凝固的 | 🎯求解二维波动方程，离散化时间导数
🎯英伟达 A100 人工智能核性能评估模型 | 🎯热涨落流体动力学求解及算法
📜有限差分法 | 本文 - 用例 📜Python和Julia河流湖泊沿海水域特征数值算法模型
📜Python和C++数学物理计算分形热力学静电学和波动方程
📜Python物理学有限差分微分求解器和动画波形传播
📜Python数值和符号算法计算及3D视图物理数学波形方程
📜Python氮氧甲烷乙烷乙烯丙烯气体和固体热力学模型计算
📜Python射频电磁肿瘤热疗数学模型和电磁爆炸性变化统计推理模型
🍇Python有限差分逼近余弦导数 函数 f ( x ) f(x) f(x)在 x = a x=a x=a点的导数 f ′ ( x ) f^{\prime}(x) f′(x)定义为：
f ′ ( a ) = lim ⁡ x → a f ( x ) − f ( a ) x − a f^{\prime}(a)=\lim _{x \rightarrow a} \frac{f(x)-f(a)}{x-a} f′(a)=x→alim​x−af(x)−f(a)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b03273c2719924ddfa86fb722aa643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b3fd46b8812ca9a38d50ce66e5955a/" rel="bookmark">
			人工智能、机器学习、深度学习：技术革命的深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
人工智能、机器学习、深度学习：技术革命的深度解析
引言
第一部分：人工智能的起源与演进
1.1 人工智能的定义
1.2 人工智能的历史
1.3 人工智能的关键概念
1.4 人工智能的应用领域
1.5 人工智能的未来发展
1.6 人工智能的代码案例
第二部分：机器学习的理论与实践
2.1 机器学习的定义
2.2 机器学习的关键概念
2.3 机器学习的主要算法
2.4 机器学习的应用案例
2.5 机器学习的未来发展
2.6 机器学习的代码案例
第三部分：深度学习的创新与突破
3.1 深度学习的定义
3.2 深度学习的关键概念
3.3 深度学习的主要架构
3.4 深度学习的应用案例
3.5 深度学习的未来发展
3.6 深度学习的代码案例
结语
人工智能、机器学习、深度学习：技术革命的深度解析 引言 在当今数字化时代，人工智能（AI）、机器学习（ML）和深度学习（DL）已经成为推动技术进步和创新的关键力量。这些技术不仅改变了我们与机器的互动方式，还在医疗、金融、交通、教育等多个领域产生了深远影响。本文将深入探讨这三个技术领域，从它们的定义、历史、关键概念、应用案例到未来的发展趋势。
第一部分：人工智能的起源与演进 1.1 人工智能的定义 人工智能（Artificial Intelligence），英文缩写为AI。 是新一轮科技革命和产业变革的重要驱动力量， 是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。
人工智能是智能学科重要的组成部分，它企图了解智能的实质，并生产出一种新的能以与人类智能相似的方式做出反应的智能机器。人工智能是十分广泛的科学，包括机器人、语言识别、图像识别、自然语言处理、专家系统、机器学习，计算机视觉等。
人工智能大模型带来的治理挑战也不容忽视。 马斯克指出，在人工智能机器学习面具之下的本质仍然是统计。 营造良好创新生态，需做好前瞻研究，建立健全保障人工智能健康发展的法律法规、制度体系、伦理道德。 着眼未来，在重视防范风险的同时，也应同步建立容错、纠错机制，努力实现规范与发展的动态平衡。
1.2 人工智能的历史 人工智能的历史可以追溯到20世纪40年代和50年代，当时的计算机科学家们开始探索如何让机器模拟人类智能。1956年，约翰·麦卡锡在达特茅斯会议上首次提出了“人工智能”这一术语。
1.3 人工智能的关键概念 人工智能（AI）是一个广泛的领域，它涉及到创建能够执行通常需要人类智能的任务的系统。以下是人工智能中的几个关键概念：
a.知识表示（Knowledge Representation） 知识表示是AI中的一个核心问题，它涉及到如何有效地将知识编码到计算机中。这样，机器就可以存储、处理和使用这些知识来解决问题。知识表示的方法包括：
命题逻辑：使用逻辑语句来表示简单的事实和关系。语义网络：通过节点和边来表示实体及其关系。框架：类似于语义网络，但可以包含更多属性和值。本体：一种形式化的知识表示方法，用于定义特定领域的概念和关系。规则：表示条件和动作的语句，用于专家系统中的推理。 b.搜索算法（Search Algorithms） 搜索算法用于在问题空间中寻找解决方案。它们通过遍历可能的解决方案来找到目标状态。常见的搜索算法包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b3fd46b8812ca9a38d50ce66e5955a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e328049b8cabda2da06ad4d11fc779/" rel="bookmark">
			数据结构与算法-字符出现的次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 以下是这个找出字符串中字符串出现频率最多的字符。大家可以自行研究一下，题目不难，我今天尝试使用C语言来完成解答，但是在解答过程居然出现了一个意想不到的问题。可能是高级语言用多了，C语言某些函数的限制和风险忘记管控了o(￣︶￣)o
解题思路 这种题目类似于hash的算法，也就是说我们可以使用数组索引[下标]来表示字母。
例如字母’A’ 可以看做 ‘A’-‘A’ ,索引为0， ‘a’-‘a’ 索引为0,（tips，题目不区分大小写字母），字母’s’可以算出索引 int index = ‘s’ -‘a’ …, 依次类推。我就用索引表示字符，索引对应的数组的值表示出现次数，例如 a[0] =3,表示字符’a’或者’A’出现三次。 程序实现 输入字符串 char str[1000001]; if (fgets(str, sizeof(str), stdin) == NULL) { return 1; }str[strcspn(str, "\n")] = 0; 遍历字符串更新数组中的出现次数 int a[26] = {0}; int max = 0; char ch; size_t len = strlen(str); for (int i = 0; i &lt; len; i++) { if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z' || str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') { int index = str[i] - (str[i] &gt;= 'a' ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e328049b8cabda2da06ad4d11fc779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c28d3f83a2807f4dc2f5c8fe992da39/" rel="bookmark">
			获取泛型，泛型擦除，TypeReference 原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 @author blog.jellyfishmix.com / JellyfishMIX - githubLICENSE GPL-2.0 获取泛型，泛型擦除 下图中示例代码是一个工具类用于生成 csv 文件，需要拿到数据的类型，使用反射感知数据类型的字段，来填充表字段名。可以看到泛型 T 没有类似 getClass() 的方法，因为编译后泛型 T 会被擦除，在字节码中不存在 T 这个类型，所以没办法通过 T 来获取某些信息。方法签名中的 java.util.List&lt;T&gt; 编译后会变成 java.util.List。解决方式是显式传入 Class&lt;?&gt; clazz 来指定数据类型。 泛型嵌套 Class&lt;?&gt; clazz 只能传递一层数据类型，无法解决泛型嵌套时的数据类型传递问题。对于泛型嵌套，例如 List&lt;List&lt;Map&lt;String, Person&gt;&gt;&gt;，这样的类型。如果使用 Class&lt;?&gt; clazz 来传递，只能感知到最外层的 List.class，内层泛型还是会出现泛型擦除的情况。完整地传递泛型嵌套，还是需要感知到具体的泛型。 TypeReference 原理分析–感知具体泛型 出现泛型嵌套情况时，获取完整的泛型，也是序列化组件需要面对的问题。解决方法例如 jackson 提供的 TypeReference。 泛型没有完全擦除 javac 编译后没有把所有持有泛型的位置都做擦除。编译后的字节码中，子类的类签名显式指定了传递给父类的泛型。 根据子类获取向父类传递的泛型理论基础 作为 TypeReference 的替代品，定义一个 CustomTypeHandler，通过演义来展示 TypeReference 的原理，
public abstract class CustomTypeHandler&lt;T extends Object&gt; { } 再定义一个 ChildCustomTypeHandler 子类，继承父类时声明泛型。
public class ChildCustomTypeHandler extends CustomTypeHandler&lt;List&lt;List&lt;Map&lt;String, Person&gt;&gt;&gt;&gt; { private String tag; } 编译项目后，使用 jclasslib(一个 IDEA 查看字节码的插件) 查看 ChildCustomTypeHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c28d3f83a2807f4dc2f5c8fe992da39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c4cf43191a058e885acdff15944e44e/" rel="bookmark">
			好文！12个策略解决 Kafka 数据丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哥们儿！有遇到Kafka数据丢失问题的问题吗，你是如何解决的？今天的文章，V哥来详细解释一下，整理了12种解决策略，希望可以帮助你解决项目中的问题：以下是一些常见的解决方案和最佳实践。
生产者确认机制：生产者可以使用 Kafka 的确认机制来确保消息成功发送到 Kafka 集群。生产者可以选择等待 Kafka 的确认响应（acks）或使用同步发送方式，以确保消息不会丢失。
增加副本因子：通过增加 Kafka 主题的副本因子，可以提高消息的可靠性。副本因子决定了每个分区的副本数量，增加副本数量可以提高消息的冗余度，降低消息丢失的风险。
监控和警报：设置监控和警报系统，及时发现和处理消息丢失的问题。可以监控生产者和消费者的指标，如发送速率、确认率和消费速率等，以及 Kafka 集群的状态和健康状况。
合理的配置和容量规划：根据应用程序的需求和负载情况，合理配置 Kafka 集群和主题的参数。确保足够的存储空间、网络带宽和处理能力，以避免由于资源不足而导致的消息丢失。
设置生产者的 acks 参数为 "all"：这将确保生产者在收到所有副本的确认后才认为消息发送成功，从而实现零丢失的配置。
调整日志存储空间和最大消息大小：根据实际需求调整 Kafka 集群的参数，如日志存储空间、最大消息大小、最大连接数等。
使用压缩：Kafka 支持 GZip 和 Snappy 压缩，这可以减少网络和磁盘 IO，同时缓解因资源限制导致的数据丢失问题。
关闭自动提交 offset：在消费者端，关闭自动更新 offset，等到数据被处理后再手动更新 offset，以避免数据丢失。
确保 broker 配置正确：broker 能接收消息的最大字节数的设置一定要比消费端能消费的最大字节数要小，以避免 broker 因为消费端无法使用这个消息而挂起。
使用同步复制：当配置了同步复制之后，多个副本的数据都在 PageCache 里面，出现多个副本同时挂掉的概率就很小了。
调整 flush 间隔：通过 log.flush.interval.messages 和 log.flush.interval.ms 配置 flush 间隔，以减少因 flush 间隔设置不当导致的数据丢失。
避免使用 unclean leader 选举：关闭 unclean.leader.election.enable，以避免非 ISR 中的副本被选举为 leader，这可能导致数据丢失。
通过这些方法，可以显著减少 Kafka 中的数据丢失问题，并提高系统的可靠性和稳定性。
下面，V哥针对12个策略再详细介绍实现步骤，并结合业务场景分析和示例代码来讲解，希望给你一个全面细致的了解。
1. 生产者确认机制 在 Kafka 中，生产者确认机制是指生产者在发送消息到 Kafka 集群后，根据配置的确认级别（acks）等待来自 Kafka 集群的响应。这是确保消息不会丢失的关键步骤。以下是生产者确认机制的具体实现步骤和 Java 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c4cf43191a058e885acdff15944e44e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b9dee0c0be2f517457fb8d1e6be3ac/" rel="bookmark">
			有哪些技术可代替docker?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker是用于创建和管理容器化应用程序的流行平台，但市场上也存在多种Docker的替代方案。
前言 国内使用Docker的困难现象，无疑是一个值得深入剖析和批判的问题。Docker作为一种容器化技术，以其轻量级、可移植性和高效性在全球范围内得到了广泛应用。
我们需要正视国内使用Docker的困难所在。尽管Docker提供了诸多便利，但在面对这些困难时，我们也需要考虑寻找替代方案。这并不是说Docker本身不可行，而是在特定环境下，我们需要根据实际需求来做出最佳选择。
寻求替代方案并不意味着我们要完全放弃容器化技术，而是要在保持技术先进性的同时，找到更适合当前环境的解决方案。这些替代方案可能包括使用国内的镜像仓库、采用其他容器化技术或者构建私有的容器平台等。
技术选择应该基于实际需求和环境考虑。Docker虽好，但并非万能。在面临困难时，我们需要勇于尝试新的解决方案，以确保技术的持续发展和应用的顺利进行。
以下是几种技术，它们可以作为Docker的替代选择：
Podman： Podman由RedHat开发，是一个无守护程序、开源、Linux原生容器引擎。
它用于构建、运行和管理Linux OCI容器和容器镜像。
Podman与Docker的一个显著区别是它不依赖守护进程（dockerd）来工作，而是使用运行时进程直接与Linux内核和注册表交互。
Podman不需要root访问权限，为额外的安全缓冲区限制了潜在的危险进程。
Podman支持多种容器格式，如OCI和Docker容器格式，并与Kubernetes兼容。
ZeroVM： ZeroVM是一个基于谷歌Chromium Native Client的开源虚拟环境。
它是一个用于嵌入应用程序的隔离平台，启动时间更短，节省了处理能力。
ZeroVM不虚拟化完整的操作系统，而是仅虚拟化运行应用程序的空间，以促进更快的部署。
它为未经验证的代码提供了安全性，并具有在没有内核或操作系统的情况下隔离每个进程的独特能力。
OpenVZ： OpenVZ是一种基于Linux的容器化技术。
它具有类似于Docker的特性和功能，但其工具集允许执行应用程序部署之外的任务。
OpenVZ是一个托管虚拟服务器的管理程序，具有分布式云存储、管理工具和专用支持等功能。
在一台服务器上，可以使用OpenVZ创建多个独立的Linux容器，每个容器都有独立的root访问权限，避免了冲突应用程序的风险。
LXD： LXD是一个专为LXC Linux容器设计的开源容器引擎。
它提供了一个用于连接LXC软件库的接口，并创建了一个守护进程来处理网络、数据存储和管理多个LXC容器。
与Docker建议每个容器只有单个进程的设计模式不同，LXD提供了更多的功能和灵活性。
以上技术都是在容器化领域与Docker竞争或提供类似功能的替代方案。选择哪种技术取决于具体的需求、应用场景和偏好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d3460ec74adb5d98ffb2b64353068c/" rel="bookmark">
			制造业为什么需要ERP企业管理软件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今，传统的制造业管理方式逐渐变得力不从心~库存积压、生产效率低下、供应链混乱…想象一下，如果你的企业仍然依赖于手工记录订单、库存和财务数据，那么每当市场发生变动时，你就需要花费大量的时间和精力去重新调整生产计划、更新库存数据、核算财务成本。这不仅效率低下，而且容易出错，给企业带来不可估量的损失。
而ERP系统能够：
帮助企业打破信息孤岛，实现各部门之间的无缝对接和协同工作。实时收集和分析企业的业务数据和市场数据，为企业提供准确的市场分析和预测结果，帮助企业更好地把握市场趋势和客户需求。能够优化企业的生产流程、提高生产效率、降低运营成本，让企业在激烈的市场竞争中立于不败之地。............. 因此，对于制造业企业来说，引入ERP系统已经成为了一项紧迫而必要的任务。
那么，ERP系统究竟是是什么？
ERP系统如何在制造业中发挥作用的？
ERP系统的优势是什么？接下来一起来探讨。
简道云ERP系统模板，可以直接查看和使用：https://www.jiandaoyun.com
首先，ERP系统是一种集成化的企业管理软件，它能对企业内部各个部门和业务流程进行整合和优化，ERP系统涵盖了供应链管理、生产管理、财务管理、人力资源管理、客户关系管理等多个方面，能够为企业提供全面的管理支持。
而在制造业中，企业可以通过ERP系统实现对供应链的全面管理，包括供应商管理、采购管理、库存管理、销售管理等。同时，ERP系统还能够对生产过程进行实时监控和数据分析，帮助企业优化生产流程、提高生产效率。此外，ERP系统还能够整合企业的财务数据和业务数据，提供全面的财务分析和决策支持。
那制造业为什么需要ERP系统？ 在制造业中，企业常常面临着多方面的困难，这些困难不仅影响了生产效率，也限制了企业的发展。以下是几个主要的困难点：
数据分散与不一致：在制造业的日常运营中，数据分散在各个部门和环节，且常常出现数据不一致的情况。这使得企业难以对整体运营状况有清晰的认识，无法做出基于全面数据的决策。流程繁琐与效率低下：在没有ERP系统的情况下，制造业的流程和操作往往繁琐而低效。例如，订单处理、库存管理、生产计划等环节需要手动进行，耗费大量时间和人力。供应链管理不善：供应链是制造业的核心，但缺乏有效的管理工具，往往导致供应链管理不善。这包括供应商管理、采购管理、库存管理等方面的问题。风险管理能力不足：制造业在运营过程中面临着各种风险，如市场风险、财务风险、生产风险等。没有ERP系统的情况下，企业难以对这些风险进行及时识别和应对。 为了解决这些问题，引入ERP系统成为企业的必然选择，ERP系统可以通过集成化的管理、自动化的流程、全面的供应链管理和强大的风险管理功能，可以帮助企业优化运营，提高竞争力。
使用ERP系统的制造业的优势在哪些方面~ 一、提升运营效率 ERP系统通过自动化和集成不同业务部门的功能，显著提升制造企业的运营效率。这一效率提升主要来自以下几个方面：
自动化业务流程：ERP系统能够自动处理许多重复性的日常任务，如库存管理、生产计划和财务核算。这不仅减少了人为错误的机会，还释放了员工的时间，使他们能专注于更具策略性的工作。 实时数据共享：不同部门之间的信息能够快速传递，无需人为手动更新，确保各部门在同一时间获得准确的数据。这种实时的协作极大地提高了业务流程的效率，并能够快速响应市场变化。 减少数据冗余：传统业务系统中，数据往往会在多个系统中重复存储，造成严重的数据冗余和一致性问题。ERP系统通过一个统一的数据库，确保数据的一致性和准确性，有效减少了冗余。提升资源利用率：ERP系统能够优化资源分配，包括人力、设备和原材料的使用。这种优化不仅提升了生产效率，还有效降低了运营成本。 二、优化资源管理 资源管理在制造业中至关重要，ERP系统通过以下方式实现了资源的优化：
精确库存管理：ERP系统能够实时监控库存状态，避免因缺货导致的生产中断或因过量库存增加的存储成本。因此，企业能够更准确地预测需求，优化库存水平。 高效生产排程：通过集成的生产计划和排程功能，ERP系统能够根据资源的可用性、订单的优先级和交货时间，制定最优化的生产计划。这不仅提高了设备和工人的利用率，还减少了生产周期和生产成本。 全方位成本控制：ERP系统可以全面跟踪从采购、生产到销售的全过程，实时监控各个环节的成本，帮助企业识别和消除过度开支的部分，实现精细化成本控制。 人力资源优化：借助ERP系统的人力资源管理模块，企业能够更有效地进行人力资源规划和调配，确保在高需求时期能够迅速调配和补充所需劳动力，同时避免在淡季因人力过剩而产生不必要的成本。 三、提高决策能力 ERP系统通过数据集成和分析工具，显著提高了企业的决策能力。以下是具体方面：
数据可视化：ERP系统提供丰富的数据可视化工具，如仪表板和图表，帮助管理层快速理解和分析复杂的数据。这种可视化工具使得管理层能够更直观地看到企业绩效和运营状态，为决策提供有力支持。 实时数据分析：ERP系统能够实时处理和分析企业运营中的海量数据，为管理层提供及时的运营报告。这些实时数据和分析结果使得企业能够迅速识别潜在问题和市场机会，并作出相应的调整。历史数据存档：ERP系统保存了企业运营中的所有历史数据，这些数据可用作未来决策的参考。如销售趋势、生产效率和成本分析等，通过历史数据的比对，企业可以制定更加科学和有依据的战略决策。 预测分析：基于大数据和机器学习技术，ERP系统能够进行精确的需求预测和市场分析，辅助企业制定长期战略和短期战术决策。 四、增强数据透明度 数据透明度是ERP系统的另一个重要优势，这不仅提高了企业内部的信息流动性，还促进了诚信和合规性。
统一数据平台：ERP系统将企业各个业务部门的数据集成在一个统一的平台上，确保所有数据来源的透明性和一致性，各部门之间能够共享同一版本的数据和信息。 实时跟踪：ERP系统能够实时监控生产过程、库存水平、采购订单和销售活动，这种实时跟踪提高了业务透明度，使管理层能够及时识别并处理潜在问题。增强审计能力：由于ERP系统记录了所有业务操作的详细信息，企业能够轻松地进行内部审计和外部审计。完整的数据记录不仅确保了业务过程的透明性，还满足了各种合规性要求。用户访问控制：ERP系统提供了详细的用户权限管理功能，不同角色的用户只能访问与其职责相关的数据和功能，这不仅保证了数据的安全性，还提高了操作的透明性。 五、改进客户服务质量 ERP系统通过优化业务流程和提高数据管理能力，直接改进了客户服务质量。
订单跟踪和处理：ERP系统能够实时跟踪从订单生成到交付的全过程，确保订单处理的及时和准确。客户服务团队可以快速查找订单状态，并及时向客户反馈相关信息，提高客户满意度。 客户关系管理（CRM）：ERP系统集成了客户关系管理功能，帮助企业记录和分析客户的历史数据和互动行为，为客户提供个性化和有针对性的服务，从而提高客户忠诚度。 快速响应市场需求：通过ERP系统的需求预测和库存管理功能，企业能够更灵活地调整生产计划和库存水平，快速响应客户的需求变化，提高客户的服务体验。提高售后服务质量：ERP系统能够记录客户的售后服务请求和处理状态，帮助企业及时跟进和解决客户问题，提高售后服务质量和客户满意度。 六、支持业务增长 ERP系统不仅优化了企业的现有业务流程，还为未来的业务增长提供了坚实的支持。
扩展性和可定制性：现代ERP系统具备高度的扩展性和可定制性，可以根据企业的业务增长和变化需求进行扩展和调整，确保系统能够随企业一起成长。 数据驱动的创新：通过ERP系统提供的数据分析和报告功能，企业可以识别市场趋势和创新机会，制定创新战略和新产品开发计划，推动长期业务增长。集成新业务模式：ERP系统能够集成和支持不同业务模式，如电子商务、数字化制造和供应链协同等，帮助企业迎接数字化转型的挑战，实现业务模式的多样化和持续增长。 分享一个简道云ERP在制造业中的应用——科林电气：专精特新“小巨人”企业的数字创新指南 科林电气设备有限公司就是一家“专精特新”小巨人企业，其母公司石家庄科林电气股份有限公司是一家集研发、生产、销售、服务为一体的上交所A股主板上市公司，凭借优质的产品和服务参与了众多国家重点项目建设。
痛点： 随着公司业务规模的持续扩大，事业部发现整个生产过程的管理，越来越难以面面俱到，管理成本越来越高，生产管理信息化的需求逐步显现。
比如在报工环节：
员工的工作量需要往上级报，这些依然在用纸质记录，层层上报，多人审核。导致每个月计算绩效和工资的时候，负责人很头疼——数据量越来越大，工序拆分越来越细，统计也越来越麻烦；生产中一旦产生异常，很难追根溯源。
再比如在库存管理环节：
开关柜的装配都是定制化的生产，一旦BOM出现错误，就会导致错料，多料等问题发生，产生呆滞库存。传统的管理方式信息很难共享，呆滞料消耗困难，造成库存的浪费。
还有很多问题，体现在车间管理中：
许多动作缺乏有效的执行、监督工具，落地的效果不理想。
解决方案： 要解决业务中产生的难题，首先需要把生产流程搬到线上。于是，事业部搭建了第一个应用——透明工厂。
制造车间里的每个产品都配有一个唯一的二维码，员工在产线上用手机扫码即可填写生产工单，并按照设计好的流程流转。管理人员不需要每月额外安排人手计算工时、绩效、工资，只要在电脑/手机点一点就能在仪表盘上看到生产统计情况。 有了大量的生产数据的积累与分析，标准工时更加准确，为自动化排产奠定了坚实的基础。每个项目都有对应的BOM，从生产过程中的物料领用到生产完成的实际用量都需要在简道云中登记，通过简道云“数据工厂”进行运算比对，发现制造过程中的各种隐性问题，减少浪费。库存管理应用搭建完成后，物料无论是否在账全部扫码登记，和生产任务创建的出料进行联动。 看到这里，ERP给制造业带来的益处太多，而简道云ERP作为一款适用于制造业的ERP系统，具有灵活定制、易用性高、高度集成、数据可视化和安全性高等优势，能够帮助制造业企业实现数字化转型和升级。
因此，制造业企业应该积极引入ERP系统，并选择适合自己的ERP系统供应商和实施团队来推进系统的实施和优化工作。通过ERP系统的应用，制造业企业可以更好地应对市场挑战和客户需求，提高企业的竞争力和盈利能力。
希望对大家有所帮助~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632f40c3676195ab329ea8216b3609e7/" rel="bookmark">
			查看服务器端口，如何查看服务器端口是多少并修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看服务器端口并修改内容是一个涉及网络管理和系统配置的专业任务。以下是一个详细的步骤说明，用于查看和修改服务器端口。
一、查看服务器端口
1. 使用命令行工具：
- 对于Linux或Unix系统，可以使用`netstat`、`lsof`或`ss`等命令来查看端口状态。例如，`netstat -tuln`命令可以列出所有正在监听的TCP和UDP端口。
- 对于Windows系统，可以使用`netstat -ano`命令来查看端口状态。该命令将显示每个端口的进程ID，从而可以追踪到哪个应用程序正在使用该端口。
2. 使用图形界面工具：
- 许多服务器管理软件都提供了图形界面来查看和管理端口。这些工具通常具有更直观的用户界面，方便非专业用户进行操作。
二、修改服务器端口
1. 修改应用程序配置：
- 如果要修改的是特定应用程序使用的端口，通常需要在该应用程序的配置文件中进行更改。这涉及到编辑配置文件并修改端口号，然后重新启动应用程序以使更改生效。
2. 使用防火墙规则：
- 在某些情况下，可能希望通过防火墙规则来重定向或映射端口，而不是直接修改应用程序配置。这可以通过配置防火墙软件来实现，例如iptables（Linux）或Windows防火墙（Windows）。
3. 修改系统级端口配置：
- 对于某些服务（如SSH、FTP等），可能需要修改系统级的配置文件来更改端口号。这通常涉及到编辑特定于服务的配置文件，并重新启动相关服务以使更改生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e2ab4bc70d0843a081f237ae6efd59/" rel="bookmark">
			MySQL数据库课程设计——订餐系统（MySQL数据库&#43;Qt5用户界面&#43;python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、系统定义
二、需求分析
三、系统设计
四、详细设计
五、参考文献
一、系统定义 订餐系统是一种基于网络技术的在线点餐平台，旨在为用户提供方便快捷的订餐服务。该系统主要包括用户登录、用户管理、菜单管理、订单管理、支付管理、评价管理等功能模块，用户可以通过系统浏览菜品、下单、支付、评价等操作，商家可以通过系统管理菜品、接收订单、配送等操作。（#系统采用python连接MySQL数据库的形式，前端使用QT Designer等技术，后端使python语言，数据库采用MySQL。）系统具有安全、稳定、高效、易用等特点，可以满足用户对订餐服务的需求。
二、需求分析 系统综合需求 用户需求 易用性：订餐系统的操作应该简单易懂，用户可以快速完成订餐、支付等操作。安全性：用户的个人信息应该得到保护，系统应该采用安全的加密技术，防止用户信息被窃取。多样性：系统应该支持多种支付方式，满足不同用户的需求。反馈机制：用户可以对订餐体验进行评价和反馈，系统应该及时处理用户的反馈意见。商家需求 管理功能：商家可以对菜品、订单、库存等进行管理，方便商家进行经营管理。数据分析功能：系统应该提供数据分析功能，帮助商家了解用户的消费习惯和需求，为商家提供决策依据。营销功能：系统应该提供多种营销功能，如优惠券、满减等，吸引用户进行消费。订单管理：商家可以通过系统对订单进行管理，方便商家进行配送和服务。技术需求 稳定性：系统应该具备高稳定性，能够保证系统的正常运行。安全性：系统应该采用安全的技术手段，保护用户的个人信息和交易安全。扩展性：系统应该具备良好的扩展性，能够满足未来的业务发展需求。兼容性：系统应该具备良好的兼容性，能够适应不同的操作系统和浏览器。系统逻辑模型 1．数据流图：
图1 系统数据流图
2．数据字典
表1 系统数据字典
编号
属性名
类型
解释
备注
1
员工号
varchar(10)
无
5位数字
2
员工姓名
varchar(10)
无
无
3
登陆密码
varchar(100)
无
8位密码
4
职位
tinyint(1)
0:管理人员 1:员工 2:厨师
无
5
在职情况
bit(1)
是否在职（0/1）
无
6
顾客编号
varchar(10)
无
6位编号
7
顾客姓名
varchar(20)
无
无
8
顾客性别
varchar(5)
无
无
9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e2ab4bc70d0843a081f237ae6efd59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/010c1780af31b4c41a78a0e5e81c12b5/" rel="bookmark">
			react 自定义鼠标右键点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能：鼠标右键点击节点时，出现“复制”功能，点击其他部位，隐藏“复制”；鼠标右键事件的文案，始终在鼠标点击位置的右下方；点击复制，提示复制成功
效果图：
代码：
const [showRight,setShowRight] = useState(false); const contextMenu = useRef(null); const [clickX,setClickX] = useState('0px'); const [clickY,setClickY] = useState('0px'); ------------ &lt;div className='topology-node' onContextMenu={(e)=&gt; handleRight(e)} &gt; 这里面是图中的节点，只有右键双击图中节点，才会触发自定义的右键事件功能 &lt;/div&gt; ------------ // 鼠标右键展示的内容，注意这里的样式rightStyle，鼠标右键时菜单的位置（图中“复制”的位置）就是靠这个样式控制的 {showRight&amp;&amp;&lt;div className='right-panel' onClick={handleRightCopy} style={rightStyle}&gt;复制&lt;/div&gt;} ------------ useEffect(()=&gt;{ // 监听其他地方的点击事件 document.addEventListener('click', _handleClick); }) ------------ // 事件 const handleRight =(event:any) =&gt;{ setShowRight(true) // event.clientX event.clientY 鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标） setClickX(event.clientX); setClickY(event.clientY); } // 右键菜单的位置，加减多少看自己，位置看着舒服就行 const rightStyle = { left:`${clickX + 5}px`, top: `${clickY + 5}px` } const _handleClick =(event:any)=&gt;{ const wasOutside = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/010c1780af31b4c41a78a0e5e81c12b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a118bc8061fcc8c6e0ed44d144315a50/" rel="bookmark">
			3D三维模型展示上传VR全景创建H5开源版开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3D三维模型展示上传VR全景创建H5开源版开发
新增三级分类（项目分类、项目、默认场景）
新增热点
前台创建项目、场景
场景跳转、提示信息
新增热点图标选择
新增预览场景是显示关联场景
新增3D模型展示功能
当然可以！以下是一个关于3D三维模型展示、上传、VR全景以及H5功能的基本列表：
3D模型展示：
支持多种格式的3D模型上传和展示，如OBJ、FBX、GLTF等。可以实现模型的旋转、缩放和移动，以便用户可以全方位查看模型细节。 上传功能：
用户能够通过界面直接上传自己的3D模型文件。支持大文件的快速上传和处理，保证用户体验流畅。 VR全景：
将3D模型转换为VR全景，使用户可以在虚拟现实环境中观察模型。支持不同VR设备，如Oculus Rift、HTC Vive等，以及WebVR技术。 H5功能：
制作交互式H5页面，嵌入3D模型展示。支持在移动设备上浏览和操作，通过触摸手势控制模型的旋转和缩放。 用户交互：
提供用户评论和评分功能，增强用户参与和反馈。用户可以分享他们喜欢的模型和VR全景至社交媒体。 定制化和扩展：
允许开发者定制界面和功能，以满足特定的商业需求。提供API和SDK，支持与其他平台和系统集成。 以上功能列表可以帮助你构建一个功能强大的3D模型展示、VR全景和H5交互体验平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f12eeeac9d5a88b5ac68b5f5a85bdbb/" rel="bookmark">
			JAVA的优势是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开始前刚好我有一些资料，是我根据网友给的问题精心整理了一份「java的资料从专业入门到高级教程」，
点个关注在评论区回复“666”之后私信回复“666”，全部无偿共享给大家！！！
java编程语言自1995年问世以来，一直是软件开发领域中的重要工具，广泛应用于企业级应用、移动应用、大数据、云计算等多个领域。Java之所以能够在众多编程语言中脱颖而出并持续保持其重要地位，其优势不可忽视。
跨平台性 Java最显著的优势之一是其跨平台能力，这得益于其“写一次，处处运行”（Write Once, Run Anywhere）的理念。Java程序编译成字节码（Bytecode），可以在任何安装了Java虚拟机（JVM）的操作系统上运行，无论是Windows、Linux还是macOS，甚至嵌入式系统和移动设备。JVM提供了一种抽象层，屏蔽了底层操作系统的差异，使得开发者无需针对不同的平台进行多次开发和维护，极大地提高了开发效率和系统的一致性。
最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。这是大佬写的， 七千页的BAT大佬写的刷题笔记，让我offer拿到手软
强大的标准库和丰富的开源生态 Java拥有丰富的标准库（Java Standard Library），涵盖了从数据结构、网络编程、文件I/O、数据库连接到图形用户界面开发等方方面面。开发者可以直接利用这些功能强大的库，减少重复造轮子的时间和精力。同时，Java社区活跃且庞大，拥有丰富的开源框架和工具，如Spring、Hibernate、Apache Commons等，这些框架和工具大大简化了开发复杂应用的难度，加快了开发进程。
强类型系统与面向对象编程 Java是一种强类型语言，所有变量必须先声明后使用，其编译器在编译阶段进行严格的类型检查，有助于早期发现代码中的错误，提高代码的安全性和可靠性。此外，Java是一种面向对象的编程语言，支持封装、继承、多态等面向对象的基本特性。通过面向对象的编程理念，开发者可以构建具有高内聚、低耦合的模块化代码，增强代码的可维护性和可重用性。
性能与可伸缩性 尽管Java最初因为使用JVM而被认为性能不如直接编译成机器码的语言（如C、C++），但经过多年的优化，现代的JVM在性能方面有了显著提升。Java的即时编译器（JIT）可以在运行时将字节码动态编译成高效的机器码，并进行多种优化，使得Java应用的运行速度接近甚至达到原生编译语言的水平。此外，Java在处理并发和大规模分布式系统方面表现出色，其多线程机制和并发库（java.util.concurrent）为开发高性能、高可伸缩性的应用提供了有力支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a80a40ec9ab1ae4c02e53471aeeeba6/" rel="bookmark">
			聆思CSK6大模型&#43;AI交互多模态开源SDK介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视觉语音大模型 AI 开发套件( CSK6-MIX )是围绕 CSK6011A 芯片设计的具备丰富语音图像功能与硬件外设的开发板，采用具备丰富组件生态的 Zephyr RTOS作为操作系统，官方提供了十几种开源SDK，包含大模型语音交互、大模型拍照识图、文生图、人脸识别、头肩追踪、手势识别、坐姿提醒等。
聆思科技还提供了模型训练推理工具将自己的算法模型部署至芯片上，也可以配合这个工具构建自己的 AI 应用。
语音交互与识图 功能介绍 SDK主要包含以下功能：
●语音交互：支持按键录音或唤醒后通过语音与大模型进行对话
●拍照识图：支持通过摄像头拍摄图像并上传给大模型进行识别，支持依据识图内容进行提问
●图片生成：支持通过语音交互描述画面内容，令大模型生成图片并显示至套件屏幕上
语音交互模式 支持的语音交互模式 多模态SDK支持三种交互方式，其特点如下：
模式
唤醒方式
交互方式
按键交互
按下屏幕麦克风图标或开发板K3按键
按住按键说话，松开提交
语音唤醒(单轮)
唤醒词 “小美小美”
听到提示音 “在呢” 后进行提问，每次提问均需要唤醒
语音唤醒(多轮)
唤醒词 “小美小美”
听到提示音 “在呢” 后进行提问，可持续对话，当超过20秒无语音输入时自动结束本次交互
语音交互模式的切换 在待机页面，下滑可调出下滑菜单，点击下滑菜单中的 设置图标，可进行配置页面：
选中对应的模式后，点击左上角即可回到待机页面并生效。
按键交互模式 设置成按键交互(按键唤醒)模式下，按住屏幕上的麦克风按钮或开发板上的K3按键，即进入录音状态，松开按键则结束录音并提交。
语音唤醒模式 当设置为语音唤醒(单轮)或语音唤醒(多轮)，可通过唤醒词 —— “小美小美” 对设备进行唤醒，当听到 “在呢” 的提示音后，即可正常进行语音输入。
退出对话 在使用过程中，点击左上角即可结束本轮对话回到待机页面，此操作会同步清除本次对话的上下文信息。
拍照识图 在待机页，点击拍照按钮即可进入取景页面，对准要拍照的物体，点击右侧中间的拍照键完成抓拍，确认画面抓拍正常后（无晃动模糊的情况），点击右侧的 √ 进行提交识别：
文生图 在设备进入语音交互状态后，可以通过带有绘画意图的提示词让大模型进行作画，比如：
●“画一只熊猫”
●“画一个人正在使用电脑”
图片生成与设备控制 功能介绍 本示例主要包含以下功能：
可通过“小聆小聆”对设备进行唤醒可通过语音交互与大模型进行对话可通过语音交互使用大模型绘制图片并显示在屏幕上可通过语音交互通过大模型控制屏幕显示的颜色支持通过LSPlatfrom接入自己的大模型应用 大模型语音对话功能 我们可以通过 “小聆小聆” 唤醒词对开发套件进行唤醒套件被正常唤醒时，会播放应答语 —— "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a80a40ec9ab1ae4c02e53471aeeeba6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/252/">«</a>
	<span class="pagination__item pagination__item--current">253/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/254/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>