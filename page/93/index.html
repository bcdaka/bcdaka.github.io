<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d558b7ab82e43c0548e51dd826e80896/" rel="bookmark">
			Flink-StarRocks详解:第三部分StarRocks分区分桶(第53天)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言2.3 数据分布2.3.1 数据分布概览2.3.1.1 常见的数据分布方式2.3.1.2 StarRocks的数据分布方式2.3.1.3 分区2.3.1.4 分桶 2.3.2 创建分区2.3.2.1 表达式分区2.3.2.1.1 时间函数表达式分区（自v3.1）2.3.2.1.2 列表达式分区（自v3.1） 2.3.2.2 Range 分区2.3.2.3 List分区2.3.2.3.1 功能介绍2.3.2.3.2 使用方式2.3.2.3.2.1 语法2.3.2.3.2.2 参数说明2.3.2.3.2.3 示例 2.3.2.3.3 使用限制 2.3.2.4 手动创建分区2.3.2.5 批量创建分区2.3.2.6 动态分区 前言 本文为Flink-StarRocks详解后续章节：主要详解StarRocks分区分桶
由于篇幅过长，后续接着下面进行详解：
 StarRocks查询数据湖
 实现即席查询案例
2.3 数据分布 建表时，可以通过设置合理的分区和分桶，实现数据均匀分布和查询性能提升。数据均匀分布是指数据按照一定规则划分为子集，并且均衡地分布在不同节点上。查询时能够有效裁剪数据扫描量，最大限度地利用集群的并发性能，从而提升查询性能。
说明
自 2.5.7 版本起，在建表和新增分区时可以不设置分桶数量 (BUCKETS)。StarRocks 默认自动设置分桶数量，如果自动设置分桶数量后性能未能达到预期，并且比较熟悉分桶机制，则也可以手动设置分桶数量。
自 3.1 版本起，在建表和新增分区时可以不设置分桶键（即 DISTRIBUTED BY 子句）。StarRocks 默认使用随机分桶，将数据随机地分布在分区的所有分桶中。
2.3.1 数据分布概览 2.3.1.1 常见的数据分布方式 现代分布式数据库中，常见的数据分布方式有如下几种：Round-Robin、Range、List 和 Hash。如下图所示：
 Round-Robin：以轮询的方式把数据逐个放置在相邻节点上。
 Range：按区间进行数据分布。如上图所示，区间 [1-3]、[4-6] 分别对应不同的范围 (Range)。
 List：直接基于离散的各个取值做数据分布，性别、省份等数据就满足这种离散的特性。每个离散值会映射到一个节点上，多个不同的取值可能也会映射到相同节点上。
 Hash：通过哈希函数把数据映射到不同节点上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d558b7ab82e43c0548e51dd826e80896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc22e8c379fbea558018d842440f2c40/" rel="bookmark">
			Git常用命
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/ahjxhy2010/article/details/80047553
1.查看某个文件或目录的修改历史 git log filename #查看fileName相关的commit记录 git log -p filenam # 显示每次提交的diff #只看某次提交中的某个文件变化，commit-id 文件名 git show c5e69804bbd9725b5dece57f8cbece4a96b9f80b filename git log --oneline #每笔提交只显示一行 # 查看当前目录下的提交记录，-n 是个数 git log -n 10 --stat . 2.查看暂存区 git ls-files //查看暂存区中文件信息 如何查看暂存区中bb.txt文件内容是什么？
git ls-files -s -- 文件名 或者直接 git ls-files -s //然后通过Blob对象，查询bb.txt里面的内容： git cat-file -p 6cef git stash //可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 //把工作区和暂存区的内容都存起来 git stash list //查看暂存内容 git stash pop //恢复的同时把stash内容也删了 git stash clear //清空所有的内容 git stash drop stash@{0} //这是删除第一个队列 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc22e8c379fbea558018d842440f2c40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db58e140369b1106cefd648d6b0be67/" rel="bookmark">
			在CentOS 7上安装Apache Tomcat 8的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
介绍 Apache Tomcat 是一个用于提供 Java 应用程序的 Web 服务器和 Servlet 容器。Tomcat 是由 Apache 软件基金会发布的 Java Servlet 和 JavaServer Pages 技术的开源实现。本教程涵盖了在 CentOS 7 服务器上安装和配置最新版本的 Tomcat 8 的基本步骤。
先决条件 在开始本指南之前，您应该在服务器上设置一个单独的非根用户帐户。您可以通过完成 CentOS 7 的初始服务器设置中的步骤 1-3 来学习如何做到这一点。我们将在本教程的其余部分中使用在此处创建的 demo 用户。
安装 Java Tomcat 要求在服务器上安装 Java，以便执行任何 Java Web 应用程序代码。让我们通过使用 yum 安装 OpenJDK 7 来满足这一要求。
要使用 yum 安装 OpenJDK 7 JDK，请运行以下命令：
sudo yum install java-1.7.0-openjdk-devel 在提示时输入 y 继续安装 OpenJDK 7。
请注意，我们稍后需要配置 Tomcat 的 JAVA_HOME 目录的快捷方式可以在 /usr/lib/jvm/jre 找到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db58e140369b1106cefd648d6b0be67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009d88de267530e08968434669583a2d/" rel="bookmark">
			matplotLib在图中标出最后一个点的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import matplotlib.pyplot as plt import numpy as np # 生成100个随机数据 data = np.random.rand(100) # 绘制数据 plt.plot(data, label='Data Points') # 获取最后一个数据点的位置和值 last_x = len(data) - 1 last_y = data[-1] # 用红圈标出最后一个点 plt.plot(last_x, last_y, 'ro') # 在图上标出最后一个点的值 plt.annotate(f'{last_y:.2f}', xy=(last_x, last_y), xytext=(last_x + 2, last_y), fontsize=12, # 字体大小 color='red' # textcoords='offset points', # ha='left', # va='bottom' ) # 设置标题和坐标轴标签 plt.title('Plot with Last Data Point Highlighted and Labeled') plt.xlabel('Index') plt.ylabel('Value') # 显示图形 plt.legend() plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009d88de267530e08968434669583a2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439ca4349c137571ce64b633af3d220c/" rel="bookmark">
			【C&#43;&#43;进阶学习】第十一弹——C&#43;&#43;11（上）——右值引用和移动语义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
前面我们已经将C++的重点语法讲的大差不差了，但是在C++11版本之后，又出来了很多新的语法，其中有一些作用还是非常大的，今天我们就先来学习其中一个很重要的点——右值引用以及它所扩展的移动定义
目录
一、左值引用和右值引用
左值引用 右值引用
二、左值引用与右值引用的比较
三、右值引用的使用
移动构造
移动赋值
四、总结
一、左值引用和右值引用 左值引用 左值引用是最常见的引用类型，通常用于绑定到一个左值。左值是一个具有名称的对象，可以取地址，通常出现在赋值操作符的左边。（简单的说，能取地址的就是左值）
语法：
类型 &amp;引用名 = 左值; 示例：
int a = 10; int &amp;refA = a; // refA是一个左值引用，绑定到左值a 特点：
左值引用必须初始化，并且只能绑定到左值。左值引用可以修改绑定的对象。 右值引用 右值引用是C++11引入的新特性，用于绑定到一个右值。右值是一个临时对象，通常没有名称，不能取地址，通常出现在赋值操作符的右边。（右值不能取地址，比如常量）
语法：
类型 &amp;&amp;引用名 = 右值; 示例：
int &amp;&amp;refB = 20; // refB是一个右值引用，绑定到右值20 特点：
右值引用必须初始化，并且只能绑定到右值。右值引用主要用于实现移动语义和完美转发。 有一个需要强调的是，常变量虽然也属于常量，但是它可以取地址，所以它属于左值
二、左值引用与右值引用的比较 左值引用：
1. 左值引用只能引用左值，不能引用右值。 2. 但是const左值引用既可引用左值，也可引用右值 int main() { // 左值引用只能引用左值，不能引用右值。 int a = 10; int&amp; ra1 = a; // ra为a的别名 //int&amp; ra2 = 10; // 编译失败，因为10是右值 // const左值引用既可引用左值，也可引用右值。 const int&amp; ra3 = 10; const int&amp; ra4 = a; return 0； } 右值引用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/439ca4349c137571ce64b633af3d220c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7bca482ac83c3f0459102d54a28457f/" rel="bookmark">
			React三原理和路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码下载 React 组件通讯原理 setState() 说明 setState() 是异步更新数据的，使用该语法时，后面的 setState() 不要依赖于前面的 setState()，可以多次调用 setState() ，只会触发一次重新渲染：
this.setState({ count: this.state.count + 1 }) console.log('count: ', this.state.count); this.setState({ count: this.state.count + 1 }) console.log('count: ', this.state.count); 推荐使用 setState((state, props) =&gt; {}) 语法，参数state表示最新的state，参数props表示最新的props：
this.setState((state, props) =&gt; { console.log('第一次 count: ', state.count); return { count: state.count + 1 } }) this.setState((state, props) =&gt; { console.log('第二次 count: ', state.count); return { count: state.count + 1 } }) console.log('count: ', this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7bca482ac83c3f0459102d54a28457f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1acb10464c033cc7196a9b42c5e68d9/" rel="bookmark">
			IDEA切换分支，会影响当前在跑的项目吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：本文测试，在IDEA中运行项目，然后切换分支，是否会影响当前正在跑的项目
准备工作 首先，创建一个Git项目，接口如下：
import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class DemoController { @GetMapping("/demo") public String demo() { return "hello"; } } 启动项目，测试接口
当前分支为main分支
测试 此时，切换另一个分支，test-hello分支
此分支修改代码如下：
import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class DemoController { @GetMapping("/hello") public String demo() { return "hello"; } } 项目没停，此时访问接口，内容依旧如下，说明切换分支对当前正在跑的项目没有影响；
总结 IDEA切换分支，对当前在跑的项目没有影响
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4236337741afc7ce611ec84cc028996/" rel="bookmark">
			【玩转python】入门篇day14-函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、函数的定义 函数通过def定义，包括函数名、参数、返回值
# 定义函数 def test(a,b): # a,b表示形式参数 print(a + b)#函数体(具体的功能) return a*b #返回值 # 函数调用 test(12,43) # 12和43表示实际参数,在调用函数时,会替换形式参数a,b 下面这个展示了稍微复杂的函数嵌套，执行test()的时候test函数中顺序先执行test1，输出‘9999’，然后接着执行print("12345")，输出‘12345’
def test(): test1() print("12345") # test() 在此处调用,会报错,因为代码顺序执行，test1()在这里还没有定义 def test1(): print("9999") test() 2、函数中的参数 （1）先看下面例子，引入形参和实参的概念 # 封装一个函数,传入两个数字,输出较大的一个数字 def get_max(num1,num2): # num1和num2是形式参数 if num1 &gt; num2: print('较大的数字是:',num1) else: print('较大的数字是:',num2) get_max(32,47) # 32和47是实际参数 上述代码中，定义了一个名为get_max的函数，传递两个形参num1，num2，函数体是比较num1和num2，执行代码get_max(32,47),这里的32和47就是实参，我们可以在任何地方调用get_max函数，传递想要的实参，函数体根据传递的参数计算出结果。
调用函数的时候,必须以正确的顺序传参一一对应，比如上面的传惨num1等于32，num2等于47,实参的数量和形参的数量保持一致在函数中,形参的名字和实参的名字可以一样.(本质上是在程序中开辟了不同的内存空间) （2）关键字参数 上面我们说了，实参和形参是数量相等一一对应的，比如上面的函数def get_max(num1,num2)，接收的是num1和num2两个参数，然后调用的时候get_max(12,2)，这样参数一一对应，12传递给num1，2传递给num2，但是能不能不按照顺序呢，答案是可以的，就是利用我们的关键字参数，看代码
get_max(num2 = 2,num1 = 12) 按照代码所示的关键字参数传递方式直接指明了num2 = 2，num1 = 12
（3）默认参数（在定义函数的时候,给形式参数直接赋值） def he(num1,num2 = 23): # num2 = 23表示默认参数 print('num1和num2两个数字的和是:',num1 + num2) # 未使用默认参数 # he(10,50) #输出 60 # 使用了默认参数 # he(82) #输出 105 从上面的代码我们可以总结一下，默认参数的意义在于给形参设置一个默认值，你可以调用的时候重新传递覆盖，也可以就用默认值，比如上面的调用he(10,50)，10传递给num1，50覆盖默认值23，计算和输出60，假如我们调用 he(82)，这个时候82传递给num1，num2就用默认值32，计算和输出105，使用默认值有几个地方要注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4236337741afc7ce611ec84cc028996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfa8ed95e10d83e9f57333199c27d22/" rel="bookmark">
			mysql高级语句的查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、排序语法，关键字排序 升序和降序
默认的排序方式就是升序
升序：ASC
降序：DESC
配合语法：order by 语法
1、升序 select * from info order by name; 根据名字升序排序，不需要加ASC select * from info order by id;根据id升序排序 2、 降序（指定列） select * from info order by name desc;根据名字降序 select * from info order by id desc; 根据id降序 3、多个列排序 以多个列作为排序关键字，只有第一个参数有相同的值第二个字段才有意义。
select * from info order by hobbid desc,id; 重复值对应的第二个字段按照指定的排序进行排序
select * from info order by id desc,score;#根据id降序，成绩升序 二、区间判断 1、and 且 两个条件都要满足
select * from info where score &gt; 70 and score &lt;=90; 成绩大于70且小于90 2、or 且 两个条件只要满足一个即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cfa8ed95e10d83e9f57333199c27d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eee7d6a6531a0e523b73beba65ebabc/" rel="bookmark">
			三子棋、井字棋 -python版本代码-C语言版本代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三子棋是一种民间传统游戏，又叫九宫棋、圈圈叉叉棋、一条龙、井字棋等。游戏分为双方对战，双方依次在9宫格棋盘上摆放棋子，率先将自己的三个棋子走成一条线就视为胜利，而对方就算输了，但是三子棋在很多时候会出现和棋的局面。
废话不多说，直接上代码，好用请给个三连关注谢谢，我的B站是技术宅学长的个人空间-技术宅学长个人主页-哔哩哔哩视频 (bilibili.com) #作者：技术宅学长（CSDN、B站、抖音均为该ID） #电赛交流1群：586475593 #电赛交流2群：878095340 #电赛交流3群：873779462 #电赛交流4群：208635284 #电赛交流5群：903429622 import random # 定义棋盘大小和玩家符号 ROWS, COLS = 3, 3 PLAYER_X = 'X'#玩家 PLAYER_O = 'O'#电脑AI EMPTY = ' ' # 函数：打印棋盘 def print_board(board): for row in board: print(" | ".join(row)) print("-" * 9) # 函数：检查当前状态是否是结束状态（胜负或平局） def check_game_over(board): # 检查行和列 for i in range(ROWS): if board[i][0] == board[i][1] == board[i][2] != EMPTY: # 检查行 return board[i][0] if board[0][i] == board[1][i] == board[2][i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eee7d6a6531a0e523b73beba65ebabc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4117e28efb39f1cd4fcd140c500a09/" rel="bookmark">
			Springboot和SpringMVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.搭建maven Spring直译就是春天的意思，那就是说，有了框架之后就有了春天，是咱们程序员的春天，在以前想要做一个程序，可能需要半年的周期，但是有了框架之后，可能只需要两三个月的时间，大大缩短了开发周期，所以很好用，但是刚开始的时候，想要建立框架就要配置xml文件，但是配置xml文件非常的严格需要有严格的程序，很麻烦，所以现在有了springboot，springboot想要建立框架，需要有jar包，但是还有一个问题是，jar包版本会影响搭建框架，所以要有maven来帮助我们，这样就可以并帮助我们快速的建立一个框架。
下面我们开始建立启动类 直接新建项目，新建项目的时候左边选择new project，右边起好项目名字，语言选择java，Build system选择Maven就可以了，
建好项目之后找settings，在settings里面搜索maven ，路径path选择到bin目录之前的文件夹（这个文件是maven文件，需要下载），第一个需要override覆盖，点一下对号之后选择settings配置文件，直接apply然后ok这样就搭建好了环境
在pom.xml文件中加上jar包，可以从网上找然后刷新一下maven就可以了
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt; &lt;/dependency&gt; 这里用的是下面这个，可以从里面挑选一个使用人多的版本 在java文件夹下面建包，在包下建立一个Application 类，这个类就是启动类，但是需要在类前面加上注解：@SpringBootApplication，在main方法里面写上SpringApplication.run(EasySpringBootAAppliction.class,args);
现在这个Application类就是启动类，只要启动这个类，整个项目就会启动
2.IOC控制反转 java类的对象 //在项目运行阶段，项目需要很多对象完成整体业务 // Springboot提供了很多注解（@Repository（数据访问层），@Controller，@Bean，@Component（其他功能类），@Service(业务类),@RestController（访问层）），让Spring管理这些类的对象的生命周期 //Spring提供了ioc（控制反转）的方式方便获取该对象， //容器和代码之间的控制权反转了，代码中不需要明文获取或者调用方法来得到对象，只需要声明该类需要什么类型的对象即可（标注注解） @Service和RestController不同不能替代，想要进入浏览器只能用后者，前者不可以
@Autowired 在框架之前，如果我们想要获取一个对象，那我们需要手动获取，而且只有在执行到我们的代码的时候才会获取到，但是SpringbootICO就可以完成反转，只要你声明好了需要获取什么类型的对象就可以了，Springboot会给予这个类型的对象，只需要下面这样声明一下就可以了需要有一个@Autowired注解，就会给予这个类型的easys对象，
@Autowired EasyService easys; @ RequestMapping @RequestMapping这个注解是要与前台进行交互，有了这个注解之后在注解后边加上（"名称"），就可以在浏览器使用http://localhost/8080/名称就可以看到执行的结果；
@RestController public class EasyController { //该类中需要EasyService类的对象 //就可以在这个类中只需要声明依赖EasyService这个类就可以，不需要通过代码主动获取EasyService类的对象 //然后只需要一个注解aotuwired //通过识别依赖关系，依赖注入（DI）对应的对象 @Autowired EasyService easys; @Autowired TestA testa; @RequestMapping("testb") public String testB(){ testa.test(); return "Easy method"; }} 另外一个类： @Component public class TestA { public void test(){ System.out.println(this); System.out.println("test method"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4117e28efb39f1cd4fcd140c500a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc1971884e76d9d2f741eb12ffc91fb/" rel="bookmark">
			详细说明Java中Map和Set接口的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Map与Set的基本概念与场景 Map和set是一种专门用来进行搜索的容器或者数据结构，其搜索的效率与其具体的实例化子类有关。以前常见的搜索方式有：
1. 直接遍历，时间复杂度为O(N)，元素如果比较多效率会非常慢。
2. 二分查找，时间复杂度为,但搜索前必须要求序列是有序的。
上述排序比较适合静态类型的查找，即一般不会对区间进行插入和删除操作了，而现实中的查找比如：
1. 根据姓名查询考试成绩
2. 通讯录，即根据姓名查询联系方式
3. 不重复集合，即需要先搜索关键字是否已经在集合中
可能在查找时进行一些插入和删除的操作，即动态查找，那上述两种方式就不太适合了，本节介绍的Map和Set是一种适合动态查找的集合容器。
模型概念 一般把搜索的数据称为关键字（Key），和关键字对应的称为值（Value），将其称之为Key-value的键值对，所以模型会有两种：
纯 key 模型，例如： 有一个英文词典，快速查找一个单词是否在词典中快速查找某个名字在不在通讯录中 Key-Value 模型，例如： 统计文件中每个单词出现的次数，统计结果是每个单词都有与其对应的次数：&lt;单词，单词出现的次数&gt;梁山好汉的江湖绰号：每个好汉都有自己的江湖绰号 Map接口的性质 在Java中，Map接口是一个用于存储键值对（key-value pairs）的对象，它属于Java Collections Framework的一部分。Map接口的主要特点包括：
键值对存储：Map存储的数据是以键值对的形式组织的，每个键（key）唯一对应一个值（value）。可以通过键来快速获取对应的值。
无序性：大多数实现类（如HashMap）不会保证元素的顺序，除非使用特定的实现（如LinkedHashMap，它可以保持插入顺序，或者TreeMap，它会按照键的自然顺序或指定的比较器进行排序）。
键的唯一性：在同一个Map中，不能有重复的键。如果试图将一个新的值与已有的键关联，原有的值将被新值替换。
实现类：Java提供了多种Map接口的实现，例如：
HashMap：基于哈希表的实现，允许null值和null键，查找速度快。TreeMap：基于红黑树的实现，支持排序的键，查找速度相对较慢。LinkedHashMap：结合了HashMap的哈希表和链表特性，维护插入顺序。 常用方法：Map接口提供了一系列的方法，例如：
put(K key, V value)：将指定的值与指定的键关联。get(Object key)：返回指定键所映射的值。remove(Object key)：移除指定键的键值对。containsKey(Object key)：检查是否存在指定的键。keySet()：返回Map中所有键的集合。values()：返回Map中所有值的集合。 总之，Map接口是Java中重要的数据结构之一，方便有效地进行数据的存储和检索，广泛应用于各种场景中。
Map接口的使用方法 put(K key, V value)：将指定的值与指定的键关联。
public class Main { public static void main(String[] args) { Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;(); map.put("one",1); map.put("two",2); map.put("three",3); map.put("four",4); } } get(Object key)：返回指定键所映射的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc1971884e76d9d2f741eb12ffc91fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3fc74f7119f2b76bc13a5ce92b0107a/" rel="bookmark">
			河南萌新联赛2024第（三）场：河南大学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 A 圆周率日挑战题意描述：解题思路：解题代码： C Circle题意描述：解题思路：解题代码： D 开心消消乐（Right Version）题意：解题思路：解题代码： F 累加器题意：解题思路：解题代码： J keillempkill学姐の卷积题意：解题思路：解题代码： L SSH题意描述：解题思路：解题代码： A 圆周率日挑战 原题链接
题意描述： 给出圆周率前100位，有n组数据：每组有两个整数a，b分别表示该图案的周长的平方和面积的4倍。一个图形越接近圆，它的a/b的值就越接近 圆周率。找出最接近圆的一组，如果接近程度相同，则选择其中周长最小的那一个“圆”所对应的一组，输出该组的a，b
解题思路： 设变量p记录a/b与圆周率的差值的绝对值选择差值最小的一组如果差值相同，则选择a较小的一组这道题难处理的是数据，用python会更好处理 （该题数据范围需要用高精，如果用C++/C语言会很麻烦，Python中可以引用decimal库，这样可以简化运算。我不会python，也是写这道题才接触，注释可能写的有点问题，代码是能过的，代码记得选python3）
解题代码： import decimal from decimal import *//导入Python中decimal模板 getcontext().prec=40//.prec用来设置精度，这里设置为40位 pi=decimal.Decimal("3.1415926535897932384626433832795028841971")//pi为Decimal类型，给pi赋值， ans,d=(0,0),pi//将(0,0)赋值给ans,pi赋值给d for i in range(int(input()))://循环，从0，循环到输入数字-1 p, a = list(map(int, input().split()))//将输入的数分别赋给p,a代表分子和分母 dis=abs(decimal.Decimal(decimal.Decimal(p)/decimal.Decimal(a))-pi)//求思路中所说与圆周率的接近程度 if dis==d://比较接近程度 if p&lt;ans[0]://比较周长，ans中ans[0]存储的为周长平方，ans[1]存储的为面积的四倍 ans=(p,a)////如果接近程度相同，选择周长最小的 elif dis&lt;d: d=dis ans=(p,a)//如果接近程度不同，选择最为接近的 print(ans[0],ans[1]) C Circle 原题链接
题意描述： t组询问，每组询问一个整数n，输出n个圆（半径可以不同）可以分割的最大区域数
解题思路： 题中给出0，1，2，3个圆分别可以分割的最大区域数，我们可以画图看看4个圆的情况，发现是16.通过画图我发现，分割最大区域时，区域分三块：所有圆都不包括的部分为1，所有圆共同的部分为1和每两个圆相交的部分（n-1）*n因此得到公式为2+（n-1)*nn为0时没有圆内区域，因此需要特判为1
(赛时看了数据，以为是2的n，还在那想21000000咋处理，数据范围那么大，我应该早点发现思路是错的，而且我也处理不了这么大的数据吖） 解题代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long #define IOS ios::sync_with_stdio(false);cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3fc74f7119f2b76bc13a5ce92b0107a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d234853578ea856d9c13d4a97950c16/" rel="bookmark">
			C&#43;&#43;必修：STL之string的了解与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：C++学习
贝蒂的主页：Betty’s blog
1. C/C++中的字符串 1.1. C语言中的字符串 在 C 语言中，字符串是由字符组成的字符数组，以空字符 '\0' 作为结束标志。由于数组特点，字符串的大小在定义数组时就已经确定，无法更改。
//数组大小为20 char str[20] = "hello betty!\n"; 当然我们可以通过动态内存分配来来解决这个问题，但无疑非常繁琐。
void Test1() { char* str = NULL; int len = 0; // 初始分配一些内存 str = (char*)malloc(10 * sizeof(char)); if (str == NULL) { perror("malloc fail"); return 1; } strcpy(str, "Hello"); len = strlen(str); // 根据需要扩展字符串 str = (char*)realloc(str, (len + 6) * sizeof(char)); if (str == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d234853578ea856d9c13d4a97950c16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/641be9774761cbda788f0d7605fa18cb/" rel="bookmark">
			vue3父子组件通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //父传字 const car=ref("给子的数据") &lt;save-template :car="car"/&gt; //子接收 defineProps(["car"]) function Callpage(){ console.log("test") } function save(){ emit("btSave",要返回的值) } //暴露方法给父调用 defineExpose({Callpage}) //返回给父组件值 const emit=defineEmits(["btSave"]) //父 const savetemp =ref("") &lt;save-template @btSave="test" ref="savetemp"/&gt; function test(res){ console.log(res) savetemp.value.Callpage() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b2c23349908522f7f2cd684ec45331/" rel="bookmark">
			【区块链&#43;绿色低碳】盈江县两山生态开发平台 | FISCO BCOS应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前林业碳汇场景中涉及林权认证、身份授权、多方机构协作、数据交换等流程，为解决复杂的业务协作所面临 的身份信息泄漏、数据造假、数据安全等问题，盈江县建设“盈江县两山生态开发平台”，在清查盈江县自然资源、 整合数据的基础上，搭建全县统一的两山生态资源管理平台，实现盈江县各类自然资源的信息整合与统一管理， 形成盈江县生态资源清单、产权清单、项目清单，并建立全县统一的生态资源资产保护、开发、监管全过程工作机制。
平台通过构建盈江县两山生态运作体系，推动全域林业碳汇、文化及旅游资源等重点领域开展项目化实际运营开 发，并在生态资源的评估、流转、交易、经营、管理等方面形成一批典型经验和制度成果。平台还通过对林草局、 生态环保局、自然资源局、金融保险等机构的数据进行多方汇集交互，将林业碳汇全流程业务通过信息化平台呈 现，在平台形成碳票并进行流转。在区域碳中和场景中，碳排企业可以在平台进行碳票购买，用于自愿碳排放抵 消，由平台中拥有多方职能的机构共同审核保证，为碳汇流转作为数据有效性做好支撑，实现数据可信，便利金 融 / 保险机构开展贷款、质押、保险等业务。
该平台由厦门哈希科技有限公司基于 FISCO BCOS 区块链技术提供支持，利用隐私计算技术确保数据安全，避免 隐私泄露。中环联合（北京）认证中心有限公司作为行业权威认证机构，参与合作共建。德宏州生态环境局盈江 分局、盈江县自然资源局、盈江县林业和草原局、德宏中盈碳汇科技有限责任公司作为碳汇链的共识节点，实现“盈 江县两山生态开发平台”的链上数据全流程可溯源可监管，提供信任背书，实现数据协同，真实可信共享，打造 信任生态。另外，盈江县人民政府将作为碳汇链的监管节点，对链上数据进行全过程监管。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69cc61cfcdd50034d5e404af62fcdf15/" rel="bookmark">
			鸿蒙系统开发【网络管理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络管理 介绍 此Demo展示如何查询网络详情、域名解析、网络状态监听等功能。
效果预览： 使用说明：
1.启动应用，在点击检查网络、网络详情、网络连接信息后，展示对应的信息；
2.在域名解析的模块下，输入对应的域名后，点击域名解析，展示解析的域名ip地址；
3.在网络监听模块下，开启网络监听后，展示当前监听的网络信息；关闭网络监听后，停止监听网络信息。
具体实现 使用@ohos.net.connection（网络连接管理）接口实现网络的详情、域名解析、网络监听等功能。代码：Index.ets
/* * * * Copyright (c) 2023 Huawei Device Co., Ltd. * * Licensed under the Apache License, Version 2.0 (the 'License'); * * you may not use this file except in compliance with the License. * * You may obtain a copy of the License at * * * * http://www.apache.org/licenses/LICENSE-2.0 * * * * Unless required by applicable law or agreed to in writing, software * * distributed under the License is distributed on an 'AS IS' BASIS, * * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69cc61cfcdd50034d5e404af62fcdf15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa5f9fb5f57fb8de71f5c71927dc49d/" rel="bookmark">
			数据可视化工具，免费无限制制作报表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多企业在报表制作上投入了大量资金，使用各种收费软件，往往只能满足基本需求，且操作复杂，让人感到无比头疼。不过最近我发现之前一直在做数据大屏的山海鲸可视化，现在新增了报表功能，不仅各种功能都可以免费使用，而且不像其他一些报表软件一样会有许多限制，本人亲自体验了一下报表功能，这里就和大家简单分享一下使用体验。
山海鲸可视化的最大优势在于其完全免费，与市场上其他工具的免费版本相比，山海鲸可视化不仅没有人数限制，同时允许无限制用户访问报表系统，无论多少成员都可以随时随地访问和共享报表，无需担心费用。大家如果感兴趣的话也可以去山海鲸官网下个软件体验一下。
此外，山海鲸可视化报表功能的操作界面继承了在数据大屏上的优点，不仅完全支持零代码拖拽式操作，而且界面简洁易懂，无需具备编程或专业技术知识。即使是数据处理新手，也能快速学会使用该工具，可以节省大量时间和培训成本。并且这样一来，团队中的每位成员都能迅速参与报表的制作，一定程度上能够提升工作效率。
功能强大是我体验下来感受到的另一大亮点。无论是简单的日常报表，还是复杂的中国式报表，都可以在此软件中轻松实现。软件中提供了丰富的可视化图表种类，使得数据的展示能够更加生动形象，可以根据需求选择不同的图表类型，不仅有柱状图、折线图、饼图等常规图表，还可以添加图片、视频、等各类其他组件。
总的体验下来，山海鲸可视化新出的这个报表功能给我的感觉还是很不错的，和市面上许多其他付费产品比起来也不遑多让，大家如果在报表方面有需求的话真的推荐试一下，可能以后就再也不用为报表付费了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc0ebb3bd41c97af215ecf3f924dad5/" rel="bookmark">
			揭秘！国内10大低代码构建平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多款低代码开发平台介绍，包括明道云、泛微e-cology、金蝶云·苍穹等，各具特色如定制性、集成能力、移动设计等，但学习曲线陡峭、成本考虑及技术支持限制需注意。
一、Zoho Creator
Zoho Creator 是一款功能强大的低代码平台，适用于快速构建定制化的业务应用程序。无论是简单的表单还是复杂的工作流，Zoho Creator都能提供一站式的解决方案。它在全球范围内受到广泛欢迎，在2023年被Gartner评为企业低代码应用程序平台中的“有远见者”。
产品主要特点：
1、灵活的拖放界面
Zoho Creator 提供了一个直观的拖放界面，用户可以通过简单的拖拽操作来设计和构建应用界面，无需编写任何代码，极大地简化了开发过程。
2、一键式部署与分发
通过内置的移动设备管理（MDM）功能，Zoho Creator实现了一键式的移动应用部署和分发，使得开发者可以轻松地将应用部署到目标用户的移动设备上，无需通过应用商店。
3、强大的数据管理功能
Zoho Creator提供了强大的数据管理功能，包括数据加密、审计日志记录、IP限制和双因素验证等，确保数据的安全性和完整性。
4、强大的集成能力
Zoho Creator 支持与多种第三方服务和系统集成，包括常见的云存储服务、支付网关、社交媒体平台等。内置连接器让数据同步和交互变得更加简单，用户可以轻松地将他们的应用程序与现有系统和服务连接起来。
5、AI辅助开发
Zoho Creator低代码开发平台的内置AI功能可以清理、排序、解析和分类电子表格中的数据。这个功能可以帮助企业设置审计跟踪建立工作流程自动化，使来自其组织的数据真正互联。
6、丰富的应用模板
Zoho Creator 提供了一套适用于60多个行业的应用模板，这使得开发者能够快速启动项目，无需从头开始编写代码。
用户可以根据自身业务需求对这些模板进行高度定制，这意味着即使是没有编程经验的用户也可以轻松地调整应用以符合特定的业务流程或需求。
二、明道云
明道云是一款面向企业的低代码开发平台，旨在帮助非技术背景的用户快速构建业务应用。
产品主要特点：
1、高度可定制性
明道云提供了丰富的组件和模板，用户可以根据自己的需求定制各种应用程序，包括CRM、项目管理等。
2、集成与扩展能力
支持与其他企业级应用和服务的集成，如ERP系统、OA系统等，通过API接口实现数据同步。
3、移动优先设计
明道云注重移动用户体验，支持创建响应式应用，确保在不同设备上都能良好运行。
4、学习曲线陡峭
对初学者来说，掌握其所有功能仍需要一定的时间投入。
三、泛微e-cology
泛微e-cology是一款面向中大型企业的协同办公与业务流程管理平台，支持低代码开发模式。
产品主要特点：
1、全面的协作工具
提供了多种协作工具，如文档共享、在线会议等，方便团队沟通。
2、灵活的工作流引擎
用户可以通过拖拽的方式设计复杂的工作流程，无需编程知识。
3、强大的权限管理系统
支持细粒度的权限控制，确保数据安全和合规。
4、定制化限制
对于非常复杂的业务逻辑，可能需要额外的技术支持来实现。
四、金蝶云·苍穹
金蝶云·苍穹是一个基于云的企业服务和管理平台，支持低代码开发和高度定制化。
产品主要特点：
1、一站式解决方案
提供财务、供应链、人力资源等多方面的管理模块。
2、云原生架构
基于云原生技术，保证系统的稳定性和可扩展性。
3、智能分析工具
集成了大数据分析和AI技术，帮助企业做出更明智的决策。
4、初期成本考虑
对于小型企业而言，初期的投资可能会较高。
五、致远互联A8+
致远互联A8+是一款专注于企业级协同管理和低代码开发的平台。
产品主要特点：
1、深度定制能力
用户可以深度定制界面和功能，满足个性化需求。
2、丰富的插件市场
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc0ebb3bd41c97af215ecf3f924dad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75143d8ef3485e9e2208c3075c371887/" rel="bookmark">
			【数据结构】了解哈希表，解决哈希冲突，用Java模拟实现哈希桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表的概念 哈希表（Hash Table）是一种高效的数据结构，用于实现快速的数据存储和检索。它通过将数据映射到一个数组的索引位置，从而能够在平均情况下实现O(1)的时间复杂度进行查找、插入和删除操作。
哈希表的基本概念包括以下几个部分：
哈希函数：哈希表使用哈希函数将输入的数据（通常是键）转换为固定大小的数组索引。一个好的哈希函数能够有效地将不同的数据映射到不同的索引，减少冲突的概率。
冲突处理：由于不同的键可能会通过哈希函数映射到相同的索引，这种情况被称为冲突。常见的冲突处理方法有链地址法（在同一个索引处使用链表存储所有冲突的元素）和开放地址法（通过探测寻找下一个可用的索引）。
负载因子：负载因子是哈希表中存储的元素数量与哈希表大小的比率。负载因子过高会导致冲突增加，影响性能，因此通常在达到一定的负载因子后会对哈希表进行扩展和重新哈希。
哈希表在实际应用中广泛用于快速查找和存储数据，例如数据库索引、缓存系统等，是一种非常实用的数据结构。
例如：数据集合{1，7，6，4，5，9}。
哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。
哈希冲突的概念 哈希冲突（Hash Collision）是指在哈希表中，不同的输入数据（通常是键）经过哈希函数处理后，得到了相同的哈希值，进而映射到了哈希表的同一个索引位置。这种现象不可避免，因为哈希函数将任意大小的数据映射到固定大小的数组索引，而输入数据的范围通常大于输出哈希值的范围，从而导致不同的数据可能会对应相同的哈希值。
哈希冲突的处理方法： 为了有效地处理哈希冲突，主要有以下几种常见的方法：
链地址法（Separate Chaining）：
在哈希表的每个索引位置，使用一个链表或其他数据结构来存储所有哈希值相同的元素。这样，当发生冲突时，新元素可以直接添加到链表中。优点：实现简单，容易扩展，链表的长度通常是较短的，性能受到较少影响。缺点：当冲突严重时，链表长度增加，会影响查找性能。 开放地址法（Open Addressing）：
当发生哈希冲突时，哈希表会寻找下一个空闲的位置，将新元素放入该位置，而不是在同一索引位置存储。包括线性探测、二次探测和双重哈希等具体策略来寻找空位。优点：内存占用较低，数据存储在连续的数组中，缓存友好。缺点：可能导致“聚集”现象，即连续的多个元素都占据相邻的索引，影响性能。 哈希冲突的影响： 哈希冲突的存在会对哈希表的性能产生影响，特别是在查找、插入和删除元素时。冲突越多，导致的查找时间可能从O(1)增长到O(n)（在最坏的情况下）。因此，选择合适的哈希函数以减少冲突的发生，以及选择有效的冲突处理策略，是设计高效哈希表的关键。
避免哈希冲突的方法 哈希函数设计 引起哈希冲突的一个原因可能是：哈希函数设计不够合理。 哈希函数设计原则：
哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间。哈希函数计算出来的地址能均匀分布在整个空间中。哈希函数应该比较简单。 常见哈希函数 直接定制法
取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B 优点：简单、均匀 缺点：需要事先知道关键字的分布情况 使用场景：适合查找比较小且连续的情况。
除留余数法
设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p&lt;=m),将关键码转换成哈希地址。
平方取中法
假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址； 再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址 平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况。
折叠法
折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。
随机数法
选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中random为随机数函数。
负载因子调节 负载因子（Load Factor）是哈希表中一个重要的度量，用于评估哈希表的使用效率和性能。负载因子定义为哈希表中存储的元素数量与哈希表的总容量（即数组大小）之间的比率，通常用公式表示为：
负载因子 = 当前元素数量 / 哈希表的容量
负载因子的意义：
性能指标：负载因子能够反映哈希表的性能。当负载因子较低时，哈希表中的元素分布较为稀疏，冲突较少，查找、插入和删除操作的效率较高。而当负载因子较高时，冲突可能增多，导致这些操作的性能下降。
自适应调整：为了保持哈希表的高效性能，通常在负载因子达到一定阈值时（例如0.7或0.75），会进行负载因子的调节。调节方法通常包括扩展哈希表的容量，并重新计算所有元素的哈希值以保证它们被均匀分布。
负载因子的调节过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75143d8ef3485e9e2208c3075c371887/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/92/">«</a>
	<span class="pagination__item pagination__item--current">93/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/94/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>