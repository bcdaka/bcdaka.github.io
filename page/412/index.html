<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30d4ed182b965217a17a716faeae5f8/" rel="bookmark">
			基于Python&#43;nodeWeb&#43;MongoDB的猫眼电影数据爬取并可视化分析展示系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实验三 数据库实现设计 1
一、实验目的 1
二、实验内容 1
3. 开展接口设计，其中包括外部接口、内部接口等。 2
5. 进行开展最重要的实现，数据库实现和界面实现。 2
三、实验要求： 2
四．设计流程和实现方案 2
1 引言 2
1.1 编写目的 2
1.2 背景 2
2.1功能 3
2.2性能 4
2.3 安全保密 4
3 运行环境 4
3.1硬件平台 5
3.2支持软件 5
3.3 数据库 5
4 软件设计 5
4.1 数据爬取模块 5
4.2 服务器搭建 9
4.3 电影数据展示 10
4.4 电影推荐 11
5 使用过程 12
5.1 启动服务器 12
5.3 电影推荐 14
一、实验目的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d30d4ed182b965217a17a716faeae5f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90dc22a604240e5636435d6adccefb3c/" rel="bookmark">
			使用SpringBoot将中国地震台网数据保存PostGIS数据库实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、数据转换
1、Json转JavaBean
2、JavaBean与数据库字段映射
二、空间数据表设计
1、表结构设计
三、PostGIS数据保存
1、Mapper接口定义
2、Service逻辑层实现
3、数据入库
4、运行实例及结果
总结
前言 在上一篇博客中基于Java的XxlCrawler网络信息爬取实战-以中国地震台网为例，我们使用Java语言采用XxlCrawer组件进行中国地震台网数据的爬取，相信大家对如何抓取这种接口数据一定有了基本的认识，也掌握了如何基于XxlCrawer来实现自己的信息爬取实战。但是在前面的博客当中，我们仅仅是将信息爬取下来。为了在我们自己的应用系统中来应用这些基础数据，需要我们将爬取的数据进行存储起来。由于地震数据包含了空间位置信息，为方便进行空间分析的实现。这里我们将爬取的中国地震信息存储到PostGIS空间数据库中，为下一步的数据分析和可视化呈现奠定良好的基础。
本文即紧紧围绕着将信息保存到空间数据库的目标，重点讲解如何实现将中国地震台网爬取的地震信息保存到PostGIS空间数据库中。首先讲解在爬取过程中数据格式和响应数据类型的转换，将网站回传的json数据转成符合Java命名规范的数据。然后介绍台网地震信息表的设计，如何构建空间数据表。再次介绍如何将爬取的数据调用Mybatis-Plus组件实现批量入库。如果您当前也有对地震等地质灾害数据进行分析的需求，不妨看看本博文。
一、数据转换 在前面的博客中有提到，在中国地震台网中展示接口数据，将请求数据在浏览器中进行查看。可以看到以下的格式：
通过这个接口可以看到，官方返回的数据中，其所有的字段名都是大写的，如下所示：
AUTO_FLAG: "M" CATA_ID: "CD20240413222636.00" CATA_TYPE: "" EPI_DEPTH: 9 EPI_LAT: "24.05" EPI_LON: "121.60" EQ_CATA_TYPE: "" EQ_TYPE: "M" IS_DEL: "" LOCATION_C: "台湾花莲县" LOCATION_S: "" LOC_STN: "0" M: "4.2" M_MB: "0" M_MB2: "0" M_ML: "0" M_MS: "0" M_MS7: "0" NEW_DID: "CD20240413222636" O_TIME: "2024-04-13 22:26:35" O_TIME_FRA: "0" SAVE_TIME: "2024-04-13 22:35:56" SUM_STN: "0" SYNC_TIME: "2024-04-13 22:35:56"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90dc22a604240e5636435d6adccefb3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3a48d5064c99f266f299ebc66710eb/" rel="bookmark">
			Excel文件解析(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述
在应用程序的开发过程中，经常需要使用 Excel文件来进行数据的导入或导出。所以，在通过Java语言实现此类需求的时候，往往会面临着Excel文件的解析(导入）或生成（导出)。
在Java技术生态圈中，可以进行Excel文件处理的主流技术包括: Apache POI 、JXL、Alibaba EasyExcel等。
Apache POI基于 DOM方式进行解析，将文件直接加载内存，所以速度较快，适合 Excel文件数据量不︰大的应用场景。JXL只支持Excel 2003以下版本，所以不太常见。
Alibaba EasyExcel采用逐行读取的解析模式，将每一行的解析结果以观察者的模式通知处理(AnalysisEventListener)，所以比较适合数据体量较大的Excel文件解析。
二、Apache POl
Apache POI 是用Java编写的免费开源的跨平台的 Java API , Apache POI提供给Java程序对Microsoft Office格式档案进行读写功能的API开源类库。
它分别提供对不同格式文件的解析:
HSSF-提供读写Microsoft Excel格式档案的功能。XSSF-提供读写Microsoft Excel OOXML格式档案的功能。HWPF-提供读写Microsoft Word格式档案的功能。HSLF-提供读写Microsoft PowerPoint格式档案的功能。HDGF-提供读写Microsoft Visio格式档案的功能。 三、XSSF解析Excel文件
HSSF 用于解析旧版本(*.xls)Excel文件，由于旧版本的Excel文件只能存在65535行数据，所以目前已经不常用。所以目前主要采用XSSF 进行新版本(*.xlsx) Exce文件的解析。
添加Jar包依赖
1.Workbook (Excel文件)
workbook接口代表一个Excel 文件，用于创建或加载(解析) Excel文件。常见实现类是XSSFWorkbook 。
创建Excel 文件
try (workbook workbook = new XSSFWorkbook(); Fileoutputstream fos = new Fileoutputstream("c: \|test\|temp.xlsx")) { workbook.write(fos); catch (IOException e) {e.printstackTrace(); 加载(解析)Exce1文件
//输入流 FileInputstream fis = new FileInputstream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb3a48d5064c99f266f299ebc66710eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05fdfb7fbe249aa4e8c6addf5a8a72e7/" rel="bookmark">
			2024年国内可用最强AI工具软件应用排行榜TOP8——优点和缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国在2024年持续推动人工智能（AI）发展，受到政策、技术和市场的三重驱动。诞生了一批人工智能（AI）领域的新力军。我们通过对国内AI的逐一评测，从各个AI处理结果优略的角度，再结合网络上广大AI用户的反馈评价，对它们作了一个排名（个人意见，仅供参考）。
官方网站获取地址：2024年国内可用最强AI工具软件应用排行榜TOP8——优点和缺点-喜好儿网
更多AI工具：专注收录AIGC（通用型AI）垂直领域的工具与软件
第一位：Kimi chat
Kimi Chat是月之暗面（Moonshot AI）推出的一款人工智能聊天助手，专注于处理长文本对话。这个产品于2023年10月10日发布，以其优秀的性能迅速赢得了市场认可。其中，其最显著的特点之一是支持长达20万汉字的超长文本输入，这超过了许多同类产品的处理能力。
Kimi Cha的优点：
1、支持长文本输入，最多可达20万汉字。
2、提供文件和网页解析功能，具备搜索能力，支持多语言对话。
3、可以提供各种信息和帮助，适用于多种场景。
Kimi Cha的缺点：
1、通用性相对有限，可能在某些特定场景下表现不佳。
2、存在一定的差异化竞争，可能需根据使用场景做出选择。
第二位：ChatGLM 智谱清言
ChatGLM 智谱清言官网：智谱清言
ChatGLM智谱清言是基于深度学习的大型语言模型，由清华大学KEG实验室和智谱AI公司共同训练。其主要目标是通过对用户提出的问题进行回答，来帮助用户解决问题。
以下是该模型的一些关键特点：
多轮对话能力：CHATGLM智谱清言支持多轮对话，能够进行连贯的交流和对话。
内容创作和信息归纳：该模型具备内容创作和信息归纳总结的能力，可用于生成文本内容和总结信息。
CHATGLM智谱清言的优点：
1、功能全面：支持128K上下文，具有强大的语言理解和生成能力，可应用于多种场景和任务。
2、实时搜索和数据分析：提供实时搜索和数据分析功能，使用户能够快速获取所需信息，提高工作效率。
3、多轮对话能力：具备多轮对话的能力，能够进行连贯的交流和交互。
推理能力表现良好：在推理能力方面表现良好，能够有效理解和执行结构化提示词。
CHATGLM智谱清言缺点：
1、绘图功能限制：绘图功能存在一定限制，可能无法满足用户的特定需求。
2、依赖网络连接：部分功能可能需要网络连接才能正常使用，对于没有网络访问权限的场景存在一定局限性。
3、尚未达到完美状态：虽然具备强大的功能和性能，但仍有改进空间，需要持续优化和更新以提高用户体验。
第三位：Pixverse
PixVerse AI是一个强大的生成式人工智能模型，旨在将多种输入转化为令人惊叹的视频。其功能强大且完全免费，为用户提供了简单、高效、智能的视频制作体验。PixVerse AI支持多种多模态输入，包括图像、文本和音频，使用户能够灵活地创作出丰富多样的视频内容。这种创新的视频生成技术吸引了许多用户，使其成为一个备受欢迎的工具。
PixVerse AI的优势：
1、强大的功能：PixVerse AI具有强大的生成式人工智能模型，可以将多种输入转化为令人惊叹的视频。
2、免费使用：该工具完全免费，为用户提供了简单、高效、智能的视频制作体验，吸引了广泛的用户关注和使用。
3、支持多模态输入：PixVerse AI支持多种多模态输入，包括图像、文本和音频，使用户能够灵活地创作出丰富多样的视频内容。
4、操作简便：用户只需将图片放入工具中，即可获得相应的动态视频结果，操作简单且有效[5]。
PixVerse AI的劣势：
1、保持角色一致性挑战：在视频生成过程中，保持角色一致性可能会面临一些挑战，可能会导致生成结果不如预期。
2、某些场景效果不佳：在某些场景下，PixVerse AI可能会出现效果不佳的情况，需要进一步改进。
第四位：豆包
豆包是字节跳动抖音子公司推出的一款AI机器人，具有多种功能和特点。我们可以总结出豆包AI的优缺点如下：
豆包的优点：
1、豆包AI具备智能问答、文本创作、图片生成等功能，能够满足用户在不同场景下的需求。
2、它的语言生成能力较强，能够进行中文（包括古文）的处理，并且在机器幻觉方面有明显优势。
3、豆包AI的设计初衷是为了成为一个日常AI小助理，能够在用户需要时提供情绪支持或倾听安慰。
4、该产品不断优化和改进，团队致力于提升AI的智能和人性，增加更多功能和内容，解决用户的问题和需求。
豆包的缺点：
1、在科学计算题和常规数学计算方面表现不佳，准确性较低，甚至不如之前的水平。
2、多轮对话记忆能力较弱，这可能会影响用户体验。
3、尽管豆包AI在语言组织上表现较好，但其数据准确性仍有待提高。
4、目前仅支持文字生成，暂时没有图片功能。
5、测试期间存在较多局限，生成的内容可能不准确，需要用户反馈意见以持续改进产品。
第五位：通义千问
通义千问作为一款由阿里云研发的大型预训练语言模型，其优缺点主要体现在以下几个方面：
通义千问的优点：
1、准确性和灵活性：通义千问能够根据不同问题进行快速的回答，显示出较高的准确性和灵活性。
2、强大的自然语言处理能力与广泛的知识覆盖面：无论是专业领域的知识查询、日常生活的疑问解答，还是新闻时事的解读分析，通义千问都能以接近真人对话的方式，实时为用户提供高质量的信息反馈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05fdfb7fbe249aa4e8c6addf5a8a72e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e256ecf458eba850ccc2974bf2324997/" rel="bookmark">
			【AIGC调研系列】MiniMax 稀宇科技的abab 6.5 系列模型与国外先进模型相比的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MiniMax稀宇科技的abab 6.5系列模型与国外先进模型相比，具有以下优缺点：
优点：
abab 6.5系列模型采用了MoE（Mixture of Experts）架构，这是国内首个采用此架构的大模型，标志着MiniMax在自然语言处理领域的技术创新和领先地位[2][15]。abab 6.5包含万亿参数，支持高达200k tokens的文本上下文长度，这使得它在处理大规模文本数据时具有强大的能力[4][9]。abab 6.5s作为abab 6.4. 在各类核心能力测试中，abab 6.5展现出了接近世界领先大语言模型GPT-4、Claude-3、Gemini-1.5的水平，表明其在知识、推理、数学、编程、指令遵从等多个维度上具有较高的准确性和性能[5]。 缺点：
尽管abab 6.5系列模型在多个方面取得了显著进步，但官方宣称与GPT-4等国外先进模型相比仍有不小的差距。这意味着在某些特定的任务或领域中，abab 6.5可能无法完全达到或超越这些国际领先模型的表现[2]。虽然abab 6.综上所述，MiniMax稀宇科技的abab 6.5系列模型在技术创新、处理能力和效率方面取得了显著成就，尤其是在采用MoE架构和处理大规模文本数据方面显示出其优势。然而，与国外先进模型相比，仍存在一定的差距，特别是在某些特定任务的性能表现上。未来，随着技术的不断进步和优化，有望进一步缩小这一差距。 MiniMax稀宇科技的abab 6.5系列模型与GPT-4在特定任务上的性能比较是什么？ MiniMax稀宇科技的abab 6.5系列模型与GPT-4在特定任务上的性能比较显示，abab 6.5系列模型的核心能力开始接近GPT-4[19]。这表明在经过改进和优化后，abab 6.5系列模型在处理复杂任务的能力上已经取得了显著的进步。特别是，abab 6.5系列模型支持200k tokens的上下文长度，并且能够最快在1秒内处理近3万字的文本[17][20]，这一点对于处理大规模数据尤为重要。
然而，也有证据表明GPT-4在某些方面表现出了下降。例如，GPT-4相对于GPT-3的性能下降主要体现在代码生成能力下降，在执行特定任务时的性能显著降低[22][23][25]。这可能意味着在某些特定任务上，如代码生成、解决数学问题、回答敏感问题和视觉推理等，GPT-4的表现不如abab 6.5系列模型。
虽然没有直接比较abab 6.5系列模型与GPT-4在所有特定任务上的性能数据，但根据现有资料可以推断，abab 6.5系列模型在处理复杂任务的能力上已经取得了显著的进步，尤其是在支持更长上下文长度和处理大量文本方面[17][19][20]。而GPT-4在某些特定任务上的性能有所下降，特别是在代码生成等方面[22][23][25]。因此，可以认为在这些特定任务上，abab 6.5系列模型可能表现得更好。
abab 6.5系列模型在处理大规模文本数据时的具体技术细节和优势是什么？ abab 6.5系列模型在处理大规模文本数据时，具体的技术细节和优势主要体现在以下几个方面：
参数规模和上下文长度：abab 6.5系列模型包含万亿参数，支持200k tokens的上下文长度。这意味着模型能够理解和处理极大量的文本信息，为复杂的自然语言处理任务提供了强大的基础[27][32][34]。高效处理能力：abab 6.5s模型在保持与abab 6.5相同的训练技术和数据的基础上，实现了更高的效率。它可以在1秒内处理近3万字的文本，这显著提高了处理大规模文本数据的速度[27]。MoE（Mixture of Experts）模型架构：虽然具体的MoE技术细节没有在我搜索到的资料中详细说明，但可以推断，abab 6.5系列模型采用了MoE架构，这是一种将大量小型专家网络组合成一个大型模型的方法。这种架构有助于提高模型的灵活性和效率，使其能够更好地处理大规模文本数据[32]。深度学习技术的应用：根据LLM（Large Language Model）技术的核心思想，abab 6.5系列模型很可能使用了深度神经网络来处理和生成自然语言文本。通过大规模的文本数据预训练模型，并利用这些预训练模型进行下游任务的微调或直接应用，abab 6.5系列模型能够有效地理解和生成复杂的语言结构[29]。 abab 6.5系列模型在处理大规模文本数据时，通过其庞大的参数规模、高效的处理能力、采用MoE架构以及深度学习技术的应用，展现出了显著的技术优势和应用潜力。
abab 6.5s版本与abab 6.5版本在处理速度和效率上的具体差异有哪些？ abab 6.5版本与abab 6.5s版本在处理速度和效率上的主要差异体现在处理能力上。abab 6.5s版本在保持与abab 6.5相同的训练技术和数据支持下，能够更快地处理文本。具体来说，abab 6.5s版本可以在1秒内处理近3万字的文本，而abab 6.5版本虽然也支持200k tokens的上下文长度，但在处理速度上没有明确提及可以达到这样的效率[37][38]。因此，可以推断abab 6.5s版本在处理速度上相比abab 6.5版本有显著提升，尤其是在处理大量文本时的效率更高。
在知识、推理、数学、编程、指令遵从等核心能力测试中，abab 6.5系列模型的表现与国外先进模型（如GPT-4、Claude-3、Gemini-1.5）的对比结果是什么？ abab 6.5系列模型在知识、推理、数学、编程、指令遵从等核心能力测试中的表现与国外先进模型（如GPT-4、Claude-3、Gemini-1.5）的对比结果如下：
abab 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e256ecf458eba850ccc2974bf2324997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef634f8e3edd345f661ca9a8e9482e8/" rel="bookmark">
			R语言入门：R的基本绘图功能(柱状图、散点图、折线图、直方图和饼图)及其参数设置汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是一些无需安装R包的绘图函数小总结~包括了barplot()、plot()、boxplot()、pie()和hist()的简单用法和举例，几个函数之间大同小异。
注：这里只给出出了简单的用法，还有很多参数和用法正在补充中。
目录
1、barplot()函数
2、plot()函数
2.1 plot()函数的基本语法
2.2 参数解释
2.3 常用外观样式参数
2.4 绘制简单的散点图
2.4 绘制折线图
3、boxplot()函数
3.1 boxplot()函数的基本语法：
3.2 参数解释
3.3 绘制一个简单的箱线图
3.4 绘制一个复杂的箱线图 4、hist()函数
4.1 hist()函数的基本语法
4.2 常用的参数解释
4.3 绘制一个简单的直方图
5、 pie()函数
1、barplot()函数 用于创建柱状图，也称为条形图，用于可视化数据的分布或频率。柱状图通常用于显示分类变量的频率或连续变量的分组汇总数据。
以下是barplot()函数的基本用法及参数：
barplot(height, names.arg = NULL, beside = FALSE, horiz = FALSE, col = NULL, border = NULL, main = NULL, xlab = NULL, ylab = NULL, ...) 参数解释：
height：一个向量，表示每个柱子的高度，即频率或计数值。names.arg：一个可选的向量，表示每个柱子的标签，通常用于指定每个柱子的名称。beside：一个逻辑值，指示是否将柱子并排显示，默认为FALSE，表示垂直堆叠。horiz：一个逻辑值，指示是否绘制水平柱状图，默认为FALSE。col：柱子的填充颜色。border：柱子的边框颜色。main：图形的标题。xlab：x轴标签。ylab：y轴标签。...：其他参数，用于传递给plot()函数。 下面是一个简单的示例，演示如何使用barplot()函数创建柱状图：
# 创建一个向量表示不同类别的频率 height &lt;- c(10, 20, 15, 25) # 创建柱状图 barplot(height, names.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef634f8e3edd345f661ca9a8e9482e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5382f3e5e6c764242adc3865c043451/" rel="bookmark">
			mac IDEA激活 亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、官网下载mac版本IDEA并安装
2、打开激活页面
3、下载脚本文件
链接: https://pan.baidu.com/s/1I2BqdfxSJv1A96422rflnA?pwd=m494
提取码: m494
4、命令行到该界面，执行 sudo bash idea.sh
可能出现的问题：
查看sh文件，targetFilePath路径不对，可以改成正确的路径后重新运行
5、重启IDEA 打开激活页面，输入激活码 点击激活
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3710c469744a0b8107ff5f387cf72665/" rel="bookmark">
			2024全球前五SQL工具盘点｜竟是国产遥遥领先？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然数据库的查询和修改等操作看似复杂且令人望而生畏，但它们在数据处理中却是至关重要的环节。以往，访问数据库仅限于通过命令行方式，这种方式不仅缺乏直观性，而且容易引发错误，甚至可能带来严重的后果。然而，经过数十年的技术革新，如今我们已经拥有了众多sql工具。这些工具极大地简化了数据库的管理过程。更值得一提的是，这些工具中不乏开源和免费的选项。今天，我们就来一起看看有哪些优秀的数据库图形客户端工具可供选择。
1）Navicat
提到sql工具，永远绕不开Navicat，从1999年发布至今，支持多种数据库，包括MySQL。它提供了直观的用户界面，可以查看正在运行的SQL和执行查询。但是需要购买软件，且并不便宜，对于个人用户可能不太友好。此外，对于较大的数据库实例，可能需要更多的系统资源来支持监控和收集数据。
2）MySQL Workbench
MySQL官方推出的可视化工具不仅支持执行SQL查询，更可实时查看数据库服务器的运行状态和当前执行的SQL语句，功能全面且强大。然而，在处理大型数据库时，特别是执行复杂查询和操作时，该工具可能会遇到性能瓶颈，影响用户体验。此外，对于初学者而言，由于该工具的界面设计较为复杂，学习和上手的过程可能会面临一定的挑战。
3）DBeaver
开源免费的数据库管理开发工具，也是一款老牌 SQL 客户端，除了基本的可视化和管理能力，它还有 SQL 编辑器，数据和模式迁移能力，监控数据库连接等等，但不足之处也非常明显，对于大数据量的处理非常拉胯，仅仅几百万行数据就会崩
4）phpMyAdmin
这是另一个老牌的开源免费MySQL访问工具了,因为没有商业化的原因，phpmyadmin迭代速度非常慢，功能支持也很有限，感兴趣的可以了解一下，日常开发使用并不是很推荐
5）dbForge Studio for MySQL
dbforge是deva rt的核心产品，也是一个商业化收费软件，下载免费试用一段时间，但是仅支持windows版本，且标准版费用为199美元每年，起步价也并不便宜。
《重头戏》-- 国产软件SQLynx 说完了以上几款，下面必须要夸夸咱们的国产软件了，我以前是Navicat的忠实用户，但是最近深度使用了一段时间SQLynx之后，就再也回不去了，我简直想大呼：这才是2024年该有的SQL工具！
如果让我用一句话总结SQLynx，我想应该是这句：你没有的-我有，你有的-我更强
就比如我们最基础的数据导出，市面上大数据sql工具，在处理大数据量时，不是非常慢，就是直接崩，sqlynx导出1300W数据仅需74秒，如果你经常导出大数据量，一定会明白，这个速度有多夸张
再比如界面和交互，他没有使用大多数工具的工具栏或按钮设计，而是将几乎所有的操作，都放在了右键中，说实话我刚开始用的时候并不适应，但是用了不到一周，就明显发现，这才是最好的交互方式啊！Navicat最常用的查看表结构和表数据需要点很多下，但SQLynx仅需两步即可，大大提高工作效率，类似的地方还有非常多
还有上手难度，Navicat的上手难度其实不高，但是SQLynx可以说是小白也能轻松使用，他的图形化建表，一键生成sql语句、生成测试数据、一键数据迁移、结构比对等等功能，仅需通过鼠标点击即可完成，不夸张的说，即使你现在一句sql不会写，在15分钟之内，也可以完成数据库基础查询操作，且得益于上面说的右键设计，SQLynx的界面也更加直观
最后，作为国产sql工具，如果不支持国产数据源，简直天理难容！SQLynx除了主流数据库mysql、Oracle、PostgreSQL、SQL Server外，还支持达梦、人大金仓等国产数据源
说了这么多，真心推荐有需要的朋友，去麦聪软件官网免费下载体验一下，反正也不要钱，试试又何妨呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8247477c941407db52fee9b8443b82a6/" rel="bookmark">
			腾讯云向量数据库——RAG七天入门课笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、RAG介绍1-0、引言-大语言模型的不足1-1、向量数据库定义1-2、工作原理1-3、优点1-4、与传统数据库的区别1-5、RAG应用痛点 二、数据处理的难点——解析和拆分2-1、复杂文档格式-解析过程中的问题2-2、复杂文档解决流程2-3、Chunk拆分的问题以及如何改进 三、相似性检索的关键3-1、文本Embedding技术3-2、文本Embedding模型的演进3-3、VDB垂类Embedding模型 四、RAG的核心——结果召回和重排序4-1、完整RAG检索流程4-2、Query的预处理4-3、检索召回4-4、排序 五、让LLM理解知识——Prompt5-0、Prompt介绍5-1、示例很少、或者没有示例——生成一个手机配置5-2、"Let's think about this" 提示——有关于人工智能未来的探讨5-3、保持一致提示5-4、Prompt进阶技巧Cot5-5、优化Prompt 六、向量搜索精度的优化总结 前言 该篇笔记主要是为了了解向量数据库的一些优化点，以及其中涉及到知识的学习，重点并不在于介绍腾讯云推出的向量数据库，如果对腾讯云向量数据库感兴趣的小伙伴欢迎去结尾参考文章听公开课并测试使用！
一、RAG介绍 1-0、引言-大语言模型的不足 2023年，大语言模型爆发元年，不管是CloseAI出品的GPT系列模型，还是LLAma系列开源模型、Google的Gemini等模型等，其表现能力都让人叹为观止，大语言模型在自然语言领域的表现都远超以往任何模型。但是大语言模型也存在很多不足：在处理一些专业领域的知识时，会表现出知识缺失，这时候大语言模型可能无法提供准确答案。在解决此类问题时，数据科学家们通常使用的方法是对模型进行微调来适应特定领域的知识，将知识参数化，尽管这种方法取得了卓越的效果，但是其缺点在于成本高昂，需要专业技术知识。
针对大语言模型的另一种解决方案：参数化知识（微调）存在极大局限性，难以保留训练语料库中的所有知识，每一次知识的更新都要消耗大量的计算资源去训练模型。模型参数无法动态更新，参数化知识会随时过时。但是相比较于参数化知识（即通过模型微调来适应专业知识），非参数化知识，即存储在外部的知识源。更加方便、易于扩展。这种方法使得开发人员无需为每一个特定任务重新训练整个庞大的模型。他们可以简单地给模型加上一个知识库，通过这种方式增加模型的信息输入，从而提高回答的精确性。为了融合两种方式的优缺点，模型可以采取半参数化的方法，将非参数化的语料库数据库与参数化模型相结合，这种方法被称为检索增强生成（Retrieval-Augmented Generation, RAG）。
下图为RAG与其他模型优化方法的比较：
RAG工作流：
RAG工作流的主要步骤：
知识切片成Chunk向量化Chunk入库Query检索知识Chunk构建Prompts调用LLM生成回答 以下为LangChain+ChatGLM的一个RAG工作流：
1-1、向量数据库定义 向量数据库: 是一种用于存储和检索以及分析大规模向量数据的数据库系统。它主要应用于图像检索、音频检索、文本检索等领域。向量数据库使用专门的数据结构和算法来处理向量之间的相似性计算和查询，通过构建索引结构，能够快速找到最相似的向量，满足各种应用场景中的查询需求。生成式模型容易产生幻觉，向量数据库可以弥补这一缺陷，为生成式人工智能聊天机器人提供外部知识库，确保提供值得信赖的信息。
1-2、工作原理 工作原理: 在向量数据库中，数据以向量的形式进行存储和处理，因此需要将原始的非向量型数据转化为向量表示。数据向量化是指将非向量型的数据转换为向量形式的过程。通过数据向量化，实现了在向量数据库中进行高效的相似性计算和查询。此外，向量数据库使用不同的检索算法来加速向量相似性搜索，如 KD-Tree、VP-Tree、LSH 以及倒排索引等。在实际应用中，需要根据具体场景进行算法的选择和参数的调优，具体选择哪种算法取决于数据集的特征、数据量和查询需求，以及对搜索准确性和效率的要求。
1-3、优点 优点：
相似性搜索： 向量数据库专注于处理向量数据，并采用专门的索引结构和相似性计算算法，能够高效地进行相似性搜索。它能够快速找到最相似的向量，适用于人脸识别、图像搜索、推荐系统等需要相似性匹配的应用。复杂数据支持：向量数据库提供多种数据类型的支持，可通过数据向量化方法转换为向量形式。同时，向量数据库还能够支持各种复杂的查询操作，如范围查询、聚类分析、维度约减等。这使得它在不同应用场景下具备更丰富的数据分析和挖掘能力。机器学习能力：向量数据库通常与机器学习算法和工具集成，能够进行自动的特征提取、聚类分析和分类等任务。它能够支持数据驱动的应用，从数据中学习并提取有价值的信息。例如，向量数据库构建相似度模型，从而实现根据向量之间的相似性度量进行快速的相似性匹配和搜索。 1-4、与传统数据库的区别 远超传统关系型数据库的规模：传统的关系型数据库管理1亿条数据已经是拥有很大的业务流量，而在向量数据库需求中，一张表千亿数据是底线，并且原始的向量通常比较大，例如512个float=2k，千亿数据需要保存的向量就需要200T的存储空间（不算多副本），单机显然不具备这种能力，可线性扩展的分布式系统才是正确的道路，这对系统的可扩展性，可靠性，低成本提出非常大的挑战。查询方式不同：传统数据库查询通常为精确查询，结果一般为查到或者未查到，而向量数据库的查询是近似查询，即查找与查询条件相近的结果，所以查询到的结果是与输入条件最为相似的结果，这种查询方式对计算能力有非常高的要求。低延时与高并发：与传统数据库相比，时延大大降低，高并发。 1-5、RAG应用痛点 尽管RAG有很多优点，但是不可避免的，也有很多缺点：
文档处理：
如何处理原始数据？如何合理地切分Chunk？如何处理不同格式的文档？ Embedding：
如何选择Embedding模型？如何微调？Embedding的最佳实践？ Retrieval：
如何选择索引和参数？多路召回、Rerank、无效结果处理、MMR？如何处理Chunk上下文？ LLM：
PromptsQuery增强改写Query意图识别话题切换微调 其他问题：
用户的问题在知识库中如果未明确提到，则效果往往不尽如人意。常见专业问题是否有QA文档引导？ 在检索用户的问题时是否首先应该进行用户的意图识别？ 二、数据处理的难点——解析和拆分 2-1、复杂文档格式-解析过程中的问题 如下图所示：PDF格式多种多样
解析过程中容易遇到的问题如下：
内容不完整
文档整体内容被截断文档页内部分内容丢失格式无法判断导致缺失 内容错误
同页表格/文本/代码混合同页不同段落格式不标准 文档格式多样
Markdown/Text/JSONPDF/Word/PPTImage/CAD/Vieo/Audio 边界场景
跨页、双栏PDF跨栏表格合并单元格、代码块 2-2、复杂文档解决流程 复杂文档格式解决流程：
2-3、Chunk拆分的问题以及如何改进 Chunk拆分对最终效果的影响：
改进知识的拆分方案：
腾讯云向量数据库AI套件解决方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8247477c941407db52fee9b8443b82a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3142fb46adeb4c191e8c0db7cd89fcb/" rel="bookmark">
			Python获取list中指定元素索引的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平时开发过程中，经常遇到需要在数据中获取特定的元素的信息，如到达目的地最近的车站，橱窗里面最贵的物品等等。怎么办？看下面
方法一： 利用数组自身的特性 list.index(target), 其中a是你的目标list，target是你需要的下标对应的值 li = [10,8,9,26,72,6,28] print(li.index(8)) 但是，如果a中有多个8呢？
我们发现，这种方法仅仅能获取都第一个匹配的value的下标（可以试试o_o）
所以，我们看看我们的第二种方案：
方法二： 利用enumerate函数。 &gt;&gt;&gt; li = [10,8,9,26,72,6,28] &gt;&gt;&gt; print (enumerate(li)) &lt;enumerate object at 0x0000000002B9A990&gt; 原来enumerate的输出类型是enumerate object对象，所以，我们可以如下
&gt;&gt;&gt; li [10, 8, 9, 26, 72, 6, 28] &gt;&gt;&gt; print(list(enumerate(li))) [(0, 10), (1, 8), (2, 9), (3, 26), (4, 72), (5, 6), (6, 28)] &gt;&gt;&gt; print([i for i,j in enumerate(li) if j == 8]) [1] 再看，如果a中有多个‘8’呢？
&gt;&gt;&gt; li.append(8) &gt;&gt;&gt; li.append(8) &gt;&gt;&gt; li [10, 8, 9, 26, 72, 6, 28, 8, 8] &gt;&gt;&gt; print(li.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3142fb46adeb4c191e8c0db7cd89fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b768926eb5926857be0dfab833e937f8/" rel="bookmark">
			安卓系统root指北（采用adb&#43;Supersu的方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上篇文章，这里来讲一下我这两天自己摸索出来的安卓root方法。
一、必备知识 1.何为root及root的分类 因为Android基于Linux内核，所以很多东西都是互通的。熟悉Linux的同学都知道，root就是系统的超级用户，拥有rm -rf /的顶级权限(，而没法得到root权限的话就相当于你只能做一个普通的系统用户了，想要修改一点系统的内容简直寸步难行，而Android默认就是不给你这种权限的。
root权限又可以分为adb中的root权限和应用能获得的root权限。
在adb中，如果你获得了root权限，那么就相当于你自己获得了系统的完全控制权，也就意味着你可以执行rm -rf /了，当然不建议大家去轻易尝试这个指令哈。
而应用能获得的root权限则更为复杂一些，需要给系统中植入能够给进程操作提级的su程序，跟Linux中概念类似，用户用这个程序进行操作就相当于获得了root用户的权限。
2.安卓系统的基本构成 从最大的层面上来看，安卓系统有三部分构成：主系统，恢复系统Recovery和CPU引导系统BootLoader。下面是一些名词的基本介绍：
Bootloader（引导加载程序）：是一个位于设备内存中的程序，负责启动操作系统。Bootloader的主要任务是在设备启动时加载操作系统内核，并将控制权交给操作系统。在安卓设备上，Bootloader还负责执行各种启动阶段的初始化和配置工作。解锁 Bootloader： 一些设备的Bootloader是被锁定的，这意味着用户不能轻易修改或刷写自定义固件。一些设备允许用户解锁Bootloader，使其可以刷入自定义固件或操作系统。解锁Bootloader可能需要特定的步骤，且会导致设备的数据擦除。Fastboot 模式： Fastboot 是一种用于与设备交互的协议和工具。通过 Fastboot，用户可以在设备上执行各种操作，例如刷入新的Bootloader、Recovery或操作系统。使用 Fastboot 需要连接设备到计算机，并在计算机上安装相应的驱动和工具。Recovery 模式： Recovery 模式是一个独立于主操作系统的环境，允许用户执行一些高级的系统维护和恢复任务。在Recovery模式下，用户可以刷入更新、备份和恢复系统等操作。 二、adb命令行(android debug bridge)中如何以root用户进行操作 如果在adb中能够获得root用户的权限，那么下一步为应用授予root权限就会相对简单一点，那么adb中如何获得root用户权限呢？有如下两种情况：
2.1情况一：系统自带adb的root权限 这种情况你会发现直接执行adb shell就能够以root用户的身份操作，或者可以执行su命令提级为root用户，如果满足这两种那么恭喜你，可以直接看下一部分了。
2.2情况二：无法提级为root用户 没有权限提级为root用户，这时就需要从头做起了。需要按照以下步骤进行操作（或者你可以尝试使用一些所谓的一键root程序，网上有很多，但是个人不推荐且成功率低）：
2.2.1解BL锁（如果有的话） 如果你的设备有BL锁，必须先想办法解锁才能进行下一步操作。
2.2.2刷入新的recovery镜像 解开BL锁之后，通过fastboot刷入一个新的recovery镜像来替换原有恢复系统，推荐TWRP(Team Win Recovery Project)。TeamWin - TWRP
2.2.3运行TWRP，刷入root软件或带root的ROM包 根据你设备的类型启动TWRP系统，一般手机是长按电源键加音量上键，电视盒子就五花八门了。
启动后，你可以有两种选择（选择你喜欢的一种即可）：
下载Supersu.zip，按照TWRP的说明将其刷入主系统（本质是用root权限修改主系统的某些文件，如增加su程序）。（官方下载地址：Chainfire SuperSU Download - Official Download Page (supersuroot.org)）下载别人改好的带Supersu（或其他root权限管理软件）的ROM包，根据TWRP的说明刷入即可。 三、为应用授权root权限（adb方式） 注意：如果在上一部分中你属于情况二，并且已经按照步骤完成所有操作，那么你已经可以为应用授予root权限了，用你的root权限管理软件，如Supersu进行权限管理即可。
以下内容仅上述情况一的用户需要阅读！
如果你的adb可以提级为root用户，那么说明你的系统已经root了一部分，只是无法为应用授权root权限而已（或者说是没有一个管理应用root权限的工具）。但是不要紧，既然已经有了系统的root权限，那么直接动手去安装一个root权限管理工具就好了，例如Supersu，由于它有自己配套的su程序，原来的su程序肯定是不能用了，当然这个替换操作会由Supersu的替换脚本自己完成。
我们只需按照以下步骤就能安装好Supersu，无需刷入TWRP，也无需刷入新的系统。
下载Supersu的Zip包（其中包含各种CPU的依赖文件）Chainfire SuperSU Download - Official Download Page (supersuroot.org)
将下好的supersu.zip推到系统的/tmp目录
adb push /your/path/super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b768926eb5926857be0dfab833e937f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9674090e0e8b5eb61f3b99d62e6b0f9/" rel="bookmark">
			网上订餐系统|基于springboot的网上订餐系统设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上订餐系统目录
目录
基于springboot的网上订餐系统设计与实现
一、前言
二、系统功能设计
三、系统实现
1、用户功能模块的实现
（1）用户注册界面
（2）用户登录界面
（3）菜品详情界面
（4）下单订餐界面
（5）订单信息界面
（6）订单配送界面
2、管理员功能模块的实现
（1）管理员登录界面
（2）会员管理界面
（3）菜品信息管理界面
（4）菜品分类管理界面
（5）订单信息管理界面
（6）订单配送管理界面
四、数据库设计
1、实体ER图
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于springboot的网上订餐系统设计与实现 一、前言 很多餐饮商户开始通过网络建设订餐系统，通过专门的网上订餐系统，一方面节省了用户订餐的时间，给用户带来方便，另一方面给商户带来了新的销售模式，同时也使订餐的管理规范化，系统化，给人们的生活带来了很大的便利。
本文重点阐述了网上订餐系统的开发过程，以实际运用为开发背景，基于Spring Boot框架，运用了JSP技术和MYSQL作为系统数据库进行开发，充分保证系统的安全性和稳定性。本系统界面良好，操作简单方便，通过系统概述、系统分析、系统设计、数据库设计、系统测试这几个部分，详细的说明了系统的开发过程，最后并对整个开发过程进行了总结，实现了用户通过网络进行订餐的重要功能。
本基于Spring Boot的网上订餐系统运行效果稳定，操作方便、快捷，界面友好，是一个功能全面、实用性好、安全性高，并具有良好的可扩展性、可维护性的订餐平台。
关键词：网上订餐，JSP技术，数据库，Spring Boot框架
二、系统功能设计 本基于Spring Boot的网上订餐系统主要管理员模块以及用户模块两大部分，系统结构图如图4-1所示。
三、系统实现 1、用户功能模块的实现 用户进入本系统可查看系统信息，包括网站首页、菜品信息等，系统主界面展示如图5-3所示。
图5-1系统登录界面
（1）用户注册界面 未有账号的用户可进入注册界面进行注册操作，用户注册界面展示如图5-2所示。
图5-2用户注册界面
（2）用户登录界面 用户在登录界面可输入用户名和密码，点击登录按钮进行登录系统，用户登录界面展示如图5-3所示。
图5-3 用户登录界面
（3）菜品详情界面 用户可选择菜品查看菜品详情信息，登录后可进行下单操作，菜品详情界面展示如图5-4所示。
图 5-4 菜品详情界面
（4）下单订餐界面 用户登录后可选择菜品进行下单订餐操作，下单订餐界面展示如图5-5所示。
图5-5 下单订餐界面
（5）订单信息界面 用户对个人订单可进行查看、支付等，订单信息界面展示如图5-6所示。
图5-6 订单信息界面
（6）订单配送界面 用户能够查看个人订单配送信息，订单配送界面展示如图5-7所示。
图5-7 订单配送界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9674090e0e8b5eb61f3b99d62e6b0f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e735e739f2c0960133c34209547fef/" rel="bookmark">
			【AI】在docker中部署ollama体验AI模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在docker中部署ollama体验AI模型 1.docker部署ollama1.1.CPU模式1.2.GPU模式（需要有NVIDIA显卡支持）1.2.1.安装英伟达容器工具包（以Ubuntu22.04为例）1.2.2.docker使用GPU运行ollama 2.docker部署ollama web ui3.使用docker中的ollama下载并运行AI模型（示例为阿里通义千问4b-chat）4.ollama模型仓库（可以选择自己想用的模型安装体验） 1.docker部署ollama 1.1.CPU模式 docker run -d -v /opt/ai/ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama 1.2.GPU模式（需要有NVIDIA显卡支持） 1.2.1.安装英伟达容器工具包（以Ubuntu22.04为例） 其他系统请参考：英伟达官方文档
# 1.配置apt源 curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \ &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \ sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list # 2.更新源 sudo apt-get update # 3.安装工具包 sudo apt-get install -y nvidia-container-toolkit 1.2.2.docker使用GPU运行ollama docker run --gpus all -d -v /opt/ai/ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22e735e739f2c0960133c34209547fef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d2d11e10e078ed8c65a0da1510de65/" rel="bookmark">
			WebGIS面试题（第五期）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebGIS面试题（第五期） 以下题目仅为部分题目，全部题目在公众号{GISer世界}，答案仅供参考
1、Cesium的核心组件有哪些？ Cesium的核心组件包括Viewer、Scene、Model、Geometry、Material和Camera等。其中，Viewer是Cesium的主要接口，用于加载和显示3D地球和地图；Scene是场景管理器，负责管理所有的实体，如地形、建筑物、标记等；Camera则定义了视角和视距。
具体：
Viewer（查看器）：Cesium的主要入口点之一。提供了一个用于渲染三维地球的Canvas或WebGL容器，并管理了场景、相机、光照等方面的状态。Scene（场景）：表示三维场景的对象，包括地球、模型、图像等。负责管理渲染的对象、光照、相机等方面。Primitive（原始对象）：Cesium中的基本渲染单元，可用于表示地形、实体、模型等。它们可以是点、线、多边形等形式，用于构建复杂的地球表面和场景。Imagery（影像）：用于加载和显示地球表面图像的组件。支持各种地图服务提供商（如谷歌地图、Bing Maps等）以及自定义图像。Terrain（地形）：用于加载和显示地球表面高程数据的组件。允许将真实世界的地形数据集成到Cesium应用程序中，以实现更真实的地球模拟。Entity（实体）：表示三维场景中的可渲染对象，如飞机、汽车、点标记等。可以具有位置、方向、大小、外观等属性，并可以在场景中动态更新。Camera（相机）：控制场景视角的组件。允许用户控制相机位置、方向、缩放等参数，以浏览和导航场景。Geometry（几何体）：用于创建和处理几何形状的组件，如球体、盒子、圆柱体等。可以用于创建自定义的地球表面对象或模型。Interpolation（插值）：提供了在场景中执行插值和动画的功能。可以用于平滑地过渡相机位置、实体属性等。 这些是Cesium中一些核心的组件，用于构建各种类型的三维地球和地球上的应用程序。
2、请解释一下Cesium中的3D Tiles技术及其作用。 3D Tiles是Cesium中用于高效地加载和显示大规模的3D地球数据的技术。它可以将复杂的3D数据分层并进行高度优化，支持大规模的3D地球数据，包括城市、建筑、地形等，从而提高数据的加载速度和显示效率。
具体：
数据组织：3D Tiles技术允许地理数据按照层次结构进行组织，将地球表面划分为一系列的瓦片（tiles）。这些瓦片可以根据需要进行分辨率和细节层次的变化，使得数据可以在不同的缩放级别下进行加载和显示。数据压缩：3D Tiles使用各种压缩技术对地理数据进行压缩，以减少数据的存储和传输开销。这包括空间压缩、纹理压缩等技术，可以大大减少数据文件的大小，提高数据传输效率。动态加载：3D Tiles允许根据视图的位置和缩放级别动态加载和卸载数据瓦片，使得在浏览大范围地理区域时可以实现流畅的体验。这种动态加载的机制可以最大程度地减少内存和网络资源的占用。多样化数据支持：3D Tiles技术不仅可以用于地形数据，还可以用于表示建筑物、植被、城市模型等多种类型的地理数据。这使得Cesium可以呈现出丰富多样的地球表面细节，从而提供更具交互性和真实感的地理应用体验。开放标准：3D Tiles是一个开放的规范，其设计思想是为了支持各种类型的地理数据和应用场景。这意味着开发者可以自由地使用和扩展3D Tiles规范，以满足不同应用的需求。 3、CZML是什么，以及它用于描述什么样的场景？ CZML（Cesium Language）是一种描述和显示动态的地球场景的数据格式。它可以用于描述航班轨迹、气象数据、卫星运行轨迹等。CZML中可以包含实体的位置、速度、方向等信息，以及可视化效果的设置。
具体：
CZML可以描述的场景包括但不限于：
地球上的实体和标记：如建筑物、飞机、汽车、船舶等。这些实体可以具有位置、方向、大小、形状、颜色等属性，并且可以在时间上动态变化。传感器和效果：如雷达、热成像仪等传感器的位置和扫描范围，以及火焰、烟雾等效果的位置和状态。时间动画：CZML可以描述场景中各个元素随时间变化的行为。例如，可以定义飞机的航迹、车辆的移动路径、建筑物的建造过程等。地球上的图形和形状：如多边形、圆形、线条等。这些图形可以用于绘制地图上的区域、路径、边界等。图像和文本标签：CZML还支持在地球表面上添加图像、文本标签等元素，用于展示地理信息或其他内容。 4、Cesium如何处理地理位置信息？ Cesium使用ECEF（Earth-Centered, Earth-Fixed）坐标系来处理地理位置信息。ECEF坐标系是一种以地球中心为原点，以赤道面为基准面的三维坐标系。开发者可以使用Cesium的Cartographic类来转换地理位置信息到ECEF坐标系，或者使用Cesium的Ellipsoid类来计算地理位置信息的距离和面积。
具体：
Cesium 使用 ECEF（Earth-Centered, Earth-Fixed）坐标系作为其核心坐标系统来处理地理空间数据。ECEF 坐标系以地球的中心为原点，其 X 轴指向本初子午线与赤道的交点，Y 轴指向赤道与东经 90 度的交点，Z 轴指向北极。这种坐标系对于描述地球表面和空间中点的位置非常有用。
在 Cesium 中，经常需要处理不同坐标系之间的转换。Cartographic 类是 Cesium 中用于表示地理坐标（经度、纬度和高度）的类，而 Cartesian3 类则用于表示 ECEF 坐标系中的三维坐标。Cesium 提供了一系列方法，允许在 Cartographic 和 Cartesian3 之间进行转换。
1、可以使用 Cartographic.toCartesian 方法将地理坐标转换为 ECEF 坐标：
var cartographic = Cesium.Cartographic.fromDegrees(longitude, latitude, height); var cartesian3 = Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77d2d11e10e078ed8c65a0da1510de65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d47a55539742e5848c3c0dc40d983b/" rel="bookmark">
			XHS的X-S,a1,webId,web_session逆向分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XHS的X-S,a1,webId,web_session逆向分析 叠甲X-S分析webIdweb_sessiona1数据采集 叠甲 此文章只用作学习，请勿用做任何商业用途，如有侵权请添加微信z1348943384或QQ1348943384进行通知删除！如用本文中的代码去对他人造成不良影响，本人概不负责。
X-S分析 还原后代码
代码全扣，补环境即可。注意就是document.cookie里面需要有个a1参数。
// 环境补完这样调用即可 var webmsxyw = window._webmsxyw return webmsxyw(path, data); webId 就是个32位随机值，必须携带，但是可以随便生成
web_session 在没登入的情况是调用一个接口返回的，这个接口好像没有任何加密参数。
但是只有在登入后才能返回详细的数据，因此web_session参数里面包含了你的账号信息，我看网上有人说过期时间很久，就没有进行逆向，直接复制好了。
a1 a1在cookies里面，那就hook一下就行。找到位置后代码很简单。
这段代码的还原真的很简单，就是把几个生成参数进行拼接，随机值都可以直接写死。
数据采集 简单的写了一个脚本进行数据的采集，解决下代理ip和账号问题应该就可以了，我也不知道，因为没有大量采集过。不过好像还有个验证码的问题，下次试试看过下验证码。
下面就是保存好的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ff6b9bd390655147c238c3d2b7cbd1/" rel="bookmark">
			错误: 字段“datlastsysoid“不存在LINE 1: SELECT DISTINCT datlastsysoid FROM pg database
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 column “datlastsysoid“ does not exist
2 Line1:SELECT DISTINCT datalastsysoid FROM pg_database
问题分析
Postgres 15 从pg_database表中删除了 datlastsysoid 字段引发此错误。
决绝方案
解决方法1：升级navicat
解决方法2：降级pgsql
解决方法3：修改dll
实操演示
1、 打开 Navicat 安装目录，找到libcc.dll文件
2、备份libcc.dll文件，将其复制并粘贴为“libcc.dll.bak”或任何其他名称 3、在任何十六进制编辑器中打开此文件，如果需要，您可以使用在线工具，例如 https://hexed.it。
4、在文件中搜索“SELECT DISTINCT datlastsysoid”，并将其替换为“SELECT DISTINCT dattablespace”
修改
5、将文件保存在原始位置。如果遇到任何安全问题，请将其另存为“.txt”文件，然后还原备份文件
6、重启navicat，可以发现，无论老和新版本的pgsql，都可以正常访问了
————————————————
原文链接：https://blog.csdn.net/zxp3817100/article/details/134822475
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bda5ba73070fdffd92ca9fc8a9879bd/" rel="bookmark">
			uniapp-小程序保存图片到相册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序保存图片到相册 一. 将图片保存到手机相册涉及的api 有以下几个
1. uni.getSetting (获取用户的当前设置)
2. uni.authorize（提前向用户发起授权请求。调用后会立刻弹窗询问用户是否同意授权小程序使用某项功能或获取用户的某些数据，但不会实际调用对应接口。如果用户之前已经同意授权，则不会出现弹窗，直接返回成功。如果用户之前拒绝了授权，此接口会直接进入失败回调，一般搭配uni.getSetting和uni.openSetting使用）
3. uni.saveImageToPhotosAlbum (保存图片到系统相册。)
4. uni.openSetting (调起客户端小程序设置界面，返回用户设置的操作结果)
上代码 // html &lt;view class="save" @click.stop="saveImg" &gt;保存海报&lt;/view&gt; // js data(){ return { imgurl:"http://tmp/SfdWgOY45WZIabad69200882f9fee9f1a0cecc2c7275.png" } }, methods:{ saveImg(){ let that = this //获取授权列表，查看是否授权写入相册权限 uni.getSetting({ success(res) { if (!res.authSetting['scope.writePhotosAlbum']) { uni.authorize({ scope:'scope.writePhotosAlbum', success() { that.saveimgtoAlbum(that.imgurl) } }) }else{ that.saveimgtoAlbum(that.imgurl) } } }) }, saveimgtoAlbum(imgurl){ //图片保存到本地 let that = this uni.showLoading() uni.saveImageToPhotosAlbum({ filePath: imgurl, success: function (data) { uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bda5ba73070fdffd92ca9fc8a9879bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e763dc3b68d79a0e2d46ff64551898a/" rel="bookmark">
			npm常用命令以及运行环境检测，前端必学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权申明
原创作者：布依前端
公众号：布依前端
禁止转载，侵权必究
npm介绍 npm是Node Package Manager（Node包管理器）的缩写。它是一个用于安装、管理和共享JavaScript代码包的命令行工具和注册表。npm是JavaScript世界中最大的软件注册表，拥有超过100万个代码包，开发者可以通过npm下载和安装这些代码包，以便在自己的项目中使用。npm还提供了一些功能，如版本管理、依赖关系管理、脚本执行等。它是Node.js生态系统中非常重要的工具之一。
重要关联文章：
配置nvm管理nodejs版本的环境详细教程【window版】npm login登录失败解决办法，亲测好用利用npm仓库发布并使用自己的js工具类npm和nrm常用命令
当前演示环境 npm 常用命令 npm 是 Node.js 的包管理工具，用于安装、升级、卸载和管理 JavaScript 包。以下是 npm 的一些常用命令：
npm init：初始化项目，生成 package.json 文件。npm install：安装项目依赖包。npm install package-name@version：安装指定的包。npm install -g package-name：全局安装指定的包。npm uninstall package-name：卸载指定的包。npm update：更新项目的依赖包。npm update -g：全局更新已安装的包。npm outdated：检查项目的依赖包是否过时。npm run script-name：运行项目中定义的脚本命令。npm publish：将自己的包发布到 npm 上。npm search keyword：在 npm 上搜索包。npm list：列出当前项目安装的所有包。npm config set key value：设置 npm 的配置。npm config get key：获取 npm 的配置。npm config delete key：删除 npm 的配置。npm doctor：检查npm运行环境是否正常。npm ls: 查看当前项目依赖清单。npm view package-name versions：查看当前包发布版本清单。npm search package-name --searchlimit=1 --json=true：搜索包信息，–searchlimit搜索显示1条数据，–json以json格式查看。 这只是一些常见的 npm 命令，npm 还有很多其他命令和功能。可以通过运行 “npm help” 命令来查看 npm 的完整文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e763dc3b68d79a0e2d46ff64551898a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea2e9798d8675284a687e28416b203c/" rel="bookmark">
			Android中logcat日志、ANR日志、trace日志的介绍与分析方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Logcat日志 在Android开发中，日志是开发者在应用程序中添加的一种输出信息的记录方式，用于查看应用程序在运行时的状态、调试信息、错误信息等。Android日志可以帮助开发者追踪应用程序的行为、诊断问题并进行调试。Android提供了一系列的日志输出方法，其中最常用的是Logcat日志。
Logcat日志是Android系统中的一个日志记录器，用于显示系统和应用程序的日志消息。通过Logcat日志，开发者可以查看系统事件、应用程序的日志信息、异常信息等。下面是关于Android日志的简要介绍以及如何分析Android日志的步骤：
Android日志种类： 在Android开发中，常用的日志输出方式包括：
Logcat：Android系统默认的日志输出方式，可以通过Log类的方法在代码中输出日志信息，如Log.d(TAG, Message)。文件日志：将日志信息写入本地文件，可以通过文本编辑器或支持日志查看的工具查看。第三方日志库：如Timber、Logger等，提供更多功能、更强大的日志记录方式。 如何分析Android日志： 针对Logcat日志的分析，可采用以下步骤：
在Android Studio中，通过Logcat视图查看应用程序的日志输出。使用特定的过滤条件来筛选出特定事件或信息。搜索关键字，以便快速找到感兴趣的日志信息。分析日志的内容，包括时间戳、日志级别、线程名称等，识别问题的根源。根据错误信息，调试堆栈信息等分析具体的问题所在。根据日志信息定位问题，并进行相应的调试和解决。 示例说明：
假设我们开发了一个Android应用程序，用户在某个特定页面上报告说应用程序在点击按钮时会崩溃。为了定位和解决这个问题，我们可以通过分析Android日志来找到问题所在。
在Android Studio中打开Logcat视图，设置过滤条件为应用程序的包名，以便查看与该应用程序相关的日志信息。然后重新打开应用程序，在点击按钮导致崩溃的情况下，在Logcat中会看到相关的错误信息和堆栈跟踪。
假设我们在Logcat中看到了以下信息：
错误类型：NullPointerException堆栈跟踪信息：at com.example.myapp.MainActivity.onClick(MainActivity.java:50) 根据以上信息，我们可以确定问题出现在MainActivity.java文件的第50行，可能是在点击按钮时未正确处理空指针异常而导致应用程序崩溃。我们可以打开MainActivity.java文件，查看第50行的代码，并进行调试和修复问题。
修改相关代码后，再次测试应用程序，确保问题得到解决。通过分析Android日志，及时调试解决问题，保证应用程序的稳定性和用户体验。
Android日志可以帮助开发者查看应用程序的运行状态、调试信息和错误信息。通过分析Android日志，开发者可以诊断问题并解决bug，提高应用程序的质量和用户体验。通过适当记录和分析Android日志，可以让开发过程更加高效和有序。
Android的logcat日志是Android设备中常用的调试工具之一，它可以帮助开发者追踪应用程序和系统在运行时的行为和性能表现。通过分析logcat日志，开发者可以找到应用程序中可能存在的问题和错误，从而优化应用程序的性能和稳定性。
logcat日志通常包含以下信息：
时间戳：表示每个事件发生的时间。日志级别：表示事件的严重程度，如V、D、I、W、E等。线程名称：表示事件发生的线程名称。进程ID：表示发生事件的进程ID。事件详情：包含事件的详细信息，如系统调用、异常信息、资源使用情况等。 分析logcat日志的步骤如下：
打开logcat视图：在Android Studio中，进入设备连接窗口，选择要连接的设备，并打开Logcat视图。查看日志过滤器：在Logcat视图中，可以看到多个过滤器选项，如线程过滤器、关键字过滤器等。可以根据需要选择合适的过滤器来缩小日志范围。搜索关键信息：在Logcat视图中，可以通过搜索关键词来找到感兴趣的事件。例如，可以通过搜索特定的系统调用、异常信息等关键词来找到可能存在的问题。分析事件详情：在找到感兴趣的事件后，可以查看事件的详细信息，包括线程名称、进程ID、系统调用等信息。这些信息可以帮助确定事件发生的原因和上下文环境。 举例说明：
假设我们发现一个Android应用程序在运行时出现崩溃的情况，为了解决这个问题，我们可以使用logcat日志来分析崩溃发生时的行为。
首先，我们在Android设备上打开logcat视图，并设置适当的过滤器来只显示与应用程序崩溃相关的日志。在过滤器中，我们可以使用关键词“java.*”来筛选出所有Java相关的日志信息。
在Logcat视图中，我们可以看到崩溃发生时的详细信息，包括崩溃发生的线程名称、进程ID、系统调用等信息。通过进一步分析，我们可以确定崩溃发生的原因，例如某个特定的代码段引发了异常或者内存泄漏等问题。
根据分析结果，我们可以采取相应的措施来解决崩溃问题，例如修复代码中的错误、释放内存等。此外，我们还可以使用其他logcat功能来进一步分析应用程序的行为和性能表现，例如使用profile工具来分析应用程序的CPU和内存使用情况。
总结起来，通过使用Android的logcat日志，开发者可以找到应用程序中的问题和错误，从而优化应用程序的性能和稳定性。这种方法可以帮助开发者更好地了解应用程序的行为和性能表现，并针对性地解决问题。
ANR日志 ANR（Application Not Responding）是指应用程序无响应的情况，通常在主线程被长时间阻塞或死锁时发生。ANR是Android系统的一种保护机制，当应用程序无响应时，系统会弹出对话框，询问用户是否关闭应用程序。为了解决ANR问题，开发者需要分析ANR发生时的情况，找出导致无响应的原因，并进行相应的优化。
下面是分析Android应用程序发生ANR的一般步骤：
获取ANR日志： 当应用程序发生ANR时，系统会在/data/anr目录下生成一个名为traces.txt的文件，其中包含了ANR日志。开发者可以通过以下几种方式获取ANR日志：
在Android设备上手动查找/data/anr目录下的traces.txt文件。使用Android Studio连接设备并查看logcat输出，过滤关键字“ANR”来找到ANR日志。在设备上启用“ANR错误报告”功能，当应用程序发生ANR时，系统会生成ANR报告并提供给开发者。 分析ANR日志： 一旦获取ANR日志，开发者可以使用文本编辑器打开traces.txt文件，并分析其中的内容。ANR日志通常包括以下信息：
ANR发生的时间戳导致ANR的线程名称和堆栈信息进程ID触发ANR的原因和描述 查找ANR的原因： 根据分析ANR日志得到的信息，开发者可以查找导致ANR的原因。常见的导致ANR的原因包括：
主线程被长时间阻塞资源竞争导致死锁大量计算或I/O操作阻塞主线程内存泄漏导致内存耗尽 解决ANR问题： 一旦找到导致ANR的原因，开发者可以采取相应的措施来解决ANR问题。例如：
将耗时操作放到后台线程中执行，避免阻塞主线程。使用异步任务或RxJava等框架处理耗时操作。优化代码逻辑，减少主线程阻塞的情况。确保适时释放资源，避免内存泄漏。 举例说明：
假设我们的Android应用程序在某个页面加载数据时发生ANR，我们可以通过分析ANR日志来找到问题所在。假设我们从ANR日志中提取到以下信息：
ANR发生时间：2022-01-01 14:30:00导致ANR的线程：main线程堆栈信息：加载数据方法调用堆栈信息触发ANR原因：主线程被长时间阻塞 通过分析以上信息，我们可以得出结论：应用程序在主线程上进行了耗时的数据加载操作，导致了ANR问题。为了解决这个问题，我们可以考虑将数据加载操作放在后台线程中执行，使用异步任务或其他并发处理机制来避免主线程阻塞。
在代码中做出相应更改后，重新测试应用程序，确保ANR问题得到解决。通过持续优化和监控，可以提高应用程序的性能和用户体验，并避免ANR等问题的发生。
总结：
分析Android应用程序发生ANR的过程需要获取ANR日志并细致分析其中的内容，找出导致ANR的原因，并采取相应的措施进行优化。通过及时解决ANR问题，可以提升应用程序的性能和用户体验。
trace日志 Android的trace日志是一种系统级别的性能分析工具，它可以用来捕捉应用程序和系统在特定时间内的行为和性能表现。通过分析这些日志，开发者可以找到应用程序中可能存在的性能瓶颈和问题，从而优化应用程序的性能和稳定性。
trace日志文件通常包含以下信息：
时间戳：表示每个事件发生的时间。事件类型：表示事件的种类，如CPU使用率、内存使用情况、应用程序的启动时间等。事件详情：包含事件的详细信息，如线程名称、进程ID、事件具体描述等。 分析trace日志的步骤如下：
获取trace日志文件：在Android设备上，通常可以通过在/data/anr目录下找到名为traces.txt的文件来获取trace日志。如果找不到该文件，可以尝试在设备上启用anr功能，或者使用Android Studio的Device Monitor工具来获取trace日志。
使用文本编辑器打开traces.txt文件：可以使用任何文本编辑器打开traces.txt文件，例如使用Android Studio的Logcat视图、使用命令行的cat命令或者使用第三方工具如logcat等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea2e9798d8675284a687e28416b203c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7a2c49e98e7cbdade48d6aaca2e62b/" rel="bookmark">
			Kingbase(人大金仓)数据库通过命令进行数据备份和还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 命令在人大金仓数据库安装目录下的\Server\bin目录下执行，win系统在目录下cmd黑窗口执行，Linux直接执行
注意 向大版本一致的小版本还原，使用sql格式，dmp会有点问题
二进制备份命令（.dmp格式） 备份:
# 命令格式 sys_dump -h 【ip】 -p 【端口】 -U 【用户名】 -F c -f 【备份文件存储路径】 【库名】 # 示例 sys_dump -h 127.0.0.1 -p 54321 -U zhangsan -F c -f /usr/local/kingbase/test.dmp test 还原：
# 命令格式 sys_restore -h 【ip】 -p 【端口】 -U 【用户名】 -d 【库名】 【备份文件路径】 # 示例 sys_restore -h 127.0.0.1 -p 54321 -U zhangsan -d test /usr/local/kingbase/test.dmp SQL格式备份命令（.sql） 备份：
# 命令格式 sys_dump -h 【ip】 -p 【端口】 -U 【用户名】 -f 【备份路径】 库名 # 示例 sys_dump -h 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d7a2c49e98e7cbdade48d6aaca2e62b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/411/">«</a>
	<span class="pagination__item pagination__item--current">412/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/413/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>