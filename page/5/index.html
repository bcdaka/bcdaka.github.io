<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87948d2ace3a57000748ba3e68d29655/" rel="bookmark">
			怎么摆脱非自然链接？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是非自然链接？ 非自然链接是人为创建的链接，用于操纵网站在搜索引擎中的排名。非自然链接违反了Google 的准则，网站可能会因此受到惩罚。
它们不是由网站所有者编辑放置或担保的。示例包括带有过度优化锚文本的链接、通过 PR 的广告、嵌入在小部件中的隐藏或低质量链接等。 非自然链接最常见的例子是付费链接，即某个网站向另一个域名付费以获得指向其网站的“跟随”反向链接。 Google 将链接作为确定网页相关性的重要因素。任何旨在操纵 Google 搜索结果排名的链接都可能被视为链接垃圾。Google 不断改进其算法，以自动对抗非自然链接。
非自然链接如何影响SEO？ 非自然链接会损害你网站的 SEO 性能。链接质量是 Google 排名算法的一个因素，因此包含非自然链接可能会损害你的网站排名。 搜索结果可见度降低会使用户更难找到你的内容。这会减少你网站的自然流量。 在评估网站的非自然链接时，Google 会重点关注链接质量。Google 不会考虑域名的权重或PageRank，这意味着即使是信誉良好的网站也会因非自然链接而受到手动警告。
如果 Google 认为你的违规行为严重，它可以禁止你的网站，禁止意味着从 SERP 中彻底取消索引（删除）你的网站。这不是危言耸听！
如果你的网站从事垃圾信息或恶意行为，损害用户或其他网站，则可能会发生这种情况。例如，私人博客网络 (PBN)、恶意软件、伪装或从其他网站抓取内容，损害用户或其他网站。
非自然链接重要吗？ 非自然链接通常是通过黑帽 SEO 链接建设工作获得的。虽然它们在短期内可能有效，但它们会大大增加受到惩罚的风险。
一旦因非自然链接而受到惩罚，你的网站排名可能会大幅下降，而且很难恢复。这就是为什么网站管理员和 SEO 专业人员需要能够识别非自然链接并实施自然的白帽链接策略。 如果你将链接建设外包，了解这一点尤其重要。许多缺乏经验或质量低下的 SEO 服务使用黑帽链接建设策略，这可能会给你的网站带来麻烦。 学习如何查找和删除这些链接可以防止你受到严格的 Google 处罚。同样重要的是要记住，Google 的算法会随着每次更新而发展，因此 SEO 链接实践也会随之发展。
（PS：想要学习如何查找和删除非自然链接可通过SEMrush或Ahrefs等专业SEO工具进行查找。）
应该怎么摆脱非自然链接？ 其实，谷歌的算法非常复杂，大多数情况下会简单地忽略非自然链接，所以我们不必担心如何摆脱它们。
但是，如果你知道自己购买或继承了一些非自然链接，并且想确保不会收到 Google 的手动操作，则需要拒绝这些链接。
审核并清理所有非自然链接后，保持健康 DR （Domain Rating）(域名评级)的最佳方法是继续使用白帽链接建设策略。
（需要注意的是，不同的工具可能会使用不同的算法来计算DR值，因此同一个网站的DR值在不同的工具中可能会有所不同，DR值只是众多影响SEO排名的因素之一，它并不能保证网站在搜索结果中的表现，但它是一个有用的参考指标。）
这将帮助你向 Google 发出信号，表明你的网站是合法的，从其他高质量网站获得反向链接，并为用户提供真正的价值。
Google 链接垃圾邮件更新说明 谷歌于 2022 年 12 月推出了链接垃圾邮件更新，以遏制非自然链接对搜索结果的影响。 此次更新使用了 SpamBrain，这是谷歌自 2018 年以来一直在完善的基于人工智能的垃圾邮件预防系统。它经过训练可以大规模检测直接和间接垃圾邮件。 谷歌表示： 我们的算法和手动操作旨在大规模消除这些非自然链接，我们将继续提高我们的覆盖范围。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87948d2ace3a57000748ba3e68d29655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f3d6d5b534863a786ef9a73e13150f/" rel="bookmark">
			c&#43;&#43;修炼之路之智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：智能指针的必要性 二：C++11和boost中智能指针的关系
三：智能指针的使用及原理
1.RAII
2.智能指针的原理
3.底层实现 四：内存泄露 接下来的日子会顺顺利利，万事胜意，生活明朗-----------林辞忧 一：智能指针的必要性 int div() { int a, b; cin &gt;&gt; a &gt;&gt; b; if (b == 0) throw invalid_argument("除0错误"); return a / b; } void Func() { // 1、如果p1这里new 抛异常会如何？ // 2、如果p2这里new 抛异常会如何？ // 3、如果div调用这里又会抛异常会如何？ int* p1 = new int; int* p2 = new int; cout &lt;&lt; div() &lt;&lt; endl; delete p1; delete p2; } int main() { try { Func(); } catch (exception&amp; e) { cout &lt;&lt; e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f3d6d5b534863a786ef9a73e13150f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730bc81d2503610b72e39b6bd8531ed7/" rel="bookmark">
			【Python篇】PyQt5 超详细教程——由入门到精通（序篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PyQt5 超详细入门级教程前言序篇：1-3部分：PyQt5基础与常用控件第1部分：初识 PyQt5 和安装1.1 什么是 PyQt5？1.2 在 PyCharm 中安装 PyQt51.3 在 PyCharm 中编写第一个 PyQt5 应用程序1.4 代码详细解释1.5 在 PyCharm 中运行程序1.6 常见问题排查1.7 总结 第2部分：创建 PyQt5 应用程序与布局管理2.1 PyQt5 的基本窗口结构2.2 基本的 PyQt5 窗口与布局QWidget 与 QMainWindow 的区别 2.3 布局管理器2.4 在窗口中使用布局管理器2.5 代码详解2.6 更多布局管理器介绍QGridLayout (网格布局管理器)代码详解： 2.7 总结 第3部分：常用控件详解3.1 QLabel（标签）代码详解： 3.2 QPushButton（按钮）代码详解： 3.3 QLineEdit（单行文本框）代码详解： 3.4 QCheckBox（复选框）代码详解： 3.5 QComboBox（下拉列表）代码详解： 3.6 总结 1-3部分总结 PyQt5 超详细入门级教程 前言 建议把代码复制到pycharm等IDE上面看实际效果，方便理解嗷❤️
序篇：1-3部分：PyQt5基础与常用控件 第1部分：初识 PyQt5 和安装 1.1 什么是 PyQt5？ PyQt5 是 Python 的图形用户界面 (GUI) 框架，它基于强大的 Qt 库。Qt 是一个跨平台的 C++ 框架，用于构建桌面应用程序。通过 PyQt5，我们可以用 Python 轻松构建跨平台的桌面应用程序，支持 Windows、macOS 和 Linux。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730bc81d2503610b72e39b6bd8531ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa3386e8586aa7885a1a2017cbe12bb9/" rel="bookmark">
			【Java 学习】：内部类详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详谈Java内部类 📃📃本文将通过Java内部类 是什么，为什么被广泛使用，以及又该如何去使用这三个方面来详细讲解其相关知识。
文章目录
1. 内部类是什么
2. 为什么要使用内部类
3. 如何使用内部类
🍉成员内部类
🥑静态内部类
🥝局部内部类
🍋‍🟩匿名内部类
📖总结
1. 内部类是什么 🥬🥬🥬当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么这个内部的完整结构最好使用内部类。在 Java 中，可以将一个类定义在另一个类或者一个方法的内部，前者称为内部类，后者称为外部类。内部类也是封装的一种体现。
/** * 外部类 */ public class Outer { //... /** * 内部类 */ class Inner { //... } } 注：
我们一般将内部类分为四种：成员内部类、静态内部类、局部（方法内部类）、匿名内部类。外部类的定义是相对于内部类而言的 2. 为什么要使用内部类 🍈使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。——《Think in java》
🍈也就是说内部类拥有类的基本特征。（eg：可以继承父类，实现接口）在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。
注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，但是这里不推荐使用。
举个例子🌰
/** 1. OuterClass类继承了 A，实现了IFunctionA */ public class OuterClass extends A implements IFunctionA{ /** *	Inner类继承了 B，实现了IFunctionB */ public class InnerClass extends B implements IfunctionB{ // } } 除此之外，内部类还可以：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa3386e8586aa7885a1a2017cbe12bb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a215ba530e737dbd8e40819ad5860bf3/" rel="bookmark">
			C语言从头学56——学习头文件limits.h
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件limits.h定义了整数类型（包括字符型）取值范围的宏。
CHAR_BIT ：每个字符包含的二进制位数。
SCHAR_MIN ：signed char 类型的最小值。
SCHAR_MAX ：signed char 类型的最大值。
UCHAR_MAX ：unsiged char 类型的最大值。
CHAR_MIN ：char 类型的最小值。
CHAR_MAX ：char 类型的最大值。
MB_LEN_MAX ：多字节字符最多包含的字节数。
SHRT_MIN ：short int 类型的最小值。
SHRT_MAX ：short int 类型的最大值。
USHRT_MAX ：unsigned short int 类型的最大值。
INT_MIN ：int 类型的最小值。
INT_MAX ：int 类型的最大值。
UINT_MAX ：unsigned int 类型的最大值。
LONG_MIN ：long int 类型的最小值。
LONG_MAX ：long int 类型的最大值。
ULONG_MAX ：unsigned long int 类型的最大值。
LLONG_MIN ：long long int 类型的最小值。
LLONG_MAX ：long long int 类型的最大值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a215ba530e737dbd8e40819ad5860bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b4c997b20a4b42ae8d09c9b3fa43b1/" rel="bookmark">
			JavaEE-HTTP&amp;HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
HTTP协议
一、概念
二、http协议格式
http请求报文
http响应报文
URL格式
三、认识方法
四、认识报头
HTTP响应中的信息
HTTPS协议
对称加密
非对称加密
中间人攻击
解决中间人攻击
HTTP协议 一、概念 HTTP (全称为 "超⽂本传输协议") 是⼀种应⽤⾮常⼴泛的应⽤层协议，诞生于1991年，现在已经发展成为最主流使用的一种应用层协议。HTTP往往是基于传输层的TCP协议实现的，平时打开网页就是通过http协议来传输数据，当我们在浏览器中输⼊⼀个 搜狗搜索的 "⽹址" (URL) 时, 浏览器就给搜狗的服务器发送了⼀个 HTTP请求, 搜狗的服务器返回了⼀个 HTTP 响应 理解http协议的工作过程： 但实际在我们在访问时会涉及很多个请求/响应。 二、http协议格式 想要进一步了解http的工作过程以及http的报文格式就需要用到抓包工具（能够把网络上传输的http数据捕捉获取到并且显示出来），抓包工具相当于一个代理程序。 代理可以分为两种角色：（1）帮客户端跑腿的：正向代理 (2)帮服务器跑腿的：反向代理。 这里我们使用Fiddler来作为我们的抓包工具作为演示（Fiddler下载教程已出）。 http是一个文本协议，本质上http数据包就是按照上述http协议的格式将数据写入到tcp socket中。 http请求报文 分为四部分 （1）首行，包含三部分：（a）请求的方法，例如GET，表示请求的目的，GET是要从服务器获取数据 （b）请求的URL（对方的地址） （c）版本号。我们可以在浏览器上输入baidu.com来抓取后得到，分别用红绿蓝代表abc （2）请求头（Header）：此处本质上使用键值对（key-value）来表示，请求头可以是若干行，每一行本质上是一个键值对，键与值之间用：作为分割， 最后用空行代表结束 。 （3）空行：Header结尾处有一个空行作为结束，类似链表的null （4）正文（body）：可选的，可以有也可以没有，可以存放任何你想要存放的数据 http响应报文 也分为四部分 （1）首行，HTTP/1.1为版本号，200为状态码，OK为状态码描述，这样的首行代表是一个成功的响应，失败的响应会显示404not found（响应的几种状态在后面介绍） （2）响应头（Header），与请求的一样不限制行数，以空行作为结束 （3）空行：可以看到在Header中的最后一行有一个Content-Length代表了响应头的行数，可以 通过行数来找到空行，避免了粘包问题 （4）正文：正文中存什么都可以，空行也可以存，只有http数据包中的第一行才作为Header的结尾。 URL格式 URL的详细标准由因特网RFC1783来规定 协议方案名：描述了我们的URL接下来要干啥，例如我们在使用java操作数据库时输入的jdbc：mysql：// 登录信息：是上古时期登录方式 服务器地址：要访问的服务器是哪个， 域名/IP地址 服务器端口号：url中的端口号可以不写，浏览器会自动设置一个端口号，这个端口是服务器的端口，http协议就是80，https协议就是443 带层次的文件路径：描述了要访问服务器的哪个资源，一个服务器会提供很多资源给外界访问，比如一个网站会有很多不同的网页，这样就可以通过文件路径区分不同的网页。 查询字符串：就是一些参数，通过这些参数将客户端想告知服务器的参数传递过去；例如当我们在浏览器搜索URL格式，，就会出现q = URL格式的字样，这就是查询字符串。 当我们使用Fiddler进行抓取时可以得到URL是这样的 也可以看作是键值对结构，键值对之间用&amp;分开，键与值之间用=分割，这些键值对都是由程序员自己规定的含义。 可以看到在我们的q = URL后面存在一些用百分号进行分割的字符，这些其实utf8进行将汉字编码的结果，我们输入的是URL格式，我们在编码转换器中输入汉字格式就可以从得到的结果中发现与这里的是一致的 浏览器为了让客户看起来更方便，在浏览器中使用的是转码前，实际发送的是转码后。 汉字通常使用utf8进行转码，对于符号需要用到urlencode进行转码，如果直接进行转码可能会导致汉字的某个字节与符号的产生冲突导致解析错误，需要转码的字符会显示出这个字符原始的十六进制编码，在这个基础上加上%。 构造http请求一定要把需要转码的部分进行url encode，不进行urlencode可能会造成跳转失败。 片段标识符：区分页面中不同的目录，像是我们在csdn博客中的目录功能，点击一个目录可以直接跳转到该目录所在的界面。 三、认识方法 虽然方法有这么多， 但常用的只有GET和POST，GET语义上是从服务器获取数据，POST语义是往服务器发送/提交数据，在实际开发中这两个方法的界限越来越模糊，get可以用来提交并且post也可以用来获取；GET通常不会使用body而是用query string来传输数据，POST通常不搭配query string而是body来传输数据（这是使用习惯上的差别，但GET和POST都是有query string和body的）。 网络上大部分请求都是GET，通过query string告诉服务器要搜啥，服务器返回搜索结果完整网页。POST的使用场景少一些，通常是这些场景： （1）登录 （2）上传文件 上述http请求是如何构造的？ GET请求：（1）在浏览器地址栏直接输入url，此时就是GET请求；（2）网页html中可能会有一些特殊的标签，这些标签会带有一个url作为属性，页面被浏览器加载后解析到这些标签就会根据url构造出新的http请求；（3）表单，html中特殊的标签form；（4）通过js构造。 POST请求：（1）表单 （2）js。 小结：GET和POST的区别 （1）从本质上讲，GET和POST没有区别，GET能做的POST也能做，POST能做的GET也能做。 （2）从语义上来讲，GET用来获取数据，POST用来发送数据 （3）从传递数据来讲，GET用query string，POST用body （4）从响应结果幂等来讲，对于GET请求的设计通常是幂等的，而POST的设计则不要求幂等。 （5）GET请求的结果可以被缓存，可以被浏览器收藏，而POST一般不可以。 四、认识报头 1、Host：请求对应的主机的端口和ip；（ 通常情况下和url中的服务器地址是一样的） 2、Content—Length：body的长度， 一旦有body就要知道body的长度才能知道一个完整的http请求， 此处涉及到http机制对于粘包问题的解决：（1）分隔符，GET请求没有body就通过空行 （2）POST请求有body，通过空行找到body的开始，通过Content—Length找到body的结尾 3、Content—Type：body的类型， 通过http协议传输的数据类型有很多种类，例如：图片/视频/音频等等，这些不同的数据浏览器有不同的处理方式。 4、User—Agent（UA）：主要信息包含两个， 浏览器版本/操作系统版本， 描述了用户使用什么样的设备打开你的网页。 UA的主要作用是用来实现兼容，在互联网发展的早期浏览器只能显示文字，后来发展出可以显示图片/视频/音频等不同功能的浏览器，UA就可以告诉服务器此时用户用的是可以显示什么画面的浏览器进而提供服务；而现在UA的主要功能是来区分手机端和电脑端，如果是电脑返回一个宽屏网页，如果是手机返回一个窄屏的网页。 5、Referer：表示当前页面从哪个网页跳转过来，如果是直接在地址栏输入url或者点击收藏栏中的网页此时Referer处为空。 6、Cookie： cookie也是键值对格式的内容，和query string相似都是程序员自己定义的，每个网站都有自己的cookie，它的具体含义只有写这个的程序员自己知道； cookie这里的键值对本质上都是能够在客户端硬盘持久保存的：网页是运行在浏览器上的，默认情况下网页是不能直接访问硬盘的，但有些情况下有的网站确实需要在客户端硬盘持久的保存一些必要信息，浏览器就给网页提供了特定的机制——Cookie，cookie机制不是让网页随意访问硬盘，网页对于硬盘是没法直接读写的，浏览器对于硬盘操作做了特殊的封装，相当于提供了一组特殊文件，只能往这个文件中读写，并且写的内容也要求是键值对。 不同网站的cookie独立存储互不影响。 Cookie从哪里来？ cookie中的数据来自于服务器，如果你的浏览器第一次访问某网站，那么此时你浏览器对应的cookie是空着的，网站的服务器就会返回一些http响应，响应中会包含set-Cookie这样的Header，就会把一些键值对保存到对应的cookie中； 当cookie保存到服务器后，后续浏览器访问该网站时就会把在请求Header中将对应的键值对都带入进去再返回给服务器。 小结： Cookie是什么？ 浏览器本地存储持久化数据的典型机制。 Cookie怎么存的？ 按照不同的域名分别存储在硬盘上，不同域名之间的cookie互不干扰。 Cookie从哪里来？ 从服务器来，如果浏览器第一次访问网站，服务器的响应Header中会带有set-Cookie字段 Cookie到哪里去？ 在后续的请求中，请求的Header中带有cookie字段将信息传输给服务器。 Cookie的作用？ （1）存储用户偏好设置：通过使用Cookie网站可以记住用户的偏好设置，比如语言偏好/主题选择等； （2）实现用户认证：在需要用户登录的网站中，Cookie可以用来保持用户的登录状态，服务器在用户登陆成功后创建一个包含用户身份信息的Cookie发送给浏览器，访问这个网站的其他网页时就可以实现自动登录。 Cookie的典型应用场景：保存会话id HTTP响应中的信息 状态码 描述这次请求是否成功以及失败原因，在此介绍一些常见的： （1）200-OK：本次访问成功 （2）404-NOT FOUND：客户端访问的请求在服务器不存在 （3）403-Forbidden：客户端权限不足无法访问 （4）405-Method Not Allowed：请求中的方法服务器不支持 （5）500-Internal Server Error：服务器内部错误（出现bug了） （6）504-Gateway Timeout：服务器访问超时（问题常出现于服务器访问比较繁忙的时候） （7）302-Move Temporarily：临时重定向（访问某个服务器时访问的是旧地址，自动跳转到新地址），302响应中的Header会有Location字段显示接下来要跳转到哪个网站 （8）301-Move Permanently：永久重定向（访问的旧地址和新地址之间的映射关系固定了，此时浏览器会缓存这样的结果），后续浏览器在访问时就可以直接构造新地址的请求，减少一次http访问 HTTPS协议 HTTPS协议本质上就是HTTP协议加了一个加密层，抛开加密层别的部分都是一样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b4c997b20a4b42ae8d09c9b3fa43b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e2e4511bca2dc23b3e1f2c7f50ce9d0/" rel="bookmark">
			解决npm i 安装报npm ERR! code E401
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前端去维护项目时，通过 git clone 下来以后，经常是直接 npm i 去安装项目需要的依赖，但是往往很多项目不是我们自己写的，或者从 GitHub 上面 clone 的开源项目，这个时候出现问题就很难处理，这里分享下安装依赖报npm ERR! code E401
2、错误截图
3、一开始按照提示信息使用npm login登录了npm账号密码 ，然后重新跑npm i，结果依旧报这个错误。
4、解决方法：首先确定node版本，这里一方面我一开始使用的是20的版本，后来更换到14的版本，并且删除了package-lock.json文件，重新进行npm i即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f6aeabd7acbd8cac6ec3a8cad1ed6b/" rel="bookmark">
			华芯邦碳化硅SIC MOSFET性能卓越应用在新能源汽车充电领域，更在其高达235°C的环境中依然保持坚韧，175度的高温下依然能够稳定工作，不会因过热而失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		碳化硅功率器件市场预计在2028年达到90亿美元，展望十分广阔。MOS管因其低开关损耗、高开关速度，以及卓越的热稳定性，而广泛应用于高频开关场合。在新能源汽车充电机中，MOS管起着控制充电电流的关键作用。深圳市华芯邦科技有限公司提供多款高压MOSFET产品和碳化硅功率模块，这些器件以其高可靠性和稳定性，充分满足新能源汽车充电设备的需求。碳化硅MOSFET虽然与高压MOSFET在高压条件下工作相似，但由于其采用碳化硅材料，具备更高的工作温度稳定性、更低的导通电阻以及更快速的开关速度，在高温、大功率、高频和高压的应用领域中展现出无与伦比的性能。碳化硅材料的优势，使得这些器件在现代工业和科技应用中，愈发不可或缺。
碳化硅是一种先进材料，常被我们用于具备高温特性的元件中。相比常见的电源管理IC和MCU等产品，碳化硅材料在高温环境下能表现出卓越的性能。其次，碳化硅材料支持高频操作，这意味着它可以在短时间内进行大量的开关动作，大大提升了电子设备的响应速度。此外，由于其低损耗特性，碳化硅在能源转换过程中能够保持较高的效率，使电能在转换过程中失去的部分降到最低，同时还易于冷却，确保设备的散热性能良好。华芯邦推出的碳化硅mos具备极高的耐电压能力，能够在高电压环境中依然保持稳定运行。
进入电力电子领域，我们目睹庞然大物般的工业逆变器、汽车、飞机和风力发电机，虽然这些设备整体体积大，但其内部元部件却在不断缩小。电源设备的缩小不仅节省了宝贵的空间，还提高了效率和便携性，成为未来科技发展的必然趋势。无论在通讯领域还是在电力电子领域，虽然这些设备整体体积大，但其内部的元部件却在不断缩小。尤其是电源部分，体积越小越受欢迎,提高效率和便携性，这是未来科技发展的必然趋势。
在新能源汽车板块中，碳化硅技术展现出其显著的能效提升能力，使充电速度得以大大加快。如今，人们越来越追求环保出行，纯电动车成为首选。然而，尽管原厂标称的续航能力可达500公里、600公里，甚至800公里，但实际驾驶中，续航里程往往只能达到标称的六成左右。在寒冷天气下，这一数值还会进一步下降，从而使得充电问题愈加突出。假设车辆是高功率版本，每小时需要5000瓦的电量，同时在充电过程中必须确保充分的电力供应。然而，当电力转化效率不高时，充电效能将受到影响，产生大量无用的热能。这些热量不仅无价值，还浪费了宝贵的电力资源。碳化硅技术则能通过提高充电效率，减少热量的生成，从而有效减少能源浪费，实现更快的充电速度与节能的目的。这项技术不仅解决了许多现有的问题，更在新能源汽车的发展中有着广阔的应用前景。
假设连续开车一个小时，或者需要连续驾驶24小时，这对于任何设备来说都是一个巨大的考验。1000瓦的设备会持续运转很长时间，并发热严重。面对高温状况普通材料可能无法承受，但碳化硅却能从容应对。碳化硅在175度的高温下依然能够稳定工作，不会因过热而失效。华芯邦科技的实验表明，碳化硅可以在高达235度的环境中依然保持坚韧，尽管我们的技术规格书只是标注175度的安全温度。在这种高温测试条件下，235度的高温足以让其他IC设备难以承受，即使再高的温度再好的元器件，碳化硅承受耐力和耐高温始终是最后一个阵亡。
华芯邦科技作为行业领先企业，始终专注于碳化硅功率半导体产品应用，集功率器件和功率模块设计、研发、封装制造、测试和销售为一体。以车规级碳化硅功率模块、高压MOSFET、IGBT、SiC碳化硅为主的功率器件设计和模块封装，覆盖新能源汽车、家电消费类电子、AI人工智能、低空经济等应用领域。致力于成为全球功率半导体领域的引领者，完全满足车规级功率器件和模块的全参数测试需求，具备AEC-Q100、101、104车规级认证的可靠性评估及失效分析能力以及AQG324国际标准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5292180543b7a2aae5bc1c0baf228129/" rel="bookmark">
			哈希表与统计——594、350、554、609、454(2简3中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		594. 最长和谐子序列（简单） 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
解法一、哈希统计 如果不存在键，放入1。如果存在键，更新数量。如果存在num+1或者-1的键，更新最大值。
class Solution { public int findLHS(int[] nums) { HashMap&lt;Integer,Integer&gt; hm = new HashMap&lt;&gt;(); int max = 0; for(int num : nums){ if(!hm.containsKey(num)){ hm.put(num,1); }else{ hm.put(num,hm.get(num) + 1); } if(hm.containsKey(num+1)){ max = Math.max(max,hm.get(num) + hm.get(num+1)); } if(hm.containsKey(num-1)){ max = Math.max(max,hm.get(num) + hm.get(num-1)); } } return max; } } 解法二、排序+滑动窗口 滑窗和双指针做法到底什么差别orzzzz
class Solution { public int findLHS(int[] nums) { Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5292180543b7a2aae5bc1c0baf228129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4e0a79584ea3e4053b7fdda102296e/" rel="bookmark">
			828华为云征文｜Flexus X实例搭配华为云EulerOS，快速部署MySQL并执行读写性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言查看镜像信息什么是Huawei Cloud EulerOS？MySQL安装与启动启动MySQL连接MySQL配置MySQL 外网访问MySQL操作命令 数据库读写速度测试创建测试数据库通过SQL 语句创建测试表 Python写入测试Python读取测试 总结 前言 上一节中我们已经手把手的购买并进行连接了Flexus云服务器X实例具体可参考文章。
华为云征文｜Flexus云服务器X实例：打造行业通用工作负载的理想选择，旗舰体验引领性能新标准-CSDN博客
本篇博文将继续对华为云Flexus云服务器X实例进行MySQL相关的实例测评
查看镜像信息 本地连接服务器之后输入指令 lsb_release -a 查看镜像信息
从镜像信息中我们可以看到我们使用的镜像是Huawei Cloud EulerOS
什么是Huawei Cloud EulerOS？ Huawei Cloud EulerOS(简称HCE OS)，是基于华为开源社区openEuler构建的linux操作系统，提供云原生、高性能、安全稳定的执行环境来开发和运行应用程序，助力企业客户快速上云及开发者创新
MySQL安装与启动 原计划是通过指令安装一个MySql 的 但是当我输入指令
dnf install mysql5-server mysql5-common mysql5 显示如下内容
看到这里不得不改变原有计划 采用 yum install mysql 来进行尝试，效果如下
看上去还是不错的。
接下来我们将会在华为云Flexus云服务器X实例下进行MySQL 的一系列操作啦。
启动MySQL 通过指令systemctl start mysqld 来启动MySQL
当MySQL启动成功后通过指令 systemctl status mysqld 来查看状态
连接MySQL 通过mysql -u root -p 连接数据库
由于没有设置密码所以直接显示连接成功， 接下来我们设置以下密码
配置MySQL 相关指令如下
# 使用mysql库 use mysql; # 修改root的密码为root ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root'; # 刷新权限 flush privileges; # 退出 exit; 此时我们再次输入指令 mysql -u root -p 连接数据库的指令 会出现 输入密码的提示 ， 我们此时输入 root 即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c4e0a79584ea3e4053b7fdda102296e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5272a62d51dc50a746f2ec5ca4520e36/" rel="bookmark">
			微信小程序跳转到另一个微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用：http://www.xmdeal.com/mobanjiaocheng/254.html
第一种方法： wx.navigateToMiniProgram 官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateToMiniProgram.html
wx.navigateToMiniProgram({ appId: 'wxab81b7b534c8e4cd', path: 'page/index/index?id=123', extraData: { foo: 'bar' }, envVersion: 'develop', success(res) { // 打开成功 }, fail(res){ // 打开失败 }, complete(res){ // 调用结束 不管成功还是失败都执行 } /** * appId：跳转到的小程序app-id * path：打开的页面路径，如果为空则打开首页，path 中 ? 后面的部分会成为 query，在小程序的 App.onLaunch、App.onShow 和 Page.onLoad的回调函数中获取query数据 * extraData：需要传递给目标小程序的数据，目标小程序可在 App.onLaunch、App.onShow 中获取到这份数据 * envVersion：要打开的小程序版本，有效值: develop（开发版），trial（体验版），release（正式版），仅在当前小程序为开发版或体验版时此参数有效，如果当前小程序是正式版，则打开的小程序必定是正式版 */ }) 第二种方法： navigator 官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html
&lt;navigator class="btn" target="miniProgram" open-type="navigate" app-id="wx213c5ba6740c814d" version="trial"&gt;点击跳转另一个小程序&lt;/navigator&gt; /** * target：在哪个目标上发生跳转，默认当前小程序，有效值: self（当前小程序），miniProgram（其它小程序） * open-type：跳转方式 “avigate 对应 wx.navigateTo 或 wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5272a62d51dc50a746f2ec5ca4520e36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda2a2f05db830782bd6d02c2a08805d/" rel="bookmark">
			使用Amazon SageMaker JumpStart微调Meta Llama 3.1模型以进行生成式AI推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用Amazon SageMaker JumpStart微调Meta Llama 3.1模型以进行生成式AI推理Meta Llama 3.1SageMaker JumpStartSageMaker JumpStart中Meta Llama 3.1模型的微调配置使用SageMaker JumpStart UI进行无代码微调使用SageMaker JumpStart SDK进行微调结论 使用Amazon SageMaker JumpStart微调Meta Llama 3.1模型以进行生成式AI推理 通过Amazon SageMaker JumpStart微调Meta Llama 3.1模型，开发者可以定制这些公开的基础模型（FM）。Meta Llama 3.1系列代表了生成式人工智能（AI）领域的重大进展，提供了一系列功能以创建创新的应用程序。Meta Llama 3.1模型有多种规模，包括80亿、700亿和4050亿参数，适应各种项目需求。亚马逊云科技链接：https://aws.amazon.com/cn/free
这些模型的突出特点在于其理解和生成文本的能力，具有令人印象深刻的一致性和细腻的表达。凭借高达128,000个标记的上下文长度，Meta Llama 3.1模型能够保持深度的上下文意识，从而轻松处理复杂的语言任务。此外，这些模型经过优化，以实现高效推理，并采用了诸如分组查询注意力（GQA）等技术，提供快速响应能力。
在本文中，演示了如何使用SageMaker JumpStart微调Meta Llama 3.1预训练的文本生成模型。
Meta Llama 3.1 Meta Llama 3.1模型的一大特点是其多语言能力。这些仅限文本的指令调优版本（8B、70B、405B）旨在进行自然语言对话，并且在常见行业基准测试中表现优于许多公开的聊天机器人模型。这使得它们非常适合构建引人入胜的多语言对话体验，能够跨越语言障碍，为用户提供沉浸式互动。
Meta Llama 3.1模型的核心是经过精心优化的自回归变压器架构。模型的调优版本还采用了先进的微调技术，如监督微调（SFT）和人类反馈的强化学习（RLHF），以使模型输出与人类偏好保持一致。这种程度的优化为开发者打开了新的可能性，现在他们可以根据应用程序的独特需求调整这些强大的语言模型。
微调过程允许用户使用新数据调整预训练的Meta Llama 3.1模型的权重，从而提高它们在特定任务上的表现。这涉及将模型训练在针对任务量身定制的数据集上，并更新模型的权重以适应新数据。微调通常可以通过最小的努力带来显著的性能提升，使开发者能够快速满足其应用程序的需求。
SageMaker JumpStart现在支持Meta Llama 3.1模型，开发者可以通过SageMaker JumpStart UI和SDK探索微调Meta Llama 3.1 405B模型的过程。本文演示了如何轻松定制这些模型以满足特定用例，无论是在构建多语言聊天机器人、代码生成助手，还是其他任何生成式AI应用程序。提供了使用SageMaker JumpStart UI进行无代码微调的示例，以及使用SDK进行微调的示例。
SageMaker JumpStart 通过SageMaker JumpStart，机器学习（ML）从业者可以从广泛的公开基础模型中进行选择。可以将基础模型部署到从网络隔离的环境中专用的Amazon SageMaker实例上，并使用SageMaker进行模型训练和部署的定制。
现在，可以通过Amazon SageMaker Studio或通过SageMaker Python SDK编程方式，以几次点击的方式发现并部署Meta Llama 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda2a2f05db830782bd6d02c2a08805d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb6483e1274e7a6d5ef31aff280e277/" rel="bookmark">
			SQL Server数据库日志占满硬盘 运行不了了怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当 SQL Server 数据库日志文件（通常是 `.ldf` 文件）占满硬盘空间导致数据库无法运行时，你可以采取以下步骤来解决问题：
1. 备份事务日志:
- 如果数据库运行在完整恢复模式下（Full Recovery Model），你应该先进行事务日志备份。这样可以截断日志并释放空间。
- 使用以下命令进行日志备份：
BACKUP LOG [数据库名称] TO DISK = '路径\backup_log.bak';
- 备份完成后，日志会自动截断，释放一些空间。
2. 收缩日志文件:
- 在备份完成后，你可以通过以下命令收缩日志文件，进一步释放磁盘空间：
DBCC SHRINKFILE (N'日志文件逻辑名', 目标大小(MB));
- 可以通过以下查询获得日志文件的逻辑名称：
SELECT name FROM sys.master_files WHERE type_desc = 'LOG' AND database_id = DB_ID('数据库名称');
3. 更改恢复模式（可选）:
- 如果不需要完整恢复模式，可以将数据库恢复模式改为简单恢复模式（Simple Recovery Model），这样会自动截断日志，减少日志文件的增长。
- 更改恢复模式的命令：
ALTER DATABASE [数据库名称] SET RECOVERY SIMPLE;
4. 定期维护:
- 定期备份事务日志并收缩日志文件，防止日志文件再次占满磁盘空间。
5. 监控和调整:
- 检查数据库和应用程序是否存在大量事务未提交或长时间运行的事务，这些都可能导致日志文件急剧增长。
- 考虑增加磁盘空间或重新分配磁盘资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb6483e1274e7a6d5ef31aff280e277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da0eb70fbf9a2b52b8a3d0536109d38/" rel="bookmark">
			“Java比较攻略：从基本类型到引用类型，一文读懂“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：JavaSE
目录
基本数据类型的比较
引用数据类型的比较 基于Comparble接口类的比较
基于比较器比较
三种方法的对比
基本数据类型的比较 像 int、char、double 这种基本数据类型，我们可以直接采用 == 来进行比较是否相等。
public class Test { public static void main(String[] args) { int a = 10; int b = 20; int c = 10; System.out.println(a == b); // false System.out.println(a == c); // true } } 这里的 == 是比较变量对应数据值。即 a == b，是看 10 == 20的结果如何，返回的是一个布尔类型的值：true 或者 false。
引用数据类型的比较 对于 Integer、Double、Character 这种基本数据类型对应的引用数据类型，我们应该采用equals方法来进行比较。但是有的小伙伴可能对下面的代码会有疑惑：为什么同样是引用数据类型，结果的比较却不一样呢？不应该都是false吗？因为引用数据类型在用 == 进行比较时，是比较其两者的地址，因此都是false才对呀！ public class Test { public static void main(String[] args) { Integer a = 10; Integer b = 20; Integer c = 10; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da0eb70fbf9a2b52b8a3d0536109d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eddcb1c9d553f06cb964e378d924646a/" rel="bookmark">
			IP地址怎样实现https访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址实现HTTPS访问的过程涉及一系列步骤，主要是为了确保网站的安全性和可信度。以下是实现IP地址HTTPS访问的关键步骤：
一、确认公网IP地址与权限 公网IP地址：确保你拥有一个公网IP地址，因为只有公网IP才能从互联网直接被客户端访问。私有IP地址位于内部网络中，无法直接从外部访问。管理权限：你需要对该IP地址具有完全的管理权限，以便进行后续的证书申请和服务器配置。 二、选择证书颁发机构（CA） 并非所有证书颁发机构（CA）都提供为IP地址颁发SSL/TLS证书的服务，因此需要选择一个支持此功能的服务商。常见的支持IP证书的CA有JoySSL等。在选择CA时，请考虑其声誉、价格和服务等因素。
IP证书详情https://www.joyssl.com/certificate/select/ip_certificate.html?nid=22
三、提交申请并验证所有权 提交申请：打开JoySSL官方网站注册一个账号。在注册过程中，需要填写特定的注册码230922以获得大额优惠和技术支持。
然后下单IP专用证书并按照指引填写IP地址SSL证书的申请表格验证所有权：CA会要求验证你对IP地址的所有权或管理权限。验证完毕后，等待CA签发证书。 四、下载并安装SSL/TLS证书 签发成功后，从Joyssl后台下载SSL证书文件。然后，在服务器上安装这些证书文件，将SSL证书绑定到相应的IP地址上。
五、测试与验证HTTPS访问 配置完成后，使用浏览器通过IP地址访问你的网站，检查是否显示安全锁图标，并确认HTTPS连接已正确建立。
通过以上步骤，你可以在没有域名的情况下，仅通过IP地址实现HTTPS访问。然而，考虑到用户体验、品牌识别度和SEO等因素，使用域名而非IP地址进行HTTPS访问通常是更好的选择。同时，为了确保网站的安全性和可靠性，建议在选择证书颁发机构和配置服务器时谨慎行事，并遵循最佳实践。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935c87b1787f0fa494889fbff465385b/" rel="bookmark">
			【ORACLE】独有的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle数据库提供了大量的内置函数，这些函数可以帮助开发者进行数据处理和计算。以下是一些Oracle独有的函数：
WM_CONCAT()：这是一个聚合函数，用于将多个行的字符串值连接成一个字符串，通常与GROUP BY子句一起使用。例如，SELECT WM_CONCAT(username) FROM users GROUP BY group_id; 会将同一个组内的所有用户名用逗号连接起来。
DECODE()：这个函数类似于一系列的嵌套IF-THEN-ELSE语句。它比较一个值与一系列可能的值，并返回相应的结果。如果没有任何匹配，它返回一个默认值。
INSTR()：这是一个字符查找函数，用于返回子字符串在字符串中的位置。它可以有多个参数，包括起始位置和要查找的子字符串出现的次数。
STRCAT()：这个函数用于连接两个或多个字符串。
SUBSTR()：这是一个字符串截取函数，用于从字符串中提取子字符串。
SYSDATE：返回当前的日期和时间。
TO_DATE()：将字符串转换为日期类型。
ADD_MONTHS()：在日期上添加或减去指定的月份数。
LAST_DAY()：返回给定月份的最后一天。
TO_CHAR()：将数值或日期转换为字符串。
TO_NUMBER()：将字符串转换为数值。
NVL()：如果字段为空，则可以用另一个值来替代。
NULLIF()：如果两个参数相等，则返回NULL，否则返回第一个参数。
COALESCE()：返回参数列表中的第一个非空值。
GREATEST()：返回参数列表中的最大值。
LEAST()：返回参数列表中的最小值。
RPAD() 和 LPAD()：分别用于在字符串的右侧和左侧填充字符以达到指定的长度。
这些函数在Oracle数据库中非常有用，可以帮助开发者进行高效的数据处理。更多详细信息和使用示例，可以参考Oracle官方文档或其他专业资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f77d5d741e18b30efb601cc1b64952/" rel="bookmark">
			【机器学习】树模型以及决策树的基本概念、决策树与随机森林的区别以及决策树在python中的实例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 机器学习中的树模型是一种广泛使用的算法，主要用于分类和回归任务
文章目录 引言一、树模型1.1 常见的树模型1.1.1 决策树（Decision Tree）1.1.2 分类与回归树（CART）1.1.3 ID3算法1.1.4 C4.5算法1.1.5 随机森林（Random Forest）1.1.6 梯度提升树（Gradient Boosting Decision Tree, GBDT）1.1.7 XGBoost 1.2 树模型的特点 二、决策树2.1 决策树的定义2.2 决策树的组成部分2.3 决策树的构建过程2.4 停止条件2.5 决策树的优缺点2.5.1 优点2.5.2 缺点 2.6 总结 三、决策树和随机森林的区别3.1 决策树3.1.1 结构3.1.2 预测3.1.3 过拟合3.1.4 稳定性 3.2 随机森林3.2.1 结构3.2.2 预测3.2.3 过拟合3.2.4 稳定性 3.3 主要区别3.4 总结 四、决策树在python中的实例4.1 数据准备4.2 模型构建与训练4.3 模型评估4.4 决策树可视化4.5 总结 一、树模型 树模型通过一系列的决策规则来预测目标变量的值
1.1 常见的树模型 1.1.1 决策树（Decision Tree） 决策树是一种基本的树模型，它通过一系列的判断节点来对数据进行分类或回归。每个节点代表一个特征，每个分支代表一个特征的取值，最终的叶子节点代表预测结果 1.1.2 分类与回归树（CART） CART是一种决策树算法，它可以用于分类（Classification and Regression Trees）和回归任务。CART通过基尼不纯度或均方误差来选择最优的特征和切分点 1.1.3 ID3算法 ID3（Iterative Dichotomiser 3）是一种基于信息增益的决策树算法。它选择具有最高信息增益的特征来分割数据集，直到满足停止条件 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f77d5d741e18b30efb601cc1b64952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678e70b3b9ab2ffc7bcb6800d062a921/" rel="bookmark">
			全面掌握MySQL数据备份策略的风险管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今这个数据驱动的时代，数据库备份策略是确保数据安全和业务连续性的关键。MySQL，作为广泛使用的开源数据库管理系统，提供了多种备份工具和策略。然而，备份过程中的风险管理同样重要，它可以帮助我们识别、评估和缓解备份过程中可能遇到的问题。本文将详细介绍如何在MySQL中实现数据备份策略的风险管理，包括策略制定、执行、监控和优化。
1. 理解风险管理的重要性 在制定MySQL数据备份策略之前，首先需要理解风险管理的重要性。风险管理是识别、评估和优先处理风险的过程，以减少它们对组织的影响。在数据备份的上下文中，风险可能包括数据丢失、备份失败、恢复时间延长等。
2. 制定备份策略 制定备份策略是风险管理的第一步。一个好的备份策略应该包括以下要素：
全备份与增量备份：全备份可以提供数据的完整副本，而增量备份则只记录自上次备份以来发生变化的数据。结合使用可以减少存储需求并加快恢复速度。定期备份：根据业务需求，定期进行全备份和增量备份。备份验证：定期验证备份文件的完整性和可恢复性。备份存储：选择合适的存储介质，如硬盘、磁带或云存储，并确保备份数据的安全性。 3. 执行备份操作 执行备份操作时，可以使用MySQL提供的多种工具，如mysqldump、mysqlpump和Percona XtraBackup。以下是使用mysqldump进行全备份的示例代码：
mysqldump -u root -p --all-databases &gt; alldb_backup.sql 对于增量备份，可以结合使用mysqldump和逻辑备份工具如LVM快照。
4. 监控备份过程 监控备份过程是确保备份成功并及时发现问题的关键。可以通过以下方式进行监控：
日志记录：确保备份工具记录详细的日志，包括成功、失败和警告信息。报警系统：设置报警系统，当备份失败或遇到问题时及时通知管理员。定期审计：定期审计备份日志和备份文件，确保备份策略的有效性。 5. 测试恢复过程 测试恢复过程是验证备份策略有效性的重要步骤。以下是测试恢复过程的一些建议：
定期恢复测试：定期从备份中恢复数据到测试环境，确保数据的完整性和可恢复性。多场景测试：测试不同的恢复场景，如单个表恢复、数据库恢复和全系统恢复。 6. 优化备份策略 根据监控和测试的结果，不断优化备份策略。优化可能包括：
调整备份频率：根据数据变化的频率和业务需求调整全备份和增量备份的频率。改进存储策略：根据存储成本和恢复时间目标，优化存储介质和备份文件的存储位置。增强安全性：定期更新安全措施，如加密备份文件和限制访问权限。 7. 文档化和培训 文档化备份策略和流程，并对相关人员进行培训，确保团队成员理解备份策略和操作流程。
8. 合规性和审计 确保备份策略符合行业标准和法规要求，并定期进行审计，以验证策略的合规性。
结论 数据备份策略的风险管理是一个持续的过程，需要不断地评估、监控、测试和优化。通过实施上述策略，可以最大限度地减少备份过程中的风险，确保数据的安全和业务的连续性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa8a0cf75c91b05f08cc0d190e7b801/" rel="bookmark">
			ETL数据集成丨SQLServer到Doris的无缝数据同步策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代企业数据架构中，数据整合是至关重要的一个环节，它不仅关乎数据的准确性与一致性，还直接影响到数据分析的有效性和业务决策的精确性。Doris（原名 Palo）与 Hive 是两大在大数据处理领域内广泛应用的数据存储与分析系统，它们各有千秋，适用于不同的场景。将Doris数据整合至Hive数据库，旨在融合两者的优势，构建更为强大、灵活的数据分析平台，以支撑复杂多变的业务需求。
Doris与Hive的特点对比 Doris是一个高性能的MPP（大规模并行处理）数据库，专为OLAP（在线分析处理）设计，擅长处理复杂的分析查询，提供低延迟的即席查询能力。其分布式架构、列式存储以及先进的索引机制，使得在海量数据上进行亚秒级响应成为可能。Doris还支持实时数据导入，非常适合实时分析场景。
相比之下，Hive则起源于Hadoop生态系统，最初作为SQL接口被设计来处理批处理式的数据分析任务，适合处理PB级别的静态数据仓库应用。Hive通过HDFS存储数据，利用MapReduce或Tez等执行引擎进行计算，虽然在交互式查询性能上可能不如Doris，但其生态丰富、兼容SQL标准，且易于与Hadoop生态内的其他组件集成，如Spark、HBase等，提供了强大的数据处理和管理能力。
Doris与Hive同步方式 Doris与Hive作为大数据处理领域中两个重要的数据仓库系统，它们在数据分析、报表生成以及大规模数据处理场景中扮演着核心角色。尽管两者都旨在提供高效的数据存储与查询能力，但它们的设计理念、架构特点及应用场景各有侧重。因此，在实际应用中，实现Doris与Hive之间的数据同步不仅能够充分发挥两者的优势，还能促进数据资源的有效整合与利用。
Doris与Hive之间的数据同步策略应根据实际应用场景、数据量大小、实时性要求以及资源条件综合考虑。直接导出导入适用于小型项目或一次性迁移；而借助中间件、ETL工具或自定义脚本则能更好地应对大规模、实时性需求；利用系统间的桥接服务，则是在保持数据源独立性的同时，实现跨系统查询的有效途径。每种方法都有其优势与局限，关键在于合理选择与灵活应用，以达到数据同步的最佳效果。
借助ETLCloud工具实现Doris数据同步至Hive数据库演示 通过对组件的拖拉拽以及配置，能快速构建数据整合通道。
流程设计
库表输入组件配置
选中Doris数据源并选中要读取数据所在的表
Hive输出节点组件配置
Hive输出节点是针对Hive数据库写入数据的组件，大大增加了数据传输到Hive的效率。
流程运行结果
轻松同步100W的数据量。
除了最基本的同结构表同步数据，ETLCloud还提供了非常丰富的数据转换、运算组件来应对同步的各种情况，比如当上述数据源的表字段不一致的话，可以在中间加入字段值映射组件来进行两张表的字段映射：
而如果想要目标表多一个字段并且赋予一个由其他两个字段进行数学运算得出的值，还可以使用字段值计算组件。
最后 在各种数据源之间进行数据迁移，选择合适的工具能够高效地解决问题。ETLCloud 作为一款高效的数据迁移工具，能快速把Doris的海量数据同步至Hive数据仓库，无论是数据分析，还是要对数据进行转换处理，平台都有针对性的功能、组件，帮助提升数据管理的效率和效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0efa1cb22699da401345fa060650a2c/" rel="bookmark">
			vue 踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地开发没有cookie 解决方案
设置代理，并把changeOrigin设为true
proxy的changeOrigin如果设置为false：请求头中host仍然是浏览器发送过来的host；
如果设置成true：发送请求头中host会设置成target。
允许axios请求携带cookie等凭证
避坑：vite Component provided template option but runtime compilation is not supported in this…
This worked for me in vite.config.js export default defineConfig({ define: { "process.env": {} }, plugins: [vue()], resolve: { alias: { "vue": "vue/dist/vue.esm-bundler.js" } } }) // 这里是重点 antd 主题色更换踩坑 参考https://www.icode9.com/content-4-524054.html
vue3 vite 不能使用require 的替代方案
方案一：
const getUrl=(url)=&gt;{ return new URL(url,import.meta.url).href; } // 使用 const imgsrc = getUrl('../assets/images/logo.png'); 或页面中直接使用
&lt;img :src="getUrl('../assets/images/logo.png')" style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0efa1cb22699da401345fa060650a2c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/6/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>