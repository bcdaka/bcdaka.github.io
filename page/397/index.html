<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f25bdd3c809bd9054c7c6c1e1bcb9b4/" rel="bookmark">
			东方通TongWeb（外置容器）部署spring boot项目（jar包改war包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat信创平替之TongWEB(东方通)、springboot项目东方通TongWeb改造以及部署、东方通TongWeb7.0.4.9部署包安装下载 本文提供了两个示例：kotlin跟java
东方通TongWeb（外置容器）部署spring boot项目（war包）
东方通TongWeb（外置容器）部署kotlin项目（war包）
spring boot项目打包方式由jar包改成war包
kotlin项目打包方式由jar包改成war包
一：准备好应用war包：
1、carrier工程（后端，kotlin语法）打包方式由jar包改成war包（修改pom文件）
2、排查内置Tomcat
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 去除内嵌tomcat --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; ①注释掉其它Tomcat相关依赖
①启动类继承 SpringBootServletInitializer 类，并重写 configure 方法
fun configure(application: SpringApplicationBuilder) { application.sources(CarrierApp::class.java) } ②然后 maven clean install 得到war包
3、前端打成war包
①首先 在项目目录下面npm run build:prod 打成dist包（这里前端打包的命令就是参考项目package.json的script命令）
②进入dist路径下面，在这里新建一个WEB-INF文件夹，然后在文件夹里面放入一个web.xml文件，用来解决tongweb部署404问题。如下
&lt;web-app&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/index.html&lt;/location&gt; &lt;/error-page&gt; &lt;/web-app&gt; ③进入dist包，然后在这个dist目录层级下输入cmd ，打开命令窗口后输入以下命令把前端dist包也打成一个war包，项目名称随便取。（这个war包打完会在dist文件夹里面）
jar -cvf 项目名称.war * 4、sunimp工程（三个应用中sunimp-app为例，java语法）：工程目录如下图
①修改pom文件:将打包方式更改为 war
②排查内置Tomcat
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 去除内嵌tomcat --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f25bdd3c809bd9054c7c6c1e1bcb9b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51971059887783b7e4daee57a0135cbd/" rel="bookmark">
			获取安卓apk证书SHA1等签名信息的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前提：确保安装了jdk环境，并正确配置了环境变量。高版本的jdk目前不支持MD5，需要MD5信息建议下载低版本。jdk下载https://download.csdn.net/download/m0_58665272/89219957
方法一：已经打包成apk文件，怎么获取签名信息 ①将打包好的.apk文件,修改为.zip格式，并解压文件
②解压好文件之后，找到.RSA文件，复制路径
③打开cmd运行命令（xxx.RSA是你第②步中复制的路径）
keytool -printcert -file xxx.RSA 运行结果就能看到SHA1值了，低版本的jdk还可以看到MD5信息
方法二：已经打包成apk文件，不用解压缩的超简易命令 直接找到apk文件位置，复制路径，cmd执行命令
keytool -printcert -jarfile xxx.apk 方法三：直接根据签名文件，获取签名信息。 找到你的签名文件位置，在相应的磁盘路径下操作（xxx.keystore是你的文件名称）
keytool -list -v -keystore xxx.keystore 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb768417b87ec23bb0ff108bee3ea623/" rel="bookmark">
			chacha20 算法流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chacha20算法请参看 RFC:7539。下面是我的理解，欢迎指正。
chacha20算法的基本思想：加密时，将明文数据与用户之间约定的某些数据进行异或操作，得到密文数据；由异或操作的特点可知，在解密时，只需要将密文数据与用户之间约定的那些数据再次进行异或操作，就得到了明文数据。
用相同值异或两次就能恢复出原来的值，所以加密和解密都严格采用同一个程序。
从原理上来说，chacha20的加解密过程还是非常简单的。这里面的难点在于理解 chacha20中那些用来与明文数据进行异或的数据是如何生成的，这就是 chacha20算法的核心所在。
大体的流程是这样的：首先，用户之间会约定一些初始的元数据，简单起见，称之为 KEY_INIT，则 KEY_INIT需要经过某种运算，得到另外一个 KEY_1，然后用 KEY_1与明文数据的第 1个分组进行异或，以得到密文数据的第 1个分组，接下来，KEY_INIT再经过某种运算，得到另外一个 KEY_2，然后用 KEY_2与明文数据的第 2个分组进行异或，以得到密文数据的第 2个分组，以此类推，直到处理完所有的明文分组。从这里可以看到，与每个明文分组进行异或的数据（KEY_n）是不相同的，且与分组所对应的顺序有关。
下面讲解一下如何由 KEY_INIT得到 KEY_1, KEY_2, ..., KEY_n。
首先需要明确的是，在 chacha20算法中，KEY_INIT和 KEY_n的长度是相同的，都是 64个字节。因此，明文分组的长度也是 64字节，即 16个 4字节整数。
其中，KEY_INIT由 4部分组成：
KEY_INIT[0]~ KEY_INIT[15]是 16字节的常量（constant）;
KEY_INIT[16]~ KEY_INIT[47]是 32字节的 key;
KEY_INIT[48]~ KEY_INIT[51]是 4字节的 block counter;
KEY_INIT[52]~ KEY_INIT[63]是 12字节的 nonce。
按顺序将上述 16个 4字节整数排列成 4x4的矩阵，记为矩阵 M，它的内容示意如下：
cccccccc cccccccc cccccccc cccccccc kkkkkkkk kkkkkkkk kkkkkkkk kkkkkkkk kkkkkkkk kkkkkkkk kkkkkkkk kkkkkkkk bbbbbbbb nnnnnnnn nnnnnnnn nnnnnnnn 其中，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb768417b87ec23bb0ff108bee3ea623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d706b6071b095d54572711b7745fb71/" rel="bookmark">
			sql server如何导出与导入数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、导出数据库
选择school数据库，右键点击任务➡分离，勾选分离数据库的删除和更新，点击“确定”
然后sql server就成功导出mdf和ldf文件了，默认导出的路径在 C:\Program Files\Microsoft SQL Server\MSSQL10_50.MSSQLSERVER\MSSQL\DATA。
带走mdf文件就可以了
二、导入数据库
点击数据库，右键选择附加，选择要导入的mdf文件，如果下面有找不到的东西，选择删除，点击确定。数据库导入完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3af5128d117b34171a2ed253a37821/" rel="bookmark">
			Mac 利用Homebrew安装JDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装JDK17 1.安装openjdk17
2.把homebrew安装的openjdk17软链接到系统目录：
brew install openjdk@17 sudo ln -sfn $(brew --prefix)/opt/openjdk@17/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-17.jdk 一、检查是否安装成功 在Terminal中运行下面的命令查看Java安装版本，如正常显示Java版本信息则说明安装成功，如果显示command java not find 或者其它则说明没有安装成功
java --version 三、配置环境变量 切到jdk的home文件
cd /Library/Java/JavaVirtualMachines/openjdk-17.jdk/Contents/Home 首次创建配置，可以使用这个命令创建配置文件～
touch .bash_profile 然后使用以下命令打开配置文件
open -e .bash_profile 添加配置内容:注意路径
export JAVA_17_HOME=/Library/Java/JavaVirtualMachines/openjdk-17.jdk/Contents/Home alias jdk17="export JAVA_HOME=$JAVA_17_HOME" export JAVA_HOME export PATH export CLASSPATH 四、完成配置 1.完成配置:source .bash_profile
2.输入echo $JAVA_HOME可以看到环境配置的路径
source .bash_profile #完成配置 echo $JAVA_HOME #检查配置 五、切换jdk jdk17 # 切换jdk java -version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4e6a9388233ee5c7fdb7a2b1db716b/" rel="bookmark">
			sql — 窗口函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基本介绍 1.1 窗口函数介绍 窗口函数是SQL中的一种强大工具，用于在查询结果中进行分析和计算。
与常规聚合函数不同，窗口函数可以在不影响查询结果集的情况下，对结果集中的每一行应用函数，生成额外的信息，例如排名、累计和等。这些函数可以根据定义的窗口范围动态地计算值，而不是像常规聚合函数那样对整个数据集进行计算。
窗口函数通常与OVER子句一起使用，OVER子句定义了窗口的范围，可以指定分区、排序规则等。
1.2 窗口函数分类 窗口函数可以分为排序窗口函数和统计窗口函数两大类。
排序窗口函数主要用于对数据进行排序和排名，包括row_number、rank、dense_rank、percent_rank、ntile；
统计窗口函数则用于进行统计计算，包括count、sum、avg、min、max、first_value、last_value、lag、lead、cume_dist。
2. 样例数据 2.1 样例数据SQL CREATE TABLE Sales ( id INT, region VARCHAR(50), amount DECIMAL(10, 2)); INSERT INTO Sales (id, region, amount) VALUES(1, 'North', 1000.50),(2, 'North', 1500.75),(3, 'South', 800.25),(4, 'West', 1200.00),(5, 'East', 2000.30); 3.各个窗口函数介绍 3.1 row_number（）窗口函数 row_number函数为结果集中的每一行分配一个唯一的整数，按照指定的排序顺序进行排列。
SELECT id, region, amount, ROW_NUMBER() OVER (ORDER BY amount DESC) AS row_numFROM Sales; 3.2 rank （）窗口函数 rank函数为结果集中的每一行分配一个排名，如果有相同数值，则会跳过相同排名并继续递增。（不连续排名）
rank()函数的结果是：1, 2, 3, 3, 5, 6。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4e6a9388233ee5c7fdb7a2b1db716b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcfbe98401aedfb0a7f4d646d47793b/" rel="bookmark">
			ai绘画软件有哪些？九款创新绘画软件赋予青春新表达
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不久便是五四青年节了，青春如歌，岁月如画。
在这个洋溢着热血与梦想的日子里，你是否想亲手绘制一幅属于自己的“五四”主题海报，将那份对青春的敬意与热爱定格在朋友圈？然而，手绘技能欠佳却让你望而却步？
别慌，今天就和大家一同来探索九款各具特色的AI绘画神器，它们不仅能ai绘画女神美图，还能帮你轻松描绘心中的“五四”画卷！
【AI绘图助手】
初入AI绘画世界，你可能会被AI绘图助手的简洁明快所吸引。其界面设计清晰直观，工具栏与工作区布局合理，色彩搭配淡雅而不失专业感。
♦操作过程体验♦
无论是导入图片、选择风格还是调整参数，都能感受到其流畅的响应速度。尤其对于新手而言，其人性化的引导教程与一键免费生成功能大大降低了学习门槛，使你能够快速上手，尽情释放创作灵感。
【ai Picasso】
若你追求的是艺术大师级别的细腻笔触与独特风格，那么ai Picasso无疑是你的理想之选。其界面犹如一座虚拟的艺术工作室，各种风格模板琳琅满目，仿佛能带你穿越时空，与毕加索面对面交流。
♦操作过程体验♦
ai Picasso对细节处理的精准度令人叹服，即使是复杂的纹理与光影也能刻画得淋漓尽致。尽管处理时间稍长，但等待后的惊艳效果绝对值得。
【DreamStudio】
DreamStudio以其梦幻般的名字揭示了其核心魅力——无限创意可能。界面设计富有未来感，色彩斑斓且动态十足，仿佛置身于科幻电影中的数字艺术实验室。该软件不仅提供了丰富的预设风格，更支持深度自定义，让你随心所欲地塑造专属画风。
♦操作过程体验♦
DreamStudio表现出色，无论是加载速度还是实时预览功能，都确保了创作过程的高效与愉悦。
【Instapainting】
Instapainting则以其亲民友好的界面风格和高效的图像处理能力赢得了大家一度的青睐。界面布局清晰有序，色调温馨舒适，让人一见倾心。
♦操作过程体验♦
从上传照片到选择风格，再到最终渲染输出，整个流程行云流水，响应迅速无卡顿。此外，其丰富的社区资源与分享功能，更是为你的“五四”海报增添了互动乐趣。
【getimg.ai】
getimg.ai以其极简主义的设计美学独树一帜。界面干净利落，功能分区明确，给人一种宁静专注的创作氛围。
♦操作过程体验♦
尽管界面简洁，但其AI绘画功能毫不含糊，无论是图像识别的准确性，还是风格转换的速度，都展现出强大的技术实力。对于追求高效、直接创作体验的友友来说，getimg.ai无疑是一个理想的选择。
【Artisto】
Artisto以其移动端的优势，将AI绘画的乐趣带到了指尖。界面设计时尚灵动，符合移动设备的操作习惯，色彩鲜艳，视觉冲击力强。
♦操作过程体验♦
尽管在小屏幕上操作，Artisto仍能保持流畅的响应速度，无论是滤镜切换还是效果微调，都能做到随心所欲。尤其适合在五四青年节当天，随时随地捕捉灵感，即时创作分享。
【Prisma AI】
Prisma AI凭借其独特的艺术滤镜风靡全球。界面设计优雅精致，如同一本翻开的艺术画册，每一种滤镜都是一幅名画的缩影。
♦操作过程体验♦
只需轻点几下，即可将普通照片瞬间转化为艺术大作，响应速度与效果呈现均令人满意。对于希望快速为“五四”海报增添艺术气息的小伙伴来看，Prisma AI无疑是最佳拍档。
【DeepArt.io】
DeepArt.io以深度学习技术为核心，打造出一款专业级的AI绘画平台。界面风格严谨专业，布局逻辑清晰，视觉效果稳重大气。
♦操作过程体验♦
尽管功能强大，但操作流程却被精心设计得简单易懂，无论是参数调整还是风格选择，都能感受到其丝滑的操作手感与迅捷的响应速度。对于追求极致画质与深度定制的友友们来说，DeepArt.io无疑是不二之选。
【Leonardo】
最后，我们来到Leonardo的世界。这款软件以其创新的协作模式与高度可定制化的AI绘画功能备受瞩目。界面设计兼顾实用与美感，模块化布局便于大家自由组合工作空间。
♦操作过程体验♦
无论是单人创作还是团队协作，Leonardo都能提供流畅无阻的体验。其强大的AI算法能在短时间内生成高质量图像，而友好的交互设计则保证了整体使用满意度。
在这个五四青年节，不妨试试这些ai绘画女神美图软件，让你的朋友圈海报与众不同，展现出你独特的艺术魅力。记住，创意无限，真正的艺术，源自你内心的激情和创造力。提前祝你创作愉快，青年节快乐！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ddcb18c401595fac4aea75812f332fc/" rel="bookmark">
			AIGC算法2：LLM的复读机问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是LLM的复读机问题 字符级别重复，指大模型针对一个字或一个词重复不断的生成例如在电商翻译场景上，会出现“steckdose steckdose steckdose steckdose steckdose steckdose steckdose steckdose…”；语句级别重复，大模型针对一句话重复不断的生成例如在多模态大模型图片理解上，生成的结果可能会不断重复图片的部分内容，比如“这是一个杯子，这是一个杯子…”；章节级别重复，多次相同的prompt输出完全相同或十分近似的内容，没有一点创新性的内容，比如你让大模型给你写一篇关于春天的小作文，结果发现大模型的生成结果千篇一律，甚至近乎一摸一样。大模型针对不同的prompt也可能会生成类似的内容，且有效信息很少、信息熵偏低 2. 为什么会出现 LLMs 复读机问题？ 数据偏差
大型语言模型通常是通过预训练阶段使用大规模无标签数据进行训练的。如果训练数据中存在大量的重复文本或者某些特定的句子或短语出现频率较高，模型在生成文本时可能会倾向于复制这些常见的模式。训练目标的限制
大型语言模型的训练通常是基于自监督学习的方法，通过预测下一个词或掩盖词来学习语言模型。这样的训练目标可能使得模型更倾向于生成与输入相似的文本，导致复读机问题的出现。缺乏多样性的训练数据
虽然大型语言模型可以处理大规模的数据，但如果训练数据中缺乏多样性的语言表达和语境，模型可能无法学习到足够的多样性和创造性，导致复读机问题的出现。模型结构和参数设置
大型语言模型的结构和参数设置也可能对复读机问题产生影响。例如，模型的注意力机制和生成策略可能导致模型更倾向于复制输入的文本。从 induction head[1]机制的影响角度
也就是模型会倾向于从前面已经预测的word里面挑选最匹配的词；在翻译上，由于input和output的天然差异性，你会发现容易出现重复的都是一些复杂度perplexity比较高的文本：也就是说input的句式越不常见，本身重复度越高，翻译结果重复的可能性也越高 3. 如何缓解LLMs复读机 3.1. Unlikelihood Training(相似性损失函数) 在训练中加入对重复词的抑制来减少重复输出,token，本身likelihood training loss是要促使模型学习到原标签中自然的语言逻辑，而修改后的loss不仅要促进模型学习到真实标签的语言自然性，也要通过unlikelihood loss抑制模型，使其尽量不生成集合C中的token。
L UL-token t ( p θ ( ⋅ ∣ x &lt; t ) , C t ) = − α ⋅ ∑ c ∈ C t log ⁡ ( 1 − p θ ( c ∣ x &lt; t ) ) ⏟ unlikelihood − log ⁡ p θ ( x t ∣ x &lt; t ) ⏟ likelihood \mathcal{L}_{\text {UL-token }}^t\left(p_\theta\left(\cdot \mid x_{&lt;t}\right), \mathcal{C}^t\right)=-\alpha \cdot \underbrace{\sum_{c \in \mathcal{C}^t} \log \left(1-p_\theta\left(c \mid x_{&lt;t}\right)\right)}_{\text {unlikelihood }}-\underbrace{\log p_\theta\left(x_t \mid x_{&lt;t}\right)}_{\text {likelihood }} LUL-token t​(pθ​(⋅∣x&lt;t​),Ct)=−α⋅unlikelihood c∈Ct∑​log(1−pθ​(c∣x&lt;t​))​​−likelihood logpθ​(xt​∣x&lt;t​)​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ddcb18c401595fac4aea75812f332fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ce5c714e480643ad5b55808b0cb196/" rel="bookmark">
			Spring Kafka——基于 Spring Kafka 实现动态管理 Kafka 连接和 topic 的监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用 Spring Kafka 动态管理 Kafka 连接和主题监听1. 前言2. 简单的消费程序配置3. Spring Kafka 主要的相关类的说明4. `@KafkaListener` 注解的加载执行流程解析5. 动态监听消费订阅的设计与实现 使用 Spring Kafka 动态管理 Kafka 连接和主题监听 文章内容较长，如果想看样例代码直接跳到 动态监听消费订阅的设计与实现
1. 前言 SpringBoot 项目中我们在使用 Spring Kafka 来消费 Kafka 的消息时通常是在 application.properties(或application.yml) 文件中先定义 Kafka 的集群地址(如 spring.kafka.bootstrap-servers) ，随后，我们通过编写一个组件并在一个方法上添加@KafkaListener注解来实现消息消费。
对于需要监听多个Kafka集群的场景，单纯通过配置文件来设定是不足够的。在这种情况下，我们需要为每个集群分别创建连接，并为每一个设定专门的ConcurrentKafkaListenerContainerFactory。以下是一个示例配置，其中包括了为两个不同的Kafka集群创建各自的消费工厂和监听容器的过程：
// 在 Spring Boot 应用中，你需要创建两个配置类来分别配置这两个集群 @Configuration public class KafkaConfig { @Bean public ConsumerFactory&lt;String, String&gt; consumerFactory1() { Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "kafka-cluster1:9092"); props.put(ConsumerConfig.GROUP_ID_CONFIG, "group1"); props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest"); // 添加其他配置项 return new DefaultKafkaConsumerFactory&lt;&gt;(props); } @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory1() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ce5c714e480643ad5b55808b0cb196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0655d39c02669fe73c2bdf98ddc62133/" rel="bookmark">
			Mac电脑Android Studio和VS Code配置Flutter开发环境（图文超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Android Studio 官网地址：
https://developer.android.google.cn/
历史版本下载地址：
https://developer.android.com/studio/archive?hl=zh-cn
二、安装Xcode 到App Store下载安装最新版本，如果MacOS更新不到13.0以上就无法安装最新的Xcode，只能去下载以前版本的Xcode。
历史版本下载地址：
https://developer.apple.com/download/all/?q=Xcode
三、安装VS Code VS Code官网地址：
https://code.visualstudio.com
四、安装Flutter SDK 官网地址：
https://docs.flutter.dev/get-started/install/macos
注意：苹果芯片需要安装rosetta翻译环境
Flutter用于git安装和升级。我们建议安装Xcode，其中包含git，但您也可以单独安装git。
$ sudo softwareupdate --install-rosetta --agree-to-license 1.下载Flutter SDK包 下载解压后，将目录放到/Library/Developer/flutter。
2.打开终端配置环境变量 配置前，先打开 系统偏好设置-&gt;安全性与隐私 进入页面等着。因为从不受信任的源下载的SDK，安装时需要用户手动点同意。
1).执行命令​​​​​​​，配置你的命令行环境 对于Bash用户
具体是什么用户，打开终端后看顶部标题。
$ vim ~/.bash_profile 或者
$ vim ~/.bashrc 对于Zsh用户
$ vim ~/.zshrc 2).输入i （进入可编辑状态） 3).复制下面的配置代码粘入 export PATH=/Library/Developer/flutter/bin:$PATH export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 有时，如上配置后，执行下面flutter doctor时会提示：
Flutter assets will be downloaded from https://storage.flutter-io.cn. Make sure you trust this source!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0655d39c02669fe73c2bdf98ddc62133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e264b2d08660fcbadeb6d06d3abe1f/" rel="bookmark">
			FloodFill算法---DFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
floodfill算法概念：
算法模板套路： 例题1：图像渲染
例题2：岛屿数量
例题3：岛屿的最大面积
例题4：被围绕的区域
floodfill算法概念： floodfill算法是一种常用的图像处理算法，用于填充连通区域。它从指定的种子点开始，将相邻的像素点按照某种条件进行填充，直到所有符合条件的像素点都被填充为止。floodfill算法常用于图像处理中的填充、边界提取、区域分割等任务。它可以用于实现画图工具中的油漆桶工具，也可以用于图像分割中的区域填充。
floodfill算法的中文名为洪水灌溉算法，基本实现内容：从某个点开始向四周扩散，直到无法再扩散为止。（可以使用DFS和BFS，本文讲解DFS解决）从这个实现内容我们不难发现这很适合我们利用爆搜来实现（一般数据范围不会太大）。如下图数字为1的就是一个性质相同的连通块。这类问题通常会问我们1的最大联通块是多大？或者有几个1的连通块？使用floodfill算法解决的题目基本一眼就能看得出来，不想滑动窗口和动态规划之类的算法，你不试一试是看不出来要使用什么算法的😭😭😭。
算法模板套路： 创建所需的全局变量（最好设置为静态，因为非静态只有在leetcode上才行）
static boolean[][] vis;//（ 不一定要有）
static int[ ] dx = {0 , 0 , 1 , -1 };
static int[ ] dy = {1 , -1 , 0 , 0 };
vis这个布尔类型数组来标记我们已经走过的路，防止重复走导致死循环。如果题目可以改给出的二维数组的值的话可以修改值就不用创建这个数组来标记了。
dx，dy数组配合使用，对应就是上下左右走，这是四个方向（上下左右）的，如果题目要求8个方向的话可以在草稿纸上画个图推一下很快的。
其他的一些条件根据题目的具体情况创建。
DFS模板如下：
其中n为行的个数，m为列的个数，至于要不要回溯要根据题目要求什么来决定。如果是8个方向的话把改一下dx和dy还有k的值变为8即可。x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m 这个可以说是默写了，因为这就是防止越界，每道题目都是这么写的。
public static void dfs(int i,int j,.....){ for(int k = 0;k &lt; 4;k++){ int x = i + dx[k]; int y = j + dy[k]; if(x &gt;=0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91e264b2d08660fcbadeb6d06d3abe1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0dd754dd1e752df7185887311b177d3/" rel="bookmark">
			rabbitmq五种消息模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ是一个流行的开源消息代理软件，也称为消息队列（Message Queue）。它支持多种消息模型，以满足不同的业务场景需求。
以下是RabbitMQ的五种主要消息模型：
1. 基本消息模型：
- 生产者将消息发送到队列，消费者从队列中获取消息。
- 队列是存储消息的缓冲区，可以缓存消息。
- 消息确认机制（ACK）确保消息被正确处理，避免丢失。
2. Work（工作队列）消息模型：
- 适用于耗时任务处理，避免长时间等待。
- 多个消费者可以监听同一个队列，任务在消费者之间共享。
- 一个消息只能被一个消费者获取，避免重复处理。
3. Fanout（广播）订阅模型：
- 消息发送到交换机，交换机将消息发送到所有绑定的队列。
- 每个消费者有自己的队列，都能接收到所有消息。
- 适用于需要广播消息的场景。
4. Direct（路由）订阅模型：
- 消息发送到交换机时，会指定一个路由键（RoutingKey）。
- 交换机会根据路由键将消息发送到匹配的队列。
- 适用于需要将不同消息路由到不同队列的场景。
5. Topic（主题）订阅模型：
- 类似于Direct模型，但支持通配符路由键。
- 队列可以使用通配符订阅感兴趣的消息。
- 适用于复杂的消息路由场景，如根据不同的话题或事件类型路由消息。
这些模型通过交换机（Exchange）和队列（Queue）的不同组合与绑定方式来实现。交换机负责接收消息并根据消息的路由键将消息路由到一个或多个队列。队列则负责存储消息，直到消费者准备好接收它们。
消息持久化是RabbitMQ中的另一个重要特性，它确保消息、队列和交换机在服务器重启后依然存在。通过设置相应的持久化属性，可以防止消息在系统故障时丢失。
了解这些模型有助于开发者根据具体的应用场景选择合适的消息传递方式，以提高系统的效率、可靠性和可扩展性。
作者：鱼哥很忙
链接：https://www.yyytang.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57818bcd8b1184272b7d4a21cbfd1105/" rel="bookmark">
			启动pip或ipython提示Fatal error in launcher: Unable to create process的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误以及原因分析 有时，运行python的pip或ipython组件会报错：
Fatal error in launcher: Unable to create process using '"C:\third_party\Python\3.9\win64-msvc-14.2\python.exe"
错误信息最后这一串路径在我们的电脑上很可能并不存在！然而，启动pip或ipython时又会尝试运行这个路径的python.exe，所以直接报错。
方法一：强制更新软件 运行下面的命令强制更新启动时报错的软件：
python -m pip install --upgrade pip python -m pip install --upgrade ipython 一般都可完美解决。
方法二 用VSCode或UltraEdit的16进制模式打开pip.exe或ipython.exe，搜索路径“C:\third_party\Python\3.9\win64-msvc-14.2\python.exe”（替换成自己报错信息中的路径），并修改为真正的python.exe所在路径、然后保存运行。
将查找到的错误路径修改为自己电脑上的正确python路径，并保存，如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8cf1181d05460b10fae613c9f63f498/" rel="bookmark">
			Java判断一个字符串是否包含某个字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hi，我是程序员王也，一个资深Java开发工程师，平时十分热衷于技术副业变现和各种搞钱项目的程序员~，如果你也是，可以一起交流交流。
今天我们来聊聊Java中字符串包含字串问题~
1. 引言 1.1 字符串操作的重要性 在Java编程中，字符串操作是日常开发中非常频繁的活动之一。字符串是文本数据的基本单位，它们可以包含字母、数字、符号和空格等字符。对字符串进行操作，如判断、查找、替换、拆分等，是编程中常见的任务。在很多应用场景中，如文本处理、数据验证、用户输入处理等，都需要用到字符串操作。
1.2 文章目的与适用读者 本文的目的是介绍如何在Java中判断一个字符串是否包含某个字符。这对于那些需要在字符串中查找特定字符的开发者来说非常有用。文章将提供不同的方法来实现这一功能，并给出相应的示例代码。
适用读者包括：
Java初学者，希望了解字符串操作的基础知识。有经验的Java开发者，想要回顾或学习新的字符串操作方法。需要在项目中实现字符串查找功能的任何Java开发者。 示例代码 以下是一些基础的Java代码示例，展示如何判断一个字符串是否包含某个字符。
使用contains(CharSequence s)方法 String类提供了contains(CharSequence s)方法，用于判断字符串是否包含指定的字符序列。
public class StringContainExample { public static void main(String[] args) { String text = "Hello, World!"; char ch = 'W'; boolean containsChar = text.contains(String.valueOf(ch)); // 将char转换为String System.out.println("字符串中是否包含字符 '" + ch + "': " + containsChar); } } 在这个例子中，我们首先定义了一个字符串text，然后定义了一个字符ch，接着使用contains方法来判断text是否包含ch。注意，contains方法接受一个CharSequence作为参数，所以我们需要将char转换为String。
使用字符数组 另一种方法是将字符串转换为字符数组，然后遍历数组来查找特定字符。
public class CharArrayExample { public static void main(String[] args) { String text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8cf1181d05460b10fae613c9f63f498/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff3f1d7760234627988edd4d2725ea8/" rel="bookmark">
			Ai绘画工具Stable Diffusion，最全提示词使用指南！建议收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享的是Stable Diffusion提示词相关内容。
文章目录 一、基本概述二、提示词顺序三、提示词权重四、连接词五、分步渲染六、调用Lora七、提示词资源八、常用提示词中英文对照表写在最后 一、基本概述 1、提示词通常是在文生图和图生图的时候会使用到，就是这里的两个功能。
2、提示词由多个描述性词汇组成，由逗号隔开，结尾不需要加分隔符（注：一般都是英文词汇和英文逗号）
例如：1girl,long hair,white hair
表示我们想生成一个长发且头发是白色的女孩。
3、提示词分为正向提示词（positive prompt）和反向提示词（negative prompt），用来告诉AI我们想要生成什么和不想生成什么。
上面第2点的例句可理解为正向提示词；
反向提示词通常是一些比较负面的描述性内容，
例如：low quality, worst quality, nsfw
表示我们不想生成质量差的，也不想生成限制级的内容
注：针对反向提示词，我们可以下载一些整合好的嵌入式(embeddings)文件，将他们放在/embedding目录下面，需要的时候直接选取即可。
例如：EasyNegative就是一个整合了大量负面提示词的embedding文件,我们将它加入到负面提示词中就可以省略很多负面提示词的输入了。
4、每个词汇的权重默认都是1，从左到右依次减弱，权重会影响画面生成的结果。
例如：1girl,forest
人物的权重会比森林的权重高，生成的人物会占画面的大部分位置，当我们颠倒它们的顺序：forest,1girl
人物在画面中的权重就会降低，相应的人物占画面的比例就会减少。
因此选择正确的顺序、语法来使用提示词，将更好、更快、更有效率地展现所想看到的画面。
5、Stable Diffusion会依照概率来选择性执行，如提示词之间有冲突，AI 会根据权重确定的概率来随机选择执行哪个提示词。
6、生成图片的大小会影响 Prompt 的效果，图片越大需要的 Prompt 越多，不然 Prompt 会相互污染。
7、Prompt 支持使用 emoji表情包，且表现力比词汇更好，可通过添加 emoji 图来达到效果。
二、提示词顺序 我们知道越排在前面的词汇权重越高，那么基于这个特征我们在写提示词时建议按如下顺序进行书写。
综述（图像质量+风格+镜头效果+光照效果+主题）
主体（人物&amp;对象+动作+服装+饰品+道具）
细节（场景+环境）
1、质量提示词
通常是整个画面的清晰度，分辨率，质量等等关键词汇组成。
例如：masterpiece,best quality,8k,Ultra-high resolution
2、风格提示词
如有则建议放在质量提示词后面，例如某个画家或某些影视作品的风格
例如：ghibli style
3、镜头效果
通常用来体现主体在画面中的位置，例如长镜头(long shot)，短镜头(short shot)，全景镜头(panoramic)等，镜头通常最后只选择其中一种即可。
4、光照效果
通常是环境的灯光效果，例如电影级照明(cinematic lighting), 丁达尔效应(tyndall effect), 体积光(volumetric lighting)等等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff3f1d7760234627988edd4d2725ea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea472ff08ee99681cc63fede7202206a/" rel="bookmark">
			C#连接Mysql数据库详细教程（内附Mysql及Navicat)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课上教学使用的是SqlServer数据库，由于SqlServer数据库配置难以理解，故学习使用Mysql代替数据库连接。(Mysql以及Navicat安装说明在压缩包内）
Mysql连接首先需要用到Mysql.Data.dll连接文件，也就是Mysql Connector Net这一文件，下载后安装会自动在C:\Program Files (x86)\MySQL\MySQL Connector Net 6.9.0这个路径（貌似...）
之后就需要在VS的引用中引用这一文件，然后就可以进行数据库的连接操作了。
首先新建项目，选择Windows窗体应用程序创建一个窗体
将窗体加上组件设置为下图所示样式（可以自由发挥，只要包含相关输入即可）
创建connect.cs的类文件（这里是我为后续创建信息系统方便设置的集成类，可以通过调用该类少写些代码）
其中需要在开头加入using MySql.Data.MySqlClient;
并在类中定义好三个对象
public MySqlConnection conn = null;//连接对象
public MySqlCommand comm = null;//语句执行对象
public MySqlDataReader dr = null;//语句执行结果数据对象
再使用load()方法封装连接过程，这里就需要自行输入数据库的相关信息
using System; using System.Collections.Generic; using System.Linq; using System.Text; using MySql.Data.MySqlClient; namespace DataBaseManager { class connect { public MySqlConnection conn = null;//连接对象 public MySqlCommand comm = null;//语句执行对象 public MySqlDataReader dr = null;//语句执行结果数据对象 //用于一个窗口让用户自定义输入用户名与密码，在这里我直接定义好了 //public string uid; //public string pwd; public void load() { //直接写链接语句，比较容易出错 //conn = new MySqlConnection( // "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea472ff08ee99681cc63fede7202206a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d797fa2d281e9e31e6b2510d309ebfb1/" rel="bookmark">
			人工智能|深度学习——多模态条件机制 Cross Attention 原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引入 虽然之前写过 Attention 的文章，但现在回头看之前写的一些文章，感觉都好啰嗦，正好下一篇要写的 Stable Diffusion 中有 cross-attention，索性就再单拎出来简单说一下 Attention 吧，那么这篇文章的作用有两个：第一是为 Stable Diffusion 做补充，第二是为后续的 Vision Transformer 和 Swin Transformer 做铺垫。
为了保证篇幅开头的完整性，还得啰嗦一下 Transformer，它最开始提出是针对nlp领域的，在此之前除了seq2seq这种encoder-decoder架构，大家主要还是用的rnn、lstm这种时序网络，像rnn系列网络它是有问题的，首先就是它记忆的长度是有限的，其次是无法并行化计算，也就是必须要先计算xt时刻的数据才能计算时刻xt+1，这就导致效率低下。针对这些问题，Google就提出了 Transformer，在 Transformer 中有两个非常重要的模块：Self Attention 和 Multi-Head Attention，本文会先介绍 Attention 的基本思想，然后再对 Self Attention 和 Multi-Head Attention 进行概述，最后再讲本文的主题 Cross Attention，其实 Cross Attention 非常简单，不要被它的名字吓到，一定要理解透彻前面的 Multi-Head Attention。
二、Attention 思想 注意力机制的核心目标是从众多信息中选择出对当前任务目标更关键的信息，将注意力放在上面。其本质思想就是【从大量信息中】【有选择的筛选出】【少量重要信息】并将注意力【聚焦到这些重要信息上】，【忽略大多不重要的信息】。聚焦的过程体现在【权重系数】的计算上，权重越大越聚焦于其对应的value值上。即权重代表了信息的重要性，而value是其对应的信息。
Q是Query，是输入的信息，即当前任务的目标，用于和key进行匹配；
K和V分别是Key和Value，一般是相同的数据，比如原始文本经过Embedding后的表征；
通过计算Q与K之间的相关性，得到权重a，再将权重a进行类似于softmax的归一化操作，表示不同的key对于Q的重要程度，或者说权重a越大，我们就会把更多的注意力放到其对应的value上；
用权重a再与对应的Value相乘，意思是我们从Value中提取到的重要信息，或者说是对Q有用的信息；
加权后的结果再求和就得到了针对Query的Attention输出，用新的输出代替原来的Q参与之后的一系列运算。
我们以机器翻译为例进一步加深理解，假设有文本“汤姆追逐杰瑞”，方便起见我们规定词库单词就为tom、chase、jerry，当我们对“汤姆”进行翻译的时候，套用上述 Attention 机制：
三、Self Attention 我们可以观察上面的传统 Attention 机制，我们可以发现每个词只表示自身的含义，不包含上下文的语义信息。而 Self Attention 则顾名思义，它指的是关注输入序列元素之间的关系，也就是说每个元素都有自己的Q、K、V，经过 Self Attention 对词向量进行重构后，使得词向量即包含自己的信息，又综合考虑了上下文的语义信息，如下图所示：
四、Multi-Head Attention 在理解了 Self Attention 之后，Multi-Head Attention 就很容易了，它相当于 h 个不同的 Self Attention 的集成，说白了就是对其的堆叠。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d797fa2d281e9e31e6b2510d309ebfb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae837b6b0b0282e88e177c4bc439291a/" rel="bookmark">
			2024Mac系统热门游戏排行榜 Mac支持的网络游戏有哪些？mac能玩哪些大型网游 苹果电脑Mac游戏资源推荐 Mac玩Windows游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“游戏是这个世界上唯一能和女性争夺男朋友的东西（/滑稽，有不少女生也喜欢玩游戏）。”
虽然只是一句玩笑话，不过也可以看出游戏对大多数男生来说是必不可少的一项娱乐活动了。而网络游戏是游戏中的一大分支，能让玩家们在网络游戏中体验到合作共赢的快感。
图 1：游戏比赛现场照片
Mac系统与Windows系统有诸多不同，包括支持软件、下载方式等方面。我们都知道如果不使用Mac虚拟机，那么苹果电脑有很多软件不能使用。那么Mac的用户能玩些什么网络游戏呢？我们能在Windows系统中体验到的各种网络游戏，在Mac中能不能体验呢？
首先给大家介绍一下Mac支持的热门网络游戏：
①使命召唤系列：
使命召唤系列游戏相信很多人即使没有亲手体验过，也会有一定程度的了解。其中各种人物、战争场面以及枪械，都符合男生们的热血情怀。因此，使命召唤系列要在热门网络游戏中占据一席之地。
图 2：使命召唤
②星际争霸：
星际争霸在当年也是火爆了一时，它和现在仍在大火的魔兽争霸游戏类型相似。作为较早的一批即时战略游戏，星际争霸赚够了人们的注意力。而其中复杂的游戏模式与巨大的专研空间也让诸多玩家爱不释手。
图 3：星际争霸
③极品飞车：
极品飞车中各种华丽的场景和科技感十足的赛车也让人心动，作为赛车类游戏的佼佼者，它的追随者自然是不少。
图 4：极品飞车
④漫漫长夜
漫漫长夜是一款生存游戏，与大多数同类游戏不同，并没有采用僵尸世界为背景题材，游戏以地磁灾难之后为背景，玩家要面对的则是严寒与大自然中所有的残酷环境，以及最大的敌人“孤独”。题材上相对来说有所创新，可以让一部分厌倦以僵尸世界为背景的生存类游戏爱好者再次燃起游玩激情。在游戏中玩家将拥有饥渴度、疲劳度、体温三项基础数值，由于每一个行动都会消耗卡路里从而降低体温，所以每一个决策都是至关重要的。
图 5：漫漫长夜
⑤GRIS
GRIS是一款只要玩过的玩家都会说很美的游戏，美到把灰色的世界都染上了心灵的色彩，或许它没有太多的游戏性，但是有时游戏性是可以为艺术让路的。GRIS的画面由明亮的水彩风格绘制，从第一眼开始就足够夺目。GRIS不仅是游戏中主角的名字，在法语和西班牙语中也意为灰色。游戏由数个短小的章节组成，每个章节都有着独特的场景设定以及一个独特的“主色调”。GRIS是一出毫无保留的美术秀，令人应接不暇的美景接连出现，且毫无重样。
⑥ Neversong
这是一款冒险游戏，在游戏中，玩家将扮演一个名叫Peet(皮特)的男孩，体验他的女友列恩被绑架并陷入昏迷。在沉睡中醒来后，他听说他的女朋友列恩仍然不见了，周围的成年人都不见了，或者行为怪异。于是皮特决定自己解决这个难题，并保存自己的女朋友。虽然游戏的操作相当直观，但在游戏开始后，不会有系统的教学指导，玩家必须不断探索甚至体验相同的人员、时间和地点，直到玩家解开线索，故事才会继续。
大家看到这里一定发现了，我们平时在Windows电脑中玩的英雄联盟、地下城等游戏不在上述之列。这时因为Mac系统中不支持这些专门面向Windows的网络游戏。那如果我们想要在Mac系统上玩这些游戏该怎么办呢？
其实当我们想要在苹果电脑上体验网络游戏时，可以首先考虑CrossOver，CrossOver是一款可以让你在Mac和Linux系统上运行Windows应用的软件，它不需要安装Windows系统或者虚拟机，也不需要购买Windows许可证，只需要下载和安装CrossOver，就可以直接从Mac的dock启动Windows应用，就像运行Mac应用一样。
CrossOver可以运行各种Windows应用，从办公软件、实用工具、游戏到设计软件，都可以在Mac上享受Windows的功能和性能。不需要安装Windows系统或者虚拟机，节省了时间和空间，提高了效率和性能。如果你是一个格斗游戏的爱好者，那么你一定不要错过这些游戏，也不要错过CrossOver这款软件。
在CrossOver软件中，搜索游戏，点击安装，CrossOver会自动下载并安装游戏客户端，以及所需的Windows组件和库文件，无需额外的配置和操作。
CrossOver24（Mac版）中文免费安装包：https://souurl.cn/mWK48N
CrossOver中文官网更多游戏推荐：https://souurl.cn/xneFDq
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e440d8eae8cc795add2c75bd037c0c21/" rel="bookmark">
			大模型LLM在Text2SQL（文本转SQL）上的应用实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Text2SQL概述 Text-to-SQL（或者Text2SQL），顾名思义就是把文本转化为SQL语言，更学术一点的定义是：把数据库领域下的自然语言（Natural Language，NL）问题，转化为在关系型数据库中可以执行的结构化查询语言（Structured Query Language，SQL），因此Text-to-SQL也可以被简写为NL2SQL。· 输入：自然语言问题，比如“查询表t_user的相关信息，结果按id降序排序，只保留前10个数据 ”· 输出：SQL，比如“SELECT * FROM t_user ORDER BY id DESC LIMIT 10”
Text2SQL应用主要是帮助用户减少开发时间，降低开发成本。“打破人与结构化数据之间的壁垒”，即普通用户可以通过自然语言描述完成复杂数据库的查询工作，得到想要的结果。
添加图片注释，不超过 140 字（可选）
二、LLM 应用架构 LangChian 作为一个大语言模型开发框架，是 LLM 应用架构的重要一环。那什么是 LLM 应用架构呢？其实就是指基于语言模型的应用程序设计和开发的架构。
LangChian 可以将 LLM 模型、向量数据库、交互层 Prompt、外部知识、外部工具整合到一起，进而可以自由构建 LLM 应用。
添加图片注释，不超过 140 字（可选）
基于LLM的应用开发基本架构如上图，本文介绍以LangChain + LLM + RDB的方式来实现Text2SQL的实践方案。
三、LangChain 组件 添加图片注释，不超过 140 字（可选）
如上图，LangChain 包含六部分组成，分别为：Models、Prompts、Indexes、Memory、Chains、Agents。
四、Text2SQL实战应用 我们可以用来构建问答系统的一种最常见类型的数据库是SQL数据库。LangChain提供了许多内置的链和代理，它们与SQLAlchemy支持的任何SQL方言兼容（例如，MySQL、PostgreSQL、Oracle SQL、Databricks、SQLite）。它们支持以下用例：●根据自然语言问题生成要运行的查询；●创建能够根据数据库数据回答问题的聊天机器人;●基于用户想要分析的洞察构建自定义仪表板;●......
架构 在高层次上，任何SQL链和代理的步骤包括：
1、 将问题转换为SQL查询：模型将用户输入转换为SQL查询。2、 执行SQL查询：执行SQL查询。3、 回答问题：模型使用查询结果回应用户输入。
添加图片注释，不超过 140 字（可选）
环境部署 安装LangChain组件
pip install --upgrade --quiet langchain langchain-community langchain-openai 安装数据库环境下面的例子将使用SQLite连接与Chinook数据库。请按照以下安装步骤在同一目录下创建Chinook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e440d8eae8cc795add2c75bd037c0c21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38c9e4c14abfa671c375c2bd99d2ffc/" rel="bookmark">
			基于Hadoop的大数据个性化商城推荐系统：使用协同过滤算法实现的推荐原理及实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于hadoop的商城推荐系统 大数据个性化商城推荐 协同过滤推荐
推荐原理：每天定时更新数据集，数据集为当然商城中用户的订单信息，将数据集保存在hadoop的hdfs文件系统中，并触发计算，根据余弦相似度计算用户间的相似度，再根据相似度矩阵与评分矩阵进行预测评分的计算，并将计算结果保存，由服务器读取缓存用于推荐
浏览页面也是这个网址，区别在于推荐算法是由hadoop执行MapReduce来实现
用户端浏览网址：
http: 124.221.225.110:8080 tmall 管理员登录页面：http: 124.221.225.110:8080 tmall admin
测试账户
管理员：1209577113 xq
ID:91600673127436645
苹果大大个 基于Hadoop的商城推荐系统
引言：
在当今互联网时代，商城推荐系统已经成为电商领域中的重要组成部分。个性化推荐系统的目的是根据用户的兴趣、行为等信息，向用户提供个性化的商品推荐，以提高用户的购物体验和商城的销售量。本文将介绍基于Hadoop的大数据个性化商城推荐系统，主要通过协同过滤推荐算法实现。推荐系统的实现过程包括数据集的更新、相似度计算、评分预测和结果保存等步骤。同时，为了实现高效的推荐服务，本系统还利用Hadoop的MapReduce框架进行推荐算法的并行计算。
数据集更新
为了保证推荐系统的准确性和时效性，每天需要定时更新数据集。数据集包括商城中用户的订单信息，这些信息可以反映用户的购买行为和偏好。将数据集保存在Hadoop的HDFS文件系统中，可以有效地管理和存储大规模的数据。数据集的更新可以通过定时任务或者事件触发器来实现。
相似度计算
推荐系统中的相似度计算是推荐算法的核心。在本系统中，使用余弦相似度计算用户之间的相似度。余弦相似度是一种常用的相似度度量方法，可以衡量两个向量之间的相似程度。基于已有的订单信息，可以构建用户-商品评分矩阵，然后根据用户之间的评分向量计算相似度。
评分预测
在得到用户之间的相似度矩阵后，可以利用该矩阵对用户的购买行为进行预测评分。预测评分可以基于用户-商品评分矩阵和相似度矩阵来计算。通过对用户的历史购买记录和与其他用户的相似度进行加权计算，可以预测用户对未购买商品的兴趣程度，并为用户生成推荐列表。
结果保存与推荐服务
计算得到的推荐结果需要保存，并由服务器读取缓存以供推荐服务使用。将计算结果保存在Hadoop的HDFS文件系统中，可以方便地进行数据的存储和读取。通过建立推荐服务接口，用户可以根据自己的需求获取个性化的推荐列表，提高购物体验和商城的销售量。
Hadoop的MapReduce并行计算
为了实现高效的推荐服务和处理大规模数据集，本系统利用Hadoop的MapReduce框架进行推荐算法的并行计算。MapReduce框架通过分布式计算和数据并行技术，能够高效地处理大规模数据和复杂的计算任务。通过将推荐算法分解成多个独立的任务，并在集群中的多台计算节点上并行执行，可以大大提高计算速度和系统的可扩展性。
总结：
基于Hadoop的商城推荐系统采用协同过滤推荐算法，通过数据集的更新、相似度计算、评分预测和结果保存等步骤实现个性化的商品推荐。通过利用Hadoop的分布式计算和数据并行技术，可以提高推荐算法的计算效率和系统的可扩展性。该系统能够为用户提供准确、实时的个性化推荐服务，提高用户的购物体验和商城的销售量。
参考关键词：Hadoop、商城推荐系统、大数据、个性化推荐、协同过滤、相似度计算、评分预测、MapReduce、分布式计算、数据并行技术。
以上相关代码,程序地址：http://matup.cn/673127436645.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/396/">«</a>
	<span class="pagination__item pagination__item--current">397/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/398/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>