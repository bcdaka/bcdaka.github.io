<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4407673eb482f5e922c05b0c52360ea/" rel="bookmark">
			免费实用的 Redis 可视化工具推荐, Redis DeskTop Manager 及 Another Redis Desktop Manager 的安装与使用，Redis Insight 下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：Redis 是每一个开发者基本必用的工具，了解 Redis 及下载、安装、配置的朋友可以前往我写的Redis篇 https://blog.csdn.net/boboJon/article/details/135068657 进行交流。
一、Redis DeskTop Manager 桌面端 Redis 可视化工具
二、Another Redis Desktop Manager github 桌面端 Redis 可视化工具 三、 Redis Insight WEB版 Redis 可视化工具
前言：Redis 是每一个开发者基本必用的工具，了解 Redis 及下载、安装、配置的朋友可以前往我写的Redis篇 https://blog.csdn.net/boboJon/article/details/135068657 进行交流。 以下就为大家介绍几款不错的 Redis 可视化工具，本人平时常用：Redis DeskTop Manager 和 Another Redis Desktop Manager github 两款都非常不错。
一、Redis DeskTop Manager 桌面端 Redis 可视化工具 Redis DeskTop Manager 工具应该是现在使用率最广的可视化工具了，也不用多说什么了。运营时间很久。经过了数次迭代。跨平台支持。现在虽然收费了。但是也不贵，一年才百来块，而且旧版本是免费的，界面看着比较简洁，功能很全。除了基本的五大数据类型之外，还支持Stream数据类型，在value的显示方面。基本支持所有数据类型的显示。
二、Another Redis Desktop Manager github 桌面端 Redis 可视化工具 Another Redis Desktop Manager github 怎么说明，只能用小巧玲珑来说了，页面非常简洁美观，基本的功能都有，支持多平台、监控统计、页面主题、集群、搜索，分组显示，多选操作。整体感觉比较不错。 最主要的是简洁免费，有想法的可以动身了， 这软件是国内一个大佬嫌弃各种可视化工具都不顺手，所以自己开发的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4407673eb482f5e922c05b0c52360ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12cc38318471516cc93b88fdbfd1167c/" rel="bookmark">
			智能手机操作系统全面解析：Android、iOS和HarmonyOS的特色及未来趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导言 智能手机操作系统是移动设备的核心，不同的操作系统影响着用户体验、应用生态和系统性能。本文将深入探讨Android、iOS和HarmonyOS三大主流手机操作系统，剖析它们各自的特色，并展望未来的发展趋势。
1. Android操作系统 1.1 开放性与自由度 开放源代码： Android是一款开放源代码的操作系统，允许制造商对系统进行自定义和修改。丰富的应用生态： Google Play Store上有数百万款应用，为用户提供了广泛的选择。 1.2 定制与多样性 制造商定制： Android允许手机制造商对界面和功能进行定制，导致各式各样的用户界面和功能差异。硬件多样性： 适应了多样化的硬件设备，从低端到高端手机都有广泛支持。 1.3 应用场景 大众市场： Android在全球范围内占据大多数市场份额，主要用于中低端到高端手机。 1.4 未来发展趋势 5G整合： Android将与5G技术深度整合，提供更快的网络连接和更强大的应用性能。 2. iOS操作系统 2.1 封闭性与安全性 封闭生态系统： iOS是一个封闭系统，由Apple严格控制硬件和软件的整合，确保更高的安全性。应用审核： 所有iOS应用都需通过Apple的审核，确保应用的质量和安全性。 2.2 精致设计与性能 用户体验： iOS以其流畅的用户体验和统一的界面设计而著称，适用于高端市场。性能卓越： 与硬件的紧密结合使得iOS设备在性能方面表现卓越。 2.3 应用场景 高端市场： iOS主要用于Apple旗下的高端设备，如iPhone、iPad等。 2.4 未来发展趋势 生态系统拓展： Apple将继续扩展其生态系统，使得iOS设备在家庭、健康和娱乐方面更为普及。 3. HarmonyOS操作系统 3.1 跨平台与分布式技术 鸿蒙内核： HarmonyOS采用鸿蒙内核，支持多种设备形态，包括手机、平板、智能家居等。分布式技术： 具备分布式技术，使得多设备之间更为灵活的互联互通。 3.2 华为生态整合 生态一体化： HarmonyOS与华为生态深度整合，实现了设备之间的无缝连接。应用迁移： 华为鼓励开发者将Android应用轻松迁移到HarmonyOS上。 3.3 应用场景 全场景智能： HarmonyOS旨在打造全场景智能体验，涵盖智能家居、汽车、穿戴设备等。 3.4 未来发展趋势 国际市场扩张： 华为计划在未来将HarmonyOS拓展至更多国际市场，加强其全球竞争力。 4. 不同操作系统的应用领域 Android： 主要应用于大众市场，适用于中低端到高端手机。iOS： 主要应用于高端市场，如iPhone、iPad等。HarmonyOS： 面向全场景智能，包括手机、平板、智能家居等。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12cc38318471516cc93b88fdbfd1167c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e047fc1023a1c02f51ea1ab35de6afdc/" rel="bookmark">
			从 0 开始实现一个 SpringBoot &#43; Vue 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 0 开始实现一个 SpringBoot + Vue 项目 从 0 开始实现一个 SpringBoot + Vue 项目软件和工具创建 SpringBoot 后端项目创建 MySQL 数据库配置文件实现增删改查接口Model 层mapper 层service 层controller 层测试 实现项目功能接口代码测试 创建 Vue 前端安装 Node.js配置 npm 镜像安装脚手架创建并配置项目项目结构Vue 组件结构Vue 组件调用与传值Vue 组件的生命周期测试 Vue 程序需求分析 实现项目页面框架搭建项目配置主界面设计设置路由内容组件设计发送组件设计分页面设计排行页面 LikesSortedView.vue最新页面 NewestView.vue随机页面 RandomView.vue 项目启动 源码下载 从 0 开始实现一个 SpringBoot + Vue 项目 参考：梦想屋A
软件和工具 后端开发软件：IntelliJ IDEA前端开发软件：Visual Studio Code后端框架：SpringBoot后端语言：Java前端框架：Vue 这是后面要用的妙妙小工具：
服务器连接工具：Termius数据库：MySQL数据库管理工具：Navicat Premium数据库连接工具：MyBatisAPI 文档生成工具：SwaggerAPI 文档美化工具：Knife4jUI 组件库：Element网络请求库：Axios字体处理库：SfntlyJSON 处理工具：FastjsonJava 工具库：Lombok 可以不必全部用这些来做，有很多类似的产品可以替代。
创建 SpringBoot 后端项目 首先我们打开 IDEA，点击新建项目，选择 Spring Initializr，然后在右侧填写项目名称，类型选择 Maven，JDK 版本选择1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e047fc1023a1c02f51ea1ab35de6afdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64da62ecf2554c0e70afe1a13a770919/" rel="bookmark">
			用python编写用户登录界面,python编写登录窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编来为大家解答以下问题，用python编写一个登录界面，用python编写用户登录界面，今天让我们一起来看看吧！
生活中我们会进入各种登录界面，那大家想制作一个属于自己的登录界面吗？如何使用Python制作简单的登录界面，下面是详细的制作流程。 一个简单地登录界面通常由以下要素组成 1）用户账号输入框 2）用户密码输入框 3）登录按钮 from tkinter import * root = Tk() root.title('入门案例') root.geometry("800x400") Button(text='按钮').place(x=100, y=0) root.mainloop() 程序运行结果如下： 1.初始页面 2.输入账号和密码 点击'登录' 3.密码输错是 4.设计程序如下 from tkinter import * from tkinter.messagebox import * # 设置主界面的容器大小和位置 root = Tk() root.title('登录页面') root.geometry("800x400+100+150") #声明组件变量 log_name = StringVar() log_pwd = StringVar() #组件的使用 def btn_login(): if log_name.get() == 'admin' and log_pwd.get() == '123': showinfo('提示信息','登录成功~') else: showwarning('提示信息','用户名或密码输入有误~') #组件的使用 Label(root,text='账号:',font=('幼圆',20)).place(x=200,y=80) Entry(width=27,font=('幼圆',20),textvariable=log_name).place(x=280,y=88) Label(root,text='密码:',font=('幼圆',20)).place(x=200,y=150) Entry(width=27,font=('幼圆',20),show='*',textvariable=log_pwd).place(x=280,y=150) Button(text='登录', background='white', # 背景色 foreground='black',width=15, # 前景色 font=('幼圆',20), #字体 大小 command=btn_login).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64da62ecf2554c0e70afe1a13a770919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22a749520539d3c0136b58368654d38/" rel="bookmark">
			【JAVA】getter与setter方法的定义与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、如何添加getter setter方法
二、getter方法
1.getter方法的定义
2.getter方法的格式
三、setter方法
1.setter方法的定义
2.setter方法的格式
四、getter与setter中代码处理
五、getter与setter的使用
六、setter和getter的作用
七、异常处理
前言
setter和getter是面向对象程序设计中的术语，用于实现封装性和安全性。它们分别代表设置器和获取器。
setter和getter的主要目的是使应用中的数据（属性）不能被直接访问。这样可以防止不安全的改变数据的情况发生，并且可以提供更严格的对数据的控制。setter和getter方法也有助于维护代码的可读性和可维护性，因为可以在方法内部实现对属性值的验证和处理逻辑
一、如何添加getter setter方法 在大多数面向对象编程语言中，添加getter和setter方法通常很简单，只需遵循以下步骤：
在类中定义一个私有属性。
创建一个公共的 setter 方法，以接受一个参数并将其分配给私有属性。
创建一个公共的 getter 方法，以返回私有属性的值。
以下是一个基本的示例，说明如何添加getter和setter方法：
public class Person { private String name; // 私有属性 // setter方法 public void setName(String newName) { this.name = newName; } // getter方法 public String getName() { return this.name; } } 在此示例中，我们为Person类添加了一个私有属性“name”，然后在类中定义了一个公共setter方法和一个公共getter方法，以允许外部代码设置和获取“name”属性的值。然后，我们可以通过以下方式使用它：
Person person = new Person(); person.setName("John"); // 设置name属性的值 System.out.println(person.getName()); // 输出John，获取name属性的值 在生产环境中，如果需要对setter和getter方法进行额外的处理，可以使用注解或AOP（面向切面编程）来实现对这些方法的切面处理 二、getter方法 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22a749520539d3c0136b58368654d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc065025da839b7e16fabc6791bbd7d8/" rel="bookmark">
			如何利用Python进行文本数据分析：深入解析与实例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多资料获取 📚 个人网站：ipengtao.com
文本数据分析在当今信息时代具有重要地位，而Python作为一门强大的编程语言，提供了丰富的工具和库来处理和分析文本数据。本文将深入研究如何使用Python进行文本数据分析，提供详细全面的内容和丰富的示例代码。
读取文本数据 使用Python内置的open()函数或第三方库如pandas读取文本文件：
# 使用open()函数读取文本文件 with open('text_data.txt', 'r') as file: text_content = file.read() # 使用pandas读取文本文件 import pandas as pd df = pd.read_csv('text_data.csv', delimiter='\t') 文本预处理 清理文本数据是文本分析的第一步，包括去除停用词、标点符号，转换为小写等：
import re from nltk.corpus import stopwords def preprocess_text(text): text = text.lower() text = re.sub(r'\W', ' ', text) text = re.sub(r'\s+', ' ', text) stop_words = set(stopwords.words('english')) tokens = [word for word in text.split() if word not in stop_words] return ' '.join(tokens) preprocessed_text = preprocess_text(text_content) 词频统计 使用nltk或Counter库进行词频统计：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc065025da839b7e16fabc6791bbd7d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806bcbd4f1a60cfb3471e8d43e726240/" rel="bookmark">
			【python】动态可视化&#43;爬虫（超燃超简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、可视化库pynimate二、爬取数据三、动态可视化 一、可视化库pynimate 这里推荐个动态可视化库pynimate，2023年还在持续更新中。调用他们动态可视化方法，实现起来不要太简单。
pynimate官方地址
首先看下他们官方例子
注意需要python版本&gt;=3.9
import pandas as pd from matplotlib import pyplot as plt import pynimate as nim df = pd.DataFrame( { "time": ["1960-01-01", "1961-01-01", "1962-01-01"], "Afghanistan": [1, 2, 3], "Angola": [2, 3, 4], "Albania": [1, 2, 5], "USA": [5, 3, 4], "Argentina": [1, 4, 5], } ).set_index("time") cnv = nim.Canvas() bar = nim.Barhplot.from_df(df, "%Y-%m-%d", "2d") bar.set_time(callback=lambda i, datafier: datafier.data.index[i].year) cnv.add_plot(bar) cnv.animate() plt.show() 二、爬取数据 会了可视化，但是没有数据怎么办？去网上爬取点数据过来。
网址链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/806bcbd4f1a60cfb3471e8d43e726240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81b7005d69682ba8a06a96d7f330a87/" rel="bookmark">
			【Spring教程31】SSM框架整合实战：从零开始学习SSM整合配置，如何编写Mybatis SpringMVC JDBC Spring配置类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 流程分析2 整合配置2.1 步骤1：创建Maven的web项目2.2 步骤2:添加依赖2.3 步骤3:创建项目包结构2.4 步骤4:创建SpringConfig配置类2.5 步骤5:创建JdbcConfig配置类2.6 步骤6:创建MybatisConfig配置类2.7 步骤7:创建jdbc.properties2.8 步骤8:创建SpringMVC配置类2.9 步骤9:创建Web项目入口配置类 欢迎大家回到《Java教程之Spring30天快速入门》，本教程所有示例均基于Maven实现，如果您对Maven还很陌生，请移步本人的博文《如何在windows11下安装Maven并配置以及 IDEA配置Maven环境》，本文的上一篇为《Rest风格简介与RESTful入门》
前面我们已经把Mybatis、Spring和SpringMVC三个框架进行了学习，今天主要的内容就是把这三个框架整合在一起完成我们的业务功能开发，具体如何来整合，我们一步步来学习。
1 流程分析 (1) 创建工程
创建一个Maven的web工程pom.xml添加SSM需要的依赖jar包编写Web项目的入口配置类，实现AbstractAnnotationConfigDispatcherServletInitializer重写以下方法 getRootConfigClasses() ：返回Spring的配置类-&gt;需要SpringConfig配置类getServletConfigClasses() ：返回SpringMVC的配置类-&gt;需要SpringMvcConfig配置类getServletMappings() : 设置SpringMVC请求拦截路径规则getServletFilters() ：设置过滤器，解决POST请求中文乱码问题
(2)SSM整合[重点是各个配置的编写] SpringConfig 标识该类为配置类 @Configuration扫描Service所在的包 @ComponentScan在Service层要管理事务 @EnableTransactionManagement读取外部的properties配置文件 @PropertySource整合Mybatis需要引入Mybatis相关配置类 @Import 第三方数据源配置类 JdbcConfig 构建DataSource数据源，DruidDataSouroce,需要注入数据库连接四要素，@Bean @Value构建平台事务管理器，DataSourceTransactionManager,@Bean Mybatis配置类 MybatisConfig 构建SqlSessionFactoryBean并设置别名扫描与数据源，@Bean构建MapperScannerConfigurer并设置DAO层的包扫描 SpringMvcConfig 标识该类为配置类 @Configuration扫描Controller所在的包 @ComponentScan开启SpringMVC注解支持 @EnableWebMvc
(3)功能模块[与具体的业务模块有关] 创建数据库表根据数据库表创建对应的模型类通过Dao层完成数据库表的增删改查(接口+自动代理)编写Service层[Service接口+实现类] @Service@Transactional整合Junit对业务层进行单元测试 @RunWith@ContextConfiguration@Test 编写Controller层 接收请求 @RequestMapping @GetMapping @PostMapping @PutMapping @DeleteMapping接收数据 简单、POJO、嵌套POJO、集合、数组、JSON数据类型 @RequestParam@PathVariable@RequestBody 转发业务层 @Autowired 响应结果 @ResponseBody 2 整合配置 掌握上述的知识点后，接下来，我们就可以按照上述的步骤一步步的来完成SSM的整合。
2.1 步骤1：创建Maven的web项目 可以使用Maven的骨架创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81b7005d69682ba8a06a96d7f330a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580e13054d66fb96bd2a1d7981bcbbb1/" rel="bookmark">
			Java接收并解析HL7协议数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 HL7协议相信医疗行业的IT人员都不陌生，笔者由于接触时间比较短，乍一听“协议”还是比较懵，不自觉就把它和“HTTP”、"SOAP”之类的网络协议挂上关联，可事实上这个HL7只是一种数据格式，传输方式也可以使用最简单的Socket。
二、正文 本文中用到的代码都做了部分敏感字删减，使用过程如遇到编译错误合理调整即可。
笔者调试中用到的工具及问题记录都会放到文末供大家参考。
1、环境配置 引入Maven依赖，笔者使用的hl7-2.6版本，所以只引入v26即可
&lt;dependency&gt; &lt;groupId&gt;ca.uhn.hapi&lt;/groupId&gt; &lt;artifactId&gt;hapi-base&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;!-- 请根据实际情况选择最新版本 --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ca.uhn.hapi&lt;/groupId&gt; &lt;artifactId&gt;hapi-structures-v26&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;!-- 请根据实际情况选择最新版本 --&gt; &lt;/dependency&gt; 增加配置文件作为hl7协议单独配置
#是否开启监听 0-关闭、1-开启 hl7socket.server.flag=0 #端口号 hl7socket.server.port=30000 2、数据接收：HL7Monitor 使用JDK自带注解@PostConstrust作为初始化启动监听，直接使用依赖中封装的API即可，需要注意的是，可以将一些数据校验关闭，否则在接受过程中直接阻断消息接收。
启动监听服务仅需要端口号即可，另外要将接收数据后的业务处理类对象作为参数传入registerApplication方法。
import ca.uhn.hl7v2.DefaultHapiContext; import ca.uhn.hl7v2.HapiContext; import ca.uhn.hl7v2.app.HL7Service; import ca.uhn.hl7v2.app.ServerConfiguration; import ca.uhn.hl7v2.llp.MinLowerLayerProtocol; import ca.uhn.hl7v2.parser.ParserConfiguration; import ca.uhn.hl7v2.parser.PipeParser; import ca.uhn.hl7v2.validation.ValidationContext; import ca.uhn.hl7v2.validation.impl.DefaultValidation; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; /** * 使用HL7监听器，监控目标端口收到的协议 */ @Component @Slf4j(topic = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/580e13054d66fb96bd2a1d7981bcbbb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b986801c9b2f999aea0579e72a6da16/" rel="bookmark">
			基于web的网上订餐系统设计与实现-计算机毕业设计源码26910
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 自从计算机发展开始，计算机软硬件相关技术的发展速度越来越快，在信息化高速发展的今天，计算机应用技术似乎已经应用到了各个领域。在餐饮行业，除了外卖以外就是到店里就餐，在店里就餐如果需要等待点餐的话，用户的体验度就会急剧下降，很多餐饮店也开始开发网上订餐的系统，这样的系统给用户带来了新的体验，尤其是在时间和空间上，让使用者不管身在何处，只要连上网就能够选购菜品，进行订餐。此网上订餐系统的开发项目以Springboot框架为基础，采用JavaWeb的开发方法，使用MySQL数据库，首选对本网上订餐系统的各个功能以及用户的需求做出了解释，然后根据用户线上订餐的需求，再介绍了系统的总体设计以及其详细设计，给用户提供了网上订餐系统的总体结构的搭建方法。从而满足用户网上订餐的需求。
关键词 JavaWeb；Springboot；网上订餐系统 ；MySQL
Online ordering system
Major: Digital media technology Grade: 2017 Class: 13 Student: HongBo Zhao Supervisor: Dujin Liu Abstract Since the development of computer, the development speed of computer hardware and software related technologies is getting faster and faster. Today, with the rapid development of information technology, computer application technology seems to have been applied to various fields. In the catering industry, in addition to takeout is to eat in the restaurant, if you need to wait for the order in the restaurant, the user experience will decline sharply, many restaurants also began to develop online ordering system, such a system brings users a new experience, especially in time and space, so that users no matter where they are, as long as the Internet can buy dishes, Make a reservation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b986801c9b2f999aea0579e72a6da16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d838df4abdef56ce869550d6fc414dd0/" rel="bookmark">
			Java——本地方法（JNA）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 JNA1、概述2、入门案例2.1、示例一（调用系统共享库）2.2、示例二（调用自定义共享库） 2、指针参数Pointer2.1、使用场景2.2、Pointer类2.3、案例 3、引用对象ByReference3.1、使用场景3.2、ByReference类3.3、案例3.4、Pointer与ByReference对比 4、Java模拟C结构体4.1、使用场景4.2、Structure类4.3、结构体本身作为参数4.3、结构体指针作为参数4.4、嵌套结构体本身作为参数4.5、嵌套结构体指针作为参数4.6、结构体中嵌套结构体数组1)、作为输入参数2)、作为输出参数 4.7、结构体数组作为参数1)、错误的调用一2)、错误的调用二3)、正确的调用 5、常见问题5.1、Java 类的字段声明必须与重写方法保持一致5.2、Java映射C数组乱码问题5.3、Java 接收 C 函数返回类型为 char*5.4、动态库和 jdk 的位数必须匹配5.5、动态库版本必须和系统类型匹配 JNA 1、概述 JNA 全称 Java Native Access，是一个建立在经典的 JNI 技术之上的 Java 开源框架。JNA 提供一组 Java 工具类用于在运行期动态访问系统本地库(native library:如 Window 的 dll)而不需要编写任何 Native/JNI 代码。开发人员只要在一个 java 接口中描述目标 native library 的函数与结构，JNA 将自动实现 Java 接口到native function 的映射。
官方网站：https://github.com/java-native-access/jna
Maven依赖：
&lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;5.10.0&lt;/version&gt; &lt;/dependency&gt; Java Native Access PackageDescriptioncom.sun.jna Provides simplified native library access. 提供简化的本机库访问权限。
com.sun.jna.ptr Provides various native pointer-to-type ( &lt;type&gt; *) representations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d838df4abdef56ce869550d6fc414dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a607e5294cac376d5a023831a40e03/" rel="bookmark">
			图像隐写综述（适合小白入门，涉及基础知识、评价指标与前沿算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创作不易，点赞收藏，谢谢！如有交流需要，请关注微信公众号“笔名二十七画生”。
分享有趣知识的公众号
1.图像隐写基础知识
信息保护主要有两种手段：
1.加密技术,是直接对要保护的数据进行数学变换，并使得未授权方无法读取交换的秘密信息。
2.信息隐藏技术,则是将要隐藏的消息放在载体中，使得未授权方无法感知到载体的变化，并且无法读取隐藏的消息。
载体图像:嵌入秘密信息之前的原始图像
含密图像:嵌入秘密信息之后的图像
隐写和数字水印都是信息隐藏的技术，但它们的应用领域、目的和实现方式有一些不同。
面向隐蔽通信的隐写（行文存在性）：
目的：主要目的是在不引起注意的情况下隐藏信息，使其对外界不可察觉。隐写术通常用于隐蔽通信，即通过隐藏信息在媒体中传递秘密消息。
实现方式：通过在媒体载体中嵌入信息，例如在图像、音频、视频等文件中隐藏文本、图像或其他数据。这种技术的主要重点是保持嵌入后的媒体文件外观或内容的一致性，以免引起怀疑。
安全性：隐写术的安全性通常体现在信息是否能够被检测到。隐写术不一定提供数据完整性或认证，而主要侧重于信息的隐蔽性。
面向内容认证和内容保护的数字水印（鲁棒性）：
目标：
内容认证和保护： 数字水印的主要目标是实现内容认证、内容保护或版权保护。它通常被用于在媒体中嵌入信息，以验证内容的真实性或保护知识产权。
鲁棒性： 数字水印注重鲁棒性，即能够抵抗一些可能导致内容变形的操作，如压缩、裁剪、旋转等。
可见性：
可感知性： 数字水印通常是可感知的，但它的设计目标是使其在人类感知的范围内尽可能不可察觉。
提取：
同步性： 数字水印提取通常是同步的，需要原始数据或者特定的密钥。
应用场景：
知识产权保护： 数字水印广泛用于知识产权保护，例如图像、音频、视频的版权认证和保护。
图像隐写技术经典例子：
囚徒模型中,可以很好地阐述隐写术中各方的角色:Alice和Bob是监狱中不同牢房的犯人,他们之间的通信需要在狱警Eve的监视下完成;同时,Eve能够看见他们的通信内容.为了降低狱警Eve防范心的同时完成通信,隐写术孕育而生.Alice将想要传达的秘密信息进行隐写操作隐藏在载体当中,Bob则需要将含密载体中的秘密信息进行提取,狱警Eve时刻监视Alice和Bob的通信,一旦发现任何可疑信息就断绝双方通信。
LSB（least significant bit)
作为早期的隐写方法,LSB是一种基于图片最低有效位修改并储存信息的隐写方法.利用人眼对于色彩差异的不敏感性,将秘密信息通过一定的嵌入方法放入图片的最低有效位,从而将我们所需要隐藏的信息通过一定方法放入图片的最低有效位上.。图3是LSB类隐写流程图,可以看到,载体图像Lena(戴帽子的女人)在隐写前后并不存在明显的差距。
基本嵌入方法给出了隐写算法的优化的基础，然而这些方法只保持了载体的低阶的特征分布，难以构造合适的方法来保持载体的高阶特征分布。
基于深度学习的图像隐写的研究方向：
2.定量与定性评价指标
从以图藏文本、以图藏图２个方面分析基于深度学习的含密图像生成方法，相比于其他图像隐写方法，隐写内容更丰富，隐写容量更大。
以图藏文本含密图像生成方法
以图藏文本的图像隐写框架HayesGAN，首次用编码网络实现图片隐藏秘密信息．
1.秘密信息与载体图像共同输入给编码网络中，得到含密图像；
2.隐写分析网络，也相当于判别网络，对生成的含密图像和 原始载体图像做分析检测；
3.信息的接收方通过解码网络可以得到解密信息．
1.Hayes J, Danezis G. Generating steganographic images via adversarial training[J]. Advances in neural information processing systems, 2017, 30.无源码
在该网络结构中，秘密信息提取的准确率是衡量该类网络性能的重要指标，神经网络提取秘密信息不同于传统的信息嵌入与提取，网络的学习过程具有不可解释性，信息提取的过程不完全可控，如何设计提取网络的结构，控制训练过程以提高秘密信息恢复的准确率是修改网络结构的关键。因此如何保证生成的含密图像有效抵抗隐写分析检测，同时保证秘密信息提取的准确率，是该类图像隐写方法面临的重大挑战。
为了增加隐写的鲁棒性，提出 Hidden图像隐写方式，在网络训练的过程中加入了噪声层，模拟真实情景下含密图像传输过程中所遇到的噪声攻击、压缩等情况，将攻击后的图像放入解码网络中提取秘密信息．该网络考虑到含密图像的真实性、秘密信息提取的准确性、隐写的隐蔽性，进一步增强了 隐写的鲁棒性，为后续隐写方法提升鲁棒性提供了 思路。
编码器E接收秘密消息M和封面图像Ico作为输入（编码为比特串），并产生编码图像Ien。噪声层N使编码图像失真，产生噪声图像Ino。解码器网络接收编码图像并试图重建消息。第三个网络，对手，预测给定图像是否包含编码信息。编码器和解码器被联合训练以最小化由对手检测到的来自封面和编码图像之间的差异的损失LI、来自输入和预测消息之间的差异的损失LM以及来自对手检测编码图像Ien的损失LG。
2.Zhu J, Kaplan R, Johnson J, et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34a607e5294cac376d5a023831a40e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15604a54688998caad6f26934cd6d82/" rel="bookmark">
			MySQL默认值（DEFAULT）和MySQL非空约束（NOT NULL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL默认值（DEFAULT） 默认值（Default）的完整称呼是“默认值约束（Default Constraint）”，用来指定某列的默认值。在表中插入一条新记录时，如果没有为某个字段赋值，系统就会自动为这个字段插入默认值。
例如，员工信息表中，部门位置在北京的较多，那么部门位置就可以默认为“北京”，系统就会自动为这个字段赋值为“北京”。
默认值约束通常用在已经设置了非空约束的列，这样能够防止数据表在录入数据时出现错误。
在创建表时设置默认值约束 创建表时可以使用 DEFAULT 关键字设置默认值约束，具体的语法格式如下：
&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;
其中，“默认值”为该字段设置的默认值，如果是字符类型的，要用单引号括起来。
例 1 创建数据表 tb_dept3，指定部门位置默认为 Beijing，SQL 语句和运行结果如下所示。
mysql&gt; CREATE TABLE tb_dept3 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22), -&gt; location VARCHAR(50) DEFAULT 'Beijing' -&gt; ); Query OK, 0 rows affected (0.37 sec) mysql&gt; DESC tb_dept3; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | YES | | NULL | | | location | varchar(50) | YES | | Beijing | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f15604a54688998caad6f26934cd6d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7ba4f0a9f0795fa57f6b26c1d6824d/" rel="bookmark">
			Mac OS安装Docker容器的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装容器方案概览 Docker是最流行的开源容器产品，为了在Mac Book Pro本地更方便的部署大模型，决定使用Docker容器环境。
下面介绍在Mac OS安装Docker3种方式：
1、命令行方式
2、Docker Desktop for Mac，带一套可视化软件，和Docker环境
3、Docker Toolbox，带一套可视化软件，VirtualBox和Docker环境
注意：Docker Desktop for Mac免费,但是需要Apple Mac OS Sierra 10.12或更高OS版本。 以前操作系统版本可以使用Docker Toolbox。
我们会使用Docker来构建Java Spring Boot 2镜像，以及扩展Java微服务，分布式架构等实战环境。
Docker标准工具套装包括4个部分：
Docker EngineDocker CLI ClientDocker ComposeDocker Machine 现在有些系统已经有GUI工具，之前还是命令客户端管理。
第1种：命令行安装 brew install docker --cask 终端显示正在下载，我这里修改了清华的源，会比国外的快很多。
命令行安装方式只下载docker软件安装，不带GUI客户端。
第2种：Docker Desktop for Mac Docker Desktop for Mac是Docker管理桌面IDE，用于在Mac上构建，调试和测试Dockerized应用程序。 Docker Desktop for Mac是一个完整的开发环境，与Mac OS Hypervisor框架，网络和文件系统深度集成。在Mac上运行Docker的最快，最可靠的方式。
Docker Desktop for Mac系统要求最低为 macOS 必须是 10.15 或更高版本， Catalina、Big Sur 或者 Monterey，建议升级到最新版本的 macOS，同时还需要至少4GB的RAM。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7ba4f0a9f0795fa57f6b26c1d6824d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0313362295ca1fddde5a33b9b1453698/" rel="bookmark">
			Stable-Diffusion|从图片反推prompt的工具：Tagger（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stable-diffusion-webui-wd14-tagger
前面几篇：
Stable-Diffusion|window10安装GPU版本的 Stable-Diffusion-WebUI遇到的一些问题（一）
【Stable-Diffusion|入门怎么下载与使用civitai网站的模型（二）】
Stable-Diffusion|文生图 拍立得纪实风格的Lora 图例（三）
Stable-Diffusion|文生图 完蛋我被美女包围了人物Lora（四）
本篇介绍通过tagger反推，如果成功安装的话，会在TXT2IMG这一个栏目中多出tagger：
填入一张图片，就会自动生成prompt，同时可以通过send to，直接跳转到txt2img,img2img
安装的方式有多种：
直接从extensions中输入https://github.com/toriato/stable-diffusion-webui-wd14-tagger.git进行安装：
还有一种git clone到extensions文件夹下面 此时，笔者遇到了版本问题，一直没有显示tagger这个栏目，参考了【解决stable diffusion webui1.6 wd1.4 tagger加载失败的问题】
需要修改：
tagger/ui.py
# 第十行 # from webui import wrap_gradio_gpu_call # 原代码 from modules.call_queue import wrap_gradio_gpu_call preload.py
# 第4行开始 # from modules.shared import models_path # 原代码 from modules import paths # default_ddp_path = Path(models_path, 'deepdanbooru') # 原代码 default_ddp_path = Path(paths.models_path, "deepdanbooru") 然后restart重启一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c667dcd9c2ea6bb55557bae923545599/" rel="bookmark">
			VSCode前端Vue项目引入Element-ui组件，三步简单操作即可
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode前端Vue项目引入Element-ui组件，三步简单操作即可 1.安装命令 推荐使用npm安装，没有下载node.js的可以前往官网下载，node.js自带npm，如果已经有下载安装过node.js的，在VSCode终端输入以下命令，回车即可安装：
npm i element-ui -S 在package.json文件上有添加"element-ui"，就表示已经安装成功，如果安装失败，需要查看安装的vue脚手架vue/cli版本是否与Element-ui版本冲突了。
2.全局引入 安装Element-ui后，需要引入才可以使用，这里完整引入，在main.js文件里加入红色框里的代码：
main.js文件代码：
import Vue from 'vue' import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import App from './App.vue' Vue.config.productionTip = false Vue.use(ElementUI); new Vue({ render: h =&gt; h(App), }).$mount('#app') 3.测试效果 引入后测试Element-ui组件是否生效，在vue项目App.vue文件里加入Element组件按钮
保存后页面显示按钮，说明已生效，引入Element-ui组件成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf7d61f239ba5a784feb919835b23f1/" rel="bookmark">
			PostgreSQL向量数据插件--pgvector安装（附PostgreSQL安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL向量数据插件--pgvector安装 一、版本二、数据库安装1. 在官网下载PostgreSQL14.0的安装包2.增加用户postgres3.解压安装 三、pgvector安装1. 从github上克隆下来2. 安装pgvector插件3. 开始使用pgvector启用pgsql命令行创建扩展 本文为本人在安装pgvector中踩过的坑，已找到解决方法，现向大家分享。 一、版本 pgvector：0.5.1PostgreSQL数据库：14.0操作系统：Ubuntu18.04 二、数据库安装 因为在此之前安装过PostgreSQL8.4.1，而pgvector只支持11.0及以后的版本，因此安装PostgreSQL14.0
1. 在官网下载PostgreSQL14.0的安装包 PostgreSQL官网
2.增加用户postgres adduser postgres 3.解压安装 解压压缩包
tar zxvf postgresql-14.0.tar.gz 安装依赖包
sudo apt-get install gcc sudo apt-get install g++ sudo apt-get install make sudo apt install libreadline-dev sudo apt-get install zlib1g-dev 编译
cd postgresql-14.0 ./configure --prefix=/usr/local/pgsql --enable-debug sudo make &amp;&amp; sudo make install cd contrib #插件 sudo make &amp;&amp; sudo make install 数据目录创建
sudo mkdir -p /var/postgresql/data chown postgres:postgres /var/postgresql -R chown postgres:postgres /usr/local/pgsql -R 切换用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cf7d61f239ba5a784feb919835b23f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1652850e28e264f6475a42b8d50168/" rel="bookmark">
			2023年度佳作：AIGC、AGI、GhatGPT、人工智能大语言模型的崛起与挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
01 《ChatGPT 驱动软件开发》
内容简介
02 《ChatGPT原理与实战》
内容简介
03 《神经网络与深度学习》
04 《AIGC重塑教育》
内容简介
05 《通用人工智能》
目　录
前言 2023年是人工智能大语言模型大爆发的一年，一些概念和英文缩写也在这一年里集中出现，很容易混淆，甚至把人搞懵。
LLM：Large Language Model，即大语言模型，旨在理解和生成人类语言。LLM的特点是规模庞大，包含成百、上千亿的参数，可以捕捉语言的复杂模式，包括句法、语义和一些上下文信息，从而生成连贯的、有意义的文本。ChatGPT、GPT-4、BERT、文心一言等都是典型的大型语言模型。
GPT：Generative Pre-training Transformer，是OpenAI开发的一种基于Transformer的大规模自然语言生成模型。
AIGC：Artificial Intelligence Generated Content，即AI生成内容。指的是利用AI技术生成的内容，比如AI写文章、画画甚至做视频等等。
AGI：Artificial General Intelligence，即通用人工智能。AGI的目标是创造一个能像人类一样思考、学习、执行多种任务的系统，成为全能的“超级大脑”，未来可能在任何领域都超越人类。
除了概念之外，如果你想进一步了解这些技术的细节和进展，推荐你读这几本书。
推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站
01 《ChatGPT 驱动软件开发》 《ChatGPT驱动软件开发》
AI 在软件研发全流程中的革新与实践
推荐语：中国IT领军者陈斌新作，详解ChatGPT在软件研发全流程的应用，大幅提升研发效率，塑造工程师AI时代竞争优势。
适读人群 ：架构师、开发工程师、数据库工程师、测试工程师、运维工程师、项目经理、产品经理、UI/UX工程师和技术管理者
内容简介 这是一本讲解以ChatGPT/GPT-4为代表的大模型如何为软件研发全生命周期赋能的实战性著作。它以软件研发全生命周期为主线，详细讲解了ChatGPT/GPT-4在软件产品的需求分析、架构设计、技术栈选择、高层设计、数据库设计、UI/UX 设计、后端应用开发、Web 前端开发、软件测试、系统运维、技术管理等各个环节的应用场景和方法。让读者深刻地感受到，ChatGPT/GPT-4在革新传统软件工程的方式和方法的同时，还带来了研发效率和研发质量的大幅度提升。
.
更为重要的是，本书能帮助架构师、开发工程师、数据库工程师、测试工程师、运维工程师、项目经理、产品经理、UI/UX工程师和技术管理者深入地理解ChatGPT/GPT-4的原理和应用，全面塑造他们在AI时代的核心竞争力，实现价值创新并形成竞争优势，为未来的发展奠定基础。
02 《ChatGPT原理与实战》 《ChatGPT原理与实战》
大型语言模型的算法、技术和私有化
推荐语：BAT资深AI专家和大模型技术专家撰写，MOSS系统负责人邱锡鹏等多位专家鼎力推荐！系统梳理并深入解析ChatGPT的核心技术、算法实现、工作原理、训练方法，提供大量代码及注解。
适读人群 ：大模型工程师、AI工程师
内容简介 这是一本系统梳理并深入解析ChatGPT核心技术、算法实现、工作原理、训练方法的著作，也是一本能指导你搭建专属ChatGPT和实现大模型迁移及私有化的著作。本书得到了MOSS系统负责人邱锡鹏等多位专家的高度评价和鼎力推荐。
.
本书集理论、实战和产业应用于一体，提供大量经详细注释的代码，方便读者理解和实操。总之，不管里是想深入研究ChatGPT本身，还是正在研发或使用其他大模型，本书都应该能给你颇具价值的技术启发与思考，让你在大模型的路上快速前行，少走弯路。
03 《神经网络与深度学习》 《神经网络与深度学习》套装
推荐语：豆瓣评分9.5！复旦大学邱锡鹏教授力作，周志华、李航联袂推荐！深受好评的深度学习讲义蒲公英书正式版！系统整理深度学习的知识体系，由浅入深地阐述深度学习的原理、模型以及方法。更适合中文读者的深度学习图书。
《神经网络与深度学习：案例与实践》作为邱锡鹏老师出品的《神经网络与深度学习》配套案例，与《神经网络与深度学习》深度融合，从实践角度诠释原书理论内容。复旦大学邱锡鹏教授、百度飞桨研发团队联袂奉献。
04 《AIGC重塑教育》 《AIGC重塑教育：AI大模型驱动的教育变革与实践》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e1652850e28e264f6475a42b8d50168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b47fb71848a1a50c419c3485fc4d22/" rel="bookmark">
			二叉树：数据结构中的灵魂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓 博客主页：江池俊的博客⏩ 收录专栏：数据结构冒险记👉专栏推荐：✅cpolar ✅C语言进阶之路💻代码仓库：江池俊的代码仓库🔥编译环境：Visual Studio 2022🎉欢迎大家点赞👍评论📝收藏⭐ 文章目录 一、树概念及结构1.1 树的概念1.2 树的相关概念1.3 树的表示1.4 树在实际中的运用（表示文件系统的目录树结构） 二、二叉树概念及结构2.1 概念2.2 特殊的二叉树：2.3 二叉树的性质2.4 二叉树的存储结构1. 顺序存储2. 链式存储 一、树概念及结构 1.1 树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继因此，树是递归定义的 注意：树形结构中，子树之间不能有交集，否则就不是树形结构
1.2 树的相关概念 节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；如上图：A是B的父节点孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；如上图：B是A的孩子节点兄弟节点：具有相同父节点的节点互称为兄弟节点；如上图：B、C是兄弟节点树的度：一棵树中，最大的节点的度称为树的度；如上图：树的度为6节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；树的高度或深度：树中节点的最大层次；如上图：树的高度为4堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙森林：由m（m&gt;0）棵互不相交的树的集合称为森林； 1.3 树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既要保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
typedef int DataType; struct Node { struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域 }; 1.4 树在实际中的运用（表示文件系统的目录树结构） 二、二叉树概念及结构 2.1 概念 一棵二叉树是结点的一个有限集合，该集合：
或者为空由一个根节点加上两棵别称为左子树和右子树的二叉树组成 从上图可以看出：
二叉树不存在度大于2的结点二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 注意：对于任意的二叉树都是由以下几种情况复合而成的：
2.2 特殊的二叉树： 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是 2k - 1，则它就是满二叉树。完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8b47fb71848a1a50c419c3485fc4d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22cfedd7e7c6149cb4c958cbc077fc3/" rel="bookmark">
			Textual Inversion: 一种精调Stable Diffusion模型的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 最近的文本到图像Stable Diffusion （SD）模型已经证明了使用文本提示合成新颖场景的前所未有的能力。这些文本到图像的模型提供了通过自然语言指导创作的自由。然而，它们的使用受到用户描述特定或独特场景、艺术创作或新物理产品的能力的限制。很多时候，用户被迫行使她的艺术自由来生成特定的独特或新概念的图像。此外，使用新数据集为每个新概念重新训练模型非常困难且昂贵。
论文《An Image is Worth One Word: Personalizing Text-to-Image Generation using Textual Inversion》提供了一种简单的方法来允许这些创作自由。在这篇博文中，我们正在讨论一种将我们自己的猫变成一幅画的方法，或者想象一种基于我们最喜欢的玩具使用SD的新产品。我们可以通过冻结文本到图像模型的嵌入空间中的新“单词”，仅使用对象或样式的 3-5 个图像来学习这些用户提供的新概念。
textual inversion工作机理 在我们之前关于SD的博客中，我们看到文本编码器模型将任何输入提示转换为嵌入，这些嵌入被馈送到扩散模型作为指导或调节。我们还可以在图 1 中看到，此过程涉及将输入提示tokenize为一组tokens，这些tokens是某些预定义字典中的索引，然后将这些tokens通过文本编码器传递以获取嵌入。每个token都链接到一个唯一的嵌入向量，可以通过基于索引的查找来检索该嵌入向量。
这些文本嵌入与潜在图像输入和 t 一起传递到下游 UNet 模型作为指导。我们还可以更改一个对象的token嵌入，并将其替换为另一个对象的token嵌入，以获得不同的图像。同样，我们可以学习特定对象或概念的新token嵌入。
在 textural inversion中，我们选择这个嵌入空间作为反演的目标。“ textural inversion”背后的想法是使用一些示例图像向文本模型教授一个新单词，并训练其嵌入接近某些视觉表示。这是通过向词汇表添加新token并使用一些代表性图像进行训练来实现的。因此，我们尝试找到代表我们新的特定概念的新嵌入向量。 textural inversion可用于将经过训练的标记添加到词汇表中，并将其与预训练的SD模型一起使用。
因此，我们指定一个占位符字符串，我们将其称为伪词，用 S* 表示，如图 1 所示，来表示我们希望学习的新概念。我们干预嵌入过程，并用新学习的嵌入 v* 替换与tokenized字符串相关的向量。因此，我们能够将新概念注入我们的词汇中。然后像任何其他单词一样对待这个伪单词，并且可以用来为生成模型组成新颖的文本查询或新句子。因此，人们可以要求“一张S在海滩上的照片”，“一幅S挂在墙上的油画”，甚至可以组成两个概念，例如“一幅S1的S2风格的画”。 ”。在此过程中我们没有对生成模型进行任何更改，因此基本生成模型可以用于我们的新概念。
论文作者将 textural inversion过程的示意图如下所示。
我们可以看到，我们可以从提示“A photo of S*”中获取图像，其中 S* 是一个新对象或新样式，就像我们从提示“A photo of cat”中获取图像一样。
文本嵌入 找到这些伪词的嵌入的任务被定义为反转任务之一。在这里，我们使用固定的预训练文本到图像模型和一小组描述该概念的图像。我们的目标是找到一个单词嵌入，这样“A photo of S*”形式的句子将导致从我们的小集合中重建图像。这种嵌入是通过优化过程找到的（图 4），我们将其称为“Textual Inversion”。
在Latent Diffusion Models领域，inversion是通过向图像添加噪声然后通过网络对其进行去噪来执行的，但此过程会显着改变图像内容。在文本转换中，我们反转用户提供的概念并将该概念表示为模型词汇表中的新伪词。新标记的嵌入存储在一个小型 PyTorch pickled 字典中，其密钥是经过训练的新文本token。由于我们pipeline中的编码器不知道该术语，因此我们需要手动添加它。
训练 Textual Inversion的目的是能够快速引导生成新的、用户指定的概念。我们尝试将这些新颖的概念编码为预训练的文本到图像模型的中间表示。因此，我们寻求在文本到图像模型所使用的文本编码器的词嵌入阶段表示这些概念。人们发现这个嵌入空间的表现力足以捕获基本的图像语义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c22cfedd7e7c6149cb4c958cbc077fc3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/549/">«</a>
	<span class="pagination__item pagination__item--current">550/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/551/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>