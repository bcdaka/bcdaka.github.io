<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ebe4464c23e4f0f1465125b2c1f44e/" rel="bookmark">
			Termius for Mac/Win：高效、安全的跨平台多协议远程管理软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Termius for Mac/Win是一款专为专业人士设计的跨平台多协议远程管理软件，以其强大的功能、简洁的界面和高效的操作体验，赢得了广泛的好评。这款软件不仅支持SSH、Telnet、SFTP等多种远程连接协议，还具备丰富的安全特性和便捷的管理功能，是远程连接和管理的理想选择。 主要特点： 多协议支持：Termius支持SSH、Telnet、SFTP、RDP、Mosh等多种远程连接协议，满足用户多样化的连接需求。无论是连接Linux服务器、Windows远程桌面还是其他设备，Termius都能提供稳定、高效的连接服务。
可视化主机管理：Termius提供了直观的可视化主机管理界面，用户可以轻松添加、编辑和删除远程主机，并为它们设置标签和颜色，以便更好地组织和管理。这种管理方式极大地提高了用户的工作效率。
多平台同步：Termius支持多平台同步功能，用户可以在多个设备上同步会话、主机和设置，实现无缝衔接。这一功能使得用户在不同设备间切换时无需重复设置和配置，提高了工作的便捷性。
强大的安全性能：Termius采用了先进的加密技术，确保数据传输过程中的安全性。同时，它还支持SSH密钥、密码、2FA等多种身份验证方式，以及指纹和面部识别等生物识别技术，为用户的数据安全提供双重保障。
丰富的实用功能：除了基本的远程连接功能外，Termius还提供了命令历史补全、端口转发、文件传输、多会话管理等实用功能。这些功能使得用户在远程管理过程中能够更加高效地完成各项任务。
总结： Termius for Mac/Win凭借其多协议支持、可视化主机管理、多平台同步、强大的安全性能以及丰富的实用功能，成为了一款备受推崇的跨平台多协议远程管理软件。无论是企业IT人员还是个人用户，都可以从中受益，实现更加高效、安全的远程连接和管理。
Mac安装：Termius for Mac(多协议远程管理软件)v8.4.0版
Win安装：Termius (终端模拟器/ssh/sftp客户端软件)v7.13.0 特别版 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab12819c40e37ee6e2c3f325a136250d/" rel="bookmark">
			关于武汉高芯coin417G2红外机芯的二次开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、外观和机芯参数二、SDK的使用1、打开相机2、回调函数中获取全局温度和图像3、关闭相机 前言 最近工作中接触了一款基于武汉高芯科技有限公司开发的红外模组,即coin417g2(测温型)+9.1mm镜头.使用此模组,开发了一套红外热成像检测桌面应用程序.下面简单记录下该模组的使用.
一、外观和机芯参数 如下是该机芯的外观和机芯参数:
二、SDK的使用 这里使用的是linux_sdk_usb2.0_v.1.1.5_aarch64-linux-gnu-gcc-8.4.0版本.
1、打开相机 int ret = guide_usb_initial(); if(ret &lt; 0){ g_pLog-&gt;log_E(QString::fromLocal8Bit("初始化相机失败,ret=%1").arg(ret)); return -1; } else{ g_pLog-&gt;log_I(QString::fromLocal8Bit("初始化相机成功,ret=%1").arg(ret)); ret = guide_usb_opencommandcontrol((OnSerialDataReceivedCB)serailCallBack); if(ret &lt; 0){ g_pLog-&gt;log_E(QString::fromLocal8Bit("开启机芯控制命令通信失败,ret=%1").arg(ret)); return -1; } else{ g_pLog-&gt;log_I(QString::fromLocal8Bit("开启机芯控制命令通信成功")); } } m_deviceInfo = (guide_usb_device_info_t*)malloc(sizeof (guide_usb_device_info_t)); m_deviceInfo-&gt;width = IMAGEWIDTH; m_deviceInfo-&gt;height = IMAGEHEIGHT; m_deviceInfo-&gt;video_mode = Y16_PARAM_YUV; //观瞄mode:YUV_PARAM //测温mode:Y16_PARAM_YUV ret = guide_usb_openstream(m_deviceInfo,(OnFrameDataReceivedCB)frameCallBack,(OnDeviceConnectStatusCB)connectStatusCallBack); if(ret &lt; 0) { g_pLog-&gt;log_E(QString::fromLocal8Bit("打开视频流失败,ret=%1").arg(ret)); return -1; } else{ g_pLog-&gt;log_I(QString::fromLocal8Bit("打开视频流成功")); } 2、回调函数中获取全局温度和图像 int serailCallBack(guide_usb_serial_data_t *pSerialData) { int i = 0; for (i = 0;i&lt; pSerialData-&gt;serial_recv_data_length;i++) { if(i== (pSerialData-&gt;serial_recv_data_length-1)) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab12819c40e37ee6e2c3f325a136250d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b24f7b998fb14f35a1994b908927f38/" rel="bookmark">
			TRIZ在充电桩安全中的应用探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今电动汽车日益普及的时代，充电桩的安全问题至关重要。TRIZ（发明问题解决理论）可以为提升充电桩的安全性提供强大助力。具体步骤如深圳天行健企业管理咨询公司下文所述：
一、充电桩安全面临的问题
1.电气安全风险：包括过压、过流、短路等电气故障，可能导致设备损坏、火灾甚至人员伤亡。
2.机械安全风险：如充电桩外壳的坚固程度、充电插头的插拔可靠性等，可能影响用户的使用安全。
3.环境安全风险：充电桩在户外使用时，可能面临恶劣的天气条件、电磁干扰等，影响其正常运行和安全性。
4.网络安全风险：随着充电桩的智能化发展，网络安全问题日益凸显，如黑客攻击、数据泄露等。
二、TRIZ在充电桩安全中的应用
1.解决电气安全问题
-利用TRIZ的矛盾矩阵和发明原理，可以找到解决过压、过流等问题的创新方案。例如，采用智能保护电路，当检测到异常电流或电压时，自动切断电源，保护设备和用户安全。
-应用分离原理，将充电桩的电气部分与外壳分离，提高电气绝缘性能，降低触电风险。
2.提高机械安全性能
-运用TRIZ的物场分析方法，优化充电插头和插座的设计，提高插拔的可靠性和稳定性，减少机械故障的发生。
-采用强化原理，增强充电桩外壳的强度和耐腐蚀性，提高其抗冲击和抗破坏能力。
3.应对环境安全挑战
-利用TRIZ的动态化原理，设计可调节的充电桩结构，使其能够适应不同的天气条件，如防风、防雨、防晒等。
-采用复合材料或特殊涂层，提高充电桩的抗电磁干扰能力，确保其在复杂的电磁环境下正常工作。
4.加强网络安全防护
-应用TRIZ的信息传递原理，建立安全的通信协议和加密技术，防止黑客攻击和数据泄露。
-采用冗余原理，设置多重安全防护措施，如防火墙、入侵检测系统等，提高充电桩的网络安全性能。
TRIZ理论为充电桩的安全问题提供了创新的解决思路和方法。通过运用TRIZ的工具和原则，可以有效地解决充电桩在电气、机械、环境和网络等方面的安全问题，提高充电桩的可靠性和安全性，为电动汽车的普及和发展提供有力保障。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a47abc7691633c7afff9d555600d8de/" rel="bookmark">
			关于HarmonyOS的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day23 一、DOM尺寸和位置 1.只能获取到内联style属性的CSS样式中的宽和高，如果有，获取;如果没有，则返回空 $('.box1').style.width $('.box1').style.height $'.box1').style.backgroundColor
2.返回了元素大小，但没有单位，默认单位是px，如果设置了其他的单位，比如100em之类，返回出来的结果还会转换为px像素（不含边框） width + padding值 $('.box2').clientWidth $('.box2').clientHeight
3.获取左边框和上边框的宽度 $('.box2').clientLeft $('.box2').clientTop
4.返回了元素大小，默认单位是px。如果没有设置任何CSS的宽和高度，他会得到计算后的宽度和高度, 包含盒模型中除margin以外的宽高（包含边框）最稳定，使用最频繁 $('.box3').offsetWidth $('.box3').offsetHeight
5.获取滚动内容的元素大小（当元素出现滚动条时，此属性指全部滚动内容的宽高）返回了元素大小，默认单位是px。如果没有设置任何CSS的宽和高度，它会得到计算后的宽度和高度 整个内容的 $('.box4').scrollWidth $('.box4').scrollHeight
二、offset家族 offsetWidth 获取元素的宽度（width+padding+border） offsetHeight 获取元素的高度（width+padding+border） offsetLeft 获取元素距离容器素左边的距离（需要定位参照） offsetTop 获取元素距离容器素上边的距离（需要定位参照） offsetParent 获取父元素（需要定位参照）
三、鼠标事件 // onclick：当用户单击鼠标按钮或按下回车键时触发 $('button:nth-child(1)').onclick = function(){ console.log('哈哈1') } ​ // ondblclick：当用户双击主鼠标按钮时触发 - 连续点击两次 $('button:nth-child(2)').ondblclick = function(){ console.log('哈哈2') } ​ // onmousedown：当用户按下了鼠标还未弹起时触发 - 弹窗测试最明显 // $('div').onmousedown = function(){ // console.log('张涛按下了') // } ​ // onmouseup：当用户释放鼠标按钮时触发 - 鼠标抬起 // $('div').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a47abc7691633c7afff9d555600d8de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339c261b12f00cabe7f8c00d23385688/" rel="bookmark">
			【数据结构】——堆排序以及向上、向下调整算法的时间复杂度推导及实现（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是堆排序？ 堆排序是由堆这种数据结构所设计的一种排序算法
堆的分类： 大根堆：每个父结点的值都大于子结点
小根堆 ：每个父结点的值都小于子结点
在了解完堆之后，需要先了解建堆，建堆有向上建堆建大堆或者小堆，也有向下建堆建大堆或者小堆 建大堆还是小堆看子结点和父结点的比较关系是大于还是小于
向上调整算法 新数据插⼊到数组的尾上，再进行向上调整算法，直到满⾜堆。
• 先将元素插⼊到堆的末尾,即最后⼀个孩⼦之后 • 插⼊之后如果堆的性质遭到破坏，将新插⼊结点顺着其双双亲往上调整到合适位置即可
void swap(int* x, int* y) { int tmp = *x; *x = *y; *y = tmp; } //建大堆还是小堆将两个算法的第一个判断条件修改相反即可 //向上调整 void AdjustUp(HPDataType* arr,int child) { int parent = (child - 1) / 2;//根据子结点求父结点 while (child &gt; 0)//直到子结点为根结点即循环停止 { // &gt; if (arr[child] &lt; arr[parent])//子结点小就交换，创建小堆 { swap(&amp;arr[child], &amp;arr[parent]); child = parent; parent = (child - 1) / 2; } else { break; } } } 向上调整算法时间复杂度计算推导 第1层，2^0个结点，需要向上移动0层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/339c261b12f00cabe7f8c00d23385688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e7422fcfb6dfc113dfb54d04476ced/" rel="bookmark">
			最新版本Anaconda 2024.06-1安装设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版本Anaconda 2024.06-1安装设置 零、时光宝盒 做自己的光，不需要很亮 太阳很强大，耀眼夺目，给世界带来温暖和阳光。
萤火虫很弱小，若隐若现，却给黑暗中前行的人带来希望。
发光不是强者的权利，我们都可以。
做自己的光，不需要很亮。
所有的努力，不是为了让别人觉得你了不起，而是为了能让自己打心里看得起自己。
没有人可以回到过去，但可以从现在开始。
----------------------------------------------------------------------------------------------
生活不易，我们都要学会在任何情况下都能让自己开心起来的能力。
大家一起开心一下:
1、我就说了一句我喝不了酒，他们就到处说我活不了多久。
2、我说我要饿昏了，他们到处说我二婚了。
3、我有什么缺点你尽管说，我放大给你看，你需要几倍的显微镜？
4、掉头发的时候感觉自己是一株蒲公英，问题是，那些头发会发芽吗？
5、夏日炎炎，你快往嘴上抹点风油精，说点风凉话给我听，让我凉快凉快，哈哈~
6、我这清汤寡水的日子，被造谣得风生水起。
逆境清醒
2024.7.5
本文目录：
零、时光宝盒
一、下载Anaconda
二、Anaconda安装
三、配置Anaconda环境
四、验证Anaconda安装
五、运行Anaconda
六、优化Anaconda
七、附录
一、下载Anaconda 开源数据科学平台Anaconda简介
我写这篇博文时，Anaconda 最新版本是：2024.06-1 (Jun 26, 2024)
安装程序 Python 版本：3.12.4
1.1、下载Anaconda地址：Download Anaconda Distribution | AnacondaDownload Anaconda's open-source Distribution today. Discover the easiest way to perform Python/R data science and machine learning on a single machine.https://www.anaconda.com/downloadhttps://www.anaconda.com/download
​
左边页面中文意思大概如下：
分配
注册以获取在工作站上开始使用所需的一切
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41e7422fcfb6dfc113dfb54d04476ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c2beb06d89a3a8aabcba81b8719226/" rel="bookmark">
			7个 C# 高阶用法详解：从基础到实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 高阶用法详解：从基础到实战 在实际开发中，C# 提供了很多高级特性和设计模式，帮助我们写出更加简洁、灵活和高效的代码。本篇将深入探讨 C# 中的高阶用法，通过丰富的示例，带你掌握这些工具的精髓。
1. LINQ（Language Integrated Query）进阶用法 LINQ 提供了强大的查询功能，下面是一些进阶的应用场景。
// 示例1：结合复杂的过滤与投影 var students = new List&lt;Student&gt; { new Student { Name = "Alice", Age = 20, Grade = 85 }, new Student { Name = "Bob", Age = 22, Grade = 70 }, new Student { Name = "Cathy", Age = 21, Grade = 95 } }; var filteredStudents = students .Where(s =&gt; s.Age &gt; 20 &amp;&amp; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99c2beb06d89a3a8aabcba81b8719226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242c41ff07358accb1a40c7ec8e3cceb/" rel="bookmark">
			大数据-122 - Flink Time Watermark Java代码测试实现Tumbling Window
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（已更完）Spark（已更完）Flink（正在更新！） 章节内容 上节我们完成了如下的内容：
Flink Time 详解示例内容分析Watermark Watermark Watermark 在窗口计算中的作用 在使用基于事件时间的窗口时，Flink 依赖 Watermark 来决定何时触发窗口计算。例如，如果你有一个每 10 秒的滚动窗口，当 Watermark 达到某个窗口的结束时间后，Flink 才会触发该窗口的计算。
假设有一个 10 秒的窗口，并且 Watermark 达到 12:00:10，此时 Flink 会触发 12:00:00 - 12:00:10 的窗口计算。
如何处理迟到事件 尽管 Watermark 能有效解决乱序问题，但总有可能会出现事件在生成 Watermark 之后才到达的情况（即“迟到事件”）。为此，Flink 提供了处理迟到事件的机制：
允许一定的延迟处理：可以配置窗口允许迟到的时间。迟到事件的侧输出流（Side Output）：可以将迟到的事件发送到一个侧输出流中，以便后续处理。 DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; mainStream = stream.keyBy(t -&gt; t.f0) .window(TumblingEventTimeWindows.of(Time.seconds(10))) .allowedLateness(Time.seconds(5)) .sideOutputLateData(lateOutputTag); 代码实现 数据格式 01,1586489566000 01,1586489567000 01,1586489568000 01,1586489569000 01,1586489570000 01,1586489571000 01,1586489572000 01,1586489573000 01,1586489574000 01,1586489575000 01,1586489576000 01,1586489577000 01,1586489578000 01,1586489579000 编写代码 这段代码实现了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242c41ff07358accb1a40c7ec8e3cceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360314ac8bc7f4d813cacba3bb779f37/" rel="bookmark">
			AcWing算法基础课-786第k个数-Java题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是何未来，本篇文章给大家讲解《AcWing算法基础课》786 题——第 k 个数。本篇文章详细解析了如何使用 Java 实现快速排序算法，以解决查找数组中第 k 个元素的问题。通过深入浅出的讲解，展示了从输入读取到快速排序实现的完整流程，帮助读者理解并掌握这一经典算法的核心思想和应用技巧。
文章目录 ❓题目描述💡算法思路✅Java代码🔗参考 ❓题目描述 给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。
输入格式
第一行包含两个整数 n 和 k。
第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整数数列。
输出格式
输出一个整数，表示数列的第 k 小数。
数据范围
1≤n≤100000, 1≤k≤n 输入样例：
5 3 2 4 1 5 3 输出样例：
3 💡算法思路 对数列进行快速排序找出排序后数列中的第 k 个数 具体实现步骤：
调用QuickSort方法对数组nums进行快速排序。快速排序的核心思想是选择一个基准值，将数组分为两部分，一部分小于基准值，一部分大于基准值，然后递归地对这两部分进行排序。在QuickSort方法中，首先选择一个基准值（这里选择的是中间位置的值），然后使用两个指针i和j从数组的两端向中间移动，分别找到第一个大于基准值和小于基准值的元素，并交换它们的位置，以此来分区。递归地对基准值左右两部分进行快速排序，直到整个数组有序。排序完成后，直接输出数组中第 k-1 位置的元素，即第 k 个数。 ✅Java代码 package basic.sort; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.StreamTokenizer; public class Aw786 { // 创建一个StreamTokenizer对象，用于读取输入流 public static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/360314ac8bc7f4d813cacba3bb779f37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10373e5b5e7f964326b2da5be07fde0/" rel="bookmark">
			Docker 容器技术：简化 MySQL 主从复制部署与优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、为什么基于Docker搭建？二、利用Docker搭建主从服务器2.1 配置Master（主）2.2 配置Slave（从）2.3 链接Master（主）和Slave（从）2.4 测试主从复制 三、常见问题3.1 什么时候用读写分离?3.2 MySQL主从复制原理3.3 解决主从复制延迟有几种常见的方法?3.4 造成 mysql 同步延迟常见原因 前言 在现代数据库管理中，MySQL 主从复制是一种关键技术，用于提高数据的可用性和性能。随着 Docker 容器技术的普及，利用 Docker 搭建 MySQL 主从复制环境已成为一种趋势，它提供了一种简便、高效且可扩展的解决方案。本文将介绍 Docker 在 MySQL 主从复制中的应用，包括搭建步骤、配置技巧以及如何避免常见的复制延迟问题。
我们将从为什么选择 Docker 进行 MySQL 主从复制开始，探讨其带来的灵活性和便利性。接着，通过详细的步骤指导，展示如何配置主从服务器并进行链接。文章还将讨论读写分离的使用场景、复制原理，以及减少同步延迟的策略。
一、为什么基于Docker搭建？ 为什么基于Docker搭建？
资源有限虚拟机搭建对机器配置有要求，并且安装mysql步骤繁琐一台机器上可以运行多个Docker容器Docker容器之间相互独立，有独立ip，互不冲突Docker使用步骤简便，启动容器在秒级别 应用场景：
一种是读写分离，新增、修改、删除操作主服务器，查询操作从服务器另外一种高可用，当主服务器出现问题，快速切换到从服务器 二、利用Docker搭建主从服务器 首先拉取docker镜像,我们这里使用5.7版本的mysql：
docker pull mysql:5.7 然后使用此镜像启动容器，这里需要分别启动主从两个容器
Master(主)：
docker run -p 3339:3306 --name master -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 Slave(从)：
docker run -p 3340:3306 --name slave -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 Master对外映射的端口是3339，Slave对外映射的端口是3340。因为docker容器是相互独立的，每个容器有其独立的ip，所以不同容器使用相同的端口并不会冲突。这里我们应该尽量使用mysql默认的3306端口，否则可能会出现无法通过ip连接docker容器内mysql的问题。
一些命令：
#停止容器 docker stop 容器名或者id docker rm 容器名或者id # 查看正在运行的容器 docker ps 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f10373e5b5e7f964326b2da5be07fde0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c94ffb83b343629254dc4f2575d8d0/" rel="bookmark">
			开源 AI 模型实际部署以及后端搭建（一）--环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源 AI 模型实际部署以及后端搭建（一）–环境配置 本文是博主zzzzz想要综合多个开源AI模型分布式部署,以及分布式后端反馈的搭建日记
技术栈 python 与 golang
Gin框架,grpc,Redis等等
基础环境搭建 算力平台 ( cuda , conda ) 基本需求显卡支持调用cuda且满足后续所提项目的显存(最好&gt;=12GB)
若搭建在虚拟机上需独占内存
对于一台新开的Linux机子,
一开始不少困扰大家的就是环境搭建,
我看过周围的人搭建环境卡了两天都没搭好(请不要让apt或者pip等工具自己匹配版本下载),
于此,我在这里写详细一些.
接下来,我以本人的Ubuntu Linux 22.04 + NVIDIA RTX 5000 架构:Turing 举例 (T4可以照抄,其他更多型号要留意适配cuda版本)
以我的举例 ( PS:我们需要在英伟达官网找到对应卡支持的版本!!! )
wget https://developer.download.nvidia.com/compute/cuda/12.3.1/local_installers/cuda_12.3.1_545.23.08_linux.run 安装nvidia显卡驱动首先需要禁用nouveau，不然会碰到冲突的问题，导致无法安装nvidia显卡驱动。
编辑文件blacklist.conf
sudo vim /etc/modprobe.d/blacklist.conf
在文件最后部分插入以下两行内容
blacklist nouveau options nouveau modeset=0 更新系统
sudo update-initramfs -u 之后需要重新启动
sudo reboot 重启之后
我们回到下载cuda的位置
给予安装权限
chmod +x cuda_12.3.1_545.23.08_linux.run 安装前保证之前安装过build-essential
sudo apt install build-essential 即可
sudo .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c94ffb83b343629254dc4f2575d8d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fb58c193c8897f92e26c671ab812fb/" rel="bookmark">
			如何在SpringBoot中实现优雅关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❃博主首页 ： 「码到三十五」 ，同名公众号 :「码到三十五」，wx号 : 「liwu0213」 ☠博主专栏 ： &lt;mysql高手&gt; &lt;elasticsearch高手&gt; &lt;源码解读&gt; &lt;java核心&gt; &lt;面试攻关&gt; ♝博主的话 ： 搬的每块砖，皆为峰峦之基；公众号搜索「码到三十五」关注这个爱发技术干货的coder，一起筑基 本文中，一起研究下Spring Boot提供的开箱即用功能之一：“优雅关闭”。
在了解什么是优雅关闭和如何关闭之前，了解我们需要处理优雅关闭的不同情况非常重要。
正常关机的要求 SpringBoot应用程序的关闭可以是崩溃，也可以是手动关闭的。
你可能想知道我们什么时候需要手动关闭它。此要求出现在许多事件中，其中包括：
当我们因任何维护活动而关闭服务时。当我们执行更新部署时。 上述情况下，要么终止进程，要么使用Spring Boot Actuator 提供的关闭方法实现进程终止。
什么是优雅关闭 Shutdown、Crash 和 Graceful 之间的区别在于，它控制决定了我们可以用这个事件做什么。按照我们的期望，Spring Boot应该为我们提供一种处理此事件的方法，这样我们就可以确保良好的资源管理（清理资源、释放锁和连接）。
让我们看看 Spring Boot 提供什么。
实现优雅关机 Spring Boot 2.3 版在 application.properties 中引入了一些设置，有助于实现优雅关闭。让我们看看这些属性。
# application.properties server.shutdown = graceful 使用此设置，当停止服务器时，它将不会接受新请求，从而确保关闭过程顺利进行。默认情况下，它将等待 30 秒以等待任何待处理的请求完成。
可以控制这个时间吗？Spring Boot 提供了另一个属性，我们可以用它来控制关机过程的时间量。
#application.properties spring.lifecycle.timeout-per-shutdown-phase=1m 通过此设置，Spring Boot 将等待 1 分钟才完成关闭过程。
让我们看看如何向SpringBoot 应用程序添加关闭方法。
启用关闭方法 需要添加以下依赖来为 Spring Boot 应用程序启用执行器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3fb58c193c8897f92e26c671ab812fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10bdd20a2cff75f706d8fb038ccd975/" rel="bookmark">
			比较版本号-双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package org.example.demo; //比较版本号 public class VersionComDoubleSolution { public int compareVersion(String version1, String version2) { int n = version1.length(), m = version2.length(); int i = 0, j = 0; while (i &lt; n || j &lt; m) { int x = 0; for (; i &lt; n &amp;&amp; version1.charAt(i) != '.'; ++i) { x = x * 10 + version1.charAt(i) - '0'; } ++i; int y = 0; for (; j &lt; m &amp;&amp; version2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e10bdd20a2cff75f706d8fb038ccd975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96dc7deb3b8d0a99f1ec393c0e9fc5ac/" rel="bookmark">
			iOS——frame和bounds的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把frame理解为占用区域，把bounds理解为边界。View在旋转过程中，其实自己的坐标系统并没有发生改变，bounds中的origin只能通过setBounds方法修改。
frame 定义了视图在其父视图坐标系统中的位置和大小。其坐标系是相对于俯视图的坐标系。
bounds 定义了视图自身坐标系统中的位置和大小。其坐标系是相对于自己本身视图的坐标系。
UIView.h中的注释：
// 如果视图进行了变换，不要使用 frame，因为它不会正确反映视图的实际位置。使用 bounds + center 代替。 @property(nonatomic) CGRect frame; // 如果非恒等变换，请使用 bounds/center 而不是 frame。 @property(nonatomic) CGRect bounds; // 默认 bounds 是原点为零，大小为 frame 的大小。 @property(nonatomic) CGPoint center; // center 是 frame 的中心，相对于 anchorPoint。 bounds的x,y是根据自己的坐标系统而言的。没错，每个view都有自己的坐标系。以自己左上角点为坐标原点。所以bounds的x,y默认为(0,0),除非调用setBounds方法；frame的size不一定等于bounds的size，在旋转后它们的size就不一样了。 有如下示例：
- (void)viewDidLoad { [super viewDidLoad]; UIButton *animateButton = [UIButton buttonWithType:UIButtonTypeSystem]; animateButton.frame = CGRectMake(100, 250, 100, 50); [animateButton setTitle:@"Animate" forState:UIControlStateNormal]; [animateButton addTarget:self action:@selector(startAnimation) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:animateButton]; self.fView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96dc7deb3b8d0a99f1ec393c0e9fc5ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294276ae330a6e1ba0f536a9def093ab/" rel="bookmark">
			双向链表的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双向链表是一种数据结构，它由节点组成，每个节点包含两个指针：一个指向前一个节点，另一个指向后一个节点。这种结构允许双向访问，即既可以向前遍历（像单链表一样），也可以向后遍历。这使得在插入和删除元素时效率较高，因为只需要改变相邻节点的指针即可，而不需要像数组那样移动大量元素。
以下是双向链表的一些关键特性：
首节点和尾节点：通常有特定的标识符表示头结点和尾结点，它们没有前驱或后继节点。插入和删除操作：相对于单链表，可以在头部、尾部以及任意位置轻松地添加或移除节点。访问元素：通过当前节点的指针可以向前或向后移动到相邻节点。 #include "doulink.h" #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; DLink_t *create_doulink() { DLink_t *pdoulink = malloc(sizeof(DLink_t)); if (NULL == pdoulink) { perror("fail malloc"); return NULL; } pdoulink-&gt;phead = NULL; pdoulink-&gt;clen = 0; pthread_mutex_init(&amp;(pdoulink-&gt;mutex), NULL); return pdoulink; } int is_empty_doulink(DLink_t *pdoulink) { return NULL == pdoulink-&gt;phead; } int push_doulink_head(DLink_t *pdoulink, DataType data) { DLink_Node_t *pnode = malloc(sizeof(DLink_Node_t)); if (NULL == pnode) { perror("fail malloc"); return -1; } pnode-&gt;data = data; pnode-&gt;ppre = NULL; pnode-&gt;pnext = NULL; if (is_empty_doulink(pdoulink)) { pdoulink-&gt;phead = pnode; } else { pnode-&gt;pnext = pdoulink-&gt;phead; pdoulink-&gt;phead-&gt;ppre = pnode; pdoulink-&gt;phead = pnode; } pdoulink-&gt;clen++; return 0; }	void doulink_for_each(DLink_t *pdoulink, int dir) { if (is_empty_doulink(pdoulink)) return; DLink_Node_t *p = pdoulink-&gt;phead; if (dir) { while (p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/294276ae330a6e1ba0f536a9def093ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba3e75f3196d4e6dc78848453a42b3c/" rel="bookmark">
			【2024高教社杯全国大学生数学建模竞赛】B题 生产过程中的决策问题——解题思路 代码 论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题 1：抽样检测方案的设计问题 2：生产过程中的决策问题 3：多工序、多零配件的生产决策问题 4：重新分析次品率题目难度分析1. 统计检测方案设计的复杂性（问题 1）2. 多阶段生产决策的复杂性（问题 2 &amp; 3）3. 多工序、多零配件的组合复杂性（问题 3）4. 次品率估计的重新决策（问题 4） 参考模型 问题 1：抽样检测方案的设计 目标是为企业设计抽样检测方案，以尽可能少的检测次数判定零配件次品率是否超过标称值。
假设检测过程服从二项分布，即抽取一定数量的样本，根据样本中不合格零配件的数量推断整体次品率。根据标称值和信度水平 ，应用统计学中的假设检验理论。这里可以采用 假设检验的双侧检验,设置：
零假设：次品率不超过标称值；
备择假设：次品率超过标称值。检验方案设计：
通过计算置信区间，结合企业的次品率要求以及信度水平（95%和90%），确定需要的样本量。
可采用 样本量计算公式 来确定最少的检测次数，确保在给定信度下可以得出正确结论。 问题 2：生产过程中的决策 为生产过程中不同阶段做出决策，包含零配件检测、成品检测、不合格成品处理等。
零配件检测：
计算检测成本与不检测带来的潜在风险损失（如不合格零配件进入装配过程会导致更多的成品不合格）。
通过分析次品率、检测成本等因素，决定是否对零配件进行检测。若检测成本较高且次品率较低，可能选择不检测。
成品检测：
需要权衡成品的市场售价、检测成本以及调换不合格成品的损失。
通过建模计算各决策方案下的总成本，找出最优的检测方案（检测或不检测）。
不合格成品拆解： 分析拆解费用与次品率，判断拆解零配件的价值是否高于直接报废不合格成品。对于高拆解费用但零配件较贵的情况，可以选择拆解，否则直接报废。
退回的成品处理:同样使用成本效益分析，对退回产品的处理（拆解或丢弃）做出最优决策。
问题 3：多工序、多零配件的生产决策 本问题在问题 2 的基础上增加了更多复杂度，要求考虑多道工序及更多零配件的生产决策。
多工序影响：
各道工序会影响零配件和半成品的次品率，需要建立更为复杂的模型。
通过 马尔科夫链或蒙特卡洛模拟 等方法预测不同工序下的质量演变，计算各工序的最优策略。
多零配件决策：
不同零配件的次品率和成本不一，对每个零配件进行单独决策。
根据总装配成本、检测成本和市场售价，优化整体生产链的成本结构。
问题 4：重新分析次品率 在问题 4 中，假设问题 2 和问题 3 中的次品率是通过抽样检测方法得到的。这意味着需要重新结合问题 1 中设计的抽样检测方案，重新计算次品率并基于此调整各个决策。
结合抽样检测数据 ：
使用问题 1 中得出的检测方案，得到更为精确的次品率估计值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba3e75f3196d4e6dc78848453a42b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbaf8d7501553c0bdc54b3109ead24dd/" rel="bookmark">
			iOS——通知协议代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通知 概要 观察者和被观察者都无需知晓对方，只需要通过标记在NSNotificationCenter中找到监听该通知所对应的类，从而调用该类的方法。并且在NSNotificationCenter中，观察者可以只订阅某一特定的通知，并对其做出相应操作，而不用对某一个类发的所有通知都进行更新操作。NSNotificationCenter对观察者的调用不是随机的，而是遵循注册顺序一一执行的，并且在该线程内是同步的 自定义实现通知方法： 通知的原理 通知机制的核心是一个与线程关联的单例对象叫通知中心（NSNotificationCenter）。通知中心发送通知给观察者是同步的，也可以用通知队列（NSNotificationQueue）异步发送通知。
数据结构 通知是一个单例。
static NSNotificationCenter *default_center = nil; + (NSNotificationCenter*) defaultCenter { return default_center; } 通知中心NSNotificationCenter的单例类中存放着两个表，一个存储所有注册通知信息的表的结构体，一个保存单个注册信息的节点结构体。
typedef struct NCTbl { Observation *wildcard; // 添加观察者时既没有传入 NotificationName ，又没有传入object，就会加在这个链表上，它里边的观察者可以接收所有的系统通知 GSIMapTable nameless; // 添加观察者时没有传入 NotificationName 的表 GSIMapTable named; // 添加观察者时传入了 NotificationName 的表 } NCTable typedef struct Obs { id observer; // 观察者对象 SEL selector; // 方法信息 struct Obs *next; // 指向下一个节点 int retained; /* Retain count for structure. */ struct NCTbl *link; /* Pointer back to chunk table */ } Observation; 解释一下NCTbl中三个表的作用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbaf8d7501553c0bdc54b3109ead24dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167dfe1fa3627f46e365eb7c6e749e9e/" rel="bookmark">
			2024年高教社杯数学建模国赛C题超详细解题思路分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次国赛预测题目难度，选题人数如下所示
难度评估 A:B:C= 1.8:1.3:1
D:E=1.5:1
选题人数 A:B:C= 1:1.5:2.8
D:E=0.5:1.2
C题一直以来都是竞赛难度最低、选题人数最多的一道本科生选题，近三年C题的选题人数一直都是总参赛队伍的一半左右，2023年六万支参赛队伍，C题选题队数2.8万。今年初步预计应该也是在3万左右。基于如此多的选题人数，本次我们将给大家带来两个版本的解题思路【思路、模型、代码完全不同】，下面进行第一版本的思路介绍
近年来，国赛在任何题目的数据预处理环节都设置了5-15分不等的数据预处理分值，因此数据预处理是必须进行的环节。数据预处理不仅仅是异常值、缺失值的处理，数据整合、数据可视化、描述性分析均是数据预处理工作。对于本次，我们可以进行异常值处理、数据整合、数据可视化、描述性分析进行数据的呈现。
数据预处理 异常值检测：题目中存在极端异常的数据，例如无论是亩产量还是种植成本存在极端数据，无论该数据是否真实我们都需要进行说明，以确保数据真实。 数据可视化、描述性分析：我们可以对题目给出的数据进行初步分析，以便后续建模，例如我们可以进行一些数据的可视化工作。
求解思路：
使用线性规划或整数规划，通过优化算法求解各地块每年应种植的作物组合，以达到收益最大化的目标。
针对问题1(1)和问题1(2)的不同假设，分别优化种植策略，并填入相应的模板文件。
创新点与改进点：
在模型中引入种植密度的约束，确保实际操作中的田间管理合理性，这在标准线性规划问题中较为少见。
不仅优化单一年的收益，而是优化未来7年的种植方案，确保作物轮作和收益的长远稳定。
问题二：考虑不确定性的最优种植方案 问题二在问题一的基础上，引入了未来销售量、种植成本和产量的波动，进一步增加了问题的复杂性。
1. 不确定性因素的引入 不确定性建模： 销售量变化：假设销售量在±5%波动，小麦和玉米的销售量以5%-10%的年增长率变化。亩产量波动：每年由于气候等因素，作物产量会在±10%之间变化。种植成本增长：假设种植成本每年增长5%。价格变化：粮食类作物的价格基本稳定，而蔬菜价格每年增长5%左右，食用菌价格每年下降1%-5%。 模型调整： 建立一个随机规划模型或使用蒙特卡洛模拟，通过模拟销售量、产量、成本和价格的不确定性，进行多次情景分析，求得不确定条件下的最优种植方案。 具体来讲；
目标: 在引入不确定性因素（产量、价格、销售量和成本波动）的情况下，最大化期望收益。
期望收益最大化:
考虑作物
的销售量、产量和价格的不确定性，我们的目标是最大化期望收益:
问题三：农作物替代性和互补性分析 问题三要求在问题二的基础上，进一步考虑不同作物之间的替代性、互补性，以及销售量、价格和种植成本之间的相关性。
1. 引入作物之间的替代性和互补性 替代性和互补性分析： 可以通过协方差矩阵或者相关性系数来量化不同农作物之间的替代性和互补性。 替代性：例如某些豆类和谷物可能在市场上具有替代关系。互补性：例如某些作物轮作可能会提升土壤肥力，使其互补性增强。 模型调整： 在问题二的基础上，加入农作物的替代性和互补性约束。通过引入相关系数矩阵调整种植方案，使整体组合效益更高。 目标函数： 目标依然是收益最大化，但需要在作物选择上综合考虑它们之间的替代性和互补性，从而优化整个系统的收益。 求解方法： 采用多目标优化模型，在最大化收益的同时，最小化作物之间的替代冲突，增强互补性。可以使用多目标优化算法如遗传算法或基于Pareto前沿的优化方法。 创新点与改进点： 利用作物间的相互作用来优化种植组合，增加实际种植策略的复杂度和现实性。通过协方差矩阵的引入，使模型不仅是静态收益最大化，而是通过综合分析作物间的复杂关系，提高整体收益。 % MATLAB Code for Data Visualization
% Data for visualization (Example data from the table you provided)
crops = {'黄豆', '黑豆', '红豆', '绿豆', '爬豆'}; % 作物名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/167dfe1fa3627f46e365eb7c6e749e9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0661dbabf55ec1c236c9a6804124f1d2/" rel="bookmark">
			“Jmeter-InfluxDB-Grafana“常见错误有哪些如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见错误：
1.网络不同，检查网络IP是否写对，端口号有没有放开（Centos7端口号命令），防火墙是否关闭
firewall-cmd --add-port=3000/tcp --permanent firewall-cmd --add-port=3000/udp --permanent firewall-cmd --reload 2.Jmeter里面的influxDB地址里面的db=jmeter，和在influxdb里面创建的数据库需要保持一致
3.后端监听器里面measurement ，默认写成jmeter和grafana监控大屏模块相对应
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18184a8d16a1fa79c20f0c8df03ccdc0/" rel="bookmark">
			【2024数模国赛赛题思路公开】国赛B题思路丨附可运行代码丨无偿自提
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年国赛B题解题思路
问题 1: 抽样检测方案设计
【题目分析】
分析：
目标是设计一个高效的抽样检测方案，在尽量少的样本数量下，确保在高信度水平下做出正确的接受或拒收决策。需要处理两个不同的信度要求，这对样本量的计算提出了挑战。 思路：
贝叶斯抽样优化：可以使用贝叶斯方法结合贝叶斯抽样优化（Bayesian Optimization）来动态调整样本量，以达到所需的信度水平。通过将次品率建模为贝叶斯后验分布，可以逐步减少样本量，同时保证决策的可靠性。自适应序贯抽样：使用逐步抽样方法，根据初始样本的检测结果动态调整后续样本量，优化检测成本和时间。蒙特卡洛模拟：模拟大量的抽样检测场景，估计在不同样本量下达成信度要求的概率，找到最小样本量的解决方案。 【解题思路】
目标
设计一个抽样检测方案，以确定是否接受供应商提供的零配件，要求在尽可能少的检测次数下达到两个信度标准：
在 95% 信度下认定零配件次品率超过标称值（拒收）。在 90% 信度下认定零配件次品率不超过标称值（接收）。 建模过程
定义变量和假设 设次品率为p ，标称次品率为p0=0.10 （即10%）。抽样样本量为n ，检测出次品的数量为 x。我们需要对p 进行假设检验，并根据检验结果决定是否接受或拒收。 2. 抽样检测模型
根据二项分布，我们有 。检验假设： 原假设
备择假设（用于拒收的情况）
使用正态近似来简化问题，当 n较大时， 可近似为正态分布： 标准化后的检测统计量为： 3. 检验条件
我们设定显著性水平α 对应的信度为1-α 。对于拒收情况，信度为 95%，则 α=0.05。计算临界值：，其中为标准正态分布的逆函数。对于接收情况，信度为 90%，则 α=0.10。 4. 计算样本量n
拒收的决策规则：若 Z＞Z0.05，则拒收。结合样本量的计算公式，我们得到： 通过展开可以得到对 n 的不等式： 为简化计算，可以迭代求解n。 5. 智能优化算法引入
为了优化样本量 n，引入贝叶斯优化。贝叶斯优化是一种基于高斯过程（Gaussian Process）的黑箱优化方法，可以在不确定的环境下高效找到最优参数。步骤： 定义目标函数：最小化检测成本 ，其中 c 为单次检测成本。目标函数中包含信度约束，使用贝叶斯优化逐步逼近最优的 n。通过模拟不同的样本量 n，评估在95%和90%信度下的检测成功率，并调整 n 使得目标函数最小。 6. 贝叶斯优化流程
初始化样本集，随机选择 n0 的样本量进行检测，计算检测成本。使用高斯过程拟合当前的检测结果。通过高斯过程预测新的 n，并计算期望改进（Expected Improvement, EI）。选择使期望改进最大的 n 作为下一步的检测样本量。更新高斯过程模型，重复迭代，直到找到满足信度约束且成本最低的样本量n* 。 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18184a8d16a1fa79c20f0c8df03ccdc0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/4/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>