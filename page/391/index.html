<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fcf59a29b3028af3cb19a9143c2dc4e/" rel="bookmark">
			ROS2快速入门Python篇-版本梳理、环境搭建、源码架构介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. ROS2版本说明及资料获取1.1 ROS2版本更新记录1.2 ROS1/ROS2各版本资料位置 2. humble安装2.1 使用Binary方式安装与测试2.2 使用源码方式安装与测试2.2.1 源码下载2.2.2 源码编译2.2.3 运行测试 3. ROS架构体系3.1 主要模块及其功能的概述3.2 ros-core, ros-base，ros_desktop差异3.3 DDS介绍 1. ROS2版本说明及资料获取 1.1 ROS2版本更新记录 https://docs.ros.org/en/foxy/Releases.html
ROS1版本更新记录
https://wiki.ros.org/Distributions
1.2 ROS1/ROS2各版本资料位置 https://docs.ros.org/en/?C=M;O=D
本系列将使用humble来讲解Ros2的使用。
2. humble安装 两种方式: Binary安装和源码安装
2.1 使用Binary方式安装与测试 binary安装支持Ubuntu Linux Jammy (Ubuntu 22.04) 64-bit x86 and 64-bit ARM，所以如果你装的是Ubuntu22.04, 可以直接使用这种方式安装或者使用源码安装。
We currently support Ubuntu Linux Jammy (22.04) 64-bit x86 and 64-bit ARM.
安装与测试步骤参考：
https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html
2.2 使用源码方式安装与测试 如果是其他Linux系统，如树莓派4（Raspi OS基于Debian Bullseye），可以选择源码安装方式。
The current Debian-based target platforms for Humble Hawksbill are:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fcf59a29b3028af3cb19a9143c2dc4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27c654fcf1dda4d758adc006cd48226/" rel="bookmark">
			大数据机器学习：常见模型评估指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据机器学习：常见模型评估指标 一.模型评估综述 1.1 什么是模型评估 模型评估是指在机器学习中，对于一个具体方法输出的最终模型，使用一些指标和方法来评估它的泛化能力。这一步通常在模型训练和模型选择之后，正式部署模型之前进行。模型评估不针对模型本身，而是针对问题和数据，因此可以用来评价不同方法的模型的泛化能力，以此决定最终模型的选择。
1.2 评估类型 机器学习的基本任务大致分为三类，分别是分类(Classification)、回归(Regression)和聚类(Clustering)，在本文仅介绍分类的模型评估。
1.3 模型泛化能力 模型的泛化能力是机器学习的一个重要概念和指标。是指一个模型在训练集之外的未知数据上的表现能力，泛化能力强的模型能够正确学习到数据的普遍规律并将其运用到新的数据上从而做出准确的预测。
简单地说，当模型在训练样本上表现良好，并且能在新的数据样本上保持相同的表现，我们就可以说这个模型的泛化能力强。
1.4 过拟合与欠拟合 过拟合与欠拟合是机器学习中常见的两个概念，描述的是模型在训练数据和未知数据上表现的差异。下图中第一到第三的图分别是欠拟合、正好和过拟合三种状态。
1.4.1 过拟合 过拟合表现为在训练数据上表现优秀的那在新数据集上表现较差，通常是因为模型过于复杂，学习到了数据集中的细节和噪声而不是数据的真实分布，因而泛化能力差。
举个很经典的例子，当我们设计一个模型用于判断一个物品是否是树叶，而训练集中有几个样本的叶片边缘带有尖刺，模型作者希望他的模型能够符合贴近他的每一个样本，因而将带有“尖刺边缘”这一不是明显特征的特点纳入了参数中，这样一来，模型就能够完美贴合训练样本，但在应用时会发现模型容易钻牛角尖，会将不带尖刺边缘的样本排除，无法识别不带尖刺边缘的树叶，这就导致了模型的泛化能力差。
解决模型过拟合的问题，有以下几种方法：
增加数据量以提供更多信息，减少噪声的影响简化模型，减少模型参数的数量通过交叉验证评估模型的泛化能力 1.4.2欠拟合 欠拟合则与过拟合相反，由于模型过于简单，无法学习到数据的足够特征，无法正确捕捉数据的复杂性和变化，没有学习到数据的规律。这就导致模型不管是在训练样本还是未知样本上的表现都不佳。
常见的解决欠拟合的方法有：
增加模型的复杂度，如增加更多的特征或使用更复杂的模型收集更多的数据，提供更加丰富的信息给模型增加训练时间或者调整模型的超参数 二.常见的分类模型评估方式 2.1 混淆矩阵 混淆矩阵是分类模型巩固的一个重要工具，可以直观展示模型的预测结果和实际结果之间的关系，通常由以下四个部分构成：
真正类 (True Positives, TP): 模型正确地预测正类的数量。假负类 (False Negatives, FN): 模型错误地将正类预测为负类的数量。假正类 (False Positives, FP): 模型错误地将负类预测为正类的数量。真负类 (True Negatives, TN): 模型正确地预测负类的数量。 二元混淆矩阵格式如下：
分类器真实结果Positive（阳性）Negative（阴性）预测结果PositiveTPFPNegativeFNTN 多元分类矩阵格式如下：
分类器真实结果ABCD预测结果ATAFAFAFABFBTBFBFBCFCFCTCFCDFDFDFDTD 2.2 准确率（Accuracy） 准确率是指模型正确预测的样本总数占总样本总数的比例，其计算公式为：
[准确率 = \dfrac{TN+TF}{TN+FN+TP+FP} = \dfrac{T}{T+F} ]
2.3 精确率(Precision) 精确率的概念比较容易与准确率的概念混淆，准确率的目标是所有样本，计算的是所有分类正确样本占总样本的多少，而精确率是指在所有被模型预测为正类的样本中，实际为正类的样本的比例，关注的是被模型分为此类的数据中有多少是正确的。
当我们使用精确率（下使用Precision代替）作为考量时，优点是不容易出现假正类，但是，当precision值过高时，容易出现模型偏向某一类别的情况，因为此时模型会倾向于预测多数类别而忽略了少数类别的预测。
举一个例子，假设在一个疾病诊断问题中，疾病发生的实际情况（正类）非常罕见。如果模型仅仅通过预测大多数人都是健康的（负类）来提高Precision，那么它可能会忽略真正的病例，因为这些病例在数据中占比很小。这样的模型虽然精确度高，但其实用性非常有限，因为它未能有效识别和预测少数但重要的正类样本。
在混淆矩阵中，这表现为某一行的T除以本行上所有数字的和，如下列表格标注了颜色的A行就是红色的TA值除以TA加FA的和。
预测/实际ABCDA(\color{red}{TA})(\color{green}{FA})(\color{green}{FA})(\color{green}{FA})BFBTBFBFBCFCFCTCFCDFDFDFDTD 其公式为：
[Precision = \dfrac{TP}{TP+FP} ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27c654fcf1dda4d758adc006cd48226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433a10195cc35a58a6807ca4e2b77bdd/" rel="bookmark">
			【数据结构】：顺序表实战（通讯录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 数据结构（初阶）第一节：数据结构概论-CSDN博客
数据结构（初阶）第二节：顺序表-CSDN博客
本文将以C语言和顺序表实现通讯录基础管理，实现功能包括增、删、改、查等，在实现相关功能时需要用到在第二节中顺序表的相关内容，需要友友们掌握顺序表的相关内容以及函数的实现方式。
目录 前言 要用到的两个文件
正文
文件包含关系
Contact.h
Contast.c
头文件
菜单
初始化
销毁
添加
判断名字是否存在
删除
显示
修改
查找
测试文件test.c
要用到的两个文件 SeqList.h
//.h文件定义 #include "Contact.h"//头文件互相包含会报错 #include &lt;malloc.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; typedef peoInfo SLDataType; //定义顺序表 typedef struct SeqList { SLDataType* a;//数组 int size;//有效元素 int capacity;//容量 }SL; //初始化 void SLinit(SL* p1); //销毁 void SLdestory(SL* p1); //扩容 void SLcheckCapcity(SL* p1); //尾插 void SLpushBack(SL* p1, SLDataType x); //打印顺序表 void SLprint(SL* p1); //头插 void SLpushFront(SL* p1, SLDataType x); //尾删 void SLpopBack(SL* p1); //头删 void SLpopFront(SL* p1); //指定插入 void SLinsert(SL* p1, int pos, SLDataType x); //指定删除 void SLerase(SL* p1, int pos); //查询 //int SLfind(SL* p1, SLDataType x); SeqList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/433a10195cc35a58a6807ca4e2b77bdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e054e7cdfa992cc8285cd538ba59db/" rel="bookmark">
			Macos 13 用 xcode 15 调试 ios 17 .4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Macos13.6.6 ventura 如何使用xcode 15.2 日志调试真机 iphoneXR 最新系统 ios 17.4
版本准备:
xcode: Version 15.2 (15C500b)macos: 13.6.6 (22G630) ventura(从13.0升级上来的)手机iphoneXR OS 17.4 方案
官方xcode 和 macos系统关系: https://developer.apple.com/support/xcode
根据macos系统下载xcode版本 推荐15系列: https://xcodereleases.com/alpha.html
Xcode 15.2 Release
IOS 17后已经不支持 device support 最新的xcode包device support只是16.4, 需要启动xcode15后在单独运行17+的运行环境, 两种运行环境安装
https://github.com/alibaba/tidevice/issues/337
按照苹果社区官方人员的说法 https://developer.apple.com/forums/thread/730947 iOS 17 之后不再提供 device support 文件
3.默认xcode第一次打开后
在这个位置获取最新的ios 17+支持
由于这边最高支持17.2
安装完后需要去官网获取 17.4的dmg运行环境:
https://developer.apple.com/download/all/
iOS 17.4 Simulator Runtime
先下载红色的 iOS 17.4 Simulator Runtime.dmg
然后去安装该17.4环境即可:
选中需要安装17.4的xcode, 然后模拟第一次运行(不模拟的话需要手动点下载17.2的包在上一副xcode的设置图), 最后把刚下载的iOS 17.4 Simulator Runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e054e7cdfa992cc8285cd538ba59db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1d91fcc99c19889056c659fd895f2c/" rel="bookmark">
			LLaMA-Factory&#43;qwen多轮对话微调测评
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
训练的时间和效果
数据准备
数据样例
数据配置
环境搭建
模型微调训练
模型预测
运行成功的web UI
LLaMA-Factory地址：https://github.com/hiyouga/LLaMA-Factory/blob/main/README_zh.md
qwen地址：https://huggingface.co/Qwen/Qwen-7B-Chat/tree/main
训练的时间和效果 7580例对话数据，单卡A6000，显存45GB
{'train_runtime': 429687.6086, 'train_samples_per_second': 2.646, 'train_steps_per_second': 0.662, 'train_loss': 0.0977083860479767, 'epoch': 150.0} ***** train metrics ***** epoch = 150.0 train_loss = 0.0977 train_runtime = 4 days, 23:21:27.60 train_samples_per_second = 2.646 train_steps_per_second = 0.662 Figure saved at: /home/wangyp/Big_Model/llama_factory_sft300/training_loss.png 04/08/2024 18:26:00 - WARNING - llmtuner.extras.ploting - No metric eval_loss to plot. [INFO|modelcard.py:450] 2024-04-08 18:26:00,005 &gt;&gt; Dropping the following result as it does not have all the necessary fields: {'task': {'name': 'Causal Language Modeling', 'type': 'text-generation'}} 数据准备 数据样例 [ {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1d91fcc99c19889056c659fd895f2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1b47be47e6fc82baa036f7b2c28a95/" rel="bookmark">
			vue3面试题：2024 最新前端 Vue 3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		+ 父组件中绑定事件 ``` &lt;my-component v-on:close="handleComponentEvent" v-on:click="handleNativeClickEvent" /&gt; ``` + 子组件中声明自定义事件 ``` &lt;script&gt; export default { emits: ['close'] } &lt;/script&gt; ``` 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。
… 3、生命周期（vue2和vue3的生命周期对比）有哪些？ ​
vue2.x的生命周期
vue3.0的生命周期
​
1
Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：
beforeDestroy改名为 beforeUnmountdestroyed改名为 unmounted Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
beforeCreate===&gt;setup()created=======&gt;setup()beforeMount ===&gt;onBeforeMountmounted=======&gt;onMountedbeforeUpdate===&gt;onBeforeUpdateupdated =======&gt;onUpdatedbeforeUnmount ==&gt;onBeforeUnmountunmounted =====&gt;onUnmounted 4、Vue3.0中的响应式原理是什么？vue2的响应式原理是什么？ vue2.x的响应式 实现原理：
对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。 Object.defineProperty(data, 'count', { get () {}, set () {} }) 存在问题：
新增属性、删除属性, 界面不会更新。直接通过下标修改数组, 界面不会自动更新。 Vue3.0的响应式 实现原理:
通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。
通过Reflect（反射）: 对源对象的属性进行操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1b47be47e6fc82baa036f7b2c28a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d5a989bb3e7be0dc5710bcf93483c3/" rel="bookmark">
			Stable Diffusion AI绘画：绘画参数与原理全攻略参上！千万别错过！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础模型和外挂VAE模型
Ⅰ. 基本术语讲解 基础模型（大模型/底模型）：属于预调模型，它决定了AI图片的主要风格。
VAE模型：全称Variational auto enconder变分自编码器，它类似于图片生成后的滤镜。
“基础模型”和“外挂VAE模型”之间的区别：首先正常情况下，每个模型都是自带了一个VAE的，VAE虽然不是滤镜但可以把它们看做是一种类似于滤镜的效果。而在大模型内的VAE出现问题、损坏或者是我们不满意的情况下，才需要使用外部手动去进行VAE选择VAE权重。
下载方式：大模型和VAE的下载我们可以从下面这些网站进行下载，而在模型下载的时候需要留意其哈希值。因为有些模型可能名字不一样，但哈希值一样，这就意味着两者几乎没有区别。
【网站①】：https://huggingface.co/
【网站②】：https://civitai.com/
Ⅱ. 不同基础模型的区别： 如下图显示，左边的图是二次元风格，右边的图是写实风格，模型的不同决定了基础的图像样子。
不同基础模型的区别
Ⅲ. 不同外挂VAE模型的区别： 如下图显示，该张图片展示了是否外挂VAE的差别，可以看到在加载新的一个VAE模型后，图片变得清晰起来。
是否加载VAE模型的区别
我们往下看，下面的图片展示了不同VAE模型下的图片差别，可以清晰看见图片的展现效果都不一样，“滤镜”效果完全不同。
不同VAE之间的区别
【总结】：所以，选用不同的VAE模型在制图的过程中很有必要，具体选用哪个模型，小编建议是用XYZ Plot（做出如图1-3的效果）选出你最喜欢的那一个。
二、clip终止层数
（clip skip）
【参考文章】：
https://github.com/AUTOMATIC1111/stable-diffusion-webui/discussions/5674
大家想要深入理解 clip终止层数 需从Stable diffusion的原理入手，具体原理可以参考这两篇文章：
【SD原理性】：
https://openaccess.thecvf.com/content/CVPR2022/papers/Rombach_High-Resolution_Image_Synthesis_With_Latent_Diffusion_Models_CVPR_2022_paper.pdf
【SD解释性】：
https://stable-diffusion-art.com/how-stable-diffusion-work/
简单来说，我们可以将Stable diffusion理解为一个扩散模型（Stable：稳定的；diffusion：扩散），通过你所给的prompt词扩散出你想要的东西。
例如，当我们尝试生成一个人的插图时，会是这样的一个情况（当然，实际情况可能远比这个更复杂）：
Clip的原理图解
为什么是到12层呢？可能会有同学有所疑问，原因是因为在该版本的模型中，深度为12层。
而你想处理到那一层就是：
clip的终止层数（clipskip）
ClipSkip为1：处理到最后一层（即所有层）
ClipSkip为2：处理到倒数第二层（忽略最后一层）
ClipSkip为3：处理到倒数第三层（忽略最后和倒数第二层）
简而言之，随着剪辑跳过的增加，要处理的层数逐渐减少。结果就是详细信息被按顺序丢弃，没有反映的提示数量增加了。（一个词含有的意思很少，需要扩散来丰富）
再举一个比较具体的例子：
Prompt：masterpiece, best quality, 1girl, white hair, black skirt, purple eyes, full body, black dress.
不同clip skip的表现
可见ClipSkip值较小，生成含有丰富提示词的插图；ClipSkip的值较大，生成忽略提示词的插图。
三、提示词与预设样式存储
提示词与预设样式存储在网上都有很多资料，小编这里就不再赘述了，大家感兴趣可以去B站或者百度搜索一下。总之，提示词需要具有一定的指向性和有效性，同时注意权重的搭配，以及英文输入。
【权重改变格式】：
（）：一个括号的权重提升1.1倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d5a989bb3e7be0dc5710bcf93483c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e2dc6a615c19e88e98cf4f813ad8ff/" rel="bookmark">
			【Spring AI】05. 向量数据库-Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Redis什么是 Redis？Redis 向量搜索是什么？先决条件依赖项用法元数据过滤 Redis 本节将指导您设置RedisVectorStore，作为文档存储向量数据库，并执行相似性搜索。
什么是 Redis？ Redis 是一个开源（BSD 许可证），用作数据库、缓存、消息代理和流引擎的内存数据结构存储。Redis支持多种数据结构，包括字符串、哈希、列表、集合、带范围查询的有序集合、位图、hyperloglogs、地理空间索引和流。
Redis 向量搜索是什么？ Redis Search and Query 扩展了 Redis OSS 的核心功能，使您可以将 Redis 用作矢量数据库：
在哈希或 JSON 文档中存储向量和相关元数据检索向量执行向量搜索 先决条件 EmbeddingClient实例，来计算文档嵌入向量。有几种选项可用： Transformers Embedding- 在您的本地环境中计算嵌入向量。请按照 ONNX Transformers Embedding 说明操作。OpenAI Embedding- 使用 OpenAI 嵌入端点。您需要在 OpenAI 注册并在 API Keys 生成 api-key 令牌。您也可以使用Azure OpenAI Embedding。 一个 Redis Stack 实例
a. Redis Cloud (推荐)
b. Docker 镜像 redis/redis-stack:latest 依赖项 将这些依赖项添加到您的项目中：
Embedding Client boot starter ，用于计算嵌入。
Transformers Embedding（本地），并按照 ONNX Transformers 嵌入向量说明操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e2dc6a615c19e88e98cf4f813ad8ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc19045444fa16b0fde515f496ec63ad/" rel="bookmark">
			Python传递参数的5种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、位置传参
# 位置传递实例: def fun1(a,b,c): return a+b+c print(fun1(1,2,3)) 输出：
6
二、关键字传参
根据每个参数的名字写入函数参数
# 关键字传递 def fun2(a,b,c): return a+b+c print(fun2(1,c=3,b=2)) 输出：
6
三、参数默认值传参
给函数的输入参数设定一个默认值,如果该参数最终没有输入,则使用默认参数出入函数.
# 默认值传递 def fun3(a,b=2,c=3): return a+b+c print(fun3(a = 1)) 6
四、包裹传参
在定义函数时，我们有时候并不知道调用的时候会传递多少个参数。这时候，包裹（packing）位置参数或者包裹关键字参数来进行参数传递会非常有用。
def fun4(*name): print(type(name)) print(name) fun4([1,2,3]) fun4((1,2,3)) fun4(1,2,3) 在fun4的参数表中，所有的参数被name收集，根据位置合并成一个元祖（tuple），这就是包裹位置传递。
&lt;class ‘tuple’&gt;
([1, 2, 3],)
&lt;class ‘tuple’&gt;
((1, 2, 3),)
&lt;class ‘tuple’&gt;
(1, 2, 3)
五、解包裹传递
def func1(a,b=1,*c,**d): print(a,b,c,d) l = [3,4] dic = {'@':2,'#':3} func1(1,2,l,dic) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc19045444fa16b0fde515f496ec63ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3e6b0ec0d52dde943c6bf2a80c2931/" rel="bookmark">
			Stable Diffusion从入门到卸载，一站式服务为你的AI绘画保驾护航！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，目前正在学习研究Stable Diffusion，致力于用最为朴素直白的语言为你介绍AI绘画的相关知识。
花了很长的时间，终于整理好这份Stable Diffusion的教程，从入门的安装、本地部署到觉得疲惫，安装失败，想要卸载，里面的内容应有尽有。
今天主要为大家介绍一下Stable Diffusion的本地部署以及卸载方法，其他的内容后续会慢慢补上，教程制作不易，如有帮助，请点赞收藏，有任何问题也欢迎在评论区留言，看到了都会回复，谢谢支持。
话不多说，我们开始今天的正文。
1、Stable Diffusion简介 Stable Diffusion (稳定扩散) 是一个扩散模型，2022年8月由德国CompVis协同Stability AI和Runway发表论文，并且推出相关程序。
Stable Diffusion WebUI能够支持多系统使用，无论是Linux/Windows还是MacOS，现在都已支持使用。Stable Diffusion WebUI有着极为广泛的插件生态，能够实现远超Midjoruney/NovelAI的自由度和实用价值。
AUTOMATIC1111所开发的Stable Diffusion WebUI是目前使用最为广泛的AI图像生成开源软件，本文章将围绕Stable Diffusion WebUI展开相关内容的说明。
2、Stable Diffusion本地部署 Stable Diffusion的部署方法有很多，在此建议，有条件在电脑上本地部署，就尽量本地部署。
没条件，可以考虑云端部署，请在B站等地搜索相关教程学习部署。目前市面上的APP暂不推荐，很多是收费的，很多只有少量的免费时长。而且大多数APP不具备完整的功能，不适合系统性的学习和进步。
此处我只介绍最简单的一种，这也是绝大多数人推荐的一种方法，对于新手玩家极为友好。
2.1 硬件需求 显卡：为达到良好的体验，请尽可能使用8GB显存及以上显卡。低显存虽然能跑，但是体验极差
内存：8GB以上
存储空间：最小20GB
操作系统：因为本人是在Windows系统下进行的，对于Mac系统和Linux系统不太了解，故而下面的内容只涉及Windows系统的操作。
上面简单的介绍了一下最低需求，按理来说，只要达到了这些需求，那么Stable Diffusion都能在你的设备上跑起来。
但是这只是一种理想情况，能玩和能玩得爽是两个概念，如果你出一张最简单的图需要十几二十分钟，那么你将毫无游戏体验。
从这个角度而言，电脑配置越好越好，配置越高，越能随心所欲地出图。
2.2 整合包部署 如果你是从零开始，这里推荐B站大佬秋葉aaaki一键包和启动器，可以看到文章末尾去下载。
2.3 运行WebUI 现在你已经将安装包下载好了，将下面的sd-webui-aki-v4.2解压缩，运行启动器运行依赖-dotnet-6.0.11这个文件：
​
然后打开sd-webui-aki文件，找到下面的A启动器，点击运行：
​
第一次运行的时候可能比较慢，不要着急，耐心等待几分钟，然后如果出现下面的这个界面，那么说明你基本上部署成功了。
​
为了测试是否真的成功，我们需要亲自跑一张图，点击上方图片中右下角的一键启动，然后会出现下面这个界面，我们不用管，等待运行，第一次一般都不是那么流畅，耐心一点，别急：
​
然后经过等待，我们就到了这个界面，我们尝试跑一张图，看能不能跑出来：
​
如上图，我只是简单的输入了一个正面提示词，其他的都默认，没有管，点击右上角的生成，运行跑图：
​
可以看到，它成功的生成了一张图片，到此为止，那么你Stable Diffusion本地部署就已经成功了，请尽情玩耍吧。
​
至此，Stable Diffusion本地部署已经完成，后面所有的更高级的操作都是基于此框架进行，这部分的内容我们后面慢慢聊。
3、彻底卸载Stable Diffusion WebUI 在经历长时间的安装部署失败、或者是长时间的跑图后，你终于对Stable Diffusion 无感，以前下载的软件又占用空间，如何彻底的删除呢？
我们贴心的为你准备了下面的卸载指南，任君采撷！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3e6b0ec0d52dde943c6bf2a80c2931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc646c4fd2ee5b8a01af8db6e30fc5d3/" rel="bookmark">
			Stable Diffusion基础：ControlNet之线稿成图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天继续给大家分享Stable Diffusiion的基础能力：ControlNet之线稿成图。
所谓线稿就是由一条条的线段组成的图形，主要用于绘画和设计领域的打底稿、表达构想和预见最终效果。
所谓线稿成图就是利用 Stable Diffusion + ControlNet 的能力，依照线稿中的图形设计生成创意图片。借助ControlNet，我们可以直接使用线稿图生成图片，也可以先从其它图片中提取线稿，然后再生成图片。
下面我将介绍ControlNet中四个优秀的线稿模型，以及它们的使用方法和注意事项。
安装ControlNet 工欲善其事必先利其器，ControlNet 还是先要安装好的，已经安装好的请跳过这一步。
使用方法 Canny 基于精细的边缘检测，准确还原图片的结构和特征。Canny边缘图中的线条没有粗细、深浅的区分。
因为是真人图片，所以这里选择了一个现实视觉的大模型：realisticVisionV51，提示词可以手写，也可以找个反推工具反推。
如果是生成真人图片，建议把“面部修复”勾选上。
ControlNet的设置是重点：
1、展开ControlNet控制面板。
2、在Unit 0中上传一张需要提取边缘的图片。
3、勾选“启用”，启用当前ControlNet Unit。
4、勾选“完美匹配像素”，自动设置预处理器的分辨率。
5、勾选“允许预览”，这样就可以预览边缘检测的效果。
6、选择“Canny”
7、预处理器和模型会自动加载，暂时不更改它们。
预处理器可以检测图片中人物和物体的边缘，绘制出边缘图。点击预处理器后边的星火图标可以在预览区看到预处理的效果图。
预处理器器还有两个选项：
无：不使用预处理器，直接在ControlNet中上传一张线稿图。颜色反转：ControlNet中能够处理的线稿图需要线条是白色， 其它区域是黑色，这和现实中的线图颜色是相反的。所以通过这个预处理器，我们可以直接反转一张现实世界的线稿图，供ControlNet模型进行生图处理。不适合普通的彩色图片。 8、控制权重：ControlNet模型在生成图片时的权重，降低这个权重，线稿对绘图的约束就会变弱。
启动控制的步数：Canny介入的时机。介入时机越早，越能保证构图依照边缘图，一般从0开始。
结束控制的步数：Canny退出的时机。退出时机越晚，细节保留程度越大，如果要多变换一些细节，可以提前退出。
9、这两个阈值是canny预处理器提取线稿图时使用的，通过调整阈值可以控制边缘图中保留细节的多少。
Canny Low Threshold：去掉过细的线段。大于低阈值的线段被认定为边缘。
Canny High Threshold：去掉零散的线段。大于高阈值的线段被认定为强边缘，全部保留；高阈值和低阈值之间的线段认定为弱边缘，只保留强边缘相邻的弱边缘。
10、控制模式：ControlNet的通用设置，以提示词为主，还是以ControlNet模型为主。
11、缩放模式：ControlNet的通用设置，参考图与要生成的图片尺寸不一致时如何处理。拉伸有变形的问题，一般使用裁剪和填充。
Lineart 使用线条艺术生成训练，通常用于黑线白底图的上色，也可以从各种图片中提取线条，然后再生成图片。
Lineart的线条有粗细深浅的区别，相比Canny，除了能够控制构图，还可以更好的还原图片深度。
下图的几个设置和上面Canny控制器的设置差不多，只是上传的图片换成了一张黑白线稿图。
重点看下这几个设置：
Lineart：线稿控制网络。
预处理器：从图片提取线稿图的处理器。这里有多个预处理器，简单介绍下：
none：不使用预处理器，需要直接上传一张处理好白线黑景线稿图。lineart_anime：适合从动漫图片中提取线稿图。lineart_anime_denoise：适合从动漫图片中提取线稿图，并去掉噪音点。lineart_coarse：从图片中粗略提取线稿图，忽略不突出的细节，生图时自由度更高。lineart_realistic：从真实视觉的图片中提取线稿图。lineart_standard：从图片提取线稿图的标准版处理器。颜色反转：反色图片，适合从白色背景、黑色线条的图片中提取线稿图。 模型：根据线稿图生成图片的ControlNet模型。
control_v11p_sd15_lineart_fp16：通用线稿图生成模型。control_v11p_sd15s2_lineart_anime_fp16：二次元线稿图生成模型。 SoftEdge 使用软边缘图像生成训练，平滑的边缘、更好的深度，忽略内部细节，方便创作更具绘画特征或艺术风格的图片。
相比Canny、Lineart，SoftEdge除了稳定构图，更好的图片深度控制，还拥有了更多的自由度。
重点看下ControlNet的这几个设置：
预处理器：从图片中提取软边缘图。
softedge_hed：合成柔边图。
softedge_hedsafe：安全的合成柔边图，边缘更清晰，稳定性更高。
softedge_pidinet：简笔柔边图，描绘的细节更少，出图的细节更自由，姿势更稳定。
softedge_pidinet：安全的简笔柔边图，边缘更清晰，稳定性更高。
模型：control_v11p_sd15_softedge_fp16，参与生成图片的软边缘模型，只有这一个。
Scribble 这是一个称之为涂鸦成图的ControlNet，生成图片的自由度更高。
丁老头大家都画过吧，我这里把它生成一个毛绒玩具的图片。
注意这几个参数：
预处理器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc646c4fd2ee5b8a01af8db6e30fc5d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc608e5263ff2297f91d9f399984a8f6/" rel="bookmark">
			扩展阅读-穿越Redis单线程迷雾：从面试场景到技术内核的解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
前言
Redis中的多线程
I/O多线程
Redis中的多进程
结论
延伸阅读
前言 很多人都遇到过这么一道面试题：Redis是单线程还是多线程？这个问题既简单又复杂。说他简单是因为大多数人都知道Redis是单线程，说复杂是因为这个答案其实并不准确。
难道Redis不是单线程？我们启动一个Redis实例，验证一下就知道了。Redis安装部署方式如下所示：
// 下载 wget https://download.redis.io/redis-stable.tar.gz tar -xzvf redis-stable.tar.gz // 编译安装 cd redis-stable make // 验证是否安装成功 ./src/redis-server -v Redis server v=7.2.4 接下来启动Redis实例，使用命令ps查看所有线程，如下所示：
// 启动Redis实例 ./src/redis-server ./redis.conf // 查看实例进程ID ps aux | grep redis root 385806 0.0 0.0 245472 11200 pts/2 Sl+ 17:32 0:00 ./src/redis-server 127.0.0.1:6379 // 查看所有线程 ps -L -p 385806 PID LWP TTY TIME CMD 385806 385806 pts/2 00:00:00 redis-server 385806 385809 pts/2 00:00:00 bio_close_file 385806 385810 pts/2 00:00:00 bio_aof 385806 385811 pts/2 00:00:00 bio_lazy_free 385806 385812 pts/2 00:00:00 jemalloc_bg_thd 385806 385813 pts/2 00:00:00 jemalloc_bg_thd 竟然有6个线程！不是说Redis是单线程吗？怎么会有这么多线程呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc608e5263ff2297f91d9f399984a8f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb05d93ff7b504978170ffb45adc84ca/" rel="bookmark">
			苹果电脑如何轻松抹掉NTFS格式磁盘 如何将Mac系统下硬盘格式化为NTFS Mac硬盘格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在苹果电脑的操作系统下，对于磁盘格式的转换基本是每个电脑使用者都会进行的操作，一般是为了使磁盘更好地在电脑上存储文件。
NTFS（New Technology File System）是一种Windows系统常用的文件系统，而Mac电脑则默认使用HFS+或APFS文件系统。因此，为了在Mac电脑上读写NTFS格式的磁盘，我们需要使用第三方的磁盘管理工具，如Tuxera NTFS for Mac。
Tuxera NTFS for Mac是一款功能强大的磁盘管理工具，可以帮助我们轻松管理NTFS格式的磁盘。其中，抹掉NTFS格式磁盘是其常用功能之一。下面，我们将详细介绍如何在Mac电脑上使用Tuxera NTFS软件抹掉NTFS格式磁盘的步骤。
苹果电脑如何轻松抹掉NTFS格式磁盘 一、安装Tuxera NTFS for Mac
首先，我们需要在Mac电脑上安装Tuxera NTFS for Mac软件。安装完成后，打开Tuxera NTFS for Mac软件，你将看到其主界面。
Tuxera NTFS for Mac 2023安装包免费体验：https://souurl.cn/IE35lO
二、选择需要抹掉的NTFS磁盘
在Tuxera NTFS for Mac的主界面中，你将看到当前电脑连接的所有磁盘信息。找到你需要抹掉的NTFS磁盘，并确认其图标上标注有红色“T”图案，同时在其右侧的信息窗口中也能看到其NTFS格式信息。确认选中的磁盘为目标格式化（即需抹掉）的NTFS磁盘。
三、开始抹掉NTFS磁盘
确认选中的磁盘为目标格式化（即需抹掉）的NTFS磁盘后，单击顶部的“格式”按钮。在弹出的格式化窗口中，你可以选择所需的文件系统格式，如Mac OS扩展（日志式）、MS-DOS（FAT32）等。选择完成后，点击“格式”按钮，开始格式化NTFS磁盘。
四、等待格式化完成
在格式化过程中，请保持电脑和磁盘的连接稳定，并耐心等待格式化完成。格式化完成后，你将看到一个全新的、符合所选文件系统的磁盘出现在Tuxera NTFS for Mac的主界面中。
五、验证格式化结果
最后，为了验证格式化结果，你可以尝试在Mac电脑上读写该磁盘，确保磁盘能够正常工作。同时，也可以在磁盘工具中查看该磁盘的信息，确认其文件系统格式已经成功转换为所选格式。
通过以上步骤，你就可以在Mac电脑上轻松抹掉NTFS格式磁盘了。需要注意的是，在进行磁盘格式化操作时，一定要谨慎选择目标磁盘，以免误操作导致数据丢失。此外，为了确保磁盘的稳定性和兼容性，建议在选择文件系统格式时参考苹果电脑的官方推荐。
Tuxera NTFS for Mac如何进行格式转换 1、在Mac上安装Tuxera NTFS for Mac软件，并且从系统偏好设置中打开这款软件的操作界面。
2、进入【卷】选项界面，点击下方“Disk Manager”按钮打开Tuxera Disk Manager操作界面，这项功能是专门用来进行磁盘管理的，点击至【格式】选项界面。
图1：格式选项
3、将硬盘插入Mac电脑中，此时硬盘会显示在界面的左侧，选中它。
4、点击“文件系统”下拉框选择NTFS文件系统，或者若你想要转化成其他文件系统也可选择。
图2：选择文件系统
5、选择好文件系统之后，直接点击“格式化”按钮进行操作即可。同时也可以设置卷的名称。
图3：格式化硬盘
这样简单的几个步骤就可以将一个硬盘的格式成功转换成NTFS格式的了。
若你在Mac上使用硬盘时遇到Mac不能正常显示移动硬盘的情况，也可以通过这项功能进行解决，所以这款软件的实用性是非常大的。
Tuxera NTFS for Mac 2023中文网站限时优惠码领取入口：https://souurl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb05d93ff7b504978170ffb45adc84ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a3aceb2e2be307499c0ebeb7f4a37c/" rel="bookmark">
			AI大模型探索之路-训练篇7：大语言模型Transformer库之HuggingFace介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-训练篇1：大语言模型微调基础认知
AI大模型探索之路-训练篇2：大语言模型预训练基础认知
AI大模型探索之路-训练篇3：大语言模型全景解读
AI大模型探索之路-训练篇4：大语言模型训练数据集概览
AI大模型探索之路-训练篇5：大语言模型预训练数据准备-词元化
AI大模型探索之路-训练篇6：大语言模型预训练数据准备-预处理
目录 系列篇章💥一、HuggingFace介绍二、HuggingFace核心模块之Models1、Multimodal（多模态大模型）2、Computer Vision（计算机视觉任务）3、Natural Language Processing（自然语言处理）4、Audio（音频模型）5、其他模型 三、HuggingFace核心模块之datasets四、HuggingFace核心模块之docs五、HuggingFace组件使用代码样例 一、HuggingFace介绍 在HuggingFace的官方网站上，你可以发现一个丰富的开源宝库，其中包含了众多机器学习爱好者上传的精选模型，供大家学习和应用。此外，你也可以将自己的模型分享至社区，与他人共同进步。HuggingFace因其开放和协作的精神被誉为机器学习界的GitHub。在这里，用户能够轻松获取到Transformers库里各式各样的组件资源，助力各类机器学习项目的实现和发展。
1）HuggingFace的核心库是Transformers，这个库集成了各种预训练模型、分词器和相应的工具。通过这个库，用户可以方便地加载和使用这些模型，进行文本分类、命名实体识别、情感分析等任务。
2）HuggingFace还提供了许多微调模型，这些模型针对特定任务进行了优化。用户可以直接使用这些模型，或者在其基础上进一步微调，以适应特定的应用场景。
3）HuggingFace的datasets库汇集了大量多样化的数据集资源，这为训练和评估AI大模型提供了便利。用户可以通过这个库轻松地下载和使用各种数据集，无需自己收集和整理数据。
总的来说，HuggingFace为AI大模型的学习提供了强大的支持，使得从数据准备到模型训练和部署的整个过程变得更加简单和高效。
下面主要说明介绍平时AI大模型开发过程中经常使用到的三个菜单模块。
二、HuggingFace核心模块之Models Models模块提供有各种类型的大模型，可以远程拉取或者下载到本地进行机器学习使用。
1、Multimodal（多模态大模型） 1）Image-Text-to-Text（图文转文本）：能够处理图像和文本输入，并生成相关文本输出的多模态模型
2）Visual Question Answering（视觉问答）：能够回答关于所提供图像的问题，这需要模型同时理解图像内容和问题文本。
3）Document Question Answering（文档问答）：是一种基于自然语言处理技术，用于分析和理解文档内容以回答用户提出的问题的系统。
2、Computer Vision（计算机视觉任务） 1）lmage Classification（图像分类）：此任务的目标是将图像分配到预定义的类别中，例如区分图片中是猫还是狗。这通常涉及到识别图像中的全局特征，并使用这些特征来预测所属类别。
2）lmage Segmentation（图像分割）：在图像分割中，目标是将图像划分成多个区域或对象。这些区域通常对应于图像中的不同物体或场景的不同部分，例如将一幅风景画中的树木、天空和草地区分开来。
3）Image-to-Text（图像到文本的任务）：该任务的目的是描述或解释给定的图像内容，通常用于自动图像标注或辅助视觉障碍人士理解图片。
4）lmage-to-Image（图像到图像的任务）：涉及将输入图像转换为具有特定风格或内容的输出图像，同时保留其识别特征。这包括风格转换、图像修复、图像上色等。
5）lmage-to-Video（图像到视频的任务）：这个领域不如其他计算机视觉任务那么发达，但它涉及到从单一图像创建视频序列，通常需要结合深度学习和视频处理技术。
6）zero-Shot lmage Classification（零样本图像分类）：这是一种特殊类型的图像分类，其中模型需要识别它未见过类的图像。它依赖于模型对类别之间关系的理解，以及利用未见类别的语义属性进行分类。
7）Unconditional lmage Generation（无条件图像生成）：在此任务中，系统生成全新的图像，而不是基于现有图像。这通常是通过学习大量图像数据集的分布来实现的。
8）Object Detection(目标检测)：与图像分类不同，目标检测不仅需要识别图像中的对象是什么，还要确定它们在图像中的位置。这通常涉及到定位对象的边界框。
9）Video Classification（视频分类）：类似于图像分类，但在处理视频时，需要考虑时间维度，识别视频中的动作或者活动类型。
10）**Depth Estimation(深度估计，估计拍摄者距离图像各处的距离) **：这个任务旨在估计图像中每个像素的深度值，从而可以推断出场景中各个对象与观察者之间的距离。
3、Natural Language Processing（自然语言处理） 1）Translation (机器翻译):机器翻译模型能够将一种语言的文本自动翻译成另一种语言。这通常涉及到复杂的算法和大规模的双语数据集来训练模型，以便它能够理解上下文并产生流畅、准确的翻译。
2）Fill-Mask (填充掩码，预测句子中被遮掩的词):在预训练语言模型如BERT时常用的任务，其中句子中的一部分单词被掩码遮盖，模型的目标是预测被遮盖的单词。这有助于模型学习双向语境表示。
3）Token Classification (词分类):这种模型对输入文本中的每个单词或标记进行分类，通常用于命名实体识别、情感分析等任务，可以给每个词赋予一个或多个类别标签。
4）Sentence Similarity (句子相似度): 句子相似度模型旨在评估两个句子之间的语义相似程度。它们广泛用于信息检索、自然语言推理等领域。
5）Question Answering (问答系统):问答系统能够回答自然语言形式的问题。这通常需要理解问题的语义，并在给定的数据源中查找或生成答案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9a3aceb2e2be307499c0ebeb7f4a37c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/472daaaae9d2319e01713d497a08be60/" rel="bookmark">
			【Mac】Photoshop 2024 for mac最新安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件介绍 Photoshop 2024是Adobe公司推出的一款图像处理软件，它支持Windows和Mac OS系统。Adobe Photoshop是业界领先的图像编辑和处理软件之一，广泛用于设计、摄影、数字绘画等领域。
Photoshop 2024的功能包括：
1.图像编辑：提供了丰富的编辑工具，包括裁剪、调整色彩、修复瑕疵、添加滤镜等，可以对图像进行各种编辑操作。
2.图层功能：支持多图层编辑，用户可以对不同图层进行独立编辑和控制，实现更复杂的图像合成和编辑效果。
3.文本编辑：提供强大的文本编辑工具，支持添加、编辑和格式化文本，用户可以创建各种样式的文字效果。
4.绘画和绘图工具：包括画笔、铅笔、橡皮擦等绘图工具，支持绘制和编辑矢量图形和位图图像。
5.3D 功能：支持创建、编辑和渲染 3D 图像和模型，可以制作各种立体效果的图像和设计。
6.自动化和批处理：提供自动化和批处理工具，可以简化重复性任务，提高工作效率。
7.云服务集成：与 Adobe Creative Cloud 云服务集成，用户可以轻松访问和分享他们的项目和资源。
Photoshop 2024带来了许多新功能和改进，以满足用户不断变化的需求，提供更强大、更高效的图像处理和编辑工具。
安装教程 安装 PS2024 前，电脑上必须先安装 ACC，ACC安装教程参考：https://mac.shuiche.cc/info/252
1.打开安装包。
2.选中脚本_1，鼠标右键点击，选择「打开」。
3.输入自己电脑的开机密码，输入密码时，密码是看不见的
4.运行 PS2024安装包安装PS。
5.接着运行。
6.点击继续。
7.点击继续。
8.选择「Photoshop v25.6+」，点击安装。
这时候软件就激活成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6ba0db48730e52c6b0a9a17c316dbf/" rel="bookmark">
			Python八大主要应用领域，你都知道吗？_python的应用领域有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2、网络爬虫 多亏有了Python，一个小白用几行代码就可以写个爬虫爬段子爬福利图了。然而爬虫的真正作用是从网络上获取有用的数据或信息，可以节省大量人工时间。能够编写网络爬虫的编程语言有不少，但Python绝对是其中的主流之一。Python自带的urllib库，第三方的requests库和Scrappy框架让开发爬虫变得非常容易。
3、计算与数据分析 随着NumPy，SciPy，Matplotlib等众多程序库的开发和完善，Python越来越适合于做科学计算和数据分析了。它不仅支持各种数学运算，还可以绘制高质量的2D和3D图像。和科学计算领域最流行的商业软件Matlab相比，Python比Matlab所采用的脚本语言的应用范围更广泛，可以处理更多类型的文件和数据。
4、人工智能 当前最热工资最高的IT工作就是从事人工智能领域的工程师了。Python在人工智能大范畴领域内的机器学习、神经网络、深度学习等方面都是主流的编程语言，得到广泛的支持和应用。最流行的神经网络框架如Facebook的PyTorch和Google的TensorFlow都采用了Python语言。你不学Python,你会用那些框架吗?
5、自动化运维 这几乎是Python应用的自留地，作为运维工程师首选的编程语言。在很多操作系统里，Python是标准的系统组件。大多数Linux发行版和MacOSX都集成了Python，可以在终端下直接运行Python。Python标准库包含了多个调用操作系统功能的库。通过pywin32这个第三方软件包，Python能够访问Windows的COM服务及其它WindowsAPI。使用IronPython，Python程序能够直接调用.NetFramework。一般说来，Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。
6、云计算 Python的最强大之处在于模块化和灵活性，而构建云计算的平台的IasS服务的OpenStack就是采用Python的，云计算的其他服务也都是在IasS服务之上的。
7、网络编程 Python提供了丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。很多大规模软件开发计划例如Zope，Mnet, BitTorrent和Google都在广泛地使用它。
8、游戏开发 很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小，然而Python则支持更多的特性和数据类型。Python的PyGame库也可用于直接开发一些简单游戏。
以上就是Python八大主要应用领域，你都知道吗？总之，Python是一门新手友好、功能强大、高效灵活的编程语言，学会之后无论是想进入数据分析、人工智能、网站开发这些领域，还是希望掌握第一门编程语言，都可以用Python来开启未来无限可能！
读者福利 小编是一名Python开发工程师，自己整理了一套最新的Python系统学习教程，包括从基础的python脚本到web开发、爬虫、数据分析、数据可视化、机器学习等。如果你也喜欢编程，想通过学习Python转行、做副业或者提升工作效率，这份**【最新全套Python学习资料】** 一定对你有用！
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的！
1、学习时间相对较短，学习内容更全面更集中
2、可以找到适合自己的学习方案
我已经上传至CSDN官方，如果需要可以扫描下方二维码都可以免费获取【保证100%免费】
一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python课程视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
三、精品书籍 书籍的好处就在于权威和体系健全，刚开始学习的时候你可以只看视频或者听某个人讲课，但等你学完之后，你觉得你掌握了，这时候建议还是得去看一下书籍，看权威技术书籍也是每个程序员必经之路。
四、清华编程大佬出品《漫画看学Python》 文末有福利领取哦~ 👉一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
👉二、Python必备开发工具
👉三、Python视频合集
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉 四、实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。（文末领读者福利）
👉五、Python练习题
检查学习结果。
👉六、面试资料
我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
👉因篇幅有限，仅展示部分资料，这份完整版的Python全套学习资料已经上传
网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化学习资料的朋友，可以戳这里无偿获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79a7d5b042684ee6dfdff3c999227d2/" rel="bookmark">
			数据库时间类型之间的转换魔法_sql 字符串强制转换成时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT TO_DATE(timestamp_column, 'YYYY-MM-DD HH24:MI:SS') AS converted_date FROM your_table; 日期转为时间戳： SELECT TO_CHAR(date_column, 'YYYY-MM-DD HH24:MI:SS') AS converted_timestamp FROM your_table; 1.3 SQL Server 时间戳转为日期： SELECT CONVERT(DATE, DATEADD(SECOND, timestamp_column, '19700101')) AS converted_date FROM your_table; 日期转为时间戳： SELECT DATEDIFF(SECOND, '19700101', date_column) AS converted_timestamp FROM your_table; 1.4 PostgreSQL 时间戳转为日期： SELECT TO_TIMESTAMP(timestamp_column) AS converted_date FROM your_table; 日期转为时间戳： SELECT EXTRACT(EPOCH FROM date_column) AS converted_timestamp FROM your_table; 1.5 Spark SQL 时间戳转为日期： SELECT FROM_UNIXTIME(timestamp_column) AS converted_date FROM your_table; 日期转为时间戳： SELECT UNIX_TIMESTAMP(date_column) AS converted_timestamp FROM your_table; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79a7d5b042684ee6dfdff3c999227d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917cf3e84cfe9bba35789428e7a28246/" rel="bookmark">
			Warning: apt-key is deprecated. Manage keyring files in trusted.gpg.d instead (see apt-key(8))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		root@diao-Inspiron-5557:/home/diao# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - Warning: apt-key is deprecated. Manage keyring files in trusted.gpg.d instead (see apt-key(8)). curl: (35) error:0A000126:SSL routines::unexpected eof while reading gpg: 找不到有效的 OpenPGP 数据。 使用 apt-key add 命令向 Ubuntu 系统添加 Docker 官方 GPG 密钥时遇到了问题。这个问题可能是由于 apt-key 已经被标记为弃用，因此系统给出了警告信息。此外，curl 命令在下载 GPG 密钥时遇到了 SSL 读取错误。
为了解决这个问题，您可以尝试使用新的方式来添加 GPG 密钥到 Ubuntu 系统中。可以按照以下步骤操作：
首先，下载 Docker 官方 GPG 密钥到本地文件中：
curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o docker_gpg 接下来，将下载的 GPG 密钥添加到系统的 keyring 文件夹中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/917cf3e84cfe9bba35789428e7a28246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4295e3b9c217f1ac99852803a99bdda2/" rel="bookmark">
			国密算法SM2/3/4简单比较，以及基于Java的SM4（ECB模式，CBC模式）对称加解密实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的国密算法包含SM2，SM3，SM4。以下针对每个算法使用场景进行说明以比较其差异
SM2：非对称加密算法，可以替代RSA 数字签名，SM2为非对称加密，加解密使用一对私钥和公钥，只有签名发行者拥有私钥，可用于加密，其他需要验证解密或验签者使用公钥进行。如果使用公钥可以成功解密，则可以确定数据、文档或其他数字资产的拥有者。因性能问题，根据实际需要常用于小体积数据加密，例如对密钥或SM3生成的hash进行加密。针对SM3生成的hash值进行加密也是一种常用的签名方式，一般先对需要签名的数据、文档或数字资产使用SM3生成hash再用SM2进行签名。 注：
如果用于加密，那么加密是用公钥进行的，解密是用私钥进行的。
如果用于数字签名，那么签名是用私钥进行的，验证签名则使用公钥。
SM3：散列哈希算法 数据库中用户密码的保存，获取用户输入明文密码后，进行SM3生成hash值，再与数据库中保存的已经过SM3计算后的密码值进行比对。数据完整性验证，针对数据、文件或数据资产进行SM3生成hash并保存，在需要验证数据是否被修改时重新生成hash并与之前保存的hash值进行比对，一旦文件有被修改则会生成不同的hash值。例如可以针对数据库中关键数据字段进行hash，并保存。然后可以通过遍历定期验证hash是否一致，来发现被篡改的数据。SM4：对称加密算法，性能比SM2好 可以用于一般数据的加密与解密，例如可以在需要网络传输的数据发送前进行加密，对方收到数据后使用相同密钥进行解密获得明文。 基于Java的SM4（ECB模式，CBC模式）对称加解密实现
简单说明：加密算法依赖了groupId:org.bouncycastle中的bcprov-jdk15to18，Bouncy Castle (bcprov-jdk15to18)提供了JDK 1.5 to 1.8可使用的大量标准加密算法实现，其中包含了SM2，SM3，SM4。在这个类库基础上实现了一个SM4Util加解密工具类。注意： 此版本我在JDK1.8环境下，不同版本JDK需要找到匹配的依赖版本1.8及以上可以使用bcprov-jdk18on。Bouncy Castle同时也提供了bcutil-jdk15to18可以实现SM4加解密。
方式一：依赖bcprov-jdk15to18（以ECB模式为例） 注如果用jdk1.8的话使用bcprov-jdk18on比bcprov-jdk15to18的加密性能要好。
&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15to18&lt;/artifactId&gt; &lt;version&gt;1.77&lt;/version&gt; &lt;/dependency&gt; 字节数组处理工具类： public class ByteUtils { private static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private ByteUtils() { // Utility class } public static byte[] fromHexString(String s) { int len = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4295e3b9c217f1ac99852803a99bdda2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af482ce5cf42a2552d5563ccdfffd64a/" rel="bookmark">
			常用浏览器禁用JavaScript方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用浏览器禁用JavaScript方法 在安全测时有一些验证逻辑是在前端进行验证的，我们就可以通过浏览器禁用JavaScript来绕过这些验证，下面是几款常用浏览器禁用JavaScript的方法
Edge
打开 Edge 浏览器，并在地址栏中输入 about:flags ，然后按 Enter 键，进入 Edge 的实验性功能页面。
在实验性功能页面中，找到 “JavaScript” 选项，并选择 “Disabled” 选项。
关闭 Edge 浏览器，并重新打开它。
在 Edge 浏览器中，单击地址栏右侧的三个点按钮，然后选择 “设置” 选项。
在设置页面中，选择 “Privacy, search, and services” 选项。
在隐私设置页面中，找到 “Cookies and site permissions” 选项，并单击它。
在 “Cookies and site permissions” 页面中，找到 “JavaScript” 选项，并选择 “Block” 选项。
禁用 JavaScript 后，您可以重新加载网页，JavaScript 将不再运行。
Chrome
地址栏输入： chrome://settings/content/javascript 然后找到JavaScript选择进行禁用即可 Firefox
地址栏输入：about:config找到 javascript.enabled 将其转换为false IE
先打开IE浏览器，点击右上角的 工具点击 Internet选项点击 安全 选项卡在 安全 选项卡里找到 自定义级别 ，点击 自定义级别选择禁用 Java小程序脚本 和 活动脚本弹出警告框点击 是然后重启浏览器 Opera
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af482ce5cf42a2552d5563ccdfffd64a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/390/">«</a>
	<span class="pagination__item pagination__item--current">391/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/392/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>