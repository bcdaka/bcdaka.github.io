<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa82d3043ed472d7abd889df8fba380d/" rel="bookmark">
			java对接第三方接口的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中，经常需要跟第三方系统对接，我们做为客户端，调用他们的接口进行业务处理，常用的几种调用方式有：
1.原生的Java.net.HttpURLConnection（jdk）；
2.再次封装的HttpClient、CloseableHttpClient（Apache）；
3.Spring提供的RestTemplate；
当然还有其他工具类进行封装的接口，比如hutool的HttpUtil工具类，里面除了post、get请求外，还有下载文件的方法downloadFile等。
HttpURLConnection调用方法 HTTP正文的内容是通过OutputStream流写入,向流中写入的数据不会立即发送到网络,而是存在于内存缓冲区中,待流关闭时，根据写入的内容生成HTTP正文。
调用getInputStream()方法时,会返回一个输入流,用于从中读取服务器对于HTTP请求的返回报文
@Slf4j public class HttpURLConnectionUtil { /** * * Description: 发送http请求发送post和json格式 * @param url 请求URL * @param params json格式的请求参数 */ public static String doPost(String url, String params) throws Exception { OutputStreamWriter out = null; BufferedReader reader = null; StringBuffer response = new StringBuffer(); URL httpUrl = null; // HTTP URL类 用这个类来创建连接 try { // 创建URL httpUrl = new URL(url); log.info("--------发起Http Post 请求 ------------- url:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa82d3043ed472d7abd889df8fba380d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280e98758d10c3aa02bf1252f42b02bd/" rel="bookmark">
			【Charles抓包教程-ios】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pc端charles配置 打开charles界面:
1）、点击【help】-&gt;【SSL Proxying】-&gt;【install Charles Root Certificate】,下载完成后，打开电脑的【钥匙串访问】,找到刚刚下载的证书进行安装（信任下的列表始终选择【始终信任】）。
2)、点击【Proxy】-&gt;【SSL Proxying Settings】-&gt;勾选【Enable SSL Proxying】，点击【Add】,弹出窗口中，Host和Port全写*，点击【ok】，回到列表，勾选刚刚添加的配置，再次点击【ok】。
2、ios手机配置 1）、数据线连接iphone和电脑
2）、打开手机【设置】-&gt;【无线局域网】（iphone和电脑需连接同一个无线网）-&gt;点击所连接的wifi进入页面-&gt;点击【配置代理】-&gt;点击【手动】,服务器栏填写电脑ip地址（charles点击【help】-&gt;【Local IP Adress】可以看到），端口8888，配置完毕，点击存储。
3）、打开手机自带Safari浏览器，输入网址：chls.pro/ssl，点击【允许】下载证书。
4）、再次打开手机【设置】-&gt;【已下载描述文件】-&gt;找到刚刚下载的证书，点击进行安装并完成。
5）、【设置】-&gt;【通用】-&gt;【关于本机】-&gt;【证书信任设置】,找到刚刚安装的证书点击开启信任。
综上所述，我们完成了双端配置。此时我们打开需要抓包的手机应用界面，就可以在电脑端charles界面看到对应域名下的请求了🎉
附：charles下载地址：Download a Free Trial of Charles • Charles Web Debugging Proxy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a31caf53332c3576cf0b416cec002f87/" rel="bookmark">
			vue 前端实现导出页面为pdf（分页导出、不分页导出、分模块导出）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：下载插件 npm install --save html2canvas // 页面转图片 npm install jspdf --save // 图片转pdf 第二步：main.js 文件引入 import htmlToPdf from './utils/htmlToPdf'; Vue.use(htmlToPdf); 第三步：utils/htmlToPdf.js 文件中定义方法（有三种方法：分页导出、不分页导出、分模块导出；具体方法 见最下边） 第四步：vue页面调用方法 （htmlToPdf） 方法一： 标准打印（分页打印）；缺点：分页处会把内容给截断 export default { install(Vue) { // eslint-disable-next-line func-names Vue.prototype.htmlToPdf = function (ele, title) { const dom = document.querySelector('#' + ele) html2Canvas(dom, { useCORS: true,//解决网络图片跨域问题 width: dom.width, height: dom.height, windowWidth: dom.scrollWidth, dpi: window.devicePixelRatio * 4, // 将分辨率提高到特定的DPI 提高四倍 scale: 4, // 按比例增加分辨率 }).then((canvas) =&gt; { // eslint-disable-next-line new-cap const pdf = new JsPDF('p', 'mm', 'a4'); // A4纸，纵向 const ctx = canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a31caf53332c3576cf0b416cec002f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0fea8be9cd3407096feabcacd9e9a4/" rel="bookmark">
			数据库系统课设--人事管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一，课程设计的目的
二，总体设计
1 系统需求分析
1.1 系统功能分析
1.2 系统功能模块设计（划分）
1.3 与其它系统的关系
1.4 数据流程图
2 数据库设计
2.1 数据库需求分析
2.2 数据库概念结构设计
2.3 数据库逻辑结构设计
2.4 数据库的建立
2.4.1 数据库的建立
2.4.2 初始数据的输入
3 各功能模块的设计与实现
3.1 功能说明
3.2 用户界面设计
3.3 各功能模块的实现
4 系统实现
4.2 加密模块
4.3 登陆模块
4.4 管理模块
4.5 新员工档案录入模块
4.6 人事变更模块
4.7 管理员员工档案查询修改模块
4.8 员工自身信息查询修改模块
4.9 数据库代码
4.10 数据库表结构
5 界面图预览
5.1 登录界面
5.2 管理界面
5.3 新员工档案录入界面
5.4 人事变更界面
5.5 管理员员工档案查询修改界面
5.6 员工自身信息查询修改界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee0fea8be9cd3407096feabcacd9e9a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74135e1e40495e2dec3d2e39717c6683/" rel="bookmark">
			javaweb个人主页设计（html&#43;css&#43;js）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 前言和要求
1.1 前言
1.2 设计要求
2 预览
2.1 主页页面
2.2 个人简介
2.3 个人爱好
2.4 个人成绩有代码，但是图片已省略，可以根据自己情况添加
2.5 收藏夹
3 代码实现 3.1 主页
3.2 个人简介
3.3 个人爱好
3.4 个人成绩（根据自己的情况添加）
3.5 收藏夹
4 可能要用的图片，其他根据自己情况选或者全部自己找新的
4.1 主页
4.2 个人简介
4.3 收藏夹
1 前言和要求 1.1 前言 如果有些东西css样式看不懂的话可以去编程宝库或者菜鸟教程查找相应的知识，另外作为业余选手，因为不是专业的，做的前端网页，是有一些毛病的，必须在全屏下效果才好，浏览器大小变化的话会有一点问题。
1.2 设计要求 （1）结构要求：主页和二级页面美观，至少2段以上文字介绍自己，至少3个二级页面（主页超链接进入），至少3张图片，有背景音乐。
（2）内容要求：个人自序、个人爱好、个人成绩、收藏夹（网上好的文章或诗词等的链接）等部分。
（3）技术要求：网页美观，内容丰富，浏览方便，界面友好，使用的HTML标签/样式及其JavaScript特效。
2 预览 2.1 主页页面 2.2 个人简介 2.3 个人爱好 2.4 个人成绩有代码，但是图片已省略，可以根据自己情况添加 2.5 收藏夹 3 代码实现 3.1 主页 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74135e1e40495e2dec3d2e39717c6683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de02be437756d5a167a868f8be4c5ef1/" rel="bookmark">
			python模型训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、新建模型 train_model.py
2、运行模型
（1）首先会下载data文件库
（2）完成之后会开始训练模型（10次）
3、 训练好之后，进入命令集
4、输入命令：python -m tensorboard.main --logdir="C:\Users\15535\Desktop\day6\train"
（1）目录的绝对路径获得方法
5、打开网页可视化图形
（1）运行完之后会自动有一个网址，点进去
（2）显示
1、新建模型 train_model.py import torch import torchvision.transforms from torch.utils.tensorboard import SummaryWriter from torchvision import datasets from torch.utils.data import DataLoader import torch.nn as nn from torch.nn import CrossEntropyLoss #step1.下载数据集 train_data=datasets.CIFAR10('./data',train=True,\ transform=torchvision.transforms.ToTensor(), download=True) test_data=datasets.CIFAR10('./data',train=False,\ transform=torchvision.transforms.ToTensor(), download=True) print(len(train_data)) print(len(test_data)) #step2.数据集打包 train_data_loader=DataLoader(train_data,batch_size=64,shuffle=False) test_data_loader=DataLoader(test_data,batch_size=64,shuffle=False) #step3.搭建网络模型 class My_Module(nn.Module): def __init__(self): super(My_Module,self).__init__() #64*32*32*32 self.conv1=nn.Conv2d(in_channels=3,out_channels=32,\ kernel_size=5,padding=2) #64*32*16*16 self.maxpool1=nn.MaxPool2d(2) #64*32*16*16 self.conv2=nn.Conv2d(in_channels=32,out_channels=32,\ kernel_size=5,padding=2) #64*32*8*8 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de02be437756d5a167a868f8be4c5ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668f64f55b3a9e424291833a5cd15e49/" rel="bookmark">
			python常用的第三方库下载,python官网下载第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，本文将围绕python常用的第三方库下载展开说明，python官网下载第三方库是一个很多人都想弄明白的事情，想搞清楚python常用第三方库下载需要先了解以下几个事情。
一、下载.whl文件方式（推荐！！） 以从清华源下载一个numpy-1.21.6-cp37-cp37m-win_amd64.whl文件为例。
①先进入网站 在浏览器输入格式为：https://pypi.tuna.tsinghua.edu.cn/simple/要下载的第三方库名/，我这里输入的是https://pypi.tuna.tsinghua.edu.cn/simple/numpy/
②使用全局搜索ctrl+f，根据自己需要的版本下载 我图上圈的，1.21.6表示numpy版本，cp37表示对应python版本为3.7，win_amd64表示适合64位机器python自动化运维效果。我圈的上一个，win32表示适合32位机器。
这里我的python是3.7，所以就搜索cp37，找到自己需要的版本下载。
③将下载好的文件移动到python下的Scripts文件夹中 就是在python解释器的文件夹下有个Scripts文件夹，找不到可以直接在pycharm中的文件File--&gt;设置setting--&gt;python解释器python interpreter查看，就可以看到当前所用的解释器的路径，在文件资源管理器打开，就会发现此路径下有个Scripts文件夹。
将下载好的文件移动到Scripts文件夹中
④在文件路径框输入cmd，回车 输入pip install numpy-1.21.6-cp37-cp37m-win_amd64.whl，回车安装
这里我出现了以下错误 这是因为使用的 pip 版本过旧，建议升级到最新版本，根据他提示的命令升级即可
然后再继续安装，成功
完成后将pycharm重启，就可以调用这些第三方库了，同时也可以在文件File--&gt;设置setting--&gt;python解释器python interpreter查看，第三方库已经安装成功啦。
二、 下载.tar.gz文件方式 一般有.whl文件的话最好用.whl文件，因为我用tar文件安装时有时候会有一些莫名其妙的问题
有的库找不到.whl文件，只有.tar.gz文件，那就只能用tar安装了
以下载robotframework-ride库为例
①进入网站 在浏览器输入格式为：https://pypi.org/projrct/要下载的第三方库名/#files(.whl文件也可在此网站下载)
我这里输入的是https://pypi.org/projrct/robotframework-ride/#files,进入后下载压缩包
如果想要下载指定版本的库，可以点击Release history进行版本选择
②解压tar文件 在文件路径框输入cmd，回车
解压压缩包，提取到python下的site-packages包中，该包在Lib文件夹中，Lib文件夹与上面提到的Scripts文件夹在同一路径
命令为：tar -zxvf pandas-2.0.3.tar.gz -C 提取文件到指定位置的路径 进入解压后的目录，提取后的结果如下
③cmd进入解压后的目录 针对setup.py进行操作，命令如下：
python setup.py install
这样安装完成了
可以用pip list命令查看已安装的库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d6bd6ba0709cd56c3b0b47dc2aab1e/" rel="bookmark">
			Kotlin 中编写静态方法的方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Kotlin 中，与 Java 不同，没有 static 关键字来定义静态方法。但是 Kotlin 提供了一种类似的机制来实现静态方法。本文将介绍 Kotlin 中编写静态方法的两种方式，并给出 Kotlin 和 Java 中的调用示例代码。
方式一：使用顶层函数 在 Kotlin 中，可以直接在文件中定义顶层函数，这些函数可以在整个文件内被调用，类似于 Java 中的静态方法。
Kotlin 示例： // Kotlin 文件：Util.kt package com.minos fun doAction1() { println("do action1") } Kotlin 调用示例： // Kotlin 文件：Main.kt package com.minos fun main() { doAction1() // 调用顶层函数 } Java 调用示例： // Java 文件：Main.java package com.minos; public class Main { public static void main(String[] args) { UtilKt.doAction1(); // 调用 Kotlin 中的顶层函数 } } 方式二：使用伴生对象 另一种在 Kotlin 中定义静态方法的方式是使用伴生对象。伴生对象是 Kotlin 中的一个特殊对象，它与类关联在一起，可以包含静态成员或者工厂方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0d6bd6ba0709cd56c3b0b47dc2aab1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b241748cb72aed01c14efb09c0e4033b/" rel="bookmark">
			MySQL进阶（日志）——MySQL的日志 &amp; bin log (归档日志) &amp; 事务日志redo log(重做日志) &amp; undo log(回滚日志)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 MySQL最为最流行的开源数据库，其重要性不言而喻，也是大多数程序员接触的第一款数据库，深入认识和理解MySQL也比较重要。
本篇博客阐述MySQL的日志，介绍重要的bin log (归档日志) 、 事务日志redo log(重做日志) 、 undo log(回滚日志)。
本系列文章合集如下：
【合集】MySQL的入门进阶强化——从 普通人 到 超级赛亚人 的 华丽转身
目录 前言引出一、MySQL日志分类二、Redo Log1. redo log重做日志的组成2. 刷盘的时机 三、undo log （事务回滚）四、Bin log两阶段提交为什么需要两阶段提交？MySQL主从复制 总结 引出 1.二进制日志bin log (归档日志) 和 事务日志redo log(重做日志) 和 undo log(回滚日志)；
2.bin log用于备份恢复、主从复制；redo log用于掉电等故障恢复；
3.redo log一旦提交意味着持久化了，但是有时候需要对其进行rollback操作，那就需要undo log；
4.主从：写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行；
一、MySQL日志分类 MySQL日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志binlog (归档日志) 和 事务日志redo log(重做日志) 和 undo log(回滚日志)。
MySQL日志主要包括七种：
1.重做日志(redo log）2.回滚日志(undo log）3.归档日志(bin log)4.错误日志(error log）5.慢查询日志(slow query log)6.一般查询日志(general log）7.中继日志(relay log） 二、Redo Log redo log(重做日志)是nnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。比如MySQL实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b241748cb72aed01c14efb09c0e4033b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c56b3421ae1aeb67e9d09b69ec3da7e/" rel="bookmark">
			Spring AI来了，Java开发者福音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring AI来了，Java生态接入LLM大模型变得更加简单！
SpringAI 今天官宣Spring AI已经上架到Spring Initializr 上，它提供了一种更简洁的方式和AI交互，减轻Java业务中接入LLM模型应用的学习成本，目前在 https://start.spring.io/ 上可以使用并构建。
Spring AI 是一个人工智能工程的应用框架。其目标是将 Spring 生态系统设计原则（例如可移植性和模块化设计）应用于 AI 领域，并推广使用 POJO 作为 AI 领域应用程序的构建块。
Features 跨 AI 提供商的便携式 API 支持聊天、文本到图像和嵌入模型。支持同步和流 API 选项。还支持配置参数访问特定Model。
支持的聊天模型
OpenAIAzure Open AIAmazon Bedrock Anthropic’s ClaudeCohere’s CommandAI21 Labs’ Jurassic-2Meta’s LLama 2Amazon’s Titan Google Vertex AIHuggingFace - HuggingFace上的大量模型，例如Llama2Ollama - 支持本地无GPU情况下运行AI模型 支持的文生图模型
OpenAI with DALL-EStabilityAI 支持的向量模型
OpenAIAzure OpenAIOllamaONNXPostgresMLBedrock CohereBedrock TitanGoogle VertexAI 官方文档：https://spring.io/projects/spring-ai#overview
快速开始 使用IDEA快速新建项目，选择要使用的AI模型依赖
这里我以ollama模型为例
Ollama Ollama帮助我们在本地的电脑上无需GPU（显卡）资源，也能一键构建大模型，并且提供控制台、RestfulAPI方式快速测试和接入Ollama上的大模型。
Ollama支持哪些模型？
Ollama官网：https://ollama.com/library
Tips:
其中gemma就是谷歌Meta近期新发布的模型llama2模型基本不支持中文语言，gemma模型对中文支持比较友好 引入依赖 **Tips：**Spring AI的相关依赖并没有开放在Meven中央仓库，因此需要配置Spring的仓库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c56b3421ae1aeb67e9d09b69ec3da7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964237c5a5aec70087fe866cbc44c5cf/" rel="bookmark">
			【工作实践-06】uniapp使用webView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、建立APP页面和webview的通讯 1.引入webview.js
App 端使用 uni.web-view.js 的最低版为 uni.webview.1.5.4.js
APP端可以支持网络网页和本地网页，但如果使用本地网页和相关资源（js、css等文件）必须放在 static 目录下。 2.引入搭桥document.addEventListener('UniAppJSBridgeReady',function(){})
在app端是识别不到document元素的，所以为了适配app，需要将搭桥的方法单独建立一个js文件放到 static 目录下
document.addEventListener('UniAppJSBridgeReady', function () { console.log('我建立起了通讯'); uni.postMessage({ data: { successFlag: true, } }); }) 3.发送消息
首先&lt;web-view&gt;中需要添加message的监听，当网页向应用 postMessage 时，会在特定时机（后退、组件销毁、分享）触发并收到消息。
&lt;web-view ref="webview" :src="webViewUrl" @message="onPostMessage"&gt;&lt;/web-view&gt; 其次网页向应用 postMessage 需要通过 wv.evalJS(``)方法，在此方法中利用uniapp的postMessage()方法向应用发送消息
wv.evalJS(`uni.postMessage({ data: { base64: canvas.toDataURL("image/png"), } });	`) 最后在uniapp通过 onPostMessage 函数中获取网页信息
onPostMessage: function (e) { console.log(e.detail.data[0]) }, 二、webview初始化遇坑 1.setJsFile() 和 appendJsFile() 方法的区别
在初始化webview时，需要引入webview.js文件和添加的搭桥 js (post.js)文件 此时需注意 setJsFile() 和 appendJsFile() 方法的区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/964237c5a5aec70087fe866cbc44c5cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2fc365bf13b0a72f8931a893a2bf86/" rel="bookmark">
			【Sql Server】Update中的From语句，以及常见更新操作方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》，大家好，我是全栈小5。
这是《Sql Server》系列文章，每篇文章将以博主理解的角度展开讲解，
特别是针对知识点的概念进行叙说，大部分文章将会对这些概念进行实际例子验证，以此达到加深对知识点的理解和掌握。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 前言常规更新分组查最大值编号更新查询更新 常见更新方式UPDATE 语句使用子查询更新数据使用 JOIN 更新数据使用临时表进行更新使用事务进行更新使用触发器进行更新 常见场景批量修改数据场景需要注意的事项 文章推荐 前言 最近在做数据修改，有时候太久没写sql语句，突然想通过子查询的方式去批量更新数据的时候，
还是有点不知所措，那就一步一步来吧，也写篇文章梳理和总结下，毕竟也是基本的操作加深印象。
上篇文章已经介绍分组查询方法，这篇文章将通过分析update更新有那些语句和方式方法。
常规更新 基于上篇文章的表数据，先查询同城市同区域同姓名存在等于2条的记录，
并将最大编号的那条记录代理商更新为"张三2"，城市区县代理商三者分组查询
分组查最大值 select * from test_name select city_name,area_name,agent_name,max(id) maxId from test_name group by city_name,area_name,agent_name having count(1)&gt;1 编号更新 不管任何时候，进行更新操作，一定更要三思，问问自己加了where条件没有，切勿大意经验之谈
update test_name set agent_name='张三2' where id=2 select * from test_name 查询更新 通过子查询方式更新数据，将上面的数据更新还原，进行下面更新操作
update test_name set agent_name='张三_'+convert(varchar(50),t.maxId) from( select city_name,area_name,agent_name,max(id) maxId from test_name group by city_name,area_name,agent_name having count(1)&gt;1 ) t where test_name.id=t.maxId select * from test_name 常见更新方式 在 SQL Server 中，更新数据是数据库管理中常见且重要的操作之一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb2fc365bf13b0a72f8931a893a2bf86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e51ef52146fc0461d1e7baa837823c8/" rel="bookmark">
			Linux如何清理Redis中的缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、清空当前redis数据库缓存：flushdb
2、清空整个redis缓存：flushall
连接redis
redis-cli -h 127.0.0.1 -p 6399 -a xxxxxxx
连接redis成功后，如果要清空redis某个缓存库如下操作
127.0.0.1:6379&gt; select 0
127.0.0.1:6379&gt; flushdb
127.0.0.1:6379&gt;
查看redis中database为0库中所以的key
127.0.0.1:6379&gt; select 0
127.0.0.1:6379&gt; keys *
“sys:cache:dict::user_status:1”“sys:cache:dict::user_status:2”“geteway_routes”“sys:cache:dict::sex:2”“sys:cache:dict::sex:1” 如果清空database为8的缓存如下
127.0.0.1:6379&gt; select 8
127.0.0.1:6379&gt; flushdb
127.0.0.1:6379&gt;
如果要清空redis全部database，如下
127.0.0.1:6379&gt; flushall
127.0.0.1:6379&gt;
使用exit 退出redis
127.0.0.1:6379&gt; exit
[root@localhost logs]#
了解更多内容 关注公众号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef38f8e8636ac41ee241c5bf63d6712/" rel="bookmark">
			stable diffusion比 transformer 作了哪些改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion 是一个基于自注意力机制的生成模型，它的设计受到了 Transformer 模型的启发，但也在很多方面进行了改进。以下是 Stable Diffusion 相较于 Transformer 的一些改进之处：
稳定性提升：Stable Diffusion 引入了扩散过程，增强了生成图像或文本时的稳定性，避免一些不稳定的训练和生成表现。
长距离依赖处理：相较于 Transformer 的固定长度自注意力机制，Stable Diffusion 通过扩散过程可以更好地处理长距离的依赖关系，提高了模型在生成长序列时的效果。
更好的生成质量：由于稳定性和长距离依赖处理的改进，Stable Diffusion 在生成图像和文本时往往能够取得更好的质量和多样性，降低了生成结果中的错误和重复。
损失函数设计：Stable Diffusion 使用了不同于传统生成模型的损失函数设计，通过在扩散过程中预测噪声水平来引导模型生成更加清晰和正确的结果。
总的来说，Stable Diffusion 在借鉴 Transformer 的自注意力机制基础上，通过引入扩散过程和改进的损失函数设计等方面的改进，提高了模型的生成稳定性、长距离依赖处理能力和生成质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd85886f94058cafdfc3840c6f809f0/" rel="bookmark">
			AI绘画新手必看，Stable Diffusion提示词神器来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是程序员晓晓
对于AI绘画来说，提示词写得好坏，十分影响最终生成图片的结果。会写提示词的话，生成的图片质量就会比较高，不会写的话，结果可能就不会好。
之前大家在使用Stable Diffuison（以下简称SD）时，写提示词往往要去翻译软件先输入中文，然后翻译成英文后，再来SD输入。整个过程非常繁琐，总需要在SD和翻译软件之间反复横跳。今天介绍一款提示词神器prompt-all-in-one，有了它，写提示词再也不是难题了。
prompt-all-in-one简介
作者对这个SD插件的简介：旨在改善提示/否定提示输入框的用户体验。拥有更加直观、强大的输入界面，提供自动翻译、历史记录和收藏功能，并支持多种语言，满足不同用户的需求。
安装它非常简单，在SD webui的扩展中，选择“从网址安装”，然后输入以下链接：
https://github.com/Physton/sd-webui-prompt-all-in-one
之后稍等片刻，即可安装成功（因为是github的链接，所以可能需要魔法，没关系，文末提供插件包的下载，下载后，请自行放置在stable-diffusion-webui\extensions\）。
功能介绍 prompt-all-in-one提供的能力太强大了，说是神器一点不夸张。挑一些我实测过，效果非常好的功能，分享给大家：
①支持几乎所有国家语言：点击语言切换按钮，即可选择几乎所有语言。
②自动翻译：勾选自动翻译功能后，你只管输入，这个插件自动就帮你把提示词翻译，并填写到相应的区域。
③一键翻译：你也可以直接在提示词区域输入中文的词汇，然后点击一键翻译，提示词就自动翻译为英文。
④权重快速调节：我们知道，提示词的先后顺序，以及在提示词外面加()和[]，可以提高提示词优先级，而这个插件可以让你快速拖拽、添加括号以更改权重。
⑤收藏和历史记录：虽然SD提供了保存提示词模板功能，但体验不是很好，而prompt-all-in-one这个插件可以记录你每一次生成的记录，喜欢的还可以收藏，再也不怕偶然的灵感再也找不回了。
⑥使用ChatGPT生成提示词：如果你想让另外一个神器ChatGPT帮你写提示词，这个插件也能做到，只要设置了API，就可以让ChatGPT帮你快速写提示词了。
prompt-all-in-one这个插件可帮了大忙了，玩了很久，爱不释手。而且它还有更多功能，等待大家去发掘。感兴趣的朋友，不要错过，快去试试吧~
写在最后 感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a001f0d881cab30e1117c431d6ffcd06/" rel="bookmark">
			Spring Boot中使用Server-Sent Events (SSE) 实现实时数据推送教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Server-Sent Events (SSE) 是HTML5引入的一种轻量级的服务器向浏览器客户端单向推送实时数据的技术。在Spring Boot框架中，我们可以很容易地集成并利用SSE来实现实时通信。
二、依赖添加 在Spring Boot项目中，无需额外引入特定的依赖，因为Spring Web MVC模块已经内置了对SSE的支持。
辅助Maven
&lt;!-- 集成beetl --&gt; &lt;dependency&gt; &lt;groupId&gt;com.ibeetl&lt;/groupId&gt; &lt;artifactId&gt;beetl-framework-starter&lt;/artifactId&gt; &lt;version&gt;1.2.30.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 集成hutool工具类简便操作 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; 三、编写核心SSE Client @Slf4j @Component public class SseClient { private static final Map&lt;String, SseEmitter&gt; sseEmitterMap = new ConcurrentHashMap&lt;&gt;(); /** * 创建连接 */ public SseEmitter createSse(String uid) { //默认30秒超时,设置为0L则永不超时 SseEmitter sseEmitter = new SseEmitter(0l); //完成后回调 sseEmitter.onCompletion(() -&gt; { log.info("[{}]结束连接...................", uid); sseEmitterMap.remove(uid); }); //超时回调 sseEmitter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a001f0d881cab30e1117c431d6ffcd06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a495b1333a0366440d99cbbc2fbb655e/" rel="bookmark">
			掌握XML解析：深入比较Java中的四种解析方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XML简介 XML 全称为可扩展标记语言（eXtensible Markup Language），是一种用于标记电子文件结构以便存储、传输和展现数据的标记语言。XML 被设计用来传输和存储数据，而不是用来显示数据的。与 HTML 类似，XML 也使用标签来描述数据的结构，但 XML 允许用户自定义标签，因此更加灵活。
XML 的基本语法规则包括：
标签需成对出现，有开始标签和结束标签，例如 &lt;tag&gt;...&lt;/tag&gt;。标签可以嵌套，但必须严格按照层次结构书写。属性值必须使用引号括起来。区分大小写，标签名、属性名需严格区分大小写。 XML 的应用领域非常广泛，常用于配置文件、数据交换、Web 服务等领域。通过定义自定义的标签和数据结构，XML 使得不同系统之间可以方便地共享和传输数据，提高了数据的可读性和可靠性。
在 Java 中，我们遇到的非常多的框架例如：Spring、MyBatis 等都使用了大量的 XML 文件作为配置文件，所以 Java 对于 XML 的解析是对于这些框架而言是非常重要的。本文就给大家介绍几种 Java 中常用的 XML 解析方式。
示例XML 通过 IDEA 创建 Maven 项目，之后可以在 resources 目录下创建 books.xml，内容如下：
&lt;bookstore&gt; &lt;book id="1"&gt; &lt;name&gt;冰与火之歌&lt;/name&gt; &lt;price&gt;89&lt;/price&gt; &lt;/book&gt; &lt;book id="2"&gt; &lt;name&gt;安徒生童话&lt;/name&gt; &lt;price&gt;77&lt;/price&gt; &lt;/book&gt; &lt;/bookstore&gt; 创建 Book 实体如下：
@Data @AllArgsConstructor @NoArgsConstructor public class Book { private Integer id; private String name; private Double price; } 创建测试类如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a495b1333a0366440d99cbbc2fbb655e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc817b838a670fb6c883d10cf49b9999/" rel="bookmark">
			C&#43;&#43;代码中使用哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是哈希表
二、C++代码中如何使用哈希表
三、哈希表的优缺点
四、std::map优缺点
五、查找效率对比
六、总结
七、扩展 chrono
一、什么是哈希表 哈希表（Hash Table）是一种数据结构，也被称为散列表。它通过将键（Key）映射到存储位置，以提高数据的访问效率。哈希表使用哈希函数将键转换为对应的存储位置，这个位置通常称为哈希桶（Hash Bucket）或槽（Slot），在这个位置存储对应的值（Value）。
二、C++代码中如何使用哈希表 Header：#include &lt;unordered_map&gt;
示例代码：
#include &lt;iostream&gt; #include &lt;unordered_map&gt; int main() { // 创建一个 unordered_map std::unordered_map&lt;std::string, int&gt; myMap; // 插入键值对 myMap["apple"] = 10; myMap["orange"] = 7; myMap["banana"] = 5; // 访问元素 std::cout &lt;&lt; "Number of apples: " &lt;&lt; myMap["apple"] &lt;&lt; std::endl; // 遍历哈希表 for (const auto&amp; pair : myMap) { std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc817b838a670fb6c883d10cf49b9999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0951f9e6d18b8ad566404175bf627cc8/" rel="bookmark">
			百度文心一言api接口调用使用教程，自媒体/网站优化批量改写文章可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是淘小白~
年前就有老客户需要写一个百度文心一言改写的软件，但是过年直接躺平了，年后抓紧给写出来了，通过百度文心一言可以改写文章，自媒体的洗稿可用。
网站优化也可以用，但是不推荐，免费调用很少，回报周期长，利润低的话不推荐使用文心一言改写。
这篇文章主要记录一下主要的几个方法和注意事项，避免自己忘记，如果文章对你有用，可以收藏一下，感谢大家~
1、百度文心一言的api 接口在千帆平台上；
2、代码语言：【Python】
3、千帆平台创建应用
网址：https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application
创建好应用之后，我们需要保存一下 API Key 和 Secret Key 这两个参数需要用来后去accesstoken
4、获取accesstoken
def GetAccessToken(APIKey, SecretKey): """ 使用 API Key，Secret Key 获取access_token，替换下列示例中的应用API Key、应用Secret Key 网址：https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application """ url = "https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id={}&amp;client_secret={}".format( APIKey, SecretKey) payload = json.dumps("") headers = { 'Content-Type': 'application/json', 'Accept': 'application/json' } response = requests.request("POST", url, headers=headers, data=payload) return response.json().get("access_token") 5、请求接口方法
def GetBaiduAi(question, model_url, APIKey, SecretKey): try: url = "{}?access_token=".format(model_url) + GetAccessToken(APIKey, SecretKey) payload = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0951f9e6d18b8ad566404175bf627cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1960287590eff1e9bb9d57282b98b69e/" rel="bookmark">
			MAC认证配置及命令解析（含华为和华三设备）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： MAC认证是网络接入控制方案（NAC）中的一种，它是基于接口和MAC地址对用户的网络访问权限进行控制的认证方法，并且不需要用户安装任何客户端软件。通过MAC认证能够实现保护企业内网的安全性的目的。
MAC认证无需用户终端安装客户端，但是却需要在服务器上登记MAC地址，管理较为复杂。相较而言，NAC中的802.1X认证方式安全性高，但是由于需要用户终端安装客户端，部署不灵活；而Portal认证方式同样不需要客户端并且部署灵活，但是安全性不高。
MAC认证一般适用于打印机、传真机等哑终端接入认证的场景。
场景 华为Agile Controller-Campus对接入用户进行MAC认证（认证点部署在接入交换机）
HUAWEI/H3C设备——对接HUAWEI AG（RADIUS服务器）
NAC为统一模式，可基于VPN实例
终端用户采用MAC认证方式接入组网环境
一、华为设备： 1、配置RADIUS服务器，添加用户账户，保证用户的认证/授权/计费功能正常运行（略） #配置过程中有两个个共享密钥（RADIUS认证和计费密钥）交换机侧与服务器侧必须要配置一致
2、配置全网路由可达 4、创建RADIUS服务器模板（指定RADIUS服务器IP地址及共享密钥） radius-server template radius_temp #创建radius server模板 radius-server shared-key cipher Radius@Auth #定义共享秘钥 radius-server authentication X.X.X.X 1812 vpn-instance Video source ip-address X.X.X.X weight 100 #ip-address为需要修改的地址，每个局点不同 radius-server accounting X.X.X.X 1813 vpn-instance Video source ip-address X.X.X.X weight 100 #ip-address为需要修改的地址，每个局点不同 radius-server testuser username AuthTest password cipher Huayun@123 #创建测试用户AuthTest，用户密码Huayun@123 radius-server authorization X.X.X.X vpn-instance Video shared-key cip Radius@Auth #定义授权秘钥 5、创建AAA认证方案，认证方式为RADIUS aaa #进入aaa模式 authentication-scheme radius_auth #创建认证方案 authentication-mode radius #指定认证方案的认证模式radius 6、创建AAA计费方案，认证方式为RADIUS accounting-scheme radius_acc #创建审计方案 accounting-mode radius #指定审计方案的审计模式为radius accounting realtime 15 #指定实时审计周期为15分钟 accounting start-fail online #指定开始计费失败策略为：如果开始计费失败，允许用户上线 （缺省情况下，如果开始计费失败，用户不能上线，即采用offline方式） 该命令仅在执行accouting-mode命令配置计费模式为HWTACACS或RADIUS模式下生效； 应用场景：应用了计费方案后，如果有用户上线，设备将向计费服务器发送开始计费请求。 正常情况下，计费服务器响应设备的请求，由于网络故障的影响，可能造成设备没有收到计费服务器的响应而造成计费失败。 计费失败后，需要执行响应的策略: 7、创建接入用户默认认证域，并将RADIUS服务器模板、认证方案、计费方案绑定至该域； aaa #进入aaa模式 domain video.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1960287590eff1e9bb9d57282b98b69e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/490/">«</a>
	<span class="pagination__item pagination__item--current">491/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/492/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>