<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b0e165cba959f867b4b0be6fff736d/" rel="bookmark">
			IDEA启动项目时报Error:Kotlin: Module was compiled with an incompatible version of Kotlin.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用IDEA启动项目时，有一个服务启不了，报错信息如下：
Error:Kotlin: Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.6.0, expected version is 1.1.13.
我的IDEA版本是：IntelliJ IDEA 2018.3.5 (Ultimate Edition)
方法一：升级Kotlin插件
由于下载时间太慢，换第二种方案；
方法二：bulid项目
启动成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9076d93ff3b9d055c0a417bd0afc8a29/" rel="bookmark">
			【数据结构与算法】前缀树的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌠作者：@阿亮joy.
🎆专栏：《数据结构与算法要啸着学》
🎇座右铭：每个优秀的人都有一段沉默的时光，那段时光是付出了很多努力却得不到结果的日子，我们把它叫做扎根
目录 👉前缀树的实现👈什么是前缀树节点的定义构造函数插入字符串查找字符串和前缀析构函数删除字符串打印前缀树完整代码OJ题：实现前缀树 👉总结👈 👉前缀树的实现👈 什么是前缀树 Trie（发音类似 “try”），被称为前缀树或字典树，是一种树形的数据结构，可用于高效地存储和检索字符串数据集中的键。这个数据结构有相当多的应用情景，例如自动补完和拼写检查。下图就是经典的前缀树，我们接下来要实现的前缀树的节点存储的数据比较丰富，以达到特定字符串在树中出现几次等类似的功能。
节点的定义 // 前缀树节点的定义 // 假设字符都是小写字母 struct TrieNode { int pass = 0;	// 有几个字符串经过该节点(前缀包含这个字符的字符串数量) int end = 0;	// 以该节点为结尾的字符串的数量,如果不允许字符串重复插入,可以改成bool // next[0] == nullptr 表示没有走向'a'的路 // next[0] != nullptr 表示有走向'a'的路 // ... // next[25] != nullptr 表示有走向'z'的路 TrieNode* next[26] = { nullptr };	// 26个空位,准备挂下一个节点'a'-'z',没有挂节点时为nullptr // 如果字符种类个数比较多,可以将数组换成哈希表或者set }; 构造函数 前缀树是用哨兵位头节点来管理整棵前缀树的，所以其构造函数需要 new 上一个哨兵位头节点。
class Trie { typedef TrieNode Node; public: Trie() { _root = new Node(); } private: Node* _root = nullptr;	// 哨兵位头节点,可以用来求前缀树中字符串的数量,也可以求空串的数量 }; 注：哨兵位头节点的 pass 值可以表示前缀树含有的字符串数量，end 值可以表示前缀树含有空串的数量。因为任何字符串都会以空串作为前缀，都会经过哨兵位头节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9076d93ff3b9d055c0a417bd0afc8a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8add35710959d8643c300200e6081c50/" rel="bookmark">
			JVM（Java虚拟机）详解（JVM 内存模型、堆、GC、直接内存、性能调优）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM（Java虚拟机） JVM 内存模型 结构图 jdk1.8 结构图（极简） jdk1.8 结构图（简单） JVM（Java虚拟机）：
是一个抽象的计算模型。如同一台真实的机器，它有自己的指令集和执行引擎，可以在运行时操控内存区域。目的是为构建在其上运行的应用程序提供一个运行环境，能够运行 java 字节码。JVM 可以解读指令代码并与底层进行交互：包括操作系统平台和执行指令并管理资源的硬件体系结构。 jdk1.7 结构图（详细） JVM 内存模型 组成元素 Java 内存模型主要包含线程私有的程序计数器、java虚拟机栈、本地方法栈和线程共享的堆空间、元数据区、直接内存。
Java运行时数据区域
Java 虚拟机在执行过程中会将所管理的内存划分为不同的区域，有的随着线程产生和消失，有的随着 Java 进程产生和消失。
根据 JVM 规范，JVM 运行时区域大致分为程序计数器、虚拟机栈、本地方法栈、堆、方法区（jkd1.8废弃）五个部分。
程序计数器（PC 寄存器、计数器）
程序计数器就是当前线程所执行的字节码的行号指示器，通过改变计数器的值，来选取下一行指令，通过它主要实现跳转、循环、恢复线程等功能。
在任何时刻，一个处理器内核只能运行一个线程，多线程是通过抢占 CPU，分配时间完成的。这时就需要有个标记，来标明线程执行到哪里，程序计数器便拥有这样的功能，所以，每个线程都已自己的程序计数器。
可以理解为一个指针，指向方法区中的方法字节码（用来存储指向下一个指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。
倘若执行的是 native 方法，则程序计数器中为空
Java 虚拟机栈（JVM Stacks）
虚拟机栈也就是平常所称的栈内存，每个线程对应一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法在执行的同时都会创建一个栈帧，方法被执行时入栈，执行完后出栈。
不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致。
每个栈帧主要包含的内容如下：
局部变量表
存储着 java 基本数据类型（byte/boolean/char/int/long/double/float/short）以及对象的引用
注意：这里的基本数据类型指的是方法内的局部变量
局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。
操作数栈
动态连接
方法返回地址
虚拟机栈可能会抛出两种异常： 栈溢出（StackOverFlowError）：
若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常
内存溢出（OutOfMemoryError）：
若虚拟机栈的容量允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OOM 异常
本地方法栈（Native Method Stacks）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8add35710959d8643c300200e6081c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5b839df71a6caf29ab242e38b22dec/" rel="bookmark">
			Android基础教程——从入门到精通（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是对B站教程 动脑学院 Android教程 学习过程中所做的笔记。文章分为上下两部分，此文是上部分，下部分链接为：Android基础教程——从入门到精通（下）源视频教程并没有录制全，本文还补充了 Service 和 网络通信 的内容文章介绍详细，示例代码丰富，相信跟着本教程可以打下很好的Android基础。 文章目录 一、开发环境搭建二、简单控件1. 文本显示2. 按钮3. 常用布局（1）线性布局LinearLayout（3）相对布局RelativeLayout（3）网格布局GridLayout 4. 图像显示（1）图像的缩放问题：（2）图像按钮ImageButton： 三、Activity1. Activity的启动和结束2. Activity的生命周期3. Activity的启动模式（1）静态设置（2）动态设置 4. Activity之间传递信息（1）显式Intent和隐式Intent1. 显式Intent2. 隐式Intent： （2）向下一个Activity发送消息：（3）向上一个Activity返回消息： 5. Activity获取一些附加信息（1）获取资源信息：（2）获取元数据信息： 四、数据存储1. 共享参数SharedPreferences（1）使用：（2）应用实例：记住密码功能 2. 数据库SQLite（1）SQLiteDatabase（2）SQLiteOpenHelper（3）代码举例：（4）优化记住密码： 3. 存储卡（1）私有空间和公有空间（2）在存储卡上读写文件（3）在存储卡上读写 图片文件 4. 应用组件Application5. 实战：购物车 五、内容共享1. 在应用之间共享数据2. 使用内容组件获取通讯信息（1）运行时动态申请权限（2）使用ContentResolver读写联系人（3）使用ContentObserver监听短信 3. 在应用之间共享文件（1）使用相册图片发送彩信（2）借助FileProvider发送彩信（3）借助FileProvider安装应用 一、开发环境搭建 安装android studio安装 sdk（当前使用最新版33） 手动下载gradle
（更新：弄完之后有时候没用，可以再试试挂梯子，换网络之类的）
如果第一次启动AndroidStudio没有报错则无需设置，这里是因为我启动完之后下载gradle报错：
could not install gradle distribution from 'https://services.gradle.org/dist 可能是网络问题连接不到，所以手动下载。
点击上面提示的链接下载压缩包，然后解压到C:\Users\OYMN\.gradle\wrapper\dists\gradle-7.2-bin\2dnblmf4td7x66yl1d74lt32g
安装模拟器
使用androidstudio提供的模拟器，或者自行下载第三方安卓模拟器（雷电模拟器）
二、简单控件 1. 文本显示 设置文本内容有两种方式：
在 XML 文件中通过属性 android:text 设置文本在 Java 代码中调用文本视图对象的 setText 方法设置文本 引用字符串资源：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5b839df71a6caf29ab242e38b22dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee3e4f9d95b7b56c827d0a61c973a94/" rel="bookmark">
			如何使用JDBC操作数据库？一文带你吃透JDBC规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. JDBC 概述2.1 概念2.2 优点 3. JDBC 快速入门4. JDBC API详解4.1 DriverManager4.1.1 注册驱动4.1.2 获取连接 4.2 Connection4.2.1 获取执行sql的对象4.2.2 事务管理 4.3 Statement4.4 ResultSet4.5 PreparedStatement4.5.1 sql注入问题4.5.2 preparedStatement 原理 5. 数据库连接池5.1 概念5.2 实现 6. Druid 连接池的使用7. 准备工作8. 实战案例9. 增删改查操作练习9.1 查询所有9.2 添加数据9.3 修改数据9.4 删除数据 10. 总结📂橙子精品文章学习推荐 1. 前言 大家好，我是橙子。最近又肝了几个大夜，总结了 JDBC 完整版的基础教程和实战案例训练。快来看看这些 Java 基础性的代码你有没有忘记？
在 Java 开发中，使用 Java 语言操作数据库是非常重要的一部分，那么 Java 语言是如何操作数据库的呢？
我们需要使用不同厂商的数据库时，例如 MySQL，Oracle 等，显然一套 Java 代码是不能同时操作不同的数据库的，那么怎样实现一套 Java 代码对不同的数据库的操作呢？
JDBC 应运而生，JDBC 是使用 Java 语言操作关系型数据库的一套 API，其中定义了对数据库操作的规范，这里的规范在 Java 中就是指接口，不同的数据库厂商提供了不同的 JDBC 实现类，称为驱动，使用时，只需要导入需要的数据库驱动 jar 包，便可以操作不同的关系型数据库，其实际是使用了 jar 包中的实现类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dee3e4f9d95b7b56c827d0a61c973a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3336c80196143607fd4b46406e5926ad/" rel="bookmark">
			前端利器——炫酷的CodePen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 众所周知，前端是一个很容易将自己的劳动成果呈现出来的一个职位，无论是写1行代码还是写100行代码，都可以通过页面来进行呈现，在工作中的劳作成果也是可以一眼就呈现给客户、用户的。比如一些精美的页面，炫酷的特效，优质的交互等，都是前端人员所呈现出来的代码成果。炫酷的特效也是必不可少的，通常来说，如果一个人写一个很不错的特效，那么它必然会花费相当的时间，从最初的构思，到码代码，再到呈现到页面并且进行不断的修修改改，那么CodePen就出现了。
1.CodePen是什么？ CodePen是一个完全免费的前端代码托管服务，可以用来制作和测试页面的网站。
2.CodePen有什么特点？ 1.可以即时预览。你也可以按照自己的需求在本地修改别人的预览作品，从而达到自己的需求效果
2.支持多种主流预处理器，不需要手写生产级别的代码，无论是 Jade 、 LESS 、 Sass ，还是CoffeeScript 、 es6+（ Babel ），都能使用。
3.快速添加外部资源文件，只需在输入框里输入库名， CodePen 就会从 cdnjs 上寻找匹配的 css 或 js 库。从而帮助你提供更好的体验
4.用户可以免费创建三个模板，避免了从零开始的问题。
5.fork 功能：用于【备份他人的优秀作品】
3.CodePen如何使用？ 点击打开CodePen，打不开的科学上网一下，我们可以看到这么一个界面（这里需要注册一下，当然可以进行Github/tuite/邮箱等登录）
2.既然想免费使用那么点击这个0$的即可
3.成功注册之后点击Your Work，这里就可以进入你的工作区了，可以看到你最近编辑的任务哦也可以根据名称进行搜索。Trending这里有许多优秀的作品，可以直接点开，然后再作品里面编辑修改。Following就是关注的人，在这里你可以看到他们的所有作品以及及时更新的作品
4.他人作品点开之后可以看到有html，css，js以及展示区，可以即时编辑并保存到本地，保存到本地的就可以直接再YourWork的区进行查看以及再次修改编辑
5.进行npm包的安装和本地资源的引入，点击设置—可以看到各种设置，在这里可以对html，css，js等进行相应的设置
6.更该视图，这里和浏览器的控制台一样可以根据自己喜欢的位置进行做自己喜爱的特效
7.spark，是一些比较优秀的作品展示，在这里可以看到更多优秀的作品(这个是我比较喜欢的，我称它为鼠标修狗)
// 鼠标修狗 // A ---- A ________ ________ // | | | | // | ^ ^ | | | // ____^___ _________|________| // | | | | | | | | // 1 2 3 4 // L R L R 写在最后 CodePen真的是一个优秀者云集的地方，它们无私的把这些特效分享给大家，每个人都能感受到，它们带来的快乐，甚至更为部分前端程序员解决了部分难题，山鱼感觉这个很不错，给大家分享一下，今天的CodePen就到这里了，更多优秀的功能内容大家就自己去探索吧毕竟惊喜自己发现的才有意思。 点赞：您的赞赏是我前进的动力！ 👍收藏：您的支持我是创作的源泉！ ⭐评论：您的建议是我改进的良药！ ✍JavaScript专栏： 小嘎鱼学JS ，Vue专栏： 小嘎鱼学Vue ，特效专栏： 小嘎鱼玩特效 ，欢迎大家加入我的个人社区—— 山鱼社区 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78adf7aefef1ffd366ae7cc545baaf64/" rel="bookmark">
			前端打包后生成的dist 或 build目录，如何在本地启动服务运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端打包后生成的dist/build目录，如何在本地启动服务运行
运行npn run build，会打包后会产生 dist 或 build 目录
一般情况下，直接打开dist 或 build 目录下的 index.html会在浏览器看到内容。
然而发现网页一片空白，打开了控制台，看到一片404的各种找不到资源，或者出现跨域的提示
解决方案 server https://www.npmjs.com/package/serverhttp-server https://www.npmjs.com/package/http-servelive-server https://www.npmjs.com/package/live-server在本地搭建express服务器使用nginx本地服务器 方案一 前三种基本使用方法是一致
以 live-server 为例：
全局安装live-server插件 npm install -g live-server 在dist 或 build文件夹（刚刚打包成功后多出来的文件夹）终端输入 live-server 浏览项目
默认监听在8080端口，打开浏览器，输入localhost:8080 就可以预览了 http://www.51sio2.cn//article/334864831.html
方案二 搭建express本地服务器 具体介绍：
https://www.pudn.com/news/63451f42272bb74d44499443.html
方案三 使用nginx本地服务器运行 具体介绍：
https://www.pudn.com/news/63451f42272bb74d44499443.html
方案四 手动起一个本地服务 具体介绍：
https://www.codenong.com/cs109000079/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f6daae076fd9e85cb92ab26f103a236/" rel="bookmark">
			Java——学生管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生管理系统实现步骤：
定义学生类学生管理系统的主界面的代码编写学生管理系统的查看所有学生的代码编写学生管理系统的添加学生代码的编写学生管理系统的删除学生的代码编写学生管理系统的修改学生的代码编写 学生系统主界面：
public class StudentManagerTest { public static void main(String[] args) { //创建集合对象，用于存储学生数据 ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;(); //为了让程序能够回到这里，我们使用for循环，死循环 while(true) { //这是学生管理系统的主界面 System.out.println("--------欢迎来到学生管理系统--------"); System.out.println("1 查看所有学生"); System.out.println("2 添加学生"); System.out.println("3 删除学生"); System.out.println("4 修改学生"); System.out.println("5 退出"); System.out.println("不好意思，目前没有学生信息可供查询，请重新输入您的选择"); //创建对象 Scanner sc = new Scanner(System.in); String choiceString = sc.nextLine(); //用switch 语句实现 switch(choiceString) { case "1": //查看所有学生 findAllStudent(array); break; case "2": //添加学生 addStudent(array); break; case "3": //删除学生 deleteStudent(array); break; case "4": //修改学生 updateStudent(array); break; case "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f6daae076fd9e85cb92ab26f103a236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f90bbe04eb902b03a94264ac40bb63/" rel="bookmark">
			解决Cannot read properties of undefined (...)类型的报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景： 在项目中，想要获取鼠标的元素，红色区域报错：Cannot read properties of undefined (reading 'grid3D')
分析： Cannot read properties of undefined类型的报错，一般是报错元素的前一个元素出了问题，也就是this.option没有获取到。
报错类型一般为两种：
对象没值的时候对象为undefined的时候 对象没有数据的时候为undefined 这个时候访问内部内容就会报错
解决方法： 查看一下this.option，注释掉问题代码，并输入console.log(this.option)
let option = xxx; this.rateChart.on("mouseover", (params) =&gt; { // console.log('params',params); if (params.target) { // console.log("非空白区"); } else { // console.log("空白区"); console.log(this.option) // this.option.grid3D.viewControl.alpha =20; // 视角绕 x 轴，即上下旋转的角度 // this.option.grid3D.viewControl.beta = 70; // 视角绕 y 轴，即左右旋转的角度。 // this.rateChart.setOption(this.option); } }); 发现输出undefined，说明没有找到option，查看上下文，发现前面已经定义了option，不需要用this，直接使用即可。
修改后：
成功解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06294720f6fdb28c5a04e8476e1347d/" rel="bookmark">
			前端Vue中实现超炫酷动态背景(全屏背景&#43;自定义banner&#43;登录/注册页)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文章引导 前端Vue中实现超炫酷动态背景 动态演示 关键代码 安装依赖 二、博主简介 🌏博客首页： 水香木鱼
📌专栏收录：后台管理
📑文章摘要：炫酷动态背景 vue2 自定义banner
💌木鱼寄语：故木秀于林，风必摧之；堆出于岸，流必湍之；行高于人，众必非之。
三、文章内容 本期 木鱼为大家带来的是，在前端vue中实现超炫酷的动态背景【可应用与登录/注册页面、自定义banner图、全屏背景等】
👉点击进入 Vanta.js-Animated website backgrounds in a few lines of code官网，体验超炫酷背景
①、安装依赖 注意：需下载以下版本号的插件 👇
npm install vanta@0.5.24 npm install three@0.121.0 ②、关键代码 height: 100vh 根据屏幕的高度去自适应 展示
&lt;div ref="vantaRef" style="width: 100%; height: 100vh"&gt;&lt;/div&gt; &lt;script&gt; import * as THREE from 'three'//导入样式 import BIRDS from 'vanta/src/vanta.birds'//导入动态样式逻辑 export default { data() { return {}; }, }, mounted() { this.vantaEffect = BIRDS({ el: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a06294720f6fdb28c5a04e8476e1347d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f955d441b4cacbf2483cf0f64663a4af/" rel="bookmark">
			【课程设计】数据库：火车票管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【课程设计】数据库：火车票管理系统 摘要：本文主要介绍了火车票管理系统，其中包括其选题功能概述，对该系统的方案方法设计，以及过程实现等内容。由于系统的代码量较大，因此将会较为抽象地对思想进行介绍，在必要时会举出一些实例，还会附上成果展示以及安装方法。最后补充一下这次团伙作案的心得体会，也是非常宝贵的财富。
文章目录 【课程设计】数据库：火车票管理系统引言——起因与动力一、选题背景二、方案论证（设计理念）2.1 运行和开发环境2.2 面向对象编程2.3 前后端分离2.4 数据库设计思路2.4.1 需求分析2.4.2 概念结构设计2.4.3 逻辑结构设计 2.5 软件框架与流程2.6 前端设计 三、过程论述3.1 任务分工3.2 整体框架3.3 前端开发3.4 图表绘制3.5 前后端交互3.6 应用层接口3.7 数据库编程 四、成果展示（部分）4.1 登录界面4.2 注册界面4.3 车次信息展示界面（与其他信息展示界面基本一致）4.4 营收报表界面4.5 售票员业绩界面 五、系统使用及测试用例（重要）六、心得体会6.1 小组协同6.2 数据库设计6.3 框架设计 引言——起因与动力 本系统是由五位华工学子（刘同学、陈同学、罗同学、鲁同学、卢同学）在课余时间中对数据库课程设计进行的一次尝试。起因在于，虽然我们都有部分项目经验，然而一般情况下，都是由导师为我们所引导安排去实施任务的，因此在此课程出来后，我们就商量着体验一次，从零开始的自主实现项目过程。这次课设为对我们自身的提升有很大的帮助，为此希望通过这篇文章分享出来。
对于该课设，对于我们的要求就是认真执行，定期开展组会与项目验收。在开发过程中，尝试了新的语言、开发工具以及开发模式等。其中最为印象深刻的是项目的集体讨论设计的过程、语雀gitee等协同开发工具、函数接口的注释标准化等细节内容、前端开发等初尝试。这些都是以往浅浅尝试过的内容，在本次课设中有了更丰富的知识获取。
当然，由于是第一次做如此大的工程，也遇到了一些困难的地方，比如在最初的数据库设定完成后，课设开展了一段时间，却发现设计内容需要修改，此时修改工程量较大，难免会出现一些烦躁情绪，当工作周期长时，也会出现部分拖沓懈怠，在小组之间的鼓励与监督下，完成让课设继续进行。可惜的是对于本系统由于时间较短，其实是开发并不完整的，而且存在并发性以及部分插入的等问题，但是这次课设体验非常难得，学到了许多课堂需不到的内容。
一、选题背景 本课题是实现对火车票售票的管理系统，具有售票系统、系统管理、综合查询等功能。该系统分为三大板块，分别为售票系统、系统管理和营收结算。以下是每个模块详细介绍。
售票管理：本系统主要功能包括：售当日票、预售票、退票、废票、选座位、站点班次查询、售票统计等。设计了多种售票模式，售票员可输入自定义站点编码或站点拼音代码，即可显示经过该站点的所有可售班次，班次车辆的座位状态实时、直观地显示并完成售票操作。对于售票员来说，可同时售数张相同或不同站点，相同或不同票种（全票、半票、优惠票）的车票，可以实现累加本次售票款，直至下次新售票开始。同时提供用户端，乘客也可以通过互联网购票。系统管理：用户管理、线路设置、站点设置、退票参数、预售票参数、票价设置等。该系统主要分为四大部分，分别为用户、车票、车次和路线板块，每个板块可以进行查询与修改操作。营收管理：售票员结算、汇总报表。对营收缴款进行管理，可以实时掌握车站营收情况，方便财务监督。能够快速、准确地生成各种营收结算报表，显著地提高了营收结算的工作质量和效率。 二、方案论证（设计理念） 2.1 运行和开发环境 操作系统：Windows10数据库：mysql集成开发环境：PycharmPython版本：3.9前端模块：pyqt5数据库模块：pymysql辅助工具：qtDesignerGit:https://gitee.com/youyouxingyuandao/database-course-design 2.2 面向对象编程 面向对象编程的优势在于易维护、开发效率高和易扩展等，对于易维护，只需维护局部模块，维护起来是非常方便和成本较低；对于开发效率高，在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类，通过对类的封装，对其的使用开发的效率和质量；易扩展由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。
前端面向对象编程体现于，每个界面的每个组件都设计为一个类，比如在管理端的用户信息展示窗口中，首先对分页器、用户信息栏、搜索框进行父类封装，在继承后，通过多态的编程思想，进行再封装，最后组装在一起。
后端面向对象编程体现于，对于数据库通过逻辑结构设计后，可以分析出各个实体类，进行面对对象的编程。不仅如此，由于设计部分工具操作，还额外定义了工具类，作为前端的辅助工具接口类。
2.3 前后端分离 对于前后端分离，可以提高工作效率，分工更加明确。两端开发可以同时进行，只需通过接口完成连接，双方互不干扰。可是为了在该次大作业中提高每位成员的参与度，因此在任务分配上，每个人都会有对前后端的工作安排。
2.4 数据库设计思路 2.4.1 需求分析 用户登录注册：用户包括工作人员和乘客，有管理员、售票员、乘客3类用户；普通人可以通过注册功能成为新用户，用户通过登录可以使用系统提供的相应功能，如添加乘客，购买车票，查询订单等等。
系统需要提供查询列车详细信息的功能：用户根据始发站和终点站，查询可以满足自己行程要求并且正常运行的列车，并且可以进一步查看开车时间，到达时间以及列车剩余座位的数量和票价；用户可以搜索具体的某一趟车次，可以得到该车次的具体路线信息以及发车时间。
系统需要提供售票功能：售票员输入站点即可显示经过该站点的所有可售班次以及班次车辆的座位状态；一个售票员可同时售数张相同或不同站点，相同或不同票种（一等、二等、站票）的车票，可以实现累加本次售票款，直至下次新售票开始；还应实现辅助提示应找款以及退票的功能，售票员可以查询当天售票帐单，乘客也可以通过互联网购票。
系统需要提供管理功能：包括用户管理、线路设置、站点设置、票价设置等。该系统主要分为四大部分，分别为用户、车票、车次和路线板块，每个板块可以进行查询与修改操作，管理员可以添加、修改和删除用户信息、线路信息、车票信息以及车次信息。
系统需要提供营收结算功能：包括售票员结算、汇总报表。对营收缴款进行管理，可以实时掌握车站营收情况，方便财务监督。能够快速、准确地生成各种营收结算报表。汇总报表主要包括：根据用户选择或者输入的各种条件（包括：时间，售票员，票号等）汇总车站运营数据，包括：售票汇总，退票汇总，预售票汇总，废票汇总，综合汇总，财务汇总，售票员结算单等等。
系统需要提供综合查询功能：包括：汇总线路、站点、班线、班次等各种基础数据；统计营运数据，生成日报表、月报表和任意时段报表；以汇总表形式，显示出售票张数、售票金额以及售票情况。
2.4.2 概念结构设计 admin管理员、user用户、sellers售票员实体：在该实体中，用户id为主键，用来作为每一个用户的唯一标识，同时也作为登陆系统的用户名使用；身份属性用于区分用户的类型，1为普通用户，2为管理员，3为售票员；每个用户都有唯一的身份证号和电话号码。 route路线实体：在该实体中，路线id为主键，用来作为每一条路线的唯一标识，另外还记录了该路线途径的每一站以及到达该站的时刻。 train车次实体：在该实体中，车次id为主键，用来作为每一个车次的唯一标识；不同车次的列车拥有自己的一等座数量、二等座数量和三等座数量；路线id作为该实体的外键与路线表相联系，该车次的一等座、二等座以及三等座的价格也通过对应路线的历时和价格参数计算出来。 ticket车票实体：在该实体中，车次id和发车日期作为联合主键，车次id作为外键与车次表相关联；一等座、二等座以及三等座剩余数量分别记录了某一车次某一日期当天的不同车票类型的剩余数量。 orders用户订单实体：在该实体中，订单id作为主键，用来作为每一份订单的唯一标识；对于每一份独立的订单，记录着用户购买某一张车票的所有信息：包括用户身份证号、购买车次id、车票类型（一等座、二等座和三等座）、该车票的价格、下单时间、起始站、终点站、出发时间、账单id以及是否发生退票行为（1为发生了退票 2为未发生退票）；其中车次id作为该实体类型的外键与车次表相关联，可以对应到相关车次的具体信息。 bill用户账单实体：在该实体中，账单id作为主键，用来作为每一份账单的唯一标识；售票员id作为外键与用户表相关联，且该用户身份属性的值为3，代表着该账单对应的某一个售票员；订单id作为外键与订单表相关联，用于记录该订单属于某一账单，一份账单可以对应到多份订单；此外该实体还包括应付金额和实付金额这两个属性，通过这两个属性可以计算出找零金额。 整体E-R图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f955d441b4cacbf2483cf0f64663a4af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd35dd8c40d31d570130f90097d9ff1/" rel="bookmark">
			Python爬虫（1）一次性搞定Selenium(新版)8种find_element元素定位方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		selenium中有8种不错的元素定位方式，每个方式和应用场景都不一样，需要根据自己的使用情况来进行修改
8种find_element元素定位方式 1.id定位2.CSS定位3.XPATH定位4.name定位5.class_name定位6.Link_Text定位7.PARTIAL_LINK_TEXT定位8.TAG_NAME定位总结 目前selenium已经出现了新的版本的定位方式，虽然说定位语法不一样，但是万变不离其宗。
用旧版的定位语法就会出现这个删除线，你用他来进行爬虫的时候运行时就会提示你虽然问题不大但是还是得考虑使用新版本的定位方式
DeprecationWarning: find_element_by_css_selector is deprecated. Please use find_element(by=By.CSS_SELECTOR, value=css_selector) instead line = li.find_element_by_css_selector("p.title a ").get_attribute('href') selenium中find_element定位方式 find_element(By.XPATH) find_element(By.CSS_SELECTOR) find_element(By.ID) find_element(By.TAG_NAME) find_element(By.class_name,) find_element(By.PARTIAL_LINK_TEXT) find_element(By.LINK_TEXT) find_element(By.name) 上面定位元素方法主要是单个，多个元素定位就在element后面加个s
1.id定位 在网站中有很多的id，我们可以通过找到这些id来帮助我们定位网页中的元素，但是id定位有缺点就是id元素往往是单一个存在，如果我们需要定位多个id的话id定位就不好帮助我们进行定位。
from selenium import webdriver from selenium.webdriver import Chrome, ChromeOptions from selenium.webdriver.common.by import By opt = ChromeOptions() # 创建Chrome参数对象 opt.headless = True # 把Chrome设置成可视化无界面模式，windows/Linux 皆可 driver = webdriver.Chrome() driver.get("网址") a1 = driver.find_element(By.ID,'livenews-id-1-202301272620080422').text print(a1) 2.CSS定位 css定位是最佳推荐的定位元素，不仅仅效率高，而且针对复杂场景的多个元素定位需求会比xpath和其他元素定位更好
在网页中快速定位我一般都是在开发者工具中找到selector然后针对这个标签进行选择
#livenews-id-1-202301272620081211 &gt; div.media-content &gt; h2 &gt; a
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fd35dd8c40d31d570130f90097d9ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444399d0b7a87752be2ce8427b2408eb/" rel="bookmark">
			2023最新pytorch安装教程，简单易懂，面向初学者（Anaconda&#43;GPU）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 目前是2023.1.27,鉴于本人安装过程中踩得坑，安装之前我先给即将安装pytorch的各位提个醒，有以下几点需要注意
1.判断自己电脑是否有GPU 注意这点很重要，本教程面向有NVIDA显卡的电脑，如果你的电脑没有GPU或者使用AMD显卡，请安装CPU版本的pytorch。AMD显卡本人并不清楚具体如何操作，不在此赘述。
2.选择合适的pytorch版本，具体方法后面会说 3.更新显卡驱动，最好是比较新的版本，这样不容易产生版本不匹配的问题，造成不必要的麻烦 二、下载安装 Anaconda 1.官网下载 下载速度较慢，官网地址: Anaconda
选择 Products -&gt; Anaconda Distribution
点击 Download，可以下载最新版本
2.镜像下载 采用开源镜像网站进行下载，速度能快一点，网速不行的同学建议使用这个方法。
链接: 开源镜像
根据需求选择合适的版本下载
3.安装Anaconda 双击运行安装包，选择all users
建议装C盘，地方不够也可以装别的盘，目前我用着还没有啥问题。
安装路径保持英文即可。
环境变量那一块，可以勾选自动添加，也可以手动添加。
添加方法比较繁琐，不再赘述。
安装完毕，调用命令行,输入
python 查看python环境，正常如下：
输入
conda --version 查看安装是否成功
显示如下：
代表环境变量配置成功。
三、使用conda下载pytorch 1.创建虚拟环境 （1）利用 conda create 指令创建新的虚拟环境
在应用列表里找到Anaconda文件夹，点击anconda prompt，进入命令行，输入以下代码，创建一个虚拟环境。
conda create –n 虚拟环境名字 python=版本 我的是python3.8,所以具体代码为
conda create -n pytorch python=3.8 （2）输入y进行下载
（3）安装完成后，输入
conda info --envs 验证是否成功安装，如果出现
代表成功。
（3）如若有同学下载速度慢，可以使用镜像下载
代码格式为
conda create –n 虚拟环境名字 python=版本 –c 镜像地址 这是镜像下载的一种方法，推荐大家使用后面接-c 镜像地址的方法进行镜像下载，尽量不要修改配置文件，我一开始看的某些教程修改文件后一直无法下载，建议不要使用，会导致一些奇奇怪怪的错误。如果要修改，建议先备份原始的配置代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444399d0b7a87752be2ce8427b2408eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daeb903d449fa39d53de651e3556fe57/" rel="bookmark">
			大数据技术之Hadoop(十一)——网站流量日志数据分析系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
素材：
一、模块开发——数据预处理
1、分析预处理的数据
2、实现数据的预处理
（1）创建Maven项目，添加相关依赖
（2）创建JavaBean对象，封装日志记录
（3）创建MapReduce程序，执行数据预处理
二、模块开发——数据仓库开发
1、上传文件
2、实现数据仓库
三、模块开发——数据分析
四、模块开发——数据导出
五、模块开发——日志分析系统报表展示
1、搭建日志分析系统
（1）创建项目，添加相关依赖
（2）编写配置文件
2、实现报表功能展示
（1）创建持久化类
（2）实现DAO层
（3）实现Service层
（4）实现Controller层
（5）实现页面功能
3、系统功能模块展示
​编辑
参考书籍：
素材： http://链接: https://pan.baidu.com/s/1aNxbVjNq1z1A-oOIYy_E4Q?pwd=gjpt 提取码: gjpthttp://链接: https://pan.baidu.com/s/1aNxbVjNq1z1A-oOIYy_E4Q?pwd=gjpt 提取码: gjpt
一、模块开发——数据预处理 1、分析预处理的数据 在收集的日志文件中，通常情况下，不能直接将日志文件进行数据分析，这是因为日志文件中有许多不合法的数据(比如日志数据在网络传输过程中发送数据丢失)。
在数据预处理阶段,主要目的就是对收集的原始数据进行清洗和筛选，因此使用MapReduce 技术就可以轻松实现。在实际开发中，数据预处理过程通常不会直接将不合法的数据直接删除，而是对每条数据添加标识字段，从而避免其他业务使用时丢失数据。
另外,此次数据预处理只是清洗和筛选不合法的数据信息，会读取每行日志文件数据并最终输出一条数据，不会进行其他操作，因此在使用MapReduce技术进行处理过程中，只会涉及 Map 阶段，不会涉及Reduce 阶段。在默认情况下，ReduceTask值为1，因此在主运行函数中，需要设置 Job.setNumReduceTasks(0)。
2、实现数据的预处理 （1）创建Maven项目，添加相关依赖 pom.xml文件配置如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;HadoopDataReport&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daeb903d449fa39d53de651e3556fe57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e1aa2391fbedc578c6d27ce942f1ca/" rel="bookmark">
			点云数据的语义分割算法综述总结大全（传统方法&#43;基于深度学习的方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 传统方法
1.1基于边缘信息的分割
1.2基于模型拟合的分割
1.3基于区域增长的分割
1.4基于属性的分割
1.5基于图优化的分割
2基于深度学习的方法
2.1基于投影的分割
2.1.1多视图表示
2.1.2球状表示
2.2基于体素的分割
2.3基于点的分割
2.3.1 逐点MLP方法
2.3.2 点卷积方法
2.3.3 基于RNN的方法
2.3.4 基于图优化的分割
3 总结
相比较于2D数据（图像数据），三维点云数据大多是非规则化、非结构化并且无序的，保留了原始的几何信息在三维空间中，虽然可以获取对象的形状大小，但对其空间位置、几何属性、实质属性等特征的分割也带来了更多的问题。加上其采集过程中，光线以及设备角度变化的速率造成采集的点数据的密度分布不均，点云语义分割仍面临一系列的问题。
早期也有不少人尝试在点云分割领域做研究，这些传统的分割方法也取得了一定的效果，但大多受限于特定的场景和先验知识，无法推广应用，并且比较耗时。
随着近些年来深度学习的快速发展，点云语义分割的研究重点也转移到以深度学习为首的相关方法上。这些方法相较于早期的传统方法，分割的准确度有了极大的提升，尤其是直接在点云上处理数据的思想被提出以后，越来越多的人开始倾向于直接在点云上进行处理，来充分利用3D点云中所包含的丰富的空间信息。
1 传统方法 在深度学习应用于点云分割领域之前，已经有相当多的方法在尝试点云的分割，这些传统的点云分割方法主要依赖于几何约束和统计规则来人工设计物体的特征，将原始的点云数据分为不重叠的几组区域，来对应场景中的各个对象，虽然效果不太理想，但思想仍然有可借鉴的地方，这些方法可分以下四个方面。
1.1基于边缘信息的分割 基于边缘的分割方法是通过识别亮度突变点来识别边缘信息，从而描述物体的形状，再对这些边缘信息点进行分组来确定最终的分割结果。
该方法分割速度较快，但缺点是准确度比较低，对于密度不均匀或稀疏的点云很敏感，还会受到噪声的干扰。
1.2基于模型拟合的分割 基于模型拟合的分割是以点云数据的分类和几何形状为基础的，将点云与已知的几何图形进行对比匹配（如圆柱体、圆锥体、球体等）将具有相同数学特征的点划为一类，从而在点云中分割出已知的几何形状，
该方法主要是基于数学原理的分割方法，与基于边缘信息的分割相比，不仅受噪声干扰小，还有较快的计算速度。
1.3基于区域增长的分割 以区域为基础的分割方法就是对点云区域进行分割，根据一定的差异准则，将差异性小的点云归为同一区域。具体分为种子和非种子区域方法。
种子区域首先需要选取多个种子点作为起始点，依据设定好的生长规则，在种子周围添加特征相似度高的邻域点，使其邻域空间生长扩散，再以此邻域点作为新的种子点重复以上生长过程。种子区域分割受噪声影响较大，计算时间较长。另外，该方法的分割精度很大程度受初始种子点选取的影响，因此，如何选择合适的初始种子点是该方法的关键点和难点。
非种子区域则是先将空间域所有的点归为同一区域，再对该区域进行进一步细分。和种子区域相比，非种子区域分割的缺点在于难以细分位置，而且存在分割过度的情况，分割的精度对先验知识的要求较高。
1.4基于属性的分割 先根据点云属性进行计算，将计算得到的点的属性进行聚类，为每一个点定义一个特征向量，相似的特征向量将会被归于一类，以此来完成分割。
该方法可以较好的解决噪声和异常值的影响，但缺点是对点云密度要求高且计算时间较长。
1.5基于图优化的分割 基于图的分割方法通过建立点之间的关系，将点云数据转变为图数据，再对这个图数据进行卷积计算，即选用合适的图卷积神经网络对其进行表征学习。
该方法的优点是图卷积能够聚合物体的点集特征，并且保持其三维空间的平移不变性，但怎么合适地建立点与点之间的关系还是一个待解决地难题。
2基于深度学习的方法 随着深度学习的发展，计算机视觉的各个领域已经越来越离不开深度学习。利用深度学习处理2D图像数据的技术已经十分成熟并且取得了很好的效果。近年来越来越多的研究者将目光投向利用深度神经网络处理点云。
二维的数字图像是由像素组成矩阵构成的，很容易的在计算机中进行表示。但三维的点云数据由空间中无序的点构成，很难在计算机中直接处理。因此需要将点云转化适合卷积神经网络(Convolutional Neural Network,CNN)处理的规则结构。
主要有以下方式:基于投影、基于体素和基于点的分割。
2.1基于投影的分割 2.1.1多视图表示 早期的深度学习方法尝试将3D点云投影到2D平面上，然后基于CNN的网络模型来对数据进行处理。这个方法解决了三维点云数据难以处理的问题，利用CNN提取平面投影的特征，将多视图的平面投影特征聚合在一起，通过全连接层和池化层得到语义分割的结果。
图2.1 基于多视图表示的代表性网络结构
Fig.2.1 Representative network structure based on multi-view approach
由于三维点云被投影到二维图像上会受到不同视点选择和投影角度的影响，导致图像丢失部分可用的空间集合信息，一定程度上会造成分割精度的下降，而这个缺点是该算法难以避免的。
2.1.2球状表示 激光雷达扫描后的点云的几何形状类似一个空心圆柱体，从垂直与圆柱体主轴的方向来看空心圆柱时，可以将其理解为一个环绕的平面图像，这样就可用球状投影图像来表示三维点云。
此方法突出特点是速度快，相较于多视图投影，球面投影方式保留了更多的点云信息，但对于多视图存在的遮挡物问题，球面投影方式仍无法解决。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e1aa2391fbedc578c6d27ce942f1ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7aa6d91adc4b9d3e443fa1a53d1bad2/" rel="bookmark">
			利用Python暴力破解邻居家WiFi密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如觉得博主文章写的不错或对你有所帮助的话，还望大家多多支持呀！关注、点赞、收藏、评论。
文章目录 一、编写代码二、展示测试结果三、测试四、生成密码本（建议自己找一个密码本） 一、编写代码 在桌面新建一个文件
如果你新建的文件没有后缀名.txt，请进行如下设置
打开刚刚新建的文件，下面代码写入文件，保存
# coding:utf-8 import pywifi from pywifi import const import time import datetime #测试连接，返回链接结果 def wifiConnect(pwd): #抓取网卡接口 wifi=pywifi.PyWiFi() #获取第一个无线网卡 ifaces=wifi.interfaces()[0] #断开所有连接 ifaces.disconnect() time.sleep(1) wifistatus=ifaces.status() if wifistatus ==const.IFACE_DISCONNECTED: #创建WiFi连接文件 profile=pywifi.Profile() #要连接WiFi的名称 profile.ssid="TP-LINK_1301" #网卡的开放状态 profile.auth=const.AUTH_ALG_OPEN #wifi加密算法,一般wifi加密算法为wps profile.akm.append(const.AKM_TYPE_WPA2PSK) #加密单元 profile.cipher=const.CIPHER_TYPE_CCMP #调用密码 profile.key=pwd #删除所有连接过的wifi文件 ifaces.remove_all_network_profiles() #设定新的连接文件 tep_profile=ifaces.add_network_profile(profile) ifaces.connect(tep_profile) #wifi连接时间 time.sleep(1) if ifaces.status()==const.IFACE_CONNECTED: return True else: return False else: print("已有wifi连接") #读取密码本 def readPassword(): print("开始破解:") #密码本路径 path="C:\\Users\\糖果\\Desktop\\Markdown学习\\pwd.txt" #打开文件 file=open(path,"r") while True: try: #一行一行读取 pad=file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7aa6d91adc4b9d3e443fa1a53d1bad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d875d18a4a76611d20228c8cb24e0fc3/" rel="bookmark">
			Python对职业人群体检数据进行分析与可视化（附源码 超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要源码和数据集请点赞关注收藏后评论区留言私信~~~
职业人群体检数据分析 有的职业危害因素会对人体血液等系统产生影响。下面针对一次职业人群体检的部分数据进行分析
实现步骤如下
1：导入模块
2：获取数据
导入待处理数据testdata.xls并显示前五行
3：分析数据
首先查看数据类型 表结构 并统计各个字段空缺值的个数
接下来删除全为空的列以及身份证号为空的数据
删除全为空的列
DataFrame.dropna(axis=0, how='any', thresh=None, subset=None, inplace=False)
函数作用：删除含有空值的行或列¶
axis:维度，axis=0表示index行,axis=1表示columns列，默认为0
how:"all"表示这一行或列中的元素全部缺失（为nan）才删除这一行或列，"any"表示这一行或列中只要有元素缺失，就删除这一行或列
thresh:一行或一列中至少出现了thresh个才删除。
subset：在某些列的子集中选择出现了缺失值的列删除，不在子集中的含有缺失值得列或行不会删除（有axis决定是行还是列）
inplace：刷选过缺失值得新数据是存为副本还是直接在原数据上进行修改
删除身份证号为空的数据
将“开始从事某工作年份”规范为4位数字年份，如“2018”，并将列名修改为“参加工作时间
增加列“工龄”（体检年份-参加工作时间）和“年龄”（体检时间-出生年份）两列
查看待处理是否有缺失值 然后删除所有缺失值 然后可以看到参加工作时间之一列的缺失值已经删除，同时也看到体检年份还有38个缺失值 也进行删除
身份证号，参加工作时间以及体检年份的数据类型都是object，需要进行类型转换，统一转化为int64类型，另外，体检年份这一列有很多异常数据，很多年份后都有年字，对体检年份数据进行时间提取
增加工龄和年龄这两列
统计不同性别的白细胞计数均值 并画出柱状图
统计不同年龄段的白细胞计数，并画出柱状图，年龄段划分为：小于或等于30岁，31-40岁，41-50岁以及大于50岁4个
经过上面这一系列工作，可以很清楚的看出数据的一些分布特征 有助于后续的解决方案
代码 部分代码如下 需要全部代码请点赞关注收藏后评论区留言私信~~~
import pandas as pd import numpy as np import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] #用来正常显示中文标签 plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 %matplotlib inline df = pd.read_excel("testdata.xls")#这个会直接默认读取到这个Excel的第一个表单 data =df.head()#默认读取前5行的数据 data df.info() df.dtypes df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d875d18a4a76611d20228c8cb24e0fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2dbca4525f3eaa233e0c28b275f1b8e/" rel="bookmark">
			【数据挖掘】葡萄酒质量分析及异常值检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍 葡萄酒在人类历史中扮演着非常重要的角色，它能舒缓疲劳、减轻病痛、消毒杀菌、美容养颜等等直到19世纪晚期，葡萄酒都是西方医学中不可缺少的用品，适量饮用对人的身体会有益处。无论是用于交际会谈，还是滋身养颜，优良的葡萄酒因其独特的风味与绝佳的品质往往具有高昂的价格。因而，葡萄酒的质量评估成为酒品酿造行业的重要过程。
通常情况下，我们根据葡萄酒的理化性质及行业的前导经验判断葡萄酒的品质。本次实验，我们基于葡萄酒数据集，通过数据挖掘的方法实现了对数据集的可视化及数据清洗，利用异常检测的方法筛除劣质葡萄酒。
数据可视化探索分析 2.1. 数据整体情况介绍 数据来源于UCI机器学习库中与葡萄牙“Vinho Verde”葡萄酒的红白变体（白葡萄酒和红葡萄酒）有关的两个数据集。“Vinho Verde”葡萄酒是葡萄牙米尼奥（西北）地区的独特产品，由于其酒精含量适、新鲜度高等特点受到市场欢迎。
我们得到原始的葡萄酒数据集，利用info函数查看数据集基本情况：
可以得知，总数据量为6497条，包含13种属性，其中葡萄酒种类（type）为object类型，感官评分（quality）为int类型，其余属性均为float类型。数据集中的各属性描述如表1所示：
Field
Attribute
Description
type
类型
葡萄酒种类：白葡萄酒和红葡萄酒
fixed acidity
固定酸度
固定酸度是由于葡萄酒中存在非挥发性酸。例如，酒石酸、柠檬酸或苹果酸。这种酸结合了葡萄酒味道的平衡，使味道清新
volatile acidity
挥发性酸度
挥发性酸度是葡萄酒中可以通过嗅觉闻到的酸的一部分，是最常见的缺陷之一。葡萄酒中醋酸的含量过高会导致令人不愉快的醋味
citric acid
柠檬酸
可以用于葡萄酒的酸处理（增加酸度）、收集葡萄酒、清洗过滤器以防真菌和霉菌感染。少量柠檬酸可以增加葡萄酒的“新鲜度”和风味
residual sugar
残糖
发酵停止后剩余的糖量
chlorides
氯化物
葡萄酒中部分矿物质（例如盐）的含量
free sulfur dioxide
游离二氧化硫
游离形式的二氧化硫在分子SO₂（作为溶解气体）和亚硫酸氢根离子之间存在平衡；它可以防止微生物的生长和葡萄酒的氧化
total sulfur dioxide
二氧化硫总量
游离和结合形式的SO₂的量;在低浓度下，SO₂在葡萄酒中几乎检测不到，但在游离SO₂浓度超过50ppm时，SO₂在酒的鼻子和味道中变得明显
density
密度
葡萄酒的密度可以小于或大于水，其值主要由酒精浓度和糖的含量决定
pH
酸碱度
描述葡萄酒的酸度或碱度从0（非常酸性）到14（非常碱性）
sulphates
硫酸盐
一种葡萄酒添加剂，可以促进二氧化硫气体（SO₂）水平，作为抗菌剂和抗氧化剂
alcohol
酒精
葡萄酒的酒精含量百分比
quality
基于感官的评分
多名葡萄酒专家根据个人感官感受对这些酒做了评分，分数在0（⾮常差）和10（⾮常好）之间，仅作为最后预测效果的参考
表1 葡萄酒数据集属性介绍
作为一种常见的饮品，我国对葡萄酒的理化性质有着明确的规定。根据国家质量监督检验检疫总局颁布的GB/T 15037-2006 葡萄酒国家标准，我们了解到葡萄酒的基本理化要求，明确葡萄酒数据字段值范围的强制要求，方便后续处理可能的异常值时，能够较好地根据酒类学理论及国标对其进行处理。
结合上述图表，我们对数据集中各字段及酒品的特征要求进行分析：
查阅资料可知，葡萄酒的三大基本特征是酸度、酒精和甜味。
酸度可以从两方面考虑。一方面，酸可分为fixed acidity（固定酸）和volatile acidity（挥发酸），其总含量反映葡萄酒浓度。其中citric acid（柠檬酸）及挥发酸的含量能够较好地反映葡萄酒的健康状态，帮助我们判断葡萄酒的质量、预测贮藏的困难程度。另一方面，pH（酸碱度）同样可以指示酸度，反映葡萄酒品尝起来口感的浓郁度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2dbca4525f3eaa233e0c28b275f1b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6402326b6557a8822faa0e89eef313/" rel="bookmark">
			YOLOv5实现目标识别全流程【超级详细！】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题背景 在深度学习中，目标识别问题是我们所熟知的最经典最重要的问题之一。目标识别需要在一幅大图片中定位到多个目标的位置和类别。目标检测的应用范围很广，比如在超市通过视频检测消费者的进出、工业制造业领域中的异常行为检测等。另一个典型的场景是，在自动驾驶时车辆需要定位视线范围内的所有物体，并识别其类别以判断危险程度。这都给目标检测这一领域提供了丰富的应用空间。
2. 模型介绍 2.1 YOLO简介 YOLO的名字来历颇有意思，他的本意是流行语You Only Live Once的缩写，而模型的作者Joseph Redmon改了一个词将You Only Look One作为模型的名字。这是由于，相对于R-CNN系列算法将检测问题分解为划定位置和判定类别分两步做，YOLO系列算法没有显式寻找区域的过程，可以实现端到端的快速预测，即输入一幅图片，在输出中给出若干目标的位置、类别和置信度。
而相对于同样是一步到位的SSD算法，YOLO系列的特点在于算法一经发出，便有各种各样的人和团队对他进行更新迭代。通过不断地更新迭代模型版本，YOLO也得到了效果上持续的提升和更广泛的关注。但值得注意的是，YOLO模型的原作者Joseph Redmon更新到v3版本后就退出了相关的研究，而后续的版本都是其他研究人员的工作。今天介绍的YOLOv5就是由ultralytics团队进行研发和维护。（相关资料可以登录其官方网站https://ultralytics.com/进行了解，也可以下载ultralytics APP体验目标识别效果）
2.2 YOLO模型介绍 我们首先介绍一下最原始的YOLO模型，然后简要介绍一下YOLOv5版本的改进，主要通过具体的例子一起看看怎么把YOLOv5模型用好。
YOLOv1的网络结构并没有什么特别，和我们熟悉的图像分类一样都是卷积神经网络，但它的输出向量却不太一样。如果把神经网络看作我们熟悉的回归分析问题，那YOLO做的事情就是改变了模型响应Y的结构，而这也奠定了YOLO目标检测的基础。YOLO的输出向量不仅包括目标的类别，还有边界框的坐标和预测的置信度。它的核心思想在于把图像分割成S*S的若干个小块，在每个格子中预先放置两个边界框，通过卷积神经网络预测得到每个边界框的坐标、类别和置信度，然后通过非极大值抑制获得局部唯一的预测框。
经过若干年的版本迭代，YOLOv5的网络结构博采众长，已经变得格外复杂，主要包括在Backbone中通过卷积和池化网络结构提取特征，在Neck部分不断地和之前提取的特征进行融合，Head部分则是用来进行最终的检测和输出，如下图所示。
我们今天选取YOLOv5作为介绍，一方面是因为从最终效果来看YOLOv5已经相当优秀，是发展的比较完备、使用比较广泛的一个版本；而更重要的是YOLOv5的调用、训练和预测都十分方便，为初学者提供了良好的练手工具。YOLOv5的另一个特点就是它为不同的设备需求和不同的应用场景提供了大小和参数数量不同的网络。
如图所示，大一点的模型比如YOLOv5l和YOLOv5x参数更多，在大规模的COCO数据集上有更高的预测准确率；而小模型比如YOLOv5n或YOLOv5s占空间更小，适合部署在移动设备上，且推理速度更快，适合于高帧率视频的实时检测。
3. 数据介绍 3.1 数据标注格式转换 我们采用真实公开的人脸识别数据集WIDER FACE进行YOLOv5模型的训练和测试，数据开源于http://shuoyang1213.me/WIDERFACE/ 。数据集相关信息可以访问网站主页。
为了进行目标检测，一个重要的步骤是进行数据标注。如果数据集已经完成标注的，则可以考虑是否需要格式转换。
下面以WIDER人脸数据集为例
1.下载下面的四个压缩包，并放在同一个文件夹内
WIDER Face Training Images
WIDER Face Validation Images
WIDER Face Testing Images
Face annotations
2. 在同一目录下解压4个压缩包，在当前目录下运行convert.py 转化为VOC格式数据集，完整代码如下：
（转化好的完整的voc格式的人脸数据集，https://pan.baidu.com/s/19w9vLbqovjL6-apH-RmwFQ，提取码：2cv4）
# -*- coding: utf-8 -*- import shutil import random import os import string from skimage import io headstr = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df6402326b6557a8822faa0e89eef313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1695b3c551c30e9c1e4537b76fe5e35/" rel="bookmark">
			Python数据库操作 ---- pymysql教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前提准备连接数据库创建数据库创建数据表、插入数据查询数据更新数据删除数据实战应用总结 前提准备 安装mysql
在使用pymysql的前提就是又一个mysql数据库，这个数据库可以是本地数据库也可以是远程的数据库,
mysql的安装这里就不再赘述了，大家可以参考其他的模块进行安装
安装pymysql
pip install pymysql 连接数据库 import pymysql # 连接数据库 db = pymysql.connect(host='localhost',user='root',password='123456',port=3306) # 创建数据库的游标 cursor = db.cursor() #execute()方法并执行 SQL 语句 cursor.execute("select version()") # 读取第一条数据 data = cursor.fetchone() print(data) # 关闭连接 db.close() # 输出: # ('8.0.24',) 解释：
在连接数据的时候需要指定相应的参数
host 数据库ip地址，如果是本地可以用localhost或127.0.0.1 如果是远程就需要指定正确的ip地址user 用户名password 密码port 端口号 如果不指定就默认是3306 cursor()：获取数据库的操作游标
execute() 执行SQL语句，把要进操作的内容写成SQL语句，
fetchone() 读取一条数据
close() 断开连接，释放资源
“select version()” sql语句的执行结果
创建数据库 import pymysql # 连接数据库 db = pymysql.connect(host='localhost',user='root',password='123456') # 创建数据库的游标 cursor = db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1695b3c551c30e9c1e4537b76fe5e35/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/616/">«</a>
	<span class="pagination__item pagination__item--current">617/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/618/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>