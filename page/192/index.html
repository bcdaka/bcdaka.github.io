<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50e12396d067bfc6c8ce2d88c4e0ceb/" rel="bookmark">
			通过 Wi-Fi 在 Android 设备之间传输文件的 5 种简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有线传输通常很麻烦，尤其是当您身边没有 USB 电缆和计算机时。因此，通过 Wi-Fi 在 Android 设备之间传输文件更方便。但是，许多人可能不知道如何在 Android 手机之间通过 Wi-Fi 传输数据。不用担心，这篇文章解释了如何以 5 种常用的方式做到这一点。
方式 1：如何使用 Coolmuster Mobile Transfer 通过 Wi-Fi 在 Android 设备之间传输文件 在 Android 手机之间传输文件的最快方法是使用 Coolmuster Mobile Transfer。通过稳定的 Wi-Fi 网络连接两部 Android 手机，您可以一键将音乐、联系人、应用程序、通话记录、短信、照片、视频和电子书从 Android 传输到 Android，没有数据限制。此外，该程序还允许您通过 Wi-Fi 网络将文件从 iOS 传输到 iOS、Android 到 iOS 以及 iOS 传输到 Android。
你能用 Coolmuster Mobile Transfer 做什么？ 一键式通过 Wi-Fi 在 Android 手机之间共享联系人、音乐、短信、通话记录、照片、应用程序、视频和电子书。通过 Wi-Fi 直接将数据从 iOS 传输到 iOS、iOS 到 Android 和 Android 到 iOS。连接方便，速度快，安全性高。广泛兼容 Android 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50e12396d067bfc6c8ce2d88c4e0ceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca04a8dfa2d851cc5c6025a0c6541ec8/" rel="bookmark">
			Vue iview-ui 被tooltip包裹的标题，点击跳转后，提示框不消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tooltip包裹的标题，点击跳转后，提示框不消失 就会有这种显示问题 下面这种错误方法不可行，解决办法往下翻 css写得没错，问题出在Javascript当中的 getElementsByClassName(“xxabc”)，
这个方法得到的是一个由class="xxx"的所有元素组成的集合，而不是单个元素；
集合是没有display属性的，集合中的元素才有display属性。当你试图做 集合.style.display的时候，自然会报错。
所以你这个问题的解决方案应该是：遍历集合中所有的元素，然后给每个元素都加上display="none"的属性
解决方法如下 &lt;p v-for="(value, key) in item.data" :key="key" class="itemTxt" @click="toClaimReceiptList(key)"&gt; &lt;template v-if="key=='头程待合单数'"&gt; &lt;Tooltip placement="right" transfer-class-name="xxabc"&gt; &lt;span style="color: blueviolet;cursor: pointer;"&gt; *{{ key }} &lt;/span&gt; &lt;span class="itemNum"&gt;({{ value }})&lt;/span&gt; &lt;div slot="content"&gt; &lt;div class="Errata"&gt; &lt;p v-for="(item1, idx1) in platformCountObj" :key="idx1 + '_1'"&gt; {{ item1.platform }}：{{ item1.count }} &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Tooltip&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;span&gt;{{ key }}&lt;/span&gt; &lt;span class="itemNum"&gt;({{ value }})&lt;/span&gt; &lt;/template&gt; &lt;/p&gt; js var divset = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca04a8dfa2d851cc5c6025a0c6541ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e488911ee06bb131e9eeb70bc40aee15/" rel="bookmark">
			tongweb 部署软航流版签一体化应用示例 提示跨域错误CORS ERROR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题现象与描述
解决办法
原理解析
什么是CORS
浏览器跨域请求限制
跨域问题解决方法
跨域请求流程
浏览器请求分类解析
http请求方法简介
问题现象与描述 重庆软航科技有限公司提供了一套针对针对word、excel等流式文件转换成PDF版式文件并进行版式文件在线签章的一个方案，给方案做了一个应用示例，该示例在完成流式文件转成PDF版式文件之后展示了一个在线阅读转换后PDF文件并在线签章的相关功能。
但是在tongweb上部署之后发现该示例完成word转PDF功能后的在线查看PDF时功能异常，浏览器中F12调试 发现状态信息不为200而是 CORS error，如下图所示：
该功能对应的请求 已配置请求头信息：Access-Control-Allow-Origin为*
查看详细的信息时发现：Referrer Policy为same-origin：
且 该应用在tomcat中 部署时并未出现此类异常，因此可以断定示例本身是没有问题的。
猜想可能是由于tongweb的配置影响了。
说一下示例所需要的资源部署情况：将其需要的软航电子签章系统、软航版式文档签批系统、软航文档转换系统以及软航提供的结合这几个一体化应用示例都部署到了同一台服务器的tongweb上了。
解决办法 打开tongweb 管理控制台，在【WEB容器配置】中选择【HTTP通道管理】选择【tong-http-listener】：
下拉到【其他设置】：
在其他设置这里有一个：禁用HTTP请求方法
将禁用的OPTIONS方法放开（勾选取消掉）：
之后 重启tongweb ，再试就可以解决 CORS error 问题了。
原理解析 什么是CORS CORS：即跨域（Cross-Origin Resource Sharing, CORS）是一种安全策略，由浏览器 enforced，限制跨域 HTTP 请求，指在一个域下的网页尝试访问另一个域下的资源。在web应用中服务器地址、端口、项目但凡有一个不同，访问的资源不是自己的，那就属于跨域。例如部署在A服务器上的appA项目，那么 在appA中访问 B服务器上的appB ,或者访问服务器A上的其他应用appx 都属于跨域。
跨域问题主要发生在浏览器端，服务器端由于协议设计的原因，不存在跨域问题。浏览器端跨域请求主要涉及到同源策略（Same-Origin Policy），同源策略限制了从一个源加载的文档或脚本与另一个源的资源进行交互。
浏览器跨域请求限制 浏览器默认是禁用跨域请求的，主要体现在以下方面：
（1）HTTP 请求方法：通常只允许 GET、POST 和 HEAD 请求。
（2）HTTP 头信息：无法发送 Cookie、HTTP 认证信息（如 Basic Auth）等。
（3）HTTP 响应：无法读取非简单响应内容，如 JSONP 只支持 JSON 格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e488911ee06bb131e9eeb70bc40aee15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1feea56d899fed490f849ec3d99cf48/" rel="bookmark">
			数学建模----滑翔伞伞翼面积的设计及运动状态描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 滑翔伞作为一项融合了挑战、冒险和刺激于一体的运动，近年来在全球范围内受到了广泛的关注。滑翔伞在救援、探险、体育、娱乐、环保和交通等领域的应用展现了其重要价值。然而，中国在滑翔伞领域尚未取得突破，缺乏全球影响力和竞争力。因此，设计一款安全、灵活、可控的滑翔伞对于中国滑翔伞行业的发展和全球滑翔伞科技的进步具有重要意义。
问题分析与思路 背景 滑翔伞在全球范围内应用广泛，但中国在这一领域仍处于初级阶段，设计符合中国使用习惯的滑翔伞对于推动滑翔伞运动的普及和发展具有重要作用。
问题提出 本文旨在研究并解决以下问题：
设计滑翔伞伞翼面积模型，并求解最小平展面积。建立无风状态下滑翔伞的飞行模型，分析其运动过程和操纵策略。在平均风状态下，建立滑翔伞的飞行模型，分析其运动过程和操纵策略。 整体建立模型以及各符号含义如下：
问题一：滑翔伞伞翼面积设计 研究思路 设计滑翔伞伞翼面积需要考虑负载能力、安全飞行速度、安全降落速度、起飞高度和滑翔性能等因素。结合这些因素建立数学模型，通过遗传算法和模拟退火算法求解，以获得最小的伞翼平展面积。
模型建立 结合设计滑翔伞伞翼需要考虑的因素，将滑翔伞伞翼最小平展面积模型建立问题转化为最优化问题，其目标是最小化滑翔伞伞翼面积，并且同时满足总重量约束、升力约束、安全飞行速度约束、安全降落速度约束以及平展宽度、投影宽度、最大弦长和气室数量等约束条件。
通过建立约束条件和目标函数，将数学模型转化为一个优化问题。 根据问题一的要求和给定参数， 需要将这些参数转化为数学表达式，以便建立数学模型。
首 先 ， 考 虑 人 的 重 量 范 围 和 滑 翔 伞 的 重 量 范 围 ， 将 其 表 示 为Pw_min、Pw_max 和 W_min、W_max。然后，定义总重量m为这些参数的平均值，即 m = (PW_min + PW_max) / 2 + (W_min + W_max) / 2。
为了确保滑翔伞的安全性和性能，需要定义一系列约束条件。根据问题一的要求和给定参数， 可以得到以下约束条件：
（1）升力约束：根据物体在地球上的重力加速度， 可以计算滑翔伞所需的最小升力L_min = W * 9.8
（2）安全飞行速度约束：滑翔伞的飞行速度应在安全范围内，即v_min &lt;= v &lt;= v_max
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1feea56d899fed490f849ec3d99cf48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71b691ac62d3c3d860288f52d3f2738/" rel="bookmark">
			PHP智慧门店微信小程序系统源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔍【引领未来零售新风尚】🔍 🚀升级启航，智慧零售新篇章🚀 告别传统门店的束缚，智慧门店v3微信小程序携带着前沿科技与人性化设计，正式启航！这个版本不仅是对过往功能的全面优化，更是对未来零售趋势的深度洞察与实践。它利用大数据、AI智能等技术，为商家打造了一个集线上线下于一体的智慧化经营平台。
📱无缝体验，线上线下融合新境界📱 智慧门店v3微信小程序实现了线上线下服务的无缝对接。顾客只需扫码即可进入小程序，享受预约、导航、购物、支付等一站式服务。同时，小程序还能根据顾客的位置信息推送周边门店信息，实现精准营销。线上浏览，线下体验，让购物变得更加便捷与个性化。
💡智能分析，精准营销新利器💡 内置的智能分析系统，是智慧门店v3微信小程序的另一大亮点。它能够实时收集并分析顾客行为数据，包括浏览记录、购买偏好等，为商家提供精准的顾客画像。基于这些数据，商家可以制定更加精准的营销策略，提高转化率和顾客满意度。
🛒高效管理，门店运营新升级🛒 对于商家而言，智慧门店v3微信小程序也是一款高效的管理工具。它支持库存管理、员工排班、业绩统计等多种功能，帮助商家实现精细化管理。同时，小程序还能自动生成经营报表，让商家随时掌握门店运营状况，及时调整经营策略。
🎉顾客互动，增强粘性新途径🎉 智慧门店v3微信小程序还注重与顾客的互动体验。通过会员系统、积分兑换、优惠券发放等功能，商家可以吸引顾客持续关注并参与门店活动。同时，小程序还支持顾客评价、留言反馈等互动方式，让商家及时了解顾客需求，提升服务质量。
🌐结语：智慧门店v3微信小程序，未来零售的必然选择🌐 在这个快速变化的时代，智慧门店v3微信小程序以其前瞻性的设计理念、强大的功能支持以及卓越的用户体验，成为了未来零售的必然选择。它不仅能够提升商家的经营效率和服务质量，还能为顾客带来更加便捷、个性化的购物体验。让我们携手智慧门店v3微信小程序，共同开启未来零售的新篇章！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8fcddb481f94f5e9b058d4aa0545e30/" rel="bookmark">
			LRU Cache 双向链表以及STL list实现----面试常考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双向链表版本： #include &lt;bits/stdc++.h&gt; using namespace std; struct Node{ int key, value; Node* prev; Node* next; Node():key(0), value(0), prev(nullptr), next(nullptr){} Node(int k, int v):key(k), value(v), prev(nullptr), next(nullptr){} }; class LRUCache{ private: int capacity_; int size_; Node* head; Node* tail; unordered_map&lt;int, Node*&gt; cache_; public: LRUCache(int capacity): capacity_(capacity), size_(0){ head = new Node(); tail = new Node(); head-&gt;next = tail; tail-&gt;prev = head; } void removeNode(Node* node){ node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next-&gt;prev = node-&gt;prev; } void addToHead(Node* node){ node-&gt;next = head-&gt;next; node-&gt;prev = head; head-&gt;next-&gt;prev = node; head-&gt;next = node; } void moveToHead(Node* node){ removeNode(node); addToHead(node); } Node* removeTail(){ auto node = tail-&gt;prev; removeNode(node); return node; } int get(int key){ if(cache_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8fcddb481f94f5e9b058d4aa0545e30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305056eacf48080b22eac4e166d26223/" rel="bookmark">
			Postman保存API返回的token以全局使用的整个流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 调通获取token的接口，包含传递参数的类型，和输入密码是否需要md5加密，根据接口的要求，传入数据
2、 查看接口响应的报文，可以看到token的有效时间，token的类型，里面的access_token就是想要获取的内容
3、 在Tests里面增加获取access_token值，并保存到环境变量的js代码
Postman有提供便捷的方法，可以直接查找右边的提示，比如设置环境变量，直接选择，然后将里面的内容，更改为自定义要设置的变量即可
4、 发送请求，查看Tests的内容有没有成功；成功的内容，可以看到TestResult里面会有通过的标志
5、 Postman自动将access_token保存到环境变量，可以在环境变量里面查看
6、 后面需要使用的到这个access_token，可以通过{{access_token}}，进行使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a33461307e8bfd918492dcbafdf32b1/" rel="bookmark">
			短信验证码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设置AccessKey 创建用户并配置使用权限，使我们拥有调用 aliyunAPI 的权限，之后会生成 AccessKeyID 和 AccessKey密码，后面我们会使用到。需要注意的是 AccessKeyID 和 AccessKey密码生成后我们需要将他保存起来，否则后期无法查询到。
二、开启阿里云短信服务 在阿里云官网搜索短信服务，进入短信服务控制台。
1、资质管理 在这里我们申请个人资质即可，就不用上传企业的证明材料。注意个人的证件照片要清除，不能有遮挡，备注信息写上申请说明，不能随便写，审核一般在两个小时内。
2、签名管理 申请签名。
3、模板管理 这里的模板，就是我们发送短信的模板，需要注意的是，要注意选择纯数字，或者则是英文数字混合使用的模板。模板CODE后面我们需要使用。
三、SpringBoot整合阿里云SMS 1、整体流程 1、前端发送短信验证码的请求；
2、后端收到请求后，生成验证码的code，调用阿里云API 接口发送短信；
3、判断 SMS API 的返回信息，“OK”则为成功发布；
4、发布成功将code存入redis，供后期校验使用；
5、将存入redis时的key值返回给前端。
2、引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;dysmsapi20170525&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; 3、配置SMS Client @Configuration public class AliyunCheckCodeConfig { @Bean public Client aliyunClient() throws Exception { Config config = new Config() .setAccessKeyId("你的AccessKeyID") .setAccessKeySecret("你的AccessKey密码"); config.endpoint = "dysmsapi.aliyuncs.com"; return new Client(config); } } 在配置类中将阿里云SMS 的客户端注册进ioc 容器，交给SpringBoot管理，这里需要将自己生成的AccessKeyID 和 AccessKey 密码替换上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a33461307e8bfd918492dcbafdf32b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05dc98c1a686d76c851f7fd8e17d5a8/" rel="bookmark">
			基于Java&#43;SpringMvc&#43;Vue技术的实验室管理系统设计与实现（6000字以上论文参考）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：硕士研究生，专注于信息化技术领域开发与管理，会使用java、标准c/c++等开发语言，以及毕业项目实战✌
从事基于java BS架构、CS架构、c/c++ 编程工作近16年，拥有近12年的管理工作经验，拥有较丰富的技术架构思想、较扎实的技术功底和资深的项目管理经验。
先后担任过技术总监、部门经理、项目经理、开发组长、java高级工程师及c++工程师等职位，在工业互联网、国家标识解析体系、物联网、分布式集群架构、大数据通道处理、接口开发、远程教育、办公OA、财务软件（工资、记账、决策、分析、报表统计等方面）、企业内部管理软件(ERP、CRM等)、arggis地图等信息化建设领域有较丰富的实战工作经验；拥有BS分布式架构集群、数据库负载集群架构、大数据存储集群架构，以及高并发分布式集群架构的设计、开发和部署实战经验；拥有大并发访问、大数据存储、即时消息等瓶颈解决方案和实战经验。
拥有产品研发和发明专利申请相关工作经验，完成发明专利构思、设计、编写、申请等工作，并获得发明专利1枚。
-----------------------------------------------------------------------------------
大家在毕设选题、项目升级、论文写作，就业毕业等相关问题都可以给我留言咨询，非常乐意帮助更多的人或加w 908925859。
相关博客地址：
csdn专业技术博客：https://blog.csdn.net/mr_lili_1986?type=blog
Iteye博客: https://www.iteye.com/blog/user/mr-lili-1986-163-com
获取论文及源代码：请加微908925859
注：每个学校每个老师对论文的格式要求不一样，故本论文只供参考，本论文页数达到60页以上，字数在6000及以上。
基于Java+SpringMvc+Vue技术的实验室管理系统设计与实现 目 录
第一章 绪论
1.1 研究背景
1.2 研究现状
1.3 研究内容
第二章 相关技术介绍
2.1 Java语言
2.2 HTML网页技术
2.3 MySQL数据库
2.4 Springboot 框架介绍
2.5 VueJS介绍
2.6 ElementUI介绍
第三章 系统分析
3.1 可行性分析
3.2 系统性能分析
3.3 系统功能分析
3.4 系统流程分析
第四章 系统设计
4.1 系统概要设计
4.2 系统结构设计
4.3 系统顺序图设计
4.4 系统关系图设计
4.5 数据库设计
第五章 系统详细设计
5.1 系统登录
5.2 首页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c05dc98c1a686d76c851f7fd8e17d5a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6562c9993dbbc13d056852c44740b9d/" rel="bookmark">
			VSCode v1.91.0 不能在MacOS11及更老版本的Mac上运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一觉醒来发现的VSCode打不开了，我的MacOS是BigSur 11.5.2。刚开始我还以为是我的电脑配置出现了问题，但是我把VSCode卸载重装之后还是不能运行
我就上VSCode的github仓库看issues，发现不是我电脑的问题而是VSCode在7月4号进行了自动更新，从v1.90.2升级到了v1.91.0，新版本的code似乎不能兼容旧版本的MacOS。这个问题已经在github上被问爆了
现在没有好的让1.91版本在BigSur上运行的方法，唯一的解决方案就是换回1.90版本，然后关闭自动更新。
v1.90版下载链接：
https://code.visualstudio.com/updates/v1_90
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cedfd4234bc648f045d38a60314979c7/" rel="bookmark">
			【算法：贪心】：贪心算法介绍&#43;基础题（四个步骤）；柠檬水找零（交换论证法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎁个人主页：我们的五年
🔍系列专栏：C++课程学习
🎉欢迎大家点赞👍评论📝收藏⭐文章
前言：
暑假马上就要留校学习算法了，现在先学习一下基本的算法打打基础。本篇要讲的是贪心算法的介绍，然后会讲两道基础的题目，用的贪心证明方法是：交换论证法。目前对贪心算法还是很感兴趣的，贪心没有固定的解法，遇到不会的，希望我可以把这种贪心算法搞清楚。
贪心算法： 🍩1.概念： 贪心算法是把问题分成很多步，每次都是选择看起来最优的那一步，就可以得到正确的答案。能用贪心解决的问题是具有贪心性质的。要想能用贪心解题，需要充分挖掘题目的条件。而且没有固定的模式。
🍩2.步骤： 对于一道贪心题，要解决并学会，可以分为：
1.题目解析。2.算法原理。3.手撕代码。4.贪心策略证明。
对于一道贪心题，可能前三步很简单，但是第四步一定是可以多多思考，多多证明的。在证明贪心策略的过程也是很有趣的。
🍩3.对于学习贪心算法建议： 贪心算法，没有一个固定的模式，我不是孙膑。我更多是去学习别人的贪心方法，并理解运用。所以在遇到有一些贪心问题的时候，我们可能没有任何思路，但是我们可以看别人的贪心解法，然后学习别人的思路。能把别人想出来的东西运用，也是一节伟大事情。
例题1 LeetCode：柠檬水找零（860）
860. 柠檬水找零 - 力扣（LeetCode）
🍩1.题目解析： ●每杯柠檬水售价5元。
●顾客排队购买。
●顾客向你付给你的钞票面额：5元，10元，20元。对于10元的，要找一张五块钱。对于20元的，你可以找三张五块钱，也可以找一张五块钱和一张十块钱。
●一开始没有零钱，也就是只能有顾客的钱来找零。
🍩2.算法原理： 1.对于顾客给的五块钱，我们直接收下，不需要找零。
2.对于顾客付的十块钱，我们将十块钱收下，然后进行找五块钱。
3.对于顾客付的二十块钱，我们有两种找零的方式。
找零一：找三张五块钱的。
找零二：找一张十块钱的， 找一张五块钱的。
🚁🚁🚁
从上面三种情况来看，五块钱有两种用途，十块钱只有一种用途（十块钱只能用来找零二十块钱的）。贪心解的情况下就是在找零二十块钱的时候，如果有十块钱就先用十块钱找（即找零方法一）。如果没有十块钱，才用三张五块钱进行找零。
🍩3.手斯代码： class Solution { public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) { int five=0,ten=0; //20元有和没有都没关系 for(auto&amp; i:bills) { if(i==5) ++five; else if(i==10) { if(five) { --five; ++ten; } else return false; } else if(i==20) { //有十块钱时，先用十块钱 if(ten&amp;&amp;five) { --ten; --five; } else if(five&gt;=3) { five-=3; } else return false; } } return true; } }; 🍩4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cedfd4234bc648f045d38a60314979c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eda33672625e779cf66a6f302dbc7413/" rel="bookmark">
			【Git 】规范 Git 提交信息的工具 Commitizen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Commitizen是一个用于规范Git提交信息的工具，它旨在帮助开发者生成符合一定规范和风格的提交信息，从而提高代码维护的效率，便于追踪和定位问题。以下是对Commitizen的详细介绍。
1、Commitizen的作用与优势 规范提交信息：通过提供预定义的提交类型和格式，引导开发者编写清晰、一致的提交信息。提高代码维护效率：规范的提交信息有助于快速理解每次提交的目的和内容，减少后续代码审查和信息查找的时间。促进团队协作：统一的提交信息规范有助于团队成员之间的沟通和协作，减少因提交信息不清晰而产生的误解和冲突。 2、Commitizen的使用方法 2.1安装Commitizen
可以通过npm（Node.js的包管理器）来全局或局部安装Commitizen。
2.1.1 全局安装命令为
npm install -g commitizen 2.1.1 局部安装则需要在项目目录下运行
npm install commitizen --save-dev 安装完成后 cz-conventional-changelog 会被默认安装，并且是作为 commitizen 的依赖项安装的。这意味着你可以直接使用 commitizen 并配置它使用 cz-conventional-changelog 适配器来规范你的 Git 提交信息。可以在 node_modules中查看， 或者通过 npm list cz-conventional-changelog显示 cz-conventional-changelog 的安装信息，包括它的版本和安装路径。 2.2 配置Commitizen
安装完成后，需要配置Commitizen以使用特定的适配器（Adapter），如cz-conventional-changelog。这通常涉及在项目的package.json文件中添加相关配置，或者创建专门的配置文件（如.czrc）。
2.2.1 全局安装配置
Vue.js、React 项目根目录中配置 package.json:
{ ... "scripts": { ... }, "devDependencies": { ... }, // 新增 config 配置 "config": { "commitizen": { "path": "cz-conventional-changelog" } } } 2.2.2 局部安装配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eda33672625e779cf66a6f302dbc7413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae33c1913595b03518489d7cd922976/" rel="bookmark">
			【算法】（C语言）：堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆（二叉树的应用）：
完全二叉树。最大堆：每个节点比子树所有节点的数值都大，根节点是最大值。父子索引号关系（根节点为0）：（向上）子节点x，父节点(x-1) // 2。（向下）父节点x，左子节点2x+1，右子节点2x+2。一般用数组实现堆。 堆排序：
第一步、构建堆（最大堆）。
找到最后的父节点：(最后元素的索引号-1) // 2。从最后的父节点到根节点，依次向下调整（比较父节点和左右子节点，最大值为父节点）。最终，根节点为最大值。尾指针指向最后节点。 第二步、排序
交换根节点和尾指针所在节点。此时，尾指针所在节点为目前正在排序中数据的最大值，保持不动。尾指针向前（向左）移动一位。从根节点到尾指针所在节点，依次向下调整。此时，根节点为目前正在排序中数据的最大值（不包含已排序好且保持不动的最大值）。 第三步、重复第二步，直到尾指针指向根节点停止。
时间复杂度：O(nlogn)
初次构建堆，时间约n。每次向下调整，都是使用2x+1、2x+2，遍历次数是logn（对数），几乎每个元素都要重排，因此时间约 nlogn。相对于nlogn而言，n可忽略，即总时间O(nlogn)。 空间复杂度：O(1)
在原位置排序，只重复使用了用于交换的临时空间，不随数据量的变动而变动，空间使用为常量(1)。 C语言实现思路：
先构建堆（最大堆），再排序。
void heapsort(int *array, int length)	// heap sort { // 构建堆（最大堆） // 找到最后的父节点 int i = ceil((length - 1) / 2);	// 从最后的父节点到根节点，依次向下调整（父子节点比较大小，最大值为父节点） for(; i &gt;= 0; i--) { adjustdown(array, i, length - 1); } // 排序 // 交换根节点和尾指针所在节点，尾指针前移一位，从根节点开始向下调整 for(int n = length - 1; n &gt; 0; n--) { swap(&amp;array[0], &amp;array[n]); adjustdown(array, 0, n - 1); } } 因多次向下调整，多次交换两个数据，因此，向下调整、交换数据分别用函数单独实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae33c1913595b03518489d7cd922976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b99799714c4d82fc0db2f93d9db1f2/" rel="bookmark">
			揭秘数据之美：【Seaborn】在现代【数学建模】中的革命性应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
已知数据集 tips
生成数据集并保存为CSV文件 数据预览：
导入和预览数据
步骤1：绘制散点图（Scatter Plot）
步骤2：添加回归线（Regression Analysis）
步骤3：分类变量分析（Categorical Variables）
步骤4：箱线图（Box Plot）
步骤5：小提琴图（Violin Plot）
步骤6：绘制热力图（Heatmap）
​编辑
总结
1. 生成数据集并保存为CSV文件
2. 导入和预览数据
3. 绘制散点图（Scatter Plot）
4. 添加回归线（Regression Analysis）
5. 分类变量分析（Categorical Variables）
6. 绘制箱线图（Box Plot）
7. 绘制小提琴图（Violin Plot）
8. 绘制热力图（Heatmap）
专栏：数学建模学习笔记
python相关库的安装：pandas,numpy,matplotlib，statsmodels
总篇：【数学建模】—【新手小白到国奖选手】—【学习路线】
第一卷：Numpy
第二卷：Pandas
第三卷：Matplotlib
在数据科学和数学建模的过程中，数据可视化是非常重要的一环。通过可视化，我们能够更直观地理解数据的分布和关系，从而为后续的分析和建模打下坚实的基础。本篇文章将围绕一个具体的实例，详细讲解如何使用Seaborn库进行数据可视化。我们将使用Seaborn内置的数据集tips，该数据集包含了一些餐馆的小费数据。我们的目标是通过数据可视化，探索影响小费金额的因素，并尝试建立一个数学模型。
已知数据集 tips tips 数据集包含以下几个主要字段：
total_bill: 总账单金额tip: 小费金额sex: 性别smoker: 是否吸烟day: 就餐日期time: 就餐时间（午餐或晚餐）size: 就餐人数 生成数据集并保存为CSV文件 import pandas as pd import numpy as np # 设置随机种子 np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b99799714c4d82fc0db2f93d9db1f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218c35a4d7d6585aa007d9d241e9be47/" rel="bookmark">
			Apache Hadoop的核心组成及其架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心组成 Apache Hadoop 是一个开源的分布式存储与计算框架，它主要由以下几个核心组件组成：
Hadoop Distributed File System (HDFS): HDFS 是 Hadoop 的分布式文件系统，它设计用于存储大量数据，并提供 高吞吐率的数据访问，通过将数据分块存储在多个节点上，实现数据的冗余存储和容错。Hadoop YARN (Yet Another Resource Negotiator): YARN 是 Hadoop 的资源管理层，负责管理计算资源（如 CPU 和内存），并为运行在 Hadoop 集群上的应用程序分配资源。YARN 引入了资源调度和作业管理的概念，使得 Hadoop 能够运行多种数据处理框架。Hadoop MapReduce: MapReduce 是 Hadoop 的编程模型，用于并行处理大规模数据集。MapReduce 工作流程分为两个阶段：Map 阶段和 Reduce 阶段，通过 Map 函数处理输入数据，然后通过 Reduce 函数聚合处理结果。 Hadoop=HDFS(分布式文件系统)+MapReduce(分布式计算框架)+Yarn(资源协调框架)+Common模块
除了这三个核心组件，Hadoop 生态系统还包含许多其他的项目和工具，如：
Hadoop Common：提供了 Hadoop 运行所需的公共库和工具。Hive：一个建立在 Hadoop 之上的数据仓库基础设施，提供 SQL 查询语言 SQL（HiveQL）来查询存储在 Hadoop 文件系统中的数据。Pig：一个高级的平台，用于创建 MapReduce 程序，使用 Pig Latin 脚本语言。HBase：一个分布式、可扩展的大数据存储系统，运行在 Hadoop 之上，提供类似 Google Bigtable 的功能。Sqoop：一个用于在 Hadoop 和关系型数据库之间传输数据的工具。Flume：一个分布式、可靠且可用的系统，用于高效地收集、聚合和移动大量日志数据。Spark：一个快速通用的大数据处理引擎，可以用于大规模数据处理和分析，与 Hadoop 生态系统紧密集成。 Hadoop 生态系统的这些组件共同提供了一个完整的大数据解决方案，使得用户可以在单一平台上进行数据存储、管理、处理和分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/218c35a4d7d6585aa007d9d241e9be47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b1462edcbb4d69f954d7196251387b/" rel="bookmark">
			java面试八股之MySQL怎么优化查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL怎么优化查询语句 优化MySQL查询语句是一个多方面的过程，旨在提高查询效率，减少资源消耗，以及改善整体数据库性能。下面是一些常见的优化策略：
理解执行流程：
了解MySQL处理SQL语句的过程和执行顺序。
利用EXPLAIN关键字分析查询的执行计划。
合理使用索引：
创建适当的索引，尤其是在频繁用于查询条件的列上。
避免在索引列上使用函数或表达式，因为这可能导致索引失效。
使用覆盖索引（Covering Index），即索引中包含所有查询字段，避免回表查询。
优化查询语句结构：
避免使用SELECT *，只选择需要的列。
优化GROUP BY和DISTINCT，确保它们后面跟的是索引列。
尽量避免使用OR操作符，可以用多个JOIN或UNION代替。
使用EXISTS或NOT EXISTS代替IN或NOT IN，当右表远小于左表时。
减少数据检索量：
使用LIMIT来限制结果集的大小。
对大型数据集使用分页查询。
避免全表扫描：
使用索引避免全表扫描，减少I/O操作。
在JOIN操作中使用适当的索引。
优化连接查询：
使用INNER JOIN代替WHERE子句连接。
确保连接条件两边的列都有索引。
调整缓存和配置：
调整查询缓存设置，如果适用的话。
优化InnoDB缓冲池大小和其他配置参数。
减少锁定时间：
缩短事务持续时间。
使用更细粒度的锁，如行级锁。
代码和应用程序优化：
避免在应用程序中重复执行相同的查询。
使用查询缓存机制或数据库缓存。
定期分析和优化：
定期执行ANALYZE TABLE和OPTIMIZE TABLE。
监控查询性能，定期检查慢查询日志。
每种情况下的优化策略可能不同，因此在实际操作中需要结合具体情况来选择最有效的优化方案。此外，优化工作通常需要测试和调整，以确保达到最佳性能。
如果大家需要视频版本的讲解，欢迎关注我的B站：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8444cda559bfce304034107606d2720a/" rel="bookmark">
			【数据结构/C&#43;&#43;】位图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 哈希思想的应用位图位图概念经典面试题位图所开的空间大小STL库中的 `bitset` 位图 位图实现大框架位运算符&lt;&lt;左移 和 &gt;&gt;右移 移动的方位set()：把x映射的位标记成1set() 接口实现reset：把x映射的位标记成0reset() 接口test()：检测x位是1还是0 效率海量面试题 布隆过滤器布隆过滤器提出数据在内存中查找布隆过滤器的引入布隆过滤器 布隆过滤器 实现大框架模板参数 讨论1：哈希函数个数 的选择 —— 开`3`个哈希函数(一个值映射`3`个位)讨论2：布隆过滤器长度 —— 开要进行插入元素个数的`5`倍大小reset() 删除 不能实现 布隆过滤器 码源实现经典面试题对于 切分的文件数量多少 的讨论极端情况：某个文件冲突很多，导致`Ai`或者`Bi`太大了，比如超过1G， `i=HashFunc(query)%100`哈希切分出各`Ai`文件 + `map&lt;string, int&gt;`统计次数 + `topK` `priority_queue`小堆 ：统计出`topK的IP`地址`i=HashFunc(query)%100`哈希切分成各`Ai`文件 + `map&lt;int, int&gt;` 逐一遍历哈希切分出的各`Ai`文件：统计出现的次数海量数据处理 问题的特征 哈希思想的应用 哈希(也叫 散列) 是一种 映射 的思想
哈希表：解决问题的思想（算法思想）：哈希表通过映射这种思想，实现了哈希表这种数据结构
还有其他的数据结构：位图、布隆过滤器。小众点的，基数树（多阶哈希）
位图 位图概念 经典面试题 给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。
排序+二分set + find 1G=1024MB；1MB=1024KB；1KB=1024byte 。( 1024=2^ 10. )
则 1G=1024 * 1024 * 1024=(2^ 10)^ 3 = 2^ 30 byte 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8444cda559bfce304034107606d2720a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e000223c4fd7a48f5f005fcfcd0d17/" rel="bookmark">
			安卓的组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空
🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 目录
🌈个人主页：人不走空 💖系列专栏：算法专题
⏰诗词歌赋：斯是陋室，惟吾德馨
1. Activity
概述
核心功能
示例代码
学习资源
2. Service
概述
核心功能
示例代码
学习资源
3. BroadcastReceiver
概述
核心功能
示例代码
学习资源
4. ContentProvider
概述
核心功能
示例代码
学习资源
总结
作者其他作品：
在Android开发中，组件是构成应用程序的基本单位，每个组件都承担特定的功能，并通过它们的协同工作来完成应用的整体任务。《第一行代码》这本书详细讲解了Android的四大组件：Activity、Service、BroadcastReceiver 和 ContentProvider，它们构成了应用程序的基础。下面我们来详细介绍每一个组件，以及它们在应用开发中的作用。
1. Activity 概述 Activity 是Android应用程序中最基本的组件，表示一个屏幕用户界面。每个Activity通常对应一个UI，用来与用户交互。Activity是用户和应用的直接交互窗口，它负责管理和处理应用的UI部分。
核心功能 管理UI: Activity 负责加载和管理应用的界面布局。处理用户交互: Activity 通过监听用户的触摸、点击等操作来响应用户的输入。生命周期管理: Activity 有一套完整的生命周期方法（如 onCreate、onStart、onResume、onPause、onStop、onDestroy），帮助开发者管理应用的状态和资源。 示例代码 kotlin
复制代码
import android.os.Bundle import androidx.appcompat.app.AppCompatActivity class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e000223c4fd7a48f5f005fcfcd0d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e366153146d3f8daef3d7bc40bae81/" rel="bookmark">
			0/1背包问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍇什么是0/1背包问题？🍈例题🍉1.分割等和子集🍉2.目标和🍉3.最后一块石头的重量Ⅱ 🍊总结 博客主页：lyyyyrics 🍇什么是0/1背包问题？ 0/1背包问题是一个经典的组合优化问题，其描述如下：
假设有一个背包，它能够承载一定的重量。现在有一组物品，每个物品有各自的重量和价值。我们的目标是在不超过背包承载重量的前提下，选择一些物品放入背包中，使得背包中物品的总价值最大化。
具体来说，假设有 n n n个物品，其重量分别为 w 1 , w 2 , . . . , w n w_1, w_2, ..., w_n w1​,w2​,...,wn​，对应的价值分别为 v 1 , v 2 , . . . , v n v_1, v_2, ..., v_n v1​,v2​,...,vn​。背包的承载重量为 W W W。我们需要在这 n n n个物品中选择一些放入背包中，使得这些物品的总重量不超过 W W W，且总价值最大化。
数学公式可以表示为：
Maximize ∑ i = 1 n v i x i subject to ∑ i = 1 n w i x i ≤ W x i ∈ { 0 , 1 } , i = 1 , 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16e366153146d3f8daef3d7bc40bae81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9957f4ac0eb6173805204e3f3e996721/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(003)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
4、pandas.read_csv函数
4-1、语法
4-2、参数
4-3、功能
4-4、返回值
4-5、说明
4-6、用法
4-6-1、创建csv文件
4-6-2、代码示例 4-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 4、pandas.read_csv函数 4-1、语法 # 4、pandas.read_csv函数 pandas.read_csv(filepath_or_buffer, *, sep=_NoDefault.no_default, delimiter=None, header='infer', names=_NoDefault.no_default, index_col=None, usecols=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=_NoDefault.no_default, skip_blank_lines=True, parse_dates=None, infer_datetime_format=_NoDefault.no_default, keep_date_col=_NoDefault.no_default, date_parser=_NoDefault.no_default, date_format=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal='.', lineterminator=None, quotechar='"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors='strict', dialect=None, on_bad_lines='error', delim_whitespace=_NoDefault.no_default, low_memory=True, memory_map=False, float_precision=None, storage_options=None, dtype_backend=_NoDefault.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9957f4ac0eb6173805204e3f3e996721/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/191/">«</a>
	<span class="pagination__item pagination__item--current">192/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/193/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>