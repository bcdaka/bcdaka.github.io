<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85093612d6ced635e438b8734e1bd54/" rel="bookmark">
			3 Go语言的变量声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本专栏将从基础开始，循序渐进，由浅入深讲解Go语言，希望大家都能够从中有所收获，也请大家多多支持。
查看相关资料与知识库
专栏地址:Go专栏 如果文章知识点有错误的地方，请指正！大家一起学习，一起进步。
文章目录 变量声明使用 `var` 声明变量练习 1.02 – 使用 `var` 声明变量使用 `var` 一次声明多个变量练习 1.03 – 使用 `var` 一次声明多个变量跳过声明变量时的类型或值练习 1.04 – 跳过声明变量时的类型或值类型推断出错短变量声明练习 1.05 – 实现短变量声明使用短变量声明同时声明多个变量练习 1.06 – 从函数中声明多个变量使用 `var` 一行声明多个变量非英语变量名修改变量的值练习 1.07 – 修改变量的值一行中修改多个变量的值一次修改多个变量的值练习 1.08 – 一次修改多个变量的值 变量声明 现在你已经对Go语言有了初步了解并完成了第一个练习，我们将深入探讨变量。我们的第一个重点是变量的声明。
变量用来暂时存储数据，以便你可以对其进行操作。当你声明一个变量时，你需要四个要素：声明变量的语句、变量的名称、变量能够存储的数据类型以及它的初始值。幸运的是，其中一些部分是可选的，这也意味着有多种方式来定义变量。
让我们详细了解所有声明变量的方法。
使用 var 声明变量 使用 var 是声明变量的基础方式。我们将要介绍的其他方法通常是这种方式的变体，通常通过省略一些部分来实现。一个完整的 var 声明如下：
var foo string = "bar" 其中关键部分包括 var、foo、string 和 = “bar”：
var 表示我们正在定义一个变量。foo 是变量的名称。string 是变量的类型。= “bar” 是变量的初始值。 练习 1.02 – 使用 var 声明变量 在这个练习中，我们将使用完整的 var 语法声明两个变量，并将它们打印到控制台。你将看到 var 语法可以在代码的任何地方使用，这并不是所有变量声明语法都能做到的。开始吧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e85093612d6ced635e438b8734e1bd54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1108c20d6db665e92732dfccd4b37abe/" rel="bookmark">
			【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下) 大家好 我是寸铁👊
【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下)✨
喜欢的小伙伴可以点点关注 💝
前言 本次文章分为上下两部分，上部分为对理论的介绍，下部分为具体的底层代码深度剖析和编程实践，感兴趣的伙伴不要错过哦~
在现代软件工程中，架构设计的精妙编织是构建稳健和高效系统的关键。组合模式作为一种经典的设计模式，通过将对象组合成树形结构以表示“部分-整体”的层次结构，已被广泛应用于各种领域的软件开发中。特别是在Gin框架这样的轻量级、高性能Web框架中，组合模式展现了其在管理复杂性和促进代码复用方面的卓越价值。本文将深入探讨组合模式在Gin框架中的革新实践和技术深度，帮助开发者全面理解如何利用组合模式优化和增强其应用程序的架构设计。
组合模式通过递归结构和多态性质，使得单个对象和组合对象在使用上具有一致性，从而使得整个系统的设计更加灵活和可扩展。在Gin框架中，组合模式可以被应用于路由结构、中间件组合以及请求处理管道的设计中，使得开发者能够更加自如地处理复杂的业务逻辑和请求处理流程。本文旨在为开发者提供深入的技术见解和实用的应用指南，帮助他们有效地运用组合模式，打造出更加稳健和可维护的Gin框架应用程序。
关键的类图和时序图 (1) 类图
Component：是组合中所有对象的基类，定义了组合中对象和组合对象的共有操作。拥有一个操作方法 operation()，可以在具体的Leaf或Composite中被实现。
Path（叶节点）：表示组合中的叶子节点对象，它没有子节点。继承自Component类，实现了operation()方法，表示基本的操作。
PathComposite（复合对象）：表示组合中的复合对象，可以包含其他Path或Composite对象。继承自Component类，包含了管理子组件的方法，如add(), remove(), getChild()等，同时也实现了operation()方法以处理组合对象的操作。
图58 组合模式的类图
由上图58可得:
在Gin框架中，组合模式主要体现在访问路由上，叶子节点为Path路径，组合对象为PathComposite。
先定义Component类，即组合中所有对象的基类，定义了组合中对象和组合对象的共有操作。拥有一个操作方法 operation()，可以在具体的Path或Composite中被实现。
再编写Path（叶节点），即表示组合中的叶子节点对象，它没有子节点。继承自Component类，实现了operation()方法，表示基本的操作。
然后编写PathComposite（复合对象）即表示组合中的复合对象，可以包含其他Path或Composite对象。继承自Component类，包含了真正实现管理子组件的方法，如add(), remove(), getChild()等，同时也实现了operation()方法以处理组合对象的操作。
(2) 时序图
图59 组合模式时序图
由上图59可得：
组合模式时序图说明：
客户端先创建具体的Composite组合对象，继承自Component类。
再创建叶子对象Path，继承自Component类。
接着调用Composite的join方法将叶子对象Path进行拼接得到可访问的路由对象router。
再逐步将拼接好的路由对象router返回给客户端Client进行调用和其他操作operation()。
主程序的流程 图60 组合模式主程序流程图
由上图60可得：程序一开始，客户端先创建路由组合对象Composite ，接着创建叶子对象Path ，然后调用组合对象Composite的join方法将Path进行拼接，再逐步返回拼接好后的路由对象给客户端，客户端获得路由对象后，进行业务处理，业务处理完毕后，程序结束。
程序模块之间的调用关系 图61 组合模式程序调用图
由上图61可得：
Gin 框架的组合模式，涉及的角色如下：
路由引擎 (Router Engine)：
router := gin.Default() 创建了 Gin 框架的路由引擎实例。该引擎负责注册路由、处理 HTTP 请求，并根据请求的路径和方法分发到相应的处理函数。
(1) 路由组 (Router Group)：
api := router.Group(“/api”) 和 admin := router.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1108c20d6db665e92732dfccd4b37abe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79bb748ff650d3960ded8fef51a5f8b0/" rel="bookmark">
			通过使用Excel VBA来进行Outlook自动邮件发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建Excel 我们需要创建一个xlsm后缀的excel文件，该后缀文件支持宏的使用
2、Excel操作 添加一些列
收件人抄送人Outlook模板路径替换内容附件内容插入图片是否发送 列的解释
收件人：你要发送给谁，以;进行连接
抄送人：抄送对象，以;进行连接
Outlook模板路径：Outlook所设置的模板，注意模板保存后缀为oft，例子：C:\Users\xx\Desktop\test.oft，路径不需要双引号。
替换内容：对模板中的内容进行替换，以：（替换词1&gt;替换内容1;替换词2&gt;替换内容2）的形式。例子：《天气状况》&gt;差;《活动》&gt;打麻将;《交通工具》&gt;地铁。不需要书名号也可以进行替换。
附件内容：添加附件的路径，以;进行连接
插入图片：插入图片到指定位置，其中例子：Image1&gt;C:\Users\z004zwey\Desktop\img\By Territory.png;Image2&gt;C:\Users\z004zwey\Desktop\img\OR chart.png，同替换内容类似，要替换的字符串&gt;图片路径。
是否发送：(1直接发送0设置为草稿,2仅显示）
设置使用宏
进入excel设置，对开发者窗口打勾
设置宏信任
3、VBA代码编写 引用outlook
发送代码
Sub SendEmail() Dim smallMessenger As Outlook.Application Set smallMessenger = New Outlook.Application Dim newEmail As MailItem Dim row, rows As Integer Dim recipient As String Dim ccRecipients As String Dim subject As String Dim outlookTemplatePath As String Dim replacementContent As String Dim attachmentContent As String Dim insertImages As String Dim sendDirectly As String Dim strImageHTML As String Dim i, j As Integer Dim Before() As Variant Dim Back() As Variant Dim attachs() As String rows = ActiveSheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79bb748ff650d3960ded8fef51a5f8b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078d864319520252f8df321d66ac0a59/" rel="bookmark">
			【C&#43;&#43;高阶】：AVL树的全面探索和深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 世事漫随流水，算来一梦浮生 🌏 📃个人主页：island1314
🔥个人专栏：C++学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
AVL树目录
🚀前言
一. AVL树的概念
二. AVL树节点的定义
🧩1. 基本元素
🧩2. 平衡因子（_bf）
🧩3.构造函数
🧩AVL节点定义：
三. AVL树的插入
四. AVL树的旋转
🌈右单旋
🌈左单旋
🌙左右双旋
🌙右左双旋
五. AVL树的验证
📝1. 验证其为二叉搜索树
📝2. 验证其为平衡树
📝3. 验证用例：
六.AVL树的性能和完整代码
🚀前言 前面我们学到了二叉搜索树，【C++高阶】二叉搜索树的全面解析与高效实现
虽然二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年发明了一种解决上述问题的方法，即AVL树，它以其独特的平衡机制和高效的搜索性能，成为了一颗璀璨的明星。它不仅解决了二叉搜索树在数据插入和删除时可能产生的失衡问题，更通过旋转操作，使得树的高度始终保持在一个相对较低的水平，从而保证了搜索的高效性。让我们来详细看看AVL树到底是怎么解决上述问题的吧，踏上这学习之旅。
一. AVL树的概念 📒二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。
因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年发明了一种解决上述问题的方法：
当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度，
📙一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：
它的左右子树都是AVL树左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1) 🎈注意： 如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在O（）搜索时间复杂度O（）。
二. AVL树节点的定义 AVL树节点的定义通常包含以下几个关键部分：
🧩1. 基本元素 在调整失衡的AVL树时，我们需要频繁的访问父节点，所以在AVL树中我们需要使用三叉链，因此AVL树的节点除了包含左右子节点的指针，还需要一个指向父节点的指针。
_left：指向节点的左子节点的指针_right：指向节点的右子节点的指针_parent：指向节点的父节点的指针_kv：一个结构体或配对（pair），包含节点的键值（key）和值（value）。这取决于AVL树的具体用途，可能只包含键或包含键值对。 🧩2. 平衡因子（_bf） 一个整数，表示节点左子树和右子树的高度差。AVL树的性质要求任何节点的平衡因子的绝对值不超过1（-1, 0, 1） 如果左子树比右子树高一层，那么平衡因子就为-1；如果左右子树一样高，平衡因子就为0；如果右子树比左子树高一层，那么平衡因子就为1，这三种情况下AVL树的性质都没有被打破。
按照这个规则，如果平衡因子为-2、2或其他值，则说明左右子树已经失衡，性质被打破。
🧩3.构造函数 初始化一个新节点时，通常需要一个构造函数，它接受一个键值对（或仅键），并设置节点的左子节点、右子节点、父节点和平衡因子（初始化为0） 另外需要说明一下，本文中，我们使用key/value模型的AVL树
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078d864319520252f8df321d66ac0a59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3fe8cfcd1fda769d51e62af74ff4b2b/" rel="bookmark">
			SpringBoot整合AES&#43;RSA加密（含前端代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
非对称加密和对称加密
RSA和AES简介
混合加密原因：
一、RSA工具类
二、AES工具类
三、解密工具类
四、自定义注解
五、aes加密实体类
六、加密的请求参数
七、这里使用拦截器解密
八、可以修改请求参数的request
九、RSA工具类
十、前端加密需要用到的js
十一、前端拦截器对请求统一加密
十二、为什么使用拦截器不使用aop
总结
非对称加密和对称加密 非对称加密
非对称加密算法是一种密钥的保密方法。非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。
公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
对称加密
加密秘钥和解密秘钥是一样，当你的密钥被别人知道后，就没有秘密可言了
AES 是对称加密算法，优点：加密速度快；缺点：如果秘钥丢失，就容易解密密文，安全性相对比较差
RSA 是非对称加密算法 ， 优点：安全 ；缺点：加密速度慢
RSA和AES简介 RSA
加密机制：属于非对称加密，公钥用于对数据进行加密，私钥对数据进行解密，两者不可逆。公钥和私钥是同时生成的，且一一对应。比如：A拥有公钥，B拥有公钥和私钥。A将数据通过公钥进行加密后，发送密文给B，B可以通过私钥进行解密。
AES
加密机制：属于对称加密，就是说，A用密钥对数据进行AES加密后，B用同样的密钥对密文进行AES解密。
加密思路
1：调用方先将请求参数用AES加密，再利用RSA公钥对AES的密钥值加密；
2：调用方将加密后的数据发送给服务端；
3：服务端接收到头信息里的加密串，先用RSA私钥解密出AES密钥值，再用解密出的AES密钥值解密请求参数；
4：处理完毕后，服务端再用AES密钥对响应参数加密；（本篇不涉及返回值加密,可以根据代码自己调试）
5：将加密后的结果返回给调用方。（本篇不涉及返回值解密，可以根据代码自己调试）
混合加密原因： 单纯的使用 RSA（非对称加密）方式，效率会很低，因为非对称加密解密方式虽然很保险，但是过程复杂，耗费时间长，性能不高;
RSA优势在于数据传输安全，且对于几个字节的数据，加密和解密时间基本可以忽略，所以用它非常适合加密 AES 秘钥（一般16个字节）;
单纯的使用AES（对称加密）方式的话，非常不安全。这种方式使用的密钥是一个固定的密钥，客户端和服务端是一样的，一旦密钥被人获取，那么，我们所发的每一条数据都会被都对方破解;
AES有个很大的优点，那就是加密解密效率很高，而我们传输正文数据时，正好需要这种加解密效率高的，所以这种方式适合用于传输量大的数据内容。
一、RSA工具类 package com.ruoyi.common.utils.rsa; import lombok.extern.slf4j.Slf4j; import org.apache.commons.codec.binary.Base64; import org.apache.commons.io.IOUtils; import javax.crypto.Cipher; import java.io.ByteArrayOutputStream; import java.security.*; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3fe8cfcd1fda769d51e62af74ff4b2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ad9a0d8338aae91a077cd0b023168f/" rel="bookmark">
			Mysql中(基于GTID方式)实现主从复制,单主复制详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡作者主页：点击！ 🐧Linux基础知识(初学)：点击！
🐧Linux高级管理防护和群集专栏：点击！
🔐Linux中firewalld防火墙：点击！
⏰️创作时间：2024年7月24日16点28分
🀄️文章质量：93分
目录
1. 单主复制
1.1 主服务器配置
修改MySQL配置文件
重启MySQL服务
1.2 创建具有复制权限的用户
1.3 从服务器配置
修改MySQL配置文件
重启MySQL服务
1.4 配置从服务器的复制
1.5 启动从服务
1.6 查看从服务器状态
测试主从复制
在主服务器上测试
在从服务器上验证
总结
在分布式数据库系统中，主从复制是实现高可用性和数据冗余的重要手段。基于GTID（Global Transaction Identifier）的复制模式可以提供更强的复制一致性和简化故障转移过程。本文将详细介绍如何配置单主复制的GTID模式，以便在MySQL数据库中实现稳定可靠的数据复制。
1. 单主复制 1.1 主服务器配置 首先，我们需要配置主服务器的MySQL，使其支持GTID模式。
修改MySQL配置文件 使用以下命令编辑MySQL配置文件：
vim /etc/my.cnf 在配置文件中添加以下内容：
server-id = 100 log_bin = mysql-bin gtid_mode = ON enforce_gtid_consistency = true 这些配置选项的作用如下：
server-id: 唯一标识MySQL实例的ID。log_bin: 启用二进制日志记录。gtid_mode: 开启GTID模式。enforce_gtid_consistency: 强制GTID一致性，确保每个事务都有一个唯一的GTID。 重启MySQL服务 应用配置更改后，需要重启MySQL服务：
systemctl restart mysqld 1.2 创建具有复制权限的用户 接下来，在主服务器上创建一个专门用于复制的用户，并授予其相应的权限：
grant replication slave on *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ad9a0d8338aae91a077cd0b023168f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a4e80d1073eadef04ae0436dff00f4/" rel="bookmark">
			Python研究生毕业设计，数据挖掘、情感分析、机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学校毕业了，其中有很多毕业论文使用到的代码，如数据挖掘、情感分析、机器学习、数据预测处理、划分数据集和测试集，绘制分类任务，词汇表示：使用TF-IDF向量化器，线性回归、多元线性回归、SVR回归模型，ARIMA时间回归模型，使用大数据可视化图展示，下面是内容：
源码地址：analysis: 数据分析研究生作业，该项目只适合做学术研究使用。 - Gitee.com
源码只提供学习，任何拿来获利者，都将被追究法律责任哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde6a9b670fc0b660b2a408ad89a17d5/" rel="bookmark">
			tinyxml2的入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tinyxml2的入门教程 前言一、tinyxml2 创建xml 文件二、tinyxml2 添加数据三、tinyxml2 更改数据四、tinyxml2 删除数据五、tinyxml2 打印总结 前言 xml 是一种标记型文档，有两种基本解析方式：DOM(Document Object Model，文档对象模型)和SAX(Simple APIs for XML，简单应用程序接口)。
DOM 将 xml 文档全部内容解析成一个对象模型树，通过对这个对象模型进行操作来实现对数据的操作。
优点：
– 解析成树的结构对象，可以实现增删改操作
缺点：
– 当 xml 文件过大时，比较占用内存
SAX 以事务为驱动，对 xml 文档从上之下，一行一行解析，当解析到事务对象则返回。
优点：
– 一行一行解析，内存占用小
缺点：
– 无能进行增删改操作
目前，有很多库封装了对 xml 文档的操作，例如 mini-xml 、libxml2、Xerces和 tinyxml等。tinyxml2 是其中一个比较简单且高效的 C ++ xml 解析器，只有一个.h 的头文件和一个 . pp 的源文件，可以轻松集成进自己的程序中。
tinyxml2采用DOM解析方式，
在 tinyxml2 中，节点是解析的基本单元，包括 文档节点(XMLDocument)、元素节点(XMLElement)、属性节点(XMLAttribute)和文本节点(XMLText)。对于 xml 文档中数据的增删改查都是基于这些节点进行操作的。
一、tinyxml2 创建xml 文件 首先，最好把 tinyxml2 的头文件和源文件放项目下：
然后就是引入 tinyxml2 的头文件并链接源文件。这里，用的是 cmake 来构建，将 tinyxml2 文件夹的路径包含进来，然后将源文件链接到 可执行文件上就行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cde6a9b670fc0b660b2a408ad89a17d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847e0bfba863ccef2002649f46514c94/" rel="bookmark">
			Linux中Mysql5.7主从架构(一主多从)配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡作者主页：点击！ 🐧Linux基础知识(初学)：点击！
🐧Linux高级管理防护和群集专栏：点击！
🔐Linux中firewalld防火墙：点击！
⏰️创作时间：2024年7月24日14点10分
🀄️文章质量：93分
目录
1.所有节点配置
建立时间同步环境
主节点
从节点
2.MySQL数据库安装
3.配置传统复制的单主复制
主服务器 (master1)
从服务器 (master2)
4.测试主从同步
1.所有节点配置 配置IP地址、网关、DNS、主机名称
通过适当的配置文件或命令设置网络相关信息，确保所有节点能正确互联互通。
停止并禁用防火墙
setenforce 0 systemctl stop firewalld systemctl disable firewalld 这些命令用于关闭SELinux和防火墙，防止它们阻碍节点之间的通信。
下载所需组件
yum groupinstall -y 'Development Tools' yum install -y lrzsz 安装开发工具和文件传输工具，确保系统具备必要的开发和传输环境。
建立时间同步环境 主节点 安装NTP
yum -y install ntp 安装NTP服务以确保时间同步。
配置NTP
vim /etc/ntp.conf 添加如下两行：
server 127.127.1.0 fudge 127.127.1.0 stratum 8 配置NTP服务以使用本地时间作为参考。
重启服务并设置为开机自动启动
systemctl restart ntpd systemctl enable ntpd 重启NTP服务并设置为开机自启动，以确保时间同步服务持续运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847e0bfba863ccef2002649f46514c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58eaa1d00f8f5d4878887d7cf16b5040/" rel="bookmark">
			xLua | xLua Framework | 2 加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 基础 0.1 不同加载模式 测试用 编辑器模式；打包模式；更新模式
public enum GameMode { EditorMode, PackageBundle, UpdateMode, } 0.2 加载资源步骤与接口 private void LoadAsset(string assetName, Action&lt;Object&gt; action) { if (AppConst.GameMode == GameMode.EditorMode) { #if UNITY_EDITOR EditorLoadAsset(assetName, action); #else Debug.LogError("Editor mode is not supported in the built version."); #endif } else { StartCoroutine(LoadBundleAsync(assetName, action)); } } 0.3 解析版本文件 /// &lt;summary&gt; /// 解析版本文件 /// &lt;/summary&gt; public void ParseVersionFile() { //版本文件路径 string url = Path.Combine(PathUtil.BundleResourcePath, AppConst.FileListName); string[] data = File.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58eaa1d00f8f5d4878887d7cf16b5040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c09814d01ae0e09e5ed4a2148ab8ff/" rel="bookmark">
			Sylar C&#43;&#43;高性能服务器学习记录01 【日志管理-知识储备篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早在19年5月就在某站上看到sylar的视频了，一直认为这是一个非常不错的视频。
由于本人一直是自学编程，基础不扎实，也没有任何人的督促，没能坚持下去。
每每想起倍感惋惜，遂提笔再续前缘。
为了能更好的看懂sylar，本套笔记会分两步走，每个系统都会分为两篇博客。
分别是【知识储备篇】和【代码分析篇】
(ps:纯粹做笔记的形式给自己记录下，欢迎大家评论，不足之处请多多赐教)
QQ交流群：957100923
B站视频：https://b23.tv/YusP39I
日志管理-知识储备 知识点01 （switch使用宏定义简化） 在日常编码中我们经常使用枚举
不仅可以统一管理，还能提高代码可读性，还能避免代码写错
如下是一个水果枚举类型
enum Fruit { UNKNOW = 0,	//未知 CHERRIES = 1,	//车厘子 STRABERRY = 2,	//草莓 APPLE = 3,	//苹果 WATERMELON = 4	//西瓜 }; 但是往往会有这样的情况，因为枚举中的值我们赋与的是数字 所以他方便运算但是不利于展示
//例如:我们想要输出对应枚举时 看到的是 3 而不是 APPLE std::cout &lt;&lt; Fruit::APPLE &lt;&lt; std::endl; 有时我们在数据存储时想要存储具体数值
但是在显示输出时 希望看到的是对应的枚举字段
那么我们就需要使用以下代码来进行输出时的转化
//这个方法名称我喜欢使用2来替换to fruit2string==fruitToString const char* fruit2string(Fruit fruit){ switch(fruit){ case fruit::CHERRIES: return "CHERRIES"; break; case fruit::STRABERRY: return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66c09814d01ae0e09e5ed4a2148ab8ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c627b93ded6a690cb29aaed18c3467/" rel="bookmark">
			【常微分方程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		框架
常微分方程的概念一阶微分方程可变离分量齐次方程一阶线性微分方程可降阶的高阶微分方程二阶常系数齐次线性微分方程二阶常系数非齐次线性微分方程 讲解
【1】
常微分方程：是微分方程的特殊情况； 阶：是方程未知函数的最高阶导数的阶数，如y^(2)，是一个二阶导；
线性，非线性：是指方程中的未知函数之间的关系是否独立存在，如果独立存在，就是线性，否则就是非线性，注意判断方法，必须两者都要符合；
通解：简单理解，就是有几阶导，就有几个常数c的x与y的关系式；
特解：简单理解，就是不含有常数c的x与y的关系式；
初始条件：简单理解，就是可以将通解中常数c求出的条件
【2】
一阶微分方程，含有可分离变量，齐次方程，一阶线性微分方程；
注意：这三种只是求解的手段，要注意每个手段的具体特征，另外，求出的结果都是x与y的关系式
可分离变量：字母相同的，可以放在一起
齐次方程：含有y/x，要进行换元，且是复合函数
一阶线性微分方程：y^(1)前面系数为1,且是正数，中间必须是+
【3】
可降阶的高阶微分方程：分为三种题型
方法：积分；换元，注意有两个题型都是换元，但是换元的内容不大一样；用一阶微分方程的方法 【4】
二阶常系数齐次线性微分方程， 二阶常系数非齐次线性微分方程，注意通解结构，题目要求
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7be6dabc29f6829d0ad7d28f170610a/" rel="bookmark">
			linux添加普通用户后无法使用K8S的kubectl命令怎么办/Linux普通用户管理K8S/Linux下普通用户无法使用K8S命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.给Linux添加普通用户 sudo useradd mqq #添加mqq账号 sudo passwd mqq #给mqq账号设置密码，需要输入2次，我输入密码是Admin@123 2.利用mqq用户输入K8S命令报错 3.给mqq用户提权 suduers文件位于路径/etc/sudoers
#编辑文件/etc/sudoers vim /etc/sudoers #编辑此文件，在root下添加mqq这行 root ALL=(ALL) ALL #本来就有的 mqq ALL=(ALL) ALL #新添加的 4.提权后利用mqq账号登录测试 sudo kubectl get ns sudo kubectl get pods,svc 5.注意点 每次在输入K8S命令前需要加上sudo
mqq账号只有在家目录下有权限（/home/mqq）任何操作，其他目录无权限操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8827d4462c1ffb44d643eccf629ac1ca/" rel="bookmark">
			【常见开源库的二次开发】基于openssl的加密与解密——SHA算法源码解析（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SHA-1算法分析：
1.1 Merkle Tree可信树
1.2 源码实现：
1.3 哈希计算功能
1.4 两种算法的区别： 1.4.1 目的
1.4.2 实现机制
1.4.3 输出
1.4.4 应用场景：
1.4 运行演示：
二、SHA-2算法分析： 2.1哈希算法简介 2.2 比特币挖矿与工作量证明
2.3 安全性 2.4 SHA-2算法概述
2.4.1. 消息填充
2.4.2 初始化链接变量缓冲区（SHA-256）
2.4.3 SHA-512 处理
2.4.4 SHA-384 和 SHA-512 的迭代函数
三、模拟比特币挖矿
3.1 区块的结构
3.2. 挖矿过程
3.3 TARGET 的计算
3.4 源码演示
3.5 算法思路
1. 目标定义:
2. 数据准备:
3. 哈希计算:
4. 有效性检查:
5. 输出结果:
总结：
一、SHA-1算法分析： 安全散列算法是一种加密散列函数，生成固定长度的散列值（或摘要），用于确保数据完整性和验证数据的真实性。
SHA-1是SHA系列中的一种，产生160比特（20字节）的散列值。其散列值通常表示为40个十六进制字符。SHA-1的散列值格式为`H0 H1 H2 H3 H4`，每个部分代表散列的不同部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8827d4462c1ffb44d643eccf629ac1ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7db7edfca3be61b58415203fa93556/" rel="bookmark">
			数据结构之《栈》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前我们已经学习了数据结构中线性表里面的顺序表与链表，了解了如何实现顺序表与链表增、删、查、该等功能。其实在线性表中除了顺序表和链表还有其他的类别，在本篇中我们就将学习另外一种线性表——栈，在通过本篇的学习后，你将会对栈的结构有充足的了解，在了解完结构后我们还将进行栈的实现。一起加油吧！！！
1.栈的概念与结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的⼀端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出（先进后出）LIFO（Last In First Out的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
那么栈的底层结构是基于什么的呢？其实基于数组还是基于单链表或者是双链表都是可以的，那么哪一种是最优解呢？接下来我们就来分析基于不同底层结构的利与弊
若底层结构基于数组，则可以让数组的低地址处表示栈底，数组的高地址处表示栈顶，使用一个size变量来表示数组有效数据个数，这样就可以要入栈时直接在size位置插入数据，之后size加一；出栈时就可以直接让size减一，这样就可以让数组的有效个数减一。以上使用数组来作为栈的底层结构时间复杂度为O(1)
在数组当中虽然每次在空间不足时都会以之前二倍的方式申请新空间，这时可能会存在内存的浪费，当时由于数组在内存中是连续存放的，这就使得在入栈和出栈不需要再每次都申请空间，而且数组在取数据的时候可能缓存中就有不一定要在主存中取。
若栈的底层结构为单链表，如果是在单链表尾部表示栈顶，头部表示栈底这样在无论是在入栈还是在出栈时因为都需要通过遍历来找到单链表的尾节点，所以时间复杂度都为O(N)。所以这时就要改变栈顶为单链表的头部，栈底为单链表的尾部，这时在入栈和出栈时就不需要遍历单链表，时间复杂度就都为O(1)。
但是单链表每次在入栈和出栈时都要申请节点和销毁节点，并且由于单链表每个节点空间在内存当中不一定是连续的，所以每次访问数据都需要区主存取。
而在双链表中无论是让头部作为栈顶，尾部作为栈底还是让尾部作为栈顶，头部作为栈底，由于双链表每个节点内部都有指向前一个节点和下一个节点的指针，所以在入栈和出栈时都不需要遍历链表，所以入栈和出栈时的时间复杂度都为O(1)。
但是双链表在每个节点内部相比单链表都多一个指针变量，在32位环境下每个节点大小就会多4个字节；在64位环境下每个节点大小就会多8字节。因此使用双链表就会造成更多的内存损耗。
通过以上的分析可以发现无论栈的底层结构是基于数组还是单链表还是双链表在入栈和出栈时的时间复杂度都为O(1)，但是综合其他因素使用数组是最优解 2.栈的实现 在实现栈的代码内在Stack.h头文件内定义栈的结构以及对各种功能函数进行声明，在Stack.c文件内实现各个函数，在test.c文件内对实现的各函数进行测试
2.1栈结构的定义 在Stack.h中创建一个结构体来定义栈的结构，在该结构体中的成员变量和顺序表中基本是相同的，只不过将顺序表中表示有效元素个数的size改名位top，让top来表示栈顶
//定义栈的结构 typedef int STDataType; typedef struct stack { STDataType* a; int capacity;//栈空间大小 int top;//栈顶 }stack; 2.2栈的初始化 要完成栈的初始化函数首先要在Stack.h完成初始化函数的声明
//初始化栈 void stackInit(stack* ps); 将该函数命名为stackInit,函数的参数就为指向结构体的指针
接下来就是在stack.c内完成初始化函数的实现
由于ps指针是指向结构体的指针，所以该指针不能为空，所以要对ps进行assert断言
//初始化栈 void stackInit(stack* ps) { assert(ps); ps-&gt;a = NULL; ps-&gt;top = ps-&gt;capacity = 0; } 2.3检测栈是否为空 要完成检测栈是否为空函数首先要在Stack.h完成该函数函数的声明
//检测栈是否为空 bool stackEmpty(stack* ps); 将该函数命名为stackEmpty,函数的参数就为指向结构体的指针，函数的返回类型为布尔类型
接下来就是在stack.c内完成检测栈是否为空函数的实现
由于ps指针是指向结构体的指针，所以该指针不能为空，所以要对ps进行assert断言
在该函数中若数组内的有效个数top为0函数就会返回true，不为0就返回false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd7db7edfca3be61b58415203fa93556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dfe60b1eca10f74aac7d98dc870cd35/" rel="bookmark">
			代码随想录算法训练营第42天 | 第九章 动态规划13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日记录 647. 回文子串 Leetcode链接
class Solution { public: int countSubstrings(string s) { vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); int result = 0; for (int i = s.size() - 1; i &gt;= 0; i--) { for (int j = i; j &lt; s.size(); j++) { if (s[i] == s[j]) { if (j - i &lt;= 1) { result++; dp[i][j] = true; } else if (dp[i + 1][j - 1]) { result++; dp[i][j] = true; } } } } return result; } }; 516.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dfe60b1eca10f74aac7d98dc870cd35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb4b2f28dfdb2d887b80ed07c154060/" rel="bookmark">
			如何在AWS免费撸一年的服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亚马逊云服务器是一家领先的云计算服务提供商，为用户提供了丰富的云计算服务和资源。对于初创企业或个人开发者来说，AWS的免费套餐是一个不错的选择。那么，如何在AWS免费撸一年的服务器呢？九河云来为读者们分享一些经验。
首先，注册AWS账号并激活免费套餐。AWS为新用户提供了一年的免费试用期，包括750小时的免费使用时间，以及一系列的免费服务和资源。用户只需注册账号并通过身份验证，即可获得这些福利。
其次，选择适合的免费服务和资源。AWS的免费套餐包括EC2实例、S3存储、RDS数据库、Lambda函数等多种服务和资源，用户可以根据自己的需求选择合适的免费项目，以免费使用时间为主，同时尽量避免超出免费额度的费用。
再者，合理规划和管理资源。在使用AWS的免费套餐期间，用户应当合理规划和管理自己的资源，避免浪费和超支。可以通过监控和报警工具，及时发现并解决资源使用过量的问题，确保在免费额度内使用。
此外，了解免费套餐的限制和使用规则。AWS的免费套餐包括一些限制和使用规则，如免费试用期结束后需要支付费用、部分服务和功能不在免费范围内等。用户应当了解这些规则，并合理利用免费资源，避免不必要的费用。
总的来说，通过充分了解和合理利用AWS的免费套餐，用户可以在一年内免费使用一定量的服务器和云计算资源，为自己的开发和业务节省成本。希望以上经验能够帮助大家更好地撸出一年的免费服务器，实现更多的商业价值。
想了解更多的AWS详情请关注九河云。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42643ccd0f973c54e0332160e6b56109/" rel="bookmark">
			79页PDF免费下载 | 全域数字化转型评估模型研究报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言： 随着数字技术的飞速发展，零售行业正站在转型的十字路口。如何在变革中找到方向，如何通过数字化转型提升企业竞争力，已成为每个零售企业必须面对的课题。腾讯智慧零售与伏羲智库深度合作，推出《2024年全域数字化转型评估模型研究报告》，揭开数字化转型的神秘面纱。
研究报告简要地回顾了零售行业数字化转型的历程，从技术、政策、产业三个维度梳理了零售行业数字化转型的趋势。在探讨行业数字化转型的共性问题，以及零售业数字化转型特性的基础上，提出“智慧零售全域数字化转型新范式”即零售企业数字化转型的整体行动模式。
研究报告广泛连接了学术界、产业界数字化转型的理论与实践经验，其中学术界强调对企业数字化转型水平、成熟度、影响因子的测算，产业界则围绕消费体验全域经营、智能管理展开。基于指导零售行业数字化转型的写作初衷，本研究报告侧重数字化转型能力评估，构建了以数字化战略、数字化应用和数据基础能力为一级指标的评估模型。细化指标充分考虑了数字化战略规划、组织人才、预算投入等企业管理侧的有关内容，数字化应用覆盖与零售企业数字化经营的具体要求，以及包括上云、用数、赋智、安全治理在内的基础能力建设。通过专家打分与模糊层次分析相结合的方法，报告确定出各级评估指标的权重。
资料已经全部打包，文末添加大师兄即可下载👇👇👇
二、目录： 三、报告摘选： 全面评估模型：20多个细分指标，全面覆盖数字化转型的各个维度。
实战案例分析：深入剖析行业标杆案例，提炼成功转型的核心要素。
战略与应用并重：不仅关注战略层面的规划，更着眼于数字化应用的实际效果。
数据驱动决策：强调数据资产的重要性，利用数据分析优化决策过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c11b5cb349d24e69d053b6a0173f3b6/" rel="bookmark">
			前端练习＜Html&amp;CSS＞——悬浮抽卡片（附完整代码及实现效果）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个小练习来源于b站up小K师兄，大家可以通过下面的链接学习哦~up讲的非常详细。
写一个好玩的悬浮抽卡片效果～
先看一下效果：
1.鼠标没有放置到card上
2.鼠标放到card上，所有card呈角度散开 3.单击选中某一张卡片，卡片上浮高亮，其他卡片变暗 HTML部分 &lt;html&gt; 标签定义了整个HTML文档。&lt;head&gt; 标签包含了文档的元数据，如字符编码、标题和样式表。&lt;body&gt; 标签包含了文档的主体内容，即展示给用户看的部分。 CSS部分 * 选择器用于选择所有元素，并设置它们的默认样式，包括去除默认的边距、填充、边框、盒模型和字体。body 选择器设置了页面的背景颜色、居中对齐、最小高度和隐藏溢出内容。.container 选择器设置了容器元素的样式，包括相对定位、宽度、居中对齐和居中对齐内容。.card 选择器设置了卡片的样式，包括绝对定位、宽度、高度、背景颜色、边框、过渡效果、旋转原点、颜色、字体大小、字体粗细、阴影等。.container:hover .card 选择器设置了鼠标悬停时卡片的旋转、平移、阴影、颜色和光标样式。.container:active .card:not(:active) 选择器设置了鼠标按下时卡片的背景颜色。.container .card:active 选择器设置了鼠标按下时卡片的平移和层级。 HTML元素 &lt;div class="container"&gt; 是一个容器元素，包含了多个卡片元素。&lt;div class="card" style="--i:-4"&gt;1&lt;/div&gt; 等元素是卡片元素，通过CSS变量 --i 控制旋转角度。 实现原理 这段代码通过CSS的伪类选择器和变量实现了卡片的动态效果。当鼠标悬停在容器上时，卡片会根据CSS变量 --i 的值进行旋转和平移，从而产生动态效果。当鼠标按下时，卡片会改变背景颜色，并进一步平移和提升层级。
完整的代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; } body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #0f0f0f; overflow: hidden; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c11b5cb349d24e69d053b6a0173f3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a41da94c1ceedb04a135dff8e6d3696/" rel="bookmark">
			代码随想录算法训练营第22天-leetcode-二叉树08：669. 修剪二叉搜索树；108.将有序数组转换为二叉搜索树；538.把二叉搜索树转换为累加树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		669. 修剪二叉搜索树 力扣题目链接(opens new window)
给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。
分析： 需要遍历整棵树，因为父节点被删除或者保留，子节点都有可能删除或者保留；父节点被删除时，左子树和右子树只可能保留一个
我的做法： 后序遍历每个节点，对于在范围外的节点，考虑保留其左子树/右子树（只可能保留一个）
struct TreeNode* trimBST(struct TreeNode* root, int low, int high) { if(root==NULL) return NULL; int x=root-&gt;val; root-&gt;left=trimBST(root-&gt;left, low, high); root-&gt;right=trimBST(root-&gt;right, low, high); if(x&lt;low){ struct TreeNode* b=root-&gt;right; free(root); return b; } else if(x&gt;high){ struct TreeNode* b=root-&gt;left; free(root); return b; } return root; } 代码随想录： 全部写成递归
struct TreeNode* trimBST(struct TreeNode* root, int low, int high) { if(root==NULL) return NULL; int x=root-&gt;val; if(x&lt;low){ return trimBST(root-&gt;right, low, high); } else if(x&gt;high){ return trimBST(root-&gt;left, low, high); } root-&gt;left=trimBST(root-&gt;left, low, high); root-&gt;right=trimBST(root-&gt;right, low, high); return root; } 108.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a41da94c1ceedb04a135dff8e6d3696/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/115/">«</a>
	<span class="pagination__item pagination__item--current">116/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/117/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>