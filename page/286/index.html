<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/200960275b67f46c4ca1338af4fa39ed/" rel="bookmark">
			Qt——升级系列（Level Four）：控件概述、QWidget 核心属性、按钮类控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
控件概述
QWidget 核心属性
核心属性概览
enabled
geometry
windowTitle
windowIcon
windowOpacity
cursor
font
toolTip
focusPolicy
styleSheet
按钮类控件
Push Button
Radio Buttion
Check Box
Tool Button
控件概述 Widget 是 Qt 中的核⼼概念. 英⽂原义是 "⼩部件", 我们此处也把它翻译为 "控件" .
控件是构成⼀个图形化界⾯的基本要素.
像上述⽰例中的, 按钮, 列表视图, 树形视图, 单⾏输⼊框, 多⾏输⼊框, 滚动条, 下拉框等, 都可以称为 "控件".
Qt 作为⼀个成熟的 GUI 开发框架, 内置了⼤量的常⽤控件. 这⼀点在 Qt Designer 中就可以看到端倪.并且 Qt 也提供了 "⾃定义控件" 的能⼒, 可以让程序猿在现有控件不能满⾜需求的时候, 对现有控件做出扩展, 或者⼿搓出新的控件. Qt 控件体系自其诞生以来经历了持续的发展与完善，旨在为开发者提供强大且灵活的图形用户界面（GUI）构建工具。以下是一些关键点概述了Qt控件体系的发展历程：
1、早期发展：
Qt 最初由 Haavard Nord 和 Eirik Chambe-Eng 在1991年开始开发，目标是创建一个同时支持X11和Windows平台的跨平台图形用户界面库。1992年，Trolltech（后更名为Qt Company）的前身团队开始了Qt的设计工作。1995年，Qt的第一个商业版本发布，标志着其作为专业开发工具的起点。 2、跨平台能力增强：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/200960275b67f46c4ca1338af4fa39ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b668d2824c6a2957e7a6d7d6609ff0e/" rel="bookmark">
			Java 数据类型 -- Java 语言的 8 种基本数据类型、字符串与数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 004 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
上一篇文章中，我们讨论了 Java 程序的基本结构，包括变量、方法、运算符与注释。本篇文章我们将深入了解 Java 的数据类型，包括 Java 语言的 8 种基本数据类型、字符串与数组。这些数据类型是 Java 程序设计的基础，也是编写高效、可靠代码的关键。
最后在前言的末尾我补充一下，如果这篇文章，对大家有所帮助或收获一定的乐趣和想法，那么非常欢迎大家能够，点赞、评论、收藏、订阅。这些也将是我持续更新的最大动力。
文章目录 1、数据类型1.1、整型1.2、浮点型1.3、字符型1.4、布尔型 2、数值类型之间的转换2.1、数值类型之间的转换2.2、强制类型转换 3、大数值4、字符串4.1、String 常见方法4.2、String 不可变 5、数组5.1、数组声明与初始化5.2、数组元素访问与赋值5.3、数组的常用方法5.3.1、Arrays.aslist()方法5.3.2、Arrays.binarySearch()方法5.3.3、Arrays.copyOf()方法5.3.4、Arrays.copyOfRange()方法5.3.5、Arrays.equals()方法5.3.6、Arrays.fill()方法5.3.7、Arrays.sort()方法5.3.8、Arrays.toString()方法 5.4、多维数组 1、数据类型 Java 是一种强类型语言，这意味着每个变量都必须声明其数据类型。Java 提供了 8 种基本数据类型，包括 4 种整型（byte、short、int、long）、2 种浮点型（float、double）、1 种字符类型（char，用于表示 Unicode 字符）和 1 种布尔类型（boolean，用于表示真假值）。
1.1、整型 Java 提供了四种整型数据类型，分别是 int、short、long 和 byte，它们的存储需求、默认值和取值范围如下：
在大多数情况下，我们会使用 int 类型。但如果需要表示非常大的数（如地球人口数量），则需要使用 long 类型。byte 和 short 类型主要用于特定的场景，如底层文件处理或大数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b668d2824c6a2957e7a6d7d6609ff0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aec40a99d1c5d65dba9ae1e226f4953/" rel="bookmark">
			Java 程序结构 -- Java 语言的变量、方法、运算符与注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 003 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
上一篇文章中，我们详细介绍了 Java 环境的安装、配置、编译与运行，帮助大家成功搭建了 Java 开发的基础环境。在这篇文章中，我们将深入探讨 Java 程序的基本结构，了解 Java 语言中的变量、方法、运算符与注释。这些知识是学习和掌握 Java 编程的基石，对于编写高效、可维护的代码至关重要。
最后在前言的末尾我补充一下，如果这篇文章，对大家有所帮助或收获一定的乐趣和想法，那么非常欢迎大家能够，点赞、评论、收藏、订阅。这些也将是我持续更新的最大动力。
文章目录 1、Java 程序基本结构1.1、一个简单的 Java 应用程序1.2、解读简单的 Java 应用程序1.2.1、代码解读-11.2.2、代码解读-21.2.3、代码解读-3 2、Java 变量&amp;常量2.1、声明变量2.2、变量初始化2.3、声明常量2.4、枚举变量 3、Java 中的方法3.1、方法构成3.2、方法传参3.3、方法重载 4、Java 运算符4.1、算数运算符4.2、数学函数 Math 类4.3、关系运算符4.4、逻辑运算符4.5、位运算符 5、Java 注释5.1、单行注释5.2、多行注释5.3、文档注释 1、Java 程序基本结构 1.1、一个简单的 Java 应用程序 下面看一个最简单的 Java 应用程序，它只发送一条 “Hello World!!!” 消息到控制台窗口中:
public class FirstSample { public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aec40a99d1c5d65dba9ae1e226f4953/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a7e94ab37953b7b56970947618afdd/" rel="bookmark">
			重新认识Word —— 制作简历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重新认识Word —— 制作简历 PPT的图形减除功能word中的设置调整页边距进行排版表格使用 我们之前把word长排版文本梳理了一遍，其实word还有另外的功能，比如说——制作简历。
在这之前，我们先讲一个小技巧：
PPT的图形减除功能 我们一般的简历，都会有一些装饰元素，这些装饰元素在word中并不是很好做：
但是在ppt中，这些就比较好做，我们这里利用ppt的图形减除做一个每个标题的log：
首先打开PPT：
插入一个文本框：
输入三个箭头：
然后我们插入一个矩形：
调整一下颜色：
此时，我们先点击箭头，然后按住Ctrl，再点击矩形：（顺序不能乱）
此时箭头和矩形都会被选中，这个时候到形状格式中找到合并形状：
调整一下颜色和大小：
这样我们就做好了一个头了。
word中的设置 调整页边距 我们先打开一个word：
到布局：
全部改成0：
这样调整好页边距之后，把我们的log头粘过来：
调整一下大小，然后插入一条直线：
上面的两个按钮可以调整线条的大小和颜色：
调整好之后，调整这两个图形的位置：
Ctrl键选中两个图形：在形状格式中找到组合:
这样就会变成一个图形，这样我们的log就做好了。
进行排版 这里我建议先把图片导入，如果先写内容，后导图片，word可能会崩：
这里为了隐私，我没有导入自己的图片，大家自己做的时候导入自己的图片，千万不能乱选图片哦。
接下来，就可以根据你自己的情况开始写内容，比如，我想先写项目经历，我们插入一个文本框：
拖到合适的位置：
这里把形状填充和形状轮廓都设为无：
然后调整字体：
然后下面拉一个文本框，调整范围和大小：
同样的方法，取消填充和边框，写入内容：
可以加上一些图标，分清层次：
同样的方法，写完下面的部分：
表格使用 如果我们想让文字对齐，我们可以插入表格：
最后设置为无框线就可以了：
整体展示：
最后，记得设置定时保存：
这是一个简单的简历，做的不好，只传授一些简单方法，大佬勿喷~。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13502b16dbca8aa2bdf94fc8084c4630/" rel="bookmark">
			图像生成发展起源：从VAE、VQ-VAE、扩散模型DDPM、DETR到ViT、Swin transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 2018年我写过一篇博客，叫：《一文读懂目标检测：R-CNN、Fast R-CNN、Faster R-CNN、YOLO、SSD》，该文相当于梳理了2019年之前CV领域的典型视觉模型，比如
2014 R-CNN2015 Fast R-CNN、Faster R-CNN2016 YOLO、SSD2017 Mask R-CNN、YOLOv22018 YOLOv3 随着2019 CenterNet的发布，特别是2020发布的DETR(End-to-End Object Detection with Transformers)之后，自此CV迎来了生成式下的多模态时代(本文介绍其中有下划线的部分，其他部分下一篇介绍)
1月3月4月5月6月8月9月10月11月2020DETRDDPM DDIM
VisionTransf.. 2021 CLIP
DALL·E
SwinTransf.. MAE
SwinTransf..V2
2022BLIPDALL·E 2 StableDiffusion BEiT-3
Midjourney V3
2023BLIP2 VisualChatGPT GPT4
Midjourney V5
SAM(Segment Anything Model)DALLE3 但看这些模型接二连三的横空出世，都不用说最后爆火的GPT4，便可知不少CV同学被卷的不行
说到GPT4，便不得不提ChatGPT，实在是太火了，改变了很多行业，使得国内外绝大部分公司的产品、服务都值得用LLM全部升级一遍(比如微软的365 Copilot、阿里所有产品、金山WPS等等)
而GPT4相比GPT3.5或GPT3最本质的改进就是增加了多模态的能力，使得ChatGPT很快就能支持图片的输入形式，从而达到图生文和文生图的效果，而AI绘画随着去年stable diffusion和Midjourney的推出，使得文生图火爆异常，各种游戏的角色设计、网上店铺的商品/页面设计都用上了AI绘画这样的工具，更有不少朋友利用AI绘画取得了不少的创收，省时省力还能赚钱，真香
但面对这么香的技术，其背后的一系列原理到底是什么呢，本文特从头开始，不只是简单的讲一下扩散模型的原理，而是在反复研读相关论文之后，准备把20年起相关的CV多模态模型全部梳理一遍，从VE、VAE、DDPM到ViT/Swin transformer、CLIP/BLIP，再到stable diffusion/Midjourney、GPT4，当然，实际写的时候，会分成两篇甚至多篇文章，比如
第一篇，即本文《AI绘画能力的起源：从VAE、扩散模型DDPM、DETR到ViT/MAE/Swin transformer》第二篇，即下篇《CV多模态和AIGC的原理解析：从CLIP、BLIP到Stable Diffusion、Midjourney》 就当2020年之后的CV视觉发展史了，且过程中会尽可能写透彻每一个模型的原理，举两个例子
网上介绍VAE的文章都太数学化(更怕那种表面正确其实关键的公式是错的误导人)，如果更边推导边分析背后的理论意义(怎么来的 出发点是什么 为什么要这么做 这么做的意义是什么)，则会更好理解，这就跟变介绍原理边coding实现 会更好理解、理解更深 一个道理如果完全展开DDPM推导的所有细节，假定需要100步的话，本文正在朝展开80步而努力，截止5月份之前，绝大部分的中文资料只展开了60步(正在因为只展开了60%，让很多初学者卡到中途)，所以你害怕的不是公式，你只是怕公式的展开不够细致，毕竟对每一个人而言，公式展开越细致 越不怕
(如果本文有任何一个公式展开的不够细致、不够一目了然，请随时指出，一定及时二次展开) 第一部分 编码器VE与变分自编码器VAE 1.1 AE：编码器(数据压缩为低维表示)-解码器(低维表示恢复为原始数据)架构 自编码器(Autoencoder，简称AE)是一种无监督学习的神经网络，用于学习输入数据的压缩表示。具体而言，可以将其分为两个部分：编码器和解码器
编码器：编码器是一个神经网络，负责将输入数据（如图像、文本等）压缩为一个低维表示，且表示为
解码器：解码器是另一个神经网络，负责将编码器生成的低维表示恢复为原始数据，且表示为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13502b16dbca8aa2bdf94fc8084c4630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c36128640ed1e053c415018a16ac06/" rel="bookmark">
			【HarmonyOS】鸿蒙应用模块化实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【HarmonyOS】鸿蒙应用模块化实现 一、Module的概念 Module是HarmonyOS应用的基本功能单元，包含了源代码、资源文件、第三方库及应用清单文件，每一个Module都可以独立进行编译和运行。一个HarmonyOS应用通常会包含一个或多个Module，因此，可以在工程中，创建多个Module，每个Module分为Ability和Library。
二、新增Module方法 通过如下两种方法，在工程中添加新的Module。
方法1：鼠标移到工程目录顶部，点击鼠标右键，选择New&gt;Module，开始创建新的Module。
方法2：在菜单栏选择File &gt; New &gt; Module，开始创建新的Module。
点击Next，在Module配置页面，设置新增Module的基本信息。
Module类型为Ability或者HarmonyOS Library时，请根据如下内容进行设置，然后点击Next。Application/Library name：新增Module所属的类名称。
Module name：新增模块的名称。
Module Type：仅Module类型为Ability时存在，工具自动根据设备类型下的模块进行设置。
Package name：软件包名称，可以点击Edit修改默认包名称，需全局唯一。
Compatible SDK：兼容的SDK版本。
设置新增Ability或HarmonyOS Library的Page Name。
若该Module类型为Ability，需要设置Visible参数，表示该Ability是否可以被其它应用所调用。
勾选(true)：可以被其它应用调用。
不勾选(false)：不能被其它应用调用。
点击Finish，等待创建完成后，可以在工程目录中查看和编辑新增的Module。
三、删除Module方法 为防止开发者在删除Module的过程中，误将其它的模块删除，DevEco Studio提供统一的模块管理功能，需要先在模块管理中，移除对应的模块后，才允许删除。
在菜单栏中选择File &gt; Project Structure &gt; Modules，选择需要删除的Module，点击按钮，并在弹出的对话框中点击Yes。
四、多module编译打包方法 HAP按构建类型和是否签名可以分为以下四种形态：
1、构建类型为Debug的HAP(带调试签名信息)：携带调试签名信息，具备单步调试等调试手段的HAP，用于开发者在真机或者模拟器中进行应用调试。
2、构建类型为Debug的HAP(不带签名)：不带调试签名信息，具备单步调试等调试手段的HAP，仅能运行在模拟器中。
3、构建类型为Release的HAP(带调试签名信息)：携带调试签名信息，不具备调试能力的HAP，用于开发者在真机或者模拟器中查看和验证应用运行效果。相对于Debug类型的HAP包，体积更小，运行效果与用户实际体验一致。
4、构建类型为Release的HAP(不带签名)：不带调试签名信息，不具备调试能力的HAP，仅能运行在模拟器中查看和验证应用运行效果。相对于Debug类型的HAP包，体积更小，运行效果与用户实际体验一致。
根据HarmonyOS工程介绍，一个HarmonyOS工程下可以存在多个Module，在编译构建时，可以选择对单个Module进行编译构建；也可以对整个工程进行编译构建，同时生成多个HAP。
在主菜单栏，点击Build &gt; Build APP(s)/Hap(s) &gt; Build Debug Hap(s)，生成已签名的Debug HAP。
可以选择对单个Module：entry、module2、module3
也可以选择整个工程：MyApplication
选单个Module编包生成对应HAP文件，选择整个项目编包，则在每个Module的outputs路径下都生成HAP文件
五、module之间的相互调用 在MyApplication工程中创建多个module：entry、module2、module3
在module1模块中创建组件
在entry模块的配置文件package.json中添加依赖项module1
在entry模块中引用module1模块的组件
运行entry后的结果：
反之也可引用到entry中相应的组件及方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f06a9fa8175601f2334b9bc5f882f7/" rel="bookmark">
			深入解析Java扩展机制：SPI与Spring.factories
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java作为一种广泛使用的编程语言，其扩展机制在其生态系统中扮演着重要角色。Java的扩展机制主要包括两大核心部分：SPI（Service Provider Interface）和Spring.factories。在本文中，我们将深入探讨这两者的原理、应用以及它们在实际开发中的重要性。
目录 引言Java扩展机制概述 什么是扩展机制？扩展机制的优势 SPI（Service Provider Interface） SPI简介SPI的工作原理实现和使用SPISPI的优缺点SPI的实际案例分析 Spring.factories Spring.factories简介Spring.factories的工作原理实现和使用Spring.factoriesSpring.factories的优缺点Spring.factories的实际案例分析 SPI与Spring.factories的对比总结 1. 引言 Java语言以其平台独立性、强大的社区支持和丰富的库而著称。为了使Java应用能够适应不同的业务需求和技术栈，Java引入了多种扩展机制。本文将重点讨论两种主要的扩展机制：SPI和Spring.factories，并深入探讨它们的原理、应用及其在开发中的重要性。
2. Java扩展机制概述 2.1 什么是扩展机制？ 扩展机制是指在不修改现有代码的基础上，通过增加或替换模块来增强系统功能的能力。对于Java而言，扩展机制允许开发者定义接口或抽象类，其他开发者可以实现这些接口，从而在运行时动态地加载这些实现。
2.2 扩展机制的优势 模块化和可插拔性：扩展机制促进了模块化设计，使得应用程序可以通过添加或替换模块来扩展功能。灵活性和可维护性：系统的灵活性提高，易于维护和升级。分离关注点：开发者可以专注于接口定义，提供者可以专注于实现细节。 3. SPI（Service Provider Interface） 3.1 SPI简介 SPI是Java的一种服务提供接口机制。它允许服务的提供者和消费者通过接口进行解耦，从而实现服务的可插拔性。SPI广泛应用于JDK和各种Java框架中。
3.2 SPI的工作原理 SPI的核心思想是定义一个服务接口，并在META-INF/services目录下提供该接口的实现类。Java通过类加载器在运行时动态加载这些实现，从而实现服务的动态扩展。
SPI的基本步骤： 定义服务接口：创建一个Java接口，定义服务的行为。实现服务接口：一个或多个类实现该接口。配置服务提供者：在META-INF/services目录下创建一个以服务接口全限定名命名的文件，文件内容为实现该接口的实现类的全限定名。加载服务：使用ServiceLoader类加载并实例化实现类。 3.3 实现和使用SPI 1. 定义服务接口 public interface MyService { void execute(); } 2. 实现服务接口 public class MyServiceImpl implements MyService { @Override public void execute() { System.out.println("MyServiceImpl executed!"); } } 3. 配置服务提供者 在META-INF/services目录下创建文件com.example.MyService，内容为：
com.example.MyServiceImpl 4. 加载服务 ServiceLoader&lt;MyService&gt; loader = ServiceLoader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70f06a9fa8175601f2334b9bc5f882f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d5528ab0e65e06c19ae312e926921f/" rel="bookmark">
			探索国内大模型AIGC产品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 人不走空
🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 目录
🌈个人主页：人不走空 💖系列专栏：算法专题
⏰诗词歌赋：斯是陋室，惟吾德馨
现状：B端占据主力，C端免费为主
AI原生应用和多模态趋势
未来展望
我使用过的AIGC产品体验分享
1. 百度文心一言
2. 阿里巴巴的通义千问
3. 腾讯元宝
4. 字节跳动的灵犀AI
我的选择：腾讯元宝
AIGC市场的未来发展方向
总结
作者其他作品：
当谈到大模型AIGC产品时，我们正处于一个令人兴奋的时刻。这些强大的AI模型正在不断进化，为我们带来更智能、更个性化的体验。让我们一起探讨一下现状、趋势以及未来的发展方向。
现状：B端占据主力，C端免费为主 根据最新的《中国AIGC应用全景报告》1，预计2024年中国AIGC应用市场规模将达到200亿人民币，到2030年将达到万亿规模，成为全球AI领域的重要增长点。在这个百亿市场中，一些特征开始显现：
B端产品成为主力：B端产品占据了整个大模型市场中八成的营收。这些产品主要面向企业，商业模式较为清晰，多数实现了盈利。C端产品免费为主：虽然C端产品占比较大，但近50%的产品仍未有明确的收入模式，以免费为主。这可能是因为C端用户需求不太明确，对产品易用性要求较高。 AI原生应用和多模态趋势 AI原生应用：这些应用完全基于生成式AI技术打造，占比接近57%。它们能够处理更复杂的任务，生成高质量的内容。多模态技术：这是AIGC的大趋势，应用产品占比已接近50%。未来，人机交互将更加自然和多元。 未来展望 产品落地阶段（2024-2027）：B端市场商业模式明确，C端市场从获客为先转向盈利为先。商业模式发展成熟阶段（2028-2029）：视频生成和多模态技术成熟，将助力AGI实现。规模化盈利阶段（2030以后）：AIGC应用将成为万亿规模市场，同时具备“听说读写看画思动”八项能力。 我使用过的AIGC产品体验分享 1. 百度文心一言 百度文心一言是百度推出的生成式语言模型，主打中文语境下的内容生成。文心一言在文本生成的准确性和上下文理解方面表现出色，尤其在回答复杂的中文问题和生成高质量的中文文章时，非常流畅和自然。作为国内首个由百度深度学习研究院开发的语言模型，文心一言已经在多个场景中得到了验证。
体验亮点：
出色的中文理解能力：文心一言在中文语境下的表现尤为出色，能够准确理解并生成语法和语义高度匹配的内容。支持多种生成模式：文心一言不仅适用于对话和问答，还能够在创意写作和技术文档等场景中生成高质量内容。强大的API支持：百度提供了丰富的API接口，方便开发者将其集成到不同的应用中，充分发挥其生成能力。 使用场景：
内容创作：适用于撰写文章、小说等创意类内容。智能客服：在自动应答系统中表现优异，能够理解并回应用户的多样化问题。 2. 阿里巴巴的通义千问 通义千问是阿里巴巴在生成式AI领域的旗舰产品，定位于提供企业级解决方案。其多功能的自然语言处理能力在智能客服、内容生成等应用场景中表现不俗。此外，通义千问还具备强大的数据分析能力，能够高效地处理和生成多种形式的内容。
体验亮点：
企业级应用的深度整合：通义千问特别适合企业应用，从电商到物流，从金融到健康，能够帮助企业提升效率和服务水平。强大的数据处理和分析能力：基于阿里巴巴在数据和计算能力上的优势，通义千问在大规模数据处理和生成方面表现卓越。出色的多语言支持：在多语言处理和生成方面，通义千问表现出色，能够满足全球化业务的需求。 使用场景：
智能客服：为客户提供自动化的、高效的客服解决方案。数据分析与报告生成：自动生成复杂的商业报告和数据分析。 3. 腾讯元宝 作为最新上线的产品，腾讯元宝迅速引起了广泛关注。元宝APP不仅可以生成文字内容，还能进行图像、音乐等多模态生成任务，满足用户在不同场景下的需求。凭借腾讯在社交和内容生态上的深厚积累，元宝在内容生成的个性化和社交互动方面有着明显的优势。
体验亮点：
多模态生成能力：元宝不仅支持文字生成，还能生成图像和音乐，使其在多种创作场景中都非常有用。高度个性化的内容推荐：元宝能够根据用户的兴趣和历史行为进行个性化内容推荐，极大地增强了用户体验。无缝融入腾讯的生态系统：元宝与腾讯的社交平台深度整合，用户可以轻松将生成的内容分享到微信、QQ等社交网络。 使用场景：
社交分享与创意表达：用户可以在社交平台上分享自己生成的内容，与好友互动。内容创作：适用于生成文字、图像和音乐，满足不同类型的创作需求。 4. 字节跳动的灵犀AI 灵犀AI是字节跳动推出的生成式AI产品，旨在通过短视频和图文生成增强用户体验。灵犀AI在个性化内容推荐和生成方面表现突出，尤其是在抖音等平台的内容创作中，提供了强大的创意支持。此外，灵犀AI还能够根据用户偏好，生成高度定制化的内容。
体验亮点：
强大的短视频和图文生成能力：灵犀AI能够生成高质量的短视频和图文内容，适合在抖音等平台上发布和传播。个性化推荐和生成：灵犀AI能够根据用户的兴趣和行为，生成高度定制化的内容，满足用户个性化的需求。深度整合字节跳动的内容平台：灵犀AI与字节跳动的各大内容平台无缝集成，为用户提供了丰富的创作和分享机会。 使用场景：
短视频创作：用户可以生成创意短视频，并发布在抖音等平台上。个性化内容推荐：根据用户的兴趣和偏好，生成定制化的内容推荐。 我的选择：腾讯元宝 在体验了多款AIGC产品后，我更倾向于选择腾讯元宝。以下是我的选择理由：
多模态生成能力：元宝不仅能生成文字，还支持图像和音乐的生成，这使得它在多种创作场景中都非常有用。
个性化推荐和社交互动：元宝能够根据用户的兴趣和历史行为进行个性化内容推荐，并且与腾讯的社交平台无缝整合，极大地增强了用户互动体验。
易于使用的界面和工具：元宝提供了一个用户友好的界面，简化了复杂的AI生成任务，使得即使是非技术用户也能轻松上手。
AIGC市场的未来发展方向 展望未来，国内的AIGC市场将可能在以下几个方向上进一步发展：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d5528ab0e65e06c19ae312e926921f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0678b346f0e457e3113368442427e2/" rel="bookmark">
			【Web世界探险家】3. CSS美学（二）文本样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📚博客主页：爱敲代码的小杨.
✨专栏：《Java SE语法》 | 《数据结构与算法》 | 《C生万物》 |《MySQL探索之旅》 |《Web世界探险家》
❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️
🙏小杨水平有限，欢迎各位大佬指点，相互学习进步！
小杨近些在学习人工智能方面的知识,发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
文章目录 1. 字体样式属性1.1 字体样式（font-family）1.2 字体大小（font-size）1.3 字体粗细（font-weight）1.4 文字样式（font-style）1.5 字体复合属性1.6 总结 2. 文本样式属性2.1 文本颜色（color）2.2 对齐文本（text-align）2.3 装饰文本（text-decoration）2.4 文本缩进（text-indent）2.5 行间距（line-height）2.6 总结 1. 字体样式属性 CSS Fonts（字体）属性用于定义字体系列，大小，粗细和文字样式（如斜体）。
1.1 字体样式（font-family） font-family属性用于设置字体。网页中常用的字体有宋体，微软雅黑，黑体等
语法:
选择器 { font-family: "字体样式"; } /* 例子 : 将p标签的文字改成微软雅黑 */ p { font-family: "黑体"; } /* 可以同时设置多个字体,如果浏览器不支持第一个字体,则回尝试下一个,直到找到合适的字体 */ boday { font-famliy: "微软雅黑","宋体","黑体"; } 运行结果：
小结：
各种字体之间必须使用英文状态下的逗号分隔；一般情况下，如果有空格隔开的多个单词组成的字体，加引号；尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示。 1.2 字体大小（font-size） font-size 属性用于设置字体大小。
语法：
标签名{ font-size: 数值px; } /* 例子：讲p标签的文字设置为20像素 */ p { font-size: 20px; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e0678b346f0e457e3113368442427e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10f5957bcaaaf364d945568fafb864f/" rel="bookmark">
			Elasticsearch：Open Crawler 发布技术预览版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：来自 Elastic Navarone Feekery
多年来，Elastic 已经经历了几次 Crawler 迭代。最初是 Swiftype 的 Site Search，后来发展成为 App Search Crawler，最近又发展成为 Elastic Crawler。这些 Crawler 功能丰富，允许以稳健而细致的方式将网站数据导入 Elasticsearch。但是，如果用户想在自己的基础设施上运行这些 Crawler，他们也需要运行整个企业搜索。企业搜索代码库非常庞大，包含许多不同的工具，因此用户无法选择只运行 Crawler。由于企业搜索是私有代码，因此用户也不完全清楚他们正在运行什么。
这一切都改变了，因为我们发布了最新版本的 Crawler：Open Crawler！
Open Crawler 允许用户从他们喜欢的任何位置抓取 Web 内容并将其索引到 Elasticsearch 中。使用 Elastic Cloud 没有任何要求，也不需要运行 Kibana 或企业搜索实例。只需要一个 Elasticsearch 实例即可将抓取结果导入其中。
这次的存储库也是开放代码。用户现在可以检查代码库、提交问题和 PR 请求，或者分支存储库进行更改并运行他们自己的爬虫变体。
有什么变化？ Open Crawler 比之前的 SaaS 爬虫轻量得多。该产品本质上是现有 Elastic Crawler 的核心爬虫代码，与企业搜索服务分离。分离 Open Crawler 意味着暂时放弃一些功能。如果你想阅读我们实现功能对等的路线图，本博客末尾有一个完整的功能比较表。我们打算重新引入这些功能，并在该产品成为正式发布时达到近乎功能对等。
这个过程还使我们能够对核心产品进行改进。例如：
我们能够消除索引命名的限制现在可以在抓取和提取内容之前对索引使用自定义映射抓取结果现在也被批量索引到 Elasticsearch 中，而不是一次索引一个网页 这提供了显着的性能提升，我们将在下面介绍 它与 Elastic Crawler 相比如何？ 如前所述，此爬虫程序可以从你喜欢的任何地方运行；你的计算机、你的个人服务器或云托管服务器。它可以将文档索引到本地、云甚至无服务器的 Elasticsearch 中。你也不再需要使用企业搜索将你的网站内容导入 Elasticsearch。
但最令人兴奋的是，Open Crawler 也比 Elastic Crawler 更快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e10f5957bcaaaf364d945568fafb864f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5750c4fdde6dc13d7041f87dece34aa/" rel="bookmark">
			大数据开发--基于Hive的航空公司客户价值分析案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标与背景 本案例的目标是客户价值识别，通过航空公司客户数据识别不同价值的客户。航空公司通常会将客户划分成几种客户，如：重要保持客户、重要发展客户、重要挽留客户、一般客户和低价值客户，识别客户价值应用最广泛的RFM模型是通过3个指标来进行客户细分，识别出高价值的客户（最近一次消费时间间隔（Recency）、
消费频率（Frequency）、消费金额（Monetary））
消费金额表示在一段时间内， 客户购买该企业产品金额的总和。
由于航空票价受到运输距离、舱位等级等多种因素影响，同样消费金额的不同旅客对航空公司的价值是不同的
例如，一位购买长航线、低等级舱位票的旅各与一位购买短航线、高等级验位票的旅客相比，后者对于航空公司而言价值可能更高。
因此，这个指标并不适用于航空公司的客户价值分析。
我们选择客户在一定时间内累积的飞行里程M和客户在一定时间内乘坐舱位所对应的折扣系数的平均值两个指标代替消费金额。
此外，考虑航空公司会员人会在时间的长短在定程度上能够影响客户价值，所以在模型中增加客户关系长度L作为区分客户的另一指标。
加粗样式本案例将客户关系长度、消费时间间隔、消费频率、飞行里程和折扣系数的平均值五个指标作为航空公司识别客户价值指标，建立LRFMC模型。
使用Hive对客户数据进行探索分析、数据预处理。
使用K-means对客户进行聚类分群，来实现航空公司利益最大化。
文章目录 目标与背景一、数据预处理二、K-means聚类二、使用步骤总结 一、数据预处理 数据集包含了62988条数据，其中有44个字段，主要字段有客户基本信息（会员卡号，入会时间等）、乘机信息（票价收入，平均折扣率等）、积分信息（积分兑换次数等）。
首先建立Hive仓库 CREATE DATABASE air_data; USE air_data; 2.建立数据表
CREATE TABLE air( member_no STRING, ffp_date STRING, first_flight_date STRING, gender STRING, ffp_tier INT, work_city STRING, work_province STRING, work_country STRING, age INT, load_time STRING, flight_count INT, bp_sum BIGINT, ep_sum_yr_1 INT, ep_sum_yr_2 BIGINT, sum_yr_1 BIGINT, sum_yr_2 BIGINT, seg_km_sum BIGINT, weighted_seg_km DOUBLE, last_flight_date STRING, avg_flight_count DOUBLE, avg_bp_sum DOUBLE, begin_to_first INT, last_to_end INT, avg_interval FLOAT, max_interval INT, add_points_sum_yr_1 BIGINT, add_points_sum_yr_2 BIGINT, exchange_count INT, avg_discount FLOAT, p1y_flight_count INT, l1y_flight_count INT, p1y_bp_sum BIGINT, l1y_bp_sum BIGINT, ep_sum BIGINT, add_point_sum BIGINT, eli_add_point_sum BIGINT, l1y_eli_add_points BIGINT, points_sum BIGINT, l1y_points_sum FLOAT, ration_l1y_flight_count FLOAT, ration_p1y_flight_count FLOAT, ration_p1y_bps FLOAT, ration_l1y_bps FLOAT, point_notflight INT ) ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' //以,为分隔 TBLPROPERTIES ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5750c4fdde6dc13d7041f87dece34aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75f1ce534015b602bc279de2b12a752/" rel="bookmark">
			2024-06-10 问AI: 在大语言模型中，ReAct Agents的理论基础是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文心一言 在大语言模型中，ReAct Agents的理论基础主要基于以下几个关键点：
推理与行为的结合：ReAct框架的核心思想是将大型语言模型的推理能力和行为能力相结合。这种结合使得模型能够以交错的方式生成推理步骤和特定于任务的操作，从而实现更智能的AI表现。这种协同作用类似于人类智能中将以任务为导向的行动和关于下一步行动的推理无缝结合的特点。
增强的动作空间：ReAct的基本思想之一是增强了动作空间，将原始的动作空间A与语言模型空间L结合，形成增强的动作空间A=A∪L。其中，来自语言模型空间的动作at∈L，一般称作thought，它不会影响外部环境，因此也不会收到观测反馈。这种增强的动作空间允许模型在推理和行动之间进行更灵活的切换。
few-shot in-context学习：ReAct框架基于权重固化的语言模型（如PaLM-540B），采用few-shot in-context学习来生成解决问题的action和thought序列。每个in-context样例由action、thought、observation构成的行为轨迹，引导模型经历一个循环过程：产生一个想法，采取一个行动，然后观察行动的结果。
动态推理和与环境的交互：ReAct允许模型执行动态推理，生成高级计划，并可与外部环境交互以收集额外的信息。这种能力使模型能够更好地适应不可预见的情况，并快速学习新任务。
提升性能：在实际应用中，ReAct在多种语言推理和决策任务中均表现出色。例如，在交互式决策基准中，ReAct的表现明显优于模仿和强化学习方法，即使只有一两个上下文示例。这种性能的提升主要归因于推理和行为的结合，使得模型能够生成类似人类的解决任务的步骤，比没有推理痕迹的基线更容易解释。
综上所述，ReAct Agents的理论基础主要强调推理与行为的结合、增强的动作空间、few-shot in-context学习、动态推理和与环境的交互以及提升的性能等方面。这些特点使得ReAct框架成为实现更智能AI的有力工具。
智谱清言 大语言模型中的ReAct Agents理论基础是建立在人工智能领域内的自然语言处理（NLP）和强化学习（Reinforcement Learning）两项技术之上。ReAct Agents是一种以自然语言处理能力为核心，通过强化学习进行训练和优化的人工智能实体。
具体来说，ReAct Agents的理论基础涉及以下几个关键点：
自然语言处理（NLP）：这是ReAct Agents的核心能力，它使这些智能体能够理解和生成人类语言。基于深度学习的方法，如变换器（Transformers）架构，被广泛应用于构建能够处理大规模文本数据并捕捉语言深层次结构的模型。
强化学习（RL）：这是训练ReAct Agents的方法。在强化学习的框架下，智能体通过与环境互动来学习如何做出最佳决策。智能体根据其行为产生的结果（奖励或惩罚）来调整其行为策略，目的是最大化长期奖励。
多模态学习：ReAct Agents可能需要处理不仅仅是文本信息，还包括图像、声音等多模态数据。多模态学习允许ReAct Agents整合来自不同模态的信息，以更全面地理解和响应复杂的环境。
社会智能和情感智能：为了更好地与人类用户互动，ReAct Agents需要具备社会智能，理解社会规范、人类情感和语言中的隐含意义。这需要情感智能的支持，使智能体能够识别、理解和模拟人类情感。
迁移学习和适应性：ReAct Agents需要能够将在一个领域学到的知识迁移到另一个领域，并适应新的环境和任务。这需要智能体具备一定的泛化能力，能够在面对新的数据和情境时作出适应。
在《大语言模型驱动汽车行业群体智能&amp;组织孪生解决方案战略合作项目》的背景下，ReAct Agents可能会被训练来理解汽车行业的特定术语、业务流程和文化，以协助在该行业中实现自动化和智能化的经营链路。通过与易慧智能和面壁智能的合作，清华大学自然语言处理实验室能够将先进的群体智能理论框架和AI Agent技术应用于实际的汽车行业场景中，开发出具有针对性的AI应用产品，从而提升整个汽车行业全链路经营的效果和效率。
豆包 ReAct Agents 的理论基础是将大型语言模型的能力与推理和行动相结合，以提高其在理解和交互决策任务中的表现。其主要特点包括：
推理步骤：ReAct 代理能够模拟推理过程，包括搜索信息、处理数据和生成回答。使用工具：代理可以调用不同的工具来辅助任务的完成，例如搜索引擎、数据库查询、文件读取器等。交互式：ReAct 代理可以与用户进行交互，根据用户的问题执行相应的动作，并可能请求更多的输入或指导。适应性：ReAct 代理能够根据当前的上下文和历史交互来调整其行为，使其能够适应不同的查询和场景。可定制性：开发者可以根据特定的需求定制 ReAct 代理的行为，包括定义新的工具、修改提示模板或调整代理的逻辑。结构化输出：ReAct 代理能够生成结构化的输出，如 JSON，这使得其输出易于被其他系统或应用程序解析和使用。错误处理：ReAct 代理能够处理执行过程中可能出现的错误，并根据需要调整其行为或提示用户。聊天历史：ReAct 代理能够考虑聊天历史，这使得它能够在对话中上下文地响应，而不是仅仅基于当前的输入。实时反馈：通过实时的反馈和迭代处理，ReAct 代理可以在与用户的交互中学习和改进。 讯飞星火 ReAct Agents，即“增强推理代理”，是构建在大型语言模型（LLM）之上的智能体系统。它们的理论基础主要涉及如何将大规模语言模型的强大能力与实际的行动和推理相结合。这种结合不仅增强了模型处理复杂任务的能力，还提高了模型在真实世界应用中的适应性和灵活性。以下是ReAct Agents的理论基础和实现方式的详细分析：
理论背景和需求
信息时代的需求：在当前信息时代，大型语言模型的发展速度和影响力日益显著，其强大的推理及生成能力成为搭建智能体的关键组件。智能体的发展历程：多年来，人们一直试图打造能自主完成预设目标的智能体，以协助人类完成各种任务。随着大语言模型的蓬勃发展，基于LLM的智能体构建技术也取得了显著进展。 核心组件和架构
用户请求与智能体大脑：在基于LLM的智能体框架中，用户的问题或请求首先被接收，然后由充当系统“大脑”的LLM处理。规划与记忆模块：规划模块帮助智能体理解问题并寻找解决方案，而记忆模块管理智能体的过往行为，两者共同支持智能体执行复杂任务。 ReAct方法的特点和优势
融合推理与执行：ReAct方法通过结合特定任务的离散动作与语言描述，实现了在LLM中融合推理与执行的能力，这不仅提高了处理复杂问题的能力，还增强了模型在真实世界应用中的适应性和灵活性。可解释性和可控性：基于自然语言的推理路径增加了模型决策过程的可解释性，使用户能够更好地理解和校验模型行为，同时注重模型行动的透明度与控制性，确保安全性与可靠性。 实现原理和技术细节
观察、思考、规划、行动循环：ReAct Agent的核心算法原理基于“观察-思考-规划-行动”的循环过程，这一过程涉及到从环境中获取信息、使用LLM进行理解和分析、生成行动计划以及执行计划中的步骤。多模态交互与动态适应：引入多模态交互和动态角色适应，使得智能体能够更自然有效地处理复杂任务和环境，提升用户体验和执行效率。 与其他框架的比较
不同的实现思路：ReAct方式是AI Agent最常用的实现思路之一，与其他如纯Prompt方式、思维链方式等相比，ReAct强调在执行任务时结合推理和行动两个方面，使得Agent能够在复杂和动态的环境中更有效地工作。性能表现与优势：ReAct提供了一种有效的解决方案，可以帮助语言模型更好地理解和回答自然语言问题，与传统的少样本学习方法相比，ReAct更加高效、准确，可以处理更复杂的任务和场景。 此外，在深入了解ReAct Agents的理论基础后，还可以从以下几个方面进一步探讨其应用和发展前景：
探索更多任务类型：虽然ReAct主要关注知识密集型推理任务，但它也可以应用于其他类型的自然语言处理任务，例如对话系统和机器翻译。提高行动空间的质量：当前的行动空间限制较大，未来的研究可以探索如何提高行动空间的质量，以便更好地支持推理和决策。结合强化学习：ReAct目前是一种无监督的学习方法，但它仍然缺乏对于长期奖励的关注。未来的研究可以考虑结合强化学习，以实现更好的长期规划和决策能力。 综上所述，ReAct Agents的理论基础在于其能够有效地结合大规模语言模型的强大推理能力与实际的行动执行，通过一系列精心设计的模块和流程，实现对复杂任务的高效处理。这种方法不仅提高了模型在处理特定任务时的效率和准确性，还在用户交互和系统长期发展方面展现出了强大的适应性和可持续性。随着技术的进一步发展和应用范围的不断扩大，ReAct Agents有望在人工智能领域发挥更大的作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75f1ce534015b602bc279de2b12a752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d7639bb37245d9e32f0a20ae712b86b/" rel="bookmark">
			目前初阶数据结构最难的一集-树&#43;二叉树_堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.树的概念以及结构 1.1.树的概念 在数据结构中我们都是怎样定义树的？
树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点
其实很简单，为了更适合理解，我们引用出了树木+亲缘关系，结构上像倒过来的树，每个节点关系像父子关系，有点像家谱
节点的度：一个节点含有的子树的个数称为该节点的度； 就是看这个节点有几个孩子
叶节点或终端节点（也就是这棵树的最后）：度为0的节点称为叶节点； 如上图：J、K、H、I...等节点为叶节点；就是看辈分最小（没有孩子的节点）的几个孩子
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点
孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
树的度：一棵树中，最大的节点的度称为树的度； 如上图：度最大的节点为A 树的度为3
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推
树的高度或深度：树中节点的最大层次； 如上图：树的高度为4（用家族的感觉就是这个家族有几代人）
堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点
节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先，相当于直系亲属
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林； 子树之间不能相交，比如说BC不能相连，相连则不为树，
相连为另一种数据结构：图 1.2.树的相关概念 树是递归定义的 任何一棵树都由【根和N（N&gt;=0）个子树】构成
比如，A由A和3个子树（B,C,D）构成，而B又由2个子树（E,F）构成，就这样一层层的递归，最终形成一整个树
1.3.树的表示 总体来说，有三种表达方式
1.直接暴力c++
2.利用顺序表，存储指针数组
3.定义出孩子指针和兄弟指针，找出父节点的第一个左孩子，然后由这个左孩子找出他的兄弟们
1.4.树在实际生活中的应用 2.二叉树的概念以及结构 2.1.概念 一棵二叉树是结点的一个有限集合，该集合:
1. 或者为空
2. 由一个根节点加上两棵别称为左子树和右子树的二叉树组成
简单来说就是树最多只能分成俩叉
2.2.特殊的二叉树 1.满二叉树：满二叉树是一种特殊的二叉树，它的每个非叶子节点都有两个子节点，而且所有的叶子节点都在同一层上。换句话说，它是一棵深度为k且恰好有2^k-1个节点的二叉树，其中k为正整数。相当于每个父亲都有俩儿子，他也是一种特殊的完全二叉树
2.完全二叉树：完全二叉树是一种特殊的二叉树，它除了最后一层节点不满外，其余各层节点数都达到了最大值，并且最后一层的节点都集中在树的左侧。换句话说，如果把一棵完全二叉树的节点按照从上到下、从左到右的顺序依次编号，那么编号为i的节点的左儿子的编号一定为2i，右儿子的编号一定为2i+1，相当于之前都是俩儿子，到最后一辈开始参差不齐，但是从左到右必须连续，不能空
2.3.二叉树的性质 2.4.二叉树的存储结构 在我们想象中二叉树是像上面一样的，但是实际在计算机内存中却不是这么存储的
逻辑结构
物理结构
因此我们要把他想象成如下的结构
3.二叉树的顺序结构以及其实现 3.1.二叉树的顺序结构 相当于数组存储，因此我们在进行代码实现时必须代换成我们想象中的逻辑结构
我们假设上图中父亲为i,则左儿子则为2i+1,右儿子则为2i+2
假设儿子为i,则父亲为（i-1）/ 2,（因为计算机在进行整形除法时会删除小数点，所以不用区分左右儿子）
正式讲二叉树之前就让我们先看二叉树的衍生物--堆，来帮助我们更好理解
3.2.堆的概念及其结构 首先堆必须是一个完全二叉树
其次通过父亲和孩子的大小关系可以区分为大小堆，大堆的根皆为最大，小堆同上
注意落实在内存中的存储不一定为升序 / 降序（因为兄弟之间没有大小关系）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d7639bb37245d9e32f0a20ae712b86b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a9acb3f7c180f9294b0acb4005bad10/" rel="bookmark">
			说说Lambda架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lambda架构由Storm的作者Nathan Marz提出，其设计目的在于提供一个能满足大数据库系统关键特性的架构，包括高容错、低延迟、可扩展等。其整合离线批处理和实时流处理，融合不可变形、读写分离和复杂隔离性等原则，集成Hadoop、Kafka、Spark、Storm、Flink等主流大数据组件，达到强鲁性、低延迟的大数据架构思想。
Lambda架构可以分为三层，即批处理层、加速层和服务层，
批处理层(Batch Layer)：主要是存储数据集和生成Batch View。Batch Layer可以很好地处理离线数据，处理地是全量数据，数据处理时延高。
加速层(Speed Layer)：存储实时视图并处理传入的数据流，以便更新这些视图。Speed Layer处理地是最近地增量地数据流。
服务层(Serving Layer)：用于响应用户的查询请求，合并 Batch View 和 Real-time View 中的结果数据集到最终的数据集。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b4474fd8f77c96806ac312057837c0/" rel="bookmark">
			MySQL内训连接汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL周内训参照1、ER实体关系图与数据库模型图绘制-CSDN博客
MySQL周内训参照2、DDL与DML语句-CSDN博客
MySQL周内训参照3、简单查询与多表联合复杂查询-CSDN博客
MySQL周内训参照4、触发器-插入-修改-删除-CSDN博客
MySQL周内训参照5、存储过程创建-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6466c0f02a80b76532b1101001d9b9/" rel="bookmark">
			springboot3一些听课笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、错误处理机制1.1 默认1.2 自定义 二、嵌入式容器 一、错误处理机制 1.1 默认 错误处理的自动配置都在ErrorMvcAutoConfiguration中，两大核心机制：
● 1. SpringBoot 会自适应处理错误，响应页面或JSON数据
● 2. SpringMVC的错误处理机制依然保留，MVC处理不了，才会交给boot进行处理
规则：
解析一个错误页
a. 如果发生了500、404、503、403 这些错误
ⅰ. 如果有模板引擎，默认在 classpath:/templates/error/精确码.html
ⅱ. 如果没有模板引擎，在静态资源文件夹下找 精确码.html
b. 如果匹配不到精确码.html这些精确的错误页，就去找5xx.html，4xx.html模糊匹配
ⅰ. 如果有模板引擎，默认在 classpath:/templates/error/5xx.html
ⅱ. 如果没有模板引擎，在静态资源文件夹下找 5xx.html如果模板引擎路径templates下有 error.html页面，就直接渲染 1.2 自定义 最佳实战
● 前后分离
○ 后台发生的所有错误，@ControllerAdvice + @ExceptionHandler进行统一异常处理。
● 服务端页面渲染
○ 不可预知的一些，HTTP码表示的服务器或客户端错误
■ 给classpath:/templates/error/下面，放常用精确的错误码页面。500.html，404.html
■ 给classpath:/templates/error/下面，放通用模糊匹配的错误码页面。 5xx.html，4xx.html
○ 发生业务错误
■ 核心业务，每一种错误，都应该代码控制，跳转到自己定制的错误页。
■ 通用业务，classpath:/templates/error.html页面，显示错误信息。
页面，JSON，可用的Model数据如下
二、嵌入式容器 Servlet容器：管理、运行Servlet组件（Servlet、Filter、Listener）的环境，一般指服务器。
首先
● SpringBoot 默认嵌入Tomcat作为Servlet容器。
● 自动配置类是ServletWebServerFactoryAutoConfiguration
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6466c0f02a80b76532b1101001d9b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7979d7b94627833585dab1847eb287e/" rel="bookmark">
			mac免费的ntfs软件哪个好 MAC读取NTFS硬盘格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于苹果用户来说，Mac电脑和移动硬盘已经成为日常工作中不可缺少的一部分，但有时我发现Mac打开移动硬盘只能读取无法写入，这是由于所连接的移动硬盘为NTFS格式。我们可以通过对硬盘格式化为Mac正常读写格式，或使用数据读写软件对NFTS硬盘进行写入数据。那么MAC有没有免费NTFS ？今天为大家详细介绍MAC读取NTFS硬盘的方法以及软件。
一、MAC有没有免费NTFS Mac系统并没有自带的NTFS读取工具，我们需要下载第三方数据读取软件帮助Mac读取NTFS硬盘。今天为大家介绍两款免费试用的NTFS读取软件。
1.Tuxera NTFS for Mac
Tuxera NTFS for Mac是一款优秀的Mac系统完全读写软件，虽然是付费软件，但用户可以免费试用。Tuxera NTFS for Mac提供Fat32、NTFS、Exfat、mac os扩展格式的转换，稳定性好，传输速度极快。Tuxera NTFS for Mac功能丰富，我们能修复NTFS卷、创建NTFS磁盘映像、创建NTFS分区等等。它的使用方法简单，安装即可使用，可稳定地应用于内外置设备，对于u盘、移动硬盘等设备的格式化也能稳定进行。
2.Mounty NTFS for Mac
Mounty NTFS吸引人的优势在于它是一款免费读写NTFS硬盘软件。但值得注意的是，它的本质是利用Mac内置的读写命令来读写NTFS硬盘。随着Mac系统不断升级，读写命令将会失效。这种方式虽然免费，但很不稳定，常常会有丢失数据的危险。此外，它的传输速度很慢，对于追求续写速度和数据安全的用户来说，不是最佳选择。
二、MAC读取NTFS硬盘 Mac如何利用数据读取软件对NTFS硬盘进行读写？我以Tuxera NTFS for Mac软件为例，下面为大家介绍如何读写NTFS硬盘。
1.下载Tuxera NTFS for Mac 2023最新版安装包：https://souurl.cn/IE35lO
2.根据提示安装Tuxera NTFS for Mac软件。
3.完成安装后，打开系统设置，找到Microsoft NTFS by Tuxetra。​​​​​​​
4.在Microsoft NTFS by Tuxera通用设置里，修改软件状态为“已启用”。
成功设置后，无需再做任何设置，Mac电脑便获得了对NTFS格式磁盘的正常读写权限。无论是对于外置的ntfs磁盘，还是mac电脑的ntfs分区，软件都可自动完成读写设置。
三、Mac如何抹掉NTFS格式 虽然mac电脑能通过读写软件对NTFS格式的磁盘进行写入，但为了更好地利用磁盘，我们可通过抹掉磁盘NTFS格式的方法，实现磁盘在mac电脑中的写入功自由使用。接下来，我们使用Tuxera NTFS for Mac具体操作一下。
1.如下图所示，打开Tuxera NTFS for Mac磁盘管理工具，可以从启动台找到Tuxera Disk Manager。
2.在磁盘管理工具的左侧列表中，选择需要抹掉NTFS格式的磁盘。
3.确认好磁盘后，选择“格式”，并在其文件系统选项中选择Mac可读写的格式，如exFAT、FAT32等。选定好格式化后文件系统，点击“格式化”。
4.再次确认是否执行格式化，即可得到全新格式的硬盘。
以上就是关于MAC有没有免费NTFS和MAC读取NTFS硬盘的相关内容。除了以上的操作外，Mac如何抹掉NTFS格式，本文也给出了具体的操作步骤。希望对大家在移动硬盘的使用方面上有所帮助。
Tuxera NTFS For Mac 2023 中文免费安装包下载：​​​​​​​https://souurl.cn/IE35lO
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7979d7b94627833585dab1847eb287e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147bebc6a010759108aa696fc8747aec/" rel="bookmark">
			【数据结构】【版本1.0】【线性时代】——顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快乐的流畅：个人主页 个人专栏：《算法神殿》《数据结构世界》《进击的C++》 远方有一堆篝火，在为久候之人燃烧！ 文章目录 引言一、顺序表的概念1.1 最基础的数据结构：数组1.2 数组与顺序表的区别 二、静态顺序表三、动态顺序表的模拟实现3.1 定义3.2 初始化3.3 销毁3.4 扩容3.5 尾插3.6 头插3.7 尾删3.8 头删3.9 指定插入3.10 指定删除3.11 查找3.12 修改3.13 打印 引言 数据结构世界——顺序表（Sequential List）
一、顺序表的概念 1.1 最基础的数据结构：数组 【思考】有了数组，为什么还要学习其他的数据结构？
假定数组有10个空间，已经使用了5个，向数组中插入数据步骤：求数组的长度，求数组的有效数据个数，向下标为数据有效个数的位置插入数据（注意：这里是否要判断数组是否满了，满了还能继续插入吗）…
假设数据量非常庞大，频繁的获取数组有效数据个数会影响程序执行效率。
结论：最基础的数据结构能够提供的操作已经不能完全满足复杂算法实现。
1.2 数组与顺序表的区别 顺序表的底层结构是数组，对数组的封装，实现了常用的增删改查等接口。
二、静态顺序表 //静态顺序表 #define N 10 typedef int SLDataType; typedef struct SeqList { SLDataType a[N]; int size; }SL; ​​​​
静态顺序表缺陷：空间给少了不够用，给多了造成空间浪费。
三、动态顺序表的模拟实现 3.1 定义 //动态顺序表 typedef int SLDataType; typedef struct SeqList { SLDataType* a; int size;//存储的有效数据的个数 int capacity;//容量 }SL; 顺序表的各种功能，都是通过函数来实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/147bebc6a010759108aa696fc8747aec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca10c24651b2d84b7b90e2617c041b44/" rel="bookmark">
			【数据结构】前缀树（字典树)汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础 {“a”,“abc”,“bac”,“bbc”,“ca” }的字典树如下图：
最主用的应用：一，字符串编码。二，位运算。
字符串编码 相比利用哈希映射编码，优点如下：
依次查询长度为n的字符串s的前缀时间复杂度是O(n)。查询完s[0…i]，再查询s[0…i+1]的时间复杂度是O(1)。而哈希映射的时间复杂度是：O(nn)。
利用哈希映射编码的代码如下：
注意m_iLeafIndex 为-1，表示此节点不是任何字符串的结束字符。
class CStrToIndex { public: CStrToIndex() { } CStrToIndex(const vector&lt;string&gt;&amp; wordList) { for (const auto&amp; str : wordList) { Add(str); } } int Add(const string&amp; str) { if (m_mIndexs.count(str)) { return m_mIndexs[str]; } m_mIndexs[str] = m_strs.size(); m_strs.push_back(str); return m_strs.size()-1; } vector&lt;string&gt; m_strs; int GetIndex(const string&amp; str) { if (m_mIndexs.count(str)) { return m_mIndexs[str]; } return -1; } protected: unordered_map&lt;string, int&gt; m_mIndexs; }; 利用字典树编码的代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca10c24651b2d84b7b90e2617c041b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b414caf0c87e06e8c7120ad7a1df684/" rel="bookmark">
			【数据结构】排序（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页~
堆排序看这篇~
还有这篇~
排序 一、排序的概念及应用1、概念2、常见的排序算法 二、常见排序的实现1、直接插入排序（1）基本思想（2）代码实现（3）时间复杂度（4）空间复杂度 2、希尔排序（1）基本思想（2）代码实现（3）时间复杂度（4）空间复杂度 3、选择排序（1）基本思想（2）代码实现（3）时间复杂度（4）空间复杂度 4、堆排序（1）基本思想（2）代码实现（3）时间复杂度（4）空间复杂度 5、冒泡排序（1）基本思想（2）代码实现（3）时间复杂度（4）空间复杂度 6、快速排序（1）基本思想（2）代码实现①hoare版本②挖坑法版本③前后指针版本 （3）时间复杂度（4）空间复杂度 一、排序的概念及应用 1、概念 排序就是按照某一关键字递增和递减排列起来的操作
排序在生活中非常常用，成绩、排行等等一切跟数字字母等有关的都能够排序
2、常见的排序算法 常见的排序算法有
插入排序：直接插入排序，希尔排序
选择排序：选择排序，堆排序
交换排序：冒泡排序、快速排序
归并排序：归并排序
二、常见排序的实现 1、直接插入排序 （1）基本思想 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列
（2）代码实现 //我们看做一个一个插入 void InsertSort(int* a, int n) { for (int i = 1; i &lt; n; i++) { //从0到end都有序，tmp插入排序 int end = i - 1;//end存储插入前的最后一个元素的下标，也就是第i-1个数据 int tmp = a[i];//tmp是插入的数据，也就是第i个数据 while (end &gt;= 0) { if (a[end] &gt; tmp) { a[end + 1] = a[end]; end--; }//如果前边比后边大，就交换并且--end，继续向前比较 else { break;//直到后边比前边大 } } a[end + 1] = tmp;//将此时end+1下标的位置赋值tmp，后边的数据全都往后移了一位 } } 封装一个打印数组的函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b414caf0c87e06e8c7120ad7a1df684/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/285/">«</a>
	<span class="pagination__item pagination__item--current">286/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/287/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>