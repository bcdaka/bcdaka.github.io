<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e71f442d59559fd49105613c957a16/" rel="bookmark">
			微信小程序 跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通跳转
wx.navigateTo({ url: '/pages/xxx/xxx' }) 返回
wx.navigateBack({}) wx.navigateBack({ delta: 0 }) 关闭当前页并跳转
wx.redirectTo({ url: 'pages/xxx/xxx' }) 切换主菜单 wx.switchTab({ url: '../store/index' }) 小程序跳转
wx.navigateToMiniProgram({ appId: 'xxx', path: 'pages/index/index?phone=' + wx.getStorageSync('phone') }) 小程序跳转传递手机号参数
/** * 生命周期函数--监听页面加载 */ onLoad: function (options) { // 小程序跳转 wx.showModal({ title: '已迁移至新小程序', content: '请搜索“xxx”', showCancel: false, complete: (res) =&gt; { if (res.confirm) { wx.navigateToMiniProgram({ appId: 'xxx', path: 'pages/index/index?phone=' + wx.getStorageSync('phone') }) } } }) }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { // 兼容小程序跳转传递手机号 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08e71f442d59559fd49105613c957a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb08427eba2f1c5c42032b3dced1596c/" rel="bookmark">
			智能创作与优化新时代：【ChatGPT-4o】在【数学建模】、【AI绘画】、【海报设计】与【论文优化】中的创新应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 引言
什么是ChatGPT4o？
背景与发展历史
2.chatgpt4o数学建模
常见的数学建模专业术语及其简要说明
一个具体的代码例子
问题描述
代码实现 代码说明
运行结果
3.chatgpt4o在论文
1.例如生成基于标签的推荐系统模型及算法研究 1. 摘要
2. 引言
3. 文献综述
4. 模型与算法
5. 实验与分析
6. 结论与展望
7. 参考文献
案例背景
2.具体应用场景
1. 摘要优化
原稿：
ChatGPT优化后的版本：
优化点：
2. 引言部分的结构优化
原稿：
ChatGPT优化后的版本：
优化点：
3. 方法部分的细化与完善
原稿：
ChatGPT优化后的版本：
4. 结论的增强
原稿：
ChatGPT优化后的版本：
优化点：
总结
4.chatgpt4o绘画
1.案例背景
2.角色描述
3.主题：火焰魔法师
4.MJ 提示词：
5.图片生成
6.火焰魔法师
5.chatgpt4o代码编程 1.如何用Python进行网络爬虫？
代码说明：
常用的爬虫库：
安装所需库：
注意事项：
2.MATLAB演化三维图
1.三维线图 (3D Line Plot):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb08427eba2f1c5c42032b3dced1596c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8295a19b6b16a3dbb2b53df20f85abe6/" rel="bookmark">
			学习日志8.30--防火墙NAT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验环境配置
二、配置防火墙静态NAT一对一
三、配置防火墙静态NAT多对多
四、配置防火墙NAT端口转换NAPT
五、防火墙smart-nat、easyip
六、防火墙三元组NAT
在学习过基于路由器的NAT网络地址转换，现在学习基于防火墙NAT的网络地址转换，防火墙的NAT配置和路由器的NAT配置还是有比较大的区别。
防火墙NAT是通过NAT策略实现的，在创建防火墙NAT之前需要先创建防火墙的安全策略。防火墙是不能直接在接口下配置NAT接口映射的
一、实验环境配置 实验拓扑结构图按标注给实验设备配置IP地址，在路由器中配置接口信息，在防火墙中配置接口信息。
给防火墙配置静态路由
命令：[FW01]ip route-static 0.0.0.0 0 GigabitEthernet 1/0/1 12.1.1.2
在防火墙中先划分接口的安全区域，将内网划分为Trust区域，将Internet划分为Untrust区域。
命令：[FW01]firewall zone trust，进入到Trust区域
命令：[FW01-zone-trust] add interface GigabitEthernet 1/0/2，将接口划分到Trust区域，那接口所在的公司内网就属于安全区域。
命令：[FW01]firewall zone untrust，进入untrust区域
命令：[FW01-zone-untrust]add interface GigabitEthernet 1/0/1，将接口划分到Untrust区域
在防火墙配置安全策略
命令：[FW01]security-policy，进入到策略里面
命令：[FW01-policy-security]rule name tru-to-utru，新建一个策略规则，名字是tru-to-utru,意思是从trust区域到untrust区域
命令：[FW01-policy-security-rule-tru-to-utru]source-zone trust，配置源区域是trust
命令：[FW01-policy-security-rule-tru-to-utru]destination-zone untrust，目的区域是untrust
命令：[FW01-policy-security-rule-tru-to-utru]source-address 192.168.1.0，源地址是192.168.1.0
命令：[FW01-policy-security-rule-tru-to-utru]action permit，允许的动作是通过
配置安全策略，允许192.168.1.0网段的流量从trust区域到untrust区域的通过，安全策略没有配置目的地址，是因为连接Internet的地址太多，可以不进行配置，就只允许主动向外访问，不允许外主动向内访问。
在配置防火墙NAT之前应该先配置NAT策略，NAT策略配置应先配置防火墙地址组，然后再配置防火墙安全策略。
现在的需求是，给公司内网的两个主机PC1和PC2，两个客户端分配公有地址。服务器是外部访问内部的时候需要配置NAT，内部的主机访问内部的服务器是不需要配置NAT的。
向运营商申请四个地址120.1.1.101到10.1.1.104，分配给两台主机，两个客户端。运营商分配的地址120.1.1.0网段是和防火墙接口地址12.1.1.0不在同一个网段，所以应该由运营商的路由器进行静态路由的书写
命令：[ISP]ip route-static 120.1.1.101 32 GigabitEthernet 0/0/1 12.1.1.1
命令：[ISP]ip route-static 120.1.1.102 32 GigabitEthernet 0/0/1 12.1.1.1
命令：[ISP]ip route-static 120.1.1.103 32 GigabitEthernet 0/0/1 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8295a19b6b16a3dbb2b53df20f85abe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9efad6f42f0208472193ba68b8073e/" rel="bookmark">
			最短路算法详解（Dijkstra 算法，Bellman-Ford 算法，Floyd-Warshall 算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Dijkstra 算法二、Bellman-Ford 算法三、Floyd-Warshall 算法 由于文章篇幅有限，下面都只给出算法对应的部分代码，需要全部代码调试参考的请点击： 图的源码 最短路径问题：从在带权图的某一顶点出发，找出一条通往另一顶点的最短路径，最短也就是沿路径各边的权值总和达到最小。涉及到三个算法：
单源最短路径：Dijkstra 算法（迪杰斯特拉算法）（不能解决负权图）单源最短路径：Bellman-Ford 算法（贝尔曼-福特算法）（可以解决负权图）多源最短路径：Floyd-Warshall 算法（弗洛伊德算法）（可以解决负权图） 注意：本文采用的图是邻接矩阵实现的。
一、Dijkstra 算法 算法概括： Dijkstra 是一种求解非负权图上单源最短路径的算法。
算法流程： 其过程为：将结点分成两个集合，已确定最短路长度的点集（记为 S 集合）和未确定最短路长度的点集（记为 T 集合）。一开始所有的点都属于 T 集合。
需要对 dist 数组（存储最短路的长度）进行初始化，除了起点设置为 0 外，其它的都设置为无穷大。
接着重复如下操作：
从 T 集合中，选取一个最短路长度最小的节点，移动到 S 集合中。对那些刚刚加入 S 集合的结点的所有出边执行松弛操作。 直到 T 集合为空，算法结束。
时间复杂度： 每次确定一个顶点 O（n），并松弛其连接出去的所有边（最多有 n - 1条），其时间复杂度为 O（n ^ 2）。
松弛操作：
对于起点 B 到达点 A，松弛操作对应如下的式子：dis(A) = min(dis(A) , dis(C ) + 边 CA），当确定一个顶点的最短路径后，对其连出去的所有边进行松弛操作。
过程演示如下图：
代码如下： /** * @param vSrc 起点 * @param dist 存储从起点到各个顶点的最小权值 * @param pPath 存储各个顶点到起点的最短权值路径 */ public void dijkstra(char vSrc, int[] dist, int[] pPath) { //用来标记已经确定的点 boolean[] vis = new boolean[size]; //获取起点对应下标 int srcIndex = getVIndex(vSrc); //初始化 dist 和 pPath Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9efad6f42f0208472193ba68b8073e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45aa2ff6d7c3142f29dd2e8952e62c50/" rel="bookmark">
			SprinBoot&#43;Vue学生选课小程序的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 项目介绍2 项目截图3 核心代码3.1 Controller3.2 Service3.3 Dao3.4 application.yml3.5 SpringbootApplication3.5 Vue3.6 uniapp代码 4 数据库表设计5 文档参考6 计算机毕设选题推荐7 源码获取 1 项目介绍 博主个人介绍：CSDN认证博客专家，CSDN平台Java领域优质创作者，全网30w+粉丝，超300w访问量，专注于大学生项目实战开发、讲解和答疑辅导，对于专业性数据证明一切！
主要项目：javaweb、ssm、springboot、vue、小程序、python、安卓、uniapp等设计与开发,万套源码成品可供选择学习。
👇🏻👇🏻文末获取源码
SprinBoot+Vue学生选课小程序的设计与实现(源码+数据库+文档)
项目描述
学生选课的需求和管理上的不断提升，学生选课管理的潜力将无限扩大，微信小程序的学生选课系统在业界被广泛关注，本网站及对此进行总体分析，将学生选课信息管理的发展提供参考。微信小程序的学生选课系统对学生选课管理有着明显的带动效应。
本系统主要包括学生、教师和管理员；主要包括：首页、个人中心、学生管理、教师管理、课程类型管理、课程信息管理、选课信息管理、取消选课管理、管理员管理、系统管理等功能的管理系统。
2 项目截图 springboot微信小程序的学生选课系统
3 核心代码 3.1 Controller package com.controller; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import com.annotation.IgnoreAuth; import com.baomidou.mybatisplus.mapper.EntityWrapper; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45aa2ff6d7c3142f29dd2e8952e62c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa6f57f6e1cc33846667b80970f2c2cd/" rel="bookmark">
			C&#43;&#43;小技巧01：MessageBox弹窗函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、正文
1、介绍
2、按键样式
3、按键返回值
4、样式
1、前言 第一次写博客，大家多多支持😁
记得点个赞！👍
2、正文 1、介绍 今天分享一个c++&amp;c通用的弹窗函数——MessageBox
“弹窗”，就是在桌面弹出一个提示框
c++与c中函数名均为
MessageBox 使用它需使用
#include&lt;windows.h&gt; 头文件(只适用于windows）。
基本格式为：
MessageBox(NULL,"窗口内容","窗口标题",MB_OK); 示例代码：
#include&lt;bits/stdc++.h&gt; //万能头文件 #include&lt;windows.h&gt; //windows下可用 using namespace std; int main() { MessageBox(NULL,"窗口内容","窗口标题",MB_OK); return 0; } 运行效果：
第一个引号内代表窗口的内容，第二个引号内代表窗口的标题，“MB_OK”代表按钮样式，有一个按键确定。
2、按键样式 需要其他按键样式，只需按照下表替换上面基本格式的“MB_OK”即可。
MB_OK：1个按键，确定
MB_OKCANCEL：2个按键，确定和取消
MB_YESNO：2个按键，是和否
MB_RETRYCANCEL：2个按键，重试和取消
MB_ABORTRETRYIGNORE：3个按键，中止、重试和忽略
MB_YESNOCANCEL：3个按键，是、否和取消 3、按键返回值 按下按钮后，系统的返回值如下表
IDYES：选中是按钮
IDNO：选中否按钮
IDOK：选中确定按钮
IDCANCEL：选中取消按钮
IDABORT：选中中止按钮
IDIGNORE：选中忽略按钮
IDRETRY：选中重试按钮
写了一段判断返回值代码，供参考：
#include&lt;bits/stdc++.h&gt; #include&lt;windows.h&gt; using namespace std; int main() { cout&lt;&lt;"请做出选择\n\n"; //以确定取消为例 if(MessageBox(NULL,"窗口内容","窗口标题",MB_OKCANCEL)==IDOK)//确定 { cout&lt;&lt;"确定"; } else //取消 { cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa6f57f6e1cc33846667b80970f2c2cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a51c2fcc8bb725576b515eea9b048be/" rel="bookmark">
			MCU官方IDE软件安装及学习教程集合 — STM32CubeIDE（STM32）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 各MCU厂商为保证产品的市场地位以及用户体验，不断的完善自己的产品配套，搭建自己的开发生态，像国外ST公司，国内的GD（兆易创新），AT（雅特力）等等。目前就开发生态而言，ST的生态开发相对比较成熟，国内MCU也是在加紧开发步伐。本系列文章主要为大家介绍各个MCU厂家官方的IDE（集成开发环境）软件，开阔大家的认知，并包含软件安装教程及学习文章教程。虽然各个厂商配套的IDE并不像Keil、Eclipse这种软件可以在广泛使用各个厂商的MCU，但是也为开发者提供了一个开发环境选择，比如对于公司或者商业产品而言，Keil软件的使用是需要购买软件使用权的。
1、软件介绍 STM32CubeIDE是STM32Cube生态系统的一部分，它集成了编译器、调试器、项目管理器和文件编辑器等功能。用户可以在一个界面内完成代码编写、编译、调试和运行等操作。它支持多种编程语言和编译器，提供了丰富的调试工具，如断点设置、变量查看、内存查看等，使得调试过程更为直观和高效。
2、官网下载链接（软件及应用手册） https://www.st.com/content/st_com/en/stm32cubeide.htmlhttps://www.st.com/content/st_com/en/stm32cubeide.html
3、软件安装 （1）软件安装都是常规操作，需要注意以下三个事项即可：
安装路径不要出现中文；软件安装完成之后，需要指定文件夹作为软件配置相关文件的存储；软件安装时会出现调试器组件安装，在这可以看出，该软件调试只支持 SEGGER J-Link 和 ST-Link驱动的调试器，经过测试，DAP调试器也是可以使用的，具体操作可参考链接：http://t.csdnimg.cn/ZT7VVhttp://t.csdnimg.cn/ZT7VV （2）STM32CubeIDE是基于Java平台开发的集成开发环境（IDE），它依赖于Java运行环境来提供必要的支持和功能。因此需要搭建JAVA环境，JAVA软件下载链接为：https://www.java.com/en/download/https://www.java.com/en/download/ 下载完成直接安装即可（安装也是不要出现中文路径）。安装完成之后检查是否成功安装，我们可以打开 Windows 的命令输入框（win + R输入cmd），输入：java –version 命令，如果显示 Java 版本信息，则安装成功。
4、软件汉化 软件安装之后是默认英文的，要想显示中文界面，需要汉化操作，网上有很多教学存在汉化失败的现象，大家可参考这个教学：http://t.csdnimg.cn/FA6Twhttp://t.csdnimg.cn/FA6Tw
5、学习文章参考链接 【STM32CubeIDE学习专栏1】http://t.csdnimg.cn/eYCTYhttp://t.csdnimg.cn/eYCTY【STM32CubeIDE学习专栏2】http://t.csdnimg.cn/EqHgihttp://t.csdnimg.cn/EqHgi【STM32CubeIDE学习专栏3】http://t.csdnimg.cn/cC2qQhttp://t.csdnimg.cn/cC2qQ【STM32CubeIDE学习专栏4】http://t.csdnimg.cn/J3uwghttp://t.csdnimg.cn/J3uwg 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd07acf36a24aab6435b30ef9ed1ff8/" rel="bookmark">
			Spring Boot 整合 Sentinel 实现流量控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微服务架构中，流量控制是保障系统稳定性和高可用性的关键技术之一。阿里巴巴开源的 Sentinel 是一款面向分布式系统的流量防护组件，旨在从流量控制、熔断降级、系统负载保护等多个维度保障服务的稳定性。本文将详细介绍如何在 Spring Boot 项目中整合 Sentinel 实现流量控制。
1. Sentinel 简介 Sentinel 是阿里巴巴开源的一个轻量级流量控制框架，主要用于保护分布式服务的稳定性。其核心功能包括：
实时监控：通过控制台可以实时查看系统的流量、响应时间等数据。
流量控制：可以针对不同的资源设定不同的流量控制规则。
熔断降级：在服务不稳定或出现故障时，自动进行熔断降级处理。
系统自适应保护：根据系统的运行状况，自动调整流量控制策略。
2. Spring Boot 项目初始化 首先，我们需要创建一个 Spring Boot 项目。可以通过 Spring Initializr 创建项目，选择合适的依赖，如 Spring Web 等。
mvn archetype:generate -DgroupId=com.example -DartifactId=sentinel-demo -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=falsecd sentinel-demo 在 pom.xml 中添加 Spring Boot 相关依赖：
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 引入 Sentinel 依赖 在 pom.xml 中添加 Sentinel 依赖：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd07acf36a24aab6435b30ef9ed1ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08542a1b7d65b054725f06e709af051b/" rel="bookmark">
			【MySQL】字节跳动MySQL连环40问（网图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于 ❄️慕雪的寒舍
字节MySQL连环40问，网图
虽然感觉这玩意和字节跳动没关系，但是管他的？直接开始回答！
1.MySQL中有哪几种锁？ 会的不全，所以查的GPT
MySQL中有多种类型的锁，主要包括以下几种：
共享锁（Shared Lock）：也称为读锁，多个会话可以同时持有共享锁，并且不互斥。共享锁适用于读取操作，多个会话可以并发读取同一份数据而不会产生冲突。排他锁（Exclusive Lock）：也称为写锁，排他锁与其他任何锁都互斥，只有一个会话可以持有排他锁。排他锁适用于写入或修改操作，确保在某个会话持有排他锁的时候，其他会话无法同时进行写入操作。记录锁（Record Lock）：记录锁（行锁）是针对某条记录的锁定，用于保护特定记录的完整性。在使用InnoDB存储引擎时，读取或修改某条记录时会自动给该记录加上记录锁，其他会话则无法对该记录进行并发写入或删除操作。Gap锁：Gap锁是InnoDB引擎的一种锁机制，用于防止幻读。它锁定了一个范围，但不包含实际的记录，用于防止其他会话在这个范围内插入新记录，以避免幻读现象的发生。表锁（Table Lock）：表锁是对整个表格进行锁定，可以在某些特殊情况下使用，但会阻塞其他会话的读取和写入操作。在需要并发读写的情况下，表锁的性能较低，因此一般不推荐使用。 除此之外，还有一个NEXT-KEY锁：
NEXT-KEY 锁是 InnoDB 存储引擎中的一种锁机制，用于解决幻读问题。它是通过将 Gap 锁和 记录锁 组合而成的。
具体来说，当一个事务在 InnoDB 表中执行范围查询时，如使用 &lt;、&lt;=、&gt;、&gt;= 等操作符，InnoDB 引擎会为查询涉及到的范围加上 NEXT-KEY 锁。这个 NEXT-KEY 锁包含两部分：
Gap 锁：锁定了查询范围内的间隙（Gap），防止其他事务向该范围内插入新的记录。记录锁：锁定了满足查询条件的记录，防止其他事务对这些记录进行并发修改或删除。 通过使用 NEXT-KEY 锁，InnoDB 可以有效地避免幻读现象的发生。它保证了在一个事务读取一个范围的数据时，其他事务无法并发地在该范围内插入新的记录，从而保证了读取的一致性。
需要注意的是，NEXT-KEY 锁只在事务隔离级别为可重复读（REPEATABLE READ）或更高级别时使用（MySQL默认隔离级别为可重复读）。在较高的并发环境下，使用 NEXT-KEY 锁可能会增加锁冲突的概率，因此在设计数据库和查询时需要考虑到锁的开销和事务的隔离级别。
2.MySQL中有哪些不同的表格？ 这个也是GPT回答的，注意，表格和存储引擎不是同一个概念！
在MySQL中，有以下几种不同的表格类型：
MyISAM：MyISAM是旧版本MySQL的默认表格类型。它提供了快速的读取速度，适用于大量的并发读取操作。不过，MyISAM不支持事务处理和崩溃恢复功能。InnoDB：InnoDB是一种支持事务处理和崩溃恢复功能的表格类型。它提供了行级锁定和外键约束等高级功能，适用于需要数据完整性和并发写入操作的场景。InnoDB是MySQL 5.5版本后的默认表格类型。Memory：Memory（也称为Heap）表格是将数据存储在内存中的临时表格类型。它在读取和写入方面非常快速，但它的数据是临时的，当数据库服务器重启时，表格中的数据将会丢失。Archive：Archive表格是一种高度压缩的表格类型，适用于存储大量历史数据和归档数据。它对于读取操作不太有效，但在大量写入和存储空间方面具有优势。CSV：CSV表格允许将数据以CSV（逗号分隔值）格式存储在文件中，支持导入和导出数据。它不支持索引，事务处理和其他高级特性。 除了以上列举的几种常见的表格类型外，MySQL还支持其他一些特殊用途的表格类型，如Partitioned（分区表格）和Federated（联合表格）等。
表格和存储引擎是同一个东西吗？并不是！ 在关系型数据库中，表格（Table）是指一个逻辑上的数据结构，用来组织和存储数据。一张表格由若干列（Column）和若干行（Row）组成，每列定义了一种数据类型和一个字段名，表格中的每一行则代表一个实体或记录，每个单元格存储着对应列的一个数值或字符串。
存储引擎（Storage Engine）则是指实现了数据库的表格和索引等功能的底层软件模块，它负责将表格数据存储到磁盘、跟踪并处理事务、执行查询语句等任务。不同的存储引擎具有各自的特点和优缺点，在不同场景下选择合适的存储引擎可以提高数据库的性能和可靠性。
3.MyISAM和InnoDB的区别？ MyISAM
不支持事务；采用非聚簇索引，普通索引和主键索引的形式相同；一张表包含三个本地文件； InnoDB
支持事务；采用聚簇索引，普通索引存放的是主键索引中的key值，需要回表查询；可以用索引覆盖来优化；一张表包含两个本地文件； 4.InnoDB支持的四种事务隔离级别和区别 四种隔离级别：读未提交，读已提交，可重复读，串行化；
这部分直接去看我的MySQL索引博客，里面详细介绍了区别，这里就不重写一遍了；
5.CHAR和VARCHAR的区别 char是定长字符串，最长255；varchar是变长字符串，最长65535；这就意味着varchar需要更多空间来存放当前字符串长度等信息，并且会根据当前字符串长度动态开辟空间大小，不会有额外的存储空间浪费；而char是定死的空间，char(8)里面即便只有一个字符也会占用八个的空间（会用空格进行补齐）；在字符串长度确定的情况下，比如计算长度确定的MD5，那就可以用char定长存储；长度不确定的情况下，比如人名、邮箱等信息，可以采用varchar； 顺带说一下varchar和text的区别；需要进行索引的长文可以用TEXT进行存储（注意，只有MyISAM支持全文索引）
存储空间：VARCHAR列存储的内容长度是可变的，而TEXT列可以存储大量的可变长度的文本数据。VARCHAR在存储时会根据实际存储的内容长度进行调整，而TEXT没有固定的最大长度限制，可以用来存储非常长的文本。由于TEXT可以存储更大的数据量，因此它通常占用更多的存储空间。查询性能：由于VARCHAR具有固定的最大长度限制，数据库可以更好地优化和管理存储空间，这可能会在某些情况下提升查询性能。而TEXT由于其可变长度和大容量，可能会对某些查询操作稍有影响。索引和排序：VARCHAR可以被索引和排序，这意味着可以根据这些列进行快速搜索和排序操作。而TEXT类型通常不直接支持索引和排序，需要额外的配置和处理才能实现类似的功能。 如下user1表做测试，会发现我们无法给TEXT类型上普通索引。给出的提示是，BLOG/TEXT类型不能在没有指定长度的时候上索引；因为你的长度不确定，如果MySQL将一个几万字的TEXT存到内存里面作为索引节点，那么就会占用过多的内存空间。
MariaDB [hello_mysql]&gt; desc user1; +-------+------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+------------------+------+-----+---------+-------+ | id | int(10) unsigned | NO | PRI | NULL | | | name | varchar(200) | NO | | NULL | | | info | text | NO | | NULL | | +-------+------------------+------+-----+---------+-------+ 3 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08542a1b7d65b054725f06e709af051b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e094c51bd1cd94a1c5ee814d98c053b/" rel="bookmark">
			网络基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
网络发展
独立模式
网络互联
局域网LAN
广域网WAN
网络通信基础
IP 地址
端口号
协议
五元组
协议分层
OSI 七层模型
TCP/IP 五层模型
网络设备所在分层
封装和分用
封装 分用
网络发展 独立模式 独立模式：计算机之间相互独立
网络互联 随着时代的发展，计算机之间需要相互通信，共享软件和数据，即，需要多个计算机协调工作来完成业务，此时就有了网络互联
网络互联：将多台计算机连接起来，完成数据共享
数据共享的本质是网络数据传输，即，计算机之间通过网络来传输数据，也就是 网络通信
根据网络互联的规模不同，可划分为 局域网 和 广域网
局域网LAN 局域网，即，Local Area Network，简称 LAN
Local 标识了局域网是本地、局部组建的一种私有网络
局域网内的主机之间能够方便的进行网络通信，又称为 内网。局域网和局域网之间在没有连接的情况下，是无法通信的
局域网组件网络的方式有很多种：
（1）基于网络直连
（2）基于集线器组建
（3）基于交换机组建
（4）基于交换机和路由器组建
广域网WAN 广域网，即，Wide Area Network，简称 WAN
通过路由器，将多个局域网连接起来，在物理上组成很大范围的网络，就形成了广域网。其内部的局域网属于其子网
网络通信基础 网络互连的目的是进行网络通信，即网络数据传输，也就是 网络主机的不同进程之间，基于网络传输数据
那么，在组件网络时，如何判断是从哪台主机将数据发送到哪台主机呢？这就需要使用 IP 地址 来进行标识
IP 地址 IP 地址主要用于标识网络主机，其他网络设备（如路由器）的网络地址，简而言之，IP 地址用于定位主机的网络地址
就像收发快递一样，只有知道对方的收货地址，快递员才能将包裹送到目的地
格式 IP 地址是一个 32 位的二进制数，通常被分割为 4个 8位二进制数（也就是4个字节），如
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e094c51bd1cd94a1c5ee814d98c053b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f72e18d8403cd74583ebcad0d1658d/" rel="bookmark">
			Python知识点：如何使用Appium进行移动应用测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Appium 是一个开源的测试工具，用于自动化移动应用的测试。它支持多种平台，如Android和iOS。以下是使用Appium进行移动应用测试的详细指南。
1. 安装Appium 首先，你需要安装Appium。Appium可以通过Node.js进行安装：
npm install -g appium 安装完成后，可以通过命令启动Appium服务器：
appium 2. 安装Appium客户端库 你还需要安装Appium的客户端库，以便在代码中与Appium服务器进行通信。可以使用pip安装Python客户端：
pip install Appium-Python-Client 3. 安装并配置Appium Desktop（可选） Appium Desktop是一个带有图形用户界面的工具，便于配置和管理Appium服务器。你可以从Appium官网下载并安装它。安装后，启动Appium服务器，并配置所需的Desired Capabilities。
4. 设置开发环境 你需要在开发环境中安装必要的工具，例如：
Java Development Kit (JDK)：Appium依赖于Java。Android SDK：用于Android设备测试。Xcode：用于iOS设备测试。 确保将这些工具添加到系统的环境变量中。
5. 配置Desired Capabilities Desired Capabilities用于指定设备和应用程序的配置。这些配置可以在测试脚本中定义，告诉Appium要测试哪个设备、哪个应用等。
以下是一个示例的Desired Capabilities配置，用于Android设备：
from appium import webdriver desired_caps = { "platformName": "Android", "deviceName": "Android Emulator", "app": "/path/to/your/app.apk", "appPackage": "com.example.android", "appActivity": "com.example.android.MainActivity", "automationName": "UiAutomator2" } driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) 6. 编写测试脚本 一旦配置了Desired Capabilities，可以开始编写测试脚本。以下是一个简单的示例，它启动应用并进行基本的UI操作。
from appium import webdriver from appium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f72e18d8403cd74583ebcad0d1658d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b0d920ecca4ecd7caab76a0129e756/" rel="bookmark">
			Websocket测试工具,在线调试 - 在线工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WebSocket 测试工具是用于测试 WebSocket 连接、发送和接收消息的工具。它们通常提供一个简单的用户界面，使开发人员能够快速验证 WebSocket 服务器的功能和性能。
在线Websocket测试工具体验地址：https://ewbang.com/websocket/index.html
什么是 WebSocket？ WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。它被设计用于在客户端（如浏览器）和服务器之间建立低延迟、实时的双向通信。WebSocket 连接一旦建立，客户端和服务器可以随时发送数据，而无需重新建立连接。
WebSocket 测试工具网页版 WebSocket 测试工具网页版是一个基于浏览器的应用程序，旨在帮助开发人员和测试人员方便地测试和调试 WebSocket 连接。它提供了一个直观的用户界面，允许用户连接到 WebSocket 服务器、发送和接收消息，并查看通信的详细信息。
主要功能 连接管理
URL 输入：允许用户输入 WebSocket 服务器的 URL 地址。连接/断开按钮：用户可以点击按钮来建立或断开 WebSocket 连接。连接状态显示：实时显示当前连接状态（已连接、已断开、连接中等）。 消息发送
消息输入框：用户可以在输入框中输入要发送的消息。发送按钮：点击按钮发送消息到 WebSocket 服务器。消息格式：支持文本消息和二进制消息（如 Base64 编码的二进制数据）。 消息接收
消息日志：实时显示接收到的消息，包括时间戳和消息内容。消息过滤：可以按消息类型（文本或二进制）过滤显示的消息。 调试和日志
连接日志：记录连接建立、断开和错误信息，帮助用户调试连接问题。消息日志：记录所有发送和接收的消息，便于分析通信过程。 高级功能
自动重连：在连接断开时自动尝试重新连接。心跳消息：定期发送心跳消息以保持连接活跃。协议支持：支持指定 WebSocket 子协议（如 protocols 参数）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0035f9795da2cc179a89ba06fc27ef6/" rel="bookmark">
			从跟跑到领跑：AIGC时代国产游戏的崛起与展望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、技术深度挖掘1.图形渲染与视觉盛宴2.物理引擎的精细化与真实性3.AI技术的深度融入与创新 二、行业影响深度剖析1.产业链的全面升级2.IT人才需求的多元化与高端化3.文化输出与国际影响力的增强 三、未来趋势与跨界合作1.技术创新引领未来2.跨界合作拓展市场 四、代码示例1.图形渲染与视觉盛宴2.物理引擎的精细化与真实性3.AI技术的深度融入与创新 在AIGC（人工智能生成内容）技术的浪潮下，国产游戏行业正以前所未有的速度崛起，不仅在技术层面实现了质的飞跃，更在全球游戏市场中占据了举足轻重的地位。
一、技术深度挖掘 1.图形渲染与视觉盛宴 国产游戏在图形渲染技术上的突破，不仅体现在高分辨率和逼真度上，更在于对光影效果的极致追求。通过采用先进的实时光线追踪技术，游戏能够模拟出真实世界中的光线散射、折射和反射等现象，为玩家带来电影级的视觉体验。同时，HDR技术和全局光照的应用，使得游戏场景中的色彩更加丰富、层次感更强，为玩家营造出一个既真实又梦幻的游戏世界。
2.物理引擎的精细化与真实性 国产游戏在物理引擎方面的研发已经达到了国际领先水平。通过引入复杂的物理模拟算法，游戏中的物体行为更加接近真实世界。无论是刚体的碰撞、流体的运动还是软体的形变，都能得到精确而自然的呈现。这种精细化的物理引擎不仅增强了游戏的真实感，也为玩家提供了更加丰富的交互体验，如驾驶车辆时的颠簸感、射击时的后坐力等。
3.AI技术的深度融入与创新 在AIGC时代，AI技术已成为国产游戏不可或缺的一部分。从NPC的智能交互到游戏策略的动态调整，再到游戏内容的自动生成，AI技术正逐步改变着游戏的玩法和体验。通过深度学习和大数据分析，游戏能够更准确地理解玩家需求，提供更加个性化的服务。同时，AI技术也为游戏设计带来了无限的创新可能，如自动生成关卡、设计角色、编写剧情等，为玩家带来全新的游戏体验。
二、行业影响深度剖析 1.产业链的全面升级 国产游戏技术的进步不仅推动了游戏开发行业的转型升级，还带动了整个产业链的协同发展。从游戏引擎、美术设计、音效制作到游戏发行、运营等环节，都在不断提升自身的技术水平和创新能力。这种全产业链的升级不仅提高了国产游戏的整体品质，也为行业的国际化发展奠定了坚实的基础。
2.IT人才需求的多元化与高端化 随着游戏技术的不断突破，IT人才需求也呈现出多元化和高端化的趋势。除了传统的编程、美术、音效等岗位外，还需要大量的AI专家、数据分析师、云计算工程师等高端技术人才。为了满足这一需求，国内高校和企业开始加强相关专业的建设和人才培养，为游戏行业输送更多高素质的人才。同时，企业也通过内部培训和外部引进等方式，不断提升员工的技能水平和创新能力。
3.文化输出与国际影响力的增强 国产游戏技术的崛起不仅提升了国内游戏市场的竞争力，还为中华文化的国际传播提供了新的载体。通过游戏这一全球通用的语言，国产游戏可以将中国的历史、文化、价值观等元素传递给全球玩家，增强中华文化的国际影响力和软实力。同时，国产游戏在国际市场上的成功也为中国文化软实力的提升做出了重要贡献。
三、未来趋势与跨界合作 1.技术创新引领未来 在未来，国产游戏将继续在技术创新方面发力。随着5G、云计算、VR/AR等新技术的不断成熟和应用，国产游戏将迎来更多的创新机遇。跨平台游戏、云游戏、VR/AR游戏等新型游戏形态将成为未来游戏发展的重要趋势。同时，区块链技术和NFT的兴起也将为游戏经济系统带来新的变革和机遇。
2.跨界合作拓展市场 国产游戏将积极寻求与其他行业的跨界合作机会，如影视、动漫、文学等。通过跨界合作，可以共享资源、拓展市场、提升品牌影响力，实现互利共赢的发展目标。同时，国产游戏还将加强与国际游戏企业的合作与交流，共同推动全球游戏行业的繁荣发展。通过国际合作，可以引进先进的技术和管理经验，提升国产游戏的技术水平和市场竞争力；同时，也可以将中国的游戏文化和价值观传递给全球玩家，增强中华文化的国际影响力。
四、代码示例 1.图形渲染与视觉盛宴 实时光线追踪技术示例（伪代码）：
function rayTrace(ray, scene) { // 假设ray是光线结构体，包含起点、方向等 // scene是场景，包含所有可交互的物体和光源 closestHit = null closestDistance = INFINITY for each object in scene.objects { // 检查光线是否与物体相交 hit, distance = intersect(ray, object) if hit and distance &lt; closestDistance { closestHit = object closestDistance = distance } } if closestHit !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0035f9795da2cc179a89ba06fc27ef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1474dbb2a6c4fe74d01c13d3242f643/" rel="bookmark">
			C&#43;&#43;：类的定义、实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、类的定义
1.1 类的定义格式
1.2 访问限定符
1.3 类域
二、实例化
2.1 实例化概念
2.2 对象大小
一、类的定义 1.1 类的定义格式 • class为定义类的关键字，Stack为类的名字，{}中为类的主体，注意类定义结束时后面分号不能省略，类体中内容称为类的成员：类中的变量称为类的属性或成员变量，类中的函数称为类的方法或者成员函数。 • 为了区分成员变量，一般习惯上成员变量会加⼀个特殊标识，如成员变量前面或者后面加_ 或者 m 开头，注意C++中这个并不是强制的，只是⼀些惯例。
• C++中struct也可以定义类，C++兼容C中struct的用法，同时struct升级成了类，明显的变化是 struct中可以定义函数，⼀般情况下我们还是推荐用class定义类。
• 定义在类面的成员函数默认为inline。
class Date { public: void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } private: // 为了区分成员变量，⼀般习惯上成员变量 // 会加⼀个特殊标识，如_ 或者 m开头 int _year; // year_ m_year int _month; int _day; }; int main() { Date d; d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1474dbb2a6c4fe74d01c13d3242f643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f8630ec5b95b965ecb1effbc3c7ab07/" rel="bookmark">
			【数据结构】关于哈希表内部原理，你到底了解多少？？？（超详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 🌟🌟本期讲解关于哈希表的内部实现原理，希望能帮到屏幕前的你。
🌈上期博客在这里：http://t.csdnimg.cn/7D225
🌈感兴趣的小伙伴看一看小编主页：GGBondlctrl-CSDN博客
目录
📚️1.哈希表的概念
📚️2.哈希-冲突
2.1冲突-概念
2.2冲突-避免
1.冲突-避免-哈希函数设计
2.冲突-避免-冲突因子
2.3冲突-解决
1.冲突-解决-闭散列
2.冲突-解决-开散列
2.4性能分析
2.5与Java类集的关系
📚️3.总结
📚️1.哈希表的概念 顺序结构以及平衡树中在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)；
平衡树中为树的高度，即O(logN )，搜索的效率取决于搜索过程中元素的比较次数。例如上期的treeMap.
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
• 插入元素
根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放
• 搜索元素
对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功
该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(HashTable)(或者称散列表)
哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。
图解 ：
​
注意：这里和计数排序差不多 ，但是如果我们加入11，会发现11的位置将直接把1给覆盖掉，那么此时就叫作哈希-冲突。
📚️2.哈希-冲突 2.1冲突-概念 对于两个数据元素的关键字ki 和kj (i != j)，有ki !=kj ，但有：Hash(ki ) == Hash(kj )，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞
2.2冲突-避免 首先，我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题，冲突的发生是必然的，但我们能做的应该是尽量的降低冲突率
1.冲突-避免-哈希函数设计 哈希函数设计原理：
• 哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间
• 哈希函数计算出来的地址能均匀分布在整个空间中
• 哈希函数应该比较简单
小编这里介绍两个比较常用的两个方法： 1. 直接定制法
取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B 优点：简单、均匀 缺点：需要事先知道关键字的分布情况 使用场景：适合查找比较小且连续的情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f8630ec5b95b965ecb1effbc3c7ab07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41708ee1f50b94cb158225ff97b342ff/" rel="bookmark">
			[Algorithm][综合训练][合并k个已排序的链表][dd爱旋转][小红取数]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.合并k个已排序的链表1.题目链接2.算法原理讲解 &amp;&amp; 代码实现 2.dd爱旋转1.题目链接2.算法原理详解 &amp;&amp; 代码详解 3.小红取数1.题目链接2.算法原理详解 &amp;&amp; 代码实现 1.合并k个已排序的链表 1.题目链接 合并k个已排序的链表 2.算法原理讲解 &amp;&amp; 代码实现 自己的解法：堆 -&gt; 将全部节点丢入堆中class Solution { typedef pair&lt;int, ListNode*&gt; PIL; public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { priority_queue&lt;PIL, vector&lt;PIL&gt;, greater&lt;&gt;&gt; heap; for(const auto&amp; list : lists) { ListNode* cur = list; while(cur) { heap.push({cur-&gt;val, cur}); cur = cur-&gt;next; } } ListNode* newHead = new ListNode(0); ListNode* tail = newHead; while(heap.size()) { ListNode* node = heap.top().second; heap.pop(); tail-&gt;next = node; tail = tail-&gt;next; } tail-&gt;next = nullptr; tail = newHead-&gt;next; delete newHead; return tail; } }; 优化解法：堆 -&gt; 只存入每个链表的头结点，出堆时，再压入下一个节点 对自己的版本进行了时间上和空间上的优化并且对堆排序时的比较方法进行了优化 class Solution { struct CMP { bool operator()(ListNode* l1, ListNode* l2) { return l1-&gt;val &gt; l2-&gt;val; } }; public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, CMP&gt; heap; for(auto head : lists) { if(head !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41708ee1f50b94cb158225ff97b342ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa95ca75f007fb2e0eda5d42c5828f80/" rel="bookmark">
			代码随想录算法训练营第五十八天 | 图论part08
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		117. 软件构建 在这一题中，只需要输出一种方法。使用BFS的方法，找到入度为0的节点，将其从树中删去，重复上述步骤，直到没有入度为0的节点。如果此时没有删除所有的节点，表明这个有向图有环，输出-1.否则，正常输出。
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; #include &lt;queue&gt; #include &lt;fstream&gt; using namespace std; int main() { int n, m; int s, t; ifstream infile("input.txt"); cin &gt;&gt; n &gt;&gt; m; unordered_map&lt;int, vector&lt;int&gt;&gt; table; vector&lt;int&gt; inDegrees(n, 0); while (m--) { cin &gt;&gt; s &gt;&gt; t; inDegrees[t]++; table[s].emplace_back(t); } queue&lt;int&gt; que; for (int i = 0; i &lt; n; ++i) { if (inDegrees[i] == 0) que.push(i); } vector&lt;int&gt; result; while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa95ca75f007fb2e0eda5d42c5828f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b239fa7bf7a6a4dea182114b92012188/" rel="bookmark">
			如何用GPT进行编程辅助？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的迅速发展，GPT（生成型预训练模型）已成为开发者的得力助手之一。无论是编写代码、调试、生成文档，还是解决编程问题，GPT都能提供显著帮助。这篇教程将详细介绍如何使用GPT进行编程辅助，并提供具体的操作步骤和案例。
一、为什么选择GPT进行编程辅助？ 1. 快速生成代码：通过提供明确的提示，GPT可以自动生成代码段，减少开发者的工作量，提升效率。
2. 代码优化与重构：GPT不仅能生成代码，还可以帮助优化现有代码，提供更简洁、高效的解决方案。
3. 文档生成：GPT可以自动生成函数、类和项目的文档，确保代码的可读性和维护性。
4. 多语言支持：无论是Python、JavaScript，还是C++等编程语言，GPT都能胜任，支持多种编程语言的代码生成和问题解答。
二、如何使用GPT进行编程辅助？ 1. 准备工作 要使用GPT进行编程辅助，你需要一个支持GPT的开发平台，如OpenAI的ChatGPT。以下是一些基本准备工作：
• 注册OpenAI账号：访问OpenAI官网，注册并获取API密钥。
• 选择合适的编程环境：你可以在Jupyter Notebook、VS Code或任何支持API调用的环境中使用GPT。
2. 编写代码生成的提示 要让GPT生成代码，你需要提供清晰的提示（Prompt）。例如，如果你想让GPT生成一个Python函数来计算两个数的和，你可以输入如下提示：
示例提示：
请生成一个Python函数来计算两个数的和，并返回结果。 GPT的响应：
def add_numbers(a, b): return a + b 这个简单的提示让GPT生成了一个基本的Python函数，节省了手动编写的时间。
3. 优化和重构现有代码 如果你有一段代码需要优化或重构，你可以将其输入GPT，并请求改进。例如，你有一个简单但不太高效的排序函数：
示例代码：
def sort_numbers(numbers): for i in range(len(numbers)): for j in range(i + 1, len(numbers)): if numbers[i] &gt; numbers[j]: numbers[i], numbers[j] = numbers[j], numbers[i] return numbers 优化请求：
请优化以下Python代码，使其更高效。 GPT的优化结果：
def sort_numbers(numbers): return sorted(numbers) GPT给出了更简洁且高效的Python内置排序函数，取代了原始的双重循环实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b239fa7bf7a6a4dea182114b92012188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a88023ca3d8e8b3f139553cf539d2a/" rel="bookmark">
			网络模型及协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.OSI七层模型 OSI Open System Interconnect 开放系统互连模型
以前不同厂家所生产的网络设备的标准是不同的，所以为了统一生产规范就制定了OSI这个生产模型。
作用：降低网络进行数据通信复杂度
这个模型的作用第一降低数据通信的复杂度，第二方便故障排查。
但凡是联网的设备其内部都有这七个车间，在数据传输的时候负责不同的事情。
应用层
作用：提供应用程序/软件，人与网络间的接口，提供数据
表示层
作用：负责数据格式的转换，比如压缩/解压缩，加密，解密
会话层
作用：建立会话，维持会话，断开会话，
会话：识别客户端的登录身份（是否登录）
比如登录邮箱是建立会话，在邮箱上进行对邮件的一系列操作是维持会话，退出邮箱是断开会话。
再比如说，一台服务器在同一时刻收到了n多条信息，怎么判断这个信息是不是已经登录的用户发送过来的信息，这就要依赖会话，
传输层
作用：用来在计算机之间提供端到端的通信的。识别不同的应用程序，
端口号1--65535
也就是说将某一端的数据传输到某一段的数据。
什么样的程序才会产生端口号，这个应用程序必须要能够联网。
windows查看端口的命令 &gt; netstat -an
如上图所示，在windows中端口号为139和445的这两个端口，负责共享文件夹的功能，
网络层
典型设备：路由器
作用：提供网络到网络的通信，网络---网络
提供选路，根据IP地址进行选路，（选路的意思是两个机器之间通信的路径。）
数据链路层
典型设备：交换机
作用：提供点到点的通信，依靠MAC地址，物理地址
windows查看MAC地址：ipconfig/all
Linux查看MAC地址：ifconfig，ip addr show
机器上的每一块网卡（虚拟网卡，物理网卡）都有其自己的MAC地址，这个地址独一无二。
可以尝试将家里的联网设备的MAC地址都计入到路由器中，这样陌生设备就不能随便访问家里的网络了。
物理层
作用：提供物理链路
第几层的问题从下往上数。
二.TCP/IP五层模型 应用层，传输层，网络层，数据链路层，物理层
在五层模型中，会话层和表示层的功能被合并到了应用层。
三.典型协议 应用层： 1.http协议的作用是用来实现web数据传输的，明文传输。
2.https协议的作用也是实现web数据传输的，密文传输。
3.ftp协议文件传输协议，用来实现数据共享，
4.DNS协议用来实现IP地址，主机名的解析，
5.ntp协议网络时间协议，用来实现时间同步，
6.snmp协议（简单网络管理协议，实现监控）
7.ssh协议设备远程连接，密文传输，适用于连接服务器。
8.telnet协议设备远程连接，明文传输，适用于在局域网连接网络设备。
传输层： 1.TCP 传输控制协议
面向连接的协议，
主机间相互发送数据前，需要建立TCP连接，连接完毕后才会开始发送真实的数据，数据发送完毕后，主机间会断开连接。
TCP连接是双向的。
如上图所示，基于TCP协议开发的软件，都是在发送数据之前建立连接，然后在发送数据的操作完成后断开连接。
2.三次握手，建立连接。
a)主机A向主机B发送带有SYN标志的数据，表示请求建立连接。
b)主机B向主机A发送带有ACK，SYN标志的数据，表示同意建立连接，向A发送建立连接的请求。
c)主机A向主机B发送带有ACK标志的数据，表示同意与B建立连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9a88023ca3d8e8b3f139553cf539d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab297f998f99ce5264f9d499b0e5363b/" rel="bookmark">
			Error running tomcat: Can‘t find catalina.jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、错误描述： 在运行 java-web项目时出现报错：Error running tomcat: Can‘t find catalina.jar
二、错误原因： tomcat的路径错误，在idea中配置正确的tomcat路径
三、解决方法： 1.点击EditConfigurations
2.点击下图中的Configure
3.选择正确的tomcat路径，然后点击OK
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/14/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>