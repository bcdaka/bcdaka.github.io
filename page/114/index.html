<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa82646f1de1197db7f1d2b00b01c89b/" rel="bookmark">
			分布式相关理论详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.绪论
2.什么是分布式系统，和集群的区别
3.CAP理论
3.1 什么是CAP理论
3.2 一致性
3.2.1 计算机的一致性说明
1.事务中的一致性
2.并发场景下的一致性
3.分布式场景下的一致性
3.2.2 一致性分类
3.2.3 强一致性
1.线性一致性
a) 定义
a) Raft算法是如何实现线性一致性的
2.顺序一致性
a）顺序一致性的定义
b) 顺序一致性和线性一致性的区别
c) zookeeper是如何实现顺序一致性的
3.2.4 弱一致性
3.2.5 最终一致性
3.3 可用性
3.4 分区容忍性
3.5 CAP组合
4.Base理论
4.1 Base理论的定义
4.1.1基本可用
4.1.2 软状态
4.1.3 最终一致性
5.拜占庭将军问题
6.引用
1.绪论 本文主要介绍的分布是系统中的一些常见的理论知识，比如CAP理论，BASE理论，拜占庭将军问题等。
2.什么是分布式系统，和集群的区别 分布式系统就是将整个系统根据业务拆分多个微服务，服务之间通过Rpc进行通信。
集群是将多个相同应用部署到不同的集群模式上，本质上是为了提高吞吐量已经保证高可用性。
3.CAP理论 3.1 什么是CAP理论 CAP理论是分布式系统的理论基础,即一个分布式系统最多满足CAP这三项中的两项。即只能满足一致性(Consistance)、可用性（Aviablity）、分区容忍性（Partition tolerance）中的两项。
3.2 一致性 在CAP理论中，一致性指的是，每次读取到的数据一定是当前最新的数据，否者报错。可以看出一致性其实指的是强一致性。
3.2.1 计算机的一致性说明 在计算机中机中有很多地方都会出现一致性这个概念，我们也经常将他们混淆一谈，这里将根据我的经验，来说明不同的一致性表达的含义。
1.事务中的一致性
事务有4个性质，分别是ACID，原子性，一致性，隔离性，持久性。什么是一致性呢？我认为这里的一致性是事务的操作逻辑应该客观事实一致。比如，张三向李四转账50元，张三卡中减少50，李四增加50，钱的总数是不变的。如果张三卡中减少50，而李四卡中余额未变，相当于钱的总数增加50，这是不符合客观事实的。
2.并发场景下的一致性
在并发场景下，由于资源的共享，导致锁竞争，所以可能出现每次请求到结果是不一样的问题，这样就会出现一致性问题。
3.分布式场景下的一致性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa82646f1de1197db7f1d2b00b01c89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d85653712dd92f358a3323b2dde79a/" rel="bookmark">
			【数据结构】堆，优先级队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 堆堆的性质大根堆的模拟实现接口实现构造方法建堆入堆判满删除判空获取堆顶元素 Java中的PriorityQueue实现的接口构造方法常用方法PriorityQueue注意事项 练习 堆 如果有一个集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足：Ki &lt;= K2i+1 且 Ki&lt;= K2i+2 (Ki &gt;= K2i+1 且 Ki &gt;= K2i+2) i = 0，1，2…，则称为 小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
堆的性质 堆逻辑结构上是一棵完全二叉树。堆上的节点一定不大于（大根堆）或者不小于（小根堆）父亲节点。 大根堆的模拟实现 使用代码来实现一个大根堆。
接口实现 接口成员方法。
public class PriorityQueue { public int[] elem; public int usedSize; public PriorityQueue() {} //建堆 public void createHeap(int[] array) {} /** * @param root 是每棵子树的根节点的下标 * @param len 是每棵子树调整结束的结束条件 * 向下调整的时间复杂度：O(logn) */ private void shiftDown(int root,int len) {} // 入堆：仍然要保持是大根堆 public void push(int val) {} private void shiftUp(int child) {} //判断堆是否满 public boolean isFull() {} //每次删除的都是优先级高的元素,删除后任是大根堆 public void pollHeap() {} //判断堆是否为空 public boolean isEmpty() {} // 获取堆顶元素 public int peekHeap() {} } 构造方法 在构造方法中构建为长度10的数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74d85653712dd92f358a3323b2dde79a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21d3416a56072363613b74f03e12d1d/" rel="bookmark">
			lua 游戏架构 之 游戏 AI （七）ai_dead
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个名为`ai_dead`的类，继承自`ai_base`类。这个类用于处理游戏中AI在死亡状态下的行为逻辑。以下是对代码的具体解释：
1. **引入基类**：
- 使用`require`函数引入`ai_base`类，作为基础类。
2. **定义`ai_dead`类**：
- 使用`class`关键字定义了`ai_dead`类，并继承自`BASE`（即`ai_base`）。
3. **构造函数 (`ctor`)**：
- 构造函数接受一个`entity`参数，并设置`_type`属性为`eAType_DEAD`，表示死亡的行为。
4. **`IsValid` 方法**：
- 这个方法用于验证AI是否应该处于死亡状态。它首先调用基类的`IsValid`方法，然后检查实体是否死亡。
5. **`OnEnter` 方法**：
- 当AI组件进入激活状态时执行。如果基类的`OnEnter`方法返回`true`，则执行以下操作： - 重置`_fadeOut`和`_slowMotion`标志。 - 检查并重置玩家的自动普通攻击状态。 - 隐藏实体的称号节点。 - 检查并重置玩家的超级模式状态。 - 检查并重置骑乘状态。 - 如果实体不是宠物或技能类型，播放死亡动作列表。 - 锁定实体动画。 - 处理同步RPC和发送死亡命令。 - 处理玩家死亡后的界面逻辑，如复活界面和宠物状态。 - 清理死亡实体的仇恨列表和战斗时间。 6. **`OnLeave` 方法**： 当AI组件离开激活状态时执行。如果基类的`OnLeave`方法返回`true`，则解锁实体动画。
7. **`OnLogic` 方法**： 逻辑更新方法。如果基类的`OnLogic`方法返回`true`，则根据时间间隔处理死亡逻辑，如淡出效果、实体销毁等。
8. **创建组件函数**： `create_component`函数用于创建`ai_dead`类的新实例，传入一个实体和一个优先级。
代码中的一些关键点：
- `IsDead()`：检查实体是否死亡。- `ShowTitleNode()`：显示或隐藏实体的称号节点。- `SuperMode()`：处理玩家的超级模式。- `OnRideMode()`：处理玩家的骑乘模式。- `PlayActionList()`：播放一系列动作。- `LockAni()`：锁定实体的动画。- `Show()`：控制实体的显示与隐藏。- `Destory()`：销毁实体。- `CanRelease()`：检查实体是否可以释放。 `OnEnter` 方法的逻辑流程：
- 调用基类的`OnEnter`方法，如果返回`true`，则继续。- 重置相关动画和攻击状态。- 隐藏称号节点。- 检查并重置超级模式和骑乘状态。- 播放死亡动作列表并锁定动画。- 发送死亡同步命令和处理复活界面逻辑。- 清理仇恨列表和战斗时间。 `OnLogic` 方法中，根据时间间隔处理死亡后的逻辑，如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21d3416a56072363613b74f03e12d1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653d3b6dfb5766e005a696963689fb98/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(044)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
151、pandas.Series.any方法
151-1、语法
151-2、参数
151-3、功能
151-4、返回值
151-5、说明
151-6、用法
151-6-1、数据准备
151-6-2、代码示例
151-6-3、结果输出
152、pandas.Series.autocorr方法
152-1、语法
152-2、参数
152-3、功能
152-4、返回值
152-5、说明
152-6、用法
152-6-1、数据准备
152-6-2、代码示例
152-6-3、结果输出
153、pandas.Series.between方法
153-1、语法
153-2、参数
153-3、功能
153-4、返回值
153-5、说明
153-6、用法
153-6-1、数据准备
153-6-2、代码示例
153-6-3、结果输出
154、pandas.Series.clip方法
154-1、语法
154-2、参数
154-3、功能
154-4、返回值
154-5、说明
154-6、用法
154-6-1、数据准备
154-6-2、代码示例
154-6-3、结果输出
155、pandas.Series.corr方法
155-1、语法
155-2、参数
155-3、功能
155-4、返回值
155-5、说明
155-6、用法
155-6-1、数据准备
155-6-2、代码示例
155-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 151、pandas.Series.any方法 151-1、语法 # 151、pandas.Series.any方法 pandas.Series.any(*, axis=0, bool_only=False, skipna=True, **kwargs) Return whether any element is True, potentially over an axis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653d3b6dfb5766e005a696963689fb98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c271c9798311e3e3184a2472942001d/" rel="bookmark">
			图像处理背后的技术与算法：深入解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像处理是计算机视觉和多媒体领域中的一个重要分支，它涉及到对图像数据进行各种操作，以增强图像质量、提取特征或者用于特定应用。在图像处理的背后，有一系列的技术和算法支撑着这些操作的实现。本文将深入探讨图像处理背后的技术原理，并结合作者自己的理解，用代码实例来具体说明。
第一部分：图像的基本概念与数据结构 图像的基本概念 图像是由像素组成的二维矩阵，每个像素包含颜色信息和亮度信息。在数字图像中，像素通常用一个数值来表示，这个数值可以代表颜色的RGB值，或者灰度值。
数据结构设计 为了有效地实现图像处理算法，我们通常使用NumPy库来表示和操作图像数据。NumPy是一个强大的数学库，它提供了一个多维数组对象，非常适合用于图像处理。
例如，我们可以定义一个Image类来表示图像：
import numpy as np class Image: def __init__(self, data): self.data = data self.shape = data.shape def display(self): import matplotlib.pyplot as plt plt.imshow(self.data, cmap='gray') plt.show() 在上面的代码中，data是图像数据，shape是图像的尺寸。display方法用于显示图像。
代码实例：创建图像 下面是一个简单的代码实例，用于创建一个灰度图像。
import numpy as np # 创建一个5x5的灰度图像 data = np.random.rand(5, 5) * 255 image = Image(data) image.display() 运行上述代码，你将看到一个随机生成的5x5灰度图像。
第二部分：图像的基本操作 图像的读取与保存 在图像处理中，读取和保存图像是非常常见的操作。我们通常使用PIL（Pillow）库来完成这些操作。PIL是一个强大的图像处理库，它提供了丰富的图像处理功能。
图像的读取
使用PIL库，我们可以轻松地读取图像文件。
from PIL import Image # 读取图像 image = Image.open('path_to_image.jpg') # 显示图像 image.show() 在上面的代码中，我们首先使用Image.open()函数来读取图像文件。然后，我们使用show()函数来显示图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c271c9798311e3e3184a2472942001d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbcc937708af9a909139190954bedd7/" rel="bookmark">
			[Python][输入输出]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1.通过控制台输出2.通过控制台输入 1.通过控制台输出 Python使用print()输出到控制台print('SnowK') 不仅能输出一个字符串，还可以输出一个其他类型的变量a = 10 print(a) b = True print(b) 如果希望输出的内容是混合了字符串和变量呢？ 使用f作为前缀的字符串，称为f-string -&gt; format-string里面可以使用{}来内嵌一个其他的变量/表达式Python中还支持其他的格式化字符串的方法，暂时只了解这个最简单的即可 # 想输出 num = 10 num = 10 print(f'num = {num}') 2.通过控制台输入 Python使用input()，从控制台读取用户的输入 input()执行的时候，会等待用户输入 num = 0 num = input('请输入一个整数: ') print(f'你输入的整数是 {num}') 注意： input()的参数相当于一个"提示信息"，也可以没有input()的返回值就是用户输入的内容，是字符串类型 如果只是单纯想拿到用户的输入，然后打印，此时直接按照str打印即可如果需要根据用户输入的内容进行算数运算，此时就需要先把读到的str -&gt; int 可以使用int()来转换类似的，使用float(), bool(), str()等可以完成对应的类型转换 例子：第一种写法的结果是字符串拼接，不是算术运算，如果要想进行算术运算，需要先转换类型# 输出结果：a + b = 1020 a = input('请输入第一个整数: ') b = input('请输入第二个整数: ') print(f'a + b = {a + b}') # 输出结果：a + b = 30 a = input('请输入第一个整数: ') b = input('请输入第二个整数: ') a = int(a) b = int(b) print(f'a + b = {a + b}') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059d96824e1333f3b8611ae615454583/" rel="bookmark">
			AIGC专栏14——ComfyUI秋叶包&#43;EasyAnimate 本地快速拉起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC专栏14——ComfyUI秋叶包+EasyAnimate 本地快速拉起 学习前言什么是ComfyUI相关地址汇总ComfyUI秋叶整合包下载地址EasyAnimateV3下载地址 操作流程下载与解压权重下载打开ComfyUI与运行 学习前言 最近给EasyAnimateV3写了ComfyUI的工作流，以方便别人测试。
不过一点一点安装环境再拉起服务有点麻烦，在Windows上用秋叶包比较简单，写个教程如何结合ComfyUI秋叶包+EasyAnimate 本地快速拉起。
什么是ComfyUI 在人工智能艺术创作的领域里，Stable Diffusion 凭借其开放源代码的特性，吸引了众多开发者与艺术家的目光，并且因为强大的社区支持而展现出强大的影响力。
Stable Diffusion 的两大主流创作平台分别是 Stable Diffusion WebUI 与 ComfyUI。前者以其即装即用的便捷性、丰富的基础功能及广泛的社区插件支持，成为了新手的理想选择。而ComfyUI则更注重算法细节，主要特点是 结合了 工作流和节点，达成更高级别的自动化，使得创作流程更易于复现与传播。不过，这也意味着较高的学习曲线，要求用户对 Stable Diffusion 及其扩展功能有深入理解，动手实践能力亦需达到一定水准。
着眼于未来的工业化生产与效率提升，ComfyUI 显现出更为广阔的潜力与前景。
相关地址汇总 ComfyUI秋叶整合包下载地址 https://pan.quark.cn/s/9d7669b85253
提取码：ScYB
我已经在该秋叶整合包中加入了EasyAnimate，无需自己安装。
EasyAnimateV3下载地址 https://github.com/aigc-apps/EasyAnimate
感谢大家的关注。
操作流程 下载与解压 直接通过上述的下载地址就可以下载ComfyUI秋叶整合包。
https://pan.quark.cn/s/9d7669b85253
提取码：ScYB
下载完后，对压缩包进行解压，解压后的文件夹如图所示：
由于我已经将EasyAnimate放入到这个秋叶包，所以不用自己再github下载EasyAnimate与安装。如果EasyAnimate插件有更新，可以通过aki的拓展页面进行更新。
权重下载 EasyAnimate的权重地址如下，根据需要进行下载就行了，EasyAnimate默认json对应的权重是768x768的权重。
名称类型存储空间UrlHugging face描述EasyAnimateV3-XL-2-InP-512x512.tarEasyAnimateV318.2GB下载🤗链接EasyAnimateV3官方权重为512x512文本和图像到视频分辨率。144帧和fps 24的训练EasyAnimateV3-XL-2-InP-768x768.tarEasyAnimateV318.2GB下载🤗链接EasyAnimateV3官方权重为768x768文本和图像到视频分辨率。144帧和fps 24的训练EasyAnimateV3-XL-2-InP-960x960.tarEasyAnimateV318.2GB下载🤗链接EasyAnimateV3官方权重为960x960文本和图像到视频分辨率。144帧和fps 24的训练 下载完权重后，在如下文件夹中创建一个EasyAnimate文件夹。
如图所示：
然后将下载好的权重放入EasyAnimate文件夹中，并且解压，在这里我用的是512的模型，按照需求选取即可。
打开ComfyUI与运行 之后直接启动秋叶整合包即可。
打开启动器后，有如图所示画面，点击一键启动即可启动comfyUI界面。
在启动ComfyUI后，我们使用 download link of the json 下载下来的json，直接拖入到ComfyUI的画面中。
注意根据下载的模型选择对应的model，然后注意选择base length与上传首图。
点击Queue Prompt即可开始生成：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3a6b406f09fcbe1db44e5b290799f20/" rel="bookmark">
			微软Edge浏览器全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT-4o (OpenAI) 微软Edge浏览器是由微软开发的一款网络浏览器，深受用户喜爱，以下是对其全面解析：
1. 简介
微软Edge浏览器最早在2015年伴随Windows 10发布。最初版本基于EdgeHTML引擎，2019年微软宣布Edge浏览器将基于开源的Chromium引擎重新构建，并于2020年1月正式发布。
2. 用户界面
- 简洁设计：Edge浏览器的界面简洁、现代化，易于导航。
- 自定义：用户可以自定义首页、新标签页的内容，包括显示新闻、天气、股票等。
3. 性能
- 高效：得益于Chromium内核，Edge浏览器具有很高的性能和兼容性，与Google Chrome有相似的网页加载速度。
- 内存优化：Edge对内存的使用比许多浏览器更优化，尤其是在多个标签页同时打开的情况下。
4. 功能
- Collections（集合）：用户可以将网页内容、图像、文字等收集在一起，方便做研究、购物计划或旅行计划。
- 阅读模式：简化网页布局，去除广告和多余元素，提升阅读体验。
- PDF工具：内置PDF查看和编辑功能，包括注释、绘图和填表等。
- 隐私保护：提供多种隐私设置，包括跟踪预防和InPrivate模式（无痕浏览）。
- 扩展支持：兼容Chrome Web Store的大多数扩展程序，同时也有自己的Microsoft Edge Add-ons商店。
5. 安全性
- SmartScreen：内置的SmartScreen筛选器可以防止访问恶意网站并下载有害文件。
- 密码监测：通知用户其保存的密码是否在网上泄露。
- 家庭安全：提供家庭端保护措施，可以为儿童设置内容限制和活动报告。
6. 跨平台支持
- 多平台：Edge支持Windows、macOS、iOS和Android操作系统。用户可以在不同设备间同步书签、密码、历史记录等数据。
7. 与Microsoft生态系统的集成
- Office 365：与Office 365和OneDrive无缝集成，方便用户在浏览器中打开和编辑文档。
- Cortana：内置Cortana语音助理（部分地区），可以直接在浏览器中进行语音搜索和命令。
8. 更新与反馈
- 频繁更新：Edge浏览器定期通过Windows Update进行更新，确保用户可以获得最新功能和安全补丁。
- 用户反馈：Edge团队重视用户反馈，并定期发布更新响应用户的需求和问题。
总结
微软Edge浏览器以其高效的性能、丰富的功能和深度的操作系统集成为用户提供了卓越的浏览体验。通过基于Chromium引擎，它不仅提升了兼容性，还能利用大量的现有扩展程序，是一款非常值得推荐的浏览器。 通义千问 微软Edge浏览器是微软推出的一款现代化网页浏览器，它取代了历史悠久的Internet Explorer浏览器，并且经历了几个重要的发展阶段。下面是关于微软Edge浏览器的一些关键信息：
发展历程 初代Edge (EdgeHTML):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3a6b406f09fcbe1db44e5b290799f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7144b9d22022bc7bb56f5c18893641b1/" rel="bookmark">
			基于微信小程序的健康饮食系统/健康饮食管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着信息技术和网络技术的飞速发展，人类已进入全新信息化时代，传统管理技术已无法高效，便捷地管理信息。为了迎合时代需求，优化管理效率，各种各样的小程序应运而生，各行各业相继进入信息管理时代，健康饮食就是信息时代变革中的产物之一。
任何小程序都要遵循系统设计的基本流程，本小程序也不例外，同样需要经过市场进行调研，论文需求进行分析，概要设计，系统详细设计，测试和编码等步骤，设计并实现了微信小程序的健康饮食系统。小程序选用微信开发者与java语言，应用SSM框架， MySQL为后台数据库。系统主要包括应用管理；食物管理、公告管理、用户管理等功能模块。
经过认真细致的研究，精心准备和规划，最后测试成功，小程序可以正常使用。分析功能调整与实现的实际需求相结合，开发了SSM框架开发微信小程序的健康饮食系统。
关键词：微信小程序的健康饮食系统；SSM框架；MySQL数据库；微信开发者
Abstract With the rapid development of information technology and network technology, mankind has entered a new information age. Traditional management technology has been unable to manage information efficiently and conveniently. In order to meet the needs of the times and optimize management efficiency, a variety of small programs came into being. All walks of life have entered the era of information management. Healthy diet is one of the products of the reform of the information age.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7144b9d22022bc7bb56f5c18893641b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935098a634182cec759253e76dc36aa0/" rel="bookmark">
			【数学建模】——【python】实现【最短路径】【最小生成树】【复杂网络分析】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 最短路径问题 - 绘制城市间旅行最短路径图
题目描述：
要求：
示例数据：
python 代码实现
实现思想：
要点：
2. 最小生成树问题 - Kruskal算法绘制MST
题目描述：
要求：
示例数据：
python代码实现
实现思想：
要点：
3. 结合最短路径与最小生成树的复杂网络分析
题目描述：
python代码
实现思想： 要点：
总结三个问题
专栏：数学建模学习笔记
上一篇：【数学建模】图与网络模型的学习
本篇是题目练习
1. 最短路径问题 - 绘制城市间旅行最短路径图 题目描述： 假设有一个包含多个城市及其之间距离的列表（或图结构），其中每个城市是图中的一个节点，城市之间的距离是边的权重。使用Dijkstra算法或Floyd-Warshall算法（视情况而定，如果图中节点数较多，推荐使用Dijkstra；如果需要求出所有点对间的最短路径，则使用Floyd-Warshall）来计算并绘制出从一个指定城市到其他所有城市的最短路径图。
要求： （1）使用Python编程，可以利用networkx库来构建图和处理图算法。
（2）绘制结果应包含所有节点（城市）和表示最短路径的边，边的粗细或颜色可以表示距离长短。
（3）标注每条边的权重（距离）。
（4）城市的数量N通过键盘输入，城市之间的距离通过随机数生成。
示例数据： # 城市间的距离矩阵（假设为完全图，即任意两城市间都有直接路径） distances = [ [0, 5, 10, 15], [5, 0, 3, 8], [10, 3, 0, 6], [15, 8, 6, 0] ] # 假设城市名称为 A, B, C, D
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935098a634182cec759253e76dc36aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be16c6692c1e7e237228f18a3f6641e/" rel="bookmark">
			DNS(域名解析协议)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. DNS工作原理 TCP / IP提供了通过IP地址来连接到设备的功能，但对用户来讲，记住某台设备的IP地址是相当困难的，因此专门设计了一种字符串形式的主机命名机制，这些主机名与IP地址相对应。在IP地址与主机名之间需要有一种转换和查询机制，提供这种机制的系统就是域名系统DNS
互联网中，一台计算机与其他计算机通信时，通过IP地址唯一的标志自己。此时的IP地址就类似于我们日常生活中的电话号码。但是，这种纯数字的标识是比较难记忆的，而且数量也比较庞大。例如，每个IPv4地址是一个32位长的二进制数字，或者采用点分十进制展示成192.168.1.1这种格式，有接近43亿个的IPv4地址。DNS的作用就是将人类可读的名称转换为机器识别的IP地址，供计算机相互连接。DNS的工作原理和电话簿相似，都是管理名称和数字之间的映射关系。就像我们日常打电话，一般使用人名查找，很少直接输入电话号码一样。当我们上网打开某个网页、视频时，也很少直接使用IP地址，而是在浏览器里输入的URL地址，例如：https://www.huawei.com，这其实使用的就是计算机的名字，一般称为域名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff9035d1d49fa5f5cffe35add5840dae/" rel="bookmark">
			【进阶篇-Day12：JAVA中stream流、File类的介绍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、stream流1.1 stream流的作用1.2 stream流的思想1.3 获取stream流对象1.4 stream流中间操作方法1.5 stream流终结操作方法1.6 stream收集操作1.7 stream的综合案例 2、File类2.1 File类创建文件对象2.2 File类的常用方法2.3 File类的创建和删除方法2.4 File类的遍历方法练习一：练习二：练习三：练习四： 1、stream流 1.1 stream流的作用 1.2 stream流的思想 注：stream流就是流水线工作，即将数据放入流水线（获取流对象），然后加工（中间方法），最后输出（终结方法）。
1.3 获取stream流对象 package com.itheima.stream; import java.util.*; import java.util.stream.Stream; public class StreamDemo1 { /** * 获取Stream流对象演示： * - 将数据放在流水线的传送带上 * * 1、集合获取 Stream 流对象 (使用Collection接口中的默认方法) * default Stream&lt;E&gt; stream() * 注意：Map集合获取Stream流对象，需要间接获取： * - map.entrySet().stream() * * 2、数组获取 Stream 流对象 (使用Array数组工具类中的静态方法) * static &lt;T&gt; Stream&lt;T&gt; stream (T[] array) * * 3、零散的数据获取Stream 流对象 (使用Stream类中的静态方法) * static &lt;T&gt; Stream&lt;T&gt; of(T.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff9035d1d49fa5f5cffe35add5840dae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a935762338d94b8e3d2e473dd89c39/" rel="bookmark">
			MySQL中实现动态表单中JSON元素精准匹配的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、动态表单技术
1、包含的主要信息
2、元素属性设置
3、表单内容
二、表单数据存储和查询
1、数据存储
2、数据的查询
3、在5.7版本中进行JSON检索
4、8.0后的优化查询
三、总结
前言 在很多有工作流设置的地方、比如需要在不同的流程中，需要实现流程表单的自定义。在以前的一些业务中，我们几乎都需要用户来固化表单。这样的实现方式，非常不友好，扩展性也不强。通常在上线后会需要进行调整。同时，在调整时，一般需要用户先明确流程，然后再反馈给开发人员，因为当时没有在线的流程表单构造器，流程的表单调整还需要开发人员来配合。这样一来，系统的开发步骤就比较长，一个流程要想走下来，花费的时间代价就非常大。因此，在这样的需求背景下，有的技术团队开始研究动态表单，将用户的创造和动手能力直接引入进来。用户不仅能自定义流程引擎，同时还能基于流程引擎来定义挂载在流程引擎上的表单。
到了这一步，应该说是非常友好的，用户可以深度的参与相关的设计，如果想调整流程。只需要下架旧的流程，然后设计新的流程，同时把相应的表单也设计好后一同发布。这样系统就会启动新的流程，表单也会自动更新。曾几何时，这种技术还是少数部分用户玩的，而今再看，就像“旧时王谢堂前燕飞入寻常百姓家”，已经没有了什么神秘的面纱，向大众展示它背后的一面。
虽然在流程中使用动态表单，有很好的扩展性和可用性。但是，同时也带来了一些额外的技术实现复杂度，就是在生成动态表单的时候，表单通常比较复杂，通常我们需要进行很多表单元素的编辑，还要定义表单的值，各种各样的表单元素类型。如果我想使用表格来导入这些数据，应该怎么来进行对应。导出的时候，怎么精准的写出数据。这对我们在数据库中设计相应的表以及针对动态表单的数据进行表单元素级的精准匹配有了一定的技术要求。
本文重点不是在于讲解如何设计动态表单，而是重点讲解，如何在将设计好的动态表单信息进行提取，比如进行模板数据导入的时候，可以根据不同的表单类型，比如根据单行文字框的名字来动态设置值，也可以在导数数据时，知道将数据库的性别一列保存的1和2翻译成男和女这两种属性。这都需要我们精准的提取表单中的不同的信息，能精准提取表单的文本、类型、默认值域还有其他的表单元素的设置。通过本文，您可以了解如何正确的操作动态表单信息，同时了解如何从表单中查找表单元素。
一、动态表单技术 为了让大家了解一些动态表单可能会包含哪些技术，我还是决定对动态表单技术进行简单的讲解，更深入的就不再进行赘述。目的是让大家对动态表单有个基本的认识。
1、包含的主要信息 众所周知，在Web界面的设计和实现中，表单其实就一个form界面，我们在这个Web界面中可以定义不同的表单元素，比如单行文本框，多行文本域、单选按钮、多选按钮、下拉框，而在现代的界面中，对元素的类型做了更进一步的细分，比如时间又可以分为时间选择器、日期选择器，其它的常见还有打分控件、计数器、颜色选择器、开关、滑块等等。在下图中列出来了常见的一些表单要素。
上面这个就是一个非常典型的表单设计器，它按照功能区域可以分为表单元素类型、表单设计渔区、属性设计渔区三个部分。从结构来说分为左、中、右三种类型。最左边的部分是表单中包含的元素类型，这个在上面的内容中有所涉及。下面有布局字段，布局的话就是用来控制页面的元素如何布置，比如一行是摆放三个单行文本域还是摆2个，这些都是通过布局元素来设置的。 中间就是主题的设计界面。点击左边的元素，然后拖到中间的设计器中即可。
2、元素属性设置 将元素和布局都设置好之后，一个设计良好的表单，还需要对表单的属性信息进行定义，比如表单的名字、它的默认值是什么，如果是下拉框，下拉框的值域又是什么？默认的下拉选项是哪个。表单的元素是否必填，是有其它的数据格式校验类型等等。这些属性信息都在最右边的属性编辑器中进行定义和设置。在中间的要素设计器中点击对应的表单元素，可以打开它对应的属性设置信息。如下图所示：
通过上面的表单设计界面，我们就可以实现表单的灵活设置。
3、表单内容 相信大家对于生成的表单内容是什么样的，一定很有兴趣吧。下面我们来看一下经过上面的动态表单设计之后，生成的表单内容是什么样的？具体的格式是什么？首先来点击预览，看一下表单设计器生成的页面效果。
点击“生成json”按钮可以将动态表单转成json，这样我们就可以把表单存储到数据库中，实现动态的管理和配置。来看下json的表单生成结果。
内容比较多，我们将表单内容复制到文本编辑器中，然后将json进行格式的美化后来看实际的效果。 "list": [ { "type": "grid", "icon": "icon-grid-", "columns": [ { "span": 12, "list": [ { "type": "input", "icon": "icon-input", "options": { "width": "100%", "defaultValue": "", "required": false, "dataType": "string", "pattern": "", "placeholder": "请输入姓名", "disabled": false, "maxlength": -1, "showWordLimit": false, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a935762338d94b8e3d2e473dd89c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66debd588d717b6ba7ca924620e8c15/" rel="bookmark">
			算法从零到精通 (一) ~ 快慢双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 快慢双指针是一种常用的算法技巧，通常用于解决涉及链表或数组的问题。它的基本思想是使用两个指针，一个移动速度快（快指针），一个移动速度慢（慢指针），来解决特定的问题。这两个指针通常从序列的起始位置开始，并以不同的步伐向前移动，直到达到特定的条件为止。
快慢双指针是指在算法处理过程中，使用两个指针，分别从序列的起始位置出发，按照不同的步伐向前移动，直到满足某种条件。通常快指针的移动速度比慢指针快，这样可以加快算法的执行速度。 判断链表是否有环：快指针每次移动两步，慢指针每次移动一步，如果存在环，快指针最终会追上慢指针。
找到链表的中间节点：快指针每次移动两步，慢指针每次移动一步，当快指针到达链表末尾时，慢指针所在位置即为中间节点。
移除排序数组中的重复项：使用快慢指针，当快指针遇到不同的元素时，将其复制到慢指针位置，然后慢指针前进一步。
2. 我对快慢指针的理解 1. 数组划分 cur：从左到右扫描数组，遍历数组(快指针)dest：已处理的区间内，非零元素的最后一个位置cur(快指针)遇到符合题意的值，把他加入这个区间。一般是先dest++然后和cur交换 如何做到维护该区间一直到结束，是解题的关键。
// 符合题意 不符合题意 未处理元素 // [0~dest] [dest + 1 ~ cur] [cur + 1 ~ n] 达到最终的目的就是持续这三块区域的关系
2. 判断是否成环 快指针每次移动两步，慢指针每次移动一步，如果存在环，快指针最终会追上慢指针。
3 例题分析 3.1 移动零 (数组划分) public void moveZeroes(int[] nums) { // 符合题意(非0元素) 不符合题意(0) 未处理元素 // [0~dest] [dest + 1 ~ cur] [cur + 1 ~ n] // 要想维护上面的关系到结束，必须让cur遇到符合题意的和dest后一个元素(不符合题意的交换)， // 然后让dest++(扩大符合题意的范围)，继续维护该区间 int n = nums.length, cur = 0, dest = -1; while(cur !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e66debd588d717b6ba7ca924620e8c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21235fcaea58278e1bf5891babab6f6e/" rel="bookmark">
			【数据结构】——单链表实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎光顾我的homepage
前言 链表和顺序表都是线性表的一种，但是顺序表在物理结构和逻辑结构上都是连续的，但链表在逻辑结构上是连续的，而在物理结构上不一定连续；来看以下图片来认识链表与顺序表的差别
这里以动态顺序表为例，和链表中的单链表对比一下
动态顺序表
单链表
这里就可以很清晰的看到顺序表的底层其实就是一个数组，数据的是连续存储的（顺序表物理结构连续）；而链表它每一个数据都不是连续的（链表物理结构上不一定连续）。
链表节点 通过观察上图，我们会发现链表每一个节点都存放在数据和下一个节点的地址。
那么来想一下，为了链表每一个节点都统一起来，都存储有效数据和下一个节点的地址，我们就需要创建应该结构体，来存储有效数据和下一个节点的指针；
注：这里只是单链表
typedef int SLType; typedef struct SLTNode { SLType data; struct SLTNode* next; }SLT; 创建好链表节点，接下来就来实习单链表存储数据的这些功能。
单链表实现 先来看一下单链表都实现都哪些功能
//输出链表 void SLTPrint(SLT* phead); //创建节点 SLT* SLTCreat(SLType x); //单链表头插 void SLTPushFront(SLT** pphead, SLType x); //单链表尾插 void SLTPushBack(SLT** pphead, SLType x); //单链表头删 void SLTPopFront(SLT** pphead); //单链表尾删 void SLTPopBack(SLT** pphead); //查找数据 SLT* SLTFind(SLT* phead, SLType x); //指定位置之前插入 void SLTInsert(SLT** pphead, SLT* pos, SLType x); //指定位置之后插入 void SLTInsertAfter(SLT* pos, SLType x); //删除指定节点 void SLTErase(SLT** pphead, SLT* pos); //删除指定位置后一个节点 void SLTEraseAfter(SLT* pos); 创建节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21235fcaea58278e1bf5891babab6f6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2114325f78711d93c20645afdcd1104/" rel="bookmark">
			Java中的优先级队列（PriorityQueue）（如果想知道Java中有关优先级队列的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：优先级队列（Priority Queue）是一种抽象数据类型，其中每个元素都关联有一个优先级，元素按照优先级顺序进行处理。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.优先队列的初识
（1）优先级队列的定义
（2）PriorityQueue的特性
2.优先级队列的模拟实现
3.优先级队列中常用API
（1）创建优先级队列
（2）插入/删除/获取优先级最高的元素/获取个数/清空/判断是否为空
4.优先级队列的使用
1. 任务调度
2. 事件驱动模拟
3. 图算法
4. 数据流处理
1.优先队列的初识 （1）优先级队列的定义 在开始学习Java中优先级队列的使用之前，先让我们了解一下什么是Java中的优先级队列（PriorityQueue）：
优先级队列（Priority Queue）是一种抽象数据类型，其中每个元素都关联有一个优先级，元素按照优先级顺序进行处理。与标准队列不同，优先级队列中的元素处理顺序并非按插入顺序，而是按照优先级高低来决定。
如果读者看了优先级队列的定义之后还是不是太理解什么是优先级队列，那么现在我们使用一个日常生活中的例子来帮助你理解：
——例如在医院急诊室，虽然你可能先到，但是医生会根据病人的病情严重程度来决定治疗顺序。病情严重的病人（例如，心脏病发作的病人）会被优先治疗，而病情较轻的病人（例如，轻微的感冒）会被安排在后面。
这样我相信读者就对优先级队列有了初步的认识了！！！
（2）PriorityQueue的特性 Java集合框架中提供了PriorityQueue和PriorityBlockingQueue两种类型的优先级队，而对于PriorityQueue是线程不安全的，PriorityBlockingQueue是线程安全的，而本文我们主要介绍是PriorityQueue。
其在Java集合框架中的关系图为：
关于PriorityQueue的使用要注意：
1. 使用时必须导入PriorityQueue所在的包，即：
import java.util.PriorityQueue; 2. PriorityQueue中放置的元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出ClassCastException异常；
3. 不能插入null对象，否则会抛出NullPointerException；
4. 没有容量限制，可以插入任意多个元素，其内部可以自动扩容；
5. 插入和删除元素的时间复杂度为O（logN）；
6. PriorityQueue底层使用了堆数据结构；
7. PriorityQueue默认情况下是小堆---即每次获取到的元素都是最小的元素；
至此，我们通过上述对Java中的优先级队列的简单讲述，我们就大致的了解了什么是Java中的优先级队列了！
2.优先级队列的模拟实现 在了解完了什么是Java中的优先级队列之后，现在让我们想想看如何去自我实现一个Java中的优先级队列呢？
——这里我们已经在每处加上了注释，希望读者可以跟随着注释进行理解代码：
package Demo1; import java.util.Arrays; // 堆的自我实现 - 创建堆 + 插入数据 + 删除数据 + 返回堆顶元素 + 判断是否为空 public class MyPriorityQueue { public int[] elem; // 存储堆元素的数组 public int useSize; // 当前堆中元素的个数 // 初始化堆 public MyPriorityQueue(int[] array) { elem = new int[11]; // 初始化堆的容量 for (int i = 0; i &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2114325f78711d93c20645afdcd1104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f482ce8ef605df024bbd5df44ecdb3/" rel="bookmark">
			力扣最热一百题——4.移动零
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
日常吐槽
题目链接：283. 移动零 - 力扣（LeetCode）
题目描述
示例
提示
解法一：交换位置
思路
代码实现
解法二：覆写元素
思路
代码实现
总结
日常吐槽 今天本来是计划玩玩游戏的，结果我直接上头了，输一把赢一把的，唉，最后也没法从完美B+差三分上A，还到欠了四十多分才上A，我真的服了，话不多说直接上今天的题目吧。
题目链接：283. 移动零 - 力扣（LeetCode） 注：下述题目描述和示例均来自力扣
题目描述 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
示例 示例 1:
输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2:
输入: nums = [0] 输出: [0] 提示 1 &lt;= nums.length &lt;= 104-231 &lt;= nums[i] &lt;= 231 - 1 进阶：你能尽量减少完成的操作次数吗？
呃不能。。。。。
这里题目有一个很关键的信息就是要在不复制数组的情况下对数组进行操作，也就是我们要在原数组上进行操作，不能新开一个数组，否则就太简单了，直接遍历一遍不要0就行了。并且记住要保持其他元素的相对顺序。
解法一：交换位置 思路 这个解法的思路就是我每次先找到一个0，这个0的位置是最靠前的一个0，然后在这个0的位置上往后找第一个不为零的元素，使用两个指针记录这两个数的位置，交换他们的位置即可，非常简单，思路也是很清晰的，交换完最后一个0之后，所有的0也就在后面了。
代码实现 class Solution { public void moveZeroes(int[] nums) { // 0,1,0,3,12 // l r // 1,0,0,3,12 // lr // 1,3,12,0,0 // l r // 获取数组的长度 int len = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f482ce8ef605df024bbd5df44ecdb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2977a0832f36ac4e4c933ff148a5341/" rel="bookmark">
			feign.codec.DecodeException: Could not extract response: no suitable HttpMessageConverter found for
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错 Could not extract response: no suitable HttpMessageConverter found for response type [xxx] and content type [application/octet-stream] feign.codec.DecodeException: Could not extract response: no suitable HttpMessageConverter found for response type [xxx] and content type [application/octet-stream] 解释一下：就是Feign自带的转换器中，无法把[class XXX]转换成content type [XXX;XXX]
在使用SpringCloud FeignClient的时候，经常的情况是我们希望返回的是一个application/json类型的返回，当返回是[application/octet-stream]类型或者其他自带转换器中没有的类型时，feign调用就会解析错误。 二、具体源码分析 （1）在 Springboot 默认处理器为 MappingJackson2HttpMessageConverter 用于将 Java 对象转换为 JSON 格式。
但是MappingJackson2HttpMessageConverter，只支持"application/json"类型；因此springboot没有找到合适的HttpMessageConverter,于是报出了上面的异常。
（2）feign默认的Decoder为SpringDecoder SpringDecoder的decode的过程：
判断目标类型合法的利用Spring框架的消息转换器messageConverters来执行这个任务，并可以通过自定义器来customizers自定义转换器的行为创建一个HttpMessageConverterExtractor对象，最终通过调用该对象的extractData方法将Feign的响应Response对象转化为Java对象 二、解决措施 解决该问题，可以自定义一个Feign的Decoder，只要添加MediaType.APPLICATION_OCTET_STREAM_VALUE类型的支持即可。
第一步：自定义一个Decoder： import com.fasterxml.jackson.databind.ObjectMapper; import feign.Response; import feign.codec.Decoder; import lombok.extern.slf4j.Slf4j; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2977a0832f36ac4e4c933ff148a5341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c47120f50209417f0633d85f2ff5ec/" rel="bookmark">
			Spark学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark学习 什么是spark？
Apache Spark是一个开源的集群计算系统，旨在使数据分析变得快速
既运行得快，又写得快
spark5大模块：
回顾：MR的执行流程
hadoop为什么慢？？？额外的复制，序列化，磁盘IO开销
spark为什么快？？？因为内存计算，当然还有DAG(有向无环图)
支持3种语言的API ：Scala（很好）Python（不错）Java（…）
有4种模式可以运行
Local 多用于测试
Standalone 节点运行
Mesos
YARN 最具前景
本地部署spark： 添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;2.12.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-compiler&lt;/artifactId&gt; &lt;version&gt;2.12.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-reflect&lt;/artifactId&gt; &lt;version&gt;2.12.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.12&lt;/artifactId&gt; &lt;version&gt;3.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.12&lt;/artifactId&gt; &lt;version&gt;3.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.12&lt;/artifactId&gt; &lt;version&gt;3.1.3&lt;/version&gt; &lt;/dependency&gt; WordCount:
数据展示：
import org.apache.spark.rdd.RDD import org.apache.spark.{SparkConf, SparkContext} object WordCount { def main(args: Array[String]): Unit = { // 创建spark配置文件对象 val conf = new SparkConf() // 设置运行模式 // local模式运行，需要设置setMaster // 若要是集群运行，注释这句话即可 conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07c47120f50209417f0633d85f2ff5ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05245404aa6064a25e1cc4b0e7c808df/" rel="bookmark">
			JavaScript轮播图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML部分
&lt;div class="box" onmouseover="over()" onmouseout="noover()"&gt; &lt;img src="./img/zuo.png" alt="" class="left_arrow" onclick="left_last()"&gt; &lt;img src="./img/yy.png" alt="" class="right_arrow" onclick="right_word()"&gt; &lt;div id="carousel"&gt; &lt;/div&gt; &lt;div class="round"&gt; &lt;/div&gt; &lt;/div&gt; JavaScript部分：携带注释哟家人们
&lt;script&gt; let data; // 声明一个变量用于存储从服务器获取的数据 let k = 0; // 当前显示的图片索引 let imgwidth; // 图片宽度 let imgheight; // 图片高度 let inter; // 用于存储定时器的变量 // 创建一个XMLHttpRequest对象用于发送请求 let xhr = new XMLHttpRequest(); // 设置请求方式和请求地址 xhr.open('get', './js/banner.json', true); // 发送请求 xhr.send(); // 接收返回的响应数据 xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05245404aa6064a25e1cc4b0e7c808df/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/113/">«</a>
	<span class="pagination__item pagination__item--current">114/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/115/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>