<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f7c5c3dbfa0cb2db070f4757256226/" rel="bookmark">
			SSE实现消息实时推送，前端渐进式学习、实践，真香
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SSE概念 SSE(Server Sent Event)，直译为服务器发送事件，顾名思义，也就是客户端可以获取到服务器发送的事件。我们常见的 http 交互方式是客户端发起请求，服务端响应，然后一次请求完毕；但是在 sse 的场景下，客户端发起请求，连接一直保持，服务端有数据就可以返回数据给客户端，这个返回可以是多次间隔的方式
二、SSE应用场景 在web端消息推送功能中，由于传统的HTTP协议是由客户端主动发起请求，服务端才会响应。基本的ajax轮询技术便是如此。而在SSE中，浏览发送一个请求给服务端，通过响应头中的Content-Type:text/event-stream等向客户端声名这是一个长连接，发送的是流数据，这样客户端就不会关闭连接，一直等待服务端发送数据。
如果服务器返回的数据中包含了事件标识符，浏览器会记录最后一次接收的事件的标识符。如果与服务器的连接中断，当浏览器再次进行连接时，会通过头来声明最后一次接收的事件的标识符。服务器端可以通过浏览器发送的事件标识符来确定从哪个事件来继续连接
三、前端使用方法、问题 1、get方式 使用eventsource完成get请求
缺点：客户端无法通过一个get请求完成数据传递
参考文档：
EventSource - Web API 接口参考 | MDN
实现流程：
后端提供了两个接口，一个是：post,用以完成前端信息的传递，我这边是做大语言模型的，所以包括了模型必要参数、问题等；二、get接口，完成流式输出的接口，配置相应的具名事件、请求头等前端通过调用post接口拿到本次会话id，将id携带在get请求里，完成信息传递前端处理SSE流式返回 代码实现：
const eventSourceRef = useRef&lt;any&gt;(null) const contact = async (messageData: any) =&gt; { eventSourceRef.current = new EventSource( `${API_BASE}/v1/model/stream?id=${id}`, ) if (!eventSourceRef.current) return // 监听 SSE 事件，因为后端定义了具名事件，所以这儿要用addEventListener监听，而不是onmessage eventSourceRef.current.addEventListener('add', function (e: any) { // 处理数据展示 }) eventSourceRef.current.addEventListener('finish', function (e: any) { // 结束标识finish eventSourceRef.current.close() // 关闭连接 }) eventSourceRef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f7c5c3dbfa0cb2db070f4757256226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6a909fe4f6aee91f14731751dfc23f/" rel="bookmark">
			java: 错误: 无效的源发行版:17。2种解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java: 错误: 无效的源发行版:17解决方式 解决方式有2种，1.降低版本，2.更新自己的JDK到17方式一：降低版本方式二：升级JDK1.下载jdk17，并配置环境变量2.IDEA配置 解决方式有2种，1.降低版本，2.更新自己的JDK到17 方式一：降低版本 降低版本操作方式链接
方式二：升级JDK 1.下载jdk17，并配置环境变量 链接：https://pan.baidu.com/s/1GFSPc3wrkWMBKj8N9NRjow
提取码：1111
2.IDEA配置 2.1 远程拉取的项目中pom.xml文件，java版本为17。
2.2 刷新Maven后，查看IDEA的setting，基本都会变成17。版本随着pom配置的版本变化
2.3 IDEA的Project Structure中，Modules也会变成17。版本随着pom配置的版本变化
2.4 启动失败截图
2.5 重点：启动项目出现无效发行源版本17。可按照此操作方式，修改Project Structure的project
2.6 成功截图，按照2.5修改后。启动可能有点慢，耐心等待即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6664c6a828c8b9b28ff635917e25e62a/" rel="bookmark">
			大数据的5个V
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据的5V是什么? 大数据的5V——速度（velocity）、体积（volume）、价值（value）、多样性（variety）和准确性（vaccuracy）——是大数据的五大固有特征。了解5V可以让数据科学家从他们的数据中获得更多价值，同时也可以让他们的组织变得更加以客户为中心。
本世纪初，大数据被称为“3V”——体积（volume）、速度（velocity）和多样性（variety）。随着时间的推移，又增加了两个V——价值（value）和准确性（veracity），以帮助数据科学家更有效地表达和传达大数据的重要特征。在某些情况下，大数据甚至还有第六个V项——可变性。
什么是大数据? 大数据是组织收集的非结构化、半结构化或结构化数据的组合。这些数据集可以被挖掘以获得洞察力，并用于机器学习项目、预测建模和其他高级分析应用程序。
大数据可以用来改善运营，提供更好的客户服务，并创建个性化的营销活动——所有这些都可以为组织增加价值。例如，大数据分析可以为公司提供有价值的客户洞察，然后可以用来改进营销技术，以提高客户参与度和转化率。
大数据可以用于医疗保健，以识别疾病风险因素，或者医生可以使用大数据来帮助诊断患者的疾病。能源行业可以使用大数据来跟踪电网，制定风险管理或进行实时市场数据分析。
使用大数据的组织比那些不使用大数据的组织具有潜在的竞争优势，因为它们可以做出更快、更明智的商业决策——就像数据提供的那样。
5个V是什么？ 5V的定义如下：
速度是指数据产生的速度和移动的速度。体积是指符合大数据标准的数据量。价值是数据提供的值。多样性是存在于数据类型中的多样性。准确性是指数据的质量和准确性。 速度
速度指的是数据产生的速度和移动的速度。对于需要数据快速流动的组织来说，这是一个重要的方面，因此可以在正确的时间使用它来做出最佳的业务决策。
使用大数据的组织将拥有大量连续的数据流，这些数据流正在被创建并发送到最终目的地。数据可能来自机器、网络、智能手机或社交媒体等来源。Velocity指信息到达的速度——例如，每天有多少社交媒体帖子被吸收——以及信息需要消化和分析的速度——通常是快速的，有时是近乎实时的。
例如，在医疗保健领域，当今许多医疗设备的设计目的是监测患者并收集数据。从医院医疗设备到可穿戴设备，收集的数据需要发送到目的地并快速分析。
然而，在某些情况下，收集一组有限的数据可能比收集组织无法处理的数据要好，因为这可能导致数据速度变慢。
体积
Volume是指存在的数据量。体积就像大数据的基础，因为它是收集数据的初始大小和数量。如果数据量足够大，就可以认为是大数据。然而，所谓的大数据是相对的，它会随着市场上可用的计算能力而变化。
例如，一家在几个州经营数百家商店的公司每天产生数百万笔交易。这被称为大数据，而商店每天的平均总交易量代表了大数据量。
价值
价值是指大数据可以提供的好处，它直接关系到组织可以用收集到的数据做什么。能够从大数据中获取价值是一种需求，因为大数据的价值会根据从中获得的洞察力而显著增加。
组织可以使用大数据工具来收集和分析数据，但如何从这些数据中获取价值应该是他们独有的。像Apache Hadoop这样的工具可以帮助组织存储、清理和快速处理大量数据。
大数据价值的一个很好的例子是收集个人客户数据。当一个公司可以对其客户进行分析时，它可以个性化他们在营销和销售方面的经验，提高沟通效率，并获得更高的客户满意度。
多样性
多样性是指数据类型的多样性。组织可能从多个数据源获取数据，这些数据源的值可能不同。数据也可以来自企业内部和外部。多样性的挑战涉及到所收集的所有数据的标准化和分布。
如上所述，收集的数据可以是非结构化、半结构化或结构化。非结构化数据是没有组织的数据，以不同的文件或格式出现。通常，非结构化数据不适合主流关系数据库，因为它不适合传统的数据模型。半结构化数据是没有组织到专门的存储库中，但具有关联信息（如元数据）的数据。这使得它比非结构化数据更容易处理。与此同时，结构化数据是组织到格式化存储库中的数据。这意味着数据可以更有效地处理和分析。
原始数据也可以作为数据类型。虽然原始数据可以属于其他类别——结构化、半结构化或非结构化——但如果根本没有接受任何处理，则认为它是原始的。raw（未经处理的格式）通常适用于从其他组织导入或由用户提交或输入的数据。社交媒体数据通常属于这一类。
一个更具体的例子是，一家公司收集了关于其客户的各种数据。这可能包括从交易或非结构化社交媒体帖子中剔除的结构化数据。其中大部分可能以原始数据的形式出现，需要在处理之前进行清理。
准确性
准确性是指数据的质量、准确性、完整性和可信度。收集到的数据可能有缺失的部分，可能是不准确的，或者可能无法提供真实的、有价值的见解。总体而言，准确性指的是对所收集数据的信任程度。
数据有时会变得混乱，难以使用。如果数据不完整，那么大量的数据可能会导致更多的混乱。例如，在医疗领域，如果关于患者正在服用的药物的数据不完整，则可能危及患者的生命。
价值和准确性都有助于定义从数据中收集的质量和见解。数据准确性的阈值通常（也应该）存在于组织的执行层，以确定数据是否适合高层决策。
第六个V：可变性 上面的5V涵盖了很多方面，在阐明大数据的正确使用方面有很大的帮助。但还有另一个V值得认真考虑——可变性——它并不是大数据的定义，而是强调了对大数据进行良好管理的必要性。
可变性指的是大数据在使用或流动方面的不一致性。在前者的情况下，一个组织可能有多个特定数据的定义。例如，保险公司可能有一个部门使用一组风险阈值，而另一个部门使用另一组风险阈值。在第二种情况下，以分散的方式流入公司数据存储的数据——没有共同的入口点或预先验证——可能会进入不同的系统，这些系统会对其进行修改，从而导致报告方面的事实来源相互冲突。
最大限度地减少大数据的可变性需要在数据通过组织系统时仔细构建数据流，从交易到分析以及介于两者之间的一切。最大的好处是大数据的准确性，因为数据使用的一致性可以产生更稳定的报告和分析，从而提高可信度。
本文转载自 雪兽软件
更多精彩推荐请访问 雪兽软件官网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c01d22ae11ab600a26e3c6e81e5b78/" rel="bookmark">
			DDD架构理论详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概念入门1. 概念简介2. DDD的核心理念3. 范式4. 模型5. 框架6. 方法论7. 软件设计的主要活动 二、DDD核心理论1. Domain领域层都包含什么？2. 聚合、实体和值对象3. 仓储，封装持久化数据4. 适配（端口），调用外部接口5. 事件，触发异步消息6. 领域服务，实现约定 一、概念入门 1. 概念简介 DDD是领域驱动设计（Domain-Driven Design）的缩写，这是一种主要软件开发方法，由Eric Evans在它的书《领域驱动设计：软件核心负责性应对之道》中首次提出。DDD主要关注于创建与业务领域紧密相关的软件模型，以确保能够准确地解决实际问题。
2. DDD的核心理念 领域模型（Domain Model） 领域模型是对特定业务领域知识的精确表示，它包括了业务中的实体（Entities）、值对象（Value Objects）、服务（Services）、聚合（Aggregates）、聚合根（Aggregate Roots）等概念。领域模型是DDD的核心，它反映了业务专家的语言和决策。
统一语言（Ubiquitous Language）： 统一语言是开发团队和业务专家之间共同使用的语言，它在整个项目中保持一致。统一语言确保所有人对业务概念有着相同的理解，减少沟通成本和误解。
限界上下文（Bounded Context） 限界上下文是明确界定的系统边界，在这个边界内部有一套统一的模型和语言。不同的限界上下文之间可能有不同的模型，它们通过上下文映射来进行交互和集成。
聚合（Aggregate） 聚合是一组相关对象的集合，它们被视为数据修改的单元，每个聚合都有一个聚合根，它是外部对象与聚合内部对象交互的唯一入口。
领域服务 当某些行为不自然属于任何实体或值对象时，这些行为可以被定义为领域服务，领域服务通常表示领域中一些操作或业务逻辑。
应用服务 应用服务是软件的一部分，它们协调领域对象来执行任务。它们负责应用程序的工作流程，但不包含业务规则和知识。
基础设施 基础设施包括为领域模型提供持久化机制（如数据库）、消息传递、应用程序配置等技术组件
领域事件 领域事件是领域中发生的有意义的业务事件，它们可以触发其他子系统的反应和流程。
DDD的目标是通过将软件的关注点集中在核心领域上，并通过丰富的领域模型来管理复杂性，从而提高软件的质量和维护性。DDD强调与业务专家的紧密合作，以确保软件解决方案能够准确反映业务需求。通过这种方法，软件开发团队可以创建更加灵活、可扩展且与业务紧密结合的系统。
其中DDD所提到的软件设计方法涵盖了：范式、模型、框架、方法论，主要活动包括建模、测试、工程、开发、部署、维护。
软件设计方法是指一系列用于指导软件开发过程的原则、概念和实践，这些方法通常包括范式、模型、框架、方法论。下面一一介绍：
3. 范式 范式是指软件设计和开发的基本风格和哲学。它通常定义了编程的基本原则和模式。常见的软件设计范式包括：
结构化编程：强调程序结构的重要性，使用顺序、选择和循环控制结构面向对象编程：基于对象的概念，将数据和处理数据的方法封装到一起函数式编程：将计算视为函数的评估，避免状态改变和可变数据事件驱动编程：以事件为中心，响应用户操作、消息或其他系统事件 4. 模型 模型是对软件系统的抽象表示，用于帮助理解、设计和测试系统。常用的软件设计模型包括：
UML统一建模语言：一套图形化的建模语言，用于描述、设计和文档化软件项目ER模型：用于数据库设计，描述数据的实体及其之间的关系状态机模型：描述系统可能的状态、事件和这些事件发生时的转换 5. 框架 框架是一套预先定制的代码和组件，用于提供软件开发的骨架。框架通常定义了应用程序的结构，提供了一组通用的功能和模式，以便开发者可以专注于实现特定的业务逻辑。
Spring FrameworkRuby on Rails：一个用于快速开发web应用程序的Ruby框架Django：一个高级的Python Web框架 6. 方法论 方法论是指一套指导软件开发过程的规则和实践。它包括项目管理、开发流程、团队协作等方面。常用的软件开发方法论如下：
敏捷开发：一种迭代和增量的开发方法，强调灵活性和客户合作Scrum：一种敏捷开发框架，用于管理复杂的软件和产品开发瀑布模型：一种线性顺序的开发方法，将项目分为不同阶段，每个阶段完成后进入下一个阶段 7. 软件设计的主要活动 软件设计的主要活动包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09c01d22ae11ab600a26e3c6e81e5b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346329ae4fd5003874967263e1d20a8c/" rel="bookmark">
			【MySQL】连接查询（JOIN 关键字）—— 图文详解：内连接(INNER JOIN)、外连接（OUTER JOIN）、左连接（LEFT JOIN）、左外连接、右连接、右外连接、全连接、全外连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 连接查询驱动表连接查询分类 内连接（INNER JOIN）内连接 —— 等值连接内连接 —— 自然连接（NATURAL JOIN）内连接 —— 交叉连接 / 笛卡尔积（CROSS JOIN） 外连接（OUTER JOIN）外连接 —— 左连接（LEFT JOIN） / 左外连接（LEFT OUTER JOIN）拓展：左连接不包含内连接 外连接 —— 右连接（RIGHT JOIN） / 右外连接（RIGHT OUTER JOIN）拓展：右连接不包含内连接 外连接 —— 全连接 / 全外连接【注意】：FULL OUTER JOIN 关键字异常讨论拓展：全连接不包括内连接 我是一名立志把细节都说清楚的博主，欢迎【关注】🎉 ~
原创不易， 如果有帮助 ，记得【点赞】【收藏】 哦~ ❥(^_-)~
如有错误、疑惑，欢迎【评论】指正探讨，我会尽可能第一时间回复的，谢谢支持
连接查询 MySQL使用 JOIN 关键字连接多个表查询数据，主要使用的是嵌套循环连接算法（nested-loop join）。这种算法机制简单的理解可以类比为for循环遍历一样。
从驱动表中选取数据作为循环的基础数据，然后以这些数据作为 查询条件 到下一个表中进行循环遍历查询。循环往复。
这种算法的缺点是： 连接的表越多，循环嵌套的层数就越多，算法复杂度呈指数级增长。
对应的处理方法是： 我们在设计查询时，尽可能减少连接表的个数。
驱动表 驱动表： 在使用多表嵌套连接时，首先，会全表扫描该一个表作为查询条件，这个表叫做驱动表。然后用驱动表返回的结果集逐行去匹配的表，叫做被驱动表。
关于驱动表的详细说明及性能优化，本文不过多提及，感兴趣的可以看这篇文章：
【MySQL】驱动表、被驱动表详解。—— 性能优化。
连接查询分类 内连接（INNER JOIN） 等值连接（最常用）自然连接交叉连接 外连接（INNER JOIN） 左连接（LEFT JOIN） / 左外连接（LEFT OUTER JOIN）右连接（RIGHT JOIN） / 有外连接（RIGHT OUTER JOIN） 全连接 内连接（INNER JOIN） 内连接查询的是两张表的交集，即两张表都有的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/346329ae4fd5003874967263e1d20a8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8935c0900f98fef9233f8b8fcf58a583/" rel="bookmark">
			FastAPI vs Flask: 选择最适合您的 Python Web 框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介2. 安装和设置3. 路由和视图4. 自动文档生成5. 数据验证和序列化6. 性能和异步支持结论 在 Python Web 开发领域，FastAPI 和 Flask 是两个备受欢迎的选择。它们都提供了强大的工具和功能，但是在某些方面有所不同。本文将比较 FastAPI 和 Flask，并帮助您选择适合您项目需求的框架。 1. 简介 FastAPI：FastAPI 是一个现代的、高性能的 Web 框架，基于 Python 3.7+ 的类型提示来实现 API。它提供了快速、简单和直观的方式来构建 Web API。Flask：Flask 是一个轻量级的 Web 框架，简单而灵活，适合构建小型到中型的 Web 应用程序。它被广泛用于构建原型和快速开发。 2. 安装和设置 FastAPI：使用 pip 安装 FastAPI 和 Uvicorn（ASGI 服务器）：pip install fastapi uvicorn 创建一个 Python 文件并编写 FastAPI 应用程序：from fastapi import FastAPI app = FastAPI() @app.get("/") async def read_root(): return {"message": "Hello, FastAPI!"} Flask：使用 pip 安装 Flask：pip install Flask 编写一个简单的 Flask 应用程序：from flask import Flask app = Flask(__name__) @app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8935c0900f98fef9233f8b8fcf58a583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7ebc3b9df3fa8d1e03d192dffe14cf/" rel="bookmark">
			利用openai的whisper，识别会议录音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是代码的详细解释：
一、 **导入必要的库** 代码开始时，导入了必要的库：`tkinter` 用于创建 GUI，`filedialog` 用于选择音频文件，`os` 用于文件操作，`whisper` 用于语音转文本。
二、**创建 GUI** GUI 由一个框架组成，包含一个按钮用于选择音频文件，一个标签用于显示所选文件，另一个标签用于显示转换结果。 **选择音频文件** 当按钮被点击时，`select_audio_file` 函数被调用，打开一个文件对话框，以便用户选择音频文件。所选文件路径被存储在 `root.filename` 变量中。
三、**将语音转换为文本** `convert_speech_to_text` 函数被调用，带有所选音频文件作为参数。该函数使用 Whisper 库将音频文件转换为文本，并将结果存储在 `text` 变量中。
四、**保存转换结果** `save_text_file` 函数被调用，带有音频文件路径和转换文本作为参数。该函数将转换结果保存到与音频文件相同目录下的文本文件中。 **显示结果** 转换结果被显示在 GUI 标签中。
安装必要的库
pip install whisper
whisper转录需要FFmpeg
安装 FFmpeg 的方法取决于你的操作系统。下面是常见操作系统的安装方法：
Windows
下载 FFmpeg 的 Windows 版本从官方网站：https://ffmpeg.org/download.html选择合适的版本（32 位或 64 位）并下载安装程序。运行安装程序并按照提示安装 FFmpeg。将 FFmpeg 的安装目录添加到系统的 PATH 中。 Mac (via Homebrew)
安装 Homebrew，如果你还没有安装：https://brew.sh/打开 Terminal 并输入以下命令：brew install ffmpeg等待安装完成。 Linux (Ubuntu/Debian)
打开 Terminal 并输入以下命令：sudo apt-get install ffmpeg 在win系统中需要将ffmpeg添加到环境变量中。为了将位于 E:\ffmpeg-7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd7ebc3b9df3fa8d1e03d192dffe14cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1861a2f0805b9e338b890715a8893b53/" rel="bookmark">
			前端处理跨域的九种方式（超级详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是跨域广义的跨域：什么是同源策略同源策略的目的同源策略限制的行为操作跨域解决方案一、通过jsonp跨域二、 document.domain + iframe跨域 此方案仅限主域相同，子域不同的跨域应用场景。三、 location.hash + iframe跨域 实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。四、 window.name + iframe跨域五、 postMessage跨域六、 跨域资源共享（CORS)1、 前端设置：2、 服务端设置： 七、Nodejs中间件代理跨域1、 非vue框架的跨域（2次跨域）2、 vue框架的跨域（1次跨域） 八、 WebSocket协议跨域九、 nginx代理跨域1、 nginx配置解决iconfont跨域2、 nginx反向代理接口跨域 什么是跨域 指一个域下文档或者脚本去请求另一个域下的资源，这里的跨域是广义的；
广义的跨域： 资源提跳转：A链接、重定向、表单提交资源潜入：link、script、img、frame等dom标签，还有样式中background:url()、@font-face()等文件外链脚本请求：js发起的ajax请求、dom和js对象的跨域操作； 其实我们通常说的跨域是由 “浏览器同源策略限制” 的一类请求场景
什么是同源策略 同源策略（Same origin policy），简称SOP，是一种约定，它由Netscape公司1995年引入浏览器，它是浏览器核心也是最基本的安全功能，如果缺少同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指“协议+ 域名+ 端口”三种相同；
同源策略的目的 为了保证用户信息的安全，防止恶意网站窃取数据
同源策略限制的行为操作 cookie、localStorage、IndexDB无法读取 （不能共享cookie）DOM和Js对象无法获得（不能相互操作dom）Ajax请求不能发送(不能发送ajax请求) 跨域解决方案 通过jsonp跨域document.domain + iframe跨域location.hash + iframewindow.name + iframe跨域postMessage跨域跨域资源共享（CORS）nginx代理跨域nodejs中间件代理跨域WebSocket协议跨域 一、通过jsonp跨域 通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离在另一台服务器上，在html页面中再通过相应的标签从不痛域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。
原生实现 &lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.demo2.com:8080/login?user=admin&amp;callback=onBack'; document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1861a2f0805b9e338b890715a8893b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d37349af97b414dd27a48fc0602ae8/" rel="bookmark">
			无处不在的AI：被科技巨头盯上的Agent智能体的崭新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥽一.Agent AI智能体 Agent AI 智能体是一种基于人工智能技术的智能代理，它可以自主地执行任务、与环境进行交互，并根据环境的变化做出决策。
OpenAI将AI Agent定义为以大语言模型（LLM）为大脑驱动具有自主理解、感知、规划、记忆和使用工具的能力能自动化执行复杂任务的系统一句话解释即——
AI Agent就是具有独立思考和行动能力的AI程序
以下是关于 Agent AI 智能体的一些常见特点和应用场景： 自主性：Agent AI 智能体具有自主决策和行动的能力，能够在没有人类干预的情况下完成任务。适应性：能够根据环境的变化和反馈调整自己的行为和策略，以提高任务完成的效率和质量。学习能力：可以通过学习和训练来不断提升自己的性能和能力，从而更好地适应不同的任务和环境。交互性：能够与其他智能体或人类进行交互和协作，共同完成复杂的任务。应用场景：Agent AI 智能体在许多领域都有广泛的应用，如金融、医疗、教育、制造、物流等。例如，在金融领域，它可以帮助银行实现智能风控、智能投资和智能客服等功能；在医疗领域，它可以辅助医生进行疾病诊断、药物研发和医学影像分析等工作；在教育领域，它可以实现智能辅助教学、个性化学习和智能评估等功能。 🥼二.Agent AI智能体的超进化 总的来说，Agent AI 智能体是人工智能技术的重要应用之一，它的出现将为人们的生活和工作带来更多的便利和效率。
就在去年来自斯坦福大学以及谷歌的人工智能研究团队创造了一个完全由AI主导的虚拟世界——“Smallville”这里的25位居民均由AI控制即25个AI Agent在设置好了基础的建筑设施、人物性格后研究人员便不再插手小镇居民每天早起刷牙、亲吻爱人、吃早饭和家人、朋友、邻居社交执行着类似人类的日常行为演绎着25个ChatGPT实例该实验在网上引发了热烈讨论
有人开玩笑说“给它再模拟100年......我们再看”
结论为在执行任务和社会互动方面AI Agent表现出令人惊艳的自主性和智能性。
执行复杂任务时AI Agent会将大目标分解为子目标从而高效规划一系列行动此外有效的记忆机制使它能够调用以往的经验和知识，提供更具个性化和连贯性的交流体验数据显示过去两年间针对AI Agent的研究投入增幅达300%大模型市场玩家正纷纷投入这一领域。
我相信，在这个大趋势的情况下，未来的Agent AI一定会真正意义的实现超进化
Agent AI 智能体如何实现超进化呢？其实主要是通过机器学习和深度学习等技术实现自我优化和知识积累主要有以下几个方面：
一、数据收集与预处理
大量数据：智能体需要获取丰富的数据，包括各种场景下的信息。数据清洗：对数据进行清理和预处理，确保数据的质量和准确性。 二、模型训练
机器学习算法：利用各种机器学习算法，如监督学习、无监督学习等，对数据进行训练。深度学习网络：构建深度神经网络，如卷积神经网络、循环神经网络等，来学习数据中的模式和规律。 三、自我优化
参数调整：根据训练结果，不断调整模型的参数，以提高性能。超参数优化：通过试验和调整超参数，找到最优的模型配置。 四、知识积累
特征学习：从数据中自动学习到有意义的特征，这些特征可以作为知识的一部分。模型记忆：模型在训练过程中会逐渐记住一些模式和经验，形成知识积累。 五、反馈机制
实时反馈：智能体在执行任务过程中，根据环境的反馈不断调整自己的行为和策略。错误修正：通过反馈发现错误和不足，进一步优化和改进模型。 六、持续学习
增量学习：可以不断接收新的数据，进行增量学习，更新和扩展自己的知识。迁移学习：利用已有的知识和模型，在新的任务和领域中进行快速适应和优化。 通过以上这些方式，Agent AI 智能体能够不断地进行自我优化和知识积累，提高自己的能力和表现，更好地适应各种复杂的任务和环境。
👔三.无处不在的AI 在当今时代，AI 已经渗透到各个行业中，其影响日益显著。不同行业对 Agent AI 智能体的依赖程度也有所不同。
1. 制造业：
制造业对 Agent AI 智能体的依赖程度较高。智能体可以优化生产流程、提高生产效率、进行质量检测等，减少对人力的需求，但同时也会创造一些新的高技能岗位，如智能系统维护和开发人员。
2. 医疗保健：
医疗领域对智能体的需求不断增加。它们可以辅助诊断、药物研发、医疗影像分析等，然而医疗专业人员的角色仍然不可替代，可能会更注重与智能技术的协作。
3. 金融服务：
Agent AI 智能体在风险评估、交易分析、客户服务等方面发挥重要作用，可能导致一些重复性工作岗位的减少，但也会催生新的金融科技专业人才需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d37349af97b414dd27a48fc0602ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28aebd00da53e4eea91edffb4e888231/" rel="bookmark">
			【服务治理中间件】consul介绍和基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、CAP定理
二、服务注册中心产品比较
三、Consul概述
3.1 什么是Consul
3.2 Consul架构
3.3 Consul的使用场景
3.4 Consul健康检查
四、部署consul集群
4.1 服务器部署规划
4.2 下载解压
4.3 启动consul
五、服务注册到consul
一、CAP定理 CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得。
一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。 CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足。因此在进行分布式架构设计时，必须做出取舍。
二、服务注册中心产品比较 服务注册中心主流产品如下：
Zookeeper和Consul保证的是CP，而Eureka则是AP，Nacos不仅支持CP也支持AP。
当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s， 且选举期间整个Zookeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得Zookeeper集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。
所以Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：
Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)当网络稳定时，当前实例新的注册信息会被同步到其它节点中 因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。
三、Consul概述 3.1 什么是Consul Consul是一个服务网格解决方案，提供了一个功能齐全的控制平面，具有服务发现、配置和分段功能。这些功能中的每一项都可以根据需要单独使用，也可以一起使用来构建一个完整的服务网格。Consul需要一个数据平面，并支持代理和原生集成模型。Consul提供了一个简单的内置代理，因此一切都可以开箱即用，但也支持第三方代理集成，如Envoy。
Consul的主要功能有:
服务发现 : Consul的客户端可以注册一个服务，比如api或mysql，其他客户端可以使用Consul来发现特定服务的提供者。使用DNS或HTTP，应用程序可以很容易地找到他们所依赖的服务。健康检查 : Consul客户端可以提供任何数量的健康检查，要么与给定的服务相关联（如： "webserver是否返回200 OK"），要么与本地节点相关联（如： "内存利用率是否低于90%"）。这些信息提供给运维人员用来监控集群的健康状况，并被服务发现组件来路由流量（比如： 仅路由到健康节点）KV存储 ： 应用程序可以利用Consul的层级K/V存储来实现任何目的，包括动态配置、功能标记、协调、领导者选举等。Consul提供了HTTP API，使其非常简单以用。安全服务通信：Consul可以为服务生成和分发TLS（ 传输层安全性协议）证书，以建立相互的TLS连接。可以使用Intention来定义哪些服务被允许进行通信。服务隔离可以通过可以实时更改Intention策略轻松管理，而不是使用复杂的网络拓扑结构和静态防火墙规则。多数据中心:Consul支持开箱即用的多数据中心。这意味着Consul的用户不必担心建立额外的抽象层来发展到多个区域。 Consul的设计对DevOps社区和应用开发人员都很友好，使其成为现代弹性基础架构的完美选择。
3.2 Consul架构 Consul是一个分布式、高可用的系统。每个为Consul提供服务的节点都会运行一个Consul Agent。运行代理不需要发现其他服务或获取/设置密钥/值数据。Agent负责对节点上的服务以及节点本身进行健康检查。
Consul Agent 分为两种模式， Server 和 Client模式，一般我们得部署模型是 Server + Client的模式（当然也可以纯Server）, Server 具有Client的全部功能， 但是由于Server负责存储数据，并且强一致性模型的缘故， Server数是有限的（3-5个Server节点，Client可以无限扩展的）更多信息可参考架构概述。 Agent与一个或多个Consul Server对话。Consul Server是存储和复制数据的地方。Server本身会选出一个Leader。虽然Consul可以用一台Server来运作，但建议使用3到5台，以避免故障情况导致数据丢失。建议每个数据中心采用Consul服务器集群。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28aebd00da53e4eea91edffb4e888231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eeca48ee535050b45e206ccdb709888/" rel="bookmark">
			全面解析：Spring Gateway如何优雅处理微服务的路由转发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Gateway简介 Spring Gateway，这是一个基于Spring 5、Spring Boot 2和Project Reactor的API网关。它旨在为微服务架构提供一个简单、有效的统一的API路由、限流、熔断等功能。在微服务的世界里，Spring Gateway就像一个交通警察，负责指挥和引导各个微服务之间的交通。
相较于其他的网关技术，比如Nginx、Zuul等，Spring Gateway有着它独特的优势。它是全异步非阻塞的，对于高并发场景有着更好的表现。而且，它基于Spring Boot 2，集成起来非常简单，使用起来也很方便。当然，没有最好的，只有最适合的。在选择网关技术的时候，我们还需要根据自己的业务场景和技术栈来做出选择。
在这个基础上，我们将进一步深入探讨Spring Gateway的路由转发机制，让我们更深入地理解这个优秀的API网关。
Spring Gateway的路由转发机制 在对Spring Gateway的基本概念和主要功能有了一定的了解后，我们将深入探讨其路由转发机制。路由转发，简单来说，就是Spring Gateway如何将传入的HTTP请求转发到正确的服务。这一过程的核心在于路由配置。
首先，我们需要了解如何定义路由。在Spring Gateway中，路由是由ID、目标URI、一系列的谓词和过滤器组成。ID是路由的唯一标识，目标URI指明了请求转发的目标地址。谓词和过滤器则是用来描述路由的行为。
谓词是用来匹配HTTP请求的，只有满足谓词条件的请求才会被路由转发。过滤器则可以在请求被转发前后对请求进行修改。通过配置不同的谓词和过滤器，我们可以灵活地控制路由的行为。
然后，我们将进一步解析Spring Gateway如何处理传入的HTTP请求，以及如何将它们转发到正确的服务。当一个HTTP请求到达Spring Gateway时，它会遍历所有的路由定义，找到满足谓词条件的路由，然后通过过滤器链对请求进行处理，最后将处理后的请求转发到目标URI。
在这个过程中，我们可以清晰地看到Spring Gateway的工作原理。通过解析这一机制，我们可以更好地理解Spring Gateway的强大之处，以及如何利用它来满足我们的业务需求。
在理解了路由转发机制的基本原理后，我们将进一步通过实例来演示如何使用Spring Gateway进行路由转发。这将帮助读者更直观地理解Spring Gateway的路由转发机制，并学习如何在实际项目中应用。
实践：使用Spring Gateway进行路由转发 在理论的讲解之后，我们来到了实践的环节，将通过一个实际的示例来演示如何使用Spring Gateway进行路由转发。想象一下，我们现在有两个微服务，一个是用户服务，另一个是订单服务。它们分别运行在localhost:8081和localhost:8082上。我们的目标是，通过Spring Gateway，让用户可以直接访问localhost:8080/user和localhost:8080/order，而无需知道实际的服务地址。
首先，我们需要在Spring Gateway的配置文件application.yml中定义路由规则。下面是一个简单的示例：
spring: cloud: gateway: routes: - id: user_route uri: http://localhost:8081 predicates: - Path=/user/** - id: order_route uri: http://localhost:8082 predicates: - Path=/order/** 在这个配置中，我们定义了两个路由规则。每个规则都有一个唯一的id，一个目标uri，以及一组路由谓词。路由谓词是用来匹配请求的，只有满足所有谓词的请求才会被路由到对应的uri。在这个例子中，我们使用了Path谓词，它会匹配请求路径。所以，当用户访问localhost:8080/user时，请求会被路由到localhost:8081；访问localhost:8080/order时，请求会被路由到localhost:8082。
这就是Spring Gateway的基本路由转发机制。通过这个机制，我们可以灵活地管理微服务的路由，而无需修改服务本身。
总结 我们详细地介绍了Spring Gateway，这个基于Spring 5、Spring Boot 2和Project Reactor的API网关。我们首先了解了它的基本概念和主要功能，然后深入探讨了它的路由转发机制。我们了解了如何定义路由，以及Spring Gateway如何处理传入的HTTP请求，并将它们转发到正确的服务。最后，我们通过一个实际的示例演示了如何使用Spring Gateway进行路由转发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eeca48ee535050b45e206ccdb709888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72df2fa09e02ad932e1a1c07b5b01a48/" rel="bookmark">
			2024年最全基于Curator检测zookeeper分布式集群节点状态变化，2024年最新面试高频考点素材
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习福利 【Android 详细知识点思维脑图（技能树）】
其实Android开发的知识点就那么多，面试问来问去还是那么点东西。所以面试没有其他的诀窍，只看你对这些知识点准备的充分程度。so，出去面试时先看看自己复习到了哪个阶段就好。
虽然 Android 没有前几年火热了，已经过去了会四大组件就能找到高薪职位的时代了。这只能说明 Android 中级以下的岗位饱和了，现在高级工程师还是比较缺少的，很多高级职位给的薪资真的特别高（钱多也不一定能找到合适的），所以努力让自己成为高级工程师才是最重要的。
这里附上上述的面试题相关的几十套字节跳动，京东，小米，腾讯、头条、阿里、美团等公司19年的面试题。把技术点整理成了视频和PDF（实际上比预期多花了不少精力），包含知识脉络 + 诸多细节。
由于篇幅有限，这里以图片的形式给大家展示一小部分。
网上学习 Android的资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。希望这份系统化的技术体系对大家有一个方向参考。
网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化学习资料的朋友，可以戳这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
org.apache.curator
curator-framework
4.2.0
org.apache.logging.log4j
log4j-core
2.12.1
添加好依赖后，就可以基于Curator检测zookeeper节点在分布式环境中的状态。
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.WatchedEvent;
public class Main {
public static void main(String[] args) {
//初始化log4j，zookeeper否则报错。
org.apache.log4j.BasicConfigurator.configure();
try {
Main m = new Main();
} catch (Exception e) {
e.printStackTrace();
}
}
public Main() throws Exception {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72df2fa09e02ad932e1a1c07b5b01a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558b169f7de7a8f041a508d9f3b9e49a/" rel="bookmark">
			【已解决】java.sql.SQLException: Access denied for user ‘root‘@‘localhost‘ (using password: YES)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.sql.SQLException: Access denied for user 'root'@'localhost' (using password: YES)* 这个异常通常意味着你尝试使用 root 用户和某个密码去连接 MySQL 数据库时，MySQL 服务器拒绝了你的连接请求。这通常是由以下几个原因引起的：
**密码错误：**你提供的密码不正确。请检查你的密码是否正确，并确保你没有在密码中不小心包含了额外的空格或字符。
** 博主就是因为不小心在application.yml配置文件中，不小心把密码输入错误了，这是个可以避免的问题！！！
**
=
用户权限问题：虽然你使用的是 root 用户，但这个用户可能没有被授权从 localhost 登录。这听起来不太可能，因为 root 用户通常默认就有这样的权限，但如果你之前修改了权限，那就可能发生了这种情况。
MySQL 用户表损坏：MySQL 的用户权限表（如 mysql.user）可能已损坏或不一致。
MySQL 服务器配置：my.cnf 或 my.ini（取决于你的操作系统和安装方式）中的某些设置可能阻止了 root 用户的登录。
MySQL 用户账号限制：在某些情况下，root 用户可能被限制只能从特定的主机或 IP 地址登录。
防火墙或安全组设置：如果你使用的是云服务或防火墙，可能存在阻止连接的安全组规则或防火墙规则。
要解决这个问题，你可以尝试以下步骤：
确认你的密码是否正确。
尝试以 root 用户身份直接登录 MySQL 服务器（使用命令行工具如 mysql -u root -p），看看是否可以成功登录。
检查 MySQL 的用户权限表，确保 root 用户有从 localhost 登录的权限。
检查 MySQL 服务器的配置文件（my.cnf 或 my.ini），看是否有任何相关的限制或设置。
如果你在云服务器上运行 MySQL，检查安全组或防火墙规则，确保它们允许从你的应用程序所在的主机到 MySQL 服务器的连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/558b169f7de7a8f041a508d9f3b9e49a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c0ae7c7fc299acc04ad27a1448e957/" rel="bookmark">
			Watchdog，一双专为 Python 而生的守护者之眼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好！我是爱摸鱼的小鸿，关注我，收看每期的编程干货。
一个简单的库，也许能够开启我们的智慧之门，
一个普通的方法，也许能在危急时刻挽救我们于水深火热，
一个新颖的思维方式，也许能激发我们无尽的创造力，
一个独特的技巧，也许能成为我们的隐形盾牌……
神奇的 Python 库之旅，第 3 章
目录 一、神秘的 Watchdog二、Watchdog 应用场景三、总结四、作者Info 一、神秘的 Watchdog 在程序员的世界里，有一种神奇的力量，它能够守护着我们的代码，保障程序的正常运行。
这个力量就是 Python 第三方库 Watchdog。今天，让我们一起揭开这位守护者的神秘面纱，探索它的奥秘与魅力。
Watchdog 是 Python 中一个用于监视文件系统变化的库，它能够监控文件或目录的变化，并在变化发生时触发相应的事件，比如文件的创建、修改、删除等。
简单来说，就像是给你的文件系统装上了一双“守护者之眼”，时刻关注着文件的一举一动。
安装 Watchdog
pip install watchdog -i https://pypi.doubanio.com/simple 这里使用国内豆瓣镜像源安装会更快。
Github 项目地址
https://github.com/gorakhargosh/watchdog
二、Watchdog 应用场景 那么，我们如何与这位守护者相遇呢？别着急，接下来我将为大家介绍几个与 Watchdog 相遇的奇妙场景。
场景一：文件同步
小明是一名程序员，他经常需要在不同的机器之间同步文件。以前，他总是需要手动复制、粘贴文件，非常麻烦。但自从他遇到了 Watchdog，一切都变得不一样了。
他写了一个简单的 Python 脚本，使用 Watchdog 监控源文件夹的变化，一旦有文件被修改，就立即同步到目标文件夹。于是，小明再也不用担心文件同步的问题了，一切都变得轻松自如。
import time from watchdog.observers import Observer from watchdog.events import FileSystemEventHandler class MyHandler(FileSystemEventHandler): def on_modified(self, event): # 文件被修改时触发 print(f'{event.src_path} has been modified') if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05c0ae7c7fc299acc04ad27a1448e957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6539fca327cf5a5620c725cd507aebd8/" rel="bookmark">
			【C 数据结构-图】3. 深度优先搜索、广度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【 1. DFS 深度优先搜索 】1.1 基本原理1.2 C 实现 【 2. BFS 广度优先搜索 】2.1 基本原理2.2 C 实现 【 3. 深度优先生成树、广度优先生成树 】【 4. 深度优先生成森林、广度优先生成森林 】4.1 深度优先生成森林4.2 广度优先生成森林 对存储的图中的顶点进行遍历搜索，常用的遍历方式有两种：深度优先搜索和广度优先搜索。 【 1. DFS 深度优先搜索 】 1.1 基本原理 深度优先搜索的过程 类似于树的先序遍历，首先从例子中体会深度优先搜索。例如下图是一个无向图，采用深度优先算法遍历这个图的过程为： 首先任意找一个未被遍历过的顶点，例如从 V1 开始，由于 V1 率先访问过了，所以，需要标记 V1 的状态为访问过；然后遍历 V1 的邻接点，例如访问 V2 ，并做标记，然后访问 V2 的邻接点，例如 V4 （做标记），然后 V8 ，然后 V5 ；当继续遍历 V5 的邻接点时，根据之前做的标记显示，所有V5 的邻接点都被访问过了。此时，从 V5 回退到 V8 ，看 V8 是否有未被访问过的邻接点，如果没有，继续回退到 V4 ， V2 ，V1 ；通过查看 V1 ，找到一个未被访问过的顶点 V3 ，继续遍历，然后访问 V3 邻接点 V6 ，然后 V7 ；由于 V7 没有未被访问的邻接点，所以回退到 V6 ，继续回退至 V3 ，最后到达 V1 ，发现没有未被访问的；最后一步需要判断是否所有顶点都被访问，如果还有没被访问的，以未被访问的顶点为第一个顶点，继续依照上边的方式进行遍历。根据上边的过程，可以得到下图通过深度优先搜索获得的顶点的遍历次序为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6539fca327cf5a5620c725cd507aebd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eb6921b43c5815f4f080da517fb27d1/" rel="bookmark">
			大学本科生论文需要查aigc吗？哪个平台AI率更高呢！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是必须要查的， 无论你是否使用了ai辅写都需要做aigc检测。
原因很简单，aigc检测的是疑似率。就算是完完整整自己完成的也避免不了会出现aigc疑似语句，要是你的写作风格与众多ai的其中一个相似都会被判定为疑似aigc生成语句。
aigc疑似率的检测不像论文重复率检测那么昂贵，便宜到只有一杯奶茶钱。
但疑似率过高，或超过了学校要求的指标，导致的后果却和重复率过高的严重度一样。都会影响毕业甚至撤销学位证书！！
市场上很多aigc检测平台， 那我们要怎么去看自己的aigc检测报告？
知网，维普，master检测出来的结果，哪一个ai率更高呢？
怎么看知网aigc报告？最重要的就是查看aigc值！ 高度疑似：AIGC值在0.9到1之间，表示文本极有可能是由AI生成的。这种情况下，你的论文可能已经被人工智能“占领”。中度疑似：AIGC值在0.7到0.9之间，表示文本有中等程度的可能性是由AI生成的。这种情况下，你的论文可能部分被人工智能“侵蚀”。轻度疑似：AIGC值在0.5到0.7之间，表示文本有较低的可能性是由AI生成的。这种情况下，你的论文可能轻微被人工智能“触碰”。 怎么看维普的aigc报告？直接看aigc疑似概率 片段切割后检测疑似程度70%到80%就算轻度疑似
片段切割后检测疑似程度80%到90%就算中度疑似
片段切割后检测疑似程度90%到100%就算重度疑似
怎么看masterAIGC的报告？主要看ai比例分布 这个aigc检测平台直接将检测内容分为：
1.AI写作
2.疑似AI写作
3.人写作
并在内容部分显示出aigc值，这一点与知网报告比较相识。
从aigc检测结果分析 master检测的结果（78.35%）和维普检测的结果（78.34%）非常接近，而且高于知网的aigc检测结果（42.4%）！！
每个平台检测的结果不一致是属于正常情况，原因是每个平台都有一套自己的算法，如果对于自己的论文非常负责建议每个平台检测一遍，完全避免aigc疑似。
所以维普和master的检测算法更加严格，知网的检测算法相对宽松一些，但随着时间的推移我相信往后各平台会越来越严格，对于ai生成的内容能够更准确的识别出来。
从aigc检测平台收费标准分析 知网：2元/千字
维普: 20元/每篇
master：20元/每篇
如果不考虑学校要求指定平台进行aigc检测，单从价格来分析：
字数少于10000字，使用知网比较划算。字数高于10000使用master或维普更加划算。
疑似AIGC现在还没有固定标准，只能说是越低越好。一般高校要求的是百分之20以下。
master ai检测地址：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcae359c2e02903ae095f20206ddd6b6/" rel="bookmark">
			智慧之巅：大数据与算力中心的融合演进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智慧之巅：大数据与算力中心的融合演进 1 引言 在这个数据驱动的时代，我们站在了一个前所未有的历史节点上。大数据和算力中心，这两个曾经各自为政的领域，如今正以一种前所未有的方式交织在一起，共同推动着数字经济的蓬勃发展。本章节将带领读者走进这个充满智慧与创新的领域，探索大数据与算力中心如何成为当今数字经济的两大支柱。
1.1 大数据与算力中心的核心地位 想象一下，我们的世界正被数据的海洋所包围。从社交媒体的每一次互动，到电子商务的每笔交易，再到智能设备的每一次感应，数据正以前所未有的速度增长，其规模已经从TB级跃升至ZB级。在这个过程中，大数据不仅仅是量的积累，更是质的飞跃，它蕴含着洞察市场、优化运营、创新服务的无限可能。
而算力中心，作为支撑这一切的“大脑”，其重要性不言而喻。它们是数据处理、分析和存储的中心，是实现数据价值的关键。随着技术的不断进步，算力中心正变得更加高效、智能，它们不仅能够处理海量数据，还能够提供实时分析，为决策提供即时支持。
1.2 技术发展对社会经济结构的影响 技术的每一次飞跃，都在重塑着我们的社会经济结构。大数据和算力中心的发展，不仅改变了企业的运营模式，也深刻影响了我们的生活方式。例如，通过大数据分析，零售商能够精准预测消费者需求，实现个性化推荐；医疗机构能够利用大数据进行疾病预测和精准治疗；城市管理者能够通过数据分析优化交通流量，提升城市运行效率。
在这个过程中，算力中心的作用不可小觑。它们不仅提供了强大的计算能力，还通过分布式计算、边缘计算等技术，使得数据处理更加高效，响应更加迅速。这种技术的融合，正在推动着商业模式的创新，促进了新业态的诞生。
总之，大数据和算力中心的发展，正如同两股强大的潮流，汇聚成推动数字经济发展的巨大动力。在接下来的章节中，我们将深入探讨这两个领域的技术演进、融合趋势以及它们对未来世界的深远影响。让我们一起，探索这个充满无限可能的智慧之巅。
2 大数据技术的演进 2.1 数据量的爆炸性增长 在过去的十年中，我们见证了数据量的指数级增长，从传统的TB（太字节）级别迅速跨越至PB（拍字节）和ZB（泽字节）级别。这种数据量的爆炸性增长主要得益于智能设备的普及、社交媒体的流行、业务自动化和物联网（IoT）的扩展等多个因素。
例如，据统计，一个普通的互联网用户每天通过各种在线活动生成约1.5GB的数据。而在全球范围内，每分钟大约有500小时的视频被上传至YouTube，超过200万条内容被分享至Facebook，这些行为产生的数据量是巨大的。
这种数据的海量增长带来了若干挑战，其中最显著的是如何高效地存储、处理和分析这些数据。传统的数据处理技术，如关系数据库管理系统（RDBMS），在处理TB级或更高级别的数据时面临性能瓶颈。这促使了新技术的诞生，比如NoSQL数据库、大数据处理框架如Apache Hadoop和Apache Spark。
此外，这种大规模的数据增长也推动了数据中心的发展，尤其是在网络基础设施和存储解决方案方面。为了应对这种增长，数据中心不得不采用更高效的数据压缩算法和更先进的硬件设备，比如使用固态驱动器（SSD）来提高数据读写速度。
总之，数据量的爆炸性增长不仅改变了数据存储和管理的方式，也为大数据分析、人工智能和机器学习等领域的应用提供了前所未有的机会和挑战。
2.2 数据处理技术的革新 在数据量爆炸性增长的背景下，传统的数据处理技术已无法满足日益增长的数据处理需求。因此，数据处理技术经历了一场深刻的革新，从批处理到流处理，再到实时分析技术的发展，每一次跃迁都是对数据处理能力的极大提升。
从批处理到流处理 批处理技术，如Apache Hadoop的MapReduce，曾是处理大规模数据集的主力。它将数据分成块，分发到集群中的多个节点进行并行处理，然后将结果合并。然而，批处理的缺点在于其处理延迟较高，不适用于需要即时反馈的场景。
随着技术的发展，流处理技术应运而生。Apache Storm、Apache Flink和Apache Kafka Streams等框架允许数据在产生时即被处理，无需等待数据积累到一定量。这种技术适用于实时监控、实时分析和实时决策等场景。例如，在金融交易系统中，流处理技术可以实时分析交易数据，即时发现异常交易行为，从而有效防范金融风险。
实时分析技术的发展 实时分析技术是流处理技术的延伸，它不仅要求数据处理的实时性，还要求分析结果的即时可用性。Apache Druid、ClickHouse等实时分析数据库的出现，使得企业能够在毫秒级别获得复杂查询的结果。这些技术在广告技术、网络分析和用户行为分析等领域发挥着重要作用。例如，在电子商务平台中，实时分析技术可以帮助企业实时了解用户行为，即时调整营销策略，提高转化率。
举例说明 以社交媒体平台为例，用户每时每刻都在产生大量的数据，包括文本、图片、视频等。传统的批处理技术无法满足对这些数据的即时分析需求。而流处理和实时分析技术的结合，使得平台能够实时监控用户行为，即时响应热点事件，甚至预测趋势。例如，当某个话题突然成为热点时，平台可以迅速调整算法，推送相关内容，增加用户参与度。
小结 数据处理技术的革新是大数据技术演进的关键环节。从批处理到流处理，再到实时分析技术的发展，每一次技术的跃迁都极大地提高了数据处理的效率和实时性，为各行各业带来了前所未有的机遇。随着技术的不断进步，我们有理由相信，未来的数据处理技术将更加智能、高效，更好地服务于人类社会的发展。
2.3 数据存储与管理：分布式存储、云计算与数据湖的融合之旅 在数字化的浪潮中，数据如同汹涌的海洋，不断涌动，不断扩张。面对这股洪流，数据存储与管理技术如同坚固的堤坝，必须不断加固，以确保数据的稳定与安全。本节将深入探讨分布式存储、云计算和数据湖等技术的发展，以及它们如何成为大数据存储与管理的坚实基石。
分布式存储：构建数据之网的基石 分布式存储技术，如同一张巨大的蜘蛛网，将数据分散存储在多个节点上，每个节点既独立又相互连接。这种架构不仅提高了数据的可靠性和访问速度，还增强了系统的扩展性。以Apache Hadoop的HDFS（Hadoop Distributed File System）为例，它通过将大文件分割成块（block），并将这些块复制到不同的数据节点上，实现了数据的高可用性和容错性。在金融领域，分布式存储技术被用于存储海量的交易记录，确保数据的完整性和快速检索。
云计算：数据存储的云端革命 云计算的出现，如同给数据存储插上了翅膀，使得数据可以在云端自由翱翔。云服务提供商如Amazon Web Services（AWS）、Microsoft Azure和Google Cloud Platform（GCP）提供了弹性、可扩展的存储解决方案，如S3、Blob Storage和Cloud Storage。这些服务允许用户根据需求动态调整存储资源，大大降低了企业的IT成本。例如，一家初创公司可以通过云存储服务快速搭建起数据存储平台，而无需投入大量资金购买硬件设备。
数据湖：汇聚数据之海的智慧港湾 数据湖，这个概念如同一个巨大的水库，可以容纳各种类型、各种格式的原始数据。与传统数据库不同，数据湖不要求数据在存储前进行严格的结构化处理，这使得它能够灵活地适应数据多样性的挑战。Apache Hadoop生态系统中的Hadoop HBase和Apache Hive，以及Amazon的S3和Glue，都是构建数据湖的优秀工具。在医疗健康领域，数据湖技术被用于整合患者的电子病历、医学影像和基因组数据，为精准医疗提供了强大的数据支持。
小结 数据存储与管理技术的进步将大数据的潜能转化为现实的力量。分布式存储、云计算和数据湖等技术的融合，不仅为数据的存储提供了坚实的保障，更为数据的分析和应用开辟了无限的可能。随着技术的不断演进，我们有理由相信，未来的数据存储与管理将更加智能、高效，更好地服务于人类社会的发展。
2.4 数据安全和隐私保护 在数字化的浪潮中，大数据的海洋里蕴藏着无尽的宝藏，但同时也潜藏着暗礁——数据安全和隐私保护。随着数据量的激增和数据价值的提升，保护数据不被非法访问、篡改或泄露，已成为大数据技术发展中不可或缺的一环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcae359c2e02903ae095f20206ddd6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f916c6286382f87ddb3a6b3f881513dc/" rel="bookmark">
			【模拟&#43;数学】LeetCode.258：各位相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎁个人主页：我们的五年
🔍系列专栏：每日一练
🌷追光的人，终会万丈光芒
前言：
【LeetCode】真的是一个好网站呀，上面的题目的太经典了，提供的方法也很很多，非常值得推荐。
下面给大家带来一道经典题。
各位相加：
【LeetCode】链接：258. 各位相加 - 力扣（LeetCode）
🏝问题描述： 问题：
给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。
示例 1:
输入: num = 38 输出: 2 解释: 各位相加的过程为： 38 --&gt; 3 + 8 --&gt; 11 11 --&gt; 1 + 1 --&gt; 2 由于2是一位数，所以返回 2。 示例 2:
输入: num = 0 输出: 0 进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？
🏝解法一（模拟）： 第一步就是把每一个位数的数字相加，得到一个新的数，然后再把每一位的数相加，再得到一个新的数，最后等这个数小于10为止。
实现代码：
int addDigits(int num) {
while(num&gt;=10)
{
int sum=0;
while(num)
{
sum+=num%10;
num/=10;
}
num=sum;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f916c6286382f87ddb3a6b3f881513dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a176829a394295007787fb2ec7e816a4/" rel="bookmark">
			【c&#43;&#43;算法篇】双指针（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页：Quitecoder
🔥专栏：算法笔记仓
朋友们大家好啊，本篇文章我们来到算法的双指针的第二部分
目录 `1.有效三角形的个数``2.查找总价格为目标值的两个商品``3.三数之和``4.四数之和`5.双指针常见场景总结 1.有效三角形的个数 题目链接：611. 有效三角形的个数
题目描述：
这道题当然可以暴力求解，三层循环枚举所有情况，来进行判断，但是可以进行优化：
我们知道，三角形的满足条件是任意的两边之和大于第三边，但是如果我们已经判断了较小的两个边大于第三边，就不需要再进行剩下两组的判断，所以我们先进行排序，再进行枚举：
class Solution { public: int triangleNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); } }; 具体讲解一下我们的思路：
这里使用的是一种双指针技术：固定最长的边（也就是数组中的最大值），使用两个指针来查找剩余部分中可能的两个较短边。如果找到了两个较短边的长度和大于最长边，那么这三者能构成一个三角形
class Solution { public: int triangleNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int count=0; for(int i=nums.size()-1;i&gt;=2;i--) { int lat=i-1,pre=0; while(pre&lt;lat) { if(nums[pre]+nums[lat]&gt;nums[i]) { count+=lat-pre; lat--; } else pre++; } } return count; } }; 它利用了一个重要的性质：如果你有三条边长分别为 a, b 和 c，且 a ≤ b ≤ c，那么 a, b 和 c 可以构成一个三角形当且仅当 a + b &gt; c
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a176829a394295007787fb2ec7e816a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4837d3b1958652c3cc7e8e2b226cae/" rel="bookmark">
			国内首篇！所有AI大模型一文概括！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		肝了将近三天的时间，终于完成了这篇“巨作”，也算圆了之前咱们一位终身VIP用户提出的的需求，主打就是宠用户。
关于这篇总结，我可以毫不夸张的说，绝对算得上市面第一篇把所有大模型说明白的内容。
我凭什么敢这么说？
是因为我是真的花时间去搜了，一篇能看都没有！
最有意思的是，这排名第一的热度总结是还是一位宠物博主为智谱写的软广。
好了，废话不多说，是骡子是马得拉出来溜溜才知道。
接下来正式进入正文。
进入正文
国内国外各大模型都有什么区别？
咱们先来看看国内的。
目前国内较为知名的AI大模型主要有10家，如图：
阶跃星辰
零一万物
月之暗面
清华智谱
百川智能
360智脑
通义干问
讯飞星火
文心一言
腾讯混元
为了方便大伙对国内大模型的优势能有个直观上的了解，我把它们汇总成了表格，如下：
在这图中有细心的伙伴会发现咱们的IMYAI竟然也在其中。
没错，为了向伙伴们提供更加便捷和高效的模型工具，IMYAI依托GPT系列技术开发了一款专注于联网搜索的模型。
该模型搭载了联网插件，能够实时获取网络信息，唯独一点，它不具备上下文记忆功能。
接下来介绍一下国外的主流语言模型，除了众所周知的GPT系列和 Claude系列之外，还有几款不错的AI模型，如下:
GPT系列
Claude系列
Google系列
Llama系列
看到这里不熟悉的伙伴估计会好奇，网站内code-llama 、llama-2和llama-3这些模型是干嘛用的，擅长什么?
还是那句话，答案都在下面图中。
以上就是国内外主流的AI大模型一览表，接下来我们一起看看各大语言模型的测试效果怎样。
各大语言模型测试
去年GPT4刚出来的时候，国内各个模型为了增加曝光度也开始进行不同程度的炒作。
为了鉴别真伪，探究周树人与鲁迅之间的关系已成为评估大型语言模型智慧水平的经典测试。
用户可通过模型对这一问题的回答准确性，来初步判断其智能水平的高低。
下面，借用我们IMYAI平台为基础一起看看各大模型针对这个问题的处理能力。
- ChatGPT系列 -
GPT3.5所有模型
GPT4.0所有模型
- Claude-3系列系列 -
Claude-3-haiku
Claude-3-sonnet
Claude-3-opus
- 谷歌系列 -
谷歌Google-palm
谷歌Gemini-pro
- 清华智谱系列 -
清华智谱-glm-3
清华智谱-glm-4
- 百度文心系列 -
百度文心-ERNIE-Bot
百度文心-ERNIE-Bot-turbo
百度文心-ERNIE-Bot-4
- 阿里通义千问系列 -
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e4837d3b1958652c3cc7e8e2b226cae/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/377/">«</a>
	<span class="pagination__item pagination__item--current">378/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/379/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>