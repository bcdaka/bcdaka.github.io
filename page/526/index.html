<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ae2390c0b7032fd69011c0b14ba6f9/" rel="bookmark">
			2024Java零基础自学路线（Java基础、Java高并发、MySQL、Spring、Redis、设计模式、Spring Cloud）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Java基础1、Java 基础3、Java8新特性4、Java集合5、Java高并发6、Java代码实例 二、MySQL数据库三、Spring Boot框架（35天）四、微服务Spring Cloud四、Redis中间件五、MongoDB数据库六、Netty网络编程七、23种设计模式八、Dubbo九、JavaScript零基础入门十、Vue基础知识十一、数据结构与算法 大家好，我是哪吒。
现在网上的学习资料铺天盖地，很多小伙伴不知道如何选择。
今天，我来分享一下我自己的学习路线和学习方法。
我跌倒的坑，希望大家一脚就能跨过去。
Java技术栈的东西还是非常多的，下面分享一下学习大纲。
2023最新最全的Java学习路线总结，从入门到就业（大概六个月）；给出目标、学习建议、关键知识点、最优资源以及各类资源推荐；按学习的先后顺序，分阶段，有时间规划的持续学习。 一、Java基础 所谓基础不牢，地动山摇。有一个好的基础，才是Java学习的关键。
前期准备
开发环境：jdk1.8开发工具：IDEA，不建议使用eclipse 1、Java 基础 Java学习路线总结（思维导图篇）
【Java基础知识 1】编程语言类型有哪些？我心中的TOP1编程语言，什么是java跨平台性？
【Java基础知识 2】配置java环境变量
【Java基础知识 3】为何要配置环境变量？
【Java基础知识 4】秒懂数组拷贝，感知新境界
【Java基础知识 5】装箱和拆箱
【Java基础知识 6】Java异常有哪几种
【Java基础知识 7】Java面向对象简介
【Java基础知识 8】Java 基本数据类型
【Java基础知识 9】java运算符简介
【Java基础知识 10】Java操作符有哪些？
【Java基础知识 11】Java控制台输入输出语句
【Java基础知识 12】Java对象、类、抽象类、构造函数
【Java基础知识 13】JDK 和 JRE 、final 与 static 、堆和栈
【Java基础知识 14】java final关键字
【Java基础知识 15】Java控制流程语句
【Java基础知识 16】禁止使用Lombok，在Lombok的加持下，“小狗”.equals(“老狗”) = true
【Java基础知识 17】Java继承和多态
【Java基础知识 18】java接口和抽象类的异同，default关键字
【Java基础知识 19】Java接口的作用和意义
【Java基础知识 20】Java初始化、构造器、对象创建的过程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38ae2390c0b7032fd69011c0b14ba6f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51fad024b5de42011eb7d08231be669/" rel="bookmark">
			Android Studio | 小白如何运行别人的安卓项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Step1：正确地打开项目
Step2：AS 同步时报错
Step3：同步完成后启动
Step4：启动成功
说明：本文简称 Android Studio 为 AS
Step1：正确地打开项目 重点：确认好项目的根目录是哪个目录！
别人以 ZIP 压缩包的形式把项目发给我们，我们把压缩包解压后得到项目文件夹。由于打成压缩包的时候往往会加一层目录，而这一层并不是项目的根目录，因此误使用它为根目录会导致 AS 识别项目结构失败。
点击 “Open”，选择项目的根目录进行打开：
如果打开后各个目录面如死灰，且 AS 没有任何提示，那么应该就是找错根目录了。
Step2：AS 同步时报错 正确打开项目后，AS 会自动进行同步。但是我在同步时遇到了以下错误：
Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin 'com.android.internal.application'. 首先，找到 gradle.properties 文件：
然后，在 gradle.properties 中添加一行：
android.overridePathCheck=true 最后，点击 “Try Again” 重新进行同步：
参考博客：org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin
Step3：同步完成后启动 同步成功后，项目结构会被 AS 整理，类似下图：
点击绿色三角启动项目，我这里是启动后的，所以长得不一样：
可能会遇到下述报错，即项目要求的 SDK 最小版本号比你 AVD 的版本高：
The application's minSdkVersion is newer than the device API level.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e51fad024b5de42011eb7d08231be669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f769be6552002314a5d95a7b68c76c7b/" rel="bookmark">
			IntelliJ IDEA 中轻松操作 Java 中的 try-catch 块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 IntelliJ IDEA 快捷键轻松操控 Java 中的 try-catch 块 1、前言 在 Java 开发中，异常处理是不可避免的一部分。为了提高编码效率，熟练使用 IntelliJ IDEA 的快捷键是极为重要的技能之一。本文将介绍如何使用 IntelliJ IDEA 的快捷键操作，轻松操控 Java 中的 try-catch 块，让你更便捷地处理异常情况。
2、基本操作 在编写代码时，我们常常需要处理可能抛出异常的代码段。在 IntelliJ IDEA 中，通过使用 Ctrl + Alt + T（Windows/Linux）或 Cmd + Alt + T（Mac），你可以轻松地生成基本的 try-catch 块。这一操作不仅能够减少冗余的手动输入，还能确保你在异常处理上的一致性。
3、演示案例 以Windows系统为例，选中代码，进行Ctrl + Alt + T 操作，选择异常模块即可，如下图3-1，3-2所示：
不选中对应的方法逻辑，会出现错误红色提示：
Couldn’t find Surround With variants applicable to the current context
如下图3-3所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704fac9bdb6c0814b77003466b1cd4fd/" rel="bookmark">
			使用jsPDF&#43;html2canvas导出PDF文件分页--可添加上下页边距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常规思路 想要将html页面通过pdf文件导出，一般我们使用html2canvas+jsPDDF导出。
单纯使用jsPDF的html()方法要求导入全部字体，于是转换思路，先转成canvas，在通过贴图，贴到pdf中，代码如下：
安装：
npm html2canvas npm jspdf 引入：
import html2canvas from 'html2canvas'; import jsPDF from 'jsPDF'; 具体代码：
// 生成pdf文件流 const elem =document.getElementById('reportContent'); const canvas = await html2canvas(elem!); //以下是分页 // pdf的尺寸 const pdfWidth = canvas.width; //a4页面尺寸高比宽为1.414 const pdfHeight = pdfWidth * 1.414; let pageHeight = canvas.height; let position: number = 0; //贴图的宽高 const imgWidth = canvas.width; const imgHeight = imgWidth / canvas.width * canvas.height; //将canvas标签转化为base64码 const pageData = canvas.toDataURL('image/jpeg', 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704fac9bdb6c0814b77003466b1cd4fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b8fd21bca4ce9cc0ee830c7dbf620fd/" rel="bookmark">
			Python NumPy数组利器 - np.zeros函数详解与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多资料获取 📚 个人网站：ipengtao.com
NumPy（Numerical Python）是Python中用于科学计算的一个重要库，它提供了高性能的多维数组对象以及用于处理这些数组的工具。本文将深入探讨NumPy库中的np.zeros函数，详细解释它的用法、参数以及如何在实际项目中应用它。将通过丰富的示例代码演示np.zeros函数的各种用途，从而帮助大家更好地理解和利用这一功能强大的工具。
np.zeros函数简介 np.zeros是NumPy库中的一个函数，用于创建一个指定形状（shape）和数据类型（dtype）的全零数组。
基本语法如下：
numpy.zeros(shape, dtype=float, order='C') shape：数组的形状，可以是一个整数或一个表示形状的元组。dtype：数组的数据类型，可选参数，默认为float64。order：数组元素在内存中的排列顺序，可选参数，可以是’C’（按行排列）或’F’（按列排列）。 创建全零数组 首先，来看一下如何使用np.zeros函数来创建全零数组。
假设想创建一个3x3的全零矩阵：
import numpy as np zeros_matrix = np.zeros((3, 3)) print(zeros_matrix) 这段代码将输出如下结果：
[[0. 0. 0.] [0. 0. 0.] [0. 0. 0.]] 如你所见，得到了一个3x3的全零矩阵，数据类型默认为浮点数（float64）。
指定数据类型 如果想要创建一个具有不同数据类型的全零数组，可以通过dtype参数来指定。
以下是一个创建整数类型数组的示例：
int_zeros = np.zeros((2, 2), dtype=int) print(int_zeros) 这将输出：
[[0 0] [0 0]] 通过设置dtype为int，创建了一个包含整数的全零数组。
控制内存布局顺序 np.zeros函数还可以控制内存中数组元素的排列顺序，可以选择按行排列（C风格）或按列排列（Fortran风格）。默认情况下，它是按行排列。
c_order_zeros = np.zeros((2, 2), order='C') f_order_zeros = np.zeros((2, 2), order='F') print("按行排列（C风格）：") print(c_order_zeros) print("按列排列（Fortran风格）：") print(f_order_zeros) 这将输出两个不同排列顺序的全零数组：
按行排列（C风格）： [[0. 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b8fd21bca4ce9cc0ee830c7dbf620fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ffbdd3874760a4b7a34b8f0c7f8cd60/" rel="bookmark">
			Java开发或调用WebService的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java开发或调用WebService的几种方式 文章目录 Java开发或调用WebService的几种方式一.JDK自带的 JAX-WS 方式开发WebService服务1.服务端开发与发布2.客户端开发与测试 二.Axis1.4调用.Net返回值为DataSet类型的WebService接口1.相关说明2. Axis1.4客户端WebService服务1.Axis1.4下载2.WebService服务接口地址及方法3.编写调用WebService服务的方法及数据解析 三. CXF 开发WebService接口1. jax-ws实现2. CXF-RESTFul服务实现 一.JDK自带的 JAX-WS 方式开发WebService服务 1.服务端开发与发布 编写接口 @WebService public interface JaxWsDemo { String helloJaxWS(String userName); } 编写接口的实现类 @WebService public class JaxWsDemoImpl implements JaxWsDemo { @WebMethod @WebResult(name = "jaxWSResult") @Override public String helloJaxWS(@WebParam(name = "userName")String userName) { return "hello," + userName + "This is a Web Service developed through JAX-WS"; } } 发布服务 public class JAXWSPublishMain { public static void main(String[] args) { String address = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ffbdd3874760a4b7a34b8f0c7f8cd60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5684fb2d12b69e1df21d3d68f8564346/" rel="bookmark">
			ChatGPT 和文心一言两大AI助手的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 背景 ChatGPT是由OpenAI开发的，它可以理解自己生成的内容，并根据输入的上下文进行推理和生成回复。这种自我理解的能力使得ChatGPT在处理复杂对话和问题时具有优势。 然而，ChatGPT的缺点是只能根据预先设定的规则和模板回复，这在一定程度上限制了其应用的灵活性。
相比之下，文心一言是由百度推出的，它在获取条件和功能体验两个方面都表现出色，被认为是国内AI超级模型。 文心一言的优点在于，它能够根据输入的上下文进行推理和生成回复，这使得它在处理复杂对话和问题时具有一定的优势。 此外，文心一言的应用场景已经足够应对至少50%的需求，这意味着它具有广泛的应用潜力。
总的来说，ChatGPT和文心一言都有各自的优点和缺点。ChatGPT在理解和生成复杂内容方面表现出色，但其回复能力受限于预先设定的规则和模板。相比之下，文心一言在获取条件和功能体验方面表现优秀，其应用场景广泛，但在某些复杂的对话和问题处理上可能不如ChatGPT。因此，选择哪种模型取决于具体的应用需求。
二 智能回复能力的比较 ChatGPT和文心一言的智能回复能力各有特点。ChatGPT是由一种大规模预训练模型，其强大的智能回复能力得益于其庞大的训练数据和先进的训练技术。无论是对于日常生活的普通问题，还是对于专业领域的深度问题，ChatGPT都能够给出准确、全面的回答。而且，ChatGPT可以理解自己生成的内容，并根据输入的上下文进行推理和生成回复。
相比之下，文心一言不能直接理解自己生成的内容，而是根据预先设定的规则和模板对输入的文本进行处理和生成回复。然而，文心一言在特定场景下的应用表现出色，例如在数字、代码、归纳和推理这些能力方面，有研究报告指出GPT4几乎把文心一言给完爆。同时，文心一言也在不断进步，特别是文心一言4.0出来之后，其能力提升了一大截。
三 语言准确性的比较 ChatGPT，它可以理解自己生成的内容，并根据输入的上下文进行推理和生成回复。这种自我理解的能力使得ChatGPT在处理复杂对话和问题时具有优势。然而，由于ChatGPT是基于大规模无监督数据训练的，其生成的回答可能存在一些错误或不准确的地方。此外，由于模型的训练数据主要来自于互联网，因此它可能无法很好地理解和处理某些特定领域的专业术语和知识。
相比之下，文心一言它在获取条件和功能体验两个方面都表现出色，被认为是国内AI超级模型。文心一言的优点在于，它能够根据输入的上下文进行推理和生成回复，这使得它在处理复杂对话和问题时具有一定的优势。然而，由于文心一言是基于有监督数据训练的，其生成的回答可能受到训练数据的局限性影响，对于一些新颖或未见过的问题可能无法给出准确的回答。
总的来说，ChatGPT和文心一言在语言准确性方面都有各自的优势和限制。ChatGPT在处理复杂对话和问题时具有优势，但其生成的回答可能存在一些错误或不准确的地方；而文心一言则能够根据输入的上下文进行推理和生成回复，但对于一些新颖或未见过的问题可能无法给出准确的回答。因此，选择哪种模型取决于具体的应用需求。
四 知识库丰富度的比较 ChatGPT，其训练数据主要来自于互联网上的大量文本数据，包括新闻、百科全书、小说等各种类型的文本。这使得ChatGPT具有广泛的知识覆盖范围，能够回答各种类型的问题。此外，由于ChatGPT是基于大规模无监督数据训练的，它能够从这些数据中自动学习和提取知识，因此其知识库是动态更新的。然而，由于模型的训练数据主要来自于互联网，因此它可能无法很好地理解和处理某些特定领域的专业术语和知识。
相比之下，文心一言，它的训练数据主要来自于百度百科等中文知识库。这使得文心一言在中文知识的覆盖范围上具有一定的优势，能够更好地理解和处理中文的专业术语和知识。此外，文心一言的知识库是经过人工筛选和整理的，因此其知识的准确性和可靠性较高。然而，由于文心一言是基于有监督数据训练的，其知识库的更新和维护需要人工参与，因此在一些新兴领域或快速发展的领域中可能存在一定的滞后性。
总的来说，ChatGPT和文心一言在知识库丰富度方面各有优势。ChatGPT具有广泛的知识覆盖范围，能够回答各种类型的问题；而文心一言则在中文知识的覆盖范围上具有一定的优势，能够更好地理解和处理中文的专业术语和知识。然而，由于两者的训练数据来源不同，因此在一些特定领域的知识和新兴领域的知识上可能存在差异。因此，选择哪种模型取决于具体的应用需求。
五 应用领域的比较 ChatGPT，其强大的智能回复能力使得它在多个领域都有广泛的应用。例如，在客户服务领域，ChatGPT可以用于自动回答用户的问题和处理用户的投诉；在教育领域，ChatGPT可以用于生成个性化的学习材料和提供在线辅导服务；在医疗领域，ChatGPT可以用于辅助医生进行诊断和治疗决策等。此外，由于ChatGPT是基于大规模无监督数据训练的，它能够从这些数据中自动学习和提取知识，因此其应用范围非常广泛。
相比之下，文心一言，它的应用场景主要集中在中文领域。例如，在新闻摘要领域，文心一言可以用于自动生成新闻摘要；在文本分类领域，文心一言可以用于对文本进行自动分类；在情感分析领域，文心一言可以用于对文本进行情感分析等。此外，由于文心一言是基于有监督数据训练的，其应用范围相对较窄，主要适用于中文领域的任务。
总的来说，ChatGPT和文心一言在不同应用场景中都有各自的优缺点。ChatGPT具有广泛的适用性，能够应用于多个领域；而文心一言则更专注于中文领域的任务。然而，由于两者的训练数据来源不同，因此在一些特定领域的知识和新兴领域的知识上可能存在差异。因此，选择哪种模型取决于具体的应用需求。
六 用户接受度和社会影响的比较 ChatGPT，其强大的智能回复能力使得它在多个领域都有广泛的应用。根据用户的反馈，ChatGPT能够给出准确、全面的回答，并且能够理解自己生成的内容，并根据输入的上下文进行推理和生成回复。这使得ChatGPT在处理复杂对话和问题时具有优势。然而，由于ChatGPT是基于大规模无监督数据训练的，其生成的回答可能存在一些错误或不准确的地方。此外，由于模型的训练数据主要来自于互联网，因此它可能无法很好地理解和处理某些特定领域的专业术语和知识。
相比之下，文心一言，它的应用场景主要集中在中文领域。根据用户的反馈，文心一言能够根据输入的上下文进行推理和生成回复，并且在数字、代码、归纳和推理这些能力方面表现出色。然而，由于文心一言是基于有监督数据训练的，其生成的回答可能受到训练数据的局限性影响，对于一些新颖或未见过的问题可能无法给出准确的回答。
总的来说，ChatGPT和文心一言在用户接受度和社会影响方面各有优势。ChatGPT在处理复杂对话和问题时具有优势，但其生成的回答可能存在一些错误或不准确的地方；而文心一言则能够根据输入的上下文进行推理和生成回复，但对于一些新颖或未见过的问题可能无法给出准确的回答。因此，选择哪种模型取决于具体的应用需求。
七 未来发展趋势和挑战 对于AI语言模型的未来发展趋势预测，一方面，随着技术的不断进步和数据的不断积累，AI语言模型的性能将会不断提升，其智能回复能力和知识库丰富度都将得到进一步提高。另一方面，随着应用场景的不断扩大，AI语言模型将会在更多的领域得到应用，例如医疗、教育、金融等。此外，随着多模态技术的发展，未来的AI语言模型将能够更好地理解和处理图像、语音等多种类型的数据。
然而，AI语言模型也面临着一些共同的挑战。首先，由于训练数据的质量和数量对模型性能的影响很大，因此如何获取高质量的训练数据是一个重要问题。其次，由于模型的训练需要大量的计算资源和时间，因此如何提高训练效率也是一个关键问题。此外，由于模型的生成回答可能存在一些错误或不准确的地方，因此如何提高模型的准确性和可靠性也是一个重要挑战。
对于ChatGPT和文心一言来说，它们都面临着一些共同的机遇和挑战。一方面，由于两者都具有强大的智能回复能力，因此在客户服务、教育等领域都有广泛的应用前景。另一方面，由于两者都是基于大规模无监督数据训练的，因此如何从这些数据中提取出有用的知识和信息仍然是一个重要问题。此外，由于两者都需要大量的计算资源和时间进行训练，因此如何提高训练效率也是一个关键问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af67729bd6473222fe8dc84415ee194e/" rel="bookmark">
			一文搞懂 Python 3 中的布尔类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 布尔数据类型可以是两个值之一，即True（真）或False（假）。在编程中，我们使用布尔值进行比较，并确定给定程序的控制流程。
布尔值表示与数学逻辑分支相关的真值，这影响计算机科学中的算法。布尔值以数学家乔治·布尔（George Boole）的名字命名，布尔值始终以大写B开头。在Python中，值True和False也始终使用大写的T和F，因为它们在Python中是特殊值。
在本教程中，我们将介绍在Python中了解布尔值的所需内容，并探讨比较运算符、逻辑运算符和真值表。
比较运算符 在编程中，比较运算符用于比较值并将其评估为单个布尔值，即 True 或 False。
下表列出了布尔比较运算符。
运算符含义==等于!=不等于&lt;小于&gt;大于&lt;=小于或等于&gt;=大于或等于 为了理解这些运算符的工作原理，让我们在Python程序中将两个整数分配给两个变量：
x = 5 y = 8 在这个例子中，由于x的值是5，它小于y的值是8。
使用这两个变量及其关联的值，让我们遍历上表中的运算符。在我们的程序中，我们将要求Python打印出每个比较运算符是否评估为 True 或 False。为了帮助我们和其他人更好地理解这个输出，我们还将要求Python打印一个字符串，以显示它正在评估什么。
x = 5 y = 8 print("x == y:", x == y) print("x != y:", x != y) print("x &lt; y:", x &lt; y) print("x &gt; y:", x &gt; y) print("x &lt;= y:", x &lt;= y) print("x &gt;= y:", x &gt;= y) 当我们运行这个程序时，我们将收到以下输出。
x == y: False x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af67729bd6473222fe8dc84415ee194e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ce72091bd01c5b23c18a2c01280ced/" rel="bookmark">
			【llm 微调code-llama 训练自己的数据集 一个小案例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这也是一个通用的方案，使用peft微调LLM。 准备自己的数据集 根据情况改就行了，jsonl格式，三个字段：context, answer, question
import pandas as pd import random import json data = pd.read_csv('dataset.csv') train_data = data[['prompt','Code']] train_data = train_data.values.tolist() random.shuffle(train_data) train_num = int(0.8 * len(train_data)) with open('train_data.jsonl', 'w') as f: for d in train_data[:train_num]: d = { 'context':'', 'question':d[0], 'answer':d[1] } f.write(json.dumps(d)+'\n') with open('val_data.jsonl', 'w') as f: for d in train_data[train_num:]: d = { 'context':'', 'question':d[0], 'answer':d[1] } f.write(json.dumps(d)+'\n') 初始化 from datetime import datetime import os import sys import torch from peft import ( LoraConfig, get_peft_model, get_peft_model_state_dict, prepare_model_for_int8_training, ) from transformers import (AutoTokenizer, AutoModelForCausalLM, LlamaForCausalLM, TrainingArguments, Trainer, DataCollatorForSeq2Seq) # 加载自己的数据集 from datasets import load_dataset train_dataset = load_dataset('json', data_files='train_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ce72091bd01c5b23c18a2c01280ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996de36c9679b4395dbd7c020f41fbb4/" rel="bookmark">
			Mysql图书借阅管理系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：本文章的图书管理系统设计将演示mysql数据库设计的基本流程：总体需求，功能需求，数据流图，数据字典，概念模型设计，逻辑模型设计，创建数据库，创建数据库表，创建视图，功能相关sql语句。不涉及前端页面的编写，前后端交互等部分。
设计需求：设计并开发一个小型的图书借阅管理系统。图书借阅管理系统主要有三类用户，（1）系统管理员：实现对读者、图书以及图书管理员信息的增加、删除、查询、修改等。读者信息包括证件号、姓名、证件状态（有效和失效）、联系方式等。图书信息包括图书编号、图书名称、作者、出版社、价格等。工作人员信息包括工作证号、姓名、电话等。
(2）读者：可以实现借书、还书，查阅图书信息、查询借书信息等。
(3）工作人员：可以实现办理借书、还书，图书超期罚款等。
图书馆规定：每位读者可以借阅多本图书，一本图书可以被不同的读者借阅，每借出一本书都有借阅日期、应还日期，每本图书的借阅期限是一个月，超期一天罚款0.5元。
1.总体需求 图书管理系统主要满足三类用户需求：系统管理员、读者、工作人员
1）系统管理员：
实现对读者、图书以及图书管理员信息的增加、删除、查询、修改等。
读者信息包括证件号、姓名、证件状态（有效和失效）、联系方式等。
图书信息包括图书编号、图书名称、作者、出版社、价格等。
工作人员信息包括工作证号、姓名、电话等。
(2）读者：
可以实现借书、还书，查阅图书信息、查询借书信息等。
(3）工作人员：
可以实现办理借书、还书，图书超期罚款等。
图书馆规定：每位读者可以借阅多本图书，一本图书可以被不同的读者借阅，每借出一本书都有借阅日期、应还日期，每本图书的借阅期限是一个月，超期一天罚款0.5元
2.功能需求 1）系统管理员
查询图书，读者，工作人员，借书信息
新增图书，读者，工作人员，借书信息
修改图书，读者，工作人员，借书信息
删除图书，读者，工作人员，借书信息
(2）读者：
查询所有书籍信息
查询借书信息
提交借书申请
提交还书申请
对自己的读者信息进行查询，修改
(3）工作人员：
查询所有书籍信息
查询借书信息
处理借书申请
处理还书申请并决定是否罚款
对自己的工作人员信息进行查询，修改
图书借阅系统功能模块划分：
3数据流图 第0层数据流：
第1层数据流
第2层数据流
登录（以读者为例）
借书
还书
处理借书申请
处理还书申请
4.数据字典 1数据项
名称
说明
数据类型
字符个数
book_id
图书编号
varchar
10
book_name
图书名称
varchar
10
author
作者
varchar
12
publish_name
出版社
varchar
12
price
价格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/996de36c9679b4395dbd7c020f41fbb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16022d6ff5253b1cd74462a8ef18213e/" rel="bookmark">
			数据库SQL入门教程(非常详细)，从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 📚 前言🌴 SQL 介绍 🌼 什么是 SQL🌀 SQL 的类型🌵 学习 SQL 的作用🍄 数据库是什么 🐥 SQL 基础语言学习 🐤 CREATE TABLE – 创建表🐑 INSERT – 插入数据🐼 SELECT – 查询数据🐫 DISTINCT – 去除重复值🐸 WHERE – 条件过滤🐹 AND &amp; OR – 运算符🐰 ORDER BY – 排序🐱 UPDATE – 更新数据🐨 DELETE – 删除数据🐵 TRUNCATE TABLE – 清除表数据🐯 DROP TABLE – 删除表 🚀 SQL 高级言语学习 🚢 LIKE – 查找类似值🚤 IN – 锁定多个值⛵️ BETWEEN – 选取区间数据🚂 AS – 别名🚁 JOIN – 多表关联🚜 UNION – 合并结果集🚌 NOT NULL – 非空🚐 VIEW – 视图 🎯 SQL 常用函数学习 🍔 AVG – 平均值🍕 COUNT – 汇总行数🍘 MAX – 最大值🍢 MIN – 最小值🍰 SUM – 求和🍪 GROUP BY – 分组🍭 HAVING – 句尾连接🍷 UCASE/UPPER – 大写🍶 LCASE/LOWER – 小写👛 LEN/LENGTH – 获取长度🍗 ROUND – 数值取舍🍞 NOW/SYSDATE – 当前时间 🍺 写在最后 📚 前言 SQL语言有40多年的历史，从它被应用至今几乎无处不在。我们消费的每一笔支付记录，收集的每一条用户信息，发出去的每一条消息，都会使用数据库或与其相关的产品来存储，而操纵数据库的语言正是 SQL ！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16022d6ff5253b1cd74462a8ef18213e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda58e7849dff355076ce5f2f3f981fc/" rel="bookmark">
			如何玩转CSDN AI工具集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 人工智能生成内容（AIGC）是当下最具有前景的技术领域之一。AI能够以惊人的速度和准确度生成各种类型的内容，完成文章翻译、代码生成、AI对话、插图创作等工作，带来了许多令人兴奋的机遇。
本文将介绍CSDN AI工具集的基本使用方法，现在您可以免费试用全部功能。
一、AI工具集 AI工具集是CSDN的一款综合AI赋能平台，集成了多项AIGC能力，提供一站式解决方案。
☞ 点击访问AI工具集
二、功能简介 目前AI工具集上线了4大功能：
1、chatDOC
定位：一款AI文件阅读工具，可以快速解析、定位和总结上传的pdf等文档内容。
功能：对照翻译、导出、摘要、润色、写作助手
2、视频处理
定位：一款视频处理工具，可以上传视频并完成翻译总结。
功能：翻译字幕、摘要生成、Chat视频
3、角色机器人
定位：定义身份和行为方式的专业AI顾问，可以在领域内精准回复。
功能：100+种专业团队，个性化筛选机器人，定制对话风格
4、C知道
定位：CSDN和外部合作伙伴合作研发的生成式AI产品。
功能：泛用性AI对话
随着研发团队的推进，将计划陆续解锁更多的实用功能：
ChatRSS：整理全球关键技术信息ChatBlog：CSDN博客/文章AI分析ChatJAVA：获取垂直领域技术资源全网搜索：沉浸式翻译，中英对照 更多需求，你来定制！
三、页面说明 AI工具集页面将所有功能放置在单个页面中，包括：
顶部导航区
这是页面的头部区域。点击图标，快速滑动或跳转到对应工具功能。
工具使用区
除C知道功能外，其他3种工具均在本页面中使用，无需跳转。
图例请参考下方 功能使用
权益扩展区
在免费试用AI工具集后，如果您觉得产品不错，还可付费享受额外权益，并查看权益剩余。也可通过反馈给产品提需求。
如果您在其他页面充值了年卡，也可以来AI工具集免费领取相同的权益，请务必不要错过哦!
四、功能使用 1.ChatDOC 格式限制：PDF、DOC、DOCX、TXT，大小3M以内。
支持功能：翻译、摘要/润色/写作助手（即将上线）、删除、搜索等
使用步骤：
1.选择功能（默认翻译）
2. 点击或拖入上传文档
3. 确认消耗权益
4. 文档处理中~（根据文档大小耗时不等）
5. 处理完成，点击右侧列表中的文件，查看翻译等操作结果
2.视频处理 格式限制：MP4、M4V、WEBM、MOV、MKV，1G以内
支持功能：翻译字幕、摘要生成、Chat视频、删除、搜索等
使用步骤：
1.选择功能（一次上传，可同时翻译字幕、摘要生成、Chat视频）
2. 点击或拖入上传视频
3. 确认消耗权益
4. 视频处理中（根据视频时长耗时不等）
5. 处理完成，点击右侧列表中的文件，查看操作结果
3.角色机器人 支持功能：与100+种角色机器人/热门AI对话、搜索
使用步骤：
1.搜索并点击角色机器人
2. 开始聊天吧~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda58e7849dff355076ce5f2f3f981fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4742d7e9292999dbe08e2cb66b482d1/" rel="bookmark">
			python中str、bytes、十六进制字符串的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基本概念 python中str、bytes、十六进制字符串的介绍
str是python的内置函数，str字符串在python中使用''或者""括起来的字符串，比如：a = "hello world" bytes也是python的内置函数，bytes字符串通常以b开头，比如：byte_str = b'hello world' 十六进制字符串是指字符串中每个字符表示一个十六进制数，两个字符组成一个字节，比如:hex_str = '68656c6c6f20776f726c64' 注：十六进制字符串的特点是不会出现f之后的字符，如果出现了hi，则无法转换成十六进制数 2.三者之间的转换方式 使用binascii模块
binascii模块官方文档：https://docs.python.org/3.9/library/binascii.html#binascii.hexlifybinascii.hexlify(data[, sep[, bytes_per_sep=1]]) Return the hexadecimal representation of the binary data. Every byte of data is converted into the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of data. binascii.unhexlify(hexstr) Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4742d7e9292999dbe08e2cb66b482d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92505541b36d62fabd57549258bbc8f/" rel="bookmark">
			Python李峋同款跳动的爱心代码（可写字版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“你是我的今日，以及所有的明天”
环境
Python
PyCharm
完整程序
import tkinter as tk import tkinter.messagebox import random from math import sin, cos, pi, log from tkinter.constants import * width = 888 height = 500 heartx = width / 2 hearty = height / 2 side = 11 heartcolor = "pink" # 爱心颜色，可修改 class Heart: def __init__(self, generate_frame=20): self._points = set() # 原始爱心坐标集合 self._edge_diffusion_points = set() # 边缘扩散效果点坐标集合 self._center_diffusion_points = set() # 中心扩散效果点坐标集合 self.all_points = {} # 每帧动态点坐标 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d92505541b36d62fabd57549258bbc8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4230a915a7ccf23d84179dffc68aa8/" rel="bookmark">
			Scrcpy：掌握你的Android设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scrcpy：掌握你的Android设备 本文将介绍Scrcpy工具，它是一种强大的安卓设备控制工具，可以实现屏幕镜像、操作控制等功能。我们将探讨Scrcpy的基本原理和工作方式，并介绍如何使用Scrcpy连接和控制安卓设备。此外，我们还将讨论Scrcpy的高级功能和扩展，以及它在不同应用场景下的优势和成功案例。最后，我们将总结Scrcpy对安卓设备控制的价值和潜力，并展望其未来发展方向。
引言 Scrcpy是一种开源的安卓设备控制工具，它可以将安卓设备的屏幕映射到计算机上，并允许用户在计算机上对设备进行操作。Scrcpy的主要特点包括延迟低、速度快、支持多种操作系统等。Scrcpy的出现为安卓设备控制带来了前所未有的便利，成为了众多开发者和用户的首选。在本文中，我们将介绍Scrcpy的背景和概述，以及Scrcpy对安卓设备控制的重要性。
Scrcpy的背景和概述 Scrcpy是由Genymobile开发的一款安卓设备控制软件，旨在为开发人员和用户提供一个高效、可靠的屏幕镜像和操作控制工具。Scrcpy采用ADB连接方式，以USB或无线局域网的方式将安卓设备和计算机连接在一起。Scrcpy的主要特点包括延迟低、速度快、支持多种操作系统等。
Scrcpy对安卓设备控制的重要性 对于开发人员而言，Scrcpy可以帮助他们更加方便地进行应用程序的调试和测试工作。通过Scrcpy，开发人员可以实时查看应用程序在真实设备上的运行情况，及时发现并解决问题。同时，Scrcpy还支持多点触控和物理按键映射等功能，能够更加精细地模拟用户操作。
对于普通用户而言，Scrcpy可以帮助他们更加便捷地管理和控制安卓设备。通过Scrcpy，用户可以将安卓设备的屏幕投射到计算机上，方便地进行数据传输、文件管理、屏幕录制等操作，无需频繁地切换设备。同时，Scrcpy还支持远程控制，可以通过局域网或互联网远程连接设备，实现便捷的远程工作。
总之，Scrcpy为安卓设备的管理和控制带来了前所未有的便利，成为了越来越多开发者和用户的首选工具。
Scrcpy的功能与特点 Scrcpy的基本原理和工作方式 Scrcpy的基本原理是通过ADB（Android Debug Bridge）实现与安卓设备的通信和控制。ADB是安卓开发工具包（SDK）中的一个命令行工具，用于与安卓设备建立连接并执行各种操作。Scrcpy利用ADB命令来获取设备的屏幕图像，并将图像传输到计算机上进行显示。同时，Scrcpy还通过ADB发送用户输入事件到设备，实现对设备的操作控制。
Scrcpy的主要功能和特点介绍 屏幕镜像：Scrcpy可以实时将安卓设备的屏幕投射到计算机上，并在计算机屏幕上实时显示设备的操作界面。这使得开发者和用户可以方便地查看设备上的内容，进行文件管理、图像预览等操作。 示例代码：
scrcpy 操作控制：通过Scrcpy，用户可以在计算机上直接操作安卓设备，包括鼠标点击、键盘输入、滑动触摸屏等。这使得用户可以更加精确地模拟设备上的操作，而无需直接触碰设备。 示例代码：
adb input tap x y 多平台支持：Scrcpy支持多种操作系统，包括Windows、macOS和Linux。这使得用户可以在不同平台上使用Scrcpy，并享受到相同的屏幕镜像和操作控制功能。
低延迟和高速度：Scrcpy在传输屏幕图像和执行操作时具有较低的延迟和高速度。这意味着用户可以获得流畅的屏幕显示和实时响应的操作体验。
支持多设备连接：Scrcpy允许同时连接多个安卓设备，并在计算机上进行切换和操作。这对于开发者来说尤为重要，他们可以方便地进行多设备的调试和测试工作。
总之，Scrcpy具有屏幕镜像、操作控制、多平台支持、低延迟和高速度等特点，为用户提供了强大而便捷的安卓设备控制能力。无论是开发者还是普通用户，都可以通过Scrcpy更好地管理和利用安卓设备。
如何使用Scrcpy连接和控制安卓设备 安装和配置Scrcpy 在计算机上下载Scrcpy的可执行文件，可以从Scrcpy的官方GitHub页面获取最新版本。解压下载的文件到一个合适的位置，并确保计算机已经安装了ADB工具。 连接安卓设备与计算机 打开安卓设备的开发者选项。在设备的设置中找到“关于手机”，连续点击“版本号”七次以解锁开发者选项。进入开发者选项，启用“USB调试”选项。使用USB数据线将安卓设备连接到计算机。 使用Scrcpy进行屏幕镜像和操作控制
打开命令行终端（Windows用户可以使用CMD，macOS和Linux用户可以使用终端）。导航到Scrcpy所在的目录。在命令行中输入以下命令来启动Scrcpy： scrcpy Scrcpy会自动连接到已经通过USB连接的安卓设备，并将设备的屏幕图像投射到计算机上。 示例代码：
scrcpy 在计算机上使用鼠标和键盘来操作安卓设备。你可以单击鼠标模拟触摸屏幕的点击，使用鼠标滚轮模拟滑动屏幕，使用键盘模拟物理按键的输入等。 示例代码（使用ADB命令模拟点击）：
adb shell input tap x y 若要断开与设备的连接，可以在命令行中按下Ctrl + C来停止Scrcpy的运行。 通过安装和配置Scrcpy，将安卓设备与计算机连接起来，并使用Scrcpy进行屏幕镜像和操作控制，用户可以方便地管理和利用安卓设备。Scrcpy的简单易用和跨平台支持使得它成为了开发者和普通用户的首选工具之一。
Scrcpy的高级功能和扩展 Scrcpy不仅提供了基本的屏幕镜像和操作控制功能，还具有许多高级功能和扩展，包括视频录制和屏幕截图、无线连接和远程控制、扩展和自定义Scrcpy功能等。
视频录制和屏幕截图 Scrcpy允许用户对设备屏幕进行录制和截图，以便于用户记录和分享设备上的内容。用户可以在命令行中输入特定的参数来启用该功能。
示例代码（启动屏幕录制）：
scrcpy --record &lt;文件名&gt;.mp4 示例代码（启动屏幕截图）：
scrcpy --screen-touch &lt;文件名&gt;.png 无线连接和远程控制 Scrcpy还支持通过Wi-Fi无线连接来实现远程控制的功能。用户需要确保设备和计算机都连接到同一个Wi-Fi网络，并在命令行中输入相应的参数。
示例代码（通过Wi-Fi连接设备）：
scrcpy --serial &lt;设备序列号&gt; --no-adb tcp:&lt;端口号&gt; 扩展和自定义Scrcpy功能 Scrcpy提供了灵活的扩展机制，用户可以通过编写脚本和插件来定制Scrcpy的功能。用户可以使用Python、Shell、Lua等多种脚本语言来编写插件，并通过命令行参数来加载和使用这些插件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4230a915a7ccf23d84179dffc68aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0100ad6f2affa1dc1c7de5f24d2f092c/" rel="bookmark">
			windows nginx开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一 通过把nginx加入到windows服务中
1、下载window service wraper（https://github.com/winsw/winsw/releases）
分享至阿里云盘可直接下载，根据对应系统下载所需版本（如果x64和x86失败，可试试NET4，建议windows 2008和windows 2012 r2使用NET4版本）
阿里云盘分享https://www.alipan.com/s/3pynW4prQvv
2、将安装包放到nginx目录下面，自定义重命名（nginx-serive.exe）
3、新建一个nginx-service.xml（文件名跟上面保持一致）
4、添加配置信息
&lt;service&gt; &lt;id&gt;nginx&lt;/id&gt; &lt;name&gt;Nginx Service&lt;/name&gt; &lt;description&gt;High Performance Nginx Service&lt;/description&gt; &lt;logpath&gt;E:\gis\nginx-1.12.2\nginx-1.12.2\logs&lt;/logpath&gt; &lt;log mode="roll-by-size"&gt; &lt;sizeThreshold&gt;10240&lt;/sizeThreshold&gt; &lt;keepFiles&gt;8&lt;/keepFiles&gt; &lt;/log&gt; &lt;executable&gt;E:\gis\nginx-1.12.2\nginx-1.12.2\nginx.exe&lt;/executable&gt; &lt;startarguments&gt;-p E:\gis\nginx-1.12.2&lt;/startarguments&gt; &lt;stopexecutable&gt;E:\gis\nginx-1.12.2\nginx-1.12.2\nginx.exe&lt;/stopexecutable&gt; &lt;stoparguments&gt;-p E:\gis\nginx-1.12.2 -s stop&lt;/stoparguments&gt; &lt;/service&gt; 5、修改上面地址为自己的nginx地址
6、cmd进入到文件目录
nginx-service.exe install #系统服务命令安装 nginx-service.exe uninstall #系统服务命令卸载 nginx-service.exe stop #停止对应的系统服务命令 nginx-service.exe start #启动对应的系统服务命令 7、进去任务管理器启动nginx服务，并打开服务器设置nginx启动属性为自动
方式二 通过windows程序计划设定nginx开机自启动
1、按下win键输入计划，回车
2、找到windows目录，在当下目录创建新任务
3、自定义名称描述
4、将触发设定为开机自启动
5.点击下一步，程序或脚本选择nginx.exe所在目录，要把下面的起始于 处填上 nginx.exe的所在路径 点击下一步
6、后续设定根据实际需求完成即可，可参考一下配置
7、在完成配置后确认即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3bfd6db0259a72db334d1bff71dd33/" rel="bookmark">
			SQLyog 社区版安装，完全免费的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时在SQLyog官网下载不了，官网打不开，崩溃情况，可以直接复制下面网址下载
复制网址到百度：
https://www.softonic.nl/download/sqlyog/windows/post-download/v/13.1.6 进去之后会直接跳出这个页面
下载好之后会得到SQLyog-13.1.6-0.x64Community.exe 安装文件
使用管理员身份安装
然后双击运行，配置连接...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbbbfa566f0e2187ad7668bdfc97560/" rel="bookmark">
			前端使用插件预览pdf、docx、xlsx、pptx格式文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF预览 H5页面pdf预览 插件：pdfh5
版本：“pdfh5”: “^1.4.7”
npm install pdfh5
import PdfH5 from "pdfh5"; import "pdfh5/css/pdfh5.css"; // methods this.$nextTick(() =&gt; { this.pdfH5 = new PdfH5("#pdf", { pdfurl: this.pdfData.url, pageNum: false, backTop: false, }); this.pdfH5.on("ready", () =&gt; { this.pdfData.totalNum = this.pdfH5.totalNum - 0 this.pdfData.currentNum = this.pdfH5.currentNum - 0 }) this.pdfH5.on("scroll", (scrollTop, currentNum) =&gt; { this.pdfData.currentNum = currentNum - 1 === 0 ? 1 : currentNum - 1 }) this.pdfH5.on('success', () =&gt; { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dbbbfa566f0e2187ad7668bdfc97560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd63923beee1c75a664ef2cf392e7ba5/" rel="bookmark">
			SQL两表/多表关联查询--JOIN语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础概念 SQL中的关联是通过JOIN关键字实现的，JOIN关键字有几种类型，包括INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL OUTER JOIN等。
二、INNER JOIN详解 INNER JOIN是最常用的关联方式之一，它返回 两个表中共同存在的数据行。
其语法格式如下：
SELECT column1, column2, ... FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; 下面是一个实际的例子：
SELECT customer.name, orders.order_date FROM customer INNER JOIN orders ON customer.id = orders.customer_id; 以上代码可以得到一个结果集，其中包含了客户的姓名和他们所下的订单的日期。
三、LEFT JOIN详解 LEFT JOIN也是一种常用的关联方式，它 返回 左表中的所有数据行 和 右表中与其匹配的数据行。
其语法格式如下：
SELECT column1, column2, ... FROM table1 LEFT JOIN table2 ON table1.column_name = table2.column_name; 下面是一个实际的例子：
SELECT customer.name, orders.order_date FROM customer LEFT JOIN orders ON customer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd63923beee1c75a664ef2cf392e7ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539fd5e14d2455cbd827fb72880db830/" rel="bookmark">
			opencv python 实现Canny检测后不连续不封闭轮廓的闭合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Canny检测后轮廓的闭合在网上看了一些相关文章后总结出有以下方法： 1、使用闭运算等形态学操作来对轮廓进行处理，但作为像素点级别 的形态学操作往往不能满足要求，如：两条轮廓线相距仅为一个像素，在进行闭运算操作时会使这两条轮廓粘连在一起。
2、对于规则的图像可通过对不连续的点或线段进行拟合，通过对称的修剪和补缺来处理，但适用的对象非常有限，所以只能特例分析。
3、找到图像中不连续轮廓中的端点，通过最近端点间画直线来处理，但这仅仅适用于简单的图像处理，对于一些复杂或者断续太大的轮廓反而效果比较差。
本章主要讲第三种方法，代码如下：
import cv2 import math import numpy as np import timeit start_time = timeit.default_timer() def point(img, h, w): p = [] for i in range(h): for j in range(w): if img[i, j] == 255: r = [] for y in range(i-1, i+2): for x in range(j-1, j+2): if y == i and x == j: continue if img[y, x] == 255: r.append((y, x)) if len(r) &gt; 0: if len(r) == 1: p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/539fd5e14d2455cbd827fb72880db830/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/525/">«</a>
	<span class="pagination__item pagination__item--current">526/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/527/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>