<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb7f75bcfbca38962e6c1aaacc13b8dc/" rel="bookmark">
			【安全】Linux Fanotify使用入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Fanotify vs Inotify 在实现某些功能时，可能需要获取某个文件执行的操作，一种可能的方案是用Audit的路径监控，但是Audit存在性能和内核稳定性问题，这个时候就可以其他的文件变更检测机制。
inotify可以监控文件被创建、修改和访问的事件，当文件或者目录发生变化时，可以得到变更的事件，但是inotify有个比较大的不足，就是无法得到执行操作的进程Pid。fanotify是另一种文件监控机制，在使用上两者类似，都是先调用init函数初始化句柄，然后调用类似watch的函数添加监控路径，再使用select+read的方式读取出变化的事件，根据事件中给出的参数获取文件的路径、事件类型以及其他需要的数据。与inotify相比，fanotify的优势在于：
访问控制：inotify只能监控文件的变化，而fanotify可以在用户操作之前决定是否可以继续操作，相当于可以用于实现阻断的功能监控范围：inotify用于监控文件或者目录的变化，如果要监控目录下所有文件(包括子目录)，就需要自行递归添加路径；fanotify则提供directed、per-mount和global三种监控模式，其中global模式可以用于监控整个文件系统进程信息：inotify只能得到某个文件发生了什么事件；fanotify可以得到对文件操作的进程pid，程序可以从/proc/pid读取进程信息 2 Fanotify Demo #include &lt;sys/fanotify.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;stdlib.h&gt; #include &lt;string&gt; #include &lt;string.h&gt; int main(int argc, char *argv[]) { int fan_fd, fd; if(argc &lt; 2) { printf("usage: ./main path\n"); return -1; } // 初始化fanotify的描述符，后续的操作都是通过该描述符 fan_fd = fanotify_init(FAN_CLASS_NOTIF, O_RDONLY); if (fan_fd &lt; 0) { perror("fanotify_init"); return -1; } // 增加监控路径 if (fanotify_mark(fan_fd, FAN_MARK_ADD, FAN_ACCESS|FAN_MODIFY|FAN_EVENT_ON_CHILD, AT_FDCWD, argv[1]) &lt; 0) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb7f75bcfbca38962e6c1aaacc13b8dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49cd720631d22c29a119f12d5044da86/" rel="bookmark">
			【数据结构】线性表之《无头单链表》超详细实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单链表 一.链表的概念及结构二.顺序表与链表的区别与联系三.单链表的实现1.创建单链表2.初始化单链表3.购买节点4.打印单链表5.插入操作1.头插2.尾插3.给定位置之前插入 6.删除操作1.头删2.尾删3.删除给定位置的结点 7.查找数据8.修改数据9.求单链表长度10.清空单链表11.销毁单链表 四.模块化源代码1.SingleLinkList.h2.SingleLinkList.c3.test.c 五.链表必做OJ题 前言：在前一章节成功实现了顺序表后，对数据结构的理解已经初具雏形，但这只是启蒙阶段，接下来我们将进入链表的探索学习。链表作为数据结构的另一种形式，不仅仅是简单的表述，它承载了更多的内涵和抽象思维，有助于深入理解数据在计算机科学中的精髓。
一.链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表
中的指针链接次序实现的 。
typedef int SLLDataType; //增强程序的可维护性 typedef struct SLLNode { SLLDataType data; //数据域 struct SLLNode* next; //指针域 }SLLNode; 实际中要实现的链表结构非常多样（2^3=8中）。
单向，双向。带头，不带头。循环，非循环。 虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：
无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结
构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都
是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带
来很多优势，实现反而简单了，后面我们代码实现了就知道了。
二.顺序表与链表的区别与联系 顺序表：
优点：空间连续，支持随机访问。
缺点：如果空间不够要增容，增容会付出一定的性能消耗，其次可能存在一定的空间浪费；头部或者中部左右的插入 ，删除效率低——&gt;O(N)。
链表：
优点：任意位置的插入删除的时间复杂度为O(1)；没有增容消耗，按需申请节点空间，但是不用了记得直接释放。
缺点：以节点为单位存储，不支持随机访问。
三.单链表的实现 1.创建单链表 链表由节点组成，每个节点要存放数据与下一个节点的地址（为了找到下一个节点）。由于存放的是不同类型的数据，所以定义一个结构体，成员则有：数据域，指针域。
单链表：指向该节点的指针。
typedef int SLLDataType; //增强程序的可维护性 typedef struct SLLNode //单链表节点 { SLLDataType data; //数据域 struct SLLNode* next; //指针域 }SLLNode; SLLNode* plist;//单链表 2.初始化单链表 注意：以下函数中的参数 phead 对应 plist；pphead 对应 &amp;plist。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49cd720631d22c29a119f12d5044da86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d691ae6ef887ea7bae9917309618df6/" rel="bookmark">
			C语言——扫雷小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷小游戏：
游戏最终效果：
1.先写一下游戏开始的简单界面。
用一个函数来写一下
void menu() { printf(" ---------------------------- \n"); printf("| 1.play |\n"); printf("| 0.exit |\n"); printf(" ---------------------------- \n"); } 这里的功能（说明）：
输入 1 代表游戏开始；
输入 0 代表游戏结束，并退出页面；
既然写扫雷，那地图中的地雷应该是随机出现的，那我们可以用一个srand函数让它随机出现生成地雷。
srand((unsigned int)time(NULL)); //生成随机数的一个函数
具体用法可以百度一下，简单的概括就是生成一个随机数字。
int main() { srand((unsigned int)time(NULL)); int input = 0; //用与while函数循环的选择 do { //也就是刚开始说的界面选择开始或结束的选项 menu(); printf("请选择&gt;"); scanf("%d", &amp;input); //这里的input就是游戏开始或结束的选择 switch (input) //再循环里面嵌套一个switch { case 1: // 当输入1的时候，那就进入游戏开始的逻辑 printf("游戏开始！\n"); system("cls"); // ：这里是系统函数，用于清空控制台的消息与文字 game(); // 这个是游戏开始的函数接口 break; case 0: // 当选择0的时候，即退出游戏退出循环，并程序结束。 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d691ae6ef887ea7bae9917309618df6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089e031278245465caf7d1659f36a0e0/" rel="bookmark">
			Python tkinter(GUI编程)模块最完整教程（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：下滑文章左侧可以查看目录！
1 走进tkinter世界 1.1 认识tkinter tkinter是一个GUI开发模块，是Tcl/Tk语言在Python上的接口，可以在大部分操作系统上运行。tkinter非常的简单而且好用。tkinter模块是自带的Python模块，如果在安装Python的时候勾选了Tcl/Tk这个选项，那么使用tkinter不会有任何问题。
导入模块非常简单，但是Python3和Python2略有不同，Python3是这样的：
import tkinter 本文的示例以Python3为准，而Python2是这样的：
import Tkinter #Tkinter开头的t是大写的 不过tkinter这个名字非常长，所以我们通常习惯这么导入：
import tkinter as tk from tkinter import * 如果导入时候就出现了错误，提示找不到_tkinter这一模块，或者调用里面的方法时出现版本错误提示，可能是因为安装时不到位，没有勾选Tk/Tcl这一选项。在安装包中选择Modify，更改Python的安装即可
接下来让我们了解一下自己tkinter的版本：
import tkinter print(tkinter.TkVersion) 最好是使用8.5 Version以上的tkinter，功能比较全面一些。
1.2 tkinter的坐标系与颜色格式 坐标系 组件的排放，鼠标事件等功能都少不了坐标。tkinter的坐标系和数学上习惯用的坐标系略有不同，和pygame的坐标系是一样的。
以左上角为起点，x轴向右延伸，y轴向下延伸。在窗口中，容器的左上角是(0, 0)，不包括窗口的标题栏和菜单栏。
颜色 当在tkinter中设置颜色时，可以用两种表示颜色的方式：一种是颜色的名称，比如"green", "brown"；另一种是颜色的十六进制形式，比如"#00ffff"。遗憾的是，tkinter不支持颜色RGB元组形式，不过可以把它转换成十六进制形式。
这种十六进制形式相当于："#"+R的十六进制+G的十六进制+B的十六进制。比如(255, 255, 255)是纯白，转换成十六进制形式就变成了#ffffff。
tkinter也有一种特殊的颜色名称，叫做SystemButtonFace，是一种浅灰色，是组件的默认背景颜色。
1.3 创建根窗口 根窗口是最主要的一个窗口，根窗口最好只有一个，因为一个Tk就是一个新的Tcl/Tk解释器，解释器并不需要太多。
根窗口使用tkinter中的Tk方法创建。在窗口中，我们可以添加各种各样的控件，也称组件(widget)，比如按钮、文本输入框等，我们将在后期介绍。窗口也可以有一些子窗口。当父窗口关闭后，所有的子窗口会跟着关闭，但是子窗口关闭，父窗口不会关闭。
from tkinter import * root = Tk() mainloop() 这一段代码创建一个窗口，并且循环显示这个窗口。mainloop方法，可以让窗口循环显示，否则运行时窗口一闪就没了。一定不要忘记mainloop！mainloop也可以用while True: root.update()这一段代替，不过mainloop更加常用一些。mainloop也可以作为窗口的一个方法，即root.mainloop()。
这段代码创建了一个独立的窗口，默认标题叫tk，你可以在下面的任务栏找到它。同样，你也可以自由拖拽它的位置，改变窗口的大小。也可以把它关闭、最小化、最大化。
Tk(screenName=None, baseName=None, className='Tk', useTk=1, sync=0, use=None)
Tk有一个参数叫做className，允许你改变窗口标题。但是这样改变标题有一个bug，就是窗口标题的首字母会自动小写，因此不推荐你这么做，而应使用title方法。Tk的参数并不常用，但有一些比较基础常用的方法，更多的方法，请参见2.2.14。
方法使用方法title(string=None)设置窗口的标题，同时返回窗口标题geometry(newGeometry=None)设置窗口的尺寸大小，同时返回当前窗口尺寸iconbitmap(bitmap=None)设置窗口的图标，需指定图标文件(*.ico)的位置resizable(width=None, height=None)设定是否能够改变窗口的宽和高尺寸destroy()销毁窗口，也就是把窗口关掉 下面看一个示例，演示了tk中一些常用的窗口操作：
from tkinter import * root = Tk() root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089e031278245465caf7d1659f36a0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c26fe5fcffc9bcd5a5d4d5d51fe8b8/" rel="bookmark">
			大模型 舆情分析 数据构造 prompt提示词 经验分享 数据准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做舆情分析，需要执行比较复杂的任务流程（例如同时执行人名识别、相关机构识别、90分类），传统Bert无法胜任，因此尝试使用大模型进行处理。
下面的一些提示词是我用来准备数据的，这些数据可以按照不同的难度混和并进行训练。另一些是用来做舆情分析的，在能力较强的大模型上可以直接使用。以下所有案例都是与电力系统相关的。
系统提示词：
你是一个电力行业的专家，你的能够依据电力行业特点对给出的中文舆情关键词进行解释。 你能够严格依照提示中的要求进行内容生成 系统参数：
top_p= 0.7, temperature= 0.95, 场景1：模拟社交媒体 我需要针对特定舆情关键词，生成四个社交媒体风格的负面句子。关键词可以直接出现在句子中，也可以不直接出现在句子中。
经验1： 一次只做一个事情，我把这个任务和“模拟新闻媒体”放在了一起，导致提示词非常长，模型效果也不好，输出结果格式也很混乱。
经验2: 步骤1中，我让模型先思考一下（但是不要输出），起到了立竿见影的效果。一定程度上，这能代替fewshot，因为模型已经知道了一些舆情的真实含义（如果不知道，可以把相关的含义拼到提示词中，或者在场景2中生成舆情解释，并训练模型学会这些解释）。
经验3： 指定风格，可以用“模拟不同年龄段、文化水平的语气”类似的提示词。指定数量和一些具体要求（例如两个带关键词，两个不带关键词），可以参照步骤2和3.
经验4： 输出格式，json不是很好控制，以后要输出json的时候，也许可以参照“输出格式”的做法，按照固定的顺序输出。例如，身份证识别任务中，可以写“请换行输出姓名、籍贯、生日、家庭住址，用#分割“”。
提示词：
`请帮我编写4个关于“{0}”的负面舆情例子，每个例子之间用####隔开。 请仿照社交媒体的写法，语气、形式更加多样。可以是陈述、反问、感叹等语气。 每次输出时，请模拟不同年龄段、文化水平的语气。 步骤1：在撰写例子之前，你应该先理解“{0}”在电力中的含义（但是不要输出）。 步骤2：在撰写前两个例子的时候,请你在行文中隐含的表达与“{0}”有关的内容，不要直接提及“{0}”这个词汇。 步骤3：在撰写最两个例子的时候，可以在行文中的过程中提及“{0}”。 输出格式：每个例子用"####"隔开。请直接输出例子的原始内容，每个例子之间不要过于相似。不要输出“例子1”之类的字眼。` 效果：
假设关键词是停电，模拟舆情如下：
#### 这大热天的，真是要命啊！空调电扇全歇菜，连个凉快地儿都找不着，这日子没法过了！ #### 又是突如其来的黑灯瞎火，看来今晚的电影是泡汤了，这频繁的“意外”什么时候是个头啊？ #### 天啊，怎么又停电了？冰箱里的食物都要化了，这可是我刚买的啊！真是让人头大。 #### 停电停得我游戏进度都丢失了，这电力供应能不能稳定一点？还让不让人好好玩耍了！ 场景2：舆情解释 我需要对一些舆情进行解释。我认为在训练中，这可以增强一些小模型的对于舆情的理解。针对一些困难的舆情词汇（行业黑化）进行训练，也可以一定程度上注入相关知识（我做过认知实验，例如人员a开发了计算机系统b，反过头来问系统b是由谁开发的，模型能够答对，但是如果问模型a的职业，模型可能无法推断出a是一名开发人员）。
经验5： pua大法。背景说明2，能一定程度提升输出质量，类似于“如果你做的好，我会给你500元钱”。
提示词：
请对舆情词汇【{}】进行解释分析，要求语言流畅、符合电力行业特点。 背景说明1：你需要对这些词汇进行解释，以保证其他大模型和非电力行业人员能够理解舆情词汇的核心内涵有透彻理解。 背景说明2：你的这些解释还会被用于大规模的舆情分析，因此请你务必给出最优质的答案。 效果：
假设关键词是违纪通报，舆情解释如下：
在电力行业，"违纪通报"通常指的是对行业内工作人员违反工作纪律、职业道德或相关法规的行为进行的正式通知和公开批评。 这种通报是对个体或集体不当行为的认定和警示，其目的在于加强电力行业内部的纪律性，维护行业秩序，确保电力供应的安全稳定，以及提升整个行业的服务质量和社会形象。 在强调严格的安全管理和高效的服务标准下，违纪通报有助于形成一种遵纪守法、廉洁自律的行业文化。 通过这种方式，电力行业能够对外展示其透明度和自我监督的能力，同时对内部员工起到教育和震慑的作用。 场景3：舆情分析-方式1 现在正式进入舆情分析。需要将【原文】与【关键词列表】中的词汇进行匹配。关键词列表有90个，即便是glm4网页版这样的先进模型，也可能出错，因此需要对提示词进行修改。
第一种方式，我们尝试把原文摘要成abstract，然后再分析。这种方式对于超长文献中的一两句负面舆情几乎没有识别能力。具体使用还要看需求方的要求。
经验6： 在提示词中，可以起一些变量名，这会加强模型的理解、遵循能力。例如提示词中，我使用了abstract和keyword两个特殊标识，起到了正向作用。
提示词：
请阅读【原文】中的内容，理解其核心主旨，然后判断是否包含关键词列表中的负面舆情。 步骤：理解文章主旨，然后生成摘要abstract，然后判断absctrct与候选列表中的哪个keyword有关。 要求1：请识别列表中每个负面舆情是否出现在abstract中。只匹配一个keyword。 要求2：请不要判断其他类型的舆情。 要求3：只输出与关键词相对应的强烈的负面舆情。 要求4：不要输出其他总结性的语句。 输出格式：针对每个识别到的舆情，单独输出为json，json的key值为：abstract、keyword 原文：【....】 关键词列表 【安全事故 邻避运动....】 效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c26fe5fcffc9bcd5a5d4d5d51fe8b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37adec3e7dcce17397fe8f9c66d4dcd4/" rel="bookmark">
			AI 已经在污染互联网了。。赛博喂屎成为现实
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是程序员鱼皮。这两年 AI 发展势头迅猛，更好的性能、更低的成本、更优的效果，让 AI 这一曾经高高在上的技术也走入大众的视野，能够被我们大多数普通人轻松使用，无需理解复杂的技术和原理。
其中，AI 有一个很重要的应用，就是 搜索 。
搜索技术经历了几个主要阶段的发展：
1）1.0 时代：以关键词匹配为主，搜索引擎根据用户输入的关键词在索引数据库中查找匹配的网页。但容易受到垃圾信息的影响，我可以疯狂制作同时包含垃圾信息和关键词的网站。
2）2.0 时代：引入了链接分析算法，基于网页之间的链接关系来评估网页的重要性。如果一个网站被更多网站引用，那么这个网站的权重就更高，更容易被搜索到。这种改进提高了搜索结果的质量，减少了垃圾信息的影响。
3）3.0 时代：结合语义分析和人工智能技术，理解用户的意图和查询的上下文。说简单点就是用 AI 来帮助用户搜索和总结回答，就好像是有一个聪明的助手帮你搜索内容，然后把所有答案整理好汇总给你。可以进一步提高搜索的效率。
现在的搜索技术是否已正式进入 3.0 时代？我不是专家，就不下这个定义了。但有一点毫无疑问，AI 正在改变人们搜索内容的方式。
比如在某度搜索 “程序员鱼皮”，第一个结果不再是广告、也不再是某某官网，而是 AI 总结的回答。
看了一下，竟然还挺靠谱的，没把我本名给暴露出来。
但是问题来了：AI 是从哪儿找到这些信息，再把答案推送给用户的呢？
我们本能的想到，AI 也是把网络上的数据 “喂” 到了自己的大脑里，跟我们人类一样，如果遇到了没见过的知识，AI 当然也可以打开某个搜索引擎，查到结果后再总结并返回答案给用户。
就像下面这样，AI 的答案可能来源于某些网站：
AI 给出的答案真的正确么？其实很难保证。如果连信息源本身都是错误的，AI 给出的答案大概率也是错的。就像你考试的时候带了一份错误的小抄，直接完犊子了。
还有一个更有意思的事情，现在的某些 AI，引用的信息来源竟然是另一个 AI 搜索？！
引用一张我看到的网图，是某博主在一个 AI 工具提问时，引用来源中竟然出现了另一个 AI 助手 doubao。
可以简单的理解为，当你在谷哥搜索内容时，搜到的竟然是某度的内容。
为什么会出现这种情况呢？学过编程的同学应该更好理解，既然 AI 引用的信息来源于网络，那 AI 生成的信息当然也可以发布到网络上，并被其他的 AI 引用。
恐怖的事情就来了，如果某个 AI 故意持续不断地将生成的内容发到网上 ，其他的 AI 也持续引用 AI 生成的内容，互联网会变成怎么样？
想象一下，以后你搜索的内容，可能是源于 AI 的 AI 的回答，就跟图片水印一样支持无限套娃，根本不知道真实的、原始的信息来自于何处。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37adec3e7dcce17397fe8f9c66d4dcd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5028754ebeba80872b6c2b80575789/" rel="bookmark">
			O‘Reilly 出品的《Nginx 完全指南(第三版)》PDF 高清版 免费下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		O’Reilly 出品的《Nginx 完全指南(第三版)》实现高性能负载均衡的进阶实操指南，PDF 格式免费下载。这本更新于 2024 年的最新版免费 O’Reilly 电子书涵盖了最新的 NGINX 操作指南和使用技巧。阅读本书，您将了解有关负载均衡、云部署、自动化、容器和微服务、服务网格、安全防护等方面的实操建议以及相关的 NGINX 配置示例。
PDF下载页面：《Nginx 完全指南(第三版)》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcd97dc32780ecd0bea6dbb94c38ea2/" rel="bookmark">
			JDK版本特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、名词说明 1.1 LTS版本 1.2属于LTS的JDK版本 二、JDK各版本特性 2.1 JDK8(2014-03, LTS) 2.2 JDK9(2017-09) 2.3 JDK10(2018-03) 2.4 JDK11(2018-09, LTS) 2.5 JDK12(2019-03) 2.6 JDK13(2019-09) 2.7 JDK14(2020-03) 2.8 JDK15(2020-09) 2.9 JDK16(2021-03) 2.10 JDK17(2021-09, LTS) 2.11 JDK18(2022-03) 2.12 JDK19(2022-09) 2.13 JDK20(2023-03) 2.14 JDK21 (2023-09, LTS) 2.15 JDK22 (2024-03) 三、相关文献 3.1 Java中JDK8、JDK11、JDK17，该怎么选择？ 3.2 JDK各版本文档以及迁移说明 3.3 Oracle Java SE支持路线图|Oracle 中国 一、名词说明
1.1 LTS版本
LTS，原名 Long-Term Support 长期支持，正常情况下 当 JDK 12 正式发布后 JDK 11 将失效，但是由于 JDK 11 是 LTS 版本，所以会延长支持更新至 2032 年。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afcd97dc32780ecd0bea6dbb94c38ea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba205a7e746af22c93761d04e67ba96c/" rel="bookmark">
			vue2 项目中axios二次封装以及拦截器 （全篇超级详细哦 ） 新手小白也适合哦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基础配置 首先全局安装axios
二、附图创建一个名为request.js的文件，放在utils下（request名称可以根据自己喜好修改哦）
三、直接上封装代码，详细注释介绍已经写在代码里了，可以直接复制，然后根据自己需求去进行修改
四、需要注意的是 拦截器的状态，根据后台返回的数据需要去处理一下
五、上面axios已经封装完闭了 ，需要创建一个api的文档（文档清晰一点找起来也不是很费劲）
六、在api/user.js 简单封装get，post请求
一、基础配置 首先全局安装axios npm install axios 二、附图创建一个名为request.js的文件，放在utils下（request名称可以根据自己喜好修改哦） 三、直接上封装代码，详细注释介绍已经写在代码里了，可以直接复制，然后根据自己需求去进行修改 import axios from 'axios'; // 基本配置 const instance = axios.create({ baseURL: 'http://localhost:3000/', // 根据实际情况修改API地址 timeout: 5000 // 设置超时时间，单位为ms }); // 请求拦截器 instance.interceptors.request.use(config =&gt; { config.headers['Authorization'] = localStorage.getItem('token'); // 设置请求头部分，这里举例使用了localStorage存储的token作为身份标识 return config; }, error =&gt; { console.log(error); return Promise.reject(error); }); // 响应拦截器 instance.interceptors.response.use(response =&gt; { const data = response.data; if (data &amp;&amp; data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba205a7e746af22c93761d04e67ba96c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67abfdf97dbc502a572f6693622cc58/" rel="bookmark">
			MySQL索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、索引 定义： 索引是一个排序的列表，包含索引字段的值和其对应的行记录数据所在的物理地址
作用： 加快表的查询速度（主要作用），还可以对字段排序 副作用： 会额外占用磁盘空间；更新包含索引的表会花费更多的时间 工作方式： 没有索引的情况下，要查询某行记录数据时，需要先扫描全表，再定位某行记录数据的位置有了索引后，会先通过索引查询到行记录数据所在的物理地址，即可直接访问相应的行记录数据，就像通过书目录的页码快速查找书内容一样。 创建索引的依据： 表的记录行数较多时（一般超过三五百行时），且读操作多的情况下应该要创建索引建议在表的 主键字段、外键字段、多表连接使用的公共字段、唯一性较好的字段、不经常更新的字段、where条件字段、分组(group by)字段、排序(order by)字段、短小的字段 上创建索引不建议在 唯一性较差的字段、更新太频繁的字段、大文本字段 上创建索引 二、索引类型： （1）普通索引： create index 索引名 on 表名(字段(长度));
alter table 表名 add index 索引名(字段);
create table 表名 (.... , index 索引名(字段)); （2）唯一索引： create unique index 索引名 on 表名(字段);
alter table 表名 add unique 索引名(字段);
create table 表名 (.... , unique 索引名(字段)); （3）主键索引： alter table 表名 add primary key(字段);
create table 表名 (.... , primary key(字段)); （4）多列组合索引： create index 索引名 on 表名(字段1, 字段2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c67abfdf97dbc502a572f6693622cc58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92839a17664a72f9650f9e53661b979e/" rel="bookmark">
			GaussDB技术解读——GaussDB架构介绍（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GaussDB架构介绍（四）从云原生关键技术架构&amp;关键技术方案两方面对GaussDB云原生架构进行了解读，本篇将从关键技术方案的事务存储组件、SQL引擎组件、DCS组件、实时分析组件等方面继续介绍GaussDB云原生架构。
目录
事务存储组件
1、本地内存和远程内存两级缓存
2、页面查找机制
3、支持远程内存池, 内存独立扩展。
4、本地缓存远程页面地址，页面地址共享，全RDMA/UB单边读写。
5、Lamport LSN
SQL引擎组件
DCS组件
1、代理层
2、数据管理
实时分析组件
PageStore组件
备份恢复组件
安全
事务存储组件 云原生数据库支持透明多写，所有节点对等，每个计算节点都可以读写全部的数据页面，事务在本节点执行，没有分布式事务。每个计算节点都有Local buffer pool，采用Remote memory pool扩展计算节点的内存，在多个计算节点之间共享buffer地址，避免页面在多个计算节点之间传来传去。存储引擎采用Inplace update引擎，底层存储接口统一采用段页式存储方式。事务ID本节点分配，保证唯一性。事务提交时间戳统一分配，合并原来的CLOG和CSN LOG统一记录。存储层采用Log is data，把数据库存储引擎的持久化卸载到Page Store执行日志持久化，日志回放修改页面，创建检查点。
图1 分布式缓冲池示意图
在计算节点，分布式缓冲池位于数据访问层和分布式存储层的中间，所有的数据访问都要经过缓冲池。分布式缓冲池需要保证页面数据的一致性和页面查找访问的高效性，是云原生数据库实现透明多写，内存资源弹性的关键模块。具体设计如下：
1、本地内存和远程内存两级缓存 本地内存和远程内存的读写时延差别非常大(30~100ns 和 800ns~5us的区别), 哪些页面在本地缓存，哪些页面在远程缓存非常关键。同时还有一个重要的因素需要考虑，那就是页面是否在多个计算节点被读写，因此云原生数据库把页面分为三大类，一类是页面在多个计算节点被读写(Heap页面，FSM页面)，适合存放在远程内存里，页面地址共享；一类是页面大概率被读，几乎不被修改或者极低概率被修改(索引的非叶子页面，系统表的页面)适合存放在本地内存；另外一类是页面只在固定的单节点被读写，(智能路由优化后索引的叶子节点页面)，适合存放在本地内存。
理想的页面分布情况如下图所示：
图2 理想页面分布示意图
2、页面查找机制 每个页面缓存对应一个元信息，称为page directory(PD)，它描述了页面的最新版本在哪个节点，也就是page owner node(PON)，页面是否是共享的远程页面地址，以及远程页面地址。PD 也是分布在各个计算节点上，每个计算节点管理一部分PD, 采用一致性Hash的方法管理PD。
图3 页面查找示意图
索引页面按照Range自动汇聚算法，根据SQL访问把相关页面汇聚到一个节点，提高索引访问的本地内存的亲和性。
索引的叶子节点本身就是从左到右按照索引key的大小顺序存放的，因此很容易根据索引的叶子节点自动划分Range，SQL优化器的路由模块按照Range路由就可以让索引页面按照Range汇聚到SQL节点的本地缓存里实现亲和性访问。针对多个索引的多个Range的亲和性场景，优先选择主键作为亲和性的Range路由。
3、支持远程内存池, 内存独立扩展。 云原生数据库在云上支持各种业务负载，CPU、MEM和Storage的配比很难一开始就配置合适，有的是计算密集型的业务，有的是内存密集型的业务，有的是存储容量大的业务。针对各类业务场景，云原生数据库需要提供精细的各种资源的独立扩展能力。支持远程内存池，实现了集群物理内存独立扩展。内存池是可选服务，也可以跟计算节点合部署。
4、本地缓存远程页面地址，页面地址共享，全RDMA/UB单边读写。 页面如果频繁在多个节点被读写，为了避免页面在多个节点之间传来传去，采用共享页面地址的方式，SQL节点Local buffer pool里缓存页面的远程地址，通过全单边读写远程页面。在设计上需要考虑读写页面的Latch问题以及写页面过程中故障的处理问题。对于exclusive latch采用lock bit和lock owner node的方式表示，对于share latch，lock bit和lock owner node的方式无法表示， 因为可以有很多发起者同时持有share latch。因此云原生在设计上采用lock-free无锁机制读取页面。
5、Lamport LSN 在云原生数据库多写的架构下，每个节点有独立的日志流，本地日志流的LSN是本地分配维护的，本地有序逻辑递增，页面在各个SQL节点之间分别被修改的情况下，需要保证在新节点上修改页面产生的日志LSN要比这个页面之前的日志LSN要大才可以，也就是说从多个节点修改过同一个页面，日志虽然在各个节点独立的日志流里，但是要维护修改页面的日志顺序LSN。Redo日志在多个SQL节点都存在，需要保证这些日志的LSN顺序，才可以保证日志回放的顺序正确性，因此采用Lamport LSN。这部分的详细设计请参照文档&lt;&lt; GaussDB Kernel TD V600R001C00 XLog日志系统设计说明书.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92839a17664a72f9650f9e53661b979e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b120fcb439eafc20ffccaec3e52db46d/" rel="bookmark">
			【Win】双系统新体验：Hyper-V上macOS安装攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在虚拟化的世界里，Hyper-V是探索不同操作系统的一扇大门。尽管macOS并不是Hyper-V官方支持的来宾操作系统，但这并未阻挡技术探索者的脚步。他们通过不懈努力，开辟出了一条条通往macOS的非官方路径。这些路径或许曲折，却为那些渴望在Windows环境中体验macOS魅力的用户打开了一扇窗。根据最新的技术指南和项目信息，我们了解到：
CPU支持限制：目前，只有Intel "i"系列CPU得到支持，Xeon、Pentium、Celeron和AMD CPU尚未兼容。macOS版本支持：从macOS 10.8 Mountain Lion到最新的macOS 14 Sonoma，多数版本均可在Hyper-V上安装和运行。 Hyper-V 推荐设置 组件：最低配置推荐配置CPU：2个虚拟核心4个以上虚拟核心GPU：128MB图形内存1GB以上图形内存内存（RAM）：macOS 10.15及更早版本需要4GB，11及更高版本需要8GB8GB以上固态硬盘（SSD）：30GB60GB以上无线网络（WiFi）：使用默认交换机使用默认交换机电池（Batt）：不适用不适用USB：不适用不适用 安装指南 前提条件 安装Hyper-V 确保您的Windows 10或11电脑上已经安装了Hyper-V。如果尚未安装，可以通过“控制面板”中的“程序和功能”启用Hyper-V功能。 安装Python 在您的系统上安装Python，这是执行某些脚本和工具所必需的。 下载UEFI.VHDX 从提供的存储库下载最新的UEFI.VHDX zip或7z文件，并将其提取到您选择的方便访问的位置。下载地址：https://github.com/balopez83/macOS_On_Hyper-V/releases/tag/2.3.0 获取OpenCore 下载最新版本的OpenCore。在安装过程中，我们将使用OpenCore工具箱中的一个工具。下载地址：https://github.com/acidanthera/OpenCorePkg/releases 准备UEFI.VHDX 解压前提条件中下载得两个工具包，获得一个UEFI.VHDX文件和以及OpenCore的文件夹。使用此页面上的说明下载您要安装的操作系统版本的恢复映像。将com.apple.recovery.boot文件夹与您之前下载的UEFI.VHDX一起保存。
右键点击您刚刚下载的com.apple.recovery.boot文件夹，点击“复制”。然后双击UEFI.VHDX。这将挂载UEFI驱动器并打开它。
在刚刚打开的挂载的UEFI驱动器资源管理器窗口中右键点击，并点击“粘贴”。现在您应该有三个文件夹。
转到“此电脑”，右键点击挂载的UEFI驱动器，然后点击“弹出”。
创建Hyper-V虚拟机 启动Hyper-V并创建一个新的虚拟机（不要使用Hyper-V快速创建）。
为您的新虚拟机命名，如果愿意，您可以更改其存储位置。点击下一步。
选择第2代。这不适用于第1代。
增加启动内存。4GB是Catalina及更早版本的最低要求；8GB是Big Sur及更高版本的最低要求。您应该保持动态内存选项被选中。点击下一步。
点击“连接”下拉菜单，选择“默认交换机”。
为您的“虚拟硬盘”命名，并更改驱动器大小为您喜欢的尺寸。驱动器会扩展到您在这里选择的最大大小，所以在选择大小时请注意。您可以更改虚拟驱动器的位置。点击下一步。
选择“稍后安装操作系统”，然后点击下一步。
点击完成。
Hyper-V完成虚拟机设置后，继续进入下一步骤。
在Hyper-V中安装macOS 右键点击您的新Hyper-V，然后点击设置。按顺序更改以下设置。
调整以下内容：在安全选项下，如果启用了“启用安全启动”，请取消选中。您可以启用或禁用TPM，因为我不知道它对虚拟机有任何负面影响。
禁用检查点，否则您在Hyper-V使用中稍后会遇到问题。
在集成服务下选择所有选项。
调整以下内容：在SCSI控制器下选择硬盘驱动器，然后点击“添加”。在虚拟硬盘下点击“浏览”。找到并选择您之前下载并更新的UEFI.VHDX。
点击应用。不要关闭窗口继续调整以下内容：在固件下调整启动顺序，使UEFI.VHDX硬盘驱动器排在第一位，其他硬盘驱动器排在第二位。如果您有网络或其他选项，请将它们移到列表的末尾。
点击应用，然后点击确定。
双击新的虚拟机。窗口将打开，在这一点上，您应该点击“开始”。
如果一切正确完成，您应该很快就会看到OpenCore启动菜单，如果没有预先选择，请选择macOS恢复并启动它（您可能需要按空格键来显示此选项）。
这将需要一段时间，但最终安装程序将加载。在启动过程中，它可能看起来在早期启动时冻结，但它会继续。如果它在启动过程的后期看起来冻结，您可以点击重置按钮重新启动。它可能需要最多5分钟才能启动，所以请耐心等待。根据您尝试安装的操作系统，您可能需要重置几次才能成功启动。
一旦恢复加载，打开磁盘工具。
选择您之前创建的“Msft虚拟磁盘介质”驱动器（应该是空白的，没有分区），并将其格式化为APFS，并为分区命名（例如“MacOS”）。
格式化后，退出磁盘工具。
启动macOS安装程序，选择您刚刚格式化的新的“macOS”分区。接受并继续点击，直到开始安装。
这次安装将需要一些时间，并且在途中可能会有几次内核崩溃。继续让它重新启动，不要停止虚拟机。最终，安装将完成，您将看到新macOS Hyper-V的初始个性化设置屏幕，
通过一系列的设置后顺利进入macOS的桌面，就是没有桌面壁纸，不知道为什么，还没细细研究。最后将得到：
恭喜您完成了在Hyper-V上安装macOS的整个过程！现在，您已经拥有了一个在Windows宿主机上运行的macOS虚拟机。虽然macOS在Hyper-V上运行可能并不完美，可能会遇到一些小问题或性能限制。但正是这些挑战，让我们的技术旅程更加充满乐趣和成就感。
参考 https://github.com/balopez83/macOS_On_Hyper-Vhttps://github.com/acidanthera/OpenCorePkghttps://dortania.github.io/OpenCore-Install-Guide/installer-guide/windows-install.html#downloading-macos 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea8e218df2ebcd6dd56c13d09c1ed6d2/" rel="bookmark">
			urllib3版本与系统openssl版本不兼容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 urllib3版本与系统openssl版本不兼容 报错信息 ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the ssl
解决办法 安装urllib3的1.x.xx版本，如：
pip install urllib3==1.25.11 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/782600001319acc9efe68fead750d85b/" rel="bookmark">
			如何抓取 GitHub：实用教程 2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub 是互联网上最重要的技术知识来源之一，对于构建复杂应用程序的开发人员来说尤其如此。跟随本指南学习如何提取这些宝贵的数据，毫不费力地紧跟最新技术趋势。
了解 GitHub 数据
开源项目文化为开发人员提供了许多分享、贡献和合作的机会，这些项目塑造了技术的未来。GitHub 就是这样一个知识共享中心。
这个想法基于 Git 系统，它提供了一种简单的方法来维护和版本控制你的代码，并与其他开发人员在共享项目上进行协作。在更大的范围内，几乎任何人都可以为大型项目做出贡献、提出问题或重复使用代码作为自己想法的起点（也称为分叉）。
每个项目都位于其专用的资源库中。这是一个保存了项目所有信息的页面，包括项目描述、代码文件、版本、更新日志、许可证、贡献者、使用的编程语言等等。这些项目就是我们在 GitHub 上搜索信息时要找的内容。让我们来看看其中最有价值的几项：
代码文件。代码文件是每个版本库的基础和黄油，包含整个项目的文件夹和文件。任何人都可以通过它了解应用程序在幕后是如何工作的，查看脚本文件，以及它们是按照怎样的逻辑运行的。README。默认情况下，所有软件源都需要有一个 README 文件。顾名思义，该文件希望你在继续前行前阅读它，因为它包含了项目的所有必要信息。该文件包括说明、设置和启动项目的分步指南，以及其他有用的信息和提示。叉和星。GitHub 并不完全是一个社交媒体平台，但如果它有 "赞 "和 "分享 "的话，这些就相当于。星星只是人们收藏或支持项目的一种方式–星星越多，项目越受欢迎，证明代码对许多人有用且有价值。分叉代表该版本库被分叉的次数。换句话说，它显示了有多少克隆库将其作为启动项目或构建、更新或修复原始代码的基础。问题和拉取请求。如果你曾在一个团队中参与过软件项目，你就会知道大多数交流都是抱怨、争论和修复代码。这正是 GitHub 所提供的，因此开发人员可以在这里找到家的感觉。问题板块允许人们提交问题单，供贡献者修复。更多乐于助人的人则会亲自动手，提交拉取请求。这些请求是接受他们对代码某部分的修改，以修复或改进代码。 总而言之，GitHub
提供了大量宝贵的技术数据。从大公司到个人项目，每个版本库中都有有用的信息。让我们来学习如何有效地收集和分析这些数据，以满足您的业务或个人需求。
选择正确的工具
有许多工具可用于 GitHub 搜索。你可以选择标准的 Requests + Beautiful Soup 组合，也可以选择 Scrapy 这样的一体化解决方案。还有一些开源项目（如 github3.py）提供了与 GitHub API 交互的增强方法。本指南将只详细介绍其中的几种方法，但请记住，你所选择的工具完全取决于你的个人选择、需求和可用功能。
首次自助交易请使用代码 “CSDN50”！https://bit.ly/4d5HeRK 请求提供美汤
如果你尝试过网络搜刮，那么 Requests 和 Beautiful Soup 这两个名字可能不会陌生。它们是目前最流行的 Python 库之一，提供简单的语法和强大的功能，可以向网站发出请求，并有效地从中抓取和解析信息。下面是一个代码示例，说明如何解析任意资源库的 HTML：
代码
脚本会将整个页面的 HTML 代码打印到控制台中。更准确地说，您可以利用 Beautiful Soup 的各种方法，如 find()。下面是一个仅提取 "关于 "部分的示例：
代码
这种方法可以顺利地从 GitHub 仓库中提取任何内容。不过，如果试图获取其中一条提交信息，就会遇到脚本返回 None 的问题。要找出原因，我们可以禁用 JavaScript 查看网站。看起来就是这样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/782600001319acc9efe68fead750d85b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc17eb3d2b64d51ab1095a5395573f63/" rel="bookmark">
			【Python】类和对象高级特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
类变量与实例变量
类方法
静态方法
私有属性和方法
多重继承
元类
描述符
总结
前言 在前一篇文章中，我们讨论了 Python 类和对象的基本概念。本文将深入探讨一些高级特性，这些特性可以帮助你更有效地使用 Python 进行面向对象编程。
类变量与实例变量 类变量是属于类的，所有实例共享同一份数据；实例变量是属于单个实例的，每个实例都有自己的数据。
class Car: wheels = 4 # 类变量 def __init__(self, brand, model): self.brand = brand # 实例变量 self.model = model # 类变量可以在类级别访问 print(Car.wheels) # 输出: 4 # 创建两个实例 car1 = Car("Toyota", "Corolla") car2 = Car("Honda", "Civic") # 修改类变量会影响所有实例 Car.wheels = 5 print(car1.wheels) # 输出: 5 print(car2.wheels) # 输出: 5 类方法 类方法是一种特殊类型的方法，它使用 @classmethod 装饰器定义，并且必须接受 cls 作为第一个参数，代表类本身。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc17eb3d2b64d51ab1095a5395573f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58b7db692bfc3fc98febe890e214664/" rel="bookmark">
			普通人当前可以入局AIGC行业吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、行业前景1.人工智能2.大数据3.物联网4.云计算 二、职业选择1.引言2.职业选择（1）机器学习工程师（2）云计算专家（3）数据工程师（4）人工智能产品经理 一、行业前景 AIGC（人工智能与大数据、物联网、云计算）行业的前景非常广阔和充满潜力。根据最新的研究报告和市场趋势，
可以预见以下几个方面的前景:
1.人工智能 随着技术的不断进步，人工智能将成为未来的关键驱动力。AI在各个领域的应用将越来越广泛，包括自动驾驶、智能家居、医疗保健、金融服务等。AIGC行业将在人工智能的发展中扮演重要角色，为各个领域提供技术支持和解决方案。
2.大数据 随着信息时代的到来，大数据已经成为企业和机构的重要资产。AIGC行业将为企业提供大数据的分析和处理解决方案，帮助企业更好地理解和利用自己的数据。大数据分析将在市场调研、个性化推荐、风险管理等方面发挥重要作用。
3.物联网 随着物联网技术的快速发展，各种设备和传感器都可以互联互通。AIGC行业将为物联网提供关键的技术支持和解决方案，包括设备连接、数据传输、安全保障等。物联网的普及将为各个行业带来更高效的运营和更智能的服务。
4.云计算 云计算已经成为企业和个人的重要工具，提供了灵活、高效和可扩展的计算资源。AIGC行业将为云计算提供安全和可靠的解决方案，包括数据存储、资源管理、网络安全等。云计算将继续发展壮大，为各个行业带来更多的创新和机会。
总的来说，AIGC行业的前景非常广阔，将对社会经济的各个领域产生巨大的影响。随着技术不断进步和应用的拓展，AIGC行业将继续发展壮大，并带来更多的创新和机会。
二、职业选择 1.引言 近年来，人工智能、大数据和云计算等领域的高速发展，使得AIGC（人工智能、大数据、云计算）行业成为一个备受瞩目的领域。相对于过去，普通人现在是否有机会入局AIGC行业？本文将探讨这个问题，并指出进入行业后可以从事的多种方向，为那些对此行业充满兴趣的普通人提供一些启示。
2.职业选择 （1）机器学习工程师 机器学习工程师是应用机器学习算法并构建模型的专家。他们负责开发和训练机器学习模型，并实现算法在实际场景中的应用。成为机器学习工程师需要深入了解机器学习算法，并具备良好的编程能力。
（2）云计算专家 云计算已经成为现代IT基础设施的核心，因此，云计算专家在AIGC行业中非常受欢迎。他们负责设计和管理云计算架构，确保系统的高效性和可靠性。成为云计算专家需要熟悉云计算平台和技术，同时具备网络和系统管理的知识。
（3）数据工程师 数据工程师是负责处理和管理大数据的专家。他们使用各种工具和技术来收集、清洗和存储海量的数据，并为数据科学家和机器学习工程师提供可靠的数据支持。成为数据工程师需要具备良好的编程能力和数据处理技术。
（4）人工智能产品经理 随着人工智能技术的发展，人工智能产品经理也成为了一个重要的角色。他们负责从市场需求和技术可行性的角度，制定人工智能产品的策略和路线图，并协调各个团队的工作。成为人工智能产品经理需要具备产品管理和技术背景，并具备良好的沟通和协调能力。
普通人可以入局AIGC行业，但需要具备相应的技术背景和知识。然而，AIGC行业的发展迅猛，给了普通人参与其中的机会。进入行业后，普通人可以选择从事数据科学家、机器学习工程师、云计算专家、数据工程师或人工智能产品经理等多种方向，根据自己的兴趣和能力进行职业发展。因此，普通人完全可以通过学习和不断提升技能，实现自己在AIGC行业的梦想。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe37d8ae408c0637772cd21d4d810ab/" rel="bookmark">
			AIGC安全与伦理问题【技术挑战与解决方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文收录于专栏：精通AI实战千例专栏合集
https://blog.csdn.net/weixin_52908342/category_11863492.html 从基础到实践，深入学习。无论你是初学者还是经验丰富的老手，对于本专栏案例和项目实践都有参考学习意义。
每一个案例都附带关键代码，详细讲解供大家学习，希望可以帮到大家。正在不断更新中~
一.AIGC安全与伦理问题【技术挑战与解决方案】 近年来，人工智能生成内容（AIGC）技术取得了巨大的进步，特别是在自然语言处理、图像生成和视频合成等领域。然而，随着这些技术的普及，AIGC的安全与伦理问题也逐渐成为亟待解决的挑战。本文将探讨AIGC技术在安全与伦理方面面临的问题，并提出可能的解决方案。
AIGC的安全问题 1. 数据隐私和安全 AIGC模型通常需要大量的训练数据，这些数据可能包含个人隐私信息。如果这些数据在训练过程中未能得到适当的保护，可能导致数据泄露和滥用。以下是一个简单的数据脱敏示例：
import pandas as pd # 示例数据 data = {'name': ['Alice', 'Bob', 'Charlie'], 'age': [25, 30, 35], 'email': ['alice@example.com', 'bob@example.com', 'charlie@example.com']} df = pd.DataFrame(data) # 数据脱敏函数 def anonymize_data(df): df['name'] = 'REDACTED' df['email'] = 'REDACTED' return df # 脱敏后的数据 df_anonymized = anonymize_data(df) print(df_anonymized) 2. 生成虚假信息 AIGC技术可以生成高度逼真的文本、图像和视频，这给虚假信息的传播提供了便利。例如，Deepfake技术可以生成看似真实的视频，可能用于政治诽谤或诈骗。
3. 模型滥用 开放的AIGC模型可能被恶意使用。例如，GPT-3可以生成欺诈性邮件或钓鱼网站内容，从而增加网络攻击的风险。
AIGC的伦理问题 1. 偏见与歧视 AIGC模型的训练数据如果包含偏见，生成的内容也可能反映这些偏见。例如，如果训练数据中存在性别歧视，生成的文本可能也会表现出性别歧视。
2. 内容所有权 AIGC生成的内容的版权问题目前尚未明确。如果模型生成的内容与某个艺术家的作品非常相似，是否会侵犯版权？
3. 社会责任 AIGC技术的开发者和使用者需要对其可能带来的社会影响负责。例如，Deepfake技术的开发者需要考虑如何防止其技术被用于恶意目的。
解决方案 1. 加强数据保护 使用数据脱敏和加密技术保护训练数据，确保个人隐私信息不被泄露。可以采用差分隐私技术来保护数据隐私：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe37d8ae408c0637772cd21d4d810ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62719a26174df0e80a797b253a11293/" rel="bookmark">
			【Chrome】用户可以手动管理和删除第三方Cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Google Chrome浏览器中，用户可以手动管理和删除第三方Cookie。以下是删除第三方Cookie的具体步骤：
方法一：通过浏览器设置删除第三方Cookie 打开Chrome浏览器：
打开你的Google Chrome浏览器。
访问设置页面：
点击右上角的三点菜单（更多选项），然后选择“设置”。
访问隐私和安全设置：
在设置页面左侧的导航栏中，点击“隐私和安全”。
进入Cookie和其他网站数据设置：
在“隐私和安全”页面中，选择“Cookie和其他网站数据”。
阻止第三方Cookie：
在“Cookie和其他网站数据”页面，选择“阻止第三方Cookie”。这将阻止所有第三方Cookie被存储在你的浏览器中。
清除现有Cookie：
如果你想删除已经存储的第三方Cookie，点击“查看所有Cookie和网站数据”。在这里，你可以看到所有存储在浏览器中的Cookie。可以逐个删除，或者点击“全部删除”来清除所有Cookie。
方法二：通过浏览器开发者工具删除特定的第三方Cookie 打开开发者工具：
在Chrome浏览器中，按 Ctrl + Shift + I（Windows）或 Cmd + Option + I（Mac）打开开发者工具。你也可以通过右键点击页面并选择“检查”来打开。
访问应用程序标签：
在开发者工具窗口中，点击顶部的“应用程序”标签。
查看Cookie：
在左侧的导航栏中，展开“存储”部分并选择“Cookie”。这里你会看到所有存储在浏览器中的Cookie，按域名分类。
删除特定Cookie：
点击你想删除的域名，选择需要删除的Cookie条目，右键点击并选择“删除”。
方法三：使用隐私扩展程序 Chrome浏览器支持多种隐私扩展程序，这些扩展程序可以帮助管理和删除第三方Cookie。例如：
Privacy Badger：自动检测并阻止跟踪Cookie。uBlock Origin：不仅阻止广告，还可以阻止跟踪Cookie。Cookie AutoDelete：自动删除不必要的Cookie。 方法四：使用隐私浏览模式 打开隐私浏览窗口：
点击右上角的三点菜单（更多选项），选择“新建隐身窗口”。你也可以按 Ctrl + Shift + N（Windows）或 Cmd + Shift + N（Mac）快捷键打开。
隐私浏览模式特点：
隐私浏览模式下，浏览器不会保存浏览历史记录、Cookie和网站数据。所有的第三方Cookie将在你关闭隐私浏览窗口时自动删除。
总结 通过以上步骤，你可以有效地管理和删除Google Chrome浏览器中的第三方Cookie，从而提升你的隐私保护水平。如果你需要定期管理Cookie，建议使用隐私扩展程序或隐私浏览模式来简化这个过程。
如果还有其他问题或需要进一步的帮助，请告诉我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725030841c24d6fa7b2d5ec45d06dc5a/" rel="bookmark">
			SiliconCloud上新：GLM-4-9B，通用能力超越Llama 3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，智谱发布了第四代 GLM 系列开源模型：GLM-4-9B。
GLM-4-9B 系列模型包括：基础版本 GLM-4-9B（8K）、对话版本 GLM-4-9B-Chat（128K）、超长上下文版本 GLM-4-9B-Chat-1M（1M）和多模态版本 GLM-4V-9B-Chat（8K）。GLM-4-9B 模型具备了更强大的推理性能、更长的上下文处理能力、多语言、多模态和 All Tools 等突出能力。
目前，SiliconCloud已上线GLM-4-9B-Chat开源模型。欢迎试用：
https://cloud.siliconflow.cn/models/text/chat/17885302522
注意！！！GLM-4-9B-Chat已进入“6.18购物狂欢节”福利包：“每人送3亿token”。注册即可畅玩（截止6月18日23:59）：
www.siliconflow.cn/zh-cn/siliconcloud
据智谱介绍，在预训练方面，他们引入了大语言模型进入数据筛选流程，最终获得了10T高质量多语言数据，数据量是ChatGLM3-6B模型的3倍以上。同时，它们采用了FP8技术进行高效的预训练，相较于第三代模型，训练效率提高了3.5倍。在有限显存的情况下，他们探索了性能的极限，并发现6B模型性能有限。因此，在考虑到大多数用户的显存大小后，他们将模型规模提升至9B，并将预训练计算量增加了5倍。
Github：https://github.com/THUDM/GLM-4
关于SiliconCloud
SiliconCloud是集合主流开源大模型的一站式云服务平台，为开发者提供更快、更便宜、更全面的模型API。
目前，SiliconCloud已上架包括GLM-4-9B-Chat、DeepSeek V2、Mixtral、Llama 3、Qwen、SDXL、InstantID在内的多种开源大语言模型、图片生成模型，支持用户自由切换符合不同应用场景的模型。同时，SiliconCloud提供开箱即用的大模型推理加速服务，为生成式AI应用带来更高效的用户体验。
真正在乎大模型推理性能和成本的开发者，绝不会错过SiliconCloud。更何况，现在还送3亿token。快试试吧：
www.siliconflow.cn/zh-cn/siliconcloud
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3bcfc0cf838c3e5ee39f181590f51a4/" rel="bookmark">
			【postgresql初级使用】触发器的enable与disable，可以自动化精准管理触发器，避免重写触发器复杂逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		触发器的enable与disable ​专栏内容：
postgresql使用入门基础手写数据库toadb并发编程 个人主页：我的主页
管理社区：开源数据库
座右铭：天行健，君子以自强不息；地势坤，君子以厚德载物.
文章目录 触发器的enable与disable概述 禁用触发器 禁用语法 案例演示 启用触发器 启用语法 案例演示 总结 结尾 概述 最近几篇文章分享了触发器相关内容，有行级触发器，也有语句级触发器，postgresql还支持视图上的INSTEAD OF触发器。
这么多的触发器，如何进行维护呢？除了删除drop 触发器之外，还可以对暂时不用的触发器禁用disable，使用时再启用enable，这样方便快捷，不用重写。
禁用触发器 先来看下禁用触发器，禁用触发器，并不是将它删除，触发器的定义仍然保留在数据库中，只是在事件触发时不再响应了。
禁用语法 对于普通触发器，都是定义在表对象上，可以禁用某个表上的触发器，SQL语法如下：
ALTER TABLE table_name DISABLE TRIGGER [ trigger_name | ALL | USER ] 说明
通过alter table命令对表对象进行修改；disable trigger后面指定触发器范围：
指定单个触发器的名称;
ALL, 该表上所有的触发器，包括系统生成的，如表的唯一约束或外键或排它约束生成的触发器；此时需要超级权限的用户才能执行；
USER，该表上的所有触发器，除了系统生成的，也就是只包含用户自定义的； 案例演示 结合《条件触发器》一文中的案例，
查看orders表上的触发器如下。
postgres=&gt; \d orders Table "senlleng.orders" Column | Type | Collation | Nullable | Default --------------+-----------------------+-----------+----------+------------------------------ order_id | integer | | not null | generated always as identity customer_id | integer | | not null | total_amount | numeric | | not null | 0 status | character varying(20) | | not null | Indexes: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3bcfc0cf838c3e5ee39f181590f51a4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/249/">«</a>
	<span class="pagination__item pagination__item--current">250/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/251/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>