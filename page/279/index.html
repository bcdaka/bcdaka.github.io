<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d7337b74d3a31a09b1dd2ddc8f307c/" rel="bookmark">
			2024年陕西省人工智能(大数据)产业链链主企业申报条件程序、材料和时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、申报条件
1.属地原则。依法在陕西省境内登记设立,具有独立法人资格的企业。
2.行业地位。位于人工智能(大数据)产业链关键环节,具有较高的产业链主导地位,在所属的产业链中具备影响力和重要性。
3.规模实力。主营业务收入或产值规模在人工智能(大数据)产业链企业中位于前列,主导产品市场占有率较高。
4.带动能力。具有较强的全产业链资源整合能力,核心配套供应商数量和本地配套率相对突出。
5.创新能力。具有较强的研发能力,技术水平业内领先或在省内同行业处于前列,主导产品具有良好发展前景。
6.其他要求。积极履行社会责任,具有良好的企业品牌形象。近三年内,无不良信用记录,无环境、质量、安全等违法违规记录。
符合上述基本条件,获得国家级或省级制造业单项冠军、专精特新、独角兽等荣誉称号的,可优先推荐为链主企业。
二、申报程序
1.组织申报。各地市工业和信息化主管部门(人工智能和大数据产业主管部门)收到本通知后,组织符合条件的人工智能(大数据)企业积极参与申报工作。
2.企业报送。人工智能(大数据)企业按要求填写申报资料(见附件),并提交至各地市工业和信息化主管部门(人工智能和大数据产业主管部门)审核。
3.审核推荐。各地市工业和信息化主管部门(人工智能和大数据产业主管部门)按照申报条件对申报企业进行审核筛选,向省人工智能(大数据)产业链工作专班报送推荐链主企业相关情况。各地市本次链主企业具体推荐户数见附件1。
4.复核审定。省人工智能(大数据)产业链工作专班建立链主企业后备库,经评审后,报制造强省建设领导小组办公室进行复核,提出链主企业建议名单。
5.公示发布。通过省工业和信息化厅网站向社会公示,公示期不少于7日。公示无异议的,上报省政府审定。
6.认定授牌。链主企业名单经省政府审定同意后,由制造强省建设领导小组办公室向社会公布认定结果并向企业授牌。
三、申报资料
1.企业需向各地市工业和信息化主管部门(人工智能和大数据产业主管部门)提交的申报资料:
(1)附件2-7所需资料;
(2)企业“多证合一”营业执照(副本)复印件,经会计师事务所审计的2023年度审计报告复印件(正文、报表和附注每页均需有二维码)、企业完税证明,信用中国查询报告;
(3)有效专利、核心自主知识产权目录,质量认证、质量荣誉、品牌荣誉等相关材料及目录;
(4)企业认为需提供的其它材料;
(5)所有资料以企业申报书形式提交(一式6份)。
2.各地市工业和信息化主管部门(人工智能和大数据产业主管部门)需向省人工智能(大数据)产业链工作专班提交复核的资料:
(1)加盖各地市工业和信息化主管部门(人工智能产业主管部门)公章的“关于推荐产业链链主企业的报告”。报告需体现但不限于体现以下内容:推荐企业为链主企业的原因说明,组织开展申报工作的程序说明,链主企业产业链规模地位、主导产品竞争力、链主企业产业链集聚带动能力说明等;
(2)各地市工业和信息化主管部门(人工智能产业主管部门)组织审核,推荐企业成为链主企业的相关过程性资料;
(3)推荐链主企业相关情况汇总表(附件8);
(4)推荐链主企业申报书(一式6份);
(5)其它认为需提供的资料。
以上就是小编将为大家具体讲解的内容，希望会对大家有个帮助!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acad6202ef856b5a16e4f1457787499b/" rel="bookmark">
			使用 Ollama框架 下载和使用 Llama3 AI大模型的完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Ollama框架下载和使用Llama3 AI大模型的完整指南如下：
一、Ollama框架介绍
Ollama是一个开源框架，专为在本地机器上便捷部署和运行大型语言模型（LLM）而设计。它提供了一套简单的工具和命令，使任何人都可以轻松地启动和使用各种流行的LLM，如GPT-3、Megatron-Turing NLG和WuDao 2.0。Ollama的主要特点包括：
简化部署：使用Docker容器技术来简化大型语言模型的部署和管理，用户只需简单的命令即可启动和停止模型。丰富的模型库：提供了丰富的预训练模型库，涵盖了各种自然语言处理任务，如文本生成、翻译、问答等。跨平台支持：支持多种操作系统，包括Windows、macOS和Linux，满足不同用户的需求。灵活的自定义：允许用户根据自己的需求调整模型的行为。 二、安装Ollama
访问Ollama的官方网站或GitHub仓库，选择与操作系统相匹配的下载链接进行安装。下载完成后，双击安装包进行安装。对于Windows用户，可以从官方网站下载预览版。安装完成后，Ollama的图标将出现在系统任务栏的图标区中，方便随时调用和管理。 三、下载和使用Llama3 AI大模型
访问Ollama的模型库页面（如https://ollama.com/library），搜索并选择需要使用的Llama3模型。在命令行或终端中，输入相应的命令来下载和运行Llama3模型。例如，使用ollama run llama3命令来启动Llama3模型。等待模型下载与加载。根据网络连接和计算机性能，下载和加载时间可能有所不同。模型加载完成后，即可在本地使用Llama3进行自然语言处理任务。你可以通过输入提示（Prompt）来让Llama3生成相应的文本或执行其他任务。 四、注意事项
确保你的计算机具有足够的计算资源和存储空间来运行大型语言模型。在使用大型语言模型时，注意保护个人隐私和数据安全。如果遇到任何问题或错误，可以查阅Ollama的官方文档或社区论坛寻求帮助。 以上是使用Ollama框架下载和使用Llama3 AI大模型的完整指南。通过遵循这些步骤，你可以轻松地在本地部署和运行Llama3模型，并利用其强大的自然语言处理能力来执行各种任务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f6f733345de55b9fa77cef720bd5b7/" rel="bookmark">
			经典的带环链表问题(链表补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环形链表1 运用快慢指针的方法，fast ,slow从头节点出发，快指针走两步，慢指针走一步，若有环，快指针先进环，后续如果慢指针和快指针相遇，则链表带环。转换成了追击问题。
struct ListNode { int val; struct ListNode *next; }; typedef struct ListNode LN; bool hasCycle(struct ListNode *head) { LN*slow,*fast; slow=fast=head; while(fast &amp;&amp; fast-&gt;next){ slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast) return true; } return false; } 思考：为什么一定会相遇，会不会错过，永远追不上？若快指针走三步，四步呢？
证明：假设链表就是有环，slow（1步）进环时，fast（两步）与slow的距离为N,追击过程中，每走一次，N都会-1，最后到0。本题的思想证明，距离为0就是追上了。
若fast走三步，同样假设slow进环时，fast与slow相差N,
fast追击slow过程中，距离变化一直-2,但是最后结果要注意，N为偶数时，最后变为0，N为奇数时，最后为-1.而当距离为-1时，两指针会错过，进行新一轮追击。这时假设环的长度为C。新的距离就变成C-1了，这是又要将C分为奇数，偶数进行讨论。
那么是否存在N是奇数且C是偶数的情况呢，
假设从出发位置到进环的位置相差L，slow进环时，fast已经走了x圈，且fast与slow相差N:
进环时：slow走的距离-&gt;L
fast走的距离-&gt;L+x*C+C-N
fast的距离应该为slow的三倍:3*L=L+x*C+C-N 化简为：2*L=(x+1)*C-N 若要满足该等式，若C是偶数,N必须是偶数。若N是奇数,如果C是偶数，则（x+1）*偶数一定是偶数，偶数-奇数！=偶数。
所以上述条件不成立，故永远追不上的条件不成立。
结论：一定能追上。
N是偶数第一轮追上。N是奇数第一轮追不上，C是奇数，第二轮追上。
其他走四步等的条件证明过程类似。
环形链表2 本题相较于第一个环形链表题，多了返回节点位置的步骤，所以最初思路也是通过快慢指针，快慢指针相遇，则证明有环存在，然后将两指针相遇点记为meet，再继续走，此时头节点也开始移动，meet与head相遇点就是环的最初节点。
证明过程如下：
struct ListNode { int val; struct ListNode *next; }; typedef struct ListNode LN; struct ListNode *detectCycle(struct ListNode *head) { LN*slow,*fast,*meet; slow=fast=head; while(fast &amp;&amp; fast-&gt;next){ slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast){ meet=slow; while(meet!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f6f733345de55b9fa77cef720bd5b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd9dbe6009cb6acb502d38d7e745f178/" rel="bookmark">
			精通AI虚拟数字人制作与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 精通AI虚拟数字人制作与应用 AI虚拟数字人是人工智能技术与计算机图形学结合的产物，已经在诸多领域展示了其潜力。无论是虚拟主播、虚拟客服，还是虚拟助手，AI虚拟数字人都能提供逼真的交互体验。本文将介绍如何制作和应用AI虚拟数字人，并提供一些示例代码，帮助你快速入门。
1. 虚拟数字人的基本组成 一个完整的AI虚拟数字人通常包括以下几个部分：
视觉模型：3D模型或2D动画，用于展示虚拟人的外观。语音合成：将文本转换为语音，使虚拟人能够发声。自然语言处理（NLP）：理解用户输入并生成相应的回应。动作驱动：根据语音和情绪驱动虚拟人的面部表情和肢体动作。 2. 创建虚拟数字人的视觉模型 2.1 使用Blender创建3D模型 Blender是一个功能强大的开源3D建模工具，可以用来创建虚拟数字人的3D模型。以下是一个基本步骤，使用Blender创建一个3D角色：
打开Blender，创建一个新的项目。使用基本几何体（如立方体、球体）构建角色的身体各部分。为模型添加材质和纹理。使用骨骼系统（Rigging）为模型添加骨骼，以便之后进行动画处理。 你可以参考Blender的官方文档或教程以获得更详细的指导。
2.2 使用Unity展示3D模型 创建好3D模型后，可以使用Unity引擎展示并进行交互开发。以下是一个在Unity中展示3D模型的简单示例：
using UnityEngine; public class VirtualHuman : MonoBehaviour { public AudioSource audioSource; public Animator animator; void Start() { audioSource = GetComponent&lt;AudioSource&gt;(); animator = GetComponent&lt;Animator&gt;(); } public void Speak(string text) { string filePath = TextToSpeech(text); PlayAudio(filePath); animator.SetTrigger("Speak"); } string TextToSpeech(string text) { // 调用第三方API进行语音合成，返回音频文件路径 return "path_to_audio_file.wav"; } void PlayAudio(string filePath) { AudioClip clip = Resources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd9dbe6009cb6acb502d38d7e745f178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe346a740403660aa35796f1c0278927/" rel="bookmark">
			Java高阶数据结构-----并查集（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🧐一.并查集的基本概念&amp;实例：
🤪二.并查集代码：
😂三：并查集的一些习题：
A.省份数量
B.等式方程的可满足性
🧐一.并查集的基本概念&amp;实例： 并查集概念：将n个不同的元素划分成一些不相交的集合。开始时，每个元素自成一个单元素集合，然后按一定的规律将归于同一组元素的集合合并。在此过程中要反复用到查询某一个元素归属于那个集合的运算。适合于描述这类问题的抽象数据类型称为并查集(union-ﬁnd set)。
有了上面的一定了解，我们再来看一个实例：
比如：某公司今年校招全国总共招生10人，西安招4人，成都招3人，武汉招3人，10个人来自不同的学校， 起先互不相识，每个学生都是一个独立的小团体，现给这些学生进行编号：{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; 给以下 数组用来存储该小集体，数组中的数字代表：该小集体中具有成员的个数。(负号下文解释)
毕业后，学生们要去公司上班，每个地方的学生自发组织成小分队一起上路，于是： 西安学生小分队s1={0,6,7,8}，成都学生小分队s2={1,4,9}，武汉学生小分队s3={2,3,5}就相互认识了，10个 人形成了三个小团体。假设右三个群主0,1,2担任队长，负责大家的出行。
一趟火车之旅后，每个小分队成员就互相熟悉，称为了一个朋友圈。
在公司工作一段时间后，西安小分队中8号同学与成都小分队1号同学奇迹般的走到了一起，两个小圈子的学生相互介绍，最后成为了一个小圈子：
现在0集合有7个人，2集合有3个人，总共两个朋友圈,负数的个数就是集合的个数
注意事项：
我们一般将数组中的元素初始化为-1
(数组的下标:) 数组的下标对应集合中元素的编号
（数组的值array[i]:） 数组中如果为负数，负号代表根，数字代表该集合中元素个数
（数组的值array[i]:）数组中如果为非负数，代表该元素双亲在数组中的下标
并查集能干的事：
查找元素属于哪个集合 沿着数组表示树形关系以上一直找到根(即：树中中元素为负数的位置)
查看两个元素是否属于同一个集合 沿着数组表示的树形关系往上一直找到树的根，如果根相同表明在同一个集合，否则不在
将两个集合归并成一个集合 将两个集合中的元素合并 将一个集合名称改成另一个集合的名称
🤪二.并查集代码： import java.util.*; public class UnionFindSet { public int[] elem; public UnionFindSet(int n){ this.elem = new int[n]; Arrays.fill(elem,-1); } //查询x的根节点，返回根节点的下标 public int findRoot(int x){ if(x &lt; 0){ throw new IndexOutOfBoundsException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe346a740403660aa35796f1c0278927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c5fdf55200f0cb00234a02f8322432/" rel="bookmark">
			JAVA:在IDEA引入本地jar包的方法并解决打包scope为system时发布无法打包进lib的方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引入本地Jar包的步骤 有时maven依耐的包是本地的jar包，此时需要进行以下步骤设置。
步骤1.在pom.xml中添加插件设置,将system范围包含进来，此设置是为了在打包时，本地jar包自动生成到部署包里。(若无法打进包，请参考下文的方案二)
&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt; 步骤2.将本地jar包添加依赖
在项目根目录下新建lib文件夹，把本地jar包放到此目录下，并配置好对应的依赖项groupId、artifactId、version。scope为system，systemPath为jar所在路径，其中project.basedir是项目的所在根目录变量。
&lt;dependency&gt; &lt;groupId&gt;com.ctg.ag.sdk.biz&lt;/groupId&gt; &lt;artifactId&gt;sdkpackage&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;systemPath&gt;${project.basedir}/lib/ag-sdk-biz-SNAPSHOT.jar&lt;/systemPath&gt; &lt;/dependency&gt; 步骤3.添加lib的对应jar包到项目
点击菜单File-&gt;Project Structure-&gt;Modules-&gt;Dependencies,点击底栏的+号，选择JARS or Directories，在弹出的窗口中选中lib目录下的那个本地jar包，确定。
以上步骤完成后，重新install，本地jar包引入完毕。
二、发布时本地包无法打包进部署包的解决方案 上述方案一正常可以将本地jar包文件打包进项目包，但也有无法打包进去的情况，可以用以下方式解决。
在pom.xml中添加resources节点：
1、设置本地jar包所在目录lib
2、指向目标生成目录,本示例是web项目，所以jar包生成目录是/WEB-INF/Lib
3、包含的文件类型为所有jar文件
&lt;!-- 打包时把 自定义lib 目录下的 jar 文件也打包进去 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;${project.basedir}/lib&lt;/directory&gt; &lt;targetPath&gt;../${project.name}/WEB-INF/lib&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;${project.basedir}/src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; 经过此resources的配置后，install后即可生成到项目部署包中。
以上教程完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1866a6e62960944bba84dc43d926eb3/" rel="bookmark">
			C# WPF入门学习主线篇（二十二）—— 样式（Styles）的定义和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# WPF入门学习主线篇（二十二）—— 样式（Styles）的定义和应用 欢迎来到C# WPF入门学习系列的第二十二篇。本篇文章将详细介绍WPF中的样式（Styles）的定义和应用。样式在WPF中起到重要作用，通过样式可以轻松地定义和复用控件的外观和行为，从而提高开发效率和代码的可维护性。
什么是样式？ 样式（Style）是用于定义控件外观和行为的集合。样式通常定义在XAML文件中，可以在多个控件中共享使用。样式可以包括各种属性的设置，如颜色、字体、边距等，以及触发器（Trigger），用于响应特定的事件或状态。
样式的定义 在WPF中，样式通常定义在XAML文件的资源字典中。以下是一个简单的样式定义示例：
&lt;Window x:Class="WpfApp.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="Styles Demo" Height="300" Width="400"&gt; &lt;Window.Resources&gt; &lt;!-- 定义一个按钮的样式 --&gt; &lt;Style x:Key="PrimaryButtonStyle" TargetType="Button"&gt; &lt;Setter Property="Background" Value="Blue"/&gt; &lt;Setter Property="Foreground" Value="White"/&gt; &lt;Setter Property="Padding" Value="10"/&gt; &lt;Setter Property="FontSize" Value="16"/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;Grid&gt; &lt;Button Content="Primary Button" Style="{StaticResource PrimaryButtonStyle}" HorizontalAlignment="Center" VerticalAlignment="Center"/&gt; &lt;/Grid&gt; &lt;/Window&gt; 在上面的代码中，我们在 Window.Resources 中定义了一个名为 PrimaryButtonStyle 的样式，并应用于一个按钮控件。
Setter的使用 Setter 用于设置控件的属性。每个 Setter 包含两个属性：
Property：要设置的属性。Value：属性的值。 应用样式 要应用样式，可以使用 StaticResource 标记扩展引用样式：
&lt;Button Content="Primary Button" Style="{StaticResource PrimaryButtonStyle}" HorizontalAlignment="Center" VerticalAlignment="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1866a6e62960944bba84dc43d926eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb0b8c3ca09e5e001c1a31316b114684/" rel="bookmark">
			Flink 命令行提交、展示和取消作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Flink中，可以通过命令行提交、展示和取消作业。以下是如何使用命令行操作Flink作业的示例：
提交作业 ./flink run -c com.example.MainClass /path/to/your/job.jar [jobArgs] 这里，run是提交作业的命令，-c后面跟着的是主类的全路径，接着是jar文件的路径和可选的作业参数。
展示作业 ./flink list 这将列出当前Flink集群中所有运行的作业。
取消作业 ./flink cancel JOB_ID 以上命令假设你在Flink的命令行工具目录下执行，并且你有正确的权限和配置。如果你的Flink集群部署在远程服务器上，你可能需要通过SSH或其他方式连接到远程服务器，然后执行上述命令。
命令行
启动本地 Flink 集群： ./bin/start-cluster.sh 停止本地 Flink 集群： ./bin/stop-cluster.sh 提交一个作业到 Flink 集群运行： ./bin/flink run examples/streaming/WordCount.jar 停止正在运行的作业： ./bin/flink cancel &lt;job-id&gt; 列出所有运行的作业： ./bin/flink list 列出作业的详细信息： ./bin/flink info &lt;job-id&gt; 7/ 列出savepoint能够恢复的作业：
./bin/flink savepoint &lt;job-id&gt; [savepointDirectory] 从savepoint恢复作业： ./bin/flink run -s :savepointMetaDataPath &lt;program&gt; [&lt;arguments&gt;] 更新运行中的作业的并行度： ./bin/flink update &lt;job-id&gt; -p &lt;newParallelism&gt; 从指定的jar或者类运行一个新的程序： ./bin/flink run -c &lt;main-class&gt; &lt;jar-file&gt; &lt;arguments&gt; 注意： 这些命令应在 Flink 安装目录的命令行终端中执行。每个命令的具体参数和用法可以通过在命令后添加 --help 来查看详细的帮助信息，例如：.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb0b8c3ca09e5e001c1a31316b114684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703091c66e0ef4b0f5b77f4c24bf6903/" rel="bookmark">
			“探索AIGC市场：腾讯元宝APP加入竞争，大模型产品的未来走向与个人选择“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 每日一句正能量前言使用体验分享独特优势和倾向选择字节豆包百度文心一言阿里通义千问腾讯元宝个人倾向选择结论 未来发展方向技术创新可持续可拓展性用户体验应用场景政府赋能数据安全与隐私保护伦理与社会责任国际合作与竞争结论 后记 每日一句正能量 不管现在有多么艰辛，我们也要做个生活的舞者。
前言 我们生活在一个由数据和算法驱动的时代，人工智能大模型产品正逐渐渗透到各个行业和日常生活的方方面面。从内容创作到语言翻译，从图像识别到智能推荐，这些“全能”的AIGC产品正在重塑我们的工作和生活方式。
近日，随着腾讯元宝APP的加入，国内大模型产品市场变得更加多元化。每一款产品都以其独特的功能和优势，吸引着不同用户群体的关注。你是否曾经使用过这些大模型产品？它们的使用体验如何？在这些产品中，你更倾向于选择哪一款？你的选择依据是什么？是技术的先进性、功能的全面性，还是品牌的信誉度？
在众多互联网厂商竞相争夺的AIGC市场中，未来的大模型产品将如何发展？它们将如何更好地满足用户需求、解决实际问题？又将如何推动行业的创新和进步？
本文将探讨大模型产品的发展趋势，分析用户在选择过程中可能考虑的因素，并邀请读者分享他们的使用体验和看法。我们相信，通过深入讨论和交流，我们可以更好地理解大模型产品的现状和未来，为行业发展提供宝贵的见解和建议。
使用体验分享 在过去的一段时间里，我有机会体验了几款市场上流行的大模型AIGC产品。在这里，我想分享我的使用感受，包括产品的功能、内容生成质量以及隐私安全性等方面的体验，并提出一些我认为可行的优化点。
产品功能体验：
我首先尝试了[产品名称]，它提供了丰富的功能，包括[具体功能1]、[具体功能2]等。我发现[具体功能1]在使用过程中非常直观，能够满足我的[具体需求]。然而，[具体功能2]虽然很有创意，但在实际操作中存在一些局限性，比如[局限性描述]。
内容生成质量：
在使用[产品名称]进行内容生成时，我对其生成的[内容类型]感到满意。生成的内容不仅[优点1]，而且[优点2]。但是，我也注意到在某些情况下，内容的[某个方面]还有改进的空间，例如[改进点]。
隐私安全性：
隐私和安全性是我在选择AIGC产品时非常关注的点。[产品名称]在隐私政策上做得很好，明确说明了[隐私保护措施]。不过，我认为在[安全方面]还可以进一步加强，比如通过[建议措施]来保护用户数据。
优化建议：
基于我的使用体验，我认为[产品名称]在以下几个方面有改进的潜力：
功能优化：改进[具体功能2]的操作流程，使其更加用户友好。内容质量：增强内容生成算法，特别是在[改进点]方面，以提升整体质量。用户教育：提供更多的教程和指南，帮助用户更好地利用产品功能。安全措施：加强数据加密和访问控制，确保用户信息的安全。 总结：
总的来说，我对[产品名称]的使用体验是积极的。尽管存在一些可以改进的地方，但我相信随着技术的不断发展，这些产品将变得更加完善。我期待看到未来的大模型产品能够更好地满足用户的需求，并在市场中发挥更大的作用。
独特优势和倾向选择 在探讨现有大模型产品的独特优势时，我们可以从多个维度进行比较，包括产品功能、使用场景、成本效益和安全性等。以下是对几个知名大模型产品的对比分析和个人倾向选择的示例：
字节豆包 优势：以内容推荐和个性化服务见长，适合内容创作者和社交媒体用户。使用场景：推荐系统、个性化新闻源。 百度文心一言 优势：在自然语言处理和搜索技术方面具有强大的能力。使用场景：搜索引擎优化、智能客服。 阿里通义千问 优势：结合电商背景，擅长理解和处理交易相关数据。使用场景：电商推荐系统、用户行为分析。 腾讯元宝 优势：依托腾讯的社交和娱乐资源，可能在娱乐内容生成方面有独到之处。使用场景：游戏、社交媒体内容创作。 个人倾向选择 在选择大模型产品时，我的偏好和考虑因素包括：
产品功能：我更倾向于选择功能全面、能够满足特定需求的产品。例如，如果我需要一个能够提供高质量内容创作的工具，我可能会选择在内容生成方面表现出色的产品。
使用成本：成本效益是一个重要的考虑因素。我会评估产品的价格、许可费用以及潜在的长期成本。
安全性：数据隐私和安全性是我非常关注的点。我倾向于选择那些有明确隐私政策、严格数据保护措施的产品。
技术支持和社区：一个活跃的技术社区和良好的技术支持可以大大提高产品的可用性和可靠性。
创新能力：我偏好那些不断创新、更新产品功能以适应市场变化的公司。
结论 综合考虑上述因素，我可能会选择[示例：百度文心一言]，因为它在自然语言处理方面的专业能力和强大的搜索技术给我留下了深刻印象。此外，百度在数据安全和隐私保护方面的承诺也让我感到放心。当然，这只是一个基于当前信息和个人偏好的示例选择，实际选择可能会随着市场和技术的发展而变化。
请注意，这只是一个示例分析，您可以根据自己的实际需求和偏好进行调整。在做出选择之前，建议您深入研究每个产品的特点、用户评价和市场反馈。
未来发展方向 大模型产品作为人工智能领域的重要组成部分，其未来发展方向可以从多个维度进行探讨：
技术创新 算法优化：持续优化算法，提高模型的准确性和效率。多模态学习：整合视觉、语言和声音等多种数据类型，提升模型的理解和生成能力。 可持续可拓展性 模型泛化：提高模型的泛化能力，使其能够适应不同的应用场景和数据集。可扩展架构：设计灵活的模型架构，方便根据需求进行扩展和定制。 用户体验 个性化定制：提供个性化的服务和体验，满足不同用户的特定需求。交互设计：优化用户界面和交互流程，提升用户体验。 应用场景 垂直行业应用：深入特定行业，开发针对性的解决方案。跨领域融合：探索大模型在不同领域的融合应用，如医疗、教育、金融等。 政府赋能 政策支持：政府通过政策引导和资金支持，促进大模型技术的创新和应用。监管框架：建立合适的监管框架，确保技术的安全和合规使用。 数据安全与隐私保护 数据安全：加强数据安全措施，保护用户数据不被未授权访问。隐私设计：采用隐私保护设计，确保用户信息在处理过程中的匿名性。 伦理与社会责任 伦理标准：制定和遵循伦理标准，确保技术的发展不损害个人和社会利益。社会责任：企业应承担社会责任，通过技术解决社会问题。 国际合作与竞争 全球合作：鼓励国际合作，共享资源和知识，推动全球人工智能技术的发展。竞争力提升：在国际舞台上提升本国技术的竞争力。 结论 大模型产品的未来发展方向是多方面的，涉及技术创新、用户体验、行业应用、政策支持等多个层面。随着技术的不断进步和市场需求的变化，大模型产品将继续演进，为社会带来更多的可能性和价值。同时，也需要关注伴随技术发展而来的伦理、法律和社会问题，确保技术的健康发展。
在展望未来的同时，我们应积极引导和参与这一进程，通过跨学科合作、政策制定和公众教育，共同推动大模型产品向着更加智能、安全和负责任的方向发展。
后记 随着腾讯元宝APP的加入，大模型AIGC产品的市场竞争愈发激烈。从字节豆包、百度文心一言、阿里通义千问到腾讯元宝，每一款产品都以其独特的优势和功能，吸引着不同用户群体的关注。在这个多样化的市场中，选择适合自己的大模型产品成为了一项挑战。
用户在选择大模型产品时，可能会基于多种因素进行考量，如产品的功能、性能、成本效益、用户体验、安全性以及厂商的信誉等。此外，随着技术的不断进步，未来的大模型产品预计将朝着更加智能化、个性化和安全化的方向发展。
在AIGC市场的竞逐中，技术创新和用户体验将成为关键的竞争力。厂商需要不断地优化算法，提升模型的生成质量和效率，同时注重用户隐私和数据安全。此外，跨领域的应用和国际合作也将为大模型产品的发展带来新的机遇。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/703091c66e0ef4b0f5b77f4c24bf6903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21fe7dcc386494327f07165428cc3032/" rel="bookmark">
			【python】tkinter GUI开发: Button和Entry的应用实战探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：python图形化GUI编程tkinter精讲
景天的主页：景天科技苑
文章目录 1.Button组件细讲1.Button应用实战 2.Entry 单行文本框1.Entry中的参数2.Entry中的方法3.Entry应用实战4.StringVar变量详细解析 1.Button组件细讲 Button（按钮）用来执行用户的单击操作。Button 可以包含文本，也可以包含图像。按钮
被单击后会自动调用对应事件绑定的方法。
具体用法可以参考文档
https://insolor.github.io/effbot-tkinterbook-archive/
点进去查看Button用法
Button组件的参数详解
1.Button应用实战 【示例】Button 按钮用法(文字、图片、事件)
"""测试Button组件的基本用法，使用面向对象的方式""" from tkinter import * from tkinter import messagebox class Application(Frame): def __init__(self, master=None): super().__init__(master) # super()代表的是父类的定义，而不是父类对象 self.master = master self.pack() self.createWidget() def createWidget(self): """创建组件""" # anchor，如果控件的空间大于文本所需的空间，此参数可控制文本的位置，默认值为'center'，可选项有'e'，'s'，'w'，'n'，'nw'，'ne'，'sw'，'se'，'center'，分别代表右、下、左、上、左上、右上、左下、右下、中间（类似于东南西北） self.btn01 = Button(root, text="登录",width=6,height=3,anchor=NE,command=self.login) self.btn01.pack() global photo photo = PhotoImage(file="imgs/数据分析.png") self.btn02 = Button(root, image=photo,width=500,height=100, command=self.login) self.btn02.pack() # self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21fe7dcc386494327f07165428cc3032/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23918ee5ac2bcfcd8d97537432a94312/" rel="bookmark">
			MySQL8.4.0 LTS安装教程 【小白轻松上手2024年最新长期支持版本MySQL手把手保姆级Windows超详细图文安装教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL8.4.0 LTS安装教程 【小白轻松上手2024年最新长期支持版本MySQL手把手保姆级Windows超详细图文安装教程】 MySQL8.4.0前言（版本说明）官网下载MySQL1.访问MySQL官网2. 打开MySQL官网下载页面3. 选择下载类型Select Version【MySQL版本号】Select Operating System【选择操作系统】选择MySQL下载版本进入下载页面选择存储目录完成MySQL下载 安装MySQL运行MySQL安装包用户许可协议选择安装类型选项准备安装 MySQL Server 8.4安装MySQL服务器8.4版本注意：配置高的电脑会秒过完成安装 MySQL配置向导选择存储数据文件的目录MySQL配置选项账户与角色配置系统服务器配置服务器文件权限配置示例数据库配置应用配置执行进度配置完成配置完成 Mysql环境变量配置打开电脑属性打开高级系统设置打开环境变量环境变量配置添加MySQL环境变量完成环境变量配置 验证MySQL进入服务页面查找MySQL服务启动命令窗口查看MySQL版本信息 安装MySQL常见问题和解决方法问题一：权限不足问题二：依赖包缺失问题三：端口冲突问题四：初始化失败问题五：安装程序无法识别操作系统问题六：安装路径错误 Python老吕说 MySQL8.4.0 前言（版本说明） MySQL Releases and Support Timelines【译为：MySQL数据库软件的发布版本及其支持的时间线】
“MySQL Releases and Support Timelines”是指MySQL数据库软件的发布版本及其支持的时间线。这涉及到MySQL的不同版本、发布日期、更新周期、以及官方对这些版本提供的支持期限等。
MySQL的版本号通常由主版本号、次版本号和补丁版本号组成。例如，在MySQL 5.7.33中，“5”是主版本号，“7”是次版本号，“33”是补丁版本号。主版本号和次版本号共同组成了一个发布系列，如5.7系列。每个系列代表了一组稳定的特性和功能集合。
MySQL的发布模型经历了变化。在MySQL 5.7及以前的版本中，主要采用的是传统的发布模型，其中新特性通常只在大版本发布时引入，且大版本的发布周期相对较长，这确保了版本的稳定性。然而，这也意味着新特性的发布速度相对较慢。
从MySQL 8.0开始，MySQL采用了持续发布模型。在这种模型中，除了包含缺陷修复外，补丁版本还可能包含已经稳定的新特性。这使得MySQL能够更快地引入新特性，但同时也要求用户更频繁地更新他们的系统。
MySQL还提供了不同的版本类型，包括社区版（Community Edition）、企业版（Enterprise Edition）以及集群版（Cluster Edition）等。社区版是开源免费的，而企业版则需要付费，但提供了更多的功能和官方技术支持。
至于支持时间线，MySQL官方通常会为每个版本提供一定的支持期限，包括修复已知问题和提供安全更新等。然而，具体的支持期限可能会因版本类型和发布策略的不同而有所差异。
“MySQL Releases and Support Timelines”涵盖了MySQL的发布策略、版本类型、以及官方对这些版本的支持期限等内容，是了解MySQL软件生命周期和规划更新策略的重要参考。
请注意，由于MySQL是一个不断发展的软件项目，具体的发布和支持策略可能会随着时间和市场需求的变化而有所调整。因此，建议定期查阅MySQL的官方文档和发布说明，以获取最新的信息和指导。
美国时间 2024 年 4 月 30 日，Oracle正式发布了MySQL数据库8.0.37版本的更新，以及LTS分支中的新版本MySQL 8.4。 Oracle为MySQL提供了两个发布流： 创新版本和LTS（Long Term Support）版本。是 MySQL 的第一个【长期支持版本】，它主要集中在功能淘汰、参数更新和 bug 修复等方面。 最醒目的一个变动就是 从【MySQL 8.4.0】开始，mysql_native_password 认证插件默认不再启用。 若要启用，需要在MySQL启动的时候，添加–mysql-native-password=ON 参数； 或在配置文件中设置 mysql_native_password=ON。 官网下载MySQL 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23918ee5ac2bcfcd8d97537432a94312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9848b33409fef22b365ede6f6d4aacaf/" rel="bookmark">
			【RabbitMQ】RabbitMQ配置与交换机学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介安装和部署1. 安装RabbitMQ2.创建virtual-host3. 添加依赖4.修改配置文件 WorkQueues模型1.编写消息发送测试类2.编写消息接收（监听）类3. 实现能者多劳 交换机Fanout交换机1.消息发送2.消息监听 Direct交换机1.消息发送2.消息接收 Topic交换机1.消息发送2.消息接收 声明队列和交换机声明队列声明交换机绑定队列和交换机1.fanout示例2. direct示例3.基于注解的方式声明队列和交换机 消息转换器 总结 简介 RabbitMQ是一个开源的消息代理软件，它实现了高级消息队列协议（AMQP）。RabbitMQ支持多种消息传递协议，具有高可靠性、高可用性和高性能等特点。它允许应用程序通过消息队列进行异步通信，从而实现解耦和负载均衡。RabbitMQ的核心概念包括交换机（Exchange）、队列（Queue）和绑定（Binding），它们共同构成了消息的路由和传递机制。
RabbitMQ的架构如图：
其中包含几个概念：
publisher：生产者，也就是发送消息的一方consumer：消费者，也就是消费消息的一方queue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理exchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。virtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue 安装和部署 这里以Centos7为例：
1. 安装RabbitMQ docker run \ -e RABBITMQ_DEFAULT_USER=shijun \ -e RABBITMQ_DEFAULT_PASS=123321 \ -v mq-plugins:/plugins \ --name mq \ --hostname mq \ -p 15672:15672 \ -p 5672:5672 \ --network hm-net\ -d \ rabbitmq:3.8-management -e RABBITMQ_DEFAULT_USER=shijun
-e参数用于设置环境变量。这行代码用来设置RabbitMQ的默认用户名为shijun。
-e RABBITMQ_DEFAULT_PASS=123321
这行代码用来设置默认密码为123321。
-p 15672:15672
这行代码用来将宿主机的15672端口映射到容器的15672端口，15672端口是RabbitMQ管理控制台的默认端口。
-p 5672:5672
这行代码用来将宿主机的5672端口映射到容器的5672端口，5672端口是RabbitMQ的默认通信端口。
--network hm-net
这行代码将容器连接到名为hm-net的网络。
-d
-d参数表示以后台模式运行容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9848b33409fef22b365ede6f6d4aacaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8900dd26c40689b8ac9c319d85df4c/" rel="bookmark">
			AIGC提示词---如何写提示词？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你真的了解你的AI助手吗？
想象一下，你和别人使用相同的AI工具，但为何他的工作效率总是高出一截？秘诀可能就藏在那些看似简单的提示词里。精准的提示词是解锁AI潜能的关键，它们能让AI更好地理解你的需求，从而提供更准确、更高效的回答。
编写提示词，好比电视节目中记者采访名人、企业家，需要提前准备好问题脚本，节目的效果与提问的内容、方式和用语息息相关。
但是，编写提示词并非人生来就会的技能，因为人与AI之间存在着沟通障碍——它常常不明白我们的意图，仅通过概率推测要回答的内容，最终导致提供给我们的答案无法让我们满意。
心理学有个术语，叫“知识的诅咒”，它表示我们一旦知道某种知识，就很难想象不知道这些知识时的情况，这种知识反而成了沟通的障碍，我们的知识“诅咒”了我们。我们很难与他人分享这些知识，这不仅会发生在人与人之间，也会发生在人与AI之间。
知识的诅咒 你是否曾对AI发出指令，却得到一个驴唇不对马嘴的回答？这可能是因为AI并没有真正理解你的意图。这就像心理学中的“知识的诅咒”——一旦我们掌握了某些知识，就很难想象不知道这些知识的人会怎么想。
这种现象不仅存在于人与人之间的交流，也普遍存在于我们与AI的互动中。我们以为自己表达得很清楚，但实际上AI可能并没有“get”到我们的点。
清华大学的刘嘉教授在混沌的课上讲述过一个很有趣的现象，在我服务的企业中他们也常对AI有类似的误解。刘嘉老师说，很多企业对AI有巨大的认知偏差，以为现如今的AI大模型能像以前的智能助手一样，自动完成各种任务。
AI其实可以分为两大类：特定任务人工智能（Task-Specific AI, TSAI）和通用人工智能（Artificial General Intelligence, AGI）。TSAI就像是专业领域的专家，专注于解决特定类型的问题。在机器学习中，任务（Task）是指一个特定的预测问题，而域（Domain）则是指该问题的输入和输出的空间。Artificial General Intelligence是一种能够像人类一样思考、学习和执行多种任务的人工智能系统。
添加图片注释，不超过 140 字（可选）
如何理解？
有两种描述方式：第一种，从AI是封闭环境还是开放环境进行区分；第二种，从AI执行的策略是动态还是静态进行区分。在我们的生活中，人脸识别系统就是一个封闭环境和静态策略；打败李世石的AlphaGo是封闭环境和动态策略；《王者荣耀》是开放环境和静态策略。今天的AGI、ChatGPT-4、自动驾驶技术就是最终的开放环境和动态策略。
也就是说，现在我们所说的AI与以往认知的AI大不相同，我们应该以全新的视角看待它。
OpenAI公司开发的ChatGPT-4是典型的大语言模型，能够理解和生成文本，像人类一样与人进行交谈。虽然它的表现看起来很类似人的思考，但实际上它并不理解它在说什么，也没有情绪、观点或意识。它仅仅是根据它所被训练的大量文本进行模式匹配和文本生成。
我们将这类模型称为预测模型。它最擅长的事情包括Learn、Predict、Make、Understand和Do，也就是学习、预测、使用、理解、以及做。其中，预测的能力值最高，这也是我叫它预测模型的原因。
在AI擅长的功能里，学习是通过什么机制实现的呢？——答案在于网络神经。
网络神经的结构模仿了人类大脑的神经元连接方式。人类大脑中的神经元通过突触相互连接，而网络神经中的节点通过权重（即媒体常说的“参数”，我的描述是“职业病”）相互连接。
提示词触发数据库里的选项，牵涉着回答的质量。因此，每个人给出的提示词不一样的话，得到的回答也会大相径庭。很多朋友跟我反映，ChatGPT的回答常常很跳跃，让人难以理解，其实这跟提示词的准确度相关。
遇到此类情况，可以试一试连续性想法，让我们一步一步思考。我举个例子便于大家充分理解：
假如小明手里有5个棒球，还有三桶棒球，一个桶能装5个棒球，棒球被打飞了3个，掉进池塘2两个，问小明手里还剩下几个棒球?
我分别使用两种提示指令，第一个为“小明有几个棒球？请一步一步地思考回答”，第二个为“请问小明有几个棒球？跳开运算步骤直接给答案”。
这是我获得的答案的对比图：
添加图片注释，不超过 140 字（可选）
从结果可以看出，不同的指令将会带来不同的回答结果。这也能够反映出我们在向ChatGPT提问时常出现的问题：它常常不明白我们的意图，仅通过概率推测，最终导致提供给我们的答案不能让我们满意。这种情况被称为AI幻觉，这些不准确的答案并非语言模型故意撒谎，而是因为用于模型的训练数据中不包含正确回答问题所需的必要信息。例如，ChatGPT 的训练中未包含 2021年9月后的任何数据，因此如果您询问这类数据，ChatGPT无法准确回答。
不仅如此，AI超强的生成能力还会致使这一情况恶化，导致我们与它的沟通越来越偏离轨道。也就是说，你花了很长时间跟它沟通，它也貌似理解了你的问题，但最终却给出一个逻辑上通顺、实则错误的答案。
要解决上述问题，需要我们在写提示词的时候保证准确和清晰，一步一步地引导AI， 帮助它避开“知识的诅咒”，确保沟通的有效性。
认知偏差 AI PPT是当下的热门，但它并不能真的做到一键生成PPT，市面上所有的AI PPT工具都没有达到理想的标准。这些AI PPT虽然各有特色，但功能相对有限，可能无法满足高度专业化的需求。
现在的AI公司在宣传自家产品的时候，往往试图用一句话打动用户，常常用一个产品视角做产品，完全不在乎生产PPT的逻辑，仅能生成一个PPT的结构。在职场中，这些用AI生成的PPT基本上不能用，因为它没有理念，也没有格局，数据处理也不够出色。
我不是全然否定AI PPT，它也有使用的价值，比如它能帮我们打磨一下PPT。在这一过程中，我们会发现，AI都在通过大数据模仿和学习人类，是否人类也需要学习一下AI呢？
在机器学习法中，有一种方法叫分治法。分治法的意思是将一个大问题细细地拆解成具体的小问题、具体的要求，通过对这些子问题的逐一解决，然后再将解决方案重新组合起来，最终形成对原始问题的完整答案。
AI PPT的隐含假设是你给出标题，它自动生成内容。它的底层逻辑是，当接到指令后，拆解出各个问题，也就是大纲，再基于大纲的方式单点打磨每一个大纲，形成PPT。因此它生成的PPT并不是你真正想要的。
真的好的做法是什么？那就是明确表达出这些隐含的假设。
我示范一下如何生成大纲：
添加图片注释，不超过 140 字（可选）
首先，在生成汇报大纲时，我要求它围绕着主题生成8个版本；其次，我要求每个版本包含6个一级大纲，而不要二级大纲；接着，在一级大纲里加上自己的观点，回归创意流程的拆解，再在二级大纲中植入观点。像剥洋葱一样，逐层深入。
我简单说一下PPT的制作逻辑。
创造力源自流程化思维，通过文档输入，然后内容以Markdown的格式生成。Markdown是一种轻量级标记语言，用于书写纯文本文档，并可以转换为HTML格式。它通过简单的标记语法来让文本具有不同的样式，如添加标题、列表、链接、图片等。它适用于简单的文章、源程序说明等，不太适合复杂的数学公式、图表等。得到Markdown格式的文件后，就可以在几乎所有网站上方便地使用它。
AI提示词是需要进阶的 可以说，提示词的用法也是逐渐进阶的。在进阶思路里，我们看似用中文与AI进行沟通，但其实提示词是一种独特的沟通语言，而要培养进阶思路，需要分三个步骤：
首先，第一步叫对话式交流。也就是我们与日常接触的AI最常做的沟通。比如，OpenAI的ChatGPT，百度的文心一言等。通过与AI的对话，我们会解答一些自己不了解的问题，比如询问某个数据，掌握某个行业的动态。
如果我们是一名准备法考的学生，向AI咨询考试该如何准备，交流式AI就相当有用。但如果我们已经是一名专业律师，需要向它咨询一些深入的行业知识，就会发现它能给到的帮助十分有限。这时候我们就需要进入到第二个阶段。
第二个阶段为新生式培养。AI很多时候不能理解我们的意思，我们可以通过培养式交流来提升它的理解能力，当你培训它一个模块和内容之后，会发现它能给你更贴切的帮助。比如你先对它进行公司介绍，展示公司的优缺点，好让它明白你的喜好、目的和意图。但这是否意味着问题已经解决？有时候当你给它喂材料的时候，会发现它吸收不了，那是因为输入的文字数量超标，到达了它理解的上限。这时你会发现一个很大的问题，AI也会遗忘。而这时就要进入第三阶段，叫做编程式迭代。
通俗来说，编程式迭代也就是用自然语言的方式写程序代码的过程。我示范一下用编程式指示词和其他指示词让AI对同一要求作出解答。
第一种指示词方式，我告诉它：“我们计划与XYZ AI公司展开合作。关于这次合作，需要你制定一个框架协议。请尽快准备一个初步方案，我们将在后续讨论中进一步细化。希望能在未来几天内看到你的进展。”
很多企业的老板一般会使用这样的方式，看似把一件事情说清楚了，但其实是站在自己的立场上，而没有充分考虑AI如何理解和执行这些指令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d8900dd26c40689b8ac9c319d85df4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6807401a30acc7ce4f9b334ef78e5e40/" rel="bookmark">
			[Algorithm][动态规划][二维费用的背包问题][一和零][盈利计划]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0.原理讲解1.一和零1.题目链接2.算法原理详解3.代码实现 2.盈利计划1.题目链接2.算法原理详解3.代码实现 0.原理讲解 本质仍然是背包问题，但是相较于普通的背包问题，只是限制条件多了一个而已 1.一和零 1.题目链接 一和零 2.算法原理详解 思路： 确定状态表示 -&gt; dp[i][j]的含义
dp[i][j][k]：从前i个字符串中挑选，字符0的个数不超过j，字符1的个数不超过k，所有的选法中，最大的长度 推导状态转移方程：根据最后一个位置的情况，分情况讨论
初始化：
三个维度都多开一“行”虚拟结点j, k这两个维度的初始化都可以交给DP阶段 确定填表顺序：i从小到大
确定返回值：dp[len][n][m]
滚动数组优化空间 大致思路与完全背包一致操作 删除所有的i修改一下j, k的遍历顺序 注意：不要去强行解释优化后的妆台表示以及状态转移方程，费时费力还没啥意义 3.代码实现 // v1.0 int findMaxForm(vector&lt;string&gt;&amp; strs, int n, int m) { int len = strs.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(len + 1, vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(m + 1))); for(int i = 1; i &lt;= len; i++) { // 先统计字符串中0 1的个数 int a = 0, b = 0; for(auto&amp; ch : strs[i - 1]) { ch == '0' ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6807401a30acc7ce4f9b334ef78e5e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc31cab40be09fef440a258a7bcaa72c/" rel="bookmark">
			01：WebGL简介、示例、应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是大剑师兰特：曾是美国某知名大学计算机专业研究生，现为航空航海领域高级前端工程师；CSDN知名博主，GIS领域优质创作者，深耕openlayers、leaflet、mapbox、cesium，canvas，webgl，echarts等技术开发，欢迎加底部微信（gis-dajianshi），一起交流。
No.内容链接1Openlayers 【入门教程】 - 【源代码+示例300+】 2Leaflet 【入门教程】 - 【源代码+图文示例 150+】 3Cesium 【入门教程】 - 【源代码+图文示例200+】 4MapboxGL【入门教程】 - 【源代码+图文示例150+】 5前端就业宝典 【面试题+详细答案 1000+】 文章目录 一、WebGL简介二、示例代码三、应用场景 一、WebGL简介 WebGL（Web Graphics Library）是一种开放标准的API，用于在Web浏览器中渲染交互式的3D和2D图形，无需任何插件。它基于OpenGL ES 2.0规范，并使用JavaScript作为接口，允许开发者直接利用GPU的硬件加速功能。WebGL通过HTML5的&lt;canvas&gt;元素来获取上下文，并使用GLSL ES（OpenGL Shading Language for Embedded Systems）来编写着色器程序。
二、示例代码 下面是一个简单的WebGL示例代码，用于在屏幕上渲染一个红色的矩形：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;canvas id="glcanvas" width="800" height="400"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.getElementById('glcanvas'); var gl = canvas.getContext('webgl'); // 初始化着色器 function createShader(gl, type, source) { var shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); var success = gl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc31cab40be09fef440a258a7bcaa72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69b605defd02b0d2a601439d55f3313/" rel="bookmark">
			JAVA基础--MAVEN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MAVEN的认识 什么是MAVEN Maven是一个项目构建及管理工具，开发团队几乎不用花多少时间就能够自动完成工程的基础构建配置，
Maven 使用了一个标准的目录结构在不同开发工具中也能实现项目结构的统一。 统一项目结构
Maven提供了清理，编译，测试，安装，打包，发布等命令可以让我们更加方便的去构建项目。 方便构建
同时采用pom.xml来导入依赖，可以自动下载jar,以及其所依赖jar，无需手动下载，拷贝Jar到项目中，大大解放了程序员的劳动力。 高效管理jar
MAVEN的优势 自动构建：清理，编译，测试，安装，打包，发布
Jar包依赖管理：自动下载jar及其依赖的jar
契约编程：在多种开发工具中也能实现项目结构统一
MAVEN的功能 使用Maven可以为我们完成很多相应的功能：清理代码，自动编译，完成测试，生成站点报告，进行打包(jar,war)，项目部署。
清理代码:相当于我们运行clear的效果
自动编译:可以为咱们自动完成编译(类似于执行javac生成class文件)
完成测试:实现测试功能，帮咱们完成
生成报告:可以较为方便的实现对项目的管理
打包:普通项目打jar包，web项目打成war包
项目部署:只需要一句命令 mvn jetty:run 即可实现项目的部署
MAVEN的安装 下载MAVEN 从网上下载 Maven：Maven – Download Apache Maven，解压即安装
配置环境变量 MAVEN配置 MAVEN仓库 Maven会自动为咱们添加相应的jar包，而这个jar包会先在本地仓库中查找，如果本地仓库中找不到，则会去中央仓库(网络上)去进行下载。
创建本地仓库 找一个位置，创建一个空目录作为本地仓库目录，如：D:/OpenSource/repository
配置本地仓库 进入Maven的安装目录，找到conf/settings.xml配置文件进行辑
增加本地仓库配置指向本地仓库目录：&lt;localRepository&gt;D:/OpenSource/repository&lt;/localRepository&gt;
在&lt;mirrors&gt;节点下增加远程仓库地址，使用阿里云的maven仓库
&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; ``` 全局配置JDK8 &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; MAVEN的命令 MAVEN项目结构 创建项目
根目录pom.xml下的代码
&lt;project xmlns="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a69b605defd02b0d2a601439d55f3313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d0aaaa2305912b46f85422c10fe88a/" rel="bookmark">
			Ivy优化算法-2024年7月SCI一区顶刊新算法！公式原理详解与性能测评 Matlab代码免费获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：文章是从本人公众号中复制而来，因此，想最新最快了解各类智能优化算法及其改进的朋友，可关注我的公众号：强盛机器学习，不定期会有很多免费代码分享~
目录
原理简介
一、初始化
二、协调有序的种群增长
三、获得阳光来源生长
四、常青藤植物的传播和进化
五、生存者选择
算法伪代码
性能测评
参考文献
完整代码
​Ivy算法是一种新型的元启发式算法（智能优化算法），灵感来源于常青藤的有序协调增长和扩散进化过程。比较有趣的是，这个算法的作者中包括了R.Venkata Rao。如果你不知道他是谁，那么，提到著名的Jaya优化算法、教与学优化算法TLBO，相信你应该就已经知道了，这些经典的算法都是由他提出的！
这位学者已经被引用了1w多次。众所周知，Jaya优化算法的优势就是速度快、参数少，此次提出来的算法也同样具备这两个特点！最重要的是，这个算法也是出版于2024年7月的新算法~非常新颖！
原文作者在26个经典测试函数上与12个工程优化问题上，与其他10种算法进行了比较，证明了其优越的性能。。该成果由Mojtaba Ghasemi等人于2024年7月发表在SCI一区顶刊《Knowledge-Based Systems 》上！
由于发表时间较短，谷歌学术上还无人引用！你先用，你就是创新！
原理简介 灵感：IVY指的是常春藤这种植物，这个算法主要模拟了常春藤的不同生命阶段，包括生长、上升和在常春藤植物群中传播。
一、初始化 在算法开始时，IVY种群在搜索空间中的初始位置是使用Eq.(1)随机确定的。
其中，区间[0,1]内均匀分布随机数的维数为D的向量用rand(1,D)表示。Imax和Imin分别是搜索空间的上界和下界，两个向量的Hadamard积(也称为元素积，在Matlab中表示为“.∗”)用运算“⊙”表示。
二、协调有序的种群增长 设Gv为增长率，φ为生长速度，φ为偏离生长的修正系数。在本文提出的算法中，基于数据密集型的实验和仿真过程，将Eq.(2)建模为成员Ii的生长速度Gvi(t)的差分方程。
其中向量ΔGvi(t)和ΔGvi(t+1)表示离散时间系统(时刻t和时刻t +1)的增长率，rand是区间[0,1]中的随机实数(即rand∈U[0,1])， rand^2是随机变量的随机数，其概率密度函数等于1/(2√x))。N(1, D)表示维数为D的随机向量，为标准高斯(正态)分布中的随机数。
三、获得阳光来源生长 对于自然界中常春藤的整体健康来说，找到一个附着的表面(例如，墙，岩石或树)以便向阳光爬去是至关重要的。在野生森林中，年轻的常春藤可以适当地选择向最近的树生长的方向，而且经常是另一棵已经找到支撑的老常春藤。这样，常春藤就可以逐渐填满大片连续的森林区域。对于森林中的其他树种来说，幸运的是，小常春藤在老常春藤上的攀爬导致了整个小常春藤和老常春藤群体中只有最强壮的存活下来，几乎与它们的年龄无关。
下面的等式描述了成员Ii如何利用成员Iii沿着光源的方向进行攀爬和逻辑移动
其中|N(1, D)|是矢量，其分量是矢量N(1, D)的分量的绝对值，运算“u⊘v”是矢量u除以矢量v的Hadamard除法(也称为逐元除法，在Matlab中表示为“./”)。
四、常青藤植物的传播和进化 在成员Ii通过搜索空间全局漫游到最近、最重要的邻居Iii的阶段之后，有一个阶段，成员Ii试图直接跟随整个种群的最佳成员IBest，这相当于在成员IBest周围寻找更好的最优解。这个阶段用数学公式表示如下：
随后，当前成员Inewi的增长率ΔGvnewi的新值由以下公式计算(这与初始化步骤中用于计算ΔGvi的公式完全类似)
五、生存者选择 Hoflacher和Bauer研究了常青藤植株最年轻和最老(基部)部分在常青藤两个生长阶段交替期间吸收阳光的能力，即“幼叶”形成阶段(典型的快速向上生长阶段)和“成叶”形成阶段(典型的新枝宽度和开花扩张阶段)。
为了模拟常青藤树生命中的两个交替阶段，即“爬升”和“扩张”，在IVY算法中，我们使用了以下决策方法。当成员Ii的目标函数值f(Ii)小于f(Ibest)的倍数时，参数β = (2 + rand)/2。然后，常春藤树开始扩展树枝和叶子的宽度(由式(5)给出)。否则，常春藤向上生长并爬升(由式(7)给出)。
算法伪代码 为了使大家更好地理解，这边给出算法的伪代码，非常清晰！
如果实在看不懂，不用担心，可以看下源代码，再结合上文公式理解就一目了然了！
性能测评 原文在26个经典测试函数上与其他10种算法进行了比较，证明了其优越的性能。此外，作者还求解了12个工程优化问题，并与各种优化算法的结果进行比较，证明了IVYA算法的有效性。
这边为了方便大家对比与理解，采用23个标准测试函数，即CEC2005，并与作者先前提出的Jaya优化算法进行对比！这边展示其中5个测试函数的图，其余十几个测试函数大家可以自行切换尝试！
可以看到，IVY在大部分函数上都超过了作者之前提出的Jaya优化算法，尤其在F1-F4函数中，更是收敛极快，没见过这么快就收敛到0的，不知道是不是采取了偏向于0点的搜索策略~当然，大家应用到各类预测、优化问题中也是一个不错的选择~
参考文献 [1]Ghasemi M, Zare M, Trojovský P, et al. Optimization based on the smart behavior of plants with its engineering applications: Ivy algorithm[J].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d0aaaa2305912b46f85422c10fe88a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97ca0de8a88e04683946cdc93c97858/" rel="bookmark">
			【机器学习300问】112、什么是特征点检测？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 特征点检测是计算机视觉中的一种技术，用于识别图像中具有显著局部特征的点。这项技术在多个领域内扮演着核心角色，包括图像识别、三维重建、运动跟踪和图像匹配等。
一、特征点任务的目的 在计算机视觉（CV）中，特征点检测的任务目的主要有以下几个方面：
（1）识别与定位：特征点检测首先旨在从图像中自动识别并精确定位具有显著性质的像素区域，这些区域通常是对光照、视角变化或尺度变换相对不敏感的。这些特征点可以是角点、边缘或其他具有特定模式的局部结构，它们在图像的不同区域中提供稳定的识别标志。
（2）动作识别与分析：在人体姿态估计和动作识别中，关节等关键点的检测是理解人体动态行为的基础。
（3）视觉追踪：在视频序列中，连续帧间特征点的跟踪可以用来维持对移动物体的稳定追踪，这对于监控、交互式应用和增强现实等领域极为重要。
二、以人脸检测为例说明什么是特征点 （1）概念解释 人脸检测不仅仅是找出图像中是否存在人脸，更重要的是进一步识别并定位人脸上的关键特征，这些关键特征点就是我们所说的“特征点”。
具体来说，在人脸检测中，特征点可能包括但不限于以下几种：
眼角：左右眼的内外角，用于确定眼睛的位置和形状。鼻尖：鼻子的最下端，帮助标定面部中央区域。嘴角：上唇和下唇的两端，有助于识别微笑、说话等表情变化。眉峰：眉毛的最高点，界定眉毛形态。脸颊轮廓点：分布在脸部边缘的点，用于描绘脸部轮廓。下巴中心：下巴的最突出点，辅助确认头部姿态。 这些特征点的检测不仅对于人脸识别至关重要，还广泛应用于美颜滤镜、表情分析、虚拟现实头盔的眼球跟踪等领域。通过精确地标记和测量这些点之间的相对位置，我们可以实现人脸对齐（即将不同姿态和大小的人脸调整到统一的标准视角和尺寸），从而提高后续人脸识别算法的准确性和鲁棒性。
（2）举例说明 检测人脸上的特定五个特征点（双眼的眼头及眼尾，以及鼻头），通常可以采用一些专为人脸分析设计的算法，这些算法在保证一定精度的同时，也注重执行速度。比如：Dlib和OpenCV的Haar cascades
人脸分析中还常使用更为详细的特征点检测比如68个特征点。这68个点覆盖了人脸的主要轮廓和细节，包括眼睛、眉毛、鼻子、嘴巴、下巴轮廓以及面部其他关键结构。
这种详尽的特征点检测主要用于需要精细面部分析和处理的应用场景，比如高级的人脸识别、表情分析、虚拟试妆、3D人脸重建等。
三、常用特征点检测算法 特征点检测技术原理简述优点缺点适用场景Harris角点检测基于图像灰度变化，通过检测窗口在多个方向上的灰度变化大小来判断角点。对图像旋转和亮度变化不敏感，稳定检测角点。对尺度变化敏感，边缘响应可能较强。图像识别、运动跟踪等。Shi-Tomasi角点检测改进自Harris方法，通过计算自相关矩阵的特征值来检测角点。能检测到更少但更稳定的角点。对尺度变化较敏感，需要手动设置阈值。三维重建、图像配准等。FAST角点检测检查一个点的周围邻域，如果连续的像素点数超过阈值则认为是角点。计算速度快，适合快速检测。可能检测到大量角点，需要后续处理。实时应用如视频跟踪、物体识别等。SIFT特征点检测在不同尺度空间寻找极值点，并构建旋转不变和尺度不变的特征描述符。对旋转、尺度和亮度变化具有不变性，适合复杂场景。计算量大，时间可能较长。特征匹配、对象识别、全景拼接等。SURF特征点检测SIFT的加速版，使用积分图和箱式滤波器加快特征提取。速度快，保持较好的不变性和鲁棒性。在复杂场景下稳定性可能略逊于SIFT。特征提取、图像匹配等。ORB特征点检测结合FAST关键点和BRIEF描述符，引入方向组件。速度快，适合实时应用，具备旋转不变性。尺度变化大的场景表现不佳。增强现实、机器人定位等。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1afe7a2f3cf91981f0c7244ef5ccd350/" rel="bookmark">
			【lesson8】云备份服务端完整版代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 util.hppconfig.hpphot.hppdata.hppserver.hppserver.ccMakefilecloud.conf util.hpp #pragma once #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; #include &lt;cstring&gt; #include &lt;cstdint&gt; #include &lt;experimental/filesystem&gt; #include &lt;jsoncpp/json/json.h&gt; #include &lt;memory&gt; #include "bundle.h" namespace cloud { namespace fs = std::experimental::filesystem; class fileUtil { public: fileUtil(std::string filename) :_filename(filename) {} bool Remove() { if(exists() == false) { return true; } remove(_filename.c_str()); return true; } size_t fileSize() { struct stat st; int ret = stat(_filename.c_str(), &amp;st); if(ret == -1) { std::cout &lt;&lt; strerror(errno) &lt;&lt; std::endl; return 0; } return st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1afe7a2f3cf91981f0c7244ef5ccd350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7cac5b9f3658a2ca1e2b97bd0fe41e3/" rel="bookmark">
			如何在 ASP.NET Core Web Api 项目中应用 NLog 写日志？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 昨天分享了在 .NET Core Console 项目中应用 NLog 写日志的详细例子，有几位小伙伴私信说 ASP.NET Core Web Api 项目中无法使用，其实在 ASP.NET Core Web Api 项目中应用 NLog 写日志，跟 .NET Core Console 项目是有些不一样的，今天我特地写了一个在 ASP.NET Core Web Api 项目中应用 NLog 写日志的例子，我们来看看如何在 ASP.NET Core Web Api 项目中应用 NLog 写日志？
不废话，直接上 Step By Step 例子。
Step By Step 步骤 创建一个 ASP.NET Core Web Api 项目
下载 Nuget 包
NLog.Web.AspNetCore
手动添加 nlog.config 文件，并设置 复制到输出目录-如果较新则复制
可直接复制粘贴 《分享一个 .NET Core Console 项目中应用 NLog 写日志的详细例子》 一文中的 附录：NLog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7cac5b9f3658a2ca1e2b97bd0fe41e3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/278/">«</a>
	<span class="pagination__item pagination__item--current">279/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/280/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>