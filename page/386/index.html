<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0052be8c11c61150339ad28e2b9c77/" rel="bookmark">
			利用Knife4j注解实现Java生成接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、简介2、生成文档3、系列注解3.1、@Api3.2、@ApiResponses和@ApiResponse3.3、@ApiOperation3.4、@Pathyvariable⭐3.5、@RequestBody3.6、@ApiOperationSupport3.7、@ApiImplicitParams 和 @ApiImplicitParam3.8、@ApiModel3.9、@ApiModelProperty ​🍃作者介绍：双非本科大三网络工程专业在读，阿里云专家博主，专注于Java领域学习，擅长web应用开发、数据结构和算法，初步涉猎Python人工智能开发和前端开发。
🦅主页：@逐梦苍穹
📕项目专栏：您的一键三连，是我创作的最大动力🌹
1、简介 Knife4j 是一款基于 Swagger 的开源 API 文档生成工具，它提供了一套简洁的界面来展示和测试你的 API。Knife4j 使得 API 文档的编写、查看和测试变得更加方便，同时支持在线调试接口。
以下是 Knife4j 的一些主要特性和优势：
基于 Swagger： Knife4j 是 Swagger 的一个增强版本，它利用 Swagger 注解来生成 API 文档，能够自动生成接口文档、测试接口等信息。美观的界面： Knife4j 提供了一个直观、美观的界面，使得 API 文档更易于阅读和理解。它支持显示接口的请求和响应参数、响应示例、参数类型等详细信息。在线调试： Knife4j 允许用户在界面中直接进行 API 接口的测试和调试，无需额外的工具。你可以在文档页面直接输入参数，模拟请求，并查看实时的响应。接口分组： 可以将接口按照业务逻辑或其他标准进行分组，使得文档更具有组织性和可读性。代码生成： Knife4j 支持通过在线界面生成前端调用 API 的代码片段，包括 Java、Spring Cloud Feign、JavaScript 等。易于集成： Knife4j 提供了简单的集成方式，支持 Spring Boot 项目，只需要引入相应的依赖即可。自定义配置： Knife4j 提供了一系列的配置选项，可以根据项目的需求进行自定义配置，以满足不同场景的需求。 总体而言，Knife4j 是一个强大、易用的 API 文档生成工具，适用于 Java 和 Spring Boot 项目，使得 API 的设计、测试和文档生成更加便捷。
2、生成文档 在springboot工程中，生成后端接口文档是非常重要的。
首先是引入依赖：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0052be8c11c61150339ad28e2b9c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab48603384a8421f691bd7d2b302583/" rel="bookmark">
			初始Java篇（JavaSE基础语法）（6）（继承和多态）（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：JavaSE
多态篇
目录
多态的概念
实现多态的条件 必须在继承体系下实现向上转型：
子类必须对父类中的方法进行重写：
通过父类引用调用重写方法：
多态的优缺点：
避免在父类的构造方法中调用重写的方法
多态的概念 通俗来说，就是多种形态，具体点就是去完成某个行为时，当不同的对象去完成时会产生出不同 的状态。
例如：同样是吃早餐，这个人可能是吃包子，饺子；另外一个人却是吃面条。这就是不同的对象去完成同一件事情时所表现出来的状态不同。
实现多态的条件 既然了解了什么是多态，接下来要知道什么情况下可以实现多态。
要想实现多态得满足以下三个条件：
1. 必须在继承体系下实现向上转型。
2. 子类必须对父类中的方法进行重写。
3. 通过父类引用调用重写方法。
下面就来解释这三个条件。
必须在继承体系下实现向上转型： 就是指一个是子类，一个是父类，然后把子类对象给到父类的引用。 注意：这里的体系，说明不一定是要在直系继承关系下，可以是通过中间类间接继承。
例如：
向上转型：把子类对象给到父类的引用。
向下转型：将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的 方法，此时：将父类引用再还原为子类对象（强制类型转换）即可，即向下转换。简单理解就是把父类对象给到子类的引用。
结合该图理解 向上转型的语法格式：父类类型 名称 = new 子类类型(); 向下转型的语法格式与其差不多。
向上（向下）转型的应用场景：直接赋值、作为方法的参数、作为方法的返回值。、
例如：
//向上转型 public class Test { public static void func1(Animal animal) { System.out.println("向上转型的场景之一：方法参数"); } public static Animal func2() { System.out.println("向上转型的应用场景之一：方法的返回值"); Dog dog = new Dog("大黄", 5); return dog; //return new Dog("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eab48603384a8421f691bd7d2b302583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9a448f298ce5138af897f0e1fb0762/" rel="bookmark">
			SpringBoot @DS注解 和 DynamicDataSource自定义实现多数据源的2种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
在实际的项目中，我们经常会遇到需要操作多个数据源的情况，SpringBoot为我们提供了多种实现多数据源的方式。本文将介绍两种常见的方式：使用@DS注解实现多数据源的切换以及使用DynamicDataSource自定义实现多数据源的切换。
我们将分别介绍这两种方法的实现原理和代码实现，并对比它们的优劣势。
方式一、使用DynamicDataSource实现多数据源
1、在application.yml文件中配置多个数据源
# 数据源配置 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.cj.jdbc.Driver druid: # 主库数据源 master: url: jdbc:mysql://xxx.xxx.xxx.101:3306/test1?useUnicode=true&amp;characterEncoding=utf8&amp;allowMultiQueries=true&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=GMT%2B8 username: root password: root123 # 从库数据源 slave: # 从数据源开关/默认关闭 enabled: true url: jdbc:mysql://xxx.xxx.xxx.102:3306/test2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=GMT%2B8 username: root123 password: root123 oracle: enabled: true url: jdbc:oracle:thin:@//xxx.xxx.xxx.103:1521/test3?useUnicode=true&amp;characterEncoding=AL32UTF8 username: root password: root123 2、添加数据源到targetDataSources集合中
创建配置文件，把多个数据源添加到targetDataSources集合中，然后返回动态数据源配置。
/** * druid 配置多数据源 * * @author admin */ @Configuration public class DruidConfig { /** * master数据源的配置 */ @Bean @ConfigurationProperties("spring.datasource.druid.master") public DataSource masterDataSource(DruidProperties druidProperties) { // 创建Druid数据源 DruidDataSource dataSource = DruidDataSourceBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae9a448f298ce5138af897f0e1fb0762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313a08e73076289559f6a7b33fe3ece6/" rel="bookmark">
			2024年国内8个常用AI大模型的适用性比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讯飞星火认知大模型
讯飞星火认知大模型具备七大核心能力：文本生成、语言理解、知识问答、逻辑推理、数学能力、代码能力和多模态能力。
在知识学习与内容创作方面它可以进行要素抽取、问题生成，帮助知识学习和内容创作领域产生更丰富更有用的智能体，结合外部知识进行合理拓展。
适用性分析
用户可使用文本生成体验文档一键生成、AI撰写助手、多语种文档生成、AI 自动配图、多种模板选择、演讲备注等功能。通过提问获取生活常识、医学知识、政策解读等内容。
讯飞星火会分析问题的前提条件和假设来推理出答案或解决方案，给出新的想法和见解。在科研任务中，它可以使用已有的数据和信息进行推断、预测和验证。它还可以解决方程求解、立体几何、微积分、概率统计等数学问题。
在代码能力方面，根据注释、函数名智能生成代码，支持逐行代码注释，还可以精准定位代码语法、逻辑错误，甚至可以智能生成单元测试数据。
多模态能力方面，讯飞星火可根据用户上传图片返回准确的图片描述，或完成针对图片素材的问答，还可以凭借用户描述，生成期望的音频和视频。
文心一言大模型
文心一言能听懂潜台词、复杂句式、专业术语、前后乱序、模糊意图等复杂提示词，也能胜任代码理解与调试任务。
适用性分析
文心一言可以应用于小说、散文、诗歌等文学作品的创作。
文案创作方面，可以撰写商业计划、市场分析报告等商业文案。提供广告创意思维、灵感和想法，快速构思出吸引人的广告文案和宣传语；文心一言的聊天机器人应用于生活服务、教育辅导、客服等领域。
多模态生成方面，文心大模型支持图像生成和处理，可以根据用户需求生成图像或者对已有图像进行处理编辑。文心大模型还支持语音合成、语音识别和音频分类。文心大模型还能对视频数据进行处理，或将文本转化为动态图像序列完成视频分类、目标检测等任务。
数理逻辑推算方面，文心大模型可以解决复杂的数学问题，也可以成为代码编写助手，比如百度基于文心大模型研制了智能代码助手 Comate，提供智能推荐、智能生成、智能问答等多种功能，支持多种编程语言和IDE。
生成能力方面，能快速生成风格多样的文本、代码、图片、图表、视频，比如进行文案创作、制定生活计划、编写高质量代码。
逻辑能力方面，能帮用户解决复杂的逻辑难题、困难的数学计算、重要的职业/生活决策、代码纠错、常识推理、逻辑校验、立体几何、辩论灵感等。
记忆能力方面，经过多轮对话后，文心一言依然能记住对话的重点，轻松胜任复杂问题、沉浸体验角色对话。
通义千问大模型
通义千问能在创意文案、办公助理、学习助手、趣味生活等方面为使用者提供丰富的交互体验。
适用性分析
创意文案应用包括：“撰写营销文案”，输入产品介绍获得量身定制的金牌营销文案。“文章润色”能对用户提交的文章进行深度分析，挖掘其中表达不足之处，提供词汇句式变化建议。“直播带货剧本生成”，基于丰富的商品信息和用户需求，为电商主播提供生动有趣且具有营销力的脚本内容。
办公助理应用于：“SWOT 分析”为用户提供全面、深入且精准的战略决策支持，从多元视角理解并评估内外部环境对特定项目的影响。“PPT 框架生成”，智能地为用户构建专业且逻辑清晰的 PPT 结构。
学习助手应用包含了：“题目加工厂”，根据提供的专业以及学科领域进行高质量试题生成，大大节省了教师、家长以及教育机构在出题上的时间和精力。“学习计划站”可为用户提供个性化、系统化的学习路径规划，定制高效且科学的学习日程安排。
趣味生活应用有：“会放飞的菜谱”，输入菜名逐步指导提供美食烹饪秘诀。“AI 健身教练”为用户制定专属健身计划。“写歌词”，根据用户提示的歌名写出生动歌词。
赤兔大模型
赤兔大模型是容联云开发的面向企业应用的垂直行业多层次大语言模型，赋能企业搭建专属智能客服和数智化营销，包含会话洞察、业务话术、问答知识库、知识运用、数据分析、智能对话框架、流程管理。三个核心点分别是智能性、可控性和投产比。
适用性分析
基于赤兔大模型，容联云发布了生成式应用“容犀 Copilot”。
大模型话术：容犀Copilot后台一键快速对海量历史会话数据进行核对筛选，挑选出更佳话术并生成金牌话术，兼顾质与量的同时，挖掘出客户高频关注的问题，从问题中洞悉业务痛点。
智能知识库：可以帮助企业从零开始、低成本地快速构建话术库，包括理解文档知识、知识快搜、智能问答等，大幅提升构建效率。
会话洞察：高效便捷洞察每一通会话沟通情况，分析客户诉求，精准诊断问题并优化。回归实际业务本身，容犀Copilot深入金融行业细分场景，打造场景化客服助手，譬如分期挽留助手、荐卡挽留助手、投诉安抚助手等，实时辅助快速洞察客户需求，推荐更佳应答话术，诊断客户情绪变化，提醒措辞及注意事项。
文修大模型
文修大模型为政务单位、新闻媒体、企业单位、学校机构、出版机构等专业用户提供更贴合使用场景的校对服务。具备校对能力强、速度快、匹配度高三大特点，更好地解决垂直行业的问题。
适用性分析
政务单位领域，赋能各级政务部门校对流程智能化，提供文字材料的内容错敏校对、修改提示和文本润色等服务，全力保障内容的准确性及严谨性，支持内网环境下校对，满足更高保密需求。
新闻媒体领域，文修大模型深入新闻媒体工作的各个环节，对多模态内容进行多类错敏校对，帮助快速定位错误并高亮显示，让内容更加规范严谨，有效维护官方账号的公信力；同时提供文本润色服务，提高出稿速度，保障新闻时效性。
企业单位领域，全流程切入企业办公场景，从内容纠错、提升文本质量等多方位出发，优化宣发内容，提高文案吸引力，助力营销效果显著提升。
学校机构领域，针对学校机构的宣传材料、新媒体稿件、科研报告、学术论文等内容进行全面校审，有效降低文字错误率，保障学术严谨性。通过 AI 润色功能助力文章、报告、材料的起草、优化工作，有助于进一步提升学校传播力、影响力；出版机构领域，提供专业、便捷、高效的内容筛查及文字质量把关服务，协助各出版机构高效处理多语言文本，降低内容差错概率，保障内容的规范性、准确性。
YonGPT大模型
YonGPT在企业服务领域的应用主要集中在4个方向：业务运营、人机交互、知识生成、应用生成。
适用性分析
在智能化业务运营方面，YonGPT通过数据分析和预测能力，深入洞察企业运营、识别潜在的业务风险和机会，并提供智能化的解决方案，从而提高经营决策水平和业务运营效率。
在自然化人机交互方面：YonGPT通过强大的自然语言处理技术和理解能力，使能企业应用和服务与用户进行自然而流畅的对话交流，以“人”为本的方式实现不同应用的调用、连接、组装，更自然、高效地完成工作。
在智慧化知识生成方面：YonGPT 通过从海量数据和信息中提取、整合知识，生成新的、有价值的知识内容，涵盖了行业解决方案、专业领域知识分享，助力企业和用户全面利用自身知识的储备和积累，促进知识的传播和应用。
在语义化应用生成方面：YonGPT 通过对用户需求、企业业务和数据特征的理解，可以自动生成具有语义化能力的应用程序，全方位提升企业个性化应用服务的创建效率。
YonGPT的智能化场景服务中有四个服务：
企业收入/利税经营智能分析，可以实时掌控经营状况、快速洞察问题所在、精准预测企业效益、有效预见应对变化。
智能生单，融合了丰富的供应链经验，通过“交互革新式”订单生成助手，实现快速智能生单，提高企业效能。
智能招聘，通过 AI 互动优化应聘体验，实现选人、用人的精准决策。
智能大搜，提供“沉浸式”搜索新体验，加速企业知识的价值化服务，并洞察用户需求、实现搜推一体，让知识赋能业务和组织。
“写易”智能创作引擎
“写易”智能创作引擎适合党政党媒、央企国企、学校医院等有日常阅读需求和写作需求的群体。“写易”智能创作引擎深入挖掘用户需求，构建了“随查”“随写”“随审”的交互体验, 具有创作高效、安全准确、内容丰富的特点。
适用性分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/313a08e73076289559f6a7b33fe3ece6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdb20f0817cd10750b23275eeec9924/" rel="bookmark">
			SpringBoot3&#43;ShardingJDBC5.5.0 读写分离配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上自己找了很多教程但是配合SpringBoot3都无法使用，经过实验发现只有最新版5.5.0支持SpringBoot3x现在把相关读写分离配置分享给大家 相关springboot3的包这里就不多赘述，我使用的是MybatisPlus 3.5.5
首先导入相关jar包
&lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;shardingsphere-jdbc&lt;/artifactId&gt; &lt;version&gt;5.5.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;shardingsphere-test-util&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 这里放一个完整的pom给大家看看
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;groupId&gt;com.yijun.sharding.jdbc&lt;/groupId&gt; &lt;artifactId&gt;spring-boot3-sharding-jdbc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot3-sharding-jdbc&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;3.2.4&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.13.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccdb20f0817cd10750b23275eeec9924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1222f8ab162e28c314a0a65fe8fae42f/" rel="bookmark">
			生成式AI（GAI）与AI生成内容（AIGC）：猴子也能看懂的科普
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在谈论人工智能（AI）时，有两个词你可能会经常听到：生成式AI（GAI）和AI生成内容（AIGC）。这两个听起来高大上的术语，实际上与我们日常生活息息相关。那么，它们究竟是什么？又能做什么呢？让我们一起来揭开它们的面纱。
GAI：像艺术家一样的AI 想象一下，有一个机器人，它不仅能执行命令，还能像艺术家一样创作诗歌、绘画、音乐。这就是生成式AI（GAI），它是人工智能领域的一个神奇分支。在这一章，我们将深入浅出地了解GAI，看看它是如何工作的，以及它在我们生活中的应用。
GAI是什么？
定义：GAI，即生成式人工智能，是一种能够创造新内容的人工智能技术。它不同于我们常见的执行特定任务的AI，如语音助手或推荐算法，GAI更注重创造性和生成能力。工作原理：GAI通过深度学习和神经网络等技术，从大量数据中学习。这些数据可以是文本、图像、音乐等。通过学习，GAI能够理解特定的风格或模式，并据此生成新的内容。 GAI能做什么？
文本创作：GAI可以写文章、诗歌、故事。比如，给它一个主题或关键词，它就能创作出相关的内容。图像生成：GAI可以绘制图画、设计图形。你只需要告诉它你想要的风格或元素，它就能生成相应的图像。音乐创作：GAI还能作曲、编曲。你可以告诉它你喜欢的音乐风格或节奏，它就能创作出相应的音乐作品。 GAI的实际应用
艺术创作：艺术家和设计师可以利用GAI来创作新颖的艺术作品，如绘画、雕塑等。游戏开发：在游戏设计中，GAI可以用来生成独特的角色、场景和故事情节。广告营销：广告公司可以利用GAI来创造吸引人的广告图像和文案，提高广告效果。教育辅导：在教育领域，GAI可以辅助教学，如为学生提供个性化的学习材料和练习题。 结论
生成式AI（GAI）就像一个多才多艺的艺术家，它不仅能够执行命令，还能创作诗歌、绘画、音乐等。随着技术的进步，GAI的应用领域将更加广泛，为我们带来更多的便利和创新。
AIGC：AI的创造工厂 想象一下，有一个工厂，它生产的不是实物产品，而是各种内容——文章、图片、视频等。这个工厂就是AI生成内容（AIGC）。在这一章，我们将深入了解AIGC，看看它是如何工作的，以及它在我们生活中的应用。
AIGC是什么？
定义：AIGC，即人工智能生成内容，是指利用AI技术生成各种形式的内容。这些内容可以是文本、图像、音频或视频等。工作原理：AIGC通过深度学习等技术，从大量数据中学习特定的模式或风格，然后生成新的内容。比如，它可以学习特定艺术家的绘画风格，然后创作出类似风格的画作。 AIGC的技术演进
早期阶段：早期的AIGC主要用于生成简单的数据，如自动生成的新闻报道、基于模板的邮件回复等。现代发展：随着技术的发展，现代AIGC能够生成更加复杂和高质量的内容。例如，基于深度学习的AIGC模型可以生成逼真的图像或视频，甚至模仿特定艺术家的风格。 AIGC的实际应用
新闻生成：AIGC可以自动生成新闻报道，尤其是在需要快速发布大量信息的情况下，如体育赛事或股市动态。虚拟现实：在虚拟现实（VR）领域，AIGC可以用来创建逼真的虚拟环境，为用户提供沉浸式的体验。在线教育：AIGC可以提供个性化的在线教育内容，如根据学生的学习进度和兴趣生成定制化的练习题和教学视频。广告设计：AIGC可以创作吸引人的广告图像和文案，提高广告的吸引力和效果。 结论
AI生成内容（AIGC）就像一个高效的创造工厂，它能够利用AI技术生成各种形式的内容。随着技术的进步，AIGC的生成质量和应用范围不断扩大，为我们的生活和工作带来了便利和创新。
GAI与AIGC的相互作用 生成式AI（GAI）和AI生成内容（AIGC）是人工智能领域的两个重要分支，它们在技术和应用上有着紧密的联系。在这一章，我们将探讨GAI与AIGC之间的关系，以及它们如何相互促进，共同推动AI技术的发展。
技术关联
GAI是AIGC的技术基础：GAI提供了生成新内容的能力，是AIGC实现内容生成的核心技术。没有GAI的创造性生成能力，AIGC就无法实现其内容生成的目标。AIGC是GAI的应用体现：AIGC是GAI在具体应用领域的体现，如内容创作、数据分析等。通过AIGC，GAI的技术能力得以在实际应用中发挥价值。 协同发展
技术进步的相互促进：随着GAI技术的进步，AIGC的生成质量和应用范围不断扩大。例如，GAI技术的提升使得AIGC能够生成更加逼真和高质量的内容。应用领域的拓展：GAI和AIGC在多个领域的应用相互促进。例如，在艺术创作领域，GAI提供了创作新颖作品的能力，而AIGC则将这些作品应用到实际的创作过程中。 实际案例
艺术创作：GAI可以创作新颖的艺术作品，而AIGC则将这些作品应用到实际的创作过程中，如生成艺术展览的宣传材料。广告营销：GAI可以创作吸引人的广告图像和文案，而AIGC则将这些内容应用到实际的广告营销活动中，提高广告效果。在线教育：GAI可以创作个性化的学习材料，而AIGC则将这些材料应用到实际的在线教育平台中，提供个性化的学习体验。 结论
生成式AI（GAI）和AI生成内容（AIGC）在技术和应用上相互关联、相互促进。GAI提供了生成新内容的能力，是AIGC的技术基础；而AIGC则是GAI在实际应用中的体现。两者共同推动了AI技术在内容生成领域的快速发展，为我们的生活和工作带来了便利和创新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ea3d1a77d3649ffc8bfa95bab7f8fe6/" rel="bookmark">
			【Mac】Lightroom Classic 2024 v13.1安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件介绍 Lightroom Classic 2024是Adobe公司推出的一款专业的数字图像处理软件，旨在为摄影师提供强大的工具和功能，以管理、编辑和分享他们的照片作品。以下是Lightroom Classic 2024的主要特点和功能：
数字照片管理： 提供直观的图像组织和管理工具，帮助用户轻松管理数千张照片。支持关键字标记、评分、筛选和搜索功能，方便用户快速找到所需照片。 非破坏性编辑： 提供丰富的编辑工具，包括基本的曝光、色调、饱和度调整，以及高级的局部调整和修饰。所有编辑都是非破坏性的，原始图像文件保持不变，用户可以随时撤销编辑操作。 批量编辑和同步： 支持批量编辑多张照片，节省用户时间和劳动成本。可以将编辑设置同步到多张照片中，确保风格一致性和效率。 RAW 文件处理： 兼容各种相机原始格式（RAW），提供高质量的RAW文件处理和转换功能。支持减少噪点、提高清晰度、修复镜头畸变等功能，使照片更加清晰和真实。 分享和输出： 支持将照片导出为各种格式和尺寸，包括JPEG、TIFF、PNG等。可以直接分享照片到社交媒体平台，如Instagram、Facebook等，或者输出到打印或在线相册。 插件和扩展性： 提供丰富的第三方插件和扩展，扩展软件功能和用户体验。用户可以根据自己的需求选择合适的插件，增强软件的功能和效果。 总体来说，Lightroom Classic 2024是摄影爱好者和专业摄影师的理想选择，提供了全面的工作流程和专业的编辑工具，帮助用户管理、编辑和分享他们的照片作品。
准备工作 重要的事情说三遍！
安装软件之前必须先看这篇文章：https://mac.shuiche.cc/article/info-9
安装软件之前必须先看这篇文章：https://mac.shuiche.cc/article/info-9
安装软件之前必须先看这篇文章：https://mac.shuiche.cc/article/info-9
安装软件的前置条件完成后，我们就可以安装Lightroom Classic 2024了。
安装步骤 1.打开安装包，双击Install安装包进行默认安装，如下图：
2.点击继续。
3.等待安装完成后点击关闭即可。
安装过程中如果弹出访问钥匙串密码，输入电脑开机密码后，选择始终允许。
4.安装完成后，打开LrC，先试用一下，弹出试用点击试用。
情况一：如果弹出您的Lightroom Classic试用已结束，直接点击忽略，然后关闭软件，直接开始第5步。
情况二：如果弹出您的Lightroom Classic试用已结束，直接点击取消，然后关闭软件，直接开始第5步。
情况三：如果弹出7天免费试用，直接点击试用，然后关闭软件，开始第5步。
在情况三下，建议在图库中导入一些图片，使用「修改照片」功能，看下是否正常
5.回到安装包，打开「lr pj补丁」，点击继续。
6.继续。
7.选择Lightroom Classic，然后点击安装。
8.等待安装，安装完成后，软件就可以使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcdca2c47010273837a3a22318e7629c/" rel="bookmark">
			2024年最新AI绘画普及课【二】文生图入门_平铺 分块 (tiling)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正面提示词： (1girl:2.0), solo, nilou \(genshin impact\), solo, long hair, jewelry, blue gemstone, earrings, horns, crown, cyan satin strapless dress, white veil, neck ring, red hair, {green eyes}, ((full body)), (SFW:1.5), front, highly detailed face, curvy body, skindentation, hands up, happy smily face, pureerosface_v1, hiqcgbody, {{masterpiece}}, {best quality},{highresl}, original, reflection,Exaggerated body proportions, greasy skin, realistic and delicate facial features, depth of field, extremely detailed CG unity 8k wallpaper, bloom, shine, (illustration), (painting), (sketch), anime coloring, fantasy, unreal engine, body shadow, artstation indoor, sitting on sofa, sunset, backlighting, shiny skin, lens flare, light particles, glowing, dappled sunlight, extreme shadow and light, long shadow, light rays, sun wind blow, maple leaf, cloudy sky, dusty, forest, plant, flower 反面提示词： EasyNegative, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)),((grayscale)),skin spots, acnes, skin blemishes, age spot, (outdoor:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcdca2c47010273837a3a22318e7629c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bbcabea9b79c595524c28be1e1711e8/" rel="bookmark">
			最新AI创作系统，ChatGPT商业运营系统网站源码，SparkAi-v6.5.0，Ai绘画/GPTs应用，文档对话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文章前言 SparkAi创作系统是基于ChatGPT进行开发的Ai智能问答系统和Midjourney绘画系统，支持OpenAI-GPT全模型+国内AI全模型。本期针对源码系统整体测试下来非常完美，那么如何搭建部署AI创作ChatGPT？小编这里写一个详细图文教程吧。已支持GPTs、GPT语音对话、GPT-4模型、GPT联网提问、DALL-E3文生图、图片对话能力上传图片，GPT4-All联网搜索模型、文档分析、Midjourney绘画动态全功能、AI换脸、垫图混图、插件功能、支持最近火爆的Suno-v3-AI音乐生成大模型。
《SparkAI系统介绍文档 - 渐进式AIGC系统》:
SparkAI系统介绍文档 - 渐进式AIGC系统
1.1 系统架构技术栈 前端： Vite + vue3 + ts + NaiveUI + Tailwindcss
管理端：Vite4 + Vue3 + Element-Plus
服务端（后端）：Nodejs + NestJs
数据支持： Mysql5.7(+) + Redis
运行环境：Linux、Windows、MacOs（推荐使用Linux）
数据存储：本地存储 | 阿里云oss | 腾讯云cos | chevereto图床
1.2 特色功能 ①GPT语音对话功能 支持电脑PC浏览器和手机端使用，具有”人的语气“
​
②GPTs应用 ​
③GPT4-All联网搜索模型 ​
④文档分析 ​
⑤Suno-AI音乐生成 ⑥局部编辑重绘 ​
⑦说图解文 ​
1.3 程序核心功能 已支持 OpenAI GPT全模型 + 国内AI全模型 + 绘画系统 +GPTs+ MJ局部编辑重绘功能+语音对话功能 + 文档分析功能 + Midjourney绘画动态全功能+插件功能！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bbcabea9b79c595524c28be1e1711e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad06c72ffc26394eef109942c89952f7/" rel="bookmark">
			Mac环境下ollama部署和体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎访问我的GitHub 这里分类和汇总了欣宸的全部原创(含配套源码)：https://github.com/zq2599/blog_demos
关于ollama ollama和LLM（大型语言模型）的关系，类似于docker和镜像，可以在ollama服务中管理和运行各种LLM，下面是ollama命令的参数，与docker管理镜像很类似，可以下载、删除、运行各种LLM Available Commands: serve Start ollama create Create a model from a Modelfile show Show information for a model run Run a model pull Pull a model from a registry push Push a model to a registry list List models cp Copy a model rm Remove a model help Help about any command 官网：https://ollama.com/非常简洁
本篇概览 作为入门操作的笔记，本篇记录了部署和简单体验ollama的过程，并且通过docker部署了web-ui，尝试通过页面使用大模型本次操作的环境如下 电脑：macbook pro m1，Sonoma 14.4.1ollama：0.1.32 安装 在官网首页点击Download即可下载，得到zip安装包，解压后就是应用程序了
会提示是否移动到应用程序目录，回车确认
打开后是个简单的页面
完成安装，会有一个提示，告诉你如何安装指定模型
关于模型 ollama支持的全量模型在这里：https://ollama.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad06c72ffc26394eef109942c89952f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925e7e9de61cbaf44845b227e03365f4/" rel="bookmark">
			从原理到实践：学习Java中OutputStreamWriter的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，各位小伙伴们，你们好呀，我是喵手。运营社区：C站/掘金/腾讯云；欢迎大家常来逛逛
今天我要给大家分享一些自己日常学习到的一些知识点，并以文字的形式跟大家一起交流，互相学习，一个人虽可以走的更快，但一群人可以走的更远。
我是一名后端开发爱好者，工作日常接触到最多的就是Java语言啦，所以我都尽量抽业余时间把自己所学到所会的，通过文章的形式进行输出，希望以这种方式帮助到更多的初学者或者想入门的小伙伴们，同时也能对自己的技术进行沉淀，加以复盘，查缺补漏。
小伙伴们在批阅的过程中，如果觉得文章不错，欢迎点赞、收藏、关注哦。三连即是对作者我写作道路上最好的鼓励与支持！
前言 在Java中，有很多IO操作的类，其中OutputStreamWriter也是一个很重要的类。OutputStreamWriter是一个字符流和字节流之间的桥梁，可以将写入字符流的字符编码成字节，写入底层的字节流中。在日常开发中，我们使用这个类可以实现将字符流写入到磁盘文件，网络连接等底层字节流的输出操作。
摘要 本文将介绍OutputStreamWriter的源代码解析、应用场景案例、优缺点分析、类代码方法介绍、测试用例以及全文小结。
OutputStreamWriter类 简介 Java中的OutputStreamWriter类是将字符流转换为字节流的桥梁。它接受一个字符流并将其编码为字节流输出。
OutputStreamWriter可以将字符流写入到指定的输出流中，例如文件，套接字或管道。它还可以指定编码类型，例如UTF-8，ISO-8859-1等。
使用OutputStreamWriter时，需要先创建一个OutputStream对象，然后使用此对象创建OutputStreamWriter对象。然后可以使用OutputStreamWriter对象的write方法将字符写入到输出流中。
源代码解析 OutputStreamWriter继承了Writer类，实现了Flushable,Closeable,Appendable三个接口。它的作用就是将字符流转换成字节流，以便后续操作。下面我们来看一下其关键代码：
public class OutputStreamWriter extends Writer { private static final int DEFAULT_BUFFER_SIZE = 8192; private final StreamEncoder se; ... public OutputStreamWriter(OutputStream out, Charset cs) { super(out); if (cs == null) throw new NullPointerException("charset"); se = StreamEncoder.forOutputStreamWriter(out, this, cs); } ... public String getEncoding() { return se.getEncoding(); } ... public void flush() throws IOException { se.flush(); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/925e7e9de61cbaf44845b227e03365f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7037d9741f53387076e66a4c3f42219d/" rel="bookmark">
			WebStorm2024版 将项目上传到gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备
WebStorm
gitee
二、上传代码到Gitee
三、过程中遇到的问题 报错：You may want to first integrate the remote changes (e.g., 'git pull ...') before pushing again.
报错：fatal: refusing to merge unrelated histories
报错：fatal: Exiting because of unfinished merge.
一、准备 WebStorm 打开WebStorm，点击"更多符号"选择设置，在插件商店中搜索，并且安装插件Gitee(码云)，安装完后点“Apply”，再重新打开Version Control就有了。
然后进入“version control”，找到Gitee，登录到Gitee系统登录自己的gitee账号，如下图所示
接下来在弹出的 Gitee 登录界面输入账号信息登录到系统，登录成功后，授权给 WebStorm 软件。
在设置中确定 Gitee账户信息，
gitee （1）需要创建一个仓库。（此处我创建的仓库名字是“oj-frontend”）
创建仓库比较简单，下面两张图就是整个过程，这里不在赘述。
二、上传代码到Gitee （1）首先添加项目到本地仓库，这步操作对应“git add”命令，
（2）提交项目目录，这步操作对应“git commit”命令，
若是初次使用，则需要在WebStorm配置连接到的Gitee上的哪个仓库。
进入后，可以看到新增加的项目，这个时候还没有仓库URL，点击 Define remote，将创建的Gitee仓库所提供的 HTTPS地址复制粘贴到这里。
打开webstrom左下角的“git”，可以看到相应的信息，右边就是我们将要提交到仓库中的文件信息
（3）推送项目到Gitee，推送你的项目的更改到Gitee上的远程仓库“oj-frontend”，
（4）进入我们Gitee中的仓库，可以看到我们上传上去的项目代码，
三、过程中遇到的问题 报错：You may want to first integrate the remote changes (e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7037d9741f53387076e66a4c3f42219d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc667cd3ba76f1b0ea4922a724170c9c/" rel="bookmark">
			Stable Diffusion WebUI 中调度器（Schedule type）简单研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💎内容概要 在近期，stable diffusion webui更新了1.9版本，其中包含的一项变化就是，把采样器和调度器（Schedule type）分开了，之前是合并在一起来选择的，所以这篇文章主要分两个部分，第一个部分是作者为什么把他们给分开了，第二个是采样器和调度器的概念对于设计师来说，是否需要重点理解。
✨作者怎么说 了解原作者的思路，还是得从官方更新说明上看，主要是这几个相关的帖子：
1.9.0 · AUTOMATIC1111/stable-diffusion-webui · Discussion #15498 · GitHub
这里分为两块，一块是在UI界面上增加了调度器的设置的说明：
emm，简单来说，就是没有太多说明，如果是选择了Automatic，那么会根据采样器自动调取最合适的调度器。
所以，对于使用来说，大家默认选择“Automatic”就好了。
另外还有一个相关的帖子，是关于SDXL-Lightning模型的。
原帖地址在：Sgm uniform scheduler for SDXL-Lightning models by KohakuBlueleaf · Pull Request #15325 · AUTOMATIC1111/stable-diffusion-webui · GitHub
(马赛克部分请忽略，虽然是比较正常的图片，但是csdn的图片屏蔽尺度比较神奇，我就先马赛克为净了)
SDXL-Lightning模型，大家应该之前也都了解过，可以更少的步数，更快的速度，生成质量还不错的图片，所以现在在各个模型网站上还是有一席之地的，貌似感觉比turbo模型更受欢迎一些？
在这位朋友的测试下，SGM Uniform的调度器会比其他调度器更适合lightning类型的模型，并且做了一些尝试，在Euler采样器下，4步采样，分别使用不同的调度器，生成结果如上图，的确SGM Uniform在这里看起来更好一些。
我也做了一点尝试。
模型使用的是，TAILANG XL-Lightning-2.5D 闪电_2.0.safetensors
（大家如果感兴趣也可以自行下载，不需要魔法：LiblibAI·哩布哩布AI -TAILANG XL-Lightning-2.5D 闪电_2.0.safetensors）
SGM Uniform + Euler + 4Steps Automatic + Euler + 4Steps SGM Uniform + Euler + 4Steps Automatic + Euler + 4Steps emm,从效果上看，如果都是4steps，固定种子，SGM Uniform调度器的确会好一丢丢，所以如果追求极致的话，大家还是需要记得在使用lightning模型时，记得手动更改下这个调度器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc667cd3ba76f1b0ea4922a724170c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f3ec43749766e70c19635ac78274de/" rel="bookmark">
			链表经典面试题上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
创作不易，如若对您有帮助，还望三连，谢谢！！！
题目一：203. 移除链表元素 - 力扣（LeetCode）
题目二：206. 反转链表 - 力扣（LeetCode）
题目三：876. 链表的中间结点 - 力扣（LeetCode）
题目四：面试题 02.02. 返回倒数第 k 个节点 - 力扣（LeetCode）
题目五：21. 合并两个有序链表 - 力扣（LeetCode）
题目六：面试题 02.04. 分割链表 - 力扣（LeetCode）
题目七：160. 相交链表 - 力扣（LeetCode）
题目八：141. 环形链表 - 力扣（LeetCode）
拓展问题：
创作不易，如若对您有帮助，还望三连，谢谢！！！ 之前我们学习了单链表，实现了单链表的一系列的功能，今天我们来讲解一下链表的一些经典面试题目，以便巩固我们对链表的理解。
话不多说，我们直接来看题目：
题目一：203. 移除链表元素 - 力扣（LeetCode） 我们看题目：给定一个单链表和头结点，让我们删除所有满足 Node.val == val 的节点，并返回 新的头节点 。
思路：创建新链表，遍历原链表，将原链表中值不为val的节点尾插到新链表中。我们之前在实现单链表功能中写过尾插的方法，所以这里就不在赘述，代码如下：
这段代码创建了一个新的带头单链表，并将原链表中满足条件的节点进行尾插，最后释放了dummy，防止内存泄漏。
那么，这段代码有问题吗？有什么问题呢？
有小伙伴会说：没有考虑链表为空的情况，题目说了链表可能为空。仔细看我们这段代码：当head为空时，不会进入while循环，最后返回NULL,没有什么问题，那么我们代码是正确的吗？我们先运行一下代码：
结果有问题，为什么最后一个值为6的节点没有被删除呢？我们回头看一下我们尾插的代码：
最后一步，pcur指向最后一个节点，节点的值为6，不满足条件，故pcur指向NULL,跳出while循环，但此时新链表最后一个节点（值为5）的next指针指向哪里呢？我们并没有修改它，所以它会指向原链表的最后一个节点，所以才会引发错误，所以我们只需要在while循环后加入一个 ：newTail-&gt;next=NULL即可，修改后的代码如下：
题目二：206. 反转链表 - 力扣（LeetCode） 这一题同样提供两种思路：
思路一：创建新链表，遍历原链表，在新链表中进行头插操作，从而达到反转链表的目的。
思路二：定义三个指针，用三个指针遍历链表，在原链表上完成反转操作。
思路一我们之前也讲过头插，代码比较简单，我们主要讲一下思路二：
代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38f3ec43749766e70c19635ac78274de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c9be9b00555928a8853d8199456ac8/" rel="bookmark">
			在java中进行日期时间比较的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Date date2 = sdf.parse(“2019-01-31”);
System.out.println("date1 : " + sdf.format(date1));
System.out.println("date2 : " + sdf.format(date2));
if (date1.compareTo(date2) &gt; 0) {
System.out.println("Date1 时间在 Date2 之后"); } else if (date1.compareTo(date2) &lt; 0) {
System.out.println("Date1 时间在 Date2 之前"); } else if (date1.compareTo(date2) == 0) {
System.out.println("Date1 时间与 Date2 相等"); } else {
System.out.println("程序怎么会运行到这里?正常应该不会"); }
}
输出结果： date1 : 2009-12-31
date2 : 2019-01-31
Date1 时间在 Date2 之前
[]( )2\. Date.before（），Date.after（）和Date.equals（） ----------------------------------------------------------------------------------------------------- 一种语义上比较友好的方法来比较两个`java.util.Date` @Test
void testDateCompare2() throws ParseException {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79c9be9b00555928a8853d8199456ac8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf831fc3e6e5fafe2ed38292e854c96/" rel="bookmark">
			JavaScript之append、appendChild、innerText、innerHTML与textConten的区别、getTime、createElement、createTextNode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MENU 前言appendappendChildinnerTextinnerHTMLtextContent其他appendappendChildinnerHTML区别性能案列createTextNodecreateElementgetTime 前言 在JavaScript中，append、appendChild、innerText、innerHTML与textContent是处理DOM(文档对象模型)的常见属性和方法。
1、如果要添加子节点，推荐使用append方法，它更简洁且支持添加多个节点。
2、如果只需要添加一个子节点，则可以使用appendChild方法。
3、如果要设置元素的文本内容，且不涉及HTML标记，可以使用textContent属性，它的性能更好。
4、如果需要操作包含HTML标记的内容，可以使用innerHTML属性，但要注意潜在的安全风险。
5、innerText属性可以用来获取已渲染的文本内容，但在设置文本时不够灵活，不推荐在修改内容时使用。
append 1、append方法用于将一个或多个节点或文本作为最后一个子节点添加到指定父节点的子节点列表中。
2、该方法直接操作DOM，不返回新创建的节点。
3、可以通过传递一个或多个参数来添加多个节点。
4、它是较新的方法，可能不被所有浏览器完全支持。
const parent = document.getElementById('parent'); const child = document.createElement('div'); child.textContent = 'Child element'; parent.append(child); appendChild 1、appendChild方法用于将一个节点添加到另一个节点的子节点列表的末尾。
2、类似于append方法，但只能接受一个参数。
3、是较旧的方法，在所有主流浏览器中都受到支持。
const parent = document.getElementById('parent'); const child = document.createElement('div'); child.textContent = 'Child element'; parent.appendChild(child); innerText 1、innerText属性设置或返回指定元素的文本内容，其中包含所有HTML标记。
2、会返回已渲染的文本，会触发浏览器的重绘和回流。
3、不会返回隐藏的文本，如通过CSS的display: none;或visibility: hidden;隐藏的元素文本。
const element = document.getElementById('example'); console.log(element.innerText); element.innerText = '关注“代码农”微信公众号'; innerHTML 1、innerHTML属性设置或返回指定元素的HTML内容，包括所有HTML标记。
2、会将字符串解析为HTML，并在指定元素内部生成对应的DOM树。
3、可以用来动态添加或更新HTML内容，但潜在的安全风险较高。
const element = document.getElementById('example'); element.innerHTML = '&lt;strong&gt;New content&lt;/strong&gt;'; textContent 1、textContent属性设置或返回指定元素的文本内容，不包含任何HTML标记。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abf831fc3e6e5fafe2ed38292e854c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c380d11055987014b378b7615e3116f2/" rel="bookmark">
			C&#43;&#43;：map和set的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于红黑树的模拟实现，大家不清楚的先去看看博主的博客再来看这篇文章，因为set和map的封装底层都是利用用的红黑树。所以这里不会过多介绍红黑树的相关内容，而更多的是去为了契合STL中的红黑树去进行改造，让封装的set和map能够去复用我们的这份代码
DS进阶：AVL树和红黑树-CSDN博客
在模拟实现之前，我们肯定要尝试去看看源码是如何实现的！我们会发现其实map和set的底层都是用的红黑树去封装的
但是你可能会有这样的疑惑，map是kv模型，set是k模型，那难道stl底层封装了两颗红黑树么？？其实并不是的，创建stl的大佬们为了增加代码的复用性，想方设法地想让map和set同时复用一颗红黑树。而解决方法就是通过控制模版参数来区分map和set。
既然底层是套的红黑树的壳子，我们就要来研究库里面的红黑树究竟通过了什么方法来让map和set都能够复用这份代码。
一、STL中的红黑树 1.1 利用模版参数控制和区分map和set 我们先来看看stl中的红黑树的模版参数，然后进行分析
接下来我们来看看第三个模版参数的作用究竟是什么
总结：
第1个模版参数是为了帮助我们拿到Key的类型，因为find、erase的接口都是Key类型比较方便
第2个模版参数决定了红黑树节点中存的是key还是pair，以此来区分map和set
第3个模版参数是通过仿函数决定了是拿什么去进行比较，对set来说就是拿key，对pair来说就是拿他的first。
第4个模版参数是具体的比较逻辑，比如说我们传的是指针，但是我们并不想通过指针比而是通过指针解引用的类型比，就可以通过传这个仿函数去控制其比较的行为。
第5个是stl实现的一个堆内存管理器，是为了提高从堆区申请内存的效率，基本上所有的stl容器都会涉及到这个，所以目前暂时不需要太在意！
1.2 stl中的红黑树结构 在该图中，设置了一个哨兵节点，哨兵节点的左指向最小节点5，最大节点的右指向哨兵节点header， 为什么要这样设计呢？？
STL明确规定，begin()与end()代表的是一段前闭后开的区间，而对红黑树进行中序遍历后，
可以得到一个有序的序列，因此：begin()可以放在红黑树中最小节点(即最左侧节点)的位
置，end()放在最大节点(最右侧节点)的下一个位置，关键是最大节点的下一个位置在哪块？
能否给成nullptr呢？答案是行不通的，因为对end()位置的迭代器进行--操作，必须要能找最
后一个元素，此处就不行，因此最好的方式是将end()放在头结点的位置：
但是这样虽然方便我们找到第一个节点和最后一个节点，但是每一次都要最最左端和最右端的节点进行和头节点之间的联系，其实比较麻烦，所以下面我们直接改造成不带哨兵节点的红黑树。去模拟实现迭代器。
1.3 改造并模拟实现红黑树的迭代器 但是最最关键的逻辑就是，实现++和--这样迭代器才能跑的起来，下面我们来进行分析
迭代器的封装
template&lt;class T,class Ref,class Ptr&gt; struct _RBTreeIterator { typedef RBTreeNode&lt;T&gt; Node; typedef _RBTreeIterator&lt;T, Ref, Ptr&gt; Self; //返回一个自身的迭代器 typedef _RBTreeIterator&lt;T, T&amp;, T*&gt; iterator; //用来转化成const迭代器 Node* _node; _RBTreeIterator(Node* node) //利用节点去构造迭代器 :_node(node) {} // 1、typedef __RBTreeIterator&lt;T, T&amp;, T*&gt; itertaor; 拷贝构造 // 2、 typedef __RBTreeIterator&lt;T, const T&amp;, const T*&gt; const_itertaor; // 支持普通迭代器构造const迭代器的构造函数 _RBTreeIterator(const iterator&amp; it) //隐私类型转化 :_node(it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c380d11055987014b378b7615e3116f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26004bebb9b654dd6721ff738b411bcf/" rel="bookmark">
			RabbitMQ 中的 VirtualHost 该如何理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《一线大厂Java面试题解析+核心总结学习笔记+最新讲解视频+实战项目源码》，点击传送门，即可获取！
登录成功后，在 admin 选项卡可以查看所有用户：
可以看到，每个用户都有一个 Can access virtual hosts 属性，这个属性是啥意思呢？
今天松哥来和大家稍微捋一捋。
1. 多租户
RabbitMQ 中有一个概念叫做多租户，怎么理解呢？
我们安装一个 RabbitMQ 服务器，每一个 RabbitMQ 服务器都能创建出许多虚拟的消息服务器，这些虚拟的消息服务器就是我们所说的虚拟主机（virtual host），一般简称为 vhost。
本质上，每一个 vhost 都是一个独立的小型 RabbitMQ 服务器，这个 vhost 中会有自己的消息队列、消息交换机以及相应的绑定关系等等，并且拥有自己独立的权限，不同的 vhost 中的队列和交换机不能互相绑定，这样技能保证运行安全又能避免命名冲突。
我们并不需要特别的去看待 vhost，他就跟普通的物理 RabbitMQ 一样，不同的 vhost 能够提供逻辑上的分离，确保不同的应用消息队列能够安全独立运行。
要我来说，我们该怎么看待 vhost 和 RabbitMQ 的关系呢？RabbitMQ 相当于一个 Excel 文件，而 vhost 则是 Excel 文件中的一个个 sheet，我们所有的操作都是在某一个 sheet 上进行操作。
本质上来说，vhost 算是 AMQP 协议中的概念。
2. 命令行创建 vhost
先来看看如何通过命令行创建 vhost。
因为松哥这里的 RabbitMQ 是用 docker 安装的，所以我们首先进入到 docker 容器中：
docker exec -it some-rabbit /bin/bash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26004bebb9b654dd6721ff738b411bcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/376a45adffe98eefe56c04e4d3d7d606/" rel="bookmark">
			在autodl平台使用llama-factory微调Qwen1.5-7B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 部署环境 step 1. 使用24GB显存以上的显卡创建环境
step 2. 创建好环境之后，关闭环境，使用无卡模式开机（有钱可忽略）
step 3. 安装LLaMA-Factory
git clone https://github.com/hiyouga/LLaMA-Factory.git # conda create -n llama_factory python=3.10 # conda activate llama_factory cd LLaMA-Factory pip install -e .[metrics] step 4. 配置ModelScope下载模型环境
export USE_MODELSCOPE_HUB=1 # 更改模型缓存地址，否则默认会缓存到/root/.cache，导致系统盘爆满 export MODELSCOPE_CACHE=/root/autodl-tmp/models/modelscope # 学术资源加速 source /etc/network_turbo pip install modelscope vllm # 安装vllm时可能导致进程killed，需要降低内存安装 # pip install modelscope vllm --no-cache-dir step 5. 使用ModelScope下载模型
#模型下载 from modelscope import snapshot_download model_dir = snapshot_download('qwen/Qwen1.5-7B') step 6. 切换到 llama-factory 工作目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/376a45adffe98eefe56c04e4d3d7d606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5986557f87d669f6ac46a594c003d07/" rel="bookmark">
			161、Rust与Python互操作：性能与简易性的完美结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust与Python互操作：了解如何使用PyO3等库在Python中运行Rust代码 本文将介绍如何在Python中运行Rust代码，主要通过PyO3库来实现。我们将从基础知识开始，逐步深入，最后提供一些实用的技巧和案例。
Rust与Python的关系 首先，我们需要了解Rust和Python的关系。Rust是一种系统编程语言，它的主要特点是内存安全、零成本抽象和所有权模型。而Python是一种高级编程语言，它的主要特点是简洁易读、可扩展性强和广泛的应用生态。虽然两者的设计哲学和应用场景不同，但它们之间仍然可以实现互操作。
PyO3介绍 PyO3是一个Rust到Python的绑定生成器，它允许Rust代码在Python中运行。通过PyO3，我们可以将Rust代码编译成Python扩展，从而在Python中调用Rust代码。PyO3的使用非常简单，我们只需要在Rust代码中添加一些特定的注释和代码，就可以自动生成相应的Python绑定。
如何在Python中运行Rust代码 要在Python中运行Rust代码，我们需要进行以下几个步骤：
编写Rust代码编译Rust代码为Python扩展在Python中导入并使用Rust扩展
下面我们将通过一个简单的例子来演示这个过程。 示例：一个简单的Rust库 首先，我们编写一个简单的Rust库，这个库提供了一个函数，用于计算两个整数的和。
// Hello.rs // 添加外部链接 extern crate python3_sys as py; // 定义一个结构体，用于表示一个可调用对象 #[py::functional] struct Callable { a: i32, b: i32, } // 实现一个方法，用于调用这个结构体 #[py::methods] impl Callable { fn add(&amp;self) -&gt; i32 { self.a + self.b } } // 定义一个模块，用于导出这个结构体和方法 #[pymodule] fn hello(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; { m.add_function(wrap_pyfunction!(add, m)?)?; Ok(()) } 示例：编译Rust代码为Python扩展 接下来，我们需要将Rust代码编译成Python扩展。这个过程可以通过cargo命令行工具来完成。
首先，创建一个Cargo.toml文件，并添加以下内容：
[package] name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5986557f87d669f6ac46a594c003d07/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/385/">«</a>
	<span class="pagination__item pagination__item--current">386/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/387/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>