<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5775b02898afa88cfafcc5117c886b62/" rel="bookmark">
			MacOS下载安装JDK8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 今天给苹果电脑安装JDK环境，后续打算把Mac系统也用起来，也体验一把用苹果系统开发。
JDK就不过多介绍了，大家都是JAVA开发，JDK就是JAVA开发的必要环境。目前已经更新到JDK20了，不过我是不会更新的，因为：
他强由他强，清风拂山冈；
他横由他横，明月照大江；
他发任他发，我用Java8。
闲话少说，我们接下来进入正题开始下载安装JDK8。
二、下载JDK8 1、官网下载 官网下载需要注册登录Orcale账号，并且网络不稳定，下载速度可能慢。如果不想注册，不想登录的话可以跳过此步骤。
进入oracle官网：https://www.oracle.com/cn/java/technologies/downloads/
上面是最新版的JDK安装包，往下拉就能看到JDK8的版本
点击蓝色导航下载
然后就跳到登录页面了
2.其他途径下载 网站地址：http://www.codebaoku.com/jdk/jdk-index.html
选中对应版本，点击下载
选中版本点击下载
选择MacOS 安装包
选择浏览器下载
二、安装JDK 打开下载好的安装包，双击运行
接下来就是傻瓜式安装步骤，因为苹果没有分盘一说，所以就一直继续就行
三、JDK验证 打开电脑终端
输入命令
java -version 如下图所示，安装成功
四、环境变量配置 给jdk配置环境变量后，就可以在任何文件目录下都可以调用java。
1.在终端中输入命令查看JDK安装步骤 /usr/libexec/java_home -V 把安装路径复制一下一会需要用到
2.在终端输入命令 sudo vi ~/.bash_profile 提示输入本机密码，输入后会打开或新建 .bash_profile文件
按i 进入终端编辑模式
复制如下代码,引号里面的是 上面复制的安装目录地址，每个人可能都不一样，大家记得修改
export JAVA_HOME="/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home" 粘贴完成后如图：
按esc 退出编辑模式（注意看 insert 没了）
输入:wq 然后拍空格 保存并退出
在终端输入命令source .bash_profile 使刚才的配置立即生效
3.验证 随便找个文件夹，打开终端
输入命令，进行验证
java -version 至此MacOS 环境安装JDK8 完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b388aac71dc92d471ba4d01986b033/" rel="bookmark">
			智能笔触，情感涌现：AI绘画如何在副业领域捕捉人类情感的细腻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI绘画作为一颗璀璨新星，正以独特的方式捕捉并诠释人类复杂细腻的情感。这项技术不仅革新了艺术创作的手段，更为追求创意副业的人们开辟了一片充满潜力的新天地。本文将探讨AI绘画如何在捕捉情感方面展现其独到之处，并解析这一副业选择带来的多重益处。
情感的数字化桥梁 AI绘画的核心在于其深度学习算法对海量数据的学习与理解，这其中包括了对人类情感表达方式的分析。通过学习历史上众多艺术作品中蕴含的情感色彩和表达技巧，AI能够逐渐掌握如何将抽象的情感概念转化为具象的视觉语言。当用户输入特定的情感关键词或个人故事时，AI便能创作出反映这些情感的艺术作品，成为连接内心世界与外界的桥梁。
副业的个性化定制优势 对于那些希望利用业余时间从事艺术创作的人来说，AI绘画提供了一个低门槛、高效率的创作平台。不同于传统绘画需要长时间的技艺，AI绘画允许用户即使不具备深厚的美术基础，也能通过简单的指导生成富含个人情感色彩的作品。这种个性化的定制服务，不仅满足了消费者对独特艺术体验的追求，也为创作者打开了个性化副业的大门，如情感纪念画、心理疗愈艺术等新型服务，市场前景广阔。
创意产业的催化剂 AI绘画在副业领域的兴起，还促进了创意产业的多元化发展。艺术家和设计师可以利用AI作为创意辅助工具，快速探索不同的设计风格和概念，提高工作效率。同时，AI绘画的商业化应用，如广告设计、影视概念艺术、游戏原画等，为创作者提供了更多元的收入来源。这种技术与创意的结合，不仅丰富了市场上的艺术产品，还激发了整个行业对新技术融合创新的热情。
心灵共鸣的创造者 最重要的是，AI绘画在捕捉和传达情感方面的独特能力，使其成为连接人心的强有力媒介。一幅幅由智能笔触绘就的作品，能够触动观众的心弦，引发共鸣，甚至在某些情境下成为情感表达和心理疗愈的工具。对于副业创作者而言，这意味着他们能够通过AI绘画这一平台，传递正能量，影响他人，实现个人价值的同时，也为社会带来正面的影响。
分享一个我常用的AI网站：aicbo，这是一个集成了热门的GPT和Midjourney 等AI绘画的聚合网站，可以满足国内用户的使用习惯。
​轻松上手，即用即享：无需复杂下载，只需打开浏览器，访问官网，即可立即体验。
功能全面，覆盖各种AI应用场景及领域，满足各行各业的任务需求。
界面简洁，功能分区清晰，一目了然，轻松找到对应的功能选项并使用。
原创性：年底时各种总结、方案等文稿每天写不完，最近常用AI先行者生成文稿，AI先行者的原创性质量很高，避免了抄袭风险，只需稍作修改即可达到预期效果。
效率高：使用AI能在短时间内生成大量文稿，只需输入关键词，30秒内即可生成一篇文案，极大提升写作效率。
适用人群广泛：无论你是教育工作者、办公室人员、管理人员还是事业单位工作者，都可以使用AI先行者来撰写专业文稿。当你没有灵感，不知如何下笔写各种公文时，记得试试aicbo写作哟~ 。
结语 在智能笔触与情感涌现的交汇点，AI绘画不仅是一场技术革命，更是一次心灵的探索之旅。它以其独特的方式，让艺术创作跨越了技术与情感的界限，为追求副业梦想的人们开辟了一条充满机遇的道路。随着技术的不断进步和应用的深化，AI绘画副业的未来无疑将更加丰富多彩，持续地为人类情感的细腻表达贡献着不可替代的力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73cf087ead87fdcb694a07103b57fcd0/" rel="bookmark">
			2024最新版JavaScript逆向爬虫教程-------基础篇之无限debugger的原理与绕过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、无限debugger的原理与绕过1.1 案例介绍1.2 实现原理1.3 绕过debugger方法1.3.1 禁用所有断点1.3.2 禁用局部断点1.3.3 替换文件1.3.4 函数置空与hook 二、补充2.1 改写JavaScript文件2.2 浏览器开发者工具中出现的VM开头的JS文件是什么？ 三、实战 一、无限debugger的原理与绕过 debugger 是 JavaScript 中定义的一个专门用于断点调试的关键字，只要遇到它，JavaScript 的执行便会在此处中断，进入调试模式。有了 debugger 这个关键字，我们就可以非常方便地对 JavaScript 代码进行调试，比如使用 JavaScript Hook 时，我们可以加入 debugger 关键字，使其在关键的位置停下来，以便查找逆向突破口。但有时候 debugger 会被网站开发者利用，使其成为阻挠我们正常调试的拦路虎。本节中，我们介绍一个案例来绕过无限 debugger。
1.1 案例介绍 案例介绍：我们先看一个案例，网址是 http://shanzhi.spbeen.com/，打开这个网站，一般操作和之前的网站没有什么不同。但是，一旦我们打开开发者工具，就发现它立即进入了断点模式，如下图所示：
我们既没有设置任何断点，也没有执行任何额外的脚本，它就直接进入了断点模式。这时候我们可以点击 Resume script execution(恢复脚本执行)按钮，尝试跳过这个断点继续执行，如下图所示：
然而不管我们点击多少次按钮，它仍然一次次地进入断点模式，无限循环下去，我们称这样的情况为无限 debugger。怎么办呢？似乎无法正常添加断点调试了，有什么解决办法吗? 办法当然是有的，本节中我们就来总结一下无限 debugger 的应对方案，在后面部分实战的案例中我们也会遇到无限 debugger。
1.2 实现原理 首先要做的是找到无限 debugger 的源头，上面的案例通过堆栈回溯，查看 debugger 是如何生成的，如下图所示：
继续往上进行追溯，如下图所示：
这时点击左下角的格式化按钮：
setInterval(()=&gt;{ (function(a) { return (function(a) { return (Function('Function(arguments[0]+"' + a + '")()')) } )(a) } )('bugger')('de', 0, 0, (0, 0)); } , 1000); 利用 Function 产生 debugger，然后通过 setInterval 循环，每秒执行1次产生 debugger 语句的操作。当然，还有很多类似的实现，比如无限 for 循环、无限 while 循环、无限递归调用等，它们都可以实现这样的效果，原理大同小异。ps：从某种意义上来说，无限 debugger 不会真正的死循环(只不过这个执行次数多到我们本身靠手点难以接受罢了)，而是有规律得执行逻辑，一般用定时器。 无限 debugger 产生小结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73cf087ead87fdcb694a07103b57fcd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3d546287bf8ea39bfbe4bc4acea994/" rel="bookmark">
			【数据结构-二叉搜索树的增删查改】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：努力学编程’
⛅个人推荐：基于java提供的ArrayList实现的扑克牌游戏 |C贪吃蛇详解
⚡学好数据结构，刷题刻不容缓：点击一起刷题
🌙心灵鸡汤：总有人要赢，为什么不能是我呢
🌈二叉搜索树 二叉搜索树又称二叉排序树，从节点的个数上又可分为两种，空树或者具有一定性质的树，这种具有特殊性质的树具有特点：
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树 根节点27的左子树的所有的节点的值都小于27，右子树的所有节点的值都大于27，这也是为什么我们叫他二叉排序树的原因。当然他的每个子树也都满足这个性质。
⚡⚡⚡特别说明：当我们使用中序遍历搜索二叉树的时候，遍历所得的数组是一个有序数组。
🌈二叉搜索树-查找 如何在二叉搜索树中查找数值呢，他和普通二叉树有区别吗？
当然我们在查找索索二叉树数值的时候，我们理应利用它结构上的特点进行查找：节点为空： 返回fasle；节点不为空：Key&gt;root.val 在根节点的右侧进行查找节点不为空： Key&lt;root.val 在根节点的左侧进行查找 🌈二叉搜索树-插入 在二叉搜索树当中，插入数据分为两步：找到要插入数据的位置，插入数据。
如何找到插入数据的位置是最重要的一步，其实这步和查找有一定的相似度。我们将带插入数据与当前的根节点进行比较，根据大小关系，在树的左右子树进行查找。
直到找到我们需要插入点的位置，但是只要你实际操作这个过程就会发现我们无法直接定位到需要插入数据的位置，只能定位到带插入位置的下个一位置，所以我们需要创建一个指针定位到插入数据指针的上一个位置，这样就找到了待插入的位置.
若节点为空，直接插入节点！！！
使用parent标记带插入的位置，直接进行插入：
🌈二叉搜索树-删除 对于删除操作，比较麻烦，需要分不同的几种情况进行讨论，待删除的节点cur，待删除的数据的父节点parent：
cur.left == null:
cur 是 root: 则 root = cur.right
cur 不是 root，cur 是 parent.left: 则 parent.left = cur.right
cur 不是 root，cur 是 parent.right 则 parent.left = cur.left
cur.right==null:
cur是root： 则 则 root = cur.left
cur 不是 root，cur 是 parent.left，则 parent.left = cur.left
cur 不是 root，cur 是 parent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c3d546287bf8ea39bfbe4bc4acea994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de755189ffa7b667df00cbe8bc37f50/" rel="bookmark">
			在没有推出硬盘的情况下，重启mac电脑，外接移动硬盘无法加载显示？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mac磁盘工具显示未装载
1.打开终端，输入
diskutil list 查看当前硬盘列表，大多数时候，可以解决。
二、使用命令行装载硬盘
执行上面命令后，仍不起作用，则手动挂载，在命令行输入如下内容：
sudo diskutil mount /dev/disk6 装载该硬盘。
参考链接：https://www.ntfsformac.cc/faq/tntfs-giokj.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d49ff281a5a4f7590a9772295235b41/" rel="bookmark">
			python连接chatgpt3.5 api 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、获取API
官网获取：
直接购买：
2、连接外网
3、编译程序前的准备
python版本：
创建虚拟环境：
pycharm
vscode：
4、测试代码
1、获取API 我所知道的获取api的方法有两种，一种是官网获取，另一种是直接联系人购买。
官网获取： 网址：https://platform.openai.com/
需要注册chatgpt的账号，需要一个美国的虚拟手机号接收验证码，还需要充值5美元的额度。相对而言比较复杂。
直接购买： 可以直接找人买一个api，我通过这种途径购买的，因为是学习使用，用大概2.3个月，买的话大概是35元1个月
2、连接外网 也就是需要购买机场，连接到clash，自行研究吧，clash官网有
3、编译程序前的准备 python版本： 使用的是3.10.11，在这之前的版本，可能会有点问题
创建虚拟环境： 因为会用到openai的包，所有还是创建虚拟环境比较好，避免在全局中出现冲突。以下介绍两种工具：pycharm和vscode
pycharm 直接创建项目就可以了，这就是一个虚拟环境
vscode： 导入python扩展：实际上只需要导入python这一个就可以了，其他的是附带的
新建项目之后，创建虚拟环境：
点击右下角：3.10.11 64-bit
依据提示，创建虚拟环境即可：
创建完成后，项目中会出现一个.venv的文件夹，这个里面存放的就是虚拟环境目录
创建test.py文件，运行一下
pip导入openai包：
pip install openai -i https://mirrors.aliyun.com/pypi/simple/
等待结束，初步配置完成
4、测试代码 import openai import os openai.api_key = "" os.environ["HTTP_PROXY"] = "http://localhost:7890" os.environ["HTTPS_PROXY"] = "http://localhost:7890" response = openai.chat.completions.create( model="gpt-3.5-turbo", messages=[ { "role": "user", "content": "你好，秦朝" } ] ) print(response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d49ff281a5a4f7590a9772295235b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e143312923b66f700ac7059ff3efdeed/" rel="bookmark">
			mac系统 安装使用adb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装adb 1.创建.bash_profile文件
touch .bash_profile 2.打开.bash_profile文件
open -e .bash_profile 3.在.bash_profile文件添加SDK路径
SDK路径查看 Tools -&gt; SDK Manager)
export ANDROID_HOME=/Users/djl/Library/Android/sdk export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools 4.执行命令
source .bash_profile 5.验证是否安装成功
adb version djl@djldeMacBook-Pro ~ % adb version Android Debug Bridge version 1.0.41 Version 30.0.4-6686687 Installed as /Users/djl/Library/Android/sdk/platform-tools/adb 二、使用基本命令(abc.apk为事例，abc修改为你的项目包名)
1、安装apk
adb install abc.apk 2、卸载apk
adb uninstall abc.apk 3、覆盖安装
abd install -r abc.apk 4、卸载且想保留数据
abd uninstall -k abc.apk 三、解决Mac 每次都要执行source ~/.bash_profile环境变量才生效
Mac 每次都要执行source ~/.bash_profile环境变量才生效
在 ~/.bash_profile中配置环境变量, 可是每次重启终端后配置的不生效，需要重新执行source ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e143312923b66f700ac7059ff3efdeed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838ce22da2fd2537dba59a0b950e1474/" rel="bookmark">
			【C&#43;&#43;】string类的使用②（容量接口Capacity || 元素获取Element access）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页： Forcible Bug Maker
🔥专栏： STL || C++
目录 前言🔥容量接口（Capacity）==size和length====capacity====max_size====reserve====resize====clear====empty====shrink_to_fit== 🔥元素获取（Element access）==operator[ ]====at====back和front== 结语 前言 本篇博客主要内容：STL库中string的容量接口（Capacity）和四种元素获取方式（Element access）的介绍和使用。
来到string类的使用第二篇，让我们接着上一篇来讲。
🔥容量接口（Capacity） size和length size_t size() const;
size_t length() const;
将这两个函数接口的功能完全相同，它们没有参数传递，只有一个返回值（且这个返回值是const类型，不能被改变），返回：string对象中串的长度。
使用样例：
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string str("Test string"); // string::size cout &lt;&lt; "字符串长度为" &lt;&lt; str.size() &lt;&lt; endl; // string::length cout &lt;&lt; "字符串长度为" &lt;&lt; str.length() &lt;&lt; endl; return 0; } 至于为什么设计了两个功能相同的函数，这就牵扯到STL的发展史了。string是STL库中最早被实现的内容之一，当时获取字符串长度的时候只有length，并没有size。但随着STL的发展，陆续出现了vector，list，stack，queue这样的容器，在获取他们的元素个数时，使用的接口函数名用length（长度）似乎不太合适，于是选用了size（大小），string为了和别的容器保持一致，不得已也给自己加了一个size上去。
capacity size_t capacity() const;
返回值：当前string对象中给串分配的字节数。
这个分配的容量不一定和string的长度（length）相等，它可以等于或大于length的大小，它额外的空间可以优化对象往串中增加字符时的操作。如果string的容量（capacity）和串的长度（length）相等的话，那么当你向string对象的串中增加字符时，会导致每次的增加操作都会重新让存储串的空间扩一次容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/838ce22da2fd2537dba59a0b950e1474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224144564a320b65cf0e13c981f58f4c/" rel="bookmark">
			【GitHub项目推荐--AI修图/绘图工具】【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lama-Cleaner Lama-Cleaner 是一款基于 SOTA AI 模型的图像修复工具，它能够帮助您轻松地从照片中删除不需要的物体、缺陷、人物等，实现高质量的图像修复
github地址：
https://github.com/Sanster/lama-cleaner
国内源代码：
http://www.gitpp.com/pythonking/lama-cleaner
Lama-Cleaner的介绍
Lama-Cleaner 是一款基于 SOTA AI 模型的图像修复工具，它能够帮助您轻松地从照片中删除不需要的物体、缺陷、人物等，实现高质量的图像修复。其核心功能是通过稳定扩散驱动技术擦除并替换照片上的任何内容。
以下是使用 Lama-Cleaner 进行图像修复的基本步骤：
1. 准备照片：首先，选择一张包含需要删除物体的照片。
2. 下载并安装 Lama-Cleaner：根据您的操作系统（如 Windows、macOS 或 Linux）下载相应的安装包，并按照安装向导进行操作。
3. 运行 Lama-Cleaner：打开命令行或终端，运行以下命令以启动 Lama-Cleaner：
```
lama-cleaner --modellama --devicecpu --port8080
```
4. 访问 Web 界面：在浏览器中输入 `http://localhost:8080`，访问 Lama-Cleaner 的 Web 界面。
5. 选择模型：在 Web 界面中，选择适用于您的图像修复任务的模型。Lama-Cleaner 提供了多种模型，如基础模型、夜间模式等。
6. 预览和调整：在预览区域查看图像修复效果，根据需要调整参数，如强度、模糊度等。
7. 应用修复：满意预览效果后，点击“应用”按钮，Lama-Cleaner 将开始处理照片。处理完成后，您将获得一个修复后的照片文件。
8. 导出结果：在 Lama-Cleaner 的 Web 界面中，您可以将修复后的照片导出为常见的图像格式（如 JPEG、PNG 等）。
通过以上步骤，您可以使用 Lama-Cleaner 擦除照片中的不需要的物体、缺陷、人物等，得到干净整洁的图像。需要注意的是，Lama-Cleaner 可能无法处理所有类型的图像修复任务，对于复杂的情况，您可能需要尝试多次或使用其他图像处理软件。祝您使用愉快！
lama模型介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/224144564a320b65cf0e13c981f58f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb8a9ad48d0d09b87c5fb03e7ab3b30/" rel="bookmark">
			【CTF-Crypto工具】Ciphey安装教程（Window&#43;Kali存在多版本python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嘿，这里是目录！ 0. 前言1. window10环境安装ciphey【简单一点】1.1 检查环境1.2 我的环境1.3 安装[^2][^3]1.4 头铁的报错 2. vmware虚拟机，kali2024.1（自带python2.7和python3.11）【复杂亿些】2.1 检查环境2.2 我的环境2.3 环境改造2.4 忽略了未生效的命令之后，后续报错解决（参考文章的所有步骤都已走完）2.4.1 sudo apt-get install build-essential libssl-dev libffi-dev python-dev2.4.2 sudo apt-get install -y python3-pip 2.5 安装[^2] 0. 前言 安装了多半天，累死简直，网上说这个的相对不大详细，总结一下经验，反正就疯狂报错，最后能用了安装环境1：windows10 + python3.8.5【简单一点】安装环境2：vmware虚拟机，kali2024.1（自带python2.7和python3.11）【复杂亿些】Ciphey官方安装教程，写的挺简单的 核心要点1：python3.7+以上的版本才可以使用，python3.8也行，但是windows下python3.9+不可以，其他平台python3.10+不可以核心要点2：windows环境下python默认安装32位，但是使用ciphey需要安装在python是64位的环境 1. window10环境安装ciphey【简单一点】 1.1 检查环境 检查python是不是3.7或者3.8版本的？不是用不了 cmd中敲（不用进管理员模式），查看是否符合 python --version 检查python是否是64位的版本1？不是用不了 cmd中敲（不用进管理员模式），查看是否符合 python import platform platform.architecture() 如果两者都满足，恭喜你具备安装条件了，开始安装 1.2 我的环境 windows10 + python3.8.5 1.3 安装23 cmd中敲（不用进管理员模式） pip install ciphey -i https://pypi.mirrors.ustc.edu.cn/simple/ 编辑这个python文件 ..\python安装的路径\Lib\site-packages\pywhat\regex_identifier.py 将文件中的r改成rb import json import os import re class RegexIdentifier: def __init__(self): path = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb8a9ad48d0d09b87c5fb03e7ab3b30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b8fb02073efba9b401a6145cad88e1/" rel="bookmark">
			5个好用的中文AI大语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI大语言模型（Large Language Models, LLMs）是近1-2年来人工智能领域的重要发展，它们通过深度学习技术，特别是基于Transformer的架构（如GPT、BERT等），实现了对自然语言处理的巨大突破。
AI大语言模型的主要功能和作用有：文本生成、创意写作、对话生成、问答系统、文本翻译、代码生成、代码解释、文档生成、辅助写作、辅助设计等。
1.讯飞星火大模型-AI大语言模型-星火大模型-科大讯飞
https://xinghuo.xfyun.cn/
讯飞星火认知大模型是科大讯飞发布的大模型。该模型具有7大核心能力，即文本生成、语言理解、知识问答、逻辑推理、数学能力、代码能力、多模交互，该模型对标ChatGPT
科大讯飞在语音识别、语音合成、自然语言处理等领域有多年技术积累，相信旗下推出的大模型体验应该不差。
2.ChatGPT
https://chatgpt.com/
ChatGPT被誉为AI大模型的始祖，由OpenAI开发并在2022年11月首次对外公布，作为首个现象级AI模型，ChatGPT如今已经迭代到了4.0版本，拥有远超ChatGPT 3.5的处理能力，而且支持插件加载、实时网络连接等多个功能。
ChatGPT服务器不在中国，可能国内直接访问不了。但是作为AI大模型的始祖，也有很强的中文语言能力，而且目前ChatGPT 3.5开放免注册使用，小编这里还是列一下。
再推荐一个ChatGPT国内镜像网址，小编亲测可用。
https://ai4.tuostudy.top/index.php
3.天工AI——能搜、能聊、能写、能画的全能AI助手
https://www.tiangong.cn/
天工AI是由昆仑万维发布的AI搜索产品。天工AI集成了大语言模型技术能力，旨在为用户提供更优质、更高效的搜索体验。
天工AI具有强大的多模态能力，支持图文对话、文生图等多模态应用，并支持最高100K的超长上下文。此外，天工AI还新增了AI绘画、数据分析、AI伴侣、AI算命、热梗百科等多项新兴玩法，让AI更聪明、更实用、更有趣，成为每个人日常生活中的全能AI小助手。
4.通义千问
https://tongyi.aliyun.com/qianwen/
通义千问，是阿里云推出的一个大语言模型， 属于(AI Generated Content，AIGC)领域， 是一个MaaS（模型即服务）的底座。
通义，取自《汉书》中的“天地之常经，古今之通义也”，有“普遍适用的道理与法则”之意。通义千问功能包括多轮对话、文案创作、逻辑推理、多模态理解、多语言支持，能够跟人类进行多轮的交互，也融入了多模态的知识理解，且有文案创作能力，能够续写小说，编写邮件等。
5.文心一言
https://yiyan.baidu.com/
文心一言是百度基于文心大模型技术推出的生成式对话产品。文心一言能够与人对话互动，回答问题，协助创作，高效便捷地帮助人们获取信息、知识和灵感。它能够理解人类的语言和意图，并能够根据人类的需求生成自然、流畅的语言回复。
文心一言的技术基础是百度在人工智能领域多年的积累和投入。百度拥有从数据、算法到平台、应用的全栈AI能力，并构建了全球首个一站式AI大生产平台飞桨。这些技术和平台的支持使得文心一言能够具备强大的生成能力和广泛的应用场景。
实际体验下来，目前文心一言在中文领域，已经不输ChatGPT3.5了。
大模型岗位需求 大模型时代，企业对人才的需求变了，AIGC相关岗位人才难求，薪资持续走高，AI运营薪资平均值约18457元，AI工程师薪资平均值约37336元，大模型算法薪资平均值约39607元。
掌握大模型技术你还能拥有更多可能性：
• 成为一名全栈大模型工程师，包括Prompt，LangChain，LoRA等技术开发、运营、产品等方向全栈工程；
• 能够拥有模型二次训练和微调能力，带领大家完成智能对话、文生图等热门应用；
• 薪资上浮10%-20%，覆盖更多高薪岗位，这是一个高需求、高待遇的热门方向和领域；
• 更优质的项目可以为未来创新创业提供基石。
可能大家都想学习AI大模型技术，也想通过这项技能真正达到升职加薪，就业或是副业的目的，但是不知道该如何开始学习，因为网上的资料太多太杂乱了，如果不能系统的学习就相当于是白学。为了让大家少走弯路，少碰壁，这里我直接把全套AI技术和大模型入门资料、操作变现玩法都打包整理好，希望能够真正帮助到大家。
-END-
👉AI大模型学习路线汇总👈 大模型学习路线图，整体分为7个大的阶段：（全套教程文末领取哈）
第一阶段： 从大模型系统设计入手，讲解大模型的主要方法；
第二阶段： 在通过大模型提示词工程从Prompts角度入手更好发挥模型的作用；
第三阶段： 大模型平台应用开发借助阿里云PAI平台构建电商领域虚拟试衣系统；
第四阶段： 大模型知识库应用开发以LangChain框架为例，构建物流行业咨询智能问答系统；
第五阶段： 大模型微调开发借助以大健康、新零售、新媒体领域构建适合当前领域大模型；
第六阶段： 以SD多模态大模型为主，搭建了文生图小程序案例；
第七阶段： 以大模型平台应用与开发为主，通过星火大模型，文心大模型等成熟大模型构建大模型行业应用。
👉大模型实战案例👈 光学理论是没用的，要学会跟着一起做，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉大模型视频和PDF合集👈 观看零基础学习书籍和视频，看书籍和视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉学会后的收获：👈 • 基于大模型全栈工程实现（前端、后端、产品经理、设计、数据分析等），通过这门课可获得不同能力；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49b8fb02073efba9b401a6145cad88e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e298aaee23e9269ac44327c26dffe669/" rel="bookmark">
			[Flutter] 运行时报错Execution failed for task ‘:connectivity_plus:compileDebugJavaWithJavac‘ 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 系统：Windows
Flutter：3.19.6
connectivity_plus：6.0.3
问题描述 Flutter升级到3.19.6，connectivity_plus库升级到6.0.3后，运行项目时报错Execution failed for task ‘:connectivity_plus:compileDebugJavaWithJavac’，如下图：
可以得知在运行时gradle在编译connectivity_plus库的过程中遇到了一个与编译Java相关的错误。
解决方案 首先猜想可能是该库的版本太高，尝试降版本到5.0.2后，其他库也会报同样的错误，所以降低版本不是一个好的解决方法，没有从根源解决问题。
其次猜测可能是当前flutter版本与jdk版本、gradle版本不匹配，既然报错和java有关，多半是jdk的版本问题，于是接下来根据这两篇文章查看了我自己的android studio版本和jdk版本：
https://juejin.cn/post/7221808657531961401
https://juejin.cn/s/android%20studio%20%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7
第一步，由于发现我的android studio确实比较老了，是22年的版本，于是进行升级，升级到2023.3.1.18，注意安装时保存旧的配置以免影响到项目。
第二步，配置环境变量：JAVA_HOME以及path：
配置好以后，重新打开flutter项目，运行flutter clean，重新flutter pub get，然后运行项目，可以正常运行。
总结 类似库的报错一般都是和 jdk 相关的，在定位问题的时候可以顺着这个方向查，或者询问小G。我升级android studio之后，jdk版本其实还是之前那个旧的，所以实际的原因可能还是我没有配置JAVA_HOME，或者没有在android studio -&gt; File -&gt; Project Structure中选择SDK等，导致gradle执行的时候找不到可用的jdk。
一些经验：
[可以尝试不使用fvm] 升级过好几次flutter，每次升级都不是很顺利，越来越觉得其实fvm管理flutter版本不是特别好用，有时候切换好版本之后，fvm list显示的是正确版本，但是报错又会出现current dart sdk xxx（实际切换的flutter版本对应的dart已经是3.3.4了）：
[记得查看flutter doctor] 跑flutter doctor可以看到本地安装的各个工具的情况，有时候确实可以发现问题，或者起码提供思路。
[force updage 强制更新库] 有时候跟某个package版本相关的报错，实在找不到好的解决方法，可以flutter clean后运行flutter update-packages --force-upgrade，然后再pub get，强制根据pubspec.yaml中配置的版本更新库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c176308e494f1056007b7ffb6913c79/" rel="bookmark">
			【数据结构】详解栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们主要来了解栈！如果对知识点有模糊，可翻阅以往文章哦！
个人主页：小八哥向前冲~-CSDN博客
所属专栏：数据结构【c语言版】_小八哥向前冲~的博客-CSDN博客
c语言专栏：c语言_小八哥向前冲~的博客-CSDN博客
值得注意的是，如果你十分了解顺序表和链表，今天这期会很轻松哦！
哈哈哈哈！当然，这期也能检测你对顺序表和链表的理解！一起看看吧！
目录
栈的定义
顺序表和链表的比较
栈的实现--顺序表
初始化
栈为空的判定
入栈
出栈
销毁
栈顶数据
数据个数
题目操练：配括号问题
栈的实现--链表
栈为空的判定
入栈
出栈
销毁
栈顶数据
数据个数
码源--栈（顺序表）
码源--栈（链表）
栈的定义 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端 称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。出栈：栈的删除操作叫做出栈。出数据也在栈顶。 上图理解一下：
注意：遵循后进先出的原则！
知道了这个原则，我们来巩固一下：
1.一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出 栈的顺序是（ ）。
A .12345ABCDE
B.EDCBA54321
C.ABCDE12345
D.54321EDCBA
2.若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）
A.1,4,3,2
B.2,3,4,1
C.3,1,4,2
D.3,4,2,1
显然：1.B 2.C
相信第一题不难，我们解释一下第二题：看到C选项，1，2，3进栈后，3出栈，而第二次出栈的只能是2或4，不可能是1，所以C错误！
了解了栈的概念，我们实现这个栈是使用顺序表还是链表呢？
如果是顺序表的话，我们的栈顶应该要在数组末尾！如果在数组头部的话，数据进栈时还需要挪动其余数据以便数据的存入！效率很低！如果是链表的话，我们的栈顶要在链表的头，入栈时，头插即可！如果栈顶在链表尾部的话，虽然入栈尾插即可，但需要遍历，效率低，那么这时就需要使用双链表！ 综上所述，我们栈使用顺序表较好！(两种都实现看看)
上图看看它们：
为了更好透彻了解顺序表和链表，我们将它们比较看看！
顺序表和链表的比较 图文更加直观：
这里的缓存利用率不做过多解释，详情见：https://www.cnblogs.com/yungyu16/p/13054874.html
栈的实现--顺序表 既然是要在顺序表基础上实现栈，那么就要实现顺序表和栈的基本框架。
（单链表若有不懂的知识点，可见：通讯录的实现（顺序表版本）-CSDN博客）
stack.h文件--包含各种需要的函数
栈里面的变量：top表示栈顶下标，capacity表示栈空间。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c176308e494f1056007b7ffb6913c79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3490504e8ee02aba2c254ff2669e791/" rel="bookmark">
			A100 解析：为何它成为 AI 大模型时代的首选？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 NVIDIA A100 Tensor Core GPU 可针对 AI、数据分析和 HPC 应用场景，在不同规模下实现出色的加速，有效助力更高性能的弹性数据中心。A100 采用 NVIDIA Ampere 架构，是 NVIDIA 数据中心平台的引擎。A100 的性能比上一代产品提升高达 20 倍，并可划分为七个 GPU 实例，以根据变化的需求进行动态调整。A100 提供 40GB 和 80GB 显存两种版本，A100 80GB 将 GPU 显存增加了一倍，并提供超快速的显存带宽（每秒超过 2 万亿字节 [TB/s]），可处理超大型模型和数据集。
英伟达 A100 显卡凭借其卓越的性能、高效能和广泛的应用场景，成为了数据中心和人工智能计算领域的佼佼者。无论是深度学习、科学计算还是大数据分析等领域，A100 显卡都能够为用户提供出色的计算能力和效率。
派欧算力云（www.paigpu.com）推出的 GPU 测评栏目正在连载中，基于实际生产中的业务场景，为大家带来不同 GPU 的性能测评，我们将专注于为大家带来最前沿、最深入的性能评测和行业动态。在这里，你将能第一时间了解到最新款 GPU 的性能表现。今天我们为大家带来的测评是 NVIDIA A100 Tensor Core GPU。
NVIDIA A100 规格参数 核心架构：Ampere，全球首款基于 7nm 工艺的数据中心 GPU 架构。CUDA 核心数：高达 6912 个，为深度学习等计算密集型任务提供强大的计算能力。Tensor Cores：432 个，支持 Tensor Float 32（TF32）和混合精度（FP16）计算，显著提升深度学习训练和推理的速度。显存：提供 40GB、80GB 和 160GB 的 HBM2e 高速显存选项，内存带宽高达 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3490504e8ee02aba2c254ff2669e791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fecc13642b0a526cffa9d7115d0e3a4/" rel="bookmark">
			Spark SQL Dataframe Doris的输入输出操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要的maven依赖
&lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;scala.binary.version&gt;2.12&lt;/scala.binary.version&gt; &lt;scala.version&gt;2.12.15&lt;/scala.version&gt; &lt;spark.version&gt;3.2.4&lt;/spark.version&gt; &lt;commons.math3.version&gt;3.4.1&lt;/commons.math3.version&gt; &lt;scalacheck.version&gt;1.15.4&lt;/scalacheck.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.doris&lt;/groupId&gt; &lt;artifactId&gt;spark-doris-connector-3.2_2.12&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- spark --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_${scala.binary.version}&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_${scala.binary.version}&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_${scala.binary.version}&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Spark 读取doris数据 val session: SparkSession = SparkSession.builder() .master("local[4]") .appName(getClass.getSimpleName) .enableHiveSupport() .getOrCreate() session.read .format("doris") .option("doris.table.identifier", "doris表名") .option("doris.fenodes", "doris Fe地址") .option("user", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fecc13642b0a526cffa9d7115d0e3a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4046ee8f4fce0aa1c6dcc37401c900/" rel="bookmark">
			谷歌浏览器124版本Webdriver驱动下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看谷歌浏览器版本 在浏览器的地址栏输入：
chrome://version/ 回车后即可查看到对应版本(不要点击帮助-关于Google chrome，因为点击后会自动更新谷歌版本)
114之前版本：下载链接
​​​​​​123以后版本：下载链接，只有后面status是绿色对勾的才可以下载，驱动大版本一致就可以使用，不需版本号一模一样；下载所需版本只需点击对应的版本名称即可跳转到对应版本的下载位置
备注：124版本的谷歌浏览器驱动使用下面这个地址就行
https://storage.googleapis.com/chrome-for-testing-public/123.0.6312.122/win64/chromedriver-win64.zip 或者 https://storage.googleapis.com/chrome-for-testing-public/125.0.6422.4/win64/chromedriver-win64.zip chromedriver使用方法：把chromedriver插件直接解压后放到python的安装目录下就可以了 D:\python3.6
测试chromedriver插件是否可以使用
from selenium import webdriver browser = webdriver.Chrome('D:\python3.6\chromedriver.exe') #或者 browser = webdriver.Chrome() browser.get("https://www.baidu.com/") browser.implicitly_wait(10) browser.maximize_window() browser.set_window_size(300, 500) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175afff460ea473e155f31429355f9b0/" rel="bookmark">
			容器化管理SpringBoot项目：在用jar包制作镜像的时候遇到的错误记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在容器化管理SpringBoot项目，进行到“用jar包制作镜像”一步时，遇到的error真的是一环接着一环，这里就记录一下，一套流程下来遇到的error，以及一些我的解决方法：
ERROR: "docker buildx build" requires exactly 1 argument. See 'docker buildx build --help'. Usage: docker buildx build [OPTIONS] PATH | URL | - Start a build
错误:"docker buildx build"只需要一个参数。
出现情况：运行“docker build -t spring-boot-imgs:0.1.0”命令时报错解决方法：很简单，命令没有完全输完，在输入完上面这一部分后，空格+“.”，然后回车运行就可以解决了。之所以要加“.”,是因为要指明是在当前路径下去创建镜像 http2: server: error reading preface from client //./pipe/docker_engine: file has already been closed
Http2:服务器:从客户端读取序言错误。/pipe/docker_engine:文件已经关闭
——*********——
ERROR: error during connect: this error may indicate that the docker daemon is not running: Get "http://%2F%2F.%2Fpipe%2Fdocker_engine/_ping": open //./pipe/docker_engine: The system cannot find the file specified.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/175afff460ea473e155f31429355f9b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7d3233cf484d0d60014adc6e26855e/" rel="bookmark">
			MongoDB Atlas Vector Search与Amazon Bedrock集成已全面可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亮点前瞻
●MongoDB Atlas Vector Search知识库与Amazon Bedrock的最新集成，将极大加速生成式AI应用的开发。
●诺和诺德利用MongoDB Atlas Vector Search与Amazon Bedrock集成，加速构建AI应用程序。
MongoDB（纳斯达克股票代码：MDB）近日在2024 MongoDB用户大会纽约站大会（MongoDB.local NYC）上宣布，MongoDB Atlas Vector Search与Amazon Bedrock 在知识库上集成现已全面可用，这将助力组织更轻松地利用完全托管的基础模型 (FM) 来构建生成式AI应用程序功能。
作为世界上应用极为广泛的开发者数据平台，MongoDB Atlas能够提供向量数据库功能，使组织能够无缝地使用其实时数据生成AI应用程序。Amazon Bedrock是亚马逊云科技 (AWS) 提供的一项完全托管服务，通过单个API提供来自领先AI公司的高性能基础模型，以及组织构建具有安全性、隐私性和负责任的生成式AI应用程序所需的各项功能。如今，各行各业的客户可以通过集成其专有数据，更加轻松地构建应用程序，并利用生成式AI自主完成复杂任务，并对最终用户的请求做出最新、准确且值得信赖的响应。
MongoDB首席产品官Sahir Azam “从初创公司到大型企业在内的各种规模的客户都开始利用生成式AI来构建激动人心的全新终端用户体验。然而，许多企业都对AI系统输出的准确性以及保障其专有数据的安全性表示担忧。随着MongoDB Atlas Vector Search与Amazon Bedrock集成的全面可用，MongoDB和亚马逊云科技的共同客户将可以更加便捷地使用托管于AWS环境中的各种基础模型来构建生成式AI应用程序。这些应用程序能够安全地运用MongoDB Atlas中的专有数据，在提高准确性的同时，改善终端用户体验。”
MongoDB Atlas Vector Search与Amazon Bedrock的全新集成将帮助组织更加轻松快捷地在AWS上部署生成式AI应用程序，这些应用程序能够利用经MongoDB Atlas Vector Search处理后的数据，做出更准确、更相关、更值得信赖的响应。与仅存储向量数据的附加解决方案不同，MongoDB Atlas Vector Search是一个高性能、可扩展的向量数据库，可驱动生成式AI应用程序的开发；与此同时，MongoDB Atlas Vector Search还可以与MongoDB全局分布式操作数据库集成，存储和处理组织的所有数据。
借助MongoDB Atlas Vector Search与Amazon Bedrock集成，客户可使用自身的实时操作数据对来自AI21 Labs、Amazon、Anthropic、Cohere、Meta、Mistral AI和Stability AI等公司的基础模型 (如大型语言模型，LLM) 进行定制，将这些数据转换为向量嵌入，与LLM一起使用。利用Agents for Amazon Bedrock的检索增强生成 (RAG) 功能，客户可以使用LLM构建应用程序，对用户查询作出具有相关性且符合情境的响应，而无需手动编码。例如，零售组织可以更加轻松地开发一款生成式AI应用程序，自动处理实时库存请求等多种任务，或在客户退货和换货时根据客户反馈自动给出相关库存商品的建议，为客户提供个性化体验。组织还可以借助MongoDB Atlas Search Nodes，在不影响其核心操作数据库的情况下隔离和扩展其生成式AI工作负载，以实现降本增效，查询时间最多可缩短60%。
依托完全托管的各项功能，此次全新集成使AWS和MongoDB的共同客户能够在整个组织范围内安全地使用生成式AI及其专有数据，在降低运营成本和减少人工操作的同时创造更多价值。
点击了解如何在AWS上使用MongoDB Atlas构建应用程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7d3233cf484d0d60014adc6e26855e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35170459f9aadf3d0b3ef57fea2911f/" rel="bookmark">
			FastGPT 调用本地Whisper模型进行语音转文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、部署Whisper模型。
二、oneapi配置
三、修改镜像中的webservice.py文件，开放跨域请求。
四、修改FastGPT代码修改
FastGPT地址:https://github.com/labring/FastGPT fastgpt默认的语音转文字模型使用的openai里面的whisper，由于我没有openai 的token故需要自己部署本地的语音转文字模型，经研究发现可以部署本地的whisper，但是该接口无法接入到oneapi（我目前没研究出来）。故直接修改fastgpt代码直接调用接口获取语音转文字内容。
注：fastgpt的麦克风权限是本地部署的才能用，或者有HTTPS证书的才可以用（麦克风权限比较重要可能涉及隐私，故浏览器对这个要求比较严格）。我目前是本地部署的fastgpt。
一、部署Whisper模型。 我部署的是whisper-asr-webservicehttps://github.com/ahmetoner/whisper-asr-webservice，地址https://github.com/ahmetoner/whisper-asr-webservice。直接docker部署的，运行如下指令
docker run -d -p 9000:9000 -e ASR_MODEL=base onerahmet/openai-whisper-asr-webservice:latest
二、oneapi配置 fastgpt中project\app\data\config.local.json中关于语音模型的配置的模型名称是whisper-1，如下图：
所以在oneapi中配置时模型名称也要写whisper-1。模型名称是一一对应的（早期版的oneapi不支持多个模型，新版本应该是修复这个问题了。我这里还是延续之前我的配置方法习惯，只写一个）
三、修改镜像中的webservice.py文件，开放跨域请求。 也可以直接修改文件再生成镜像继续后面的步骤。我是先部署了容器后，才发现跨域问题。
1、开启容器
2、进入容器 docker exec -ti 容器id /bin/bahs
3、找到要修改的文件并修改，一般容器都没有安装vim\nano等编辑器。故需要将文件复制出来修改后在传上去。
docker cp &lt;container_name_or_id&gt;:/app/app/webservice.py /usr/local/yxq/webservice.py
docker cp &lt;container_name_or_id&gt;:/app/Dockerfile /usr/local/yxq/Dockerfile
修改完后再传上去
docker cp /usr/local/yxq/webservice.py &lt;container_name_or_id&gt;:/app/app/webservice.py docker cp /usr/local/yxq/Dockerfile &lt;container_name_or_id&gt;:/app/Dockerfile
webservice.py修改如下：
增加如下代码：
from fastapi.middleware.cors import CORSMiddleware app.add_middleware( CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"] ) 代码位置如图：
Dockerfile修改如下：RUN $POETRY_VENV/bin/pip install starlette==0.15.0
修改dockerfile镜像后，镜像启动会先将需要的包下载下来。
4、**将修改后的容器保存为新的镜像：** 使用以下命令将修改后的容器保存为新的镜像： `docker commit 容器id &lt;new_image_name&gt;:&lt;tag&gt;`
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35170459f9aadf3d0b3ef57fea2911f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79aabd2a8bd481393e647e27dc2ea1c6/" rel="bookmark">
			AI语言战争再起：阿里巴巴发布通义千问Qwen2.5追平GPT-4 Turbo，中文能力傲视群雄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在人工智能领域的激烈竞争中，阿里巴巴再次展现出其在自然语言处理方面的实力。最新发布的通义千问2.5版本，在多个关键能力上取得了显著提升，特别是在中文能力方面，继续保持了业界的领先地位。
据悉，通义千问2.5在理解能力、逻辑推理、指令遵循和代码能力等方面均实现了不同程度的进步。具体来说，理解能力提升了9%，逻辑推理能力提升了16%，指令遵循能力提升了19%，而代码能力也提升了10%。这些数据的提升，不仅展现了通义千问2.5在算法和模型优化方面的成果，也进一步巩固了其在自然语言处理领域的领先地位。
值得一提的是，通义千问2.5在中文能力方面的持续领先，无疑为其在中文市场的应用提供了有力支撑。随着中文互联网用户的不断增长，对于高效、准确的中文自然语言处理能力的需求也日益增加。通义千问2.5在这方面的突破，将有助于更好地满足用户需求，推动人工智能在中文领域的应用和发展。
在基准测试OpenCompass的测评中，通义千问2.5更是取得了令人瞩目的成绩。其得分追平了GPT-4 Turbo，这一结果无疑是对通义千问2.5技术实力的高度认可。同时，这也进一步证明了阿里巴巴在自然语言处理领域的研发能力和技术实力。
此外，阿里巴巴还发布了1100亿参数的开源模型Qwen1.5-110B，该模型在性能上超越了Meta的Llama-3-70B。这一成果的取得，不仅展现了阿里巴巴在人工智能领域的创新能力，也为整个行业树立了新的标杆。
综上所述，通义千问2.5的发布标志着阿里巴巴在自然语言处理领域又迈出了坚实的一步。其在理解能力、逻辑推理、指令遵循和代码能力等方面的显著提升，以及中文能力的持续领先，都将为其在人工智能领域的应用和发展提供有力支撑。未来，我们期待看到通义千问在更多领域展现出其强大的实力和价值。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/373/">«</a>
	<span class="pagination__item pagination__item--current">374/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/375/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>