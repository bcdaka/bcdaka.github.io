<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729b69cffbee856b7fcbd84990a2c73b/" rel="bookmark">
			【Python GUI库】六个图形用户界面库优缺点及实例预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，有很多库可以帮助创建图形用户界面(GUI)。以下是一些流行的选择：
一、 Tkinter Python的标准库之一，用于创建窗口、按钮、滑动条和其他常见的GUI元素。对于简单的应用程序，Tkinter可能就足够了。
Tkinter的优点：
1.Tkinter是Python的标准GUI库，易于学习和使用，提供了基本的GUI组件和布局管理器，可以快速开发小型GUI应用程序。同时支持多平台，可以在Windows、Mac和Linux上使用。
Tkinter的缺点：
1.Tkinter的图形界面相对较旧，可能不如一些其他库那么现代和吸引人。另外，它的功能相对较少，无法支持一些复杂图形效果。
使用场景：适合开发小型到中型的图形用户界面，例如桌面应用程序、游戏等。由于其简单易用的特点，特别适合初学者入门学习GUI编程。
示例：
# 这个示例程序创建了一个简单的窗口，并在窗口中添加了一个标签，显示“Hello, World!” # 导入Tkinter模块 import tkinter as tk # 创建一个主窗口 root = tk.Tk() # 设置窗口标题 root.title("Hello, Tkinter!") # 创建一个标签，并设置其文本内容为"Hello, World!" label = tk.Label(root, text="Hello, World!") # 将标签添加到窗口中 label.pack() # 运行主循环，等待用户交互 root.mainloop() 二、PyQt 或 PySide 这两个库都是Qt库的Python绑定。Qt是一种创建跨平台应用程序的工具，PyQt和PySide让你可以用Python语言编写Qt应用程序。它们比Tkinter更强大，但也更复杂一些。
PyQt的优点：
1. 功能强大：PyQt库封装了Qt库的所有功能，可以创建复杂的GUI应用程序。这意味着你可以使用它来创建具有各种控件、布局、事件处理等复杂界面。
2. 良好的跨平台性：PyQt可以在所有主流操作系统（如Windows、Mac和Linux）上运行。
3. 可视化工具支持：PyQt支持Qt Designer，这是一个可视化工具，可以方便地设计和构建GUI。这意味着你可以通过拖拽控件、设置属性等方式快速构建GUI。
PyQt的缺点：
1. 学习曲线陡峭：相比Tkinter等其他GUI库，PyQt的学习曲线更为陡峭。你需要花费更多的时间和精力来学习其API和概念。
2. 安装稍显复杂：你需要先安装Qt库和相关的Python工具包才能使用PyQt，这相比其他一些GUI库的安装可能会稍显复杂。
使用场景：适合开发大型、复杂的图形用户界面，例如桌面应用程序、数据可视化等。对于有大量图形组件和交互需求的应用程序特别有用。对于希望使用C++进行开发的开发者来说，PyQt也是一个很好的选择，因为PyQt是Python绑定Qt库的桥梁，可以通过Python进行开发然后转化为C++代码。
示例：
from PyQt5.QtWidgets import QApplication, QLabel import sys # 创建一个应用实例 app = QApplication(sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/729b69cffbee856b7fcbd84990a2c73b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b752180ba07c17ef7932444fc1b67e/" rel="bookmark">
			Android HID设备（键盘、遥控等）功能实现流程及键值映射关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HID（Human Interface Device，人机接口设备）是USB设备中常用的设备类型，是直接与人交互的USB设备，例如键盘、遥控器、鼠标与游戏杆等。在USB设备中，HID设备的成本较低。
之前文章 android 键盘（遥控）键值定义大全 中整理了android中各种功能键值定义，那么从键盘按键到安卓设备控制生效的流程是怎样的呢？
Android 设备上的键盘操作实现流程：
EventHub 从 evdev 驱动程序中读取原始事件，并使用键盘的按键布局映射将 Linux 按键代码（有时也称扫描代码）映射到 Android 按键代码中。
InputReader 将消费原始事件，并更新元键状态。例如，如果您按下或释放左 Shift 键，该读取器就会相应地设置或重置 META_SHIFT_LEFT_ON 和 META_SHIFT_ON 位。
InputReader 会向 InputDispatcher 发送按键事件的相关通知。
InputDispatcher 通过调用 WindowManagerPolicy.interceptKeyBeforeQueueing 询问 WindowManagerPolicy 如何处理按键事件。该方法（负责在按下某些按键时唤醒设备）属于关键路径的一部分。实际上，EventHub 会在此关键路径上一直持有唤醒锁，从而确保它运行至结束。
如果目前正在使用 InputFilter，那么 InputDispatcher 将给予它机会消费或转换按键。InputFilter 可用于实现低级别的全系统可访问性政策。
InputDispatcher 可将按键排入队列，以便在分配线程上对其进行处理。
当 InputDispatcher 将按键移出队列时，它会通过调用 WindowManagerPolicy.interceptKeyBeforeDispatching 使 WindowManagerPolicy 再次有机会拦截按键事件。此方法可用于处理系统快捷方式和其他功能。
随后，InputDispatcher 会识别按键事件目标（获得焦点的窗口），并等待按键事件目标就绪。接下来，InputDispatcher 会将按键事件发送到应用。
在应用内，按键事件会沿着视图层次结构向下传送到获得焦点的视图，以进行 IME 按键预分配。
如果按键事件未在 IME 按键预分配阶段进行处理，而某个 IME 正在使用中，那么按键事件会被发送到 IME。
如果 IME 未消费按键事件，那么按键事件会沿着视图层次结构向下传送到获得焦点的视图，从而进行标准按键分配。
应用反过来向 InputDispatcher 报告有关按键事件是否被使用的情况。如果事件未被使用，InputDispatcher 会调用 WindowManagerPolicy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b752180ba07c17ef7932444fc1b67e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4fc5205ee6a7bf6c239864cb646ede1/" rel="bookmark">
			SQL Server 跨库/服务器查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1 SQL Server 跨库/服务器查询1.1 跨库查询1.2 跨服务器查询1.2.1 创建链接服务器1.2.2 跨库查询 1.3 拓展：SQL Server 中所有权和用户与架构的分离 1 SQL Server 跨库/服务器查询 1.1 跨库查询 在同一服务器下的跨库查询较为简单，示例
Database.DatabaseSchema.DatabaseObject # 示例 [SqlMatc] 数据库中，查询数据库[SQLATM]里的 DeptSales_copy 表里的所有数据 select * from [SQLATM].[dbo].[DeptSales_copy] 1.2 跨服务器查询 进行跨服务器查询前提是在本地服务器上创建链接服务器。
1.2.1 创建链接服务器 方法一：利用系统存储过程 sp_addlinkedserver
sp_addlinkedserver
创建链接服务器。 链接服务器提供对 OLE DB 数据源的分布式异类查询的访问权限。 使用 sp_addlinkedserver创建链接服务器后，可对此服务器运行分布式查询。 如果将链接服务器定义为 SQL Server 实例，则可以执行远程存储过程。
权限
语句 sp_addlinkedserver 需要 ALTER ANY LINKED SERVER 权限。 (“SQL Server Management Studio新建链接服务器”对话框的实现方式需要固定服务器角色的成员sysadmin身份。)
参数解读
sp_addlinkedserver [ @server = ] 'server' -- 链接服务器的名称 [ , [ @srvproduct = ] 'product_name' ] -- 链接服务器的 OLE DB 数据源的产品名 -- product_name值为 nvarchar (128) ， -- 默认值为 NULL。 -- 如果值为SQL Server，则无需指provider_name、 -- data_source、位置、provider_string和目录。 [ , [ @provider = ] 'provider_name' ] -- 唯一编程标识符。建议使用 MSOLEDBSQL 而不是 SQLNCLI。 [ , [ @datasrc = ] 'data_source' ] -- 目的服务器地址 [ , [ @location = ] 'location' ] -- 本地登录 [ , [ @provstr = ] 'provider_string' ] -- 标识唯一数据源的特定于 OLE DB 提供程序的连接字符串。 [ , [ @catalog = ] 'catalog' ] -- 与 OLE DB 提供程序建立连接时要使用的目录。 链接示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4fc5205ee6a7bf6c239864cb646ede1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff91cad7558cf30bcde0f87aab117256/" rel="bookmark">
			浅析目标检测入门算法：YOLOv1,SSD,YOLOv2,YOLOv3,CenterNet,EfficientDet,YOLOv4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文致力于让读者对以下这些模型的创新点和设计思想有一个大体的认识，从而知晓YOLOv1到YOLOv4的发展源流和历史演进，进而对目标检测技术有更为宏观和深入的认知。本文讲解的模型包括：YOLOv1,SSD,YOLOv2,YOLOv3,CenterNet,EfficientDet,YOLOv4。
R-CNN 候选区域
SPP-Net 和R-CNN最大区别是什么？
先提取特征，再对候选区域做处理？
Fast R-CNN: 并行选择性搜索算法和ConvNet提取特征
将SPPNet中的金字塔池化替换为RoI池化层
Faster R-CNN 每个候选框一个分数，就不用手工设计算法来筛选候选框了，用CNN进行候选区域的提取
二阶段目标检测算法 将目标检测作为一个 分类问题 来解决，（S1）一个模块提出一些候选框，（S2）后续的网络将其分类为目标或背景
YOLO将 目标检测问题 重构成一个 回归问题 ，直接将图片中的每个像素分类为 （1）目标、（2）边界框、 （3）不是目标（也就是背景） 这三种类型
单阶段目标检测算法 YOLOv1 YOLOv1的设计灵感来自于GoogLeNet模型，使用较小的卷积网络的级联模块。使用的具体细节是，使用GoogLeNet在ImageNet上预训练过、精度已经很高的预训练模型。在此基础上，添加随机初始化的卷积层和全连接层进行微调fine-tuning
YOLOv1在准确性和速度都远远超过当时的两阶段实时目标检测模型，但是小目标检测和密集目标检测效果不好
SSD 基于VGG-16来构建的
模型浅层的SSD（特征图的size比较大，小目标的信息被保留的比较完整）用来检测较小的目标。较深的层用来 检测较大的物体
在训练期间，SSD将每个GT框（ground truth）与具有最佳IoU的默认框匹配,（ 【我猜】truth的答案标签 框 和你模型预测的 框 相匹配），并相应的训练网络，类似Muti-Box。（啥是Multi-box?）
SSD作者还使用了困难负样本挖掘和（啥是困难负样本挖掘？）大量数据增强方法
损失函数：与DPM（啥是DPM?）类似，SSD利用 定位损失 和 置信度损失 的 加权和，作为总的损失值来训练监督模型
并通过执行菲最大抑制NMS（什么是是非最大抑制，有什么用？）获得最终输出 SSD在检测小目标方面也存在困难。这个问题可以通过使用更好的backbone网络（如ResNet）来解决
YOLOv2 相比YOLOv1，YOLOv2提供了速度和准确性之间良好的平衡
YOLOv2，是YOLO系列中，首次使用了DarkNet-19作为backbone的。，
使用了BatchNormalization以提高收敛性
分类和检测系统的联合训练以增加检测类别（意思是：分类 和 打bouding box 这两个任务一起训练， 然后类别就多了？ 啥叫检测类别？ 识别是人，是车，是摩托？这和前面的联合训练有什么关系）
移除Fully connected层以提高速度（参数量小了，计算量小了，速度自然块 ）
使用学习的anchor框（是可学习的anchor框吧？）来提高召回率recall并获得更好的先验（啥叫先验？事先就知道这些框有可能是真实的框？）
recall=TP/(TP+FN)。实际为正的样本里，预测正确的样本的比例。所有的罪犯里，有多少罪犯被你抓住了。
precision=TP/(TP+FP)。在你预测为正的样本集合里，多大比例是被正确预测的。所有你认为是犯人，被抓进Police局里人里，多少人真的是犯人
YOLOv2的作者Redmon等人，使用WordNet将分类和检测数据集，组合在层次结构中。此WordTree可以用于预测更高的上位词条件概率，从而提高系统的整体性能。（啥意思啊？不知所云！）
YOLOv3 YOLOv3是在YOLOv2基础上做增量改进，整个范式上没有太大的改进了。YOLOv3相比YOLOv2只是速度上更快了，但是上从技术上是没有突破的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff91cad7558cf30bcde0f87aab117256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e734edc2ff2cfa2e39436e38758506d/" rel="bookmark">
			Qt实现图书管理系统(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据库表的实现创建表将powerDesigner里面的表导出成xxx.sql脚本将SQL文件导入数据库创建表 图书管理系统思维导图创建工程开发阶段创建Dlg_login登录页面login页面样式主页页面布局主函数测试login设置logo打包程序子页面的样子将子页面放到StackedWidget里面按钮直接形成互斥效果 用属性选择器来改变样式设置user页面的标头和设置文本不可编辑 创建SqlMgr类进行SQL操作初始化数据库 登录功能login用户功能getUsers功能导入用户（导入文件里面的数据到数据库）删除用户（del）搜索用户 图书管理功能获取图书添加图书修改图书删除图书遇到的错误 借阅图书搜索图书 借阅记录管理功能获取借阅记录模糊查询记录归还图书出现的问题 清空借阅记录登录功能页面展示 数据库表的实现 创建表 创建三个表
将powerDesigner里面的表导出成xxx.sql脚本 此时就会生成文件在桌面了
将SQL文件导入数据库创建表 运行sql文件
设置主键自增
图书管理系统思维导图 创建工程 在qt上创建一个工程项目
把这个四个文件发到controller文件夹下，在创建一个dao文件夹
controller文件夹下面是一些界面类和逻辑类，dao文件夹下就是和数据库交互的
进入项目
加上这一句话
include($$PWD/controller/controller.pri)
正在右键项目执行qmake
添加一句这个以后生成的目标文件都在这里（当前文件目录的上一级创建一个bin 文件夹
开发阶段 创建Dlg_login登录页面 login页面样式 QLabel#le_title{font:38px '方正姚体';} QLabel#name,QLabel#pwd{font: 18px '楷体';} QLineEdit{border-radius:4px;min-height:25px;border:1px solid gray;} QPushButton{border-radius:4px;background-color:#409eff;color:white;font-size:18px;} QWidget#bg{background:white;} 主页页面布局 主函数测试login int main(int argc, char *argv[]) { QApplication a(argc, argv); //实现登录 Dlg_login dlg; int ret=dlg.exec(); if(1==ret){ Cell_main w; w.show(); return a.exec(); } if(0==ret){ exit(0); return 0; } return 0; } 实现Dlg_login函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e734edc2ff2cfa2e39436e38758506d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7317b9240dc4aebe13bcfd6dd58035be/" rel="bookmark">
			瑞芯微RK3568/RK3588平台YOLOV5实时视频算法的部署小白教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		瑞芯微平台YOLOV5算法的部署 本文实现整体的部署流程比较小白，首先在PC上分别实现工程中的模型仿真推理、yolov5-pytorch仿真推理、自己训练yolov5模型仿真推理，完成仿真之后再在板端分别实现rk提供模型的板端推理、yolov5-pytorch板端推理、自己训练的yolov5模型板端推理，最后实现自己训练的yolov5模型实时视频算法部署，整个过程从仿真到板端，从图片到视频，过程较为繁琐，各位大佬们可以根据自己的情况选择跳过某些章节。接下来我们就一块开始部署之旅吧！
一. 部署概述 环境：Ubuntu20.04、python3.8
芯片：RK3568
芯片系统：buildroot
开发板：RP-RK3568-B
依赖：Qt + opencv + rknn + rga实现视频流采集缩放识别到输出显示，支持USB摄像头、mipi摄像头等，输出支持mipi、hdmi
开发主要参考文档：《Rockchip_Quick_Start_RKNN_Toolkit2_CN-1.4.0.pdf》、《Rockchip_User_Guide_RKNN_Toolkit2_CN-1.4.0.pdf》
二.yolov5模型训练 训练过程网上的博客已经非常完善，不过要注意一下下面提到的yolov5版本，简单记录一下步骤。
2.1创建conda环境 PC机：win10
CUDA：11.7
# 创建conda环境 conda create -n rkyolov5 python=3.8 # 激活conda环境 conda activate rkyolov5 # 删除所有镜像源 conda config --remove-key channels # 安装pytoch conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia 安装pytorch到官网下载对应的CUDA版本。
2.2训练yolov5 对应版本的yolov5链接：https://github.com/ultralytics/yolov5/tree/c5360f6e7009eb4d05f14d1cc9dae0963e949213
此版本为v5.0，相应的权重文件可对应从官网下载；
将yolov5的激活函数由silu改为relu，会损失精度但能带来性能的提升。
以下QA记录训练时的报错信息。
Q：UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7317b9240dc4aebe13bcfd6dd58035be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e569b3a146e7c4ee69b1b8605eac12ed/" rel="bookmark">
			数据结构：栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、栈1.栈的概念及结构1.栈的概念及结构2.栈的实现 2.栈的顺序表实现1.栈的结构体和实现的功能函数2.栈的初始化，入栈和出栈操作3.栈的其他操作 3.栈的链表实现1.栈的结构体和实现的功能函数2.栈功能函数的实现 二、队列1.队列的概念及结构1.队列的概念及结构2.队列的实现 2.队列的顺序表实现（循环队列）1.循环队列分析2.循环队列的结构体和实现的功能函数2.循环队列初始化和插入2.循环队列的其他操作 3.队列的链表实现1.队列的结构体和实现的功能函数2.队列功能函数的实现 二、栈和队列应用实列：实现简单计算器1.问题分析1.代码实现 总结 一、栈 1.栈的概念及结构 1.栈的概念及结构 栈是一种特殊的线性表，只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端其称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出的原则。
2.栈的实现 栈的实现一般可以使用数组或者链表实现
栈的数组实现：
栈的链表实现：
对比两种方式的插入和删除：数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。
2.栈的顺序表实现 1.栈的结构体和实现的功能函数 typedef int STDataType; typedef struct Stack { STDataType* data; int top;	// 栈顶 int capacity; // 容量 }Stack; void StackInit(Stack* ps);// 初始化栈 void StackPush(Stack* ps, STDataType data);// 入栈 void StackPop(Stack* ps);// 出栈 STDataType StackTop(Stack* ps);// 获取栈顶元素 int StackSize(Stack* ps);// 获取栈中有效元素个数 bool StackEmpty(Stack* ps);// 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 void StackDestroy(Stack* ps);// 销毁栈 这里我们使用动态开辟的结构，保证栈的空间足够。数组实现我们需要一个变量来保存栈顶元素。栈顶元素也是我们栈中有效元素的个数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e569b3a146e7c4ee69b1b8605eac12ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b60b291ddbd78691318abf3b4d627e/" rel="bookmark">
			Stable Diffuse AI 绘画 之 ControlNet 插件及其对应模型的下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffuse AI 绘画 之 ControlNet 插件及其对应模型的下载安装 目录
Stable Diffuse AI 绘画 之 ControlNet 插件及其对应模型的下载安装
一、简单介绍
二、ControlNet 插件下载安装
三、ControlNet 插件模型下载安装
四、ControlNet 插件其他的下载安装方式
五、ControlNet 插件模型名称说明
一、简单介绍 Stable Diffusion是一个文本到图像的潜在扩散模型，由CompVis、Stability AI和LAION的研究人员和工程师创建。它使用来自LAION-5B数据库子集的512x512图像进行训练。使用这个模型，可以生成包括人脸在内的任何图像，因为有开源的预训练模型，所以我们也可以在自己的机器上运行它，如下图所示。
Stable Diffusion 是一个AI 绘图软件 （开源模型），可本地部署，可切换多种模型，且新的模型和开源库每天都在更新发布，最重要的是免费，没有绘图次数限制。
Github 网址：GitHub - AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI
玩 Stable Diffusion，就一定要会玩 ControlNet，它是 Stable Diffusion 一个非常重要的扩展插件（sd-webui-controlnet），它不仅可以用来复制构图和人体姿势，还有其他很多强大的功能，要使用 ControlNet（sd-webui-controlnet），就必须先要学会怎么安装它。
ControlNet github 地址：https://github.com/lllyasviel/ControlNet
ControlNet-v1-1-nightly github 地址：https://github.com/lllyasviel/ControlNet-v1-1-nightly
sd-webui-controlnet
github 地址：https://github.com/Mikubill/sd-webui-controlnet
通过上面的方式，ControlNet 可以重用SD编码器作为一个深度，强，鲁棒和强大的骨干来学习不同的控制。许多证据(像这个和这个)验证了SD编码器是一个优秀的骨干。
注意，我们连接层的方式是计算效率高的。原始SD编码器不需要存储梯度(锁定的原始SD编码器块1234和Middle)。所需的GPU内存并不比原来的SD大多少，尽管增加了许多层。
所有的模型和检测器都可以从 our Hugging Face page下载。确保SD模型放在“ControlNet/models”中，检测器放在“ControlNet/annotator/ckpts”中。确保从 our Hugging Face page下载了所有必要的预训练权重和检测器模型，包括HED边缘检测模型、Midas深度估计模型、Openpose等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b60b291ddbd78691318abf3b4d627e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be01960024b6493bbc0c07e929b74db4/" rel="bookmark">
			insert overwrite table：数据仓库和数据分析中的常用技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍： INSERT OVERWRITE TABLE 是用于覆盖（即替换）目标表中的数据的操作。它将新的数据写入表中，并删除原有的数据。这个操作适用于非分区表和分区表。
二、使用场景： 1、数据更新：当您需要更新表中的数据时，可以使用覆写操作。通过覆写，您可以将新的数据写入表中，替换原有的数据。这在需要定期更新或替换表中数据的情况下非常有用。
2、数据重载：如果您需要重新加载表中的数据，覆写操作可以清空表并将新的数据加载进去。这在数据仓库或数据分析任务中很常见，当需要重新加载或替换表中的数据时，覆写操作是一个快速有效的方法。
3、数据清理：当需要删除表中的数据时，可以使用覆写操作。通过将一个空表覆写到目标表中，可以清空表中的数据并释放存储空间。
注：insert overwrite table 是一个具有破坏性操作的语句，因为它会完全覆盖表中的数据。在使用之前，请确保您理解该操作的影响，并备份重要的数据以防止意外数据丢失。
三、普通表应用： 1、准备工作 create table db_1.tb_student( id int, name string, city string ) row format delimited fields terminated by ','; insert into db_1.tb_student values (1,'张三','beijing') , (2, '李四', 'beijing'), (3, '王五', 'beijing'), (4, '妲己', 'shanghai'), (5, '哪吒', 'shanghai'), (6, '雷震子', 'shanghai'), (7, '悟空', 'guangzhou'), (8, '八戒', 'guangzhou'), (9, '沙和尚', 'guangzhou'); create table db_1.tb_student_2( id int, name string, city string ) row format delimited fields terminated by ','; drop table if exists tb_student_3_part; create table db_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be01960024b6493bbc0c07e929b74db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0e8c14ccbb99f75a61659f99532b9e/" rel="bookmark">
			python pytorch-GPU 环境搭建 (CUDA 11.2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 环境搭建逻辑 如下图所示，为 pytorch 或 tensorflow 的环境搭建逻辑
2. 一般情况 一般情况下，我们需要按照如下顺序考虑我们该安装哪个版本的 cuda 以及 安装哪个版本的 pytorch
2.0 查看是否已安装cuda 通过下述cmd命令行
C:\Users\asus&gt;nvcc -V 如果已安装cuda，则如下图所示，可知悉安装的cuda版本
2.1 安装哪个版本的cuda（尚未安装cuda） 1. 通过以下cmd命令行获悉最高能安装的cuda版本
C:\Users\asus&gt;nvidia-smi 结果如下图所示
2. 通过以下网址，结合自己对pytorch版本的需要，综合考虑该安装哪个版本的cuda
cuda-pytorch版本对应 官方https://pytorch.org/get-started/previous-versions/ （建议使用Ctrl+F快速搜索）
2.2 安装哪个版本的pytorch（已安装cuda，且不是cuda11.2） 如果已知自己的cuda版本（且不是cuda11.2），则通过以下网址，决定安装哪个版本的pytorch
Previous PyTorch Versions | PyTorchhttps://pytorch.org/get-started/previous-versions/（建议使用Ctrl+F快速搜索）
如下图所示，如果我安装的cuda版本是11.3 且我希望通过pip安装pytorch，则我应该用“Ctrl+F”的方式找“Wheel” 和 “CUDA 11.3”这两个关键字。
通常会看到很多符合要求的结果，如下展示两例，表明：windows环境下，如果想通过pip安装pytorch，且cuda版本是11.3，那么至少pytorch1.12.1和pytorch1.12.0我是可以安装的。（其实还有更多pytorch版本都可以安装，这里仅贴上来两个例子）
（类似的，如果想通过conda在虚拟环境中安装pytorch，那么在网站中应该搜索的关键字应为“Conda” 和 “CUDA 11.3”）
3. 特殊情况 已安装 CUDA11.2 比较麻烦的情况是，如果我安装的是cuda 11.2这个版本，那么在上述网站中检索不到对应的pytorch版本。
一个已经被验证的解决方案为：（只适用于已安装cuda11.2）
1. 确保已安装cuda11.2
2. 确保虚拟环境的python版本为python3.8
那么，我们可以通过如下命令行，在虚拟环境中用pip安装pytorch1.9.1这个版本
pip install torch==1.9.1+cu111 torchvision==0.10.1+cu111 torchaudio==0.9.1 -f https://download.pytorch.org/whl/torch_stable.html --trusted-host pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd0e8c14ccbb99f75a61659f99532b9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283cfa855c637f897ef4ffa47cbeb87e/" rel="bookmark">
			ElasticSearch详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Elasticsearch是什么？
二、为什么要使用ElasticSearch
2.1 关系型数据库有什么问题？
2.2 ElasticSearch有什么优势？
2.3 ES使用场景
三、ElasticSearch概念、原理与实现
3.1 搜索引擎原理
3.2 Lucene 倒排索引核心原理
倒排索引
四、Elasticsearch 整体架构
4.1 集群节点角色
4.2 数据副本
4.3 水平扩容
4.4 故障转移
4.5 路由机制
4.6 新建、更新、删除文档
4.6.1 写数据底层原理
4.6.2 索引的不变性
4.6.3 动态索引创建过程
4.6.4 分步查看数据持久化过程
4.6.5 更新/删除数据底层原理
4.7 查询文档
4.8 更新文档
4.9 分布式检索
五、ElasticSearch实际使用过程中会有什么问题
5.1 分片的设定
5.2 ES数据近实时问题
5.3 深分页问题
六、ES性能优化
七、ElasticSearch运维
一、Elasticsearch是什么？ Elasticsearch（简称ES）是一个分布式、可扩展、实时的搜索与数据分析引擎。ES不仅仅只是全文搜索，还支持结构化搜索、数据分析、复杂的语言处理、地理位置和对象间关联关系等。
ES的底层依赖Lucene，Lucene可以说是当下最先进、高性能、全功能的搜索引擎库。但是Lucene仅仅只是一个库。为了充分发挥其功能，你需要使用Java并将Lucene直接集成到应用程序中。更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理，因为Lucene非常复杂。
鉴于Lucene如此强大却难以上手的特点，诞生了ES。ES也是使用Java编写的，它的内部使用Lucene做索引与搜索，它的目的是隐藏Lucene的复杂性，取而代之的提供一套简单一致的RESTful API。
ES具有如下特点：
一个分布式的实时文档存储引擎，每个字段都可以被索引与搜索
一个分布式实时分析搜索引擎，支持各种查询和聚合操作
能胜任上百个服务节点的扩展，并可以支持PB级别的结构化或者非结构化数据
二、为什么要使用ElasticSearch 2.1 关系型数据库有什么问题？ 传统的关系数据库提供事务保证，具有不错的性能，高可靠性，久经历史考验，而且使用简单，功能强大，同时也积累了大量的成功案例。
后来，随着访问量的上升，几乎大部分使用 MySQL 架构的网站在数据库上都开始出现了性能问题，web 程序不再仅仅专注在功能上，同时也在追求性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283cfa855c637f897ef4ffa47cbeb87e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db3dab2b1386cdc99119b81df6c99425/" rel="bookmark">
			【MQTT接收数据写入数据库】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT接收数据写入数据库 1.搭建MQTT服务器 参考上一篇文章
2.安装数据库mysql sudo apt update sudo apt install mysql-server 创建一个数据库和数据表存储mqtt消息
首先，登录到MySQL服务器：
mysql -u root -p 输入你的root用户密码。默认root
3.创建mqtt数据表 创建数据库: CREATE DATABASE mqtt_data; 选择创建的数据库: USE mqtt_data; 创建数据表: 这里我们假设你从MQTT接收到的数据是一个简单的字符串。我们将创建一个包含两个字段的表，一个字段是自增的ID，另一个字段用于存储字符串数据。
CREATE TABLE mqtt_messages ( id INT AUTO_INCREMENT PRIMARY KEY, message_data VARCHAR(255) NOT NULL, received_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); 完成以上步骤后，你现在有一个名为mqtt_data的数据库和一个名为mqtt_messages的数据表。
4.编写python脚本来从MQTT接收数据并保存到数据库 模板文件
import paho.mqtt.client as mqtt import mysql.connector # MySQL数据库配置 db_config = { 'host': 'localhost', 'user': 'root', 'password': 'your_root_password', # 替换为你的root密码 'database': 'mqtt_data' } # 连接到数据库 conn = mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db3dab2b1386cdc99119b81df6c99425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7bb47c74c39e364518c99d8bf5a2eb1/" rel="bookmark">
			el-select数据过多的解决（纯前端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 el-select数据过多这个问题应该很多人都遇到过，在生产环境中数据几百、几千条是比较常见的。当数据过多时，就会造成浏览器卡顿，如果客户电脑性能不行，浏览器直接卡死也有可能。
解决 先说一下现在项目中遇到的两种解决方案：
原解决方案 添加分页条
这种方案好像有点问题，具体什么问题忘记了，感兴趣的可以看一下：element ui 下拉框分页（下拉框数据过多）
滚动懒加载
这种方式是我的一个同事写的，代码就不放了。原理就是一开始加载20条数据，当列表滚动到底部的时候，加载下一个20条数据。
先解决方案 最近在思考，卡顿的根本原因就是数据太多了。那么我能否一下子把所有数据都请求过来，但是我每次就显示20条数据，当我向下滚动时我就渲染下一个20条数据。
当然有一些问题是需要解决的：
数据回显的问题。当下拉绑定的值在下拉项里匹配不到时就是显示绑定的值，而不是对应的名称。目前考虑：这20条数据里如果有这个值则不处理；没有这个值，则往数组里添加上。这样会有20条数据和21条数据两种情况模糊搜索的话，也是每次显示20条数据数据切换的话打算通过鼠标滑轮事件来实现 示例
肯定会有些问题，但是作为一个demo就懒得处理了，纯粹是提供一种思路
&lt;template&gt; &lt;div&gt; &lt;el-select v-model="selectValue" placeholder="Select" size="large" :loading="loading" filterable @visible-change="handleVisible" :filter-method="myFilter"&gt; &lt;el-option v-for="item in showOptions" :key="item.value" :label="item.label" :value="item.value" /&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { ref, onMounted, nextTick } from "vue"; // 绑定的值 const selectValue = ref(22); // 下拉显示的值 const showOptions = ref&lt;Array&lt;any&gt;&gt;([]) // 下拉所有的值 const allOptions = ref&lt;Array&lt;any&gt;&gt;([]) // 每次显示的条数 const showCount = 20 // 当前页 const current = ref(1) // 总页数 const total = ref(0) // loading动画 const loading = ref(false) // 外层容器 const outer = ref() // 上一次滚动的值 const lastScrollTop = ref(0) // 用于记录中间值 const tempList = ref&lt;Array&lt;any&gt;&gt;([]) onMounted(() =&gt; { // 假设下拉值共用100条数据 for (let i = 1; i &lt;= 200; i++) { allOptions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7bb47c74c39e364518c99d8bf5a2eb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334b9847f4d886d9e8cb19eea03218ce/" rel="bookmark">
			【算法系列篇】分治-归并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言什么是归并算法1. 排序数组1.1 题目要求1.2 做题思路1.3 Java代码实现 2. 数组中逆序对2.1 题目要求2.2 做题思路2.3 Java代码实现 3. 计算右侧小于当前元素的个数3.1 题目要求3.2 做题思路3.3 Java代码实现 4. 翻转对4.1 题目要求4.2 做题思路4.3 Java代码实现 总结 前言 上一篇算法文章，我们介绍了分治-快排的算法，今天我将为大家分享关于分治的另外一种算法——归并。
什么是归并算法 归并算法是一种常用的排序算法，它采用分治策略将待排序的数组分解为更小的子数组，然后逐步合并这些子数组以获得最终的有序数组。归并排序的主要思想是将两个有序的子数组合并成一个有序的数组。
归并算法通常包含以下步骤：
分解（Divide）：将待排序的数组递归地分解为规模更小的子数组，直到每个子数组只有一个元素或为空。
解决（Conquer）：通过递归地排序子数组，将其转化为有序的子数组。这通常是通过继续将子数组进一步分解并排序的方式实现的。
合并（Merge）：将两个有序的子数组合并成一个有序的数组。该步骤的实现方式是比较两个子数组的元素，并按照顺序合并到一个新的数组中，直到所有元素都被合并。
归并排序的时间复杂度是O(nlogn)，其中n是待排序数组的长度。它的主要优点包括：
稳定性：归并排序是一种稳定的排序算法，即相等元素的相对顺序不会被改变。
适用性：归并排序适用于各种数据结构，尤其在外部排序中，它对于大规模数据的排序效果明显。
然而，归并排序也存在一些缺点：
额外空间消耗：归并排序需要额外的空间来存储临时的子数组和合并结果，这可能对内存消耗造成一定影响。
递归调用：归并排序的实现通常使用递归调用，对于大规模数据的排序可能导致递归深度增加，从而增加了额外的函数调用开销。
总结而言，归并排序是一种高效、稳定的排序算法，通过分治策略将待排序的数组分解为更小的子数组，然后逐步合并这些子数组以获得最终的有序数组。尽管归并排序需要额外的空间和函数调用开销，但它在实践中被广泛使用，特别适用于对大规模数据进行排序。
1. 排序数组 https://leetcode.cn/problems/sort-an-array/
1.1 题目要求 给你一个整数数组 nums，请你将该数组升序排列。
示例 1：
输入：nums = [5,2,3,1] 输出：[1,2,3,5] 示例 2：
输入：nums = [5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示：
1 &lt;= nums.length &lt;= 5 * 104-5 * 104 &lt;= nums[i] &lt;= 5 * 104 class Solution { public int[] sortArray(int[] nums) { } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/334b9847f4d886d9e8cb19eea03218ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195ab708091e4ff9f5a02adcb9eb2eae/" rel="bookmark">
			【web知识清单】你想要的都有：网络、HTTP、会话保持、认证授权......持续更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：
目录
1.网络
2.HTTP
2.1.报文结构
2.1.1.请求报文
2.1.2.响应报文
2.2.方法
2.3.HTTPS
2.4.跨域
3.会话保持
3.1.概述
3.2.cookie
3.3.session
4.认证授权
4.1.Token
4.2.JWT
4.3.oauth
1.网络 计算机网络：
计算机网络，由节点和边组成的一组拓扑结构。
边，即链路，路由器间的链路为主干链路，路由器和主机之间的链路为接入链路。
节点，即主机节点或者数据交换节点，由主机或者数据交换设备（或者更高层的负载均衡设备）组成
分层：
根据所负责的功能的不同，计算机网络在逻辑上分层吗，经典模型是OSI七层，但是七层稍显繁琐，一般用TCP/IP四层就能简要说明网络分层中层级的作用。
TCP/IP四层分层：
应用层
应用程序
传输层
提供端到端之间的通信，传输层在终端用户之间提供透明的数据传输，向上层提供可靠的数据传输服务。传输层在给定的链路上通过流量控制、分段/重组和差错控制来保证数据传输的可靠性。
网络层
IP层，负责处理IP数据报文在网络中的传输，IP层传输的是IP数据报文，借助路由表，把IP数据报文从网络的一端传输到另一端，简而言之，IP实现包的路由传输，IP协议和路由器工作在网络层。
网络接口层
包括操作系统的设备驱动程序和网卡，它们一起处理与传输媒介（光纤等）的物理接口细节。
数据在分层间流转、网络中游走的过程如下：
协议：
协议，对等层实体间通信过程中遵守的规则的集合。
以下为各层中一些经典的协议：
2.HTTP HTTP，超文本传输协议，WEB体系选用了该协议作为应用层协议。
2.1.报文结构 2.1.1.请求报文 HTTP的请求报文（request）由四部分组成：请求行(request line)、请求头部(header)、空行和请求数据(request data)
名称作用请求行记录请求方法、URL、HTTP协议版本号请求头以键值对的方式记录一些附加信息，如cookie、编码、host等请求数据请求数据，也叫请求体，不在GET方法中使用，而是在POST方法中使用， POST方法适用于需要客户填写表单的场合。 请求头中存在两个与请求数据相关的重要key：Content-Type和Content-Length。 也就是说只有Post请求有请求体：
2.1.2.响应报文 HTTP的响应报文（response）中最重要的两部分：
状态码
记录响应的状态
响应体
记录响应的数据，可以是是网页（HTML代码），是图片、视频、音频等。
2.2.方法 HTTP中总共有GET、POST、PUT、DELETE、CONNECT、HEAD，本来设计的初衷是想让对服务器的每一种操作都有对应的方法，但在实际使用中发现其实GET、POST两个方法就足够了，GET负责向服务器要数据，POST负责向服务器存数据。
GET、POST区别：
名称特点GET参数在URL中，数据大小不能超过2KBPOST数据在HTTP报文的“请求数据”这一区域，理论上大小没有上限 2.3.HTTPS https=http+ssl/TSL，即使用HTTP进行通信，使用SSL/TLS对数据进行保护。
在https体系中，SSL/TLS为HTTP协议（应用层）和TCP（传输层）间的中间层。
SSL/TLS在三个维度对数据进行保护：
内容加密：采用混合加密技术，中间者无法直接查看明文内容
验证身份：通过证书认证客户端访问的是自己的服务器
保护数据完整性：防止传输的内容被中间人冒充或者篡改
SSL:
Secure Sockets Layer，安全套接层协议，为网络通信提供安全及数据完整性的一种安全协议。在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195ab708091e4ff9f5a02adcb9eb2eae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d798868da16faeb0d81dbb9dccc35fc6/" rel="bookmark">
			MySQL问题：2002 - Can‘t connect to server on ‘localhost‘(10061)【已解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MySQL报错信息 "2002 - Can't connect to server on 'localhost' (10061)" 通常表示MySQL客户端无法连接到MySQL服务器。这个问题通常有以下几个可能的原因和解决方法：
MySQL服务器未启动：首先确保MySQL服务器已经启动。你可以在命令行中输入以下命令来启动MySQL服务：
sudo service mysql start 如果你使用的是Windows，你可以在服务中找到MySQL服务并手动启动它。
MySQL服务器端口被占用：默认情况下，MySQL使用3306端口。确保这个端口没有被其他程序占用。你可以尝试修改MySQL配置文件（通常是my.cnf或my.ini）来更改MySQL的端口号，然后重新启动MySQL服务。
MySQL服务器配置问题：检查MySQL服务器的配置文件，确保它允许远程连接。你可以找到my.cnf文件，然后检查bind-address属性是否设置为允许远程连接。如果你希望允许远程连接，将其设置为0.0.0.0或注释掉该行。然后重启MySQL服务。
防火墙问题：如果你的操作系统启用了防火墙，确保3306端口被允许通过防火墙。你可以根据你的操作系统类型和防火墙软件来配置防火墙规则。
MySQL用户名和密码问题：如果你的应用程序需要提供MySQL用户名和密码进行连接，确保它们是正确的。检查你的应用程序代码或配置文件，确保用户名和密码与MySQL服务器中的帐户匹配。
MySQL服务器崩溃或未响应：有时候MySQL服务器可能会崩溃或停止响应。在这种情况下，你可以尝试重新启动MySQL服务。
MySQL客户端问题：最后，确保你使用的MySQL客户端能够正确连接到MySQL服务器。有时候问题可能出在客户端配置或驱动程序上。
以下是一些可能用到的代码片段，用于检查MySQL服务是否已启动和重新启动MySQL服务。这些命令可以在终端或命令提示符中运行：
启动MySQL服务（Linux）： sudo service mysql start 2.启动MySQL服务（Windows）： net start mysql 3.重新启动MySQL服务（Linux）： sudo service mysql restart 重新启动MySQL服务（Windows）： net stop mysql net start mysql 以下是我的Windows系统遇到的问题及解决方案 1.报错问题 ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)
将mysql加入到Windows的服务中。切换到mysql安装目录下的bin文件夹，命令行运行"mysqld --install"
2.解决方法 打开计算机管理
打开服务
点击MYSQL80，手动启动
重新连接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62e9a630d63a816bcd1c8ec686658d6/" rel="bookmark">
			【链表OJ 11】复制带随机指针的链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言: 💥🎈个人主页:​​​​​​Dream_Chaser～ 🎈💥
✨✨刷题专栏:http://t.csdn.cn/UlvTc
⛳⛳本篇内容:力扣上链表OJ题目
目录
leetcode138. 复制带随机指针的链表
1. 问题描述
2.代码思路:
2.1拷贝节点插入到原节点的后面
2.2控制拷贝节点的random 2.3拷贝节点解下来尾插组成拷贝链表，恢复原链表
leetcode138. 复制带随机指针的链表 来源:138. 复制带随机指针的链表 - 力扣（LeetCode）
1. 问题描述 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不
应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。
返回复制链表的头节点。
题解接口: struct Node* copyRandomList(struct Node* head) { } 2.代码思路: 2.1拷贝节点插入到原节点的后面 复制节点：遍历原链表，对于每个节点，创建一个副本节点，并将其插入到原节点的后面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62e9a630d63a816bcd1c8ec686658d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfaf792768d26255c35fa25ab1e49dc8/" rel="bookmark">
			通过nginx将https协议反向代理到http协议请求上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过nginx将https协议反向代理到http协议请求上 1、问题背景2、介绍nginx的反向代理功能及配置https协议3、具体实现3.1 后端服务支持方式3.2 nginx重定向方式 3.3、nginx的反向代理方式4、关于nginx常用模块和指令 1、问题背景 目前一个系统仅支持https协议访问，因后端服务基于ssl协议，前端在请求是也需要支持ssl协议的https请求来访问。目前的代理服务器是nginx，现在想要通过http访问系统，需通过nginx的反向代理或者重定向方式将https请求代理为http请求。可实现的做法有如下几种：
1、使后端开放两种端口，一个端口支持https协议访问，一个端口支持http协议访问，之后前端请求通过nginx代理，同时nginx也开放两个端口（比如80端口作为http访问，443端口作为https访问系统）。使不同协议走不同的后端服务
2、使用nginx的重定向功能，每次http请求过来后重定向为https请求
3、使用nginx的反向代理功能，将将https协议反向代理到http协议请求上
2、介绍nginx的反向代理功能及配置https协议 反向代理是一种服务器架构，它接收来自客户端的请求，然后将这些请求转发到一个或多个后端服务器，并将后端服务器的响应返回给客户端。
与正向代理的区别：
正向代理是客户端与代理服务器之间的一种代理模式。在正向代理中，客户端请求首先发送到代理服务器，然后由代理服务器转发请求给目标服务器。代理服务器代表客户端发送请求，目标服务器并不知道实际发出请求的客户端身份
反向代理是服务器与后端服务器之间的一种代理模式。在反向代理中，客户端请求首先发送到反向代理服务器，然后由反向代理服务器根据配置将请求转发给后端的一个或多个服务器。后端服务器的响应再由反向代理服务器返回给客户端。客户端不需要知道后端服务器的实际存在。
反向代理就像商店的售货员，当你去商店购物时，你与售货员打交道，但实际上商品是从后面的仓库取出来的。售货员帮你获取商品，然后交给你。在这个比喻中，售货员就是反向代理，仓库就是后端服务器，你则是客户端。
nginx配置https请求,主要是如下方式，且通过location指令将请求代理都后端的https接口上
server { listen 443 ssl; server_name example.com www.example.com; ssl_certificate /path/to/ssl/certificate.crt; ssl_certificate_key /path/to/ssl/private.key; location / { # 处理HTTPS请求的配置 proxy_pass https://backend_server; } } 3、具体实现 3.1 后端服务支持方式 springboot应用中，可以通过配置文件方式配置开启端口，但是协议只能指定一个，如下：通过application.yml的server属性可以配置一个https协议访问的应用端口
如果想要再次打开一个端口支持http请求，需要根据使用的后端服务器编写配置类，当前项目使用的是Jeety服务器，配置类代码如下：
import org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory; import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class HttpConfig { @Bean public WebServerFactoryCustomizer&lt;JettyServletWebServerFactory&gt; servletContainer() { return server -&gt; { server.setPort(8081); // 这里配置 HTTP 端口为 8081，也可以通过加配置文件方式获取 }; } } 这时候启动项目，会同时开放两个端口，之后通过nginx代理即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfaf792768d26255c35fa25ab1e49dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b82d5c214f9d960a75df952a1808d3c/" rel="bookmark">
			Vue &#43; Element UI 前端篇（六）：更换皮肤主题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义主题 命令行主题工具 1.安装主题工具 首先安装「主题生成工具」，可以全局安装或者安装在当前项目下，推荐安装在项目里，方便别人 clone 项目时能直接安装依赖并启动。
yarn add element-theme --dev 2.安装chalk主题 安装白垩主题，可以从 npm 安装或者从 GitHub 拉取最新代码，这里从 npm 安装。
yarn add element-theme-chalk -D 3.初始化变量文件 主题生成工具安装成功后，如果全局安装可以在命令行里通过 et 调用工具，如果安装在当前目录下，需要通过 node_modules/.bin/et 访问到命令。执行 -i 初始化变量文件。默认输出到 element-variables.scss，当然你可以传参数指定文件输出目录。
node_modules/.bin/et -i 执行命令
命令执行成功之后，会在根目录生成 scss文件 element-variables.scss 。
4、修改主题色 在 element-variables.scss 文件里修改 $–color-primary:#4b5f6e，即你想要的主题颜色
5、编译主题 执行主题编译命令生成主题，根目录会生成一个theme的文件夹 。
node_modules/.bin/et 6、引入自定义主题 把生成的主题按颜色改名放置 src/theme 目录下。
在 main.js 中 import ‘所在路径/index.css’。
7、效果展示 重新加载后，我们看到按钮颜色已经不是默认的蓝色了。
动态换肤器方式 1. 在下图位置添加封装的换肤组件。 index.vue
&lt;template&gt; &lt;el-color-picker class="theme-picker" popper-class="theme-picker-dropdown" v-model="theme"&gt;&lt;/el-color-picker&gt; &lt;/template&gt; &lt;script&gt; const version = require('element-ui/package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b82d5c214f9d960a75df952a1808d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79885a547a3fcbbad72d617932e1a77b/" rel="bookmark">
			FastAPI &#43; NGINX &#43; Gunicorn：一步一步教你部署一个高性能的Python网页应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 部署一个 FastAPI 应用到你的服务器是一项复杂的任务。如果你对NGINX、Gunicorn和 Uvicorn 这些技术不熟悉，可能会浪费大量的时间。如果你是刚接触 Python 语言不久或者希望利用 Python 构建自己的Web应用程序，本文的内容可能会让你第一次部署时更节省时间。
FastAPI 是用于开发API应用最受欢迎的Python库之一，用于开发API。它以其出色的性能和易用性而闻名。如果你在网页应用中使用机器学习模型，那么它很可能是你首选的工具。
NGINX、Gunicorn 和 Uvicorn 都是经过实践验证的技术，常被用作反向代理和ASGI服务器来部署Python网页应用。如果你熟悉 Django 或 Flask，你可能之前听说过它们中的一些。
接下来，我将展示如何结合这些工具来部署一个 FastAPI 网页应用。以下是主要内容：
介绍FastAPI、NGINX、Gunicorn和Uvicorn的基础知识。
配置Gunicorn + Uvicorn作为ASGI服务器。
设置NGINX作为反向代理服务器。
使用Let's Encrypt生成免费SSL证书。
二、技术框架介绍 2.1、FastAPI FastAPI 是一个现代的、高性能的 Web 框架，用于使用 Python 构建 API，并基于标准类型提示。
它具有以下主要特点：
高效运行：借助 Starlette 和 pydantic，FastAPI 提供了与 NodeJS 和 Go 类似的出色性能。FastAPI比Flask快得多，它实际上是Python最快的Web框架之一。唯一比 FastAPI 更快的框架是 Starlette（FastAPI 实际上是基于 Starlette 构建的）。
快速开发：它可以显著提高开发速度。
减少错误：减少了人为错误的可能性。
直观易用：支持强大的编辑器功能、自动补全和更少的调试时间。
简单易学：设计简单明了，您可以花更少时间阅读文档。
减少重复代码量：最大限度地减少了代码重复。
健壮可靠：提供生产就绪的代码和自动生成交互式文档功能。
基于标准化：遵循 API、OpenAPI 和 JSON 模式等开放标准。
该框架旨在优化开发人员体验，使您能够以简洁的代码构建具备最佳实践且适合生产环境使用的 API。
2.2、Gunicorn Gunicorn是用于Python应用程序的WSGI服务器的一种实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79885a547a3fcbbad72d617932e1a77b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/585/">«</a>
	<span class="pagination__item pagination__item--current">586/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/587/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>