<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2dbd8cb638b7456a009e0d0fafe6c3f/" rel="bookmark">
			springboot整合webservice使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为做的项目中用到了webservice,所以在此总结一下。
一、webservice简介 Web Service也叫XML Web Service, WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术。是通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。WebService是一种跨编程语言和跨操作系统平台的远程调用技术。
还可以从多个角度来理解WebService，从表面看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端。从深层次看，WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。
二、webservice三要素： SOAP、WSDL、UDDI（UniversalDescriptionDiscovery andIntegration）三者构成了WebService的三要素。下面详细阐述这三大技术：
SOAP：
WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC(远程调用技术)方法来调用Web Service。
SOAP协议组成：
SOAP协议 = HTTP协议 + XML数据格式
SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML的，XML是SOAP的数据编码方式。
WSDL
好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。
WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。
UDDI
uddi是一个跨产业，跨平台的开放性架构，可以帮助 Web 服务提供商在互联网上发布 Web 服务的信息。UDDI 是一种目录服务，企业可以通过 UDDI 来注册和搜索 Web 服务。简单来说，UDDI 就是一个目录，只不过在这个目录中存放的是一些关于 Web 服务的信息而已。
也就是说：
soap：就是在与webservice通信时规定好的协议
wsdl：就是webservice中的食谱，你可以找到webservice中有哪些材料（方法），怎去做这道菜（入参、方法、返回值）等
uddi：wsdl是食谱的话，uddi就是菜单，可以用来注册和搜索web服务。
三、为什么要使用WebService 跨平台调用跨语言调用远程调用 四、springboot简单调用案例 1、引入依赖： &lt;!-- CXF webservice --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-spring-boot-starter-jaxws&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; 2、创建实体类： @Data @Builder public class UserDto { private Long id; private String name; private Integer age; private String address; } 3、创建WebService接口 public interface IUserServer { UserDto getUser(Long str)； } 4、创建WebService接口的实现类 @Service @WebService public class UserServerImpl implements IUserServer { @Override public UserDto getUser(Long id) { return UserDto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2dbd8cb638b7456a009e0d0fafe6c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b83870a610eed106ca0bd8661984f5/" rel="bookmark">
			【卫星定位】GPS/BDS北斗卫星单点定位SPP详解（附Matlab源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract 本文使用Matlab编写了支持RINEX 3.03的单点定位系统（Single Point Positioning，SPP)，目前支持GPS与北斗系统定位。具体工作如下：1）实现了RINEX格式的OBS与NAV数据解析程序，通过NAV文件得到观测卫星轨道位置与钟差，通过OBS文件得到卫星观测伪距；
2）实现了对伪距的观测与误差建模，采用最小二乘优化解算，并对HDOP值等估计参数进行了计算；
3）进行了定点基站定位与移动站定位的误差分析，最后解算结果以NMEA 0183格式输出。为贡献卫星学习社区，本文代码将开源于：https://github.com/Franky-X/SPP-Supporting-RENIX3.03-with-GPS-BDS。
Introduction 卫星单点定位系统（Single Point Positioning，SPP)是最常用且简单的定位手段之一。SPP利用接收机收到的广播星历数据解析出各卫星的轨道位置，结合卫星的伪距、钟差以及对流层、电离层误差模型，对接收机位置进行解算。本文针对RENIX
3.03格式接收机数据进行了解析，完成了支持GPS和北斗系统的定位，并分析了定位误差结果。本文的核心工作点如下：
实现了OBS与NAV数据解析程序，通过NAV文件得到观测卫星轨道位置与钟差，通过OBS文件得到卫星观测伪距；
实现了对伪距的观测与误差建模，采用最小二乘优化解算，并对HDOP值等估计参数进行了计算；
进行了定点基站定位与移动站定位的误差分析，并将代码开源至社区。
本文将就以下内容展开介绍。第2部分详细介绍了SPP的整体流程，RENIX文件的读取格式、卫星位置计算以及伪距观测与误差建模的原理。第3部分介绍了SPP算法在Matlab中的实现方式和细节。第4部分展示了GPS和BDS的定位结果与误差分析。第5部分总结了本文的工作内容。
Methods 在本小节，我们首先介绍了SPP定位的系统框架，然后对RENIX文件的NAV和OBS文件读取方法进行了分析，接着我们介绍了GPS和北斗卫星位置的解算方法。最后讨论了伪距观测与误差建模过程，介绍了最小二乘问题的构建与解算。
系统框架 如图所示，SPP定位的主要原理是利用已知的卫星位置，结合观测的伪距与对流层模型进行位置解算。
系统执行流程如图所示，首先卫星的位置及钟差由NAV文件读取获得，卫星的伪距观测由OBS文件获得。接着，将卫星的位置、钟差、观测伪距以及对流层误差模型结合，构建最小二乘问题解算，最后输出用户的位置以及相关估计参数。
RENIX文件解析 RENIX文件包括了对卫星轨道位置参数的解算和接收机伪距观测的信息提取，接下来进行详细介绍。
NAV文件解析 NAV文件分为头部解释部分和数据部分，其中头部解释Header部分的信息量有限。主要通过数据部分，结合官方RINEX手册中的广播星历解释，获取计算卫星位置和钟差所需要的轨道参数。参数解析方式可参照我的NAV解析代码https://github.com/Franky-X/Computation-of-BD-Orbit，在此不再赘述。
在读取NAV文件时需要记录卫星编号，以便后续在得到伪距观测侯寻找到与之对应的卫星位置与钟差。
OBS文件解析 OBS文件分为头部解释部分和数据部分。其中头部解释Header部分主要描述了卫星系统、接收消息的种类、接收消息的间隔与接收消息的起止时间，对于数据解析非常重要，部分重要字段如表所示。
含义字段卫星系统/参数个数/观测种类SYS / / OBS TYPES信息时间间隔INTERVAL第一次观测时刻（GPS时间）GPS TIME OF FIRST OBS最后一次观测时刻（GPS时间）GPS TIME OF LAST OBS SPP利用的是伪距进行定位，因此在数据部分我们需要提取的是伪距观测量，在OBS TYPE字段中，伪距观测的首字母为C，因此在读取卫星伪距过程中，只需要读取首字母为C，具有相同波段n的数据即可。
此外，在读取OBS文件过程中，每一个时刻读入的数据记作一个Epoch，便于后续处理。
卫星位置解算 卫星位置和钟差的解算是SPP伪距定位的基础，GPS与北斗系统的卫星系统在真实定位情况中计算有所不同，下面详细介绍GPS和北斗系统的卫星位置与钟差解算过程。
GPS卫星位置解算 计算GPS卫星运动的平均角速度 首先根据广播星历给出的参数 A \sqrt{A} A ​
计算参考时刻 t o e t_{o e} toe​ 的平均角速度 n 0 \mathrm{n}_0 n0​ :
n 0 = G M ( A ) 3 \mathrm{n}_0=\frac{\sqrt{G M}}{(\sqrt{A})^3} n0​=(A ​)3GM ​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b83870a610eed106ca0bd8661984f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c05f2be9796c3d67e259b440c40ad29/" rel="bookmark">
			AndroidStudio导入程序、项目（教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 首先解压压缩包，转为文件夹
2. 打开解压好的项目文件夹，删除.gradle和.idea这两个文件
3. 修改bulid.gradle文件，将gradle的版本型号改成自己的
(1) 传统结构
(2) 简洁结构
4.修改Sdk路径
5. 打开android stdio软件，导入已经修改好的项目
6. 修改gradle-wrapper.properties文件
(1) 修改方法1
(2) 修改方法2
7. Cause: connect timed out报错
8. Installed Build Tools revision 34.0.0 is corrupted. Remove and install again using the SDK Manager.报错
导入项目需要注意的文件有，build.gradle，gradle-wrapper.properties，.gradle，.idea。
1. 首先解压压缩包，转为文件夹 请注意，项目文件夹路径中不能包含中文字符，包含中文字符会导致如下报错：
(1) org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin 'com.android.internal.application'.
(2) Caused by: org.gradle.api.tasks.StopExecutionException: Your project path contains non-ASCII characters. This will most likely cause the build to fail on Windows.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c05f2be9796c3d67e259b440c40ad29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6aff0e960cb365113127b8b4f88b00/" rel="bookmark">
			数据结构-如何实现一个队列？逐步解析与代码示例（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.队列的基本概念2.链表与数组实现队列的区别2.1数据存储结构2.2性能2.3内存使用 3.为什么选择链表实现队列？4.结构定义函数声明 5.核心操作5.1初始化 (`QInit`)5.2销毁 (`QDestroy`)5.3入队 (`QPush`)5.4出队 (`QPop`) 6.队列的查询操作6.1队首元素 (`QueueFront`)6.2队尾元素 (`QueueBack`) 7.辅助函数7.1判断空 (`QueueEmpty`)7.2队列大小 (`QueueSize`) 总结 前言 在计算机科学中，队列是一种非常基础且广泛使用的数据结构。它的工作原理类似于现实生活中的排队：先来的先服务（FIFO, First-In-First-Out）。在本文中，我们将深入探讨如何在C语言中使用链表实现一个队列，并解析相关的代码实现。
1.队列的基本概念 队列是一种遵循先进先出原则的线性数据结构。在队列中，添加操作（入队）发生在一端（队尾），而移除操作（出队）则发生在另一端（队首）。这种结构在多种场景中非常有用，如任务调度、数据缓冲等。
2.链表与数组实现队列的区别 当使用数组和链表实现队列时，主要区别在于数据存储结构、性能和内存使用：
2.1数据存储结构 数组：队列使用一个固定大小的数组。当数组满时，需要进行扩容，这可能涉及复制整个数组到新的内存位置。
链表：队列使用动态分配的节点，每个节点包含数据和指向下一个节点的指针。不需要事先分配固定大小的空间。
2.2性能 数组：入队和出队操作通常是O(1)复杂度，但当数组需要扩容时，复杂度会增加。
链表：由于不需要扩容，入队和出队操作始终保持O(1)复杂度。
2.3内存使用 数组：可能会有未使用的预留空间，特别是在队列大小波动较大时。
链表：每个元素单独分配，无需预留额外空间，但每个节点需要额外存储指针，略增加内存使用。
3.为什么选择链表实现队列？ 在C语言中，链表是一种常用的数据结构，用于创建动态大小的序列。相比于数组实现，链表实现的队列具有动态分配内存的优点，不受固定大小的限制。
与基于数组的队列实现相比，链表实现的队列具有以下优势：
动态大小：不受固定长度的限制，可以根据需要动态扩展或收缩。
内存利用：每个元素仅在需要时分配内存，减少了空间浪费。
性能优化：避免了数组实现中可能发生的元素搬移操作。
接下来我们来用链表进行实现队列。
4.结构定义 该队列的实现基于两种结构：QueueNode 和 Queue。
typedef int QDataType; // 定义队列数据类型为int // 队列节点的结构体定义 typedef struct QueueNode { QDataType val; // 节点存储的数据 struct QueueNode* next; // 指向下一个节点的指针 } QNode; // 队列的结构体定义 typedef struct Queue { QNode* phead; // 指向队列头部的指针 QNode* ptail; // 指向队列尾部的指针 int size; // 队列的大小 } Queue; 这里，QueueNode 表示队列中的每个节点，包含一个数据字段和一个指向下一个节点的指针。而Queue结构则持有指向队列头部和尾部的指针，并跟踪队列的当前大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6aff0e960cb365113127b8b4f88b00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7264787dbec6cc20e8a1519baf296230/" rel="bookmark">
			SpringDoc注解解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是SpringDoc SpringDoc注解的使用，它是基于OpenAPI 3和Swagger 3的现代化解决方案，相较于旧版的Swagger2(SpringFox)，SpringDoc提供了更简洁、更直观的注解方式。
二、SpringDoc的注解分类 2.1 作用于类的注解 1. @Tag 用于说明或定义的标签。也可以作用于方法上
部分参数：
name：名称
description：描述
@Tag(name = "用户接口", description = "用户管理相关接口") @RestController @RequestMapping("/users") public class UserController { } 2. @Hidden 某个元素（API操作、实体类属性等）是否在 API 文档中隐藏。当我们想要隐藏某些不必要的信息时，可以使用@Parameter(hidden = true)、@Operation(hidden = true)或者@Hidden注解。
3. @ApiResponse API 的响应信息。也可以作用于方法上，一般常用于方法上
部分参数：
responseCode：响应的 HTTP 状态码
description：响应信息的描述
content：响应的内容
@ApiResponse(responseCode = "200", description = "查询成功", content = @Content(schema = @Schema(implementation = User.class))) @ApiResponse(responseCode = "404", description = "查询失败") @GetMapping("/users/{id}") public ResponseEntity&lt;User&gt; getUserById(@PathVariable("id") Long id) { // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7264787dbec6cc20e8a1519baf296230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8451b2e9e69e42d9e5b466ed0e6cadfc/" rel="bookmark">
			时序预测：根据历史数据预测未来趋势的任务和算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时序预测是一项重要的数据分析任务，它旨在通过分析过去的数据模式和趋势，预测未来事件或现象的发展方向。在现代社会中，时序预测被广泛应用于各个领域，如金融、气象、交通和能源等，为决策者提供了有价值的信息和洞察力。本文将介绍时序预测的基本概念、任务以及常用的算法方法，并探讨其在实际应用中的挑战和应对策略。
一、时序预测的基本概念
时序预测是指利用历史数据中的时间序列信息，通过建立合适的模型和算法来预测未来的趋势。时间序列是按照时间顺序排列的一系列数据点，其中每个数据点对应着特定的时间戳和数值。时序预测的目标通常是预测未来某个时间点的数值，或是一段时间内的趋势变化。时序预测的输入数据包括历史时间序列数据和可能的外部因素，而输出结果则是未来时间点的预测值和相应的置信区间。
二、时序预测的任务
时序预测的主要任务可以分为以下几种：
(1) 单点预测：单点预测是指根据已知的历史数据，预测未来某个特定时间点的数值。这种任务常见于金融领域，如股票价格预测或货币汇率预测等。在单点预测中，常用的算法包括移动平均法、指数平滑法和自回归模型等。
(2) 区间预测：区间预测是指根据历史数据，预测未来一段时间内数值的范围。这种任务常见于气象预测领域，如气温预测或降雨量预测等。在区间预测中，常用的算法包括基于统计方法的置信区间估计和基于机器学习方法的回归模型等。
(3) 趋势预测：趋势预测是指根据历史数据，预测未来一段时间内数据的趋势变化。这种任务常见于交通规划和能源管理等领域。在趋势预测中，常用的算法包括支持向量回归、神经网络和决策树等。
三、常用的时序预测算法
时序预测涉及多种算法和方法，下面介绍几种常用的算法：
(1) 移动平均法：移动平均法是一种简单直观的预测方法，通过计算过去一段时间内数据点的平均值，来预测未来某个时间点的数值。它适用于平稳的时间序列数据，并且对异常值具有一定的鲁棒性。
(2) 指数平滑法：指数平滑法基于加权平均的思想，通过给不同时间点的数据赋予不同的权重，来预测未来的数值。指数平滑法适用于较为平稳的时间序列数据，可以进行单点预测或区间预测。
(3) 自回归移动平均模型（ARIMA）：ARIMA模型是一种经典的统计模型，结合了自回归和移动平均的特性，可以对时间序列数据进行建模和预测。ARIMA模型适用于平稳或近似平稳的时间序列数据，可以进行单点预测或区间预测。
(4) 支持向量回归（SVR）：SVR是一种机器学习算法，通过寻找最优的超平面来拟合时间序列数据，从而进行预测。SVR适用于非线性时间序列数据，可以进行单点预测或趋势预测。
(5) 神经网络：神经网络是一种强大的机器学习模型，可以对复杂的时间序列数据进行建模和预测。通过多层神经元的连接，神经网络可以捕捉时间序列数据中的非线性关系，并进行准确的预测。
综上所述，时序预测是一项重要的数据分析任务，它通过利用历史数据的模式和趋势，帮助我们预测未来的发展方向。无论是在金融、气象、交通还是能源等领域，时序预测都扮演着重要的角色。然而，时序预测也面临着一些挑战，如数据质量、模型选择以及外部因素的影响等。为了克服这些挑战，我们需要综合考虑多种因素，并选择合适的算法和方法来进行预测。随着数据科学和机器学习的不断发展，时序预测技术也在不断演进，为我们提供更准确、可靠的预测结果，助力更明智的决策和规划。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b7dbcc2542bab03879b52432c2bcc4/" rel="bookmark">
			PHP&#43;MySQL制作简单动态网站（附详细注释&#43;源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 项目名称：图书管理系统
项目实现的内容：
1.用户登录、用户注册、登录界面验证码功能。
2.退出登录功能、内容查看、内容添加、内容修改。
前端页面设计得有点可能不太专业，将就着用。主要专注在功能的实现。
内容页
添加内容
删除内容
修改内容
具体实现步骤 根目录布置： 1.登录界面实现 具体步骤参照文章：
PHP+MySQL制作简单的用户注册登录界面（注释超详细~附源代码）_Tsing X的博客-CSDN博客
2.内容页实现 *注意，请完成登录界面后再进行后续操作
1.1创建index.html 用于显示内容页
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;图书管理系统&lt;/title&gt; &lt;link rel="stylesheet" href="../css/style.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="top"&gt; &lt;div class="title"&gt;图书管理系统&lt;/div&gt; &lt;div class="nav"&gt; &lt;a href="../add.php"&gt;添加图书&lt;/a&gt; &lt;a href="../logout.php"&gt;退出登录&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="main"&gt; &lt;table class="lib-list"&gt; &lt;tr&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th width="200"&gt;作者&lt;/th&gt; &lt;th width="200"&gt;国家&lt;/th&gt; &lt;th width="200"&gt;图书编号&lt;/th&gt; &lt;th width="250"&gt;入库时间&lt;/th&gt; &lt;th width="200"&gt;操作&lt;/th&gt; &lt;/tr&gt;	&lt;?php foreach($data as $v): ?&gt; &lt;tr&gt; &lt;td class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b7dbcc2542bab03879b52432c2bcc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57bf99176f9896dbe93b3a99e8d78e1/" rel="bookmark">
			SQL Server 中 RAISERROR 的用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server 中 RAISERROR 的用法详解 大家好，我是免费搭建查券返利机器人赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！今天，我们将深入研究SQL Server数据库中的一个强大而常用的错误处理工具——RAISEERROR，了解其详细用法和在实际开发中的应用。
1. RAISEERROR的背景 在SQL Server中，RAISEERROR是一种用于生成错误消息并返回其错误号的机制。通过合理使用RAISEERROR，可以更好地处理错误，提高数据库的稳定性和可靠性。
2. RAISEERROR的基本语法 RAISEERROR (message_string, severity, state) message_string: 错误消息的文本，可以是字符串常量或变量。severity: 错误的严重程度，范围为0到25。级别0-10表示信息性消息，11-16表示警告，17-25表示错误。state: 错误状态的整数，范围为0到255。 3. RAISEERROR的使用案例 DECLARE @ErrorMessage NVARCHAR(4000) = N'An error occurred.'; DECLARE @ErrorSeverity INT = 16; DECLARE @ErrorState INT = 1; -- 使用 RAISEERROR 抛出错误 RAISEERROR (@ErrorMessage, @ErrorSeverity, @ErrorState); 上述案例中，当执行到RAISEERROR语句时，将会抛出一个错误，错误消息为"An error occurred."，错误级别为16，错误状态为1。
4. 使用RAISEERROR进行错误信息定制 RAISEERROR允许开发者定制错误消息，提高错误信息的可读性和对问题的定位。下面是一个使用动态消息的例子：
DECLARE @ProductName NVARCHAR(50) = 'ProductABC'; DECLARE @ErrorMessage NVARCHAR(4000) = N'Product ' + @ProductName + ' not found.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d57bf99176f9896dbe93b3a99e8d78e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79d214d95c13547e91f521000ac7dfd0/" rel="bookmark">
			【好书推荐-第二期】《实战AI大模型 》：带你走进大模型GPTs、AIGC的世界（李开复、周鸿祎、颜水成倾力推荐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😎 作者介绍：我是程序员洲洲，一个热爱写作的非著名程序员。CSDN全栈优质领域创作者、华为云博客社区云享专家、阿里云博客社区专家博主、前后端开发、人工智能研究生。公粽号：程序员洲洲。
🎈 本文专栏：本文收录于洲洲的《送书福利》系列专栏，该专栏福利多多，只需 关注+点赞+收藏 三连即可参与送书活动！欢迎大家关注本专栏~专栏一键跳转
🤓 同时欢迎大家关注其他专栏，我将分享Web前后端开发、人工智能、机器学习、深度学习从0到1系列文章。
🌼 同时洲洲已经建立了程序员技术交流群，如果您感兴趣，可以私信我加入我的社群~社群中将不定时分享各类福利
🖥 随时欢迎您跟我沟通，一起交流，一起成长、进步！点此即可获得联系方式~
本文目录 一、大模型简介二、大模型领域三、著名的大模型四、推荐好书：《实战AI大模型》五、抽奖方式总结 一、大模型简介 这两年，大模型扮演着科技和人工智能领域中的关键角色，在各行各业中都已经如日中天，例如爆火的ChatGPT3.5、GPT4等等。
大模型是指在机器学习和深度学习领域中，具有大规模参数和复杂结构的模型。这类模型通常包含大量的神经元和层次结构，使得其能够处理高维度的输入数据，并在训练过程中学习到更为抽象和复杂的特征。以下是大模型的一些主要特征：
深度（Depth）： 大模型通常具有深层次的结构，包含多个隐藏层，使其能够从数据中学习到更复杂的表示和模式。宽度（Width）： 大模型的宽度指的是网络中每一层中神经元的数量。较大的宽度有助于提高模型的表示能力，使其能够学到更为详细和具体的特征。参数数量：
大模型拥有巨大数量的参数，这些参数用于在训练过程中调整模型以适应输入数据。较多的参数提供了更大的拟合能力，但也带来了计算和存储的挑战。计算能力： 由于大模型通常需要处理大量的数据和参数，因此需要强大的计算能力来加速训练和推理过程。这促使了对于高性能硬件和并行计算的需求。 二、大模型领域 大模型在各个领域的广泛应用展示了其强大的学习和表示能力，这里洲洲给大家举例一些常见的领域：
自然语言处理（NLP） 大模型在NLP领域中的应用引起了广泛关注。其中最为突出的例子之一是BERT（Bidirectional
Encoder Representations from Transformers），这是一种基于Transformer结构的预训练模型。BERT在理解上下文相关性和语义关系方面取得了巨大成功，成为众多NLP任务的重要基石，包括情感分析、问答系统、语言生成等。计算机视觉（CV） 在计算机视觉领域，大模型通过深度学习技术在图像识别、物体检测、图像生成等任务中展现出色表现。例如，大型卷积神经网络（CNNs）如ResNet和Inception在图像分类中取得了卓越的成绩。此外，生成对抗网络（GANs）等大模型也在图像生成和风格迁移等方面取得了显著进展。强化学习在强化学习领域，大模型的应用使得智能体能够更好地理解环境和制定复杂的决策。深度强化学习方法，如深度Q网络（DQN）和深度确定性策略梯度（DDPG），采用大型神经网络作为函数近似器，实现了在复杂环境中的高效学习。跨领域应用除了上述主要领域，大模型还在交叉领域中取得了卓越成就，例如医学影像分析、自动驾驶、金融预测等。大模型的通用性和适应性使其成为解决各种现实世界问题的有力工具。 三、著名的大模型 BERT（Bidirectional Encoder Representations from Transformers） BERT 是一种预训练的自然语言处理模型，由Google提出。与传统的从左到右阅读文本的模型不同，BERT 通过同时考虑句子中左右两个方向的上下文，有效地捕捉到了双向的语义关系。BERT 在多项自然语言处理任务上刷新了记录，包括问答、文本分类、语言生成等。其模型结构基于Transformer，具有可扩展性，使其能够适应不同规模的任务。
GPT（Generative Pre-trained Transformer） GPT 系列是由OpenAI提出的一系列基于Transformer结构的生成模型。GPT 利用预训练策略，通过大规模语料库的无监督学习，在生成文本的任务中表现卓越。其中，GPT-3是目前最大的模型，拥有数万亿的参数。GPT-3不仅在自然语言处理任务中表现出色，还在代码生成、图像生成等领域展现了强大的泛化能力，显示出大模型在多个任务上的通用性。
四、推荐好书：《实战AI大模型》 讲到这里，我给各位铁铁推荐一本经典好书：《实战AI大模型》。
《实战AI大模型》详细介绍了从基本概念到实践技巧的诸多内容，全方位解读AI大模型，循序渐进、由浅入深。书中配有二维码视频，使读者身临其境，迅速、深入地掌握各种经验和技巧。本书还附带了丰富的额外资源：开源工具和库、数据集和模型案例研究和实际应用、在线交流社区等。读者可以综合利用这些资源，获得更丰富的学习体验，加速自己的学习和成长。
《实战AI大模型》是一本旨在填补人工智能（AI）领域（特别是AI大模型）理论与实践之间鸿沟的实用手册。书中介绍了AI大模型的基础知识和关键技术，如Transformer、BERT、ALBERT、T5、GPT系列、InstructGPT、ChatGPT、GPT 4、PaLM和视觉模型等，并详细解释了这些模型的技术原理、实际应用以及高性能计算（HPC）技术的使用，如并行计算和内存优化。
同时，《实战AI大模型》还提供了实践案例，详细介绍了如何使用Colossal AI训练各种模型。无论是人工智能初学者还是经验丰富的实践者，都能从本书学到实用的知识和技能，从而在迅速发展的AI领域中找到适合自己的方向。
除此之外，本书还获得了许多业界大佬的鼎力推荐：
五、抽奖方式 抽奖送书老规矩（不点赞收藏中奖无效）：注意记得关注博主及时获取中奖通知。
1. 点赞+收藏 文章 2. 评论区留言：我要成为架构师（留言才能进入奖池，每人最多留言三条） 3. 2024年1月10日-周3晚八点随机抽奖3人 4. 京东自营购买链接：https://item.jd.com/14281522.html 总结 Hello，各位铁铁好，洲洲已经建立了CSDN技术交流群，如果你很感兴趣，可以私信我加入我的社群。
📝社群中不定时会有很多活动，例如每周都会包邮免费送一些技术书籍及精美礼品、学习资料分享、大厂面经分享、技术讨论、行业大佬创业杂谈等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79d214d95c13547e91f521000ac7dfd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287b5f290e99bfdcaf9a521e082739d8/" rel="bookmark">
			大数据Hadoop、HDFS、Hive、HBASE、Spark、Flume、Kafka、Storm、SparkStreaming这些概念你是否能理清？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Hadoop Hadoop是大数据开发的重要框架，是一个由Apache基金会所开发的分布式系统基础架构，其核心是HDFS和MapReduce，HDFS为海量的数据提供了存储，MapReduce为海量的数据提供了计算，在Hadoop2.x时 代，增加 了Yarn，Yarn只负责资 源 的 调 度。
目前hadoop包括hdfs、mapreduce、yarn、核心组件。hdfs用于存储，mapreduce用于计算,yarn用于资源管理。
2 HDFS HDFS是什么？
Hadoop Distributed File System：分步式文件系统
源自于Google的GFS论文，发表于2003年10月，HDFS是GFS克隆版
HDFS是Hadoop体系中数据存储管理的基础
通过流式数据访问，提供高吞吐量应用程序数据访问功能，适合带有大型数据集的应用程序
提供一次写入多次读取的机制，数据以块的形式，同时分布在集群不同物理机器上
高度容错性的系统，能检测和应对硬件故障，用于在低成本的通用硬件上运行
3.Hive hive是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。hive数据仓库工具，计算基于MapReduce或Spark，能将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行。Hive的优点是学习成本低，可以通过类似SQL语句实现快速MapReduce统计，使MapReduce变得更加简单，而不必开发专门的MapReduce应用程序。
4 HBase HBase 是一个面向列式存储的分布式数据库，其设计思想来源于 Google 的 BigTable 论文。HBase 底层存储基于 HDFS 实现，集群的管理基于 ZooKeeper 实现。HBase良好的分布式架构设计为海量数据的快速存储、随机访问提供了可能，基于数据副本机制和分区机制可以轻松实现在线扩容、缩容和数据容灾，是大数据领域中 Key-Value 数据结构存储最常用的数据库方案。
一句话，HBase是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统.
5 Spark Spark是一个分布式计算框架，是由Scala语言编写完成的，是apache基金会下的顶级开源项目 ，和Mapresuce的作用一样，可以完成对数据的计算。
Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。Spark是UC Berkeley AMP lab (加州大学伯克利分校的AMP实验室)所开源的类Hadoop MapReduce的通用并行框架，Spark，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是——Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法,可用来构建大型的、低延迟的数据分析应用程序。。
Spark 是一种与 Hadoop 相似的开源集群计算环境，但是两者之间还存在一些不同之处，这些有用的不同之处使 Spark 在某些工作负载方面表现得更加优越，换句话说，Spark 启用了内存分布数据集，除了能够提供交互式查询外，它还可以优化迭代工作负载。
Spark 是在 Scala 语言中实现的，它将 Scala 用作其应用程序框架。与 Hadoop 不同，Spark 和 Scala 能够紧密集成，其中的 Scala 可以像操作本地集合对象一样轻松地操作分布式数据集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/287b5f290e99bfdcaf9a521e082739d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0620a16e201f079883e3c734f8adb1f5/" rel="bookmark">
			【AIGC工具】我找到了使用大模型问答的最短路径！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是豆小匠~
好久没介绍提高效率的工具啦，这次来介绍一个UTools的骚操作，可以极速打开LLM进行提问！
完成后的效果是：
快捷键调出输入框；2. 输入问题；3. 选择模型；4. 回车提问 这个流程可以大大减少软件切换，打开网站等操作造成的思维打断感。
下面从UTools安装开始介绍，已经安装的同学可以跳到第二步，打开AI对话快开开关！
第一步：安装UTools 简单介绍下UTools，可以理解为一个电脑端的插件平台，类似微信小程序的思想，用完即走。
UTools下载地址：https://www.u.tools
这里UTools主要是提供功能底座，我们在这个基础上安装插件，然后通过UTools入口实现快速打开LLM网站提问的功能。
第二步：打开AI对话开关 安装好UTools后，打开输入框的快捷键默认是Alt + 空格键（Mac是Option + 空格键）
按照下图所示，在输入框里输入【插件应用市场】，打开后搜索【网页快开】插件进行安装即可。
这个插件是UTools官方开发的，AI对话也依赖了官方提供的UBrowser能力。
安装完插件，在UTools输入框输入【网页快开】，打开AI对话开关！
目前网页快开支持的AI对话快开平台有文心一言、通义千问、ChatGPT、Claude、Copilot、豆包、讯飞星火等，打开平时常用的即可。
第三步：快速提问LLM大模型 好了，现在所有前置步骤都完成了，我们来看看提问大模型的效果：
唤醒输入框后，输入文字，UTools显示已经打开AI对话开关的大模型平台↓↓↓
选择需要提问的大模型后，回车或者点击，UTools会自动把我们在输入框的输入发送到大模型，然后获得和网页端一致的体验。
这期就喵到这里啦！大家伙帮忙点个赞~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af2c2e5aceb2c954320058f1a5b6ee2/" rel="bookmark">
			mac环境下安装python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查看当前mac上的python版本
-首先打开终端
1.打开后输入python3确定电脑上是否已安装python3，如果输入python是查看mac上的自带版本
命令：python3【直接回车】
出现下面是页面，表示已经安装python3 【退出时可输入：exit（）然后点回车】
如果出现下面页面，表示还不存在python3哦（我电脑已经安装啦。所以只能用代码形式展示）
二、安装python3
1.第一种方法brew 安装python3：brew install python32.第二种方法官网下载【链接: Python Releases for macOS | Python.org.】根据自己的需求下载自己需要的版本 三、安装pip
pip介绍：pip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能。
如果你在 python.org 下载最新版本的安装包，则是已经自带了该工具。
Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。
————————————————
1.查看pip是否安装 终端输入：pip --version【python2版本的命令】 pip3 --version【python3版本的命令】
如下图是已经成功安装pip的状态
出现下面是页面，表示没有安装pip3
2.安装pip3
终端输入命令：
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 下载安装脚本
sudo python3 get-pip.py # 运行安装脚本
注意：用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本。一般情况 pip 对应的是 Python 2.7，pip3 对应的是 Python 3.x。
3.pip3常用命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af2c2e5aceb2c954320058f1a5b6ee2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7967f7370438e9b4fad392e99ba9d8ff/" rel="bookmark">
			Android AndServer本地服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.AndServer简介 官方文档：https://github.com/yanzhenjie/AndServer AndServer 是一个 HTTP 和反向代理服务器。Android平台的Web服务器和Web框架。它提供了像SpringMVC一样的注解，如果你熟悉SpringMVC，你可以很快掌握它。
1.web网站部署。 2.动态http api部署。 3.反向代理服务器。 2.AndServer使用 1.项目使用依赖添加 App目录 build.gradle，如果您使用的是 Kotlin，请替换annotationProcessor为kapt.
plugins { id 'com.android.application' } apply plugin: 'com.yanzhenjie.andserver' ...
...
dependencies { implementation 'com.yanzhenjie.andserver:api:2.1.12' annotationProcessor 'com.yanzhenjie.andserver:processor:2.1.12' } project build.gradle中 buildscript { dependencies { classpath 'com.yanzhenjie.andserver:plugin:2.1.12' } } 2. web网站部署。 web项目文件位置设置，比如vue3，导出dist文件，并放在如下位置，并在AppConfig中配置该位置目录。 @Config public class AppConfig implements WebConfig { @Override public void onConfig(Context context, Delegate delegate) { // 增加一个位于assets的web目录的网站 delegate.addWebsite(new AssetsWebsite(context, "/dist/")); // 增加一个位于/sdcard/Download/AndServer/目录的网站 // delegate.addWebsite(new StorageWebsite(context, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7967f7370438e9b4fad392e99ba9d8ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735bd4bcfd252f704e0fe98a8cb2bad0/" rel="bookmark">
			Mysql为什么只能支持2000w左右的数据量？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明一下：
MySQL并没有硬性规定只能支持到2000万左右的数据量。
其实，MySQL能够处理的数据量远远超过这个数字。无论是开源社区版还是商业版，
MySQL在适当的硬件和配置下，都能够支持非常大的数据集。
通常所说的“MySQL只能支持2000万左右的数据量”，是在谈论具体的一些使用场景时大概的估算值，
受到某些配置、硬件资源或设计上的限制。在这些情况下，MySQL的性能可能会遇到瓶颈。
这些瓶颈可能来自于硬件限制、表结构设计、配置不当、查询优化、并发处理等。
2000万的数据量是如何估算的？ 这里就不得提及数据库索引的构建，以及InnoDB存储引擎的结构和它是如何存储数据与索引的了。
索引的构建 索引是数据库中的一个数据结构，可以帮助快速定位到表中特定行的记录，就像书的目录能帮助你快速找到某个主题的章节一样。在MySQL的InnoDB存储引擎中，索引通常是使用B-Tree（具体来说是B+Tree）数据结构来构建的。
构建索引的过程如下：
选择索引列：通常，你会为表中的主键、经常用于查询条件（WHERE子句）的列、经常参与连接操作的列（JOIN条件）或者是经常需要排序和分组的列（ORDER BY、GROUP BY子句）创建索引。确定索引类型：可以是单列索引，也可以是多列组合索引。组合索引考虑列的顺序，这会影响其效率。创建索引：使用SQL语句CREATE INDEX或者在创建表的时候直接定义。InnoDB处理索引：InnoDB存储引擎会在后台创建并维护相应的B+Tree结构，每个索引都会对应一棵B+Tree。 InnoDB的结构 InnoDB是MySQL的默认存储引擎，它支持事务、行级锁定和外键。它的主要结构包括：
表空间（Tablespace）：InnoDB使用表空间来存储数据和索引。表空间可以是单个文件（file-per-table模式）也可以是共享的（如ibdata文件）。数据页（Data Page）：InnoDB将数据存储在页中，通常大小为16KB。数据页按行记录组织。B+Tree索引结构：这种索引结构有几个特点——平衡的树形结构，所有的叶子节点都在同一层，叶子节点之间是双向链表，叶子节点包含所有数据信息。 InnoDB如何存储数据与索引 在InnoDB中，表数据本身就是按照主键顺序存储的，这种结构被称为聚簇索引（Clustered Index）。每张表的聚簇索引是其主键索引，意味着表数据都存放在主键索引的B+Tree结构中的叶子节点上。如果表没有显式的主键，InnoDB会选择一个唯一索引代替；如果没有唯一索引，InnoDB会自动生成一个隐藏的row ID来作为主键。
对于非主键索引（也称为二级索引或辅助索引），叶子节点不直接存储行数据，而是存储相应行的主键值。当通过辅助索引查找数据时，会先在辅助索引的B+Tree中找到主键，然后再通过主键在聚簇索引中检索实际的行数据。
索引与2000万数据的关系 索引可以显著提高查询效率，尤其是在数据量大的表中。
但同时，索引也占用磁盘空间，并且在插入、更新和删除操作时需要额外的维护成本，因为不仅是数据本身，索引也需要相应地更新。
在数据库设计中，特别是当涉及到大量数据的时候，考虑B+树索引的层数是非常重要的。主键列被广泛使用bigint类型，这主要是因为bigint类型的整数范围很大（从-263到263-1），
能够支持极大量的数据行，这对于有大量数据的系统来说非常有用。
B+树索引层数的影响 B+树索引的层数决定了查询需要多少次磁盘I/O操作才能找到指定的数据。
理论上，B+树的每增加一层，就能够索引更多的数据，但同时也意味着访问数据时需要更多的磁盘访问次数。
因此，数据库系统通常尽可能地减少这些层数。
如何估算B+树索引的层数 假设我们使用的是InnoDB存储引擎，一个页（Page）默认是16KB大小，而一个bigint类型的索引大约需要8字节（实际上可能更多一点，因为还包括了页的指针，假设为14字节）。我们可以大概估算一下：
首先算每个叶子结点能够存储的数据量（假设每条数据1k，那么每个page能存储16条，非叶子节点的上一层节点数 = 数据量 / 16）然后，假设每个非叶子节点存储的节点数量是 x，那么第一层就是 x = 16384 / 14；第二层就是，x的平方，三层就是x的三次方，以此类推计算值与非叶子节点的上一层节点数比较即可得到层数 为何MySQL建议树的层数不超过三层？ B+树的层数建议限制在3层以内，主要是基于性能的考虑。当B+树的层数增加时，每次查询数据所需的磁盘I/O次数也会增加，因为每一层都可能涉及到一次磁盘I/O（尽管数据库的缓存机制可以减少这种情况发生的频率）。磁盘I/O通常比CPU计算和内存访问要慢得多，因此，为了维持数据库查询的高性能，建议尽量减少层数。
现在我们来估算一下三层B+树能存放多少索引条目。以InnoDB存储引擎为例，它的默认页大小是16KB（16384字节）。
我们假设现在数据库中的每一条数据为1k，每个索引条目大小为14字节（如果包含事务ID和回滚指针的话），
那么每个数据页假设存储16条数据。
下面是计算过程：
第一层：每个页可以存储的索引条目数为 16384 / 14 ≈ 1170 ，第一层有1170个叶子节点。第二层：如果第二层也是完全填满的，那么它可以索引 1170 * 1170 ≈ 1368900， 第一层有1368900个叶子节点。第三层（叶子节点）：同理，第三层可以索引 1368900 * 16 ≈ 21902400 条数据。 这里是以bigint类型举例，当使用的类型不同时，存储的索引量不同，而且还与每行的数据大小有关。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/735bd4bcfd252f704e0fe98a8cb2bad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06a2cd9839cea54c06964c5b72f48190/" rel="bookmark">
			大数据 - Doris系列《二》- Doris安装（亲测成功版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🐶2.1 安装前准备
🥙1.设置系统最大文件打开句柄数 ==&gt;启动一个程序的时候，打开文件的数量就是句柄数
🥙2.设置文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量
🥙3.时钟同步
🥙4.关闭交换分区（swap）
🐶2.2 安装FE
🐶2.3 安装BE
🐶2.4 BE向FE注册
🐶2.5 扩容和缩容（搭建集群）
🥙2.5.1 doris集群的扩容
🥙2.5.2 缩容
🐶2.1 安装前准备 Linux 操作系统版本需求
Linux 系统版本CentOS7.1 及以上Ubuntu16.04 及以上 软件需求
软件版本Java1.8 及以上GCC4.8.2 及以上 测试环境硬件配置需求
模块CPU内存磁盘网络实例数量Frontend8核+8GB+SSD 或 SATA，10GB+ *千兆网卡1Backend8核+16GB+SSD 或 SATA，50GB+ *千兆网卡1-3 * 生产环境硬件配置需求
模块CPU内存磁盘网络实例数量（最低要求）Frontend16核+64GB+SSD 或 RAID 卡，100GB+ *万兆网卡1-5 *Backend16核+64GB+SSD 或 SATA，100G+ *万兆网卡10-100 * 操作系统环境要求
🥙1.设置系统最大文件打开句柄数 ==&gt;启动一个程序的时候，打开文件的数量就是句柄数 doris要求在linux上面只要要打开65536的句柄数，doris才能正常运行。而linux默认打开的句柄数为1000.所以需要修改。
1.打开文件 security /sɪˈkjʊərəti/ vi /etc/security/limits.conf 2.在文件最后添加下面几行信息(注意* 也要复制进去) * soft nofile 65536 * hard nofile 65536 * soft nproc 65536 * hard nproc 65536 ulimit -n 65536 临时生效 修改完文件后需要重新启动虚拟机，重启永久生效 reboot 如果不修改这个句柄数大于等于60000，回头启动doris的be节点的时候就会报如下的错 如果报错：Please set the maximum number of open file descriptors to be 65536 using 'ulimit -n 65536'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06a2cd9839cea54c06964c5b72f48190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b6bf571ac6159d153f444d313854ea/" rel="bookmark">
			Copilot在PyCharm中可能遇到的问题及其解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尽管GitHub Copilot为PyCharm用户带来了诸多便利，但在实际使用过程中，部分开发者可能会遇到一些问题。下面是一个典型的场景及相应的解决方法： 问题描述：
在启用GitHub Copilot后，在编写Python代码时发现，虽然Copilot能够提供代码建议，但有时生成的代码片段并不完全符合项目需求，或者出现延迟、无法及时响应的情况。
具体问题案例：
开发者正在一个特定的遗留项目中工作，其中包含了大量自定义库和内部函数。当他们尝试利用Copilot补全某个复杂功能的实现时，插件提供的代码建议与项目实际情况存在偏差，甚至有时候无任何建议输出。
分析与解决方案：
上下文理解不足：由于Copilot基于GPT-3模型训练，它依赖于对已有公开代码的理解。如果项目中的自定义库或内部函数不在其学习范围内，Copilot可能无法准确预测出合适的代码。此时，可以考虑为这些自定义内容添加详细的文档注释，以便Copilot更好地理解和适应项目上下文。项目索引与同步： 确保已将项目关联至正确的GitHub账户，并且Copilot有权限访问项目源码。Copilot需要时间来索引项目的源代码，特别是对于大型项目，初次使用时可能需要等待一段时间才能提供有效的建议。如果项目有更新，确保通过Git同步到本地，并触发Copilot重新索引。 网络连接与性能优化： 检查开发环境的网络连接是否稳定，因为Copilot的部分功能需要在线处理。考虑优化IDE设置以减少资源消耗，比如调整内存分配给PyCharm以及Copilot插件，确保有足够的计算资源来实时处理和生成代码建议。 反馈与报告问题： 如果认为Copilot的行为不一致或提供了错误的建议，可以直接在Copilot插件界面内提交反馈。在GitHub上查找并查看相关issue，看看是否有类似问题的已知解决方案或官方回复。 总结来说，面对Copilot在PyCharm中可能出现的问题，用户应首先确保正确配置和使用该插件，同时根据实际情况调整项目结构和代码注释，增强AI助手对项目上下文的理解能力。对于技术性问题，则可通过排查网络、资源分配等因素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f6b0c4c84db6c4cf1945f743451c08/" rel="bookmark">
			Java的MVC架构中，controller层、service层、serviceImpl和mapper层的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.controller层 也被称为控制器，它是业务模块流程的控制中心。Controller负责接收页面传递过来的参数，然后将这些参数传给service进行处理。同时，controller还会接收service处理后的返回值，并将这些返回值再次传给页面。此外，controller还负责处理前端请求和响应，与前端进行交互，为前端提供接口。
@RestController @RequestMapping("/user") @Slf4j public class UserController { @Autowired private UserService userService; /** * 移动端用户登录 * @param map * @param session * @return */ @PostMapping("/login") public R&lt;User&gt; login(@RequestBody Map map, HttpSession session) { //获取用户手机号 String phone = map.get("phone").toString(); //获取验证码 String code = map.get("code").toString(); //获取session的验证码； Object sessionInCode = session.getAttribute(phone); if(sessionInCode != null &amp;&amp; sessionInCode.equals(code)) { //判断是不是新用户 LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); userLambdaQueryWrapper.eq(User::getPhone,phone); User user = userService.getOne(userLambdaQueryWrapper); if(user == null) { //说明是新用户 user = new User(); user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f6b0c4c84db6c4cf1945f743451c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b24f6d676bdffbcf174963ce9837e7/" rel="bookmark">
			Paragon NTFS for Mac 破解版 15.5 Mac读写NTFS硬盘必备软件（附激活序列号）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件介绍 Paragon NTFS for Mac 破解版 15.5.102 Mac读写NTFS硬盘必备软件 已通过小编安装运行测试 100%可以使用。
Paragon NTFS 15.5.106版。ntfs是一种由微软开发专属的用于Windows系统的限制级专用的文件系统，用于取代老式的FAT文件系统，Paragon NTFS 对FAT和HPFS作了若干改进，比如支持元数据，并且使用了高级数据结构，改善性能、可靠性和磁盘空间利用率，并提供了若干附加扩展功能。所以原生的macOS系统默认无法对NTFS格式的硬盘做编辑和写入操作的，从macOS 10.13 High Sierra、macOS 10.14 Mojave到最新的macOS 10.15 Catalina都不能对NTFS分区做写入操作。因此当我们把NTFS格式的移动硬盘接入到Mac电脑时，会发现只能读取文件但不能写入文件。Paragon NTFS for Mac 15.5.106版打破了该限制，可确保从macOS 10.13 High Sierra快速，轻松，安全地访问NTFS分区，而且具备完整的读取和写入权限。安装Paragon NTFS for Mac后，用户可以立即快速浏览内容并读取，编辑，复制或创建文件和文件夹。该驱动程序保证了Mac对NTFS文件系统的复杂读写支持，并提供了对macOS 10.13下任何NTFS分区的完全快速访问权限。 Paragon NTFS 15.5.102特征 前所未有的高NTFS性能。传输速率与本地HFS文件系统相同。熟悉的界面，类似于Apple的Disk Utility。菜单栏附加组件，可让您一键点击启用所有权并指定允许哪些用户访问每个新创建的文件或文件夹，以及他们的读/写/执行权限。如果您需要macOS调出您在选定卷上访问的每个文件，请节省上次访问时间。如果要立即进行Spotlight搜索，并且要查看有关已用空间的详细信息，请启用Spotlight索引：应用程序，音乐，视频，照片等占用了多少空间。如果您需要访问敏感数据而不修改任何文件，则以只读方式挂载。如果要手动控制对卷的访问，请不要自动安装。 信息 运行平台：Paragon：macOS 10.12 及以上，支持Intel以及M系列芯片；
支持语言：均支持简体中文，其中Paragon运行前注意事项为英文，软件界面为中文。
Paragon NTFS For Mac中文破解版下载安装与激活： 1、首先下载Paragon软件，然后解压「ParagonNTFSForMac_15.5.102-r.zip」安装包。
2、然后解压完毕安装即可。注意在最后需要给Paragon NTFS设置访问权限。
3、注意：安装完成Paragon软件后，接下来就是激活了，我们打开百度网盘提供的激活序列号（网盘地址见文章底部）进行激活即可无限期全功能的使用啦。
Paragon软件与激活序列号下载 Paragon安装包：https://souurl.cn/Y3geC5
Paragon激活序列号网盘地址：https://pan.baidu.com/s/1zX3DqXt-wsy510L1lDI7Xg （务必从本帖安装的Paragon安装包方可激活）
提取码：3bvd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6849ad90acbc5fde7c815ed9a811988c/" rel="bookmark">
			C&#43;&#43;大作业——公司员工信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.系统概述2. 系统环境1.1 软件环境1.2 硬件环境 3. 设计内容3.1 系统流程3.2功能模块及详细说明3.2.1设计框架3.2.2定义宏数据3.2.3类的应用3.2.4链表3.2.5二进制文件 4.测试内容5.源代码 1.系统概述 使用C++面向对象程序设计设计一个简易的公司员工信息管理系统，其中用到了：类的使用、数组、循环体、函数的调用、封装等内容。系统需要定义职工（Employee）类，其中包括工号、姓名、性别、电话、所在科室和工资等信息。实现如下基本功能：
（1）设计菜单实现功能选择；
（2）添加功能：输入人员信息，并保存到文件中；
（3）删除功能：输入人员编号实现删除，并保存到文件中；
（4）修改功能：输入人员编号及其他相关信息，实现修改并保存到文件中；
（5）查询功能：能够根据姓名精确查询人员信息；
（6）统计功能：根据科室分别统计每个科室员工的平均工资并输出结果；
2. 系统环境 1.1 软件环境 操作系统为Windows 10,工作软件为：Dev-c++ 5.11
1.2 硬件环境 系统类型: 64 位操作系统, 基于 x64 的处理器
3. 设计内容 3.1 系统流程 问题分析：
系统要求实现如下功能：
（1）系统后台
1.原有数据：利用二进制文件存储公司员工信息管理系统的原始数据，存储员工信息。
2.修改信息：在原有数据的基础上，有客户信息需要修改，需要二进制文件的读写操作进行存储和读取数据文件内的信息，并通过链表修改实现文件信息修改。
（2）系统前台
添加加职工信息
删除职工信息
修改职工信息
按姓名查询职工信息
按科室查询职工信息
按科室统计职工平均工资程序模块流程
查看文件中现有职工信息
退出职工信息管理系统
3.2功能模块及详细说明 功能结构图
3.2.1设计框架 利用循环语句及switch语句实现功能模块多次执行，代码如下：
void show() { int n; while (1) { menu_show(); cin &gt;&gt; n; switch (n) { case (0) : { exit(1); //退出职工工资管理系统 } case (1): { AddEmployee();//增加职工信息函数 break; } case (2): { DeleteEmployee();//删除职工信息函数 break; } case (3):{ UpdateEmployee();//修改职工信息函数 break; } case(4) :{ reseachStudentByName();// 按姓名查询职工信息函数 break; } case(5):{ reseachStudentByOffice();//按科室查询职工信息函数 break; } case (6) : { add();//按科室统计职工平均工资函数 break; } case(7):{ ap();//显示文件信息函数 break; } } } } 设计主菜单
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6849ad90acbc5fde7c815ed9a811988c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db449f7a46055de7a8a1e3a312f0e95/" rel="bookmark">
			Edge浏览器开启/关闭侧栏和找回Copilot&amp;Bing按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 Edge浏览器开启/关闭侧栏找回Copilot&amp;Bing按钮（正常使用其功能需要能够访问外网） Edge浏览器开启/关闭侧栏 打开Edge浏览器，通过快捷键 Ctrl + Shift + / 来开启/关闭侧栏。
找回Copilot&amp;Bing按钮（正常使用其功能需要能够访问外网） 从Edge Insider官网下载dev版的Edge浏览器。将Edge浏览器的语言切换为英文。重启Edge浏览器。注：在Edge浏览器侧栏出现Copilot&amp;Bing按钮后，可以将语言重新切换为中文。 如果以上操作仍然未生效，可尝试以下操作：
打开梯子能够访问外网。把浏览器的设置中的地区设置成美国。把微软账号的所在地区也设置成美国。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/536/">«</a>
	<span class="pagination__item pagination__item--current">537/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/538/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>