<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c194879fda184f6b30507775101b6b5/" rel="bookmark">
			【WEEK16】 【DAY2】 Dubbo and Zookeeper Integration Part 2【English Version】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.6.11 Tuesday
Following 【WEEK15】 【DAY4】Dubbo and Zookeeper Integration Part 1【English Version】
Contents 18. Dubbo and Zookeeper Integration18.3. Setting Up the Test Environment18.3.4. Installing dubbo-admin on Windows18.3.4.1. Download dubbo-admin18.3.4.2. Extract and Enter the Directory18.3.4.3. Package dubbo-admin in the Project Directory18.3.4.4. Execute dubbo-admin-0.0.1-SNAPSHOT.jar in dubbo-admin\target Directory 18.4. SpringBoot + Dubbo + Zookeeper18.4.1. Framework Setup18.4.1.1. Create an Empty Project Dubbo_zookeeper18.4.1.2. Create a New Module provider-server18.4.1.3. Create a New Module consumer-server 18.4.2. Modify provider-server (Service Provider)18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c194879fda184f6b30507775101b6b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d235c620b80c76e4a7776ffe967d972f/" rel="bookmark">
			搭建一个简单的深度神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引入所需要的库
二、制作数据集
三、搭建神经网络
四、训练网络
五、测试网络
本博客实验环境为jupyter
一、引入所需要的库 torch库是核心，其中torch.nn 提供了搭建网络所需的所有组件，nn即神经网络。matplotlib类似与matlab，其中pyplot用于进行数据可视化，如绘制图表、曲线等。%matplotlib inline: 这是IPython（Jupyter Notebook）的魔法命令，用于在Notebook中直接显示Matplotlib绘制的图表，而不是弹出一个新窗口显示。
import torch import torch.nn as nn import numpy as np import pandas as pd import matplotlib.pyplot as plt %matplotlib inline # 展示高清图 from matplotlib_inline import backend_inline #导入Matplotlib库中的backend_inline模块，用于控制图表的显示方式。 backend_inline.set_matplotlib_formats('svg') #设置Matplotlib图表的显示格式为SVG格式，SVG格式的图表在显示时具有高清晰度，适合用于展示精细的图形。 二、制作数据集 主要任务是读取数据集，划分为训练集和测试集，一定要随机划分。
读取的数据集中共760组数据，共8个输入特征，1个输出特征。
其中第一列是索引，从0开始，70%为训练集，30%为测试集。
#读取数据 df = pd.read_csv('Data.csv', index_col=0)#之前的pandas库中有介绍到，即df为读取后的对象，以第一列为索引 arr = df.values #转化为numpy数组 arr = arr.astype(np.float32)#转化为深度学习常用的单精度浮点类型 ts = torch.tensor(arr)#转化为张量tensor ts = ts.to('cuda')#送到cuda设备上即gpu上计算 # 划分训练集与测试集 train_size = int(len(ts) * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d235c620b80c76e4a7776ffe967d972f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f348641e6d7c91eb8557bd129d4c325/" rel="bookmark">
			用python把docx批量转为pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为保证转换质量，本文的方法是通过脚本和com技术调用office自带的程序进行转换的，因此需要电脑已经装有office。如果希望不装office也能用，则需要研究OpenXML技术，后面实在闲的慌（退休）再搞。
安装所需库 pip install comtypes 示例代码 # Copy from Yue Zhang import os import comtypes.client def convert_word_to_pdf(folder_path): word = comtypes.client.CreateObject("Word.Application") word.Visible = False for file in os.listdir(folder_path): if file.endswith(".docx") or file.endswith(".doc"): in_file = os.path.abspath(os.path.join(folder_path, file)) out_file = os.path.abspath(os.path.join(folder_path, file.replace(".docx", ".pdf").replace(".doc", ".pdf"))) doc = word.Documents.Open(in_file) doc.SaveAs(out_file, FileFormat=17) # 17 代表 PDF 格式 doc.Close() word.Quit() # 使用示例 folder_path = '存放docx或者doc文件的文件夹路径' convert_word_to_pdf(folder_path) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40aa0a16334e1958ecd5a3cdf7e781c/" rel="bookmark">
			Python酷库之旅-比翼双飞情侣库(01)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、xlrd库的由来
二、xlrd库优缺点
1、优点
1-1、支持多种Excel文件格式
1-2、高效性
1-3、开源性
1-4、简单易用
1-5、良好的兼容性
2、缺点
2-1、对.xlsx格式支持有限
2-2、功能相对单一
2-3、更新和维护频率低
2-4、依赖外部资源
三、xlrd库的版本说明
1、xlrd 1.2.0版本
2、xlrd 2.0.1版本
3、xlrd3(非官方名称)
四、如何学好xlrd库？
1、获取xlrd库的属性和方法
2、获取xlrd库的帮助信息
3、用法精讲
3-1、cellname函数
3-1-1、语法
3-1-2、参数
3-1-3、功能
3-1-4、返回值
3-1-5、说明
3-1-6、用法
3-2、cellnameabs函数
3-2-1、语法
3-2-2、参数
3-2-3、功能
3-2-4、返回值
3-2-5、说明
3-2-6、用法
3-3、colname函数
3-3-1、语法
3-3-2、参数
3-3-3、功能
3-3-4、返回值
3-3-5、说明
3-3-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、 博客个人主页
在Excel中，通常所说的“情侣键”并非官方术语，而是对某些常用且经常成对出现的快捷键的一种形象化的称呼。其中，最为人熟知和广泛使用的“情侣键”是“Ctrl+C”和“Ctrl+V”。
1、Ctrl+C：这个快捷键的作用是“拷贝”或“复制”。当你在Excel中选中某个单元格、一行、一列或整个工作表的内容后，按下Ctrl+C键，这些内容就会被复制到计算机的剪贴板中，等待下一步的粘贴操作。
2、Ctrl+V：这个快捷键的作用是“粘贴”。在你按下Ctrl+C键将内容复制到剪贴板后，可以通过按下Ctrl+V键将这些内容粘贴到Excel中的另一个位置，这两个操作经常是连续进行的，因此Ctrl+C和Ctrl+V就像一对“情侣”，总是成对出现。
除了这对常见的“情侣键”外，Excel中还有许多其他的快捷键可以帮助用户更高效地完成各种操作。然而，这些快捷键通常并没有像Ctrl+C和Ctrl+V那样形成特定的“情侣”关系。
然而，今天我不再展开介绍“情侣键”，而是要重点推介Python中的“情侣库”，即xlrd和xlwt两个第三方库。
一、xlrd库的由来 xlrd库是一种用于在Python中读取Excel文件的库，它的名称中的"xl"代表Excel，"rd"代表读取，其开发者是John Machin(注：库名字符拆分诠释，只是一种猜测)。
xlrd最初是在2005年开始开发的，是基于Python的开源项目(下载：xlrd库官网下载)。
由于Excel文件在数据处理和分析中的重要性，xlrd库填补了Python在处理Excel文件方面的空白，使得用户可以方便地在Python环境中读取Excel文件的内容，并进行进一步的数据操作和分析。
二、xlrd库优缺点 1、优点 1-1、支持多种Excel文件格式 xlrd库支持多种Excel文件格式，包括`.xls`和`.xlsx`(在旧版本中)，这使得无论数据存储在哪种格式的Excel文件中，用户都可以使用xlrd库来读取。
1-2、高效性 xlrd库使用C语言编写，因此其性能非常高，即使面对非常大的Excel文件，xlrd也可以快速地读取其中的数据。
1-3、开源性 xlrd是完全开源的，可以在GitHub等平台上找到其源代码，这使得任何人都可以根据自己的需求对其进行修改和扩展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40aa0a16334e1958ecd5a3cdf7e781c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f36f5cecddc754bec05e24feda5ce65/" rel="bookmark">
			3D开发工具HOOPS如何推动3D打印应用实现数据格式转换、模型可视化？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3D打印技术的发展已经彻底改变了制造业、医疗、建筑和设计等众多领域。这一技术的核心在于其能够将数字模型转化为实物，而这一过程需要强大的软件支持。在这一领域，HOOPS作为一种专业的图形软件开发工具，发挥着至关重要的作用。
本文将深入探讨HOOPS在3D打印系统开发中的重要性，具体体现在数据处理、模型可视化、跨平台支持和开发效率等方面。
HOOPS中文网http://techsoft3d.evget.com/
数据处理和转换
3D打印的关键在于能够准确地处理和转换复杂的三维数据。HOOPS提供了一套强大的工具HOOPS Exchange，可以有效地处理各种CAD（计算机辅助设计）和CAE（计算机辅助工程）数据格式。其支持多种文件格式，如STEP、IGES、STL等，使得不同设计软件之间的数据互通变得更加容易。
通过HOOPS的API，开发者可以轻松地读取、解析和转换三维模型数据。这不仅简化了数据预处理的步骤，还确保了数据转换的准确性和高效性。例如，在将CAD模型转换为3D打印所需的STL格式时，HOOPS能够确保几何数据的完整性和精度，从而避免打印过程中的错误。
高效的模型可视化
在3D打印系统的开发中，模型的可视化是一个不可或缺的环节。高效的可视化工具不仅能够帮助设计师直观地查看和修改模型，还能在打印前进行全面的检查，以发现潜在的问题。HOOPS提供了强大的3D可视化功能，支持实时渲染和动态交互。
HOOPS Commuicator图形引擎能够处理复杂的几何形状和大规模的数据集，并且具有高帧率的渲染性能。这对于需要处理高分辨率和精细细节的3D打印模型尤为重要。通过使用HOOPS，开发者可以创建一个交互式的可视化界面，允许用户进行旋转、缩放和剖切等操作，从而全面了解模型的结构和细节。
跨平台支持
现代3D打印系统需要在多种硬件和操作系统环境下运行，包括桌面电脑、移动设备和云端服务器。HOOPS提供了跨平台的开发支持，使得开发者可以编写一次代码并在多个平台上运行。这不仅提高了开发效率，还降低了维护成本。
HOOPS支持多种编程语言和开发环境，如C++、C#和JavaScript，适用于不同的开发需求。通过其统一的API接口，开发者可以轻松地将3D打印应用部署到Windows、MacOS、Linux、iOS和Android等平台上。此外，HOOPS还支持WebGL和HTML5，使得3D打印应用可以直接通过浏览器访问，从而实现更广泛的用户覆盖。
提高开发效率
开发一个功能齐全的3D打印系统通常需要大量的时间和资源。HOOPS通过提供丰富的功能库和工具，极大地简化了开发过程。其模块化设计允许开发者根据需要选择和集成特定的功能模块，而无需从头开始编写大量代码。
HOOPS还提供了详细的文档和示例代码，帮助开发者快速上手并解决常见问题。通过其社区支持和专业技术支持服务，开发者可以获得及时的帮助和指导，从而加速项目的开发进程。此外，HOOPS的定期更新和功能扩展确保了开发者能够利用最新的技术和最佳实践，从而保持竞争优势。
结论
总的来说，HOOPS在开发3D打印系统中扮演了重要的角色。其在数据处理、模型可视化、跨平台支持和提高开发效率等方面的优势，使得开发者能够创建更强大、更高效的3D打印应用。
随着3D打印技术的不断发展，HOOPS作为一种关键工具，将继续推动这一领域的创新和进步。通过利用HOOPS，开发者可以更好地应对复杂的技术挑战，实现从数字模型到实物打印的无缝转换，从而充分发挥3D打印技术的潜力。
申请HOOPS试用http://x7pfmmn259623uby.mikecrm.com/d7EBgIv如果您的企业目前也有3D数据格式转换、3D Web轻量化渲染的需求，欢迎联系我们~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f7753fc00025a613e08e34adea3524/" rel="bookmark">
			2024年从零学习AI和深度学习Transformer的路线图（非常详细）零基础入门到精通，收藏这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024 年学习 AI 路线图 最近AI大热，相关的研究层出不穷。
你想学习AI吗？但您不知道如何或从哪里开始？
人工智能和深度学习是发展的趋势：
Science 2023封面论文：ChatGPT缩小了人们在写作能力上的差距
Nature子刊Nature Machine Intelligence也已经上线近三年了，每年接收文章不到100篇，影响因子达到16.65，表示着Nature对人工智能方法的认可。
2023年下半年，华为、英伟达、谷歌的天气系统预报大模型展现了强大的实力和统治力…
然而对于普遍的非计算机专业的朋友来说，这些技术变得越来越难，越来越不好掌握了！以前我们还能说“站在巨人的肩膀上”，现在回过头来看，人工智能发展得太快，巨人的肩膀也站不住了！
为了逃离铺天盖地的代码copy，你必须亲自动手，从头开始编写算法，实现论文，并使用人工智能解决问题来完成有趣的项目。
写在前面 首先是代码，然后是理论。建议读者先看代码，后学理论~
我出于需要还是喜欢学习？
如果我要解决某件问题，我会广泛获取所需的信息、研究、理解它，然后采取行动。
例如，我的目标是复现最新的模型（如盘古模型），这涉及到从头开始编写 Transformer 代码以及在 GPU 上微调的技能。我现在做不到这一点，因为在我的知识，我的目标是填补这些空白。
或者你以 NLP 为重点；如果您正在寻找其他人工智能应用，例如计算机视觉或强化学习，可以在公众号下面发表评论或私信我，我会给你一些建议。
另外建议读者定期查看一些相关Kaggle竞赛，这里有下游任务的最新模型与得分；也建议读者注册X账号（Twitter），上面一些深度学习大牛会发布最新资讯；或者关注一些优质公众号。
目录 数学基础
工具
Python
Pytorch
机器学习
模型评估、算法学习
从头开始编写第一个程序
使用Pytorch和Scikit-Learn
深度学习
一本"鱼书"入门深度学习
计算机视觉
NLP
Transformer
多做竞赛
大模型
从零开始写Transformer
从零实施BERT和Transformer
深度了解Transformer相关模型
模型微调
数学基础 机器学习在很大程度上依赖于数学的三大支柱：线性代数、微积分、概率和统计学。每个都在使算法有效运行方面发挥着独特的作用。
**线性代数：**用于数据表示和操作的数学工具包，其中矩阵和向量构成算法解释和处理信息的语言
**微积分：**机器学习优化的引擎，使算法能够通过理解梯度和变化率来学习和改进。
**概率与统计：**不确定性下决策的基础，允许算法预测结果并通过随机性和可变性模型从数据中学习。
一般而言，大学学到的高数足够应对了，尤其是考研生。
额外推荐一本线性代数书：Introduction to Linear algebra [Introduction to Linear Algebra by Gilbert Strang.pdf](books/Introduction to Linear Algebra by Gilbert Strang.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1f7753fc00025a613e08e34adea3524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d3f391b863c19e37670d362e7e766c5/" rel="bookmark">
			vscode terminal git bash 运行异常卡顿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 在使用 VSCODE 时，在 git bash 终端中管理 Git
问题描述 在某一天的一个下午 git bash 运行 git 命令变的异常卡顿。让人难以忍受
原因分析： 观察 git bash 终端和之前的变化
在命令的签名多了一个浅蓝色的圆圈，点击后，如下图所示
从菜单中可以看到 vscode 嵌入了 对以下终端命令做了增强
Linux/macOS: bash, fish, pwsh, zshWindows: pwsh 解决方案： 在输入行中输入 terminal.integrated.shellIntegration.enabled 取消选中并重新打开git bash窗口即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50bcaa5a30c6a0b561edee54c4eb321d/" rel="bookmark">
			【WEB前端2024】3D智体编程：乔布斯3D纪念馆-第39课-时间通知-按秒刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【WEB前端2024】3D智体编程：乔布斯3D纪念馆-第39课-时间通知-按秒刷新 使用dtns.network德塔世界（开源的智体世界引擎），策划和设计《乔布斯超大型的开源3D纪念馆》的系列教程。dtns.network是一款主要由JavaScript编写的智体世界引擎（内嵌了three.js编辑器的定制版-支持以第一视角游览3D场馆），可以在浏览器和node.js、deno、electron上运行，它是一个跨平台的软件，支持多个操作系统使用！并且支持使用内置的poplang智体编程语言实现3D组件的智能化编程——语法超简单，一句话语法，人人轻松上手！
下面分为几步介绍，如何基于dtns.network智体世界引擎如何实现乔布斯3D纪念馆的碟状总部的时间通知的3D组件化按秒刷新。通过时间通知功能，可以实现后续的动态的3D场馆的交互式变化。例如用户操作影响3D场馆的场景显示、3D组件内容展现、实时互动效果显示等。可以充分的体现出3D智体编程的实时变更3D场景内容的能力。
同上一节，我们通过 . g 3 d o b j e c t t e x t u r e i m a g e s e t 实现了 3 D 组件的纹理贴图设置功能（可设置图片或文字贴图图片），并可使用 .g_3d_object_texture_image_set实现了3D组件的纹理贴图设置功能（可设置图片或文字贴图图片），并可使用 .g3​do​bjectt​exturei​mages​et实现了3D组件的纹理贴图设置功能（可设置图片或文字贴图图片），并可使用.g_3d_create_text_image实现将文字转为图片（base64编码），以便在纹理设置指令中使用它。
第一步：打开头榜页面，找到3D纪念馆xverse轻应用 注：找到标题为“3D纪念馆-密室逃脱”的xverse轻应用。
第二步：点击右上角…进入头榜编辑器 第三步：点击正面的“编辑xverse轻应用源码”，进入3D场馆编辑器 注：我们点击“视图”关闭玩家视角， 以便缩放3D场馆，移动视角到合适的位置（以便添加精灵3D组件）
第四步：在当前位置添加精灵3D组件（用于显示时间） 注：通过精灵3D组件显示时间的文字纹理，可以移动玩家视角到任意位置，精灵的贴图均面向玩家视角（保持文字能以正面方向看见！）
第五步：通过左上角的组件控制器移动时间通知3D组件至合适位置，并在右侧属性面板控制缩放为10：4：1（x-y-z轴） 注：在后续的poplang脚本控制文字纹理的生成时，规格也应该是10:4（x:y轴）
第六步：设置时间显示的精灵3D组件的贴图默认为一张图片 注：通过右侧的材质组件，设置纹理为一张图片（任意图片，但是不能为空）
第七步：点击属性面板右下角的“脚本”-新建，编辑poplang代码 注：使用了 . g 3 d c r e a t e t e x t i m a g e 生成了文字“时间字符串”的纹理图片（ b a s e 64 编码），并保存在 v a l 中。最后使用 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50bcaa5a30c6a0b561edee54c4eb321d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36bcf4388302ceb580e27a1b17ab2b4/" rel="bookmark">
			mysql安装报错unknown variable ‘mysqlx_port=0.0‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用mysql-installer-community-8.0.36.0.msi类似这种文件安装mysql 的时候，会遇到初始化数据库失败，查看log，如果是unknown variable 'mysqlx_port=0.0'.，可以试着这样解决 这里默认到了报错那一步了 1、删除data文件夹 安装那一步报错，直接关闭即可，打开c盘（默认安装在c盘，如果自己修改了路径，找对应的路径即可），如图
找到C:\ProgramData\MySQL\MySQL Server 8.0\下的data文件夹，直接删除
2、修改my.ini配置文件 然后修改同级目录下面的my.ini文件，修改mysqlx-port=0.0为mysqlx-port=33060
这里会出现不可以保存的情况，可以将my.ini复制到桌面，删除之前的my.ini，修改保存后再粘贴回来
3.重新初始化数据库 如果没有配置环境变量，
找到自己mysql安装目录的bin目录，在路径上面，清空输入cmd，输入这个命令
mysqld --defaults-file="C:\ProgramData\MySQL\MySQL Server 8.0\my.ini" --initialize-insecure
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3e9ac0bb8b07a5e3f0de4c3a1434e8/" rel="bookmark">
			Kafka 负载均衡挑战及解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自 Agoda Engineering，介绍了在实际应用中，如何应对 Kafka 负载均衡所遇到的各种挑战，并提出相应的解决思路。本文简要阐述了 Kafka 的并行性机制、常用的分区策略以及在实际操作中遇到的异构硬件、不均匀工作负载等问题。通过深入分析这些挑战，并提供具体的解决方案，本文旨在帮助读者更好地理解和应用 Kafka 的负载均衡技术，从而提高系统的整体性能和稳定性。
以下大部分内容翻译自原文 how-we-solve-load-balancing-challenges-in-apache-kafka，并已获得原作者同意。
思维导图 Kafka 并行性 Kafka 通过分区来实现并行性，如下图所示，生产者（Producer）产生的消息会按照一定的分区策略分配到多个分区（Partition）中，消费组中的每个消费者会分别负责消费其中的若干个分区。
分区策略：
轮询（Round Robin）：默认情况下，Kafka 使用轮询策略将消息均匀地分配到所有分区。哈希（Key Hashing）：如果消息有分区键，Kafka 会对键进行哈希计算，将消息分配到特定的分区。自定义分区策略：开发者可以实现自定义的分区器（Partitioner）逻辑，以满足特定需求。 如果要使用轮询或者哈希策略来达到“负载均衡”的目的，那么需要满足以下 2 个假设：
消费者拥有相同的处理能力，消息的工作量相等。 然而，在实践中，这些假设往往不成立。
现实挑战 1. 异构硬件 不同代的服务器硬件性能不同，导致处理速率存在差异。例如，使用不同代硬件进行处理的基准显示性能存在显着差异：
2. 每条 Kafka 消息的工作负载不均匀 下图显示了在一个时间窗口内到达的 12 条消息。在这里，生产者向该主题中的六个分区中的每一个发布两条消息。因此，每个 worker 消耗来自 2 个分区的数据，这意味着每个 worker 需要处理 4 条消息。
不同的消息可能需要不同的处理步骤集。例如，处理消息可能涉及调用第三方 HTTP 端点，并且不同的响应大小或延迟可能会影响处理速率。此外，对于涉及数据库操作的应用程序，其数据库查询的延迟可能会根据查询参数而波动，从而导致处理速率发生变化。
3. 过度配置问题 由于工作负载和处理效率不同，为了达到系统吞吐量的需求，可能会出现过度配置问题，从而导致资源浪费。
假设我们的高吞吐量和低吞吐量的处理速率分别为 20 msg/s 和 10 msg/s（根据表 1 中的数据进行简化）。使用两个较快的处理器和一个较慢的处理器，我们预计总容量为 20+20+10 = 50 条消息/秒。但是，当保持消息的循环分配时，我们无法达到此容量。下图显示了如果流量持续达到每秒 50 条消息时会发生什么情况。
从这个例子中我们可以看到，我们的处理器服务一次最多只能接受 30 条消息，以防止滞后并确保及时传递更新。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac3e9ac0bb8b07a5e3f0de4c3a1434e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63de9f712c67f471742615258d729433/" rel="bookmark">
			SpringBoot试题集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单选题 1、SpringBoot是在__基础上开发的（）?
A Spring 1.0
B Spring 2.0
C Spring 3.0
D Spring 4.0
2、关于启动SpringBoot的方式正确的是：（）
A 直接使用主程序启动类中的main方法启动
B 使用mvn 命令来启动
C 使用mvn编译，而后在class目录生成jar包，使用Java命令来启动
D 都对
3、使用SpringBoot作为我们的框架，连Tomcat都不用自己配置。Tomcat默认的端口是( )
A 8080
B 8085
C 8095
D 8888
4、SpringBoot中，在yml文件中配置属性，那么我们在Controller中可以使用属性来进行获取。( )
A @Parameter
B @Value
C @Component
D @Name
5、默认情况下SpringBoot使用__作为日志框架？（）
A Logback
B Logger
C sl4jback
D都不是
6、下列不是SpringBoot常用的starter有哪些?( )
A spring-xml-starter-
B spring-boot-starter-data-jpa
C spring-boot-starter-thymeleaf
D spring-boot-starter-web
7、下面哪个注解不是@SpringbootApplication包含的默认属性值：（ ）
A @SpringBootConfiguration
B @EnableAutoConfiguration
C @ComponentScan
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63de9f712c67f471742615258d729433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb5036a837719826e608699d8319beb/" rel="bookmark">
			从源码分析 vllm &#43; Ray 的分布式推理流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 随着 LLM 模型越来越大，单 GPU 已经无法加载一个模型。以 Qwen-14B-Chat 模型为例，模型权重大概 28GB，但是单个 NVIDIA A10 仅有 24GB 显存。如果想要在 A10 上部署 Qwen-14B-Chat 模型，我们需要将模型切分后部署到 2 个 A10 机器上，每个 A10 卡加载一半的模型，这种方式称之为分布式推理。
社区涌现了很多支持分布式推理的框架如 vllm、deepspeed-mii，rtp-llm 等。本文选取了 vllm 框架，从源码角度分析 vllm + Ray 如何实现 LLM 模型的分布式推理。
二、在 K8s 中部署 vllm 分布式推理应用 2.1 模型准备 下载 Qwen-14B-Chat 到 OSS 中，并在集群中创建对应的 pv，pvc。pvc 名称为 llm-model。
kubectl apply -f- &lt;&lt; EOFapiVersion: v1kind: Secretmetadata: name: oss-secretstringData: akId: ${your-accesskey-id} # 用于访问oss的AK akSecret: ${your-accesskey-secert} # 用于访问oss的SK---apiVersion: v1kind: PersistentVolumemetadata: name: llm-model labels: alicloud-pvname: llm-modelspec: capacity: storage: 30Gi accessModes: - ReadOnlyMany persistentVolumeReclaimPolicy: Retain csi: driver: ossplugin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb5036a837719826e608699d8319beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89440e4eea094ec132007fd61776e07b/" rel="bookmark">
			C&#43;&#43;中的备忘录模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
备忘录模式（Memento Pattern）
实际应用
文本编辑器的撤销功能
游戏角色状态保存和恢复
图形编辑器的撤销/重做功能
总结
备忘录模式（Memento Pattern） 备忘录模式是一种行为型设计模式，它允许在不破坏封装性的前提下捕获和恢复对象的内部状态。这个模式的主要目的是保存对象的某个状态，以便在适当的时候恢复对象到之前的状态。备忘录模式主要包含三个角色：
1. Originator：负责创建一个备忘录（Memento），用以记录当前的内部状态，并在需要时使用备忘录恢复内部状态。
2. Memento：备忘录，负责存储Originator的内部状态。
3. Caretaker：负责保存备忘录，但不能对备忘录的内容进行操作或检查。
实际应用 文本编辑器的撤销功能 -- 文本编辑器，支持撤销操作。
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; // Memento类，用于存储文本编辑器的状态 class Memento { private: std::string state; public: Memento(const std::string&amp; state) : state(state) {} std::string getState() const { return state; } }; // Originator类，表示文本编辑器 class TextEditor { private: std::string text; public: void write(const std::string&amp; words) { text += words; } std::string getText() const { return text; } Memento save() const { return Memento(text); } void restore(const Memento&amp; memento) { text = memento.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89440e4eea094ec132007fd61776e07b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38db9041f87df4c648cb5a1335dfe03/" rel="bookmark">
			Java 中的线程本地存储（ThreadLocal）机制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在并发编程中，我们经常需要确保某些数据在线程之间是隔离的，以避免多线程竞争带来的数据不一致问题。Java 提供了一种方便的机制来实现这种隔离，即 ThreadLocal。本篇博客将详细讲解 ThreadLocal 的工作原理、使用方法以及其在实际开发中的应用场景，并附带代码示例以帮助读者理解。
什么是 ThreadLocal？ ThreadLocal 是 Java 提供的一种线程局部变量，它为每个使用该变量的线程都提供了一个独立的副本，从而每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。简而言之，ThreadLocal 实现了线程级别的数据隔离，非常适用于在多线程环境下各线程需要拥有独立的变量副本的场景。
ThreadLocal 的基本用法 创建和使用 ThreadLocal 使用 ThreadLocal 非常简单，下面是一个基本的示例：
public class ThreadLocalExample { // 创建一个 ThreadLocal 实例 private static ThreadLocal&lt;Integer&gt; threadLocalValue = ThreadLocal.withInitial(() -&gt; 0); public static void main(String[] args) { // 创建两个线程 Thread thread1 = new Thread(new Task(), "Thread-1"); Thread thread2 = new Thread(new Task(), "Thread-2"); thread1.start(); thread2.start(); } static class Task implements Runnable { @Override public void run() { // 获取当前线程的 ThreadLocal 变量值 int value = threadLocalValue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38db9041f87df4c648cb5a1335dfe03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fede8fc5333af71c114ea7b68f8d3809/" rel="bookmark">
			AI大模型探索之路-实战篇：智能化IT领域搜索引擎的构建与初步实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 No.文章1AI大模型探索之路-实战篇：智能化IT领域搜索引擎的构建与初步实践2AI大模型探索之路-实战篇：智能化IT领域搜索引擎之GLM-4大模型技术的实践探索3AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（初步实践）4AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（函数封装）5AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（流程优化）6AI大模型探索之路-实战篇：智能化IT领域搜索引擎之github网站在线搜索7AI大模型探索之路-实战篇：智能化IT领域搜索引擎之HuggingFace网站在线搜索 目录 系列篇章💥前言一、总体概览1、需求分析2、技术方案 二、创建Google Cloud Search API（准备工作）1、Google Cloud 简介2、Custom Search API概述3、GoogleCloud平台注册4、创建项目5、启用API6、获取API密钥 三、创建Google Custom Search Engine（准备工作）1、可编程的搜索引擎简介2、创建自己的搜索引擎3、获取cx、配置环境变量 四、Google自定义搜索引擎使用测试1、页面搜索测试2、代码调用测试 结语 前言 在信息技术飞速发展的当下，对于专业知识的检索需求正呈现出前所未有的增长态势。为了应对这一挑战，本文将深入探讨如何巧妙地结合大型语言模型的功能调用能力与谷歌搜索引擎API的强大功能，共同打造一个专门针对IT领域的智能在线搜索平台。这个平台不仅能够为用户提供更为精准、高效的搜索结果，还将引领信息技术检索的新潮流，为专业人士带来更加便捷、智能的搜索体验。
一、总体概览 1、需求分析 在构建智能在线搜索平台的过程中，深入的需求分析是至关重要的一步。用户通过输入查询（Prompt）向大型语言模型提出知识性问题，这不仅是用户与系统交互的起点，也是整个搜索流程的核心。当用户提出问题时，我们首先会分析问题的性质和类型，以确定是否需要调用外部搜索引擎进行实时查询。
接下来，如果大型语言模型内置的知识库能够提供答案，则直接回应用户，这样可以大大缩短响应时间，提高搜索效率。然而，若内置知识库无法提供满意的答案，系统将自动触发外部搜索引擎的调用机制，进行实时查询。这一过程中，我们需要确保系统的自动判断逻辑准确无误，以便在内置知识库无法满足需求时，及时且准确地获取外部信息资源。
2、技术方案 本项目的技术核心由以下三部分组成：
1）利用GLM4大模型的函数调用（Funcation Calling）能力，实现智能调度和规划；
2）使用谷歌搜索引擎提供的API对特定技术平台进行爬取和搜索。
3）结合提示词Prompt的能力实现实现智能在线搜索。
在技术方案的实施过程中，我们首先利用GLM4大模型的函数调用能力，对用户的查询请求进行智能解析和规划。通过大模型的强大处理能力，我们能够准确理解用户的意图，并快速制定出相应的搜索策略。
随后，我们使用谷歌搜索引擎提供的API接口，对特定的技术平台进行深度爬取和搜索。谷歌搜索引擎作为全球领先的搜索引擎之一，其强大的搜索能力和海量的数据资源，为我们提供了丰富、准确的搜索结果。
最后，我们结合提示词Prompt的能力，进一步提升了搜索的智能化水平。通过精心设计的提示词，我们能够引导大模型更加精准地理解用户的搜索需求，并返回更为符合期望的结果。
二、创建Google Cloud Search API（准备工作） 1、Google Cloud 简介 Google Cloud，全称Google Cloud Platform（GCP），是Google提供的一系列云计算服务和API。它允许个人、企业和政府机构在Google的数据中心上运行其应用程序和存储数据。
2、Custom Search API概述 Google Cloud上的Custom Search API是Google提供的一项服务，允许开发者将Google的搜索功能集成到自己的应用程序中。这项服务特别适用于需要在特定数据集或网站上提供搜索功能的情况。以下是Custom Search API的一些关键特性：
自定义搜索引擎：用户可以创建一个搜索引擎，只搜索他们选择的网站或网页。编程访问：通过API，开发者可以以编程方式访问搜索结果，并将它们集成到自己的应用程序中。搜索结果定制：可以定制搜索结果的显示方式，包括排序、过滤和样式。搜索范围控制：可以指定搜索的范围，例如只搜索特定的网站或排除某些网站。安全性选项：包括成人内容过滤等安全搜索选项。使用限制和计费：Custom Search API可能有使用限制和计费要求，具体取决于使用量和功能。 3、GoogleCloud平台注册 登录GoogleCloud平台注册一个账号，有一定的免费额度可以使用；选择一个项目，开始新建项目
4、创建项目 新增一个项目名称“MyProject001”,地点可以选择无组织
5、启用API 创建完项目后，启用API和服务（必须启用Custom Search API才能取得凭证）
输入“google search”搜索，找到自定义搜索的API服务
启用自定义搜索的API服务
6、获取API密钥 创建凭证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fede8fc5333af71c114ea7b68f8d3809/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b500e7d3d759bae2a9a3b2718bc97c7/" rel="bookmark">
			【架构之路】微服务中常用的几种通信方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年，计算机相关专业还值得选择吗？ 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
引言 微服务架构由于其灵活性、高可扩展性和易维护性，已成为构建复杂系统的主流选择。
微服务架构将系统拆分为多个独立的服务，每个服务负责特定的功能，并通过各种通信方式进行协作。
这些通信方式在确保系统高效、可靠运行的过程中起着至关重要的作用。
本文将介绍几种常见的微服务通信方式，包括HTTP REST、gRPC、消息队列和WebSocket，并通过Java示例说明它们的应用场景和实现方法。
几种通信方式 在微服务架构中，服务之间的通信是关键组件之一。常见的通信方式包括HTTP REST、gRPC、消息队列、以及基于WebSocket的通信。下面举例说明这些通信方式。
1. HTTP REST HTTP REST是一种广泛使用的同步通信方式。每个微服务通过HTTP请求相互通信，通常使用JSON作为数据格式。
示例：
假设有两个微服务，一个用于用户管理（User Service），另一个用于订单管理（Order Service）。Order Service需要从User Service获取用户信息。
User Service:
@RestController @RequestMapping("/users") public class UserController { @GetMapping("/{id}") public ResponseEntity&lt;User&gt; getUserById(@PathVariable String id) { // 假设从数据库获取用户信息 User user = userService.findUserById(id); return ResponseEntity.ok(user); } } Order Service:
@Service public class UserServiceClient { private final RestTemplate restTemplate; @Autowired public UserServiceClient(RestTemplate restTemplate) { this.restTemplate = restTemplate; } public User getUserById(String userId) { String url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b500e7d3d759bae2a9a3b2718bc97c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e3779b30b629cfb1a11de8a63a618e/" rel="bookmark">
			先别吹sora，ComfyUI&#43;SVD才是你2024年必须掌握的ai视频工具！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		comfyui+svd最新教程，没玩过ai视频的你必须要了解！
这可能是你见过最适合小白的comfyui+svd入门教程！
一、comfyui的特点？ 很多人其实还不知道，目前市面上热门的ai视频工具有哪些？
Sora：Sora目前大家都使用不上，但它作为一个AI视频生成工具，提供了60s的视频内容创作功能。ComfyUI+svd：ComfyUI+svd目前在效果上优于Runway和Pika，它在视频生成的质量、用户界面的友好性上很突出。ComfyUI提供了易于理解的工作流，使得用户能够更直观地控制视频的生成过程。Runway：Runway是全球AI视频制作前沿模型，目前拥有30多个AI应用工具，包括视频抠图换背景、自动跟踪物体、智能字幕、智能音频节拍检测、消除噪音、在线协做编辑、文生图像、文生视频、图生视频等等。Pika：Pika是一个AI视频生成工具，它支持多种风格的视频生成，如3D动画、动漫、卡通和电影，并且具有强大的视频编辑功能，如画布延展、局部修改、视频时长拓展等 那么，comfyui到底比runway、pika牛在哪里？
1.显存占用更少，相较于传统的 WebUI，ComfyUI在相同显存条件下能够呈现更宏伟的图像。特别是在当前显存有限的情况下，使用WebUI探索SDXL显得颇具挑战。这或许是ComfyUI迎来第二春的核心原因所在。 2.上限更高，ComfyUI更适合处理复杂、长线的大规模工作，能够将传统WebUI中需要多步操作的流程巧妙整合于一个流畅的工作流之中。 3.工作流可轻松复用，ComfyUI能够保存已使用的工作流，方便下次使用相同流程时直接加载并实现快捷复用。 4.可玩性更为丰富，每个节点都可以安装所需加载，而且通过连线的流程式玩法，用户能够拥有更多探索的可能性。 comfyui生成视频的效果展示
comfyui生成视频的效果展示
所以，2024年你想学ai视频，一定要了解comfyui+svd的工作流！
二、新手小白如何启动comfyui？ 好，话不多说，首先打开我们的Comfyui云部署网站揽睿星舟，无需显卡，云端出图。
https://www.lanrui-ai.com/register?invitation_code=6817
新用户注册能免费使用2个小时，最近有充值优惠活动，更加划算一点。
1、创建工作空间 点击左侧【工作空间】-【创建工作空间】
选择显卡3090-24g（夜间还更便宜，适合晚上玩ai绘图和视频的朋友）
选择镜像-【comfyui】
网盘点击 【已挂载网盘】，数据集选择挂载【sd-base】
然后点击右下角的【立即创建】
稍微等一会儿，等左上角变成【运行中】，这个时候我们点击下方的【Jupyterlab】
在跳出来的界面中，选择【terminal】
2、启动comfyui 当我们打开terminal界面后，只需要输入以下命令，然后按回车键，等待1分钟左右
bash /home/user/start.sh 当你的界面上出现“To see the GUI go to: http://0.0.0.0:27777”，就说明启动成功了。
这个时候我们回到之前的工作空间，点击【打开调试地址】。
就成功进入到了comfyui的使用界面。
三、如何使用comfyui生成视频？ 揽睿星舟的很多模型都是自带的，所以很多不需要下载，直接用就可以。
1、如何导入工作流？ 打开comfyui官方网站：https://comfyanonymous.github.io/ComfyUI_examples/video/
你可以在这个网站先下载工作流文件：一般是一张图片，或者一个后缀名为json的文件。
然后点击右侧菜单栏中的【加载】来导入图片或者json文件。
然后就可以看到我们的工作流了。
揽睿家的很多节点也都是内置的，像我用的这个svd工作流，拖进去就可以用（有需要的可以直接戳我）
比如这里我们导入的是svd图生视频的工作流，点击【choose file to upload】，输入一张你想要转成视频的图片。
然后点击右侧的【添加提示词队列】
等待一会儿就可以生成我们的视频了。
2、哪里可以下载更多的工作流？ 如果你需要更多的工作流，可以在这几个社区下载。
https://openart.ai/home https://comfyworkflows.com/images 为了帮助大家更好地掌握 ComfyUI，我在去年花了几个月的时间，撰写并录制了一套ComfyUI的基础教程，共六篇。这套教程详细介绍了选择ComfyUI的理由、其优缺点、下载安装方法、模型与插件的安装、工作流节点和底层逻辑详解、遮罩修改重绘/Inpenting模块以及SDXL工作流手把手搭建。
由于篇幅原因，本文精选几个章节，详细版点击下方卡片免费领取
一、ComfyUI配置指南 报错指南
环境配置
脚本更新
后记
.......
二、ComfyUI基础入门 软件安装篇
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7e3779b30b629cfb1a11de8a63a618e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1af90361de00be940e6a3cfd68358a/" rel="bookmark">
			C# Web控件与数据感应之模板循环输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于模板循环输出
准备数据源
​范例运行环境
RepeatHtml 方法
设计与实现
如何获取模板内容
getOuterHtml 方法
getInnerHtml 方法
调用示例 小结
关于模板循环输出 数据感应也即数据捆绑，是一种动态的，Web控件与数据源之间的交互，模板循环输出 ，是指使用 UI 前端设计的 HTML 模板片断，并结合数据记录进行循环输出的过程，比如，有如下如图输出 ：
如图人员列表是一个循环输出的过程，我们按照图示设计模板，并结合数据查询结果即可，模板代码如下：
&lt;div id="pitemdetail" runat="server" class="query-box" onclick="waittip(this);window.location='answer.aspx?cid={wxmpCid}&amp;pid={cid}'" style="border-radius:5px; cursor:pointer; padding:10px; background-color:White; margin-bottom:10px"&gt; &lt;div style="display:flex;flex-direction:row; flex-wrap:wrap;justify-content:space-between; "&gt;&lt;label style="cursor:pointer; font-size:12pt; color:Gray; " &gt; &lt;b&gt;{name}&lt;/b&gt;&lt;/label&gt;{dtip}&lt;/div&gt; &lt;div style="width:100%; color:Silver; "&gt;{dname}&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;!-- pitemdetail --&gt; &lt;asp:Literal ID="result" runat="server"&gt;&lt;/asp:Literal&gt; 其中 id 为 pitemdetail 的 div 即为设计模板片断，其设计要点如下：
（1）需要添加 runat="server" 服务器标记
（2）输出的数据，用花括号和字段名表示，如代码中的 "{wxmpCid}","{name}" 。字段名可以用DataSet.Tables.Colums 里的序号进行表示，如 “{0}”，“{1}” ，用序号表示，性能会略有提升，但从代码易读性来讲相对较差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a1af90361de00be940e6a3cfd68358a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3851cc32a86fd0dba8a03ce994fb202/" rel="bookmark">
			机器学习-监督学习6大核心算法技术精讲与代码实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监督学习线性回归、逻辑回归、决策树、支持向量机、K近邻、朴素贝叶斯算法精讲，模型评估精讲
关注作者，复旦AI博士，分享AI领域与云服务领域全维度开发技术。拥有10+年互联网服务架构、AI产品研发经验、团队管理经验，同济本复旦硕博，复旦机器人智能实验室成员，国家级大学生赛事评审专家，发表多篇SCI核心期刊学术论文，阿里云认证的资深架构师，项目管理专业人士，上亿营收AI产品研发负责人。
目录 1. 介绍1.1 什么是监督学习监督学习的基本流程 1.2 监督学习与其他学习方法的比较无监督学习（Unsupervised Learning）强化学习（Reinforcement Learning） 1.3 监督学习的应用场景1.4 监督学习的挑战 2. 算法精讲2.1 线性回归2.1.1 线性回归简介2.1.2 线性回归的假设2.1.3 最小二乘法2.1.4 代码实现代码解释： 2.2 逻辑回归2.2.1 逻辑回归简介2.2.2 逻辑回归的假设2.2.3 逻辑回归的损失函数2.2.4 代码实现代码解释： 2.3 决策树2.3.1 决策树简介2.3.2 决策树构建过程2.3.3 纯净度指标2.3.4 决策树的优缺点2.3.5 代码实现代码解释：决策树剪枝2.3.6 决策树的应用场景 2.4 支持向量机2.4.1 支持向量机简介2.4.2 支持向量机的优化目标2.4.3 核函数2.4.4 支持向量机的优缺点2.4.5 代码实现代码解释：2.4.6 支持向量机的应用场景 2.5 K近邻2.5.1 K近邻简介2.5.2 距离度量2.5.3 选择K值2.5.4 K近邻的优缺点2.5.5 代码实现代码解释：2.5.6 K近邻的应用场景 监督学习精讲2. 常见算法2.6 朴素贝叶斯2.6.1 朴素贝叶斯简介2.6.2 朴素贝叶斯的类型2.6.3 朴素贝叶斯的优缺点2.6.4 代码实现代码解释：2.6.5 朴素贝叶斯的应用场景 监督学习精讲3. 模型评估与验证3.1 交叉验证3.1.1 K折交叉验证3.1.2 留一法交叉验证 3.2 过拟合与欠拟合3.2.1 过拟合3.2.2 欠拟合 3.3 混淆矩阵与分类报告3.4 ROC曲线与AUC代码示例代码解释： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3851cc32a86fd0dba8a03ce994fb202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69877bf78942de7cfac4cf8cb8970880/" rel="bookmark">
			【C&#43;&#43;】list 容器的增删改查---模拟实现（图例超详细解析！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、 list 容器的模拟实现思
✨ 模块分析
✨ 作用分析
三、list的节点类设计 四、list 的迭代器类设计
⭐ 迭代器类--存在的意义
⭐ 迭代器类--模拟实现
💦 模板参数 和 成员变量
💦 构造函数 💦 ++运算符的重载 💦 -- 运算符的重载
💦 重载 != 和 ==
💦 * 运算符的重载
💦 -&gt; 运算符的重载
💦 迭代器类 总体代码
五、list 结构的完善
🥝成员变量和模板参数 🍍 默认成员函数
⚡构造函数
⚡拷贝构造
⚡迭代器区间构造 ⚡n个相同元素构造 ⚡赋值重载 ⚡析构函数
🍇迭代器相关函数
⚡begin 和 end 🍓访问容器相关函数
⚡fron 和 back 🍑增删改查相关函数
⚡insert -- 插入
⚡erase
⚡push_back 和 pop_back
⚡push_front 和 pop_front
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69877bf78942de7cfac4cf8cb8970880/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/277/">«</a>
	<span class="pagination__item pagination__item--current">278/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/279/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>