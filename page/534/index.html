<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3d43027af5507c7a0536b189a6148c/" rel="bookmark">
			java 学生信息管理系统课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目简介
三、个人任务简述
四、本人负责功能详解
五、课程设计感想
六、展望
一、项目简介 1.功能描述：
学生基本信息管理系统
提供一个简单、方便的管理界面，帮助管理员高效地管理学生信息
1.1查询功能：根据学号、姓名，查询特定学生的信息。
1.2增加功能：输入新学生的所有信息，并将这些信息添加到系统文件中。
1.3删除功能：根据查询条件，删除满足条件的学生信息。
1.4修改功能：修改已存在学生的信息。
2.主要任务：
系统整体设计；编写学生信息管理系统的核心代码；
对系统进行功能测试，确保各个功能模块能够正常工作
功能架构图 图1-系统功能架构图
三、个人任务简述 1. 完成的任务与功能：
序号
完成功能与任务
描述
1
面向对象设计
使用了面向对象技术设计系统，将学生基本信息的八个组成部分封装成学生基本信息类，方便后续的增删改查工作。
2
GUI界面设计
使用了GUI图形界面，提高了系统交互性，使界面变得简洁大方更加美观，同时避免了传统命令行界面的繁琐操作，提高了工作效率。
3
学生基本信息的增删改查
采用数组的形式存放录入的学生信息，并进行增删改查。使用GUI事件处理，创建监听类实现相关功能
4
学生基本信息的保存
使用txt文件来进行数据持久化的操作
表1-个人任务简述表
四、本人负责功能详解 *面向对象设计 图3-StudentInformation类和StudentUI类的UML类图
图4-StudentListen类的uml类图
图5-包图
*StudentInformation类 2.1功能概述：
定义一个名为StudentInformation的类，代表学生信息
2.2使用技术
使用了Java编程语言中的面向对象编程（OOP）技术
2.3关键代码截图
图
图6-StudentInformation类关键代码截图
StudentUI类： 3.1功能概述：
创建一个图形用户界面（GUI），用于学生信息管理系统。
包括一个主窗口，一个面板用于显示操作相关的内容和五个按钮用于增删改查和保存学生信息。同时为每个按钮设置了事件监听器，以便在按钮被点击时执行相应的操作。
3.2使用技术：Java Swing
具体使用了以下Swing组件和技术：
- JFrame：创建应用程序的主窗口。
- JButton：创建可交互的按钮。
- JPanel：创建一个面板，用于组织其他组件。
- Color：设置组件的颜色。
- ActionListener：监听用户的动作事件
3.3关键代码截图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3d43027af5507c7a0536b189a6148c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfef79e0974862184180205525b3eb2/" rel="bookmark">
			JDBC如何连接SQL Server数据库实现增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、连接前准备
1. 环境配置
2. 下载JAR包
3. 添加环境变量
4. 导入JDBC包
二、连接SQL Server
三、实现增删改查
1. 查询数据
2. 添加数据
3. 修改数据
4. 删除数据
5. 拓展
JDBC的全称是Java数据库连接(Java DataBase Connectivity) ，应用程序通过JDBC连接到数据库，使用SQL语句对数据库中的表进行查询、增加、修改、删除等操作。此文章提供JDBC连接SQL Server的所有步骤，帮助大家实现Java对数据库的增删改查！
JDBC访问数据库的方式 一、连接前准备 1. 环境配置 我们右键点击“开始”菜单打开“计算机管理”，接下来以此打开树形菜单，启用所有协议。
下一步，打开控制面版—&gt;程序—&gt;程序与功能—&gt;启用或关闭Windows功能 —&gt;勾选 Telnet客户端
接下来，重启计算机，在此之前请务必点击“收藏”或“关注”，以免找不到下一步教程。
重启后，按Win+R，输入cmd后按回车，输入命令：
telnet localhost 1433 进入只有光标闪烁的空白页面即通信成功。
2. 下载JAR包 下面讲解的方法都是基于 IntelliJ IDEA 软件，如果是 Eclipse 会有细微差别。
首先，在连接JDBC之前，需要下载MS JDBC Driver包，下载地址：下载 Microsoft SQL Server JDBC 驱动程序https://learn.microsoft.com/zh-cn/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server
那么如何选择正确的JDBC呢？
请参照以下对应规则下载相应的JDBC驱动版本。
从 Microsoft JDBC Driver 12.2 for SQL Server 开始，支持 Java 开发工具包 (JDK) 19.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cfef79e0974862184180205525b3eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cfc2a82374522f3b221bb8e0695064/" rel="bookmark">
			Oracle-并集、交集、差集（union、union all、intersect、minus）的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 并集-union、union all举例-union举例-union all 交集-INTERSECT举例-intersect 差集-miuns举例-minus 并集-union、union all unoin 和 union all 主要作用是将两个或两个以上select语句的结果集进行并集操作。主要区别是，union 会对最后的结果集去重，union all 则会保留所有结果集（包含重复值）。
--union语法使用 select column1,column2,column1…… from table1 union select column1,column2,column1…… from table2; --union all语法使用 select column1,column2,column1…… from table1 union all select column1,column2,column1…… from table2; 在使用过程中有几点需要注意：
UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔。UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。如果结合UNION使用的SELECT语句遇到不同的列名,它会返回第一个列的名字。UNION会取消重复的行，UNION ALL则不去重，列出所有行。在用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后，DBMS将用它来排序所有SELECT语句返回的所有结果。 举例-union 这里举个简单的例子，如下图所示，将三个select语句的结果集进行union操作，重复的内容包含’a’、‘b’，最后结果会去重。
举例-union all 还是刚才的例子，前面两个select语句进行union操作，再和第三个select语句进行union all 操作。最后结果集会包含三个select语句的所有结果。
交集-INTERSECT intersect 和前面的 union、union all 恰好相反，intersect 是取多个结果集中的交叉集，即多个结果集里都存在的数据。
select column1,column2,column1…… from table1 intersect select column1,column2,column1…… from table2; 举例-intersect 现在有两个表 test_tab1 和 test_tab2 ,各自的结果集如下图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9cfc2a82374522f3b221bb8e0695064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d79854f25f0fa64346e62c33112d3d/" rel="bookmark">
			手把手教你调用文心一言API，含py调用示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取API密钥 打开网址：百度智能云千帆大模型 (baidu.com)
注册或登录账号
选择应用接入
创建应用
随便起个名字
点击显示即可。
这个API Key和Secret Key就是我们需要的。
Python调用示例 下面的例子是用文心一言批量回答问题。
输入长这样就行：
下面就是代码啦！
""" @author: HeroZhang（池塘春草梦） @contact:herozhang101@gmail.com @version: 1.0.0 @file: law_ques.py @time: 2024/1/11 16:25 @description: 调用文心一言api,实现批量回答问题 """ import json import pandas as pd import requests from tqdm import tqdm filename = "一列问题.CSV" # 格式：一列问题 filepath = "D:/gun/data/" API_KEY = "换成你的" SECRET_KEY = "换成你的" def ask_Q(question): url = "https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/completions?access_token=" + get_access_token() payload = json.dumps({ "messages": [ { "role": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d79854f25f0fa64346e62c33112d3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadf3b922f702983a5e3e15f09ac4ee3/" rel="bookmark">
			Qualcomm® AI Engine Direct 使用手册（20）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm® AI Engine Direct 使用手册（20） 7 转换器7.1 概述7.2 张量流转换7.2.1 模式匹配7.2.2 额外必需的参数7.2.3 有关 Tensorflow 2.x 支持的说明7.2.4 例子 7.3 TFLite 转换7.3.1 额外必需的参数 7.4 PyTorch 转换7.4.1 额外必需的参数7.4.2 例子 7.5 Onnx 转换7.6 自定义操作输出形状推断7.7 自定义输入/输出7.8 保留 I/O 7 转换器 7.1 概述 Qualcomm® AI Engine Direct目前支持四种框架的转换器：Tensorflow、TFLite、PyTorch 和 Onnx。每个转换器至少需要原始框架模型作为输入来生成 Qualcomm® AI Engine 直接模型。有关其他所需的输入，请参阅下面的框架特定部分。
每个转换器的流程是相同的：
转换器工作流程 每个转换器有四个主要部分：
前端翻译，负责将原始框架模型转换为通用中间表示（IR）
通用 IR 代码包含图形和 IR 操作定义以及可应用于翻译图形的各种图形优化。
量化器，可以选择调用它来在最终降低为 QNN 之前量化模型。有关详细信息，请参阅量化。
Qnn 转换器后端负责将 IR 降低到最终的 QnnModel API 调用中。
所有转换器共享相同的 IR 代码和 QNN 转换器后端。每个转换器的输出都是相同的，即model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadf3b922f702983a5e3e15f09ac4ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4849a4c285b29503a6edcfbf78191f/" rel="bookmark">
			Windows安装Rust环境（详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 安装mingw64(C语言环境) Rust默认使用的C语言依赖Visual Studio，但该工具占用空间大安装也较为麻烦，可以选用轻便的mingw64包。
1.1 安装地址 (1) 下载地址1-GitHub：Releases · niXman/mingw-builds-binaries · GitHub
(2) 下载地址2-WinLibs：WinLibs - GCC+MinGW-w64 compiler for Windows
1.2 压缩包 1.2.1 压缩包下载
下面以GitHub下载为例：
1.2.2 压缩包关键字说明
架构（Architecture）：x86_64表示压缩包适用于64位的x86处理器架构。版本（Version）：13.2.0-release表示压缩包的版本号为13.2.0，并且是正式发布的版本。操作系统平台（Operating System Platform）： posix：适用于符合POSIX标准的操作系统，如Linux、UNIX等。win32：适用于32位的Windows操作系统。
（如果Linux和Window混用选posix；如果只用Windows开发选win32） 异常处理（Exception Handling）： seh：压缩包使用结构化异常处理（Structured Exception Handling）来处理异常。 运行时库（Runtime Library）： msvcrt：压缩包使用Microsoft Visual C++运行时库（MSVCRT）。ucrt：压缩包使用通用C运行时库（UCRT）。 版本修订（Revision）：rev1表示这些压缩包的修订版本号为1。 综上所述，根据自身需求和操作系统选择适合的压缩包。
1.2.3 msvcrt和ucrt说明
1、 MSVCRT（Microsoft Visual C++ Runtime）：
MSVCRT是Microsoft Visual C++编译器的旧版运行时库，用于支持在Windows系统上使用Visual C++编译的程序。
它提供了许多标准C库函数和C++运行时函数的实现，用于支持程序的运行和调试。
MSVCRT通常与早期的Visual C++版本（如Visual Studio 2010及更早版本）相关联。
2、UCRT（Universal C Runtime）：
UCRT是自Windows 10起引入的新一代运行时库，旨在提供更好的兼容性和性能。
UCRT是一个通用的C运行时库，用于支持使用C语言编译的程序，而不仅仅是限于Visual C++编译器。
它提供了对标准C库函数的更新实现，并支持一些新的C标准（如C11标准）。
UCRT与较新版本的Visual C++（如Visual Studio 2015及更新版本）相关联。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4849a4c285b29503a6edcfbf78191f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46bacd301cfa6ef35496aa88eb04f75d/" rel="bookmark">
			Stable Diffusion（SD）核心基础知识——（文生图、图生图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Stable Diffusion核心基础原理（一）Stable Diffusion模型工作流程（二）Stable Diffusion模型核心基础原理（三）Stable Diffusion的训练过程（四）其他主流生成式模型 二、Stable Diffusion核心网络结构（一）SD模型整体架构（二）VAE模型（三）U-Net模型（四）CLIP Text Encoder模型 Stable Diffusion是计算机视觉领域的一个生成式大模型，可以用于文生图，图生图，图像inpainting，ControlNet控制生成，图像超分等丰富的任务。
一、Stable Diffusion核心基础原理 （一）Stable Diffusion模型工作流程 文生图（txt2img）
文生图任务是指将一段文本输入到SD模型中，经过一定的迭代次数，SD模型输出一张符合输入文本描述的图片。 步骤一： 使用CLIP Text Encoder模型将输入的人类文本信息进行编码，输出特征矩阵；步骤二： 输入文本信息，再用random函数生成一个高斯噪声矩阵 作为Latent Feature的“替代” 输入到SD模型的 “图像优化模块” 中；步骤三： 将图像优化模块进行优化迭代后的Latent Feature输入到 图像解码器 （VAE Decoder） 中，将Latent Feature重建成像素级图。 图生图（img2img）
图生图任务在输入本文的基础上，再输入一张图片，SD模型将根据文本的提示，将输入图片进行重绘以更加符合文本的描述。 步骤一： 在输入文本信息进行编码的同时，将原图片通过图像编码器（VAE Encoder） 生成Latent Feature（隐空间特征）作为输入；步骤二： 将上述信息输入到SD模型的 “图像优化模块” 中；步骤三： 将图像优化模块进行优化迭代后的Latent Feature输入到 图像解码器 （VAE Decoder） 中，将Latent Feature重建成像素级图。 总结：不管是文生图还是图生图，核心模型都是图像优化模块，图像优化模块的输入都是文字+图片，输出都是一张经过优化后的图片。只不过文生图任务中图像优化模块的输入是一张随机生成的噪声图。模型对文字的编码采用CLIP Text Encoder模型，对于图片的编码采用VAE Encoder。
图像优化模块 是由一个U-Net网络和一个Schedule算法共同组成
U-Net网络负责预测噪声，不断优化生成过程，在预测噪声的同时不断注入文本语义信息；schedule算法对每次U-Net预测的噪声进行优化处理（动态调整预测的噪声，控制U-Net预测噪声的强度），从而统筹生成过程的进度；在SD中，U-Net的迭代优化步数大概是50或者100次，在这个过程中Latent Feature的质量不断的变好（纯噪声减少，图像语义信息增加，文本语义信息增加）
（二）Stable Diffusion模型核心基础原理 SD模型属于扩散模型 扩散模型的整体逻辑的特点是过程分步化与可迭代；SD模型具备较强的泛化性能，这些都归功于扩散模型中核心的前向扩散过程和反向生成过程； Stable Diffusion模型的整个流程遵循参数化的马尔可夫链，前向扩散过程是对图像增加噪声，反向生成过程是去噪过程。
SD模型是基于Latent的扩散模型 常规的扩散模型在实际像素空间进行前向扩散过程和反向生成过程；基于Latent的扩散模型在低维的Latent隐空间进行前向扩散过程和反向生成过程，可以大大降低显存占用和计算复杂性。 （三）Stable Diffusion的训练过程 假设我们已经有了一张图像，生成产生一些噪声加入到图像中，然后就可以将该图像视作一个训练样例。使用相同的操作可以生成大量训练样本来训练图像生成模型中的核心组件。基于上述数据集，我们就可以训练出一个性能极佳的噪声预测器，经过训练的噪声预测器可以对一幅添加噪声的图像进行去噪，也可以预测添加的噪声量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46bacd301cfa6ef35496aa88eb04f75d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef522a726a24f0f569730baad9c253d3/" rel="bookmark">
			【算法】基础算法001之双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👀樊梓慕：个人主页
🎥个人专栏：《C语言》《数据结构》《蓝桥杯试题》《LeetCode刷题笔记》《实训项目》《C++》《Linux》《算法》
🌝每一个不曾起舞的日子，都是对生命的辜负
目录
前言
1.数组分块（数组划分）
移动零
复写零
2.快慢双指针（循环往复）
快乐数
3.对撞指针-&gt;暴力枚举的优化-&gt;利用单调性
盛最多水的容器
有效三角形的个数
4.对撞指针-&gt;两数之和、三数之和、四数之和
两数之和
三数之和
四数之和
前言 💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐
《算法》专栏正式挂牌成立
《算法》专栏主要是会系统的梳理一些OJ题的算法思想，将他们按照解题方法的不同划分出来，然后归纳总结，当然希望大家多多收藏，以后忘了可以常回来看看！ 💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐
本篇文章主要会讲解双指针的思想，双指针是一种非常优秀的算法思想，有对撞指针和快慢指针两种基本用法。
双指针对于有序数据的处理是比较有优势的，当你遇到有序的数据时，你可以尝试着利用双指针或者二分来解题，当然本篇文章只会讲解双指针。
那么双指针思想具体的应用，以及为什么双指针适用于有序数组的处理呢？
欢迎大家📂收藏📂以便未来做题时可以快速找到思路，巧妙的方法可以事半功倍。
=========================================================================
GITEE相关代码：🌟fanfei_c的仓库🌟
=========================================================================
1.数组分块（数组划分） 数组分块顾名思义，该类题目有一个特性就是将数组中的数据进行分类，然后将分类的数据放在不同的区域上。
移动零 移动零 - 力扣（LeetCode）https://leetcode.cn/problems/move-zeroes/description/
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
利用数组分块的思想，我们可以将该数组划分为三个区域：非零的已处理区域、零的已处理区域、待处理区域。
三个区域恰好可以利用两个指针进行分割得到。
所以我们定义两个指针：
cur：从左向右扫描数组（遍历数组的作用），主要用来分割已处理区域和待处理区域用；dest：已处理的区域内，非零元素的最后一个位置，主要用来分隔已处理区域内部非零元素和零元素。 得到三个区间：
非零的已处理区域：[0,dest]零的已处理区域：[dest+1,cur-1]待处理区域：[cur,n-1] 有了思路，画图独立完成代码，不要直接看博主的代码。
class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { for (int dest = -1, cur = 0; cur &lt;= nums.size() - 1; cur++) { //如果是零就跳过，不是零进入 if (nums[cur]) { swap(nums[++dest], nums[cur]); } } } }; 复写零 复写零 - 力扣（LeetCode）https://leetcode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef522a726a24f0f569730baad9c253d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc0960639da5dbb0af7a15befee61c1/" rel="bookmark">
			如何在 Ubuntu 20.04 上安装 Rust
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个人工智能学习网站，通俗易懂，风趣幽默，最重要的屌图甚多，忍不住分享一下给大家。点击跳转到网站。
如何在 Ubuntu 20.04 上安装 Rust 介绍 Rust 编程语言，是一种功能强大的通用编程语言。Rust 在语法上与C++类似，用于广泛的软件开发项目，包括浏览器组件、游戏引擎和操作系统。
在本文中，将在 Ubuntu 20.04 上安装最新版本的 Rust（1.66），然后创建、编译和运行测试程序。
**注意：**本文也适用于 Ubuntu 22.04，但是，可能会出现apt upgrade针对各种问题的交互式对话框。例如，系统可能会询问是否要在需要时自动重新启动服务，或者是否要替换已修改的配置文件。这些问题的答案取决于自身的软件和偏好，本文不会提及。
先决条件 需要一台 Ubuntu 20.04 服务器，并具有启用 sudo 的非 root 用户和防火墙。可以按照Ubuntu 20.04 初始服务器设置教程进行设置。
第 1 步 — 使用rustup在 Ubuntu 上安装 Rust 尽管在 Linux 上安装 Rust 有多种不同的方法，但推荐的方法是使用rustup命令行工具。
运行命令下载该rustup工具并安装 Rust 的最新稳定版本：
curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh 系统会提示选择安装类型：
Outputsammy@ubuntu:~$ curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh info: downloading installer Welcome to Rust!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfc0960639da5dbb0af7a15befee61c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cfffc5b8c59d655ff8c6964472cd06c/" rel="bookmark">
			Mac上使用phpstudy&#43;vscode配置PHP开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的工具： 1、系统版本 2、vs code code 3、phpstudy_pro 一、下载vs code code以及必要的插件 1、vs code下载 点击vs code官网下载
选择对应的版本，一般电脑会自动识别对应的版本，点击下载，然后傻瓜式安装！
2、vs code 的插件安装 点击下面的图标，扩展
搜索“Chinese”，然后点击“install”，等待安装
安装完成右下角显示，点击重启
你就得到中文版的vs code 了！！
继续搜索“PHP”，安装“PHP Debug”和“PHP Intelephense”插件
3、用vs code打开文件夹 选择资源管理器，并发开一个自定义的文件夹
如图所示
二、下载并配置PHP_study 1、下载phpstudy 官网下载链接
选择“Mac版”
点击图标打开
2、配置phpstudy 2.1 设置一键启动
安装之后打开，如图点击启点击“WNMP”，设置一键启动
选中Apache和MySql的选项，点击“确定”
2.2、启动apache和mysql
点击“启动”
显示信息如下：
2.3、下载PHP
下载PHP，任意一个版本就行
2.4、设置PHP
点击“设置”，“扩展组件”，打开“OP Cache缓存优化PH P组件”
2.5、 网站建立
我们先暂停这个自带localhost的网站，因为我们需要自己重新配置一个端口号为80的网站，避免端口号冲突，依次点击“网站”，“管理”，“停止”
接下来我们创建新的网站
我们回到vs code code，复制一个文件夹路径作为我们新建网站的根目录
鼠标右键点击我们打开的文件夹，然后点击“复制路径”
回到phpstudy
点击“新建网站”
输入一个自定义的域名(建议还是用localhost，因为在电脑的/etc/host文件中有配置)，将刚才复制的路径粘贴进“根目录”，再点击“确认”
三、我的第一个网页 1、创建文件 在刚才打开的vs code 的目录下，创建一个后缀名为“.php”的文件
在这里插入图片描述
2、写代码 写入PHP的代码
&lt;?php echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cfffc5b8c59d655ff8c6964472cd06c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb04170e5cd814a19e92833ae2bd5a14/" rel="bookmark">
			华为OD机试真题目录汇总（C语言、C&#43;&#43;、Java、Python、JS五种语言解法）2024 B&#43;C&#43;D卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀前言🚀其他华为OD机试题清单一、什么是华为OD，什么是华为OD机试？二、华为OD面试流程？三、华为OD机试通过率高吗？四、华为OD薪资待遇？🚀五、怎么刷题？通过华为OD机试？华为OD原题刷题列表🔰部分文章试读演示🔰部分思路及代码参考演示🔰刷题列表：2024华为OD机试真题(C C++ Java Py JS) B+C+D卷2024年B+C+D卷 新题库(100分)2024年B+C+D卷 新题库(200分) 作者：KJ.JK 🚀前言 本文是2024华为OD机试真题(C C++ Java Py JS) B卷 专栏的目录贴（定期更新华为OD各个时间阶段的机试真题，每日定时更新，本专栏每篇的文章都会将使用C语言、C++、Python、Java、JS五种语言进行更新解答，包含真题，思路分析，代码参考，每个题目的思路分析都非常详细，超过百字欢迎大家订阅学习，代码可以直接运行使用，限时优惠，持续更新）
🚀其他华为OD机试题清单 🔥2024华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
🔥2024华为OD机试真题(C语言) B+C+D卷🔥
🔥2024华为OD机试真题(Python语言) B+C+D卷🔥
🔥2024华为OD机试真题(Java 语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++语言)B+C+D卷🔥
🔥2024华为OD机试真题(JS 语言) B+C+D卷🔥
🔥2024华为OD机试真题(Golang语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++ Java Python) 🔥
一、什么是华为OD，什么是华为OD机试？ 华为OD是Outsourcing Dispacth模式，是华为和外企德科联合招聘的简称。目前华为大多数是OD招聘。OD模式也是华为提出的一种新的用工形式，每年都会从OD项目挑优秀员工转为正编。所有OD和正式员工一样对待，没有差别，部门平时开会、评审等活动都是一起参加的，是同薪同酬，都是由华为的HR直接定的薪资，看的是我们技术能力。华为是大企业，能到华为上班也是有能力的，每个部门都有好多职位，是金子，在哪都会发光。薪资对华为OD也是有绝对的优势，在互联网一线的大厂中，华为的工作环境和薪资都是很好的，OD其实简单说就是外包，现在有很多公司都在给华为供给外包服务，比如中软，因为华为有很多业务部门，去年一个很熟的猎头给我推荐了几个技术岗位的华为OD都通过了
而华为OD机试是指华为公司的在线笔试，是华为公司用于筛选招聘岗位候选人的一种考核方式，
华为OD机试通常由多个题目组成，包括算法设计、编程、调试等多个环节，考察候选人的基础知识、实际能力和算法编写能力等多个方面，是华为招聘流程中非常重要的一环
二、华为OD面试流程？ 华为OD面试流程一般包括以下几个步骤：
1、笔试：考察候选人的基础知识、算法设计和编程能力等多个方面，题目通常包括算法题、编程题、数据结构题等
2、性格测试(综合测试)：这部分是用来评估候选人的性格特质，以便更好地了解其适应能力、沟通能力和团队合作能力等
3、技术一面：该面试官通常是该项目组的技术负责人，主要考察候选人对技术的理解和实际应用能力。面试内容通常包括代码题和项目问题解决，围绕计算机/编程基础+项目经验+代码能力进行考察，如应届生无项目经验，重点复习八股文+刷算法题
4、HR面：围绕求职动机、稳定性、薪酬期望、Gap经历、延毕等异常情况进行考察
5、终面：终面是在参加完所有面试后进行的最后一轮面试，，主要考察候选人的综合素质和领导潜力；其中，笔试和性格测试是比较常见的部分，而技术一面和群面则比较特殊，通常会根据不同的岗位和项目有所不同，最终的面试结果也会根据个人的表现和竞争情况而定，不会限制通过人数
全流程线上进行，一般机考通过后2-3周内出offer，特殊情况时间过长的话需要积极联系接口人HR
三、华为OD机试通过率高吗？ 据华为官方公布的数据，华为OD机试的通过率约为75%。具体来说，华为OD机试一共有五个级别，从D1到D5，对应13到17级，每个级别的题目数量和难度都有所不同。在过去的招聘中，据说只有25%左右的候选人能够通过第一轮机试。第二轮性格测试也是招聘流程中的重要环节，会刷掉一部分人。不过，华为表示，最终的通过率取决于候选人的实际表现和竞争情况，不会限制通过人数
此外，华为还将机试分为上机考试和在线作业两部分，上机考试主要考察算法设计和编程能力，在线作业主要考察算法思维和解决问题的能力。华为表示，在线作业部分是考察候选人的综合能力，包括解决问题的能力、沟通能力和团队合作能力等。
综合来看，华为OD机试的通过率虽然不是100%，但是也是在高水平范围内的。对于候选人来说，需要全面提升自己的能力，才能更好地通过机试
四、华为OD薪资待遇？ 薪资结构：
1、基本工资+绩效工资+年终奖（2-4个月，一般绩效A-4个月，B-2个月）；
2、D1-D5分别对应华为13-17级，参考范围10-40K；
3、试用期内（6个月）工资不打折，按B绩效发绩效工资，转正时重新评绩效，一般分A、B、C三档（主要A或B，C概率较小），和正式员工分开评，半年评一次；
4、五险一金基数按基本工资，公积金比例5%-12%，具体看base地。
5、福利补贴：带薪年假、入职&amp;年度免费体检、免费夜宵、班车/加班打车免费、下午茶、节假日礼品等
13级薪资：9k-13k
14级薪资：13k-17k
15级薪资：17k-21k
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb04170e5cd814a19e92833ae2bd5a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091731708a63a7bb5982003bff1321d4/" rel="bookmark">
			nginx（NGINX）详细下载安装及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 NGINX 是一个非常流行的开源 Web 服务器和反向代理服务器，它可以帮助用户负载均衡（主要体现在可以创建多个服务器，一般将静态资源页面和动态页面分开部署到不同服务器，这样就可以降低服务器压力）、缓存、反向代理、SSL 终止等功能，常用于 Web 应用程序的开发和部署。
什么是 NGINX?（详细介绍）
NGINX 是一个开源的 Web 服务器和反向代理服务器，它使用 Nginx 作为 Web 服务器和反向代理服务器的原因是它拥有高性能、可扩展性和可靠性。它可以处理大量的并发连接，并且可以缓存 HTTP 请求以提高性能。
工作原理
NGINX是由俄罗斯一名程序员开发，于2020年12月15日正式发布公开版本，其工作原理是将 HTTP 请求转发到服务器，然后将响应返回给用户。它可以通过配置来支持缓存、SSL 终止、负载均衡等功能。NGINX 可以运行在多种操作系统上，如 Linux、Windows 等。
NGINX 具有以下功能:
负载均衡:NGINX 可以通过轮询、加权轮询、最小连接数等方法对传入的请求进行负载均衡。
缓存:NGINX 可以缓存 HTTP 请求以提高性能，可以使用 Etag、If-None-Match 等指令来缓存请求。
SSL 终止:NGINX 可以终止 HTTPS 请求并将其转换为 HTTP 请求，以便可以将其传递给 Web 服务器。
反向代理:NGINX 可以充当 Web 服务器和客户端之间的代理，将请求转发到服务器，并将响应返回给客户端。
路由:NGINX 可以根据 URL 将请求转发到不同的服务器，也可以根据请求的参数、状态码等来路由请求。
NGINX 具有以下优点:
高性能:NGINX 可以处理大量的并发连接，并且可以将请求缓存以提高性能。
可扩展性:NGINX 可以轻松地扩展以处理更多的请求，并且支持多种插件和模块。
可靠性:NGINX 具有高可靠性，可以在没有管理员干预的情况下自动处理故障和恢复。
易于配置:NGINX 的配置非常简单，并且提供了丰富的文档和教程来帮助用户快速上手。
总的来说，NGINX 是一个非常强大的 Web 服务器和反向代理服务器，它可以提高 Web 应用程序的性能和可靠性，并且可以轻松地扩展以处理更多的请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091731708a63a7bb5982003bff1321d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ab139729db3c4d9028765f78a9887a/" rel="bookmark">
			什么是预训练Pre-training—— AIGC必备知识点，您get了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Look！👀我们的大模型商业化落地产品📖更多AI资讯请👉🏾关注Free三天集训营助教在线为您火热答疑👩🏼‍🏫 随着人工智能(AI)不断重塑我们的世界，其发展的一个关键方面已经成为现代机器学习模型的支柱:预训练。在本篇文章中，我们将探讨预训练的概念，它在人工智能中的重要性， 用于实现预训练的各种技术，以及该领域的研究人员所面临的一些挑战。
什么是预训练? 在人工智能和机器学习的领域，预训练(pre-training)是指在一个较小的、特定任务的数据集上进行微调(fine-tuning)之前，在一个大数据集上训练一个模型的过程。这个初始训练阶段允许模型从数据中学习一般的特征和表征，然后可以针对具体任务进行微调。
预训练背后的主要动机是利用从大规模数据集获得的知识来提高模型在较小的、更集中的数据集上的性能。通过这样的方式，研究人员可以用较少的标记实例获得更好的结果，减少对大量特定任务、标记数据的需求。
预训练的重要性
预训练成为现代人工智能的一个重要组成部分有几个原因:
转移学习: 预训练使知识可以从一个领域或任务转移到另一个领域。通过从大规模的数据集中学习一般的特征和表征，可以对模型进行微调，以便在广泛的任务中表现良好。这减少了对特定任务训 练数据的需求，使研究人员能够更容易地处理新问题。
计算效率: 预训练允许模型从大量的数据中学习，而不需要特定任务的、标记的例子。这可以大大减少训练所需的计算资源，使训练大规模模型更加可行。
模型性能: 经过预训练的模型在特定任务上的表现往往比从头开始训练的模型更好。在预训练期间 学到的一般特征和表征可以针对广泛的任务进行微调，从而提高性能并加快收敛。
预训练的技术
有几种技术可用于人工智能模型的预训练，其中无监督和有监督的预训练是最常⻅的方法。
无监督预训练
无监督预训练(Unsupervised Pre-training)：包括在一个没有任何标记的例子的大数据集上训练一个模型。该模型学会了在没有任何标签指导的情况下识别数据中的模式和结构。
一些流行的无监督预训练技术包括:
1.自动编码器(Autoencoders，AE): 自动编码器是学习对数据进行编码和解码的神经网络。它们被训练成通过最小化原始输入和重构输出之间的差异来重构其输入。通过学习数据的压缩表示，自动编码器可以捕捉到对后续任务有用的重要特征和模式。
2.生成式模型(Generative models): 生成式模型，如变异自动编码器(VAEs)和生成对抗网络 (GANs)，学习生成与训练数据相似的新数据样本。通过学习基础数据分布，这些模型可以学习 有用的特征和表征，可以转移到其他任务。
有监督的预训练 有监督的预训练(Supervised Pre-training)：包括在一个有标签的大数据集上训练一个模 型。该模型学习预测与输入数据相关的标签，然后可以为特定的任务进行微调。一些流行的监督性预训练技术包括:
1.语言模型: 语言模型的训练是为了预测一个序列中的下一个词，给定前面的词。通过学习生成连贯的文本，这些模型捕捉重要的语言特征和表征，可以转移到其他自然语言处理任务中。预训练的语言模型的例子包括OpenAI推出的GPT和Google的BERT。
2.图像分类模型: 图像分类模型的训练是为了预测输入图像的类别。预训练的图像分类模型，如ResNet和VGG，可以进行微调，以便在广泛的计算机视觉任务中表现良好，包括物体检测、分类等。
预训练面临的挑战 可扩展性: 随着人工智能模型的规模和复杂性不断增加，预训练所需的计算资源也在增加。开发更 有效的预训练技术和利用分布式计算资源将是推动该领域发展的关键。
数据偏差: 预训练的模型很容易受到训练数据中存在的偏差的影响。解决数据偏差和开发方法以确 保预训练模型的公平性和稳健性是一个持续研究的领域。
可解释性: 随着模型变得越来越复杂，理解它们的内部运作和它们学习的表征变得越来越有挑战 性。开发更好地理解和解释预训练模型的方法，对于建立信任和确保人工智能系统的安全至关重要。
关于预训练的具体定义和其作用机制，我们近屿智能OJAC推出的《AIGC星辰大海：大模型工程师和产品专家深度训练营》就是学习这部分知识的最好选择。我们的课程是一场结合了线上与线下的双轨合流式学习体验。
别人教您使用AIGC产品，例如ChatGPT和MidJourney，我们教您增量预训练，精调大模型，和创造属于自己的AI产品!
您是否想利用AIGC为您打破职业与薪资的天花板？您是否想成为那个在行业里脱颖而出的AI专家？我们的培训计划，将是您实现这些梦想的起点。
让我带您了解一下近屿智能OJAC如何帮您开启AI的大门。
首先，为了让零基础的您也能轻松上手，我们特别设计了“Python强化双周学”这个先修课程。在两周的时间里，我们将通过在线强化学习，把大模型相关的Python编程技术娓娓道来。就算您现在对编程一窍不通，也不要担心，我们会带您一步步走进编程的世界。
然后，是我们的“AIGC星辰大海：大模型工程师与AIGC产品经理启航班”。这个课程包含6节精彩的直播课，不仅能让您深入了解ChatGPT等大模型的奥秘，还会带您领略至少20个来自全球的成功AIGC产品案例。想象一下，未来您同样有机会利用这些先进技术打造出热门AI产品！
更深层次的学习，则在“AIGC星辰大海：大模型工程师和产品专家深度训练营”中进行。这个深度训练营覆盖了从理论基础到实际操作的全过程，让您不仅学会理论，更能将知识应用到实际项目中。如果您想要深挖大模型的秘密？这里就是您的实验室！
如果您选择加入我们的OJAC标准会员，我们的"AI职场导航"项目，还将为您提供量身定制的职业机会，这些职位来自于我们广泛的行业网络，包括初创企业、中型企业以及全球知名公司。我们会根据您的技能、经验和职业发展愿景，为您筛选合适的机会。此外，我们也提供简历修改建议、面试准备指导和职业规划咨询，帮助您在竞争激烈的市场中脱颖而出。
同时您也可以享受到未来景观AI讲座暨每月技术洞见”系列讲座，获得最新的技术洞见。这不仅是一个学习的机会，更是一个与行业顶尖大咖直接交流的平台。
以下是我们大模型工程师和产品专家深度训练营的课程内容：
除此之外，现在报名我们即将开班的第六期AIGC星辰大海大模型工程师和产品经理训练营，您将可以参与到以下三个创新实战项目中的任意一个，这些项目不仅能够锻炼您的实战能力，还能让您在AIGC领域脱颖而出。
项目1:企业级知识问答GPT
这个项目将教您如何打造一个智能机器人，它能够接入企业内部的知识库，如技术文档、HR政策、销售指南等。您将学会如何使其具备强大的自然语言处理能力，进行复杂查询的理解和精确答案的提供。此外，该项目还包括教您如何让机器人保持对话上下文、支持多语言交流，并具备反馈学习机制，以不断提升服务质量。
项目2:行业级AI Agent
在这个项目中，您将学习如何为特定行业定制化AI Agent。您将被指导如何让它理解行业专有术语和工作流程，并训练它自动执行任务，如预约设置、数据输入和报告生成。这个项目不仅帮助您构建一个决策支持系统，还教您如何进行用户行为预测和性能监控与优化。
项目3:论文翻译
如果您对语言学习和学术研究有浓厚兴趣，这个项目将是您的理想选择。您将探索如何实现从英语到中文或其他目标语言的精准学术翻译，确保保留学术文献的深层含义。本项目还包括学术格式定制、专业词汇精确匹配以及广泛语言选项的训练，最后通过翻译效果评价系统，您将能够持续提升翻译质量。
无论您选择哪个项目，都将是您职业生涯中不可多得的实战经历。
我们诚邀您继续与我们携手前行。在未来的职业道路上，让我们共同探索AI的更多奥秘，共创辉煌。如果您还有任何疑问或者想要深入了解更多课程内容，请随时联系我们。我们期待着与您共同开启下一阶段的AI探索之旅。
加入我们的“AIGC星辰大海”训练营，让我们一起在AI的世界里创造不凡！立刻加入我们，开启您的AI大模型旅程，将梦想转变为现实。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a21642be7cf6e705e636faf4691c9cd7/" rel="bookmark">
			MySql的安装与IDEA配置Mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL下载与安装 1.MySql下载 地址：https://dev.mysql.com/downloads/mysql/
2.MySql安装 （1）解压压缩包 （2）环境变量配置 我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;选中系统变量Path-&gt;编辑-&gt;新建
复制文件夹里bin文件的路径，添加进去
（3）配置MySql 1.新建ini和data文件 MySql文件目录下新建一个配置文件mysql.ini 和一个data文件夹（用于存放数据库数据）。
文件mysql.ini 的创建方法为：新建一个txt文档，将“新建文本文档.txt”改为“mysql.ini”，注意一定要把.txt的后缀改了，否则这个文件就还是txt文件，不是我们需要的配置文件。如果你的文件名里没显示.txt，那么点查看-&gt;详细信息-&gt;文件扩展名
2.用记事本打开mysql.ini，添加如下内容 设置mysql客户端默认字符集
default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # ！！！设置mysql的安装目录 basedir=D:\project needs\MySql\mysql-5.7.44-winx64 #！！！ 设置mysql数据库的数据的存放目录 datadir=D:\project needs\MySql\mysql-5.7.44-winx64\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 其中，这两句要设置成自己的目录，其他的不用变 # ！！！设置mysql的安装目录 basedir=D:\project needs\MySql\mysql-5.7.44-winx64 #！！！ 设置mysql数据库的数据的存放目录 datadir=D:\project needs\MySql\mysql-5.7.44-winx64\data 3.在屏幕左下角右键打开Windows Powershell（管理员）或者以管理员身份运行cmd A 输入下面命令，回车，会提示安装成功 mysqld install B 启动服务，输入如下命令，回车，提示mysql服务启动成功 net start mysql 如果出现上述情况，请查看以下几种方法：
方法一：可能是端口被占用 （1）查看端口，找到占用3306端口的进程：命令行输入 netstat -aon ，找到端口号为3306的对应的PID
如图所示，我的占用3306的端口的进程对应的PID为4076
（2）结束占用端口3306的进程：命令行输入 taskkill /f /pid xxxx，杀掉进程，xxxx即为PID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a21642be7cf6e705e636faf4691c9cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b994b9a5c296015885c2a47895bdb8/" rel="bookmark">
			Hadoop 实战 | 词频统计WordCount
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		词频统计 通过分析大量文本数据中的词频，可以识别常见词汇和短语，从而抽取文本的关键信息和概要，有助于识别文本中频繁出现的关键词，这对于理解文本内容和主题非常关键。同时，通过分析词在文本中的相对频率，可以帮助理解词在不同上下文中的含义和语境。
"纽约时报"评论数据集记录了有关《纽约时报》2017年1月至5月和2018年1月至4月发表的文章上的评论的信息。月度数据分为两个csv文件：一个用于包含发表评论的文章，另一个用于评论本身。评论的csv文件总共包含超过200万条评论，有34个特征，而文章的csv文件包含超过9000篇文章，有16个特征。
本实验需要提取其中的 articleID 和 snippet 字段进行词频统计
MapReduce 在Hadoop中，输入文件通常会通过InputFormat被分成一系列的逻辑分片，分片是输入文件的逻辑划分，每个分片由一个Mapper处理。
本实验中，WordCount通过MapReduce统计snippet 字段中每个单词出现的总次数。程序主要包括Mapper, Reducer, Driver三个部分。
自定义的Mapper和Reducer都要继承各自的父类。Mapper中的业务逻辑写在map()方法中，Reducer的业务逻辑写在reduce()方法中。整个程序还需要一个Driver来进行提交，提交的是一个描述了各种必要信息的job对象。
程序总体流程如下图所示。
Mapper Mapper的主要任务是处理输入分片并生成中间键值对，这些键值对将被传递给Reducer进行进一步处理，也就是对应的Map的过程。
在本实验中，Mapper需要将这行文本中的单词提取出来，针对每个单词输出一个&lt;word, 1&gt;的&lt;Key, Value&gt;对。之后MapReduce会对这些&lt;word,1&gt;进行排序重组，将相同的word放在一起，形成&lt;word, [1,1,1,1,1,1,1…]&gt;的&lt;Key,Value &gt;结构并传递给Reducer。
Reducer Reducer则以中间键值对为输入，将其按照键进行分组，并将每个组的值按一定规则合并成最终的输出。
注意在此阶段前，Hadoop框架会自行将中间键值对经过默认的排序分区分组，Key相同的单词会作为一组数据构成新的&lt;Key, Value&gt;对。
在本实验中，Reducer将集合里的1求和，再将单词（word）与这个和（sum）组成一个&lt;Key, Value&gt;，也就是&lt;word, sum&gt;输出。每一个输出就是一个单词和它的词频统计总和了。
Driver Driver是一个程序的主入口，负责配置和启动整个MapReduce任务。Driver类通常包含了整个MapReduce作业的配置信息、作业的输入路径、输出路径等信息，并启动MapReduce作业的执行。
总结 该程序基于Hadoop MapReduce框架实现了简单的单词计数功能，适用于大规模文本数据的并行处理。
PSEUDO-CODE 2 WordCount(词频统计)
/* Map函数，处理每一行的文本 */
1：input &lt;Key,Value&gt;； //Value使用Text类型表示文本行
2：从文本中提取文档ID和实际文本内容snippet；
3：使用空格、单引号和破折号作为分隔符，将文本snippet分词；
4：for 文本snippet中的每个单词：
5： 去除特殊字符后将&lt;word,1&gt;写入context，发射给Reducer；
6：end for
/* Reduce函数，处理相同键的所有值 */
1：input &lt;Key,Value&gt;，sum←0； //来自Map的&lt;word,[1,1,1…]&gt;
2：for Value的每个1：
3： 累加计数sum += 1；
代码 import java.io.IOException; import java.util.regex.*; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b994b9a5c296015885c2a47895bdb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/829cad58257935834ff4d8b300d9a9f8/" rel="bookmark">
			OFDM系统信道估计误码率matlab仿真,对比LS,LMMSE,LR-LMMSE三种信道估计算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 最小二乘（LS）信道估计算法
2. 线性最小均方误差（LMMSE）信道估计算法
3. 基于低秩逼近的LMMSE（LR-LMMSE）信道估计算法
4. MATLAB程序
OFDM，即正交频分复用技术，是多载波调制（MCM）的一种。以下是其主要特性和工作原理的详细介绍：OFDM的主要思想是将信道划分为若干相互正交的子信道，每个子信道都使用一个独立的子载波进行调制。这些子载波在频谱上是重叠的，但由于它们之间的正交性，可以在接收端被准确地分离出来。在发送端，高速数据流被转换为多个并行的低速子数据流，每个子数据流都调制到一个子载波上。然后，这些已调制的子载波信号被相加，形成一个复合信号进行传输。在接收端，复合信号被分离成各个子载波信号，每个子载波信号都被独立解调，恢复出原始的子数据流。最后，这些子数据流被合并成原始的高速数据流。
正交频分复用（OFDM）系统是一种多载波调制技术，广泛应用于无线通信领域。在OFDM系统中，信道估计是一个关键步骤，用于估计无线信道的频率响应，以便在接收端正确解调数据。常见的信道估计算法包括最小二乘（LS）算法、线性最小均方误差（LMMSE）算法和基于低秩逼近的LMMSE（LR-LMMSE）算法。
1. 最小二乘（LS）信道估计算法 最小二乘（LS）信道估计算法是一种在通信系统中常用的信道估计方法。它的核心思想是通过最小化接收信号与通过信道后的发送信号之间的平方误差来估计信道特性。
LS信道估计算法的具体步骤如下：
假设在一个OFDM系统中，发送信号经过信道后受到噪声干扰，接收端接收到信号。LS信道估计的目标是根据接收信号和已知的发送信号来估计信道频率响应。
定义一个代价函数，该函数表示接收信号与通过信道后的发送信号之间的平方误差。代价函数可以表示为：
LS算法是一种简单而直观的信道估计算法。它的目标是最小化接收信号与通过信道后的发送信号之间的平方误差。LS信道估计的数学表达式如下：
其中，H^LS​ 是LS信道估计结果，Y 是接收信号，X 是发送信号。这个公式假设信道是平坦的，即在一个OFDM符号内信道的频率响应保持不变。在实际应用中，通常会使用导频符号来进行信道估计。
然而，LS算法的一个主要缺点是它对噪声非常敏感，因为它没有考虑噪声的影响。因此，在信噪比（SNR）较低的情况下，LS算法的性能可能会严重下降。
2. 线性最小均方误差（LMMSE）信道估计算法 LMMSE算法是一种更复杂的信道估计算法，它考虑了噪声的影响，并试图最小化信道估计的均方误差。LMMSE信道估计的数学表达式如下：
LMMSE算法的性能通常优于LS算法，特别是在SNR较低的情况下。然而，LMMSE算法的计算复杂度较高，因为它需要计算矩阵的逆。
3. 基于低秩逼近的LMMSE（LR-LMMSE）信道估计算法 LR-LMMSE算法是一种改进的LMMSE算法，它通过利用信道频率响应的低秩特性来降低计算复杂度。LR-LMMSE算法的基本思想是将信道频率响应矩阵分解为低秩矩阵和稀疏矩阵的和，然后只对低秩矩阵进行LMMSE估计。
LR-LMMSE算法的数学表达式比较复杂，涉及矩阵分解和优化问题。简单来说，LR-LMMSE算法可以表示为：
LR-LMMSE算法的性能通常接近LMMSE算法，但其计算复杂度较低，更适合实际应用。
4. MATLAB程序 clc; clear; close all; warning off; addpath(genpath(pwd)); %本次仿真载频为2GHz，带宽1MHz，子载波数128个，cp为16 %子载波间隔为7.8125kHz %一个ofdm符号长度为128us，cp长度为16us %采用16QAM调制方式 %最大doppler频率为132Hz %多径信道为5径，功率延迟谱服从负指数分布~exp(-t/trms),trms=(1/4)*cp时长，各径延迟取为delay=[0 2e-6 4e-6 8e-6 12e-6] pilot_inter=5;%导频符号间隔为10,可以调整，看不同导频间隔下的BER情况，和理论公式比较 pilot_symbol_bit=[0 0 0 1];%导频为常数，对应星座点1+3*j cp_length=16;%cp长度为16 SNR_dB=[0:2:30]; ls_err_ber=zeros(1,length(SNR_dB)); lmmse_err_ber=zeros(1,length(SNR_dB)); lr_lmmse_err_ber=zeros(1,length(SNR_dB)); for i=1:length(SNR_dB)%每个SNR点上仿真若干次 i ls_error_bit=0; lmmse_error_bit=0; lr_lmmse_error_bit=0; total_bit_num=0; loop_num=10; for l=1:loop_num ofdm_symbol_num=100;%每次仿真产生100个ofdm符号,则每次仿真共有100×128个星座映射符号；16QAM调制下，1个星座映射符号包含4个bit bit_source=input_b(128,ofdm_symbol_num);%为每次仿真产生100个ofdm符号的比特个数，128为每个ofdm符号的子载波个数 [nbit,mbit]=size(bit_source); total_bit_num=total_bit_num+nbit*mbit; map_out=map_16qam(bit_source);%对一次仿真符号块进行16QAM映射 [insert_pilot_out,pilot_num,pilot_sequence]=insert_pilot(pilot_inter,pilot_symbol_bit,map_out);%按块状导频结构，对映射后的结果插入导频序列 ofdm_modulation_out=ifft(insert_pilot_out,128);%作128点逆FFT运算，完成ofdm调制 ofdm_cp_out=insert_cp(ofdm_modulation_out,cp_length);%插入循环前缀 %********************** 以下过程为ofdm符号通过频率选择性多径信道 ************************* %假设功率延迟谱服从负指数分布~exp(-t/trms),trms=(1/4)*cp时长； %t在0~cp时长上均匀分布 %若cp时长为16e-6s，可以取5径延迟如下 delay=[0 20e-6 40e-6 60e-6 80e-6]; num=length(delay); trms=4e-6; var_pow=10*log10(exp(-delay/trms)); fd=0;%doppler频率 t_interval=1e-6;%采样间隔为1us counter=200000;%各径信道的采样点间隔，应该大于信道采样点数。由以上条件现在信道采样点数 count_begin=(l-1)*(5*counter);%每次仿真信道采样的开始位置 trms_1=trms/t_interval; t_max=16e-6/t_interval; %信道采样点数，每个调制符号采一个点 passchan_ofdm_symbol=multipath_chann(ofdm_cp_out,num,var_pow,delay,fd,t_interval,counter,count_begin); %********************** 以上过程为ofdm符号通过频率选择性多径信道 ************************* %********************** 以下过程为ofdm符号加高斯白噪声 ************************* snr=10^(SNR_dB(i)/10); [nnl,mml]=size(passchan_ofdm_symbol); spow=0; for k=1:nnl for b=1:mml spow=spow+real(passchan_ofdm_symbol(k,b))^2+imag(passchan_ofdm_symbol(k,b))^2; end end spow1=spow/(nnl*mml); sgma=sqrt(spow1/(2*snr));%sgma如何计算，与当前SNR和信号平均能量有关系 receive_ofdm_symbol=add_noise(sgma,passchan_ofdm_symbol);%加入随机高斯白噪声，receive_ofdm_symbol为最终接收机收到的ofdm符号块 %********************** 以上过程为ofdm符号加高斯白噪声 ************************* cutcp_ofdm_symbol=cut_cp(receive_ofdm_symbol,cp_length);%去除循环前缀 ofdm_demodulation_out=fft(cutcp_ofdm_symbol,128);%作128点FFT运算，完成ofdm解调 %********************** 以下就是对接收ofdm信号进行信道估计和信号检测的过程************************ ls_zf_detect_sig=ls_estimation(ofdm_demodulation_out,pilot_inter,pilot_sequence,pilot_num);%采用LS估计算法及迫零检测得到的接收信号 lmmse_zf_detect_sig=lmmse_estimation(ofdm_demodulation_out,pilot_inter,pilot_sequence,pilot_num,trms_1,t_max,snr);%采用LMMSE估计算法及迫零检测得到的接收信号 low_rank_lmmse_sig=lr_lmmse_estimation(ofdm_demodulation_out,pilot_inter,pilot_sequence,pilot_num,trms_1,t_max,snr,cp_length);%采用低秩LMMSE估计算法及迫零检测得到的接收信号 %********************** 以下就是对接收ofdm信号进行信道估计和信号检测的过程************************ ls_receive_bit_sig=de_map(ls_zf_detect_sig);%16QAM解映射 lmmse_receive_bit_sig=de_map(lmmse_zf_detect_sig); lr_lmmse_receive_bit_sig=de_map(low_rank_lmmse_sig); %以下过程统计各种估计算法得到的接收信号中的错误比特数 ls_err_num=error_count(bit_source,ls_receive_bit_sig); lmmse_err_num=error_count(bit_source,lmmse_receive_bit_sig); lr_lmmse_err_num=error_count(bit_source,lr_lmmse_receive_bit_sig); ls_error_bit=ls_error_bit+ls_err_num; lmmse_error_bit=lmmse_error_bit+lmmse_err_num; lr_lmmse_error_bit=lr_lmmse_error_bit+lr_lmmse_err_num; end %计算各种估计算法的误比特率 ls_err_ber(i)=ls_error_bit/total_bit_num; lmmse_err_ber(i)=lmmse_error_bit/total_bit_num; lr_lmmse_err_ber(i)=lr_lmmse_error_bit/total_bit_num; end figure semilogy(SNR_dB,ls_err_ber,'b-*') hold on semilogy(SNR_dB,lmmse_err_ber,'r-o') hold on semilogy(SNR_dB,lr_lmmse_err_ber,'k-+') hold off legend('ls','lmmse','lr-lmmse'); xlabel('SNR'); ylabel('error'); grid on; up4021 测试结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/829cad58257935834ff4d8b300d9a9f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ad84f7e38eeaa270733f0fbc88fdf7/" rel="bookmark">
			(适合新手上机)关于navicat基本使用，以及sql的事务的基础使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建一个数据库 在以demo用户连接下创建数据库，右键-新建数据库，选上后点确定
2.创建一张表 选上first test中的表，右键-新建表
依次在名下输入id，类型选择int，以及name，类型选择varchar…,那个键有个钥匙的，说明id作为主键
3.新建查询，查询里可以运行sql语句 左键按住选中执行这4条insert语句，点击执行后打开user表，在user中如果没显示数据，右键刷新即可
INSERT into user VALUES(1,'阿里',1); INSERT into user VALUES(2,'阿白',12); INSERT into user VALUES(3,'阿强',123); INSERT into user VALUES(4,'阿明',1234); 4.开始执行事务 1）在执行事务前，检查自动提交是不是off(autocommit=off)，如果不是则要调成off,不然事务就没有作用了，运行的语句都会自动修改到表里，而不是暂时储存，等到我们自己commit提交 show VARIABLES like 'autocommit' 2）设置autocommit=off set autocommit = off set autocommit = off/0（这里off和0是一样的效果）
set autocommit = on/1(on是把autocommit打开),
但此处只需要set autocommit = off
3)写好sql语句，注意实现事务的sql语句运行顺序 START TRANSACTION; INSERT into user VALUES(28,'安DANNSDN',12345); SAVEPOINT AA; DELETE FROM `user` where password='12345'; ROLLBACK; COMMIT; SELECT * FROM `user`; select * from user; 注意：rollback(回滚)和commit不能同时运行！！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16ad84f7e38eeaa270733f0fbc88fdf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd6af0ef4a2db654bb6f40a6b55a1af/" rel="bookmark">
			文心一言API调用，保姆级案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一个调用文心一言API的案例。今天自己用程序去过去文心一言模型中获取结果。 文心一言API调用如何收费？ 官方给送了20块钱的体验券！
后续收费规则如下
如何开通所需要要的 API key 和 Secret key？ api调用需要先在千帆平台开通API key 。这里根据教程中一步一步操作即可开通成功。
文心一言API使用教程（python版） - 百度智能云千帆社区
调用文心一言的代码 python 这里是调用文心一言的代码。包含引入依赖。都有提供。
使用langchain接入文心一言API - 百度智能云千帆社区
验证效果 我的测试代码 我的需求是根据一段文本内容，生成QA对儿。
from langchain.schema import ( AIMessage, HumanMessage, ) from langchain_wenxin import ChatWenxin WENXIN_APP_Key = "your app key" WENXIN_APP_SECRET = "your secret key" chat_model = ChatWenxin( temperature=0.9, model="ernie-bot-turbo", baidu_api_key = WENXIN_APP_Key, baidu_secret_key = WENXIN_APP_SECRET, verbose=True, ) # 这里是我的需求，我需要根据一段内容，生成QA。 response = chat_model( [ HumanMessage(content="请根据以下内容为我生成3-5个相关的问题，注意一定要根据我给的内容生成问题和答案。并给出对应的答案，答案要根据我给的内容生成不要自己生成。问题和答案，请给我json格式。内容如下“第三章 调查准备第十条 中国人民银行及其省一级分支机构发现符合本实施细则第六条的可疑交易活动时，应当登记，作为反洗钱调查的原始材料，妥善保管、存档备查。第十一条 中国人民银行及其省一级分支机构对可疑交易活动进行初步审查，认为需要调查核实的，应填写《反洗钱调查审批表》(见附 2)，报行长(主任)或者主管副行长(副主任)批准”"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd6af0ef4a2db654bb6f40a6b55a1af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99816a69769cfb2d8dae900f50b9d230/" rel="bookmark">
			Spark on YARN部署模式保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、基础环境（可根据自己的环境进行调整）
三、安装包下载及解压
1.下载压缩包及上传
2.上传压缩包
3.解压
四、配置环境变量
五、Spark的配置
六、配置worker节点
七、启动Spark集群
八、测试用例
九、关闭集群
一、引言 Local模式：这种模式主要用于本地开发和测试。它可以启动一个或多个执行器，具体取决于你是否使用"local"还是"local [n]"来启动Spark应用。"local"模式表示利用本节点单核单线程运行，而"local [n]"则表示利用本节点多核多线程运行。
Standalone模式：这是独立模式，自带完整的服务，可以单独部署到一个集群中，无需依赖任何其他资源管理系统。从一定程度上说，该模式是其他三种模式的基础。目前Spark在Standalone模式下是没有任何单点故障问题的，这是借助ZooKeeper实现的。
Yarn模式：这种模式运行在YARN资源管理器框架之上，由YARN负责资源管理，Spark负责任务调度和计算。
Mesos模式：这种模式运行在Mesos资源管理器框架之上，由Mesos负责资源管理，Spark负责任务调度和计算。
Kubernetes模式：这是一种较新的部署模式，将Spark应用部署到Kubernetes集群中。
没有最好的部署模式，具体要根据实际需求进行部署，由于Spark可以和Hadoop部署在一起，相互协作，Hadoop的HDFS，HBase负责数据存储与管理，Spark负责数据的计算，所以本文将详细讲解Spark on YARN模式的部署。
二、基础环境（可根据自己的环境进行调整） 1. Linux系统，CentOS7.6及以上
2. Hadoop3.3.5
3.JDK1.8版本及以上
4. spark3.4.0
5.集群架构
Hadoop集群架构Spark架构 IPmasterMaster节点192.168.244.131hadoop01Worker节点192.168.244.132hadoop02Worker节点192.168.244.133 三、安装包下载及解压 1.下载压缩包及上传 访问Spark官网下载页面 Index of /dist/spark (apache.org)https://archive.apache.org/dist/spark/
由于此前我们已经安装了Apache Hadoop3.3.5，所以，下载“
spark-3.4.0-bin-hadoop3-scala2.13.tgz 即可。
补充：
spark-3.4.0-bin-without-hadoop.tgz：这个版本是用于没有安装Hadoop环境下的Spark安装包。
spark-3.4.0-bin-hadoop3-scala2.13.tgz：这个版本是专为安装了Hadoop 3.x版本且使用Scala 2.13的用户而设计的。
spark-3.4.0-bin-hadoop3.tgz：这个版本则是为已经安装了Hadoop 3.x版本的用户提供的。
spark-3.4.0.tgz：这是Spark 3.4.0版本的通用安装包，适用于多种环境和组合。
2.上传压缩包 通过xftp或rz命令将压缩包上传到Linux的/export/software目录
3.解压 $ tar -zxvf /export/software/spark-3.4.0-bin-hadoop3-scala2.13.tgz -C /export/servers $ cd /export/servers $ ln -s spark-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99816a69769cfb2d8dae900f50b9d230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a375313de520823e60f9e48af5d0673e/" rel="bookmark">
			java解压缩(上传和下载)zip压缩包[超详细]包含[前后端]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在日常中，我们想在没有网络的情况下进行将一个项目中的数据，导入另一个项目中，从而实现数据之前的转换和迁移。这时候，我们可以通过生成压缩包，和解压zip压缩包的形式，将数据进行各种迁移，接下来就让我们开始吧。
一、生成(下载)zip压缩包 1、前端代码 因为我使用的是vue2，所以就按照vue2的形式来编写了，其实就是一个点击按钮，对应的点击事件的方法。具体项目具体分析即可
&lt;a-button @click="sendToThreePlatform" type="danger" ghost icon="upload"&gt;生成zip压缩包&lt;/a-button&gt; &lt;!-- 下面的代码就是sendToThreePlatform函数方法，具体项目具体分析--&gt; export default { methods:{ sendToThreePlatform(){ // params理解为参数 let params = { projectId: this.selectedMainId, } this.$message.loading({ content: '请稍等...', key: 'Zip', duration: 0 }) //自己封装的ajax方法，你可以使用原始的ajax // 参数1：url；参数2：形参 getAction(this.url.deriveThreeStagePlatform, params).then((res) =&gt; { if (res.success) { // window.open(getFileAccessHttpUrl(res.result)) this.$message.success({ content: '下载开始', key: 'Zip', duration: 1 }) if (typeof window.navigator.msSaveBlob !== 'undefined') { //允许用户在客户端上下载文件 参数1：生成数据，参数2：指定文件名称 //data 和fileName是我自己封装好的数据，具体，你可以在百度上搜索一下msSaveBlob如何使用 window.navigator.msSaveBlob(new Blob([data]), fileName) } else { //下面步骤可以理解为：生成一个下载链接，下载完成之后将改标签删除。 //获取文件服务访问路径 let url = getFileAccessHttpUrl(res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a375313de520823e60f9e48af5d0673e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/533/">«</a>
	<span class="pagination__item pagination__item--current">534/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/535/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>