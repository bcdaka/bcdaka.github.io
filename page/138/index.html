<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e197e76ca558c002e1b2790c71fdf0/" rel="bookmark">
			代码随想录学习 day54 图论 Bellman_ford 队列优化算法（又名SPFA） 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bellman_ford 队列优化算法（又名SPFA） 卡码网：94. 城市间货物运输 I 题目描述 某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。 网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。 权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。 请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。 如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。 城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。 负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。 输入描述 第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。 接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v（单向图）。 输出描述 如果能够从城市 1 到连通到城市 n， 请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市 1 没有路径可达城市 n，请输出 "unconnected"。 输入示例： 6 7 5 6 -2 1 2 1 5 3 1 2 5 2 2 4 -3 4 6 4 1 3 5 思路 背景 本题我们来系统讲解 Bellman_ford 队列优化算法 ，也叫SPFA算法（Shortest Path Faster Algorithm）。 SPFA的称呼来自 1994年西南交通大学段凡丁的论文，其实Bellman_ford 提出后不久 （20世纪50年代末期） 就有队列优化的版本，国际上不承认这个算法是是国内提出的。 所以国际上一般称呼 该算法为 Bellman_ford 队列优化算法（Queue improved Bellman-Ford） 大家知道以上来历，知道 SPFA 和 Bellman_ford 队列优化算法 指的都是一个算法就好。 如果大家还不够了解 Bellman_ford 算法，强烈建议按照《代码随想录》的顺序学习，否则可能看不懂下面的讲解。 Bellman_ford 算法每次松弛 都是对所有边进行松弛。 但真正有效的松弛，是基于已经计算过的节点再做的松弛。 给大家举一个例子： 本图中，对所有边进行松弛，真正有效的松弛，只有松弛 边（节点1-&gt;节点2） 和 边（节点1-&gt;节点3） 。 而松弛 边（节点4-&gt;节点6） ，边（节点5-&gt;节点3）等等 都是无效的操作，因为 节点4 和 节点 5 都是没有被计算过的节点。 所以 Bellman_ford 算法 每次都是对所有边进行松弛，其实是多做了一些无用功。 只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边进行松弛就够了。 基于以上思路，如何记录 上次松弛的时候更新过的节点呢？ 用队列来记录。（其实用栈也行，对元素顺序没有要求） 模拟过程 接下来来举例这个队列是如何工作的。 以示例给出的所有边为例： 5 6 -2 1 2 1 5 3 1 2 5 2 2 4 -3 4 6 4 1 3 5 我们依然使用minDist数组来表达 起点到各个节点的最短距离，例如minDist[3] = 5 表示起点到达节点3 的最小距离为5 初始化，起点为节点1， 起点到起点的最短距离为0，所以minDist[1] 为 0。 将节点1 加入队列 （下次松弛从节点1开始） 从队列里取出节点1，松弛节点1 作为出发点连接的边（节点1 -&gt; 节点2）和边（节点1 -&gt; 节点3） 边：节点1 -&gt; 节点2，权值为1 ，minDist[2] &gt; minDist[1] + 1 ，更新 minDist[2] = minDist[1] + 1 = 0 + 1 = 1 。 边：节点1 -&gt; 节点3，权值为5 ，minDist[3] &gt; minDist[1] + 5，更新 minDist[3] = minDist[1] + 5 = 0 + 5 = 5。 将节点2、节点3 加入队列，如图： 从队列里取出节点2，松弛节点2 作为出发点连接的边（节点2 -&gt; 节点4）和边（节点2 -&gt; 节点5） 边：节点2 -&gt; 节点4，权值为1 ，minDist[4] &gt; minDist[2] + (-3) ，更新 minDist[4] = minDist[2] + (-3) = 1 + (-3) = -2 。 边：节点2 -&gt; 节点5，权值为2 ，minDist[5] &gt; minDist[2] + 2 ，更新 minDist[5] = minDist[2] + 2 = 1 + 2 = 3 。 将节点4，节点5 加入队列，如图： 从队列里出去节点3，松弛节点3 作为出发点连接的边。 因为没有从节点3作为出发点的边，所以这里就从队列里取出节点3就好，不用做其他操作，如图： 从队列中取出节点4，松弛节点4作为出发点连接的边（节点4 -&gt; 节点6） 边：节点4 -&gt; 节点6，权值为4 ，minDist[6] &gt; minDist[4] + 4，更新 minDist[6] = minDist[4] + 4 = -2 + 4 = 2 。 将节点6加入队列 从队列中取出节点5，松弛节点5作为出发点连接的边（节点5 -&gt; 节点3），边（节点5 -&gt; 节点6） 边：节点5 -&gt; 节点3，权值为1 ，minDist[3] &gt; minDist[5] + 1 ，更新 minDist[3] = minDist[5] + 1 = 3 + 1 = 4 边：节点5 -&gt; 节点6，权值为-2 ，minDist[6] &gt; minDist[5] + (-2) ，更新 minDist[6] = minDist[5] + (-2) = 3 - 2 = 1 因为节点3 和 节点6 都曾经加入过队列，不用重复加入，避免重复计算。 在代码中我们可以用一个数组 visited 来记录入过队列的元素，加入过队列的元素，不再重复入队列。 从队列中取出节点6，松弛节点6 作为出发点连接的边。 节点6作为终点，没有可以出发的边。 所以直接从队列中取出，如图： 这样我们就完成了基于队列优化的bellman_ford的算法模拟过程。 大家可以发现 基于队列优化的算法，要比bellman_ford 算法 减少很多无用的松弛情况，特别是对于边数众多的大图 优化效果明显。 了解了大体流程，我们再看代码应该怎么写。 在上面模拟过程中，我们每次都要知道 一个节点作为出发点连接了哪些节点。 如果想方便知道这些数据，就需要使用邻接表来存储这个图，如果对于邻接表不了解的话，可以看 kama0047.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e197e76ca558c002e1b2790c71fdf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b476b0694407c8807c4c9cc12c18ea27/" rel="bookmark">
			AI让老照片动起来，日赚500&#43;，爆火项目拆解近，AI技术让老照片动起来火爆网络。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近AI技术让老照片动起来火爆全网。
老照片动起来是什么？怎么做？怎么赚钱？
接下来，我将为你详细解析。读完这篇文章，你将明白这个项目背后的商业潜力！
项目实操和工具扫描下方，免费获取
一、老照片动起来项目介绍 结合动态人物视频和怀旧音乐，能够迅速唤起人们的情感共鸣。每个人都有自己的回忆，无论是青春岁月还是亲人的笑脸，这样的内容总能触动人心。无论是在抖音、小红书还是视频号上分享，都能迅速吸引大量关注。这就是老照片动起来项目的魔力所在！
二、老照片动起来项目优势 项目热度高这一点显而易见，目前这个项目在网络上的热度极高。高热度意味着巨大的流量和商机，无论是增加粉丝还是实现变现，都能达到事半功倍的效果。内容制作简便与传统的视频制作相比，老照片动起来项目的制作流程非常简单。只需对老照片进行翻新上色，再生成动态视频并进行简单剪辑，整个过程大约20分钟就能完成。长期可持续性正如我在文章开头提到的，老照片修复和动起来服务一直有市场需求。即使热潮退去，这个项目依然可以作为一个长期运营的业务。你可以在电商平台搜索"老照片"，看看相关店铺的月销量，便知市场潜力。 三、老照片动起来项目如何变现 小红书视频号平台分成最直接的变现方式是通过小红书商单和视频号创作者分成。小红书粉丝达到1000即可接商单，视频号也可以参与创作分成计划。前期可以通过免费为用户制作视频来吸引关注，实现快速增粉。 2.代做视频服务只要有作品曝光，就会有人找你制作AI视频。市场价在50元到80元之间，每单都是纯利润。这种涉及人类情感的产品，很容易促成交易。
3.知识付费老照片动起来项目已经在网络上引起了广泛关注，除了感动的用户，还有许多对此感兴趣的创业者。因此，我们可以将这个项目制作成课程或提供教学服务，在私域进行销售。
关于AI绘画技术储备 学好 AI绘画 不论是就业还是做副业赚钱都不错，但要学会 AI绘画 还是要有一个学习规划。最后大家分享一份全套的 AI绘画 学习资料，给那些想学习 AI绘画 的小伙伴们一点帮助！
对于0基础小白入门：
如果你是零基础小白，想快速入门AI绘画是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：stable diffusion安装包、stable diffusion0基础入门全套PDF，视频学习教程。带你从零基础系统性的学好AI绘画！
零基础AI绘画学习资源介绍 👉stable diffusion新手0基础入门PDF👈 （全套教程文末领取哈）
👉AI绘画必备工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉AI绘画基础+速成+进阶使用教程👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉12000+AI关键词大合集👈 这份完整版的AI绘画全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8456d05bb7b86bbfb351fe700acf029/" rel="bookmark">
			秋叶大佬24年最新的Stable Diffusion整合包V4.8来了～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要说今年绘画圈最大的新秀
那妥妥的就Stable Diffution
V4升级版无需安装**，直接解压就能用**
*（在此要感谢秋葉aaaki大佬的分享！*）
比之前推送的更加智能、快速和简单
有多简单呢？这么说吧
之前的版本需要初中生级别
现在的V4加强版小学生也能上手！
SD安装包获取
1
背景信息 ▍****Stable Diffusion 是什么？ Stable Diffusion（简称SD）是一种生成式人工智能，于2022年发布，主要用于根据文本描述生成详细图像，也可用于其他任务，如图像的修补、扩展和通过文本提示指导图像到图像的转换。除图像外，您还可以使用该模型创建视频和动画。
这是AI绘画第一次能在可以在消费级显卡上运行，任何人都可以下载模型并生成自己的图像。另外，SD高质量的成图以及强大的自由度（自定义、个性化）受到诸多网友的追捧。Stable
Diffusion XL 1.0 (SDXL 1.0) 是Stable Diffusion的一个更为高级和优化的版本，它在模型规模、图像质量、语言理解和模型架构等方面都有显著的改进。
▍****Stable Diffusion 能做什么？ 首先，大家在入坑SD前，务必要清楚现阶段的SD到底能做什么？能否满足自己的需求？
Stable Diffusion 功能包括文本转图像、图像转图像、图形插图、图像编辑和视频创作。
**文本转图像生成：**最常见和最基础的功能。Stable Diffusion 会根据文本提示生成图像。图像转图像生成使用输入图像和文本提示，您可以根据输入图像创建新图像。典型的案例是使用草图和合适的提示。创作图形、插图和徽标使用一系列提示，可以创建各种风格的插图、图形和徽标。图像编辑和修正可以使用 Stable Diffusion 来编辑和修正照片。例如，可以修复旧照片、移除图片中的对象、更改主体特征以及向图片添加新元素。视频创作使用 GitHub 中的 Deforum 等功能，可以借助 Stable Diffusion 创作短视频片段和动画。另一种应用是为电影添加不同的风格。 还可以通过营造运动印象（例如流水）来为照片制作动画。 2
安装和部署Stable Diffusion **
**
介绍如何安装和部署Stable Diffusion。我使用的是秋葉aaaki的整合包，文章末尾提供180G整合包～
**
**
电脑系统：Windows10及以上/macOS Monterey (12.5)。
显卡：RTX3060及以上。
显存：8G及以上。
内存：16G及以上。
磁盘空间：500 SSD及以上
▍****操作步骤 步骤一：右键解压Stable Diffusion安装包。
步骤二：双击Stable Diffusion安装包进入文件夹中，解压sd-webui-aki-v4.2。
步骤三：双击启动器运行依赖-dotnet-6.0.11，安装所需依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8456d05bb7b86bbfb351fe700acf029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0a5359cd1b21af0651b537e377134f/" rel="bookmark">
			51.2T 800G 以太网交换机，赋能AI开放生态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IB与以太之争 以太网替代IB趋势明显。据相关报告：2024年TOP500的超算中，采用以太网方案占比48.5%，InfiniBand占比为39.2%，其中排名前6的超算中已有5个使用以太网互联。
开放系统战胜封闭系统仅是时间问题。我们已经看到，以太网借助其与生俱来的开放性迅速弥合了与InfiniBand的差距，如采用RoCEv2技术路线的星融元CX732Q-N（400G）超低时延交换机，已在多次严格的现场测试中表现出与InfiniBand交换机相当的性能。
以太网走向800G时代 从GPT-1到GPT-4，模型参数数量已从1.1亿增长到5000亿，甚至可能超过万亿。
然而，在部署超算集群的算力中心，先进芯片和先进算力并不对等，算力芯片只提供算力，而先进算力其实遵循着“木桶效应”——算力、存储和网络三个核心环节，出现一个短板会使整个系统的性能出现巨大的下滑。正因如此，800G以太网的推出势在必行。
近年来IEEE（电气电子工程师协会）、OIF（光网络互联论坛）等标准组织相继制定了400G网络的标准，为800G网络的发展奠定了基础。
800G 以太网发展大事记
年份主要事件2022首款 51.2T 交换芯片发布；网络行业迎来了重要的里程碑。这些交换芯片将支持64个800Gb/s端口，标志着800G以太网发展进入实体化落地阶段。与此同时，首批800G光模块的验证也在此期间开始。2023标准发布和开发验证；IEEE发布了IEEE 802.3df标准的第一版，该标准定义了800G以太网的物理层规范。与此同时，OIF还发布了224 Gb/s标准，为800G和1.6T系统构建112 Gb/s和224 Gb/s通道提供了指导方针。2024-2026预计将确认800G以太网的物理层标准，进一步完善和测试规范，以确保网络设备的互操作性和高性能。 星融元超低时延800G以太网交换机 CX864E-N是一款行业顶尖规格的单芯片盒式以太网交换机，专为AI训练/推理、高性能计算（HPC）和云计算/存储的需求设计，具有业界领先的低延迟和高可靠性，是AI时代下智算中心的首选。它拥有 51.2T 的超大交换容量和 64x800G 的端口密度，可构建超大规模数据中心，并在更优的投入成本下提供与 InfiniBand 网络相当的端到端性能。
CX864E-N符合UEC（超以太网联盟）标准，具有丰富全面的 API，便于与数据中心和HPC集群的无缝集成，其作为厂商中立的网络设备亦可兼容其他主流厂商的GPU和网卡硬件。
亮点
单芯片51.2T 高密端口以太网交换机，极简的硬件设计，在2RU 空间可提供 64x800G OSFP 或 128x400G/512x100G全端口支持RoCE（基于融合以太网的RDMA）以及用于简化无损以太网配置管理的Easy RoCE行业速度最快的交换机，兼容400G和800G，800GE 端口转发延迟低于 560 纳秒满流量负载下64x800G SR8 端口的最大 TDP 为 2200200+MB 的大型片上缓冲区可实现更好的 RoCE 无损以太网性能10ns PTP 和 SyncE 性能，支持严格时间同步的 AI 并行计算先进的 INT（带内网络遥测）提供更加实时精确的数据包延迟、丢包和路径数据，助力实现更先进的拥塞控制算法搭载企业就绪的SONiC 发行版 AsterNOS，提供一站式的开放网络解决方案；功能容器化软件架构让操作系统更加强大、可靠，且易于二次开发和定制兼容来自业界主流供应商的异构 GPU 和 SmartNIC线速可编程，平滑支持不断演进的 UEC（超以太网联盟）标准 系列化交换机产品，构建中立、开放的一站式高性能AI网络 星融元成立于2017年，是国内领先的互联软硬件解决方案提供商。自成立以来，星融元上百名SONiC 研发专家组成的专业团队一直专注于打造世界上最好的SONiC 网络操作系统——最终成果便是 AsterNOS。基于此，星融元推出了1G-800G的系列化交换机，全面覆盖从PoE接入到大规模AI训练的网络互联场景。
经过多年的技术积淀和迭代，星融元已在国内外AI算力中心、云服务商、垂直行业、园区网等多场景头部客户实现落地，为移动云、国家电网、人民银行等海内外上千家客户提供完整网络互联方案，并在年初以第一名身份中标中国移动2023-2024年白盒交换机集采。
面向新时代下的新需求和新挑战，星融元仍将积极拥抱开放生态，持续为用户构建中立透明、易于运维、高性价比的AI基础网络。
关注vx公号“星融元Asterfusion”，获取更多技术分享和最新产品动态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f48b1557fe4faf54eaeedb8e36efa2/" rel="bookmark">
			SwiftUI 6.0（Xcode 16）新 PreviewModifier 协议让预览调试如虎添翼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概览 用 SwiftUI 框架开发过应用的小伙伴们都知道，SwiftUI 中的视图由各种属性和绑定“扑朔迷离”的缠绕在一起，自成体系。
想要在 Xcode 预览中泰然处之的调试 SwiftUI 视图有时并不是件容易的事。其中，最让人秃头码农们头疼的恐怕就要数如何正确的向预览传入视图内部的状态了。
在本篇博文中，您将学到如下内容： 概览1. PreviewModifier 到底有啥用？2. 用 PreviewModifier “点缀”预览视图外观3. PreviewModifier 诞生之前我们如何向预览传送数据？4. 用 PreviewModifier 注入（inject）预览模拟数据总结 遵循 SwiftUI 6.0（Xcode 16）新推出的 PreviewModifier 协议，正可谓是：“你好，我好，大家都好”。
不信？且看分晓！Let‘s go！！！😉
1. PreviewModifier 到底有啥用？ 从 SwiftUI 6.0 开始，顺便借助 Xcode 16 的东风，苹果推出了全新的 PreviewModifier 协议：
正如该协议“自夸”的那样：PreviewModifier 可以让 Xcode 预览（Preview）界面和调试数据“浑然天成，融洽无间”。
有了 PreviewModifier，我们即可从两个方面来为预览调试“雪中送炭”：
统一改变预览中视图的外观；为预览视图传入模拟测试数据； 下面，就让我们依次来看看它们究竟是如何“大施拳脚”的吧。
2. 用 PreviewModifier “点缀”预览视图外观 假若我们希望 Xcode 预览中某些被调试的视图都放在导航容器中，并且根据实际情况增加导航标题和导航栏 Logo。
注意，这些视图的 body 代码自身并没有嵌入到导航视图内，因为这是使用它们的父视图份内的事儿。这意味着，我们必须繁文缛节的在所有预览中将这些视图嵌入到导航视图中去：
#Preview { NavigationStack { ContentView() .navigationTitle("SwiftUI 滚动行为演示") .toolbar { Text("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82f48b1557fe4faf54eaeedb8e36efa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca72e33a39602fb225f07582fa54291/" rel="bookmark">
			【银河麒麟服务器操作系统】java进程oom现象分析及处理建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解银河麒麟操作系统更多全新产品，请点击访问麒麟软件产品专区：https://product.kylinos.cn
现象描述 某服务器系统升级内核至4.19.90-25.22.v2101版本后仍会触发oom导致java进程被kill。
现象分析 oom现象分析 系统messages日志分析，故障时间2024.3.2 13：45左右，如图1：
图1
从下面的日志信息，可以看到java进程是在内核采用GFP_KERNEL|__GFP_COMP分配order=3也就是2的3次方，8个连续页的时候，系统无法提供对应大小的连续内存页，导致oom产生并选择java进程进行kill掉了。
现在来分析这一现像是否为正常现像（因为oom是内核的正常的机制），GFP_KERNEL的首先内存管理区为ZONE_NORMAL。从日志可以看出，当前系统一共有3个内存管理区，分别是ZONE_DMA、ZONE_DMA32和ZONE_NORMAL。接下来分析这个3个内存管理区的内存使用情况：
1)ZONE_DMA的空闲内存是15876kB , 最低水位是32k，低水位是44k, 高水位是56k, 空闲内存远大于高水位，所以kswapd是不会启动回收的，但是Linux内核有一个对低端内存管理区的保护机制，lowmem_reserve中有体现，加上保护机制，最低水位为：32K + 30759*4KB=123068KB，这个数据比空闲内存15876KB要大了，所以ZONE_DMA是不能分配成功的。
Mar 22 13:45:18 wzhapp13 kernel: [6229155.126208] Mem-Info:
Mar 22 13:45:18 wzhapp13 kernel: [6229155.126213] active_anon:1656544 inactive_anon:541287 isolated_anon:0#012 active_file:307018 inactive_file:548893 isolated_file:0#012 unevictable:0 dirty:136 writeback:0 unstable:0#012 slab_reclaimable:3601440 slab_unreclaimable:525232#012 mapped:39889 shmem:22418 pagetables:10064 bounce:0#012 free:124343 free_pcp:63 free_cma:0
Mar 22 13:45:18 wzhapp13 kernel: [6229155.126215] Node 0 active_anon:6626176kB inactive_anon:2165148kB active_file:1228072kB inactive_file:2195572kB unevictable:0kB isolated(anon):0kB isolated(file):0kB mapped:159556kB dirty:544kB writeback:0kB shmem:89672kB shmem_thp: 0kB shmem_pmdmapped: 0kB anon_thp: 6649856kB writeback_tmp:0kB unstable:0kB all_unreclaimable?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca72e33a39602fb225f07582fa54291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f87153a249295ee045adc38061f2cbb1/" rel="bookmark">
			Apache Kylin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Kylin 是一个开源的分布式分析引擎，提供 SQL 查询接口及多维分析（OLAP）能力以支持超大规模数据集。它能在亚秒级的时间内提供 PB 级数据的查询能力，非常适合大数据分析和报表系统。
### 入门指南
#### 1. 环境准备
首先，你需要准备一个适合 Apache Kylin 运行的环境。Kylin 基于 Hadoop 生态系统，因此你需要有 Hadoop、Hive、Zookeeper 和 HBase 的运行环境。此外，Kylin 还需要一个元数据存储数据库，如 MySQL 或 PostgreSQL。
#### 2. 下载与安装
从 Apache Kylin 的官方网站下载最新稳定版本的二进制包。解压后，按照官方文档的指导进行配置，包括设置环境变量、配置文件等。
#### 3. 启动 Kylin
在配置好环境之后，你可以启动 Kylin Server 和 Web UI。通常，这可以通过运行`bin/kylin.sh start`来完成。
#### 4. 构建 Cube
Cube 是 Kylin 中的数据结构，用于存储预计算的结果，以加速查询。你需要定义一个 Cube 的模型，指定数据源、维度、度量以及聚合方式。然后，使用 Kylin 的工具或 Web UI 来构建 Cube。
#### 5. 数据加载
在构建 Cube 之前，你需要将数据加载到 Hive 表中。Kylin 可以直接查询 Hive 表，但为了获得最佳性能，通常建议将数据进行分区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f87153a249295ee045adc38061f2cbb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d959d8c459d8dae5bd0afa11de2176/" rel="bookmark">
			Blackbox AI：你的智能编程伙伴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Blackbox AI 产品介绍
Blackbox AI 产品使用教程
Blackbox AI体验
AI问答
代码验证
实时搜索
探索&amp;代理
拓展集成
总结
Chat Blackbox: AI Code Generation, Code Chat, Code SearchBLACKBOX AI is the Best AI Model for Code. Millions of developers use Blackbox Code Chat to answer coding questions and assist them while writing code faster. Whether you are fixing a bug, building a new feature or refactoring your code, ask BLACKBOX to help.BLACKBOX has real-time knowledge of the world, making it able to answer questions about recent events, technological breakthroughs, product releases, API documentations &amp; moreBLACKBOX integrates directly with VSCode to automatically suggests the next lines of code based on your repo context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85d959d8c459d8dae5bd0afa11de2176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718da317cc378c5d833ac21f78ccd1ae/" rel="bookmark">
			【C语言初阶】C语言函数全解析：编写高效代码的秘密武器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C语言 “ 登神长阶 ”
🤡往期回顾🤡：C语言分支与循环语句
🌹🌹期待您的关注 🌹🌹
❀函数 📒1. C语言中函数的分类🎩库函数🎈自定义函数 📙2. 函数的参数🔍实际参数（实参）🔄形式参数（形参） 📕3. 函数的调用🌞传值调用🌙传址调用⭐调用练习 📚4. 函数的嵌套调用和链式访问🌸嵌套调用🌺链式访问 📜5. 函数的声明和定义🍁函数声明🍂函数定义 📝6. 函数递归🏞️递归的两个必要条件🧩递归练习 🌄递归与迭代🧩递归练习 📖7. 总结 前言： 在探索编程世界的浩瀚星图中，C语言无疑是一颗璀璨夺目的星辰，它不仅奠定了现代计算机编程语言的基础，更是无数软件与系统背后的基石。自其诞生以来，C语言以其高效、灵活、接近硬件的特性，赢得了开发者们的广泛青睐与深厚情感。而在这门语言的浩瀚海洋中，函数（Function）则是航行者手中的罗盘与风帆，指引着代码的方向，驱动着程序的运行
函数，作为C语言中最基本也是最强大的构建块之一，它不仅仅是一段可以重复使用的代码集合，更是模块化编程思想的集中体现。通过定义函数，我们能够将复杂的任务分解成一系列简单、易于理解和维护的子任务，这不仅提高了代码的可读性和可维护性，还促进了代码的重用，使得软件开发过程更加高效有序
在本文中，我们将踏上一场关于C语言函数的探索之旅，揭开其神秘面纱，一窥其内部结构与工作原理。我们将从函数的基本概念出发，逐步深入到函数的定义、声明、调用以及参数传递等核心知识点，通过生动的例子和详细的解析，帮助读者构建起对C语言函数全面而深刻的理解
让我们一同踏上这段充满挑战与收获的C语言函数之旅吧！
📒1. C语言中函数的分类 库函数自定义函数 🎩库函数 库函数是将一些常用到的函数编完放到一个文件（通常是库文件，如lib文件）里，供其他人或程序进行调用的方式。这些函数一般是编译器提供的，可以在C源程序中直接调用。库函数极大地方便了用户，同时也补充了C语言本身的不足
C语言常用的库函数：
IO函数字符串操作函数字符操作函数内存操作函数时间/日期函数数学函数其他库函数 库函数必须知道的一个秘密就是：使用库函数，必须包含 #include 对应的头文件
推荐一个C/C++查询库函数的网址：库函数
🎈自定义函数 自定义函数是编程中非常重要的一个概念，它允许程序员根据自己的需求创建特定的函数来执行一系列操作或计算。这些函数可以在程序中多次调用，提高了代码的重用性和可维护性，给程序员一个很大的发挥空间
函数的组成：
ret_type fun_name(para1, * ) { ......;//语句项 } ret_type 返回类型 fun_name 函数名 para1 函数参数 我们来简单定义几个函数
函数定义代码示例：
//获取最大值函数的设计 int get_max(int x, int y) { return (x &gt; y) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718da317cc378c5d833ac21f78ccd1ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed70cee072e078ff9bc4f9ba59a2ab8/" rel="bookmark">
			数据仓库实践：使用 SQL 计算材料BOM成本单价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在制造业财务数据分析建设过程中，有时需要通过BOM汇总计算材料的单价，一般会有采购核价，库存成本，还有下阶材料单价按用量汇总得到的单价参与。
这些单价来源一般会根据优先级获取并在计算后作为最终的BOM 单价结果。参与财务三大报表中的损益表计算。
获取数据：采购核价、币种和汇率 采购核价 核价一般会包括成品和底层材料，而且优先级一般会比较高，所以这里直接使用核价的方式设置一个成品的单价，以用于测试。
库存成本 除了采购核价外，库存成本一般是覆盖范围比较广的单价，能够覆盖到最底层的大量材料料号。
这里我们在初始化时设置最底层材料成本时，将使用库存成本金额。
币种 为了兼容多个货币和地区，价格会有一个字段表示币种。金额则是此币种的单价金额。
同时需要带上一个汇率明细。以满足各个币种单价金额的汇算。
获取数据：BOM汇总结构 初始化时使用核价和成本单间仍然不能完全覆盖企业内使用的所有的材料，尤其是BOM结构复杂、材料料号过多的情况下。
所以一般情况下，企业会使用BOM关系，将材料的单价汇总计算到上阶材料。
本文将使用 bom 结构重新汇总后的BOM数据分析维度，具体可见：
数据仓库实践：使用SQL汇总BOM数据分析维度 http://t.csdnimg.cn/gZ1pS
部分 dim_bom 结构
初始化 使用BOM关联并计算核价和成本单价
insert into dw_mt_bom_unit_price_mview(material_code_prod, material_code, currency_cost, price_cost_ori, price_cost, currency_verify, price_verify_ori, price_verify, price_calculate) select * from (with tmp_prod as (select material_code material_code_prod, material_code, null currency_cost, null as price_cost_ori, null as price_cost, c.currency_verify, c.price_verify as price_verify_ori, d.exchange_rate * IFNULL(c.price_verify, 0) as price_verify, null price_calculate from (select distinct bom_subordinate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed70cee072e078ff9bc4f9ba59a2ab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93530b19509d19b00eee70f5baafc1f3/" rel="bookmark">
			解密AI绘画与修图： Stable Diffusion&#43;Photoshop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是爱编程的喵喵。双985硕士毕业，现担任全栈工程师一职，热衷于将数据思维应用到工作与生活中。从事机器学习以及相关的前后端开发工作。曾在阿里云、科大讯飞、CCF等比赛获得多次Top名次。现为CSDN博客专家、人工智能领域优质创作者。喜欢通过博客创作的方式对所学的知识进行总结与归纳，不仅形成深入且独到的理解，而且能够帮助新手快速入门。
本文主要介绍了解密AI绘画与修图： Stable Diffusion+Photoshop，希望能对同学们有所帮助。
文章目录 1. 前言2. 书籍推荐2.1 内容简介2.2 本书作者2.3 本书目录 3. 购买链接 1. 前言 在不到两年的时间里，生成式AI（Artificial Intelligence，人工智能）绘画已经从一个实验性的概念迅速发展成为拥有数千万用户的实用工具。如今，生成式AI绘画已经在摄影、电商、自媒体、设计等领域得到广泛的运用。使用ChatGPT进行写作，利用Stable Di?usion画图已经成为许多人的常用做法。按照目前的应用情况，相信过不了多久，AI绘画工具将像Photoshop一样成为计算机的必备软件，每个计算机用户或多或少都会掌握其中的一些相关技能。
AI绘画的最大意义在于实现了艺术创作的普及化，使每个人都能拥有艺术创作的能力。及早从“车夫”转换成“司机”，才能跟上时代的发展步伐。绘图领域的AI工具层出不穷，其中，Photoshop和Stable Diffusion是大多数国内用户的首选。Photoshop的优势不言而喻，但使用创成式填充（Generative Fill）、生成式扩展（Generative Expand）等AI功能生成的内容完全随机，创作过程更像抽奖，而且国内用户还无法使用。Stable Diffusion具有强大的图像生成能力，不仅可以精确控制生成的内容，还能部署到自己的计算机中，免费且没有网络限制。将两者结合，甚至进一步利用插件把Stable Diffusion集成到Photoshop中，就能完全打通图像生成和后期处理的环节，大幅提升创作效率。
2. 书籍推荐 因此，像《解密AI绘画与修图：Stable Diffusion+Photoshop》这样一本全面且系统地介绍AI绘画与修图的书是非常必要的。
本书不仅详尽讲解了Stable Diffusion的各项功能，以及ControlNet、SadTalker、AnimateDiff等插件的具体使用方法，还介绍了如何在Photoshop中直接调用Stable Diffusion，以更快、更好地实现对象移除、创成式填充、外绘扩图、草图上色、艺术字体和海报创作等功能。另外，本书还通过实例完整复盘了影楼级AI摄影、小说推文封面设计、电商商品主图制作以及卡通和数字人形象打造的全过程。
本书配套资源文件中包含了丰富的素材，包括4K、60帧的全程语音视频教学文件，以及全书案例用到的所有图片素材。此外，还提供了ControlNet的所有预处理器模型和控制模型，以及AnimateDiff、Stable SR等插件所需的各种模型，以帮助读者解决在使用Stable Di?usion过程中可能遇到的各种问题。
2.1 内容简介 《解密AI绘画与修图：Stable Diffusion+Photoshop》全面介绍了Photoshop和Stable Diffusion的交互方式，以及各自的AI功能和具体使用方法。除了讲解功能，还通过实际案例加强AI在摄影、插画、电商等领域的运用。《解密AI绘画与修图：Stable Diffusion+Photoshop》用浅显易懂的语言、详尽的图文步骤以及4K视频语音教学，全程还原了所有实例的操作过程，确保零基础的读者也能读得懂、学得会。
为了解决Stable Diffusion插件配置和模型下载困难的问题，《解密AI绘画与修图：Stable Diffusion+Photoshop》还提供了ControlNet、Inpaint Anything、AnimateDiff等常用插件的全套模型和配置说明文档，帮助读者解决在使用Stable Diffusion过程中可能遇到的各种问题。
《解密AI绘画与修图：Stable Diffusion+Photoshop》案例丰富，讲解细致，适合对AI绘图感兴趣的各类读者阅读。
2.2 本书作者 王岩，从事计算机图形图像类图书写作二十余年，写作经验丰富，出版过《After Effects CC案例设计与经典插件》《InDesign CC排版设计全攻略》《中老年人学智能手机应用全攻略》等图书数十本。
2.3 本书目录 第1章　常用AI图像生成工具简介 1 1.1　Midjourney 2 1.2　DALL-E 3 3 1.3　Stable Diffusion 4 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93530b19509d19b00eee70f5baafc1f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1afaa5d0e1a40c7717e2014f1f09a937/" rel="bookmark">
			多语言声音克隆，CosyVoice模型最强部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CosyVoice是由阿里通义实验室开源的一款多语言语音理解模型，它主要聚焦于高质量的语音合成，能够生成自然且逼真的语音。
CosyVoice模型经过超过15万小时的数据训练，支持中文、英语、日语、粤语和韩语多种语言的合成，且在多语言语音生成、零样本语音生成、跨语言声音合成和指令执行能力方面表现卓越。
CosyVoice支持one-shot音色克隆技术，仅需3~10秒的原始音频即可生成模拟音色，包括韵律、情感等细节。
CosyVoice展现了零样本学习的能力，能够通过一个简短的参考语音样本复制任意声音，实现内容一致性和说话者相似度的高度还原。
CosyVoice能够对生成的语音进行细粒度的情感、语调、语速和音调控制，使合成的语音更加丰富和具有表现力。
github项目地址：https://github.com/FunAudioLLM/CosyVoice。
一、环境安装 1、python环境
建议安装python版本在3.10以上。
2、pip库安装
pip install torch==2.0.1+cu118 torchvision==0.15.2+cu118 torchaudio==2.0.2 --index-url https://download.pytorch.org/whl/cu118
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
3、CosyVoice-300M模型下载：
git lfs install
git clone https://www.modelscope.cn/iic/CosyVoice-300M.git CosyVoice-300M
4、CosyVoice-300M-SFT模型下载：
git lfs install
git clone https://www.modelscope.cn/iic/CosyVoice-300M-SFT.git CosyVoice-300M-SFT
5、CosyVoice-300M-Instruct模型下载：
git lfs install
git clone https://www.modelscope.cn/iic/CosyVoice-300M-Instruct.git CosyVoice-300M-Instruct
当使用自然语音控制推理模式时，需要采用该模型。
6、CosyVoice-ttsfrd模型下载：
git lfs install
git clone https://www.modelscope.cn/iic/CosyVoice-ttsfrd.git CosyVoice-ttsfrd
二、功能测试 1、调用测试：
（1）调用接口测试代码
from cosyvoice.cli.cosyvoice import CosyVoice from cosyvoice.utils.file_utils import load_wav import torchaudio #初始化CosyVoice模型 cosyvoice = CosyVoice('pretrained_models/CosyVoice-300M-SFT') #列出可用的发音人 print(cosyvoice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1afaa5d0e1a40c7717e2014f1f09a937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41c6cef8a84f4dbc5b4061b4c020b80/" rel="bookmark">
			Docker-compose单机容器集群编排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统的容器管理：Dockerfile文件 -&gt; 手动执行 docker build 一个个镜像的构建 -&gt; 手动执行 docker run 一个个容器的创建和启动
容器编排管理：Dockerfile文件 -&gt; 在docker-compose.yml配置模板文件里定义容器启动参数和依赖关系 -&gt; 执行docker-compose命令指定配置模板文件，根据模板文件的配置一键完成所有镜像的构建和容器的创建启动
一、Compose概述 1、Compose的相关概念 Dockerfile可以让用户管理一个单独的应用容器；而Compose则允许用户在一个模板（YAML格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。
Docker-Compose是一个容器编排工具。通过一个.yml或.yaml文件，将所有的容器的部署方法、文件映射、容器端口映射等情况写在一个配置文件里，执行docker-compose up命令就像执行脚本一样，一个一个的安装并部署容器。
本质上就是在yaml格式的docker-compose配置模板文件里定义一个或多个服务及其容器的启动参数和依赖关系，并使用docker-compose命令根据配置模板文件中的参数来启动和管理容器。
2、docker-compose的作用 docker镜像管理的问题 需要多次使用Dockerfile Build Image或者DockerHub拉取Image;
需要创建多个Container，多次编写启动命令；
Container互相依赖，如何进行管理和编排；
当我们服务数量增多的时候，上面三个问题就会更加的被放大，如果这三个问题不解决，其实从虚拟机到容器化除了机器减少一些浪费以外，好像没有更多的变化。Docker有没有什么好的方法，可以让我们通过一个配置就搞定容器编排和运行呢?这个时候Docker Compose就站出来了。
Docker Compose的解决方案 提供工具用于定义和运行多个docker容器应用；使用yaml文件来配置应用服务(docker-compse.yml)；可以通过一个简单的命令docker-compse up可以按照依赖关系启动所有服务；可以通过一个简单的命令docker-compose down停止所有服务；当一个服务需要的时候，可以很简单地通过--scale进行扩容； 3、Compose的特征 1、多容器管理 Compose 可以通过一个单一的 YAML 文件来定义和管理多个容器。这个文件中描述了所有的服务、网络和存储卷，使得应用的部署和管理变得简单且一致。
2、环境隔离 Compose 可以在不同的环境中运行相同的应用配置，比如开发、测试和生产环境。通过使用不同的 Compose 文件或覆盖文件，可以轻松切换环境。
3、网络配置 Compose 可以轻松地配置服务之间的网络连接。每个服务可以自动连接到一个默认的网络，或者连接到用户定义的网络。这使得服务之间的通信变得简单和直观。
4、数据卷管理 Compose 支持定义数据卷，并在多个服务之间共享数据卷。这使得持久化数据的管理更加方便，并且可以确保数据在容器重启或重新创建时不会丢失。
5、服务扩展 可以通过简单的命令扩展服务的实例数量。例如，可以通过 docker-compose up --scale web=3 命令来扩展 web 服务的实例数量为 3 个，以便进行负载均衡和高可用部署。
6、与 Docker 集成 Compose 与 Docker 深度集成，可以使用 Docker 的所有特性和功能。通过 Compose，可以方便地管理容器的生命周期、监控容器状态、查看日志和调试容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41c6cef8a84f4dbc5b4061b4c020b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574ed867c555890561059e376ae70f65/" rel="bookmark">
			最新开源的解析效果非常好的PDF解析工具MinerU （pdf2md pdf2json）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毫不夸张的说 PDF解析工具MinerU是照进RAG黑暗中的一道光——这是我对它的评价。我测过太多了文档解析工具！ 最近在做文档解析的工作。看了很多的开源的文档解析的工具，版面分析的工具，其中包括paddelpaddel这样30k+star的明星工具。但是效果都觉得不好。 MinerU是一个最近开源的文档解析工具，可以把PDF转成json结构，还可以转成md格式。可以解析得到其中的图片，表格，可以得到段落，可以得到标题，这是很哇塞的事情。因为最近RAG特别火热，这些都是RAG非常需要的。文档解析是非常重要的一个环节。可以看看这篇文章。 RAG的上限在哪里？边界在哪里？_rag的限制-CSDN博客 虽然现在MinerUstar数量不高，1k star都不到，但是绝对会涨起来的。我们调研对比过很多开源的工具，效果都强差人意，这个是我看到的最满意的一个。甚至要比我们生产环境的都要好一些。MinerUstar 绝对是一个为RAG而创造的工具，开源世界的一道光。 这篇文章会详细介绍它的解析效果，它的优势和不足。并且给出详细的安装教程。MinerU 在github上的安装教程太粗糙了。一堆问题。 环境介绍 windows10 环境
使用CPU运行
Magic-PDF简介 MinerU 是一款一站式、开源、高质量的数据提取工具，主要包含以下功能:
Magic-PDF PDF文档提取Magic-Doc 网页与电子书提取 Magic-PDF 是一款将 PDF 转化为 markdown 格式的工具。支持转换本地文档或者位于支持S3协议对象存储上的文件。
解析系效果总结 我觉得不妨先看看解析的效果，不着急折腾环境，先看看我列出来的缺点是否能接受。或者看看优点是不是自己想要的。再去安装它。
缺点 问题1： 解析速度慢 这里使用的CPU跑的，6页大概两三分钟。解析走的纯模型，先版面分析，再ocr，再公式检测。
模型初始化耗时167s，之后每页大概是16s
问题2：表格解析成图片 把表格处理成了图片
原文件如下所示
解析结果如下所示
原文件如下
解析后的结果
问题3：标题识别不准确，且没有分层 原文件
解析后的结果
问题4:财报中的表格没有识别出来 优点 优点1：论文版面分析准确 表定位，图表定位准确。测了一篇论文，都正确。并且准确获取到了表格和图片的caption
支持多栏，解析顺序是正确的
优点2：混乱的杂志 + 多栏 + 图片 解析效果挺不错。一页多栏，顺序是对的。
优点3：多语言 测了中文和英文。都可以，github上的描述，支持176种语言
优点4：获取了表格和图片的caption 能够获取到caption并且单独存储了。
优点5：页眉页脚、脚注识别准确 转md的时候，都已经去掉了。
优点6：段落结构比较好 段落合并的好。得到的结果多数是自然段落
优点7：可以解析公式 优点8：多平台多环境支持 支持windows/linux/mac平台；支持cpu和gpu环境
安装MinerU 虚拟化环境 conda create -n MinerU python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/574ed867c555890561059e376ae70f65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62992984b540b6521f0288df4ce3a3a7/" rel="bookmark">
			【C&#43;&#43;】C&#43;&#43;11的新特性 --- 右值引用与移动语义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如生活欺骗了你 不要悲伤，不要心急！ 忧郁的日子里须要镇静 相信吧 快乐的日子将会来临 -- 普希金 《假如生活欺骗了你》 C++11的新特性 1 左值与右值2 左值引用和右值引用3 引用的意义4 移动语义4.1 移动构造与移动赋值4.2 区分现代写法与移动语义4.3 实践中落实移动语义 5 万能引用和完美转发Thanks♪(･ω･)ﾉ谢谢阅读！！！下一篇文章见！！！ 1 左值与右值 C++中，一个表达式不是右值就是左值。C语言中：左值可以位于赋值对象的左边，右值则不能。在C++中就没有这么简单了。在C++中的左右值可以通过是否可以取地址来区分：
左值表示一个占据内存中可识别位置的一个对象，有可能是一个表达式。更进一步地，可以对左值取地址右值即不能进行取地址的值或表达式。包括常量，加减乘除等表达式，临时对象。 PS:左值和右值在内存中都是有地址的，只有左值可以取地址！
左值包括变量名，解引用的指针的等。下面是比较经典的左值，他们都可以进行取地址操作！
注意左值引用和右值引用都是左值
int a = 1; int* p = &amp;a; int** pp = &amp;p; const int b = 2; 右值一般是常量，表达式，临时变量 ,对于一个常量肯定是无法取地址的！
&amp;10; &amp;(1 + 1); &amp;string("111"); 当一个对象被作为右值进行使用时，用的是对象的值（内容）；用做左值时，实际使用的是对象的身份（在内存中的位置）
2 左值引用和右值引用 左值引用就是对左值进行取别名：
int a = 1; int&amp; ra = a; int* p = &amp;a;	int*&amp; rp = p 右值引用就是对右值进行取别名：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62992984b540b6521f0288df4ce3a3a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff65ac0db6034fe1f3f676338b12bf5/" rel="bookmark">
			【微服务】第37节：微服务的注册中心Eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.注册中心 本章主要学习Nacos中的一些特性和原理，以及与Eureka的功能对比。
1.1.环境隔离 企业实际开发中，往往会搭建多个运行环境，例如：
🔹 开发环境
🔹 测试环境
🔹 预发布环境
🔹 生产环境
这些不同环境之间的服务和数据之间需要隔离。
还有的企业中，会开发多个项目，共享nacos集群。此时，这些项目之间也需要把服务和数据隔离。
因此，Nacos提供了基于namespace的环境隔离功能。具体的隔离层次如图所示：
说明：
⭕Nacos中可以配置多个namespace，相互之间完全隔离。默认的namespace名为public
⭕namespace下还可以继续分组，也就是group ，相互隔离。 默认的group是DEFAULT_GROUP
⭕group之下就是服务和配置了
1.1.1.创建namespace nacos提供了一个默认的namespace，叫做public：
默认所有的服务和配置都属于这个namespace，当然我们也可以自己创建新的namespace：
📑 然后填写表单：
添加完成后，可以在页面看到我们新建的namespace，并且Nacos为我们自动生成了一个命名空间id：
我们切换到配置列表页，你会发现dev这个命名空间下没有任何配置：
因为之前我们添加的所有配置都在public下：
1.1.2.微服务配置namespace 默认情况下，所有的微服务注册发现、配置管理都是走public这个命名空间。如果要指定命名空间则需要修改application.yml文件。
比如，我们修改item-service服务的bootstrap.yml📄文件，添加服务发现配置，指定namespace：
spring: application: name: item-service # 服务名称 profiles: active: dev cloud: nacos: server-addr: 192.168.150.101 # nacos地址 discovery: # 服务发现配置 namespace: 8c468c63-b650-48da-a632-311c75e6d235 # 设置namespace，必须用id # 。。。略 启动item-service，查看服务列表，会发现item-service出现在dev下：
而其它服务则出现在public下：
此时访问http://localhost:8082/doc.html，基于swagger做测试：
会发现查询结果中缺少商品的最新价格信息。
我们查看服务运行日志：
会发现cart-service服务在远程调用item-service时，并没有找到可用的实例。这证明不同namespace之间确实是相互隔离的，不可访问。
当我们把namespace切换回public，或者统一都是以dev时访问恢复正常。
1.2.分级模型 在一些大型应用中，同一个服务可以部署很多实例。而这些实例可能分布在全国各地的不同机房。由于存在地域差异，网络传输的速度会有很大不同，因此在做服务治理时需要区分不同机房的实例。
例如item-service，我们可以部署3个实例：
🌐127.0.0.1:8081
🌐127.0.0.1:8082
🌐127.0.0.1:8083
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff65ac0db6034fe1f3f676338b12bf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79d886e8df6f127a1aba8233768e540/" rel="bookmark">
			基于天地图使用Leaflet.js进行WebGIS开发实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、天地图的key
1、创建应用
2、调用限制策略
注：
（1）日服务调用超量会暂时拒绝访问，次日自动开启；
（2）如果服务调用过程中存在数据爬取或者下载行为，服务调用会被自动拒绝。
二、使用Leaflet调用天地图的底图服务
1、天地图提供的地图服务
2、实际加载底图
三、Leaflet调用天地图的地理编码接口
1、地理编码接口介绍
2、实现自定义的地理编码查询
四、总结
前言 在之前的博客中，我们曾介绍了天地图这个官方的网站，除了介绍它在线提供的功能，同时也介绍了它的API服务能力，在博客的最后还使用QGIS进行了在线底图的调用展示。其实在平常的开发或者学习工作中，我们接触到的都是WebGIS，而之前介绍得都是桌面GIS的使用和学习方式，有了天地图之后，其实大家都可以做出比较好用的WebGIS应用，依赖天地图，我们可以实现不同的底图的在线切换，还能实现根据中文地名查找其对应的经纬度信息并且在地图上进行展示。
本文重点介绍如何基于天地图使用Leaflet来开发WebGIS的应用，首先讲解如何在天地图上申请个人的key，然后讲解在天地图中不同的账户的调用限制策略，最后使用Leaflet开发一个加载天地图影像底图和影像文字标注，在地图的基础之上实现一个全国范围内的地名地址检索。在自己没有对应的地图服务器和地理查询服务器的时候，使用天地图来实现业务的快速支撑。感兴趣的你不妨来这里看看。
一、天地图的key 天地图的key是我们的第三方应用访问天地图的凭证，现在天地图的key分为浏览器端的key和服务端的key，以前是可以两者混用的，现在必须要分开，否则在请求时就会报错，无法返回对应的数据。因此在这里重点讲一下如何在天地图中申请key。
1、创建应用 首先使用注册的邮箱登录到天地图的官方网站，然后切换到开发资源目录，如下图所示：
其实在官网上也大致的说了如何申请key，在成为注册用户之后，还要申请陈伟开发则会，然后获取服务许可也就是key，最后通过key来访问api或者服务（比如在线的地图）。 我们可以点击任意一个api的地址，然后在他的官方说明文档都会有创建key的说明，如下图所示：
点击申请key的超链接之后，系统将自动跳转到应用管理页面，在应用中来创建不同的key。管理页面如下所示。 在上面的页面中其实就管理了我们申请的两个应用。这是我之前申请过的，默认是空白的。点击创建应用发起新建操作。 在创建应用的过程当中，根据页面的提示来进行创建即可，唯一需要注意的就是，应用的类型这里。主要包含三种浏览器端、服务端、Android平台。这其实分别代表了使用浏览器访问、后台接口模式（如使用java进行接口调用），以及移动端的调用。 在以前的天地图中，key是可以混用的，现在应用类型分开之后就需要分开，务必按照实际的应用来填写。填写完毕之后，系统会自动创建应用出来，里面包含了服务的类型，还有第三方的应用，如下图所示：
默认会包含上面这些接口，比如搜索引擎、地理编码、逆地理编码、公交引擎等。可以看到下面有一些第三方服务，暂时我们用不到，使用默认的即可。在线上服务器，我们其实可以限制访问的应用ip，不输入的话默认是不限制的。
因新系统升级，自公告之日起，应用类型tk严格区分，浏览器端JavaScript开发请选择“浏览器端”类型tk，“服务端tk”不再支持“浏览器端”应用，请注意检查您的应用类型。
上面的公众确实要仔细查看，历史的应用需要进行调整，否则可能访问不了。经过以上的步骤我们大概就已经创建好了应用，同时可以在应用列表中看到产生的key。在访问天地图的服务时就可以带上这些key即可（按场景和应用类型分开）。
2、调用限制策略 天地图网站其实根据不同的账号类型有不同的访问限制策略，这里摘录其官网的配置说明。
类别服务名称个人开发者工商企业政府机构日配额日配额日配额地图API影像底图1000030000005000000矢量底图1000030000005000000矢量注记1000030000005000000影像注记1000030000005000000地形晕渲1000030000005000000地形注记1000030000005000000矢量英文注记1000030000005000000影像英文注记1000030000005000000全球境界1000030000005000000三维地名1000030000005000000三维地形1000030000005000000Web服务API静态地图300060000008000000行政区划服务300060000008000000逆地理编码700060000008000000地理编码700060000008000000公交规划300060000008000000驾车规划300060000008000000地图搜索300060000008000000 对于个人开发来说，调用次数远远是不够的，对于对外提供服务的，还是需要升级到企业账号，调用次数才能上一个档次。同时这里需要说明的是：
注： （1）日服务调用超量会暂时拒绝访问，次日自动开启； （2）如果服务调用过程中存在数据爬取或者下载行为，服务调用会被自动拒绝。 我们可以在应用中对我们的请求次数进行监控，看是否会有超的情况，在访问统计中可以看到如下的界面：
上图中就很明显的展示了服务的调用次数。
二、使用Leaflet调用天地图的底图服务 在掌握了如何申请天地图的key以后，我们就可以拿着申请的key进行相关的服务调用。首先我们来看一下如何在leaflet中调用天地图的地图服务。
1、天地图提供的地图服务 在加载天地图的地图服务之前，首先我们要知道它提供了哪些在线底图。在他的地图API页面有明确的展示。
通过上面的API列表可以看到，天地图提供了不同类型的地图资源，比如矢量图层还有影像图层。还有地形晕渲的效果，在提供底图的在线图源同时，还有有注记信息。通过辅助的注记信息，让我们在地图的展示时更加的友好和明确，能抓住地图的重点。
为了简单的演示在leaflet中如何加载具体的图层，我们这里展示如何加载球面墨卡托投影的影像底图和对应的注记图层。在官网提供了如何进行瓦片进行数据请求的说明：
（2）地图瓦片获取
http://t0.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=img&amp;STYLE=default&amp;TILEMATRIXSET=w&amp;FORMAT=tiles&amp;TILEMATRIX={z}&amp;TILEROW={y}&amp;TILECOL={x}&amp;tk=您的密钥。
可以看到，这里不同的除了key之外，还有一个图层的不一样，其它的都是一样的。因此我们只要替换上述的红色部分的内容即可。
2、实际加载底图 关于如何在地图上使用Leaflet来进行地图加载，相信大家已经非常熟悉了，如果还不太了解的可以先去学习一下基础知识，也可以看一些我之前的一些博客，均有非常详细的说明。这里仅以具体加载瓦片的javascript代码为主进行讲解。首先定义地图实例对象和天地图的key，这里的可以我们选取浏览器端的key，因为我们要实现的webgis的功能。
var map = L.map('mapid',{/*crs:L.CRS.CustomEPSG4326*/}).setView([34.669359, 113.642578], 10); var tdt_client_key = "xxx";//天地图客户端的key 加载影像底图和影像注记，关键代码如下所示：
L.tileLayer('http://t0.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=img&amp;STYLE=default&amp;TILEMATRIXSET=w&amp;FORMAT=tiles&amp;TILEMATRIX={z}&amp;TILEROW={y}&amp;TILECOL={x}&amp;tk=' +tdt_client_key, { maxZoom: 18, attribution: 'Map data &amp;copy; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d79d886e8df6f127a1aba8233768e540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc9d1e319edc5c44e95f640f0234b7e/" rel="bookmark">
			离散型随机变量为何不是左连续？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
离散型随机变量
引言
离散型随机变量的定义和性质是什么？
定义
性质
如何证明离散型随机变量的分布函数在每个可能取值处不具有左连续性？
离散型随机变量的阶梯状分布函数是如何影响其左连续性的？
在统计学中，有哪些方法可以用来处理或模拟离散型随机变量的左连续性问题？
离散型随机变量与连续型随机变量在数学和应用领域上有何不同？
离散型随机变量 引言 离散型随机变量不能左连续的原因主要与其定义和性质有关。根据离散型随机变量的定义，这类随机变量的取值是有限个或可列无穷多个值。这意味着其取值可以明确地一一列举出来，并且每个可能的取值都有一个确定的概率。
在讨论分布函数时，对于离散型随机变量，其分布函数通常表现为阶梯状，即在每个可能取值处有一个突变点。这种阶梯状的特性使得分布函数在这些突变点处不具有左连续性。具体来说，如果一个离散型随机变量 𝑋X 可能取的值为 𝑥1,𝑥2,…x1​,x2​,…，那么对于每一个 𝑥𝑖xi​，𝑃(𝑋=𝑥𝑖)P(X=xi​) 是一个非零的正数，而 𝑃(𝑋&lt;𝑥𝑖)P(X&lt;xi​) 则是所有小于 𝑥𝑖xi​ 的取值对应的概率之和，这个和在 𝑥𝑖xi​ 处会有一个跳跃，因此无法满足左连续性的要求。
此外，离散型随机变量的分布函数必须满足单调递增、有界以及右连续等条件。这些条件确保了分布函数在非离散点（即连续区间内）的连续性，但并不影响其在离散点上的行为。因此，离散型随机变量的分布函数在每个可能取值处都是不连续的，从而导致整体上不具有左连续性。
离散型随机变量不能左连续的主要原因是其取值的离散性和分布函数的阶梯状特性，这使得其在每个可能取值处都存在跳跃，无法达到左连续的要求。
离散型随机变量的定义和性质是什么？ 离散型随机变量的定义和性质如下：
定义 离散型随机变量是指其所有可能取值是有限个或可数无限多个的随机变量。具体来说，如果一个随机变量 𝑋X 的全部可能取值可以列成一个序列，并且这个序列是有限的或者可以一一对应到自然数集合上，则称 𝑋X 为离散型随机变量。
例如，抛四次硬币，设正面朝上为 𝑋X，那么 𝑋X 可能取的值有 0,1,2,3,40,1,2,3,4，这是一个有限的取值范围，因此 𝑋X 是一个离散型随机变量。
性质 离散型随机变量 𝑋X 的概率质量函数（概率密度函数在连续型随机变量中对应的是概率质量函数）是一个非负函数 𝑓(𝑥)f(x)，它满足以下条件：
𝑃(𝑋=𝑥)=𝑓(𝑥)P(X=x)=f(x)
其中，𝑥x 是 𝑋X 的可能取值。
分布函数 𝐹(𝑥)F(x) 定义为随机变量 𝑋X 小于或等于 𝑥x 的概率：
𝐹(𝑥)=𝑃(𝑋≤𝑥)F(x)=P(X≤x)
对于离散型随机变量，分布函数可以通过累加概率质量函数来得到：𝐹(𝑥)=∑𝑘≤𝑥𝑓(𝑘)F(x)=k≤x∑​f(k) 其中，𝑘k 是 𝑋X 的可能取值。
离散型随机变量的期望值（或均值） 𝐸(𝑋)E(X) 定义为：
𝐸(𝑋)=∑𝑥𝑥𝑓(𝑥)E(X)=x∑​xf(x) 这表示对每个可能取值 𝑥x，乘以其相应的概率 𝑓(𝑥)f(x)，然后将这些乘积相加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc9d1e319edc5c44e95f640f0234b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0455ef6ac136a5b25f759565fa116db2/" rel="bookmark">
			大数据开发之Hadoop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据开发之Hadoop Hadoop的发展Hadoop的三个功能组件一、HDFS 分布式文件系统 1、HDFS的基础架构2、HDFS基础操作命令3、HDFS WEB浏览：4、Big Data Tools插件5、使用NFS网关功能将HDFS挂载到本地系统6、HDFS数据存储7、NameNode 元数据8、SecondaryNameNode的作用 二、MapReduce 分布式计算 1、大数据体系内的计算， 举例：2、分布式（数据）计算 的两种模式3、分布式计算框架 - MapReduce 三、Yarn 分布式资源调度 1、资源调度2、Yarn核心架构3、Yarn容器4、Yarn辅助架构 提交MapReduce程序至YARN运行 大数据的核心工作、软件生态
大数据的核心工作解释大数据软件生态存储妥善保存海量待处理数据Apache Hadoop HDFS、Apache HBase、Apache Kudu、云平台计算完成海量数据的价值挖掘Apache Hadoop MapReduce、Apache Spark、Apache Flink传输协助各个环节的数据传输fApache Kafka、Apache Pulsar、Apache Flume、Apache Sqoop Hadoop的发展 Hadoop创始人：Doug Cutting
Hadoop起源于Apache Lucene子项目：Nutch：Nutch的设计目标是构建一个大型的全网搜索引擎。遇到瓶颈：如何解决数十亿网页的存储和索引问题
Google三篇论文：
《The Google file system》：谷歌分布式文件系统GFS
《MapReduce: Simpliﬁed Data Processing on Large Clusters》：谷歌分布式计算框架MapReduce
《Bigtable: A Distributed Storage System for Structured Data》：谷歌结构化数据存储系统
Hadoop商业发行版本：
CDH（Cloudera’s Distribution, including Apache Hadoop） Cloudera公司出品，目前使用最多的商业版HDP（Hortonworks Data Platform），Hortonworks公司出品，目前被Cloudera收购星环，国产商业版，星环公司出品，在国内政企使用较多 Hadoop的三个功能组件 HDFS组件：HDFS是Hadoop内的分布式存储组件。可以构建分布式文件系统用于数据存储MapReduce组件：MapReduce是Hadoop内分布式计算组件。提供编程接口供用户开发分布式计算程序YARN组件：YARN是Hadoop内分布式资源调度组件。可供用户整体调度大规模集群的资源使用。 一、HDFS 分布式文件系统 HDFS全称：Hadoop Distributed File System
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0455ef6ac136a5b25f759565fa116db2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f37fc6eb4ef53b96a1fd6e1aa7ce72/" rel="bookmark">
			python—正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 导入re模块常用的元字符re模块match方法分组贪婪匹配编译 Python中的正则表达式是一种强大的文本处理工具，它使用一种特殊的语法来描述字符串的模式。Python通过re模块提供了对正则表达式的支持。使用正则表达式，你可以进行复杂的文本搜索、替换和验证等操作。 所以判断一个字符串是否是合法的Email的方法是： 创建一个匹配Email的正则表达式用该正则表达式去匹配用户的输入来判断是否合法 导入re模块 在使用正则表达式之前，你需要先导入Python的re模块。
import re 常用的元字符 Python中常见的元字符有：
要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n~m个字符。
A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。
re模块 Python提供re模块，包含所有正则表达式的功能。由于Python的字符串本身也用\转义，所以要特别注意：
s = ‘ABC\001’ ，s类型为str，即Python最基本的字符串
由于’‘会对’'进行转义，故对应的正则表达式字符串变成：‘ABC\001’
实例：
print("ABC\\001") #输出结果：ABC\001 如果使用r标记字符串，那么就不再需要考虑转义的问题了：
s = r’ABC\001’
对应的正则表达式字符串不变：‘ABC\001’
实例：
print(re.match(r"\w+\\\d+","ABC\\001")) #输出结果：&lt;re.Match object; span=(0, 7), match='ABC\\001'&gt; 推荐在Python中进行正则表达式匹配时，使用r前缀标记字符串
match方法 re模块提供了一个match方法，可以判断正则表达式是否匹配
match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None
phone_num = "0551-123456789" print(re.match(r"\d{4}-\d{3,8}",phone_num)) #输出结果：&lt;re.Match object; span=(0, 13), match='0551-12345678'&gt; match方法通常会结合if选择结构进行判断：
分组 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group），比如：
t = "19:59:59" print(re.match(r"([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)",t).groups()) print(re.match(r"([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)",t).group(1)) print(re.match(r"([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)",t).group(2)) print(re.match(r"([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)",t).group(3)) #输出结果：('19', '59', '59') #19 #59 #59 如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。
注意：group(0)永远是与整个正则表达式相匹配的字符串，group(1)、group(2)…表示第1、2、……个子串。
贪婪匹配 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
例如，匹配出数字后面的0：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f37fc6eb4ef53b96a1fd6e1aa7ce72/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/137/">«</a>
	<span class="pagination__item pagination__item--current">138/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/139/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>