<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82ac137420a274b8425dfb72737ad4a/" rel="bookmark">
			顺序表＜数据结构 C版＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
线性表
顺序表
动态顺序表类型
初始化
销毁
打印
检查空间是否充足（扩容）
尾部插入
头部插入
尾部删除
头部删除
指定位置插入
指定位置删除
查找数据
线性表 线性表是n个相同特性的数据元素组成的有限序列，其是一种广泛运用的数据结构，常见的线性表有顺序表、栈、链表、队列等。
其在逻辑上是线性的，物理结构（存储结构）上不一定是线性的。
顺序表 顺序表就是线性表的一种，它在逻辑结构与物理结构上都是连续的，一般情况下它的底层就是数组，在数组基础上多了增删查改操作。
顺序表有静态顺序表和动态顺序表，我们常常采用动态顺序表，因为它的扩容方便、空间浪费更少。
动态顺序表类型 typedef int SeqDataType;//将动态顺表的存储数据的类型重命名，方便后期统一修改 //动态顺序表 typedef struct SeqList {//命名：Sequence List顺序表 SeqDataType* arr; int capacity;//动态顺序表的容量 int size;//动态顺序表的有效个数 }SL; 初始化 //初始化 void SLInit(SL* s) { s-&gt;arr = NULL; s-&gt;capacity = s-&gt;size = 0; } 销毁 //销毁 void SLDestory(SL* s) { if (!s-&gt;arr) {//等同于s-&gt;arr==NULL，判断要释放的空间是否是NULL，防止释放NULL perror("Destory Fail");//打印错误 exit(1); } free(s-&gt;arr);//释放动态开辟的内存 s-&gt;arr = NULL; s-&gt;capacity = s-&gt;size = 0; } 打印 打印操作方便我们检查错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b82ac137420a274b8425dfb72737ad4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e5c337a49f50a69cb1c7f5de420af4/" rel="bookmark">
			单链表＜数据结构 C版＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念
链表的单个结点
链表的打印操作
新结点的申请
尾部插入
头部插入
尾部删除
头部删除
查找
在指定位置之前插入数据
在任意位置之后插入数据
测试运行一下：
删除pos结点
删除pos之后结点
销毁链表
概念 单链表是一种在物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接顺序实现的。
链表的每个结点有两个部分，分别是数据和指向下个结点的指针，每个链表的最后一个结点的下一个结点为NULL（不能对NULL解引用）。
放一张bit课件里的图,我觉得很形象：
链表的单个结点 typedef int SLDataType;//重定义一下在链表内存放的数据类型，方便后期对类型进行统一修改 //链表的单个结点 typedef struct SListNode {//Single List Node :链表结点 SLDataType data;//存放的数据 struct SListNode* next;//指向下一个结点的指针 }SLNode;//重定义名字方便后期使用 链表的打印操作 //链表的打印操作 void SLPrint(SLNode* phead) { assert(phead);//不能传入空指针 SLNode* pcur = phead; //pointer cursor:指针光标，不让头结点丢失(虽然不会改变头结点的指向) while (pcur) {//等同于pcur!=NULL printf("%d-&gt;", pcur-&gt;data);//打印此结点的数据 pcur = pcur-&gt;next;//使pcur指向下一个结点 } printf("NULL\n"); } 新结点的申请 后面会涉及到新结点的插入，申请新结点可以封装成一个函数，避免代码冗余
//新结点的申请 SLNode* SLBuyNode(SLDataType x) { SLNode* node = (SLNode*)malloc(sizeof(SLNode)); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e5c337a49f50a69cb1c7f5de420af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c89a6ee96259c48cca8e3a356d26f599/" rel="bookmark">
			重生之“我打数据结构，真的假的？”--2.单链表（完结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.链表的深拷贝 . - 力扣（LeetCode）
思路：
1.遍历原链表根据结点保存的数据，申请并复制到新的结点，并且插入到该节点后。
2.新结点的随机指向结点 = 原链表结点的随机指向结点的下一个结点！！
3.所有malloc的新节点全部连接起来
struct Node* copyRandomList(struct Node* head) { struct Node* phead = NULL; struct Node* flag = head; struct Node* q = NULL; struct Node* p = NULL; if(head==NULL) return q; while (flag) { q = NULL; q = (struct Node*)malloc(sizeof(struct Node)); q-&gt;next = flag-&gt;next; flag-&gt;next = q; q-&gt;val = flag-&gt;val; flag = q-&gt;next; } flag = head; p = flag-&gt;next; phead = p; while (p-&gt;next) { if (flag-&gt;random == NULL) p-&gt;random = NULL; else { p-&gt;random = flag-&gt;random-&gt;next; } flag = p-&gt;next; p = flag-&gt;next; } if (flag-&gt;random == NULL) p-&gt;random = NULL; else { p-&gt;random = flag-&gt;random-&gt;next; } p=head-&gt;next; while (p-&gt;next) { p-&gt;next=p-&gt;next-&gt;next; p=p-&gt;next; } return phead; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c89a6ee96259c48cca8e3a356d26f599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95cf1dbcdd5242796ac4451f65da88cd/" rel="bookmark">
			机器人开源调度系统OpenTcs6-架构运行分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统启动
启动 Kernel：加载核心应用，初始化系统配置和状态。
启动 Plant Overview：加载图形用户界面，初始化模型和用户界面。
模型导入和配置
在 Plant Overview 中导入或创建工厂布局模型。
配置路径、位置和车辆信息。
车辆连接
通过 Vehicle Adapters 连接 AGV 控制器。
配置和注册 AGV，包括通讯参数和物理特性。
任务创建和分配
通过 Order Management 客户端或 RESTful API 创建运输任务。
Kernel 根据调度算法将任务分配给合适的 AGV。
任务执行和监控
AGV 接收并执行任务，根据路径规划行驶到指定位置。
系统实时监控 AGV 状态和任务进度，通过 GUI 或监控工具展示。
±--------------------------+
| Client Apps |
| (Order Management, etc.) |
±-----------±-------------+
|
|
±-----------v--------------+
| Plant Overview |
| (GUI, Model Editor, etc.)|
±-----------±-------------+
|
|
±-----------v--------------+
| Kernel |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95cf1dbcdd5242796ac4451f65da88cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91795817b60ad1615967ff4ce017464b/" rel="bookmark">
			短短3个月“AI教母”李飞飞创造一家独角兽；OpenAI推出新算法帮助提升AI模型输出可读性 | AI头条...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 王轶群
出品 | AI 科技大本营（ID：rgznai100）
一分钟速览新闻点！
三个月估值超10亿美元，李飞飞的 World Labs 聚焦“空间智能”
OpenAI 推出新算法帮助提升 AI 模型输出可读性
YouTube 争议中，苹果表示其 OpenELM 模型无法为 Apple Intelligence 提供支持
Meta 将暂停在欧盟推出多模态新模型只提供纯文本模型 Meta 决定暂停在巴西使用生成式 AI 工具
谷歌将 AI 代理平台 Project Oscar 开源
欧盟反垄断机构调查谷歌和三星的人工智能交易是否妨碍竞争
微软的 Designer 应用程序登陆 iOS 和 Android，具备 AI 编辑和创作功能
英伟达继续进军医药 AI，携手辉瑞等投资 AI 疗法模型研发商 CytoReason
Spotify 推出西班牙语的 AI DJ，其测试版将引入拉丁美洲和西班牙
国内外 AI 要闻
三个月估值超10亿美元，李飞飞的 World Labs 聚焦“空间智能”
短短三个多月，被业界誉为“AI 教母”的知名华裔计算机科学家李飞飞（Fei-Fei Li）便打造出了一家AI独角兽。
当地时间 7月17日据知情人士称，李飞飞首次创业成立的 World Labs 已完成两轮融资，投资者包括安霍创投（Andreessen Horowitz）和 AI 基金 Radical Ventures 等顶尖科技投资者。知情人士同时称，在最新一轮融资中，World Labs 筹到约1亿美元，估值已超过10亿美元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91795817b60ad1615967ff4ce017464b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3500476bddc4bbb4994c6d32d8c22052/" rel="bookmark">
			【Qt】事件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 事件鼠标事件键盘事件 事件 事件是应用程序内部或者外部产生的事情或者动作的统称。在 Qt 中使用⼀个对象来表示⼀个事件。所有的 Qt 事件均继承于抽象类 QEvent。
事件是由系统或者 Qt 平台本⾝在不同的时刻发出的。⼀些事件是在用户操作时发出，如键盘事件、鼠标事件等，另⼀些事件则是由系统自动发出，如定时器事件。常见的 Qt 事件如下：
QMouseEvent 鼠标事件
QKeyEvent 键盘事件
Qt在上级控件中定义了一些事件处理函数，这是一些虚函数，如（例如 QObject::event()、QWidget::mousePressEvent()）。对象通过继承上级基类，并重写事件处理函数来处理事件。
事件与信号槽机制
信号槽实际上是Qt为了方便事件处理的实现，抽象出来的一种机制，也就是说事件是信号槽的底层实现，我们在开发中往往使用信号槽居多，事件机制适用于更底层，更贴近系统层面的事件处理。
鼠标事件 QWidget中关于鼠标的事件
Events说明mousePressEvent(QMouseEvent *event)点按鼠标mouseReleaseEvent(QMouseEvent *event)释放鼠标mouseDoubleClickEvent(QMouseEvent *event)双击鼠标mouseMoveEvent(QMouseEvent *event)移动鼠标enterEvent(QEvent *event)鼠标进入控件leaveEvent(QEvent *event)鼠标离开控件wheelEvent(QWheelEvent *event)滑动鼠标滑轮 QMouseEvent类中一些常用接口
接口说明QPoint pos()获取鼠标所在坐标 (当前控件内)int x()横坐标int y()纵坐标Qt::MouseButton button()返回造成此次事件发生的鼠标按键 (Qt::MouseButton鼠标按键枚举类型)QPoint globalPos()获取鼠标所在坐标 (全屏内) class Label : public QLabel//自定义Label类，继承自QLabel，重写事件处理函数以自定义事件处理逻辑 { Q_OBJECT public: Label(QWidget* parent); //重写事件处理函数 void mousePressEvent(QMouseEvent *event); void mouseReleaseEvent(QMouseEvent *event); void mouseDoubleClickEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void wheelEvent(QWheelEvent *event); }; #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3500476bddc4bbb4994c6d32d8c22052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f341183a5c663e80d6c579034e9e47/" rel="bookmark">
			FastJson详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、FastJson介绍二、FastJson序列化API1、序列化Java对象2、序列化List集合3、序列化Map集合 三、FashJson反序列化API1、反序列化Java对象2、反序列化List集合3、反序列化Map集合（带泛型） 四、SerializerFeature枚举1、默认字段为null的不显示2、格式化 五、@JSonField注解六、@ JSonType注解 一、FastJson介绍 FastJson 是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将JavaBean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。
Fastjson 的优点
速度快 fastjson相对其他JSON库的特点是快从2011年fastjson发布1.1.x版本之后，其性能从未被其他Java实现的JSON库超越 使用广泛 fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受在2012年被开源中国评选为最受欢迎的国产开源软件之一 测试完备 fastjson有非常多的testcase，在1.2.11版本中，testcase超过3321个每次发布都会进行回归测试，保证质量稳定 使用简单 fastjson的API十分简洁 功能完备 支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展 引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.79&lt;/version&gt; &lt;/dependency&gt; 二、FastJson序列化API 序列化 : 是指将Java对象转成json格式字符串的过程。JavaBean对象、List集合对象、Map集合为应用最广泛的。
1、序列化Java对象 @Test public void objectToJson(){ Student student = new Student(); student.setId(1); student.setName("张三"); student.setAge(20); student.setAddress("北京市"); String jsonString = JSON.toJSONString(student); System.out.println(jsonString); } 结果： {"address":"北京市","age":20,"id":1,"name":"张三"} 2、序列化List集合 @Test public void listToJson(){ Student student = new Student(); student.setId(1); student.setName("张三"); student.setAge(20); student.setAddress("北京市"); Student student2 = new Student(); student2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f341183a5c663e80d6c579034e9e47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d82374ea8c6d3a32dc18c4d22cbbf79/" rel="bookmark">
			华为od 100问 持续分享6-入职体检
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一名软件开发培训机构老师，我的学生已经有上百人通过了华为OD机试，学生们每次考完试，会把题目拿出来一起交流分享。
重要：2024年5月份开始，考的都是OD统一考试（D卷），题库已经整理好了，命中率95%以上。
2024年OD统一考试（D卷）完整题库：华为OD机试2024年最新题库（Python、JAVA、C++合集）
问：入职前的体检做哪些检查，如果有问题有机会复检吗？
答：华为OD体检要求参照公务员标准，涵盖全面的身体健康检查项目，包括血常规、肝功能、心电图、B超等。
华为作为全球领先的信息与通信技术解决方案提供商，对员工的健康和素质有着严格的要求。对于希望通过华为OD（Outsourcing Department）方式加入公司的人员，体检是一个必不可少的环节，这也是确保员工能够承担日后工作的重要保障。以下是关于华为OD体检要求的详细介绍：
1. 体检流程
参照公务员标准：华为的入职体检是严格按照公务员体检标准进行的，这包括一系列的检查项目，如血常规、血糖、肝功能、肾功能、梅毒、艾滋、心电图、B超、胸部透视、尿常规等。
指定医院：体检通常在指定的医院进行，这些医院与华为有合作关系，能够提供详细且标准化的体检服务。
2. 主要项目
血液检查：包括血常规、血糖、肝功能、肾功能等。这些项目可以检查基本的血液成分和器官功能，确保没有糖尿病、贫血或肝肾功能异常等问题。
传染病筛查：包含艾滋病和梅毒的检测，这是确保员工及工作环境安全的必要措施。
心电图和B超：心电图可以检查心脏功能，及时发现潜在的心脏病；B超则用于内脏器官的可视化检查，如肝、胆、肾、甲状腺等。
胸透：通过对胸部进行X光透视，检查肺部和心脏的状况，确保没有肺结核或肺部肿瘤等疾病。
3.不合格项目
常见不合格问题：包括血液问题（如白细胞计数异常）、肝功能异常（如高胆红素）、心电图异常（如心律不齐）、血压偏高或偏低等。
复查机会：某些问题可能会给予复查的机会，例如第一次血压或心电图检查结果异常，通常会允许复查一次。但如果多次检查结果仍不正常，可能会影响最终的入职决定。
4. 体检前准备
体检前一晚需要禁食禁水，以确保第二天的检查结果准确。一般从前一天晚上19:00开始禁止饮食。
避免熬夜剧烈运动：体检前几天应保持良好的作息，避免熬夜和剧烈运动，以免影响体检结果。
女性特殊注意事项：女性在预约体检时需避开经期，因为经期间部分尿检项目可能受影响，导致结果不准确。
5.体检费用和流程
自费报销：一般情况下，体检需要自行支付费用，但华为会在一定时间内给予报销。具体的费用和流程可以在体检前与HR确认。
6. 复检情况说明
虚惊一场：有时候，体检中可能会出现虚惊一场的情况，比如窦性心律T波异常或白细胞计数偏高，但这些并不一定代表严重的健康问题。只要按照医嘱进行复检，大多数情况下都能通过。
总的来说，通过上述介绍，大家对华为OD体检的要求有了详细的了解。为了顺利通过体检，建议拿到offer后尽快准备并选择合适的医院进行体检，同时做好各项准备工作，确保结果的准确性和顺利入职。
关于入职大家还有想了解的欢迎一起交流~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293f5e71b454145a51e12e0cb80e0059/" rel="bookmark">
			15. 【C&#43;&#43;】详解搜索二叉树 | KV模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.定义
初始化
插入
查找
删除
完整代码
2.运用
K 模型和 KV 模型详解
K 模型
KV 模型
代码解释
为了更好地理解 map 和 set 的特性，和后面讲解查找效率极高的平衡搜索二叉树，和红黑树去实现模拟，所以决定在这里对搜索二叉树进行一个讲解~
1.定义 二叉搜索树（Search Binary Tree）
每一颗子树都满足，左子树上所有节点的值都小于根节点的值，右子树都大于
所以就能得到性质：左子树的值 &lt; 根 &lt; 右子树的值
它也称二叉排序树或二叉查找树，最多找高度次 O（N）
二叉搜索树蜕化为单边树（或类似单边），其平均比较次数为：O（N）
搜索二叉树由于控制不了极端情况，与 O(logN) 失之交臂了，但后面讲到的平衡二叉搜索树可以做到。
初始化 template&lt;class K&gt; struct BSTreeNode {//全部都共有开放的，就直接定struct BSTreeNode&lt;K&gt;* _left;//左结构体指针 BSTreeNode&lt;K&gt;* _right; K _key; BSTreeNode(const K&amp; key) :_left(nullptr) ,_right(nullptr) ,_key(key) {} }; //定义一个树 template&lt;class K&gt; class BATree{ typedef BSTreeNode&lt;K&gt; Node; private: Node* _root = nullptr; // 这里我们构造函数都没必要写，它自己生成的就够用了 }; 插入 思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/293f5e71b454145a51e12e0cb80e0059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5064443664901fc3bdbb6bffc3c178a0/" rel="bookmark">
			如何在 Mac 上下载安装植物大战僵尸杂交版? 最新版本 2.2 详细安装运行教程问题详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		植物大战僵尸杂交版已经更新至2.2了，但作者只支持 Windows、手机等版本并没有支持 MAC 版本，最近搞到了一个最新的杂交 2.2 版本的可以在 Macbook 上安装运行的移植安装包，试了一下非常完美能够正常在 MAC 上安装运行，看图：
该版本安装其实也蛮简单的，包括全通存档都整理到了一起打包成了 dmg 安装包，下载完成后直接打开 dmg 安装包然后将里面的游戏拖拽到右侧文件夹中就可以了
植物大战僵尸杂交版安装下载：https://www.hereitis.cn/articleDetails/2551
这里面的资源很全，包括历史版本还有 PC 版本，手机版本以及各种补丁等都有，我们 MAC 的话就选择对应版本下载文件夹中 DMG 文件下载就可以了，也可以在外面将整个文件夹下载下来，不过下载下来如果是 rar 等压缩格式记得先解压，在找到 DMG 安装包打开安装
拖拽后就安装好了，我们可以前往应用启动台打开该游戏，不过我们第一次安装第三方软件可以需要设置一下电脑运行安装任何来源软件, 设置步骤：
打开终端（Terminal.app）
拷贝粘贴 sudo spctl --master-disable按回车键
输入你的账户密码，按回车键确认执行（该密码不会显示，直接输入即可）
设置完成后，我们返回到 DMG 安装包内，里面有个软件损坏修复引导程序，我们打开运行，按照提示操作后，就可以正常打开此游戏了
整理步骤不算太难，该游戏默认是窗口化的，可能会只显示一个横条，我们等待二三十秒以后拖拽该横条多甩甩，就能恢复窗口画面了
该游戏自带全通存档，各个关卡都已经通关了，每个关卡和模式都可以直接玩，背包里的物资也都刷好了，祝大家玩的愉快
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c27a3ce3ea5e7d211f63a479161044e/" rel="bookmark">
			Jupyter notebook如何快速的插入一张图片？如何控制插入图片的缩放、靠左展示（ChatGPT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Jupyter Notebook中，你可以使用Markdown语法快速插入图片，并且可以通过HTML标签来控制图片的展示方式和缩放。
注意：以下所有操作都有一个前提，即选择Cell-CellType-Markdown
1. 快速插入图片 要在Jupyter Notebook中插入图片，可以使用Markdown的图片语法：
![图片描述](图片链接) 如：![OpenAI Logo](https://openai.com/favicon.ico) 2. 控制图片的缩放和靠左展示 2.1 控制图片缩放 你可以使用HTML的标签来控制图片的缩放。在Markdown中直接插入HTML代码也是有效的。
&lt;img src="图片链接" alt="图片描述" style="width: 200px;"/&gt; 如：&lt;img src="https://openai.com/favicon.ico" alt="OpenAI Logo" style="width: 50px;"/&gt; 2.2 靠左展示图片 默认情况下，Markdown插入的图片是居中显示的。要让图片靠左显示，可以使用HTML的标签，并添加style="float: left;"属性。
&lt;img src="图片链接" alt="图片描述" style="width: 200px; float: left; margin-right: 10px;"/&gt; 如：&lt;img src="https://openai.com/favicon.ico" alt="OpenAI Logo" style="width: 100px; float: left; margin-right: 10px;"/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfa8dcb117b6de0e6c286ddf1241c50/" rel="bookmark">
			MySQL 8.0安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Windows10环境下MySQl 8.0 ZIP安装步骤
安装包获取 MySQL官方网站MySQL :: MySQL Downloadshttps://www.mysql.com/cn/downloads/点击MySQL Community(GPL) Downloads
点击Community Server
点击Archives
选择版本和操作系统类型（以8.0.37版本为例），下载第一个ZIP包即可
安装步骤 将下载完成的压缩包进行解压，解压的位置为文件最终存放的位置
环境变量 进入文件夹，进入bin文件夹，复制文件路径，添加到系统环境变量中
点击桌面左下角开始按钮，进入设置
点击系统选项
选择导航栏底部的关于，在关于界面点击相关设置中的高级系统设置
点击右下角的环境变量
在系统变量中找到Path，选择并编辑
新建环境变量，添加MySQl文件路径
操作完成后确定，将查看中的文件拓展名勾选
在MySQL文件夹中新建文本文件，命名为my.ini
打开my.ini，将下列文本复制进去
[client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8mb4 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] # 服务端设置 # 设置3306端口 port=3306 # 重要，设置mysql的安装目录 basedir=D:\mysql-8.0.37-winx64 # 重要，设置mysql数据库的数据的存放目录 datadir=D:\mysql-8.0.37-winx64\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 注意：文件路径为该文件所在的位置
文本默认位置
文件当前存放位置 将文本保存
初始化MySQL 在桌面右下角开始，右键选择power shell，以管理员身份运行
输入以下命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dfa8dcb117b6de0e6c286ddf1241c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a1347db0f60a8dfe26d84b1e489e5b/" rel="bookmark">
			Umi Max 详解：打造高性能、可扩展的前端应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UMI是蚂蚁金服的底层前端框架，也是一个基于React的企业级前端应用框架，它提供了开箱即用的项目脚手架和插件化的配置，如路由构建、部署测试、文档工具、请求库等，帮助开发者快速搭建和管理复杂的前端项目，其设计目标是提高前端项目的开发效率和可维护性，尤其适用于大型复杂项目的开发与管理。
目录
初识Umi Max
Umi Max数据流
接口请求
初识Umi Max 了解框架：为了方便开发者更加方便的使用umi提供的插件，umi团队在这些插件开源的基础上，直接将其集成到一起，打造了@umijs/max，让开发者直接可以通过脚手架马上获得和蚂蚁集团开发umi应用一样的开发体检，只需要在使用create-umi选择Ant Design Pro模板，就能使用@umijs/max来创建项目了，可以参考官方文档：地址 ，详细了解umi max的相关开发：
因为umi max是使用Ant Design Pro模板进行开发的，所以我们也需要了解 Ant Design Pro 对应相关配置和API的使用，通过查阅官方文档进行详细了解：
当然我们在使用antd的时候，有一些组件的是十分细碎的，这里我们可以参考ProComponents ，其可以让让中后台开发更简单，如下所示：
像登录表单的内容，ProComponents组件库已经帮助我们封装好了，如下图所示：
安装项目：接下来我们开始安装umi max项目，安装的方式和umi项目命令一样，只需要在进行模板选择的时候，选择Ant Design Pro模板即可：
安装完之后直接拖到编辑器中执行 pnpm run dev 运行项目即可，最终呈现的效果如下所示：
当然在使用 Ant Design Pro 的时候，除了使用 umi 进行安装项目，我们也可以使用官方推荐给我们的pro-cli脚手架进行安装项目，如下图所示：
Umi Max数据流 官方文档给我们介绍到，umi max给我们内置了数据流管理插件，它是一种基于hooks范式的轻量级数据管理方案，可以在umi项目中管理全局的共享数据，从官方文档可以看到umi max规定的数据流和相关命名规范方面的内容，如下所示：
这里我们在src下的models目录下新建一个ts文件，用于全局状态管理的设置，这里我们可以使用react提供的相关API函数进行书写，书写的方式有点类似pinia状态管理的写法，条理十分清晰：
import { useState, useCallback,useEffect } from "react"; export default function countModel() { const [count, setCount] = useState(0); // setCount修改状态是异步的，所以需要使用useCallback包裹一下 const add = useCallback(() =&gt; setCount(count + 1) , [count]); const minus = useCallback(() =&gt; setCount(count - 1), [count]); // 设置两秒之后修改count的值 useEffect(() =&gt; { setTimeout(() =&gt; { setCount(100); }, 2000) }, []); // 返回count和两个方法 return { count, add, minus } } 定义好仓库之后，接下来我们就需要使用仓库中的数据了，使用方式也是非常简单，直接借助umi框架提供的api函数useModel即可，具体代码如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1a1347db0f60a8dfe26d84b1e489e5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40becb2734e01910a8fa5593f4463753/" rel="bookmark">
			Kafka 实现延迟队列的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Kafka 是一个高性能、分布式的流处理平台，广泛应用于消息队列、日志收集和实时数据流处理等场景。虽然 Kafka 本身并不直接支持延迟队列的功能，但可以通过一些巧妙的设计和第三方工具来实现这一需求。本文将介绍几种常见的实现延迟队列的方法。
1. 使用 Kafka 内置的时间戳和定时器 Kafka 0.10.0 版本引入了消息时间戳（timestamp）的概念，可以用于记录消息的生产时间。结合 Kafka Streams 或自定义消费者，可以实现简单的延迟队列。
步骤：
生产者：在生产消息时，设置消息的时间戳为当前时间加上延迟时间。消费者：使用 Kafka Streams 或自定义消费者，检查消息的时间戳，如果当前时间小于消息的时间戳，则将消息重新放回队列。 这种方法的优点是简单易实现，但缺点是延迟精度较低，且需要额外的逻辑处理消息的重放。
2. 使用 Kafka 和外部定时器 另一种常见的方法是结合 Kafka 和外部定时器（如 Quartz、Redis 的延迟队列等）来实现更精确的延迟队列。
步骤：
生产者：生产消息时，将消息发送到 Kafka 主题，并同时在外部定时器中设置一个延迟任务。定时器：当延迟时间到达时，定时器触发任务，将消息从 Kafka 中重新消费。 这种方法的优点是延迟精度较高，但需要维护额外的定时器系统，增加了系统的复杂性。
3. 使用 Kafka 和时间轮算法 时间轮算法是一种高效的定时任务调度算法，可以用于实现高精度的延迟队列。结合 Kafka，可以实现一个基于时间轮的延迟队列。
步骤：
生产者：生产消息时，将消息发送到 Kafka 主题，并同时在时间轮中添加一个延迟任务。时间轮：时间轮按照固定的时间间隔（如1秒）进行轮转，当轮转到某个槽位时，触发该槽位中的延迟任务，将消息从 Kafka 中重新消费。 这种方法的优点是延迟精度高，且性能较好，但实现复杂度较高。
4. 使用 Kafka 和第三方延迟队列插件 有一些第三方插件和工具（如 Kafka Delay Queue、Kafka Lag Exporter 等）专门用于实现 Kafka 的延迟队列功能。这些插件通常提供了更高级的功能和更好的性能。
步骤：
生产者：生产消息时，使用插件提供的 API 设置消息的延迟时间。插件：插件负责管理延迟消息，并在延迟时间到达时将消息重新放回 Kafka 主题。 这种方法的优点是实现简单，且性能较好，但需要依赖第三方插件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40becb2734e01910a8fa5593f4463753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c200fae7fe50033c0d2f99968b5ecddb/" rel="bookmark">
			ceph log内容解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		log内容构造 如osd的一条log
分别表示 时间戳 线程id 日志等级 子模块 内容实体
剖析源码实现 每条log都是由一个Entry构成
定义在src/log/entry.h中
Entry(short pr, short sub) : m_stamp(clock().now()), // 打印日志时的时间戳 m_thread(pthread_self()), // 打印日志的线程ID m_prio(pr), // 日志的优先级值（值越大，优先级越低） m_subsys(sub) // 子模块ID，如osd {} 如
ldout是带前缀的dout_impl
定义在src/common/dout.h中
#define ldout(cct, v) dout_impl(cct, dout_subsys, v) dout_prefix dout和ldout类似，也是带前缀的dout_impl，只有个别模块有使用，如src/mds/MDBalancer.cc中
#undef dout #define dout(lvl) \ do {\ auto subsys = ceph_subsys_mds;\ if ((dout_context)-&gt;_conf-&gt;subsys.should_gather(ceph_subsys_mds_balancer, lvl)) {\ subsys = ceph_subsys_mds_balancer;\ }\ dout_impl(dout_context, ceph::dout::need_dynamic(subsys), lvl) dout_prefix #undef dendl #define dendl dendl_impl; } while (0) 学习链接：https://daimajiaoliu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c200fae7fe50033c0d2f99968b5ecddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9515e6292b2b9fc24b82edff4c04bc4/" rel="bookmark">
			零代码本地搭建AI大模型，详细教程！普通电脑也能流畅运行，中文回答速度快，回答质量高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇教程主要解决：
1). 有些读者朋友，电脑配置不高，比如电脑没有配置GPU显卡，还想在本地使用AI；
2). Llama3回答中文问题欠佳，想安装一个回答中文问题更强的AI大模型。
3). 想成为AI开发者，开发一款AI大模型的应用和产品，如何选择API的问题。
我相信，大家平时主要还是以中文问答为主，安装一个中文回答更强的AI，就显得更很有必要。
这篇教程主要解决上面两个问题。
1 通义千问大模型的优势
近日阿里云正式发布通义千问2.5，模型性能全面赶超GPT-4 Turbo，成为地表最强中文大模型。
从初代模型升级至2.5版本，2.5版模型的理解能力、逻辑推理、代码能力分别提升9%、16%、10%，中文能力更是持续领先业界。
通义千问2.5相对于前代版本还有以下几方面的重大升级：
文档处理能力增强：通义千问2.5能够处理单次长达1000万字、100个文档的大量数据，支持包括PDF、Word、Excel在内的多种文件格式，并能解析标题、段落、图表等多种数据结构。
音视频理解能力提升：融合了语音、大规模语言模型（LLM）、多模态和翻译能力，实现了实时语音识别、说话人分离，能够从音视频内容中提取全文摘要、总结发言要点、提取关键词，同时支持同时上传处理50个音视频文件。
智能编码能力集成：集成通义灵码，使得用户能够在移动设备上编写、阅读代码及学习编程技能，进一步提升了代码相关的交互和处理能力。
因此，如果你的日常以中文回复为主，在本地搭建一个通义千问用于回复中文问题，是最好的选择。并且，通义千问****开源免费，在自己电脑可以直接搭建一个，使用起来非常方便。再看看通义****千问回答问题的速度，很快：
如果，你想更友好的使用通义千万，这篇教程还会帮助你，搭建一个前端网站，零代码，按照教程逐步搭建好，使用通义千问，就更加方便，下面是带界面问答使用效果：
因为阿里通义千问是在本地运行，数据安全，并且开源免费，不用花钱充值买流量，开箱即用，良心好用。
2 下载通义千问大模型
推荐使用ollama工具，一行命令就能下载千问。
千问尺寸提供多种，如果你的电脑配置一般，比如是5年前的电脑，可以安装一个小尺寸的，从下面的尺寸列表中：
ollama run qwen:0.5bollama run qwen:1.8bollama run qwen:4bollama run qwen:7b 下面，已安装1.8b尺寸为例演示：
第一步，执行下面一行命令：
下面就开始安装，看到这个模型只有1.1G大小：
出现success，表明安装成功：
接下来，就直接可以提问通义千问，如下图所示：
AI时代，很多读者都想学习一点编程，下面我们提问它文章开头的那个问题，下面是GIF演示，回答很快，回答中文是真的好，用过llama3的读者有体会，每次提问后缀都要带上：请用中文回答，但是通义千问就不需要，对中文支持更好。
3 前端网页配置
第一步，安装docker。
第二步，docker拉取lobe镜像，无论windows还是mac，都是打开命令窗口，输入下面命令：
这条命令用于从 Docker Hub 上拉取最新的 lobehub/lobe-chat 镜像。
执行这条命令后，Docker 会将 lobehub/lobe-chat 镜像的最新版本下载到你的本地系统，以便你可以使用它创建和运行 Docker 容器。
第三步，再运行一条命令就可以了：
解释下这条命令，不想看的读者直接跳过：docker run：启动并运行一个新的 Docker 容器。-d：在后台（守护进程模式）运行容器，不会占用当前终端。–name lobe-chat：给容器分配一个名称 lobe-chat。这有助于以后通过名称管理容器。-p 10084:3210：将主机的 10084 端口映射到容器的 3210 端口。这样，主机的 10084 端口的请求会被转发到容器的 3210 端口。-e ACCESS_CODE=lobe66：设置环境变量 ACCESS_CODE 的值为 lobe66，这通常是用于在容器内配置应用程序的参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9515e6292b2b9fc24b82edff4c04bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b6f052a9d9c3fbf84cd4133a3eedb3/" rel="bookmark">
			代理伺服器分類詳解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代理伺服器的主要分類
代理伺服器可以根據不同的標準進行分類。以下是幾種常見的分類方式：
按協議分類按匿名性分類按使用場景分類 1. 按協議分類 根據支持的協議類型，代理伺服器可以分為以下幾類：
HTTP代理：專門用於處理HTTP協議的請求，常用於網頁流覽。HTTPS代理：支持加密的HTTPS協議，提供更高的安全性。SOCKS代理：支持多種協議，包括HTTP、FTP等，具有更廣泛的應用場景。FTP代理：專門用於處理FTP協議的檔傳輸請求。SMTP代理：用於處理電子郵件傳輸協議（SMTP）的請求。 2. 按匿名性分類 根據匿名性程度，代理伺服器可以分為以下幾類：
透明代理（Transparent Proxy）：不隱藏客戶端的IP地址，目標伺服器可以直接看到客戶端的真實IP。適用於緩存和內容過濾。匿名代理（Anonymous Proxy）：隱藏客戶端的IP地址，但會告知目標伺服器請求來自代理伺服器。適用於基本的隱私保護。高匿名代理（Elite Proxy）：完全隱藏客戶端的IP地址，目標伺服器無法識別請求來自代理伺服器。適用於需要高度隱私保護的場景。 3. 按使用場景分類 根據具體使用場景，代理伺服器可以分為以下幾類：
正向代理（Forward Proxy）：代理客戶端的請求，常用於用戶訪問外部網路資源。反向代理（Reverse Proxy）：代理伺服器端的請求，常用於負載均衡和安全防護。透明代理（Transparent Proxy）：無需客戶端配置，直接在網路層進行代理，常用於企業網路管理和內容過濾。 代理伺服器的應用場景 緩存和加速：通過緩存常用資源，代理伺服器可以顯著提高訪問速度，減少帶寬消耗。隱私保護：匿名代理和高匿名代理可以隱藏用戶的真實IP地址，保護隱私。內容過濾：透明代理可以根據預設規則過濾不良內容，適用於企業和學校網路管理。負載均衡：反向代理可以分發請求到多臺伺服器，均衡負載，提高系統穩定性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edfd42b9cf8f3d6e42b334c618f7436f/" rel="bookmark">
			JavaScript进阶：探索模块化、ES6&#43;与前端框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着Web技术的快速发展，JavaScript也在不断演进。ES6（ECMAScript 2015）及更高版本的发布为JavaScript带来了许多新特性和改进，使得JavaScript更加强大和易用。同时，模块化编程和前端框架的兴起也极大地推动了前端开发的现代化进程。本文将带您深入探索JavaScript的进阶话题，包括模块化、ES6+新特性以及前端框架的应用。
1. 模块化编程 模块化的重要性：解释模块化编程的概念、意义以及它在前端开发中的作用。ES6模块：介绍ES6中引入的模块系统，包括默认导出、命名导出、默认导入和命名导入等语法。构建工具：学习如何使用Webpack、Rollup等构建工具来打包和管理JavaScript模块。 2. ES6+新特性 箭头函数：详细讲解箭头函数的语法、特点以及与普通函数的区别。模板字符串：介绍模板字符串的概念、语法以及它在字符串拼接和格式化方面的优势。解构赋值：学习如何通过解构赋值快速地从数组或对象中提取数据。扩展运算符：掌握扩展运算符在数组和对象操作中的用法。类与继承：理解ES6中class关键字的引入以及基于类的面向对象编程方式。Promise与async/await：回顾Promise的概念和用法，并深入学习async/await语法在异步编程中的应用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eedbc29297284b433b44cf9c47d0994/" rel="bookmark">
			poi库简单使用（java如何实现动态替换模板Word内容）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Blue留言：
Blue的推荐：
什么是poi库？ 实现动态替换
第一步：依赖
第二步：实现word模板中替换文字
模板word：
通过以下代码：（自己建一个类，随意取名，主要是看test2这个函数）
第三步：实现word模板中替换图片
模板：
通过以下代码：
效果：
第四步：实现word模板表格 模板：
代码：
效果：
结语：
Blue留言： 💕💕💕Hello，Hello！！！好久没发文了，最近一直在写我的竞赛的项目，导致没时间写文章。正好，今天也差不多把竞赛项目写的差不多了，也可以来写写文章。俺今天分享一下简单的去使用poi库，希望各位能够从文章中获取经验！！！💕💕💕
Blue的推荐： 推荐学习poi库的网站：
https://www.w3ccoo.com/apache_poi/apache_poi_overview.html
推荐视频：
http://【Java导出Word太简单了，有手就会？】https://www.bilibili.com/video/BV18X4y1v7yD?vd_source=bb412cc25ca27e171f8e17085daad038
什么是poi库？ Apache POI 是一种流行的 API，允许程序员使用 Java 程序创建、修改和显示 MS Office 文件。 它是由 Apache Software Foundation 开发和分发的开源库，用于使用 Java 程序设计或修改 Microsoft Office 文件。 它包含将用户输入数据或文件解码为 MS Office 文档的类和方法。
实现动态替换 第一步：依赖 &lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.12.1&lt;/version&gt; &lt;/dependency&gt; 第二步：实现word模板中替换文字 首先我们制作一个模板word，将需要动态替换的文字用{{text}}去替换，其中text可以是任意名称
模板word： 通过以下代码：（自己建一个类，随意取名，主要是看test2这个函数） import com.deepoove.poi.XWPFTemplate; import com.deepoove.poi.data.PictureRenderData; import com.deepoove.poi.data.Pictures; import java.io.FileOutputStream; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eedbc29297284b433b44cf9c47d0994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b65dc5bdf9022a30d42042263d27f4/" rel="bookmark">
			Java版Flink使用指南——安装Flink和使用IntelliJ制作任务包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 安装Flink操作系统安装JDK安装Flink修改配置启动Flink测试 使用IntelliJ制作任务包新建工程Archetype 编写测试代码打包测试 工程代码参考资料 在《0基础学习PyFlink》专题中，我们熟悉了Flink的相关知识以及Python编码方案。这个系列我们将使用相对主流的Java语言，来实践Flink的相关设计。
安装Flink 操作系统 我安装的是Ubuntu 22TLS版。
cat /proc/version Linux version 5.15.0-112-generic (buildd@lcy02-amd64-051) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #122-Ubuntu SMP Thu May 23 07:48:21 UTC 2024
安装JDK sudo apt install openjdk-11-jdk 通过下面命令查看java版本号
java --version openjdk 11.0.23 2024-04-16
OpenJDK Runtime Environment (build 11.0.23+9-post-Ubuntu-1ubuntu122.04.1)
OpenJDK 64-Bit Server VM (build 11.0.23+9-post-Ubuntu-1ubuntu122.04.1, mixed mode, sharing)
安装Flink 从https://flink.apache.org/downloads/可以获得最新的地址
wget https://dlcdn.apache.org/flink/flink-1.19.1/flink-1.19.1-bin-scala_2.12.tgz . tar -xzf flink-*.tgz 修改配置 为了让本地之外的其他机器可以访问，我们需要修改Flink的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b65dc5bdf9022a30d42042263d27f4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/136/">«</a>
	<span class="pagination__item pagination__item--current">137/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/138/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>