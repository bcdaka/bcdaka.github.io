<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cea039e4aca0a74693208e0f44fe602/" rel="bookmark">
			15：00面试，15：06就出来了，问的问题有点变态。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从小厂出来，没想到在另一家公司又寄了。
到这家公司开始上班，加班是每天必不可少的，看在钱给的比较多的份上，就不太计较了。没想到6月一纸通知，所有人不准加班，加班费不仅没有了，薪资还要降40%,这下搞的饭都吃不起了。
还在有个朋友内推我去了一家互联网公司，兴冲冲见面试官，没想到一道题把我给问死了：
如果模块请求http改为了https,测试方案应该如何制定，修改?
感觉好简单的题，硬是没有答出来，早知道好好看看一大佬软件测试面试宝典了。
通过大数据总结发现，其实软件测试岗的面试都是差不多的。常问的有下面这几块知识点：
全网首发-涵盖16个技术栈 第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础 软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点… Linux grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
判断 101-200 之间有多少个素数，并输出所有的素数
一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例
…
MySQL 你用的Mysql是哪个引擎，各引擎之间有什么区别?
如何对查询命令进行优化?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cea039e4aca0a74693208e0f44fe602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807ca9f3d94fad3bc63f5f54743fd848/" rel="bookmark">
			GAMES104：09高级动画技术：动画树、IK和表情动画-学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一，动画混合1.1 数学混合：线性插值1.2 混合空间Blend Space1.2.1 1D Blend Space1.2.2 2D Blend Space1.2.3 Skeleton Masked Blending骨骼遮罩混合1.2.4 Addictive Blending 二，动画状态机Animation State Machine（ASM）2.1 动画状态机定义2.1.1 节点：分为clip和blend space。2.1.2 Transitions 2.2 Cross Fades 三，动画混合树3.1 Layered ASM3.2 动画混合树 四，IK技术（Inverse Kinematics）4.1 Two Bones IK4.2 Multi-Joint IK4.2.1 CCD(Cyclic Coordinate Decent)4.2.2 FARBRIK（Forward And Backward Reaching Inverse Kinematics）4.2.3 IK with Multiple End-Effectors4.2.4 Other IK Solutions其他解决方法（了解） 五，面部动画六，动画重定向6.1 同标准骨骼结构6.2 不同标准骨骼重定向6.3 动画重定向的挑战 一，动画混合 当我们知道了动画算法原理、有了各种动画切片素材（clips）后，怎么让这些动画自然地连接在一起，达到无极切换的效果呢？
1.1 数学混合：线性插值 不同于上节课的lerp（同一个clip内不同pose之间），动画blending需要在不同clip之间线性插值
计算权重：就跑步的案例来说，根据速度来变化两个clip之间的权重即可。
对齐混合时间线：，要lerp两个clip动画，就需要2个动画的循环时间线是一致的，比如跑步是左右脚各一次循环，走路也得是，并且脚的落地时间一致，做到时间线对应，这样才方便归一化后用权重lerp。下图就是跑是走的速度的两倍时如何根据当前速度进行插值时时间线上的变化（其中length是指时间长短），delta time是指要去对应clip1和clip2的哪一个时间帧去取对应的pose。
1.2 混合空间Blend Space 1.2.1 1D Blend Space 比如在直走、向左以及向右等多个clip中的插值，由于变量只有一个移动方向，所以是一维的混合，但采样点可能有多个，并且插值也不一定是线性或均匀的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/807ca9f3d94fad3bc63f5f54743fd848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f29fee30daf032fd7c7b278343ad682/" rel="bookmark">
			【数据结构】优先级队列（堆）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、优先级队列
1.1 概念
2、优先级队列的底层
2、1 堆的概念
2、2 堆的存储方式
2、3堆的创建
2.3.1 堆向下调整
2.3.2堆的创建
2.4 堆的插入与删除
2.4.1 堆的插入
2.4.2 堆的删除
3.常用接口介绍
3.1 PriorityQueue的特性
3.2 PriorityQueue 的构造方法 3.3 PriorityQueue 常用的成员方法
3.4 优先级队列的运用 -Oj题
1、优先级队列 1、1 概念 前面介绍过队列，队列是一种先进先出(FIFO)的数据结构，但有些情况下，操作的数据可能带有优先级，一般出队列时，可能需要优先级高的元素先出队列。
在这种情况下，数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象。这种数据结构就是优先级队列(Priority Queue)。
2、优先级队列的底层 优先级队列实现的使用的工具为二叉堆较普遍，JDK1.8中的PriorityQueue底层就使用了二叉堆这种数据结构，而堆实际就是在完全二叉树的基础上进行了一些调整。
2、1 堆的概念 如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储 在一 个一维数组中，并满足：Ki = K2i+1 且 Ki &gt;= K2i+2) i = 0，1，2…，则称为小堆(或大 堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
堆的性质：
结构性： 堆总是一棵完全二叉树。一个堆结构将由一个（Comparable对象的）数组和一个代表当前堆的大小的整数组成
堆序性： 堆中某个节点的值总是不大于或不小于其父节点的值；
2、2 堆的存储方式 从堆的概念可知，堆是一棵完全二叉树，因此可以层序的规则采用顺序的方式来高效存储
【注意】：对于非完全二叉树，则不适合使用顺序方式进行存储，因为为了能够还原二叉树，空间中必须要存储空节点，就会导致空间利用率比较低。
将元素存储到数组中后,通过数组对应下标，找出二叉树的父子关系；
节点下标关系左节点leftChild = parent *2 + 1右节点rightChild = parent *2 + 2父节点parent = ( child -1) / 2 则有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f29fee30daf032fd7c7b278343ad682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b622360ee844109e3632cb62987184bf/" rel="bookmark">
			Spring Cloud Stream与Kafka（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Stream与Kafka（一） ​ 在实际开发过程中，消息中间件用于解决应用解耦，异步消息，流量削峰等问题，实现高可用、高性能、可伸缩和最终一致性架构。不同的消息中间件实现方式不同，内部结构是不一样的。比如常见的RabbitMQ和Kafka，RabbitMQ有exchange，kafka有topic、partition，这些中间件的差异性导致我们在实际项目开发过程中造成了一定的干扰。如果采用了其中的一种，后面的业务需求，我想往另一种消息队列迁移，有一堆东西需要重做。Spring Cloud Stream是一种解耦的方式。
文章目录 Spring Cloud Stream与Kafka（一）简单介绍Kafka实例生产者消费者 简单介绍 Spring Cloud Stream是由一个中间件中立的核心组成，应用通过Spring Cloud Stream插入的input(相当于消费者)和output(相当于生产者)通道与外界交流。通道通过指定中间件的Binder与外部代理连接，业务开发者不需要关注具体的消息中间件，只需要关注Binder对应程序提供的抽象概念来使用中间件实现业务就可以了。Spring Cloud Stream许多抽象和原语，简化了消息驱动微服务应用程序的开发。 最底层是消息服务，中间层是绑定层，绑定层和底层的消息服务进行绑定，顶层是消息生产者和消费者，顶层可以向绑定层生产消费、获取消息。 Binder绑定器作为中间层，实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得应用程序不需要考虑具体的中间件实现。当需要升级或更换中间件产品时，我们要做的就是更换对应的Binder绑定器而不需要修改任何应用逻辑。
在Spring Cloud Stream中的消息通信方式遵循发布订阅模式，当一条消息被投递到消息中间件后，它会通过共享的主题进行广播，消费者在订阅的主题收到消息后触发自身的业务逻辑处理。这里的主题是抽象概念，代表发布共享消息给消费者的地方。在不同的消息中间中，主题可能对应着不同的概念。
Destination Binders是负责提供与外部消息系统集成的组件。Destination Bindings是外部消息系统和最终用户提供的应用程序代码(生产者/消费者)之间的桥梁。Message是生产者和消费者用于与目标绑定器通信的规范化数据结构。
Kafka实例 分别创建生产者kafka-producer和消费者kafka-consumer，引入依赖。 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 生产者 添加配置文件application.yml spring: cloud: stream: kafka: binder: # 绑定器 brokers: 192.168.182.171:9092 # broker的IP和端口 application: name: kafka-provider server: port: 8301 添加启动类 package org.lxx.stream.kafka.producer; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class KafkaProducerApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b622360ee844109e3632cb62987184bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad6a2d805bc037c7e269c2d8cdb51cf/" rel="bookmark">
			消息队列MQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQ概述 1.MQ简介 MQ，Message Queue，是一种提供消息队列服务的中间件，也称为消息中间件，是一套提供了消息生产、储、消费全过程API的软件系统。消息即数据。一般消息的体量不会很大。
2.MQ用途 限流削峰
MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮。
异步解耦
上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度
太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。
数据收集
分布式系统会产生海量级数据流，如:业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术通过MQ完成比类数据收集是最好的选择。
3.常见的MQ产品 ActiveMQ
ActiveMQ是使用Java语言开发一款MQ产品。早期很多公司与项目中都在使用。但现在的社区活跃度已经很低。现在的项目中已经很少使用了。
RabbitMQ
RabbitMQ是使用ErLang语言开发的一款MQ产品。其吞吐量较Kafka与RocketMQ要低，且由于其不是Java语言开发，所以公司内部对其实现定制化开发难度较大。
Kafka
Kafka是使用Scala/Java语言开发的一款MQ产品。其最大的特点就是高吞吐率，常用于大数据领域的实时计算、日志采集等场景。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring CloudNetcix，其仅支持RabbitMq与Kafka.
RocketMQ
RocketMQ是使用Java语言开发的一款MQ产品。经过数年阿里双 11 的考验，性能与稳定性非常高。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring Cloud Alibaba，其支持RabbitMQ、Kafka，但提倡使用RocketMQ.
RocketMQ的安装与启动 下载与安装 1.下载RocketMQ
https://rocketmq.apache.org/download/
2.windows下解压安装，配置环境变量ROCKETMQ_HOME
注意路径不要有中文或者空格等特殊字符
RocketMQ部署 1.启动nameserver
鼠标双击执行bin目录下的mqnamesrv.cmd 文件 或者 cmd 打开控制台，切换目录到rocket的bin目录下，执行命令：
start mqnamesrv.cmd 注：如果出现“找不到主类”的问题，需要将ROCKMQ_HOME和JAVA _HOME两个变量路径改掉，换成没有空格的路径
2.启动broker
执行bin目录下的 mqbroker.cmd 文件 或者 cmd 打开控制台，切换到bin目录下，执行命令：
start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true 默认端口是9876，autocreateTopicEnable=true表示允许自动创建topic
注：rocketMq运行环境中的内存不足会导致启动失败，可以修改配置文件
runserver.sh/runserver.cmd，runbroker.sh/runbroker.cmd中的配置参数
3.RocketMQ插件安装
访问 https://github.com/apache/rocketmq-externals/tags
下载rocketmq-console-1.0.0，并解压
在Eclipse中导入项目：
修改pom.xml文件中的java环境为当前环境1.8并执行compile指令
构建成功
在application.properties中设置地址namesrvAddr为localhost:9876
右键项目更新Maven
通过启动类App.java启动
在浏览器中打开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aad6a2d805bc037c7e269c2d8cdb51cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df024873c1d8e872288748c2b28810f8/" rel="bookmark">
			Linux-kubesphere（K8S）小白单机版搭建部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、虚拟机环境设置
二、Kubesphere安装
1、安装工具
1）Socat、conntrack、ebtables、ipset
2）Docker
2、下载KubeKey
3、开始安装
参考官网：https://www.kubesphere.io/zh/docs/v3.4/quick-start/all-in-one-on-linux/
一、虚拟机环境设置 环境：VM虚拟机 + Centos7.x
操作系统Centos7.x-86_x64硬件配置：内存4G,CPU2核 VM启动后，关闭并禁用防火墙 （本地直接关闭，公网环境开放端口和配置对应白名单访问即可）
# systemctl stop firewalld # systemctl disable firewalld
关闭selinux (主要作用是强化系统的安全性和保护系统资源免受未经授权的访问和攻击)
# sed -i 's/enforceing/disabled/' /etc/selinux/config #永久（配置后需重启机器）
# setenforce 0 #临时
测试拉取下最新的包命令
# yum update
如果提示如下错误：
解决方式可参考：“Could not resolve host: mirrorlist.centos.org； 未知的错误“
如果同时存在2个基础源 Centos-7.repo和Centos-Base.repo，则保留一份即可（推荐使用阿里云的yum源），如果都不是阿里云的yum源，均先备份，再下载阿里云yum源。
此处因之前处理：“Could not resolve host: mirrorlist.centos.org； 未知的错误“问题的时候已经下载了阿里云的 Centos-7.repo，所以这里只需要备份原有的CentOS-Base.repo即可
先备份原生的yum源
# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
修改其他源可参考：CentOS7更新yum源
阿里云的yum源，命令如下（已下载的无需执行）：
# wget -O /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo
二、Kubesphere安装 1、安装工具 1）Socat、conntrack、ebtables、ipset # yum -y install socat
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df024873c1d8e872288748c2b28810f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0164ebc4eb15d5b15a8bf254041b992b/" rel="bookmark">
			UE5 UMG UI编辑器工作流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建UI控件 1.在内容菜单（Content Browser）面板，点击添加（Add）或者右键空白处，依次选择用户界面（User Interface）/ 控件蓝图（Widget Blueprint）。
2.在弹出来的窗口中，点击User Widget即可创建一个UI控件，可以自定义命名（规范一点可以命名为WBP_XXX）。
初识UMG UI 编辑器 双击UI控件蓝图打开UMG 设计器：
UMG主要由七个部分组成：
选项卡用途1.设计器（Designer）设计UI布局的画布，用于搭建并显示UI，可以摆放UI在屏幕中的位置2.调色板（Palette）可供使用的控件列表，引擎自带的或用户自定义的控件模版3.细节面板（Details）控件的属性，包括旋转变换属性等4.层级面板（Hierarchy）当前创建的所有控件列表都显示在这里，UI之间的层级关系5.动画面板（Animations）为UI创建的动画都在这里显示6.时间轴（Timeline）控件动画的属性和关键帧，可以制作帧动画7.编辑器模式（Editor Mode）有设计器和图表两种编辑模式切换，图表模式与蓝图编辑器具有几乎相同的功能。 tip: 画布上的操作，通过按住右键并移动鼠标即可上下左右平移画布，通过鼠标滚轮滑动可进行缩放画布。 搭建UI界面 在进行UI 设计之前，你应该先往画布中放置一个Canvas Panel作为根物体。
可以在调色板里面搜索Canvas Panel或者在展开面板下找到：鼠标左键按住并拖拽到画布区域或层级面板中松开即可。
之后你就可以在画布中放置你所需的其他控件了，比如文本、按钮等等。
你还可以重命名控件、拖动控件、调整大小，也可以通过细节面板修改相关信息。
在设计好UI 界面之后，记得点击编辑器左上角的编译并保存。
显示UI界面 当你很高兴的运行游戏时却发现看不见你刚才设计的UI，这是因为要将UI显示到Game视口中，还要做一点额外的蓝图操作。
1.在关卡编辑器主工具栏处依次点击蓝图/打开关卡蓝图。
2.右键空白处搜索并添加Event BeginPlay节点
3.将鼠标放置到Event BeginPlay节点的执行引脚上，按住左键并拖拽到其余空白处松开并搜索Create Widget节点，点击Class参数下拉列表，搜索我们要创建的UI实例“WBP_HUD”。
4.同样的操作将Create Widget节点的执行引脚连接到Add to Viewport节点，并将其返回值Return Value连接到Target。
5.点击左上角编译并保存，关闭该窗口，点击主编辑界面的运行按钮，这时就能在游戏视口上看到制作的UI界面了。
更新UI界面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60827b228e2dfac6ccecc82b49d02a65/" rel="bookmark">
			Docker 安装消息队列RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉取镜像 docker pull rabbitmq 拉取最新镜像
创建并运行 docker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5673:5672 rabbitmq 开启Web管理 进入容器
docker exec -it rabbitmq /bin/bash 开启web管理
rabbitmq-plugins enable rabbitmq_management http://localhost:15672 进入管理端
账号密码默认都是guest
各端口作用 AMQP: 5672 - 默认的消息传递协议端口客户端连接。
管理控制台: 15672 - Web 界面用于管理和监控。
AMQP（SSL/TLS）: 5671 - 加密的 AMQP 连接端口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f098ef00e0f7bae68a2b36fb3695673a/" rel="bookmark">
			奇文网盘项目对应windows版本的中间件下载，otp，rabbitmq，postgresql，onlyoffice（在线预览编辑等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的解压是百度网盘，要会员，油猴也无法下载，所有我下载之后给你们提供阿里云盘链接（不限速）
本次软件版本介绍：
01-otp_win64_24.1
02-rabbitmq-server-3.9.8
03-postgresql-9.6.23-2-windows-x64
04-Redis-x64-5.0.14
05-没有mysql安装mysql
06-onlyoffice-documentserver
压缩包中有文档的安装步骤，原作者和我的
以下是分享链接：
阿里云盘快传
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85631da734907cf5975ee98c02eab19d/" rel="bookmark">
			新手该如何选择与小程序定位相关的关键词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词的优化是提高小程序排名的关键步骤之一，所以如何选择与小程序定位相关的关键词是一个很重要的过程，需要考虑多个因素以确保关键词既符合小程序的业务特性，又能吸引目标用户。以下是一些具体的步骤和建议：
1. 深入了解小程序定位
明确业务范畴：首先，要清晰地定义小程序的业务范围、服务内容或产品特性。
了解目标用户：分析目标用户的群体特征、需求偏好及搜索习惯，这将有助于选择更符合用户搜索意图的关键词。
2. 市场调研与竞品分析
市场调研：通过问卷调查、用户访谈、行业报告等方式收集市场数据，了解行业趋势和用户需求变化。
竞品分析：分析同类型内其他小程序或相似应用的关键词使用情况，观察它们是如何选择和优化关键词的。
3. 关键词选择原则
相关性：确保所选关键词与小程序的内容、功能或服务紧密相关。
搜索量：选择具有一定搜索量的关键词，以确保能够获得足够的曝光机会。
竞争度：考虑关键词的竞争程度，避免选择过于热门、难以排名的关键词。
准确性：选择能够准确反映小程序特色的关键词，以提高转化率。
4. 使用工具辅助选择
关键词规划工具：利用如微信指数、百度指数等关键词规划工具，分析关键词的搜索量、趋势、相关性等数据。
5. 筛选与组合关键词
关键词筛选：根据以上原则筛选出合适的关键词。注意关键词的字数（一般为2-4个）、匹配性以及与标题的契合度。
关键词组合：将筛选出的关键词进行组合搭配，形成更具体、更具针对性的短语或句子。这样可以在搜索结果中获得更高的排名和点击率。
6. 持续优化与调整
定期监测：利用小程序后台的数据分析工具监测关键词的表现情况，包括搜索量、点击率、转化率等指标。
优化调整：根据数据反馈来进行关键词优化的调整。对于表现不佳的关键词进行替换或调整组合方式；对于表现优异的关键词则可以考虑增加曝光机会或进行进一步挖掘。
7. 注意事项
避免堆砌关键词：在小程序名称、描述等位置合理使用关键词，避免过度堆砌导致内容不好或影响用户的体验。
保持自然流畅：关键词的使用应自然的加入在文本中，保持内容的流畅性和可读性。
遵守平台规则：确保所选关键词符合微信小程序平台的规则和政策要求。
综上所述，选择与小程序定位相关的关键词需要综合考虑多个因素并进行持续优化调整。通过合理的关键词选择和使用策略，可以提高小程序的搜索排名和曝光率进而吸引更多目标用户。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8df48458877266d4872117594dd75ea/" rel="bookmark">
			小程序常用的模板语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WXML 文件 &lt;!-- page.wxml --&gt; &lt;view&gt; &lt;!-- 数据绑定: 将数据 message 绑定到视图中 --&gt; &lt;view&gt;{{message}}&lt;/view&gt; &lt;!-- 条件渲染: 根据 isLoggedIn 的值显示不同的内容 --&gt; &lt;view wx:if="{{isLoggedIn}}"&gt;Welcome back!&lt;/view&gt; &lt;view wx:else&gt;Please log in.&lt;/view&gt; &lt;!-- 列表渲染: 遍历 items 数组，并为每个项渲染一个 text 标签 --&gt; &lt;view wx:for="{{items}}" wx:key="id"&gt; &lt;text&gt;{{item.name}}&lt;/text&gt; &lt;/view&gt; &lt;!-- 属性绑定: 将 imageUrl 绑定到 image 组件的 src 属性 --&gt; &lt;image src="{{imageUrl}}" mode="aspectFill"/&gt; &lt;!-- 事件绑定: 点击按钮时触发 handleTap 方法 --&gt; &lt;button bindtap="handleTap(2)"&gt;Click Me&lt;/button&gt; &lt;!-- 模板引用: 引用外部定义的 userTemplate 模板并传递数据 --&gt; &lt;import src="template.wxml"/&gt; &lt;template is="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8df48458877266d4872117594dd75ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d987b3a044cce43de97344a23a5018/" rel="bookmark">
			nginx &#43; lnmp架构部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、nginx简介 Nginx是一款轻量级的Web服务器/反向代理服务器及电子（IMAP/POP3）代理服务器。
Nginx由俄罗斯的程序设计师Igor Sysoev所开发，最初供俄国大型的入口网站及搜寻引擎Rambler使用。
第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。
nginx的特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
二、nginx的特性与优点 1、nginx特性 Nginx是一个很牛的高性能WEB和反向代理服务器，它具有很多非常优越的特性：
（1）在高连接并发情况下，nginx是apache服务器不错的替代品，能够支持高达5万个并发连接数的响应
（2）使用epoll and kqueue作为开发模型
（3）Nginx作为负载均衡服务器：nginx既可以在内部直接支持和PHP程序对外进行服务，也可以支持作为HTTP代理服务器对外进行服务
（4）Nginx采用C进行编写，不论系统资源开销还是CPU使用效率都比Perlbal要好很多。
2、nginx的优点 （1）高并发连接：官方测试能够支撑5万并发连接，在实际生产环境中跑到2-3万并发连接数
（2）内存消耗少：在3万并发连接下，开启的10个nginx进程才消耗150M内存（15M*10=150M）
（3）配置文件非常简单：风格跟程序一样通俗易懂
（4）成本低廉：nginx为开源软件，可以免费使用。而购买F5 BIG-IPNetScaler等硬件负载均衡交换机则需要十多万至几十万人民币
（5）支持Rewrite重写规则：能够根据域名、URL的不同，将HTTP请求分到不同的后端服务器群组
（6）内置的健康检查功能：如果Nginx Proxy后端的某台Web服务器宕机了，不会影响前端访问
（7）节省带宽：支持GZIP压缩，可以添加浏览器本地缓存的Header头
（8）稳定性高：用于反向代理，宕机的概率微乎其微
（9）模块化设计：模块可以动态编译
（10）外围支持好：文档全，二次开发和模块较多
（11）支持热部署：可以不停机重载配置文件
（12）支持事件驱动、AIO（AsyncIO，异步IO）、mmap（Memory Map，内存映射）等性能优化
三、nginx的功能及应用类别 1、nginx的基本功能 （1）静态资源的web服务器，能缓存打开的文件描述符
（2）http、smtp、pop3协议的反向代理服务器
（3）缓存加速、负载均衡
（4）支持FastCGI（fpm，LNMP），uWSGI（Python）等
（5）模块化（非DSO机制），过滤器zip、SSI及图像的大小调整
（6）支持SSL
2、nginx的扩展功能 （1）基于名称和IP的虚拟主机
（2）支持keepalive
（3）支持平滑升级
（4）定制访问日志、支持使用日志缓冲区提高日志存储性能
（5）支持URL重写
（6）支持路径别名
（7）支持基于IP及用户的访问控制
（8）支持速率限制，支持并发数限制
3、nginx的应用类别 （1）使用nginx结合FastCGI运行PHP、JSP、Perl等程序
（2）使用nginx作反向代理、负载均衡、规则过滤
（3）使用nginx运行静态HTML网页、图片
（4）nginx与其他新技术的结合应用
四、nginx的模块与工作原理 nginx由内核和模块组成。其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block（location是nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作
1、nginx的模块分类 nginx的模块从结构上分为核心模块、基础模块和第三方模块
（1）HTTP模块、EVENT模块和MAIL模块等属于核心模块
（2）HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块属于基本模块
（3）HTTP Upstream模块、Request Hash模块、Notice模块和HTTP Access Key模块属于第三方模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d987b3a044cce43de97344a23a5018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48976a9c8de1bd8bba5d37acc8021fb6/" rel="bookmark">
			★ 数据结构 ★ 二叉树（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ciallo～(∠・ω&lt; )⌒☆ ~ 今天，我将继续和大家一起学习数据结构中的二叉树~
目录
一 二叉树链式结构的实现
二 二叉树的遍历
2.1 前序、中序以及后序遍历
2.2 层序遍历
三 二叉树实现的一些函数
3.1 二叉树结点个数
3.2 二叉树叶子结点个数
3.3 二叉树层数
3.4 二叉树第k层结点个数
3.5 二叉树查找值为x的结点
3.6二叉树的销毁
3.7 判断二叉树是否是完全二叉树
四 二叉树的一些选择题
一 二叉树链式结构的实现 二叉树的基本结构：
typedef int BTDataType; typedef struct BinaryTreeNode { BTDataType a; struct BinaryTreeNode* left; struct BinaryTreeNode* right; }BTNode; 手动快速创建一棵简单的二叉树的方式~
BTNode* CreatBinaryTree() { BTNode* node1 = BuyNode(1); BTNode* node2 = BuyNode(2); BTNode* node3 = BuyNode(3); BTNode* node4 = BuyNode(4); BTNode* node5 = BuyNode(5); BTNode* node6 = BuyNode(6); node1-&gt;left = node2; node1-&gt;right = node4; node2-&gt;left = node3; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } 注意：上述代码并不是创建二叉树的方式，真正创建二叉树方式后序讲解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48976a9c8de1bd8bba5d37acc8021fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d25e360d7a25216702d3033d18bd7e3/" rel="bookmark">
			react面试题九
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、React Router是如何实现单页应用的路由管理的？ React Router 实现单页应用（SPA）的路由管理主要通过以下方式：
一、路由模式 React Router 提供了多种路由模式来适应不同的开发需求，其中主要的两种模式是 HashRouter 和 BrowserRouter。
HashRouter：
使用 URL 的哈希部分（即#后面的部分）来进行路由。通过监听浏览器的 hashchange 事件来感知 URL 中 hash 部分的变化，从而触发路由的切换。当 hash 发生变化时，React Router 会根据新的 hash 值来匹配对应的路由并展示相应的组件。这种模式不会导致页面的完全重新加载，适用于简单的单页应用或在不支持 HTML5 History API 的环境中使用。 BrowserRouter：
使用 HTML5 History API（如 history.pushState 和 history.replaceState）来改变 URL，从而在不刷新页面的情况下改变浏览器地址栏的 URL。通过监听 popstate 事件来感知 URL 的变化，并做出相应的路由处理。URL 中的路径部分用于路由匹配，使得 URL 更加自然和友好，但需要服务器端的配置支持来处理前端路由未匹配到的路径请求。 二、路由配置 在使用 React Router 时，通常会在应用的顶层组件中包裹一个 Router 组件（如 HashRouter 或 BrowserRouter），并在其内部定义一系列的 Route 组件，每个 Route 组件都指定一个 path 属性和一个 component 或 element 属性，分别表示要匹配的 URL 路径和要渲染的组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d25e360d7a25216702d3033d18bd7e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ff93ddf3e2060ca8551778c6950dd3/" rel="bookmark">
			Stable Diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion是一种基于深度学习的文本到图像生成模型，其原理主要基于扩散模型（Diffusion Model）的变体，即潜在扩散模型（Latent Diffusion Model, LDM）。
原理 一、技术架构与组成 Stable Diffusion由三个主要部分组成：变分自编码器（VAE）、U-Net和一个文本编码器。
变分自编码器（VAE）：
VAE是一种生成模型，用于将图像压缩到低维的潜在空间（latent space）中，并能够从潜在空间中恢复出图像。VAE由编码器和解码器两部分组成。编码器将图像压缩为潜在空间中的低维表示，而解码器则负责从潜在空间中恢复出图像。 U-Net：
U-Net是一个用于图像分割的神经网络架构，但在Stable Diffusion中，它被用作噪声预测器（noise predictor）。U-Net通过一系列卷积层、上采样和下采样操作，逐步去除图像中的噪声，并注入语义信息，从而生成与文本描述相匹配的图像。 文本编码器：
文本编码器通常使用预训练的CLIP模型（Contrastive Language-Image Pre-training），将文本描述转换为嵌入空间中的向量。这些文本嵌入向量作为条件信息，引导U-Net在生成图像时遵循特定的文本描述。 二、工作原理 Stable Diffusion的工作原理可以分为前向扩散和反向扩散两个过程：
前向扩散（Forward Diffusion）：
在前向扩散过程中，高斯噪声被迭代地添加到图像的潜在表示中，逐渐将图像转换为纯噪声图像。这个过程类似于物理上的扩散现象，即噪声在图像中逐渐扩散并覆盖原始图像信息。 反向扩散（Reverse Diffusion）：
反向扩散是前向扩散的逆过程，旨在从纯噪声图像中逐步恢复出原始图像。在这个过程中，U-Net作为噪声预测器，逐步去除图像中的噪声，并注入与文本描述相匹配的语义信息。通过多次迭代，U-Net能够生成与文本描述高度匹配的图像。 三、条件引导与文本嵌入 文本编码器将输入的文本描述转换为嵌入向量，这些向量作为条件信息引导U-Net在生成图像时遵循特定的文本描述。通过交叉注意力机制（cross-attention mechanism），文本嵌入向量被注入到U-Net的每一层中，以确保生成的图像与文本描述保持一致。 四、优势与应用 Stable Diffusion的优势在于其能够在潜在空间中操作，从而显著降低了计算量并提高了生成速度。这使得Stable Diffusion能够在大多数配备有适度GPU的电脑硬件上运行，而无需依赖云计算服务。
Stable Diffusion的应用领域非常广泛，包括艺术创作、游戏设计、电影制作等。通过输入文本描述，用户可以快速生成高质量的图像，极大地提高了创作效率和灵活性。
综上所述，Stable Diffusion通过结合变分自编码器、U-Net和文本编码器，实现了从文本到图像的生成过程。其潜在空间操作和条件引导机制使得Stable Diffusion在图像生成领域具有显著的优势和广泛的应用前景。
VAE 在Stable Diffusion模型中，虽然变分自编码器（VAE）扮演了重要的角色，但通常不被视为该模型的重点，这主要基于以下几个原因：
1. 角色定位 辅助工具：VAE在Stable Diffusion中主要用于将图像压缩到潜在空间（latent space），并从潜在空间中恢复图像。这是为了降低计算量并提高生成速度，而不是直接参与图像生成的核心过程。编码与解码：VAE的编码器和解码器分别负责将图像压缩到潜在空间和从潜在空间恢复图像，这是一个预处理和后处理步骤，而非图像生成的主要逻辑。 2. 核心机制 扩散模型：Stable Diffusion的核心是基于扩散模型的潜在扩散模型（LDM）。这个模型通过前向扩散添加噪声和反向扩散去除噪声的过程来生成图像。VAE虽然参与其中，但主要是为了优化这一过程，而非主导。文本到图像的映射：Stable Diffusion的关键在于将文本描述映射到图像空间，这一过程主要由文本编码器和U-Net（作为噪声预测器）共同完成。VAE在这一过程中主要起辅助作用。 3. 实际应用 计算效率：VAE通过压缩图像到潜在空间，显著降低了后续处理的计算量，使得Stable Diffusion能够在普通GPU上运行。然而，这种优化是基于模型整体架构的考虑，而非VAE本身的独特性。模型集成：在许多Stable Diffusion的实现中，VAE已经被集成到模型中，成为了一个不可分割的部分。但这并不意味着VAE是模型的重点，而是模型设计中的一个必要环节。 4. 发展趋势 技术演进：随着技术的不断发展，新的方法和模型不断涌现。Stable Diffusion也在不断迭代和优化中，可能会引入更先进的技术来替代或增强VAE的作用。多模态学习：未来的发展方向可能包括多模态学习，即结合多种类型的数据（如图像、文本、音频等）来提升模型的性能和泛化能力。在这种趋势下，VAE可能只是众多技术组件中的一个。 Unet 在Stable Diffusion（简称SD）模型中，UNet处理的是经过VAE（变分自编码器）压缩得到的latents（潜在表示）。具体来说，SD模型是一个基于latent的扩散模型，其核心工作流程可以概括为以下几个步骤：
图像压缩：首先，通过VAE（特别是其encoder部分）将输入图像压缩到latent空间，得到图像的latent表示。这一步骤中，VAE的encoder将原始图像（例如，大小为H×W×3的图像）编码为一个大小较小的latent（例如，64×64×4的latent，取决于VAE的具体参数设置）。
Latent生成：然后，利用UNet作为扩散模型的主体部分，在文本条件的引导下生成新的latent表示。UNet通过其编码器-解码器结构，结合cross attention机制，将CLIP text encoder提取的文本嵌入作为条件，逐步生成与文本描述相匹配的latent。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ff93ddf3e2060ca8551778c6950dd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4035a1a0133d49a600d9aab06114f2c/" rel="bookmark">
			卡牌抽卡机小程序搭建，探索新鲜有趣的拆卡体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡牌作为一种新的潮玩方式，市场热度逐渐提升，在各大社交平台上，拆卡的话题层出不穷，各种卡牌迅速走红，成为了当下“顶流”，吸引了众多的消费者！卡牌的价格低，还涉及到了动漫等各个热门IP，市场火热非凡。
随着互联网发展，卡牌在线上发展的模式深受大众喜爱，玩法新颖、种类丰富的抽卡机小程序吸引到了无数的玩家。抽卡机小程序是一个线上自助拆卡平台，能够为玩家带来丰富便捷的拆卡体验，提高玩家对小程序的忠诚度，也能增加卡牌商家的盈利。那么抽卡机小程序拥有哪些开发特点呢？
1、卡牌种类：小程序中的卡牌系列是吸引玩家的关键，商家可以与各大IP合作，推出具有吸引力的卡牌，为玩家带来丰富的卡牌选择，吸引到更多的消费者。
2、随机性：抽卡机小程序具有随机性，用户在拆卡时可以随机获得一款卡牌，增加了拆卡时惊喜性和未知性，也同时保证了抽卡的公平性。
3、碎片合成：小程序具有合成功能，玩家在平台上拆到的小卡可以存放在盒柜中，玩家在盒柜上可以清晰查看剩余卡牌的情况，刺激玩家集齐一系列卡牌，玩家在集齐后还可以合成碎片，兑换隐藏款限量款卡牌，可以刺激玩家下单拆卡。
4、社交互动：抽卡机小程序拥有社交互动性，平台玩家之间可以进行交流互动，讨论拆卡的乐趣，还可以进行互换卡牌等，为玩家带来更多的游戏乐趣。
5、更新优化：抽卡机小程序可以持续进行优化升级，对卡牌种类进行创新，提高平台的新鲜有趣性。
卡牌市场是一个拥有巨大发展潜力的行业，抽卡机小程序也将为玩家带来一个独特体验的模式，同时为更多想要入局的商家创业者提供一个新的机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad55ddac52097cb4f5506843d57a9c4/" rel="bookmark">
			货运搬家小程序app定制开发过程中需要的主要功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		货运搬家小程序是一个集成了物流服务全过程的数字化解决方案，它通过移动平台提供注册与登录、货物管理、车辆管理、路线规划、货物分配、订单管理、实时追踪、评价与反馈、价格透明等功能。
具体的功能：
注册与登录用户可以通过小程序注册账号并登录，以便进行后续操作和管理。货物管理用户可以在小程序中添加、编辑和删除货物信息，包括货物名称、数量、重量、尺寸等。车辆管理类似于货物管理，用户可以在小程序中添加、编辑和删除车辆信息，包括车型、载重量、车辆尺寸等。路线规划小程序可以根据货物信息和车辆信息自动生成最佳路线，考虑起始地点、目的地点、距离、交通状况等因素。货物分配根据生成的最佳路线，将货物分配给符合条件的车辆，用户可以查看货物与车辆的匹配情况以及分配结果。订单管理生成订单并存储相关信息，包括货物、车辆、路线、司机等，用户可以查看订单列表、详情以及订单状态。实时追踪提供货物运输的实时追踪功能，用户可以查看货物所在位置和运输进度。评价与反馈用户可以对司机、货物以及整个运输过程进行评价和反馈，司机也可以对用户进行评价。价格透明用户可以实时查询货物运输价格，包括基于货物重量、体积、运输距离等因素的费用计算。 货运搬家小程序的制作包括商家端和用户端，商家端具有强大的功能，在货运搬家小程序制作的过程中也可以提出自己的需求，个性化定制。在不懂的过程中可以随时向我们咨询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4c691c8b167c9f8e7776660c91b058/" rel="bookmark">
			idea怎么从commit信息中打开对应文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击Commit
右击想要打开的文件，点击Jump to Source
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020cea5c4138af4681f0366ba35d8504/" rel="bookmark">
			《机器学习》 决策树 ID3算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是决策树？
1、概念
2、优缺点
3、核心
4、需要考虑的问题
二、决策树分类标准，ID3算法
1、什么是ID3 算法
2、ID3算法怎么用
1）熵值计算公式
2）用法实例
三、实操 ID3算法
1）求出play标签的熵值
2）分别计算天气、温度、湿度、风、play的信息增益
• 求outlook 总熵值及信息增益
• 求temperature 总熵值及信息增益
• 求humidity总熵值及信息增益
• 求windy总熵值及信息增益
当前可以绘画出决策树根节点部分：
3）此时需要对sunny对应的块进行当做一个表来计算其内数值的熵：
• play标签的熵
• 求temperature 总熵值及信息增益
• 求humidity总熵值及信息增益
• 求windy总熵值及信息增益
4）此时需要对rainy对应的块进行当做一个表来计算其内数值的熵：
• play标签的熵
• 求temperature 总熵值及信息增益
• 求humidity总熵值及信息增益
• 求windy总熵值及信息增益
一、什么是决策树？ 1、概念 决策树是机器学习中一种常见的分类和回归算法。它基于树状结构的模型，通过对数据进行逐步划分，最终生成一棵决策树来进行预测或分类任务。
在决策树中，每个节点代表一个特征或属性，每个分支代表该特征的不同取值，而每个叶节点代表一个类别或者一个预测结果。
决策树的构建过程通过选择最优的特征和划分点来进行。这个选择过程通常基于一些衡量指标，比如信息增益、基尼指数等，来选择最能区分不同类别的特征进行划分。递归地对数据集进行划分，直到满足某个停止条件，例如达到最大深度、样本数量不足等。这样就生成了一棵完整的决策树模型。
2、优缺点 易于理解和解释，能够处理离散和连续型特征，对缺失值和异常值具有鲁棒性，同时可以处理多分类问题。
容易过拟合训练数据，对噪声敏感，不适合处理高维稀疏数据。针对这些问题，可以采用剪枝、集成学习等方法进行改进。
3、核心 所有数据从根节点一步一步落到叶子结点
例如下图，房产是根节点，下面的车辆、年收入是非叶子节点，那么其结果可以贷款和不可贷款就是叶子结点
4、需要考虑的问题 1）哪个节点作为根节点？哪些节点作为中间节点？哪些节点作为叶子结点？
2）节点如何分裂？
3）节点分裂标准的依据是什么？
二、决策树分类标准，ID3算法 1、什么是ID3 算法 衡量标准：熵值，熵值表示随机变量不确定性的度量，或者说是物体内部的混乱程度。
用于根据给定的训练数据集构建决策树模型，其基本思想是在每个节点上选择最佳的属性来进行划分，以使得划分后的子节点中的样本尽可能属于同一类别。
ID3算法通过计算每个属性的信息增益来度量属性选择的好坏。信息增益反映了在已知某个属性的取值的条件下，对类别的不确定性减少了多少。在每个节点上选择信息增益最大的属性作为划分依据，递归地构建决策树。
其缺点是仅适用于处理离散型属性，不适用于处理连续型属性。此外，ID3算法在处理缺失数据时也存在问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/020cea5c4138af4681f0366ba35d8504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/babd6cbb728a10101460d8e31961b0b8/" rel="bookmark">
			C&#43;&#43;第四十一弹---C&#43;&#43;11新特性深度解析：让你的代码更现代、更高效(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1. C++11简介
2. 统一的列表初始化
2.1 ｛｝初始化
2.2 std::initializer_list
3. 声明
3.1 auto
3.2 decltype
3.3 nullptr
3.4 STL中一些变化
1. C++11简介 阶段内容C with
classes类及派生类、公有和私有成员、类的构造和析构、友元、内联函数、赋值运算符
重载等C++1.0添加虚函数概念，函数和运算符重载，引用、常量等C++2.0更加完善支持面向对象，新增保护成员、多重继承、对象的初始化、抽象类、静
态成员以及const成员函数C++3.0进一步完善，引入模板，解决多重继承产生的二义性问题和相应构造和析构的处
理C++98C++标准第一个版本，绝大多数编译器都支持，得到了国际标准化组织(ISO)和美
国标准化协会认可，以模板方式重写C++标准库，引入了STL(标准模板库)C++03C++标准第二个版本，语言特性无大改变，主要：修订错误、减少多异性C++05C++标准委员会发布了一份计数报告(Technical Report，TR1)，正式更名
C++0x，即：计划在本世纪第一个10年的某个时间发布C++11增加了许多特性，使得C++更像一种新语言，比如：正则表达式、基于范围for循
环、auto关键字、新容器、列表初始化、标准线程库等C++14对C++11的扩展，主要是修复C++11中漏洞以及改进，比如：泛型的lambda表
达式，auto的返回值类型推导，二进制字面常量等C++17在C++11上做了一些小幅改进，增加了19个新特性，比如：static_assert()的文
本信息可选，Fold表达式用于可变的模板，if和switch语句中的初始化器等C++20自C++11以来最大的发行版，引入了许多新的特性，比如：模块(Modules)、协
程(Coroutines)、范围(Ranges)、概念(Constraints)等重大特性，还有对已有
特性的更新：比如Lambda支持模板、范围for支持初始化等C++23制定ing 在2003年C++标准委员会曾经提交了一份技术勘误表(简称TC1)，使得C++03这个名字已经取代了C++98称为C++11之前的最新C++标准名称。不过由于C++03(TC1)主要是对C++98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并称为C++98/03标准。从C++0x到C++11，C++标准10年磨一剑，第二个真正意义上的标准珊珊来迟。相比于C++98/03，C++11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中
约600个缺陷的修正，这使得C++11更像是从C++98/03中孕育出的一种新语言。相比较而言，
C++11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更
强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个
重点去学习。C++11增加的语法特性非常篇幅非常多，我们这里没办法一 一讲解，所以本节课程
主要讲解实际中比较实用的语法。
C++11官网https://en.cppreference.com/w/cpp/11小故事：
1998年是C++标准委员会成立的第一年，本来计划以后每5年视实际需要更新一次标准，C++国际标准委员会在研究C++ 03的下一个版本的时候，一开始计划是2007年发布，所以最初这个标准叫C++ 07。但是到06年的时候，官方觉得2007年肯定完不成C++ 07，而且官方觉得2008年可能也完不成。最后干脆叫C++ 0x。x的意思是不知道到底能在07还是08还是09年完成。结果2010年的时候也没完成，最后在2011年终于完成了C++标准。所以最终定名为C++11。
2. 统一的列表初始化 2.1 ｛｝初始化 在C++98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定。比如：
// 1、{}初始化 struct Point { int _x; int _y; }; int main() { // C语言中支持数组使用{}花括号初始化 int array1[] = { 1,2,3,4,5 }; int array2[5] = { 0 }; int array3[5]{ 0 };// 可以不加= // C语言中结构体支持使用{}初始化 Point p = { 1,2 }; return 0; } 测试结果 C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/babd6cbb728a10101460d8e31961b0b8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/21/">«</a>
	<span class="pagination__item pagination__item--current">22/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/23/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>