<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4126153d78c5f3445f71b6036b7d23/" rel="bookmark">
			DVWA靶场-SQL Injection（难度低、中、高）-sqlmap自动化漏洞扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DVWA靶场-SQL Injection（难度低、中、高）-sqlmap自动化漏洞扫描 一、环境搭建 1.搭建dvwa靶场环境 此处使用docker容器搭建靶场。使用docker平台即可实现靶场的快速搭建，比较方便。使用docker搜索dvwa镜像：docker search dvwa。
此处选择第一个镜像文件下载：docker pull citizenstig/dvwa。
下载完毕后，可以使用docker images来查看所有的镜像，从中可以找到dvwa。
从图中可以看出已经将镜像文件下载到本地，使用以自定义的密码启动mysql服务，并以后台方式运行的方式：docker run --name dvwa -d -p 80:80 -p 3306:3306 -e MYSQL_PASS=“mypass” docker.io/citizenstig/dvwa。
截图中可以看到，容器中的80端口映射到本机80端口冲突，是因为本机80端口已被占用，所以端口映射改成”-p 8080:80”，这样就不会有端口冲突。 此处可以选择没有被占用的端口进行映射。
展示正在运行的容器列表及主要信息：docker ps（加上-a参数展示全部容器列表）。
浏览器输入本机IP:8080，访问得到dvwa页面，如果访问不成功，重启docker：systemctl restart docker，再运行dvwa：docker start dvwa。
注意：此处setup check处除reCAPTCHA key选项为红色外，其余选项都要为绿色才算成功搭建。第一次登录需要创建数据库，点击“Create/Reset Database”按钮。
2.设置靶场 接下来我们要进入靶场。登录dvwa，默认的用户名密码是：admin/password。
登录进来之后页面如下图所示：
我们要先去DVWA Security选项后中调节难度，可调节为low、medium、high以及impossible。先将难度改为low，点击Submit按钮。后续会逐步调高难度。
3.寻找目标注入点 调节难度后点击SQL Injection选项，可以看到有个User ID输入框，尝试输入1点击提交。
可以看到，提交后，页面给出回显，提交请求的URL变成了 IP:8080/vulnerabilities/sqli/?id=1&amp;Submit=Submit#，这就是我们的目标注入点。
二、安装sqlmap 安装具体步骤可查看https://blog.csdn.net/Z_David_Z/article/details/113278533
此处使用kali自带的sqlmap。打开shell，输入sqlmap -h即可查看sqlmap指令。
图中标示的-u参数是使用中经常使用的一个参数，其后接目标url，即可进行自动注入。
三、使用sqlmap自动化扫描 （一）low级别难度 1.使用 -u参数进行自动注入 sqlmap -u “目标url”
在使用-u参数的时候遇到了登录验证的问题，系统重定向到了登录页面，所以此时我们要在使用sqlmap的时候加上cookie参数来授权给sqlmap。
2.添加cookie参数 在浏览器登录访问之后，按F12进入开发者工具，选择Network选项，此时该选项下无数据。
刷新页面后，出现文件后单击第一个文件，出现Request Headers后选择Cookie值
右键该值，选择Copy，再粘贴到刚刚的sqlmap命令添加的cookie参数中。
sqlmap -u “目标url” --cookie “站点cookie”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd4126153d78c5f3445f71b6036b7d23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da479e6ba0ebdd8992c3ade15b0b346e/" rel="bookmark">
			【图解数据结构】深入剖析时间复杂度与空间复杂度的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：聆风吟
🔥系列专栏：图解数据结构、算法模板
🔖少年有梦不应止于心动，更要付诸行动。
文章目录 一. ⛳️算法的定义二. ⛳️算法的特性2.1 🔔输入输出2.2 🔔输入输出2.3 🔔有穷性2.4 🔔确定性2.5 🔔可行性 三. ⛳️算法设计要求3.1 🔔正确性3.2 🔔可读性3.2 🔔健壮性3.3 🔔时间效率高和存储量低 四. ⛳️算法效率的度量方法4.1 🔔事后统计方法4.2 🔔事前分析估算方法 五. ⛳️算法的复杂度5.1 🔔算法的复杂度的简单介绍5.2 🔔算法复杂度在面试中考察 六. ⛳️算法的时间复杂度（重点）6.1 🔔算法的时间复杂度定义6.2 🔔大O的渐进表示法6.3 🔔常见的时间复杂度6.4 🔔最好情况、最坏情况与平均情况 七. ⛳️算法的空间复杂度📝全文总结 一. ⛳️算法的定义 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
二. ⛳️算法的特性 算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。
2.1 🔔输入输出 算法具有零个或多个输入，尽管对于大多数算法来说，输入参数都是有必要的，但对于个别情况，如打印"hello world!"这样的代码，不需要任何输入参数，因此算法的输入可以是零个。
2.2 🔔输入输出 算法至少有一个或多个输出，算法是一定需要输出的，不需要输出，你用这个算法干嘛呢？输出的形式可以打印输出，也可以是返回一个或多个值等。
2.3 🔔有穷性 有穷性：是指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤都在可接受的时间内完成。
2.4 🔔确定性 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行的路径，相同的输入只能有唯一的输出结果。算法的每一步骤都被精确定义而无歧义。
2.5 🔔可行性 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。
三. ⛳️算法设计要求 算法不是唯一的。也就是说，解决同一个问题，可以有多种解决问题的算法。通常为了设计一个 “好” 的算法应考虑达到一下目标：
3.1 🔔正确性 正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能够得到问题的正确答案。但是算法的 “ 正确 ” 一词在用法上通常有很大差别，大体分为一下四个层次：
算法程序没有语法错误；算法程序对于合法的输入数据能够产生满足要求的输入结果；算法程序对于非法的输入数据能够得出满足规格说明的结果；算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。 对于这四层含义，层次 1的要求最低，但仅仅没有语法错误实在谈不上是好算法。这就是如同仅仅解决温饱，不算是生活幸福一样。而层次 4是最难实现的，我们几乎不可能逐一验证所有的输入都得到正确的结果。所以一般情况下，我们通常把层次 3作为衡量一个算法算法是否合格的标准。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da479e6ba0ebdd8992c3ade15b0b346e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac11b250e098d0e1d636241fdf3584b0/" rel="bookmark">
			MySQL数据库游标（Cursor）的定义及使用和MySQL流程控制语句详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL游标（Cursor）的定义及使用 在 MySQL 中，存储过程或函数中的查询有时会返回多条记录，而使用简单的 SELECT 语句，没有办法得到第一行、下一行或前十行的数据，这时可以使用游标来逐条读取查询结果集中的记录。游标在部分资料中也被称为光标。
关系数据库管理系统实质是面向集合的，在 MySQL 中并没有一种描述表中单一记录的表达形式，除非使用 WHERE 子句来限制只有一条记录被选中。所以有时我们必须借助于游标来进行单条记录的数据处理。
一般通过游标定位到结果集的某一行进行数据修改。
结果集是符合 SQL 语句的所有记录的集合。
个人理解游标就是一个标识，用来标识数据取到了什么地方，如果你了解编程语言，可以把他理解成数组中的下标。
不像多数 DBMS，MySQL 游标只能用于存储过程和函数。
下面介绍游标的使用，主要包括游标的声明、打开、使用和关闭。
1. 声明游标 MySQL 中使用 DECLARE 关键字来声明游标，并定义相应的 SELECT 语句，根据需要添加 WHERE 和其它子句。其语法的基本形式如下：
DECLARE cursor_name CURSOR FOR select_statement; 其中，cursor_name 表示游标的名称；select_statement 表示 SELECT 语句，可以返回一行或多行数据。
例 1 下面声明一个名为 nameCursor 的游标，代码如下：
mysql&gt; DELIMITER // mysql&gt; CREATE PROCEDURE processnames() -&gt; BEGIN -&gt; DECLARE nameCursor CURSOR -&gt; FOR -&gt; SELECT name FROM tb_student; -&gt; END// Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac11b250e098d0e1d636241fdf3584b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e344d4a951dbd5b2c75525f5748558b4/" rel="bookmark">
			Could not build wheels for llama-cpp-python, which is required to install pyproject.toml-based proj
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装llama-cpp-python包时，出现下述问题：
Collecting llama-cpp-python Using cached llama_cpp_python-0.2.28.tar.gz (9.4 MB) Installing build dependencies ... done Getting requirements to build wheel ... done Installing backend dependencies ... done Preparing metadata (pyproject.toml) ... done Requirement already satisfied: typing-extensions&gt;=4.5.0 in d:\software\anaconda3\lib\site-packages (from llama-cpp-python) (4.8.0) Collecting diskcache&gt;=5.6.1 Using cached diskcache-5.6.3-py3-none-any.whl (45 kB) Requirement already satisfied: numpy&gt;=1.20.0 in d:\software\anaconda3\lib\site-packages (from llama-cpp-python) (1.23.5) Building wheels for collected packages: llama-cpp-python Building wheel for llama-cpp-python (pyproject.toml) ... error error: subprocess-exited-with-error × Building wheel for llama-cpp-python (pyproject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e344d4a951dbd5b2c75525f5748558b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af729659cb3b50c71f99ab911a6397c6/" rel="bookmark">
			Hive导入数据的五种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Hive中建表成功之后，就会在HDFS上创建一个与之对应的文件夹，且文件夹名字就是表名； 文件夹父路径是由参数hive.metastore.warehouse.dir控制，默认值是/user/hive/warehouse； 也可以在建表的时候使用location语句指定任意路径。
不管路径在哪里，只有把数据文件移动到对应的表文件夹下面，Hive才能映射解析成功; 最原始暴力的方式就是使用hadoop fs –put | -mv等方式直接将数据移动到表文件夹下； 但是，Hive官方推荐使用hive命令将数据加载到表中。
本篇文章介绍五种导入数据的方法：Load 加载数据 、Insert插入数据、 As Select加载数据、 Location加载数据、 Import加载数据
一、Load加载数据 Load英文单词的含义为：加载、装载；
所谓加载是指：将数据文件移动到与Hive表对应的位置，移动时是纯复制、移动操作。
纯复制、移动指在数据load加载到表中时，Hive不会对表中的数据内容进行任何转换，任何操作。
LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)] 语法规则 语法规则之filepath filepath表示待移动数据的路径。可以指向文件（在这种情况下，Hive将文件移动到表中），也可以指向目录（在这种情况下，Hive将把该目录中的所有文件移动到表中）。
filepath文件路径支持下面三种形式，要结合LOCAL关键字一起考虑：
相对路径，例如：project/data1
绝对路径，例如：/home/huser/project/data1
具有schema的完整URI，例如：hdfs://localhost:9000/user/hive/project/data1
语法规则之LOCAL 指定LOCAL， 将在本地文件系统中查找文件路径。
若指定相对路径，将相对于用户的当前工作目录进行解释；
用户也可以为本地文件指定完整的URI-例如：file://user/hive/project/data1。
没有指定LOCAL关键字。
如果filepath指向的是一个完整的URI，会直接使用这个URI；
Hive会使用在hadoop配置文件中参数fs.default.name指定的（一般都是HDFS）。
LOCAL本地是哪里？
本地文件系统指的是Hiveserver2服务所在机器的本地Linux文件系统，不是Hive客户端所在的本地文件系统。
语法规则之OVERWRITE 如果使用了OVERWRITE关键字，则目标表（或者分区）中的已经存在的数据会被删除，然后再将filepath指向的文件/目录中的内容添加到表/分区中。
代码示例 二、Insert插入数据 insert+select insert+select表示：将后面查询返回的结果作为内容插入到指定表中，注意OVERWRITE将覆盖已有数据。
需要保证查询结果列的数目和需要插入数据表格的列数目一致。
如果查询出来的数据类型和插入表格对应的列数据类型不一致，将会进行转换，但是不能保证转换一定成功，转换失败的数据将会为NULL。
INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1 FROM from_statement; INSERT INTO TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af729659cb3b50c71f99ab911a6397c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8d7c686a9ae7295dd9fec022f9f1d3/" rel="bookmark">
			Zookeeper使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
ZooKeeper包含一个简单的原语集，提供Java和C的接口。ZooKeeper代码版本中，提供了分布式独享锁、选举、队列的接口，代码在$zookeeper_home\src\recipes。其中分布锁和队列有Java和C两个版本，选举只有Java版本。
ZooKeeper的每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。其应用场景包括统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。
使用场景 ZooKeeper的使用场景非常广泛，主要包括以下几个方面：
配置中心 ：ZooKeeper可以用来存储和管理配置信息，例如集群中的机器配置、服务地址配置等。通过Zookeeper，可以将配置信息统一管理，同时实现动态加载和更新。统一命名服务 ：Zookeeper可以用来实现命名服务，例如将集群中的机器名称和IP地址进行映射，或者将服务的唯一标识和实际地址进行映射。这样，客户端可以通过名称或标识来访问服务，而不需要知道服务的实际地址。分布式锁 ：Zookeeper可以用来实现分布式锁，通过创建一个特殊的节点，各个节点可以竞争同一个锁，从而保证分布式系统中的一致性。分布式队列 ：Zookeeper可以用来实现分布式队列，通过创建一个特殊的节点，各个节点可以加入或离开队列，同时队列中的节点可以按照一定的顺序进行排序。数据发布订阅 ：通过发布者将数据信息存储到ZooKeeper的节点上，订阅者对数据进行订阅，达到动态获取数据的一个效果。集群管理 ：Zookeeper可以用于监测集群中的机器退出和加入、选举master等。 主要特点 Zookeeper是一个开源的分布式协调服务，它主要用于分布式系统中的服务发现、配置管理和分布式同步等。
Zookeeper的优点： 简单易用：Zookeeper提供了简洁的API和数据模型，使得开发人员可以轻松地使用它来协调和管理分布式系统中的服务和节点。高性能：Zookeeper具有高可用性、高性能和低延迟的特点，能够处理大量的请求和数据。稳定可靠：Zookeeper具有稳定可靠的特点，能够在分布式环境中提供一致、可靠的服务。可扩展性：Zookeeper可以轻松地扩展到数千个节点的规模，并且可以保证系统的可扩展性和可靠性。数据一致性：Zookeeper提供了强一致性的数据模型，保证了在分布式系统中的数据一致性。 Zookeeper也有一些缺点： 依赖网络：Zookeeper的性能和可靠性高度依赖于网络通信的质量。如果网络出现故障或延迟，Zookeeper可能会受到影响。不适合存储大量数据：Zookeeper主要是为了协调和管理分布式系统中的配置信息和服务状态而设计的，不适合用于存储大量数据。如果需要存储大量数据，可能需要考虑其他解决方案。不适合实时应用：Zookeeper的响应时间可能会影响到实时应用的性能和稳定性。因此，对于实时性要求高的应用，可能需要寻找其他更适合的解决方案。 工作原理 ZooKeeper的工作原理基于原子广播机制，该机制保证了各个Server之间的同步。这个机制由Zab协议实现，Zab协议有两种模式：恢复模式（选主）和广播模式（同步）。
当服务启动或者在领导者崩溃后，Zab就进入了恢复模式。当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。
ZooKeeper采用了递增的事务id号（zxid）来标识事务，所有的提议（proposal）都在被提出的时候加上了zxid，从而保证了事务的顺序一致性。
架构模式 ZooKeeper的架构模式包括以下几种：
领导者（Leader）模式：在这种模式下，ZooKeeper集群中只有一个领导者节点，负责处理所有的写请求，并将这些请求广播给其他从节点。所有的读请求可以直接从领导者节点或者从节点中获取。分布式（Distributed）模式：在这种模式下，ZooKeeper集群中的每个节点都可以处理读写请求。每个节点都会复制一份数据，并且通过互相监视来保持数据的一致性。集群（Cluster）模式：在这种模式下，ZooKeeper集群中的每个节点都是对等的，每个节点都可以处理读写请求。通过互相监视和同步，来保持数据的一致性。 节点角色划分 ZooKeeper的节点角色划分主要分为三种：领导者（Leader）、跟随者（Follower）和观察者（Observer）。
领导者（Leader）：负责协调集群中的其他节点，处理所有的写请求，并将这些请求广播给其他节点。同时，领导者也负责维护数据的一致性。
跟随者（Follower）：为客户端提供读服务，参与Leader选举过程。
观察者（Observer）：为客户端提供读服务，不参与Leader选举过程。
Leader选举机制 ZooKeeper的Leader选举机制基于Zab协议，该协议有两种模式：恢复模式（选主）和广播模式（同步）。
在初始化集群分布式的时候会进行Leader选举，或者在运行期间Leader出现故障也会进行选举。当ZooKeeper集群中的节点启动时，它们都会默认认为自己是Leader，然后通过投票机制来确定Leader。
投票机制基于(myid, ZXID)来表示，每个节点都会将自己认为的Leader信息（包括myid和ZXID）发送给集群中的其他节点。每个节点都会统计投票信息，判断是否已经有过半的节点接受了相同的投票信息。如果有，那么这个节点就被认为是被选举为Leader。
一旦确定了Leader，每个节点就会更新自己的状态。如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。
数据一致性保证 ZooKeeper通过Zab协议来保证数据一致性。Zab协议是一种原子广播协议，支持崩溃恢复，实现分布式数据一致性。Zab协议包括两种基本的模式：崩溃恢复和消息广播。
在消息广播模式下，Leader节点的写入是一个两步操作，第一步是广播事务操作，第二步是广播提交操作。过半数指的是反馈的节点数 &gt;=N/2+1。如果收到超过半数的Follower的反馈，Leader就会提交事务。
在崩溃恢复模式下，如果发生故障导致Leader节点宕机，会进行新一轮的Leader选举。当与过半的机器同步完成后，就退出恢复模式，然后进入消息广播模式。
ZooKeeper还通过保证数据的一致性来保证数据的安全性。ZooKeeper中的每个节点都有一个唯一的路径，并且每个节点都有一个与之关联的数据。当数据发生变化时，ZooKeeper会保证这个变化对所有节点都是一致的。
此外，ZooKeeper还提供了事务日志来保证数据的持久性和可靠性。事务日志记录了所有对数据的修改操作，如果发生故障导致数据损坏，可以通过事务日志来恢复数据。
ZooKeeper通过Zab协议、保证数据一致性和提供事务日志等方式来保证数据的安全性和可靠性。
数据冗余性保证 ZooKeeper通过数据复制来保证数据冗余性。为了提高数据可靠性和可用性，ZooKeeper将数据放在内存中，并支持数据的复制。每个ZNode（节点）都有一个与之关联的Data攥取句柄，可以获取该节点的数据。同时，ZooKeeper支持对节点的子节点进行监视，当子节点发生变化时，会收到通知。
在数据复制方面，ZooKeeper支持同步和异步两种复制方式。在同步复制方式下，当主节点发生写操作时，需要等待从节点完成写操作后再返回结果，这种方式可以保证数据的一致性，但是可能会影响性能。在异步复制方式下，主节点只需要将写操作结果发送给从节点，不需要等待从节点完成写操作，这种方式可以提高性能，但是可能会牺牲一些数据一致性。
ZooKeeper还支持节点的事务性保证，即每个事务都有一个唯一的事务ID（zxid），并且每个事务在执行过程中都按照严格的顺序执行，从而保证了数据的一致性和操作的原子性。
ZooKeeper通过数据复制、同步和异步复制方式以及事务性保证等方式来保证数据冗余性和可用性。
集群模式中的数据查询与更新机制 ZooKeeper集群中的数据查询与更新机制基于Zab协议，主要包括以下步骤：
数据查询： 当客户端向ZooKeeper集群发送数据查询请求时，该请求首先会被路由到一个领导者节点上。领导者节点会查询自己的内存中的数据，如果数据存在，则直接返回给客户端。如果领导者节点中不存在该数据，则会向其他节点发送查询请求，并将查询结果返回给客户端。 数据更新： 当客户端向ZooKeeper集群发送数据更新请求时，该请求首先会被路由到一个领导者节点上。领导者节点会记录下要更新的数据项以及更新操作，然后将其广播给其他节点。其他节点在收到广播消息后，会执行相应的更新操作，并将更新结果发送给领导者节点。领导者节点在收到所有节点的更新结果后，会进行汇总，然后将汇总结果返回给客户端。 在数据查询与更新过程中，ZooKeeper集群通过领导者选举和数据同步机制来保证数据的一致性和可用性。当领导者节点出现故障时，其他节点会重新选举一个领导者节点，并保证数据的一致性。同时，ZooKeeper集群中的每个节点都会定期与其他节点进行数据同步，以保证数据的实时性和一致性。
CAP理论在Zookeeper中的应用 CAP理论在Zookeeper中的应用主要体现在其数据一致性、可用性和分区容错性方面。
首先，Zookeeper遵循一致性原则（Consistency）。在分布式系统中，Zookeeper保证所有节点在同一时刻具有完全相同的数据备份。这意味着在Zookeeper中，每个节点都可以提供一个一致的数据视图。
其次，Zookeeper在可用性方面（Availability）有所牺牲。Zookeeper不能保证每次服务请求的可用性。例如，在极端环境下，Zookeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。
最后，Zookeeper具有分区容错性（Partition Tolerance）。Zookeeper能够容忍节点之间的网络通信故障，也就是说，即使集群因为网络或者机器故障等原因分成几个区域（分区），Zookeeper集群也能保持其功能性。
根据CAP理论，一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项。由于分区容错性是必须的，因此Zookeeper选择了CP原则，即选择了一致性和分区容错性，而牺牲了可用性。
安装部署 单节点安装部署 Zookeeper单节点安装部署可以按照以下步骤进行：
下载Zookeeper：访问Zookeeper官网，下载对应版本的Zookeeper压缩包。解压缩：将压缩包解压缩到目标目录，例如“/usr/local/zookeeper”。配置文件：进入解压缩后的目录，找到“conf”文件夹，修改“zoo_sample.cfg”文件为“zoo.cfg”，配置Zookeeper的相关参数。启动Zookeeper：在终端中输入“bin/zkServer.sh start”命令，启动Zookeeper服务。创建数据目录和日志目录：进入“/usr/local/zookeeper-3.4.6”目录，创建“data”和“logs”文件夹。创建myid文件：在“data”文件夹下创建一个名为“myid”的文件，并在文件中输入当前机器的IP地址。配置防火墙：如果需要在防火墙中开放Zookeeper的端口，需要配置防火墙规则。测试Zookeeper：通过Zookeeper客户端连接Zookeeper服务，测试是否能够正常连接和使用。 以上是Zookeeper单节点安装部署的基本步骤，按照步骤进行操作即可完成安装部署。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee8d7c686a9ae7295dd9fec022f9f1d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dacfcf0b5549fa97b9a7ea1b8258a295/" rel="bookmark">
			Python之Matplotlib绘图调节清晰度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python之Matplotlib绘图调节清晰度 文章目录 Python之Matplotlib绘图调节清晰度引言解决方案dpi是什么？效果展示总结 引言 使用python中的matplotlib.pyplot绘图的时候，如果将图片显示出来，或者另存为图片，常常会出现清晰度不够的问题，当然这种问题是对于png或者jpg这种格式的图片而言的，如果是生成svg或者pdf则不存在这种问题，但是png和jpg也是经常需要使用的图片格式，因此就需要想办法去解决这个问题。
解决方案 要提高Matplotlib图的清晰度，你可以采取以下几种方法： 调整DPI（每英寸点数）：
使用plt.figure()函数时，可以通过设置dpi参数来调整图的分辨率。增加DPI可以提高图像的清晰度，但文件大小也会增加。 import matplotlib.pyplot as plt plt.figure(dpi=300) # 设置dpi为300，可以根据需要调整 # 在这里添加绘图代码 plt.show() 保存图像时设置DPI：
在保存图像时，可以通过dpi参数来设置图像的分辨率。 import matplotlib.pyplot as plt # 在这里添加绘图代码 plt.savefig('output.png', dpi=300) # 设置dpi为300，可以根据需要调整 使用矢量图格式：
矢量图格式（如SVG、PDF）在不同分辨率下都能保持清晰度。使用plt.savefig()保存图像时，可以选择保存成矢量图。 import matplotlib.pyplot as plt # 在这里添加绘图代码 plt.savefig('output.svg', format='svg') # 保存成SVG格式 然后你可以将SVG文件转换为其他格式，如PNG，以满足特定的需求。
4. 调整图像尺寸：
通过调整图像的尺寸，你可以使图像中的元素更为清晰。在plt.figure()中使用figsize参数设置图像的宽度和高度。
import matplotlib.pyplot as plt plt.figure(figsize=(8, 6)) # 设置宽度和高度，可以根据需要调整 # 在这里添加绘图代码 plt.show() 尝试这些方法中的一个或多个，根据你的需求选择最适合的方式。
dpi是什么？ dpi越大清晰度越高，一般来说，DPI（每英寸点数）越高，图像的清晰度越高。DPI表示在每英寸的空间内有多少个点，因此在相同物理尺寸下，有更多的点可以用于表示图像细节。 当你增加DPI时，图像文件的分辨率也会相应增加，因此在打印或显示时，图像看起来更为清晰。但需要注意的是，增加DPI也会增加图像文件的大小，因为有更多的像素需要存储。
在Matplotlib中，你可以通过设置dpi参数来调整图像的DPI，例如：
import matplotlib.pyplot as plt plt.figure(dpi=300) # 设置dpi为300，可以根据需要调整 # 在这里添加绘图代码 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dacfcf0b5549fa97b9a7ea1b8258a295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddeeb8aa33377599023119a3675a5f67/" rel="bookmark">
			C语言：数据在内存中的存储形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、整数在内存中的存储 关于整数在内存中的存储形式，在博主之前写的文章里已经介绍了！友友们可以去点下面链接去看，这里就不过多介绍。
C语言：进制的转换以及原码、反码、补码
我们以整型在内存中的存储形式为基础，探究后面的内容：整型提升与截断、算数转换、大小端字节序和字节序判断、强制类型转换的原理、浮点数在内存中的存储！！
二、整型提升与截断 C语⾔中，整型算术运算总是⾄少以缺省（缺省就是默认的意思）整型类型的精度来进⾏的。
为了获得这个精度，表达式中的字符和短整型操作数在使⽤之前被转换为普通整型，这种转换称为整型提升。
2.1 整型提升的意义 表达式的整型运算要在CPU的相应运算器件内执⾏，CPU内整型运算器(ALU)的操作数的字节⻓度⼀ 般就是int的字节⻓度，同时也是CPU的通⽤寄存器的⻓度。
因此，即使两个char类型的相加，在CPU执⾏时实际上也要先转换为CPU内整型操作数的标准⻓度。
通⽤CPU（general-purpose CPU）是难以直接实现两个8⽐特字节直接相加运算（虽然机器指令中 可能有这种字节相加指令）。所以，表达式中各种⻓度可能⼩于int⻓度的整型值，都必须先转换为 int或unsigned int，然后才能送⼊CPU去执⾏运算。
也就是说，假设c1和c2是char类型，那么要先将要实现c1+c2,就需要对c1和c1进行整型提升之后进行运算，那么假设我们用char类型的c3去接收c1和c2的结果，由于char类型是一个字节，所以会发生截断。截断之后，只会保留低位的字节存储在c3中！！
2.2 如何进行整体提升呢？ 1. 有符号整数提升是按照变量的数据类型的符号位来提升的
2. ⽆符号整数提升，⾼位补0
2.3 如何进行截断呢？ 当长字节的数据类型用短字节的数据类型进行存储时，会发生截断，截断就是通过简单地将高位丢弃，保存低位来实现
补充一条知识：
C语言规定，char类型默认是否带有正负号，由当前的系统决定，也就是说char类型可能等价于signed char也可能等价于unsigned char，这一点与int不同，int必然等价于signed int，但是在大多数的编译器环境下，包括当前的vs，char等价于signed char！
下面我将通过一道例题来深入解析整型提升和截断的全过程！！！
大家可以看我的注释，写的比较详细！ 我们会发现，当char类型进行运算时，会进行整型提升，而当计算的结果保存在char类型时，会对整型提升后的结果进行截断，只保留低位。
三、算数转换 明白了整型提升与截断，我们考虑到了计算字符和短整型操作数使用前的情况，那如果操作数类型都大于等于4个字节呢？？？
如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转换为另一个操作数的类型，否则操作将无法进行。那么为了判别两个操作数转换的优先级，设置了如下层次体系，该体系杯成为寻常算数转换。
long double double float unsigned long int long int unsigned int int 类型排名较低的操作数应该转换成类型排名高的操作数进行计算
比方说float a+int b，那计算前会先把b转换成float类型运算
如果是float a +double b，那计算前会先把a转换成double类型运算
四、大小端字节序和字节序判断 当我们了解了整数在内存中存储后，我们调试看⼀个细节：
调试的时候，我们可以看到在a中的 0x11223344 这个数字是按照字节为单位，倒着存储的。这是为什么呢？下面就要讲到大小端概念！
4.1 什么是大小端呢？ “大端”和“小端”可以追溯到1726年的Jonathan Swift的《格列佛游记》，其中一篇讲到有两个国家因为吃鸡蛋究竟是先打破较大的一端还是先打破较小的一端而争执不休，甚至爆发了战争。1981年10月，Danny Cohen的文章《论圣战以及对和平的祈祷》（On holy wars and a plea for peace）将这一对词语引入了计算机界。这么看来，所谓大端和小端，也就是big-endian和little-endian，其实是从描述鸡蛋的部位而引申到计算机地址的描述，也可以说，是从一个俚语衍化来的计算机术语。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddeeb8aa33377599023119a3675a5f67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4998cd1eb4441c32b338008d1d860d1/" rel="bookmark">
			人脸清晰化神器codeFormer图形界面包GUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. codeFormer介绍 在NeurIPS 2022上，南洋理工大学-商汤科技联合研究中心S-Lab提出了一种基于VQGAN+Transformer的人脸复原模型CodeFormer，效果是真的强大，先展示下效果，用的官方案例效果图。
官方给出的代码见这里 传送门
2. 图形化界面一体包 由于源码对小白不友好，装环境难题直接阻拦大部分用户，为此我打包好了所需的python环境，做了一个图形GUI包，无需你本地安装python环境也可使用，下载链接放在文末
用法很简单
下载解压后，点击“启动程序.bat”，然后你要处理的是图片还是视频，切换到对应选项卡选择待处理的图片或者视频，以及结果保存位置点击开始处理，程序开始自动运行 如果运行被360拦截，请关闭360。所有源代码均公开可见，在_internal文件夹里可查看，无需担心程序后门
我这个打包版本的功能，除了codeformer本身功能之外，还有以下功能：
1. 对deepfacelab切好的aligned强化，直接写入dfl已有信息，无需重新切脸，强化完可以直接用于训练
2. 关闭了codeformer里默认尺寸放大2倍的功能，改为默认1倍尺寸，保持dfl切好的图不会出现尺寸不匹配问题
3. 把强化aligned人脸图和强化整个图分开到2个标签页，分别对应alinged文件夹强化和merge文件夹强化，方便新手小白理解
3. 效果实测 此处对比3种针对人脸的清晰化算法：codeFormer，GPEN，GFPGAN
使用老婆新垣结衣的图做测试
先测试正面情况：
正面效果上，codeFormer（以下简称CF）效果最好，清晰又清爽，原人物的身份特征保留完好
GPEN其次，清晰，但会增加一种油腻感，会平白增加一些雀斑一样的东西，原人物的身份特征保留完好
GFPGAN最垃圾，人物的身份特征会受影响，都看不出这是新垣结衣了
再测试小侧面情况
小侧面效果，
CF清爽自然，但眼神有变化
GPEN油腻，但眼神有变化
GFPGAN反而效果好一点
再测试大侧面情况
大侧面效果上，CF和GPEN都不太好，眼神跟鬼一样。GFPGAN更烂
codeFormer算法里有个w参数控制追求细节还是忠于原图，对比如下
这个没有好坏之分，看个人喜好了
下载链接 （已更新支持40系显卡）
链接：https://pan.baidu.com/s/1C48Fjanjki4-JupwoyKS6Q?pwd=1c2i 提取码：1c2i 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9067e9e9a928b6d11156768f591c59a9/" rel="bookmark">
			Python超详细基础文件操作（详解版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件操作 1. 文件打开与关闭 1.1 打开文件 在Python中，你可以使用 open() 函数来打开文件。
以下是一个简单的例子：
# 打开文件（默认为只读模式） file_path = 'example.txt' with open(file_path, 'r') as file: # 执行文件操作，例如读取文件内容 file_content = file.read() print(file_content) # 文件在with块结束后会自动关闭，无需显式关闭文件 在上述示例中：
'example.txt' 是文件的路径和名称，你可以根据实际情况修改为你想要打开的文件。
'r' 表示只读模式。如果你想要写入文件，可以使用 'w' 模式，如果想要追加内容，可以使用 'a' 模式等。
with open(...) as file : 是使用上下文管理器的方式，确保文件在使用后被正确关闭，即使在处理文件时发生异常也能保证关闭。
1.2 关闭文件 在 Python 中关闭文件有两种主要的方法：
1.2.1 使用 with 语句
with 语句是一种上下文管理器，当它的代码块执行完毕时，会自动关闭文件。这是推荐的方式，因为它确保文件在使用完毕后被正确关闭，即使发生异常也能保证关闭。
file_path = 'example.txt' with open(file_path, 'r') as file: # 执行文件操作，例如读取文件内容 file_content = file.read() print(file_content) # 文件在这里已经被自动关闭 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9067e9e9a928b6d11156768f591c59a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0639255d2b64fa5da2d0ba914d79408c/" rel="bookmark">
			解决SpringBoot日期序列化问题:[Java 8 date/time type `java.time.LocalDateTime` not supported by default]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题背景 最近项目在通过sql查询数据的时候，报了如下错误：
Caused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Java 8 date/time type `java.time.LocalDateTime` not supported by default: add Module "com.fasterxml.jackson.datatype:jackson-datatype-jsr310" to enable handling (through reference chain: com.ytx.dependency.common.utils.Result["data"]-&gt;com.ytx.ccserverform.modules.data.dto.ViewModelDataVO["list"]-&gt;java.util.ArrayList[0]-&gt;java.util.HashMap["occurrence_time"]) 2、分析过程 异常信息：Java 8 date/time type `java.time.LocalDateTime` not supported by default: add Module "com.fasterxml.jackson.datatype:jackson-datatype-jsr310" 从异常信息中我们解读到 java8 Jackson库在默认情况下不支持LocalDateTime序列化和反序列化。
于是看了数据表的字段，确实有datetime日期类型的字段， java8将 java.time.LocalDateTime 序列化为 JSON 时，就会报以上错误。
3、解决方法 1、配置全局配置（亲测有效）
在Springboot WebMvcConfigurer其全局配置中增加以下配置，代码如下：
@Configuration public class WebJsonConverterConfig implements WebMvcConfigurer { /** * 解决Java8 日期序列化问题 * jackson默认不支持java8 LocalDateTime的序列化和反序列化 * * @param converters */ @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0639255d2b64fa5da2d0ba914d79408c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc074de6b46492664f90c0bd5c27ec63/" rel="bookmark">
			苹果(IOS)开发证书/发布证书申请
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介
准备环境
一、注册开发者账号
二、 进入证书管理
三、申请苹果 App ID
四、生成证书请求文件
五 、申请开发证书
1、申请开发(Development)证书
2、导出 .p12 证书文件
3、添加调试设备
4、申请开发 (Development) 描述文件
六、申请发布证书
1、申请发布(Production)证书
2、导出 .p12 证书文件
3、申请发布 (Distribution) 描述文件
简介 证书主要包含两个部分内容：iOS证书(.p12)和描述文件(.mobileprovision)。
iOS有两种证书和描述文件 证书类型使用场景开发(Development)证书和描述文件用于开发测试，在 HBuilderX 中打包后可在真机环境通过Safari调试发布(Distribution)证书和描述文件用于提交 AppStore，在 HBuilderX 中提交云打包后提交到 AppStore 审核发布 准备环境 必需要有苹果开发者账号，并且加入了 “iOS Developer Program”Mac OS 10.9以上系统（如果已经申请p12证书则不需要） 一、注册开发者账号 苹果开发者官网地址：Sign In - Applehttps://developer.apple.com/account
目前，苹果开发者账号可分为三种类型：个人、公司、企业，且三者的费用以及权限等不尽相同。公司开发者账号与个人开发者账号的费用、是否需要Apple ID以及app能否上传至App Store的权限上是一致的，相对个人开发者账号来说，公司开发者账号的协作人数较多，但需要提供的信息也较多
1.个人账号
① 费用：99 美元/年
②协作人数：仅限开发者自己
③不需要填写公司的邓百氏编码（ D-U-N-S Number）
④支持账号下的 app 上线 App Store
⑤需要创建 Apple ID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc074de6b46492664f90c0bd5c27ec63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84fd5f547117abfdac0abe909e9fac5/" rel="bookmark">
			大数据开发之Hive（详细版，最后有实战训练）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第 1 章：Hive基本概念 1.1 Hive 1.1.1 Hive产生背景 HDFS来存储海量的数据、MapReduce来对海量数据进行分布式并行计算、Yarn来实现资源管理和作业调度。但是面对海量的数据和负责的业务逻辑，开发人员要编写MR对数据进行统计分析难度极大，所以就产生了Hive这个数仓工具。Hive可以帮助开发人员将SQL语句转化为MapReduce在yarn上跑。
1.1.2 hive简介 Hive是基于hadoop的一个数据仓库工具，将结构化的数据文件映射成一张表，并提供类SQL（HQL）查询功能。
1.1.3 Hive本质：将HQL（hiveSQL）转化成MapReduce程序 1、Hive处理的数据存储在HDFS
2、Hive分析数据底层的实现是MapReduce
3、执行程序运行在Yarn上
4、结构化文件如何映射成一张表呢？借助存储在元数据数据库中的元数据来解析结构化文件。
1.2 Hive架构原理 1.2.1 Hive架构介绍 1）用户结构：ClientCLI（command-line interface）、JDBC/ODBC（jdbc访问hive）2）元数据：Metastore元数据包括：表名、表所属的数据库（默认是default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore3) Hadoop使用HDFS进行存储，使用MapReduce进行计算4) 驱动器：Driver解析器（SQL Parser）将SQL字符串转换成抽象语法树AST，这一步一般都用第三方工具库完成，比如antlr；对AST进行语法分析，比如表是否存在、字段是否存在、SQL语义是否有误编译器（Physical Plan）将AST编译生成逻辑执行计划优化器（Query Optimizer）对逻辑执行计划进行优化执行器（Execution）把逻辑执行计划转换成可以运行的物理计划。对于Hive来说，就是MR/Spark 1.2.2 Hive的运行机制 hive通过给用户提供的一系列交互接口，接受到的用户指令（SQL），使用自己Driver，结合元数据（metaStore），将这些指令翻译成MapReduce，提交到Hadoop中执行，最后，将执行返回的结果输出到用户交互接口中。
1.3 Hive和数据库比较 Hivemysql语言类sqlsql语言规模大数据pd及以上数据量小一般在百万左右到达单表极限数据插入能增加insert，不能update，delete能insert，update，delete数据存储Hdfs拥有自己的存储空间计算引擎MapReduce/Spark/tez自己的引擎innodb 第 2 章：Hive安装 2.1 修改hadoop相关参数 1）修改core-site.xml
1、配置该superUser允许通过代理访问的主机节点
2、配置该superUser允许通过代理用户所属组
3、配置该superUser允许通过代理的用户
2）配置yarn-site.xml
1、NodeManager使用内存数，默认是8G，修改成4G内存
2、容器最小内存，默认512M
3、容器最大内存，默认是8G，修改成4G
4、关闭虚拟内存检查（默认开启）
3）分发修改后的配置文件
2.2 Hive解压安装 1）上传压缩包到linux的/opt/softsware目录下
2）将/opt/softsware目录下的压缩包解压到/opt/module目录下
3）将解压后的文件修改成hive
4）修改/etc/profile.d/my_env.sh文件，将hive的/bin目录添加到环境变量
2.3 Hive元数据的三种部署方式 2.3.1 元数据库之Derby 这种方式适用于轻量级或者单机模式的部署，通常用于测试或开发环境。配置相对简单，但不适合高可用性和大规模部署。
1、内嵌模式示意图：
2、Derby数据库：
Derby数据库是Java编写的内存数据库，在内嵌模式中与应用程序共享一个JVM，应用程序负责启动和停止。
3、初始化Derby数据库：
1）在hive根目录下，使用/bin目录下的schematool命令初始化hive自带的Derby元数据库
2）执行上述初始化元数据库时，会发生存在jar包冲突问题
3）解决jar包冲突问题，只需要把hive的/lib目录下的log4j~.jar重命名即可
4、启动Hive
1）执行/bin目录下的hive命令，就可以启动hive，并通过cli方式连接到hive
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84fd5f547117abfdac0abe909e9fac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91585e47baa2bd44b175db938fb049a9/" rel="bookmark">
			Java&#43;Springboot&#43;Mysql个性化电影推荐系统 movielens电影数据集 基于深度学习/机器学习/人工智能 基于协同过滤推荐算法 爬虫 可视化数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java+Springboot+Mysql个性化电影推荐系统 movielens电影数据集 基于深度学习/机器学习/人工智能 基于用户标签/协同过滤推荐算法 爬虫 可视化数据分析MovielensRecommendSys 一、项目简介 1、开发工具和使用技术 IDEA/Eclipse，jdk1.8，mysql5.5/mysql8，navicat数据库管理工具，springboot开发框架，spring+springmvc+mybatis框架，thymeleaf视图渲染模板，html页面，javascript脚本，jquery脚本，bootstrap前端框架，echarts图表组件等。
2、实现功能 前台用户首页地址：http://localhost:8080/
后台管理员首页地址：http://localhost:8080/admin
管理员账号：admin 管理员密码：admin
前台用户包含：注册、登录、注销、喜好标签、浏览电影、搜索电影、信息修改、密码修改、电影评分、电影收藏、电影评论、排行榜、热点推荐、个性化推荐电影等功能；
后台管理员包含：数据分析、用户管理、电影管理、电影类型管理、用户喜好标签管理、评分管理、收藏管理、评论管理、浏览记录管理等。
个性化推荐功能：
游客：热点推荐（根据电影总评分降序推荐）;
登录用户：基于用户的协同过滤推荐算法（根据评分数据），如果没有推荐结果，采用标签推荐（推荐登录用户喜好标签下的总评分较高的电影，同时是登录用户没有评分的）。
人气榜单：查询浏览数量最多的电影，同时不包括当前登录用户浏览过的电影。
相关推荐：
推荐与当前电影相同类型下收藏量较高的电影，同时不包括当前登录用户收藏过的电影。
电影数据来源：
系统采用由grouplens项目组从美国著名电影网站movielens整理的ml-latest-small数据集，该数据集包含了671个用户对9000多部电影的10万条评分数据
ml-latest-small数据集是由grouplens项目组从美国著名电影网站movielens整理的
该数据集包含：
movies.csv文件：9742个电影数据，包括电影id、电影名称、电影类型
links.csv文件：包含了电影id在imdb电影网站与tmdb电影网站的id，即：movieid是当前数据集中的电影的id，imdbid是电影在imdb网站中的id，tmdbid是电影在tmdb网站中的id
ratings.csv文件：包含了671个用户对电影的100836个评分数据
movies_all.csv文件：是爬虫根据电影imdbid从imdb网站爬取的电影的其他信息，包括：
导演、编剧、演员、电影图片、电影时长、语言、区域、简介等
将ml-latest-small数据集保存在数据库中的过程：
1、爬虫读取movies.csv和links.csv文件，并通过电影的imdbid到imdb网站爬取电影数据（包括图片、导演、演员等信息），同时将电影图片下载在电脑中，数据库中只保存电影图片的名称
2、将爬取的数据保存在movies_all.csv文件中
3、解析movies_all.csv，将电影类型数据保存在电影类型表中，将电影数据保存在电影表中，将电影-电影类型关联数据，保存在关联表中
4、解析ratings.csv文件，将用户id保存在用户表中，将评分数据保存在评分表中
5、因为数据集中只有用户id数据，所以用户表中也只有用户id，因此需要添加用户的用户名、密码等信息
6、添加用户标签数据。
3、开发步骤 二、项目展示 三、代码展示及运行结果 专业长期研究java、python推荐算法（基于内容、协同过滤、关联规则、机器学习等）、大数据等，欢迎留言、私信互相交流学习，后续会不断更新，欢迎关注。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6794d8e4094bb7c3713c25590198cf/" rel="bookmark">
			OpenJDK 和 OracleJDK 哪个jdk更好更稳定，正式项目用哪个呢？关注者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenJDK 和 OracleJDK：哪个JDK更好更稳定，正式项目应该使用哪个呢？我会从，从开源性质、更新和支持、功能差异等方面进行比较，如何选择，哪个jdk更好更稳定，正式项目用哪个呢，进行比较回答
本文已收录于，我的技术网站 ddkk.com，有大厂完整面经，工作技术，架构师成长之路，等经验分享
开源性质 1、OpenJDK：
OpenJDK是一个完全开源的Java开发工具包（JDK），由Oracle领导，并得到了广泛的社区支持。
它的源代码可以在公共域中自由访问和修改，这使得开发人员可以根据自己的需求自定义JDK。
最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。这是大佬写的， 七千页的BAT大佬写的刷题笔记，让我offer拿到手软
2、OracleJDK：
OracleJDK是Oracle公司基于OpenJDK源代码开发的官方JDK版本。
它包含一些专有的功能和性能优化，但在某些版本中需要商业许可。
更新和支持 1、OpenJDK：
OpenJDK通常是最先接收到Java最新特性的版本。
社区支持广泛，但Oracle官方的免费公共更新可能不如OracleJDK频繁。
2、OracleJDK：
OracleJDK提供长期支持（LTS）版本，这对于需要长期稳定环境的企业级应用尤其重要。
Oracle为其JDK提供商业支持，包括安全更新和性能优化。
功能差异 虽然OpenJDK和OracleJDK在功能上非常相似，但存在一些差异：
1、性能优化：
OracleJDK可能包含一些专有的性能增强特性。
OpenJDK在社区支持下，也逐渐增加了性能优化和新功能。
2、工具和插件：
OracleJDK提供了一些专有的工具和插件，如JRockit Mission Control等。
OpenJDK可能缺少这些工具，但开源社区提供了许多替代方案。
代码示例与真实案例 为了更好地理解两者的应用，我们可以看一下具体的代码示例：
示例1：Java版本检测 这个示例展示了如何在代码中检测Java的版本，这对于理解你的应用在不同JDK版本上的兼容性很重要。
最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。这是大佬写的， 七千页的BAT大佬写的刷题笔记，让我offer拿到手软
public class JavaVersionCheck { public static void main(String[] args) { // 输出当前Java的版本 System.out.println("Java版本: " + System.getProperty("java.version")); } } 在不同的JDK版本上运行这个程序，你可以看到它们所对应的Java版本。
示例2：使用JMH进行性能基准测试 Java微基准测试套件（JMH）是一个用于代码性能基准测试的工具。它可以帮助你了解不同JDK版本之间的性能差异。
import org.openjdk.jmh.annotations.*; @Benchmark public void myBenchmark() { // 执行一些需要测试性能的代码 } 这个示例需要使用JMH库，并在不同的JDK上运行以比较性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc6794d8e4094bb7c3713c25590198cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5e5208f899cee0f341df237b6cd5ba/" rel="bookmark">
			js(JavaScript)数据结构之树（Tree）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是数据结构？ 下面是维基百科的解释：
数据结构是计算机存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。
我们每天的编码中都会用到数据结构，下面是常见的数据结构：
数组（Array）栈（Stack）队列（Queue）链表（Linked List）散列表（Hash）字典树（Tree）图（Graph）堆（Heap） 树（Tree） 树（Tree）是一种常见的数据结构，由节点（Node）和边（Edge）组成。树的节点通过边连接，形成层次结构。树的一个节点可以有多个子节点，但只有一个父节点（除了根节点）。树的一个重要特点是没有环，即任意两个节点之间都有唯一的路径。
在树结构中，有一种特殊的树叫做二叉树。二叉树中，每个节点最多有两个子节点，一个是左节点，一个是右节点。这种设计的好处是我们可以通过限制每个节点的子节点个数为2，编写出高效的程序来进行插入、查找和删除数据操作。
二叉查找树（BST）是二叉树的一种，它有一个很聪明的性质：相对较小的值保存在左节点中，而较大的值保存在右节点中。这个性质使得在BST中进行查找操作非常高效，因为我们可以根据数值的大小迅速确定搜索方向。
举个例子，想象一个BST表示数字。根节点是一个中等大小的数字，比如50。如果我们要找的数字是30，由于30比50小，我们知道它应该在左节点。然后，如果我们要找的是60，因为60比50大，我们知道它应该在右节点。这样，我们可以在树中快速定位目标。
BST不仅适用于数值，还可以用于存储其他类型的数据，比如单词和字符串。这种树结构在计算机科学中被广泛应用，为数据的快速检索和操作提供了便利。
以下是一个使用 JavaScript 实现树的案例，演示了如何创建一个树、添加节点、遍历节点以及查找节点的功能：
HTML 代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JavaScript实现树的案例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick="addRoot()"&gt;添加根节点&lt;/button&gt; &lt;button onclick="addChild()"&gt;添加子节点&lt;/button&gt; &lt;button onclick="traversePreorder()"&gt;先序遍历树&lt;/button&gt; &lt;button onclick="traverseInorder()"&gt;中序遍历树&lt;/button&gt; &lt;button onclick="traversePostorder()"&gt;后序遍历树&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;label for="findInput"&gt;查找节点: &lt;/label&gt; &lt;input type="text" id="findInput" placeholder="请输入"&gt; &lt;button onclick="findNode()"&gt;查找节点&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;label for="result"&gt;结果: &lt;/label&gt; &lt;span id="result"&gt;&lt;/span&gt; &lt;script src="tree.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JavaScript 代码：
// 定义树节点类 function TreeNode(value) { this.value = value; this.children = []; // 子节点数组 } // 定义树类 function Tree() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d5e5208f899cee0f341df237b6cd5ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86af26c756a1de6b0a2cb96d828ea6a4/" rel="bookmark">
			数据仓库（2）-认识数仓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据仓库是什么 数据仓库 ，由数据仓库之父比尔·恩门（Bill Inmon）于1990年提出，主要功能仍是将组织透过资讯系统之联机事务处理(OLTP)经年累月所累积的大量资料，透过数据仓库理论所特有的资料储存架构，做有系统的分析整理，以利各种分析方法如联机分析处理(OLAP)、数据挖掘(Data Mining)之进行，并进而支持如决策支持系统(DSS)、主管资讯系统(EIS)之创建，帮助决策者能快速有效的自大量资料中，分析出有价值的资讯，以利决策拟定及快速回应外在环境变动，帮助建构商业智能(BI)。
下图是本文后续要介绍的认识数据仓库的相关内容。
2、大数据相关岗位 大数据相关岗位包括数据仓库，数据平台，数据分析，数据产品。各自职能不同，本文重点介绍数据仓库相关。
2.1数据仓库技术分组 数据仓库作为大数据相关技术栈之一，相关岗位和工作内容可见如下：数据仓库按照技术能力划分，分为离线开发组，实时开发组，数据治理组，数据安全组。
离线开发组
实时开发组
数据治理组
数据安全组
3、数据仓库在大数据生态中的定位 数据仓库在大数据生态中定位：承接各种数据源，**通过采（对数据源数据采集）、建（数据资产/模型建设）、管（数据管理、数据服务）、用（如何利用数据为下游创造更多应用价值分析）**的方式实现下游需求内容为数据分析、运营、风控等业务提供数据支撑.
4、数据仓库变化历史 数据仓库演变可以分为3个时代，从2000-2013是1.0时代，从2013到现在是2.0时代（仍有很多公司使用），从2016到现在也是3.0时代。
1.0时代
2.0时代
3.0时代
5、数据仓库建设版图 6、数据仓库组件及架构 组件，如下图
架构-Lambda架构
架构-Kappa架构
图1中的1.2和1.7内容，本文不做介绍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096bac57dd311408644076485c709285/" rel="bookmark">
			【深度学习实验】图像处理（一）：Python Imaging Library（PIL）库：图像读取、写入、复制、粘贴、几何变换、图像增强、图像滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、实验介绍二、实验环境1. 配置虚拟环境2. 库版本介绍 三、实验内容0. 安装 PIL 库1. 图像读取和写入a. 图像读取b. 图像写入c. 构建新图像 2. 图像复制粘贴a. 图像复制b. 图像局部复制c. 图像粘贴 3. 几何变换a. 图像调整大小b. 图像旋转c. 图像翻转 4. 图像增强a. 图像亮度增强b. 图像颜色增强c. 图像对比度增强d. 图像锐度增强 5. 图像滤波a. 图像滤波 - 浮雕b. 图像滤波 - 轮廓 ​
一、实验介绍 图像处理在深度学习领域中起到了至关重要的作用，Python Imaging Library（PIL）作为一种主流的图像处理库，为图像的读取、处理和增强提供了丰富的功能。
本实验将介绍 PIL 的基本用法，主要包括图像读取、写入、复制、粘贴、几何变换以及图像增强、图像滤波等方面。
Pillow v2.4.0 (PIL fork)
二、实验环境 本系列实验使用了PyTorch深度学习框架，相关操作如下：
1. 配置虚拟环境 conda create -n DL python=3.7 conda activate DL pip install torch==1.8.1+cu102 torchvision==0.9.1+cu102 torchaudio==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html conda install matplotlib conda install scikit-learn 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096bac57dd311408644076485c709285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975ca3a70455352098eaae480915ed77/" rel="bookmark">
			大数据深度学习卷积神经网络CNN：CNN结构、训练与优化一文全解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 大数据深度学习卷积神经网络CNN：CNN结构、训练与优化一文全解一、引言1.1 背景和重要性1.2 卷积神经网络概述 二、卷积神经网络层介绍2.1 卷积操作卷积核与特征映射卷积核大小多通道卷积 步长与填充步长填充 空洞卷积（Dilated Convolution）分组卷积（Grouped Convolution） 2.2 激活函数ReLU激活函数优势与劣势 Leaky ReLUSigmoid激活函数优势与劣势 Tanh激活函数优势与劣势 Swish激活函数其他激活函数激活函数的选择 2.3 池化层最大池化（Max Pooling）优势与劣势 平均池化（Average Pooling）优势与劣势 全局平均池化（Global Average Pooling）池化窗口大小和步长池化的替代方案池化层的选择 2.4 归一化层批量归一化（Batch Normalization）优势与劣势 层归一化（Layer Normalization）实例归一化（Instance Normalization）组归一化（Group Normalization）归一化层的选择 三、训练与优化3.1 训练集准备与增强数据预处理数据增强常见增强技巧 训练集分割 3.2 损失函数回归任务分类任务优化损失函数 3.3 优化器随机梯度下降（SGD）自适应优化器优化器选择注意事项 3.4 学习率调整固定学习率学习率调度预定调整自适应调整 学习率预热 3.5 正则化技巧L1和L2正则化DropoutBatch Normalization数据增强 3.6 模型评估与调优交叉验证调参技巧早停技巧模型集成 4. 总结 大数据深度学习卷积神经网络CNN：CNN结构、训练与优化一文全解 本文全面探讨了卷积神经网络CNN，深入分析了背景和重要性、定义与层次介绍、训练与优化，详细分析了其卷积层、激活函数、池化层、归一化层，最后列出其训练与优化的多项关键技术：训练集准备与增强、损失函数、优化器、学习率调整、正则化技巧与模型评估调优。
一、引言 卷积神经网络（Convolutional Neural Networks, CNN）的复杂性和灵活性使其成为深度学习领域的核心研究主题之一。在本引言部分中，我们将深入探讨CNN的历史背景、基本原理、重要性以及其在科学和工业领域的影响。
1.1 背景和重要性 卷积神经网络的灵感源自人类视觉系统，特别是视觉皮层中的神经元结构。自Hubel和Wiesel在1962年的开创性工作以来，这一理念已经引发了一系列研究和发展。
早期发展: 由Yann LeCun等人在上世纪80年代末到90年代初开发的LeNet-5被视为第一个成功的卷积神经网络。LeNet-5在手写数字识别方面取得了令人印象深刻的结果。现代崛起: 随着硬件的快速进展和大数据的涌现，CNN在21世纪初开始重新崛起，并在各个领域实现了突破性进展。 CNN的重要性不仅体现在其精度和效率上，而且还体现在其理论洞见上。例如，卷积层通过共享权重减少了参数数量，这有助于更有效地训练模型，还增强了模型对平移不变性的理解。
1.2 卷积神经网络概述 卷积神经网络是一种前馈神经网络，它的人工神经元可以响应周围单元的局部区域，从而能够识别视觉空间的部分结构特征。以下是卷积神经网络的关键组成部分：
卷积层: 通过卷积操作检测图像的局部特征。激活函数: 引入非线性，增加模型的表达能力。池化层: 减少特征维度，增加模型的鲁棒性。全连接层: 在处理空间特征后，全连接层用于进行分类或回归。 卷积神经网络的这些组件协同工作，使得CNN能够从原始像素中自动学习有意义的特征层次结构。随着深度增加，这些特征从基本形状和纹理逐渐抽象为复杂的对象和场景表现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/975ca3a70455352098eaae480915ed77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40d7086009bef58e6822afe8b5d13e2/" rel="bookmark">
			android studio——设计简单微信界面超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、作业目标 本次作业开发的是微信APP的门户框架，UI布局为上中下结构。
功能一：用户可通过点击底部导航栏切换四个板块进行切换，它们分别是“聊天”、“联系人”、“功能”、“我的”，每切换一个界面会有对应的文本提示。
功能二：在每一tab页面实现列表效果。
（功能二的实现在功能一的前提下改进，详情可直接移步第四点的第3点）
二、设计流程 1、外观设计 微信页面整体为上-中-下结构
上部：显示栏背景为黑色，内有白色“微信”字样
中部：纯文本“这是××界面”和几行列表
下部：四个.png文件的图标以及对应板块的名字
2、内部联系 I.用一个main.xml文件将三个部分联系起来，使得三个部分可以在同一个页面进行展示
II.写一个Mainactivity.java文件来实现点击切换的功能：
（1）创建四个Fragment类及其对应的四个tab.xml文件,通过Fragmentxx类绑定板块对应的布局文件,将其联系起来;再用一个myadapter类将所有的单个文本Item.xml联系起来。
（2）在MainActivity类中创建Fragmentxx对象，通过Transaction将Fragmentxx对象添加到主布局中间的空板块，创建FragmentManager管理Fragment。
（3）初始化方法
（4）写监听方法
（5）设置控件被点击后的响应事件
（6）展示页面的方法
四、技术说明及关键代码（含详细步骤） 在这之前先了解一下各方面功能：
android:id="@+id/top"，为组件设置资源id，top为命名，在java文件中通过findViewById(id)被找到。
android:layout_width=“wrap_content”，布局的宽度
android:layout_height=“wrap_content”，布局的高度
android:layout_weight=“1”，用来等比例地划分区域。
android:gravity=“center”,对齐方式。
android:text=“微信”,显示的文本。
android:textColor="@color/white"，设置文字的颜色。
android:textSize=“28dp” /&gt;，设置文字的大小。
1.实现外观设计 I.上部 找到res下的layout文件夹，并在该文件夹下右键—&gt;new—&gt;XML—&gt;Layout XML File创建一个weixin.xml文件；点击下图右上角的Design，将TextView拖一个到LinearLayout下面，再点击code查看代码，进行修改 点击code显示的代码即为weixin.xml的代码:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/textView3" android:layout_width="match_parent" android:layout_height="67dp" android:layout_weight="24" android:background="@color/black" android:gravity="center" android:shadowColor="@color/white" android:text="微信" android:textColor="@color/white" android:textSize="28dp" /&gt; &lt;/LinearLayout&gt; II.中部 在layout下继续右键创建一个tab1.xml文件，点击code查看代码，修改文本为“这是聊天界面”，并调整大小。
这时候，由于共有四个界面，所以你可以选择：
（1） 将tab1.xml直接复制，粘贴到layout下，改名为tab2.xml，tab3.xml，tab4.xml（记得把文本和code里面 android:id="@+id/textView8" 这一句TextView后的数字改成不同值）；
（2）重复三次创建tab1.xml的操作。
这里只展示tab1.xml的代码：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40d7086009bef58e6822afe8b5d13e2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/530/">«</a>
	<span class="pagination__item pagination__item--current">531/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/532/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>