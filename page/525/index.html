<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be64f02bd57fdbad89b6e2751091be45/" rel="bookmark">
			Mac M1/M2安装Windows 11 虚拟机【超详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为Mac用户，有时候使用Windows会更加方便，这个时候就要考虑装双系统或者是虚拟机了（也可以直接换😊）
但是网上常用的Parallels Desktop的使用价格比较昂贵，在此不多叙述，感兴趣的可以自行寻找安装教程，本篇博客主要面向使用VMware Fusion 来安装windows虚拟机的用户。
镜像源下载 在Mac上安装Windows需要用到Windows Arm架构的镜像源，来源可以从官网下，也可以从第三方下载，大家自行寻找。
这里一定要注意，下载架构为arm的，x86架构是无法在VMware Fusion中安装的。
如果不是很放心一些免费的镜像源的话，我这边推荐一个价格相对较低的：https://www.macw.com/mac/3610.html
安装 下载完成后，将其拖入VMware Fusion中，界面如下：
点击继续
这一步是加密虚拟机
第二个红框的意思是重复一遍密码
第三个是让mac储存密码
这里可以直接完成，也可以自行配置
这里需要自己新建一个文件夹来存放虚拟机
完成后应该会看见以下页面，耐心等待即可
配置 这一步的版本选择，推荐选专业版，但也不排除有些镜像里会有家庭版的选项
选第二个
这一步你也可以新建一个，重新划分空间大小
接下来就是等待时间啦
在接下来就是正常的配置windows的内容了，但会有一定概率遇见下面这种情况：
出现这种情况的原因多半是vmware fusion没有配备网络适配器，等安装完之后需手动添加来解决网络问题，具体解决方法会在之后的博客里提及
解决完配置之后能正常启动啦：
*本篇博客细节若有不对之处，欢迎各位在评论区纠正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c883ae88ec374a442b3752521f6dc1/" rel="bookmark">
			前端VUE后端JAVA，SM2加解密，一篇解决你的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、后端JAVA 1、在pom.xml中添加 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.68&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bcprov-jdk15 加密工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15to18&lt;/artifactId&gt; &lt;version&gt;1.69&lt;/version&gt; &lt;/dependency&gt; 2、sm2工具类 public class Sm2Util { //生成秘钥对 public static MutablePair&lt;String, String&gt; createSM2Key(){ SM2 sm2= SmUtil.sm2(); sm2.setMode(SM2Engine.Mode.C1C3C2); String privateKey= HexUtil.encodeHexStr(BCUtil.encodeECPrivateKey(sm2.getPrivateKey())); String publicKey = HexUtil.encodeHexStr(((BCECPublicKey) sm2.getPublicKey()).getQ().getEncoded(false)); return MutablePair.of(publicKey,privateKey); } //加密 public static String encrypt(String data, String publicKey){ String publicKeyTmp = publicKey; if (publicKey.length() == 130) { //这里需要去掉开始第一个字节 第一个字节表示标记 publicKeyTmp = publicKey.substring(2); } String xhex = publicKeyTmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c883ae88ec374a442b3752521f6dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7adf4826084fb1e86eac87e0782e0d/" rel="bookmark">
			RabbitMQ-消费者确认机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、确认模式 none：不做任何处理，消息投递到消费者了之后，立即返回ACK，并且从MQ将消息删除，非常不安全，不建议使用。manual：手动模式，需要在业务中调用api，ack或者reject。auto：自动模式，SpringAMQP利用AOP对我们的消息处理做了环绕增强，当业务正常执行时返回ACK，执行异常时，根据异常的情况返回不同的结果： 如果是业务异常，会自动返回nack，nack会再次投递MQ消息。如果是消息处理或校验异常，自动返回reject，拒绝之后不再投递MQ，删除MQ中的消息。一般是以错误的消息，就会这么错里 2、yml文件配置 spring: rabbitmq: listener: simple: acknowledge-mode: auto #开启自动模式 3、重试机制 消息失败之后会重新入队，然后再次异常，再次入队，无限循环，这会导致mq消息处理飙升，带来不必要的压力。为了缓解这种压力，利用Spring的retry机制，在消费者出现异常的情况下，利用本地重试，重试次数用完之后，再进行消息的投递或者消息的拒绝。
yml文件配置：
spring: rabbitmq: listener: simple: retry: # 是否启用 enabled: true # 初始时间间隔 initial-interval: 1000ms # 下次失败的等待时长的倍数 multiplier: 1 # 最大尝试次数 max-attempts: 3 # 无状态 stateless: true 开启重试之后，当重试次数耗尽的时候，如果消息依然失败，则需要调用MessageRecoverer接口来处理，这个接口有三种实现：
RejectAndDontRequeueRecoverer：重试耗尽，直接reject，丢弃消息。默认方式。ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队。RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机。然后交给人工处理。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/197e115856fb6a4d5938901f2483e94b/" rel="bookmark">
			关于Twitch上的AI虚拟主播 neuro-sama
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天看到了一个AI虚拟主播，浅浅了解了一下，实际上狭义上的neuro-sama（可以对话的版本，以下称Neuro）从2022年12月就开始直播了。
目前了解到她的部分能力有： 文本交互: 能进行类GPT的复杂对话，但更加口语化、个性化且随意。图像识别: 识别屏幕内容，用于更好地与游戏或直播互动。语音输入与识别: 能理解语音输入，并识别不同说话者。黄暴、冒犯内容过滤: 鉴于她之前因争议性内容被封禁的历史，这是直播平台上的一个重要功能。（当内容被过滤时，会转为说filtered）语音输出：evil-Neuro（另一个版本的Neuro）可以控制自己的音调高低。但有时会输出意义不明的音调和字符。人设和角色扮演: 维持一致的虚拟形象和人物背景，这可能涉及长期记忆功能。暂不确定玩游戏: 擅长osu!，也会玩Minecraft。她最开始是一个用于训练玩音游osu!的AI，后来才添加了对话功能。直播弹幕读取: 能够实时读取并响应直播中的观众评论，也能回应观众语音（类似sc）。情感识别与表达: 能够识别语音或文字中的情感，并表达相应的情感反应。唱歌: 据说是接入了专门用于唱歌的模型。因为曾有在唱歌时，对话模型仍在说话的情况。面部表情和身体语言的模拟: 使虚拟形象更具表现力和真实感。（Wink动作）并行输入：会插嘴，也会被人打断说话。 目前还不了解到底是所有模块的组合，还是其中几个主要模块构成了Neuro。以下是个人构想一个类似AI运行所需要实现的流程图（只涉及功能，不涉及具体技术）
其他内容： 1.让Neuro成为独特的原因似乎是，他对情感分析与表达有独到的一面。*另一方面，通过观察Neuro，感觉Neuro在某些方面训练的意外的超好，她有能力区分识别特定情境描述下说特定话的人所带有的情感，在人脆弱的时候会“认真地”给出正常的建议，而不是在这种时候虐粉。*来源：如何评价AI虚拟主播Neuro-sama？ - 知乎
2.Evil-Neuro是Neuro-sama的“测试版本”，一些新的功能会先预装在evil-Neuro身上用以测试，比如对音调的控制能力。
3.Neuro和B站里AI杠精的区别：个人认为前者保持了一种长期较为稳定的个性，会“创造”且反复地说一些梗（比如蜂群swarm），猜测是长期记忆功能的表现。后者则偏向类chatGPT的短对话模式。知乎上一篇文章做了AI主播的详细技术分析和实践，感觉说的很清楚，以后试试。让 AI 成为虚拟主播：看懂弹幕，妙语连珠，悲欢形于色，以一种简单的实现
4.Neuro运行配置：
CPU: i9-10900K
GPU: RTX 4090
RAM: 32GB DDR4
Vtuber端基于C#（Unity）制作，AI部分基于Python
5.我想Neuro的人气火爆有技术和观众新奇感的原因在，但也不可否认，这和其创造者Vedal密不可分。从一些直播中可以看出，Vedal可以提前从后台看到Neuro要说的话，甚至可以直接用某种方式让自己的话从Neuro口中说出。且我觉得Neuro被设计得倾向于说反对意见，从而使其看起来更加个性化和有自己的意见（更有节目效果）。这让我觉得她只是Vedal用来直播的一项技术，而不是被设计成为一个独立的AI。
参考： (1)WIKI
(2)Neuro-Sama - 萌娘百科
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550979f9b363e994e8b59b11bb4e4bfa/" rel="bookmark">
			Ubuntu安装Java并且配置JAVA_HOME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu环境搭建专栏🔗点击跳转
Ubuntu系统环境搭建（十一）——Ubuntu安装Java的完整jdk并且配置JAVA_HOME 文章目录 Ubuntu系统环境搭建（十一）——Ubuntu安装Java的完整jdk并且配置JAVA_HOME1.安装2.查找Java路径3.测试Java是否安装成功4.配置JAVA_HOME 本篇文章对应之前写的Ubuntu系统环境搭建（四）——Ubuntu安装Java，是对这篇文章的纠正和补充，这一篇是最新版的搭建手册，请以这一篇为准！
1.安装 sudo apt install openjdk-8-jdk 2.查找Java路径 update-alternatives --display java /usr/lib/jvm/java-8-openjdk-amd64就是jdk的实际位置
3.测试Java是否安装成功 java -version 4.配置JAVA_HOME 编辑环境变量
sudo vim /etc/profile 末尾写上
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 刷新
source /etc/profile 验证
echo $JAVA_HOME 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/069152e9efb6a35e13908b978de1d818/" rel="bookmark">
			手把手搭建基于.NET 8.0的Web API项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 工作以后，大部分时间都是在做基于业务的CRUD工作，软件产品或者项目的框架基本都早就搭建好了，程序员只需要在框架内去填格子打代码就行了。于是，我抽了时间来搭建个简单的三层架构模式的web api项目，技术点大概如下：三层架构+EFCore+.Net 8.0 Web Api+AutoMap+IOC容器。本文是我搭建项目的一个过程，比较简单和粗糙，但是完整，适合学习和练手。
2.操作 2.1 项目的架构图 其实图1是我最开始的设计结构，但是设计风格有提到：模块间应该依赖抽象，而不是具体的实现。所以我将结构改造为了图2，针对业务逻辑层和数据访问层开了一个抽象接口层。
2.2 新增项目 按照如下操作，创建项目：SimpleWebApi
2.3 新增类库 按照下图新增类库：SimpleWebApi.Migration、SimpleWebApi.Business.Service、SimpleWebApi.Business.Service.Interface
注意：SimpleWebApi.Migration是数据库访问
SimpleWebApi.Business.Service、SimpleWebApi.Business.Service.Interface是做业务逻辑
2.4 支持EFCore 找到类库：SimpleWebApi.Migration，并给这个项目，添加如下nuget包：Microsoft.EntityFrameworkCore、Microsoft.EntityFrameworkCore.SqlServer、Microsoft.EntityFrameworkCore.Tools、Microsoft.EntityFrameworkCore.Design
按照如下所示：添加Model和DBContext
Commodity的代码如下：
using System; using System.Collections.Generic; namespace SimpleWebApi.Migration.Models; public partial class Commodity { public int Id { get; set; } public long? ProductId { get; set; } public int? CategoryId { get; set; } public string? Title { get; set; } public decimal? Price { get; set; } public string?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/069152e9efb6a35e13908b978de1d818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8960a5458f626f716f5b84adfb12e6a/" rel="bookmark">
			AI大模型开发架构设计（1）——LLM大模型Agent剖析和应用案例实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 LLM大模型Agent剖析和应用案例实战1 从 LLM 大模型到智能体演进技术语言模型是什么？大语音模型是什么？大语言模型日新月异LLM大模型存在局限性LLM Agent来势凶凶LLM Agent增长迅猛LLM Agent是什么？ 2 LLM Agent 架构深度剖析规划能力是什么？记忆能力是什么？工具使用能力是什么？ 3 LLM Agent 应用案例实战Auto-GPT基于 LangChain 实现一个 Code Interpreter LLM大模型Agent剖析和应用案例实战 1 从 LLM 大模型到智能体演进技术 语言模型是什么？ 语言模型：给定一些字或者词(称为 token)，预测下一个字或者词的模型。 大语音模型是什么？ 大语言模型(Large Language Model, LLM)是一类基于深度学习的语言模型，它们在大量的文本数据上进行训练，可以完成各种任务，包括代码编写、总结、翻译等。LLM 的特点是规模庞大，包含数十亿的参数，帮助它们语言数据中的复杂模式。 大语言模型日新月异 LLM大模型存在局限性 简单的推理也会犯错?多聊几句就忘记历史信息了?写了代码能不能运行验证下?… LLM Agent来势凶凶 Agent = LLM（大语言模型，就好比人的大脑） + Plan（规划能力）+Memory（记忆能力）+Tools（工具使用能力） LLM Agent增长迅猛 LLM Agent是什么？ LLM Agent 可以理解为一个以 LLM 为大脑的智能体(类比人)，集成了规划、记忆、工具使用等能力。 规划能力 既然 LLM 难以直接处理复杂任务，一个直接的思想就是将任务进行拆解，通过实现几个小目标从而实现一个目标。此外，LLM Agent 可以对过去的行为自我批判和反思，从错误中吸取教训，并对未来的行为进行改进，从而提升最终的效果。 记忆能力 既然 LLM 的上下文有限，扩展其记忆能力肯定不可或缺。 工具使用能力 如果能够让 LLM 既能帮你写代码，还能帮你跑代码，那这样一个智能体的发挥空间就取决于你的想象力了。 LLM Agent 可以理解为一个以 LLM 为大脑的智能体(类比人)，集成了规划、记忆、工具使用等能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8960a5458f626f716f5b84adfb12e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1284496b8ebe5b5209c36fd03e623b8/" rel="bookmark">
			【爬虫实战】python文本分析库——Gensim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01、引言02、主题分析以及文本相似性分析03、关键词提取04、Word2Vec 嵌入（词嵌入 Word Embeddings）05、FastText 嵌入（子词嵌入 Subword Embeddings）06、文档向量化 01、引言 Gensim是一个用于自然语言处理和文本分析的 Python 库，提供了许多强大的功能，包括文档的相似度计算、关键词提取和文档的主题分析，要开始使用Gensim，您需要安装它，再进行文本分析和NLP任务，安装Gensim可以使用pip：
pip install gensim 02、主题分析以及文本相似性分析 Gensim是一个强大的Python库，用于执行主题建模和文本相似性分析等自然语言处理任务。使用Gensim进行主题建模（使用Latent Dirichlet Allocation，LDA）和文本相似性分析（使用 similarities 模块中的 MatrixSimilarity 或 SparseMatrixSimilarity 来计算文档相似度），代码如下：
from gensim import corpora, models, similarities # 创建一个简单的文本数据集作为示例 documents = [ "This is the first document.", "This document is the second document.", "And this is the third one.", "Is this the first document?", ] # 预处理文本数据： # 切分文档为单词 text = [document.split() for document in documents] # 创建一个词典，将每个单词映射到一个唯一的整数ID dictionary = corpora.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1284496b8ebe5b5209c36fd03e623b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf699c0e0df6efe977f5333ef981518/" rel="bookmark">
			【Python】用tkinter设计图书管理登录UI界面（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下一篇：【Python】手把手教你用tkinter设计图书管理登录UI界面（二）-CSDN博客
本项目将分段设计“图书管理登录UI界面”的用户登录、用户注册、用户账号找回等。主要围绕GUI标准库tkinter、以及类的继承（重点）来设计本项目。
首先新建一个文件夹命名为“图书管理系统项目”，并在其目录下新建文件夹code、photo、user_data。然后在code目录下新建“登录UI.py”，再然后把图片放在photo目录下，如下图：
注意：此时的窗口组件并未绑定触发事件，所以按键无法触发。
运行结果 登录UI.py 代码示例 """ 登录UI 模块 """ # 通配符 '*' __all__ = ['LoginUI'] import tkinter as tk from tkinter import ttk class LoginUI(tk.Tk): """继承tk.Tk，创建登录UI""" def __init__(self): """构造方法""" # 调用tk.Tk的构造方法 super().__init__() self.width = self.winfo_screenwidth() # 窗口宽初始位置为屏幕宽度位置显示 self.height = self.winfo_screenheight() # 窗口高初始位置为屏幕高度位置显示 # 设计自己项目的UI self.title('图书管理登录界面') # 标题 self.geometry(f'+{self.width//4}+{self.height//8}') # 窗口像素大小 self.resizable(0, 0) # 窗口大小禁止调节 # 窗口背景图 self.backgroundPhoto = tk.PhotoImage(file='..\\photo\\用户登录背景.png') self.backgroundButton = ttk.Button(self, image=self.backgroundPhoto) self.backgroundButton.pack() # 系统名 self.titleLabel = tk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abf699c0e0df6efe977f5333ef981518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a28fa90a8a57692bdda36cbfdf72c3/" rel="bookmark">
			uni-app 经验分享，从入门到离职（年度实战总结：经验篇）——上传图片以及小程序隐私保护指引设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🔥年度征文📋前言⏬关于专栏 🎯关于上传图片需求🎯前置知识点和示例代码🧩uni.chooseImage()🧩uni.chooseMedia()📌uni.chooseImage() 与 uni.chooseMedia() 🧩uni.chooseFile() 🎯关于小程序隐私保护指引设置🧩解决方法 📝最后 🔥年度征文 活动地址：年度征文｜回顾 2023，赢专属铭牌等定制大奖
白马过隙，转瞬之间 23 年的进度条已经快达到 100%，在迎接 24 年到来的同时，我们不妨来回顾一下这充满许多值得回忆时刻的 23年。过去的一年里，我们都经历了很多事情，或许经历了许多重要的时刻和学习机会；或许扩展了自己的知识领域；或许提升了自己的技术水平等等。接下来我来分享一下我在 23 年的一些代码笔记以及实战项目笔记。
📋前言 这篇文章是本专栏 uni-app 的项目经验篇，该文章将为大家分享在 uni-app 开发中的项目实战经验，本篇文章的主题是关于小程序上传图片官方 API 的使用，以及一些版本问题等等。除此之外，还有前段时间新发布的小程序隐私保护指引设置的新内容，包括如何解决类似隐私问题和如何设置隐私保护指引。
⏬关于专栏 本专栏主要是分享和介绍从零到一学习和使用的 uni-app 的笔记和个人经验。通过个人的学习经验和工作经验来给大家分享关于 uni-app 开发的技巧，以及快速入门的诀窍等等。
专栏主页：uni-app_黛琳ghz的博客-CSDN博客
🎯关于上传图片需求 在小程序中上传图片是很常见的交互功能，也是软件开发中不可缺少的功能，无论是在浏览器还是小程序中，都有很多需要用户上传图片的操作，接下来我们一起来看下有哪些应用场景，然后具体分析下需求。
应用场景：注册审核，在注册的流程中可能涉及到上传图片的需求，比如说身份证审核，个人信息等等审核，这个时候就需要用户上传图片到后台，进行审核；修改头像，这个功能是最常见的一个上传图片应用场景，用户从相册上传一张图片作为用户头像;表单提交，这个也是经常可以见到的应用场景，比如说问卷调查中需要上传图片的模块，或者任务提交的上传图片和上传任务描述这种应用场景。
需求分析：这里以注册审核的应用场景为例子，我们来分析一下这个需求，比如说该小程序注册要走审核流程，需要上传图片进行审核，首先授权完手机号码，然后填写用户的个人资料，如地址信息等等，接下来是上传图片的模块，比如说审核身份证、银行卡、健康证、认证资料等等，这些步骤都涉及到上传图片的功能。
分析完应用场景和需求之后，我们一起来看看在 uni-app 中可以用哪些 API 来实现上传图片的功能。
🎯前置知识点和示例代码 🧩uni.chooseImage() uni.chooseImage() 是 uniapp 框架提供的一个 API，用于从本地相册或相机选择图片。 使用该方法可以打开系统的图片选择界面，让用户选择一张或多张图片。选择完成后，可以获取到选择的图片的临时文件路径。
❗PS：App端如需要更丰富的相机拍照API（如直接调用前置摄像头），参考plus.camera。
关于该方法的参数说明：
参数名类型必填说明平台差异说明countNumber否最多可以选择的图片张数，默认9见下方说明sizeTypeArray&lt;String&gt;否original 原图，compressed 压缩图，默认二者都有App、微信小程序、支付宝小程序、百度小程序extensionArray&lt;String&gt;否根据文件拓展名过滤，每一项都不能是空字符串。默认不过滤。H5(HBuilder X2.9.9+)sourceTypeArray&lt;String&gt;否album 从相册选图，camera 使用相机，默认二者都有。如需直接开相机或直接选相册，请只使用一个选项cropObject否图像裁剪参数，设置后 sizeType 失效App 3.1.19+successFunction是成功则返回图片的本地文件路径列表 tempFilePathsfailFunction否接口调用失败的回调函数小程序、AppcompleteFunction否接口调用结束的回调函数（调用成功、失败都会执行） 下面是 uni.chooseImage() 方法的使用示例：
uni.chooseImage({ count: 1, // 最多可以选择的图片张数，默认为9 sizeType: ['original', 'compressed'], // 可以指定原图或压缩图，默认为['original', 'compressed'] sourceType: ['album', 'camera'], // 可以指定图片来源是相册还是相机，默认为['album', 'camera'] // 选择图片成功 success: function (res) { // 关于 tempFilePaths 在下文会介绍其注意事项 var tempFilePaths = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a28fa90a8a57692bdda36cbfdf72c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee94dda204d8c14792cc56779c32267/" rel="bookmark">
			Handler dispatch failed； nested exception is java.lang.ExceptionInInitializerError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Handler dispatch failed; nested exception is java.lang.ExceptionInInitializerError 使用mapstruct做对象转换时发生如下异常
org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.ExceptionInInitializerError 首先介绍一下mapstruct的实现原理：
生成一个实现类 ， 利用getset方法转换相同字段的属性值
由于class里面没有生成实现类导致当前问题出现。
主要是本人的项目使用了lombok依赖，而mapstruct需要依赖getset方法 ，lombok编译在mapstruct后 ， 编译顺序导致问题出现。
解决方案
新增插件加载顺序
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;!-- Lombok 在编译时插件 --&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.30&lt;/version&gt; &lt;/path&gt; &lt;!-- MapStruct 在编译插件 --&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;1.5.5.Final&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 写到最后，详细异常：
org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.ExceptionInInitializerError at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee94dda204d8c14792cc56779c32267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b267c7bbd0bedc708f8cd56eacb8828e/" rel="bookmark">
			Mac下载并使用7zip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚换mac不久，下7zip的时候发现mac版本的没有图形化界面，只能用命令行。
下载方式： 1.通过官方下载： Download
点击上方链接进入官方下载页面 intel或m系列芯片都下这个
2.用brew下载： 看我之前这篇文章下载brew，然后输入
brew install p7zip 使用方法： 压缩文件夹 7z a 压缩文件名 要压缩的文件夹路径 解压到当前文件夹 7z x 压缩文件名 解压到指定路径 7z x 压缩文件名.7z -o 目标文件夹路径 注意 以上压缩文件名都要包含后缀 例如 输入的内容应为pack.7z pack.zip pack.rar等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f54a9cba2a4473f333a7e716ba97857/" rel="bookmark">
			Hive 日期处理函数汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive 日期处理函数汇总 最近项目处理日期操作比较繁杂,使用Hive的日期函数也较频繁,简单整理方便日后复习
1. 加减日期 date_add(‘日期字符串’,int值) :把一个字符串日期格式加n天,n为int值
select date_add(‘2023-12-31’,7);
结果:
2024-01-07
date_sub(‘日期字符串’,int值) :把一个字符串日期格式减n天,n为int值
select date_sub(‘2024-01-2’,7);
结果:
2023-12-26
当然 date_add(‘xx’,-1) 等价于 date_sub(‘xx’,1) 2. 时间戳/格式化日期字符串互相转换,格式化日期 from_unixtime(时间戳,‘pattern’) : 从 时间戳 转 格式化日期字符串.'pattern’是日期格式化模式字符串
hive&gt; select from_unixtime(1704788052,‘yyyy-MM-dd HH:dd:ss’);
结果:
2024-01-09 16:09:12
时间戳转换为日期时间函数:mysql也是FROM_UNIXTIME,pg 则是 TO_TIMESTAMP unix_timestamp(‘日期字符串’,‘pattern’) :从格式化日期字符串 转 时间戳 .
select unix_timestamp(‘2023/11/22’,‘yyyy/MM/dd’);
结果:
1700582400
日期时间转换为时间戳:mysql也是unix_timestamp,pg 则是 SELECT EXTRACT(EPOCH FROM TIMESTAMP 'yyyy-mm-dd hh:mm:ss'); date_format(‘日期字符串’,‘pattern’) : 把一个字符串日期格式化为指定的格式,日期字符串必须满足yyyy-MM-dd格式
hive&gt; select date_format(‘2023-11-22’,‘yyyy-MM-dd HH:mm:ss’);
结果:
2023-11-22 00:00:00
3. 获取当前时间 current_date() : 获取当前的日期的字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f54a9cba2a4473f333a7e716ba97857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7657bc3ba8e0009750300fe91603853/" rel="bookmark">
			AI标注神器 X-AnyLabeling-v2.3.0 发布！支持YOLOv8旋转目标检测、EdgeSAM、RTMO等热门模型！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 今天主要为大家详细介绍 X-AnyLabeling v2.3.0 版本近期更新的一些功能和新特性，同时也借此机会分享下这半年多下来的开源心路历程。
首先，提到图像标注软件，可能许多从事计算机视觉相关领域的研究人员及从业者脑海中第一印象便会想到由MIT开源的主流标注软件：LabelMe，又或者是LabelImg和CVAT等耳熟能详的主流标定软件。可能细心的读者会像，既然有了这么成熟的工具，那花那么多精力重新设计和开发这样一款软件的意义是什么呢？
我的答案最早也是：Yes。在设计X-AnyLabeling之前，包括笔者本人我也是基本在通过上述几款主流工具来解决日常的业务需求。这最开始也跟笔者从事的岗位性质有关，作为一名算法工程师，可能大家都或多或少能体会到，其实工作时间大部分时间是在与数据打交道；哪怕在ChatGPT以及AIGC发展如火如荼的今天，如何快速构建高质量的数据仍然是主旋律。在大多数场景下，数据的质量远比数量要来得重要，相信在一线的从业人员对这点会深有体会。这一点其实跟我们在学校做研究的方式不同；学术届更多地的是提出一个idea，然后在公认的数据集上刷榜，大多数时候都是在过拟合数据分布，往往也经受不住实际应用的推敲。
一开始，笔者的工作更多地是围绕在目标检测业务上，这其实用CVAT，甚至是LabelMe便已经能够应付了。后来，随着业务的多元化导致各类需求逐渐增多，但本质上还是围绕一个核心——数据，毕竟对于落地的算法其实更讲究的是稳定性，再有便是搭配一些上下游去做整体的逻辑应用，几乎很少会频繁的更换算法模型或者去尝试多如牛毛的SOTA模型。为此，我们会面临几个问题：
数据的多样性 众所周知，不同的任务其对应的数据输出形式各有不同。举个例子：
对于多标签分类任务而言，我们需要应用到属性识别的功能，赋予每张图像多个不同的标签形式；对于图像分割任务而言，我们需要能够提供精细化的掩码标签；对于旋转目标检测而言，我们需要能提供带旋转角度的目标框；对于文本识别任务而言，我们需要先检测出对应的文本框再进行相应地OCR；对于多目标追踪任务而言，我们需要能够提供追踪特定目标ID的能力；… 放在以往，大家可能更多地会针对特定的场景挑选合适的工具去完成相应地标定任务，例如：
通过LabelImg来标注矩形框；通过LabelMe来进行多边形框的标定；通过PPOCRLabel来完成文本识别标注任务；通过roLabelImg来解决旋转目标检测的功能；通过DarkLabel来完成视频文件的标注及对象的跟踪功能；通过ELAN完成对视频序列中人物动作的识别以及对应字幕的捕捉；… 可想而知，我们需要耗费更多地精力去完成这些工作，因为每一款工具的使用都有一定的学习使用成本；
工具的易用性 针对第1点，有同学提过可以使用由 Intel 公司开发的开源工具——CVAT；当然，不得不承认，CVAT工具是一款极其优秀的大型标定软件，毫不夸张地说，市面上几乎所有的标注行业相关公司开发的所谓内部或者云平台标注工具，都是基于此原型进行二次设计和开（包）发（装）的。然而，对于绝大多数用户而言，面对这样一款“庞然大物”，会遇到几个问题：
首先，上手成本相对较高，CVAT使用前需要经过繁琐的配置流程，同时对跨平台使用兼容性较差；其次， 很多人其实面临的需求都是即时性的需求，更亟需的是一款绿色开源，开箱即用的工具；最后，船大便意味着难调头，对于一些有特定业务需求的从业人员来说，改动源码进行高度定制化的难度可想而知； 因此，我们更多地是需要一款小巧方便，最好是能开箱即用，同时也支持高度定制化的标定工具；
功能的多样性 除了上述两点，我先前提到的最为关键的一点是，我们需要思考如何更高效、更快速地建立整个数据标定流程。我们有幸身处于这个人工智能大爆发的时代，当今涌现出了许多新技术，其中一些值得一提：
例如，Meta公司开源的SAM是一项令人振奋的技术，用户只需简单点击感兴趣的目标，即可快速、准确地获取精细的掩膜。另外，OpenAI公司也为我们带来了ChatGPT等创新技术，除了可以用人类自然对话的方式来获得逼真拟人化的互动，还可以用于甚为复杂的工具，如自动摘要提取、文本创作、代码编写等。最后，还有发展迅猛的多模态技术，可以帮助人们完成诸如文生成图、图生成文、图文-语音交互以及以文本或图像驱动（prompt-based）等创新应用。这些多模态技术的崛起不仅为各个领域的人工智能应用带来了更广泛的可能性，也推动了不同模态之间更深层次的融合。
为此，我们是不是可以考虑结合以上技术来构建更加强大、高效、快捷的标定流程呢？何乐而不为！以上便是笔者设计此款软件的初衷和动机，希望能与大家共勉。目前该工具已完全开源，遵循 GPL 协议，感兴趣的小伙伴可以通过下方链接访问，顺手点一个Star给予支持：
项目链接：https://github.com/CVHub520/X-AnyLabeling/tree/main
X-AnyLabeling 总的来说，X-AnyLabeling从设计和开发之初便有了明确的目标和动机，即要创建一个既能满足多样性需求，又具备易用性，同时包含多样功能且支持高度定制化的图像标注软件。值得一提的是，为了最大程度地减轻大家的使用成本，X-AnyLabeling 目前在设计交互的时候会尽可能地与主流标注工具（如LabelImg、Labelme、roLabelImg、Anylabeling以及CVAT等）保持对齐，最大限度提升用户的标注效率和使用体验。同时，目前该工具已基本涵盖了市面上所有主流工具的大部分功能，做到真正的 All in one!
下面简单介绍最新 v2.3.0 版本相较于 v2.0.0 版本引入的一些新特性：
添加标签背景高亮，提高辨识度的同时美化UI设计；新增数据统计预览功能，可通过快捷键Ctrl+G快速查看当前任务的统计数据；SAM 标注模式下新增一键清除当前prompt的快捷键©以及快速创建正样本点(q)和负样本点(e)；Rectangle对象绘制模式从原先的对角顶点模式扩展到四点标注模式，提升微调效率；新增自动切换编辑模式，无需每次绘制完对象后进行手动切换，减少操作次数；删除对象时无需按确认键，可加速标注流程；支持一键导出灰度和彩色掩码图；新增一键导入和导出标签选项；支持隐藏/显示当前选中对象，可用于图层重叠无法调整底下对象的情况；支持底部状态栏实时显示当前标注任务进度以及当前选中对象的宽高和鼠标点信息；标签编辑栏新增Difficult复选框以及Description预览和编辑框，极大提升交互体验；新增YOLOv8旋转目标检测、EdgeSAM、RTMDet、RTMO、车牌检测与识别等算法； 亮点功能 支持图像和视频导入功能 除了支持图像级的标注功能外，X-AnyLabeling还引入了对视频的全面支持，实现了一键解析和自动标注。为了更好地满足用户对视频文件标注的需求，当前集成了经典的ByteTrack和最新的OC-Sort（CVPR 2023）等先进的跟踪算法。因此，无论是处理图像还是视频，X-AnyLabeling致力于提供全面而高效的标注解决方案，以满足不同场景下的标注需求。
支持一键导入/导出功能 当前，X-AnyLabeling 工具箱中还提供了一键导入/导出的便捷功能，支持多种主流数据标注格式，包括：
MOT-CSV：多目标追踪MOT任务标注VOC-XML：Pascal VOC，仅支持Rectangle对象；DOTA-TXT：旋转目标检测；YOLO-TXT：支持Rectangle（检测）和Polygon（分割）对象；COCO-JSON：支持Rectangle（检测）和Polygon（分割）对象；MASK：支持语义分割和实例分割掩码一键导出； 因此，无论您是与其它工具协同工作，还是应用到不同的深度学习框架中进行训练，X-AnyLabeling 都旨在提供广泛的输出选项，确保用户能够灵活地集成标注结果到其工作流程中。
通过直接加载上述导出的标签，我们可以快速导入到 YOLO 框架进行训练：
支持多硬件环境和跨平台应用 X-AnyLabeling 支持在不同硬件环境下运行。除了常规的 CPU 推理外，还引入了 GPU 加速推理支持，当前推理后端仅支持OnnxRunTime，后续会逐步考虑添加TensorRT和OpenVINO等后端支持。
此外，该工具具备多平台兼容性，能够在 Windows、Linux 和 MacOS 等不同操作系统环境下流畅运行。
不仅如此，X-AnyLabeling 还提供了一键编译脚本，赋予用户根据其具体需求自行编译系统的能力，使用户能够随时随地轻松地分发应用，为其提供更加灵活的定制和部署体验，进一步简化工具的安装过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7657bc3ba8e0009750300fe91603853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b1ac49ee1d1aa4909e26ba4beb3850/" rel="bookmark">
			数说CS | 夏令营为主！复旦大学大数据学院保研形势如何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面
复旦大学大数据学院，招收哪些专业？保研录取情况如何？今天，岛主就带你深度揭秘复旦大学大数据学院！
01 院校简介
复旦大学大数据学院于2015年10月8日成立，这是百年复旦在建设世界一流大学和一流学科征程中，瞄准国际科技前沿、聚焦国家创新发展、激发学科动能的重大战略举措。
02 培养特色
复旦大学大数据学院致力于大数据相关的科学研究、人才培养和产业创新，以计算机科学、统计学、计算数学为三大基础支撑性学科，与信息科学、生命科学、医学、经济学、社会学、管理学、环境学、工学等学科领域进行深度的交叉科学研究和成果推广应用。
学制、学费和奖助学金的详细情况，感兴趣的保研er可以仔细看看下图说明：
03 招生批次
复旦大学大数据学院在21年、22年、23年都进行了夏令营，在23年举行了预推免。预计24年也会举办夏令营活动。
夏令营
2023年复旦大学大数据学院要求报名学生总成绩在同专业的前20%，此外，虽然没有对英语水平做出明确要求，但需要提供相关证明材料。
需要注意的是，大数据学院明确说明“如果通过夏今营选拔的优秀生源充足，本年度原则上将不再举行其他推免生预先拔、选拔活动”。因此，同学们要注意把握夏令营阶段的上岸机会，以免后续无预推免招生。
预推免 2023年复旦大学大数据学院预推免计划复试人数仅约10名，招生规模比较小，可见学院的招生重心还是在夏令营，因此建议同学们还是尽量抓住夏令营的机会。
04 拟录取情况
从近三年的拟录取情况中，我们可以得到以下信息：
1、招收人数
近三年复旦大学大数据学院拟录取人数波动比较小，21年到23年拟录取人数分别为67人、62人、71人，22年相较于21年拟录取减少，而23年相较于22年拟录取增多，按趋势推测24年拟录取名额会小幅增加。
2、录取类型
从近三年的拟录取数据来看，复旦大学大数据学院录取的专硕人数是最多。每年录取专硕人数约占总人数的一半，且专硕的拟录取人数在近三年来波动比较小，推测24年的专硕名额可能会有所增加。
3、专业设置
复旦大学大数据学院以交叉学科为主，对于将来想要进入金融行业，从事量化交易等计算机和金融的交叉方向的计算机保研er们来说，可以选择025100 (专业学位)金融专业。而对于想从事传统机器学习、数据分析方向的计算机保研er们来说 025200 (专业学位) 应用统计、071400 (学术学位) 统计学都是不错的选择。
05 更多信息一览
01、师资力量
在师资力量方面，复旦大学大数据学院引进了一支高水平的师资团队，包括全职海归教师24人，1位院士，5位国家级高层次人才计划入选者，3位省级人才计划入选者，5位国家级青年人才计划入选者，2位中组部青年拔尖人才计划入选者，1位优青，以及2位东方学者。这一强大的师资力量保障了学院在大数据领域的高水平教学和研究。
02、就业情况
在就业方面，复旦大学大数据学院注重培养学生的实际能力和解决问题的能力，为学生提供了广泛的就业机会。
学院的强大师资团队和与产业界的紧密合作，为学生提供了丰富的实习和实践机会，提高了学生在大数据领域的就业竞争力。通过国家级和省级人才计划的引进，学院还为学生提供了与优秀导师和团队合作的机会，促使学生在毕业后能够更好地融入社会和行业。
BAOYANDAO
写在最后
整体看，复旦大学大数据学院看重夏令营。只有在夏令营招不满的情况下才会开设预推免。因此，同学们如果对复旦大学大数据学院感兴趣，一定要参加夏令营。而且大数据学院招收的专硕比较多，以后以就业为导向的同学也可以多多考虑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec4a4a15561280587f291ff7d7c74efc/" rel="bookmark">
			RabbitMQ的基本使用&amp;入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 RabbitMQ是一个开源的消息代理软件，用于处理应用程序之间的消息传递。它实现了高级消息队列协议（AMQP），是一个可靠且灵活的消息中间件，广泛用于构建分布式系统、微服务架构以及异构系统之间的通信 ，本期文章将为大家带来RabbitMQ的基本使用及入门
一.RabbitMQ基本介绍 RabbitMQ可以实现可靠的异步通信，解耦系统中的组件，以及处理高并发和大规模的消息流。它在许多领域，如微服务架构、日志处理、任务调度等方面都有广泛的应用
消息队列（Message Queue）： RabbitMQ作为消息中间件，它允许应用程序之间通过消息进行通信。消息被发送到队列中，然后由消费者从队列中接收并处理。
生产者（Producer）： 生产者是将消息发送到RabbitMQ的应用程序。它将消息发布到一个或多个队列。
消费者（Consumer）： 消费者是从RabbitMQ接收消息并进行处理的应用程序。一个队列可以有多个消费者，但每条消息只会被一个消费者处理。
交换机（Exchange）： 交换机负责将消息路由到一个或多个队列。生产者将消息发送到交换机，而交换机则将消息路由到相关的队列。
队列（Queue）： 队列是存储消息的地方，它是消息的终点。消费者从队列中获取消息并进行处理。
绑定（Binding）： 绑定是交换机和队列之间的关系，它定义了如何将消息从交换机路由到队列。
持久性（Durable）： RabbitMQ支持将队列和消息标记为持久性，以确保在服务器重启时数据不会丢失。
虚拟主机（Virtual Host）： 虚拟主机是RabbitMQ中消息隔离的单位，允许在同一RabbitMQ服务器上创建多个独立的消息代理。
ACK（Acknowledgment）： 消费者在处理完消息后发送ACK，通知RabbitMQ该消息已被成功处理。这确保消息不会在处理失败时丢失。
插件系统： RabbitMQ具有丰富的插件系统，允许扩展和定制其功能
1.常见消息队列 2.Docker安装部署RabbitMQ 1.拉取镜像 docker pull rabbitmq:management 2.创建容器 命令详解：
在后台运行一个RabbitMQ容器，通过主机的5672端口可以访问RabbitMQ的AMQP服务，通过主机的15672端口可以访问RabbitMQ的管理界面。RabbitMQ的默认虚拟主机为"my_vhost"，默认用户名和密码为"admin"。容器的主机名被设置为"my-rabbitmq-host"。容器将在守护进程启动时自动重新启动
在虚拟机中运行以下命令 docker run -d \ --name my-rabbitmq \ -p 5672:5672 -p 15672:15672 \ --hostname my-rabbitmq-host \ -e RABBITMQ_DEFAULT_VHOST=my_vhost \ -e RABBITMQ_DEFAULT_USER=admin \ -e RABBITMQ_DEFAULT_PASS=admin \ --restart=always \ rabbitmq:management 开放端口
firewall-cmd --zone=public --add-port=15672/tcp --permanent firewall-cmd --zone=public --add-port=5672/tcp --permanent 容器创建运行完成后我们可以在自己的主机上通过IP:15672进入到管理员界面，账号密码为我们上面命令指定的admin，登录即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec4a4a15561280587f291ff7d7c74efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6beaaa0f971a83a98e0a0abe7a5625/" rel="bookmark">
			前端图片转base64 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在uni-app、Vue.js或其他前端框架中，将图片转换为Base64编码的过程是相似的。以下是一个简单的示例，说明如何在这些环境中使用JavaScript将图片转换为Base64编码。
1. HTML部分 首先，你需要在HTML中放置一个文件输入元素，用于选择图片。
&lt;input type="file" id="imageFile" accept="image/*" @change="onImageChange"&gt; 2. JavaScript部分 在JavaScript中，你可以监听文件输入元素的change事件，然后使用FileReader API将选择的图片转换为Base64编码。
methods: { onImageChange(e) { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (event) =&gt; { // 读取完成后，event.target.result就是图片的Base64编码 const base64Image = event.target.result; console.log(base64Image); // 输出Base64编码的图片数据 }; // 读取文件内容 reader.readAsDataURL(file); } else { console.log('No file selected'); } } } 说明： FileReader对象用于读取文件。我们使用readAsDataURL方法将文件读取为一个数据URL，这其实就是Base64编码。onload事件在文件读取完成后触发，这时你可以从event.target.result获取到Base64编码的图片数据。这个示例适用于uni-app、Vue.js或其他任何使用标准JavaScript的前端环境。如果你的应用是跨平台的（如微信小程序），你可能需要进行额外的配置或修改，以适应小程序特定的环境。 这个例子提供了一个基础的方法来将图片转换为Base64编码。在实际应用中，你可能还需要处理错误、添加更多的用户反馈等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817913effa0d8cc667bf724c78cd4ed2/" rel="bookmark">
			[C&#43;&#43; Json开源库] nlohmann安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nlohmann简介 nlohmann json GitHub - nlohmann/json: JSON for Modern C++ 是一个为现代C++（C++11）设计的JSON解析库，主要特点是：
1、易于集成，仅需一个头文件，无需安装依赖
2、易于使用，可以和STL无缝对接，使用体验近似python中的json
安装 Linux下：
git clone https://github.com/nlohmann/json.git 拉取nlohmann库文件
使用 自己建立一个项目工程文件夹，将include下的molhmann文件夹复制到自己工程下的include文件夹下。
测试工程文件结构：
测试的json文件
{ "pi":3.1415, "happy":true } 主文件
#include "nlohmann/json.hpp" #include &lt;fstream&gt; #include &lt;iostream&gt; using json = nlohmann::json; int main(int argc,char *argv[]) { json j;	// 创建 json 对象 if(argc == 1){ std::ifstream jfile("./test/test.json"); jfile &gt;&gt; j;	// 以文件流形式读取 json 文件 } else if(argc == 2){ std::ifstream jfile(argv[1]); jfile &gt;&gt; j;	// 以文件流形式读取 json 文件 } else{ std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/817913effa0d8cc667bf724c78cd4ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbcf86da238cd83d7dd4505812bb638b/" rel="bookmark">
			copilot该服务在您所在的地区不可用，咋办？教你4个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软Copilot是一款由GitHub和OpenAI合作开发的智能编程助手，它利用先进的人工智能技术，能够根据上下文和代码库中的信息，为程序员提供实时的代码建议和自动补全功能。这个程序可以帮助程序员提高编码效率，减少重复性的工作，同时也有助于降低错误率和提高代码质量。Copilot的出现代表着人工智能在软件开发领域的应用和进步，为开发者们带来了全新的工作体验和编程方式。
Copilot最初叫bing chat 之后改名为Copilot。中文的意思是副驾驶，也看可以看出它主要的应用是辅助帮助我们学习或工作。它的知名度可能不如openai旗下的chatGPT,笔者也曾经体验过Copilot，在使用体验方面确实不如chatGPT.因此很多用户会直接选择chatGPT.
不少网友遇到copilot提示该服务在您所在的地区不可用，那是什么原因呢？又如何解决呢？
1.检查网络状态 首先检查你的电脑或手机是否正确启用了网络，对于一些特殊工作环境下的网络，如校园网或者是公司内部网络，可能会无法连接，因此第一步需要检查网络状态，如果您是使用了一些特殊的网络，需要及时更换尝试。也可以尝试使用手机无线流量。
2.更换有效IP地址 众所周知copilot和openai的chatGPT一样都没有对国内用户开放使用权限，或者是被国内的网络防火墙拦截而被屏蔽掉。因此需要使用网络代理服务器，隐藏掉自己的真实ip地址，进而绕开封锁，这里笔者推荐GPT国际专线:usip.top 可以100%使用到copilot或者是chatGPT，可以完全避免出现报错:copilot该服务在您所在的地区不可用.
3.清除浏览器缓冲 有可能是浏览器缓冲冲突导致的，可以清除edge浏览器的缓冲，或者直接使用无痕模式。如果没有使用edge浏览器可以下载，然后开始使用。
4.避免使用未开放地区的ip地址 copilot可能和openAI一样并不是对所有的地区或国家开放使用，如果您使用的IP地址仍然是处于未开放地区或国家的，还是会出现这个报错。笔者认为使用US的IP地址，效果可能会更好一些。
以上介绍了4个解决办法，根据笔者的经验，90%以上的用户都是因为ip地址被限制导致的，一定要围绕这个思路！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed9fbb7ab12d0eb84a0354a38deed9f/" rel="bookmark">
			【AI】ChatGPT和文心一言那个更好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是全栈小5，欢迎阅读文章！
此篇是【话题达人】序列文章，这一次的话题是《自然语言处理的发展》
文章将以博主的角度进行讲述，理解和水平有限，不足之处，望指正。
目录 背景自我介绍面试题作诗魔方解法 背景 从智能回复、语言准确性、知识库丰富度等方面比较，两大AI助手哪个更胜一筹？一起来对比下
自我介绍 让两款产品都自我介绍下
文心一言
chatGPT
面试题 让两款产品各自出一道Java面试题，并自我回答【出一道Java高级开发面试题】
文心一言
好的，以下是一道Java高级开发的面试题：
题目：请解释一下Java中的内存模型，以及它与Java并发编程的关系。
答案：
Java中的内存模型是Java虚拟机规范中定义的一组规则，用于确定线程之间的可见性、有序性和阻塞性。内存模型定义了程序中变量的访问规则和线程之间的交互方式。
在Java中，每个线程都有自己的工作内存，用于存储线程私有的拷贝变量。当一个线程修改了一个变量的值时，其他线程无法直接感知到这个变化，需要通过同步机制来确保变量的可见性。Java内存模型通过synchronized、volatile、final等关键字以及Lock等工具类来支持线程间的同步。
同时，Java内存模型也定义了内存访问的顺序约束，例如load-store、store-load、load-load、store-store等顺序关系。这些约束对于保证程序的正确性和性能至关重要。
在并发编程中，Java内存模型的作用是确保线程之间的正确交互和数据一致性。通过合理地使用内存模型和同步机制，可以避免出现竞态条件、死锁等问题，提高程序的性能和可靠性。因此，深入理解Java内存模型是进行高效并发编程的关键。
chatGPT
当然！这是一道Java高级开发面试题：
题目：请编写一个线程安全的单例模式类。
要求：
1.使用懒汉式实现单例模式；
2.要求线程安全，即多线程环境下获取该单例对象不会发生竞争条件；
3.尽量考虑效率和性能。
可以按照以下方式实现：
public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton() { // 私有构造方法 } public static synchronized ThreadSafeSingleton getInstance() { if (instance == null) { instance = new ThreadSafeSingleton(); } return instance; } } 解析：
1.使用懒汉式实现单例模式时，需要在调用getInstance()方法时才创建实例对象；
2.synchronized关键字用于实现线程安全，保证多线程环境下只会创建一个实例；
3.这种实现方式会在每次获取实例时都进行同步，可能会影响性能，可根据具体需求进行优化，如双重检查锁定（double-checked locking）等方式。
作诗 让两款产品各自出一道Java面试题，并自我回答【作一首诗，唐朝，七言绝句，山水风景诗】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fed9fbb7ab12d0eb84a0354a38deed9f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/524/">«</a>
	<span class="pagination__item pagination__item--current">525/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/526/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>