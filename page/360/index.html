<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90a285a4bac0cafe68517af6233a838/" rel="bookmark">
			cx_Oracle Python 库连接 Oracle 数据库时遇到报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误 DPI-1047: Cannot locate a 64-bit Oracle Client library: "The specified module could not be found" 是在尝试使用 cx_Oracle Python 库连接 Oracle 数据库时遇到的。这个错误表明 cx_Oracle 无法找到 Oracle 客户端库（通常称为 Instant Client）。
要解决这个问题，请按照以下步骤操作：
下载 Oracle Instant Client：
前往 Oracle 官方网站下载适合你操作系统（Windows、Linux、macOS）和 Python 版本的 64 位 Oracle Instant Client。确保下载的是 64 位的版本，因为你遇到了 DPI-1047 错误。
设置 Oracle Instant Client 环境变量：
在 Windows 上，你可能需要将 Instant Client 目录添加到 PATH 环境变量中。在 Linux 或 macOS 上，你可能需要设置 LD_LIBRARY_PATH（对于 Linux）或 DYLD_LIBRARY_PATH（对于 macOS）。
对于 Windows，假设你的 Instant Client 安装在 C:\oracle\instantclient_19_3，你可以在系统属性 -&gt; 高级 -&gt; 环境变量 中添加一个新的系统变量，名称为 PATH，值为 ;C:\oracle\instantclient_19_3（注意分号 ; 是用来分隔已有路径和新路径的）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90a285a4bac0cafe68517af6233a838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a158a4f4227a08c80462ce58cfcaa68e/" rel="bookmark">
			【MySQL探索之旅】数据库设计以及聚合查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📚博客主页：爱敲代码的小杨.
✨专栏：《Java SE语法》 | 《数据结构与算法》 | 《C生万物》 |《MySQL探索之旅》 |《Web世界探险家》
❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️
🙏小杨水平有限，欢迎各位大佬指点，相互学习进步！
小杨近些在学习人工智能方面的知识,发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
文章目录 1. 数据库设计1.1 数据库设计基本概念1.2 数据库设计的步骤1.3 表设计1.3.1 一对一1.3.2 一对多1.3.3 多对多 2. 聚合查询2.1 聚合函数2.2 分组查询2.3 条件过滤 1. 数据库设计 1.1 数据库设计基本概念 数据库设计就是根据业务的具体需求，结合我们所学的 DBMS ，为了这个业务构造最优的数据存储模型。建立数据库中的表结构以及表与表之间的关联关系的过程。 1.2 数据库设计的步骤 需求分析（数据是什么？数据具有哪些属性？数据和属性之间的特点是什么）
逻辑分析（通过 ER图对数据库进行逻辑建模）
物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）
维护设计（1. 对新的需求进行建表；2. 表优化）
1.3 表设计 1.3.1 一对一 例如：人 和 身份证 的关系
一个人只能对应一个身份证号
1.3.2 一对多 例如： 班级 和 学生 的关系
一个班级多个学生
1.3.3 多对多 例如：学生 和 课程 的关系
一个学生可以选择多个课程
一个课程可以被多个学生选择
案例：
创建学生表：学生 id ，姓名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a158a4f4227a08c80462ce58cfcaa68e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a7b1986c381b9aaccdb0055a83bb65/" rel="bookmark">
			【C&#43;&#43;】——vector容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于vector，其实和string类是有点像的，但是里面的结构又有点不一样，所以有些操作是需要注意的
一 vector基本概念 1.我们使用vector的时候，可以把他当作一个数组来使用，只不过这个数组是可以自动扩容的
2.vector里面的数据是存在堆上面的，数组里面的数据是存在栈里面的，这个要区分
3.使用vector的时候需要包含#include&lt;vector&gt;头文件
二 vector的构造函数 函数原型：
default (1) explicit vector (const allocator_type&amp; alloc = allocator_type()); fill (2) explicit vector (size_type n, const value_type&amp; val = value_type(), const allocator_type&amp; alloc = allocator_type()); range (3) template &lt;class InputIterator&gt; vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type()); copy (4) vector (const vector&amp; x); 1.vector (const allocator_type&amp; alloc = allocator_type());//无参构造函数
2.vector (size_type n, const value_type&amp; val = value_type(), const allocator_type&amp; alloc = allocator_type());//将n个val拷贝给本身
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29a7b1986c381b9aaccdb0055a83bb65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2775ad38b74b57e98796630f94edc897/" rel="bookmark">
			【Web世界探险家】HTML5 探索与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📚博客主页：爱敲代码的小杨.
✨专栏：《Java SE语法》 | 《数据结构与算法》 | 《C生万物》 |《MySQL探索之旅》
❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️
🙏小杨水平有限，欢迎各位大佬指点，相互学习进步！
小杨近些在学习人工智能方面的知识,发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
文章目录 1. HTML的结构1.1 基本结构1.2 标签1.2.1 标签的分类1.2.2 标签的关系 2. HTML 常用标签2.1 标签语义2.2 标题标签（h1~h6）2.3 段落标签2.4 换行标签2.5 文本格式化标签2.6 图像标签2.7 超链接标签2.7.1 超链接的语法格式2.7.2 超链接的分类 2.8 表格标签2.8.1 表格标签的主要作用2.8.2 表格标签的基本写法2.8.3 表格属性2.8.4 合并单元格 2.9 列表标签2.9.1 无序列表2.9.2 有序列表2.9.3 自定义列表 2.10 表单标签2.10.1 表单的组成2.10.2 表单域2.10.3 表单控件 2.11 无语义标签 3.参考文档 1. HTML的结构 学习任何一门语言，首先要掌握它的基本格式，就像写信需要符合书信的格式要求一样。学习 HTML ，同样需要掌握 HTML 的基本格式。
1.1 基本结构 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2775ad38b74b57e98796630f94edc897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c378cd1191d74063382d2424f428f826/" rel="bookmark">
			探索GGUF：利用llama.cpp高效运行大型语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索GGUF：利用llama.cpp高效运行大型语言模型 在人工智能领域，大型语言模型（LLM）的应用越来越广泛，但运行这些模型常常需要大量计算资源和复杂的配置。最近，一个名为llama.cpp的开源项目引起了广泛关注，它通过C/C++实现了一个高效的LLM推理框架，极大地简化了在各种硬件上部署和运行LLM的过程。
什么是llama.cpp? llama.cpp 是一个开源项目，由 Georgi Gerganov 创建，它提供了一个用纯 C/C++ 编写的库，用于在本地或云端高效地执行大型语言模型（LLM）的推理任务。这个库的设计目标是简化在不同硬件平台上部署和运行大型语言模型的过程，同时避免了对外部框架如 Python、PyTorch 或 TensorFlow 的依赖。
与传统的基于 Python 的实现相比，llama.cpp 通过直接在 C/C++ 环境中运行，减少了对解释器的依赖，从而可能提高性能并降低资源消耗。此外，llama.cpp 支持跨平台，可以在多种操作系统上编译和运行，包括但不限于 macOS、Linux、Windows，以及通过 Docker 容器化部署。
llama.cpp官网
GGUF模型格式的创新之处 GGUF（Georgi Gerganov’s Universal Format），即 Georgi Gerganov 通用格式，是 llama.cpp 项目中开发的一种创新模型文件格式。GGUF 专为提升大型语言模型（LLM）的推理速度和优化内存占用而设计，它代表了对之前 GGML（Georgi Gerganov’s Machine Learning）格式的重要升级。
主要创新点包括： 高效推理：GGUF 格式对模型数据进行了优化，以实现更快的加载时间和推理速度，这对于需要快速响应的应用场景至关重要。
内存优化：通过精心设计的数据结构和存储方案，GGUF 减少了模型在运行时的内存占用，使得在资源受限的设备上部署大型语言模型成为可能。
复杂令牌化支持：GGUF 支持复杂的令牌化过程，包括对特殊令牌的识别和处理，这使得模型能够更准确地理解和生成语言文本。
灵活性和扩展性：GGUF 格式设计考虑了未来的扩展，可以适应不同语言模型的需求，包括自定义词汇和特殊操作。
跨平台兼容性：GGUF 格式的模型文件可以在多种硬件和操作系统上使用，确保了模型的广泛适用性。
量化支持：GGUF 支持多种量化技术，允许模型在不同精度级别上运行，从而在性能和模型大小之间取得平衡。
通过这些创新，GGUF 格式成为了 llama.cpp 高效运行大型语言模型的关键因素，为开发者提供了一个强大的工具，以在各种环境中部署和使用先进的自然语言处理能力。
为什么选择llama.cpp? 选择llama.cpp作为LLM推理的平台，有几个显著优势：
无依赖实现：llama.cpp不依赖Python、PyTorch或TensorFlow等框架，可以直接在C/C++环境中运行，减少了复杂性和潜在的性能瓶颈。跨平台支持：从支持苹果硅片到各种GPU和CPU，llama.cpp优化了多种硬件的性能，确保在不同系统上都能获得最佳性能。灵活的性能配置：用户可以通过设置不同的位深（1.5位至8位）来量化模型，这有助于在保持推理速度的同时减少内存使用。 开始使用llama.cpp 使用llama.cpp涉及以下几个步骤：
获取模型：首先需要获得一个已经转换为GGUF格式的模型，可以通过Hugging Face等平台下载。配置和编译：将llama.cpp源代码下载到本地后，使用CMake等工具进行编译。加载和运行模型：通过llama.cpp提供的API加载模型，并根据需要配置推理参数，如上下文大小和批处理大小。 通过上述步骤，开发者不仅可以在自己的项目中快速部署LLM，还可以根据具体需求调整模型运行的配置，从而在各种应用场景中实现高效、灵活的语言处理功能。
参考文献和视频 Lessons from llama.cpp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c378cd1191d74063382d2424f428f826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7e9c0419688f75fe9dee7ffa45a655/" rel="bookmark">
			Python的time模块——各种与时间相关的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 获取当前时间2. 时间格式化3. 延时执行4. 时间戳运算5. 计算代码执行时间6. 转换为指定时区的时间7. 定时器（每隔一定时间执行一次任务）8. 获取时间戳的日期部分 Python的time模块提供了各种与时间相关的函数，包括获取当前时间、处理时间间隔、执行时间测量等。以下是对time模块中一些常用功能的详细介绍、用法、常见用法以及示例代码和运行结果。
1. 获取当前时间 time.time(): 返回自纪元（1970年1月1日00:00:00 UTC）以来的秒数，通常称为Unix时间戳。time.localtime(): 返回一个表示本地时间的time.struct_time对象。time.gmtime(): 返回一个表示协调世界时（UTC）的time.struct_time对象。 import time # 获取当前时间戳 timestamp = time.time() print("当前时间戳:", timestamp) # 获取本地时间 local_time = time.localtime() print("本地时间:", local_time) # 获取UTC时间 utc_time = time.gmtime() print("UTC时间:", utc_time) 运行结果（取决于你的时区和当前时间）：
当前时间戳: 1715833304.1631322 本地时间: time.struct_time(tm_year=2024, tm_mon=5, tm_mday=16, tm_hour=12, tm_min=21, tm_sec=44, tm_wday=3, tm_yday=137, tm_isdst=0) UTC时间: time.struct_time(tm_year=2024, tm_mon=5, tm_mday=16, tm_hour=4, tm_min=21, tm_sec=44, tm_wday=3, tm_yday=137, tm_isdst=0) 2. 时间格式化 time.strftime(format, time_tuple): 将time.struct_time对象格式化为字符串。time.strptime(string, format): 将字符串解析为time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7e9c0419688f75fe9dee7ffa45a655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa54e8ab7bd8436debd98157bdecfd73/" rel="bookmark">
			Linux网络配置全攻略：解读/etc/network/interfaces文件的精髓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的博客，代码的世界里，每一行都是一个故事 Linux网络配置全攻略：解读/etc/network/interfaces文件的精髓 前言文件结构与基本概念配置网络接口的常用参数高级网络配置技巧实用工具与调试技巧实战案例与最佳实践 前言 在我们的日常生活中，网络已经成为了不可或缺的一部分，而正确配置网络对于系统运行和通信至关重要。而 Linux 系统中的网络配置文件 /etc/network/interfaces 就像是网络世界的一本"说明书"，它记录了系统中网络接口的种种参数和配置。但是，你是否真正了解过这个文件呢？本文将带你一起深入解析 /etc/network/interfaces，揭开它的神秘面纱，让你在网络世界中游刃有余！
文件结构与基本概念 /etc/network/interfaces 是一个重要的网络配置文件，通常用于配置 Linux 系统中的网络接口和网络参数。它在 Debian 系统及其衍生版本（如 Ubuntu）中广泛使用，用于定义网络接口的配置信息，如IP地址、子网掩码、网关、DNS等。
以下是 /etc/network/interfaces 文件的一般结构和一些常用配置项：
文件结构：
文件以文本格式存储，可以使用文本编辑器（如vi、nano等）进行编辑。每个网络接口的配置通常由一个或多个配置块组成，每个块以关键字 iface 开始，后跟接口名称（如 eth0、enp0s3 等）。每个配置块包含一个或多个配置项，每个配置项由关键字和相应的值组成。 常用配置项：
address：设置接口的IP地址。netmask：设置接口的子网掩码。gateway：设置接口的默认网关。dns-nameservers：设置DNS服务器的IP地址。dns-search：设置DNS搜索域。auto：指定系统在启动时是否自动激活该网络接口。iface：定义一个网络接口的配置块。 示例配置：
auto eth0 iface eth0 inet static address 192.168.1.100 netmask 255.255.255.0 gateway 192.168.1.1 dns-nameservers 8.8.8.8 8.8.4.4 在此示例中，配置了一个名为 eth0 的网络接口，并将其配置为静态IP地址，IP地址为 192.168.1.100，子网掩码为 255.255.255.0，默认网关为 192.168.1.1，DNS服务器为 8.8.8.8 和 8.8.4.4。
总的来说，/etc/network/interfaces 文件是配置 Linux 系统网络接口的重要文件，通过对其进行适当的配置，可以设置系统的网络连接方式、IP地址、网关、DNS服务器等信息，从而实现网络连接和通信。
配置网络接口的常用参数 下面是对常用网络接口配置参数的详细解读：
auto：
含义：指定系统在启动时是否自动激活该网络接口。用法：通常在配置文件中为每个网络接口定义一行 auto 语句，接着是相应的网络接口名称。如果设置为 auto &lt;interface&gt;，则表示在系统启动时会自动激活该网络接口；如果设置为 allow-hotplug &lt;interface&gt;，则表示仅在接口插入时才激活。 iface：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa54e8ab7bd8436debd98157bdecfd73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ccfa3fe3b1d5f8616c76b66f3d4f7f0/" rel="bookmark">
			RabbitMQ架构设计原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息中间件 消息中间件基于队列模型实现异步/同步传输数据
作用：可以实现支撑高并发、异步解耦、流量削峰、降低耦合度。
"异步" 和 "同步" 通常指的是数据发送（生产）和消费（处理）的方式。
解耦： 解耦意味着将原本紧密关联或相互依赖的组件、功能或系统分离，使它们能够独立地运行、修改和扩展，而不需要影响其他部分。
在进程或线程中，解耦可以使得多步骤的操作并行执行，而不是串行执行，从而提高效率。例如，在一个下载和解析的场景中，下载和解析函数可以放在进程池或线程池中并行运行，谁先下载完就先解析，从而实现解耦。
“异步解耦” 可以理解为在并发编程或系统设计中，通过异步处理的方式实现系统组件或功能之间的解耦，使得它们能够并行运行、独立扩展，并且不会相互阻塞或依赖。
流量削峰： 流量削峰是指通过一些技术手段来削弱瞬时的请求高峰，使系统吞吐量在高峰请求下保持可控
传统的http请求有诸多缺点： 1.在高并发的情况下，发送大量的请求达到服务器端导致服务器端处理请求堆积。
2.Tomcat服务器处理每个请求都有自己独立的线程，如果超过最大线程数，会将该请求缓存到队列中，请求堆积过多的情况下，可能导致tomcat服务器崩溃
所以一般都会在nginx入口实现限流，整合服务保护框架。
3. http请求处理业务逻辑比较耗时，容易造成客户端一直等待，阻塞等待过程中会导致客户端超时重发，引发幂等性问题。
注意事项：接口是为http协议的情况下，最好不要处理比较耗时的业务逻辑，耗时的业务逻辑应该单独交给多线程或者是mq处理。
举例说明： 客户端发送请求到达服务器端，服务器端实现会员注册业务逻辑，
1.insertMember() --插入会员数据 1s
2.sendSms()----发送登陆短信提醒 3s
3.sendCoupons()----发送新人优惠券 3s
总共响应需要7s时间，可能会导致客户端阻塞7s时间，对用户体验不是很好。
代码演示： import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class MemberService { //@Autowired //public MemberServiceAsync memberServiceAsync; //@Bean @RequestMapping("/addMember") public String addMember(){ //1.数据库插入数据 log.info("&gt;01&lt;"); System.out.println("&gt;01&lt;"); sms(); System.out.println("&gt;04&lt;"); return "用户注册成功！！"; } public String sms(){ System.out.println("&gt;02&lt;"); try{ System.out.println("&gt;正在发送短信&lt;"); Thread.sleep(3000); }catch(Exception e){ e.printStackTrace(); } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ccfa3fe3b1d5f8616c76b66f3d4f7f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e73296022f64997278ebfb2b63c2c13/" rel="bookmark">
			7大最佳开源生成式AI模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（使用人工智能生成。）
作为一个人工智能时代的普通用户，你可能用过或听说过 ChatGPT、文心一言这样的生成式人工智能工具。但如果你是一个开发者或使用人工智能的企业，那你大概率听说过或正在使用开源模型。《福布斯》就推荐了七大“当今最好的开源生成式人工智能模型”，我们来看看都有哪些。
开发者和企业在开始使用生成式人工智能时，选择开源而不是专有工具的原因有很多。
这可能是因为成本、定制和优化的机会、透明度，或者仅仅是因为社区提供的支持。
当然，开源也有缺点。
对于一般软件来说，“开源”一词仅仅意味着源代码是公开的，可以免费用于几乎任何目的。
但说到人工智能模型，人们对其确切含义还存在一些争议，我们将在讨论本文涉及的各个模型时对此进行探讨。那么，让我们开始吧。
Stable Diffusion
作为最强大、最灵活的图像生成模型之一，当然也是使用最广泛的开源图像模型，Stable Diffusion 3（当前的最新版本）支持文本到图像以及图像到图像的生成，并以其创建高度逼真、细节丰富的图像的能力而闻名。
与常见的开源软件一样，使用 Stable Diffusion 并不像使用 ChatGPT 等商业专有工具那么简单。它没有自己的 Web 界面，而是通过商业实体开发的第三方工具来访问，包括 DreamStudio 和 Stable Diffusion Web。另一种方法是在本地自行编译和运行，这就需要提供自己的计算资源和技术知识。
Meta Llama 3
这是一系列具有各种规模的语言模型，使其适合不同的应用程序，从轻量级移动客户端到全规格云部署。在其社交媒体平台上为 Meta AI 助手提供动力的同一个模型，任何人都可以将其用于多种用途，包括自然语言生成和创建计算机代码。它的强项之一是能够在功率相对较低的硬件上运行。不过，与本文涉及的其他一些模型一样，由于 Meta 公司没有披露其训练数据的确切细节，因此对于它是否能真正被视为开源模型还存在一些争议。
Mistral AI
Mistral 是一家法国初创公司，开发了多种生成式人工智能模型，并以开源许可的方式提供。其中包括 Mistral 7B，其设计轻巧且易于在低功耗硬件上部署，以及功能更强大的 Mistral 8x22B。它拥有强大的用户社区提供支持，并将自己定位为高度灵活和可定制的生成语言模型。
GPT-2
OpenAI 已经开源了其大型语言模型的第二个版本——本质上是现在用于为 ChatGPT 提供动力的引擎的早期版本。虽然它不像后来的 GPT-3.5 或 GPT-4 那么大、强大或灵活（与 GPT-4 的一万亿个参数相比，它建立在 12 亿个参数上），但它仍被认为完全可以胜任许多基于语言的任务，如生成文本或为聊天机器人提供动力。GPT-2 由 OpenAI 根据 MIT 许可提供，通常被认为符合开源原则。
BLOOM
BLOOM 被称为世界上最大的开放式多语言语言模型，建立在 1760 亿个参数的基础上。开发工作由 Hugging Face 领导，Hugging Face 是一个开源人工智能资源库，与 1000 多名研究人员组成的团队合作，是一个名为 BigScience 的全球合作项目的一部分。其目的是创建一个真正开放、透明的大型语言模型，任何人只要同意该项目的“负责任的人工智能许可”条款，都可以使用。从技术上讲，这意味着它并不完全开源，但只要不将其用于许可证条款定义的有害目的，就可以免费使用和分发。这使得它在开发和传播道德人工智能这一至关重要的领域成为一个非常有趣的实验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e73296022f64997278ebfb2b63c2c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f7ea7d18f28f6e3be4d2d73789720c/" rel="bookmark">
			技术前沿 |【大模型LLaMA：技术原理、优势特点及应用前景探讨】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型LLaMA：技术原理、优势特点及应用前景探讨 一、引言二、大模型LLaMA的基本介绍三、大模型LLaMA的优势特点五、结论与展望 一、引言 随着人工智能技术的飞速发展，大模型已成为推动这一领域进步的重要力量。近年来，大模型LLaMA以其卓越的性能和广泛的应用前景，受到了业界的广泛关注。本文旨在深入解析大模型LLaMA的技术原理、优势特点以及可能的应用场景，以期为相关领域的研究和应用提供参考。
二、大模型LLaMA的基本介绍 大模型LLaMA是一种基于深度学习技术的自然语言处理模型，其名称来源于西班牙语中的“LLaMA”（意为“羊驼”），寓意着其强大的处理能力和广泛的应用范围。该模型采用了先进的Transformer架构，通过大量的训练数据和计算资源，实现了对自然语言的深入理解和高效处理。
LLaMA模型的设计特点主要包括以下几个方面：
1.大规模参数：LLaMA模型拥有数以亿计的参数，使其能够处理更加复杂的语言现象和任务。
2.多任务学习：通过同时训练多个任务，LLaMA模型能够实现知识的共享和迁移，提高模型的泛化能力。
3.上下文感知：LLaMA模型能够充分考虑文本的上下文信息，从而更准确地理解文本的含义和意图。
三、大模型LLaMA的优势特点 相较于传统模型，大模型LLaMA具有以下优势特点：
1.更高的性能：由于采用了先进的Transformer架构和大量的训练数据，LLaMA模型在各项自然语言处理任务中都取得了显著的性能提升。
2.更强的泛化能力：通过多任务学习和上下文感知技术，LLaMA模型能够更好地适应不同的应用场景和任务需求。
3.更低的资源消耗：相较于传统的深度学习模型，LLaMA模型在训练和推理过程中具有更低的资源消耗和更高的效率。
例如，在机器翻译任务中，LLaMA模型能够实现对多种语言的实时翻译，并且保持较高的翻译质量和准确性。此外，LLaMA模型还在文本分类、情感分析、问答系统等任务中表现出色，为相关领域的研究和应用提供了有力的支持。
四、大模型LLaMA的应用前景
大模型LLaMA在自然语言处理领域具有广泛的应用前景，以下是一些可能的应用场景：
1.智能客服：LLaMA模型可以应用于智能客服系统中，实现自动回答用户问题、提供个性化服务等功能，提高客服效率和用户体验。
2.内容推荐：通过分析用户的浏览历史、兴趣偏好等信息，LLaMA模型可以为用户推荐相关的内容和服务，提高内容的点击率和转化率。
3.文本创作：LLaMA模型可以辅助作家、编辑等人员完成文本创作和修改工作，提高创作效率和质量。
4.语音识别与合成：结合语音处理技术，LLaMA模型可以实现高质量的语音识别和语音合成功能，为智能语音助手、智能音响等应用提供支持。
五、结论与展望 大模型LLaMA以其卓越的性能和广泛的应用前景，在人工智能领域具有重要的地位和作用。未来，随着技术的不断进步和应用场景的不断拓展，LLaMA模型将在更多领域发挥重要作用。同时，我们也需要关注其可能带来的伦理和安全问题，并采取相应的措施进行防范和解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06d7b3e40d8cc9a11855dd17ca5c839/" rel="bookmark">
			如何在PS里使用stable diffusion插件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位设计界的领军人物们，你们一定对PS（也就是大家熟知的Photoshop）不陌生吧。同样，对于AI领域的精英们，SD（stablediffusion）这款软件也应该是如雷贯耳。这两款软件，各自独立且功能强大，都是设计领域不可或缺的工具。
特别是在今年AI技术的飞速发展下，我们很难在设计工作中完全忽视SD这款强大且高度可控的AI软件。与此同时，PS作为设计师的必备工具，其地位也是不言而喻的。然而，在AI作图这个领域，PS的表现似乎总是有些不尽如人意。
尽管我们愿意为Adobe买单，购买了正版的PS Beta版本，并尝试使用了其创意式填充功能，但效果却难以令人满意。不仅如此，还经常出现一些奇怪的生成报错等问题。这让我们不禁思考，在AI技术的冲击下，PS是否应该做出更多的改进和创新，以适应这个快速发展的时代。
一、插件介绍
好的，让我们言归正传。想必各位已经猜到我接下来要介绍的内容了，那就是【Auto-Photoshop-StableDiffusion-Plugin】。这款PS插件真可谓是个神器，它让我们能在Photoshop中直接使用Stable Diffusion（SD）的功能，彻底告别了来回切换软件的繁琐。在设计过程中，我们可以随时调用SD的辅助功能，轻松生成AI制作的图片。
简而言之，这款插件强大到令人咋舌。Photoshop和Stable Diffusion，这两款软件各自在其领域都是顶尖的存在，如今它们强强联手，简直是如虎添翼。那么，它究竟有多强大呢？请随我一起深入了解，你会发现它不仅能满足你的期待，更可能让你为之倾倒。现在，就让我们一起踏上这段探索之旅吧！
二、关于插件的安装 2.1 官方文档
安装插件这个事情是最简单的，咱也别藏着掖着，这里有一份官方使用说明文档，且包含两款软件中的插件安装包，这个网站打开需要各位乘坐小飞机（网络）：https://github.com/AbdullahAlfaraj/Auto-Photoshop-StableDiffusion-Plugin
如果你嫌麻烦，不想去看官方文档可不可以呢，当然没毛病哈，保姆级教学是我的标签，下面我会给大家介绍安装的方法，以及我安装的时候遇到的一些坑。
2.2 StableDiffusion插件安装
对于熟悉Stable Diffusion（SD）的朋友们来说，插件的安装应该是驾轻就熟的。不论是选择在线安装还是本地安装，都是大家常用的方法。
选择在线安装时，首先要确保你的网络连接是畅通的。然后，在Photoshop的扩展面板中，选择“可下载”选项。接下来，你可以按下键盘上的“Ctrl+F”组合键，打开搜索功能，输入【Auto-Photoshop-StableDiffusion-Plugin】进行搜索。一旦找到了这个插件，点击“安装”按钮即可开始安装过程。安装完成后，你可以在“已安装”列表中查看到这个插件，确认它已经成功安装在你的Photoshop中了。
这个插件的安装过程相对简单直观，即使对于新手来说，也能够轻松上手。只要按照上述步骤操作，你就可以将SD的强大功能集成到Photoshop中，进一步提升你的设计效率和创作能力。无论是对于专业设计师还是设计爱好者来说，这个插件都是一个不可多得的好工具。
我在首次尝试安装这个插件时，便是按照通常的方法进行，但在后续使用Photoshop的图生图功能时，发现蒙版功能并未如预期般生效。这个问题让我困扰了数小时，尝试了各种方法都未能解决。最终，我选择了本地安装的方式，问题才得以顺利解决。
对于这个问题，我尚不确定是由于我的操作不当还是插件本身存在BUG。为了避免大家后续也遇到类似的困扰，我建议大家还是像我一样选择本地安装的方式，这样更为稳妥可靠。
注：其他插件同理，在线安装导致各种报错那就本地安装。
本地安装需要我们下载安装包，两种方法：
1、去官方文档上下载，链接在此：https://github.com/AbdullahAlfaraj/Auto-Photoshop-StableDiffusion-Plugin/releases/tag/v1.3.3
2、来我们社区下载该插件，通过百度网盘的形式下载，无网络限制（直接私我）
下载完成后，接下来就是将这个文件夹放置到指定的【extensions】目录中。具体的文件路径已在下图中详细标出，按照此路径将文件夹放入即可。完成这些步骤后，恭喜你，安装大功告成！为了确保安装成功，你可以前往webUI上的“已安装”目录进行检查，确认插件已经成功添加至列表中。现在，你可以开始享受这款插件带来的便捷与高效了。
为了确保插件能够顺利运行，我们需要进行一项关键设置——打开web-ui的API模式。
请按照以下步骤操作：首先，打开秋叶的启动器界面，这是一个集成了多种功能的便捷工具。
在启动器界面中，你需要仔细寻找“高级选项”这一设置项。一旦找到，点击进入，你会看到一系列详细的网络设置选项。
在这些选项中，特别留意“启动API”按钮，并确保它处于打开状态。
通过这一设置，我们将为插件提供必要的接口支持，从而确保其能够正常运作。完成这些步骤后，你就可以放心地使用插件了，它将为你带来更加流畅和高效的设计体验。
2.3 Photoshop插件安装
安装完Stable Diffusion后，接下来的重要步骤是为Photoshop配备相应的插件。这里有个关键信息要告诉大家，SD和PS的插件文件其实是相同的，也就是之前提到的那个文件。
在开始安装之前，有几点事项需要提醒大家注意。首先，这款插件目前仅支持【Photoshop v24】及以上版本，也就是说，如果你的Photoshop版本是2023年或之后发布的，那么就可以放心使用。我个人目前正在使用的是2024年版的Photoshop，体验非常棒。当然，如果你还没有这些软件，不用担心，随时可以向我咨询相关信息。
安装插件的过程其实非常简便。你只需要将插件文件夹拖放到Photoshop的【Plug-ins】目录下就可以了。要找到这个目录，你只需右键点击Photoshop软件图标，选择“打开文件所在的位置”，然后就能轻松定位到【Plug-ins】目录了。完成这些步骤后，你就可以开始享受插件带来的便利和高效了。
2.4 测试并启动插件
插件安装完毕后，接下来我们要进行一番测试，确保插件能够正常运行。
在开始测试之前，请确保一点至关重要：StableDiffusion必须正常启动。这需要我们保持【SD控制台】处于运行状态。虽然web-UI界面可以关闭，但【控制台】绝对不能关闭。请仔细查看下面的界面，这就是我们需要保持开启的【控制台】。这个步骤非常关键，因为它关系到插件能否与StableDiffusion进行正常的交互。
同时，也请留意，如果在测试过程中遇到任何问题或异常，不要慌张。首先检查插件是否安装正确，然后查看【SD控制台】是否正常运行。如果一切正常，但插件仍然无法正常工作，那么可能是其他因素导致的问题，此时建议查阅相关文档或寻求专业帮助。
确保【SD控制台】正常运行是测试插件能否正常工作的前提。只有在这个前提下，我们才能准确判断插件的安装和配置是否成功。
接下来，我们需要启动Photoshop软件。在启动后，请将目光移向顶部菜单栏，点击【增效工具】这一选项。在这里，你应该能够看到一个名为【Auto-Photoshop-StableDiffusion-Plugin】的条目。
这正是我们安装的插件，看到它意味着插件安装成功。接下来，为了使用该插件，只需点击【SD插件（明空汉化）】即可调出该插件的操作界面。
这个界面将为你提供一系列强大的功能，帮助你更好地利用Stable Diffusion进行创作。所以，不妨现在就去尝试一下吧，相信你会被它的便捷和高效所折服。
至此，安装篇到此结束，希望大家能跟着教程一把过，不出现任何的问题，愿主保佑你们~
三、四种生图功能详解 本章节我们来介绍Auto Photoshop界面及其主要功能，但不会介绍stablediffusion的工作原理，如果你还没接触过stablediffusion这款软件，可以先去看看我的另外一篇文章
《外婆都能看懂的Stable Diffusion入门教程》。
3.1 基础功能介绍
下面以两张图片来详细介绍下插件的功能，该功能都是与SD对应的，其他的功能会在后续操作中插入讲解。
3.2 文生图功能详解
文生图功能是Stable Diffusion中最常用且最易上手的操作之一。只需简单输入几个关键词并设定好尺寸，即可快速生成你想要的图片。下面，我们将进行实际的操作演示。
首先，在Photoshop中新建一个画板（快捷键ctrl+n）。为了演示效果，我选择的尺寸是1920*1080，这是一个常见的宽屏尺寸。
接下来，我们需要选择一个适合的大模型。在这里，我推荐“majicMIX realistic 麦橘写实”，这是一个非常出色的写实风格模型。
我们开始输入关键词。正向关键词描述了我们想要图片中包含的元素，例如：“1girl, sweater, white background”，这表示我们想要生成一张图片，其中包含一个女孩，穿着毛衣，背景为白色。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b06d7b3e40d8cc9a11855dd17ca5c839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601e13d25f710e39af08e2d7857993ba/" rel="bookmark">
			一文读懂RDMA: Remote Direct Memory Access（远程直接内存访问）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
引言
一、RDMA的基本原理
二、RDMA的主要特点
三、RDMA的编程接口
四、RDMA的代码演示
服务器端代码：
客户端代码：
五、总结
引言 RDMA，全称Remote Direct Memory Access，即远程直接内存访问，是一种高效的网络通信技术。与传统的网络通信方式不同，RDMA允许网络中的一台机器直接读写另一台机器的内存，而无需操作系统和CPU的过多介入。这种技术可以极大地提高网络通信的效率和性能，特别适用于高性能计算、大数据处理、分布式存储等场景。
一、RDMA的基本原理 RDMA的基本原理是，通过硬件（如RDMA网卡）直接在应用程序的内存之间搬移数据，绕过了操作系统的网络协议栈，从而避免了数据在用户空间和内核空间之间多次拷贝的开销，以及上下文切换的开销。RDMA操作可以看作是硬件执行的远程内存读写操作，因此具有非常高的性能。
二、RDMA的主要特点 零拷贝：RDMA可以直接将数据从发送方的内存传输到接收方的内存，无需在内核和用户空间之间进行数据拷贝。低延迟：由于绕过了操作系统的网络协议栈，RDMA可以实现微秒级的低延迟通信。高带宽利用率：RDMA可以有效地利用网络的带宽，提高数据传输的效率。CPU卸载：RDMA操作大部分由硬件完成，大大减轻了CPU的负担。 三、RDMA的编程接口 RDMA的编程接口主要包括Verbs API和RDMA CM（Connection Manager）API。Verbs API提供了一套完整的RDMA操作函数，包括内存注册、队列对（Queue Pair, QP）的创建和管理、数据发送和接收等。RDMA CM API则提供了一套用于建立和管理RDMA连接的功能。
四、RDMA的代码演示 下面是一个简单的RDMA客户端和服务器的代码演示。这个例子中，客户端向服务器发送一个消息，服务器接收到消息后回复一个确认。
服务器端代码： #include &lt;infiniband/verbs.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; int main() { // 初始化RDMA设备和资源... // 省略初始化代码... // 创建并配置队列对（QP）... // 省略QP创建和配置代码... // 等待接收消息... while (1) { // 接收消息... // 省略接收代码... printf("Received message: %s\n", received_message); // 发送确认消息... // 省略发送代码.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/601e13d25f710e39af08e2d7857993ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bbc89e6584fea7a76358cdcee01261c/" rel="bookmark">
			【Python】语句与众所周知【自我维护版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位大佬好 ，这里是阿川的博客 ， 祝您变得更强 个人主页：在线OJ的阿川
大佬的支持和鼓励，将是我成长路上最大的动力 阿川水平有限，如有错误，欢迎大佬指正 本篇博客是在之前的基础上进行的维护
目录 条件语句循环语句众所周知模板函数 条件语句 if elif else
程序只会选择满足的其中一个进入，当进入一个条件时，其他选择便不作考虑 if if else
记得这些后面要加个冒号：
相较于其他语言，在Python当中缩进很重要
4个空格或者一个tab为一个缩进看见缩进就能判断该代码的作用域及生命周期 循环语句 whilefor循环变量in可迭代对象 把可迭代对象依次取出来放入循环变量中，取完可迭代对象则循环结束。可迭代对象是一种特殊的变量，可能包含很多元素 例如 range它是一个内联对象（包含很多元素，是左闭右开哦），起到的效果就是一个可迭代对象。 range有三个参数，前两个参数代表范围，左闭右开，第3个参数是指步长（相隔单位） 在循环当中，continue是代表立即结束当前循环 进入下个循环。
break是立刻结束整个循环。
众所周知 Python中 负数 % 2它是大于等于1的 Python不能有空语句，如果真的想啥也不做的话，则用pass来占位。 光看到whele Ture不一定是死循环，关键是看它循环体是否有break。
计算机领域常常有说**“合法"和"非法”**指的是：是否合理，是否有效，并不是指触犯了法律。 模板 也就是别人写好的代码直接来用 在Python当中，如果引入模板，需要先使用import语句，把模板的名字给"导入"进来
以随机数模板random.randint(begin, end) 为例 这个random是指模板，.randint是模板当中的一个类型（随机数类型） exit代表直接结束程序，它的模板是sys.exit（0） 导入 import sys
sleep代表放缓多少秒 它的模板是time.sleep(数字) import time
函数 是指一段可以被重复使用的代码。 函数的调用
是指用一个函数名（实参列表） 实差列表应该等于形参列表个数。在编程当中有一套软性要求，也就是PEP8原则。是指定义函数后，调用函数应在定义函数后空两行. Python当中形参的类型可以不同，也就是Python的动态类型，只要符合相应运算规则即可。
一个通用的编程原则：
一个函数只做一件事，让逻辑和交互/页面分离。这样解耦合程度越低 越好。 在Python中可以返回多个值由逗号分割即可，甚至可以多元赋值，若不想使用其中一部分，可用 _ 来占位。
这跟其他的编程语言不同，Golang语言吸收了这一点。 在函数定义中，想对全局变量进行修改，则用global关键字声明下变量说明为全局变量，这样才可对全局变量进行修改。
好的，到此为止啦，祝您变得更强
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bbc89e6584fea7a76358cdcee01261c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b698771528df3ddcccb53cca11d6e2ea/" rel="bookmark">
			排序(一)----冒泡排序,插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天讲一些简单的排序,冒泡排序和插入排序,但是这两个排序时间复杂度较大,只是起到一定的学习作用,只需要了解并会使用就行,本文章是以升序为例子来介绍的
一冒泡排序 思路 冒泡排序是一种简单的排序算法，它重复地遍历要排序的序列，每次比较相邻的两个元素，如果顺序错误则交换它们。这样每一轮遍历过后，序列中最大的元素就会被移动到最后的位置上，直至整个序列有序。
具体步骤如下：
1. 从序列的第一个元素开始，比较相邻的两个元素，如果顺序错误则交换它们；
2. 继续遍历序列，每次比较相邻的两个元素并交换，直至遍历完整个序列；
3. 重复以上步骤，除去已排序的元素，直至整个序列有序
屏幕录制 2024-05-14 213653-CSDN直播
具体实现 这里建议排序可以写一次的运动在推测总体的代码,下面第一次写代码,下面的n 是数组具体个数,但是第一个代码和第二个代码是一样的情况,都可以实现这个排序
为什么会不一样呢?
因为下面的索引 i 的不同,第一个是i和i+1,那么假设有4个数的话,从0下标开始比较3次,i&lt;n-1 满足了条件三次循环的条件,并从下标0开始比较因为下面的索引 i 的不同,第二个是i和i-1,那么假设有4个数的话,从0下标开始比较3次,i&lt;n 满足了条件三次循环的条件,并从下标1开始比较 for (int i = 0; i &lt; n-1; i++) { if (a[i] &gt; a[i + 1]) { Swap(&amp;a[i], &amp;a[i + 1]); } } for (int i = 1; i &lt; n ; i++) { if (a[i - 1] &gt; a[i]) { Swap(&amp;a[i], &amp;a[i-1]); } } 实现了一次的代码之后就可以套用整个代码的逻辑去完善代码,总共n个数,那么比较n-1次就行了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b698771528df3ddcccb53cca11d6e2ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b7b3ff4e262cd240f7ee6dab3a65ed/" rel="bookmark">
			mysql 重复数据删除只保留一条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中，删除重复数据并只保留一条记录可以通过几种方法实现，以下是一些常用的方法：
方法一：临时表法
创建临时表：首先创建一个临时表，结构与原表相同。
插入去重数据：使用INSERT INTO ... SELECT语句结合GROUP BY或DISTINCT将去重后的数据插入临时表。
删除原表数据：清空原表数据。
将临时表数据移回原表：将临时表中的数据插入回原表。
清理临时表：最后，如果不需要了，可以删除临时表。
示例SQL（假设表名为ceshi，主键或唯一标识列为id，重复依据列为name, class）:
CREATE TEMPORARY TABLE temp_ceshi AS SELECT MIN(id) as id, name, class FROM ceshi GROUP BY name, class; DELETE FROM ceshi; INSERT INTO ceshi SELECT * FROM temp_ceshi; DROP TABLE temp_ceshi; 方法二：自连接删除法
直接在原表上操作，通过自连接删除重复项，但需确保你有足够的方式确定哪一行是需要保留的（例如，通过日期、ID或其他唯一条件）。
示例SQL（假设保留每个重复组中ID最小的记录）:
DELETE c1 FROM ceshi c1, ceshi c2 WHERE c1.id &gt; c2.id AND c1.name = c2.name AND c1.class = c2.class; 方法三：窗口函数（如果MySQL版本支持）
对于MySQL 8.0及以上版本，可以使用窗口函数ROW_NUMBER()来标记重复行，然后删除标记为非1（即重复的）行。
WITH CTE AS ( SELECT *, ROW_NUMBER() OVER(PARTITION BY name, class ORDER BY id) AS rn FROM ceshi ) DELETE FROM ceshi WHERE id IN (SELECT id FROM CTE WHERE rn &gt; 1); 请根据实际情况调整上述SQL语句中的表名、列名以及决定保留哪条记录的逻辑。在执行任何删除操作之前，强烈建议先备份数据，以防数据丢失。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c9a8d560446b71cc61f5b1bf917614/" rel="bookmark">
			崔喵历险记之MySQL梦境世界（第一章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回游戏主界面：个人主页 呼.......哈........呼.......噜~~~~~⚠崔喵睡着了！！！
目录
引言：
新手教程：
1.数据库的操作
1.1显示当前的数据库
1.3使用数据库
1.4删除数据库
2.常用数据类型
2.1数值类型：
2.2字符串类型
2.3日期类型
3.表的操作
3.1显示当前的表
3.2 创建表
3.3注释
3.4查看表
3.5删除表
3.6新增表
3.7查看表的内容
虚拟练习室
1.第一关
2.第二关
3.第三关
4.崔喵攻略
引言 你成功来到崔喵的梦境世界，别看了这个游戏是没有登出按钮的，只有通关游戏才能逃离梦境世界。我可没有坑你，（好吧是有点坑你），作为新手奖励丢给你一只崔喵向导，它会带着你学习在前几层的梦境世界冒险，崔喵会帮助你打开新手教程，不要小看它好吗？是吧，崔喵。喵呜~~~。
新手教程 使用指南：帮助玩家学习新技能，你将会学习的技能是: 数据库的操作,常用数据类型,表的操作,
通过第一次新手教程之后，第二次的新手教程可以提升技能的技能点！
所以崔喵什么是数据库？数据库是用来干什么的？你咋啥都不知道？？？喵！！
1.数据库的操作 1.1显示当前的数据库 show databases; 1.2创建数据库
create database 数据库名; eg1：create database test; //说明：当我们创建数据库没有指定字符集和校验规则时，系统使用默认字符集：utf8，校验规则 是：utf8_ general_ ci。 //说明：如果系统没有test的数据库 ，则可以创建一个名test数据库，如果有则不会创建。 1.3使用数据库 use 数据库名; 1.4删除数据库 drop 数据库名; 说明:数据库删除以后，内部看不到对应的数据库，里边的表和数据全部被删除。 2.常用数据类型 2.1数值类型： 整型&amp;浮点型
2.2字符串类型 2.3日期类型 3.表的操作 需要操作数据库中的表时，首先要使用该数据库：
引用：eg1：create database test;
3.1显示当前的表 show tables; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6c9a8d560446b71cc61f5b1bf917614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9d20fbb859d8156a41627ebae81393/" rel="bookmark">
			python代码实现及Logistic回归（逻辑回归）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 逻辑回归是机器学习中非常重要的一种统计方法，广泛用于分类问题。尽管名为“回归”，逻辑回归实际上是用来做二分类的工具，例如判断邮件是否为垃圾邮件，或者一个患者是否有某种疾病。逻辑回归的优点在于它的输出可以被解释为概率，这为决策提供了便利，而且它相对简单，易于实现，是初学者入门机器学习的良好起点。
目标 本文将全面解析逻辑回归模型，包括它的结构、学习目标、优化算法，以及如何使用 Python 进行实现。读者将从基本的数学原理了解到如何在实际数据集上应用逻辑回归，最终能够自己动手编写代码，建立并优化逻辑回归模型。文章的结构清晰，旨在帮助刚接触人工智能的大学新生，理解并掌握逻辑回归的核心概念和应用。
一、逻辑回归模型结构 1.1 基本概念 模型定义
逻辑回归（Logistic Regression，简称 LR）是一种广义线性模型（GLM），通常用于分类问题。与传统的线性回归模型（预测连续值输出）不同，逻辑回归预测的是一个概率值，表示为介于 0 和 1 之间的数。这使得它非常适合于二分类问题，比如预测一个电子邮件是不是垃圾邮件。
模型功能
逻辑回归通过输入特征的加权和，使用 sigmoid 函数将任意实数映射到 (0, 1) 区间，输出一个概率值。Sigmoid 函数的 S 形曲线确保了输出值在 0 到 1 之间，这个值表示样本属于正类（通常编码为 1）的概率。
决策边界
逻辑回归模型的决策边界是功能的关键，这是一个用来决定样本分类的边界。在逻辑回归中，这个边界是线性的，意味着它可以用一条直线（或者在多维空间中是一个超平面）来表示。当逻辑回归模型的输出（概率）等于 0.5 时，对应的输入特征组合就位于这条决策边界上。
1.2 数学表达 逻辑回归的数学基础非常重要，理解它有助于深入掌握模型的工作原理。模型本质上是一个概率估计，通过最大似然估计（MLE）来优化参数。公式表达为：
其中 ( p ) 是给定输入特征 ( x ) 下样本属于正类的概率，( w ) 表示模型参数。
逻辑回归的目标是调整 ( w ) 的值，使得模型的预测尽可能接近实际的标签。
二、学习目标和损失函数 2.1 理解分类目标 预测和实际的对比
在使用逻辑回归进行分类时，核心目标是确保模型的预测概率尽可能接近实际的标签。例如，如果一个样本的实际标签是 1（正类），逻辑回归模型预测这个样本属于正类的概率应该接近 1。相反，如果样本的标签是 0（负类），则模型的预测概率应接近 0。这种方式帮助我们评价和优化模型的性能，确保模型能够正确区分不同类别的样本。
2.2 最大似然估计 最大似然估计（MLE）是一种在统计模型中估计参数的方法，它寻找能够使观测到的数据出现概率最大的参数值。在逻辑回归中，MLE尝试找到一组参数，使得给定参数下，观测到的样本标签的概率最大化。这通常通过优化一个称为似然函数的表达式来实现，该函数是对所有数据点的预测概率的乘积。
2.3 交叉熵损失 交叉熵损失函数解释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da9d20fbb859d8156a41627ebae81393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334081a1c03f17989dd1f522cb7cf00c/" rel="bookmark">
			Python Web部署方式全汇总_python部署成web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末有福利领取哦~ 👉一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
👉二、Python必备开发工具
👉三、Python视频合集
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉 四、实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。（文末领读者福利）
👉五、Python练习题
检查学习结果。
👉六、面试资料
我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
👉因篇幅有限，仅展示部分资料，这份完整版的Python全套学习资料已经上传
网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化学习资料的朋友，可以戳这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over特性等等。FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。
FastCGI的工作流程:
Web Server启动时载入FastCGI进程管理器（PHP-CGI或者PHP-FPM或者spawn-cgi)FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出。 FastCGI 的特点：
打破传统页面处理技术。传统的页面处理技术，程序必须与 Web 服务器或 Application 服务器处于同一台服务器中。这种历史已经早N年被FastCGI技术所打破，FastCGI技术的应用程序可以被安装在服务器群中的任何一台服务器，而通过 TCP/IP 协议与 Web 服务器通讯，这样做既适合开发大型分布式 Web 群，也适合高效数据库控制。明确的请求模式。CGI 技术没有一个明确的角色，在 FastCGI 程序中，程序被赋予明确的角色（响应器角色、认证器角色、过滤器角色）。 WSGI： Python Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。WSGI是作为Web服务器与Web应用程序或应用框架之间的一种低级别的接口，以提升可移植Web应用开发的共同点。WSGI是基于现存的CGI标准而设计的。
WSGI区分为两个部份：一为“服务器”或“网关”，另一为“应用程序”或“应用框架”。在处理一个WSGI请求时，服务器会为应用程序提供环境上下文及一个回调函数（Callback Function）。当应用程序完成处理请求后，透过先前的回调函数，将结果回传给服务器。所谓的 WSGI 中间件同时实现了API的两方，因此可以在WSGI服务和WSGI应用之间起调解作用：从WSGI服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。“中间件”组件可以执行以下功能：
重写环境变量后，根据目标URL，将请求消息路由到不同的应用对象。允许在一个进程中同时运行多个应用程序或应用框架。负载均衡和远程处理，通过在网络上转发请求和响应消息。进行内容后处理，例如应用XSLT样式表。 以前，如何选择合适的Web应用程序框架成为困扰Python初学者的一个问题，这是因为，一般而言，Web应用框架的选择将限制可用的Web服务器的选择，反之亦然。那时的Python应用程序通常是为CGI，FastCGI，mod_python中的一个而设计，甚至是为特定Web服务器的自定义的API接口而设计的。WSGI没有官方的实现, 因为WSGI更像一个协议。只要遵照这些协议,WSGI应用(Application)都可以在任何服务器(Server)上运行, 反之亦然。WSGI就是Python的CGI包装，相对于Fastcgi是PHP的CGI包装。
WSGI将 web 组件分为三类： web服务器，web中间件,web应用程序， wsgi基本处理模式为 ： WSGI Server -&gt; (WSGI Middleware)* -&gt; WSGI Application 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/334081a1c03f17989dd1f522cb7cf00c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb659799af68f18440aaa3a44f9fc4dc/" rel="bookmark">
			AI绘画保姆级教程 | 比Remini更好的黏土风格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文教程：https://docs.loopin.network/zh/tutorials/stablediffusion/comfyui-how-to-implement-clay-style-filters
Comfy UI 是一种节点化操作界面，它比其他WebUI更容易操作和微调，很适合复现和调整图像效果。通过熟练使用，还可以定制工作流程。
🚀 新功能！ 想先体验一下？试试我们的AI粘土风格滤镜&amp;nbsp;👉&amp;nbsp;&amp;nbsp;https://docs.loopin.network/playground/comfyui-clay-demo
什么是Comfy UI？
Comfy UI 是基于节点的操作界面，很适用于Stable Diffusion XL 1.0模型。你可以直观地看到不同模型（如Base模型、Refiner精炼模型）生成的效果图。其高可控性让你能轻松复现和微调图像效果，熟练之后还能定制个人工作流。
如何在LooPIN上安装Comfy UI
1. 配置GPU实例
访问 LooPIN流动性池，使用$LOOPIN代币购买GPU时间。选择合适的GPU型号，如RTX 3080。
2. 兑换GPU资源
选择需要的$LOOPIN代币数量，通过滑块选择GPU数量，确认并完成交易。
3. 进入Jupyter Notebook
交易成功后，进入Rented Servers的Server区域，访问你的远程服务器，启动Jupyter Notebook（一般需2-4分钟）。
4. 验证GPU
在Jupyter Notebook中，打开终端窗口，运行nvidia-smi命令检查GPU是否已激活。
+-----------------------------------------------------------------------------------------+
| NVIDIA-SMI 550.54.15 Driver Version: 550.54.15 CUDA Version: 12.4 |
|-----------------------------------------+------------------------+----------------------+
| GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC |
| Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb659799af68f18440aaa3a44f9fc4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7465573e7b9dc9c583a85339197bcf68/" rel="bookmark">
			【数据结构】这里有一份KMP算法优化的详细攻略，不要错过哦！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KMP算法优化 导读一、C语言实现next数组1.1 next数组的底层逻辑1.2 串的数据类型的选择1.3 函数三要素1.3.1 查漏补缺——数组传参1.3.2 小结 1.4 函数主体1.4.1 通过模拟实现1.4.1.1 算法思路1.4.1.2 代码实现1.4.1.3 算法测试 1.4.2 算法的缺陷1.4.3 算法优化1.4.3.1 算法思路1.4.3.2 代码实现1.4.3.3 算法测试 二、`KMP`算法的进一步优化2.1 `KMP`算法存在的缺陷2.2 `nextval`数组 三、KMP算法测试四、模式匹配算法的对比五、算法的C语言函数接口总结 导读 大家好，很高兴又和大家见面啦！！！
在上一篇内容中我们详细介绍了KMP算法的基础知识点，相信大家在阅读完后应该对前缀、后缀、PM值、next数组这些基本概念有了一个初步的了解。但是在上一篇内容中我们对KMP算法的介绍还不够完整，遗留下来了两个问题：
next数组的代码实现KMP算法的缺陷优化 在今天的内容中，我们将会围绕这两个问题，进一步的对KMP算法进行深入探讨。相信大家都很期待今天的内容了，下面我们就进入正题吧！！！
一、C语言实现next数组 在求解next数组之前，我们先思考一个问题——对于不同的模式串，当首字符失配时，会不会有不同的处理方式？
这个问题的答案显然是不会。对于任意长度为 n ( n &gt; = 1 ) n(n&gt;=1) n(n&gt;=1) 模式串，不管模式串怎么改变，只要首元素失配，那我们在下一次进行匹配时肯定是将模式串向右移动1位，因此，首元素失配时对应的next[j]肯定是 j − 1 j-1 j−1。
！！！注意这里的j指的是元素在字符串中对应的数组下标。
也就是说当采用的存储方式是数组下标 = 位序 - 1时，那首元素的next[j]中j = 0，对应的值就为-1；
当采用的存储方式是数组下标 = 位序时，那首元素的next[j]中j = 1，对应的值就为0.
同样的对于任意长度为 n ( n &gt; = 2 ) n(n&gt;=2) n(n&gt;=2) 的模式串，不管模式串怎么改变，当第二个字符失配时，在下一次匹配时肯定是将首元素与主串中当前失配元素进行匹配，因此第二个元素失配时对应的next[j]同样也是是 j − 1 j-1 j−1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7465573e7b9dc9c583a85339197bcf68/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/359/">«</a>
	<span class="pagination__item pagination__item--current">360/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/361/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>