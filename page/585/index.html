<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff15d7e2fa2b3b7666f859c3abd3687/" rel="bookmark">
			H5（uniapp）跳转至小程序页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前场景：需要在H5页面点击跳转至微信小程序页面
主要参考方法：1、获取接口调用凭据 | 微信开放文档
2、获取scheme码 | 微信开放文档
需要解决的主要问题:
在对微信文档中的API接口进行调用的时候，不可避免的会出现跨域的问题,那么就需要在uniapp项目中对跨域进行处理，主要更改manifest.json下的h5进行配置：
"h5" : { ..... "devServer": { "proxy": {//配置代理服务器来解决跨域问题，uniapp不适用CORS方案和设置JSONP方案 "/api/": {//映射域名 "target": "https://api.weixin.qq.com", "pathRewrite": { "^/api": "" } } } }, .... } 这样跨域问题就解决了，在请求API时就不需要对请求头进行跨域处理了。
主要步骤：(简单示例)
&lt;template&gt; &lt;view&gt; &lt;uni-link href="weiwx:xxxxxxxxx" text="跳转至小程序"&gt;&lt;/uni-link&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{} }, onLoad() { this.getToken() }, methods:{ getToken(){ uni.request({ url: "/api/cgi-bin/token", method: 'GET', data: { "grant_type": "client_credential", "appid": "小程序唯一凭证，即 AppID", "secret": "小程序唯一凭证密钥，即 AppSecret" }, success: res =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff15d7e2fa2b3b7666f859c3abd3687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add75df695a5b06af82bf7d68790d1d2/" rel="bookmark">
			前端：纯css实现图片轮播（自动&#43;手动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.图片自动轮播
2.图片手动轮播
3.补充内容
1.图片自动轮播 创建2个盒子，一个盒子进行轮播图展示，一个盒子用来承载图片
&lt;body&gt; &lt;!-- 创建外部展示容器 --&gt; &lt;div class="banner-container"&gt; &lt;!-- 创建图片储存容器 --&gt; &lt;div class="banner-img-container"&gt; &lt;img src="./img/banner01.png" alt=""&gt; &lt;img src="./img/banner02.png" alt=""&gt; &lt;img src="./img/banner03.png" alt=""&gt; &lt;img src="./img/banner04.png" alt=""&gt; &lt;img src="./img/banner05.png" alt=""&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; CSS重置reset.css &amp; normalize.css，在写页面时，由于HTML标签自带一些CSS属性，导致在调试样式的时候会出现各种奇怪的问题，为了大概率避免这些问题，在写CSS之前可以引用一下代码。
html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } autoMatic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add75df695a5b06af82bf7d68790d1d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69bf400843016deaaecb6159eb0920a/" rel="bookmark">
			数据结构——【堆】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、堆的相关概念 1.1、堆的概念 1、堆在逻辑上是一颗完全二叉树（类似于一颗满二叉树只缺了右下角）。
2、堆的实现利用的是数组，我们通常会利用动态数组来存放元素，这样可以快速拓容也不会很浪费空间，我们是将这颗完全二叉树用层序遍历的方式储存在数组里的。
3、堆有两种分别是大根堆和小根堆 。
1.2、堆的分类 1.2.1、大根堆 大根堆就是整个完全二叉树，任意一个根节点的值都比左右子树的值大 这就是一个大根堆，所有根节点的值永远比左右子树的大，那么就可以看出，整棵树的根节点，他的值是整个堆中最大的。同时我们也发现没有直接父子关系的节点他们的值没有完全地关系，就像第二层的33和第三层的45以及20，没有规定第三层的元素值必须小于第二层，只要满足根节点比自己左右子树节点的值大即可。
1.2.3、小根堆 小根堆表示整个完全二叉树，任意一个根节点的值都比左右子树的值小。
以上就是一个简单地小根堆它的定义与大根堆相似，只是跟节点的值小于自己的左右节点的值，同时小根堆的层与层之间没有直接关系的节点的值也没有必然的大小关系。
1.3、堆的结构 堆的逻辑结构是一颗完全二叉树
堆的物理结构是一个数组
我们可以用左右孩子节点和父节点，来表示所有的节点。
leftchild = parent * 2 + 1;
rightchild = parent * 2 + 2;
parent = (child - 1) / 2;(child可以是左孩子,也可以是右孩子)
如下图：是一个大根堆，父节点的值都大于子节点的值。
在数组中存储的是：
109 865743 二、堆的实现 2.1、堆的功能 我们是以顺序表的形式实现的堆，其中基本的操作和顺序表的操作是大致一样的。
下面是我们要实现的堆的一些基础功能
#pragma once #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; typedef int HPDataType; typedef struct Heap { HPDataType* a; int size; int capacity; }Heap; //堆的初始化 void HeapInit(Heap* hp); // 堆的构建 void HeapCreate(Heap* hp, HPDataType* a, int n); // 堆的销毁 void HeapDestory(Heap* hp); // 堆的插入 void HeapPush(Heap* hp, HPDataType x); // 堆的删除 void HeapPop(Heap* hp); // 取堆顶的数据 HPDataType HeapTop(Heap* hp); // 堆的数据个数 int HeapSize(Heap* hp); // 堆的判空 int HeapEmpty(Heap* hp); //打印堆 void HeapPrint(Heap* hp); //交换函数 void Swap(HPDataType* p1, HPDataType* p2); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f69bf400843016deaaecb6159eb0920a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2379075489ee64a81adcb3b24f036a6b/" rel="bookmark">
			C&#43;&#43; 中的原子变量（std::atomic）使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 C++ 中的原子变量（std::atomic）使用指南基本概念使用方法创建原子变量读取值修改值原子操作 常见应用场景1. 计数器2. 控制标志3. 链表和数据结构 示例代码结论 C++ 中的原子变量（std::atomic）使用指南 原子变量（std::atomic）是C++中用于多线程编程的强大工具之一。它们提供了一种线程安全的方式来访问和修改共享数据，而无需使用显式的互斥锁。本文将介绍std::atomic的基本概念、使用方法、常见应用场景以及示例代码，适合入门级读者。
基本概念 原子变量是一种特殊的数据类型，用于执行原子操作。原子操作是不可分割的操作，可以确保在多线程环境中线程安全地执行。C++中的std::atomic提供了对原子操作的支持。
std::atomic支持各种数据类型，如整数、布尔值、指针等。您可以创建std::atomic对象，并使用原子操作来读取和修改它们的值。
使用方法 创建原子变量 要创建一个std::atomic变量，只需在变量类型前加上std::atomic，然后初始化它：
std::atomic&lt;int&gt; atomicInt(0); std::atomic&lt;bool&gt; atomicBool(true); 读取值 要读取std::atomic变量的值，可以使用load函数：
int value = atomicInt.load(); bool flag = atomicBool.load(); 修改值 要修改std::atomic变量的值，可以使用store函数：
atomicInt.store(42); atomicBool.store(false); 原子操作 std::atomic提供了一系列的原子操作函数，如exchange、compare_exchange_weak、compare_exchange_strong、fetch_add、fetch_sub等，用于执行各种原子操作。
下面是一个示例，演示了如何使用fetch_add来执行原子的加法操作：
std::atomic&lt;int&gt; atomicValue(0); int increment = 5; int result = atomicValue.fetch_add(increment); 常见应用场景 1. 计数器 原子变量在实现计数器时非常有用，特别是在多线程环境中。您可以使用fetch_add和fetch_sub来安全地增加和减少计数器的值。
std::atomic&lt;int&gt; counter(0); // 线程1增加计数器 counter.fetch_add(1); // 线程2减少计数器 counter.fetch_sub(1); 2. 控制标志 std::atomic&lt;bool&gt; 变量常用于控制线程的启动和停止。您可以使用load和store来读取和修改标志的状态。
std::atomic&lt;bool&gt; flag(true); // 线程1检查标志 if (flag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2379075489ee64a81adcb3b24f036a6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc24d5ab4c7c5db387188abda96a450/" rel="bookmark">
			【JAVA】String类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：paper jie_的博客
本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。
本文录入于《JAVASE语法系列》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。
其他专栏：《JAVA》《算法详解》《C语言》等
内容分享：本期将会对JAVA中的String类进行分享
目录
String类的引出
String类的常用方法
字符串构造
String对象的比较
比较是否引用的是同一个对象
boolean aquals（Object o）比较方法：按照字典序比较
int compareTo(String s)方法：按照字典序进行比较
字符串查找
转换
数值与字符串转换
大小写转换
字符串与数组转换
格式化
字符串替换
字符串拆分
字符串截取
去处空格
字符串的不可变性
String设计成不可变的原因
字符串的修改
StringBuilder和StringBuffer
String，StringBuilder，StringBuffer的区别
String类的引出 C语言中，我们发现里面是没有字符串类型的，要想表达字符串只能通过字符数组或者字符指针，可以用它的标准库提供的字符串函数完成操作，但是这种将数据和操作数据方法分离的方式它不符合面向对象的思想，因此java中专门提供了String类。
String类的常用方法 字符串构造 String类提供的构造方法一般有三种：
public class Test { public static void main(String[] args) { //使用常量串构造 String s1 = "hello word"; System.out.println(s1); //直接new一个String对象 String s2 = new String("hello word"); System.out.println(s2); //使用字符数组进行构造 char[] array = {'h','e','l','l','0'}; String s3 = new String(array); } } 这里要注意一个地方：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cc24d5ab4c7c5db387188abda96a450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/894a7d88a1e82fc7dbe0ae01a7d0fa6f/" rel="bookmark">
			【Java 基础篇】Java HashSet 集合详解：高效存储唯一元素的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中的集合框架提供了各种各样的数据结构，用于存储和操作数据。其中，HashSet 是一种常用的集合类，它实现了 Set 接口，用于存储不重复的元素。本篇博客将详细介绍 HashSet 的基本概念、创建和初始化、基本操作、遍历、性能考虑、使用注意事项以及示例代码。无论您是初学者还是有经验的开发者，都可以通过本文的学习来掌握 HashSet 的使用。
1. 什么是 HashSet？ HashSet 是 Java 中的一个集合类，它实现了 Set 接口。Set 是一种不允许包含重复元素的集合，而 HashSet 则是 Set 接口的一个具体实现。因此，HashSet 用于存储一组唯一的元素，不允许重复。
以下是 HashSet 的一些特点：
不允许重复元素：如果试图向 HashSet 中添加重复的元素，重复元素将被忽略。无序性：HashSet 不保证元素的顺序，元素在 HashSet 中是无序的。允许 null 元素：HashSet 可以包含一个 null 元素。 2. 创建和初始化 HashSet 要使用 HashSet，首先需要创建一个 HashSet 对象。可以使用以下方式进行创建和初始化：
2.1 创建空的 HashSet Set&lt;String&gt; set = new HashSet&lt;&gt;(); 上述代码创建了一个空的 HashSet 对象，用于存储字符串类型的元素。您可以根据需要选择不同的数据类型。
2.2 创建包含元素的 HashSet Set&lt;Integer&gt; numbers = new HashSet&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5)); 上述代码创建了一个包含整数元素的 HashSet，并初始化了一组元素。使用 Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/894a7d88a1e82fc7dbe0ae01a7d0fa6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd8dc5964e8224c26b116132d681bfe2/" rel="bookmark">
			Web Component -- 即将爆发的原生的 UI 组件化标准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web Component 概述 Web Component 是一种用于构建可复用用户界面组件的技术，开发者可以创建自定义的 HTML 标签，并将其封装为包含逻辑和样式的独立组件，从而在任何 Web 应用中重复使用。
每个 Web Component 都具有自己的 DOM 和样式隔离，避免了全局 CSS 和 JavaScript 的冲突问题。它还支持自定义事件和属性，可以与其他组件进行通信和交互。
不同于 Vue/React 等社区或厂商的组件化开发方案，Web Component 被定义在标准的 HTML 和 DOM 标准中。它由一组相关的 Web 平台 API 组成，也可以与现有的前端框架和库配合使用。
Web Component 的兼容性良好，可以在现代浏览器中直接使用，也可以通过 polyfill 兼容到旧版浏览器（IE11 理论上可以兼容，出于初步调研的考虑，本文不对兼容性作过多探讨）。
同类组件化方案比较 Pros技术Cons可以异构Micro Frontend需要主应用、对子应用有侵入、样式统一困难模块级的多项目在运行时共享Module Federation主要依赖webpack5，既有项目改造成本未知；实现异构引用需要借助其他插件模块级动态共享Vue :is + 动态import依赖vue技术栈可以异构、完全解耦、对原有开发方法改造极小Web CompnentIE兼容性仅11可通过Polyfill支持 TL;DR 实例：用异构系统共建 web components
https://gitee.com/tonylua/web-component-test1/tree/master
Web Component 关键特性 Custom Elements（自定义元素） 是 Web 标准中的一项功能，它允许开发者自定义新的 HTML 元素，开发者可以使用 JavaScript 和 DOM API，使新元素具有自定义的行为和功能
4.13.1.1 Creating an autonomous custom element This section is non-normative.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd8dc5964e8224c26b116132d681bfe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a7bfaed61b1931d2c29925b315d52b2/" rel="bookmark">
			动态规划入门：斐波那契数列模型以及多状态（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		斐波那契数列模型以及多状态 动态规划简述斐波那契数列模型1.第 N 个泰波那契数（简单）2.三步问题（简单）3.使⽤最⼩花费爬楼梯（简单）4.解码方法（中等） 简单多状态1.打家劫舍（中等）2.打家劫舍II（中等）3.粉刷房子（中等）4.删除并获得点数（中等）5.买卖股票的最佳时期含⼿续费（中等）6.买卖股票的最佳时机含冷冻期（中等）7.买卖股票的最佳时机III（困难）8.买卖股票的最佳时机IV（困难） 动态规划简述 动态规划(Dynamic programming，简称 DP)是一种解决多阶段决策问题的算法思想。它将问题分解为多个阶段，并通过保存中间结果来避免重复计算，从而提高效率。
动态规划的解题步骤一般分为以下几步：
思考状态表示，创建dp表(重点)分析出状态转移方程(重点)初始化确定填表顺序确定返回值 斐波那契数列模型 1.第 N 个泰波那契数（简单） 链接：第 N 个泰波那契数
题目描述 做题步骤 状态表示 面对动态规划问题，我们一般有两种状态表示：
以某一个位置为起点，……以某一个位置为终点，…… 我们一般优先考虑第1种表示，但如果第1种无法解决就考虑第2种。
状态转移方程
这个题目直接告诉了我们状态转移方程：dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
初始化
泰波那契数的第0、1、2个是特殊的，不满足状态转移方程，因此我们需要初始化这三个位置为0、1、1
填表顺序
保证填当前状态时，所需状态已经计算过，填表顺序很明显是从左往右
返回值
根据状态表示，假设要求的是第n个，返回的应该是dp[n]
代码实现 class Solution { public: int tribonacci(int n) { //对于第0、1、2单独处理 if(n == 0) return 0; if(n == 1 || n == 2) return 1; //dp[i]：第i个泰波那契数 vector&lt;int&gt; dp(n + 1); dp[0] = 0; dp[1] = 1; dp[2] = 1; for(int i = 3; i &lt; n + 1; i++) { dp[i] = dp[i-1] + dp[i-2] + dp[i-3]; } return dp[n]; //空间复杂度：O(N) //时间复杂度：O(N) } }; //不知道大家有没有发现向后填表的过程其实只需要前置的3个状态 //其余的状态都是多余的，我们可以用有限的变量来保存这些状态，这样就实现了空间优化 //这种优化方式被称为“滚动数组” //经过优化原O(N)-&gt;O(1) O(N^2)-&gt;O(N) //但这并不是动态规划讲解的要点，所以我只会把两种优化情况的代码给出 // class Solution { // public: // int tribonacci(int n) // { // if(n == 0) // return 0; // if(n == 1 || n == 2) // return 1; // int t1 = 0; // int t2 = 1; // int t3 = 1; // int ret = 0; // for(int i = 3; i &lt; n + 1; i++) // { // ret = t1 + t2 + t3; // t1 = t2; // t2 = t3; // t3 = ret; // } // return ret; // } // }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a7bfaed61b1931d2c29925b315d52b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccaab03f9973338d5a971b924ae63d3/" rel="bookmark">
			解决Tomcat异常:java.lang.IllegalStateException: 非法访问：此Web应用程序实例已停止。无法加载。为了调试以及终止导致非法访问的线程，将抛出以下堆栈跟踪。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调试项目的时候发现每次使用idea重新部署项目时会出现这个错误，但是不影响实际使用，重启服务器第一次部署时也不会出现错误，尝试搜索解决这个问题。
解决方法：
进入tomcat目录下查找配置文件，conf &gt; Context.xml，查找Context标签，修改属性reloadble为 reloadable=“false” (如果没有reloadable属性，就自己创建一个)
&lt;Context reloadable="false"&gt; &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;${catalina.base}/conf/web.xml&lt;/WatchedResource&gt; &lt;Manager pathname="SESSIONS.ser" /&gt; &lt;/Context&gt; reloadable的功能：如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用 ，也就是热部署。 有助于调试servlet和其它的class文件，但这样用加重服务器运行负荷，建议在Web应用的发存阶段将reloadable设为false。
后续问题:
如果reloadable变为false后依然有一个报错:
意思是注册过jdbc驱动，在容器关闭时没有注销，并且是在AbandonedConnectionCleanupThread线程中。 所以为了内存避免泄露，就强制注销了驱动。
解决方法:
写一个容器监听器，在容器销毁时注销AbandonedConnectionCleanupThread。
网上的查找到的监听器代码是基于旧版驱动的，我修改了一个新版本的，记得在配置中添加对应的包扫描
import com.mysql.cj.jdbc.AbandonedConnectionCleanupThread; import jakarta.servlet.ServletContextEvent; import jakarta.servlet.ServletContextListener; import jakarta.servlet.annotation.WebListener; import java.sql.Driver; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Enumeration; @WebListener public class MyContextListener implements ServletContextListener { //注销驱动,防止服务器重新部署时jdbc报错 @Override public void contextDestroyed(ServletContextEvent sce) { Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers(); while (drivers.hasMoreElements()) { try { DriverManager.deregisterDriver(drivers.nextElement()); } catch (SQLException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fccaab03f9973338d5a971b924ae63d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b3e1c980936bd7babedf72bc6f5e4f/" rel="bookmark">
			【算法训练营】贪心算法专题(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🕺作者： 主页
我的专栏C语言从0到1探秘C++数据结构从0到1探秘Linux菜鸟刷题集 😘欢迎关注：👍点赞🙌收藏✍️留言
🏇码字不易，你的👍点赞🙌收藏❤️关注对我真的很重要，有问题可在评论区提出，感谢阅读！！！
前言 这篇都是关于贪心算法的OJ题，但是并不只有这一种方法，但在本篇中只写出贪心的解法，标题下面都有超链接，可以同时过去写题哦~
之后还会更新相关专题的，敬请期待！！
算法解释
顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。
举一个最简单的例子：小明和小王喜欢吃苹果，小明可以吃五个，小王可以吃三个。已知苹果园里有吃不完的苹果，求小明和小王一共最多吃多少个苹果。在这个例子中，我们可以选用的贪心策略为，每个人吃自己能吃的最多数量的苹果，这在每个人身上都是局部最优的。又因为全局结果是局部结果的简单求和，且局部结果互不相干，因此局部最优的策略也同样是全局最优的策略。
📍455. 分发饼干 链接：455. 分发饼干
解题思路 因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。
简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。
至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。
注意：对数组或字符串排序是常见的操作，方便之后的大小比较。
注意：在之后的讲解中，若我们谈论的是对连续空间的变量进行操作，我们并不会明确区分数组和字符串，因为它们本质上都是在连续空间上的有序变量集合。一个字符串“abc”可以被看作一个数组 [‘a’,‘b’,‘c’]。
AC代码 class Solution { public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(),g.end()); sort(s.begin(),s.end()); int child=0,cookie=0; while(child&lt;g.size()&amp;&amp;cookie&lt;s.size()) { if(g[child] &lt;= s[cookie]) ++child; ++cookie; } return child; } }; 📍435. 无重叠区间 链接：435. 无重叠区间
解题思路 在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。
具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选择的区间不重叠的区间。我们这里使用 C++ 的 Lambda，结合 std::sort() 函数进行自定义排序。
在样例中，排序后的数组为 [[1,2], [1,3], [2,4]]。按照我们的贪心策略，首先初始化为区间[1,2]；由于 [1,3] 与 [1,2] 相交，我们跳过该区间；由于 [2,4] 与 [1,2] 不相交，我们将其保留。因此最终保留的区间为 [[1,2], [2,4]]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b3e1c980936bd7babedf72bc6f5e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db41cb115f993b5e4d371815354b109/" rel="bookmark">
			如何把RabbitMQ完全卸载干净?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想必大家在安装与卸载软件的时候，都踩过不少的坑？那么如何完全卸载RabbitMQ？
1.打开控制面板，找到RabbitMQ server,右键单击RabbitMQ Server 卸载。
2.在控制面板的当前安装程序列表中找到 Erlang OTP 右键单击 卸载。
3. 在任务管理器中，找到epmd.exe，看进程是否还在运行，右键结束进程。
4.删除所有RabbitMQ和Erlang的文件夹与安装目录。
5.删除C:\Windows\System32\config\systemprofile\.erlang.exe文件。
6.删除C:\Users\[UserName]\.erlang.exe文件([UserName是你的用户名]）。
7.删除C:\Users\[UserName]\AppData\Roaming\RabbitMQ文件。
8打开注册表，找到HKEY_LOCAL_MACHINE下的Ericsson下的Erlang文件夹进行删除。
此时RabbitMQ就完全卸载成功，可以进行重新安装等操作了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7c6c68779124e6ef2d614312a3e3d2/" rel="bookmark">
			在MAC电脑上将NTFS格式移动硬盘转换为ExFAT格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：转化之前先将移动硬盘中的内容进行备份
1、点击桌面上的【前往】，选择【实用工具】
2、在列表中选择【磁盘工具】
3、在左侧选中你的磁盘，点击右侧上方的【抹掉】,注意：将永久抹掉储存在上面的所有数据，因此需要提前备份
4、格式选择ExFAT
5、执行抹掉操作后，再查看移动硬盘的信息，发现格式变为了ExFAT，且硬盘内容全部清空了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ec4ea08a9aae1296973d1458c62dc7/" rel="bookmark">
			【数据结构入门指南】二叉树链式结构的实现（保姆级代码思路解读，非常经典）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构入门指南】二叉树链式结构的实现（保姆级代码思路解读，非常经典） 一、前置说明二、二叉树的遍历2.1前序遍历2.2中序遍历2.3 后序遍历 三、以前序遍历为例，递归图解四、层序遍历五、节点个数以及高度等5.1 二叉树节点个数5.2二叉树叶子节点个数5.3 二叉树第k层节点个数5.4 二叉树查找值为x的节点5.5 二叉树的高度 六、二叉树的创建和销毁6.1 构建二叉树6.2 二叉树的销毁6.3 判断二叉树是否为完全二叉树 一、前置说明 其他数据结构不同，二叉树的增删查改接口实现的意义不大（后续搜索树的增删查改才有意义）。普通初阶二叉树更重要的是学习控制结构，为后续的AVL树、红黑树等高级数据结构打下基础。同时大部分OJ题也出在此处。
二、二叉树的遍历 所谓二叉树遍历(Traversal)是按照某种特定的规则，依次对二叉树中的节点进行相应的操作，并且每个节点只操作一次。访问结点所做的操作依赖于具体的应用问题。
按照规则，二叉树的遍历有：前序/中序/后序的递归结构遍历：
前序遍历(Preorder Traversal 亦称先序遍历)——访问顺序：根节点—&gt;左子树—&gt;右子树中序遍历(Inorder Traversal)——访问顺序：左子树—&gt;根节点—&gt;右子树后序遍历(Postorder Traversal)——访问顺序：左子树—&gt;右子树—&gt;根节点 2.1前序遍历 【代码思路】:
若二叉树为空，则直接返回。访问根节点。递归遍历左子树，即调用前序遍历函数，传入左子树的根节点。递归遍历右子树，即调用前序遍历函数，传入右子树的根节点 代码：
void PrevOrder(BTNode* root) { if (root == NULL) { printf("NULL "); return; } printf("%d ", root-&gt;data); PrevOrder(root-&gt;left); PrevOrder(root-&gt;right); } 2.2中序遍历 【代码思路】：
首先判断二叉树是否为空，若为空则直接返回。对当前节点的左子树进行中序遍历，即递归调用中序遍历函数。访问当前节点的值。对当前节点的右子树进行中序遍历，即递归调用中序遍历函数。 代码：
void InOrder(BTNode* root) { if (root == NULL) { printf("NULL "); return; } InOrder(root-&gt;left); printf("%d ", root-&gt;data); InOrder(root-&gt;right); } 2.3 后序遍历 【代码思路】：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8ec4ea08a9aae1296973d1458c62dc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d6cd23d7af398b57d11363a257aba3/" rel="bookmark">
			全网最全c&#43;&#43;中的system详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章是二发，做了些微调，感兴趣的朋友可以看原文：C++中的system_一只32汪的博客-CSDN博客
1，简介
system()函数是在C++制作中十分常用，有用的一个函数。
其效果类似于系统中"cmd"控制台和"bat"文件。
通常会在C++字符游戏，和C++整蛊程序中使用。
其形式是以:system("***");呈现。
2，程序中的用法： 1，system("pause");
PAUSE能够暂停文件处理，并显示消息
如下↓
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;"HELLO WORLD\n"; system("pause"); cout&lt;&lt;"给个点赞+关注吧！"; return 0; } 会输出：
再按下任意键后：
2，system("cls");
cls能够清除页面上的文本内容
如下↓
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;"HELLO WORLD\n"; system("pause"); system("cls"); cout&lt;&lt;"给个点赞+关注吧！"; return 0; } 会输出：
再按下任意键后：
可以看到：原来的 消失了（是被清屏了）
这样，我们可以完成一些极其简单的事情：
蓝奏云下载↓
文件（密码321）
csdn资源：
【免费】奇奇怪怪的编年史-二进制新资源-CSDN文库
3，system("color ij");
color能够更换页面上的文本内容颜色
其中"i"为背景色，"j"为前景色
颜色对照表 0黑色8灰色1蓝色9淡蓝色2绿色A淡绿色3淡绿色B淡浅绿色4红色C淡红色5紫色D淡紫色6黄色E淡黄色7白色F亮白色 如下↓
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;"HELLO WORLD\n"; system("pause"); system("cls"); cout&lt;&lt;"给个点赞+关注吧！"; system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d6cd23d7af398b57d11363a257aba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb93307fc73d15b5fd29f2f4b4af9543/" rel="bookmark">
			Hbase解决ERROR: KeeperErrorCode = ConnectionLoss for /hbase/master报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、在单机模式中，要先修改一个文件：/usr/local/hbase/conf/hbase-site.xml
hbase-site.xml内容：
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;file:///usr/local/hbase/hbase-tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 保存运行
start-hbase.sh hbase shell 报错
报错原因：可能是因为之前启动过hadoop，然后里面/usr/local/hbase/hbase-tmp有hbase.id不一致的原因导致的
解决办法：将之前的hbase-site.xml的内容修改为
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;file:///usr/local/hbase/hbase-tmp1&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 成功运行
hbase基础命令
#创建表: create '表名','字段1','字段n' #查看数据库中已创建的表 list #添加数据 put 'student','95011',Sname','Li' #查看数据 get 'student','95011' #查看全部数据 scan 'student #删除数据（删除学号为95001的所有Sname字段 delete 'student','95001','Sname' #删除表:第一步，让表不可用，第二步，删除 disable 'student' drop 'student' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06181eb25eadec9e15646b6c744ec59/" rel="bookmark">
			【C&#43;&#43; • STL • 力扣】详解string相关OJ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、仅仅翻转字母2、字符串中的第一个唯一字符3、字符串里最后一个单词的长度4、验证一个字符串是否是回文5、字符串相加总结 ヾ(๑╹◡╹)ﾉ" 人总要为过去的懒惰而付出代价 ヾ(๑╹◡╹)ﾉ"
1、仅仅翻转字母 力扣链接
代码1展示：【下标】
class Solution { bool isLetter(const char&amp; c) { if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return true; else if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return true; else return false; } public: string reverseOnlyLetters(string s) { int left = 0; int right = s.size() - 1; while (left &lt; right) { while (left &lt; right &amp;&amp; !isLetter(s[left])) { left++; } while (left &lt; right &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a06181eb25eadec9e15646b6c744ec59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6e2139d700f5517e0f15591e20c600/" rel="bookmark">
			Bean 的生命周期总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Bean生命周期的五个阶段
Bean的初始化
二、@PostConstruct 和 @PreDestroy 各自的效果
三、 实例化和初始化的区别
四、为什么要先设置属性在进⾏初始化呢？
一、Bean生命周期的五个阶段 Java 中的公共类称之为 Bean 或 Java Bean，而 Spring 中的 Bean 指的是将对象的生命周期，交个 Spring IoC 容器来管理的对象。所以 Spring 中的 Bean 对象在使用时，无需通过 new 来创建对象，只需要通过 DI（依赖注入），从 Spring 中取出要使用的对象即可。
Bean作为一个Java对象，具有一定的生命周期。它的生命周期包括以下几个阶段：
实例化：在Java应用程序中，Bean对象是通过new关键字或者反射机制来实例化的。在这个阶段，Bean对象被创建，并分配了内存空间。设置属性(Bean注入和装配)初始化：当Bean对象被创建后，需要进行初始化，包括设置属性值、执行一些初始化操作等。在Spring框架中，Bean的初始化可以通过配置文件中的init-method属性进行指定。使用：在Bean初始化之后，它就可以被应用程序使用了。在使用过程中，Bean可能会调用其他对象的方法，从而导致其他Bean对象被实例化和初始化。销毁：当Bean对象不再被使用时，应该将其销毁并释放占用的内存空间。在Spring框架中，Bean的销毁可以通过配置文件中的destroy-method属性进行指定。 总的来说，Bean对象的生命周期可以通过实例化、初始化、使用和销毁这几个阶段来描述。在Spring框架中，Bean的生命周期还可以通过BeanPostProcessor接口来进行扩展和定制。
为了便于理解 我们引用一个现实中的事件来形容 Bean 的⽣命流程看似繁琐，但咱们可以以⽣活中的场景来理解它，⽐如我们现在需要买⼀栋房⼦，那么我们的流程是这样的：
1. 先买房（实例化，从⽆到有）；
2. 装修（设置属性）；
3. 买家电，如洗⾐机、冰箱、电视、空调等（[各种]初始化）；
4. ⼊住（使⽤ Bean）；
5. 卖出去（Bean 销毁）。 Bean的初始化 执行各种通知(BeanNameAware、BeanFactoryAware)等接口方法初始化的前置方法(PostConstruct)初始化方法初始化的后置方法(PreDestroy) 下面用代码演示整个Bean的生命周期:
我们用构造方式来展示实例化的效果 ,实例化和属性设置是 Java 级别的系统“事件”，其操作过程不可⼈⼯⼲预和修改 所以下面没有演示设置属性
package com.example.bean.test; import org.springframework.beans.factory.BeanNameAware; import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6e2139d700f5517e0f15591e20c600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011510b018f590e5d7d73fc90309382c/" rel="bookmark">
			SpringBoot&#43;jSerialComm实现Java串口通信 读取串口数据以及发送数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下使用SpringBoot+jSerialComm实现Java串口通信，使用Java语言开发串口，对串口进行读写操作,在win和linux系统都是可以的，有一点好处是不需要导入额外的文件。
案例demo源码：SpringBoot+jSerialComm实现Java串口通信 读取串口数据以及发送数据
之前使用RXTXcomm实现Java串口通信，这种方式对linux(centos)的支持效果不好还有些问题 但在win下面使用还不错，原文地址：SpringBoot+RXTXcomm实现Java串口通信 读取串口数据以及发送数据
不需要额外导入文件 比如dll 只需要导入对应的包
&lt;dependency&gt; &lt;groupId&gt;com.fazecast&lt;/groupId&gt; &lt;artifactId&gt;jSerialComm&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;boot.example.jSerialComm&lt;/groupId&gt; &lt;artifactId&gt;boot-example-jSerialComm-2.0.5&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;boot-example-jSerialComm-2.0.5&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fazecast&lt;/groupId&gt; &lt;artifactId&gt;jSerialComm&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011510b018f590e5d7d73fc90309382c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23690b06edf0bb8fb5142703994d7586/" rel="bookmark">
			BI软件概述以及FineBI安装并连接Hive（包含安装包和插件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
二、FineBI介绍及安装
（1）安装包下载
（2）安装
（3）配置Hive连接驱动
（4）安装插件
（5）新建Hive连接
一、概述 BI：Business Intelligence，商业智能。指用现代数据仓库技术、线上分析处理技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。简单来说，就是借助BI工具，可以完成复杂的数据分析、数据统计等需求，为公司决策带来巨大的价值。
常见BI软件有：
①FineBI
②SuperSet
③PowerBI
④TableAu
二、FineBI介绍及安装 （1）安装包下载 1.百度网盘链接：https://pan.baidu.com/s/1kdhfE270W4D-pBj-t80ypA 提取码：1111 2.官网下载（FineBI）
进入官网免费注册账号即可获取安装包
（2）安装 1.打开安装包
2.点击下一步，选择我接受协议
3.设置安装位置
4.选择给予内存，根据电脑性能而定
5.然后一直点击下一步
6.运行程序，输入在官网注册账号获取的激活码，也可以点击获取激活码
7.设置用户和密码
8.选择Fine BI元数据存储数据库，个人选择内置即可
9.点击登录
（3）配置Hive连接驱动 1.在FineBI安装目录进入FineBI6.0\webapps\webroot\WEB-INF\lib此文件夹
2.粘贴jar包，jar在前面的百度网盘中的Hive连接驱动里
（4）安装插件 ①打开Fine BI管理系统
②打开插件管理
③点击本地安装
④安装插件包（百度网盘链接有）
⑤安装成功后重启程序，重新登录即可。
（5）新建Hive连接 ①打开管理系统
②在数据连接里点击数据连接管理
③选择新建连接
④点击所有，找到Hadoop Hive
⑤填写信息，密码不用填然后点击测试连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b649a72893504941e818c883d639eb/" rel="bookmark">
			【5G】5G 核心网（5GC）基本架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言5G 核心网（5GC）基本架构1. 5GC 的服务化架构（SBA）2. 5G 核心网的十大关键原则3. 不同场景下的网络架构3.1 非漫游参考架构3.2 漫游参考架构3.3 数据存储参考架构3.4 与 EPC 互通参考架构3.5 非 3GPP 接入参考架构 4. 基于服务的接口和参考点4.1 基于服务的接口4.2 参考点 总结 前言 本文旨在科普5G核心网相关知识，参考5G相关书籍《深入浅出：5G 移动通信标准与架构》及3GPP文章。
5G 核心网（5GC）基本架构 1. 5GC 的服务化架构（SBA） 什么是 SBA？就是服务化架构（SBA，Service Based Architecture），5G 核心网的控制面采用服务化架构设计。
初这样说起来可能大家还是不理解，看下图：
与以往有什么不同？以往是层级的拓扑网络结构，节点与节点之间是层级交错的网络关系，而且节点集成度很高，各种功能大包大揽，这样有它的好处，入网简单，但缺点也很明显：扩展性困难、升级困难，所以我们看到以前的核心网扩容，要么加新节点，要么在现有节点上升级，在现有节点上升级风险比较大，升级错误可能造成网络瘫痪，而且，升级只能在原硬件平台上进行。 而 SBA 架构则不同，由于将网络功能（NF）拆分了，而所有的 NF 又都通过接口接入到系统中，这样做得好处：
1、 负荷分担：相同的网络功能（NF）一起来承担和提供网络功能服务（NFS），负荷可以均衡分担。
2、 容灾：任何的网络功能（NF）出现故障，智能化的网络管理可以让它暂时退出服务，将服务转给其它相
同的网络功能（NF）上处理。
3、 扩容简单：只需要增加新的网络功能接入系统即可，丝毫不影响现网运行。
4、 升级容易：都是基于标准接口的接入，无论是硬件还是软件功能，需要推出新一代的，都可以直接接入，
旧的需要淘汰则直接退网。
5、 实现网络的开放能力，在标准接口下，其它系统也可以接入。
借鉴 IT 系统服务化的理念，通过模块化实现网络功能间的解耦和整合，各解耦后的网络功能（服务）可以独立扩容、独立演进、按需部署；各种服务采用服务注册、发现机制，实现了各自网络功能在 5G 核心网中的即插即用、自动化组网；同一服务可以被多种 NF 调用，提升服务的重用性，简化业务流程设计。SBA 设计的目标是以软
件服务重构核心网，实现核心网软件化、灵活化、开放化和智慧化。
SBA 的三大优点：
1、 拆分：网络功能独立，既可以独立自治，又能相互合作分担。
2、 直达：网络功能之间直达，不再需要像拓扑结构一样层级依赖，提高了传输效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48b649a72893504941e818c883d639eb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/584/">«</a>
	<span class="pagination__item pagination__item--current">585/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/586/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>