<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42bd2efbf4aa10ad4befdd0df95ab86e/" rel="bookmark">
			AI模型：windows本地运行下载安装ollama运行llama3、llama2、Google CodeGemma、gemma等可离线运行数据模型【自留记录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI模型：windows本地运行下载安装ollama运行llama3、llama2、Google CodeGemma、gemma等可离线运行数据模型【自留记录】 CodeGemma 没法直接运行，需要中间软件。下载安装ollama后，使用ollama运行CodeGemma等AI模型。
类似 前端本地需要安装 node.js 才可能跑vue、react项目
1、下载 ollama： 官网下载：https://ollama.com/download，很慢，原因不解释。
阿里云盘下载：https://www.alipan.com/s/jiwVVjc7eYb 提取码: ft90
百度云盘下载：https://pan.baidu.com/s/1o1OcY0FkycxMpZ7Ho8_5oA?pwd=8cft 提取码：8cft
2、安装 运行 OllamaSetup.exe ，安装过程不能选择自定义文件夹
3、测试安装是否成功 win + R 输入 cmd ，回车输入：ollama
4、修改模型文件地址 (非必须) ollama模型默认安装地址在C:\Users&lt;用户名&gt;.ollama
因为模型较大，所以我们需要在环境变量内设置模型的安装位置，如下进行设置
变量名： OLLAMA_MODELS
变量值： E:\ollama（根据自己打算存放的地址自行填写）
5、官网下载安装模型 本文依 codegemma为例，如果使用其他模型一样的操作。
选择对应模型
2b： 最低配，有点SB。不智能，不推荐
命令：ollama run codegemma:2b
7b： 内存8G以上，建议16G电脑上这个版本更好一点，碾压2b版本。预计占用1.5G内存，CPU要求高，低压U估计压不住，时间太长
命令：ollama run codegemma:7b
7b全量： 说是更智能，没体验。建议16G或者32G电脑上这个版本，cpu要求更高
命令：ollama run codegemma:7b-code-fp16
带instruct： 能够理解自然语言输入，并根据指令生成相应的代码。
带code： 预训练的模型，专门用于代码补全和根据代码前缀和/或后缀生成代码。
带2b： 最新的预训练模型，提供了最多两倍更快的代码自动补全功能。它的目标是提高代码补全的速度和效率。就是回复的有点拉胯。
点击复制按钮
6、命令行粘贴回车运行 Ctrl + V 即可
输入问答问题即可测试运行
7、API接口调用： 由于实际使用命令行问答很不方便，改造成api调用。都是 POST 接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42bd2efbf4aa10ad4befdd0df95ab86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1dfc2c015421b63619ed4aa8d1b9dc/" rel="bookmark">
			Kimi智能助手：你的全天候AI伙伴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kimi使用链接：
https://kimi.moonshot.cn/
Kimi手机端下载链接：
https://kimi.moonshot.cn/download/app?ref=chat
简介： Kimi AI 是由月之暗面科技有限公司（Moonshot AI）开发的一款人工智能助手，它具备多种功能和优势，旨在为用户提供高效、便捷的辅助工具。在人工智能的浪潮中，Kimi智能助手以其独特的功能和用户友好的设计，成为了人们日常生活中不可或缺的AI工具之一。Kimi不仅是一个信息查询和日常任务管理的工具，还是一个能够提供个性化服务和学习支持的智能伙伴。
常用功能： 语音识别与交互：Kimi能够准确识别用户的语音指令，进行流畅的对话交互。信息搜索与提供：无论是日常知识还是专业信息，Kimi都能快速搜索并提供答案。任务管理：用户可以设置提醒和日程，Kimi会按时提醒，帮助用户管理时间。娱乐互动：Kimi可以播放音乐、讲笑话，甚至进行简单的游戏互动，为用户带来轻松愉快的体验。语言学习：Kimi还能辅助用户学习新语言，提供语言练习和纠正发音的帮助。 技术亮点： 自然语言处理（NLP）：Kimi利用先进的NLP技术，理解用户的自然语言指令和问题。机器学习：通过不断的交互学习，Kimi能够更好地适应每个用户的习惯和偏好。个性化推荐：Kimi能够根据用户的历史行为和偏好提供个性化的内容推荐。 实际应用与影响： Kimi智能助手在提升个人效率、简化日常任务管理、丰富娱乐生活等方面发挥了重要作用。它通过减少用户在信息搜索和日常任务上的时间消耗，让用户有更多时间专注于重要或创造性的工作。同时，Kimi的个性化服务也让用户感受到了科技带来的温暖和便利。
智能搜索与提供 Kimi AI 可以快速访问互联网，结合搜索结果提供用户所需的信息，帮助用户快速获取有价值的数据和知识
支持多种文件格式输入 支持用户上传多种格式的文件，如TXT、PDF、Word文档、PPT幻灯片、Excel电子表格等，方便信息处理和内容生成
支持20W字的超长文本处理能力 Kimi AI 能够处理长达20万字的中文输入，适合阅读和理解长篇文本，如学术论文等
除了核心功能，Kimi智能助手还配备了多种辅助工具，如办公效率优化工具、写作辅助软件、社交娱乐平台和日常生活小工具，这些工具共同作用，旨在提升用户的整体工作效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82fadcc9803c1784a482e377a2a4c4b7/" rel="bookmark">
			OpenAI Whisper 语音转文本实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了实现语音方式与大语言模型的对话，需要使用语音识别（Voice2Text）和语音输出（Text2Voice）。感觉这项技术已比较成熟了，国内也有许多的机构开发这项技术，但是像寻找一个方便测试的技术居然还不容易。Google 墙了，微软需要注册，而国内的资料很少，最后选择了OpenAI 的Whisper。
Whisper 简介 Whisper是OpenAI于2022年12月发布的语音处理系统。它以英语为主，支持99种语言，包括中文。
提供了从tiny到large，从小到大的五种规格模型，适合不同场景。
Large 模型有2.88G，Basic 模型大约几百M。测试下来，Large 模型比较慢，Basic比较快。
Whisper 安装 pip install openai-whisper 安装 ffmpeg whisper 要使用ffmpeg 程序，在windows 的PowerShell 下安装的方式：
choco install ffmpeg 其它一些模块的安装 测试的语音文件 在网络上找中文的语音文件好像不太容易，不是收费，就是文不对题，在github 上找了一个英文的语音样文件。
audio-samples.github.io
Whisper 语音转文本 import whisper print("Start....") whisper_model = whisper.load_model("large") print("Begine...") result = whisper_model.transcribe("E:/yao2024/sample-0.wav",language='en') print(", ".join([i["text"] for i in result["segments"] if i is not None])) 程序运行时要下载相关的模型数据，花费一段时间 Langchain 语音助手 Langchain 有语音助手链，它使用pyttsx3和speech_recognition库分别将文本转换为语音和语音转换为文本。
speech_recognition 是一个语音识别引擎，它可以调用多个语音识别的API ，其中包括:
CMU Sphinx (works offline)
Google Speech Recognition
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82fadcc9803c1784a482e377a2a4c4b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ff9bcea55aeebc2db68105dff356e7b/" rel="bookmark">
			Mac M3 Pro 通过 VMWare Fusion 安装 Windows 11（UUP下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路 一、下载VMWare Fusion并安装 链接: VMWare Fusion 13 WIN11 ARM安装与申请免费序列号办法
二、下载Windows11镜像 三、下载Win11镜像方法二（速度快） 1、Mac 安装 Homebrew
链接：Mac下镜像飞速安装Homebrew教程
2、Mac 安装 并配置 Aria2（下载神器）
下载Aria2
问题：mac下载windows arm镜像，需要在UUP dump通过aria2下载，下载时依赖项brew install sidneys/homebrew/chntpw 执行出现错误chntpw not building，解决办法：
brew tap minacle/chntpw brew install minacle/chntpw/chntpw 配置Aria2
3、通过UUP下载Windows 11(arm64版）iso镜像文件
链接: https://uupdump.net/
四、安装 Windows 11 在 Apple 芯片的 Mac 上通过 VMware Fusion 13 使用 Windows 11
连不上网：按Fn+shift+F10，进入cmd界面，输入并回车：oobe\bypassnro
设置1：在进去windows11时，以管理员身份运行PowerShell，输入并回车：
Set-ExecutionPolicy RemoteSigned
选择A回车
设置2：
1.在菜单栏，点击安装VMware-Tools
2.CD-ROM中找到setup文件，右击使用PowerShell安装
配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0fe7a936dcbacacd84a2f2340ec24a/" rel="bookmark">
			【微信支付】【java】Springboot对接开发微信支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章是介绍java对接（微信小程序）微信支付，包括微信预下单、支付、退款等等。 目录
一、微信配置申请
1、微信支付配置申请
二、开发环境
1、开发环境
2、maven依赖
3、application.yml文件配置
三、代码开发
1、配置类
2、初始化商户配置
3、JSAPI微信预下单
3.1、先建个WxPayService服务类
3.1、R实体类
3.2、CreateOrderReq类
4、微信支付回调通知 5、根据商户订单号查询订单（out_trade_no）
5.1 QueryOrderReq类
6、根据支付订单号查询订单 （transaction_id）
7、微信申请退款
8、退款回调通知 四、mysql表结构
五、controller类
一、微信配置申请 1、微信支付配置申请 详细操作流程参考官方文档：https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_1.shtml#part-1
配置完成需要以下信息：
APPID商户号（mchid）商户API私钥（apiclient_key.pem）商户证书序列号商户APIv3密钥 二、开发环境 1、开发环境 开发语言：java ，编译工具：idea ，框架：springboot ，仓库：maven
2、maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.wechatpay-apiv3&lt;/groupId&gt; &lt;artifactId&gt;wechatpay-java&lt;/artifactId&gt; &lt;version&gt;0.2.10&lt;/version&gt; &lt;/dependency&gt; 3、application.yml文件配置 #微信支付配置 wx: pay: #应用id（小程序id） appId: wx6b5xxxxxxxxxxxx #商户号 merchantId: 1xxxxxxxxx #商户API私钥 privateKey: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx #商户证书序列号 merchantSerialNumber: 315DDXXXXXXXXXXXXXXXXXXXXXXXXXXX #商户APIv3密钥 apiV3Key: XXXXXXXXXXXXXXXXXXXXXXXXXX #支付通知地址 payNotifyUrl: https://xxx.xxxx.xxx.xxx/xx/xxxx/xxxx/openapi/wx/payNotify #退款通知地址 refundNotifyUrl: https://xxx.xxx.xxx.xxx/xxxx/xxxx/xxxx/openapi/wx/refundNotify 三、代码开发 1、配置类 import lombok.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c0fe7a936dcbacacd84a2f2340ec24a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8cede86c6a8d2dbc4d70c38a2439b3/" rel="bookmark">
			摸鱼大数据——Linux搭建大数据环境(集群免密码登录和安装Hadoop)二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集群设置免密登录 克隆node1虚拟机的前置条件：node1虚拟机存在且处于关闭状态
1.克隆出node2虚拟机 1.node1虚拟机: 右键 -&gt; "管理" -&gt; "克隆"
2.图形化弹窗中: "下一页"-&gt;"下一页"-&gt;选择"创建完整克隆"再"下一页"-&gt;填写"node3和对应位置"再点击"完成"
3.node3虚拟机: 右键 -&gt; "设置" -&gt; "NAT模式" -&gt; "高级" -&gt; "生成"Mac地址再'确定' -&gt; 最后点击"确定"
node3基础配置 修改ip地址
[root@node1 /]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 # 注意此操作是在node3中修改ip地址 IPADDR="192.168.88.103" 修改主机名
[root@node1 ~]# vim /etc/hostname # 注意此操作是在node3中修改主机名 node3 重启虚拟机
[root@node1 ~]# reboot 查看配置是否生效
[root@node3 ~]# ifconfig 3.CRT操作所有会话 SecureCRT软件: "查看 "- &gt; 选择"交互窗口" -&gt; 右键选择"发送交互到所有会话" 4.设置免密登录 三台虚拟机都生成公钥和私钥
输入命令(注意需要三次回车操作): ssh-keygen 三台虚拟机都执行完命令后,在 /root/.ssh 中会自动生成两个文件: id_rsa 和 id_rsa.pub
分别拷贝公钥给其他虚拟机
输入命令(注意需要输入yes和密码): ssh-copy-id node1 输入命令(注意需要输入yes和密码): ssh-copy-id node2 输入命令(注意需要输入yes和密码): ssh-copy-id node3 测试免密登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f8cede86c6a8d2dbc4d70c38a2439b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d748baea748b249ebdf1a8942bf323/" rel="bookmark">
			IDEA文件出现java file outside of source root
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.问题： 2.解决方法：
3.扩展：父子工程引入Module后报错
参考文献:
1.问题： 有时候打开Module，发现各级文件夹下的类不能正常使用，类前的符号（小咖啡杯）是红色的（红色表示这个类是不可编译文件）。类前红色咖啡杯符号如图1所示：
图1 类前红色咖啡杯符号
打开文件后显示文字“Java file is located outside of the module source root,so it won't be complied”,警告文字如图2所示：
图2 警告文字
2.解决方法： 单击Module所在的“java”文件夹（注意不要点到其它的文件夹了），然后右键，找到“Mark Directory as”，选择“Sources Root”，操作过程如图3所示：
图3 操作过程
然后就会发现类前面本来红色的“小咖啡”变成蓝色的“小C圈”，而且本来灰色的java文件夹也变成蓝色了，这样类就可以正常使用了。颜色变化如图4所示：
图4 颜色变化
3.扩展：父子工程引入Module后报错 对于父子工程，有时候因为各种需要，会选择直接复制他人优秀的Module作为子模块，但是引入之后会格格不入（报错啦，O(∩_∩)O） ，报错很大可能就跟子模块的“名字”有关。
比如引入Module“consumer1”，但父工程的pom.xml文件中并没有包含“consumer1”，那么引入的“consumer1”Module就会是一个灰色的文件夹（正常的Module应该是一个文件夹上有个蓝色小框框），不能正常使用。Module未被父工程pom.xml文件引入如图5所示：
图5 Module未被父工程pom.xml文件引入
解决方法一：
直接将“consumer1”引入父工程的pom.xml文件的&lt;module&gt;,发现“consumer1”文件夹变成蓝色小框框了，然后就可以正常使用“consumer1”模块了，直接引入“consumer1”如图6所示：
图6 直接引入“consumer1”
解决方法二： 如果觉得“consumer1”这个名字不能传达自己的想法，或者不够文艺，总之不管怎样，想改个名字，此处假设将“consumer1”改为“consumer”。
单击“consumer1”文件夹，右键，选择“Refactor”，选择“Rename”，Rename操作如图7所示：
图7 Rename操作
输入自己想改的名字，然后点击“Refactor”，即可完成名字的修改，修改名字如图8所示：
图8 修改名字 但是修改完名字之后，发现“consumer1”文件夹确实改为了“consumer”文件夹，而且文件夹上有小蓝框，可以正常使用这个模块了，但是“consumer”后面跟着文字：“consumer1”，跟着文字：“consumer1”如图9所示：
图9 跟着文字：“consumer1”
不改其实也不影响使用，但假设想改的话，还是跟改名字一个套路：单击“consumer”文件夹，右键，选择“Refactor”，选择“Rename”，Rename操作如图10所示：
图10 Rename操作
但是发现多出来一个选项，就是让选择修改哪一个，上面一个“Rename directory”是修改文件夹名称的（跟第一次操作结果其实是一样的），本次选择下面一个“Rename module”，用于修改module名称，选择“Rename module”如图11所示：
图11 选择“Rename module”
将module由“consumer1”修改为“consumer”，然后单击“OK”，修改module名称如图12所示：
图12 修改module名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10d748baea748b249ebdf1a8942bf323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e3f4e68c05c458c161924f49d0932a/" rel="bookmark">
			超详细Redis下载安装图文教程（Win和Linux版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超级详细 的 Redis 安装教程 说明
Windows 版本的 Redis 是 Microsoft 的开源部门提供的 Redis. 这个版本的 Redis 适合开发人员学习使用，生产环境中使用 Linux 系统上的 Redis, 这里讲解了这两种的安装和下载。按照你们需要的liunx 或window步骤来 就可以了（也可以留言，后面看反馈决定是否反馈，Liunx版和Window版）
什么是NOSQL NOSQL(not only sql) 不仅是sql,它是所有非关系型数据库的一种统称。
NOSQL和RDBMS的区别
RDBMS --关系型数据库
高度组织化结构化数据。 --表结构 列 列....结构化查询语言（SQL） sql语句数据和关系都存储在单独的表中。数据操纵语言DML，数据定义语言DDL严格的一致性. ACID 原子性 隔离性 持久性 一致性基于事务----都支持事务 NOSQL--非关系型数据库
代表着不仅仅是SQL没有声明性查询语言键 - 值对存储。非结构化和不可预知的数据 字符串 集合 对象 队列高性能，高可用性和可伸缩性。 ----便于搭建集群---挂载 常见的非关系数据库的种类: redis: 典型的非关系数据库---结构基于key和value的形式
mongodb---介于关系型数据库和非关系数据库之间
hbase: 数据库【海量数据】
什么是Redis Redis是一种开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。Redis提供数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，地理空间索引和流。Redis具有内置的复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供了高可用性。
redis它是一个开源的数据库，缓存的服务器，它里面可以存放字符串，hash，列表，集合数据类型的数据，它的计算基于内存进行计算的。而且数据也可以持久化到磁盘中。 而且它也提高了哨兵模式以及集群模式来提高redis的可用性。
redis特点
Redis读取的速度是110000次/s，写的速度是81000次/s
Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 ---影响redis性能的因素：内存而不是多线程
支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合)
持久化--磁盘--防止数据丢失
官方不支持window系统,但是又第三方版本。 linux系统。
一、Redis安装（Win版） 1、下载redis 安装包 官网：Redis - The Real-time Data Platform
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e3f4e68c05c458c161924f49d0932a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af026ef5d7ab7de1d2006d393452cb0e/" rel="bookmark">
			MySQL四种方法实现merge into
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MERGE INTO：不存在则 insert, 存在则 update
目录
方法一：update + insert
1.where exists
（1）介绍
（2）原理
2、update + insert
方法二：replace into
方法三：on duplicate key update
方法四：创建存储过程
Mysql 8.x 版本引入了 MERGE INTO 语法
Merge 语句的基本语法： MERGE INTO target_table USING source_table ON condition WHEN MATCHED THEN UPDATE SET column1 = value1, column2 = value2, ... WHEN NOT MATCHED THEN INSERT (column1, column2, ...) VALUES (value1, value2, ...); target_table: 要更新或插入数据的目标表。source_table: 包含要合并数据的来源表。condition: 指定用于匹配目标表和来源表数据的条件。WHEN MATCHED: 当目标表和来源表数据匹配时，执行的更新操作。WHEN NOT MATCHED: 当目标表和来源表数据不匹配时，执行的插入操作。 本文主要介绍将oracle中的merge into转换成MySQL的语法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af026ef5d7ab7de1d2006d393452cb0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fedc9f7526d98fad09907685062c6e/" rel="bookmark">
			2024年最全前端面试八股文【很经典 很全面 字字珠玑】【建议收藏&#43;关注】，2024年最新web前端面试题 应届生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自学几个月前端，为什么感觉什么都没学到？？ 这种现象在很多的初学者和自学前端的同学中是比较的常见的。
因为自学走的弯路是比较的多的，会踩很多的坑，学习的过程中是比较的迷茫的。
最重要的是，在学习的过程中，不知道每个部分该学哪些知识点，学到什么程度才算好，学了能做什么。
很多自学的朋友往往都是自己去找资料学习的，资料上有的或许就学到了，资料上没有的或许就没有学到。
这就会给人一个错误的信息就是，我把资料上的学完了，估计也-就差不多的了。
但是真的是这样的吗？非也，因为很多人找的资料就是很基础的。学完了也就是掌握一点基础的东西。分享给你一份前端分析路线，你可以参考。
开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
还有很多的同学在学习的过程中一味的追求学的速度，很快速的刷视频，写了后面忘了前面，最后什么都没有学到，什么都知道，但是什么都不懂，要具体说，也说不出个所以然。
所以学习编程一定要注重实践操作，练习敲代码的时间一定要多余看视频的时间。
20.动画有哪些实现方法? Js
setTimeout、setInterval、requestAnimationFrame
requestAnimationFrame方法是h5提供的一种专门解决动画更新的API，浏览器会自动以最合适的频率去刷新动画
jQuery中动画也比较实用css
animationcanvas元素结合JS插件
例如 jQuery 21.浅拷贝 浅拷贝对原对象或副本的更改可能也会导致其他对象的更改。它实际上只拷贝了一层，并且只当数组和对象包的值是原始值时才会进行拷贝。
赋值运算符 = let a=[1,2,3] let b=a; console.log(b==a)//true 扩展运算符 … let a=[1,2,3] let b=[...a]//把数组a的内容 挨个取出 放到b数组中 console.log(b===a) //true slice方法 let a=[1,2,3] let b=a.slice() console.log(a===b) //false a[0]=4; console.log(a)//4 2 3 console.log(b) //1 2 3 assign方法 let a=[1,2,3] let b=[] Object.assign(b,a); a[0]=4 console.log(a)//4 2 3 console.log(b) //1 2 3 Array.from let a=[1,2,3] let b=Array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39fedc9f7526d98fad09907685062c6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d666160afdcc9589346f0dec9ed9246/" rel="bookmark">
			2024年最全前端程序员面试笔试宝典，2024年最新web前端高级工程师面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 面试题 1.Vue 双向绑定原理
2.描述下 vue 从初始化页面–修改数据–刷新页面 UI 的过程？
3.你是如何理解 Vue 的响应式系统的?
4.虚拟 DOM 实现原理
5.既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进行 diff 检测差异?
6.Vue 中 key 值的作用？
7.Vue 的生命周期
8.Vue 组件间通信有哪些方式?
9.watch、methods 和 computed 的区别?
10.vue 中怎么重置 data?
11.组件中写 name 选项有什么作用？
12.vue-router 有哪些钩子函数?
13.route 和 router 的区别是什么？
14.说一下 Vue 和 React 的认识，做一个简单的对比
15.Vue 的 nextTick 的原理是什么？
16.Vuex 有哪几种属性?
17.vue 首屏加载优化
18.Vue 3.0 有没有过了解？
19.vue-cli 替我们做了哪些工作？
…
算法 开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
冒泡排序选择排序快速排序二叉树查找: 最大值、最小值、固定值二叉树遍历二叉树的最大深度给予链表中的任一节点，把它删除掉链表倒叙如何判断一个单链表有环给定一个有序数组，找出两个数相加为一个目标数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d666160afdcc9589346f0dec9ed9246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19740f65f7e0eed01fe62a5fc35d3bd1/" rel="bookmark">
			用java调用geoserver发布地图服务——（萌新记录自己终于解决的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我的项目中需要使用cesium展示地图服务（矢量、栅格），在我接手之前，代码使用的时arcgis发布的地图服务，arcgis确实功能强大并且教程很多，但是可能负载太大了，网不好的时候栅格图像他要加载很久。如下图，网络原因我的底图出现了错误没加载出来（意思一下），于是乎想到了使用geoserver发布地图服务并加载，geoserver是轻量级并且开源的。
准备工作 1.下载geoserver 我使用的版本是2.23.1
https://geoserver.org/release/2.23.1/
去官网下载一个安装版的就好了，很方便
2.确保自己的电脑有jdk，geoserver是基于java的 小贴士：高版本的java，一定要下载一个java11，把geoserver安装到java11的环境下，虽然说是支持java17但是支持的不是很好，我之前安装在17的环境下，服务器一直500.
更换后：才能正常用
3.依赖 要使用geoserver，就需要引入大佬们的jar包
maven依赖
&lt;dependency&gt; &lt;groupId&gt;nl.pdok&lt;/groupId&gt; &lt;artifactId&gt;geoserver-manager&lt;/artifactId&gt; &lt;version&gt;1.7.0-pdok2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; 使用java编写代码发布栅格图层 1.获取geoserver的manager对象
该对象可以获取到GeoServerRESTPublisher，还有很多方法用于获取其他的管理对象
2.创建工作区（workspace）
调用GeoServerRESTPublisher类中的createWorkspace方法
3.创建对应的数据储存（栅格数据储存需要创建这个，其他的数据储存可以参考源码（createDataStore、createDataStore、createPostGISDatastore））
4.发布图层
调用publisher.publishGeoTIFF方法，该方法有很多同名的重载方法，可以参考源码依据情况使用
具体工具类代码（可以直接用） public class GeoServerUtil { /** * geoServer配置 */ private static String url = "http://localhost:8088/geoserver"; private static String geoUsername = "admin"; private static String geoPassword = "geoserver"; public static GeoServerRESTManager getManager() throws MalformedURLException { URL u = new URL(url); //获取管理对象 GeoServerRESTManager geoServerRESTManager = new GeoServerRESTManager(u, geoUsername, geoPassword); return geoServerRESTManager; } /** * 判断工作区（workspace）是否存在，不存在则创建 */ public static boolean judgeWorkSpace(String workspace) throws MalformedURLException { boolean flag = false; GeoServerRESTManager manager = getManager(); GeoServerRESTPublisher publisher = manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19740f65f7e0eed01fe62a5fc35d3bd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c89ca4ea2f6941fb19a2b65595322a/" rel="bookmark">
			Java——类和对象第二节——封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是封装 封装是面向对象程序的三大特性之一，面向对象程序的三大特性分别是封装，继承，多态
而封装简单来说就是套壳隐藏细节
打个比方：
在一些电脑厂商生产电脑时，仅对用户提供开关机键，键盘输入，显示屏和USB插口，而使用电脑的人不必关心电脑内部硬盘，CUP，芯片等核心组件，就可以通过键盘鼠标显示屏进行交互完成各种功能
封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互
2.访问限定符 在java中封装主要由类和访问权限来实现，类可以将数据以及封装数据的方法结合在一起，更符合人类对事物的认知，而访问权限用来控制方法或者字段能否直接在类外使用。
以上是java提供的4种访问限定的关键字
这四种关键字要怎么理解呢？
这里可以做个比喻
将类比作一个人，包比作一个家族
1.private:同一包中的同一类，也就相当于自己，自己的秘密只有自己知道，所以被private修饰的成员变量和方法只能本类中的成员方法可以调用
2.default：同一包中的不同类，也就相当于一个家族，被default修饰的成员方法和成员变量在同一个包中可以被其他类中的成员方法调用，也就相当于被default修饰后，成为了家族里面的秘密，外人是不知道的
3.protected:主要运用在继承里面，这里就不做过多介绍
4.public：他相当于一个人的外貌特征，谁都可以访问
注意：
1.当成员变量，成员方法或者类的前面什么访问限定符都不写时，编译器会默认为default
2.访问权限除了可以限定类中成员的可见性，也可以控制类的可见性
3.封装的步骤 1.使用private关键字对类里面的成员变量进行隐藏
2.写setter和getter方法对隐藏的成员变量进行访问
注意：1.private一般修饰成员变量
2.setter和getter方法可以通过idea自动给我们生成
3.可以在方法里面加一些条件语句进行限制
3.1使用idea生成Getter和Setter方法 3.2封装代码演示 class Student{ //private修饰类的成员变量 private String name; private int age; private String gender; public String getName() { return name; } //在类的方法里面添加条件语句，限制名字的长度 public void setName(String name) { if(name.length()&lt;6) this.name = name; } public int getAge() { return age; } //在类的方法里面添加条件语句，限制年龄的范围 public void setAge(int age) { if(age&gt;0&amp;&amp;age&lt;30) this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9c89ca4ea2f6941fb19a2b65595322a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3941187f32bafe6e8deef7fa8198b261/" rel="bookmark">
			【ChatGPT】官方Mac版下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5月13日，OpenAI发布了新版本的ChatGPT，其桌面版也从昨日开始发布，Mac首先体验，在App Store中没有找到软件。
于是查询openai论坛：
Chat GPT Desktop App for Mac - ChatGPT - OpenAI Developer Forum
发现https://persistent.oaistatic.com/sidekick/public/ChatGPT_Desktop_public_latest.dmg 可以下载到dmg安装包，如果下载不了，我这边也进行上传了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2a7c76f17a92d5bd914d9e8e1fb427/" rel="bookmark">
			【重生之我在学Android原生】Media3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章 【重生之我在学Android原生】ContentProvider(Java)
【重生之我在学Android原生】Media3
前言 内容颇多，尽量从简
ExoPlayer使用 官方文档
参考文章
实现效果 Android（java）
使用ExoPlayer播放视频，自定义ExoPlayer界面，记录播放位置（横屏竖屏切换/切换至后台等）
案例实现 创建项目 添加依赖 Sync 一下
/// Jetpack Media3 ExoPlayer implementation ("androidx.media3:media3-exoplayer:1.3.1") implementation ("androidx.media3:media3-ui:1.3.1") implementation ("androidx.media3:media3-common:1.3.1") 转到activity_main.xml 选择Player.View
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;androidx.media3.ui.PlayerView android:id="@+id/video_view" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; player初始化 要在Activity的生命周期中完成player的初始化销毁等
package com.test.exoplayerexampleapplication; import androidx.annotation.OptIn; import androidx.appcompat.app.AppCompatActivity; import androidx.media3.common.util.UnstableApi; import androidx.media3.common.util.Util; import androidx.media3.ui.PlayerView; import android.os.Bundle; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e2a7c76f17a92d5bd914d9e8e1fb427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92435272b53072f87b2dd839e73297a/" rel="bookmark">
			Hadoop上传文件到HDFS的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.启动Hadoop集群：
2. 打开终端或命令行界面：
在安装了Hadoop的服务器上，打开一个终端或命令行界面。
3.使用hdfs dfs命令上传文件： 使用hdfs dfs -put命令将本地文件上传到HDFS。命令的基本格式如下：
例如，如果你想将本地的/home/user/data.txt文件上传到HDFS的/user/hadoop/data/目录下，你可以运行以下命令：
如果你只想上传文件到HDFS的根目录，并保留其原始文件名，你可以这样做：
4.验证文件是否成功上传：
5.删除HDFS上的文件：
结论：
前言： 随着大数据时代的到来，数据存储和处理变得至关重要。Hadoop作为大数据处理的基石，其分布式文件系统HDFS提供了高效、可靠的数据存储方案。本文旨在简要介绍如何使用Hadoop命令行工具将文件上传到HDFS，为大数据处理提供基础支持。
1.启动Hadoop集群： 确保你的Hadoop集群已经启动并且运行正常。你可以通过jps命令查看Hadoop相关的进程是否在运行，如NameNode、DataNode、ResourceManager、NodeManager等。
2. 打开终端或命令行界面： 在安装了Hadoop的服务器上，打开一个终端或命令行界面。 3.使用hdfs dfs命令上传文件：
使用hdfs dfs -put命令将本地文件上传到HDFS。命令的基本格式如下： hdfs dfs -put &lt;local-file-path&gt; &lt;hdfs-path&gt; 其中：
&lt;local-file-path&gt; 是你要上传的本地文件的路径。&lt;hdfs-path&gt; 是HDFS上的目标路径，包括文件名。如果目标路径是一个目录，那么文件将被上传到该目录下，并保留其原始文件名。 例如，如果你想将本地的/home/user/data.txt文件上传到HDFS的/user/hadoop/data/目录下，你可以运行以下命令： hdfs dfs -put /home/user/data.txt /user/hadoop/data/ 如果你只想上传文件到HDFS的根目录，并保留其原始文件名，你可以这样做： hdfs dfs -put /home/user/data.txt / 注意：如果HDFS上的目标路径已经存在同名文件，hdfs dfs -put命令会覆盖它。
4.验证文件是否成功上传： 你可以使用hdfs dfs -ls命令来列出HDFS上的文件和目录，以验证文件是否已成功上传。例如：
hdfs dfs -ls /user/hadoop/data/ 这将列出/user/hadoop/data/目录下的所有文件和子目录。你应该能在其中看到你刚刚上传的data.txt文件。
5.删除HDFS上的文件： 如果你需要删除HDFS上的文件，可以使用hdfs dfs -rm命令。例如：
hdfs dfs -rm /user/hadoop/data/data.txt 例1：不带-r的。输入命令： hdfs dfs -rm /1/dir1/test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92435272b53072f87b2dd839e73297a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d9f6b56df708f10fabac28eeaf3c27/" rel="bookmark">
			在Windows 11中开启Copilot AI助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前许多Windows 11用户收到了23H2升级推送，升级之后发现没有Copilot（预览版）当然你如果是22H2版本亲测也是可以的。想要开启copilot尝鲜的朋友，手动开启方法如下：
首先下载压缩包ViveTool v0.3.3.zip，文件只有391KB
Windows11开启copilot-ViVeTool-v0.3.3.zip | BOBO Blog (soulcloser.com)https://www.soulcloser.com/download/windows11%e5%bc%80%e5%90%afcopilot-vivetool-v0-3-3-zip/
双击打开解压缩的文件夹，在地址栏输入cmd，输入以下命令启动windows copilot
vivetool /enable /id:44774629,44776738,44850061,42105254,41655236 回车后命令提示：
ViVeTool v0.3.3 - Windows feature configuration tool Successfully set feature configuration(s) 重启电脑。OK大功告成。
如果发现任务栏没有显示copilot则需要：打开设置 – 个性化 – 任务栏 – 启用Copilot(预览版)
操作视频在原文链接中：
在Windows 11中开启Copilot AI助手 | BOBO Blog (soulcloser.com)
需要注意的是，copilot使用目前大陆是无法使用的，需要科学上网环境。像下面这样就大功告成了
如果这篇文章对你有帮助，点赞分享支持一下吧！如果你遇到了问题，欢迎私信或留言~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaae6232aa24ede5f9af594cf668a42c/" rel="bookmark">
			Baidu Comate——一款能让我开发效率翻倍的AI插件助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Baidu Comate 背景 百度 Comate，Coding Mate Powered by AI。是文心大模型的智能代码助手，结合百度积累多年的编程现场大数据和外部优秀开源数据，可以生成更符合实际研发场景的优质代码。功能非常多可以推荐代码、生成代码注释、查找代码缺陷、给出优化方案，深度解读代码库、关联私域知识生成新的代码。提升编码效率，释放“十倍”软件生产力。
功能包含 智能生成完整的代码注释生成代码代码优化代码解释一些技术性的解答生成单元测试 支持语言 Baidu Comate支持 100+多种主流语言，C/C++、Java、Python、Go、JavaScript等等各种语言
VS Code、IntelliJ IDEA、GoLand、PyCharm、WebStorm、CLion、PhpStorm、Android Studio 等IDE插件 一键安装 上手非常简单
下面是Baidu Comate的官网
baidu Comate官网
下面我带着大家一起体验一下这个AI插件到底有多好用！！！
Baidu Comate的功能还是非常多的！！
涉及的行业也是很多~
今天我来从IDEA里面安装Baidu Comate AI插件助手
在settings里面找到 plugins
搜索Comate 安装即可~
接着找到官网里的个人信息 右上角 如果没有百度账号的记得创建一个~
输入完成以后界面右侧会出现一个蓝色的图标
右侧类似于chatgpt的对话 非常智能！！
我们也可以通过点击代码左边的图标来实现更便捷的功能~
函数注释的功能
行间注释的功能
代码解释的功能 生成单元测试
如果想要清空对话
以下是我亲自体验的视频 使用的心得体会 Baidu Comate的优点
大大帮助了开发者在日常业务中解决代码的问题减少调试时间 提高代码质量Baidu Comate有自动补全 以及单元测试 还有函数注释的功能大大提供了开发的效率 Baidu Comate的缺点
对于一些复杂的业务 Baidu Comate可能不能解决 需要程序员自行解决
总的来说 ·baidu Comate的优点还是非常多的 对于小白开发可以大大提高开发效率十分推荐大家去使用这款Baidu Comate智能编码助手
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaae6232aa24ede5f9af594cf668a42c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79796b3efe0d4d4d8e9e61d58b142816/" rel="bookmark">
			在虚机VirtualBox7.0.8安装Androidx86_64系统详细步骤要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近需要用到安卓系统蓝牙功能做测试，就选择了Virtualbox+androidx86方案，先把系统安装好，后面看是否可以比较好的完成蓝牙功能测试。如果可以的话，我会再发文分享下的，敬请期待。
1.准备材料 （1）VirtualBox
VirtualBox是一款开源虚拟机软件，原由德国Innotek公司开发，后来被Sun Microsystems公司收购，并在Sun被Oracle收购后正式更名为Oracle VM VirtualBox。VirtualBox支持多种操作系统，包括Windows、Linux、macOS、Solaris等，允许用户设置每个客户操作系统正在运行的虚拟硬件的类型，因此即使主机系统的硬件不兼容，用户也能够安装过时的操作系统。
下载地址：Index of http://download.virtualbox.org/virtualbox/7.0.8
（2）Android-x86
Android是一个基于Linux内核的开源移动操作系统，由安迪·鲁宾开发，被谷歌收购。它具有开放性、可定制性、庞大的应用生态系统和集成谷歌服务等特点，是全球最流行的移动操作系统之一。
下载地址：Android-x86 download latest version
我的安装环境是windows10 64bit系统，下载好的包如下所示：
2.安装步骤 2.1安装virtual box虚拟机 安装比较简单，这里不赘述。可以参考这篇文章：
【VirtualBox】win10安装配置 Vbox---超详细 最新 持续更新中-CSDN博客
2.2安装androidx86系统 记录下关键步骤和注意点：
要点1.虚拟电脑名称和系统类型 当在虚拟光盘选择android-x86_64-9.0-r2.iso时，会自动选择类型为Linux,版本为Ubuntu(32-bit）。 版本按选择的镜像版本（_64）相应修改为Ubuntu(64-bit)，否则后面会安装失败。
要点2. 安装系统到硬盘 如下图，选择Installation -Install Android-x86 to harddisk。
要点3.创建硬盘分区 选择“Create/Modify partitions”。
不使用GPT分区
从可用空间创建新分区，选择New。
选择Primary。
回车确定。 选择Write，回车。
输入“yes”（注意“s”是显示不出来的），回车。
回到界面选择“Quit”，回车。
要点4.选择分区安装android系统 选择刚才分区好的“sda1”，回车。
选择ext4，回车。
格式化为etx4，选择Yes，回车。
安装引导程序GRUB，选择Yes，回车。
安装/system目录，选择Yes,回车。 选择“Reboot（重启）"，回车。
要点5.移除虚拟盘 重启发现又进入了安装界面，原因是光驱中还有安装镜像。可以在设备&gt;分配光驱&gt;移除虚拟盘。
要点6.如何设置为开机启动图形界面 默认的是这种命令行模式如下图所示，不是我们要的图形界面。
所以我们还需要进一步设置，需要重启一次，开机选择第二项回车，进入debug模式。
重启选第二项（Debug mode）
输入“mount -o remount,rw /mnt”（重新加载/mnt为可写模式）按回车键。
修改/mnt/grub/menu.lst, 加入nomodeset选项，输入：vi /mnt/grub/menu.lst回车， 按“ i ”键，进入编辑模式，在第一个启动项，quiet后面加入nomodeset，如下图： 按“esc”键取消编辑模式，输入"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79796b3efe0d4d4d8e9e61d58b142816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7648bbb152dd6ee212ce08c3a06010c8/" rel="bookmark">
			【数据结构】解密链表之旅（单链表篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 哈喽大家好，我是野生的编程萌新，首先感谢大家的观看。数据结构的学习者大多有这样的想法：数据结构很重要，一定要学好，但数据结构比较抽象，有些算法理解起来很困难，学的很累。我想让大家知道的是：数据结构非常有趣，很多算法是智慧的结晶，我希望大家在学习数据结构的过程是一种愉悦的心情感受。因此我开创了《数据结构》专栏，在这里我将把数据结构内容以有趣易懂的方式展现给大家。
1.线性表链式存储结构定义 在上一篇博客中我们提到了线性表有两种存储方式，一种是顺序存储，一种是链式存储。线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据可以存在内存未被占用的任意位置。
在之前的顺序结构中，每个数据元素只需要存储数据元素信息就可以了。现在链式结构中，除了要存储数据元素信息外，还要存储它的后继元素的存储地址。链式存储结构相比于顺序存储结构的优势在于插入和删除操作的高效性。由于链式存储结构中的元素通过指针连接，所以在插入和删除元素时，只需改变指针的指向，不需要移动其他元素，因此效率较高。而顺序存储结构需要移动元素位置，效率较低。线性表的链式存储结构是通过节点之间的指针来实现的，每个节点包含两个部分：数据域（存储数据元素信息的域）和指针域（存储直接后继位置的域）。n个节点链接成一个链表，即为线性表的链式存储结构（链表）。
链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表的存储结构就与火车车厢相似，淡季时车次的车厢会有所减少，相对的在旺季时车次的车厢会有所增加。这需要将火车的车厢去掉或者加上，不会影响其他的车厢，每节车厢都是独立的。就像下面这张图：
每节车厢都是独立的，每节车厢都有自己的车门。假设每节车厢都是锁住的状态，他们都需要不同的钥匙来解锁且每次只能携带一把钥匙，该如何从车头走向车尾呢？最简单的方法就是：在每节车厢存放下一节车厢的钥匙。那么在链表这个“火车”中，每节“车厢”的情况是什么样子的呢？
与顺序表不同的是，链表每节“车厢”都是独立申请下来的空间，我们称为“节点/结点”。对于线性表来说，总得有头有尾啊，链表也不能例外。我们把链表中的第一个节点存储的位置叫做头指针，那么整个链表的存取就必须是从头指针开始运行了。之后的每一个节点，其实就是上一个后继指针指向的位置。既然如此，那最后一个节点的指针指向哪里？什么！最后一个？当然就意味着后继不存在了，所以我们规定最后一个节点的指针为空。有时候，我们为了更加方便地对链表进行操作，会在单链表的第一个节点之前附设一个节点，我们成为头节点。下图为在上图基础上加一个头节点：
头指针和头结点的异同点：
头指针和头节点都是链表的概念，用于表示和操作链表的入口。头指针是一个指针变量，存储的是第一个节点的地址；头节点是一个特殊节点，位于链表的第一个位置，不包含有用的数据。头指针用于遍历链表中的所有节点；头节点用于简化对链表的操作。头指针在链表中的位置是可变的，可以随着节点的插入或删除而改变；头节点在链表中位置固定，一般不会发生变化。 链表的种类非常多样，我们主要根据是否有头节点、单向或双向、是否循环将链表分为8类：
1.带头或者不带头
2.单向或者双向：
3.是否循环：
虽然有这么多的链表结构，其实我们最常用的还是两种结构：不带头的单向链表和双向循环链表。我们这一篇就主要围绕单链表来介绍。 2.单链表各个功能的实现 单链表是一种最简单的链表数据结构，它由一系列节点组成，每个节点包含两部分：数据域和指针域。数据域用于存储节点的数据，指针域用于指向下一个节点。单链表的特点是节点之间只有一个指针连接，每个节点只能访问下一个节点，不能访问前一个节点。链表的头节点是第一个节点，尾节点是最后一个节点，尾节点的指针域通常指向一个空地址（NULL）。用C语言来描述单链表的结构指针：
typedef int SLNDataType; typedef struct SListNode { SLNDataType val; struct SListNode* next; }SLNode; 在这里我们主要详细介绍单链表的插入删除等操作。在单链表中插入有尾插、头插、任意位置插入等操作，每次插入都需要申请空间，每次申请空间的操作都相同，我们干脆写一个函数来实现申请空间，这样能使我们的操作更加方便。
SLNode* CreateNode(SLNDataType* x) { SLNode* newnode = (SLNode*)malloc(sizeof(SLNode)); if (newnode == NULL) { perror("malloc fail"); exit(-1); } newnode-&gt;val = x; newnode-&gt;next = NULL; return newnode; } 2.1单链表的尾插和尾删 单链表的尾插操作步骤：
创建一个新的节点，设置其数据域为要插入的值，指针域为空。检查链表是否为空。若为空，则将新节点作为链表的第一个节点。若链表不为空，需要找到链表的最后一个节点。从链表的头节点开始遍历，直到遍历到最后一个节点（即指针域为空的节点）。将最后一个节点的指针域指向新节点，将新节点插入到链表中。 我们需要使用单链表指针变量来创建头指针，所以我们在传参时要使用二级指针。我们来实现一下单链表的尾插操作：
void SLPushBack(SLNode** phead, SLNDataType x) { assert(phead); SLNode* newnode=CreateNode(x); if (*phead == NULL) { *phead = newnode; } else { SLNode* tail = *phead; while (tail-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7648bbb152dd6ee212ce08c3a06010c8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/363/">«</a>
	<span class="pagination__item pagination__item--current">364/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/365/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>