<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fff106188df704bb32b779a6cb9b0e0/" rel="bookmark">
			MySQL | JDBC连接数据库详细教程【全程干货】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是JDBC？二、JDBC工作原理三、使用JDBC连接MySQL数据库【✔】1、安装对应数据驱动包2、将jar包导入项目中3、编写代码连接数据库【⭐】1️⃣ 创建数据源2️⃣ 和数据库建立网络连接3️⃣ 构造SQL语句4️⃣ 执行SQL语句5️⃣ 断开连接，释放资源 4、测试观察5、代码优化1️⃣灵活变通SQL2️⃣防止SQL注入攻击 6、SQL查找的写法7、SQL修改和删除的写法 四、整体代码展示五、总结与提炼 一、什么是JDBC？ JDBC，即Java Database Connectivity，java数据库连接。是一种用于执行SQL语句的Java API，它是Java中的数据库连接规范。这个API由 java.sql.*,javax.sql.* 包中的一些类和接口组成，它为Java开发人员操作数据库提供了一个标准的API，可以为多种关系数据库提供统一访问
二、JDBC工作原理 JDBC 为多种关系数据库提供了统一访问方式，作为特定厂商数据库访问API的一种高级抽象，它主要包含一些通用的接口类
下面是我画的一张有关JDBC访问数据库层次结构的图：
可以看到，我们程序员在开发JavaEE应用的时候，通过调用Sun公司提供给我们的JDBC相关API，就可以切访问数据库的JSBC驱动程序，继而通过驱动来加载数据库
JDBC优势：
Java语言访问数据库操作完全面向抽象接口编程开发数据库应用不用限定在特定数据库厂商的API程序的可移植性大大增强 三、使用JDBC连接MySQL数据库【✔】 1、安装对应数据驱动包 那有同学就问了，数据驱动包是什么？
💬 对于数据驱动包而言，其实就是上面我所说到的各个【数据库厂商】所提供给我们的JDBC驱动程序，因为只有数据库厂商那边提供给了我们加载数据库的驱动，我们才能去获取到数据库中的数据表然后进行CRUD等操作
这样说呢可能还不是很好理解，我们可以通过画图来帮助理解，知道了JDBC的工作原理后，我们还要去了解什么去驱动包 接下去就要去下载这个驱动包，去哪里下呢？当然是官网！
但是呢，官网很麻烦，你要一个个地去找，不知道要下那个才好，下面是MySQL的官网的驱动下载处，很好找。但若是你用的是Oracle数据库的话，就会很麻烦了，因为它们这家公司很大，产品也很多，所以官网中会很很多东西，你很难去找到自己想要的驱动程序 难道这就没办法了吗？要一个个找吗😥当然有，那就是我们心爱的【Maven】
对于Maven而言，学Java的同学一定不陌生，它是一个 “中央仓库”，Maven 作为 Java 项目管理工具，它不仅可以用作包管理，还有许多的插件，可以支持整个项目的开发、打包、测试及部署等一系列行为，简直是居家旅行、杀人灭口必备良药！咳咳，然后我们就可以去下载MySQL对应的驱动包了，按照下图指示来即可 点进去之后就可以选择对应的驱动包版本了，但是这里在选择的时候要注意了，需要和你MySQL安装的版本一致才可，我的MySQL是5.7的，所以这里大版本不能变，要选择5.1开头的，后面的小版本没关系；当然如果你的MySQL是8.x版本的，你就要选择8开头的驱动包了 点进去之后我们看到有个jar，点一下它，你就可以拥有一个MySQL相关的驱动包了，就和我们平常使用的.rar、.zip压缩包没什么区别，就是Java的压缩包以.jar结尾 下载好了之后就是这个样子的 2、将jar包导入项目中 现在我们有了这个jar后，就要把它用起来
那现在我们去新建一个项目，然后把这个包导进来，不过在此之前要新建一个名为lib的目录，它是library库的缩写，当然你也可以写其他的名称 然后右键这个目录选择【添加为库…】 此时这个MySQL的驱动库就导入到我们的项目中了 3、编写代码连接数据库【⭐】 加载完MySQL的驱动包之后，我们就可以使用一些API去操作数据库了，准备好了吗，发车了🚗
1️⃣ 创建数据源 👉首先第一点，要连接数据库的话，我们就要知道这个数据库在哪里
这里我会介绍两种方式，一个是通过DataSource（数据源）对象获取，另一种则是通过DriverManager（驱动管理类）的静态方法获取，不过重点在于第一种 ①DataSource（数据源）对象获取
下面是创建数据源的相关代码，我使用到了Java中的向上转型和向下转型，不是很清楚的同学可以先去了解一下 DataSource dataSource = new MysqlDataSource(); ((MysqlDataSource)dataSource).setURL("jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false"); ((MysqlDataSource)dataSource).setUser("root"); ((MysqlDataSource)dataSource).setPassword("xxxxxxxxxxx"); 也就是这一句我使用到了向上转型，DataSource是Java中的一个接口，MysqlDataSource则是它的实现类，下面这种便是很典型的使用接口来实现向上转型 DataSource dataSource = new MysqlDataSource(); 然后下面的setURL()、setUser()、setPassWord()都是【MysqlDataSource】这个接口实现类中的一些方法，但是由于向上转型后父类无法去调用子类独有的方法，所以我们还要去进行一个向下转型通过去进行一个强制类型转换就可以做到，此时我们便能调用到实现类中的方法了 ((MysqlDataSource)dataSource).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fff106188df704bb32b779a6cb9b0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e2e84bd189e42fcc1415a18c2e15aa/" rel="bookmark">
			Mac OS镜像包免费下载地址，我来告诉你！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 为什么写这篇文章？因为踩过的坑，不想别人再踩一遍。
在windows系统上，用VMware安装mac os虚拟机的过程，发现Mac OS镜像包的下载是个很头疼的事情，CSDN找了很多文章，里面要么收费，要么是转别人的收费链接，很蛋疼（真的就是这个感觉！），没办法我花了58元子开了VIP才下载了一份！！！
后来偶然去修手机，和修手机的老哥聊起这事，这哥们轻描淡写的一句“苹果系统之家上有啊”，然后像看沙雕一样看着我！
MF！！！
正文 好了，不废话，地址在下方
https://macoshome.com/
我只下载过Mac OS镜像包，其他内容，感兴趣的话自己可以去研究一下。
点这个进去，选自己想要的镜像版本即可，
这里版本很全面（再扇自己两巴掌！）
点这里跳转到下载地址
保存到网盘，然后下载即可。
写在最后 知识在传递的过程才能发光！
赠人玫瑰，手留余香，我乐于把自己的经验分享给各位，希望各位也能奉献自己的所学，祝各位在求知的路上少走弯路！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4c1090fa5fdd7599eb1994e1db273f7/" rel="bookmark">
			Java | interface 和 implements关键字【接口，看这篇就够了】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学完继承、学完多态，但面对汹涌而来🌊的接口，相信很多同学都不知所措，因此我耗费几天几夜的时间，搜寻大量书籍资料，苦心闭关钻研，写出了一篇关于Java的接口从入门小白到精通大佬的学习之路，相信这篇文章一定对您有所帮助📖
Java——接口的详细介绍和灵活使用 🌳接口的基本概念引入🌳如何去定义和实现一个接口🔑【interface关键字】🔑【implements关键字】 🌳接口特点及作用🍃接口的特点📕接口的作用和意义 🌳接口的UML图（类图）🍃UML图的基本概念🍃UML图的作用🍃接口UML图的基本结构和组成🎈继承关系类图与接口图的区别 🌳接口回调与多态的联系📚权威解释🍃具体案例分析 🌳函数接口与Lambda表达式🍃Lambda表达式🍃函数式接口🍃简化规则定义💡细心小贴士 🌳深入理解接口【面向接口的思维】❓提问一：为什么不在一个类中直接实现相应的方法，而是要先进行接口抽象呢？❓提问二：接口的真正用处在哪里，用接口可以帮助我们实现什么？❓提问三：接口与抽象类如此地相似，为什么有的时候要使用接口而不用抽象类呢？ 🌳接口的实战项目演练"Hello World"【⭐】新能源时代【⭐⭐⭐】疯狂农场【⭐⭐⭐⭐⭐】 🌳总结与提炼 🌳接口的基本概念引入 Java接口是一系列方法的声明，是一些方法特征的集合
对于接口，它是Java中一个新增的知识点，而C++中没有，因为Java有一个缺陷就是不可以实现多继承，只可以单继承，这就限制了有些功能的使用，于是为了让Java也能有这种能力，因为提出了接口的概念对于接口的基本概念，大家应该要回想一下我们上一文所讲的abstract抽象类的概念，因为接口它与抽象类非常类似，在抽象类中我们可以了解到其实除了不可以实现一些抽象方法外，其余的和正常的类没有什么本质的区别，一些常量、变量，私有、静态方法都可以定义，但是在接口中，就只能有抽象方法以及常量，而且接口中所有抽象方法的访问权限都是public公开的，因为它也算是static静态方法，所以可以省略public和static这两个关键字但是从JDK8开始，就有了一些改变，接口中也可以定义default和private关键字修饰的方法，对于default关键字修饰的方法，不可以将此关键字省略，因为在接口体中不允许定义通常的带方法体的public实例方法；而对于private修饰的方法，则是配合default默认方法进行使用，即将某些算法封装在private方法中，供接口中的实例方法调用 🌳如何去定义和实现一个接口 了解了接口的基本概念之后，是不是很想知道一个接口时怎么去定义和实现呢，让我们马上来看一看吧
🔑【interface关键字】 首先最基本的定义一个接口，对于接口，如果你觉得有一些方法它们有一个功能的类名，那你就可以把它定义为一个接口，在这个接口中去定义一些抽象方法，比方是大家都会运动，运动的方式有很多，比方说跑步、游泳等等，但是你做这些事情的方式的方式和节奏和人家专业运动员又不一样，所以可以由不同的类去继承这个接口，然后去实现具体的对应的功能 public interface Sport { void run(); //跑步 void swim(); //游泳 } 这和类的定义很相似，细心的小伙伴可以看出来这是将class关键字换成inferface关键字，但是变得可不止这一种哦，接口可是有它的专属图表的🎇 IDEA👉
eclipse👉
这两个Java编译器应该是大家用的最用的了，对于接口，细心的小伙伴应该可以发现，存在一个【大写的I】，这个标志就是【interface】的首字母大写了，相信这点很多人都没有发现吧 🔑【implements关键字】 好，说完如何入定义一个接口，接下去就来讲讲怎么去实现一个接口吧那就是用【implements】这个关键字，通过一个具体的类去实现 public class People implements Sport{ } 但是这样的话就会出现报错，这个我们在继承抽象类的时候就有说过，继承一个抽象类，就要去重写其所有的抽象方法 public class People implements Sport{ @Override public void run() { System.out.println("我会慢跑🏃‍"); } @Override public void swim() { System.out.println("我会自由泳🏊‍"); } } 【注意事项】
对于抽象类的话，如果你用一个抽象类去继承，那么你就不用重写这个抽象方法，当然对于接口也是一样如果一个非abstract类实现了某个接口，那么这个类就必须重写该接口的所有抽象方法如果一个abstract类实现了某个接口，那么这个类可以选择重写接口中的抽象方法或者该接口的抽象方法 🌳接口特点及作用 了解了接口的定义和实现之后，接下来我们来说一说接口有哪些特点以及其具体的作用
🍃接口的特点 接口虽与抽象类相似，但是比抽象类更加抽象，却不需要写abstract关键字，因为接口中所有方法都是抽象的，因此可以省略这个关键字
接口中只可以有常量，而且都是public、static、final关键字修饰的【默认都有，可以不加】，但是不可以有变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4c1090fa5fdd7599eb1994e1db273f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb3a1814e664c8df5266e12adbc54878/" rel="bookmark">
			【数据结构】二叉树的存储与基本操作的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍀二叉树的存储🌳二叉树的基本操作🐱‍👤二叉树的创建🐱‍👓二叉树的遍历🎡前中后序遍历📌前序遍历📌中序遍历📌后续遍历 🛫层序遍历🐱‍👤前中后序代码实现（递归）🚩前序遍历🚩中序遍历🚩后续遍历 🛬前中后序练习题 🐱‍🏍二叉树的基本操作🎈获取树中节点的个数🎈获取叶子节点的个数🎈获取第K层节点的个数🎈 获取二叉树的高度🎈检测值为value的元素是否存在 ⭕总结 🍀二叉树的存储 二叉树的存储结构分为：顺序存储和类似于链表的链式存储
这里博主讲一下链式存储
二叉树的链式存储是通过一个一个的节点引用起来的，常见的表示方式有二叉和三叉表示方式
二叉表示：
// 孩子表示法 class Node { int val; // 数据域 Node left; // 左孩子的引用，常常代表左孩子为根的整棵左子树 Node right; // 右孩子的引用，常常代表右孩子为根的整棵右子树 } 三叉表示：
/ / 孩子双亲表示法 class Node { int val; // 数据域 Node left; // 左孩子的引用，常常代表左孩子为根的整棵左子树 Node right; // 右孩子的引用，常常代表右孩子为根的整棵右子树 Node parent; // 当前节点的根节点 } 这里博主主要讲解一下孩子表示法
🌳二叉树的基本操作 🐱‍👤二叉树的创建 在学习二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。由于现在大家对二叉树结构掌握还不够深入，为了降低大家学习成本，此处手动快速创建一棵简单的二叉树。
创建如下：
public class BinaryTree{ public static class BTNode{ BTNode left; BTNode right; int value; BTNode(int value){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb3a1814e664c8df5266e12adbc54878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bcd58e27b61dd89e760f8108fd079b1/" rel="bookmark">
			原地起飞！VS Code 最好用的 10 款 AI 插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好，我是 EarlGrey，喜欢翻译点东西，偶尔写写代码。
点击下方卡片关注我，一起向上进击，提升自我。后台回复关键词“电子书”，送你一份我收藏的电子书合集。
开发人员的工具箱每年都在增加。最近，AI 工具受到热捧，质量和数量都在不断提高。
今天，我将为大家分享 10 款 AI 驱动的 VS Code 插件，合理运用这些插件，或许能将你的工作效率提升十倍。
那么，让我们直接开始吧！
1. GitHub Copilot 如果你是一名程序员，你一定听说过 GitHub Copilot。
它是一个人工智能配对程序员，能大大提高开发人员的工作效率。它能在编码时为你提供智能的自动完成建议。此外，你还可以用户自然语言写注释，定义你希望 GitHub Copilot 生成什么样的代码。
它由 OpenAI Codex 驱动，经过数十亿行开源代码训练，结果准确度极高。虽为付费工具，但提供 60 天试用期。
截至 2023 年 12 月 1 日，GitHub Copilot 已在 VS Code 上安装了1000 多万次。
2. Tabnine Tabnine是一个类似于 GitHub Pilot 的 VS Code 插件，但有一些不同之处。它提供由人工智能驱动的代码自动补全，以提高开发人员的工作效率。
Tabnine 可以帮助你从注释中生成代码、完成整行代码和函数，甚至可以在你编写代码时实时完成中行代码。
3. Bito AI Bito 是一款人工智能助手工具，用途广泛。你可以用它来生成代码、询问语法、生成测试用例、代码解释、生成注释、提高代码性能、检查安全性以及学习技术概念。
Bito 可以安装在 VS Code、JetBrains IDE 和 Chrome 浏览器中。它可以作为聊天机器人与你互动和提问。你还可以用它来自动删除日志语句，并为代码添加错误和异常处理功能。
截至 2023 年 12月 1 日，Bito AI 在 VS Code 中的安装次数已超过 38.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bcd58e27b61dd89e760f8108fd079b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81a2ff7d70b913125303e2967c0deb0/" rel="bookmark">
			【Vue】监控路由与路由参数, 刷新当前页面数据的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Vue监控路由
1、Vue中watch监控路由
2、Vue中watch监控路由的某一个参数
3、Vue中watch同时监控多个路由
二、刷新当前页面数据
1、location.reload
2、$router.go(0)
3、this.$router.resolve()与this.$router.resolve()
a、this.$router.resolve()
b、this.$router.push()
三、示例场景
四、往期相关优质推荐
Vue官网Element官网 一、Vue监控路由 1、Vue中watch监控路由 如果你想要监控整个路由对象的变化，包括路由路径、参数、查询参数等的变化，可以使用`$route`对象进行监控。以下是一个使用`watch`监控整个路由对象的示例：
&lt;template&gt; &lt;div&gt; &lt;!-- 显示监控的路由信息 --&gt; &lt;div&gt;{{ monitoredRoute }}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { monitoredRoute: null, // 用于存储监控的路由信息 }; }, watch: { '$route'(newRoute) { this.monitoredRoute = newRoute; // 将新的路由信息保存到组件的monitoredRoute属性中 // 执行其他操作或调用其他方法 }, //或 $route(newRoute) { this.monitoredRoute = newRoute; // 将新的路由信息保存到组件的monitoredRoute属性中 // 执行其他操作或调用其他方法 }, }, }; &lt;/script&gt; 在这个示例中，我们在组件的`data`选项中定义了一个`monitoredRoute`属性，用于存储监控的路由信息。在`watch`选项中，使用`'$route'`来指定要监控的路由对象。当路由发生变化时，`watch`函数会被触发，将新的路由信息保存到组件的`monitoredRoute`属性中。
你可以根据需要在`watch`函数中执行其他操作或调用其他方法，例如根据路由信息更新组件的状态、重新加载数据等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f81a2ff7d70b913125303e2967c0deb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683064d5320d89e9fc853f743b966bfd/" rel="bookmark">
			stable-diffusion model目录修改、自定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 stable-diffusion model目录修改、自定义 修改文件stable-diffusion-webui/modules/paths_internal.py28行 修改文件stable-diffusion-webui/modules/paths_internal.py28行 models_path = os.path.join(data_path, "models") #原来 models_path = '/workspace/diffusion_model/Stable-diffusion' #你想修改的路径 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e52d3b11a5e9094317b5a1ac92c0036/" rel="bookmark">
			记：vite3&#43;vue3&#43;axios前端项目跨域问题解决【前端和服务器nginx配置】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：什么是跨域，网上一搜一大把，所以这里直接跳过，直入主题。
处理方式：不通过后端处理跨域，通过前端+服务器nginx处理。
1.前端涉及处理跨域的必要配置（开发环境、生产环境）：vite3、vue3、axios
2.服务器涉及处理跨域的配置（生产环境）：nginx【主要用到其配置文件nginx.conf】
3.配置开发环境【跟目录下分别创建：.env.development、.env.production】
.env.development内容如下：
VITE_APP_PROXY_BASE_API='/proxyCustomerApi-dev' .env.production内容如下：
VITE_APP_PROXY_BASE_API='/proxyCustomerApi-pro' tips: .env.development、.env.production中的常量命名须以"VITE_"开头，这里定义的常量为VITE_APP_PROXY_BASE_API，值分别为"/proxyCustomerApi-dev"、"/proxyCustomerApi-pro"用以区分开发环境和生产环境，值可自定义为"/+自己想定义的内容"
4.前端vite.config.js中添加如下代码（代码中有相关注释）：
import { defineConfig, loadEnv } from 'vite'; import vue from '@vitejs/plugin-vue'; import * as path from 'path'; ... ... export default defineConfig((env) =&gt; { // 获取到当前开发模式（dev/pro）下对应的环境文件对象值 const evnMap = loadEnv(env.mode, process.cwd()); // console.log(`evnMap = ${JSON.stringify(evnMap)}`); return { ... ... server: { host: '0.0.0.0', // ip地址 port: 8088, // 启动端口 // 反向代理配置，注意rewrite写法，开始没看文档在这里踩了坑 proxy: { // 本地开发环境通过代理实现跨域，生产环境使用 nginx 转发 // 对应项目根目录 - [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e52d3b11a5e9094317b5a1ac92c0036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea01862ca919f2bfe95d7ed9f3446828/" rel="bookmark">
			如何使用Net2FTP轻松部署本地Web文件管理器并远程访问管理内网资源？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言2. Net2FTP网站搭建2.1. Net2FTP下载和安装2.2. Net2FTP网页测试 3. cpolar内网穿透3.1.Cpolar云端设置3.2.Cpolar本地设置 4.公网访问测试5.结语 1.前言 文件传输可以说是互联网最主要的应用之一，特别是智能设备的大面积使用，无论是个人存储文件资料，还是商业文件流转，都有数据存储和传输的需求。有需求就有市场，相应的传输软件层出不穷，而这些软件也各有各的特色，在这些软件的加持下，我们可以轻松的将不方便携带的电脑转变成为数据存储中心，再配合cpolar内网穿透创建的数据隧道，就可以轻松构建专属的私有云盘。今天，笔者就为大家介绍，如何使用Cpolar内网穿透+Net2FTP，打造私人专属的文件共享网站。
2. Net2FTP网站搭建 Net2FTP算是比较出名的web文件管理器，经常在将资料上传服务器时使用。Net2FTP基于Web技术，因此可以使用各种浏览器打开，并通过网页页面进行数据传输操作，因此使用范围很广，用来搭建自己的私有云盘正合适。
2.1. Net2FTP下载和安装 首先我们需要下载Net2FTP的安装文件，可以在其官网（net2ftp.com/）找到，这里笔者下载的是完整版。下载完成后，将下载好的压缩包解压，并粘贴到网页运行环境中。
笔者使用的是PHPstudy，因此将net2ftp_v1.3文件夹粘贴到www文件夹下。
接着打开phpstudy，点击左侧的网站按钮。在“网站”页面下，点击左上角的创建网站，对本地的net2ftp网站进行设置。
具体需要设置的内容很少也很简单，具体为：
域名：本地访问net2ftp网页所使用的域名端口：即网页输出端口根目录：即net2ftp网页文件存放的位置，也就是files_to_upload文件夹的位置，需要注意的是，下载的net2ftp_v1.3没法安装网站，安装文件在files_to_upload文件夹，根目录也必须定在这里勾选FTP和数据库 完成各项设置后点击下方的确认，就能完成net2ftp网站的搭建。
接着点击网站条目右侧的管理按钮，选择弹出菜单中的打开网站按钮，就能访问到本地net2ftp网站。此处要注意的是，必须将php扩展栏目中的ftp项目勾选，否则可能导致网页出错。
2.2. Net2FTP网页测试 只要phpstudy中对net2ftp网站的设置正确，就能打开net2ftp的本地网页。
由于net2ftp是FTP客户端的网页化界面，因此我们需要设置好本地电脑上的ftp服务。笔者使用的是filezilla作为ftp管理软件，因此打开filezilla界面，点击左上方“文件”菜单下的“站点管理器”。
在站点管理器中，新建一个站点:
主机栏位设置为12.0.0.1端口选择21号输入用户名和密码（此处的密码仅在ftp使用） 完成设置后，点击页面下方的确认创建该站点。
接着，我们将filezilla创建的ftp主机信息（包括地址和端口），填入net2ftp页面中，再填入用户名、密码、邮箱等信息，就能登录net2ftp网页，进行文件的上传下载。
3. cpolar内网穿透 在本地电脑上安装net2ftp网页并成功进行访问测试后，就可以进行Cpolar内网穿透的安装。Cpolar的安装注册也很简便。可直接在cpolar的官网页面（www.cpolar.com）找到下载按钮。
笔者使用的是Windows操作系统，因此选择Windows版本进行下载。
Cpolar下载完成后，将下载的文件解压，双击解压后的.msi文件，即可自动执行安装程序，一路点击“Next”就能完成安装。
由于cpolar会为每个用户创建独立的数据隧道，并辅以用户密码和token码保证数据安全，因此我们在使用cpolar之前，需要进行用户注册。注册过程也非常简单，只要在cpolar主页右上角点击“用户注册”，在注册页面填入必要信息，就能完成注册。
到这一步，我们完成了net2ftp页面的本地访问测试，也在本地电脑上安装了cpolar内网穿透软件，接下来我们就可以创建一条能够连接本地net2ftp的内网穿透数据隧道，让我们能在公共互联网上访问到本地net2ftp网站。
3.1.Cpolar云端设置 数据访问并没有特定时间，也就是随时可能发生，因此需要我们的内网穿透数据隧道能够长期稳定在线。但cpolar免费版的数据隧道每24小时重置一次，笔者并不想每天进行重连设置，因此笔者将cpolar升级至vip版，以便能获得能长期稳定存在的内网穿透数据隧道。
要达到内网穿透的目的，需要先登录cpolar的官网，并在用户主页面左侧找到预留按钮，并点击进入cpolar的数据隧道预留页面。
在这里生成一个公共互联网地址（也可以看做数据隧道的入口），由于此时这个地址没有连接本地的软件输出端口，因此也可以看做是一条空白的数据隧道。
在预留页面，可以看到很多种可保留的数据隧道，这里我们选择保留二级子域名栏位。
在“保留二级子域名”栏位，需要进行几项信息的简单设置，即
地区：服务器所在区域，就近选择即可二级域名：会最终出现在生成的公共互联网地址中，作为网络地址的标识之一描述：可以看做这条数据隧道的描述，能够与其他隧道区分开即可）。 完成这几项设置后，就可以点击右侧的“保留”按钮，将这条数据隧道保留下来。
当然，如果这条数据隧道不打算再使用，还可以点击右侧的“x”将其轻松删除，节约宝贵的隧道名额。
3.2.Cpolar本地设置 完成cpolar云端的设置，并保留了空白数据隧道后，我们回到本地的cpolar客户端，将云端生成的空白数据隧道与本地的测试页面连接起来，让我们能在公共互联网上访问到本地的测试页面。
在本地打开并登录cpolar客户端（可以在浏览器中输入localhost:9200直接访问，也可以在开始菜单中点击cpolar客户端的快捷方式）。
点击客户端主界面左侧隧道管理项下的创建隧道按钮，进入本地隧道创建页面（如果要创建没24小时重置地址的临时数据隧道，可直接在此进行设置，不必再cpolar官网设置空白数据隧道）。
在这个页面，同样需要进行几项信息设置，这些信息设置包括：
1. 隧道名称 – 可以看做cpolar本地的隧道信息注释，只要方便我们分辨即可；
2. 协议 – 由于的测试页面是网页，因此选择http协议；
3. 本地地址 – 本地地址即为本地网站的输出端口号，而默认输出端口为，因此这里也填入81；
4. 域名类型 – 在这个例子中，我们已经在cpolar云端预留了二级子域名的数据隧道，因此勾选“二级子域名”（如果预留的是自定义域名，则勾选自定义域名），并在下一行“Sub Domain”栏中填入预留的二级子域名，该例子中为“net2ftpweb”。如果打算创建临时数据隧道，则直接勾选“随机域名”，由cpolar客户端自行生成网络地址；
5. 地区 – 与cpolar云端预留的信息一样，我们依照实际使用地填写即可；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea01862ca919f2bfe95d7ed9f3446828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67abde7b636b00ff69f78314aa5ffcf/" rel="bookmark">
			Python 中 decimal 模块的用法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们开发工作中浮点类型的使用还是比较普遍的，对于一些涉及资金金额的计算更是不能有丝毫误差，Python 的 decimal 模块为浮点型精确计算提供了支持。
1.简介 decimal 模块设计以十进制数、算术上下文和信号这三个概念为中心。十进制数是不可变的，它有一个符号，系数数字和一个指数，为了保持重要性，系数数字不会截断尾随零，十进制数也有特殊值，
如：Infinity、-Infinity 和 NaN；算术上下文是指定精度、舍入规则、指数限制、指示操作结果的标志以及确定符号是否被视为异常的陷阱启用器的环境；信号是在计算过程中出现的异常条件组。对于 decimal 模块的设计原则，我们只需简单了解即可。
2.快速上手 Decimal 我们看一下 Decimal 实例的基本使用。示例如下：
from decimal import * print(Decimal(1.1) + Decimal(3.3)) print(Decimal(1.1) - Decimal(3.3)) print(Decimal(1.1) * Decimal(3.3)) print(Decimal(1.1) / Decimal(3.3)) #输出结果 ''' 4.399999999999999911182158030 -2.199999999999999733546474090 3.630000000000000097699626167 0.3333333333333333781908292778 ''' 使用 getcontext().prec 设定有效数字。示例如下：
from decimal import * print(Decimal(1.1) / Decimal(3.3)) getcontext().prec = 2 print(Decimal(1.1) / Decimal(3.3)) #输出结果 ''' 0.3333333333333333781908292778 0.33 ''' 设置小数位数。示例如下：
from decimal import * print(Decimal(1.1) / Decimal(3.3)) print((Decimal(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c67abde7b636b00ff69f78314aa5ffcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42987405f20cf80ea8119f9d1bfae564/" rel="bookmark">
			QT使用SQLite 超详细（增删改查、包括对大量数据快速存储和更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT+SQLite 在QT中使用sqlite数据库，有多种使用方法，在这里我只提供几种简单，代码简短的方法，包括一些特殊字符处理。在这里也给大家说明一下，如果你每次要存储的数据量很大，建议使用事务（代码中有体现），万条数据不到一秒吧。
用SQlite建立一个简单学生管理数据库 数据库中有两个表一个是class和student。
class表结构
student表结果
创建工程 我的工程如下：
直接上代码（看注释更通透） student.pro文件添加sql模块。
QT += core gui QT += sql #添加数据库模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets CONFIG += c++17 # You can make your code fail to compile if it uses deprecated APIs. # In order to do so, uncomment the following line. #DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0 SOURCES += \ main.cpp \ Student.cpp HEADERS += \ Student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42987405f20cf80ea8119f9d1bfae564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7fb1d4ca777273a75c6bd77e3b8c6b1/" rel="bookmark">
			国产化（三）：中间件——东方通TongWeb7.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 1、软件包和license文件 2、检查jdk是否安装 二、安装 1、创建tongweb文件夹 我是把软件包放在了桌面，通过命令将软件包移动到指定文件夹下。
1---切换到opt文件夹 cd /opt
2---查看文件夹里的文件 ls
3---创建tongweb文件夹 sudo mkdir tongweb
4---检查是否创建成功 ls
2、复制软件包 1---切换到tongweb文件夹 cd /opt/tongweb
2---复制软件包 sudo cp -r 软件包的当前路径 ./
3---查看是否复制成功 ls
4---赋予执行权限 sudo chmod 755 -R Install_TW7.0.3.0_Enterprise_Linux.bin
3、安装配置 进入创建的tongweb文件夹，右击打开终端，输入安装命令。
使用命令行方式安装 ./Install_TW7.0.3.0_Enterprise_Linux.bin -i console
使用图形界面方式安装 ./Install_TW7.0.3.0_Enterprise_Linux.bin
3.1 选择区域 3.2 选择Java虚拟机 3.3 选择安装文件夹 3.4 选择链接位置 3.5 预安装摘要 3.6 端口号设置 3.7 许可文件放置 将获取的许可license.dat放到TongWeb7.0根目录下，默认目录为/home/kylin/TongWeb7.0。
1---切换到TongWeb7.0根目录 cd /home/kylin/TongWeb7.0
2---查看该目录下的文件 ls
3---将license文件复制到该目录下 sudo cp -r license文件的当前路径 ./
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7fb1d4ca777273a75c6bd77e3b8c6b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486ae713cb4739f5a4ad301058f8a803/" rel="bookmark">
			科研神器：Vscode &#43; latex&#43;grammarly&#43;github copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科研论文编写神器：Vscode + latex + grammarly + github copilot 相信很多科研人都有使用latex排版及撰写论文的需求，我一开始使用的是在线编辑的overleaf，overleaf的优点是省事便捷，不用配置，并且支持版本回溯，如果图方便的话使用完全没有问题。
但是由于overleaf的服务器在国外，国内访问很慢，有时候虽然用科技编译也是非常慢，改一下编译要等半天甚至timeout，这对于一个急性子的人真的很难受，因此参考网上资料我决定使用vscode这个万能编译器配合来编写latex。
先介绍一下一通配置下来的优点吧
光速编译tex文件tex文件和pdf文件双向同步，单击任意一方另一方快速定位到相应位置多端同步，多人协同，版本回溯AI论文辅助编写及AI对话提问实时语法检查并一键修改TODO提示 第一步 latex环境配置 第一步是配置本地latex环境，笔者使用的是Tex Live，我们直接下载iso镜像就可以
网址：Acquiring TeX Live as an ISO image
下载后右键管理员权限运行install-tl-windows.bat
然后可以进行下载，你可以更改下载路径，texlive文件大概有7GB大小，最好别放在C盘，然后等待安装，直到出现欢迎界面才可以关闭，一定要耐心，安装过程需要一定时间
测试 下载完毕后，打开cmd，输入xelatex -v，如果出现版本信息，就是安装成功了
第二步 vscode插件 下载vscode这里就不赘述，移步网上教程
我们想在vscode中使用latex还需要配置一个插件，这里使用最常用的LaTeX Workshop插件
点击extension \ 扩展后搜索下载
下载完毕后还需要进行配置
打开setting后点击右上角任务栏的文件图标会出现setting.json
加入以下配置，如果原本有内容，则在原本内容最后加 , 后加入下面内容
如果原本没有内容，则先输入，在大括号中填充下面的内容
{ } 解释一下部分配置的内容信息，其余可以查询官方文档
"latex-workshop.latex.autoBuild.run"：设置什么时候进行自动的代码编译
“onSave”：保存时编译“onFileChange”：检测到有文件修改就编译“never”：从不自动编译 "latex-workshop.showContextMenu"：显示latex上下文菜单，这个打开之后会有很好的作用
本地配置latex的一个很好作用是可以实现双向同步，在左侧tex文件右键点击SyncTeX from cursor后，右侧会自动跳转定位到左侧光标所在的编辑区
"latex-workshop.view.pdf.internal.synctex.keybinding" 从右侧任意地方双击左侧会定位到该位置的代码区 "double-click"：和overleaf一样，双击"ctrl-click"：ctrl+鼠标左键 "latex-workshop.latex.autoBuild.run": "onSave", "latex-workshop.showContextMenu": true, "latex-workshop.intellisense.package.enabled": true, "latex-workshop.message.error.show": false, "latex-workshop.message.warning.show": false, "latex-workshop.latex.tools": [ { "name": "xelatex", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/486ae713cb4739f5a4ad301058f8a803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160ebd476be347d65eb73a027ef86ccc/" rel="bookmark">
			【数据结构】- 详解哈夫曼树（用 C 语言实现哈夫曼树的构造和哈夫曼编码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、哈夫曼树的基本概念
二、哈夫曼树的构造算法
2.1 - 哈夫曼树的构造过程
2.2 - 哈夫曼树的存储表示
2.3 - 算法实现
三、哈夫曼编码
3.1 - 哈夫曼编码的主要思想
3.2 - 哈夫曼编码的性质
3.3 - 算法实现
一、哈夫曼树的基本概念 哈夫曼树的定义，涉及路径、路径长度、权等概念，下面先给出这些概念的定义，然后再介绍哈夫曼树。
路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。
路径长度：路径上的分支数目称作路径长度。
树的路径长度：从树根到每一结点的路径长度之和。
权：赋予某个实体的一个量，对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有结点权和边权。结点权和边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应就有带权树等概念。
结点的带权路径长度：从树根到该结点的路径长度与该结点上权值的乘积。
树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作 。
在含有 n 个叶子结点的二叉树中，每个叶子结点的权值为 ，则其中 WPL 最小的二叉树称作最优二叉树或哈夫曼（Huffman）树。
例如，下图所示的 3 棵二叉树中，都含有 4 个叶子结点 a、b、c、d，分别带权 7、5、2、4。
其中 (c) 树的带权路径长度最小，可以验证，它恰为哈夫曼树。
哈夫曼树中具有不同权值的叶子结点的分布有什么特点呢？从上面的例子中，可以直观地发现，在哈夫曼树中，权值越大的结点离根结点越近。根据这个特点，哈夫曼最早给出了一个构造哈夫曼树的方法，称哈夫曼算法。
二、哈夫曼树的构造算法 2.1 - 哈夫曼树的构造过程 根据给定的 n 个权值 ，构造 n 棵只有根结点的二叉树，这 n 棵二叉树构成一个森林 F（Forest）。
在森林 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。
在森林 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/160ebd476be347d65eb73a027ef86ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852e489f321fa95fd3e5ce2d965c5763/" rel="bookmark">
			学生成绩管理系统（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发环境: Windows 11 IDEA 2021.3.3
需求:
package com.it.neu; import java.util.ArrayList; import java.util.Scanner; import static java.time.Clock.system; class Student { //创建学生类 private String Stu_name; private String Stu_id; public Student(String id, String name) { this.Stu_id = id; this.Stu_name = name; } public String getStu_name() { return Stu_name; } public void setStu_name(String stu_name) { Stu_name = stu_name; } public String getStu_id() { return Stu_id; } public void setStu_id(String stu_id) { Stu_id = stu_id; } } class Course { //创建课程类 private String Course_name; public Course(String course_name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852e489f321fa95fd3e5ce2d965c5763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7519b4cd8976f1863ba04981b73033/" rel="bookmark">
			数据结构——链式二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：哈喽小伙伴们，上篇文章我们讲述了一个特殊的二叉树——使用数组实现的堆的基本知识之后呢，从这篇文章开始，我们就正式进入普通二叉树的介绍啦，二叉树真正的难点——递归，即将来临，小伙伴们注意不要掉队哦。
目录
一.链式二叉树
二.遍历二叉树
三.二叉树的实现
1.二叉树的定义
2.创建二叉树节点
四.二叉树的操作
1.先序遍历
2.中序遍历
3.后序遍历
4.节点个数
递归分析
5.叶节点数
6.树的高度
7.第k层节点数
8.查找指定值节点
9.销毁二叉树
四.完整代码展示
1.BinaryTree.h
2.BinaryTree.c
3.test.c
五.总结
一.链式二叉树 在前边的文章中，我们已经了解到，二叉树可以有顺序存储和链式存储两种方式，在堆的文章中，我们讲解了顺序存储的完全二叉树，那么现在，我们一起来认识一下链式存储的普通二叉树。
我们知道，二叉树的规则是，每个节点至多有两个子节点，而两个子节点及其后续的子节点组成的整体，又可以分别称为左右子树，如右图所示，1为根节点，2和3则一起构成左子树，4、5、6则构成右子树。 而这两个子树，同样可以看做是由一个根节点和左右子树构成的新树。
所以，任何一个二叉树都可以被拆解为三部分：
根节点左子树右子树 由此看来，二叉树和递归离不开关系，后续二叉树的各种基本操作，也都是通过递归来实现的。
二.遍历二叉树 二叉树的遍历有三种方式：
1.前（先）序遍历：先遍历树的根节点，再遍历它的左子树，最后是右子树。
2.中序遍历：先遍历树的左子树，再遍历它的根节点，最后是右子树。
3.后序遍历：先遍历树的左子树，再遍历它的右子树，最后是根节点。
我们以这棵树为例：
前序遍历即为：1 2 3 4 5 6。
但是这样写其实并不合理，因为我们是用链表来写二叉树的结构的，所以对于节点2来说，它并不是没有右子树，而是右子树是空树。
同样的，3、5、6同样可以作为一颗树，不过它们的左右子树都是空树罢了。
所以合理的遍历方式应该把空树也带上，我们这里用N表示，于是：
前序遍历：1 2 3 N N N 4 5 N N 6 N N，如果用图形来表示，如下：
每一个方框都可以看做是一个新的树，从左到右依次为：根，左，右。如此，我们便也能写出中序遍历和后序遍历：
中序遍历：N 3 N 2 N 1 N 5 N 4 N 6 N，图形如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b7519b4cd8976f1863ba04981b73033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa64bba19968cbcb82bd51956c85b652/" rel="bookmark">
			旅行商问题（枚举，回溯，动态规划，贪心，分支界限）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述暴力枚举回溯法动态规划法贪心法分支界限法 问题描述 假设有一个货郎担要拜访n个城市，他必须选择所要走的路程，路程的限制时每个城市只能拜访一次，而且最后要走到原来出发的城市，要求路径长度。
旅行商问题将要走过的城市建立成一个完全图。稠密图，所以用临接矩阵来存。
由于路径的特殊性，可以正走也可以反着走，所以一般存在两条最优路径同时也可以用这条性质检验算法的正确性。
暴力枚举 使用dfs枚举每一个点， 不适用剪枝的话就是暴力枚举方法
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 10; int g[N][N], n, m; int cv = 0, bv = 0x3f3f3f3f; bool st[N]; vector&lt;int&gt; ans, x; void dfs(int k) { if (k == n) { // printf("before cv : %d\n", cv); // printf("last : {%d, %d} = %d\n", 1, x[k - 1], g[1][x[k - 1]]); cv += g[1][x[k - 1]]; x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa64bba19968cbcb82bd51956c85b652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7edccb0fc99a08216773dcea74f5248a/" rel="bookmark">
			Spring Boot 整合kafka：生产者ack机制和消费者AckMode消费模式、手动提交ACK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 生产者ack机制消费者ack模式手动提交ACK 生产者ack机制 Kafka 生产者的 ACK 机制指的是生产者在发送消息后，对消息副本的确认机制。ACK 机制可以帮助生产者确保消息被成功写入 Kafka 集群中的多个副本，并在需要时获取确认信息。
Kafka 提供了三种 ACK 机制的配置选项，分别是：
acks=0：生产者在成功将消息发送到网络缓冲区后即视为消息已被提交，不等待任何服务器响应。这种配置下，可能会出现消息丢失的情况。
acks=1：生产者在成功将消息发送到主题的分区 leader 后即视为消息已被提交。这种配置下，生产者会收到分区 leader
的确认，但仍有可能出现消息丢失的情况，例如当 leader 出现故障，而消息尚未复制到其他副本时。
acks=all 或acks=-1：生产者需要等待所有分区副本都成功写入消息后才视为消息已被提交。这种配置下，生产者会等待所有分区副本的确认，确保消息被复制到足够数量的副本后才返回提交确认。这是最安全的确认方式，但也会导致较长的等待时间。
在实际使用中，根据对消息可靠性和延迟的要求，可以选择不同的 ACKs 级别。一般来说，如果对消息的可靠性要求较高，可以选择较高的 ACKs 级别，但需要考虑相应的延迟成本。
我们可以通过spring.kafka.producer.acks来配置ack机制
spring.kafka.producer.acks=1 消费者ack模式 kafka支持的消费模式，在AbstractMessageListenerContainer.AckMode的枚举中，下面就介绍下各个模式的区别
public enum AckMode { /** * Commit after each record is processed by the listener. */ RECORD, /** * Commit whatever has already been processed before the next poll. */ BATCH, /** * Commit pending updates after * {@link ContainerProperties#setAckTime(long) ackTime} has elapsed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7edccb0fc99a08216773dcea74f5248a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856f9e7f14ab4c072a6f2fa74ee690e2/" rel="bookmark">
			前端实现主题（深色模式）切换的几种方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一：link 动态引入 通过改变link 标签的 href 属性实现动态修改样式（暂不推荐这种方案）
优点：实现了按需加载，提高了性能；
缺点：动态加载样式文件，可能会因为网络问题导致样式加载过慢；
可维护性较差，后续新增或修改主题较为麻烦。
方案二：提前引入样式，类名切换 在这个方案中，我们只有一个css文件，然后通过js来改变他的类名（也暂不推荐这种方案）
优点：相比方案一，不会因为网络问题导致样式切换延迟；
缺点：样式文件过大时可能会出现首屏加载过慢问题；
可维护性依旧较差，后续新增或修改主题较为麻烦；
方案三：CSS 滤镜 利用CSS3新增的filter属性（需求简单可以使用）
优点：一行代码实现黑色主题功能，简单易于维护；
缺点：不能满足需求的要求，不能实现对区域的主题颜色自定义；
方案四：CSS变量+类名切换（目前的主流方案） VUE3官方文档使用的解决方案（比较推荐），这一个方案也是我目前使用的方案
实现思路：首先定义几个我们需要的全局样式变量，之后定义几个集合属性&lt;html lang="en" data-theme="dark"&gt;（不同的主题样式），然后将其放在html根元素标签里，再动过js动态的切换这个集合属性就可以实现主题的切换，具体看以下代码；
优点：不会因为网络问题导致样式切换延迟；
在需要切换主题的地方利用 var0绑定变量即可，不存在优先级问题；
新增或修改主题方便灵活，仅需新增或修改 CSS 变量即可，在 var（）绑定样式变量的地 方就会自动更换；
缺点：首屏加载时会牺牲一些时间加载样式资源；
预览效果
具体实现
&lt;!DOCTYPE html&gt; &lt;!-- &lt;html lang="en" data-theme="light"&gt; --&gt; &lt;html lang="en" data-theme="dark"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;王国梁&lt;/title&gt; &lt;link rel="shortcut icon" href="./img/w.png" type="image/x-icon"&gt; &lt;!-- 引入谷歌字体 --&gt; &lt;link rel="preconnect" href="https://fonts.googleapis.com"&gt; &lt;link rel="preconnect" href="https://fonts.gstatic.com" crossorigin&gt; &lt;link href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856f9e7f14ab4c072a6f2fa74ee690e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d182474a83659f3aa124661a8428d75e/" rel="bookmark">
			工业机器人运动学与Matlab正逆解算法学习笔记（用心总结一文全会）（四）——雅可比矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 建立DH模型机器人正运动学机器人逆运动学机器人雅可比矩阵△ 机器人速度雅可比矩阵○ 雅可比矩阵相关概念○ 以二连杆平面机器人举例说明雅可比矩阵 △ 机器人雅克比矩阵与速度分析△ 雅克比矩阵的奇异性○ 机器人的奇异位形（奇异形位、奇异点） △ 雅可比矩阵的建立※ 相邻连杆间的速度关系○ 矢量积法· 矢量积法概念· 矢量积法求机器人雅可比矩阵示例 ○ 微分变换法· 坐标系的微分运动· 机器人的微分运动· 微分变换法概念※ 关于相对于末端（工具）坐标系的雅可比矩阵 · 微分变换法求2连杆机械臂雅可比矩阵示例 ○ 矢量积法与微分变换法的转换关系○ matlab机器人工具箱法· jacob0()· jacobn()· 雅可比矩阵的变换· matlab代码 △ ZK-500六轴工业机器人的雅可比矩阵○ 矢量积法· 求 i 0 T {_i^0}T i0​T· 求 z i z_i zi​· 求 i p 6 {_\ ^i}p_6 i​p6​· 求 i p 6 0 {_\ ^i}p_6^0 i​p60​· 求 J i J_i Ji​· 雅可比矩阵 ※ 矢量积法matlab程序验证· 计算过程matlab符号变量表示· 雅可比矩阵计算结果对比机器人工具箱验证 ○ 微分变换法 CSDN提示我字数太多，一篇发不下，只好拆分开。。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d182474a83659f3aa124661a8428d75e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/556/">«</a>
	<span class="pagination__item pagination__item--current">557/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/558/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>