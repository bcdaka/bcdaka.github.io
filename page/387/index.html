<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7c436d5e85128fefa059f1aa174b66/" rel="bookmark">
			Python与OpenCV：图像处理与计算机视觉实战指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和机器学习软件库，它包含了数百种计算机视觉算法，包括图像处理、视频分析、物体检测、面部识别等。结合Python语言的强大功能，OpenCV可以用于快速开发复杂的图像处理和计算机视觉应用。本文将介绍如何使用Python和OpenCV进行图像处理，并提供一个简单的实践示例。
1. OpenCV与Python的结合 Python是一种易于学习和使用的脚本语言，而OpenCV提供了丰富的图像处理功能。通过Python调用OpenCV库，可以方便地实现图像的基本操作和高级处理。
2. 安装OpenCV 在Python中使用OpenCV之前，需要先安装它。可以通过pip安装：
pip install opencv-python 安装完成后，可以通过以下代码检查OpenCV是否安装成功：
import cv2 print(cv2.__version__) 安装报错升级即可
安装成功
3. 图像的基本操作 使用OpenCV进行图像处理的第一步通常是读取图像。以下是一个读取图像并显示的基本示例：
import cv2 # 读取图像 image = cv2.imread('path_to_image.jpg') # 显示图像 cv2.imshow('Image', image) # 等待用户按键然后关闭窗口 cv2.waitKey(0) cv2.destroyAllWindows() 请将'path_to_image.jpg'替换为你的图像文件路径。
4. 实战示例：边缘检测 边缘检测是图像处理中的一个重要任务，用于识别图像中的轮廓和边界。OpenCV提供了多种边缘检测算法，如Canny边缘检测。以下是一个使用Canny算法进行边缘检测的示例：
import cv2 import numpy as np # 读取图像 image = cv2.imread('path_to_image.jpg', cv2.IMREAD_GRAYSCALE) # 应用Canny边缘检测 edges = cv2.Canny(image, threshold1=100, threshold2=200) # 显示原始图像和边缘检测结果 cv2.imshow('Original Image', image) cv2.imshow('Edge Detection', edges) # 等待用户按键然后关闭窗口 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c7c436d5e85128fefa059f1aa174b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681afe9ada666bec4055894d4b6fd2fd/" rel="bookmark">
			2024最新版JavaScript逆向爬虫教程-------基础篇之JavaScript混淆原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、常量的混淆原理1.1 对象属性的两种访问方式1.2 十六进制字符串1.3 Unicode字符串1.4 字符串的ASCII码混淆1.5 字符串常量加密1.6 数值常量加密 二、增加 JS 逆向者的工作量2.1 数组混淆2.2 数组乱序2.3 花指令2.4 jsfuck 三、代码执行流程的防护原理3.1 流程平坦化3.2 逗号表达式混淆 四、其他代码防护方案4.1 eval加密4.2 内存爆破4.3 检测代码是否格式化 一、常量的混淆原理 示例代码：
Date.prototype.format = function (formatStr) { let str = formatStr; let Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); // console.log(str); str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1) .toString() : '0' + (this.getMonth() + 1)); // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681afe9ada666bec4055894d4b6fd2fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d991d9df4d2189c68fda073f54a150/" rel="bookmark">
			Kafka如何将消息发送到指定分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 面试一个时，面试官问了一个问题，Kafka如何做到顺序消息。我回答只给Kafka的Topic创建一个分区，发送到该Topic的消息在Kafka中就是有序的。
面试官又问，如果Topic有多个分区呢？我回答消息发送者在发送消息的时候，指定分区进行发送，可以在发送消息时，每次指定相同的Key。但是面试官说这样做不到，我后面去查了资料，是可以做到的，我当时也没有反驳，毕竟我是一个求职者，跟面试官产生冲突也不太好。而且可能面试官也只知道其他的方式，不知道基于这种方式可以将消息发送到指定分区。
写个博客记录下。
有哪些方式可以将消息发送到指定分区？ 当一个Topic中有多个分区的时候，如何将消息发送到指定分区呢？
方式一：基于key 下面的第二个参数，partitionA就是message的key。
Kafka会将具有相同的key的消息发送到同一分区，这是通过哈希函数实现的。
此外，Kafka会按照消息产生的顺序被一致性的接受，这就保证了同一分区内消息的顺序性。
kafkaProducer.send("order-topic", "partitionA", "critical data"); kafkaProducer.send("order-topic", "partitionA", "more critical data"); kafkaProducer.send("order-topic", "partitionA", "another more critical data"); 方式二：自定义分区器 Kafka允许自定义分区器，允许用户根据Topic、message key、message val、cluster等信息，自定义将消息发送到哪个分区。
自定义分区器：
public class CustomPartitioner implements Partitioner { // PREMIUM的意思是额外加价 private static final int PREMIUM_PARTITION = 0; // NORMAL的意思是正常、标准 private static final int NORMAL_PARTITION = 1; @Override public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) { String customerType = extractCustomerType(key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d991d9df4d2189c68fda073f54a150/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a3efa1110ae58ff30abacbce34ac02/" rel="bookmark">
			Android多屏显示——Presentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Presentation 介绍 要了解 API 的具体调用，推荐先查看官方的文档：Presentation文档
Android 从4.2开始支持双屏显示，开发时需 minSdkVersion &gt;= 17 。Android 连接两个屏幕时，自动分配主屏和副屏，主屏显示正常的 Activity 界面，副屏通过创建 Presentation 类来实现。
通过查看 Presentation 继承关系可知，Presentation 继承自 Dialog，创建的时候需要遵循 Dialog 相关要求。当和 Presentation 相关联的屏幕被移除后，Presentation 也会自动的被移除，所以当 Activity 处于 pause 和 resume 的状态时，Presentation 也需要特别注意当前显示的内容的状态。
二、Presentation 实现 首先建立一个空工程，然后创建MyPresentation类继承Presentation类，由于我需要在副屏界面创建2个Button，并监听点击事件所以我implements了View.OnClickListener接口。
//MyPresentation.java package com.example.multidisplaydomo; import android.app.Presentation; import android.content.Context; import android.os.Bundle; import android.view.Display; import android.view.View; import android.widget.Button; import android.widget.Toast; public class MyPresentation extends Presentation implements View.OnClickListener{ public MyPresentation(Context context, Display display){ super(context,display); } @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7a3efa1110ae58ff30abacbce34ac02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52bb1cc65cbd23483c815d7eee507b9/" rel="bookmark">
			spring Ai框架整合Ollama，调用本地大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ollama使用 Ollama是一个用于在本地计算机上运行大模型的软件
软件运行后监听11434端口，自己写的程序要调大模型就用这个端口
ollama命令
ollama list：显示模型列表
ollama show：显示模型的信息
ollama pull：拉取模型
ollama push：推送模型
ollama cp：拷贝一个模型
ollama rm：删除一个模型
ollama run：运行一个模型
ollama全是命令行下操作，所以结合web客户端界面使用【安装可选】
主流的web工具
1 Openwebui
2 LobeChat,功能强大，可调用Ollama的模型，也可调用openai,google的等，在设置界面中配置url和key即可
spring Ai框架调用 1 pom.xml，注意添加的依赖和配置了仓库
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-ollama&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-ai-ollama&lt;/name&gt; &lt;description&gt;spring-ai-ollama&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;spring-ai.version&gt;0.8.1&lt;/spring-ai.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springboot.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-ollama-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52bb1cc65cbd23483c815d7eee507b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf681969dedfd7f812a960c2c7cbc5c9/" rel="bookmark">
			git提交错了？别慌，直接删除提交记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要删除提交历史 前几天产品提了个很扯淡的需求，我在代码了进行了吐槽....
要命的是我不下心进行了代码提交：
我们的远程仓库大家都能看见的
这要是被其他人发现就惨了！当务之急，我必须立刻马上删除这一条提交记录！！
于是，我打开百度，搜索到两个救命关键词：git revert和git reset！这两个命令都有撤销操作的功能！
使用git revert撤销提交 revert的英文释义是回复、恢复（到原来的状态）
作用 git revert 是 Git 中用于撤销一个或多个提交的命令，但是会保留历史记录。它创建一个新的提交，该提交是对原提交的相反操作，以撤销原提交的更改。通过 git revert 撤销提交，可以保持历史记录的完整性，不会修改已经共享的提交历史。
语法 撤销单个提交：
git revert &lt;commit-hash&gt; 这会创建一个新的提交，用于撤销指定的提交 的更改。
撤销多个提交：
git revert &lt;commit-hash1&gt; &lt;commit-hash2&gt; ... 这会为每个指定的提交创建一个新的撤销提交。
撤销最近的提交：
git revert HEAD 撤销某个范围内的提交：
git revert &lt;commit-hash1&gt;^..&lt;commit-hash2&gt; 这会撤销从 （不包括）到 （包括）范围内的所有提交。
撤销提交时，Git 会打开一个文本编辑器，让你输入撤销提交的信息。你可以修改默认的提交信息，然后保存并关闭编辑器。
撤销实操 不管3721，我们先试着用它撤销下提交试试。
先试用git log（其他可视化面板也行）找到要撤销的commit哈希码
b1b56b50a0859556623283946972e495d4a42fc1 然后，执行单个文件撤销命令
git revert b1b56b50a0859556623283946972e495d4a42fc1 执行命令后，控制台会出现vim编辑器，让我们为本次更改提交说明
vim编辑器小技巧
进入编辑模式：进入编辑模式的方式取决于当前编辑器的模式。通常情况下，按下 i 键可以进入插入模式，允许你编辑文本。
编辑文本：在插入模式下，你可以编辑文本。使用方向键或者 h, j, k, l 键移动光标。
退出编辑模式：编辑完成后，按下 Esc 键退出插入模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf681969dedfd7f812a960c2c7cbc5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a3a81baa52ab31098af99091124a85/" rel="bookmark">
			智能消费记账|基于SSM&#43;vue的大学生智能消费记账系统(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能消费记账目录
基于SSM+vue的大学生智能消费记账系统
一、前言
二、系统设计
三、系统功能设计 1 用户列表
2 预算信息管理
3 预算类型管理
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SSM+vue的大学生智能消费记账系统 一、前言 大学生智能消费记账系统采用的是WEB应用程序开发中最受欢迎的B/S三层结构模式，使用占用空间小但功能齐全的MySQL数据库进行数据的存储操作，系统开发技术使用到了JSP技术。该大学生智能消费记账系统能够解决许多传统手工操作的难题，比如数据查询耽误时间长，数据管理步骤繁琐等问题。总的来说，大学生智能消费记账系统性能稳定，功能较全，投入运行使用性价比很高。
关键词：大学生智能消费记账系统；MySQL数据库；SSM技术
二、系统设计 系统功能结构如图
三、系统功能设计 1 用户列表 如图5.1显示的就是用户列表页面，此页面提供给管理员的功能有：查看用户、新增用户、修改用户、删除用户等。
图5.1 用户列表页面
2 预算信息管理 管理员可以对前台的注册用户的基本信息进行管理，可以设置注册用户的账号为冻结或者是在用状态，管理员也能选择很多个已经失效的注册用户的信息进行批量删除操作。注册用户管理界面如图5.2所示。
图5.2 预算信息管理页面
3 预算类型管理 预算类型管理页面显示所有预算类型，在此页面既可以让管理员添加新的预算信息类型，也能对已有的预算类型信息执行编辑更新，失效的预算类型信息也能让管理员快速删除。下图就是预算类型管理页面。预算类型管理界面如图5.3所示。
图5.3预算类型管理界面
四、数据库设计 数据库表的设计，如下表：
大学生智能消费记账系统的一些数据表。
表4.1字典表
序号
列名
数据类型
说明
允许空
1
Id
Int
id
否
2
dic_code
String
字段
是
3
dic_name
String
字段名
是
4
code_index
Integer
编码
是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a3a81baa52ab31098af99091124a85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8d98fc32b5e21cb69085328f65ae71/" rel="bookmark">
			【C&#43;&#43;庖丁解牛】C&#43;&#43;11---lambda表达式 | 包装器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍁你好，我是 RO-BERRY 📗 致力于C、C++、数据结构、TCP/IP、数据库等等一系列知识 🎄感谢你的陪伴与支持 ，故事既有了开头，就要画上一个完美的句号，让我们一起加油 目录 1. lambda表达式1.1 C++98中的一个例子1.2 lambda表达式1.3 lambda表达式语法1.4. 捕获列表说明1.5 函数对象与lambda表达式 2.包装器2.1 bind 1. lambda表达式 1.1 C++98中的一个例子 在C++98中，如果想要对一个数据集合中的元素进行排序，可以使用std::sort方法。
#include &lt;algorithm&gt; #include &lt;functional&gt; int main() { int array[] = { 4,1,8,5,3,7,0,9,2,6 }; // 默认按照小于比较，排出来结果是升序 std::sort(array, array + sizeof(array) / sizeof(array[0])); // 如果需要降序，需要改变元素的比较规则 std::sort(array, array + sizeof(array) / sizeof(array[0]), greater&lt;int&gt;()); return 0; } 在这里，greater是一个函数对象（function object），它是C++标准库中的一个模板类，用于比较两个元素的大小关系。greater是一个用于降序排序的比较器，它会将较大的元素排在前面。
如果待排序元素为自定义类型，需要用户定义排序时的比较规则：
#include&lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;string&gt; #include &lt;vector&gt; struct Goods { string _name; // 名字 double _price; // 价格 int _evaluate; // 评价 Goods(const char* str, double price, int evaluate) :_name(str) , _price(price) , _evaluate(evaluate) {} }; struct ComparePriceLess { bool operator()(const Goods&amp; gl, const Goods&amp; gr) { return gl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc8d98fc32b5e21cb69085328f65ae71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b9185f0f35de464daf53f3e88c135b/" rel="bookmark">
			MySQL如何设计库表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 在设计数据库时，表结构的设计是至关重要的。合理的表结构设计不仅可以提高数据库的性能，还可以使数据更加清晰、易于维护。MySQL作为一种流行的关系型数据库管理系统，其表结构设计也遵循一定的原则和最佳实践。本文将介绍MySQL表结构设计的一些基本步骤和注意事项。
二、需求分析 在设计表结构之前，首先要进行需求分析。了解系统的业务需求、数据需求和性能需求，是设计合理表结构的前提。需求分析的主要内容包括：
数据实体识别：确定系统中需要存储哪些数据实体（如表、视图、索引等）。属性分析：分析每个数据实体的属性（如字段名、数据类型、长度、约束等）。关系分析：确定数据实体之间的关系（如一对一、一对多、多对多等）。 三、设计原则 在设计MySQL表结构时，应遵循以下原则：
1. 规范化 第一范式（1NF）：确保每列都是不可分割的原子项。第二范式（2NF）：在满足1NF的基础上，确保非主键列完全依赖于主键列。第三范式（3NF）：在满足2NF的基础上，确保非主键列之间不存在传递依赖关系。 规范化有助于消除数据冗余，提高数据完整性和一致性。但过度的规范化可能会导致查询性能下降，因此在实际应用中需要权衡利弊。
2. 字段设计 选择合适的数据类型：根据字段的取值范围和特点选择合适的数据类型，如INT、VARCHAR、DATE等。设置合适的字段长度：避免使用过长的字段长度，以节省存储空间和提高查询性能。使用默认值：为字段设置默认值可以简化数据插入操作，并减少数据冗余。避免使用NULL：尽量避免在字段中使用NULL值，因为NULL值在查询和计算中可能会带来麻烦。可以使用NOT NULL约束和默认值来替代。 3. 索引设计 选择合适的索引类型：MySQL支持多种索引类型，如B-Tree索引、哈希索引等。根据查询需求和数据特点选择合适的索引类型。避免过度索引：过多的索引会占用额外的存储空间并降低写操作的性能。因此，在设计索引时要权衡利弊，选择必要的索引。使用复合索引：当查询条件涉及多个字段时，可以考虑使用复合索引来提高查询性能。但需要注意复合索引的列顺序和查询条件的匹配度。 4. 主键设计 使用自增主键：自增主键可以确保数据的唯一性，并简化插入操作。但需要注意自增主键的溢出问题。避免使用业务字段作为主键：业务字段的值可能会发生变化，如果将其作为主键可能会导致数据更新和删除操作的复杂性增加。 5. 关联设计 使用外键约束：外键约束可以确保数据的引用完整性，防止无效数据的产生。但需要注意外键约束对性能的影响。优化关联查询：在设计关联查询时，要注意关联条件的匹配度和查询结果的返回量。可以使用JOIN操作来优化关联查询的性能。 四、表结构设计实例 以一个简单的电商系统为例，介绍MySQL表结构的设计过程：
1. 用户表（users） 字段名数据类型长度/值约束idINT11主键、自增usernameVARCHAR50NOT NULL、唯一passwordVARCHAR255NOT NULLemailVARCHAR100NOT NULL、唯一phoneVARCHAR20NOT NULL、唯一create_timeDATETIME默认值为当前时间 2. 商品表（products） 字段名数据类型长度/值约束idINT11主键、自增nameVARCHAR255NOT NULLdescriptionTEXTpriceDECIMAL10,2NOT NULLstockINT11NOT NULLcategory_idINT11外键，关联商品分类表 3. 订单表（orders） 当然，让我们继续完善订单表的设计。在实际应用中，订单表可能会包含更多的字段，以记录订单的各种状态和详细信息。以下是一个更完整的订单表设计示例：
字段名数据类型长度/值约束描述idINT11主键、自增订单的唯一标识符user_idINT11外键，关联用户表下单用户的IDorder_numberVARCHAR50NOT NULL、唯一订单编号，用于唯一标识订单total_priceDECIMAL10,2NOT NULL订单总价create_timeDATETIME默认值为当前时间订单创建时间update_timeDATETIME记录订单最后一次更新的时间statusENUM(‘pending’, ‘processing’, ‘shipped’, ‘completed’, ‘cancelled’)NOT NULL订单状态（待处理、处理中、已发货、已完成、已取消）shipping_addressTEXT配送地址，可存储为JSON或其他格式payment_methodENUM(‘credit_card’, ‘paypal’, ‘bank_transfer’, ‘cod’)NOT NULL支付方式（信用卡、PayPal、银行转账、货到付款）payment_statusENUM(‘pending’, ‘paid’, ‘failed’)NOT NULL支付状态（待支付、已支付、支付失败）tracking_numberVARCHAR50可为空物流追踪号码coupon_codeVARCHAR50可为空使用的优惠券代码notesTEXT可为空用户或管理员备注 4. 订单项表（order_items） 字段名数据类型长度/值约束idINT11主键、自增order_idINT11外键，关联订单表product_idINT11外键，关联商品表quantityINT11NOT NULLunit_priceDECIMAL10,2NOT NULL 5. 商品分类表（categories） 字段名数据类型长度/值约束idINT11主键、自增nameVARCHAR255NOT NULLdescriptionTEXT 五、总结 在设计MySQL表结构时，我们需要根据业务需求和数据特点进行需求分析，并遵循规范化、字段设计、索引设计、主键设计和关联设计等原则。通过合理的表结构设计，我们可以提高数据库的性能和可维护性，为系统的稳定运行提供有力的支持。同时，还需要注意在实际应用中权衡利弊，选择适合的表结构和索引策略。希望本文能对您在设计MySQL表结构时提供一些帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939b5e9a342596dd2cab30d770354edd/" rel="bookmark">
			Redis第15讲——RedLock、Zookeeper及数据库实现分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于篇幅原因，在上篇文章我们只介绍了redis实现分布式锁的两种方式——setnx和Redission，并对Reidssion加锁和看门狗机制的源码进行了分析，但这两种方案在极端情况下都会出现或多或少的问题。那么针对上述问题，比较主流的解决方案有两种：RedLock和Zookeeper实现的分布式锁。
ps：我们上篇文章提到过主流的分布式锁实现方案有zookeeper、redis和数据库，所以本节也会顺带介绍一下数据库实现分布式锁。
一、数据库 ps：这里就简单介绍一下。
最简单的方式可能就是直接创建一张锁表，然后通过该表的数据来实现。
表的字段可以是：id、method_name(唯一约束)、update_time等：
加锁：当我们想要锁住某个方法时，可以在表中insert一条数据，因为我们对method_name做了唯一性约束，所以这时如果有多个请求的话，数据库可以保证只有一个操作可以成功。解锁：当方法执行完毕可以用删除语句来解锁。 存在的问题：
锁没有失效时间，一旦解锁失败，其它线程就无法获得锁。
解决：弄个定时任务定时清理一遍。
非阻塞锁，一旦插入失败就会直接报错，没有获得锁的线程并不会排队等待。
解决：可以while循环把它变成阻塞的。
非重入，同一个线程在释放锁之前无法再次获得该锁。
解决：可以在表中加个记录获得锁的主机信息和线程信息，下次再获取的时候先查一把数据库。
虽然有对应的解决方案，但是这些解决方案的背后又都是问题，比如定时任务这个，假如任务还没执行完，定时任务就把锁给清理了；而且数据库也需要一定的开销，所以不推荐使用数据库实现分布式锁。
二、RedLock 进入正题。
简单来说RedLock是Redis的作者Antirez在单Redis节点基础上引入的高可用模式。
2.1 为什么要使用RedLock 在上篇文章也提到过，不管是用原生的setnx命令还是用Reidssion实现的分布式锁，它们都无法解决Reids在主从复制、哨兵集群下的多节点问题：
线程A在Matser上获取锁。在Key的写入被传输到Slave之前，Matser崩溃。Slave被提升为主节点。线程B 获取了与线程A已经持有锁相同的锁。 这个场景同一把锁被两个线程同时持有，这是不被允许的，所以Redis的作者提出RedLock算法来应对这种问题。
2.2 RedLock加锁原理 RedLock通过使用多个Redis节点，来提供一个更加健壮的分布式锁解决方案，能够在某些Redis节点故障的情况下，仍然能够保证分布式锁的可用性。
假设我们有N个Redis主节点，例如N=5，这些节点是完全独立的，我们不适用赋值或任何其它隐式协调系统，为了取到锁，客户端应该执行以下操作（来自Redis官方文档）：
获取当前时间（毫秒）。依次从5个节点，使用相同的key和随机值（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个超时时间，这个时间要远小于锁失效的时（例如，如果自动释放时间为 10 秒，超时时间可能在 5-50 毫秒范围内）。这可以防止客户端在尝试与宕机的 Redis 节点通信时被长时间阻塞：如果一个实例不可用，客户端应该尽快尝试与下一个实例通信。客户端计算获取锁所用的时间减去步骤1的时间，就获得了获取锁消耗的时间。当前仅当大多数（N/2+1,这里是3个节点）的Redis节点都获取到锁，并且获取锁使用的时间小于锁失效的时间，锁才算获取成功。成功获取锁后，key的真正有效时间=TTL-锁的获取时间-时钟漂移（2.5小节会提）。如果客户端由于某种原因未能获取锁（无法锁定 N/2+1 个实例或有效时间为负），它将尝试解锁所有实例（甚至是它认为自己无法锁定的实例）。 ps：加锁失败的实例也要执行解锁操作的原因是：可能会出现服务端响应消息丢失但实际上成功了的情况。
2.3 存在的问题 上述看着似乎挺完美的，但在实际工作中，用的并不多，主要有两个原因：该方案的使用成本较高、且并不能完全解决分布式锁的问题：
假设现在还是5个Redis节点，线程A此时已经在三个节点上获取到了锁，表示已经加锁成功了，那么极端场景下就会出现问题：
严重依赖系统时间：如果获取到锁的三个节点中的某个节点时间稍微快一点，则它持有的锁就会被提前释放，当他释放后，就又有3个实例空闲了，这时线程2也可以获取到锁，就又出现了两个线程同时持有了锁。
假设redis没有配置持久化：3个节点中的某一个节点重启了，此时又有3个节点空闲了，然后另一个线程又可以加锁成功了。
在脑裂（网络分区）的情况下，RedLock也可能会产生两个线程同时持有锁的情况。
还有一个性能问题：setnx和Redission实现的分布式锁只需要在一个节点写成功就行了，而RedLock需要写多个节点才算加锁成功。
2.4 如何使用 在Redission客户端中也实现了基于Redis的RedLock加锁算法：
Config config1=new Config(); config1.useSingleServer().setAddress("redis://127.0.1.1:6379"); Config config2=new Config(); config1.useSingleServer().setAddress("redis://127.0.1.1:6378"); Config config3=new Config(); config1.useSingleServer().setAddress("redis://127.0.1.1:6377"); RedissonClient redissonClient1 = Redisson.create(config1); RedissonClient redissonClient2 = Redisson.create(config2); RedissonClient redissonClient3 = Redisson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/939b5e9a342596dd2cab30d770354edd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660aa8f7c3082b8e400eaecddd73fe61/" rel="bookmark">
			【如何成功安装 Python 软件包 weditor】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何成功安装 Python 软件包 weditor 在进行软件开发或者使用 Python 进行编程时，经常会遇到需要安装第三方软件包的情况。然而，有时候安装过程并不顺利，可能会遇到各种问题。在本文中，我将分享我解决安装 Python 软件包 weditor 的过程，并介绍了一个成功的解决方法。
背景 最近，我需要在我的 Python 环境中安装 weditor 这个软件包，用于编写 atx 脚本。然而，当我尝试使用常规的 pip install weditor 命令安装时，遇到了一些困难。
问题描述 在尝试使用 pip install weditor 命令安装 weditor 时，出现了如下错误：
[metadata] name = weditor author = codeskyblue author_email = codeskyblue@gmail.com summary = tool for writing atx script license = MIT home_page = https://github.com/openatx/weditor description_file = README.md classifier = Environment :: Console Intended Audience :: Developers Operating System :: OS Independent Programming Language :: Python [files] packages = weditor [entry_points] console_scripts = weditor = weditor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/660aa8f7c3082b8e400eaecddd73fe61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c72938dd2ad3c8b81f615fcabe33599/" rel="bookmark">
			AI智能体｜使用扣子Coze搭建AI智能体，看这一篇就够了（新手必看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是无界生长。
今天分享下如何使用Coze（扣子）搭建AI智能体，手把手教学，流程超级详细，学会了的话，欢迎分享转发！
搭建AI智能体 创建Bot 登陆Coze国内官网：Coze ，点击“创建Bot”
按照实际情况填写Bot信息，图标可以本地上传图片，也可以通过AI生成，填写完成后，点击“确认”按钮
编写提示词 进入Bot的编辑页面，左侧的编排，可以选择Bot运行模式和使用的大语言模型。
运行模式支持“单Agent模式”和“多Agents模式”，“单Agent模式”适合处理简单的逻辑，“多Agents模式”适合处理复杂的逻辑。咱们的示例比较简单，选择“单Agent模式”。
大语言模型支持“云雀语言模型”和“moonshot”（月之暗面的Kimi），选择Coze自带的“云雀语言模型”即可，你也可以调整为使用“moonshot”的模型，推荐选32k的。
在左侧的“人设与回复逻辑”下方，填写Bot的提示词，提示词内容一般与Bot的功能相关，填写完成后，可以点击右上角的“优化”按钮，让Coze帮你优化一下提示词。
为Bot添加技能 添加知识库 点击知识库右边的“+”号
选择知识库，这里选择我们之前创建好的知识库，点击“添加”按钮
知识库添加成功后，如下图所示：
可以看到知识库已经添加进来了，右边保持默认的“自动调用”即可。
设置开场白 可以给Bot添加开场白，用户体验更好。添加开场白支持Markdown编辑器
插入用户昵称 在Markdown编辑器里面，可以看到开场白文案支持插入图片、插入链接、插入用户昵称，我们在开场白中插入用户昵称，在右侧的预览界面可以看到效果。
预览与调试 Bot的提示词和技能添加完成后，可以在右侧的预览与调试界面，调试Bot
测试Bot是否会检索知识库 可以看到Bot有尝试从知识库获取信息
测试Bot使用外部资源是否会引用网址链接 可以看到在回答末尾，有引用链接
发布Bot 调试完成，确认Bot功能正常后，点击右上角的“发布”按钮，发布Bot
填写发布记录，选择发布平台。默认授权的平台是 Bot Store 和豆包，其他平台需要手动授权。这里演示发布Bot到 Bot Store 和豆包，勾选发布平台后，点击右上角的“发布”按钮。
发布完成
使用AI智能体 查看Bot 发布完成后，在个人空间的 Bots 标签下，可以看到刚才创建的 Bot
在 Bot 商店搜索 Bot 名称：“无界生长的AI助手”，也可以搜到
使用Bot 与Bot对话，测试Bot功能是否正常
总结 本文详细的介绍了通过Coze平台创建和发布AI智能体的流程，包括填写Bot信息、编写提示词、添加技能和知识库、设置开场白、预览调试，最后发布到平台供用户使用。如果看完还没学会的话，可以私信我。学会了的话，欢迎转发分享给你的朋友们。
我是无界生长，如果你觉得我分享的内容对你有帮助，麻烦点个关注，带你一起玩转AI！
AI学习资料在微信公众号：无界生长，个人微信：wjsz2070
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e0cef829b5efe70eee18a3db5e438d/" rel="bookmark">
			Flutter 弃用 WillPopScope 使用 PopScope 替代方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 弃用 WillPopScope 使用 PopScope 替代方法 视频 https://youtu.be/u3qdqUvFWiM
https://www.bilibili.com/video/BV1aJ4m1n7FZ
前言 原文 https://ducafecat.com/blog/migrating-from-willpopscope-to-popscope-in-flutter
了解如何在 Flutter 3.16 中将弃用的 WillPopScope 替换为 PopScope，并学习如何升级您的 Flutter 应用程序。详细指南和最佳实践，帮助您顺利迁移和更新您的导航逻辑。
Flutter, WillPopScope, PopScope, 替换指南, 迁移, 最佳实践, Flutter 3.19 迁移
参考 Flutter 官方文档 - NavigatorFlutter 官方文档 - PopScopeFlutter 官方文档 - WillPopScopeFlutter 社区 - FlutterDev PopScope 组件定义 /flutter/lib/src/widgets/pop_scope.dart
class PopScope extends StatefulWidget { /// Creates a widget that registers a callback to veto attempts by the user to /// dismiss the enclosing [ModalRoute].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1e0cef829b5efe70eee18a3db5e438d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd74759e161cd45fc285870c75ade0c/" rel="bookmark">
			ES的安装以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
在window上安装ES
1. 下载安装包
2.下载后解压
3.验证安装结果
4.修改yml配置文件
5.创建Kibana用户
安装 kibana
1.下载与Elasticsearch 相同版本的 kibana
2.配置
3.启动 Kibana服务
3.输入用户密码
使用
安装IK分词器
1.下载
2.创建ik目录
3.重启
在window上安装ES 1. 下载安装包 地址：Download Elasticsearch | Elastic
点击 View past releases 可以找到所有版本，请选择8.12.2的windows版本
这边我选择的是8.12.2的版本,不使用最新版本是因为还没有相对应的IK分词器插件
2.下载后解压 双击 elasticsearch.bat 启动 elasticsearch 服务
注:第一次启动时, 要注意此时的 ip 地址(注意下自己的虚拟机或者vpn, 它们的ip可能会产生干扰), 该 ip 地址会被绑定到 enrollment token 中, 在安装 Kibana 时有用
ES的默认端口是9200,如果需要修改端口可以在配置类中修改
我这里修改是因为端口冲突了所以修改了
启动后第一次会显示一些配置信息,包括默认的用户密码 elastic 和 XbeTTn2EX0*gpBQJ7QMU
第一次启动会打印以下内容, 账号和密码用记事本记录起来
第二次启动不会再打印密码,关闭前先保存你的密码
3.验证安装结果 在浏览器中输入如下链接和用户名密码
https://localhost:9201/ 端口要跟你配置类中的一样
出现以下内容, 则代表启动成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebd74759e161cd45fc285870c75ade0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd57d088d7db1844019567ebfad6c487/" rel="bookmark">
			探讨AIGC技术的发展现状和未来趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 每日一句正能量前言技术应用一、AIGC对未来产生了革命性影响二、AIGC将助力元宇宙数字经济的加速发展三、AIGC将加速出版业数字化智能化的转型升级四、AIGC的未来发展趋势及影响 伦理与风险未来展望后记 每日一句正能量 懒人做工作，越懒越费力。
前言 AIGC技术（Artificial Intelligence in Game Creation）是一种结合人工智能和游戏开发的创新技术，旨在提升游戏设计和开发的效率和质量。随着人工智能技术的快速发展，AIGC技术在游戏行业中的应用日益广泛。它可以通过智能算法和机器学习技术自动化游戏创作的不同方面，如场景设计、角色生成、敌人行为模式等。本文将探讨AIGC技术的发展现状和未来趋势，为读者提供一个全面了解这项技术的引言。我将从以下三个方面来论述：
技术应用伦理与风险未来展望 技术应用 对于出版来说，AIGC具有两面性。一方面，利用人工智能生成内容，这与使用传统技术完全不同。传统工业技术对出版只有复制、粘贴功能，复制和粘贴使成本递减，所以图书的大众化普及速度更快。而AIGC是一个创造的过程，是一个创造新内容、创造新价值的过程。在这个基础上提升了标准化、流程化甚至生产线，所以AIGC给出版工作带来极大的便利，生产效率也将大大提升。信息、知识传播和大众化的速度与原来大机器时代相比呈几何式增长。
另一方面，AIGC对现在的出版人提出了挑战。它不仅对出版业造成挑战，出版业会迎来迭代的更新，会产生新的方式、新的价值，而且对出版人提出了挑战，传统的、只擅于文字加工的编辑，逐渐会被更擅于学习的流程化、标准化的AI取代，这对于出版人来说提出了一个更高的要求。任何产业都是在迎接挑战和回应挑战的过程中得到提高，出版业也应顺势而为，勇敢面对。
在新的技术革命大潮中，出版人既要擅于开拓，又要保持定力、审时度势，不随波逐流。在人才培养上，对只擅于内容和文字的编辑需求减少，对文字+内容+科技的编辑需求增多。我们要培养编辑站稳不倒的定力、不为所动的自控力、随机应变的适应力等。唯有如此，我们才能不被技术裹挟，才能让技术为我们所用。
人工智能一直在漫长的历史中艰难探索，直至今日，大模型的发展才引发了AIGC的质变。AIGC是一种利用人工智能技术生成内容的方法，其应用之一ChatGPT的横空出世引起全球范围内的广泛关注与思考，AIGC热度持续攀升。
一、AIGC对未来产生了革命性影响 大数据一直推动着人工智能的发展，在大数据的统计中，往往会自动显现出事物发展的规律性。AIGC代表着AI技术从感知、理解世界到生成、创造世界的跃迁，正推动人工智能迎来智能创作时代。
AIGC是人工智能算法的一次重大突破，意味着人类对人工智能的运用不再被局限于某一特定功能，而是真正迈入了通用人工智能阶段。可以说，AIGC开创了模型主导内容生成的时代，人类将跑步进入传统内容创作和人工智能内容生成并行的时代。
二、AIGC将助力元宇宙数字经济的加速发展 2021年被称为“元宇宙元年”，元宇宙的建设需要大量的数字内容来支撑，人工设计和开发根本无法满足需求。AIGC的出现可以最终完善元宇宙生态的底层基础设施，极大地推动元宇宙的发展。
AIGC利用AI技术解决虚拟化身的生成问题，实现亿万用户的个性化需求；虚拟物品的生成在未来同样可以借助AIGC来实现；AIGC还可以助力虚拟场景的生成，大大降低元宇宙场景的创作门槛。AIGC将进一步助推元宇宙的发展。
三、AIGC将加速出版业数字化智能化的转型升级 AIGC将为内容生产提供新的智能化创作工具。在已有的内容生产方式中，由专业化团队主导的PGC与由用户生产内容的UGC分别受产能和质量所限，难以满足迅速增长的内容需求，亟须新的生产方式带来内容变革。AIGC突破了人工限制，通过AI技术带来更加丰富多样的内容。在出版数字化智能化过程中，AIGC将带来新的机遇：优化内容供给，更快地生产出更新、更差异化的内容；提升编辑审校效率，代替一些程式化的、重复性的、基础性的编辑工作，实现人机协同；提高营销效率，基于用户心理和需求生成营销策划案、营销文案，为不同的用户提供个性化的营销方案。
对出版业来说，出版事业关键在人才。面对出版大变革的时代，出版业需要更多创新型人才，希望更多的人才主动进行自我训练，以自我驱动的内在创造力持续不断地在选题策划、编辑加工、文案写作、营销宣传等方面提出新想法，开拓新路径，以促进出版业的数字化转型。
四、AIGC的未来发展趋势及影响 未来AIGC的应用场景会进一步多元化，涉及领域会更加全面，最终将进一步朝着实现独立完成内容创作的方向迈进。出版作为国家科学、文化传播的重要领域，将是AIGC的主要使用者行业之一，也是版权、内容质量和数据安全界限界定的探索者之一。出版人应紧跟国家政策，遵循人工智能的道德伦理要求，维护良好的人工智能治理秩序。
ChatGPT对金融科技有三个方面的价值：一是ChatGPT对金融科技的直接价值，二是ChatGPT在金融科技创新中的潜在风险，三是ChatGPT对于金融科技创新的间接价值。
ChatGPT主要有两大技术特点。一是通用性，是指它什么问题都可以回答；二是它处理的是非结构化数据，非结构化数据和我们的实际应用更接近。ChatGPT是一个超级语言模型，而不是视觉模型，也不是听觉模型，更不是硬件方面的革命性突破， ChatGPT不是万能的。
值得一提的是，ChatGPT虽然是大语言模型，但是它在自然语言处理NLP技术上从过去到现在一直没有大的突破，因为人的语义、语法和句法非常复杂，ChatGPT绕开了这个瓶颈，它通过人工反馈和大数据的训练来解决。
伦理与风险 AIGC技术在游戏开发中的应用，虽然带来了许多潜在的好处，但也引发了一些伦理和风险问题。下面将讨论这些问题，并提出应对措施和监管建议。
首先，一个重要的伦理问题是游戏内容的合适性。使用AIGC技术生成游戏元素可能会导致出现不恰当或令人不安的内容，例如暴力场景、色情内容或歧视性言论。因此，必须确保AIGC技术的算法和训练数据不会引导游戏开发者制作具有不良影响的内容。这可以通过制定行业标准和规范来监管，同时游戏开发者也应该对生成的内容进行严格审查和筛选。
其次，随着AIGC技术的发展，可能出现对人类劳动力的替代性。自动化生成游戏元素可能会减少人力需求，可能导致一定程度上的就业问题。为了解决这个问题，监管机构和政府应该与相关行业合作，制定政策和计划来确保人力资源的合理利用和培训，以避免高技术就业机会的减少。
此外，随着AIGC技术的普及，数据隐私和信息安全也成为一个重要的考虑因素。AIGC系统需要获取和分析大量的用户数据来生成游戏元素，这可能引发个人隐私泄露的风险。监管机构应该加强对数据使用和保护的监管，确保个人数据的合法使用和保密，并对违规行为进行处罚。
最后，伦理问题还涉及到游戏中的道德选择。AIGC技术在生成游戏情节和剧情时，可能会面临一些道德抉择，例如道德困境、伦理冲突等。此时，开发者需要在算法和系统的基础上加入道德规则和指导，确保游戏的内容和情节不会引发伦理上的争议。
综上所述，AIGC技术的应用在游戏开发中带来了伦理和风险问题。为了解决这些问题，需要制定相关的政策和标准，加强监管，并与行业相关方合作，以确保AIGC技术的合理、安全和道德使用。只有在伦理和风险问题得到妥善解决的情况下，AIGC技术才能发挥其最大的潜力，并为游戏行业带来更好的发展。
未来展望 AIGC技术（人工智能生成内容）在未来会继续取得突破性的发展。以下是一些可能的发展方向和潜在可能性：
更精确和智能的内容生成：随着技术的不断进步，AIGC技术将变得越来越智能和精确。它将能够生成更加真实、准确和具有个性化的内容。这将使得AIGC技术在各个行业，如新闻、娱乐、广告等领域的应用更加广泛。
自动化创作和编辑：AIGC技术将能够自动创作和编辑各种类型的内容，如文章、音乐、视频等。这将极大地提高内容创作的效率和质量。
跨语言翻译和文化适应：AIGC技术有潜力实现跨语言翻译和文化适应，使得内容能够以原汁原味的方式传达给不同的受众。这将促进不同国家和文化之间的交流和理解。
虚拟角色和虚拟助手：AIGC技术可以用于创建和操作虚拟角色和虚拟助手。这些角色和助手可以与人类进行互动，并提供各种服务和支持。
这些发展将带来许多个人和社会上的影响和挑战：
就业和职业变化：AIGC技术将取代部分人类的工作，例如内容创作、翻译等。这将对相关行业的就业形成冲击，并要求工作者不断更新自己的技能。
道德和伦理问题：AIGC技术的广泛应用将引发一系列道德和伦理问题，例如虚假信息的传播、隐私保护等。社会将不得不制定相关规定来规范和管理这些问题。
社会不平等：AIGC技术的发展可能会加剧社会不平等现象。那些无法适应和利用AIGC技术的人可能会被边缘化。因此，必须采取措施来确保技术的普惠性和公平性。
总之，AIGC技术在未来将在各个领域取得突破性的发展，并对个人和社会产生深远影响。了解和应对这些影响和挑战将是未来发展的关键。
后记 总结来说，AIGC技术在游戏开发领域的发展现状显示出了巨大的潜力和前景。过去几年中，我们见证了AIGC技术从一个初步的实验阶段逐渐成熟，并在各种游戏中得到实际应用。通过与传统游戏开发流程相结合，AIGC技术已经在提高游戏质量、缩短开发周期和降低开发成本方面取得了显著的成果。
然而，尽管在目前的发展中AIGC技术已经取得了一些重要的突破，但仍然存在一些挑战需要解决。其中之一是如何实现更加智能化和创造性的游戏设计。虽然AIGC技术可以提供自动生成的游戏元素，但如何让这些元素与玩家的期望和需求相匹配仍然是一个难题。此外，与AIGC技术相关的伦理和法律问题也需要认真思考和解决，例如游戏内容是否合适，以及如何保护玩家的隐私等。
展望未来，AIGC技术将继续发展壮大，通过更高级的人工智能算法和深度学习技术，将能够更好地理解玩家的喜好和需求，并自动化创造出更加真实、引人入胜的游戏体验。此外，随着虚拟现实和增强现实等技术的普及，AIGC技术也将在这些领域发挥重要作用，为玩家带来全新的交互和沉浸式体验。
总之，AIGC技术作为人工智能和游戏开发的交叉领域，正在持续发展并呈现出巨大的潜力。未来，我们可以期待看到更多创新和突破，为游戏行业带来更加智能化、个性化和创造性的游戏体验。
转载自：
欢迎 👍点赞✍评论⭐收藏，欢迎指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87dbf7cd1f90e4f4c98ea63642e62c6/" rel="bookmark">
			JSON教程（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章来源：JSON教程（非常详细）
目录
JSON
JSON 发展史
为什么要使用 JSON？
JSON 的不足
存储格式
使用场景
1) 定义接口
2) 序列化
3) 生成 Token
4) 配置文件
JSON语法规则
JSON 与 JavaScript 对象的区别
JSON数据类型
1、字符串
2、数字
3、布尔值
4、空
5、对象
6、数组
JSON注释
JSON5 前端使用
示例
运行结果
JSON Schema
定义 Schema
Schema 中提供了一系列关键字
1) 字符串（String）
2) 数值类型
3) 对象 属性（Properties）
额外属性（Asdditional Properties）
必须属性（Required Properties）
属性名称（Property names）
属性个数（Size）
4) 数组
列表验证（List validation）
元组验证（Tuple validation）
数组长度（Length）
唯一（Uniqueness）
5) 布尔（boolean）
6) 空值（null）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b87dbf7cd1f90e4f4c98ea63642e62c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc060e7458d4788a66cda817e13307c/" rel="bookmark">
			深入了解C语言中的结构体类型与内存对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言1.结构体类型1.1 结构体的声明1.2 结构体的创建和初始化1.3 访问结构体成员1.4 小技巧1.5 结构的特殊声明1.6 结构体的自引用 2.结构体内存对齐2.1 对齐规则2.1.1 内存对齐例题 2.2 为什么存在内存对⻬?2.3 修改默认对⻬数 3.结构体传参结语 引言 在C语言中，结构体是一种自定义的数据类型，它允许我们将不同类型的数据组合在一起，形成一个新的数据类型。结构体的使用为我们解决了一些复杂数据的表示和处理问题，不仅限于单单的整型或者字符。本文将深入探讨结构体类型、结构体变量的创建和初始化，并详细介绍结构体中的内存对齐规则。
1.结构体类型 结构体类型是由不同类型的数据成员组成的集合，其中每个数据成员可以是任意类型的数据，包括基本数据类型、数组、指针、其他结构体等。结构体类型的定义使用关键字"struct"。
1.1 结构体的声明 形式如下：
struct tag { member-list; // 成员列表 }; 举例：描述一个学生
struct student { char name[20]; // 名字 int age; // 年龄 char sex[5]; // 性别 char id[20]; // 学号 }; // 注意分号不要遗忘 1.2 结构体的创建和初始化 结构体可以在声明的同时创建 struct student { char name[20]; // 名字 int age; // 年龄 char sex[5]; // 性别 char id[20]; // 学号 }stu; // 这样就在声明的同时创建了一个struct student类型的变量stu 结构体也可以声明完后再创建 struct student { char name[20]; // 名字 int age; // 年龄 char sex[5]; // 性别 char id[20]; // 学号 }; int main() { struct student stu; // 这样也是创建了一个struct student类型的变量stu return 0; } 结构体的初始化 struct Stu { char name[20];//名字 int age;//年龄 char sex[5];//性别 char id[20];//学号 }; int main() { //按照结构体成员的顺序初始化 struct Stu s = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc060e7458d4788a66cda817e13307c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd94cb866ea67a29b6a82eb9ca8a449d/" rel="bookmark">
			C&#43;&#43;--const成员及const取地址操作符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天我们来了解一下const成员的基本使用,以及const取地址重载的运用
来开始今天的学习
const成员 1.基本定义, 将const修饰的“成员函数”称之为const成员函数，const修饰类成员函数，实际修饰该成员函数 隐含的*this指针，表明在该成员函数中不能对类的任何成员进行修改。
一般使用如下:
因为this是隐藏的,使用时const放在函数参数括号之后,表示const Date*this 的作用
2,使用场景 此时可以保证*this的成员不被被修改可以用在一些不修改数时的情景,但是如果是一些计算等值会变化得函数,就不能使用它,比如int operator+=(const Date &amp;d)是一个错误用法
3,const的调用权限 现在有几个问题,如果在函数中同时存在const 成员函数,与非const成员函数的话下面情况,会怎麽样
1. const对象可以调用非const成员函数吗？
是不可以的,这里有权限放大的错误,如下cosnt 的对象相当于d2传过出的是const Date*this,
而printf函数是默认的Date*this函数,那么this由原来的只读不写变成了可读可写,权限放大,会出现错误 const Date d2(2024, 3, 1); d2.printf(); void printf() //Date类里的函数 { cout &lt;&lt; _year &lt;&lt; " " &lt;&lt; _month &lt;&lt; " " &lt;&lt; _day &lt;&lt; endl; } 那么怎么修改上面的错误,答案是void printf()const,将非const成员函数变成const成员函数,如此也说明了cosnt对象可以调用cosnt成员函数
2. 非const对象可以调用const成员函数吗？
是可以的,这里有权限缩小,如下cosnt 的对象相当于d2传过出的是Date*this,
而printf函数是默认的const Date*this函数,那么this由原来的可读不写变成了只读可写,权限缩小,在c++中是允许的
Date d2(2024, 3, 1); d2.printf(); void printf()cosnt //Date类里的函数 { cout &lt;&lt; _year &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd94cb866ea67a29b6a82eb9ca8a449d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d6d9a0ea77e7abfc39a3e203bd120f/" rel="bookmark">
			【智能助手体验】分享一款超好用的AI工具：Kimi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
1. 引言
2. Kimi简介
3. 主要功能
4. 使用案例
5. 案例代码演示
与Kimi对话的示例：
6. 个人体验与总结
1. 引言 在数字化时代，AI助手正变得越来越不可或缺。今天，我要向大家介绍一款我最近发现的超级实用的AI工具——Kimi。它不仅能理解自然语言，还能阅读和理解用户上传的文件内容，甚至结合互联网搜索来回答复杂问题。如果你对提高工作效率和生活质量感兴趣，那么Kimi绝对值得一试。
2. Kimi简介 Kimi是由月之暗面科技有限公司开发的人工智能助手，擅长中文和英文对话。它能够处理用户上传的多种格式文件，结合搜索结果提供信息，同时遵循中华人民共和国的法律和道德标准。
3. 主要功能 语言理解与对话：Kimi可以理解和回应各种问题，无论是日常对话还是专业知识。文件内容解析：支持TXT、PDF、Word文档、PPT幻灯片和Excel电子表格等格式，Kimi可以阅读并理解文件内容。互联网搜索整合：Kimi能够利用搜索结果，为用户提供更全面的答案。例如： 4. 使用案例 日常咨询解答：Kimi可以快速回答天气、新闻、科学知识等日常咨询。数据文件解读：上传一个Excel表格，Kimi能帮你分析数据，提取关键信息。网络信息检索：需要了解某个话题？Kimi结合搜索结果，为你提供最准确的信息。 5. 案例代码演示 与Kimi对话的示例： { "user": "Kimi，你能帮我写一段CNN图像分类代码吗？", "kimi": "当然可以，下面是一个使用Python和TensorFlow/Keras库实现的简单卷积神经网络(CNN)图像分类的示例代码。" } 这个demo将构建一个小型的CNN模型，用于对MNIST数据集中的手写数字进行分类。
import tensorflow as tf from tensorflow.keras import datasets, layers, models # 加载 MNIST 数据集 (train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data() # 归一化像素值 train_images, test_images = train_images / 255.0, test_images / 255.0 # 构建模型 model = models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d6d9a0ea77e7abfc39a3e203bd120f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763616161fde1654d0e37e4231a6979c/" rel="bookmark">
			前端 CSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
选择器 复合选择器
伪类-超链接
结构伪装选择器
伪元素选择器
画盒子
字体属性
CSS三大属性
Emmet写法
背景属性
显示模式
盒子模型
盒子模型-组成
盒子模型-向外溢出
盒子模型-圆角
盒子模型-阴影
flex
position定位
CSS小精灵
字体图标
垂直对齐方式
过渡 transition
透明度 opacity
光标类型 cursor
transform 平面转换
渐变
空间转换
动画-animation
手机端移动适配方案
rem适配方案
less
vm与vw适配方案
前言
本文章将讲述前端CSS的属性和用法,内容非常齐全,希望大家可以从中学到知识,也非常希望大家可以和我一起探讨!
🙈个人主页: 心.c
🔥文章专题:前端
💕欢迎大家点赞👍🥳收藏💞
层罍样式表(Cascading stvle sheets，缩写为 CSS)，是一种 样式表 语言，用来描述 HTML 文档的呈现(美化内容)。
书写位置:title 标签下方添加 style 双标签，style 标签里面书写 CSS 代码。
选择器 作用:查找标签,选择样式,都写在style标签里面
基础选择器:
标签选择器选择标签名作为选择器,选中同名标签设置相同样式类选择器作用:查找标签，差异化设置标签的显示效果，id选择器类似于类选择器,第一个用#表示,同一个id只能用一次通配符选择器*{}表示,自动查找所有标签,设置相同样式 步骤:
定义类选择器 →.类名使用类选择器 → 标签添加 class="类名" 一个标签不可以写多个class文件,但是class类中可以写多个属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/763616161fde1654d0e37e4231a6979c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/386/">«</a>
	<span class="pagination__item pagination__item--current">387/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/388/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>