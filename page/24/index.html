<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e40a55e06910c96cbb1c0b131c1d075/" rel="bookmark">
			数据结构【链试结构二叉树】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟摘要：设⼆叉树的根结点所在层数 为1，层序遍历就是从所在⼆叉树的根结点出发，⾸先访问第⼀层的树根结点，然后从左到右访问第2 层上的结点，接着是第三层的结点，以此类推，⾃上⽽下，⾃左⾄右逐层访问树的结点的过程就是层 序遍历。根结点的左⼦树和右⼦树分别⼜是由⼦树结点、⼦树结点的左⼦树、⼦树结点的右⼦树组成的，因此 ⼆叉树定义是递归式的,后序链式⼆叉树的操作中基本都是按照该概念实现的。回顾⼆叉树的概念，⼆叉树分为空树和⾮空⼆叉树，⾮空⼆叉树由根结点、根结点的左⼦树、根结点 的右⼦树组成的。根结点、左⼦树、右⼦树。
🌟个人主页：落叶
目录
实现链式结构⼆叉树
前中后序遍历：
遍历规则
代码实现
前序遍历：
中序遍历：
后序遍历：
图解遍历：
函数递归栈帧图：
结点个数以及高度等
【⼆叉树】结点个数
【二叉树】叶子节点个数
【二叉树】第k层节点个数
【二叉树】的深度/⾼度
【二叉树】查找值为x的结点 【二叉树】销毁
层序遍历
判断是否为完全二叉树
实现链式结构⼆叉树 ⽤链表来表⽰⼀棵⼆叉树，即⽤链来指⽰元素的逻辑关系。通常的⽅法是链表中每个结点由三个域组 成，数据域和左右指针域，左右指针分别⽤来给出该结点左孩⼦和右孩⼦所在的链结点的存储地址， 其结构如下：
创建二叉树数据：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int data; typedef struct Tree { int arr; //数值 struct Tree* zuo;//左孩子 struct Tree* you;//右孩子 }BT; ⼆叉树的创建⽅式⽐较复杂，为了更好的步⼊到⼆叉树内容中，我们先⼿动创建⼀棵链式⼆叉树
我们进行连接后就成下面这个二叉树
当然我们也可以这样看
//申请空间 BT* koj(data x) { //申请节点 BT* tab = (BT*)malloc(sizeof(BT)); if (tab == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e40a55e06910c96cbb1c0b131c1d075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c530826419b3045dc1b02379609797e2/" rel="bookmark">
			fastapi 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前置知识
1.1、HTTP 协议
1.2、I/O 密集型和 CPU 密集型
慢操作
计算机/程序 🤖一些相对较慢（与处理器和 RAM 存储器的速度相比）的 I/O 操作，比如说：
● 通过网络发送来自客户端的数据
● 客户端接收来自网络中的数据
● 磁盘中要由系统读取并提供给程序的文件的内容
● 程序提供给系统的要写入磁盘的内容
● 一个 API 的远程调用
● 一个数据库操作，直到完成
● 一个数据库查询，直到返回结果
● 等等.
I/O 密集型
这个执行的时间大多是在等待 I/O 操作，因此它们被叫做 “I/O 密集型” 操作
CPU 密集型
大多数执行时间是由实际工作（而不是等待）占用的，并且计算机中的工作是由 CPU 完成的，所以他们称这些问题为"CPU 密集型"
CPU 密集型操作的常见示例是需要复杂的数学处理。
例如：
● 音频或图像处理；
● 计算机视觉: 一幅图像由数百万像素组成，每个像素有3种颜色值，处理通常需要同时对这些像素进行计算；
● 机器学习: 它通常需要大量的"矩阵"和"向量"乘法。想象一个包含数字的巨大电子表格，并同时将所有数字相乘；
● 深度学习: 这是机器学习的一个子领域，同样适用。只是没有一个数字的电子表格可以相乘，而是一个庞大的数字集合，在很多情况下，你需要使用一个特殊的处理器来构建和使用这些模型。
1.3、同步和异步
同步
去等待慢操作完成的确切时刻，而在此期间不做任何事情直到能够获取任务结果才继续工作
异步
等待慢操作📝完成的这段时间，计算机可以做一些其他工作
1.4、async 和 await
使用 async def，Python 就知道在该函数中，它将遇上 await，并且它可以"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c530826419b3045dc1b02379609797e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1488e3efc65046fb7f4a244a9b857858/" rel="bookmark">
			Android常见布局控件（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言
RecyclerView控件
数据适配器
布局管理器
使用RecyclerView
创建XML布局文件
创建ReActivity类
创建数据适配器
onCreateViewHolder
onBindViewHolder
完整代码
补充知识
ItemDecoration
前言 在前一篇中，我们讲解了ListView控件，那么本篇我们就来讲解RecyclerView控件
RecyclerView控件 与ListView类似，RecyclerView控件同样也是以列表的形式将数据进行展示，都是为了维护少量的View来进行显示大量的数据。是在android5.0之后新添的控件，用来替代传统的ListView和GridView控件的。
与传统的ListView不同，RecyclerView能通过LayoutManager类来实现横向或者竖向的列表效果、瀑布流效果和GridView效果，而ListView只能实现竖直的列表效果。
格式如下：
&lt;androidx.recyclerview.widget.RecyclerView android:layout_width="match_parent" android:layout_height="match_parent"/&gt; 我们 可以通过在Patale中找到RecylcerView，将其拉到XML文件中
当然，我们也可以手动添加：
数据适配器 RecyclerView控件使用的是RecyclerView.Adapter，该数据适配器将BaseAdapter中的getView()方法拆解为onCreateViewHolder()方法和onBindViewHolder()方法，强制使用ViewHolder类，使代码更加规范化。
布局管理器 LayoutManager布局管理器用来设置每一项view在RecyclerView中的位置布局，以及控件item view的显示或隐藏。当View重用或者回收的时候，LayoutManager都会向Adapter来请求新的数据进行替换原来的数据的内容。这种回收复用机制可以提供性能，避免创建很多的view或者是频繁的调用findViewById()方法。
RcyclerView提供了三种内置的LayoutManager：
LinearLayoutManager：线性布局，横向或者纵向滑动列表GridLayoutManager：网格布局StaggerdGridLayoutManager：流式布局，如瀑布流效果。 当然，我们也可以通过继承RecyclerView.LayoutManager来实现一个自定义的LayoutManager。
Animations（动画）效果：
RecyclerView对于Item的添加和删除是默认开启动画的，我们也可以通过RecyclerView.ItemAnimator类来定制动画，再通过RecyclerView.setItemAnimator()方法来使用 以下是RecyclerView的一些相关类：
类名说明RecyclerView.Adapter可以托管数据集合，为每一项Item创建视图并且绑定数据RecyclerView.ViewHolder承载Item视图的子布局RecyclerView.LayoutManager负责Item视图的布局的显示管理RecyclerView.ItemDecoration给每一项Item视图添加子View，例如进行画分割线等RecyclerView.ItemAnimator负责处理数据添加或者删除时候的动画效果 使用RecyclerView 创建XML布局文件 这里我选择创建一个名为recycle_list.xml的布局文件。
这里我们选择模仿聊天的界面，那么首先我们需要实现一个聊天的界面，就在上面创建的布局中实现。效果图如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="16dp"&gt; &lt;ImageView android:id="@+id/tv" android:src="@mipmap/ic_launcher" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;LinearLayout android:layout_width="200dp" android:layout_height="match_parent" android:layout_marginLeft="10dp" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tv_name" android:text="李四" android:textStyle="bold" android:textSize="20sp" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;TextView android:id="@+id/news" android:text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1488e3efc65046fb7f4a244a9b857858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b01cd8c34e33562943c998717ce4cca/" rel="bookmark">
			minio 大视频观看，下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线观看 /** * 下载视频文件 fileName文件路径名称 文件路径 BacketName/video/1111.mp4 需要截取桶名后面的路径 video/1111.mp4 video前面不要带/ * * @param fileName * @param request * @param response */ public void play(String fileName, HttpServletRequest request, HttpServletResponse response) { if (StringUtils.isNotBlank(fileName)) { log.info("download:" + fileName); String range = request.getHeader("Range"); log.info("current request rang:" + range); //获取文件信息 // 调用statObject()来判断对象是否存在。 // 如果不存在, statObject()抛出异常, // 否则则代表对象存在。 StatObjectResponse statObjectResponse = null; try { statObjectResponse = client.statObject( StatObjectArgs.builder().bucket(minioConfig.getBucketName()).object(fileName).build()); } catch (ErrorResponseException e1) { e1.printStackTrace(); } catch (InsufficientDataException e1) { e1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b01cd8c34e33562943c998717ce4cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3745d8749b5ee87d2a745b740b9a13/" rel="bookmark">
			引用本地仓库私有jar包爆红问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：各个公司都有自己的私有核心jar包，只能在公司maven仓库中拉取，如果当前环境无法链接到公司maven仓库，可以将jar包放到本地仓库，但是idea会出现无法识别的情况
解决方案：
删除maven本地仓库jar包目录下的 .lastUpdated 和 .repositories 文件，即可解决
批量删除操作
del /S/Q *.lastUpdated del /S/Q *.repositories 原因：
.repositores里包含仓库地址，每次更新的适合都想要取拉去最新的代码，但是又因为网络不通，所以一直拉取不到，所以把这个文件删除之后，他就不会去拉去最新的，直接去本地仓库的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b259409ad7947d721c087dc6847d6d1/" rel="bookmark">
			基于大数据爬虫&#43;hive&#43;数据可视化大屏的网络电视剧收视率分析与可视化平台设计和实现(源码&#43;LW&#43;部署讲解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝50W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行前辈交流✌
技术范围：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
主要内容：免费功能设计、开题报告、任务书、中期检查PPT、系统功能实现、代码编写、论文编写和辅导、论文降重、长期答辩答疑辅导、腾讯会议一对一专业讲解辅导答辩、模拟答辩演练、和理解代码逻辑思路。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
大数据项目实战《100套》
Python项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人​
系统介绍： 基于Hive的网络电视剧收视率分析系统是一个高效、精确的数据管理与分析平台，旨在为电视传媒机构和观众提供一个全面的收视率数据解决方案。通过利用Hive的大数据处理能力，该系统能够存储和分析海量的收视数据，从而揭示不同电视剧的受欢迎程度和观众偏好。管理员可以通过系统管理模块轻松地更新用户信息、发布公告以及维护系统稳定。用户得以在个人中心内修改密码、管理发布内容和收藏喜好。该系统还提供了一个交流论坛，以增强用户间的互动和讨论。整体而言，该系统不仅优化了数据处理流程，也提高了用户参与度，为网络电视剧市场提供了宝贵的见解和指导。
在当今多媒体时代，网络电视剧已成为主流娱乐方式之一。随着互联网的普及和在线视频平台的迅猛发展，观众逐渐从传统电视转向网络平台观看电视剧。这一转变不仅改变了人们的观影习惯，也对电视剧内容制作、发布及评价体系带来了深远影响。在这样的背景下，如何准确评估一部网络电视剧的受欢迎程度，把握观众偏好，并据此指导内容创新与精准营销，成为行业急需解决的问题。数据科学的发展为这一问题提供了新的解决思路。基于Hive的网络电视剧收视率分析系统正是在这样的需求推动下应运而生的。Hive作为构建在Hadoop之上的数据仓库解决方案，能够处理PB级别的大数据，并提供高效的SQL查询功能，非常适合用来进行海量收视数据的存储与分析。
基于Hive的网络电视剧收视率分析系统对于电视剧制作方、发行方以及广告商等都有着极其重要的意义。对制作方而言，通过系统提供的精确收视数据可以了解观众喜好，指导剧本创作和剧集改进，提高作品质量；对发行方来说，可以基于收视趋势调整发行策略，优化推广计划，扩大观众群体；广告商则能利用这些数据分析观众特征，实现广告精准投放，提升广告效果。对观众而言，系统的交流论坛提供了一个分享观点、参与讨论的平台，增强了观众之间的互动，丰富了观影体验。整个系统不仅推动了电视剧市场的数据分析技术进步，也为网络时代的影视文化消费行为研究提供了实证基础，具有广泛的社会和经济效益。
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​ 程序操作流程图
首先前端通过Vue和axios发送HTTP请求到后端的登录接口。在后端接收登录请求的Controller会使用`@RequestParam Map&lt;String, Object&gt; params`来接收前端传递的用户参数，用户名和密码。然后后端根据接收到的参数创建一个查询条件封装对象MyBatis的EntityWrapper用于构建查询条件。接着在业务层，调用相应的service方法来查询数据库中是否存在匹配的用户信息。这个查询方法Login()会将前端传递的对象参数传递到后台的DAO层，进行数据库的交互操作。如果存在符合条件的用户，则会返回相关的用户信息。最后在后端控制器中将查询结果封装成响应体，通过`return R.ok().put("data", userService.selecView(ew))`将用户信息返回给前端。前端收到响应后，可以通过调用Vue、ElementUI等组件来渲染登录结果，例如显示用户信息或者跳转到相应的页面。
系统架构设计 系统架构设计是软件开发过程中至关重要的一环。首先是模型层（Model），模型层通常对应着数据库或者其他数据源，它负责与数据库进行交互，执行各种数据操作，并将处理后的数据传递给控制器层。模型层的设计应该简洁清晰，尽可能减少与视图和控制器的耦合，以提高代码的可维护性和可重用性。
其次是视图层（View）通常是通过网页、移动应用界面或者其他用户界面来展示数据。视图层与用户交互，接受用户的输入，并将输入传递给控制器层进行处理。在MVC三层架构中，视图层应该尽量保持简单，只负责数据的展示和用户交互，不涉及业务逻辑的处理，以保持视图层的清晰度和可复用性，最后是控制器层（Controller），每个层都有特定的职责和功能，通过分层架构设计，实现代码模块化，为软件开发提供了一种有效的架构模式。系统架构如图4-1所示。
详细视频演示 请文末卡片dd我获取更详细的演示视频
功能截图： 在系统前台首页，调用`$route(newValue)`方法监听路由变化，根据当前的路由地址来确定活动菜单的索引，并且根据路由的哈希部分（即URL的`#`后面的部分）来判断是否需要滚动页面到顶部或者某个特定元素的位置。如果不是首页，会将页面滚动到指定元素处，否则滚动到页面顶部。另外通过`headportrait()`方法用于更新组件渲染点前用户头像。在用户登录后，后端返回了新的用户信息，需要及时更新页面上的用户头像信息。
论文参考： 1 绪 论 1.1研究背景与意义 1.2系统研究现状 1.3 论文主要工作内容 2 系统关键技术 2.1 java简介 2.2 MySQL数据库 2.3 B/S结构 2.4 SpringBoot框架 2.5 VUE框架 3 系统分析 3.1 系统可行性分析 3.1.1 技术可行性 3.1.2 操作可行性 3.1.3 经济可行性 3.1.4 法律可行性 3.2 系统性能分析 3.3 系统功能分析 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b259409ad7947d721c087dc6847d6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf68f7780a9443ec5a5d8ffd1ad7c12b/" rel="bookmark">
			C语言小项目源码大全（60套）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言小项目源码大全60套 目录源码文件 目录 纯c语言迷宫源码.exe .
c语言五子棋源码.exe
c语言24点游戏源码.exe
c语言万年历源码.exe
c语言别踩白块儿(双人版)源码.exe
c语言奔跑的火柴人游戏源码.exe
c语言吃逗游戏源码.exe
C语言超市管理系统.exe
c语言对对碰游戏源码.exe
c语言大丰收游戏源码.exe
c语言地空对战游戏.exe
c语言对自己电脑系统测试.exe
c语言打字母游戏源码.exe
c语言电子时钟程序.exe
c语言打字游戏代码.exe
c语言俄罗斯方块.exe
c语言俄罗斯方块.exe
c语言黑白棋ai游戏源码.exe .
c语言火车票订票管理源码.exe
c语言华容道源码.exe
c语言盒子接球游戏源码.exe
c语言教工工资管理系统.exe
c语言坑爹大冒险.exe
c语言矿井逃生.exe
c语言连连看游戏源码.exe
c语言力学相关的流体源码.exe
c语言模拟快打旋风游戏源码.exe
c语言拼图游戏源码.exe
c语言配有图片和音乐的打字母游戏.exe
c语言情人节的红玫瑰.exe
c语言青蛙过河小游戏.exe
c语言扔香蕉的大猩猩.exe
c语言商品销售系统源码.exe
c语言实现的超级玛丽游戏源码.exe
c语言实现的汉诺塔演示程序.exe
c语言实现的象棋源码.exe
c语言实现非常漂亮祝福烟花效果.exe
c语言实现类似弹力球效果.exe
c语言实现如果cmd中的ping.exe
c语言实现水波纹显示效果.exe
c语言实现数字雨.exe
c语言实现图片转化为ASCII图.exe
c语言贪吃蛇游戏的双人对战版.exe
c语言涂格子游戏源码.exe
c语言坦克游戏源代码.exe
c语言图书管理系统源码.exe
c语言图书借阅系统源码.exe
c语言Turbo C下写的俄罗方块.exe
c语言通讯录管理系统源码.exe
c语言UDP传输系统源码.exe
c语言文本编辑器系统源码.exe
c语言学生成绩管理系统.exe
c语言学生成绩管理系统源码.exe
c语言学生信息系统.exe
c语言自创军旗游戏源码.exe
c语言自创推箱子游戏改版.exe
c语言支持自己创建迷宫，并求解最短路径.exe
c语言做的-一个任务管理器.exe
c语言做的播放器源码.exe
c语言做的绘图板系统.exe
c语言种地要浇水游戏源码.exe
链表HuffmanTree.exe
源码文件 链接：https://pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf68f7780a9443ec5a5d8ffd1ad7c12b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f90406eb18e08a8e2931a87667b11e7/" rel="bookmark">
			【C&#43;&#43;类和对象（下）】——我与C&#43;&#43;的不解之缘（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 时隔多日，继续学习C++，类和对象；
大致内容：初始化列表，explicit关键字，static成员，友元，匿名对象
一、再探构造函数 1、接上篇，我们实现构造函数时，初始化成员变量主要在函数体内部进行赋值；构造函数初始化还有一种方法就是初始化列表，初始化列表的使用方式是以一个冒号开始，接着一个逗号分隔的数据成员列表，在每一个“成员变量”后面跟一个放在括号中的初始值和表达式。
2、每一个成员变量在初始化列表中只能出现一次，语法理解上初始化列表可以理解为是每一个成员变量定义初始化的地方。
3、引用成员变量、cosnt成员变量、没有默认构造函数的类类型变量，这些必须在初始化列表位置进行初始化，不然会编译报错。
4、尽量使用初始化列表因为不在初始化列表初始化的成员也会走初始化列表（如果这个成员在声明的时候给了缺省值，初始化列表会使用这个缺省值进行初始化）；（如果没有给缺省值，对于没有显示在初始化列表的内置类型成员变量是否初始化就取决于编译器了）；对于没有在初始化列表初始化的自定义类型成员变量会调用这个成员类型的默认拷贝构造，如果没有就编译错误。
5、初始化列表中按照成员变量在类中声明顺序进行初始化，跟成员在初始化列表出现的先后顺序无关（建议声明顺序和初始化列表顺序保持一致）。
初始化列表 1、
初始化列表可以理解为每一个成员变量定义和初始化的地方。
初始化列表使用：
class Data { Data(int year = 1,int month = 1, int day = 1) :_year(year) ,_month(month) ,_day(day) {} private: int _year; int _month; int _day; }; 2、
引用成员变量 、const成员变量和没有默认拷贝构造的类类型变量必须使用初始化列表 ：
#include&lt;iostream&gt; using namespace std; class A { public: A(int a) :_a(a) {} //没有默认拷贝构造函数 private: int _a; }; class B { public: B(int b = 1, int&amp; x) :_b(b) ,_i(x) ,_ci(520) ,_A(11) {} private: int _b; int&amp; _i; //引用成员变量 const int _ci; //const成员变量 A _A; //没有默认拷贝构造的类类型成员变量 }; int main() { int x = 0; B b(11, x); return 0; } 3、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f90406eb18e08a8e2931a87667b11e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8c501ce095404107568d7b917cc930/" rel="bookmark">
			Redis面试都卷到C语言去了。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 面试都卷到 C 去了。有个小伙伴在前两天找松哥模面的时候如是说到。
是啊，没办法，自从 Java 八股文这个概念被提出来并且逐步在 Java 程序员中强化之后，现在各种各样的八股文手册，有免费的有付费的，琳琅满目。
单纯的八股文已经区分不出 Java 猿水平的高低了，所以现在面试总会卷出新高度。
这次是小伙伴面试时候被问到一个 SDS 的问题，也就是 Redis 中 String 字符串的底层实现原理。
我来和小伙伴们简单聊一聊这个话题。
一 String 类型 Redis 中有一个 String 类型，使用频率还比较高，我们日常做缓存、分布式锁都会用到。
很多小伙伴也都知道 Redis 是用 C 写的，那么就有一个问题，Redis 中的 String，底层数据结构是什么样的？
是不是就是 C 中的 String 呢？
二 C 中的 String 玩过 C 的小伙伴应该知道，C 语言本身并没有内置的 String 类型，但是 C 语言中可以使用字符数组（char array[]）或指向字符的指针（char *pointer）来表示字符串。在 C 语言中，字符串是以空字符 '\0' 结尾的字符序列。例如：
char *str1 = "Hello, World!"; 在这个例子中，str1 是一个指向字符串字面量 “Hello, World!” 的指针。
当我们在 Redis 中使用 String 的时候，很多小伙伴可能会想这个 String 可能就是 C 中的 String 吧？并不是！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c8c501ce095404107568d7b917cc930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0899474551508da18ecfb70e28cc504/" rel="bookmark">
			贪心算法---跳跃游戏（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：
给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
0 &lt;= j &lt;= nums[i] i + j &lt; n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
思路：
从覆盖范围出发，不管怎么跳，覆盖范围内一定可以跳到，以最小步数增加覆盖范围，覆盖范围一旦覆盖了终点得到的就是最小步数。
统计两个覆盖范围，当前这一步的最大覆盖范围和下一步最大覆盖范围。如果移动下标到了当前这一步的最大覆盖最远距离，还没有到达终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。
有一个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时，如果当前覆盖最远距离下表不是集合终点，步数加一，还要继续走；如果当前覆盖最远距离下标是集合终点，部署不用加一，因为不能再往后走了。
代码：
public int jump(int[] nums) { if(nums.length==1) return 0;//数组只有一个元素，不用跳跃 int curDistance=0;//当前覆盖的最远距离下标 int ans=0;//记录走的步数 int nextDistance=0;//下一步覆盖最远距离下标 for(int i=0;i&lt;nums.length;i++){ nextDistance=Math.max(nums[i]+i,nextDistance);//更新下一步覆盖最远距离下标 if(i==curDistance){//遇到当前覆盖最远距离下标 ans++;//需要走下一步 curDistance=nextDistance;//更新当前覆盖的最远距离下标 if(nextDistance&gt;=nums.length-1) break;//当前覆盖范围包含终点，直接结束 } } return ans; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c03d1b99cd7562fed34f7dd7dbc1b9/" rel="bookmark">
			HTTP与HTTPS：数据安全性的差异与风险分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代互联网通信中，HTTP（HyperText Transfer Protocol，超文本传输协议）和HTTPS（HyperText Transfer Protocol Secure，超文本传输安全协议）是两种常见的网络协议，它们都在浏览器和服务器之间传输数据。
然而，在保障数据安全性方面，HTTPS以其卓越的安全特性远优于HTTP。当前，随着网络安全意识的不断提升，网络安全愈发重要，HTTP协议因其固有的不安全性而逐渐被弃用，而HTTPS协议因其具有的安全性而逐渐被越来越多的用户选择使用。今天我们就来详细介绍HTTP协议存在哪些不安全性、风险，以及HTTP与HTTPS之间的主要区别又是在哪里。
一、HTTP协议的不安全性及风险 HTTP协议是一种未加密的明文传输协议，所有通信数据都在网络中明文传输，它不具备任何数据加密和身份验证机制。这种设计使得HTTP在数据传输过程中面临多种安全风险：
1. 数据窃听
由于HTTP以明文形式传输数据，任何中间人（如黑客）都可以轻易截取并读取传输内容，包括敏感信息如密码、信用卡号等。
2. 数据篡改
HTTP协议无法验证报文的完整性。我们没有任何办法确认，发出的请求和接收到的响应是前后相同的，即使请求或响应的内容遭到篡改，也无法知晓。一旦数据被篡改，用户可能会接收到错误或恶意的信息。
3. 身份伪装
HTTP协议中的请求和响应不会对通信方进行身份验证，在请求或响应到达接收方这段时间内，请求或响应被拦截伪造之后再次发出，通信双方也无法知晓。这使得攻击者可以伪装成合法服务器或客户端进行通信，实施欺诈或攻击。
4. 缺乏加密保护
HTTP不提供加密功能，因此无法对通信整体进行加密，导致数据传输过程中存在严重的安全漏洞。
二、HTTP与HTTPS的区别 HTTPS作为HTTP的安全版本，通过结合SSL/TLS（Secure Sockets Layer/Transport Layer Security，安全套接层/安全传输层协议）协议，提供了数据加密、身份验证和数据完整性保护等多重安全特性。以下是HTTP与HTTPS之间的主要区别：
1. 协议安全性
HTTP：未加密的明文传输协议，不提供任何数据保护机制，容易被攻击者截取信息，存在严重的安全风险。
HTTPS：在HTTP基础上通过SSL/TLS协议，使报文进行加密传输，确保数据在传输过程中的安全性和完整性。
2. 证书管理
HTTP：无需证书，没有身份验证机制。
HTTPS：需要使用数字证书对网站进行认证，服务器向CA（证书颁发机构）申请数字证书，客户端验证证书的有效性以确认服务器的身份，证明网站的真实性和合法性，防止中间人攻击。
3. 连接状态
HTTP：连接是明文的，一旦连接被截断，数据就可能被窃取或篡改。
HTTPS：连接在数据传输过程中始终保持加密状态，即使连接被截断，也不会影响数据的加密状态。
4. 端口号
HTTP：默认使用80端口。
HTTPS：默认使用443端口。
5. 资源消耗
HTTP：由于无需加密和解密操作，资源消耗相对较小。
HTTPS：由于使用了加密和解密操作，资源消耗较大，可能增加页面加载时间。
6. 兼容性
HTTP：兼容性较好，适用于各种设备和操作系统。
HTTPS：在某些情况下可能面临兼容性问题，如某些老旧设备或浏览器可能不支持最新的SSL/TLS协议。
三、结论 综上所述，HTTPS 协议在安全性和搜索排名方面有明显的优势，而 HTTP 协议只是在成本控制方面会好一点。随着网络安全威胁的不断增加，建议网站运营者考虑将 HTTP 协议升级为 HTTPS 协议，以提高网站的安全性和竞争力。
作为国内可信赖的互联网业务安全服务商，德迅云安全提供的SSL证书，由国际顶级CA机构授权颁发，加密保护浏览器/APP与服务器之间的数据传输安全，采用HTTPS加密APP及网页通讯，防止数据在传送过程中被窃取、篡改，确保数据的完整性；防止运营商的流量劫持、网页植入广告现象；同时有效抵挡中间人的攻击，大大提升安全性。可帮助企业实现网站HTTPS加密保护及身份的可信认证，安全有保障。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28d6ca160b4b8fa533767a42d2733044/" rel="bookmark">
			在Kotlin中使用Spark SQL的UDF和UDAF函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 项目结构与依赖 1.1 项目依赖 使用gradle: 在项目的build.gradle.kts添加
dependencies { implementation("org.apache.spark:spark-sql_2.12:3.3.1") } 使用maven: 在模块的pom.xml中添加
&lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.12&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; 2. UDF的使用与实现 UDF，即用户自定义函数，允许用户在SQL查询中使用自定义的函数。下面案例做了一个简单的案例，将首字母变为大写。
2.1 数据源 准备数据源使用JSON数据作为数据格式，保存到项目的根路径下的`data/user.txt`文件。
{"name":"zhangsan","age":19,"gender":"boy"} {"name":"lisi","age":20,"gender":"boy"} {"name":"wangwu","age":21,"gender":"boy"} {"name":"zhaoliu","age":22,"gender":"boy"} {"name":"sunqi","age":23,"gender":"boy"} {"name":"zhouba","age":24,"gender":"boy"} {"name":"wujiu","age":25,"gender":"boy"} {"name":"zhengshi","age":26,"gender":"boy"} 2.2 代码示例 import org.apache.spark.sql.SparkSession import org.apache.spark.sql.api.java.UDF1 import org.apache.spark.sql.types.DataTypes import java.util.* class SparkSQL_UDF { fun f1() { val sparkSession = SparkSession.builder() .master("local") .appName("Kotlin Spark UDF") .orCreate // 读取JSON数据并创建视图 sparkSession.read().json("data/user.txt") .createOrReplaceTempView("user") // 注册UDF函数，将名字的首字母大写 sparkSession.udf().register("nameHeaderUpper", UDF1 { name: String -&gt; name.substring(0, 1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28d6ca160b4b8fa533767a42d2733044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9d48681e1490fe3252df6f2a64db6fe/" rel="bookmark">
			从多维度视角探讨“开源AI智能名片O2O商城小程序”的设计与管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：在数字化转型的浪潮中，产品设计与管理已成为企业竞争力的核心要素。本文旨在从产品设计、产品管理及产品文化三个维度，深入探讨“开源AI智能名片O2O商城小程序”的设计理念与实践策略。通过强调设计即沟通的原则，本文分析了直接控制产品细节的人员如何与用户建立有效沟通渠道，以及“开源AI智能名片O2O商城小程序”如何借助用户洞察来优化产品设计、指导产品决策并塑造以用户为中心的产品文化。
一、产品设计角度：设计即沟通，开源AI智能名片O2O商城小程序的实践 1.1 设计即沟通的核心思想
在产品设计领域，设计不仅仅是对外观和功能的规划，更是一种与用户之间的深度沟通。对于“开源AI智能名片O2O商城小程序”而言，其设计过程必须紧密围绕用户需求，通过不断的用户反馈和体验测试来完善产品。这意味着直接控制产品细节的人员，如产品经理、UI/UX设计师等，必须与用户建立直接的沟通渠道，亲身体验产品的使用环境，以确保设计能够精准满足用户需求。
1.2 开源AI技术的赋能
“开源AI智能名片O2O商城小程序”充分利用了开源AI技术的优势，通过智能推荐、个性化定制等功能，提升用户体验。这种技术的引入要求设计团队不仅要具备设计技能，还需了解AI算法的基本原理和应用场景，以便在设计中更好地融合AI技术，实现技术与设计的无缝对接。
1.3 用户体验的持续优化
基于设计即沟通的理念，“开源AI智能名片O2O商城小程序”的设计团队不断收集用户反馈，通过数据分析、用户访谈等方式，深入了解用户在使用过程中的痛点与需求。这些反馈成为产品迭代优化的重要依据，帮助设计团队不断优化产品细节，提升用户体验。
二、产品管理角度：用户洞察与用户画像在开源AI智能名片O2O商城小程序中的应用 2.1 用户洞察的重要性
用户洞察是产品管理的关键环节，它帮助产品团队深入了解用户需求、行为习惯和偏好。对于“开源AI智能名片O2O商城小程序”而言，用户洞察不仅有助于发现潜在的市场机会，还能为产品决策提供有力支持。
2.2 用户画像的构建
通过用户洞察形成的用户画像是产品团队对产品理解达成一致的重要工具。对于“开源AI智能名片O2O商城小程序”而言，用户画像不仅包含了用户的基本信息（如年龄、性别、职业等），还涵盖了用户的消费习惯、使用场景、痛点需求等深层次信息。这些信息为产品团队制定营销策略、优化产品功能提供了重要参考。
2.3 产品规划的指导
基于用户画像，“开源AI智能名片O2O商城小程序”的产品团队能够更清晰地了解需求的轻重缓急，制定科学合理的产品规划。通过优先解决用户需求最为迫切的问题，产品团队能够快速提升产品竞争力，赢得用户口碑。
三、产品文化角度：以用户为中心的产品创新与设计实践 3.1 以用户为中心的产品文化
在“开源AI智能名片O2O商城小程序”的产品文化中，以用户为中心的理念贯穿于产品创新的始终。这意味着产品团队在设计和开发过程中，始终将用户需求放在首位，致力于为用户提供更加便捷、高效、个性化的服务体验。
3.2 用户洞察的实践行动
为了践行以用户为中心的产品文化，“开源AI智能名片O2O商城小程序”的产品团队积极开展用户洞察活动。通过组织用户访谈、问卷调查、实地观察等方式，产品团队能够直接接触到用户，了解用户的真实需求和反馈。这些实践行动不仅丰富了产品团队的用户知识库，还增强了团队成员对用户需求的敏感度和理解力。
3.3 不同角色人员的共同参与
在“开源AI智能名片O2O商城小程序”的项目中，不同角色的产品团队成员（如产品经理、设计师、工程师等）共同参与用户洞察活动。这种跨职能的合作模式有助于打破部门壁垒，促进信息共享和协同工作。通过共同接触用户、了解用户并获知用户需求，产品团队能够形成更加一致的产品理解和工作决策，推动产品不断向前发展。
结论 综上所述，“开源AI智能名片O2O商城小程序”在产品设计、产品管理及产品文化等方面均体现了以用户为中心的理念。通过设计即沟通的原则、用户洞察的深入实践以及以用户为中心的产品文化塑造，“开源AI智能名片O2O商城小程序”不仅提升了用户体验和满意度，还为企业赢得了市场竞争优势。未来，随着技术的不断进步和市场的不断变化，“开源AI智能名片O2O商城小程序”将继续秉持以用户为中心的理念，不断优化产品设计和服务体验，为用户创造更多价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747fbffbe0c704f5559e91f287770cab/" rel="bookmark">
			《黑神话·悟空》是用什么编程语言开发的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近火爆全球的国产 3A 大作《黑神话·悟空》，你玩了吗？没玩没关系，有人就是对游戏不感冒，我找了个宣发片，一起感受下3A大作的视觉冲击，而且还是我们从小听到大，那猴子🐒的故事。
‌‌什么是 3A 大作‌： 高成本、高质量、高体量的单机游戏。
– 视频
点击观看视频
说说《黑神话·悟空》用了什么编程语言
对于游戏来说，不论是网游、手游、还是单机游戏对流程度都要求很高，而每种技术都有他的瓶颈和天花板，所有技术选型就尤为重要。
搞技术的都心里大概知道每个编程语言的性能和优劣势，就像应该没有人用 PHP 写游戏引擎，也没有人用 C 语言写一个业务极度复杂的管理系统。当然 PHP 是全世界最好的编程语言。
根据游戏开发公司游戏科学官网的显示，《黑神话：悟空》游戏使用的是虚幻引擎（Unreal Engine）：
也就是他们主要是C++（也用到C#和其他语言）
而这个引擎的底层源码主要使用的就是C++。
虚幻引擎属于开源项目，大家自己学习或者开发一些免费的东西是可以直接用的。但如果要开发像《黑神话：悟空》这样的商业产品，那就得给钱了。按照他们的协议，当产品销售超过 100 万 $ 时，就要付 5% 的版税。
不说了，我去学 C++ 了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeec4962ce4dc74cd1173c2d7c0594cd/" rel="bookmark">
			数据结构之排序（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.排序的概念及其运用
1.1排序的概念
1.2 常见的排序算法
1.3排序的用途
二、排序的原理及实现 2.1插入排序
2.1.1基本思想 ：
2.1.2排序过程：
​编辑2.1.3代码实现
2.1.4直接插入排序的特性总结：
2.2希尔排序（希尔排序法又称缩小增量法）
2.2.1基本思想：
2.2.2排序过程：
2.2.3代码实现
2.2.4希尔排序的特性总结：
2.3选择排序
2.3.1基本思想：
2.3.2排序过程：
2.3.3代码实现
2.2.4直接选择排序的特性总结：
2.4堆排序
三、结尾
一.排序的概念及其运用 1.1排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
简单来讲，就是相同字母颜色不同的J，红色在前，蓝色在后，如图，蓝色的J经过排序之后排在了红色的J前面，则这样的排序称之为不稳定，反之，称之为稳定
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
1.2 常见的排序算法 1.3排序的用途 在店铺中，我们可以通过我们直接的需求来进行购物，而以价格从低到高，销量，评论数，这些就需要通过排序来供我们选择
二、排序的原理及实现 2.1插入排序 2.1.1基本思想 ： 直接插入排序是一种简单的插入排序法 ，其 基 本 思 想 是把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。
就如我们在摸牌时，摸到一张排，对手上的排从前往后依次比较，若比到比这张牌大的时候，就插入在这张排前面，其上这样的思想与插入排序大相径庭。
2.1.2排序过程： 插入思想：当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移。
2.1.3代码实现 void InsertSort(int* a, int n) { for (int i = 1; i &lt; n; i++) { int end = i - 1; int tmp = a[i]; // 将tmp插入到[0,end]区间中，保持有序 while (end &gt;= 0) { if (tmp &lt; a[end]) { a[end + 1] = a[end]; --end; } else { break; } } a[end + 1] = tmp; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeec4962ce4dc74cd1173c2d7c0594cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ecf06baf73b71b75418ff5a7a974c21/" rel="bookmark">
			数据仓库系列4-什么是维度建模,它与关系型建模有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想象一下,你正在分析一家大型零售连锁店的销售数据。突然,你意识到传统的数据库模型无法有效地回答"去年黑色星期五当天,哪个地区的哪类产品销售额最高?"这样的复杂问题。这就是维度建模发挥作用的时候了
目录 引言:维度建模的魔力什么是维度建模?维度建模的定义维度建模的起源 维度建模 vs 关系型建模:关键区别关系型模型示例:维度模型示例(星型模式): 维度建模的核心概念1. 事实表(Fact Table)2. 维度表(Dimension Table)3. 星型模式(Star Schema)4. 雪花模式(Snowflake Schema)5. 缓慢变化维度(Slowly Changing Dimensions, SCD)6. 退化维度(Degenerate Dimension)7. 聚集事实(Aggregate Fact) 实际案例:零售业维度模型业务需求维度模型设计1. 事实表: FactSales2. 维度表: DimDate3. 维度表: DimProduct4. 维度表: DimStore5. 维度表: DimCustomer6. 维度表: DimPromotion 模型说明示例查询 维度建模的优势维度建模的挑战实施维度建模:最佳实践结论:选择正确的建模方法 引言:维度建模的魔力 在大数据时代,企业面临着前所未有的数据分析挑战。传统的关系型数据库模型在处理复杂的多维度查询时往往力不从心。这就是维度建模横空出世的原因 —— 它为数据仓库和商业智能系统提供了一种革命性的数据组织方法。
本文将深入探讨维度建模的本质,揭示它与传统关系型建模的根本区别,并通过具体示例展示其在现实世界中的应用。无论你是数据架构师、BI开发人员,还是对数据建模感兴趣的技术爱好者,这篇文章都将为你打开一扇通往高效数据分析的大门。
什么是维度建模? 维度建模是一种专为数据仓库和商业智能(BI)系统设计的数据建模技术。它的核心思想是将复杂的业务数据组织成直观、易于理解和高效查询的结构。
维度建模的定义 维度建模是一种数据组织和访问技术,它:
将数据分为事实(度量)和维度(上下文)两类。采用星型模式或雪花模式来组织这些事实和维度。优化了面向商业用户的查询性能和易用性。
维度建模的起源 维度建模的概念最早由Ralph Kimball在20世纪90年代提出。Kimball观察到,传统的实体关系(ER)建模虽然适合事务处理系统,但在支持复杂的分析查询时表现不佳。他提出了一种新的方法,将业务过程的度量(如销售额)放在中心,周围环绕着描述这些度量的维度(如时间、产品、客户等)。
维度建模 vs 关系型建模:关键区别 要真正理解维度建模的价值,我们需要将其与传统的关系型建模进行对比。以下是几个关键区别:
设计目标
关系型建模:主要目标是减少数据冗余,确保数据一致性。维度建模:主要目标是优化查询性能和提高数据的可理解性。 数据结构
关系型建模:通常使用高度规范化的表结构。维度建模:使用非规范化或部分规范化的星型或雪花型结构。 查询复杂性
关系型建模:复杂查询可能需要多个表连接,影响性能。维度建模:简化了复杂查询,减少了表连接的需求。 数据冗余
关系型建模:尽量减少数据冗余。维度建模:允许一定程度的冗余以提高查询效率。 灵活性
关系型建模:修改模式可能比较困难。维度建模:更容易适应新的业务需求和维度。 用户友好性
关系型建模:对于业务用户来说可能较难理解。维度建模:结构直观,易于业务用户理解和使用。 为了更清晰地展示这些差异,让我们看一个具体的例子:
假设我们有一个简单的销售系统,需要记录产品销售信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ecf06baf73b71b75418ff5a7a974c21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80214e184b5ca6f5aa091acafdfbb677/" rel="bookmark">
			WebLlama：基于Llama-3的网页浏览助手开发指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebLlama：基于Llama-3的网页浏览助手开发指南 webllamaLlama-3 agents that can browse the web by following instructions and talking to you项目地址:https://gitcode.com/gh_mirrors/we/webllama 项目介绍 WebLlama 是一个由 McGill-NLP 团队创建的开源项目，旨在构建能够通过接受指令并进行对话来辅助用户浏览网页的人工智能代理。该项目利用了 Meta AI 的 Llama-3 大型语言模型，并对其进行专门的微调以优化网页导航任务。WebLlama 的设计哲学是增强而非替代用户的上网体验，提供本地可审计的强大辅助工具，解决云服务可能存在的昂贵成本、高延迟及隐私安全顾虑。
项目快速启动 要开始使用 WebLlama，首先确保你的开发环境已准备就绪，包括安装必要的Python库和依赖项。以下步骤将引导你完成初始设置：
步骤1：克隆项目仓库 在终端中运行以下命令以克隆 webllama 项目到本地：
git clone https://github.com/McGill-NLP/webllama.git cd webllama 步骤2：安装依赖 使用 pip 安装项目所需的依赖包：
pip install -r requirements.txt 步骤3：快速启动示例 接下来，你可以通过调用特定的脚本或API来启动WebLlama，并给予它简单的浏览指令。这里提供一个简化的交互示例，具体实现细节需参考项目中的具体说明文件：
from webllama.agent import WebLlamaAgent agent = WebLlamaAgent() response = agent.interact("打开Google主页并搜索'人工智能最新进展'") print(response) 请注意，实际使用时，你可能需要配置更多细节，如API密钥、浏览器集成等，具体遵循项目文档的指引。
应用案例和最佳实践 WebLlama可以应用于多种场景，例如自动化市场研究、辅助数据分析、快速查找特定信息或进行在线教育辅助。最佳实践建议包括：
明确指令：给定清晰、具体的任务指令，有助于提高执行效率。上下文理解：利用其对话能力，让WebLlama理解前后对话的内容，进行更连贯的操作。安全性考虑：在涉及个人数据或敏感操作时，谨慎使用，并确保数据保护措施到位。 典型生态项目 WebLlama作为一款创新工具，它的生态系统仍在持续发展之中。开发者可以基于此项目构建定制化的网络助手服务，比如：
个性化新闻摘要: 结合RSS订阅源，自动获取并总结用户感兴趣的新闻。学术文献检索: 帮助研究人员快速找到相关领域的最新论文。在线教育资源整合: 为学生和教师提供一站式的学习材料搜集服务。 在构建这类应用时，社区的贡献和二次开发极为重要，鼓励开发者积极参与，共同推动WebLlama及其生态系统的成熟与完善。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80214e184b5ca6f5aa091acafdfbb677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/391e9f3ea622bd85e69704e529641bb5/" rel="bookmark">
			LeetCode //C - 330. Patching Array
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		330. Patching Array Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.
Return the minimum number of patches required.
Example 1: Input: nums = [1,3], n = 6
Output: 1
Explanation:
Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/391e9f3ea622bd85e69704e529641bb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f34f3f5279363a4928e12d7f94fd12/" rel="bookmark">
			小程序的数据驱动和vue的双向绑定有何异同？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序的数据驱动和Vue的双向绑定在现代应用程序开发中扮演着重要角色，它们都是为了提高开发效率和用户体验而设计的。以下是对两者异同点的详细分析：
相同点 目的相同：都是为了实现数据与视图的自动同步，使得开发者可以更加专注于业务逻辑的处理，而无需过多地关注界面更新。基于观察者模式：两者都采用了观察者模式来建立数据与视图之间的关联，当数据发生变化时，能够自动触发视图的更新。响应式机制：小程序和Vue都具备响应式机制，即当数据发生变化时，能够实时地反映到视图上，保持UI与数据的同步。 不同点 实现方式 小程序：主要通过WXML模板和JS脚本实现数据驱动。开发者中在定义JS数据，通过setData方法更新数据，WXML模板则负责将数是据渲染到视图上。这种方式下，数据绑定单向的，即从数据到视图。Vue：通过模板引擎和响应式数据等机制实现双向绑定。开发者在Vue实例的data选项中定义数据，使用v-model等指令在模板中绑定数据。Vue的双向绑定支持从视图到数据和从数据到视图的双向同步。视图渲染 小程序：视图渲染是基于组件的，需要开发者手动编写组件的模板和逻辑。小程序的组件系统提供了丰富的组件库，但开发者也需要根据需求自定义组件。Vue：视图渲染同样是基于组件的，但Vue的组件系统更加灵活和强大。Vue组件支持单文件组件（.vue文件），将模板、逻辑和样式封装在一起，便于复用和维护。双向绑定支持 小程序：虽然小程序也支持数据驱动，但其双向绑定能力相对较弱。在需要实现双向绑定的场景（如表单输入），通常需要通过事件监听和手动调用setData方法来更新数据，实现类似双向绑定的效果。Vue：Vue提供了强大的双向绑定能力，通过v-model指令可以轻松实现表单输入与数据的双向同步。此外，Vue还提供了.sync修饰符和自定义事件等方式来实现更复杂的双向绑定场景。生态系统与扩展性 小程序：小程序的生态系统相对封闭，主要面向移动端应用开发。虽然小程序平台提供了丰富的API和组件库，但在功能扩展和第三方库支持方面可能受到一定限制。Vue：Vue作为一个通用的前端框架，拥有庞大的社区和丰富的生态系统。Vue提供了官方状态管理库Vuex、路由库Vue Router等，方便开发者构建复杂的应用程序。同时，Vue也支持丰富的第三方库和插件，使得功能扩展更加灵活和方便。 综上所述，小程序的数据驱动和Vue的双向绑定在目的、实现方式和响应式机制等方面存在相似之处，但在实现方式、视图渲染、双向绑定支持和生态系统与扩展性等方面存在明显差异。开发者在选择使用哪种技术时，需要根据具体的应用场景和需求进行权衡和选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781bd133178624bc5daa003474c1c27f/" rel="bookmark">
			C#进阶-实现基于ADO.NET框架的DBHelper工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#开发中，与数据库的交互是常见的需求。通常，我们会使用ADO.NET直接执行SQL查询，虽然这种方法非常灵活，但容易导致代码重复，并且在处理多个SQL语句时容易出错。为了提高代码的可维护性和复用性，封装一个通用的数据库操作助手类（DBHelper）是非常有必要的。本文将详细介绍如何创建和使用一个DBHelper类来简化数据库操作。
一、ADO.NET简介 ADO.NET是.NET框架中用于与数据库交互的核心组件。它提供了一套用于连接数据库、执行SQL查询、插入、更新和删除数据的类库，包括SqlConnection、SqlCommand、SqlDataReader等。这些类提供了对底层数据库操作的直接控制，但同时也要求开发者手动编写SQL语句和管理数据库连接，容易导致代码冗长和重复。正因为如此，在复杂项目中，开发者往往会选择封装这些底层操作，以提高代码的复用性和维护性。
ADO.NET 特色类库
类库名称描述SqlConnection管理与数据库的连接。用于打开和关闭数据库连接。SqlCommand用于执行SQL语句，如查询、插入、更新和删除操作。SqlDataReader用于逐行读取数据查询结果，提供高效的只进读访问。SqlDataAdapter在数据库与DataSet之间桥接数据，支持填充和更新DataSet中的数据。DataSet用于存储内存中数据的离线副本，可以包含多个数据表和关系。DataTable表示内存中数据表的结构，包括表的列、行和约束。SqlParameter用于参数化查询，帮助防止SQL注入攻击并提供对参数化命令的支持。 二、DBHelper类的设计 DBHelper类的核心目标是封装常用的数据库操作，如执行查询、执行命令、获取数据集等。它通过统一的接口和简单的封装，减少了直接与ADO.NET打交道的复杂性，使得数据库操作更加简洁和安全。
DBHelper工具类示例代码如下：
namespace Test { public static class DBHelper { // 请根据实际情况设置数据库连接字符串 private static readonly string connectionString = "your_connection_string_here"; /// &lt;summary&gt; /// 执行一个查询，返回结果集中第一行的第一列。 /// &lt;/summary&gt; public static int GetScalar(string sql, SqlParameter[] parameters = null) { using (SqlConnection conn = new SqlConnection(connectionString)) { using (SqlCommand cmd = new SqlCommand(sql, conn)) { if (parameters != null) { cmd.Parameters.AddRange(parameters); } conn.Open(); object result = cmd.ExecuteScalar(); return result !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781bd133178624bc5daa003474c1c27f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/25/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>