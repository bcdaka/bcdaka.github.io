<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ca9c4d4c16dbbeba487094898eec47/" rel="bookmark">
			数据结构（单链表（1））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 线性表中有着许多的结构，如顺序表和链表。而单链表则是链表的最基础的一种形式，下面就让我们对其做一个了解。
概念 概念：链表是⼀种物理存储结构上⾮连续、⾮顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
结构 我们可以将单链表的结构想象成火车的车厢：
淡季时⻋次的⻋厢会相应减少，旺季时⻋次的⻋厢会额外增加⼏节。只需要将⽕⻋⾥的某节⻋厢去掉/ 加上，不会影响其他⻋厢，每节⻋厢都是独⽴存在的。 在链表⾥，每节“⻋厢”是什么样的呢？
如图：
结点 与顺序表不同的是，链表⾥的每节"⻋厢"都是独⽴申请下来的空间，我们称之为“结点”。
结点的组成主要有两个部分：当前结点要保存的数据和保存下⼀个结点的地址（指针变量）。
中指针变量plist保存的是第⼀个结点的地址，我们称plist此时“指向”第⼀个结点，如果我们希望 plist“指向”第⼆个结点时，只需要修改plist保存的内容为0x0012FFA0。
链表中每个结点都是独⽴申请的（即需要插⼊数据时才去申请⼀块结点的空间），我们需要通过指针变量来保存下⼀个结点位置才能从当前结点找到下⼀个结点。
性质 1、链式结构在逻辑上是连续的，在物理结构上不⼀定连续
2、结点⼀般是从堆上申请的
3、从堆上申请来的空间，是按照⼀定策略分配出来的，每次申请的空间可能连续，可能不连续
结合C语言中结构体的相关知识，我们能得到链表的每个结点对应的结构体代码： 假设当前保存的结点为整型：
struct SListNode { int data; //结点数据 struct SListNode* next; //指针变量⽤保存下⼀个结点的地址 }; 当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数 据，也需要保存下⼀个结点的地址（当下⼀个结点为空时保存的地址为空）。
当我们想要从第⼀个结点⾛到最后⼀个结点时，只需要在当前结点拿上下⼀个结点的地址就可以了。
链表的打印 给定的链表结构中，我们该如何实现结点从头到尾的打印呢？
我们用一张图来解释：
实现单链表 下面我先给出实现单链表所必须的头文件，（SList.h）
typedef int SLTDataType; typedef struct SListNode { SLTDataType data; //结点数据 struct SListNode* next; //指针保存下⼀个结点的地址 }SLTNode; void SLTPrint(SLTNode* phead); //头部插⼊删除/尾部插⼊删除 void SLTPushBack(SLTNode** pphead, SLTDataType x); void SLTPushFront(SLTNode** pphead, SLTDataType x); void SLTPopBack(SLTNode** pphead); void SLTPopFront(SLTNode** pphead); //查找 SLTNode* SLTFind(SLTNode* phead, SLTDataType x); //在指定位置之前插⼊数据 void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x); //删除pos结点 void SLTErase(SLTNode** pphead, SLTNode* pos); //在指定位置之后插⼊数据 void SLTInsertAfter(SLTNode* pos, SLTDataType x); //删除pos之后的结点 void SLTEraseAfter(SLTNode* pos); //销毁链表 void SListDestroy(SLTNode** pphead); 具体的实现我将在下一期进行详细说明，敬请期待！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b027440a6ee7709a9830328a5c972332/" rel="bookmark">
			ConfigMap-secrets-静态pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.ConfigMap 1.概述 ConfigMap资源，简称CM资源，它生成的键值对数据，存储在ETCD数据库中
应用场景：主要是对应用程序的配置
pod通过env变量引入ConfigMap，或者通过数据卷挂载volume的方式引入ConfigMap资源
官方解释：
configMap 卷提供了向 Pod 注入配置数据的方法。 ConfigMap 对象中存储的数据可以被 configMap 类型的卷引用，然后被 Pod 中运行的容器化应用使用。
引用 configMap 对象时，你可以在卷中通过它的名称来引用。 你可以自定义 ConfigMap 中特定条目所要使用的路径。 下面的配置显示了如何将名为 log-config 的 ConfigMap 挂载到名为 configmap-pod 的 Pod 中
2.查看k8s集群系统中都有哪些资源类型 [root@master demo]# kubectl api-resources 3.ConfigMap资源管理 · 创建工作目录 [root@master demo]# mkdir configmap [root@master demo]# cd configmap · 创建ConfigMap资源 1.声明式创建ConfigMap资源 · 编辑ConfigMap资源清单 [root@master a]# cat 01-cm.yaml apiVersion: v1 kind: ConfigMap metadata: name: cm01 #声明cm资源的数据 data: #第一种写法【key：value】 demo: demo-cm k8s: kubernets #第二种写法【key:| value value value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b027440a6ee7709a9830328a5c972332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ad6a16796dcd60ef20cb014021035f/" rel="bookmark">
			数据结构之初始二叉树（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
树型结构
树的概念 与树的有关概念
树的表示形式 树的应用 二叉树 概念
两种特殊的二叉树 二叉树的性质
有关二叉树的性质的练习 二叉树的存储
二叉树的遍历
二叉树遍历的练习
树型结构 树的概念 在正式学习二叉树之前，我们先来了解一下：数据结构中什么是树型结构。我们前面学习的顺序表、链表、栈、队列这些都是线性结构的。
树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看 起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
左边是大自然中正常的树，右边是数据结构中的树。 数据结构中的树具有以下的特点：
1、有一个特殊的结点，称为根结点，根结点没有前驱结点。
2、除根结点外，其余结点被分成M(M &gt; 0)个互不相交的集合T1、T2、......、Tm，其中每一个集合Ti (1 &lt;= i &lt;= m) 又是一棵与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继。总结就是一句话：子树与子树之间不能有相交的部分，相交了就不能称之为树了。
3、树是递归定义的。
4、除了根结点外，每个结点有且仅有一个父结点。
5、一棵N个结点的树有N-1条边。
与树的有关概念 重点掌握：
结点的度：一个结点所含的子树的个数，也就是一个节点多少条边。
树的度：因为树有多个结点，因此树结点就是整个树中 所有 结点的度 的最大值。
叶子结点或终端结点：度为0的点，也就是没有边的点。
双亲结点或父结点：若一个结点A含有子结点B，则称该节点A为父结点。
孩子结点或子结点：若一个结点A含有子结点B，则称该节点B为子结点。
根结点：一棵树中，没有 双亲结点 的 结点，就是最上面的那个结点。
结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推。
树的高度或深度：树中结点的最大层次，其实就是从根节点到叶子结点之间的最大值。
了解即可：
非终端结点或分支结点：度不为0的结点。
兄弟结点：具有相同 父结点 的 结点 互称 为兄弟结点。
堂兄弟结点：双亲在同一层的结点，它们的子结点 互为 堂兄结点。
结点的祖先：从根到该结点所经分支上的所有结点，都称为该结点的祖先。
子孙：以某结点为根的子树中任一结点都称为该结点的子孙。
森林：只要是能构成树的结点，就可以称为森林。例如：一颗树有一个节点，那么构成这棵树的这个结点也可以称为森林。
树的表示形式 树的结构相对线性表就比较复杂了，要存储表示起来就比较麻烦，实际中树有很多种表示方式，如：双亲表示法， 孩子表示法、孩子双亲表示法、孩子兄弟表示法等等。我们这里就简单的了解其中最常用的孩子兄弟表示法。 顾名思义：这个节点中可以储存其孩子和兄弟：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7ad6a16796dcd60ef20cb014021035f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814f6a39e0a08c191fb57e2860e90316/" rel="bookmark">
			[AHK] WinHttpRequest.5.1报错 0x80092004 找不到对象或属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景描述
用浏览器访问，正常返回
​编辑
AHK v2官方示例源代码
AHK v2运行结果报错(0x80092004) 找不到对象或属性
用thqby大佬的WinHttpRequest.ahk库测试报错 0x80092004 找不到对象或属性
附：
用Apifox访问，也正常返回
AHK v1 官方示例源代码
AHK v1运行失败报错 0x80092004 找不到对象或属性
用Msxml2.XMLHTTP则能正常得到结果
背景描述 想通过ahk编程，获取 https://autohotkey.com/download/2.0/version.txt 的文件内容。
在确认用浏览器可以正常访问情况下，用官方帮助中的示例运行会报错 Error: (0x80092004) 找不到对象或属性。用 thqby大佬的 WinHttpRequest.ahk 网络请求库 https://github.com/thqby/ahk2_lib/blob/master/WinHttpRequest.ahk 也报同样错误。
求指点
用浏览器访问，正常返回 AHK v2官方示例源代码 whr := ComObject("WinHttp.WinHttpRequest.5.1") whr.Open("GET", "https://autohotkey.com/download/2.0/version.txt", true) whr.Send() whr.WaitForResponse() version := whr.ResponseText MsgBox version AHK v2运行结果报错(0x80092004) 找不到对象或属性 如果把参数 true改为 false ,报错如下：
用thqby大佬的WinHttpRequest.ahk库测试报错 0x80092004 找不到对象或属性 /************************************************************************ * @file: WinHttpRequest.ahk * @description: 网络请求库 * @author thqby * @date 2021/08/01 * @version 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814f6a39e0a08c191fb57e2860e90316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb15abac65a3859ec611c9012b3438ea/" rel="bookmark">
			Sentinel规则持久化Push模式两种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 sentinel持久化push推模式微服务端的实现具体实现源码分析读数据源写数据源的实现 微服务端解析读数据源流程 修改源码的实现官方demo修改源码实现配置类flowauthoritydegreadparamsystemgateway修改源码 测试补充 前置知识 pull模式
sentinel持久化push推模式 pull拉模式的缺点，以保存本地文件举例：
定时任务是每隔3s执行一次，去判断规则持久化文件的最后修改时间。这里有一定时间的延迟，但如果时间设置的太短，有影响服务器的性能我们的微服务是集群部署的，其他服务实例可读取不到我这台服务器的本地文件 所以还有一种push推送模式。我们一般会引入第三方中间件来实现，以Nacos为例。我们修改了nacos中的配置，它就会将更新后的数据推送给微服务。
push模式有两种实现方式：
在微服务端添加读数据源，为dataId添加监听器，当规则配置文件更改之后我就获取到更改后的规则内存并更新内存中的数据；再添加一个写数据源，每当dashboard中更新了规则，我除了更新内存中的数据之外，我通过ConfigService.publishConfig()方法还往Nacos端进行写入
在dashboard源码中进行更改，在获取规则内容、更新规则内容的接口中，不要和微服务端进行交互，直接去和Nacos通信，通过ConfigService.publishConfig()和ConfigService.getConfig()来实现。这种方式主要注意dashboard端的规则实体对象和微服务端的规则实体对象不一致问题，需要经过转换相关的操作。sentinel默认情况下就直接把规则实体转换为json字符串推送给Nacos，Nacos配置文件更改了，又推送给微服务，微服务这边再把json字符串转换为规则实体对象这一步就会发现，转换失败了，某些属性对应不上。进而就导致了dashboard端设置的规则在微服务这边未生效。
微服务端的实现 具体实现 引入读数据源的依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;/dependency&gt; 配置文件中添加规则持久化的dataId
server: port: 8806 spring: application: name: mall-user-sentinel-rule-push #微服务名称 #配置nacos注册中心地址 cloud: nacos: discovery: server-addr: 127.0.0.1:8848 sentinel: transport: # 添加sentinel的控制台地址 dashboard: 127.0.0.1:8080 datasource: # 名称自定义，可以随便定义字符串 flow-rules: nacos: server-addr: 127.0.0.1:8848 # dataId取了微服务名字，后面再拼接字符串 dataId: ${spring.application.name}-flow-rules # 我这里在Nacos配置中心，单独使用了一个组 groupId: SENTINEL_GROUP username: nacos password: nacos data-type: json rule-type: flow degrade-rules: nacos: server-addr: 127.0.0.1:8848 dataId: ${spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb15abac65a3859ec611c9012b3438ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45a7b6b754a839925491716d5a661a9/" rel="bookmark">
			【qt】考试系统项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说,先一睹芳颜
咱们的账号,题库和答案都是通过文件获取的.
话不多说,直接开干
目录 一.登录窗口1.界面设计2.邮箱验证3.登录验证 二.题库窗口1.考试计时2.布局管理器3.题库显示4.按钮布局5.计算分数 三.窗口交互四.完整代码五.结语 一.登录窗口 1.界面设计 这里添加背景图片.
密码输入模式和提示语句.
注意:背景图标放在的标签必须要第一个,不然会盖住其他组件.
2.邮箱验证 用正则表达式来进行判断.
3.登录验证 第一行读取的话,要跳过,我们不用.
中间有多个空格,所以我们可以使用正则表达式来进行匹配来获取子串.
如果循环完都没有找到就说明我们输入的账号有问题,所以这个是循环读取外面加的.
二.题库窗口 1.考试计时 需要用到计时器
每隔一秒,我们就发出timeout()这个信号.
然后计算分秒来设置在窗口的标题上.
对窗口进行一点的渲染.
2.布局管理器 这是一个神器,当我们用代码来写组件的时候,有了它,你可以高枕无忧的布局.
下面我们布局组件的时候可以来看布局管理器怎么使用.
3.题库显示 定义了这个来保存我们的答案,方便我们后面计算分数.
添加到组件上,并使用布局管理器.
第一个参数是要添加布局的组件
第二三个参数是这个组件的位置,可以把布局管理器理解成一个表格,从0行0列开始
第四五哥参数是这个组件所占的行数和列数.
4.按钮布局 用的组件数组来初始化.
初始化单选题的时候,我们要进行分组,这样才可以每个题选一项.
同时添加到布局管理器中.
初始化按钮并关联槽函数,来计算分数.
5.计算分数 在计算分数前,我们先来判断是否所有的题都已答完,若没有就继续.
单选题只需要判断每个单选组里面有没有选择的即可.
多选题记一下数,看是不是大于等于2即可
接下来就是正式的算分了.
多选题的算分比较复杂
先获取答案中有那些选项,我们用bool类型来设置状态.
然后与多选框的每个选项状态一一对比.
完全一样才得分.
单选题和判断题都从按钮组中获取到文本来与我们先前获取到的答案进行对比.
显示分数,并给用户选择是否重新答题.
三.窗口交互 现在,我们的两个窗口都写好了,怎么衔接起来呢?
这个可以关闭当前的窗口,并返回一种用户点击的信息.
在main中用模态的方式,来进行接受信息.
并构造我们的考试窗口.
在考试窗口的构造函数中进行显示,以防未初始化窗口就进行显示.
四.完整代码 examdialog.h
#ifndef EXAMDIALOG_H #define EXAMDIALOG_H #include &lt;QDialog&gt; #include &lt;QTimer&gt; #include &lt;QGridLayout&gt; #include &lt;QTextEdit&gt; #include &lt;QRadioButton&gt; #include &lt;QCheckBox&gt; #include &lt;QPushButton&gt; #include &lt;QLabel&gt; #include &lt;QButtonGroup&gt; class ExamDialog : public QDialog { Q_OBJECT public: ExamDialog(QWidget *parent=0); void initTimer(); void initLayout(); bool initTextEdit(); void initButton(); bool hasSelected(); void getScores(); private: QTimer*m_timer; int m_sec=0; QGridLayout*m_layout; QTextEdit*m_textEdit; QLabel*m_label[10]; QRadioButton*m_radioBtn[32]; QRadioButton*m_radioA; QRadioButton*m_radioB; QCheckBox*m_CheckBoxBtn[4]; QStringList answers; QButtonGroup*BtnGroup[9]; private slots: void onTimeout(); void onBtn(); }; #endif // EXAMDIALOG_H examdialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c45a7b6b754a839925491716d5a661a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ab8df5135825bc9f5ff7c30609f02f/" rel="bookmark">
			Spark SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark SQL 一、Spark SQL架构 能够直接访问现存的Hive数据
提供JDBC/ODBC接口供第三方工具借助Spark进行数据处理
提供更高层级的接口方便处理数据
支持多种操作方式：SQL、API编程
API编程：Spark SQL基于SQL开发了一套SQL语句的算子，名称和标准的SQL语句相似 支持Parquet、CSV、JSON、RDBMS、Hive、HBase等多种外部数据源。(掌握多种数据读取方式)
Spark SQL核心：是RDD+Schema(算子+表结构)，为了更方便我们操作，会将RDD+Schema发给DataFrame
数据回灌：用于将处理和清洗后的数据回写到Hive中，以供后续分析和使用。
BI Tools：主要用于数据呈现。
Spark Application：开发人员使用Spark Application编写数据处理和分析逻辑，这些应用可以用不同的编程语言编写，比如Python、Scala、Java等。
二、Spark SQL运行原理 Catalyst优化器的运行流程： Frontend（前端） 输入：用户可以通过SQL查询或DataFrame API来输入数据处理逻辑。Unresolved Logical Plan（未解析的逻辑计划）：输入的SQL查询或DataFrame转换操作会首先被转换为一个未解析的逻辑计划，这个计划包含了用户请求的所有操作，但其中的表名和列名等可能尚未解析。 Catalyst Optimizer（Catalyst优化器） Catalyst优化器是Spark SQL的核心组件，它负责将逻辑计划转换为物理执行计划，并进行优化。Catalyst优化器包括以下几个阶段： Analysis（分析）：将未解析的逻辑计划中的表名和列名解析为具体的元数据，这一步依赖于Catalog（元数据存储）。输出是一个解析后的逻辑计划。Logical Optimization（逻辑优化）：对解析后的逻辑计划进行各种优化，如投影剪切、过滤下推等。优化后的逻辑计划更加高效。Physical Planning（物理计划）：将优化后的逻辑计划转换为一个或多个物理执行计划。每个物理计划都代表了一种可能的执行方式。Cost Model（成本模型）：评估不同物理计划的执行成本，选择代价最低的物理计划作为最终的物理计划。 Backend（后端） Code Generation（代码生成）：将选择的物理计划转换为可以在Spark上执行的RDD操作。这一步会生成实际的执行代码。RDDs：最终生成的RDD操作被执行，以完成用户请求的数据处理任务。 一个SQL查询在Spark SQL中的优化流程 SELECT name FROM( SELECT id, name FROM people ) p WHERE p.id = 1 Filter下压：将Filter操作推到更靠近数据源的位置，以减少不必要的数据处理。合并Projection：减少不必要的列选择IndexLookup return:name：如果存在索引，可以直接通过索引查找并返回name列 三、Spark SQL API SparkContext：Spark应用的主入口，代表了与Spark集群的连接。
SQLContext：Spark SQL的编程入口，使用SQLContext可以运行SQL查询、加载数据源和创建DataFrame。
HiveContext：SQLContext的一个子集，可以执行HiveQL查询，并且可以访问Hive元数据和UDF。
SparkSession：Spark2.0后推荐使用，合并了SQLContext和HiveContext，提供了与Spark所有功能交互的单一入口点。
创建一个SparkSession就包含了一个SparkContext。
若同时需要创建SparkContext和SparkSession，必须先创建SparkContext再创建SparkSession。否则，会抛出如下异常，提示重复创建SparkContext：
详细解释 创建SparkSession的代码 val conf: SparkConf = new SparkConf() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ab8df5135825bc9f5ff7c30609f02f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df830ef302bbf882da0d712990439391/" rel="bookmark">
			【学习笔记】无人机（UAV）在3GPP系统中的增强支持(十三)-更换无人机控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 本文是3GPP TR 22.829 V17.1.0技术报告，专注于无人机（UAV）在3GPP系统中的增强支持。文章提出了多个无人机应用场景，分析了相应的能力要求，并建议了新的服务级别要求和关键性能指标（KPIs）。
下载资源：3GPPTR22.829R17EnhancementforUnmannedAerialVehicles资源-CSDN文库
主要内容包括：
无人机高清视频直播：支持4K乃至8K视频实时上传，要求低延迟、高可靠性和精确定位，以避免事故。无人机作为空中基站：在灾难监测等场景中，无人机携带基站设备，提供临时覆盖，强调快速部署和灵活配置。无人机命令与控制（C2）通信：定义了直接C2、网络辅助C2等多种模式，强调QoS保障和安全性，以适应不同飞行环境和需求。无人机与地面用户共存：探讨了无人机与增强型移动宽带（eMBB）用户共享网络资源时的干扰最小化问题。自主无人机控制：AI系统通过5G网络控制无人机，对上下行传输提出了高带宽和低延迟要求，并需要高精度定位信息。无人机群管理：支持无人机群在物流等领域的应用，强调群管理和协同作业能力。服务可用性和体验保障：提出通过边缘计算和路径优化，确保无人机通信服务的低延迟和高可靠性。 文章最后总结了无人机通信服务的潜在要求，并建议3GPP制定相关服务规范，以更好地支持无人机生态系统的发展。
5.12 更换无人机控制器 5.12.1 描述
无人机与无人机控制器建立关联并开始飞行任务后，C2链路即建立，并正常支持无人机系统（UAS）的操作。在某些场景下，例如无人机飞出视线范围或发生紧急事件时，无人机控制器将由另一个无人机控制器或优先级更高的无人机控制器接管。在这种情况下，应与新的无人机控制器建立C2连接，以确保对飞行任务的持续支持。此外，还可以根据无人机交通管理系统（UTM）和运营商的政策考虑进行一些流程优化。
根据中国IMT2020(5G)推进组发布的《5G无人机应用白皮书》，无人机支持远程控制器应用的性能要求如下表所示：
Table 5.1.12.1-1: KPIs for Changing UAV Controller
Application
Upload data rate(UL)
Remote control data rate(DL)
E2E latency
Control latency
Positioning Accuracy
Altitude
Region
Remote controller through HD video
25Mbps
300Kbps
&lt;200ms
20ms
0.5m
&lt;100m
Urban, Rural, countryside
注：根据TS 22.125第5.3条，无人机的相对飞行速度可达320km/h。
在无人机控制器更换后，无人机与无人机控制器之间的连接质量至关重要。如果C2链路质量下降甚至断开，无人机和无人机控制器需要能够检测到这种情况，并应采取一些行动，例如根据配置自动返回无人机。
5.12.2 先决条件
无人机“bumblebee”已与由Bob装备的无人机控制器A相关联，以执行飞行任务。在任务期间，C2连接由运营商X提供。
5.12.3 服务流程
当“bumblebee”飞出Bob的视线范围时，Bob需要将无人机控制器A更换为远程无人机控制器B，以便继续与其无人机协同工作。
UTM同意并授权远程无人机控制器B接管无人机“bumblebee”以继续飞行任务。
UTM要求3GPP系统为新的无人机控制器B与无人机“bumblebee”和UTM建立C2连接，同时要求3GPP系统断开无人机控制器A的C2连接。
无人机控制器B继续控制无人机“bumblebee”。
无人机控制器A无法控制无人机“bumblebee”。
5.12.4 后续条件
无人机“bumblebee”在新的远程无人机控制器B的指挥下继续其飞行任务。
5.12.5 部分或完全覆盖用例功能的现有功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df830ef302bbf882da0d712990439391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8592773435f9765a7ec906cb0470bed1/" rel="bookmark">
			SM2椭圆曲线公钥密码算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 SM2加密与解密算法与实现
（1）按照有效的椭圆曲线参数生成椭圆曲线
（2）掌握 SM2加密与解密算法原理
（3）将字符串明文转换为比特串格式之间转换，能够将有意义的消息 转换为比特串进行加密，并将解密的结果还原为字符串
硬件：运行 Windows 操作系统的计算机
软件：Python
二、方案设计 背景 SM2算法是中国国家密码管理局（CNCA）发布的一种基于椭圆曲线的非对称加密算法。它采用椭圆曲线密码体系（Elliptic Curve Cryptography，ECC）进行密钥交换、数字签名和公钥加密等功能。SM2算法包括SM2-1椭圆曲线数字签名算法、SM2-2椭圆曲线密钥交换协议和SM2-3椭圆曲线公钥加密算法，分别用于实现数字签名、密钥协商和数据加密等功能。
SM2算法于2010年12月17日首次公开发布，并在2012年成为中国商用密码标准（标准号为GM T 0003—2012），2016年成为中国国家密码标准。该算法的安全性基于椭圆曲线离散对数难题，具有较小的密钥长度、更快的运算速度和更高的安全性，相对于RSA算法具有显著优势。
原理 1.椭圆曲线 椭圆曲线不是椭圆，之所以叫椭圆曲线，是因为其表达式和计算椭圆周长的积分表达式有相似之处，这就是椭圆曲线名称的由来。椭圆周长的积分表达式为:
其中，E(x)是x的三次或四次多项式。
Weierstrass型椭圆曲线是在椭圆曲线密码体制中的一种最常用的曲线:
j称为不变量，当俩条椭圆曲线相同时，则它们同构。
通过变量置换：
得到常用仿射坐标方程简化形式： 判别式为： 2.椭圆曲线离散对数问题(ECDLP) 给定定义在有限域Fp上的椭圆曲线E，及E上的一个n阶点G，和另一点Q，如果存在k，0&lt;k&lt;n-1，使Q=kG，则称k是Q的以G为基的离散对数。
由k和G，求Q容易。
由G和Q，求k困难。
ECC就是建立在求解相应加法群中ECDLP困难基础上的。
3.SM2算法 SM2-算法-密钥生成算法 （1）选择随机整数 。
（2）以G为基点，计算点 。
（3）密钥是，其中d是私钥，P是公钥。
SM2-算法-加密算法 设需要发送的明文为比特串M，klen为M的比特长度。用户A获得用户B的公钥后：
（1）选择随机数 。
（2）计算椭圆曲线点，并将的数据类型转换为比特串。
（3）计算椭圆曲线点（ℎ为余因子，为椭圆曲线
的阶，n 是基点G的阶），若S是无穷远点，则报错并退出。
（4）否则计算椭圆曲线点，并将坐标的数据类型转换为比特
串。
（5）计算，若t为全0比特串，则回退至步骤（1）。
（6）否则计算、 。
（7）输出密文。
SM2-算法-解密算法 用户B用自身的私钥对密文解密，设klen为密文中的比特长度：
（1）从C中取出比特串C_1，将C_1的数据类型转换为椭圆曲线上的点，验证是否满足
椭圆曲线方程，若不满足，则报错并退出。
（2）否则计算椭圆曲线点S=[ℎ]C_1，若S是无穷远点，则报错并退出。
（3）否则计算[d_B]C_1=(x_2,y_2)，并将坐标x_2、y_2的数据类型转换成比特串。
（4）计算t=KDF(x_2||y_2, klen) ，若t为全0比特串，则报错并退出。
（5）否则从C中取出比特串C_2，计算M^′=C_2⊕t 。
（6）计算u=Hash(x_2||M^′ ||y_2)，从C中取出比特串C_3，若u≠C_3，则报错并退出。
（7）否则输出明文M^′=C_2⊕t。
三、方案实现 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8592773435f9765a7ec906cb0470bed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c336e8a9bcac6efd6d706c252e2014d5/" rel="bookmark">
			【前端素材】推荐优质大气的电商家具商城网站设计Umbra平台模板（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求分析 大气的电商家具商城网站是指通过互联网平台销售各类家具产品的电子商务网站，其特点是提供用户在线选购各种风格、价格区间的家具产品，并为用户提供方便的购物体验。以下是对大气的电商家具商城网站的详细分析和实现方案：
网站功能与特点： 产品展示与分类：网站应提供清晰的家具产品展示页面，包括高清图片、详细描述、价格和品牌信息。产品应按照不同的分类进行组织，如家具类型（沙发、床、桌椅等）、风格（现代、简约、欧式等）等。定制服务：提供家具定制服务，用户可以根据个人需求定制尺寸、颜色、材质等，实现个性化定制。购物车与结账系统：用户可以将喜欢的家具产品加入购物车，然后进行结账支付。购物车功能应方便用户随时查看已选商品，并支持多种支付方式。用户账户管理：用户可以注册账户，查看订单历史、编辑个人信息、管理收货地址等。个性化推荐功能可根据用户偏好推荐适合的家具产品。虚拟试验与体验：提供虚拟试验功能，让用户在网站上模拟家具摆放效果，体验不同家具风格的搭配效果。评论与评分系统：用户可以对购买的家具产品进行评价和打分，帮助其他用户做出购买决策。物流与配送：建立稳定的物流合作伙伴，确保家具产品安全、快速地送达客户手中。 实现方案： 网站开发与设计：寻找专业的网站开发团队，设计符合大气风格的网站界面，确保页面简洁清晰、导航顺畅。商品采购与库存管理：建立与家具供应商的合作关系，确保家具供应充足、质量过关，及时更新商品信息和库存。支付系统接入：整合安全可靠的支付系统，支持多种支付方式，保障用户支付信息的安全性。数据分析与市场推广：通过数据分析工具了解用户行为和购买偏好，制定精准的市场推广策略，提升网站流量和转化率。客户服务与售后支持：建立完善的客户服务体系，包括在线客服、售后服务保障等，保证用户满意度和忠诚度。法律合规：遵循相关法律法规，保护用户隐私和消费权益，确保网站运营合法合规。 通过以上详细分析和实现方案，一个大气的电商家具商城网站可以为消费者提供优质的家具购物体验，为家具行业带来更多销售机会，并提升用户对品牌的认知和忠诚度。
2、技术架构分析： 前端技术： 使用HTML、CSS、JavaScript等技术实现网页的展示和交互功能，确保用户友好的界面体验。
后端技术： 采用常见的后端开发语言和框架，如Java Spring、Python Django、Node.js等，处理业务逻辑和数据库交互。
数据库： 使用关系型数据库（如MySQL、PostgreSQL）或者NoSQL数据库（如MongoDB）存储用户信息、商品信息、订单信息等数据。
云计算服务： 借助云计算服务（如AWS、阿里云、腾讯云）搭建商城的服务器和存储资源，保证系统的稳定性和扩展性。
安全技术： 采用SSL加密技术保障用户数据传输的安全性，实施权限管理、防火墙等措施保护系统安全，同时，采用HTTPS协议传输数据，使用身份验证和授权机制保护系统安全。
数据分析： 利用数据分析工具对用户行为、销售数据等进行分析，优化商城的运营策略和用户体验。
API：前端与后端通过RESTful API进行数据交换和通信。
3、设计思路 用户友好性：界面简洁直观，易于操作，减少用户的学习成本。模块化设计：将系统功能模块化，每个模块负责一类功能，方便扩展和维护。权限控制：根据用户角色设定不同的权限，确保用户只能访问其权限范围内的功能。数据安全：对用户数据进行加密存储、访问控制等措施，保护用户隐私和系统安全。Responsiveness：后台管理系统应当是响应式设计，能够适配不同设备屏幕大小，包括电脑、平板和手机等。日志功能：记录关键操作日志，保留操作痕迹，便于审计和追踪问题。系统性能：考虑系统的性能优化，包括减少不必要的数据读写、合理利用缓存等，提高系统响应速度。 二、界面展示 1、系统首页
【广告栏】
2、家具导航栏
【家具推荐】
3、商品详情
【页面预览】 4、购物车
【页面栏】
6、商品博文
7、博文详情
三、资源获取 大气的电商家具商城网站HTML模板.zip资源-CSDN文库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004ca727560303cffe68ee2eaca2d6b6/" rel="bookmark">
			C&#43;&#43;常用算法的简单总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、遍历算法
for_each(iterator beg, iterator end, func) :遍历容器
transform(iterator beg1, iterator end1, iterator beg2, _func): func可以直接搬运数据，也可以数据加减乘除之后搬运
2、查找算法
find(iterator beg, iterator end, 需要查找的数据) 查找元素
查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()
find_if(iterator beg, iterator end, 查找条件&lt;谓词&gt;) 按条件查找元素
按值查找元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()
count(iterator beg, iterator end, 需要统计的数据) 统计元素个数
count_if(iterator beg, iterator end, 统计条件&lt;谓词&gt;) 按条件统计元素个数
adjacent_find(iterator beg, iterator end) 查找相邻重复元素
只能找到相邻且重复的元素，如果重复但是不相邻，那么就不会找到
binary_search(iterator beg, iterator end, 需要查找的数据) 二分查找法
查找指定元素，查到返回true，否则返回true，并且仅仅针对有序序列
3、排序算法
sort(iterator beg, iterator end, _Pred) 对容器内元素进行排序
random_shuffle(iterator beg, iterator end) 指定范围内的元素随机调整次序
merge(iterator beg1, iterator end1,iterator beg2, iterator end2, 放在新容器的什么位置&lt;v3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004ca727560303cffe68ee2eaca2d6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700cc42e9e23f927fab981ab8c165d87/" rel="bookmark">
			【python学习】python标准库之正则表达式库re的定义、功能和函数，以及正则表达式的元字符和含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 re 库是Python标准库的一部分，不需要额外安装。要使用 re 库，只需在代码中导入它
文章目录 引言一、re库的定义二、`re` 库中常用的功能和函数：2.1 搜索模式2.2 查找模式2.3 替换模式2.4 分割模式2.5 编译模式2.6 错误信息2.7 支持的模式2.8 匹配对象 三、正则表达式的定义四、正则表达式的元字符及其含义4.1 点号 `.`4.2 星号 `*`4.3 加号 `+`4.4 问号 `?`4.5 竖线 `|`4.6 括号 `()`4.7 反斜杠 `\`4.8 反斜杠后跟数字 `\n`4.9 美元符号 `$`4.10 井号 `#`4.11 双引号 `"`4.12 单引号 `'`4.13 花括号 `{n,m}`4.14 花括号 `{n,}`4.15 花括号 `{n}` 五、总结（思维导图） 一、re库的定义 re库 是一个内置的库，用于处理正则表达式（Regular Expression）
正则表达式是一种强大的文本处理工具，可以用于搜索、匹配、替换、分割字符串等操作
二、re 库中常用的功能和函数： 2.1 搜索模式 re.search(pattern, string, flags=0): 在字符串中搜索正则表达式的匹配re.match(pattern, string, flags=0): 在字符串的开始位置搜索正则表达式的匹配re.fullmatch(pattern, string, flags=0): 在字符串的整个长度上搜索正则表达式的匹配 2.2 查找模式 re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700cc42e9e23f927fab981ab8c165d87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33786d112717ff77c7c3b256e0da6956/" rel="bookmark">
			在html中使用vue.js的component
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于vue.js不依赖于dom元素，所以在body中引入就行，在head中引入会在渲染dom前加载，影响页面加载速度。
var vm = new Vue({ el: "#app", data: { price: "$10", }, }); 在vue实例中data可以是一个对象，也可以是一个函数，但是在组件中必须是一个函数。
var Counter = { template: `&lt;button @click="count++"&gt;当前点击了次&lt;/button&gt;`, }; 组件是一个对象而不是一个vue实例
完整代码:
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;HTML + CSS&lt;/title&gt; &lt;link rel="stylesheet" href="styles.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;Pitle label="价目表"&gt;&lt;/Pitle&gt; {{price}} &lt;Counter /&gt; &lt;/div&gt; &lt;script src="./vue.min.js"&gt;&lt;/script&gt; &lt;script&gt; var Counter = { data() { return { count: 0, }; }, template: `&lt;button @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33786d112717ff77c7c3b256e0da6956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf23c05e78079fa1843cbd3a63f2a9e/" rel="bookmark">
			【数据结构C&#43;&#43;之看懂就这一篇】图（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📚博客主页：Zhui_Yi_
🔍：上期回顾：图【中】
❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️
🎇追当今朝天骄，忆顾往昔豪杰。
文章目录 前言一、最小生成树引入以及复习广度优先生成树和深度优先生成树求最小生成树如何求最小生成树 Prim算法kruscal算法 二、最短路径Dijkstra算法存储结构（顶点个数为n）算法思想 三、拓扑排序引入AOV网AOE网AOV网示例 算法思想（重复选择没有直接前驱的顶点） 总结 前言 本期我将带来图的应用，包括最小生成树、最短路径、拓扑排序、关键路径。
一、最小生成树 引入以及复习 在理解最小生成树的时候，我们先了解一下生成树。
生成树：包含图G所有顶点的极小连通子图（n-1条边）。
那么什么是极小连通子图呢？
极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。
广度优先生成树和深度优先生成树 那么我们上篇文章提到了广度优先遍历和深度优先遍历：
在广度优先遍历和深度优先遍历过程中，可以得到一颗遍历树，我们称之为广度优先生成树和深度优先生成树。
那么我们根据这个图，以v0作为起点，画出生成树。
我们先把邻接表给画出来：
那么画出来深度优先生成树如下：
广度优先生成树如下：
求最小生成树 我们首先明确一下：
使用不同的遍历图的方法，可以得到不同的生成树
从不同的顶点出发，也可能得到不同的生成树。
按照生成树的定义，n 个顶点的连通网络的生成树有n 个顶点、n-1 条边。
那么我们该如何求最小生成树？
在网的多个生成树中，寻找一个各边权值之和最小的生成树
构造最小生成树的准则：
必须只使用该网中的边来构造最小生成树；
必须使用且仅使用n-1条边来联结网络中的n个顶点
不能使用产生回路的边
那么最小生成树有什么用途呢？
欲在n个城市间建立通信网，则n个城市应铺n-1条线路；但因为每条线路都会有对应的经济成本，而n个城市可能有n(n-1)/2 条线路，那么，如何选择n–1条线路，使总费用最少？
如何求最小生成树 在这里有两种求法：
Prim（普里姆）算法
Kruskal（克鲁斯卡尔）算法
他们的特点是：
Prim算法: 归并顶点，与边数无关，适于稠密网
Kruskal算法：归并边，适于稀疏网
Prim算法 基本思想：归并顶点
设连通网络 N = { V, E }中找最小生成树T={V，TE}
从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中直到所有顶点都加入到生成树顶点集合U中为止 应用构造最小生成树的过程
我们先把A结点放在U里面，再把其他节点放在V-U里面
然后再找与A相连权值最小的，AB,AC,AD,AE，谁权值最小？AB，再把B放在U里面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdf23c05e78079fa1843cbd3a63f2a9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0516d5a690056b6a5e4998686fe404/" rel="bookmark">
			连锁直营店小程序赋能多店如何管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如商超便利店卖货线下场景，也有不少品牌以同城多店和多地开店经营为主，获取店铺周围客户和散流，如今线上重要性凸显，品牌电商发展是经营的重要方式之一，也是完善同城和外地客户随时便捷消费的方式之一。
多个门店管理商品销售和提高客户消费满意度，运用雨科平台搭建连锁多店商城小程序，开启使用连锁直营模式进行总部统一管理，分店管理商品承接订单运营、营销分销商户拉新促活、业绩增长。
如综合电商、生鲜蔬果、美妆护肤、鞋帽箱包等行业多店卖货管理都非常适合。
当开通商城-直营商户版本后（新号有几天的试用时间），在后台创建所有的商户并完善信息，如商户名称、图片、联系电话、地址、营业状态等，设置完成进行保存。
到【配送】栏里设置到店自提和同城配送，可单独设置相应的分店提供服务及作为自提点。后台添加员工并设置每个分店员工的权限（产品、订单、工具、商户管理/数据权限）。
销售的商品可以与商户关联，在发布产品时，可直接设置同步商户。设置后对应商户默认上架产品并开始销售。如果需要不同商户买不同的商品，则可以单独设置。当客户消费提交订单后，商家可在后台订单里查看，并根据商户筛选订单及批量修改订单状态等。
设置完成保存，当客户进入小程序，LBS就近推荐门店，客户购物选择到店自提或配送到家方式，就近商户（客户也可自选）开始相应接单服务。
上门自提：可根据买家地理位置推荐附近自营商户，买家也可修改所在位置，重新匹配附近自营商户，快速引导下单成交，精准承接周边流量，服务更高效。
配送到家：系统可根据买家定位匹配配送范围内最近的商户，实现智能派单，同时，买家可切换其他收货地址。
注意：商家直营模式中的其他商户在商城里并没有商户详情页，此模式只是为了让所有商户都获得曝光和线上生意、服务好客户。商户管理员可在商城后台查看管理自己门店的订单。
营销是由总部设置并同步所有商户参与。统一商品/库存/营销/数据，多店连锁卖货总部轻松管理运营。
现在就到雨科后台搭建小程序管理连锁门店吧。
↓↓↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4917127012dd484733b4f3663ed151ac/" rel="bookmark">
			【超音速 专利 CN117576413A】基于全连接网络分类模型的AI涂布抓边处理方法及系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		申请号CN202311568976.4公开号（公开）CN117576413A申请日2023.11.22申请人（公开）超音速人工智能科技股份有限公司发明人（公开）张俊峰（总）; 杨培文（总）; 沈俊羽; 张小村 我的理解 步骤一：获取涂布边缘图像并提取对应的关键点特征；
步骤二：采用卷积以及全连接操作对所述关键点特征进行分析，通过分类头确定关键点的纵坐标、横坐标以及可见性；
步骤三：构建全连接网络分类模型并训练至损失函数收敛，将所述关键点的纵坐标、横坐标以及可见性输入到所述全连接网络分类模型，提取出虚边、融合边和实边在涂布边缘图像边缘处的关键点坐标；
步骤四：将涂布边缘图像的关键点的纵坐标、横坐标以及可见性并输入到完成训练的全连接网络分类模型进行检测并获取虚边、融合边和实边在涂布边缘图像边缘处的关键点坐标，根据关键点坐标确定虚边、融合边和实边的位置。
2.根据权利要求1所述的基于全连接网络分类模型的AI涂布抓边处理方法，其特征在于，所述获取涂布边缘图像并提取对应的关键点特征，包含以下步骤：
获取涂布原始图像并进行预处理将图片转换为统一的格式，所述预处理包括以下一种或多种方式：缩放、裁剪、灰度增强、对比度增强；
通过边缘提取算法确定预处理后的涂布原始图像的第一边缘位置，以第一边缘位置为中心对涂布原始图像进行裁剪，生成涂布边缘图像；
对所述涂布边缘图像进行数据标注，使用带有预训练模型的特征提取网络提取所述涂布边缘图像的关键点特征。
步骤四.根据权利要求1所述的基于全连接网络分类模型的AI涂布抓边处理方法，其特征在于，所述采用卷积以及全连接操作对所述关键点特征进行分析，通过分类头确定关键点的纵坐标、横坐标以及可见性，包括：
所述分类头包含纵坐标分类头、横坐标分类头以及可见性分类头；
通过纵坐标分类头确定关键点的纵坐标，通过横坐标分类头确定关键点的横坐标，通过可见性分类头确定关键点的可见性。
步骤五.根据权利要求3所述的基于全连接网络分类模型的AI涂布抓边处理方法，其特征在于，所述采用卷积以及全连接操作对所述关键点特征进行分析，通过分类头确定关键点的纵坐标、横坐标以及可见性，还包含：
纵坐标分类头通过一维卷积以及全连接操作将图像特征变换成N个一维向量，表示关键点的纵坐标；
横坐标分类头通过一维卷积以及全连接操作将图像特征变换成N个一维向量，表示关键点的横坐标；
可见性分类头通过二维卷积以及全连接操作将图像特征变换成一个长度为N的一维向量，表示关键点的可见性。
步骤六.根据权利要求4所述的基于全连接网络分类模型的AI涂布抓边处理方法，其特征在于，所述通过纵坐标分类头确定关键点的纵坐标，通过横坐标分类头确定关键点的横坐标，通过可见性分类头确定关键点的可见性，还包含：
纵坐标分类头首先对提取的关键点特征通过二维卷积和ReLU激活函数压缩特征；将压缩特征的横坐标方向特征进行展平，进行全连接操作及ReLU激活函数，将其特征维度转变为涂布边缘图像高度的ɑ倍；进行尺度不变的横坐标方向一维卷积操作，得到关键点的纵坐标分类头输出结果；
横坐标分类头首先对提取的关键点特征通过二维卷积和ReLU激活函数压缩特征；接下来将压缩特征的纵坐标方向特征进行展平，进行全连接操作及ReLU激活函数，将其特征维度转变为原图像宽度的ɑ倍；最后，进行尺度不变的纵坐标方向一维卷积操作，得到关键点的横坐标分类头输出结果；
可见性分类头首先对提取的关键点特征经过两次二维卷积将特征长宽进行压缩，再将其进行全局池化、展平、以及全连接操作后得到关键点的可见性分类头输出结果。
步骤七.根据权利要求1所述的基于全连接网络分类模型的AI涂布抓边处理方法，其特征在于，所述获取涂布边缘图像并提取对应的关键点特征，包含：
获取涂布边缘图像，在图像边缘逐渐向外填充特定颜色的像素，每一圈像素的颜色均相同，并保持相邻圈层之间的色度差和饱和度差设定在特定范围内；
将图像标注数据中位于图像边缘的关键点标签移至填充的像素区域最外圈。
步骤八.根据权利要求6所述的基于全连接网络分类模型的AI涂布抓边处理方法，其特征在于，包含：
所述全连接网络分类模型进行推理时需要根据不同关键点类型将预测的关键点移至图像边缘处；
所述全连接网络分类模型提取的关键点包括虚边、实边、融合边在图像边缘位置的两个关键点坐标，根据两点确定一条直线的原理确定虚边、融合边和实边的位置。
步骤九.一种基于全连接网络分类模型的AI涂布抓边处理系统，包括：
处理模块，用于获取涂布边缘图像并提取对应的关键点特征；
分析模块，采用卷积以及全连接操作对所述关键点特征进行分析，通过分类头确定关键点的纵坐标、横坐标以及可见性；
训练模块，构建全连接网络分类模型并训练至损失函数收敛，将所述关键点的纵坐标、横坐标以及可见性输入到所述全连接网络分类模型，提取出虚边、融合边和实边在涂布边缘图像边缘处的关键点坐标；
检测模块，将涂布边缘图像的关键点的纵坐标、横坐标以及可见性并输入到完成训练的全连接网络分类模型进行检测并获取虚边、融合边和实边在涂布边缘图像边缘处的关键点坐标，根据关键点坐标确定虚边、融合边和实边的位置。
步骤十.一种计算机设备，其特征在于，包括处理器和存储器，所述存储器用于存储可执行的指令，所述指令用于控制所述处理器执行根据权利要求1至7中任一项所述的方法。
步骤十二.一种计算机可读存储介质，其特征在于，其上存储有计算机程序，所述计算机程序在被处理器执行时实现如权利要求1至7中任一项所述的方法。
如果有不明白的，请加文末QQ群。
扩展阅读 视频课程 先学简单的课程，请移步CSDN学院，听白银讲师（也就是鄙人）的讲解。
https://edu.csdn.net/course/detail/38771
如何你想快速形成战斗了，为老板分忧，请学习C#入职培训、C++入职培训等课程
https://edu.csdn.net/lecturer/6176
相关推荐 我想对大家说的话《喜缺全书算法册》以原理、正确性证明、总结为主。按类别查阅鄙人的算法文章，请点击《算法与数据汇总》。有效学习：明确的目标 及时的反馈 拉伸区（难度合适） 专注闻缺陷则喜(喜缺)是一个美好的愿望，早发现问题，早修改问题，给老板节约钱。子墨子言之：事无终始，无务多业。也就是我们常说的专业的人做专业的事。如果程序是一条龙，那算法就是他的是睛 测试环境 操作系统：win7 开发环境： VS2019 C++17
或者 操作系统：win10 开发环境： VS2022 C++17
如无特殊说明，本算法用**C++**实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b333e76ef4ade1a65d15c6ee29e7bef9/" rel="bookmark">
			运维的操作红线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 无工单、邮件的任何操作，严禁执行。
2. 工单标题和内容不一致或工单内容超出现场范围禁止操作。
3. 操作前必须确定资产信息：机柜号、U位、资产号、sn 号、ip。
4. 机柜后门操作设备，必须多次执行第 3 条红线。
5. 严禁操作、触碰工单指定设备或关联设备外的其他设备。
6. 设备维修，必须仔细核实新配件的参数，不一致禁止更换。
7. 停机维修，必须下架到指定区域，使用墙电调测。
8. 网络设备插拔光纤、网线、模块、板卡，端口不灭，严禁操作。
9. 线缆（包括但不限于网络、电源线、光纤等）应该按照网易要求进行绑扎、固定、摆
放，
10. 禁止出现飞线（线缆跨设备下垂交叉等）等情况出现；
11. 操作结束（包括未完成等待后续操作）后应该将设备复原，包括但不限于盲板、设备
复位、摆放整齐、线缆归位、盘扣及刀片扳手复位等内容；
12. 操作完成或者等待后续操作需要离开机房现场时应该将杂物（例如内存假体、CPU
假体、硬盘假体、扎带等）带离机房，保持机房整洁；
13. 如机柜有机柜门未操作时应该保持常闭，如核心机柜有条件应该上锁；
14. 禁止为便捷操作跨排或者多机柜拉线、搭建环境等；
15. 机房内非机架区域尽量不要摆放设备，禁止摆放备配件，特殊情况应提前审批说明；
16. 其他操作要求请按照机房组组最新流程进行操作，如有不确定问题应该第一时间与主
管或者经理沟通，确认后才可进行操作1. 无工单、邮件的任何操作，严禁执行。
2. 工单标题和内容不一致或工单内容超出现场范围禁止操作。
3. 操作前必须确定资产信息：机柜号、U位、资产号、sn 号、ip。
4. 机柜后门操作设备，必须多次执行第 3 条红线。
5. 严禁操作、触碰工单指定设备或关联设备外的其他设备。
6. 设备维修，必须仔细核实新配件的参数，不一致禁止更换。
7. 停机维修，必须下架到指定区域，使用墙电调测。
8. 网络设备插拔光纤、网线、模块、板卡，端口不灭，严禁操作。
9. 线缆（包括但不限于网络、电源线、光纤等）应该按照网易要求进行绑扎、固定、摆
放，
10. 禁止出现飞线（线缆跨设备下垂交叉等）等情况出现；
11. 操作结束（包括未完成等待后续操作）后应该将设备复原，包括但不限于盲板、设备
复位、摆放整齐、线缆归位、盘扣及刀片扳手复位等内容；
12. 操作完成或者等待后续操作需要离开机房现场时应该将杂物（例如内存假体、CPU
假体、硬盘假体、扎带等）带离机房，保持机房整洁；
13. 如机柜有机柜门未操作时应该保持常闭，如核心机柜有条件应该上锁；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b333e76ef4ade1a65d15c6ee29e7bef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74b669fd1fe0d8b82131e4bbc167b6eb/" rel="bookmark">
			AI Agent调研--7种Agent框架对比！盘点国内一站式Agent搭建平台，一文说清差别！大家都在用Agent做什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理（Agent）乃一种智能实体，具备自主环境感知与决策行动能力，旨在达成既定目标。作为个人或组织之数字化替身，AI代理执行特定任务与交易，其核心价值在于简化工作流程，削减繁复性，并有效降低人力投入与沟通障碍，促进效率与协作的双重提升。简而言之，代理技术让AI成为高效助手，助力个人与组织在复杂多变的环境中更加游刃有余。
01.Agent基础 Agent的核心决策机制围绕着动态适应与持续优化展开。它使LLM（大型语言模型）能够依据实时变动的环境信息，灵活选择并执行恰当的行动策略，或对行动结果进行精准评估与判断。这一过程通过多轮迭代不断重复，每一次迭代都基于对环境的深入理解与上一次执行效果的反馈，旨在逐步逼近并最终达成既定目标。Agent的此种运作模式，确保了其在复杂多变的环境中能够保持高效、灵活与适应性，持续推动任务向成功迈进。
精简的决策流程：P（感知）→ P（规划）→ A（行动）
感知（Perception）是指Agent从环境中收集信息并从中提取相关知识的能力。
规划（Planning）是指Agent为了某一目标而作出的决策过程。
行动（Action）是指基于环境和规划做出的动作。
工程实现上可以拆分出四大块核心模块：推理、记忆、工具、行动
02.各平台功能总结与比较 官方GPTs商店：各大平台均设有官方GPTs应用商店，汇聚了琳琅满目的插件与模型，满足多元化需求。
知识库：在知识库构建上，各平台展现独特风采，内容既广泛又深入，助力用户轻松获取所需信息。
流程图编排： 流程图编排功能作为标配，让无编程基础的用户也能通过直观拖拽，迅速构建高效工作流，实现流程自动化。
**多模型支持：**对于模型支持，部分平台展现开放姿态，兼容多模型选择；而有的则专注于自家大模型深度优化，但无论哪种，均能有效支撑日常工作的顺利进行。
**插件调用：**插件调用机制的引入，极大增强了平台的灵活性与扩展性，用户可根据实际需求灵活调用各类插件，提升工作效率。
**Prompt配置：**至于Prompt配置，各平台均展现出创新精神，提供个性化、精细化的配置选项，确保用户能够精确控制模型行为，满足特定场景下的需求。
03.国内主流一站式Agent平台深度测评 1.Betteryeah
网址：https://www.betteryeah.com/agentstore
斑头雁智能科技，其核心团队源自阿里巴巴钉钉的初创精英，专注于打造零门槛Agent构建平台，旨在迅速激活并释放大模型的强大潜力。该平台内置了包括ChatGLM、阿里通义千问、百度千帆在内的国内外顶尖AI模型，为用户提供了丰富的选择。
**产品形态：**在产品形态上，斑头雁智能科技与Coze等前沿平台并驾齐驱，均属于高度集成的平台型产品，为用户提供了一站式解决方案。
**开发模式：**其开发模式灵活多变，既支持单一Agent的精细化打造，也适应于Multi-Agent系统的复杂部署，满足不同业务场景下的多样化需求。
**应用场景：**面向企业级市场，斑头雁智能科技聚焦AI客服、营销、销售等多个关键领域，提供智能化升级的全面解决方案。
其官方智能体中心更是汇聚了全类别的智能应用，从全面的智能客服系统，到针对电商、销售、营销、HR等多个垂直行业的定制化方案，再到快速上手的学习资源，一应俱全，助力企业轻松实现数字化转型与智能化升级。
2.Coze
网址：https://www.coze.cn
Coze，作为字节精心打造的AI Bot开发旗舰平台，致力于赋能开发者，以强大而简洁的界面，加速智能聊天机器人的设计与部署流程。在中文大模型智能体生态中，Coze以其先驱地位傲视群雄，无论是率先布局的市场先机，还是其在智能体编排工具的成熟度、插件的广泛性、兼容大模型种类的多样性，乃至发布渠道的全面覆盖，均展现出非凡实力。
Coze平台慷慨开放，无论是其自研的云雀大模型，还是外部知名的moonshot等尖端技术，均对开发者免费开放，极大地降低了创新门槛。其卓越的用户体验与庞大的日活用户数，共同构筑了行业内的领先地位，无论是从生态构建、用户体验，还是底层技术支撑来看，Coze无疑是众多智能体平台中的佼佼者。
不得不提的是字节的另一款AI智能对话助手——豆包。豆包以其独特的prompt驱动方式，让用户能够轻松定制专属智能体，其亮点在于无缝集成了先进的TTS（文本到语音）技术，让自定义的智能体能够直接与用户进行语音交互，体验更加自然流畅。相较于Coze的全方位智能体构建方案，豆包更像是一款功能精炼、操作快捷的便携式Coze版本，尤其适合在移动端快速高效地应用。以下是豆包智能体中心的精彩展示，进一步诠释了其便捷与高效。
3.百度千帆AgentBuilder
网址：https://agents.baidu.com/
百度AgentBuilder是一款智能体开发工具，旨在降低智能体开发门槛，让每个人、每个组织都能够成为智能体的开发者。AgentBuilder是百度推出的三大AI开发工具之一，另外两个工具分别是AppBuilder和ModelBuilder(小纸条之前的文章给大家介绍过各家产品们的区别)。
产品形态：基于文心大模型的智能体平台，也是平台型。
开发方式：支持开发者根据自身行业领域和应用场景选择不同类型的开发方式，提供低成本的prompt编排方式。
功能特点：提供零代码和低代码两种开发模式，适合不同技术背景的开发者
来看下智能体中心大家都在用什么，热门的主要也还是聚焦提效、娱乐、生活、以及实时热点的高考。
4.SkyAgents(昆仑万维)
昆仑万维公司隆重推出天工SkyAgents，这是一款引领未来的AI Agents构建平台，旨在重塑智能应用的创造边界。
产品形态创新：天工SkyAgents以其先进的技术架构，打造了一个高效、灵活的AI Agents构建生态系统。该平台不仅集成了前沿的人工智能技术，还通过模块化设计，让AI Agent的创建与部署变得前所未有的简单快捷。
开发体验革新：区别于传统繁琐的开发流程，天工SkyAgents引入了革命性的开发方式。用户仅需通过自然语言输入，即可轻松描述AI Agent的功能与行为；同时，可视化拖拽界面更是将复杂的技术操作简化为直观的图形操作，深度集成Skywork大语言模型，让AI Agent的智能化水平跃升至新高度。
应用场景广泛：天工SkyAgents的智能体，凭借其强大的感知与决策能力，能够精准适配各类具体业务场景。无论是电商平台的个性化推荐、客服系统的智能应答，还是金融领域的风险评估、智能制造的自动化控制，天工SkyAgents都能以用户需求为核心，提供定制化的智能解决方案，助力企业实现数字化转型与升级。
社区生态活跃：在天工SkyAgents的智能体中心，一个充满活力的社区生态正在形成。这里不仅有官方精心打造的示例Agents，展示着AI Agent的无限可能与最佳实践；更有来自全球的个人开发者，他们通过天工平台贡献自己的智慧与创意，构建了一个丰富多彩、不断更新的Agent市场。这个市场不仅为开发者提供了展示自我的舞台，更为用户提供了更多元化、更个性化的AI服务选择。
综上所述，天工SkyAgents以其独特的产品形态、革新的开发方式、广泛的应用场景以及活跃的社区生态，正逐步成为AI Agent构建领域的佼佼者。未来，随着技术的不断进步与应用的持续深化，天工SkyAgents有望引领智能体技术迈向新的高度，为人类社会创造更加美好的智能生活。
5.阿里云魔搭社区
网址：https://modelscope.cn/studios/agent
产品形态革新：我们自豪地推出这款专为开源大语言模型（LLM）量身定制的AI Agent开发框架。它不仅完美兼容并优化各类主流LLM，还提供了一个高度灵活与可扩展的平台，让AI Agent的开发与部署更加便捷高效。
开发方式多元化：该框架支持创建多样化的多模态AI Agent，涵盖客户服务、个人助理等多个领域，满足不同场景下的智能化需求。用户可以根据具体业务场景，轻松构建出既能处理文本对话，又能理解图像、语音等多类型信息的智能体，实现全方位的用户交互体验。
一键协作，简化流程：我们深知在AI项目开发中，模型间的协作至关重要。因此，该框架创新性地引入了一键发送指令调用其他AI模型的功能，大幅简化了模型集成与协作的流程。用户无需深入技术细节，即可轻松实现多模型间的无缝对接，提升整体项目的智能化水平和响应速度。
低/零代码平台，降低门槛：为了进一步降低AI Agent的开发门槛，我们结合了低/零代码平台的设计理念，让非技术背景的用户也能参与到AI应用的开发中来。通过直观的图形化界面和丰富的预设模板，用户可以快速上手，实现个性化定制的智能体，无需编写复杂的代码。
广泛适用，未来可期：该框架设计之初就充分考虑了未来技术的发展趋势，因此它不仅适用于当前多种业务场景，还具备高度的可扩展性和兼容性。随着开源大模型的不断涌现与更新，我们将持续优化该框架，确保它能够快速适配更多新增的开源大模型，为用户提供更加丰富和强大的AI解决方案。
创建智能体新体验：在开源社区中，该产品的智能体创建过程同样令人印象深刻。用户可以通过对话配置和参数配置两种方式，灵活定义智能体的行为逻辑和外观样式。虽然当前版本暂未直接展示workflow流程设计界面，但凭借其强大的功能集成和易用性设计，我们相信未来版本中将会引入更多高级功能，包括workflow流程编辑器等，以进一步提升用户的开发体验和智能体的智能化水平。
6.讯飞的星火友伴
网址：https://xinghuo.xfyun.cn/botcenter/createbot
讯飞科技，以其深厚的AI技术底蕴，携手星火V3.0这一强大引擎，精心打造了一个专注于虚拟人格GPTs应用的创新平台。该平台不仅代表了讯飞在人工智能领域的又一里程碑式成果，更是为探索个性化智能交互体验开辟了全新的道路。
智能体中心，是由讯飞官方精心设计的虚拟人格模板。这些模板各具特色，涵盖了从亲切友善的客服助手到风趣幽默的聊天伙伴，再到专业严谨的顾问导师等多种角色设定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74b669fd1fe0d8b82131e4bbc167b6eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256afd1e956c3506f9870d8a3db7ba28/" rel="bookmark">
			Java 中的正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转义字符由反斜杠\x组成，用于实现特殊功能当想取消这些特殊功能时可以在前面加上反斜杠\ 例如在Java中当\出现时是转义字符的一部分，具有特殊意义，前面加一个反斜可以取消其特殊意义，表示1个普通的反斜杠\，\\\\表示2个普通的反斜杠\\。其实就是要求Java中的字符串输出结果是正确的正则表达式。
1. 概念 正则表达式其实就是规则。
2. 字符类 单字符匹配规则，语法示例： [abc]：a 或者 b，或者 c 字符中的一个；[^abc]：除 a,b,c 以外的任何字符中的一个；[a-z]：a-z 小写字母中的一个；[A-Z]：A-Z 大写字母中的一个；[0-9]：0-9 数字中的一个；[a-zA-Z0-9]：a-z 或者 A-Z 或者 0-9 中的一个；[a-dm-p]：a 到 d 或 m 到 p 中的一个。 3. 逻辑运算符 语法示例： &amp;&amp;：并且| ：或者 4. 预定义字符 语法示例： “.” ： 匹配任何字符；“\d”：任何数字 [0-9] 的简写；“\D”：任何非数字 [^0-9] 的简写；“\s”： 空白字符 [ \t\n\x0B\f\r] 的简写；“\S”： 非空白字符 [^\s] 的简写；“\w”：大小字母或数字或下划线或汉字；“\W”：非单词字符 [^\w] ；“\t”：一个 Tab 的间隔。 5. 数量词 语法示例： X? : 0 次或 1 次；X* : 0 次或者多次；X+ : 1 次或者多次；X{n} : 正好好 n 次；X{n,} : 至少 n 次；X{n,m}: n 到 m 次（n 和 m 都是包含的） 正则表达式的作用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/256afd1e956c3506f9870d8a3db7ba28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc9588235df5f774931324edc845511/" rel="bookmark">
			【算法】单调队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是单调队列 单调队列是一种数据结构，其特点是队列中的元素始终保持单调递增或递减，主要用于维护队列中的最小值或最大值。
不同于普通队列只能从队头出队、队尾入队，单调队列为了维护其特征，还允许从队尾出队
不管怎么向单调队列中添加元素或删除元素，其单调性始终不变。这是如何做到的呢？我们用一道例题来说明
二、如何使用单调队列 2.1 滑动窗口问题 滑动窗口问题是单调队列的典型应用场景
简单来说，一个长度固定的窗口从序列开始一步步移动到结尾，我们要得到这个窗口每一步移动中其内部的最大值和最小值。
这个问题很简单，如果我们使用一个单调队列，窗口每次移动就将新元素入队，让其内部的元素保持单调递增，那么队头元素就是窗口的最小值，求最大值则保持单调递减即可
那我们该如何维护一个单调队列呢？首先来讲讲单调队列的思想
2.2 单调队列的思想 我们以上面例题中给出的序列 {1,3,-1,-3,5,3,6,7} 为例，窗口大小为3，单调队列大小和窗口一致
窗口从头开始向后移动，首先是1入队，然后是3入队，到这里单调队列内部都保持单调递增，于是我们不作处理
窗口继续向后移动，接下来是-1入队。但是-1入队后就打破了单调队列的单调性了，所以我们需要进行一些操作维护其单调性
因为我们选择保持队列单调递减，所以当有更小的元素要从队尾入队时，我们要把它前面所有比它更大的元素全都先从队尾出队。
也就是说，当准备入队的元素更优时，我们需要先将前面造成干扰的元素出队，再将新元素入队。
此时，窗口已经完整的进入序列中了，可以开始拿到最值，此时单调队列的队头元素就是窗口中的最小值
窗口滑动，接下来-3准备入队。和前面的步骤一样，先将-1从队尾出队，然后-3入队
得到此时窗口最小值-3 窗口滑动，接下来5正常入队
得到此时窗口最小值-3
窗口滑动，接下来3准备入队，和前面的步骤一样，先将5从队尾出队，然后3入队
得到此时窗口最小值-3
窗口滑动，接下来6正常入队
但是！此时单调队列中的-3已经滑出窗口范围了，需要出队
得到此时窗口最小值3
窗口滑动，接下来7正常入队
得到此时窗口最小值3
这就是单调队列完整的思想，如果要求窗口每个时刻的最大值，则将单调队列保持单调递减即可
关于单调队列还有一个很残酷的比喻：后入队的比先入队的年轻，如果后入队的既年轻又比先入队的更强，那先入队的就可以滚蛋了。就算先入队的更强，到了一定年龄之后也得滚蛋。
2.3 实际解题过程 明白了单调队列的思想后，我们还需要学会如何在实际解题时使用它
在上面的例题中，我们可以用一个数组来模拟单调队列，用两个下标 h 和 t 来维护队头和队尾
另外一个数组存储目标序列，len 表示窗口长度，i 表示窗口的右侧，则 i - len + 1就是窗口的左侧。通过i++就可以实现窗口滑动的效果
我们在单调队列中存储元素在原序列中的下标，这样做是为了便于判断一个元素仍在单调队列中但已经滑出窗口的情况（如果该元素的下标小于窗口左侧则说明已经滑出窗口，则出队）
用下标维护队列头尾的目的：采用伪删除法，将 t-- 就能达到队尾出队的效果，h++就能达到队头出队的效果
大概思路都讲完了，这里直接放出例题的代码
#include &lt;iostream&gt; using namespace std; const int N = 1000010; int n, k; int a[N]; int q[N]; void winmin() //求窗口最小值 { int h = 1, t = 0; //h是队头，t是队尾，队列初始为空 for(int i = 1;i &lt;= n;i++) //i为窗口右端，i递增则窗口不断滑动 { while(h &lt;= t &amp;&amp; a[q[t]] &gt;= a[i]) //队列不为空且队尾元素比新元素大，出队 t--; q[++t] = i; //存储下标方便判断队头出队 if(q[h] &lt; i - k + 1) h++; //队头存储的下标小于窗口左侧，队头元素滑出窗口 if(i &gt;= k) cout &lt;&lt; a[q[h]] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc9588235df5f774931324edc845511/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/156/">«</a>
	<span class="pagination__item pagination__item--current">157/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/158/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>