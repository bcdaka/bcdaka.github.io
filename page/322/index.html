<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f9c5fa3f7f851cb7029ab5fef626e1/" rel="bookmark">
			MES系统的功能、架构及应用价值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MES系统生产过程控制的主要方面涵盖了生产计划与控制、生产调度与排程、数据采集与监控、质量控制与管理、物料管理与控制以及设备管理与维护等多个方面。这些功能共同构成了MES系统的核心价值，帮助企业实现生产过程的数字化、智能化和精细化管理。
一、工厂使用MES系统的应用价值主要体现在以下几个方面：
1. 提高生产效率和产品质量：
在传统的生产管理模式下，工厂往往难以实时掌握生产线的运行状态和产品质量情况，导致生产效率低下、产品质量不稳定等问题。而MES系统通过实时收集、监测和分析生产线上的数据，帮助管理者及时发现生产过程中的问题、瓶颈和风险，从而及时采取措施进行调整和优化。这不仅减少了生产线停机和报废产品的质量问题，还提高了生产效率和产品质量，为工厂的稳定运营和可持续发展提供了有力保障。
2. 优化资源投入：
其次，MES系统能够帮助工厂优化资源投入，实现资源的合理配置和高效利用。在传统的生产管理模式下，工厂往往难以准确掌握各种资源的消耗情况和使用效率，导致资源的浪费和亏损。而MES系统通过智能算法进行生产计划的优化和协调，根据生产车间的实际情况来进行各种资源的投入和使用。这样不仅能够减少资源的浪费和亏损，提高资源利用效率，还能够帮助工厂管理者更好地掌握资金的使用情况，为工厂的财务管理和成本控制提供有力支持。
3. 加强数据取证能力：
此外，MES系统还具有强大的数据取证能力，为工厂提供数据支持和决策依据。在生产过程中，各种异常情况难以避免，如设备故障、产品质量问题等。而MES系统能够对这些异常情况进行记录和保存，提供详细的数据记录和分析。这帮助工厂管理者进行状况分析和问题的排查，提高了对异常情况的把控和处置能力。同时，MES系统还能够为工厂提供数据支持和决策依据，帮助管理者制定更加科学合理的生产计划和经营策略。
4. 实现生产数字化转型：
最后，MES系统是实现工厂生产数字化转型的关键。随着科技的不断发展，数字化转型已经成为工厂发展的必然趋势。而MES系统作为数字化转型的核心工具之一，能够帮助工厂实现生产线的数字化转型，提高生产线的自动化和智能化水平。通过MES系统的应用，工厂可以更好地适应市场的变化和生产的需求，实现更高效、智能、便捷、自动化的生产。
二、万界星空科技MES系统的主要功能：
1、全面集成
承上启下，完成工厂所有与MES系统链接的信息化系统 （如ERP、PLM等）、自动化控制系统（如PLC、DCS、SCADA等）和设备（如数控机床、质检设备、加工设备等）的无缝集成，通过MES系统整合上下游信息流，建立一个业务统一、流程顺畅、数据规范的生产信息管理平台。
2、车间排程
结合ERP系统或配合计划部门建立先进的计划体系，制定在产能和物资等资源约束条件下的详细排程计划，统一指挥控制物料、人员、流程指令和设备等工厂生产资源。
3、自动化物流和物料管理
MES系统应覆盖部分WMS功能，并实现与自动化物流系统（如自动化立库、AGV小车等）一起完成生产物流管理，在数字化工厂内实现无人化自动物料流转，MES系统指挥和跟踪物料流动、管理物料消耗、编制物料投料计划等，同时采用工单、批次管理，实现对物料的跟踪和反馈。
4、质量管理
质量管理以生产过程质量信息汇总和控制为核心，建立快速、高效全过程的质量反馈、质量处理、质量跟踪控制，同时建立完善的质量追溯体系，MES系统还可以自动生成各类质量报告和出厂试验报告等资料。
5、生产过程管理
以全厂数据采集系统为基础，建立起综合控制系统，包括电子看板、SCADA系统集成、监控中心和Andon系统等，实时显示整个生产过程的各种现场数据，并按照预先设定的条件，出现异常情况应及时报警提醒，并采取相应的调度措施。
6、设备管理
对生产车间主要生产设备的台账、使用频率、运行状况、工时、定额、能耗、产能等有关信息进行采集和分析，对设备进行全面管理，以达到保持设备完好率、充分发挥其效能的目的。
7、统计分析
对实时数据进行统计分析 ，通过对大量数据的综合分析，可以对生产运行情况进行有效评价，为优化组织、提高产量质量、提高设备保障能力、降低生产成本提供准确的数据支撑，如员工绩效管理、核算计件工资、设备效率分等。
8、移动端应用
支持手机、pad等移动终端，实现移动端的派工报工、接料发料、数据录入、生产进度跟踪、实时统计分析展示等。
万界星空科技专注于制造业生产管理MES平台的研发和实施.如果你的企业也有生产管理上面的问题，可以私信或者联系我们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de743c9329b25414a8285335d6be6d0/" rel="bookmark">
			企业级网络安全问题及其解决手段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着企业信息化程度的不断提高，网络安全问题已成为企业面临的重大挑战。本文将探讨企业级网络安全问题的现状、原因以及相应的解决手段。
一、企业级网络安全问题的现状
近年来，企业级网络安全事件频发，给企业带来了巨大的经济损失和声誉损害。黑客攻击、数据泄露、恶意软件等安全威胁不断涌现，使得企业的网络安全形势日益严峻。这些安全问题不仅威胁到企业的正常运营，还可能对国家安全和社会稳定造成严重影响。
二、企业级网络安全问题的原因
外部攻击：黑客利用各种手段对企业网络进行攻击，窃取敏感数据或破坏网络系统。
内部威胁：企业内部员工可能因疏忽或恶意行为导致网络安全问题，如密码泄露、权限滥用等。
技术漏洞：企业网络设备和应用系统存在的安全漏洞可能被攻击者利用。
管理缺陷：企业在网络安全管理方面存在的不足，如缺乏有效的安全策略、安全培训不足等。
三、企业级网络安全问题的解决手段
建立完善的安全策略：企业应制定全面的网络安全策略，明确安全目标、责任分配和操作流程，确保网络安全工作的有序进行。
加强技术防护：采用先进的防火墙、入侵检测系统、加密技术等，加强对网络边界和数据传输的保护，防止未经授权的访问和数据泄露。
强化身份认证和权限管理：实施严格的身份认证和权限管理措施，确保只有授权用户才能访问敏感资源，防止权限滥用和非法访问。
加强安全监控和应急响应：建立健全的安全监控体系，实时监测网络状态和安全事件，及时发现并处置安全威胁。同时，制定详细的应急预案，确保在发生安全事件时能够迅速响应并恢复正常运营。
提高员工安全意识：加强员工的网络安全培训和教育，提高员工的安全意识和防范能力，使员工成为网络安全防护的第一道防线。
建立合作关系：与政府部门、行业协会和安全研究机构等建立合作关系，共同应对网络安全挑战，分享安全信息和技术资源。
持续改进和创新：随着网络安全技术的不断发展，企业应持续关注新的安全威胁和防护技术，不断改进和创新自身的网络安全防护体系。
总之，解决企业级网络安全问题需要综合运用各种手段，建立完善的安全体系。企业应高度重视网络安全工作，不断加强自身的安全防护能力，确保企业网络安全和业务稳定。同时，政府和社会各界也应加强合作，共同营造安全、健康的网络环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb2536a96a61f4e2bba18e8a546d6fe/" rel="bookmark">
			“开源与闭源：AI大模型发展的未来之路“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 每日一句正能量前言数据隐私开源大模型与数据隐私闭源大模型与数据隐私数据隐私保护的共同考虑结论 商业应用开源大模型的商业应用优势：开源大模型的商业应用劣势：闭源大模型的商业应用优势：闭源大模型的商业应用劣势：商业应用中的共同考虑：结论： 社区参与开源大模型的社区参与优势：开源大模型的社区参与劣势：闭源大模型的社区参与优势：闭源大模型的社区参与劣势：对行业发展的推动作用：结论： 后记 每日一句正能量 每件事最后都会是好事。如果不是好事，说明还没到最后。
前言 在当今快速发展的人工智能领域，大模型作为技术进步的重要里程碑，正受到业界和学术界的广泛关注。这些模型以其强大的数据处理能力和学习潜力，为各种应用场景提供了强大的智能支持。然而，大模型的开发和部署并非没有挑战，其中之一便是开源与闭源的选择。
开源大模型，以其开放共享的特性，鼓励了广泛的社区参与和协作创新。它们通过公开源代码和模型参数，促进了知识的自由流通和技术的快速迭代。这种开放性不仅加速了AI技术的发展，还有助于减少重复工作，提高研发效率。
另一方面，闭源大模型则侧重于商业利益和知识产权的保护。闭源模型通过限制访问，能够为开发者和企业提供一定程度的竞争优势。此外，闭源模式下，开发者可以更加精细地控制产品发布的节奏，确保技术的稳定性和安全性。
评价这两种模式哪一种更有前景，需要从多个角度进行考量。开源模式的社区活力、创新速度和应用广泛性是其显著优势，而闭源模式的商业潜力、技术保护和市场控制力同样不容忽视。此外，我们还必须考虑到技术发展、伦理法规、社会影响等多方面因素。
本文将探讨开源与闭源大模型各自的优势与挑战，并分析在当前及未来的AI发展中，哪一种模式更有可能引领行业前行。通过对比这两种模式在不同应用场景下的表现，我们将尝试预测它们在未来AI领域的发展趋势。
数据隐私 在讨论开源大模型和闭源大模型在数据隐私保护和用户数据安全方面的差异时，我们需要考虑这两种模型的开发、部署和维护方式。
开源大模型与数据隐私 优势：
透明度：开源模型允许任何人查看和审查代码，这增加了透明度，有助于发现和修复潜在的隐私问题。社区监督：由于开源项目的代码可被广泛访问，社区成员可以共同监督和提高数据隐私标准。快速响应：开源社区通常能够快速响应安全漏洞和隐私问题，及时提供更新和补丁。 挑战：
数据暴露风险：如果开源模型在训练过程中使用了敏感数据，这些数据可能会被公开，增加数据泄露的风险。滥用风险：开源模型可能被不当使用，用于侵犯隐私的恶意目的。 闭源大模型与数据隐私 优势：
控制权：闭源模型的开发和维护由特定组织控制，可以更严格地管理数据访问和使用。合规性：闭源模型的开发团队可以确保遵守数据保护法规，如GDPR等。安全措施：闭源模型可以实施更严格的安全措施，如加密技术和访问控制，以保护用户数据。 挑战：
缺乏透明度：闭源模型的不透明性可能导致用户对数据处理方式的不信任。监督困难：没有公开的代码和文档，外部监督和审查变得更加困难。 数据隐私保护的共同考虑 无论是开源还是闭源模型，都应考虑以下方面：
数据最小化：只收集实现目的所必需的数据。数据匿名化和伪匿名化：在可能的情况下，对数据进行匿名化或伪匿名化处理，以减少隐私风险。用户同意：确保用户充分了解其数据如何被使用，并在此基础上获得用户的明确同意。数据保护政策：制定和执行强有力的数据保护政策，包括数据访问、存储和共享的规则。法律遵从：遵守适用的数据保护法律和行业标准。 结论 开源和闭源大模型在数据隐私保护和用户数据安全方面各有优势和挑战。开源模型通过提高透明度和社区参与来增强信任，而闭源模型通过控制权和安全措施来保护数据。最重要的是，无论选择哪种模型，都应采取适当的技术和政策措施来确保数据隐私和安全。
商业应用 开源大模型和闭源大模型在商业应用领域各有优劣，它们在市场中的定位、商业模式、创新速度和客户关系管理等方面展现出不同的特点。
开源大模型的商业应用优势： 成本效益：开源模型通常免费提供，有助于降低企业在技术开发和部署上的初期投资。灵活性：企业可以自由修改和定制开源模型，以适应特定的业务需求。社区支持：开源模型拥有庞大的开发者社区，可为企业提供免费的技术支持和协作机会。透明度：开源模型的代码公开，有助于建立客户信任，尤其是在数据隐私和安全性方面。创新速度：开源模式鼓励快速迭代和创新，有助于企业快速响应市场变化。 开源大模型的商业应用劣势： 技术支持：开源项目可能缺乏官方的技术支持和咨询服务。质量控制：由于缺乏统一的质量标准，开源模型的性能可能参差不齐。长期维护：开源项目可能面临维护和更新的不确定性，影响企业的长期规划。 闭源大模型的商业应用优势： 专有技术：闭源模型为企业提供了独特的竞争优势，有助于保持市场领先地位。定制服务：闭源模型提供商通常提供专业的定制服务和技术支持。质量保证：闭源模型往往有更严格的质量控制和性能保证。商业模式：闭源模型可以通过许可、订阅或按使用付费等方式为企业创造稳定的收入流。客户关系：闭源模型提供商可以通过提供专业服务来建立和维护客户关系。 闭源大模型的商业应用劣势： 成本：闭源模型可能涉及高昂的许可费用和维护成本。灵活性：企业在使用闭源模型时可能受到限制，难以根据需求进行定制。依赖性：企业可能过度依赖单一供应商，影响议价能力和风险管理。 商业应用中的共同考虑： 市场需求：无论是开源还是闭源，都需要紧密跟随市场趋势和客户需求。合规性：确保商业应用符合行业法规和数据保护法律。风险管理：评估和缓解与技术选择相关的商业风险，包括安全漏洞和数据泄露。持续创新：在保护知识产权的同时，持续推动技术创新和产品升级。 结论： 开源大模型和闭源大模型在商业应用领域提供了不同的价值和挑战。企业在选择时应考虑自身的业务目标、资源、技术能力和市场定位。通过综合评估，企业可以确定哪种模型更适合自己的长期发展和成功。
社区参与 开源大模型和闭源大模型在社区参与和合作方面存在显著差异，这些差异对人工智能行业的发展产生了不同的推动作用。
开源大模型的社区参与优势： 开放协作：开源模型鼓励社区成员共同参与开发和改进，形成了一个开放的协作环境。知识共享：开源项目促进了知识和技术的共享，加速了整个行业的学习和创新速度。多样性：来自不同背景的开发者可以为项目贡献想法和代码，增加了解决方案的多样性。快速迭代：社区的广泛参与可以加速问题的发现和解决，实现快速迭代和优化。降低门槛：开源项目降低了参与门槛，使得小型企业和个人开发者也能参与到大型项目中。 开源大模型的社区参与劣势： 质量控制：社区贡献可能导致质量参差不齐，需要有效的管理和审查机制。方向一致性：众多参与者可能导致项目方向分散，需要强有力的领导和协调。资源分配：社区项目可能面临资源和资金的限制，影响项目的持续性和稳定性。 闭源大模型的社区参与优势： 专注性：闭源项目通常由单一组织管理，能够保持项目的专注性和一致性。资源保障：闭源项目背后的组织可以提供稳定的资源和资金支持。专业支持：闭源项目可以提供专业的技术支持和客户服务，增强用户体验。合作伙伴：闭源项目可以通过选择合作伙伴和联盟，有针对性地扩展影响力。 闭源大模型的社区参与劣势： 参与限制：闭源模型限制了社区的广泛参与，可能错失外部创新和改进的机会。知识壁垒：闭源项目的知识和技术不公开，形成了知识壁垒，限制了知识的传播。成本问题：闭源模型可能需要用户支付费用才能访问，限制了小型企业和个人开发者的参与。 对行业发展的推动作用： 创新速度：开源大模型通过社区的广泛参与，可以加快创新的速度，推动行业发展。技术普及：开源项目有助于技术的普及和教育，提高整个行业的技术水平。商业机会：闭源大模型通过商业化运作，为行业创造收入和增长机会。合作与竞争：开源和闭源模型之间的合作与竞争可以激发更多的创新和优化。生态系统建设：开源和闭源模型都可以在其周围建立起强大的生态系统，促进行业多元化发展。 结论： 开源大模型和闭源大模型在社区参与和合作方面各有优势和劣势，它们共同推动了人工智能行业的发展。开源模型通过开放协作和知识共享加速了技术的创新和普及，而闭源模型则通过专注的管理和商业运作保障了项目的稳定性和专业性。行业的发展需要两者之间的平衡，以实现技术创新、知识普及和商业成功的共同目标。
后记 随着人工智能技术的不断进步，大模型作为推动这一进步的关键力量，其开发和应用已经成为了行业内的热点话题。开源与闭源，作为两种截然不同的发展策略，各自拥有独特的优势和局限性。
开源大模型通过其开放性，促进了技术的快速迭代和创新。它激发了社区的活力，加速了知识的共享，降低了研发的门槛。这种开放性不仅有助于推动科学的发展，还能够在一定程度上提高技术的透明度和可解释性，这对于建立公众对AI技术的信任至关重要。
闭源大模型则以其商业潜力和对知识产权的保护而受到重视。它允许企业在市场中保持竞争优势，通过控制技术的发布和应用，确保产品和服务的质量和安全性。此外，闭源模式也为投资和盈利提供了更为明确的路径。
在评估这两种模式的未来前景时，我们不能忽视技术发展的速度和市场的需求。开源模式可能会因为其快速的创新和广泛的应用而继续受到青睐，尤其是在开放数据和算法公平性的推动下。而闭源模式则可能在特定领域和行业中保持其独特价值，特别是在那些对安全性和隐私性有特殊要求的场景中。
然而，无论选择哪种模式，我们都必须认识到，AI技术的发展不仅仅是技术问题，它还涉及到伦理、法律和社会等多个层面。因此，未来的AI大模型发展，需要在创新与责任、开放与保护之间找到平衡。
在本文的探讨中，我们尝试从不同的角度分析了开源与闭源大模型的优势和挑战，并对未来的发展趋势进行了预测。我们希望这些讨论能够为读者提供一些有益的见解，并激发更多的思考和讨论。
转载自：https://blog.csdn.net/u014727709/article/details/139282471
欢迎 👍点赞✍评论⭐收藏，欢迎指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2f173b16080e45beee3407cfddc726/" rel="bookmark">
			Python魔法之旅-魔法方法(07)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1、定义
2、作用
二、应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
23、__getattribute__方法
23-1、语法
23-2、参数
23-3、功能
23-4、返回值
23-5、说明
23-6、用法
24、__getitem__方法
24-1、语法
24-2、参数
24-3、功能
24-4、返回值
24-5、说明
24-6、用法
25、__getnewargs__方法
25-1、语法
25-2、参数
25-3、功能
25-4、返回值
25-5、说明
25-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f2f173b16080e45beee3407cfddc726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026057840ed216f68a1a68b16c42ef5a/" rel="bookmark">
			Golang | Leetcode Golang题解之第123题买卖股票的最佳时机III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：
题解：
func maxProfit(prices []int) int { buy1, sell1 := -prices[0], 0 buy2, sell2 := -prices[0], 0 for i := 1; i &lt; len(prices); i++ { buy1 = max(buy1, -prices[i]) sell1 = max(sell1, buy1+prices[i]) buy2 = max(buy2, sell1-prices[i]) sell2 = max(sell2, buy2+prices[i]) } return sell2 } func max(a, b int) int { if a &gt; b { return a } return b } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ae63e5d9b9915ee94bcdc754272d2f/" rel="bookmark">
			C语言王国——杨氏矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 引言
2. 了解杨氏矩阵
3. 思路分析
4. 代码
5. 总结
1. 引言 最近在做二维数组的训练的时候发现了一个很有意思的题：
一看这不是杨氏矩阵嘛，接下来就由姜糖我带大家了解一下这个著名的矩阵。
2. 了解杨氏矩阵 通过查阅百度得知：
杨氏矩阵：
是对组合表示理论和舒伯特演算很有用的工具。它提供了一种方便的方式来描述对称和一般线性群的群表示，并研究它们的性质。有一个二维数组. 数组的每行从左到右是递增的，每列从上到下是递增的. 在这样的数组中查找一个数字是否存在。 时间复杂度小于O(N)。
平常我们在数组里查找数字时，是否我们用的都是暴力遍历查找，一个数一个数的去比对时间复杂度为O(n)，效率很低，这时候就该我们杨氏矩阵出场了。 3. 思路分析 资料中我们知道了杨氏矩阵是一个二维数组，数组的每行从左到右是递增的，每列从上到下是递增的. 在这样的数组中查找一个数字是否存在，所以我们举一个例子：
在arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}}查找数字n。
数组如图：
此数组符合杨氏矩阵。
那接下来我们该怎么查找数字更快捷呢。接下来我们要找此数组里的特殊的数，我们会发现最右上角的那个数是一行之中最大的一列之中最小的所以我们拿n去跟他比较，然后我们就会发现：
红色为查找范围，黄色为除去范围。
根据图中我们发现当n&gt;3时，第一行就被排除了，查找范围只有第二、三行；
当n&lt;3时，第一列就被排除了 ，查找范围只有第二、三列。
然后在接下来的图像中继续取右上角的数字进行比较，排除行和列直达剩下查找的数，若都找不到则数字n不在数组中。
我们将n赋值进行具体分析，为了特殊性，我们就取右上角的对角左下角7吧。
当n=7，如图分析：
这样我们就能找到我们的数字n了。最后我们也发现：在一个杨氏矩阵中查找最特殊的数字7，我们总共进行了5次比较，找到了元素，这样的查找方式明显比遍历二维数组的效率高 。
4. 代码 接下来我就来分享一下我写的代码：
#include&lt;stdio.h&gt; int young(int (*arr)[3], int n) { int i,j = 0; for (i = 0; i &lt; 3; i++) { for (j = 2; j &gt;= 0; j--) { if (n == arr[i][j]) { return 1; } else if(n &gt; arr[i][j]) { break; } } } return 0; } int main() { int arr[3][3] = { 1,2,3,4,5,6,7,8,9 }; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75ae63e5d9b9915ee94bcdc754272d2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3a33fb4b5d2700be7a927af7078d15/" rel="bookmark">
			算法（十三）回溯算法---N皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 算法概念经典例子 - N皇后问题什么是N皇后问题？实现思路 算法概念 回溯算法是类似枚举的深度优先搜索尝试过程，主要是再搜索尝试中寻找问题的解，当发生不满足求解条件时，就会”回溯“返回（也就是递归返回），尝试别的路径求解。 经典例子 - N皇后问题 什么是N皇后问题？ N皇后问题研究的是：如何将ｎ个皇后放在n * n的棋盘上，并且使皇后彼此之间不能相遇，也就是一个皇后的上下左右、以及斜着对角线上都不能有另外一个皇后，也就是一个皇后在 ”米“ 的视线中不能遇到另外一个皇后。
实现思路 如上图，我们可以把这个问题划分成8个阶段，依次将8个棋子放到第一行、第二行…第八行。在放置的过程中，我们不停的检查当前的方法是否满足要求。如果满足，继续下一行放置，如果不满足，就再换一种方法，继续尝试。
实现代码：
package com.xxliao.algorithms.backtrack; /** * @author xxliao * @description: N皇后问题 求解 * @date 2024/6/1 0:14 */ public class NQueens { public static void main(String[] args) { NQueens queens=new NQueens(); queens.setQueens(0); queens.printQueens(); } // 皇后数量 static int queens_count = 8; // 定义数组来存在皇后，索引表示行，值表示皇后存在改行的那一列中 int[] array = new int[queens_count]; /** * @description 根据行号，设置该行的皇后位置 * @author xxliao * @date 2024/6/1 0:17 */ public void setQueens(int row) { if(row == queens_count) { // 递归结束条件 return; } // 尝试每一列放置，如果没有合适的，就返回上一层 for(int column = 0; column &lt;queens_count; column++) { if(isOk(row,column)) { // 符合条件，放置 array[row] = column; // 然后设置下一行 setQueens(++row); } } } /** * @description 判断改行该列是否 符合条件 * @author xxliao * @date 2024/6/1 0:23 */ private boolean isOk(int row, int column) { // 定义左上角、右上角 列索引标记 int leftup = column - 1; int rightup = column + 1; // 然后从当前行逐行向上遍历，看当前row、column是否满足条件 for(int i = row-1; i &gt;= 0; i--) { if(array[i] == column){ // 如果该位置已经有了皇后了，不满足 return false; } if(leftup &gt;=0 &amp;&amp; array[i] == leftup) { //左上对角线存在queen,第一次执行是当前行，肯定不满足条件，i--，leftup--之后就是当前点的左上角位置 return false; } if(rightup &lt; queens_count &amp;&amp; array[i] == rightup) { //右下对角线存在queen，同上理由 return false; } leftup--; rightup++; } return true; } /** * @description 打印N皇后棋盘 * @author xxliao * @date 2024/6/1 0:34 */ private void printQueens() { for (int i = 0; i &lt; queens_count; i++) { for (int j = 0; j &lt; queens_count; j++) { if (array[i] == j) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f3a33fb4b5d2700be7a927af7078d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc25c95063c1933e5c3dcbbd79261b03/" rel="bookmark">
			【 0 基础 Docker 极速入门】镜像、容器、常用命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Images（镜像）生命周期 Docker 是一个用于创建、部署和运行应用容器的平台。为了更好地理解 Docker 的生命周期，以下是相关概念的介绍，并说明它们如何相互关联：
Docker：
Docker 是一个开源平台，用于自动化应用程序在轻量级、便携式容器中的部署、扩展和管理。 Dockerfile：
Dockerfile 是一个文本文件，包含一系列指令，用于构建 Docker 镜像。每个指令在 Docker 镜像中创建一个新的层。 build：
docker build 命令用于从 Dockerfile 构建一个 Docker 镜像。该命令读取 Dockerfile 的内容，并按照其中的指令一步步创建镜像。 Images：
Docker 镜像是一个不可变的文件，它包含了应用程序以及其运行所需的一切。镜像是基于层的，每层代表一个文件系统的快照。 tag：
标签用于给 Docker 镜像赋予一个易于识别的名字和版本号。比如，myapp:1.0 中的 1.0 就是一个标签。 registry：
Docker 仓库是存储和分发 Docker 镜像的地方。最常用的公共仓库是 Docker Hub，也可以有私有仓库。 push：
docker push 命令用于将本地 Docker 镜像上传到 Docker 仓库中，以便在其他环境中使用或共享。 pull：
docker pull 命令用于从 Docker 仓库中下载镜像到本地环境。 Containers：
容器是从镜像创建的一个实例，运行应用程序。容器是轻量级的隔离环境，确保应用程序的独立运行。 run：
docker run 命令用于创建并启动一个新的容器。例如，docker run myapp:1.0 会从 myapp:1.0 镜像创建并启动一个容器。 commit：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc25c95063c1933e5c3dcbbd79261b03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133d3162aa6a69eb8cc475830d169b48/" rel="bookmark">
			轻松拿捏C语言——自定义类型之【联合体与枚举】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥰欢迎关注 轻松拿捏C语言系列，来和 小哇 一起进步！✊
🎉创作不易，请多多支持🎉
🌈感谢大家的阅读、点赞、收藏和关注💕
🌹如有问题，欢迎指正
目录👑
🌟一、联合体（共用体）
🌙1、声明
🌙2、特点
🌙3、大小计算
🌟二、枚举类型
🌙1、声明
🌙2、优点
🌙3、使用
🌟一、联合体（共用体） 🌙1、声明 联合体和结构体一样可以有多个成员，成员类型可以不同。
联合体所有成员共用一块空间，所以联合体又叫 共用体
一个联合变量的大小至少是最大成员的大小
在声明上，联合体和结构体类似，只是把struct关键字换成了union关键字。
给联合体一个成员赋值，其他成员的值也会跟着变化
#include &lt;stdio.h&gt; //联合类型的声明 union Un { char c; int i; }; int main() { //联合变量的定义 union Un un = { 0 }; //计算连个变量的⼤⼩ printf("%d\n", sizeof(un)); return 0; } 这里结果为4，因为这里int最大，占四个字节 🌙2、特点 代码1
#include &lt;stdio.h&gt; //联合类型的声明 union Un { char c; int i; }; int main() { //联合变量的定义 union Un un = { 0 }; // 下⾯输出的结果是⼀样的吗？ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/133d3162aa6a69eb8cc475830d169b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a64f33028083cfc869768ef05b5f0cf/" rel="bookmark">
			Scikit-Learn 基础教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🐋Scikit-Learn 基础教程
🐋Scikit-Learn 简介
🐋 数据预处理
🦈数据集导入
🦈数据清洗
🦈特征选择
🦈特征标准化
🐋 模型选择
🦈分类模型
🦈回归模型
🦈聚类模型
🐋模型训练与评估
🦈交叉验证
🦈超参数调优
🐋 模型保存与加载
🐋 实战案例
🦈分类问题：手写数字识别
🦈回归问题：波士顿房价预测
🦈聚类问题：鸢尾花数据集聚类分析
🐋总结
🐋Scikit-Learn 基础教程 Scikit-Learn（简称 sklearn）是一个基于 Python 的机器学习库。它构建在 NumPy、SciPy 和 Matplotlib 之上，为各种机器学习任务提供了简单而高效的工具。本文将详细解析 Scikit-Learn 的基础知识，并通过具体示例来展示其应用。 🐋Scikit-Learn 简介 Scikit-Learn 是一个开源的机器学习库，由 David Cournapeau 在 2007 年创建，并在 2010 年由 INRIA 进行发布。它以其简单易用、丰富的功能和良好的文档支持，成为了机器学习领域的重要工具。 Scikit-Learn 提供了以下主要功能：
数据预处理：包括特征提取、归一化和降维等。模型选择：支持多种分类、回归和聚类算法。模型评估：提供了丰富的模型评估指标和交叉验证方法。模型调优：支持网格搜索和随机搜索等超参数调优方法。模型持久化：支持模型的保存和加载。 🐋 数据预处理 数据预处理是机器学习流程中的重要环节，旨在将原始数据转换为适合模型训练的数据形式。Scikit-Learn 提供了一系列工具来简化这一过程。 🦈数据集导入 Scikit-Learn 提供了一些常用数据集，可以通过 datasets 模块直接加载。此外，还可以从 CSV、Excel 等文件中导入数据。 from sklearn import datasets # 加载鸢尾花数据集 iris = datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a64f33028083cfc869768ef05b5f0cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6fe80f82d5564d8afcbc3e257c43ad/" rel="bookmark">
			Groqbook：AI写书神器，基于Llama3几秒钟生成完整书籍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AI技术飞速发展的今天，许多传统行业都面临着被颠覆的可能。近日，我发现了一款名为Groqbook的AI写书神器。它利用Llama3和Groq技术，能够基于一个主题在几秒钟内生成一本完整的书。这是否意味着未来的作者将面临AI的竞争，甚至被取代？本文将详细介绍Groqbook的工作原理和使用方法，并探讨其对写作行业的影响。
项目地址：https://github.com/Bklieger/groqbook
什么是Groqbook？ Groqbook是一款基于AI技术的自动写书工具。它利用了Llama3大模型，通过Groq API接口，只需输入一个主题，便能在几秒钟内生成一本完整的书籍。这种技术的出现，不仅提高了写作效率，也为内容创作带来了新的可能性。
Groqbook的核心技术 Llama3大模型：Llama3是一个强大的语言生成模型，具有处理大量文本数据的能力。它能够理解复杂的语言结构和语义关系，从而生成连贯且高质量的文本内容。Groq API：Groq API是Groqbook的核心接口，通过该接口，用户可以轻松地与Llama3模型进行交互，获取所需的文本内容。 使用Groqbook生成书籍 使用Groqbook生成书籍非常简单，只需以下几个步骤：
注册Groq API：首先，需要在Groq官网注册一个API账号，获取API密钥。配置API密钥：在本地安装的Groqbook版本中，配置API密钥。输入书籍主题：在界面中输入你想要写的书籍主题，例如“AI Agent Application”。生成书籍：点击生成按钮，几秒钟内即可生成包含多个章节的完整书籍。 以下是详细的操作步骤：
第一步：注册Groq API 访问Groq官网，注册并获取API密钥。如果你已经有了API密钥，可以直接跳到下一步。
第二步：配置API密钥 在本地安装的Groqbook版本中，找到配置文件并将API密钥填入对应位置。
export GROQ_API_KEY="your_api_key_here" 第三步：输入书籍主题 在Groqbook界面中输入你想要写的书籍主题。例如，输入“AI Agent Application”，然后点击生成按钮。
第四步：生成书籍 几秒钟内，Groqbook会自动生成一本包含19个章节的完整书籍。生成的书籍以Markdown格式保存，可以直接下载并查看。
Groqbook的实际应用 速度与效率 在演示中，Groqbook在不到一分钟的时间内生成了一本约13000字的书籍，速度惊人。以下是生成过程中的一些数据：
每秒生成1258个Token总生成时间为0.61秒文档长度约13000字 文件格式与下载 生成的书籍以Markdown格式保存，用户可以直接下载使用。Markdown格式的好处在于其简单易用，方便后期编辑和排版。
Groqbook对写作行业的影响 优势 高效写作：Groqbook极大地提高了写作效率，对于需要快速生成大量内容的用户来说，非常有帮助。多样化创作：AI写书工具能够生成各种主题和风格的书籍，满足不同读者的需求。辅助创作：对于写作初学者或需要灵感的作者，Groqbook可以作为辅助工具，提供创作思路和范例。 挑战 质量与原创性：尽管AI生成的内容连贯性较好，但在创意和深度上仍与人类创作有一定差距。如何提高AI生成内容的质量和原创性，是一个值得关注的问题。版权与法律问题：AI生成的内容涉及版权归属问题，如何界定AI与用户的创作权利，需要法律层面的进一步明确。作者的角色转变：随着AI写作工具的普及，传统作者可能需要调整自己的角色，更加注重内容的策划和质量把控，而非纯粹的文字输出。 未来展望 虽然目前AI写作工具尚未完全取代人类作者，但随着技术的不断进步，这一趋势不可忽视。未来，AI有可能在更多领域中发挥重要作用，例如教育、新闻、市场营销等。同时，作者可以利用AI工具，提高创作效率和内容质量，创造出更多优秀的作品。
总的来说，Groqbook的出现为写作行业带来了新的可能性和挑战。我们应当积极拥抱技术变革，探索AI在内容创作中的更多应用场景，同时保持对创意和原创性的追求，确保内容的高质量输出。
希望本文能为您提供有关Groqbook及其对写作行业影响的深入理解。如果对本文内容有任何疑问或建议，欢迎留言讨论。感谢您的阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d103b2c37d1f61b675a1cb579f61ff5/" rel="bookmark">
			AI智能体｜使用扣子Coze从0到1搭建一个信息收集助手，并接入微信公众号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是无界生长。
AI智能体｜使用扣子Coze从0到1搭建一个信息收集助手，并接入微信公众号本文通过案例实操的方式，演示了如何使用Coze从0到1搭建一个信息收集助手，核心是利用Coze的“数据库”、“快捷指令”功能。如果看完还没学会的话，可以在文章下方评论或私信我。学会了的话，欢迎转发分享给你的朋友们。https://mp.weixin.qq.com/s?__biz=MzU1MjgyOTA5NQ==&amp;mid=2247484540&amp;idx=1&amp;sn=d0eebce482690ef4ab09c48034d364d2&amp;chksm=fbfd6db4cc8ae4a2ddf165bb8078fd1b8fde99ec7968dbde8f638721616b0ca5e462fc25d822&amp;token=1382993676&amp;lang=zh_CN#rd
最近在做Coze开发AI智能体的课程，大家如果有课程学习需求可以联系我。下面分享一个实操案例：使用扣子Coze从0到1搭建一个信息收集助手，并接入微信公众号。为了方便演示，对案例中的数据进行了简化及脱敏，同时对案例的交互流程进行了简化。在这个案例中，主要使用到了Coze的“数据库”、“快捷指令”功能，保姆级教程，直接嘴里喂饭，学会了的话，记得点赞关注，欢迎分享转发！
价值 智能客服是AI智能体实操落地最多的场景之一，企业通过AI搭建自己的智能客服，几乎避免不了一个问题——收集用户信息。无论你的智能客服是提供什么功能，都希望通过收集用户信息的方式链接到用户，尤其是服务咨询、产品营销等场景，而智能客服处于对接用户的一线，是最方便也最容易成为用户信息收集入口的。通过填写信息的方式筛选意向用户，可以有效提升用户转换率，提升营业额。
思路梳理 在开始之前，需要想清楚要做哪些事情，挑战是什么，内容大致整理如下：
需要收集哪些信息
如何定义对应信息的字段名称
如何引导用户准确的填写信息
如何保存用户填写的信息
如何查询用户填写的信息
看完是不是有点头大？不要慌，有手就行，下面跟着我一步步实操。
操作流程 创建Bot
编排Bot
设置提示词
设置模型参数
创建数据库表
设置开场白
添加快捷指令
调试Bot
发布Bot
功能验证
查询数据表
创建Bot 登录Coze国内版，创建Bot，填写Bot名称，Bot功能介绍和图标按需修改，确认无误后，点击“确认”创建Bot。
编排Bot 设置提示词 提示词的设置非常关键，决定了智能体与用户交互逻辑，尤其是在需要引导用户准确填写信息的场景下，需要进行多轮调整，效果才会相对比较好。既然是保姆级教学，提示词我也给大家准备好了，如下图所示。文字版的提示词内容较长，扫描文末二维码加我微信领取。
在上述提示词中，明确了要收集哪些信息，字段名称是什么，准确引导用户填写信息并让用户确认，保存用户信息到“user_info”表。
设置模型参数 单 Agent 模式
豆包 Function call 模型
精确模式
携带上下文论数：10
输出格式：文本
说明：
案例演示的场景比较简单，单 Agent 模式即可；
需要准确引导用户填写信息，精确模式相对更符合要求；
流程涉及到与用户进行多轮对话/交互，携带上下文轮数推荐设为10，可以视实际情况调大；
输出格式保持文本格式即可。
创建数据库表 在数据库右边点击“+”，添加表
填写数据表名称、数据表描述、Table查询模式以及字段相关信息
设置开场白 主要是提示用户使用快捷指令
添加快捷指令 点击快捷指令后面的“+”，添加指令
填写快捷指令信息
按钮名称用于在Coze平台触发
指令名称用于在飞书、公众号等渠道触发
定义组件和指令内容
指令效果预览，核对无误后，点击“确认”
调试Bot 不使用快捷指令 测试输入无关内容
按流程输入信息
故意输入非法信息
纠正电话号码后，确认信息，提示收集完成
测试信息确认功能是否生效
使用快捷指令 使用快捷指令的好处是能高效准确的收集信息，避免多轮对话交互，信息填写完成后，回车确认
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d103b2c37d1f61b675a1cb579f61ff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c51efcbbc448db2e077eb41756abc7c/" rel="bookmark">
			一次滑稽的面试(鼎夏)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文记述自己今天面试的经历，堪称滑天下之大稽
清晨起来打开窗，心情美美哒，boss上有个小姐姐给我推荐职位，把简历发送过后，小姐姐立即就给我安排了下午的面试，并且时间准确，我问的问题也及时回复，接到面试的时候，还些许有些紧张，但是两分钟后，脸色一黑，面试的鼎夏师傅(叼毛，以下称为师傅，毕竟咱是个讲文明的人)真的是看人低，
问答环节，只有三个环节，
你会设备吗？ 接触到的设备比较少，某信的某图。某服的ips
会那些操作(不耐烦) 个人权限问题，仅限于查看流量等，没有进行过设备升级，维护等操作
谁谁谁的设备会不会？（不行） 没接触过，不会
当我说出之前的工作内容，渗透，基线检查等，并且代审还有些成果的，时候，惊讶道，你还会代码审计，php的呀（一脸不屑），
你他喵的简历都不看完？？都在一页，看不到？？ 没了 个人因素：由于之前的工作内容，个人对于设备这块并不擅长，很多设备都没操作过，这一点确实是个人原因，但是之前问过人事小姐姐，这个职位并不是只是给设备配个人，还有一些渗透的内容，反正要参加hvv,先面试一下，看看自己的能力在那个层次
我觉得一个面试官，最起码应该要先看一下面试者的简历，然后再进行面试，鼎夏的面试官，简历都不看，直接面试，语言中充斥着不耐烦，并且面试完之后还牵扯人事，说是人事的责任，我不晓得是什么给的你高高在上的感觉，
以下是气愤的原因
首先 简历上写了熟悉php审计与java代码审计，鼎夏叼毛为什么会感到惊讶，连简历都不看，直接面试，鼎夏也是遇到的头一份
人与人之间要互相尊重，鼎夏叼毛毫无尊重可言
其次 我的简历中，没有提到任何红队成果，鼎夏方面来了句，看到你的红队成果很多，就不面试渗透了。
你他喵的那只眼看到红队成果了？？？ 最后 我向人事说明了情况，鼎夏叼毛搁那喷人事，说人事的检验标准不对，
我只能说 666 啊 总结 我的代审能力仅限于top10，只有十几个cms通用漏洞，40余个cnvd编号，这位师傅如此的瞧不起人，大概是瞧不起我这两位数的，打底也是有三位数的通用0day，当然了，要是事件漏洞方面，我相信鼎夏师傅肯定是手拿把掐，没有4位数都不会出来面试别人，毕竟有这种高高在上的傲气嘛，希望这位师傅，拿着面试时高高在上的感觉，将三位数的通用漏洞砸到我脸上，而不是自己当只会top10的设备牛马，去说教每一个面试的人。
当然了，这位师傅充分表达了自己对php代审的不屑，肯定早已精通java，.net审计，并且对于java.net有着自己独特的理解，手中的java 0day肯定是不计其数，还希望这位师傅不吝赐教，传授一下经验。
鼎夏的风评也是耐人寻味，从一月前发的公告可见一斑，当然了，我们也知道那些都是外包嘛，和贵公司没有丝毫关系，懂得都懂，这个叼毛的领导也是那个样子，人事反馈上去，没有任何结果，最后还是人事过来和我说明情况，龙生龙，凤升凤，鼎夏的人员出现这些叼毛很正常(小姐姐很好的，很耐心)。
建议各大安全厂商联合起来，出一个 设备认证证书 ，能圈钱，还能给自己卖出去的设备配人。
最后一句 鼎夏的叼毛拿出你高高在上的依靠砸死我 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f1f7b5e803a79e88dae3e6af24efac/" rel="bookmark">
			安全风险 - 组件导出风险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安全审查中关于组件导出风险是一种常见问题，不同组件都有可能遇到这种问题，而且从一定角度来看的话，如果涉及到三方业务，基本处于无法解决的场景，所以我们需要说明为何无法避免这种风险
组件导出风险能不能规避？能不能解决？
如果你的组件风险是由 exported 属性所引起，那么可以规避，也可以解决，只要将 exported 设置为 false 即可； 这样外部就无法调用项目内组件了，自然就避免了风险的产生，同时带来了一些不太好的结果，例如业务出错、功能缺失等等，毕竟 很多项目内集成的三方平台SDK都是需要 exported 所附带的权限的！
最终结果：当 组件导出风险 遇到三方业务时，很多时候我们可能无法规避这类型风险！
雨 基础分析那些无法解决的风险场景Activity 组件导出风险Service 组件导出风险Broadcast Receiver组件导出风险 定义权限、保护组件 基础分析 组件导出风险一般都是由 android:exported 属性引起的，如果我们在 AndroidManifest 对应组件内声明了 android:exported=true，意味着允许让外部组件启动这个组件；反之，则不允许让外部组件启动这个组件；
初步搜索后，AI已经给出了部分参考答案，简单看一下就好（解决方式未尝试，不确定是否可用）
其实当你已经将 android:exported 设置为 true 时，已经证明该组件因业务需要确实需要被外部调用，这种场景如果是项目内我方业务的话，可以参考 权限过滤、intent-filter 过滤方式（个人感觉这种方式只是在内部做了限制保护，从安全检查的角度来看可能当你android:exported 设置为 true 时就已经存在风险了，并不关注你内部做了何限制…）
如果android:exported设置了false，又在外部试图启动这个Activity，则会发生程序崩溃，报异常，例如：
java.lang.SecurityException: Permission Denial: starting Intent 常见组件可以参考Android四大组件
活动（Activity）：用于表现功能，是用户操作的可视化界面，它为用户提供了一个完成操作指令的窗口；服务（Service）：后台运行服务，不提供界面呈现；广播接受者（Broadcast Receive）：用于接收广播；内容提供者（Content Provider）：支持多个应用中存储和读取数据，相当于数据库。 exported 在不同场景下默认值也有所不同
关于exported属性还是挺关键的，参考自 Android 组件导出风险及防范
Activity、Service、Broadcast Receive 中 exported 默认值
没有 intent filter 时，默认为 false有 intent filter 时，默认为 true Content Provider 中 exported 默认值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f1f7b5e803a79e88dae3e6af24efac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b682371e5cc7b3d1bf44af2b85891f69/" rel="bookmark">
			配置资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 Secret Secret 是用来保存密码、token、密钥等敏感数据的 k8s 资源，这类数据虽然也可以存放在 Pod 或者镜像中，但是放在 Secret 中是为了更方便的控制如何使用数据，并减少暴露的风险。
1 有三种类型： kubernetes.io/service-account-token：由 Kubernetes 自动创建，用来访问 APIServer 的 Secret，Pod 会默认使用这个 Secret 与 APIServer 通信， 并且会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中;
Opaque ：base64 编码格式的 Secret，用来存储用户自定义的密码、密钥等，默认的 Secret 类 型;
kubernetes.io/dockerconfigjson ：用来存储私有 docker registry 的认证信息。
2 Pod 需要先引用才能使用某个 secret，Pod 有 3 种方式来使用 secret： 作为挂载到一个或多个容器上的卷 中的文件。作为容器的环境变量。由 kubelet 在为 Pod 拉取镜像时使用。 应用场景：凭据
https://kubernetes.io/docs/concepts/configuration/secret/ 二 创建 Secret 1 用kubectl create secret命令创建Secret 创建 Secret 1、用kubectl create secret命令创建Secret echo -n 'zhangsan' &gt; username.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b682371e5cc7b3d1bf44af2b85891f69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b38849d276356d11713fb8cbe8656b/" rel="bookmark">
			个人关于ChatGPT的用法及建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 这里只是个人常用的几个软件，做一下汇总，希望对各位有用。
如果有更高认知的朋友，请留下你的工具名称，提醒我一下，谢谢～
常用的chatgpt模型工具： 以下是一些知名的例子：
文心一言 - 百度公司开发的预训练语言模型，用于自然语言处理和文本生成。Claude - Anthropic公司推出的语言模型，以其高质量的对话和内容生成能力著称。Qwen - 阿里云开发的AI助手，专为中国用户设计，可在GitHub上互动。Bing聊天机器人 - 微软集成ChatGPT技术至Bing搜索引擎和Edge浏览器中提供的聊天功能。阿里云小蜜 - 虽然更偏重于客户服务，但也是阿里云开发的智能对话系统。讯飞星火 - 科大讯飞的预训练语言模型，服务于多场景的AI应用。Minimax - 中国AI企业打造的语言模型，面向特定行业和应用场景。天工 - 暂无详细信息，但可能指代某一专注于特定领域（如工业、制造）的AI解决方案。智谱清言 - 又一国产大模型，致力于提供高质量的文本生成和对话服务。Kimi Chat - 未具体说明，可能是一个面向消费者或特定市场的聊天AI应用。 这些模型各自具有不同的特点和应用场景，反映了全球范围内对AI语言技术的积极探索和多样化发展。
手机端也有很多，比如kimi，豆包等等都可以为你提供基本的搜索和问答服务。
用法建议 1、搜索 提高自己的搜商，感觉比情商都重要了。
毕竟与机器的交互，慢慢滴会成为日常行为的一部分。
甚至当下，也是一种超越同龄人，提升自己效率的必备工具啦。
2、发散 弥补自己思维的漏洞，为自己思考的过程做一个推演。
让自己可以通过它的视角来看待整个事情的完整性，同时为自己提供更好的思考的角度。
3、好友 一个24小时可以为自己对话的朋友；
一头不知疲倦，不辞劳苦的老黄牛；
同时也是自己的导师，为自己提供对应的建议；
4、缺点 缺点也有很多，有时候他会自圆其说，说着风凉话，那叫一个绝情。
所以，我们当前就把其当作一个自己的外挂，在自己困惑的时候，在自己搜索的时候，在自己无头绪的时候，可以让他给我们一些建议。
个人感觉这些还是比我们高级的，虽然他并不懂这些文字的真正意义！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1f8a01a85cc8d81fd9b56501550961/" rel="bookmark">
			有三台机器A,B,C ,A和B分别处于一个局域网内，C是一个允许Linux的公网服务器,如果通过ssh命令让A通过C访问B的指定端口?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有三台机器A,B,C ,A和B分别处于一个局域网内，C是一个允许Linux的公网服务器,如果通过ssh命令让A通过C访问B的指定端口?
要让机器A通过机器C访问机器B的指定端口，并且使用SSH，你可以设置一个SSH隧道。SSH隧道允许你通过SSH连接转发TCP端口。在这个例子中，你需要设置一个反向SSH隧道从机器B到机器C，然后在机器A上设置一个本地端口转发到机器C上的隧道端口。
这里是如何设置的步骤：
1. 在机器B上设置反向SSH隧道到机器C
首先，你需要在机器B上设置一个反向SSH隧道到机器C。你可以使用ssh命令的-R选项来做到这一点。
在机器B上执行以下命令：
bash
ssh -fN -R &lt;local_port_on_C&gt;:&lt;host_or_ip_of_B&gt;:&lt;port_on_B&gt; user@C -p C的端口
&lt;local_port_on_C&gt; 是你希望在机器C上打开的端口，用于转发到机器B的&lt;port_on_B&gt;。
&lt;host_or_ip_of_B&gt; 是机器B的IP地址或主机名。
&lt;port_on_B&gt; 是机器B上你想要访问的端口。
user@C 是机器C上的用户名和机器C的地址。
例如，如果你想要转发机器B上的22端口（SSH端口）到机器C上的3306端口，你可以这样做：
ssh -fN -R 3306:127.0.0.1:22 user@C -p C的端口
2. 在机器A上设置本地端口转发到机器C
现在，你需要在机器A上设置一个本地端口转发，将某个本地端口转发到机器C上的&lt;local_port_on_C&gt;。这样，当你连接到机器A的这个本地端口时，流量会被转发到机器C，然后通过SSH隧道转发到机器B。
在机器A上执行以下命令：
bash
ssh -L &lt;local_port_on_A&gt;:&lt;host_or_ip_of_B&gt;:&lt;local_port_on_C&gt; user@C -p C的端口
&lt;local_port_on_A&gt; 是机器A上的本地端口，用于接收连接。
&lt;host_or_ip_of_B&gt; 和 &lt;local_port_on_C&gt; 应该是你在机器B上设置的反向SSH隧道时使用的相同值。
user@C 是机器C上的用户名和机器C的地址。
例如，如果你想要在机器A上使用本地端口4444来访问机器B的22端口，并且机器C上的隧道端口是3306，你可以这样做：
ssh -L 4444:127.0.0.1:3306 user@C -p C的端口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ded2311e171008d355d750e6362fd0/" rel="bookmark">
			.NET数据交互之生成和读取YAML文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目中，业务上需要与Python进行交互，而Python程序用的配置文件主要是YAML，程序以命令行形式运行，前端页面由C#通过WPF开发完成。现在需要通过C#生成YAML配置文件，并经过Python读取和修改后，再次由C#进行读取。在C#开发程序中，主要用的配置文件主要是XML，JSON，INI等，很少用到YAML，今天以一个简单的小例子，简述如何通过C#程序，进行YAML文件的读取和写入，仅供学习和参考使用，如有不足之前，还请指正。
什么要YAML？ YAML 是 "YAML Ain't Markup Language"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。
YAML的基本特点 YAML吸收了XML，JSON，INI等格式文件的优点，主要有以下几种特点：
大小写敏感使用缩进表示层级关系缩进时不允许使用Tab键，只允许使用空格。缩进的空格数目不重要，只要相同层级的元素左侧对齐即可#表示注释字符串无需加引号，如果要加，单引号会被转义，双引号不会不转义key: value key和value之间有空格 YAML支持的数据类型 YAML以数据为中心，支持的数据类型主要有以下几种：
纯量（scalars）：单个的、不可再分的值，数据最小的单位，不可以再分割。类似于Python中单个变量数组：一组按次序排列的值，又称为序列（sequence） / 列表（list），与Python的list数组结构类似，数组元素使用“-”开头，也可以根据缩进进行数组嵌套。对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary），对象的一组键值对，使用冒号结构表示。类似Python中的字典数据结构。 YAML数据示例 1. 列表示例 列表获数组，与Python的list数组结构类似，数组元素使用“-”开头，也可以根据缩进进行数组嵌套。如下所示：
#行内写法： k: [v1,v2,v3] #或者 k: - v1 - v2 - v3 2. 对象示例 对象【map，hash，set，object】表示一组键值对，使用冒号结构表示。类似Python中的字典数据结构。
platformName: Android platformVersion: 6.0.1 注意：冒号后面一定要有空格！
YamlDotNet安装 在本示例中，主要通过YamlDotNet库进行Yaml文件的读取的和写入，即对象的序列化和反序列化。在VS中，点击项目右键，打开Nuget包管理器，然后搜索YamlDotNet库[当前版本为15.1.6]进行安装，如下所示：
YamlDotNet对应的GitHup地址为：GitHub - aaubry/YamlDotNet: YamlDotNet is a .NET library for YAML
创建Yaml帮助类 Yaml帮助类主要包括读取和写入Yaml文件两个功能。
1. 读取 从Yaml文件中读，并反序列化，主要通过DeserializerBuilder类进行构建反序列号接口，然后再反序列化，如下所示：
public static T ReadYaml&lt;T&gt;(string file) { var target = DeserializeFromFile&lt;T&gt;(file); return target; } public static T Deserialize&lt;T&gt;(string yaml) { IDeserializer _deserializer = new DeserializerBuilder().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ded2311e171008d355d750e6362fd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf551392f13db424b0a191a155fe61f/" rel="bookmark">
			数据结构的快速排序（c语言版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.快速排序的概念 1.快排的基本概念 快速排序是一种常用的排序算法,它是基于分治策略的一种高效排序算法。它的基本思想如下:
从数列中挑出一个元素作为基准(pivot)。将所有小于基准值的元素放在基准前面,所有大于基准值的元素放在基准后面。这个过程称为分区(partition)操作。递归地应用上述步骤到左右两个子数列上,直到各个子数列只有一个元素为止。 这样通过不断的分割和排序,就可以实现整个数列的排序。快速排序的时间复杂度平均情况下为O(nlogn),虽然在最坏情况下会退化为O(n^2),但在实际应用中往往是一种高效的排序算法。
2.快排的适用场景 大规模数据排序:快速排序的平均时间复杂度为O(nlogn),在处理大规模数据时比其他算法如冒泡排序、插入排序更加高效。
内存受限的环境:快速排序是一种就地排序算法,不需要额外的存储空间,这在内存受限的环境(如嵌入式系统)中更有优势。
数据较为随机分布:快速排序的性能最佳情况发生在数据较为随机分布的情况下。如果数据已经基本有序或完全逆序,则会退化为O(n^2)的时间复杂度。
需要频繁排序的场景:由于快速排序的实现相对简单,且不需要额外空间,因此在需要频繁进行排序的场景中更有优势,如动态维护一个有序集合。
并行计算环境:快速排序可以很好地并行化,利用多核处理器可以大幅提高排序效率,在并行计算环境中表现出色。
总的来说,对于大规模、内存受限、数据较为随机分布且需要频繁排序的场景,快速排序通常是一个很好的选择。但对于小规模数据集或数据已经基本有序的情况,其他简单排序算法可能会更加高效。
3.快排的优点 优点:
时间复杂度平均情况下为O(nlogn)，是比较高效的排序算法。算法简单,且可以就地排序,不需要额外的存储空间。相比于归并排序,快速排序的递归调用次数较少。在硬件条件受限的情况下(如嵌入式系统),快速排序的空间复杂度优势更加明显。 4.快排的缺点 缺点:
最坏情况下的时间复杂度为O(n^2),发生在输入数据已经有序或完全逆序的情况。对于小规模数据集,其他简单排序算法如插入排序、冒泡排序效率可能会更高。快速排序是不稳定的排序算法,即相等元素的相对位置可能会改变。算法实现的难度略高于一些其他排序算法,需要掌握分区操作等技巧 二.快速排序的功能 就地排序:快速排序是一种原地排序算法,它不需要额外的存储空间来保存中间结果。这使它在空间利用率方面具有优势,特别适用于内存受限的环境。
时间复杂度:快速排序的平均时间复杂度为O(nlogn),这使它成为高效的排序算法之一。但在最坏情况下,如输入数据已经完全有序或逆序,时间复杂度会退化到O(n^2)。
分治策略:快速排序采用分治的思想,通过不断将数组划分为较小的子数组,然后对子数组进行排序,最终达到整个数组有序的目标。这种递归的方式使算法实现相对简单。
分区操作:快速排序的核心是分区操作。它会选择一个基准元素,将数组划分为两个子数组,一个包含小于基准的元素,另一个包含大于等于基准的元素。这个过程是快速排序的关键。
随机化:为了避免最坏情况下的时间复杂度,快速排序通常会随机选择基准元素。这样可以保证平均情况下的高效性。
并行化:快速排序可以很好地并行化。在分区操作时,左右两个子数组是相互独立的,可以同时进行排序。这在多核处理器环境中可以大幅提高排序效率。
适用范围广泛:快速排序可以排序各种数据类型,如整数、浮点数、字符串等。并且可以根据实际需求定制比较函数,满足不同场景的排序需求。
稳定性:快速排序是一种不稳定的排序算法,即相等元素的相对位置可能会改变。如果需要保持相等元素的相对顺序,可以考虑使用其他稳定的排序算法,如归并排序。
三.快速排序的代码实现 1.变量的交换 swap(int *a, int *b) 函数的实现非常简单,它使用一个临时变量 temp 来交换 a 和 b 的值。这是一种常见的交换两个变量值的方式。
void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } 2.划分元素 partition(int arr[], int low, int high) 函数的核心思想是选择最后一个元素作为基准(pivot),然后将数组划分为两部分:小于基准的元素在左边,大于等于基准的元素在右边。它使用一个指针 i 来记录小于基准的子数组的最后一个位置,然后遍历数组,将小于基准的元素交换到左边。最后,它将基准元素交换到正确的位置,并返回该位置。
int partition(int arr[], int low, int high) { int pivot = arr[high]; // 选择最后一个元素作为基准 int i = (low - 1); // 小于基准的子数组的最后一个位置 for (int j = low; j &lt;= high - 1; j++) { if (arr[j] &lt; pivot) { i++; swap(&amp;arr[i], &amp;arr[j]); } } swap(&amp;arr[i + 1], &amp;arr[high]); return (i + 1); } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf551392f13db424b0a191a155fe61f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24b7e6c5d834cbb14eaa0b5ad71d4bc/" rel="bookmark">
			【C&#43;&#43;】List模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💞💞 前言 hello hello~ ，这里是大耳朵土土垚~💖💖 ，欢迎大家点赞🥳🥳关注💥💥收藏🌹🌹🌹
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：C++入门至进阶
这里将会不定期更新有关C++的内容，希望大家多多点赞关注收藏💖💖
目录 💞💞 前言一、什么是List二、Lits模拟实现2.1 List完整实现代码2.2List框架✨ListNode节点✨List类 2.3尾插尾删2.4迭代器封装✨尾插尾删测试代码✨const迭代器 2.5头插头删✨头插头删测试代码 2.6任意位置插入2.7任意位置删除✨任意位置插入删除测试代码 2.8清空数据2.9析构函数2.10构造函数✨默认构造✨拷贝构造✨initializer_list构造✨测试代码 2.11赋值运算符重载✨赋值运算符重载测试代码 三、结语 一、什么是List C++中的list是一种双向链表（doubly linked list）的实现。它是C++标准库中的一种容器，可以存储一系列元素，并且允许在任意位置插入、删除和访问元素。对于双向链表有疑问的可以点击查看数据结构——带头双向循环链表详解
二、Lits模拟实现 2.1 List完整实现代码 #pragma once using namespace std; #include&lt;iostream&gt; #include&lt;assert.h&gt; namespace tutu { //1.list节点 template&lt;class T&gt; struct ListNode { //默认构造 struct ListNode(const T&amp; val = T()) :_node(val) ,_prev(NULL) ,_next(NULL) { } //成员函数 T _node; ListNode&lt;T&gt;* _prev; ListNode&lt;T&gt;* _next; }; //2.迭代器类 template&lt;class T,class Ref,class Ptr&gt; struct List_Iterator { typedef struct ListNode&lt;T&gt; Node; typedef List_Iterator&lt;T,Ref,Ptr&gt; self; Node* _pnode; //构造函数 List_Iterator(Node* node) :_pnode(node) { } Ref operator*()const { return _pnode-&gt;_node; } Ptr operator-&gt;() const { return &amp;_pnode-&gt;_node; } //前置++ self&amp; operator++() { _pnode = _pnode-&gt;_next; return *this; } //后置++ self&amp; operator++(int) { self tmp(*this); _pnode = _pnode-&gt;_next; return tmp; } //前置-- self&amp; operator--() { _pnode = _pnode-&gt;_prev; return *this; } //后置-- self&amp; operator--(int) { self tmp(*this); _pnode = _pnode-&gt;_prev; return tmp; } bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24b7e6c5d834cbb14eaa0b5ad71d4bc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/321/">«</a>
	<span class="pagination__item pagination__item--current">322/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/323/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>