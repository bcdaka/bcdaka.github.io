<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d9657ca4164242b37fdc719004407b/" rel="bookmark">
			使用Keepalived实现双机热备(虚拟漂移IP地址)详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡作者主页：点击！ 🐧Linux基础知识(初学)：点击！
🐧Linux高级管理防护和群集专栏：点击！
🔐Linux中firewalld防火墙：点击！
⏰️创作时间：2024年7月15日14点40分
🀄️文章质量：95分
目录
——前言——
Keepalived 简介
工作原理
主服务器
备服务器
虚拟(漂移)地址测试
——前言—— 以下内容全是重点 请仔细阅读
以下内容全是重点 请仔细阅读
Keepalived 是一个用于实现高可用性。它主要用于确保服务的连续性，防止单点故障，通常应用于负载均衡和故障转移场景。
Keepalived 简介 Keepalived 是一个基于 VRRP（虚拟路由冗余协议）协议的软件实现。
它可以管理 LVS（Linux Virtual Server）集群系统，也可以单独用于实现服务的高可用。
Keepalived 通过配置虚拟 IP 地址（VIP）来实现服务的故障转移。
它能够监控服务器和服务的状态，在发生故障时自动进行切换。
特别适合需要快速故障转移和负载均衡的网络环境
工作原理 VRRP协议
Keepalived使用VRRP（虚拟路由冗余协议）来实现高可用性。
多台服务器组成一个VRRP组，共享一个虚拟IP地址。
一台服务器作为主服务器，其他为备用服务器。
主服务器定期发送VRRP通告包，如果备用服务器在一定时间内没有收到通告，就会接管虚拟IP。
2.健康检查
Keepalived定期检查本地和远程服务的健康状态。
支持多种检查方式，如TCP、HTTP、SSL等。
如果检测到服务不可用，会触发故障转移。
3.负载均衡：
当与LVS（Linux Virtual Server）结合使用时，Keepalived可以管理LVS的配置。
支持多种负载均衡算法，如轮询、加权轮询、最少连接等。
4.配置管理
通过配置文件定义VRRP实例、虚拟IP、健康检查等参数。
支持动态配置更新，无需重启服务。
5.故障转移
当主服务器失效时，备用服务器会自动接管虚拟IP。
转移过程快速，通常在几秒内完成，对用户几乎无感知。
过这些机制，Keepalived能够有效地提供高可用性和负载均衡服务，确保系统的稳定性和可靠性。
实验环境
主 192.168.192.100 虚拟漂移地址 192.168.192.200
备 192.168.192.111 虚拟漂移地址 192.168.192.200
主服务器 安装所需组件 yum -y install gcc openssl-devel libnfnetlink-devel libnl libnl3-devel yum install -y keepalived ipvsadm 编辑配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72d9657ca4164242b37fdc719004407b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdba70eb6871f67e0a7576b76005d67/" rel="bookmark">
			python pandas处理股票量化数据：笔记1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装python和tushare及相关库 matplotlib
pyplot
pandas
pandas_datareader
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import datetime as dt
&gt;&gt;&gt; import pandas_datareader.data as web
失败的尝试yfinance和pandas_datareader &gt;&gt;&gt; start = dt.datetime(2024, 1, 1)
end = dt.datetime(2024, 6, 1)
&gt;&gt;&gt; stock = web.DataReader('AAPL', 'yahoo', start, end)
&gt;&gt;&gt; stock = web.DataReader('600797.SS', 'yahoo', start, end)
Traceback (most recent call last):
File "&lt;pyshell&gt;", line 1, in &lt;module&gt;
&gt;&gt;&gt; import yfinance as yf
&gt;&gt;&gt; symbol = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bdba70eb6871f67e0a7576b76005d67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153a7656ff1080f1f0634883ceda3be1/" rel="bookmark">
			相交链表&#43;判断环型链表&#43;求环型链表的入口节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表OJ题 一.相交链表二.判断环型链表三.求环型链表的入口节点 一.相交链表 相交链表
相交：两个链表从头开始遍历，尾节点一定是同一个节点。
情况一：当两个链表长度相同时：
情况二：当两个链表长度不同时：
思路：
求两个链表长度的差值gap。让长链表先走gap个节点。分别遍历两个链表，比较是否为同一个节点，若是则相交，否则不相交。 代码如下：
typedef struct ListNode ListNode; struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { ListNode* la = headA; ListNode* lb = headB; int lengthA = 0, lengthB = 0; while(la) { lengthA++;//求链表A的长度 la = la-&gt;next; } while(lb) { lengthB++;//求链表B的长度 lb = lb-&gt;next; } //求链表A与链表B长度差的绝对值 int gap = abs(lengthA - lengthB); //找出长链表与短链表 ListNode* longList = headA; ListNode* shortList = headB; if(lengthB &gt; lengthA) { longList = headB; shortList = headA; } //让长链表先走gap个节点 while(gap--) { longList = longList-&gt;next; } //此时longList与shortList指针在相对的位置上（同时遍历链表为NULL） //判断两个链表是否相交 while(longList &amp;&amp; shortList) { if(longList == shortList) { //链表相交 return longList; } //两个指针继续往后走 longList = longList-&gt;next; shortList = shortList-&gt;next; } //链表不相交 return NULL; } 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/153a7656ff1080f1f0634883ceda3be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a0009f5f707f653f320a92426d57ad/" rel="bookmark">
			ASP.NET Core----基础学习08----MVC中的属性路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1.MVC 中属性路由2.如果控制器名称与路由的第一级名称不一致3.指定读取的视图文件4.指定路由的一级 &amp; 二级目录 1.MVC 中属性路由 step1： 在Startup.cs文件中设置仅使用UseMvc（不包含路由的设置）
step2： 在控制器中设置路由的属性：
step3： 最终可以通过如下地址分别访问到index &amp; Privacy 方法：
http://localhost:5188/
http://localhost:5188/home
http://localhost:5188/home/index
http://localhost:5188/home/privacy
2.如果控制器名称与路由的第一级名称不一致 再次通过路由的路径去访问网页，最终也无法找到函数。因为网页会先去寻找控制器（目前控制器 叫WelcomeController），则先找这个控制器下面的路由（第一级路由为welcome）。而~/home/index 是HomeController这个控制器才会去找这个路由。 3.指定读取的视图文件 如上情况控制器因为没找到对应的视图文件，最终导致页面没发渲染。可以在action中指定哪个视图文件即可正常显示页面。
4.指定路由的一级 &amp; 二级目录 [Route(“[controller]”)] 由控制器的名称代表路由的一级名称[Route(“[action]”)] 由action的名称代表路由的二级名称 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa63cab4f5b5dcc60656296d0564b0d5/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
61、pandas.to_numeric函数
61-1、语法
61-2、参数
61-3、功能
61-4、返回值
61-5、说明
61-6、用法
61-6-1、数据准备
61-6-2、代码示例
61-6-3、结果输出
62、pandas.to_datetime函数
62-1、语法
62-2、参数
62-3、功能
62-4、返回值
62-5、说明
62-6、用法
62-6-1、数据准备
62-6-2、代码示例
62-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 61、pandas.to_numeric函数 61-1、语法 # 61、pandas.to_numeric函数 pandas.to_numeric(arg, errors='raise', downcast=None, dtype_backend=_NoDefault.no_default) Convert argument to a numeric type. The default return dtype is float64 or int64 depending on the data supplied. Use the downcast parameter to obtain other dtypes. Please note that precision loss may occur if really large numbers are passed in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa63cab4f5b5dcc60656296d0564b0d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5acf9a6c74b8df1d5635076515acd01/" rel="bookmark">
			大数据核心面试题（Hadoop，Spark，YARN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据核心面试题（Hadoop，Spark，YARN） 高频面试题及答案1. 什么是Hadoop？它的核心组件有哪些？2. 解释HDFS的架构及其工作原理。3. HDFS如何保证数据的高可用性和容错性？4. 什么是NameNode和DataNode？它们的区别是什么？5. 解释MapReduce编程模型及其主要组成部分。6. HDFS的读写流程是怎样的？7. 什么是Secondary NameNode？它的作用是什么？8. 如何处理NameNode的单点故障问题？9. 什么是Hadoop的块（Block）？为什么要使用块？10. HDFS中的数据块大小可以配置吗？如果可以，如何配置？11. 什么是Apache Spark？它有哪些核心组件？12. 什么是RDD（Resilient Distributed Dataset）？其特性有哪些？13. Spark的执行模型是怎样的？14. 解释Spark SQL和DataFrame的概念。15. 什么是Spark Streaming？它是如何处理流数据的？16. 什么是宽依赖和窄依赖？举例说明。17. 什么是Spark的持久化（Persistence）机制？18. 解释Spark中的Shuffle操作及其优化方法。19. 什么是广播变量和累加器？它们的作用是什么？20. 如何在YARN上运行Spark应用程序？21. 什么是YARN？它的主要组件有哪些？22. YARN的架构是怎样的？23. ResourceManager的主要功能是什么？24. NodeManager的作用是什么？25. ApplicationMaster的职责是什么？26. 什么是YARN的Container？其作用是什么？27. YARN的资源调度策略有哪些？28. YARN如何进行资源管理和作业调度？29. 如何在YARN上运行一个Hadoop作业？30. YARN如何处理应用程序的失败和容错？ 高频面试题及答案 1. 什么是Hadoop？它的核心组件有哪些？ 回答：
Hadoop是一个用于存储和处理大规模数据集的开源框架。它的核心组件包括：
HDFS（Hadoop Distributed File System）： 用于分布式存储数据。MapReduce： 用于分布式数据处理的计算框架。YARN（Yet Another Resource Negotiator）： 用于资源管理和作业调度。 2. 解释HDFS的架构及其工作原理。 回答：
HDFS是一个主从架构，由NameNode和DataNode组成：
NameNode： 管理元数据，如文件名、块位置等。DataNode： 存储实际的数据块。
工作原理：数据存储： 文件被分割成块（默认128MB），每个块被复制到多个DataNode上（默认3个副本）。数据读取： 客户端通过NameNode获取数据块的位置信息，然后直接从DataNode读取数据。 3. HDFS如何保证数据的高可用性和容错性？ 回答：
HDFS通过数据块的复制机制来保证高可用性和容错性。每个数据块会被复制到多个（默认3个）不同的DataNode上，以确保即使某些节点发生故障，数据仍然可以从其他副本中获取。
4. 什么是NameNode和DataNode？它们的区别是什么？ 回答：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5acf9a6c74b8df1d5635076515acd01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc96ea92ce8cd2fe4da61ca532c1a45/" rel="bookmark">
			Spark核心技术架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Spark是一个开源的分布式计算系统，它提供了一个快速、通用和易于使用的集群计算环境。Spark 支持多种编程语言，如 Scala、Java 和 Python，并针对大规模数据处理进行了优化。以下是 Spark 技术架构的详细简述：
1. 核心组件 Spark Core: Spark 的核心库，提供了基本的分布式数据集操作，如 map、reduce、filter 等。Spark SQL: 提供了对结构化和半结构化数据的处理能力，支持 SQL 查询和各种数据源的连接。DataFrames and Datasets: 抽象的数据模型，DataFrame 是分布式数据集，Dataset 是类型化的数据集合，提供了强类型和编译时类型检查。Spark Streaming: 支持实时数据流处理，可以处理来自 Kafka、Flume、Kinesis 等源的数据流。MLlib: Spark 的机器学习库，提供了常见的机器学习算法和工具。GraphX: 图处理库，用于处理图结构数据和执行图计算。 2. 集群管理器 Spark 可以与多种集群管理器集成，以支持分布式计算：
Standalone: Spark 自带的简单集群管理器。Hadoop YARN: 支持在 Hadoop 集群上运行 Spark。Apache Mesos: 一个集群管理器，可以同时运行多个框架，包括 Spark。Kubernetes: 现代的容器编排系统，Spark 可以作为 Pod 运行在 Kubernetes 上。 3. 数据抽象 RDD（Resilient Distributed Dataset）: 弹性分布式数据集，是 Spark 的基础数据结构，提供了不可变的、分布式的数据集合。DAG（Directed Acyclic Graph）: 任务调度模型，Spark 将作业转换为 DAG，然后根据依赖关系进行优化。 4. 执行引擎 Task Scheduling: 任务调度器负责将作业分解为多个任务，并根据资源情况分配给不同的节点执行。In-Memory Computing: Spark 的内存计算能力，允许数据在内存中进行迭代计算，大大提高了处理速度。Caching: 数据缓存机制，可以将经常访问的数据集缓存到内存中，避免重复的 I/O 操作。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc96ea92ce8cd2fe4da61ca532c1a45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c81d8b62acc803503b6be2aef117459/" rel="bookmark">
			C&#43;&#43; 类和对象 赋值运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在上文我们知道数据类型分为自定义类型和内置类型，当我想用内置类型比较大小是非常容易的但是在C++中成员变量都是在类(自定义类型)里面的，那我想给类比较大小那该怎么办呢？这时候运算符重载就出现了
一 运算符重载概念： 允许用户为自定义类定义或重新定义运算符的行为，使这些类在使用运算符时表现得像内置数据类型一样，从而提高代码的可读性和简洁性。
1.2 运算符重载与函数重载的区别： 我第一次听到这两个重载都傻傻的分不清楚，以为是一个意思。其实他们的区别可大了
函数重载：
函数重载是指在同一作用域中有多个同名函数，但它们的参数列表（参数的类型和数量）不同。编译器通过参数列表来决定调用哪个函数。函数重载的目的是为了提高代码的可读性和灵活性，使同一操作可以应用于不同类型的参数。
运算符重载：
运算符重载允许我们为用户定义的类型（如类）定义或重新定义特定运算符（如 +、-、*、/ 等）的行为。运算符重载函数的名称为 operator 后跟运算符符号。尽管这些函数的返回类型和参数列表与普通函数类似，但它们的目的是使自定义类型能够使用像内置类型一样的运算符。
1.3 运算符特点： 1 定义运算符重载函数：运算符重载是通过定义特殊的成员函数或全局函数来实现的
2 运算符重载函数的返回类型：通常是运算符操作后的结果类型。
3 运算符重载函数的参数：根据运算符的类型，参数可以是一个或多个。
4 * :: sizeof ?: . 注意以上5个运算符不能重载
3.1 代码解析： 运算符重载成员函数代码示例：
//成员函数 运算符重载 class Date { public: int _x = 5; int _y = 4; int operator+(const Date&amp; b) { return this-&gt;_x + b._x + this-&gt;_y + b._y; } //错误写法 //int operator+(const Date&amp; a ， const Date&amp; b) /*{ return a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c81d8b62acc803503b6be2aef117459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b633e691385c6789bb0eb54015b071f/" rel="bookmark">
			【详解】Spring Cloud概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥 个人主页：Dikz12🔥个人专栏：Spring学习之路📕格言：吾愚多不敏，而愿加学欢迎大家👍点赞✍评论⭐收藏 目录
1. 认识微服务
1.1 单体架构
1.2 集群和分布式架构 1.3 集群和分布式
1.4 微服务架构 2. 什么是Spring Cloud？
2.1 Spring Cloud和Spring Boot的关系
2.2 Spring Cloud实现方案
总体内容方向：
什么是微服务？什么是Spring Cloud ? 1. 认识微服务 下图表示服务架构从单体单体应⽤逐渐转变为微服务应⽤的过程. 1.1 单体架构 很多创业公司早期或者传统企业会把业务的所有功能实现都打包在⼀个项⽬,这就是单体架构.
这种架构开发简单,部署简单,⼀个项⽬就包含了所有的功能,省去了多个项⽬之间的交互和调⽤消耗.直接部署在⼀个服务器即可.
1.2 集群和分布式架构 当网站的的用户量越来越大，需求量越来越多，请求量越来越大，服务器可能就会⾯临以下问题:
后端服务器的压⼒就会越来越⼤，负载越来越⾼，甚⾄出现⽆法访问的情况业务场景逐渐复杂. 为了满⾜⽤⼾的需求，单体应⽤也会越来越⼤.各个业务代码之间的耦合度也会越来越⾼.任何⼀个问题,都需要整个项⽬重新构建,发布.⼀个微⼩的问题,可能会导致整个应⽤挂掉. 可以从两个方面进行优化：
横向：添加服务器,把单台机器变成多台机器的集群.纵向：把一个系统，根据业务进行拆分，拆分成多个项目.此架构也称为垂直架构. 1.3 集群和分布式 集群(cluster)是将⼀个系统完整的部署到多个服务器上，每个服务器都能提供系统的所有服务，多个服务器通过负载均衡调度完成任务. 每个服务器称为集群的节点(node)。 (不同的服务器，功能相同).
分布式是将⼀个系统拆分为多个⼦系统，多个⼦系统部署在多个服务器上，多个服务器上的⼦系统
协同合作完成⼀个特定任务. (不同的服务器，共同完成一个工作）
比如： 刚成立的一个餐馆，只有一个厨师，这个厨师负责做饭相关的所有工作.(备菜,洗菜,切菜,炒菜)。随着这个饭店的⽣意越来越好,这个厨师忙不过来了. 出现问题就要解决问题.
横向：在招聘一个厨师，这两个厨师都是可以独立做饭的.。这两个厨师的关系就是集群.纵向：招聘一个配菜师，负责备菜，洗菜，切菜。 厨师和配菜师的关系就是分布式. 在后来⼀个配菜师也忙不过来了, ⼜请了⼀个配菜师, 这两个配菜师的关系就是集群.
集群和分布式区别和联系
从概念上.集群是多个计算机做同样的事，分布式是多个计算机做不同的事.从功能上.集群的每⼀个节点功能是相同的，并且可以替代的.分布式也是多个节点组成的系统,但是每个节点完成的业务是不同的，⼀个节点出现问题，这个业务就不可访问了.从关系上.分布式和集群在实践中，很多时候是互相配合使⽤的.分布式架构⼤多是建⽴在集群上的.所以实际的分布式架构设计中并不会把分布式和集群单独区分，⽽是统称:分布式架构. 1.4 微服务架构 在分布式架构下，当部署的服务越来越多，重复的代码就会越来越多，服务的调⽤关系也会越来越复杂.我们可以把⼀些通⽤的，会被多个上层服务调⽤的共享业务，提取成独⽴的基础务，组成⼀个个微⼩的服务。这就是微服务.
简单来说,微服务就是很⼩的服务.⼩到⼀个服务只对应⼀个单⼀的功能,只做⼀件事.这个服务可以单独部署运⾏。
微服务之间可以采⽤REST和RPC协议进⾏通信.
从这个⻆度来看,微服务架构是分布式架构的⼀种拓展,这种架构模式下它拆分粒度更⼩,服务更独⽴.可以理解为:微服务是⼀种经过良好架构设计的分布式架构⽅案.
分布式:服务拆分,拆了就⾏.
微服务: 不仅拆分，还拆分的很细，通常指不能再拆的服务.
优势
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b633e691385c6789bb0eb54015b071f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6857b83f6420bccb288c92b704edd8/" rel="bookmark">
			【C语言初阶】探索编程基础：深入理解分支与循环语句的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C语言 “ 登神长阶 ”
🤡往期回顾🤡：C语言入门
🌹🌹期待您的关注 🌹🌹
❀分支与循环语句 📒1. 什么是语句?📜2. 分支语句🔄if 语句🍁else 的匹配🍂if 书写形式 💬switch 语句🎩switch中 break🎈default子句 📚3. 循环语句🧩while 循环🌞while中 break🌙while中 continue 🧩for 循环⛰️break和continue在for循环中🏞️for语句的循环控制变量🌄for循环和while循环 🧩do while 循环🌄do while循环中的break和continue 📝4. goto语句📖5. 总结 前言： 在编程的世界里，构建程序的基石不仅仅是数据的表示与处理，更在于如何根据条件做出选择，以及如何重复执行特定的代码块以完成任务。这正是分支语句（如if-else、switch等）和循环语句（如for、while、do-while等）大放异彩的舞台。它们如同编程语言的导航员和动力源泉，引领着代码逻辑在复杂的任务中穿梭前行，实现高效、灵活的程序逻辑控制
分支语句： 让我们能够基于不同的条件执行不同的代码块，它们如同决策树上的分叉，每个分叉都代表了一个可能的路径，根据条件判断的结果选择最合适的路径继续执行。这种能力使得程序能够根据用户输入、系统状态或计算结果等外部条件灵活地调整其行为，从而应对各种复杂多变的场景
循环语句： 是重复执行某段代码的强大工具。无论是需要遍历数组、处理大量数据、还是执行周期性任务，循环语句都能以简洁高效的方式完成任务。它们通过设定循环条件和循环体，使得程序能够在满足条件的情况下不断重复执行特定的操作，直至条件不再满足为止。这种能力极大地提高了程序的自动化程度和执行效率
因此，掌握分支和循环语句是成为一名合格程序员不可或缺的一步 。它们不仅是构建程序逻辑的基本单元，更是实现复杂功能和优化程序性能的关键所在。在接下来的内容中，我们将深入探讨这两种语句的工作原理、语法规则以及实际应用场景，帮助大家更好地理解并灵活运用它们来编写高效、可靠的程序代码
让我们一同踏上这段充满挑战与收获的C语言分支与循环语句之旅吧！
📒1. 什么是语句? C语句可分为以下五类：
表达式语句函数调用语句控制语句复合语句空语句 我们今天介绍的是控制语句：
控制语句用于控制程序的执行流程，以实现程序的各种结构方式（C语言支持三种结构：顺序结构、选择结构、循环结构），它们由特定的语句定义符组成
控制语句可分为以下三类：
条件判断语句也叫分支语句：if语句、switch语句；循环执行语句：do while语句、while语句、for语句；转向语句：break语句、goto语句、continue语句、return语句 📜2. 分支语句 分支语句（Branch Statements）在编程中扮演着至关重要的角色，它们允许程序根据特定的条件执行不同的代码块。这种能力使得程序能够处理不同的输入、状态或计算结果，从而以灵活和动态的方式响应各种情况
我们在前两节入门时简单提到过
🔄if 语句 if 语句代码示例：
// 语法结构： if(表达式) 语句1; else 语句2; //多分支 if(表达式1) 语句1; else if(表达式2) 语句2; else 语句3; 在 if 语句中，我们规定如果表达式的结果为真，则语句执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6857b83f6420bccb288c92b704edd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f710e3056da08941138cd282b4990f9/" rel="bookmark">
			Datawhale AI夏令营- 讯飞机器翻译挑战赛baseline解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讯飞机器翻译挑战赛题 赛题数据分析NLP前置知识GRUSeq2SeqEncoder编码器Decoder解码器 数据处理思路数据清洗构建数据集类型TranslateDataset 模型搭建和训练基于seq2seq 的模型基于transformer的模型训练代码 基于BLUE4的评估指标BLEU4 的计算步骤：举个例子：1. 分词：2. 计算n-gram匹配：3. 计算精确度：4. 计算加权几何平均：5. 计算惩罚因子BP：6. 计算最终的BLEU4分数： 实现代码 推理参考 赛题数据分析 在官方提供的数据集中,我们可以了解到:训练集又14w条数据,同时官方也提供了一个测试集给我们用来模型评估。同时还提供了一个术语词典,作为一些特殊词语的翻译对照表。
了解到这些信息后,我们可以下载这些数据看看这些数据怎样的。
我们打开训练集train.txt后发现,英文和中文通过制表符\t来分割,我们后续就可以每一行读取,然后通过\t划分来拿到中文数据和英文数据。这些后续会在数据处理部分说明
NLP前置知识 本次baseline用的是seq2seq的模型, 然后Encode和decode部分使用的是GRU模型。下面我将一一讲解这两种模型
GRU 在讲GRU之前,需要先补充一下RNN是什么。如下图:
RNN模型在每个时间步接收一个字的输入，生成隐藏状态和输出，再将隐藏状态与下一个字输入到模型中，重复此过程。
GRU（门控循环单元）是RNN的变体，能够有效捕捉长序列语义关联，缓解梯度消失或爆炸现象，其核心结构由更新门和重置门两部分组成。
如果看不懂的话,可以直接理解为GRU的输入,输出都和RNN是一致的,但是比RNN更加厉害。
Seq2Seq 结构图如下:
Seq2Seq由两个结构组成,分别是Encoder和Decoder块
Seq2Seq模型由两个主要部分组成：Encoder（编码器）和Decoder（解码器），两者均为GRU网络。以下是该模型的详细介绍：
Encoder编码器 输入序列：模型接收输入序列 x = [ x 1 , x 2 , x 3 , x 4 ] x = [x_1, x_2, x_3, x_4] x=[x1​,x2​,x3​,x4​]。GRU网络：输入序列逐步传递给GRU单元，每个输入 x i x_i xi​ 生成相应的隐藏状态 h i h_i hi​。 第一个GRU单元接收 x 1 x_1 x1​，生成隐藏状态 h 1 h_1 h1​。第二个GRU单元接收 x 2 x_2 x2​和 h 1 h_1 h1​，生成隐藏状态 h 2 h_2 h2​。如此反复，直到最后一个输入 x 4 x_4 x4​ 生成隐藏状态 h 4 h_4 h4​。 上下文向量：最后一个隐藏状态 h 4 h_4 h4​ 作为上下文向量 c c c，用于解码阶段。 Decoder解码器 初始状态：解码器的初始隐藏状态由编码器生成的上下文向量 c c c 初始化。GRU网络：解码器逐步生成输出序列 y = [ y 1 , y 2 , y 3 , y 4 ] y = [y_1, y_2, y_3, y_4] y=[y1​,y2​,y3​,y4​]。 解码器的第一个GRU单元接收上下文向量 c c c 和初始隐藏状态，生成第一个隐藏状态 h 1 ′ h'_1 h1′​和输出 y 1 y_1 y1​。第二个GRU单元接收第一个隐藏状态 h 1 ′ h'_1 h1′​，生成第二个隐藏状态 h 2 ′ h'_2 h2′​ 和输出 y 2 y_2 y2​。如此反复，直到生成最后一个隐藏状态 h 4 ′ h'_4 h4′​和输出 y 4 y_4 y4​。 过程描述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f710e3056da08941138cd282b4990f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2a86398635580a1f92cd9f6f362eb3d/" rel="bookmark">
			【C&#43;&#43;&amp;Python&amp;Java】字符处理详细解读_字符_ASCLL码_字母数字转换_算法竞赛_开发语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Beginning1）ASCLL 码2）大小比较2）判断数字字符3）字符、数字间的相互转换End Beginning 在 C++ 中，字符和整数有着密不可分的关系。原因就是在计算机中，字符是以一种较 ASCLL 码的整数存储的。自然，在算法竞赛或一些应用场景中，字符和整数之间的相互转换也成为一种华丽且简便的技巧。
但一旦使用不好这些技巧，就可能导致程序出现漏洞，出现运行问题。所以，本文将介绍一些基本的字符和整数之间的转换用法。望大家多多指教。
1）ASCLL 码 百度百科 上的解释：ASCII (American Standard Code for Information Interchange)：美国信息交换标准代码是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。
以下是可显示字符的 ASCLL 码表：
以下是 ASCLL 控制字符表：
在 C++ 语言中，可以通过强制类型转换来获取字符的 ASCLL 码：
cout &lt;&lt; int('A'); // 输出65 cout &lt;&lt; int(' '); // 输出32 注意：在使用 cout 时，一定要加强制类型转换，即 int(…)。不然会以整数输出；scanf 和 printf 因为有固定的类型占位符，反而没有这和问题。
在 Python 中，可以用 ord() 函数获取字符的 ASCLL 码值：
print(ord('a')) # 输出97 print(ord('+')) # 输出43 在 Java中，可以用整数 Integer 类的 valueOf() 函数进行获取：
System.out.println(Integer.valueOf('q')); // 输出113 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2a86398635580a1f92cd9f6f362eb3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2469ca7480a6d498fecf6b539aa43f10/" rel="bookmark">
			转型Web3开发第二课：Dapp开发入门基础 | 01 | 安装MetaMask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 完成了《转型 Web3 开发第一课》之后，得到了不少读者的认可，很多都在问什么时候开始下一课，近期终于抽出了时间开始搞起这第二课。
这第二课的主题为「Dapp开发入门基础」，即想要转型做 Dapp 开发的人员，不管是做前端开发、后端开发、智能合约开发，都需要掌握的基础知识。这部分知识，我将其分为四个模块：MetaMask、区块浏览器、以太坊基础、Dapp全栈架构，如下图所示：
昨天一口气录制了 6 个小节的视频，已经上传到了 B 站，大家可以到 B 站搜索【Keegan小钢】找到这第二课的视频进行观看学习。
也可以观看我的视频，以下是这第一小节的视频：
https://www.bilibili.com/video/BV1bE4m1R7QG/?spm_id_from=333.999.0.0
之后我会陆续录制完其他小节的视频并上传，以及同步到其他平台，图文版也会陆续更新。
下面，我们开始第一小节的图文版内容。
安装 MetaMask MetaMask 插件钱包是所有做 Dapp 开发的人都需要安装的第一个钱包，开发、测试等都需要用到它。
目前支持 MetaMask 插件钱包的浏览器还比较有限，只支持 Chrome、Firefox、Brave、Edge 和 Opera。
所以，想要安装 MetaMask 插件钱包之前，先确保你的电脑里已经至少有这几个浏览器之一。
有了支持的浏览器之后，就可以从浏览器的应用商店里搜索出 MetaMask，如下：
下一步就是点击右上角的按钮，把它添加到浏览器中。添加成功后，会自动弹出 MetaMask 的开始页面，如下所示：
下一步，勾选“I agree to MetaMask’s Terms of use"，点击”Create a new wallet"按钮就可以开始创建一个新钱包了。
之后，会让你创建密码，这个密码只是用于解锁当前设备上的 MetaMask 钱包的，类似于解锁手机屏幕的屏保密码，如下所示：
接着，会告诉你如何保护你的钱包，如下所示：
点击 “Secure my wallet”，进入下一步，之后可以看到由 12 个单词组成的助记词，如下所示：
如果把钱包比喻为保险箱，那这套助记词就是开保险箱的钥匙。如果助记词丢失被盗了，那你钱包里的资产通常也会被盗走。所以一定要安全保存好这套助记词，最好是线下存储，不要将其存在云端，也不要进行网络传输。
下一步会要求你补全缺失的几个单词，确认你已经保存了这一套助记词。
安装完成之后，会自动创建出一个钱包账户，如下：
最后一步，为了平时更方便使用，可以把 MetaMask 钉到浏览器导航栏里，如下图：
钉到导航栏之后，就可以直接点击导航栏里的小狐狸小图标来打开钱包，非常方便。
以上，我们就完成了 MetaMask 的安装和启用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce181514ed0c7b36c63e79b712f7b9bd/" rel="bookmark">
			SQL Server设置定时作业调度Schedule
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SQL Server代理 SQL Server代理 SQL Server提供了一种称为SQL Server代理的功能，可以用来设置定时作业。以下是在SQL Server中设置定时作业的步骤：
打开SQL Server Management Studio（SSMS）。 连接到要设置定时作业的数据库实例。
在对象资源管理器中，展开“SQL Server代理”文件夹。
右键单击“作业”文件夹，然后选择“新建作业”。
在“作业属性”对话框中，输入作业的名称和描述。
在“步骤”选项卡中，单击“新建”按钮，然后输入步骤的名称和描述。
在“命令”文本框中，输入要定期执行的SQL语句或命令。
在“计划”选项卡中，单击“新建”按钮来创建一个新的计划。
设置每天早上八点执行这个定时任务。
在“计划”对话框中，选择要定期运行作业的时间和频率。确认并保存所做的更改。 现在，您已经成功设置了一个定时作业。SQL Server代理将在指定的时间和频率下运行作业，并执行您定义的SQL语句或命令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cae761383e4d49e9567127e43a36fde/" rel="bookmark">
			C语言之带环链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		带环链表是数据结构链表中的一个经典问题，这里我们研究该问题分为两个方向：链表是否带环、返回链表的入环节点。
下面我们通过两个题目来分析带环链表：
1.判断链表是否带环 141. 环形链表 - 力扣（LeetCode）
那么我们要怎么判断一个链表是否带环呢？
这里我们直接给出答案：借助快慢指针来判断链表是否带环。
我们创建两个指针变量slow和fast，slow一次走一步，fast一次走两步，如果链表带环，那么fast就会先进入环，当slow也进入环之后，它们就开始了追击，因为fast走得比slow快，所以fast和slow一定会相遇，如果fast和slow相遇了，就证明了该链表是带环链表；如果fast走到了NULL，那么就说明该链表是不带环的。
分析图如下：
这个逻辑还是很简单的，该操作的代码也很简单，这里直接给出：
bool hasCycle(struct ListNode *head) { struct ListNode* fast = head; struct ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) { return true; } } return false; } 到这里了就有问题了，那这样子写的原理是什么呢？我们借助图来解释一下：
到这里，问题就解决了么？其实还没有，fast走2步可以，那么fast走3步，4步，n步可不可以呢？ 下面我们来研究一下fast走3步的情况：
1.1fast走3步 我们借助图来分析：
我们看到，如果C-1是奇数的话，他就会陷入循环中，每一次都追不上，且每一次的距离都是C-1。那么fast走4步和走n步都是同样的分析道理，大家感兴趣的话可以自己推一下。 我们现在就要问了，fast走三步真的追不上么？
1.2fast走三步到底追不追得上？ 我们在上面说当N是奇数且C-1是奇数的时候就追不上，那么事实是这样的么？我们继续分析一下。我们假设进环前的路程为L，所以slow走的路程就是L，fast走的路程是L+x*C+N。x表示fast在环中走的圈数，因为在slow进环之前，fast可能已经在环中走了好几圈了。N表示slow刚入环时，fast和slow的距离。
然后又因为fast一次走三步，slow一次走一步，所以fast走的路程是slow路程的三倍。所以有等式：3L = L+x*C+N。化简得：2L = x*C+N。
综上所述，当fast一次走三步时，不管slow刚进入环时，fast和slow的距离N是奇数还是偶数，都会追上。偶数会在第一次追击就追上；奇数则会在第二次追击追上。 2.返回带环链表的第一个入环节点 142. 环形链表 II - 力扣（LeetCode）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cae761383e4d49e9567127e43a36fde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ae72535a11c40e4d5eae4c93097c683/" rel="bookmark">
			【C&#43;&#43;】构造函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢博客主页：https://blog.csdn.net/2301_779549673
📢欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！
📢本文由 JohnKi 原创，首发于 CSDN🙉
📢未来很长，值得我们全力奔赴更美好的生活✨
文章目录 📢前言🏳️‍🌈 什么是构造函数🏳️‍🌈 构造函数的特点❤️1. 函数名与类名相同🧡2. 无返回值。💛3. 对象实例化时系统会自动调用对应的构造函数。💚4. 构造函数应写尽写 👥总结 📢前言 本篇博客主要介绍一下C++中的构造函数及拷贝构造函数的特性及用法，至于与这一部分有关的析构函数及运算符重载等内容就放在下次。
🏳️‍🌈 什么是构造函数 构造函数是特殊的成员函数，构造函数千万不要认为它是用来创建对象的，其实构造函数的主要任务并不是开空间创建对象，而是初始化对象。
关于构造函数，可以理解为使用类实例化对象时，每一个对象都要进行初始化，都要进行调用初始化函数，这个操作是实例化对象的必要操作，那么有没有更好的方式来简化这个调用操作。于是C++便推出了构造函数
🏳️‍🌈 构造函数的特点 ❤️1. 函数名与类名相同 顾名思义你类名取什么，函数名就是什么
就比如下面这样就是一种最基本的无参构造函数，它的函数名就是类名
#include&lt;iostream&gt; using namespace std; class Date { public: //⽆参构造函数 //可以认为是默认构造 Date() { _year = 1; _month = 1; _day = 1; } private: int _year; int _month; int _day; }; 🧡2. 无返回值。 返回值啥都不需要给，也不需要写void，不要纠结，C++规定如此，可以理解为可自定义的内置初始化函数，仅用来初始化
比如说下面这就是一个带参数的构造函数
// 带参构造函数 Date(int year, int month, int day) { _year = year; _month = month; _day = day; } 💛3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ae72535a11c40e4d5eae4c93097c683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b130be9a9bd338fb5fad2c0ff8317a4e/" rel="bookmark">
			图像边缘检测中Sobel算子的原理,并附OpenCV和Matlab的示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sobel算子是一种用于图像边缘检测的离散微分算子。它结合了图像的平滑处理和微分计算，旨在强调图像中强度变化显著的区域，即边缘。Sobel算子在图像处理中被广泛使用，特别是在计算机视觉和图像分析领域。
Sobel算子的原理
Sobel算子主要用于计算图像的梯度。它使用两个3x3的卷积核（或称滤波器），分别对水平方向和垂直方向的梯度进行估计。
水平方向的Sobel核（Gx）：
-1 0 1
-2 0 2
-1 0 1
垂直方向的Sobel核（Gy）：
1 2 1
0 0 0
-1 -2 -1
这两个卷积核分别与图像进行卷积运算，计算出每个像素在水平方向和垂直方向上的梯度近似值。
计算步骤
1 卷积运算：
使用Gx核对图像进行卷积，得到水平梯度图像Gx。
使用Gy核对图像进行卷积，得到垂直梯度图像Gy。
2 梯度幅值计算：
对于每个像素，计算其梯度幅值：
梯度方向计算：
对于每个像素，计算其梯度方向：
作用
Sobel算子通过计算梯度的幅值，可以突出图像中灰度变化较大的部分，即边缘。梯度的方向则可以用来描述边缘的方向信息。
优点和缺点
优点：
计算简单，速度快。
能有效地检测出边缘，并对噪声有一定的平滑作用。
缺点：
对斜边缘的检测效果不如对水平和垂直边缘的检测效果好。
对高频噪声较敏感，尽管比单纯的差分算子要好一些。
应用
Sobel算子广泛应用于边缘检测、图像分割、目标检测等领域，是计算机视觉和图像处理中的基础算法之一。通过结合其他方法，Sobel算子可以实现更加复杂和高级的图像分析任务。
下面是一个使用OpenCV的C++示例，演示如何使用Sobel算子进行边缘检测。
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; int main() { // 读取图像 cv::Mat src = cv::imread("path_to_your_image.jpg", cv::IMREAD_GRAYSCALE); if (src.empty()) { std::cerr &lt;&lt; "Error: Could not open or find the image!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b130be9a9bd338fb5fad2c0ff8317a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2606d111d1df77d410d4474b9f8a29/" rel="bookmark">
			机器学习-1：人工智能、机器学习和深度学习的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能（AI） 简单理解，任何一种事物只要具备了一定的智能就可以把它归类为人工智能。
官方定义："AI is the field that sdudies the synthesis and analysis of computational agents that act intelligently."
其中，“computational agents”指用来计算的机器；“act intelligently”机器可以聪明、智慧地去行动。
即：AI是一个研究分析具有一定智能的机器的领域，该机器可以聪明的做一些事情。
其他维度：“AI are systems that Think like humans, Think rationally, Act like humans, Act rationally.”
从四个维度定义，首先AI是一个系统，这个系统可以像人类一样思考，具有一定理性思考能力（理性是机器的特长），像人类一样做一些智能行为并做一些事情，理性行动。
如果发现一个系统符合者四个标准，就可以认为该系统为AI系统。
AI领域分为两大类：限制领域AI（Narrow AI）和通用AI（General AI）。限制领域AI指某一个特定场景下的AI，关注的问题都是某一个特定场景下的某一类特定问题，如广告推荐系统、园区导航系统、医疗智能问答等；通用AI指让AI做任何事情，类似人类一样，做各种各样的思考，完成各种事情。
目前的AI系统不足以让AI完成各种事情，AI能解决的问题一定是限制在某个领域的，且几十年内很难见到通用AI，所以现阶段主要关注限制领域AI。
所以当提出一个解决方案的时候，把注意力放在限制领域AI上；在实际项目中，要把问题范围定义好认清技术的边界，做好范围管理，严格杜绝范围蔓延和项目镀金等行为。
机器学习 机器学习是解决人工智能问题的关键的、最核心的技术，比如推荐系统、无人驾驶、人脸识别等应用都要依赖机器学习技术。
“机器学习”即我们希望让机器像人了一样拥有一些自主学习的能力。例如：给小孩儿讲这是一只小猫，他会从大脑中自动刻画小猫的样子（具体刻画了哪些，都不得而知），自动学出一个规律并记录下来，下次再看到小猫时就能准确的识别出来。我们希望机器也能像人类学习的过程一样，具有这种能力。
官方定义：“Field of study that gives computers the ablility to learn without being explicitly programmed.”
其中，关键是在不需要做任何特定编程情况下，有能力去学习。即希望给机器一种能力，就是不需要特定编程的情况下自己学习的能力，且这种能力（比如识别出苹果）不是我告诉机器的，是机器自己学习到的。
机器学习的核心是，从数据中自动学出规律，而不是一个人拍脑袋想出来的，可以简单理解为归纳总结，而且有时候通过机器归纳出来的规律可能很多是我们之前都没有想到的。
机器学习典型流程：将训练数据输入给机器学习模型，模型可以得出一个算法，识别出物体的特性，模型学习完成后这个模型可以识别测试数据，给出某个分类的概率。
深度学习 官方定义：“Deep Learning is a subfield of machine learning concerned with algorithms inspired by the structure and function of the brain called artificial neural networks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac2606d111d1df77d410d4474b9f8a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5863c20f7c8d86956911d85277b8a9/" rel="bookmark">
			Richtek立锜科技可用于智能门铃的电源管理解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新型的智能门铃不仅能满足呼叫、提醒的需要，还能在线监控、远程操作、闯入通知、记录过程，系统构成相对复杂，与传统门铃相比有了很大的改变。
从电源管理的角度来观察，满足这样需求的系统构成也相对复杂：
处于外置状态的门铃通常需要大容量电池为之供电，但充电时间又必须要短，使用大电流充电是不可避免的，RT9471 可使用 5V、12V 的输入以 3A 电流对锂离子电池进行充电，若需 5A 充电时可选 RT9466、RT9467。当系统需要随时了解电池状况时可使用以电池电压为基础构建的电池电量计 RT9426A，其对电池荷电状态和健康状态的把握度很高，计量误差低于 1%，这样也便于使用者知道何时该给系统充电了。
音频功放通常需要较高的工作电压以输出较大功率，Boost 转换器 RT8509、RT4813、RT4822 或 RT4823 可为之提供高于电池电压的供电。RT4813、RT4822 支持通过 I2C 接口对其工作参数进行调节，RT4823 则支持直通状态，低音量时可直接将电池电压提供给功放使用以降低损耗。若采用数字式音频传输和处理，整体换用自带智能Boost 升压电路的 D 类功放 RT5509 可简化设计、改善性能。
长期处于工作状态的 MCU、WiFi 模组等需要的 3.3V 电压恰好位于电池工作电压区间内，可自动升降压的 Buck-Boost 转换器 RT6160A 可满足需求，其负载能力达 3A。
ISP 影像传感器的模拟部分需要低噪声电源以确保图像质量，具有高PSRR 和低输出噪声的线性稳压器是不二之选，这里的推荐是 RT9086，250mA 的供电能力已够用。
系统的核心部分工作电压低但电流大，大部分时段处于待机状态，待机电流消耗仅 360nA、负载能力 0.4A-1A 的 Buck 转换器 RT5707/A、RT5713、RT5714 可发挥作用，RT5762/RT5753/RT5788/RT5779 则能提供 2A/3A/4A/5A 电流输出以满足更大电流的需求。如果你的系统需要动态电压供应，可通过 I2C 接口对输出电压进行调节的 RT8092（4A）、RT5735（5A）可满足你的需求。
图中出现的 RT1715 是 TCPC 即 USB-C 型端口控制器，应用需要支持 USB PD 协议时就要用到，MCU 可通过 I2C 接口与之连接以实现 TCPM 的功能，全新的设计也可选择 RT1719 来替代 RT1715，它是不支持 DRP 的用电端专用器件，用在这里可能更符合节俭的原则。上图左侧属于 AC-DC 转换器部分的内容，立錡同样提供完整方案，它们已在智能手机等领域的应用中大量使用，感兴趣者可与我们联系以获得相关支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5863c20f7c8d86956911d85277b8a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5339eb5843a91ada6a2c61282f9ac44/" rel="bookmark">
			knife4j springboot3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.5.0&lt;/version&gt; &lt;/dependency&gt; 2.配置类 import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.Info; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class Knife4jConfig { @Bean public OpenAPI openAPI() { return new OpenAPI().info(new Info() .title("Cloud-platform-api-service Service Api") .description("管理页面API") .contact(new Contact().name("jjj")) .version("1.0.0")); } } 3.application.yaml # springdoc-openapi springdoc: swagger-ui: path: /swagger-ui.html tags-sorter: alpha operations-sorter: order api-docs: path: /v3/api-docs group-configs: - group: 'api页面' paths-to-match: '/organization-structure/**' packages-to-scan: com.cloudservice - group: '老版本' paths-to-match: '/organization-manage/**' packages-to-scan: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5339eb5843a91ada6a2c61282f9ac44/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/151/">«</a>
	<span class="pagination__item pagination__item--current">152/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/153/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>