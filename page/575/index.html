<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27a37361edcc03db7864ab438595ae9/" rel="bookmark">
			nodejs处理图片的几种方法,使用sharp，jimp，webconvert
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用sharp Sharp是一款快速高效的Node.js图片处理库，支持图片格式转换、尺寸调整、压缩、裁剪、旋转、水印等功能。以下是使用Sharp库的基本步骤：
1. 安装Sharp库 安装Sharp库可以使用npm命令：
npm install sharp 2. 调用Sharp库 在代码中调用Sharp库，可以先引入Sharp库：
const sharp = require('sharp'); 3. 图片格式转换 利用Sharp库，可以将图片格式转换为其它格式，例如将JPEG图片转换为PNG图片：
sharp('input.jpg') .toFormat('png') .toFile('output.png', (err, info) =&gt; { // 处理错误或完成后的回调函数 }); 4. 尺寸调整 利用Sharp库，可以调整图片的尺寸，例如将图片宽度调整为800像素：
sharp('input.png') .resize(800, null) .toFile('output.png', (err, info) =&gt; { // 处理错误或完成后的回调函数 }); 5. 压缩 利用Sharp库，可以压缩图片文件大小，例如将图片文件压缩为50%：
sharp('input.png') .jpeg({ quality: 50 }) .toFile('output.png', (err, info) =&gt; { // 处理错误或完成后的回调函数 }); 6. 裁剪 利用Sharp库，可以裁剪图片，例如将图片裁剪为400x400像素：
sharp('input.png') .resize(800, 800) .extract({ width: 400, height: 400, left: 200, top: 200 }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f27a37361edcc03db7864ab438595ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c754cd196bea2e4d81269ee754a2ab4/" rel="bookmark">
			MySQL｜基础操作&#43;8大查询方式汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL操作 一、操作数据库 MySQL中可以创建多个数据库用于存储不同场景的表结构，学习MySQL之前，我们要先理清如下的关系：
数据库 --&gt; 数据表 --&gt; 字段
抛开数据库存储上限去考虑，每个数据库中可以包含无数个数据表，而每个数据表又可以包含无数个字段，因此我们的学习也应该从创建数据库开始。
创建数据库 create database 数据库名 charset=utf8; 例： create database mydata charset=utf8; 查看所有数据库 : show databases; show databases; 使用数据库 use 数据库名; 查看当前使用的数据库 select database(); 删除数据库 drop database 数据库名; 例： drop database mydata; 二、数据表常见操作 创建好了数据库，我们就可以在某个数据库中进行数据表的创建与操作了，数据表是MySQL语法中的核心部分，数据工作者的多数时间都在进行数据表中各个字段的“增删改查”。
1. 基本操作 查看当前数据库中所有表 show tables; 查看表结构 desc 表名; 2. 创建表 给定字段名和数据类型时，我们就可以进行数据表的创建了，当然创建表的时候也有很多特殊的可选项，具体如下：
数据表创建示例（简版）：
column：字段名datatype：数据类型 MySQL常用数据类型介绍：点击此处
CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype ); 例：创建分数表 create table Score( name varchar(20), age tinyint, score int ); 例：创建学生表 create table students( id int unsigned primary key auto_increment not null, name varchar(20) default '', age tinyint unsigned default 0, height decimal(5,2), gender enum('男','女','保密'), cls_id int unsigned default 0 ); 上述代码块创建的时候使用了许多特殊语句，解释如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c754cd196bea2e4d81269ee754a2ab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba7d4ffea42ef0ca49f94efd10735c9/" rel="bookmark">
			前端（二十二）——前端工程化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😄博主：小猫娃来啦
😄文章核心：提高开发效率、降低维护成本、增强代码质量的前端工程化
文章目录 前言前端工程化的定义和意义前端工程化的核心原则前端程化的工具和技术前端框架单元测试工具实战案例：使用前端工程化提升开发效率的经验分享前端工程化的挑战与未来发展总结 前言 前端工程化是指通过使用各种工具和技术，将前端开发过程中的重复、繁琐、易错的工作自动化和规范化，从而提高开发效率、代码质量和团队协作能力。随着Web应用的复杂性和前端开发的日益重要性，前端工程化已经成为现代前端开发的核心要素之一。
前端工程化的定义和意义 前端工程化是一种开发方法论和实践，通过将前端开发流程中的各个环节进行规范化、自动化和模块化，以提升开发效率、代码质量和项目可维护性。通过前端工程化，我们可以实现以下几个方面的优势：
提高开发效率：自动化构建工具和代码生成工具可以减少重复性的工作，提高开发效率，让开发人员能够更专注于业务逻辑的编写。提高代码质量：规范化的代码风格、强大的测试工具和代码检查工具可以帮助开发人员提高代码质量、减少潜在BUG，并保持团队开发的代码风格一致。加强团队协作：使用模块化开发和版本控制系统，多个开发人员可以并行开发不同的功能模块，同时能够更好地进行版本管理、代码托管和团队协作。提高项目可维护性：通过组件化开发、模块管理和文档生成工具，可以降低代码的合度和维护成本，使项目变得更加可扩展可维护。 前端工程化的核心原则 前端工程化包含多个核心原则，下面将详细介绍其中的几个：
组件化开发
组件化开发是指将页面划分为多个独立、可复用的组件，通过组合不同的组件来构建页面。组件化开发的好处在于可以提高代码的可复用性和可维护性，减少代码的冗余和重复编写。常见的组件化开发框架有React、Vue等。下面是一个简单的React组件示例： import React from 'react'; const Button = ({ text, onClick }) =&gt; { return ( &lt;button onClick={onClick}&gt;{text}&lt;/button&gt; ); }; export default Button; 模块管理
模块管理是指将前端项目中的代码划分为多个模块，采用模块化的开发方式。通过使用模块化开发，可以将代码拆分为独立的功能模块，每个模块负责特定的功能，从而提高代码的可维护性和可测试性。常见的模块规范有CommonJS和ES Modules。下面是一个使用ES Modules的示例： // module.js export const sum = (a, b) =&gt; a + b; // main.js import { sum } from './module.js'; console.log(sum(2, 3)); // Output: 5 自动化构建工具
自动化构建工具可以帮助我们自动处理和优化前端项目的构建过程，包括编译、压缩、合并文件等。常用的自动化构建工具有Webpack、Gulp、Parcel等。下面是一个使用Webpack进行模块打包的示例： // webpack.config.js module.exports = { entry: '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba7d4ffea42ef0ca49f94efd10735c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ec80075d72a78b3b7c8b614e20d2c0/" rel="bookmark">
			百度文心一言4.0——使用及API测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录百度智能云：百度智能云
文心一言4.0使用 开通付费：
创建应用：
自行创建应用名称：
对话测试：
API测试 ERNIE-Bot-4 API：ERNIE-Bot-4
打开链接查看自己的API Key，Secret Key。
可参考：API在线调试介绍
找到示例代码即可：
import requests import json def get_access_token(): """ 使用 API Key，Secret Key 获取access_token，替换下列示例中的应用API Key、应用Secret Key """ url = "https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=[应用API Key]&amp;client_secret=[应用Secret Key]" payload = json.dumps("") headers = { 'Content-Type': 'application/json', 'Accept': 'application/json' } response = requests.request("POST", url, headers=headers, data=payload) return response.json().get("access_token") def main(): url = "https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/completions_pro?access_token=" + get_access_token() payload = json.dumps({ "messages": [ { "role": "user", "content": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ec80075d72a78b3b7c8b614e20d2c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86c9daafc8fc5d02c62b4d6a641bb216/" rel="bookmark">
			Java Stream流详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 学习目标中间操作Filter(过滤)Map(转换)Sorted(排序)Distinct(去重)Limit(限制)Skip(跳过)Peek(展示) 终止操作forEach(循环)Collect(收集)Count(计数)Reduce(聚合)AnyMatch(任意匹配)AllMatch(全部匹配)NoneMatch(无匹配) 使用Stream流的优缺点：优点：缺点： 怎么用？ 学习目标 看玩这篇将会：
1.了解stream流
2.学会使用stream流
3.掌握stream流的使用场景
每个方法通过举例子的形式学习！
Stream API主要提供了两种类型的操作：中间操作 和 终止操作。
中间操作 中间操作是返回一个新的流，并在返回的流中包含所有之前的操作结果。它们总是延迟计算，这意味着它们只会在终止操作时执行，这样可以最大限度地优化资源使用。
Filter(过滤) filter()方法接受一个谓词（一个返回boolean值的函数），并返回一个流，其中仅包含通过该谓词的元素。 建一个数组，帅选出长度大于4的元素
eg: public class Main { public static void main(String[] args) { List&lt;String&gt; names = Arrays.asList("Alex", "Brian", "Charles", "David"); List&lt;String&gt; collect = names.stream().filter(item -&gt; item.length() &gt; 4).collect(Collectors.toList()); System.out.println(collect); } } 这段代码创建了一个包含4个字符串的List集合，然后使用Stream()方法将其转化为一个Stream流。接下来使用filter()方法筛选出长度大于4的字符串，返回一个新的包含符合条件元素的Stream流collect。最后使用collect()方法将筛选后的结果转换成一个List集合。
使用Stream流中的filter()方法可以对流中的元素进行筛选过滤。在这段代码中，lambda表达式item -&gt; item.length() &gt; 4指定了筛选判断条件，即只保留长度大于4的字符串。collect(Collectors.toList())则将筛选后的结果转换成一个List集合返回。
通过这段代码，开发人员可以对包含字符串的数据进行快速的筛选和过滤，并且返回结果是一个新的可操作的集合，方便后续进行处理或展示。
Map(转换) map()方法可将一个流的元素转换为另一个流。它接受一个函数，该函数映射流中的每个元素到另一个元素。 public class Main { public static void main(String[] args) { List&lt;Integer&gt; numbers = Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86c9daafc8fc5d02c62b4d6a641bb216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838137403daf2d28b076627b7328abff/" rel="bookmark">
			Kafka简单入门02——ISR机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
ISR机制
ISR 关键概念
HW和LEO
Java使用Kafka通信
Kafka 生产者示例
Kafka 消费者示例
ISR机制 Kafka 中的 ISR（In-Sync Replicas）机制是一种用于确保数据可靠性和一致性的重要机制。ISR 是一组副本，它包括分区的领导者（Leader）和追随者（Follower）副本，这些副本与领导者保持数据同步。
ISR 关键概念 领导者和追随者：每个分区有一个领导者和零个或多个追随者。领导者负责处理客户端的写请求，而追随者主要用于数据复制。
ISR 集合：ISR 集合是分区领导者的一组追随者副本，它们与领导者保持数据同步。只有在 ISR 集合中的追随者副本可以参与数据的写入和读取操作。
数据复制：领导者将消息写入其本地日志，并定期将这些消息发送给 ISR 集合中的追随者。追随者接收消息后，将其写入本地日志，以保持数据同步。
Leader Epoch 和 Log Start Offset：ISR 集合中的每个追随者都维护了领导者的日志信息，包括领导者的 Leader Epoch 和 Log Start Offset。这些信息用于确保数据的正确复制和同步。
数据一致性：只有在 ISR 集合中的所有追随者都成功复制了一条消息后，领导者才会将该消息标记为已提交，确保数据的一致性。
故障处理：如果某个追随者发生故障或者追赶进度过慢，那么该追随者可能会被从 ISR 集合中移除。这有助于保持数据的可靠性和避免影响性能。
其中，需要注意的的概念：
分区中的所有副本统称为AR(Assigned Replicas)。
所有Leader副本加上和Leader副本保持同步的Follower副本组成ISR(In-Sync Replicas)。
所有没有保持同步的Follower副本组成OSR(Out-of-Sync Replicas)。
AR = ISR + OSR。正常情况下，所有Follower副本都应该和Leader副本一致，即AR=ISR。
当Leader故障时，在ISR集合中的Follower才有资格被选举为新的Leader。
HW和LEO 在 Kafka 中，HW（High Watermark）和 LEO（Log End Offset）是与数据复制和消费有关的两个重要概念。
HW（High Watermark）：HW 是指在分区中，已经被所有追随者（Follower）副本复制的消息的位置。HW 是每个分区的属性，它表示已经提交的消息。只有在 HW 之前的消息才被认为是已经提交的，这些消息已经被写入分区的所有追随者副本，并且被认为是安全的，不会丢失。HW 是为了确保数据一致性和可靠性而引入的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/838137403daf2d28b076627b7328abff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c39d2c1897c171509a91ca6360e295/" rel="bookmark">
			【Java用法】computeIfAbsent() 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		computeIfAbsent的使用 一、背景描述二、功能发现三、示例代码 一、背景描述 编程中经常遇到这种数据结构，判断一个map中是否存在这个key，如果存在则处理value的数据，如果不存在，则创建一个满足value要求的数据结构放到value中。在 JDK1.7 之前，经常这么干，这样做起来功能是可以实现的，但是代码不够优雅。
二、功能发现 于是呢，在经历了时间的检验，终于千呼万唤始出来，在 Java8 版本中，加入了 computeIfAbsent() 这个api，computeIfAbsent() 是 Java8 中 Map 接口新增的一个方法，用于在 Map 中根据指定的键获取对应的值，如果该键不存在，则使用指定的函数计算出一个默认值并将其存储到 Map 中，最后返回该默认值。
语法如下：
V Map.computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) 其中，key 表示要获取值的键，mappingFunction 表示计算默认值的函数。具体来说，如果 Map 中已经存在指定的键，则直接返回该键对应的值；否则，使用 mappingFunction 计算出一个默认值，并将该键和默认值存储到 Map 中，最后返回该默认值。
三、示例代码 示例代码如下：
import java.util.HashMap; import java.util.Map; public class TestComputeIfAbsent { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put("apple", 1); map.put("banana", 2); int orangeCount = map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55c39d2c1897c171509a91ca6360e295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ace9ea823474cb2d9aaaa9f97c096b6/" rel="bookmark">
			flutter错误记录 Please enable Developer Mode in your system settings. Run start ms-settings:developers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Please enable Developer Mode in your system settings. Run start ms-settings:developers
原因
这个错误表示你的系统尚未启用开发者模式,所以无法使用Flutter的插件功能。
Flutter插件会通过符号链接的方式与Flutter工程连接,所以需要启用开发者模式和符号链接支持。
解决方法
要解决这个错误,可以按以下步骤操作:
打开手机的开发者模式：不解释
打开电脑的开发者模式
Windows:按Win+I键打开设置,选择“更新和安全性”-“开发者模式”
Mac:打开系统偏好设置,选择“高级”-“开发者选项”
将“开发者模式”开关打开启用
重启系统让设置生效
重新运行Flutter命令,错误应消失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f368c035b63608d2733faa01546957a/" rel="bookmark">
			【Maven】VSCode Java&#43;Maven 环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 前言 没写过 Java，得配个带 Maven 的编码环境，不太明白，试试看顺便记录一下
0x01 配置过程 安装 jdk1.8 后，找到安装位置：
(base) dian@CD-Ali doraemon % /usr/libexec/java_home -V Matching Java Virtual Machines (2): 1.8.381.09 (x86_64) "Oracle Corporation" - "Java" /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home 1.8.0_291 (x86_64) "Oracle Corporation" - "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home
/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home
在 .zshrc 配置环境：
# java env JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH 下载 Maven：
在 Index of /dist/maven/maven-3 里找到所需的 Maven 下载使用，
由于 jdk 版本常年是 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f368c035b63608d2733faa01546957a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8534ad64f405c391d127cf3cd4e481a2/" rel="bookmark">
			使用JavaScript将图片转换为Base64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在Web开发中，我们经常需要将图片转换为Base64格式，以便在不依赖外部资源的情况下直接在HTML中使用。在这篇文章中，我将向您展示如何使用JavaScript将图片转换为Base64格式。
FileReade方式 首先，我们需要创建一个FileReader对象，它是HTML5中的一个API，用于读取文件内容。然后，我们需要监听FileReader的load事件，当图片加载完成时，会触发这个事件。在这个事件的回调函数中，我们可以获取到图片的Base64编码。 代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Image to Base64&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="file" id="inputImage" /&gt; &lt;script&gt; const inputImage = document.getElementById('inputImage'); inputImage.addEventListener('change', function(event) { const file = event.target.files[0]; const reader = new FileReader(); reader.onload = function(e) { const base64 = e.target.result; console.log(base64); // 输出图片的Base64编码 }; reader.readAsDataURL(file); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; canvas方式 我们可以利用canvas.toDataURL，将使用JavaScript来获取图片的base64编码。以下是步骤：
使用JavaScript创建一个canvas元素的引用。使用JavaScript创建一个新的Image对象，并将其源设置为要转换的图片的URL。当图片加载完成后，将其绘制到canvas上。使用toDataURL方法将canvas的内容转换为base64编码的字符串。 创建新的Image对象 var img = new Image(); img.src = 'your_image_url'; // 替换为你的图片URL // 图片加载完成后，将其绘制到canvas上 img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8534ad64f405c391d127cf3cd4e481a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfdd39c408051159ffb3cd8cced6dee/" rel="bookmark">
			Spring Cloud Alibaba 五大组件&#43;代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Alibaba 五大组件 一，介绍 前言 Spring Cloud Netflix 部门组件的维护已经停止，这使得 Spring 社区意识到需要寻找新的解决方案来支持微服务架构。同时，由于阿里巴巴在微服务领域拥有丰富的经验和技术实践，因此 Spring 社区选择与阿里巴巴合作，通过整合阿里开源的组件和工具来开发 Spring Cloud Alibaba，以取代 Spring Cloud Netflix。
Spring Cloud Alibaba 一开始是作为 Spring Cloud 的子项目推出的，现在已经成为了一个独立的项目。它整合了阿里巴巴的多个开源组件，如 Nacos、Sentinel、Dubbo 等，而这些组件都具有高可用性、高性能等优点，并且在阿里巴巴内部得到了广泛应用，经过了大量的生产验证。因此，Spring Cloud Alibaba 可以帮助开发人员更加轻松地构建微服务架构，提供了一整套完善的解决方案，包括服务注册与发现、配置管理、服务调用、流量控制、熔断降级等功能，以及对 Dubbo RPC 框架的支持。而且，Spring Cloud Alibaba 还在不断地更新迭代，增加新的特性和改进性能。
总之，Spring Cloud Alibaba 的诞生不仅是为了填补 Spring Cloud Netflix 部门组件停止维护的空缺，更重要的是借助阿里巴巴的技术实力，为广大开发者提供更为稳定、高效的微服务解决方案。
1.Nacos 1.介绍 Nacos（全称为Not Another Configuration Service）是阿里巴巴开源的一款分布式配置中心和服务发现框架。它提供了以服务注册、服务发现和动态配置管理为核心的功能，可以帮助开发者构建和管理微服务架构。
Nacos 的主要功能包括：
服务注册与发现：Nacos 提供了基于 DNS 和 HTTP/RESTful 的服务注册与发现机制。服务提供者在启动时将自身的信息注册到 Nacos 服务器，服务消费者可以通过查询 Nacos 获取可用的服务实例列表。这样，服务提供者和消费者之间可以实现解耦，动态地进行服务发现和调用。
配置管理：Nacos 提供了统一的配置管理功能，支持动态的配置更新。开发者可以将应用的配置信息存储在 Nacos 中，然后在运行时动态地获取最新的配置。Nacos 还支持配置的版本管理和灰度发布，方便进行配置的变更和回滚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfdd39c408051159ffb3cd8cced6dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0649833524ce01fa28b1a9ccc1e95d47/" rel="bookmark">
			探索Java中最常用的框架：Spring、Spring MVC、Spring Boot、MyBatis和Netty
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spring框架Spring MVC框架Spring Boot框架MyBatis框架Netty框架总结 🎉欢迎来到Java面试技巧专栏~探索Java中最常用的框架：Spring、Spring MVC、Spring Boot、MyBatis和Netty
☆* o(≧▽≦)o *☆嗨~我是IT·陈寒🍹✨博客主页：IT·陈寒的博客🎈该系列文章专栏：Java面试技巧📜其他专栏：Java学习路线 Java面试技巧 Java实战项目 AIGC人工智能 数据结构学习🍹文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️ 在现代的软件开发中，框架是不可或缺的工具，它们能够极大地提高开发效率、代码质量以及应用程序性能。Java作为一种广泛应用于企业级应用开发的编程语言，拥有众多优秀的框架。本文将重点介绍Java中最常用的几个框架，包括Spring、Spring MVC、Spring Boot、MyBatis和Netty，深入探讨它们的作用、特点以及适用场景。
Spring框架 Spring是一个轻量级的开源框架，用于构建企业级应用。它提供了广泛的功能，包括依赖注入、面向切面编程、事务管理、消息传递等。Spring的核心思想是控制反转（IoC）和面向切面编程（AOP）。
IoC（Inversion of Control）：IoC容器管理Java应用中的对象，负责创建、组装、配置和管理它们。开发者只需要定义对象之间的关系，而不需要手动创建对象。
AOP（Aspect-Oriented Programming）：AOP通过将横切关注点（如日志、事务、安全性等）与应用的核心业务逻辑分离，提供了更好的代码组织和维护。
Spring框架的优点：
松耦合：Spring鼓励编写松耦合的代码，使得应用更容易维护和测试。广泛的生态系统：Spring的生态系统包括了大量的扩展模块，满足了各种需求，如Spring Security、Spring Data、Spring Cloud等。高度可测试：由于IoC容器的使用，测试变得更加容易。事务管理：Spring提供了强大的事务管理功能，支持编程式和声明式事务。 Spring MVC框架 Spring MVC是Spring框架的一部分，用于构建Web应用程序。它提供了一种MVC（Model-View-Controller）的架构，使得Web应用的开发更有组织和易于维护。
模型（Model）：模型代表应用程序的数据和业务逻辑。
视图（View）：视图负责显示模型的数据。
控制器（Controller）：控制器接受来自用户的请求，处理它们并选择适当的视图来响应请求。
Spring MVC的优点：
松耦合：Spring MVC使用了松耦合的设计，允许将控制器、模型和视图分开开发，从而提高了代码的可维护性。高度可扩展：Spring MVC支持自定义视图解析器、拦截器等，使得定制化开发变得容易。强大的数据绑定：Spring MVC可以将请求参数绑定到控制器方法的参数，大大减少了开发工作。REST支持：Spring MVC支持构建RESTful Web服务，通过注解和配置来定义REST端点。 Spring Boot框架 Spring Boot是Spring的扩展，旨在简化Spring应用程序的创建和开发。它通过提供默认配置、自动配置和快速开发功能，大大减少了开发者的工作量。
Spring Boot的特点：
自动配置：Spring Boot根据项目中使用的库和类自动配置应用程序。如果你需要自定义配置，只需覆盖默认配置即可。嵌入式Web服务器：Spring Boot集成了嵌入式的Web服务器，如Tomcat、Jetty等，无需额外配置。生产就绪特性：Spring Boot内置了用于监控、度量、健康检查的功能，便于生产环境的部署。开箱即用：Spring Boot提供了一系列的“Starter”依赖，可以快速构建特定类型的应用程序，如Web应用、数据访问应用、消息队列等。 MyBatis框架 MyBatis是一种优秀的持久层框架，它简化了数据库访问操作。与其他ORM框架不同，MyBatis使用XML或注解配置SQL语句，提供了更灵活的SQL编写方式。
MyBatis的特点：
SQL分离：MyBatis将SQL语句与Java代码分离，提供了更好的可读性和维护性。参数映射：MyBatis可以将Java对象和数据库表之间的字段映射自动处理。高性能：MyBatis执行SQL语句的性能很高，支持懒加载、缓存等特性。灵活性：MyBatis支持自定义类型处理器、插件等扩展功能。 Netty框架 Netty是一个基于事件驱动的网络应用程序框架，用于快速开发高性能的网络服务器和客户端。它支持各种传输协议，如TCP、UDP、HTTP等。
Netty的特点：
高性能：Netty的事件驱动架构使得它在高负载情况下表现出色。可扩展性：Netty的组件是可扩展的，可以轻松添加自定义的处理器。多协议支持：Netty支持多种协议，使其适用于各种应用，包括Web服务、实时通信等。成熟的生态系统：Netty有一个活跃的社区，提供了丰富的扩展和文档资源。 适用场景
使用Spring来构建企业级应用，特别是那些需要控制反转和面向切面编程的应用。开发Web应用程序时，可以使用Spring MVC来处理Web请求。使用Spring Boot来快速创建独立的Spring应用程序，减少配置工作。需要数据库持久化操作时，可以选择MyBatis作为ORM框架。需要构建高性能的网络应用程序时，可以使用Netty。 总结 Spring、Spring MVC、Spring Boot、MyBatis和Netty是Java开发中最常用的框架之一，每个框架都有自己的优点和适用场景。选择合适的框架取决于你的项目需求和技术栈。熟练掌握这些框架将有助于提高你的Java开发技能，加速项目开发，并提高应用程序的性能和质量。希望本文对你更好地理解这些框架提供了帮助。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0649833524ce01fa28b1a9ccc1e95d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07828f0e38c6d661226f32b72334201d/" rel="bookmark">
			SQL server2022的详细安装流程以及简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于SQL Server2008R2版本过于老旧，本文主要讲述如何安装SQL Server 2022。
本文主要详细介绍SQL server2022的详细安装流程以及简单使用，以《数据库系统概论（第5版）》的第79页—第80页为例，详细介绍如何使用SQL server2019这款数据库软件，包括启动SQL server服务，建立数据库（学生—课程模式S-T）,建立课程表等，内容比较简单，容易理解，适合广大初学者了解SQL server的简单使用。不会涉及到复杂的语法知识，如果有也会详细解释的！（下文标红的字请重点关注一下！）
本文的需要建表的数据如下：
Course：
安装 1.1 在线安装文件下载 首先，我们进入到微软Data platform页面，找到SQL Sever下载页面，选择合适版本进行下载（以Developer版为例）。
下载地址：
https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads
选择Develper版，下载完成后，开始安装。
1.2 安装SQL Server 双击SQL Server 2022安装包开始安装，会显示以下界面：此处选择安装类型为基本，操作默认下一步。 选择安装路径，然后点击安装即可。然后进行下一步：全新安装，首先找到D:\SQL2022\Developer_CHS目录下的SETUP.EXE，双击运行。（这个路径是SSEI的安装路径）打开后选择“安装”，点击全新SQL Sever独立安装或向现有安装添加功能。 点击下一步。（这里“Windows防火墙”的警告是没有影响的）
选择“执行SQL Server2022的全新安装”，点击下一步。指定要安装的版本，我们这里选择Developer（开发且免费版本），点击下一步。勾选“我接受许可条款和（A）”，点击下一步。选择自己需要的功能（没必要全部勾选，后期还是可以添加的），此处路径可更改，然后点击下一步。进行实例命名，可默认实例或命名实例，注意：如果实例名已存在时就需要进行重新命名实例。“服务器配置”默认即可，然后点击下一步。选择【混合模式】，并为系统管理员sa设置密码，例如：root1234，然后点击“添加当前用户”，然后点击“下一步”。点击安装。安装完成，之后直接关闭页面即可。 选择邻域数据点的方法是根据距离x0的远近来加权选择。
1.3 安装SQL Server管理工具 安装SQL Sever管理工具，点击安装SQL Sever管理工具，页面直接跳转到官网SQL Server管理工具下载安装包界面。点击进行下载。下载完成之后，点击应用程序，并以管理员的身份运行，选择自己要安装的位置，然后点击安装即可。安装完毕关闭即可。 二、启动SQL Server服务的三种方法 2.1 不启动SQL Server服务的影响 在使用Microsoft SQL Server Management Studio 18r时，必须先启动SQL server服务，如果直接打开Microsoft SQL Server Management Studio 18，输入用户密码后，点击连接，会提示类似下图的错误信息：
2.2 方法一：利用cmd启动SQL Server服务 在开始页面搜索cmd，选择命令提示符，点击以管理员身份运行（一定注意要以管理员身份运行启动SQL Server服务会失败！） 失败的样子：
在命令提示符中输入以下的代码： net start mssqlserver 输入完成后，按回车键，会自动启动SQL Server服务，此时的界面如下：
此时显示SQL server服务已经启动成功了，SQL server服务启动之后，关闭命令提示符，打开Microsoft SQL Server Management Studio输入用户密码后，点击连接，就可以正常使用了（也可以windows 身份验证登录）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07828f0e38c6d661226f32b72334201d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc86cdf2f95db7972aa8f6d60b66803/" rel="bookmark">
			Python连接SQL SEVER数据库全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍 在数据分析领域，经常需要从数据库中获取数据进行分析和处理。而SQL Server是一种常用的关系型数据库管理系统，因此学习如何使用Python连接SQL Server数据库并获取数据是非常有用的。
以下是Python使用pymssql连接SQL Server数据库的全流程：
安装pymssql库本地账号设置脚本连接数据导入函数实现 一、安装pymssql pymssql是Python连接SQL Server数据库的一个库，可以通过pip命令进行安装。在命令行中输入以下命令即可安装：
pip install pymssql 二、本地账号设置 1、设置sa账户的登录密码 在SQL Server Management Studio中，展开“安全性”文件夹，右键单击“登录名”并选择“新建登录名”。在弹出的对话框中，输入登录名“sa”，选择“SQL Server身份验证”，设置密码并确保“登录”选项卡下“默认数据库”为目标数据库。最后，在“状态”选项卡下选择“启用”并确保“允许连接”复选框被选中。
2、开启双重验证 在SQL Server Management Studio中，右键单击SQL Server实例名称并选择“属性”。在弹出的对话框中，选择“安全性”选项卡，将“身份验证”设置为“SQL Server和Windows身份验证模式”，并选择“应用”以保存更改。
3、开启TCP/IP本地服务 在SQL Server Configuration Manager中，展开“SQL Server网络配置”文件夹，右键单击“协议”文件夹并选择“新建协议”。选择“TCP/IP”协议，右键单击“TCP/IP”协议并选择“属性”。在弹出的对话框中，将“启用”设置为“是”，并确保“IP地址”选项卡下的“TCP动态端口”为空。然后，切换到“IPALL”选项卡，并将“TCP端口”设置为1433（或其他您想要的端口号）。保存更改并重启SQL Server服务。
完成以上步骤后，即可使用Python连接本地SQL Server数据库。
三、脚本连接 做好以上的准备工作，用测试脚本连接（如果连接出错——b’DB-Lib error message 20002，试下在connect函数参数最后面加上tds_version=“7.0” 或者其他值）。
import pymssql server = '(local)' database = '订单信息' username = 'sa' password = '123456' # 连接到数据库 conn = pymssql.connect(server=server, user=username, password=password, database=database,tds_version="7.0")#最后一个参数不是必须的 # 创建游标对象 cursor = conn.cursor() print('连接成功！') # 关闭数据库连接 conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cc86cdf2f95db7972aa8f6d60b66803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63adf9de6b1c4504f7bb77aab1013558/" rel="bookmark">
			使用AI编写测试用例——详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着今年chatGPT的大热，每个行业都试图从这项新技术当中获得一些收益我之前也写过一篇测试领域在AI技术中的探索：软件测试中的AI——运用AI编写测试用例现阶段AI还不能完全替代人工测试用例编写，但是如果把AI当做一个提高效率的工具，它将会是一个很实用很强大的辅助。经过一段时间的实践和沉淀之后，已经有一个相对成熟的模式。此篇文章则是将这段时间的经验，总结为教程分享出来。但是这种使用AI编写用例的模式仍然有很多不足的地方，也欢迎大家提出意见和建议，一起改进优化。 文章目录 一、准备工作（一）AI介绍（二）该选择哪个AIChatGPTNewBing（新必应）文言一心 （三）AI编写测试用例原理 二、编写用例（一）通过需求生成测试点（二）通过测试点生成测试用例（三）注意事项 一、准备工作 （一）AI介绍 AI即人工智能，这项技术希望产出一种以人类智能相似的方式做出反应的智能机器。ChatGPT是OpenAI研发的一款聊天机器人程序。ChatGPT是人工智能技术驱动的自然语言处理工具。使用AI编写测试用例，其实是将我们提供的需求或测试点通过聊天机器人程序，对自然语言进行处理，重新组合为测试用例。 （二）该选择哪个AI ChatGPT 自从ChatGPT大热之后，大部分国内途径可以获取到的AI（聊天机器人）都为GPT-3.5版本。GPT-4.0版本因为要付费等等原因，使用门槛会相对更高。GPT-3.5版本当然比不上GPT-4.0版本，但如果只是用作编写测试用例的话，3.5版本也是够用的。 NewBing（新必应） 微软推出的NewBing（新必应）与ChatGPT使用同一个算法模型并且New Bing的回答结果带有搜索来源的地址，即使作为普通的搜索引擎也比传统搜索引擎好用很多。最重要的一点，现阶段NewBing是免费的，并且只由单次对话的限制，对话的总次数没有限制。NewBing也是我现在最常用的AI。
文言一心 前两个AI想要在国内访问需要一定的门槛，过程相对复杂如果只是简单的体验一下智能聊天机器人，可以尝试一下国内的文言一心
（三）AI编写测试用例原理 正如前面介绍的那样，聊天机器人程序本质上是一个自然语言处理工具。它就像一面镜子，它输出什么取决于你给它什么所以，该提供哪些信息，该如何下达命令，就是最核心的问题。 给AI下达命令，有一个专有名词叫prompt（提示词）
例如，下图注册弹框的需求
我让AI生成这条需求的测试点：“1.点击手机号输入框弹出键盘。限制只能输入数字，除数字外字符输入不成功。手机号限制输入11位；”得到的结果如下，可以看到输出的结果大部分是来源于我的提示词，AI将提示词分析并重新整合，输出一份测试点。
这就意味着，提示词越详细，输出的内容就越贴近想要的结果，但随着而来的成本也就越高。但输出的内容不够准确，后期的修改的成本也会变高。所以，如何平衡成本也是一个很大的问题。 二、编写用例 理想状态是直接把需求直接提供给AI，让AI直接写用例，但这样与实际想要达到的结果相差甚远。所以建议，先使用需求通过AI生成测试点，再测试点通过AI生成测试用例。以下示例说明以newbing为例 （一）通过需求生成测试点 下面是向AI发出指令的模板，黄色字的内容是可选项或说明：
注意：由于AI回复的字数有限制，建议对需求进行分块分类型，然后分批生成测试点。 我是一名移动端软件测试工程师，下面这份需求帮我输出一份测试点，（或 每条测试点需要输出正向和逆向的用例）：
需求名称：需求名称
需求说明：需求说明
输出要求：将测试点分为触发条件、触发时机、样式、功能逻辑、异常处理几个模块，并且新增一列，表明所属的模块。（如果是非页面性的功能，使用触发条件、触发时机，如果是页面、弹框等，使用展示条件、展示时机）
输出格式：表格，分为序号、所属模块、测试点，总共三列。
以下图注册弹框的需求为例，使用的AI是newbing
按照模板编辑后，黏贴到newbing并发送
输出的结果如下
（二）通过测试点生成测试用例 下面是向AI发出指令的模板，蓝色字的内容是可选项或说明：
注意：由于AI回复的字数有限制，建议跟生成测试点一样，分批生成测试用例。 我是一名移动端软件测试工程师，下面这份是针对移动端软件的测试点，帮我输出一份测试用例，每条测试点用一条以上用例验证 （或 每条测试点需要输出正向和逆向的用例）：
需求名称：需求名称（需求名尽量概述功能点）
模块名称：模块名称（用例中所属模块）
需求说明：需求说明
功能流程：功能流程（可以写一条正向的流程）
输出要求：需要包含用例名称、所属模块（填写测试点所属模块名称）、前置条件（非必填，可为空）、测试步骤、预期结果
输出格式：表格。
以上面输出的测试点为例： 先编辑模板，黏贴到newbing并发送
输出的结果如下
（三）注意事项 遇到输出数据不完整时，可以让AI继续输出后续的内容。例如：“从第五条开始，继续输出剩下的用例”注意，AI直接输出的结果，大部分不够准确，还是需要经过人工审核， 此篇文章只是提供了一个可行的方法，但是它还不完美，欢迎大家一起讨论一个更完美的为未来~
————————————————————————————————————————————
本人运营的博客同名公众号【软件测试必备技能】不定期会上传测试相关资料，可点击文章下方二维码，前往领取~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e41cad4f14b2aea5e0f12d36cef46bf/" rel="bookmark">
			【数据结构】String类对象的创建与字符串常量池的“神秘交易”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：paper jie_博客
本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。
本文录入于《JAVA数据结构》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。
其他专栏：《算法详解》《C语言》《javaSE》等
内容分享：本期将会分享java数据结构中的String对象创建的深入探索
目录
创建对象内的“那些事”
字符串常量池
对String对象创建的具体分析
直接使用字符串常量进行赋值
通过new创建String对象
intern方法
创建对象内的“那些事” 话不多说，直接上代码：
public static void main(String[] args) { String s1 = "hello"; String s2 = "hello"; String s3 = new String("hello"); String s4 = new String("hello"); System.out.println(s1 == s2); // true System.out.println(s1 == s3); // false System.out.println(s3 == s4); // false } 上面这个代码我们发现创建的String对象的方式类似，但是结果s1和s2是同一个对象，但s3和s4却却不是？
这就是要深究到java中的常量池了。在java中，“hello”，“1234”等常量经常被频繁使用，java为了让程序运行的速度更加快，跟节省内存，就为8种基本类型和String类提供了常量池。
java中引入了：
Class文件常量池：每个Java源文件编译后生成的.Class文件中会保存当前类中的字面常量以及符号信息
运行时常量池：在.Class文件被加载时，Class文件中的常量池被加载到内存中称为运行时常量池，运行时常量池每个类都会有一份
"池" 是编程中的一种常见的, 重要的提升效率的方式, 我们会在遇到各种 "内存池", "线程池", "数据库连接池
字符串常量池 字符串常量池在JVM中是一个StringTable类，实际是一固定大小的HashTable，它是一种高效查找的数据结构，在不同的JDK版本下字符串常量池的位置以及默认大小是不同的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e41cad4f14b2aea5e0f12d36cef46bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37a35deb324c75a2a09e6cd3bdd3a09/" rel="bookmark">
			【数据结构】Java对象的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：paper jie_博客
本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。
本文录入于《JAVA数据结构》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。
其他专栏：《算法详解》《C语言》《javaSE》等
内容分享：本期将会分享java数据结构中的对象比较
目录
priorityQueue中如何插入对象
元素的比较
基本类型的比较
对象类型的直接比较
对象正确的比较方式
重写equals方法
基于Comparble接口类的比较
基于比较器比较
集合框架中priorityQueue的比较方式
priorityQueue中如何插入对象 我们知道，优先级队列在插入元素时有一个要求：需要可以比较的对象才能插入。这里我们需要知道怎样插入自定义类型对象：
比如我们插入这个student对象：
class student { int age; String name; public student(int age, String name) { this.age = age; this.name = name; } } public class Test { public static void main(String[] args) { PriorityQueue&lt;student&gt; priorityQueue = new PriorityQueue&lt;&gt;(); priorityQueue.offer(new student(12,"小猪佩奇")); priorityQueue.offer(new student(12,"小猪乔治")); } 在运行后发现它会报类型不兼容的异常，这是因为在堆中插入元素，为了满足堆的性质，需要进行对象的比较，但是我们的student类型对象时不能直接比较的，所以会报错
​
元素的比较 基本类型的比较 在Java中，基本类型的对象是可以直接进行比较大小的
class TestCompare { public static void main(String[] args) { int a = 10; int b = 20; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a37a35deb324c75a2a09e6cd3bdd3a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ea205afdf743d93ed9eb0f7a5d0d57/" rel="bookmark">
			超详细 | 差分进化算法原理及其实现(Matlab/Python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		差分进化(Differential Evolution，DE)算法是由美国学者Storn和 Price在1995年为求解Chebyshev多项式拟合问题而提出的。算法主要通过基于差分形式的变异操作和基于概率选择的交叉操作进行优化搜索，虽然其操作名称和遗传算法相同，但实现方法有本质区别。
差分进化算法的原理简单,参数设置较少,易于编程实现,目前已被证明为是一种高效的智能优化算法，已在人工神经网络、电力、机器人、信号处理等领域得到了应用。
本文将介绍其理论模型和代码实现。
00 目录 1 差分进化算法原理
2 代码目录
3 算法性能
4 源码获取
01 差分进化算法原理 差分进化算法的基本思想源于遗传算法。
变异：DE算法是通过把种群中两个个体之间的加权差向量加到第三个个体上来产生新参数向量;
交叉：将变异向量的参数与另外预先决定的目标向量的参数按照一定的规则混合起来产生子个体;
选择：新产生的子个体只有当它比种群中的目标个体优良时才对其进行替换;
DE算法的选择操作是在完成变异、交叉之后由父代个体与新产生的候选个体――对应地进行竞争，优胜劣汰,使得子代个体总是等于或优于父代个体。
而且,DE算法给予父代所有个体以平等的机会进入下一代,不歧视劣质个体。
差分进化算法把一定比例的多个个体的差分信息作为个体的扰动量,使得算法在跳跃距离和搜索方向上具有自适应性。在进化的早期,因为种群中个体的差异性较大,使得扰动量较大,从而使得算法能够在较大范围内搜索,具有较强的勘探能力﹔到了进化的后期﹐当算法趋向于收敛时,种群中个体的差异性较小,算法在个体附近搜索,这使得算法具有较强的局部开采能力。
正是由于差分进化算法具有向种群个体学习的能力,使得其拥有其他进化算法无法比拟的性能。其具体操作如下：
（1）变异
当种群进化至第 G 代时，对父代个体Xi，G 实施变异操作得到变异个体，即：
式中下标 r1，r2，r3 是在 1 和 NP（种群规模） 之间随机选择的与i不同的互异整数，Xr1,G称为基向量，( Xr2,G - Xr3,G ) 称为差分向量，F为缩放因子。如果变异个体中的参数超出边界，则该参数的值将被边界值替换。
（2）交叉
通过交叉操作产生试验个体为：
其中，
式中 rj[ 0，1) 代表第 j 次计算的随机数，CR 为交叉率。r(i)是在1和D之间随机选取的 整数，可使Ui,G + 1从Vi,G + 1获得至少一个变量。
（3）选择
对于最小化问题，在试验个体Ui,G + 1与父代个体Xi,G中选择目标函数较小的个体进入下一代种群，即：
式中 F (X)代表目标函数。
算法中主要的控制参数为种群规模NP、缩放因子F、交叉率CR，通常这些参数在进化时都保持不变。
算法流程图如下：
02 代码目录 MATLAB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ea205afdf743d93ed9eb0f7a5d0d57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da39832653c51b65aee591792f8a0928/" rel="bookmark">
			C#使用Asp.Net创建Web Service接口并调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.创建Asp.net web应用以及Web Service服务
(1).运行环境
(2)创建项目
二.创建控制台应用来调用上面创建的Web Service
一.创建Asp.net web应用以及Web Service服务 (1).运行环境 开发工具: Visual Studio 2022 Current (免费社区版)
框架版本: .net framework4.7.2,更高的.net 5 、net6貌似没有默认提供带web service的asp.net 应用模板了。
确保VS的工作负荷有勾选下方箭头所指的模块
确认环境没有问题之后就可以开始创建项目了。
(2)创建项目 打开vs点创建新项目
选择箭头指向的项目模板，注意是.NET Framework后缀的，带Core的都是版本比较新的框架项目模板，选择好之后点击下一步选择项目存放的路径以及项目命名、解决方案命名、框架版本，
我这里就用默认的命名了，框架我选.net framework 4.7.2，然后点击创建即可开始下一步。
点击创建进去会出来一个模板进一步的配置，因为我这也只是整个Web Service接口来而已就选空模板，直接在本机跑也不需要Docker之类的
搞定之后直接创建，创建完成后右键项目点添加-&gt;新建项-&gt;找到Web 服务(AMSX),选择之后点添加就能创建一个web service默认的hello world模板
加上之后直接启动就可以看到一个网页的服务说明以及对应方法的测试路由,以及对应的方法
在调试模式下可以直接通过上面的调用按钮调用指定的方法，这里点一下调用会返回一个xml并转换成网页
打包之后这个操作就不支持了，到这里创建就算完成了。
这里因为打开的文档就是刚刚创建的web服务所以vs会直接把路由跳到这里，如果当前打开的文档不是创建的WebService1类运行起来就会报服务器没有开启目录浏览，所以要像下面设置一下项目属性。
二.创建控制台应用来调用上面创建的Web Service 直接右键解决方案添加一个控制台应用,这里我用HttpClinet类所以用的框架版本是.net 6
且使用顶级语句，因为就几句话emmmm,发送报文运行一下web服务把报文copy下来就好。
本地测试的时候可以用http直接调用，虽然不知道为什么部署到服务器之后就只能通过Soap协议丢xml报文来调了。下面是代码报文是运行一下web服务把对应方法的post请求直接copy下来
返回的就是一坨xml,箭头指的就是方法返回的Hello world，可以用.net自带的linq来解析很方便,命名空间是这个
using System.Xml.Linq;
这是上面运行的代码。
using System.Net.Http.Headers; var clinet = new HttpClient(); var xml = "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da39832653c51b65aee591792f8a0928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9041da3d121c3329e43dc7286575fb8c/" rel="bookmark">
			我的数据仓库与数据挖掘期末大作业重置版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 我的数据仓库与数据挖掘期末大作业重置版准备工作预设定及导入相对应的库库的导入调整 Jupyter Notebook 的预设定调整 MatPlotLib 和 Pandas 的输出设置 任务 1：预测问题数据的保存和读取数据的分析和预处理模型的选择和构建线性回归一元多项式回归 拟合预测拟合优度的评估 任务 2：聚类分析问题数据的保存和读取数据的分析和预处理聚类的实现聚类结果有效性评估 任务 3：Apriori 关联规则算法数据的保存和读取数据的分析和预处理Apriori 关联规则算法流程设计和计算关联规则挖掘和输出结果的分析 任务 4：层次分析法决策问题层次分析法的准则构造建立层次结构模型通过 Python 计算 APH 层次分析法层次分析法的代码实现一致性检验的基本步骤 我的数据仓库与数据挖掘期末大作业重置版 这是之前已经完成的任务，原本是我的数据仓库与数据挖掘课程的作业。里面都是比较入门的东西，没什么难度。之前学这门课的时候，上了一整个学期的课，几乎都在讲解数学原理。作为数学科目挂了四门的理工蠢材，我整个学期都听得云里雾里，到了学期末的时候突然告诉我们说期末大作业要用 Python 来写。
我当时的反应就是：
啊？
Python？
啊这，您玩儿我呢？一整个学期过去了关于 Python 的事情只字未提，现在只剩下一个星期了您跟我说要用 Python 交期末作业…… 你这样我很尴尬啊。
然后只好赶鸭子上架，学了三小时速通 Python 直接开始写报告。这个作业本来是小组作业，但是我们“小组”很尴尬地只有两个人，而学了 Python 的只有我一个。到最后只好提交了一些狗屁不通的代码（我自己都看不懂），勉勉强强把这件事情糊弄过去了。
于是我决定现在重新把这几个任务做一遍，一雪前耻。总的来说，这几个入门级别的任务还算是比较考验数据分析综合能力的（？）。
本文我希望实现的效果就是对于这四个实验能够做到事无巨细，把所有以前没有弄明白的问题全都弄懂。代码不一定都是自己写的，但是要确保自己能看懂。
希望有一定的参考价值。
准备工作 安装 Python ，本次实验的版本为 Python 3.9.10在 Visual Stdio Code 中安装 Jupyter 插件，搭建开发环境使用 pip 安装需要的各种库 在终端中执行如下命令：
pip requests # http 请求库，不先安装的话后续装其他库会报错 pip install numpy pandas matplotlib scikit-learn itertools 下面介绍各个库的功能以及用途。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9041da3d121c3329e43dc7286575fb8c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/574/">«</a>
	<span class="pagination__item pagination__item--current">575/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/576/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>