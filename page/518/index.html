<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf317adfee2072795e7f1e2079180be/" rel="bookmark">
			Java之IDE开发工具eclipse下载安装使用详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDE开发工具之一：eclipse的使用 教学目标 熟练eclipse的使用 1、概述 Eclipse是一个IDE(集成开发环境)，集成了代码编写功能，分析功能，编译功能，调试功能等一体化的开发软件。
免费Java语言编写免安装扩展性强 下载和安装
下载地址：http://eclipse.org绿色版 解压就可以使用(Eclipse) 版本代号平台版本需要的JDK最低版本Galileo（伽利略）3.5JDK1.5Helios（太阳神）3.6JDK1.5Indigo（靛蓝）3.7JDK1.5Juno（朱诺，天后）3.8及4.2JDK1.5Kepler（开普勒）4.3JDK1.6Luna（月神）4.4JDK1.6Mars（火星）4.5JDK1.7Neon（霓虹灯）4.6JDK1.8Oxygen（氧气）4.7JDK1.8Photon（光子）4.8JDK1.8Eclipse 2018-094.9Eclipse 2018-124.10Eclipse 2019-034.11Eclipse 2019-064.12 2、工作空间workspace 1、eclipse的管理层次 工作空间：存放项目代码等、其中的.metadata目录中是eclipse关于本工作空间的个性化配置文件、插件
eclipse中管理层次是：工作空间 》 项目 》 包 》 类等
一个工作空间可以有很多的项目，但是项目之间是互相独立的，一个项目不能使用另一个项目中的类等
一个项目可以有很多的包，不同包之间的类可以通过导包方式互相使用
一个包中可以有很多的类
2、指定工作空间 如果想取消默认进入某个工作空间，可以把下面的选项勾上：
3、如何切换工作空间 4、设置工作空间字符编码等 5、缩进4个空格 3、界面介绍 基本界面介绍 左边的导航区域：
navigation：导航器package explorer：包资源管理器（建议初学者开发时选择使用这个，更紧凑一些）project explorer：项目资源管理器 如何打开各种小窗口 如何快速恢复界面布局 当界面中各种小窗口乱了，如何快速恢复如初：
如何保存布局 4、设置字体 Window -&gt; Preferences -&gt; General -&gt; Appearance -&gt; Colors and Fornts，只需修改 Basic 里面的 Text Font 就可以了
5、设置编辑区域背景颜色 6、设置控制台相关颜色 7、创建项目 File菜单–》New --》Java Project
8、创建类等 9、运行Java程序 要作为Java程序运行，该类必须包含main方法，而且在eclipse中，包含主方法的类必须与源文件名相同
三种方式运行Java程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf317adfee2072795e7f1e2079180be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c27cf94a4fcb0d415c7e50cd7f0162/" rel="bookmark">
			Android MediaCodec 简明教程（四）：使用 MediaCodec 将视频解码到 Surface，并使用 SurfaceView 播放视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Android MediaCodec 简明教程（一）：使用 MediaCodecList 查询 Codec 信息，并创建 MediaCodec 编解码器Android MediaCodec 简明教程（二）：使用 MediaCodecInfo.CodecCapabilities 查询 Codec 支持的宽高，颜色空间等能力Android MediaCodec 简明教程（三）：详解如何在同步与异步模式下，使用MediaCodec将视频解码到ByteBuffers，并在ImageView上展示 文章目录 系列文章目录前言一、Surface 是什么？二、MediaCodec 解码到 Surface2.1 Surface 从哪来？2. 2 MediaCodec 与 Surface 共享内存，实现零拷贝2.3 数据流动2.4 ReleaseOutputBuffer，控制水流速度2.5 Show me the code 参考 前言 在上一个教程 Android MediaCodec 简明教程（三） 中，我们学会了使用 MediaCodec 解码到 ByteBuffers 上，包括同步模式和异步模式。本章将讨论 MediaCodec 解码到 Surface 的相关知识点。Google 推荐使用 Surface 进行编解码操作，这样效率更高。
一、Surface 是什么？ Android Surface 是一个复杂的概念，它涉及到 Android 图形系统，网络已经有很多相关的博文，例如：
从整体上看Android图像显示系统Android图形系统综述(干货篇)浅谈Android Surface机制深入Android系统（十二）Android图形显示系统-1-显示原理与Surface Surface 是 Android 图形架构的一部分，它与 SurfaceFlinger、SurfaceView、SurfaceTexture、SurfaceHolder 等组件一起，构成了 Android 的图形系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c27cf94a4fcb0d415c7e50cd7f0162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505b62d06287103c5d15d7e0bb7abbb3/" rel="bookmark">
			Stable Diffusion【插件篇】：使用After Detailer实现人脸修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是程序员晓晓。
在使用SD绘图的时候，默认的分辨率大小是512*512，这样设置的好处是出图效率高。但是如果涉及到人全身照的时候，经常会出现一个问题：脸部崩。主要原因是在一个比较低的像素画布上，绘制一个全身图，脸部能分配到的像素不够了。我们来看一下效果。
一. 使用高分辨率修复
上面图片的提示词：tunning female model, full body,seaside landscape, rocky cliffs, clear blue sky, white sand, flowing white dress, sunlight streaming through hair, captivating eyes, high level of detail, masterpiece（提示词中包含有full body，目的就是出一个全身图）。
我们尝试采用高分辨率修复看一下效果。
为了保证图片的一致，我们保持随机数种子一致。
点击生成按钮，效果如下：
即使使用了高清修复，我们发现脸部还是有些拉胯。可见即使使用高分辨率修复，一方面生成的图片分辨率发生了变化，另一方面生成图片效果并不是特别理想。
那么有没有办法在分辨率为512*512人物全身照的情况下正常展示人脸呢，这个就是我们今天要介绍的插件：After Detailer。
今天我们演示使用的是LibLibAI, 在LiblibAI里面集成了After Detailer插件，在这里也介绍一下After Detail插件的安装方法。
二. After Detailer插件的安装
插件地址：https://github.com/Bing-su/adetailer.git
如果无法下载，请看文末直接获取哦
我们也可以将安装包拷贝到对应的/…/stable-diffusion-webui/extensions/目录下面。
安装完成后，重启SD Web UI即可。
三. After Detailer插件的介绍
After Detailer插件的主界面如下。
After Detailer插件支持多通道，可以同时开多个单元，比如在一张照片中同时修复脸部和手部。
After Detailer启用：在使用的时候需要选中开启。
After Detailer模型：
After Detailer插件支持修复脸部、手部、和全身。但是就目前使用情况来看，修复脸部效果最好，堪称完美，修复手部和全身效果还不是太好，需要继续完善功能。
上面是常用的一些模型，如果有些模型没有的话，可以在huggingface网站进行下载：https://huggingface.co/Bingsu/adetailer/tree/main。
（如果无法下载，请看文末直接获取哦）
提示词：修复脸部、手部、全身用到的正向、负面提示词，只描述需要修复的部分即可。可以和文生图的提示词不一致。默认可以不输入。
检测/蒙版/重绘：
这些参数的设置和人脸修复的实现机制有关系。人脸修复的原理大致如下：首先，需要准备一张进行人脸修复的原始图像。插件程序会定位原始图像中人脸的中心，并确定脸部的遮罩范围。然后，在遮罩范围内增加一些噪点，并将其输入局部重绘模块，重新绘制脸部的遮罩范围。也就是说，脸部修复涉及到脸部检测、遮罩生成以及局部重绘这三个步骤。分别对应上面检测、蒙版、重绘参数设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505b62d06287103c5d15d7e0bb7abbb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c4a9681c5fe8436c4f8352ad472e1d/" rel="bookmark">
			前端qrcode生成二维码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、浏览器支持2、优点3、缺点4、相关方法5、安装及使用示例 前言 qrcode 是一个基于JavaScript的二维码生成库，主要是通过获取 DOM 的标签，再通过 HTML5 Canvas 绘制而成，不依赖任何库。
官方文档：https://www.npmjs.com/package/qrcode
1、浏览器支持 qrcode理论上支持所有现代浏览器以及部分老版本浏览器。具体而言，只要这些浏览器支持HTML5 Canvas和/或DOM操作，就可以使用 qrcode 来生成二维码，具体的有：IE6~10， Chrome， Firefox，Safari，Mobile Safari，Opera，Android， Windows Mobile，Microsoft Edge等。
2、优点 1）客户端实时生成：无需服务器端干预，可以在浏览器端直接生成二维码，减少服务器负载和网络传输成本，使得动态内容的二维码生成更加便捷。例如：根据用户输入或当前页面URL生成二维码。
2）轻量级：qrcode.js 是一个轻量级的库，体积小，易于引入到项目中，不会显著增加网页加载时间。
3）易用性：API设计简单，只需要几行代码就可以将文本转换为二维码，并且可以灵活地控制生成二维码的各种参数（如纠错级别、大小等）。
4）跨平台兼容性：基于HTML5 Canvas或DOM元素绘制，适用于大部分现代浏览器，包括桌面端和移动端。
5）动态更新：由于是在客户端生成，因此能够实现动态内容的实时更新，比如在网页上显示不断变化的数据对应的二维码。
6）无额外图片资源：不需要上传或存储预生成的二维码图片，减少了文件存储空间的需求和维护工作。
7）可嵌入Web应用：与网站其他功能集成紧密，可以方便地将生成的二维码内嵌到网页的任何位置，实现良好的用户体验。
8）自定义扩展：虽然原始库可能不支持一些高级特性（如Logo添加），但因为是开源项目，开发者可以根据需要对源码进行修改和扩展来满足个性化需求。
3、缺点 1）不支持中文直接编码：根据提及的信息，原始版本的 jquery.qrcode 插件可能不支持直接将包含中文的文本转换为二维码。在处理非ASCII字符时，需要先对中文内容进行URL编码或其他转码操作。
如果将用中文来生成二维码，然后用微信扫描生成的二维码会看到如下提示：
2）LOGO添加功能缺失：该插件本身并未提供集成Logo图像到二维码中心的功能。如果需要带有Logo的二维码，需要额外开发或寻找其他支持此功能的库。
3）兼容性问题：在不同浏览器间可能存在兼容性差异，比如在较老版本的IE浏览器（如IE7/8）中生成的二维码图片尺寸可能会与现代浏览器（如Chrome、Firefox等）显示的不同，这可能需要开发者针对特定环境做特殊处理。
4）尺寸和分辨率限制：对于较大的数据量或者更高级别的纠错级别，生成的二维码可能会变得很大，并且由于是基于HTML5 Canvas或DOM元素绘制，可能受限于设备屏幕大小或渲染能力，导致部分区域无法完整显示。
5）性能优化不足：在某些低性能设备上，尤其是在大量生成或频繁更新二维码的情况下，JS实时生成可能比服务器端生成和返回静态图片的方式效率更低。
6）功能相对基础：相比于一些更全面的库，qrcode 提供的功能较为基础，例如缺乏高级定制选项，如颜色自定义、样式美化等。
4、相关方法 关于API的详细使用方法和Option配置项，可参看：https://www.npmjs.com/package/qrcode#api
浏览器端 ​ 1）create(text, [options])，创建二维码并返回一个qrcode对象。
​ 2）toCanvas(text, [options], [cb(error, canvas)]), 将二维码绘制到画布上。
​ 3）toDataURL(canvasElement, text, [options], [cb(error, url)])，返回一个数据 URI，其中包含二维码图像的格式，这种方法也是使用 Canvas作为画布来生成数据 URI。
​ 4）toString(text, [options], [cb(error, string)])，返回二维码的字符串格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c4a9681c5fe8436c4f8352ad472e1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8404b5df60cea807c65cd5c5346a9334/" rel="bookmark">
			Stable Diffusion【ControlNet】：改善画质细节的tile模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是程序员晓晓。
在ControlNet中，有一个模型叫做Tile, 翻译成中文为"瓷砖，瓦片"。在SD Web UI工具中经常翻译为“分块”,它的主要作用是在保持图片整体布局的基础上给照片添加细节。基于这个特性，经常结合各种插件做图片的精细放大处理，用于对图片进行高清修复改善画质。另外它还有一个很重要的功能，就是用来转换图片风格，比如真人漫改，漫改真人、各种艺术字制作等。今天我们重点来看一下使用这个插件进行图片的高清处理以及细节处理。
一. Tile模型介绍
在上图中，tile模型的控制类型是Tile/Blur（分块/模糊）。这是由于在1.1.410版本后，引入了Blur预处理器，该处理器主要用于调整图片的模糊度。
二. 应用场景1：图片的高清修复
我们下面来看一下使用tile模型进行图片的高清修复。这里使用图生图的方式来操作。
【第一步】：图生图图片的上传
下面进行相关参数设置。
采样器：DPM++ 2M Karras
采样迭代步数：30
图片宽高：512*512，我这里原图片宽高是64*64,这里最好调整到512*512，对图片进行等比例放大。
生成数量：2，一次多生成几张，提高抽签概率
重绘强度：设置为0.6，这个参数建议在0.5以上，大家可以多尝试**。**
【第二步】：ControlNet的设置
相关参数设置如下：
控制类型：选择"Tile/Blur"
预处理器：tile_resample
模型：control_xxx_tile
控制权重 : 设置为1
【第三步】提示词的编写
由于使用了图生图，所以我们可以根据画面的内容简单的写一下提示词。
A dog is sitting on the grass。
如果图片比较复杂，可以借助Tagger工具反推出提示词。
【第四步】大模型的选择以及图片的生成
这里我们使用一些通用的写实模型即可。我这里使用的是DreamShaper 8。可以结合自己的图片特点选择对应的大模型。
点击【生成】按钮，最终生成的图片效果如下。
对比一下使用tile模型处理前后的区别。
三. 应用场景2：增加细节
我们直接使用上面生成图片，在文生图中使用tile模型对图片进行处理一下。
我们看一下生成的图片效果，图片增加了更多的细节。
对比一下使用tile模型处理前后的区别。
下面我们添加一些提示词看一下效果。我们在提示词中添加"被五颜六色的鲜花环绕"。
best quality,masterpiece,A dog is sitting on the grass,((surrounded by colorful flowers:1.2)),
再换一下提示词，在提示词中添加"冬天，在雪地里"。
best quality,masterpiece,A dog is sitting in the snow,((winter,It is snowing:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8404b5df60cea807c65cd5c5346a9334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f12b91303e03e6ddd77e7b0bfeb52bef/" rel="bookmark">
			【Spark系列1】DAG中Stage和Task的划分全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、整体流程 每个Aciton操作会创建一个JOB，JOB会提交给DAGScheduler，DAGScheduler根据RDD依赖的关系划分为多个Stage，每个Stage又会创建多个TaskSet，每个TaskSet包含多个Task，这个Task就是每个分区的并行计算的任务。DAGScheduler将TaskSet按照顺序提交给TaskScheduler，TaskScheduler将每一个任务去找SchedulerBackend申请执行所需要的资源，获取到资源后，SchedulerBackend将这些Task提交给Executor，Executor负责将这些任务运行起来。
二、JOB提交 2.1、为什么需要action操作 在Spark中，分为transformation操作和action操作。执行用户程序时，transformation操作将一个RDD转换成了新的RDD，并在compute()函数中，记录了如何根据父RDD计算出当前RDD的数据、RDD如何分区等信息，并且能够得出最后一个RDD的数据。 但是RDD中的每个分区中依然是一条一条的分散的数据，那么要对最后一个RDD执行什么操作呢？这就是action操作的作用。
2.2、Job提交 每个action操作都会生成一个Job，这个Job包含了需要计算的RDD对象、需要计算的分区、需要执行什么样的计算。RDD和用户执行的计算都是可以序列化的，RDD序列化之后，在Executor中反序列化之后即可得到该RDD对象，再根据对象compute()函数就可以计算出某个分区的数据。JOB中包含的数据如下所示
2.3、分布式执行 当提交Job以后，就可以将Job划分为多个并行的任务，每个任务计算指定分区的一个分区即可。通过RDD的计算函数即可计算出该分区的数据，今儿计算出分区的结果。
三、Stage划分 3.1、宽依赖和窄依赖 如果一个RDD的每个分区最多只能被一个Child RDD的一个分区所使用， 则称之为窄依赖（Narrow dependency）， 如果被多个Child RDD分区依赖， 则称之为宽依赖（wide dependency）
3.2、Stage划分 在用户编写的一系列转换中，多个RDD可能既形成了多次窄依赖，也形成了多次宽依赖，连续的窄依赖可以通过一个任务进行流水线处理，但是如果遇到了宽依赖，就必须先将父RDD的所有数据都进行计算并保存起来，再进行RDD的运算。在一个Job中，action操作知识定义了在最后的RDD中执行何种操作，而最后的RDD会依赖上个RDD，上个RDD又会有其他依赖，这样就形成了一系列的依赖关系。如果为宽依赖的话，就在依赖的地方进行切分，先将宽依赖的父RDD进行计算出来，再计算后续的RDD，按照快依赖被划分的过程，即为Stage划分的过程。
如上图所示，rdd1-&gt;rdd2,rdd3-&gt;rdd4是窄依赖，rdd2-&gt;rdd3,rdd4-&gt;rdd5是宽依赖。在发生shuffle的位置，Spark将计算分为两个阶段分别执行，每发生一次shuffle，Spark就将计算划分为先后的两个阶段，如下图
在划分阶段的过程中，对于某个阶段而言其并行的计算任务都完全相同，因此在Job执行的过程中，并行计算就是指每个阶段中任务并行的计算。如在Stage1中，每个分区的数据可以使用一个任务进行计算。10000个分区即可在集群中并行运行10000个任务进行计算。如果集群资源不够，可以将10000个任务依次在集群中运行，直到运行完毕，再进行Stage2的计算。Stage2也会根据分区数启动多个任务并行的加载Stage1生成的数据，完成Stage2的计算。
在一个Job的运行过程中，所有的Stage其实都是为最后一个Stage做准备，因为action操作只需要最后一个RDD的数据。因此最后一个Stage称为ResultStage，之前所有的Stage都是由Shuffle引起的中间计算过程，被称为ShuffleMapStage。其过程如下图
3.3、Spark实现 再Spark实现中，SparkContext将Job提交至DAGScheduler,DAGScheduler获取Job中执行action操作的RDD，将最后执行action操作的RDD划分到最后的ResultStage中，然后遍历该RDD的依赖和所有的父依赖，每遇到宽依赖就将两个RDD划分到两个不同的Stage中，遇到窄依赖就将窄依赖的多个RDD划分到一个Stage中，经过这次操作，一个RDD就划分为有多个依赖关系的Stage。再每个Stage中，所有的RDD之间都是窄依赖的关系，Stage之间的RDD都是宽依赖的关系。DAGScheduler将最初被依赖的Stage提交，计算该Stage中的数据，计算完成后，再将后续的Stage提交，知道最后运行的ResultStage，则整个计算Job完成。ResultStage和ShuffleMapStage结构如下图
在生成ShuffleapStage时，ShuffleDependency起到了承上启下的作用，如果两个RDD之间为宽依赖，子RDD的依赖为ShuffleDependency；在划分Stage的时候，父Stage会保存该ShuffleDependency，以便在执行父Stage的时候，根据ShuffleDependency获取Shuffle的写入器，在子Stage执行的时候，会根据RDD的依赖关系使用相同的ShuffleDependency获取Shuffle的读取器。
在计算过程中，ShuffleMapStage会生成该Stage的结果，为下一个Stage提供数据，计算下一个Stage的RDD的时候，会拉取上一个Stage的计算结果。上一个Stage的计算保存在哪呢？答案是Spark的组件MapOutputTracker。MapOutputTracker也是主从结构，Executor端是MapOutputTrackerWroker，当ShuffleMapStage的任务运行完成后，会通过Executor上的MapOutputTrackerWroker将数据保存的位置发送到Driver上的MapOutputTrackerMaster中。在后续Stage需要上一个Stage的计算结果的时候，就通过MapOutputTrackerMaster询问计算结果的保存位置，进而加载相应的数据。
四、Task划分 DAGScheduler将Job划分为多个Stage之后，下一步就是将Stage划分为多个可以在集群中并行执行的任务，只有将任务并行执行，Stage才能更快的完成。
4.1、任务的个数 由于Stage中都是对RDD的计算，RDD又是分区的，所以在对任务进行划分的时候，每个分区可以启动一个任务进行计算。无论是ResultStage还是ShuffleMapStage，每个阶段能够并行执行的任务数量都取决于该阶段中最后一个Rdd的分区数量
上面已经介绍，在一个Stage中，RDD的依赖关系是窄依赖，所以最后一个RDD的分区数量取决于其依赖的RDD的分区数量，一直依赖到该阶段的开始的RDD的分区。对于第一阶段开始的RDD分为两种情况：
第一种为初始的RDD，即从数据源加载数据形成的初始RDD，这种情况的分区数量取决于初始RDD的形成分区方式。第二种为该阶段的初始RDD为Shuffle阶段的Reduce任务，这种情况下，该RDD的分区数量取决于在Shuffle的Map阶段最后一个RDD的分区器设置的分区数量。 4.2、Task的生成 当确定了每个Stage的分区数量之后，就需要为每个分区生成相应的计算任务，该计算任务就是需要对该阶段的最后一个RDD执行什么操作
在ResultStage中，需要对最后一个RDD的每个分区分别执行用户自定义的action操作，所以在ResultStage中生成的每个Task都包含以下三个部分
需要对哪个RDD进行操作需要对RDD哪个分区进行操作需要对分区的内容执行什么样的操作 在ResultStage中划分的Task称为ResultTask，ResultTask中包含了ResultStage中最后一个RDD，即执行action操作的的RDD，需要计算的RDD分区的id和执行action操作的函数。
在ShuffleMapStage中，最终需要完成Shuffle过程中的Map阶段的操作，每个分区按照Shuffle中的Map端定义的过程执行数据的分组操作，将分组结果进行保存，并将保存结果位置通知Driver端的MapOutputTrackerMaster，MapOutputTrackerMaster保存着每一个Shuffle中Map输出的位置。在ShuffleMapStage中划分的Task称为ShuffleMapTask。ShuffleMapTask同样由三个重要的部分组成：Stage中最后的RDD、需要计算的分区的id、划分Stage的ShuffleDependency
4.3、Task的最佳运行位置 生成Task时，还会计算Task的最佳运行位置。虽然RDD包含计算RDD的所有信息，可以在任何节点上运行，但是如果通过为Task计算分配最佳的运行位置，可以将Task调度到含有该Task需要的数据的节点，从而实现移动计算而不是移动数据的目的。Spark会根据RDD可能分布的的情况，将Task的运行位置主要分为Host级别和Executor级别。当一个RDD被某个Executor缓存，则对该RDD计算时，优先会把计算的Task调度到该Executor中执行。当一个RDD需要的数据存在某个host中时，则会把该Task调度到这个节点的Executor中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531e9344cfa9d15d3b2e20e6cacad2af/" rel="bookmark">
			疑似ai写作怎么解决，解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的飞速发展，疑似AI写作的问题也日益凸显。如何有效解决这一问题，成为了当前亟待探讨的话题。本文将从七个方面展开讨论，以期为解决疑似AI写作提供一些思路和建议。
一、定义疑似AI写作
疑似AI写作指的是在文本中表现出类似人工智能的写作风格或模式，但实际上可能并非由人类作者所写。这种写作风格通常缺乏人类情感、个人特色以及文化背景等方面的元素。
二、探究原因
造成疑似AI写作的原因主要有两个方面。一是随着人工智能技术的普及，越来越多的工具可以帮助人们快速生成文本，导致一些人滥用这些工具，使得文本缺乏人类情感和思考。二是现代社会信息爆炸，人们为了追求效率和速度，往往忽视了对文本质量和原创性的要求，从而产生了大量疑似AI写作的文本。
三、辨识方法
要辨识疑似AI写作，可以从以下几个方面入手。一是观察文本的语言表达，看是否符合人类语言的习惯和逻辑；二是分析文本的主题和内容，看是否具有深度和广度；三是考虑作者的背景和风格，看是否与文本内容相符；四是利用技术手段进行检测，如使用自然语言处理和机器学习算法等。
四、应对策略
针对疑似AI写作的问题，我们可以采取以下策略。一是加强教育引导，提高人们对文本质量和原创性的认识；二是鼓励作者发挥个人特色和文化背景，避免过度依赖工具生成文本；三是建立评价体系，对疑似AI写作进行评估和筛选；四是加强技术研发，提高人工智能生成文本的可信度和质量。
五、案例分析
以某在线翻译平台为例，该平台提供了快速翻译服务，但由于过度依赖机器翻译，导致生成的文本往往缺乏人类语言的情感和文化元素。这不仅影响了用户体验，还可能对信息传播造成负面影响。因此，该平台需要加强技术研发和人工审核，提高机器翻译的质量和可信度。
六、未来展望
随着人工智能技术的不断发展，疑似AI写作的问题也将持续存在。未来我们需要进一步探索如何平衡人工智能的效率和人类的创造力，同时加强对疑似AI写作的研究和评估，以期在技术和文化层面上找到更好的解决方案。同时，我们也需要关注人工智能的伦理和社会问题，确保其在推动社会进步的同时，不会对人类文化和思想造成负面影响。
七、结语
疑似AI写作是一个复杂的问题，需要我们从多个方面入手解决。通过加强教育引导、鼓励作者发挥个人特色和文化背景、建立评价体系以及加强技术研发等措施，我们可以有效地减少疑似AI写作的出现。同时，我们也需要持续关注人工智能的发展趋势和挑战，以期在未来的发展中找到更好的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a1d8c260e9b302570648032f5f2c9bd/" rel="bookmark">
			Android中下载 HAXM 报错 Intel® HAXM installation failed，如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在搭建 Flutter 环境，但是在 Android Studio 中安装 Virtual Device 时，出现了一个 问题 Intel® HAXM installation failed. To install Intel® HAXM follow the instructions found at: https://github.com/intel/haxm/wiki/Installation-Instructions-on-Windows 一直提示HAXM 下载失败。
网上查了各种办法，我来说一下我的解决步骤，适合新手小白去解决。
此次显示设备：Window 10 操作系统 + Android Studio
1. 验证虚拟化支持 我这里失败的主要原因就是 Hyper-V 要求: 固件中已启用虚拟化: 是， 一开始是 否 的，所以导致一直下载不上。
1.1 先查看设备是否开启虚拟化支持 以管理员身份打开命令提示符：Win + R -&gt; cmd输入 systeminfo 按 enter向下滚动至 Hyper-V要求 部分，就像我上面截的图确保在固件中启用虚拟化 设置为 是如果设置为 否，则需要在 BIOS 设置中 启用虚拟化 。方法如下： 重启电脑。在启动期间访问 BIOS 设置（通常通过按F2、F12或Del等键）。查找虚拟化设置（通常标记为 VT-x 或 Virtualization Technology），这一步要提醒一下，设备不同，主板不同，文件目录也不一样，一定要先查看主板型号！！！启用虚拟化并保存 BIOS 设置。重启电脑 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a1d8c260e9b302570648032f5f2c9bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f116532ca86576be05e4533559cd580/" rel="bookmark">
			用python实现调用百度文心一言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要使用Python调用百度文心一言，你需要使用百度提供的API。具体步骤如下：
前往百度AI开放平台官网，注册并创建一个应用。在创建应用时，你需要填写相关信息，并选择你要使用的API服务。在创建应用后，你会获得一个API密钥。这个密钥是用来验证你的应用身份的，确保你的应用能够正确地调用API。使用Python编写代码，调用百度文心一言的API。你可以使用requests库来发送HTTP请求，并使用JSON库来处理返回的JSON数据。在代码中，你需要指定API的URL、请求方法（GET或POST）、请求头（包括API密钥）和请求参数（根据具体API的要求而定）。发送请求后，你会获得一个JSON响应。你需要解析这个响应，提取你需要的数据。 以下是一个简单的Python代码示例，用于调用百度文心一言的文本生成API：
python复制代码
import requests import json # 填写你的API密钥 api_key = 'your_api_key' # 填写你要调用的API的URL api_url = 'https://api.ai.baidu.com/gensim/api/v1/gensim/text/generate' # 填写请求参数 params = { 'text': 'Hello, world!', # 要生成的文本 'n_sentences': 1, # 生成句子的数量 'n_words': 50, # 每个句子的单词数量 'embedding_dim': 300, # 嵌入向量的维度 'model_name': 'ERNIE2.0', # 使用的模型名称 } # 发送GET请求 response = requests.get(api_url, params=params, headers={'Authorization': api_key}) # 解析响应JSON数据 data = json.loads(response.text) # 提取生成的文本 generated_text = data['data'] print(generated_text) 请注意，这只是一个简单的示例代码，具体的请求参数和响应数据结构可能会根据所使用的API而有所不同。你需要参考百度文心一言的官方文档，了解更多关于API的使用方法和数据结构的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9daa09a338affa15ac18e05169eda4a0/" rel="bookmark">
			Mac下查看、配置和使用环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac下查看、配置和使用环境变量 一：Mac怎么查看环境变量命令 printenv 一：这个命令会一次性列出所有环境变量的键值对，输出格式为： VAR1=value1 VAR2=value2 ... 二： 也可以通过给这个命令加上环境变量名参数，只查看指定的环境变量的值；或者使用 echo $VAR 命令查看指定环境变量的值 printenv VAR echo $VAR 二：Mac查看环境变量在哪个文件配置 通常情况下，环境变量是在 Shell 配置文件中设置的。Mac上默认的 Shell 是 bash，所以在这里以 bash 的配置文件为例：
如果是系统级别的全局环境变量，则在文件 /etc/bashrc 中进行设置。如果是用户级别的自定义环境变量，则在文件 ~/.bash_profile 中进行设置。 补： 打开终端,输入命令"open ~/.bash_profile",即可打开环境变量文件;在open的文件中,可以查看、设置和修改电脑上的环境变量;修改完毕后,点击文件上方的"保存"按钮,即可保存修改的环境变量。 三：Mac怎么配置环境变量 一：可以直接在终端中使用 export 命令添加环境变量： 系统全局环境变量的配置：
修改文件 /etc/bashrc，添加环境变量定义。
例如添加环境变量JAVA_HOME：
export JAVA_HOME=/usr/libexec/java_home 用户级别的自定义环境变量配置：
修改文件 ~/.bash_profile，添加环境变量定义。
例如添加环境变量ANDROID_HOME：
export ANDROID_HOME=~/Library/Android/sdk 二：可以在 .bash_profile 中添加环境变量的定义，并在终端中运行 source ~/.bash_profile 命令使其生效 在 .bash_profile 中添加环境变量的定义。
例如添加环境变量ANT_HOME：
export ANT_HOME=/usr/local/ant 添加完毕之后，记得执行下面这个命令，使之立即生效：
source ~/.bash_profile 四：Mac怎么更改环境变量 更改环境变量的值和添加环境变量的定义类似，只需要重新赋值即可。
例如更改环境变量 JAVA_HOME 的值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9daa09a338affa15ac18e05169eda4a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2af13fe7ed8b3d86d1da6ff33ef08b5/" rel="bookmark">
			算法沉淀——滑动窗口（leetcode真题剖析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法沉淀——滑动窗口 01.长度最小的子数组02.无重复字符的最长子串03.最大连续1的个数 III04.将 x 减到 0 的最小操作数05.水果成篮06.找到字符串中所有字母异位词07.串联所有单词的子串08.最小覆盖子串 滑动窗口算法是一种用于解决数组或列表中子数组或子序列问题的有效技巧。它通过维护一个可变大小的窗口（通常是一个连续的子数组或子序列），在数据流中滑动该窗口来进行问题求解。这种方法在一维数组和二维数组中都有应用，并且在字符串处理中也很常见。 滑动窗口算法的基本思想是使用两个指针，通常是左指针（left）和右指针（right）来定义窗口，通过移动这两个指针，调整窗口的大小和位置，从而在不重复计算的情况下找到问题的解。
以下是滑动窗口算法的一般步骤：
初始化窗口： 定义左指针和右指针，并将窗口初始化为满足问题条件的初始状态。移动窗口： 不断移动右指针，扩展窗口大小，直到不再满足问题条件为止。调整窗口： 一旦窗口不再满足问题条件，开始移动左指针，缩小窗口大小，直到满足问题条件为止。记录解： 在窗口移动的过程中，记录满足问题条件的解。 滑动窗口算法适用于一些问题，例如：
子数组和子序列的最大/最小值： 在数组中找到满足条件的子数组或子序列的最大或最小值。子数组和子序列的和或平均值： 在数组中找到满足条件的子数组或子序列的和或平均值。字符串处理问题： 如找到最小覆盖子串、找到没有重复字符的最长子串等。 下面我们通过几个真题来学习这个算法
01.长度最小的子数组 题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：
输入：target = 4, nums = [1,4,4] 输出：1 示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 思路
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2af13fe7ed8b3d86d1da6ff33ef08b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dbe783551b2af69856821fa4194624e/" rel="bookmark">
			win11设置mysql开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
命令式 1、打开命令提示符或 PowerShell：
2、使用管理员权限运行命令行工具：
3、设置 MySQL 服务为开机自启动：
4、启动 MySQL 服务：
5、 验证设置是否生效：
操作视图式
1、右击任务栏 ---&gt; 选择任务管理器 2、选择服务---&gt;打开服务
3、找到 MySQL 服务。通常服务名称为 "MySQL" 或 "MySQL80"
4、应用设置并重启系统：
命令式 要通过命令行方式设置 MySQL 在 Windows 11 上的开机自启动，你可以按照以下步骤进行操作：
1、打开命令提示符或 PowerShell： 使用快捷键 Win + R 打开运行框。在运行框中输入 "cmd" 或 "powershell" 并按 Enter 键，打开相应的命令行工具。 2、使用管理员权限运行命令行工具： 在开始菜单中找到命令提示符或 PowerShell，并右键点击。选择 "以管理员身份运行"，以获取足够的权限执行命令。 3、设置 MySQL 服务为开机自启动： 在命令行中输入以下命令并按 Enter 键： sc config mysql start= auto 4、启动 MySQL 服务： 在命令行中输入以下命令并按 Enter 键： net start mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dbe783551b2af69856821fa4194624e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8c73f22f46e0c5d317b5504e0bd34d/" rel="bookmark">
			解密人工智能：探索机器学习奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：聆风吟
🔥系列专栏：网络奇遇记、数据结构
🔖少年有梦不应止于心动，更要付诸行动。
文章目录 📋前言一. 机器学习的定义二. 机器学习的发展历程三. 机器学习的原理四. 机器学习的分类3.1 监督学习3.2 无监督学习3.3 半监督学习3.4 强化学习3.5 四种分类对比 五. 机器学习的应用场景六. 机器学习的未来发展趋势📝全文总结 📋前言 机器学习（Machine Learning）是一种让计算机通过数据自动学习的技术。它可以让计算机从数据中自动学习规律和模式，并根据这些规律和模式进行预测和决策。
一. 机器学习的定义 机器学习是一种让计算机能够通过经验和数据自我改进的技术。在机器学习中，计算机通过对训练数据的分析和学习，可以自动地发现数据中的规律和模式，并根据这些规律和模式进行预测和决策。机器学习的目标是让计算机具有类似人类的智能能力，能够自主地学习和适应新的任务和环境。
它可以让计算机从数据中自动学习规律和模式，并根据这些规律和模式进行预测和决策。机器学习技术已经成为人工智能领域的核心技术之一，被广泛应用于图像识别、语音识别、自然语言处理、推荐系统、金融风控、医疗诊断等领域。
二. 机器学习的发展历程 机器学习的发展历程可以分为以下几个阶段：
规则制定阶段(1950年代-1980年代)： 在这个阶段，机器学习主要依靠人工设计和制定规则来进行预测和决策。这种方法的优点是简单可靠，但是缺点是需要大量的人工工作和专业知识。
统计学习阶段(1980年代-2000年代)： 在这个阶段，机器学习开始引入统计学的概念和技术，例如线性回归、逻辑回归等。这种方法的优点是可以自动发现数据的规律和模式，但是缺点是需要大量的数据和计算资源。
深度学习阶段(2000年代-现在)： 在这个阶段，机器学习开始引入深度学习的概念和技术，例如卷积神经网络(CNN)、循环神经网络(RNN)等。这种方法的优点是可以自动地从数据中学习和提取高层次的特征表示，但是缺点是需要大量的数据和计算资源，并且容易出现过拟合等问题。
三. 机器学习的原理 机器学习是一种通过训练数据来让机器自动学习和改进性能的方法。它的原理可以概括为以下几个步骤：
数据收集和准备：机器学习的基石是数据。系统需要大量的数据来学习和进行模型训练。这包括收集、清洗和处理数据，确保数据质量和适用性。
特征提取和选择：从收集的原始数据中抽取和表示有意义的特征是机器学习的关键。特征提取的目标是将原始数据转化为对算法更有用的形式，以便更好地进行模型训练和预测。
模型选择和训练：选择适当的机器学习模型来拟合数据。常见的机器学习模型包括线性回归、逻辑回归、决策树、支持向量机、神经网络等。然后使用训练数据对模型进行训练，通过调整模型的参数来最小化预测误差。
模型评估和调优：使用测试数据对训练好的模型进行评估。常用的评估指标包括准确率、精确度、召回率、F1值等。如果模型的性能不满意，可以通过调整模型的超参数或使用更复杂的模型来改进性能。
模型应用和预测：对新的未见过的数据进行预测。通过将输入数据输入到训练好的模型中，模型将输出相应的预测结果。
总的来说，机器学习的原理是通过训练数据来构建一个数学模型，然后利用该模型对新的未知数据进行预测或分类。通过不断的训练和调优，模型可以逐渐提高性能，并应用于实际问题中。
四. 机器学习的分类 机器学习可分为多个主要类别，每种类别都在不同应用领域展现出独特的优势。以下是机器学习主要的分类方式：
3.1 监督学习 定义：监督学习是从有标签的训练数据中学习模型，然后对某个给定的新数据利用模型预测它的标签。如果分类标签精确度越高，则学习模型准确度越高，预测结果越精确。监督学习主要用于回归和分类：
常见的监督学习的回归算法有：线性回归、回归树、K邻近、Adaboost、神经网络等。
常见的监督学习的分类算法有：朴素贝叶斯、决策树、SVM、逻辑回归、K邻近、Adaboost、神经网络等。
应用：常见于分类和回归问题，如图像识别、语音识别、房价预测等。
3.2 无监督学习 定义：无监督学习中，模型在没有标签的情况下从数据中学习模式和结构。目标是发现数据的内在结构或关系。无监督学习主要用于关联分析、聚类和降维。 常见的无监督学习算法有聚类算法（如k-means、DBSCAN）、主成分分析（PCA）等。
应用：常见于聚类、降维、关联规则挖掘等，如客户分群、主题模型等。
3.3 半监督学习 定义：监督学习是介于监督学习和无监督学习之间的一种学习方式。半它使用一部分带有标签的训练样本和一部分没有标签的训练样本进行学习。半监督学习侧重于在有监督的分类算法中加入无标记样本来实现半监督分类。
应用：在标注数据有限的情况下，通过更充分利用未标注数据提升模型性能。
3.4 强化学习 定义： 强化学习中，模型通过与环境的交互学习，根据行为的反馈来调整策略，以最大化累积奖励。在强化学习中，智能体与环境交互，通过采取不同的动作来观察环境的反馈，然后根据反馈来更新策略。常见的强化学习算法包括Q学习、策略梯度等。
应用：应用： 适用于决策场景，如游戏策略、自动驾驶、机器人控制等。
3.5 四种分类对比 为了便于读者理解，用灰色圆点代表没有标签的数据，其他颜色的圆点代表不同的类别有标签数据。监督学习、半监督学习、无监督学习、强化学习的示意图如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f8c73f22f46e0c5d317b5504e0bd34d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2efb9eccad6af40015c2c4076edc10/" rel="bookmark">
			数据仓库内容分享(七)：Flink CDC 实现海量数据实时同步转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
CDC 概念回顾
对比常见的开源 CDC 方案
传统 CDC ETL
Flink CDC
Flink CDC ETL
CDC 概念回顾 CDC 的全称是 Change Data Capture ，在广义的概念上，只要是能捕获数据变更的技术，我们都可以称之为 CDC 。目前通常描述的 CDC 技术主要面向数据库的变更，是一种用于捕获数据库中数据变更的技术。CDC 技术的应用场景非常广泛：
数据同步：用于备份，容灾； 数据分发：一个数据源分发给多个下游系统； 数据采集：面向数据仓库 / 数据湖的 ETL 数据集成，是非常重要的数据源。 CDC 的技术方案非常多，目前业界主流的实现机制可以分为两种：
基于查询的 CDC：离线调度查询作业，批处理。把一张表同步到其他系统，每次通过查询去获取表中最新的数据；无法保障数据一致性，查的过程中有可能数据已经发生了多次变更；不保障实时性，基于离线调度存在天然的延迟。
基于日志的 CDC：实时消费日志，流处理，例如 MySQL 的 binlog 日志完整记录了数据库中的变更，可以把 binlog 文件当作流的数据源；保障数据一致性，因为 binlog 文件包含了所有历史变更明细；保障实时性，因为类似 binlog 的日志文件是可以流式消费的，提供的是实时数据。
对比常见的开源 CDC 方案 对比增量同步能力，基于日志的方式，可以很好的做到增量同步；而基于查询的方式是很难做到增量同步的。
对比全量同步能力，基于查询或者日志的 CDC 方案基本都支持，除了 Canal。
而对比全量 + 增量同步的能力，只有 Flink CDC、Debezium、Oracle Goldengate 支持较好。
从架构角度去看，该表将架构分为单机和分布式，这里的分布式架构不单纯体现在数据读取能力的水平扩展上，更重要的是在大数据场景下分布式系统接入能力。例如 Flink CDC 的数据入湖或者入仓的时候，下游通常是分布式的系统，如 Hive、HDFS、Iceberg、Hudi 等，那么从对接入分布式系统能力上看，Flink CDC 的架构能够很好地接入此类系统。 在数据转换 / 数据清洗能力上，当数据进入到 CDC 工具的时候是否能较方便的对数据做一些过滤或者清洗，甚至聚合？在 Flink CDC 上操作相当简单，可以通过 Flink SQL 去操作这些数据；但是像 DataX、Debezium 等则需要通过脚本或者模板去做，所以用户的使用门槛会比较高。 另外，在生态方面，这里指的是下游的一些数据库或者数据源的支持。Flink CDC 下游有丰富的 Connector，例如写入到 TiDB、MySQL、Pg、HBase、Kafka、ClickHouse 等常见的一些系统，也支持各种自定义 connector。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b2efb9eccad6af40015c2c4076edc10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a590be10b858c2c6a82bc82fd2fcff4/" rel="bookmark">
			数学建模入门笔记(2) 聚类分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚类分析 ​ 聚类分析（Cluster Analysis）：又称群分析，对多个样本/指标定量分类的多元分析方法，是无监督学习
1 聚类分析的分类 ​ Q型聚类（Qualitative Clustering）：也称硬聚类，一般用于将样本聚类，每一簇之间无交集，用距离作为相似性度量，包括 K-Means聚类、层次聚类、DBSCAN聚类 等
​ R型聚类（Qualitative Clustering）：也称软聚类或模糊聚类，一般用于将指标聚类，每一簇之间有交集，用相关系数/夹角余弦等作为相似性度量，包括 Fuzzy C-Means聚类、Possibilistic C-Means聚类 等
a. http://t.csdnimg.cn/X0jnX
b. Q聚类针对个案，适合个体预测，诊断，分型之类的；R聚类针对指标，适合指标归类、降维之类的。
2 Q型聚类的相似性度量 2.1 样本距离的计算方式 1. 闵氏距离（Minkowski Distance） d q ( x , y ) = [ ∑ k = 1 p ∣ x k − y k ∣ q ] 1 q , q &gt; 0 , d_q(\boldsymbol{x}, \boldsymbol{y})=\left[\sum_{k=1}^p\left|x_k-y_k\right|^q\right]^{\frac{1}{q}}, q&gt;0, dq​(x,y)=[k=1∑p​∣xk​−yk​∣q]q1​,q&gt;0,
​ 当 q = 1 , 2 q=1,2 q=1,2 或 q → + ∞ q\rightarrow+\infty q→+∞ 时,则分别得到:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a590be10b858c2c6a82bc82fd2fcff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d5f83660790e156ae063a249765b9f5/" rel="bookmark">
			基于Python&#43;大数据的线上教育平台数据分析系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💗博主介绍：✌全网粉丝10W+,CSDN全栈领域优质创作者，博客之星、掘金/华为云/阿里云等平台优质作者。
👇🏻 精彩专栏 推荐订阅👇🏻
计算机毕业设计精品项目案例-200套
🌟文末获取源码+数据库+文档🌟
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以和学长沟通，希望帮助更多的人
一.前言 随着互联网技术的不断和快速发展，网络与大数据很早就成为了人们生活中的一部分，线上教育平台大数据分析由于其特有的便捷性，用户能够更加容易地接受。互联网有了这种便捷调剂信息(阅读量TOP10)、访问信息等分析形式，也是一种新型的全新应用形式[3]。从侧面来看，线上教育平台大数据分析还能够推进网上用户查看爬取下的大数据调剂信息的普及。
同传统的人工统计数据模式相比，线上教育平台大数据分析具有较多的优势。建立规范化的流程通常可以解决用户查询阅读量统计、发布时间统计、地区访问量统计、访问类型统计、调剂信息(阅读量TOP10）分析问题，而目前如果需要管理网站爬取下的大数据，管理员依然以人工的方式进行管理的话太过于落后。线上教育平台大数据分析处理数据越来越趋于信息化，这种模式需要依赖于智能化手段管理。随着科技发展的进步与大数据的普及，信息技术能够改善我们的生活，现在许多生活场景都需要信息化技术帮助改善我们的生活。
本课题就是以线上教育系统爬取为例，介绍网络爬虫的基本原理，Python环境的搭建，PyCharm scrapy模块的爬虫数据的运用，把获取到的数据进行清洗、整合，储存数据到MySQL，然后进行数据可视化的呈现，简单对呈现的图进行数据分析。
二.技术环境 开发语言：Python
python框架：django
软件版本：python3.7/python3.8
数据库：mysql 5.7或更高版本
数据库工具：Navicat11
爬虫框架：Scrapy
开发软件：PyCharm/vs code
前端框架:vue.js
三.功能设计 系统功能结构图是系统设计阶段，系统功能结构图只是这个阶段一个基础，整个系统的架构决定了系统的整体模式，是系统的根据。线上教育平台数据分析系统的整个设计结构如图所示。
四.数据设计 概念模型的设计是为了抽象真实世界的信息，并对信息世界进行建模。它是数据库设计的强大工具。数据库概念模型设计可以通过E-R图描述现实世界的概念模型。系统的E-R图显示了系统中实体之间的链接。而且Mysql数据库是自我保护能力比较强的数据库，下图主要是对数据库实体的E-R图：
五.部分效果展示 系统管理员功能实现效果 管理员要登录线上教育平台大数据分析，需要输入账号和密码，进行登录，管理员登录界面如图所示。
管理员登录进入线上教育平台大数据分析可以查看系统首页、个人中心、调剂信息管理、访问信息管理、访问类型管理、系统管理等功能，进行详细操作，如图所示。
管理员点击调剂信息管理；在调剂信息管理页面输入来源、学校名、标题、阅读量、发布时间、分类等信息，进行查询，爬起数据或删除调剂信息等操作；如图所示。
管理员点击访问信息管理；在访问信息管理页面输入访问编号、访问地区、访问量、访问类型、更新时间等信息，进行查询，新增、导入或删除访问信息等操作；如图所示。
管理员点击访问类型管理；在访问类型管理页面输入访问类型等信息，进行查询、新增或删除访问类型等操作；如图所示。
管理员点击系统管理；在系统管理页面对系统简介等信息，进行查询或修改系统信息等操作；如图所示。
数据可视化分析大屏展示实现效果 线上教育平台分析系统展示图，如图所示。
下面展示是阅读量统计，对于阅读量统计大数据，数据获取之后，开始对这些数据进行可视化分析，首先是阅读量统计的基本情况，其中根据爬取的数据以饼状图的形式来展示，如图所示。
下面展示是发布时间统计，对于发布时间统计大数据获取之后，开始对这些数据进行可视化分析，首先通过页面查看发布时间统计详情进行展示，如图所示。
在地区访问量统计页面以条形图进行展示所示。
下图是访问类型统计，通过python爬取清洗后的数据以饼状图形式展示如图所示：
下图是调剂信息(阅读量TOP10)，通过python爬取清洗后的数据以信息表形式展示如图所示：
六.部分功能代码 # 数据爬取文件 import scrapy import pymysql import pymssql from ..items import TiaojixinxiItem import time import re import random import platform import json import os from urllib.parse import urlparse import requests import emoji # 调剂信息 class TiaojixinxiSpider(scrapy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d5f83660790e156ae063a249765b9f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1123dd18557b111404da60c560e1a024/" rel="bookmark">
			Python中bs4的soup.find()和soup.find_all()用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 我们在使用python对网页爬虫的时候，经常会得到一些html数据，因此我们就会利用soup.find()和soup.find_all()方法来筛选出想要的数据。
二、用法 1.soup.find() 1.1利用name来查找 代码如下：
from bs4 import BeautifulSoup html_string = """&lt;div&gt; &lt;h1 class="item" id="x1"&gt;蔡x坤&lt;/h1&gt; &lt;ul class="item" id="x2"&gt; &lt;li&gt;唱&lt;/li&gt; &lt;li&gt;跳&lt;/li&gt; &lt;li&gt;rap&lt;/li&gt; &lt;li&gt;篮球&lt;/li&gt; &lt;/ul&gt; &lt;div class="item "id='x3'&gt; &lt;span&gt;你干嘛&lt;/span&gt; &lt;a href="www.xxx.com" class='info'&gt;ikun.com&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;""" soup = BeautifulSoup(html_string, features="html.parser") #利用name来查找 tag_list=soup.find(name="h1") print(tag_list) 结果如下：
&lt;h1 class="item" id="x1"&gt;蔡x坤&lt;/h1&gt;
1.2利用属性attrs来寻找 代码如下：
html_string = """&lt;div&gt; &lt;h1 class="item" id="x1"&gt;蔡x坤&lt;/h1&gt; &lt;ul class="item" id="x2"&gt; &lt;li&gt;唱&lt;/li&gt; &lt;li&gt;跳&lt;/li&gt; &lt;li&gt;rap&lt;/li&gt; &lt;li&gt;篮球&lt;/li&gt; &lt;/ul&gt; &lt;div class="item "id='x3'&gt; &lt;span&gt;你干嘛&lt;/span&gt; &lt;a href="www.xxx.com" class='info'&gt;ikun.com&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;""" soup = BeautifulSoup(html_string, features="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1123dd18557b111404da60c560e1a024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e823f360caf7ff584d32530eec8c0442/" rel="bookmark">
			HBase数据类型：基本数据类型和复合数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 HBase是一个分布式、可扩展、高性能的列式存储系统，基于Google的Bigtable设计。HBase提供了一种高效的数据存储和查询方式，支持大规模数据的读写操作。在HBase中，数据类型是一种重要的概念，用于描述存储在HBase表中的数据的结构和类型。在本文中，我们将讨论HBase数据类型的基本数据类型和复合数据类型，以及它们在HBase中的应用和实现。
1.背景介绍 HBase数据类型是指存储在HBase表中的数据的基本结构和类型。HBase支持多种数据类型，包括基本数据类型和复合数据类型。基本数据类型包括字符串、整数、浮点数、布尔值等，用于存储简单的数据值。复合数据类型则包括列族、列和单元格等，用于存储复杂的数据结构。
2.核心概念与联系 在HBase中，数据类型的核心概念包括基本数据类型和复合数据类型。基本数据类型用于存储简单的数据值，如字符串、整数、浮点数、布尔值等。复合数据类型则用于存储复杂的数据结构，如列族、列和单元格等。这些数据类型之间存在着紧密的联系，可以通过相互关联和组合来实现更复杂的数据存储和查询需求。
2.1基本数据类型 基本数据类型在HBase中用于存储简单的数据值。常见的基本数据类型包括：
字符串(String)：用于存储文本数据，如名称、描述等。整数(Int)：用于存储整数数据，如计数、编号等。浮点数(Float)：用于存储小数数据，如金额、比率等。布尔值(Boolean)：用于存储逻辑值，如是否、有效等。 2.2复合数据类型 复合数据类型在HBase中用于存储复杂的数据结构。常见的复合数据类型包括：
列族(Column Family)：列族是HBase表中数据的组织方式，用于存储一组相关的列。列族是HBase表中数据的基本组织单位，每个列族对应一个数据节点。列(Column)：列是HBase表中数据的基本单位，用于存储一组相关的单元格。列可以包含多个单元格，每个单元格对应一个数据值。单元格(Cell)：单元格是HBase表中数据的基本单位，用于存储一组相关的数据值。单元格包含一个键(Row Key)、一个列(Column)和一个值(Value)。 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 在HBase中，数据类型的核心算法原理和具体操作步骤如下：
3.1基本数据类型的存储和查询 基本数据类型的存储和查询在HBase中是相对简单的。存储基本数据类型的数据，可以通过将数据值赋值给相应的列和单元格。查询基本数据类型的数据，可以通过使用相应的列和单元格的键值对来获取数据值。
3.2复合数据类型的存储和查询 复合数据类型的存储和查询在HBase中则需要更复杂的算法原理和操作步骤。存储复合数据类型的数据，需要将数据值分别赋值给相应的列和单元格，并将这些列和单元格组合在一起。查询复合数据类型的数据，需要通过使用相应的列和单元格的键值对来获取数据值，并将这些数据值组合在一起。
3.3数学模型公式详细讲解 在HBase中，数据类型的数学模型公式主要包括：
基本数据类型的存储和查询公式：$$ V = f(C, R, C') $$，其中V是数据值，C是列，R是行键，C'是列。复合数据类型的存储和查询公式：$$ V = f(C1, C2, ..., Cn, R, C'1, C'2, ..., C'm) $$，其中V是数据值，C1, C2, ..., Cn是列，R是行键，C'1, C'2, ..., C'm是列。 4.具体最佳实践：代码实例和详细解释说明 在HBase中，数据类型的最佳实践包括：
使用合适的基本数据类型来存储简单的数据值，如字符串、整数、浮点数、布尔值等。使用合适的复合数据类型来存储复杂的数据结构，如列族、列和单元格等。使用合适的算法原理和操作步骤来存储和查询数据类型的数据。 以下是一个HBase数据类型的代码实例：
```java import org.apache.hadoop.hbase.HBaseConfiguration; import org.apache.hadoop.hbase.client.HTable; import org.apache.hadoop.hbase.client.Put; import org.apache.hadoop.hbase.client.Result; import org.apache.hadoop.hbase.util.Bytes;
public class HBaseDataTypeExample { public static void main(String[] args) throws Exception { // 创建HBase配置 Configuration conf = HBaseConfiguration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e823f360caf7ff584d32530eec8c0442/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29bd0b8a72165132d01c922bc197243/" rel="bookmark">
			数据仓库与多源数据集成的技术与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 数据仓库与多源数据集成是数据科学领域的核心技术，它们为数据分析、报表和业务智能提供了基础设施。在本文中，我们将深入探讨数据仓库与多源数据集成的技术和实践，揭示其核心概念、算法原理、最佳实践和实际应用场景。
1. 背景介绍 数据仓库是一个用于存储、管理和分析大量历史数据的系统，它通常用于支持企业决策和竞争力。多源数据集成则是将来自不同来源的数据整合到一个统一的数据仓库中，以实现数据的一致性、可靠性和易用性。
数据仓库与多源数据集成的主要优势包括：
提高数据分析效率：通过将数据集成到一个中心化的仓库中，可以减少数据查询和分析的时间和成本。提高数据质量：通过将数据来源进行统一管理和清洗，可以提高数据的准确性和一致性。提高决策能力：通过将来自不同来源的数据整合到一个仓库中，可以为企业提供更全面、准确的决策支持。 2. 核心概念与联系 2.1 数据仓库 数据仓库是一个用于存储、管理和分析大量历史数据的系统，它通常包括以下组件：
数据源：来自不同来源的数据，如销售、市场、财务等。数据仓库：一个用于存储和管理数据的数据库系统，如Oracle、SQL Server等。数据仓库管理系统：用于管理数据仓库的软件系统，如Informatica、Microsoft SQL Server Integration Services等。数据仓库应用系统：用于分析和报表的软件系统，如Microstrategy、Cognos等。 2.2 多源数据集成 多源数据集成是将来自不同来源的数据整合到一个统一的数据仓库中的过程，它通常包括以下步骤：
数据源识别：识别并确定需要整合的数据源。数据源连接：连接并访问数据源。数据清洗：对来自不同来源的数据进行清洗和转换。数据集成：将清洗后的数据整合到数据仓库中。数据质量管理：对整合后的数据进行质量管理和监控。 2.3 数据仓库与多源数据集成的联系 数据仓库与多源数据集成是紧密相连的，多源数据集成是实现数据仓库的关键技术。多源数据集成可以帮助数据仓库实现数据的一致性、可靠性和易用性，从而提高数据分析和决策的效率和准确性。
3. 核心算法原理和具体操作步骤及数学模型公式详细讲解 3.1 数据清洗算法 数据清洗是将来自不同来源的数据整合到一个统一的数据仓库中的关键步骤，它通常包括以下操作：
数据类型转换：将来自不同来源的数据类型转换为统一的数据类型。数据格式转换：将来自不同来源的数据格式转换为统一的数据格式。数据值转换：将来自不同来源的数据值转换为统一的数据值。数据去重：将来自不同来源的重复数据去重。数据补全：将来自不同来源的缺失数据补全。 3.2 数据集成算法 数据集成是将清洗后的数据整合到数据仓库中的关键步骤，它通常包括以下操作：
数据导入：将清洗后的数据导入到数据仓库中。数据映射：将来自不同来源的数据映射到数据仓库中的目标表。数据合并：将来自不同来源的数据合并到一个统一的表中。数据索引：为数据仓库中的数据创建索引，以提高查询和分析的效率。数据压缩：为数据仓库中的数据创建压缩，以节省存储空间。 3.3 数据质量管理算法 数据质量管理是确保数据仓库中的数据质量的关键步骤，它通常包括以下操作：
数据质量检查：对数据仓库中的数据进行质量检查，以确保数据的准确性、一致性和完整性。数据质量报告：生成数据质量报告，以帮助数据仓库管理员了解数据质量的问题和解决方案。数据质量改进：根据数据质量报告的结果，采取措施改进数据质量。 4. 具体最佳实践：代码实例和详细解释说明 4.1 数据清洗实例 假设我们有以下两个数据源：
销售数据：包括订单号、客户号、商品号、商品名称、商品价格、数量等字段。客户数据：包括客户号、客户名称、客户地址、客户电话等字段。 我们需要将这两个数据源整合到一个数据仓库中，并进行数据清洗。
sql -- 数据类型转换 SELECT CAST(订单号 AS INT), CAST(客户号 AS INT), CAST(商品号 AS INT), CAST(商品价格 AS DECIMAL(10,2)), CAST(数量 AS INT), 客户名称, 客户地址, 客户电话 FROM 销售数据, 客户数据 WHERE 销售数据.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f29bd0b8a72165132d01c922bc197243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e92816c4a48240912bd6c3a177b4ebdb/" rel="bookmark">
			【人工智能】模糊逻辑推理-洗衣机模糊推理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
理解模糊逻辑推理的原理及特点，熟练应用模糊推理，并以此设计一个洗衣机模糊推理系统。
二、实验原理
模糊推理即以模糊集合论为基础描述工具，对以一般集合论为基础描述工具的数理逻辑进行扩展，从而建立了模糊推理理论。是不确定推理的一种。在人工智能技术开发中有重大意义。
整个模糊推理的过程就是由一组模糊规则出发。许多模糊规则实际上是一组多重条件语句，可以表示为从条件论域到结论论域的模糊关系矩阵R。通过条件模糊向量与模糊关系R的合成进行模糊推理，得到结论的模糊向量，然后采用“清晰化”方法将模糊结论转换为精确量。
三、实验过程记录
已知人的操作经验为：
“污泥越多，油脂越多，洗涤时间越长”；
“污泥适中，油脂适中，洗涤时间适中”；
“污泥越少，油脂越少，洗涤时间越短”
可以得到以下模糊控制规则表
x
y
z
SD
NG
VS
SD
MG
M
SD
LG
L
MD
NG
S
MD
MG
M
MD
LG
L
LD
NG
M
LD
MG
L
LD
LG
VL
其中SD（污泥少）、MD（污泥中）、LD（污泥多）、NG（油脂少）、MG（油脂中）、LG（油脂多）、VS（洗涤时间很短）、S（洗涤时间短）、M（洗涤时间中等）、L（洗涤时间长）、VL（洗涤时间很长）。
假设污泥、油脂、洗涤时间的论域分别为[0,100]、[0,100]、[0,120]，设计模糊推理系统如下：
输入：待洗涤衣物的污泥和油脂
控制对象：洗涤时间
污泥隶属函数：
油脂隶属函数：
时间隶属函数：
Python代码实现：
def Sludge(a):#污泥 sludge=[0,0,0]#默认隶属度为0，依次对应SD,MD,LD if a&lt;0 or a&gt;100: return (print("输入值有误")) elif 0&lt;=a&lt;=50: sludge[0]=(50-a)/50 sludge[1]=a/50 elif 50&lt;a&lt;=100: sludge[1]=(100-a)/50 sludge[2]=(a-50)/50 return sludge def Grease(a):#油脂 grease=[0,0,0]#默认隶属度为0,依次对应NG,MG,LG if a&lt;0 or a&gt;100: return (print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e92816c4a48240912bd6c3a177b4ebdb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/517/">«</a>
	<span class="pagination__item pagination__item--current">518/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/519/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>