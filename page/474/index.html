<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6967913f029297de941a2701faa4d294/" rel="bookmark">
			Oracle lead和lag函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle数据库中的LEAD和LAG函数是窗口函数，它们允许你在查询中访问当前行的下一行（LEAD）或上一行（LAG）的值。这些函数在处理时间序列数据、比较相邻行数据、计算差异等场景中非常有用。
LAG函数的基本语法如下：
LAG(value_expression [, offset] [, default]) OVER ( [PARTITION BY partition_expression] ORDER BY sort_expression [ASC | DESC] ) value_expression：你想要获取前一行值的列。offset：可选参数，指定从当前行向上移动的行数，默认值为1。default：可选参数，当没有足够的行时返回的默认值。如果省略，且没有行可返回时，结果为NULL。PARTITION BY：可选子句，用于指定分区，类似于GROUP BY。ORDER BY：必需子句，用于指定窗口函数计算的排序顺序。 以下是一个使用LAG函数的示例：
假设你有一个名为sales的表，其中包含salesperson（销售人员）、sale_date（销售日期）和amount（销售金额）三个字段。你想要获取每个销售人员在前一天的销售金额。
SELECT salesperson, sale_date, amount, LAG(amount) OVER (PARTITION BY salesperson ORDER BY sale_date) AS prev_amount FROM sales; 在这个查询中，LAG(amount)函数会为每个销售人员获取他们在前一天的销售金额。如果某个销售人员在某一天之前没有销售记录，prev_amount将为NULL。
请注意，LAG函数通常与ORDER BY子句一起使用，以确保结果集的顺序是有意义的。此外，LAG函数在处理分区数据时也非常有用，例如在处理按周或按月分组的数据时。
Oracle数据库中的**LEAD函数**是一个窗口函数，它允许你访问当前行的下一行（或指定偏移量的行）的值。这个函数在处理时间序列数据、预测未来值、比较相邻行数据等场景中非常有用。
LEAD函数的基本语法如下：
LEAD(value_expression [, offset] [, default]) OVER ( [PARTITION BY partition_expression] ORDER BY sort_expression [ASC | DESC] ) value_expression：你想要获取未来行值的列。offset：可选参数，指定从当前行向下移动的行数。默认值为1，表示获取下一行的值。default：可选参数，当没有足够的行时返回的默认值。如果省略，且没有行可返回时，结果为NULL。PARTITION BY：可选子句，用于指定分区，类似于GROUP BY。ORDER BY：必需子句，用于指定窗口函数计算的排序顺序。 以下是一个使用LEAD函数的示例：
假设你有一个名为sales的表，其中包含salesperson（销售人员）、sale_date（销售日期）和amount（销售金额）三个字段。你想要获取每个销售人员在后一天的销售金额。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6967913f029297de941a2701faa4d294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e95c483393b1f4bc611dfd750ee2685/" rel="bookmark">
			问题“Web应用程序[ROOT]似乎启动了一个名为[mysql-cj-abandoned-connection-cleanup]的线程，但未能停止它。这很可能会造成内存泄漏”的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题描述 运行环境如下：
项目版本JDK1.8Tomcat9.0.73IDEA2023.3.2 写了一个SSM Java Web 项目，项目能正常运行，但是在关闭项目时（亦即在IDEA中通过按钮关闭Tomcat 9.0.73服务时），如下了如下警告：
D:\Server\apache-tomcat-9.0.73-windows-x64\apache-tomcat-9.0.73\bin\catalina.bat stop
Using CATALINA_BASE: “C:\Users\Abc\AppData\Local\JetBrains\IntelliJIdea2023.3\tomcat\be4e23eb-1dde-42b0-9e52-853b5050e770”
Using CATALINA_HOME: “D:\Server\apache-tomcat-9.0.73-windows-x64\apache-tomcat-9.0.73”
Using CATALINA_TMPDIR: “D:\Server\apache-tomcat-9.0.73-windows-x64\apache-tomcat-9.0.73\temp”
Using JRE_HOME: “D:\programfiles\BaseTools\Java\jdk-1.8”
Using CLASSPATH: “D:\Server\apache-tomcat-9.0.73-windows-x64\apache-tomcat-9.0.73\bin\bootstrap.jar;D:\Server\apache-tomcat-9.0.73-windows-x64\apache-tomcat-9.0.73\bin\tomcat-juli.jar”
Using CATALINA_OPTS: “”
14-Mar-2024 08:32:34.599 信息 [main] org.apache.catalina.core.StandardServer.await 通过关闭端口接收到有效的关闭命令。正在停止服务器实例。
14-Mar-2024 08:32:34.600 信息 [main] org.apache.coyote.AbstractProtocol.pause 暂停ProtocolHandler[“http-nio-8080”]
14-Mar-2024 08:32:34.686 信息 [main] org.apache.catalina.core.StandardService.stopInternal 正在停止服务[Catalina]
14-Mar-2024 08:32:34.694 警告 [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesJdbc Web应用程序 [ROOT] 注册了JDBC驱动程序 [com.alibaba.druid.proxy.DruidDriver]，但在Web应用程序停止时无法注销它。 为防止内存泄漏，JDBC驱动程序已被强制取消注册。
14-Mar-2024 08:32:34.695 警告 [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesJdbc Web应用程序 [ROOT] 注册了JDBC驱动程序 [com.mysql.cj.jdbc.Driver]，但在Web应用程序停止时无法注销它。 为防止内存泄漏，JDBC驱动程序已被强制取消注册。
14-Mar-2024 08:32:34.695 警告 [main] org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e95c483393b1f4bc611dfd750ee2685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a4e856fa1fde15d14dd9c2c08639310/" rel="bookmark">
			前端每日一练：使用 JavaScript 下载图片并保存到本地的方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发中，经常会遇到需要将图片从网络上下载并保存到本地的需求。本文将介绍如何使用 JavaScript 实现下载图片的功能，并提供详细的解释和代码示例。
1. downloadImage 函数 首先，让我们来了解 downloadImage 函数的实现原理和作用。这个函数的主要功能是接收图片的 URL 和要保存的文件名，然后在用户点击下载链接时将图片保存到本地。
function downloadIamge(src, imgName){​ let image = new Image();​ image.src = src;​ image.setAttribute("crossOrigin", "anonymous");​ image.onload = function() {​ let c = document.createElement("canvas");​ c.width = image.width;​ c.height = image.height;​ c.getContext("2d").drawImage(image, 0, 0, image.width, image.height);​ let a = document.createElement("a"); ​ a.download = imgName;​ a.href = c.toDataURL("image/png");​ a.click();​ }​ } 2. 实现原理解释 首先，创建一个新的 Image 对象，并将图片的 URL 赋值给它。通过设置 crossOrigin 属性为 "anonymous"，解决跨域访问的问题。当图片加载完成后，创建一个新的 canvas 元素，并将图片绘制到 canvas 上。创建一个新的 &lt;a&gt; 元素作为下载链接，并设置下载的文件名为 imgName。将 canvas 的数据转换为 Data URL，并将其赋值给下载链接的 href 属性。最后，模拟用户点击下载链接，触发图片下载的操作。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a4e856fa1fde15d14dd9c2c08639310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb333d8482b0550d4829397a5a123ac5/" rel="bookmark">
			在visual studio里配置Qt插件并运行Qt工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt插件，也叫qt-vsaddin，它以*.vsix后缀名结尾。visual studio简称为VS，从visual studio 2010版本开始，VS支持Qt框架的开发，Qt以插件方式集成到VS里。这里简述在visual studio 2019里配置Qt 5.14.2插件，并配置Qt环境、编译和运行Qt工程。
1 下载VS2019 下载VS2019,官网地址： https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/
个人地址： https://pan.baidu.com/s/1VaQC5_CprbTtp8mbPWCaBA
提取码：uo1b
双击该安装包，选中"使用C++的桌面开发"，然后一路默认，直到安装完成。
图(1) 下载VS2019 图(2) 安装VS2019，并勾选C++组件 2 注册Qt账号和下载Qt 5.14.2 2.1 注册Qt账号 在 login.qt.io/register官网，注册一个Qt账号，如下所示：
图(2.1) 注册Qt账号 2.2 下载Qt安装包 Qt安装包分为离线安装包、在线安装包。从Qt 5.15版本开始，Qt官网只能下载在线安装包。而低于Qt5.15版本的，可以下载离线安装包，例如Qt5.14.2就有离线安装包。为了加快安装速度，选择Qt 5.14.2，如图(3)所示。
Qt 5.14.2老官网地址: https://download.qt.io/archive/qt/5.14/5.14.2/
Qt 5.14.2新官网地址: https://download.qt.io/new_archive/qt/5.14/5.14.2/
Qt其他历史版本地址: https://download.qt.io/new_archive/qt/
图(3) 下载Qt 5.14.2 安装包 安装包下载好之后，双击该安装包，选择安装目录: D:\Qt，这里选择64位的开发方式，即64-bit。
编译器选2个：MSVC 2017 64-bit(VS编译器)、MinGW 7.3.0 64-bit(类Linux编译器)；开发工具包选择：Qt Creator 4.11.1 CDB Debugger Support和MinGW 7.3.0 64-bit。Qt组件，这些组件是按需选择的，自己需要什么，就勾选什么。
其中，Sources是Qt源码包，主要用于查看函数定义、调试代码使用； 组件作用SourcesQt源码包,用于查看类结构和函数定义Qt Charts界面二维图表模块，用于绘制饼图、曲线图、柱状图等二维图形Qt Quick 3DQuick的扩展，渲染3D内容Qt Data Visualization三维显示与绘制模块,绘制三维曲线、三维空间分布Qt Lottie AnimationLottie动画的Qt版本，渲染JSON格式的动画Qt Purchasing购物模块，支持Andriod、iOS和MacQt Virtual Keyboard虚拟键盘,支持QML和本地键盘布局Qt Network Authorization网络模块 ，支持TCP、UDP、HTTP等协议Qt Script脚本模块,已迁移到QMLQt Quick Timeline动画控制，关键帧设置 图(2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb333d8482b0550d4829397a5a123ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa26e8dda4f0e1866ca4b70ec1107e30/" rel="bookmark">
			第六篇【传奇开心果系列】Python的自动化办公库技术点案例示例：大学生数据全方位分析挖掘经典案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传奇开心果博文系列 系列博文目录Python的自动化办公库技术点案例示例系列 博文目录前言一、Pandas库全方位分析挖掘大学生数据能力介绍二、大学生学生成绩数据分析数据挖掘示例代码三、大学生选课数据分析数据挖掘示例代码四、大学生活动参与数据分析数据挖掘示例代码五、大学生消费行为数据分析数据挖掘示例代码六、大学生社交网络数据分析数据挖掘示例代码七、大学生考勤数据分析数据挖掘示例代码八、大学生健康数据分析数据挖掘示例代码九、大学生心理健康数据分析数据挖掘示例代码十、大学生就业数据分析数据挖掘示例代码十一、大学生住宿数据分析数据挖掘示例代码十二、归纳知识点 系列博文目录 Python的自动化办公库技术点案例示例系列 博文目录 前言 Pandas在大学生数据的分析和挖掘中发挥着重要作用，帮助研究人员和教育工作者更好地理解大学生群体、优化教学管理和提升教育质量。
一、Pandas库全方位分析挖掘大学生数据能力介绍 Pandas库可以用来分析挖掘大学生数据的各各方面，包括但不限于：
学生成绩数据：可以通过Pandas对大学生的成绩数据进行统计分析、可视化展示，了解不同课程的表现、成绩分布等情况。通过数据挖掘探索分析，你可以更深入地了解学生成绩数据之间的关系、学生的总体表现情况以及成绩分布情况，为学校教学成绩管理提供高质量的分析报告，为学校教学成绩管理方案优化提供可靠依据。
学生选课数据：可以利用Pandas分析大学生的选课情况，了解大学生的兴趣偏好、常见组合，了解不同专业或年级的选课趋势等。通过数据挖掘探索分析可以帮助学校更好地了解学生的选课偏好，发现课程之间的关联性，为学校提供更好的课程推荐和课程设置建议。
学生活动参与数据：通过Pandas可以对大学生参与各类活动的数据进行分析，了解学生的社交圈子、兴趣爱好，评估活动对大学生成长的影响。通过数据挖掘探索分析关联规则，学校可以更好地了解学生的活动偏好和社交圈子，为活动组织和学生成长提供更有针对性的建议和支持。
学生消费行为数据：可以利用Pandas分析大学生的消费行为数据，包括食堂消费、校园卡消费等，了解学生的普遍消费习惯和偏好等。通过数据挖掘探索分析，学校可以更深入地了解不同群体学生的消费习惯和消费偏好，为提供更精准的消费服务和制定针对性的消费政策提供参考。
学生社交网络数据：通过Pandas可以对大学生之间的社交网络数据进行分析，学校可以了解学生之间的社交关系，发现在社交网络中具有重要影响力的学生。通过数据挖掘可以帮助发现学生参加社交活动的频繁组合，而关联规则则可以揭示这些这些社交活动之间的关联性。为学校组织社交活动和学生关系管理提供高价值的参考。
学生考勤数据：通过Pandas可以分析学生的考勤数据，了解学生的出勤情况、迟到早退情况，通过数据挖掘发现大学生考勤潜在的规律和趋势，帮助学校进行高质量的考勤管理和考勤监督。
学生健康数据：可以利用Pandas对学生的健康数据进行分析，包括体重、身高、运动习惯等信息，帮助学校关注学生的健康状况。通过数据挖掘探索分析可以帮助学校更全面地了解大学生的健康状况，发现规律和趋势，为健康管理和教育提供数据支持和决策参考。
学生心理健康数据：通过Pandas可以分析学生的心理健康数据，包括压力水平、情绪波动等，帮助学校及时发现并关注学生的心理健康问题。通过数据挖掘探索发现潜在问题并及时出台应对措施和干预措施提供相应技术支持。
学生就业数据：可以利用Pandas对学生的就业数据进行分析，包括就业率、就业岗位分布等，帮助学校了解毕业生的就业情况，优化教学计划。通过数据挖掘发现大学生就业群体中的潜在模式和群集，为学校大学生就业工作提供更深入的洞察，从而优化学校教学计划和就业指导工作方案，进一步提高学校就业指导工作的质量。
学生住宿数据：通过Pandas可以分析学生的住宿数据，了解学生的住宿选择、住宿费用等情况。通过数据挖掘探索分析每个群体的统计信息，可以更好地了解不同群体大学生的住宿特点，为学校提供住宿管理和规划方面的高质量分析报告和更加优质的决策建议。
综上所述，Pandas作为一个强大的数据分析和数据挖掘工具，可以在各个方面帮助学校和教育机构更好地理解和管理大学生，从而提升学校教育质量和学生服务水平。
二、大学生学生成绩数据分析数据挖掘示例代码 学生成绩统计分析可视化示例代码 当使用Pandas对学生成绩数据进行统计分析和可视化展示时，可以按照以下示例代码进行操作：
import pandas as pd import matplotlib.pyplot as plt # 创建一个示例的学生成绩数据DataFrame data = { '学生姓名': ['张三', '李四', '王五', '赵六', '钱七'], '数学成绩': [85, 90, 78, 92, 88], '英语成绩': [80, 88, 75, 95, 82], '物理成绩': [88, 85, 79, 93, 90] } df = pd.DataFrame(data) # 显示数据DataFrame print(df) # 统计学生成绩数据 summary = df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa26e8dda4f0e1866ca4b70ec1107e30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21058a1b04927e3cba336e7ff3acb4b/" rel="bookmark">
			【学习心得】Python调用JS的三种常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做JS逆向的时候，一种情况是直接用Python代码复现JS代码的功能，达成目的。但很多时候这种方法有明显的缺点，那就是一旦JS代码逻辑发生了更改，你就得重写Python的代码逻辑非常不便。于是第二种情况就出现了，我直接得到你的JS代码片段，用Python去操作JS运行，并得到结果。这种做法的好处在于可以将JS代码看成一个黑盒子，我不关心里面是怎么写的，我只在乎是否输出了正确的结果。
方法一、用Python的pyexecjs库 pyexecjs库允许在Python环境中执行JavaScript代码，无需浏览器环境。在我的另一篇文章中详细讲了pyexecjs库的用法，大家可以去看看哦！
http://t.csdnimg.cn/Eo29Dhttp://xn--pythonpyexecjs-082ha0760esa4358l6pybfnik9rvpff4ap62eee2q
优点：
简单易用，无需启动浏览器环境即可执行JavaScript代码。在内存中执行JavaScript代码，性能相对较高。 缺点：
只能执行纯JavaScript代码，无法处理DOM操作或者利用浏览器特性的功能（如Web API、HTML5特性等）。需要系统安装支持的JavaScript运行时环境（如Node.js或Rhino等）。对于复杂或依赖特定环境的JavaScript代码支持有限。 方法二、用Python的selenium库 selenium主要用于Web自动化测试，它可以启动一个真实的浏览器（如Chrome、Firefox等）并模拟用户操作。若要执行JavaScript代码，可以利用execute_script方法。至于如何使用execute_script我这里给出一段参考的代码：
# 导入webdriver模块中的Options类（这里省略了import语句） chrome_option = Options() # 设置Chrome浏览器启动选项，使其在无头模式下运行，即不显示用户界面 chrome_option.add_argument("--headless") # 禁用GPU硬件加速，这对于某些系统在headless模式下运行时是必要的 chrome_option.add_argument("--disable-gpu") # 忽略SSL证书错误，防止因为证书问题导致的网页加载失败 chrome_option.add_argument('--ignore-certificate-errors') # 使用前面设置好的Chrome启动选项实例化一个Chrome浏览器对象 browser = webdriver.Chrome(options=chrome_option) # 定义要访问的网址，并使用浏览器打开该网址 url = "替换成你想要处理的网址" browser.get(url) # 在当前页面上执行一段JavaScript代码，并获取其返回结果 result = browser.execute_script("你想执行的JS代码片段") # 输出执行JavaScript后得到的结果 print(result) # 暂停程序运行10秒，确保有足够时间进行页面加载或执行后续操作 time.sleep(10) # 关闭并退出浏览器 browser.quit() 优点：
真实的模拟浏览器环境执行JavaScript代码，因此能够处理与DOM相关的操作，以及调用浏览器提供的所有Web API和HTML5特性。适用于网页自动化测试和爬虫开发等场景，对网页动态加载内容有良好的支持。 缺点：
执行速度相比直接在内存中执行JavaScript慢，因为需要启动和控制一个完整的浏览器实例。使用成本相对较高，需要配置对应的浏览器驱动程序。若只是简单的JavaScript计算任务，使用selenium显得较为笨重。 方法三、用node.js搭建一个HTTP API后台服务接口，开放给Python代码调用 首先，在Node.js中创建一个HTTP服务器，并暴露执行JavaScript功能的API。然后，在Python中调用这个HTTP API来执行JavaScript代码。下面介绍Node.js中的一个包express，他可以快速的搭建一个Web服务。
// 导入express包 const express = require("express") // 创建Web实例 const app = express() // 设置端口 const port = 3000 // 处理GET请求 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c21058a1b04927e3cba336e7ff3acb4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b2976aedcb6cf24722495f83c1e02e1/" rel="bookmark">
			【学习心得】Python好库推荐——websocket-client
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		websocket-client 是一个在 Python 中广泛使用的库，用于创建 WebSocket 客户端并实现与 WebSocket 服务器的双向通信。更多的关于websocket协议介绍，可以看看我之前写的文章哦！
【学习心得】websocket协议简介并与http协议对比http://t.csdnimg.cn/C3hEQ
一、安装和快速入门 pip install websocket-client 两个基本的使用示例来说明如何创建一个 WebSocket 客户端、连接到服务器、发送消息。
（1）websocket短连接 # 安装websocket-client库 # pip install websocket-client # 导入websocket import websocket # 创建客户端实例 ws = websocket.WebSocket() # 连接指定的ws服务器 ws.connect("ws://echo.websocket.events") # 这个网址是官方测试网址 # 发送消息 ws.send("Hello!") # print(ws.send("Hello!")) # 返回的是你发送信息的字节大小，并不是真的服务器响应给你的数据 # 接收响应 res = ws.recv() print(res) # recv方法才能得到服务器响应给你的数据 # 关闭ws连接 ws.close() （2）websocket长连接 # 导入websocket-client包 import websocket # 定义on_message回调函数用来处理 websocket事件——客户端接收服务端数据时触发 def on_message(ws_app, message): print(message) # 当客户端接收到服务器响应回的数据时，把他打印出来显示一下 # 实例化一个ws客户端 url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b2976aedcb6cf24722495f83c1e02e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f4a7bff4bbff294678eee76166a001/" rel="bookmark">
			前端实现读取word文件，并将其进行原样式展示的几种方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端直接读取并原样展示Word文档是一个相对复杂的任务，因为Word文档的格式（如.doc或.docx）与Web技术栈使用的格式（HTML、CSS）不兼容。要实现这一功能，通常需要将Word文档转换为Web友好的格式。以下是实现这一目标的几种方法：
1. 使用第三方库 一些JavaScript库可以帮助你解析和显示Word文档，例如mammoth.js。Mammoth旨在将.docx文档转换为HTML和纯文本，重点是把文档内容以干净的格式转换出来，尽可能保留基本的样式。
// 使用mammoth.js示例 mammoth.convertToHtml({arrayBuffer: arrayBuffer}) .then(function(result) { document.getElementById('output').innerHTML = result.value; }) .catch(function(err) { console.log(err.message); }); 这段代码展示了如何使用mammoth.js将Word文档（arrayBuffer格式）转换为HTML并显示在页面上。注意，这种方法主要适用于保持文本内容和基本样式，可能无法完全原样展示复杂的文档格式。
2. 使用Office 365 API 如果你希望用户可以查看、编辑Word文档，可以考虑使用Microsoft的Office 365 API。Microsoft Graph API允许开发者在应用程序中集成Office 365服务，包括Word文档的读取和编辑。这种方法需要用户有Office 365订阅，并且对文档的显示效果有很高的保真度。
3. 转换为PDF 将Word文档转换为PDF格式也是一种可行的方法，因为PDF文件较容易在Web上原样展示。可以在服务器端使用工具（如LibreOffice、Microsoft Office等）将Word文档转换为PDF，然后在前端使用PDF.js等库显示PDF文件。
// 使用PDF.js示例 pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) { console.log("PDF loaded"); // 获取第一页 pdfDoc_.getPage(1).then(function(page) { var scale = 1.5; var viewport = page.getViewport({scale: scale}); // 准备用于渲染的画布 var canvas = document.getElementById('the-canvas'); var context = canvas.getContext('2d'); canvas.height = viewport.height; canvas.width = viewport.width; // 渲染PDF页 var renderContext = { canvasContext: context, viewport: viewport }; var renderTask = page.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37f4a7bff4bbff294678eee76166a001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd7ce487b3d9b720a7eb5898471f950/" rel="bookmark">
			何为一致性哈希？一致性哈希和哈希有什么区别？一文深入理解一致性哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、哈希2.1、哈希碰撞2.2、针对哈希碰撞的两种方案2.3、为什么用哈希2.4、普通哈希的缺点 三、一致性哈希3.1、实现方式 - 哈希环3.2、场景复现3.3、优化版本的哈希环 四、总结 一、前言 在学到分布式负载均衡时，负载均衡的方式有很多种，其中一致性哈希与哈希的区别？开一篇文章记录一下一致性哈希的原理。
二、哈希 对于哈希，日常开发中在很多场景都会用到，比如：
md5 之类的哈希函数分库、分表时，使用某个字段的 hash 值对固定数值取模，来确定对应库表一个大量数据的集合，根据某个字段作为拆分键，对数据进行打散处理PHP的 HashTable、Go的 map、Python 的 dict 等数据结构实现Redis 分片时使用 crc16 对key进行哈希，然后对 16384 取模来确定分片等等 …
除上面场景，还有很多地方会用到 hash，而他们都是哈希的一种实现方式。 哈希与一致性哈希
2.1、哈希碰撞 无限个原始数据在经过Hash函数运算之后，得到的哈希结果会有一定的概率相同。那么，这些不同的原始数据得到相同哈希值的情况，就是哈希碰撞。
例如下图所示：c、d在经过某个哈希函数计算之后得到相同的哈希值10，那么c、d 就发生了哈希碰撞。
需要了解的：
哈希碰撞无法避免 (因为哈希结果值域是有限的，原始数据是无限的)
哈希值域越大，碰撞概率一般越低
好的哈希函数除了运算速度外，还需要尽量小的哈希碰撞概率
2.2、针对哈希碰撞的两种方案 在出现哈希碰撞情况下常用的方案有：
开放地址法拉链法 开放地址法一般不常使用，读者可以自行查阅相关资料。
拉链法则在很多场景、甚至开源系统都会用到。
例如：PHP的 HashTable(PHP5使用双向链表、PHP7使用数组)、以及Go的map底层实现。
如图所示，c、d的哈希结果都为10，在存储的时候使用尾插法来把他们串在一起(就像拉了一条锁链一样)。
其中，bucket 为在某一时刻大小固定的数组，下标为哈希值对固定数值取模之后得到。bucket 的大小一般会在某种临界状态下进行自动的扩容、缩容。
查找的时候，根据计算的哈希值先定位到bucket对应位置，然后再遍历链表查找对应数据。
注意：
原始数据经过Hash计算一般会得到比较大的哈希值，此时需用哈希值对bucket大小取模来确定数据存储位置
理想情况下，不会有哈希碰撞，数值落在bucket的不同位置，查找时间复杂度为 O(1)
糟糕情况下，数据全部哈希碰撞，数值都落在bucket同一个位置，查找时间复杂度为 O(n)
2.3、为什么用哈希 例如一个项目，每天数据量2亿多条，这些数据需要落盘。建表的话，如果存在一张表里面，那将会是一个灾难。如果建10张表，使用用户uid对10取模来确定当前数据落在哪一张表里面。
其中，uid%10 相当于hash算法，这样的话就把2亿多条的数量分拆在不同的表里面，减少了单表数据量，好处的话：可以提升查询速度、数据在同步时效率提升等等。
在这种情况之下，使用哈希对大量数据进行拆分再合适不过了。
2.4、普通哈希的缺点 优点说了一堆，那么接下来说一下不好的地方。
假设有这样一种场景：原来使用了10张表存储数据，完全没有问题。突然有一天，业务要求现在使用20张表或者5张表存储数据，那该怎么办?
由于表的个数发生变化，此时的hash函数 uid%10 就应该变为 uid%20 或者 uid%5。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fd7ce487b3d9b720a7eb5898471f950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8af856f307ae96df978ddf2465ba04/" rel="bookmark">
			解决 Java 错误 Java.Sql.SQLException: No Suitable Driver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章介绍了 Java 中的 java.sql.SQLException：No suitable driver 错误。
Java 中 java.sql.SQLException: No suitable driver 的原因 当我们尝试连接到 MySQL 或任何其他数据库并尝试侦听端口时，会出现错误 java.sql.SQLException: No suitable driver。 没有合适的驱动程序对应于控制台中的java.sql.SQLException: No suitable driver 找到 jdbc:mysql://localhost:3306/test。
出现此错误的原因有：
当调用 DriverManager.getConnection() 之前没有为数据库和端口注册 JDBC 驱动程序时。当 MySQL JDBC 驱动程序未添加到类路径时。 以下部分给出了 java.sql.SQLException: No suitable driver 错误的解决方案。
注册 JDBC 驱动程序解决 Java 中的 java.sql.SQLException: No suitable driver 错误 如果您的 JDBC 驱动程序未注册，则任何使用 acceptURL 方法加载的驱动程序都不会接受 JDBC URL。 为了解决这个问题，提到MySQL JDBC驱动，如下：
MySQL 的 JDBC URL：
jdbc:mysql://localhost:3306/test?useSSL=false AcceptURL 的原型：
boolean acceptsURL(String url) throws SQLException 数据库连接的完整语法为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d8af856f307ae96df978ddf2465ba04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a62d41b96f683ae6bca6a08fc1513db0/" rel="bookmark">
			MySQL大表优化方案（应该是最完整最全的了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化：
单表优化 除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量：
字段 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED
VARCHAR的长度只分配真正需要的空间
使用枚举或整数代替字符串类型
尽量使用TIMESTAMP而非DATETIME，
单表不要有太多字段，建议在20以内
避免使用NULL字段，很难查询优化且占用额外索引空间
用整型来存IP
索引 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描
应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描
值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段
字符字段只建前缀索引
字符字段最好不要做主键
不用外键，由程序保证约束
尽量不用UNIQUE，由程序保证约束
使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引
查询SQL 可通过开启慢查询日志来找出较慢的SQL
不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边
sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库
不用SELECT *
OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内
不用函数和触发器，在应用程序实现
避免%xxx式查询
少用JOIN
使用同类型进行比较，比如用'123'和'123'比，123和123比
尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描
对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大
引擎 目前广泛使用的是MyISAM和InnoDB两种引擎：
MyISAM MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：
不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
不支持事务
不支持外键
不支持崩溃后的安全恢复
在表有读取查询的同时，支持往表中插入新纪录
支持BLOB和TEXT的前500个字符索引，支持全文索引
支持延迟更新索引，极大提升写入性能
对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用
InnoDB InnoDB在MySQL 5.5后成为默认索引，它的特点是：
支持行锁，采用MVCC来支持高并发
支持事务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a62d41b96f683ae6bca6a08fc1513db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca31de770d2da6a87c7b4c17e2bca75/" rel="bookmark">
			Linux本地搭建FastDFS系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 本地搭建FastDFS文件系统1.1 环境安装1.2 安装libfastcommon1.3 安装FastDFS1.4 配置Tracker1.5 配置Storage1.6 测试上传下载1.7 与Nginx整合1.8 安装Nginx1.9 配置Nginx 2. 局域网测试访问FastDFS3. 安装cpolar内网穿透4. 配置公网访问地址5. 固定公网地址5.1 保留二级子域名5.2 配置二级子域名 6. 测试访问固定二级子域名 前言 FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。
FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。
配备一台公网服务器作为文件上传下载,花费资源和开销比较大,如果在本地搭建FastDFS服务,只把上传后的文件通过cpolar内网端口转发工具将文件配置可通过互联网访问,极大了减少服务器费用及开销,本文介绍详细搭建FastDFS教程,并结合Nginx+cpolar工具实现远程访问文件。
1. 本地搭建FastDFS文件系统 1.1 环境安装 由于fastDFS是由c语言编写,所以我们需要安装gcc
yum -y install gcc-c++ FastDFS依赖libevent库，需要安装。执行如下命令：
yum -y install libevent 1.2 安装libfastcommon 进入local目录
cd /usr/local libfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。点击下面链接即可获取:
https://github.com/happyfish100/libfastcommon/releases/tag/V1.0.7
获取后,上传到local目录下
解压libfastcommon
tar -zxvf libfastcommonV1.0.7.tar.gz 进入解压文件夹
cd libfastcommon-1.0.7/ 编译
./make.sh 安装
./make.sh install libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。
cp /usr/lib64/libfastcommon.so /usr/lib/ 1.3 安装FastDFS 进入local目录
cd /usr/local 点击下列地址,可获取下载FastDFS_v5.05.tar.gz文件:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ca31de770d2da6a87c7b4c17e2bca75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42059fc3bf762a8a190bce04e2dd670f/" rel="bookmark">
			Java中的Map集合如何根据key值排序？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的Map集合如何根据key值排序（HashMap&lt;String,Object&gt;）？ Map集合的键（key）默认是按照它们的hashCode排序的，这在有时间不符合业务排序。如果你想要根据Map的key值进行排序，一般以下有几种方法可以实现。
方法一：使用TreeMap 使用TreeMap类，它会自动根据key的自然顺序或自定义比较器进行排序。
1、使用key(String)的自然排序: 代码示例：
// 假设Map为HashMap Map&lt;String, Integer&gt; unsortedMap = new HashMap&lt;&gt;(); // 添加元素到unsortedMap unsortedMap = ... ; // 使用TreeMap进行排序 Map&lt;String, Integer&gt; sortedMap = new TreeMap&lt;&gt;(unsortedMap); 2、使用自定义规则排序，传入Comparator自定义排序规则： // 假设为HashMap&lt;String, Object&gt; map // 未排序的HashMap Map&lt;String, Object&gt; unSortMap = ...; // 使用TreeMap并提供一个Comparator用于排序key Map&lt;String, Object&gt; sortedMap = new TreeMap&lt;&gt;(new Comparator&lt;String&gt;() { @Override public int compare(String k1, String k2) { // 对于字符串key升序排序 return k1.compareTo(k2); // 若需要降序排序，则可以改为 // return k2.compareTo(k1); } }); // 将原始Map的内容复制到TreeMap中，此时Map会根据key排序 sortedMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42059fc3bf762a8a190bce04e2dd670f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cee8a023a591d207d32d16fb96bd2b1/" rel="bookmark">
			【C&#43;&#43;】string进一步介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页 ： zxctscl
如有转载请先通知
文章目录 1. 前言2. 迭代器2.1 反向迭代器2.2 const对象迭代器 3. Capacity3.1 size和length3.2 max_size3.3 capacity3.4 clear3.5 shrink_to_fit （了解即可）3.6 reserve3.7 resize 4. Element access4.1 operator[]4.2 at 5. Modifiers5.1 push_back5.2 append5.3 operator+=5.4 assign（了解即可）5.5 insert5.6 erase5.7 replace5.8 swap 6. String operations6.1 c_str6.2 find 和 substr6.3 rfind6.4 compare 7. Non-member function overloads7.1 operator+7.2 getline 1. 前言 在之前的博客中初步介绍了string一下: 【C++】string类初步介绍，那么这次来看看它的实现。
2. 迭代器 string类对象的访问及遍历操作：
函数名称功能说明operator[] （重点）返回pos位置的字符，const string类对象调用begin+ endbegin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器范围forC++11支持更简洁的范围for的新遍历方式rbegin + rendrbegin反向迭代器以反向开始,end将迭代器返回到末尾 2.1 反向迭代器 在前面的一篇中已经提到了前面三个，这次来看看反向迭代器。
reverse_iterator：将给的字符串反向逆置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cee8a023a591d207d32d16fb96bd2b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0039b73fe2105cff9bbb4529d16654cc/" rel="bookmark">
			【海贼王的数据航海】栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 -&gt; 栈
1.1 -&gt; 栈的概念及结构
1.2 -&gt; 栈的实现
1.2.1 -&gt; Stack.h
1.2.2 -&gt; Stack.c
1.2.3 -&gt; Test.c
2 -&gt; 队列
2.1 -&gt; 队列的概念及结构
2.2 -&gt; 队列的实现
2.2.1 -&gt; Queue.h
2.2.2 -&gt; Queue.c
1 -&gt; 栈 1.1 -&gt; 栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO(Last In First Out)的原则。
压栈：栈的插入操作叫进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
1.2 -&gt; 栈的实现 栈的实现一般可以使用数组或链表实现，相对而言数组的结构实现更优。因为数组在尾上插入数据的代价比较小。
1.2.1 -&gt; Stack.h #pragma once #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #include &lt;stdbool.h&gt; // 定长的静态栈的结构，实际中一般不实用 //typedef int STDataType; //#define N 10 //typedef struct Stack //{ //	STDataType a[N]; //	int top; //}ST; // 动态增长的栈 typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; // 栈的初始化 void STInit(ST* pst); // 栈的销毁 void STDestroy(ST* pst); // 入栈 void STPush(ST* pst, STDataType x); // 出栈 void STPop(ST* pst); // 获取栈顶元素 STDataType STTop(ST* pst); // 判空 bool STEmpty(ST* pst); // 栈的有效元素个数 int STSize(ST* pst); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0039b73fe2105cff9bbb4529d16654cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94da45907ff04835ebfb71d6cbf86e2d/" rel="bookmark">
			python之格式化输出format()函数使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中，format 方法是一种用于字符串格式化的强大工具。它允许你将变量或表达式插入到字符串中，并根据需要进行格式化。下面是对 format 方法的详细介绍：
format 方法的基本语法如下：
formatted_string = "string {0} {1}".format(arg1, arg2) 在这个语法中，被大括号 {} 包围的占位符用于指示将要插入的变量的位置。format 方法的参数将按照位置顺序填充到占位符中。
下面是 format 方法的一些常见用法和格式选项：
1. 位置参数 可以使用位置参数将变量插入到字符串中。
name = "John" age = 30 message = "My name is {}, and I'm {} years old.".format(name, age) message = "My name is {0}, and I'm {1} years old.".format(name, age) print(message) 输出："My name is John, and I'm 30 years old."。
2. 关键字参数 除了位置参数外，还可以使用关键字参数指定要插入的变量。
name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94da45907ff04835ebfb71d6cbf86e2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7772481eb474787515f7d8c3bbe128c/" rel="bookmark">
			spring boot上传文件，并限制上传文件类型、上传文件大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日上传文件遇到诸多问题，我以为上传就一个io流就能搞定的东西，结果写完给我同事测试一下漏洞百出，问题1.单次上传文件超过10MB就会报错，文件太大。问题2.文件限制文件类型。问题3.即使使用逻辑限制了类型只要有人有心上传两个文件，第一个是能过校验第二个就不会校验了。那么我们一起来解决一下这些问题。
问题1、
上传文件这个有很多方案可以解决，可以直接一个异常捕获返回文件太大，也可以将文件容量扩大，而这里我是两个搭配使用，配置了yml文件，还配置了异常捕获，也可以直接在上传的代码那捕获这个异常 MaxUploadSizeExceededException ，我这是新建了一个IExceptionHandler直接全局进行配置了
spring: servlet: multipart: max-file-size: 50MB # 最大上传大小限制为50MB。任何尝试上传超过这个大小的单个文件都会被拒绝。 max-request-size: 50MB # 整个请求的最大大小限制为50MB。这包括所有上传文件的总和以及其他请求参数的大小 全局捕获异常
@ExceptionHandler(MaxUploadSizeExceededException.class) public JsonResult handlerAnyException(MaxUploadSizeExceededException e) { e.printStackTrace(); var status = HttpStatus.INTERNAL_SERVER_ERROR; return JsonResult.custom( status, "文件过大", null ); } 问题2、
我当前项目需要只能上传PDF文件，所以我的文件中是这样限制的，直接在逻辑中限制文件类型（完整代码放文章最后）
if (!pdfFile.getContentType().equals("application/pdf")) { return JsonResult.badRequest("请上传PDF文件"); } 问题3、
问题3的话我觉得无伤大雅，因为只要只接收一个文件参数，那么就算传再多文件，也只会读取第一个。
以下是完整代码
@Override @Transactional public JsonResult uploadPdfFile(MultipartFile pdfFile) { if (pdfFile.isEmpty()) { return JsonResult.badRequest("请上传文件"); } if (!pdfFile.getContentType().equals("application/pdf")) { return JsonResult.badRequest("请上传PDF文件"); } try { // 获取文件名 String fileName = pdfFile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7772481eb474787515f7d8c3bbe128c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88b732be1f8cb5b06ca24c5f390103e/" rel="bookmark">
			MySQL用法---MySQL Workbench创建数据库和表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 连接数据库 打开软件，点击左下角卡片，输入设置的数据库密码，勾选单选框
2. 了解主页面的组成部分 3. 创建数据库 先点击工具栏的创建按钮
再输入数据库名称
点击 Apply 创建
4. 创建数据表 展开数据库，在Tables上右键，点击 Create Table
输入表名，填写描述当前表的作用
设计表的字段
default 设置默认值
Apply 创建
DataType 数据类型 1. int 整数
2. varchar（len）字符串
3. tinyint（1）布尔值
字段的特殊标识 1. PK（primary Key） 主键、唯一标识
2. NN（Not Null） 值不允许为空
3. UQ（unique） 值唯一
4. AI（Auto Increment） 值自动增长
5. 向表中写入数据 鼠标右键刚建立的表，点击Select Rows
在右表内输入用户名和用户密码
id是自增的，不需要输入，status 是状态 默认为0也不需要输入
再点击 apply 保存修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61bf45b01f4e1294098d6c15e05a7bd1/" rel="bookmark">
			Android 使用adb操作WiFi相关指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没有系统原生设置应用又需要调试WiFi功能时，可以使用如下指令来验证WiFi相关功能
最常用的就是 svc wifi enable/disable，再使用wpa_supplicant/wpa_cli来验证，但对于AP功能就没办法验证了，其实Android有组很强大的shell指令集，包含各个方便，这里只记录下平时使用的WiFi相关指令
1、adb shell cmd wifi -h
查看WiFi所有指令以及参数
2、打开关闭WLAN
adb shell cmd wifi set-wifi-enabled enabled
adb shell cmd wifi set-wifi-enabled disabled
3、扫描WiFi
adb shell cmd wifi start-scan //扫描
adb shell cmd wifi list-scan-results //查看扫描结果
4、连接WiFi
adb shell cmd wifi connect-network TP-LINK_5G_0FE1 wpa2 12345678
//TP-LINK_5G_0FE1 连接WiFi名称
//wpa2 加密方式
//12345678 密码
5、查看WiFi状态
adb shell cmd wifi status
6、打开关闭热点
adb shell cmd wifi start-softap ap_ssidxx wpa2 12345678 -b5
// ap_ssidxx 热点名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61bf45b01f4e1294098d6c15e05a7bd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305adf7caf799c23b58f4798e7902ceb/" rel="bookmark">
			微信小程序入门到实战\小程序项目\小程序开发（保姆级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 1.什么是小程序？
小：项目小：2m
嵌入到微信中
Html css jss
大：
数量大
制裁（微信小程序不影响，苹果商店app不让上架）
2.为什么要会微信小程序？
要会：
入门简单
寄生于微信
跨平台
适合创业 成本低
开发效率特别高
一. 环境搭建 1-申请微信小程序账号（htpps：//mp.weixin.qq.com/）
2.登录成功之后 会看到小程序发布流程
点击&lt;开发&gt;
自己创作提交开发版本 提交审核发布小程序为体验版本
注意唯一的appID
3.微信小程序工具
3.1下载微信工具 打卡之后是二维码
3.2添加创建小程序
4-创建第一个小程序
创建项目预览
要注意云服务区别：简单来说云开发使用比较复杂，是一个比较完善的小demo。不使用就是一个简单的JavaScript。
4.1页面介绍
4.2项目组成（目录文件）
4.3page.json 文件
（针对微信小程序全局的配置）
4.4index.html
pages 注册页面
window 窗口信息
5.主页设置
把新建的文件路径调到最上面那就是主页了，意思就是，第一个路径就是首页的路径!
二.微信小程序之Flex-Direction 1.布局 盒子模型
Div宽度=边框+内空隙+内容宽度
Div高度同理
2.FLEX布局
flex-direction 决定主轴的方向
row：从左到右
row-reverse：从右到左
colums：交叉轴方向 从上到下
.box-1{ flex-direction: column-reverse; } 3.新建一个页面
4.新建文件添加内容
flex-wrap
nowrap:不换行
wrap：换行
wrap-reverse：反向换行
.box-2{ flex-direction: row; flex-wrap:wrap-reverse; } flex-flow
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/305adf7caf799c23b58f4798e7902ceb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/473/">«</a>
	<span class="pagination__item pagination__item--current">474/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/475/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>