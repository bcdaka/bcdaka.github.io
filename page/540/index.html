<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9237d543d66c012c16de41ecf0348a7/" rel="bookmark">
			RabbitMQ常见问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、消息丢失
1、生产者重连
2、生产者确认
3、数据持久化
4、惰性队列
5、消费失败处理
二、消息重复
1、通过业务保证幂等性（优先）
2、通过消息状态去重保证幂等性
三、消息堆积
1、优化消费者处理逻辑
2、增加队列及消费者数量
3、使用惰性队列
四、保证消息顺序消费
一、消息丢失 1、生产者重连 由于网络波动，可能会出现客户端连接失败的情况，需开启重连机制。
SpringBoot项目配置：
spring: rabbitmq: # 连接超时时间 connection-timeout: 500ms template: retry: # 开启失败重连 enabled: true # 失败后重连初始间隔时间 initial-interval: 1000ms # 失败后下次间隔的时长倍数，下次间隔时长=本次间隔时长*multiplier multiplier: 1 # 最大重试次数 max-attempts: 3 注意：重试过程线程是被阻塞的，合理配置等待时长及最大重试次数，或开启异步线程执行，以免影响业务性能。
2、生产者确认 SpringBoot项目配置：
spring: rabbitmq: # 开启生产者确认 publisher-confirm-type: correlated # 返回路由失败消息，一般是开发问题，无需开启 publisher-returns: true publisher-confirm-type三种模式：
none关闭simple同步阻塞等待MQ回执消息correlated（推荐）MQ异步回调返回回执消息 注意：以上两种方式均会造成MQ性能下降，非必要不建议开启。失败情况毕竟非常少，可在代码中通过输出日志或存储数据库等方式将发送失败的消息记录下来，稍后手动处理。
3、数据持久化 交换机持久化：在声明交换器时将“durable”参数设置为true队列持久化：在声明队列的时将“durable”参数设置为true消息持久化：生产消息时设置属性delivery_mode=2 SpringBoot项目：
交换机和消息默认为持久化，需自行设置队列持久化。
@RabbitListener(bindings = @QueueBinding( value = @Queue(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9237d543d66c012c16de41ecf0348a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ab22e1e8585b9abf6e7c6930dc44c1/" rel="bookmark">
			Unity 工具“常用插件九大分类汇总”（UI/VR/AR/建模/Shader/动画/网络/AI/资源/数据/区块链等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 UI / 2D 相关： 1、Doozy UI Manager Doozy UI Manager是一套让任何人都可以轻松设计、管理和动画现代用户界面的系统。这是一套专门为专业人士设计的专业工具。
EditorUI是一组编辑器uielement组件，用于创建自定义编辑器。它负责Doozy UI Manager使用的所有编辑器。
使用本机uGUI本地编辑器集成节点图UI导航流程支持所有平台分辨率独立移动友好In-Editor文档链接可搜索的文档干净的代码。易于理解、修改和测试。提供了完整的c#源代码 2、Modern UI Pack Modern UI Pack 是一个干净，简约和时尚的UI包，为那些想要有更好和丰富的特色UI元素。它易于使用，完全可编辑和定制
3、Graph And Chart 适用于 Unity 的顶级 2D/3D 数据可视化。美观度、响应度和互动性。易于使用和快速设置。每项功能都可以从代码和编辑器中自定义。“图形和图表”兼容任何平台，包括 VR/AR、移动端、网页和桌面端。支持所有最新的 Unity 版本。与 UI Canvas 集成。
条形图 (2D/3D)、饼图 (2D/3D)、环面图 (2D/3D)、表图 (实时串流 2D/3D)、气泡图 (2D/3D)、雷达图 (2D/3D)、蜡烛图 (2D) 和金字塔图 (Beta 2D)。全部都可以使用您自己的颜色、尺寸、材料和预制件进行自定义。所有都可以根据尺寸自适应。所有都可以处理用户事件。
可以与一系列其他资源和功能相集成：
Playmaker、 TextMeshPro、自动加载 JSON/XML支持 LWRP 和 HDRP。 4、UGUI MiniMap UGUI迷你地图是一个完整的和易于使用的迷你地图/世界地图解决方案，使用完整的UGUI系统。你可以为赛车、FPS、RPG、RTS游戏等任何类型的游戏轻松创建任何类型的小地图。
你可以让它运行起来，就像拖放一个现成的小地图预制在你的场景
特点：
矩形和圆形迷你地图。实时和图片渲染模式。支持内置和通用渲染管道。针对移动平台进行优化。指南针酒吧。边境图标。世界地图点标记。新的RTS相机运动。圆边界图标。区域电网。3D和2D模式。静态或动态旋转地图。命中/伤害效果。世界地图和小地图静态映射模式。圆圈区域为每个图标。支持自定义地图掩码。在运行时轻松创建路点/图标。二维场景示例。平移渐变。HoofdPunt指标。放大和缩小。在编辑文档。易于使用(拖放)。自定义图标颜色、大小、精灵等。动画图标。缩放级别。按钮的物品。自动计算范围。干净的代码- c#。良好的注释。 5、3D WebView 使用与支持 Vuplex VR/AR 浏览器的相同代码，即可轻松在 Windows/MacOS/Android/iOS 上以 3D 形式渲染 Web 内容并与之进行交互。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9ab22e1e8585b9abf6e7c6930dc44c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c69f745971b811312a6fd80908135f1/" rel="bookmark">
			【史上最细教程】CentOS7 下载安装 RabbitMQ（两种方式：手动安装 / Docker安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【史上最细教程】CentOS7 下载安装 RabbitMQ方式一：手动安装1.下载安装Erlang、RabbitMQ2.防火墙、安全组端口放行3.启动RabbitMQ服务4.浏览器用户登录5.配置文件查看(可略) 方式二：Docker安装1.安装Docker2.获取RabbitMQ镜像、创建容器3.浏览器访问 扩展内容 【史上最细教程】CentOS7 下载安装 RabbitMQ 官网地址：https://www.rabbitmq.com/download.html
两种下载安装方式自选。
方式一：手动安装 1.下载安装Erlang、RabbitMQ # 查看系统版本号（centos7） root@songdanminserver:[/]lsb_release -a # 下载 # 下载 Erlang rpm安装包 # Erlang是RabbitMQ语言环境，需要先安装好 # 通过下面&lt;1.Erlang版本下载地址&gt;，选择centos7对应的Erlang安装包下载（erlang-23.3.4.11-1.el7.x86_64） # 用xftp上传到服务器（/usr/local/rabbitmq） # 下载 RabbitMQ rpm安装包 # 通过下面&lt;3.Erlang和RabbitMQ版本对照地址&gt;，选择Erlang版本对应的RabbitMQ版本 （rabbitmq-server-3.9.16-1.el7.noarch） # 用xftp上传到服务器（/usr/local/rabbitmq） # 安装 # 查看安装包 root@songdanminserver:[/usr/local/rabbitmq]ls erlang-23.3.4.11-1.el7.x86_64.rpm rabbitmq-server-3.9.16-1.el7.noarch.rpm # 安装Erlang root@songdanminserver:[/usr/local/rabbitmq]sudo yum localinstall -y /usr/local/rabbitmq/erlang-23.3.4.11-1.el7.x86_64.rpm root@songdanminserver:[/usr/local/rabbitmq]erl -v # q(). 退出 # 安装Socat root@songdanminserver:[/usr/local/rabbitmq]yum install -y socat root@songdanminserver:[/usr/local/rabbitmq]socat -V # Socat 是一种多功能的网络工具，可以创建各种类型的连接。 # 安装RabbitMQ root@songdanminserver:[/usr/local/rabbitmq]sudo yum localinstall -y /usr/local/rabbitmq/rabbitmq-server-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c69f745971b811312a6fd80908135f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6668c4344b84c354674b55c045ae5ea/" rel="bookmark">
			mac的python怎么运行py文件,macbook的python如何运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编为大家解答mac的python怎么运行py文件的问题。很多人还不知道macbook的python如何运行，现在让我们一起来看看吧！
首先，新建一个文本，改后缀名为.py，这样就成功建立了一个python程序（注意一定要显示文件拓展名，点击查看，选中文件拓展名）
编辑python程序方式：
1.右击——打开方式——记事本——编写python代码——ctrl+s保存——运行（点击保存路径，输入cmd回车打开代码窗口，接着输入python test.py(这里的test.py是你的文件名））
（1）打开记事本
（2）编写代码+保存（ctrl+s）
（3）运行（点击保存路径，输入cmd回车打开代码窗口，接着输入python test.py(注意！！！这里的test.py是你的文件名））
2.使用安装python自带编辑器
右击——选择Edit——编写代码——保存——F5运行（或者点击run后点击run module）
（1）右击打开
（2）编写代码
（3）运行
3.mac电脑，点击火箭台（启动台）找到IDLE/Windows电脑点击开始找到IDLE——点击file再点击New file——编写代码——保存——运行加粗样式****
（1）点击开始找到IDLE
（2）点击file再点击New file
（3）编写代码 保存（保存在哪里都可以） 运行
以上方法个人更建议第二种，如果是刚学习编程的小伙伴，没有学习编程的资源，可以关注我，我每天会把自己所学的内容记录在这里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fac08d2d8cb673cc274a9e5ea55a62c/" rel="bookmark">
			Github Copilot入门-问答形式带你全面了解Copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可以根据网站内容做一个GitHub Copilot教程吗？请先给出教程的提纲ChatGPT
当然可以。以下是一个关于如何使用GitHub Copilot的基础教程的提纲：
引言 1.1. 什么是GitHub Copilot 1.2. GitHub Copilot如何工作 1.3. GitHub Copilot的优点和限制安装和设置 2.1. 如何安装GitHub Copilot 2.2. 如何在你的编码环境中配置GitHub CopilotGitHub Copilot的基本使用 3.1. 输入代码片段以获取建议 3.2. 接受或拒绝建议 3.3. 编辑和修改建议 3.4. 如何在不同的编程语言中使用GitHub CopilotGitHub Copilot的高级使用 4.1. 如何用GitHub Copilot写函数 4.2. 如何用GitHub Copilot写类和方法 4.3. 如何用GitHub Copilot写测试 4.4. 使用GitHub Copilot快速原型设计GitHub Copilot的最佳实践 5.1. 如何最有效地使用GitHub Copilot 5.2. GitHub Copilot的常见问题和解决方案 5.3. 在不侵犯版权的情况下使用GitHub Copilot结论 6.1. GitHub Copilot的潜力和未来 6.2. GitHub Copilot在软件开发中的应用 每一章节都将提供详细的步骤、例子和相关的屏幕截图来说明如何使用GitHub Copilot。这个教程将适合于所有熟悉编程基础和有一定编程经验的读者。
请详细解释什么是GitHub CopilotChatGPT GitHub Copilot 是一个由 GitHub 和 OpenAI 合作开发的 AI 驱动的代码助手。它的工作原理基于 OpenAI 的 GPT-3（或更高版本）模型，该模型已经在大量的公开源代码上进行了训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fac08d2d8cb673cc274a9e5ea55a62c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfbe19a4416a23fc09b0776ae6155f16/" rel="bookmark">
			解决JSONObject中属性为null时，不显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在spring boot项目中用JSONObject来存放参数，并传参时发现参数为null时，这个键值对会被移除
查看源码发现，在忽略null模式下，参数为null会被移除
那么，如何解决呢？
1、新建一个Map
HashMap&lt;String, Object&gt; entriesMap = new HashMap&lt;&gt;(); 2、将键值对放入Map中
entriesMap.put("status",null); entriesMap.put("enableTranslate",true); entriesMap.put("oIds",empStatus); entriesMap.put("isWithDeleted",true); 3、转换为JSONObject对象
JSONObject entries = JSONUtil.parseObj(entriesMap,false); 使用JSONUtil.parseObj方法可以设置参数选择是否忽略空值
成功解决啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cca953ff5e0266578d15046c6362391/" rel="bookmark">
			Java中的contains方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Java 中，`contains` 方法是 `Collection` 接口中定义的一个方法，用于检查集合（如 `List`、`Set` 等）是否包含特定的元素。当你调用这个方法时，它会检查集合内是否存在一个元素等同于所提供的参数。
具体到 `HashSet` 这种类型的集合中，`contains` 方法的工作原理如下：
1. **参数**：`contains` 方法接受一个对象作为参数，这个对象是你想在集合中查找的元素。
2. **返回值**：如果集合中包含一个与所提供参数相等的元素，`contains` 方法返回 `true`。否则，返回 `false`。
3. **效率**：在 `HashSet` 中，`contains` 方法非常高效，因为 `HashSet` 基于哈希表实现。哈希表允许快速查找，所以即使在包含大量元素的情况下，`contains` 方法的时间复杂度通常接近 O(1)。
4. **相等性的判断**：`contains` 方法使用元素的 `equals` 方法来判断是否相等。在 Java 中，两个对象如果通过 `equals` 方法比较返回 `true`，则被视为相等。
举个例子，如果你有一个 `HashSet&lt;Integer&gt;` 并且你想检查它是否包含数字 5，你会这样调用 `contains` 方法：
```java
Set&lt;Integer&gt; mySet = new HashSet&lt;&gt;();
mySet.add(1);
mySet.add(2);
mySet.add(5);
boolean containsFive = mySet.contains(5); // 这会返回 true
```
在这个例子中，`containsFive` 会被赋值为 `true`，因为 5 是 `mySet` 集合的一个元素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9758749b1014c95c117863db088998d/" rel="bookmark">
			Java中使用RabbitMQ(持续更新中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 前言
RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang （ https://www.erlang.org/downloads ）。同时，在安装RabbitMQ 时需要注意RabbitMQ 与Erlang的对应版本，防止安装过程中出错。一般情况下，版本均选择新版本不会有太大问题，但还是需要注意下。可以参考RabbitMQ 的社区，里面有介绍版本号及推荐的Erlang版本。
1.windows安装 需要安装Erlang和RabbitMQ两个东西
1.1 安装Erlang 1.1.1 下载 地址:https://www.erlang.org/downloads
1.1.2 安装 傻瓜式安装,双击下一步即可 (安装到没有中文的目录下)
1.1.3 配置环境变量 1.1.4 测试安装 Win+R打开运行，输入cmd进入黑窗口。输入 erl，出来版本号即成功。
1.2 安装RabbitMQ 1.2.1 下载 地址:https://www.rabbitmq.com/download.html
1.2.2 安装 1.2.2.1 傻瓜式安装,双击下一步即可(安装在没有中文的目录)
打开命令行cd，输入RabbitMQ的sbin目录。
E:\Program Files\RabbitMQ Server\rabbitmq_server-3.7.4\sbin 然后输入以下命令进行安装
rabbitmq-plugins enable rabbitmq_management 验证rabbitmq是否安装成功
rabbitmqctl status 如果出现以下的图，说明安装是成功的，并且说明现在RabbitMQ Server已经启动了,运行正常
打开浏览器，地址栏输入mq访问地址，即可看到管理界面的登陆页
http://127.0.0.1:15672
输入用户名和密码，都为guest 进入主界面
1.2.3 安装可能遇到的问题 出现 Authentication failed (rejected by the remote node), please check the Erlang cookie
如果改完cookie没生效，重启一下电脑，清除cookie缓存，获取最新修改的cookie，即可解决该问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9758749b1014c95c117863db088998d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8416c07e9276733ed44495040484a9cb/" rel="bookmark">
			Go语言开发利器：几种主流IDE的优势与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：Go 语言因其简洁、高效和强大的并发模型而受到越来越多开发者的青睐。为了提高 Go 语言开发的效率，选择一款合适的集成开发环境（IDE）至关重要。本文将详细介绍几种 Go 语言开发常用的 IDE，包括 Visual Studio Code、Goland、IntelliJ IDEA、Code::Blocks 等，并分析各自的优缺点，帮助 Go 语言开发者找到最适合自己的开发工具。
一、Visual Studio Code
Visual Studio Code（简称 VS Code）是由微软开发的一款免费、开源的代码编辑器，通过安装插件可以支持 Go 语言的开发。
优势：
1、轻量级：VS Code 启动速度快，占用资源少，适合轻量级开发需求。
2、插件丰富：VS Code 拥有庞大的插件市场，可以通过安装插件来拓展功能。
3、代码提示：VS Code 的代码提示功能非常强大，可以帮助开发者快速补全代码。
4、版本控制：内置 Git 功能，方便进行版本控制。
劣势：
1、功能相对简单：作为一款代码编辑器，VS Code 的功能相对较弱，无法与专业的 IDE 相比。
2、性能较差：在处理大型项目时，VS Code 的性能可能会略显不足。
二、Goland
Goland 是 JetBrains 推出的一款专为 Go 语言设计的 IDE，具有强大的功能和丰富的特性。
优势：
1、专业化：Goland 是一款专业的 Go 语言 IDE，内置丰富的 Go 语言特性支持，如代码提示、静态检查等。
2、项目管理：Goland 提供完善的项目管理功能，方便开发者管理多个项目。
3、性能优异：Goland 针对Go语言优化，性能表现出色，适合大型项目开发。
4、集成工具：Goland 内置了许多实用的工具，如数据库工具、版本控制等。
劣势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8416c07e9276733ed44495040484a9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a6b2f28a06766e9759fc58a04d7413/" rel="bookmark">
			Hive 的日志路径查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive日志
hive分为两种日志
1、系统日志，记录hive服务运行情况，错误状况
进入hive shell 窗口，执行以下命令，将显示当前配置的系统日志属性值，默认为/var/log/hive
&gt;set system:hive.log.dir; +-------------------------------------+ | set | +-------------------------------------+ | system:hive.log.dir=/var/log/hive | +-------------------------------------+ 修改配置可以在 /etc/hive/conf/下的hive-env.sh配置的hive.log.dir ，修改完毕后重启hive服务
2、查询日志，记录hive中的查询执行的日志
进入hive shell窗口，执行以下命令，将显示当前配置的属性值，默认为tmp/hive。
&gt;set hive.querylog.location; +-----------------------------------+ | set | +-----------------------------------+ | hive.querylog.location=/tmp/hive | +-----------------------------------+ 修改配置可以在 /etc/hive/conf/下的hive-site.xml配置的hive.querylog.location，修改完毕后重启hive服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ce457384068714de57debb46d83e3d/" rel="bookmark">
			Mysql 恢复误删库表数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前提 1、如果你的数据库有备份文件，自己还原即可。
2、如果没有备份文件，那首先检查下你的 binlog 是否开启。如果未开启，那你就不用往下看了。如果开启了，可以往下看看。
1.1 查看位置 可以通过以下的命令查看是否开启了 binlog 以及它的存储路径，mysql8.0 版本是默认开启的。
show variables like '%log_bin%' 二、简单场景演示 2.1 背景 此时演示的数据库版本是 Mysql 8.0。且创建表、插入数据和删除表都是在一个 binlog 里面完成的。
2.2 创建数据库 确认 binlog 是开启状态之后，创建测试数据库，在测试数据库中创建测试表，并写入数据，脚本如下：
create database if EXISTS itcast; use itcast; create table tb_user( id int(11) not null, name varchar(50) not null, sex varchar(1), primary key (id) )engine=innodb default charset=utf8; insert into tb_user(id,name,sex) values(1,'Tom','1'); insert into tb_user(id,name,sex) values(2,'Trigger','0'); insert into tb_user(id,name,sex) values(3,'Dawn','1'); 2.3 删除数据库 执行下面的语句将数据库删除掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65ce457384068714de57debb46d83e3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2eec714ae8d3e80c08648c83f281790/" rel="bookmark">
			【大数据安全-Kerberos】Kerberos常见问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【大数据安全-Kerberos】Kerberos常见问题及解决方案 1）总结2）异常处理2.1.GSS initiate failed2.2.kinit 异常2.3.LoginException2.4.HTTP 异常2.5.其他异常 1）总结 可以用来帮助诊断 Kerberos 相关问题的原因并实施解决方案的指南。
2）异常处理 2.1.GSS initiate failed javax.security.sasl.SaslException: GSS initiate failed [Caused by GSSException: No valid credentials provided (Mechanism level: Failed to find any Kerberos tgt)]
此消息表明一个操作尝试要求以 Kerberos 的 user/host@realm 身份认证的操作，但票据 cache 中没有用于 user/host@realm 的票据。
用户环境引用的策略/票证缓存文件丢失、不可读（权限）、损坏或无效
票证续签寿命设置为零
票证授予票证（TGT）不存在，因为服务A需要将命令作为服务B运行，但尚未正确配置为允许模拟服务B
票证更新尚未执行/未成功。这可能是由于CDH 5.3之前的HBASE或CDH5.2之前的Hive / Sentry缺陷引起的
该用户的凭据尚未在KDC中生成
执行了手动步骤，例如hadoop fs -ls，但是用户从未通过Kerberos身份验证
Oracle JDK 6 Update 26或更早版本无法读取由MIT Kerberos 1.8.1或更高版本创建的Kerberos凭证高速缓存。
某些版本的Oracle JDK 8可能会遇到此问题
配置useTicketCache=false，如果配置为true在新版本中可能不支持，就会出现每次票据更新的时间点产生GSS的问题
javax.security.sasl.SaslException: GSS initiate failed [Caused by GSSException: No valid credentials provided (Mechanism level: Fail to create credential.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2eec714ae8d3e80c08648c83f281790/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a28246b94c073c17e0d2e42f799f7c/" rel="bookmark">
			DBeaver安装与使用教程（MacOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 DBeaver安装使用教程（MacOS）1. 简介2. 安装3. 使用3.1. 添加数据库连接3.2. sql执行 DBeaver安装使用教程（MacOS） 1. 简介 DBeaver 是一个通用的数据库管理工具和客户端，几乎支持所有主流的数据库（MySQL, MariaDB, PostgreSQL, SQLite, Clickhouse等）。DBeaver需要JDK1.8以上的环境，使用DBeaver之前电脑需配置好JDK环境。
2. 安装 下载链接：官方下载网站，选择对应版本。
下载好打开安装包。
直接拖拽安装。
点击启动即可，第一次打开的弹窗表示是否需要创建示例数据库，可随便勾选（如图勾选是，会出现一个示例连接）
3. 使用 3.1. 添加数据库连接 点击左上角 - 添加。
选择对应的数据库 - MySQL
输入连接方式、用户密码等。
配置好后，先点击测试连接，第一次连接可能未导入对应驱动，直接勾选下载即可。
下载完成，显示连接成功表示已完成连接。
最后，点击完成。
3.2. sql执行 选择对应的表。 选择数据。
双击此处，可执行自定义sql。
如下所示。
也可选择在控制台中读数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5418ff642a192ea5c3a28b19257ac11e/" rel="bookmark">
			【强化学习战场谁为王？】近端策略优化算法 PPO、优势演员-评论家算法 A2C、异步优势演员-评论家算法 A3C、深度确定性策略梯度 DDPG、软性演员-评论家算法 SAC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		演员-评论家AC变种：近端策略优化算法 PPO、优势演员-评论家算法 A2C、异步优势演员-评论家算法 A3C、深度确定性策略梯度 DDPG、软性演员-评论家算法 SAC 强化学习战场：A2C、A3C、DDPG、SAC 与 PPO，哪个才是真正的王者？近端策略优化算法 PPO优势演员-评论家算法 A2C异步优势演员-评论家算法 A3C深度确定性策略梯度 DDPG软性演员-评论家算法 SAC 强化学习战场：A2C、A3C、DDPG、SAC 与 PPO，哪个才是真正的王者？ 我将逐一介绍这些算法，各自的问题背景、改进点、组成要素以及局限性：
A2C (优势演员-评论家算法)
问题背景: A2C 被提出来改进基本的演员-评论家算法，提高学习效率和稳定性。改进点: A2C 使用优势函数（Advantage function）代替原始的价值函数，减少方差，提高学习稳定性。组成要素: A2C 包括两部分，演员（负责选择动作）和评论家（评估动作的好坏）。优势函数是其核心，用于评价动作相比平均水平的优劣。局限性: A2C 适用于离散动作空间，但在连续动作空间中表现不佳。 A3C (异步优势演员-评论家算法)
问题背景: 为了进一步提升训练速度和效率，A3C 引入了异步训练机制。改进点: A3C 允许多个智能体并行在不同的环境实例中学习，并异步更新全局模型。组成要素: 与 A2C 类似，包括演员和评论家，但在多个并行环境中同时运行。局限性: 需要大量并行执行资源，且难以稳定训练过程。 DDPG (深度确定性策略梯度)
问题背景: 针对连续动作空间的优化问题。改进点: DDPG 结合了确定性策略（更高效的探索）和深度学习（处理复杂环境）。组成要素: 包括一个确定性策略的演员和一个价值函数的评论家，还使用经验回放和软更新技术。局限性: 需要大量的样本和较慢的收敛速度。 SAC (软性演员-评论家算法)
问题背景: 为了在连续动作空间中平衡探索与利用。改进点: SAC 引入了熵作为奖励的一部分，鼓励探索。组成要素: 包括演员、评论家和熵优化机制。局限性: 相对于其他算法，SAC 更为复杂，且调参更为困难。 PPO (近端策略优化)
问题背景: PPO 被设计为解决策略梯度方法中策略更新步长难以控制的问题，特别是为了改善早期方法如梯度策略算法的复杂性和效率问题。改进点: PPO 通过简化策略更新机制，旨在提供一种既简单又有效的方式来平衡探索和利用。它使用了一种剪裁（clipping）机制，限制策略更新的幅度，从而避免在学习过程中出现过大的策略变动。组成要素: PPO 包括一个演员（用于生成动作）和一个评论家（用于评价这些动作）。此外，PPO 还使用了特殊的目标函数和剪裁机制来平衡策略更新的稳定性和效率。局限性: 尽管 PPO 相比于其他方法简化了训练过程，但它的性能仍然高度依赖于超参数的选择，尤其是剪裁参数的设置。此外，在某些特别复杂的环境中，PPO 可能不如其他更复杂的算法表现得好。 没有一个算法可以称为“真正的王者”，因为每个算法都有其适用的场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5418ff642a192ea5c3a28b19257ac11e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34abafe3028fc8774552a8593d0725b4/" rel="bookmark">
			Java中的throw和throws：异常处理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单来说就是：你用throws不一定会抛出异常，它只是代表这个方法可能抛出这个异常，像打个预防针一样；
你要用throw那一定会抛出异常，因为throw是一个行为，代表抛出异常的动作。 一. throw关键字： 1.作用： throw关键字用于在程序中手动抛出一个异常。当异常发生时，程序会中断当前的执行流程，并将异常信息传递给上层的异常处理机制。
2.使用场景： (a)当我们发现某些条件不符合业务逻辑要求时，我们可以使用throw关键字抛出一个异常。
(b)当我们在定义自己的异常类时，可以通过throw关键字主动抛出这个自定义的异常对象。
3.代码示例： public void checkAge(int age) { if (age &lt; 0) { throw new IllegalArgumentException("年龄不能为负数"); } } 二. throws关键字： 1.作用： throws关键字用于指定方法可能抛出的异常。它标识了哪些异常可以传递到方法的调用者，需要调用者进行相应的处理。
2.使用场景： (a)当方法内部的代码可能会引发异常时，可以使用throws关键字声明这些异常。
(b)当我们不希望在当前方法中捕获异常，并且希望将异常传递给上层调用者来处理时，可以使用throws关键字。
3.代码示例： public void readFile() throws IOException { // 异常处理逻辑 } 三. 区别与联系： throw关键字是用于在方法内抛出异常，而throws关键字是在方法声明中指定可能抛出的异常。
throw关键字通常用于手动抛出异常，而throws关键字通常用于声明方法可能抛出的异常。throw关键字只能抛出一个异常对象，而throws关键字可以同时指定多个异常。throw关键字会中断当前的执行流程，寻找合适的异常处理机制，而throws关键字将异常传递给调用者来处理。 四. 完整的例子说明（1）： 下面我们通过一个完整的例子来说明throw和throws的使用：
public class Example { public void divide(int a, int b){ if (b == 0) { throw new ArithmeticException("除数不能为0"); } int result = a / b; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34abafe3028fc8774552a8593d0725b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fec521b7fd4f87b4cdf3a0f084a1df8/" rel="bookmark">
			人工智能课程设计毕业设计——基于机器学习的手写汉字识别系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要完整代码和论文私信我 《机器学习》课程设计实验报告
题目：基于深度学习的手写汉字识别系统
目录
基于深度学习的手写汉字识别系统实验报告
1.绪论............................................................................................................................................................ 1
1.1 研究背景及意义.......................................................................................................................... 1
1.2 国内外研究现状.......................................................................................................................... 1
1.3 研究内容....................................................................................................................................... 2
2.相关技术概述........................................................................................................................................... 2
3.数据准备.................................................................................................................................................... 2
3.1 数据获取....................................................................................................................................... 2
3.2 数据预处理................................................................................................................................... 3
4.数据描述性分析....................................................................................................................................... 5
5.模型选择、训练与测试........................................................................................................................... 6
5.1深度学习与传统机器学习............................................................................................................ 6
5.2卷积神经网络................................................................................................................................. 6
5.3模型训练......................................................................................................................................... 8
5.4模型测试....................................................................................................................................... 14
6.模型性能评估与优化.............................................................................................................................. 15
6.1模型性能评估.............................................................................................................................. 15
6.2模型优化....................................................................................................................................... 16
7.模型部署与使用..................................................................................................................................... 18
7.1模型部署....................................................................................................................................... 18
7.2模型使用....................................................................................................................................... 18
8.总结.......................................................................................................................................................... 20
参考文献...................................................................................................................................................... 21
附录.............................................................................................................................................................. 23
(1) 程序清单............................................................................................................................................. 23
(2) 源代码................................................................................................................................................. 23
基于深度学习的手写汉字识别系统实验报告
1.绪论
研究背景及意义 在上世纪60年代，美国IBM公司开始进行了对印刷体汉字的模式识别研究工作；1996年Casey和Nag用模板匹配法成功的识别出了1000个印刷体汉字，在全球范围内，基于汉字的识别研究开始展开了。而就在这个时候，研究界对手写汉字识别也掀起了高潮。日本率先开始研究手写汉字识别，到了80年代，国内开始了对手写汉字的研究，因为汉语作为我们的母语，汉字主要在我国广泛使用，对汉字的种类、内涵、造字原理国内的掌握情况较透彻，所以关于手写汉字识别的深入研究主要集中在国内。至今，手写汉字识别已经具备了比较成熟的理论基础和广阔的运用前景，近年来，随着机器学习和人工智能产业的高速发展，手写文字识别更是被广泛运用。
在实际运用中，手写汉字识别被用于汉字扫描、机器自动阅卷、票据识别、证件识别等，提高了汉字的输入效率，降低了手动输入汉字的错误率，极大便利了人们的工作和生活。手写体汉字识别是一个具有挑战性的模式识别和机器学习问题。汉字结构复杂，相似性大、数量大、种类多等特点给汉字识别研究带来很多困难，尤其是手写汉字识别，不同人具有不同的手写风格，在不同的书写环境下容易发生形变，再加上汉字又分为行书、草书、楷书等多种形式，手写汉字识别问题的研究一直困扰着字符识别研究学者的一个关键性难题。
本次机器学习课程设计项目我们小组基于卷积神经网络算法设计了手写汉字识别系统，采用卷积神经网络实现的低成本和快速高效手写汉字图像识别系统，将在日常工作和生活中带来极大的现实意义，同时也有着非常重要的研究意义。
国内外研究现状 如今在手写字识别领域，存在的识别方法有多种。手写汉字识别由于数据采集方式不同可以划分为脱机手写体汉字识别和联机手写体汉字识别两大类：联机手写汉字识别所处理的手写文字是书写者通过物理设备(如数字笔、数字手写板或者触摸屏)在线书写获取的文字信号，书写的轨迹通过定时采样即时输入到计算机中；而脱机手写文字识别所处理的手写文字是通过扫描仪或摄像头等图像捕捉设备采集到的手写文字二维图片。目前，比较常用的手写汉字识别方法有K最近邻算法、神经网络、隐马尔可夫模型、贝叶斯分类器、支持向量机和改进的二次判别函数等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fec521b7fd4f87b4cdf3a0f084a1df8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a41699b37519957a9f21a6411a8cb1a/" rel="bookmark">
			115 道 MySQL 面试题，从简单到深入！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是数据库事务？ 数据库事务是一个作为单个逻辑工作单元执行的一系列操作。事务具有ACID属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这意味着事务内的操作要么全部成功，要么全部失败，保持数据完整性，并且独立于其他事务运行。
2. MySQL中InnoDB与MyISAM的区别是什么？ InnoDB支持事务处理，行级锁定和外键，适用于需要高并发和事务处理的场景。MyISAM不支持事务和行级锁定，但读取速度快，适用于查询密集型的场景。
3. 解释MySQL中的JOIN操作。 JOIN操作用于结合两个或多个数据库表的行。类型包括INNER JOIN（只返回两表匹配的行）、LEFT JOIN（返回左表的所有行及右表匹配的行）、RIGHT JOIN（返回右表的所有行及左表匹配的行）等。
4. 如何优化MySQL查询？ 优化MySQL查询的方法包括：使用合适的索引、避免在WHERE子句中使用函数、选择合适的数据类型、使用LIMIT语句减少数据量、避免全表扫描、合理设计表结构等。
5. 什么是索引，它是如何提高查询性能的？ 索引是数据库对象，可以提高数据检索的速度。它类似于书的目录，使数据库能够快速定位并检索数据，而不必扫描整个表。索引尤其在处理大量数据时显著提高查询性能。
6. 解释MySQL中的主键与唯一键的区别。 主键（Primary Key）是表中用于唯一标识每条记录的列或列的组合。一个表只能有一个主键，且主键列的值必须是唯一的，不允许为NULL。唯一键（Unique Key）也确保列的值唯一，但一个表可以有多个唯一键，并且唯一键的列可以包含NULL值。
7. 什么是视图，它有什么优点？ 视图是基于SQL语句的结果集的可视化表现。它像一个虚拟表，包含了从一个或多个表中获取的数据。视图的优点包括简化复杂SQL查询、保护数据（通过限制对特定数据的访问）、更改数据格式和表示等。
8. MySQL中的存储过程是什么？ 存储过程是一组为了完成特定功能的SQL语句，它存储在数据库中，可以通过指定的名称和参数进行调用。存储过程可以提高SQL代码的重用性，减少网络通信量，提高性能。
9. 什么是归一化？它有哪些类型？ 归一化是数据库设计中的一个过程，目的是减少数据冗余和提高数据完整性。它涉及将数据组织到逻辑上的表中，使每个表专注于一个主题或概念。常见的归一化形式包括第一范式（1NF）、第二范式（2NF）、第三范式（3NF）和博耶-科得范式（BCNF）。
10. 解释MySQL中的外键。 外键是一种数据库约束，用于建立两个表之间的关系。在一个表中的外键会指向另一个表的主键。外键的主要作用是维护跨表的数据完整性，确保参照完整性。
11. 解释MySQL中的事务隔离级别以及它们如何影响并发。 MySQL支持四种事务隔离级别：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。这些隔离级别逐渐增强了事务之间的隔离，防止了不同程度的并发问题，如脏读、不可重复读和幻读，但同时可能降低并发性能。例如：
READ UNCOMMITTED：允许读取尚未提交的数据变更，可能导致脏读。READ COMMITTED：只能读取已提交的数据，避免了脏读。REPEATABLE READ：保证在同一个事务内多次读取的数据一致，MySQL默认级别。SERIALIZABLE：完全串行化的读，防止脏读、不可重复读和幻读，但性能代价最高。 12. 如何在MySQL中使用索引优化查询？ 使用索引优化查询的一种方式是确保WHERE子句中的条件使用了索引。例如，假设有一个名为students的表，其中包含name和age列，对age列有索引：
SELECT * FROM students WHERE age &gt; 18; 这个查询将利用age列的索引，提高查询效率。
13. MySQL中的慢查询日志是什么，如何使用它来优化性能？ 慢查询日志是MySQL用来记录执行时间超过预设阈值的查询语句的日志。通过分析这些查询，可以发现哪些查询最消耗资源，然后对它们进行优化。可以通过设置long_query_time参数来定义什么构成慢查询。
14. MySQL中如何实现主从复制？ 在MySQL中实现主从复制涉及以下步骤：
在主服务器上配置唯一的服务器ID，开启二进制日志记录。在从服务器上设置唯一的服务器ID，配置主服务器的相关信息（如主服务器IP、登录凭证）。在主服务器上创建一个具有复制权限的用户账户，供从服务器使用。初始化从服务器的数据，并启动复制进程。 这些步骤可以通过修改MySQL的配置文件（例如my.cnf或my.ini）和执行SQL命令来完成。
15. 解释MySQL中的分区表，它如何提高性能？ 分区表是将一个大的表分成多个小的物理段的技术。这可以通过范围（RANGE）、列表（LIST）、散列（HASH）或键（KEY）等方式进行。分区可以提高性能，因为：
查询可以仅在相关的一个或几个分区上运行，而不是整个表。分区也可以在不同的磁盘上进行，提高I/O性能。 例如，可以根据年份对销售数据表进行范围分区：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a41699b37519957a9f21a6411a8cb1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff44dec1842f04d0be95622ae01a0834/" rel="bookmark">
			Python常用代码大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Hello World 1
print("Hello World!")
这段代码使用 print 函数输出字符串 “Hello World!” 到控制台。
2、计算数字的平方和 以下是使用 python 计算数字的平方和的代码：
1
2
3
4
5
6
7
def square_sum(numbers):
sum = 0
for num in numbers:
sum += num ** 2
return sum
print(square_sum([1, 2, 3, 4])) # 输出 30
3、计算简单数学表达式 1
2
3
4
5
6
7
8
9
# 计算简单数学表达式
def calculate(expression):
return eval(expression)
# 用户输入数学表达式
expression = input("请输入一个数学表达式：")
# 计算并输出结果
print("结果是：", calculate(expression))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff44dec1842f04d0be95622ae01a0834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e27163ead181fcc509c2de1826b52d5/" rel="bookmark">
			Spark在Windows下的环境搭建及pyspark的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JDK的安装 Spark是一个用于大数据处理的开源框架，它是用Scala编写的，而Scala是一种运行在Java虚拟机（JVM）上的编程语言，因此它依赖于Java的运行环境。所以首先需要安装JDK（JavaTM Platform Standard Edition Development Kit），并将环境变量配置好。
可参考我的另一篇博客：http://t.csdnimg.cn/6Kj8w
二、Spark的安装 1.下载Spark 从Spark官网进行下载：Apache Spark™ - Unified Engine for large-scale data analytics，点击Download
这里我下载2.2.0版本，滑到下面，选择Archived releases，点击Spark release archives
找到2.2.0版本
选择带有Hadoop版本的Spark： spark-2.2.0-bin-hadoop2.7.tgz 意思是Spark版本是2.2.0，还需安装hadoop2.7版本
单击即可下载
下载完成后将文件进行解压，得到大约200M的文件： spark-2.2.0-bin-hadoop2.7
最好解压到一个盘的根目录下，并重命名为Spark，简单不易出错。并且需要注意的是，在Spark的文件目录路径名中，不要出现空格和中文，类似于“Program Files”这样的文件夹名是不被允许的，我放的位置是D:\Spark
2.配置环境变量 系统变量创建SPARK_HOME：D:\Spark\spark-2.2.0-bin-hadoop2.7
系统变量中的Path添加：%SPARK_HOME%\bin 3.测试是否安装成功 Win+R键打开运行窗口，输入cmd，命令行串口输入spark-shell
出现下图即安装成功
这时开启的是Spark的交互式命令行模式，但直接使用很有可能会碰到各种错误，如下图，这里主要是因为Spark是基于hadoop的，所以这里还需配置一个Hadoop的运行环境。
三、Hadoop的安装 1.下载Hadoop 下载上面spark对应版本的hadoop 2.7:Hadoop Releases
我这里选择2.7.1版本
选择好相应版本并点击后，进入详细的下载页面，如下图所示
上面的src版本就是源码，需要对Hadoop进行更改或者想自己进行编译的可以下载对应src文件，我这里下载的就是已经编译好的版本，即图中的“hadoop-2.7.1.tar.gz”文件
下载并解压到指定目录，我这里是D:\Hadoop
2.配置环境变量 系统变量创建HADOOP_HOME：D:\Hadoop\hadoop-2.7.1
系统变量中的Path添加：%HADOOP_HOME%\bin
3.安装winutils.exe winutils.exe是在window系统上安装hadoop时必要的文件，可在github上下载
github下载地址：https://github.com/steveloughran/winutils
选择对应安装的Hadoop版本号
进入到bin目录下
找到winutils.exe文件，单击下载
将下载好的winutils.exe文件放入到Hadoop的bin目录下，我是D:\Hadoop\hadoop-2.7.1\bin
4.测试是否安装成功 Win+R键打开运行窗口，输入cmd，命令行串口输入hadoop
四、常见问题 正常情况下是可以运行成功并进入到Spark的命令行环境下的，但是可能会遇到如下错误：
&lt;console&gt;:14: error: not found: value spark import spark.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e27163ead181fcc509c2de1826b52d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43a1d7a6f6dc953ca35c0e9d0c6af07/" rel="bookmark">
			Python 操作 Word 详解（python-docx）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 概述1.1 第三方库：python-docx 2 新建文档2.1 空白文档2.2 标题2.3 段落2.4 文本2.5 字体2.6 图片2.7 表格 3 扩展3.1 修改文档3.2 读取文档 1 概述 1.1 第三方库：python-docx &gt; pip install python-docx 2 新建文档 2.1 空白文档 import docx from docx import document # 1.新建 文档对象 doc = docx.Document() # [可选] 代码提示。需增加下列代码 # print(type(doc)) assert isinstance(doc, document.Document) # 格式：doc, doc 的类型 # 2.保存文档，绝对路径 和 相对路径 均可 # doc.save(r'C:\Users\Administrator\Desktop\test.docx') doc.save('test.docx') 2.2 标题 import docx from docx import document # 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d43a1d7a6f6dc953ca35c0e9d0c6af07/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/539/">«</a>
	<span class="pagination__item pagination__item--current">540/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/541/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>