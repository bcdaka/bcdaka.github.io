<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8007a42b0ff323ea3023616d3da0b6b/" rel="bookmark">
			前端高频面试题 js中堆和栈的区别和浏览器的垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 栈(stack)和 堆(heap) 栈(stack)：是栈内存的简称，栈是自动分配相对固定大小的内存空间，并由系统自动释放，栈数据结构遵循FILO（first in last out）先进后出的原则，较为经典的就是乒乓球盒结构，先放进去的乒乓球只能最后取出来。
堆(heap)：是堆内存的简称，堆是动态分配内存，内存大小不固定，也不会自动释放，堆数据结构是一种无序的树状结构，同时它还满足key-value键值对的存储方式；我们只用知道key名，就能通过key查找到对应的value。比较经典的就是书架存书的例子，我们知道书名，就可以找到对应的书籍。
栈的特点：开口向上、速度快,容量小；堆的特点：速度稍慢、容量比较大；
二、 基本类型和引用类型 基本数据类型：Undefined,String,Boolean,Null,Number，都是直接按值存放在栈内存中，占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。
引用数据类型：指那些可能由多个值构成的对象，如对象(Object)、数组(Array)、函数(Function) ，它们是通过拷贝和new出来的，这样的数据存储于堆中。
三、 传值和传址的区别 基本类型：采用的是值传递。
引用类型：则是地址传递。
引用类型的数据的地址指针是存储于栈中的，将存放在栈内存中的地址赋值给接收的变量。当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据（保存在堆内存中,包含引用类型的变量实际上保存的不是变量本身，而是指向该对象的指针）。
四、 内存分配垃圾回收 1.内存分配：
（1）栈内存：线性有序存储，容量小，系统分配效率高。
（2）堆内存：首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。
2.垃圾回收：
（1）栈内存：变量基本上用完就回收了，相比于堆来说存取速度会快，并且栈内存中的数据是可以共享的。
（2）堆内存：堆内存中的对象不会随方法的结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)。创建对象是为了反复利用（因为对象的创建成本通常较大），这个对象将被保存到运行时数据区（也就是堆内存）。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。
五、浏览器垃圾回收机制 1. 浏览器的垃圾回收机制 (1). 垃圾回收的概念
垃圾回收：JavaScript代码运⾏时，需要分配内存空间来储存变量和值。当变量不在参与运⾏时，就需要系统收回被占⽤的内存空间，这就是垃圾回收。
回收机制：
● Javascript 具有⾃动垃圾回收机制，会定期对那些不再使⽤的变量、对象所占⽤的内存进⾏释放，原理就是找到不再使⽤的变量，然后释放掉其占⽤的内存。
● JavaScript中存在两种变量：局部变量和全局变量。全局变量的⽣命周期会持续要⻚⾯卸载；⽽局部变量声明在函数中，它的⽣命周期从函数执⾏开始，直到函数执⾏结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执⾏结束后，这些局部变量不再被使⽤，它们所占有的空间就会被释放。
● 不过，当局部变量被外部函数使⽤时，其中⼀种情况就是闭包，在函数执⾏结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使⽤，所以不会回收。
(3) 垃圾回收的⽅式
浏览器通常使⽤的垃圾回收⽅法有两种：标记清除，引⽤计数。
(1）标记清除
● 标记清除是浏览器常⻅的垃圾回收⽅式，当变量进⼊执⾏环境时，就标记这个变量“进⼊环境”，被标记为“进⼊环境”的变量是不能被回收的，因为他们正在被使⽤。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
● 垃圾收集器在运⾏的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引⽤的标记。⽽在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经⽆法访问到这些变量了。最后。垃圾收集器完成内存清除⼯作，销毁那些带标记的值，并回收他们所占⽤的内存空间。
(2）引⽤计数
● 另外⼀种垃圾回收机制就是引⽤计数，这个⽤的相对较少。引⽤计数就是跟踪记录每个值被引⽤的次数。当声明了⼀个变量并将⼀个引⽤类型赋值给该变量时，则这个值的引⽤次数就是1。相反，如果包含对这个值引⽤的变量⼜取得了另外⼀个值，则这个值的引⽤次数就减1。当这个引⽤次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运⾏时，这个变量所占有的内存空间就会被释放出来。
● 这种⽅法会引起循环引⽤的问题：例如： obj1 和 obj2 通过属性进⾏相互引⽤，两个对象的引⽤次数都是2。当使⽤循环计数时，由于函数执⾏完后，两个对象都离开作⽤域，函数执⾏结束，obj1 和 obj2 还将会继续存在，因此它们的引⽤次数永远不会是0，就会引起循环引⽤。
function fun() { let obj1 = {} let obj2 = {} obj1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8007a42b0ff323ea3023616d3da0b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e111319ea96d68d6d3dd9aae903710/" rel="bookmark">
			数据结构双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，好久不见，今天我们讲链表的双向链表，这是一个很厉害的链表，带头双向且循环，学了这个链表，你会发现顺序表的头插头删不再是一个麻烦问题，单链表的尾插尾删也变得简单起来了，那废话不多说，让我们开始我们的学习吧！
首先我们要了解它的物理和逻辑结构，那他们的样子是怎样的呢，首先是一个带头的，那这个难道是我们的哨兵位吗，又是双向，且循环，那让我们来画图了解它吧。
大致就是这样的一个形状，那我们现在需要这样的一个结构体来实现这样的功能，首先应该有一个存储数据的，就是data，然后就是得有两个指针，一个指向前面的节点，一个就是指向后面的节点，那我们就叫它们一个pre指向前面，一个next指向后面，我们来实现一下吧。
typedef int DListType; typedef struct DList { struct DList* pre; struct DList* next; DListType data; }DLNode; 为了方便我们写后面的时候结构体方便一点，我们先定义结构体为DLNode，这样更加方便使用。
现在我们要实现下面的各种接口来完成双链表
首先最重要的就是怎么初始化
初始化的话我们先要想想这个接口函数改的参数和返回值
因为是双向链表，所以得有一个head的头节点，这样才能链接后面的内容
初始化双链表
DLNode* DListInit(); 接口函数的名字
这里我们分析首先我们得返回值为什么不是void，而是DLNode*
因为我们要在这里面创建一个头节点，这个节点我们后面都得使用，其次还有一个原因就是这样头节点就不会被销毁，当然我们也可以在外面创建一个节点，然后我们在传它的指针进去，对结构体的内容进行修改，都可以达到相同的作用，废话不多说，我们来实现吧！
DLNode* DListInit() { DLNode* pHead = (DLNode*)malloc(sizeof(DLNode)); assert(pHead); pHead-&gt;next = pHead; pHead-&gt;pre = pHead; } 其实很简单，这里必须指针指向自己才可以，如果不这样的话，那我们的循环就不能实现了。
接下来就是怎么打印，打印很简单，我们将它这个指针传过去就行了。
打印双链表
void DListPrint(DLNode* pHead) { assert(pHead); DLNode* cur = pHead-&gt;next; while (cur != pHead) { printf("%d ", cur-&gt;data); cur = cur-&gt;next; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e111319ea96d68d6d3dd9aae903710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2c1124fcf1367d51d806ad5a23f334/" rel="bookmark">
			MySQL 图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求分析 1.1项目需求分析简介 1.1.1信息需求分析 (1) 图书信息：包括书籍编号，书籍名称，出版社，作者，库存量，出版日期，价格，库存，剩余量，类别等；
(2) 借阅证信息：包括借阅证编号，办证日期，可借数量等；
(3) 读者信息：读者编号，读者姓名，读者性别，读者电话
(4) 图书借还信息：包括图书编号，借阅证编号，读者编号，借阅日期，借阅数量，归还日期，归还数量，超期天数，罚款金额等；
1.1.2功能需求 学校图书借阅系统主要由：图书信息管理，读者信息管理，借阅证信息管理，借还信息管理，规则信息等模块组成。进入改系统后，用户可以对系统中的信息进行添加、修改、删除、查询等操作，包括以下功能：
(1) 图书信息管理模块：对图书信息进行增、删、改、查等操作；
(2) 读者信息管理模块：对读者信息进行增、删、改、查等操作；
(3) 借阅证信息管理模块：增加办卡，注销借阅卡等操作；
(4) 借还信息管理模块：进行借书、续借、还书等操作，查找出逾期的人及其逾期的天数；
(5) 操作记录管理模块：对读者的借，还，续借进行实时记录，便于管理员查找出指定读者的所有借阅记录。
(6) 规则信息管理模块：记录借书逾期的人及其逾期的天数，罚款。
1.2数据字典 1.2.1数据结构 1.数据结构：图书
含义说明：是学校图书借阅管理系统的主要数据结构，定义了图书的信息
组成：图书编号，书名，作者，出版日期，出版社，库存，剩余量，类别；
2.数据结构：读者
含义说明：是学校图书借阅管理系统的主要数据结构，定义了借阅者的基本信息
组成：读者编号，姓名，性别，电话号码；
3.数据结构：借阅证
含义说明：是学校图书借阅管理系统的主要数据结构，定义了借阅证的信息
组成：借阅证号，办证日期，可借数量；
4.数据结构：借，还，续借
含义说明：是学校图书借阅管理系统的主要数据结构，定义了图书借还的详细情况
组成：图书编号，借阅证编号，读者编号，借还日期，借还数量，是否续借
5.数据结构：规则
含义说明：是学校图书借阅管理系统的主要数据结构，定义了规则的详细情况
组成：读者编号，图书编号，借阅证编号，超期天数，超期本书，超期处罚
1.3系统分析 1.3.1功能模块简介 1.3.2功能需求描述 借阅功能： 图书出借时考虑三个问题：
读者是否因为超期、罚款等情况被关闭了借阅权限；
读者是否已经借满其限额。
该书是否不在库中；
如果不存在以上情况，则可以出借。
预约功能： 读者想借的书如果不在库中（已经被出借），读者可以预约该图书，当该图书被归还时系统给读者发送邮件，提醒他来借阅，此时其他读者也可以借阅该书。
续借功能： 读者还书的时候可以续借该图书，续借的过程包括先执行还书操作，再执行借阅操作。
发送催还邮件： 管理员可以发送邮件提醒读者到期还书。
读者管理功能： 对读者信息进行查看、添加、修改、删除。将读者分为不同类别，赋以不同权限。
系统管理功能： 对管理员的登录账号、密码进行添加、修改、删除。
借阅规则管理功能： 对图书借阅规则进行查看、添加、修改、删除。
概念结构设计 2.画E-R图 （1）图书实体E-R图
（2）图书类别实体E-R图
（3）借阅证实体E-R图
（4）读者实体E-R图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2c1124fcf1367d51d806ad5a23f334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e1d9b0d99fab85fb906851ac7772cf/" rel="bookmark">
			【哈士奇赠书活动 - 36期】- 〖Django Web 开发实例精解〗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 ⭐️ 赠书 - 《Django Web开发实例精解》⭐️ 内容简介⭐️ 作者简介⭐️ 编辑推荐⭐️ 赠书活动 → 获奖名单 ⭐️ 赠书 - 《Django Web开发实例精解》 ⭐️ 内容简介 《Django Web开发实例精解》详细阐述了与Django相关的基本解决方案，主要包括模型和数据库结构、表单和视图、模板和JavaScript、自定义模板过滤器和标签、模型管理、安全和性能、层次结构、导入和导出数据、测试、部署、维护等内容。此外，本书还提供了相应的示例、代码，以帮助读者进一步理解相关方案的实现过程。
⭐️ 作者简介 爱达斯·班德拉蒂斯在过去的18年里一直从事专业的网站建设。在过去的14年里，他一直在柏林一家名为studio 38 pure communication的设计公司工作。他和一个小的专门团队一起，主要使用Django作为后端，jQuery作为前端来创建文化和旅游web平台。
⭐️ 编辑推荐 Django是一个功能强大的Python Web框架，支持快速开发过程以及简洁、实用的设计方案。Django是高水准的Python编程语言驱动的一个开源模型，是一个视图、控制器风格的Web应用程序框架，它起源于开源社区。使用这种架构，程序员可以方便、快捷地创建高品质、易维护、数据库驱动的应用程序。另外，在Django框架中，还包含许多功能强大的第三方插件，使得Django具有较强的可扩展性。 本次送书 3 本 评论区抽三位小伙伴送书 活动时间：截止到 2023-08-27 20:00:00 抽奖方式：利用网络公开的在线抽奖工具进行抽奖 参与方式：关注、点赞、收藏，评论 "人生苦短，一天当做两天卷！" 点赞最多的1位小伙伴与随机抽取的2位小伙伴将免费获得此书！ 小伙伴也可以访问链接进行自主购买哦~ 清华大学出版社 京东特惠 -《Django Web 开发实例精解》 ⭐️ 赠书活动 → 获奖名单 名单公布时间： 2023-08-27 21:00:00 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d79d7f99658cab5aae6bc5147d2859/" rel="bookmark">
			LLM系列 | 19 : Llama 2实战(上篇)-本地部署(附代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 小伙伴们好，我是《小窗幽记机器学习》的小编：卖热干面的小女孩。紧接前文：万字长文细说ChatGPT的前世今生，后续会尝试以理论+实践的方式逐步对主流的各大LLM进行实测和汉化。今天这篇关于Llama2的小作文其实比较长，所以分为上下两篇，上篇主要介绍Llama2的基本情况和基于官方模型实测Llama2在中英上的效果，包括单轮和多轮对话。本文作为上篇，整个实验过程使用的模型是官方发布的Llama2模型，包括基座模型和经过RLHF的Chat模型。下篇则主要介绍如何用中文语料对Llama 2的基座模型进行微调并实测微调后模型的效果。感兴趣的小伙伴，可以关注下！本文实验完整代码获取请前往《小窗幽记机器学习》找小编索取。
Llama 2模型 以下先简单介绍下Llama 2的技术细节。
模型尺寸： Llama2 提供了三种模型尺寸：7B、13B和70B。其中，7B和13B的架构与LLaMA 1相同，可直接用于商业应用。
预训练： Llama 2模型的训练数据包含2万亿个token，训练语料比Llama 1多出40%。Llama 2上下文长度是Llama 1的两倍，上下文长度从2048增加到4096，使其能够理解和生成更长的文本。
微调： Llama 2使用公开的在线数据进行预训练，微调版Llama-2-chat模型基于100万个人类标记数据训练而得到。通过监督微调(SFT)创建Llama-2-chat的初始版本。接下来，Llama-2-chat使用人类反馈强化学习(RLHF)进行迭代细化，其中包括拒绝采样和近端策略优化(PPO)。
模型架构： Llama 2采用了Llama 1 的大部分预训练设置和模型架构，使用标准Transformer架构，使用RMSNorm应用预归一化、使用SwiGLU激活函数和旋转位置嵌入RoPE。与Llama 1的主要架构差异包括增加了上下文长度和分组查询注意力(GQA)。
分组查询注意力(GQA)： 这种注意力机制可以提高大模型推理可扩展性。它的工作原理是将key和value投影在多个head之间共享，而不会大幅降低性能。可以使用具有单个KV投影的原始多查询格式(MQA)或具有8KV投影的分组查询注意力变体(GQA)。
超参数： 使用AdamW优化器进行训练，其中β1=0.9，β2=0.95，eps=10−5。使用余弦学习率计划，预热2000步，衰减最终学习率降至峰值学习率的10%。使用0.1的权重衰减和1.0的梯度裁剪。
分词器： Llama 2使用与 Llama 1相同的分词器。都采用字节对编码(BPE)算法，使用SentencePiece实现。与 Llama 1一样，将所有数字拆分为单独的数字，并使用字节来分解未知的UTF-8字符。总数词汇量为32k个token。
微调： Llama-2-Chat是数月实验研究和对齐技术迭代应用的结果，包括指令微调(SFT)和RLHF，需要大量的计算和数据标注资源。有监督微调指令数据质量非常重要，包括多样性，注重隐私安全不包含任何元用户数据。
效果： 据Meta所说，Llama 2 在许多外部基准测试中都优于其他开源语言模型，包括推理、编码、熟练程度和知识测试。
安全性： 该研究使用三个常用基准评估了Llama 2的安全性，针对三个关键维度：真实性，指语言模型是否会产生错误信息，采用TruthfulQA基准；毒性，指语言模型是否会产生「有毒」、粗鲁、有害的内容，采用ToxiGen基准；偏见，指语言模型是否会产生存在偏见的内容，采用BOLD基准。
模型下载 关于Llama2模型的下载，建议直接在 huggingface 上申请 Llama 2模型的下载权限：https://huggingface.co/meta-llama，再利用huggingface_hub进行下载。
具体下载示例如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2023/7/25 14:29 # @Author : JasonLiu # @File : download_hf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82d79d7f99658cab5aae6bc5147d2859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3dd078b180290da24896badb16abc9c/" rel="bookmark">
			提高Stable Diffusion十倍计算速度以及解决内存崩溃问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在启动Stable Diffusion时一直报Torch not compiled with CUDA enabled警告，一开始没在意本着能用就行的态度凑活用，每个图都耗时十多秒，然后本着好奇Torch not compiled with CUDA enabled这个警告去搜索解决方案，都没说这个警告解决了有什么用，并且网上资料东拼西凑根本不能解决问题，本着专研解决问题的心态花一晚上解决这个警告，并将计算速度提高了十倍基本4G的模型2秒能出图。
在这发一个推广：GitHub - stablediffusion-website-online: stable diffusionAI绘画 AI画图生成平台，适合自己开绘画平台网站，包含图片生成及图片浏览
出现这个问题是两个方面一是的确显存不足
本地环境：windows11 13900k 32G Nvidia 3080ti
当前显卡驱动版本：
注意上面的CUDA12.0.147不一定要和CUDA Toolkit 版本一样，但是CUDA Toolkit一定要和pytorch中版本一样
我没用conda太麻烦了，直接裸装到本地python环境速度还快,下面是步骤：
正式开始
首先要安装cuda_11.6.0_511.23_windows.exe 这个版本必须要和pytorch官网对应(其实不一定非要安装最新的cuda老的也可以的只要版本对上），然后安装pytorch可以从官网或者本地，如果安装过程中出现以来报错，可以检查手动安装依赖再重新安装
网盘地址：
我用夸克网盘分享了「cuda驱动」，
链接：夸克网盘分享
关于CUDA Toolkit 与你的显卡驱动版本对应关系可以参考这个文档，他都是大于等于也就是说你的cuda老版本也没关系 CUDA 12.2 Release Notes 可以如上图看显卡版本或者cmd命令行执行nvidia-smi查看
1.下载CUDA Toolkit
CUDA Toolkit 11.6 Downloads | NVIDIA Developer
cuda_11.6.0_511.23_windows.exe （全部下一步）
2.安装pytorch
Start Locally | PyTorch 参考地址
pip都是在cmd命令行安装如果没pip去baidu查一下python pip安装教程，python版本我这里是10.0
组合脚本（在线安装）：
pip install protobuf==3.20.0 requests==2.28.2 torch==1.13.1 torchvision==0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3dd078b180290da24896badb16abc9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea2e792ca48f3fcf95723c294febf3a/" rel="bookmark">
			AI 绘画Stable Diffusion 研究（十五）SD Embedding详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是风雨无阻。
本期内容：
Embedding是什么？Embedding有什么作用？Embedding如何下载安装？如何使用Embedding？ 大家还记得 AI 绘画Stable Diffusion 研究（七） 一文读懂 Stable Diffusion 工作原理 这篇文章中，曾提到过词嵌入（Embedding）吗？
我们来简单回顾一下：Embedding 将输入的tokens转换为一个连续的向量，然后stable diffusion再将 Embedding 向量 通过text transformer转换后，作为模型输入，进行训练。
那在上一篇中只是简单提到了Embedding， 对于我们实际使用stable diffusion过程中，可能很多朋友对Embedding的概念还不是很清楚。今天我们就来详细介绍一下Embedding， 它到底是干嘛的？有什么作用？以及应该怎么安装和使用Embedding ？
一、Embedding 的介绍
1、Embedding是什么？
Embedding 又名 textual inversion 中文名：“嵌入或文本反转”。
在计算机科学中，Embedding是将高维数据映射到低维空间的过程。
在图像处理中，Embedding通常用于将图像转换为向量表示，以便进行机器学习和深度学习任务。
在使用stable diffusion进行绘画时，Embedding可以用于将输入的图像转换为向量表示，以便于算法对其进行处理和生成新的图像。这种技术可以使算法更加高效地处理图像数据，并提高生成图像的质量和准确性。
2、Embedding有什么作用？
通俗来讲，Embedding 的作用就是对提示词进行打包。
如果你有做 UI 的经验，那么应该知道组件的概念。
在 Stable Diffusion 中，Embedding 技术就可以被理解为一种组件，它可以将输入数据转换成向量表示，方便模型进行处理和生成。
在日常使用中，Embedding 技术通常用于控制人物的动作和特征，或者生成特定的画风。
我们来举例，思考一个问题：
如果我们直接使用原版本的stable diffusion 文生图功能， 不使用stable diffusion 任何插件，我们应该怎么来生成如下的图片呢？
想必大家首先想到的是，写一大堆的提示词来进行控制生成，类似例如：
masterpiece, high-quality,1girl,clothes with Pink pattern,(brown hair), pinkearphones, green pattern on the earphones, blue tights, white gloves, ((pinkpattern on the clothes)), cat pattern on the face, detailed eyes, (pink theme), rabbitdecoration on the chest, green word pattern, sewing line on the clothes, long hair.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ea2e792ca48f3fcf95723c294febf3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1dedafd76e602050cb2c4dbd1e24a9/" rel="bookmark">
			【错误记录】Android Studio 中 Kotlin 版本报错 ( Module was compiled with an incompatible version of Kotlin. T )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、报错信息二、问题分析三、解决方案1、低版本 Gradle 配置2、高版本 Gradle 配置 一、报错信息 在 Android Studio 中 , 编译应用 , 报如下错误 :
C:/Users/octop/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-common/1.6.0/7857e365f925cfa060f941c1357cda1f8790502c/kotlin-stdlib-common-1.6.0.jar!/META-INF/kotlin-stdlib-common.kotlin_module: Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.6.0, expected version is 1.1.13. 这个报错问题 , 出现了十几次 ;
详细报错信息如下 : 下面的报错信息 , 仅做参考 , 就不要点开了 ;
&gt; Task :app:compileDebugKotlin FAILED w: Runtime JAR files in the classpath should have the same version. These files were found in the classpath: C:/Users/octop/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1dedafd76e602050cb2c4dbd1e24a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4667153f9b01836c6fda8a45d4a366/" rel="bookmark">
			STM32 OV7725摄像头模块识别颜色物体（1）--HSL二值化和腐蚀中心算法，并用串口输出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、摄像头采集数据流程
二、如何将图像显示到电脑上
三、图像二值化
1、什么是RGB?
2、RGB565转RGB888
I、RGB565和RGB888的区别
II、代码
3、RGB转HSL
I、什么是HSL
II、转换公式
III、代码
3、输出一张摄像头二值化图片
I、原理
II、代码 四、简单的物体识别
1、原理参考
2、识别代码
3、显示代码
总结
前言 前阵子用STM32弄摄像头，断断续续有段时间，也在网上翻阅了不少资料，写篇博客记录一下学习过程。最后成功识别单个物体，图形和多个物体暂不支。
一、摄像头采集数据流程 (1) 利用 SIO_C、SIO_D 引脚通过 SCCB 协议向 OV7725 的寄存器写入初始化配置；
(2) 初始化完成后，OV7725 传感器会使用 VGA 时序输出图像数据，它的 VSYNC 会
首先输出帧有效信号（低电平跳变），当外部的控制器（如 STM32）检测到该信号
时，把 WEN 引脚设置为高电平，并且使用 WRST 引脚复位 FIFO 的写指针到 0 地
址；
(3) 随着 OV7725 继续按 VGA 时序输出图像数据，它在传输每行有效数据时， HREF
引脚都会持续输出高电平，由于 WEN 和 HREF 同时为高电平输入至与非门，使得
其连接到 FIFO WE 引脚的输出为低电平，允许向 FIFO 写入数据，所以在这期间，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4667153f9b01836c6fda8a45d4a366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/023ac9da79feebabc3539d17feeb9062/" rel="bookmark">
			Oracle Database12c数据库官网下载和安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 下载安装Oracle自带的客户端工具使用 下载 进入oracle官网
点击下载连接之后右上角会有一个下载
我们只需要数据库本体就够了
运行这个下载器
等待下好之后即可
出现 Complete 之后代表下载成功，然后我们解压即可
安装 双击 双击setup.exe
根据自己需求填写邮箱或者勾选接收安全更新，也可以直接下一步跳过
这里我们不填
首次安装就选第一个
个人使用就选择桌面类；如果是服务器环境就选择服务器类
虚拟账户和创建新Windows用户我们一般不用，我们选择使用内置用户
这里着重讨论一下使用现有的windows用户和使用windows内置用户区别
区别权限内置用户具有较高的权限；现有用户可能是只有普通权限。安装oracle需要具有足够的权限才能成功安装账户管理内置用户可直接登陆操作系统；现在用户实在oracle数据库中创建和管理的，不能直接登录到操作系统安全性内置用户通常是广泛使用的公共账户，可能存在风险；现有用户根据需求创建，更好的控制和保护数据库安全数据库权限内置用户通常没有数据库权限，安装oracle数据库是需要创建专门的数据库用户。“SYS”和“SYSTEM”是常见的特殊系统用户。具有高级权限，用于管理和为数据库数据库连接内置用户可以使用特定的工具或命令行连接到oracle数据库；现有用户需要通过数据库实例名或IP地址，使用数据库客户端连接到oracle数据库 内置用户：侧重于系统层面的权限和访问控制
现有用户：侧重于数据库层面的权限和访问控制
字符集修改为Unicode之后方便国际化。规范了数据库中数据的存储和处理方式
口令：英文字母大小写+数字即可满足规则
需要记录一下SID
Oracle Enterprise Manager Database Express URL:https://localhost:5500/em
最后验证安装是否成功
sqlplus -v
如果失败，则查看一下这五个服务是否启动
会发现Oracle服务非常消耗内存资源，我们平常使用的话再开启，设置成手动。
OracleJobScheduleORCL：禁用，关闭
Oracle自带的客户端工具使用 如果不小心把左边的导航栏全部删除掉的话点击绿色图标即可建立新的数据库连接
也可以在这里查看已经连接好的数据库信息
运行一下 select * from help; 验证一下是否能成功运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058746eba3886110713ec58758d4d2c1/" rel="bookmark">
			vue3&#43;axios&#43;router实现页面跳转及登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章主要是，使用 vite 创建一个vue3 书籍商城的小型案例，项目中主要运用到路由router及接口axios等知识点。
1.开始搭建项目框架，使用vite来构建项目
npm create vite@latest 2.由于vite构建的项目中需要自己手动下载路由以及创建路由文件夹，所以在创建好的项目文档中找到src文件夹，在src文件夹下创建router文件夹，并且在其下创建index文件，对于index文件中要写的内容如下，在此之前还需要创建一个views文件夹，本次项目主要用到三个页面，所以需要在views文件夹下需创建三个文件，包括HomeView.vue、AboutView.vue、UserLoginView.vue。这些准备好之后还有重要的一点就是手动安装router。
npm install vue-router//终端中安装router index.js文件中的内容：
import { createRouter, createWebHashHistory } from "vue-router"; import HomeView from "../views/HomeView.vue"; const routes = [ {//首页 path: "/", name: "home", component: HomeView, }, {//书籍商城 path: "/about", name: "about", component: () =&gt; import( "../views/AboutView.vue"), }, {//登录页 path: "/userlogin", name: "userlogin", component: () =&gt; import("../views/UserLoginView.vue"), }, ]; const router = createRouter({ history: createWebHashHistory(), routes, }); export default router; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058746eba3886110713ec58758d4d2c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665c74d03b4f338e95260c6971629467/" rel="bookmark">
			Fluent求解器——SIMPLE、SIMPLEC、PISO与Coupled算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、压力基求解器 Fluent提供两种不同的求解器，基于压力的求解器(Pressure-Based)和基于密度的求解器(Density-Based)，压力基求解器也叫分离式求解器(Segregated Solver)，密度基求解器也叫耦合式求解器(Coupled Solver)。
压力基求解器适用于低速、不可压缩流体，此求解器首先由动量方程求速度场，继而由压力方程进行修正使得速度场满足连续性条件。由于压力方程来源于连续性方程和动量方程，从而保证流场的模拟同时满足质量守恒和动量守恒。密度基求解器适用于高速、可压缩流体，此求解器直接求解瞬态N-S方程(此方程理论上是绝对稳定的)，将稳态问题转化为时间推进的瞬态问题，由给定的初场时间推进到收敛的稳态解，即时间推进法。适用于求解亚音速、高超音速等的强可压缩问题。本文只对压力基求解下的Methods进行整理。
基于压力的求解器采用的是一种称为投影法(projection method)的一般方法类。在投影方法中，速度场的质量守恒（连续性）的约束通过求解压力（或压力校正）方程来实现；压力方程由连续性方程和动量方程推导而来，通过压力校正的速度场满足连续性；由于控制方程是非线性的并且彼此耦合，所以求解过程涉及迭代，其中重复求解整个控制方程组，直到解收敛。
Fluent中提供了两种基于压力的求解器算法：分离算法(The Pressure-Based Segregated Algorithm)和耦合算法(The Pressure-Based Coupled Algorithm)。（这里的耦合算法要区别于密度基的耦合式求解）
二、分离算法与耦合算法 在 Solution Methods 设置中,使用压力基求解器时，在求解时涉及到算法的问题，这里的算法一般有以下几种：SIMPLE、SIMPLEC、PISO和Coupled。在FLUENT 6.3版本以前，这四种算法分为2类，即前3种称为分离求解方法，第4种称为耦合求解方法。分离式求解器以前主要用于不可压缩流动和微可压流动，而耦合式求解器用于高速可压流动。现在，两种求解器都适用于从不可压到高速可压的很大范围的流动，但总的来讲，当计算高速可压流动时，耦合式求解器比分离式求解器更有优势。 1、分离算法 基于压力的分离算法按照顺序求解其中控制方程（即对控制方程组彼此分离求解），由于控制方程是非线性和耦合的，因此必须迭代执行解循环以获得收敛的数值解。在分离算法中，解变量（例如压力项、温度项、速度项等）单独控制方程一个接一个地求解，每个控制方程在求解时都与其他方程“解耦”或“分离”，因此得名。分离算法是实时储存的，因为离散化方程只需要一次存储一个，然而，由于方程是以解耦的方式求解，所以解的收敛速度相对较慢。分离算法对燃烧、多相流问题更加有效。
求解流程：
(1) 基于当前方案流体的属性（e.g. 密度、粘度、比热），包括湍流粘度（扩散率）进行更新；
(2) 使用最新的压力和面质量通量值，逐个求解动量方程；
(3) 使用最新获得的速度场和质量通量求解压力校正方程；
(4) 使用上述步骤获得的压力，校正面质量通量、压力和速度场；
(5) 使用当前求解所得的变量值求解附加（如有）方程，如湍流量、能量、物料和辐射强度；
(6) 更新由不同相位之间的相互作用产生的源项（例如，离散粒子引起的载流子相位的源项）；
(7) 检查方程的收敛性。
2、耦合算法 基于压力的耦合算法求解包括动量方程和基于压力的连续性方程的耦合方程组。因此，在耦合算法中，分离解算法中的步骤2和3由求解耦合方程组的单个步骤代替。其余方程以分离算法中的解耦方式求解；由于动量和连续性方程以紧密耦合的方式求解，与分离算法相比，解的收敛速度显著提高。然而，由于在求解速度场和压力场时，所有基于动量和压力的连续性方程的离散系统必须存储在存储器中（而不是像分离算法那样仅存储一个方程），因此，存储需求增加了分离算法的1.5~2倍。但是，耦合算法可以和所有动网格、多相流、燃烧、和化学反应模型兼容，收敛速度远高于密度基求解器。
3、注意事项 需要注意的是，在分离式求解器中提供的几个物理模型，在耦合式求解器中是没有的。这些物理模型包括：流体体积模型(VOF)，多项混合模型，欧拉混合模型，PDF燃烧模型，预混合燃烧模型，部分预混合燃烧模型，烟灰和NOx模型，Rosseland辐射模型，熔化和凝固等相变模型，指定质量流量的周期流动模型，周期性热传导模型和壳传导模型等。 而下列物理模型只在耦合式求解器中有效，在分离式求解器中无效：理想气体模型，用户定义的理想气体模型，NIST理想气体模型，非反射边界条件和用于层流火焰的化学模型。
三、算法介绍 1、SIMPLE 原理即分离求解的流程，可以概括为预测-校正。SIMPLE 算法是目前工程上应用最为广泛的一种流场计算方法，它属于压力修正法的一种。
2、SIMPLEC 求解思路同SIMPLE，唯一区别在于为面通量引入一个修正函数进行修正，主要解决了压力-速度耦合方法难以获得解的问题，提高了收敛的速度。
操作指导：SIMPLEC开启后需要选择使用Skewness Correction的个数，默认是0。
3、PISO 压力隐式算子分离法，更大提升了压力和速度之间的近似程度，通过引入两个校正指标：neighbor correction（领域校正）和 skewness correction（偏度校正），即每个迭代步中增加了动量修正和网格畸变修正过程。解决了分离算法中，求解压力校正方程后，每个迭代步获得的压强场与动量方程偏离过大，速度和相应的通量不满足动量平衡的问题。虽然PISO算法的的计算量大于SIMPLE 算法和 SIMPLEC 算法，但是由于每个迭代步中获得的压强场更准确，所以使得计算收敛得更快，也就是说获得收敛解需要的迭代步数大大减少了。
操作指导：
(1) 使用带Neighbor Correction的PISO时，建议所有方程的松弛因子为1.0或接近1.0。
(2) 使用带Skewness Correction的PISO时，动量和压力的松弛因子的和应设置为1（例如Pressure为0.3，Momentum为0.7）。
(3) 同时使用两种校正的PISO时，遵循带Neighbor Correction的PISO的建议；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665c74d03b4f338e95260c6971629467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e1b50b3215f70ab4f1e728b74286e4/" rel="bookmark">
			Python调用文心一言的API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近申请了文心一言的key，然后尝试调用了一下文心一言，这里使用一个简单的方式来调用文心一言：
pip install paddle-pipelines from pipelines.nodes import ErnieBot api_key = "your apply key" secret_key = "your apply secret key" ernie_bot = ErnieBot(api_key=api_key, secret_key=secret_key) res = ernie_bot.predict('请问您是哪位？') print(res) 然后就可以开开心心的使用文心一言的API了。
参考文献 文心千帆
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae223c15d9ab5631a026f3549309fcde/" rel="bookmark">
			Python——列表(list)推导式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于python3。
目录 1、Python推导式2、列表(list)推导式2.1、定义2.2、实际操作2.2.1、一个表达式，后面为一个 for 子句2.2.2、一个表达式，后面为一个 for 子句，然后，跟着if 子句。2.2.3、一个表达式，后面为一个 for 子句，然后，跟着 for 子句。2.2.4、一个表达式，后面为一个 for 子句，然后，跟着 for 子句，if 语句2.2.5、表达式的不同2.2.5.1、表达式是函数2.2.5.2、表达式是元组2.2.5.2、表达式是复杂的表达式和嵌套函数 3、利用列表推导式实现乘法口诀4、总结 1、Python推导式 你可以理解成一种数据的处理方式。目的是为了构建一个新的数据序列。
Python 支持各种数据结构的推导式：
列表(list)推导式字典(dict)推导式集合(set)推导式元组(tuple)推导式 各自从字面意思就知道，创建一个列表、字典、集合、元组。
我们本文只看列表(list)推导式。
2、列表(list)推导式 列表推导式创建列表的方式更简洁。
常见的用法：
对序列或可迭代对象中的每个元素应用某种操作，用生成的结果创建新的列表。用满足特定条件的元素创建子序列。 2.1、定义 定义主要有两种：（该部分定义来自：菜鸟教程）
定义1： [表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list] 定义2 [表达式 for 变量 in 列表 if 条件] [out_exp_res for out_exp in input_list if condition] out_exp_res：列表生成元素表达式，可以是有返回值的函数。for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。if condition：条件语句，可以过滤列表中不符合条件的值。 总结：一个表达式，后面为一个 for 子句，然后跟着零个或多个 for 或 if 子句。结果是由表达式依据 for 和 if 子句求值计算而得出一个新列表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae223c15d9ab5631a026f3549309fcde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff22685e952ef825599574da2918c09/" rel="bookmark">
			Plugin mysql_native_password reported: ‘‘mysql_native_password‘ is deprecated and will be removed i
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Plugin mysql_native_password reported: ''mysql_native_password' is deprecated and will be removed in a future release. Please use caching_sha2_password instead'
show variables like 'default_authentication%';
select host,user,plugin,authentication_string from mysql.user;
1.参考初步分析中的方案，将应用的连接配置修改为正确的用户信息；
2.可以在mysql数据库中通过参数将该告警过滤，避免该告警信息输入到错误日志文件。相关配置如下：
show variables like 'log_error_suppression_list'; set global log_error_suppression_list='MY-013360; show variables like 'log_error_suppression_list'; 注意，使用该方案也会导致某个存在且使用SHA256_PASSWORD认证插件产生的告警。可以作为临时方案；
3.修改mysql代码，避免在使用不存在用户登录数据库时，选择 SHA256_PASSWORD认证插件。目前针对该方案已提交Bug #109635。
或者
sha256_password' is deprecated and will be removed in a future release. Please use caching_sha2_password instead
mysql server errorlog忽然爆出大量的sha256_password' is deprecated and will be removed in a future release.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fff22685e952ef825599574da2918c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00ef568c1d64e6b2f151e9c967935d0/" rel="bookmark">
			Stable Diffusion Webui源码剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关键python依赖 （1）xformers：优化加速方案。它可以对模型进行适当的优化来加速图片生成并降低显存占用。缺点是输出图像不稳定，有可能比不开Xformers略差。
（2）GFPGAN：它是腾讯开源的人脸修复算法，利用预先训练号的面部GAN（如styleGAN2）中封装的丰富多样的先验因素进行盲脸（blind face）修复，旨在开发用于现实世界人脸修复的实用算法。
（3）CLIP：Contrastive Language-Image Pre-Training，多模态方向的算法。可以训练出一个可以处理图像和文本的模型，从而使得模型可以同时理解图像和对图像的描述。
（4）OPEN-CLIP：一个开源的clip实现。
（5）Pyngrok：Ngrok工具的python实现，可以实现内网穿透
2、核心目录文件 （1）sd根目录下的repositories
存放算法源码
1）stable-diffusion-stability-ai：sd算法
2）taming-transformers：高分辨率图像合成算法
3）k-diffusion：扩散算法
4）CodeFormer：图片高清修复算法
5）BLIP：多模态算法
（2）sd根目录/models
存放模型文件
（3）sd根目录/extensions/sd-webui-additional-networks/models/lora
存放lora模型文件
3、参数初始化 进入webui.py的api_only()或者webui()函数时，已经完成了部分参数的初始化
Webui.py的依赖中有代码：from modules import shared
而shared.py中有如下代码：
opts = Options()
if os.path.exists(config_filename):
opts.load(config_filename)
config_filename对应cmd_opts.ui_settings_file，也就是根目录下的config.json文件
这些参数都将在程序正式运行前加载到shared.opts中
比如被选中的模型参数信息就有了。
4、webui之模型处理流程 （1）cleanup_models函数move模型文件 将models目录下的文件移到相关子目录下，比如ckpt文件和safetensors文件放到Stable-diffusion子目录下。
（2）启动SD模型setup_model流程 该模型位于：/data/work/xiehao/stable-diffusion-webui/models/Stable-diffusion
主要是通过list_models函数遍历所有的模型的信息并存到checkpoint_alisases中。
第1步，查看sd/models/Stable-diffusion下是否有cpkt和safetensors结尾的文件，有则放入model_list列表中，没有则从hugginface下载模型。
第2步，通过CheckpointInfo函数检查model_list中每个模型的checkpoint信息。如果是safetensors文件，通过read_metadata_from_safetensors读取文件信息。Safetensors模型的参数都存放在json中，把键值对读出来存放到metadata字段中。
第3步，最后把每个模型根据{id : 模型对象}的键值对存放到checkpoint_alisases全局变量中。
（3）启动codeformer模型的setup_model流程 该模型位于：/data/work/xiehao/stable-diffusion-webui/models/Codeformer
主要将Codeformer初始化之后的实例放到shared.face_restorers列表中。在此过程中并没有将模型参数装载到Codeformer网络中。
（4）启动GFPGAN模型的setup_model流程 （5）遍历并加载内置的upscaler算法 这些算法位于：/data/work/xiehao/stable-diffusion-webui/modules
遍历该目录下_model.py结尾的文件，通过importlib.import_module()进行加载，这一步未看到实际作用。
初始化以下放大算法[&lt;class 'modules.upscaler.UpscalerNone'&gt;, &lt;class 'modules.upscaler.UpscalerLanczos'&gt;, &lt;class 'modules.upscaler.UpscalerNearest'&gt;, &lt;class 'modules.esrgan_model.UpscalerESRGAN'&gt;, &lt;class 'modules.realesrgan_model.UpscalerRealESRGAN'&gt;]，其中第1个没任何算法，第2-4是img.resize()方法实现的，第5、6个需要单独加载模型，数据都以UpscalerData格式存放，其中该对象的local_data_path存放了模型的本地地址信息。
比如：shared.sd_upscalers[5].local_data_path为：
'/data/work/xiehao/stable-diffusion-webui/models/RealESRGAN/RealESRGAN_x4plus_anime_6B.pth'
（6）加载py执行脚本load_scripts 遍历sd根目录/scripts下的py脚本 以及 extensions下各扩展组件的py脚本，放到scripts_list变量中，格式如下：ScriptFile(basedir='/data/work/xiehao/stable-diffusion-webui/extensions/sd-webui-controlnet', filename='processor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b00ef568c1d64e6b2f151e9c967935d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83e22896d9bab7241e4778e0d626c08/" rel="bookmark">
			FastDFS与Nginx结合搭建文件服务器，并实现公网访问【内网穿透】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 本地搭建FastDFS文件系统1.1 环境安装1.2 安装libfastcommon1.3 安装FastDFS1.4 配置Tracker1.5 配置Storage1.6 测试上传下载1.7 与Nginx整合1.8 安装Nginx1.9 配置Nginx 2. 局域网测试访问FastDFS3. 安装cpolar内网穿透4. 配置公网访问地址5. 固定公网地址5.1 保留二级子域名5.2 配置二级子域名 6. 测试访问固定二级子域名 前言 FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。
FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。
配备一台公网服务器作为文件上传下载,花费资源和开销比较大,如果在本地搭建FastDFS服务,只把上传后的文件通过cpolar内网端口转发工具将文件配置可通过互联网访问,极大了减少服务器费用及开销,本文介绍详细搭建FastDFS教程,并结合Nginx+cpolar工具实现远程访问文件。
1. 本地搭建FastDFS文件系统 1.1 环境安装 由于fastDFS是由c语言编写,所以我们需要安装gcc
yum -y install gcc-c++ FastDFS依赖libevent库，需要安装。执行如下命令：
yum -y install libevent 1.2 安装libfastcommon 进入local目录
cd /usr/local libfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。点击下面链接即可获取:
https://github.com/happyfish100/libfastcommon/releases/tag/V1.0.7
获取后,上传到local目录下
解压libfastcommon
tar -zxvf libfastcommonV1.0.7.tar.gz 进入解压文件夹
cd libfastcommon-1.0.7/ 编译
./make.sh 安装
./make.sh install libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。
cp /usr/lib64/libfastcommon.so /usr/lib/ 1.3 安装FastDFS 进入local目录
cd /usr/local 点击下列地址,可获取下载FastDFS_v5.05.tar.gz文件:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c83e22896d9bab7241e4778e0d626c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf96fff9e50a51b88f0d80185b18360/" rel="bookmark">
			Go语言time库，时间和日期相关的操作方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		time库 用于处理时间、日期和时区的核心库。在实际开发中，常常需要与时间打交道，例如记录日志、处理时间差、计算时间间隔等等。因此，掌握time库的使用方法对于Go开发者来说非常重要。
在Go语言中，时间表示为time.Time类型，日期表示为time.Time类型或者time.Date类型，时区表示为time.Location类型。下面将详细介绍这些类型的概念及使用方法。
时间 在Go语言中，时间表示为time.Time类型。time.Time类型是一个结构体，包含两个字段：一个具有 century 和 second 等字段的大整数和一个小整数，分别表示时间的年份和时间的小数部分。
可以使用time包中的函数来获取当前时间、指定时间或者进行时间的加减操作。下面是一些常用的时间操作函数：
time.Now()：返回当前本地时间
time.Parse(layout, str)：将字符串str解析为指定格式layout的时间
time.Add(d time.Duration)：返回当前时间加上给定时间间隔d的结果
time.Sub(t, u time.Time)：返回时间t减去时间u的时间间隔
日期 日期表示为time.Time类型或者time.Date类型。其中，time.Time类型表示完整的的时间，包括时分秒等信息；而time.Date类型则只表示日期部分，不包含时间部分。
可以使用time包中的函数来获取指定日期的月份和日数，或者进行日期的加减操作。下面是一些常用的日期操作函数：
time.Month(month int)：返回指定的月份的字符串表示
time.Day()：返回当前日期中的天数
time.AddDate(year int, month int, day int)：返回指定年月日加上给定时间间隔的结果
time.Sub(t, u time.Time)：返回时间t减去时间u的时间间隔
时区 时区表示为time.Location类型。time.Location类型是一个结构体，包含一个字符串表示时区的标识符和一些字段，例如seconds 和 bias 等。
可以使用time包中的函数来获取指定时区的偏移量或者进行时区的转换。下面是一些常用的时区操作函数：
time.Local：表示本地时区
time.UTC：表示UTC时区
time.LoadLocation(name string)：返回指定时区名称的time.Location类型对象
time.In(loc time.Location, t time.Time)：返回指定时区的时间t转换为目标时区loc的结果
函数 time.Now(): 返回当前本地时间。
time.Parse(layout, str): 将字符串 str 解析为指定格式 layout 的时间。
time.Add(d time.Duration): 返回当前时间加上给定时间间隔 d 的结果。
time.Sub(t, u time.Time): 返回时间 t 减去时间 u 的时间间隔。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf96fff9e50a51b88f0d80185b18360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904e74f75dc3d9182e150ba9f6aeef57/" rel="bookmark">
			WebStorm前端开发神器：十大必装插件推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 WebStorm是JetBrains推出的一款专业的JavaScript IDE,它提供了强大的JavaScript/TypeScript开发环境和工作流。作为前端开发人员,我们可以通过安装各种插件来丰富和增强WebStorm的功能。本文将为大家推荐10个WebStorm前端开发必装的插件。
1. HTML CSS Support HTML CSS Support插件可以为HTML和CSS文件提供高亮,自动完成,错误检查和格式化等功能。它支持HTML5,CSS3以及LESS和SCSS等预处理器。安装后,HTML和CSS文件会获得和JavaScript一样丰富的代码支持。
&lt;!-- HTML代码高亮 --&gt; &lt;div class="container"&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/div&gt; /* CSS代码高亮 */ .container { color: #333; } 2. ESLint ESLint插件可以实时检查JavaScript和JSX代码中的错误、风格问题和危险操作,同时也支持自动修复。它与Webpack结合可以直接在代码保存时自动修复问题。
// ESLint检查示例 function sum(a, b) { return a + b } 3. Path Autocomplete Path Autocomplete插件可以自动完成文件路径,特别适合前端项目中引用图片、文件等资源路径。只需输入路径的开头部分即可自动补全,大大提高开发效率。
// 自动完成图片路径 import logo from './asse../images/logo.png'; 4. Prettier Prettier插件可以自动格式化代码,保持统一的代码风格。它与ESLint完美结合,可以一键格式化和修复所有代码问题。
// Prettier格式化前 function foo(bar) { return bar++; } // Prettier格式化后 function foo(bar) { return bar + 1; } 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/904e74f75dc3d9182e150ba9f6aeef57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/322861aa6c913e4e824c0f0969ad9bb7/" rel="bookmark">
			数据库系统课设——基于python&#43;pyqt5&#43;mysql的酒店管理系统（可直接运行）--GUI编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几个月之前写的一个项目，通过这个项目，你能学到关于数据库的触发器知识，python的基本语法，python一些第三方库的使用，包括python如何将前后端连接起来（界面和数据），还有界面的设计等等。希望大家能从项目中学到东西。
一，项目背景 1，实验设计简述 宾馆管理系统通过提供顾客和员工信息之间的关系建立该系统，其中包括员工管理功能，出租管理功能，客户管理功能，订单管理功能，报表和维护功能，登录功能。该系统可以通过客户信息的查找 快速找到该客户的房间信息。还包括对客户信息的增加、删除、修改、查询等以及员工信息的增加、删除、修改、查询
（1）宾馆有员工，员工员工信息查看，查看订单权限，查看房号，房型。
（2）宾馆有各种标准的房间。房间数据包括房间号、房间级别、房间价位及房间的状态（是否已经有客人）。房间号唯一表示一个房间，房间级别决定房间价位。房间有多种级别，分别为单人间、标准间、豪华间、商务间、行政间。房间状态表示此房间是否可以预定、入住或者转房。
基本功能实现： （1）房间管理。
（2）客人预定、退订客房管理。
（3）客人入住、店内消费管理。
（4）结算管理。
（5）实现分类查询。
（6）输出相应的数据报
描述每个业务的主要功能。 1、房间管理：存储房间信息数据，房间号，客户可以查看房型（单人间，标准间，豪华间、商务间、行政间），房间价位，房间状态（有无客人，无客人：房间可以预定，房间可以转入。有客人：客人能退房，转房），房间对应楼层。
2、客户管理：客户分为个人预约客户和团队预约客户（预约时间，预约客户号），个人入住客户和团队入住客户（入住时间，入住客户号），还有换房功能。
3、员工管理：可以添加员工（姓名，性别，员工号，职位，入职时间），删除员工，修改员工，查询员工信息。可以查看所有订单，对房间进行增删改查操作(房间号，房型，价格）。
4、报表和维护：数据备份（导出数据，导入数据，导出数据表到表格），报表。
5、订单管理功能:订单记录报表，客户入住的房型（图片说明），支付金额，入住的客户信息（客户号，入住时间，退房时间）
6、登陆功能：登陆（员工（账号密码）登陆/客户（账号密码）登陆）密码找回功能，修改密码功能。
2，根据功能分析和列举涉及的数据项。 booking_client个人预定表：(cid客户号,rid房间号,star_time入住时间,end_time退房时间,booking_time预定时间,remark备注)booking_team团队预定表：(tid团队号,rid房间号,star_time入住时间,end_time退房时间,booking_time预定时间,remark备注)checking_clint个人入住表：(rid房间号，cid客户号,star_time入住时间,end_time退房时间,total_price总价格,check_in_sid办理入住的员工编号,remark备注)checking_team团队入住表：(rid房间号,tid团队好,star_time入住时间,end_time退房时间,total_price总价格,check_in_sid办理入住的员工编号,remark备注)client客户表：(cname姓名,cid客户号,cphone电话号码,cage年龄,csex性别,register_sid注册员工号,accomodation_times入住次数,register_time注册时间)hotel order订单表：（id用户标识，ordertype订单形式，start_time预定时间,rid房间号,pay_type支付方式,money支付价格,remark备注,order_time订单时间，register_sid注册员工时号)room房间表：（rid房间号,rtype类型,rstorey楼层,rprice价格,rdesc房间状态,rpic房间图片)staff员工表：(sid员工号，sname姓名,ssex性别,stime登记入职时间,susername账户号,spassword密码,srole权限,sidcard身份证,sphone手机号) 9、team团队表：(tname名称,tid团队好,tphone电话号码,check_in_sid登陆员工号,accomodation_time入住次数,register_time注册时间)
二，项目具体实现 1、数据项的简要描述。 1、booking_client客户个人预定表 ( cid varchar(255) NOT NULL rid varchar(255) NOT NULL start_time date DEFAULT NULL end_time date DEFAULT NULL） 2、booking_team团队预定表( tid varchar(255) NOT NULL rid varchar(255) NOT NULL start_time date DEFAULT NULL end_time date DEFAULT NULL booking_time timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP） remark varchar(255) DEFAULT NULL 3、checkin_client个人入住表 ( rid 房间号 varchar(255) NOT NULL cid客户号 varchar(255) NOT NULL start_time入住时间 date DEFAULT NULL end_time退房时间 date DEFAULT NULL total_price总价格 varchar(255) DEFAULT NULL check_in_sid办理入住的员工编号 varchar(255) DEFAULT NULL remark备注 varchar(255) DEFAULT NULL） 4、checkin_team团队入住表( rid房间号 varchar(255) NOT NULL tid 客户号 varchar(255) NOT NULL start_time入住时间 date DEFAULT NULL end_time退房时间 date DEFAULT NULL total_price总价格 varchar(255) DEFAULT NULL, check_in_sid办理入住的员工编号 varchar(255) DEFAULT NULL, remark备注 varchar(255) DEFAULT NULL） 5、 client客户表 ( cname姓名 varchar(255) NOT NULL cid客户号 varchar(255) NOT NULL cphone电话号 varchar(255) DEFAULT NULL cage年龄 varchar(255) NOT NULL csex性别 varchar(255) DEFAULT NULL register_sid注册员工号 varchar(255) DEFAULT NULL accomodation_times入住次数 int(11) DEFAULT NULL） register_time注册时间 timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP） 6、hotelorder订单表 ( id 用户标识 varchar(255) NOT NULL ordertype订单形式 varchar(255) NOT NULL start_time入住时间 date NOT NULL end_time退房时间 date NOT NULL rid房间号 varchar(255) NOT NULL pay_type支付方式 varchar(255) DEFAULT NULL money缴费 varchar(255) DEFAULT NULL remarkv备注 varchar(255) DEFAULT NULL order_time订单时间 timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP register_sid注册员工编号 varchar(255) DEFAULT NULL） 7、room房间表 ( rid房间号 varchar(255) NOT NULL rtype房间类型 varchar(255) NOT NULL rstorey楼层 varchar(255) NOT NULL rprice价格 varchar(255) NOT NULL rdesc房间状态 varchar(255) DEFAULT NULL rpic房间图片 varchar(255) DEFAULT NULL） 8、 staff员工表 ( sid 员工号 varchar(255) NOT NULL sname 姓名 varchar(255) NOT NULL ssex性别 varchar(255) DEFAULT NULL stime入职时间 date DEFAULT NULL susername账号 varchar(255) NOT NULL spassword 密码 varchar(255) NOT NULL srole 权限 varchar(255) NOT NULL sidcard 身份证号 varchar(255) NOT NULL sphone 手机号码 varchar(255) DEFAULT NULL） 9、team 团队表( tname名字 varchar(255) NOT NULL tid团队号 varchar(255) NOT NULL tphone电话号码 varchar(255) DEFAULT NULL check_in_sid 登记员工编号 varchar(255) DEFAULT NULL accomodation_times 入住次数 int(11) DEFAULT NULL register_time注册时间 timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP） 2、安全性分析 数据安全是指在数字信息的整个生命周期中保护数字信息免遭未经授权的访问并抵御损坏、失窃等风险，为此，我们设置了权限访问，只有输入正确的账号密码才能查看系统中的相关信息，非管理员登录无法得到系统的信息。此外，我们还可以通过输入的账号密码匹配查看相应的数据报表和客户员工个人信息，或者修改需要变动的数据。这也使得信息不容易被泄露出去，增加了数据的可改性。为防止因管理员想要修改密码，我们还设置了在登录页面可修改密码功能，加强了数据的安全性。为了防止人为操作失误使得原数据丢失、软件BUG造成数据丢失以及硬件故障造成数据库数据丢失等问题，我们设置了数据库备份，用来找回丢失的数据信息。尤其是客户的预订信息、入住信息以及数据报表的信息，在每添加一名新客户或新团体时，我们的数据库便会进行更新，这也有利于我们进行数据核对。使用数据库备份也有利于相同数据库用于新环境的搭建以及开发测试环境数据库的搭建。围绕数据安全、数据备份和其他等角度，描述系统可采取的安全策略和风险控制策
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/322861aa6c913e4e824c0f0969ad9bb7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/589/">«</a>
	<span class="pagination__item pagination__item--current">590/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/591/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>