<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a906d75acc6e7366083d3eb2c04429/" rel="bookmark">
			合成孔径雷达(SAR) RD算法 面目标成像Matlab仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		合成孔径雷达SAR RD算法 面目标成像Matlab仿真 一、概述二、面目标成像的注意点1.算力的问题2.距离向分辨率与方位向分辨率的问题3.随机相位的问题 三、成像步骤与图解1.回波生成2.距离向频谱3.距离压缩结果4.方位向傅里叶变换结果(距离多普勒域)5.徙动校正结果6.方位压缩(成像结果) 四、完整代码 一、概述 所谓面目标仿真，其实是点目标仿真的升级版，不了解点目标仿真的同学可以先看一下点目标仿真
https://blog.csdn.net/qq_30017409/article/details/133905960
在点目标仿真中，我们主要是通过距离多普勒算法，将回波数据成像为了多个点，但是这个点在内容上是没有任何意义的。而如果有许多点目标，每个点目标都有它的灰度值，组合在一起就能够达到成像的效果了。
例如，一张分辨率为300*300的SAR图像，代表着它有300行×300列的像素，而每个像素都有一个灰度值（注意将SAR图像与RGB三通道图像区分），也就是强度值；那么我们利用点目标成像的方法，将每个点的强度值赋到我们的点目标上，就能够实现面目标成像了。
重新梳理一下面目标成像的流程：首先有一张SAR图像-&gt;将SAR图像的每个像素点对应的灰度值，赋到一个点目标上-&gt;对许多点目标同时进行成像-&gt;得到一副由回波数据，进过距离多普勒算法（其他算法也一样）成像的图片，这张图片对应与我们预设的那张SAR图像
那么肯定有同学要问了，这把一幅图片生成为回波数据，再成像，最后得到的还是原来那一副图片，好像没有什么意义？其实不然，因为各种各样的原因，写论文或是做实验的时候，很多实验并不适合在实测（真实的雷达）数据上进行，转而使用这种仿真的方式，一样能够达到发论文，论证创新方法有效性的目的，所以面目标成像也算是基本功。
本文旨在基于Ian G. Cumming的《合成孔径雷达成像算法与实现》中第六章的距离多普勒算法处，机载雷达的数据进行面目标仿真，辅以讲解，完整代码请见文末
另外：作者也是SAR成像的初学者，代码和讲解当中也有许多瑕疵的存在，仅供读者参考
二、面目标成像的注意点 将一个点目标的成像看成是用打印机打印“一个点”，那么面目标成像就是用打印机打印“很多个点”，而这些点的强度值(灰度值)不相同，从而组成了我们看到的图像。在这个“打印”的过程当中，下面的问题需要注意，其他涉及的部分基本与点目标仿真相同
1.算力的问题 面目标成像十分消耗算力，但不是成像过程消耗算力，而是将一张图片转换成回波，生成回波的计算过程非常消耗算力，这里面涉及到大量的矩阵运算，所以在专业仿真当中一般都会用GPU运算进行优化，接下来的示例使用一张130*150的J20图像用于演示，一般的笔记本也可以进行仿真。
在Matlab中，我们可以在生成回波时使用：
single函数转换数据为单精度，缩短运行时间gpuArray函数将数据转移到GPU上进行计算 %根据Naz*Nrg的点数生成回波 Target_num=Ntarget; S_echo = zeros( Nrg,Naz); S_echo=gpuArray(single(S_echo));%转换为单精度并放置到GPU上计算 2.距离向分辨率与方位向分辨率的问题 将面目标成像看做是打印目标点，那么需要非常注意目标点之间的“间距”。
在图像中，我们的每个像素点都是紧邻的，所以不存在间距的概念但是在SAR成像中，我们的每个点目标之间的距离分别是“距离分辨率”与“方位分辨率”
因此产生了不同，我们需要在代码中将像素点与点目标的坐标对应起来
首先我们要计算rho_r和rho_a % 合成孔径参数 rho_r = c / (2 * Fr); % 距离向分辨率 rho_a = Vr/Fa; % 距离向分辨率|La / 2 然后生成点目标的坐标
%% 点目标坐标设置 % 设置目标点相对于景中心之间的距离 img_0 = imread('./800600_SIM/J20.png'); img_0=imrotate(img_0, -6, 'crop');%顺时针旋转5度(可选) img = im2double(rgb2gray(img_0)); %img = im2double(img_0); w_r =rho_r; % 图片img中单位像素对应的距离(m) w_a=rho_a; NPosition = zeros(numel(img),4); % 坐标系原点设为参考点零多普勒时刻雷达星下点，x地距向，y方位向，z地表法线向 for m = 1:size(img,1)%行数 for n = 1:size(img,2)%列数 img(m,n) if(img(m,n)==0) continue;%跳过背景点 end NPosition( (m-1)*size(img,2)+n,: ) = [(n-1)*w_a,(m-1)*w_r, 0, img(m,n) ]; end end Range_Size=size(img,1);%求像素点大小数量 Azimuth_Size=size(img,2); nonZeroRows = any(NPosition, 2);%去除全为0的行，也就是刚才的背景点 NPosition = NPosition(nonZeroRows, :); Ntarget = size( NPosition,1 );%像素点的个数 Position_x_r = (NPosition(:,2)-max(NPosition(:,2))/2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0a906d75acc6e7366083d3eb2c04429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e82288ec6a47dbfa973052823fc16355/" rel="bookmark">
			【数据结构】——（二叉树）堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.树概念及结构 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根结点没有前驱结点
除根结点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继因此
树是递归定义的。
注意：树形结构中，子树之间不能有交集，否则就不是树形结构。
1.2 树的相关概念 结点的度：一个结点含有的子树的个数称为该结点的度； 如上图：A的为6
叶结点或终端结点：度为0的结点称为叶结点； 如上图：B、C、H、I...等结点为叶结点
非终端结点或分支结点：度不为0的结点； 如上图：D、E、F、G...等结点为分支结点
双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点
孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点
兄弟结点：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点
树的度：一棵树中，最大的结点的度称为树的度； 如上图：树的度为6 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推；
树的高度或深度：树中结点的最大层次； 如上图：树的高度为4
堂兄弟结点：双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点
结点的祖先：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先
子孙：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
1.3 树的表示 树的表达有很多种
1.明确知道树的度时，直接用指针数组、
//明确告诉树的度为N #define N 4 struct treeNode { int val; struct treeNode* subs[N]; }; 这种方法在N很大时，可能会导致极大的空间浪费，因为树最大的有N个节点，不代表每个父节点都有N个子节点，很可能会导致空间浪费。
2.左孩子右兄弟表示方法
typedef struct treeNode { int val; struct treeNode* leftchild; // 第一个孩子结点 struct treeNode* rightbrother; // 指向其下一个兄弟结点 }HP; 结构图如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e82288ec6a47dbfa973052823fc16355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e15a58488f2ccf6a6715001641f2467b/" rel="bookmark">
			axios详解，基本使用与封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios详解，基本使用与封装 什么是Axios对比1. AJAX2. jQuery的$.ajax方法3. Axios4. XMLHttpRequest5. Fetch6. 总结 Axios的基本使用ts封装Axios为什么封装axios一次封装二次封装 如何封装第一次封装第二次封装使用 什么是Axios Axios 是一个基于 Promise 的网络请求库（类似于jQuery的Ajax，用于HTTP请求），作用于node.js 和浏览器中。
对比 1. AJAX AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术，是一个技术统称。
2. jQuery的$.ajax方法 AJAX的简化,jQuery是一个封装好的JavaScript库，所以jQuery的$.ajax方法比原生Ajax的简单
缺点：依赖 jQuery，配置繁琐，不轻量
选择建议：项目已经使用了jQuery，并且对HTTP请求没有特殊需求
3. Axios 基于 Promise的网络请求库，用于浏览器和Node.js中发送HTTP请求。axios是通过promise技术实现对ajax实现的一种封装，本身上来说axios就是ajax
缺点：可能出现跨域问题
选择建议：正在使用较新的JavaScript框架（如React、Vue等），并且需要高级HTTP功能
4. XMLHttpRequest XMLHttpRequest是一个浏览器内置的JavaScript对象，它允许开发者在页面没有刷新的情况下从服务器请求数据，并接收服务器的响应。是AJAX的基础
缺点：配置和调用方式都很繁琐
选择建议：正在开发一个需要兼容旧浏览器或需要更精细地控制HTTP请求的应用
5. Fetch Fetch API ES6 之后出现的基于 Promise 的一个JavaScript库，是一个现代的网络请求API，
缺点：新技术，部分浏览器可能不兼容
选择建议：正在开发一个不需要复杂HTTP处理功能的Web应用，并且希望使用原生的浏览器API
6. 总结 ajax是一个技术的统称，是js异步技术的术语，XMLHttpRequest 是实现 Ajax 的一种方式。jQuery的$.ajax方法是一个方法，封装了Ajaxaxios是一个库，是用于网络请求的第三方库。fetch是一个api，是es6新增的用于网络请求标准api。XHR是一个 JavaScript 对象，可以封装Ajax Axios的基本使用 get：一般用于获取数据
post：一般用于提交数据（表单提交与文件上传）
patch：更新数据（只将修改的数据推送到后端（服务端））（适合数据量比较大的更新）
put：更新数据（所有数据推送到服务端）（适合数据量比较小的更新）
delete：删除数据
// ————————axios get方法第一种写法———————— // get方法——————1.不带参数 axios.get('http://jsonplaceholder.typicode.com/posts') .then(function (response) { // 处理成功情况 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e15a58488f2ccf6a6715001641f2467b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae8266ed6847b936162eaa41c39948f/" rel="bookmark">
			18个AI变现案例分享，每一个都可以作为副业赚睡后收入！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是向阳
分享了这么多关于AI绘画方向的技术教程，使用教程。就有很多粉丝希望我分享一些关于AI绘画副业以及变现方面的指南，那么今天这篇文章就重点分享一些目前我所知的，且比较容易实现的AI变现项目。文章较长，建议收藏观看！
看完你也一定能用AI赚到第一桶金！
下面的18个AI变现案例，每一个都可以作为一个副业去做。AI时代已经来了，抓紧学习AI知识，拥抱未来。
1. AI +剧本创作
项目概述：
AI技术助力剧本创作，面向商单客户，提供简洁、经济的解决方案，实现低成本、高效率的剧本产出
市场分析：
目标客户：追求高性价比的商单客户群体，对AI剧本创作有实际需求
市场机遇：原创剧本供应短缺，人力成本高，AI创作成为有效补充
商机探索：在主流电商平台如小红书、拼多多、淘宝等竞争不激烈，有机会建立长期合作伙伴关系
2. AI + LOGO、建筑设计
项目简介：
创新项目将知名品牌LOGO及日常物品元素融入建筑设计中，打造独特且引人注目的建筑作品。通过互动评论和粉丝管理提升账号活跃度，实现快速增长关注者，为后续变现打下基础。
操作策略：
1.部署Stable Diffusion模型至本地或云端
2.对目标LOGO进行精细抠图
3.利用Stable Diffusion的segment anything功能处理，或采用局部重绘技术
4.在小红书发布专题内容，参考并借鉴成功案例账号
引流与变现：
通过提供个性化定制设计服务，确保服务质量，吸引口碑传播和客户复购
3.AI +口播视频
项目概念：
依托小红书平台，运用ChatGPT生成专业或生活科普类文案，内容涵盖专业领域知识及生活小常识，以实现后续的商品推广和变现。参考专注于减肥领域的博主案例，自8月起累计粉丝超3万，作为参考标准。
执行步骤：
注册短视频账号，实施矩阵策略，增加账号间的互动与合作
账号专题化，将账号打造成特定领域的专业账号
赛道选择，进行多话题测试，如：一个账号专注减肥知识，另一个分享生活冷知识，再如分享教师资格证考试经验等
利用ChatGPT生成口播文案，并配合口播软件进行内容创作。参考目标账号内容，通过爬取其文章并投喂给ChatGPT以生成新文案
结合热门话题和关键词，创作并发布相关内容，提高内容的曝光率和互动性
4. AI +婚礼定制
项目概述：
运用Midjourney AI技术提升婚礼场景设计的效率，创造传统手绘无法比拟的效果图，开拓AI在婚礼策划行业的新商业机会。通过提供婚礼策划师培训、开发行业小程序和销售专业prompt集等方式实现变现。
具体操作：
1.婚礼策划师的Midjourney使用培训
-课程内容：涵盖Midjourney基础知识、历史、功能特点
-教授如何在Midjourney上创建、编辑、保存婚礼布场设计，讨论设计技巧，颜色、布局和元素选择
-解决使用Midjourney时的常见问题
-设立问答环节，解答策划师的实际操作疑问
5. AI +家居家装小红书号
项目简介：
利用Stable Diffusion技术在小红书平台上进行家居家装内容创作，通过结合Instagram及国内家居应用中的家居图片，吸引目标用户群体，实现有效引流和变现。
操作指南：
1.注册并运营小红书账号，采用矩阵策略以增强品牌影响力。在个人简介中巧妙地提供联系方式，或通过评论区引导用户至私域流量，同时遵守平台规则避免违规操作。
2.训练或搜索下载适合的Stable Diffusion模型，用于创作家居装修效果图，并定期发布。同时，从Instagram和国内家居应用中筛选并下载高质量的家居图片作为参考。
3.结合当前热门话题和关键词，创作并发布相关内容，提高内容的搜索排名和用户互动，从而吸引更多用户关注和转化。
6. AI +简历代做
项目概述：
针对日益激烈的求职市场，提供专业的简历优化服务。通过AI技术，快速提升简历质量，帮助求职者在众多竞争者中脱颖而出，实现服务变现。
操作指南：
1.账号准备：在闲鱼app上注册账号，并通过淘宝账号登录。对于新手，建议先熟悉平台规则和界面，避免违规操作，再根据需要设置个性化昵称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae8266ed6847b936162eaa41c39948f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2629928dc7920a8aa0ea29874ae4b7e3/" rel="bookmark">
			如何使用androidstudio成功导入别人项目教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.打开别人的项目文件夹，删除 .idea .gradle文件夹和local.properties文件 2.打开项目app文件夹，删除build文件，如果有*.iml文件的也要删除(* 表示所有) 3.修改项目app文件夹下的build.gradle 可以打开之前可以运行的项目，或者新建一个项目，一定要是可以成功运行的！！
然后根据成功运行项目里的app/build.gradle文件来修改别人项目的build.gradle
① 修改 compileSdkVersion , buildToolsVersion；（根据你自己电脑上成功运行的模板修改）
② 修改 defaultConfig{} 中的 minSdkVersion 和 targetSdkVersion（根据你自己电脑上成功运行的模板修改）
③ 把 dependencies{} 中implementation 里面相对应的版本也修改，别人的项目可能会有很多条，我们只要修改我们自己成功运行项目里implementation对应的版本即可，别人项目里多余的implementation不要删除也不要修改！！！
4.修改主项目下的build.gradle，注意是主项目下，不要搞错 打开自己之前可以运行的项目，将classpath：...一整句直接复制即可。
5.打开主项目下/gradle/wrapper下的gradle-wrapper.properties 用成功的项目里面的这句话替代，一定要按自己AS版本来！
6.最后open打开项目，记得同步一下，如果还报错，可以invalidate Caches一下即可。 补充：
如果别人项目里的主项目下的build.gradle有
maven{url '...网址'}，可以复制一下它的网址到浏览器打开，通过提示去换一个新版的阿里云仓库地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f6efdbc35e297553191c74dcfc979f/" rel="bookmark">
			【SpringBoot】SpringBoot中使用AOP实现日志记录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
📕AOP简介
📂创建日志数据库 🔥创建日志记录表
🌼创建用户表 🍉SpringBoot使用AOP
一、导入依赖
二、创建我们的项目结构
三、使用AOP
1.创建枚举类
2..创建Log注解
3.创建切面类
4.IpUtil
5.进行测试
在我之前的一篇文章中我已经讲解过了AOP的基本概念，在这里无非也就是在重复一遍。
📕AOP简介 AOP的全称是Aspect-Oriented Programming，即面向切面编程（也称面向方面编程）。它是面向对象编程（OOP）的一种补充，目前已成为一种比较成熟的编程方式。
在传统的业务处理代码中，通常都会进行事务处理、日志记录等操作。虽然使用OOP可以通过组合或者继承的方式来达到代码的重用，但如果要实现某个功能（如日志记录），同样的代码仍然会分散到各个方法中。这样，如果想要关闭某个功能，或者对其进行修改，就必须要修改所有的相关方法。这不但增加了开发人员的工作量，而且提高了代码的出错率。
为了解决这一问题，AOP思想随之产生。AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行时，再将这些提取出来的代码应用到需要执行的地方。这种采用横向抽取机制的方式，采用传统的OOP思想显然是无法办到的，因为OOP只能实现父子关系的纵向的重用。虽然AOP是一种新的编程思想，但却不是OOP的替代品，它只是OOP的延伸和补充。
想要再详细了解AOP的大家可以看看我这篇文章。这篇文章我主要将在SpringBoot中使用AOP实现日志记录。
【Spring】Spring中AOP的简介和基本使用，SpringBoot使用AOP-CSDN博客
📂创建日志数据库 🔥创建日志记录表 SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for sys_oper_log -- ---------------------------- DROP TABLE IF EXISTS `sys_oper_log`; CREATE TABLE `sys_oper_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '日志主键', `operation` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '操作', `business_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '业务类型', `method` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '方法名称', `create_time` datetime(0) NULL DEFAULT NULL COMMENT '操作时间', `oper_name` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '操作用户', `params` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '参数', `ip` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '请求的ip地址', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 2058 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '操作日志记录' ROW_FORMAT = Dynamic; SET FOREIGN_KEY_CHECKS = 1; 🌼创建用户表 SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for user -- ---------------------------- DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID', `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '姓名 ', `age` int(11) NULL DEFAULT NULL COMMENT '年龄 ', `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱 ', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; -- ---------------------------- -- Records of user -- ---------------------------- INSERT INTO `user` VALUES (2, 'Jack', 20, 'test2@baomidou.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63f6efdbc35e297553191c74dcfc979f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf29e511544e3ea2d433dfc4b2c2f8a/" rel="bookmark">
			网络安全（黑客）—-2024自学手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是网络安全 网络安全可以基于攻击和防御视角来分类，我们经常听到的 “红队”、“渗透测试”等就是研究攻击技术，而“蓝队”、“安全运营”、“安全运维”则研究防御技术。 无论网络、Web、移动、桌面、云等哪个领域，都有攻与防两面性，例如 Web 安全技术，既有 Web 渗透，也有 Web 防御技术（WAF）。作为一个合格的网络安全工程师，应该做到攻守兼备，毕竟知己知彼，才能百战百胜。
二、怎样规划网络安全 如果你是一个安全行业新人，我建议你先从网络安全或者Web安全/渗透测试这两个方向先学起，
一、是市场需求量高 二、则是发展相对成熟入门比较容易
值得一提的是，学网络安全，是先网络后安全；学Web安全，也是先Web再有安全。
安全不是独立存在的，而是建立在其他技术基础之上的上层应用技术。脱离了这个基础，就很容易变成纸上谈兵，变成“知其然，不知其所以然”，在安全的职业道路上也很难走远。
如果你是原本从事网工运维，那么可以选择网络安全方向入门； 如果你原本从事程序开发，推荐选择Web安全/渗透测试方向入门。 当然学到一定程度、或者有了一定工作经验，不同方向的技术耦合会越来越高，各个方向都需要会一点。
根据以上网络安全技能表不难看出，网络安全需要接触的技术还远远很多，
常见的技能需要学习：
三、网络安全的知识多而杂，怎么科学合理安排？ 1、基础阶段 中华人民共和国网络安全法 （包含18个知识点）
Linux操作系统 （包含16个知识点）
计算机网络 （包含12个知识点）
SHELL （包含14个知识点）
HTML/CSS （包含44个知识点）
JavaScript （包含41个知识点）
PHP入门 （包含12个知识点）
MySQL数据库 （包含30个知识点）
Python （包含18个知识点）
入门的第一步是系统化的学习计算机基础知识，也就是学习以下这几个基础知识模块:操作系统、协议/网络、数据库、开发语言、常用漏洞原理。
前面的基础知识学完之后，就要进行实操了。
因为互联网与信息化的普及网站系统对外的业务比较多,而且程序员的水平参差不齐和运维人员的配置事物，所以需要掌握的内容比较多。
2、渗透阶段 SQL注入的渗透与防御（包含36个知识点）
XSS相关渗透与防御（包含12个知识点）
上传验证渗透与防御（包含16个知识点）
文件包含渗透与防御（包含12个知识点）
CSRF渗透与防御（包含7个知识点）
SSRF渗透与防御（包含6个知识点）
XXE渗透与防御（包含5个知识点）
远程代码执行渗透与防御（包含7个知识点）
掌握常见漏洞的原理、使用、防御等知识。Web渗透阶段还是需要掌握一些必要的工具。
主要要掌握的工具和平台：burp、AWVS、Appscan、Nessus、sqlmap、nmap、shodan、fofa、代理工具ssrs、hydra、medusa、airspoof等，以上工具的练习完全可以利用上面的开源靶场去练习，足够了；
3、安全管理（提升） 渗透报告编写（包含21个知识点）
等级保护2.0（包含50个知识点）
应急响应（包含5个知识点）
代码审计（包含8个知识点）
风险评估（包含11个知识点）
安全巡检（包含12个知识点）
数据安全（包含25个知识点）
主要包括渗透报告编写、网络安全等级保护的定级、应急响应、代码审计、风险评估、安全巡检、数据安全、法律法规汇编等。
这一阶段主要针对已经从事网络安全相关工作需要提升进阶成管理层的岗位。如果你只学习参加工程师方面的岗位，这一阶段可学可不学。
4、提升阶段（提升） 密码学（包含34个知识点）
JavaSE入门（包含92个知识点）
C语言（包含140个知识点）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf29e511544e3ea2d433dfc4b2c2f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63fd3b016935fb15a8b077f1b9c026e5/" rel="bookmark">
			程序员必备的5类AI工具盘点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件开发领域，人工智能技术正以惊人的速度推动着创新和进步。从代码生成到自动化测试，各种AI工具正在改变着软件开发的方式和未来。在本文中，我们将盘点软件开发领域中最具创新性和影响力的5类AI工具
一. 编程辅助AI工具 1.GitHub Copilot GitHub Copilot是由GitHub与OpenAI合作开发的一款革命性的智能代码补全和生成工具，旨在帮助开发人员更高效、更准确、更快地编写代码。这款由人工智能驱动的AI编程助手与程序员常用的代码编辑器无缝集成，超过数百万人在使用，对全球各地的开发者来说都是代码神器和得力助手。
详细信息请点击 GitHub Copilot 查看
2.CodeGeeX CodeGeeX是国内人工智能公司智谱AI开发的对标GitHub Copilot的免费AI编程工具，该工具基于其CodeGeeX2多语言代码生成模型，支持Python、Java、C++/C、JavaScript、Go等多种编程语言，可以实现代码的生成与补全、自动添加注释、代码翻译以及智能问答等功能，帮助开发者快速编写代码，提升开发效率。
详细信息请点击 CodeGeeX 查看
3.Codeium Codeium 是一个基于人工智能技术构建的AI代码编程工具，提供代码自动补全和搜索功能，使开发人员能够快速定位和生成代码。该AI工具包可以帮助开发人员更快、更高效地编写代码，以增强开发人员的编程体验。
详细信息请点击 Codeium 查看
二. 代码Review AI工具 1.DeepSource DeepSource 是一款自动代码审查和分析工具，旨在帮助开发团队提高代码质量和安全性。它支持多种编程语言，并提供一套静态代码分析规则，用于检测潜在的代码错误、安全漏洞和代码风格问题。同时，DeepSource 可与代码托管平台（如 GitHub、GitLab 等）和集成开发环境（IDE）集成，实时分析代码并提供改进建议，帮助开发人员及早发现并解决问题。
详细信息请点击DeepSource查看
2.DeepCode AI DeepCode AI 是一款基于人工智能的代码审查工具，它使用机器学习算法分析代码库，识别潜在的安全漏洞、错误风险和性能问题。通过从大型开源代码数据集中学习并应用先进的语义分析技术，DeepCode 能够为开发人员提供精确的、上下文感知的建议，以提高代码质量。
详细信息请点击DeepCode AI查看
三. 代码测试AI工具 1.CodiumAI CodiumAI是一款AI代码测试和分析工具，可以智能分析开发者编写代码、文档字符串和注释，并且可以与人聊天互动，在编程时生成测试建议和提示。借助其全面的测试套件，可以帮助开发人员在软件发布前发现Bug或错误，确保软件的可靠性和准确性。
详细信息请点击CodiumAI查看
2.Testim Testim 是一款基于人工智能的现代 UI 测试工具，它提供快速、低代码编写和代码定制功能，自愈式人工智能定位器，以及用于高效扩展质量程序的 TestOps 工具，使团队能够减少测试次数，提高创新能力。
详细信息请点击Testim查看
四. 代码重构AI工具 Sourcery Sourcery 是一款自动代码重构工具，旨在帮助开发人员改进和简化代码。Sourcery 会分析代码并自动应用一系列重构模式和最佳实践，以提高代码的可读性、性能和可维护性。这些重构包括消除冗余、简化复杂代码、引入更清晰的命名等。通过自动重构，Sourcery 可帮助开发人员节省时间，确保代码符合最佳编码实践，从而提高代码质量和开发效率
详细信息请点击Sourcery查看
五. 代码阅读AI工具 Cursor Cursor是一款AI代码生成工具，它能够自动生成高质量的代码，也可以用于阅读项目源代码。通过使用Cursor，开发者可以快速地阅读代码、生成代码，减少开发时间和人力成本。
详细信息请点击 Cursor 查看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63fd3b016935fb15a8b077f1b9c026e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8c9792e7bcd3f0da8148f134407012/" rel="bookmark">
			多目标遗传算法(NSGAⅢ)的原理和matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献： [1] Deb K , Jain H .An Evolutionary Many-Objective Optimization Algorithm Using Reference-Point-Based Nondominated Sorting Approach, Part I: Solving Problems With Box Constraints[J].IEEE Transactions on Evolutionary Computation, 2014, 18(4):577-601.DOI:10.1109/TEVC.2013.2281535.
非支配排序遗传算法(Non-dominated Sorting Genetic Algorithms，NSGA)是最经典的多目标优化算法之一，在NSGA算法的基础上，目前已经更新了NSGA-Ⅱ和NSGA-Ⅲ两种算法。NSGA-Ⅲ算法又称为NSGA3算法，第三代非支配排序遗传算法，第三代多目标遗传算法，这篇博客主要对NSGA-Ⅲ算法的原文献进行解读，重点介绍NSGA-Ⅲ算法的实现原理。
1.引言 由于传统的多目标优化已经很难满足水论文的目的了，因此现在多目标优化的研究主要集中在超多目标优化(many-objective optimization)，也就是四个以上目标函数的优化问题。而超多目标优化问题的研究也凸显了NSGA-Ⅱ及其他一些传统多目标优化算法的不足之处：
1）非支配解的数量爆炸式增长。超多目标优化问题中非支配解的数量呈指数级别增加，如何筛选和存储非支配解成为难题；
2）种群多样性评估的算法效率问题。超多目标优化问题中进行种群的选择操作时，为保证种群多样性，采用拥挤距离或聚类算子的计算效率很低，时间和空间复杂度都会变得很高；
3）种群重组策略的作用存疑。在超多目标优化问题中，不同的解之间的欧氏距离一般都较远，通过不同解信息相结合得到的新解的距离一般也会很远，这样更新的效果存疑。
4）不同优化目标的权衡面表示困难。需要用更大规模的解集才能表示帕累托前沿，同时很难从解集中选择适当的方案。
5）帕累托前沿可视化困难。不同于2目标或者3目标问题，超多目标优化问题的帕累托前沿难以用图像展示。
针对非支配解计算效率相关的问题，通常有两种不同的解决方法，其中一种方法是通过设置特殊支配原则(如ε支配原则)进行缓解。通过ε-支配，可以在很大程度上减少非支配解的数量，提高算法的搜索效率。
而在NSGA-Ⅲ算法中，针对种群多样性评估的算法效率等问题，采用了预定义的参考点对搜索方向进行引导。通过预先构造均匀分布的参考点对算法搜索方向进行引导，可以使得生成的帕累托前沿也尽可能均匀分布，即使在超多目标优化中也无需存储大规模非支配解集即可表示出帕累托前沿。针对种群重组策略的问题，NSGA-Ⅲ采用了对重组操作的个体进行限制的方式，只有处于相邻参考点的解之间才会发生重组操作，可以避免无效的重组操作。
2.相关概念的解释 引言中存在一些较新的概念，下面分别对这些概念进行简单说明，后面也会结合算法原理进一步解释。
2.1 ε-支配 在多目标进化算法中，ε-支配是一种改进的支配关系定义，用于解决传统Pareto支配关系的局限性。传统Pareto支配关系要求一个解在所有目标函数上都不劣于另一个解。然而，超多目标优化中，这种支配关系将导致非支配解数量过多。ε-支配通过引入一个小的正数ε来修正支配关系的定义。仅当一个解在所有目标上都比另一个解更优，且数值差在ε以上才认为其中一个解支配另一个解。举例说明：
对于多目标优化问题min {f1,f2,f3,f4}，设定ε=0.05，假设有两个解A=[1.5, 1.5, 1.5, 1.5]，B=[1.46, 1.7, 1.48, 1.9]，按照传统支配关系定义，解A和解B互不支配，为一组非支配解，但如果按照ε-支配的定义，A ≤ B+ε = [1.51, 1.75, 1.53, 1.95]，因此在ε-支配的定义下，可以认为解A支配解B。同理可得，通过使用ε-支配原则，可以大量减少非支配解的数量。
2.2 参考点 参考点常常被用来解决多目标优化问题上的收敛性和多样性问题，使用预定义的参考点可以指导NSGA-Ⅲ算法搜索解空间的方向，使得算法会更加倾向于搜索那些距离参考点较近的解。此外，参考点的分布会影响到生成的非支配解的多样性。如果参考点分布均匀，NSGA-Ⅲ算法就可以在 Pareto 前沿上找到尽可能广泛的解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8c9792e7bcd3f0da8148f134407012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a86d3b7e97cd92709bbd9b9adb82fa0/" rel="bookmark">
			JAVA批量新增、批量修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA批量新增、批量修改 若数据量非常大，可以把List拆成多份，每份1000条数据。NetPointDTO批量新增SQL.xml批量修改SQL.xmlpom.xml 文件 需要一个 hutool 依赖 若数据量非常大，可以把List拆成多份，每份1000条数据。 import cn.hutool.core.collection.ListUtil; import cn.hutool.core.util.StrUtil; import cn.路劲.NetPointDTO; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; import java.util.List; import java.util.Map; import java.util.stream.Collectors; @Slf4j @Service public class NetPointServiceImpl implements NetPointService { /** * 批量新增 */ @Override public boolean add(List&lt;NetPointDTO&gt; dataList) { //数据里的 编码 查重 String netPointCode = dataList.stream() .collect(Collectors.groupingBy(NetPointDTO::getNetPointCode, Collectors.counting())) .entrySet() .stream() .filter(e -&gt; e.getValue() &gt; 1L) .map(Map.Entry::getKey) .collect(Collectors.joining("、")); if (StrUtil.isNotBlank(netPointCode)){ throw new RuntimeException("网点编码 "+ netPointCode + " 重复"); } //切分List， 此方法返回的是原List的视图，也就是说原List有变更，切分后的结果也会变更 List&lt;List&lt;NetPointDTO&gt;&gt; partition = ListUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a86d3b7e97cd92709bbd9b9adb82fa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec003d1f08063f61e10c8b8060bc8422/" rel="bookmark">
			【面试干货】二叉树的遍历算法（先序、中序、后序遍历）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【面试干货】二叉树的遍历算法（先序、中序、后序遍历） 1、实现思想2、代码实现 💖The Begin💖点点关注，收藏不迷路💖 1、实现思想 先序遍历（Pre-order Traversal）：
从根节点开始，按照根节点-左子树-右子树的顺序递归遍历每个节点。实现思路：递归地对当前节点进行处理，先将当前节点的值加入结果列表，然后递归处理左子树和右子树。 中序遍历（In-order Traversal）：
从根节点开始，按照左子树-根节点-右子树的顺序递归遍历每个节点。实现思路：递归地对当前节点进行处理，在递归调用之前处理左子树，然后将当前节点的值加入结果列表，在递归调用之后处理右子树。 后序遍历（Post-order Traversal）：
从根节点开始，按照左子树-右子树-根节点的顺序递归遍历每个节点。实现思路：递归地对当前节点进行处理，在递归调用之前处理左子树，然后处理右子树，在最后将当前节点的值加入结果列表。 2、代码实现 package csdn; import java.util.ArrayList; // 导入 ArrayList 类，用于存储遍历结果 import java.util.List; // 导入 List 接口，用于存储遍历结果 public class TreeNode { // 定义 TreeNode 类 int val; // 定义整型变量 val，用于存储节点的值 TreeNode left; // 定义左子节点 TreeNode right; // 定义右子节点 TreeNode(int x) { // 构造方法，初始化节点的值 val = x; // 将传入的参数 x 赋值给 val } // 用递归的方法进行先序遍历 public void qianxuDigui(TreeNode treeNode, List&lt;Integer&gt; resultList) { // 先序遍历方法，参数为当前节点和存储结果的列表 if (treeNode !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec003d1f08063f61e10c8b8060bc8422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25108e969a886376df2f0ad18b824d58/" rel="bookmark">
			Hadoop 3.3.6 &#43; Tez 0.10.3 &#43; Hive 4.0.0 安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据 Hive 官方发布说明，Hive 4.0.0 兼容 Hadoop 3.3.6 和 Tez 0.10.3，尝试搭建了一套单节点的环境用于学习
一、系统安装及配置 操作系统：RHEL 9.4IP地址: 192.168.1.10主机名: hadoop创建 hadoop 用户# 创建家目录 mkdir /user # 创建用户 useradd -m -d /user/hadoop hadoop # 设置密码 passwd hadoop 配置 SSH 免密登录# 切换到 hadoop 用户 su hadoop # 生成 SSH 密钥对 ssh-keygen -t rsa # 复制公钥 ssh-copy-id hadoop 安装 Java 8# 解压安装包 tar xvf jdk-8u411-linux-x64.tar.gz -C /opt # 配置环境变量 vim /etc/profile.d/hadoop.sh # JAVA export JAVA_HOME=/opt/jdk1.8.0_411 export PATH=$PATH:$JAVA_HOME/bin 安装 MySQL# 安装 MySQL 服务 yum -y install mysql-server # 启动 MySQL systemctl start mysqld # 设置开机自动启动 systemctl enable mysqld # 设置 root 密码 mysqladmin -u root -p password 二、Hadoop 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25108e969a886376df2f0ad18b824d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c376507464cdc4aaac63eeb31badfa4c/" rel="bookmark">
			AIGC行业现在适合进入吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
1.1.行业发展阶段
1.2.市场需求
1.3.政策扶持
1.4.小结
2.行业前景
2.1.AIGC行业当前发展前景
​​​​​​​2.2.相关领域的发展趋势
​​​​​​​2.3.行业的潜力和竞争情况
​​​​​​​2.4.小结
3.市场需求
​​​​​​​3.1.市场需求分析
​​​​​​​3.2.人才需求类型分析
​​​​​​​3.3.人才供给现状分析
3.4.​​​​​​​机会和挑战分析
3.4.1.机会
​​​​​​3.4.2.​挑战
​​​​​​​3.5.小结
4.选择与规划
​​​​​​​4.1.AIGC行业概述
​​​​​​​4.2.个人技能分析
​​​​​​​4.3.个人兴趣分析
​​​​​​​4.4.职业规划
​​​​​​​4.5.自身选择与规划
4.6.小结
1.概述 当前时机是否适合进入AIGC行业，需要从行业发展阶段和市场需求两个方面进行综合考虑。我们从这两个方面展开探讨是否适合进入AIGC行业。
1.1.行业发展阶段 1.技术成熟度
AIGC行业的发展离不开人工智能技术的成熟。近年来，随着深度学习、生成对抗网络等技术的不断发展，AIGC技术逐渐走向成熟。根据Gartner发布的炒作周期，生成式AI目前正处于第2阶段，即膨胀预期峰值。行业内的关注度和期望值正在迅速上升，技术的发展和应用前景广阔。
2.市场规模
随着技术的成熟，AIGC行业的市场规模也在不断扩大。根据市场调查机构的数据，AIGC市场规模预计将在未来几年内保持高速增长。AIGC行业具有较大的市场潜力，为进入该行业提供了良好的发展空间。
3. 行业竞争格局
尽管AIGC行业市场规模不断扩大，但竞争也日益激烈。目前，已有众多企业和研究机构投入到生成式AI的研发和应用中，占据了市场份额。进入AIGC行业需要具备一定的技术实力和创新能力，以应对激烈的竞争。
1.2.市场需求 1.行业应用场景丰富
AIGC技术在多个领域取得了显著进展，如文本、图像、音乐、视频等内容的自动生成。为各行各业提供了便捷的创新工具，满足了市场需求。随着技术的进一步发展，AIGC技术在更多领域有望实现突破，为市场带来更多应用场景。
2. 企业和个人需求增长
随着企业和个人对数字化转型的需求不断增长，AIGC技术逐渐成为重要的创新力量。企业通过引入AIGC技术，可以提高运营效率、降低成本、提升用户体验。个人用户也可以通过AIGC技术实现个性化内容创作，满足自我表达的需求。
1.3.政策扶持 我国政府高度重视人工智能行业的发展，出台了一系列政策措施，鼓励企业加大研发投入，推动人工智能技术与实体经济的深度融合。为AIGC行业的发展提供了良好的政策环境，有利于企业进入该行业。
综合分析，当前时机适合进入AIGC行业。原因如下：
1.技术成熟度不断提高，为行业的发展提供了有力支撑。
2.市场规模不断扩大，市场潜力巨大。
3.行业应用场景丰富，满足了企业和个人用户的需求。
4.政策扶持力度加大，为AIGC行业的发展创造了有利条件。
然而，进入AIGC行业也面临一定的挑战：
1.竞争激烈，需要具备较强的技术实力和创新能力。
2.数据隐私和伦理问题需要关注，合规经营至关重要。
3.行业波动较大，需要应对市场风险。
1.4.小结 在进入AIGC行业时，企业应充分了解行业特点，把握市场需求，加强技术创新，确保合规经营，以在激烈的市场竞争中脱颖而出。
2.​​​​​​​​​​​​​​行业前景 2.1.AIGC行业当前发展前景 人工智能生成内容（AIGC）技术，作为人工智能领域的热点之一，正逐渐成为数字世界的新生产力。AIGC技术涵盖了文本生成、图像生成、视频生成、音频生成等多种形式，其在广告、媒体、娱乐、教育、电商等行业的应用日益广泛，展现出巨大的商业价值。
1.技术驱动的创新
随着深度学习、生成对抗网络（GANs）、变分自编码器（VAEs）等技术的不断突破，AIGC的生成质量和效率得到了显著提升。AIGC技术与其他领域的融合创新，如虚拟现实（VR）、增强现实（AR）、混合现实（MR）等，为用户提供更为丰富和沉浸式的体验。
2.行业应用的拓展
AIGC技术的应用场景持续拓展，从传统的媒体、娱乐领域，逐渐渗透到教育、医疗、金融、法律等多个领域。例如，在教育领域，AIGC技术可以用于生成个性化的教学内容；在医疗领域，AIGC技术可以辅助医生进行诊断和治疗规划。
3.商业模式的变革
AIGC技术的发展，推动了一系列商业模式的变革。以内容创作为例，传统的以人力为主的内容创作模式，正逐渐转变为以机器为主、人机协作的内容创作模式。不仅提高了内容创作的效率，也拓宽了内容创作的边界。
​​​​​​​2.2.相关领域的发展趋势 1.区块链技术
区块链技术以其去中心化、不可篡改等特点，与AIGC技术有着天然的契合度。在未来，区块链技术有望与AIGC技术结合，为内容创作、版权保护等领域带来新的解决方案。
2.5G技术
5G技术的高带宽、低延迟特性，为AIGC技术在多个领域的应用提供了基础设施支持。例如，在虚拟现实、增强现实等领域，5G技术可以提供更为流畅和真实的体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c376507464cdc4aaac63eeb31badfa4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23fefb09a48a043c9c0c7dfedfb3b702/" rel="bookmark">
			Linux badblocks命令教程：如何检测和处理Linux磁盘的坏块(附案例详解和注意事项)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux badblocks命令介绍 badblocks是一个在Linux中用于搜索设备上坏块的命令。它通常用于搜索磁盘分区上的坏块。默认情况下，它以非破坏性只读模式运行。
Linux badblocks命令适用的Linux版本 badblocks命令在大多数Linux发行版中都可以使用，包括Debian、Ubuntu、Alpine、Arch Linux、Kali Linux、RedHat/CentOS、Fedora、Raspbian等。如果在某些Linux发行版中无法使用，通常可以通过包管理器（如apt、yum、dnf或pacman等）来安装。例如，在Debian或Ubuntu上，可以使用以下命令来安装：
[linux@bashcommandnotfound.cn ~]$ sudo apt-get install e2fsprogs 在RedHat/CentOS 7上，可以使用以下命令来安装：
[linux@bashcommandnotfound.cn ~]$ sudo yum install e2fsprogs 在RedHat/CentOS 8或Fedora上，可以使用以下命令来安装：
[linux@bashcommandnotfound.cn ~]$ sudo dnf install e2fsprogs 在Arch Linux上，可以使用以下命令来安装：
[linux@bashcommandnotfound.cn ~]$ sudo pacman -S e2fsprogs Linux badblocks命令的基本语法 badblocks命令的基本语法如下：
badblocks [-b block_size] [-i input_file] [-o output_file] [-svwnf] [-c blocks_at_once] [-d delay_factor_between_reads] [-e max_bad_blocks] [-p num_passes] [-t test_pattern [-t test_pattern [...]]] device [last_block [first_block]] 其中，device是对应设备的特殊文件（例如/dev/hdc1）。
Linux badblocks命令的常用选项或参数说明 以下是badblocks命令的一些常用选项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23fefb09a48a043c9c0c7dfedfb3b702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30043689f10aa90fad8737d232f20a63/" rel="bookmark">
			Flutter 中的 DropdownButton 小部件：全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 中的 DropdownButton 小部件：全面指南 在 Flutter 应用中，DropdownButton 是一种常用的下拉选择控件，它允许用户从一组选项中选择一个。DropdownButton 提供了一个简洁的界面，用户可以点击后展开一个下拉菜单进行选择。本文将详细介绍 DropdownButton 的用途、属性、使用方式以及一些高级技巧。
什么是 DropdownButton 小部件？ DropdownButton 是 Flutter 的 Material 组件库中的一个控件，它实现了 Material Design 中的下拉选择器。用户可以通过点击 DropdownButton 来展开一个包含多个选项的菜单，并选择其中一个选项。
如何使用 DropdownButton 使用 DropdownButton 的基本方式如下：
import 'package:flutter/material.dart'; class DropdownButtonExample extends StatefulWidget { @override _DropdownButtonExampleState createState() =&gt; _DropdownButtonExampleState(); } class _DropdownButtonExampleState extends State&lt;DropdownButtonExample&gt; { String? _selectedItem; @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: Text('DropdownButton Example'), ), body: Center( child: DropdownButton&lt;String&gt;( value: _selectedItem, onChanged: (String?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30043689f10aa90fad8737d232f20a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add820804547598cd8536cce8f475868/" rel="bookmark">
			pgsql 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些常用的 PostgreSQL (pgsql) 命令，用于在 PostgreSQL 数据库中执行各种操作：
1. 连接到 PostgreSQL 数据库 psql -U username -d database_name 这将连接到指定的数据库。您需要替换 username 为您的 PostgreSQL 用户名，database_name 为您要连接的数据库名称。
2. 退出 PostgreSQL \q 这个命令用于退出 PostgreSQL 的命令行界面。
3. 列出所有数据库 \l 这个命令用于列出 PostgreSQL 中所有的数据库。
4. 连接到指定数据库 \c database_name 这个命令用于切换到指定名称的数据库。
5. 列出所有表 \dt 这个命令用于列出当前数据库中的所有表。
6. 显示表结构 \d table_name 这个命令用于显示指定表的结构，包括列名、数据类型等。
7. 显示视图 \dv 这个命令用于显示当前数据库中的所有视图。
8. 执行 SQL 查询 SELECT column1, column2 FROM table_name WHERE condition; 这是一个简单的 SQL 查询语句示例，从表中选择特定的列，并使用条件过滤结果。
9. 创建数据库 CREATE DATABASE database_name; 这个命令用于创建一个新的数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add820804547598cd8536cce8f475868/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5b89b88bc038257cff73bd7bdc45f5/" rel="bookmark">
			【C&#43;&#43;】初识类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.初识类和对象2.类的定义3.类的访问限定符及封装3.1访问限定符3.2 封装 4.类的实例化5.类对象模型5.1 如何计算类对象的大小 6.this指针6.1隐含的this指针6.2this指针的特性 1.初识类和对象 C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。
C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成。
类的引入 C语言结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。
结构体中的函数无需再传递结构体参数，其在内部可以直接访问类中的成员
2.类的定义 在C++中，更喜欢用class代替struct
class className { //类体 //成员函数 //成员变量 }; // 一定要注意后面的分号 class为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号不能省略。
类体中内容称为类的成员：类中的变量称为类的属性或成员变量; 类中的函数称为类的方法或者成员函数。
类的两种定义方式：
声明和定义全部放在类体中，需注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。 类声明放在.h文件中，成员函数定义放在.cpp文件中，注意：成员函数名前需要加类名::(域限定符) 类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员时，需要使用 :: 作用域操作符指明成员属于哪个类域。
3.类的访问限定符及封装 3.1访问限定符 访问类中的成员：默认情况下，我们是访问不到类中的成员的
C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。
访问限定符说明
public修饰的成员在类外可以直接被访问protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止如果后面没有访问限定符，作用域就到 }，即类结束。class的默认访问权限为private，struct为public(因为struct要兼容C) 一般情况下，我们把成员函数设置为共有，将成员变量设置为私有
一道面试题：
问题：C++中struct和class的区别是什么？
解答：C++需要兼容C语言，所以C++中struct可以当成结构体使用。另外C++中struct还可以用来定义类。和class定义类是一样的，区别是struct定义的类默认访问权限是public，class定义的类默认访问权限是private。
3.2 封装 面向对象的三大特性：封装、继承、多态。
封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。
封装本质上是一种管理，让用户更方便使用类。
在C++语言中实现封装，可以通过类将数据以及操作数据的方法进行有机结合，通过访问权限来隐藏对象内部实现细节，控制哪些方法可以在类外部直接被使用。
4.类的实例化 用类类型创建对象的过程，称为类的实例化
类是对对象进行描述的，是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它； 一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量 5.类对象模型 5.1 如何计算类对象的大小 下面代码的输出结果是多少呢？ struct Stack { void Init(int capacity = 4) { //... } int* _arr; int _top; int _capacity; }; int main() { Stack st1; cout &lt;&lt; sizeof(st1) &lt;&lt; endl; cout &lt;&lt; sizeof(Stack) &lt;&lt; endl; return 0; } 结果是12，那就说明它没有计算成员函数的大小，为什么呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e5b89b88bc038257cff73bd7bdc45f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b30a39c1bc7ffcdfb1102893c036da/" rel="bookmark">
			【AI学习】简单聊聊后训练（Post-Training）的重要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近的学习，越来越领会后训练的重要性。预训练只能学到语言本身的统计概率、基础通用的语义，如果希望模型发挥更好的作用，后训练显得越来越重要。
这里，我想，可能存在这样一个逻辑，在预训练阶段，只是学习到了网络的平均水平，而通过后期的对齐和引导，模型是可以输出高于网上数据的平均水平的结果，进一步的，模型也可以自动的引导这个提升过程，就像《SELF-INSTRUCT: Aligning Language Models with Self-Generated Instructions》文章所看到的那样。
在前面，Meta推出 Llama 3 的介绍中，提到了后训练的重要性，“我们在后训练阶段投入了大量的工作，我想大家都喜欢谈论预训练，以及我们扩大了规模，使用的 GPU 数量达到了数万个，以及在预训练中使用了多少数据，但实际上，真正的关键在于后训练阶段。这就是我们目前花费大部分时间的地方，我们在这里生成了大量的人工注释，执行了大量的有监督微调（SFT），我们正在做的事情，比如拒绝采样、PPO、DPO，尝试在这些模型的可用性、人类方面的特征以及预训练中的大规模数据之间找到平衡，这就是我们如何思考这些问题的”。
恰好，今天看到两条微博，其中都提到了后训练。
微博转载一 来自微博@宝玉xp老师的微博：
OpenAI 创始人 John Schulman 访谈节选：为什么 GPT-4 比一年前更“聪明”了？主要都是后训练（Post-Training）带来的！
另外他认为，在强化学习研究领域，研究人员需要具备丰富的经验和敏锐的直觉。了解整个技术堆栈，并对各个部分充满好奇心是关键。此外，从第一性原理出发思考问题，而不仅仅依靠实验证据，也能够帮助研究人员在数据操控和环境设置方面做出更好的决策。
Dwarkesh Patel：在未来，用于训练的计算力中，预训练与后训练的比例是否会明显偏向后训练呢？
John Schulman：确实，有一些观点支持这种说法。
Dwarkesh Patel：我是说，现在这个比例非常不平衡。
John Schulman：但你可以认为，模型生成的输出质量比网上的大多数内容都要高。因此，让模型自己思考似乎更有道理，而不仅仅是训练来模仿网络上的内容。所以，我认为从第一性原理上来说，这是有说服力的。我会说，我们通过后训练取得了很多进步。因此，我不确定。所以，我希望我们会继续推动这种方法，并且可能会增加投入到后训练中的计算力。
Dwarkesh Patel：当前的 GPT-4 的 ELO 分数比最初发布的版本高出了大约 100 分。这是否全都是后训练带来的改进呢？
John Schulman：对，我会说大部分都是后训练带来的。
Dwarkesh Patel：这很有意思。
John Schulman：因此，有很多不同的改进方向。我们会考虑数据质量，数据数量，进行更多的部署和收集新数据的迭代，改变你收集的注解种类。因此，有很多因素叠加在一起。但是全部加在一起，就会带来一个相当不错的，有效的计算力提升。
Dwarkesh Patel：后训练的优化程度对于竞争优势有多大影响呢？
John Schulman：目前，我会区别公司是通过我们的模型有多大等等。那么，找出你之前提到的所有这些数据的复杂问题的公司，会占据大优势吗？
John Schulman：我认为这确实是一个优势，因为这是一个非常复杂的任务。因此，你必须有很多有技能的人来执行它。因此，存在大量的隐性知识。同时也需要大量的组织知识。我认为后训练的过程，创建一个具备人们所关心的所有功能的模型，是十分复杂的。这需要付出大量的努力，它是大量研发工作的积累。我会说这种情况在某种程度上形成了一种壁垒，要想立即启动这种模型并非易事。
Dwarkesh Patel：看起来那些正在进行最严肃的预训练努力的公司，也在进行严肃的后训练努力。因此，看起来这种模型有可能被复制或有更多的类似努力出现。
John Schulman：另外，还有一种情况使得这个壁垒并非那么明显，那就是你可以提取模型，或者复制别人的模型输出，或者使用别人的模型进行比较。我认为大公司可能并不会这样做，因为这违反了服务条款，也会损害他们的自尊心，但我预计一些规模较小的参与者可能正在这样做以便更好地起步。
Dwarkesh Patel：那些真正擅长进行这种强化学习（RL）研究的人有什么样的特质呢？我听说这种研究非常具有挑战性，但是什么样的直觉能帮助你找到操控数据和设置环境的方法呢？
John Schulman：我觉得有相当多的经验是关键。自从研究生时期以来，我一直在研究 RL 算法，涉及到数据收集、到注释过程，再到与语言模型的交互。所以，我算是涉猎了这些领域。我认为，在这类研究中表现出色的人通常对整个技术堆栈有全面的了解，并且对其中的各个部分充满好奇心。他们不仅依靠实验证据来更新自己的观点，还会从第一性原理出发思考问题。比如，假设深度学习是有效的，那么理想的收集数据的类型应该是什么，等等。
微博转载二 来自@i陆三金老师的微博：
Scale AI 创始人 Alexandr Wang 对于 OpenAI 和 Google 最近发布会的评价，他反复强调 post-training（后训练）非常重要，不过他就是做这部分数据的，并表示下周有重要发布，还请理性看待他的言论：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b30a39c1bc7ffcdfb1102893c036da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc29204957ab101dc24ed2702764585a/" rel="bookmark">
			7款读文献的AI神器，可总结分析文件、读论文必备！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、包阅 一款国内文档分析工具，可以上传文档实时分析。支持各种文件类型，如PDF、doc、docx等文件。总之选择文档上传，分分钟搞定论文、图书、文档、网页阅读，且能对文件进行快速分析。
除此之外，还有一点特别牛，你同时可以发送6个文件给他，它会自动总结全部的内容并对其分析。这点已经暴打很多市面上的软件。而且它具备了直接生成论文分析、大纲、文档对话、笔记、翻译功能，能解决绝大部分阅读难题。
使用地址：包阅AI-你的智能AI阅读助手
2、Kimi 国内一款AI模型，支持图片、word、PDF等格式的上传。目前可以实现同时上传50个文件，且并对多文件进行同时分析结果，页面也比较简洁，对于读论文来说是个不错的选择。
使用地址：Kimi.ai - 帮你看更大的世界
3、GPT学术版 GPT学术优化 (GPT Academic):支持一键润色、一键中英互译、一键代码解释、chat分析报告生成、PDF论文全文翻译功能、互联网信息聚合+GPT等等
支持上传文件并对文件进行分析，总结全文，提供图形交互界面，特别优化论文阅读/润色/写作体验，模块化设计，支持自定义快捷按钮&amp;函数插件，支持Python和C++等项目剖析&amp;自译解功能，PDF/LaTex论文翻译&amp;总结功能，支持并行问询多种LLM模型，支持清华chatglm等本地模型。且兼容复旦MOSS、llama、rwkv、盘古、newbing, claude等
学术版需要自行配置：天空蓝：图文详解：在windows中部署ChatGPT学术版
如果懒得布置可以订阅别人或使用GPT4：爱发电 · GPT学术版订阅更新
4、Humata Humata是由GPT驱动的一个AI文档文件分析、阅读、问答工具，该工具可以帮助用户：
总结长篇问答，让你学习更快，把复杂的技术论文变成简单解释的摘要。即时问答，回答与你的文档相关的难题，立即获得易于理解的答案。提高写论文速度，可根据您的文件自动创建新的paper，快速为报告、论文和各种任务生成详细的见解。 使用地址:ChatGPT for Your Data Files (需特殊网络)
5、SciSpace Copilot SciSpace Copilot是一个基于 OpenAI GPT 语言模型构建的科研论文辅助阅读理解平台。据官方介绍，收录多个学科领域2亿篇学术论文摘要信息。毕竟我也没有写论文的需求，所以论文方面的功能没怎么体验，不过用这个工具阅读文章，效果还是相当不错滴！
SciSpace Copilot可以做很多事情：
帮助研究人员寻找和组织研究文献帮助研究人员生成研究想法帮助研究人员分析研究数据帮助研究人员写作研究论文 SciSpace Copilot仍在开发中，但它已经帮助许多研究人员提高了研究效率和质量。
相比于ChatPDF和ChatDOC，SciSpace Copilot阅读文章就更加灵活了。不仅可以总结文章，提取要点，还可以根据生成的答案定位文章中的位置，并且能够单独框选某一段内容让它进行解释。当然，如果你有阅读论文需求的话，SciSpace Copilot还有很多针对性的功能，都可以去一一体验一下。
官网：https://typeset.io/ （需特殊网络）
6、通义智文 这款AI文献阅读工具，堪称良心产品。它就是阿里旗下的“通义智文”，完全免费！
最重要的是上传文档没有页数限制、也没有上传次数限制，还可以边读遍做笔记，划线翻译对话。功能太强大！
使用地址：通义智文_AI助手_文档阅读_人工智能-阿里云
7、txyz txyz接入了全球免费的学术开放平台arxiv，所以不管你是科研党，还是学生党，不论你是学医的，还是学物理、计算机的，txyz都随叫随到，且绝对专业。
你可以将自己下载好的论文，直接上传给txyz。然后点击一下每篇论文下面的chat按钮，就可以通过对话框，提任何关于这篇论文的问题，txyz也会知无不言，言无不尽。
添加图片注释，不超过 140 字（可选）
不管是专业名词、晦涩的公式，还是研究方法的拆解和评价，txyz都可以轻松帮你找到答案。并帮你分析总结出该论文的内容。
使用地址：txyz.ai - Integrate all paths to knowledge
如果可以，希望小伙伴们点赞和收藏，这是我的更新动力！
如果可以，希望小伙伴们点赞和收藏，这是我的更新动力！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940b05e1995b7496551c6bc83b70ee40/" rel="bookmark">
			Java——多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.多态概述 多态是面向对象语言三大特征之一，多态是指对象的多种形态，就是同类型的对象，表现出的不同形态。
多态的前提：有继承关系，有父类引用指向子类对象，有方法重写
多态的表现形式：父类类型 对象名称=子类对象；
1.1多态的场景应用 在一个球类信息管理系统当中，我们要去写一个方法查看各种各样球的信息
是每一种球都写一种方法查看信息呢？还是只写一种方法去查看所有的球的信息好呢？
答案肯定是只写一种
接下来简单的实现一个球类信息查看的系统
class Ball{ private int price; public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public void show(){ } } class pingpong extends Ball{ public void show(){ System.out.println("乒乓球的价格为"+getPrice()+"元"); } } class badminton extends Ball{ public void show(){ System.out.println("羽毛球的价格为"+getPrice()+"元"); } } class basketball extends Ball{ public void show(){ System.out.println("篮球的价格为"+getPrice()+"元"); } } class football extends Ball{ public void show(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/940b05e1995b7496551c6bc83b70ee40/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/355/">«</a>
	<span class="pagination__item pagination__item--current">356/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/357/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>