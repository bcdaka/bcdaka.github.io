<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186d8c843869d7a5ea66bf7e8ad511ed/" rel="bookmark">
			深入探索C语言中的结构体：定义、特性与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：大耳朵土土垚 目录 结构体的介绍结构体定义结构成员的类型结构体变量的定义和初始化结构体成员的访问结构体传参 结构体的介绍 在C语言中，结构体是一种用户自定义的数据类型，它允许开发者将不同类型的变量组合在一起，形成一个新的数据类型。结构体可以包含多个成员变量，每个成员可以是不同的数据类型，例如整型、字符型、浮点型等。
结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
结构体定义 结构体的定义使用关键字struct，后面跟随结构体的名称。
例如描述一个人：
struct Person { char name[20]; int age; float height; }; 上述代码定义了一个名为Person的结构体，它包含三个成员变量：name、age和height。name是一个字符型数组，有20个元素；age是一个整型变量；height是一个浮点型变量。
结构成员的类型 结构成员的类型可以是以下几种：
基本数据类型：包括整型（int）、浮点型（float）、字符型（char）、布尔型（bool）等。枚举类型：表示一组具有离散值的变量。结构体类型：用来定义多个不同类型的变量，形成一个新的数据类型。结构体中可以包含基本数据类型、枚举类型、数组、指针等。指针类型：表示变量的地址。数组类型：表示一组相同类型的变量。函数类型：表示函数的参数和返回值类型。 这些类型可以在结构体中作为成员类型，用于定义结构体的成员变量。
结构体变量的定义和初始化 结构体变量定义有两种方式，一种在声明时候直接定义，一种在使用时再定义：
struct Point { int x; int y; }p1; //声明类型的同时定义变量p1 //需要使用时 struct Point p2; //定义结构体变量p2 定义变量的同时初始化：
struct Point p3 = {1, 2};//定义结构体变量p3并赋值1和2 结构体嵌套初始化：
struct Node { int data; struct Point p; struct Node* next; }n1 = {10, {4,5}, NULL}; //结构体嵌套初始化 struct Node n2 = {20, {5, 6}, NULL};//结构体嵌套初始化 结构体成员的访问 通过点操作符（.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/186d8c843869d7a5ea66bf7e8ad511ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1a0458e60c5d62b1bdeb41d5cee52c/" rel="bookmark">
			【话题】AI是在帮助开发者还是取代他们
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是全栈小5，欢迎阅读小5的系列文章，这是《话题》系列文章
目录 引言AI在代码生成中的应用AI在错误检测和自动化测试中的作用对开发者职业前景的影响技能需求的变化与适应策略结论文章推荐 引言 随着人工智能（AI）技术的快速发展，生成式人工智能（AIGC）在软件开发领域正逐渐展现出其巨大潜力。从代码生成到错误检测再到自动化测试，AI工具正在以前所未有的方式影响着开发者的工作方式。然而，这种技术革新也带来了一系列关于开发者职业前景和技能需求变化的讨论，引发了对于AI到底是在帮助开发者还是取代他们的深刻思考。
AI在代码生成中的应用 生成式AI在代码生成方面展示了其强大的能力。传统上，开发者需要耗费大量时间编写重复性代码或者处理基础性任务，然而AI能够通过学习大量现有代码和最佳实践，自动生成符合需求的代码片段甚至整个模块。这不仅提高了开发效率，也减少了人为错误的可能性，使开发者能够更专注于解决复杂问题和创新性工作。
AI在错误检测和自动化测试中的作用 除了代码生成，AI在错误检测和自动化测试方面同样发挥着重要作用。通过分析代码库中的模式和历史数据，AI能够检测潜在的bug或者性能问题，并提供及时的修复建议。在自动化测试领域，AI可以根据业务逻辑和用户行为生成全面的测试用例，大大缩短了测试周期和提高了软件的质量。
对开发者职业前景的影响 尽管生成式AI为开发者带来了诸多便利，但其潜在影响也不可忽视。一些观点认为，随着AI技术的成熟和普及，传统开发者的工作可能会面临挑战，特别是那些专注于基础性、重复性工作的开发者。AI的普及可能导致行业中需求低层次开发技能的减少，而更多的需求会转向具备AI理解和应用能力的高级开发者。
技能需求的变化与适应策略 面对AI技术带来的变革，开发者需要适时调整自己的技能和学习方向。除了扎实的编码能力和算法知识外，对AI工具和技术的理解和应用能力将成为未来开发者的重要竞争优势。此外，开发者还应注重跨学科的学习，如数据科学和机器学习，以更好地与AI技术结合并创造出新的应用和解决方案。
结论 生成式人工智能在软件开发领域的应用为开发者带来了前所未有的机遇和挑战。尽管AI工具的普及可能改变传统开发者的工作方式和职业前景，但通过不断学习和适应新技术，开发者可以更好地利用AI的优势，提升自己的竞争力，并在技术变革中保持领先地位。
在未来的发展中，生成式AI将继续扮演着重要角色，成为开发者创新和提高效率的重要助手，而开发者也将在不断变化的技术环境中，发挥其独特的创造力和价值。
文章推荐 【AI应用】层出不穷的大模型产品，你怎么选？
【机器学习】通用大模型VS垂直大模型，你更加青睐哪一方？
【话题】评价GPT-4o：从革命性技术到未来挑战
【话题】开源大模型与闭源带模型你更看好哪一方
【话题】AIGC行业现在适合进入吗
【话题】你眼中的IT行业现状与未来趋势
【话题】软件开发的航海图：程序员的实用神器探秘
【话题】你用过最好用的AI工具有那些
【话题】Agent AI智能体的未来
【话题】如何看待AI技术，以及AI技术的发展现状和未来趋势
【话题】为什么选择成为了一名程序员
【话题】AI技术创业有那些机会，简单探讨下
【话题】程序员35岁会失业吗
【话题】AI大模型学习：理论、技术与应用探索
【话题】全球首位AI程序员诞生，将会对程序员的影响有多大？
【话题】2024年AI辅助研发趋势
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/901c9e1325e04fae0b6a48492a1f8f5b/" rel="bookmark">
			【C&#43;&#43;/STL】stack/queue的使用及底层剖析&amp;&amp;双端队列&amp;&amp;容器适配器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 少年的旅途应是星辰大海 🌏 📃个人主页：island1314
🔥个人专栏：C++学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
🚀前言 点击跳转到文章【【C++/STL】list容器的深度剖析及底层实现】
前面我们已经学习了list容器的相关知识，本文主要介绍STL中另外两种重要的结构，stack和queue。但是在STL中这两者并没有划分在容器范围内，而是将其称为容器适配器。
💥一、容器适配器 1、什么是容器适配器？ 适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该种模式是将一个类的接口转换成客户希望的另外一个接口。
2、STL标准库中stack和queue的底层适配？ 虽然stack和queue中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为stack和queue只是对其他容器的接口进行了包装，STL中stack和queue默认使用deque，比如：
💥二、双端队列deque的介绍 1、deque的原理介绍 deque(双端队列)：是一种双开口的"连续"空间的数据结构，双开口的含义是：可以在头尾两端进行插入和删除操作，且时间复杂度为O(1)，与vector比较，头插效率高，不需要搬移元素；与list比较，空间利用率比较高。
deque在功能上是vector和list的结合体，如图：
deque并不是真正连续的空间，而是由一小段一小段连续的buff小数组和中控数组(指针数组)构成，实际deque类似于一个动态的二维数组，其底层结构如下图所示：
小数组满了之后不扩容，而是再开辟一小段空间做buff，并且开辟buff数组时并不是从中控数组的开头开始申请的，而是在中间，头插尾插时才向两边申请。
比如：
双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器身上，因此deque的迭代器设计就比较复杂，如下图所示：
2、deque的缺陷 （1）与vector比较，deque的优势是：头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的。
（2）与list比较，其底层是连续空间，空间利用率比较高，不需要存储额外字段。
（3）但是，deque有一个致命缺陷：不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下，并且deque的中间位置的insert 和erase 也要挪动数据，效率并不高。而序列式场景中，可能需要经常遍历，因此在实际中，需要线性结构时，大多数情况下优先考虑vector和list，deque的应用并不多，而目前能看到的一个应用就是，STL用其作为stack和queue的底层数据结构。
3、为什么选择deque作为stack和queue的底层默认容器 stack是一种后进先出的特殊线性数据结构，因此只要具有push_back()和pop_back()操作的线性结构，都可以作为stack的底层容器，比如vector和list都可以；queue是先进先出的特殊线性数据结构，只要具有push_back和pop_front操作的线性结构，都可以作为queue的底层容器，比如list。但是STL中对stack和queue默认选择deque作为其底层容器，主要是因为：
(1) stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。
(2) 在stack中元素增长时，deque比vector的效率高(扩容时不需要搬移大量数据)；queue中的元素增长时，deque不仅效率高，而且内存使用率高。
结合了deque的优点，而完美的避开了其缺陷。
💥三、对于stack和queue的使用和模拟实现 1、stack和queue的使用 首先，使用stack和queue需要包含头文件&lt; satck &gt; 和 &lt; queue &gt;。
stack和queue的主要接口十分简单：
代码如下：
#include&lt;stack&gt; #include&lt;queue&gt; int main() {	//stack的使用 stack&lt;int&gt; st; st.push(1); st.push(2); st.push(3); st.push(4); while (!st.empty()) { cout &lt;&lt; st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/901c9e1325e04fae0b6a48492a1f8f5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/228c54c3fee4decfe2fd1d470429478d/" rel="bookmark">
			Stable Diffusion：最全详细图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion，作为一种革命性的图像生成模型，自发布以来便因其卓越的生成质量和高效的计算性能而受到广泛关注。不同于以往的生成模型，Stable Diffusion在生成图像的过程中，采用了独特的扩散过程，结合深度学习技术，实现了从噪声到清晰图像的逐步演化。本文将深入浅出地解析Stable Diffusion的工作原理，通过详细的图解和实例演示，带领读者全面理解这一前沿技术。
一、Stable Diffusion概览 1.1 模型起源与特点 Stable Diffusion模型源于Diffusion Probabilistic Models，这是一种通过向初始数据添加高斯噪声，然后学习逐步去除噪声以恢复原始数据的生成模型。Stable Diffusion通过优化训练过程，提高了生成效率和图像质量，同时降低了计算资源的需求，使其成为图像生成领域的一个里程碑。
1.2 主要组件 扩散过程：模型的核心，通过一系列步骤将图像从纯噪声状态逐步还原为清晰图像。反向扩散过程：学习从噪声到图像的逆向映射，是生成图像的关键。条件输入：允许模型根据特定的文本描述或其他条件生成图像，增强了生成的可控性和多样性。 二、Stable Diffusion工作原理 2.1 扩散过程 在扩散过程中，Stable Diffusion将原始图像逐渐添加噪声，直到图像完全变为随机噪声。这一过程可以表示为一系列随机变量的分布转移，即：
2.2 反向扩散过程 反向扩散过程是模型学习的重点，其目标是从噪声中逐步恢复图像。Stable Diffusion通过一个深度神经网络（通常是一个U-Net架构）学习以下条件分布：
2.3 条件生成 Stable Diffusion支持条件生成，即根据特定的输入（如文本描述）生成图像。这一特性通过在U-Net中加入额外的条件编码器实现，确保生成的图像与给定的条件相匹配。
三、Stable Diffusion图解 3.1 扩散过程图解 图中展示了一个图像从清晰状态逐渐变为噪声的过程。每一步，模型都会添加一定量的噪声，直到图像完全模糊。
3.2 反向扩散过程图解 这一图解展示了从噪声逐步恢复到清晰图像的过程。通过深度神经网络预测噪声并逐步去除，最终生成清晰的图像。
四、Stable Diffusion与其它模型的对比 4.1 与GAN的对比 稳定性：Stable Diffusion相比GAN更稳定，不易出现模式崩溃或生成质量波动。生成质量：两者均能生成高质量图像，但Stable Diffusion在保持多样性的同时，生成的图像更加一致和稳定。 4.2 与VAE的对比 灵活性：Stable Diffusion在生成图像时更具灵活性，可以更容易地控制生成过程和结果。训练难度：Stable Diffusion的训练相对简单，而VAE可能需要复杂的调优以获得良好性能。 五、Stable Diffusion的未来展望 随着技术的不断发展，Stable Diffusion模型有望在图像生成、视频合成、3D建模等多个领域展现更广泛的应用。其高效、稳定和可控的特性，将为AI生成内容带来更多的可能性，推动创意产业的革新。
六、结语 Stable Diffusion作为图像生成领域的一项突破性成果，不仅在学术界引起了轰动，也为广大开发者和创意工作者提供了强大的工具。通过本文的解析，我们不仅理解了Stable Diffusion的工作原理，还看到了它在实际应用中的巨大潜力。随着技术的不断进步，我们有理由相信，Stable Diffusion将在未来的AI生成内容领域发挥更加重要的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1685e5fbff4e81b1eee4fc1c7a057d/" rel="bookmark">
			【C语言小知识】缓冲区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓冲区 当我们使用printf()将数据显示在屏幕上，或者使用scanf()函数将数据输入到电脑里，我们是否会产生些许疑问？为何输入的字符会直接显示到屏幕上等等。这里需要介绍一个C语言中的一个关键概念——缓冲区。
当我们使用老式系统进行运行代码时，会出现这样一种情况：输入一个数据，会将一个数据先打印在屏幕上，然后再把处理过的一个数据打印再屏幕上。
例如：ii lliikkee yyoouu!!
像这样回显用户输入的字符后立即打印该字符是无缓冲（或直接）输入，即正在等待的程序可立即使用输入的字符。
而现在大部分系统在用户按下Enter键之前不会重复打印刚刚输入的字符，这种输入形式输入缓冲输入。
例如：i like you!
i like you!
用户输入的字符被收集并存储在一个被称为缓冲区的临时存储区，按下Enter键后，程序才可以使用用户输入的字符。
该图比较了缓冲输入与无缓冲输入 为什么存在缓冲输入呢？
1.首先，把若干字符作为一个快进行传输比逐个发送这些字符节约时间。
2.如果用户打错字符，可以直接通过键盘修正错误，当最后按下Enter键后，传输的是正确的输入。
但是并不是缓冲输入比较好，在某些交互式程序中同样也需要无缓冲输入。
缓冲的分类：
缓冲分为俩类，完全缓冲I\O和行缓冲I\O。
完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的缓冲区大小为512字节和4096字节。
行缓冲I\O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，即在按下Enter键后才刷新缓冲区。
一般情况下，该使用缓冲输入还是无缓冲输入？
ANSI C和后续的C标准都规定输入是缓冲的，不过最初K&amp;R把这个决定权交给编译器的编写者。
缓冲区的作用是为了提高数据传输的效率和稳定性。
缓冲区的刷新（即进行实际的I\O操作并清空缓冲区）通常会发生以下情况：
缓冲区满时执行flush语句执行endl语句关闭文件 ANSI C 决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。
如果计算机允许无缓冲输入，那么所用的 C 编译器很可能会提供一个无缓冲输入的选项。例如，许多 IBM PC 兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型通常在 conio.h 头文件中，这些函数包括用于回显无缓冲输入的 getche()函数和用于无回显无缓冲输入的 getch()函数（回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击键后对应的字符不显示）。而 Unix 系统则使用另一种不同的方式控制缓冲。
在 ANSI C 中，可以使用 setbuf()和 setvbuf()函数控制缓冲，但受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI 没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。
缓冲区是一个存储区域，用于暂存数据，以协调不同速度的设备或操作之间的数据传输。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/636dd22ba26995c8b9ddf4e288eea1cc/" rel="bookmark">
			【高性能服务器】select模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 我要成为C++领域大神
🎥系列专栏：【C++核心编程】 【计算机网络】 【Linux编程】 【操作系统】
❤️感谢大家点赞👍收藏⭐评论✍️
本博客致力于知识分享，与更多的人进行学习交流
IO多路复用就是复用一个线程，从原先一个客户端需要一个线程去调用recv询问内核数据是否已经就绪，那么多个客户端就需要多个线程，转变成现在多个客户端都用一个线程使用select/poll去统一管理，主动通知用户哪些数据已经就绪（read，write，accept等事件），所以复用了这个线程，减少了系统开销。
在客户端增加时，线程不会呈O(n)增加。
关于recv和accept工作流程 accpet通过服务端文件描述符监听socket事件，当监听到READ_EVENT事件时，说明有其他网络端向此socket发送数据，触发socket读事件（三次握手中客户端会发送数据），建立TCP连接。
recv通过客户端文件描述符监听socket事件，当监听到READ_EVENT事件，处理事件，将数据读取到用户缓冲区buffer
通过IO复用，实现监听到socket事件就绪后，直接调用accpet或recv即可，直接完成TCP连接或者数据读取，两个函数不会阻塞。
可以实现单进程一对多效果，但是没有使用并发技术
处理的业务复杂度不能过高，要在极短的时间内处理若干任务，投入二次监听
IO多路复用第一版select 实现原理 select 实现多路复用的方式是，将已连接的 Socket 都放到一个监听集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，就是通过遍历监听集合的方式进行检查。
当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。
所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。
select 使用固定长度的 BitsMap，表示文监听集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，最多只能监听1021个用户socket，因为0、1、2是标准文件描述符。
监听集合中对应的socket位码是1，表示监听次socket，为0表示不监听
在select这种I/O多路复用机制下，我们需要把想监控的文件描述集合通过函数参数的形式告诉select，然后select会将这些文件描述符集合拷贝到内核中，我们知道数据拷贝是有性能损耗的，因此为了减少这种数据拷贝带来的性能损耗，Linux内核对集合的大小做了限制，并规定用户监控的文件描述集合不能超过1024个，同时当select返回后我们仅仅能知道有些文件描述符可以读写了，但是我们不知道是哪一个，因此必须再遍历一边找到具体是哪个文件描述符可以读写了。 实现流程 核心接口 void FD_ZERO(fd_set *fdset) 初始化监听集合为0
void FD_SET(int fd,fd_set *fdset) 对set集合中fd对应位码设置为1
void FD_CLR(int fd,fd_set *fdset) 对set集合中fd对应位码设置为0
int bitcode=void FD_ISSET(int fd,fd_set *fdset) 查看fd在监听集合中是1还是0，并直接返回
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/636dd22ba26995c8b9ddf4e288eea1cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f03ffbddb65750b4242787934ad74c/" rel="bookmark">
			Linux安装部署PostgreSQL详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、版本和环境 选择要安装的版本进行下载：PostgreSQL: File Browser
我选的版本是：postgresql-14.7.tar.gz 操作系统是：CentOS-stream9
二、安装依赖包 在要安装postgresql数据库的Linux服务器（hostname：hdp001）上执行以下命令安装所需要的依赖包：
yum install -y perl-ExtUtils-Embed readline-devel zlib-devel pam-devel libxml2-devel libxslt-devel openldap-devel python-devel gcc-c++ openssl-devel cmake 三、安装postgres 1、上传安装包并将postgresql-14.7.tar.gz解压，我是将安装包传的目录/home/appview/dev_package,目录自己决定 [root@hdp001 dev_package]# cd /home/appview/dev_package/ [root@hdp001 dev_package]# ll -rw-r--r-- 1 appview appview 29070900 7月 6 16:55 postgresql-14.7.tar.gz [root@hdp001 pgsql]# pwd 2、解压压缩包 [root@hdp001 pgsql]# tar -zxvf postgresql-14.7.tar.gz # 解压过程略过了，太多了 3、进入解压后的文件夹 [root@hdp001 dev_package]# cd postgresql-14.7. [root@hdp001 postgresql-14.7.]# ls aclocal.m4 configure contrib doc HISTORY Makefile src config configure.in COPYRIGHT GNUmakefile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f03ffbddb65750b4242787934ad74c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aea56b2f04af8f3920b42631507027f/" rel="bookmark">
			在Linux环境下搭建Redis服务结合内网穿透实现通过GUI工具远程管理数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 安装Docker步骤2. 使用docker拉取redis镜像3. 启动redis容器4. 本地连接测试4.1 安装redis图形化界面工具4.2 使用RDM连接测试 5. 公网远程访问本地redis5.1 内网穿透工具安装5.2 创建远程连接公网地址5.3 使用固定TCP地址远程访问 前言 本文主要介绍如何在Linux Ubuntu系统本地部署Redis容器，并结合cpolar内网穿透工具配置公网地址实现远程访问本地数据库。
Redis作为一款高速缓存的key value键值对的数据库，在许许多多的场景中广泛使用，由于是把数据存储在内存中，所以读写效率极高。而在docker中部署Redis也非常简单，下面就来一起看看吧。
1. 安装Docker步骤 本文中使用的操作系统为Ubuntu 22.04
添加Docker源
# Add Docker's official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # Add the repository to Apt sources: echo \ "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aea56b2f04af8f3920b42631507027f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30909382df0b5de2e4f748058137abe1/" rel="bookmark">
			【C&#43;&#43;】初步认识C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 初识C++1.1 C++概念相关1.2 C++发展史及其重要性1.2.1 发展史1.2.2 重要性 2. C++关键字3. 命名空间4. 输入和输出 个人主页：C_GUIQU
归属专栏：【C++学习】
1. 初识C++ 1.1 C++概念相关 C语言是结构化和模块化的语言，适合处理较小规模的程序。
【来源】1982年，Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与C语言的渊源关系，命名为C++。
【概念】C++是基于C语言而产生的，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。
【性质】
面向对象三大特性：封装，继承，多态。 【C语言和C++的关系】
1.2 C++发展史及其重要性 1.2.1 发展史 【C++的历史版本】
1.2.2 重要性 重要性不言而喻
【4个层次】
第一个层次，C++基础 (平平常常)第二个层次，正确高效的使用C++ (驾轻就熟)第三个层次，深入解读C++ (出神入化)第四个层次，研究C++ (返璞归真) 【建议】中后期画思维导图总结。
【摘录】 最后，我说一说我的一些感受：
这些年来的对于外企和国内感受—— 国外牛B的IT公司的工程能力并不见得比国内的要强多少，但是国外那些NB的IT公司的架构和设计能力远远超过国内的公司，最可怕的是，那些有超强架构和设计能力的“老程序员们”还战斗在一线，这些战斗在一线的老鸟的能力绝对超过100个普能的新手。对年轻程序员的感受——国内新一代的程序员们太浮燥了。老实说，对于大多数人来说，如果你没有编程到30岁，你还不能成为一个“合格”的程序员。所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门。这些不合格的程序，整天BS这个不好，那个不好的，而且喜欢速成，好大喜功。我是一个奔四的人了，编程就像登山一样，越往上爬人越少，所以，在我这个年纪还有想法，对编程还有热情的人不多了，基本上都是转Manager了。其实，什么职位，Title都是虚的，公司没了什么都没了，只有技术才是硬通货。而且，越是这个年纪还在玩编程玩技术的人，其实其经验和能力都是比较强的，都是中坚力量，如果还有其它这个年纪和我一样的人，求交往。 2. C++关键字 C语言32个关键字，C++总计63个关键字。
后期学习慢慢了解。
asm do if return try continue auto double inline short typedef for bool dynamic_cast int signed typeid public break else long sizeof typename throw case enum mutable static union wchar_t catch explicit namespace static_cast unsigned default char export new struct using friend class extern operator switch virtual register const false private template void true const_cast float protected this volatile while delete goto reinterpret_cast 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30909382df0b5de2e4f748058137abe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407d553ab635f8ce1b0fed14a2aecfa4/" rel="bookmark">
			迎接AI新时代：GPT-5即将登场的巨大变革与应用前瞻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迎接AI新时代：GPT-5即将登场的巨大变革与应用前瞻 💎1. GPT-5 一年半后发布：AI新时代的来临1.1 GPT-5的飞跃：从高中生到博士生 💎2. GPT-5的潜在应用场景💎2.1 医疗诊断和健康管理💎2.2 教育领域💎2.3 商业智能💎2.4 内容创作 💎3. GPT-5及其潜在影响💎3.1 技术创新：超越语言的界限💎3.2社会影响：重塑工作与生活方式💎3.3未来趋势：AI与人类社会的共生 💎4. 如何准备迎接GPT-5💎5. 总结 🚀欢迎互三👉： 2的n次方_💎💎
💎1. GPT-5 一年半后发布：AI新时代的来临 在美国达特茅斯工程学院的采访中，OpenAI首席技术官米拉·穆拉蒂确认，GPT-5将在一年半后发布。她将GPT-4到GPT-5的飞跃比喻为从高中生到博士生的成长，这引发了对下一代大语言模型的广泛期待。随着AI技术的飞速发展，GPT-5的登场将对我们的工作和日常生活产生深远影响。本文将探讨GPT-5可能带来的新应用场景、创新可能性，并提供一些代码示例，帮助读者准备迎接这一技术变革。
1.1 GPT-5的飞跃：从高中生到博士生 穆拉蒂将GPT-4比喻为聪明的高中生，而GPT-5则将达到博士生的智力水平。尽管这种“博士级”智能仅适用于特定任务，但在这些任务中，GPT-5将展示出超越目前AI系统的能力。这意味着GPT-5将具备以下几个方面的显著提升：
更深层次的自然语言理解：GPT-5将能够理解更复杂的语言结构和上下文关系，从而提供更加精准和人性化的回答。
更高效的任务执行：GPT-5在特定任务上的执行能力将大大增强，能够在更短时间内完成更复杂的任务。
更深入的知识整合：GPT-5将能够整合来自不同领域的知识，提供跨学科的解决方案和见解。
💎2. GPT-5的潜在应用场景 💎2.1 医疗诊断和健康管理 精准诊断：GPT-5可以在分析患者病历和医学文献后，提供更加精准的诊断建议，辅助医生做出决策。这将极大提高医疗诊断的准确性和效率。
个性化健康管理：基于患者的健康数据和历史记录，GPT-5可以制定个性化的健康管理计划，帮助患者更好地管理自己的健康状况。
import openai # 设置OpenAI API密钥 openai.api_key = 'your-api-key' # 定义请求参数 patient_history = "患者，男性，45岁，既往史高血压，近日出现头痛、恶心症状。" medical_query = f"请根据以下病历提供诊断建议：{patient_history}" model = "gpt-5" # 调用API生成诊断建议 response = openai.Completion.create( model=model, prompt=medical_query, max_tokens=500, n=1, stop=None, temperature=0.7 ) # 输出生成的诊断建议 print(response.choices[0].text.strip()) 💎2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/407d553ab635f8ce1b0fed14a2aecfa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f46c6dbd872fe8aea31d666f8ca79112/" rel="bookmark">
			PostgreSQL 如何有效地处理数据的加密和解密？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用 `pgcrypto` 扩展安装 `pgcrypto` 扩展对称加密（使用 AES 算法）非对称加密（使用 RSA 算法） 二、自定义函数实现加密解密三、处理加密数据的最佳实践1. 密钥管理2. 数据备份和恢复3. 性能考虑4. 访问控制 四、结合应用层面的加密 对安全级别要求较高的项目，对敏感数据都要求加密保存。
在 PostgreSQL 中处理数据的加密和解密可以通过多种方式实现，以确保数据的保密性和安全性。
我这里提供几种常见的方法。
一、使用 pgcrypto 扩展 pgcrypto 是 PostgreSQL 中一个常用的扩展，用于提供加密和解密功能。
安装 pgcrypto 扩展 首先，需要确保 pgcrypto 扩展已安装。可以使用以下命令在数据库中安装：
CREATE EXTENSION pgcrypto; 对称加密（使用 AES 算法） 以下是使用 pgcrypto 扩展进行对称加密（AES）的示例代码：
-- 加密 SELECT encrypt('Hello World', 'y_secret_key', 'aes'); -- 解密 SELECT decrypt(encrypt('Hello World', 'y_secret_key', 'aes'), 'y_secret_key', 'aes'); 在上述示例中，'my_secret_key' 是您选择的加密密钥，用于加密和解密数据。AES 算法通常提供了较好的安全性和性能平衡。
解释：
encrypt 函数接受要加密的数据、加密密钥和加密算法作为参数，并返回加密后的结果。decrypt 函数接受加密后的结果、加密密钥和加密算法进行解密，并返回原始数据。 非对称加密（使用 RSA 算法） 使用 pgcrypto 扩展进行非对称加密（RSA）的示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f46c6dbd872fe8aea31d666f8ca79112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f51107fd5a7c7eec73b5307d4701e3/" rel="bookmark">
			【maya插件开发】vscode debug python 代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maya端 import sys import os import debugpy maya_location = "D:\\soft\\maya\\maya2022_4\\Maya2022\\bin\\mayapy.exe" debugpy.configure({'python': maya_location}) try: debugpy.listen(5678) except Exception as e: print("Port 5678 is already in use. Debugger might be already running.") print("Waiting for debugger attach") debugpy.wait_for_client() debugpy.breakpoint() print('break on this line') vscode：launch.json
{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ { "name": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f51107fd5a7c7eec73b5307d4701e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf860b5815cd3fba8bad4c701f84b8c/" rel="bookmark">
			基于自编码器的时间序列异常检测方法（以传感器数据为例，MATLAB R2021b）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尽管近年来研究者对自编码器及其改进算法进行了深入研究，但现阶段仍存在以下问题亟须解决。
1) 无监督学习模式对特征提取能力的限制与有监督学习相比，无监督学习模式摆脱了对样本标签的依赖、避免了人工标注的困难，但也因此失去了样本标签的辅助，标签信息难以有效应用于特征提取中，使自编码器性能与有监督学习存在一定差距。因此，研究半监督或有监督条件下的自编码器，合理运用标签信息提升自编码器特征提取能力，是一个需要重点关注与解决的问题。针对此问题，一方面可以通过在自编码器输入层或输出层中直接添加样本标签，同时重构输入样本及其标签，强迫自编码器在编码与解码过程中考虑到标签损失，使提取的特征更加符合不同样本的类本质。另一方面，可以通过在损失函数上添加暗含标签信息的类内离散度或类间离散度正则化项，在最小化损失函数的过程中，减少抽象特征的类内距离，增加类间距离，增强抽象特征的类可区分性，提升自编码器的特征提取能力，使抽象特征更适用于分类任务。
2) 硬件要求高，训练时间长
复杂的网络结构依赖大量的训练样本，以自编码器为代表的深度学习模型具有较高的时空复杂度，需要消耗巨大的计算与存储资源，这对硬件设备提出了更高要求，往往导致训练时间过长。针对此问题，一方面可以将模型压缩技术应用于自编码器中，采用剪枝算法剔除冗余节点或通道，实现网络结构的精简，或对权值进行稀疏化，抑制部分神经节点，完成对网络参数的压缩。另一方面可以研究轻量化自编码器算法，借鉴ELM-AE算法，对自编码器的训练方式进行改进，减少参数迭代微调次数，提升算法训练效率。此外，还可以通过研究分布式优化算法来降低模型的计算复杂度，或研究并行计算方法以充分利用现有计算资源。这些方法有助于降低自编码器的结构复杂度，降低软硬件要求，减少训练时间。
3) 随机初始化引入额外噪声
目前，绝大多数自编码器及其改进算法对网络参数均采用随机初始化，这不可避免地引入了额外噪声，影响算法的收敛速度与泛化性能。因此，如何有效地进行网络初始化是一个值得深入研究的问题。针对此问题，一方面可以通过在损失函数中添加 L1 或 L2 范数正则化项，以降低随机初始化导致的噪声影响，另一方面可以采用Glorot 初始化方法、He初始化方法等其他改进初始化方法，在缓解噪声影响的同时，使自编码器的训练过程更加稳定，避免出现梯度消失或爆炸现象。
4) 难以适应小样本条件，易产生过拟合
自编码器及其深度结构由于模型结构复杂，需要大量样本进行训练，在小样本条件下训练自编码器极易产生过拟合，进而降低模型泛化性能。因此小样本条件已成为制约自编码器应用的关键因素。
鉴于此，采用普通的自编码器对传感器时间序列数据进行异常检测，运行环境为MATLAB R2021B。
% Loop through data points (the anomaly occurs somewhere around 1350) for i = 1000:1500 % Take a frame of data data = faultydata(i:i+99); % Predict with autoencoder yhat = predict(autoenc,data); % Calculate error losses = [losses;sqrt(sum((yhat - data).^2))]; % After first frame, only add one data point to the plot if j &gt; 1 yhat = yhat(end); data = data(end); end % Update data to be plotted dataall = [dataall;[data yhat]]; % Plot p1(1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf860b5815cd3fba8bad4c701f84b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71c2ddc2417786404536d8894169626/" rel="bookmark">
			Linux系统下虚拟机中安装（搭建）mysql的详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动虚拟机 ①打开VMware、MobaXterm，启动虚拟机集群；
②上传mysql的rpm安装包至linux系统下目录（只需有一台安装，我们在第一台虚拟机上安装）；
2、检查mysql的安装环境 ①输入代码，检查是否存在 mariadb：
rpm -qa | grep mariadb ②如图所示查询到mariadb，需要先进行卸载：
rpm -e --nodeps mariadb-libs ③再次输入命令 rpm -qa | grep mariadb 进行检查，没有出现mariadb即为ok；
3、安装mysql的rpm包 ①进入mysql压缩包所在目录:
cd /opt/install_packages/ ②解压到当前目录：
tar -xf mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar ③第一步安装common，如图所示即为成功：
rpm -ivh /opt/install_package/mysql-community-common-5.7.28-1.el7.x86_64.rpm 第二步安装libs：
rpm -ivh /opt/install_package/mysql-community-libs-5.7.28-1.el7.x86_64.rpm --nodeps --force 第三步安装libs-compat：
rpm -ivh /opt/install_package/mysql-community-libs-compat-5.7.28-1.el7.x86_64.rpm 第四步安装client：
rpm -ivh /opt/install_package/mysql-community-client-5.7.28-1.el7.x86_64.rpm 第五步安装server： rpm -ivh /opt/install_package/mysql-community-server-5.7.28-1.el7.x86_64.rpm --nodeps --force ④安装完成，删除rpm包： rm -rf *.rpm 4、mysql已安装完成，为其更改配置 第一步、删除/var/lib/mysql 目录下所有内容 ①进入配置文件目录： cd /etc/ ②编辑配置文件： vim my.cnf
③复制如图所示目录： /var/lib/mysql 输入：q退出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a71c2ddc2417786404536d8894169626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f53230ca56f5126a6bbfed6ec406b546/" rel="bookmark">
			AIGC专栏12——EasyAnimateV3发布详解 支持图&amp;文生视频 最大支持960x960x144帧视频生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC专栏12——EasyAnimateV3发布详解 支持图&amp;文生视频 最大支持960x960x144帧视频生成 学习前言项目特点生成效果相关地址汇总项目主页Huggingface体验地址Modelscope体验地址源码下载地址 EasyAnimate V3详解技术储备Diffusion Transformer (DiT)Hybrid Motion ModuleU-VITLora 算法细节算法组成Slice VAEHybrid Motion Module图生视频技术路线 项目使用项目启动文生视频图生视频超长视频生成 学习前言 研究了好长时间的文生视频，EasyAnimate到了V3版本，我们将vae修改从MagVIT替换成了Slice VAE，同时支持图生视频，扩大了生成的分辨率。
现在EasyAnimate支持 图 和 文 生视频 同时最大支持960x960 144帧的视频生成，FPS为24，另外通过图生视频的能力，我们还可以进行视频续写，生成无限长视频。
本文主要进行EasyAnimateV3的算法详解，并且介绍一下EasyAnimateV3的使用。
项目特点 支持 图 和 文 生视频；支持 首尾图 生成视频最大支持720p 144帧视频生成；最低支持12G显存使用（3060 12G可用）；无限长视频生成；数据处理到训练完整pipeline代码开源。 生成效果 EasyAnimateV3的生成效果如下，分别支持图生视频和文生视频。
通过图生视频的能力，我们还可以进行视频续写，生成无限长视频。
下面是一些比较好，有意思的生成结果，通过图生视频实现。
人像：
动物：
火焰：
水：
名画：
其它：
相关地址汇总 项目主页 https://easyanimate.github.io/
Huggingface体验地址 https://modelscope.cn/studios/PAI/EasyAnimate/summary
Modelscope体验地址 https://huggingface.co/spaces/alibaba-pai/EasyAnimate
源码下载地址 https://github.com/aigc-apps/EasyAnimate
感谢大家的关注。
EasyAnimate V3详解 技术储备 Diffusion Transformer (DiT) DiT基于扩散模型，所以不免包含不断去噪的过程，如果是图生图的话，还有不断加噪的过程，此时离不开DDPM那张老图，如下：
DiT相比于DDPM，使用了更快的采样器，也使用了更大的分辨率，与Stable Diffusion一样使用了隐空间的扩散，但可能更偏研究性质一些，没有使用非常大的数据集进行预训练，只使用了imagenet进行预训练。
与Stable Diffusion不同的是，DiT的网络结构完全由Transformer组成，没有Unet中大量的上下采样，结构更为简单清晰。
在EasyAnimateV3中，我们设计了一个独特的混合Motion Module加入到DiT中，在Motion Module中引入了全局信息，借助DIT的强大生成能力进行视频生成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f53230ca56f5126a6bbfed6ec406b546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ea7114d918713bcbca8f62ce6f90d9/" rel="bookmark">
			【学习笔记】程序设计竞赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序设计竞赛 文章目录 程序设计竞赛0x00 基本操作指南0x01 算法分析0x02 STL和基本数据结构栈队列集合map 0x03 排序插入排序归并排序（Merge Sort)快速排序 0x04 搜索技术BFSDFS回溯与剪枝 深度迭代ID A*A star双向广搜 0x05 递推方程0x06 高级数据结构并查集二叉树二叉搜索树退化树Treap树（堆）伸展树Splay线段树树状数组 0x07 分治法*一般方法求最大最小元二分搜索排序问题选择问题斯特拉森 0x08 动态规划（Dynamic Programming，DP）*定义硬币组合0/1 背包问题滚动数组最短路径问题最长公共子序列（LCS）最少拦截问题 =&gt; LIS 最长递增子序列矩阵连乘问题 0x09 基础语法0x10 二分答案概念练习整数域二分实数域二分 0x11 贪心法（Greedy）*导言背包问题0/1 背包问题一般背包问题 活动安排问题最佳合并模式 0x12 数论质数快速幂矩阵快速幂约数扩欧算法 0x13 图论基本概念无向图和有向图的连通性 0x14 回溯法*基本概念涂色问题4/n-皇后问题0/1背包问题 0x15 分支限界法*4-皇后问题 0x16 优先队列 0x00 基本操作指南 输入的结束,推荐使用下面的非~：位运算符，按位取反；只有当x值为-1时（-1的补码：11111111），~x的值才为0
while(~scanf("%d%d", &amp;a, &amp;b)) 指定数据个数结束，提高程序编写效率
int main(){ int n, a, b; scanf("%d", &amp;n); while(n -- ){ } } 以特定元素作结束符，以读取到0结束为例
while(~scanf("%d", &amp;n) &amp;&amp; n) 测试的两种方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ea7114d918713bcbca8f62ce6f90d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c1f2eff839c3331d378058090f0bc6/" rel="bookmark">
			Java - JDK17语法新增特性（如果想知道Java - JDK17语法新增常见的特性的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Java在2021年发布了最新的长期支持版本：JDK 17。这个版本引入了许多新的语法特性，提升了开发效率和代码可读性。本文将简要介绍一些常见的新特性，帮助开发者快速掌握并应用于实际开发中。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
1.yield关键词 ——先让我们来了解一下yield关键词的作用：
yield关键字，用于增强switch表达式，使其能够返回值。yield允许switch表达式在不同的分支中返回特定的值，并将其赋给变量。
先让我们来看一个正常的switch的例子：
public class Test { public static void main(String[] args) { String data = "one"; int result = 0; // 接收数据的返回值 switch (data) { case "one": result = 1; // 为result重新赋值 break; case "two": result = 2; // 为result重新赋值 break; default: result = -1; // 为result重新赋值 break; } System.out.println(result); } } 代码分析：
定义类和主方法：代码定义了一个名为Test的类，并包含一个main方法，这是程序的入口点。
初始化变量：声明并初始化了两个变量，data和result。data被赋值为字符串"one"，result被初始化为0。
switch语句：
根据data的值进行判断。
如果data的值是"one"，则执行result = 1;，并通过break跳出switch语句。
如果data的值是"two"，则执行result = 2;，并通过break跳出switch语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c1f2eff839c3331d378058090f0bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb58269c4b52c447eb7976f117811971/" rel="bookmark">
			超级好用的java http请求工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kong-http 基于okhttp封装的轻量级http客户端 使用方式 Maven
&lt;dependency&gt; &lt;groupId&gt;io.github.kongweiguang&lt;/groupId&gt; &lt;artifactId&gt;kong-http&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; Gradle
implementation 'io.github.kongweiguang:kong-http:0.1' Gradle-Kotlin
implementation("io.github.kongweiguang:kong-http:0.1") 简单介绍 请求对象 public class ObjTest { @Test void test1() throws Exception { //自定义请求创建 Req.of().method(Method.GET).url("http://localhost:8080/get"); //基本的http请求 Req.get("http://localhost:8080/get"); Req.post("http://localhost:8080/post"); Req.delete("http://localhost:8080/delete"); Req.put("http://localhost:8080/put"); Req.patch("http://localhost:8080/patch"); Req.head("http://localhost:8080/head"); Req.options("http://localhost:8080/options"); Req.trace("http://localhost:8080/trace"); Req.connect("http://localhost:8080/connect"); //特殊http请求 //application/x-www-form-urlencoded Req.formUrlencoded("http://localhost:8080/formUrlencoded"); //multipart/form-data Req.multipart("http://localhost:8080/multipart"); //ws协议请求创建 Req.ws("http://localhost:8080/ws"); //sse协议请求创建 Req.sse("http://localhost:8080/sse"); } } url请求地址 url添加有两种方式，可以混合使用，如果url和构建函数里面都有值，按构建函数里面为主
直接使用url方法 public class UrlTest { @Test void test1() throws Exception { final Res res = Req.get("http://localhost:8080/get/one/two").ok(); System.out.println("res = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb58269c4b52c447eb7976f117811971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278b26b193941aee8f14fbaca10fb096/" rel="bookmark">
			【机器学习】基于密度的聚类算法：DBSCAN详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 基于密度的聚类算法：DBSCAN详解引言DBSCAN的基本概念点的分类聚类过程 DBSCAN的参数DBSCAN的优势DBSCAN的局限性实践案例数据准备应用DBSCAN可视化结果 结论 基于密度的聚类算法：DBSCAN详解 引言 在数据科学和机器学习领域中，聚类是一种常见的无监督学习技术，用于发现数据集中的自然分组或结构。传统的聚类算法，如K-means，依赖于预定义的簇数量和球形簇假设，这限制了它们在复杂数据集上的表现。相比之下，基于密度的聚类算法，尤其是DBSCAN（Density-Based Spatial Clustering of Applications with Noise），能够识别任意形状的簇，并能有效地处理噪声点。本文将深入探讨DBSCAN的工作原理、参数选择、优势与局限性，以及其在实际应用中的表现。
DBSCAN的基本概念 点的分类 在DBSCAN中，数据点被分为三类：
核心点：在一个指定半径内（Eps）至少有MinPts个邻居点。边界点：虽然它自身不是核心点，但位于某个核心点的Eps邻域内。噪声点：既不是核心点也不是边界点。 聚类过程 DBSCAN从数据集中随机选取一个未访问的点开始，如果该点是核心点，则它和它的所有直接可达的点形成一个簇。如果一个点既不是核心点也不是边界点，则标记为噪声点。这一过程会重复进行，直到所有点都被访问过。
DBSCAN的参数 DBSCAN有两个关键参数：Eps（ε）和MinPts。
Eps：定义了邻域的大小，即两个点被认为是“接近”的最大距离。MinPts：在Eps邻域内至少需要的点数来定义一个核心点。 正确选择这两个参数对于DBSCAN的成功至关重要。通常，Eps可以通过计算所有点之间的平均距离来估计，而MinPts则可以根据数据的维度和稀疏性来确定。
DBSCAN的优势 处理任意形状的簇：DBSCAN不需要簇具有球形或凸形，可以识别出任意形状的簇。自动检测噪声：通过定义核心点和边界点，DBSCAN能够有效地识别并分离噪声点。无需预定义簇的数量：与K-means等算法不同，DBSCAN不需要事先知道簇的数量。
DBSCAN的局限性 对参数敏感：不合适的Eps和MinPts值可能导致聚类效果不佳。处理高维数据的挑战：在高维空间中，由于“维度灾难”，点之间的距离变得不那么有意义，导致DBSCAN性能下降。对变量尺度敏感：特征之间的尺度差异可能会影响聚类结果。 实践案例 数据准备 首先，我们需要一个数据集。可以使用Python的scikit-learn库生成一个包含多个簇的数据集。
from sklearn.datasets import make_moons X, _ = make_moons(n_samples=300, noise=0.05) 应用DBSCAN 使用sklearn.cluster.DBSCAN来应用算法。
from sklearn.cluster import DBSCAN dbscan = DBSCAN(eps=0.3, min_samples=10).fit(X) 可视化结果 利用matplotlib库可视化聚类结果。
import matplotlib.pyplot as plt plt.scatter(X[:,0], X[:,1], c=dbscan.labels_) plt.show() 结论 DBSCAN作为一种基于密度的聚类算法，为处理复杂数据集提供了一种强大的工具。通过合理选择参数，它能够有效地识别数据中的自然分组，即使在存在噪声的情况下也能保持良好的性能。然而，其对参数的选择敏感性和在高维数据上的局限性也是在实际应用中需要注意的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/278b26b193941aee8f14fbaca10fb096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704b4b900ffcaa710dbfbdea7d12de30/" rel="bookmark">
			Spring Boot中的API文档生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot中的API文档生成
大家好，我是免费搭建查券返利机器人省钱赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！
一、为什么需要API文档生成？
在现代的软件开发中，良好的API文档是团队协作和系统集成的关键。API文档不仅提供了对外部开发人员使用你的API的指导，还在团队内部提供了清晰的接口定义和使用说明。Spring Boot作为一个流行的Java开发框架，提供了多种方式来生成和管理API文档，本文将介绍其中的一些方法和最佳实践。
二、使用Swagger生成API文档
Swagger是一个流行的API文档生成工具，它可以自动化地从Spring Boot应用程序中的代码生成API文档，并提供一个交互式的UI界面来测试API。以下是在Spring Boot中集成Swagger的步骤：
添加Swagger依赖
在Spring Boot项目的pom.xml文件中添加Swagger依赖：
&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; 配置Swagger
创建一个配置类来启用Swagger，并配置基本信息：
package cn.juwatech.apidoc.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage("cn.juwatech")) .paths(PathSelectors.any()) .build(); } } 上述配置指定了扫描的基础包为cn.juwatech，并且将所有的路径都包含在API文档中。
访问Swagger UI
启动Spring Boot应用程序后，访问以下URL可以查看生成的API文档和Swagger UI：
http://localhost:8080/swagger-ui/index.html Swagger UI提供了一个友好的界面，可以浏览和测试每个接口，展示了接口的输入参数、输出参数以及响应码等信息。
三、其他选项
除了Swagger外，还有一些其他的API文档生成工具和框架可以在Spring Boot中使用，例如：
Spring RestDocs：结合单元测试，从测试代码中生成API文档。OpenAPI Generator：生成符合OpenAPI（Swagger）规范的文档。Postman：虽然不是生成文档的工具，但可以通过导出功能生成API文档。 每种工具都有其适用的场景和优势，开发者可以根据项目的需求选择合适的工具来生成和管理API文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704b4b900ffcaa710dbfbdea7d12de30/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/187/">«</a>
	<span class="pagination__item pagination__item--current">188/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/189/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>