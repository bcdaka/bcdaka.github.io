<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ed0671cd8602be08c13e876a180093/" rel="bookmark">
			WPF窗体动态效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在浏览网页的时候，发现现在很多网页都采用这种效果。看起来很炫。
效果如下：
已经实现很久了，一直没写出来。今天突然想到，写出来分享一下
原理比较简单，就是在Window里面放一个MediaElement控件，播放视频就行
1、首先需要定义Window样式 如果使用 WindowStyle="None"属性再手动实现窗体效果，那窗体是没有阴影、标题栏，也没有动画效果，所以需要使用WindowChrome类来自定义窗体
WindowChrome类介绍WindowChrome 类 (System.Windows.Shell) | Microsoft Learn
一、新建一个WPF工程，命名为DynamicWindow 二、添加资源字典WindowStyle.xaml，用于自定义窗体样式 输入以下代码
&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:local="clr-namespace:DynamicWindow"&gt; &lt;Style x:Key="CaptionNormalButtonStyle" TargetType="{x:Type Button}"&gt; &lt;Setter Property="Focusable" Value="False" /&gt; &lt;Setter Property="Background" Value="Transparent" /&gt; &lt;Setter Property="BorderBrush" Value="Transparent" /&gt; &lt;Setter Property="BorderThickness" Value="1" /&gt; &lt;Setter Property="HorizontalContentAlignment" Value="Center" /&gt; &lt;Setter Property="VerticalContentAlignment" Value="Center" /&gt; &lt;Setter Property="Template"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType="{x:Type Button}"&gt; &lt;Grid&gt; &lt;Rectangle x:Name="TitleButtonBackground" Width="40" Height="40" Fill="Silver" Opacity="0" /&gt; &lt;Border x:Name="ButtonBorder" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}" Background="{TemplateBinding Background}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72ed0671cd8602be08c13e876a180093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c294943d678b5aef251f6f6fd2f2863c/" rel="bookmark">
			【SQL Server】在 SSMS 中 使用 生成 SQL 脚本 方式 实现 数据库 备份 / 还原 ( 数据备份操作 - 生成 SQL 脚本 | 数据还原操作 - 执行 SQL 脚本 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、SQL Server 数据库备份简介1、SQL Server Management Studio 简介2、数据备份操作 - 生成 SQL 脚本3、数据还原操作 - 执行 SQL 脚本4、生成数据库表创建语句 一、SQL Server 数据库备份简介 1、SQL Server Management Studio 简介 SSMS 全称 " SQL Server Management Studio " , 是 由 Microsoft 开发的一款集成式环境 , 用于管理 Microsoft SQL Server 的数据库 ;
SSMS 是 SQL Server 的主要管理工具之一 , 提供了丰富的功能和工具 , 帮助开发人员和数据库管理员进行数据库管理、查询、优化和开发工作 ;
本篇博客介绍如何使用 SSMS 进行数据库备份 ;
使用的原理是 将数据库中的 数据 生成为 SQL 脚本 ( 几万条 SQL 语句 ) , 还原数据库的时候 , 先 TRUNCATE 清空表 , 然后再执行上述生成的 SQL 脚本 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c294943d678b5aef251f6f6fd2f2863c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e5f0b0fe42d88724b977ca020eb158/" rel="bookmark">
			在 CentOS 8.2.2004 上部署 ELK 栈实现日志归集20240813
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 CentOS 8.2.2004 上部署 ELK 栈实现日志归集 在现代分布式系统中，日志的集中管理和分析至关重要。ELK（Elasticsearch, Logstash, Kibana）是一个强大的日志处理和分析平台，能够帮助我们实现日志的集中管理。在本文中，我将详细介绍如何在 CentOS 8.2.2004 环境下部署 ELK 栈，并在 CentOS 6.6 服务器上使用 Filebeat 收集日志。
环境概述 日志归集服务端: CentOS 8.2.2004Java 应用服务器: CentOS 6.6日志收集工具: Filebeat日志处理和可视化工具: Elasticsearch, Logstash, Kibana ELK 栈及 Filebeat 组件介绍 Elasticsearch: Elasticsearch 是一个分布式搜索和分析引擎。它在日志归集中起到了日志数据存储和快速检索的核心作用。日志数据被发送到 Elasticsearch 进行索引，随后可以通过 Kibana 快速搜索和可视化。
Logstash: Logstash 是一个数据处理管道，能够从多种来源收集数据、解析并进行过滤，然后将处理后的数据发送到 Elasticsearch。它在日志归集中充当数据转换和处理的角色，可以根据需要对日志数据进行丰富的过滤和解析操作。
Kibana: Kibana 是一个开源数据可视化工具，专门为与 Elasticsearch 配合使用而设计。它为日志数据提供了图形化的用户界面，可以方便地进行搜索、分析和可视化展示。在日志归集中，Kibana 是前端展示和分析日志数据的主要工具。
Filebeat: Filebeat 是一个轻量级的日志收集器，安装在日志来源服务器上（如 Java 应用服务器）。它负责监控日志文件并将日志数据发送到 Logstash 或 Elasticsearch。在日志归集中，Filebeat 是日志数据从来源服务器传输到日志处理平台的入口。
部署步骤概述 在 CentOS 8 上安装和配置 ELK 栈
安装 Java安装并配置 Elasticsearch安装并配置 Kibana安装并配置 Logstash 在 Java 应用服务器（CentOS 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e5f0b0fe42d88724b977ca020eb158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d128b88979e344ea7042cf2717ff9bf2/" rel="bookmark">
			信奥C&#43;&#43;，输入一个n*m的矩阵，在输入一个变量s，如果s==0,则水平翻转矩阵，否则垂直翻转矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		属于信奥题目，具体解法如下。已经通过调试，欢迎使用。
有更有解法欢迎在评论区沟通，谢谢！
#include &lt;iostream&gt;
using namespace std;
int main(){
int m,n;
cin&gt;&gt;m&gt;&gt;n;
int matrix[100][100];
for(int i=0;i&lt;m;i++){
for(int j=0;j&lt;n;j++){
cin&gt;&gt;matrix[i][j];
}
}
int s;
cin&gt;&gt;s;
if(s==0){
for(int i=m-1;i&gt;=0;i--){
for(int j=0;j&lt;n;j++){
cout&lt;&lt;matrix[i][j]&lt;&lt;" ";
}
cout&lt;&lt;endl;
}
}else{
for(int i=0;i&lt;m;i++){
for(int j=n-1;j&gt;=0;j--){
cout&lt;&lt;matrix[i][j]&lt;&lt;" ";
}
cout&lt;&lt;endl;
}
}
return 0;
}
运行校验结果如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfefd6bc286cfe072ad03fc5aae73214/" rel="bookmark">
			【初阶数据结构】通讯录项目（可用作课程设计）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述1. 通讯录的效果2. SeqList.h3. Contact.h4. SeqList.c5. Contact.c6. test.c 概述 通讯录项目是基于顺序表这个数据结构来实现的。如果说数组是苍蝇小馆，顺序表是米其林的话，那么通讯录就是国宴。
换句话说，通讯录就是顺序表中存储结构体数据的。
那我在这里就给出所有的代码，具体细节这里就不再多说了，代码中都有注释。需要的可以自己复制粘贴。
1. 通讯录的效果 至于功能6大家可以执行测试。
下面，我将分文件展示每个文件的所有代码，有需要的读者可以自行的拷贝。
2. SeqList.h #pragma once #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; #include"Contact.h" typedef PeoInfo SLDataType; typedef struct SeqList { SLDataType* arr; int size; //有效的数据个数 int capacity; //空间大小 }SL; //打印顺序表中的数据 void SLPrint(SL s); //顺序表的初始化 void SLInit(SL* ps); //顺序表的销毁 void SLDestory(SL* ps); //尾插 void SLPushBack(SL* ps, SLDataType x); //头插 void SLPushFront(SL* ps, SLDataType x); //尾删 void SLPopBack(SL* ps); //头删 void SLPopFront(SL* ps); //指定位置之前插入数据 void SLInsert(SL* ps, int pos, SLDataType x); //删除指定位置的数据 void SLErase(SL* ps ,int pos); //找到指定位置的数据 int SLFind(SL* ps, SLDataType x); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfefd6bc286cfe072ad03fc5aae73214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05db4bc73bd1729837501d86f4b97b3b/" rel="bookmark">
			How to import openai package using jupyter notebook?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：如何在 Jupyter Notebook 中导入 openai 包？
问题背景： I am getting the below error message when importing openai as ai using google jupyter notebook:
当我在 Google Jupyter Notebook 中导入 openai 并将其命名为 ai 时，出现了以下错误消息：
ImportError Traceback (most recent call last) &lt;ipython-input-9-3f86bb4abbfc&gt; in &lt;module&gt; ----&gt; 1 import openai as ai /opt/anaconda3/lib/python3.8/site-packages/openai/__init__.py in &lt;module&gt; 4 5 import os as _os ----&gt; 6 from typing_extensions import override 7 8 from . import types ImportError: cannot import name 'override' from 'typing_extensions' (/opt/anaconda3/lib/python3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05db4bc73bd1729837501d86f4b97b3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f76d39f9b829335284d1356514be2d4/" rel="bookmark">
			java map 快速根据value排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中Map通过value进行排序(value类型可以是字符串string)
从map中取出最大或最小value值对应的key值
JAVA对Map按Value排序
主要思路：将待排序Map中的所有元素置于一个列表中，接着使用Collections的一个静态方法 sort(List list, Comparator&lt;? super T&gt; c) 来排序列表，同样是用比较器定义比较规则。排序后的列表中的元素再依次装入Map，为了肯定的保证Map中元素与排序后的List中的元素的顺序一致，使用了LinkedHashMap数据类型。
//Map根据value进行排序 public static Map&lt;String, Integer&gt; valueUpSort(Map&lt;String, Integer&gt; map) { //map不能为空 if (map == null || map.isEmpty()) { return null; } //定义一个LinkedHashMap Map&lt;String, Integer&gt; sortedMap = new LinkedHashMap&lt;String, Integer&gt;(); List&lt;Map.Entry&lt;String, Integer&gt;&gt; entryList = new ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet()); //比较器 Collections.sort(entryList, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() { @Override public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) { //降序 return o2.getValue().compareTo(o1.getValue()); //升序 // return o2.getValue().compareTo(o1.getValue()); } }); Iterator&lt;Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f76d39f9b829335284d1356514be2d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53007a30bb43ad2a4ee37c9e21bb3db/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(080)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
331、pandas.Series.str.repeat方法
331-1、语法
331-2、参数
331-3、功能
331-4、返回值
331-5、说明
331-6、用法
331-6-1、数据准备
331-6-2、代码示例
331-6-3、结果输出
332、pandas.Series.str.replace方法
332-1、语法
332-2、参数
332-3、功能
332-4、返回值
332-5、说明
332-6、用法
332-6-1、数据准备
332-6-2、代码示例
332-6-3、结果输出
333、pandas.Series.str.rfind方法
333-1、语法
333-2、参数
333-3、功能
333-4、返回值
333-5、说明
333-6、用法
333-6-1、数据准备
333-6-2、代码示例
333-6-3、结果输出
334、pandas.Series.str.rindex方法
334-1、语法
334-2、参数
334-3、功能
334-4、返回值
334-5、说明
334-6、用法
334-6-1、数据准备
334-6-2、代码示例
334-6-3、结果输出
335、pandas.Series.str.rjust方法
335-1、语法
335-2、参数
335-3、功能
335-4、返回值
335-5、说明
335-6、用法
335-6-1、数据准备
335-6-2、代码示例
335-6-3、结果输出
一、用法精讲 331、pandas.Series.str.repeat方法 331-1、语法 # 331、pandas.Series.str.repeat方法 pandas.Series.str.repeat(repeats) Duplicate each string in the Series or Index. Parameters: repeats int or sequence of int Same value for all (int) or different value per (sequence).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c53007a30bb43ad2a4ee37c9e21bb3db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdb159544cf7fcfc9af702ad305a14e/" rel="bookmark">
			重修设计模式-创建型-原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重修设计模式-创建型-原型模式 原型模式就是利用已有对象（原型）通过拷贝方式来创建对象的模式，达到节省对象创建时间的目的。适用于对象创建成本较大，且同一类的不同对象之间差别不大的场景。
比如一个对象中的数据需要经过复杂计算才能得到（如排序），或者对象是从网络、文件系统等通过IO读取的，这种情况下就可以用原型模式快速拷贝出一个新对象来使用，而不是再经过复杂计算或读取 IO 来创建对象。
原型模式的核心就是对象的拷贝，且有浅拷贝和深拷贝的区别。
浅拷贝：只会复制基本类型的数据和引用对象的内存地址，不会递归的拷贝引用对象本身，比如 Java 中 Object 的 clonse() 方法。深拷贝：不仅复制基本类型的数据，也会拷贝引用类型的对象（会开辟新的内存空间，并将新开辟的内存地址引用给新对象），从而得到一份完全独立的对象。 Kotlin 中 data class 的 copy() 方法，或 Java 中 Object 的 clone() 方法都是浅拷贝的实现，下面验证一下：
data class User(var name: String, var age: Int, val address: Address): Cloneable { public override fun clone(): Any { return super.clone() } } data class Address(var street: String, var city: String) : Cloneable { override fun clone(): Any { return super.clone() } } 测试 copy() 和 clone() 方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdb159544cf7fcfc9af702ad305a14e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839d05c6e0c8494fdaaf1ea14771facb/" rel="bookmark">
			comfyui入门｜超详细安装教程（汉化&#43;管理器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天我给大家分享的是怎么安装comfyUI。
网上安装comfyui的教程有很多，但是说的有点偏复杂了，特别是安装节点的时候，其实没那么难，这篇文章我就给大家分享下如何快速安装comfyui及各个节点的安装卸载。
其实刚开始我也摸索了很久，遇到很多问题，我把遇到的问题都给大家整理好了，继续往下看；
本次教程主要针对windows的小伙伴，下一篇文章，我会专门出一期mac系统的安装教程。
本篇文章主要分为三大板块内容：
comfyui软件安装
comfyui节点管理器安装
comfyui汉化方法
——🔋——
comfyui软件安装 安装comfyui主要有两种方式，分别是：
官方安装
客户端安装
这两种方法各有优势，大家选择一种即可。
首先介绍第一种安装：官方安装
第一步：打开github官方网站：🔗https://github.com/
所有的AI设计工具，模型和插件，都已经整理好了，👇获取~ 第二步：
搜索输入 comfyui，找到第一个条目“comfyanonymous/ComfyUI”，点击打开
第三步：下滑找到Direct link to download“，点击即可下载
第四步：下载完成之后，解压到当前文件夹，框选的四个文件分别对应的是：
**comfyui：**最关键的文件夹，所有的模型、控制节点等都要放在里面；
run_cpu.bat: 用电脑的cpu运行
**run_nvidia_gpu.bat：**用电脑的gpu运行
**update:**版本升级
大多数情况下点击run_nvidia_gpu.bat就可以运行了
用mac电脑代替演示，内容是一样的哦。
运行的初次界面如下：
——🔋——
其次介绍第二种安装：客户端安装
这里推荐秋叶的comfyui一键启动，他的安装包里面已经配置好了基本的常用模型和节点，对于小白用户更加友好，点击“一键启动”就可以直接使用了。
这是秋叶的唯一指定安装包链接：https://pan.quark.cn/s/64b808baa960
这里框选的四个选项的意思分别是：
**根目录：**comfyui主要文件夹
**自定义节点：**控制图像的各种节点都必须放在这个文件夹中
**输入图片：**上传的图片集合
**输出图片：**生成的图片集合
——🔋——
2.comfyui节点管理器安装
comfyui节点管理器建议每一个使用软件的人都安装下，他能帮助我们更快地搜索、安装、更新、卸载节点，效率很高。
安装方法如下：
如果你已经安装了秋叶启动器，就不需要安装这个了，因为秋叶已经帮你装好了
如果你没有安装秋叶启动器，看看👇获取秋叶安装包 点击"download ZIP",下载到本地，之后将文件复制到【custom_nodes】目录，记得要解压，然后重新启动comfyui
就能看到如下界面：
——🔋——
3. comfyui界面汉化
刚进去的界面全是英文的，所以几乎看不懂 ，所以我们需要一个汉化补丁，这个补丁其实本质就是一个节点（custom_node）。
3.1 本地安装打开链接：
https://github.com/AIGODLIKE/AIGODLIKE-ComfyUI-Translation
点击"download ZIP",下载到本地，之后将文件复制到【custom_nodes】目录，记得要解压
3.2在线安装
如果你已经安装好了manager管理器，那么就可以有一种更方便的办法进行汉化，你只需要打开节点管理器，点击“install custom node”
接着搜索“translation”，点击“install”即可，安装完成点击“restart”重启即可。
3.3 我推荐的安装方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/839d05c6e0c8494fdaaf1ea14771facb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cacb0e7fdf0983383821311c5f5dd29a/" rel="bookmark">
			WPF中XAML相对路径表示方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在WPF XAML中，相对路径是一种非常实用的方式来引用资源文件，如图像、样式表和其他XAML文件。相对路径可以帮助您构建更加灵活和可移植的应用程序，因为它允许资源文件的位置相对于XAML文件的位置进行定位。
相对路径的表示方法 在XAML中，相对路径通常使用.（当前目录）和..（父目录）来表示。以下是几个常用的相对路径表示方法：
当前目录内的文件:
./Images/MyImage.png或者简写为 Images/MyImage.png 父目录下的文件:
../Images/MyImage.png这里的..表示上一级目录。 更深层次的目录:
../Images/SubFolder/MyImage.png这里包含了两个层级的目录。 跨多个目录层次:
../../Images/MyImage.png这里../../表示从当前文件的目录向上两级。 示例 假设您的文件结构如下所示：
YourProject/ |-- YourNamespace/ | |-- MainWindow.xaml | |-- MainWindow.xaml.cs |-- Assets/ | |-- Images/ | |-- Logo.png | |-- Fonts/ | |-- MyFont.ttf MainWindow.xaml 文件位于 YourNamespace 文件夹内。Assets 文件夹位于与 YourNamespace 同级的位置。 引用 Logo.png 图像文件 在 MainWindow.xaml 中引用 Logo.png 图像文件，可以使用如下路径：
&lt;Image Source="../Assets/Images/Logo.png" /&gt; 这里，../Assets/Images/Logo.png 表示从 MainWindow.xaml 所在的目录向上一级，然后进入 Assets 文件夹，再进入 Images 子文件夹，并找到 Logo.png 文件。
更详细的解释 ../: 表示从 MainWindow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cacb0e7fdf0983383821311c5f5dd29a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49d416c105e4b200d0b5280c0ba6d78/" rel="bookmark">
			线程池的创建以及工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说说线程池的作用
避免创建过多的线程时引发的内存溢出问题。因为创建线程还是比较耗内存的，通常来说创建一个线程会默认分配1M的内存。
线程池的主要优势：
降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
一、如何创建线程池 线程池的创建方法总共有 7 种，但总体来说可分为 2 类：
一类是通过 ThreadPoolExecutor 创建的线程池；
另一个类是通过 Executors 创建的线程池。
线程池的创建方式总共包含以下 7 种（其中 6 种是通过 Executors 创建的，1 种是通过ThreadPoolExecutor 创建的）：
Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池；Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。ThreadPoolExecutor：最原始的创建线程池的方式，它包含了 7 个参数可供设置 ThreadPoolExecutor 参数介绍
ThreadPoolExecutor 最多可以设置 7 个参数，如下代码所示：
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { // 省略... } 7 个参数代表的含义如下：
参数 1：corePoolSize
核心线程数，线程池中始终存活的线程数。
参数 2：maximumPoolSize
最大线程数，线程池中允许的最大线程数，当线程池的任务队列满了之后可以创建的最大线程数。
参数 3：keepAliveTime
最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。
参数 4：unit:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a49d416c105e4b200d0b5280c0ba6d78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5295c0e0e4e14071a7edea143b5bfc0f/" rel="bookmark">
			重头开始嵌入式第十九天（Linux系统编程 文件IO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓冲区 1.行缓冲
行缓冲，1k， terminal，主要用于人机交互stdout
缓存区满或者遇到\n刷新 1024
行缓存多是关于终端的一些操作
1.遇到\n刷新
2.缓存区满刷新
3.程序结束刷新
4.fflush刷新 fflush(stdout);
2.全缓冲
全缓冲，4k，主要用于文件的读写
缓存区满刷新缓存区 4096
对普通文件进行标准IO操作，建立
的缓存一般为全缓存
刷新条件:
1.缓存区满刷新
2.程序结束刷新
3.fflush来刷新 fflush(fp);
3.无缓冲
无缓冲，0k 主要用于出错处理信息的输出 stderr 不对数据缓存直接刷新
printf();==&gt;&gt;stdout fprintf(strerr,"fopen error %s",filename);
界面交互 出错处理
使用gdb查看，FILE结构体，或使用写入数据测试缓冲区。
缓冲区的大小是可以设置
在 C 语言中，可以通过以下方式手动控制缓冲：
1. 使用 fflush 函数： fflush 函数用于强制刷新输出缓冲区，将缓冲区中的内容立即输出。例如： fflush(stdout); 这将刷新标准输出缓冲区。
2. 设置缓冲模式：可以使用 setvbuf 函数来设置缓冲区的类型和大小。函数原型为： int setvbuf(FILE *stream, char *buffer, int mode, size_t size); 其中：
- stream 是要设置缓冲的文件流指针。
- buffer 是用户提供的缓冲区（如果为 NULL ，则由系统分配）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5295c0e0e4e14071a7edea143b5bfc0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3461631b00fb9731ce9c64c0537b2eb/" rel="bookmark">
			API-Runtime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 的 Runtime 类允许应用程序与运行环境进行交互。以下是一些常用的方法：
常用方法 获取 Runtime 实例
Runtime.getRuntime()：返回当前运行时对象。 执行命令
exec(String command)：执行指定的系统命令。 内存管理
totalMemory()：返回 Java 虚拟机中的总内存量。freeMemory()：返回 Java 虚拟机中的空闲内存量。maxMemory()：返回 Java 虚拟机试图使用的最大内存量。gc()：请求垃圾收集器运行。 关机和重启
exit(0)：终止当前运行的虚拟机，非零表示异常终止。addShutdownHook(Thread hook)：注册在虚拟机关闭时调用的钩子。removeShutdownHook(Thread hook)：移除已注册的钩子。 获取虚拟机能够使用的处理器数量
availableProcessors() 示例代码 public class RuntimeExample { public static void main(String[] args) { Runtime runtime = Runtime.getRuntime(); // 内存信息 System.out.println("Total Memory: " + runtime.totalMemory()); System.out.println("Free Memory: " + runtime.freeMemory()); System.out.println("Max Memory: " + runtime.maxMemory()); // 执行系统命令（如：列出当前目录） try { Process process = runtime.exec("ls"); // 在 Windows 中使用 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3461631b00fb9731ce9c64c0537b2eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca36c5e72678e6ee1517478588a5f5f/" rel="bookmark">
			左值引用 VS 右值引用 —— 基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.左值 和 左值引用 1.1什么是左值？ 左值是一个指代内存位置的表达式（如变量名、解引用的指针），这意味着左值拥有内存地址，是可以进行取地址操作的；
常见的左值如下：
// ptr、*ptr、a、b都是左值 int main() { int* ptr = new int(1); int a = 2; const int b = 3; return 0; } 1.2什么是左值引用？ 左值引用就是 对左值的引用，本质上就是 对左值取别名，我们可以通过这个别名来操作这个左值。常见的左值引用如下：
int main() { int*&amp; rp = ptr; int&amp; rb = a; //对const修饰的变量的引用需要加const //避免权限放大 const int&amp; rc = b; int&amp; rpv = *p; return 0; } 左值引用不仅可以引用左值，还可以引用右值，但是左值引用 引用右值的时候需要加 const
const int&amp; ri = 10; 1.3为什么需要左值引用？ 学习过C语言，我们都知道在函数传参时，我们可以选择传值传参和传址传参，但是传值传参和传址传参都具有一定的缺点；传值传参效率低，传址传参代码复杂。例如：
对于传值传参：形参是实参的一份临时拷贝，如果实参所占用的内存空间比较大，传值传参形成形参的时候，需要的时间和空间的开销比较大，会造成一定程度时间和空间的浪费，影响程序的执行效率；而且，传值传参的函数，在函数中修改形参，并不会影响实参，如果想要在该函数中修改实参，就需要传址传参。
传值传参代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca36c5e72678e6ee1517478588a5f5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e86705c5cdd9c0fdad33ad3cdcb9ff/" rel="bookmark">
			新形势下职业教育云计算人才培养策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 在数字化转型的浪潮中，云计算作为核心技术之一，正在深刻影响着各行各业的发展。职业教育作为培养技术技能型人才的重要途径，需要紧跟时代步伐，不断优化和创新云计算人才培养模式，以满足社会对云计算人才的迫切需求。然而，职业教育在云计算人才培养方面面临教学目标不明确、教学模式单一化等问题，迫切需要改革以提升人才培养效能，满足行业发展的迫切需求。唯众旨在深入探讨当前职业教育中云计算应用型人才的培养现状，分析加强这一领域人才培养的重要意义，并在此基础上提出一系列有效的策略，以适应快速变化的信息技术行业需求，确保职业教育能够为社会输送高质量的云计算专业人才。
二、职业教育云计算人才培养发展现状分析 （一） 教学目标不明确
在当前职业教育体系中，部分职业院校在云计算人才培养方面存在教学目标不明确的问题。这些院校往往过分侧重于理论知识的传授，而忽视了对学生实践能力和职业素养的培养。这种做法导致毕业生在就业市场上的竞争力不足，难以满足企业对云计算人才的实际需求。为了解决这一问题，职业院校需要重新审视和明确云计算人才培养的教学目标，确保教学内容既包含理论知识，也注重实践技能和职业素养的培养。
（二） 教学形式单一
传统的以教师讲授为主的课堂教学形式已难以满足云计算人才培养的需求。云计算技术具有高度的实践性和创新性，要求学生不仅要掌握理论知识，还要具备自主学习和团队合作的能力。然而，当前的教学形式往往缺乏互动性和实践性，学生缺少参与实践的机会和团队合作的体验，这限制了他们实际操作能力和团队协作精神的培养。因此，职业院校需要改革教学方法，引入更多互动式和实践性的教学模式，以培养学生的综合能力。
（三）教学内容滞后
云计算技术的发展日新月异，新技术和新应用层出不穷。然而，职业教育的教学内容往往更新不够及时，难以跟上技术发展的步伐。这导致学生在学习过程中接触到的技术和知识可能已经过时，无法满足当前和未来行业的需求。为了解决这一问题，职业院校需要建立一个灵活的教学内容更新机制，确保教学内容能够及时反映云计算技术的最新发展。
（四）实践教学不足
云计算人才培养需要学生通过大量的实践操作来掌握技术，积累实战经验。然而，许多职业教育机构在实践教学方面的投入不足，缺乏必要的实验设备和实训平台，导致学生缺乏实际操作经验。这种情况不仅影响了学生的技术掌握，也限制了他们解决实际问题的能力。职业院校需要增加对实践教学的投入，建立完善的实训体系，为学生提供充足的实践机会，帮助他们积累宝贵的实战经验。同时，通过与企业的合作，可以为学生提供实习机会，让他们在真实的工作环境中学习和成长。
三、新形势下加强职业教育云计算人才培养的意义分析 （一）适应国家发展战略
在国家信息化战略和“互联网+”行动计划的推动下，职业教育院校肩负着培养能够适应新时代发展需求的高素质技术人才的重任。通过不断优化云计算专业的教学内容和教学模式，职业教育能够培养出既具备扎实技术能力，又拥有创新思维和社会责任感的复合型人才。这些人才将成为推动国家战略实施的重要力量，为国家的科技进步、经济发展和社会进步做出贡献。
（二） 适应数字化转型，满足行业需求
云计算技术作为数字化转型的核心驱动力，正在深刻改变着社会的各个方面。加强职业教育在云计算领域的人才培养，不仅能够为社会输送大量高素质、专业化的云计算人才，满足社会对云计算技术的广泛需求，还能帮助学生更好地适应数字化转型的趋势，提升他们在各行各业中的竞争力。通过与行业紧密结合，职业教育能够及时响应市场变化，培养出更符合行业需求的云计算专业人才。
（三） 激发学生学习潜能
云计算专业的学生通常对技术实践充满热情。为了充分激发学生的学习潜能，职业教育需要改革传统的教学方法，引入项目驱动和案例教学等互动性和实践性更强的教学模式。这种教学方式不仅能够提高学生的学习积极性，还能增强他们解决实际问题的能力，促进理论与实践的有效融合。通过这种方式，学生能够在学习过程中不断探索、实践和创新，为将来的职业生涯打下坚实的基础。
（四） 提升学生就业竞争力
加强云计算人才培养，对于提升学生的就业竞争力具有重要意义。通过系统的教育和培训，学生能够掌握云计算领域的前沿技术和核心技能，同时培养良好的职业素养。此外，与企业的紧密合作和实践教学的开展，可以帮助学生更深入地了解行业需求，提前适应职场环境，明确职业发展方向。这些因素共同作用，将显著提高云计算专业毕业生的就业竞争力，使他们在激烈的就业市场中脱颖而出，赢得更多的职业发展机会。
四、新形势下职业教育云计算人才培养策略探索 （一）明确教育目标
在新形势下，职业院校必须紧密结合国家的发展战略和行业发展趋势，明确云计算应用型人才培养的具体目标。这要求院校构建一个与市场需求紧密对接的课程体系，同时强化师资队伍建设和学生实践技能的培养。通过这些措施，可以促进学生的全面发展，确保他们毕业后具备适应社会和市场需求的能力。
（二）实施产教融合
为了提升学生的实际操作能力和职业素养，职业院校需要加强与云计算企业的深度合作。通过引入企业的真实项目案例进入课堂，实施工学结合的订单式培养模式，可以使学生在真实的工作环境中学习和成长。此外，通过企业实习、见习等形式，学生能够亲身体验工作环境，缩短理论与实践之间的距离，为未来的职业生涯打下坚实的基础。
（三）优化教师团队
提升教师队伍素质是提高教学质量的关键。职业院校应定期对教师进行云计算前沿技术和教育方法的培训，鼓励教师参与企业实践，引入企业专家授课。通过这些措施，可以形成一支"双师型"教学团队，确保教学内容的时效性和实用性，更好地满足产业需求。
（四）开展特色实践活动
为了增强学生的实践能力和团队协作能力，职业院校应组织云计算技术竞赛、云平台搭建、项目开发等特色实践活动。利用虚拟化技术和云平台资源，学生可以在模拟真实环境中解决问题，锻炼自己的项目管理和团队协作能力。这些实践活动不仅能够增强学生的就业竞争力，还能帮助他们提前适应职场环境。
（五）更新教学内容，紧跟技术发展
云计算技术的发展日新月异，职业教育机构需要及时更新教学内容，引入最新的云计算技术和应用案例。这不仅能够确保教学内容与技术发展同步，还能帮助学生掌握最前沿的技术和知识，提高他们的竞争力。
（六）建立完善的评价体系
为了全面、客观地评价学生的学习成果，职业院校应建立一个完善的评价体系。这个评价体系应包括理论知识考核、实践能力考核和职业素养考核三个方面，确保学生在各个方面都能得到全面的培养和发展。通过这样的评价体系，可以更好地指导教学活动，促进学生的全面发展。
五、总结 随着云计算技术的飞速发展，其在各行各业中的应用日益广泛，对专业人才的需求也日益迫切。职业教育作为培养技术技能型人才的重要基地，肩负着为社会输送高质量云计算专业人才的使命。面对新形势下的挑战与机遇，职业教育必须进行深刻的教学改革，以适应云计算人才培养的新要求。未来，职业教育机构需要持续关注云计算技术的发展趋势，不断优化和创新人才培养模式，以满足社会对云计算人才的持续需求。同时，也需要加强与政府、企业以及社会各界的合作，共同构建一个开放、协同、高效的云计算人才培养生态系统，为云计算人才的成长和发展提供更加广阔的平台和空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb8728a8211a44aca678cdba3ee7ff3/" rel="bookmark">
			Cannot connect to the Docker daemon at unix:///var/run/docker.sock. 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 原来我的服务器docker服务运行正常，但在某次尝试用时, 根据系统的错误提示执行了snap install docker指令之后，
再执行docker ps命令则提示Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 无法访问docker服务了, 查看状态是正常, 并且重启也没报错, 就是无法通过docker命令操作docker了
网上很多相同的报错, 都是一开始下载的时候才出现问题,
而不是像我这种正常使用后, 因为用了另一种方式安装docker导致原来的服务无法被访问到
因此解决的方式会和别的不太一样
问题分析 执行 snap install docker 后，你实际上通过 Snap 安装了 Docker 的另一个实例，
这个实例可能与系统中原有的 Docker 实例（可能是通过包管理器如 apt, yum, dnf 等安装的）发生冲突。
这通常会导致 /var/run/docker.sock 文件被新的 Docker 实例使用，或者原有的 Docker 服务被停止。
解决步骤 要解决这个问题，需要有以下几个步骤：
1. 停止并卸载通过 Snap 安装的 Docker 首先，尝试停止并卸载通过 Snap 安装的 Docker：
sudo snap stop docker sudo snap remove docker 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdb8728a8211a44aca678cdba3ee7ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6c6b2a573686b736fe36a4033e7db2/" rel="bookmark">
			API-System
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 的 System 类提供了许多与系统相关的实用方法和属性。以下是一些常用的功能：
常用方法 标准输入输出
System.out.println(String x)：输出信息到控制台。System.err.println(String x)：输出错误信息到控制台。 系统属性
System.getProperty(String key)：获取系统属性。System.setProperty(String key, String value)：设置系统属性。 环境变量
System.getenv(String name)：获取指定环境变量的值。 时间
System.currentTimeMillis()：获取当前时间的毫秒数。System.nanoTime()：获取高精度时间的纳秒数。 数组操作
System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：复制数组。 终止虚拟机
System.exit(int status)：终止当前运行的 Java 虚拟机。 示例代码 public class SystemExample { public static void main(String[] args) { // 输出到控制台 System.out.println("Hello, World!"); // 获取系统属性 String javaVersion = System.getProperty("java.version"); System.out.println("Java Version: " + javaVersion); // 获取环境变量 String path = System.getenv("PATH"); System.out.println("System PATH: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6c6b2a573686b736fe36a4033e7db2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd0767781bd63cd4709f1bd7a2045ea/" rel="bookmark">
			第七节 流编辑器sed(stream editor)(7.2.1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3,2 常用编辑命令 对文件内容的编辑命令说明d删除匹配的行p打印匹配到的行a文本内容将文本内容添加到匹配行的下一行i文本内容将文本内容添加到匹配行的上一行c文本内容用文本内容替换匹配到的所有行r读入文件内容追加到匹配行的后面R读入文件一行的内容追加到匹配行的后面w /dir/filename将匹配行的内容另存到/dir/filename中s /pattern/replacement/flag根据正则表达式进行匹配,将匹配到的内容替换为replacment,
flag可以指定 g(表示全局替换,默认只替换每行第一个), num1(表示) 示例:
生成测试文件
sed -e '\#adm#,$#:#@@@#g' testfile a)删除行
sed '1d' testfile sed '$d' testfile sed '/root/d' testfile sed '/root/! d' testfile b)显示行
sed -n '1p' testfile sed -n '$p' testfile sed -n '/root/p' testfile sed -n '/root/! p' testfile c)添加,插入,替换行
sed '1ahello world' testfile sed '$ahello world' testfile sed '/adm/ahello world' testfile sed '/adm/ihello world' testfile sed '/adm/! ihel1o\nworld' testfile d)整合文件
vim numfile1 1 2 6 vim numfile2 2 3 4 sed '1rnumfile2' numfile1 sed '1Rnumfile2' numfile1 e)保存处理结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cd0767781bd63cd4709f1bd7a2045ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99774823100431e101e3add5d825c25/" rel="bookmark">
			【Mind&#43;】掌控入门 项目13 贪吃蛇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多游戏玩家都会记得小时候用最简朴的掌机玩《贪吃蛇》的岁月，在那款分辨率极低的屏幕上，几条扭扭曲曲的弧线似乎穿越了整个童年。
今天就让我们用掌控板来实现这款经典的游戏。
项目示例
在本项目中，我们将屏幕上的单个像素点作为贪吃蛇的蛇头、身体和食物，利用按钮A、B控制蛇头的运动方向，通过不断吃食物，贪吃蛇身体变长，来制作一个简单的贪吃蛇游戏。
在编程过程中，首先我们将通过按钮控制蛇头的运动，然后实现蛇的身体跟随蛇头一起运动，最后添加吃食物身体变长、开机动画、游戏失败和计分机制，完善整个游戏。
通过以下三个小任务进行实践：
任务一：按钮控制蛇头运动 任务二：蛇的身体运动 任务三：完善游戏机制 任务一：按钮控制蛇头移动
将贪吃蛇的蛇头简化为屏幕上一个像素点，通过按扭A、B改变像素点的运动方向。
在屏幕上，蛇头一共有上、下、左、右四个运动方向，游戏开始默认向右运动，按下按钮A逆时针（左转）改变运动方向，按下按钮B顺时针（右转）改变运动方向。每按下一次按钮，方向改变90度。
程序如下：
运行结果：
开机时，屏幕中央显示一个像素点，默认向右运动； 按下A，左转； 按下B，右转。 * 因为未对坐标范围进行限制，所以蛇头像素点会超过屏幕显示范围。如果觉得像素点太小，可以使用画圆指令。
任务二：蛇的身体运动
将蛇的身体也简化为像素点，一个像素点代表一节身体。蛇的身体运动时只需要考虑蛇头坐标变化，其余每一节身体依次取代前一节身体的坐标即可。
程序如下：
运行结果：开机时，由6个像素点组成的贪吃蛇出现在屏幕中央，默认向右移动，按下A或B，会逆时针或顺时针转向。
在程序中我们使用了列表来存储贪吃蛇每个像素点的位置。如下图，列表X、Y分别存储贪吃蛇6个像素点的x、y坐标值。
当蛇头向右移动一步时，旧蛇身数据依次替换到新蛇身中，补齐新蛇头的坐标即可。
任务三：完善游戏机制 在任务二程序基础上，添加函数“开场动画”、“吃到食物”、“碰壁”来完成游戏的开场动画、吃到食物身体变长、计分机制、游戏失败并重新开始游戏。
1.“开场动画”函数
定义“开机动画”函数，将下面16张照片依次显示在掌控板上，每张显示0.2秒。下图中只截取了部分程序。
2.“碰壁”函数
定义“碰壁”函数，设定游戏失败条件是蛇头碰到屏幕边缘。游戏失败后显示得分，2秒后重新开始游戏。
3.“吃到食物”函数
定义“吃到食物”函数，在屏幕上随机显示一个像素点作为食物，当蛇头与食物位置重合表示吃到食物，蛇的长度+1。
4. 同时为了保证开场时随机食物的出现，在初始化长度中，增加设置随机食物初始值。
5. 将函数“开场动画”放置到主程序中，并放置显示食物像素点的“画点”指令，以保证食物一直出现在屏幕上。
6. 最后，将函数“吃到食物”、“碰壁”放置到函数“贪吃蛇活动”中。
运行结果：
开场动画 随机出现食物 碰壁之后结束游戏和计分 知识拓展
软件知识
1、“列表”指令
列表是变量的一种，表示一组变量。举个例子，一周中每天的天气如何？周一是晴天还是下雨？周二呢？周三？……这些就可以看成一组变量，因为都是描述这一周天气的。
“列表”指令的新建：
当要存储和调用多个字符的时候，使用“列表”指令会很方便。需要注意的是，在列表中存储的数据是以字符串的形式存在，比如
，插入的1表示字符串1，而不是数字1。
当需要字符串与数字相互转换的时候，此时可以调用“运算符”中的转换指令。
通过指令
可替换列表中指定项的数据。
通过指令
调可获得列表中指定项的数据。
2、数据类型
什么叫数字1，什么又叫字符串1呢？其实字符串或者数字都叫做数据类型。比如数字1表示数值类型数据，可以加减乘除，而字符串1表示文本类型数据，不能加减乘除，但可以和其他文本合并。字符串一般可以由数字、字母、下划线组成。
数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。例如大胖子必须睡双人床，就给他双人床，瘦的人单人床就够了。
3、指令汇总
项目小结
掌握掌控板函数、变量的使用 学习列表，存储和调用多组字符，完成复杂任务 了解数据类型，掌握数据类型转换方法 挑战一下
1、增加游戏难度，比如随着吃到的食物越来越多，加快贪吃蛇运动速度。
2、在屏幕中内置迷宫和障碍，增加游戏趣味度。
文本参考： 官方教程https://mc.dfrobot.com.cn/misc.php?mod=tag&amp;id=3395
mindplus官方https://mc.dfrobot.com.cn/misc.php?mod=tag&amp;id=3309
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b99774823100431e101e3add5d825c25/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/49/">«</a>
	<span class="pagination__item pagination__item--current">50/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/51/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>