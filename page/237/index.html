<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a186b5b351e1d6d90f2861be0b3fc766/" rel="bookmark">
			在Ubuntu22.04 使用stable-diffusion-webui 秋叶整合包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 众所周知，赛博菩萨已经发布了windows下的整合包，开箱即用，且集成度较高。
那我为啥非要在Ubuntu下使用呢？ 当然是因为主力机就是Ubuntu系统啦。而且涉及到sd webui API 的调用，在Ubuntu 下调试更加方便一点。
那有没有可以在Ubuntu下使用的方式呢？
两种思路：
使用SD-WebUI 的安装脚本，安装好之后，将插件等复制一份过去。直接复制整个包，然后小小改造一下。 相比之下，方法一可能还会遇到一些网络问题，所以，我选择了更偷懒的方法二。
分析一下整合包的内容，其实就多了windows 下的git 和 python 的环境。
git Ubuntu 自带，windows 的python, Ubuntu也用不了，所以这两个直接删了，就可以进行改造了。
创建python 环境 我因为习惯用conda 管理，就用conda 创建了。SD-WebUI 是用python venv 管理的，在 webui-user.sh 中配置
conda 脚本
conda create -n sdweb python=3.10.6 conda activate sdweb venv
# python3.10 -m venv &lt;env name&gt; python3 -m venv venv # 启动 source ./venv/bin/activate # 退出 deactivate 安装所需环境 执行启动脚本，就会安装缺失的python包了。
bash webui.sh 需要注意，这里是bash， 不是sh
如果你选择从头安装的话，如下命令
wget -q https://raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a186b5b351e1d6d90f2861be0b3fc766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ccfb11a528a435f3e98895feab5f06/" rel="bookmark">
			基于Java&#43;SpringBoot&#43;Mysql学生成绩管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、前言介绍： 1.1 项目摘要 随着信息技术的飞速发展，教育领域对信息化、自动化的需求日益增强。学生成绩管理作为学校日常教学管理的重要组成部分，其管理效率和准确性直接影响到教学质量和学生的学习体验。传统的成绩管理方式往往依赖于纸质文档和人工操作，这种方式不仅效率低下，而且容易出错，无法满足现代教学管理的需求。
因此，开发一个基于Web的学生成绩管理系统具有重要的现实意义。该系统能够利用现代信息技术手段，实现学生成绩的自动化管理，包括成绩的录入、查询、统计、分析等功能。通过该系统，教师可以方便快捷地录入学生成绩，学生可以实时查询自己的成绩信息，学校管理层可以全面掌握学生的成绩情况，为教学决策提供数据支持。
此外，学生成绩管理系统还能够提高教学管理的透明度和公正性。通过系统记录的成绩信息，学生和家长可以更加清晰地了解学生的学习情况，促进家校之间的沟通和合作。同时，系统还能够对成绩数据进行统计分析，为教师的教学改进提供有力支持。
综上所述，学生成绩管理系统的开发是教育信息化发展的必然趋势，也是提高教学管理效率和准确性的重要手段。
1.2 目的意义 研究目的：
学生成绩管理系统的主要研究目的在于利用计算机技术和信息化管理手段，实现对学生成绩信息的数字化、系统化、规范化管理。通过该系统，旨在解决传统成绩管理方式中存在的效率低下、查询不便、管理混乱等问题，提高成绩管理的准确性和效率，减轻教师和管理人员的工作负担。
研究意义：
提高工作效率： 学生成绩管理系统能够自动化处理大量成绩数据，减少人工操作，提高工作效率。
加强数据管理： 系统化的管理方式使得成绩数据更加规范、有序，便于查询、统计和分析。
提升服务质量： 通过系统，教师可以更快速地获取学生成绩信息，为学生提供更及时、准确的服务。
促进信息化建设： 学生成绩管理系统的建设是学校信息化建设的重要组成部分，有助于推动学校整体信息化水平的提升。
适应社会发展需求： 随着信息技术的不断发展，社会对教育信息化、管理信息化的需求日益增加，学生成绩管理系统的研究与应用符合这一发展趋势。
综上所述，学生成绩管理系统的研究不仅具有重要的现实意义，还有助于推动学校信息化建设的深入发展，提高学校的管理水平和服务质量。
二、主要技术： 2.1 SpringBoot技术 SpringBoot是基于Spring框架的一个开发框架，旨在简化Spring应程序的搭建和开发过程以下是关于SpringBoot技术的一些主要特点和优势：
SpringBoot提供了许多自动配置的功能，可以根据的依赖和需要自动配置应程序所需的环境，大大少了开发人员的配置工作。Spring提供了强大的Actuator模，我们可以通过HTTP、JMX、SSH等方式对应用进行监控、管理和健康检查。SpringBoot与Spring框架完美结合，可以轻松集成Spring全家桶中的各模块，如Spring Data、Spring Security等。SpringBoot提供丰富的测试支持，开发者可以轻松地编写单元测试、集成测试等各种测试用例。
2.2 Mysql数据库 MySQL数据库是一款开源的关系数据库管理系统。MySQL是开源软件，免费使用，可以降低企的成本开销。MySQL可以在各个操作系统上运行包括Windows、Linux、macOS等提供了比较好的跨平台持。MySQL拥有高性能的查询处理能力、优化的储机制、高效的索引制等，可以满足大部分应用场景的性能需求。MySQL提供了直观的管理工具和丰富的SQL语法，使得用户可以轻松地进行数据库的管理和操作。MySQL经过时间的发展和广泛应用，在稳定性和可靠性方面表现良好，保证了数据的安性和完整性。
2.3 Layui前端框架 Layui是一款轻量级的前端UI框架，专注于提供简洁、易用、灵活的界面组件和交互体验。它基于HTML5和CSS3技术，采用模块化开发的思想，提供了丰富的UI组件、常用的工具函数和灵活的扩展机制。
Layui的设计理念是“经典与创新的全面结合”，它提供了一套简洁、直观、易于上手的API，使得开发者能够快速搭建出美观、功能完善的前端界面。其代码精简，文件体积小，加载速度快，非常适合开发响应式的Web应用程序。
Layui的主要特点包括：
简单易用：Layui的API接口简洁明了，同时提供了丰富的组件，使得开发人员可以快速上手，快速构建页面。
模块化设计：Layui采用了模块化的设计理念，将功能划分为独立的模块。每个模块都有自己的功能和接口，开发人员可以根据需要加载所需的模块，从而减少了不必要的代码冗余。
兼容性好：Layui兼容了大部分主流浏览器，包括IE6+、Chrome、Firefox等，保证了在不同浏览器下的兼容性。
自定义样式：Layui提供了丰富的主题样式，开发人员可以根据自己的需求进行自定义样式的设置，使得页面更加美观。
Layui的组件非常丰富，包括按钮、表单、表格、导航、选项卡、弹窗、富文本编辑器等等，这些组件具有一致的风格和交互体验，可以有效提高开发效率。同时，Layui还提供了丰富的工具函数和插件，如日期选择器、分页、上传组件等，方便开发者进行常见的操作和功能扩展。
在实际应用中，使用Layui可以轻松地实现页面的布局和样式设计，同时其提供的表单验证功能也可以帮助开发者轻松实现对用户输入的验证，保证数据的准确性和安全性。
请注意，尽管Layui在前端开发中曾经非常流行，但随着时间的推移，一些新的前端框架和库逐渐崭露头角，Layui的社区支持和更新可能有所减缓。因此，在选择是否使用Layui时，建议根据项目需求、团队经验和社区活跃度等因素进行综合考虑。
2.4 Mybatis技术 Mybatis框架是一个功能强大的持久层框架，主要用于Java应用程序中与数据库进行交互。它提供了一种简洁、高效的方式来管理数据库操作，使开发人员能够专注于业务逻辑的实现，而无需过多关注底层数据库细节。
Mybatis的核心思想是通过映射文件或注解将SQL语句与Java代码进行分离，实现对象与数据库表的映射。这使得开发人员可以更加直观地编写SQL语句，同时避免了手动拼接SQL语句的繁琐和易错性。
Mybatis框架具有以下优点：
灵活性：Mybatis支持自定义SQL语句，可以根据业务需求灵活编写复杂的查询和更新操作。
性能高效：通过预编译SQL语句和缓存机制，Mybatis可以显著提高数据库访问性能。
易于维护：映射文件和注解的方式使得SQL语句与Java代码分离，便于后续维护和修改。
降低耦合度：Mybatis通过依赖注入和面向切面编程的方式，可以降低代码之间的耦合度，提高系统的可维护性和可扩展性。
在SSM（Spring+SpringMVC+Mybatis）框架中，Mybatis通常与Spring框架整合使用，通过Spring的依赖注入功能来管理Mybatis的SqlSessionFactory和Mapper对象。这种整合方式可以进一步提高系统的灵活性和可维护性，使开发人员能够更加高效地构建稳定、可靠的后端系统。
总之，Mybatis框架是一个强大而灵活的持久层框架，它能够帮助开发人员简化数据库操作，提高开发效率，同时保证系统的稳定性和可维护性。
三、系统设计 使用框架SpringBoot+Mybatis
项目功能有: 教师端：学生管理、成绩管理、学生总成绩查询
学生端：学生信息管理、成绩查询、总成绩查询
运行环境：windows/Linux均可、jdk1.8、mysql5.7、idea/eclipse均可。
运行本项目必须有java环境 如果无java环境 请自己安装环境后再来启动本项目
四、功能截图 五、部分实体类设计 六、数据库设计 七、关键代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c002a911ff161c437974db31dba7055/" rel="bookmark">
			苹果解锁工具iToolab UnlockGo 中文安装版(附教程&#43;补丁) 2024年6月ios17.4.1可用（记得点赞）解压密码请看文章最后 评论区获取最新链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UnlockGo 允许您非常轻松地绕过 iPhone 的密码并获得对设备的完全访问权限。它在以下场景中很有用。
在几分钟内删除 iPhone/iPad 上的各种锁定。
解锁 4 位/6 位密码、Touch ID 和 Face ID
删除没有密码的 iCloud 免费锁
无需密码即可从 iPhone/iPad/iPod 中删除 Apple ID
无需密码即可轻松关闭“查找我的 [设备]” MDM 绕过和删除 MDM 配置文件
在 iOS 设备上重置屏幕时间密码
安装免费教程 （本人设备为企业监管锁，购于4.29号，刷机时出现该情况特制作该教程，希望有所帮助） 1.将获得fix文件夹和Setup.exe安装程序；
双击Setup.exe开始安装软件，如图:
2.勾选我同意此协议，点击下一步，如图:
3.选择软件安装目录，默认目录：C:\Program Files (x86)\UnlockGo ；如图
4.等待安装完成,去掉运行unlockgo，等待安装软件补丁，如图:
5.在安装免费文件前，首先要打开软件的安装目录，如果忘记软件的安装目录，请返回到桌面，找到软件的桌面快捷图标，并右键点击图标，出现弹窗后选择“打开文件位置”即可获得文件安装目录。如图:
6.打开Crack文件夹，将里面的"UnlockGo.exe"文件复制到软件安装目录替换即可，如图:
7.安装完成，以管理员身份运行快捷键，如图:
8.成功如图；
9.链接设备绕过MDM
10.下图为重置及解锁步骤
网盘链接：https://pan.baidu.com/s/1-UYOSlas2X2aH3xiZSlLsA?pwd=366u 提取码：366u 有效期至6月1号，评论区查看最新链接地址不定时更新，过期私聊，文件密码 " ufvyct.test "
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844e3ced955557cd4131940d7c33bf58/" rel="bookmark">
			Hadoop 面试题（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简述Google三驾马车是Hadoop等分布式系统的基石，其中论文()不属于三驾马车之一 ？ A：GFS B：MapReduce C：OpenTSDB D：BigTable 选项C：OpenTSDB 不属于Google三驾马车之一。
Google的三驾马车是指以下三篇具有里程碑意义的论文，它们对Hadoop等分布式系统的设计理念产生了深远影响：
A: GFS (Google File System) —— GFS是Google开发的一个分布式文件系统，其论文描述了GFS的架构和设计，对Hadoop的HDFS（Hadoop Distributed File System）有重要影响。
B: MapReduce —— MapReduce是Google提出的一种编程模型，用于大规模数据集的并行处理。Hadoop的MapReduce是受Google MapReduce论文启发而开发的。
D: BigTable —— BigTable是Google开发的一种分布式存储系统，用于结构化数据。它的设计影响了Hadoop生态系统中的HBase等NoSQL数据库。
OpenTSDB是一个开源的时间序列数据库，它并不是Google三驾马车之一。OpenTSDB用于处理和存储时间序列数据，通常用于监控和测量系统。
2. 简述现有一个安装 2.6.5 版本的 Hadoop 集群，在不修改默认配置的情况下，存储 200 个每个 200M 的文本文件，请问最终会在集群中产生多少个数据块（包括副本） ？ A：200 B：40000 C：400 D：1200 在Hadoop中，默认的数据块大小（dfs.blocksize）是128MB。给定的文本文件每个是200MB，但由于Hadoop的块大小是128MB，文件会被分割成两个数据块：一个128MB的块和一个不足128MB的剩余部分块。
由于每个文件会产生至少两个数据块（第一个块128MB，第二个块小于128MB），200个文件将产生至少400个数据块。
然而，由于默认的副本因子（dfs.replication）是3，这意味着每个数据块会有3个副本。所以，最终产生的数据块总数将是文件产生的数据块数乘以副本因子。
计算如下：
[ \text{总数据块数} = \frac{200 \times 200MB}{128MB} \times 3 ]
[ \text{总数据块数} = 2 \times 200 \times 3 ]
[ \text{总数据块数} = 400 \times 3 ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/844e3ced955557cd4131940d7c33bf58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404d94cfe7237d9e2a7440b4904bccde/" rel="bookmark">
			何恺明新作再战AI生成：入职MIT后首次带队，奥赛双料金牌得主邓明扬参与
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梦晨 发自 凹非寺
量子位 | 公众号 QbitAI 何恺明入职MIT副教授后，首次带队的新作来了！
让自回归模型抛弃矢量量化，使用连续值生成图像。并借鉴扩散模型的思想，提出Diffusion Loss。
他加入MIT后，此前也参与过另外几篇CV方向的论文，不过都是和MIT教授Wojciech Matusik团队等合作的。
这次何恺明自己带队，参与者中还出现一个熟悉的名字：
邓明扬，IMO、IOI双料奥赛金牌得主，在竞赛圈人称“乖神”。
目前邓明扬MIT本科在读，按入学时间推算现在刚好大四，所以也有不少网友猜测他如果继续在MIT读博可能会加入何恺明团队。
接下来具体介绍一下，这篇论文研究了什么。
借鉴扩散模型，大改自回归生成 传统观点认为，图像生成的自回归模型通常伴随着矢量量化（Vector Quantization），比如DALL·E一代就使用了经典的VQ-VAE方法。
但团队观察到，自回归生成的本质是根据先前的值预测下一个token，这其实与值是离散还是连续没啥必然联系啊。
关键是要对token的概率分布进行建模，只要该概率分布可以通过损失函数来测量并用于从中抽取样本就行。
并且从另一个方面来看，矢量量化方法还会带来一系列麻烦：
需要一个离散的token词表，需要精心设计量化的目标函数，训练困难，对梯度近似策略很敏感
量化误差会带来信息损失，导致还原图像质量打折
离散token适合建模分类分布，有表达能力上的局限
那么有什么更好的替代方法？
何恺明团队选择在损失函数上动刀，借鉴近年大火的扩散模型的思想，提出Diffusion Loss，消除了离散tokenizer的必要性。
如此一来，在连续值空间中应用自回归模型生成图像就可行了。
具体来说，它让自回归模型输出一个潜变量z作为条件，去训练一个小型的去噪MLP网络。
通过反向扩散过程，这个小网络就学会了如何根据z去采样生成连续值的token x。扩散的过程天然能建模任意复杂的分布，所以没有类别分布的局限。
这个去噪网络和自回归模型是端到端联合训练的，链式法则直接把损失传给自回归模型，使其学会输出最佳的条件z。
这篇工作的另一个亮点，是各种自回归模型的变体都适用。它统一了标准的自回归AR、随机顺序的AR、以及何恺明擅长的掩码方法。
其中掩码自回归（MAR）模型，可以在任意随机位置同时预测多个token，同时还能和扩散损失完美配合。
在这个统一的框架下，所有变体要么逐个token预测，要么并行预测一批token，但本质上都是在已知token的基础上去预测未知token，都是广义的自回归模型，所以扩散损失都能适用。
通过消除矢量量化，团队训练的图像生成模型获得了强大的结果，同时享受序列建模的速度优势。
论文在AR、MAR的各种变体上做了大量实验，结果表明扩散损失比交叉熵损失稳定带来2-3倍的提升。
与其他领先模型一比也毫不逊色，小模型都能做到1.98的FID分数，大模型更是创下了1.55的SOTA。
而且它生成256x256图像速度也很快，不到0.3秒一张。这得益于自回归生成本来就很快，比扩散模型少采样很多步，再加上去噪网络又很小。
最后总结一下，这项工作通过自回归建模token间的相关性，再搭配扩散过程对每个token的分布进行建模。
这也有别于普通的潜空间扩散模型中用单个大扩散模型对所有token的联合分布建模，而是做局部扩散，在效果、速度和灵活性上都展现出了巨大的潜力。
当然，这个方法还有进一步探索的空间，团队提出，目前在在某些复杂的几何图形理解任务上还有待提高。
何恺明团队都有谁 最后再来介绍一下即将或可能加入何恺明课题组的团队成员。。
Tianhong LI（黎天鸿），清华姚班校友，MIT博士生在读，将于2024年9月加入何恺明的课题组，担任博士后。
Mingyang Deng（邓明扬），MIT本科数学和计算机科学专业在读。
他在高一获得IMO金牌，高三获得IOI金牌，是竞赛圈为数不多的双料金牌得主，也是IOI历史上第三位满分选手。
目前邓明扬的研究重点是机器学习，特别是理解和推进生成式基础模型，包括扩散模型和大型语言模型。
不过他的个人主页上还没有透露下一步计划。
One More Thing 何恺明当初在MIT的求职演讲备受关注，其中提到未来工作方向会是AI for Science，还引起圈内一阵热议。
现在，何恺明在AI4S方向的参与的首篇论文也来了：强化学习+量子物理学方向。
把Transformer模型用在了动态异构量子资源调度问题上，利用自注意力机制处理量子比特对的序列信息。并在概率性环境中训练强化学习代理，提供动态实时调度指导，最终显著提升了量子系统性能，比基于规则的方法提高了3倍以上。
这样一来，何恺明在自己的成名领域CV和探索新领域AI4S上都没耽误，两开花，两开花。
论文：
https://arxiv.org/abs/2406.11838
参考链接：
[1]https://www.tianhongli.me
[2]https://lambertae.github.io
[3]https://arxiv.org/abs/2405.16380
— 完 —
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404d94cfe7237d9e2a7440b4904bccde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95814ce0bbbdf8350560149f812464b1/" rel="bookmark">
			（超简单、超易懂、超详细）算法精讲(十四)：广度优先搜索算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你也喜欢C#开发或者.NET开发，可以关注我，我会一直更新相关内容，并且会是超级详细的教程，只要你有耐心，基本上不会有什么问题，如果有不懂的，也可以私信我加我联系方式，我将毫无保留的将我的经验和技术分享给你，不为其他，只为有更多的人进度代码的世界，而进入代码的世界，最快捷和最容易的就是C#.NET,准备好了，就随我加入代码的世界吧！ 一、算法简介 广度优先搜索算法（Breadth-First Search，简称BFS）是一种图搜索算法，用于在图或树的数据结构中搜索目标节点。
BFS从给定的起始节点开始，逐层地向外扩展搜索，直到找到目标节点或者遍历完整个图。具体来说，BFS按照层级逐个遍历与当前节点直接相连的节点，并将这些节点加入到待搜索队列中。然后再逐个遍历队列中的节点，并将与这些节点直接相连的未被访问过的节点加入到队列中。这样不断重复直到队列为空或者找到目标节点。
BFS算法可以用于解决许多问题，如寻找最短路径、检测图中的环、生成图的最小生成树等。它的时间复杂度为O(V+E)，其中V为顶点数，E为边数。
BFS算法有许多应用场景，如社交网络中的朋友推荐、迷宫的最短路径搜索等。由于BFS按照层级逐步扩展搜索，因此在搜索最短路径问题时，BFS往往比深度优先搜索更为高效。但是，BFS需要使用队列来保存待搜索的节点，因此在空间消耗方面可能比DFS更大。
二、为什么要学习广度优先搜索算法： 广度优先搜索算法是一种重要的图搜索算法，能够在图中找到最短路径或解决问题。
广度优先搜索算法能够遍历图中的所有节点，并且以层次结构的方式进行搜索，从而能够系统地探索所有可能的路径或解。
广度优先搜索算法可以应用于多种问题，如寻找最短路径、迷宫问题、社交网络中的人际关系等。
学习广度优先搜索算法能够提高对图的理解能力，对于解决更复杂的图相关问题有帮助。
学习广度优先搜索算法能够提高编程能力，锻炼问题解决和算法设计的能力。
三、广度优先搜索算法在项目中有哪些实际应用： 3.1 网络爬虫： 广度优先搜索算法可以用于网络爬虫，以从互联网上获取信息。爬虫可以从一个起始页面开始，在页面上获取所有链接，并将这些链接添加到待处理队列中。然后，依次处理队列中的链接，获取更多链接，直到遍历整个网站。
3.2 社交网络分析： 广度优先搜索算法可以用于社交网络分析，以发现用户之间的关系和社交网络的整体结构。通过从一个用户节点开始，搜索其所有直接连接的用户，然后搜索这些用户的连接，以此类推。这种方法可以帮助识别关键用户和社区。
3.3 迷宫求解： 广度优先搜索算法可以用于解决迷宫问题。迷宫可以看作是一个图，其中每个房间是一个节点，每个房间的通道是边。通过使用广度优先搜索算法，可以找到从起点到终点的最短路径。
3.4 操作系统调度： 广度优先搜索算法可以应用于操作系统调度算法中，用于处理进程和资源分配。通过广度优先搜索算法，可以确保每个进程得到相应的时间片，以便公平地使用系统资源。
3.5 单词游戏求解： 广度优先搜索算法可以用于解决单词游戏，如寻找两个单词之间的最短转换序列。通过广度优先搜索算法，可以从起始单词开始，逐步转换每个单词，直到找到目标单词。
四、广度优先搜索算法的实现与讲解： 4.1 广度优先搜索算法的实现 using System; using System.Collections.Generic; class Graph { private int V; // 图中顶点的数量 private List&lt;int&gt;[] adj; // 邻接表表示的图 public Graph(int v) { V = v; adj = new List&lt;int&gt;[V]; for (int i = 0; i &lt; V; i++) { adj[i] = new List&lt;int&gt;(); } } // 添加一条边到图中 public void AddEdge(int v, int w) { adj[v].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95814ce0bbbdf8350560149f812464b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66676c3d6a7ea4396398e8a1f2a09af/" rel="bookmark">
			MATLAB-遗传GA-CNN-SVM，基于GA遗传优化算法优化卷积神经网络CNN结合支持向量机SVM数据分类(多特征输入多分类)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MATLAB-遗传GA-CNN-SVM，基于GA遗传优化算法优化卷积神经网络CNN结合支持向量机SVM数据分类(多特征输入多分类)
1.数据均为Excel数据，直接替换数据就可以运行程序。
2.所有程序都经过验证，保证程序可以运行。
3.具有良好的编程习惯，程序均包含简要注释。
结果展示：
获取方式
https://mbd.pub/o/bread/mbd-ZpeYkpZu 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf3550a9a10511de11714c1cee52e10/" rel="bookmark">
			【数据结构】线性表之《栈》超详细实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈 一.栈的概念与结构二.顺序栈与链栈1.顺序栈2.链栈1.单链表栈2.双链表栈 三.顺序栈的实现1.创建顺序栈2.栈的初始化3.检查栈的容量4.入栈5.出栈6.获取栈顶元素7.栈的大小8.栈的判空9.栈的清空10.栈的销毁 四.栈的盲区五.模块化源代码1.Stack.h2.Stack.c3.test.c 一.栈的概念与结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除
操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）
的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
二.顺序栈与链栈 栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上
插入数据的代价比较小。那是为什么？且听下文分解。
1.顺序栈 2.链栈 1.单链表栈 将栈顶与栈低换个位置可以解决该问题，如下图：
2.双链表栈 由于双向链表比单链表多一个指针，基于节省内存的原由单链表优于双向链表。数组的效率更优于单链表，原因：链表每一次插入一个数据都要申请一个节点，每次删除一个数据都要释放一个节点，且顺序栈包含数据+容量+栈顶，而链栈包含数据+指针，每个数据都要包含指针，顺序栈较于连栈会省一些内存。 接下来我将实现最优的——&gt;顺序栈
三.顺序栈的实现 会写顺序表，那么实现顺序栈会非常轻松，这里就不一一介绍了，直接上代码。
1.创建顺序栈 typedef int STDataType; typedef struct Stack { STDataType* arr; //栈空间的首地址 int top; //栈顶 int capacity; //容量 }ST; ST st;//st代表顺序栈 2.栈的初始化 void StackInit(ST* ps) { assert(ps);//断言 ps-&gt;arr = NULL; ps-&gt;capacity = 0; ps-&gt;top = 0; } 3.检查栈的容量 void CheckCapacity(ST* ps) { assert(ps); //栈满 if (ps-&gt;top == ps-&gt;capacity) { int newCapacity = ps-&gt;capacity == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf3550a9a10511de11714c1cee52e10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf6b18d9a368e92c4c75f5b7fabb82f/" rel="bookmark">
			【SQL】count(1)、count(*) 与 count(列名) 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 SQL 中，COUNT 函数用于计算查询结果集中的行数。COUNT(1)、COUNT(*) 和 COUNT(列名) 都可以用来统计行数，但它们在实现细节和使用场景上有一些区别。以下是详细的解释：
1. COUNT(1) 定义: COUNT(1) 计算查询结果集中的行数。实现: 在执行过程中，COUNT(1) 会将 1 作为一个非空的常量值，并对每一行进行计数。效率: 现代的 SQL 优化器通常会将 COUNT(1) 和 COUNT(*) 优化为相同的执行计划，因此性能基本相同。用途: 适用于计算总行数，与 COUNT(*) 无区别。 SELECT COUNT(1) FROM employees; 2. COUNT(*) 定义: COUNT(*) 计算查询结果集中的总行数，包括所有列，不会忽略任何行，即使某些列包含 NULL。实现: SQL 优化器会对 COUNT(*) 进行优化，将其转换为统计行数的操作。效率: 通常是最常用和推荐的方式，因为其语义明确且优化器能够很好地处理。用途: 适用于计算总行数，性能通常优于 COUNT(列名)。 SELECT COUNT(*) FROM employees; 3. COUNT(列名) 定义: COUNT(列名) 计算查询结果集中某一列非 NULL 值的行数。实现: 只有当指定列的值不为 NULL 时，该行才会被计入结果。效率: 由于需要检查每行中的特定列是否为 NULL，性能可能略低于 COUNT(*) 和 COUNT(1)。用途: 适用于计算某一特定列中非 NULL 值的数量。 SELECT COUNT(department_id) FROM employees; 示例代码 下面是一个使用 JDBC 示例代码，展示如何使用 COUNT(1)、COUNT(*) 和 COUNT(列名)：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecf6b18d9a368e92c4c75f5b7fabb82f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c243de790a64cf724be1d54293d7ceb8/" rel="bookmark">
			【递归、搜索与回溯】floodfill算法一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		floodfill算法一 1.floodfill算法简介2.图像渲染3.岛屿数量4.岛屿的最大面积 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.floodfill算法简介 floodfill算法又叫洪水灌溉或者洪水淹没啥的，这个算法
比如有一个区域，负数表示低谷，0表示平原，正数表示山峰。此时发大水把这些区域淹了。其中平原和山峰可能不会改变，但是低谷水位就要上升。这种类型题目就是，我们要在这个区域中找出水位会上升的区域或者说找到会被洪水淹的区域。其实这道题说白了就是把 性质相同的一个连通块 找出来。
比如这里就是把所有是负数的连通块找到，注意只能上下左右相连，斜着不能连！
floodfill算法解决的问题就这么简单，它解决方法也非常简单，可以用深度优先遍历和宽度优先遍历。dfs就是一条路走到黑，如果无法走就回溯到上一层，然后能走就继续走，直到走到一个不能走的位置。此时就把一个连通区域找到了。
bfs从一个位置开始把和我相连的位置加入到队列里，然后继续在扩一层在扩一层…
因此floodfill算法有两种解决方式，要么dfs、要么bfs。你会发现这个dfs和我们前面单词搜索，黄金矿工解法非常相似，到一个位置之后就上下左右扫描，当和我性质相同就递归进去。这里主要用的是dfs。bfs在优先算法里面，本质其实就是暴搜。
2.图像渲染 题目连接：733. 图像渲染
题目分析：
题目说这么多，其实就是给一个矩阵，在给一个初始的坐标，然后把和这小格性质相同的连通块找到然后变成newcolor。注意只能上下左右去找！
算法原理：
有我们之前做那么多题基础，这里不应该是问题。我们只是简单把过程说一下。其他都是差不多。这里我们只用进行一次深度优先遍历就可以了。以初始位置为起点开始上下左右扫描，当我扫描到和我相同的像素值的时候我就递归进去，但是在递归进去之前先要把我当前位置的值改成newcolor。如果递归到某个位置它上下左右都走不了就回溯。然后如果能走就继续递归下去。直到把这次性质相同的连通块走完。
有一个细节问题，如果newcolor就等于给我们初始位置值，如 newcolor=1，那我们刚才的策略就有问题了。因为上下左右递归的时候可能会回到上一次递归，就会造成死递归。当原始的值和要修改的值相同的话，我们要把这个情况特殊出来一下。无需修改直接返回即可！
class Solution { int dx[4]={0,0,1,-1}; int dy[4]={1,-1,0,0}; int m,n; int prev; public: vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int color) { if(image[sr][sc] == color) return image; m=image.size(),n=image[0].size(); prev=image[sr][sc]; dfs(image,sr,sc,color); return image; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int i, int j, int color) { image[i][j]=color; for(int k = 0; k &lt; 4; ++k) { int x = i + dx[k],y = j + dy[k]; if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; image[x][y] == prev) { dfs(image,x,y,color); } } } }; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c243de790a64cf724be1d54293d7ceb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa133643ec92c2a0190195825d54c2f/" rel="bookmark">
			计算机Java项目｜基于SpringBoot的网上摄影工作室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：编程指南针
作者简介：Java领域优质创作者、CSDN博客专家 、CSDN内容合伙人、掘金特邀作者、阿里云博客专家、51CTO特邀作者、多年架构师设计经验、腾讯课堂常驻讲师
主要内容：Java项目、Python项目、前端项目、人工智能与大数据、简历模板、学习资料、面试题库、技术互助
收藏点赞不迷路 关注作者有好处
文末获取源码 项目编号：L-BS-QBBSSPRINGBOOT-140 一，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
技术：springboot+mysql+html+java
二，项目简介 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了网上摄影工作室的开发全过程。通过分析网上摄影工作室管理的不足，创建了一个计算机管理网上摄影工作室的方案。文章介绍了网上摄影工作室的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本网上摄影工作室管理员功能有个人中心，用户信息管理，作品分类管理，摄影作品管理，摄影圈，系统管理等。用户可以注册登录，对摄影作品进行收藏和点赞以及评论，摄影圈发布信息，发布摄影作品，我的收藏等。因而具有一定的实用性。
本站是一个B/S模式系统，采用Spring Boot框架，MYSQL数据库设计开发，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得网上摄影工作室管理工作系统化、规范化。本系统的使用使管理人员从繁重的工作中解脱出来，实现无纸化办公，能够有效的提高网上摄影工作室管理效率。
本系统是基于B/S架构的网站系统，设计的功能结构图如下图所示：
三，系统展示 3.1 管理员模块的实现 3.1.1 用户信息管理 网上摄影工作室的系统管理员可以管理教师，可以对用户信息修改删除以及查询操作。具体界面的展示如图3.1所示。
图3.1 用户信息管理界面
3.1.2 作品分类管理 系统管理员可以查看对作品分类进行添加，修改，删除以及查询操作。具体界面如图3.2所示。
图3.2 作品分类管理界面
3.1.3 轮播图管理 系统管理员可以对轮播图信息进行添加，修改，删除以及查询操作。界面如下图所示：
图3.3 轮播图信息管理界面
3.1.4 摄影作品管理 系统管理员可以对用户提交的摄影作品进行添加修改删除操作。界面如下图所示：
图3.4 摄影作品管理界面
3.2 用户模块的实现 3.2.1 摄影作品收藏 用户登录后可以对摄影作品进行收藏操作。界面如下图所示：
图3.3 摄影作品收藏界面
3.2.2 摄影圈 用户登录后可以在摄影圈发布信息。界面如下图所示：
图3.6 摄影圈界面
3.2.3 摄影作品发布 用户可以发布自己的摄影作品信息。界面如下图所示：
图3.7 摄影作品发布界面
四，核心代码展示 五，相关作品展示 基于Java开发、Python开发、PHP开发、C#开发等相关语言开发的实战项目
基于Nodejs、Vue等前端技术开发的前端实战项目
基于微信小程序和安卓APP应用开发的相关作品
基于51单片机等嵌入式物联网开发应用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa133643ec92c2a0190195825d54c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62485f6231594fceb653f3a9bd9b5950/" rel="bookmark">
			javascript阻止浏览器回退事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做一个金融相关的项目，甲方想要一个能阻止浏览器回退的方案以实现用户操作包括浏览器左上角按钮，鼠标右键打开菜单选择返回，或者alt+键盘左键的情况下能不丢失用户键入数据或者操作的动作。
从我调查来看因为浏览器安全策略问题没办法直接屏蔽掉回退功能，在用户交互之前（新进入一个界面不进行鼠标点击，滚轮或者键盘操作）或者连续点击回退按钮的情况下总会出现屏蔽失效的问题 这个问题没办法改变 但是可以阻止用户因为误触导致画面回退用户的数据或者动作操作丢失的问题。
1.强行阻止
在JavaScript中，阻止浏览器回退事件通常使用window.onbeforeunload事件。但是，目前的浏览器安全策略可能会要求用户与页面进行交互后才能触发该事件。
这是为了防止恶意网站滥用此功能，强制用户停留在页面上，阻止其离开。通过在用户与页面进行交互时才允许触发window.onbeforeunload事件，浏览器确保用户可以自由地离开页面，同时在必要时提供一些保护。
以下是一个示例，展示了如何使用window.onbeforeunload事件来阻止浏览器回退：
window.onbeforeunload = function() { return "确定要离开此页面吗？"; }; 要阻止浏览器右键菜单中的返回按钮（不阻止整个右键菜单的弹出），你可以使用beforeunload事件来捕获用户离开页面的行为，并在事件处理程序中阻止默认的返回行为。以下是一个示例代码：
window.addEventListener('beforeunload', function(event) { event.preventDefault(); event.returnValue = ''; // 兼容旧版本浏览器 }); 这段代码将监听窗口的beforeunload事件，并在事件处理程序中调用preventDefault()方法来阻止默认的返回行为。为了兼容旧版本的浏览器，我们还将设置event.returnValue为空字符串。
通过这种方式，当用户在右键菜单中选择返回按钮时，浏览器将不会执行返回操作。
2.修改历史记录
要在JavaScript中阻止浏览器的回退事件（即用户按下浏览器的后退按钮），你可以使用history.pushState()方法来修改浏览器的历史记录，从而阻止默认的后退行为。以下是一个示例代码：
window.history.pushState(null, null, window.location.href); window.onpopstate = function(event) { window.history.pushState(null, null, window.location.href); }; 这段代码将在页面加载时调用pushState()方法，将当前URL添加到浏览器的历史记录中。然后，当用户按下浏览器的后退按钮时，onpopstate事件将触发，并再次调用pushState()方法，将当前URL再次添加到历史记录中。当然第一个pushState()方法是为了要画面一跳转进来就压入历史记录中。
这样做的效果是，当用户按下后退按钮时，浏览器的历史记录中只有一个页面条目，即当前页面的URL，因此无法回退到前一个页面。
请注意，阻止浏览器的回退事件可能会影响用户的导航体验，因为他们可能无法像预期的那样回退到前一个页面。请谨慎使用此功能，并确保在特定情况下进行适当的测试和验证。
可以搭配以下代码使用：
history.back() // 与在浏览器点击后退按钮相同 （）里面可以填参数是回退的页面数history.forward() //与在浏览器中点击向前按钮相同（）里面可以填参数是回退的页面数history.go(1); // go() 里面的参数表示跳转页面的个数 例如 history.go(1) 表示前进一个页面history.go(-1); // go() 里面的参数表示跳转页面的个数 例如 history.go(-1) 表示后退一个页面 详情可以了解JavaScript window.history 对象包含浏览器的历史
以上是一个简略的修改history来实现功能的方法 另附（浏览器左上角按钮，鼠标右键打开菜单选择返回，或者alt+键盘左键的控制历史记录实现回退）：
// 阻止浏览器的回退事件（包括后退按钮、右键返回、Alt+左键） window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62485f6231594fceb653f3a9bd9b5950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66949c23098989da181620341da6df74/" rel="bookmark">
			什么是dB？dBm、dBc、dBi、dBd怎么计算，有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是dB？dBm、dBc、dBi、dBd怎么计算，有什么区别？
引言 在电子工程、通信和音频领域，dB（分贝）是一个常见的术语。许多人刚接触时可能会感到困惑，因为它不仅仅是一个简单的单位，还有多种不同的形式，如dBm、dBc、dBi和dBd。这篇文章将详细解释这些概念，并介绍如何计算它们，帮助初学者更好地理解和应用。
什么是dB？ dB，即分贝，是一种表示两个数值比值的对数单位。分贝的基本公式是：
dB = 10 log ⁡ 10 ( P 1 P 2 ) \text{dB} = 10 \log_{10} \left( \frac{P_1}{P_2} \right) dB=10log10​(P2​P1​​)
这里， P 1 P_1 P1​ 和 P 2 P_2 P2​ 是两个功率值。如果涉及到电压或电流，公式稍有不同：
dB = 20 log ⁡ 10 ( V 1 V 2 ) \text{dB} = 20 \log_{10} \left( \frac{V_1}{V_2} \right) dB=20log10​(V2​V1​​)
这里， V 1 V_1 V1​ 和 V 2 V_2 V2​ 是两个电压值。同理，如果涉及到电流值，也是20对数。
20log和10log的区别和推导 为什么有时用10log，有时用20log？这取决于我们是在比较功率还是电压（或电流）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66949c23098989da181620341da6df74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3de57481e505302d345468d7d62f89/" rel="bookmark">
			C# Onnx Yolov5 水果识别，人员识别，物品识别 人工智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
先上效果
来电废话，但实用
网络成功案例实践易失败的原因
万物检测涉及技术
下载合集
关键代码
全部代码
实操vs2022安装关键
YOLO V5核心库编译
编写自己识别软件
更新相关依赖
标注字库文件
测试效果
名词解释YOLO
名词解释ONNX
源码
直播教学和作者
先上效果 来电废话，但实用 为何照做网络成功案例仍失败？软件与男女关系的启示 在网络上看到的成功案例，往往只是呈现了表面的步骤和结果，而忽略了背后诸多复杂的细节和潜在的问题。
就像您提到的软件相关的情况，看似简单的操作，实际上涉及众多组件，版本的不匹配就如同齿轮无法精准咬合，导致整个系统无法顺畅运转。无法下载所需组件更是直接阻断了操作的进行，而系统对某些版本的不兼容，以及某些版本资源的稀缺，都使得我们难以完全复刻所谓的成功。
再以男女关系为例，两个优秀的个体并不意味着就能组成完美的组合。就如同不同规格的零件，尽管各自品质上乘，但如果规格不匹配，强行组合在一起，不仅无法发挥优势，还可能产生冲突和矛盾
网络成功案例实践易失败的原因 A.软件组件复杂
看似简单，实则涉及众多组件。各个版本不匹配，影响正常使用。
B.组件下载受限
部分组件无法下载。
C系统与版本不兼容
某些系统无法安装特定版本。部分版本已无法获取。
万物检测涉及技术 序号软件和技术版本说明1visual studio2022 社区版安装单个必须勾选net5.02Microsoft.ML.Onnx.1.16.2 Microsoft.ML.OnnxRuntime.dll
onnxruntime.dll
3OpenCvSharp4.8安装方式nuget，或者库文件4 SixLabors.Fonts
SixLabors.ImageSharp.Drawing
SixLabors.ImageSharp
1.1
1.0
2.18
5net 架构net5.0net4.7,net4.5,net 4.8 都不行6yolov5n6.onnx模型文件源码自带7yolov58 labelimg1.8labelimg是一款开源的图像标注工具，标签可用于分类和目标检测，它是用python写的 下载合集 1.yovo v5
人工智能神经/yolov5-net
2. visual studio 2022下载
Visual Studio 2022 IDE - 适用于软件开发人员的编程工具
3. onnx C#
https://github.com/microsoft/onnxruntime/releases
5. labelimg 下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb3de57481e505302d345468d7d62f89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73746c9cc8c71eb46f304ce01dfc3929/" rel="bookmark">
			项目介绍与需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一篇文章：项目介绍与需求分析 1. 项目介绍 随着自动驾驶技术的迅猛发展，可靠的仿真环境成为评估和验证自动驾驶算法的关键工具。本项目旨在利用Carla这一强大的自动驾驶仿真平台，测试不同自动驾驶算法在多样化场景下的性能。Carla以其高度可定制化的仿真环境、支持从简单到复杂的多种驾驶场景模拟，以及丰富的传感器模拟功能，为我们提供了一个理想的测试平台。
2. 需求分析 本项目的主要需求可以概括为以下两个方面：
功能需求： 开发并实现自动驾驶车辆的基本功能，包括但不限于车辆控制、路径规划、障碍物检测与避让等。支持多种驾驶场景的仿真，覆盖城市道路、高速公路、复杂交通路口等多种实际驾驶环境。提供多种传感器模拟，如摄像头、激光雷达、GPS等，以模拟真实世界中的传感器数据输入。性能需求： 仿真环境需具备良好的实时性和稳定性，确保测试结果的准确性和可靠性。系统应易于扩展和定制，以满足不同自动驾驶算法和场景的测试需求。 3. SIL、HIL与Carla的应用 软件在环(Software-in-the-Loop, SIL)：在SIL测试阶段，我们将自动驾驶软件集成到Carla仿真环境中，通过模拟器的运行来验证算法的基本功能和逻辑正确性。这一阶段主要用于软件的开发和调试，可以快速迭代和验证算法的改动。
硬件在环(Hardware-in-the-Loop, HIL)：在HIL测试阶段，我们将真实的自动驾驶控制单元（ECU）连接到Carla仿真环境中，模拟真实车辆的传感器输入和执行器输出。通过HIL测试，我们可以验证自动驾驶系统在实际硬件上的性能和稳定性，确保系统在实际应用中的可靠性。
4. 结论 通过本文的介绍和需求分析，我们明确了在Carla仿真环境下进行自动驾驶仿真测试的重要性和目标。接下来，我们将进一步研究测试标准和测试用例设计，确保项目能够按计划实施并取得成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9262b4ce365a86a1a9653598da4d3011/" rel="bookmark">
			【人机交互 复习】第2章 Hadoop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 1.Hadoop 是一个能够对大量数据进行分布式处理的软件框架，并 且是以一种可靠、高效、可伸缩的方式进行处理的，
2.特点：
高可靠性，高效性，高可扩展性，高容错性
运行在Linux平台上，支持多种编程语言
二、Hadoop生态系统（要求熟读） 组件
功能
HDFS
分布式文件系统
MapReduce
分布式并行编程模型
YARN
资源管理和调度器
Tez
运行在YARN之上的下一代Hadoop查询处理框架
Hive
Hadoop上的数据仓库
HBase
Hadoop上的非关系型的分布式数据库
Pig
一个基于Hadoop的大规模数据分析平台，提供类似SQL的查询语言Pig Latin
Sqoop
用于在Hadoop与传统数据库之间进行数据传递
Oozie
Hadoop上的工作流管理系统
Zookeeper
提供分布式协调一致性服务
Storm
流计算框架
Flume
一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统
Ambari
Hadoop快速部署工具，支持Apache Hadoop集群的供应、管理和监控
Kafka
一种高吞吐量的分布式发布订阅消息系统，可以处理消费者规模的网站中的所有动作流数据
Spark
类似于Hadoop MapReduce的通用并行框架
三、习题 1.Hadoop 1.0不包括下列哪个组件(C)
A) HDFS
B) MapReduce
C) Yarn
2.HDFS是(A)
A) 分布式文件系统
B) 分布式并行计算框架
C) 批处理框架
D) 资源管理器
3.HBase是(C)
A) 关系数据库
B) 键值数据库
C) 分布式列式数据库
D) 文档数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9262b4ce365a86a1a9653598da4d3011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5eeba1692aad929081b17f5ed7b3bc9/" rel="bookmark">
			MySQL 高级(进阶) SQL 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、普通查询
1.SELECT ----显示表格中一个或数个字段的所有数据记录
2.DISTINCT ----不显示重复的数据记录
3.WHERE ----有条件查询
4.AND OR ----且 或
5.IN ----显示已知的值的数据记录
6.BETWEEN ----显示两个值范围内的数据记录
二、通配符查询
1.通配符
2.LIKE ----匹配一个模式来找出我们要的数据记录
3.ORDER BY ----按关键字排序
三、函数
1.数学函数
2.聚合函数
3.字符串函数
4.GROUP BY ----对GROUP BY后面的字段的查询结果进行汇总分组
5.HAVING ----用来过滤由 GROUP BY 语句返回的记录集，
6.别名 ----字段別名 表格別名
7.子查询 ----连接表格，在WHERE 子句或 HAVING 子句中插入另一个 SQL 语句
四、连接查询
1.inner join(内连接)
2.left join(左连接)
3.right join(右连接)
5.CREATE VIEW ----视图，可以被当作是虚拟表或存储查询。
6.UNION ----联集
五、交集值 ----取两个SQL语句结果的交集
1.内连接
2.左连接
3.右连接
4.子查询
5.多表查询
6.联集+分组
六、CASE ----是 SQL 用来做为 IF-THEN-ELSE 之类逻辑的关键字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5eeba1692aad929081b17f5ed7b3bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8734b1f81ff977d17295b5aaaa45291a/" rel="bookmark">
			elasticsearch PipelineI详解：原理与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 在Elasticsearch的数据处理流程中，Pipeline API为数据的预处理和转换提供了强大的工具。随着Elasticsearch 5.x版本之后Ingest Node的引入，Pipeline API的引入为开发者们提供了更多的灵活性和便利性。本文将对Pipeline API的原理、具体使用方法及其在实际场景中的应用进行更加详细的探讨。
目录 一、Pipeline 背景和原理Elasticsearch 5.0之前的文档预处理Ingest Node的引入Ingest Node的工作原理Ingest Node的配置与灵活性Elasticsearch对Logstash的替代 二、Pipeline API使用1. 定义 Pipeline2. 使用 Pipeline3. 获取 Pipeline 信息4. 删除 Pipeline5. 模拟 Pipeline6. 引用其他 Pipeline 三、Pipeline API应用场景四、Pipeline 应用方式五、内置 Processors 一、Pipeline 背景和原理 Elasticsearch 5.0之前的文档预处理 在 Elasticsearch 5.0 版本之前，如果用户希望在文档被索引到 Elasticsearch 之前进行预处理，他们通常需要依赖外部工具，如 Logstash，或者以编程方式/手动进行预处理。这是因为早期的 Elasticsearch 版本并不提供文档预处理或转换的能力，它仅仅是将文档按原样索引。
Ingest Node的引入 从 Elasticsearch 5.x 版本开始，为了解决这个问题，Elasticsearch 引入了一个名为 ingest node 的功能。Ingest node 为 Elasticsearch 本身提供了文档预处理和丰富的轻量级解决方案。这意味着用户可以在 Elasticsearch 内部直接对文档进行预处理，而无需依赖外部工具。
Ingest Node的工作原理 当数据进入 Elastic 集群并指定了特定的 Pipeline 时，Elasticsearch 中的 ingest node 会按照定义好的处理器（processor）顺序对数据进行操作和处理。这种预处理是通过截取批量和索引请求在 ingest node 上执行的，处理完成后将文档传递回索引或批量 API。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8734b1f81ff977d17295b5aaaa45291a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0b67f09cf0ffbfbece12ea1119310f/" rel="bookmark">
			java 技术 架构 相关文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，有许多不同的技术和架构，这里我将列举一些常见的Java技术和架构，并提供一些相关的文档资源。
Spring Framework
Spring是一个开源的Java/Java EE全功能框架，以Apache许可证形式发布，提供了一种实现企业级应用的方法。
官方文档：Spring Framework
Spring Boot
Spring Boot是Spring的一个子项目，旨在简化创建生产级的Spring应用和服务的过程。
官方文档：Spring Boot
Spring boot 中文文档
Spring Boot 中文文档 | Spring官方文档中文翻译 | Spring Boot 中文翻译 - CADN开发者文档中心
Spring framework 中文文档
Spring Framework 中文文档 | Spring官方文档中文翻译 | Spring Framework 中文翻译 - CADN开发者文档中心
Spring Cloud 中文文档
Spring Cloud 中文文档 | Spring官方文档中文翻译 | Spring Cloud 中文翻译 - CADN开发者文档中心
Spring Cloud Gateway 中文文档
Spring Cloud Gateway 中文文档 | Spring官方文档中文翻译 | Spring Cloud Gateway 中文翻译 - CADN开发者文档中心
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0b67f09cf0ffbfbece12ea1119310f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5330d3d942cba00c806854f3fb1f4d69/" rel="bookmark">
			【机器学习】在【R语言】中的应用：结合【PostgreSQL数据库】的【金融行业信用评分模型】构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.数据库和数据集的选择
1.准备工作
2.PostgreSQL安装与配置
3.R和RStudio安装与配置
2.数据导入和预处理
1.连接数据库并导入数据
1.连接数据库
2.数据检查和清洗
1.数据标准化
2.拆分训练集和测试集
3.特征工程
1.生成新特征
2.特征选择
4.模型训练和评估
1.逻辑回归
2.随机森林
3.XGBoost
4.模型比较与选择
5.深度挖掘和优化
1.模型调参
2.特征交互和组合
6.实际应用中的挑战与解决方案
1.数据偏差
1.持续监控模型性能
2.在线学习和模型更新
3.数据增强
2.模型过拟合
1.交叉验证
2.正则化
3.增加训练数据
3.业务需求变化
1.模块化设计
2.自动化流程
3.多模型集成
附录
完整代码示例
金融行业由于其高度数据驱动的特点，是机器学习技术应用的理想领域。信用评分作为金融领域的重要应用，通过评估借款人的信用风险，帮助金融机构做出放贷决策。本文将详细介绍如何使用R语言结合PostgreSQL数据库，基于公开数据集构建一个信用评分模型。
1.数据库和数据集的选择 本次分析将使用Kaggle上的德国信用数据集（German Credit Data），并将其存储在PostgreSQL数据库中。该数据集包含1000个样本，每个样本有20个特征，用于描述借款人的信用情况。
1.准备工作 在开始我们的分析之前，我们需要安装和配置所需的软件和库。
安装PostgreSQL：PostgreSQL是一个强大的开源关系型数据库管理系统，可以方便地处理大规模数据。安装R和RStudio：R是本次分析的主要编程语言，RStudio作为集成开发环境。安装必要的R包：包括DBI和RPostgreSQL用于数据库连接，dplyr用于数据处理，caret和xgboost用于机器学习模型。 2.PostgreSQL安装与配置 访问PostgreSQL官方网站下载适用于您操作系统的安装包。按照官方网站上的说明进行安装，确保安装过程中包括pgAdmin管理工具。安装完成后，打开pgAdmin并创建一个名为credit_rating的数据库。在数据库中创建表并导入德国信用数据集。我们可以使用SQL脚本完成此操作： CREATE TABLE german_credit_data ( ID SERIAL PRIMARY KEY, Status_Checking VARCHAR(255), Duration INT, Credit_History VARCHAR(255), Purpose VARCHAR(255), Credit_Amount INT, Savings_Account VARCHAR(255), Present_Employment_Since VARCHAR(255), Installment_Rate INT, Personal_Status_Sex VARCHAR(255), Other_Debtors_Guarantors VARCHAR(255), Present_Residence INT, Property VARCHAR(255), Age INT, Other_Installment_Plans VARCHAR(255), Housing VARCHAR(255), Number_of_Existing_Credits INT, Job VARCHAR(255), Number_of_People_Liable INT, Telephone VARCHAR(255), Foreign_Worker VARCHAR(255), CreditRisk INT ); 然后使用批量导入工具将CSV数据文件导入到表中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5330d3d942cba00c806854f3fb1f4d69/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/236/">«</a>
	<span class="pagination__item pagination__item--current">237/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/238/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>