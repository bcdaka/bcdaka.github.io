<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282285a2d6bcfd7e722d9ec0e3964821/" rel="bookmark">
			传统的进程间通信——管道通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统的进程间通信——管道通信 管道是UNIX系统中最古老的进程间通信方式，是一种特殊文件读写机制
当进程从管道文件中读取数据时，如果管道中没有数据则进程会进入阻塞状态，直到有数据读取出来才返回，因此不需要借助信号、文件锁来协调读写时间
管道中的数据一旦读取完毕就会消失，因此也不需要管理文件的位置指针，所以使用管道文件比普通文件的进程间通信要方便很多
古老的好处是所有系统都支持，早期的管道文件是半双工，现在有些系统支持管道文件的全双工，现在绝大多数情况已经不使用管道来通信了
有名管道： 在文件系统中创建出一个实体的有文件名的管道文件，然后通过系统I/O的相关API来进行相关操作
使用函数创建： #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; ​ int mkfifo(const char *pathname, mode_t mode); 功能：创建一个有名管道文件 pathname:管道文件的名字 mode:管道文件的权限 返回值：成功返回0 失败-1 使用命令创建： mkfifo &lt;file&gt; 管道单向通信的编程模型： 进程A -&gt; 进程B 创建有名管道 打开管道 打开管道 写数据 读数据 关闭管道 关闭管道 删除管道 #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; ​ int main(int argc,const char* argv[]) { // 创建管道文件 if(mkfifo("fifo",0644)) { perror("mkfifo"); return -1; } ​ // 打开管道 int fd = open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/282285a2d6bcfd7e722d9ec0e3964821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e42e749f1e1d2101b78554472c5dc0/" rel="bookmark">
			Jmeter进行http接口测试，这一篇就搞定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jmeter-http接口测试脚本 jmeter进行http接口测试的主要步骤（1.添加线程组 2.添加http请求 3.在http请求中写入接口的URL，路径，请求方式，参数 4.添加查看结果树 5.调用接口，查看返回值）
针对接口添加header在如下途径添加：
jmeter做http接口测试添加cookie：
3.jmeter-webservice脚本
进行webservice测试的一般步骤
1、在soapui中新建已经soap项目，导入wsdl地址，获取到请求报文、SOAPAction和请求url（在soapui的raw中能找到）
2、打开jmeter新建一个线程组
3、新建一个SOAP/XML-RPC Request
4、把url、soapaction和请求报文写到soaprequest中5、调用接口、查看返回值）
4.jmeter-参数化
参数化的作用：调用接口入参时。有时要求参数经常变化，如果每次去修改就会变得很繁琐，这时候就需要把经常变化的值改变为提前编辑好的文档或函数中，便于调用时使用不同的值。
Jmeter参数化的方式有三种：
1）用户定义的变量（这种就是为了方便管理参数，只能有一个值，比如说ip地址不经常变化的）。
在线程组中添加一个用户定义的变量，然后写key和value就可以了，key就是这个参数的名称，也就是你在脚本里面取的值，value就是具体值了。在取参数化的值的时候，使用${name}这样去取值，name就是你取的变量名称。
在脚本中获取参数化的值
2）函数生成器（函数生成器可以参照一定的规则生成数据，这样的比如说生成一些随机数）。
函数助手的话，可以按照规则生成一些参数，比如说随机数取当前时间，最常用的就是这两种。
随机数__Random，可以在你指定的一个范围内取随机值
取当前时间__time，如果在有一些需要传时间的情况下可以使用，日期格式是：yyyy-MM-dd HH:mm:ss 年-月-日-小时:分钟:秒
取唯一id，__UUID，这个就是每次会生成一个随机的uuid，都是唯一的。
利用函数助手可以按照规则生成一些参数。
3）从文件中读取（文件读取就是事先写好一些数据，然后从文件中读取，这样的话，比如说登录接口，账号和密码都是我们事先注册好的）
从文件中读取的有3个步骤：
1、读取文件
2、取文件内容里面的参数，给它一个名字
3、使用值（从文件读取的话，需要在线程组里面添加一个CSV Data Set Config，它就是做前面两步的操作的）。
5.jmeter断言
断言的作用是用来查看返回结果是否正确，如果正确就代表这个请求的返回值是正确的，如果没有的话就代表这个请求的结果和我们预期的不一致，这样我们就可以通断言来检查返回结果，测试是否通过。
6.jmeter关联
关联作用是由于后面操作需要用到前面服务器返回的结果，所以将该值保存传递过来以便使用。
Jmeter中的关联一般通过正则表达式提取器来完成（如果有特殊的jar包也可）
关联的值在其他请求引用时，直接使用${name}即可，name就是你关联的时候设置的变量名。
7.jmeter操作数据库mysql
操作数据库的步骤：
1.导入jdbc的jar包，因为jmeter本身不能直接连接mysql，所以需要导入第三方的jar包，来连接mysql。
2、创建数据库连接配置，mysql的url、端口号、账号、密码
3、写sql，执行sql
4、查看结果
Jmeter导入jdbcjar包
配置mysql连接
(1)添加一个JDBC Connection Configuration
(2)配置mysql连接池的名称，后面发sql请求的时候指定连接哪里
(3)数据库的url：jdbc:mysql://192.168.1.116:3307/bugfree?allowMultiQueries=true
(4)数据库驱动：这里就是指定连接什么类型的数据库，mysql、oracle、SqlServer等等
(5)账号密码
Jmeter执行sql
查看sql结果
8.Linux下运行jmeter压测
我们在做测试的时候，有时候要运行很久，公司用的测试服务器一般都是linux，就可以运行在linux下面，linux下面不能像windows一样有图形化界面，那怎么运行脚本呢，就先在windows上把脚本做好，然后在linux下运行即可，linux下运行jmeter是在jmeter的bin目录下的jmeter.sh这个shell脚本。
sh jmeter.sh -n –t a.jmx -l res.jtl
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e42e749f1e1d2101b78554472c5dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa5a7b9227f24b44d1e07dbd7b53c6d/" rel="bookmark">
			《区块链：能源市场变革的引领者》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在全球能源需求不断增长和能源结构转型的关键时期，传统的能源市场模式正面临着诸多挑战。其中，中心化的交易结构导致的效率低下、信任缺失以及智能合约管理的复杂性等问题日益凸显。然而，区块链技术的出现为能源市场带来了新的曙光，有望通过去中心化交易和智能合约管理实现能源领域的重大变革。
能源市场一直以来都依赖于中心化的机构来协调能源的生产、分配和交易。这种集中式的模式不仅容易产生垄断，限制市场竞争，还可能导致信息不对称，使得消费者和小型能源生产者处于不利地位。此外，复杂的交易流程和繁琐的合约管理增加了交易成本，降低了市场的灵活性和响应速度。
区块链技术的去中心化特性为能源市场提供了一种全新的解决方案。通过分布式账本，能源交易可以在无需中心化机构的干预下直接在生产者和消费者之间进行，实现了点对点的能源交易。这意味着小型能源生产者，如家庭太阳能板拥有者，能够直接将多余的电力出售给附近的消费者，打破了传统能源巨头的垄断，促进了市场的竞争和多元化。
在去中心化的能源交易中，区块链确保了交易的安全性和透明度。每一笔交易都被记录在不可篡改的区块链上，所有参与者都可以查看和验证交易记录，消除了信息不对称的问题。这种透明度不仅增加了市场的信任度，还为监管机构提供了更有效的监督手段，有助于防范欺诈和违规行为。
智能合约是区块链技术的另一个重要应用，它为能源市场的合约管理带来了前所未有的自动化和效率提升。传统的能源合约通常需要人工起草、审核和执行，过程繁琐且容易出错。而智能合约可以将合约条款编写为代码，当预设的条件满足时，合约自动执行，无需人工干预。
例如，在能源采购合约中，可以设定当能源价格达到一定阈值时，自动触发购买或出售操作。智能合约还可以用于管理能源供应的质量和稳定性，确保生产者按照合约规定提供符合标准的能源。此外，它还能够实现能源交易的实时结算，大大缩短了资金周转周期，提高了资金使用效率。
区块链技术在能源市场的应用还可以促进可再生能源的整合和发展。随着太阳能、风能等可再生能源在能源结构中的比重不断增加，其间歇性和分布式的特点给能源管理带来了挑战。区块链可以为可再生能源的生产者和消费者提供一个高效的交易平台，激励更多的人参与到可再生能源的生产和使用中。
通过记录可再生能源的产生和消耗数据，区块链能够为绿色能源证书的发行和交易提供可靠的基础。这有助于推动可再生能源的投资和发展，加速全球能源转型的进程。
然而，要实现区块链在能源市场的广泛应用，还需要克服一些技术和政策方面的障碍。在技术上，区块链的扩展性和性能仍然是需要解决的问题，以应对能源市场大规模交易的需求。同时，能源行业的高度专业性和复杂性也要求区块链解决方案具备高度的安全性和稳定性。
在政策方面，由于能源市场受到严格的监管，区块链应用需要符合相关的法律法规和政策要求。政府和监管机构需要制定明确的政策框架，引导和规范区块链技术在能源领域的应用，保障能源市场的安全和稳定运行。
尽管面临诸多挑战，但区块链技术在能源市场的潜力巨大。它不仅能够提高能源交易的效率和透明度，降低交易成本，还能够推动能源市场的去中心化和民主化，促进可再生能源的发展，为全球能源转型提供强大的技术支持。
随着技术的不断进步和政策环境的逐步完善，我们有理由相信，区块链将成为能源市场未来发展的重要驱动力，引领我们走向一个更加高效、公平和可持续的能源新时代。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d4b3c74f0c80ca28773b97ebc97f1b/" rel="bookmark">
			Swift中的数据守护者：Core Data全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：Swift中的数据守护者：Core Data全解析 在Swift语言的iOS开发中，数据持久化是一个核心议题，而Core Data则是Apple提供的一个强大而灵活的解决方案。它不仅可以处理本地数据存储，还可以与远程数据源同步。本文将深入探讨如何在Swift中使用Core Data进行数据存储，包括其架构、优势以及具体的实现步骤和代码示例。
Core Data简介 Core Data是Apple的一个框架，用于在iOS、macOS和watchOS上管理模型层的数据。它提供了对象图映射（ORM）功能，允许开发者以对象的形式操作数据库，同时自动处理数据的持久化。
Core Data的主要组件 数据模型（Data Model）：定义数据的存储结构。托管对象上下文（Managed Object Context）：协调数据的创建、查询、更新和删除。托管对象（Managed Object）：数据模型中的实体实例。持久化存储协调器（Persistent Store Coordinator）：管理数据的存储方式。实体描述（Entity Description）：定义实体的属性和关系。 Core Data的优势 自动持久化：开发者不需要编写SQL语句，Core Data自动处理数据的保存。数据版本控制：支持数据模型的迁移和版本控制。多线程支持：可以在不同的线程上并发执行数据操作。灵活的数据模型：支持一对多、多对多等复杂关系。 使用Core Data进行数据存储的步骤 定义数据模型：使用Xcode创建数据模型文件（.xcdatamodeld），定义实体和属性。设置托管对象上下文：在AppDelegate中配置托管对象上下文。创建和查询数据：使用托管对象上下文创建和查询数据。保存上下文：在数据修改后，保存托管对象上下文以更新数据库。 代码示例 以下是一个简单的示例，展示如何在Swift中使用Core Data存储和查询数据。
1. 定义数据模型 在Xcode中创建一个新的数据模型文件，添加一个名为"Person"的实体，包含两个属性：“name”（字符串类型）和"age"（整数类型）。
2. 设置托管对象上下文 在AppDelegate中配置持久化存储协调器和托管对象上下文。
import UIKit import CoreData @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? lazy var persistentContainer: NSPersistentContainer = { let container = NSPersistentContainer(name: "Model") container.loadPersistentStores { (storeDescription, error) in if let error = error as NSError?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d4b3c74f0c80ca28773b97ebc97f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a6bf4221c0cf73c18afcc2a22d6fcd2/" rel="bookmark">
			基于人工智能、三维视觉、混合现实等技术的智慧能源开源了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、简介 AI视频监控平台, 是一款功能强大且简单易用的实时算法视频监控系统。愿景在最底层打通各大芯片厂商相互间的壁垒，省去繁琐重复的适配流程，实现芯片、算法、应用的全流程组合，减少企业级应用约 95%的开发成本，在强大视频算法加持下的AR使得远程培训和远程操作指导不仅仅能够实现前后场的简单互动，而且能够实现人机结合，最终实现整个巡检流程的标准化。用户仅需在界面上简单操作，即可实现全视频的接入及布控。
通过全球最前沿的技术解决视频拼接中时延带来的的应用缺陷，使得全景视频拼接能够真正在行业中得以大范围使用和推广。AI+AR技术的有机结合：在强大视频算法加持下的AR使得远程培训和远程操作指导不仅仅能够实现前后场的简单互动，而且能够实现人机结合，最终实现整个巡检流程的标准化。
​
​
系统根据客户环境目前共分为三种形态：分别为
集群版-AIBox
支持大量边缘盒子集中管理调度，平台实现多个盒子的控制管理，报警推送消息升级。 基于多个边缘盒子部署的综合视频安防系统，多用于布置大量摄像头的场景，如仓库、物流园区、学校、医院、工厂、交通枢纽等。
单机版-SingleBox
应用单个边缘盒子，可关联少量摄像头、算法，在客户现场可快速落地体验。
服务器版-Master
适用于拥有 GPU显卡的企业用户。 基于服务器部署的综合视频安防系统，多用于布置大量摄像头的场景。
项目公开演示链接：http://39.164.53.248:33089/
1.集群版-AIBOX
名称描述备注AIBOX-Server后端项目需付费AIBOX-VUE前端项目 2. 服务器版-Master
名称描述备注Master-Server后端项目暂时开源Master-VUE前端项目 3.单机版-SIngleBOX
名称描述备注SingleBox-Server后端项目需付费SingleBox-VUE前端项目 二、项目特点 集成化：视频监控、计算机视觉计算、告警通知 一体的视频安防平台支持RTSP/RTMP 推流拉流形式支持x86、arm等指令集平台部署支持H265/H264/GB28181/的视频格式支持添加客户自己训练的模型支持多路多算法的实时AI计算全方面告警通知，支持语音电话、短信、企业微信、钉钉、APP、第三方接口、音柱高性能，支持多路多算法实时监控与AI计算，及时返回告警结果 三、项目定位 跨平台视觉安防解决方案二次开发项目服务商用级机器视觉平台 四、功能清单 光伏板异路光伏板位移安全帽识别告警管理安全钩子识别火焰识别烟雾识别敬请期待...... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f558767c5c091fffc17b575b8479a4c0/" rel="bookmark">
			Web3D技术有哪些优势？应用场景有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Web3D技术具有多方面的优势，这些优势使得它在多个领域得到了广泛的应用。51建模网为各行业web3D展示提供技术支持。以下是对Web3D技术优势的详细阐述及其应用场景的归纳：
一、Web3D技术的优势 1、跨平台兼容性： Web3D技术可以在不同的平台和设备上运行，包括桌面、移动设备和虚拟现实设备等，用户可以随时随地访问3D内容。
2、强大的交互性： Web3D技术允许用户与3D模型进行全方位的交互，如旋转、缩放、移动等，这种深度互动极大地提升了用户体验和产品认知度。
3、轻量化处理： 通过优化算法和压缩技术，Web3D技术实现了3D模型的轻量化处理，既保留了产品的精细度，又确保了快速加载和流畅交互。
4、无缝浏览： Web3D技术支持多平台（PC、手机、平板）无缝浏览，用户无需额外安装插件，仅凭一个链接即可在浏览器中直接体验3D产品。
5、丰富的展示效果： Web3D技术可以结合热点标注、动态动画、爆炸视图、材质切换等丰富交互元素，为用户带来前所未有的沉浸式体验。
6、广泛的应用场景： Web3D技术不仅限于娱乐和游戏领域，还广泛应用于教育、培训、营销、广告、医疗、建筑等多个领域，为各行各业提供了全新的展示和营销方式。
二、Web3D技术的应用场景 1、游戏和娱乐： Web3D技术可以用于创建在线游戏，如角色扮演游戏、策略游戏、休闲游戏等，使游戏画面更加逼真，提升玩家的沉浸感。
2、营销和广告： 通过Web3D技术实现3D商品展示和营销，720°立体多角度展示产品外观、功能和卖点，增强消费者对产品的信心。51建模网为个大品牌和电商企业的产品3D展示提供技术支持。
3、教育和培训： Web3D技术可以用于教育领域的虚拟现实场景中，如人体解剖、化学实验、历史重现等，帮助学生和员工更好地理解和掌握知识和技能。
4、建筑和设计： 建筑设计师可以使用3D建模软件创建建筑模型，然后通过Web3D技术呈现给客户，实现建筑设计的沟通和展示。
5、艺术和文化： Web3D技术可以用于艺术作品的呈现和展示，艺术家可以创作出更加逼真、生动和沉浸式的作品，并通过网络向世界各地的用户展示和分享。
6、工业制造： Web3D技术可以将工厂的设备、生产线等以三维模型的形式呈现，便于了解运行情况和运营管理。
7、旅游和观光： 通过Web3D技术，可以创建虚拟旅游场景，让用户在家中就能身临其境地游览世界各地的名胜古迹。
综上所述，Web3D技术以其独特的优势在多个领域得到了广泛的应用，并随着技术的不断发展和完善，其应用场景还将进一步拓展和创新。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f0f3c0e53403ec8748b69f92e95ca52/" rel="bookmark">
			手机谷歌浏览器怎么用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌浏览器不仅在PC端受欢迎，在移动端也是广泛应用的。为了帮助大家更好的理解和使用手机谷歌浏览器，本文将详细介绍如何使用手机谷歌浏览器，对这款浏览器感到陌生的话就快快学起来吧。（本文由https://chrome.cmrrs.com/站点的作者进行编写，转载时请进行标注。）
手机谷歌浏览器使用方法 1、下载与安装：
在手机的应用商店（如Google Play Store或Apple App Store）中搜索“谷歌浏览器”或“Chrome”。找到应用后，点击下载并按照提示完成安装过程。安装完成后，你会在手机的主屏幕上看到谷歌浏览器的图标。
2、基本操作：
打开浏览器：点击手机主屏幕上的谷歌浏览器图标即可启动应用。
浏览网页：打开浏览器后，可以在地址栏中输入你想访问的网址或者使用语音搜索功能。你也可以点击地址栏旁边的放大镜图标进入搜索界面，在搜索框中输入关键词进行网页搜索。
切换标签页：当有多个标签页打开时，你可以通过点击屏幕底部的标签页图标来切换不同的网页。若想快速切换，可以在地址栏上向左或向右滑动来实现这一功能。
3、高级功能与设置：
地址栏位置调整：如果你使用大屏手机，可以将地址栏设置到屏幕底部以方便单手操作。在浏览器设置中找到地址栏位置选项，选择“底部”即可实现这一变化。
快速复制网址：长按地址栏中的网址会弹出一个菜单，其中包含复制选项，可以直接复制当前网址到剪贴板中。
滑动操作：在浏览器的三点菜单（更多选项）中，可以通过滑动手指来快速选择不同的功能选项，如添加书签、共享链接等，而无需准确点击每个小图标。
4、个性化设置与优化：
调整浏览外观：在设置菜单中可以找到外观设置，这里你可以调整字体大小、背景颜色以及是否开启夜间模式，以适应不同的阅读环境和习惯。
添加主页按钮：如果你希望每次打开浏览器时都能快速访问特定的网站，可以在设置中添加主页按钮。这需要编辑浏览器的快捷方式，将常用网站的URL设置为主页URL。
搜索引擎切换：如果你不喜欢使用谷歌搜索，可以更改默认搜索引擎。在设置中找到搜索引擎选项，选择你喜欢的搜索引擎（如Bing、Yahoo等）作为新的默认搜索引擎。
5、特殊功能与技巧：
离线阅读模式：对于想在没有网络的情况下阅读的文章，可以将其保存为离线阅读材料。在浏览器设置中找到“离线阅读”或“稍后阅读”的功能，按照提示操作即可保存网页内容。
点按字词搜索：在浏览网页时，如果遇到需要查询的词汇，只需长按该词汇，系统会弹出一个搜索选项。点击搜索，系统会自动在默认搜索引擎中查询该词的定义、解释等信息。
快速打开下载的文件：当你从网页下载文件后，通常会有一个通知提示。长按这个通知，可以选择打开下载的文件，而无需离开浏览器进入文件管理器。
此外，在使用手机谷歌浏览器时，还需要注意以下几点，以确保最优的上网体验：
1、定期清理缓存：使用一段时间后，浏览器会产生大量的缓存文件，这可能会占用大量存储空间并影响浏览器性能。定期清理缓存可以保持浏览器运行流畅。
2、利用安全功能：谷歌浏览器提供多种安全功能，如恶意软件防护、钓鱼攻击防护等。确保这些功能处于开启状态，可以更安全地浏览网页。
3、同步书签和密码：如果你在多个设备上使用谷歌浏览器，可以开启同步功能，这样书签、密码和打开的标签页就可以在不同设备之间自动同步，实现无缝切换。
以上就是关于手机谷歌浏览器如何使用的全部内容了，掌握好这些技巧之后，可以大大提升我们的网络浏览体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2424bdc440abe7021e060a4083c423b/" rel="bookmark">
			为什么要使用TikTok云手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着TikTok平台的日益繁荣，TikTok云手机作为一种新兴的运营工具，正以其独特的云端技术和用户体验，赢得广大用户的青睐。相较于传统手机，TikTok云手机通过云端技术为用户带来了一系列新的优势，让TikTok运营变得更加灵活、高效。那么，TikTok云手机究竟有哪些值得使用的理由呢？本文将深入探讨其优势，并分析为何它能在TikTok运营中脱颖而出。
TikTok云手机为用户提供了独立纯净的海外当地IP。这一特性使得用户能够更精准地定位目标受众，实现高效引流，同时避免了限流、封号等风险，让运营更加安心。
TikTok云手机实现了多设备通信的无缝切换。用户可以在手机、平板、电脑等多种设备上轻松使用，无需担心数据同步问题。通过云端存储，用户可以随时随地访问自己的数据，这种跨设备的便捷性极大地提升了TikTok运营的灵活性。
TikTok云手机采用轻量级系统，降低了系统负担，提高了运行性能。相较于传统手机繁重的系统，云手机更加流畅，启动速度更快，为用户带来更加顺畅的操作体验。
TikTok云手机还支持多账号运营。用户可以同时操作、管理多个TikTok账号，实现多元化营销和推广，提高运营效率。这一功能对于需要同时运营多个账号的商家来说，无疑是一个巨大的优势。
云手机还节省了存储空间与成本。由于大部分数据存储在云端，本地设备所需的存储空间大大减少，避免了频繁清理和升级的困扰。同时，购买云手机也能在一定程度上降低成本，实现更高效的投资回报。
TikTok云手机还具有节约能源环保的优点。通过云端计算和存储，降低了设备本地运算的需求，减少了功耗，符合绿色环保理念。
此外，云手机的系统和应用更新通常由云端服务器自动进行，用户无需手动操作，使得更新维护更为便捷。这种自动化的更新机制确保了用户始终能够享受到最新的功能和安全性保障。
综上所述，TikTok云手机不仅解决了传统手机在TikTok运营中的诸多痛点，还通过一系列创新功能，提高了运营效率，降低了成本。因此，越来越多的商家开始尝试使用TikTok云手机这一新工具，以实现更高效的TikTok运营。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0a8388c40089f56a45220ab08f2bab/" rel="bookmark">
			利用Geohash算法，快速检索周边兴趣点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、基本原理三、Geohash算法四、算法存在的问题五、代码实现六、问题解决处理 一、前言 需要一个需求，查找某小区附近的超市，如果该小区和超市距离在500米以内，则查找成功。
实现该功能按照传统方式，需要获取小区中心点坐标，然后500米半径做缓冲，然后对所有的超市点位和生成的缓冲区做空间分析，在缓冲区内的就是符合条件的超市。但是超市数据量很大，有什么方式能快速过滤超市数据呐？geohash是不错的方式，下面这种介绍geohash算法的原因和实现方式。
二、基本原理 GeoHash是一种地址编码方法。他能够把二维的空间经纬度数据编码成一个字符串。
（1） 按照经度范围[-180°,180°]，纬度范围[-90°,90°]对目标经纬度进行计算；二分经度和纬度范围区间，分别判断经度和纬度，在右侧集合则为1，在左侧集合则为0；循环进行此计算。
（2）将所得经纬度1和0结果，经度在偶数位（从0位计算），纬度在奇数位进行拼接，5位二进制结果为 一组，转换为十进制数后，再转换为对应Base32码表中数字，即得到对应GeoHash值。
具体分法：
经度范围是东经180到西经180，纬度范围是南纬90到北纬90，我们设定西经为负，南纬为负，所以地球上的经度范围就是[-180， 180]，纬度范围就是[-90，90]。如果以本初子午线、赤道为界，地球可以分成4个部分。
如果纬度范围[-90°, 0°)用二进制0代表，（0°, 90°]用二进制1代表，经度范围[-180°, 0°)用二进制0代表，（0°, 180°]用二进制1代表，那么地球可以分成如下4个部分
如果在小块范围内递归对半划分呢？
可以看到，划分的区域更多了，也更精确了。geohash算法就是基于这种思想，划分的次数更多，区域更多，区域面积更小了。通过将经纬度编码，给地理位置分区
三、Geohash算法 Geohash算法一共有三步。
首先将经纬度变成二进制。
第一步：
比如这样一个点（39.923201, 116.390705）
纬度的范围是（-90，90），其中间值为0。对于纬度39.923201，在区间（0，90）中，因此得到一个1；（0，90）区间的中间值为45度，纬度39.923201小于45，因此得到一个0，依次计算下去，即可得到纬度的二进制表示，如下表：
最后得到纬度的二进制表示为：
10111000110001111001 同理可以得到经度116.390705的二进制表示为：
11010010110001000100 第2步将经纬度合并：
经度占偶数位，纬度占奇数位，注意，0也是偶数位。
11100 11101 00100 01111 00000 01101 01011 00001 第3步，按照Base32进行编码：
Base32编码表的其中一种如下，是用0-9、b-z（去掉a, i, l, o）这32个字母进行编码。具体操作是先将上一步得到的合并后二进制转换为10进制数据，然后对应生成Base32码。需要注意的是，将5个二进制位转换成一个base32码。上例最终得到的值为
wx4g0ec1 Geohash比直接用经纬度的高效很多，而且使用者可以发布地址编码，既能表明自己位于北海公园附近，又不至于暴露自己的精确坐标，有助于隐私保护。
GeoHash用一个字符串表示经度和纬度两个坐标。在数据库中可以实现在一列上应用索引（某些情况下无法在两列上同时应用索引）
GeoHash表示的并不是一个点，而是一个矩形区域
GeoHash编码的前缀可以表示更大的区域。例如wx4g0ec1，它的前缀wx4g0e表示包含编码wx4g0ec1在内的更大范围。 这个特性可以用于附近地点搜索
编码越长，表示的范围越小，位置也越精确。因此我们就可以通过比较GeoHash匹配的位数来判断两个点之间的大概距离。
四、算法存在的问题 geohash算法有两个问题。首先是边缘问题。
如图，如果小区中心点在红点位置，区域内还有一个黄点。相邻区域内的绿点明显离红点更近。但因为黄点的编码和红点一样，最终找到的将是黄点。这就有问题了。
要解决这个问题，很简单，只要再查找周边8个区域内的点，看哪个离自己更近即可。
另外就是曲线突变问题。
本文第2张图片比较好地解释了这个问题。其中0111和1000两个编码非常相近，但它们的实际距离确很远。所以编码相近的两个单位，并不一定真实距离很近，这需要实际计算两个点的距离才行。
五、代码实现 public class GeoHash { public static final double MINLAT = -90; public static final double MAXLAT = 90; public static final double MINLNG = -180; public static final double MAXLNG = 180; private static int numbits = 3 * 5; //经纬度单独编码长度 private static double minLat; private static double minLng; private final static char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' }; //定义编码映射关系 final static HashMap&lt;Character, Integer&gt; lookup = new HashMap&lt;Character, Integer&gt;(); //初始化编码映射内容 static { int i = 0; for (char c : digits) lookup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af0a8388c40089f56a45220ab08f2bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e763f776e8036b2bad9873d02adcd59c/" rel="bookmark">
			MS SQL Server partition by 函数实战二 编排考场人员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求
输出效果
范例运行环境
表及视图样本设计
功能实现
生成考场数据
生成重复的SQL语句
封装为统计视图
编写存储过程实现统计
小结
需求 假设有若干已分配准考证号的考生，准考证号示例（01010001）共计8位，前4位为分类号，后4位为分类下的总排序号。现提供考场分配信息EXCEL文件（包括考场编号 、考场名称、考场容纳人数等），希望根据准考证号升序，将考生分配于对应的考场中，并生成对应的座位号（也即每一个考场的排序号），即分配原则为准考证号越小，考场号和座位号越靠前 。本文将继续介绍利用 partition by 、c# 来实现这一需求，主要实现如下功能：
（1）上传考场分布信息的EXCEL，导入生成考场信息数据。
（2）使用 C# 生成重复的SQL语句进行 union all 合并，生成考场座位信息。
（3）将准考证号信息左连接考场座位信息，生成考生分配明细表（包装为视图）。
（4）生成每个考场的准考证号以分类号（前4位）分组统计最小号和最大号范围。
输出效果 实现的考生准考证号分配表如下图：
如图，第1考场可容纳30人，座位号分配则从 1 到 30。分类为0101的准考证号在分配不开的情况下继续分配到 第2考场，座位号重新进行分配，以此类推。
另外，实现考场准考证号范围分类统计如下图：
如图，准考证号范围按前4位分组统计，输出最小号与最大号范围。 范例运行环境 操作系统： Windows Server 2019 DataCenter
数据库：Microsoft SQL Server 2016
.netFramework 4.7.1
开发工具：VisualStudio 2019 C#
表及视图样本设计 考场表 [dlzp_kc] 设计如下：
序号字段名类型说明备注1xm_ciduniqueidentifier所属项目ID比如某一考试项目2kcbhnvarchar(6)考场编号按固定位补位排序3kcmcnvarchar(50)考场名称4kcrssmallint考场人数 含准考证号的考生视图 v_ypz 设计如下：
序号字段名类型说明备注1xm_ciduniqueidentifier所属项目ID比如某一考试项目2zkzhchar(8)准考证号固定8位 根据设计 v_ypz 数据集记录大于等于考场记录数，因此使用左连接以显示考场座位数不足的情况统计。
准考证号考场范围分布情况表 dlzp_kc_zkzhs 设计如下：
序号字段名类型说明备注1xm_ciduniqueidentifier所属项目ID比如某一考试项目2kcbhnvarchar(6)考场编号 3kcmcnvarchar(50)考场名称冗余字段4zkzhsnvarchar(500)准考证号范围转多行为一行数据 功能实现 生成考场数据 根据提供的EXCEL考场文件，导入到考场表（dlzp_kc）中，如何将EXCEL文件导入成数据集，可参考我的文章《C#实现Excel合并单元格数据导入数据集》，成功导入后，在查询分析器示例如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e763f776e8036b2bad9873d02adcd59c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7946399cde54938c17c3b44c6ea4c4b/" rel="bookmark">
			鲲鹏服务器安装Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于项目需求，需要在鲲鹏云主机上安装Kafka，并且要求安装的版本为2.3.X。下面主要从以下几个步骤说明如何安装：
1、下载kafka的安装文件
2、上传到服务器
3、修改配置
4、启动
5、使用工具测试
服务器信息 CPU信息
[root@ecs02 ~]# lscpu Architecture: aarch64 CPU op-mode(s): 64-bit Byte Order: Little Endian CPU(s): 32 On-line CPU(s) list: 0-31 Thread(s) per core: 1 Core(s) per socket: 16 Socket(s): 2 NUMA node(s): 2 Vendor ID: HiSilicon Model: 0 Model name: Kunpeng-920 Stepping: 0x1 CPU max MHz: 2400.0000 CPU min MHz: 2400.0000 BogoMIPS: 200.00 L1d cache: 2 MiB L1i cache: 2 MiB L2 cache: 16 MiB L3 cache: 64 MiB NUMA node0 CPU(s): 0-15 NUMA node1 CPU(s): 16-31 Vulnerability Itlb multihit: Not affected Vulnerability L1tf: Not affected Vulnerability Mds: Not affected Vulnerability Meltdown: Not affected Vulnerability Spec store bypass: Not affected Vulnerability Spectre v1: Mitigation; __user pointer sanitization Vulnerability Spectre v2: Not affected Vulnerability Srbds: Not affected Vulnerability Tsx async abort: Not affected Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma dcpop asimd dp asimdfhm 操作系统信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7946399cde54938c17c3b44c6ea4c4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1974faded5261041972c54c46e6e42ef/" rel="bookmark">
			计算机毕业设计选题推荐-地震数据分析与预测-Python爬虫可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨作者主页：IT研究室✨
个人简介：曾从事计算机专业培训教学，擅长Java、Python、微信小程序、Golang、安卓Android等项目实战。接项目定制开发、代码讲解、答辩教学、文档编写、降重等。
☑文末获取源码☑
精彩专栏推荐⬇⬇⬇
Java项目
Python项目
安卓项目
微信小程序项目
文章目录 一、前言二、开发环境三、系统界面展示四、代码参考五、论文参考六、系统视频结语 一、前言 地震作为一种突发性自然灾害，对人类社会造成巨大的生命和财产损失。根据全球地震活动统计，每年大约发生18次显著地震，其中约有1/10可能造成严重灾害。地震预测和数据分析作为减轻地震灾害的重要手段，一直是地球科学研究的热点。然而，由于地震的复杂性和不可预测性，目前地震预测的准确率仍然较低，地震数据的实时分析和有效利用也面临挑战。例如，现有的地震监测系统可能存在数据报告延迟、分析方法单一、缺乏综合预测模型等问题。
鉴于现有地震数据分析与预测系统的不足，本课题旨在开发一个集成化的地震数据分析与预测平台。该平台将实现地震数据的实时监控、快速处理和多维度可视化展示，同时采用先进的数据分析技术和机器学习算法，提高地震预测的准确性和可靠性。本课题的研究目的在于提供一个更为精确和高效的地震分析工具，为地震科学研究、灾害预警和应急管理提供决策支持。
本课题的研究将推动地震学、数据科学和人工智能等领域的理论发展。通过深入分析地震数据的特征和模式，可以增进我们对地震发生机理的理解，为地震预测理论提供新的视角。此外，本课题还将探索数据驱动的地震预测方法，为相关领域的研究方法论提供创新。
实际而言，本课题的研究成果将对地震预警系统、灾害管理部门和公众安全教育产生积极影响。准确的地震预测和及时的数据分析结果可以帮助相关部门提前做好准备，减少地震灾害的损失。同时，可视化的地震数据分析工具也有助于提高公众对地震风险的认识，增强社会的整体抗灾能力。此外，随着技术的进步和数据量的增加，本课题的研究成果还可能为其他自然灾害的预测和分析提供参考。
二、开发环境 开发语言：Python数据库：MySQL后端：Django+Scrapy前端：Vue+Echarts 三、系统界面展示 地震数据分析与预测系统界面展示：
首页：
查看地震数据：
词云图：
可视化分析：
地震位置分布图：
周统计震级平均值：
地震时间热力图：
地震预测：
四、代码参考 项目实战代码参考： class EarthquakeDataSpider(scrapy.Spider): name = 'earthquake_data' allowed_domains = ['example.com'] # 替换为目标网站的域名 start_urls = ['http://example.com/earthquake-data'] def parse(self, response): # 假设地震数据是以表格形式展示 for row in response.css('table tr'): yield { 'event_date': row.css('td:nth-child(1)::text').get(), 'latitude': row.css('td:nth-child(2)::text').get(), 'longitude': row.css('td:nth-child(3)::text').get(), 'depth_km': row.css('td:nth-child(4)::text').get(), 'magnitude': row.css('td:nth-child(5)::text').get(), 'description': row.css('td:nth-child(6)::text').get(), } # 如果有分页，添加以下代码以处理分页 next_page = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1974faded5261041972c54c46e6e42ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966f3542ec3f68d78c8c4a70eb774e37/" rel="bookmark">
			MapBox Android版开发 1 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MapBox Android版开发 1 配置 前言MapBox V9 配置创建工程配置地图配置私钥配置公钥配置仓库配置依赖配置权限地图初始化 显示地图布局文件地图Activity 运行效果 MapBox V11 配置创建工程配置地图配置私钥配置公钥配置仓库配置依赖配置权限 显示地图布局文件 运行效果 前言 本文主要介绍如何使用MapBox SDK V9和 V11两个版开发Android地图应用。
准备工作：
注册MapBox账户获取公钥获取私钥（确保选中Downloads:Read，注意申请后只有一次机会复制机会） 主要步骤：
创建工程配置地图显示地图运行效果 MapBox V9 配置 创建工程 AndroidStudio 选择菜单 File → New → New Project... ，打开 New Project 对话框；选择模板 Empty Views Activity，单击Next；项目参数参考如下，设置后，单击Finish； 参数值NamemapdemoPackage namecom.example.mapdemoSave location默认路径或自定义路径即可LanguageJavaMinimum SDK默认推荐即可Build configuration languageGroovy DSL (build.gradle) 至此创建项目完成，目录结构如下： ├── app │ ├── build.gradle │ ├── libs │ ├── proguard-rules.pro │ └── src │ ├── androidTest │ ├── main │ └── test ├── build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966f3542ec3f68d78c8c4a70eb774e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af04a53a3ec1c28616fdeb6857c34ce/" rel="bookmark">
			【人工智能】Python融合机器学习、深度学习和微服务的创新之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 🚀 引言1.1 🚀 人工智能的现状与发展趋势1.2 📜 机器学习、深度学习和神经网络的基本概念1.3 🏆 微服务架构在人工智能中的作用 2. 🔍 机器学习的演变与创新2.1 🌟 机器学习的历史回顾2.2 🧠传统机器学习算法的优势与不足2.3 🚀 新兴机器学习算法的探索与应用2.4 🎙️案例分析：机器学习在推荐系统中的应用 3. 🧠 深度学习：突破传统的限制3.1 📜 深度学习的起源与发展3.2 📷 卷积神经网络（CNN）的革新3.3 📝 循环神经网络（RNN）与自然语言处理3.4 🎨 生成对抗网络（GAN）的应用与挑战3.5 🖼️ 案例分析：深度学习在图像识别中的应用 4. 🌐 神经网络的前沿进展4.1 💡神经网络的基本结构与工作原理4.2 🌟 多层感知机（MLP）的最新进展4.3 🔍 自注意力机制与变换器模型（Transformers）4.4 🚀 神经架构搜索（NAS）的未来趋势4.5 🎙️ 案例分析：神经网络在语音识别中的应用 5. 🛠️ 微服务架构：构建灵活的AI系统5.1 🏗️ 微服务的基本概念与架构设计5.2 📊 微服务与传统单体应用的比较5.3 🏆 微服务在AI系统中的优势5.4 📦 容器化与服务编排技术5.5 💡 案例分析：基于微服务的AI平台设计 6. 🌟 创新应用：将AI技术与微服务结合6.1 ⚡ 实时数据处理与AI服务的集成6.2 🔧 AI模型的版本控制与服务治理6.3 ⚖️ 动态扩展与负载均衡6.4 🤖 案例分析：微服务架构下的智能客服系统 7. 🔮 挑战与未来展望7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af04a53a3ec1c28616fdeb6857c34ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/237b797d94ca314aa2c803e66a324070/" rel="bookmark">
			【Java】—— Java实现模拟ATM提款功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇文章中，我们将学习如何使用Java编程语言来实现一个简单的ATM提款功能。我们将通过以下步骤来完成这个任务：
声明一个变量balance来记录银行账户的余额。使用Scanner类从用户那里获取输入。根据用户的选择执行存款、取款、显示余额和退出操作。关闭资源。 下面是完整的代码实现：
import java.util.Scanner; /* 题目：模拟ATM提款 声明变量balance并初始化为0，用以表示银行账户的余额，下面通过ATM机程序实现存款，取款等功能 =========ATM=========== 1、存款 2、取款 3、显示余额 4、退出 请选择（1-4）： */ public class DoWhileTest1 { public static void main(String[] args) { // 1、定义balance的变量，记录账户余额 double balance = 0; Scanner sc = new Scanner(System.in); // 实例化scanner boolean flag = true; // 控制循环结束 while (flag){ // 2、声明ATM取款界面 System.out.println("=========ATM==========="); System.out.println(" 1、存款"); System.out.println(" 2、取款"); System.out.println(" 3、显示余额"); System.out.println(" 4、退出"); System.out.print("请选择（1-4）："); // 3、使用scanner获取用户的准则 int selection = sc.nextInt(); // 4、根据用户的选择，决定执行存款、取款、显示余额、退出的操作 switch (selection){ case 1: System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/237b797d94ca314aa2c803e66a324070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea84f6b4cf323adb3797b653e165589/" rel="bookmark">
			音频导出后为什么效果变差了 FL Studio音频导出设置推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FL Studio是一款功能强大的编曲软件，除了可以编曲之外，FL Studio还支持各种音频格式导出。有的小伙伴在使用FL Studio导出音频后，会发现的导出的音频效果不理想，这很大的原因可能是导出设置不对造成的。下面给大家详细讲解，音频导出后为什么效果变差了，以及FL Studio音频导出设置推荐的相关内容。
FL Studio Win-安装包：https://souurl.cn/NQNkEh
FL Studio Mac-安装包：https://souurl.cn/gAPeSY
FL Studio 版本对比：https://souurl.cn/tmS3dI
FL Studio-fl 首页：https://souurl.cn/dw0RIY FL Studio-fl 下载：https://souurl.cn/PnyZpu FL Studio-fl 购买：https://souurl.cn/jIAnwK FL Studio-升级页：https://souurl.cn/ImbPGs FL Studio-FL七天训练营：https://souurl.cn/FctLyg 一、音频导出后为什么效果变差了
使用FL Studio音乐制作软件导出音频，音频效果变差，可能由两点原因导致的。第一点是播放器问题，第二点是FL Studio导出设置问题。下面给大家详细讲解。
现在市面上很多的音频播放器，为了让音频听起来更加的饱满，会在播放音频的时候，对音频进行渲染处理。使用FL Studio导出的音频的时候，也是为了让音频更加有层次感，也会对音频进行渲染处理，这就导致音频在播放的时候，进行了二次渲染，音频播放的效果也就变差了。
现在大多部分的音频文件都是MP3格式，这种音频格式的兼容性非常好，但是整体音频质量却比较一般。很多小伙伴在使用FL Studio导出音频文件的时候，并不知道这一点，会将音频文件导出为MP3格式，这样就会损失给音频添加的一些效果器。在使用FL Studio导出音频的时候，最好是将音频导出为WAV格式，不过需要注意的是这种格式兼容性较差。
图1：FL Studio
二、FL Studio音频导出设置推荐
在使用FL Studio导出的音频的时候，会发现，有些小伙伴导出的音频质量很高，有些小伙伴导出的音频质量却一般，导致这一问题的原因，主要是音频导出设置不同。下面给大家详细讲解具体设置操作。
1.FL Studio保存设置窗口分为四大模块，分别是项目类型、音频格式、品质、其他。
图2：FL Studio保存设置窗口
2.项目类型有两个参数模式和尾音。一般模式选择“完整歌曲”，尾音选择“剪切剩余部分”。
模式：这个参数有两个选项，完整歌曲和样式。完整歌曲是将整首歌曲都导出。样式是只导出歌曲样式。
尾音：这个参数有三个选项，剪切剩余部分、保留剩余部分、返回剩余部分。剪切剩余部分是只导出播放列表中歌曲的长度，剩余的混响延音效果会被剪切掉。保留剩余部分是歌曲和效果都会被保存下来。返回剩余部分是将多余歌曲本身长度的混响延迟，放到歌曲开头部分进行保存输出。
图3：FL Studio音频类型设置
3.音频格式有很多种，一般常使用到的是MP3格式和WAV格式。MP3格式音频质量较WAV格式差一些，WAV格式的兼容性较MP3差一些。
图4：FL Studio音频格式设置
4.品质的重采样设置的是音频的采样率，最好的采样率是512点正弦。禁用最大复调可以节省CPU利用率。
图5：FL Studio音频品质设置
5.其他里面的参数设置主要看导出音频是否需要，不一定要进行设置，可以使用默认设置。
图6：FL Studio音频其他设置
三、FL Studio怎么将音频转换为MIDI
在FL Studio中想要将音频文件转换为MIDI，需要用到Edison插件，下面给大家演示具体操作步骤。
1.在FL Studio播放列表中双击音频文件，在弹出的窗口鼠标右键底部的波形音频，选择“在音频编辑器中编辑”。或者使用快捷键Ctrl+E直接打开Edison编辑窗口。
图7：选择“在音频编辑器中编辑”
2.在“Edison”窗口，点击板斧图形工具按钮，选择“转换为乐谱并转储到钢琴卷帘”，音频文件就会自动转换到钢琴卷帘窗口。
图8：“Edison”窗口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea84f6b4cf323adb3797b653e165589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6757bee57d3ebe4daf2dcac97698e8ba/" rel="bookmark">
			鸿蒙HarmonyOS实战：创建NDK工程、毕昇编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NDK适用场景 适合使用NDK的场景：应用涉及如下场景时，适合采用NDK开发
性能敏感的场景，如游戏、物理模拟等计算密集型场景。
需要复用已有C或C++库的场景。
需要针对CPU特性进行专项定制库的场景，如Neon加速。
不建议使用NDK的场景：应用涉及如下场景时，不建议采用NDK开发
纯C或C++的应用。
希望在尽可能多的HarmonyOS设备上保持兼容的应用。
NDK必备 为顺利进行NDK开发，开发者需要先掌握必要的基本概念及基础知识。
NDK基本 Node-APINode-APINode-API
曾用名NAPI，是HarmonyOS中提供ArkTS/JS与C/C++跨语言调用的接口，是NDK接口中的一部分。该接口是在Node.js提供的Node-API基础上扩展而来，但与Node.js中的Node-API不完全兼容。
C API
HarmonyOS NDK的曾用名，不再使用。
前置知识 Linux C语言编程知识
内核、libc基础库基于POSIX等标准扩展而来，掌握基本的Linux C编程知识能够更好的帮助理解HarmonyOS NDK开发。
CMake使用知识
CMake是HarmonyOS默认支持的构建系统。请先通过CMake官方文档了解基础用法。
Node Addons开发知识
ArkTS采用Node-API作为跨语言调用接口，熟悉基本的Node Addons开发模式，可以更好理解NDK中Node-API的使用。
Clang/LLVM编译器使用知识
具备一定的Clang/LLVM编译器基础知识，能够帮助开发者编译出更优的Native动态库。
NDK目录 build目录：放置预定义的toolchain脚本文件ohos.toolchain.cmake
CMake编译时需要读取该文件中的默认值，比如编译器架构、C++库链接方式等，因此在编译时会通过CMAKE_TOOLCHAIN_FILE指出该文件的路径，便于CMake在编译时定位到该文件。
build-tools文件夹：放置NDK提供的编译工具
# 键入下一行命令查看CMake的版本 cmake -version # 结果 cmake version 3.16.5 CMake suite maintained and supported by Kitware (kitware.com/cmake). llvm文件夹：放置NDK提供的编译器
NDK常用模块 下表介绍了NDK的常用模块。
模块模块简介标准C库以musl为基础提供的标准C库接口。标准C++库C++运行时库libc++_shared。日志打印日志到系统的HiLog接口。Node-API当需要实现ArkTS/JS和C/C++之间的交互时，可以使用Node-API。libuv三方异步IO库。zlibzlib库，提供基本的数据压缩、解压接口。Rawfile应用资源访问接口，可以读取应用中打包的各种资源。XComponentArkUI XComponent组件提供surface与触屏事件等接口，方便开发者开发高性能图形应用。Drawing系统提供的2D图形库，可以在surface进行绘制。OpenGL系统提供的OpenGL 3D图形接口。OpenSL ES用于2D、3D音频加速的接口库。 创建NDK工程 下面通过DevEco Studio的NDK工程模板，来演示如何创建一个NDK工程。
不同DevEco Studio版本的向导界面、模板默认参数等会有所不同，请根据实际工程需要，创建工程或修改工程参数。
通过如下两种方式，打开工程创建向导界面。
如果当前未打开任何工程，可以在DevEco Studio的欢迎页，选择Create Project开始创建一个新NDK工程。如果已经打开了工程，可以在菜单栏选择File &gt; New &gt; Create Project来创建一个新NDK工程。 根据工程创建向导，选择Native C++工程模板，然后单击Next。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6757bee57d3ebe4daf2dcac97698e8ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d40c920999311e570e4232e328115d90/" rel="bookmark">
			【vue】编辑器段落对应材料同步滚动交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景需求 编辑器段落对应显示材料编辑器滚动时，材料同步滚动编辑器段落无数据时，材料不显示 实现方法 编辑器与材料组件左右布局获取编辑器高度，材料高度与编辑器高度一致禁用材料组件的滚动事件获取编辑器段落距离顶部的位置，对应材料的顶部高度与段落一致监听编辑器滚动高度，对应材料组件同步滚动当段落为空时，材料不显示当段落比材料短的时候，对应材料进行下移，避免材料重叠 html代码 // 编辑器中段落代码 &lt;div class="ws-container"&gt; &lt;div class="ws-result" data-set="第一段" data-set-code="dyd" :style="[normal]"&gt; &lt;div :style="[indentbase]"&gt;这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段这是第一段&lt;/div&gt; &lt;/div&gt; &lt;div class="ws-result" data-set="第二段" data-set-code="ded" :style="[normal]"&gt; &lt;div :style="[indentbase]" &gt;这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段这是第二段&lt;/div&gt; &lt;/div&gt; &lt;div class="ws-result" data-set="第三段" data-set-code="dsd" :style="[normal]"&gt; &lt;div :style="[indentbase]"&gt;这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段这是第三段&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; // 对应段落材料代码 &lt;div class="doc-source" @touchmove.prevent @mousewheel.prevent&gt; &lt;div ref="sourceMode"&gt; &lt;div class="source-mode" :ref="index" v-for="(item, index) in list" :key="index"&gt; &lt;div class="source-mode-item" v-for="(item1, index1) in item" :key="index1" :title="item1.name"&gt; &lt;div class="flag"&gt;&lt;/div&gt; &lt;div class="file"&gt;来源：{{ item1.name}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; JS代码 export const SOURCEMODE = [ { name: '第一段', code: 'dyd' }, { name: '第二段', code: 'ded' }, { name: '第三段', code: 'dsd' }, ]; // 编辑器更新时 contentChange() { const dom = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d40c920999311e570e4232e328115d90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64bc8d0184c84d53c9d7eacc9c56add2/" rel="bookmark">
			web的发展历史,互联网和万维网的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OpenSNN开思通智网，官网地址：https://w3.opensnn.com/
2024年8月份 “O站创作者招募计划”
快来O站写文章，千元等你来拿！
“一起来O站，玩转AGI！”
web的发展历史 Web（万维网，World Wide Web）的发展历史是一段非常重要的技术进步和社会变革的历程。以下是Web发展的关键阶段：
1. Web的诞生 (1989-1991) 提出概念：Web的概念由英国科学家蒂姆·伯纳斯-李（Tim Berners-Lee）在1989年首次提出。当时他在欧洲核子研究组织（CERN）工作，提出了一种通过超文本链接在计算机之间共享信息的方式。第一款Web浏览器：1990年，伯纳斯-李开发了世界上第一个Web浏览器和编辑器，称为“WorldWideWeb”（后更名为Nexus）。第一个网站：1991年8月6日，伯纳斯-李发布了第一个网站，网址是http://info.cern.ch，这标志着Web的正式诞生。 2. Web 1.0时代 (1991-2004) 静态网页：Web 1.0主要是由静态网页组成，用户只能查看信息，无法与内容互动。网页通常使用HTML语言编写，内容固定，缺乏互动性。早期浏览器：Netscape Navigator（1994年发布）和Internet Explorer（1995年发布）是这一时期的代表性浏览器。搜索引擎的出现：1990年代中期，Yahoo、AltaVista、Lycos等早期搜索引擎开始出现，使得用户可以更方便地在Web上查找信息。 3. Web 2.0时代 (2004-2010) 动态内容与用户生成内容：Web 2.0引入了动态网页和用户生成内容（UGC）的概念。网站不再只是发布者单向提供内容，用户也可以互动、评论、分享、编辑内容。博客、维基、社交网络等都是这一时期的产物。社交媒体的崛起：2004年，Facebook的推出标志着社交媒体时代的来临。随后，YouTube（2005年）、Twitter（2006年）等平台迅速普及。AJAX技术：AJAX（Asynchronous JavaScript and XML）技术的普及，使得Web应用程序能够以更快、更流畅的方式进行数据传输，改善了用户体验。 4. Web 3.0时代 (2010年至今) 语义Web与智能化：Web 3.0被认为是语义Web的时代，旨在让计算机能够理解和处理Web上的数据，以提供更智能的服务。搜索引擎变得更加精准，个性化推荐系统逐渐成熟。区块链与去中心化：区块链技术的兴起推动了去中心化Web（即Web 3.0）的概念，人们可以通过去中心化应用（DApps）来更安全和私密地进行互动。移动互联网与云计算：随着智能手机的普及和云计算的发展，Web服务不再局限于桌面设备，而是随时随地可用，移动Web应用成为主流。 5. 未来展望 扩展现实 (XR) 与元宇宙：虚拟现实（VR）、增强现实（AR）和混合现实（MR）技术的进步推动了Web在三维空间中的发展，未来Web可能会扩展到元宇宙（Metaverse）中，提供更加沉浸式的用户体验。人工智能的深度融合：AI将进一步与Web融合，带来更加个性化、智能化的应用，改变用户与Web的互动方式。 Web的发展不仅改变了信息的传播方式，也深刻影响了全球社会、经济和文化。随着技术的不断进步，Web将继续演变，带来更多创新和机遇。
互联网和万维网，是什么关系 互联网（Internet）和万维网（World Wide Web，简称Web）虽然常常被混淆，但它们实际上是两个不同的概念，彼此之间有着密切的关系。
1. 互联网（Internet） 定义：互联网是全球范围内由一系列计算机网络组成的网络，允许计算机之间互相通信和共享资源。它可以看作是一个基础设施，连接了全球各地的计算设备，使它们能够交换数据。历史：互联网的起源可以追溯到1960年代，由美国国防部开发的ARPANET项目发展而来。随着时间的推移，互联网逐渐演变为一个全球性的网络体系，支持各种协议和服务。功能：互联网不仅支持Web，还支持电子邮件、文件传输、即时消息、在线游戏、视频会议等多种服务。 2. 万维网（World Wide Web） 定义：万维网是建立在互联网上的一种信息系统，它允许用户通过浏览器访问由超文本标记语言（HTML）编写的网页。Web是互联网的一部分，但它并不是互联网的全部。发明：万维网由蒂姆·伯纳斯-李在1989年发明，旨在通过超文本链接在全球范围内共享信息。Web使用了HTTP（超文本传输协议）和URL（统一资源定位符）等技术，使用户能够通过浏览器访问和浏览网页。内容：Web的内容主要包括文本、图像、视频等多媒体信息，用户可以通过点击超链接在不同的网页之间导航。 3. 两者之间的关系 依赖性：万维网依赖于互联网的存在。没有互联网这个底层网络，万维网无法运作。互联网是承载万维网的基础设施，而万维网是互联网的一种应用。组成部分：互联网包含了很多不同的服务和协议，Web只是其中之一。除了Web，互联网还包括电子邮件（SMTP）、文件传输（FTP）、远程登录（SSH）等多种协议和应用。用户体验：对于大多数用户而言，他们的互联网体验很大程度上是通过Web来实现的。Web使得互联网的内容更加可视化和易于访问，但互联网的作用远不止于此。 总结来说，互联网是全球范围的网络基础设施，而万维网是运行在这之上的一个信息系统和服务。万维网让互联网更易于使用和访问，但互联网还支持其他许多应用和服务。
【转载自:】OpenSNN开思通智网 ---- “一起来O站，玩转AGI！”
【官网:】https://w3.opensnn.com/
【原文链接:】https://w3.opensnn.com/os/article/10001264
结束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919748c41940770a23cc074f47e42a47/" rel="bookmark">
			场外个股期权是不是个股期权？场外个股期权和个股期权的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天带你了解场外个股期权是不是个股期权？场外个股期权和个股期权的区别。场外个股期权是指在沪深交易所之外交易的个股期权，其本质是一种金融衍生品，允许投资者在股票交易场所外以特定价格买进或卖出证券。
个股期权作为一种重要的投资工具，为投资者提供了多样化的风险管理和投资策略。 然而，个股期权又可分为场内交易和场外交易两种形式，它们在交易机制、监管规则和流动性等方面存在显著差异。
场内个股期权是指在交易所内进行的标准化合约交易。这些合约具有统一的规格，包括行权价格、到期日等，且交易过程受到严格的监管。
场外个股期权则是指在交易所之外，由买卖双方直接协商达成的个性化合约。这种交易方式更加灵活，可以根据投资者的具体需求定制合约条款。
对于寻求个性化投资策略和更高风险回报的投资者，场外个股期权则提供了更多的灵活性和潜在收益。
个股场外期权交易的下单流程如下： 1、投资者需要向场外期权机构，类似期权懂，提交询价单，其中包括感兴趣的股票以及期权交易的时间等相关信息。
2、期权懂机构会根据你提供的信息给出一个期权价格，你需要确认是否接受这个报价。如果接受报价，你需要下达购买或卖出的交易指令。
3、每日估值报告，提前平仓，到期清算报告，现金了结，走到这一步其实就是标志着该项交易正式结束。
场外个股期权和个股期权的主要区别在于交易方式和合约标准化程度： 1.交易方式： 场外个股期权（OTC期权）：这种期权是在场外市场进行的，交易双方可以直接协商期权合约的条款，包括标的资产、行权价格、到期时间等。由于是场外交易，合约不标准化，更具灵活性。
个股期权：这种期权是在证券交易所上市交易的，合约条款标准化，交易过程公开透明，流动性较高，受交易所监管。
2.标准化程度： 场外个股期权：不标准化，交易双方可以根据需要量身定制。
个股期权：高度标准化，合约条款由交易所统一规定。
3.流动性和市场透明度： 场外个股期权：流动性较低，市场透明度较低，交易信息通常不公开。
个股期权：流动性较高，市场透明度较高，交易信息公开，投资者可以随时查看市场价格和交易量。
以上就是“场外个股期权是不是个股期权？场外个股期权和个股期权的区别”的全部内容，希望本文能给您带来帮助，在未来市场交易中收获满满，财源广进！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/34/">«</a>
	<span class="pagination__item pagination__item--current">35/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/36/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>