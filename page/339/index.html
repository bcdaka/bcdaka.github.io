<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5cd1b3e318a4f0a4092220ad310fb2/" rel="bookmark">
			数独游戏详解（附有Python详细代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数独游戏是一种源自18世纪末欧洲的逻辑谜题游戏,在20世纪初在美国获得了广泛的流行。它的规则简单明了,但要解决一个困难的数独游戏实际上是一个NP完全的问题,需要采用各种算法和启发式方法来有效地解决。因此,数独游戏不仅是一种有趣的益智游戏,也是一个非常有价值的数学问题,可以用来研究人工智能算法和组合优化技术。
数独游戏的规则 数独游戏是在一个9x9的网格中进行的,网格分为9个3x3的小方块。游戏开始时,网格中已经填入了一些数字,玩家需要根据这些已有的数字提示,填入1到9之间的数字,使得每一行、每一列和每一个3x3的小方块中,都包含1到9的数字,且不重复。
一个完整的数独谜题有且只有一个解决方案。虽然规则看似简单,但要解决一个困难的数独游戏实际上是一个NP完全的问题,需要采用各种算法和启发式方法来有效地解决。
数独游戏的历史 数独游戏起源于18世纪末的瑞士,当时被称为"拉丁方阵"或"格子游戏"。1892年,法国数学家拉雷弗在一本杂志上发表了一个关于这种游戏的文章,并将其命名为"数独"。
1979年,香港出版商邵夷尧在一本名为《数独》的书中,将这种游戏推广到了更广泛的范围。同年,一家日本出版社将数独引进日本,并在报纸和杂志上连载,受到了极大的欢迎。
数独游戏在20世纪80年代和90年代期间在日本非常流行,并逐渐传播到了世界其他地区。2005年,数独游戏在英国和美国掀起了一股热潮,成为报纸和杂志上的常见内容。从那时起,数独游戏在世界范围内获得了极大的普及。
数独游戏的复杂性 虽然数独游戏的规则看起来非常简单,但要解决一个困难的数独游戏实际上是一个NP完全的问题。NP完全问题是一类最难解决的问题,即使使用最快的算法和最快的计算机,解决这类问题所需的时间也会随着问题规模的增长而指数级增长。
具体来说,解决一个数独谜题需要从981种可能的解决方案中找到唯一正确的解决方案。这个数字非常庞大,大约等于1047。换句话说,即使使用最快的计算机,也需要耗费大量的计算资源来解决一个困难的数独谜题。
因此,在实际应用中,通常会采用各种算法和启发式方法来有效地解决数独游戏,例如回溯算法、约束传播算法、Dancing Links算法等。这些算法通过剪枝和优化策略,可以大大减少需要搜索的空间,提高求解效率。
下面是一个使用Python实现的数独求解器的代码示例,它采用了回溯算法(backtracking)来解决这个问题。
def solve_sudoku(board): """ 使用回溯算法解决数独谜题 :param board: 表示数独谜题的二维列表 :return: 如果有解决方案,返回True;否则返回False """ # 找到第一个空白单元格 row, col = find_empty(board) # 如果没有空白单元格,说明已经解决了数独谜题 if row == -1 and col == -1: return True # 尝试在当前单元格填入1到9的数字 for num in range(1, 10): # 如果当前数字可以填入该单元格 if is_valid(board, row, col, num): # 填入数字 board[row][col] = num # 递归调用函数,尝试解决剩余的数独谜题 if solve_sudoku(board): return True # 如果填入的数字无法解决数独谜题,清空单元格并尝试下一个数字 board[row][col] = 0 # 如果所有数字都无法解决数独谜题,返回False return False def find_empty(board): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b5cd1b3e318a4f0a4092220ad310fb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e9eb73d1d87b9717933fe73b3ab1fe/" rel="bookmark">
			Stable Diffusion系列（三）：网络分类与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络分类模型基座模型衍生模型二次元模型2.5D模型写实风格模型 名称解读 VAELora嵌入文件放置界面使用 网络分类 当使用SD webui绘图时，为了提升绘图质量，可以多种网络混合使用，可选的网络包括了模型、VAE、超网络、Lora和嵌入。
其中，模型就是我们所熟知的最核心的生成图片的稳定扩散模型，不需要额外的文件就可以直接运行，大小也最大，通常在2GB以上。
而其他网络本质上是依附于模型的插件，不能独立运行。在这其中，VAE是模型中用于从潜空间生成图片的网络模块，大小通常为几百MB，注意模型本身自带VAE，但是你可以用选择的其他VAE替换掉这部分；超网络是添加到交叉注意力层的附加网络模块，会改变模型结构，大小通常为几百MB；Lora（Low-Rank Adaption，低秩自适应）可以修改交叉注意力层的参数权重，不改变模型结构，大小同样为几百MB；嵌入则可以看做是一种特殊的提示词，它可以影响模型对文本的编码层，通常为 10-100 KB。
从效果和流行程度上来看，VAE&gt;Lora&gt;嵌入&gt;&gt;超网络，所以接下来我们重点介绍模型、VAE、Lora和嵌入这几部分。
模型 基座模型 虽然当你打开熟悉的C站寻觅模型时，可能会看到各种奇奇怪怪让人眼花缭乱的名字，但这些模型并不是创作者自己从零开始创造的，而是基于Stable Diffusion官方发布的一系列基座模型训练而来。在模型卡片的右侧，可以看到它所基于的基座模型（Base Model）：
按发展的时间顺序，基座模型有这样几个系列：
SD1.X：包括了最早的SD1.4和SD1.5，图像大小一般为512×512，没有什么生成限制，SD1.5至今长盛不衰。SD2.X：包括了后来的SD2.0和SD2.1及其生成图片大小为768的版本。注意这类模型虽然在绘画效果尤其是手部上更好，但不支持NSFW和名人内容，因此并不受欢迎。SDXL：参数量大大增加，对自然语言的理解能力大大增强，生成画面更加细腻真实，生成尺寸一般设为1024×1024。基座模型包括一个基础生图模型和一个用于精修的Refiner模型，使用时分文生图和图生图两阶段。SDXL Turbo：基于SDXL 1.0开发而成，由于使用了一种全新的对抗扩散蒸馏技术（ADD），可将图像所需的生成步骤减少至1—4步，从而实现秒级出图。 衍生模型 上述基座模型的图片生成能力一般比较平庸但均衡，基于这些基座模型，开发者可以使用谷歌提出的Dreambooth方法（Dreambooth : It’s like a photo booth, but once the subject is captured, it can be synthesized wherever your dreams take you）在自己构建的数据集上做微调，使其特别擅长生成某种主题或风格的图片，也就是特定领域的衍生模型。这也是目前最为广泛使用的一类模型。
按照生成的风格不同，衍生模型大致可分为二次元模型、2.5D模型和写实风格模型，下面将具体介绍一些常用模型的信息和使用方法。
二次元模型 顾名思义，主打动漫风格的模型。
OrangeMixs https://civitai.com/models/4769?modelVersionId=5460
生成高质量、高度逼真的插图，基于 Basil_Mix
命名规则
_sfw：SFW（全年龄模型）
_nsfw : SFW ~ 软 NSFW (R16状态)
_hard : SFW ~ 硬 NSFW（R18G状态）
Anything https://civitai.com/models/66/anything-v3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e9eb73d1d87b9717933fe73b3ab1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5729bb4e3c07c0328326b0db523e1b40/" rel="bookmark">
			使用 Django 和 RabbitMQ 构建高效的消息队列系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 RabbitMQ 简介Django 中使用 RabbitMQ总结与拓展 在现代的 Web 应用程序开发中，构建一个高效的消息队列系统变得越来越重要。使用消息队列可以帮助我们解耦系统中不同模块的任务，并提高系统的性能和可扩展性。本文将介绍如何结合 Django 和 RabbitMQ 来构建一个高效的消息队列系统。
RabbitMQ 简介 RabbitMQ 是一个流行的开源消息队列系统，它支持多种消息协议，包括 AMQP、STOMP 和 MQTT。RabbitMQ 提供了高度可靠的消息传递机制，并且具有良好的性能和可扩展性，因此成为了许多开发人员首选的消息队列系统。
Django 中使用 RabbitMQ 首先，我们需要安装 celery 和 django-celery 库来实现 Django 与 RabbitMQ 的集成。在项目的 requirements.txt 文件中添加以下依赖：
celery==5.2.2 django-celery==3.3.1 然后使用 pip 安装这些依赖：
pip install -r requirements.txt 接下来，在 Django 项目的配置文件中进行如下配置：
# settings.py # 使用 RabbitMQ 作为消息队列 CELERY_BROKER_URL = 'amqp://localhost' CELERY_RESULT_BACKEND = 'rpc://' 以上配置指定了 RabbitMQ 的地址作为消息队列的后端，并且指定了 RPC 作为结果后端。
接着，创建一个 tasks.py 文件来定义 Celery 任务：
# tasks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5729bb4e3c07c0328326b0db523e1b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7520c978057726050c68e04597a13b/" rel="bookmark">
			“提升人工智能大模型智能：策略与挑战“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 每日一句正能量前言算法创新数据质量与多样性模型架构优化后记 每日一句正能量 失败时可以称为人生财富，成功时可以称为财富人生。
前言 随着人工智能技术的飞速发展，大模型已经成为推动多个领域创新的关键力量。从自然语言处理到图像识别，再到复杂的决策支持系统，大模型正在逐步改变我们的生活和工作方式。然而，尽管这些模型在特定任务上展现出了令人瞩目的性能，它们在理解力、泛化能力和适应性等方面仍然面临着挑战。
理解力是大模型面临的一个核心问题。当前的模型虽然能够处理和生成语言，但它们往往缺乏对语境、隐喻和幽默等深层次语义的真正理解。此外，泛化能力也是限制大模型应用的一个重要因素。许多模型在特定数据集上表现出色，但当面对新的或不同的数据时，它们的性能往往会显著下降。适应性问题也同样关键，大模型需要能够快速适应新的任务和环境，而不是仅仅在预设的任务上表现良好。
为了克服这些挑战，研究人员和工程师们正在探索多种方法来提升大模型的智能。这包括改进算法以增强模型的理解力，开发更有效的训练策略来提高泛化能力，以及设计更灵活的模型架构来增强适应性。此外，跨学科的合作也越来越被认为是推动大模型发展的重要途径，结合认知科学、心理学和神经科学等领域的知识，可能会为大模型的智能提升提供新的视角。
本文将探讨如何让大模型变得更聪明的问题，分享当前的研究进展、面临的挑战以及未来的发展方向。我们诚邀来自不同领域的专家和爱好者共同参与讨论，分享您的见解和想法，共同推动人工智能技术的创新和进步。
算法创新 在人工智能领域，算法创新是推动技术进步的关键因素。以下是几个关键点，探讨如何通过算法创新来提高模型的学习和推理能力：
深度学习架构的改进：
研究和开发新的神经网络架构，如卷积神经网络（CNN）的变体，循环神经网络（RNN）及其高级形式，例如长短期记忆网络（LSTM）。 强化学习：
通过强化学习算法，使模型能够在与环境的交互中学习并做出决策，提高其在动态和不确定环境中的表现。 无监督和半监督学习：
探索无监督学习算法，以便模型能够从未标记的数据中学习，以及半监督学习算法，结合少量标记数据和大量未标记数据提高学习效率。 生成对抗网络（GANs）：
利用GANs生成高质量数据，提高模型在图像、视频和音频处理等方面的能力。 元学习（Meta-Learning）：
研究元学习算法，使模型能够学会如何快速适应新任务，提高其泛化能力和适应性。 注意力机制和Transformer模型：
利用注意力机制和Transformer架构改进序列模型，增强模型处理长距离依赖关系的能力。 知识蒸馏：
通过知识蒸馏技术，将大型复杂模型的知识迁移到更小、更高效的模型中。 多任务学习：
开发多任务学习算法，使模型能够同时学习完成多个相关任务，提高模型的通用性和效率。 可解释性和透明度：
研究提高模型可解释性的算法，帮助人们理解模型的决策过程，增强对模型的信任。 跨学科融合：
结合认知科学、心理学等领域的知识，开发能够模拟人类思维和推理的算法。 优化算法：
改进现有的优化算法，如梯度下降及其变体，以提高训练过程的效率和稳定性。 隐私保护学习：
研究差分隐私、联邦学习等技术，使模型能够在保护用户隐私的前提下进行学习。 通过这些算法创新，可以不断提高AI模型的学习能力、推理能力、泛化能力和适应性，推动人工智能技术向更高水平发展。同时，算法创新也需要考虑伦理和社会影响，确保技术进步能够造福人类社会。
数据质量与多样性 在人工智能和机器学习领域，训练数据的质量和多样性对于构建高效、健壮的模型至关重要。以下是一些关键点，探讨如何通过确保数据的高质量和多样性来增强模型的泛化能力：
数据清洗：
通过数据预处理技术，如去噪、异常值检测和填补缺失值，提高数据质量。 数据标注：
确保数据标注的准确性，使用专业的标注团队，并制定清晰的标注指南。 数据多样性：
收集来自不同来源、具有不同特征的数据，以确保模型能够处理各种情况。 数据平衡：
处理类别不平衡问题，确保模型不会对多数类产生偏见。 数据增强：
应用数据增强技术，如图像旋转、缩放、裁剪等，增加数据的多样性。 多模态学习：
结合来自不同模态的数据，如文本、图像、声音和视频，提高模型的理解和推理能力。 领域适应：
通过领域适应技术，使模型能够适应不同的应用场景和数据分布。 主动学习：
采用主动学习策略，让模型能够识别并请求标注最有价值的数据点。 集成学习：
使用集成学习方法，结合多个模型的预测，提高整体性能和泛化能力。 数据隐私：
在收集和使用数据时，确保遵守数据隐私法规和伦理标准。 数据集划分：
合理划分训练集、验证集和测试集，确保模型在未见过的数据上也能表现良好。 数据集评估：
定期评估数据集的质量，包括覆盖度、平衡性和代表性。 跨文化和跨语言数据：
包含跨文化和跨语言的数据，以提高模型在全球化应用中的泛化能力。 长期数据监控：
建立长期的数据监控机制，确保数据集随着时间推移仍然保持高质量和相关性。 开放数据集：
利用和贡献开放数据集，促进研究社区的数据共享和模型的公平比较。 通过这些措施，可以显著提高训练数据的质量和多样性，从而增强模型的泛化能力，使模型在面对新情况和未知数据时表现更加稳定和可靠。此外，确保数据的高质量和多样性也是实现人工智能公平性、可解释性和透明度的重要基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d7520c978057726050c68e04597a13b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb92a195fb4e4feb84b38fbd42cef78/" rel="bookmark">
			AI大模型探索之路-实战篇9：探究Agent智能数据分析平台的架构与功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-实战篇4：深入DB-GPT数据应用开发框架调研
AI大模型探索之路-实战篇5：探索Open Interpreter开放代码解释器调研
AI大模型探索之路-实战篇6：掌握Function Calling的详细流程
AI大模型探索之路-实战篇7：Function Calling技术实战自动生成函数
AI大模型探索之路-实战篇8：多轮对话与Function Calling技术应用
目录 系列篇章💥前言一、平台概览与核心特性二、架构设计说明三、数据字典说明四、指标字典说明五、平台技术选型六、项目调研七、核心功能分析结语 前言 随着数据量的激增和业务复杂性的提升，企业和组织对高效、精准的数据分析工具的需求日益增强。智能数据分析平台因此应运而生，它结合了最新的人工智能技术，尤其是大型语言模型，来解析用户的自然语言查询，并实现这些查询到数据库操作的转换。这种创新不仅提升了数据分析的效率和准确性，还极大地改善了用户体验。
本文将详细介绍这一平台的架构设计、核心技术、以及实现方法。我们的目标是展示如何构建一个功能强大、用户友好且高度可靠的数据分析工具，它将支持交互式数据探索和智能分析，适用于各种业务场景。
通过深入探讨相关的技术细节和应用实例，希望能够提供实施或优化智能数据分析平台时的实用指南和灵感。随着技术的不断进步，我们期待看到这类平台在未来发挥更大的作用，帮助企业和组织实现数据驱动的决策和增长。
一、平台概览与核心特性 智能数据分析平台旨在通过最新的人工智能技术，尤其是大型语言模型，为用户提供一个高效、直观的数据查询和分析工具。该平台允许用户通过自然语言提出数据相关的问题或查询，内部的大型语言模型处理这些自然语言请求，将其转换为数据库可执行的SQL命令。这种转换能力不仅减少了技术门槛，也优化了数据分析的流程，使其更加自动化和智能化。
核心特性包括：
自然语言支持：用户可以依靠自己的语言表达数据需求，降低了学习SQL等数据查询语言的需求。互动式操作：在执行由自然语言生成的SQL命令前，系统会提示用户进行确认，确保查询的准确性，从而避免潜在的错误和风险。记忆功能：平台具备一定的长短期记忆能力，能够记住用户的历史查询和数据字典中的业务逻辑，用以提升后续查询的效率和准确性。智能分析：利用内置的智能算法和数据字典，平台能够对数据进行深入分析，提供超出简单SQL查询的分析见解。稳定性：平台的设计和实施需要考虑到了数据处理的稳定性和可靠性，确保高频及复杂查询的顺畅执行。图表展示：提供丰富的数据可视化选项，帮助用户更直观地理解数据和分析结果，增强数据的可读性和影响力。 本次项目实战，主要是落地实践一个智能数据分析平台；用户可以通过自然语言进行提问，由平台调用大模型对自然语言进行解析识别，生成SQL，再由系统自动的调用SQL,生成结果返回给用户，并且SQL执行之前，将要执行的SQL返回给用户界面，由用户进行检查正确与否，确认是否需要执行。类似于前面调研的DB-GPT开源项目； 同时又融入了Open Interpreter开源项目中的确认交互机制。
二、架构设计说明 智能数据分析平台的架构设计充分考虑了系统的可扩展性、稳定性及用户交互的流畅性。在构建此平台时，我们注重以下几个关键能力：
增强记忆能力： 平台通过维护一份详尽的数据字典和指标字典来实现长期记忆功能。这些字典包含业务逻辑、数据源信息和历史查询，帮助系统更好地理解用户的查询意图并提供准确的数据分析结果。
任务处理能力： 平台具备将复杂数据分析任务拆解为多个子任务的能力，每个子任务更易于管理和执行。这种任务拆解能力基于平台的推理和逻辑思维能力，能够高效地安排和优化查询流程。
SQL解析与兼容性： 平台设计了先进的SQL解析器，能够兼容不同的数据服务接口，如MySQL、Hive、SparkSQL等。这意味着无论数据存储在何处，平台都能够顺畅地进行数据交互和分析。
代码解析能力： 对于复杂的数据分析需求，平台能够通过内置或外部的代码库支持高级的数据处理和可视化功能。例如，可以利用Python脚本来进行机器学习分析或使用JavaScript库来生成高级图表。
交互机制： 平台强调多轮对话和用户交互的重要性，通过提供实时反馈和确认机制，确保用户对数据分析过程的完全控制。此外，交互式界面允许用户逐步细化查询条件，以获得更精确的数据分析结果。
三、数据字典说明 数据字典是一个记录数据库或数据集中各种数据元素的文档或文件，它提供了对数据元素的详细描述和定义，以及数据的结构、关系和属性等信息。数据字典对于数据管理和数据分析非常重要，它有助于组织、理解和使用数据，以及确保数据的准确性、一致性和可靠性。下面将详细介绍数据字典的作用和功能，包括数据元素的定义、关系表示、数据字典的组成和应用。
数据字典通常由以下几个组成部分构成：
数据元素定义： 包括数据元素名、标识符、数据类型、长度、含义、取值范围、格式等。数据结构和关系： 表明数据元素之间的逻辑和物理关系，如表的关系图、主键和外键关联等。数据属性和约束： 描述数据元素的属性和限制，如大小、精度、唯一性约束等。数据质量规则和指标： 定义数据的质量标准和要求，如完整性、准确性、一致性等。数据安全和权限： 记录数据的敏感性和访问权限，如数据分类、保密级别、用户权限等。数据源和血缘追溯： 追踪数据的来源、处理过程和传递路径，保证数据的可追溯性和可信度。数据文档和注释： 提供数据的文档和注释，包括数据定义、解释、用途和示例等信息。 四、指标字典说明 指标字典是什么？
指标字典在智能数据分析平台中发挥着至关重要的作用，它是业务数据标准化和统一管理的基础。通过定义和标准化关键业务指标，指标字典帮助组织内部建立对业务数据的共识，从而提高数据分析的准确性和效率。
（比如：什么是日活？GDP是指什么？）主要设计目的包括：
规范命名： 明确并通用的指标命名规则确保了跨部门和团队的数据一致性，避免了因命名差异引起的误解和混淆。
统一计算口径： 对于每一个指标，指标字典提供了明确的计算公式或逻辑，确保在不同时间点或不同场景下，指标的计算方式保持一致，从而保证数据比较的公正性和准确性。
核心维度与量度覆盖： 指标字典力求覆盖所有关键的业务维度和量度，这不仅有助于推动数据驱动的业务决策，还确保了数据分析的全面性。 五、平台技术选型 技术模块选型开发语言Python大模型选型GPT/GLM4或者私有模型是否需要微调否额外准备1. 安装MySQL数据库 2. 安装HiveSQL服务（可选） 六、项目调研 1、ChatGPT Code Interpreter
1）不能联网
2）仅限于官方内置提供的一些库，不能自己安装其他库，或调用其他库的功能。
3）老生常谈的数据安全话题，如果你想体验自动化的数据分析或者代码编写，就必须把本地文件进行上传。（并且有大小限制）
2、DB-GPT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffb92a195fb4e4feb84b38fbd42cef78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba999e3e48c42817ffb6b04b96ca38f4/" rel="bookmark">
			【大模型】 基于AI和全球化进程的权衡：开源大模型与闭源大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【大模型】 基于AI和全球化进程的权衡：开源大模型与闭源大模型
前言 实际上关于开源or闭源，一直以来都是颇有争议的话题，人们争执于数据的隐私性和共享性，到底哪一方能获得的收益更大。而对于开源与闭源哪个更好实际上也就是说是隐私更好还是公开更好。
是想要共享这个世界？还是想要独自打怪升级？
这取决于你自己。
但是基于AI和全球化进程的权衡，往往有时候你不得不在遵循自己的同时顺应时代的潮流，那么在这个环境下，究竟是开源——共享，还是闭源——内部使用更好呢？
文章目录 前言开源大模型GPT-3（OpenAI）BERT（Google）T5（Google）GPT-Neo和GPT-J（EleutherAI）BLOOM（BigScience）优势挑战 闭源大模型GPT-4（OpenAI）Bard（Google）LaMDA（Google）Claude（Anthropic）MUM（Google）优势挑战 开源大模型与闭源大模型，你更看好哪一方？数据隐私商业应用社区参与 结论 首先我们还是对 大模型以及开源闭源进行一定的分析。 大模型是指具有大规模参数和复杂计算结构的机器学习模型。通常基于深度学习技术。这些模型在AI的发展中起到了至关重要的作用，尤其是在自然语言处理（NLP）、计算机视觉和语音识别等领域。
以下是开源大模型和闭源大模型的基本简介。
开源大模型 开源大模型近年来在人工智能领域取得了显著的进展，许多开源大模型在学术研究、工业应用和社区创新中发挥了重要作用。以下是几个著名的开源大模型的介绍：
GPT-3（OpenAI） 简介
GPT-3（Generative Pre-trained Transformer 3）是OpenAI发布的一个大规模预训练语言模型。尽管GPT-3本身不是完全开源的，但OpenAI提供了API，使得开发者可以访问和使用该模型。它是基于Transformer架构，拥有1750亿参数，是目前最大的语言模型之一。
特点
生成能力：GPT-3在生成自然语言文本方面表现出色，可以生成具有连贯性和上下文相关的段落。多用途：GPT-3可以用于多种任务，如翻译、问答、摘要生成、对话系统等。少量样本学习：GPT-3在少量样本情况下也能表现出良好的效果，这使得它在实际应用中非常灵活。 应用场景
企业应用：GPT-3通过OpenAI API帮助企业自动化内容生成、客户支持和市场营销文案。例如，自动生成产品描述、撰写营销邮件和创建社交媒体内容。开发工具：开发者可以利用GPT-3 API在应用中集成智能助手、对话系统和自动化客服机器人，提高用户体验和效率。 BERT（Google） 简介
BERT（Bidirectional Encoder Representations from Transformers）是Google发布的一个开创性语言模型。它的出现引领了自然语言处理领域的重大突破。BERT的源代码和预训练模型都在GitHub上开源。
特点
双向编码：BERT使用双向Transformer进行编码，这使得模型在理解句子上下文时更加准确。预训练和微调：BERT通过在大规模语料上预训练，然后在特定任务上微调，从而实现了卓越的性能。广泛应用：BERT在许多自然语言处理任务中表现出色，如问答、命名实体识别、情感分析等。 应用场景
自然语言理解：BERT被广泛应用于自然语言处理任务，如情感分析、命名实体识别和文本分类。例如，分析社交媒体上的情感趋势、识别新闻中的关键实体和自动分类客户反馈。搜索引擎优化：BERT改进搜索引擎的查询理解能力，提高搜索结果的相关性和准确性。它被用于Google搜索引擎中，帮助理解复杂的搜索查询并提供更相关的结果。 T5（Google） 简介
T5（Text-To-Text Transfer Transformer）是Google提出的一种统一的文本到文本框架模型。T5的设计理念是将所有的自然语言处理任务转化为文本到文本的形式。T5的代码和预训练模型也是开源的。
特点
统一框架：T5将不同的任务（如翻译、摘要、分类）统一为文本生成问题，这使得模型架构更加简洁。大规模预训练：T5在大规模文本数据上进行了预训练，具有强大的生成和理解能力。灵活性：由于其统一的框架，T5可以很容易地适应各种自然语言处理任务。 应用场景
翻译和摘要：T5在翻译和文本摘要生成方面表现出色，应用于自动翻译文档、生成新闻摘要和提取关键信息。例如，帮助企业自动翻译技术文档，生成简洁的新闻摘要，便于快速阅读。问答系统：T5被用于构建智能问答系统，如企业内部知识库问答、在线客服机器人和教育领域的智能辅导工具，提供准确和高效的问答服务。 GPT-Neo和GPT-J（EleutherAI） 简介
GPT-Neo和GPT-J是由EleutherAI开发的开源大规模语言模型，旨在提供与GPT-3相当的开源替代品。GPT-Neo和GPT-J的源代码和预训练模型都公开发布，供社区使用和改进。
特点
高可用性：作为开源项目，任何人都可以访问和使用这些模型。大规模：GPT-J拥有60亿参数，是当前最大的开源语言模型之一。社区驱动：EleutherAI的模型开发依赖于社区的贡献和合作，促进了快速的迭代和创新。 应用场景
教育和研究：GPT-Neo和GPT-J被广泛应用于教育和研究领域，帮助学生和研究人员生成报告、撰写论文和进行数据分析。例如，生成科研报告的初稿，提供论文写作辅助和自动化数据摘要。内容创作：这些模型被用于自动化内容创作，如博客文章、故事创作和剧本写作，帮助创作者提高生产效率和创意表达。 BLOOM（BigScience） 简介
BLOOM（BigScience Large Open-science Open-access Multilingual Language Model）是由BigScience项目发布的一个大规模多语言模型。BLOOM的开发集中了来自全球研究者的合作力量。
特点
多语言支持：BLOOM支持数十种语言，具有强大的跨语言理解和生成能力。社区合作：BLOOM的开发过程透明，依赖于全球研究社区的合作。开源和开放访问：BLOOM的源代码和模型权重公开发布，供研究和应用使用。 应用场景
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba999e3e48c42817ffb6b04b96ca38f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22afaa8950fb579575e5ad6f03f6c7e8/" rel="bookmark">
			Java实现链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表 前言一、链表的概念及结构二、链表的分类三、链表的实现无头单向非循环链表实现无头双向链表实现具体代码 四、链表习题五、顺序表和链表的区别 前言 推荐一个网站给想要了解或者学习人工智能知识的读者，这个网站里内容讲解通俗易懂且风趣幽默，对我帮助很大。我想与大家分享这个宝藏网站，请点击下方链接查看。
https://www.captainbed.cn/f1
链表是一种常见的数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。链表的一个显著特点是，它不需要在内存中连续存储，因此可以高效地插入和删除节点。这种灵活性使得链表在许多应用中成为理想的选择，尤其是在需要动态调整数据结构大小的场景中。
在链表的实现中，通常会有头节点和尾节点之分。头节点是链表的第一个节点，而尾节点是链表的最后一个节点。通过遍历链表，我们可以访问链表中存储的所有数据。链表还支持在链表头部或尾部快速添加新节点，这些操作的时间复杂度通常为O(1)。
然而，链表也有一些缺点。比如，访问链表中的某个特定节点需要从头节点开始遍历，这导致访问链表中间节点的平均时间复杂度为O(n)。此外，链表需要额外的空间来存储指针，这增加了内存的使用。
链表有多种类型，如单向链表、双向链表和循环链表等。单向链表是最简单的链表类型，每个节点只有一个指向下一个节点的指针。双向链表则允许节点同时指向前一个和下一个节点，这使得双向链表在某些操作上比单向链表更高效。循环链表则是将尾节点的指针指向头节点，形成一个闭环。
在实际应用中，链表常用于实现栈、队列和哈希表等数据结构。例如，链表可以作为栈的底层数据结构，实现元素的先进后出。此外，链表还可以用于实现动态数组，支持元素的动态插入和删除。
总之，链表作为一种重要的数据结构，在编程和数据处理中发挥着重要作用。尽管链表在某些方面存在不足，但其灵活性和高效性使得它在许多场景中仍然是理想的选择。通过深入了解链表的特性和应用，我们可以更好地利用这种数据结构来解决实际问题。
一、链表的概念及结构 链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的 。
概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
现实中 数据结构中
二、链表的分类 实际中链表的结构非常多样，以下情况组合起来就有8种链表结构：
单向或者双向
带头或者不带头
循环或者非循环
虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：
无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。 三、链表的实现 无头单向非循环链表实现 // 1、无头单向非循环链表实现 public class SingleLinkedList { //头插法 public void addFirst(int data); //尾插法 public void addLast(int data); //任意位置插入,第一个数据节点为0号下标 public boolean addIndex(int index,int data); //查找是否包含关键字key是否在单链表当中 public boolean contains(int key); //删除第一次出现关键字为key的节点 public void remove(int key); //删除所有值为key的节点 public void removeAllKey(int key); //得到单链表的长度 public int size(); public void display(); public void clear(); } 无头双向链表实现 // 2、无头双向链表实现 public class DoubleLinkedList { //头插法 public void addFirst(int data); //尾插法 public void addLast(int data); //任意位置插入,第一个数据节点为0号下标 public boolean addIndex(int index,int data); //查找是否包含关键字key是否在单链表当中 public boolean contains(int key); //删除第一次出现关键字为key的节点 public void remove(int key); //删除所有值为key的节点 public void removeAllKey(int key); //得到单链表的长度 public int size(); public void display(); public void clear(); } 具体代码 // 2、使用无头单向非循环链表实现 public class SingleLinkedList { private Node head; // 头节点 // 节点类 private class Node { private int data; // 数据 private Node next; // 下一个节点 public Node(int data) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22afaa8950fb579575e5ad6f03f6c7e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6d590463bc2367271961e8db8c9b94/" rel="bookmark">
			Web安全：文件上传漏洞详解，文件上传漏洞原理、绕过方式和防御方案。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「作者简介」：2022年北京冬奥会网络安全中国代表队，CSDN Top100，就职奇安信多年，以实战工作为基础对安全知识体系进行总结与归纳，著作适用于快速入门的 《网络安全自学教程》，内容涵盖系统安全、信息收集等12个知识域的一百多个知识点，持续更新。
文件上传漏洞是指：用户通过「文件上传功能」，上传「可执行脚本」文件到服务器本地，拿到服务器「权限」。
漏洞形成的核心在于：网站对上传的文件过滤不够严谨。
因此，我们学习的重点要放在：文件过滤的方式，以及如何绕过这些过滤！
文件上传漏洞 1、前端绕过2、MIME类型绕过3、后缀名绕过4、.htaccess绕过5、点绕过6、防御 1、前端绕过 1）程序员在「前端」使用「JS代码过滤」上传的文件，过滤成功以后，再向后端发送请求，代码逻辑示例：
//JS检查文件类型（大概逻辑） function checkFile() { //定义允许上传的文件类型 var allow_ext = ".jpg|.png|.gif"; //文件类型不满足时，返回false，并弹窗 if(){ alert(errMsg); return false; } } 2）我们可以根据页面是否「向后台发送请求」，来判断前端是否有过滤。
当页面发送请求时，浏览器左下角的状态栏会「显示请求链接」（显示状态栏功能，默认开启），上传文件失败时，如果左下角不显示链接，就说明前端有过滤；如果左下角显示链接，就说明前端没有过滤（或者前端过滤已经被绕过）。
3）绕过前端过滤的方式有两种：
「浏览器禁用JS」（JS代码不起作用，但也会导致其他正常的JS功能也不能用）「抓包」修改文件后缀（比如上传一个jpg文件，抓包修改成php文件） 对应的练习靶场： Upload LABS Pass-1
练习靶场下载：https://github.com/c0ny1/upload-labs
靶场搭建可参考 PhpStudy下载安装使用教程
2、MIME类型绕过 浏览器通过「MIME类型」（而不是文件扩展名）来标识文件的类型，也就是http请求头中的 Content-Type 字段，内容为 image/jpeg、image/png、image/gif 时，表示文件是图片类型。
1）程序员通过请求的MIME类型，判断是否为图片类型，代码逻辑示例：
//MIME类型过滤（大概逻辑） if($_FILES['upload_file']['type'] == 'image/jpeg'){ //上传文件到upload路径 } else { //提示文件类型不正确 } 2）我们可以抓包修改 Content-Type 字段的值为 image/jpeg、image/png、image/gif ，进行绕过。
​​​​​​​​
对应的练习靶场： Upload LABS Pass-2
3、后缀名绕过 1）程序员通过「后缀名黑名单」，禁止上传指定类型的文件，代码逻辑示例：
# 获取上传的文件名 $file_name = trim($_FILES['upload_file']['name']); # 定义黑名单 $deny_ext = array('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da6d590463bc2367271961e8db8c9b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3098a3151b8ada7240761d02941fff6/" rel="bookmark">
			Java项目：基于SSM框架实现的学生请假管理系统【ssm&#43;B/S架构&#43;源码&#43;数据库&#43;毕业论文】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介 本项目是一套基于SSM框架实现的学生请假管理系统
包含：项目源码、数据库脚本等，该项目附带全部源码可作为毕设使用。
项目都经过严格调试，eclipse或者idea 确保可以运行！
该系统功能完善、界面美观、操作简单、功能齐全、管理便捷，具有很高的实际应用价值
二、技术实现 jdk版本：1.8 及以上
ide工具：IDEA或者eclipse
数据库: mysql5.7
后端：spring+springmvc+mybatis+maven+mysql
前端：vue，css
三、系统功能 系统用户包括有管理员、老师、学生
主要功能如下：
用户登录
用户注册
首页
个人中心
修改密码
个人信息
学生管理
学生信息
老师管理
请假申请管理
审批
驳回
专业管理
学院管理
班级管理
留言管理等功能
四、页面功能 五、论文 六、数据库 一共11张表
七、源码地址 https://download.csdn.net/download/weixin_43860634/89365949
需要远程部署，可以加我下方的联系方式哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6833d362bd64288f29fedbb9cc59cef4/" rel="bookmark">
			AI智能体｜扣子Coze文生图功能接入微信公众号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是无界生长。
AI智能体｜扣子Coze文生图功能接入微信公众号本文分享了如何将Coze平台的文生图功能接入微信公众号的详细操作流程，包括创建图像流、创建并配置Bot、设置提示词和开场白、调试、发布等步骤。如果看完还没学会的话，可以私信我。学会了的话，欢迎转发分享给你的朋友们。​https://mp.weixin.qq.com/s?__biz=MzU1MjgyOTA5NQ==&amp;mid=2247484482&amp;idx=1&amp;sn=f615491cd909cbc4feb3b5ca27bbfd66&amp;chksm=fbfd6d8acc8ae49cb8150bd15c8ac6b2556ee8e84e96b78e340cd1e965c437099a6788ed303b&amp;token=719210586&amp;lang=zh_CN#rd
在昨天的文章《AI智能体｜手把手教你使用扣子Coze图像流的文生图功能》有详细介绍如何使用Coze的文生图功能，今天分享下如何把Coze文生图功能接入微信公众号，如果你觉得我分享的内容对你有帮助，麻烦点个关注，分享转发给你的朋友们！
操作流程 创建图像流
创建文生图Bot
创建Bot
编排Bot
添加图像流
设置Bot提示词
设置开场白
调试Bot
发布Bot
创建图像流 创建一个名称为“TextToImage_TuningPrompt”的图像流
添加“提示词优化”和“文生图”节点，并对图像流节点的参数进行配置，试运行成功后，发布图像流。如果对图像流不太熟悉，可以先查看这两篇文章《AI智能体｜扣子Coze“图像流”功能速览》、《AI智能体｜手把手教你使用扣子Coze图像流的文生图功能》
创建Bot 点击右上角的“创建Bot”，填写Bot相关信息，我这里已经创建好了，就不演示了
编排Bot 添加图像流 点击图像流后面的“+”，添加图像流
点击“添加”
设置Bot提示词 这里简单设置下，你可以根据实际情况进行调整
设置开场白 这里简单设置下，你可以根据实际需要进行调整
调试Bot 输入内容：戴着墨镜跳舞的猫
发布Bot 发布平台勾选微信公众号（订阅号），如果未授权，需要先进行授权，然后点击“发布”按钮，等待审核完成
测试Bot 打开微信公众号对话框，输入内容，等待生成图片
图片链接就是具体的内容，这里不做演示了，想验证的小伙伴可以按照上面流程进行操作，绑定自己的微信公众号测试，我这里教程演示完成，就解绑微信公众号了。
总结 本文分享了如何将Coze平台的文生图功能接入微信公众号的详细操作流程，包括创建图像流、创建并配置Bot、设置提示词和开场白、调试、发布等步骤。如果看完还没学会的话，可以私信我。学会了的话，欢迎转发分享给你的朋友们。
我是无界生长，如果你觉得我分享的内容对你有帮助，麻烦点个关注，带你一起玩转AI！
AI学习资料在微信公众号：无界生长，个人微信：wjsz2070
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3eb407a13ea7929e5c54eb9f34371f7/" rel="bookmark">
			PHP框架 之YII2框架 (yii2 framework - Yii PHP Framework)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又有新项目要撘框架，毫无意外的，我又被借调走了，又写一篇文章记录一下，这次讲的是：yii2 framework - Yii PHP Framework框架，有需要的同学自取，Yii 是一个高性能，基于组件的 PHP 框架，用于快速开发现代 Web 应用程序,特别适合开发大型应用，如门户网站、社区、内容管理系统（CMS）、电子商务项目和 RESTful Web 服务 1.安转： 1.1Composer 安装： （需要切换国内镜像：composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/，科学上网的同学可以忽略这一步） 命令安装 Composer asset plugin，它是通过 Composer 管理 bower 和 npm 包所必须的，此命令全局生效，一劳永逸。 composer global require "fxp/composer-asset-plugin:~1.0.0"
1.1.1 基础版本 （basic作为指定目录：比如你本机的E:\phpstudy\PHPTutorial\WWW\myproject\yii）。 composer create-project --prefer-dist yiisoft/yii2-app-basic E:\phpstudy\PHPTutorial\WWW\myproject\yii 2.0.22
1.1.2 基础开发版本 composer create-project --prefer-dist --stability=dev yiisoft/yii-app-basic E:\phpstudy\PHPTutorial\WWW\myproject\yii 2.0.22
1.1.3完整版本（basic作为指定目录：比如你本机的E:/yii） composer create-project --prefer-dist yiisoft/yii2 E:\phpstudy\PHPTutorial\WWW\myproject\yii 2.0.22
1.2官网下载安装（此种方式安装PHP版本必须大于8.1）： https://www.yiiframework.com/download
2.配置秘钥： 文件路径：yii\config\web.php 需要配置项：cookieValidationKey
3.目录结构： basic 应用根目录 composer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3eb407a13ea7929e5c54eb9f34371f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e00a77ac371991ce686311f2080403/" rel="bookmark">
			已解决java.lang.annotation.AnnotationFormatError: 注解格式错误的正确解决方法，亲测有效！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已解决java.lang.annotation.AnnotationFormatError: 注解格式错误的正确解决方法，亲测有效！！！
目录
问题分析
报错原因
解决思路
解决方法
检查注解定义
检查注解的使用
确认依赖版本和兼容性
检查默认值和实际值
检查编译器和工具链
总结
问题分析 java.lang.annotation.AnnotationFormatError是一种运行时错误，表示在解析注解时发生了格式问题。这通常是在编译或运行过程中发现注解的定义或使用不符合预期格式时抛出的。这类错误可能出现在注解的声明、使用方法或者注解处理器中。
报错原因 注解格式错误主要由以下原因引起：
注解的定义不符合Java的注解语法规范。注解使用中的参数类型与注解定义不匹配。注解的默认值和实际使用值不一致。使用了无效的值作为注解参数。编译器或工具链的问题，导致注解格式在编译或运行时被破坏。 解决思路 解决AnnotationFormatError的思路包括：
检查注解的定义，确保其语法和格式正确。检查所有注解的使用，确保每个参数都符合注解的定义。确认注解所依赖的类和接口版本是最新且兼容的。检查编译器和构建工具的配置，确保其正常工作并支持所使用的注解。 解决方法 检查注解定义 确保注解的定义符合Java的注解语法规范。
// 示例：正确的注解定义 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String value(); } 检查注解的使用 确保注解的使用方式和参数符合注解的定义。
// 示例：正确的注解使用 public class MyClass { @MyAnnotation(value = "Example") public void myMethod() { // 方法实现 } } 确认依赖版本和兼容性 确保项目所依赖的库和工具都是最新且兼容的版本。
# 示例：使用Maven更新依赖并重新编译项目 mvn clean install 检查默认值和实际值 确保注解的默认值和实际使用值一致，避免类型不匹配或非法值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98e00a77ac371991ce686311f2080403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ad52bb90d67b51d1462760a8840c3e/" rel="bookmark">
			three.js官方案例webgl_loader_fbx.html学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.1 添加库引入
1.2 添加必要的组件scene,camera,webrenderer等
1.3 模型加载
1.4 半球光
1.5 动画
1.6 换个自己的fbx模型
1.7 fbx模型和fbx动画关联
1.7 html脚本全部如下
1.8 fbx.js全部脚本如下
1.1 添加库引入 import * as THREE from 'three'; import Stats from 'three/addons/libs/stats.module.js'; //控制器 import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; //fbx模型加载器 import { FBXLoader } from 'three/addons/loaders/FBXLoader.js'; 1.2 添加必要的组件scene,camera,webrenderer等 先创建必要的场景scene,相机camera，渲染器webrenderer，控制器controls和灯光DirectionalLight. 性能检测stars， 地面， 网格
自定义属性
let camera, scene, renderer, stats;
function init() { const container = document.createElement( 'div' ); document.body.appendChild( container ); //相机 camera = new THREE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38ad52bb90d67b51d1462760a8840c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf968f396c987e5965008edb789c6066/" rel="bookmark">
			电脑找不到opencl.dll原因分析及5种详细的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机使用过程中，我们经常会遇到一些错误提示，其中之一就是“找不到opencl.dll”。这通常意味着计算机中缺少或损坏了与OpenCL（开放计算语言）相关的动态链接库文件。OpenCL允许应用程序利用图形处理器（GPU）或其他加速器进行并行计算，因此该文件的缺失可能会影响依赖其功能的程序运行。下面我将介绍5种解决找不到opencl.dll的方法。
一，找不到opencl.dll具体表现 当OpenCL.dll文件丢失或损坏时，依赖于该文件的应用程序可能无法启动，或者在运行过程中出现崩溃。具体表现包括但不限于以下几种情况：
开机或应用程序启动时显示错误消息，如“找不到OpenCL.dll”或“OpenCL.dll为无效的Windows映像”。
应用程序在执行依赖于OpenCL.dll的操作时突然停止工作，导致程序崩溃或退出。
系统在尝试执行某些图形密集型任务时响应缓慢或完全无响应。
某些游戏或图形应用程序在启动时可能显示图形渲染错误，影响用户体验。
这些表现不仅影响了用户的正常使用，还可能导致数据丢失或工作中断，给用户带来不便。解决OpenCL.dll相关问题，对于恢复系统稳定性和应用程序的正常运行至关重要。
二，找不到opencl.dll解决方法 方法1：回收站恢复 如果OpenCL.dll文件是被误删的，最简单快捷的恢复方法是检查回收站。用户应打开回收站并寻找OpenCL.dll文件，如果找到，可以通过右键点击并选择“还原”来恢复文件到原始位置。这种方法适用于因用户操作失误导致文件丢失的情况。
方法2：更新显卡驱动程序 由于OpenCL.dll与显卡驱动紧密相关，更新显卡驱动程序是解决OpenCL.dll问题的有效方法之一。用户首先需要确认显卡型号，然后访问显卡制造商的官方网站下载并安装最新的驱动程序。更新驱动后，重启计算机以确保更改生效。这一步骤对于解决因驱动不兼容或过时引起的OpenCL.dll问题至关重要。
方法3：使用DLL修复工具（有效） 首先在浏览器顶部输入：dll修复工具.site（按下键盘回车键打开）并下载。
运行该程序，点击一键修复，它将自动扫描并修复系统中缺失或损坏的DLL文件。
检测完成后将使用一键修复便可以解决缺失的OpenCL.dll文件和其他的dll文件可以一并修复。等待修复过程完成后，重新启动电脑以使更改生效。
优点：方便快捷，适用于电脑小白用户。
方法4：从官方网站下载opencl.dll文件 可以尝试从官方网站下载OpenCL.dll文件。在下载前，用户需要确认操作系统的位数以及显卡型号，以确保下载正确版本的文件。下载后，将文件复制到系统文件夹中，并重启计算机。
以下是下载与替换步骤的详细介绍：
确认系统类型：在进行opencl.dll文件下载之前，用户需要确定自己的操作系统是32位还是64位，因为不同位数的系统需要不同版本的动态链接库文件。这可以通过在系统信息中查看操作系统的“系统类型”来完成。
查找显卡型号：由于OpenCL与图形处理单元密切相关，了解显卡型号对于确保兼容性是必要的。可以通过设备管理器中的“显示适配器”部分来查找此信息。
选择可靠来源下载：用户应当从官方网站或者经过验证的可靠源如系统之家等网站下载opencl.dll文件。这些网站通常会提供详细的使用说明以及最新版本的文件，以确保安全性和兼容性。
执行文件复制过程：下载正确的opencl.dll文件后，需要将其复制到系统文件夹中的正确位置。对于32位系统，文件通常被放置在C:\Windows\System32目录中；而对于64位系统，则放在C:\Windows\SysWOW64目录下。
重启计算机：完成文件复制后，重启计算机以使更改生效。这对于确保系统正确识别并应用新添加或替换的动态链接库文件至关重要。
方法5：进行系统还原 当其他方法都无法解决问题时，可以考虑使用系统还原功能。系统还原可以将计算机恢复到之前的状态，可能解决因系统更新或软件安装导致的问题。用户需要打开控制面板，选择“系统和安全”下的“系统”，然后点击“系统保护”并选择“系统还原”。选择一个合适的还原点并按照指示操作。需要注意的是，系统还原可能会影响最近安装的软件和系统设置。
三，找不到opencl.dll原因分析 误删除或清理工具误操作：在用户进行磁盘清理或手动删除文件时，可能会不小心删除OpenCL.dll文件，或被某些清理工具错误地识别为无用文件而清除。据统计，约有30%的OpenCL.dll丢失问题是由于用户误操作导致的。
病毒感染或恶意软件攻击：恶意软件，包括病毒和木马，可能会扫描系统文件并删除或篡改OpenCL.dll，以避免被安全软件检测或破坏系统稳定性。安全研究人员指出，约15%的OpenCL.dll丢失案例与恶意软件有关。
系统文件保护机制失效：Windows系统拥有文件保护机制，如Windows Resource Protection (WRP)，旨在防止系统文件被篡改或删除。然而，当这一机制被禁用或出现故障时，OpenCL.dll等关键系统文件可能会丢失，这种情况在所有案例中约占10%。
软件冲突：安装或卸载某些程序可能会影响OpenCL.dll的完整性或注册表项，导致文件丢失或损坏。软件冲突引起的OpenCL.dll问题在所有案例中大约占20%。
驱动程序问题：如果OpenCL驱动程序没有正确安装，或者驱动版本与系统不兼容，可能会导致OpenCL.dll无法被系统正确调用。驱动问题导致的OpenCL.dll丢失在所有案例中约占15%。
系统更新或升级失败：操作系统在更新或升级过程中如果遇到错误或中断，可能会导致包括OpenCL.dll在内的系统文件丢失或损坏。系统更新失败导致的OpenCL.dll问题在所有案例中约占10%。
总结起来，找不到opencl.dll的错误可能是由于OpenCL驱动程序损坏、系统环境变量配置不正确、操作系统或相关软件版本不兼容、OpenCL开发工具包损坏或丢失等原因引起的。通过以上几种方法，我们可以解决找不到opencl.dll的问题。希望这些方法能够帮助到遇到此问题的你。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f3df374b6d169e93bd2e50c777b6a4/" rel="bookmark">
			Kotlin 标准函数 with、run、apply 的定义和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kotlin 标准函数 with、run、apply 的定义和使用 1. with 函数 定义：
with 函数允许你在一个对象的上下文中执行一个 lambda 表达式，而不需要在 lambda 表达式中重复引用该对象。
@kotlin.internal.InlineOnly public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block() 使用场景：
当你需要在多个地方引用同一个对象，并且不想每次都显式地写出这个对象名时，可以使用 with 函数。
示例：
val stringBuilder = StringBuilder() with(stringBuilder) { append("Hello") append(", ") append("World!") } println(stringBuilder) // 输出 "Hello, World!" 2. run 函数 定义：
run 是 Kotlin 中所有类的成员函数，用于在当前对象的上下文中执行一个 lambda 表达式，但不返回任何值（返回 Unit）。
虽然这不是显式定义的函数，但它是通过扩展函数为所有类隐式提供的。
使用场景：
当你需要在对象的上下文中执行一些操作，但不需要返回任何结果时，可以使用 run。
示例（虽然不常见，因为可以直接在对象上调用方法）：
val stringBuilder = StringBuilder() stringBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f3df374b6d169e93bd2e50c777b6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d48eab3e25ecd66b329752ea071d4e/" rel="bookmark">
			SqlSugar:基于SQLSugar框架在 .Net环境中搭建PostgreSQL数据库访问、操作的框架，C#连接访问PostgreSQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SqlSugar 是一款 老牌 .NET开源ORM框架，由果糖大数据科技团队维护和更新 ，开箱即用最易上手的ORM 优点 ：【生态丰富】【高性能】【超简单】 【功能全面】 【多库兼容】【适合产品】 【SqlSugar视频教程】 支持 ： .net framework .net core3.1 .ne5 .net6 .net7 .net8 .net9 特色 ： 拥有全球最活跃的ORM线上论坛，比EF还要活跃，交流群人数已超过万人 ，技术支持快，口碑好。
详情请看SqlSugar 官方教程SqlSugar .Net ORM 5.X 官网 、文档、教程 - SqlSugar 5x - .NET果糖网
概览 本文描述了在.Net环境中使用SQLSugar框架连接及访问PostgreSQL数据库的详细操作过程，主要包括四个步骤：1 下载SqlSugar包 2 创建初始化并连接数据库工具类 3 创建数据操作类 4调用操作类访问数据库。
1.下载SqlSugar包 1.1 下载 ​​​在NuGet包管理器中搜索sqlsugar。注：.Net Framework框架选择SqlSugar，如果是.Net框架下则选择SqlSugarCore。
1.2引用 using SqlSugar
2.连接 创建数据库访问基类，代码中加密解密步骤可以根据实际需求省略或自设 using SqlSugar; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms.Design; namespace DemoSummaryZT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98d48eab3e25ecd66b329752ea071d4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b157cc3acc3a666e4f431a995c5e06/" rel="bookmark">
			spring boot3整合邮件服务实现邮件发送功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⛰️个人主页: 蒾酒
🔥系列专栏：《spring boot实战》
目录
内容概要
开通服务
依赖引入
配置属性
创建邮件发送工具类
测试
最近发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。
点击跳转到学习网站
内容概要 本文介绍了spring boot整合email服务，实现发送验证码，邮件（普通文本邮件、静态资源邮件、附件邮件）。
坚持看完相信对你有帮助。
同时欢迎订阅springboot系列专栏，持续分享spring boot的使用经验。
开通服务 实现email服务需要先将自己的邮箱开通POP3/IMAP服务才可以通过该邮箱发送邮件，开通步骤如下：
这里以QQ邮箱为例
1.进入QQ邮箱官网 https://wx.mail.qq.com/
2.登录后点击设置 3.选择账号 找到 POP3/IMAP.....服务这里开启你的服务，这里我已经开启了的。
4.开启服务 开启成功会得到授权码 ，记住这个授权码。下面开始在spring boot中整合。
spring boot整合 1.依赖引入 pom.xml:
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 2.配置属性 application.yml：
修改成你自己的实际信息。
spring: #邮件服务配置 mail: host: smtp.qq.com #邮件服务器地址 protocol: smtp #协议 username: 305462*****@qq.com #发送邮件的邮箱也就是你开通服务的邮箱 password: fiwvcy******d #开通服务后得到的授权码 default-encoding: utf-8 #邮件内容的编码 3.创建邮件发送工具类 使用@component注解标记为组件，可以在Service中注入使用。
里面一共定义了三种发送邮件方法：
发送纯文本的普通邮件，可以发送一些纯文本的消息以及验证码内容。发送HTML格式的文本内容，可以发一些静态资源，图片，音频，视频等，也可以发验证码信息。发送携带附件的邮件，比如word,excel,pdf文档或者其他文件。 具体可以根据业务需求调整代码。我实现的较为简单可以当个模板使用。
import jakarta.annotation.Resource; import jakarta.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18b157cc3acc3a666e4f431a995c5e06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f8e50ee4b785aa148d221ab6d9eaf6/" rel="bookmark">
			WebGIS简述及地理、地图的基础概念解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WebGIS是什么？ 基础概念 WebGIS是一种利用Web技术实现服务器与客户端（C/S端）之间通信的地理信息系统。它允许用户在网络上动态访问、共享和操作地理空间数据。WebGIS通常由GIS服务器和客户端组成，其中GIS服务器负责处理数据请求并提供响应，客户端可以是Web浏览器、桌面应用程序或移动应用程序。WebGIS的通信是通过超文本传输协议（HTTP/HTTPS）进行的，响应的格式可以是HTML、二进制图像、XML（可扩展标记语言）、GML（地理标记语言）或JSON（JavaScript对象表示法）。
更详细的理解 在给出WebGIS的明确定义之前，有必要区分几个相关的概念，即：Network GIS、Internet GIS或World Wide Web GIS (WebGIS)。在国外，WebGIS通常被称为Web Mapping。辨析这些概念有助于正确理解和应用WebGIS。
在所有这些概念中，Network GIS包含的内容最为广泛，包括C/S或B/S模式，即基于各种分布式计算模型的多层分布式地理信息系统应用，可以基于J2EE框架，也可以基于分布式计算框架，如COM/DCOM和CORBA.
这里的网络包括局域网、广域网、互联网和各种无线网络。Network GIS中使用的协议可以是TCP/IP，也可以是不同层的其他协议，如HTTP、WAP、GPRS和蓝牙协议。
Internet GIS是Network GIS的一个子集，它是基于TCP/IP协议的网络地理信息系统，可以在互联网上部署和运行。这些地理信息系统可以是C/S模式，也可以是B/S模式。谷歌的GoogleEarth软件是谷歌提供的C/S模式网络地图服务的客户端软件。
因此，WebGIS是一个基于超文本传输协议的B/S模式分布式计算机应用系统，在Internet或Intranet环境下存储、管理、分析、发布和共享地理信息。
地图投影 是什么？ 地图投影是一种将地球表面的经、纬线转换到平面上的理论和方法。由于地球是一个赤道略宽两极略扁的不规则的梨形球体，其表面是一个不可展平的曲面，因此需要通过特定的数学法则将其转换到平面上。这个过程会产生投影变形，不同的投影方法具有不同性质和大小的投影变形。地图投影的目的是为了在二维平面上表示三维地球的形状和特征，以便于制图、导航和地理信息的展示。
按辅助投影面的形状分类：
方位投影：辅助投影面为平面。圆柱投影：辅助投影面为圆柱面。圆锥投影：辅助投影面为圆锥面。 常见的地图投影坐标系： 墨卡托投影高斯克里格投影兰伯特等角投影 地图缩放及漫游 地图缩放 地图缩放是指通过调整地图的显示比例来查看不同范围的地理信息。在大多数地图服务中，您可以通过点击界面上的加号（+）或减号（-）按钮来实现地图的放大和缩小。此外，一些地图服务还支持使用鼠标滚轮进行缩放操作，滚动向前放大地图，滚动向后缩小地图。 地图漫游 地图漫游是指在地图上移动视图位置，以便查看不同区域的详细信息。在地图服务中，您可以通过点击并拖动地图来实现漫游。有些地图服务还提供了自动导航功能，允许用户输入目的地，地图会自动规划路线并展示沿途风景。
常见问题及解决方案 如果您在使用地图时遇到缩放和漫游卡顿的问题，可能是因为加载的数据量过大或者地图服务的性能有限。您可以尝试减少显示的数据量，例如关闭不必要的图层，或者使用更高性能的地图服务。如果问题依然存在，可能需要联系地图服务提供商寻求技术支持。
地图数据源 简述 地图数据源是提供地理数据的来源，这些数据对于地理信息系统（GIS）的应用至关重要。地图数据源可以分为多种类型，包括卫星影像、地理位置数据、地图数据、传感器数据等。
常见的地图数据源 卫星遥感数据：通过卫星传感器获取的地球表面的图像和数据，提供高分辨率的地理信息，包括地形、植被、土地利用等。常见的卫星遥感数据源包括美国国家航空航天局（NASA）的陆地卫星数据、欧洲航天局（ESA）的哨兵卫星数据等。 ​地理位置数据：包含地理坐标信息的数据，用于绘制地图和进行空间分析。常见的地理位置数据源包括全球定位系统（GPS）数据、地理编码数据、地理信息数据库等。​地图数据：用于绘制地图的数据，包括地理边界、道路网络、水系等。常见的地图数据源包括地理信息系统公司提供的地图数据、政府部门提供的行政区划数据等。传感器数据：由各种传感器收集的数据，如气象站、水质监测站点等，用于环境监测和分析。公开数据集：一些组织或政府部门会公开发布地图数据，如OpenStreetMap、美国地质调查局、国家地球空间信息局等。这些数据通常可以免费获取，也可以用于商业目的。商业地图数据供应商：如谷歌地图、百度地图、高德地图等，这些公司通常会花费大量的时间和资源来创建和维护他们的数据源，并提供一系列的API接口供开发者使用。 地图符号学 简述 地图符号学是研究和建立作为地图语言的地图符号系统的理论。它主要研究和建立地图符号系统的理论与方法及其应用的法则，也常被称为地图语言学。地图符号学探讨用符号学的基本概念和原理来研究地图符号的特征、意义、本质、发展变化规律以及符号与人类多种活动之间的关系。
地图符号学的内容 地图符号学包括三个主要方面的内容：
地图符号的结构（句法）：应形成相互联系的、完整的符号系统结构。​地图符号的结构（语义）：符号系统应能表达任何信息内容，并保证符号明确代表所表达的内容。地图符号的实用性（语用）：符号系统应保证快速感受和牢固记忆。 地图符号的类型 地图符号可以分为几种类型：
点状符号：用于表示抽象意义上的点，如城市、山峰等，通常通过形状和颜色来表示地图要素的性质、等级、大小和数量特征。线状符号：用于表示抽象意义上的线，如河流、道路等，其宽度往往反映地图要素的等级或数值。面状符号：用于表示抽象意义上的面，如湖泊、森林等，其轮廓线表示分布范围，轮廓线内的颜色或说明符号表示性质和数量。文字符号：用于对地图要素的属性进行说明，如地名、统计数据等，其定位比较特殊，可以用相对位置的移动来保持图形的美观。 地理空间分析 简述 地理空间分析是一种定量研究地理空间现象的方法，它能够操纵空间数据，使之成为不同的形式，并从中提取潜在信息。这种分析是地理信息系统（GIS）的核心部分，特别是对空间隐含信息的提取和传输能力，是GIS区别于一般信息系统的主要方面。
基本方法 空间信息量算：这是空间分析的定量化基础，涉及拓扑、顺序、距离、方位等空间关系的查询和定位空间实体。空间信息分类：包括对线状地物求长度、曲率、方向，对面状地物求面积、周长、形状、曲率等，以及求几何体的质心等。缓冲区分析：针对点、线、面等地理实体，自动在其周围建立一定宽度范围的缓冲区多边形，用于解决邻近度问题。叠加分析：将有关主题层组成的数据层面进行叠加，产生新数据层面，综合了原来两层或多层要素所具有的属性。网络分析：对地理网络（如交通网络）、城市基础设施网络进行地理分析和模型化，研究网络工程的最优安排。空间统计分析：结合地理信息与环境要素的监测数据，对区域环境质量进行评价，提取污染物分布图、噪声分布图等。 WebGIS开发工具 WebGIS是将Web技术应用于地理信息系统（GIS）开发的产物，它允许用户通过Web浏览器访问和操作地理数据。以下是一些常用的WebGIS开发工具：
GIS软件 ArcGIS：由Esri公司开发，是一套广泛使用的商业GIS软件。Erdas：专注于遥感数据处理和分析的软件。Envi：同样是一款专业的遥感图像处理软件。QGIS：一款免费、开源的GIS软件，支持多种操作系统。国产GIS软件：如超图、中地MapGIS等，这些软件通常针对中国市场进行优化。 二次开发编程语言 HTML、CSS、JavaScript：网页前端开发的基础技术。JQuery、Bootstrap、Angular、Vue：前端框架和库，用于加速开发过程。Java、Node.js、Tomcat：服务端编程语言和框架，用于处理后端逻辑和服务。C#：适用于Windows平台的二次开发语言。Python：常用于数据分析和科学计算。数据库：如SqlServer、MySQL、Oracle、PostgreSQL，以及专为地理数据设计的PostGIS、Oracle Spatial、SpatiaLite。 GIS二次开发软件包 GDAL：操作栅格地理数据格式的库，支持Python语言。Geopandas：用于空间数据可视化的Python库。ArcPy：ArcGIS的Python脚本库。rasterio：快速的光栅图像读写库。Fiona：地理数据引擎。spectral-python：高光谱图像处理库。Shapely：用于笛卡尔平面几何对象的Python工具包。 地图制图工具 Mapnik：基于C++的地图制图工具。GeoTools：基于Java的GIS工具集。GeoServer：基于Java的OGC Web服务器规范实现。udig：基于Java的桌面GIS应用。OpenLayers：基于JavaScript的WebGIS客户端开发库。Leaflet：轻量级的JavaScript地图库，适合移动端交互式地图。 发布地图服务 ArcGIS Server：用于发布地图服务的平台。GeoServer：用于发布地图数据的OGC Web服务器规范实现。 数据分析与图像处理软件包 OpenCV：计算机视觉和图像处理库。scikit-learn：机器学习库。tensorflow：深度学习库。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e78d2bf82643869c09db95afa01d5ccf/" rel="bookmark">
			PYTHON绘制常见函数图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装Matplotlib和NumPy库 1）Matplotlib库的使用 Matplotlib库由各种可视化类构成,内部结构复杂,受Matlab启发。matplotlib.pyplot是绘制各类可视化图形的命令子库
2）引入pyplot子库 import matplotlib.pyplot as plt
2.常用方法 1）plt.figure()方法 创建画布，可以通过参数指定它的大小和背景颜色：
plt.figure(figsize=None, facecolor=None)
2）plt.subplot() 在全局绘图区域绘制一个子图
plt.subplot(nrows, ncols, index, **kwargs) 3个参数，分别代表网格的行数 nrows，列数 ncols，索引号index。它们都是位置参数。
plt.subplot(pos, **kwargs) 3位数的整数，每一位分别代表网格的行数，列数 ，索引号。pos也是是位置参数。
plt.subplot(**kwargs) 用默认值创建一个子图。
plt.subplot(ax) 以一个axes为参数，创建子图。
3）plt.axes(rect,axisbg='w') 创建一个坐标系风格的子图，用rect参数指定位置，用axisbg参数指定背景颜色。
4）plt.rcParams plt.rcParams["font.sans-serif"]=["SimHei"] # 设置字体为黑体
plt.rcParams["axes.unicode_minus"]=False # 防止负号乱码
Matplotlib库默认是不支持中文的，使用中文会产生乱码，如果要使用中文可以在导入库后加入下列两行代码来临时修改配置文件
5）plt.title()和plt.suptitle() 用plt.title()方法为子图添加标题，也可以使用plt.suptitle()方法为当前绘图区域添加中心标题。
6）plt.xlabel(s)和plt.ylabel(s) 使用plt.xlabel(s)和plt.ylabel(s)方法可以分别设置当前x轴和y轴的标签。
7）plt.grid() 使用plt.grid()方法可以设置图表中的网格线：
plt.grid(b=None, which='major', axis='both', **kwargs)
b：可选，默认为 None，可以设置布尔值，true 为显示网格线，false 为不显示，如果设置 **kwargs 参数，则值为 true。
which：可选，可选值有 ‘major’、‘minor’ 和 ‘both’，默认为 ‘major’，表示应用更改的网格线。
axis：可选，设置显示哪个方向的网格线，可以是取 ‘both’（默认），‘x’ 或 ‘y’，分别表示两个方向，x 轴方向或 y 轴方向。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e78d2bf82643869c09db95afa01d5ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c3f9d1ff54d22ce51e9027992b6ec5/" rel="bookmark">
			python 第四章 函数 （pycharm） （1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、python函数介绍 函数中三要素
函数名 必须定义
参数 （可选）将数据传递函数中使用
返回值 （可选）将函数中的数据传递外部进行使用
二、函数使用 2-1 语法格式 def 是定义函数的关键
def 函数名(参数): 代码的逻辑片段 return 返回值 函数的调用执行
函数名()
2-2 函数的基本定义和使用 # 函数的介绍 # 功能1 def login(name_list,password_list): # 接受参数 # 函数作用域 # 通过四个空格，来确认函数所执行的逻辑从哪里开始 for num in range(3): # [0,3) 0,1,2 name = input('请输入用户名:') password = input('请输入密码:') # 先判断用户名是否正确 if name in name_list: # 在判断密码是否正确 if password in password_list: print('登录成功') # 适应break关键，会结束循环，不再进行取值 break else: print('密码不正确') else: print('用户名不正确') # 功能2 def register(): name = input('请输入注册的用户名：') password = input('请输入出注册的密码：') name_list = [name] password_list = [password] # 将函数的的数据返回到外部 return name_list, password_list # 功能3 def pay(): print('支付') # 功能4 def order(): print('下单') name_list = None password_list = None while 1==1: num = input('1-登录 2-注册 3-支付 4-下单 5-退出程序:') if num == '1': # 函数功能的调用 # namelist和password_list 是函数的参数 login(name_list,password_list) # 函数名() elif num == '2': name_list, password_list = register() elif num == '3': pay() elif num == '4': order() else: break 2-3 函数参数 # 函数的介绍 # 功能1 def login(name_list,password_list): # 接受参数 # 函数作用域 # 通过四个空格，来确认函数所执行的逻辑从哪里开始 for num in range(3): # [0,3) 0,1,2 name = input('请输入用户名:') password = input('请输入密码:') # 先判断用户名是否正确 if name in name_list: # 在判断密码是否正确 if password in password_list: print('登录成功') # 适应break关键，会结束循环，不再进行取值 break else: print('密码不正确') else: print('用户名不正确') # 功能2 def register(): name = input('请输入注册的用户名：') password = input('请输入出注册的密码：') name_list = [name] password_list = [password] # 将函数的的数据返回到外部 return name_list, password_list # 功能3 def pay(): print('支付') # 功能4 def order(): print('下单') name_list = None password_list = None while 1==1: num = input('1-登录 2-注册 3-支付 4-下单 5-退出程序:') if num == '1': # 函数功能的调用 # namelist和password_list 是函数的参数 login(name_list,password_list) # 函数名() elif num == '2': name_list, password_list = register() elif num == '3': pay() elif num == '4': order() else: break 2-4 参数接收数据类型 # 函数参数能接受的数据类型 data_str = 'itcast' data_list = ['hadoop', 'spark'] data_tuple = ('hadoop', 'spark') data_set = {'hadoop', 'spark'} data_dict = {'id': 1} def func(data): # 要求传递的数据是字典 # 判断传递的数据是什么类型 if type(data) == dict: # 参数的类型由传递的数据决定 print(type(data), data) # 按照字典进行操作 data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c3f9d1ff54d22ce51e9027992b6ec5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/338/">«</a>
	<span class="pagination__item pagination__item--current">339/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/340/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>