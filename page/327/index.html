<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef519e599e13a6217746cc4e1e6402c6/" rel="bookmark">
			C&#43;&#43;初阶学习第十一弹——探索STL奥秘（六）——深度刨析list的用法和核心点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在前面，我们已经学习了STL中的string和vector，现在就来讲解STL中的最后一个部分——list的使用及其相关知识点，先说明一点，因为我们之前已经讲过了string和vector的接口函数等用法，list的这些用法与它们相差不大，所以我们讲解的重心就不再是如何使用list上，而是后面list的模拟实现和一些细节点
目录
一、list的使用
1.1 list的简单接口函数
1.2 list的注意事项
二、list的模拟实现
三、list和vector的区别
四、总结
一、list的使用 1.1 list的简单接口函数 首先我们需要先明确list的底部实际上是类似一个带头双向链表的，结构如下图所示：
因此list非常便于插入和删除数据，下面我们就先来看一下list的一些重要的接口函数
初始化列表：
std::list&lt;int&gt; myList = {1, 2, 3, 4, 5}; 通过迭代器访问元素：
std::list&lt;int&gt;::iterator it = myList.begin(); while (it != myList.end()) { std::cout &lt;&lt; *it &lt;&lt; std::endl; ++it; } 在链表尾部插入元素：
myList.push_back(6); 在链表头部插入元素：
myList.push_front(0); 删除元素：
myList.remove(3); // 删除值为3的元素 myList.erase(it); // 删除迭代器指向的元素 排序链表：
myList.sort(); 反转链表：
myList.reverse(); 上面这些就是list经常使用的一些接口函数，没啥难度，有不理解的地方可以私信我或者到网上搜一下
1.2 list的注意事项 迭代器失效： 在list进行插入和删除操作时，不仅操作的元素所在的迭代器会失效，所有指向链表的迭代器、指针和引用都会失效。因此，在进行操作后，需要重新获取有效的迭代器。（vector的使用也要注意这个问题）内存效率： list的内存效率相对较高，因为它不需要像数组那样连续分配内存，但是它的插入和删除操作的时间复杂度为O(1)，这是因为链表的每个元素都需要存储指向前后节点的指针。没有容量概念： list没有容量(capacity)这个概念，它总是根据需要动态分配内存。元素唯一性： list中的元素是不重复的，如果尝试插入已经存在的元素，该元素将被覆盖。操作顺序： 由于list是双向链表，因此插入和删除操作会保持元素的相对顺序，即元素在链表中的位置不会改变。 使用list时，应该根据具体需求选择合适的操作，并注意迭代器的管理，以确保程序的正确性。
特别强调一下迭代器失效的问题，list的迭代器失效问题一般只有在删除元素的时候会出现，因为它插入数据的时候都是开辟的新空间，不同数据之间一般不是连接在一起的
二、list的模拟实现 list的模拟实现上与前面的vector和string也极为相似，这里我们主要想讲一下list的迭代器的模拟实现，首先我们要知道，因为我们期待迭代器能像指针那样发挥作用，所以它的模拟实现需要包含以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef519e599e13a6217746cc4e1e6402c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a95b7a5e1947b91c8492f7909bb945c/" rel="bookmark">
			【赠书第26期】AI绘画教程：Midjourney使用方法与技巧从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
1 Midjourney入门指南
1.1 注册与登录
1.2 界面熟悉
1.3 基础操作
2 Midjourney进阶技巧
2.1 描述词优化
2.2 参数调整
2.3 迭代生成
3 Midjourney高级应用
3.1 创意启发
3.2 团队协作
3.3 商业应用
4 总结与展望
5 推荐图书
6 粉丝福利
前言 在数字艺术日益繁荣的今天，AI 绘图工具成为了创作者们的新宠。其中，Midjourney 以其强大的生成能力和灵活的操控性，赢得了众多艺术家的青睐。本文将从入门到精通，详细阐述 Midjourney的使用方法与技巧，帮助读者掌握这一强大工具。
1 Midjourney入门指南 1.1 注册与登录 在 Midjourney 的官方网站进行注册，填写相关信息后，即可获得一个账户。注册成功后，使用用户名和密码登录 Midjourney 平台。
1.2 界面熟悉 Midjourney 的界面简洁明了，主要包括输入栏、生成栏、设置栏等部分。输入栏用于输入描述词和参数，生成栏用于展示生成的图片，设置栏则用于调整生成参数和输出设置。
1.3 基础操作 在输入栏中输入描述词，例如“森林中的独角兽”，然后点击生成按钮，即可在生成栏中看到生成的图片。此时，可以根据需要调整参数和设置，以获得满意的图片。
2 Midjourney进阶技巧 2.1 描述词优化 描述词是 Midjourney 生成图片的关键。为了使生成的图片更加符合自己的需求，需要掌握一些描述词的优化技巧。例如，使用具体的形容词和名词来描述细节，避免使用模糊和笼统的词汇。同时，可以尝试使用不同的描述词组合，以获得更多样化的图片。
2.2 参数调整 Midjourney 提供了丰富的参数供用户调整，包括风格、尺寸、分辨率等。通过调整这些参数，可以进一步控制生成的图片。例如，可以尝试调整风格参数以改变图片的整体风格，或者调整尺寸和分辨率以获得更高质量的图片。
2.3 迭代生成 Midjourney 支持迭代生成，即根据上一次生成的图片进行调整和优化。在生成栏中选中已生成的图片，然后修改描述词或调整参数，再次点击生成按钮即可。通过不断迭代生成，可以逐渐完善自己的作品。
3 Midjourney高级应用 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a95b7a5e1947b91c8492f7909bb945c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834f1f30683cf5788ba0c70bc4a1ef89/" rel="bookmark">
			编译安装PHP服务（LAMP3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.初始化设置，将安装PHP所需软件包传到/opt目录下
（1）关闭防火墙
（2）上传软件包到/opt目录
2.安装GD库和GD库关联程序，用来处理和生成图片
3.配置软件模块
4.编译及安装
5.优化把PHP 的可执行程序文件放入路径环境变量的目录中便于系统识别
6.复制模版文件作为PHP 的主配置文件，并进行修改
7.修改httpd 服务的配置文件，让apache支持PHP
8.验证PHP 测试页
linux设置
浏览器访问
1.初始化设置，将安装PHP所需软件包传到/opt目录下 （1）关闭防火墙 systemctl stop firewalld.service #关闭防火墙 setenforce 0 #关闭selinux防火墙 （2）上传软件包到/opt目录 2.安装GD库和GD库关联程序，用来处理和生成图片 yum -y install \ gd \ libjpeg libjpeg-devel \ libpng libpng-devel \ freetype freetype-devel \ libxml2 libxml2-devel \ zlib zlib-devel \ curl curl-devel \ openssl openssl-devel #本地yum安装 3.配置软件模块 cd /opt #切换到opt目录 tar xf php-7.1.10.tar.bz2 #解压 cd /opt/php-7.1.10/ #切换到/opt/php-7.1.10/目录 ./configure \ #指定将PHP程序的安装路径 --prefix=/usr/local/php \ --with-apxs2=/usr/local/httpd/bin/apxs \ #指定Apache httpd服务提供的apxs 模块支持程序的文件位置 --with-mysql-sock=/usr/local/mysql/mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/834f1f30683cf5788ba0c70bc4a1ef89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671a6756b822e0745f9e8febfe42ebdb/" rel="bookmark">
			大象AI写作 我是如何编写一套属于自己的Prompt提示词的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文背景 我们在写提示词的时候，AI对COT少量样本的学习能力很重要。
要编写出一套出色的内容创作提示(prompt)，关键在于如何教GPT进行自我创作，这就是一门“know how”的艺术。
比如当你要AI写一个视频标题，初学者只是简单地提出“帮我想一个热门视频标题”。但是，热门的定义是什么？它的热门程度是什么？应该运用哪些创作技巧？ 如果你没有明确这些要素，GPT怎么能创作出满足你期望的内容？
低质量的输入只会导致低质量的输出。
正确的方法是提供一套明确的创作方法论和技巧，比如使用特定的修辞手法、写作视角、语言风格或内容结构，让AI有一个模仿和学习的基础。
数据采集 首先我们需要收集用于模仿的内容。在我的案例中，要收集几十个目标博主的视频标题，这些将作为我们的“数据”。数据收集可以通过两种方式进行：
第一种是手工采集，即直接复制粘贴、OCR识别或手动输入。
第二种是自动采集，使用爬虫或脚本。 我使用的是“后羿采集器”的爬虫软件。
我原本计划写一个使用后羿采集器采集小红书笔记的教程，但由于小红书页面经常更新，所以就算写一个出来也会很快失效。
不过本文的主题并不是数据采集，等我找到新方法后分享相关教程。 完成采集后，将数据导出为Excel表格。
获得高点赞数的视频标题质量是较高的，所以我建议使用WPS打开表格后，通过筛选功能按“点赞数”降序排列，以便快速找到最受欢迎的标题和文案。
数据整理 数据清洗的过程，本质上是去除不需要的数据并保留有价值的信息。
数据清洗同样可以通过手工或自动两种方式进行。
手工清洗意味着自己复制粘贴和删除，如果数据量不大，这种方法是可行的。
但现在能用AI了，重复性工作自然应该交给自动化工具来完成。
我推荐的方法是使用AI的数据分析器（之前称为代码解释器），上传Excel表格后，下达数据清洗的指令，明确指出需要去除和保留的内容。
如图示
这是一个GPT4数据分析器的使用范例。如果我们的目标仅仅是获取标题，实际上可以直接在Excel中选择并复制。
方法论拆解 1、拆解分析维度
首先，我给 GPT 提问：
❝ 假设我们只关注小红书博主视频笔记的标题文字，忽略其他因素，我应该如何分析这些标题，以便学习其文字风格和创作技巧，进而模仿出同样吸引人的标题呢？
GPT 回复：
❝ GPT的回答提供了一套分析框架：
关键词运用：留意博主频繁使用的关键词或短语，它们可能与博主的内容主题、风格或目标受众紧密相关。
标题长度：分析标题是简洁有力还是详尽描述，不同长度的标题各有其优势。
语言风格与语调：观察标题是正式还是非正式，是否运用了修辞技巧，如夸张、对比等。
结构与格式：注意是否有固定的模式，如“技巧清单”或“问题解答”，以及是否使用了数字、符号等吸引注意。
问题解决：标题是否指出并解决了一个具体问题。
目标受众：标题是否针对特定受众群体，使用了受众熟悉的术语。
这些维度为我们提供了一个全面的分析框架，但还有更多细节值得我们深挖。
请思考有哪些我们可能忽略的点？
在分析小红书博主视频笔记标题时，除了上述提到的几个维度，还有一些可能被忽视的分析点：
文化与背景：标题中是否有文化、历史或社会元素的引用。 时效性：标题是否与时事热点、流行文化或季节性事件相关联。 互动性：标题是否鼓励观众参与，如提问或挑战。 对比与对照：标题是否使用对比手法，展示不同情境或变化。 神秘感与好奇心：标题是否创造神秘感，激发读者的好奇心。 跨平台策略：博主是否借鉴了其他社交媒体平台的流行标题策略。 品牌连贯性：是否有一致的命名或风格，使内容易于识别。 视觉元素：虽然不是文字分析的一部分，但配图或缩略图也可能影响点击率。 总的来说，全面分析需要考虑文化、受众、品牌策略等多个层面，通过细致的观察与分析，是成功的关键。
这样我们就得到了多个分析标题的维度，其中有些并不适用于分析小红书视频笔记，所以我们需要剔除一些无关的维度，例如”参考其他平台的策略“、”品牌和连贯性“。
2、分析标题 我们打开一个新的 GPT 对话窗口，发布对标题进行分析的指令。
在深入探究某位小红书博主的视频笔记标题时，忽略其他干扰因素，专注于标题的文字特性，以此来学习博主在创作视频标题时的文字风格和技巧，可以从以下几个方面进行分析：
[在此插入我们先前讨论的分析维度]
接下来，我将提供一些我认为制作精良的视频标题。基于这些标题，请您针对每一个分析维度进行详尽的分析。
对于每个维度，请列出3至5种技巧，并为每种技巧附上详细的解释和示例。应优先考虑使用原标题作为例证，并提供深入的分析。
若发现某些分析维度在所提供的内容中未被触及，请直接指出“未体现”。
[在此填入在数据处理阶段收集到的标题]
GPT 的性能受限于输入长度，即token的数量。由于分析维度本身已占用较多token，因此我仅选取了大约20个标题进行分析，我们追求的是质量而非数量。
通过这种方法，我们获得了GPT对这些标题的详细分析：
创作 prompt 我们所有努力的核心目标是知道如何指导GPT进行创造性写作，掌握其创作技巧的“know how”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/671a6756b822e0745f9e8febfe42ebdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c956dff5e59d46e177cad7fcdcd8fc4c/" rel="bookmark">
			深入理解Prompt Engineering：Transformers与OpenAI的实践启示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我最近完成了吴恩达的《ChatGPT提示工程师》课程的学习。这门课程如何通过精心设计的提示来引导模型生成我们想要的输出。然而，我必须承认，尽管这门课程的内容丰富且深入，但我在完成课程后并没有获得让我从提示词，上升到“工程化”的理解。
在我看来，这门课程的内容和我之前使用OpenAI API的经验相差无几。我之前已经熟悉了如何使用API，如何发送请求，以及如何处理返回的结果。我也已经理解了如何通过调整一些参数，如temperature和tokens，来影响模型的输出。但是对于prompt是打开大模型这座金矿的钥匙，课程里的prompt 设计技巧，没什么感觉…
带着这些迷茫，我投入了AI绘画炼丹，更细致的prompt,绘画专用提示词，让我感受到了prompt的效果。但是对于不搞设计的我，在绘画领域投入太多时间练习prompt工程，不会是好的方向,提示词工程的学习肯定也深入不了…
我怎么掌握提示词工程这门AI显学呢？从哪个实战项目入手呢？最近我在玩Transformers 和 OpenAI的时候，好像有了点感悟。
何为Transformers？ Transformers是由Hugging Face公司开发的一个开源库，专门用于自然语言处理（NLP）任务。它提供了大量预训练的模型和分词器，可以用于各种NLP任务，如文本分类、命名实体识别、情感分析、文本生成等。在我的上一篇文章AIGC前端工程师的Transformers 入门（一）：pipeline - 掘金 (juejin.cn)中有一些demo, 建议大家也玩起来。
Transformers和OpenAI的对比 OpenAI和Transformers都是我在探索人工智能和自然语言处理（NLP）领域的重要工具。OpenAI让我感受到了人工智能生成内容（AIGC）的力量。通过使用OpenAI，我可以生成各种各样的文本，从简单的句子到复杂的文章，甚至是编程代码。这种能力让我深感震撼，也让我对人工智能的未来充满了期待。
与此同时，Transformers库让我深入了解了机器学习和NLP的底层原理。Transformers提供了大量的预训练模型，如BERT、GPT-2、RoBERTa等，这些模型在各种NLP任务上都表现出色。通过学习和使用这些模型，我对深度学习的工作原理有了更深的理解。我了解到，这些模型的强大性能并不是偶然的，而是建立在大量的数据和精心设计的架构之上。
OpenAI和Transformers的结合，让我既能感受到人工智能的魅力，也能理解其背后的科学原理。这种结合让我对AIGC的学习充满了信心，同时又可以快速开展业务。
于是我有了个想法，同类型的任务，分别用transformers 和 OpenAI，各自怎么做？
NLP任务 以下是Transformers情感分析的demo
python复制代码 !pip install transformers # 安装huggingface开源的 transformers库 from transformers import pipeline # pipeline是 transfromers的模块，专业安排各种NLP。 classifier = pipeline('sentiment-analysis') #安排了情感分析任务 result = classifier('I love you')[0] #返回情感分析结果 print(f"label: {result['label']}, with score: {round(result['score'], 4)}") 输出结果为 label: POSITIVE, with score: 0.9999 0.9999 当时学完这个NLP任务的例子后，感觉自己可以从WEB开发，走向AI功能的开发了，transformers真的简单，好用！
没想到，当我看到OpenAI的文本分析Demo后，惊喜连连…
python复制代码import openai openai.api_key = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c956dff5e59d46e177cad7fcdcd8fc4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d4bcce4d943dee1a538bfa057fa632/" rel="bookmark">
			搭建zookeeper单机环境实现简单的增删改查（CRUD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ==========jdk========= 1. 下载JDK： 从官网（***/java/technologies/javase-downloads.html）下载所需的Linux版JDK，如jdk1.8.0_261.tar.gz。
2. 解压缩JDK： 将下载的JDK压缩包解压缩到指定的目录，例如/home/username/devTools。可以使用以下命令：
tar -zxvf jdk1.8.0_261.tar.gz
3. 配置JDK： 将JDK的bin目录添加到系统的环境变量中。在Shell中执行以下命令：
export JAVA_HOME=/home/username/devTools/jdk1.8.0_261
export PATH=$JAVA_HOME/bin:$PATH
4. 验证JDK： 使用`java -version`命令验证是否成功安装和配置了JDK。如果一切正常，将显示JDK的版本信息。
=====ZooKeeper整体步骤==== 1、下载：apache.zookeeper.org
https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.2/apache-zookeeper-3.7.2-bin.tar.gz
2、解压缩
3、配置：
创建dataDir目录
创建zoo.cfg文件
修改配置文件
dataDir=/home/123/devTools/apache-zookeeper-3.7.2-bin/dataDir
4、启动ZooKeeper服务端
./zkServer.sh start
5、启动客户端
./zkCli.sh -server 192.168.249.134:2181
6、CRUD
====================== xhell的连接问题 ====================== （xshell的连接问题）
Xhsell进行连接
1、下载：apache.zookeeper.org https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.2/apache-zookeeper-3.7.2-bin.tar.gz
2、解压缩 2.1解压jdk-8u261-linux-x64.tar.gz 2.2解压apache-zookeeper-3.7.2-bin.tar.gz 1.3zookeeper下相关的文件 3、配置 3.1 创建dataDir目录 3.2创建zoo.cfg文件（zoo.sample.cfg复制过来然后改成zoo.cfg） 3.3修改配置文件 esc 然后：wq退出并保存（或者强制退出：q！）
4、启动ZooKeeper服务端 ./Server.sh start 5、启动客户端 6、创建数据库 6.1创建一个jiyuting 6.2查询 6.3修改 6.4删除 6.5删除成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b1ac1d346be205fb841a88b85c805b/" rel="bookmark">
			怎么画程序流程图？3款AI自动生成流程图软件推荐，办公绘图必备！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序流程图是什么？
程序流程图是一种图形化表示程序逻辑的视觉工具，它以直观的方式展示了程序的执行流程和结构。流程图通过一系列的图形符号和箭头来表示程序中的不同操作和决策点，使得程序的执行过程一目了然。程序流程图对于软件开发者来说至关重要，它不仅有助于开发者在编程前规划和设计程序的逻辑，还能在开发过程中作为检查和调试程序的工具。
*程序流程图
程序流程图怎么画？ 画程序流程图，与画其他类型的流程图的步骤基本是一致的，包括明确绘图需求、设计草图、选择工具、开始绘制、添加注释、检查和修改等。
需求分析：与项目团队沟通，明确程序流程图需要展示的功能和需求。设计草图：在纸上或白板上草拟流程图的基本框架和结构。选择工具：选择合适的流程图绘制工具或软件，准备绘制。绘制符号：根据设计草图，在工具中绘制各种流程图符号。连接流程：使用流程线将各个符号连接起来，形成完整的流程。添加注释：在需要的地方添加注释，对流程图中的某些部分进行说明。审查和修改：与团队成员一起审查流程图，根据反馈进行必要的修改。最终确认：确保流程图准确无误，得到所有相关人员的认可。 整体而言，画程序流程图包含的步骤较多，过去受限于技术的发展，我们只能通过手绘来完成，而当下出现了众多基于AI技术来绘图的工具和软件，我们也可以切换到这些新一代的AI绘图软件，如boardmix AI、Miro Assist、EdrawMax AI等，使用它们来代替复杂繁琐的绘图过程。
AI生成程序流程图的软件推荐 ① AI生成程序流程图boardmix AI boardmix，是一款以无限白板作为载体的在线流程图软件，提供了近乎无限大的画布，可在其中自由绘制流程图。boardmix集成了时下流行的AI绘图功能，支持AI自动生成流程图、AI自动生成思维导图、AI自动生成用户旅程图、AI自动生成商业画布、AI自动生成SWOT分析图等，让绘图效率更上一层楼。
*自动生成流程图软件boardmix
自动生成流程图软件boardmix-功能亮点：
AI辅助生成流程图：boardmix利用AI技术帮助用户快速生成流程图，简化了绘图过程。多种模板：boardmix的「模板中心」和「模板社区」内置流程图、泳道图、组织结构图、会议流程图、ER图、时间线、UML等多种模板，满足不同场景的需求。智能排版：提供分支自动对齐、等间距数字显示、列表自动布局等智能化绘图功能。无限画布：提供无穷的画布创作空间，可无限延展，自由绘图不受限。一键美化流程图：支持一键美化流程图样式，多种风格自由切换。 *一键美化流程图
多人协作：支持多人同屏协作，实时显示协作成员头像和光标。多格式导入导出：支持PDF、PNG、JPG、bdx文件的导入和导出，可自定义导出分辨率、区域和背景。历史版本管理：可创建不同版本，按时间轴顺序随时回溯文件至任意历史版本。图标库：内置丰富的单色和多色图标库，支持图标尺寸、颜色更改。 如何使用boardmix AI生成程序流程图？ 在浏览器打开boardmix的首页，如下图所示，点击「AI一键生成流程图」，新建一个boardmix流程图文件。
在打开的boardmix流程图文件，会自动弹出下图的「AI生成流程图」浮窗，输入流程图主题或名称，按下回车键，boardmix AI会自动生成一个完整的流程图。
AI生成的流程图样式默认为白底黑边，如果你不喜欢这一默认样式，可以用鼠标框选整个流程图，点击工具栏的第一个选项「流程图主题」，弹出的浮窗展示了boardmix内置的所有流程图主题，单击任意选项，即可一键美化流程图。
*boardmix一键美化流程图
海量流程图模板，尽在boardmix模板中心 除了使用AI生成流程图，boardmix还内置了一个提供海量优质模板的「模板中心」，在使用AI生成流程图之前，我们也可以先从这里搜索查找模板，如果有合适的流程图模板，直接调用模板即可，如果没有，再使用boardmix AI生成对应的流程图。
使用boardmix模板中心的步骤：
在任意一个boardmix文件中，点击左侧工具栏的第1个选项「模板中心」，打开下图的模板中心面板。boardmix模板中心提供了适用于不同场景的可视化模板，包括绘图&amp;创作、调研分析、灵感/笔记、项目管理、头脑风暴、策略&amp;分析、会议&amp;工作坊、企业管理。
如果想要查看模板中心内置的流程图模板，可以点击面板左侧的「绘图&amp;创作」类别，查看该分类下的所有模板资源。
当然，我们也可以在顶部的搜索框输入想找的流程图模板名，查找筛选出所有与之相关的模板资源。
② AI生成程序流程图Miro Assist Miro（原RealtimeBoard）是一个协作式在线白板平台，与前面介绍的boardmix类似，它提供了一个无限大的画布，允许团队成员共同创建、编辑和分享流程图。
在原有功能的基础上，Miro推出了一个基于AI技术的功能模块——Miro Assist，目前处于测试阶段（beta）。它旨在通过AI技术帮助用户扩展思维、快速探索新主题、调整团队方向，并通过AI驱动的思维导图和图表生成来加速工作流程。
自动生成流程图软件Miro-功能亮点：
AI 驱动的思维导图和图表生成：Miro Assist 可以基于用户的内容快速生成新的思维导图和各类图表。洞察力获取：从客户研究、回顾或研讨会中挖掘最有价值的见解。即时可视化：自动生成演示文稿、行动列表等，以动员团队和利益相关者。控制权：管理员和用户可以根据自身业务需求启用或禁用 Miro Assist。 客观而言，Miro Assist目前可生成的内容类型较少，仅限于序列图、思维导图、便签、图片、代码块，而同类型的boardmix AI可生成的内容包括流程图、思维导图、用户旅程图、商业画布、用户画像、SWOT分析、PPT、代码、图片、文本等，且原生支持中文语言，对国内用户更为友好。
③ AI生成程序流程图EdrawMax AI EdrawMax是一个多功能的图表制作工具，它支持创建上百种类型的图表，包括流程图、思维导图、组织结构图、甘特图等。EdrawMax的AI流程图生成器是一个在线工具，它利用人工智能技术从文本描述、数据集或图表自动创建流程图，分析输入数据，识别逻辑关系，并将信息组织成结构化的视觉表示。
值得一提的是，EdrawMax在国内也有相应的中文版本——亿图图示，被看作是最接近微软Visio的绘图软件，不过最新的亿图图示已推出AI功能，相比而言，迭代速度比Visio更快，也更契合本地用户的需求。如果你掌握的英语能力不是很好，建议优先使用EdrawMax的国内版本。
自动生成流程图软件EdrawMax-功能特点：
文本到流程图的转换：EdrawMax AI能够将文本转换为流程图，简化了创建过程。
多种图表类型：支持生成流程图、思维导图、饼图、柱状图、折线图等多种图表。
自定义设计：用户可以自定义流程图的设计和外观，包括颜色、形状、符号、字体和布局。
导出多种格式：支持超过10种格式的导出，包括VSDX、PPTX等，方便进一步编辑或演示。
AI辅助：提供AI辅助的图表制作、绘图、图片分析和聊天功能。
模板和图标库：提供超过100万个模板、形状、图片、图表和图标。
程序流程图各图形代表什么？ 程序流程图，归属于流程图整个大类中的细分图形，用于描述程序的逻辑流程和步骤，在绘制程序流程图时，常用的各图形与其他流程图类型相差不大，这些图形在不同的流程图中，所代表的含义也是通用的，具体如下——
开始/结束符号：通常是一个圆形或椭圆形，表示流程的开始和结束。
处理/动作/活动符号：矩形框，用于描述流程中的一个具体步骤、操作或活动。
判断/决策符号：菱形框，表示根据某一条件进行决策，并指向不同的流程分支路径。
输入/输出符号：通常是一个指向处理框的带箭头的三角形，表示数据或信息的输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26b1ac1d346be205fb841a88b85c805b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f52ba8614499bfd9bbc91674a07022b/" rel="bookmark">
			Java Sort 方法的使用（包含Arrays.sort(),Collections.sort()以及Comparable，Comparator的使用 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Comparable &amp;&amp; Comparator的使用：
Comparable:
Comparator:
Arrays.sort()的使用:
升序排序：
降序排序：
自定义排序方法：
在日常的刷题或开发中，很多时候我们需要对数据进行排序，以达到我们的预期效果的作用。那么这些排序方法具体怎么实现和使用呢？本文就来好好缕一缕，总结一下这些方法：
Comparable &amp;&amp; Comparator的使用： Comparable: 当我们对类中的对象进行比较时，要保证对象时可比较的，这时我们就需要用到Comparable 或 Comparator接口，然后重写里面的compareTo()方法。假设我们有一个学生类，默认需要按照学生的年龄age排序，具体实现如下：
class Student implements Comparable&lt;Student&gt;{ private int id; private int age; private String name; public Student(int id, int age, String name) { this.id = id; this.age = age; this.name = name; } @Override public int compareTo(Student o) { //降序 //return o.age - this.age; //升序 return this.age - o.age; } public int getId() { return id; } public void setId(int id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f52ba8614499bfd9bbc91674a07022b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b842e082cb58538a7d53ef5c582aab0/" rel="bookmark">
			植物大战僵尸杂交版破解C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言准备工作：基地址与偏移UI界面设计和绑定项目模板总览图生成与实现信号处理1、阳光值更新:BTN12、三种钱币值更新:BTN2-BTN43、冷却刷新:BTN54、锁定阳光：check15、无冷却：check26、OnTimer（）和OnClose（）处理函数7、其余未描述部分参考 前言 最近出来的PVZ杂交版又掀起一波热潮，在各大短视频平台也有一席之地，借助工具Cheat Engine，写了个简单的植物大战僵尸杂交版破解程序，话不多说，我们来看如何实现的。
工具：Cheat Engine、visual studio （MFC支持）、植物大战僵尸杂交版
准备工作：基地址与偏移 通过CE寻找基地址的工作可以参考其他人的博客：
通过CE寻找游戏基址1
通过CE寻找游戏基址2
这里直接给出对应内容：【基址+偏移】
阳光值：0x006A9EC0 + 0x00000768 + 0x00005560
银币值：0x006A9EC0 + 0x0000082C + 0x00000208
金币值：0x006A9EC0 + 0x0000082C + 0x0000020C
钻石值：0x006A9EC0 + 0x0000082C + 0x00000210
冷却值：0x006A9EC0 + 0x00000768 + 0x00000144 +{
0x00000070, 0x000000C0, 0x00000110, 0x00000160,
0x000001B0, 0x00000200, 0x00000250, 0x000002A0,
0x000002F0, 0x00000340, 0x00000390, 0x000003E0,
0x00000430, 0x00000480, 0x000004D0, 0x00000520
对应卡牌栏目第几章卡牌，索引就是几，实际上卡牌不会超过14张，只要给出14个就行了，找到前几个偏移量之后可以按照规律往后推测。
}
UI界面设计和绑定 项目模板 使用MFC应用程序，选择基于对话框选项
总览图 生成与实现 1、依此双击按钮、单选框，studio会自动建立信号与函数的映射。
2、Dlg.h中添加成员变量：
public： UINT sunvalue;	//阳光 UINT money_a;	//银币 UINT money_b;	//金币 UINT money_c;	//钻石 int check1;	//锁定阳光	check 的状态 int check2;	//无冷却	check 的状态 3、Dlg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b842e082cb58538a7d53ef5c582aab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54747608a86205d9d5b2727fdd356e30/" rel="bookmark">
			Java 抽象类和接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 抽象类和接口 1. 抽象类1.1 什么是抽象类1.2 抽象类的语法1.3 抽象类的特性1.4 抽象类的意义 2. 接口2.1 接口的概念2.2 接口的语法2.2.1 接口的关键字2.2.2 接口中的成员变量以及成员方法 2.3 接口的使用2.4 接口的特性2.5 实现多个接口2.6 接口间的继承 3. 接口的使用实例3.1 实现对象的可比较3.1.1 Comparable 接口3.1.2 Comparator 接口 3.2 对象数组的排序3.2.1 根据Comparable 接口排序3.2.2 根据比较器进行排序 3.3对象的拷贝3.3.1 普通拷贝3.3.2 浅拷贝3.3.3 深拷贝 4. 判断类相等 🔥 博客主页: 偷心编程
🎥 系列专栏: 《Java学习》 《C语言学习》
❤️ 感谢大家点赞👍收藏⭐评论✍️
1. 抽象类 1.1 什么是抽象类 从程序上来说就是这个类中的某些方法没有具体的实现代码，只是定义了一个这样的方法的名字，表示存在一个这样的方法。因此抽象类一定是用来继承的，必须要子类来实现这些具体的方法。方便多态的实现。
从实际意义上理解是这样的：在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。如下：
1.2 抽象类的语法 关键字：abstract
// 抽象类：被abstract修饰的类 public abstract class Shape { // 抽象方法：被abstract修饰的方法，没有方法体 abstract public void draw(); abstract void calcArea(); // 抽象类也是类，也可以增加普通方法和属性 public double getArea(){ return area; } protected double area; // 面积 } 注：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54747608a86205d9d5b2727fdd356e30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3abe70d0fe65df709284babb591063bf/" rel="bookmark">
			Pylance has crashed. Would you like to try using a Node.js executable to run the language server?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vscode编程python代码时，跳转到函数定义的功能（F12或者control+左键）没反应，并同时右下角提示：
Pylance has crashed. Would you like to try using a Node.js executable to run the language server? 主要是Pylance 插件的问题，
打开 settings.json 按F1输入 open settings选择 Open User Settings (JSON) 修改languageServer 将原始python.languageServer":"Pylance " 改为 python.languageServer":"Jedi" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0f9d04b4910b2ba52e76e2752e53bb/" rel="bookmark">
			Python魔法之旅-魔法方法(04)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1、定义
2、作用
二、主要应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
14、__enter__方法
14-1、语法
14-2、参数
14-3、功能
14-4、返回值
14-5、说明
14-6、用法
15、__eq__方法
15-1、语法
15-2、参数
15-3、功能
15-4、返回值
15-5、说明
15-6、用法
16、__exit__方法
16-1、语法
16-2、参数
16-3、功能
16-4、返回值
16-5、说明
16-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、主要应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc0f9d04b4910b2ba52e76e2752e53bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4539ea16db51b31121204bba10a35f79/" rel="bookmark">
			Android 如何传递参数给webView的h5页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.最简单的方式是通过URL参数将数据传递给H5页面 Android可以通过WebView的loadUrl()方法加载带有参数的URL，H5页面可以通过解析URL来获取参数值。
首先，在Android端构造带有参数的URL，然后加载该URL到WebView中：
WebView webView = findViewById(R.id.webView); String param1 = "value1"; String param2 = "value2"; String url = " + param1 + "&amp;param2=" + param2; webView.loadUrl(url); 在H5页面中，可以通过解析URL获取参数值：
function getParameterByName(name, url) { if (!url) url = window.location.href; name = name.replace(/[[\]]/g, "\\$&amp;"); var regex = new RegExp("[?&amp;]" + name + "(=([^&amp;#]*)|&amp;|#|$)"), results = regex.exec(url); if (!results) return null; if (!results[2]) return ''; return decodeURIComponent(results[2].replace(/\+/g, " ")); } var param1 = getParameterByName('param1'); var param2 = getParameterByName('param2'); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4539ea16db51b31121204bba10a35f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82094a80be1eae28eead578cde1eb4f4/" rel="bookmark">
			【C&#43;&#43;修行之道】类和对象（二）类的6个默认成员函数、构造函数、析构函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、类的6个默认成员函数
二、构造函数
2.1 概念
2.2 特性
2.2.5 自动生成默认构造函数
不进行显示定义的隐患：
2.2.6 自动生成的构造函数意义何在？
两个栈实现一个队列
2.2.7 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。
2.4 一般情况，建议每个类，都可以写一个全缺省的构造（好用）
三、析构函数
3.1 概念
3.2 特性
3.3 C++实现括号匹配和C语言的不同
一、类的6个默认成员函数 如果一个类中什么成员都没有，简称为空类。
空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。
默认成员函数：用户没有显式实现，编译器会自动生成（半自动化）的成员函数称为默认成员函数。
class Date {}; 二、构造函数 2.1 概念 对于以下Date类：
class Date { public: void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1; d1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82094a80be1eae28eead578cde1eb4f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1dd858064b2353aecf10ea056124ea2/" rel="bookmark">
			Spring Cloud Gateway通过配置文件方式提供路由服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Spring Cloud Gateway的路由匹配规则 Spring Gateway支持两种方式提供路由服务，其一是配置文件启用，其二则是通过代码达到目的，此文章是通过配置文件方式
二、使用步骤 1.通过配置文件方式提供路由服务 yml配置如下（示例）：
gateway: routes: #路由数组，指当请求满足什么样的条件转发到整个微服务中某个服务上 - id: order_router #当前路由标识，要求唯一 uri: lb://provider #请求最终要被转发的地址，lb指的是从nacos中按照名称获取微服务，并按照负载均衡策略 order: 1 #路由的优先级，数字越小代表路由的优先级越高 predicates: #断言(条件判断，返回值是boolean，转发请求要满足的条件） - Path=/order/route/** #如果为/route/**,那么对应StripPrefix=1 filters: - StripPrefix=2 #在请求转发之前去掉一层路径，这里去掉orderservice 2.白名单 配置如下：
# 不校验白名单 ignore: whites: - /auth/logout - /auth/login - /auth/register - /**/v2/api-docs #对应的例如：- Path=/order/route/** - /*/v2/api-docs #对应的例如：- Path=/route/** - /csrf 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292eddaf8c656a95d918105984a9dad2/" rel="bookmark">
			20240531 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⚙️最强开源编程大模型一夜易主！Mistral AI 推出了其首个代码生成模型 Codestral
- Codestral 支持 80 多种编程语言，包括流行的 Python、Java、C、C++、JavaScript 和 Bash 等，以及较为冷门的 Swift 和 Fortran。
- 能够完成代码函数、编写测试，并使用填补中间的机制完成部分代码。
- 拥有 32k 的上下文窗口，超过同类竞品模型。
- 在 HumanEval、MBPP、CruxEval、RepoBench、Spider 等多个基准上表现出色。
- 提供 API 端点、插件和开发环境集成。
🔗详细：https://mistral.ai/news/codestral/
⚠️黑客发布破解版ChatGPT “Godmode GPT”
- 破解版ChatGPT“Godmode GPT”绕过了OpenAI限制，允许非法咨询。
- OpenAI采取行动，但黑客持续努力绕过AI模型限制。
- 用户试图破解AI模型，GPT-4o被成功破解，采用Leetspeak绕过限制。
🎶Udio推出新的udio-130音乐生成模型
- 可以生成2分钟的音频，帮助创建更具连贯性和结构的曲目。
- 增加了新的高级控制功能：随机种子设置、剪辑开始时间控制、提示词或歌词强度调节等。
- 方便用户精准控制音乐生成和剪辑。
🔗 https://blink.csdn.net/details/1712855
📱Apten：AI驱动的短信助手：​
- 以亲切的方式24/7响应并自动跟进客户。​
- 自动分类和标签潜在客户，提升营销和销售效率。​
- 自定义知识库，确保提供准确信息。​
🔗 https://blink.csdn.net/details/1712875
✈️卡塔尔航空与Space X的Starlink合作：​
- 提供免费、超高速、低延迟的Wi-Fi服务。​
- 首批升级三架波音777-300，未来两年覆盖整个机队。​
- 乘客可享受每秒高达500兆比特的Wi-Fi，支持直播、视频和在线游戏。​
🔗https://blink.csdn.net/details/1712885
🎨新SD加速模型！相比LCM模型PCM出图又快又稳 - 扩展了模型的应用范围，提高了图像的动态范围
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292eddaf8c656a95d918105984a9dad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5107d32884fa87f6f2a3d94eb00afd74/" rel="bookmark">
			是什么奠定了前端三分天下的局面？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是什么奠定了前端三分天下的局面？ 引言前端技术发展简史Vue.js：轻量级的崛起React.js：Facebook的重量级入场Angular：Google的全栈框架尝试三大框架的异同比较数据绑定机制对比：性能与优化策略：学习曲线与开发效率：社区支持与资源丰富度： 形成“三分天下”格局的关键因素结论附录 引言 前端技术的快速发展与演变始于 1990 年代，随着 Web 的诞生和浏览器的出现，经历了从静态网页到动态交互，再到如今高度复杂和丰富的用户体验的转变。
以下为前端简要发展历程：
前端技术的发展是一个不断进化的过程，从简单的网页展示到复杂的单页应用，再到今天的全栈式开发，技术的每一次进步都伴随着用户体验的显著提升和开发效率的飞跃。
在当前阶段，为何 Vue、React、Angular 能在众多前端框架中脱颖而出，形成三足鼎立之势？
接下来我们来讨论一下标题的问题：是什么奠定了前端框架三分天下的局面？
前端技术发展简史 早期 Web 开发面临了诸多挑战与限制，这些难题在很大程度上塑造了 Web 技术后续的发展路径。以下是一些关键点：
早期 Web 主要由静态 HTML 页面组成，缺乏动态交互能力，导致用户体验单一且有限。而且 HTML 的早期版本功能较为基础，对复杂布局和样式的支持不足。JavaScript 作为客户端脚本语言在 1995 年引入，但其功能较弱，且浏览器支持不一致，限制了其在增强交互性上的应用。不同浏览器对 HTML 、CSS 、JavaScript 的支持差异巨大，开发者不得不编写大量代码来确保跨浏览器兼容性，增加了开发成本和复杂度。Internet Explorer 的多个版本尤为著名，它们对 Web 标准的支持不一，给开发者带来了额外的头痛问题。当时的网络基础设施远不如今天发达，慢速的连接意味着开发者必须严格控制网页的大小和复杂度，以减少加载时间。缺乏现代化的 IDE 、调试工具和自动化构建工具，开发者多依赖于文本编辑器和手动测试，效率低下。动态内容生成主要依赖于服务器端技术，前端与后端的界限模糊，前端开发往往需要涉及后端逻辑，增加了开发复杂度。客户端验证薄弱，安全措施不健全，容易遭受 XSS 、CSRF 等攻击。网站的稳定性和性能优化也因技术限制而成为挑战。设计受限于技术，难以实现复杂的视觉效果和交互模式，网页通常显得单调且不够吸引人。 为了解决早期 Web 开发面临的问题，jQuery 应运而生。
jQuery 时代大致可以从 2006 年左右开始算起，直至 2010 年代中期，这段时间 jQuery 成为了 Web 开发中极为流行的一个 JavaScript 库。它的出现极大地简化了前端开发工作，特别是在处理 DOM 操作、事件处理、动画效果以及 AJAX 请求等方面，为开发者提供了一套统一且易于使用的 API 。以下是 jQuery 时代的几个关键特点：
普及与易用性：jQuery 以其简洁的语法和强大的功能迅速被广泛采用，几乎成为 Web 开发的标准库，显著降低了 JavaScript 编程的入门门槛。跨浏览器兼容性：在浏览器差异显著的时期，jQuery 出色地解决了不同浏览器之间的兼容性问题，让开发者可以编写一次代码，运行在多种浏览器上。DOM操作简化：通过 CSS 选择器快速选取元素，简化了 DOM 操作，提高了开发效率。动画与效果：内置丰富的动画接口，使得实现页面动态效果变得简单快捷。AJAX支持：简化了异步请求的编写，促进了无刷新网页的普及。 当然，jQuery 虽然确实是解决了一些问题，让 Web 开发技术更上一层楼，但它也不是万能的。他也会有一些局限性，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5107d32884fa87f6f2a3d94eb00afd74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f52602e84a5fcbd643494a66d9122c/" rel="bookmark">
			vscode编译和调试wsl环境的c语言程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接f5会报错，提示你改一下json文件
launch.json
{
“version”: “0.2.0”,
“configurations”: [
{
“name”: “(gdb) Launch”,
“type”: “cppdbg”,
“request”: “launch”,
“program”: “ w o r k s p a c e F o l d e r / a . o u t " , " a r g s " : [ ] , " s t o p A t E n t r y " : f a l s e , "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f52602e84a5fcbd643494a66d9122c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b60024c2454e07d0647765d89fcac5/" rel="bookmark">
			【数据结构】二叉树的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如有不懂的地方，可翻阅我之前文章哦！
个人主页：小八哥向前冲~
所属专栏：数据结构【c语言】
目录
前言
二叉树的遍历
前序遍历
中序遍历
后序遍历
总结点数
二叉树的高度
第k层叶子数
查找x值
叶子总数
左（右）孩子数
树的销毁
总代码
前言 前一章我们学习了堆，并且了解了什么是树。简单来说，堆就是一个二叉树，现在我们来真正了解一下二叉树！
以这棵树为例：
我们如何用链式结构来表示一颗二叉树呢？不错，结构体！
根据二叉树的节点特点，可以将每个部分分为左孩子节点，右孩子节点和根节点，于是我们可以这样来描述它：
typedef struct TreeNode { struct TreeNode* left;//左孩子节点 struct TreeNode* right;//右孩子节点 TDatatype val;//节点数值 }TNode; 现在我们手搓一个二叉树（上图为例），来进行深入研究！
//创建节点 TNode* BuyNode(TDatatype x) { TNode* node = (TNode*)malloc(sizeof(TNode)); if (node == NULL) { perror("malloc failed!"); return NULL; } node-&gt;left = node-&gt;right = NULL; node-&gt;val = x; return node; } //手动创建一个二叉树 TNode* CreateTree() { TNode* node1 = BuyNode(1); TNode* node2 = BuyNode(2); TNode* node3 = BuyNode(3); TNode* node4 = BuyNode(4); TNode* node5 = BuyNode(5); TNode* node6 = BuyNode(6); node1-&gt;left = node2; node2-&gt;left = node3; node1-&gt;right = node4; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } 二叉树的遍历 我们知道链表如何遍历，那么一颗链式树是怎么遍历的呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41b60024c2454e07d0647765d89fcac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66e119ebac131f08269822b02c4afa3/" rel="bookmark">
			SpringBoot Configuration Annotation Processor not configured 解决方案和详细问题分析以及作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、问题出现：
2、解决方案： 2.1方式一 简单粗暴的禁止提示
2.2 方式二 引入jar包
3、问题深入探究
写在前：笔者出现这个问题的时候，大概猜到是什么问题，在网上也是很快找到了解决方案，但是很多帖子，并没有深究，只是单纯的解决了问题。 1、问题出现： 当我们写配置类时就会出现如下的提示，虽然不影响运行，但看着实在碍眼，笔者这个是刚解决了的，为了记录，所以后面才截图，如果是一开始即对应的是后面截图的图片
2、解决方案： 2.1方式一 简单粗暴的禁止提示 在idea打开面板，取消勾选下面的选项即可。
2.2 方式二 引入jar包 刷新依赖即可
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 3、问题深入探究 为什么这个问题idea只是提示，而不是错误呢？那就让我们了解下这个jar包的作用吧。
贴个官网的对于这个jar的解释：https://docs.spring.io/spring-boot/specification/configuration-metadata/annotation-processor.html
这个jar主要是在程序编译后会生成 元数据json文件，这个文件的作用是为了方便我们写properties或者yaml文件配置我们自定义的Configuration properties的键时，能显示提示，因此，这也是为什么这个没有也不会报的原因。
spring-boot-configuration-processor 是 Spring Boot 提供的一个注解处理器，它用于处理配置类（Configuration Classes）中的注解。在 Spring Boot 中，我们通常使用注解来标记配置类，例如 @Configuration、@Bean、@PropertySource 等。
这个注解处理器的主要作用是帮助 Spring Boot 框架在编译时处理配置类中的注解，生成相关的元数据，以便在运行时进行配置类的加载和相关操作。它会分析配置类中的注解，并生成必要的代码或配置信息，从而实现 Spring Boot 的自动配置和相关功能。
使用这个注解处理器有几个好处：
提高性能: 在编译时生成元数据，减少了在运行时进行反射扫描的开销，从而提高了应用程序的性能。
更好的 IDE 支持: 注解处理器会生成额外的元数据，使得 IDE 能够更好地理解和支持配置类，提供更好的代码补全、导航和验证等功能。
更严格的编译时检查: 注解处理器可以在编译时检查配置类的合法性，捕获一些错误，例如缺少必需的注解或不合法的配置，从而提高了代码的质量和稳定性。
在 Spring Boot 项目中添加 spring-boot-configuration-processor 依赖后，它会自动与 Maven 或 Gradle 集成，通过注解处理器的方式来处理配置类，提高应用程序的性能和开发效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66e119ebac131f08269822b02c4afa3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/326/">«</a>
	<span class="pagination__item pagination__item--current">327/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/328/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>