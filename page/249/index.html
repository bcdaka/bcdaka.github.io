<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203be39022775ea9d13baba1d6a307cb/" rel="bookmark">
			【Stable Diffusion 3】本地部署SD3详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👋 Hi, I’m @Beast Cheng
👀 I’m interested in photography, hiking, landscape…
🌱 I’m currently learning python, javascript, kotlin…
📫 How to reach me --&gt; 458290771@qq.com
1. Stable Diffusion 3 模型下载 「点击前往」
进入之后是这样的页面，如果你没有登录，可以点击右上角进行登录（登录之后才能下载SD3的模型！！！）
点击这个：
找到适合你电脑配置的模型：
有独立显卡 独立显卡配置高（8G以上）：fp16独立显卡配置较低（大于4G、小于8G）：fp8 没有独立显卡：下载CPU版本
2.下载 ComfyUI 控制面板 「点击前往」
进入之后往下拉，找到 Installing ComfyUI
找到 Windows ，点击 Direct link to download
3.ComfyUI 语言包汉化 先下载中文语言包「点击前往」
进入页面后找到 Code ，点击右边的小三角
点击 Download ZIP
下载后解压
进入 ComfyUI 的 custon_nodes 文件夹中
文件夹路径为 ComfyUI\custom_nodes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203be39022775ea9d13baba1d6a307cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741142cdc0b641c7823385e08f6149c4/" rel="bookmark">
			文心一言、智谱清言、kimi，AI批量文章工具2.1版更新说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI批量生成文章2.1版更新优化了一下，然后已经打包上传了，已经使用的用户可下载更新。AI批量软件工具集成了文心一言、通义千问、智谱清言、kimi一共18个接口。
可同时选择5个不同接口，读取excel第1列和第2列内容批量生成文章，并保存word或txt。每次最多5个不同接口多线程同时处理3行excel，直到excel所有行列内容处理完毕。
ai批量生成文章
AI批量生成文章2.1功能更新说明： 1.新增保存文件格式选择，可选择生成结果保存为word或者txt。
2.修改excel模板，第一列为标题列，如果该列有内容，则生成内容按照第一列内容保存为文件名。若为空则截取生成内容第一段前50个字符作为保存文件名。
3.有很多人不会写指令，我就新增了几个简单的指令，大家可以尝试使用，可以自行修改和自定义指令提示词，注意自定义的时候，要注意模板prompt的参数规范。
没有使用过的用户，直接下载整个软件包。已经使用的用户，可把压缩包里的主程序2.1程序复制到原工具目录下，删除原2.01程序。
instruct和zhuti文件夹下分别对应的是指令文件和excel批量文件，若是有需要可自行选择复制粘贴过去使用。
劝退篇： 对了，在这里也在讲一下，我也是怕麻烦的，符合以下情况的不要继续下载了，做自媒体最重要的是时间，浪费你的时间去研究一款对你无用的软件不可取。
1、没有执行力，不爱钻研，比我还怕麻烦的，请绕道！
2、完完全全是小白的，不懂也不去钻研怎么申请key嫌麻烦的也请绕道！
3、认为软件是万能的、软件拿过来直接可以生成文章的也请绕道！
4、对指令、提示词不懂的请绕道！
5、期望批量产出结果个个是精品文章的请绕道！
不过，还是要感谢已经使用的用户给我提出的建议，我也会抽空慢慢优化软件，增加更多的指令和功能。
Ai扫盲篇 1、我们说的接口是指各个ai的开放平台地址，api接口调用，一般不是免费的。
2、指令、提示词是指你发送给ai的内容，包含你想让ai按照什么要求生成什么样的结果。
3、excel模板：主题关键词，可以是一句话，可以是一篇文章，注意很多接口发送的token要求不超过2000，也就差不多不要超过1800字。有的不超过4098字，注意取官方平台查看接口限制。
4、免费网页版，这里的意思是各个平台对外开发的官网使用平台。
5、token你就理解成1000token是800汉字吧，不要想太多。做大概换算就行了。
6、key不要外传，自己用自己的，避免损失。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a089adb465f12723e67231c74050847/" rel="bookmark">
			信息打点web篇----企业宏观资产打点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 欢迎来到我的博客
个人主页:北岭敲键盘的荒漠猫-CSDN博客
专栏描述：因为第一遍过信息收集的时候，没怎么把收集做回事
导致后来在实战中，遭遇资产获取少，可渗透点少的痛苦，如今决定
从头来过，全面全方位的对信息收集进行一次完整的整理。
本篇描述:
本篇为整理打点宏观web资产的方法
就是理解为尽可能多的找到这个企业的web网站
适合人群:
有一定基础的人(但大佬别看，我怕被笑话。。。。)
因为我这样整理就不会单个解释这些dns，域名啥的这些概念了。
注意!本篇内容全为学习使用案例均已打码处理。
企业资产分类 web资产
App资产
桌面应用资产
微信小程序
微信公众号
其他资产
企业资产查询 背景:
src平台我们挖的都是某个企业的洞，那么肯定是要对这个企业进行一番打点的。
目标信息:
1.获取目标的资产总数，web，app，公众号，微博等。因为有的企业可能都有，但是主体功能在某一个资产中。微信公众号和微博等里面可能有正常搜不到的接口。
2.集团的联盟企业。
查询平台查询:
免费查询平台:小蓝本-商业信息搜索
付费查询平台:爱企查
爱企查信息打点演示:
1.集团内部公司集合
抓取集团内部各个企业，扩大渗透范围。
2. 确定公司具体资产信息
从企业查询中，获取企业旗下的域名网站和App以及微信公众号等信息。
3.查看域名，公众号等
这个企业没有微信公众号微博等，所以止步于此。
小蓝本也是一样，自己用用摸索一下吧。
web域名打点 目的:获取本公司中更多的网站。
web备案查询 打点思路:本公司备案号相同，也就是说搜索备案有些时候可以搜索备案号反查域名。
平台:
https://beian.miit.gov.cn/#/Integrated/index
ICP备案查询网 - 网站备案查询 - 工信部域名备案查询实时数据
知识产权查询 就是用上面的企业查询的方法，查找他们知识产权。
注册域名查询 方法：购买域名是会帮我们查重的，利用这一点。
但是也会出现很多打不开的情况，需要自己分析。
IP反查 方法:获得一个莫名ip的情况下使用。
原因:一台服务器上可以通过 不同端口搭建多个网站，所以反查有概率找到更多的网站。
平台:
微步在线X情报社区-威胁情报查询_威胁分析平台_开放社区
web子域名打点 dns解析查询 dns在部署的时候会产生一个历史记录，利用这个特性可以找到一些网站。
其中包括以前的网站，但是没有删除，也会被我们找出来。
平台:
DNSDumpster.com - dns recon and research, find and lookup dns records
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a089adb465f12723e67231c74050847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53397ccc23acfd8dbc87393535d515e8/" rel="bookmark">
			【链表专题】深入探索链表：文章索引与知识架构（链表的概念、实现、应用、经典例题大合集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓 博客主页：倔强的石头的CSDN主页 📝Gitee主页：倔强的石头的gitee主页
⏩ 文章专栏：《数据结构与算法》
期待您的关注
目录
一、引言
二、链表的基础概念
🍃链表的概念
🍃顺序表和链表的对比
🍃 链表的分类
三、链表的实现
🍃无头单向非循环链表的实现
🍃带头双向循环链表的实现
四、链表的应用
🍃基于单链表实现通讯录
五、链表相关习题解析
初阶：
🍃求链表的中间节点
🍃合并两个有序链表
🍃环形链表的约瑟夫问题
🍃移除链表元素
🍃反转链表
🍃相交链表求交点
🍃返回单链表的倒数第k个节点
进阶：
🍃链表的回文结构
🍃随机链表的复制
🍃判断链表是否带环
🍃求带环链表的入环节点
一、引言 链表，作为计算机科学中的基础数据结构，以其独特的非连续存储方式和高效的插入、删除操作而备受青睐。无论是数据结构、算法还是实际系统开发中，链表都扮演着不可或缺的角色。
为了深入理解和掌握链表，我们需要从基本概念出发，通过实践来加深理解。
本文旨在为读者提供一个理论与实践相结合的链表学习指南，帮助大家系统地掌握链表的核心知识，并在实际编程中灵活运用。让我们一起踏上这场链表探索之旅吧！
二、链表的基础概念 🍃链表的概念 链表（Linked List）是一种常见的数据结构，用于存储一系列有序的元素。与数组不同，链表中的元素在内存中并不是连续存储的，而是通过指针或引用链接在一起。以下是链表的一些基础概念：
节点（Node）： 链表中的每一个元素都称为一个节点。一个节点通常包含两部分：数据部分和指针部分（或称为链接部分）。 数据部分用于存储实际的数据。指针部分（或链接部分）用于指向链表中的下一个节点。头节点（Head Node）： 链表的第一个节点通常被称为头节点。在某些实现中，链表可能包含一个哑节点（dummy node）或哨兵节点（sentinel node）作为头节点，其数据部分不存储实际的值，仅用于简化边界条件的处理。尾节点（Tail Node）： 链表的最后一个节点被称为尾节点。尾节点的指针部分通常设置为 null 或 None（取决于编程语言），表示链表的结束。 🍃顺序表和链表的对比 顺序表与链表是两种常见的线性数据结构，它们在存储方式、操作性能等方面存在显著的差异。以下是它们之间的详细对比：
1. 存储方式
顺序表： 将元素一个接一个地存入一组连续的存储单元中，存储空间连续。存储密度高，因为每个数据元素只占用一个空间。长度固定，必须在分配内存之前确定数组的长度。链表： 节点在物理存储单元上非连续、非顺序的存储，通过指针或引用链接在一起。存储空间不连续，每个节点除了存储数据元素外，还需要存储指向下一个节点的指针。长度不固定，可以动态地添加或删除节点。 2. 操作性能
插入和删除： 顺序表：在顺序表中插入或删除元素时，需要移动大量元素以保持连续性，因此效率较低，时间复杂度为O(N)。但在末尾插入或删除数据比较方便，时间复杂度为O(1)。链表：在链表中插入或删除元素时，只需修改相关节点的指针，时间复杂度为O(1)（如果知道要处理节点的前一个位置）或O(N)（如果不知道要处理节点的前一个位置）。头插、头删的效率高，时间复杂度是O(1)。查找： 顺序表：支持随机访问，查找效率高，时间复杂度为O(1)（按索引查找）。如果顺序表的数据按序排列，还可以使用二分查找法进一步提高效率。链表：不支持随机访问，查找效率低，需要遍历节点，时间复杂度为O(N)。空间性能： 顺序表：需要预先分配足够大的存储空间，如果估计过大，可能会导致空间浪费；如果估计过小，又会造成溢出。链表：动态分配存储空间，无需预先估计存储规模，可以根据需要动态地添加或删除节点。 3. 适用场景
顺序表：适用于需要频繁访问元素、且元素数量基本不变的场景，如大量访问元素的而少量增添/删除元素的程序。链表：适用于需要频繁插入、删除元素，且对访问元素无严格要求的场景，如管理动态数据、实现文件系统、排序等。 4. 总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53397ccc23acfd8dbc87393535d515e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092c052b258ca8f85fe967f59a041685/" rel="bookmark">
			CleanMyMac X for Mac v4.15.4 最新破解激活版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CleanMyMac X4.15.4中文直装板是一款颇受欢迎的专业mac清理软件，拥有十多项强大的功能，可以进行系统清理、清空废纸篓、清除大旧型文件、程序卸载、除恶意软件、系统维护等等，并且这款清理软件操作简易，非常好上手，特别适用于那些刚入手苹果系统的宝宝们。
CleanMyMac X for Mac（好用的优化清理工具） v4.15.4
CleanMyMac X for Mac v4.15.4 最新破解激活版。
CleanMyMac X 2024下载地址：https://souurl.cn/IXHiLp
cleanMyMacx 许可证激活码: ak3984150564huackr
[软件名称]：CleanMyMac X
[软件大小]：123.3M
[操作系统]：最低 ≥ macOS BigSur 11 以上版本
[兼容架构]：Intel、Apple Silicon（M1/M2）、
[最近更新]：2024.6.11
[特别说明]：已完美适配最新 macOS Sonoma 14系统
一键智能清理
一键智能化清理是对您的Mac进行一站式清理，自动扫描Mac上的所有文件， 包括：Mac系统清理、邮件应用程序清理、大&amp;旧型文件清理、 itunes文件清理、废纸篓清理等。
清洁您的系统垃圾
当大多数人清理iTunes垃圾都是通过应用程序和清理附件文件，但并不能真正清洁iTunes垃圾。iTunes不仅仅是音乐还有iso数据等很多，所以人们手动不能完全清理干净，那么cleanmymac4就能够帮助人们解决难题。
快速卸载无用软件
很多使用mac的人卸载应用程序的方法都是直接将图标拖至废纸篓，其实这个是没有任何作用的，卸载器可以帮助您扫描所有的应用程序信息，彻底卸载软件，无后顾之忧！
维护系统
Clean My Mac4中的系统优化，他不仅仅只是帮助您进行系统垃圾的清理，同时还能随时监测系统状态，提高检索效率，确保Mac性能最优化。运行脚本维护、修复磁盘权限、邮件加速、重启数据库服务、重建索引焦点、刷新DNS缓存等。
清理大型文件和旧文件
Mac使用时间长了，就会有大量不用的大型文件或是陈旧文件，Cleanmymac3可以帮助人们监测出这些文件，会显示出文件的日期、类型等信息，您可以随时选中彻底清除，释放空间
应用说明：
安装便捷，1秒即可完成。
CleanMyMac-购买：https://souurl.cn/F7woCQ
CleanMyMac-首页：https://souurl.cn/AifDic
CleanMyMac X 活动入口 ：https://souurl.cn/F7woCQ
优惠码：KWVA5830 （限时）
支持intel，M1/M2芯片（原生应用无需Rosetta转译）
永久激活使用（此链接免费提供后续版本更新）
已完美适配最新 macOS Sonoma 14系统
CleanMyMac x值得买吗 用户可以选择两种进行购买。如果不购买也是拥有30天的试用。用户也可以在30天体验之后决定是否需要购买。
1、购买178元的版本，如图片所示，购买之后是可以永久的使用。如果用户更换了新的电脑，也是支持在新的电脑上继续使用，不需要额外购买的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092c052b258ca8f85fe967f59a041685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02150e6ffa91be0196c0e1572c59326e/" rel="bookmark">
			数据库异常数据恢复（1）-快速恢复和镜像恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(一) 数据库服务器的崩溃和恢复 1. 服务器的修复机制 数据库因为某些原因导致数据库突然异常donw机，为了保证数据库的使用，提供了一些机制进行数据库的恢复
快速恢复：数据库异常down机后重启数据库自己的恢复方式，人工无法干预备份文件恢复：手动进行恢复的方式磁盘镜像和数据复制：都是一种灾备方式，从一定程度上可以机器自主反应保证应用的运行 镜像：两个chunk，一个为主chunk，一个为镜像chunk，主chunk出现问题，会启用镜像chunk，在一定程度上可保证应用的运行数据复制：集群灾备 2. 数据库服务武器崩溃的类型和修复方式 系统崩溃：因为电源或其他原因导致机器donw机，重启计算机后，数据库会通过快速恢复的机制，自动恢复磁盘崩溃：当包含数据库服务器的磁盘因为某些原因不能使用，针对这种，由于数据存放在磁盘中，只能通过备份文件恢复的方式进行恢复机器失败：如果是整个系统失败了，数据复制（HDR或RSS）提供的第二个数据库实例可以马上作为备份系统使用 (二) 数据库异常down机的表现方式和快速恢复 1. 数据库正常关闭和异常崩溃的差异 正常关闭 数据库正常关闭的情况下，最后一次操作是checkpointcheckpoint之后物理日志会被清空逻辑日志最后一条是checkpoint消息日志包含了关闭数据库的时间 异常崩溃 异常关闭的数据库没有执行checkpoint物理日志没有情况逻辑日志最后一条不是checkpoint消息日志没有关闭数据库时间且数据库异常崩溃，可能会有断裂块的情况产生 2. 快速恢复概述 快速恢复是数据库的一种特性，不能被认为干预，不能被关闭快速恢复只适合系统方面的异常崩溃，磁盘不可用的情况无法使用异常崩溃恢复快速恢复的目标有三个 物理日志恢复：恢复到最近的检查点时间，达到物理日志恢复逻辑日志恢复：通过逻辑日志恢复到最近的逻辑一致状态事务回滚：回滚崩溃时没有完成的事务 3. 快速恢复的步骤 物理日志恢复： 由于异常关闭没有清空物理日志，所以将物理日志的内容读取到缓冲池内，清页线索会将内容刷新到磁盘中，刷到磁盘是为了避免出现异常down机前数据更新后脏块刷入了磁盘，但是物理日志未刷新的情况。刷新磁盘可以将磁盘的数据恢复到最后一个检查点时的状态如果物理日志中没有数据，则表示第一步已经完成 逻辑日志前滚恢复到最近的逻辑性一致状态 找到逻辑日志的最后一个checkpoint前滚最后一个checkpoint之后的所有操作记录 回滚没有递交的事务或者系统失败时没有完成的事务 回滚在逻辑日志中没有commit和rollback work配对的事务这样保证数据库内不会留下那些失败没有完成的事务 4. 快速恢复对记录日志开启缓冲和不记录日志两种数据库的差异 数据库开启了日志缓冲：由于数据库开启了缓冲，可能出现日志没有刷新到逻辑日志文件中，但是还存在日志缓冲区的情况 这种情况下：还在逻辑日志缓冲区的事务将丢失针对开启了日志缓冲的数据库，快速恢复无法保证完全恢复 不记录日志的数据库：不会将数据库的操作记录保存记录到逻辑日志中 其最后一次检查点之后的所有事务和操作都丢失 5. 快速恢复后消息日志中的记录 第一步恢复之后记录Physical Recovery Complete的信息第二步恢复之后记录Logical Recovery Complete的信息还会记录提交了多少事务、回滚的事务、仍然打开的锁的当前数量onlog可以详细分析 (三) 镜像崩溃和恢复 1. 镜像情况下主primary chunk和镜像Mchunk的状态 [gbasedbt@iZ2ze2nmdlhki0ezcrioayZ node4_dbs]$ onstat -d Your evaluation license will expire on 2025-03-15 00:00:00 On-Line -- Up 00:02:01 -- 676080 Kbytes Dbspaces address number flags fchunk nchunks pgsize flags owner name 472a8028 1 0x70002 1 1 2048 M BA gbasedbt rootdbs 4a899888 2 0x60001 2 1 2048 N BA gbasedbt llogdbs 4a899ab8 3 0x70001 3 1 2048 N BA gbasedbt plogdbs 4a899ce8 4 0x68001 4 1 2048 N SBA gbasedbt sbspace1 4a9b7028 5 0x42001 5 1 16384 N TBA gbasedbt tmpdbs1 4a9b7258 6 0x60001 6 1 16384 N BA gbasedbt datadbs1 4add9028 7 0x60002 7 1 16384 M BA gbasedbt db1dbs 7 active, 2047 maximum Chunks address chunk/dbs offset size free bpages flags pathname 472a8258 1 1 0 102400 86165 PO-B-D /home/gbasedbt/gbase/node4_dbs/rootdbs 472a9028 1 1 0 102400 0 MD-B-- /home/gbasedbt/gbase/node4_dbs/rootdbs_mirror 4a9b7488 2 2 0 51200 1147 PO-B-D /home/gbasedbt/gbase/node4_dbs/llogdbs 4a9b9028 3 3 0 51200 1447 PO-B-D /home/gbasedbt/gbase/node4_dbs/plogdbs 4a9ba028 4 4 0 51200 47678 47678 POSB-D /home/gbasedbt/gbase/node4_dbs/sbspace1 Metadata 3469 2581 3469 4a9bb028 5 5 0 6400 6347 PO-B-- /home/gbasedbt/gbase/node4_dbs/tmpdbs1 4a9bc028 6 6 0 64000 63413 PO-BED /home/gbasedbt/gbase/node4_dbs/datadbs1_1 4add9258 7 7 0 6250 6197 PO-B-D /home/gbasedbt/gbase/node4_dbs/db1 4ab5c028 7 7 75000 6250 0 MO-B-D /home/gbasedbt/gbase/node4_dbs/db1_mirror 7 active, 32766 maximum NOTE: The values in the "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02150e6ffa91be0196c0e1572c59326e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb2acd42fdfa8ae4ac5f52f8c1d3de8/" rel="bookmark">
			xcode和iPhone真机或者watch真机连接问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如果真机是第一次连接xocde，就需要开启真机上的开发者模式，开启开发者模式的方式：
iphone/ipad开启方式:
设置 &gt; 隐私与安全 &gt; 开发者模式 &gt; 开启，然后重启就可以了
watch设置：很麻烦，看文章apple watch真机开发第一步连接xcode详细教程，开启watch开发者模式真的很坑啊啊啊啊啊-CSDN博客
2.如果真机和xcode处于同一个局域网的话，之前已经连接过的话，默认在xcode中会显示这个真机设备的，直接选中这个设备就可以在设备上运行了：不用连接数据线就可以
watch如果之前连过的话，也会显示，哪怕watch匹配的手机关机了，只要watch和xcode在同一个局域网，就可以识别到这个watch：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0285fdb9539de6ed8f1079e08ade44a/" rel="bookmark">
			力扣每日一题 6/19 排序&#43;动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 2713.矩阵中严格递增的单元格数【困难】 题目： 给你一个下标从 1 开始、大小为 m x n 的整数矩阵 mat，你可以选择任一单元格作为 起始单元格 。
从起始单元格出发，你可以移动到 同一行或同一列 中的任何其他单元格，但前提是目标单元格的值 严格大于 当前单元格的值。
你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。
请你找出从某个单元开始访问矩阵所能访问的 单元格的最大数量 。
返回一个表示可访问单元格最大数量的整数。
示例 1：
输入：mat = [[3,1],[3,4]] 输出：2 解释：上图展示了从第 1 行、第 2 列的单元格开始，可以访问 2 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 2 个单元格，因此答案是 2 。 示例 2：
输入：mat = [[1,1],[1,1]] 输出：1 解释：由于目标单元格必须严格大于当前单元格，在本示例中只能访问 1 个单元格。 示例 3：
输入：mat = [[3,1,6],[-9,5,7]] 输出：4 解释：上图展示了从第 2 行、第 1 列的单元格开始，可以访问 4 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 4 个单元格，因此答案是 4 。 分析问题： 这道题旨在寻找一个最大解，可以用动态规划来解，而题意又是让我们顺序移动单元格，只能从小到大的顺序，因此我们可以用一个哈希表来记录每个值所对应的坐标，遍历每个可能的起点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0285fdb9539de6ed8f1079e08ade44a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3677a5924562dc1df6c4585e201b542a/" rel="bookmark">
			数据结构之探索“队列”的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
队列有关概念
队列的使用 队列模拟实现 循环队列的模拟实现
622. 设计循环队列 双端队列
栈与队列相互转换
232. 用栈实现队列
225. 用队列实现栈 队列有关概念 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 的特点。
入队列：进行插入操作的一端称为队尾（Tail/Rear） ；
出队列：进行删除操作的一端称为队头 （Head/Front）。
队列和我们在日常生活中买东西排队或者在食堂打饭的场景是一样的。如下图：
队列的使用 上面这张图中，Queue 便是队列，可以看到其底层是 LinkedList ，也就是双向链表实现的。
队列的常用方法 方法功能boolean offer(E e)往队尾添加元素E poll()获取并删除队头元素peek()获取队头元素int size()获取队列中有效元素个数boolean isEmpty()检测队列是否为空 public class Test { public static void main(String[] args) { Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 判断队列是否为空 System.out.println(queue.isEmpty()); // 往队尾插入元素 queue.offer(1); queue.offer(2); queue.offer(3); queue.offer(4); queue.offer(5); // 获得并删除对头元素 System.out.println(queue.poll()); // 获取对头元素 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3677a5924562dc1df6c4585e201b542a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954c14c4cb0e3f33754029d12d256134/" rel="bookmark">
			【golang学习之旅】使用VScode安装配置Go开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载并安装Go1.1 下载地址1.2 选择版本并下载1.3 安装目录1.4 验证是否安装成功 2. 配置环境变量2.1 配置步骤2.2 GO部分环境变量说明 3. 下载或更新 Vscode3.1 下载地址3.2 安装步骤 4. 为Go开发配置VScode 1. 下载并安装Go 1.1 下载地址 https://studygolang.com/dl
1.2 选择版本并下载 我选择了较新的稳定版本 go1.21.11。并且根据自己的系统选择安装包，我是Windows所以选择下面的安装包进行下载：
路径选择可以自定义：
1.3 安装目录 安装好之后安装目录中有如下文件：
目录介绍apigo1.1.txt,go.1.2.txt…go1.12.txt存放go的所有版本（go1.1到go.1.21）的api信息doc存放Go语言几乎全部的HTML格式的官方文档和说明，方便开发者在离线时查看bin存放go的可执行文件。包括gofmt.exe ，go官方的代码格式化工具，用来统一代码风格；godoc.exe 在不联网的情况下在本地访问go的api；go.exe 编译构建整个go项目，贯穿go项目的声明周期，go env; go build; go mod; go install;等等lib一些公共的库。存放各类编辑器或IDE（集成开发环境）软件的插件，辅助它们查看和编写Go代码pkg在go install 完成后，用于保存go语言标准库的所有归档文件（比如fmt包被构建安装后，将生成一个fmt.a归档文件），同时也包含了和平台（windows，linux，mac）项目的一些目录,不同的操作系统看到不一样src存放go所有标准库，go语言工具，以及涉及到的底层库（C语言）实现的代码test存放测试go语言的代码文件 1.4 验证是否安装成功 安装完成后，Win + R 打开输入 cmd 打开命令行窗口，然后输入 go version 可以查看 Go 的版本：
2. 配置环境变量 2.1 配置步骤 右键此电脑 → 属性 → 高级系统设置 → 环境变量
新建系统变量
新建GOROOT变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/954c14c4cb0e3f33754029d12d256134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf21db48444150c42c0475c114430a3/" rel="bookmark">
			基于单类支持向量机的滚动轴承异常检测方法（NASA-IMS轴承数据，Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from sklearn import svm from tqdm import tqdm df_stats_Ch1_test2 = pd.read_csv("estadisticos_test2_ch1.csv" , sep = ',') X_Ch1 = df_stats_Ch1_test2[['Min', 'Max', 'Kurt', 'ImpFactor', 'RMS', 'MargFactor', 'Skewness', 'ShapeFactor', 'PeakToPeak', 'CrestFactor']].values X_primerCuarto = X_Ch1[:int(len(X_Ch1)/4)] X_train = X_primerCuarto clf = svm.OneClassSVM(kernel="rbf", gamma = 0.01, tol=1e-15, nu=1e-15) clf.fit(X_train) OneClassSVM(gamma=0.01, nu=1e-15, tol=1e-15) clf.predict(X_train) array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int64) X_test = X_Ch1[int(len(X_Ch1)/4):] y_pred = clf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf21db48444150c42c0475c114430a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbb46edc18e404ed47bffac5c2956c7/" rel="bookmark">
			【C&#43;&#43;高阶】高效搜索的秘密：深入解析搜索二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C++ “ 登神长阶 ”
🤡往期回顾🤡：C++多态
🌹🌹期待您的关注 🌹🌹
❀二叉搜索树 📒1. 二叉搜索树🎩二叉搜索树概念🎈二叉搜索树操作 📕2. 二叉搜索树模拟实现🧩二叉搜索树结构🧩二叉搜索树操作🌈插入🌞遍历🌙查找⭐删除 🧩二叉搜索树默认成员函数 📜3. 二叉搜索树模拟实现(递归)🌞插入🌙查找⭐删除 📚4. 二叉搜索树的应用🍁KV模型🍂KV模型实现💧英汉词典🔥计数 🌄二叉树巩固知识 📖5. 总结 前言： 在数据结构和算法的广阔领域中，二叉搜索树（Binary Search Tree，简称BST）无疑是一颗璀璨的明星。它以其高效的数据检索能力和独特的树形结构，在计算机科学领域扮演着举足轻重的角色。对于任何对编程和数据结构感兴趣的人来说，掌握二叉搜索树都是至关重要的一步
二叉搜索树不仅仅是一个简单的数据结构，它更是一种解决问题的方式和思维的体现。通过维护二叉树中每个节点的左子树所有值均小于它的值，右子树所有值均大于它的值的特性，二叉搜索树在插入、查找和删除操作中展现出了卓越的性能。这种特性使得二叉搜索树在各种应用中成为了一种理想的数据结构选择，从基础的算法练习到复杂的系统优化，都能见到它的身影
学习二叉搜索树并非易事。它需要我们深入理解其性质、原理和算法实现。我们需要掌握如何构建一棵二叉搜索树，如何遍历它，以及如何在其中进行高效的查找、插入和删除操作。这些都需要我们付出大量的时间和精力去学习和实践。我们将从二叉搜索树的基本概念出发，逐步深入到其性质、构建、遍历以及操作的实现
让我们一起踏上学习二叉搜索树的旅程，探索它带来的无尽可能！
(本文重在二叉搜索树的模拟实现与理解)
📒1. 二叉搜索树 🎩二叉搜索树概念 二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树 🎈二叉搜索树操作 首先，在二叉搜索树的操作中只支持插入，查找，删除，遍历，并不支持修改操作，因为在修改后谁也不能保证它依然是一棵二叉搜索树，二叉搜索树的时间复杂度范围在(O(logN)~O(N))
在二叉搜索树的遍历中一般采用中序遍历： 先遍历左子树，然后访问根节点，最后遍历右子树。在BST中，中序遍历会按照升序访问所有节点
二叉搜索树示例
int a[] = {8, 3, 1, 10, 6, 4, 7, 14, 13}; 📕2. 二叉搜索树模拟实现 🧩二叉搜索树结构 二叉搜索树结构的和树形结构差不多，这意味着每个元素（通常称为节点）都有两个指针：一个指向前一个左子树，另一个指向右子树，因此我们需要单独再定义一个类来表示节点结构，每个节点再串联起来构成BST
（在模拟实现二叉搜索树时，不用定义命名空间，因为不会和库中发生冲突）
节点定义（示例）：
template&lt;class K&gt; struct BSTreeNode { BSTreeNode&lt;K&gt;* _left; BSTreeNode&lt;K&gt;* _right; K _key; BSTreeNode(const K&amp; key = K()) :_key(key) , _left(nullptr) , _right(nullptr) {} }; BST定义（示例）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dbb46edc18e404ed47bffac5c2956c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db77f4d55a2ed6aaa6e69439d5814840/" rel="bookmark">
			【C&#43;&#43;初阶路】--- 类和对象(中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、this指针1.1 this指针的引出1.2 this指针的特性1.3. C语言和C++实现Stack的对比 二、类的6个默认成员函数三、构造函数3.1 概念3.2 特性 一、this指针 1.1 this指针的引出 如下定义一个日期类Date
class Date { public: //void InitDate(Date* const this, int year = 2024, int month = 6, int day = 14) void InitDate(int year = 2024, int month = 6, int day = 14) { _year = year; _month = month; _day = day; } //void PrintDate(Date* const this); void PrintDate() { cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db77f4d55a2ed6aaa6e69439d5814840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bff9e9a5fae5b838338c2198472d10d/" rel="bookmark">
			课程设计---哈夫曼树的编码与解码（Java详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.设计任务&amp;&amp;要求：
二.方案设计报告：
2.1 哈夫曼树编码&amp;译码的设计原理：
2.3设计目的：
2.3设计的主要过程：
2.4程序方法清单：
三.整体实现源码：
四.运行结果展示：
五.总结与反思：
一.设计任务&amp;&amp;要求： 题目要求：测试数据是一段任意的英文，也可以是一段完整的中文，采用哈夫曼算法进行编码，可输出对应的字符编码的解码
哈夫曼编码是一种最优变长码，即带权路径最小。这种编码有很强的应用背景，是数据压缩中的一个重要理论依据。对输入的一串文字符号实现哈夫曼编码，再对哈夫曼编码生成的代码串进行译码，输出字符串。要求完成以下功能：
1.针对给定的字符串，建立哈夫曼树。
2.生成哈夫曼编码。
3.对编码字符串译码。
二.方案设计报告： 2.1 哈夫曼树编码&amp;译码的设计原理： 哈夫曼编译码器的主要功能是先建立哈夫曼树，然后利用建好的哈夫曼树生成哈夫曼编码后进行译码。在数据通信中，通常需要将传送文字转换成由二进制字符0，1组成的二进制串，称之为编码。构建一个哈夫曼树，设定哈夫曼树中的左分支为0，右分支代表1，则从根结点到每个叶子节点所经过的路径组成的0和1的序列便为该节点对应字符的编码，称之为哈夫曼编码。最简单的二进制编码方式是等长编码。若采用不等长编码，让出现频率高的字符具有较短的编码，让出现频率低的字符具有较长的编码，这样可以有效缩短传送文字的总长度。哈夫曼树则是用于构造使编码总长最短，最节省空间成本的编码方案。 2.3设计目的： (1) 巩固和加深对数据结构课程所学知识的理解，了解并掌握数据结构与算法的设计方法；
(2) 初步掌握软件开发过程的问题分析、系统设计、程序编码、测试等基本方法和技能；
(3) 提高综合运用所学的理论知识和方法，独立分析和解决问题的能力；
(4) 训练用系统的观点和软件开发一般规范进行软件开发，培养软件工作者所应具备的科学的工作方法和作风；
(5) 培养查阅资料，独立思考问题的能力。
2.3设计的主要过程： 1.哈夫曼树叶子节点的创建
叶子节点需要存储字符，及其出现的频率，指向左右子树的指针和将来字符所编码成的二进制数字。这里用一个静态内部来来初始化树的叶子节点：
//用一个静态内部类来初始化树的节点 static class Node{ char ch; //记录字符 int freq; //统计每个字符出现的频次 Node left; Node right; String code; //编码 public Node(char ch) { this.ch = ch; } public Node(int freq, Node left, Node right) { this.freq = freq; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bff9e9a5fae5b838338c2198472d10d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c53cd966850e6cbb26dae19fe7d06fa/" rel="bookmark">
			20240620 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤖一个人使用ChatGPT 取代了60名员工 ，最后自己也被解雇了
Miller领导着一个由 60 多名作家和编辑组成的团队，负责为技术公司撰写和编辑文章。
起初，这个工作让Miller感到非常有创造性和成就感。
后来他们的工作逐渐被 ChatGPT 所取代，而他们的职责则变成了专门修改AI生成的文章，使其不那么机械化和公式化
公司引入了一个自动化系统：经理将文章标题输入在线表单，AI生成大纲，Miller的团队根据大纲撰写文章，Miller进行最后的编辑。几个月后，公司决定让ChatGPT编写完整的文章，大部分团队成员被解雇，剩下的人负责编辑AI生成的文本，使其更像人类写的。
到2024年，公司解雇了Miller的整个团队，他变成了唯一的员工，每天都在编辑AI写的文章。
这种工作变得非常单调重复，让Miller感觉自己像机器人一样。Miller的经历反映了一个更广泛的趋势：许多行业开始使用AI来完成原本由人类进行的工作。
原文：https://bbc.com/future/article/20240612-the-people-making-ai-sound-more-human
🌐Meta AI 公布多项新的研究成果：4个可用的新的AI模型和2个额外的研究成果
- Meta Chameleon：能同时理解和生成文本与图像的混合模态模型
🔗论文：https://arxiv.org/pdf/2405.09818
- 多令牌预测模型：通过预测多个未来标记来提高模型的效率和性能。
🔗论文：https://arxiv.org/pdf/2404.19737
🔗模型下载: https://huggingface.co/facebook/multi-token-prediction
- JASCO： 一个可以将文本转换为音乐的生成模型
🔗项目地址: https://pages.cs.huji.ac.il/adiyoss-lab/JASCO/
- AudioSeal：音频水印模型 专门用于检测AI生成语音的音频水印技术
🔗项目地址: https://github.com/facebookresearch/audioseal
- PRISM数据集：包含来自75个国家的1500名参与者的社会人口统计数据和偏好反馈，旨在提高LLM的反馈多样性和包容性。
🔗论文: http://https:/l/arxiv.org/pdf/2404.16019
🔗数据集: https://huggingface.co/datasets/HannahRoseKirk/prism-alignment
- 衡量和改善文本到图像生成系统中的地理差异，确保AI生成的图像能真实反映不同地区的文化和地理特征。
🔗论文: https://arxiv.org/pdf/2405.04457
🔗GitHub: https://github.com/facebookresearch/DIG-In
🔗Meta官方介绍:https://ai.meta.com/blog/meta-fair-research-new-releases/
🖥️OpenAI、斯坦福等多所机构筛选出1565篇论文发布大模型《提示技术报告》！
- 研究团队从各种学术资源中筛选出超过1,500篇相关论文，整理出了一套标准术语和提示方法，并创建了一个易于理解和使用的目录。
- 使得不论是开发者还是普通用户，都能更清楚地知道如何给AI下达有效的指令。
- 研究团队系统性地审查了相关文献，采用了PRISMA方法，从三个主要学术数据库（arXiv、Semantic Scholar和ACL）中共处理了4797条记录，最终筛选出1565篇与提示技术相关的论文。
- 论文中详细介绍了58种基于文本的提示技术。
- 此外，还收集并整理了许多模态（如图像、音频）和多语言的提示技术。
- 除了基础的提示技术外，论文还审查了如何扩展这些技术来创建更复杂的系统，比如如何评估生成的内容，以及设计出更加安全和可靠的提示。
🔗报告简介：https://trigaten.github.io/Prompt_Survey_Site/
🔗报告全文：https://arxiv.org/pdf/2406.06608
🖼️Hedra：上传人物照片+任意语音 可实现人物唱歌、说话
- 支持根据任意人物照片和语音内容生成个人会说话和唱歌的动态视频，同时保持唇形和表情、姿态和语音内容相匹配。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c53cd966850e6cbb26dae19fe7d06fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e0ca7132057222c8a32ce574c8fe4c/" rel="bookmark">
			【Linux】环境基础开发工具使用（yum、vim、gcc/g&#43;&#43;、gdb、make/Makefile）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux 软件包管理器 yumLinux开发工具Linux编辑器-vim使用vim的基本概念vim下各模式的切换vim命令模式各命令汇总vim底行模式各命令汇总批量化注释和批量化去注释vim简单的配置解决一个小问题 Linux编译器-gcc/g++作用gcc/g++ 语法预处理编译汇编链接什么是函数库 Linux调试器-gdb使用Linux项目自动化构建工具-make/Makefile Linux第一个小程序－进度条 Linux 软件包管理器 yum Linux下安装软件的方式
在Linux下安装软件的方法大概有以下三种：
（1）下载到程序的源代码，自行进行编译，得到可执行程序。
（2）获取rpm安装包，通过rpm命令进行安装。（无法处理软件之间的依赖关系）
（3）通过yum进行安装软件。（常用）
yum全称为 Yellow dog Updater Modified，它是一个在线的软件安装命令。YUM是C/S架构，是RPM1的前端工具，依赖于RPM存在的。能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。
依赖关系：假如我要安装一个软件A而软件A又要依赖于软件B才能跑起来，万一软件B又要依赖其他软件，就很麻烦处理了。而我们用yum不用去处理这种复杂的关系。一步到位。
那么YUM是如何下载安装RMP包的呢？
但是上述这种机制，也存在着一些问题，万一服务器上的程序包或者依赖关系发生了变化，就会导致服务器和客户端本地的元数据不一致。想解决这个问题，可以在每次使用YUM的时候，都向服务器请求元数据。但是这种方式浪费带宽和时间，有的时候明明没有变化，但还是需要下载。
如何解决这种问题呢？
YUM服务器上有一个特殊文件，文件中记录了每一个元数据文件的校验码，实际上每次运行YUM的时候，都会向服务器请求这个文件(刚刚配置好YUM源的时候，本地没有这个文件，这时候肯定是要下载元数据的)，并和本地元数据中的校验码文件进行对比，如果一致则代表元数据没有变化，本地元数据有效，否则就重新请求元数据。
查找软件包 yum list是罗列可下载的全部软件，这个时候可以配合那个管道和grep进行查询要下载的软件
比如要查询tree，可用以下指令
base，基本软件原，很稳定
epel，扩展软件源
可以理解成epel包含base，开发了更多的型新功能
安装软件和卸载软件前面指令那块说过了。这里再提醒一下
安装：yum -y install 软件名
卸载：yum -y remove 软件名
Linux开发工具 我们在 windows 中编写 C/C++ 程序时，常用的 VS2022，是一个集成开发环境，包含了很多工具包。而 Linux 下开发，大部分情况下都是使用的一个一个独立的工具。比如编写代码用 vim，编译代码用 gcc，调试代码用 gdb。
Linux编辑器-vim使用 vim的基本概念 我们讲解vim的三种模式(其实有好多模式，目前掌握这3种即可),
分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：
正常/普通/命令模式(Normal mode)：控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode
插入/编辑模式(Insert mode)：只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9e0ca7132057222c8a32ce574c8fe4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb168d4b97fbd681d26d91521197b97d/" rel="bookmark">
			【AI 大模型】提示工程 ① ( 通用人工智能 和 专用人工智能 | 掌握 提示工程 的优势 | 提示工程目的 | 提示词组成、迭代、调优及示例 | 思维链 | 启用思维链的指令 | 思维链原理 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、提示工程 Prompt Engineering 简介1、通用人工智能 和 专用人工智能2、Prompt 提示词3、提示工程4、掌握 提示工程 的优势5、提示工程目的 二、提示词组成、迭代、调优及示例1、提示词的组成2、提示词的迭代、调优3、提示词基础示例4、提示词 " 指定输出格式 " 示例5、提示词 " 上下文语境 " 示例 - 多轮对话解决问题6、提示词 " 增加约束 " 示例 三、思维链 Chain of Thought1、思维链简介2、思维链推理过程3、启用思维链的提示词指令4、思维链原理5、思维链示例 一、提示工程 Prompt Engineering 简介 1、通用人工智能 和 专用人工智能 通用人工智能 和 专用人工智能 :
AGI , Artificial General Intelligence , 通用人工智能 , 是一种具备学习、推理、感知、理解等人类智能的 全面智能系统 , 不局限于某一领域或任务 , 可以在多个领域表现出类似于人类的智能水平 ;ANI , Artificial Narrow Intelligence , 专用人工智能 , 只能执行特定任务 , 如 : 语音识别、图像识别、自然语言处理 ; 提示工程 Prompt Engineering 主要作用于 AGI , Artificial General Intelligence , 通用人工智能 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb168d4b97fbd681d26d91521197b97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc98a8fbc472ebade966b0d9983fc0f0/" rel="bookmark">
			Stable Diffusion文生图模型训练入门实战（完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion 1.5（SD1.5）是由Stability AI在2022年8月22日开源的文生图模型，是SD最经典也是社区最活跃的模型之一。
以SD1.5作为预训练模型，在火影忍者数据集上微调一个火影风格的文生图模型（非Lora方式），是学习SD训练的入门任务。
显存要求 22GB左右
在本文中，我们会使用SD-1.5模型在火影忍者数据集上做训练，同时使用SwanLab监控训练过程、评估模型效果。
代码：Github实验日志过程：SD-naruto - SwanLab模型：runwayml/stable-diffusion-v1-5数据集：lambdalabs/naruto-blip-captionsSwanLab：https://swanlab.cn 1.环境安装 本案例基于Python&gt;=3.8，请在您的计算机上安装好Python；
另外，您的计算机上至少要有一张英伟达显卡（显存大约要求22GB左右）。
我们需要安装以下这几个Python库，在这之前，请确保你的环境内已安装了pytorch以及CUDA：
swanlab diffusers datasets accelerate torchvision transformers 一键安装命令：
pip install swanlab diffusers datasets accelerate torchvision transformers 本文的代码测试于diffusers0.29.0、accelerate0.30.1、datasets2.18.0、transformers4.41.2、swanlab==0.3.11，更多库版本可查看SwanLab记录的Python环境。
2.准备数据集 本案例是用的是火影忍者数据集，该数据集主要被用于训练文生图模型。
该数据集由1200条（图像、描述）对组成，左边是火影人物的图像，右边是对它的描述：
我们的训练任务，便是希望训练后的SD模型能够输入提示词，生成火影风格的图像：
数据集的大小大约700MB左右；数据集的下载方式有两种：
如果你的网络与HuggingFace连接是通畅的，那么直接运行我下面提供的代码即可，它会直接通过HF的datasets库进行下载。如果网络存在问题，我也把它放到百度网盘（提取码: gtk8），下载naruto-blip-captions.zip到本地解压后，运行到与训练脚本同一目录下。 3.准备模型 这里我们使用HuggingFace上Runway发布的stable-diffusion-v1-5模型。
模型的下载方式同样有两种：
如果你的网络与HuggingFace连接是通畅的，那么直接运行我下面提供的代码即可，它会直接通过HF的transformers库进行下载。如果网络存在问题，我也把它放到百度网盘（提取码: gtk8），下载stable-diffusion-v1-5.zip到本地解压后，运行到与训练脚本同一目录下。 4. 配置训练可视化工具 我们使用SwanLab来监控整个训练过程，并评估最终的模型效果。
如果你是第一次使用SwanLab，那么还需要去https://swanlab.cn上注册一个账号，在用户设置页面复制你的API Key，然后在训练开始时粘贴进去即可：
5.开始训练 由于训练的代码比较长，所以我把它放到了Github里，请Clone里面的代码：
git clone https://github.com/Zeyi-Lin/Stable-Diffusion-Example.git 如果你与HuggingFace的网络连接通畅，那么直接运行训练：
python train_sd1-5_naruto.py \ --use_ema \ --resolution=512 --center_crop --random_flip \ --train_batch_size=1 \ --gradient_accumulation_steps=4 \ --gradient_checkpointing \ --max_train_steps=15000 \ --learning_rate=1e-05 \ --max_grad_norm=1 \ --seed=42 \ --lr_scheduler="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc98a8fbc472ebade966b0d9983fc0f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a1084b2594677cffa766c2c829c3e2/" rel="bookmark">
			Flink 反压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反压 Flink反压是一个在实时计算应用中常见的问题，特别是在流式计算场景中。以下是对Flink反压的详细解释：
一、反压释义 反压（backpressure）意味着数据管道中某个节点成为瓶颈，其处理速率跟不上上游发送数据的速率，从而需要对上游进行限速。在Flink等实时计算框架中，反压通常是从某个节点传导至数据源，并降低数据源（如Kafka consumer）的摄入速率。
二、反压原因 数据倾斜：数据分布不均，导致个别task处理数据过多。算子性能问题：可能某个节点逻辑很复杂，如sink节点很慢或lookup join热查询慢等。流量陡增：如大促时流量激增，或者使用了数据炸开的函数。 三、反压影响 任务处理性能出现瓶颈：例如，在消费Kafka时，可能会出现消费Kafka Lag。Checkpoint时间长或失败：因为某些反压会导致barrier需要花很长时间才能对齐，从而影响任务的稳定性。State状态变大：由于数据处理速度不匹配，可能导致系统内部状态堆积。Kafka数据积压：当Flink作业无法及时处理Kafka中的数据时，会导致数据在Kafka中积压。OOM（内存溢出）：严重的反压可能导致系统资源耗尽，进而引发内存溢出等问题。 四、反压机制实现方式 在Flink中，反压机制可以通过以下两种方式实现：
阻塞式反压：当下游任务无法及时处理上游任务生成的数据时，上游任务会被阻塞，直到下游任务处理完毕。这种方式可以保证数据不丢失，但会造成延迟增加。异步非阻塞式反压：此方式的具体实现和细节可能因Flink版本和配置而异，但通常旨在通过异步处理和非阻塞操作来减轻反压的影响。 五、解决思路 优化数据分布：通过调整数据分区策略或重新设计数据模型来减少数据倾斜。提升算子性能：针对性能瓶颈的算子进行优化，如简化逻辑、增加资源等。限流与缓冲：在数据源端或关键节点前设置限流策略和缓冲区，以平滑处理流量陡增的情况。监控与告警：建立完善的监控和告警机制，及时发现并处理反压问题。 综上所述，Flink反压是一个需要关注的问题，它可能影响到实时计算应用的性能和稳定性。通过理解反压的原理和影响，并采取相应的解决措施，可以有效地提升Flink作业的处理能力和稳定性。
监控 Flink Web Flink Web 界面提供了一个选项卡来监控正在运行 jobs 的反压行为。
Task 性能指标 task（SubTask）的每个并行实例都可以用三个一组的指标评价：
backPressuredTimeMsPerSecond，subtask 被反压的时间dleTimeMsPerSecond，subtask 等待某类处理的时间busyTimeMsPerSecond，subtask 实际工作时间 在任何时间点，这三个指标相加都约等于1000ms。 这些指标每两秒更新一次，上报的值表示 subtask 在最近两秒被反压（或闲或忙）的平均时长。 当工作负荷是变化的时需要尤其引起注意。如，一个以恒定50%负载工作的 subtask 和另一个每秒钟在满负载和闲置切换的 subtask 的busyTimeMsPerSecond值相同，都是500ms。
在内部，反压根据输出 buffers 的可用性来进行判断的。 如果一个 task 没有可用的输出 buffers，那么这个 task 就被认定是在被反压。 相反，如果有可用的输入，则可认定为闲置，
WebUI WebUI 集合了所有 subTasks 的反压和繁忙指标的最大值，并在 JobGraph 中将集合的值进行显示。除了显示原始的数值，tasks 也用颜色进行了标记，使检查更加容易。
闲置的 tasks 为蓝色，完全被反压的 tasks 为黑色，完全繁忙的 tasks 被标记为红色。 中间的所有值都表示为这三种颜色之间的过渡色。
反压状态 在 Job Overview 旁的 Back Pressure 选项卡中，可以找到更多细节指标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19a1084b2594677cffa766c2c829c3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530a6876a590c0d1a8bb4569436e6cfa/" rel="bookmark">
			搜索算法工程师如何搜索内容质量算法的研发，通过Query意图理解、多模态内容理解、用户文本和行为数据挖掘挖掘提升数据质量？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索内容质量算法的研发是一个复杂且多层次的过程。为了提升搜索结果的质量，需要综合利用Query意图理解、多模态内容理解以及用户文本和行为数据挖掘等技术。这些技术相辅相成，共同作用于提升搜索内容的相关性和用户体验。以下是详细的步骤和策略：
一、Query意图理解 Query意图理解是提升搜索质量的第一步。了解用户的搜索意图，可以更准确地匹配相关内容。
1. 自然语言处理（NLP） 分词与词性标注：将用户查询拆分为单词，并标注每个词的词性，有助于理解查询的基本结构。命名实体识别（NER）：识别查询中的实体，如人名、地名、品牌等，帮助更准确地理解用户意图。依存句法分析：分析词与词之间的依存关系，理解查询的语法结构和层次关系。 2. 语义分析 词向量与嵌入：使用Word2Vec、GloVe或BERT等模型，将查询词转换为向量，捕捉语义信息。意图分类：利用机器学习或深度学习模型将查询分类为不同的意图类型，如信息查询、导航查询、交易查询等。同义词扩展：通过同义词库或上下文分析扩展查询词，增加检索的全面性。 3. 历史数据分析 查询日志分析：通过分析用户的历史查询日志，发现常见查询模式和意图。点击率与停留时间：结合用户点击行为和页面停留时间，评估查询与结果的匹配度，优化意图理解模型。 二、多模态内容理解 多模态内容理解是指同时理解文本、图像、视频等多种形式的内容，以提升搜索结果的全面性和准确性。
1. 文本内容理解 文本分类与聚类：利用自然语言处理技术对文本内容进行分类和聚类，提取主题和关键字。情感分析：分析文本的情感倾向，有助于理解用户对内容的态度和情绪。 2. 图像内容理解 图像分类：使用卷积神经网络（CNN）对图像进行分类，识别图像中的对象和场景。图像标注：利用图像标签和描述生成技术，提取图像的语义信息。 3. 视频内容理解 视频分割与关键帧提取：将视频分割成多个片段，提取关键帧，进行内容分析。视频标签与描述生成：结合图像和音频分析技术，为视频生成标签和描述。 三、用户文本和行为数据挖掘 用户文本和行为数据挖掘是提升搜索内容质量的重要手段，通过分析用户的行为数据，可以更好地理解用户需求和偏好。
1. 用户行为分析 点击流分析：追踪用户在搜索引擎上的点击路径，分析用户的行为模式和兴趣点。停留时间与跳出率：评估用户在页面上的停留时间和跳出率，判断内容的吸引力和相关性。 2. 个性化推荐 协同过滤：基于用户行为数据（如点击、浏览、购买等），利用协同过滤算法推荐相关内容。内容推荐：结合用户的历史搜索和浏览记录，推荐相似或相关的内容。 3. 用户反馈分析 显性反馈：分析用户的评分、评论和反馈信息，调整搜索算法。隐性反馈：通过用户的点击率、停留时间等隐性反馈数据，优化搜索结果的排序和推荐。 四、综合策略与优化 1. 数据融合 多模态数据融合：将文本、图像、视频等多模态数据融合，形成统一的内容理解模型。跨平台数据整合：整合不同平台的用户行为数据，提升数据质量和全面性。 2. 模型训练与优化 深度学习模型：利用深度学习模型（如BERT、Transformer等）进行意图理解和内容分析，提升模型的准确性和鲁棒性。在线学习：通过在线学习机制，实时更新和优化模型，适应用户需求和行为变化。 3. 实验与评估 A/B测试：通过A/B测试评估不同算法和策略的效果，选择最优方案。用户反馈循环：建立用户反馈循环机制，持续收集用户反馈并调整算法，确保搜索结果的质量不断提升。 五、案例分析 为了更好地理解上述技术和策略，我们可以通过一些实际案例来分析如何应用这些方法提升搜索内容质量。
1. Google 搜索引擎的改进 Google 搜索引擎广泛应用了自然语言处理、深度学习和用户行为分析等技术，不断改进搜索结果质量。
BERT模型：Google引入BERT模型用于理解查询中的自然语言，提升对复杂查询的理解能力。RankBrain：利用机器学习算法RankBrain，分析查询与内容的相关性，提高搜索结果的精准度。多模态搜索：通过图像搜索和视频搜索，提供更全面的搜索结果。 2. Amazon 的个性化推荐系统 Amazon 的推荐系统通过分析用户的购买行为、浏览历史和商品评价，提供个性化的商品推荐。
协同过滤：基于用户行为数据（如购买记录），利用协同过滤算法推荐相关商品。内容推荐：结合商品的描述、用户评论和评分，推荐相似或相关的商品。多模态数据融合：整合商品图片、视频和文本描述，提供更丰富的商品信息。 3. Netflix 的内容推荐 Netflix 通过用户观看历史、评分和行为数据，提供个性化的内容推荐，提升用户体验。
深度学习模型：利用深度学习模型分析用户观看行为，实时推荐用户可能感兴趣的电影和电视剧。情感分析：分析用户评论和评分中的情感信息，了解用户对内容的态度和喜好。多模态内容理解：结合视频内容分析和文本描述，推荐更符合用户偏好的内容。 六、未来发展方向 随着技术的不断进步，搜索内容质量算法的研发将迎来更多的发展机遇和挑战。
1. 增强的语义理解 未来的搜索引擎将进一步提升对语义的理解能力，通过更先进的自然语言处理技术，准确理解用户的查询意图和内容语义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/530a6876a590c0d1a8bb4569436e6cfa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/248/">«</a>
	<span class="pagination__item pagination__item--current">249/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/250/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>