<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ed5fe3fda0f4dfd08265f8784266521/" rel="bookmark">
			【Python・统计学】Kruskal-Wallis检验/H检验（原理及代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自学笔记，分享给对统计学原理不太清楚但需要在论文中用到的小伙伴，欢迎大佬们补充或绕道。ps：本文不涉及公式讲解（文科生小白友好体质）～（部分定义等来源于知乎百度等）
本文重点：Kruskal-Wallis检验(Kruskal-Wallis test),也称H检验
【1.定义和简单原理】
【2.应用条件】
【3.数据实例以及Python代码】
【4.多重比较（例：Dunn检验）】
1.定义和简单原理 Kruskal-Wallis检验(Kruskal-Wallis test),也称为克鲁斯卡尔-沃利斯检验或H检验,是一种非参数检验方法,用于比较三个或更多独立样本的差异。它可以看作是Mann-Whitney U检验的扩展。
补充1:Mann-Whitney U检验适用于两组数据，Kruskal-Wallis检验适用于三组及以上数据 【Python・统计学】Mann-Whitney U检验/Wilcoxon秩和检验（原理及代码）https://mp.csdn.net/mp_blog/creation/editor/138028894
Kruskal-Wallis检验的基本思想是,如果各组样本来自同一总体,那么各组样本的秩和应该相近。具体步骤如下:
将所有样本的数据合并,并按照从小到大的顺序排列,记录每个数据点的秩(排名)。对每个组内的秩求和,计算每个组的平均秩。如果各组样本来自同一总体,那么各组的平均秩应该相近。如果某些组的平均秩明显偏高或偏低,则可能表明这些组与其他组存在显著差异。计算Kruskal-Wallis检验的统计量H,并根据H的值和自由度,查表或计算p值,以判断是否拒绝原假设。 2.应用条件 数据是独立的随机样本,各组之间相互独立。数据至少是顺序尺度的,即可以比较大小,但不要求数值之间的差异有意义。各组样本不必服从正态分布,也不要求方差齐性。各组样本的分布形状相似(如都是偏态分布或都是对称分布),但不要求完全一致。 3.数据实例以及Python代码 假设我们想比较三种不同教学方法(A、B、C)对学生数学成绩的影响。我们随机选择了一些学生,分别接受这三种教学方法,并记录他们的数学成绩(满分100分)。数据如下:
methodA = [85, 92, 78, 88, 90, 82, 84, 80] methodB = [75, 80, 82, 74, 79, 76, 81] methodC = [90, 87, 92, 93, 88, 91, 85, 89, 94] from scipy.stats import kruskal # 三组学生的数学成绩 methodA = [85, 92, 78, 88, 90, 82, 84, 80] methodB = [75, 80, 82, 74, 79, 76, 81] methodC = [90, 87, 92, 93, 88, 91, 85, 89, 94] # 进行Kruskal-Wallis检验 statistic, p_value = kruskal(methodA, methodB, methodC) print(f'检验统计量为: {statistic}') print(f'p值为: {p_value}') if p_value &lt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ed5fe3fda0f4dfd08265f8784266521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded623a1dfc7b99c75dc6ec19e825576/" rel="bookmark">
			湖南大学python头歌实训 实验14：递归与二分法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第4章算法思维4.3.1 二分搜索 第1关：不重复序列二分搜索 #Student start def findx(A,x): l,r = 0,len(A)-1 while l&lt;=r: mid = (l+r)//2 if A[mid] == x: break elif A[mid] &lt; x: l = mid+1 elif A[mid] &gt; x: r = mid - 1 if A[mid] != x: return -1 return mid #Student End Y = input().split() #输入格式[1,2,3,4,5] 4 A = eval(Y[0]) x = eval(Y[1]) ind = findx(A,x) print(ind) 第2关：重复序列的二分搜索 #Student start def findx(A,x): l,r = 0,len(A)-1 if A[0]==x: return 0 while l&lt;=r: mid = (l+r)//2 if A[mid] == x: break elif A[mid] &lt; x: l = mid+1 elif A[mid] &gt; x: r = mid - 1 if A[mid] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ded623a1dfc7b99c75dc6ec19e825576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c544cf17839a800f8037b03bf2ec1a/" rel="bookmark">
			Kettle 创建mysql连接报错：Driver class ‘org.gjt.mm.mysql.Driver‘ could not be found, make sure the ‘MySQL‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错内容以及原因 org.pentaho.di.core.exception.KettleDatabaseException: Error occurred while trying to connect to the database Driver class 'org.gjt.mm.mysql.Driver' could not be found, make sure the 'MySQL' driver (jar file) is installed. org.gjt.mm.mysql.Driver at org.pentaho.di.core.database.Database.normalConnect(Database.java:497) at org.pentaho.di.core.database.Database.connect(Database.java:389) at org.pentaho.di.core.database.Database.connect(Database.java:360) at org.pentaho.di.core.database.Database.connect(Database.java:350) at org.pentaho.di.core.database.DatabaseFactory.getConnectionTestReport(DatabaseFactory.java:85) at org.pentaho.di.core.database.DatabaseFactory.getConnectionTestResults(DatabaseFactory.java:115) at org.pentaho.di.core.database.DatabaseMeta.testConnectionSuccess(DatabaseMeta.java:2859) at org.pentaho.ui.database.event.DataHandler.testDatabaseConnection(DataHandler.java:659) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.pentaho.ui.xul.impl.AbstractXulDomContainer.invoke(AbstractXulDomContainer.java:313) at org.pentaho.ui.xul.impl.AbstractXulComponent.invoke(AbstractXulComponent.java:157) at org.pentaho.ui.xul.impl.AbstractXulComponent.invoke(AbstractXulComponent.java:141) at org.pentaho.ui.xul.swt.tags.SwtButton.access$500(SwtButton.java:43) at org.pentaho.ui.xul.swt.tags.SwtButton$4.widgetSelected(SwtButton.java:137) at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c544cf17839a800f8037b03bf2ec1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e870f8780306aa1e98724b7f3ab5b1/" rel="bookmark">
			conda怎么查看可以安装哪些版本的python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Conda环境中，你可以通过几种不同的方式查看可以安装的Python版本。以下是一些常用的命令：
查看所有可用的Python版本：
使用以下命令，可以列出所有可通过conda安装的Python版本：
conda search python --full-name --all 选项可以列出所有版本，包括不可用的版本。
查看特定Python版本的可用安装选项：
如果你已经知道你想要安装的Python版本，可以使用以下命令来查看该版本下所有可用的安装选项：
conda search python=3.x.x 其中 3.x.x 是你想要查询的Python版本。
查看当前配置的Conda环境中可用的Python版本：
如果你想要查看在当前配置的Conda环境中可以安装的Python版本，可以使用：
conda search python --override-channels --channel "defaults" 这将搜索默认的Conda通道中可用的Python版本。
查看特定通道中可用的Python版本：
Conda允许你从不同的通道（channels）安装软件包。如果你想要查看特定通道中可用的Python版本，可以指定通道：
conda search python --override-channels --channel conda-forge 这里 conda-forge 是一个常用的第三方通道，包含了许多默认通道中没有的软件包。
查看已安装的Python版本：
如果你想要查看当前系统中已经安装的Python版本，可以使用：
conda list python 这将列出当前环境中已安装的Python版本。
请记得，根据你的系统和Conda配置，可用的Python版本可能会有所不同。如果你使用的是Anaconda，可能还需要考虑Anaconda自己的通道。此外，某些Python版本可能需要特定的操作系统或架构才能安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3f3680278fa91c3fc4edba45651e172/" rel="bookmark">
			通俗易懂的Stable Diffusion模型结构介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SD的发展历程
SD 模型的网络结构
ClipText 文本编码器
文本向量输入Unet
VAE模型
总结图
SD的发展历程 Stable Diffusion是一个的文本条件隐式扩散模型(text-conditioned latent diffusion model)，可以根据文字描述生成效果极好的图像。
2021年12月提出了隐式扩散模型（Latent Diffusion Models，LDMs）的text-to-image模型。这个研究使得用扩散模型进行文字生成图片任务可以在普通显卡上执行，并且耗时较短。为一年后现象级的稳定扩散（Stable Diffusion）诞生奠定了基础。
SD 模型的网络结构 主要包括三个部分： ClipText 文本编码器 ClipText 文本编码器：用于解析提示词的 Clip 模型
文本编码器负责将提示词转换成电脑可以识别的文本向量
Diffusion 扩散模型 Diffusion 扩散模型：用于生成图像的 U-Net 和 Scheduler
扩散模型负责根据文本向量生成图像
VAE 模型 VAE 模型：用于压缩和恢复的图像解码器
而图像编码器则用于将生成的图像信息进行解码，以生成最终的图像输出
简化网络结构图 详细网络结构图 ClipText 文本编码器 为了导入提示词，我们首先需要为文本创建数值表示形式。
为此，Stable Diffusion使用了一个名为CLIP的预训练Transformer模型。
CLIP的文本编码器会将文本描述转换为特征向量，该特征向量可用于与图像特征向量进行相似度比较。
因此，CLIP非常适合从文本描述中为图像创建有用的表征信息。输入的文本提示语首先会被分词（也就是基于一个很大的词汇库，将句子中的词语或短语转换为一个一个的token），然后被输入CLIP的文本编码器，从而为每个token（分词）产生一个768维（针对Stable Diffusion 1.x版本）或1024维（针对Stable Diffusion 2.x版本）的向量。
CLIP模型 CLIP模型是一个基于对比学习的多模态模型，主要包含Text Encoder和Image Encoder两个模型。
其中Text Encoder用来提取文本的特征，可以使用NLP中常用的text transformer模型作为Text Encoder；
而Image Encoder主要用来提取图像的特征，可以使用CNN/vision transformer模型（ResNet和ViT）作为Image Encoder。与此同时，他直接使用4亿个图片与标签文本对数据集进行训练，来学习图片与本文内容的对应关系。
文本向量输入Unet 文本提示词转换为向量后将被输入扩散模型，用于引导图像的生成，这里使用的扩散模型是Unet网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3f3680278fa91c3fc4edba45651e172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed01a79cae5be026c6c5c17a527578b3/" rel="bookmark">
			YOLO目标检测项目--YOLOv4算法对交通标志的识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交通安全的重要性 交通安全是指在道路上保障交通参与者的生命安全和财产安全，预防交通事故发生的和减少事故造成的伤亡和损失。交通安全是社会发展和人民生活的重要组成部分，其与人们的生命财产安全和社会稳定密切相关。为此，通过深度学习技术对交通标志进行识别和检测，包括交通指示牌、交通信号灯和交通标线导向箭头等，提高导航设备对交通标志识别的准确性和效率，为驾驶员提供更好的交通信息服务，降低驾驶风险。
YOLOv4算法简介 YOLOv4是You Only Look Once版本4的缩写，是一种先进的目标检测算法，是基于YOLOv3的基础上进行进一步优化和完善，其旨在解决yolo之前版本和其他检测模型的局限性-- 不仅适用于推荐系统，还适用于独立的流程管理和减少人工输入，并且可以使用传统的GPU进行训练和测试，并能够获得实时的、高精度的检测结果。
YOLOv4算法属于单阶段目标检测算法，其具有检测速度快、综合性能强的优点，可以实现一次性得到检测对象的位置信息和类别信息。其主要组成部分如下：
骨干网络Backbone--用于从输入数据中提取特征；颈部Neck--将提取到的各种尺寸特征进行融合；检测头部Head--用来完成目标分类以及回归操作。 数据准备及标注 首先，通过代码将模型训练所需标注和检测的图像（交通指示牌、交通信号灯和交通标线导向箭头）进行采集，采集过程中需注意以下几点要求：
数据集应包含以上提到的交通指示牌、交通信号灯和交通标线导向箭头等种类，确保模型在任何情况下都能准确识别；数据的质量--数据集中的图像优先采取分辨率高的且易识别的，切不可包含太多的噪声和干扰；数据集需要有准确的标注信息，包括每张图像中交通标志的位置和类别。 数据预处理的步骤如下：
数据格式转换：采集到的图像通常是.jpg、.webp、.png等格式，使用格式工厂将采集到图像进行格式转换，统一转换成.jpg格式；数据标注：使用labelling对每张图像进行标注，标明需要识别的交通标志的位置以及其类别；标注完成后以.xml的格式进行保存到相应的文件夹；数据加载：将预处理后的图像加载到相应的文件夹，用于下一步模型的训练；数据压缩：对图像进行适当的有损压缩，图像太大也会影响模型的正常训练。 本模型共采集图片150张，对150张图片进行数据预处理，最终筛选到100张质量较高的图片用于模型训练，目标检测算法--自动划分训练集和测试集。
附（如何使用labelling进行图片标注）：
首先，解压labelling压缩包，运行labelling.exe;设置需要标注图像的文件夹路径以及标注成功的图像存放路径；加载图片后，点击create\nRectBox进行标注--使用矩形框对其所需要识别的类型标注；标注完成，点击保存图片。 YOLOv4模型的训练 将下载好的YOLOv4的代码框架解压，并使用pycharm打开；将模型需要标注的图像保存到yolov4-pytorch-master/VOCdevkit/VOC2007/JEPGImages目录（保存之前，清空该目录下的所有图像）；同理，将已使用labelling标注过的.xml文件保存到yolov4-pytorch-master/VOCdevkit/VOC2007/Annotations（保存之前，清空该目录下的所有.xml文件）。(注意：JEPGImage中的图像名称必须与Annotations中的.xml文件对应且数量相同)修改yolov4-pytorch-master/model_data/coco_classes.txt和yolov4-pytorch-master/model_data/voc_classes.txt，将上述文件修改成所需要标注和识别图像的类型。修改train.py中的‘optimizer_type’="adam"（原代码框架使用的优化器为SGD），同时相应的修改"weight_decay"=0（adam会导致weight_decay错误，使用adam时建议设置为0）。完成上述步骤后，对模型开始进行训练--先运行voc_annotation.py，再运行train.py（完成一次训练大概3.5小时）。模型训练完成后，将模型训练得到的last_epoch_weights.pth存放到yolov4-pytorch-master/model_data，同时修改yolo.py的“model_path”路径（即model_path:'model_data/last_epoch_weights.pth'），修改结束后，需要再次运行yolo.py。将需要进行预测的图像保存到yolov4-pytorch-master/img文件夹中，运行predict.py对图像进行预测：完成上述步骤后，对训练好的模型进行保存。 模型预测结果 经过训练后的模型能够较为准确的识别不同图像的交通指示牌、交通信号灯和交通标线导向箭头这三类并对其进行位置标注以及精确率的展示。这些识别结果证明了本模型在交通标志识别任务上的性能和效果，为交通管理部门和驾驶员提供了重要的辅助信息，有助于提高交通安全水平。
以下是模型预测结果的展示：
结论 通过展示经过训练的YOLOv4模型在测试集上的交通标志识别结果，可以得出以下结论：
YOLOv4模型在交通标志识别任务上表现不错，能够准确地识别不同类型的交通标志，并且标注出它们的位置和类别。模型对于各种复杂场景下的交通标志都能够有效地进行识别，包括停车标志、限速标志、交通信号灯和路口标线导向箭头等。YOLOv4模型在交通标志识别任务上具有高准确性和鲁棒性，能够为驾驶员和交通管理部门提供重要的交通信息，有助于提高交通安全水平。 综上所述，经过训练的YOLOv4模型在交通标志识别方面表现不错，为改善交通管理和提升交通安全提供了有效的技术支持。随着深度学习技术的不断发展和模型的进一步优化，相信这种技术将在未来更多领域发挥更加重要的作用，为建设更便捷、美好的社会做出贡献。
参考文献 [1]张鐘月.基于改进Yolo5s的人脸口罩检测[D].东华大学,2021.DOI:10.27012/d.cnki.gdhuu.2021.001527.
[2]江屾,殷时蓉,罗天洪,等.基于改进YOLOv4的多目标车辆检测算法[J].计算机工程与设计,2024,45(04):1181-1188.DOI:10.16208/j.issn1000-7024.2024.04.030.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28e8d1fa2c4c1272d9dddd37143dddf/" rel="bookmark">
			【Python】全面掌握 Collections Deque：队列与栈的高效实现及动态内存管理指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一章：`deque` 的定义和特性1. 什么是双端队列（deque）2. `deque` 与普通列表（list）的性能差异 第二章：构造函数1. 如何创建一个 `deque`2. 可选参数 `maxlen` 的作用和使用场景 第三章：添加和删除元素1. 使用 `append` 方法在右端添加元素2. 使用 `appendleft` 方法在左端添加元素3. 使用 `pop` 方法从右端删除元素4. 使用 `popleft` 方法从左端删除元素 第四章：访问和旋转元素1. 如何访问 `deque` 中的元素2. `deque` 的索引和切片操作3. `deque` 的 `rotate` 方法 第五章：扩展 `deque`1. 使用 `extend` 方法在右端扩展多个元素2. 使用 `extendleft` 方法在左端扩展多个元素 第六章：限制和性能考虑1. `maxlen` 属性的影响2. `deque` 的内存效率和操作效率 第七章：实际应用场景1. 实现队列和栈2. 实现滑动窗口代码实现维护 `deque` 的递减性质例子解析检查和移除逻辑 3. 广度优先搜索 (BFS) 第八章：注意事项和局限性1. `deque` 的局限性2. 何时不应使用 `deque` 本文章主要探讨 Python collections 模块中的 deque 类，详尽介绍了其定义、特性、构造方法、操作技巧、实际应用场景以及其使用时的注意事项和局限性。
第一章：deque 的定义和特性 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a28e8d1fa2c4c1272d9dddd37143dddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07cd252b5e219a95cf4b482e441df2a9/" rel="bookmark">
			大数据深度学习长短时记忆网络（LSTM）：从理论到PyTorch实战演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理长期依赖问题 遗忘门机制梯度消失问题的缓解广泛的应用领域灵活的架构选项成熟的开源实现小结 4. LSTM的实战演示 4.1 使用PyTorch构建LSTM模型 定义LSTM模型 训练模型评估和预测 5. LSTM总结 解决长期依赖问题 广泛的应用领域灵活与强大开源支持持战与展望 总结反思 广泛的应用领域灵活与强大开源支持持战与展望总结反思 大数据深度学习长短时记忆网络（LSTM）：从理论到PyTorch实战演示 本文深入探讨了长短时记忆网络（LSTM）的核心概念、结构与数学原理，对LSTM与GRU的差异进行了对比，并通过逻辑分析阐述了LSTM的工作原理。文章还详细演示了如何使用PyTorch构建和训练LSTM模型，并突出了LSTM在实际应用中的优势。
1. LSTM的背景 人工神经网络的进化 人工神经网络（ANN）的设计灵感来源于人类大脑中神经元的工作方式。自从第一个感知器模型（Perceptron）被提出以来，人工神经网络已经经历了多次的演变和优化。
前馈神经网络（Feedforward Neural Networks）: 这是一种基本的神经网络，信息只在一个方向上流动，没有反馈或循环。卷积神经网络（Convolutional Neural Networks, CNN）: 专为处理具有类似网格结构的数据（如图像）而设计。循环神经网络（Recurrent Neural Networks, RNN）: 为了处理序列数据（如时间序列或自然语言）而引入，但在处理长序列时存在一些问题。 循环神经网络（RNN）的局限性 循环神经网络（RNN）是一种能够捕捉序列数据中时间依赖性的网络结构。但是，传统的RNN存在一些严重的问题：
梯度消失问题（Vanishing Gradient Problem）: 当处理长序列时，RNN在反向传播时梯度可能会接近零，导致训练缓慢甚至无法学习。梯度爆炸问题（Exploding Gradient Problem）: 与梯度消失问题相反，梯度可能会变得非常大，导致训练不稳定。长依赖性问题: RNN难以捕捉序列中相隔较远的依赖关系。 由于这些问题，传统的RNN在许多应用中表现不佳，尤其是在处理长序列数据时。
LSTM的提出背景 长短时记忆网络（LSTM）是一种特殊类型的RNN，由Hochreiter和Schmidhuber于1997年提出，目的是解决传统RNN的问题。
解决梯度消失问题: 通过引入“记忆单元”，LSTM能够在长序列中保持信息的流动。捕捉长依赖性: LSTM结构允许网络捕捉和理解长序列中的复杂依赖关系。广泛应用: 由于其强大的性能和灵活性，LSTM已经被广泛应用于许多序列学习任务，如语音识别、机器翻译和时间序列分析等。 LSTM的提出不仅解决了RNN的核心问题，还开启了许多先前无法解决的复杂序列学习任务的新篇章。
2. LSTM的基础理论 2.1 LSTM的数学原理 长短时记忆网络（LSTM）是一种特殊的循环神经网络，它通过引入一种称为“记忆单元”的结构来克服传统RNN的缺点。下面是LSTM的主要组件和它们的功能描述。
遗忘门（Forget Gate） 遗忘门的作用是决定哪些信息从记忆单元中遗忘。它使用sigmoid激活函数，可以输出在0到1之间的值，表示保留信息的比例。
[
f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f)
]
其中，(f_t)是遗忘门的输出，(\sigma)是sigmoid激活函数，(W_f)和(b_f)是权重和偏置，(h_{t-1})是上一个时间步的隐藏状态，(x_t)是当前输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07cd252b5e219a95cf4b482e441df2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f40e659fc2e1842d6fb2fff1a257c8c/" rel="bookmark">
			【刷题】leetcode 1 . 两数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两数之和 两数之和1 思路一 （简单突破）2 思路二 （进行优化）3 思路三 （哈希表 我还不会） 谢谢阅读Thanks♪(･ω･)ﾉ下一篇文章见！！！ 两数之和 题目链接
1 思路一 （简单突破） 最简单的思想： 遍历 从头开始逐个遍历。
首先选定 加数1 然后寻找 加数2 ，如果两者之和满足条件 target 。返回相应下标即可！
int* twoSum(int* nums, int n, int target, int* returnSize) { for(int i = 0;i &lt; n;i++){ //加数1 从头开始 for(int j = i + 1;j &lt; n;j++){ //加数2 从加数1 后一位开始 if(nums[i]+nums[j] == target){ //满足条件即可返回对应下标 int* a = (int*)malloc(2*sizeof(int)) ; a[0] = i; a[1] = j; //返回的数组大小 *returnSize = 2; //返回数组 return a; } } } //如果全不满足 返回NULL *returnSize = 0; return NULL; } 提交！ 过啦！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f40e659fc2e1842d6fb2fff1a257c8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18bf901b3e04d00cf54ea80c162c730c/" rel="bookmark">
			学习 | android studio 如何制作.9图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纯纯的一边开发一边学习，是小白是菜鸟，单纯的记录和学习，大神勿喷，理解有错望指正～
前言 前几天接触到了android studio 中的.9格式的图片制作，详细记录一下我所理解的吧～
问题 我们经常会遇到某个图片被拉伸，变形，失真这些问题。
那么如何在图片可以被拉伸的情况下，依然不影响四个角落与中间的图案呢？
.9图片就可以帮助解决这个问题。
举例 如下所示，这个图片是一个正方形的图片，但由于它容器里的textView文本偏长，导致这张图片就被拉伸的不忍直视，我们要做的就是：让它的四个角以及中间的图片不被拉伸
在这里展示一下对比的结果，效果还是很明显的吧，那接下来我们就来制作.9图片。
设置前：
设置后：
制作 新建.9图片： 1、可以让公司的UI设计师针对你的图片画一份；
2、右击图片重命名直接在后面加上.9；
3、右击图片选择create 9-Patch file 直接生成一张新的，不过记得要把旧的png的删掉，否则编译会报错；
查看.9图片： 创建好后打开，左下角图片预览那一栏下面多了两个 tab 栏：9-Patch 和 ImageFileEditor；
选中 9-Patch 栏，我们可以看到如下界面：
左边的是我们的原图； 原图图片很小的话，可以用下方工具栏的Zoom放大查看。 右边可以看到有3张图： 代表竖直方向拉伸后的图片代表水平方向拉伸后的图片代表竖直方向和水平方向都拉伸后的图片 可以看到，拉伸后四个角都已经变形，里面的数字1也被拉伸了，如果你预览的时候右边的图片很小的话，可以用下方工具栏的patch scale 放大查看。 将鼠标移到左边原图上，这个时候会看到边界显示的有好几条线，通过移动这几条线，就可以给图片绘制1px宽度的黑线。
这里就必须说一下四条边上黑线的含义了，也是制作的秘诀。
上边：控制图片水平方向可拉伸的区域左边：控制图片竖直方向可拉伸的区域右边：控制图片内包裹内容的竖直显示区域下边：通知图片内包裹内容的水平显示区域 也就是左上两条边控制图片本身的拉伸，右下两条边控制图片包裹内容的显示区域。
编辑.9图片： 那这张图片就可以这样制作：
这里说一下这些线条的意思：
上边：代表水平可拉伸区域，在水平方向设置一条黑线，也可以是一个点，或者几条或几个点（不用设置很长，因为黑线区域就表示可无限拉伸）左边：代表竖直方向可拉伸的区域，同样也是为了避免中间的1被拉伸，而且上下拉伸距离一样，所以选择了在圆角部分和1的部分不做拉伸。右边，内容竖直方向区域是要充满的，但不能到圆角部分下边，内容水平方向区域是要充满的，但是不能到圆角部分 设置完后，就可以看到这图的效果了，然后我们设置一下scale参数，发现就算被放大到很大，图片依然没有失真，那我们的 .9 就算成功了。
这里再说一下上图中几个可勾选内容的意思：
show lock :暂时不知道什么意思，只是注意到如果勾选，鼠标放到原图上会出现一块红黑色区域show content ：图片包裹内容的显示区域，也就是上图右边部分图偏蓝色部分show patches：显示图片被拉伸的区域，也就是左边原图中间那几个红色小区域show bad patches: 显示做的不好的可拉伸的区域。比如，我们的消息气泡的那个尖尖我们肯定不想被拉伸，如果我们照如下图设置左边黑线让尖角也是可拉伸的区域，就会显示 bad patches。 到此， .9 图就制作完毕了。
参考链接：android studio 制作.9 图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b17b0b45dcc66d919514b717121c810f/" rel="bookmark">
			Stable-Diffusion 报错： no attribute ‘lowvram‘ 或not implemented for ‘Half‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AttributeError: ‘NoneType‘ object has no attribute ‘lowvram‘；
RuntimeError: “addmm_impl_cpu_” not implemented for ‘Half’
进入stable-diffusion-webui文件夹，找到webui-user.bat文件，右键编辑，找到
set COMMANDLINE_ARGS= 这一行，在后面添加
--lowvram --precision full --no-half --skip-torch-cuda-test 使得整个文件呈现以下内容
@echo off set PYTHON= set GIT= set VENV_DIR= set COMMANDLINE_ARGS= --lowvram --precision full --no-half --skip-torch-cuda-test call webui.bat 保存后重新启动webui-user.bat文件文件即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8053b9ec40474750c778b2373514534a/" rel="bookmark">
			Android Studio 安装配置教程 - MacOS(详细版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven{ url’http://maven.aliyun.com/nexus/content/repositories/jcenter’}
}
dependencies {
classpath ‘com.android.tools.build:gradle:3.5.2’
// NOTE: Do not place your application dependencies here; they belong
// in the individual module build.gradle files
}
}
allprojects {
repositories {
google()
//jcenter()
maven{ url’http://maven.aliyun.com/nexus/content/groups/public/’ }
maven{ url’http://maven.aliyun.com/nexus/content/repositories/jcenter’}
}
}
task clean(type: Delete) {
delete rootProject.buildDir
}
然后Try Again再尝试一下
OK 编译正常了，遇到问题不可怕，可怕的是对问题的恐惧和没有解决问题的决心。下面进行一些个人喜好的常规配置
Mac不同于Windows 编译器的导航栏都在系统顶部，点击Android Studio 然后选择Preferences…,快捷键就是 ⌘ + ,
点击更换背景图片
然后点击OK,再去更改字体的样式和大小
点击OK
现在看起来就舒服多了。
安装插件
1.GsonFormat
快速将json字符串转换成一个Java Bean，免去我们根据json字符串手写对应java Bean的过程。
点击安装，安装完之后需要重启Android Studio 你的插件才会生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8053b9ec40474750c778b2373514534a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892c87702a0f4db8eb1367d6e5fe68f0/" rel="bookmark">
			【MySQL】查询数据，对结果进行排序（关键字：ORDER BY）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 单列排序多列排序指定排序方式，升序（ASC，ASCENDING） / 降序（DESC，DESCENDING）`ORDER BY` 关键字与 `LIMIT` 关键字联用 我是一名立志把细节都说清楚的博主，欢迎【关注】🎉 ~
原创不易， 如果有帮助 ，记得【点赞】【收藏】 哦~ ❥(^_-)~
如有错误、疑惑，欢迎【评论】指正探讨，我会尽可能第一时间回复的，谢谢支持
我们有个学生表，里面有10个学生数据。
SELECT idx_student_name FROM student; 查询结果：
+ ---------------- + | idx_student_name | + ---------------- + | 范晓明 | | 刘秀英 | | 黎璐 | | 苏云熙 | | 雷睿 | | 方睿 | | 严震南 | | 沈璐 | | 刘岚 | | 严宇宁 | + ---------------- + 通常我们直接查询出来的数据顺序是数据的插入顺序，所以并不一定是我们想要的顺序。
单列排序 我们要让数据按我们希望的方式，就需要使用到 ORDER BY 关键字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/892c87702a0f4db8eb1367d6e5fe68f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46464637aac20c180248bf76600b4f41/" rel="bookmark">
			Android Studio APK在真机上运行的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之后我们再回到目录下看APK目录发现两个文件已经更新了，APK也变大了很多，这时候我们再进行安装就可以了。
那么Instant Run是什么呢，Make Project又是什么呢。
Instant Run（即时运行）是android的新版本出了一个革命性的功能。新的即时运行功能可以让开发者像写html网页一样写Android原生代码，能做到一边修改代码，一边在模拟器或者实际设备上看到修改代码后的结果。但也存在着一些的问题，我们可以在Settings→Build→Instant Run:中关闭它，但是并不建议，可以通过重新Build一下解决。
Build下面有很多的选项，搬运一下翻译：
1. Make Project：编译Project下所有Module，一般是自上次编译后Project下有更新的文件，不生成apk
Make Selected Modules: 编译指定的Module，一般是自上次编译后Module下有更新的文件，不生成apk
Clean Project: 删除之前编译后的编译文件，并重新编译整个Project，比较花费时间，不生成apk
Rebuild Project: 先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成apk
Build APK:前面4个选项都是编译，没有生成apk文件，如果想生成apk，需要点击Build APK
Generate Signed APK:生成有签名的apk
平时小的改动直接用Make Project就可以了。
这种方法最快，但是像第三方登录、分享、支付等功能，都需要打上签名包才能完整使用，这种Debug包不能直接使用，我们就只能通过最常规的方法采用Generate Signed APK。
点进来的界面是这样的，这时我们需要点击Create New，填写弹出来的弹框
按照步骤来操作
等待完成之后我们就可以到相应目录找到apk进行安装
这样程序就可以在手机上跑了
当然我们要是在虚拟机上程序能运行的话，也可以通过ES浏览器，找到应用，长按相应应用进行备份，就会生成应用的安装包，然后找到安装包导出到手机上安装也可。
最后 希望大家能有一个好心态，想进什么样的公司要想清楚，并不一定是大公司，我选的也不是特大厂。当然如果你不知道选或是没有规划，那就选大公司！希望我们能先选好想去的公司再投或内推，而不是有一个公司要我我就去！还有就是不要害怕，也不要有压力，平常心对待就行，但准备要充足。最后希望大家都能拿到一份满意的 offer ！如果目前有一份工作也请好好珍惜好好努力，找工作其实挺累挺辛苦的。
这里附上上述的面试题相关的几十套字节跳动，京东，小米，腾讯、头条、阿里、美团等公司19年的面试题。把技术点整理成了视频和PDF（实际上比预期多花了不少精力），包含知识脉络 + 诸多细节。
由于篇幅有限，这里以图片的形式给大家展示一小部分。
网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化学习资料的朋友，可以戳这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！**
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ee5ede14c56f98d2e968d7d8591dd2/" rel="bookmark">
			最新可商用级chatgpt4.0系统源码&#43;Midjourney-AI绘画系统 集成国内外数十个AI大模型和绘画接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的飞速发展，人工智能正在逐步改变我们的生活，特别是在艺术创作领域。分享一款最新可商用级ChatGPT 4.0系统源码与Midjourney AI绘画系统的完美结合，集成国内外数十个AI大模型与绘画接口，为创作者们带来了前所未有的智能创意体验。
一、ChatGPT 4.0：智能对话，引领语言理解新高度
ChatGPT 4.0作为最新一代的智能对话系统，以其卓越的自然语言处理能力和深度学习技术，能够与用户进行流畅、智能的对话。无论是艺术创作的灵感探讨，还是技术细节的咨询，ChatGPT 4.0都能给出精准、富有创意的回答和建议，为创作者们提供源源不断的灵感支持。
二、Midjourney AI绘画系统：智能生成，绘就艺术新篇章
结合Midjourney AI绘画系统，创作者们可以尽情释放自己的想象力。该系统集成了国内外数十个AI大模型和绘画接口，能够根据用户的输入智能生成高质量的画作。无论是细腻的笔触、鲜明的色彩，还是深邃的意境，Midjourney都能完美呈现，让创意在画布上自由流淌。
三、集成优势，打造一站式智能创意平台
ChatGPT 4.0与Midjourney AI绘画系统的集成，实现了智能对话与智能绘画的无缝对接。用户可以通过与ChatGPT的对话，描述自己的创作意图和风格要求，然后直接将这些信息传递给Midjourney进行智能绘画。系统不仅仅可以AI对话，AI绘画做图，还可以AI智能生成思维导图，系统支持用户自助注册成为会员并自助购买会员套餐使用，无需人工干预，是一款盈利能力超强的智能AI系统源码，帮助大家低成本利用互联网创业。这种一站式的智能创意平台，不仅提升了创作效率，更让创作者们能够专注于创意本身，尽情享受创作的乐趣。
四、可商用级系统源码：稳定可靠，灵活扩展
我们提供的ChatGPT 4.0系统源码和Midjourney AI绘画系统源码均经过严格测试和优化，确保稳定可靠的性能。同时，源码的开放性也意味着用户可以根据自己的需求进行定制开发，添加更多的功能和特性，满足个性化的创作需求。
Chatgpt4.0系统源码下载地址：帮企商城或春哥技术博客——AI智能对话绘画二合一系统源码商业运营版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d904910b40347fc9cf4c5968f0949c/" rel="bookmark">
			java中switch条件语句的用法、switch的三种语法、switch支持的参数类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、switch的应用场景二、switch三种语法2.1、switch 标准方式2.2、switch - &gt; 用法2.2、switch yield 用法 三、什么是case穿透？四、示例4.1、标准示例4.2、错误示例4.3、引申用法（多条件合并） 一、switch的应用场景 在分支结构中，我们除了使用if-else或者是if-else if之外，当分支量过大的时候，我们即可选择使用switch语句进行选择
二、switch三种语法 Java中switch的三种用法详解：
switch 标准方式switch - &gt; 用法switch yield 用法 2.1、switch 标准方式 语法：
switch (表达式) { case 值1: // 执行语句块1 break; case 值2: // 执行语句块2 break; ... case 值N: // 执行语句块N break; default: // 如果以上所有case都不匹配，执行默认语句块 } case语句中指定的每个值必须具有与表达式兼容的类型。switch语句的执行顺序是，首先计算表达式的值，然后将该值与每个case的值进行比较，如果找到匹配的case，则执行该case下的语句，直到遇到break语句或switch语句结束。如果没有找到匹配的case，且存在default子句，则执行default子句中的语句。如果没有匹配的case且没有default子句，程序将不执行任何操作。
注意：若表达式的值与case后面的值匹配则会执行该case下的语句，但是若该case下没有break，则会一直往下执行，直到遇到break语句或switch语句结束
注意
1.表达式支持的参数类型：
JDK1.0-1.4 数据类型接受 byte、short、int、char
JDK1.5 数据类型接受 byte、short、int、char、enum(枚举)、(包装类型Character、Byte、Short、Integer)
JDK1.7 数据类型接受 byte、short、int、char、enum(枚举)、包装类型、String 六种类型
（1）对四个包装类的支持是因为java编译器在底层手动进行拆箱。
（2）而对枚举类的支持是因为枚举类有一个ordinal方法,该方法实际上是一个int类型的数值。
（3）jdk1.7开始支持String类型,但实际上String类型有一个hashCode算法,结果也是int类型。
（4）而byte short char类型可以在不损失精度的情况下向上转型成int类型.所以总的来说,可以认为switch中只支持int类型。
float、double都不能用于switch语句。
2.default 子句是可选的，当没有匹配的 case 时，执行default
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3d904910b40347fc9cf4c5968f0949c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674ba46c903045d74a924113df90ad85/" rel="bookmark">
			C#实现 IDbConnection / IDbCommand 等相关通用数据接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于数据接口
对象执行流程
范例运行环境
设计与实现
引用
GetConnection方法
GetCommand方法
GetParameter方法
小结
关于数据接口 在.net 应用中，与数据库进行连接、访问和执行经常会用到数据接口的相关对象，如下：
1、 Connection
表示一个到数据库的打开的连接，是连接数据必不可少的对象。
2、 Command
命令对象，表示要对数据源连接执行的 SQL 语句或存储过程，以获取返回结果或执行返回值。
3、 DataParameter
用于表示Command命令对象需要的参数设置，虽然这是一个可选项，但在实际的应用中几乎都会使用到
ADO.NET 中的数据提供者对象提供了IDbConnection、IDbCommand、IDbDataParameter等通用数据接口，本文将利用这些对象实现一个通用方法以访问和操作数据库内容。
对象执行流程 首先需要创建连接对象，成功后下达符合对应数据库规范的命令指令，该指令可能包括需要的参数对象（需要定义名称和赋值等操作），大体流程如下图：
范例运行环境 操作系统： Windows Server 2019 DataCenter
.net版本： .netFramework4.7.1 或以上
开发工具：VS2019 C#
数据库：在这里我们以支持 Oracle 9i、MS SQL Server 2016、国产达梦数据 8 为例
设计与实现 引用 在实现方法前请引用如下代码：
using System.Data; using System.Data.SqlClient; using System.Data.OracleClient; using Dm; using System.Collections; GetConnection方法 GetConnection 方法返回 System.Data.IDbConnection 对象，其参数说明见下表：
序号参数名类型说明1DbServerTypestring目前支持 "oracle"、 "dm8"，其它字符串均视为 MS SQL Server2ConnectionStringstring对应数据库的连接字符串 实现代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/674ba46c903045d74a924113df90ad85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b274b8ff4422cc7d558563d31dedcc/" rel="bookmark">
			C语言：数据结构（双向链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、双向链表的结构2、顺序表和双向链表的优缺点分析3、双向链表的实现 1、双向链表的结构 注意：这⾥的“带头“跟前面我们说的“头节点”是两个概念，实际前面的在单链表阶段称呼不严谨，但是为了更好的理解就直接称为单链表的头节点。
带头链表里的头节点，实际为“放哨的”，哨兵位节点不存储任何有效元素，只是站在这里“放哨的”。
“哨兵位”存在的意义：遍历循环链表避免死循环。
2、顺序表和双向链表的优缺点分析 不同点顺序表链表存储空间上物理上一定连续逻辑上连续，但物理上不一定连续随机访问支持O(1)不支持O(N)任意位置插⼊或者删除元素可能需要搬移元素，效率低只需修改指针指向插入动态顺序表，空间不够时需要扩容没有容量的概念应用场景元素高效存储和频繁访问任意位置频繁插入和删除 3、双向链表的实现 ListNode.h
#pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; //定义双向链表节点的结构 typedef int Ltdatatype; typedef struct ListNode { Ltdatatype data; struct ListNode* prev;//指向前一个节点的指针 struct ListNode* next;//指向后一个节点的指针 }ListNode; //双向链表的初始化 ListNode* LtInit(); //尾插 //不改变哨兵位的地址，所以传一级即可 void LtPushBack(ListNode* phead, Ltdatatype x);//插入数据之前，链表必须初始化到只有一个头结点的情况 //打印链表 void LtPrint(ListNode* phead); //头插 void LtPushFront(ListNode* phead, Ltdatatype x); //尾删 LtPopBack(ListNode* phead); //头删 LtPopFront(ListNode* phead); //查找 ListNode* LtFind(ListNode* phead, Ltdatatype x); //指定位置前插入 void LtInsert(ListNode* pos, Ltdatatype x); //删除pos位置 void LtErase(ListNode* pos); //销毁链表 void LtDestroy(ListNode* phead); ListNode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b274b8ff4422cc7d558563d31dedcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b092e3a45196a0dc190a13cfe4db9e7/" rel="bookmark">
			Linux系统安装Redis7（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统安装Redis7 一、windows安装redis二、Linux安装Redis下载redis编辑redis7.conf文件启动redis-server服务如何关闭redis服务设置Redis开机自启动 一、windows安装redis Window 下安装
下载地址：https://github.com/dmajkic/redis/downloads
下载到的Redis支持32bit和64bit。根据自己实际情况选择，将64bit的内容cp到自定义盘符安装目录取名redis。 如 C:\reids
打开一个cmd窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.conf 。
如果想方便的话，可以把redis的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个redis.conf可以省略，
如果省略，会启用默认的。输入之后，会显示如下界面：
这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。
切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。
设置键值对 set myKey abc
取出键值对 get myKey
二、Linux安装Redis 1、Linux环境安装Redis必须先具备gcc编译环境
什么是gcc：
gcc是linux下的一个编译程序，是C程序的编译工具。
GCC(GNU Compiler Collection) 是 GNU(GNU’s Not Unix) 计划提供的编译器家族，它能够支持 C, C++, Objective-C, Fortran, Java 和 Ada 等等程序设计语言前端，同时能够运行在 x86, x86-64, IA-64, PowerPC, SPARC和Alpha 等等几乎目前所有的硬件平台上。鉴于这些特征，以及 GCC 编译代码的高效性，使得 GCC 成为绝大多数自由软件开发编译的首选工具。虽然对于程序员们来说，编译器只是一个工具，除了开发和维护人员，很少有人关注编译器的发展，但是 GCC 的影响力是如此之大，它的性能提升甚至有望改善所有的自由软件的运行效率，同时它的内部结构的变化也体现出现代编译器发展的新特征。
查看 gcc -v
如果没有就安装，注意要能访问外网的情况下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b092e3a45196a0dc190a13cfe4db9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c413abba4ce9af956480f96c6b7d27/" rel="bookmark">
			VSCode安装python以及python第三方库----Numpy，pandas，matplotlib等等最全方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
python下载与安装
VSCode下载与安装
VSCode配置
下载中文包
下载python
Numpy，pandas，matplotlib等第三方库下载
其他情况
关于matplotlib使用时可能出现的问题
matplotlib包的其他配置
关于%matplotlib inline
前言 最近在学习有关python第三方库的使用，到网上查找下载Numpy，pandas，matplotlib的方法，发现没有针对使用VSCode安装的简短系列教程，自己也是在网上找大佬的博客，然后反复调试，最后成功完成安装，写了几个相关代码也都可以运行。所以特此发布我总结其他大佬发布文章后的安装方法。
python下载与安装 https://www.python.org/downloads/
在此界面选择下载系统，以Windows为例，直接点图中红色圈记位置，将会下载最新python版本。（推荐下载最新版本，可以减少麻烦）
如果需要下载其他版本，往下翻，在如下图位置进行选择下载。
下载完成后会跳出这个界面，有两个选择 ！！！无论哪种，记得勾选画圈部分
（1）Install Now会直接下载到C盘某文件
（2）Customize installation自定义安装
按如下图进行勾选，Browse选择安装路径（推荐：可以保护C盘不被过多的文件占用，从而避免系统运行缓慢的问题，而且容易找到文件）
VSCode下载与安装 https://code.visualstudio.com/Download
对于Windows下载文本的解释
文本 文本解释User Installer默认安装在当前计算机帐户目录，如果使用另一个帐号登陆计算机将无法使用别人安装的vscode。vscode默认提供的为User InstallerSystem Installer 安装在非用户目录,例如C盘根目录,任何帐户都可以使用。 推荐System Installer版本，它可以自定义安装路径（可以下载到python同一盘里，方便查找）
注意！！！按下图进行勾选
VSCode配置 下载中文包 作为一名英语渣，我选择下载中文包（-_-||）
有两种方法（推荐2）
（1）打开VSCode，Ctrl + Shift + P，点第一个，然后选择下载语言并使用
（2）按下面这个图，搜索Chinese，点击安装即可
下载python 按图中方法，安装第一个就行了
下载完可以新建一个python文件运行print("Hello World")，最上面中间位置会跳出一个选项，要求你选择编译器，按他推荐的来就行，然后再次运行应该就没有问题了
Numpy，pandas，matplotlib等第三方库下载 如图，找到终端，点击新建终端（或者直接Ctrl + Shift + `），在命令行中输入
py -m pip install numpy
pandas，matplotlib的下载只需要将numpy替换即可
其他情况 如果没有出现上面这种下载进度条，显示错误的话，尝试使用下面这个命令
pip install numpy
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c413abba4ce9af956480f96c6b7d27/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/391/">«</a>
	<span class="pagination__item pagination__item--current">392/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/393/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>