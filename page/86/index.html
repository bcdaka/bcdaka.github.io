<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2aa0770de47bff0ed2ec3abad63ad94/" rel="bookmark">
			MySQL版本选择与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL版本选择与安装 MySQL 5.5 优点:
稳定性：5.5版本是长期支持（LTS）版本，因此它非常稳定，被广泛部署在生产环境中。
兼容性：与旧版本的MySQL和各种应用程序有很好的兼容性。
缺点:
过时：5.5版本已经停止支持，不再接收安全更新和修复。
性能限制：与更新的版本相比，性能和扩展性上可能有所不足。
MySQL 8.0 优点:
全面的性能改进：8.0版本引入了更多的性能优化和新特性，如默认的InnoDB存储引擎和更好的并行复制。
现代化特性：支持窗口函数、公共表表达式（CTE）、角色和资源组等现代SQL特性。
改进的安全性：提供了更多的安全特性，如默认的加密连接和新的用户账户管理。
缺点:
升级挑战：从早期版本升级到8.0可能需要大量的准备工作和应用修改。
某些应用不兼容：一些旧的应用程序可能无法直接在8.0上运行，需要进行适当的修改和测试。
建议 对于大多数用户，建议使用最新的稳定版本，如MySQL 8.0，因为它提供了最佳的性能、安全性和新特性。
如果您的应用程序已经在一个较旧的版本上运行良好，并且没有迫切的升级需求，可以继续使用该版本，但应计划在未来进行升级。
如果您正在开发新的应用程序，建议直接使用最新的MySQL版本，以充分利用其提供的所有优势。
安装教程 1.进入MySQL官网：https://www.mysql.com/
2.点击DOWNLOADS去下载页面，页面往下滚动，点击MySQL Community (GPL) Downloads »下载社区版
3.点击MySQL Installer for Windows–&gt;选择window安装版
4.选择下面这一项，点击Download
5.点击No thanks, just start my download.
6.双击安装包，选择server only，next
7.点击Execute
8.点击next
9.设置密码，点击next
10.点击Execute安装
11.点击finish，后面一路next确定即可
配置环境变量 1.找到mysql安装目录：C:\Program Files\MySQL\MySQL Server 8.0
2.右键此电脑 ——属性——系统——系统设置——高级系统设置——环境变量
2.新建系统变量
变量名：MYSQL_HOME
变量值（MYSQL路径）：C:\Program Files\MySQL\MySQL Server 8.0
3.选中Path系统变量，然后点击编辑
4.新建：%MYSQL_HOME%\bin
5.按住Win + R打开运行
6.输入mysql -uroot -p，然后输入密码，成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f37a52c6322c267643d307e8e08083/" rel="bookmark">
			C#类和结构体的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、类class是引用类型，多个引用类型变量的值会互相影响。存储在堆（heap）上
2、结构体struct是值类型，多个值类型变量的值不会互相影响。存储在栈（stack）上
类结构关键字classstruct类型引用类型值类型存储位置托管 堆（heap）上栈（stack）上语法都使用new来说明实例都使用new来说明实例 using System; using System.Collections.Generic; using System.Text; namespace VariableScopeSample3 { class Vector { int value; public int Value { get; internal set; } } } using System; using System.Collections.Generic; using System.Text; namespace VariableScopeSample3 { struct Point { public int X { get; internal set; } public int Y { get; internal set; } } } using System; namespace VariableScopeSample3 { class Program { static int j = 20; static int Main(string[] args) { int j = 30; Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f37a52c6322c267643d307e8e08083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7bbdaa48280cf48df11f545f2086f43/" rel="bookmark">
			鸿蒙媒体开发【相机数据采集保存】拍照和图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机数据采集保存 介绍 本示例主要展示了相机的相关功能 接口实现相机的预览拍照功能。
效果预览 使用说明
弹出是否允许“CameraSample”使用相机？点击“允许”弹出是否允许“CameraSample”使用麦克风？点击“允许”进入预览界面，预览正常，点击拍照按钮，跳转到图片预览页面，跳转正常，图片预览页面显示当前所拍照的图片，显示正常进入预览界面，预览正常，点击拍照按钮，跳转到图片预览页面，跳转正常，图片预览页面显示当前所拍照的图片，显示正常，退出应用并进入图库应用，第一张图片显示为刚刚拍照的图片，拍照正常点击图片预览页面的左上角返回按钮，重新进入预览页面，预览正常进入预览界面，预览正常，滑动变焦条，变焦条上方显示变焦值，显示正常，并且预览界面随着变焦条的滑动放大或缩小，预览正常进入预览界面，预览正常，点击预览显示区域进行对焦，对焦正常进入预览界面，预览正常，点击“拍照”旁边的“录像”切换到录像模式，预览正常，点击录像按钮，开始录像，录像正常，点击停止录像按钮，跳转到录像预览界面，跳转正常，点击视频播放按钮，播放正常 具体实现 相机功能接口实现在CameraService.ets，源码参考：[CameraService.ets] /* * Copyright (c) 2024 Huawei Device Co., Ltd. * Licensed under the Apache License, Version 2.0 (the 'License'); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an 'AS IS' BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7bbdaa48280cf48df11f545f2086f43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5659a38e972c1a376c2f44967c27f089/" rel="bookmark">
			机器学习练手（三）：基于决策树的iris 多分类和波士顿房价预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：本文为和鲸python 可视化探索训练营资料整理而来，加入了自己的理解（by GPT4o）
原活动链接
原作者：vgbhfive，多年风控引擎研发及金融模型开发经验，现任某公司风控研发工程师，对数据分析、金融模型开发、风控引擎研发具有丰富经验。
在前一关中学习了如何使用肘部法则计算最佳分类数，也知道了计算 KMeans 分类的特征要求。在新的一关中，我们将开始学习训练决策树模型。
总结：注意训练模型后打印特征重要性的操作，clf.feature_importances_ ，用于后续优化模型
目录 决策树iris 数据集之多分类问题引入依赖加载数据训练模型和计算测试集指标特征重要性可视化决策树总结 波士顿房价之回归问题加载数据预处理数据训练回归模型计算测试集指标 闯关题STEP1：请根据要求完成题目 决策树 决策树字如其名，其主要展示类似于树状结构。
在分类问题中，表示基于特征对实例进行分类的过程，过程可以认为是 if-then 的集合 ;而在回归问题中，会被认为特征分布在分类空间上的条件概率分布。
iris 数据集之多分类问题 Iris 数据集算是机器学习算法的入门数据集，其包含有三个分类结果和四个特征信息，其分别是花萼长度，花萼宽度，花瓣长度，花瓣宽度，通过上述四个特征信息预测鸢尾花卉属于哪一类？
引入依赖 import pandas as pd import numpy as np from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor from sklearn.metrics import accuracy_score, r2_score, mean_squared_error 加载数据 # 1. 加载数据 iris = load_iris() x, y = pd.DataFrame(iris.data), iris.target x.head(), y ( 0 1 2 3 0 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5659a38e972c1a376c2f44967c27f089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6059c15d48a080f14a8ce7fe48f1b83/" rel="bookmark">
			OGG同步目标端中文乱码处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象说明： 源端字符集：AMERICAN_AMERICA.ZHS16GBK
目标端字符集：AMERICAN_AMERICA.AL32UTF8
源端同步过来的数据显示中文乱码。
查询数据库表中含有乱码的字段：
select * from xx.xxxx a where to_char(a.crtopetime,'yyyy-mm-dd')='2024-08-02' and asciistr(a.customername) like '%?%' or asciistr(a.customername) like '%\FFFD%' order by a.feerecid,a.crtopetime 处理方法如下，在源端的E进程和目标端的R进程添加如下配置。
Replicate Chinese Characters AMERICAN_AMERICA.ZHS16GBK to target charset AL32UTF8, Oracle to Oracle, 11.1 and before 11.2 (Doc ID 1469735.1)
OGG目标端的R进程的字符集目前配置的SETENV (NLS_LANG=“AMERICAN_AMERICA.AL32UTF8”)，
源端的字符集设置是SETENV (NLS_LANG=“SIMPLIFIED CHINESE_AMERICA.ZHS16GBK”)
根据MOS这个解决方法是，源端和目标端都要设置为
setenv NLS_LANG=AMERICAN_AMERICA.ZHS16GBK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dfb595655a2741e9967b9a1f6f17c67/" rel="bookmark">
			R 语言学习教程，从入门到精通，R的安装与环境的配置（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、R 基础语法 一门新的语言学习一般是从输出 “Hello, World!” 程序开始，R 语言的 “Hello, World!” 程序代码如下：
myString &lt;- "Hello, World!" print ( myString ) 以上示例将字符串 “Hello, World!” 赋值给 myString 变量，然后使用 print() 函数输出。
注意：R 语言赋值使用的是左箭头 &lt;- 符号，不过一些新版本也支持等号 =。
1.1、变量 R 语言的有效的变量名称由字母，数字以及点号 . 或下划线 _ 组成。
变量名称以字母或点开头。
1.2、变量赋值 最新版本的 R 语言的赋值可以使用左箭头 &lt;-、等号 = 、右箭头 -&gt; 赋值:
# 使用等号 = 号赋值 &gt; var.1 = c(0,1,2,3) &gt; print(var.1) [1] 0 1 2 3 # 使用左箭头 &lt;-赋值 &gt; var.2 &lt;- c("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dfb595655a2741e9967b9a1f6f17c67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17cc48dff5de397b7e0a3205424b6a9/" rel="bookmark">
			C&#43;&#43;——异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本篇文章我们来分享C++的一个全新内容——异常。
目录
一.异常概念
二.异常的使用
1.异常的抛出和匹配原则 2.在函数调用链中异常栈展开匹配原则
3.异常的重新抛出
三.异常的优缺点
1.优点
2.缺点
结语
一.异常概念 异常是一种处理错误的方式，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的直接或间接的调用者处理这个错误。
异常的使用包含以下三个关键字：
throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。catch: 在您想要处理问题的地方，通过异常处理程序捕获异常.catch 关键字用于捕获异常，可以有多个catch进行捕获。try: try 块中的代码标识将被激活的特定异常,它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：
try
{
// 保护的标识代码
}catch( ExceptionName e1 )
{
// catch 块
}catch( ExceptionName e2 )
{
// catch 块
}catch( ExceptionName eN )
{
// catch 块
} 简单来说，就是try区域保护某些语句，当语句出现异常时，由throw抛出一个某种类型的异常对象，通过与多个catch语句的对象类型进行匹配，再执行catch中的语句。 二.异常的使用 1.异常的抛出和匹配原则 异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个。 抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁。（这里的处理类似于函数的传值返回）catch(...)可以捕获任意类型的异常，问题是不知道异常错误是什么。实际中抛出和捕获的匹配原则有个例外，并不都是类型完全匹配，可以抛出的派生类对象使用基类捕获。 2.在函数调用链中异常栈展开匹配原则 首先检查throw本身是否在try块内部，如果是再查找匹配的catch语句。如果有匹配的，则调到catch的地方进行处理。没有匹配的catch则退出当前函数栈，继续在调用函数的栈中进行查找匹配的catch。如果到达main函数的栈，依旧没有匹配的，则终止程序。上述这个沿着调用链查找匹配的catch子句的过程称为栈展开。所以实际中我们最后都要加一个catch(...)捕获任意类型的异常，否则当有异常没捕获，程序就会直接终止。找到匹配的catch子句并处理以后，会继续沿着catch子句后面继续执行。 下面我们实战一下异常的使用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d17cc48dff5de397b7e0a3205424b6a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37009d2d80c367b3dcafe5bd0174c807/" rel="bookmark">
			GPT-4o mini模型：小型化AI解决方案的创新应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 每日一句正能量前言开发者视角初步接触与性能评估集成与开发流程成本效益分析创新应用案例面临的挑战与解决方案社区贡献与经验分享未来展望 性能评估处理能力与响应速度准确性与可靠性多功能性与灵活性资源效率可扩展性与集成性用户定制与微调 结论 成本效益分析初始投资成本运营成本性能与价格的平衡维护与支持成本扩展性与长期投资回报成本效益的实际案例 结论 应用案例研究聊天机器人的智能化升级内容推荐系统的优化自动化报告生成语言学习应用的辅助工具社交媒体监控与分析 结论 提升开发效率快速原型开发减少编码工作量自动化测试与验证代码生成与优化多语言支持持续集成与持续部署（CI/CD）知识库与文档自动生成个性化开发助手 结论 创新能力创意构思的加速器自然语言理解的深化数据驱动的洞察力内容创作的自动化个性化服务的定制跨领域应用的融合交互式学习体验创新解决方案的快速迭代 结论 挑战与解决方案挑战一：特定领域适应性挑战二：数据隐私和安全性挑战三：模型解释性和透明度挑战四：多语言和方言支持挑战五：实时性能要求挑战六：持续的模型更新和维护挑战七：用户接受度和培训 结论 后记 每日一句正能量 成功与不成功之间有时距离很短只要后者再向前几步。自己打败自己是最可悲的失败，自己战胜自己是最可贵的胜利。
前言 在人工智能的宏伟画卷中，OpenAI的GPT-4o mini模型以其小巧的身躯和强大的能力，为小型化AI解决方案添上了浓墨重彩的一笔。这款被誉为“迄今为止最具成本效益的小模型”的发布，不仅在技术领域引起了广泛的关注，更为开发者们带来了前所未有的机遇与挑战。
随着AI技术的日益成熟，其在各行各业的应用也变得日益广泛。然而，高昂的成本和复杂的部署流程往往让许多有志于创新的开发者望而却步。GPT-4o mini模型的出现，以其卓越的性能和亲民的价格，打破了这一僵局，为小型企业和个人开发者打开了AI世界的大门。
本次活动旨在汇聚来自不同领域的开发者，分享他们使用GPT-4o mini及其他大型语言模型的宝贵经验。我们希望通过这些真实的案例，深入探讨如何有效利用这些工具来提升开发效率，激发创新能力，并在实际工作中实现价值最大化。
从自动化客服到智能内容生成，从数据分析到个性化推荐，GPT-4o mini模型的应用案例将为我们展示AI技术如何助力解决现实问题，推动行业发展。我们诚邀您加入这场关于创新与实践的讨论，共同见证AI技术如何以其小型化解决方案，开启智能时代的新篇章。
开发者视角 初步接触与性能评估 作为开发者，我对GPT-4o mini模型的初步接触是通过OpenAI的官方发布。这款模型以其卓越的性能和经济实惠的价格迅速吸引了我的注意。在对模型进行初步的性能评估后，我被其处理速度和准确性所折服，这些特性对于任何寻求在AI领域创新的开发者来说都是极具吸引力的。
集成与开发流程 集成GPT-4o mini模型到我的项目中是一个相对平滑的过程。OpenAI提供的文档和API接口非常易于理解和使用，这大大减少了技术门槛和学习成本。我开始通过几个小规模的试点项目来测试模型的极限和适用性，这些项目包括了一个简单的聊天机器人和内容推荐系统。
成本效益分析 成本效益是我选择GPT-4o mini模型的一个重要因素。相较于其他大型语言模型，GPT-4o mini在保持了高性能的同时，显著降低了计算资源的需求和使用成本。这使得我可以将预算和资源集中在创新和功能开发上，而不是仅仅为了维持模型的运行。
创新应用案例 在我的开发过程中，GPT-4o mini模型被用于多种应用场景。例如，在构建一个自动化客户支持系统时，该模型能够快速准确地理解用户查询并提供有用的反馈。此外，我还利用它来增强我的数据分析工具，通过自然语言查询来提取和解释数据模式。
面临的挑战与解决方案 尽管GPT-4o mini模型带来了许多便利，但在开发过程中也遇到了一些挑战。例如，模型在处理特定领域的专业术语时有时会遇到理解上的障碍。为了解决这个问题，我对模型进行了微调，并引入了领域特定的训练数据集，以提高其在特定任务上的表现。
社区贡献与经验分享 作为开发者社区的一部分，我积极参与到GPT-4o mini模型的讨论和知识共享中。通过技术论坛、博客文章和开源项目，我分享了我的经验和学习成果，同时也从其他开发者那里获得了宝贵的反馈和建议。
未来展望 展望未来，我期待GPT-4o mini模型能够继续进化，增加更多功能和改进。我相信，随着AI技术的不断进步，GPT-4o mini将为更多创新应用提供动力，帮助开发者解决更加复杂和多样化的问题。
通过上述内容，我们可以看到GPT-4o mini模型不仅为开发者提供了一个高效且经济的AI解决方案，而且通过社区的共同努力，它的潜力正在不断地被挖掘和扩展。
性能评估 处理能力与响应速度 GPT-4o mini模型在处理自然语言任务时展现出了令人印象深刻的能力。从简单的问答到复杂的语言推理，该模型都能迅速给出响应。我们通过一系列基准测试，包括问答、文本摘要和情感分析等任务，评估了其响应速度和准确性，结果表明GPT-4o mini在各项任务中均达到了行业领先水平。
准确性与可靠性 准确性是衡量语言模型性能的关键指标之一。在对GPT-4o mini模型进行了一系列测试后，我们发现其在理解自然语言和生成合理响应方面表现出色。此外，模型的可靠性也得到了验证，即使在长时间运行和高负载情况下，也能保持稳定的性能。
多功能性与灵活性 GPT-4o mini模型的多功能性是其另一大亮点。无论是文本生成、翻译、摘要还是对话系统，该模型都能提供高质量的输出。这种灵活性使得GPT-4o mini能够轻松适应不同的应用场景和需求，为开发者提供了广泛的选择空间。
资源效率 在评估性能的同时，我们也关注模型的资源效率。GPT-4o mini模型在保持高性能的同时，对计算资源的需求相对较低，这使得它能够在多种硬件平台上运行，包括一些资源受限的环境。这一点对于希望降低运营成本的企业和开发者来说尤为重要。
可扩展性与集成性 评估还包括了模型的可扩展性和集成性。GPT-4o mini模型提供了易于使用的API接口和灵活的部署选项，使得开发者可以快速将其集成到现有系统或新项目中。此外，模型的可扩展性也意味着它可以随着业务需求的增长而水平扩展，满足更大规模的应用需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37009d2d80c367b3dcafe5bd0174c807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7863d6f1b963215b82546bed585ad76/" rel="bookmark">
			一键编译并启动一个 ARM Linux qemu 虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要事先自己编译 qemu-system-arm 可执行文件；
1，编译创建ARM 虚拟机 1.1 一起从头开始版 cd 进一个空文件夹，然后
$ vim buildup.sh
$ bash buildup.sh
访问github网络没什么问题：
硬编码了一个路径/home/hipper/ex_vexpress/ 两处，
改成自己的当前路径即可，懒得改了，见谅见笑了 ^^
buildup.sh:
#!/usr/bin/bash mkdir workspace cd workspace git clone https://github.com/qemu/qemu.git cd qemu/ git checkout v9.0.0 mkdir build_arm/ cd ./build_arm/ ../configure --target-list="arm-softmmu,arm-linux-user" --prefix=/home/hipper/ex_vexpress/workspace/qemu-bin-arm/ make -j make install cd ../../ sudo ls sudo apt-get install gcc-arm-linux-gnueabi wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.10.tar.gz tar zxf linux-kernel-v5.10.tar.gz cd linux-5.10/ make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm vexpress_defconfig make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm -j cd .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7863d6f1b963215b82546bed585ad76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb9751d77864db4ec241ae19bbc585d6/" rel="bookmark">
			分布式领域扩展点设计稿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式领域扩展点设计稿 背景坐标设计理念设计图Quick Start相关组件 背景 随着交易业务和基础知识的沉淀，愈发觉得扩展点可以在大型交易分布式架构中可以做更多的事情。
经过一个月的思考，决定将 单点领域扩展点（savior-ext） 从原有的 savior架构 中剥离开来，升级成为 分布式领域扩展点（sext） ，之后单独去维护和迭代。
坐标 官网：轻量级分布式技术解决方案框架 - Savior
分布式领域扩展点（新 · 完全兼容上一个大版本 · 可直接替换坐标）
&lt;dependency&gt; &lt;groupId&gt;cn.sunjinxin.savior&lt;/groupId&gt; &lt;artifactId&gt;sext&lt;/artifactId&gt; &lt;version&gt;2.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 领域扩展点（旧）
&lt;dependency&gt; &lt;groupId&gt;cn.sunjinxin.savior&lt;/groupId&gt; &lt;artifactId&gt;savior&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;/dependency&gt; 设计理念 作为一名工程师，我深知一个框架引入到系统中会带来很大的便利，但同时也会让系统设计和架构升级以及业务迭代变得更加复杂。
所以该分布式领域扩展点框架具备以下几种特性
轻量化（引入轻量、API轻量，达到一键启动）可插拔（防止应用架构变得沉重，业务点可随时一键剔除，一键替换）可编排（可达到工作流的编排能力，对业务能够达到充分的抽象化）可配置（基于配置中心能力，对框架所有能力和服务动态配置）可灰度（可通过对流量进行染色，设置流量权重，达到灰度可能）可监控（对框架所覆盖的业务指标和相关基础设施指标进行监控）可降级（对编排的扩展点进行熔断降级，提高系统的可用性）可扩展（基本的业务扩展能力，以及供开发人员在应用层扩展框架的能力） 设计图 Quick Start 在启动类上标注@Savior注解，即可启动Savior框架所有组件的功能。
import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.SpringApplication; import cn.sunjinxin.savior.core.anno.Savior; /** * @author issavior * @date 1314/05/20 00:00:00 */ @Savior @SpringBootApplication public class AppRun { public static void main(String[] args) { SpringApplication.run(AppRun.class, args); } } 相关组件 Savior框架中的组件亦可以独立引入，目前支持的组件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb9751d77864db4ec241ae19bbc585d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70f5549c2e8e0ab4addc30babec4b1a/" rel="bookmark">
			#Datawhale AI 夏令营第三期—siRNA药物药效预测学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		赛事概要 一、赛题背景 随着mRNA疫苗在新冠预防领域取得成功，核酸类药物的研发获得了越来越多的关注。本次比赛聚焦于通过机器学习技术，利用化学修饰后的siRNA序列来预测RNA干扰（RNAi）机制下对靶基因（target gene）的沉默效率，这一指标与药物实际疗效直接相关。RNAi是生物体内天然存在的一种基因表达调控机制，通过抑制靶基因的表达来实现降低目标蛋白量的目的，这一机制一般可通过siRNA实现。目前开源的数据库中，以RNA主干序列（裸序列）为主，缺少相应的化学修饰数据。而本赛题特别关注了化学修饰对siRNA序列功能的影响，化学修饰对siRNA的毒性、体内稳定性、靶向效果、药效等具有重大影响，在实际药物设计中至关重要。参赛者将接触到领域独特的包含靶基因、siRNA裸序列、经过化学修饰的siRNA修饰序列以及实验室测定的沉默效率值。这些数据反映了当今siRNA设计的最新科技成果，包括化学修饰的种类和位置，以及它们如何影响siRNA对靶基因的沉默效率。
本赛题的研究成果将可以直接用于优化siRNA药物在医学研究和临床应用中的效率和安全性。优化siRNA的设计可以提高其沉默特定基因的能力，降低非特异性作用，从而增强疗效和降低副作用。这一技术的提升在疾病治疗和基因治疗领域具有极高的应用潜力和商业价值。此外通过建立对应预测模型，可以加速新型siRNA药物的虚拟筛选，促进个性化医疗的实现。
二、赛题任务 初赛 提供一部分公开文献中提取的siRNA修饰序列以及相应实验条件数据（例如药物浓度、细胞系、转染方式等），随机打散后使用约85%数据训练，剩余约15%数据用于leaderboard submission评分，主要用于测试针对在训练集中出现过的目标mRNA序列，不同siRNA的沉默效率预测的准确率。
复赛 在初赛基础上，将额外增加一部分公开文献提及的以及RONA Therapeutics（大睿生物）提供的尚未公开专利中的siRNA修饰序列数据作为测试数据，主要评估未在训练集中出现过的目标mRNA序列的siRNA的沉默效率的预测准确性。
三、评审规则 1.数据说明 train_data.csv train_data.csv的每行为一条训练记录，包含数据记录的id、siRNA裸序列、相应的siRNA修饰序列、目标mRNA序列、siRNA浓度、细胞系、转染方法等实验室条件以及对应的实验室测量的mRNA Remaining值等总计19个字段。其中mRNA Remaining值为我们模型的训练目标，其余18个字段的全部或部分可以作为模型的输入特征。Remaining值代表了经过siRNA的沉默之后，mRNA的剩余百分比（相对于对照组）。Remaining值越低，siRNA的沉默效率越好，药效就越好。Remaining值一般位于0-100的区间内，100表示完全没有沉默效果，0表示该mRNA被彻底沉默，但是由于实验室测量的误差，可能存在少量训练记录的mRNA Remaining值在这个范围之外，这是正常的数据。
打开文件如下图所示：
表头解释：
sample_submission.csv sample_submission.csv为初赛的leaderboard submission测试集，格式与初赛训练集train_data.csv相同。不同之处在于mRNA_remaining_pct列的数值为空，参赛者需要填充这些空白处的预测结果后提交。
vocab.csv vocab.csv为经过归一化后的siRNA化学修饰缩写表
第一列（Abbreviation）：列出了各种修饰核苷酸的缩写。第二列（Chemical Name）：展示了与第一列中缩写对应的完整化学名称。这些化学名称详细描述了核苷酸的结构，包括对其进行的化学修饰。这些修饰可能涉及改变核苷酸的糖部分、磷酸基团或碱基，以增强其性能，如提高稳定性或特定的生物活性。 baseline.py 本次比赛提供一个基础的基线方法，利用 RNN 来预测Remaining值。基线方法中我们仅使用了siRNA_sense_seq 字段作为特征，除此之外尚有其他特征对Remaining结果有重大影响。
2.评分机制 本次任务采用3个指标来进行评测
平均绝对误差（MAE）：平均绝对误差是对每个样本的绝对误差取平均值，主要用于衡量模型在整体上的预测精度。为实验室的真实测量值，为模型的预测值，计算公式 MAE=，其中是样本总数，MAE∈[0,100]MAE∈[0,100]。预测值在一定范围内的平均绝对误差（Range-MAE）：在实际场景我们会尤其关注在低Remaining区间模型的预测准确率，此指标衡量在特定范围内的预测值的平均绝对误差。在本次比赛中，低Remaining范围为[0,30]，计算公式 Range-MAE=，其中是预测值在[0,30][0,30]范围内的样本数量，Range-MAE∈[0,100]。预测值在一定范围内的F1指标（F1）：此指标衡量在特定范围内的预测值的precision以及在相应区间预测的recall情况，综合得到F1值。在本次比赛中，低Remaining范围为[0,30][0,30]。 初赛 初赛评测：将公开文献中的siRNA序列数据随机打乱后，提供选手85%数据训练评估，保留15%数据用于leaderboard评分。最终得分基于上述3个指标计算得到，计算公式
score=50%×(1−MAE/100)+50%×F1×(1−Range-MAE/100)score=50%×(1−MAE/100)+50%×F1×(1−Range-MAE/100)
score计算的第一项关注模型在整体区间上的预测精度情况，score计算的第二项同时关注模型在低Remaining区间的粗分类结果以及更进一步在低Remaining区间的预测精度情况。
复赛 复赛评测：额外增加一部分公开文献以及大睿生物提供的尚未公开的siRNA修饰序列实验数据作为测试数据。最终得分计算方式与初赛一致。
代码实现解释： # score = 50% × (1−MAE/100) + 50% × F1 × (1−Range-MAE/100) def calculate_metrics(y_true, y_pred, threshold=30): # 预测值和真实值之间绝对误差的平均值，衡量了模型预测的总体准确性。 mae = np.mean(np.abs(y_true - y_pred)) # 这里将真实值和预测值进行二值化处理：如果值小于阈值（30），则为1，否则为0。 y_true_binary = (y_true &lt; threshold).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e70f5549c2e8e0ab4addc30babec4b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717d0bc0fcd3cf9d2ab0634cd2b5a9a9/" rel="bookmark">
			实践致知第17享：电脑忽然黑屏的常见原因及处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景需求 小姑电话说：最近，电脑忽然就黑屏了（如下图所示），但是等待几十秒甚至一分钟，电脑就能自然恢复了，这种状况一天能出现三四次，怎么办？
二、分析诊断 电脑黑屏常见的原因有很多种，这里介绍三种：
1、系统问题：这种问题重装一下即可。
2、驱动问题：这种问题可能是由于系统升级导致驱动版本太低不适配导致的，需要下载一个驱动大师，修复一下即可；
3、硬件问题：需要去电脑修理店修理。
三、解决方案 这次遇到的“黑屏问题”是因为驱动问题，升级完驱动之后，一切就恢复正常了，没有再出现突然黑屏的现象，下为操作步骤：
1、百度搜索“驱动人生”，或者直接点击该链接https://www.160.com/，下载最新版本的“驱动人生”，路径如下图所示。
2、安装好“驱动人生”后，点击“全面诊断”，会提示诊断到的问题（如下图所示），点击“立即修复”即可。
3、修复工作完成之后，重启一下电脑即可。
四、拓展思考 除了这3种情况，是否还有其他的情况及其解决方法？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5150f3ac46f182934ee3925a78d7fbb/" rel="bookmark">
			Java语言程序设计——篇十一(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌿🌿🌿跟随博主脚步，从这里开始→博主主页🌿🌿🌿
欢迎大家：这里是我的学习笔记、总结知识的地方，喜欢的话请三连，有问题可以私信🌳🌳🌳
您的点赞👍、关注➕、收藏⭐️、评论📝、私信📧是我最大的支持与鼓舞！！！🌻🌻🌻 集合——Set Set接口及实现类HashSet类实战演练 用Set对象实现集合操作TreeSet类实战演练实战演练 对象顺序实战演练综合实例 Set接口及实现类 Set接口是Collection的子接口，其中不允许有重复的元素。Set接口没有定义新的方法，只包含从Collection接口继承的方法。Set接口的常用实现类有：HashSet类、TreeSet类。 HashSet类 HashSet类用散列方法存储元素，具有最好的存取性能，但元素没有顺序。HashSet类的构造方法有： HashSet(): 初始容量是16，默认装填因子是0.75。
HashSet(Collection c)
HashSet(int initialCapacity)
HashSet(int initialCapacity, float loadFactor)
实战演练 例：HashSetDemo.java
import java.util.*; public class HashSetDemo { public static void main(String[] args) { Set&lt;String&gt; words = new HashSet&lt;&gt;(); words.add("one"); words.add("two"); words.add("three"); words.add("one"); //不能将重复元素添加到集合中 for(String s:words) System.out.print(s+" "); } } 用Set对象实现集合操作 使用Set对象的批量操作方法，可以实现标准集合代数运算。假设s1和s2是Set对象，下面的操作可实现相关的集合运算。 s1.addAll(s2)：实现集合s1与s2的并运算。
s1.retainAll(s2)：实现集合s1与s2的交运算。
s1.removeAll(s2)：实现集合s1与s2的差运算。
s1.containAll(s2)：如果s2是s1的子集，该方法返回true。
TreeSet类 TreeSet实现一种树集合， 它使用红-黑树算法为元素排序，因此集合中的元素是有序存放的。添加到TreeSet中的元素必须是可比较的，即元素的类必须实现Comparable接口。构造方法如下： TreeSet()
TreeSet(Collection c)
TreeSet(Comparator c)
实战演练 例：TreeSetDemo.java
import java.util.*; public class TreeSetDemo{ public static void main(String[] args){ Set&lt;String&gt; ts = new TreeSet&lt;&gt;(); String[] s = new String[]{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5150f3ac46f182934ee3925a78d7fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065b9f294766b60a4c65552e4fd2367b/" rel="bookmark">
			Blazor Web 应用如何实现Auto模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍Blazor Web应用Auto交互呈现模式的实现方案，如下示例是基于 Known 框架来实现的，该解决方案共有3个项目，具体实现步骤如下：
1. 前后端共用项目 创建前后端共用类库项目Sample，定义系统的实体类、数据模型、服务接口、常量、枚举等，项目工程文件内容如下： &lt;Project Sdk="Microsoft.NET.Sdk"&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt; &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt; 在该项目中添加示例服务接口，继承框架IService //IService为框架定义的Api服务接口，用于标识该接口为前后端交互接口 //程序启动时，框架自动查找Assembly中的接口，根据接口定义WebApi路由 //该示例路由为：/Test/GetMessage public interface ITestService : IService { Task&lt;string&gt; GetMessageAsync(); } 2. 客户端项目 创建客户端项目Sample.Client，引用WebAssembly所需依赖，引用Castle依赖动态代理Http请求后端WebApi，项目工程文件内容如下： &lt;Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly"&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt; &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt; &lt;NoDefaultLaunchSettingsFile&gt;true&lt;/NoDefaultLaunchSettingsFile&gt; &lt;StaticWebAssetProjectMode&gt;Default&lt;/StaticWebAssetProjectMode&gt; &lt;/PropertyGroup&gt; &lt;ItemGroup&gt; &lt;PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="8.0.6" /&gt; &lt;PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Authentication" Version="8.0.6" /&gt; &lt;PackageReference Include="Microsoft.Extensions.Http" Version="8.0.0" /&gt; &lt;PackageReference Include="Castle.Core" Version="5.1.1" /&gt; &lt;PackageReference Include="Castle.Core.AsyncInterceptor" Version="2.1.0" /&gt; &lt;ProjectReference Include="..\Sample\Sample.csproj" /&gt; &lt;/ItemGroup&gt; &lt;/Project&gt; 添加拦截器HttpClientInterceptor.cs类文件，继承Castle.DynamicProxy.IAsyncInterceptor，实现Http动态代理 using Castle.DynamicProxy; namespace Sample.Client; // HttpInterceptor为框架封装的拦截器 public class HttpClientInterceptor&lt;T&gt;(IServiceScopeFactory provider) : HttpInterceptor&lt;T&gt;(provider), IAsyncInterceptor where T : class { protected override async Task&lt;HttpClient&gt; CreateClientAsync() { var type = typeof(T); var factory = await ServiceFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/065b9f294766b60a4c65552e4fd2367b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84dcca979bd1dda72dc701d532842592/" rel="bookmark">
			机器人主板维修｜ABB机械手主板元器件故障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ABB机器人电路板故障原因诊断】
针对上述故障现象，我们需要对ABB机器人IO板进行详细的故障诊断。以下是一些可能的故障原因：
1. 元器件老化或损坏：ABB机械手安全面板上的元器件在长期使用过程中可能出现老化、损坏或接触不良等问题，导致IO板无法正常工作。
2. 电源异常：电源异常或供电不稳可能导致IO板上的芯片或其他元器件损坏，进而影响整个系统的运行。
3. 通讯线缆故障：ABB工业机械臂通讯板与主板之间的通讯线缆可能出现断线、短路或接触不良等问题，导致通讯异常。
4. 外部干扰：外部干扰源如电磁干扰、静电等可能对ABB机器人IO板产生影响，导致其工作异常。
5. 环境因素：恶劣的使用环境如高温、潮湿、粉尘等也可能对IO板造成损害。
ABB机器人主板维修：ABB机械手主板维修
子锐机器人常见ABB机器人主板维修型号有：ABB机械手安全面板 DSQC643 3HAC024488-001维修、ABB工业机械臂通讯板 DSQC602 3HAC12816-1维修、ABB机器人IO板 DSQC1031 3HAC058664-001维修等。
【ABB工业机械臂主板维修方法】
针对不同的故障原因，我们可以采取以下维修方法：
1. 检查电源：首先检查ABB机器人IO板的电源是否正常，包括电源电压、电流等参数是否符合要求。同时检查电源线缆是否连接牢固，无短路或断路现象。
2. 更换元器件：如果确定元器件损坏，需要将其更换为同型号、同规格的新元器件。在更换过程中要注意操作规范，避免损坏其他元器件或电路板。
3. 检查通讯线缆：检查ABB机械臂IO板与主板之间的通讯线缆是否正常，包括线缆是否完好、接头是否牢固等。如有需要，可以更换新的通讯线缆。
4. 抗干扰措施：针对外部干扰源引起的故障，可以采取相应的抗干扰措施，如增加滤波器、磁环等器件来降低干扰对ABB机械手IO板的影响。
5. 改善使用环境：如果故障由环境因素引起，需要改善机器人的使用环境，如降低温度、减少湿度、清理粉尘等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf25bbb30c4bc4808b0673511578a40/" rel="bookmark">
			Flask&#43;LayUI开发手记（一）：LayUI表格的前端数据分页展现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用数据表格table展示系统数据，是LayUI的基本功能，编码十分简单，就是通过table.render()渲染，把属性配置好就OK了，十分方便，功能也十分强大。
不过，在实现时，把table的有个功能却理解错了，就是分页。
table.render()的分页属性，主要包括三个，page、limit和limits，page是逻辑值，设置为true是分页，limit是每页显示行数，limits是设置面显示行数的多条选项。应该说，这几个属性都十分清晰，按说明配好后，果然分页控制栏就显示出来了，真不错。
原来以为只要在服务端把需要的数据生成好传到前端来，分页就算完成了，但做了一段时间就发现不对了。开始做无外乎就是用户、角色、权限编辑，记录都很少，用不上分页，等做日志显示时一下就看出错误了，分页设的16条，怎么系统在一个页面把全部100多条数据都展示了。
然后仔细研究才发现，这三个分页属性设置好，只是相当于打了了前端控制的开关，界面上显示出分页流程控件，可以进行分页切换操作，但数据展示内容，前端不管，还是要后端做处理的。table会在每次点击一次页面切换时，就向后端提交一次数据请求，请求中含有page和limit属性，后端按这两个参数把当前页的数据记录生成传下来。
我是一直不喜欢这种每换一次页就要向后端提数据请求的实现逻辑的。一页才展示10几条记录，每次换页都要去取数据，来来回回的，性能不好，对后端压力有些太多了。而且，大部分数据展示功能，总共也就是几百条数据，完全可以一次把数据取到前端来，只在前端做处理就可以了。这样无疑大大减轻后端服务器的压力，而且控制上也比较简单是吧。
也因此，我把系统需要进行分页展示的功能分成两种模式实现，一是前端数据分页，二是后端数据分页 。前端数据分页，即一次性提取后台数据到前端，由前端实现全部的分页数据处理控制，后端数据分页，即前端展示分页操作栏，所有的分页操作均提交到后端进行数据请求，由后端生成分页数据传给前端。
下面这些程序，就是前端数据分页功能的实现，程序主要分为三个部分，前端html、JS实现、后端数据处理服务。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; &lt;title&gt;CMS系统-登录日展示&lt;/title&gt; &lt;link rel="stylesheet" href="/static/layui/css/layui.css" media="all"&gt; &lt;/head&gt; &lt;body&gt; &lt;table id="admin_log" lay-filter="admin_log" style="margin-top:-15px;"&gt;&lt;/table&gt; &lt;script type="text/html" id="toolBar"&gt; &lt;div class="layui-btn-container"&gt; &lt;div class="layui-inline" style="display:inline;margin-right:10px;"&gt; &lt;label class="layui-btn-sm"&gt;日期范围&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;input type="text" id="bdate" placeholder="开始日期" autocomplete="off" class="layui-input layui-btn-sm"&gt; &lt;/div&gt; &lt;label class="layui-btn-sm" style="display:inline;"&gt;-&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;input type="text" id="edate" placeholder="结束日期" autocomplete="off" class="layui-input layui-btn-sm"&gt; &lt;/div&gt; &lt;div class="layui-input-inline" style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf25bbb30c4bc4808b0673511578a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc8a13dba43de09076689036e023ec82/" rel="bookmark">
			Redis1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的优势 1.性能极高
2.数据类型丰富
3.支持数据的持久化
4.支持数据备份
Redis除了能做什么？ 分布式缓存、内存存储和持久化、分布式锁、排行榜、消息队列.....
Redis怎么实现消息队列？ Redis5.0新增的数据结构Stream可以用来做消息队列，不过和专业的消息队列相比还有很多欠缺。
Redis数据类型 1.String（字符串）
2.List（列表）
3.Hash（哈希表）
4.Set（集合）
5.Zset(sorted set：有序集合)
6.GEO（地理空间）
7.HyperLogLog（基数统计）
8.bitmap（位图）
9.bitfield（位域）
10.Stream（流）
最后两种不常见
Redis实现统计网站UV？ UV：独立访客，一般理解为客户端IP，需要去重
HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的
Redis实现一个排行榜？ Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。可以用Zset实现排行榜。
Redis单线程模型 Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现
所谓 I/O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 select 、 poll 、 epoll 来配合。多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。 Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型 Redis6.0之前为什么不使用多线程依旧很快？ 1.基于内存操作
2.数据结构简单
3.多路复用和非阻塞I/O
4.避免上下文的切换
Redis6.0之前性能瓶颈不在CPU
Redi6.0之后为何引入了多线程？ 提高网络IO读写性能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c631144fa3c0cb5bd0c41515991c982/" rel="bookmark">
			Golang内存管理——堆分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go语言的内存自动分配和回收的，因此内存的使用流程大致为：获取内存——分配内存——回收内存——再分配内存。
其中分配内存分为两方面，堆内存分配和栈内存分配，堆内存和栈内存是两种不同的分配方式，本篇文章主要是堆内存的分配方式。
1. 自主内存管理 Go语言为了方便内存的自主管理，一开始启动的时候会向操作系统申请一大块连续的内存，后续的内存分配都是基于这一大块内存的。如果程序运行过程中，内存不足了，Go语言会再向操作系统进行内存的申请。
为了高效的进行内存管理，Go语言将申请到的内存划分为三个区域，分别为spans、bitmap、arena。其中arena是堆区，GO语言将其划分为一个个8KB的page页，程序运行过程中的内存都是从arena堆区进行分配的。spans和bitmap是为了对arena堆区的高效管理而设置的。
Go语言的三个内存区域 2. mspan 和 ClassID表 我们程序的运行，从使用的角度看，以对象为基本单位的。比如：函数是一个对象、goroutine是一个对象、slice是一个对象。因此，为了实现从对象到内存页之间的映射，Go语言引入了一个mspan结构体。mspan是内存管理的基本单位，每一个span包含一个或多个连续的页。为了满足小对象的分配，会将span中的一页划分为更小的粒度，而对于大对象比如超过页的大小，则会通过多页实现。每个span用于管理特定的class对象，根据对象的大小，span将一个或多个页拆分成多个块进行管理。
mspan的结构体定义如下：位置 runtime:mheap.go 一些字段已经省略了
type mspan struct { next *mspan // 链表后向指针，用于将span链接起来 prev *mspan // 链表前向指针，用于将span链接起来 startAddr uintptr // 起始地址，即所管理页的地址 npages uintptr // 该span中占用的page页数 //作用于GC,垃圾会有的时候会使用这三个字段 allocBits *gcBits //分配位图，每一位代表一个块是否已分配 gcmarkBits *gcBits pinnerBits *gcBits allocCount uint16 // 该Span中已经分配的对象数量 spanclass spanClass // 该Span的等级，一个特定的span中存储特定的ClassID大小的对象 elemsize uintptr // 块大小，该span中存储特定ClassID的大小 } Class等级列表如下:
源码位置：runtime:sizeclasses.go
划分如此多的Class等级的目的：
尽可能地减少内存浪费降低从全局缓存中获取特定SpanClass锁的粒度 // class bytes/obj bytes/span objects tail waste max waste min align // 1 8 8192 1024 0 87.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c631144fa3c0cb5bd0c41515991c982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7662b5be5693dd0a2dee379d5383cb6a/" rel="bookmark">
			抖音豆包大模型AI写作教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简数采集器支持调用字节跳动抖音的豆包AI大模型API接口，用于对采集的数据进行研究分析，内容写作等。
抖音豆包大模型AI写作使用教程：
目录
1.启用豆包AI大模型API功能
2.设置豆包API处理规则
3.应用API规则处理数据
4.获取AI处理结果
1.启用豆包AI大模型API功能 1-1）开通豆包API功能 在字节跳动的火山方舟大模型平台，先创建API Key，然后在模型推理处，创建推理接入点，选择合适版本的AI豆包大模型开通。
1-2）简数采集器连接豆包API 在简数采集器的 "第三方API接入管理" 处，点击 "+字节豆包" 按钮，填写豆包API的相应信息，连接上抖音AI豆包大模型API功能。
2.设置豆包API处理规则 API处理规则的作用：能设置调用特定的AI接口，对指定的字段执行自定义指令（Prompt）；
在简数采集器的 "API处理规则管理" 页面 --》点击 "添加API处理规则" --》设置调用豆包AI接口处理数据哪些字段的内容，字段前后可选择添加自定义AI指令（AI提示词）。
比如让豆包AI生成文章：
请用下面标题生成短文：[title]，要求短文字数小于500字
3.应用API规则处理数据 在简数采集任务的 【结果数据&amp;导出】页面，点击【第三方API执行(含AI)】 -》选择对应的API处理规则 -》可按所选的数据或状态批量执行，等待执行结果。
4.获取AI处理结果 抖音豆包AI接口写作生成的结果，会存储在新字段里，可以在【结果数据】页面中查看和获取。
如果要导出发送AI生成的结果，请注意修改其发送目标映射配置，选择新生成的AI字段。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab54048ce979174422b6d3a3f60bd95/" rel="bookmark">
			【C&#43;&#43;入门（上）】—— 我与C&#43;&#43;的不解之缘（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 学完C语言和初阶数据结构，感觉自己又行了？
接下来进入C++的学习，准备好接受头脑风暴吧。
一、第一个C++程序 C++ 的第一个程序，梦回出学C语言，第一次使用C语言写代码；这里使用C++写第一个C++代码。
#include&lt;stdio.h&gt; int main() { printf("Hello,World ! ! !\n"); return 0; } 看到这里，很疑惑？不是第一个C++程序代码吗？怎么使用C语言来写呢？
这里C++兼容C语⾔绝⼤多数的语法，所以C语⾔代码也可以运行，C++文件后缀为.cpp，vs编译器对后缀为 .cpp的文件就会调⽤C++编译器编译；linux下要⽤g++编译，不再是gcc。
当然呢，C++ 也有自己的输入输出，来看使用C++代码实现第一个C++程序：
#include&lt;iostream&gt; int main() { cout &lt;&lt; "Hello World！！！" &lt;&lt; endl; return 0; } 在接下来的学习中，一一来学习C++这些知识。
二、命名空间 2.1、命名空间的作用 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称都存在于全局作用域中，可能会导致很多冲突。
使用命名空间的目的就是对标识符的名称进行本地化，来避免命名冲突或，namespace关键字的出现就是针对命名冲突这种问题的。
在C语言中，类似与下面程序这样的命名冲突，是一个普遍存在的问题，C++引入namespace就是为了更好的解决这样的问题。
#include&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int rand = 10; int main() { // 编译报错：error C2365: “rand”: 重定义；以前的定义是“函数” printf("%d\n", rand); return 0; } 2.2、namespace的定义 定义命名空间，需要使用到namespace关键字，后面跟命名空间的名字，然后接一对{}即可，{}中即为命名空间的成员。命名空间中可以定义变量/函数/类型等等。namespace本质上是定义出一个域，这个域跟全局域各自独立，不同的域可以定义同名变量，所以下面的rand就不存在冲突（可以解决如上图所示命名冲突问题）。C++ 中域有函数局部域、全局域、命名空间与和类域；域影响的编译时语法查找一个变量/函数/类型出处（声明和定义）的编辑，所以有了域的隔离，名字冲突问题就解决了。局部域和全局域除了会影响编译查找逻辑，还会影响变量的生命周期，命名空间域和类域不影响变量的生命周期。namespace只能定义在全局，当然，也可以嵌套定义。项目工程中多文件中定义的同名namespace会认为是一个namespace，不会冲突。C++ 标准库都放在一个叫 std（standard）的命名空间里。 定义命名空间：
#include&lt;stdlib.h&gt; namespace HL { int rand = 0; int Add(int x, int y) { return x + y; } } int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eab54048ce979174422b6d3a3f60bd95/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/85/">«</a>
	<span class="pagination__item pagination__item--current">86/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/87/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>