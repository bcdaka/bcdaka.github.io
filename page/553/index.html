<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533b2da1c4e6ec1cf77bf297131143a3/" rel="bookmark">
			Android Studio配置国内镜像源和HTTP代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio配置国内镜像源和HTTP代理 一、配置国内镜像源/依赖库 1.1 打开项目的setting.gradle.kts文件 1.2 根据需要填入仓库地址 1.2.1 新版kotlin文件 maven { url=uri ("https://www.jitpack.io")} maven { url=uri ("https://maven.aliyun.com/repository/releases")} maven { url=uri ("https://maven.aliyun.com/repository/google")} maven { url=uri ("https://maven.aliyun.com/repository/central")} maven { url=uri ("https://maven.aliyun.com/repository/gradle-plugin")} maven { url=uri ("https://maven.aliyun.com/repository/public")} 示例 pluginManagement { repositories { maven { url=uri ("https://www.jitpack.io")} maven { url=uri ("https://maven.aliyun.com/repository/releases")} maven { url=uri ("https://maven.aliyun.com/repository/google")} maven { url=uri ("https://maven.aliyun.com/repository/central")} maven { url=uri ("https://maven.aliyun.com/repository/gradle-plugin")} maven { url=uri ("https://maven.aliyun.com/repository/public")} google() mavenCentral() gradlePluginPortal() } } dependencyResolutionManagement { repositoriesMode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/533b2da1c4e6ec1cf77bf297131143a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d744bda9ac7f3edc8364e8c0af82a304/" rel="bookmark">
			使用Log4j与log4j2配置mybatisplus打印sql日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：项目非完全spring项目，没有spring的配置文件。执行sql时老是不打印sql语句。因此进行修改，过程比较坎坷，记录一下。
我尝试使用log4j和log4j2进行配置 最终把这两种全部配置记录上
Log4j配置
如果项目用的是log4j需要进行配置打印sql的步骤
首先引入log4j的包配置一下log4j的配置文件 #STDOUT 表示配置sql语句输出 log4j.rootLogger=ERROR,STDOUT #xxx代表你项目中的mapper路径 log4j.logger.xxx.xxx.xxx=DEBUG log4j.appender.STDOUT=org.apache.log4j.ConsoleAppender log4j.appender.STDOUT.Target=System.out #log4j.appender.STDOUT.layout=org.apache.log4j.PatternLayout log4j.appender.STDOUT.layout=org.apache.log4j.EnhancedPatternLayout log4j.appender.STDOUT.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} %-5p %c{1.}:%L - %m%n Log4j2配置
如果使用log4j2需要进行配置打印sql的步骤
引入log4j2包配置log4j2配置文件 &lt;Configuration status="WARN"&gt; &lt;Appenders&gt; &lt;Console name="myConsole" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="[%d{MM-dd HH:mm:ss} %-5p] [%t] %c{2\} - %m%n%ex"/&gt; &lt;/Console&gt; &lt;Console name="myConsole2" target="STDOUT"&gt; &lt;PatternLayout pattern="[%d{MM-dd HH:mm:ss} %-5p] [%t] %c{2\} - %m%n%ex"/&gt; &lt;/Console&gt; &lt;RollingFile name="activexAppender" fileName="../log/jxedtgouchescf.log" filePattern="../log/jxedtgouchescf.log.%d{yyyy-MM-dd}.log"&gt; &lt;PatternLayout&gt; &lt;Pattern&gt;[%d{MM-dd HH:mm:ss SSS} %-5level] [%t] %c{3} - %m%n%ex&lt;/Pattern&gt; &lt;/PatternLayout&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d744bda9ac7f3edc8364e8c0af82a304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/727b0b3a13aee2debab8a3da48f6a5d2/" rel="bookmark">
			Java 数据结构篇-用数组、堆实现优先级队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 优先级队列说明
2.0 用数组实现优先级队列
3.0 无序数组实现优先级队列
3.1 无序数组实现优先级队列 - 入队列 offer(E value)
3.2 无序数组实现优先级队列 - 出队列 poll()
3.3 无序数组实现优先级队列 - 查看队列中优先级最大的元素 peek() 3.4 无序数组实现优先级队列 - 判断是否为空队列
3.5 无序数组实现优先级队列 - 判断是否为满队列
3.6 无序数组实现优先级队列完整代码
4.0 有序数组实现优先级队列
4.1 有序数组实现优先级队列 - 入队列 offer(E value)
4.2 有序数组实现有序队列 - 出队列 poll()
4.3 有序数组实现有序队列 - 查看优先级最大的元素 peek()
4.4 有序数组实现优先级队列 - 判断队列是否为空
4.5 有序数组实现优先级队列 - 判断队列是否为满队列
4.6 有序数组实现优先级队列完整代码
5.0 大顶堆实现优先级队列
5.1 堆实现优先级队列 - 入队列 offer(E value)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/727b0b3a13aee2debab8a3da48f6a5d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18cb094b11ffa1e7b2b53ed742ee9060/" rel="bookmark">
			[MySQL]数据库原理1，三大范式，E-R图，DataBase，数据库管理系统（DBMS），Relationship，实体、属性、联系 映射基数，关系型数据库，联系的度数等——喵喵期末不挂科
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		希望你开心，希望你健康，希望你幸福，希望你点赞！
最后的最后，关注喵，关注喵，关注喵，佬佬会看到更多有趣的博客哦！！！
喵喵喵，你对我真的很重要！
目录
前言
认识数据库
常见的数据库管理系统应用案例。
1．数据（Data）
2．数据库（DataBase ，简称DB ）
3．数据库管理系统（DBMS） 认识关系型数据库
实体、属性、联系
绘制E-R图
关系模式的规范化
1．第一范式（1NF）
2．第二范式（2NF）
3．第三范式（3NF）
4．第二范式（2NF）和第三范式（3NF）的区别
E-R图
实体间的联系
联系（Relationship）的基本概念
联系的度数
映射基数
一对一联系(1:1)
一对多联系(1:n)
多对多联系(m:n)
E-R图
E-R图的画法
举个栗子
前言 学习数据库，一般要先学数据库原理。
将面对很多抽象难懂的概念和理论知识，如数据模型、实体、属性、联系、E-R图、关系模式和数据建模等。
初学者，会感觉原理部分特别的枯燥。
了解数据库的基本概念；
认识关系模型和关系型数据库；
认识实体和属性；
认识C/S 、B/S模式架构；
学习数据库的概念结构设计和逻辑设计方法。
学习关系模式的规范化；
绘制E-R图，建立数据库概念模型；
将E-R图转换成关系模式进行数据模型的建立
一、了解实体之间的联系
二、熟悉概念模型表示方法E-R图
三、掌握E-R图的画法
认识数据库 常见的数据库管理系统应用案例。 1．留言板。
2．进销存管理系统。
3．ERP系统。
4．图书管理系统。
1．数据（Data） 数据实际上就是描述事物的符号记录。如文字、数字、日期时间、图片、音频、视频等。
2．数据库（DataBase ，简称DB ） 数据库是长期储存在计算机内的、有组织的、可共享的数据集合。
数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。
3．数据库管理系统（DBMS） 数据库管理系统是一个负责对数据库进行数据组织、数据操纵、维护、控制以及数据保护和数据服务等的软件系统，是数据库的核心。
常用的数据库管理系统有MySQL、MS SQL Server、Oracle、DB2、Accesst和Sybase等。
认识关系型数据库 1．认识数据模型
数据模型由3部分组成：模型结构、数据操作和完整性规则。
DBMS所支持的数据模型分为三种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18cb094b11ffa1e7b2b53ed742ee9060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a86ed8a4d6739b96d5b59c20e8332e/" rel="bookmark">
			[MySQL]事务原理之redo log,undo log
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈键盘敲烂，年薪30万🌈
目录
一、log日志文件
📕 事务执行流程
📕 redo log
📕 undo log
二、总结
👀再来一遍ACID 1. 原子性：原子性确保事务作为一个整体执行，要么全部执行成功，要么全部不执行。
2. 一致性：一致性确保事务将数据库从一个状态转换为另一个状态。
3. 隔离性：隔离性确保并发执行的多个事务互相隔离。
4. 持久性：事务一旦提交，其修改将永远保存在数据库中。
一、log日志文件 📕 事务执行流程 为什么会有日志❓ 先说结论：
数据库日志的存在是为了确保事务的持久性，支持故障恢复和并发控制，并提供回滚、撤销以及备份和恢复的功能。日志记录了对数据库的操作，使得数据库系统能够有效地管理数据的修改和恢复。
确保持久性❓ 难道没有日志事务提交后可能出现数据不一致❓ 分析：
执行事务-&gt;判断内存中有无数据-&gt;（加载磁盘数据到内存）-&gt;事务提交-&gt;日志保存到磁盘
问题1：刷新数据时机？
系统会根据负载情况和性能优化的考虑来决定脏数据刷新的时机和方式。
问题2：为什么不能提交完事务，直接将Buffer Pool数据保存到磁盘文件？
我们平时操作的数据库都是随机的，也就意味着随机访问磁盘文件，这会大量占用I/O，性能很低。但是，日志是以追加的方式写入，是顺序访问磁盘文件，性能高的很。
WAL机制：
Writer - Ahead - Logging: 先记录日志在刷新脏数据
小结：
了解了事务的执行流程在看日志就比较简单了，无非就是两种记录方式。
📕 redo log 重做日志，记录事务提交时对数据页的操作，从而实现事务的持久性。 redo log buffer:内存中的数据库数据。
redo log file:磁盘中的数据库数据。
📕 undo log 又称回滚日志，用于记录被修改前的信息，作用有两个，回滚事务，MVCC。它可以保障事务的原子性
注意：
Undo log记录的数据是反向的，比如执行一条delete语句，undo log保存一条insert语句，回滚就是读取undo log中的sql语句，再比如执行update语句，undo log会保存update前的数据库状态。
Undo log销毁：事务提交后不会立刻销毁日志，因为这些日志可能用于MVCC
Undo log存储：采用段的方式进行管理和记录（这里不太懂）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6a86ed8a4d6739b96d5b59c20e8332e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3af0ce9061d4dd1f9def8a43631cf38/" rel="bookmark">
			CoPilot究竟如何使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本步骤说明 CoPilot是一款由GitHub开发的人工智能代码助手，可以提供实时代码建议和自动完成功能。下面是使用CoPilot的详细介绍：
安装：首先，你需要在你的代码编辑器中安装CoPilot插件。目前，CoPilot支持一些主流的代码编辑器，如VS Code和Atom。你可以在相应的插件商店中搜索CoPilot并进行安装。
启用：安装完成后，你需要登录你的GitHub账号，并按照CoPilot的指导进行授权，以便让CoPilot能够访问和学习GitHub上的代码库。
使用：一旦授权完成，你就可以开始使用CoPilot了。当你在编辑器中编写代码时，CoPilot会实时分析你的输入，并推荐可能的代码片段。你可以按下Tab键来接受CoPilot的建议，并将其插入到你的代码中。
自动完成：CoPilot还可以通过自动完成功能来帮助你更快地编写代码。当你键入一个字符时，CoPilot会根据已有的上下文和常见的模式来推测你要输入的内容，并提供相应的建议。你可以通过按下Tab键或Enter键来接受建议并完成输入。
反馈和训练：CoPilot是基于机器学习的，所以它的建议可能不总是完美的。如果你认为CoPilot的建议不合适或有错误，你可以提供反馈，以帮助它改进。另外，CoPilot还可以通过你的输入进行训练，从而提供更准确的建议。
总之，CoPilot是一款功能强大的代码助手，可以帮助你更快地编写代码并提供实时的代码建议。然而，它并不是一个完全替代人工编程的工具，你仍然需要自己进行代码的理解和调试。
具体开发示例1 GitHub Copilot是一个由GitHub和OpenAI合作开发的人工智能编码助手。它使用机器学习模型，能够为开发人员提供代码补全、建议和片段，从而加速编写代码的过程。
使用GitHub Copilot时，你需要在支持的编辑器或集成开发环境（IDE）中安装相应的插件。目前，它支持一些流行的开发环境，如Visual Studio Code（VS Code）等。
下面是一些使用GitHub Copilot的基本方法：
1. 安装 GitHub Copilot 插件 打开你的编辑器或IDE（例如 VS Code）。在插件商店或扩展商店中搜索并安装 "GitHub Copilot" 插件。 2. 登录 GitHub 账户 确保你已经登录了你的 GitHub 账户。有时候，GitHub Copilot可能需要你的 GitHub 账户来提供更准确的代码建议。 3. 编写代码并使用 Copilot 打开一个项目或文件开始编写代码。当你编写代码时，GitHub Copilot会显示代码建议。这些建议通常是基于你当前正在编写的上下文。接受 Copilot 的建议：使用 Tab 键或其他指定的快捷键接受 Copilot 提供的建议。 4. 给予反馈 在使用 Copilot 的过程中，你可以通过给予反馈来改善它的准确性。这种反馈可以帮助 Copilot 学习和提高其代码生成的质量。 示例 例如，在编写代码时，你可能会输入一些描述性的注释或函数名，然后 Copilot 将会根据你的上下文生成可能的代码建议。你可以通过按 Tab 键或其他指定的快捷键来接受其中一个建议，从而快速生成代码片段。
# 举例：编写一个简单的 Python 函数并利用 Copilot 的建议 # 输入注释描述函数的功能 # 并在函数名称下方输入基本的框架 def calculate_square_area(side_length): # Copilot 根据函数名和参数，提供可能的代码建议 # 比如，它可以自动生成计算正方形面积的代码 area = side_length * side_length return area 请记住，GitHub Copilot仍然在不断地学习和改进中，因此它的准确性可能因时间而异。此外，遵循最佳的安全实践和代码质量标准，仍然是开发的关键部分。因此，即使使用 Copilot，也要审查并确保生成的代码符合项目的要求和标准。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3af0ce9061d4dd1f9def8a43631cf38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9ba93e11ed2f2888ffd22da505290a/" rel="bookmark">
			mac切换node版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 上切换 node 版本总结
背景
在做项目的时候，往往会遇到老项目没有升级的问题，node环境版本比较低，自己电脑安装或者新项目安装了最新版本的 node 环境，那么既要支持老版本的使用也要支持新版本那么怎么办呢？
Mac 提供了切换node版本的办法
nvm n 首先介绍 nvm nvm 安装 brew install nvm 安装成功之后，还不能直接使用nvm命令，需要进行以下配置，将以下命令复制到终端执行： echo "source $(brew --prefix nvm)/nvm.sh" &gt;&gt; .bash_profile 修改之后，需要重新定向来源，复制以下命令并执行： . ~/.bash_profile 通过 nvm ls-remote 查看 node 所有版本 v16.7.0 v16.8.0 v16.9.0 v16.9.1 v16.10.0 v16.11.0 v16.11.1 v16.12.0 v16.13.0 (LTS: Gallium) v16.13.1 (Latest LTS: Gallium) // 当前稳定版本 v17.0.0 v17.0.1 v17.1.0 v17.2.0 v17.3.0 nvm install xx.xx.xx (版本号) 安装指定版本 node nvm install 17.3.0 安装成功后 nvm ls 可以查看已经安装到本地的node版本 nvm ls nvm use node 使用本地最新node环境 nvm use 17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da9ba93e11ed2f2888ffd22da505290a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078294469bde3b4bd8334b391bd49eb9/" rel="bookmark">
			Mac 中文版 Navicat Premium 16 下载安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽朋友们大家好，今天做一期 Mac 数据库连接工具 Navicat Premium 16 的安装教程，很多朋友不知道怎么安装的，要不就是有试用期无法正常使用，要不就是英文的，改不了中文，大家可以跟着我的步骤安装，简单又好用
先上图，成功安装而且已汉化：
安装教程 1、首先我们先下载汉化过的安装包，下载后直接打开即可
➤ Navicat Premium 16 汉化安装包
打开该安装包以后，我们直接将左侧的 Navicat Premium 拖拽到右侧文件夹中即可（已经安装过该软件的点击替换就行了，数据库中的数据都会保留的）
2、然后我们在启动台运行 Navicat Premium，大多数可以直接正常启动了，该版本是直接汉化过的，安装后就是汉化了的，可直接使用
3、如果你运行时，显示该软件已损坏等，我们回到刚刚的安装程序，启动软件损坏修复引导程序，按照步骤引导操作即可
然后我们修复后，再次重新启动该软件，就能正常运行了，是不是非常的简单那，好了今天的数据库教程就到这里了，感谢大家的阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad57194cc022e4a7630ba3c913d47d1/" rel="bookmark">
			【腾讯云云上实验室】向量数据库与数据挖掘分析的黄金组合指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在当今信息化时代，掌握对数据进行挖掘和分析的能力变得愈发关键。根据需求精准处理数据不仅仅是一项技能，更是对未来决策和操作的至关重要的支持。除了熟练运用适当的算法模型对大数据进行挖掘和分析外，合理高效存储和处理大量数据，对开发者和企业来说变得越来越重要。
文章目录 一、走近腾讯云向量数据库二、助力数据收集和处理三、数据挖掘和分析使用指南1. 准备工作2. 数据操作演示（平台端）3. 数据操作演示（SDK接入）4. 以汽车相关数据进行分析预测 四、向量数据库为大数据时代注入智慧五、总结 前几天，和往常一样下班后回家打开电脑学一会，偶然机会看到了腾讯云刚发布的向量数据库体验活动，刚好最近手头的工作也忙完了，于是下意识也报名申请了一个体验名额。在体验使用的时候，也融入了一些对数据进行分析和挖掘的算法。 整体使用感觉也非常棒，经过这几天的整理和总结，能够帮助不了解或者没使用过的小伙伴快速熟悉并且有一定的上手。（腾讯云向量数据库:感兴趣的小伙伴可以去申请名额体验)
一、走近腾讯云向量数据库 看到向量数据库你可能会想到数据库，但是它和传统数据库相比有鲜明的优点。可能有不少朋友在平常工作或者生活中，或多或少都接触过一些关于向量数据库的消息，作为一个全能的程序员，除了关注底层的逻辑外，清晰明了向量数据库发展的方向和未来趋势，能否抓住这个在发展风口机会。我们还需要去了解，让我来以腾讯云向量数据库为例给你讲讲吧。
随着AI技术的快速发展，越来越多的公司和企业开始重视底层数据的合作探索。在将大型模型应用于实际场景中，数据处理和挖掘变得至关重要。向量数据库作为支撑大型模型的关键基础设施，将在个人、企业和社交媒体等领域发挥越来越重要的作用。
总的来说：向量数据库的优势在于高效的向量相似性搜索、高维数据处理、特定索引结构、异构数据类型支持，适用于机器学习和深度学习、大规模数据处理，提供实时性能。选择使用向量数据库应基于应用需求和性能评估。
二、助力数据收集和处理 每天，每个人都面临来自各个渠道的数千条信息。而对于开发者和企业用户而言，每天需要处理的信息量更是以万计甚至千亿计。信息的接收和处理成为一个极具挑战性的任务。。
往往让开发者和企业在处理数据方面头疼的问题不外乎：
1. 如何适应业务数据快速变化的需求？
2. 如何保障数据安全？
3. 如何实现业务系统对高实时响应的要求？
4. 如何在多样化的销售和服务场景中？
腾讯云向量数据库由于其卓越的稳定性、性能、易用性和便捷的运维，都展现出了显著优势，能够提供高效稳定的服务。
高性能： 向量数据库单索引支持10亿级向量数据规模，可支持百万级 QPS 及毫秒级查询延迟。高可用： 向量数据库提供多副本高可用特性，其多可用区和三节点的架构可用性可达99.99%，显著提高系统的可靠性和容错性：确保数据库在面临节点故障和负载变化等挑战时仍能正常运行。大规模： 向量数据库架构支持水平扩展，单实例可支持百万级 QPS，轻松满足 AI 场景下的向量存储与检索需求。低成本： 只需在管理控制台按照指引，简单操作几个步骤，即可快速创建向量数据库实例，全流程平台托管，无需进行任何安装、部署和运维操作，有效减少机器成本、运维成本和人力成本开销。简单易用： 支持丰富的向量检索能力，用户通过 HTTP API 接口即可快速操作数据库，开发效率高。同时控制台提供了完善的数据管理和监控能力，操作简单便捷。稳定可靠： 向量数据库源自腾讯集团自研的向量检索引擎 OLAMA，近40个业务线上稳定运行，日均处理的搜索请求高达千亿次，服务连续性、稳定性有保障。 三、数据挖掘和分析使用指南 1. 准备工作 首先我们需要去申请一台向量数据库 腾讯云向量数据库申请 ，登录进入后，点击新建。如图，是已经构建好的向量数据库
配置向量数据库实例相关信息创建好向量数据库后，可以查看相关的配置信息，包括内网外网访问地址，以及密钥信息创建好向量数据库后，点击登录，来到向量数据库登录界面，如图需要账号和密码账号默认是root，密码是向量数据库配置中的密钥登录进去后，可以看到先向量数据库管理模块和数据操作模块。管理模块可以创建向量数据库，管理集合。数据操作模块可以进行精确、相似度查询、插入/替换、更新、删除数据。 2. 数据操作演示（平台端） 腾讯云向量数据库支持多种方式操作向量数据库，包括：使用平台数据操作模块操作，或者接入Python，Java以及HttpAPI来进行操作，在这里我演示一下平台数据操作和接入Python的SDK使用。
1.插入/更新 参数数据 支持以json格式插入数据
2.精确查询 参数支持以 表单和JSON两种格式根据不同情况（包括：主键和条件进行查询)
3.相似度查询 可以根据不同格式进行检索，同时也支持条件查询和主键查询，这一步会检索出结果有相似程度的数据
4.删除数据 可以根据条件查询删除，同时也可以根据主键去删除
3. 数据操作演示（SDK接入） 1.官方提供了多种接入方式，在这里我以Python为例子，进行接入 腾讯云向量数据库API文档
2.以Python为例，本地连接远程向量数据库
首先需要导入依赖：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad57194cc022e4a7630ba3c913d47d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16b716ed06f78a6f80fdb36607e56bfb/" rel="bookmark">
			AndroidStudio运行Flutter时卡在Running ‘gradle assembleDebug...‘问题解决[2023-12-13更新]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 最近由于项目需要，开始学习Flutter框架和Dart语言，具体的配置步骤强烈推荐这篇博客，写得非常好:【window10】Dart+Android Studio+Flutter安装及运行
按照这篇博客设置完Flutter和Dart的环境后，我开启AndroidStudio的虚拟移动设备，尝试运行官方给的Dart示例代码
结果就见运行输出那边一直卡在Running Gradle task 'assembleDebug'...：
然后查询资料发现，运行Flutter貌似需要外网环境，没有外网的话会卡在这非常久......
还有一些人给出了一些解决方案，有的有用，有的没用，最后我把他们的方法都中和了一下成功了 ，下面介绍一下我的解决方法，先声明很多地方我也不知道为什么这么设置，我不是学计算机的，会的不多，步骤仅供参考。 2.设置步骤 大部分步骤参考这篇博客，我在他的基础上又遇到了很多报错，逐一解决后就成功了:Flutter卡在Running ‘gradle assembleDebug‘最完整解决
2.1 设置准备 准备一个可以完成编译和运行的Android项目（简称项目A）打开你的Flutter项目（简称项目B）Flutter的安装目录 2.2 步骤1-查看项目A的gradle-wrapper.properties 打开A项目的Gradle Scripts/gradle-wrapper.properties，记住里面的gradle版本号:
2.3 步骤2-修改项目B的gradle-wrapper.properties 打开项目B，打开项目目录下的\android\gradle\wrapper\gradle-wrapper.properties：
如上图将distributionUrl这一项替换为腾讯的镜像源:
distributionUrl=https://mirrors.cloud.tencent.com/gradle/gradle-8.0-bin.zip 注意将'gradle-8.0-bin.zip'替换为你刚才在项目A记录的gradle版本号
接着打开项目目录下的\android\build.gradle：
如上图在buildscript{...}和allprojects{...}中添加如下代码：
注意我添加的maven代码与参考文章中的不一样！
maven { url 'https://maven.aliyun.com/repository/google' } maven { url 'https://maven.aliyun.com/repository/jcenter' } maven { allowInsecureProtocol = true url 'https://maven.aliyun.com/nexus/content/groups/public' } 注意要将该段代码添加在google()和mavenCentral()之前：
2.4 步骤3-gradlew指令执行 在AndroidStudio打开项目B，新建终端，依次输入：
cd android ./gradlew clean ./gradlew build 注意上面的命令如果提示 .不是有效命令 ，去除./即可
这里比较难搞的地方来了，如果正常的就会显示：
但是我这边并没有成功，而是显示BULID FAILED，接下来我把我遇到的错误写出来，供大家参考。
3.错误解决 3.1 错误1-BUG! exception in phase 'semantic analysis' 经查询这是JDK版本过高导致Gradle不兼容的问题，这里提供官方提供的jdk版本与gradle的兼容版本：java与gradle兼容版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16b716ed06f78a6f80fdb36607e56bfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f67ea51a1609dc8ac4714ef0ecb9236/" rel="bookmark">
			【语义分割】12个主流算法架构介绍、数据集推荐、总结、挑战和未来发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 语义分割是将图像中的每个像素按其语义类别进行分类，从而实现像素级别的语义理解。其在自动驾驶、医学图像、结构损伤检测等领域有着广泛的应用。
1.主流算法架构 1.1 U-Net 论文地址：https://arxiv.org/abs/1505.04597
U-Net2015年由Ronneberger等人提出,是经典的编码-解码架构。其中编码器部分利用卷积层和池化层逐步提取输入图像的特征，获取输入图像特征的潜在表示。解码器部分使用转置卷积和卷积从编码器的各级分辨率级别还原目标的细节特征。U-Net因其结构简单、易于训练和有效性而受到青睐，同时也为图像分割任务提供了一个强大的基准模型。
1.2 SegNet 论文地址：https://arxiv.org/abs/1511.00561
SegNet是2016年由Cambridge提出旨在解决自动驾驶的图像语义分割深度网络。SegNet与U-Net网络类似，主要的区别在于SegNet提出了记录池化的位置，反池化时恢复。SegNet在解码恢复信息时不再和编码器对应的分辨率级别进行拼接操作，而是直接进行转置卷积。
1.3 PSPNet 论文地址：https://arxiv.org/pdf/1612.01105.pdf
PSPNet是2017年提出的一种用于语义分割的深度卷积神经网络。其架构的主要特点是金字塔池化模块（Pyramid Pooling Module）。PSPNet最大的创新是引入金字塔池化模块，通过不同尺度的池化操作获得全局和局部信息。输入特征图被分割为不同大小的区域，并进行池化操作以提取每个区域的特征。不同池化尺度下的特征被级联在一起，形成了一个更加丰富和多样的特征表示。
1.4 UNet++ 论文：https://arxiv.org/pdf/1807.10165.pdf
Unet++于2018年提出，Unet++继承了Unet的结构，同时又借鉴了DenseNet的稠密连接方式。其主要有四个结构特点：
（1）密集连接的多级UNet结构：UNet++采用了分层的、多级的UNet结构。每个UNet++模块都由一个编码器和多个解码器组成。每个解码器的特征图与上一级解码器的所有特征图相连接，形成了一种密集连接的结构，有助于更好地传递和利用不同层级的信息。
（2）嵌套连接与跳跃连接：UNet++结构通过嵌套连接将不同分辨率的特征图相互连接，以多层级方式传递信息。跳跃连接也被保留在不同层次，使得不同分辨率的信息可以更有效地在编码器和解码器之间传递。
（3）特征重组和特征融合：每个UNet++模块内部，通过特征重组和特征融合操作，将不同分辨率和不同层级的特征图结合起来，增强了特征表达的多样性和丰富性。
（4）多尺度特征提取：UNet++在编码器和解码器中都包含了多尺度特征提取模块，有助于捕获不同尺度下的语义信息。
1.5 DeepLabv3+ 论文：https://arxiv.org/pdf/1802.02611v3.pdf
DeepLabv3+是由Google于2018年提出的图像语义分割模型，旨在解决语义分割任务中的精度和效率问题。它是DeepLab系列模型的最新版本，结合了深度卷积网络和空洞卷积网络的优势，并引入了空间金字塔池化模块(ASPP)和解码器模块，利用多尺度信息增强模型的性能，有助于解决对象尺度不一致的问题。
DeepLabv3+整体来说也是一个编码-解码架构，其中编码器中的DCNN是可以按照具体任务需求修改的backbone。举例来说，DCNN可以是高效轻便的MobileNet、EfficientNet，也可以是深度残差网络ResNet，也可以是经典的Xception、Inception等网络。具体的架构方案需要根据当前的任务做具体的设计和调整。
1.6 HRNet 论文：https://arxiv.org/pdf/1904.04514.pdf
HRNet于2019年提出，作者通过通过聚合来自所有并行卷积的（上采样的）表示来增强高分辨率表示，而不是仅聚合来自高分辨率卷积的表示。这种架构设计模式是模型有更强的表征能力。其架构的主要特点如下：
（1）多分辨率特征金字塔：HRNet在网络的不同分支中保持多个分辨率的特征图，同时通过高分辨率和低分辨率的交互，保留了更多的细节信息。通过多个分支，每个分支都以不同的分辨率来处理输入图像，然后进行特征融合，以综合不同分辨率的信息。
（2）多层级信息融合：HRNet内部进行多层级的信息融合，使得不同分辨率特征图之间可以相互交流和融合，充分利用不同分辨率的特征。
（3）高分辨率信息保留：通过保留高分辨率特征图，HRNet在姿态估计和图像分割任务中能够更好地捕获和利用细节信息，避免了传统网络中由于下采样导致的低分辨率特征损失问题。
（4）通道交流：HRNet在不同分辨率特征图之间引入了通道交流（channel fusion），使得不同分辨率的特征图可以相互交流和融合，提高了特征的丰富性和表达能力。
1.7 U2Net U2Net于2020年发表于CVPR。U2Net的主体是一个两层嵌套的U型结构，网络中的每个编码器和解码器模块也是类似UNet的结构，也就是在大的UNet中嵌入了一堆小UNet。其架构的主要特点如下：
（1）ReSidual U块（RSU）中混合了不同大小的感受野，它能够从不同的尺度捕获更多的上下文信息。
（2）RSU块中使用了池化操作，它增加了整个架构的深度，而不显著增加计算成本。这种架构使得使用者能够从头开始训练深度网络，而无需使用图像分类任务中的主干（backbone）。
1.8 HRNet-OCR 论文：https://arxiv.org/pdf/1909.11065.pdf
HRNet-OCR于2021年提出，它在HRNet的基础上，进一步引入了OCR Object-Contextual Representations）机制。这种OCR机制是一种简单而有效的对象上下文表示方法，帮助网络更好地理解图像中不同对象之间的关系和上下文信息。OCR模块在每个HRNet分支上引入了空间注意力机制（Spatial Attention）和对象级别的上下文信息建模。空间注意力机制有助于网络学习不同区域的重要性，对象级别的上下文信息帮助网络更好地理解对象之间的联系。
1.9 SETR 论文地址：https://arxiv.org/pdf/2012.15840.pdf
SETR于2021年提出，是基于ViT来进行语义分割的第一个代表模型。它提出以纯Transformer结构的编码器来代替CNN编码器，改变现有的语义分割模型架构。其架构的主要特点如下：（1）Image to sequence 图像序列化方法：作者参考了ViT的做法，即对输入图像进行切片处理，将每一个2D的图像切片（patch）视为一个“1D”的序列作为整体输入到网络当中。（2）Transformer: 通过将序列输入到Transformer架构可进行特征的提取，其主要包含两个部分Multi-head Self-Attention (MSA) and Multilayer Perceptron (MLP) blocks。（3）解码：作者给出了三种解码上采样方式，即朴素上采样、渐进上采样、多级特征融合（类似于特征金字塔）。
1.10 SegFormer 论文地址：https://arxiv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f67ea51a1609dc8ac4714ef0ecb9236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55afc79c5a18e9c55d3a65b88e8c16b/" rel="bookmark">
			ELADMIN - 免费开源 admin 后台管理系统，基于 Spring Boot 和 Vue ，包含前端和后端源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一款简单好用、功能强大的 admin 管理系统，包含前端和后端源码，分享给大家。
ELADMIN 是一款基于 Spring Boot、Jpa 或 Mybatis-Plus、 Spring Security、Redis、Vue 的前后端分离的后台管理系统。
ELADMIN 的作者在 Github 和 Gitee 上看了很多的项目，发现大多数都是基于 Mybatis ， 而基于 Spring Boot Jpa 的很少，于是就产生了开发 ELADMIN 的想法。不过后来考虑到国内开发业务比较复杂，很多项目都使用 Mybatis ，ELADMIN 也同步发布了 Mybatis-Plus 的版本。
ELADMIN 目前最新版是基于 Spring Boot 2.6.4 、 Spring Boot Jpa、 JWT、Spring Security、Redis、Vue、Element UI 的前后端分离的后台管理系统， 项目采用按功能分模块的开发方式，权限控制采用 RBAC 思想，支持数据字典与数据权限管理，支持一键生成前后端代码，支持前端菜单动态路由等。
需要注意的是，和之前分享的很多 admin 管理后台的前端项目不同，这是一个包含 web 前端和 Spring Boot 后端开发源码的项目，适合使用该技术选型的开发者或者是公司团队使用。
使用最新技术栈，社区资源丰富；
高效率开发，代码生成器可一键生成前后端代码；
支持数据字典，可方便地对一些状态进行管理；
支持接口限流，避免恶意请求导致服务层压力过大；
支持接口级别的功能权限与数据权限，可自定义操作；
自定义权限注解与匿名接口注解，可快速对接口拦截与放行；
对一些常用地前端组件封装：表格数据请求、数据字典等；
前后端统一异常拦截处理，统一输出异常，避免繁琐的判断；
支持在线用户管理与服务器性能监控，支持限制单用户登录；
支持运维管理，可方便地对远程服务器的应用进行部署与管理。
用户管理：提供用户的相关配置，新增用户后，默认密码为 123456
角色管理：对权限与菜单进行分配，可根据部门设置角色的数据权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a55afc79c5a18e9c55d3a65b88e8c16b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95e1118f703dbd724a16c217cf1879c/" rel="bookmark">
			Python中栈的概念和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、栈的概念
三、栈的使用
1、创建栈
2、入栈操作
3、出栈操作
4、查看栈顶元素
5、判断栈是否为空
四、应用场景
1、函数调用
2、表达式求值
3、深度优先搜索
4、括号匹配
五、总结
一、引言 栈是一种重要的数据结构，它遵循后进先出（LIFO）的原则。在Python中，栈可以通过内置的list类型实现，也可以使用collections模块中的deque类型来实现。栈在计算机科学和编程中有着广泛的应用，如函数调用、表达式求值、深度优先搜索等。本文将详细介绍Python中栈的概念、使用方法以及应用场景。
二、栈的概念 栈是一种数据结构，它按照后进先出（LIFO）的原则对元素进行存储和访问。栈中的元素只能从一端（称为栈顶）添加或删除。这种特性使得栈在某些情况下非常有用，例如在实现函数调用、表达式求值等功能时。
在Python中，可以使用列表（list）实现栈。由于列表具有动态大小的特点，因此非常适合用于实现栈这种需要动态添加和删除元素的数据结构。
三、栈的使用 1、创建栈 在Python中，可以使用列表（list）创建栈。例如，以下代码创建一个空栈：
stack = []
2、入栈操作 入栈操作是指将元素添加到栈顶。在Python中，可以使用列表的append()方法实现入栈操作。例如，以下代码将元素1添加到栈中：
stack.append(1)
3、出栈操作 出栈操作是指从栈顶删除元素。在Python中，可以使用列表的pop()方法实现出栈操作。例如，以下代码从栈中删除并返回栈顶元素：
top_element = stack.pop()
4、查看栈顶元素 查看栈顶元素是指获取栈顶元素但不删除它。在Python中，可以使用列表的[-1]索引来获取栈顶元素。例如，以下代码查看并打印栈顶元素：
top_element = stack[-1] print(top_element) 5、判断栈是否为空 判断栈是否为空是指检查栈是否为空。在Python中，可以使用列表的len()方法来检查栈的大小。例如，以下代码检查并打印栈是否为空：
is_empty = len(stack) == 0 print(is_empty) 四、应用场景 1、函数调用 在函数调用过程中，可以使用栈来保存函数的局部变量和参数。当函数被调用时，将参数和局部变量压入栈中；当函数返回时，从栈中弹出参数和局部变量。这样就可以保证函数调用的正确性和可重复性。例如：
def add(a, b): return a + b stack = [] stack.append(2) stack.append(3) result = add(*stack) # 使用*运算符将栈中的元素作为参数传递给add函数 print(result) # 输出5 2、表达式求值 在表达式求值过程中，可以使用栈来保存操作数和运算符。当遇到操作数时，将其压入栈中；当遇到运算符时，从栈中弹出操作数进行计算，并将结果压入栈中。这样就可以按照后进先出的原则对表达式进行求值。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95e1118f703dbd724a16c217cf1879c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53972b0c1b2ec2c682d90c82bf33774e/" rel="bookmark">
			python中异常值的检测和处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 通常，咱们做数据挖掘的时候经常免不了会遇到异常值检测或者异常值处理等步骤，那么什么是异常值呢？如何检测数据中是否存在异常值？如何处理数据中的异常值？本文专门探究一下这些问题。
异常值又称离群点，是指那些在数据集中存在的不合理的值，需要注意的是，不合理的值是偏离正常范围的值，不是错误值。
异常值出现的原因：数据集中的异常值可能是由于传感器故障、人工录入错误或异常事件导致。
一、异常值的检测 异常值的检测通常有简单统计分析、3σ原则、箱型图、聚类等方法，以下详细对各个方法进行逐一说明。
1.1 简单统计分析 最常用的统计量是最大值和最小值，用来判断这个变量的取值是否超出合理的范围。在pandas中，一般使用describ属性就可以查看相关的统计量。
# 全国房价数据统计 df_dropna = df[~df.price.isna()].reset_index(drop=True) # 首先剔除NA值 df_dropna.price.describe() 1.2 3σ原则（Z-score Method） 3σ原则的前提假设是数据集符合正态分布（高斯分布），如下图：
观察上图容易得出以下数据分布情况：
数值分布在区间（μ-σ, μ+σ）中的概率为 0.6826数值分布在区间（μ-2σ, μ+2σ）中的概率为 0.9545数值分布在区间（μ-3σ, μ+3σ）中的概率为 0.9973 可以认为，数据存在随机误差，其取值几乎全部集中在（μ-3σ, μ+3σ）区间内，超出这个范围的可能性仅占不到0.3%，那么误差超过这个区间的值就识别为异常值了。
实际上，大部分真实的数据并不满足这一条件，我们就需要先对原始数据集进行Z-score变换，使用原始数据的均值（μ）和标准差（σ）进行数据的标准化。经过处理的数据也将服从标准正态分布，其均值为0，标准差为1，故3σ原则又被称为Z-score method。
Z = x − μ σ Z = \frac{x-μ}{σ} Z=σx−μ​
经过Z-score标准化后得到符合正态分布的数据，我们就可以使用3σ原则来处理数据了。演示代码如下：
# 观察原始房价数据分布情况 import matplotlib.pyplot as plt s = df_dropna.price fig = plt.figure(figsize=(6, 6)) # 创建自定义图像 ax1 = fig.add_subplot(2,1,1) # 创建子图1 ax1.scatter(s.index, s.values) # 绘制散点图 plt.grid() # 添加网格 ax2 = fig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53972b0c1b2ec2c682d90c82bf33774e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26026f28709b385d6b96e13ceeb74b4/" rel="bookmark">
			Nginx: [emerg] the “ssl“ parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现上面标题中的问题是因为我当初在安装Nginx的时候没有安装SSL模块，但是现在我在Nginx配置文件(nginx.cnf)中配置了SSL的相关配置信息。当我再次启动Nginx的时候就提示我nginx: [emerg] the "ssl" parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf:111 了。下面我将我的解决方案给记录了下来，供大家参考哦！
出现上面标题中的问题是因为我当初在安装Nginx的时候没有安装SSL模块，但是现在我在Nginx配置文件(nginx.cnf)中配置了SSL的相关配置信息。当我再次启动Nginx的时候就提示我nginx: [emerg] the "ssl" parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf:111 了。下面我将我的解决方案给记录了下来，供大家参考哦！
1、查看Nginx 的版本 [root@xxx ~]# /usr/local/nginx/sbin/nginx -V nginx version: nginx/1.16.1 ... configure arguments: 可以看到，我这里的configure arguments: 后面没有任何配置参数。
我们现在切换到源码包目录下面，增加SSL配置项进行重新编译：
# 切换到Nginx源码目录下面： [root@xxx ~]# cd /usr/local/nginx/ # 新增SSL模块进行重新配置： [root@xxx nginx]# ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module # 重新编译： [root@xxx nginx]# make 注意：这里不在需要执行make install命令了，如果执行了会覆盖之前的安装，会有一定的风险哦！
2、具体操作 （1）备份原有已安装好的 nginx : [root@xxx nginx]# cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak （2）停止现有的 Nginx 服务： [root@xxx ~]# /usr/local/nginx/sbin/nginx -s stop （3）将刚刚编译好的 nginx 覆盖掉原有的 nginx，刚才重新编译好的nginx在/usr/local/nginx/objs/ 下面。 [root@xxx ~]# cp .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d26026f28709b385d6b96e13ceeb74b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a246f3d08f11414ba961c447ab9bce9e/" rel="bookmark">
			LangChain 27 AI Agents角色扮演多轮对话解决问题CAMEL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LangChain系列文章
LangChain 实现给动物取名字，LangChain 2模块化prompt template并用streamlit生成网站 实现给动物取名字LangChain 3使用Agent访问Wikipedia和llm-math计算狗的平均年龄LangChain 4用向量数据库Faiss存储，读取YouTube的视频文本搜索Indexes for information retrieveLangChain 5易速鲜花内部问答系统LangChain 6根据图片生成推广文案HuggingFace中的image-caption模型LangChain 7 文本模型TextLangChain和聊天模型ChatLangChainLangChain 8 模型Model I/O：输入提示、调用模型、解析输出LangChain 9 模型Model I/O 聊天提示词ChatPromptTemplate, 少量样本提示词FewShotPromptLangChain 10思维链Chain of Thought一步一步的思考 think step by stepLangChain 11实现思维树Implementing the Tree of Thoughts in LangChain’s ChainLangChain 12调用模型HuggingFace中的Llama2和Google Flan t5LangChain 13输出解析Output Parsers 自动修复解析器LangChain 14 SequencialChain链接不同的组件LangChain 15根据问题自动路由Router Chain确定用户的意图LangChain 16 通过Memory记住历史对话的内容LangChain 17 LangSmith调试、测试、评估和监视基于任何LLM框架构建的链和智能代理LangChain 18 LangSmith监控评估Agent并创建对应的数据库LangChain 19 Agents Reason+Action自定义agent处理OpenAI的计算缺陷LangChain 20 Agents调用google搜索API搜索市场价格 Reason Action：在语言模型中协同推理和行动LangChain 21 Agents自问自答与搜索 Self-ask with searchLangChain 22 LangServe用于一键部署LangChain应用程序LangChain 23 Agents中的Tools用于增强和扩展智能代理agent的功能LangChain 24 对本地文档的搜索RAG检索增强生成Retrieval-augmented generationLangChain 25: SQL Agent通过自然语言查询数据库sqliteLangChain 26: 回调函数callbacks打印prompt verbose调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a246f3d08f11414ba961c447ab9bce9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f2ade3dc77363331c5edf7c5b5f264/" rel="bookmark">
			头歌——HBase 开发：使用Java操作HBase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：创建表 题目 任务描述 本关任务：使用Java代码在HBase中创建表。
相关知识 为了完成本关任务，你需要掌握：1.如何使用Java连接HBase数据库，2.如何使用Java代码在HBase中创建表。
如何使用Java连接HBase数据库 Java连接HBase需要两个类：
HBaseConfigurationConnectionFactory HBaseConfiguration 要连接HBase我们首先需要创建Configuration对象，这个对象我们需要通过HBaseConfiguration（HBase配置）对象来进行创建，HBaseConfiguration看名字我们就能猜到它的用途：读取指定路径下hbase-site.xml和hbase-default.xml的配置信息。
具体用法：
Configuration config = HBaseConfiguration.create(); //使用create()静态方法就可以得到Configuration对象 ConnectionFactory 获取到连接对象Connextion我们就算连接上了HBase了，怎么获取呢？
通过ConnectionFactory（连接工厂）的方法我们就能获取到Connection（连接对象）了。
具体用法：
Connection connection = ConnectionFactory.createConnection(config); //config为前文的配置对象 使用这两个步骤就能完成连接HBase了。
注意：在1.0之前的版本HBase是使用HBaseAdmin和HTable等来操作HBase的，但是在1.0之后的版本中这些被弃用了，新的客户端API更加干净简洁，本文使用的HBase是2.1.1版本（18年10月发布）的，
创建表 要创建表我们需要首先创建一个Admin对象，然后让它来创建一张表：
Admin admin = connection.getAdmin(); //使用连接对象获取Admin对象TableName tableName = TableName.valueOf("test");//定义表名HTableDescriptor htd = new HTableDescriptor(tableName);//定义表对象HColumnDescriptor hcd = new HColumnDescriptor("data");//定义列族对象htd.addFamily(hcd); //添加admin.createTable(htd);//创建表 HBase2.X创建表 上述创建表的方法是HBase1.X版本的方式，而在HBase2.X的版本中创建表使用了新的API，创建表关键代码如下：
TableName tableName = TableName.valueOf("test");//定义表名//TableDescriptor对象通过TableDescriptorBuilder构建；TableDescriptorBuilder tableDescriptor = TableDescriptorBuilder.newBuilder(tableName);ColumnFamilyDescriptor family = ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes("data")).build();//构建列族对象tableDescriptor.setColumnFamily(family);//设置列族admin.createTable(tableDescriptor.build());//创建表 在2.X版本中主要是HTableDescriptor对象被弃用，取而代之的是TableDescriptor对象，TableDescriptor对象通过TableDescriptorBuilder构建；
TableName tableName = TableName.valueOf("test");TableDescriptorBuilder tableDescriptor = TableDescriptorBuilder.newBuilder(tableName); 然后添加列簇方法变更：
ColumnFamilyDescriptor family = ColumnFamilyDescriptorBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f2ade3dc77363331c5edf7c5b5f264/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b0db489bf2addc2da2d2c60b67c454/" rel="bookmark">
			Python-5个有趣的小程序【每一个都附完整源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：樱花树 运行效果：
完整代码如下：
import turtle import random from turtle import * from time import sleep # 画樱花的躯干(60,t) def tree(branchLen,t): sleep(0.0005) if branchLen &gt;3: if 8&lt;= branchLen &lt;=12: if random.randint(0,2) == 0: t.color('snow') # 白 else: t.color('lightcoral') # 淡珊瑚色 t.pensize(branchLen / 3) elif branchLen &lt;8: if random.randint(0,1) == 0: t.color('snow') else: t.color('lightcoral') # 淡珊瑚色 t.pensize(branchLen / 2) else: t.color('sienna') # 赭(zhě)色 t.pensize(branchLen / 10) # 6 t.forward(branchLen) a = 1.5 * random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b0db489bf2addc2da2d2c60b67c454/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0fc55cd9ebd4679acb88f7a710d0d3/" rel="bookmark">
			排序算法-快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.快速排序（递归） 快速排序是 Hoare 于 1962 年提出的一种二叉树结构的交换排序方法，其基本思想为： 任取待排序元素序列中 的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右 子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止 。 void QuickSort(int* a, int begin, int end) { if (begin &gt;= end) return; int keyi = PartSort3(a, begin, end); //[begin,keyi-1]keyi[keyi+1,end] QuickSort(a, begin, keyi - 1); QuickSort(a, keyi + 1, end); } 上述为快速排序递归实现的主框架，发现与二叉树前序遍历规则非常像，同学们在写递归框架时可想想二叉 树前序遍历规则即可快速写出来，后序只需分析如何按照基准值来对区间中数据进行划分的方式即可。 将区间按照基准值划分为左右两半部分的常见方式有： 1. hoare 版本 2. 挖坑法 3. 前后指针版本 我来给大家讲解一下前后指针版本，因为这个代码简洁，但是不太好理解。 首先创建一个变量keyi保存left的值keyi=left，然后创建后指针prev开始也是在left位置prev=left，前指针cur在prev前一个位置cur=prev+1，，然后写一个while循环，结束条件是cur&gt;right,意味着cur越界了，进入循环首先判断一下a[cur]和a[keyi]的大小，如果a[cur]大则再判断++prev是否等于cur，如果等于则不用交换，cur++,如果两个条件都满足则交换a[prev]和a[cur]，因为prev已经++，所以直接交换即可。循环结束之后再交换a[key]和a[prev]. cur的作用就是和prev拉开距离，然后将大于a[keyi]的值放到右边的部分，最后交换a[keyi]和a[prev]，就完成了部分排序。 int PartSort(int* a, int left, int right) { int keyi = left; int prev = left, cur = prev + 1; while (cur &lt;= right) { if (a[cur] &lt; a[keyi] &amp;&amp; (++prev) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba0fc55cd9ebd4679acb88f7a710d0d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b96282b08cb6c2707153c9241b2e12/" rel="bookmark">
			2023最新版Node.js下载安装及环境配置教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进入官网地址下载安装包
https://nodejs.org/zh-cn/download/
选择对应你系统的Node.js版本，这里我选择的是Windows系统、64位
Tips：如果想下载指定版本，点击【以往的版本】，即可选择自己想要的版本下载
二、安装程序
（1）下载完成后，双击安装包，开始安装Node.js
(2)直接点【Next】按钮，此处可根据个人需求修改安装路径，修改完毕后继续点击【Next】按钮
（3）可根据自身需求进行，此处我选择默认安装，继续点击【Next】按钮
（4）不选中，直接点击【Next】按钮
（5）点击【Install】按钮进行安装
（6）安装完毕，点击【Finish】按钮
（7）测试安装是否成功，按下【win+R】键，输入cmd，打开cmd窗口
输入：node -v // 显示node.js版本 npm -v // 显示npm版本 –成功显示版本说明安装成功
三、环境配置
（1）找到安装的目录，在安装目录下新建两个文件夹【node_global】和【node_cache】
（2）创建完毕后，使用管理员身份打开cmd命令窗口（打开方法见下方Tips），输入
①npm config set prefix “你的路径\node_global” （复制你刚刚创建的“node_global”文件夹路径）
npm config set prefix "D:\develop\Node.js\node_global" ②npm config set cache “你的路径\node_cache” （复制你刚刚创建的“node_cache”文件夹路径）
npm config set cache "D:\develop\Node.js\node_cache" Tips: 使用管理员身份运行cmd的方法 ：点击左下角【开始】菜单，在搜索区域输入“命令提示符”，然后点击【以管理员身份运行】
=或单击鼠标右键选择【以管理员身份运行】============
（3）配置环境变量
①【此电脑】-单击右键-【属性】-【高级系统设置】-【环境变量】
② 在【系统变量】中点击【新建】
变量名：NODE_PATH
变量值：C:\Program Files\nodejs\node_global\node_modules
然后你就会发现【node_global】里多出了一个【node_modules】文件夹
Tips: 如果输入变量值之后没有自动创建【node_modules】文件夹，就在【node_global】下手动创建一个【node_modules】文件夹，再复制你创建的【node_modules】文件夹的路径地址到变量值
③编辑【用户变量】中的【Path】
④将默认的 C 盘下【 AppData\Roaming\npm 】修改成 【node_global】的路径，点击确定
⑤在【系统变量】中选择【Path】点击【编辑】添加【NODE_PATH】，随后一直点击【确定】
四、测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18b96282b08cb6c2707153c9241b2e12/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/552/">«</a>
	<span class="pagination__item pagination__item--current">553/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/554/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>