<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aac5125acbf1f25f2fc03405c58b935/" rel="bookmark">
			sql中COALESCE函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL中，COALESCE函数是一个非常有用的函数，用于从其参数列表中返回第一个非NULL值。如果所有给定的参数都是NULL，那么COALESCE函数将返回NULL。这个函数可以接受多个参数，使其在处理可能出现的NULL值时非常灵活和强大。
语法 COALESCE(expression1, expression2, ..., expressionN) expression1, expression2, ..., expressionN：是COALESCE函数要检查的表达式列表。函数会从左到右评估这些表达式，返回第一个非NULL的表达式值。 使用场景 默认值设置：当你希望某个列或表达式返回一个默认值（而不是NULL）时，COALESCE可以提供这个默认值。这对于数据报告和用户界面显示特别有用，因为你可以避免显示NULL值，而是显示一个更有意义的默认值。数据清洗：在处理含有NULL值的数据时，COALESCE可以帮助你将这些NULL值转换为实际的数值或文本，便于分析和计算。条件选择：COALESCE可以用于基于数据存在性（是否为NULL）条件性地选择值。 示例 假设你有一个Employees表，其中包含员工的salary列，你想要选择一个列，显示员工的薪水，如果薪水是NULL，则显示0。
SELECT COALESCE(salary, 0) AS effective_salary FROM Employees; 这个查询通过COALESCE函数确保了effective_salary列不会包含NULL值；如果salary是NULL，则effective_salary会显示为0。
小结 COALESCE函数提供了一种简单有效的方式来处理SQL查询中的NULL值，使得数据分析和展示更加灵活和清晰。它是处理NULL值时应该考虑的首选函数之一，特别是当你需要从一组可能的NULL值中选择第一个实际存在的值时。
leetcode例题：1378. 使用唯一标识码替换员工ID 题目描述 Employees 表：
+---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | name | varchar | +---------------+---------+ 在 SQL 中，id 是这张表的主键。 这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。 EmployeeUNI 表：
+---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | unique_id | int | +---------------+---------+ 在 SQL 中，(id, unique_id) 是这张表的主键。 这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。 展示每位用户的 唯一标识码（unique ID ）；如果某位员工没有唯一标识码，使用 null 填充即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aac5125acbf1f25f2fc03405c58b935/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1753cb8a47ef0dd782f6380ff9ad98ea/" rel="bookmark">
			Android studio （一） 新建一个Android项目 编程语言为Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载Android studio 下载 Android Studio 和应用工具 - Android 开发者 | Android Developers
这里我下载的是2023年的
二、新建项目 选择如下模板。
填写项目名、项目保存位置、编程语言、最低支持Android API的版本、打包编译模式
三、报错Connection refused: no further information 报错原因：Android studio不能使用代理，否则无法下载 Gradle 相关依赖
在File -&gt; Settings 里面 关闭代理proxy
之后点击try again，如果弹出界面，就点击yes
四、报错 Plugin [id: 'com.android.application', version: '8.2.2', apply: false] was not found in any of the following sources: 在本机电脑C盘找到之前残留的gradle文件，将里面配置的代理注释掉
认识Android的项目目录结构 ，理解gradle和sdk的含义，直接上手锁屏显示，重点就是专注逻辑，视图层，使用混合开发的react native就很不错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97342fb6dd675cca5f4fd1d64ff51186/" rel="bookmark">
			PyCharm的配置及AI智能工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、虚拟环境以及本地环境(重要)
2、PyCharm的配置及使用
1、基础设置
2、常用快捷键
3、方法中快速注释参数
4、.py文件模板
3、AI智能编码辅助
分享一下最近使用pycharm的一些心得，以及收集的一些资料
1、虚拟环境以及本地环境(重要) PyCharm 中的虚拟环境（Virtual Environment）和本地环境（Local Environment）在 Python 开发中有以下主要区别：
隔离性：
本地环境：通常指的是全局Python环境，即系统安装的那个Python解释器及其相关的库。所有项目都共享这个环境中的第三方包。虚拟环境：为每个项目单独创建一个独立的Python环境，其中包含特定于该项目的Python解释器和第三方库。不同项目之间的库互不影响，这样可以避免版本冲突和不必要的依赖问题。 管理依赖：
本地环境：如果直接在本地环境中安装各种项目所需的库，会导致库版本错综复杂，难以管理和维护。虚拟环境：每个虚拟环境中仅包含项目所需要的特定版本库，通过pip install等命令在虚拟环境中安装或更新库时，不会影响其他项目的环境。 切换与配置：
本地环境：只有一个，无需切换，但当需要针对不同项目使用不同Python版本或库版本时会很麻烦。虚拟环境：可以在PyCharm中方便地切换不同的虚拟环境以适应不同项目需求，确保开发和运行时的一致性。 路径与结构：
本地环境：Python安装在系统的全局位置，如 C:\PythonXX (Windows)。虚拟环境：位于项目目录下的特定子目录中（例如 .venv 或者用户自定义的名称），包含了一个复制或链接到系统Python解释器的副本以及独立的site-packages目录来存放项目级的第三方包。 总结起来，使用虚拟环境的主要目的是为了更好的项目管理、依赖隔离以及团队协作，它有助于保持开发环境的整洁和可复现性。在PyCharm中，创建和管理虚拟环境非常便捷，并且完全支持虚拟环境的各种操作，包括创建、激活、安装库以及设置项目使用指定虚拟环境等。
一般创建新项目，只需要设置好新项目路径Location及新虚拟环境 New environment using里的路径Location即可
虚拟环境的Location路径包含特定于该项目的Python解释器和第三方库，一般习惯命名为venv
如下图展示虚拟环境路径下的文件夹及文件
Previously configured interpreter 指的是之前已经设置并配置过的Python解释器。当你创建或配置项目时，可以选择一个现有的Python解释器作为该项目的运行环境。这个解释器可以是本地安装的全局Python，也可以是一个为特定项目创建的虚拟环境（Virtual Environment）。
勾选 global site-packages 系统本地所有依赖包都会拷贝（可选），如果需要更纯净的开发环境可以不勾选 虚拟环境管理入口：
1、pycharm右下角
2、Files -&gt; Settings -&gt; Project -&gt; 如果在Terminal终端发现没有(venv)开头，可能是没有在虚拟环境， .\venv\Scripts\activate 切入到虚拟环境
2、PyCharm的配置及使用 1、基础设置 风格字体大小
Files -&gt; Settings -&gt; Appearance&amp;Behavior -&gt; Appearance
pycharm是不支持ctrl+ "+" 或 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97342fb6dd675cca5f4fd1d64ff51186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebd059e5bb0d78fa561419e99e7e746/" rel="bookmark">
			RabbitMQ和RocketMQ区别 | RabbitMQ和RocketMQ优缺点解析 | 消息队列中间件对比：RabbitMQ vs RocketMQ - 选择哪个适合您的业务需求？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、基础概述： RabbitMQ和RocketMQ作为消息队列中间件，共同具有以下几个共同的核心机制： 消息传递模型：它们都基于消息传递模型，通过将消息发送到队列中进行异步传递，实现不同组件或系统之间的解耦和通信。
生产者和消费者：它们都支持生产者和消费者的角色。生产者负责将消息发送到队列中，而消费者则从队列中接收并处理消息。
队列：它们都使用队列作为消息存储的中间介质。生产者将消息发送到队列，消费者从队列中接收消息进行处理。
发布/订阅模式：它们都支持发布/订阅模式，其中生产者将消息发布到主题或交换机，而消费者通过订阅感兴趣的主题或绑定到交换机来接收消息。
消息确认机制：它们都支持消息确认机制，确保消息的可靠传递。生产者可以选择等待消费者确认收到消息，或者通过确认机制来确保消息的投递。
持久化：它们都支持消息的持久化，以防止消息在异常情况下的丢失。消息可以被持久化到磁盘，以确保即使在系统故障或重启后，消息仍然可用。
以下是一些常见的业务场景，其中RabbitMQ和RocketMQ可以发挥作用： 异步任务处理：将耗时的任务或处理过程异步化，通过消息队列将任务提交给消费者进行处理，以避免阻塞和提高系统的响应性能。
事件驱动架构：通过事件发布和订阅模式，实现系统内部各个组件之间的解耦和消息通信，使系统更具灵活性和可扩展性。
消息通知和推送：将消息发送到消息队列，然后通过订阅者消费消息，实现实时通知和推送功能，如实时聊天、通知提醒等。
数据流处理：将大规模数据流分割成消息，并通过消息队列进行分发和处理，实现流数据处理、实时计算等场景，如日志处理、实时监控等。
异构系统集成：通过消息队列作为中间件，实现不同系统之间的数据传输和通信，解决异构系统之间的数据格式不兼容、性能不匹配等问题。
事务消息处理：支持事务消息的发送和消费，确保消息的可靠传递和一致性，适用于需要事务性保证的业务场景，如订单处理、支付系统等。
RabbitMQ 的特点和优缺点如下： 特点： RabbitMQ 是一个开源的、基于 AMQP（Advanced Message Queuing Protocol）协议的消息队列中间件。它支持多种消息传递模式，包括点对点、发布/订阅和请求/响应模式。RabbitMQ 提供了丰富的功能，如消息持久化、消息路由、消息确认机制、灵活的消息队列优先级等。它具有广泛的客户端库和插件生态系统，可以与多种编程语言和技术集成。 优点： 简单易用，上手快，文档丰富，社区活跃。可靠性高，支持持久化、消息确认机制等，适用于可靠性要求较高的场景。性能较好，适用于高吞吐量的消息处理。插件丰富，提供了很多扩展功能，如消息转发、消息事务等。 缺点： RabbitMQ 在处理大量消息时，会占用较多的内存资源。在某些复杂的场景下，配置和管理可能稍显复杂。 RocketMQ 的特点和优缺点如下： 特点： RocketMQ 是一个开源的、分布式的、基于消息传递的中间件。它支持高吞吐量、低延迟的消息传递，适用于大规模分布式系统的消息通信。RocketMQ 提供了丰富的消息传递模式，包括发布/订阅、点对点和顺序消息等。它具有良好的扩展性和可伸缩性，支持集群部署和水平扩展。 优点： 高吞吐量和低延迟，适用于对性能要求较高的场景。支持分布式部署和扩展，具备较好的可扩展性。提供了丰富的消息模式和功能，如事务消息、顺序消息等。在大规模集群场景下，具备较好的稳定性和可靠性。 缺点： 配置和管理相对复杂，上手难度较大。社区相对较小，文档和资源相对较少。 总结： RabbitMQ是一个简单易用的开源消息队列中间件，适用于可靠性要求较高的场景。它具有广泛的客户端库和插件生态系统，提供丰富的功能和可靠性保证。然而，在处理大量消息时可能占用较多内存资源，并且在某些复杂场景下配置和管理稍显复杂。RocketMQ是一个分布式的、高吞吐量的消息队列中间件，适用于大规模分布式系统。它具备良好的扩展性和可伸缩性，支持丰富的消息模式和功能。然而，RocketMQ的配置和管理相对复杂，上手难度较大。在选择RabbitMQ还是RocketMQ时，需要根据具体需求和使用场景进行评估和选择。RabbitMQ适用于简单易用、可靠性要求高的场景，而RocketMQ适用于大规模分布式系统和对性能要求较高的场景。无论选择哪个，它们都是强大的工具，能够帮助我们构建可靠、高效的消息传递系统。无论是RabbitMQ还是RocketMQ，它们都是推动现代应用和系统架构的关键技术之一。通过合理的选择和使用，我们能够充分利用它们的优势，提升系统的可靠性、可扩展性和性能，从而满足不同业务场景的需求。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d2b2d25105f6bbb9ae6cc6fab01c80/" rel="bookmark">
			【EFK】基于K8S构建EFK&#43;logstash&#43;kafka日志平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于K8S构建EFK+logstash+kafka日志平台 一、常见日志收集方案1.1、EFK1.2、ELK Stack1.3、ELK +filbeat1.4、其他方案 二、EFK组件介绍2.1、Elasticsearch组件2.2、Filebeat组件【1】 Filebeat和beat关系【2】Filebeat是什么【3】Filebeat工作原理【4】传输方案 2.3、Logstash组件2.4、Fluent组件2.5、fluentd、filebeat、logstash对比分析 三、EFK组件安装3.1、安装elasticsearch【1】创建headless service服务【2】创建Storageclass ，实现存储类动态供给【3】安装Elasticsearch集群 3.2、安装kibana可视化UI界面3.3、安装fluentd组件3.4、测试收集pod容器日志 一、常见日志收集方案 1.1、EFK 在Kubernetes集群上运行多个服务和应用程序时，日志收集系统可以帮助你快速分类和分析由Pod生成的大量日志数据。Kubernetes中比较流行的日志收集解决方案是Elasticsearch、Fluentd和Kibana（EFK）技术栈，也是官方推荐的一种方案。
Elasticsearch是一个实时的，分布式的，可扩展的搜索引擎，它允许进行全文本和结构化搜索以及对日志进行分析。它通常用于索引和搜索大量日志数据，也可以用于搜索许多不同种类的文档。
Elasticsearch通常与Kibana一起部署，kibana可以把Elasticsearch采集到的数据通过dashboard（仪表板）可视化展示出来。Kibana允许你通过Web界面浏览Elasticsearch日志数据，也可自定义查询条件快速检索出elasticccsearch中的日志数据。
Fluentd是一个流行的开源数据收集器，我们在 Kubernetes 集群节点上安装 Fluentd，通过获取容器日志文件、过滤和转换日志数据，然后将数据传递到 Elasticsearch 集群，在该集群中对其进行索引和存储。
1.2、ELK Stack E - Elasticsearch（简称：ES）
L - Logstash
K - Kibana
Elasticsearch：日志存储和搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。
Logstash：是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作。）。
Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。
应用程序（AppServer）–&gt;Logstash–&gt;ElasticSearch–&gt;Kibana–&gt;浏览器（Browser）：
Logstash收集AppServer产生的Log，并存放到ElasticSearch集群中，而Kibana则从ElasticSearch集群中查询数据生成图表，再返回给Browser。
考虑到聚合端（日志处理、清洗等）负载问题和采集端传输效率，一般在日志量比较大的时候在采集端和聚合端增加队列，以用来实现日志消峰。
1.3、ELK +filbeat Filebeat（采集）—&gt; Logstash（聚合、处理）—&gt; ElasticSearch （存储）—&gt;Kibana （展示）
1.4、其他方案 ELK日志流程可以有多种方案（不同组件可自由组合，根据自身业务配置），常见有以下：
Logstash（采集、处理）—&gt; ElasticSearch （存储）—&gt;Kibana （展示）
Logstash（采集）—&gt; Logstash（聚合、处理）—&gt; ElasticSearch （存储）—&gt;Kibana （展示）
Filebeat（采集、处理）—&gt; ElasticSearch （存储）—&gt;Kibana （展示）
Filebeat（采集）—&gt; Logstash（聚合、处理）—&gt; ElasticSearch （存储）—&gt;Kibana （展示）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d2b2d25105f6bbb9ae6cc6fab01c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96259818d49c9af524908db404f4aa78/" rel="bookmark">
			Warp-“21世纪现代化终端“-智能AI终端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Warp支持多种shell风格提示符主题 AI快捷键最后 Warp Warp 是一个基于 Rust 的现代化终端，内置 AI功能，支持GPU加速。
官网下载地址：https://app.warp.dev/referral/Z6L64P
目前warp支持macOS和Linux系统。
支持多种shell 默认情况下，Warp 会尝试加载你的登录shell。 目前，Warp 支持 bash、fish 和 zsh； 如果你的登录 shell 设置为其他内容（例如 Nushell），Warp 将改为加载 zsh。
Zsh 是 macOS 上的默认登录和交互式 shell（从 2019 年 macOS Catalina 开始），取代了 bash shell。 对于大多数 Linux 发行版，默认 shell 是 bash。
风格 提示符 Warp 有一个可定制的原生提示符Warp prompt，可以显示各种信息，包括 cwd、git、svn、kubernetes、pyenv、日期、时间等。并且你可以拖拽进行个性化的配置，十分方便：
如果你习惯于使用自己原先的shell提示符风格，你可以选择Shell prompt这项。
主题 Warp有多种内置的主题可供选择，也可以上传自己喜欢的图片定制主题。
AI Warp最核心和强大的功能就是AI，平时我们经常会遇到想要通过shell实现某些功能，但是不知道如何敲命令。有了AI提示功能，我们只需要通过询问AI，它就能快速给出答案。
比如询问AI如何撤回git最近的提交，它会给出答案，如果你觉得是你想要的可以点击’&gt;_'按钮，发送到shell中输入框中，回车即可执行命令：
快捷键 Warp一些常用的快捷键和iterm2的使用习惯是相似的。比如（例子在mac下）：
纵向分屏: ⌘+D横向分屏：⌘+⇧+D新建标签页：⌘+T新建窗口：⌘+N 如果你之前是iterm2的用户，切换到Warp将十分的丝滑。
如果你之前有使用fzf并且习惯与使用⌃+R的历史命令搜索功能，Warp已经为你自动集成了这些：
最后 总的来说虽然Warp还是一个比较早期的公测版本，但是已经实现了一些基本的好用且强大的功能，相信接下来会不断推出更加强大的功能。
如果你喜欢漂亮且智能的终端体验，那不妨下载Warp体验一下，官网下载地址：https://app.warp.dev/referral/Z6L64P
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef75a47f6f28c42bbac137049f3dc28/" rel="bookmark">
			基于微信小程序考研信息共享系统 (后台java&#43;Springboot框架)答辩常规问题和如何回答(答辩指导)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：黄菊华老师《Vue.js入门与商城开发实战》《微信小程序商城开发》图书作者，CSDN博客专家，在线教育专家，CSDN钻石讲师；专注大学生毕业设计教育和辅导。
所有项目都配有从入门到精通的基础知识视频课程，学习后应对毕业设计答辩。
项目配有对应开发文档、开题报告、任务书、PPT、论文模版等
项目都录了发布和功能操作演示视频；项目的界面和功能都可以定制，包安装运行！！！
如果需要联系我，可以在CSDN网站查询黄菊华老师
在文章末尾可以获取联系方式
在答辩过程中，你可能会面临以下一些常规问题，以及一些如何回答这些问题的指导：
项目介绍和背景
描述你的项目的目标和意义，以及为什么你选择了这个主题。提供一些背景信息，例如市场调研结果、用户需求等，证明你的项目的必要性和可行性。 系统架构和技术选型
解释你选择的系统架构和技术选型的原因。强调你选择的技术对于解决你的问题和实现你的目标的重要性。 功能实现和创新点
详细描述你的系统实现了哪些功能，以及这些功能如何满足用户的需求。强调你的系统的创新点，例如新颖的功能、改进的用户体验等。 技术难点和解决方案
说明你在项目开发过程中遇到的主要技术难点。阐述你采取的解决方案，并解释为什么这些解决方案是合适的。 用户体验和界面设计
解释你如何设计用户界面和用户体验，以提高用户满意度。指出你的设计考虑了哪些因素，例如易用性、美观度等。 测试和评估
描述你对你的系统进行的测试和评估方法。分享测试结果，并说明你根据这些结果采取的改进措施。 部署和运维
解释你将如何部署和运维你的系统。强调你的系统的可靠性和可扩展性。 项目展望和改进
展望你的项目的未来发展方向，并提出进一步的改进措施。强调你的项目的潜力和长期可持续发展性。 在回答问题时，要清晰、简洁地表达自己的观点，注意不要跑题，并且用具体的事例和数据来支持你的观点。此外，要尽量避免术语和专业术语，以便评委和观众都能理解你的回答。最重要的是，保持自信和冷静，积极与评委进行交流和沟通。
在微信小程序考研信息共享系统使用Java和Spring Boot框架进行后台开发的答辩中，你可能会遇到关于系统设计、技术实现、用户体验、安全性、性能优化等方面的问题。以下是一些常见的答辩问题及其建议的回答方式：
1. 项目背景与意义 问题：为什么选择开发微信小程序考研信息共享系统？回答：强调考研信息对于考生的重要性，如提供及时、准确的资讯有助于考生备考。同时，指出微信小程序具有广泛的用户基础和便捷的使用方式，能够为考生提供一个高效的信息共享平台。 2. 技术选型 问题：为什么选择Java和Spring Boot作为后台开发技术？回答：介绍Java的跨平台性和Spring Boot的易用性、快速开发等特点。强调Spring Boot简化了Spring应用的初始搭建以及开发过程，使得项目能够快速迭代和部署。 3. 系统设计与架构 问题：请描述你的系统设计和架构。回答：概述系统的整体架构，包括前后端分离、数据库设计、API接口等关键组件。特别提及使用Spring Boot构建的RESTful API以及微信小程序前端与后端通信的机制。 4. 功能实现 问题：你的系统提供了哪些核心功能？回答：详细介绍主要功能，如考研资讯发布、在线答疑、用户认证、学习资料共享等。讨论如何使用Spring Boot和相关技术实现这些功能，如使用Spring Security进行用户认证和授权。 5. 微信小程序集成 问题：如何实现与微信小程序的集成？回答：描述后端如何提供API接口供微信小程序调用，包括数据交互、用户授权等。同时，可以提及如何确保API的安全性和稳定性。 6. 用户体验与界面设计 问题：你的系统如何保证良好的用户体验？回答：强调系统界面设计的简洁性、直观性和响应性，以及如何通过用户调研和测试来优化界面设计和交互流程。同时，可以提及与微信小程序团队的合作和遵循微信的设计规范。 7. 数据安全与隐私保护 问题：你的系统如何保证用户数据的安全和隐私保护？回答：描述系统采用的数据加密、访问控制、数据备份等安全措施。同时，强调遵循相关法律法规和隐私政策，确保用户数据的安全性和隐私性。 8. 性能优化 问题：你的系统如何确保在高并发情况下的性能表现？回答：讨论系统的性能优化策略，如使用缓存技术、数据库优化、负载均衡等。同时，可以提及通过监控和调优来确保系统在高并发情况下的稳定运行。 9. 可扩展性与可维护性 问题：你的系统如何支持未来的功能扩展和系统维护？回答：强调系统的模块化设计和清晰的API接口定义，以及如何通过微服务和容器化技术来支持系统的可扩展性。同时，可以提及采用版本控制、持续集成/持续部署等最佳实践来提高系统的可维护性。 10. 遇到的挑战与解决方案 问题：在开发过程中你遇到了哪些挑战，是如何解决的？回答：分享开发过程中遇到的具体问题和挑战，如技术难题、数据处理、性能优化等，并描述采取的解决措施和最终效果。这可以展示你的问题解决能力和适应能力。 11. 未来展望与改进计划 问题：你的微信小程序考研信息共享系统未来有什么发展规划和改进计划？回答：展望系统的未来发展方向，提出可能的新功能、性能优化、安全性提升等方面的改进计划。同时，可以讨论如何根据用户反馈和市场需求来持续优化系统，以满足不断变化的考研信息需求。 答辩准备建议 深入了解你的项目，能够清楚、有条理地阐述你的工作。准备展示项目的演示材料，如小程序截图、操作流程视频等。复习相关的技术知识，以便应对可能的技术细节问题。练习答辩演讲，确保能够自信、流畅地表达。准备应对评委可能提出的额外问题或质疑，并展示你的问题解决能力和批判性思维。 通过这些准备，你将能够更好地展示你的项目，并回答评委可能提出的各种问题。记得在答辩过程中保持自信、清晰和专注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faaa2447f6f8cf5378006a79afc8d9b2/" rel="bookmark">
			nacos开启鉴权&#43;springboot配置用户名密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos默认没有开启鉴权，springboot无需用户名密码即可连接nacos。从2.2.2版本开始，默认控制台也无需登录直接可进行操作。
因此本文记录一下如何开启鉴权，基于nacos2.3.0版本。
编辑nacos服务端的application.properties： # 开启鉴权 nacos.core.auth.enabled=true # 用户服务间通信鉴权的header的key和value nacos.core.auth.server.identity.key=abc nacos.core.auth.server.identity.value=def # 自定义指定生成JWT的密钥，使用BASE64进行编码，编码前的key长度必须不小于32个字符 nacos.core.auth.plugin.nacos.token.secret.key=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI= 启动nacos后，使用默认的用户名nacos和密码nacos进行登录：
登录后可进行密码修改：
springboot配置文件中指定自己的用户名和密码：
spring: cloud: nacos: username: nacos password: xxxxxx discovery: server-addr: http://xxx.xxx.xxx.xxx:8848 config: server-addr: http://xxx.xxx.xxx.xxx:8848 file-extension: yaml 参考：https://nacos.io/docs/v2/guide/user/auth/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b7861af310c26865f12d3bc7293d4d/" rel="bookmark">
			基于java web的在线图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 项目简介2 实现效果3 系统设计3.1 功能需求3.2 功能设计 4 关键代码5 论文概览6 最后 1 项目简介 🔥 Hi，各位同学好呀，这里是L学长！
🥇今天向大家分享一个今年(2023)最新完成的毕业设计项目作品，基于java web的在线图书管理系统
🥇 学长根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：3分
创新点：3分
项目分享:见文末!
2 实现效果 废话不多说，先上实现效果
篇幅有限，本文不做过多展示
3 系统设计 3.1 功能需求 在线图书管理系统利用软件工程思想，将整个系统结构化，分为三大模块：学生管理模块、系统管理员端和公共模块。该系统的总用例图如图
学生端
① 在线查询：学生联网浏览馆内书籍信息，找到自己需要的书，原则上规定如果某书目的馆藏总量低于5本，将不能供学生借阅，学生在借总量超过10本时，也不能继续借阅。
② 查询历史书单：每个学生可同时借阅多次，每次可借阅多本书籍，查看历史书单可帮助学生查询历史借阅情况，包含借阅时间，借阅状态和每次借阅书目总量。
③ 查询书单明细：学生可查阅每个借阅书单的详细书目信息和借阅时间。
④ 续借：如果学生所借书籍即将到期还未看完时，可以续借，每续借一次，书籍的使用期限增加7天。
⑤ 添加书目：学生网上查询想要借阅的书籍，添加到小小车中，添加一本或多本后，可检查小小车中所添加的书目信息，确认无误后，提交预约书单，成功借阅。
⑥ 查看小小车：学生在浏览书目时，可以查看小小车中的书目信息，从而帮助判断将要添加的书籍，也可在被页面中删除已经添加进小小车中的部分书籍，对小小车中的书籍信息进行更新。
⑦ 清空小小车：学生如果不满意添加进小小车中的所有书籍，可以直接清空小小车，删除车中所有书目信息
管理员端
① 添加用户：点击添加用户按钮后 ，输入学生的基本信息，点击提交，完成新用户的添加，数据库中的用户表也将同步更新。
② 删除用户：点击删除用户按钮后，输入学生帐号，则可删除用户，同时数据库中的用户表也将同步更新。
③ 查看用户借阅状态：点击查看用户借阅状态按钮，则可直接在页面右侧显示所有注册用户的借阅状态。
④ 逾期通知：管理员可直接查看学生的借阅状态，若学生的借阅状态为超期，则点击该学生的明细信息，根据所留的邮箱或者电话进行逾期通知。
⑤ 添加书籍：新书到馆时，点击添加书籍按钮，并输入该书籍的相关信息，如书名，出版社，出版时间等，点击提交添加新的书目信息到数据库中。
⑥ 删除书籍：当馆藏书籍陈旧或因其他原因需要下架时，点击删除书籍按钮，并输入该书目名称，则可将图书馆中该书目信息进行删除。
⑦ 修改书籍：当书目总量发生改变时，点击修改书籍按钮，输入书籍名称和最新数量，点击提交，即可完成数据库馆藏信息的更新。
⑧ 图书归还：输入书籍名称和用户ID，学生核对情况后，完成还书。
管理员端用例图如图
3.2 功能设计 E-R (Entity-Relationship)图，用于描述实体的属性以及实体之间的联系，可以帮助我们在系统设计阶段描绘出数据库的概念模型。在线图书管理系统中主要涉及bm_book，bm_user，bm_order，bm_line四个实体，bm_book中用于记录保存馆藏书目信息，bm_user中同时包含管理员和学生信息，bm_order中保存学生的借阅书单，bm_line保存书单的详细条目信息。这四个实体之间的具体关系如图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b7861af310c26865f12d3bc7293d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe3c0d99ef0d970da4ec0a1ece1adec/" rel="bookmark">
			Spring Boot 整合 Redis 超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、pom.xml 中添加 Redis 依赖二、配置 Redis 连接信息三.使用 RedisTemplate 进行操作1、RedisTemplate Bean配置类2、注入 RedisTemplate3、 Redis 操作 四. Spring Cache 简化缓存操作1、pom.xml中添加 Spring Cache 依赖2、启用类添加缓存支持注解3、使用缓存注解 五. 实现分布式锁 Redisson1、pom.xml中添加 Redisson 依赖2、yml中进行Redisson配置3、Redisson 获取锁 六. Redis相关配置1、redis.conf连接池配置2、客户端Jedis连接池配置对象JedisPoolConfig配置3、超时时间设置1、在 Redis 配置文件中设置 timeout 参数，用于控制 Redis 操作的超时时间，以防止长时间的阻塞或无响应操作2、通过 JedisClientConfiguration 进行配置，将读取操作的超时时间设置为 5秒 前言 Redis 是一种高性能的键值存储数据库，而 Spring Boot 是一个简化了开发过程的 Java 框架。将两者结合，可以轻松地在 Spring Boot 项目中使用 Redis 来实现数据缓存、会话管理和分布式锁等功能。
话不多说直接干货！！！
一、pom.xml 中添加 Redis 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 二、配置 Redis 连接信息 在 application.yml 配置文件中添加 Redis 连接信息，根据自己 Redis 服务器配置，修改主机和端口信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe3c0d99ef0d970da4ec0a1ece1adec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1930d142bebde0119db643e1e306c676/" rel="bookmark">
			【Java】Spring循环依赖：原因与解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空
🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 目录
🌈个人主页：人不走空 💖系列专栏：算法专题
⏰诗词歌赋：斯是陋室，惟吾德馨
什么是Spring循环依赖？
Spring循环依赖的解决方法
循环依赖的形成
1. 构造函数循环依赖
2. 属性循环依赖
解决方法
1. 使用构造函数注入
2. 使用@Lazy注解
3. 使用setter方法注入
结语
作者其他作品：
在Spring框架中，处理循环依赖一直备受关注。这是因为Spring团队在源代码中为了解决这个问题做了大量的处理和优化。同时，循环依赖也是Spring高级面试中的必考问题，对其深入了解可以成为面试中的制胜法宝。本文将详细介绍Spring循环依赖的产生原因、解决方法以及相关示例。
什么是Spring循环依赖？ Spring循环依赖指的是两个或多个Bean之间相互依赖，形成一个环状依赖的情况。简单来说，就是A依赖B，B依赖C，C依赖A，这样就形成了一个循环依赖的环。
Spring循环依赖通常会导致Bean无法正确地被实例化，从而导致应用程序无法正常启动或者出现异常。因此，Spring循环依赖是一种需要尽量避免的情况。
Spring循环依赖的解决方法 为了解决Spring循环依赖问题，我们可以采取以下几种方法：
构造函数注入： 在构造函数注入中，Spring会检查循环依赖，并在发现循环依赖时抛出异常，避免死循环。
使用@Lazy注解： @Lazy注解可以延迟Bean的实例化，从而避免循环依赖的问题。
使用setter方法
Spring框架为开发者提供了强大的依赖注入功能，然而，当不当使用时，就会出现循环依赖的问题。本文将介绍Spring循环依赖的形成原因以及解决方法。
循环依赖的形成 Spring循环依赖通常出现在两种情况下：
1. 构造函数循环依赖 构造函数循环依赖发生在Bean的构造函数中相互依赖的情况下。例如：
@Component public class A { private B b; public A(B b) { this.b = b; } } @Component public class B { private A a; public B(A a) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1930d142bebde0119db643e1e306c676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce05bde75c5e8daa3a1cbc7acae0b781/" rel="bookmark">
			Java实战：Spring Boot生成PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将详细介绍如何在Spring Boot应用程序中自定义生成PDF。我们将探讨生成PDF的基本概念，以及如何使用Spring Boot和第三方库来实现PDF的生成。此外，我们将通过具体的示例来展示如何在Spring Boot应用程序中配置和使用不同的PDF生成方案，以满足不同的需求。本文适合希望使用PDF生成技术来增强Spring Boot应用程序功能的开发者阅读。
一、引言 在现代Web应用程序中，生成PDF是一种常见的需求，用于将Web内容以PDF格式呈现给用户。Spring Boot提供了一种简便的方式来集成PDF生成技术，通过集成第三方库来实现这一功能。本文将介绍如何在Spring Boot应用程序中自定义生成PDF，并探讨如何使用Spring Boot和第三方库来实现这一机制。
二、生成PDF的基本概念 1. 什么是PDF？
PDF（Portable Document Format）是一种用于文档交换的文件格式，由Adobe Systems开发。PDF文件可以包含文本、图形、图像、超链接等多种信息，并可以被多种应用程序读取和打印。PDF文件具有跨平台、可移植、可自定义等优点，被广泛应用于电子文档、电子表格、电子书等场景。
2. 生成PDF的作用
提高数据可视化：生成PDF可以将数据以可视化的形式呈现给用户，提高用户体验。便于文档交换：PDF文件可以被多种设备和应用程序读取，便于文档的交换和共享。实现打印预览：生成PDF可以实现打印预览功能，方便用户查看文档的打印效果。 三、在Spring Boot中自定义生成PDF 1. 使用iText库 iText是一个开源的PDF生成库，它提供了丰富的API用于生成PDF文件。iText支持多种编程语言，包括Java、C#等。在Spring Boot应用程序中，使用iText库来实现PDF的生成。
1.1. 添加iText依赖
在项目的pom.xml文件中，添加iText依赖。以下是一个使用iText的示例：
&lt;dependencies&gt; &lt;!-- iText依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.2. 创建PDF文档
使用iText库创建PDF文档。以下是一个简单的创建PDF文档的示例：
import com.itextpdf.text.Document; import com.itextpdf.text.Paragraph; import com.itextpdf.text.pdf.PdfWriter; import java.io.FileOutputStream; public class PdfGenerator { public static void main(String[] args) { Document document = new Document(); try { PdfWriter.getInstance(document, new FileOutputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce05bde75c5e8daa3a1cbc7acae0b781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c3fe7c24a16e02227b952cacd1393ad/" rel="bookmark">
			nginx漏洞修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞名称：web服务器http信息头公开
解决，在以下各个监听端口加上一行，然后重启nginx
server_tokens off;
漏洞名称：默认的nginx http服务器设置
解决：请求头加上以下参数
add_header Content-Security-Policy "default-src 'self';";
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload";
add_header X-Frame-Options "SAMEORIGIN";
漏洞名称：允许的http方法
解决：在nginx配置文件中添加以下配置
写在location中
if ($request_method !~ ^(GET|POST|DELETE|PUT)$) { return 405; }
if ($request_method !~ ^(options)$) { return 405; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97279637bc7031db3f442860ffcee020/" rel="bookmark">
			【zookeeper】在Windows上启动zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎个人博客：个人主页
🏆个人专栏：软件的安装使用
⛳️ 功不唐捐，玉汝于成
目录
前言
正文
1.下载ZooKeeper：
2.配置ZooKeeper：
3.启动ZooKeeper：
4.关闭ZooKeeper：
结语
我的其他博客
前言 在当今分布式系统中，ZooKeeper扮演着至关重要的角色，作为协调服务的核心组件。其高可用性和一致性保证了分布式环境中各种服务的可靠性和稳定性。在Windows平台上启动ZooKeeper可能会有些许不同，但遵循正确的步骤可以确保系统的顺利运行。
正文 1.下载ZooKeeper： 首先，你需要从Apache ZooKeeper的官方网站(http://zookeeper.apache.org)下载适用于Windows的二进制文件。下载后，解压缩到你选择的目录中。
2.配置ZooKeeper： 在解压后的目录中，你需要修改ZooKeeper的配置文件。默认的配置文件是conf/zoo.cfg。你可以复制一份zoo_sample.cfg并命名为zoo.cfg，然后进行相应的修改。在zoo.cfg中，你需要指定ZooKeeper服务器的配置，包括数据目录、客户端端口、同步时间等。确保配置满足你的需求。 3.启动ZooKeeper： 打开命令提示符（CMD）或者PowerShell，并导航到ZooKeeper的安装目录。运行以下命令来启动ZooKeeper服务器： 然后在bin文件下找到zkCli.cmd 双击运行 如下箭头所示则表示成功
4.关闭ZooKeeper： 要关闭ZooKeeper服务器，可以在ZooKeeper的命令行界面中输入quit命令，或者直接关闭命令行窗口。 结语 通过本文提供的步骤，你应该能够在Windows上成功启动ZooKeeper，并开始利用其强大的功能来构建可靠的分布式系统。无论是在开发、测试还是生产环境中，ZooKeeper都是一个不可或缺的工具，它的稳定性和性能将帮助你实现各种复杂任务。务必遵循官方文档和最佳实践，以确保系统的安全和可靠性。
我的其他博客 【MySQL】数据库规范化的三大法则 — 一探范式设计原则-CSDN博客
【JAVA】线程的run()和start()有什么区别？-CSDN博客
【日常聊聊】程序员必备的面试技巧：如何在面试战场上脱颖而出-CSDN博客
【JAVA】Java8开始ConcurrentHashMap,为什么舍弃分段锁-CSDN博客
【JAVA】怎么确保一个集合不能被修改-CSDN博客
【Web开发】会话管理与无 Cookie 环境下的实现策略-CSDN博客
【Mybatis】Mybatis如何防止sql注入-CSDN博客
【软件工程】航行敏捷之路：深度解析Scrum框架的精髓-CSDN博客
【Spring】理解IoC与AOP：构建灵活而模块化的软件架构-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b97714330054f700490de78f8b9fde/" rel="bookmark">
			python｜闲谈2048小游戏和数组的旋转及翻转和转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
2048
生成数组
n阶方阵
方阵旋转
顺时针旋转
逆时针旋转
mxn矩阵
矩阵旋转
测试代码
测试结果
翻转和转置
2048 《2048》是一款比较流行​的数字游戏​，最早于2014年3月20日发行。原版2048由Gabriele Cirulli首先在GitHub上发布，后被移植到各个平台，并且衍生出不计其数的版本。但在网上看到，居说它也不算是原创，是基于《1024》和《小3传奇》的玩法开发而成的；还有一说，它来源于另一款游戏《Threes!》，由Asher Vollmer和Greg Wohlwend合作开发，于2014年2月6日在App Store上架。
2048游戏规则很简单，游戏开始时在4x4的方格中随机出现数字2，每次可以选择上下左右其中一个方向去滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢外，相邻的相同数字在靠拢时会相加，系统也会在空白的格子里随机增加一个数字2或4。玩家要想办法在这16格范围中，不断上下左右滑动相加数字，从而凑出“2048”这个数字方块。
实际上，这个游戏就是在操作一个4x4的二维数组，数组的元素只要1-11就行了，因为2的11次方就是2048。同样，相邻相同数字的累加就变成了相邻相同指数的递增1。
在编写这个2048游戏前，先来谈谈4x4数组的操作，对python来说虽然也有数组，但通常会用列表来操作。以下就在IDLE shell上流水账操作：
生成数组 16个数字的列表推导式：
&gt;&gt;&gt; [i for i in range(16)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
用*解包更pythonic：
&gt;&gt;&gt; [*range(16)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
分割成4x4二维列表：
&gt;&gt;&gt; [[*range(16)][i*4:i*4+4] for i in range(4)]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b97714330054f700490de78f8b9fde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66a5d541afbb5bff87ee2957ef57f47/" rel="bookmark">
			SpringBoot 集成 RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 集成 RabbitMQ 1.应用实例 需求说明/图解 -P : 消息的发送者/生产者
-C : 消息的接受者/消费者
-中间表示队列
完成步骤 添加依赖 &lt;!--rabbitmq-需要的 AMQP 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 修改yaml配置 spring: #rabbitmq 配置 rabbitmq: host: 192.168.79.202 username: guest password: guest #虚拟主机 virtual-host: / #端口 port: 5672 listener: simple: #消费者最小数量 concurrency: 10 #消费者最大数量 max-concurrency: 10 #限制消费者，每次只能处理一条消息，处理完才能继续下一条消息 prefetch: 1 #启动时是否默认启动容器，默认为 true auto-startup: true #被拒绝时重新进入队列的 default-requeue-rejected: true template: retry: #启用消息重试机制，默认为 false enabled: true #初始重试间隔时间 initial-interval: 1000ms #重试最大次数，默认为 3 次 max-attempts: 3 #重试最大时间间隔，默认 10000ms max-interval: 10000ms #重试的间隔乘数， #配置 2 的话，第一次等 1s，第二次等 2s，第三次等 4s multiplier: 1 #在 RabbitMQ 中，initial-interval 和 max-interval 是用于指定消息重试机制的两个参数， #它们的区别如下： #1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c66a5d541afbb5bff87ee2957ef57f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441bbe536d2f9f175472b02de9ace9c9/" rel="bookmark">
			【Flutter/Android】运行到安卓手机上一直卡在 Running Gradle task ‘assembleDebug‘... 的终极解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法步骤简要 查看你的Flutter项目需要什么版本的 Gradle 插件：
下载这个插件：
方法一：浏览器输入：https://services.gradle.org/distributions/gradle-7.6.3-all.zip
方法二：去Gradle官网找对应的版本：https://gradle.org/releases/
方法三：问别人要（反正就是你要能够自己找到这个玩意）
把压缩包放在C盘指定目录，比如：不要解压！！！！
Android Studio 中修改下载路径为你本地电脑上的：
distributionUrl=file:///C:/AndroidGradle/gradle-7.6.3-all.zip
重新点击运行你的Flutter项目即可----over！
另外可视化构建的3个方法（参考即可）： ./android/gradlew clean（一定要在./android下运行，可以先cd，再运行./gradlew clean）./android/gradlew build （同理）在C:\Users\你的用户名称\.gradle\wrapper\dists目录下找到特定文件，不断地刷新就可以看到下载大小…(很傻)
原理介绍： Gradle 是安卓的构建工具，必须要先下载对应版本才能使用。
而新手遇到的最大问题其实就是Android Studio 里面下载实在太慢了！！！
而且非常容易下载不成功，导致Flutter项目无法运行到手机上（运行到浏览器web是没问题的）。
所以本方法是手动下载到本地计算机磁盘上，然后，让 Android Studio 从磁盘上下载（相当于本地服务器）。
一方面你自己下载的速度快的离谱，另一方面 Android Studio 从本地磁盘上下载也快的离谱。
两者一结合，快到起飞！
另外的方法探索：
从上面的介绍过程，我们发现，他是由xxx.zip.part 转换成 xxx.ok
所以是否还有这样的方法：
直接把解压好的文件放入xxx.zip.lck和xxx.zip.part的文件中，然后把part文件删除，并新建一个xxx.ok的文件表示解压成功。然Android Studio 知道已经下载并解压成功了。
这个方法我还没实验，给你们作为课外作业，感兴趣可以自己探索！
还有一个小细节补充（上面的课外作业我已经试了——OK！），但是注意，这个gradle文件第点进去之后比如是可以看到bin目录：不能是gradle-7.5-bin,然后点进去还是一层gradle-7.5。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95611c99f6aac69594159747c884cb64/" rel="bookmark">
			Java/JDK下载安装与环境配置安装（win11超详细图文版教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：安装JDK 1.开始安装JDK
从Oracle官网进入（Java Archive | Oracle）下载安装文件。
然后往下滑，可以看到官方已经讲收费和免费的分开来了。
这边建议下载Java SE 8 (8u201 and earlier)，原因请看这个博主讲述的理由JDK版本8u191与8u192的区别， jdk小版本号奇数与偶数的区别_jdk8小版本区别-CSDN博客
win11系统选择这个去下载。
点击下载按钮会跳到登录的按钮，登录后即可下载。
2.自定义安装功能和路径
安装成功后，点击下一步。
点击下一步。
3.JDK目录介绍
JDK安装完毕，会在磁盘上生成一个目录，该目录被称为JDK目录。如下图所示。
为了更好地学习JDK，下面对JDK的各个子目录进行介绍。
（1）bin目录：binary（二进制的）的缩写，该目录放一些可执行程序，javac.exe（java编译器）、java.exe（java运行工具）。
（2）include目录：因为JDK是用从语言和C++开发的，所以这个目录用来存放C语言的头文件。
（3）lib目录：library的缩写，java的库文件。
（4）jre目录：java运行程序的环境。
二：系统环境变量 1.path环境变量
直接在搜索栏搜索path，点击环境变量。
2.新建系统变量
变量名设置为JAVA_HOME，变量值填入安装java时JDK所在的地址，像我的就是
C:\Program Files\Java\jdk1.8.0_201
通过下面这种方式去复制地址。
然后再次新建变量
新建变量名：CLASSPATH，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
然后找到Path，点击编辑
然后分别新建以下两个变量值%JAVA_HOME%\bin;
%JAVA_HOME%\jre\bin 效果如下
三：验证JDK环境是否安装成功
点击win+R，输入cmd
输入javac
出现以下画面即表示环境配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba239710fdaa38a0ab6c5663ac19b8d7/" rel="bookmark">
			简单聊聊AI绘画中的SD（Stable Diffusion）是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聊到AI绘画，基本上就会聊到SD这个概念，毕竟作为开源可以本地部署的AI绘画软件，SD可能是目前的唯一选择，不管是webUI或者ComfyUI，还有国内的很多套壳绘画AI，都是sd作为基础进行二次优化的。那么SD到底是个啥，这篇文章就结合我个人的理解简单跟大家聊聊。
基础介绍 SD全称是Stable Diffusion，稳定扩散模型，可以理解为一种技术，而大家常说的WebUI或者Comfyui都是这个技术的界面层，所以这一点首先要了解。
Stable Diffusion模型是一种基于扩散过程的生成模型，它用于生成高质量的图像。这种模型是在传统的扩散模型（Denoising Diffusion Probabilistic Models, DDPMs）的基础上发展而来的。
那么，SD的架构长什么样子呢？接下来要放出这张已经被很多人发过的图片了：
Stable Diffusion的改进 Stable Diffusion模型的主要改进在于它在潜在空间（latent space）中进行扩散过程，而不是在原始图像空间。这使得模型在生成图像时速度更快，同时保持了高质量的输出。
潜在空间（Latent Space）：首先，模型训练一个自编码器（autoencoder），将原始图像压缩到一个低维的潜在空间表示。这个表示包含了图像的压缩信息，但尺寸远小于原始图像。
在潜在空间中的扩散：在潜在空间中进行正向和反向扩散过程。由于潜在数据的尺寸较小，这大大加快了去噪过程。
条件生成：Stable Diffusion模型可以接收文本提示作为条件输入，这使得模型能够根据文本描述生成相应的图像。这是通过将文本提示转换为嵌入向量，并通过注意力机制（如Transformer）与潜在数据结合来实现的。
核心组件构成 没错，stable diffusion其实是由三部分组成的，而每一个都可以理解为一个较为独立的模块，每次使用的时候，不管是文生图还是图生图，都是他们三个相互配合才能生成一张图片，
VAE（变分自编码器，Variational Auto-Encoder）：VAE负责将原始图像压缩到一个低维的潜在空间（latent space）表示，这个表示被称为潜在数据。VAE由编码器（Encoder）和解码器（Decoder）两部分组成，编码器将图像压缩成潜在数据，解码器则将潜在数据还原为图像。
U-Net：U-Net是一个深度神经网络，它在Stable Diffusion中扮演着去噪器的角色。在扩散过程中，U-Net学习如何逐步去除添加到潜在数据中的噪声，从而生成清晰的图像。U-Net通常包含多个卷积层，以及用于处理时间步的调度算法。
CLIP Text Encoder：这是一个基于Transformer的语言模型，用于将文本输入转换为数字表示，即文本嵌入（embeddings）。这些文本嵌入随后被用作条件信息，指导图像生成过程，使得生成的图像与文本描述相匹配。
这三个组件共同工作，使得Stable Diffusion能够根据文本提示生成高质量的图像。在生成过程中，模型首先在潜在空间中进行正向扩散，添加噪声，然后在反向扩散过程中，通过U-Net逐步去除噪声，最终由VAE的解码器生成最终的图像。CLIP Text Encoder在整个过程中提供文本条件，确保生成的图像与输入的文本描述相符。
篇幅有限，我们这里先讲讲vae，因为在comfyui里边经常看到个VAE encoder，VAE decoder，到底编码解码的在玩啥？
VAE是干啥的 首先，它肯定不是有些自媒体朋友们讲的，就是个滤镜，它真的不是滤镜，虽然看起来效果上，有点类似加了个滤镜...
VAE（变分自编码器，Variational Auto-Encoder）是一种深度学习模型，它结合了自编码器（Auto-Encoder）的结构和概率图模型（如贝叶斯网络）的原理。
在Stable Diffusion模型中，VAE的编码器部分负责将图像压缩到潜在空间(latent space)，而解码器部分则在生成过程中将潜在数据转换回像素空间，从而生成最终的图像。这种结构使得Stable Diffusion能够在潜在空间中高效地进行图像生成和编辑。
潜空间latent space是个啥？ Latent Space（潜在空间）是机器学习和深度学习中的一个概念，它指的是数据的一种低维表示，这种表示能够捕捉数据的主要特征和结构。在潜在空间中，数据的复杂性被简化，使得数据点之间的模式和关系更加清晰，便于分析和理解。
潜在空间的特点包括：
低维性：潜在空间通常具有比原始数据空间更低的维度。这意味着它能够通过较少的变量来表示数据，从而减少计算复杂度。
压缩表示：潜在空间中的每个点代表了原始数据的一个压缩版本，这种压缩保留了数据的关键信息，同时去除了冗余和噪声。
特征学习：通过潜在空间，模型可以学习到数据的内在特征，这些特征对于执行特定任务（如分类、回归或生成）可能是有用的。
模式识别：在潜在空间中，相似或相关的数据点会彼此靠近，这有助于识别数据中的模式和结构。
生成能力：在生成模型（如变分自编码器VAE或生成对抗网络GAN）中，潜在空间可以用来生成新的数据实例。通过在潜在空间中选择或随机采样点，并通过解码器生成对应的数据，可以创造出新的、与训练数据相似的数据点。
潜在空间的概念在许多机器学习应用中都非常重要，因为它提供了一种有效的方式来理解和操作数据，尤其是在处理高维数据时。通过潜在空间，研究人员可以更好地探索数据的内在属性，发现数据之间的关联，以及创造新的数据样本。
是不是还是有点萌萌的？
其实可以简单理解为“概念空间”。并不准确，但是可以这么大概理解，比如说这张图片：
它在像素空间里边是1280x1280像素，每个像素点都是RGB三个色值组成，也就是 3x1280x1280这么大的信息量，可以说，不算小的一张图片了。
但是，在你的脑海里边，并没有记下来这么多的数据，而是有个大概的印象“一个红色的苹果”。
嗯，这张图片，就是像素空间，而这张图片表达的概念，就是“一个红色的苹果”。
很明显，后边这个“概念”占的字符数要小的多。这，就是“latent space”。
VAE如何实现像素图片的压缩呢？ VAE（变分自编码器）实现数据压缩的主要方式是通过其编码器（Encoder）部分，该部分将输入数据映射到一个低维的潜在空间表示。以下是VAE实现压缩的详细过程：
编码过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba239710fdaa38a0ab6c5663ac19b8d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a781646c4bdb3a97dae020fa173880c/" rel="bookmark">
			【AI.OS】深入解读阿里开源系统全图化引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章介绍了阿里开源高性能搜索引擎 Havenask - Ha3 本文重点解析2018年这个AI.OS版本的创新点
目录 1 全图化引擎介绍2 AI.OS集成的各大模块简介2.1 DII2.2 RTP2.3 BE2.4 IGraph2.5 Ha32.6 总结 3 图化 - 算子开发3.1 自定义算子3.2 调用算子 4 DII4.1 丰富的本地索引支持4.2 原生的外部服务访问集成4.3 完善的数据更新链路 5 RTP5.1 迭代效率-平台架构5.2 运行效率-存储与计算5.2.1架构优化-online2offline5.2.2 特征计算优化-codegen5.2.3 网络计算优化-异构计算 5.3 RTP和TensorFlow Serving5.4 RTP在阿里巴巴的应用5.4.1 搜索架构的视角看RTP的位置和作用5.4.2 推荐架构的视角看RTP的位置和作用5.5 RTP模型和数据更新5.6 RTP对外接口服务5.7 RTP内部实现原理 6 BE6.1 架构和工作原理6.2 向量召回和应用 7 iGraph8 名词解析 1 全图化引擎介绍 看到这张图可能会有点懵，熟悉和使用过搜索推荐服务的同学可能都知道在线技术组件如DII、RTP、HA3、BE、IGraph，它们在不同场景发挥各自擅长的作用。那么AI.OS(Artificial Intelligence Online Serving) 是个啥概念？
乍一看，是将搜索、推荐、广告、深度学习、信息流所应用到的技术组件融合成了一个体系，形成一个基础的引擎平台。仔细一琢磨，这么做是想干啥呢？带着这个问题一步一步往下看
在这个组件的最下层是资源的管理，叫 Hippo，是一个非常高效的资源管理系统。最上层业务，包括淘内业务，云上业务和广告业务，都是近几年陆陆续续拓展起来，一起逐步迁移到 AI·OS 这个功能体系上的。阿里的很多技术、业务是一个自底向上的模式，我们有非常强的创新意识。我们自底向上把搜索推荐平台化建设到百分之七八十，再组织推动到战略高度，加速之后形成了全覆盖的格局。
右侧是系统里的中间件，是更为基础的组件，跟实际的业务功能都直接相关。包括服务的定位——运行数万台机器的系统，内部要想服务定位需要有一个自己的机制。服务监控达到秒级的，这种秒级的服务监控和内部应用的 metrics 对分布式系统的 debug 是非常关键的。索引分发是解决引擎数据更新链路的重要基础组件。我们的消息队列是一个利用机器碎片资源搭建的高性能消息组件，只有非常小的 CPU 消耗和网络的通量，基本上是一个免费的组件，成本上比较有优势。二层调度和弹性扩缩，在应对大促时，是在内部做搜索、推荐、广告之间分钟级资源调配的重要手段。
左侧的算法平台、离线平台、训练平台、计算平台，是我们在深度学习时代新的开拓。从样本和特征的处理链路来说，有我们的算法平台——星云体系，在这个过程当中，有训练引擎的对接——XDL。计算平台，是支撑算法样本和训练的基础，也是阿里集团内部强大的技术支点，是和搜索一起成长起来的，相互促进相互支撑。
中间，是这几年最重要的积累，和业务密切相关。端上智能，我们在端上不仅仅做简单的推荐改变和结果混排的变化，而是真正在端上做模型的训练，深度模型的预测，在这方面，手淘信息流是全世界规模最大的深度学习、训练和预测的应用场景，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a781646c4bdb3a97dae020fa173880c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/493/">«</a>
	<span class="pagination__item pagination__item--current">494/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/495/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>