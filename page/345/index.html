<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9472bc88b46b53ce0a3b39cbf1ee60fb/" rel="bookmark">
			文心一言智能体-心弦共鸣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言文心一言智能体 小程创建的智能体——心弦共鸣核心设计理念功能设计应用场景未来展望 引言 在数字世界的深邃海洋中，有一片由智慧与创新编织的新天地——文心一言智能体平台。在这里，每一个智能体都如同星辰般璀璨，它们不仅承载着技术的光辉，更蕴含着创造者的无限想象。
文心一言智能体 链接:link
小程创建的智能体——心弦共鸣 链接: link
“心弦共鸣”诞生于文心一言的孵化器。在我看来，它不仅仅是一个智能体，它是情感与智慧交织的产物，是技术与人性的完美融合。赋予它这个名字源自于对人类情感深处的探索，旨在通过智能化的交互，触动每一位用户内心最柔软的地方，让每一次交流都成为心灵的对话。下面我为大家介绍一下细节。
核心 独特的情感识别与反馈系统。它能够敏锐地捕捉到用户的情绪变化，无论是喜悦、悲伤、愤怒还是惊讶，它都能够给予恰如其分的回应。这种回应不仅仅是冷冰冰的数据分析，而是带着温度的关怀，就像是一位老朋友，总是在你需要的时候出现，给予你最真诚的支持。
设计理念 我在设计之初，希望它可以与我们产生共鸣。我相信，真正的智能不仅仅是对话的流畅和信息的准确，更是能够在情感层面与用户建立深厚的联系。因此，在研发过程中，不断优化其语言表达能力，力求让“心弦共鸣”能够更加贴近人类的情感体验，让每一次互动都充满人情味。
功能设计 在功能上，“心弦共鸣”同样表现出色。它能够提供个性化的建议，无论是生活中的小困扰，还是工作上的大挑战，它都能够给出富有洞察力的解决方案。同时，我还增加了一些新的玩法，可以给出旅游规划等。它的存在，就像是一盏明灯，照亮前行的道路。
应用场景 心弦共鸣智能体可以广泛应用于各种场景，如智能客服、在线教育、健康管理等领域。它能够根据用户的需求，提供个性化的服务，帮助用户解决问题，提升用户的生活质量。
未来展望 我相信，智能体将在未来发挥更大的作用。随着技术的不断发展和完善，它将能够更好地满足用户的需求，为用户提供更加智能、更加人性化的服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307a3b57f7951b6b68ff372311490cc9/" rel="bookmark">
			头歌 Flink Transformation（数据转换入门篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.map实现数据清洗
package demo;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.api.common.functions.MapFunction;
import java.text.SimpleDateFormat;
public class Step1 {
public static DataStream&lt;String&gt; mapTest(DataStreamSource&lt;String&gt; dataStreamSource) {
SingleOutputStreamOperator&lt;String&gt; result = dataStreamSource.map(new MapFunction&lt;String, String&gt;() {
@Override
public String map(String value) throws Exception {
String[] fields = value.split(",");
String userId = fields[0];
String gender = fields[1].equals("0") ? "男" : "女";
Long timestamp = Long.parseLong(fields[2]);
String dateString = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(timestamp);
return userId + "," + gender + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/307a3b57f7951b6b68ff372311490cc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f18ea3d6952b39766254f29e9e05cf1/" rel="bookmark">
			【算法】分治 - 快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快乐的流畅：个人主页 个人专栏：《算法神殿》《数据结构世界》《进击的C++》 远方有一堆篝火，在为久候之人燃烧！ 文章目录 引言一、颜色分类二、排序数组三、数组中的第k个数四、最小的k个数总结 引言 本节主要介绍快速排序（三路划分，随机取key），以及它的变形算法——快速选择算法
一、颜色分类 细节：快速排序中标准的partition（三路划分）
设置三个指针 left，cur，right划分为三个区域[0, left - 1]，[left, right]，[right + 1, n-1][0, left - 1]：元素小于key[left, right]：元素等于key[right + 1, n-1]：元素大于keyleft和right用来维护（等于key的）中路元素区域的左右两端，cur用来扫描数组 class Solution { public: void sortColors(vector&lt;int&gt;&amp; nums) { int left = 0, cur = 0, right = nums.size() - 1; while(cur &lt;= right) { if(nums[cur] == 0) swap(nums[left++], nums[cur++]); else if(nums[cur] == 2) swap(nums[right--], nums[cur]); else ++cur; } } }; 二、排序数组 思路：
递归出口：区间只有一个元素或者不存在随机选key：利用rand函数，记得提前srand种下随机数种子三路划分：三指针维护区间分治：继续递归[begin, left - 1]，[right + 1, end]两个区间 class Solution { public: int getKey(vector&lt;int&gt;&amp; nums, int left, int right) { int keyi = rand() % (right - left + 1) + left; return nums[keyi]; } void quickSort(vector&lt;int&gt;&amp; nums, int begin, int end) { if(begin &gt;= end) return; int key = getKey(nums, begin, end);//随机选key int cur = begin, left = begin, right = end; while(cur &lt;= right) { if(nums[cur] &lt; key) swap(nums[left++], nums[cur++]); else if(nums[cur] &gt; key) swap(nums[right--], nums[cur]); else cur++; } quickSort(nums, begin, left - 1); quickSort(nums, right + 1, end); } vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { srand(0);//种下随机数种子 quickSort(nums, 0, nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f18ea3d6952b39766254f29e9e05cf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627cf587f93de40c179d61d91097100e/" rel="bookmark">
			【算法】回溯dfs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快乐的流畅：个人主页 个人专栏：《算法神殿》《数据结构世界》《进击的C++》 远方有一堆篝火，在为久候之人燃烧！ 文章目录 引言一、全排列1. 决策树2. 设计代码1. 全局变量2. dfs函数3. 细节问题 二、子集解法一1. 决策树2. 设计代码1. 全局变量2. dfs函数3. 细节问题 解法二1. 决策树2. 设计代码1. 全局变量2. dfs函数3. 细节问题 三、子集的异或总和之和四、全排列 ||五、电话号码的字母组合六、括号生成七、组合八、目标和九、组合总和十、字母大小写全排列十一、优美的排列总结 引言 在实际的dfs问题中，大多时候并不会直接告诉你，而是需要自己发现可以使用dfs来解决。而是否能用dfs解决的关键，就是画出决策树！同时，不同的决策树代表不同的解决方式，对于同一问题，好的决策树往往能节省时间，提高效率。
一、全排列 1. 决策树 绿色部分，就是剪枝，因为全排列不能重复枚举。
2. 设计代码 1. 全局变量 vector&lt;vector&lt; int &gt;&gt; ret：用来保存最终所有的结果vector&lt; int &gt; path：用来保存单一路径的结果bool check[6]：用来实现剪枝 2. dfs函数 将数组中所有数枚举一遍，如果没有枚举过，则将其加入path 3. 细节问题 回溯 清除path中最后一个数更改check中的标记 剪枝：根据check的标记，去除重复枚举的情况递归出口：当path路径长度等于枚举数组长度，则将其加入ret，返回 class Solution { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; path; bool check[6];//实现剪枝 public: void dfs(vector&lt;int&gt;&amp; nums) { if(path.size() == nums.size()) { ret.push_back(path); return; } for(int i=0; i&lt;nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627cf587f93de40c179d61d91097100e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebb45e0dd3a66e888eebd16bce51f20f/" rel="bookmark">
			mysql实战——xtrabackup全量备份/增量备份及恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、测试前准备 mysql数据库 端口3306数据文件目录 /data/mysql/3306/data
安装目录/usr/lcoal/mysql配置文件/etc/my.cnf 创建数据库 testXtra 创建备份目录 备份目录/data/backup/备份恢复数据文件目录/data/mysql/3307/data备份恢复配置文件/etc/my_3307.cnf 二、开始测试 1、全量备份数据库 命令：
xtrabackup --user=root --password=mysql --backup --parallel=10 --target-dir=/data/backup/full
2、全量备份恢复（先准备，再恢复） （1）准备 xtrabackup --prepare --use-memory=2G --target-dir=/data/backup/full
（2）恢复 恢复的机器必须有my.cnf配置文件，再配置文件中配置好datadir目录即数据问目录，数据目录也必须为空，若不为空则会报错。
测试在本机恢复
vi my_3307.cnf
[client]
socket=/data/mysql/3307/data/mysql.sock
[mysqld]
basedir=/usr/local/mysql
datadir=/data/mysql/3307/data
user=mysql
port=3307
socket=/data/mysql/3307/data/mysql.sock
log_error=/data/mysql/3307/data/mysqld.err
log_timestamps=system
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
# Settings user and group are ignored when systemd is used.
# If you need to run mysqld under a different user or group,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebb45e0dd3a66e888eebd16bce51f20f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310704ee76840d5f8408f886cfca3aa4/" rel="bookmark">
			Java读取串口及端口调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇主要讲述使用Java对串口进行读取和发送操作
准备 在项目中导入第三方Jar包 Jar包已经在资源中绑定，或者去官网上自行下载jSerialComm
注意当前jar包是配合JDK1.8环境使用，如果是1.8以下程序将直接中断
安装虚拟串口的软件 Configure Virtual Serial Port Driver：可以在没有物理意义上的设备时，虚拟出来两个串口，免费使用14天
sscom5.13.1可以通过端口进行发送数据和接收数据的软件
设置发送端，端口使用COM2
同样的设置第二个页面接收页面，接收端设置为COM1
端口连接是否正常 测试通过 测试通过以后再进行代码的编写，不然不利于排除错误。
Java代码读取串口数据 Java代码接收串口传输的数据 package dzz.com; import com.fazecast.jSerialComm.SerialPort; import com.fazecast.jSerialComm.SerialPortDataListener; import com.fazecast.jSerialComm.SerialPortEvent; public class SerialPortReaderData { private SerialPort serialPort; public void openAndReadSerialPort(String portName) { // 查找并打开串口 serialPort = SerialPort.getCommPort(portName); if (serialPort.openPort()) { System.out.println("Port is open: " + portName); // 设置串口参数（这些参数应该与你的设备相匹配） serialPort.setBaudRate(9600); serialPort.setNumDataBits(8); serialPort.setNumStopBits(SerialPort.ONE_STOP_BIT); serialPort.setParity(SerialPort.ODD_PARITY); try { //休眠，因为防止过度的循环 Thread.sleep(1000L); } catch (InterruptedException e) { closeSerialPort(); } boolean flag=false; StringBuffer sb= new StringBuffer(); while(serialPort.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310704ee76840d5f8408f886cfca3aa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa91e5c3554fee01f8ac597a94377c1f/" rel="bookmark">
			web学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端 什么是前端 前端：前端即网站前台部分，是运行在PC端、移动端等浏览器上展现给用户浏览的网页,前端是用户所看到的，包括按钮、复选框、图形和文本消息等视觉元素。
前端的工作原理 用户可以直接与之交互的图形用户界面（GUI），例如导航菜单、设计元素、按钮、图像和图表。采用技术术语，用户看到的带有多个 UI 组件的页面或屏幕称为文档对象模型（DOM）。
三种主要的计算机语言（前端三剑客）会影响用户与前端的交互方式：
HTML 定义前端结构和不同的 DOM 元素层叠样式表（CSS）定义 Web 应⽤程序的样式，包括布局、字体、颜⾊和视觉样式JavaScript 通过操作 DOM 增加⼀层动态功能 JavaScript 可以触发页面上的更改并显示新信息。这意味着前端可以处理基本的⽤户交互（或请求），例如显示日历或检查用户是否输入有效的电子邮件地址。
前端的作用： 交互：当用户与界面进行交互时，前端负责捕获这些交互（如点击按钮或提交表单），并将它们转换为后端可以理解的请求。然后，前端会接收后端返回的响应，并更新用户界面以反映这些变化。
用户界面设计：前端可以创建与用户进行交互的界面。包括布局、颜色、字体、图标等视觉元素的设计，以及如何响应用户的各种输入，如点击、输入文本等。
后端 什么是后端 后端：后端是处理请求，数据，逻辑和与前端（用户界面）进行交互的服务器端部分。
后端的工作原理 后端用于管理 Web 应用程序的整体功能。当用户与前端交互时，此交互会以 HTTP 格式向后端发送请求。后端处理请求并返回响应。
后端的组成 一个简单的后端由，服务器，数据库，操作系统，中间件，API，源码等组成。
浏览器 浏览器是指一种用于显示网页内容的应用程序，通过HTTP或HTTPS协议与网页服务器交互并获取网页，在用户设备上以图形化界面展示。
浏览器的基本功能 用户界面：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示请求的页面外，其他所有显示的页面元素都属于用户界面。
浏览器引擎：在用户界面和渲染引擎之间传送指令。
渲染引擎：负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。
网络组件：负责网络调用，如HTTP请求。它包括了平台无关的接口，下层通过平台相关的接口实现，接口通常以库的形式提供。
JavaScript解释器：用于解析和执行JavaScript代码，使得网页具有交互性。
数据存储：浏览器需要在硬盘上保存各种各样的数据，例如Cookie。新的HTML规范（如HTML5）定义了“网络存储”的API，这是一种更安全、更强大的数据存储方法。
UI后端：用于绘制基本的窗口小部件，如组合框和窗口。这个后端公开了与平台无关的通用接口，而在底层使用操作系统的用户接口方法。
小提问：当你在浏览器的地址栏中输入URL后到页面显示出来之前发生了什么？ 查看缓存：浏览器会查看浏览器缓存，操作系统缓存，本地dns缓存，ISP缓存等，如果找到缓存，就会直接发送请求。DNS解析：当浏览器找不到缓存时，本地dns服务器会向根域名服务器发送请求，根域名服务器返回查询某个顶级域名服务器；再向顶级域名服务器发送请求，返回查询某个权限域名服务器；再向权限域名服务器发送请求，返回需要的IP地址。获取端口号。建立tcp连接：三次握手。发送http请求：发送端在不同的体系层给数据增添首部，接收端删除首部。释放tcp连接：四次挥手。 假设你要查询www.baidu.com的IP地址:
（1）首先会查找浏览器的缓存，看看是否能找到www.baidu.com对应的IP地址，找到就直接返回，否则进行下一步。 （2）将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步。 （3）本地DNS服务器向根域名服务器发送请求，根域名服务器返回负责.com的顶级域名服务器的IP地址的列表。 （4）本地DNS服务器再向其中一个负责.com的顶级域名服务器发送一个请求，返回负责.baidu的权威域名服务器的IP地址列表。 （5）本地DNS服务器再向其中一个权威域名服务器发送一个请求，返回www.baidu.com所对应的IP地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d216a738511938e26e5a45ac40de7a/" rel="bookmark">
			新质生产力：AI大模型在制造业的深度融合与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TONGDA
在当今这个快速变化的工业时代，制造业正站在一个新的历史起点。
随着国家对“人工智能+”战略的深入推进，制造业的数字化转型已成为推动产业升级、提升国际竞争力的关键力量。
在这个转型的浪潮中，大模型技术以其卓越的理解和生成能力，为制造业带来了革命性的变革机遇。
在大模型之前，AI在工业的应用有“一场景一训练一模型”的局限，而大模型的出现，其泛化能力不仅能有效提升AI在工业的应用场景，而且有望形成“基础模型+各类应用”的新范式。
那么，大模型在制造业的应用场景究竟有哪些？它们又是如何改变我们的制造方式的呢？接下来，让我们一起探索大模型在制造业的魅力所在，看看它们如何为制造业注入新的活力，引领我们走向更加智能、高效的制造未来。
01
工业文档智能问答
在工业领域，工程师、销售、客服等人员经常需要查阅大量的技术文档、操作手册和维护指南来解决工作中遇到的问题。传统的文档检索方式耗时且效率低下，而基于检索增强生成（RAG）技术方案的智能问答系统，能够极大地提高这一过程的效率和准确性。
1.即时技术问题解答
利用RAG技术，工程师可以通过自然语言直接向系统提问有关技术细节、故障诊断或操作步骤的问题。系统能够理解问题的上下文，并从大量的工业文档中检索相关信息，生成精确的答案，从而加快问题解决的速度。 2.维护与支持的智能化
对于日常的设备维护和故障排除工作，智能问答系统可以提供即时的指导和建议。系统不仅能够检索到相关的维护文档，还能够根据历史案例和解决方案生成操作步骤，帮助技术人员快速定位并解决问题。 3.客户服务与支持的增强
智能问答系统不仅服务于内部人员，还能作为客户服务的强大工具。客户可以通过系统查询产品的使用指南、维护建议和故障排除方法。此外，系统能够根据客户的反馈和查询历史，提供个性化的服务和支持，从而提升客户满意度和忠诚度。企业的客户服务团队也可以利用这一系统，更高效地处理客户咨询，快速解决问题，确保客户获得及时、准确的帮助。通过这种方式，智能问答系统成为了企业与客户之间沟通的重要桥梁，提升了整体的客户服务水平。 4.人力资源
在人力资源管理场景中，智能问答系统的应用可以极大地提升HR部门的工作效率，同时改善员工的工作体验。通过利用大数据和自然语言处理技术，系统能够实时响应员工关于福利政策、培训资源、考核标准等企业办公制度方面的查询，从而使人力资源管理更加高效和透明。 (RAG智能问答工作原理)
通答AI基于企业数据的智能问答系统是一个统一的知识来源，通过直观的搜索和聊天界面，使企业用户能够快速定位、检索和处理企业数据和见解，具备以下特征：
确定性响应：系统对特定输入会产生可预测和确定的输出，不会出现随机性或变化。
可追溯到基本事实：系统的输出可以追溯到真实的事实或数据来源，具有可追溯性和可验证性。
企业访问控制：涉及企业对于数据和资源访问的控制和管理，以确保安全和合规性。
无LLM导致的数据泄露：系统不会因为使用大型语言模型（LLM）而导致数据泄露，这样可以保护数据的安全。
无幻觉：系统输出不会出现虚假或不实的信息，保持真实和可信度。
LLM不可知：系统不依赖于大型语言模型的具体工作方式和内部结构。
客户案例：提升制造业安装与维护效率
客户背景
一家大型跨国制造集团，在全球31个工厂生产产品，该公司不仅拥有庞大的内部和第三方分销渠道，还提供安装和维护服务，由超过200名内部现场工程师和数千名第三方现场操作员共同执行。此外，一个独立的客户服务部门为内部和第三方支持团队提供远程协助，以完成安装和维护任务。
挑战
在采用通答 AI之前，现场团队经常难以访问公司数千种不同产品设备和服务信息。现场工程师在执行安装任务时，常因搜索冗长的设备手册中的特定安装指导而遭遇延误，而客户服务代理必须手动识别正确的设备型号并回答具体问题，以最有效地支持现场团队。
解决方案
该制造公司选择利用通答AI 实时问答系统简化信息获取，选择该平台是因其特定于领域的架构、企业级安全标准和快速部署能力。
通答 AI开发者和客户专家组成的联合团队在不到2天的时间内配置了应用程序，并向选定的远程服务操作员开放。在这2天的部署过程中，团队上传并索引了超过40份每份80页的设备手册，优化了搜索性能，并向外地和客户服务团队添加了17名用户进行试点。
成果
在其首周推出期间，通答AI 实时问答系统被公司的现场工程师广泛使用，总共处理了超过300个用户查询。使用通答AI 实时问答系统，现场安装团队查找信息所需的时间缩短了90％以上，使现场工程师能够将焦点转移到关键的安装和维护任务上。
下一步
在初步有限部署之后，该制造集团现在正在努力将通答AI 实时问答系统扩展到其业务的更多领域，通过扩大用户基础和设备范围、增加额外的语言支持（如法语）以及引入更多结构化数据源以解锁更多用例，进一步提升服务效率和客户满意度。
此案例展示了通答AI 实时问答系统如何为制造业提供创新解决方案，通过简化信息访问，显著提升现场工程师的工作效率，进而优化了整个安装和维护流程，为企业带来了显著的时间和成本节约。
02
自动化工业文档与内容创作
在工业领域，内容创作和文档生成是日常工作的重要组成部分，涉及技术手册编写、操作指导、维护指南等多个方面。这些任务传统上需要大量的人工编写和校对，耗时且容易出错。现在，借助先进的大模型能力，这些工作可以通过更加智能化的方式自动完成，大幅提升效率和质量。
1.技术手册与用户指南的自动撰写
通过自然语言处理技术，可以自动从技术参数和产品功能描述中提取关键信息，生成详尽且易于理解的技术手册和用户指南。这不仅加快了文档的编写速度，还确保了信息的准确性和一致性，为用户提供了清晰的操作指导。 2.维护文档与故障排除向导的生成
针对设备的维护和故障排除，智能化技术能够根据历史维护数据和常见问题，自动编制维护流程和故障处理指南。这样的文档能够帮助维护人员快速定位问题并采取相应措施，减少设备停机时间，提高生产效率。 3.生产与市场分析报告自动化编制
利用自然语言处理技术，可以从生产数据和市场动态中提取洞察，自动生成详细的分析报告。这些报告为管理层提供了及时的数据支持，帮助他们做出更加明智的决策，同时也为市场策略的调整提供了依据。 4.培训材料与模拟操作场景的创建
智能化技术还可以用于创建培训材料和模拟操作场景，使得员工培训更加高效和实用。通过模拟真实的工作流程和场景，员工可以在短时间内掌握必要的操作技能和应急处理方法，提高了培训的效果和员工的工作效率。 通过这些智能化的应用，工业领域的文档编写和内容创作变得更加高效、准确，为企业节省了大量的时间和资源，同时也提高了工作质量。随着技术的不断发展，这种自动化和智能化的趋势将在工业领域发挥越来越重要的作用。
03
工业产品设计创新与优化
在工业产品设计领域，大模型技术的应用正引发一场深刻的变革。通过整合先进的大模型技术，设计师们现在能够以前所未有的速度和效率进行创新和设计工作。这种技术不仅加速了从概念到原型的转变，而且极大地提高了设计的多样性和质量。
大模型技术通过其强大的图像生成和理解能力，使得设计师能够快速将抽象的设计概念转化为具体的视觉表现。设计师仅需提供简单的文字描述或初步的草图，大模型即可自动生成一系列详细设计方案和高保真度的设计效果图。这一过程不仅极大地缩短了设计时间，还允许设计师探索更多可能性，从而推动创新思维的边界。
1.产品外观设计
利用大模型的生成能力，设计师可以通过简单的文字描述或草图输入，迅速获得高保真度的设计效果图。这些效果图不仅能够满足个性化需求，还为设计师提供了丰富的选择空间和灵感来源，从而加速设计过程并提高设计质量。
2.研发设计软件辅助
大模型与CAD软件的结合，使得设计师能够更高效地进行工程制图和布局规划。大模型可以根据历史设计数据和用户的特殊要求，自动生成多种设计方案，同时提供快速优化调整的建议，帮助工程师减少错误、节省时间，并提高设计的精确度和可靠性。
行业案例： "海尔集团利用大模型技术加速家电产品设计创新”
作为一家全球领先的家电和消费电子制造商，海尔集团一直致力于通过创新推动工业设计和智能制造的发展。在大模型技术的应用上，海尔展现了其对前沿科技的积极探索和应用能力，为客户提供了更加高效和个性化的产品设计解决方案。
在海尔的实践案例中，大模型技术被应用于加速新产品的研发流程，并提升设计的创新性。通过与大模型技术的结合，海尔的设计团队能够在最短的时间内，根据市场需求和消费者偏好，快速生成多种设计方案。设计师仅需提供初步的设计概念或消费者反馈，大模型即可自动生成一系列详细的设计效果图和三维模型，这些设计方案不仅涵盖了产品的外观，还包括了用户界面、交互体验等多个方面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d216a738511938e26e5a45ac40de7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0c4c5b62abc77bf65dfd9fc0e0c498/" rel="bookmark">
			【数据结构】快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序是通过对序列不断划分，把原始序列以划分元素为界形成两个子序列，再对子序列重复划分的过程。这是一个递归的过程，终止条件就是最终所有的子序列都只含有一个元素。
首先需要一个数组序列，再对其进行划分（重点就是划分）。每次划分都需要设置前后两个指针（low和high），两个指针依次往中间位置移动，当指针重合时，结束这一次划分，还需要设置一个枢轴（temp）。最后的结果分三块，第一块的元素都小于第二块元素，第三块都大于第二块。所以第一次划分大概如下图：
现在讲一下两个指针是如何将序列划分的：先是从high指针往前走，如果high指针所指向的数比枢轴（temp）大的话则继续往前走，直到碰见比枢轴小的数时将这个high指针所指向的数复值给low指针指向的位置。接着就从low指针开始往后走，当遇见比枢轴（temp）大的数就将low指针所指向的数复值给high现在指向的位置。重复以上操作，直至high和low指针指向同一个位置是停止上面的操作，但是需要将枢轴（temp）的数复值给这个位置上的数。这样就出现了三块序列。
int partition(int arr[], int low, int high) { int temp = arr[low]; while (low &lt; high) { while (arr[high] &gt;= temp &amp;&amp; low &lt; high) { high--; } if (arr[high] &lt; temp) { arr[low] = arr[high]; low++; } while (arr[low] &lt;= temp &amp;&amp; low &lt; high) { low++; } if (arr[low] &gt; temp) { arr[high] = arr[low]; high--; } } arr[low] = temp; return low; } 再接下来就是重复操作，从第一块中再分三块，也需要前后指针以及枢轴。我就不再重复了，就划分好的序列画出来：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc0c4c5b62abc77bf65dfd9fc0e0c498/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f7c7bbfc463e5c9a75d71154e1e8ae/" rel="bookmark">
			SpringBoot整合Netty(服务端)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作场景:使用Netty长连接实时获取第三方接口的车辆定位数据
开发环境:JDK8
Netty基本介绍 一、什么是Netty Netty是由JBOSS提供的一个Java开源框架，现为Github上的独立项目。它是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序。Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。
Netty提供了一套完整的API，用于处理网络IO操作，如TCP和UDP套接字。它封装了底层的网络编程细节，使得开发者可以更加专注于业务逻辑的实现。Netty使用了一种高效的线程模型，可以处理大量的并发连接，并且具有很好的伸缩性。
Netty在多个领域都有广泛的应用，如RPC框架、游戏行业、大数据领域等。它支持多种传输类型和协议，如阻塞和非阻塞、基于BIO和NIO的UDP传输、本地传输（in-VM传输）、HTTP通道等。同时，Netty还提供了丰富的编解码器，用于处理各种协议的编解码操作。
Netty的整体结构包括核心层和协议支持层。核心层提供了底层网络通信的通用抽象和实现，包括可扩展的事件模型、通用的通信API、支持零拷贝的ByteBuf等。协议支持层则覆盖了主流协议的编解码实现，如HTTP、SSL、Protobuf等。
总的来说，Netty是一个功能强大、易于使用的网络应用框架，它可以帮助开发者快速构建高性能、高可靠性的网络应用程序。
二、Netty核心组件 Netty的核心组件主要包括以下几个部分：
Channels：Channel是Netty网络通信的抽象，用于进行I/O操作。它可以被看作是Java NIO的一个基本抽象，代表了与硬件设备、文件、网络socket等实体的开放连接，或者是一个能够完成读、写等I/O操作的程序。Channel可以被打开或关闭，连接或断开。Callbacks（回调）：Callback是一个方法，它是提供给另一个方法的引用，使得另一个方法可以在适当的时候回过头来调用这个Callback方法。Callback在很多编程情形中被广泛使用，是用于通知相关方某个操作已经完成最常用的方法之一。Futures：在Netty中，Futures用于异步I/O操作的结果。当一个异步操作开始时，会立即返回一个Future，这个Future会在操作完成时得到结果或者异常。Handlers：Handlers是Netty中处理I/O事件或拦截I/O操作的组件。Netty提供了许多内置的Handler，如ChannelInboundHandler、ChannelOutboundHandler等，这些Handler可以处理各种I/O事件，如连接建立、数据接收、异常处理等。Bootstrap与ServerBootstrap：Bootstrap和ServerBootstrap是Netty程序的引导类，主要用于配置各种参数并启动整个Netty服务。它们都继承自AbstractBootstrap抽象类，不同的是，Bootstrap用于客户端引导，而ServerBootstrap用于服务端引导。EventLoopGroup：EventLoopGroup可以理解为一个线程池，用于处理I/O操作。在服务端程序中，一般会绑定两个EventLoopGroup，一个用于处理Accept事件（即新的连接请求），另一个用于处理读写事件。 以上这些组件共同构成了Netty的核心框架，使得开发者可以更加专注于业务逻辑的实现，而无需过多关心底层的网络通信细节。
三、SpringBoot与Netty整合 1. 添加依赖 在SpringBoot项目的pom.xml文件中，我们需要添加Netty的依赖。Netty的官方Maven仓库地址为：https://mvnrepository.com/artifact/io.netty/netty-all
&lt;dependencies&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- netty --&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mybatis-plus.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.创建Netty服务端 @Component public class NettyServer { //负责处理接受进来的链接 private EventLoopGroup bossGroup; //负责处理已经被接收的连接上的I/O操作 private EventLoopGroup workerGroup; //在这个场景中，它表示服务器的绑定操作的结果 private ChannelFuture future; @PostConstruct public void startServer() throws Exception { bossGroup = new NioEventLoopGroup(); workerGroup = new NioEventLoopGroup(); try { //创建ServerBootstrap,这个类封装了服务器端的网络配置，使得我们可以轻松地设置服务器参数 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f7c7bbfc463e5c9a75d71154e1e8ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8abf5e84582085900c4abe779e27379c/" rel="bookmark">
			引领“工作流时代”的AI绘画工具！Comfyui零基础入门操作教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是画画的小强
本期教程将带你轻松了解官方版Comfyui的工作流界面基本使用方式、模型下载上传、工作流上传等操作
前言
Comfyui，一款基于节点式工作流的WebUI，提供了精确的工作流定制和高效的图像生成性能。本期，将给大家带来Comfyui入门基础教学。
首先，我们需要在电脑上安装ComfyUI这款AI绘画软件，安装部署请看我往期教程这大概是最好用的AI绘画软件！comfyui一键启动整合包来了
ComfyUI同样也是Stable Diffusion的母公司StabilityAI旗下开源的AI绘画工作流形式的AI绘图软件，它拥有更快的出图速度，更节省电脑配置等优点。但同样的，学习成本对于Stable Diffusion来说，会难上一些！
01、工作流界面操作
进入Comfyui应用后，先来看看整个工作流操作界面
官方操作界面的使用语言是英文，这并不方便我们操作工作流。但是应用里面内置了官方中文，点击右边操作栏的齿轮按钮进入设置页面
然后往下拖动页面找到AGLTranslation-language，将English修改成中文
应用自动刷新，整个操作界面就会变成中文面板。消除了语言障碍，这样就可以正式使用Comfyui了
修改完语言选项后，先来讲讲最基本且最实用的操作控制吧。
使用鼠标滚轮进行放大缩小界面
在界面空白处，按住鼠标左键或中间可以拖动界面
鼠标左键按住并拖动节点工作区可在界面移动
左键双击空白界面，调出快捷搜索选项
鼠标左键按住并拖动工作区之间相应的输入和输出点以形成连接
在首次启动 Comfyui，会看到这个界面是默认的文本生成图像的**Workflow（工作流）**界面
而Checkpoint加载器是修改我们“大模型”的地方
“大模型”：影响图像生成的风格
将Checkpoint选择为juggernaut模型，其他参数保持不变，点击右侧的添加提示词队列，就会生成一个较为写实的紫色星空杯。
提示词：beautiful scenery nature glass bottle landscape, purple galaxy bottle
模型：juggernautXL_v8Rundiffusion
而将现模型更换为animapencil，生成出来的图像则会偏漫画风格一些。而通过演示，我相信大家对“大模型”也有了个初步了解
模型：animaPencilXL_v100
工作流界面中的两个文本编码器，上方的是输入正向提示词，下方的是反向负面提示词，
正向提示词是你希望在图像会生成的东西
反向提示词则是图像里面你不希望生成的东西
这里给大家提供一个万能的负面提示词：
lowres, bad anatomy, bad hands, ((text)), (watermark), error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, ((username)), blurry, (extra limbs)
空Latent则是修改生成图像分辨率大小和图像生成张数
K采样器影响的是整体图像的变化
这里主要调整的是步数和CFG参数，步数参数越高生成的图像就显得更加精致，反之则会更加简洁
“步数”：20 “CFG”：8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8abf5e84582085900c4abe779e27379c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3ce75c75116e50e3f205ff7d131cb8/" rel="bookmark">
			漫画|基于SprinBoot&#43;vue的漫画网站(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漫画网站
目录
基于SprinBoot+vue的漫画网站
一、前言
二、系统设计
三、系统功能设计 1系统功能模块
2管理员功能模块
3用户功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SprinBoot+vue的漫画网站 一、前言 首先,论文一开始便是清楚的论述了系统的研究内容。其次,剖析系统需求分析,弄明白“做什么”,分析包括业务分析和业务流程的分析以及用例分析,更进一步明确系统的需求。然后在明白了系统的需求基础上需要进一步地设计系统,主要包括软件架构模式、整体功能模块、数据库设计。本项目软件架构选择B/S模式和java技术，总体功能模块运用自顶向下的分层思想。再然后就是实现系统并进行代码编写实现功能。论文的最后章节总结一下自己完成本论文和开发本项目的心得和总结。通过漫画网站将会使漫画信息管理各个方面的工作效率带来实质性的提升。
关键字：java 漫画 软件架构
二、系统设计 系统功能结构如图
三、系统功能设计 1系统功能模块 漫画网站，在系统首页可以查看首页、漫画投稿、排行榜、交流论坛、公告信息、个人中心、后台管理等内容，并进行详细操作，如图5-1所示。
图5-1系统首页界面图
用户注册，在用户注册页面通过填写用户账号、密码、确认密码、用户姓名、联系方式等信息进行注册操作，如图5-2所示。
图5-2用户注册界面图
2管理员功能模块 管理员进行登录，进入系统前在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行登录操作，如图5-5所示。
图5-5管理员登录界面图
3用户功能模块 用户登录进入漫画网站可以对首页、个人中心、漫画投稿管理等进行相应操作，如图5-14所示。
图5-14用户功能界面图
四、数据库设计 漫画投稿实体图如图4-2所示：
图4-2漫画投稿实体图
数据库表的设计，如下表：
表4-1：收藏表
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
userid
bigint
用户id
refid
bigint
收藏id
tablename
varchar
200
表名
name
varchar
200
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc3ce75c75116e50e3f205ff7d131cb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df03b31d26d6b20aa449274b63acb56c/" rel="bookmark">
			DFS：解决二叉树问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 了解DFS1.计算布尔二叉树的值思路代码展示 2.求根节点到叶节点数字之和思路代码展示 3.二叉树剪枝思路代码展示 4.验证二叉搜索树思路分析代码展示 5.二叉搜索树中第k小元素思路：代码展示 6.二叉树的所有路径思路分析代码展示 总结 了解DFS 所谓DFS就是就是深度优先搜索，首先我们回到我们以前学习过的二叉树，对于二叉树我们讲过深度优先遍历，也就前序，后序，中序，这三种遍历方式，对于深度优先搜索，深度优先遍历是一个过程，在这个过程中我们加上搜索。
在一颗二叉树上，对于遍历来说，我们会一条路走到黑，直到走到空的节点为止，才会返回上一个节点，走另一个分支，但是对于DFS（深度优先搜索）来说，我们的目的是、搜索当中的值，而不是一味地遍历。
接下来我们通过几道题来深入理解这个算法
1.计算布尔二叉树的值 首先我们来理解题意，题意很简单就是在一颗二叉树中只有0，1，2，3这几个值，他们分别代表的是false true || &amp;&amp;，我们来看看实际的一颗树：
右边这颗二叉树就可以投影成左边这颗树的样子。
接下来我们来分析一下这个道题应该怎么做：
思路 首先这道题说了这颗树是完整的二叉树，意思就是所有节点要么一个节点都没有，要么就是有两个节点。我们再来看这颗树的特征：非叶子节点肯定是2或者3，叶子节点肯定是1或者0，所以这里划分就出来了，我们对叶子节点和非叶子节点做不同的处理，如果是叶子节点就直接返回当前节点的值，如果不是叶子节点就判断一下该节点的值，如果是2就对左子树和右子树进行||操作，反之则进行&amp;&amp;操作即可。
函数头
函数头：bool dfs(root)
函数体
遇到叶子节点返回叶子节点的值，遇到非叶子节点，对左子树和右子树进行递归操作。
递归出口
就是返回叶子节点的值
代码展示 class Solution { public: bool evaluateTree(TreeNode* root) { //只用判断一边就可以 if(root-&gt;right==nullptr) { //叶子节点直接返回值 return root-&gt;val; } //得到左子树的结果 bool left=evaluateTree(root-&gt;left); //得到右子树的结果 bool right=evaluateTree(root-&gt;right); //判断一下当前节点的值是2还是3，进行&amp;&amp;操作还是||操作 return root-&gt;val==2?left||right:left&amp;&amp;right; } }; 2.求根节点到叶节点数字之和 题目解释：
首先我们先给出一棵树
对于这棵树并不是说所有节点的和就是把所有节点的值加起来，而是，我们先看第一个路径，4--9--5对于这个路径来说，这个路径下对应的和就是495，第二个路对应的是491，第三个路径对应的是40.
从下面图应该可以看出：
思路 对于这道题，我们先来走一遍，当我们进入根节点4的时候，我们先递归左子树，我们肯定必须要知道前面的和是多少，因为我们要计算下一个节点的和，所以必须知道前面节点的和是多少，所以这里我们传递的参数就多了一个presum（前驱和）
函数头
函数头：int dfs(root,presum)
因为这道题要求返回所有路径的和，所以有一个返回值就是int
函数体
这里我们来想一下函数体是什么？
我们把presum传进行，当进入根节点的时候肯定不能带值，因为根节点的前驱和是0，所以这里我们传参的话，传presum进去先是0，进了函数之后我们先更新一下这个 presum，presum=presum*10+root-&gt;val,更新了presum之后，判断一下这个节点是否是叶子节点，如果是叶子节点直接返回presum，因为如果是叶子节点的话就说明这个路径的和已经求完了，只需要求下一个路径的和就可以了，这里我们用一个ret来存放一下左子树和右子树的和，如果左子树不为空，则返回将左子树的和加在ret上，如果右子树不为空，则再将右子树的和加在ret上，最后返回ret。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df03b31d26d6b20aa449274b63acb56c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1b96bccaa5535c48dec2e8e2ae4ffb/" rel="bookmark">
			Spark Sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SparkSQL 是什么 SparkSQL 可以简化 RDD 的开发，提高开发效率，且执行效率非 常快，所以实际工作中，基本上采用的就是 SparkSQL。Spark SQL 为了简化 RDD 的开发， 提高开发效率，提供了 2 个编程抽象，类似 Spark Core 中的 RDD。DataFrame与DataSet
DataFrame 在Spark中，DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表格，也很像pyhton中的pandas,DataFrame与RDD的主要区别在于，前者带有schema元信息(更关注于每一列的属性)，即DataFrame所表示的二维表数据集的每一列都带有名称和类型。这使得Spark SQL得以洞察更多的结构信息，从而对藏于DataFrame背后的数据源以及作用于DataFrame之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观RDD，由于无从得知所存数据元素的具体内部结构，Spark Core只能在stage层面进行简单、通用的流水线优化。
同时，与Hive类似，DataFrame也支持嵌套数据类型（struct、array和map）。从 API 易用性的角度上看，DataFrame API提供的是一套高层的关系操作，比函数式的RDD API 要更加友好，门槛更低。
上图直观地体现了DataFrame和RDD的区别。
左侧的RDD[Person]虽然以Person为类型参数，但Spark框架本身不了解Person类的内部结构。而右侧的DataFrame却提供了详细的结构信息，使得 Spark SQL 可以清楚地知道该数据集中包含哪些列，每列的名称和类型各是什么。
DataFrame是为数据提供了Schema的视图。可以把它当做数据库中的一张表来对待
DataFrame也是懒执行的，但性能上比RDD要高，主要原因：优化的执行计划，即查询计划通过Spark catalyst optimiser进行优化。比如下面一个例子:
为了说明查询优化，我们来看上图展示的人口数据分析的示例。图中构造了两个
DataFrame，将它们join之后又做了一次filter操作。如果原封不动地执行这个执行计划，最终的执行效率是不高的。因为join是一个代价较大的操作，也可能会产生一个较大的数据集。如果我们能将filter下推到 join下方，先对DataFrame进行过滤，再join过滤后的较小的结果集，便可以有效缩短执行时间。而Spark SQL的查询优化器正是这样做的。简而言之，逻辑查询计划优化就是一个利用基于关系代数的等价变换，将高成本的操作替换为低成本操作的过程。
DataSet DataSet是分布式数据集合。DataSet是Spark 1.6中添加的一个新抽象，是DataFrame的一个扩展。它提供了RDD的优势（强类型，使用强大的lambda函数的能力）以及Spark SQL优化执行引擎的优点。DataSet也可以使用功能性的转换（操作map，flatMap，filter
等等）。
➢ DataSet是DataFrame API的一个扩展，是SparkSQL最新的数据抽象
➢ 用户友好的API风格，既具有类型安全检查也具有DataFrame的查询优化特性；
➢ 用样例类来对DataSet中定义数据的结构信息，样例类中每个属性的名称直接映射到
DataSet中的字段名称；
➢ DataSet是强类型的。比如可以有DataSet[Car]，DataSet[Person]。
➢ DataFrame是DataSet的特列，DataFrame=DataSet[Row] ，所以可以通过as方法将
DataFrame转换为DataSet。Row是一个类型，跟Car、Person这些的类型一样，所有的表结构信息都用Row来表示。获取数据时需要指定顺序
RDD 、 DataFrame 、 DataSet 三者的关系 这三者是可以相互转化的
三者的共性 ➢ RDD、DataFrame、DataSet全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c1b96bccaa5535c48dec2e8e2ae4ffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0930d6375635e3502546904f0a78277/" rel="bookmark">
			普通人如何通过AIGC逆风翻盘？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终身学习:
利用AI辅助的在线教育平台,如Coursera、edX、Khan Academy等,学习新技能或提升现有技能。尝试使用AI驱动的语言学习应用,如Duolingo、Rosetta Stone等,提高语言能力。探索AI辅助的编程学习平台,如Codecademy、LeetCode等,学习编程语言和算法。 职业发展:
了解AI在你所处行业中的应用,如医疗、金融、教育、制造业等。参加AI相关的在线课程或研讨会,学习AI技术及其在职业中的应用。考虑获得AI相关的认证或学位,如数据科学、机器学习等。 自动化日常任务:
使用AI助手,如Google Assistant、Amazon Alexa等,自动化日程管理、提醒事项等。利用AI工具,如Grammarly、Hemingway等,自动化邮件和文档的语法检查和编辑。使用AI驱动的项目管理工具,如Trello、Asana等,自动化任务分配和进度跟踪。 增强创造力:
利用AI设计工具,如Adobe Sensei、Canva等,辅助设计和排版。使用AI写作助手,如Jasper、Copy.ai等,获取写作灵感和建议。尝试AI音乐创作工具,如AIVA、Amper Music等,创作独特的音乐作品。 数据分析:
学习基本的数据分析技能,如Python、R、SQL等。利用AI驱动的数据分析工具,如Tableau、Power BI等,洞察业务趋势和消费者行为。探索AI预测分析工具,如Google Analytics、IBM Watson等,预测市场趋势。 健康管理:
使用AI驱动的健康应用,如Fitbit、Apple Health等,监测身体状况和运动数据。尝试AI营养助手,如MyFitnessPal、Noom等,获取个性化的饮食建议。利用AI心理健康应用,如Woebot、Wysa等,改善情绪和缓解压力。 投资和理财:
利用AI投资顾问,如Betterment、Wealthfront等,获取投资建议和资产配置。使用AI驱动的股市分析工具,如Yahoo Finance、Stocktwits等,进行市场分析。探索AI加密货币交易平台,如Coinbase、Binance等,了解加密货币投资。 社交网络:
利用AI社交媒体分析工具,如Hootsuite、Brandwatch等,分析社交网络数据。使用AI驱动的网络分析工具,如LinkedIn Sales Navigator等,建立和维护职业联系。尝试AI聊天机器人,如ManyChat、Chatfuel等,自动化社交媒体互动。 创业:
考虑创办一个利用AI技术解决特定问题的初创公司。加入一个AI驱动的创业团队,贡献你的技能和知识。探索AI相关的创业孵化器和加速器项目,如Y Combinator、Techstars等。 个人品牌建设:
利用AI工具,如BuzzSumo、SEMrush等,分析社交媒体趋势和受众兴趣。使用AI内容创作工具,如Canva、Headline Analyzer等,创建吸引人的内容。尝试AI社交媒体管理工具,如Buffer、Hootsuite等,自动化内容发布和互动。 内容创作:
利用AI写作助手,如Jasper、Copy.ai等,辅助内容创作和编辑。使用AI视频编辑工具,如Adobe Premiere Rush、Magisto等,快速制作视频。尝试AI音频编辑工具,如Descript、Lumen5等,创建音频和播客内容。 职业转型:
利用AI职业规划工具,如LinkedIn Learning、Coursera等,探索新的职业路径。参加AI相关的职业转型培训项目,如谷歌的"Grow with Google"等。考虑获得AI相关的认证或学位,如数据科学、机器学习等,以支持职业转型。 网络课程:
参加由AI辅助的网络课程,如Coursera的"AI for Everyone"等。尝试AI自适应学习平台,如DreamBox、Photomath等,根据你的学习进度调整难度。探索AI驱动的在线实验室和模拟环境,如Microsoft Reactor等,进行实践学习。 利用AI进行决策:
利用AI分析工具,如Tableau、Power BI等,进行数据驱动的决策。使用AI预测分析工具,如Google Analytics、IBM Watson等,预测未来趋势。尝试AI决策支持系统,如Decision Mapper、SWOT分析器等,辅助复杂决策。 持续探索:
保持对AI最新发展和应用的关注,了解AI如何影响你的生活和工作。加入AI相关的在线社区和论坛,如Reddit的r/artificial、LinkedIn的AI群组等,与他人交流和学习。参加AI相关的会议和研讨会,如NeurIPS、CVPR等,了解行业趋势和最新研究。 总之,普通人可以通过终身学习、职业发展、自动化、创造力、数据分析、健康管理、投资、社交网络、创业、个人品牌、内容创作、职业转型、网络课程、决策支持和持续探索等途径,充分利用AI翻盘。关键是保持开放的心态,不断学习和探索,将AI融入你的生活和职业发展中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163ff143af16144e9ea4f509d923a47d/" rel="bookmark">
			同样的APP为何在Android 8以后网络感觉变卡？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
在无线网络技术不断发展的今天，Wi-Fi已经成为了我们日常生活中不可或缺的一部分。无论是家庭娱乐、办公还是在线游戏，Wi-Fi都在提供着便捷的互联网接入服务。然而，在安卓8.1后，为了进一步延长安卓设备的待机时间。原生安卓(AOSP等)默认开启了全局省电（低功耗模式），该模式下WIFI芯片通过牺牲网络系统来省电，同时降限制CPU的工作频率。
但是在某些特定的应用场景中，如在线游戏、实时视频会议等，低延迟比高带宽更为重要。为此，Android系统提供了一种名为WIFI_MODE_FULL_LOW_LATENCY的Wi-Fi模式，以及强制激活高性能模式WIFI_MODE_FULL_HIGH_PERF。
一、什么是WIFI_MODE_FULL_HIGH_PERF/WIFI_MODE_FULL_LOW_LATENCY？
WIFI_MODE_FULL_HIGH_PERF/WIFI_MODE_FULL_LOW_LATENCY是Android系统中Wi-Fi的一种模式，它允许设备在连接Wi-Fi网络时获得更高的性能。在这种模式下，设备会尝试使用更高的无线频率和更多的无线通道，从而提高数据传输速率和降低延迟。
二、为什么要开启WIFI_MODE_FULL_HIGH_PERF/WIFI_MODE_FULL_LOW_LATENCY？
1.提高数据传输速率
在WIFI_MODE_FULL_HIGH_PERF/WIFI_MODE_FULL_LOW_LATENCY模式下，设备可以使用更高功耗来处理无线数据，从而提高数据传输速率。这对于需要高速无线网络的场景，如高清视频流媒体、大型文件传输等，具有很大的优势。
2.降低延迟
在网络游戏，VOIP中，延迟对于用户的使用体验至关重要。WIFI_MODE_FULL_HIGH_PERF/WIFI_MODE_FULL_LOW_LATENCY模式可以降低无线网络的延迟，使玩家在游戏中获得更流畅的操作体验。此外，对于实时音视频通话等场景，降低延迟也能提高通信质量。
3.提高网络稳定性
WIFI_MODE_FULL_HIGH_PERF/WIFI_MODE_FULL_LOW_LATENCY模式可以提高无线网络的稳定性，减少因信号干扰等原因导致的网络中断。这对于需要长时间稳定连接的场景，如远程办公、在线教育等，具有很大的帮助。
4.充分发挥设备性能
许多高端智能设备都支持高速无线网络，但默认的Wi-Fi模式可能无法充分发挥其性能。开启WIFI_MODE_FULL_HIGH_PERF/WIFI_MODE_FULL_LOW_LATENCY模式后，设备可以充分利用其硬件资源，提高无线网络性能。
三、使用WIFI_MODE_FULL_HIGH_PERF 还是 WIFI_MODE_FULL_LOW_LATENCY？
虽然WIFI_MODE_FULL_HIGH_PERF 和 WIFI_MODE_FULL_LOW_LATENCY 使用效果基本一致，但是有几个小的不同点需要注意。
1.WIFI_MODE_FULL_HIGH_PERF 在 API level 12中被引入， 但在API level 34中被标记为废弃，在以后得API版本中可能被移除。面对以后构件的代码中可能失效。
WIFI_MODE_FULL_LOW_LATENCY 在API level 29中引入，目前官方建议使用WIFI_MODE_FULL_LOW_LATENCY 替代WIFI_MODE_FULL_HIGH_PERF
2.WIFI_MODE_FULL_LOW_LATENCY 仅当获取应用程序在前台运行时，锁定才处于活动状态。但是WIFI_MODE_FULL_HIGH_PERF 启用后应用在后台状态依然可以保持无线高性能模式运行。
四、代码测试
1.在AndroidManifest.xml 文件中添加所需权限
&lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.WAKE_LOCK"/&gt; 2.在任意一个可以获取context的class内激活高性能模式
import android.net.wifi.WifiManager; import android.net.wifi.WifiManager.WifiLock; import android.os.PowerManager; import android.os.PowerManager.WakeLock; private final String TAG = "LockManager@" + hashCode(); public void onStart() { Context appContext = getApplicationContext(); WifiManager wifiManager = (WifiManager) appContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/163ff143af16144e9ea4f509d923a47d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5924b8737a579a2130b1da348bbe1b93/" rel="bookmark">
			全国最具价值的AIGC培训免费课程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于课程 课程名称 AIGC 驱动的新质电商运营精英实战训练营 课程价格 699元
包含所有学习权益+所有兼职、实习、就业权益 + 中国软件行业协会监制的中国软件行业专业技术能力“AIGC提示词工程师”认证证书。 课程价值 线下两个月16,800元职业培训《AIGC 驱动的新质电商运营精英实战训练营》保就业班线上平替班 授课形式 精品录播
长期持续更新 定期直播
每周一次的直播 圈子论坛
圈子提问、圈子问答、圈子互动 线下沙龙
不定期全国各城市举办线下沙龙 适合人群 电商从业者 希望提升电商运营技能，掌握AIGC前沿技术，实现业绩突破的电商从业人员。 内容创作者 短视频、直播、自媒体等领域的创作者，想要增强创作能力，提高内容质量。 企业主和创业者 希望通过AIGC技术优化电商业务，提升品牌影响力和市场竞争力的企业主和创业者。 数字营销人员 从事数字营销、社交媒体管理、品牌推广等工作，渴望掌握最新AIGC技术和应用的营销人员。 本地生活服务商家 餐饮、零售、娱乐等行业的商家，寻求利用AIGC技术和电商运营提升客户体验和业务增长的商家。 学生和转行人士 对AIGC和电商感兴趣，想要进入这一领域并快速掌握核心技能的学生和转行人士。
在读大学生、在读研究生免费学习
申请渠道，关注元壤教育公众号，点击底部菜单栏“AI训练营”，点击699课程免费申请，填写申请表，24小时以内审核通过。 职场白领和蓝领人士 寻求AI赋能自身岗位和职业，同时希望通过AIGC技术实现碎片化时间兼职的职场人士。 兼职、实习、就业、创业 兼职 元壤平台提供长期稳定的任务型计费派单模式，您可以利用碎片化时间进行长期兼职。
元壤平台还提供长期分佣制的AI切片电商模式，让您在任何有家的地方和有网的地方都能有工作。
元壤为优秀学员提供各种上市公司、大中小型企业的AIGC人才工厂用工兼职模式，提供底薪或底薪+提成的兼职模式。
实习 线上实习，签订实习合同，底薪+绩效模式。
线下企业实习，签订实习合同，底薪+绩效模式。
就业 元壤为学员提供简历指导、简历优化、技术指导、就业服务。 创业 元壤将长期为每一位学员提供创业支持和创业陪跑。 课程8大阶段/板块 按照要求和教程，准备并注册好系列图文、短视频自媒体平台，完成每个平台的账号注册，包括名称规范和介绍规范等。 图文平台
短视频平台
阶段/板块一：AIGC 提示词工程 学完本阶段具备能力
了解全球及中国主流的文本生成模型。 逐一体验全球及中国主流文本生成模型的差异化。 熟练掌握AIGC提示工程中文本生成的原则、规则和技巧。 具备利用AI提示工程进行人机对话创作各种风格和类型的高质量内容的能力。 能够独立思考并设计各种场景的高质量提示词。 具备基于公司或产品介绍，结合人机互动，为该公司或产品提供原创宣传内容的能力。 具备每天利用不到一个小时的零散时间，高质量创作某个垂直内容并分发到20个自媒体平台的能力。 具备为各类公司或企业提供宣传内容创作和分发服务的能力。 学完第一个板块的内容后，针对优秀学员，平台将陆续尝试派发图文种草任务，并按任务计费。 阶段/板块二：AI 切片电商 1.0 教学 学完本阶段具备能力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5924b8737a579a2130b1da348bbe1b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a6d239b238d2b8883a22252b3b08fa/" rel="bookmark">
			滑不动窗口的秘密—— “滑动窗口“算法 (Java版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
前言 学习完了 双指针算法，相比小伙伴应该对我们的 双指针算法 烂熟于心了吧 💖 💖 💖
接下来迎面走来的就是我们的 == “滑动窗口” 算法== ,什么是滑动窗口算法，该怎么用，有哪些特殊的场景，下面就请宝子们和我一起推开 “滑动窗口” 算法的大门吧 💞 💞 💞
目录 滑动窗口的初识
滑动窗口的应用
滑动窗口的结论
一. 滑动窗口的初识 1. 滑动窗口的简介 滑动窗口算法是一种常用的 解决字符串/数组子串问题 的算法。它通过维护一个窗口，该窗口在字符串/数组上滑动，每次滑动一个位置，并根据问题的要求调整窗口的 大小和位置 。
通过不断滑动窗口，可以有效地解决 字符串/数组子串问题 。
滑动窗口算法的基本思想是通过两个指针（左指针和右指针）来定义窗口的边界。
2. 滑动窗口如何使用 初始时，左指针和右指针都指向字符串/数组的 第一个元素 ，然后右指针开始向右移动，直到满足某个 条件（如子串的长度等）时停止。
然后左指针开始向右移动，同时 缩小窗口的大小，直到不满足某个条件时停止。
这样，通过不断地向右移动 右指针 和 左指针，可以在 字符串/数组上 滑动窗口，并根据问题的要求进行相应的 调整和计算。
滑动窗口算法在求解字符串/数组子串问题时具有 高效性 ，因为它将问题的规模由 O(n^2) 降低到O(n) ，而且只需要遍历一次 字符串/数组 。同时，滑动窗口算法也可以解决一些 其他类型的问题，
如求解最长不重复子串、找到满足特定条件的子串等。
鱼式疯言 滑动窗口本质上还是一种 双指针算法 ，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a6d239b238d2b8883a22252b3b08fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3124109d6661d566540ed095d6ce57dd/" rel="bookmark">
			数据结构第一篇【探究List和ArrayList之间的奥秘 】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构第一篇【探究List和ArrayList之间的奥秘 】 前言 List什么是List?List ArrayListArrayList使用ArrayList常见操作ArrayList的遍历ArrayList的扩容机制ArrayList的具体使用 前言 😀😄😁😊🤨🥰😚😗😄🫠😀😄😁😊🤨🥰😗🫢🫠🥰
欢迎开始数据结构的学习,本章讲解List与ArrayList
😀😄😁😊🤨🥰😗🫢🫠🥰😀😄😁😊🤨🥰😗🫢🫠🥰
List 什么是List? 在集合框架中，List是一个接口，继承自Collection。Collection也是一个接口,常用方法如下
站在数据结构的角度来看，List就是一个线性表，即n个具有相同类型元素的有限序列，在该序列上可以执行增删改查以及变量等操作。
List中提供了好的方法，虽然方法比较多，但是常用方法如下：
List 注意：List是个接口，并不能直接用来实例化。
如果要使用，必须去实例化List的实现类。在集合框架中ArrayList和LinkedList都实现了List接口。
ArrayList 在集合框架中，ArrayList是一个普通的类，实现了List接口
【说明】
ArrayList是以泛型方式实现的，使用时必须要先实例化ArrayList实现了RandomAccess接口，表明ArrayList支持随机访问ArrayList实现了Cloneable接口，表明ArrayList是可以clone的ArrayList实现了Serializable接口，表明ArrayList是支持序列化的. 和Vector不同，ArrayList不是线程安全的，在单线程下可以使用，在多线程中可以选择Vector或者CopyOnWriteArrayListArrayList底层是一段连续的空间，并且可以动态扩容，是一个动态类型的顺序表 ArrayList使用 public static void main(String[] args) { // ArrayList创建，推荐写法 // 构造一个空的列表 List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); // 构造一个具有10个容量的列表 List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(10); list2.add(1); list2.add(2); list2.add(3); // list2.add("hello"); // 编译失败，List&lt;Integer&gt;已经限定了，list2中只能存储整形元素 // list3构造好之后，与list中的元素一致 ArrayList&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(list2); // 避免省略类型，否则：任意类型的元素都可以存放，使用时将是一场灾难 List list4 = new ArrayList(); list4.add("111"); list4.add(100); } ArrayList常见操作 ArrayList虽然提供的方法比较多，但是常用方法如下所示:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3124109d6661d566540ed095d6ce57dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f1f3b5eab835f38b955ca7d6bf2603/" rel="bookmark">
			一键部署！QQ AI 聊天机器人！支持ChatGPT、文心一言、讯飞星火、Bing、Bard、ChatGLM、POE，多账号，人设调教
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的不断发展，智能聊天机器人已经成为我们日常生活中不可或缺的一部分。ChatGPT作为一款强大的人工智能聊天模型，能够为我们提供高效、便捷的聊天体验。那么，如何将ChatGPT接入QQ，实现智能聊天新体验呢？本文将为你详细介绍。无需太多的要求，你只需要自备key即可，可以在这里获取 api.wpzllq.top
Github项目地址 体验可以添加QQ1114362762 ⚡ 支持
关键词触发回复 多账号支持 百度云内容审核 人格设定 可作为 HTTP 服务端提供 Web API 支持 ChatGPT 网页版 支持 ChatGPT Plus 支持 ChatGPT API 支持 Bing 聊天 支持 Google bard 支持 poe.com 网页版 支持 文心一言 网页版 支持 ChatGLM-6B 本地版 🤖 多平台兼容
支持QQ聊天平台。
平台群聊回复私聊回复条件触发管理员指令绘图语音回复QQ支持支持支持支持支持支持个人微信支持支持支持不支持支持支持 教程开始 下载压缩包，解压后拖到一个文件夹，建议是课桌，避免文件名是 中文！
打开 run-mirai.bat 登录QQ机器人
一直回车直到出现这个指示的时候停止 ，输入这一行字符 将123456分别改成你的QQ账户 密码
autologin add 123456 123456 然后回车 如果显示登录成功 输入 exit 回车自动退出
然后再次双击运行 run-mirai
会看到提示要验证复制link 后面的链接 粘贴到浏览器去打开
按F12打开控制台，选择图片验证，在网络--下面会出现有一项叫cap _union_new_yerif 右键复制值 然后输入到终端中回车 然后可以看到提示要进行短信验证 输入yes 回车---会获取的QQ的手机验证码输入验证码回车就登录成功了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f1f3b5eab835f38b955ca7d6bf2603/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/344/">«</a>
	<span class="pagination__item pagination__item--current">345/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/346/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>