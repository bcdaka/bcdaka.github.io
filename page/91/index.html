<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3a838022920792f4fdeba041247adf/" rel="bookmark">
			欧科云链7月安全月报 | 私钥泄露损失约占总损失88%，超2.6亿美元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7 月全网累计造成损失约 2.9 亿美元，因私钥泄露所造成损失占总损失的&amp;nbsp;88.31%，其中 WazirX 因多签钱包私钥泄露，造成约&amp;nbsp;2.35 亿美元的损失，为 7 月最大安全事件。
最大安全事件-私钥泄漏
7&amp;nbsp;月&amp;nbsp;18&amp;nbsp;日，WazirX&amp;nbsp;多签钱包私钥泄露，造成损失约&amp;nbsp;2.35&amp;nbsp;亿美元。
最大安全事件-钓鱼诈骗
7 月 24 日，ETH 链上地址 0x07...fDC9 损失价值 469 万美元的 Pendle 重新质押代币。
最大安全事件-REKT
7 月 16&amp;nbsp;日，LiFi Protocol 跨链桥聚合协议被攻击，导致损失约 1 千万美元，攻击者利用了任意调用漏洞，可以让攻击者盗取授权给这个合约用户的资产。
最大安全事件-RugPull
7 月 21 日，ETH TrustFund 发生&amp;nbsp;RugPull&amp;nbsp;并在 Base 上窃取了价值约 200 万美元的加密货币。
案例分析
7 月 15 日，Minterest 在 Mantle 上遭遇了重大的安全事故，并因此造成了约 140 万美元的损失。目前，其项目团队已暂停该协议。
流程分析：
1)&amp;nbsp;从 Mantle DEX 的 USDY/USDT 资金池中闪电贷出 426.5 万 USDY；
在其回调函数中：共循环又进行了 25 次&amp;nbsp;FlashLoan &amp; Redeem Underlying 动作；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f3a838022920792f4fdeba041247adf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff605956534e70441083a49a383845b/" rel="bookmark">
			Python爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫 1.什么是爬虫2.基础入门之简单的页面设计3.urllib基本使用，一个类型六个方法4.urllib下载5. 请求对象的定制6.get请求的quote方法7. get请求urlencode方法8.urllib_post请求百度翻译9.百度翻译详细版10.urllib_ajax的get请求豆瓣电影的第一页11.get请求豆瓣电影的前十页12.ajax_post请求肯德基官网13.异常14.微博的cookie登录15.handler处理器的基本使用16.urllib代理17.代理池18.xpath的基本使用19.解析_百度一下20.站长素材21.jsonpath22.用jsonpath解析淘票票23.BeautifulSoup24.bs4获取星巴克数据25.Selenium26.selenium元素定位27.举例Selenium邓紫棋28.Selenium 其他操作29.selenium-phantomjs30.selenium-handless31.request基本使用request中的get请求32.request中的post请求33.request_代理34.request免验证登录古诗词网35.scrapy基本使用36.58同城实例37.汽车之家38.当当网39.电影天堂40.crawlspider 1.什么是爬虫 网络爬虫（又被称为网页蜘蛛，网络机器人）就是模拟浏览器发送网络请求，接收请求响应，一种按照一定的规则，自动地抓取互联网信息的程序。
2.基础入门之简单的页面设计 这一部分主要是为了展示怎样在爬虫中寻找网页中信息，在这些代码中展示的是一个列表，
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- table 表格 tr 行 td 列 --&gt; &lt;table width = "200px" height = "200px" border = "1px"&gt; &lt;tr&gt; &lt;td&gt; 姓名 &lt;/td&gt; &lt;td&gt; 年龄 &lt;/td&gt; &lt;td&gt; 性别 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 张三 &lt;/td&gt; &lt;td&gt; 18 &lt;/td&gt; &lt;td&gt; 男 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- ul li (无序列表) 爬虫使用很多--&gt; &lt;ul&gt; &lt;li&gt;铁锅炖大鹅&lt;/li&gt; &lt;li&gt;小鸡炖蘑菇&lt;/li&gt; &lt;li&gt;锅包肉&lt;/li&gt; &lt;/ul&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ff605956534e70441083a49a383845b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a795995b92dd3858dc626afa45aca0/" rel="bookmark">
			文心一言的实用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言收获日常错误避免 憧憬 前言 亲爱的读者，你是否曾在忙碌的工作中感到语言沟通的障碍？是否在文学创作、商业文案撰写或是日常办公中，遇到过需要快速高效处理大量文字信息的困扰？那么，让我为你介绍一款强大的助手——百度智能云的文心一言。
文心一言，作为百度推出的先进人工智能大语言模型，它拥有跨模态、跨语言的深度语义理解与生成能力。
无论是搜索问答、内容创作生成还是智能办公，文心一言都能提供更广阔的想象空间和解决方案。
现在，就让我们一起探索文心一言的魅力，揭开它的神秘面纱。
让我们从OCR技术开始。
你是否曾为处理纸质文档、扫描件和照片中的文字而烦恼？文心一言的OCR技术通过图像处理和深度学习算法，能将图片中的文字转换成可编辑和可搜索的文本，大大提升工作效率和准确性。
再来说说机器翻译功能。
在全球化日益加深的今天，跨语言沟通变得尤为重要。
文心一言的机器翻译功能能够实时将输入的文本翻译成多种语言，帮助你轻松跨越语言鸿沟。
情感分析则是文心一言的一项独特功能。
它能通过深度学习算法分析文本的情感倾向性，判断出文本是积极、消极还是中性。
这对于理解用户反馈、市场调研等方面具有重要价值。
当然，不得不提的还有文心一言强大的文本生成功能。
它能根据主题或关键词自动生成符合要求的文本，这在写作辅助、新闻报道、广告词创作等领域有着极大的应用价值。
语音识别和实体关系抽取等高级功能也为文心一言增色不少。
语音识别能够将语音转换为文本，实现智能客服等多种应用场景；而实体关系抽取则能自动建立实体之间的关系模型，帮助深入理解数据关联。
接下来，我将分享一些实用的技巧和实例，帮助你更好地利用文心一言。
比如，当你需要准备一场演讲稿时，只需简单输入主题和要点，文心一言就能帮你生成一篇结构完整、内容丰富的稿件。
或者在你需要快速整理会议纪要时，它的智能对话功能可以准确捕捉并总结关键信息点。
在使用过程中，记得保持指令的清晰性和具体性，这样能进一步提升与文心一言的交互效果。
同时，不断探索它的高级功能，将让你在日常工作和生活中如鱼得水。
提醒你抓住机会体验文心一言的强大功能。
无论你是企业中的一员，还是对AI技术充满好奇的个人，都不要错过这一改变未来的工具。
现在就行动起来，让文心一言成为你智能生活和工作的得力助手吧！
收获 使用文心一言进行编程语言的学习和问题解决，可以遵循以下步骤：
提问具体问题：向我提出具体的编程问题，比如语法、算法、代码调试等。
代码示例：如果你需要代码示例或模板，可以告诉我你想要实现的功能，我会提供相应的代码。
错误分析：如果你遇到了代码错误或异常，可以将错误信息或代码段发给我，我会帮你分析可能的原因并提供解决方案。
学习资源推荐：如果你需要学习特定编程语言的资源，我可以推荐在线教程、书籍或课程。
编程概念解释：如果你对某个编程概念或术语有疑问，可以问我，我会尽量用简单的语言解释清楚。
最佳实践和设计模式：如果你需要了解编程的最佳实践或设计模式，我可以提供相关信息和示例。
工具和库的使用：如果你在使用某个编程工具或库时遇到困难，可以询问我如何使用它们。
编程语言特性：如果你对特定编程语言的新特性或高级用法感兴趣，我可以提供相关信息。
项目建议：如果你在规划一个编程项目，我可以提供项目结构的建议和开发流程的指导。
持续学习：编程是一个不断学习和进步的过程，我可以提供持续学习的策略和资源。
记住，虽然我可以提供很多帮助，但实践是学习编程的关键。尝试自己编写代码，解决问题，并从错误中学习。如果你需要帮助或有任何问题，随时向我提问。
但是我建议用通义灵码，这个不错。
日常 文心一言，作为百度开发的语言模型，可以以多种方式帮助提高您的工作效率，具体包括：
文档撰写与编辑：
自动生成报告：文心一言可以快速生成各类文档，如市场分析报告、项目总结等，节省撰写时间。文本编辑与优化：它能帮助您编辑和优化现有文档，提升语言表达的准确性和专业度。 智能客服与沟通：
自动化客服：文心一言可以处理客户咨询，提供即时回复，减轻客服压力，提升客户满意度。邮件撰写：自动撰写邮件，包括商务邀请、会议通知等，提高沟通效率。 创意内容创作：
广告文案：快速生成吸引人的广告语和产品描述，提升营销效率。文章创作：为博客、新闻稿等提供创意内容，帮助您保持内容更新和吸引读者。 数据分析与报告生成：
自动分析：基于数据输入，文心一言可以生成分析报告，帮助您快速理解业务趋势和市场动态。 多语言支持：
翻译服务：提供快速的多语言翻译，促进国际业务交流，减少语言障碍带来的效率损失。 会议纪要与总结：
自动记录与整理：文心一言能够记录会议内容，自动生成会议纪要，确保信息准确传达。 知识管理与检索：
文档检索：帮助查找和整理公司内部的文档，提高知识管理和检索效率。智能问答：快速回答工作相关的专业问题，减少查找资料的时间。 通过上述应用，文心一言可以显著提高您的工作效率，减少重复劳动，让您有更多时间专注于核心业务和创新工作。
错误避免 在使用文心一言提问时，以下是一些常见的错误和建议，以帮助你避免这些问题：
问题过于模糊：避免提出过于宽泛或含糊的问题，这样很难给出具体的答案。例如，不要问“如何编程？”而是问“如何使用Python编写一个冒泡排序算法？”
缺乏上下文：不要假设我知道你问题的所有背景信息。提供足够的上下文，以便我可以更准确地理解你的问题。
使用专业术语而不解释：如果你使用了专业术语或缩写，确保提供解释或定义，以便我能够理解。
期望即时回复：虽然我可以快速回复，但某些问题可能需要一些时间来处理和分析。请耐心等待。
重复提问：如果你已经问过一个问题，并且得到了回答，不要重复提问相同的问题，除非有新的情况或信息。
期望不切实际：避免期望我能够解决超出我能力范围的问题，比如需要高度专业知识或经验的问题。
发送大量无关信息：避免发送大量无关的文件或信息，这可能会分散注意力，使我难以找到问题的关键点。
不明确的指令：如果你需要我执行特定的任务或操作，请提供明确的指令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a795995b92dd3858dc626afa45aca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc911ad083e11f1c94a552edaf4d37c/" rel="bookmark">
			沉浸式企业VR展厅，重塑企业形象展示方式！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业VR展厅以颠覆传统的沉浸式体验，重塑企业形象展示方式，让全球客户足不出户即可身临其境地探索企业风采、深入了解产品精髓。通过VR的魔力，企业形象不再局限于二维平面，而是以三维立体、互动生动的形式跃然眼前，让每一次展示都成为深刻而难忘的品牌记忆。
一站式元宇宙虚拟活动云平台——视创云展，为企业搭建线上VR展厅提供技术支持，通过标准化营销展厅服务，直接选择模板即可自由创作搭建展厅。
视创云展企业VR展厅展厅具有以下优势： 1. 跨越时空的便捷访问 在数字化浪潮的推动下，企业VR展厅为客户开启了一扇通往未来的大门。客户无需长途跋涉至实体展厅，仅需轻点鼠标或滑动屏幕，借助稳定的互联网连接，即可瞬间“穿越”至虚拟世界，全方位探索企业风采与产品细节。
这一变革不仅极大地缩短了距离，还显著节省了客户的时间与金钱成本，特别是对于那些身处异地、寻求高效交流的客户而言，其优势更是无可比拟。无论是在家中舒适的沙发上，还是在移动设备的方寸之间，企业VR云展厅随时待命，为客户带来即时、便捷的信息获取体验。
2. 沉浸式互动，激发无限探索欲 企业VR展厅不仅仅是一个展示平台，更是一个充满趣味与互动的虚拟空间。在这里，客户不再是被动接受信息的旁观者，而是成为主动探索的参与者。通过直观的点击、拖拽操作，客户可以自由地穿梭于展厅之间，细品每一件产品的纹理与构造，观看高清视频演示，甚至与企业代表进行即时沟通，解决心中疑惑。
3D建模技术的运用，更是让产品展示跃升至全新高度，客户能够720度无死角地审视产品，甚至模拟实际使用场景，这种身临其境的体验无疑将帮助客户做出更加明智、满意的购买决策。
3. 个性化定制，精准触达客户需求 企业VR展厅深知每一位客户的独特性与需求差异，因此特别注重个性化内容的呈现。借助先进的数据分析与用户行为追踪技术，系统能够精准捕捉客户的兴趣点与偏好，从而智能推送定制化信息。
这种一对一的精准服务，不仅极大地提升了客户的满意度与忠诚度，也为企业与客户之间建立了更加紧密、稳固的联系。在VR云展厅中，企业可以根据不同客户的需求设置多样化的主题展区，实现信息的精准传递与高效转化，让每一次互动都充满价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097670c7b43e3a12c928b7964bfaa145/" rel="bookmark">
			【查看Kafka存储日志时间】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 步骤关键配置参数示例总结使用`kafka-topics.sh`查看Topic基本信息使用`kafka-configs.sh`查看Topic的配置参数示例使用`--bootstrap-server`选项查看Topic基本信息查看Topic的配置参数 总结 要查看Kafka服务器的配置文件，你需要访问Kafka安装目录中的配置文件。通常，这些配置文件位于Kafka安装目录的 config子目录中。最常见的配置文件是 server.properties，它包含了Kafka broker的各种配置参数。 步骤 找到Kafka安装目录：首先，你需要知道Kafka安装在你的系统中的哪个目录。假设Kafka安装在/opt/kafka目录下。
进入配置文件目录：进入Kafka安装目录的config子目录。
cd /opt/kafka/config 查看server.properties文件：使用文本编辑器或命令行工具查看server.properties文件。 cat server.properties 或者使用文本编辑器，如nano或vim：
nano server.properties 关键配置参数 在server.properties文件中，你可以找到与消息保留时间和大小相关的默认配置参数。以下是一些关键参数：
log.retention.hours：消息保留的时间（以小时为单位）。默认值通常是168小时（7天）。
log.retention.hours=168 log.retention.bytes：每个分区的最大存储大小。默认值是-1，表示没有大小限制。
log.retention.bytes=-1 log.retention.ms：消息保留的时间（以毫秒为单位）。如果设置了这个参数，它会覆盖log.retention.hours。
log.retention.ms=604800000 log.segment.bytes：每个日志段的最大大小。默认值通常是1GB。
log.segment.bytes=1073741824 log.segment.ms：每个日志段的最大时间长度（以毫秒为单位）。
log.segment.ms=604800000 log.retention.check.interval.ms：Kafka检查并删除过期消息的时间间隔。默认值通常是5分钟（300000毫秒）。
log.retention.check.interval.ms=300000 示例 假设你查看server.properties文件，可能会看到类似以下的内容：
# The number of hours to keep a log file before deleting it (in hours), default is 168 hours (7 days) log.retention.hours=168 # The maximum size of a log segment file. When this size is reached a new log segment will be created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/097670c7b43e3a12c928b7964bfaa145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7804bff05377da47d5befd45c90af014/" rel="bookmark">
			ELK日志系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
ELK概念
ELK实验
数据流向
架构
步骤
安装elasticsearch
安装logstash
es的主从和数据模式
ELK索引数据管理
创建数据
修改数据
删除数据
创建日志收集系统
安装kibana
httpd日志收集脚本
ELKF
ELKF概念
filebeat远程收集nginx日志
操作
filebeat远程收集nginx、httpd、mysqld日志
ELK概念 ELK是一套完整的日志集中处理方案。
E：ElasticSearck 简称ES 分布式索引型非关系型数据库，用来存储logstash输出的日志 ，它是一个全文检索引擎，保存的格式是json格式
L：logstash 是基于Java语言开发的，用来作数据收集引擎、日志的收集。可以对数据进行过滤，分析，汇总，以标准格式输出
K：Kibana 是ES的可视化工具，对ES存储的数据进行可视化展示，分析和检索。
ELK实验 数据流向 架构 192.168.233.10 ES1
192.168.233.20 ES2
192.168.233.30 logstash+Kibana+nginx/http
步骤 1.安装ntpdate（所有设备都要安装） yum -y install ntpdate -y
然后查看时间是否一致
安装elasticsearch 2.在ES1和ES2（同步操作）
yum -y install java
安装 elasticsearch-6.7.2
rpm -ivh elasticsearch-6.7.2.rpm
然后配置elasticsearch
vim /etc/elasticsearch/elasticsearch.yml
ES1改为
ES2改为
然后检查配置文件是否有错
grep -v "^#" /etc/elasticsearch/elasticsearch.yml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7804bff05377da47d5befd45c90af014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5efb0db9ad7ea56a259161854d411f12/" rel="bookmark">
			数仓: 1- 数据仓库基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1- 数据仓库基础1.1 数据仓库概念和特点1.1.1 数据仓库的概念1.1.2 数据仓库的主要特点1.1.2.1 面向主题的(Subject-Oriented)1.1.2.2 集成的(Integrated)1.1.2.3 相对稳定的(Non-Volatile) 非易失1.1.2.4 反应历史变化的(Time-Variant) 时变的 1.1.3 数据仓库其它重要特征1.1.3.1 支持决策1.1.3.2 读取密集型1.1.3.3 数据粒度1.1.3.4 元数据管理1.1.3.5 数据质量 1.1.4 数据仓库vs操作型数据库1.1.4.1 数据仓库1.1.4.2 操作型数据库 1.1.5 数据仓库的挑战 1.2 数据仓库架构1.2.1 数据源层1.2.2 数据抽取和转换层(ETL层)1.2.3 数据存储层1.2.3.1 暂存层(Staging Area)1.2.3.2 核心数据仓库1.2.3.3 数据集市 1.2.4 元数据层1.2.5 数据访问1.2.6 数据展现层1.2.7 数据管理和监控层1.2.8 几种常见的数据仓库架构模式1.2.8.1 独立数据集市架构1.2.8.2 总线架构(Bus Architecture)1.2.8.3 中心仓库架构(Hub and Spoke)1.2.8.4 联邦架构(Federated Architecture) 1.2.9 现代趋势 1.3 OLTP vs OLAP1.3.1 定义1.3.2 主要区别1.3.3 关系1.3.4 总结 1.4 数据仓库设计方法论1.4.1 Inmon方法论 (自上而下法)1.4.2 Kimball 方法论 (自下而上)1.4.3 Data Vault 方法论1.4.4 Anchor 建模1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5efb0db9ad7ea56a259161854d411f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92be3f3a58911cedbe2edad7cd07de80/" rel="bookmark">
			数据结构： 单向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、链表的概念及结构
二、单链表的实现
2.1 头文件
2.2 各个功能的实现
2.2.1 内存申请
2.2.2 头插，尾插，头删，尾删
头插
尾插
头删
尾删
2.2.3 查找数据
2.2.4 指定位置前中后的数据增删
指定位置之前插入数据
指定位置之后插入数据
删除指定位置之后数据
删除指定位置数据
2.2.5 打印链表
2.2.6 销毁链表
一、链表的概念及结构 概念：链表是⼀种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
链表的结构跟火车车厢相似，淡季时车次的车厢会相应减少，旺季时车次的车厢会额外增加几节。只需要将火车里的某节车厢去掉或者加上，不会影响其他车厢，每节车厢都是独立存在的，车厢是独立存在的，且每节车厢都有车门，想象⼀下这样的场景，假设每节车厢的车门都是锁上的状 态，需要不同的钥匙才能解锁，每次只能携带⼀把钥匙的情况下如何从车头走到车尾？ 最简单的做法：每节车厢里都放⼀把下⼀节车厢的钥匙。
链表里的“车厢”
与顺序表不同的是，链表里的每节"车厢"都是独立申请下来的空间，我们称之为“节点”， 节点的组成主要有两个部分：当前节点要保存的数据和保存下⼀个节点的地址（指针变量）。 图中指针变量plist保存的是第⼀个节点的地址，我们称plist此时“指向”第⼀个节点，如果我们希望plist“指向”第⼆个节点时，只需要修改plist保存的内容为0x0012FFA0。
链表中每个节点都是独立申请的（即需要插⼊数据时才去申请⼀块节点的空间），我们需要通过指针变量来保存下⼀个节点位置才能从当前节点找到下⼀个节点。
结合结构体知识，我们可以给出每个节点对应的结构体代码： 假设当前保存的节点为整型：
struct SListNode { int data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数 据，也需要保存下⼀个节点的地址（当下⼀个节点为空时保存的地址为空）。
当我们想要从第⼀个节点走到最后⼀个节点时，只需要在前⼀个节点拿上下⼀个节点的地址（下⼀个 节点的钥匙）就可以了。
二、单链表的实现 2.1 头文件 先要创建一个头文件，写入我们需要的函数名以及结构体
typedef int SLTDataType;//方便类型转换 typedef struct SListNode { SLTDataType data; //节点数据 struct SListNode* next; //指针保存下⼀个节点的地址 }SLTNode; void SLTPrint(SLTNode* phead); //头部插入删除数据/尾部插入删除数据 void SLTPushBack(SLTNode** pphead, SLTDataType x); void SLTPushFront(SLTNode** pphead, SLTDataType x); void SLTPopBack(SLTNode** pphead); void SLTPopFront(SLTNode** pphead); //查找数据 SLTNode* SLTFind(SLTNode* phead, SLTDataType x); //在指定位置之前插入数据 void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x); //删除指定位置节点 void SLTErase(SLTNode** pphead, SLTNode* pos); //在指定位置之后插入数据 void SLTInsertAfter(SLTNode* pos, SLTDataType x); //删除指定位置之后的节点 void SLTEraseAfter(SLTNode* pos); //销毁链表 void SListDesTroy(SLTNode** pphead); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92be3f3a58911cedbe2edad7cd07de80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb282b4a69e61ad8959fe5aa4f6b41df/" rel="bookmark">
			手搓交换排序、归并排序、计数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 交换排序冒泡排序快速排序hoare版本挖坑法lomuto前后指针 非递归快速排序 归并排序实现计数实现排序代码测试排序算法性能 交换排序 冒泡排序 void BubbleSort(int* arr, int n) { for (int i = 0; i &lt; n; i++) { int flag = 0; for (int j = 0; j &lt; n - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { Swap(&amp;arr[j], &amp;arr[j + 1]); flag = 1; } } if (0 == flag) break; } } 时间复杂度：O(N^2)
快速排序 快速排序是一种二叉树结构的交换排序方式，基本思想：任取待排元素序列中的某元素作为基准值，按照该基准值将待排序列分割成两子序列，左子序列所有元素均小于该基准值，右子序列均大于该基准值，然后在左子序列，和右子序列重复上述过程，直到待排元素符合预期结果。
void QuickSort(int* arr, int left, int right) { if (left &gt;= right)//left 等于 right说明此时子序列里只有一个数据了，若left 大于 right说明此时子序列为空 { return; } //int meet = hoare_QuickSort(arr, left, right); //int meet = hole_QuickSort(arr, left, right); //int meet = lomuto_QuickSort(arr, left, right); QuickSort(arr, left, meet - 1); QuickSort(arr, meet + 1, right); } 时间复杂度：O(nlogn~n^2)，在以下查找基准值的方法，是以待排序列首元素位基准值，这种方法存在缺陷，使得快速排序的性能下降，时间复杂度及较高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb282b4a69e61ad8959fe5aa4f6b41df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f346043f26c3d79b64822780492799a2/" rel="bookmark">
			Python 爬虫项目实战（一）：破解网易云 VIP 免费下载付费歌曲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 网络爬虫（Web Crawler），也称为网页蜘蛛（Web Spider）或网页机器人（Web Bot），是一种按照既定规则自动浏览网络并提取信息的程序。爬虫的主要用途包括数据采集、网络索引、内容抓取等。
爬虫的基本原理
种子 URL：爬虫从一个或多个种子 URL 开始，这些 URL 是起点。发送请求：爬虫向这些种子 URL 发送 HTTP 请求，通常是 GET 请求。获取响应：服务器返回网页的 HTML 内容作为响应。解析内容：爬虫解析 HTML 内容，提取所需的数据（如文本、链接、图片等）。提取链接：从网页中提取出所有链接，并将这些链接加入待访问队列。重复过程：爬虫重复上述步骤，直到达到某个停止条件，如爬取了一定数量的页面，或所有页面都被爬取完毕。 爬虫的分类
通用爬虫
设计用于抓取整个互联网的大量网页。搜索引擎（如 Google、Bing）的爬虫就是通用爬虫。 聚焦爬虫
专注于特定主题或领域，抓取相关网页。比如，一个新闻爬虫只抓取新闻网站的内容。 增量爬虫
仅抓取自上次爬取以来发生变化或更新的网页，适用于动态内容更新频繁的网站。 爬虫的合法性和道德
在编写和运行爬虫时，必须遵循以下原则：
遵守网站的 robots.txt：
大多数网站都有一个 robots.txt 文件，规定了哪些页面允许被爬取，哪些不允许。爬虫应当尊重这些规则。
避免过度抓取：
设置适当的抓取频率，避免对服务器造成过大负担。 尊重版权和隐私：
不应抓取或使用受版权保护的内容，或涉及用户隐私的数据。 获取许可：
在某些情况下，最好获得网站管理员的许可，特别是当你打算频繁地抓取大量数据时。 通过以上方法和原则，可以编写高效、可靠且合规的网络爬虫来满足数据采集的需求。 侦察 打开页面
F12 检查定位关键元素
在网络中刷新页面
搜索关键字
查看在页面中的渲染情况是不是我们想要的数据，可以看到这里列出了200首歌那么就是的
在标头中确定数据来源地址及请求方法
源代码 import re import os import requests filename = 'music\\' # 如果没有则创建文件夹 if not os.path.exists(filename): os.makedirs(filename) # 请求网址（如果想要爬取其他的榜单的歌曲内容，只需要改这个 url 即可） url = 'https://music.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f346043f26c3d79b64822780492799a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3964064f6f205f3c374db1a6699228e9/" rel="bookmark">
			llama-factory源码详解——以DPO为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文记录了我在学习 llama-factory过程中对代码运行过程的梳理
代码入口——src/train.py from llamafactory.train.tuner import run_exp def main(): run_exp() def _mp_fn(index): # For xla_spawn (TPUs) run_exp() if __name__ == "__main__": main() run_exp() 该函数位于src/llamafactory/train/tuner.py
def run_exp(args: Optional[Dict[str, Any]] = None, callbacks: List["TrainerCallback"] = []) -&gt; None: callbacks.append(LogCallback()) model_args, data_args, training_args, finetuning_args, generating_args = get_train_args(args) if finetuning_args.stage == "pt": run_pt(model_args, data_args, training_args, finetuning_args, callbacks) elif finetuning_args.stage == "sft": run_sft(model_args, data_args, training_args, finetuning_args, generating_args, callbacks) elif finetuning_args.stage == "rm": run_rm(model_args, data_args, training_args, finetuning_args, callbacks) elif finetuning_args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3964064f6f205f3c374db1a6699228e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938ba04beae2f98c732889eacd484f14/" rel="bookmark">
			深入分析 Android ContentProvider (十二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深入分析 Android ContentProvider (十二)Android 中 ContentProvider 的系统代码分析（续）1. ContentProvider 的内部实现机制1.1. ContentProvider 的创建与生命周期管理1.2. ContentProvider 的数据访问与处理1.3. ContentProvider 的权限管理与安全性 2. ContentProvider 的通知机制示例：通知数据变化 3. ContentProvider 的测试示例：ContentProvider 的单元测试 4. 总结 深入分析 Android ContentProvider (十二) Android 中 ContentProvider 的系统代码分析（续） 我们继续深入分析 Android 系统中 ContentProvider 的底层实现，进一步理解其工作流程及设计逻辑。
1. ContentProvider 的内部实现机制 ContentProvider 是 Android 中用于实现跨应用数据共享的组件。为了更详细地理解其内部工作机制，我们将探讨以下几个方面：
ContentProvider 的创建与生命周期管理ContentProvider 的数据访问与处理ContentProvider 的权限管理与安全性 1.1. ContentProvider 的创建与生命周期管理 ContentProvider 的创建和生命周期管理由 Android 系统框架负责。当某个应用尝试访问 ContentProvider 时，系统会根据需要实例化该 ContentProvider 并调用其 onCreate() 方法。
在 Android 系统中，ContentProvider 的实例化是通过 ActivityThread 类来完成的。以下是相关的系统代码片段：
// ActivityThread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/938ba04beae2f98c732889eacd484f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c07ada66f3cec330597e653e71a1772/" rel="bookmark">
			深度学习任务中的 Zero-shot、One-shot 和 Few-shot 是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习任务中的 Zero-shot、One-shot 和 Few-shot 是什么？ 在深度学习的任务中，Zero-shot、One-shot 和 Few-shot 学习是处理有限数据的三种重要方法。这些方法尤其在计算机视觉领域表现得非常突出。接下来，我们将详细探讨这三种学习方式，包括它们的定义、原理以及在计算机视觉领域的应用实例。
Zero-shot 学习（零样本学习） 定义： Zero-shot 学习是指在训练过程中完全没有见过某些类别的数据，但模型能够在测试阶段成功地对这些新类别进行分类。这个概念的核心在于模型能够利用先验知识或语义信息来推断新类别的特征。
原理： 在 Zero-shot 学习中，模型依赖于类间的语义关系或属性描述。这些描述通常是通过预训练的词嵌入（如 Word2Vec、GloVe）或其他语义空间（如视觉-语言对齐模型）来获取的。模型在训练时看到的类别与测试时的类别可能完全不同，但它们共享某些属性或特征。
公式与代码：
假设我们有一个训练好的模型，它可以根据特征向量 x x x 和类别描述 d d d 进行分类。对于测试样本，我们计算其与各个类别描述的相似度，然后选择相似度最高的类别作为预测结果。
公式表示为：
y = arg ⁡ max ⁡ c ∈ C Similarity ( f ( x ) , d c ) y = \arg\max_{c \in C} \text{Similarity}(f(x), d_c) y=argc∈Cmax​Similarity(f(x),dc​)
其中， C C C 是所有类别的集合， f ( x ) f(x) f(x) 是特征提取函数， d c d_c dc​ 是类别 c c c 的描述向量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c07ada66f3cec330597e653e71a1772/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2c380ef8d65e491c6cb8fdc157d955/" rel="bookmark">
			深度学习，机器学习，强化学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习、机器学习、python、人工智能项目代做和指导答疑～擅长（svm、罗辑回归、贝叶斯、决策树、xgboost等）机器学习算法、各种opencv图像处理、图像分类模型（vgg、resnet、mobilenet、efficientnet、densenet等）、人脸检测、烟雾检测、火灾检测、车辆检测、人脸识别、表情识别、各种目标检测算法（yolo5、yolo6、yolo7、yolo8、centernet、detr、rcnn系列等）、各种图像分割算法（unet、nnunet、deeplab、maskrcnn等）、图像生成算法（stable diffusion、stylegan系列等）医学影像dicom、nii数据处理、ct和mri医学影像图像分割、肿瘤分割、可视化ui界面等，tensorflow、keras、pytorch等deep learning框架均可，包括远程安装配置环境和售后答疑等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e797730d03dbf9ed76eaafb507647d/" rel="bookmark">
			黑客们都用什么笔记本电脑？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几年前我探访过几次黑客大赛。既然是比赛，黑客们肯定会带上自己最趁手的武器。我就把当年你的文章贴在这里吧，大家感受一下，黑客们到底用啥电脑。
黑客都用什么电脑？这里有一份极简版TCTF黑客大赛装X指南（节选） 2017年，深圳，黑客大赛：Tencent CTF。
一起来看看黑客都用什么电脑，看图：
这个是 Surfacebook
这个是Terrans Force（未来人类）
这个是 Surface
外国小哥偏爱宏碁
美女似乎是全场唯一一部 SONY VAIO
当然少不了 Mac
还有贵贵的 Mac
外国小哥似乎偏爱老牌子，比如 HP
比如戴尔
比如小红点 ThinkPad
不过，看到了下面几台电脑，我觉得上面的都是渣渣。
终于发现了，本节目是由神舟赞助播出。以后谁再说神舟low，你可以直接怼回去：你懂毛，黑客都用神舟！
朋友：求盗图发朋友圈。
你：拿去！
为了帮助大家更好的学习网络安全，我给大家准备了一份网络安全入门/进阶学习资料，里面的内容都是适合零基础小白的笔记和资料，不懂编程也能听懂、看懂这些资料！
网络安全资源分享 对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
【点击免费领取】CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》
1.学习路线图 攻击和防守要学的东西也不少，具体要学的东西我都写在了上面的路线图，如果你能学完它们，你去接私活完全没有问题。
2.视频教程 网上虽然也有很多的学习资源，但基本上都残缺不全的，这是我自己录的网安视频教程，上面路线图的每一个知识点，我都有配套的视频讲解。【点击领取视频教程】
技术文档也是我自己整理的，包括我参加大型网安行动、CTF和挖SRC漏洞的经验和技术要点，电子书也有200多本【点击领取技术文档】
（都打包成一块的了，不能一一展开，总共300多集）
3.技术文档和电子书 技术文档也是我自己整理的，包括我参加大型网安行动、CTF和挖SRC漏洞的经验和技术要点，电子书也有200多本【点击领取书籍】
4.工具包、面试题和源码 “工欲善其事必先利其器”我为大家总结出了最受欢迎的几十款款黑客工具。涉及范围主要集中在 信息收集、Android黑客工具、自动化工具、网络钓鱼等，感兴趣的同学不容错过。
最后就是我这几年整理的网安方面的面试题，如果你是要找网安方面的工作，它们绝对能帮你大忙。
这些题目都是大家在面试深信服、奇安信、腾讯或者其它大厂面试时经常遇到的，如果大家有好的题目或者好的见解欢迎分享。
参考解析：深信服官网、奇安信官网、Freebuf、csdn等
内容特点：条理清晰，含图像化表示更加易懂。
内容概要：包括 内网、操作系统、协议、渗透测试、安服、漏洞、注入、XSS、CSRF、SSRF、文件上传、文件下载、文件包含、XXE、逻辑漏洞、工具、SQLmap、NMAP、BP、MSF…
👋全套《黑客&amp;网络安全入门&amp;进阶学习资源包》👇👇👇 这份完整版的学习资料已经上传CSDN，也可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2acf53b87d5798e4199cc17218b7571/" rel="bookmark">
			Android 系统架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 框架（Android Framework）是 Android 操作系统的核心部分之一，它提供了一组 API，开发者可以使用这些 API 来构建应用程序。Android 框架处于 Android 系统架构的中间层，位于应用层和操作系统核心层之间。
Android 系统架构 应用层（Applications）:
这一层包括用户安装的所有应用程序，如浏览器、联系人、相机等。开发者可以使用 Android 框架提供的 API 来构建自己的应用程序。 应用框架层（Application Framework）:
Android 框架的核心部分，提供了构建应用程序的基本组件和服务。它包含许多核心组件，例如活动管理器（Activity Manager）、窗口管理器（Window Manager）、内容提供者（Content Providers）、资源管理器（Resource Manager）等。开发者可以使用这些框架组件来管理 UI、数据存储、后台服务、应用间通信等。 系统库和 Android 运行时（Libraries and Android Runtime）:
系统库: 包含一些 C/C++ 库，为 Android 系统提供基本功能，如媒体库（OpenGL、WebKit）、C 库（libc）、SSL（libSSL）等。Android 运行时: 包括核心库和虚拟机（如 Dalvik 或 ART）。核心库提供 Java 编程语言的基本功能，而虚拟机运行 .dex 字节码。 硬件抽象层（Hardware Abstraction Layer, HAL）:
HAL 为硬件驱动提供标准接口，使 Android 操作系统能够与硬件组件（如相机、传感器等）进行交互。开发者通常不直接与 HAL 交互，但 HAL 是系统与硬件之间的桥梁。 Linux 内核（Linux Kernel）:
Android 基于 Linux 内核，它处理底层硬件抽象、内存管理、进程管理、网络堆栈和设备驱动等。它为 Android 系统提供了基础服务，如电源管理、安全性、网络和驱动程序管理。 Android 框架的作用 提供基本的应用开发组件: Android 框架提供了活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）和内容提供者（Content Provider）等基本组件，这些组件是构建 Android 应用的基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2acf53b87d5798e4199cc17218b7571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ab6770cca164c30dd1d03490a4f18d/" rel="bookmark">
			2024年有什么赚钱的副业推荐半年还清贷款，成功变现12.3w的全套玩法都放这里了！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要说推荐副业，我是最有发言权了。普通打工人一个，年轻不懂事，经常超前消费，欠了一屁股债，没得办法，就只能到处找能赚钱的门路。
尝试了30+的副业，就发现能赚钱的不是太辛苦，就是需要很高的门槛。比如外卖、滴滴、直播都能赚钱，但是真的一般人干不了的。
勉强去干，经常被投诉，完全是白干，直播没啥颜值没啥才艺，根本就是浪费时间。不过多尝试还真给我找到一个普通人都能上手，一台电脑每天2小时左右，就可以赚钱的门路。
笔者本人 17 年就读于一所普通的本科学校，20 年 6 月在三年经验的时候顺利通过校招实习面试进入大厂，现就职于某大厂安全联合实验室。
兼职收入 先简单晒一下，我今年其中一个大单挖漏洞兼职赚钱的收益吧！涉及到企业敏感信息，我这里就详细展示了。
下面是我前年挖漏洞部分收益，去年公司项目较忙，所以没怎么兼职。 今年互联网企业开启了裁员潮，当然我目前还能幸免被裁，但是看着周边逐渐空缺的工位，也加重了我的职业发展危机意识，又重新开始捡起了兼职副业这个收入。
网安接私活的渠道 晒了这么多兼职副业受，想必大家都比较关心我的副业收入来源，其实网安接私活的渠道我常去的就这4个。
1.挖SRC漏洞 很多地方都可以去挖SRC漏洞赚钱，合法挖到漏洞后提交到平台，平台就会给予你奖励，最多一个高危漏洞一万多。
综合性平台比如补天、漏洞盒子和CNVD等等，独家SRC也有很多，比如说华为、阿里、腾讯、360等等。
国外的漏洞也可以去挖，国外给的奖励会更高，但除了技术要过硬之外，你还得会英语能沟通交流。
2.接安全测试委托 在公司允许的情况下去对公司产品进行网安检测和渗透测试，发现漏洞后提交给修复方案和渗透测试报告，这个我经常去程序员客栈和一品威客等IT兼职平台去接。
相比较于个人私下接活，平台会更加方便一些，不用跟乙方扯来扯去，而且不用害怕甲方卷钱跑路。
3.投稿 像比较大的网安平台会不定期举办有奖投稿活动，比如说freebuff和CSDN等等平台，CSDN我没弄过，但freebuff我倒是经常由投稿，奖金有几百到几千不等。
做了那么多年网安，只要我想说，那绝对有很多故事可以讲的。
提醒大家一个点：网安的私活不是一次性的，很多以前合作过的甲方都会在后面有事的时候有偿来找我，所以人脉这一块也很重要。
4.参加CTF 通俗易懂的讲，CTF也叫作网络安全攻防大赛。这类大赛一般都是由政府安全部门、从事信息安全的企业、高校等等单位主办的。目的也很简单，一般都是为了加强国家网络信息安全建设，挖掘网络信息安全人才。当然你夺旗之后，也会有对应的奖金。
.
但关键是你的技术得学得到位！
接下来我给大家讲讲黑客/网安这一块该学哪些东西。
网络安全学习路线&amp;学习资源 网络安全的知识多而杂，怎么科学合理安排？ 下面给大家总结了一套适用于网安零基础的学习路线，应届生和转行人员都适用，学完保底6k！就算你底子差，如果能趁着网安良好的发展势头不断学习，日后跳槽大厂、拿到百万年薪也不是不可能！
初级网工 1、网络安全理论知识（2天） ①了解行业相关背景，前景，确定发展方向。
②学习网络安全相关法律法规。
③网络安全运营的概念。
④等保简介、等保规定、流程和规范。（非常重要）
2、渗透测试基础（一周） ①渗透测试的流程、分类、标准
②信息收集技术：主动/被动信息搜集、Nmap工具、Google Hacking
③漏洞扫描、漏洞利用、原理，利用方法、工具（MSF）、绕过IDS和反病毒侦察
④主机攻防演练：MS17-010、MS08-067、MS10-046、MS12-20等
3、操作系统基础（一周） ①Windows系统常见功能和命令
②Kali Linux系统常见功能和命令
③操作系统安全（系统入侵排查/系统加固基础）
4、计算机网络基础（一周） ①计算机网络基础、协议和架构
②网络通信原理、OSI模型、数据转发流程
③常见协议解析（HTTP、TCP/IP、ARP等）
④网络攻击技术与网络安全防御技术
⑤Web漏洞原理与防御：主动/被动攻击、DDOS攻击、CVE漏洞复现
5、数据库基础操作（2天） ①数据库基础
②SQL语言基础
③数据库安全加固
6、Web渗透（1周） ①HTML、CSS和JavaScript简介
②OWASP Top10
③Web漏洞扫描工具
④Web渗透工具：Nmap、BurpSuite、SQLMap、其他（菜刀、漏扫等）
恭喜你，如果学到这里，你基本可以从事一份网络安全相关的工作，比如渗透测试、Web 渗透、安全服务、安全分析等岗位；如果等保模块学的好，还可以从事等保工程师。薪资区间6k-15k
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73ab6770cca164c30dd1d03490a4f18d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d138556d7b249ec96ad3afae059430a/" rel="bookmark">
			【前端面试】五、框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 Vue2
2 Vue3 3 React 4 Angular 1 Vue2 Vue2 是目前仍被广泛使用的前端框架之一，其特点包括响应式数据绑定、组件化开发等。
响应式系统：Vue2 使用 Object.defineProperty 来实现数据的响应式。每个组件实例在创建时，会将 data 中的属性转换为 getter/setter，从而实现数据变化时视图自动更新的功能。
组件化开发：Vue2 鼓励开发者将界面拆分成多个可复用的组件，每个组件包含自己的模板、逻辑和样式。组件之间可以通过 props 进行数据传递，通过 events 进行通信。
指令系统：Vue2 提供了一套丰富的指令（Directives），如 v-bind、v-model、v-on 等，用于在模板中声明式地绑定数据、事件等。
生命周期钩子：Vue2 组件包含多个生命周期钩子（如 created、mounted、updated、destroyed 等），允许开发者在不同阶段执行特定的逻辑。
2 Vue3 Vue3 相比 Vue2 进行了大量的内部优化和重构，引入了Composition API等新特性。
Proxy 响应式系统：Vue3 使用 Proxy 替代了 Vue2 中的 Object.defineProperty，实现了更加全面和高效的响应式系统。Proxy 可以直接监听对象和数组的变化，而无需对它们进行特殊处理。
Composition API：Vue3 引入了 Composition API，它提供了一种更灵活的方式来组织和重用逻辑。与 Vue2 的 Options API 不同，Composition API 允许开发者将组件的逻辑按照功能组织成不同的函数（如 setup、computed、watch 等）。
Fragment、Teleport 和 Suspense：Vue3 新增了 Fragment、Teleport 和 Suspense 三个组件，分别用于处理多根节点、远程DOM挂载和异步组件的等待状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d138556d7b249ec96ad3afae059430a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2096e2c208b5d3332ef0b6fe2cbe1409/" rel="bookmark">
			科普文：万字细说微服务及其框架Netflix，Spring Cloud，Spring Cloud Alibaba梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概叙 微服务（Microservices）是一种软件架构风格，它将单一的应用程序拆分为多个小的服务，每个服务都是独立运行和部署的。每个微服务通常只专注于一个业务功能，具有自己的数据存储，并且通过轻量级的通信机制（如HTTP或消息队列）与其他服务进行交互。
微服务发展到现在，不仅仅只是服务治理，从架构设计，编码，测试，部署运维（版本管理、CICD集成发布，部署，故障跟踪、负载均衡、弹性扩展、容器化、云原生 ），服务治理（负载均衡、弹性扩展、故障跟踪、容错），再结合需求分析、产品设计，微服务基本是涵盖了软件工程的整个生命周期。
所以微服务其实是一套完善的解决方案，供大家选择。
微服务架构主要特点 独立开发：不同的微服务可以由不同的团队开发，每个团队可以选择最适合其服务的技术栈和开发工具。
独立部署：每个微服务可以独立部署，不需要影响其他服务。这使得开发和运维更加灵活，能够更快地响应业务需求的变化。
单一职责：每个微服务专注于完成特定的业务功能，遵循单一职责原则（SRP），这使得代码更加简洁、维护更加容易。
去中心化的数据管理：每个微服务可以有自己的数据库，这样可以减少服务之间的数据耦合。
分治原理：单个服务的吞吐始终是有限的，通过微服务拆分可以突破扩展上限，分拆流量可支撑全球化的业务，不再受机房规模甚至地域影响
弹性扩展：微服务架构可以按需扩展某个特定的服务，而不是整体应用。这样更能有效利用资源，提高应用的可用性和性能。
容错性：微服务的独立性使得某个服务的故障不会直接导致整个系统的崩溃，提高了系统的容错性。
风险隔离：高度自治和高度隔离，明显不让低等级的服务影响高等级
微服务的优势 灵活性：能够快速适应业务需求的变化，通过独立部署来实现快速迭代。
技术多样性：允许使用不同的技术栈来实现不同的微服务，充分利用各种技术的优势。
故障隔离：一个微服务的失败不会影响整个系统，增强了系统的稳定性。
微服务的不足 分布式系统的固有复杂性：微服务架构是基于分布式的系统，而构建分布式系统必然会带来额外的性能开销和可靠性挑战。
服务的依赖管理和测试：在单体应用中，通常使用集成测试来验证依赖是否正常。而在微服务架构中，单元测试和整条服务链路的可用性都需要关注。
有效的配置版本管理：需要引入配置的版本管理、环境管理。
自动化的部署流程：有效地构建自动化部署体系，配合服务网格、容器技术，是微服务面临的另一个挑战。
对于DevOps有更高的要求：开发者也需承担起整个服务的生命周期的责任，包括部署、链路追踪、监控。构建全功能的团队，也是一个不小的挑战。
运维成本飙升：运维主要包括配置、部署、监控与告警和日志收集四大方面。微服务架构中，每个微服务粒度都需要独立地配置、部署、监控和收集日志，成本呈指数级增长。服务化粒度越细，运维成本越高。
微服务架构的适用场景 微服务架构的适用场景广泛，尤其在以下情况下表现尤为突出：
1. 业务复杂，模块多且相对独立：当业务复杂到单体应用难以维护时，将应用拆分为多个微服务是一个明智的选择。每个微服务专注于一个业务领域，实现业务的高度解耦和快速迭代。
2. 团队多，管理隔离：随着公司规模的扩大，团队数量也在不断增加。每个团队都有自己的管理方式和负责的业务领域。微服务架构可以实现团队自治，提高开发效率。
3. 应用规模大，并发用户多：微服务架构可以横向分布式扩展，轻松应对应用规模的不断扩大和海量用户增长。
4. 快速迭代、持续交付：在业务需求快速变化的情况下，微服务架构可以实现快速的开发、测试和部署，支持持续交付和持续集成。
微服务的挑战 复杂性增加：系统由许多微服务组成，需要有效的服务管理和协调，增加了系统的复杂性。
性能：分布式系统是跨进程、跨网络的调用， 受网络延迟和带宽的影响。（服务拆分后必须要面对的问题。性能不够，机器来凑）
可靠性：由于高度依赖于网络状况， 任何一次的远程调用都有可能失败，随着服务的增多还会出现更多的潜在故障点。如何提高系统的可靠性、降低因网络引起的故障率，是系统构建的一大挑战。（相对性的4个9的可用性很难）
分布式系统管理：微服务架构需要处理分布式系统的一些常见问题，如网络延迟、数据一致性、服务发现等。
分布式通信：分布式通信大大增加了功能实现的复杂度，并且 伴随着定位难、调试难等问题
数据一致性：需要保证分布式系统的数据强一致性，即 在 C（一致性）A（可用性）P（分区容错性） 三者之间做出权衡。
部署和运维：需要一套完善的持续集成和持续部署（CI/CD）流程以及监控、日志系统，以确保微服务的高效运作。（增加了复杂性，运维人员要求提高了，工作量多了）
安全性问题：微服务架构涉及多个服务之间的网络通信，存在数据泄露、劫持等安全风险，需要实施适当的安全措施。（增加了复杂性）
微服务架构特别适用于大型、复杂且需要频繁迭代和部署的大型应用，但对中小型应用可能过于复杂。因此，选择微服务架构需要根据具体业务需求和团队能力来做出决定。
是否需要微服务 四种场景可以考虑使用微服务 规模大（团队超过10人，分工协作，专人专职）
业务复杂度高（系统超过5个子模块，单一服务不利于协作开发，也不利于系统稳定性）
业务需求变化快（具体需求可以拆分到某几个服务上，而不是整个系统都需要整改。例如：电商上的营销系统）
分布式系统的三高要求：高可并发、高可用、高性能
其他因素筛选微服务 软件功能变化频繁，快速迭代，缩短交付周期为核心的业务（专人专职，分工协作）。
模块有独立的生命周期，服务复用，降本增效，减少重复造轮子
有独立的隔离性需求和扩展性需求（容错，单一服务的容错性差）
简化的外部依赖（Facade模式（外观模式）场景：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。）
外观（Facade）模式包含以下主要角色： 1.外观（Facade）角色：为多个子系统对外提供一个共同的接口。 2.子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 3.客户（Client）角色：通过一个外观角色访问各个子系统的功能。 微服务拆分和改造 1.基于业务逻辑拆分 基于业务逻辑拆分相对好理解一点，典型的单一职责原则，我们将功能相近的业务整合到一个服务颗粒上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2096e2c208b5d3332ef0b6fe2cbe1409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14aa9c791bea776304f250f33f817255/" rel="bookmark">
			Charles怎么修改参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Charles怎么修改参数 1、再【Structure】下，找到需要抓取的包，鼠标右键，点中断点。
2、在【Proxy】-点击【Breakpoint Settings…】
3、双击设置断点的接口
4、勾选后，点击【OK】。
5、再次刷新，重新发请求，就可以进入设置好的断点界面
6、就可以对所需要修改的参数进行修改，
7、最后点击【Execute】就可以啦！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/90/">«</a>
	<span class="pagination__item pagination__item--current">91/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/92/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>