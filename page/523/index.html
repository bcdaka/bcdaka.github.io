<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34bdff67727c81d5a2b9606a3301001/" rel="bookmark">
			Flink1.16.0下载安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载前需要先下载Linux版本JDK，下载链接：https://download.csdn.net/download/fvyutk/88772054
一、下载 一、通过命令行下载
#下载Flink1.16.0压缩包 wget https://archive.apache.org/dist/flink/flink-1.16.0/flink-1.16.0-bin-scala_2.12.tgz #解压 tar -zxvf flink-1.16.1-bin-scala_2.12.tgz 二、Windows下载
1.访问下方链接即可下载
https://archive.apache.org/dist/flink/flink-1.16.0/flink-1.16.0-bin-scala_2.12.tgz
2.下载后通过Xftp传输至虚拟机/服务器指定目录（虚拟机/服务器如何连接Xftp：http://t.csdnimg.cn/NksST）
3.传输成功后，同样操作进行解压
#解压 tar -zxvf flink-1.16.1-bin-scala_2.12.tgz 二、启动Flink 一、进入到Flink-1.16.0/bin目录下
cd flink-1.16.0/bin 二、启动Flink
1.启动
./start-cluster.sh 如图显示即启动成功 2.停止
./stop-cluster.sh 如图显示即启动失败
访问FlinkUI：http://t.csdnimg.cn/hTh9M 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb92f0f19176d800e2a7b887c28c7f6/" rel="bookmark">
			抖音出的AI工具火了！自动生成抖音文案，一键脚本数字人成片！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些结论 抖音即创是一个一站式的智能创意生产与管理平台。
视频创作: AI视频脚本、数字人、一键成片
图文创作: 商品卡、图文工具
直播创作: AI背景、AI文案
抖音即创目前处于公测，全部功能免费使用！
抖音即创是什么？ “抖音即创”是一个集智能创意生产与管理于一体的全面平台，旨在通过先进的AI技术为用户提供一站式的创意解决方案。它的核心特点在于利用AI技术帮助用户高效地生产和管理创意内容，从而提升工作效率和创造力。平台不仅提供了视频创作和图文生成等基础功能，还包括直播工具等更多实用服务。这些工具不仅适用于个人用户，也能满足企业和商业用户的需求。
“抖音即创”的智能创意生产功能，通过深度学习和数据分析，使用户能够快速生成高质量的创意内容。它能够根据用户的需求和偏好，提供个性化的创意建议和解决方案。此外，平台的管理分析功能帮助用户有效地规划和优化内容策略，从而在竞争激烈的内容市场中脱颖而出。抖音即创通过其强大的功能，为创意工作者提供了一个高效、便捷的工作环境，从而释放他们的创意潜能，提升内容创作的质量和效率。
抖音即创有哪些功能 视频创作：即创内置了多种AI视频创作工具，如智能编剧、数字人物、一键成片等，使用户能够快速生成高质量的视频内容。这些工具利用先进的AI技术，不仅提高了视频内容的创意性和吸引力，而且显著提升了制作效率。
图文创作：提供智能图文生成工具，能够快速制作微信文章、产品详情等图文内容。这一功能特别适合需要大量图文内容的自媒体从业者和电商平台，帮助他们轻松应对内容创作的挑战。
直播创作：支持AI直播背景、直播文案等创作工具，用户可以轻松制作适用于抖音、快手等平台的直播内容。这一功能为直播行业的内容创作者提供了极大的便利，有助于提升直播内容的专业度和观看体验。
如何使用抖音即创 访问即创官网，登录或注册巨量引擎的账号，支持手机号码和邮箱注册。由于目前即创只有网页端，所以只能通过网页使用。
https://aic.oceanengine.com/
绑定公司和组织，可以创建或加入组织，实测任意输入一个组织名称即可。
回到即创工作台，选择你要使用的功能即可。
对于视频创作，可以利用平台提供的智能编剧和一键成片等工具，上传素材并根据提示操作，快速生成视频。
在图文创作方面，可以使用智能图文生成工具，输入相关信息和关键词，平台会自动生成相应的图文内容。
对于直播创作，可以选择AI直播背景和文案生成工具，定制个性化的直播场景和内容。
抖音即创使用测试 推荐阅读 白嫖GPT4，Dalle3和GPT4V - 字节开发的Coze初体验！附教程及提示词Prompt
​当我们说“少即是多”时，我们在谈论新闻：让ChatGPT重塑你的新闻阅读
字节开发的Coze进阶使用：用免费的GPT4打造一个专属的新闻播报机器人！附教程及提示词Prompt
福布斯2024年十大AI趋势预测：颠覆性创新与挑战即将到来（中文概要版）
盘点那些免费的AI对话工具（国内篇）：国内TOP3 AI聊天机器人产品介绍
AI聊天机器人，一个就够了：文心一言、讯飞星火、通义千问AI聊天机器人深度对比（一）
AI聊天机器人，一个就够了：文心一言、讯飞星火、通义千问AI聊天机器人深度对比（二）
人工智能时代的领跑者：你必须了解的全球三大AI聊天机器人！
ChatGPT和文心一言哪个更好用？一道题告诉你答案！
关于ChatGPT，你可能不知道的10个真相
微软Copilot全新升级：Copilot Pro为个人和企业释放前所未有的AI能力
最新消息，GPT-5终于要来了！比尔盖茨专访OpenAI CEO山姆奥特曼: 揭示GPT-5神秘面纱【附音频原文和访谈文稿】
探索字节跳动的“小悟空”：超200款AI工具一站式体验，承包你所有AI需求！附教程及提示词模板
我用一张照片跳出南方小土豆版科目三，可以抢网红饭碗吗？
AI Weekly『1月15-21日』: OpenAI筹集资金建造AI芯片工厂；马斯克加码AI投资，共投入110亿美金；微软推出Copilot Pro；2024年CES大会人工智能主导
Midjourney V6有多厉害，看完这27张图你就明白了！
欢迎关注我的公众号“AI信息Gap”，原创技术文章第一时间推送。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15876cfd0b0311b58c5cecc7d2f3543f/" rel="bookmark">
			修复现网漏洞扫描结果项：ZooKeeper 未授权访问[原理扫描]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 某主机漏扫后，有高危风险项需要修复：ZooKeeper 未授权访问[原理扫描]
问题描述 现网zookeeper是kafka自带的，版本号2.8.1 (Commit:839b886f9b732b15)
解决方案： 使用最简单的处理方案，端口加白。
CentOS7.9下，修改/etc/firewalld/zones/public.xml文件，内容为：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;zone&gt; &lt;short&gt;Public&lt;/short&gt; &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt; &lt;service name="ssh"/&gt; &lt;service name="dhcpv6-client"/&gt; &lt;port protocol="tcp" port="9092"/&gt; &lt;port protocol="tcp" port="22"/&gt; &lt;port protocol="tcp" port="443"/&gt; &lt;/zone&gt; 然后systemctl restart firewalld即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7229dc7cc25a849ebce609eb84da86d1/" rel="bookmark">
			【JavaWeb】web乱码总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 web乱码问题一、 HTML乱码二、 Tomcat控制台乱码三、 IDEA sout 乱码四、 请求乱码4.1 GET请求乱码1. 分析：2. 演示：3. 解决： 4.2 POST请求乱码1. 分析：2. 演示：3. 解决： 五、 响应乱码1.分析：2. 演示：3. 解决： 总结 web乱码问题 乱码问题产生的根本原因：
数据的编码和解码使用的不是同一个字符集使用了不支持某个语言文字的字符集
一、 HTML乱码 设置项目文件的字符集要使用一个支持中文的字符集
查看当前文件的字符集
查看项目字符集 配置 将Global Encoding 全局字符集Project Encoding 项目字符集Properties Files 属性配置文件字符集设置为UTF-8 当前视图文件的字符集通过&lt;meta charset="UTF-8"&gt; 来告知浏览器通过什么字符集来解析当前文件
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 主页 &lt;/body&gt; &lt;/html&gt; 二、 Tomcat控制台乱码 在tomcat10和tomcat9版本中,
修改 tomcat/conf/logging.properties中,
所有的UTF-8为GBK即可
三、 IDEA sout 乱码 sout乱码问题,设置JVM加载.class文件时使用UTF-8字符集
设置虚拟机加载.class文件的字符集和编译时使用的字符集一致 -Dfile.encoding=UTF-8
四、 请求乱码 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7229dc7cc25a849ebce609eb84da86d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845d93d4f9a64c18df33a73e38ef0bdb/" rel="bookmark">
			Python - SnowNLP 情感分析与自定义训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.引言
二.SnowNLP 情感分析
1.安装 SnowNLP
2.测试 SnowNLP
三.SnowNLP 自定义训练
1.数据集准备
2.训练与保存
3.模型替换
4.模型测试
5.SnowNLP 原理
◆ Bayes 公式
◆ 先验概率
◆ 后验概率
◆ 情感模型
四.总结
一.引言 SnowNLP 是一个基于 Python 的简洁的自然语言处理工具包，它提供了文本情感分析、关键词提取、文本分类等功能。该工具包具有简单易用的接口，可帮助用户快速实现文本处理和情感分析任务。SnowNLP 的设计理念是简洁高效，它采用了一些先进的自然语言处理算法，同时也尽量减少了不必要的复杂性，使得用户可以轻松地应用它来处理文本数据。本文主要包括两部分:
◆ SnowNLP 情感分析
◆ SnowNLP 自定义训练
二.SnowNLP 情感分析 1.安装 SnowNLP pip install snownlp -i https://pypi.tuna.tsinghua.edu.cn/simple 出现 Successfully 即为安装成功，博主这里 Py == 3.8、snownlp == 0.12.3。
2.测试 SnowNLP from snownlp import SnowNLP def sentiment_analysis(text): # 使用SnowNLP对中文文本进行情感分析 s = SnowNLP(text) # SnowNLP的sentiments方法返回情感倾向分数，越接近1表明情感越积极，越接近0表明情感越消极 sentiment_score = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845d93d4f9a64c18df33a73e38ef0bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948b0c8689b07edb5bea3d30d70a5d15/" rel="bookmark">
			创建表：HBase表的定义与创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 在大数据时代，HBase作为一种高性能、可扩展的列式存储系统，已经成为了许多企业和组织的首选。本文将深入探讨HBase表的定义与创建，揭示其核心概念、算法原理、最佳实践和实际应用场景。
1. 背景介绍 HBase是Apache Hadoop项目的一个子项目，基于Google的Bigtable设计。它提供了一个分布式、可扩展的列式存储系统，用于存储和管理大量结构化数据。HBase的核心特点包括：
高性能：HBase支持随机读写操作，可以在毫秒级别内完成，适用于实时数据处理。可扩展：HBase通过分布式架构实现了水平扩展，可以根据需求增加更多的节点。数据一致性：HBase支持强一致性，确保数据的准确性和完整性。高可用性：HBase提供了自动故障转移和数据备份等功能，确保数据的可用性。 HBase表是HBase系统中的基本组成单元，用于存储和管理数据。在本文中，我们将深入探讨HBase表的定义、创建、操作和应用。
2. 核心概念与联系 在HBase中，表是一种逻辑上的概念，实际上是由一组Region组成的。Region是HBase中的基本存储单元，包含一定范围的行和列数据。每个Region都有一个唯一的RegionServer，负责存储和管理该Region的数据。
HBase表的定义包括：
表名：表名是表的唯一标识，用于区分不同的表。列族：列族是表中所有列的父类，用于组织和存储列数据。列族是创建表时指定的，一旦创建，不能修改。列：列是表中的基本数据单元，可以包含多种数据类型，如整数、字符串、浮点数等。行：行是表中的基本数据单元，可以包含多个列。 HBase表的创建涉及到以下步骤：
定义表名和列族。创建表。插入数据。查询数据。 在本文中，我们将详细介绍这些步骤，并提供代码实例和解释。
3. 核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1 算法原理 HBase表的创建涉及到以下算法原理：
分区：HBase表的数据分布在多个Region上，每个Region包含一定范围的行和列数据。HBase使用一种自动分区策略，根据行键的哈希值将数据分布在不同的Region上。索引：HBase使用一种自适应索引机制，根据访问模式动态地创建和删除索引。索引可以加速查询操作，但也会增加存储开销。数据压缩：HBase支持多种数据压缩算法，如Gzip、LZO等，可以减少存储空间占用和提高读写性能。 3.2 具体操作步骤 创建HBase表的具体操作步骤如下：
启动HBase集群。使用HBase Shell或者Java API创建表。定义表名、列族、列等属性。执行创建表的SQL语句。插入数据。查询数据。 3.3 数学模型公式详细讲解 在HBase中，数据存储和查询涉及到一些数学模型公式。例如：
哈希函数：用于将行键映射到Region的公式为：$h(row_key) \mod N$，其中$N$是Region数量。数据压缩：支持多种压缩算法，如Gzip、LZO等，可以通过公式计算压缩后的数据大小。查询性能：查询性能受到多种因素影响，如数据分布、索引、缓存等，可以通过公式计算查询性能指标。 在本文中，我们将详细讲解这些数学模型公式，并提供代码实例和解释。
4. 具体最佳实践：代码实例和详细解释说明 在本节中，我们将提供一个具体的HBase表创建、插入和查询的代码实例，并详细解释说明。
4.1 创建表 首先，我们需要使用HBase Shell或者Java API创建表。以下是一个使用Java API创建表的示例代码：
```java import org.apache.hadoop.hbase.HBaseConfiguration; import org.apache.hadoop.hbase.HColumnDescriptor; import org.apache.hadoop.hbase.TableDescriptor; import org.apache.hadoop.hbase.client.HBaseAdmin; import org.apache.hadoop.hbase.client.HTable; import org.apache.hadoop.hbase.util.Bytes;
public class CreateTableExample { public static void main(String[] args) throws Exception { // 获取HBase配置 Configuration conf = HBaseConfiguration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/948b0c8689b07edb5bea3d30d70a5d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eca92f6654e988f1f754a2256ea45f7/" rel="bookmark">
			画出你的创意世界：eSheep带你进入AIGC的绘图殿堂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在互联网上，有一个让人们聚集在一起交流创意和分享作品的地方。它就是eSheep，全称为一站式的AIGC社区。eSheep.com是国内知名的AIGC在线画图网站，为用户提供海量模型，并支持在线AI画图。无论你是AIGC的新手还是资深玩家，这个网站都将成为你探索创作世界的好伙伴。
Ai工具集导航（Ai-321.com）| eSheep官网：https://www.esheep.com
工具简介
eSheep是一个绘图工具，专注于为用户提供最佳的绘图体验。它拥有简洁而直观的界面，让用户能够轻松上手。不仅如此，eSheep还支持在线AI画图，这意味着你可以使用智能算法来辅助你的创作，让绘图变得更加高效和精确。
需求人群
eSheep适用于广大爱好绘图和创作的人群。无论你是学生、职场人士还是艺术家，只要你对AIGC绘图有兴趣，都可以在eSheep找到你所需的资源和交流社区。
产品特色
eSheep的独特之处在于它提供了海量的模型供用户选择，这些模型涵盖了各种风格和类型，帮助用户快速构建自己的创作世界。此外，eSheep还兼容并支持AI绘图，为用户提供更多的实验和创意空间，使他们的作品更加突出和独特。
功能列表展示
1. 海量模型库：包含各种风格和类型的模型，帮助用户快速创建作品。
2. AI画图辅助：智能算法辅助用户创作，提供高效和精确的绘图体验。
3. 作品上传和交流：用户可以将自己的AIGC作品上传到eSheep，并与其他用户进行交流和互动。
使用场景
eSheep适用于各类创意和艺术项目，例如插图设计、动画创作、游戏开发等。无论你是个人创作者还是团队合作，都可以在这个平台上找到所需的工具和资源，与他人分享和协作。
评测总结
通过对eSheep的使用和评估，我们发现它是一个功能强大且易于上手的AIGC绘图工具。它不仅提供了丰富多样的模型库，还支持AI绘图辅助，使用户能够更高效地创作出独特的作品。与其他绘图工具相比，eSheep在用户交流和互动方面也非常出色。总的来说，eSheep是一个值得推荐的AIGC社区。
SEO关键词建议：
1. AIGC在线画图
2. eSheep社区
3. 在线AI画图工具
4. 创意绘图平台
5. 独特的模型库
6. 高效的绘图体验
7. 创意和艺术项目
8. 交流及互动平台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aea69586e654aa6f732c1ea5106ff43/" rel="bookmark">
			RabbitMQ控制界面详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、overview 概述 1.1、Totals 总计 Ready： 待消费的消息总数。Unacked： 待应答的消息总数。Total：总数 Ready+Unacked。 Publish： producter pub消息的速率。Publisher confirm： broker确认pub消息的速率。Deliver(manual ack)： customer手动确认的速率。Deliver( auto ack)： customer自动确认的速率。Consumer ack： customer正在确认的速率。Redelivered： 正在传递'redelivered'标志集的消息的速率。Get (manual ack)： 响应basic.get而要求确认的消息的传输速率。Get (auto ack)： 响应于basic.get而发送不需要确认的消息的速率。Return： 将basic.return发送给producter的速率。Disk read： queue从磁盘读取消息的速率。Disk write： queue从磁盘写入消息的速率。 Connections：client的tcp连接的总数。Channels：通道的总数。Exchange：交换器的总数。Queues：队列的总数。Consumers：消费者的总数。 1.2、Nodes 节点 启动一个broker都会产生一个node。Name：broker名称File descriptors：broker打开的文件描述符和限制。Socket descriptors：broker管理的网络套接字数量和限制。当限制被耗尽时，RabbitMQ将停止接受新的网络连接。Erlang processes：erlang启动的进程数。Memory：当前broker占用的内存。Disk space：当前broker占用的硬盘。Uptime：当前broker持续运行的时长。Info：未知。Reset stats：未知。 2、Connections：当前所有客户端活动的连接。包括生成者和消费者。 Virtual host：所属的虚拟主机。Name：名称。User name：使用的用户名。State：当前的状态，running：运行中；idle：空闲。SSL/TLS：是否使用ssl进行连接。Protocol：使用的协议。Channels：创建的channel的总数。From client：每秒发出的数据包。To client：每秒收到的数据包。 3.Channels：当前连接所有创建的通道。 channel：名称。Virtual host：所属的虚拟主机。User name：使用的用户名。Mode：渠道保证模式。 可以是以下之一，或者不是：C: confirm。T：transactional(事务)。State ：当前的状态，running：运行中；idle：空闲。Unconfirmed：待confirm的消息总数。Prefetch：设置的prefetch的个数。Unacker：待ack的消息总数。publish：producter pub消息的速率。confirm：producter confirm消息的速率。deliver/get：consumer 获取消息的速率。ack：consumer ack消息的速率。 4、Exchanges 交换机 Virtual host：所属的虚拟主机。Name：名称。Type：exchange typeFeatures：功能。 可以是以下之一，或者不是：D: 持久化。T：Internal，存在改功能表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定，否则可以推送消息也可以绑定。Message rate in：消息进入的速率。Message rate out：消息出去的速率。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aea69586e654aa6f732c1ea5106ff43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e735ff959910c83e0d851de6e9def1/" rel="bookmark">
			【C&#43;&#43;进阶07】哈希表and哈希桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、哈希概念 顺序结构以及平衡树中
元素关键码与存储位置没有对应关系
因此查找一个元素
必须经过关键码的多次比较
顺序查找时间复杂度为O(N)
平衡树中为树的高度，即O( l o g 2 N log_2 N log2​N)
搜索效率 = 搜索过程中元素的比较次数
理想的搜索方法：不经任何比较
一次直接从表中获取想要的元素
构造一种存储结构
通过某种函数(hashFunc)使元素的存储位置
与它的关键码之间建立一一映射的关系
就能在查找时通过该函数直接找到该元素
向该结构中：
插入元素：
根据待插入元素的关键码
以此函数计算出该元素的存储位置并按此位置
进行存放
搜索元素：
对元素的关键码进行同样的计算
把求得的函数值当做元素的存储位置
在结构中按此位置取元素比较
若关键码相等，则搜索成功
该方式即为：
哈希(散列)方法
哈希方法中使用的转换函数称为：
哈希(散列)函数
构造出来的结构称为：
哈希表(Hash Table)(或者称散列表)
例如：
数据集合{1，7，6，4，5，9};
哈希函数设置为：
hash(key) = key % capacity; capacity：
存储元素底层空间总的大小
二、哈希冲突 不同关键字通过相同的哈希函数
计算出相同的哈希地址
该种现象称为哈希冲突或哈希碰撞
把具有不同关键码
而具有相同哈希地址的数据元素称为“同义词”
11、21、31…数据经过哈希函数计算都为1
都插入在下标为1的地方便会冲突
三、哈希函数 引起哈希冲突的一个原因可能是：
哈希函数设计不够合理
哈希函数设计原则：
哈希函数的定义域必须包括
需要存储的全部关键码
而如果散列表允许有m个地址时
其值域必须在0到m-1之间哈希函数计算出来的地址能均匀分布在
整个空间中哈希函数应该比较简单 常用哈希函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e735ff959910c83e0d851de6e9def1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daad647bdd58035dcc86cefe0bdd4314/" rel="bookmark">
			四.Winform使用Webview2加载本地HTML页面并互相通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Winform使用Webview2加载本地HTML页面并互相通信 往期目录本节目标核心代码实现HTML代码实现的窗体Demo2代码效果图 往期目录 往期相关文章目录
专栏目录
本节目标 实现刷新按钮点击 C# winform按钮可以调用C# winform代码显示到html上点击HTML按钮可以调用C# winform代码更改html按钮字体 核心代码 C# -&gt; html this.mainView2.ExecuteScriptAsync("调用方(发送消息..)"); html-&gt;C# 确保mainView2的CoreWebView2异步初始化完成 this.mainView2.EnsureCoreWebView2Async(null); 在webview2的CoreWebView初始化之后设置属性 //coreWebview2完成时发生。在完成时进行一系列设置。 this.mainView2.CoreWebView2InitializationCompleted += (object sender, CoreWebView2InitializationCompletedEventArgs e)=&gt;{ this.mainView2.CoreWebView2.Settings.IsScriptEnabled = true; } 在coreWebview2完成时添加WebMessageReceived监听。如下代码。 this.mainView2.CoreWebView2InitializationCompleted += (object sender, CoreWebView2InitializationCompletedEventArgs e) =&gt; { this.mainView2.CoreWebView2.Settings.IsScriptEnabled = true; this.mainView2.CoreWebView2.WebMessageReceived += CoreWebView2_WebMessageReceived; }; 实现接受方法 /// &lt;summary&gt; /// 页面发送消息时，后台接受信息 /// &lt;/summary&gt; private void CoreWebView2_WebMessageReceived(object sender, CoreWebView2WebMessageReceivedEventArgs e) { // e.WebMessageAsJson.ToString();为获取到的JSON字符串 } 实现HTML代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daad647bdd58035dcc86cefe0bdd4314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329a597d856a1079490405fa226d782b/" rel="bookmark">
			前端解析包含图片的excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 1、问题描述 有时候难免会遇到解析excel的情况，现在前端的很多插件都可以实现excel文件中文本内容的解析；但是很多时候excel文件中是带有图片文件的，这个图片文件的提取着实是让人有点头疼的；
本人查阅了很多资料，试了很多方法，结果都是以失败告终！
现决定使用一个迂回战术，完成一次曲线救国，哈哈哈，方法可能不太好，但勉强能够使用，如果有哪位大佬看见，还望指点迷津，跪谢~
2、excel文件 3、实现效果 二、实现思路 第一步，使用XLSX插件，解析excel中的文本内容；第二步，使用JSZip插件，解析excel中的图片内容；第三步，将图片数据和文本数据进行整理，封装成我们最终需要的数据格式； 三、完整代码 &lt;template&gt; &lt;div class="container"&gt; &lt;!-- 长传组件 --&gt; &lt;el-upload action="" :before-upload="beforeUpload" :http-request="() =&gt; {}"&gt; &lt;el-button type="primary"&gt;导入excel&lt;/el-button&gt; &lt;/el-upload&gt; &lt;!-- 表格组件 --&gt; &lt;el-table :data="tableData" border style="width: auto; margin-top: 10px"&gt; &lt;el-table-column :prop="item" :label="item" align="center" v-for="(item, index) in tableColumnLabel" :key="index" &gt; &lt;template #default="scope" v-if="item == 'avatar'"&gt; &lt;img :src="scope.row.avatar" alt="" style="width: 200px" /&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref } from "vue"; import JSZip from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/329a597d856a1079490405fa226d782b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c463312cc6732d696de13fde4e3baecb/" rel="bookmark">
			C语言实现数据结构之迷宫求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务 输入一个任意大小的迷宫数据，用非递归的方法求出一条走出迷宫的路径，并将路径输出。
分析 用结构体定义迷宫结点类型，成员分别储存横坐标、纵坐标、找到通路后的方向；用顺序栈存储路径，通路则入栈、死路则返回。使用二维数组next给结点赋值，使其抵达不同方向的下一结点。双重循环，栈空表示所有路径已经走完（count变量计算通路数量），循环四次表示各结点的四个方向都走过一遍（若遇墙则continue，若已找到下一结点则break）。
栈的top储存步数。（回溯算法）
存储结构设计 /*定义迷宫各结点*/ typedef struct { int x;	//结点的位置 int y; int direction;	//路径的方向 } Elemtype; /*用顺序栈存储路径，通路则入栈，遇死路则返回*/ typedef struct { Elemtype data[MAXSIZE]; int top;	//记录步数 } SeqStack; //新建一个空栈 SeqStack *InitStack () { SeqStack *S; S=(SeqStack *)malloc(sizeof(SeqStack)); S-&gt;top =-1; return S; } //判断是否为空栈 int StackEmpty (SeqStack *S) { if(S-&gt;top==-1) return TRUE; else return FALSE; } //入栈 int Push (SeqStack *S,Elemtype e) { if(S-&gt;top==MAXSIZE-1) return FALSE; S-&gt;top++; S-&gt;data[S-&gt;top]= e; return TRUE; } //出栈并返回 int Pop (SeqStack *S,Elemtype *e) { if(S-&gt;top == -1) return FALSE; *e=S-&gt;data[S-&gt;top]; S-&gt;top--; return TRUE; } //取出栈顶元素 int GetTop (SeqStack *S,Elemtype *e) { if(S-&gt;top == -1) return FALSE; else { *e=S-&gt;data[S-&gt;top]; return TRUE; } } SeqStack *SS; int book[M][M];	//标记数组 int map[M][M];	//地图 char out[M][M][3];	//输出数组 int width,high;	//迷宫的宽高 int count ;	//记录走法 源代码 #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c463312cc6732d696de13fde4e3baecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3efbf6ecdb4f228f923a0d661f9419/" rel="bookmark">
			[已解决]ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables 成功解决报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 在mysql中创建新用户、给数据库授权用户及配置服务器IP时发生的这个报错：ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement。
报错说mysql服务器正在运行不能添加，但是关闭mysql服务器重新登录时会有这个报错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket /var/lib/mysql/mysql.sock（此报错解决方法可参考这篇文章ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket /var/lib/mysql/mysql.sock报错解决-CSDN博客）解决这个报错是要重启mysql服务，这样就会陷入死循环。
解决办法 在mysql窗口中刷新一下配置即可
mysql&gt; flush privileges; Query OK, 0 rows affected (0.02 sec)
这时再进行用户创建和数据库授权IP操作时就会正常进行了
退出mysql，重启mysql服务
[root@localhost bin]# service mysqld restart
Redirecting to /bin/systemctl restart mysqld.service
这样就可以正常操作了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70be5b0b2c8ea01c16cd4e96e6e0e523/" rel="bookmark">
			本地部署轻量级web开发框架Flask并实现无公网ip远程访问开发界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 安装部署Flask2. 安装Cpolar内网穿透3. 配置Flask的web界面公网访问地址4. 公网远程访问Flask的web界面 本篇文章主要讲解如何在本地安装Flask，以及如何将其web界面发布到公网进行远程访问。
Flask是目前十分流行的web框架，采用Python编程语言来实现相关功能。较其他同类型框架更为灵活、轻便、安全且容易上手。它可以很好地结合MVC模式进行开发，开发人员分工合作，小型团队在短时间内就可以完成功能丰富的中小型网站或Web服务的实现。
另外，Flask还有很强的定制性，用户可以根据自己的需求来添加相应的功能，在保持核心功能简单的同时实现功能的丰富与扩展，其强大的插件库可以让用户实现个性化的网站定制，开发出功能强大的网站。
轻量级web开发框架：Flask本地部署及公网远程访问
1. 安装部署Flask 本篇文章代码使用 Python3 运行
安装环境：需要在电脑上安装 Python3 和 pip3。建议安装最新版本
检查是否有安装了pip的可用Python，查看Python和pip版本：
C:&gt; py --version Python 3.N.N C:&gt; py -m pip --version pip X.Y.Z from ... (python 3.N.N) 使用pip安装和更新：
$ pip install -U Flask 创建环境：
conda create -n FLASK python=3.10 激活环境：
conda activate FLASK 创建项目目录：
mkdir FLASK 进入到创建的目录：
cd FLASK 在当前目录启动VS Code：
code . 在VS Code里 FLASK下新建一个文件，名字为 app.py
粘贴下面命令，并保存
# save this as app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70be5b0b2c8ea01c16cd4e96e6e0e523/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9369851ac3191c7233c4ce7db01d6d60/" rel="bookmark">
			Copilot安装和使用最全教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 Copilot 是一款由 GitHub 和 OpenAI 合作开发的代码辅助工具。它基于 OpenAI 的大型语言模型 GPT-3.5，专为帮助软件开发者提升编程效率而设计
Copilot的主要功能是通过理解用户输入的代码注释或部分代码片段、自动生成或补全代码，本文主要介绍copilot的安装和使用
官网：https://github.com/features/copilot/
文档：https://docs.github.com/en/copilot
安装 登陆自己的github帐号，找到左侧栏的 Settings，并找到 Copilot
点击“Start free trial”
点击“Get access to GitHub Copilot”，填写visa信息，可以获取到30天免费试用
当然，如果没有visa卡，或者不想这么麻烦，可以找某宝，一年20多块钱
在VSCode插件中，搜索“Copilot github”，安装即可使用
安装成功，右下角会有以下图标
使用 以快速排序为例子，我们来介绍copilot常用的功能
代码补全 按Tab采用代码建议，按Esc不采纳代码建议。
另外，可以切换建议，下一条建议：Alt（mac键为Fn）+Option+]，上一条建议：Alt+Option+[
多条代码建议 按“Ctrl+Enter”建，可以出现10条建议
右侧选择“Accept Colution”，即可采纳该条建议。
代码注释 可以在代码函数上，加上//，即可自动生成注释
代码交互 可以在函数上方输入"// q: 问题描述"，copilot就会给出回复
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de93731391ff52ceaeab063cfded6163/" rel="bookmark">
			公网环境调试本地配置的Java支付宝沙箱环境模拟支付场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 下载当面付demo2. 修改配置文件3. 打包成web服务4. 局域网测试5. 内网穿透6. 测试公网访问7. 配置二级子域名8. 测试使用固定二级子域名访问 前言 在沙箱环境调试支付SDK的时候，往往沙箱环境部署在本地，局限性大，在沙箱环境中有多种支付场景，往往是多人联合开发，本地环境可能无法满足异地联合，所以把本地环境变成公网环境下进行调试开发会更好。
本次教程，我们将使用支付宝平台提供的沙箱环境，在本地配置测试模拟支付，并做内网穿透，通过cpolar穿透内网，实现在公网环境下的远程访问，无需公网IP，也无需配置路由器。
1. 下载当面付demo 进入支付宝开放平台沙箱应用(https://open.alipay.com/develop/sandbox/app),查看产品列表–&gt;已支持的产品，选择一种支付场景，这里选择 当面付，然后点击查看文档
然后下载官方提供demo,有三种语言,这里以java语言为例,下载java版demo
2. 修改配置文件 demo下载好后，把TradePayDemo和TradePaySDK两个模块倒入开发工具中，这里以IDEA开发工具为例，需要注意，官方要求的JDK版本是1.6
倒入并且设置好JDK版本后,打开TradePayDemo下面的zfbinfo.properties配置文件，填写对应的信息
注意配置文件情况：
第一个配置信息open_api_domain的值需要设置成支付宝开发平台以下对应的值 pid和appid对应以下信息 private_key和public_key和alipay_public_key分别对应以下信息 修改好配置文件后,在Main启动类,右键运行mian方法运行测试配置文件是否正确,出现下单成功表示配置文件正确
3. 打包成web服务 接下来把TradePayDemo这个web项目打包成web服务.
接着右键重新运行Main类的main方法
然后在输出的路径上可以看到出现了一个.war的web war包
接下来把这个war包放在tomcat中的webapps目录下运行.(这里tomcat版本为8.5.84)
运行tomcat
4. 局域网测试 在浏览器上输入http://localhost+:端口号/TradePayDemo_war exploded/index.html，访问支付页面，出现如下界面表示成功
5. 内网穿透 接着使用cpolar穿透本地支付宝支付沙箱环境demo,使得远程可以进行访问沙箱环境进行测试。cpolar支持http/https/tcp协议，不限制流量，操作简单，无需公网IP，也无需路由器。
cpolar官网：https://www.cpolar.com/
在本地安装cpolar内网穿透之后，在浏览器上访问本地9200端口，打开cpolar web ui 界面:http://127.0.0.1:9200。
点击左侧仪表盘的隧道管理——创建隧道，由于tomcat中配置的是8040端口，因此我们要来创建一条http隧道，指向8040端口：
隧道名称：可自定义，注意不要与已有的隧道名称重复协议：http本地地址：8040域名类型：免费选择随机域名地区：选择China top 点击创建
隧道创建成功后，点击左侧的状态——在线隧道列表，可以看到，刚刚创建的隧道已经有生成了相应的公网地址，将其复制下来
6. 测试公网访问 打开浏览器，访问刚刚复制的公网地址，出现如下界面表示公网访问成功
7. 配置二级子域名 由于以上使用cpolar所创建的隧道使用的是随即公网地址，该地址为随机临时地址，24小时内会发生变化，不利于长期远程访问。
因此我们可以为其配置二级子域名，该地址为固定地址，不会随机变化【ps：cpolar.cn已备案】
需要注意，配置固定二级子域名需要将cpolar升级到基础套餐或以上。
登录cpolar官网，点击左侧的预留，选择保留二级子域名，设置一个二级子域名名称，点击保留
地区：选择china二级域名：可自定义描述：即备注，可自定义 地址保留成功后，将其复制下来，本例为alipayTest
访问本地9200端口，打开cpolar web ui 界面，点击左侧的隧道管理——隧道列表，找到支付接口测试隧道，点击右侧的编辑
修改隧道信息：
域名类型：选择二级域名Sub Domain：填写刚刚保留成功的二级子域名 点击更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de93731391ff52ceaeab063cfded6163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2c5b88ea1f267edec80446a5b089fb/" rel="bookmark">
			Hive数据库系列--Hive文件格式/Hive存储格式/Hive压缩格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Hive文件存储格式1.1、行存储与列存储 二、Hive存储格式2.1、TextFile2.2、SequenceFile2.3、RCFile2.4、ORCFile2.4.1-ORC相比较 RCFile 的优点2.4.2-ORC的基本结构 2.5、Parquet2.6、Avro2.7、自定义文件格式 三、Parquet 和 ORC对比3.1、ORC和Parquet有什么区别3.2、Parquet 和 ORC 压缩格式对比 四、实际生产中Hive一般用什么文件格式和压缩方式？五、存储空间与执行效率的对比六. Hive压缩格式6.1、mr支持的压缩格式:6.2、hive配置压缩的方式:6.2.1、开启map端的压缩方式:6.2.2、开启reduce端的压缩方式: 七、hive中存储格式和压缩相结合八、hive主流存储格式性能对比8.1、压缩比比较8.2、存储文件的查询效率测试 本篇主要讲解一下Hive的文件格式，官方文档见《 https://cwiki.apache.org/confluence/display/Hive/FileFormats》、《 https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-StorageFormatsStorageFormatsRowFormat,StorageFormat,andSerDe》 一、Hive文件存储格式 HIve的文件存储格式常见的有四种：textfile 、sequencefile、orc、parquet ，前面两种是行式存储，后面两种是列式存储。
hive的存储格式指表的数据是如何在HDFS上组织排列的。
文件格式类型存储备注使用情况TextFile文本行存储存储为纯文本文件。TEXTFILE是默认的文件格式，除非配置参数hive.default.fileframe具有不同的设置。一般SequenceFile二进制行存储存储为压缩序列文件。生产中基本不会用，k-v格式，比源文本格式占用磁盘更多RCFile二进制列存储存储为记录列文件格式。生产中用的少，行列混合存储，ORC是他得升级版ORC二进制列存储存储为ORC文件格式。ORC支持ACID事务和基于成本的优化器（CBO）。存储列级元数据。生产中最常用，列式存储Parquet二进制列存储生产中最常用，列式存储Avro二进制行存储生产中几乎不用JSONFILE二进制列存储Hive 4.0.0 及以上版本才支持STORED BY非hive的表，例如Hbase、Druid or Accumulo的表INPUTFORMAT and OUTPUTFORMAT自定义的文件格式 注：RCFile 和 ORCFile 并不是纯粹的列式存储，它是先基于行对数据表进行分组(行组)，然后对行组进行列式存储
行存储 VS 列存储 行存储和列存储方式是指数据在磁盘中按照行或者列的方式进行组织和物理存储
行存储 –适合增加、插入、删除、修改的事务处理处理 –对列的统计分析却需要耗费大量的I/O。对指定列进行统计分析时，需要把整张表读取到内存，然后再逐行对列进行读取分析操作
列存储 –对增加、插入、删除、修改的事务处理I/O高、效率低 –非常适合做统计查询类操作，统计分析一般是针对指定列进行，只需要把指定列读取到内存进行操作
1.1、行存储与列存储 行式存储下一张表的数据都是放在一起的，但列式存储下数据被分开保存了。
行式存储：
优点：数据被保存在一起，insert和update更加容易缺点：选择（selection）时即使只涉及某几列，所有数据也都会被读取 列式存储：
优点：查询时只有涉及到的列会被读取，效率高缺点：选中的列要重新组装，insert/update比较麻烦 如下图，箭头的方向代表了数据是如何进行（写入）组织排列的。
【结论：由上图可知】
行式存储一定会把同一行数据存到同一个块中，在select查询的时候，是对所有字段的查询，不可以单独查询某一列。列式存储同一列数据一定是存储到同一个块中，换句话说就是不同的列可以放到不同块中，在进行select查询的时候可以单独查询某一列。 我们看下这几种存储结构的优缺点：
以下表格为例:
1&gt; 水平的行存储结构:
采用行式存储时，数据在磁盘上的组织结构为：
行存储模式就是把一整行存在一起，包含所有的列，这是最常见的模式。这种结构能很好的适应动态的查询。
比如：
select a from tableA 和 select a, b, c, d, e, f, g from tableA 这样两个查询其实查询的开销差不多，都需要把所有的行读进来过一遍，拿出需要的列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2c5b88ea1f267edec80446a5b089fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9855ef6c09e776275dcddce6f1d9ef55/" rel="bookmark">
			MySQLTransactionRollbackException: Lock wait timeout exceeded； try restarting transaction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到 MySQLTransactionRollbackException: Lock wait timeout exceeded; try restarting transaction 这个错误时，通常意味着你的数据库事务在尝试获取一个锁时等待了太长时间。这通常发生在有长时间运行的事务持有锁，而其他事务在等待这个锁时超过了锁等待超时的时间。要解决这个问题，你可以按照以下步骤进行排查和解决
1. 确定哪个事务持有锁 首先，需要找出哪个事务持有了锁并导致其他事务等待。你可以通过运行以下SQL命令来查看当前的锁情况：
sql
SHOW ENGINE INNODB STATUS; 这个命令会显示InnoDB的许多内部运行信息，包括锁等待和死锁信息。在输出的 LATEST DETECTED DEADLOCK 部分，你可以找到有关最近检测到的死锁的信息。在 TRANSACTIONS 部分，你可以看到当前正在运行的事务及其锁定状态。
2. 分析长时间运行的查询 通过分析长时间运行的查询，你可以确定是哪些查询可能导致了锁等待超时。运行以下命令查看长时间运行的事务：
sql
SELECT * FROM information_schema.innodb_trx ORDER BY trx_started; 这将列出当前运行的所有InnoDB事务及其开始时间。
3. 终止长时间运行的事务 如果确定某个事务是导致锁等待超时的原因，且该事务是可以安全中断的，你可以通过杀死该事务来释放其持有的锁
执行 sql KILL 线程 ID;
线程id也就是步骤2 查出来的trx_mysql_thread_id；
4.调整等待时间 SET GLOBAL innodb_lock_wait_timeout = 120; -- 全局设置
SET SESSION innodb_lock_wait_timeout = 120; -- 当前会话设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aaf7ea24477ccb0babf9a014fb45cd8/" rel="bookmark">
			安卓之导致ANR的原因分析，问题定位以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 在Android应用开发中，Application Not Responding（ANR）是一种常见的性能问题，它直接关系到用户体验的质量。当应用在特定时间段内无法及时响应用户的交互或者系统事件时，系统将会抛出ANR错误，提示用户应用已停止响应。为了确保应用的流畅性和用户满意度，理解ANR产生的根源、掌握其精准定位方法以及实施有效的解决方案至关重要。
下面我们将深入探讨ANR的原因、定位流程以及应对措施。
二、ANR原因分析 2.1、主线程阻塞 2.1.1、耗时操作 在Android应用的主线程（UI线程）中执行了过于耗时的操作，例如大量的数据处理、网络请求、数据库访问等。这些操作会阻碍主线程的正常消息循环，进而导致界面无法及时刷新响应用户操作。
2.1.2、同步锁等待 主线程在获取或释放同步锁时长时间等待，例如由于其他线程持有锁而导致主线程被挂起，同样会导致ANR。
2.1.3、资源竞争 应用程序中存在资源竞争，多个线程同时访问共享资源，导致线程间互相等待，主线程阻塞。
2.2、输入事件未及时处理 2.2.1、BroadcastReceiver超时 如果在主线程注册的BroadcastReceiver的onReceive()方法执行时间超过规定阈值（通常是10秒），也会触发ANR。
2.2.2、前台Service超时 若Service在前台运行且在规定时间内未能完成相应的工作，同样可能出现ANR。
2.3、系统资源争抢 2.3.1、IO/CPU密集型操作 大量占用CPU资源或等待IO操作完成导致主线程被抢占，不能及时响应触摸事件或其他UI事件。如前台在玩游戏，可能会导致你的后台广播被抢占。
2.3.2、系统服务无法及时响应 比如获取系统联系人等，系统的服务都是Binder机制，服务能力也是有限的，有可能系统服务长时间不响应导致ANR。
2.4、复杂的布局渲染 布局层级过深或包含大量的视图元素，可能导致界面渲染缓慢。
2.5、内存泄漏 未及时释放的资源占用过多内存，导致应用运行缓慢。
2.6、第三方库或系统服务异常 2.6.1、依赖库bug 某些第三方库存在可能导致主线程阻塞的设计缺陷或BUG。
2.6.2、系统服务故障 与系统服务交互时，若服务出现问题或响应慢也可能造成ANR。
三、ANR问题定位 3.1、Logcat日志分析 3.1.1、查看ANR日志 利用Android Studio自带的Logcat工具，搜索关键词“ANR”或“Input dispatching timed out”，找到ANR发生时刻的日志记录，通常会包含有错误报告和堆栈信息，如导致ANR的进程、线程和代码位置。
3.1.2、解析traces.txt ANR发生时，系统会在设备上生成traces.txt文件，它记录了所有线程的状态，通过ADB工具将其导出分析，可以定位到具体哪个线程可能引起阻塞。
3.2、使用性能分析工具 3.2.1、Android Profiler 实时监控CPU、内存、网络、磁盘I/O等资源使用情况，寻找可能导致ANR的性能瓶颈。
3.2.2、Systrace 系统层级的跟踪工具，能够追踪系统各组件间的交互和调度，帮助找出主线程阻塞的源头。
3.3、ANR检测工具 使用Android提供的ANR检测工具，如Traceview，可以获取应用程序的执行堆栈信息。通过分析堆栈信息，可以准确找到导致ANR的代码位置。
3.4、调试和单步执行 通过在开发工具中进行调试和单步执行，可以逐步跟踪代码的执行过程，找到导致ANR的具体位置和原因。
四、ANR解决方案 4.1、异步化处理 4.1.1、使用异步任务 将耗时操作转移到后台线程（如使用AsyncTask、HandlerThread、ExecutorService等）、异步任务、后台服务。确保主线程专注于UI更新和事件处理。
// 创建一个固定大小的线程池，大小为4 executorService = Executors.newFixedThreadPool(4); // 假设有一个耗时任务 Runnable longRunningTask = new Runnable() { @Override public void run() { // 这里是耗时操作 doSomeHeavyWork(); } }; // 将耗时任务提交给线程池执行 executorService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aaf7ea24477ccb0babf9a014fb45cd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a0db93af131a25a93ef25106a5f7bf/" rel="bookmark">
			idea、mybatis报错Property ‘sqlSessionFactory‘ or ‘sqlSessionTemplate‘ are required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误通常与MyBatis的配置有关，涉及到MyBatis的SqlSessionFactory或SqlSessionTemplate的配置问题。以下是一些可能的解决方案：
1.检查DataSource配置： 确保你的数据源（DataSource）被正确配置。在Spring Boot中，你可以使用application.properties或application.yml文件来配置数据源。例如：
spring:
datasource:
url: jdbc:mysql://localhost:3306/your_database
username: your_username
password: your_password
driver-class-name: com.mysql.cj.jdbc.Driver
2.MyBatis配置文件： 如果你使用的是MyBatis，确保MyBatis的配置文件（比如mybatis-config.xml）正确配置，并且位于正确的位置。这个文件通常包含有关SqlSessionFactory的配置。
&lt;!-- mybatis-config.xml --&gt;
&lt;configuration&gt;
&lt;!-- 其他配置 --&gt;
&lt;/configuration&gt;
3.Mapper扫描配置： 如果你使用了@MapperScan注解，确保它的basePackages属性正确指定了你的Mapper接口所在的包。例如：
@MapperScan("com.example.mapper")
4.MyBatis的Mapper接口： 确保你的Mapper接口标记了@Mapper注解，或者在启动类上使用@MapperScan注解时，它被正确扫描到。
@Mapper
public interface YourMapper {
// Mapper方法
}
5.Spring Boot版本兼容性： 确保你的Spring Boot版本和MyBatis版本兼容。有时候，不同版本的Spring Boot可能需要特定版本的MyBatis。
（不要觉得到最后才考虑降版本，如果其他都对了很有可能问题就是其中一个的版本太高）
6.检查依赖： 确保你的项目中包含了正确版本的MyBatis和MyBatis-Spring的依赖。
&lt;!-- MyBatis 依赖 --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
&lt;version&gt;your_version&lt;/version&gt;
&lt;/dependency&gt;
如果以上步骤都没有解决问题，可以尝试在你的应用程序中创建一个自定义的SqlSessionFactoryBean（如果没有的话）并手动配置，确保正确的MyBatis配置被应用。例如：
@Configuration
public class MyBatisConfig {
@Bean
public SqlSessionFactory sqlSessionFactory(DataSource dataSource, ApplicationContext applicationContext) throws Exception {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6a0db93af131a25a93ef25106a5f7bf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/522/">«</a>
	<span class="pagination__item pagination__item--current">523/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/524/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>