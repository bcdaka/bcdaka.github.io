<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951ca0b0e723d5a3b88ce1c12ea150d8/" rel="bookmark">
			数据挖掘可以挖掘什么类型的模式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、挖掘频繁模式、关联和相关性 频繁模式（frequent pettern）是在数据中频繁出现的模式。
频繁项集一般是指频繁的在事务数据集中一起出现的商品的集合。
频繁出现的子序列，如顾客倾向于先买相机，再买内存卡这样的模式就是一个（频繁）序列模式。
子结构可能涉及不同的机构模式，如图、数或格。如果一个子结构频繁出现，则可称为（频繁）结构模式。
挖掘频繁模式可以发现数据中有趣的关联和相关性。
关联规则可分为单维关联规则和多维关联规则。
二、用于预测分析的分类与回归 分类是找出描述和区分数据类或概念的模型，以便能够使用模型预测类标号未知的对象的类标号。
分类和回归是有监督的学习方法。数据集分为训练集和测试集。
分类是预测类别的标号。
回归是建立连续值函数模型，即用来预测难以获得的数据值或缺失的数据。
两种方法可以成为数值预测和类标号预测。
三、聚类分析 聚类分析是一种无监督的学习方法。
聚类的特点是最大化类簇间的距离、最小化类簇内样本的距离。
四、离群点分析 大部分数据挖掘方法都将离群点视为噪声或异常而丢弃。
但在欺诈检测等应用中，离群点的出现则很重要。
参考文献：数据挖掘：概念与技术（原书第三版）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075cd5c5bde8c36633edd5b4bad51bc2/" rel="bookmark">
			深度学习中卷积算子和dropout算子的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者在调网络的时候，有时调细一些在想不同卷积核尺寸的卷积操作有啥区别，在哪些算子后用dropout会比较好呢？于是有了下面一段总结。
文章目录 一、卷积核尺寸1X1和3X3的区别1x1卷积核3x3卷积核 二、dropout的作用使用情况算子组合注意事项 一、卷积核尺寸1X1和3X3的区别 在卷积神经网络中，1x1和3x3卷积核有着不同的用途和特点，各自适用于不同的情况和目标。以下是它们的主要区别：
1x1卷积核 功能： 通道间信息整合：1x1卷积主要用于改变通道数，通过线性组合不同通道的信息，可以实现跨通道的信息融合。降维和升维：1x1卷积可以用来减少特征图的通道数，从而降低计算成本；也可以用来增加通道数，提升特征表达能力。非线性映射：虽然1x1卷积没有空间上的感受野，但它可以引入非线性激活函数，使得模型具备更强的表达能力。 优点： 计算效率高：1x1卷积的计算量很小，非常高效。参数少：参数量小，有助于减小模型的复杂度。 应用场景： 瓶颈层（Bottleneck）：在ResNet等网络中，通过1x1卷积先降维再升维，减少计算量。特征融合：在Inception网络中，用于融合不同尺度的特征。 3x3卷积核 功能： 局部特征提取：3x3卷积核有一个较小的感受野，但比1x1卷积能捕捉更多的空间信息，是最常用的卷积核尺寸。平滑和细化：通过3x3卷积，可以实现对图像局部区域的平滑和细化，提取更细致的特征。 优点： 较好的感受野：相比1x1卷积，3x3卷积有更大的感受野，可以捕捉更广泛的局部信息。计算复杂度适中：3x3卷积在计算效率和感受野之间取得了较好的平衡，是一种常见且有效的选择。 应用场景： 特征提取：广泛应用于各种卷积层，用于提取图像的局部特征。深度网络：在VGG、ResNet等深度网络中，大量使用3x3卷积层，形成深层次的特征表示。
总结 1x1卷积：主要用于通道间的信息整合和调整通道数，计算效率高，参数少。3x3卷积：用于提取局部空间特征，具有较好的感受野和适中的计算复杂度。 总结一下：增加通道的时候一般用大尺寸的卷积核，因为打的卷积核有更大的感受野，更能捕捉到更多的局部特征，增加通道正合适。反之就用1X1的卷积核。
二、dropout的作用 Dropout是一种常见的正则化技术，用于防止神经网络的过拟合问题。它通过在训练过程中随机地将一部分神经元的输出设置为零，从而减少模型对特定神经元的依赖，提高模型的泛化能力。Dropout在以下情况下和算子组合中使用较为常见：
使用情况 防止过拟合： 当训练数据较少或模型过于复杂时，容易发生过拟合现象。Dropout可以有效地防止过拟合，提升模型在测试数据上的表现。 大型神经网络： 在深层神经网络（如全连接层、卷积神经网络等）中，特别是当网络层数较多时，使用Dropout可以防止网络过度拟合训练数据。 训练阶段： Dropout通常只在训练阶段使用。在测试阶段，神经元的所有输出都会保留，并且会将训练时的Dropout概率考虑进去，以便于保持输出的一致性。 算子组合 全连接层（Fully Connected Layer）： Dropout在全连接层中使用非常普遍。在每个训练步骤中，随机将部分神经元的输出设置为零。例如：model.add(Dense(128, activation='relu')) model.add(Dropout(0.5)) # 50%的神经元输出被随机丢弃 卷积层（Convolutional Layer）： 在卷积层后也可以使用Dropout，虽然较少见，但在一些较复杂的网络结构中会使用。例如：model.add(Conv2D(64, (3, 3), activation='relu')) model.add(Dropout(0.25)) # 25%的神经元输出被随机丢弃 循环神经网络（RNN/LSTM/GRU）： 在循环神经网络中，Dropout也被广泛使用，通常称为“时间Dropout”或“变换Dropout”。例如：model.add(LSTM(128, dropout=0.2, recurrent_dropout=0.2)) 正则化组合： Dropout可以与其他正则化方法组合使用，如L2正则化、Batch Normalization等。例如：model.add(Dense(128, activation='relu', kernel_regularizer=l2(0.01))) model.add(Dropout(0.5)) model.add(BatchNormalization()) 在分类任务的最后一层之前： Dropout通常在输出层之前使用，确保最后一层的神经元不会被丢弃。例如：model.add(Dense(128, activation='relu')) model.add(Dropout(0.5)) model.add(Dense(num_classes, activation='softmax')) 注意事项 Dropout率选择：通常的Dropout率为0.2到0.5，具体取决于任务和模型复杂度。测试阶段：在测试阶段应关闭Dropout，通过使用训练时的Dropout率缩放神经元的输出。计算开销：Dropout增加了一些计算开销，尤其是在大型网络中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/075cd5c5bde8c36633edd5b4bad51bc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256e56c18ff494a7624145c4946d2239/" rel="bookmark">
			Leetcode每日一题 20240802 3128.直角三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给你一个二维 boolean 矩阵 grid 。
请你返回使用 grid 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。
注意：
如果 grid 中 3 个元素满足：一个元素与另一个元素在 同一行，同时与第三个元素在 同一列 ，那么这 3 个元素称为一个 直角三角形 。这 3 个元素互相之间不需要相邻。 3128.直角三角形
测试案例及提示 示例1：
输入：grid = [[0,1,0],[0,1,1],[0,1,0]]
输出：2
解释：
有 2 个直角三角形。
示例 2：
输入：grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]
输出：0
解释：
没有直角三角形。
示例 3：
输入：grid = [[1,0,1],[1,0,0],[1,0,0]]
输出：2
解释：
有两个直角三角形。
解题思路 看题目理解题意
题目需要我们统计一个二维数组中的直角三角形数量，三角形的三点元素都为一。我们需要找到三个值为1的点，同时这三个点中需要满足一个元素与另一个元素在 同一行，同时与第三个元素在 同一列。
进一步分解问题
对于一个直角三角形，直角节点是唯一的，因此在寻找直角三角形的时候可以通过遍历直角节点，做到不重不漏。
对于一个直角节点来说，因为三角形的三个节点不需要相邻，因此在行中选取一个1，在列中再选取一个1，就可以组成直角三角形。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/256e56c18ff494a7624145c4946d2239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c38bd73f5fb65ca9f6f7497b8f27509/" rel="bookmark">
			用Python打造精彩动画与视频，4.3 创建动态文本和字幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章：深入MoviePy
4.3 创建动态文本和字幕
在视频编辑中，动态文本和字幕是传达信息、增强观众体验的重要元素。MoviePy 提供了丰富的工具来添加和自定义文本和字幕，包括字体、颜色、动画效果等。本节将介绍如何在视频中添加动态文本和字幕，并提供具体的代码示例。
4.3.1添加静态文本
from moviepy.editor import VideoFileClip, TextClip, CompositeVideoClip
# 加载原始视频
clip = VideoFileClip("I:\\《从基础到精通：用Python打造精彩动画与视频》\\python动画视频项目目录\\MyNewProject\\example.mp4")
# 创建文本剪辑
text = TextClip("Hello, MoviePy!", fontsize=70, color='white', font="Arial-Bold", stroke_color='black', stroke_width=2)
# 设置文本出现的位置和持续时间
text = text.set_position(('center', 'bottom')).set_duration(clip.duration)
# 合成视频和文本剪辑
final_clip = CompositeVideoClip([clip, text])
final_clip.write_videofile("I:\\《从基础到精通：用Python打造精彩动画与视频》\\python动画视频项目目录\\MyNewProject\\text_output.mp4")
静态文本是指位置和内容固定不变的文本，适用于标题、标签或其他固定信息。
4.3.2添加动态文本
动态文本可以通过淡入淡出、移动等效果来吸引观众注意力。以下示例展示了如何让文本在视频中淡入淡出：
from moviepy.editor import VideoFileClip, TextClip, CompositeVideoClip
# 加载原始视频
clip = VideoFileClip("I:\\《从基础到精通：用Python打造精彩动画与视频》\\python动画视频项目目录\\MyNewProject\\example.mp4")
# 创建文本剪辑
text = TextClip("Dynamic Text", fontsize=70, color='white', font="Arial-Bold", stroke_color='black', stroke_width=2)
# 设置文本位置和出现时间
text = text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c38bd73f5fb65ca9f6f7497b8f27509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/993a62f91b2e2e3d0e5b1b96dbd1e5ca/" rel="bookmark">
			Datawhale AI 夏令营 市场博弈和价格预测 EDA 探索性数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 基于挑战赛“市场博弈和价格预测”
使用探索性数据分析（EDA）深入理解赛题。
对数据做尽可能多的探索，
了解数据所在的领域先验知识，数据本身的特性等，
（发现数据的结构、异常值、模式、趋势、关系以及变量之间的相互作用）
并总结为一系列有用的信息
0 编程准备 !pip install numpy pandas seaborn matplotlib statsmodels import pandas as pd import seaborn as sns import matplotlib.pylab as plt from pathlib import Path import warnings warnings.filterwarnings('ignore') plt.style.use('ggplot') plt.rcParams['font.sans-serif'] = ['WenQuanYi Micro Hei',"SimHei"] plt.rcParams['axes.unicode_minus'] = False base_path=Path("data") 请将数据文件electricity_price_parsed放在代码文件同级的data文件夹路径
下载链接：https://linklearner.com/activity/12/2/2 =&gt; 左上角打开面板 =&gt; 选择“Tsak 2”
1 数据基本信息 读取数据，并按照 NAN 划分训练集&amp;测试集 代码
electricity_price = pd.read_csv(base_path/"electricity_price_parsed.csv", parse_dates=["timestamp"], index_col=0) electricity_price.columns = ["demand", "price"] electricity_price.head() # 创建测试集掩码，标记出所有价格为 NaN 的数据行 test_mask = electricity_price["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/993a62f91b2e2e3d0e5b1b96dbd1e5ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837938daa1350507b00302d37f525028/" rel="bookmark">
			2024下半年，前端的技术风口来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“
你近期有体验过哪些大模型产品呢？
你有使用大模型API做过一些实际开发吗？
在你日常开发中，可以与大模型相关应用结合来完成工作吗？
”
**最近，一直在和同事聊，关于前端可以用大模型干点啥！**从去年底开始，大模型的发展趋势就非常迅猛，这也代表着人工智能进入了一个新的时代。
以上几个话题，在程序员话题圈中长期位列榜首，大家都跃跃欲试，期望在这次AI风口上抢占先机。那作为程序员的我们，该如何赶上这趟“列车”？ 认知和规划是重中之重。
近期，国内AI大模型不仅在技术上有所突破，而且在实际应用中，也展现出了巨大的潜力。除国家在此方向大力投入之外，各大科技公司更是纷纷推出自己的大模型产品，如文心一言、通义千问、天工baichuan等等，可谓层出不穷。
越来越多的企业寻求更加强大的大模型技术和应用产品，AI大模型技术正在受到高度关注，各大科技公司更是开出高价聘请相关人才，最高竟开出100-130k·24薪！
据猎聘大数据研究院发布的《AIGC就业趋势大数据报告2023》报告显示，2023一季度AIGC人才需求是三年前同期的5.6倍，近一年AIGC新发职位同比增长超**43%。**近5成AIGC职位分布在互联网行业，招聘平均年薪为43万。
作为一个普通的程序员还有机会吗？尤其是从我们个人能力提升上看，如何全面吃透大模型相关应用？如何才能赚到技术红利？
作者我是耗费了几天的时间在各个平台上寻找了许多相关的资料和视频，从初学者到高阶晋级者都很有帮助的，都整理好了分享在下图，至于学到多少就看个人能力了！
😝有需要的小伙伴，可以V扫描下方二维码免费领取🆓
一、全套AGI大模型学习路线 AI大模型时代的学习之旅：从基础到前沿，掌握人工智能的核心技能！
二、640套AI大模型报告合集 这套包含640份报告的合集，涵盖了AI大模型的理论研究、技术实现、行业应用等多个方面。无论您是科研人员、工程师，还是对AI大模型感兴趣的爱好者，这套报告合集都将为您提供宝贵的信息和启示。
三、AI大模型经典PDF籍 随着人工智能技术的飞速发展，AI大模型已经成为了当今科技领域的一大热点。这些大型预训练模型，如GPT-3、BERT、XLNet等，以其强大的语言理解和生成能力，正在改变我们对人工智能的认识。 那以下这些PDF籍就是非常不错的学习资源。
四、AI大模型商业化落地方案 阶段1：AI大模型时代的基础理解 目标：了解AI大模型的基本概念、发展历程和核心原理。内容： L1.1 人工智能简述与大模型起源L1.2 大模型与通用人工智能L1.3 GPT模型的发展历程L1.4 模型工程L1.4.1 知识大模型L1.4.2 生产大模型L1.4.3 模型工程方法论L1.4.4 模型工程实践L1.5 GPT应用案例 阶段2：AI大模型API应用开发工程 目标：掌握AI大模型API的使用和开发，以及相关的编程技能。内容： L2.1 API接口L2.1.1 OpenAI API接口L2.1.2 Python接口接入L2.1.3 BOT工具类框架L2.1.4 代码示例L2.2 Prompt框架L2.2.1 什么是PromptL2.2.2 Prompt框架应用现状L2.2.3 基于GPTAS的Prompt框架L2.2.4 Prompt框架与ThoughtL2.2.5 Prompt框架与提示词L2.3 流水线工程L2.3.1 流水线工程的概念L2.3.2 流水线工程的优点L2.3.3 流水线工程的应用L2.4 总结与展望 阶段3：AI大模型应用架构实践 目标：深入理解AI大模型的应用架构，并能够进行私有化部署。内容： L3.1 Agent模型框架L3.1.1 Agent模型框架的设计理念L3.1.2 Agent模型框架的核心组件L3.1.3 Agent模型框架的实现细节L3.2 MetaGPTL3.2.1 MetaGPT的基本概念L3.2.2 MetaGPT的工作原理L3.2.3 MetaGPT的应用场景L3.3 ChatGLML3.3.1 ChatGLM的特点L3.3.2 ChatGLM的开发环境L3.3.3 ChatGLM的使用示例L3.4 LLAMAL3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/837938daa1350507b00302d37f525028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7420e86121a4450442703e2e483593a/" rel="bookmark">
			JVM—对象已死？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料：深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）周志明
在堆里面存放着 Java 世界中几乎所有的对象实例,垃圾收集器在对堆进行回收前,第一件事情就是要确定这些对象之中哪些还“存活”着,哪些已经“死去”。
1、如何判断对象存活 1.1 引用计数法 给对象增加一个引用计数器，当对象被引用一次计数器加一、当引用失效时计数器减一
任何时候计数器为0的对象就不可能再被使用
这个方法虽然占用一定内存但是原理简单、效率也很高，大多情况都是不错的算法。但Java虚拟机并没有使用这个方法因为这个方法还要考虑很多额外的情况，配合大量处理逻辑才能解决问题。
引用计数法的缺点：
public class ReferenceCountingtGC { public Object instance = null; public static final int _1MB = 1024 * 1024; //这个成员属性的唯一意义就是占点内存，以便在GC日志中看清楚是否回收过 private byte[] bigSize = new byte[2 * _1MB]; public static void testGC(){ ReferenceCountingtGC objA = new ReferenceCountingtGC(); ReferenceCountingtGC objB = new ReferenceCountingtGC(); objA.instance = objB; objB.instance = objA; //假设在这发生GC，objA和objB能否被回收？ System.gc(); } } 这两个对象objA和objB已经不可能再被访问了，但是它们因为互相引用对方，导致它们的引用计数都不为零。 所以引用计数算法就无法回收他们
1.2 可达性分析算法 这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集。
从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7420e86121a4450442703e2e483593a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35155338d289fdf78b9cc79aa2e72a15/" rel="bookmark">
			MySQL案例：MHA实现主备切换（主从架构）万字详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MHA
概念
MHA的组成
特点
案例介绍
（1）案例需求
（2）案例实现思路
（3）案例拓扑图
（4）案例环境
案例步骤
基本环境配置
关闭防火墙和内核安全机制
安装数据库
授权
主从复制的授权
高可用MHA的授权
部署主从架构
部署MHA
安装MHA
在所有节点安装node组件
换仓库源
免密连接
测试
安装manager组件
修改脚本和配置文件
测试免密登录
测试主从连接
配置IP
启动MHA
查看日志
测试
模拟故障
子接口vip的变化
修复
MHA MHA全称是MySQL Master High Availability，它是一款开源的高可用程序，‌专门为MySQL的主从复制架构设计，‌提供了自动化的主节点故障转移功能。‌
概念 是一套优秀的MySQL高可用环境下故障切换和主从复制的软件MySQL故障过程中，MHA能做到0-30秒内自动完成故障切换 MHA的组成 MHA Manager（管理节点）MHA Node（数据节点） 特点 在发生故障自动切换的过程中，MHA会尝试从故障的主服务器上保存二进制日志，最大程度保证数据不丢失使用半同步复制，可以大大降低数据丢失的风险目前MHA支持一主多从架构，最少3台服务器，也就是一主两从 案例介绍 （1）案例需求 本案例要求通过 MHA 监控 MySQL 数据库在故障时进行自动切换，不影响业务。
（2）案例实现思路 安装MySQL 数据库配置MySQL一主两从安装MHA软件配置无密码认证配置MySQL MHA 高可用模拟master故障切换 （3）案例拓扑图 （4）案例环境 主机
操作系统
IP 地址
角色
服务器
CentOS7.9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35155338d289fdf78b9cc79aa2e72a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241b4df9c9841905b9f0eda81f3cef67/" rel="bookmark">
			电脑自动重启是什么原因？重启原因排查和解决办法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你的电脑突然毫无预警地自动重启，不仅打断了工作流程，还可能导致未保存的数据丢失，这无疑令人很懊恼，那么，电脑自动重启是什么原因呢？有什么方法可以解决呢？别担心，在大多数情况下，通过一些基本故障排除步骤，我们可以找到问题所在并加以修复。下面小编就来给大家讲解讲解！
电脑自动重启不仅打断了我们的工作节奏，还可能导致数据丢失和软件错误。电脑自动重启是什么原因呢？以下是一些可能的因素：
系统更新：电脑可能会自动重启电脑进行更新系统导致，这是一个正常的过程。病毒或恶意软件：感染病毒，或恶意的程序都可能导致系统文件被损坏，从而触发重启。硬件故障：内存条、硬盘或电源等硬件组件出现问题时，可能会导致电脑无法正常运行并自动重启。驱动程序冲突：当驱动程序与操作系统或其他硬件组件不兼容时，可能会引发冲突并触发自动重启。 排查出电脑自动重启的原因，我们可以尝试使用以下方法解决：
解决方法一：关闭自动更新 首先，我们可以尝试关闭自动更新功能。通过进入系统设置，找到更新和安全选项，然后关闭自动更新功能，可以避免因系统自动更新而导致的电脑重启问题。当然，关闭自动更新后，你需要手动检查并安装系统更新，以确保系统的安全性和稳定性。
解决方法二：电脑病毒查杀 检查电脑是否感染了病毒。电脑频繁重启很有可能是因为安装了恶意软件或感染病毒。我们可以使用杀毒软件对电脑进行全面扫描，清除潜在的病毒威胁。同时，定期更新杀毒软件并保持其运行状态，可以有效预防病毒攻击。
解决方法三：重置电脑 如果以上方法都无法解决问题，我们可以考虑重置电脑，通过重置可以将电脑恢复到初始状态，解决因系统文件损坏或软件冲突导致的自动重启问题。
解决方法四：检查硬件 最后，如果问题依然存在，那么可能是硬件故障导致的。我们可以尝试更换电源供应器，确保电源稳定；清理电脑内部灰尘，保证散热良好；检查内存条是否插好，或更换新的内存条。如果自己不会弄建议到维修店让专业人员来检查解决。
无论是硬件问题还是软件冲突，只要按照上述步骤进行排查和修复，大部分的自动重启问题都能够得到有效的解决。
如果因为电脑突然自动重启导致电脑数据丢失的话，我们可以使用牛学长数据恢复工具恢复数据，牛学长可以从PC中恢复已删除、格式化、分区丢失、重装系统等多种场景丢失的数据，支持恢复照片、视频、音乐/音频、RAR / ZIP、Office文件多种电脑文件，是电脑丢失数据恢复首选！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1bf3a4c0b8259b64fc92e5c9045428/" rel="bookmark">
			Java语言程序设计——篇十一（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌿🌿🌿跟随博主脚步，从这里开始→博主主页🌿🌿🌿
欢迎大家：这里是我的学习笔记、总结知识的地方，喜欢的话请三连，有问题可以私信🌳🌳🌳
您的点赞👍、关注➕、收藏⭐️、评论📝、私信📧是我最大的支持与鼓舞！！！🌻🌻🌻 🚩集合——List 集合框架List接口及实现类List的操作ArrayList类实战演练 遍历集合元素实战演练 数组转换为List对象综合实例 集合框架 集合框架是Java以类库的形式提供了用户开发程序时可直接使用的各种数据结构。数据结构：以某种形式将数据组织在一起，不仅支持存储数据，还支持访问和处理数据。在面向对象思想里，一种数据结构被认为是一个容器（集合）。Java集合框架提供了一些现成的数据结构可供使用，这些数据结构是可以存储对象的集合，在这里对象也称为元素。Java集合框架由两种类型构成：
1️⃣Collection，用于存放一组对象。
2️⃣Map ，用于存放一组“关键字/值”的对象。
基本操作
boolean add(E e)：向集合中添加元素e
boolean remove(Object o)：从集合中删除指定的元素o
boolean contains(Object o)：返回集合中是否包含指定元素
boolean isEmpty()：判空
int size()：返回集合中所包含元素的个数
Iterator iterator()：返回包含所有元素的迭代器对象批量操作
boolean addAll(Collection&lt;? extends E&gt; c) 功能：将集合c中的所有元素添加到当前集合中 boolean removeAll(Collection&lt;?&gt; c)
功能：从当前集合中删除集合c中的所有元素
default boolean removeIf(Predicate&lt;? super E&gt; filter)
功能：从当前集合中删除满足谓词的所有元素数组操作
Object[] toArray() ：用来返回包含集合中所有元素的Object型数组
eg: Object[] a = c.toArray();
T[] toArray(T[] a)：用来返回包含集合中所有元素的指定类型的数组
eg: String[] a = c.toArray(new String[0]);流（Stream）操作
default Stream stream()
功能：以当前集合作为源返回一个顺序Stream对象
default Stream parallelStream()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c1bf3a4c0b8259b64fc92e5c9045428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933dedec218ede2ee5da2ae4cb6143fa/" rel="bookmark">
			认真学习JVM中类加载过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文我们总结JVM中类加载器子系统关于类加载过程，这里默认是Oracle的Hotspot。
【1】类加载器子系统作用 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。
ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。
加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）
如下图所示类编译后class文件我们使用javap -v StackStruTest 查看字节码，其中Constant pool部分就会存储在方法区运行时常量池。
javap 是 Java Platform 的一个命令行工具，用于查看 Java 类文件的内容。它通常用来反汇编字节码并展示类文件的结构信息，包括类名、字段、方法和属性等。javap 是 Java 开发工具包 (JDK) 的一部分，因此如果你安装了 JDK，那么你就可以使用 javap。
【2】类加载器ClassLoader角色 如下图所示装载Car.class文件。
class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。class file加载到JVM中，被称为DNA元数据模板，放在方法区。在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。
【3】类的加载过程 例如下面的一段简单的代码
public class HelloLoader { public static void main(String[] args) { System.out.println("我已经被加载啦"); } } 它的加载过程是怎么样的呢?
完整的流程图如下所示：
【4】类加载过程-加载 通过一个类的全限定名获取定义此类的二进制字节流
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
加载class文件的方式
从本地系统中直接加载通过网络获取，典型场景：Web Applet从zip压缩包中读取，成为日后jar、war格式的基础运行时计算生成，使用最多的是：动态代理技术由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见从加密文件中获取，典型的防Class文件被反编译的保护措施 【5】类加载过程-链接 链接阶段包括验证、准备和解析。
① 验证 Verify 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
如下图所示，我们查看16进制的class文件时（可以使用PXBinaryViewer查看），开头几个字符是CA FE BA BE 来表明其是可以运行在JVM上的。
如果出现不合法的字节码文件，那么将会验证不通过。
② 准备 Prepare 为类变量分配内存并且设置该类变量的默认初始值，即零值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/933dedec218ede2ee5da2ae4cb6143fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642582f67b7b9b7568640ac313205ee0/" rel="bookmark">
			【C语言】程序环境，预处理，编译，汇编，链接详细介绍，其中预处理阶段重点讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
程序环境
翻译环境
1. 翻译环境的两个过程
2. 编译过程的三个阶段 执行环境 预处理(预编译) 1. 预定义符号
2. #define 2.1 用 #define 定义标识符(符号)
2.2 用 #define 定义宏 2.3 #define 的替换规则 2.4 # 和 ## 的用法
2.5 宏和函数
2.6 #undef
3. 命令行定义
4. 条件编译
5. 文件包含
5.1 两种头文件的包含
5.2 嵌套文件包含
程序环境 在ANSI C(标准C)的任何一种实现中，存在两个不同的环境。
1. 翻译环境，在这个环境中源代码被转换为可执行的机器指令。
2. 执行环境，它用于实际执行代码。
.
我们写出的C语言代码是文本信息，计算机不能直接理解，计算机是执行二进制指令的，翻译环境负责将C语言代码转成二进制指令，执行环境负责执行二进制代码。
翻译环境 1. 翻译环境的两个过程 1. 一个工程可以有多个.c(源文件)文件，每个源文件都会单独经过编译器处理生成自己对应的目标文件(.obj)，这个过程叫做编译。
2. 多个目标文件和链接库经过链接器的处理，最后生成可执行程序，这个过程叫做链接。
链接库的意思是链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。
2. 编译过程的三个阶段 翻译环境分为编译和链接两部分，编译又有预处理，编译，汇编三个阶段。
1. 预处理：gcc -E test.c -o test.i
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/642582f67b7b9b7568640ac313205ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7de7f48d33f974982ab775f5db7bf05/" rel="bookmark">
			【CSDN平台BUG】markdown图片链接格式被手机端编辑器自动破坏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bug以及解决方法 现在是2024年8月，我打开csdn手机编辑器打算修改一下2023年12月的一篇文章，结果一进入编辑器，源码就变成了下面这个样子，我起初不以为意，就点击了发布，结果图片全部显示不出来了。
而当我修改了一下链接格式后，图片又能正常显示了
如果文章坏了，可以把md源码存成文本，用npp之类的文本编辑器写一个正则式进行字符串替换
正则式写法：\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\([A-Za-z0-9\-]*\)
替换为：![图片标题]
实际效果如下：
错误式子： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oL9nPdT2-1722564488609)(https://i-blog.csdnimg.cn/blog_migrate/f8cf5ba6d4b75d418112c55641f4043e.png)]
修正后： ![图片标题](https://i-blog.csdnimg.cn/blog_migrate/f8cf5ba6d4b75d418112c55641f4043e.png)]
还有个小尾巴，所以还要把)]替换为)
现在文章就彻底恢复正常了！
bug原理 上述过程说来简单，其实经过了一个小时的排查和客服咨询，客服没起到什么作用，纯粹是我自己排查出来的。这个问题有两大原因：
2024年csdn自家markdown编辑器里上传的图片，自动生成的链接格式中间有一级目录是"/direct"，而23年同样操作生成的链接，中间那一级目录是“/blog_migrate”手机端编辑器无法识别23年的链接，一旦遇到就会直接转化为“[外链图片转存失败
···”这样的格式，破坏掉markdown源码里的所有图片的格式，如果此时你把这个错误的源码发布出去，整片文章就被破坏了 锐评 和客服掰扯了一个小时，我严肃地和他们说了这个问题，可笑的是客服竟然听不懂我这样的表述，最后还是我自己排查出来的问题，而且我让他们帮我恢复一下历史版本，他们还做不到，我真服了，客服从头到尾毫无作用。
此外还要吐槽的就是那个客服界面做的也实在是令人蛋疼，这个算个小瑕疵吧，真正大的问题还是客服的专业素质不够强，有踢皮球的感觉。
如果这个平台的反馈机制以后还这么差，无法保证图文平台最基本的数据安全的话，以后谁还敢在这个平台上发文章呢？没人会不担心自己发出去的文章莫名其妙的没了或者是图片莫名其妙的丢了，我就直接在CSDN平台上攻击CSDN平台了，爱审不审，反正我也不指望这个平台赚钱啥的，话就撂这了，不改进的结果就是灭亡，如果以后CSDN倒了，我正好可以拿出这篇文章品味品味。
最终依我之见，文章还是要掌控在自己手中，md源码和文章的pdf都要备一份（保存图片和其位置）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82aae162e357a643c0af183b01da3fc7/" rel="bookmark">
			力扣-200.岛屿数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷力扣热题–第二十四天:200.岛屿数量
新手第二十四天 奋战敲代码，持之以恒，见证成长
1.题目描述 2.题目解答 这道题刚开始想的确实想的绞尽脑汁的，看了相关解答才明白的，三种方法，这里想先用两种方法进行实现，一个深度优先，一个广度优先。深度优先就是从一个点遍历直至到底，再向上一层，一个一个遍历，广度优先就更类似于树的层序遍历，最后岛屿的个数就是搜索的次数。
（1）广度优先搜索
使用双端队列的方式第一次见，所以这里参考的是力扣官网的写法，自己还得再理解消化一下～
（2）深度优先搜索
深度优先目前位置还是不太会实现，等在理解理解，扎实一下算法～
3.心得体会 （1）广度优先搜索
class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 nums = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == "1": nums += 1 grid[i][j] = "0" neighbors = collections.deque([(i, j)]) while neighbors: row, col = neighbors.popleft() for x, y in [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]: if 0 &lt;= x &lt; len(grid) and 0 &lt;= y &lt; len(grid[0]) and grid[x][y] == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82aae162e357a643c0af183b01da3fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b60a49139cc527dd8de9553623fba2e/" rel="bookmark">
			超全总结！大模型算法面试指南（含答案）_大模型面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，从 2019 年的谷歌 T5 到 OpenAI GPT 系列，参数量爆炸的大模型不断涌现。可以说，LLMs 的研究在学界和业界都得到了很大的推进，尤其去年 11 月底对话大模型 ChatGPT 的出现更是引起了社会各界的广泛关注。
近些年，在大规模语料库上预训练 Transformer 模型产生了预训练语言模型（PLMs），并在解决各类 NLP 任务上展现出了强大的能力。
有趣的是，当参数规模超过一定水平时，这个更大的语言模型实现了显著的性能提升，并展现出小模型中不存在的能力，比如上下文学习。为了区别于 PLM，这类模型被称为大型语言模型（LLMs）。
为了让大家更容易上车大模型算法赛道，我总结了大模型常考的面试题，喜欢记得收藏、关注。
目录 [x] 大模型（LLMs）基础面
[x] 1. 目前 主流的开源模型体系 有哪些？
[x] 2. prefix LM 和 causal LM 区别是什么？
[x] 3. 涌现能力是啥原因？
[x] 4. 大模型LLM的架构介绍？
[x] 大模型（LLMs）进阶面
[x] 1. llama 输入句子长度理论上可以无限长吗？
[x] 1. 什么是 LLMs 复读机问题？
[x] 2. 为什么会出现 LLMs 复读机问题？
[x] 3. 如何缓解 LLMs 复读机问题？
[x] 1. LLMs 复读机问题
[x] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b60a49139cc527dd8de9553623fba2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278685823fe9bc63251634f87eb3867d/" rel="bookmark">
			Java与Python谁更适合后端开发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件开发的世界里，选择合适的编程语言就像为建筑选择合适的材料一样重要。
对于后端开发而言，Java和Python都是流行的选择，但它们各自拥有独特的优势和劣势，“谁更适合”就成为一个被议论的话题。
事实上，并不存在绝对的“更适合”。
Java和Python就像两把不同的利刃，分别适用于不同的场景。选择哪种语言，更像是一个根据项目需求和团队情况进行的取舍问题。
『Python』
灵活性与快速迭代的利器
Python以其简洁易懂的语法和丰富的第三方库而闻名，赋予开发者极高的开发效率（不是执行效率）。
因此，从开发角度来说，Python会更加灵活，对于需要快速迭代的产品原型和小型项目来说，Python也许比Java更适合。
想象一下，一个初创公司正在开发一款全新的移动应用，业务逻辑在一周内可能经历三次重大调整。在这种情况下，一个熟练的Python后端开发者能够以惊人的速度响应需求变化，快速调整代码以适应新的业务方向。
而对于大型项目来说，Python也能干，但没那么合适。随着项目规模的扩大，团队成员增加，对网站可靠性和稳定性的要求也越来越高，此时Python的一些固有特性可能会成为制约因素。
此时，Java就成为首选。
『Java』
稳定性与企业级应用的基石
Java更注重代码的健壮性和可维护性，有着更强的类型检查机制和异常处理能力，因此Java代码更加稳定，也就更适合用来构建大型项目。
此外，Java拥有庞大而成熟的生态系统，提供了丰富的框架和工具，例如 Spring、Hibernate 等，这些框架和工具可以帮助开发者更高效地构建复杂应用，同时提供诸如事务管理、安全控制等强大的企业级功能支持。
因此，对于那些注重稳定性、可靠性和可维护性的大公司和企业级项目而言，Java通常是更稳妥的选择。
『Python还是Java』
如何做出明智的选择
那么话说回来，如果是你，你会选择Java还是Python呢？
1.如果你正在进行技术选型
优先考虑团队的技术栈 如果团队成员已经熟练掌握Java或Python，那么选择熟悉的语言能够最大程度地提高开发效率。
根据项目规模和需求选择 对于小型项目和需要快速迭代的项目，Python是更灵活的选择；而对于大型项目和企业级应用，Java则更加稳定可靠。
考虑人才招聘的难易程度 如果项目需要招聘大量的后端开发者，那么选择Java会更容易招到合适的人才。
2.如果你是一名正在规划职业发展方向的开发者
Java仍然是后端开发的主流选择 如果你希望进入后端开发领域，并且希望获得更多的工作机会，那么学习 Java 是一个稳妥的选择。
总而言之，Java 和 Python 都是优秀的编程语言，它们各自拥有独特的优势和适用场景。
选择哪种语言并没有绝对的对错之分，关键在于根据实际情况进行权衡和取舍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f06d37bd1be36f8538671d5ec08099/" rel="bookmark">
			【数据结构】——链式二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、链式二叉树的定义结构
二、链式二叉树的遍历
2.1前序遍历
2.2中序遍历
2.3后序遍历
2.4层序遍历
三、链式二叉树的基本功能函数
3.1结点个数
3.2叶子结点个数
3.3二叉树第k层结点个数
3.4查找值为x的结点
3.5二叉树的销毁
四、基础OJ
4.1二叉树遍历
4.2左叶子的和
4.3翻转二叉树
一、链式二叉树的定义结构 &lt;1&gt;二叉树的结构体 包含了数据和指向左右子树的指针
typedef int BTDataType; typedef struct BinaryTreeNode { BTDataType data; struct BinaryTreeNode* left; struct BinaryTreeNode* right; }BTNode; &lt;2&gt;二叉树结点的创建
BTNode* BuyNode(BTDataType x) { BTNode* root = (BTNode*)malloc(sizeof(BTNode)); if (root == NULL) { perror("malloc fail"); return NULL; } root-&gt;data = x; root-&gt;left = NULL; root-&gt;right = NULL; return root; } &lt;3&gt;二叉树的创建
BTNode* CreatBinaryTree() { BTNode* node1 = BuyNode(1); BTNode* node2 = BuyNode(2); BTNode* node3 = BuyNode(3); BTNode* node4 = BuyNode(4); BTNode* node5 = BuyNode(5); BTNode* node6 = BuyNode(6); node1-&gt;left = node2; node1-&gt;right = node4; node2-&gt;left = node3; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } Tip：二叉树是递归定义的，都可以单独看作 根、左子树、右子树
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f06d37bd1be36f8538671d5ec08099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1641e3fb7bfa4072247b50e85ad0b130/" rel="bookmark">
			Python 爬虫项目实战（二）：爬取微博热搜榜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 网络爬虫（Web Crawler），也称为网页蜘蛛（Web Spider）或网页机器人（Web Bot），是一种按照既定规则自动浏览网络并提取信息的程序。爬虫的主要用途包括数据采集、网络索引、内容抓取等。
爬虫的基本原理
种子 URL：爬虫从一个或多个种子 URL 开始，这些 URL 是起点。发送请求：爬虫向这些种子 URL 发送 HTTP 请求，通常是 GET 请求。获取响应：服务器返回网页的 HTML 内容作为响应。解析内容：爬虫解析 HTML 内容，提取所需的数据（如文本、链接、图片等）。提取链接：从网页中提取出所有链接，并将这些链接加入待访问队列。重复过程：爬虫重复上述步骤，直到达到某个停止条件，如爬取了一定数量的页面，或所有页面都被爬取完毕。 爬虫的分类
通用爬虫
设计用于抓取整个互联网的大量网页。搜索引擎（如 Google、Bing）的爬虫就是通用爬虫。 聚焦爬虫
专注于特定主题或领域，抓取相关网页。比如，一个新闻爬虫只抓取新闻网站的内容。 增量爬虫
仅抓取自上次爬取以来发生变化或更新的网页，适用于动态内容更新频繁的网站。 爬虫的合法性和道德
在编写和运行爬虫时，必须遵循以下原则：
遵守网站的 robots.txt：
大多数网站都有一个 robots.txt 文件，规定了哪些页面允许被爬取，哪些不允许。爬虫应当尊重这些规则。
避免过度抓取：
设置适当的抓取频率，避免对服务器造成过大负担。 尊重版权和隐私：
不应抓取或使用受版权保护的内容，或涉及用户隐私的数据。 获取许可：
在某些情况下，最好获得网站管理员的许可，特别是当你打算频繁地抓取大量数据时。 通过以上方法和原则，可以编写高效、可靠且合规的网络爬虫来满足数据采集的需求。 侦察 这个比较简单，直接抓包就可以看到数据来源
保存请求网址 检查数据在页面标签中的位置
标题在 td-02 中 热度在 span 中
源代码 import parsel import csv import requests # 创建 csv 文件 # 'a' 表示以追加模式（append mode）打开文件 # newline=''的作用是确保在写入文件时，所有的换行符都使用'\n' f = open('res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1641e3fb7bfa4072247b50e85ad0b130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3170bc23d49a6b7ad84d994feaddf9ab/" rel="bookmark">
			现在有什么赛道可以干到退休？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家：点击跳转到网站 ，对人工智能感兴趣的小伙伴可以点进去看看。
最近，一则“90后无论男女都得65岁以后退休”的消息在多个网络平台流传，也不知道是真是假，好巧不巧今天刷热点的时候又看到一条这样的热点：现在有什么赛道可以干到退休？
点进去看了几条热评，第一条热评说的就是：
“除了体制内，哪里可以干到65岁退休？”
结果后面就有两个人发了两张截图截图，内容分别是“入职阿里巴巴15周年的祝福”和“入职腾讯14周年的祝福”，真的是让人羡慕嫉妒恨呐，他们稳定干到退休肯定是没问题…
那你呢？你现在的“赛道”可以干到退休吗？
想听听大家对这件事的看法，欢迎大家在评论区讨论！
当然看这些东西就图一乐哈，最重要的还是学习，下面就分享一下粉丝投稿的万兴实习面经。
万兴实习面试 一面（Hr） 自我介绍你认为你的个人优势是什么谈谈你的工作经历或实习经验说说你个人的优点你对这个行业未来的看法了解Ai吗，对ai的看法 二面（技术） go defer顺序 类似于栈，先进后出
mysql如何储存大量数据，分库存分表的建议和看法（没答出来） 在 MySQL 中处理大量数据时，分库分表是一种常见的策略：
一、分库
垂直分库 按照业务模块将不同的数据表存储在不同的数据库中。例如，将用户相关的数据表放在一个库，订单相关的数据表放在另一个库。优点：可以降低单个数据库的复杂度，提高特定业务模块的性能和可用性。缺点：跨库关联查询变得复杂，需要通过应用层来处理。 水平分库 将数据按照某种规则（如用户 ID 取模）分布到多个数据库中。优点：可以有效应对数据量的增长，实现分布式存储和负载均衡。缺点：数据的分布规则需要精心设计，数据迁移和扩容相对复杂。 二、分表
垂直分表 将一个表中不常用的字段、大字段或者长度较长的字段拆分到另一个表中。例如，将商品表中的详细描述字段拆分到单独的表中。优点：减少表的宽度，提高查询性能，便于维护。缺点：增加了表关联的操作。 水平分表 按照一定的规则（如主键值取模、按时间范围等）将一个表的数据拆分到多个表中。优点：可以解决单表数据量过大的问题，提高查询效率。缺点：同样存在数据分布规则设计和跨表查询的复杂性。 谈谈你对docker的理解（参考中阳哥docker那篇文章） Docker 是一种重要的技术，理解如下：
隔离应用 把应用和其依赖打包在独立容器中，彼此隔离不干扰。像 Web 应用和数据库应用能在同一主机上互不影响。 便于部署迁移 容器包含应用所需一切，能在不同环境快速部署，无视环境差异。 优化资源利用 能更精细分配资源，多个容器可共享主机资源。 支持版本控制与回滚 对容器镜像能版本控制，出问题可回滚。 促进开发运维协作 开发环境与生产一致，减少问题。 适合微服务架构 每个微服务可打包成容器，方便独立操作。 助力 CI/CD 与相关工具链集成，实现自动化流程。 Grpc和http的区别 性能 Grpc 通常在性能方面表现更优，因为它使用二进制协议，数据传输效率高。Http 一般使用文本格式，数据量相对较大。 连接方式 Grpc 支持长连接，能减少连接建立的开销。Http 常见的是短连接，每次请求都要重新建立连接。 数据格式 Grpc 基于 Protocol Buffers 定义数据格式，具有高效的序列化和反序列化能力。Http 可以使用多种数据格式，如 JSON、XML 等。 流处理 Grpc 对双向流和服务器流的支持较好。Http 在流处理方面相对较弱。 协作开发时，不同人员的go版本不同如何解决 统一版本 确定一个共同的 Go 版本，要求所有开发人员安装和使用该版本。可以通过项目规范和文档明确指定。 使用工具管理 利用版本管理工具，如 go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3170bc23d49a6b7ad84d994feaddf9ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46221ac9419e1b0eab3fd5bab99cb981/" rel="bookmark">
			【PyTorch】多对象分割项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【PyTorch】单对象分割项目
对象分割任务的目标是找到图像中目标对象的边界。实际应用例如自动驾驶汽车和医学成像分析。这里将使用PyTorch开发一个深度学习模型来完成多对象分割任务。多对象分割的主要目标是自动勾勒出图像中多个目标对象的边界。
对象的边界通常由与图像大小相同的分割掩码定义，在分割掩码中属于目标对象的所有像素基于预定义的标记被标记为相同。
目录
创建数据集
创建数据加载器
创建模型
部署模型
定义损失函数和优化器
训练和验证模型
创建数据集 from torchvision.datasets import VOCSegmentation from PIL import Image from torchvision.transforms.functional import to_tensor, to_pil_image class myVOCSegmentation(VOCSegmentation): def __getitem__(self, index): img = Image.open(self.images[index]).convert('RGB') target = Image.open(self.masks[index]) if self.transforms is not None: augmented= self.transforms(image=np.array(img), mask=np.array(target)) img = augmented['image'] target = augmented['mask'] target[target&gt;20]=0 img= to_tensor(img) target= torch.from_numpy(target).type(torch.long) return img, target from albumentations import ( HorizontalFlip, Compose, Resize, Normalize) mean = [0.485, 0.456, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46221ac9419e1b0eab3fd5bab99cb981/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/89/">«</a>
	<span class="pagination__item pagination__item--current">90/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/91/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>