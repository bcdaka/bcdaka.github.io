<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ff959ac9e301e529b7b3f8e0e3e324/" rel="bookmark">
			一个php快速项目搭建框架源码，带一键CURD等功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍： 框架易于功能扩展，代码维护，方便二次开发，帮助开发者简单高效降低二次开发成本，满足专注业务深度开发的需求。
百度网盘下载
图片： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421458a9d39852b3b4cdf0b9f2880f2c/" rel="bookmark">
			Node.js-身份证号实名认证-小程序实名认证接口集成方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用身份证实名认证API之前，首先要确保已有一个可运行的开发环境，例如小程序或应用程序开发环境。这将是集成和测试API的基础。在应用中设计一个用户输入界面，用于用户输入姓名和身份证号码，同时设计提交按钮以触发验证流程。
在选择合适的身份证实名认证API服务提供商时，应考虑其数据准确性、稳定性、以及服务支持等方面。选择口碑良好且服务稳定的提供商是关键。在选定服务提供商后，需要在其平台上注册账号并获得API密钥。这个密钥是后续进行API调用时的重要凭证，需妥善保管。
身份证二要素翔云实名认证接口Node.js代码示例如下：
var request = require('request'); var options = { 'method': 'POST', 'url': 'https://netocr.com/verapi/veridenNoOrd.do', 'headers': { }, formData: { 'key': 'M***********g', 'secret': '3***********6', 'typeId': '3009', 'trueName': '陈**', 'idenNo': '13***************3', 'format': 'json' } }; request(options, function (error, response) { if (error) throw new Error(error); console.log(response.body); }); 集成身份证实名认证API接口涉及到选择服务商、准备开发环境、编写API请求代码、设计前端展示和进行功能测试与部署等步骤。在此过程中，保护用户隐私、合法合规使用API并定期更新维护是关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8040da739912fbe8cf11f1f18284090/" rel="bookmark">
			React——useRef（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		useRef 是 React 的一个 Hook，用于在组件的整个生命周期内持久化保存数据。主要有以下几个用途：
存储对 DOM 节点的引用：通过给 DOM 元素添加 ref 属性来直接访问实际的 DOM 节点。这常用于需要直接操作 DOM 时，比如管理焦点、文本选择或媒体播放。
示例代码：
function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () =&gt; { // `current` 指向挂载到 `input` 元素的真实 DOM 节点 inputEl.current.focus(); }; return ( &lt;&gt; &lt;input ref={inputEl} type="text" /&gt; &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt; &lt;/&gt; ); } 保存组件状态跨渲染周期不变的数据：useRef 返回的对象在组件的整个生命周期内保持不变，可以用来保存任何可变值。与实例属性类似，当你想要保存不需触发视图重新渲染的数据时，可以使用 useRef。
示例代码：
function TimerComponent() { const intervalRef = useRef(); useEffect(() =&gt; { const id = setInterval(() =&gt; { // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8040da739912fbe8cf11f1f18284090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4584eae326bdef053d685ca14f02a775/" rel="bookmark">
			PHP基础之面向对象讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 面向对象1.1 PHP 类定义1.2 创建对象1.3 构造&amp;析构函数1.3.1 构造函数1.3.2 析构函数 1.4 继承1.4.1 方法重写1.4.2 父子类初始化顺序1.4.3 示例说明 1.5 访问控制1.5.1 属性的访问控制1.5.2 方法的访问控制 1.6 接口 &amp; 抽象1.6.1 接口1.6.2 抽象类 1.7 关键字1.7.1 parent，self，this1.7.1.1 parent1.7.1.2 self1.7.1.3 this 1.7.2 常量1.7.2.1 const1.7.2.2 const &amp; define 1.7.3 Static1.7.4 Final 1 面向对象 1.1 PHP 类定义 PHP 定义类通常语法格式如下：
&lt;?php class Site { /* 成员变量 */ var $url; var $title; /* 成员函数 */ function setUrl($par){ $this-&gt;url = $par; } function getUrl(){ echo $this-&gt;url .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4584eae326bdef053d685ca14f02a775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2574e102b50737d9686b6d7aebca28/" rel="bookmark">
			深入MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL逻辑架构
MySQL逻辑架构整体分为三层，顶层客户端并非MySQL独有，如：连接处理、授权认证、安全等功能都在客户端层。
核心服务层，MySQL大多数核心服务都在这一层，包括查询解析、分析、优化、缓存、内置函数等。所有跨存储引擎的功能也在这一层实现：如存储过程、触发器、视图。
最下层为存储引擎，负责MySQL中的数据存储和提取。类似于Linux的文件系统，每种存储引擎都有优劣。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。
MySQL查询过程
客户端/服务端通信协议
客户端/服务端通信协议是“半双工”的:在任一时刻，要么是服务器端向客户端发送数据，要么是客户端向服务器发送数据， 两个动作不能同时发生。一旦一端开始发送消息，另一端要完整接受整个消息之后才能响应，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。
客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是值得注意的是如果查询实在很大，服务端会拒绝接受更多数据并抛出异常。
相反的是，服务器发送给客户端数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个查询结果，不能简单的只接收前几条结果然后让服务器停止发送。因此在实际开发中，尽量保持查询简单且只返回必要的数据，减少通信间数据包的大小和数量是一个很好的习惯，这也是查询中尽量避免使用select*以及加上limit的原因之一。
查询缓存
在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询正好命中查询缓存，在检查一次用户权限之后直接返回缓存中的结果。这种情况下，查询不会被解析。也不会生成执行计划，更不会执行查询语句。
MySQL将缓存放在一个引用表中(不要理解成table，可以认为是类似HashMap的数据结构)，通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询的任何字符上的不同(例如:空格，注释)，都会导致缓存不会命中。
如果查询中包含任何用户自定义函数、存储函数、用户变量、临时变、mysql库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT__DATE()会因为不同的查询时间，返回不同的查询结果，再比如包含CURRENT_USER或者CONNECTION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何意义。
既然是缓存，就会失效，那查询缓存什么时候时效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表(结构或者数据)发生了变化，那么和这张表有关的所有缓存都会失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统开销，甚至导致系统卡住。而且查询缓存对系统的额外消耗也不仅仅在写操作中，读操作也不例外。
1.任何查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存 2.如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统开销。 基于此，我们知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会额外带来消耗，只有当缓存带来的资源节约大于本身的消耗时，才会给系统带来性能上的提升。但是如何评估打开缓存是否能够带来性能提升是一件不容易的事情，本文也不讨论这个棘手的问题。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库上做一些优化，比如：
用多个小表代替一个大表，注意不要过度设计批量插入代替循环单条插入合理控制缓存空间大小，一般来说大小设置为几十兆较为合适可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存。 最后忠告不要轻易打开查询缓存，特别是写密集型应用。如果实在忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询不会，这样可以自由的控制哪些查询需要被缓存。
当然查询缓存系统本身也是很复杂的，这里讨论的只是很小的一部分，其他深入的话题：缓存是怎么使用内存的？怎么控制内存的碎片化？事务对查询缓存有什么影响？读者可以自行阅读相关资料
语法解析和预处理
MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等。
查询优化
经过前面的步骤生成的语法树被认为是合法的，并且由优化器将其转化成查询计划。多数情况下一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好打的执行计划。
mysql&gt; select * from t_message limit 10; ...省略结果集 mysql&gt; show status like 'last_query_cost'; +-----------------+-------------+ | Variable_name | Value | +-----------------+-------------+ | Last_query_cost | 6391.799000 | +-----------------+-------------+ 示例中的结果表示优化器认为大概需要做6391个数据页的随机查询才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。
有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本(用户自定义函数，存储过程)、MySQL认为的最优跟我们预想的不一致等等。
MySQL的查询优化器是一个非常复杂的不见，他是用了非常多的优化策略来生成一个最优的执行计划。：
重新定义表的关联顺序(多张表关联查询时，并不一定按照SQL指定的顺序执行，但有一些技巧可以指定关联顺序)优化MIN()和MAX()函数(找某列的最小值，如果该列有索引，只需要查找B+树索引最左端，反之可以找最大值，原理见下文)提前终止查询(比如：使用limit时，查找到满足数量的结果集后会自动终止查询)优化排序(在老版MySQL中会使用两次传输排序，即先读取指针和需要排序的字段在内存中对其排序，然后根据排序结果读取数据行，而新版本采用单次传输排序，即一次读取所有数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多) 查询执行引擎
在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。查询过程中的每一个表由一个handler实例表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。
返回结果给客户端
查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL依然会返回这个查询的相关信息，比如查询影响到的行数以及执行时间等。
如果查询缓存被打开并且这个查询可以被缓存，MySQL也会将结果存在缓存中。
结果集返回给客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多的内存，也可以让客户端第一时间获得返回结果。要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。
总结一下MySQL整个查询执行过程，大体分为6个步骤：
客户端向MySQL服务区发送一条查询请求服务器首先检查查询缓存，如果命中缓存，则立即返回存储在缓存中的结果，否则下一步服务器进行SQL解析、预处理、再由优化器生成对应的执行计划MySQL根据执行计划，调用存储引擎的API来执行查询将结果返回给客户端，同时缓存查询结果 性能优化建议
看了这么多，你可能会期待给出一些优化手段，是的，下面会从3个不同方面给出一些优化建议。但是请稍等，还有一句忠告：不要听信你看到的关于优化的“绝对真理”，包括本文讨论的内容，而是应该在实际的业务场景下通过测试来验证你的关于执行计划以及响应时间的假设.
Scheme设计与数据类型优化
选择数据类型只要遵循小且简单的原则就好，越小的数据类型通常就会越快，占用更少的磁盘、内存，处理需要的CPU周期也更。越简单的数据类型在计算的时候需要的CPU周期也更少。比如：整型就比字符操作代价低，因而会适应整型来存储IP地址，使用DATETIME来存储时间而不是用字符型。
这里总结几个容易理解错误的技巧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2574e102b50737d9686b6d7aebca28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ccb399322704a6be17521af76b2bf4/" rel="bookmark">
			快速学习“堆“排序（C语言数据结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 堆的实现其实并不难，难的是要用堆实现排序，也就是堆的运用。
下面需要探究一下堆的排序是怎样的。
如何利用堆进行升序或者降序的排序。
"堆排序"： 原理： 例如：此时要将数组里的数组int arr[] = {12,20,26,8,1,2,3}进行升序或者降序排序。
第一步：把数放进堆里面，但是究竟是放在大堆还是小堆里面呢？
如果需要升序就需要放进大堆里面！
如果需要降序就需要放进小堆里面！
（原因后续画图讲解）
如何将一个数组直接放在大堆当中呢？
可以直接遍历数组，将数一个一个放入。
代码如下：
typedef int HPDataType; void AdjustUp(HPDataType* a, int child) { int parent = (child - 1) / 2; while (child &gt; 0) { if (a[child] &gt; a[parent]) { swap(&amp;a[child], &amp;a[parent]); child = parent; parent = (child - 1) / 2; } else { break; } } } void HeapPush(Heap* hp, HPDataType x) { assert(hp); if (hp-&gt;_capacity == hp-&gt;_size) { int newcapacity = hp-&gt;_capacity == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72ccb399322704a6be17521af76b2bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7f002d13bb45fec4dcfc7953463c33/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(100)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
431、pandas.DataFrame.items方法
431-1、语法
431-2、参数
431-3、功能
431-4、返回值
431-5、说明
431-6、用法
431-6-1、数据准备
431-6-2、代码示例
431-6-3、结果输出
432、pandas.DataFrame.keys方法
432-1、语法
432-2、参数
432-3、功能
432-4、返回值
432-5、说明
432-6、用法
432-6-1、数据准备
432-6-2、代码示例
432-6-3、结果输出
433、pandas.DataFrame.iterrows方法
433-1、语法
433-2、参数
433-3、功能
433-4、返回值
433-5、说明
433-6、用法
433-6-1、数据准备
433-6-2、代码示例
433-6-3、结果输出
434、pandas.DataFrame.itertuples方法
434-1、语法
434-2、参数
434-3、功能
434-4、返回值
434-5、说明
434-6、用法
434-6-1、数据准备
434-6-2、代码示例
434-6-3、结果输出
435、pandas.DataFrame.pop方法
435-1、语法
435-2、参数
435-3、功能
435-4、返回值
435-5、说明
435-6、用法
435-6-1、数据准备
435-6-2、代码示例
435-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 431、pandas.DataFrame.items方法 431-1、语法 # 431、pandas.DataFrame.items方法 pandas.DataFrame.items() Iterate over (column name, Series) pairs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a7f002d13bb45fec4dcfc7953463c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9794c9b45f88e187d31d399b3e6dffe/" rel="bookmark">
			知识付费小程序搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，我的一位教育培训机构的朋友巧妙运用了一款知识付费小程序，成功解锁了教育创新的新篇章。这个月，他的教学平台迎来了显著的增长，新增生源高达200人，这一成就令人瞩目。他巧妙地将线上教学的便捷性与线下互动的沉浸式体验相结合，不仅打破了地域限制，让知识传播无界，还通过线下活动加深了学员之间的情感联结，营造了浓厚的学习氛围。
小程序内丰富多样的课程内容，辅以个性化的学习路径设计，极大地激发了学员的学习兴趣与参与度。同时，智能化的管理工具帮助他高效运营，精准触达每位学员的需求，确保了教学质量与用户体验的双重提升。
此次成功，不仅验证了知识付费模式的强大生命力，也展示了线上线下融合教育的巨大潜力。朋友的教学事业因此迈上了新台阶，收获了学员们的一致好评与信赖。这不仅是他个人努力的成果，更是对教育创新探索的一次有力证明，激励着更多人在知识传播的道路上勇往直前。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0c4c539b66b8d5bf68a58d7cdbb86b/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(099)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
426、pandas.DataFrame.at属性
426-1、语法
426-2、参数
426-3、功能
426-4、返回值
426-5、说明
426-6、用法
426-6-1、数据准备
426-6-2、代码示例
426-6-3、结果输出
427、pandas.DataFrame.iat属性
427-1、语法
427-2、参数
427-3、功能
427-4、返回值
427-5、说明
427-6、用法
427-6-1、数据准备
427-6-2、代码示例
427-6-3、结果输出
428、pandas.DataFrame.loc属性
428-1、语法
428-2、参数
428-3、功能
428-4、返回值
428-5、说明
428-6、用法
428-6-1、数据准备
428-6-2、代码示例
428-6-3、结果输出
429、pandas.DataFrame.iloc属性
429-1、语法
429-2、参数
429-3、功能
429-4、返回值
429-5、说明
429-6、用法
429-6-1、数据准备
429-6-2、代码示例
429-6-3、结果输出
430、pandas.DataFrame.insert方法
430-1、语法
430-2、参数
430-3、功能
430-4、返回值
430-5、说明
430-6、用法
430-6-1、数据准备
430-6-2、代码示例
430-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 426、pandas.DataFrame.at属性 426-1、语法 # 426、pandas.DataFrame.at属性 pandas.DataFrame.at Access a single value for a row/column label pair.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee0c4c539b66b8d5bf68a58d7cdbb86b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d132fdc2fed7508230911efded5c5b/" rel="bookmark">
			私域流量升级下的新机遇——“开源 AI 智能名片S2B2C 商城小程序”与新兴技术的融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文深入探讨了随着私域流量应用的进一步升级，智能对话式营销持续火爆的同时，CEM（客户体验管理）、MA（营销自动化）、CDP（客户数据平台）及 DAM（数据资产管理）也因私域流量而备受关注。在此背景下，详细分析“开源 AI 智能名片、S2B2C 商城小程序”如何与这些新兴技术融合，为企业创造更大的价值，展现其在私域流量新时代的重要作用和广阔前景。
一、引言 在当今数字化高速发展的时代，私域流量已成为企业在激烈市场竞争中脱颖而出的关键法宝。随着科技的不断进步和消费者需求的日益多样化，私域流量的应用也在持续升级。其中，智能对话式营销以其高效的沟通方式和个性化的服务，迅速在市场中占据重要地位。与此同时，CEM、MA、CDP 和 DAM 等先进技术也因私域流量的蓬勃发展而备受瞩目。而“开源 AI 智能名片、S2B2C 商城小程序”作为新兴的营销工具，在这一趋势下展现出巨大的发展潜力，为企业带来全新的机遇与挑战。
二、私域流量升级的表现与影响 （一）智能对话式营销的火爆
智能对话式营销是人工智能技术在营销领域的创新应用。它通过自然语言处理和机器学习等技术，实现与客户的实时互动，为客户提供个性化的服务和解决方案。
1. 高效沟通方式
智能对话式营销打破了传统营销中时间和空间的限制，客户可以随时随地与企业进行沟通。无论是在白天还是夜晚，只要客户有需求，智能对话系统都能及时响应，为客户提供快速准确的解答。这种高效的沟通方式大大提高了客户的参与度和满意度，增强了客户与企业之间的互动性。
2. 个性化服务
智能对话系统能够根据客户的历史行为、偏好和需求，为客户提供个性化的服务和推荐。例如，当客户询问产品信息时，系统可以根据客户的购买记录和浏览历史，为客户推荐适合其需求的产品。这种个性化的服务不仅提高了客户的购买意愿，还增强了客户对企业的忠诚度。
3. 提升营销效率
智能对话式营销可以自动化地处理大量的客户咨询和问题，减少了人工客服的工作量，提高了营销效率。同时，系统还可以通过数据分析和机器学习，不断优化对话策略和推荐算法，提高营销效果。
（二）CEM、MA、CDP 及 DAM 的兴起
1. CEM（客户体验管理）
客户体验管理是一种以客户为中心的管理理念，旨在提升客户在整个购买和使用过程中的体验。在私域流量时代，CEM 变得尤为重要，因为客户的口碑和满意度直接影响着企业的品牌形象和市场竞争力。
（1）收集和分析客户反馈
CEM 通过多种渠道收集客户的反馈信息，如在线调查、社交媒体、客户服务热线等。然后，利用数据分析技术对这些反馈信息进行深入分析，了解客户的需求、痛点和期望。企业可以根据这些分析结果，及时调整产品和服务，提高客户满意度。
（2）优化客户旅程
CEM 关注客户在整个购买和使用过程中的体验，包括产品发现、购买决策、使用体验和售后服务等环节。企业可以通过优化客户旅程，提高客户的购买转化率和忠诚度。例如，企业可以通过简化购买流程、提供个性化的推荐和优质的售后服务，提升客户的购买体验。
（3）提升客户忠诚度
通过提供优质的客户体验，企业可以增强客户对品牌的认同感和忠诚度。客户忠诚度的提高不仅可以带来重复购买和口碑传播，还可以降低客户流失率，为企业带来长期的稳定收益。
2. MA（营销自动化）
营销自动化是一种利用软件和技术，自动化执行营销任务的方法。在私域流量时代，MA 可以帮助企业提高营销效率，实现个性化营销，降低营销成本。
（1）自动化执行营销任务
MA 可以自动化执行多种营销任务，如邮件营销、社交媒体推广、短信营销等。企业可以根据客户的行为和偏好，设置自动化的营销流程，实现精准营销。例如，当客户完成购买后，系统可以自动发送感谢邮件，并推荐相关的产品或服务。
（2）个性化营销
MA 可以根据客户的行为、偏好和需求，为客户提供个性化的营销内容和推荐。例如，系统可以根据客户的浏览历史和购买记录，为客户推荐适合其需求的产品或服务。这种个性化的营销方式可以提高客户的参与度和购买意愿，提高营销效果。
（3）降低营销成本
营销自动化可以减少人工干预，降低营销成本。同时，系统还可以通过数据分析和优化，提高营销效率，降低营销成本。例如，系统可以通过分析邮件营销的效果，优化邮件内容和发送时间，提高邮件的打开率和转化率，降低营销成本。
3. CDP（客户数据平台）
客户数据平台是一种整合了来自多个渠道的客户数据，为企业提供全面的客户画像的技术。在私域流量时代，CDP 可以帮助企业更好地了解客户需求，制定精准的营销策略。
（1）数据整合
CDP 可以整合来自多个渠道的客户数据，如网站、社交媒体、移动应用、线下门店等。通过数据整合，企业可以获得全面的客户画像，了解客户的行为、偏好和需求。
（2）客户画像
CDP 利用数据分析技术，对整合后的客户数据进行深入分析，为企业提供全面的客户画像。客户画像包括客户的基本信息、行为特征、偏好和需求等方面的内容。企业可以根据客户画像，制定精准的营销策略，提高营销效果。
（3）数据驱动营销
CDP 可以为企业提供实时的客户数据和分析报告，帮助企业实现数据驱动营销。企业可以根据客户数据和分析报告，及时调整营销策略，提高营销效果。例如，企业可以根据客户的购买行为和偏好，调整产品推荐和促销活动，提高客户的购买转化率。
4. DAM（数据资产管理）
数据资产管理是一种对企业数据资产进行有效管理和利用的方法。在私域流量时代，DAM 可以帮助企业提高数据的价值和安全性，为企业的决策提供支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44d132fdc2fed7508230911efded5c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90e7ac6c1ccd3ffd517258a5f823177/" rel="bookmark">
			【C&#43;&#43;离线查询】2250. 统计包含每个点的矩形数目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及的基础知识点 离线查询
LeetCode2250. 统计包含每个点的矩形数目 给你一个二维整数数组 rectangles ，其中 rectangles[i] = [li, hi] 表示第 i 个矩形长为 li 高为 hi 。给你一个二维整数数组 points ，其中 points[j] = [xj, yj] 是坐标为 (xj, yj) 的一个点。
第 i 个矩形的 左下角 在 (0, 0) 处，右上角 在 (li, hi) 。
请你返回一个整数数组 count ，长度为 points.length，其中 count[j]是 包含 第 j 个点的矩形数目。
如果 0 &lt;= xj &lt;= li 且 0 &lt;= yj &lt;= hi ，那么我们说第 i 个矩形包含第 j 个点。如果一个点刚好在矩形的 边上 ，这个点也被视为被矩形包含。
示例 1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90e7ac6c1ccd3ffd517258a5f823177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a673d5347ceb34a7c9400418b1f9ff2/" rel="bookmark">
			JVM对象创建和内存分配机制深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、对象创建方式 1、new关键字 这是最常见的创建对象的方式。通过调用类的构造方法（constructor）来创建对象。如：MyClass obj = new MyClass()。这种方式会触发类的加载、链接、初始化过程（如果类还未被加载过的话），并在堆内存中为对象分配空间，然后执行构造方法初始化对象。
2、反射机制 反射是Java提供的一种强大的机制，可以在运行时动态的创建对象。通过反射创建对象主要有两种方式：
1. 使用Class类的newInstance()方法。但在Java 9及以后版本中，Class类的newInstance()方法被标记为过时，推荐使用Class类的getDeclaredConstructor()方法配合Constructor的newInstrance()方法使用。如：MyClass obj = MyClass.class.newInstance() 在java9及之后建议使用MyClass.getDeclaredConstructor().newInstance()。
2. 使用Constructor类的newInstance()方法。首先通过反射获取类的构造器（Constructor），然后调用newInstance()方法创建对象，这种方式更加灵活可以指定构造函数的参数。如：Constructor&lt;?&gt; constructor = Class.forName("MyClass").getConstrutor(int.class, String.class);
MyClass myClass = (MyClass)constructor.newInstance(1, "小明");
3、使用clone()方法 通过实现Cloneable接口并重写Object类的clone()方法，可以创建对象的浅拷贝。如果对象中包含其他对象的引用，则这些引用指向的对象不会被克隆，而是共享。要实现深拷贝，需要在clone()方法中手动复制这些对象。
4、序列化和反序列化 序列化是将对象的状态信息转换为可以存储或传输形式的过程，反序列化则是将序列化后的对象状态信息恢复为对象的过程。通过序列化可以将对象写入到文件、数据库或通过网络传输；通过反序列化可以从文件、数据库或网络接收到的字节流中恢复对象。这种方式要求对象所属的类实现Serializable接口。
5、使用第三方库 除了上述Java标准库提供的方式外，还可以使用第三方库来创建对象，如Objenesis等。这些库通常提供了更高级或更灵活的对象创建机制，以满足特定的需求。
二、对象创建过程 1、类加载检查 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。
2、分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。
这个步骤有两个问题：
1.如何划分内存。
2.在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的 情况。
划分内存的方法：
“指针碰撞”（Bump the Pointer）(默认用指针碰撞)：如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
“空闲列表”（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
解决并发问题的方法：
CAS（compare and swap）：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。
本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过­XX:+/­-UseTLAB参数来设定虚拟机是否使用TLAB(JDK1.8 会默认开启­XX:+UseTLAB)，­XX:TLABSize 指定TLAB大小 默认eden区1%。当分配的内存放不下时 会采用CAS方式分配内存。
3、初始化 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头 跟静态变量初始化一样）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问 到这些字段的数据类型所对应的零值。
4、设置对象头 初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对 象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a673d5347ceb34a7c9400418b1f9ff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df55aeefbbf036f86cba6614383beda/" rel="bookmark">
			【网格dp】力扣1594. 矩阵的最大非负积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个大小为 m x n 的矩阵 grid 。最初，你位于左上角 (0, 0) ，每一步，你可以在矩阵中 向右 或 向下 移动。
在从左上角 (0, 0) 开始到右下角 (m - 1, n - 1) 结束的所有路径中，找出具有 最大非负积 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。
返回 最大非负积 对 109 + 7 取余 的结果。如果最大积为 负数 ，则返回 -1 。
注意，取余是在得到最大积之后执行的。
示例 1：
输入：grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]
输出：-1
解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1 。
示例 2：
输入：grid = [[1,-2,1],[1,-2,1],[3,-4,1]]
输出：8
解释：最大非负积对应的路径如图所示 (1 * 1 * -2 * -4 * 1 = 8)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df55aeefbbf036f86cba6614383beda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/272b222b8aec9b19225aa750cf8ed5a3/" rel="bookmark">
			PHP易支付系统，支付系统源码下载，已测试，带多个支付接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		易支付系统源码，已测试，功能齐全，带有多支付接口，站内有对应的视频教程，详细教程
搭建出来的网站前端和后台还是比较美观的
PHP全开源易支付系统源码，一键安装版
搭建环境：PHP 5.4 以上 推荐7.0
搭建必备：服务器/主机 域名
搭建教程：
1.源码传到空间 解压
2.解析个域名到空间的IP或CNAME
3.访问域名/install安装
4.安装完访问域名/admin 配置后台信息
后台账号密码统一：admin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ecc9ff9246416be62dc40cd278e8231/" rel="bookmark">
			算法【Java】—— 二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找算法分析 二分查找算法其实也是对撞指针的另一种用法，左右两个指针分别指向数据的左右端点，然后双指针向中间移动。
朴素二分查找 上面这道题是朴素的二分查找算法，由于数据是有序的，我们可以从中间值入手
如果中间值大于目标值说明目标值位于绿色区间则需要修改右指针，如果中间值小于目标值的那说明目标值位于蓝色区间则需要修改左指针，如果相等的话直接返回下标即可。
这里的 mid = left + (right - left) / 2 是为了防止溢出，大家应该会这样写 mid = (left + right) / 2，但是由于整型数据是有范围的，所以直接加的话可能会出现溢出现象，为了避免这一现象的出现，我们使用 left + (right - left) / 2，利用减法获取一半。
补充： mid = left + (right - left) / 2 或者 mid = left + (right - left + 1) / 2 ，在朴素的二分查找算法是一样的。
class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ecc9ff9246416be62dc40cd278e8231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1215de365e76fbd50ac4d6f8f24c33d/" rel="bookmark">
			通过小程序进度条了解Linux下的多文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：Yui_
🌈Linux专栏：Linux
🌈C语言笔记专栏：C语言笔记
🌈数据结构专栏：数据结构
🌈C++专栏：C++
文章目录 1.进度条1.1 回车概念1.2 缓冲区概念1.3 makefile准备1.4 进度条1.01.5 进度条2.0 1.进度条 在网络中进度条可以说是无处不在的，下载和上传都需要有进度条来帮助我们来判断目前的进度如何。当然今天我们写的进度条只会有其形。
再讲进度条前，先了解一下什么是回车吧
1.1 回车概念 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。
后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
回车 \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return
换行 \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed
符号ASCII码意义\n10换行NL\r13回车CR在进度条中我们就需要用到\r来吧光标回到一行的初始 1.2 缓冲区概念 缓冲区是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。
当我们使用printf函数的时候其实是要打印的内容是先进入缓冲区然后再从缓冲区打印到屏幕，因为在下面代码中存在sleep的缘故，缓冲区的内容不会马上打印到屏幕，这样会影响到进度条的运行，所以需要使用fllush把缓冲区的内容强制取出，又因为缓冲区会分为输出缓冲区和输出缓冲区，从输出缓冲区取值的流是stdout。将stdout作为fllush函数的参数就可以把内容取出了。
大家可以输入以下的代码试一试：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int main() { printf("hello makefile"); sleep(3); return 0; } 1.3 makefile准备 因为为了充分利用Linux下makefile，本次的进度条会分为以下3个文件书写
progressbar.c progressbar.h test.c 再写之前我们先来配置以下makefile的内容：
progressbar:test.o progressbar.o gcc -o progressbar test.o progressbar.o test.o:test.c gcc -c test.c progressbar.o:progressbar.c gcc -c progressbar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1215de365e76fbd50ac4d6f8f24c33d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8038a9bbcaa67f95f29addead36ab5c2/" rel="bookmark">
			Java重修笔记 第四十二天 LinkedList 类、ArrayList 和 LinkedList 比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LinkedList 类 1. LinkedList 类底层是一个双向链表
2. LinkedList 类中有两个属性 first 和 last ，他们分别指向首节点和尾节点
3. 每个结点（LinkedList 的内部类 Node 对象）中有三个属性，prev 指向前一个结点、next 指向后一个结点、item 存储元素的值，来实现双向链表
4. 双向链表只需要操作 prev 和 next 的指向就可以完成添加的删除操作，不存在数组扩容和数据前移的情况，所以 LinkedList 添加的删除的效率比较高
LinkedList 类常用方法 1. public boolean add(E e)
将指定元素插入到链表的末尾
2. public void add(int index, E element)
在指定位置插入
3. public E remove()
删除链表的第一个元素
4. public E remove(int index)
删除链表中指定位置的元素
5. public boolean remove(Object o)
删除链表中第一次出现的该元素
6. public E set(int index, E element)
替换指定位置的元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8038a9bbcaa67f95f29addead36ab5c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b48b4a7f84d013f2955af36589004b6/" rel="bookmark">
			Springboot里集成Mybatis-plus、ClickHouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌹作者主页：青花锁 🌹简介：Java领域优质创作者🏆、Java微服务架构公号作者😄
🌹简历模板、学习资料、面试题库、技术互助
🌹文末获取联系方式 📝
Springboot里集成Mybatis-plus、ClickHouse目录 前言1、构建JDK8 + Springboot 2.6.13项目1.1、修改Server URL，支持Java81.2、 选择Springboot 版本、选择加载的依赖包1.3、查看pom.xml文件1.4、检查项目结构1.4.1、检查项目设置1.4.2、检查模块 1.5、检查项目配置1.5.1、配置Maven环境1.5.2、检查Java编译配置 2、集成Mybatis-plus、ClickHouse2.1、加载Mybatis-plus、ClickHouse依赖包2.2、修改配置文件 3、在clickhouse里添加表4、在Springboot项目里创建商品表的操作类4.1、添加雪花ID实现4.2、添加Mybatis-plus写法的表操作 5、测试5.1、新增数据5.2、查询数据 结尾 【基于ClickHouse的大数据开发系列文章】
第一章 Linux部署-安装jdk以及shell脚本检查jdk
第二章 阿里云CentOs ClickHouse安装
第三章 Springboot里集成Mybatis-plus、ClickHouse
前言 上一章节讲解在阿里云ECS centos服务器上安装ClickHouse。
这一章节我们在Springboot里集成Mybatis-plus、ClickHouse。
环境：JDK8 + Springboot 2.6.13 + ClickHouse
1、构建JDK8 + Springboot 2.6.13项目 JDK8 + Springboot 2.x基本上都可以，保险起见，2.5-2.7左右最好。
1.1、修改Server URL，支持Java8 在Idea里创建一个Springboot项目，首先修改Server URL，默认的Server URL已经不支持JDK8。
1.2、 选择Springboot 版本、选择加载的依赖包 1.3、查看pom.xml文件 构建完成之后，就会生成一个Springboot项目，文件里最主要是pom.xml文件。
1.4、检查项目结构 1.4.1、检查项目设置 与我们的项目里选择的JDK8保持一致
1.4.2、检查模块 检查项目结构，语言级别、Sources、Resources、Test Resources等。
1.5、检查项目配置 检查项目的Settings。
1.5.1、配置Maven环境 （JDK8 对应的是3.3 - 3.9等，一般使用3.6、3.8最佳）
1.5.2、检查Java编译配置 检查Java编译配置，1.8、8都可以，代表使用java8编译Java文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b48b4a7f84d013f2955af36589004b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae3e4ad3a0ec167bee477371fcf659d/" rel="bookmark">
			每日一练【最大连续1的个数 III】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、题目描述 给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。
二、题目解析 本题同样是利用滑动窗口的解法。
首先进入窗口，如果是1，就直接让right++，但是如果是0，那么需要让计数器去++，当计数器大于指定的k时，就需要让left一直循环，直到计数器不大于k为止。
三、原码 class Solution { public: int longestOnes(vector&lt;int&gt;&amp; nums, int k) { int left = 0,right = 0; int len = nums.size(); int zero = 0; int max_len = 0; while(right &lt; len) { if(nums[right] == 0) { zero++; } if(zero &gt; k) { while(zero &gt; k) { if(nums[left++] == 0) { zero--; } } } max_len = max(max_len,right-left+1); right++; } return max_len; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6619258e951e622d12fbab68e1892e95/" rel="bookmark">
			【C&#43;&#43;从小白到大牛】C&#43;&#43;智能指针的使用、原理和分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、我们为什么需要智能指针？
2、内存泄露
2.1 什么是内存泄漏，内存泄漏的危害
2.2如何避免内存泄漏
总结一下:
3.智能指针的使用及原理
3.1 RAII
3.2关于深拷贝和浅拷贝更深层次的理解：
3.3 std::auto_ptr
3.4 std::unique_ptr
3.5 std::shared_ptr
引用计数的原理：
原码：
std::shared_ptr的循环引用（特定场景下的缺陷）
很坑的赋值重载函数
智能指针的缺陷：（循环引用）
解决方案：
1、我们为什么需要智能指针？ 下面我们先分析一下下面这段程序有没有什么内存方面的问题？
解析：
这里如果是p1的new抛异常了 那么首先p1是申请空间失败的 然后程序跳转到异常处理机制，如果main函数中没有对异常捕捉，那么程序就终止了。
如果是p2的new抛异常了 那么大体和p1抛异常一样。区别在于p1这个指针申请的空间就会内存泄漏，因为p1已经申请成功了但是由于抛异常下面的delete语句不再执行！
div抛异常也一样 只不过这个时候p1和p2开辟的空间都会造成内存泄漏！
2、内存泄露 2.1 什么是内存泄漏，内存泄漏的危害 什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。
void MemoryLeaks() { // 1.内存申请了忘记释放 int* p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p3 = new int[10]; Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放. delete[] p3; } 2.2如何避免内存泄漏 1. 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6619258e951e622d12fbab68e1892e95/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/22/">«</a>
	<span class="pagination__item pagination__item--current">23/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/24/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>