<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74bb8e4455e9b09999aabb42744f16d3/" rel="bookmark">
			智能电子班牌源码之终端管理-SAAS本地化及未来之窗行业应用跨平台架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一智能电子班牌 智能电子班牌为教育行业量身打造，高清显示屏体、可安装各类软件，满足门禁、考勤、信息显示等多种功能。节能防水防误触设计，更适用于校园环境。 二、设备管理 1. 提高效率：管理员无需亲临设备现场，即可对设备进行配置、监控和维护，节省了时间和人力成本。
2. 实时监控：能够实时获取设备的运行状态、性能指标和故障信息，及时发现并解决问题，减少设备停机时间。
3. 快速响应故障：当设备出现故障时，可以迅速远程诊断和修复，缩短故障解决时间，提高设备的可用性。
4. 统一管理：方便对分布在不同地点的大量设备进行集中统一管理，确保管理策略的一致性和规范性。
5. 降低成本：减少差旅费用和现场维护所需的资源投入，同时降低因设备故障导致的生产损失。
6. 软件更新便捷：可以远程推送和安装软件更新、补丁，确保设备运行最新的安全和功能改进。
7. 增强安全性：能够远程实施安全策略，如设置访问权限、加密数据等，提高设备和数据的安全性。
8. 灵活配置：根据业务需求，随时远程调整设备的配置参数，以适应变化的工作环境和任务要求。
9. 数据收集与分析：远程收集设备产生的数据，进行分析以优化设备性能、预测维护需求和改进业务流程。
10. 便于培训与支持：远程为终端用户提供培训和技术支持，提高用户的满意度和工作效率。 三、前端代码 &lt;dd class="address-wrapper dd-padding"&gt; &lt;div class="address-container"&gt; &lt;div class="kv-line"&gt; &lt;h6&gt;名称：&lt;/h6&gt;&lt;p&gt;ld,2023-11-07 &lt;/p&gt; &lt;/div&gt; &lt;div class="kv-line"&gt; &lt;h6 style="width: 75px;"&gt;类型：&lt;/h6&gt;&lt;p&gt;未来之窗智能OS&lt;/p&gt; &lt;/div&gt; &lt;div class="kv-line"&gt; &lt;h6 style="width: 75px;"&gt;设备SN：&lt;/h6&gt;&lt;p&gt;0f9-6d0-00&lt;/p&gt; &lt;/div&gt; &lt;!-- &lt;div class="kv-line"&gt; &lt;h6 style="width: 75px;"&gt;通讯地址：&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;/div&gt; --&gt; &lt;/div&gt; &lt;/dd&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d79acc8dfdf0263c98d6a098eeed37/" rel="bookmark">
			基于ssm&#43;vue&#43;uniapp的学生签到系统小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：ssm+uniappJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
学生信息管理
教师信息管理
公告信息管理
签到信息管理
系统首页
公告信息展示
班课信息展示
我的页面
摘要
本次开发一套基于微信小程序的学生签到系统，有管理员，教师，学生三个角色。管理员功能有个人中心，学生管理，教师管理，签到管理，学生签到管理，班课信息管理，加入班课管理，请假信息管理，审批信息管理，销假信息管理，系统管理。教师和学生都可以在微信端注册和登录，教师可以管理签到信息，管理班课信息，审批请假信息，查看学生签到，查看加入班级，查看审批信息和销假信息。学生可以查看教师发布的学生签到信息，可以自己选择加入班课信息，添加请假信息，查看审批信息，进行销假操作。基于微信小程序的学生签到系统服务端用Java开发的网站后台，接收并且处理微信小程序端传入的json数据，数据库用到了MySQL数据库作为数据的存储。
研究背景
互联网时代不仅仅是通过各种各样的电脑进行网络连接的时代，也包含了移动终端连接互联网进行复杂处理的一些事情。传统的互联网时代一般泛指就是PC端，也就是电脑互联网时代，但是最近几十年，是移动互联网时代，是向下一步互联网时代过度的一个重要时代，下一个互联网时代叫物联网，而移动互联网就是一个风口，是当前社会的主流风向。目前移动互联网大行其道，人人都手中拿着智能机，手机手机，手不离机，如果开发一个用在手机上的程序软件，那是多么的符合潮流，符合管理者和客户的理想。
关键技术
当今流行的“SSM组合框架”是Spring + SpringMVC + MyBatis的缩写，受到很多的追捧，“组合SSM框架”是强强联手、各司其职、协调互补的团队精神。web项目的框架，通常更简单的数据源。Spring属于一个轻量级的反转控制框架(IoC)，但它也是一个面向表面的容器(AOP)。SpringMVC常常用于控制器的分类工作模式，与模型对象分开，程序对象的作用与自动取款机进行处理。这种解耦治疗使整个系统的个性化变得更加容易。MyBatis是一个良好的可持续性框架，支持普通SQL查询，同时允许对存储过程的高级映射进行数据的优化处理。大型Java Web应用程序的由于开发成本太高，开发后难以维护和开发过程中一些难以解决的问题，而采用“SSM组合框架”，它允许建立业务层次结构，并为这个问题提供良好的解决方案。
JS-SDK是对之前的 WeixinJSBrige 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放，在很短的时间内获得了极大的关注。从数据监控来看，绝大部分在微信内传播的移动网页都使用到了相关的接口。
JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 微信小程序 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。我们团队把很多技术精力放置在如何帮助平台上的微信小程序开发者解决这个问题。因此我们设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 微信小程序 资源离线存储”。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
Vue是一款流行的开源JavaScript框架，用于构建用户界面和单页面应用程序。Vue的核心库只关注视图层，易于上手并且可以与其他库或现有项目轻松整合。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。 系统实现
管理员可以对学生信息进行添加，修改，删除，查询操作。管理员可以对教师信息进行添加，修改，删除，查询操作。管理员可以对公告信息进行添加，修改，删除，查询操作。管理员可以对签到信息进行修改，删除，查询操作。
微信小程序输入正确的账号密码后就会默认进入首页显示界面。首页主要有轮播图，班级信息，以及下面的导航为主要组成部分。用户可以在公告展示界面对公告进行搜索和查看。学生登录后可以查看班课信息，可以选择立即加入。我的里面主要是可以进行退出，点击小齿轮就可以选择退出当前账户，也可以点击其他信息进行操作。
系统测试
程序软件的开发阶段也包括了系统测试，这个部分就是程序质量评定的一个重要环节，如果说程序通过编码实现功能之后，不通过测试检查程序中出现的错误，那么程序一旦投入生活中运行使用时，就会产生许多大大小小的错误，这个时候去解决问题已经晚了，所以一个程序在被交付给使用者使用之前，开发者就需要使用多种测试方法反复进行测试，也是对程序的一个负责表现。程序进入系统测试阶段，在讲究策略进行测试时，也需要对时效性进行把控。当开发者测试完程序，并解决完测试期间程序产生的各种错误时，就需要程序的验收方来对程序进行验收测试，这也是程序测试的最后一个操作步骤。验收测试也是对程序的质量以及可交付性方面起到关键的作用。
结论
基于微信小程序的学生签到系统开发过程中，自己之前觉得比较抽象的许多门课程，例如数据库原理，软件工程，动态网站开发等课程开始变得很清晰，只有自己独立开发程序，才会觉得这些开发类的课程在实践中具有的重要作用。为了让自己设计的作品能够顺利的完成，我把所学知识全部运用在程序的开发流程中，包括了程序的需求分析环节，程序的编码环节，程序的测试环节等，让程序软件在开发周期内完成制作，并能够保证程序质量达标，力求程序开发流程规范化，程序对应的配套文档标准化。
（可运行源码+sql文件+文档）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5612b606c394a42e58a41400a3601b63/" rel="bookmark">
			CSS文字方向控制属性text-orientation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CSS中，text-orientation 属性主要用于控制文本的方向，特别是当文本被设置为垂直排列时。这个属性主要用于东亚语言的排版，比如中文、日文和韩文，这些语言在垂直书写时，字符的排列方向可能与拉丁文字不同。
text-orientation 属性有两个常用的值：
mixed：默认值。在垂直书写模式下，文本的方向会根据字符的类型自动调整。对于拉丁文字，它们会保持水平方向；而对于东亚文字（如中文、日文、韩文），它们会保持垂直方向。
upright：在这个模式下，所有字符都会尝试以垂直方向排列，即使它们是拉丁文字。这可能会导致拉丁文字的阅读变得困难，因为它们的自然方向是水平的。
需要注意的是，text-orientation 属性通常与 writing-mode 属性一起使用，后者用于设置文本的方向（水平或垂直）。例如，如果你想要将文本设置为垂直方向，并希望所有字符（包括拉丁文字）都保持垂直排列，你可以这样做：
.vertical-text { writing-mode: vertical-rl; /* 文本方向设置为垂直，从右到左 */ text-orientation: upright; /* 强制所有字符都垂直排列 */ } 然而，需要注意的是，text-orientation: upright; 的效果可能因浏览器和字体而异，特别是在处理拉丁文字时。有些浏览器可能无法很好地支持拉丁文字的垂直排列，导致显示效果不佳。
此外，text-orientation 属性是一个较新的CSS属性，可能在一些旧版浏览器中不被支持。因此，在使用时需要考虑兼容性问题。
总的来说，text-orientation 属性为CSS提供了更精细的文本方向控制，特别是在处理东亚语言的垂直排版时非常有用。然而，在使用时需要注意其与其他CSS属性的配合以及浏览器的兼容性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b0b349508e1b9fb85bf0d42cd1dfe6/" rel="bookmark">
			css中怎样使calc计算的高度生效？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 CSS 中，calc() 函数用于动态计算长度、大小或其他值。对于计算后的高度要生效，通常父元素需要具备一定的高度定义。你可以通过以下几种方式设置父元素的高度：
1、固定高度：父元素使用固定高度，如 height: 500px;，这样子元素的 calc() 计算会基于这个高度进行。
2、百分比高度：如果父元素的高度是百分比，那么其父元素（祖先元素）也需要有固定高度或百分比高度，最终回溯到一个具有固定高度的元素。
3、vh 单位：父元素可以使用 vh（视口高度单位）来设置高度，这样子元素的 calc() 计算也可以生效。
示例 1：父元素有固定高度
&lt;div class="parent"&gt; &lt;div class="child"&gt;子元素&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .parent { height: 500px; /* 固定高度 */ background-color: lightblue; } .child { height: calc(100% - 50px); /* 高度为父元素高度的100%减去50px */ background-color: coral; } &lt;/style&gt; 示例 2：父元素使用 vh 单位
&lt;div class="parent"&gt; &lt;div class="child"&gt;子元素&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .parent { height: 50vh; /* 使用视口高度单位 */ background-color: lightblue; } .child { height: calc(100% - 50px); /* 高度为父元素高度的100%减去50px */ background-color: coral; } &lt;/style&gt; 在这两个示例中，calc() 函数都可以正常计算子元素的高度，并且该高度基于父元素的高度进行计算。第一种情况下，父元素的高度是固定的 500px，而第二种情况下，父元素的高度是视口高度的 50%。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0522ea30fd46e1987a08aa6d0a84faeb/" rel="bookmark">
			【AI绘画】Midjourney提示词详解：精细化技巧与高效实践指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 💯AI作画提示词基础结构1 图片链接1.1 上传流程 2 文字描述3 后置参数 💯AI作画提示词的文字描述结构1 主体+主体细节描述2 环境背景2.1 环境2.2 光线2.3 色彩2.4 氛围 3 视角4 景别构图5 艺术风格6 图片制作方法7 作品质量万能词 💯AI作画提示词符号1 语义隔断2 权重符 💯如何使用AI工具辅助生成AI作画提示词💯AI作画提示词学习网站介绍1 Midjourney 提示词生成平台2 midlibrary3 PromptHero 💯AI作画提示词基础结构 [图片链接1] [图片链接2] 提示词 --arr 宽:高 格式：图片链接+文字描述+后置参数
注意：各部分用空格分开
1 图片链接 作用：让一张或多张图片做为Midjourney生成图片的参考
1.1 上传流程 上传图片 素材图： 复制进聊天框
2. 获得图片地址
粘贴进提示词第一部分，用空格与文字描述隔开 提示词： Still Life of perfume,simple background,water 注意点：文字描述与图片共同影响生成结果
注意1 关于图片链接的部分，这是一个可选项，并非必须提供。只有当你有具体的图片作为参考时，才需要附上图片链接。如果你没有图片进行参考，那么图片链接自然也就不需要了。比如，当你想要生成一瓶香水的静物图时，如果你事先没有明确的构图、材质和形状作为目标，那么你无需过多描述，只需直接写出“香水的静物图”即可。此时，系统仍然能够生成图片，但它就无法根据你想要的特定感觉或你提供的图片中的感觉来生成图片了。
只有提示词,没有图片参考效果任如下： 注意2 当你上传多张图片时，请确保图片与图片之间有空格作为区分。
这里以防水的面料图为例，讲解其具体适用场景
提示词： Close-up of waterproof fabric with water droplets on the fabric 如果不进行垫图处理，Midjourney给出的图像往往难以达到我们预期的效果。具体来说，存在两个问题。首先，生成的布料显得过于光滑，更像是塑料布，而非真正的布料。其次，布料的皱褶细节不足，缺乏布料应有的质感。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0522ea30fd46e1987a08aa6d0a84faeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d54e30d0a06d767fbb2a0e10b91589/" rel="bookmark">
			高性能 Web 服务器：让网页瞬间绽放的魔法引擎（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.Nginx 反向代理功能
1.缓存功能
2.http 反向代理负载均衡
二.实现 Nginx 四层负载均衡
三.实现 FastCGI
1.为什么会有FastCGI？
2.什么是PHP-FPM？
3.FastCGI配置指令
4.Nginx与php-fpm在同一服务器
5.Nginx配置转发
6. php的动态扩展模块（php的缓存模块）
​编辑​编辑
7.php高速缓存
四.nginx 二次开发版本:编译安装 openresty
一.Nginx 反向代理功能
1.正向代理是客户端指定让代理去访问哪个服务。翻墙服务是用户自己花钱买到，所以正向代理代表的是客户端的利益， 反向代理是代理将客户端的请求分发给某个服务器。Nginx服务器是服务端搭建的，代表的是服务端的利益。
2.反向代理：reverse proxy，指的是代理外网用户的请求到内部的指定的服务器，并将数据返回给用户的 一种方式，这是用的比较多的一种方式。 nginx 本身不具备的请求通过某种预 定义的协议转发至其它服务器处理，不同的协议就是Nginx服务器与其他服务器进行通信的一种规范，主要在不同的场景使用以下模块实现不同的功能： ngx_http_proxy_module: #将客户端的请求以http协议转发至指定服务器进行处理 ngx_http_upstream_module #用于定义为proxy_pass,fastcgi_pass,uwsgi_pass #等指令引用的后端服务器分组 ngx_stream_proxy_module: #将客户端的请求以tcp协议转发至指定服务器处理 ngx_http_fastcgi_module: #将客户端对php的请求以fastcgi协议转发至指定服务器助理 ngx_http_uwsgi_module: #将客户端对Python的请求以uwsgi协议转发至指定服务器处理
3.逻辑调用关系：
同构代理：用户不需要其他程序的参与，直接通过http协议或者tcp协议访问后端服务器 。
异构代理：用户访问的资源时需要经过处理后才能返回的，比如php，python，等等，这种访问资源需 要经过处理才能被访问
#需要三台主机： #172.25.254.100 Nginx 代理服务器 #172.25.254.10 后端node1web，Apache部署 #172.25.254.20 后端node2web，Apache部署 --------------------node1web:172.25.254.10-------------------------- yum install httpd -y systemctl enable --now httpd echo node1web - 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51d54e30d0a06d767fbb2a0e10b91589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ac1baf8f93111a6fc13a99a39a170c/" rel="bookmark">
			鸿蒙内核源码分析(Fork篇) | 一次调用，两次返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者第一次看到fork时，说是一次调用，两次返回，当时就懵圈了，多新鲜，真的很难理解.因为这足以颠覆了以往对函数的认知， 函数调用还能这么玩，父进程调用一次，父子进程各返回一次.而且只能通过返回值来判断是哪个进程的返回.所以一直有几个问题缠绕在脑海中.
fork是什么? 外部如何正确使用它.为什么要用fork这种设计? fork的本质和好处是什么?怎么做到的? 调用fork()使得父子进程各返回一次，怎么做到返回两次的，其中到底发生了什么?为什么pid = 0 代表了是子进程的返回? 为什么父进程不需要返回 0 ? 直到看了linux内核源码后才搞明白，但系列篇的定位是挖透鸿蒙的内核源码，所以本篇将深入fork函数，用鸿蒙内核源码去说明白这些问题.在看本篇之前建议要先看系列篇的其他篇幅.如(任务切换篇，寄存器篇，工作模式篇，系统调用篇 等)，有了这些基础，会很好理解fork的实现过程.
fork是什么 先看一个网上经常拿来说fork的一个代码片段.
#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { pid_t pid; char *message; int n; pid = fork(); if (pid &lt; 0) { perror("fork failed"); exit(1); } if (pid == 0) { message = "This is the child\n"; n = 6; } else { message = "This is the parent\n"; n = 3; } for(; n &gt; 0; n--) { printf(message); sleep(1); } return 0; } pid &lt; 0 fork 失败pid == 0 fork成功，是子进程的返回pid &gt; 0 fork成功，是父进程的返回fork的返回值这样规定是有道理的。fork在子进程中返回0，子进程仍可以调用getpid函数得到自己的进程id，也可以调用getppid函数得到父进程的id。在父进程中用getpid可以得到自己的进程id，然而要想得到子进程的id，只有将fork的返回值记录下来，别无它法。子进程并没有真正执行fork()，而是内核用了一个很巧妙的方法获得了返回值，并且将返回值硬生生的改写成了0，这是笔者认为fork的实现最精彩的部分.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ac1baf8f93111a6fc13a99a39a170c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a314476090309e27ce74133c8fe6cb8/" rel="bookmark">
			基于Java和GeoTools的Shapefile矢量数据缩略图生成实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、关于GeoTools的图片生成
1、关于GtRenderer
2、关于 图像生成架构
3、流式计算绘制
二、全球空间预览生成实战
1、pom.xml中关于图像生成依赖
2、样式设置及地图资源绑定
3、图片生成绘制
4、图片生成测试
三、成果验证
1、全球范围生成
2、我国的范围示意图
3、日本范围生成
四、总结
前言 在很多的面向WebGIS的应用开发过程中，我们通常会将空间地理数据，比如Shapefile等矢量数据或者Tiff等栅格数据进行发布到GIS服务器中。为了能直观的展示这些空间矢量数据或者栅格数据的空间范围及大致的数据边界，我们需要将服务化之后的数据进行缩略图的预览展示。如果大家熟悉GeoServer或者ArcgisServer的话，对这个需求一定不陌生。如果我们是自己发布的GIS服务，怎么提供这种类似的空间数据的预览服务呢？在不引入其它的外部服务的情况下。这是个值得思考的问题。
本文即是在上述的需求场景下出现的。本文主要使用Java语言，讲解如何使用GeoTools这个组件来进行空间Shapefile数据转换成图片，从而实现服务缩略图的功能。文章通过实例的模式讲解预览图片的生成，对于在研究Java的服务预览图片生成的同学和朋友有一定的参考价值。 一、关于GeoTools的图片生成 关于GeoTools这个使用Java开发的地理开发组件，它提供了许多丰富的功能和生态来帮助我们实现图片的生成操作。关于GeoTools的整体架构和相关知识，我想在后面的章节中再慢慢介绍。今天先试用它的图形渲染功能来实现空间数据的可视化渲染。本节重点讲解Geotools当中的GTRenderer功能。
1、关于GtRenderer 关于在GeoTools中使用图像渲染和生成的功能，我们会使用到GtRenderer这个组件。它在GeoTools的官网原文中的介绍如下：
GTRenderer renderer is the reason why you signed up for this whole GeoTools experience; you want to see a Map.
GTRenderer is actually an interface; currently there are two implementations:
2、关于 图像生成架构 为了实现空间对象的生成，我们来看下它的后台使用类的生成关系。这个图可以参考管网给出的一个类关系图。
当然，上图中的相关接口和类中，尤其是在实现类中，实现类的方法和属性的定义是非常多的。但是在上图中做了一定的处理，没有展示那么多的方法。这里，我们会对StreamIngRenderer这个类比官网多一些的详细说明。 详细说明为什么使用流式计算，在实际的绘图过程中，有哪些方法是比较重要的
在面向对象的学习过程中，我们选择从接口或者抽象类，自顶向下的方式来研究相关的类。因此，在这里，我们首先对抽象的接口GTRenderer进行研究。GTRenderer的源码不多，主要定义的都是关于如何绘制的API，这里直接给出它的代码：
package org.geotools.renderer; import java.awt.Graphics2D; import java.awt.Rectangle; import java.awt.RenderingHints; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a314476090309e27ce74133c8fe6cb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54aa59cd6d866ad7f220edcc3edb6144/" rel="bookmark">
			Spring模块详解Ⅱ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Spring Beans模块详解1. 什么是 Bean?2. Spring Bean的配置方式2.1 基于 XML 配置例子： 2.2 基于注解配置例子： 2.3 基于 Java 配置（JavaConfig）例子： 3. Bean 的生命周期生命周期回调的例子： 4. Bean 的作用域例子： 5. 依赖注入方式5.1 构造器注入例子： 5.2 Setter 注入例子： 5.3 字段注入例子： 6. 自动装配（Autowiring）例子： 7. Bean 的依赖关系例子： 8. Bean 后置处理器（BeanPostProcessor）例子： 总结 Spring Context1. 什么是 Spring Context?2. ApplicationContext 的主要实现3. 国际化支持国际化消息文件使用 `MessageSource`XML 配置：Java 配置： 使用国际化消息： 4. 事件处理机制核心接口与类：自定义事件：自定义监听器：发布事件： 5. 资源访问获取资源： 6. 生命周期管理生命周期回调：生命周期回调示例： 7. Environment 抽象访问环境属性： 8. ApplicationContext 的扩展WebApplicationContext 示例： 总结 Spring Beans 模块详解 Spring Beans 模块是 Spring 框架的核心部分之一，它主要负责 Bean（即应用程序中的对象）的定义、配置、创建、管理和销毁。Spring Beans 模块通过依赖注入（Dependency Injection, DI）和控制反转（Inversion of Control, IoC）模式帮助开发者解耦对象之间的依赖关系，从而简化代码结构，提高可测试性和可维护性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54aa59cd6d866ad7f220edcc3edb6144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da365a4c8e666ef46c81c39eeb725895/" rel="bookmark">
			STM32 GPIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.GPIO的8种工作模式
输入浮空 输入上拉 输入下拉 模拟输入
开漏输出 推挽式输出 推挽式复用功能 开漏复用功能
2.位设置寄存器的必要性
没有寄存器 位操作的方法是：读取8位寄存器的值—&gt;与或运算—&gt;重新写入
如果在与或运算时发生中断改变了值 那么重新写入的就是错误的，为避免出现这种情况需要硬件寄存器位操作
3.GOPIO配置流程
1.开时钟
2.初始化设置 ：配置GPIO_InitTypeDef结构体（模式 引脚 上拉下拉 开关频率）
3.配置接PB8的LED灯
结构体的参数 可全局搜索定义@后的内容
4.配置代码
void led1_init(void) //LED1初始化 { __HAL_RCC_GPIOB_CLK_ENABLE(); //打开GPIOB时钟树 GPIO_InitTypeDef gpioinit_struct; gpioinit_struct.Mode = GPIO_MODE_OUTPUT_PP;//推挽 gpioinit_struct.Pin = GPIO_PIN_8; gpioinit_struct.Pull = GPIO_PULLUP;//上拉 gpioinit_struct.Speed = GPIO_SPEED_FREQ_HIGH;//高频 HAL_GPIO_Init(GPIOB, &amp;gpioinit_struct); } void led1_on(void) { HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8,GPIO_PIN_SET);//位操作输出高 } void led1_off(void) { HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8,GPIO_PIN_RESET); } void led1_toggle(void) { HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_8);//位操作翻转 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90634d545d576c15696c58829ae5b3ab/" rel="bookmark">
			STM32自制手持小风扇实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 介绍： 实验功能说明：功能（1）按一下按键小风扇开启，再按一下关闭。
功能（2）按一下按键小风扇一档风速，再按一下二挡，依次三挡…关闭。
按键模块说明：按下S输出低电平
电机驱动一体模块说明：VG引脚供电，AB是信号控制引脚，PWM可以调速
正转控制：B低电平，A高电平 反转控制：B高电平，A低电平
1.3 实验组件： 1.4模块接线图： 1.5 实验代码： 链接：https://sourl.cn/7FXAif
1.6实验结果： 件连接好线之后，将上述程序上传到STM32开发板之后
功能（程序1）按一下按键小风扇开启，再按一下关闭。
功能（程序2）按一下按键小风扇一档风速，再按一下二挡，依次三挡…关闭。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04560ab810dff4d5d535a7d09fce80fd/" rel="bookmark">
			三问AI手机：什么意图？怎么识别？何种框架？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早在几个月前，就有媒体同行问我：AI手机到底是什么？跟智能手机有什么本质的不同？
试想一下，如果经常跟科技企业、技术趋势打交道的媒体人、分析师都对何谓AI手机云里雾里，更别提门店销售和消费者了。
2024被认为是AI手机元年，但今天走进线下门店，会发现店员和用户都对手机里的AI有啥不一样，感知并不明显。
移动互联网时代，我们常说手机是人“肢体”的延伸，可以让我们的“手”触及更远的地方，“看”到更广阔的事物。到了AI时代，手机是“大脑”的延伸，心念一动、言出法随，手机会根据我们的使用习惯和意图，主动提供有价值的服务。
所以，AI手机区别于智能机的一个更高阶、更本质的能力，就是“意图识别”。
目前，苹果阵营、华为鸿蒙阵营、荣耀OV安卓阵营，都将意图识别作为重点。
苹果CEO库克在AI系统“Apple Intelligence”的发布会上重点强调，在“苹果智能（Apple Intelligence）”的支持下，Siri具备了精准识别用户真正意图的能力。
而安卓和鸿蒙用户，恐怕对此并不陌生。
华荣OV等国产手机厂商早就上线了相应能力。荣耀在2023开发者大会上带来了行业首个基于AI意图识别的人机交互（IUI）操作系统——MagicOS 8.0；华为在HDC 2024上提出Harmony Intelligence，使得小艺能力大幅提升，能够理解并预测用户需求，并通过意图框架与合作伙伴应用场景整合。
OV虽然没有明确推出意图框架等平台，但也用行动参与其中。将大模型融入系统的底层设计中，升级OriginOS、BlueOS，来实现复杂的意图识别和推理决策。
那么用户又该迷惑了，各家都在说“意图识别”，到底有啥不一样呢？
“意图”是人心中所想，带有模糊和不确定性，“识别”结果也就有了很大的自由阐释空间，厂商如何避免自说自话，把“手机懂你”这件事落在实处？
就要依靠一个操作系统级的全局意图感知、理解、决策技术体系。
我们不妨把“意图识别框架”这一新概念详细拆分开，看看每一个环节的准入门槛是什么。
意图识别的第一步，当然是搞清楚什么是用户的“意图”，也就是手机厂商所说的“懂你”。
但“意图”并不是什么新概念。
早在互联网时代，意图识别就被应用于搜索引擎、广告推荐等场景。比如用户在搜索框输入“抓娃娃”，底层的检索策略要识别到这是电影需求，再去电影的数据库里检索，如果电影意图识别失败，返回的搜索结果中，根本没有《抓娃娃》电影相关内容，或者要翻好几页才显示，都会导致很糟糕的用户体验。所以，意图识别很早是科技企业研究的对象。
那么，AI手机所谓的“意图识别”，有啥特殊呢？
特殊在于，要游过深海。
今天手机所承载的“意图”，有两个特点：
一是范围广。一个动作或词语可能对应多个意图。现代消费电子设备的激增，带来了丰富多样的功能和服务，几乎涵盖了我们生活的方方面面，终端设备的多元、服务的多样，经常会出现多种意图，比如输入“长城”，可能是景点、电影或者汽车，这就使手机的意图识别更难做。
二是隐蔽性。传统意图识别可以根据用户给出的query词来进行判断，属于相对明确的“显性意图”，但日常使用手机时，还有大量隐性意图，比如眼睛注视手机屏幕，可能是想看时间、看新消息通知或日程计划；遗忘了出行计划，可实际上航班时间应该重点关注……这些是用户真实需要，但自己很少意识到或清晰表达出来的“隐性意图”，由于无法被清晰表达，难以转译成计算机语言，自然也就难以满足。
这些多且隐蔽的意图，构成了一片“意识深海”，需要手机厂商跋涉而过，找到一条最短路径。
由此，我们不难明确，AI手机意图识别的意义：
首先是化繁为简。通过洞察用户真正的需求，简化获取服务的步骤。
比如荣耀的“任意门”功能，带来了行业首个基于意图识别的人机交互，只需一拖不到1秒即可完成以往8步10秒的操作流程。当用户收到一条信息，复制之后，系统会自动分析语义并提炼关键内容，预判接下来的需求和操作，自动一步直达备忘录、地图等应用。华为智慧搜索支持“一键场景直达”、OPPO的ColorOS 14系统中的“流体云”功能，能预测用户行为，自动接入相应的使用场景……这些都简化了操作步骤。
其次，多想一步。通过隐性意图的识别和满足，带来超出用户期望的惊喜体验，构建差异化优势。
华为曾在一次分享会中提到，HarmonyOS意图框架可以通过长时间的学习训练，把人们自己都感觉不到的规律串联起来，并通过端侧的本地学习完成本地学习推荐，从而完成“超预期”的智慧搜索服务体验。
接下来，可以主动服务。比用户多想一步，就能将服务化被动为主动，更快更恰当地送到用户的眼前指尖。
目前，鸿蒙系统的场景化入口，就可以根据意图判断，将不同服务融入实际场景中，比如搭乘飞机，航班信息会优先显示在实时状态栏，荣耀Magic Live也有类似的主动服务，在观影、听歌、走进地铁站等场景中，提前将取票、听歌偏好、地铁码等原子化服务进行推送。
基于意图识别的人机交互，让你最需要的服务，涉过意识的深海。
洞察到了用户的意图，就能将服务精准送达吗？其实还要穿过一片AI的丛林。
有一个职场段子，老板让秘书定一个航班，最低段位的秘书，就只会看那一班，而最高段位的，还会提供多个航班选择，还考虑到出差需求，也把当地的住宿、餐饮等都提前查好备选。
如果让手机AI来应聘做你的助理，你希望是哪一个段位呢？
最高段位的AI助理，要真正理解你说的话背后的真实意图，并真正完成你想要的任务，其实要拆分为几个步骤。
步骤一：充分感知。一个优秀的助理，并非“胡子眉毛一把抓”，什么事情都要提前安排，而是结合上下文背景和情境，来对用户的潜在意图进行判断。所以，充分感知场景和情境，就非常必要了。
苹果高级副总裁Craig曾表示，Apple Intelligence的真正独特之处是能理解个人情境。能够根据你的个人数据，你现在打开的页面等背景，来理解需求。
比苹果更早一些，荣耀在2016年第一代Magic上首发Magic Live智慧系统，就能够自动感知判断。
步骤二：分析判断。
有了上下文背景，怎么推断多个意图的重要性和优先级呢？这就涉及语义理解了。目前，检索、问答等任务，由于用户有明确的检索词，利用大模型的自然语言理解能力，已经可以很好地推断用户到底想干什么。
其中比较具有代表性的是Apple Intelligence苹果智能+ GPT-4o大模型的方案。基于Apple Intelligence，苹果为Siri引入了多模态交互能力，可以从输入的自然语言中精准地进行用户意图识别，将任务拆分为多个任务，作为生成回答的基石。
步骤三：精准执行。
我们可以把每一个服务和功能，想象成一个个智能体，每个智能体只有孤立的识别和输出能力，要完成用户需要的复杂任务，需要对这些智能体进行精巧地、自动化地调取和编排，才能在意图判断之后，做出最恰当的执行反馈。
OPPO与IDC联合发布的《AI手机白皮书》中提到，成熟的AI手机系统要内嵌用户定义的专属智能体，不断理解用户习惯，自学习、直觉化。
在VDC开发者大会的一场技术论坛中，vivo的技术人员也透露，作为业内首个推出手机大模型（蓝心大模型）的厂商，他们很早就开始研究agent，对手机原生化服务组件的拆分很细、编排恰当。
这样看，从意图到服务之间，还要经过数据（感知）、算法（分析）、智能体（执行）的一片AI森林，只有具备完整AI技术体系的厂商，才能顺利跑通。
从上述意图识别的拆解中不难感受到，AI手机想做的“以人为中心”的主动服务，跨设备的数据流转（全场景感知），跨应用的服务触达，以及全局安全，是必不可少的。
如何将各层级、各终端、各系统、各应用都整合在一起？
意图框架，就是关键纽带，具备操作系统平台级的能力，可以让AI贯穿从数据到服务的完整链路，带来意图识别的能力飞跃。
目前，荣耀、华为、苹果都推出了自己的框架或平台。
其中，Magic Live智慧引擎是基于场景感知、用户理解和意图决策三大核心能力的平台型AI解决方案，形成了一个能够衔接各种轨迹和能力的“大脑”，实现了从单意图到多意图关联的精准意图判断。
苹果也采用了“荣耀模式”，App Intent意图框架包含了自学习引擎，实时学习用户行为，并根据时间和空间信息，提供个性化服务。
华为HarmonyOS的意图框架，则构建全局意图范式，基于鸿蒙系统的跨端互联协作优势，实现多维系统感知，结合AI大模型、AI推理框架、端云协同等计算处理能力，将需求传递给服务方，拉起/执行更恰当的服务。
总结一下荣耀、华为、苹果的意图框架，就是具备“地基”的能力。
为了更好的意图理解，三家都进行了深度的技术搭建，实现了操作系统级别、跨终端的意图感知、理解，只有深入到系统层面，才能真正重构手机AI体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04560ab810dff4d5d535a7d09fce80fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f41cadb89d60827b3adadfb7d2f9431/" rel="bookmark">
			【Linux学习】Linux开发工具——vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页： Forcible Bug Maker
🔥专栏：Linux学习
目录 🌈前言🔥vim的基本概念🔥vim的基本操作🔥vim命令模式的命令集🔥简单vim配置⭐一键配置美观的vim安装方法卸载方法 🔥结语 🌈前言 前言：Linux编辑器——vim的介绍和使用。
vim 是一款在 Linux、Unix 以及类 Unix 系统（比如 macOS）上广泛使用的文本编辑器。它最初由 Bram Moolenaar 在 1991 年发布，作为 vi 编辑器的改进版。vi 编辑器是 Unix 系统上最早的屏幕编辑器之一，由 Bill Joy 在 1976 年为 BSD Unix 系统编写。
vi/vim的区别简单点来说，它们都是多模式编辑器，不同的是vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。例如语法加亮，可视化操作不仅可以在终端运行，也可以运行于x window、 mac os、windows。
🔥vim的基本概念 vim编辑器有很多种模式，目前主要介绍常用的三种，分别是 命令模式（Command mode），插入模式（Insert mode） 和 底行模式（Last line mode），这三种模式的区别如下：
命令模式：
控制屏幕光标的移动，字符，字或行的删除，移动复制某区段及进入Insert mode，或者进入Last line mode。插入模式：
只有在Insert mode下，才可以做文字输入，按[Esc]键可回到命令模式。底行模式：
文件保存或退出，也可进行文件替换，找字符串，列出行号等操作。在命令模式下：:符号，也就是shift + ;可以切换到底行模式。 也可以在底行模式下输入:help vim-modes查看更多的模式介绍。
🔥vim的基本操作 进入vim，在系统提示符号输入vim+文件名称之后，就可以进入vim全屏幕编辑画面：
$ vim test.c 需要注意的是，进入vim之后，首先处于[命令模式]，需要切入到[插入模式]才能输入文字。
[命令模式]切换至[插入模式] 输入i输入a输入o [插入模式]切换至[命令模式] 按[Esc] [命令模式]切换至[底行模式] [Shift + ;]，其实就是输入[:] 退出vim并保存文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f41cadb89d60827b3adadfb7d2f9431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183d5cb8eb82f62b8fb15ce494a63f56/" rel="bookmark">
			基于python&#43;大数据爬虫技术&#43;数据可视化&#43;Spark的电力能耗数据分析与可视化平台设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝50W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行前辈交流✌
技术范围：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
主要内容：免费功能设计、开题报告、任务书、中期检查PPT、系统功能实现、代码编写、论文编写和辅导、论文降重、长期答辩答疑辅导、腾讯会议一对一专业讲解辅导答辩、模拟答辩演练、和理解代码逻辑思路。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
大数据项目实战《100套》
Python项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人​
系统介绍： 随着经济的发展和人口的增加，能源消耗也在不断增加。电力作为人们生产和生活中不可或缺的一部分，对于能源消耗的贡献也非常大。传统的电力供应模式已经无法满足人们对电力的需求，同时也带来了环境污染等问题。如何优化电力供应模式，提高能源利用效率，成为了当前亟待解决的问题。而电力能耗数据分析正是解决这一问题的有效手段之一。本研究基于Spark技术对电力能耗数据进行分析，旨在为电力企业提供决策支持，优化能源消耗结构，提高能源利用效率。通过对历史用电数据的分析，可以得到不同时间段内的用电趋势、用电负荷分布、能源消耗结构等信息，为电力企业的生产管理和决策提供科学依据。该系统可以帮助政府制定合理的能源政策，促进可持续发展。还可以为普通用户提供更加智能化的用电服务，提高用电效率，节约能源。因此，本研究具有重要的理论和实践意义。
近年来，随着大数据技术的快速发展，电力能耗数据分析系统在国内得到了广泛的关注和应用。国内学者和研究人员在电力能耗数据分析领域开展了大量的研究工作，涉及到数据清洗、特征提取、模型训练等方面。基于Spark技术的电力能耗数据分析系统成为了研究的热点之一。许多研究者利用Spark技术对电力能耗数据进行分析，得出了不同时间段内的用电趋势、用电负荷分布、能源消耗结构等信息，为电力企业的生产管理和决策提供了科学依据。
在国外，电力能耗数据分析也受到了广泛的关注和应用。许多国外的研究机构和企业都在开展相关的研究工作。其中，美国、欧洲等发达国家在电力能耗数据分析领域的研究处于领先地位。这些国家的研究者们利用先进的技术和方法对电力能耗数据进行分析，探索出了一些新的模型和方法，如深度学习、神经网络等。这些国家还注重将研究成果应用到实际生产中，为电力企业提供更加智能化的决策支持。
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​ 程序操作流程图
首先前端通过Vue和axios发送HTTP请求到后端的登录接口。在后端接收登录请求的Controller会使用`@RequestParam Map&lt;String, Object&gt; params`来接收前端传递的用户参数，用户名和密码。然后后端根据接收到的参数创建一个查询条件封装对象MyBatis的EntityWrapper用于构建查询条件。接着在业务层，调用相应的service方法来查询数据库中是否存在匹配的用户信息。这个查询方法Login()会将前端传递的对象参数传递到后台的DAO层，进行数据库的交互操作。如果存在符合条件的用户，则会返回相关的用户信息。最后在后端控制器中将查询结果封装成响应体，通过`return R.ok().put("data", userService.selecView(ew))`将用户信息返回给前端。前端收到响应后，可以通过调用Vue、ElementUI等组件来渲染登录结果，例如显示用户信息或者跳转到相应的页面。
系统架构设计 系统架构设计是软件开发过程中至关重要的一环。首先是模型层（Model），模型层通常对应着数据库或者其他数据源，它负责与数据库进行交互，执行各种数据操作，并将处理后的数据传递给控制器层。模型层的设计应该简洁清晰，尽可能减少与视图和控制器的耦合，以提高代码的可维护性和可重用性。
其次是视图层（View）通常是通过网页、移动应用界面或者其他用户界面来展示数据。视图层与用户交互，接受用户的输入，并将输入传递给控制器层进行处理。在MVC三层架构中，视图层应该尽量保持简单，只负责数据的展示和用户交互，不涉及业务逻辑的处理，以保持视图层的清晰度和可复用性，最后是控制器层（Controller），每个层都有特定的职责和功能，通过分层架构设计，实现代码模块化，为软件开发提供了一种有效的架构模式。系统架构如图4-1所示。
详细视频演示 请联系我获取更详细的演示视频
功能截图： 在系统前台首页，调用`$route(newValue)`方法监听路由变化，根据当前的路由地址来确定活动菜单的索引，并且根据路由的哈希部分（即URL的`#`后面的部分）来判断是否需要滚动页面到顶部或者某个特定元素的位置。如果不是首页，会将页面滚动到指定元素处，否则滚动到页面顶部。另外通过`headportrait()`方法用于更新组件渲染点前用户头像。在用户登录后，后端返回了新的用户信息，需要及时更新页面上的用户头像信息。
随着时代的发展，都电力能耗数据也爆发出了强大的潜力，人们对于快捷高效的追求愈演愈烈，而传统管理方式显然不再适用快节奏的今天，都电力能耗数据迫切希望出现一个工具，来帮助电力能耗的高效管理。本文系统性的论述了电力能耗数据分析的研究与设计的过程，其主要的内容如下所示：
1.系统性的分析了电力能耗数据分析的研究背景和国内外的研究现状，简单性的介绍了该系统的理论意义和实践意义；
2.简单介绍了实现的相关技术，包括：python 技术、MySQL数据库、B/S模式等技术；
3.从用户需求方面对系统的功能需求进行了分析；
4.对系统的功能做了详细的设计，并加以实现；
5.对系统做了大量的测试，并对存在的问题加以修改完善。
最终实现了电力能耗数据分析的成功运行，系统内实现了都电力能耗数据的全部功能，能够满足人们对于高效便捷的需求，可以成为人们身边的好助手，同时也增加了一种高效的管理途径。
论文参考： 1 绪 论 1.1研究背景与意义 1.2系统研究现状 1.3 论文主要工作内容 2 系统关键技术 2.1 java简介 2.2 MySQL数据库 2.3 B/S结构 2.4 SpringBoot框架 2.5 VUE框架 3 系统分析 3.1 系统可行性分析 3.1.1 技术可行性 3.1.2 操作可行性 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183d5cb8eb82f62b8fb15ce494a63f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615b12084c3d768dd31ee25623ecbb92/" rel="bookmark">
			css高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定位 1.1定义 作用：灵活的改变盒子在网页中的位置
实现：定位模式：position
边偏移：设置盒子的位置
left
right
top
bottom
1.2相对定位 position:relative
特点：
1.改变位置的参照物是自己原来的位置
2.不脱标、占位
3.显示模式不变
1.3绝对定位 position：absolute
使用场景：子级绝对定位，父级相对定位（子绝父相）
特点：
1.先找最近的已经定位的元素参照，所有祖先元素都没定位，就参照浏览器
2.显示模式变行内块
3.脱标，不占位
二、定位居中 2.1实现步骤 1.绝对定位
2.水平、垂直边偏移50%
3.子级向左、上移动自身尺寸的一半（margin、transform）
2.2transform 定位居中：transform：translate（50%，50%）
三、固定定位 position:fixed
特点：
1.脱标、不占位
2.参照物是浏览器窗口
3.显示模式具备行内块特点
四、堆叠层级 默认效果：按照书写顺序，后来者居上
作用：设置元素的层级顺序，改变元素定位的显示顺序
想要谁在上就给谁加z-index
取值为整数，默认为0，越大越靠上
五、css精灵 5.1优点 减轻服务器的压力，提高页面加载速度
5.2使用 设置背景图然后调整图片偏移量
六、字体图标 6.1下载 图标库：https://www.iconfont.cn/
下载步骤：
进入官网-选图标-加入购物车-添加至项目-下载到本地
6.2使用 1.把下载好的文件夹放进项目文件
2.在html文件中link iconfont.css文件 字体文件不能删
3.标签使用字体图标类名
class="iconfont 要使用的图标类名"
打开实例文件-fontclass-复制图标下的类名
如果要调整图标大小，选择器的优先级要高于iconfont类
6.3上传矢量图 svg文件上传图标库，生成字体
七.css修饰属性 7.1垂直对齐方式 vertical-align
属性值
baselline:基线对齐（默认）
top：顶部
middle：居中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/615b12084c3d768dd31ee25623ecbb92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a51b3c137985ebdeb55e04e5322fb235/" rel="bookmark">
			C语言04--数组超详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基本概念 逻辑：一次性定义多个相同类型的变量，并存储到一片连续的内存中语法： 数据类型 数组名字 [ 数据的量 ] ; 示例： int a[5]; int Num ; 语法释义： a 是数组名，即这片连续内存的名称[5] 代表这片连续内存总共分成5个相等的格子，每个格子称为数组的元素int 代表每个元素的类型，可以是任意基本类型，也可以是组合类型，甚至可以是数组初始化：在定义的时候赋值，称为初始化 // 正常初始化 int a[5] = {100,200,300,400,500}; int a[5] = {100,200,300,400,500,600}; // 错误，越界了 int a[ ] = {100,200,300}; // OK，自动根据初始化列表分配数组元素个数 int a[5] = {100,200,300}; // OK，只初始化数组元素的一部分 数组的真实存储
2.数组元素的引用 存储模式：一片连续的内存，按数据类型分割成若干相同大小的格子元素下标：距离数组入口位置的偏移量 3.示例： int a[5]; // 有效的下标范围是 0 ~ 4 a[0] = 1; a[1] = 66; a[2] = 21; a[3] = 4; a[4] = 934; a[5] = 62; // 错误，越界了 a = 10; // 错误，不可对数组名赋值 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a51b3c137985ebdeb55e04e5322fb235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7b99a956da36269185126557524257/" rel="bookmark">
			【C&#43;&#43;】————智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页： 作者主页
本篇博客专栏：C++
创作时间 ：2024年8月20日
一，什么是智能指针 在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。
c++中用的最多的是下面三种智能指针 C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件&lt;memory&gt;
std::shared_ptr：共享的智能指针std::unique_ptr：独占的智能指针std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。 二，共享的智能指针shared_ptr 首先了解一下基本概念，再看代码，会学的很快 1. shared_ptr的初始化 共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针shared_ptr 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数use_count
2.获取原始指针 对应基础数据类型来说，通过操作智能指针和操作智能指针管理的内存效果是一样的，可以直接完成数据的读写。但是如果共享智能指针管理的是一个对象，那么就需要取出原始内存的地址再操作，可以调用共享智能指针类提供的get()方法得到原始地址
3. 指定删除器 当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。
下面我们来看一下代码如何实现： #pragma once #include &lt;iostream&gt; #include &lt;functional&gt; namespace zy { template&lt;class T&gt; class shared_ptr { public: shared_ptr(T* ptr = nullptr) : _ptr(ptr) , _pcount(ptr ? new int(1) : nullptr) { std::cout &lt;&lt; "shared_ptr(T* ptr)" &lt;&lt; std::endl; } template&lt;class D&gt; shared_ptr(T* ptr = nullptr,D del) : _ptr(ptr) , _pcount(ptr ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d7b99a956da36269185126557524257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78ff6dec64045e0e4f527a8769bf2d6/" rel="bookmark">
			Nginx 从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
2.1 Nginx 概述
2.1.1 Nginx 介绍
2.1.2 Nginx 功能介绍
2.1.3 基础特性
2.1.4 Web 服务相关的功能
2.2 Nginx 架构和进程
2.2.1 Nginx 进程结构
2.2.2 Nginx 进程间通信
2.2.3 Nginx 启动和 HTTP 连接建立
2.2.4 HTTP 处理过程
2.3 Nginx 模块介绍
2.4 Nginx 安装
2.4.1 Nginx版本和安装方式
2.4.2.Nginx 编译安装
2.4.2.1 编译安装 Nginx
2.4.2.2 验证版本及编译参数
2.4.2.3使用安装完成的二进制文件nginx
2.4.2.4 Nginx 启动文件
2.6 平滑升级和回滚
2.6.1 平滑升级流程
2.6.2 平滑升级和回滚案例
平滑升级
回滚
三 Nginx 核心配置详解
3.1 配置文件说明
3.3 http 配置块
3.4 核心配置示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b78ff6dec64045e0e4f527a8769bf2d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56dde2afad554287b6de929e9ab3849/" rel="bookmark">
			机器学习-下采样（全网最详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 相关介绍逻辑回归不平衡数据集下采样逻辑回归与下采样结合 下采样运用1.导入相关包2.数据预处理3.数据下采样与合并4.绘制下采样图像5. 划分数据集6. 模型训练与评估7. 阈值调整与性能评估 总结1.下采样的优点2.下采样的缺点 相关介绍 逻辑回归 逻辑回归是一种预测分类结果的线性模型。它使用逻辑函数（通常是Sigmoid函数）来将线性模型的输出转换为概率。逻辑回归的目标是最小化预测概率和实际标签之间的误差，这通常通过梯度下降等优化算法实现。
不平衡数据集 在许多实际应用中，数据集往往是不平衡的，即某些类别的样本数量远多于其他类别。这种不平衡可能导致模型偏向于多数类，从而影响少数类的预测性能。
下采样 下采样是一种处理不平衡数据集的方法，通过减少多数类的样本来平衡数据集。在下采样过程中，可以从多数类中随机选择样本进行删除，直到多数类和少数类的样本数量达到一个相对平衡的状态。
逻辑回归与下采样结合 将逻辑回归与下采样结合使用，可以处理不平衡数据集上的二分类问题。具体步骤如下：
下采样：从多数类中随机选择样本进行删除，以减少多数类的样本数量，使数据集更加平衡。逻辑回归模型训练：使用下采样后的平衡数据集训练逻辑回归模型。模型评估：使用适当的评估指标（如准确率、召回率、F1分数等）评估模型的性能。 下采样运用 1.导入相关包 import matplotlib.pylab as plt import numpy as np import pandas as pd from pylab import mpl def cm_plot(y, yp): from sklearn.metrics import confusion_matrix import matplotlib.pyplot as plt cm = confusion_matrix(y, yp) plt.matshow(cm, cmap=plt.cm.Blues) plt.colorbar() for x in range(len(cm)): for y in range(len(cm)): plt.annotate(cm[x, y], xy=(y, x), horizontalalignment='center', verticalalignment='center') plt.ylabel('True label') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f56dde2afad554287b6de929e9ab3849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79e468b799df2b61513eb6bbb42f33c1/" rel="bookmark">
			C/C&#43;&#43;控制台贪吃蛇游戏的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀欢迎互三👉：程序猿方梓燚 💎💎
🚀关注博主，后期持续更新系列文章
🚀如果有错误感谢请大家批评指出，及时修改
🚀感谢大家点赞👍收藏⭐评论✍
一、概述 本文对给定的贪吃蛇游戏代码进行详细分析。该游戏使用 C++语言编写，通过控制台界面实现了经典的贪吃蛇游戏玩法，包括登录、注册、游戏介绍、游戏操作和计分等功能。
二、功能模块分析 （一）基础模块 常量定义：
MAX：定义了蛇身最大长度为 100。
UP、DOWN、LEFT、RIGHT：分别代表蛇的上、下、左、右四个方向。
MOVING：表示蛇正在移动的状态。
STOP：表示蛇停止的状态。
全局变量：
hMain_Out：控制台输出句柄。
hMain_In：控制台输入句柄。
NewPos[MAX]：用于存储蛇身新位置的数组。
Food：食物的位置结构体。
Wall：墙壁的范围结构体。
count、grade、level、amount、speed：分别用于记录蛇的移动步数、分数、难度等级、食物数量和移动速度。
isPaused：表示游戏是否暂停的布尔变量。
基础函数：
HideTheCursor()：隐藏光标。通过获取控制台光标信息，将其可见性设置为 FALSE，实现隐藏光标的效果。
basic()：游戏的基础功能模块，包括菜单选择（登录、注册、游戏介绍、退出），根据用户选择调用相应的函数。
显示菜单选项，让用户选择登录、注册、游戏介绍或退出。
根据用户选择调用相应的函数，如login()、registerUser()、gameIntroduction()或out()。
out()：退出游戏，显示感谢信息并逐步退出。
显示感谢信息和退出提示。
使用循环和延迟来模拟逐步退出的效果。
login()：实现用户登录功能，检查用户名和密码是否正确。
提示用户输入用户名和密码。
检查输入是否为空，如果为空则显示错误信息和提示框。
读取用户信息文件，对比输入的用户名和密码是否与文件中的一致。
registerUser()：用户注册功能，将新用户的用户名和密码保存到文件中。
提示用户输入新用户名和密码。
检查输入是否为空，如果为空则显示错误信息和提示框。
打开用户信息文件，将新用户名和密码写入文件。
gameIntroduction()：展示游戏介绍界面，介绍游戏规则，一段时间后自动返回大厅。
显示游戏介绍信息和规则说明。
使用循环和延迟来模拟自动返回大厅的效果。
（二）游戏模块 初始化函数：
Init(Body&amp; b)：初始化蛇的初始位置、长度、方向等，设置控制台输出句柄，创建游戏墙壁和食物，并显示游戏信息。
设置蛇的初始长度为 3，初始方向为向右。
获取控制台输出句柄和输入句柄。
创建游戏墙壁，通过获取控制台屏幕缓冲区信息，确定墙壁的范围，并在边界绘制墙壁。
随机生成食物的位置，确保食物位置在有效范围内且坐标为偶数。
显示游戏信息，包括分数和难度等级。
输出函数：
Print(const Body&amp; b)：在控制台输出蛇的位置，以圆形符号 “●” 表示蛇身。
使用循环遍历蛇身位置数组，设置控制台光标位置，输出蛇身符号。
Print(int x, int y)：在指定坐标位置输出特定字符，用于创建墙壁和食物。
设置控制台光标位置，输出指定字符。
移动函数：
Move(Body&amp; b)：实现蛇的移动逻辑，包括判断是否碰到墙壁或食物，更新蛇的位置，增加蛇身长度等。如果蛇碰到墙壁，则显示游戏结束信息并重新开始游戏；如果碰到食物，则增加分数、蛇身长度和食物数量，重新生成食物。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79e468b799df2b61513eb6bbb42f33c1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/35/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>