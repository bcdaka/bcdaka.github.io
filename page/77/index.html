<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc6bd40805788b5ddf4ada15d1a144e/" rel="bookmark">
			vue 使用 element-plus 中的el-tree 卡顿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Element Plus UI 框架中的 el-tree 组件的示例。el-tree 是一个树形控件，通常用于展示具有层级关系的数据。下面是对代码中关键部分的介绍：
：树形控件的根元素，用于定义树的基本属性和事件。
class=“video-tree”：为树控件添加了一个 CSS 类，可能用于定制样式。
ref=“eltree”：为树控件注册了一个引用名称 eltree，这样可以通过 this.$refs.eltree 在 Vue 实例中访问树的实例方法和数据。
:data=“treeData”：绑定了树的数据源 treeData，这是一个包含树节点的数组。
:props=“{ children: ‘children’, label: ‘label’, hasChildren: ‘hasChildren’ }”：定义了树节点对象的属性配置，指定了子节点、标签和是否有子节点的字段名。
:lazy=“true”：启用了懒加载功能，意味着树节点的子节点将按需加载而不是一次性加载所有节点。
:load=“loadNode”：定义了懒加载时用于加载子节点的函数 loadNode。
@node-click=“handleNodeClick”：为树节点点击事件绑定了处理函数 handleNodeClick。
@node-contextmenu=“handleNodeMenuClick”：为树节点右键菜单事件绑定了处理函数 handleNodeMenuClick。
:accordion=“false”：设置手风琴效果为 false，意味着不会在点击节点时自动折叠其他同级节点。
:highlight-current=“true”：高亮当前选中的节点。
node-key=“id”：指定了树节点的唯一标识字段为 id。
&lt;template #default=“{ node, data }”&gt;：使用作用域插槽自定义树节点的内容，其中 { node, data } 是插槽的参数，包含了当前节点的信息。
：在每个树节点上使用 el-dropdown 组件来创建一个下拉菜单，触发方式为右键点击（trigger=“contextmenu”）。
:ref="‘dropdown’+ node.data.id "：为每个下拉菜单实例注册引用，引用名称与节点的 id 相关联。
@visible-change=“(visible) =&gt; handleVisibleChange(node, visible)”：为下拉菜单的可见性变化事件绑定处理函数 handleVisibleChange。
&lt;template #dropdown&gt;：使用作用域插槽自定义下拉菜单的内容，条件是当前节点等于 currentDrop。
和 ：定义下拉菜单的菜单项，包括“新建”、“删除”、“重命名”和“属性”等操作。
@click=“handleModal”、@click=“deleteNodes”、@click=“renameNode” 和 @click=“handleMessageModal”：分别为下拉菜单项绑定了点击事件处理函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc6bd40805788b5ddf4ada15d1a144e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74190e121d11143604bfc6bc0be2866/" rel="bookmark">
			AI 时代的程序员：如何在变革中保持核心竞争力（万字长文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否曾经想象过，有一天你的代码伙伴可能不再是人类，而是一个能够瞬间生成复杂算法的 AI？这个未来已经悄然来临。随着 ChatGPT、Midjourney 和 Claude 等 AIGC 技术的迅猛发展，AI 辅助编程工具正在重塑我们的工作方式。面对这场技术革命，我们该如何应对？本文将深入探讨 AI 时代程序员的核心竞争力，以及如何在这个快速变化的环境中保持领先地位。
AI 编程助手的崛起 在过去的几年里，我们见证了 AI 技术在编程领域的快速发展。从简单的代码补全工具到能够生成完整函数的 AI 助手，这些技术正在改变我们编写代码的方式。以下是几个引人注目的 AI 编程工具：
GitHub Copilot：由 OpenAI 和 GitHub 合作开发，基于 GPT-3.5 架构，能够根据注释和上下文生成代码片段。
TabNine：利用深度学习技术，提供智能代码补全和建议。
Kite：专注于 Python 开发的 AI 辅助工具，提供实时代码补全和文档查询。
CodeGeeX：清华大学开发的开源 AI 编程助手，支持多种编程语言。
这些工具的出现引发了一个重要问题：AI 是否会取代程序员？答案是否定的。AI 更像是一个强大的助手，而不是替代品。让我们看看 AI 如何改变我们的工作流程。
AI 如何改变编程工作流程 AI 编程助手正在以多种方式改变我们的工作方式：
代码生成：AI 可以根据注释或简短描述生成代码片段，甚至是完整的函数。
智能补全：比传统的自动补全更进一步，AI 可以预测你接下来可能要写的多行代码。
bug 检测和修复：AI 可以分析代码，找出潜在的 bug 并提供修复建议。
代码重构：AI 可以建议更优雅或高效的代码结构。
自然语言转代码：将自然语言描述转换为可执行的代码片段。
让我们通过一个实际的例子来看看 AI 如何改变我们的编码过程：
假设我们需要实现一个函数，用于计算给定数组中的最大子数组和（即 Kadane 算法）。传统的编码方式可能是这样的：
def max_subarray_sum(arr): max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # 测试 arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] print(max_subarray_sum(arr)) # 输出: 6 现在，让我们看看使用 AI 编程助手（如 GitHub Copilot）后的工作流程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e74190e121d11143604bfc6bc0be2866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d36b824f5b79e10fd5b218ceb40d92/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(068)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
271、pandas.Series.dt.dayofyear属性
271-1、语法
271-2、参数
271-3、功能
271-4、返回值
271-5、说明
271-6、用法
271-6-1、数据准备
271-6-2、代码示例
271-6-3、结果输出
272、pandas.Series.dt.days_in_month属性
272-1、语法
272-2、参数
272-3、功能
272-4、返回值
272-5、说明
272-6、用法
272-6-1、数据准备
272-6-2、代码示例
272-6-3、结果输出
273、pandas.Series.dt.quarter属性
273-1、语法
273-2、参数
273-3、功能
273-4、返回值
273-5、说明
273-6、用法
273-6-1、数据准备
273-6-2、代码示例
273-6-3、结果输出
274、pandas.Series.dt.is_month_start属性
274-1、语法
274-2、参数
274-3、功能
274-4、返回值
274-5、说明
274-6、用法
274-6-1、数据准备
274-6-2、代码示例
274-6-3、结果输出
275、pandas.Series.dt.is_month_end属性
275-1、语法
275-2、参数
275-3、功能
275-4、返回值
275-5、说明
275-6、用法
275-6-1、数据准备
275-6-2、代码示例
275-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 271、pandas.Series.dt.dayofyear属性 271-1、语法 # 271、pandas.Series.dt.dayofyear属性 pandas.Series.dt.dayofyear The ordinal day of the year.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92d36b824f5b79e10fd5b218ceb40d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c9c4da29857a32fffd1e61c3414a0a/" rel="bookmark">
			LeetCode //C - 301. Remove Invalid Parentheses
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		301. Remove Invalid Parentheses Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.
Return a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.
Example 1: Input: s = “()())()”
Output: [“(())()”,“()()()”]
Example 2: Input: s = “(a)())()”
Output: [“(a())()”,“(a)()()”]
Example 3: Input: s = “)(”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c9c4da29857a32fffd1e61c3414a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2ef5995218385a02826cce5dfa3427/" rel="bookmark">
			Redis 的6种回收策略（淘汰策略）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redis 的6种回收策略（淘汰策略）详解 1、Redis的六种淘汰策略1. volatile-lru2. volatile-ttl3. volatile-random4. allkeys-lru5. allkeys-random6. no-eviction 2、使用策略规则 💖The Begin💖点点关注，收藏不迷路💖 在Redis中，当内存使用达到上限时，为了保持服务的稳定性和响应速度，Redis提供了多种数据回收（淘汰）策略，以便在必要时释放内存空间。本文将详细介绍Redis的六种主要淘汰策略。
1、Redis的六种淘汰策略 1. volatile-lru 说明：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据进行淘汰。适用场景：适用于数据访问频率差异较大的场景，即部分数据访问频繁，部分数据访问较少。 2. volatile-ttl 说明：从已设置过期时间的数据集中挑选那些即将过期的数据进行淘汰。适用场景：当希望优先淘汰那些即将过期的数据时，可以使用此策略。 3. volatile-random 说明：从已设置过期时间的数据集中随机选择数据进行淘汰。适用场景：当数据集的访问频率没有明显差异，且希望随机淘汰过期数据时，此策略是一个不错的选择。 4. allkeys-lru 说明：从所有数据集（server.db[i].dict）中挑选最近最少使用的数据进行淘汰，不局限于已设置过期时间的数据。适用场景：如果数据访问频率呈现出幂律分布（即大部分数据访问频率低，少数数据访问频率高），此策略非常有效。 5. allkeys-random 说明：从所有数据集中随机选择数据进行淘汰。适用场景：当数据集的访问频率几乎相同时，可以使用此策略。然而，由于Redis的设计初衷是快速存取，因此这种策略在实际应用中并不常见。 6. no-eviction 说明：不进行任何淘汰操作，当内存不足时，Redis会拒绝新的写入请求，并返回错误。适用场景：在某些特定的场景下，如不希望因淘汰数据而影响业务逻辑时，可以使用此策略。但需要注意的是，这可能会导致Redis服务拒绝新的写入请求。 2、使用策略规则 幂律分布场景：如果数据访问频率呈现出幂律分布，即大部分数据访问频率低，少数数据访问频率高，推荐使用allkeys-lru策略。这可以确保那些长时间未被访问的数据被优先淘汰，从而为新的热点数据腾出空间。
平等分布场景：如果数据集的访问频率几乎相同，即所有数据的访问频率都相似，那么可以考虑使用allkeys-random策略。然而，在实际应用中，这种情况较为少见，因为大多数业务场景下的数据访问都会存在一定的差异。
💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3652d845e59f27ddf9c9121980d2d616/" rel="bookmark">
			Flink-DataWorks第一部分：DataWorks（第57天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 1.1 什么是DataWorks
1.2 功能特性
1.2.1 数据集成：全领域数据汇聚
1.2.3 数据建模：智能数据建模
1.2.4 数据分析：即时快速分析
1.2.5 数据质量：全流程的质量监控
1.2.6 数据地图：统一管理，跟踪血缘
1.2.7 数据服务：低成本快速发布API
1.2.8 开放平台：能力全面开放
1.2.9 迁移助手与迁云服务
1.3 各引擎使用说明
1.3.1 什么是MaxCompute
1.3.2 MaxCompute功能特性
1.3.3 DataWorks与MaxCompute的关系
文章目录 系列文章目录前言1.1 什么是DataWorks1.2 功能特性1.2.1 数据集成：全领域数据汇聚1.2.3 数据建模：智能数据建模1.2.4 数据分析：即时快速分析1.2.5 数据质量：全流程的质量监控1.2.6 数据地图：统一管理，跟踪血缘1.2.7 数据服务：低成本快速发布API1.2.8 开放平台：能力全面开放1.2.9 迁移助手与迁云服务 1.3 各引擎使用说明1.3.1 什么是MaxCompute1.3.2 MaxCompute功能特性1.3.3 DataWorks与MaxCompute的关系 前言 本文主要详解了DataWorks基本功能，为第一部分：
由于篇幅过长，分章节进行发布。
后续：
 数据集成的使用
 数据开发流程及操作
 运维中心的使用
1.1 什么是DataWorks DataWorks基于MaxCompute、Hologres、EMR、AnalyticDB、CDP等大数据引擎，为数据仓库、数据湖、湖仓一体等解决方案提供统一的全链路大数据开发治理平台。
产品架构：
DataWorks十多年沉淀数百项核心能力，通过智能数据建模、全域数据集成、高效数据生产、主动数据治理、全面数据安全、数据分析服务六大全链路数据治理的能力，帮助企业治理内部不断上涨的“数据悬河”，释放企业的数据生产力。
发展历史：
从2009年产品立项开始，DataWorks与阿里巴巴业务共同发展，结合MaxCompute、Hologres等大数据计算引擎的能力，跨越多个技术阶段，支撑阿里巴巴数据中台与数据治理建设。目前阿里巴巴集团内DataWorks每天活跃用户数超过5万人，平均每3个人就有1个人使用DataWorks，支持300多个数据应用，服务100多个阿里巴巴集团事业部。
2015年DataWorks正式上云，将多年沉淀的大数据建设方法论产品化输出，服务阿里云上客户，通过不断迭代的产品能力，DataWorks正在与各行各业的客户与合作伙伴一起，通过全链路数据治理，管得好数据、用得好数据，让数据从低质低效向高质高效流动。
1.2 功能特性 1.2.1 数据集成：全领域数据汇聚 DataWorks的数据集成功能模块是稳定高效、弹性伸缩的数据同步平台，致力于提供复杂网络环境下、丰富的异构数据源之间高速稳定的数据移动及同步能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3652d845e59f27ddf9c9121980d2d616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c75d371d0d7eb83e42858de7ed62cf3/" rel="bookmark">
			C语言 ——深入理解指针（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 数组名的理解2. 二级指针3. 指针数组4. 字符指针变量5. 数组指针变量6. 函数指针变量7. 函数指针数组 1. 数组名的理解 这里我们使用 &amp;arr[0] 的方式拿到了数组第一个元素的地址，但是其实数组名本来就是地址，而且是数组首元素的地址，我们来做个测试。
#include &lt;stdio.h&gt; int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; printf("&amp;arr[0] = %p\n", &amp;arr[0]); printf("arr = %p\n", arr); return 0; } 输出结果：
我们发现数组名和数组首元素的地址打印出的结果一模一样，数组名就是数组首元素(第一个元素)的地址。
数组名如果是数组首元素的地址，那下面的代码怎么理解呢？
#include &lt;stdio.h&gt; int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; printf("%d\n", sizeof(arr)); return 0; } 输出的结果是：40，如果arr是数组首元素的地址，那输出应该的应该是4/8才对。
其实数组名就是数组首元素(第一个元素)的地址是对的，但是有两个例外：
sizeof(数组名)，sizeof中单独放数组名，这里的数组名表示整个数组，计算的是整个数组的大小，
单位是字节&amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址（整个数组的地址和数组首元素
的地址是有区别的） 除此之外，任何地方使用数组名，数组名都表示首元素的地址。
2. 二级指针 指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？
这就是二级指针。
对于二级指针的运算有：
*ppa 通过对ppa中的地址进行解引用，这样找到的是pa ， *ppa 其实访问的就是pa .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c75d371d0d7eb83e42858de7ed62cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0841ca34203c20202488659ab92b71e5/" rel="bookmark">
			在亚马逊云科技AWS上利用PEFT和RLHF高效微调AI大模型减少有害回复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 小李哥将继续每天介绍一个基于亚马逊云科技AWS云计算平台的全球前沿AI技术解决方案，帮助大家快速了解国际上最热门的云计算平台亚马逊云科技AWS AI最佳实践，并应用到自己的日常工作里。
本次我将介绍如何用亚马逊云科技的AI模型训练服务Amazon SageMaker和PEFT、RLHF框架高效微调AI大模型FLAN-T5-BASE，减少大模型回复过程中的潜在有害内容。我将带领大家手把手通过一行一行的代码学会AI模型的微调，0基础学会AI核心技能。本架构设计还包括了与用户交互的前后端应用，全部采用了云原生Serverless架构，提供可扩展和安全的AI应用解决方案。本方案架构图如下
项目开发背景知识 参数高效微调（PEFT）和基于人类反馈的强化学习（RLHF）都是我们在 AI 大模型微调中使用的常见方法。PEFT 通过选择性地调整模型的一部分参数，提高了微调过程的效率和资源利用率，而 RLHF 则通过引入人类反馈，优化模型的表现，减少偏见和有害暗示。这两种方法各有优势，可以互补使用，以实现更高效、更可靠的机器学习模型微调，满足不同应用场景的需求。
参数高效微调（PEFT） 参数高效微调（Parameter-Efficient Fine-Tuning, PEFT）是一种在微调预训练模型时只调整部分参数的方法。与传统的全参数微调相比，PEFT 专注于模型中的一小部分参数，这不仅可以减少计算资源的消耗，还能提高微调过程的效率。PEFT 方法通过选择性地更新模型参数，保持了模型的整体结构和大部分预训练信息，从而在保持高性能的同时，显著减少训练时间和资源消耗。这种方法特别适用于资源有限的开发环境，同时也能在大规模模型上取得优异的效果。
基于人类反馈的强化学习（RLHF） 基于人类反馈的强化学习（Reinforcement Learning from Human Feedback, RLHF）是一种结合人类反馈来优化机器学习模型的算法。RLHF 通过引入人类在训练过程中的评价和反馈，指导模型进行自我调整和优化。具体而言，RLHF 利用人类标注的奖励信号来更新模型的策略，使其更符合预期的行为和输出。这种方法可以显著提升模型的表现，尤其在处理涉及伦理和偏见的问题时，RLHF 能够通过人类的反馈来减少有害暗示和不良行为，提高模型的安全性和可靠性。RLHF 在对话系统、推荐系统等应用中表现出色，能够有效提高用户体验和模型的实际应用价值。
本方案包括的内容： 使用 Amazon SageMaker Studio 微调基础模型。 使用参数高效微调（PEFT）在一部分参数上进行微调，提升微调效率降低成本。 使用基于人类反馈的强化学习（RLHF）算法优化大语言模型。 分析微调对减少有害回复的效果。 将微调结果上传到 Amazon DynamoDB 表中保存。 项目搭建具体步骤： 1. 首先我们打开亚马逊云科技控制台，打开SageMaker服务主页，进入到我们的SageMaker Studio中。
2. 接下来我们创建一个新的Jupyter Notebook，开始我们的模型微调。首先我们安装必要的依赖
%%capture %pip install torch==2.0.1 torchdata %pip install transformers==4.28.1 %pip install datasets==2.17.0 %pip install accelerate==0.16.0 %pip install evaluate==0.4.0 %pip install trl==0.7.1 %pip install rouge_score==0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0841ca34203c20202488659ab92b71e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc35d9890869ff09447b9687432fa21/" rel="bookmark">
			【Linux】权限理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. Linux权限的概念2.文件类型和访问权限2.1 文件访问者的分类2.2 文件属性 3. 文件权限值的表示方法4. 文件访问权限的相关设置方法4.1 chmod----设置文件的访问权限4.2 chown----修改文件的拥有者/所属组4.3 chgrp----修改文件或目录的所属组4.4 umask----查看或修改文件掩码4.4.1 起始权限问题 5. 目录的权限5.1 粘滞位 1. Linux权限的概念 Linux下有两种用户：超级用户（root）、普通用户。
超级用户：可以再linux系统下做任何事情，不受限制普通用户：在linux下做有限的事情。超级用户的命令提示符是“#”，普通用户的命令提示符是“$”。 普通用户和超级用户 互转的方法：
指令的提权（针对普通用户）
使用：sudo command
注意：我们用adduser新建的用户，没有颁发执行shudo，因为系统不信任你，除非未来将普通用户添加到系统的信任白名单中。
2.文件类型和访问权限 权限和两件事物有关：
身份，事物的属性（文件属性）
2.1 文件访问者的分类 文件和文件目录的拥有者：u—User文件和文件目录的所有者所在的组（所属组）的用户：g—Group其它用户：除了拥有者和所属组就是o—Others 当一个用户同时为拥有者和所属组时，该用户的权限为拥有者的权限，因为在进行认证时，只能选择一个角色进行认证。
2.2 文件属性 文件类型
d：文件夹-：普通文件：文本、可执行程序，库l：软链接（类似Windows的快捷方式）b：块设备文件（例如硬盘、光驱等）p：管道文件：用来通信的c：字符设备文件（例如屏幕等串口设备）s：套接口文件 文件类型的后缀：linux系统文件后缀没有直接意义，但是不代表linux系统上运行的其他软件不需要后缀（例如gcc这一款编译器软件）
3. 文件权限值的表示方法 a)字符表示方法
b)8进制数值表示方法
4. 文件访问权限的相关设置方法 4.1 chmod----设置文件的访问权限 chmod
功能：设置文件的访问权限
格式：chmod [参数] 权限 文件名
使用者：文件的拥有者和root用户
常用选项：
-R ： 递归修改目录文件的权限 chmod设置权限的格式：
chmod 用户符号+/-/=权限代号 文件chmod 三位八进制数 文件 +:向权限范围增加权限代号所表示的权限-:向权限范围取消权限代号所表示的权限=:向权限范围赋予权限代号所表示的权限用户符号： u：拥有者g：拥有者同组o：其它用户a：所有用户 实例：
chmod a=x /home/abc.txtchmod a-wrx /home/abc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc35d9890869ff09447b9687432fa21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e48c41c06dfba4e75f256d1466300e5/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(067)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
266、pandas.Series.dt.second属性
266-1、语法
266-2、参数
266-3、功能
266-4、返回值
266-5、说明
266-6、用法
266-6-1、数据准备
266-6-2、代码示例
266-6-3、结果输出
267、pandas.Series.dt.microsecond属性
267-1、语法
267-2、参数
267-3、功能
267-4、返回值
267-5、说明
267-6、用法
267-6-1、数据准备
267-6-2、代码示例
267-6-3、结果输出
268、pandas.Series.dt.nanosecond属性
268-1、语法
268-2、参数
268-3、功能
268-4、返回值
268-5、说明
268-6、用法
268-6-1、数据准备
268-6-2、代码示例
268-6-3、结果输出
269、pandas.Series.dt.dayofweek属性
269-1、语法
269-2、参数
269-3、功能
269-4、返回值
269-5、说明
269-6、用法
269-6-1、数据准备
269-6-2、代码示例
269-6-3、结果输出
270、pandas.Series.dt.weekday属性
270-1、语法
270-2、参数
270-3、功能
270-4、返回值
270-5、说明
270-6、用法
270-6-1、数据准备
270-6-2、代码示例
270-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 266、pandas.Series.dt.second属性 266-1、语法 # 266、pandas.Series.dt.second属性 pandas.Series.dt.second The seconds of the datetime. 266-2、参数 无
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e48c41c06dfba4e75f256d1466300e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec64827fa42187d364d16540f6d9c30/" rel="bookmark">
			【线性代数】【二】2.3 矩阵的列空间与线性方程组的解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、矩阵的列空间二、线性方程组的解2.1 矩阵列空间维数等于列向量维数2.1 矩阵列空间维数小于列向量维数 总结 前言 基于上篇所学习的极大线性无关组与张成空间维数的有关知识，我们回到矩阵中，重新省视一下线性方程组的求解与向量空间的关系。此外，在本系列笔记1.6中我们从矩阵可逆性分析了线性方程组的解的性质，这次，我们从向量空间的角度再次分析其解的性质。
一、矩阵的列空间 所谓矩阵的列空间，即由矩阵 A \bm{A} A的所有列向量张成的向量空间。因此，我们也可以得到一个性质，即矩阵列空间中的任意一个向量，均可表示为该矩阵列向量的线性组合。
根据上篇极大线性无关组与张成空间维数的性质，我们可知矩阵列空间的维数，等于其列向量的极大线性无关组的向量个数。例如对于如下矩阵：
A = ( a 1 a 2 a 3 ) = ( 1 0 1 0 1 1 0 0 0 ) \mathbf{A} = \left( \begin{array}{ccc} \bm{a}_1&amp; \bm{a}_2&amp;\bm{a}_3 \end{array} \right)= \left( \begin{array}{ccc} 1 &amp; 0 &amp;1\\ 0&amp;1&amp;1\\ 0&amp;0&amp;0\\ \end{array} \right) A=(a1​​a2​​a3​​)= ​100​010​110​ ​
其列向量的一个极大线性无关组可为 { [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] } \{[1,0,0],[0,1,0]\} {[1,0,0],[0,1,0]}，所以该矩阵的列空间维数为2，这个列空间是 R 3 R^3 R3的一个子空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec64827fa42187d364d16540f6d9c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796ddb15e3ac707aa5500471d5be0d69/" rel="bookmark">
			自动生成数据：Navicat 16 让数据测试更高效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Navicat是什么？二、Navicat 16 新功能1. 自动生成数据2. 改进的用户界面3. 云同步 三、 安装指南Windows 版安装macOS 版安装Linux 版安装 四、使用示例：自动生成数据1. 创建连接2. 选择表3. 打开数据生成器4. 设置数据规则5. 生成数据 总结 前言 数据库管理在现代应用开发中扮演着至关重要的角色。而 Navicat 作为一款功能强大的数据库管理工具，提供了简洁易用的用户界面和强大的功能，深受开发者和数据库管理员的喜爱。本文将详细介绍 Navicat 16 的新功能，特别是自动生成数据的功能，并提供完整的安装指南，帮助你快速上手使用这款工具。
一、Navicat是什么？ Navicat 是一款跨平台的数据库管理工具，支持 MySQL、MariaDB、SQL Server、SQLite、Oracle、PostgreSQL、Redis 等多种数据库。它为用户提供了直观的图形界面和丰富的功能，涵盖数据库开发、管理、数据迁移和数据同步等多个方面。通过 Navicat，用户可以轻松地执行复杂的 SQL 查询、创建和编辑数据库对象、导入导出数据，以及生成报表。
二、Navicat 16 新功能 1. 自动生成数据 Navicat 16 版本新增了自动生成数据的功能，这一功能对于开发和测试非常有用。用户可以根据预定义的规则生成虚拟数据，用于测试和开发。这不仅节省了手动输入数据的时间，还可以模拟多种数据场景，帮助测试人员更全面地测试应用程序的性能和稳定性。
自动生成数据功能的特点：
自定义数据类型：支持生成文本、数字、日期、布尔值等多种类型的数据。灵活的数据规则：可以设置数据的长度、范围、格式等，确保生成的数据符合特定需求。多表数据生成：支持同时为多个表生成数据，自动处理外键关系。 2. 改进的用户界面 Navicat 16 在界面设计上进行了优化，提供了更现代、更易用的操作体验。新的 UI 设计使得用户可以更加高效地浏览和管理数据库对象，同时支持深色模式，更加适合长时间工作。
3. 云同步 Navicat 16 支持云同步功能，用户可以将连接、查询、模型等数据同步到云端，在不同设备之间无缝切换。通过 Navicat Cloud，用户可以随时随地访问和管理数据库资源，提高工作效率。
三、 安装指南 有想使用破解的小伙伴可以移步至该文章🚪进行破解
Windows 版安装 下载安装程序
访问 Navicat 官方网站🚪，下载适用于 Windows 的安装包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/796ddb15e3ac707aa5500471d5be0d69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18442dac8c737afa461435872591df64/" rel="bookmark">
			【AI 大模型】RAG 检索增强生成 ① ( 大模型的相关问题描述 - 幻觉、时效性、数据安全 | RAG 检索增强生成 | RAG 关键组件 | LLM &#43; RAG 的运行流程 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、大模型的相关问题描述1、大模型 " 幻觉 " 问题描述2、大模型 " 时效性 " 问题描述3、大模型 " 数据安全 " 问题描述 二、RAG 检索增强生成1、RAG 引入2、RAG 关键组件3、LLM + RAG 的运行流程 一、大模型的相关问题描述 1、大模型 " 幻觉 " 问题描述 AI 大模型 不知道 ① 实时性的信息 或 ② 特定领域的私有信息 , 如果在私有场景中向 大模型 提问 相关问题 , 大模型训练时没有接触过这些知识 , 就会随机生成错误输出 ;
ChatGPT 产生 " 幻觉 " 的 案例 ,
目前 ChatGPT 免费版本 使用的是 ChatGPT 4o mini 模型 , 其 训练数据时 2022 年初收集的 , 之后的实时信息是没有的 , 向 ChatGPT 大模型 提问 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18442dac8c737afa461435872591df64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd7f956c37c1a99f1fa9ba15d02a2b3/" rel="bookmark">
			【Java数据结构】---初始数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观学习，乐观生活，才能不断前进啊！！！
我的主页：optimistic_chen
我的专栏：c语言 ，Java
欢迎大家访问~
创作不易，大佬们点赞鼓励下吧~
前言 从今天开始我们就要学习Java的数据据结构部分，根据前面Java语法的基础上，更加深入的了解算法的基本知识。
文章目录 前言什么是数据结构？集合框架容器具体的数据结构 如何学好数据结构？时间复杂度和空间复杂度时间复杂度大O的渐进表示法推导大O阶方法 空间复杂度 完结 什么是数据结构？ 数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的
集合。
集合框架 Java 集合框架 Java Collection Framework ，又被称为容器 container ，是定义在 java.util 包下的一组接口 interfaces和其实现类 classes
Java当中已经实现好的一些集合类（数据结构）
我们总体的学习框架如下图所示：
容器具体的数据结构 Collection：是一个接口，包含了大部分容器常用的一些方法List：是一个接口，规范了ArrayList 和 LinkedList中要实现的方法
ArrayList：实现了List接口，底层为动态类型顺序表
LinkedList：实现了List接口，底层为双向链表Stack：底层是栈，栈是一种特殊的顺序表Queue：底层是队列，队列是一种特殊的顺序表Deque：是一个接口Set：集合，是一个接口，里面放置的是K模型
HashSet：底层为哈希桶，查询的时间复杂度为O(1)
TreeSet：底层为红黑树，查询的时间复杂度为O( ),关于key有序的Map：映射，里面存储的是K-V模型的键值对
HashMap：底层为哈希桶，查询时间复杂度为O(1)
TreeMap：底层为红黑树，查询的时间复杂度为O( )，关于key有序 如何学好数据结构？ 首先要有代码量，只有写的代码足够多才慢慢熟悉数据结构的基本要领；其次，学习中要时刻记得画图，做题前先画图是一个“小白”的必经之路；之后学习的过程就是总结的过程，每学到一个章节要知道总结，最后才会变成自己的东西；最后要大量刷题，我推荐两个刷题的网站力扣（LeetCode），牛客建议由易到难，由简单到复杂，慢慢来，刚开始一定慢。
时间复杂度和空间复杂度 解决一个问题有多种算法，那么就一定有最高效的算法，这就是算法效率：第一种是时间效率，第二种是空间效率。 但是实际上，只要能解决问题的算法都是好算法。
时间效率（时间复杂度）：时间复杂度主要衡量的是一个算法的运行速度
空间效率（空间复杂度）：空间复杂度主要衡量一个算法所需要的额外空间
时间复杂度 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个数学函数，它定量描述了该算法的运行时间.一个算
法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
大O的渐进表示法 大O符号：是用于描述函数渐进行为的数学符号。
void func1(int N){ int count = 0; for (int i = 0; i &lt; N ; i++) { for (int j = 0; j &lt; N ; j++) { count++; } } for (int k = 0; k &lt; 2 * N ; k++) { count++; } int M = 10; while ((M--) &gt; 0) { count++; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cd7f956c37c1a99f1fa9ba15d02a2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de5346f974bab7a5efd8b82c9578267/" rel="bookmark">
			阿里云&#43;DDNS-GO&#43;宝塔反向代理内网穿透后使用域名无端口访问内网保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章 需求的简介和应用功能的概述
1.1 简介 由于公司没有允许员工使用云服务，同时又需要远程存储家中监控摄像头的数据，笔者决定购买一台NAS设备来解决生活和工作上的问题。在经过多方考虑后，笔者选择了绿联NAS，因为它非常适合初学者，而且自带docker，可扩展性非常高。
但是，想要玩转NAS，必须实现内网穿透。如果不进行内网穿透，那么即使购买了NAS，也无法实现远程访问。由于笔者家里的宽带没有公网IP，所以只能采用DDNS-TO进行内网穿透，但它还是存在一些局限性的，例如连接端口数量上限、带宽容量上限等。此外，如果安装应用程序，还需要在DDNS-TO上添加映射，操作较为繁琐。
然而，DDNS-TO也有其优点，例如支持HTTPS方式访问，安装配置简单等。为了替代DDNS-TO的缺陷并保留其优点，笔者通过学习，决定使用 DDNS-GO、阿里云、NginxWebUI、cloudflare组合来实现我的需求。
1.2 应用功能概述
为了替换DDNS-TO的缺点，笔者决定使用DDNS-GO、阿里云、NginxWebUI下面简单概述这些工具各自的功能和解决的问题。
1.2.1 阿里云
阿里云提供了域名服务，可以申请短期免费或长期付费的域名，并且没有连接端口数量上限和带宽容量上限的限制。此外，用户还可以进行个性化自定义，非常方便。同时，阿里云还提供了API密钥（Accesskey id和Accesskey Secret）以及家庭局域网动态公网IP地址与域名的绑定，在NAS上安装应用程序时，只需要记住应用映射的域名即可。
1.2.2 DDNS-GO
DDNS-GO是一款非常实用的内网穿透工具，仅限于无固定IPV4地址和IPV6地址，但有真实动态IPV4地址的内网环境。如果用户拥有固定IPV6或固定IPV4中的其中一种公网IP地址，则不必关注该工具，也无需安装。需要注意的是，获取公网IP需要将光猫改成桥接，而光猫如何改桥接及光猫开通IPV6因运营商而异，用户需要自行百度或咨询运营商的工作人员。使用DDNS-GO做内网穿透前，必须要确定公网IPV4地址是否真实有效，否则可能会出现问题。
1.2.3 NginxWebUI
NginxWebUI是一款管理Nginx服务器的Web界面，支持在Nginx中添加和删除域名、配置文件等操作。它可以通过docker安装在绿联NAS上，方便用户进行管理。
2.访问你的路由器，找到上网设置，查看你路由器上的公网IP 正常路由器地址：192.168.2.1 192.168.0.1 192.168.31.1
3.如果以上两个公网IP是一致的，这意味着公网动态IPV4地址是真实有效的。如果不一致，则说明当前没有公网IP地址。若出现后者，建议直接联系宽带运营商开通动态IPV4或提供固定IPV6地址。如果这些方式都无法满足需求，可以考虑更换宽带运营商或使用其他内网穿透方式（例如DDNS-TO）。
1.2.3 NginxWebUI
NginxWebUI是一款非常实用的工具，它可以实现反向代理，从而访问内网NAS上安装的应用程序，在访问内网应用之前，需要先经过Nginx进行代理。此外，NginxWebUI还支持根据域名生成免费的SSL证书，并将http请求转化为https请求。
1.2.4 cloudflare
cloudflare是一个全球性的CDN网络，提供了很多有用的功能，例如网站加速、防火墙等。通过将自己的域名指向cloudflare，用户可以隐藏NAS真实的IP地址，避免黑客攻击。同时，它还能够转发URL路径重定向，使用户只需使用域名访问而不用带上特定的端口号。
第2章 各应用的安装配置
2.1 阿里云的注册和域名申请
2.1.1 注册
为了使用阿里云提供的服务，首先需要注册一个账户。如果您已经拥有阿里云账户，则可以直接跳过这一步。在访问阿里云的官方网站后，点击“登录/注册”，按照指示填写信息并完成注册。
2.1.2 域名申请
在注册成功之后，可以开始申请域名。这里推荐申请一个.cn或.com的域名，因为这两种域名是最通用的。在阿里云的控制台中，选择“域名”选项卡，然后按照页面上的提示申请域名。当您完成付款后，就可以获得您自己的域名了。
2.2 DDNS-GO的配置
2.2.1 安装DDNS-GO
DDNS-GO可以通过绿联NAS上的docker进行安装，只需在终端中输入相应的命令即可。
2.2.2 DDNS-GO的配置
在安装完成后，需要进行一些配置工作。首先，在阿里云的控制台中创建一对API密钥，并将其保存起来。然后，在DDNS-GO的设置中输入相关信息，例如域名、密钥等。最后，启动DDNS-GO，测试与阿里云的连接是否正常。
阿里云访问地址：https://www.aliyun.com，支持多种注册方式，自行注册。
2.1.2 申请阿里云 API 的密钥
A.注册并登录阿里云后，双击网站首页右上角的“控制台“并进入。
B.设置权限模式
C.在”AccessKey管理”界面创建AccessKey
D.AccessKey ID和AccessKey Secret申请成功后复制到本地保存，后面安装完DDNS-GO后做动态域名绑定时要用到
2.1.3 注册域名 (有域名的可略过，没域名的买个最便宜的后缀即可)
A.在阿里云首页双击搜索图标，选择域名搜索
使用域名需要进行实名认证，具体操作请根据网站提示完成。注册时选择个人使用即可，不需要进行备案。
2.1.4 添加二级域名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de5346f974bab7a5efd8b82c9578267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680c8d5e429ac2accdb4b79e2141b688/" rel="bookmark">
			Django与数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
创建项目app
路由子表
数据库
创建数据库
什么是ORM
定义数据库表
Django Admin 管理数据
过滤条件
代码直接生成HTML
使用模板
前后端分离架构
对资源的增删改查处理
列出客户
添加客户
临时取消 CSRF 校验
修改客户信息
删除客户
Django中ORM的处理
数据模型的配置
字段设置
字段参数
数据更新的实现
创建项目app Django中的一个app就是项目里面的一个应用的意思，一个项目包含多个app,一个app通常就是一个相对独立的模块，实现相对独立的功能。比如我们可以把系统中的管理员管理的功能放在一个名为mgr的app里面，把销售人员的操作实现在另一个名为sales的app里面。
Django中创建app可以通过执行命令，创建一个app目录，并在里面自动创建app常用的文件。
进入项目根目录，执行以下命令：
python manage.py startapp sales 这样就会创建一个目录名为 sales， 对应 一个名为 sales 的app，里面包含了如下自动生成的文件： migrations __init__.py admin.py apps.py models.py tests.py views.py 路由子表 一个请求对应一个处理函数，项目较大时，请求的url会特别多，我们可以将不同的路由记录按照功能分拆到不同的url路由子表中。
数据库 后端开发基本需要操作数据，包括数据的存储、查询、修改、删除。通常，这些都是通过数据来完成，目前业界最广泛使用的数据库还是：关系型数据库。
关系型数据库系统，常用的开源数据库有mysql和postgresql.
创建数据库 项目中数据库的配置在settings.py中。
DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', # 数据库类型 'NAME': 'core', # 所使⽤的数据库的名字 'USER': 'root', # 数据库服务器的⽤户 'PASSWORD': 'xxxxxx', # 密码 'HOST': '127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/680c8d5e429ac2accdb4b79e2141b688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41588d84a420f1ed6639abf09391f05/" rel="bookmark">
			JavaDS —— AVL树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文章将介绍 AVL 树的概念，重点介绍AVL 树的插入代码是如何实现的，如果大家对 AVL 树的删除（还是和二叉搜索树一样使用的是替换删除法，然后需要判断是否进行旋转调整）感兴趣的话，可以自行去翻阅其他资料~~
概念 回顾二叉搜索树 之前我们就了解到二叉搜索树中序遍历的时候数据是有序的，这是由于二分搜索树具有以下性质：
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
它的左右子树也分别为二叉搜索树
最好的搜索时间复杂度为 O(logN)，但是如果插入的数据是有序或者逆序的时候，二叉搜索树就会变成一颗单分支的二叉树，搜索的时间复杂度也最差，为 O(N)
那么能不能让二叉搜索树在插入结点的时候就能始终保持平衡，也就是保持一颗饱满的二叉树形态呢？
这就是我们要学习的 AVL 树
AVL 树 两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年 发明了一种解决上述二叉搜索树存在的问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。
一棵AVL树具有以下性质：
AVL 树同时具有二叉搜索树的性质
它的左右子树都是AVL树
左右子树高度之差(简称平衡因子)的绝对值不超过 1 (-1、0、1)，即始终保持高度平衡
如果一棵二叉搜索树是高度平衡的，它就是AVL树。
平衡因子 平衡因子就是左右子树高度之差
这里我定义平衡因子等于右子树高度减去左子树的高度
以下图为例：
A 结点右子树高度等于左子树高度，平衡因子为0
B 结点右子树高度减左子树高度等于 -1，平衡因子为 -1
C 结点右子树高度减左子树高度等于 1，平衡因子为 1
D 结点右子树高度等于左子树高度，平衡因子为0
E 结点右子树高度等于左子树高度，平衡因子为0
结点定义 和普通的树结点一样，具有左引用，右引用，数据val，以及构造方法
但是 AVL 树还要再加一个平衡因子（Balance Factor）简写为 bf
还有一个双亲结点的引用（和平衡因子一样，插入的时候要用到）
public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode parent; int bf; //平衡因子 右子树高度减去左子树高度 public TreeNode(int val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41588d84a420f1ed6639abf09391f05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19cc9d00e7e4a75a59df1ca5a6228520/" rel="bookmark">
			评分超越MJ和SD？揭秘FLUX.1 AI绘画模型，实例评测不容错过（附体验地址）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过4个月的沉寂，Stable Diffusion的原团队再次出发，他们推出了性能卓越的开源文本到图像模型FLUX.1，其表现在多个方面超越了Midjourney和DALL-E。
今年 3 月底，Stability AI 遭遇了资金和运营上的压力，内部动荡，联合创始人遭到解职，而关键团队成员 Robin 也决定退出。
经过 4 个月的时间，Robin 宣布了新的创业计划，成立了 Black Forest Labs。8 月 1 日，Black Forest Labs 发布了他们的 FLUX.1 图像生成模型。
官方博客宣称，该模型在图像细节呈现、提示词的遵循度、风格多样性以及场景复杂性方面均达到了行业领先水平。其官方网站上公布的 ELO 评分显示，FLUX.1 已经超过了 Midjourney-V6.0 和 Stable Diffusion3-Ultra 的评分。
一、FLUX.1 3 个版本 介绍 版本名称说明获取方式FLUX.1 [pro][专业版]提供最先进的性能图像生成，具有顶级的即时跟踪、视觉质量、图像细节和输出多样性。通过 Black Forest Labs 的 API 注册 FLUX.1 [pro]申请FLUX.1 [dev] [开发版]一种开放权重、指导提炼的模型，适用于非商业应用可在开源网站下载FLUX.1 [schnell] [快速]可以商用的开源模型，为本地开发和个人使用量身定制的完全开源，可在 Comfyui 中使用 此外，FLUX团队已经开始着手训练DiT视频生成模型。他们的官方网站上展示了相关演示视频，这些视频在运动幅度、稳定性以及物理效果方面表现出色。
二**、FLUX 优势说明** 看评测说得很厉害的样子，那么FLUX 到底厉害在哪，我们来看看优势说明。
提升的图像品质：FLUX 能够以更高的分辨率生成令人印象深刻的视觉效果，并支持各种自定义分辨率比例的直接绘图输出。在美学评分ELO上，FLUX的得分在很多方面都超过了SD3和MJ6。
先进的人体解剖学和逼真度：FLUX 在直接生成完美手指和脚趾的绘图方面取得了近乎完美的成果，显著降低了多指或畸形出现的概率。直白点说，就是画的手、脚比较不会变形，比如多手指，少手指等。
精确的英文文字渲染和复杂提示处理：FLUX 能够精确渲染英文文字，并且能够准确遵循复杂的提示语，展现出卓越的处理能力。
对于小白理解，简化来说就是生成的图片效果更好，分辨率更好，生成的人物手脚不会那么容易蹦。
三、体验测试 那么说了那么多，效果怎么样呢？
行者使用的是仙宫云平台的FLUX工作流来进行评测。（本地没有24G显存，肝不起）
接下来我从个人像、写实、科幻、文字嵌入、风景、动物、二次元等多个风格来进行出图测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19cc9d00e7e4a75a59df1ca5a6228520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514b8ff2dc4017fc6b97862b6c993537/" rel="bookmark">
			C语言 ——— 学习并使用 strerror 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
学习strerror函数
使用strerror函数 学习strerror函数 库函数在执行的时候，发生了错误，会将这个错误码存放在errno这个变量中，而errno是C语言提供的一个全局变量
而strerror函数是一个错误报告函数，可以将对应的错误码转换成对应的错误信息
打印0~9的错误码所对应的错误消息：
使用strerror函数 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { // 打开当前路径的 "data.txt" 文件，并且以读的形式打开 FILE* pf = fopen("data.txt", "r"); // 当前路径没有 "data.txt" 文件时，会打开失败，并返回一个NULL if (pf == NULL) { // 打印错误信息 printf("%s\n", strerror(errno)); return -1; } return 0; } 代码验证：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b280a68034451f6bc38d978def6131d0/" rel="bookmark">
			Java中的Map（如果想知道Java中有关Map的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在Java编程语言中，集合框架（Collection Framework）提供了一系列用于存储和操作数据的接口和类。其中，Map和Set是两个非常重要的接口，分别用于存储键值对和无重复元素的集合。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.Map概念简介
（1）Map的定义
（2）Map.Entry的说明,&gt;
（3）Map类在Java集合类中的关系
2.Map接口中常用API
3.Map的常见实现类
（1）HashMap
（2）LinkedHashMap
（3）TreeMap
4.Map的实际案例
5.总结
1.Map概念简介 （1）Map的定义 在开始学习如何使用Java中的Map类之前，先让我们了解一下什么是Java中的Map类：
——Map类是Java集合框架中的一部分，用于存储键值对（key-value pairs）。每个键（key）对应一个值（value），键是唯一的，但值可以重复。常见的Map实现类包括HashMap、LinkedHashMap、TreeMap。
这里我们也附上官方文档中对Map的解释：Map (Java Platform SE 8 )
我相信读者如果初次学习Java中的Map类的话，可能对上面对Java中Map类的解释不能很好的理解，不过没有关系，读者继续向下阅读即可。
（2）Map.Entry&lt;K, V&gt;的说明 对于Map这种数据结构而言，其底层可以简单的理解为是由一个个节点进行构成的的树，而Map.Entry&lt;K, V&gt;就是其每一个节点。
对于Map.Entry&lt;K, V&gt;来说，其是Map内部实现的用来存放&lt;key, value&gt;键值对映射关系的内部类，该内部类中主要提供了&lt;key, value&gt;的获取，value的设置以及Key的比较方式：
方法解释K getKey()返回 entry 中的 keyV getValue()返回 entry 中的 valueV setValue(V value)将键值对中的value替换为指定value （3）Map类在Java集合类中的关系 了解了Map的定义与Map.Entry&lt;K, V&gt;之后，在让我们看看Map在Java集合类中的关系，如下图：
从图中我们可以看出，Map类不在实现Collection接口，而是实现Map自身接口。
——通关上边的学习了解之后，这样我们就大致的了解了Java中的Map究竟是什么东西了。
2.Map接口中常用API Map接口提供了一些基本的方法，用于操作键值对。以下是Map接口的主要方法：
方法解释V get(Object key)返回 key 对应的 valueV getOrDefault(Object key, V defaultValue)返回 key 对应的 value，key 不存在，返回默认值V put(K key, V value)设置 key 对应的 valueV remove(Object key)删除 key 对应的映射关系Set&lt;K&gt; keySet()返回所有 key 的不重复集合Collection&lt;V&gt; values()返回所有 value 的可重复集合Set&lt;Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b280a68034451f6bc38d978def6131d0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/76/">«</a>
	<span class="pagination__item pagination__item--current">77/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/78/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>