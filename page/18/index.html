<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6889d70cdf8497309a113d49b3260635/" rel="bookmark">
			Spark-RDD迭代器管道计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、上下文 《Spark-Task启动流程》中讲到我们提交Stage是传入的是这个Stage最后一个RDD，当Task中触发ShuffleWriter、返回Driver数据或者写入Hadoop文件系统时才触发这个RDD调用它的iterator()，下面我们就来看下RDD.iterator()背后的故事。
二、RDD中的iterator 我们先来看下rdd.iterator()以及后面一些列的调用
final def iterator(split: Partition, context: TaskContext): Iterator[T] = { //如果该rdd是被持久化的那么直接得到它或者根据血缘关系计算它，并返回，到这就终止了，可以直接从这往后计算了 if (storageLevel != StorageLevel.NONE) { getOrCompute(split, context) } else { //调用compute()或者从Checkpoint读取数据 computeOrReadCheckpoint(split, context) } } private[spark] def computeOrReadCheckpoint(split: Partition, context: TaskContext): Iterator[T] = { //如果该RDD是Checkpointed那么直接返回对应分区的迭代器，直接从这里开始计算 if (isCheckpointedAndMaterialized) { firstParent[T].iterator(split, context) } else { compute(split, context) } } //由子类实现，用于计算给定的分区，下面我们看下重要的几个子类 def compute(split: Partition, context: TaskContext): Iterator[T] 三、RDD子类中的compute MapPartitionsRDD //一个RDD调用 map() flatMap() filter() glom() mapPartitions() 都会返回一个 MapPartitionsRDD 且把对应的处理函数传进去 //这个时候就会返回该函数，且里面会调用父RDD的 iterator 去拿数据来处理 override def compute(split: Partition, context: TaskContext): Iterator[U] = f(context, split.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6889d70cdf8497309a113d49b3260635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8039d056dc1de5297bdccb417ccd675f/" rel="bookmark">
			Java 5.3 - MyBatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#{} 和 ${} 的区别是什么？ ${} 是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如 ${driver} 被静态替换为 com.mysql.jdbc.Driver
#{} 是 sql 的参数占位符
xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？ Dao 接口工作的原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？ 最佳实践中，通常一个 xml 映射文件，就会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中 namespace 的值；接口的方法名，就是映射文件中 MappedStatement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。
* 全限名
Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。
这里使用了动态 sql 进行实现方法重载。
补充：Dao 接口方法可以重载，但是需要满足以下条件
1、仅有一个无参方法和一个有参方法
2、多个有参方法时，参数数量必须一致。且使用相同的 @Param
Mybatis 是如何进行分页的？分页插件的原理是什么？ 简述 Mybatis 的插件运行原理，以及如何编写一个插件。 Mybatis 执行批量插入，能返回数据库主键列表吗？ 可以
JDBC 都可以，Mybatis 当然也可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8039d056dc1de5297bdccb417ccd675f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0279ada5112d04c5db592a024f7f154c/" rel="bookmark">
			微服务集成 Seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引入依赖配置TC地址其它服务使用 本篇文章介绍分布式架构下, 各个微服务之间要达成分布式事务, 引入 Seata 的步骤和使用方式.
引入依赖 首先，在 order-service 服务中引入依赖：
&lt;!--seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--版本较低，1.3.0，因此排除--&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;!--seata starter 采用1.4.2版本--&gt; &lt;version&gt;${seata.version}&lt;/version&gt; &lt;/dependency&gt; 配置TC地址 在 order-service 中的 application.yml 中，配置 TC 服务信息，通过注册中心 nacos，结合服务名称获取 TC 地址：
seata: registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址 type: nacos # 注册中心类型 nacos nacos: server-addr: 127.0.0.1:8848 # nacos地址 namespace: "" # namespace，默认为空 group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP application: seata-tc-server # seata服务名称 username: nacos password: nacos tx-service-group: seata-demo # 事务组名称 service: vgroup-mapping: # 事务组与cluster的映射关系 seata-demo: SH 微服务如何根据这些配置寻找TC的地址呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0279ada5112d04c5db592a024f7f154c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d41f4558fcca128e4693aad96b86f4/" rel="bookmark">
			米家商城主题 html 页面源码分享，可用于网页设计作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用技术：
HTML, CSS , Javascript
项目亮点：
1. 仿照米家商城页面布局所做的页面样式结构
2. 首页放置了可自动切换的轮播图
3. 登录页有表单结构，并且有切换的动画效果
4. 包含实时的动态时间，使用 js 实现
5. 页面布局清晰，结构简单，适合初学者
&lt;!--导航栏开始--&gt; &lt;div class="logoNav"&gt; &lt;div class="logo"&gt;&lt;img src="images/1-top/logo.jpg" /&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="./index.html"&gt;智能硬件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="./page1.html"&gt;搭配&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="./page2.html"&gt;配件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="./page3.html"&gt;周边&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;盒子 · 影音&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;路由器&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;智能硬件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;服务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;社区&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="search"&gt; &lt;div class="hotwords"&gt; &lt;a href="#"&gt;小米MIX&lt;/a&gt; &lt;a href="#"&gt;小米电视3s 48英寸&lt;/a&gt; &lt;/div&gt; &lt;input type="search" /&gt; &lt;input type="submit" value="&amp;#xe605;" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--导航栏结束--&gt; &lt;!--轮播图栏开始--&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87d41f4558fcca128e4693aad96b86f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8786ca1ad34c19eb465a1e6ebe847fd5/" rel="bookmark">
			以阅读为翼,将英语学习融入青少年生活日常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读作为文化传承与个人成长的基石,正以一种全新的姿态融入青少年的学习生活之中。尤其是在英语学习领域,通过阅读将语言学习转化为生活习惯,成为越来越多家长及学生的共识。
在青少年共享阅读校长峰会上,江苏省南通市实验小学教育集团总校长刘昕通过“一个人的阅读史就是一个人的精神成长史”指出了阅读的重要性。这一理念在英语学习领域同样适用。青少年通过阅读英文原著和英文报刊,可以深入了解不同国家的文化精神。同时,利用数字化工具进行互动阅读,也进一步丰富了他们的阅读体验。这些阅读活动不仅让青少年获得了知识,更在潜移默化中培养了他们的跨文化交流能力。这种能力在未来的国际社会中将显得尤为重要。
兴趣以及家长的陪伴是激发青少年坚持阅读的重要因素。过往,在阅读中,存在选书难、买书贵的客观现实,现在这种问题正在迎刃而解,除了全民素养提升、家庭生活水平提高之外,数字化阅读也是解决方案之一。除“国家智慧教育读书平台”外,近些年,借助大数据、人工智能、移动互联等技术,不少教育、科技企业也在提供智慧化的阅读解决方案。
iEnglish智能英语学习解决方案作为“在海量输入输出中自然习得英语”的积极推动者,通过引入多元化的英文阅读材料结合智能化推荐系统,为青少年打造了一个无边界的阅读世界。从经典文学到前沿科技,从历史文化到当代社会热点,丰富多样的内容不仅满足了青少年对不同领域知识的好奇与渴望,更通过个性化的阅读推荐,激发了他们的阅读兴趣,为将英语阅读养成终身习惯打下了坚实基础。
“读书无嗜好,就不能尽其多。不先泛览群书,则会无所适从或失之偏好。”iEnglish阅读成长营负责人深谙此道,他鼓励青少年广泛涉猎不同类型的英文阅读材料,从经典文学到科普知识,从新闻报道到创意故事,让阅读成为一场探索世界的旅程。
来自厦门市的何同学以“iEnglish”为学伴,坚持每天不低于30分钟的原版阅读已经近2000天。痴迷于军事、宇宙等知识的他,在iEnglish的书籍板块中,探索专业知识,精进专业能力,不仅获取知识,更通过阅读自主习得英语,具备了无障碍阅读和交流沟通的外语能力。
对于任何事物,即使孩子再有兴趣,但最后的坚持大多与家长的陪伴脱离不了关系。早期阅读习惯的培养离不开父母的坚持,“你或许拥有无限的财富,但你永远不会比我富有,我有一位读书给我听的妈妈。”这句话充分表达了亲子阅读在亲子关系和孩子成长中的重要性。当家长读书给孩子听的时候,有三件重要的事在同时发生:孩子和书之间产生了一种愉悦的联结关系;家长和孩子同时从书里汲取了力量;家长把文字以及文字的发音用感情灌输在了孩子的耳朵里,能量在孩子心中积聚。
为帮助青少年激发阅读兴趣,iEnglish设置了许多游戏化、兴趣化板块,用来吸引初学者的注意力和喜好。家长可以利用iEnglish陪伴孩子进行阅读,同时结合进步时的一些小奖励,引导其自然养成阅读习惯。
国际化交流日渐频繁的今天,每个家长都希望自己的孩子在学好母语的同时,也能习得一门外语,这不仅是为了孩子未来的全面发展,也能在生活和工作中多一分助益。而阅读,正是培养这些能力的重要途径之一。通过英语阅读,青少年不仅能够掌握一门国际通用语言,更能够深入了解不同文化的精髓和差异,为未来的国际交流与合作打下坚实基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a7f34178293590c9a8e3c135de825d/" rel="bookmark">
			微服务间调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、restTemplate 1、先将restTemplate注册成为一个bean @Configuration public class RemoteCallConfig { @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } 2、实现代码 private void handleCartItems(List&lt;CartVO&gt; vos) { // TODO 1.获取商品id Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet()); // 2.查询商品 // List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds); // 2.1.利用RestTemplate发起http请求，得到http的响应 ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange( "http://localhost:8081/items?ids={ids}", HttpMethod.GET, null, new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() { }, Map.of("ids", CollUtil.join(itemIds, ",")) ); // 2.2.解析响应 if(!response.getStatusCode().is2xxSuccessful()){ // 查询失败，直接结束 return; } List&lt;ItemDTO&gt; items = response.getBody(); if (CollUtils.isEmpty(items)) { return; } // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7a7f34178293590c9a8e3c135de825d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b274f5c548d7fb1d409a926250e5065/" rel="bookmark">
			C# for语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计数循环使用for语句比while语句可读性高
for (int i = 0; i &lt; 10; i++)
{
Console.WriteLine("hello");
}
先执行int i=0；语句，且只执行一次
判断循环条件 i&lt;10; 语句的结果是否为true，如果为true，先执行循环体，再执行 i++；语句。
打印九九乘法表
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace StatementsExample4 { internal class Program { static void Main(string[] args) { for(int a=1;a&lt;10;a++) { for(int b=1;b&lt;10;b++) { if (b &gt; a) { break; } Console.Write("{0}x{1}={2}\t",a,b,a*b);//\t 是制表 } Console.WriteLine(); } Console.ReadLine(); } } } 该代码可以修改为
using System; using System.Collections.Generic; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b274f5c548d7fb1d409a926250e5065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cfe050de185c5fe42d265874bd34903/" rel="bookmark">
			什么是美颜SDK？视频美颜API集成与优化技术探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今，无论是自拍还是直播，拥有一个出色的美颜效果已经成为许多用户的刚需。而美颜SDK正是满足这一需求的关键技术工具。
一、美颜SDK的基本概念
这种SDK通常包括一套可供调用的API，以及一些预设的美颜滤镜和调整参数。通过这些API，开发者可以根据应用场景的需求，灵活地定制美颜效果，以提升用户的视觉体验。
二、视频美颜API的集成
集成视频美颜API是开发具有实时美颜功能应用程序的核心步骤之一。以下是视频美颜API集成的几个关键环节：
1.选择合适的美颜SDK：市面上有许多不同类型的美颜SDK，如腾讯、美图等提供的SDK。选择合适的SDK需要考虑应用的具体需求、用户群体和平台兼容性等因素。一个优秀的SDK应该具备高效的处理能力、丰富的美颜功能以及良好的兼容性。
2.API调用与参数设置：在集成API时，开发者通常需要设置相关的美颜参数，如磨皮强度、色调调节、滤镜效果等。这些参数直接影响美颜效果的呈现，因此在开发过程中需要经过多次调试和优化，以找到最佳的参数组合。
3.性能优化：实时美颜对系统性能要求较高，尤其是在处理高清视频时，容易出现卡顿、延迟等问题。因此，优化视频美颜API的性能至关重要。开发者可以通过减少美颜滤镜的计算复杂度、优化代码逻辑、使用硬件加速等方式，提升应用的运行效率。
三、美颜SDK的优化技术探索
在美颜SDK的使用过程中，优化不仅仅是为了提升用户体验，更是为了确保应用的稳定性与流畅性。以下是一些常见的优化技术：
1.硬件加速：利用GPU加速美颜处理，可以大幅降低CPU的运算压力。通过OpenGL或Vulkan等图形处理技术，将部分美颜运算任务交给GPU处理，从而提高整体的处理速度。
2.算法优化：美颜效果的实现依赖于一系列复杂的图像处理算法，如磨皮、滤镜等。通过优化这些算法，减少不必要的计算步骤，可以有效提升处理效率。例如，使用更加高效的图像模糊算法，或者通过采样优化减少计算量。
3.多线程处理：在处理高分辨率视频时，可以将美颜处理任务分配到多个线程中执行，以充分利用多核处理器的计算能力。这种方式不仅可以提高处理速度，还能避免因单线程阻塞导致的卡顿问题。
4.分辨率自适应：在网络条件较差或设备性能较低的情况下，适当降低视频分辨率，可以减少美颜处理的计算负荷，同时保证流畅的用户体验。这种分辨率自适应技术可以根据实际情况动态调整，从而在不同设备和网络环境下保持良好的表现。
总结：
美颜SDK为现代移动应用的开发提供了强大的工具，使得实时美颜成为可能。然而，要充分发挥美颜SDK的潜力，开发者需要在API的集成与性能优化上投入大量精力。通过合理选择SDK、精确设置美颜参数，以及运用多种优化技术，开发者可以为用户提供流畅、自然的美颜体验，满足其在拍摄和视频中的高要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd14da6f616ede0efc1fdaff233bad96/" rel="bookmark">
			弗洛伊德(Floyd)算法（C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		弗洛伊德算法（Floyd's algorithm），又称为弗洛伊德-沃尔什算法（Floyd-Warshall algorithm），是一种用于在加权图中找到所有顶点对之间最短路径的算法。这个算法适用于有向图和无向图，并且可以处理负权重边，但不能处理负权重循环。
弗洛伊德算法（Floyd-Warshall Algorithm）是一种用于计算图中所有顶点对之间最短路径的动态规划算法。本文将详细介绍弗洛伊德算法的原理，并提供一个C++实现的示例，以帮助读者理解算法的工作原理和编程技巧。
算法原理 弗洛伊德算法的核心思想是通过逐步寻找并更新所有顶点对之间的最短路径来解决问题。算法使用一个距离矩阵来存储顶点之间的距离，并在每一步中考虑通过一个新的中间顶点来更新这些距离。跟上一篇Dijkstra算法一样的原理，也是通过中转点去更新最短距离。不过Floyd算法处理的是多源的最短路问题。
算法步骤 初始化一个距离矩阵，其中dist[i][j]表示顶点i到顶点j的直接距离。如果i和j不直接相连，则dist[i][j]为无穷大。对于每个顶点k，作为中间顶点，更新dist[i][j]为min(dist[i][j], dist[i][k] + dist[k][j])。 Floyd是经典三重for循环，所以它的时间复杂度为o(n^3)，n是图中顶点的数量。第一层遍历中转点，第二层遍历起点，第三层遍历终点，对于图中点的数量多的情况，Floyd算法的时间复杂度是很高的。
图解算法： 下面我们将以4个点的图进行讲解，图的连边为有向边和无向边的结合。以邻接矩阵的方式进行存储，如果大家喜欢用邻接表存储，也可以使用邻接表，下面介绍两个矩阵，矩阵A表示（i，j）i-&gt;j的最短距离，初始化为inf。矩阵B表示i-&gt;j路径由i到j的中转点，也就是路径上除去起点的第一个点，初始化为-1。
初始： 按照图中的点距离给其赋值，A矩阵i-&gt;i距离都为0，inf为无法到达。B矩阵初始为-1。
第一步： 我们选取一个点（按照顺序选取）把它作为中转点，看看以它为中转点，所能到达的点中有没有产生更小的距离，如果产生了，则更新A矩阵的距离，更新B矩阵的中转点。我们先选取1号点，那么位于1号点的行跟列的值都是不可能变化的，还有就是自己到自己的点也是不会变化的永远是0，图中黄颜色标记的是此步不会改变的点，其他的可能会变。在更新距离的时候我们可以不看图就能更新矩阵，例如下图中2号点到3号点本来为10，我们可以连一个矩阵，以1号点画的两条蓝线为两条边，红色线为剩余2边，我们既然把1号点当作中转点，路径必然为2-1-3，此时距离就是副对角线的顶点值相加2+6=8&lt;10，那么通过1号点绕路的方式距离更短。类似的还有3-&gt;2号点，6+2=8&lt;inf。3-&gt;4号点，10+6=16&lt;inf。4-&gt;3号点，10+6=16&lt;inf。顺便把B矩阵更新完。
更新完后（红色标记为变化的值）： 第二步： 此时把2号结点作为中转结点，看一看能够更新哪一个最短路径，还是跟上一步一样直接看图更新就可以。如下图，4-&gt;1号点，2+4=6&lt;10。1-&gt;4号点，2+4=6&lt;10。3-&gt;4号点，8+4=12&lt;16。4-&gt;3号点，8+4=12&lt;16。对于一些不能更新的值，例如1-&gt;3号点，2+8=10&gt;6，这样的则不能更新。
对于B矩阵，要注意3-&gt;4跟4-&gt;3的路径是相反的，更新是则不能直接修改为2，对于3-&gt;4号点第一个中转点还是1号点。更新完后（红色标记为变化的值）： 第三步： 把3号点作为中转结点，跟前几步一样，继续寻找最短距离。经过更新我们发现3号点作为中转点不能更新任意一个距离，所以A、B矩阵不需要更新。在图中，经过验证我们发现3号点中转距离反而变大，所以不更新。
第四步： 把4号点作为中转点，继续更新最短距离。我们发现跟3号点一样，不能更新任何距离，在A矩阵中除了黄色的点之外，所能连起来的矩形，主对角线顶点值相加都比当前值要大。在图中也可以验证，所以不给予更新。
这样我们就更新完所有点，把所有点都当作中转点更新完一遍，这样就完成了Floyd算法，更新时每次按照顺序把点当作中转点，遍历寻找路径的起点，再遍历寻找终点，算法时间复杂度为o(n^3)。
视频讲解可以看一下B站这位UP主的讲解，点击直达
算法实现： 以下是弗洛伊德算法的C++实现示例：
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;limits&gt; using namespace std; // 定义图的顶点数 const int N = 100; // 定义无穷大的初始距离 const int INF = numeric_limits&lt;int&gt;::max(); // 弗洛伊德算法的实现 void floydWarshall(vector&lt;vector&lt;int&gt;&gt;&amp; dist) { int n = dist.size(); // 遍历所有顶点作为中间顶点 for (int k = 0; k &lt; n; k++) { // 遍历所有顶点作为起点 for (int i = 0; i &lt; n; i++) { // 遍历所有顶点作为终点 for (int j = 0; j &lt; n; j++) { // 如果通过顶点k可以找到更短的路径，则更新dist[i][j] if (dist[i][k] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd14da6f616ede0efc1fdaff233bad96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9d0ff7199a30a112d05fd90718c100/" rel="bookmark">
			什么是 AWS CloudWatch？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AWS CloudWatch 是 AWS 提供的一项全面的监控和可观测性服务，使用户能够收集和可视化指标、日志和事件；设置警报；并根据预定义的条件自动执行操作。CloudWatch 提供对 AWS 资源和应用程序的运行状况、性能和运行状态的深入了解，使用户能够优化资源利用率并主动排除问题。
AWS CloudWatch提供的功能 Amazon CloudWatch 主要从三个主要来源收集数据：指标、日志和事件。
指标是衡量资源性能和运行状况的数值，AWS CloudWatch 为 AWS 服务收集各种预定义指标，例如 CPU 利用率、磁盘读写、网络流量和 Lambda 函数执行时间。管理员还可以为应用程序定义自定义指标。
另一方面，日志是包含有关系统中发生的事件的信息的文本文件。AWs CloudWatch可以从应用程序、AWS资源、AWS CloudTrail记录的API调用，甚至本地系统中提取日志。
CloudWatch本身并不直接将事件作为单独的数据源收集，然而，AWS生态系统中有处理事件的功能：
Amazon CloudWatch Events：这是一项专门用于管理跨AWS资源的事件的服务，它可以从各种来源摄取事件，并将它们路由到不同的目标（包括Amazon CloudWatch Logs）以便进行存储和分析。AWS Lambda性能事件：AWS Lambda使用“性能事件”监控与函数执行相关的数据。这些事件包括CPU利用率、内存使用和网络流量等详细信息。它们被提取到CloudWatch日志中进行分析。 在这些数据的帮助下，CloudWatch提供了以下核心功能：
指标收集和可视化：AWS CloudWatch从AWS资源中收集各种指标，包括CPU利用率、网络流量、内存使用情况和应用程序性能指标。然后，这些指标显示在可自定义的控制面板上，以便管理员跟踪资源运行状况并识别潜在问题。日志聚合和分析：AWS CloudWatch 通过从 Amazon Elastic Compute Cloud（EC2）实例、Lambda 函数和其他来源提取日志来简化日志管理。它提供强大的筛选和搜索功能，可以精确定位日志中的特定事件，从而促进故障排除和调试。事件监控：Amazon CloudWatch让管理员随时了解AWS环境中发生的重大事件。其中包括系统状态更改、API调用和安全警报，管理员可以接收实时通知，以确保及时收到需要立即关注的关键事件的警报。警报和通知：AWS CloudWatch允许管理员根据特定指标或日志模式定义自定义警报，它可以在违反警报阈值时通过电子邮件、SMS或Amazon Simple Notification Service主题触发通知，从而实现主动事件响应。可定制的控制面板：AWS CloudWatch 能够创建直观的控制面板，将来自各种来源的指标、日志和事件组合在一起，这种整合视图使管理员能够从单一管理平台监控整个 AWS 基础设施的运行状况和性能。 AWS CloudWatch是如何工作的 Amazon CloudWatch 在 AWS 生态系统中无缝运行。以下是其工作流程的简化细分：
数据采集：在资源中部署AWS CloudWatch代理，以收集指标、日志和事件。或者可以将 CloudWatch 与各种 AWS 服务（如 Simple Storage Service、DynamoDB 和 CloudTrail）集成，以便它直接提取数据。数据处理：将收集到的数据发送到AWS CloudWatch进行处理和存储。数据可视化：AWS CloudWatch 提供直观的控制面板和可视化功能，用于实时监控AWS资源。警报和通知：Amazon CloudWatch 使管理员能够根据特定指标或日志模式定义自定义警报，当超出阈值时，AWS CloudWatch 会触发通知以通知管理员。 CloudWatch 与 CloudTrail 对比 虽然 AWS CloudWatch 和 AWS CloudTrail 都是 AWS 提供的监控服务，但它们的用途不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c9d0ff7199a30a112d05fd90718c100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6edfb26f53f55f91f4dc95791f9d8e04/" rel="bookmark">
			微服务简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务是一种软件架构风格，通过将一个大型的应用程序分解为一组小型的、相互独立的服务来实现。这些服务可以分别进行开发、部署和扩展，且通常通过轻量级的通信机制（如HTTP API）进行交互。微服务架构的核心思想是将应用程序的各个功能模块拆分为独立的服务，使得每个服务专注于特定的业务能力，从而提升整个系统的灵活性、可维护性和可扩展性。
微服务的优势 1. 独立开发和部署：微服务允许各个团队并行开发和部署不同的服务。由于服务之间松耦合，不同服务的更新和升级不会影响其他服务的正常运行。这种特性提高了开发效率，并减少了部署风险。
2. 灵活的技术栈：每个微服务可以根据自身的需要选择合适的技术栈，而不必拘泥于整个应用的技术选择。这意味着可以使用最适合的编程语言、数据库和框架来实现特定的功能。
3. 故障隔离：在微服务架构中，某个服务的故障不会导致整个系统崩溃。由于服务之间通过轻量级的通信机制进行交互，即使某个服务出现问题，也可以通过重试、降级等策略来保证系统的整体可用性。
4. 易于扩展：微服务架构允许根据业务需求对某些服务进行独立扩展，而无需扩展整个系统。例如，如果某个服务需要处理大量的请求，可以单独扩展该服务的实例数量，从而提高性能。
5. 易于维护：由于微服务将复杂的大型应用拆分为多个小型服务，每个服务的代码量较小，逻辑相对简单，因此更容易进行测试、调试和维护。
微服务的相关组件 微服务架构不仅仅是将应用程序拆分为多个服务，还需要一系列的配套组件来支持和管理这些服务的运作。以下是微服务架构中一些重要的组件及其重要性：
1. 服务发现（Service Discovery） - 作用：服务发现组件负责跟踪和管理所有微服务的注册信息，以便其他服务能够找到并与之通信。服务实例的动态注册和注销保证了服务的高可用性。
- 重要性：在微服务环境中，服务实例可能会频繁启动和停止，服务发现可以自动更新这些变化，确保服务之间的通信不会中断。
2. API网关（API Gateway - 作用：API网关是客户端和后端服务之间的入口，负责请求路由、负载均衡、认证、权限控制、缓存、日志记录等功能。
- 重要性：API网关集中管理所有外部请求，减少了客户端与多个服务直接交互的复杂性，并且提供了一个统一的接口来保障系统的安全性和性能。
3. 配置管理（Configuration Management） - 作用：配置管理工具用于集中管理微服务的配置文件，支持配置的动态更新而无需重新部署服务。
- 重要性：配置管理使得微服务能够在不同的环境（如开发、测试、生产）中灵活运行，并根据需要动态调整配置参数。
4. 负载均衡（Load Balancing） - 作用：负载均衡组件将请求分发到多个服务实例，以均衡负载，优化资源使用率，防止某个实例过载。
- 重要性：负载均衡保证了服务的高可用性和性能，尤其是在高并发场景下，可以有效减少服务的响应时间。
5. 分布式追踪（Distributed Tracing） - 作用：分布式追踪工具用于监控和分析跨多个微服务的请求路径，帮助开发者识别性能瓶颈和排查故障。
- 重要性：在微服务架构中，一个请求可能会经过多个服务，分布式追踪提供了完整的调用链路视图，便于对系统进行性能调优和故障诊断。
6. 日志管理（Log Management） - 作用：日志管理工具用于集中收集、存储和分析各个微服务的日志信息，支持实时监控和故障排查。
- 重要性：在分布式系统中，日志是重要的调试和审计工具，通过集中化的日志管理可以快速定位问题，提升运维效率。
7. 容器化与编排（Containerization and Orchestration） - 作用：容器化技术（如Docker）将微服务及其依赖打包为独立的容器，而编排工具（如Kubernetes）负责管理这些容器的部署、扩展和健康检查。
- 重要性：容器化保证了服务的一致性和可移植性，而编排工具则简化了大规模微服务的管理，使得系统具有良好的弹性和自愈能力。
结论 微服务架构凭借其独立开发部署、灵活的技术选择、故障隔离和易于扩展等优势，已成为现代软件开发的重要趋势。为了实现微服务的高效运作，服务发现、API网关、配置管理、负载均衡、分布式追踪、日志管理以及容器化与编排等组件是不可或缺的。通过合理设计和集成这些组件，可以构建出一个高效、稳定和易于维护的微服务系统，满足不断变化的业务需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0807859e5a9d71661049c23c9dedbc1f/" rel="bookmark">
			【MySQL】JDBC编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注个人主页：逸狼
创造不易，可以点点赞吗~
如有错误，欢迎指出~
目录
代码连接数据库的 前期准备 通过代码使用JDBC的API
创建数据源对象
给数据源对象设置必要属性
setUrl
setUser
setPassword
建立网络连接
发送到服务器 执行
释放资源
完整代码 插入数据
用户自行输入内容
查询操作代码
​编辑
代码连接数据库的 前期准备 针对数据库的操作,实际工作中 很少会直接通过 命令行/图形化 客户端来操作数据库,更多是通过代码(C++,Java,Python,Go.....)操作数据库,前提数据库要提供一组API(Application Programming Interface 应用程序编程接口,在库中的类/方法/函数就可以称为API)供其他程序来使用
每个数据库的api都是自成一套体系,Java自身指定了一套API,其他数据库都要把自己的API转换成和Java这一套兼容的API(即JDBC),对于Java程序员,只需要学习一套api就可以应对各种数据库了
mysql官方提供了一个mysql-connector第三方库 将MySQL原生的C的API转换成 兼容JDBC的Java的API
mysql-connector 是第三方库,需要自己下载,推荐取maven中央仓库下载
以下是下载步骤:
如果mysql 服务器是8系列,connector 也必须使用8版本(5版本同理) 下载好jar包 ,在idea里创建一个项目,拷贝到自己创建的一个目录(这里演示的是'lib' ),右键这个目录,选择 add as library(告诉idea,这个lib目录是一个'库'目录),添加完 '库'后,此时idea就能自动分析出jar包里的内容
通过代码使用JDBC的API 下面通过演示 用代码操作数据库 并 插入数据的效果
创建数据源对象 由于DataSource是一个Interface,不能new出来,需要实现这个接口的子类(MysqlDataSource())
//1.创建数据源对象 DataSource dataSource =new MysqlDataSource(); //给数据源对象 设置必要的属性 ((MysqlDataSource) dataSource).setUrl("jdbc:mysql://127.0.0.1:3306/test1?characterEncoding=utf8&amp;useSSL=false"); ((MysqlDataSource) dataSource).setUser("root"); ((MysqlDataSource) dataSource).setPassword("111111"); 给数据源对象设置必要属性 setUrl 设置 数据库服务器的 位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0807859e5a9d71661049c23c9dedbc1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebbd559a034ee5425ce38713ee7ecd38/" rel="bookmark">
			STM32原理图一些引脚VDDA/VSSA/VBAT/OSC/NRST/BOOT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以STM32f103c8t6为例
OSC IN和OSC OUT引脚是STM32单片机上的外部高速晶体振荡器（crystal oscillator）的输入和输出引脚。这些引脚用于连接外部晶体振荡器，以提供精确的时钟信号给单片机，建立稳定的振荡回路。
OSC32_IN和OSC32_OUT引脚是STM32单片机上的外部32.768 kHz低速晶体振荡器的输入和输出引脚。这些引脚用于连接外部32.768 kHz晶体振荡器，以提供低功耗时钟信号给单片机，建立稳定的振荡回路。
VDDA即GND
VSSA即VCC
VBAT 电池或其他电源供电，这保证当主要电源被切断时， RTC 能继续工作
BOOT 用于确定单片机的启动模式 NRST 外部复位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deccaaf6f342688903a1b4eb8be8fd5e/" rel="bookmark">
			C&#43;&#43;第四十二弹---C&#43;&#43;11新特性深度解析：让你的代码更现代、更高效(中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1 右值引用和移动语义
1.1 左值引用和右值引用
1.2 左值引用与右值引用比较
1.3 右值引用使用场景和意义
1.4 右值引用引用左值及其一些更深入的使用场景分析
1.5 完美转发
1 右值引用和移动语义 1.1 左值引用和右值引用 传统的C++语法中就有引用的语法，而C++11中新增了的右值引用语法特性，所以从现在开始我们
之前学习的引用就叫做左值引用。无论左值引用还是右值引用，都是给对象取别名。
什么是左值？什么是左值引用？
左值是一个表示数据的表达式(如变量名或解引用的指针)，我们可以获取它的地址+可以对它赋值，左值可以出现赋值符号的左边，右值不能出现在赋值符号左边。定义时const修饰符后的左值，不能给他赋值，但是可以取它的地址。左值引用就是给左值的引用，给左值取别名。
代码演示
int main() { // 左值是一个表达式，可以取地址 // 左值和右值，能否取地址 // 左值：能取地址 // 右值：不能取地址 int a = 10; int b = a; const int c = 10; int* p = &amp;a; vector&lt;int&gt; v(10, 1); v[1]; cout &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; &amp;c &lt;&lt; endl; cout &lt;&lt; &amp;(*p) &lt;&lt; endl; cout &lt;&lt; &amp;(v[1]) &lt;&lt; endl; return 0; } 测试结果 以上表达式均能够获取它的地址，因此均为左值。 什么是右值？什么是右值引用？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deccaaf6f342688903a1b4eb8be8fd5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fc5a2f1f7f31b41bc5087ce54b0c1e/" rel="bookmark">
			Leetcode面试经典150题-122.买卖股票的最佳时机II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解法都在代码里，不懂就留言或者私信，比第一题稍微难点
class Solution { /**题目分析：这个问题是我们可以无限次买卖，这个题其实是寻找波峰和波谷的问题 理论上我们在上升期的最低点买，最高点卖就能获得最大利润，但是寻找波峰和波谷的过程会比较麻烦 我们这里代替一下寻找波峰和波谷：如果在上升阶段，把所有的点获得的利润（都是前一个交易日买这个交易日卖） 加一起，其实就是波谷买波峰卖，只不过这样比较简单 忽略当前价格比前一个交易日小的时间，因为这是下降阶段*/ public int maxProfit(int[] prices) { /**习惯性的健壮性判断 */ if(prices == null || prices.length &lt; 2) { return 0; } /**定义最大利润 */ int max = 0; /**0位置不可能卖，从下标1开始尝试 */ for(int i = 1; i &lt; prices.length; i++) { /**不习惯这么写的话就写if(prices[i]&gt;prices[i-1]) { max += prices[i] - prices[i-1]; } */ max += Math.max(0, prices[i]-prices[i-1]); } return max; } } 绝对最优解，跑出这个百分比也是疯了，不管了 稍后更新股票系列3-4题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0654040baa496e259f8bce9624d57520/" rel="bookmark">
			笔记本电脑中怎么查看光驱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你的笔记本电脑配备了光驱，你可以通过以下步骤来查看：
检查笔记本外观：首先看看笔记本侧面或前端是否有明显的光盘托盘入口，通常标有CD/DVD图标。
Windows系统下查找：
打开【我的电脑】或者【此电脑】（不同版本的Windows命名可能有所不同）。
如果系统识别到了光驱并且驱动正常安装，你应该能看到一个名为"DVD RW 驱动器"（或者其他类似的名称，取决于具体的光驱类型和制造商）的图标。
使用设备管理器确认：
按Win+X组合键打开快捷菜单，选择【设备管理器】。
展开【DVD/CD-ROM 驱动器】类别，这里列出了连接到计算机上的所有光驱设备。
Mac系统下查找：
打开Finder，从侧边栏的【设备】部分看是否有一个表示光驱的条目。
请注意，由于近年来许多新款笔记本为了追求轻薄设计已不再配备内置光驱，如果你找不到上述选项，很可能意味着你的笔记本并未配置光驱。在这种情况下，可以考虑外接USB光驱作为替代解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c2ef472213cc9d7b28bf1507371218c/" rel="bookmark">
			SCDN的优势在哪？Edge SCDN与传统SCDN有何不同？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们经常听到的SCDN，即安全加速，是一种在传统CDN的基础上融入了安全防护功能的网络服务，通过在全球范围内部署多个边缘服务器，根据就近原则给用户调取最近节点缓存的内容，能够在满足用户的资源请求的同时显著减少延迟并提高访问速度。
相较于其他安全产品而言，SCDN的特点在于其能够做好在性能与安全的平衡，不仅能够提供安全防护，还可以保障内容分发的高效性。SCDN不仅继承了CDN的所有功能，还加强了安全防护能力，能在确保数据传输快速的同时，为网站或应用提供强大的安全防护。
举个例子，在同样对安全性和内容分发效率有较高要求的场景，如电商网站、视频流媒体平台、大型游戏等，SCDN相较于WAF（Web应用防火墙）或高防IP存在以下优势：
1.内容分发效率
SCDN能够利用智能调度算法选择最优的传输路径，确保内容以最快的速度、最低的延迟到达用户，还支持通过内容压缩、图片优化等一系列手段进一步提升内容分发效率；而WAF和高防IP相较于SCDN更侧重于安全防护方面，不直接参与分发过程，可能无法提供全局优化的内容分发服务。
2.安全性
从安全性的角度，SCDN集成了包括DDoS防护、CC自适应防御、智能WAF防护等多种安全防护技术，能够全方位地保护网站防止恶意攻击；而WAF及高防IP的防护能力方面各有侧重，WAF多专注于Web应用层面的安全防护，高防IP则以提供DDoS攻击防护功能为主，可以说SCDN是二者的优势结合。
Edge SCDN
Edge SCDN（边缘安全加速推出的集分布式DDOS防护、CC防护、WAF防护为一体的安全加速解决方案，能够全方位有效保护网站和应用的安全。同传统的SCDN相比，Edge SCDN不仅能覆盖传统SCDN的所有功能优势，并在此基础上提供更多的优势功能。
1.边缘计算能力
与传统SCDN相比，Edge SCDN能够直接在边缘节点完成对恶意流量进行实时的分析、拦截，并进行攻击特征匹配，减少了数据往返中心服务器的时间，进一步提升了响应速度。
2.灵活的成本控制
Edge SCDN采用流量计费，用户可根据实际的需求和预算进行调整，有助于客户更加灵活高效地管理成本。
3.一站式全面防护
用户可以轻松自助配置，接入简便，轻松享受DDoS、CC攻击和WAF全面防护，显著减少安全风险，提升整体安全性。
Edge SCDN 不仅覆盖了传统 SCDN 的所有功能优势，而且还增加了边缘计算的能力、更高级的安全防护措施以及更灵活的计费模式，为客户提供了一个更加全面和先进的解决方案，有效满足客户在不同应用场景下的个性化需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8294bdbcc55c658a3a32d646c584023e/" rel="bookmark">
			神经网络——优化器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.优化器介绍： 优化器集中在torch.optim中。
Constructing it optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9) optimizer = optim.Adam([var1, var2], lr=0.0001) Taking an optimization step for input, target in dataset: optimizer.zero_grad() output = model(input) loss = loss_fn(output, target) loss.backward() optimizer.step() 2.代码实战： import torch import torchvision from torch import nn from torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linear from torch.utils.data import DataLoader dataset=torchvision.datasets.CIFAR10("data",train=False,transform=torchvision.transforms.ToTensor(), download=True) #每个批次中加载的数据项数量 dataloader=DataLoader(dataset,batch_size=1) class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1=Sequential( Conv2d(3,32,5,padding=2), MaxPool2d(2), Conv2d(32,32,5,padding=2), MaxPool2d(2), Conv2d(32,64,5,padding=2), MaxPool2d(2), Flatten(), Linear(1024,64), Linear(64,10) ) def forward(self, x): x=self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8294bdbcc55c658a3a32d646c584023e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7924ec9c8d8ec81c4c28c4c8ceb8c183/" rel="bookmark">
			布偶猫应该怎么喂？希喂、交响乐金罐、尾巴生活彩虹泥适合布偶猫吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我开了家布偶猫咖，这些长相甜美可爱的小家伙超会撒娇卖萌，把客人迷的团团转。布偶猫又叫仙布拉多尔猫，它是现存体型最大、体重最重的猫之一，它们体型大，食量也大，但肠胃却特别弱，所以一定要特别重视主食的选择。金天我们猫舍的30只猫咪就化身猫罐头侦查员，就来个主食罐头安全测试，咱们一起练就火眼金睛，安全罐头轻松选！
一、品牌介绍 品牌1：希喂
希喂在高级猫咖中相当有名。它曾为多家海外知名猫粮品牌提供测试与本土化配方优化解决方案，并邀请了300多位资深宠物医生和百家猫咖参与研发测试。这款主食罐头，里面富含矿物质、牛磺酸和三文鱼油等黄金营养素，简直是猫咪的营养宝库！听说还有上百家猫舍亲测，长久喂食能让猫咪的活力提升50%，免疫力提高78.56%，更让人放心的是，它由汉欧匠心打造，按批次送检，主动提供详尽的质检报告！
品牌2：交响乐金罐
交响乐金罐是GranataPe旗下品牌。GranataPe成立于2009年，其名字巧妙融合了德文中的“石榴”（Granata）与“宠物”（Pet），寓意着产品中融入了对宠物大有裨益的石榴精华。该品牌精心打造了四大系列猫咪罐头，包括备受欢迎的交响乐金罐系列、趣味横生的丑猫系列、便捷实用的餐盒系列，以及鲜美可口的汤罐系列。其中，交响乐金罐系列凭借其多样化的口味组合受到一些中国消费者的欢迎。
品牌3：高爷家
据说是为了一只叫高爷的猫，创立的品牌。它是杭州忘妙生物科技有限公司旗下品牌，诞生于2019年，旗下产品包括猫粮、主食罐头、微生物除臭剂等。他们家餐盒只有40克，精致小巧，便于喂食与保存。有小奶盒、小鱼盒、小鸡盒三种口味，每种口味配以独特包装色彩，十分可爱。
二、多方位对比测评 1.对比维度一：营养
猫咪对蛋白质的需求远高于其他动物，是狗的3倍、人的5~6倍。而布偶猫是大型猫，它们比一般体型的猫咪需要更多的蛋白质。当摄入的蛋白质无法满足身体代谢需求的时候，布偶猫会分解自己的肌肉来解决蛋白质需求，长期如此，他们就无法保持圆嘟嘟的小脸和靓丽的毛发了。考虑到肉类富含高质量蛋白质，要尽量选择高蛋白高肉含的主食罐，给布偶猫提供充足的营养。
测评类目：肉含量、蛋白含量
希喂：★★★★★
交响乐金罐：★★★
尾巴生活：★★★★
光看数据，三款主食罐的肉含量都很高，但实际上只有希喂去水后肉含量超过了95%。交响乐金罐的肉含量是算上肉汤的，尾巴生活彩虹泥餐盒的肉含量也包括了27%的羊乳。这两款罐头去水肉含量可能只在70%左右。其实从蛋白质含量也可以看出这两款罐头的肉含量没达到90%，蛋白质主要来源于肉类，肉含量越高，蛋白质越丰富。交响乐金罐和尾巴生活彩虹泥如果肉含量和希喂相近，蛋白含量不可能相差那么多。
2. 对比维度二：热量
由于基因和食量，布偶猫很容易发胖。所以铲屎官一定要注意它们的饮食结构，尽量给它们挑选热量低的主食罐。像肝脏这种高热量食物，最好不要超过10%。另一方面，要主要观察主食罐的脂肪含量，脂肪越多，热量越丰富，猫咪更容易吃胖。对于易胖的布偶猫，脂肪含量最好控制在20%以下。
测评类目：脂肪、肝脏含量
希喂：★★★★★
交响乐金罐：★★★★
尾巴生活：★★★
金色交响乐没有标明肝脏含量，但是翻看主食罐内容物，我能找到不少肝脏。而且他的脂肪含量接近30%，热量十分高，长期喂食容易发胖。希喂采用人食级鲜肉食材，选择高蛋白低脂肪的鸽肉为核心原料，并且只加入4%的鸡心和4%的鸡肝，将脂肪含量控制在合理范围。尾巴生活没有加肝脏成分，所以脂肪含量很低。但是适当的肝脏还是很必要的，肝脏富含维生素A，能够保护猫咪视力。
3.对比维度三：安全性
布偶猫的肠胃非常敏感脆弱，食用品控不好的罐头很容易出问题。所以我们收集了主食罐的品控信息和猫咪试吃后反应，测试主食罐的安全性。
测评类目：品控表现、食用后情况
希喂：★★★★★
交响乐金罐：★★★★
尾巴生活：★★★
希喂——希喂选择配方、品控两手抓。它不追求新奇的口味，只推出了金枪鱼、鸽肉两种纯净配方。者两种口味都是无淀粉、无谷物、无食用胶、无诱食剂，走的是低碳水、温和健康的路线，不容易刺激猫咪肠胃，猫咪吃了后都没有不良反应。而且希喂的品控相当稳定，它它由汉欧匠心打造，坚持婴儿奶粉级别品控，采用GMP标准车间和5A级品控体系，三重质检保驾护航：第三方、代工厂和中央实验室，层层把关，质量杠杠的。
交响乐金罐——交响乐金罐的品控不太稳定，部分批次会严重翻车。比如我们发现日期是251025的罐头，摇晃能听见水声。有位家长喂了一个，猫咪吃了罐头后开始只是一点点出血+软便，第三天发现它的便便里好多血。
尾巴生活——品控稳定，但可能配方需要调整一下，极少数猫咪吃了会拉稀。
三、总结 通过本次测评，大家应该也学会了给布偶猫挑选主食罐头，至于哪款猫罐头更适合自家猫咪，就交给大家自行判断啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b921d8788404ff3dabd2b1bb445ba5b/" rel="bookmark">
			大数据-106 Spark Graph X 计算学习 案例：1图的基本计算、2连通图算法、3寻找相同的用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（已更完）Spark（正在更新！） 章节内容 上节完成了如下的内容：
Spark Graph X基本概述架构基础概念详解核心数据结构
编写 Spark GraphX 程序注意的事情 数据分区与负载均衡 由于 GraphX 运行在分布式环境中，数据分区策略直接影响到计算性能。合理分区可以减少网络传输和计算开销，提高图计算的效率。要注意图数据的分布情况，避免数据倾斜。
处理大规模数据时的内存管理 GraphX 会对顶点和边的数据进行分区和缓存，但在处理大规模图数据时，内存管理尤为重要。需要注意内存使用情况，合理配置 Spark 的内存参数，避免内存溢出或垃圾回收频繁的问题。
迭代计算的收敛条件 许多图算法（如 PageRank）是基于迭代计算的，因此要合理设置收敛条件（例如迭代次数或结果变化阈值）。过多的迭代会浪费计算资源，过少的迭代可能导致结果不准确。
图的变换和属性操作 在对图进行操作时，特别是更新顶点和边的属性时，要确保变换操作不会导致数据不一致或图结构的破坏。使用 mapVertices、mapEdges 等操作时，要谨慎处理每个顶点和边的属性。
错误处理与调试 在编写分布式程序时，错误处理和调试尤为重要。GraphX 的操作涉及复杂的图结构，调试时应充分利用 Spark 的日志和错误信息，使用小规模数据集进行初步验证，逐步扩展到大规模数据。
数据存储与序列化 GraphX 在处理大规模图数据时，可能需要将数据保存到外部存储中（如 HDFS）。要注意选择合适的数据格式和序列化方式，以保证数据读写的高效性和可靠性。
扩展性与性能优化 在开发 GraphX 应用时，考虑到未来可能的扩展需求，程序设计应具有一定的扩展性。同时，针对性能的优化也是关键，要通过测试和调整参数来找到最佳的执行配置。
编写 Spark GraphX 程序 以下是编写 Spark GraphX 程序的主要步骤：
初始化 SparkContext 创建 SparkConf 和 SparkContext，这是 Spark 应用程序的入口。
import org.apache.spark.{SparkConf, SparkContext} import org.apache.spark.graphx._ object GraphXExample { def main(args: Array[String]): Unit = { val conf = new SparkConf().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b921d8788404ff3dabd2b1bb445ba5b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/17/">«</a>
	<span class="pagination__item pagination__item--current">18/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/19/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>