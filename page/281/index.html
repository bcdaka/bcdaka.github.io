<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e920ef57b9125850808a65c70e5032b/" rel="bookmark">
			Flink SQL实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备 方式1：基于Standalone Flink集群的SQL Client
启动Flink集群
[hadoop@node2 ~]$ start-cluster.sh [hadoop@node2 ~]$ sql-client.sh ... 省略若干日志输出 ... Flink SQL&gt; 方式2：基于Yarn Session Flink集群的SQL Client
启动hadoop集群
[hadoop@node2 ~]$ myhadoop.sh start 使用Yarn Session启动Flink集群
[hadoop@node2 ~]$ yarn-session.sh -d 启动一个基于yarn-session的sql-client
[hadoop@node2 ~]$ sql-client.sh embedded -s yarn-session ... 省略若干日志输出 ... Flink SQL&gt; ​ 看到“Flink SQL&gt;”提示符，说明成功开启了Flink的SQL客户端，此时就可以进行SQL相关操作了。
注意：以上选择其中一种方式进行后续操作。
数据库操作 Flink SQL&gt; show databases; +------------------+ | database name | +------------------+ | default_database | +------------------+ 1 row in set ​ Flink SQL&gt; create database mydatabase; [INFO] Execute statement succeed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e920ef57b9125850808a65c70e5032b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0dcbd0e499718f7034c6e821f6a9b2/" rel="bookmark">
			如何通过 CDN 优化网站加载速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多个人用户应该都遇到过打开某个企业网站时，页面加载缓慢，等待时间漫长，让人心生厌烦的情况；或者说作为企业主体，市场主管们也会担心因为网站加载慢而失去宝贵的潜在客户。在这里，小编将向您介绍一项网站加速技术— CDN ( 内容分发网络 ) ，它能将上述大部分问题都完美地解决！
CDN是一种用于提高企业网站访问速度和性能的工具，通过将内容分布在全球多个服务器上，CDN可以将用户请求导向最近的服务器，从而减少数据传输的距离和延迟。这样一来，企业网站的页面加载速度将得到显著的提升，用户体验也将得到改善。
举个例子，比如一家面向全球用户的企业官网，用户分布在欧美、亚洲等不同地区，如果这家企业只有独立的服务器托管网站，那么用户在欧洲和亚洲的访问速度将会较慢，因为数据需要经过较长的传输距离，而这会导致页面加载时间增加，用户流失的可能性也会大大增加。
而如果使用CDN，该企业就可以在欧洲、亚洲等地区分别设置多个服务器节点，这些节点会存储网站的静态内容。
当用户从欧洲访问网站时，CDN会将请求导向欧洲的服务器节点，从而实现更快的加载速度。同理，亚洲地区的用户也会被引导到亚洲的服务器节点。
一般来说，使用 CDN 后用户访问网站的过程是这样的：
1、用户在浏览器中输入网站地址并按下回车键。
2、用户的请求首先被指向最近的CDN服务器节点，该节点可能位于该用户所在的某个城市。
3、CDN服务器节点上存有网站的缓存内容，准备调用。
4、服务器节点将缓存的内容快速传送给用户的浏览器。
如此之后，用户就不再需要请求跨国跨域服务器，极大降低了数据传输的时间和延迟，提高了网站的响应速度。
当然了，CDN另一个优点是CDN还可以防止DDoS等恶意攻击，原理是由于CDN分散了流量，当恶意流量涌入时，CDN可以帮助过滤掉这些流量，保护网站免受攻击。
除了加速网站访问速度和提高安全性，CDN还有助于降低网站的服务器负载。
当大量用户同时访问网站时，CDN可以将请求分发到不同的服务器节点上，从而分担了单一服务器的压力，这可以确保网站在高流量时仍能保持稳定的性能。所以对于大中型企业来说，CDN是一个非常有用的工具，它能够显著提高企业网站的访问速度和性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f1757c4cfb294ed8b1d8c7f4b11099/" rel="bookmark">
			【网络安全】跨站脚本攻击漏洞—HTML前端基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、HTML概述
1.1 head部分
1.2 body部分
1.3 HTML特殊符号
二、JavaScript概述
2.1 HTML中JavaScript的存在方式
2.2 DOM操作
2.3 BOM操作
跨站脚本攻击（Cross-site scripting，通常缩写为XSS）是一种常见的网络安全漏洞，攻击者利用这种漏洞在网站上注入恶意的客户端代码。当受害者访问这些页面时，恶意代码会在其浏览器中执行，从而允许攻击者窃取用户的敏感信息，如cookie、会话令牌等，或者以受害者的身份与网站进行交互
XSS攻击可以大致分为三类：
反射型XSS：攻击者通过诱使用户点击一个链接，该链接包含恶意脚本，当用户点击后，恶意脚本随请求发送到服务器，并由服务器响应回用户浏览器执行2。存储型XSS：恶意脚本被存储在目标服务器上，例如在数据库中。当其他用户访问存储了恶意脚本的页面时，脚本会被加载并执行。DOM型XSS：这种类型的XSS发生在客户端，恶意脚本通过修改DOM来执行，不经过服务器的直接响应。 XSS攻击的危害包括但不限于：
盗取用户账号和敏感信息。控制企业数据，包括读取、修改、添加或删除敏感数据。非法转账和强制发送电子邮件。网站挂马和控制受害者机器发起其他攻击。 为了防止XSS攻击，开发者需要掌握一定的HTML前端基础，本章我们来介绍HTML前端基础。
一、HTML概述 1.1 head部分 &lt;title&gt; ：title标签定义文章的标题，显示在浏览器的标题栏和标题页上&lt;meta&gt; ：定义文档的元数据，如字符集声明 &lt;meta charset="UTF-8"&gt; 1.2 body部分 &lt;p&gt; ：段落标签&lt;a&gt; ：超链接标签&lt;img&gt; :图片标签布局标签： 1）&lt;div&gt; 块级标签：属于容器级的标签，div标签定义的是一个区域；加上css样式，实现网页布局重构2)&lt;span&gt;行级标签：属于文本级的标签，只能存放文本，图片，表单元素 三种列表方式：
表格：
form表单：
1.3 HTML特殊符号 在HTML中有些字符是有特殊含义的，不能在浏览器中直接显示出来，例如：
&lt;p&gt;我是&lt;h1&gt;标签&lt;/p&gt; #&lt;h1&gt;被当作主标题 解决方式：实体字符（实体字符有很多，这里只举例左右尖括号）
&lt;p&gt;我是&amp;lt;h1&amp;gt;标签&lt;/p&gt; 二、JavaScript概述 javaScript是一种可以在浏览器中运行的脚本语言。主要用来实现在浏览器端的动作：用户交互、数据处理等。和Java没有关系。
2.1 HTML中JavaScript的存在方式 &lt;script&gt;&lt;/script&gt;标签中 &lt;script&gt; alert('Hello, World!'); &lt;/script&gt; 在&lt;script&gt;的src属性或指定的外部文件中 &lt;script src="script.js"&gt;&lt;/script&gt; 在HTML事件处理器中，如onclock、onmouseover等 &lt;button onmouseover="alert('Mouse over!')"&gt;Hover over me&lt;/button&gt; 2.2 DOM操作 文档对象模型（Document Object Model），访问和操作HTML文档的标准方法，通过利用javascript来访问、操作HTML
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f1757c4cfb294ed8b1d8c7f4b11099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f096d958c421be7bf1f4bb9d5af9cc2/" rel="bookmark">
			在微信小程序中安装和使用vant框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、初始化项目2、安装vant相关依赖3、修改 app.json4、修改 project.config.json5、构建npm6、使用示例 本文将详细介绍如何在微信小程序中安装并使用vant框架～
开发工具：微信开发者工具
1、初始化项目 从终端进入小程序项目目录，执行初始化命令：npm init
初始化之后，会看到项目根目录下多了一个package.json文件：
2、安装vant相关依赖 执行命令以下：
npm i @vant/weapp -S --production npm i miniprogram-sm-crypto --production 执行成功后，会看到项目多了一个node_modules文件夹：
3、修改 app.json 移除： "style": "v2"
原因：小程序强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱。
4、修改 project.config.json 在微信开发者工具创建的项目，miniprogramRoot 默认为 miniprogram，package.json 在其外部，npm 构建无法正常工作。
所以需要手动在 project.config.json 内添加如下配置，使开发者工具可以正确索引到 npm 依赖的位置。
"setting": { "packNpmManually": true, "packNpmRelationList": [ { "packageJsonPath": "./package.json", "miniprogramNpmDistDir": "./miniprogram_npm/" } ] } 5、构建npm 左上角工具 &gt; 构建npm &gt; 构建成功，然后就可以使用组件啦～
6、使用示例 2种方式：全局引入 和 局部引入，其实就是在入口的app.json 或 各子页面.json 配置usingComponents
1）全局使用示例：button
在app.json中引入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f096d958c421be7bf1f4bb9d5af9cc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f177a60bff31ab63a6440421d9bbcd08/" rel="bookmark">
			防止连续点击按钮，多次调用接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防止连续点击按钮，导致多次调用接口问题 文章目录 防止连续点击按钮，导致多次调用接口问题一、为什么需要禁止按钮多次调用问题？二、实现步骤1.使用Vue.directive 自定义指令2.在入口文件main.js引入文件2.使用自定义指令 总结 一、为什么需要禁止按钮多次调用问题？ 因为在很多场景下，都会新增一些案例，如果允许可以多次调用就会出现新增多条同样的数据，还有就是在工作人员操作下会不小心多次点击导致多条同样的数据，会引起误解，因此需要防止连续点击新增/保存按钮多次
二、实现步骤 1.使用Vue.directive 自定义指令 使用自定义指令的好处就是方便简洁，还有就是用的地方比较多，不用到处引入文件,创建一个文件后缀为xxx.js
export default { install(Vue) { // 防止重复点击preventMoreClick 就是自定义命令的名称 Vue.directive('preventMoreClick', { inserted(el, binding) { // 监听事件 el.addEventListener('click', () =&gt; { if (!el.disabled) { el.disabled = true; // 给一个定时器点一次需要多久才可以点从而实现了这个功能 setTimeout(() =&gt; { el.disabled = false; }, 2000); } }); } }); } }; 2.在入口文件main.js引入文件 代码如下（示例）：
j// XXX就是文件名称 import XXX from 'xxx.js'; Vue.use(XXX ); 2.使用自定义指令 &lt;el-button @click='handleClick' v-preventMoreClick&gt;点击这里&lt;/el-button&gt; 总结 提示：这里对文章进行总结：
例如：以上就是今天要讲的内容，就是为简单的简述了自定义指令的用法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ad8835330860a9ce556e79f585eb1e/" rel="bookmark">
			【笔记】Windows 中 一键部署本地私人专属知识库：MaxKB &#43; Docker &#43; MaxKB docker &#43; Ollama
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker的部署： Docker下载直接进入链接：
https://www.docker.com/
Docker使用需要启动Docker,启动Docker以后，会在桌面右下角看到Docker的一个图标：
只有启动了Docker以后，Docker的各种命令才可以使用。
Docker需要开启Hyper-V。一般情况下Hyper-V应该开机自启，但为了防止没有启动，还需要查看下 Hyper-V的启动情况，确保启动后，重启电脑：
找不到的话，应该默认就是开启的。
启动之后，就可以使用Docker的各种命令了：
如果只能看到Client，说明Docker没有启动。需要启动之后才能看到Server.
关于Docker的知识：
镜像（Images）和容器（Containers）是Docker的核心概念。
Docker 和容器不一样，只是容器的一种实现，是一个容器化的解决方案和平台。而容器是一种虚拟化技术，和虚拟机类似，也是一个独立的环境。可以在这个环境中运行应用程序，和虚拟机不同的是，它并不需要在容器中运行一个完整的操作系统，而是使用宿主机的操作系统，所以启动速度非常快。
比如我们一台物理服务器上只能运行几台虚拟机，但是却可以运行上百个容器。
镜像是一Docker的一个只读的模板，可以用来创建容器。容器是Docker的运行实例，它提供一个独立的可移植的环境，可以在这个环境中运行应用程序。
镜像和容器的关系 和 面向对象语言中类和对象关系非常类似。我们可以根据镜像（类）创建多个容器（对象）。镜像也像一道食谱，容器就是根据这个食谱做出来的菜（可以一个或多个），但这些菜都是根据同一道食谱做出来的。你也可以将这个食谱分享给其他人，那么其他人也可以根据这道食谱做出来这道和你做的一模一样的菜。
DockerHub类似于github, 它是一个公共的Docker的仓库，用来集中存储和管理Docker镜像。我们可以在这里下载和上传各种镜像。
Docker是一个 Client-Server
Docker Daemon是一个后台进程，用来接收和处理来自Docker客户端的请求，然后将结果返回给客户端。实际上，我们在终端使用的各种命令，都是发送给Docker Daemon的，经过Docker Daemon处理后，返回给客户端。
容器化和DockerFile的概念：
DockerFile是一个文本文件，里面包含各种指令，用来告诉Docker如何来构建镜像。
Docker 实践：
在桌面创建一个HelloDocker文件夹。
Dockerfile作为一个文件，没有任何扩展名，第一个字母D大写，后面字母小写。这是约定俗成的规范，如果不遵守这个规范，Docker就无法识别这个文件。
我们需要构建一个基础镜像，镜像是按照层次结构来构建的，每一层都是基于上一层的。
编写完Dockerfile
也可以指定Tag版本，在镜像后面加上 :TAG ,用来说明你想找的镜像。
运行Docker镜像：
如果你想使用这个镜像，你可以直接复制这个文件，也可以将这个文件上传到DockerHub上。
我们可以使用
DockerDesktop 的图形化界面：
当我们创建一个容器的时候，它通常以一个干净的文件系统开始，容器启动以后，我们可以在容器中创建文件修改文件。当容器停止以后，容器中的所有数据都会被丢掉。Volumes可以将容器中的目录或者指定路径映射到宿主机的某一个位置和目录上，这样就可以实现数据的持久化，把数据保存到宿主机的磁盘上。
MaxKB的加载： https://github.com/1Panel-dev/MaxKB
查看虚拟化是否可用：
docker run -d --name=maxkb -p 8080:8080 -v ~/.maxkb:/var/lib/postgresql/data 1panel/maxkb # 用户名: admin # 密码: MaxKB@123.. Ollama的安装： https://ollama.com/download
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efcf9d1cc4329043811212c0c76b85d5/" rel="bookmark">
			shell脚本简单命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell脚本 脚本就是可运行代码的集合，脚本语言（计算机语言）脚本的特点：从上到下，按行执行。
python 脚本语言 格式更严谨 严格的执行锁进。也是从上到下按行执行。
shell脚本就是在shell环境（/bin/bash）bash就是shell的解释器。linux环境下的编程语句。
自动化运维。可重复执行的，自动化的在系统中实现增删改查的操作。
shell的解释器，默认就是bash
sh：已经淘汰
bash：sh的扩展版
csh：类c语言
tcsh：整合了c语言的shell
nologin：用户无法登陆到系统的shell
shell的作用： 1、自动化运维
2、批量化的重复操作以及配合定时任务执行。
3、有了脚本就可以减轻管理员的工作量
4、避免配置出错。
5、提高处理批量文件的速度
shell脚本的构成： [root@localhost ~]# cd /opt [root@localhost opt]# vim test.sh #!/bin/bash #声明shell的解释器这一行可以不写，默认就是bash. /python expect，只要不是默认shell，其他的都是声明解释器 #被注释掉的部分是不会被执行的，步骤的含义。 #可执行语句： #this is my first shell cd /boot echo "当前的目录位置：" #echo的作用就是打印 pwd echo"展示其中以vml开头的文件：" ls -lh vml * 第一行：声明解释器（默认就是bash，可以不写）
注释：以#开头，就是注释的信息，注释的部分不会被执行。
可执行语句：linux的命令都可以作为可执行语句，一行一行的往下写。一行就是一个可执行的语句。
shell的运行方式： 3种：
第一种：不给脚本执行权限的执行方式：
sh：就是在当前的shell里生成一个子shell，运行的结果不改变父shell的环境。
source：点命令，他会改变当前shell的环境，也就是真正的执行代码。
bash：就是在当前的shell里生成一个子shell，运行的结果不改变父shell的环境。
第二种：赋权执行
脚本调试完毕，都是赋权执行。
chmod 777 test.sh
#执行语句 ./test.sh ​ /opt/test.sh ​ source /opt/test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efcf9d1cc4329043811212c0c76b85d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03b881cf2c248d9d5ddc3b56a238fcb/" rel="bookmark">
			苹果AI一夜颠覆所有，Siri史诗级进化，内挂GPT-4o
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果AI一夜颠覆所有，Siri史诗级进化，内挂GPT-4o 刚刚，苹果AI，正式交卷！
今天，苹果构建了一个全新AI帝国——个人化智能系统Apple Intelligence诞生，智能助手Siri迎来诞生13年以来的史诗级进化，打通苹果全家桶系统。
今天加州现场的阳光明媚又热烈，将衣服晒得滚烫。在动感的暖场音乐后，库克出来跟现场观众交流互 动，之后整个Keynote所有现场媒体和开发者仍然是围坐在一起“看录播视频”。
联手OpenAI尘埃落定无需注册、Siri实时调用GPT-4o 对于苹果AI在合作方面的一些进展苹果也在今天做了重要官宣。
除了自家大模型，苹果还将Siri变成使用外部模型的入口，这些外部模型的能力会全部融入用户的使用体验中。
苹果与OpenAI此前盛传已久的合作终于尘埃落定，苹果首选了GPT-4o作为外部大模型之一。
首先，Siri支持调用GPT，例如需要菜品灵感、家装建议等，都可以让GPT直接给出答案，不止文字、照片，就连文档、PPT、PDF都可以直接提问。
值得注意的是，每次调用GPT出场时，Siri都需要征求用户的同意，再将相关信息分享给GPT。
此外，苹果将GPT融入了全系统适用的书写工具中。其编写功能让用户分分钟搞定带插图的睡前小故事。
苹果对于大模型的调用将免费、方便贯彻到底，用户不必创建账户就可以免费使用GPT，GPT订阅用户也能关联自己的账户，并在苹果设备中使用相关产品时接入付费功能。
GPT将集成在iOS 18、iPadOS 18和macOS Sequoia中，今年稍晚推出。未来苹果还会增加对其他AI模型的支持。
GPT4o，国内可免费体验 在我做的 gpt 国内官网：https://chatgpt-plus.top/ 已经上线，需要4o授权码可私信我获取
欢迎大家前来体验，感受智能语言的魅力！期待与大家一起探索更多可能！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254502a9af254a433427a5f9bf64f4d8/" rel="bookmark">
			各大AI预测2024年广东省高考状元将会出在哪个高中？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【开放猫AI导读】2024年高考即将结束，那么广东省的高考状元会出自哪个高中呢？我把这个问题丢给各大AI，看看到底哪些高中在他们眼里是最好的！
一、Chat GPT
Chat GPT预测的2024年广东省高考状元最有可能出现在以下的三个高中：
广州市第六中学： 概率40%
广州市实验中学： 概率30%
深圳中学： 概率20%
二、Gimini
Gimini预测的2024年广东省高考状元最有可能出现在以下的三个高中：
广州市第六中学： 概率35%
广州市实验中学： 概率25%
深圳中学： 概率20%
三、腾讯元宝
腾讯元宝预测的2024年广东省高考状元最有可能出现在以下的三个高中：
华南师范大学附属中学
广东省实验中学
深圳市深圳中学
四、百度文心一言
百度文心一言预测的2024年广东省高考状元最有可能出现在以下的三个高中：
珠海一中：概率35%
潮阳实验学校： 概率30%
广东外语外贸大学附属中学： 概率25%
五、Kimi
Kimi预测的2024年广东省高考状元最有可能出现在以下的三个高中：
珠海一中： 概率35%
华南师范大学附属中学： 概率25%
深圳外国语学校： 概率20%
六、字节火山写作
字节火山写作没有给出具体的预测排名，根据过往经验广东省高考状元可能会出现在以下的三个高中：
珠海一中
华南师范大学附属中学
深圳外国语学校
七、讯飞星火 讯飞星火没有给出具体的预测排名，根据过往经验广东省高考状元可能会出现在以下的三个高中：
华南师范大学附属中学
广东省实验中学
深圳中学
八、智谱清言
智谱清言没有给出具体的预测排名，根据过往经验广东省高考状元可能会出现在以下的三个高中：
华南师范大学附属中学
深圳中学
广东省实验中学
【开放猫总结】以上每个AI大模型的预测结果都有所不同，如果我们把以上AI的预测结果做简单分析，2024广东省高考状元出现的概率将会是以下排名：
AI预测的2024年广东省高考状元出现的中学出现的次数华南师范大学附属中学5深圳中学5广东实验中学3珠海一中3广州市第六中学2广州市实验中学2深圳外国语学校2潮阳实验学校1广东外语外贸大学附属中学1 所以在开放猫看来，2024年广东省高考状元最有可能出现在华南师范大学、深圳中学、广东省实验中学等高中。
你觉得2024年广东省高考状元会来自哪个中学呢？也欢迎大家留言讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2e529701f5d13051ae55c59cafaf25/" rel="bookmark">
			【C#】pdf按页分割文件，以及分页合并，效果还不错，你值得拥有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》
这是《C#》系列文章，每篇文章将以博主理解的角度展开讲解。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 背景效果单页分割文件合并多页分割插件说明相关文章 背景 最近遇到一个文件上传限制大小问题，
因为有哪些pdf文件可能有300多页，大小已经有100MB，
但是有些文件上传限制大小在10MB以内，
因为本篇文章将简单讲讲如何将大文件通过分页分割和合并。
效果 下面就是通过pdf插件进行按页进行文件分割输出
单页分割 插件命名空间
using iTextSharp.text; using iTextSharp.text.pdf; 目标分割pdf文件、创建输出文件所在的文件夹、iTextSharp插件操作pdf分割
// 目标分割pdf文件 string inputFilePath = @"你自己的pdf文件物理路径.pdf"; // 创建输出文件所在文件夹 string outputFolder = "NewFile"; string rootPath = System.IO.Directory.GetCurrentDirectory(); string folderAll = Path.Combine(rootPath, outputFolder); if (!Directory.Exists(folderAll)) { Directory.CreateDirectory(folderAll); } // 操作pdf分割 using (PdfReader reader = new PdfReader(inputFilePath)) { for (int i = 1; i &lt;= reader.NumberOfPages; i++) { string newFilePath = Path.Combine(outputFolder, $"page_{i}.pdf"); using (Document document = new Document()) using (PdfCopy copy = new PdfCopy(document, new FileStream(newFilePath, FileMode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2e529701f5d13051ae55c59cafaf25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ee7e2793506e80547b7401d2511913/" rel="bookmark">
			Stable diffusion的SDXL模型，针不错！（含实操）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与之前的SD1.5大模型不同，这次的SDXL在架构上采用了“两步走”的生图方式：
以往SD1.5大模型，生成步骤为 Prompt → Base → Image，比较简单直接；而这次的SDXL大模型则是在中间加了一步 Refiner。Refiner的作用是什么呢？简单来说就是能够自动对图像进行优化，提高图像质量和清晰度，减少人工干预的需要。
简单来说，SDXL这种设计就是先用基础模型（Base）生成一张看起来差不多的图片，然后再使用一个图像精修模型（Refiner）进行打磨，从而让图片生成的质量更高。而在没有这个之前，我们往往需要通过其他手段，如高清修复或面部修复来进行调优。
除了有出图质量更高这个优势，SDXL还有以下优点：
支持更高像素的图片（1024 x 1024）
对提示词的理解能力更好，比较简短的提示词也能达到不错的效果
相比SD1.5模型，在断肢断手多指的情况上有所改善
风格更为多样化
当然，每件事物不可能是完美的，所以SDXL也有一些局限性：
1、低像素出图质量不高
由于SDXL都是用1024x1024的图片训练的，这既导致它在这个像素级别上生成的质量比较高。但同时也导致了它在低像素级别（如512x512）生成的质量反而比较低，甚至不如SD1.5等模型。
2、与旧Lora不兼容
过去一些适用于SD1.5, 2.x 的Lora和ControlNet模型，大概率无法使用，得重新找一些带有SDXL的模型
3、对GPU显存的要求更高（这个下面会着重讲到）
4、出图时间也变久了
好了，简单讲完了SDXL大模型以及它的优缺点，接下来就开始实战了！
一、模型的下载 这次模型的下载有点不同，因为我们需要下载三个模型，分别是：sd_xl_base_1.0.safetensors、[1]sd_xl_refiner_1.0.safetensors 和 [2]sdxl_vae.safetensors[3] 。
三个模型的地址分别是：
https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/tree/main
https://huggingface.co/stabilityai/stable-diffusion-xl-refiner-1.0/tree/main
https://huggingface.co/stabilityai/sdxl-vae/tree/main
二、模型的加载 如果你的模型下载好了，就把 sd_xl_base_1.0.safetensors、sd_xl_refiner_1.0.safetensors 丢到根目录的 models\Stable-diffusion，把 sdxl_vae.safetensors 丢到 models\VAE 即可。
需要注意的是 Refiner 模型的加载，看发布日志是 SD1.6.0 的时候才支持，所以如果想使用的话得看你的版本有没有达到。另外就是这里的SD1.6.0指的是内核的版本，并不是模型的版本（不要被各种简写误导了）
内核的版本指的是这里的版本
还有一个需要注意的是貌似升级版本容易有一些不兼容的问题，而且在使用SDXL大模型时也不一定就得用Refiner，单纯使用基础模型（base）也是OK的，只不过效果会差点，所以建议升级前也做一下调研工作。
最后Refiner的位置可能没那么显眼，在生成选项卡里面
三、显存的大小 由于SDXL的模型和出图尺寸比之前的SD1.5大得多，所以也间接导致了它在出图方面所需要的显存和时间也变大了。
那到底需要多少显存呢？网上有一个说法是：跑SDXL最低显存是8G。经过我的测试，这个数据具有一定参考性，在进行一些优化的情况下，8G的显存的确能跑；但如果你什么优化都不做的话，8G的显存是不够的。
我自己的显卡是4060Ti 16G，内存32G，在这个配置的基础上我做了几个小测试（都是1024 x 1024的尺寸）
提示词：
a beatuiful real female play guitar
3.1 不开任何优化 + 不使用Refiner
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ee7e2793506e80547b7401d2511913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb7b8a46bac98bd7a4ffab654c1e306c/" rel="bookmark">
			15. 《C语言》——【如何动态内存开辟】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲爱的读者，大家好！我是一名正在学习编程的高校生。在这个博客里，我将和大家一起探讨编程技巧、分享实用工具，并交流学习心得。希望通过我的博客，你能学到有用的知识，提高自己的技能，成为一名优秀的程序员。如果你有任何疑问或建议，请随时在评论区留言，让我们一起成长进步！现在，让我们开始这场知识之旅吧！
🚀个人主页：FEN03
📚收入专栏：C语言
文章目录 📚前言📘1. 为什么要动态内存分配❓📗2. 如何去动态内存开辟❓🔖2.1 malloc🔖2.2 free🔖2.3 calloc🔖2.4 realloc 👋结束语 📚前言 为什么需要动态内存开辟，如何向内存申请空间？接下来，就让我们去探讨吧~
📘1. 为什么要动态内存分配❓ 在先前，我们开辟内存的方法无非是在栈区创建一个变量，或者说一个数组。
#include&lt;stdio.h&gt; int main() { int a = 0; //在栈区开辟了4个字节的空间 int arr[10] = { 0 }; //在栈区开辟了40个连续字节的空间 return 0; } 这2种内存开辟，都存在着2种特点：
内存开辟的大小是固定的了。数组在创建时，必须是指定它的长度，一旦确定大小后不能再进行更改。 为了迎合更高的要求，上述的情况就不能满足了。那么为了解决这一问题，C语言引入了动态内存开辟，这样程序员就可以灵活的去申请和释放空间。
那么接下来就让我们探索如何去动态的向内存开辟。
📗2. 如何去动态内存开辟❓ 那么为了实现动态内存的开辟，C语言提供了4个函数，那么接下来，就让我们去学习如何使用这些函数吧~⬇️
🔖2.1 malloc 为了实现动态内存开辟，C语言提供了malloc函数。
函数语法形式：
void* malloc (size_t size); 这个函数能够向内存开辟一块连续可用的空间，并且会返回指向这块内存空间的指针。
如果内存开辟成功，则会返回指向这块开辟好的内存的指针。如果内存开辟失败，则会返回NULL，所以当我们使用malloc函数时，一定要检查是否开辟成功。malloc函数的返回类型是void* ，这是因为malloc函数并不知道程序员要开辟内存空间的类型，所以当程序员使用时由自己决定返回类型。如果size为0，这一行为是标准未定义的，而且也没必要，最终的结果也是编译器决定的。 使用malloc函数需要包含头文件：
#include&lt;stdlib.h&gt; 我们可以使用malloc来开辟下内存空间：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { //向内存开辟40个字节 int*p = (int*)malloc(10 * sizeof(int)); //使用if语句来判断是否开辟成功，如果失败则提示错误信息以及提前结束 if (p == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb7b8a46bac98bd7a4ffab654c1e306c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f611db9f3b708e83bb9ebbe37a575d/" rel="bookmark">
			JSONObject.toJSONString(***) json化后的值中的日期值被转换为时间戳？如何修改？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当处理 JSON 数据时，有时我们需要自定义日期类型的序列化方式，以保留原有的日期时间数据格式而不是将其转换为时间戳。在 Java 中，我们可以利用 Jackson 库来实现这一需求。
首先，我们需要自定义一个 JsonSerializer 类，用于将 Date 类型序列化为指定的日期格式字符串。接着，我们需要注册这个自定义模块，确保日期类型字段被序列化为指定格式的日期字符串。
下面是一个具体的示例代码：
import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.SerializerProvider; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Map; public class DateSerializer extends JsonSerializer&lt;Date&gt; { private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); @Override public void serialize(Date date, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeString(dateFormat.format(date)); } } public class Main { public static void main(String[] args) { ObjectMapper objectMapper = new ObjectMapper(); SimpleModule module = new SimpleModule(); module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f611db9f3b708e83bb9ebbe37a575d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c87d53c8f28fdff6c0d1a4e0cc7e0e/" rel="bookmark">
			普通人想要自学ai，该如何入手，看完这篇你就懂了，零基础教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学会了AIGC之后，我只想说：无敌是多么寂寞？
之前我整理一篇会议记录起码要2小时。现在交给AI ，5分钟搞定；
之前整理账目总是出错，现在利用AI财务整合器，轻松解决统计难题；
之前写个短视频脚本，憋的脑袋通红，现在用AI，20秒生成一篇优质文案。
在我看来，AIGC像一个魔法师，随便你要什么东西，它都能变出来，包括变现。
我是年前学的AIGC，刚学完没多久，领导要给我升职加薪，碰巧那时候有一个猎头正在挖我，薪资是我当时的三倍，我当然向钱看齐。
别人35岁要么失业，要么007卷上天，我35岁依靠AIGC，升职加薪，逆天改命。
学会了AIGC之后，我只想说：无敌是多么寂寞？
之前我整理一篇会议记录起码要2小时。现在交给AI ，5分钟搞定；
之前整理账目总是出错，现在利用AI财务整合器，轻松解决统计难题；
之前写个短视频脚本，憋的脑袋通红，现在用AI，20秒生成一篇优质文案。
在我看来，AIGC像一个魔法师，随便你要什么东西，它都能变出来，包括变现。
我是年前学的AIGC，刚学完没多久，领导要给我升职加薪，碰巧那时候有一个猎头正在挖我，薪资是我当时的三倍，我当然向钱看齐。
别人35岁要么失业，要么007卷上天，我35岁依靠AIGC，升职加薪，逆天改命。
不过话说回来，既然AIGC这么强大，那它的前景怎么样呢？
据我了解，AIGC行业在国内的市场容量正在迅速增长。2022年AIGC行业核心市场规模为11.5亿元，预计到今年年底，这一数字将增长至200亿元。更为显著的是，到2030年，AIGC行业的市场规模有望超过10000亿亿元。这显示了AIGC行业在国内市场的巨大潜力和增长前景。
不仅行业前景好，薪资也遥遥领先，AIGC行业的平均工资年薪一般在20万到50万元人民币之间。具体的薪资水平会受到多种因素的影响，在一线城市，AIGC行业的平均工资年薪普遍超过30万元。即使是二线或三线城市，工资水平也在15万到30万元之间。
可以看出，AIGC绝对算得上是蓝海，行业内顶尖人才少，市场需求量大，平均学习半年就能从事这个行业，不需要计算机基础，更没有专业限制，只要你想学，学成转行，升职加薪不是难事。
我就是在认识到这个“商机”之后，决定从前端，转行做AIGC工程师，35岁的年龄，再为自己搏一把。
我的学习路线大概就是这样，跟着课程学习3个月后，创作的作品被甲方爸爸看中，被高价买走，我不仅获得一大笔原创费用，也算是抛出了橄榄枝，让猎头注意到了我。
跳槽转行后，我的工资翻了整整三倍，从一个苦逼的前端工程师，摇身一变成了行业内炙手可热的AIGC工程师。
(仅代表个人收益，具体收益因人而异)
AI 给我带来的红利太多了，就像我文章开头说的，从前整理一份会议纪要要2小时，现在只需要5分钟，效率提高了几百倍，什么档次不用我多说。
除此之外还有更多AI多种新的变现方式，以下是其中的一些例子：
AI绘画创作：stablediffusion绘画能够快速生成各种风格的插画、设计作品，为艺术家和设计师提供了新的创作途径。这种技术可以用于服装设计、包装设计、电商模特换装、海报、logo、UI、二维码、PPT等多种平面设计图的制作，从而产生了多种商业变现方式。
AI自媒体：AI在自媒体领域的应用也日益广泛。例如，AI可以协助创作情感类、历史类、热点新闻类等公众号文章，这些文章可以吸引大量流量，进而通过广告等方式变现。此外，AI还可以用于生成小说、漫画、表情包、儿童绘本等内容，这些都可以成为创作者新的收入来源。
AI内容创作：AI不仅可以在自媒体领域发挥作用，还可以用于策划网站内容、博客、销售内容、电子邮件、社交媒体帖子等。通过提供高质量的内容，AI可以帮助企业吸引更多的潜在客户，提高转化率，从而实现商业变现。
AI聊天机器人：聊天机器人已经成为市场的新趋势，它们可以通过提供一流的效率和个性化服务来彻底改变行业。企业可以利用AI聊天机器人来增强客户服务，提高客户满意度，进而增加销售额和利润。
AI模型的多模态应用：传统的AI模型主要处理单一模态的信息，而现在的多模态深度学习技术使得AI模型能够处理来自不同模态的信息，如将文本“翻译”成图像，或将图像变成视频等。这种技术可以应用于多个领域，如广告、娱乐、教育等，为这些领域带来新的商业机会。
总之，随着AI技术的不断发展，新的变现方式将不断涌现。对于企业和个人来说，了解并掌握这些新的变现方式将有助于在竞争激烈的市场中脱颖而出。
最后想说 AIGC（AI Generated Content）技术，即人工智能生成内容的技术，具有非常广阔的发展前景。随着技术的不断进步，AIGC的应用范围和影响力都将显著扩大。以下是一些关于AIGC技术发展前景的预测和展望：
1、AIGC技术将使得内容创造过程更加自动化，包括文章、报告、音乐、艺术作品等。这将极大地提高内容生产的效率，降低成本。2、在游戏、电影和虚拟现实等领域，AIGC技术将能够创造更加丰富和沉浸式的体验，推动娱乐产业的创新。3、AIGC技术可以帮助设计师和创意工作者快速生成和迭代设计理念，提高创意过程的效率。
未来，AIGC技术将持续提升，同时也将与人工智能技术深度融合，在更多领域得到广泛应用。感兴趣的小伙伴，赠送全套AIGC学习资料和安装工具，包含AI绘画、AI人工智能等前沿科技教程。
对于从来没有接触过AI绘画的同学，我已经帮你们准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
AIGC学习必备工具和学习步骤
工具都帮大家整理好了，安装就可直接上手
现在AI绘画还是发展初期，大家都在摸索前进。
但新事物就意味着新机会，我们普通人要做的就是抢先进场，先学会技能，这样当真正的机会来了，你才能抓得住。
如果你对AI绘画感兴趣，我可以分享我在学习过程中收集的各种教程和资料。
学完后，可以毫无问题地应对市场上绝大部分的需求。
这份AI绘画资料包整理了Stable Diffusion入门学习思维导图、Stable Diffusion安装包、120000+提示词库，800+骨骼姿势图，Stable Diffusion学习书籍手册、AI绘画视频教程、AIGC实战等等。
【Stable Diffusion安装包（含常用插件、模型）】
【AI绘画12000+提示词库】
【AI绘画800+骨骼姿势图】
【AI绘画视频合集】
还有一些已经总结好的学习笔记，可以学到不一样的思路。
实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5320dc75c59b77d06d6a6e7bcc825ab/" rel="bookmark">
			MySQL周内训参照1、ER实体关系图与数据库模型图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求详情地址：04-MySQL比赛内容与要求细则
编号人员题目总分数题干提交内容得分标准1产品经理绘制ER图10使用工具统一版本viso2013
要求创建的实体有：
1、用户表(user)、用户钱包表(user_wallet)(与user是1对1关系)、用户钱包交易日志表(user_wallet_log)(与user是1对多关系)。
2、商品类别表(product_type)(与product是1对多关系)、商品表(product)。
3、订单表(order)(与product是1对多关系)、订单详情表(order_info)。
4、需要独立完成实体属性的分析、外键关系连接、表之间关联关系说明。ER图图片1、共计7个实体，用户系列1分，商品系列1分，订单系列1分(共3分)。
2、保障所有主外键属性基础连接，所有表一条连接3分，2条连接2分，3条连接1分，3条连接以上不得分（共3分）。
3、合理属性添加，每张表需要有必备的3条以上基础属性，合理即可，有任何一个无用或不合理属性扣1分，抠完为止。(共3分)。
4、标明一对一或一对多关系合理即得分，错误1项不得分(1分)。2产品经理数据库模型图10使用工具统一版本viso2013
需要根据绘制的ER图来完成数据库模型图，要求有：
1、表的属性与ER图表中显示属性要求一致。
2、表之间连线主外键关系明确。
3、连接线标明一对一，一对多关系。
4、连接线连接合理，且没有堆叠情况。数据模型图图片1、共计7个实体的属性与ER图一致，少一个扣1分，多一个扣1分(共3分)。
2、表之间的主外键关有明确的标识，少一处扣1分，多一个扣1分(共3分)。
3、一对一，一对多关系明确，错误一处扣1分(共2分)。
4、连接线连接合理，无堆叠情况（2分）。 ER图是什么? ER 图即实体-关系图（Entity Relationship Diagram）。
它是用来描述现实世界中实体及其相互关系的一种概念模型工具。
在 ER 图中，用【矩形】表示实体，【椭圆】表示实体的属性，【菱形】表示实体之间的关系，并通过连线(直线)来表明它们之间的关联。
ER 图有助于清晰地展现数据库中所涉及的各种对象及其之间的联系，对于数据库设计等具有重要意义，可以帮助设计人员更好地理解业务需求和数据结构，从而更合理地规划数据库的结构和内容。
ER图绘制工具 PowerDesigner：功能强大，支持多种模型的设计。
Visio：微软的绘图工具，广泛应用于各种图表绘制，包括 ER 图。
ERwin：专门用于数据库设计和 ER 图绘制的工具。
MySQL Workbench：针对 MySQL 数据库的工具，也可绘制 ER 图。
DbSchema：不仅能绘制 ER 图，还具有数据库管理等功能。
这里我们采用【Visio】来绘制我们的ER图。
visio2013安装以及安装问题说明-ER图与数据库模型图绘制示例 visio2013安装以及安装问题说明-ER图与数据库模型图绘制示例
Chen's 数据库表示法——ER图绘制使用形状 在设计中可以修改纸张方向和纸张大小。
Crow's Foot数据库表示法——数据库模型图使用形状 这里需要注意外键需要自己添加一下，连线的时候注意美观。
关系表示——显示多重性 这里可以使用文本自己写，也可以在连接线上点击鼠标右键，选择显示多重性来修改。
属性分析 1、用户表(user)、用户钱包表(user_wallet)(与user是1对1关系)、用户钱包交易日志表(user_wallet_log)(与user是1对多关系)。
user：用户表通常包含用户的基本信息，例如用户ID（主键）、用户名、密码（通常加密存储）、邮箱、手机号、创建时间等。
属性设计：
user_id: 用户ID（主键，自增）
username: 用户名（唯一）
password: 密码（加密存储）
email: 邮箱（唯一）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5320dc75c59b77d06d6a6e7bcc825ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4916cf45bfb2d846eb9a1f0d21ffbb/" rel="bookmark">
			【python】在【机器学习】与【数据挖掘】中的应用：从基础到【AI大模型】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
💗一、Python在数据挖掘中的应用💕
💖1.1 数据预处理💞
数据清洗💞
数据变换💞
数据归一化💞
高级预处理技术💞
💖1.2 特征工程💕
特征选择💕
特征提取💕
特征构造💕
💗二、Python在机器学习中的应用💕
💖2.1 监督学习💞
分类💞
回归💞
💖2.2 非监督学习💞
聚类💞
降维💞
💗三、Python在深度学习中的应用💕
💖3.1 深度学习框架💞
TensorFlow💞
PyTorch💞
💗四、Python在AI大模型中的应用💕
💖4.1 大模型简介💞
💖4.2 GPT-4o实例💞
💗五、实例验证💕
💖5.1 数据集介绍💞
💖5.2 模型构建与训练💞
💖5.3 模型优化💞
💗六.深度扩展与具体实例💕
💖1.数据预处理扩展：💞
缺失值填补💞
异常值检测与处理💞
数据增强💞
💖2.特征工程扩展：💞
💖3.模型选择与评估：💞
💖4.深度学习实例：💞
💖5.AI大模型应用：💞
💖6.进一步实例验证与优化：💞
💗总结💕
在大数据时代，数据挖掘与机器学习成为了各行各业的核心技术。Python作为一种高效、简洁且功能强大的编程语言，得到了广泛的应用。
💗一、Python在数据挖掘中的应用💕 💖1.1 数据预处理💞 数据预处理是数据挖掘的第一步，是确保数据质量和一致性的关键步骤。良好的数据预处理可以显著提高模型的准确性和鲁棒性。
数据清洗💞 数据清洗是数据预处理的重要组成部分，主要包括去除缺失值、去除重复值和处理异常值。
import pandas as pd # 读取数据 data = pd.read_csv('data.csv') # 数据清洗 data = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da4916cf45bfb2d846eb9a1f0d21ffbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ee0479e0e29561446e45d206fa014f/" rel="bookmark">
			短剧片源火爆，千金难求好剧源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在当今快节奏的生活中，短剧以其精悍的篇幅、吸睛的剧情和便捷的观看方式，异军突起，吸引了大量观众的关注和喜爱。这些短剧不仅让人们在忙碌的间隙轻松娱乐，更以其高潮迭起的情节设计，让观众在短时间内便能体验到极致的观剧感受。正因如此，短剧片源的需求量节节攀升，市场潜力显现出巨大的增长空间。
一、为什么要获取更多片源？ 对于许多想要涉足短剧市场的从业者来说，热门短剧的片源却成了一大难题。毕竟，优质的短剧内容是吸引观众的关键，而热门片源往往掌握在少数人手中，获取不易。拥有更多的片源，能更好地提升平台的竞争力。
二、更多的片源能带来什么效益？ 片源的增加，既得益于市场竞争的推动，也与短剧市场的特性密不可分。为了扩大市场份额，片源持有者往往愿意以更优惠的价格授权给有实力的合作伙伴，从而共同将短剧市场这块蛋糕做大。同时，短剧市场的多样性也决定了授权价格的灵活性。片源类型众多，从都市情感到古装奇幻，从轻松喜剧到悬疑推理，应有尽有。这种多样性不仅满足了不同观众的口味需求，也为从业者提供了更多的选择空间，使得他们能够在控制成本的同时，精准定位自己的目标受众。
总结 热门短剧片源的易得与授权价格的优惠，无疑为那些有志于在短剧市场大展拳脚的从业者提供了难得的机遇。抓住了这一波浪潮，便有可能在激烈的市场竞争中脱颖而出，成为短剧市场的新领军者。
了解更多内容请关注“云云圈子”回复“888”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a1b8190468b7c95c54101750f1553f/" rel="bookmark">
			使用seq2seq架构实现英译法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		seq2seq介绍 模型架构：
Seq2Seq（Sequence-to-Sequence）模型是一种在自然语言处理（NLP）中广泛应用的架构，其核心思想是将一个序列作为输入，并输出另一个序列。这种模型特别适用于机器翻译、聊天机器人、自动文摘等场景，其中输入和输出的长度都是可变的。
embedding层在seq2seq模型中起着将离散单词转换为连续向量表示的关键作用，为后续的自然语言处理任务提供了有效的特征输入。 数据集 下载: https://download.pytorch.org/tutorial/data.zip
🍸️步骤：
基于GRU的seq2seq模型架构实现翻译的过程:
导入必备的工具包.对文件中数据进行处理，满足模型训练要求.构建基于GRU的编码器和解码构建模型训练函数，并进行训练构建模型评估函数，并进行测试以及Attention效果分析 # 从io工具包导入open方法 from io import open # 用于字符规范化 import unicodedata # 用于正则表达式 import re # 用于随机生成数据 import random # 用于构建网络结构和函数的torch工具包 import torch import torch.nn as nn import torch.nn.functional as F # torch中预定义的优化方法工具包 from torch import optim # 设备选择, 我们可以选择在cuda或者cpu上运行你的代码 device = torch.device("cuda" if torch.cuda.is_available() else "cpu") 数据预处理 将指定语言中的词汇映射成数值💫
# 起始标志 SOS_token = 0 # 结束标志 EOS_token = 1 class Lang: def __init__(self, name): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a1b8190468b7c95c54101750f1553f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7da14cfd9167155003318fb370775c1/" rel="bookmark">
			Python：基础&amp;爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python爬虫学习（网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。）
python学习资料已打包好，需要的小伙伴可以戳这里【python资料】
一、基础知识准备 Python在各个编程语言中比较适合新手学习，Python解释器易于扩展，可以使用C、C++或其他可以通过C调用的语言扩展新的功能和数据类型。Python也可用于可定制化软件中的扩展程序语言。Python丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。
1 条件判断语句 score = 60 if score &gt;=90 and score &lt;=100: print("本次考试等级为A") elif score &gt;=70 and score &lt;90: #elif == else if print("本次考试等级为B") else: print("本次考试等级为C") #output: 本次考试等级为C 2 循环语句 2.1 for循环 for i in range(5): #输出5个数 [0 1 2 3 4] print(i) for i in range(0,10,3):#从[0,10)，以3为间距输出 #output: [0 3 6 9] print(i) for i in range(-10,-100,-30):#从[-10，-100)，以-30为间距 #output: [-10 -40 -70] print(i) name="chengdu" for x in name: print(x) #output: [c h e n g d u] a = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7da14cfd9167155003318fb370775c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071edf7c1095dccd858b36095b3354be/" rel="bookmark">
			设计模式学习（二）工厂模式——工厂方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设计模式学习（二）工厂模式——工厂方法模式 前言工厂方法模式简介示例优点缺点使用场景 前言 前一篇文章介绍了简单工厂模式，提到了简单工厂模式的缺点（违反开闭原则，扩展困难），本文要介绍的工厂方法模式在一定程度上弥补了简单工厂模式的缺点。
工厂方法模式 简介 工厂方法模式是创建型设计模式之一，它在抽象工厂类中声明创建对象的接口，在具体工厂类中实现具体的实例化过程。这个模式的核心思想是将对象的实例化延迟到子类中进行，从而使得父类通过其子类来指定创建哪个对象，实现了类的实例化操作的封装和数据的封装。
这样的话，当要添加一个具体产品时，我们不会修改原有的工厂类（不违反开闭原则），而是新创建一个关联于具体产品的具体工厂类（易扩展）。
示例 抽象相机类：CameraDevice
具体相机类：BaslerCameraDevice，SickCameraDevice，HuarayCameraDevice
抽象工厂类：CameraDeviceFactory
具体工厂类：BaslerCameraFactory，SickCameraFactory，HuarayCameraFactory
UML类图如下：
代码如下：
// 抽象产品类 class CameraDevice { public: CameraDevice() = default; virtual ~CameraDevice() = 0; virtual bool Init(){}; virtual bool OpenDevice() = 0; }; class BaslerCameraDevice : public CameraDevice { public: ~BaslerCameraDevice() override; bool Init() override{}; bool OpenDevice() override{}; }; class HuarayCameraDevice : public CameraDevice { public: ~HuarayCameraDevice() override{}; bool Init() override{}; bool OpenDevice() override{}; }; class SickCameraDevice : public CameraDevice { public: ~SickCameraDevice() override{}; bool Init() override{}; bool OpenDevice() override{}; }; // 抽象工厂类 class CameraDeviceFactory { public: virtual std::shared_ptr&lt;CameraDevice&gt; CreateCamera() = 0; }; // 具体工厂类 class BaslerCameraFactory : public CameraDeviceFactory { public: std::shared_ptr&lt;CameraDevice&gt; CreateCamera() override { return std::make_shared&lt;BaslerCameraDevice&gt;(); } }; class HuarayCameraFactory : public CameraDeviceFactory { public: std::shared_ptr&lt;CameraDevice&gt; CreateCamera() override { return std::make_shared&lt;HuarayCameraDevice&gt;(); } }; class SickCameraFactory : public CameraDeviceFactory { public: std::shared_ptr&lt;CameraDevice&gt; CreateCamera() override { return std::make_shared&lt;SickCameraDevice&gt;(); } }; int main() { std::shared_ptr&lt;CameraDeviceFactory&gt; factory = std::make_shared&lt;BaslerCameraFactory&gt;(); std::shared_ptr&lt;CameraDevice&gt; camera = factory-&gt;CreateCamera(); camera-&gt;Init(); camera-&gt;OpenDevice(); return 0; } 优点 解耦：工厂方法模式可以减少客户代码与具体类之间的耦合。客户端在使用的时候只需知道接口，而不是具体类。这样可以更容易地扩展或修改创建逻辑，而无需修改现有客户代码。符合开闭原则：工厂方法模式允许系统在不修改现有代码的情况下引入新的类型。满足对扩展开放，对修改封闭的原则。单一职责原则：工厂方法模式中，创建对象的逻辑被封装在一个工厂类中，这符合单一职责原则。这让代码更加清晰，维护也更简单。 缺点 代码复杂：工厂方法模式为每种产品类型提供一个单独的工厂类。这意味着每增加一个新的产品类别，就需要增加一个新的具体工厂类。这会导致类的数量迅速增加，从而增加了代码的复杂性代码冗余：如果具体工厂类之间的创建逻辑相似，这可能会导致代码冗余。虽然每个工厂类只负责创建一个具体产品，但这些工厂类的创建逻辑可能高度相似，不能有效地重用代码。 使用场景 产品类别经常变化：一个系统会频繁添加或修改产品的创建，而每种产品的创建又有不同的复杂配置和依赖时，工厂方法可以将具体产品的创建逻辑封装在各自的工厂类中，从而简化客户端代码。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/280/">«</a>
	<span class="pagination__item pagination__item--current">281/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/282/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>