<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a20f412b76c2a52191a7468f0eb468c3/" rel="bookmark">
			掌握Perl的文件系统钩子：深度集成的艺术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🪝 掌握Perl的文件系统钩子：深度集成的艺术 在Perl编程中，文件系统钩子（File System Hooks）是一种强大的功能，它们允许开发者在文件操作发生时介入并执行自定义代码。这种机制对于实现诸如日志记录、权限检查、文件锁定等特性至关重要。本文将深入探讨如何在Perl中实现自定义的文件系统钩子，通过详细的步骤、丰富的代码示例，教您如何利用Perl的灵活性监控和干预文件系统事件。
🌐 Perl文件系统钩子概述 Perl的文件系统钩子是通过fcntl函数和Fcntl模块实现的，它们可以用来设置和管理文件描述符的标志。
🏗️ 文件系统钩子的基础 在Perl中实现文件系统钩子，需要以下基础知识：
文件描述符：文件操作的标识符。fcntl函数：用于执行文件控制操作。Fcntl模块：提供文件控制相关的常量和函数。 🛠️ 使用Fcntl模块设置钩子 Fcntl模块提供了设置和管理文件系统钩子所需的常量和函数。
步骤1：引入Fcntl模块 use Fcntl; 步骤2：打开文件并获取文件描述符 open(my $fh, '+&lt;', 'example.txt') or die "Cannot open file $!"; 步骤3：使用fcntl设置钩子 my $oldflags = fcntl($fh, F_GETFL, 0) or die "Cannot get flags $!"; fcntl($fh, F_SETFL, $oldflags | O_NONBLOCK) or die "Cannot set flags $!"; 🔗️ 创建自定义的文件操作钩子 自定义钩子可以通过在文件操作前后执行特定代码来实现。
代码示例：自定义读取钩子 sub custom_read_hook { my ($fh, $buffer, $length, $offset) = @_; # 在读取之前执行的操作 print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a20f412b76c2a52191a7468f0eb468c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4d873175e26df2f3f465b25049f175e/" rel="bookmark">
			STM32智能无人机控制系统教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言环境准备智能无人机控制系统基础代码实现：实现智能无人机控制系统 4.1 数据采集模块 4.2 数据处理与控制算法 4.3 通信与网络系统实现 4.4 用户界面与数据可视化应用场景：无人机管理与优化问题解决方案与优化收尾与总结 1. 引言 智能无人机控制系统通过STM32嵌入式系统结合各种传感器、执行器和通信模块，实现对无人机的实时监控、路径规划和自动控制。本文将详细介绍如何在STM32系统中实现一个智能无人机控制系统，包括环境准备、系统架构、代码实现、应用场景及问题解决方案和优化方法。
2. 环境准备 硬件准备 开发板：STM32F4系列或STM32H7系列开发板调试器：ST-LINK V2或板载调试器传感器：如IMU、GPS、气压计、激光雷达等执行器：如电机、舵机等通信模块：如RF模块、Wi-Fi模块等显示屏：如OLED显示屏按键或旋钮：用于用户输入和设置电源：电池组 软件准备 集成开发环境（IDE）：STM32CubeIDE或Keil MDK调试工具：STM32 ST-LINK Utility或GDB库和中间件：STM32 HAL库和FATFS库 安装步骤 下载并安装STM32CubeMX下载并安装STM32CubeIDE配置STM32CubeMX项目并生成STM32CubeIDE项目安装必要的库和驱动程序 3. 智能无人机控制系统基础 控制系统架构 智能无人机控制系统由以下部分组成：
数据采集模块：用于采集无人机飞行过程中的姿态、位置和环境数据数据处理与控制算法模块：对采集的数据进行处理和分析，执行控制算法通信与网络系统：实现无人机与地面站或其他设备的通信显示系统：用于显示系统状态和飞行信息用户输入系统：通过按键或旋钮进行设置和调整 功能描述 通过各种传感器采集无人机飞行过程中的关键数据，并实时显示在OLED显示屏上。系统通过PID控制算法和网络通信，实现对无人机的自动化控制和数据传输。用户可以通过按键或旋钮进行设置，并通过显示屏查看当前状态。
4. 代码实现：实现智能无人机控制系统 4.1 数据采集模块 配置IMU 使用STM32CubeMX配置I2C接口：
打开STM32CubeMX，选择您的STM32开发板型号。在图形化界面中，找到需要配置的I2C引脚，设置为I2C模式。生成代码并导入到STM32CubeIDE中。 代码实现：
#include "stm32f4xx_hal.h" #include "i2c.h" #include "mpu6050.h" I2C_HandleTypeDef hi2c1; void I2C1_Init(void) { hi2c1.Instance = I2C1; hi2c1.Init.ClockSpeed = 100000; hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2; hi2c1.Init.OwnAddress1 = 0; hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT; hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE; hi2c1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4d873175e26df2f3f465b25049f175e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9d40e695667009a72566091ef6b469/" rel="bookmark">
			常用Docker命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 基础命令 检查 Docker 版本 $ docker --version Docker version 20.10.7, build f0df350 获取 Docker 系统信息 $ docker info 获取 Docker 命令帮助 $ docker help Docker 镜像管理 Docker 镜像是一个只读模板，用于创建 Docker 容器。以下是一些管理镜像的常用命令：
拉取镜像 $ docker pull ubuntu:latest 列出镜像 $ docker images 删除镜像 $ docker rmi ubuntu:latest Docker 容器管理 容器是从镜像创建的可运行实例。以下是一些管理容器的常用命令：
运行容器 $ docker run -it ubuntu:latest /bin/bash 列出容器 $ docker ps 停止容器 $ docker stop container_id 删除容器 $ docker rm container_id Docker 容器操作 操作容器时，除了启动和停止之外，还有许多其他有用的命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9d40e695667009a72566091ef6b469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0e131547c83ec1e5e4f53e7a8faad8/" rel="bookmark">
			盲盒抽卡机小程序：抽卡机的多样化发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近几年，盲盒卡牌出现在了大众的生活中，深受学生和年轻消费者的喜爱。卡牌是一种新的盲盒模式，玩家购买后随机获得卡牌，为了收集一整套卡牌，玩家会进行各种复购行为，卡牌逐渐成为了年轻人追捧的休闲方式，因此，卡牌市场获得了快速发展，发展前景巨大。
在数字化时代，抽卡机实现了线上发展，为消费者提供了一个新的抽卡模式选择，让玩家更加便利的进行抽卡。本文将介绍盲盒抽卡机小程序系统开发。
抽卡机小程序是一个基于微信的应用程序，它将线下抽卡的模式搬到线上，并进行创新融合。用户在手机上直接选择卡牌拆卡，操作非常简单，为用户带来了全新的拆卡体验。
抽卡机小程序系统的优势
1、抽卡机小程序具有公开透明的特点，所有的卡牌信息都会在平台上进行展示，玩家能够清晰了解各个卡牌的抽奖情况，保障玩家在拆卡中公平性。
2、抽卡机上的卡牌种类丰富，涵盖了各个动漫、影视等领域；并且拥有众多限量款和隐藏款卡牌，具有很高的收藏价值，能够吸引到更多的玩家到平台参与抽奖，推动平台的发展，帮助商家提高销量。
3、小程序操作简单，玩家在平台上可以直接浏览各个系列卡牌，任意选择喜欢的系列即可下单拆卡，方便快捷，让玩家快速获得喜欢的卡牌。
4、卡牌小程序中拥有很多优惠活动，能够提高玩家对平台的粘性。玩家在平台上通过下单、领取活动折扣、分享邀请好友等都可以获得积分奖励，免费兑换卡牌；同时，平台还将不定时举办各种活动，让玩家低价格获得限量卡牌。
抽卡机小程序在当下互联网时代中凭借着自身优势，拥有了广泛的发展前景，随着技术的发展和市场需求的增加，抽卡机小程序在未来将发挥着更大的作用，为商家带来更多的收益。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6610338780452a32063aabbace3ed339/" rel="bookmark">
			实习期间创下 Transformer，他说：当年整个 AI 圈都无法预见我们今天的高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 王启隆
出品 | AI 科技大本营（ID：rgznai100）
原文 | https://www.youtube.com/watch?v=ZFmapxYBafY
写出 Transformer 论文的那八个人，如今都在干什么？
在今年三月的英伟达全球技术大会（GTC）上，黄仁勋曾经把「Transformer 八子」中的七位（Niki Parmar 未出席）拉来凑了个圆桌，和这几位对整个 AI 界带来深远影响的科学家们同台聊了聊。但是，就连老黄都没能成功集齐八人，可见实现“八人同框”的难度究竟有多大。
欢迎回顾我们整理的文章：黄仁勋对话Transformer七子：太多算力浪费，我们必须解决自适应计算问题
最近，我们也是终于盼来了“八子之一”的 Aidan Gomez 最新采访，他在最近接受 CNBC 采访时表示：“当时在这个领域内的任何工作者，都无法预见我们如今在技术能力上所达到的高度。”“模型正在做的事情，是我个人原本以为可能要等到职业生涯晚期（40 年后）才能见证的。”
Gomez 出生在加拿大，他早年对计算机科学产生浓厚兴趣，并在多伦多大学和牛津大学深造，后者的影响尤为深远，使他在国际舞台上崭露头角。在完成他的博士学位之前，他就加入了 Google Brain 团队成为实习生，参与了开发 TensorFlow 模型框架的工作。
2017 年，Gomez 在 Google 的实习期间合著了奠定 Transformer 架构基础的论文《Attention Is All You Need》。这篇论文首次提出了一种全新的机器学习架构 —— Transformer。在此之前，大多数 NLP 模型依赖于循环神经网络（RNN）或卷积神经网络（CNN），而 Transformer 的出现彻底改变了游戏规则。
在我们最近整理的《Perplexity CEO 最新四万字访谈：杀死谷歌，成为 AI 时代的搜索皇帝！》中，Perplexity CEO 埃拉文德花了很长的时间回忆他在谷歌担任实习生时所经历的 AI 发展史，完整阐述了 Transformer 的前世今生。
离开 Google 之后，Gomez 和他在多伦多大学的校友 Ivan Zhang 和 Aidan Gomez 共同创立了 Cohere 公司，担任 CEO。2023 年 6 月，Cohere 以 22 亿美元的估值从 Salesforce 和 Oracle 等投资者手中筹集了 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6610338780452a32063aabbace3ed339/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ba44bee19e160094684c13219e8f0e/" rel="bookmark">
			6、java程序员-前端面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		俗话说的前端三剑客是指：html css javascript
1、有哪些常用的事件（可以直接说过中文名）
离焦事件 onblur
聚焦事件 onFocus
鼠标移上去 onmouseover
鼠标移出去 onmouseout
点击事件 onclick
表单提交 onsubmit
2、设置样式的时候有哪些常用的选择器
标签选择器
标签名{}
class类选择器
.class名字{}
id选择器
#id值{}
3、你们用的VUE哪个版本？
VUE3
4、v-if和v-show的区别
都是可以控制显隐、
v-if控制的话在浏览器查看源码是看不到隐藏的内容
v-show控制的话在浏览器查看源码是可以看到隐藏的内容 display样式控制
5、VUE的生命周期
VUE对象从创建到销毁 会自动触发8个函数，叫做钩子函数
我们经常用mounted 打开页面时执行查询数据的方法
6、TypeScript是什么
主要是控制JavaScript中的类型
7、做过前端吗？
我们用的是ElementPlus和VUE3，管理类型的页面是没有问题的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff3ca52d9d3483c7ca7cb78922b4e38e/" rel="bookmark">
			从模型到应用：李彦宏解读AI时代的新趋势与挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何理解李彦宏说的“不要卷模型，要卷应用” 开源项目的机遇与挑战 7月4日，2024世界人工智能大会暨人工智能全球治理高级别会议在上海世博中心举办。在产业发展主论坛上，百度创始人、董事长兼首席执行官李彦宏呼吁：“大家不要卷模型，要卷应用！”这句话引发了广泛的讨论。李彦宏认为，AI技术已经从辨别式转向了生成式，但技术本身并不是目的，真正的价值在于如何将这些技术应用于实际场景，解决实际问题。本文将从三个方向来探讨李彦宏的这一观点：AI技术应用场景探索、避免超级应用陷阱的策略、个性化智能体开发。
方向一：AI技术应用场景探索
方向一：AI技术应用场景探索 AI技术的进步为各种实际应用场景带来了巨大的潜力。以下是一些AI可以发挥最大作用的实际场景及其潜在价值：
医疗健康： AI在医疗健康领域的应用前景广阔，从疾病诊断、个性化治疗方案的制定，到医疗影像分析和药物研发，AI都能发挥重要作用。例如，利用AI技术对X光片、CT影像进行快速准确的分析，可以显著提高诊断效率，减轻医生的工作负担。此外，AI还可以通过分析病人的基因数据和病史，帮助医生制定更加精准的个性化治疗方案，提高治疗效果。
智能制造： 在智能制造中，AI可以通过优化生产流程、预测设备故障、提高产品质量等方面提高生产效率和降低成本。工业机器人、智能物流系统以及预测性维护都是AI在制造业中的实际应用。例如，通过对生产线的数据进行实时监控和分析，AI可以发现潜在的问题并及时预警，避免生产停工和产品质量问题。此外，AI还可以优化供应链管理，提高物流效率和库存管理水平。
自动驾驶： 自动驾驶是AI技术的一个重要应用领域。通过深度学习和计算机视觉技术，自动驾驶汽车能够识别道路状况、行人和障碍物，并做出实时决策，从而提高交通安全性和运输效率。例如，AI可以通过分析道路上的车辆和行人行为，预测潜在的危险情况，并采取相应的避让措施。此外，AI还可以优化车辆的行驶路径，减少交通拥堵和能源消耗。
金融科技： 在金融行业，AI可以用于风险管理、欺诈检测、智能投顾等方面。通过分析海量的金融数据，AI可以帮助金融机构更准确地评估风险，提高投资回报率。例如，AI可以通过分析客户的交易行为和信用记录，发现潜在的欺诈行为，并及时采取措施。此外，AI还可以根据客户的投资偏好和风险承受能力，提供个性化的投资建议，提高客户的满意度和投资收益。
智能家居： AI技术在智能家居中的应用也在不断扩展。智能音箱、智能安防系统和家电设备的智能控制都可以通过AI技术实现，为用户提供更便捷、安全的生活环境。例如，通过语音识别和自然语言处理技术，智能音箱可以理解用户的指令并执行相应的操作。此外，AI还可以通过对家庭环境数据的分析，优化家电设备的工作模式，提高能源利用效率和用户体验。
方向二：避免超级应用陷阱的策略
方向二：避免超级应用陷阱的策略 李彦宏提醒大家避免掉入“超级应用陷阱”，即过分追求用户日活跃量（DAU）而忽视了应用的实际效果和产业价值。这一观点值得深思。以下是避免超级应用陷阱的策略：
注重应用实效： 在开发和推广AI应用时，应更多关注其实际效果和用户反馈，而不仅仅是用户活跃度。一个应用的成功不在于有多少用户使用，而在于能否真正解决用户的问题，带来实质性的价值。例如，在医疗健康领域，AI应用的成功应体现在提高诊断准确率、缩短治疗时间和降低医疗成本上，而不仅仅是用户的使用频率。
提升用户体验： 尽管DAU是衡量应用受欢迎程度的一个指标，但提升用户体验才是长久之计。通过不断优化应用功能和界面设计，提供个性化的服务，可以提升用户满意度，增加用户粘性。例如，在智能家居领域，AI应用应关注如何提供更便捷、安全和智能的服务，而不仅仅是用户的使用频率。
聚焦产业价值： AI应用应聚焦于为产业带来实质性的增益，而不是盲目追求用户数量。无论是提高生产效率、降低运营成本，还是开创新的业务模式，应用的产业价值才是关键。例如，在智能制造领域，AI应用的成功应体现在提高生产效率、降低生产成本和提高产品质量上，而不仅仅是用户的使用频率。
长远视角： 研发和推广AI应用时应有长远视角，注重应用的可持续发展和长远价值，而不是追求短期的用户增长。通过持续创新和优化，不断提升应用的竞争力和用户价值。例如，在自动驾驶领域，AI应用的成功应体现在提高交通安全性、减少交通拥堵和降低能源消耗上，而不仅仅是用户的使用频率。
方向三：个性化智能体开发
方向三：个性化智能体开发 个性化智能体开发是AI应用的重要方向，能够提供一对一的个性化服务，满足用户的独特需求。以下是个性化智能体开发的一些建议：
数据驱动的个性化： 个性化智能体需要依赖大量的用户数据进行训练和优化。通过分析用户的行为数据、偏好数据和历史记录，智能体可以提供更精准的个性化服务。例如，在智能投顾领域，AI可以根据客户的投资偏好和风险承受能力，提供个性化的投资建议，提高客户的满意度和投资收益。
自然语言处理： 自然语言处理（NLP）技术在个性化智能体中起着关键作用。通过先进的NLP技术，智能体可以更好地理解用户的语言表达，提供更自然、更贴心的交互体验。例如，在智能客服领域，AI可以通过语音识别和自然语言处理技术，快速理解用户的问题并提供准确的答案，提高客服效率和用户满意度。
持续学习和优化： 个性化智能体需要具备持续学习和优化的能力。通过不断收集和分析用户反馈，智能体可以不断改进其服务质量，提升用户满意度。例如，在医疗健康领域，AI可以通过对病人的治疗数据进行分析，优化治疗方案，提高治疗效果和病人的满意度。
多场景应用： 个性化智能体不仅可以应用于智能客服、智能助手等领域，还可以扩展到教育、医疗、金融等多个场景。通过跨场景的数据共享和模型优化，智能体可以提供更全面、更智能的服务。例如，在教育领域，AI可以根据学生的学习行为和成绩数据，提供个性化的学习建议和辅导方案，提高学习效果和学生满意度。
结论 李彦宏的“不要卷模型，要卷应用”提醒我们，技术创新的最终目的是为了更好地解决实际问题，推动社会进步。AI技术的发展应更多关注其应用价值，通过实际应用场景的探索、避免超级应用陷阱以及个性化智能体的开发，实现技术与应用的有机结合。只有这样，AI技术才能真正发挥其潜力，为社会带来实质性的价值。通过持续创新和优化，不断提升应用的竞争力和用户价值，AI技术必将为各行各业带来更多的机遇和挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d7233bbdaf968a6bb00bdeed0c2b555/" rel="bookmark">
			Everything搜索无法搜索到桌面的文件（无法检索C盘 或 特定路径的文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象描述 在Everything搜索框中输入桌面已存在的文件或随便已知位置的文件，无法找到。
搜索时检索结果中明显缺少部分磁盘位置的，例如无法检索C盘，任意关键字搜索时结果中没有位于C盘的，无论怎样都搜不到C盘文件。
解决方法 在 工具 - 选项 中找到 索引，关闭【启用排除列表】（取消勾选即可）。
如仍无法解决，须彻底退出软件后，重新打开软件，先设置一下排除C盘（点击添加文件夹按钮选择C盘），点击 应用 再点击 确定 后关闭窗口。重新进入选项设置，再取消排除C盘，点击 应用 - 确定 后即可成功搜索到C盘文件。即：将C盘排除一下再重新加回来，触发重建索引。 其他方案 1.检查是否取消掉了全字匹配。全字匹配会导致文件名必须一毛一样才能搜索到，也会引起搜索结果缺失。
可以直接Ctrl+B关闭全字匹配。 2.尝试重建索引。在 工具 - 选项 - 索引 页面点击“强制重建”按钮，等待一段时间后再搜索。
重装Everything 疑似是Everything的bug导致，没有修改任何配置就出现类似问题，可以尝试重新安装一下Everything，或者更新到最新版本。
Everything下载地址：http://www.voidtools.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958ed0ad33b59ac35f6db858d159e078/" rel="bookmark">
			Go 环境部署 （linux 和Windows 下的 GoLand ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux 下： 下载地址：
https://golang.google.cn/dl/
在 linux 下 的 /root/yjq 目录下
执行命令
wget https://golang.google.cn/dl/go1.18.linux-amd64.tar.gz tar -zxvf go1.18.linux-amd64.tar.gz 在当前目录下，会产生一个go目录
编辑用户的bash配置文件来添加环境变量。打开bashrc文件
vim ~/.bashrc 在此文件的末尾处，添加下面这两句
export PATH=$PATH:/root/yjq/go/bin 最后
source ~/.bashrc 有可能会报以下错误
需要手动敲
export PATH=$PATH:/root/yjq/go/bin 验证
go version 如果项目是用 mod 管理，就不需要配置 GOROOT 和GOPATH了
但首先要确保 GO111MODULE 为 on 可以用命令 go env GO111MODULE 查看
如果不是on 就设置为 on，命令
go env -w GO111MODULE=on 如果项目中还没有 go.mod 文件，可以用命令 【go mod init 目录】 ，就会自动生产
go.mod 文件 ，然后执行命令 go mod tidy
go mod tidy（在项目开发过程中，如果由需要依赖新的第三方包，需要经常的执行此命令【每次运行调试之前】）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/958ed0ad33b59ac35f6db858d159e078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d75bec653234d8a404a9d8f0ee0a81/" rel="bookmark">
			【架构】分布式与微服务架构解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式与微服务架构解析 一、分布式1、什么是分布式架构2、为什么需要分布式架构3、分布式架构有哪些优势？4、分布式架构有什么劣势？5、分布式架构有哪些关键技术？6、基于分布式架构如何提高其高性能？7、如何基于架构提高系统的稳定性?8、分布式架构有什么难点？ 二、微服务1、什么是微服务2、微服务架构诞生的背景3、为什么需要微服务架构4、微服务架构存在的问题5、微服务架构的优点6、常见的微服务架构 三、分布式架构和微服务架构的区别 一、分布式 1、什么是分布式架构 微服务架构是分布式架构，分布式架构不一定是微服务架构
当系统的并发处理能力、存储能力不足时，我们可能会创建多个web服务(多个tomcat服务器)，多个数据库服务(主从架构等)，这些服务器通过网络进行连接，然后协同处理客户端的并发请求，这样的系统我们称之为分布式系统。
2、为什么需要分布式架构 分布式架构可以更好的提高系统的容量、可靠性(避免单点故障)、性能。 同时因为模块化，系统的可重用性以及并行并发开发的效率也会提高。
当一个系统的业务量越来越大时，我们需要垂直或是水平拆分业务系统，同时为了避免所有业务都部署在一台机器上时，一旦机器出现故障从而导致整体不可用，就需要将这些业务部署在多台计算机上，来构建一个分布式架构。
3、分布式架构有哪些优势？ 可以实现更大数据量的存储。（抖音每天几十pb的数据）可以更好提高系统的高可用性。（业务冗余、业务拆分、限流、熔断）可以更好提高系统的可重用性。可以更好提高系统的性能。 4、分布式架构有什么劣势？ 复杂性增加：分布式架构的设计和实现相对于单体应用来说更加复杂。开发人员需要考虑到网络通信、数据一致性、故障处理等方面的问题，这增加了系统的复杂性和开发的难度。性能问题：由于分布式架构将系统拆分成多个服务，服务之间需要通过网络进行通信，这会引入一定的延迟。同时，分布式系统中的负载均衡和数据分片等机制也会对性能产生一定的影响。一致性难题：在分布式系统中，由于存在多个节点，数据的一致性成为一个复杂的问题。保证数据的一致性需要引入复杂的分布式事务机制，增加了系统的开销和复杂性。部署和维护成本增加：由于分布式架构涉及多个服务的部署和维护，这增加了部署和维护的成本。同时，对于分布式系统的监控和故障排查也需要更多的工作。
系统的复杂性增加了故障排查的难度：由于分布式架构的复杂性，当系统出现故障时，排查问题变得更加困难。需要考虑多个服务之间的交互，以及网络通信等方面的问题。 5、分布式架构有哪些关键技术？ 服务治理 服务治理最大的意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。一般我们所讨论的服务拆分、服务注册、服务发现、服务限流、服务熔断、降级、服务的链路跟踪，监控等都属于服务治理的范畴。
架构管理 基于服务所形成的架构需要用架构管理、整体架构的生命周期管理，以及对服务的编排、聚合事务处理等服务调度的功能。
DevOps（开发与运维一体化） 分布式系统可以更为快速的更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要DevOps的全流程，其中包括环境构建、持续集成、持续部署等、自动化运维。有了DevOps后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。（AIOps）
资源调度管理 应用层的自动化运维需要基础层的调度支持，也就是云计算IaaS层的计算、存储、网络等资源调度、隔离和管理。
整体架构监控 如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛、没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件、基础层）进行监控。
流量控制 6、基于分布式架构如何提高其高性能？ 一般面对这样的问题，首先要从整体维度去思考，要分析问题，例如影响系统性能的因素有哪些？
请求数据的传输时间请求数据的处理时间响应数据的传输时间响应数据的渲染时间
当了解影响系统性能的因素以后，此时可以给出一些具体解决方案，例如；减少数据传输时间？（加宽带，减少数据传输量，减少传输距离）提高请求数据的处理速度？（CPU、内存、硬盘、分布式架构，缓存、算法、sql调优，索引的设计、异步）
3.减少数据在客户端的渲染时间？（局部更新-Ajax，减少不必要的元素渲染等）
具体从架构层面进行设计的话可以从如下几个维度进行思考： 应用缓存 为系统添加缓存，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和CPU，全都有缓存，这是提高快速访问能力最有效的手段。
负载均衡 负载均衡是做水平扩展的关键技术，使用多台机器来共同分担一部分流量请求。
异步调用 异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，而后端通过自己能够处理的速度来处理请求。
数据分区和数据镜像 数据区分是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区分来分担不同区的流量。
具体从SQL调优层面如何进行优化呢？
获取执行慢的SQL（通过慢 SQL日志找到执行慢的SQL）获取影响SQL执行比较慢的原因（通过执行计划分析SQL执行慢的原因）给出具体SQL的优化方案（例如数据量太大，没设计索引或没走索引，SQL结构设计不合理） 7、如何基于架构提高系统的稳定性? 服务拆分：分而治之 服务拆分可以更好的实现故障隔离，同时也可以重用服务模块。
服务冗余：有备无患 服务冗余是为了去除单点故障，支持服务的弹性伸缩，以及故障迁移。
限流降级：细水长流，断尾求生 当系统扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分任务，或是拒绝一部分用户，以确保整个架构不会挂掉。
高可用架构：多机房部署 高可用就是从冗余架构的角度来保障可用性。比如多租户隔离，灾备多活等，总之是wield不出单点故障。
高可用运维 指的是DevOps中的CI（持续集成）、CD（持续部署）。一个良好的运维应做了足够的自动化测试，做相应的灰度发布，以及对线上系统的自动化控制。这样就可以做到“计划内”或是“非计划内”的宕机事件的时长最短。
8、分布式架构有什么难点？ 异构系统存在很多不标准的问题 构建软件时使用的编程语言、通讯协议、数据格式、运维标准可能不同，进而导致架构设计的复杂度越来越高。
系统架构中的服务依赖问题 传统的单体应用，一台机器挂了，整个软件就垮掉了，分布式架构下也可能出现这样的问题，因为一个服务可能会依赖另一个服务，某个服务挂掉了，会导致调用链上的服务都出现故障。
故障发生的概率更大 分布式架构中，服务和机器都会比较多，故障发生的频率会更大，只是影响面没有单体应用的影响面大，分布式系统中故障可以被隔离。还有就是分布式架构管理相对于单体架构也更加复杂，没有优秀的架构管理人员，故障的频率还是会非常高。
多层架构的运维复杂度很大 分布式架构中，我们可以将系统分为四层(基础层、平台层、应用层、接入层)
基础层：包括机器、网络和存储设备平台层：就是中间件层包括tomcat、MySQL、Redis、RocketMQ类似的软件。应用层：就是我们的业务软件，包括各种业务服务。接入层：就是接入用户请求的网关、负载均衡、CDN、DNS等。 二、微服务 1、什么是微服务 微服务是一种软件架构风格，是一种分布式架构解决方案，简单点就是将整体大应用，基于业务划分为更加微小的服务。然后作为独立的进程进行开发、测试、部署、运行、维护，每个服务都具备独立的自治能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64d75bec653234d8a404a9d8f0ee0a81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5584073e75d845d1f64edaa99b144f27/" rel="bookmark">
			AI in Finance 金融领域AI应用-基于DeepNLP AI App Store 真实用户评论打分和排名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI在金融领域应用 AI in Finance 金融服务领域的AI应用和传统的金融智能应用不同。传统金融智能应用包括如风险评估 (Risk assessment), 风险管理（Risk management), 欺诈检测 (Fraud Detection）等等。
通用AI大模型和人工智能应用如ChatGPT，Gemini，Perplexity等基于大语言模型LLM的技术发展，在投资、保险、银行等领域有了更多的应用。本文收集了常见细化分类目的金融类 Prompts。
评论地址：
Best AI App in Finance
github: https://github.com/rockingdingo/ai_store
AI在金融投资领域应用 AI in Investment Finance
AI在金融保险领域应用 AI in INSURANCE FinanceAI在金融抵押贷款和借贷应用 AI in Mortgage and Loan Finance
AI在银行领域应用 AI in BANKING Finance
AI在债务领域应用 AI in DEBT Finance
金融领域大模型智能问答 Prompts - You are an expert in stock investment, and I will consult you a few questions. The questions include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5584073e75d845d1f64edaa99b144f27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94047c8b8fd7b76bad42caa9536527ef/" rel="bookmark">
			【C语言】【排序算法】----- 归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近要考试，好久没有发博客了，非常抱歉大家对我的支持。之后我会不断更新博客，继续创作出高质量的文章，希望能帮到大家！
文章目录 一、归并排序基本思想二、递归实现三、非递归实现四、效率分析 一、归并排序基本思想 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法，即分解和合并。先使每个子序列有序，再使子序列段间有序，最后合并成一个有序数组。
二、递归实现 基本思路：
① 申请一个空间tmp，大小为两个已经排好序列之和，该空间用来存放合并后的序列。
② 设定两个下标，分别指向两段已排好序的起始位置。
③ 比较两个下标所指向的元素大小，选择较小的元素放入到合并空间，并且移动指针指向下一位置。
④ 不断重复步骤③，直到当某一指针到达序列尾部。
⑤ 然后将另一序列剩下的所有元素直接插入到合并序列的尾端。代码实现： //归并排序递归 void _MergeSort(int* a, int* tmp, int begin, int end) { //只有一个元素或不存在这样的区间时 if (begin &gt;= end) { return; } //分成两段区间，分别有序时在进行归并 int mid = (begin + end) / 2; _MergeSort(a, tmp, begin, mid); _MergeSort(a, tmp, mid + 1, end); //第一个数组的两端 int begin1 = begin, end1 = mid; //第二个数组的两端 int begin2 = mid + 1, end2 = end; //由于两段数组都是从begin开始，因此将begin给i确保其在相同的区间上 int i = begin; while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { if (a[begin1] &lt; a[begin2]) { tmp[i++] = a[begin1++]; } else { tmp[i++] = a[begin2++]; } } //有一个排完了，剩下的直接放入 while (begin1 &lt;= end1) { tmp[i++] = a[begin1++]; } while (begin2 &lt;= end2) { tmp[i++] = a[begin2++]; } //tmp已经归并成功，将tmp复制会数组a中 memcpy(a + begin, tmp + begin, (end - begin + 1) * sizeof(int)); } void MergeSort(int* a, int n) { assert(a); //创建一个临时数组 int* tmp = (int*)malloc(sizeof(int) * n); if (tmp == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94047c8b8fd7b76bad42caa9536527ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a156de1411bbde86385978ce6bc08e4/" rel="bookmark">
			Linux配置仓库，安装软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Linux中安装软件，必须得配置仓库，挂载，才能安装成功 1.选择使用的虚拟机，右键点击“设置”
2.点击“CD/DVD”，勾选“设备状态”中的“已连接”和启动时链接，选择ISO映像文件
3..开启虚拟机
4.配置仓库
[root@localhost ~]# cat /etc/yum.repos.d/rpm.repo [BaseOS] name=BaseOS baseurl=/mnt/BaseOS gpgcheck=0 enable=1 [AppStream] name=AppStream baseurl=/mnt/AppStream gpgcheck=0 enbale=1 5.创建挂载点（文件夹） [root@localhost ~]# mkdir /mnt 6.挂载
[root@localhost ~]# mount /dev/sr0 /mnt mount: /mnt: WARNING: source write-protected, mounted read-only. 7.安装你需要的软件
例，安装http服务
[root@localhost ~]# yum install -y httpd 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f98dfa5152f99c221e43e1a72731a2b/" rel="bookmark">
			【AI模型】一分钟教你使用GPT-SoVITS，克隆你的声音，效果十分逼真，全干货教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章不废话，直接上教程
喜欢的小伙伴点个大拇指或者收藏一下，一键三连，你们的支持就是我最大的动力
一、GPT-SoVITS下载 首先该模型是GitHub上的开源项目，可以直接下载
GitHub - RVC-Boss/GPT-SoVITS: 1 min voice data can also be used to train a good TTS model! (few shot voice cloning)
项目下载后压缩包放入一个非中文路径解压，解压后在文件夹找到go-webui.bat，双击运行即可，如果长时间cmd没反应，可以尝试回车，或者在顶头右键属性，取消快速编辑模式并确定即可
启动成功后浏览器会自动打开这个UI界面，接下来我们就可以正式开始了
二、GPT-SoVITS使用 首先我们可以准备好一段音频，用于切割训练，我这里准备了四分钟，取自一个视频中的音频
1.人声分离 音频分离可以将“是否开启UVR5-WebUI”勾选上，等待几秒就会自动打开这个界面，选择需要处理的音频，选择好模型和输出的文件夹目录后就可以开始转换了
2.音频处理 得到需要训练的音频后，我们将音频的文件路径复制到第一个方框，然后在第二个方框选择输出的路径，其余不变即可，点击开启语音切割，耐心等待几秒钟，文件就会被切割成几秒钟的一句话
随后下面找到ASR音频处理，文件路径选择刚刚切分好音频的文件夹，输出路径也选择一个文件夹用于存放生成的list文件
注：ASR模型可以自己选择，只训练中文可以不修改，但如果想生成英文或者日语，可以自行选择
生成好的文件
最后我们在下方填入list的文件路径，点击下方开启语音文本校对标注工具，开始打标
此操作也会启动一个新的界面
3.音频打标 进入如下界面后即可进行打标，左侧为自动生成的文字，中间为原音频，我们需要根据音频实际去修改左侧文字，看看是否有错误，错误一般为文字错误，标点错误，断句错误等，修改好后点击第二个Submit Test提交即可
本页检查完，如果有第二页，则点击右上角Next跳转下一页进行打标，需要删除音频则勾选yes，然后点击顶部的Delete Audio进行删除
文件全部打标完成，点击Save File即可，然后关闭页面，把上一个页面的“是否开启打标WebUI”勾给取消，滚动到界面上方跳转到TTS界面
4.TTS处理 这一步很简单，我们只需要使用更改这一个list文件夹目录即可
随后找到最底下的一键三连！！！（疯狂暗示） 文件处理完成后上方切换到1B-微调训练
可以自己更改数值，一般不建议太大，以我笔记本3050为例，默认的数值保持不变如下，生成模型所需要的时间和轮数以及保存频率有关，模型数量可以自己计算
模型数量=总训练轮数÷保存频率
点击开启SoVITS训练，也点击GPT训练
这一步耗时较长，我们在控制台可以看到运行的结果
5.TTS推理 训练结束后，点击跳转1C-推理
同理，其他都不用动，模型列表我们默认选择最大的，我这里就是e15和e8，都选上之后，点击开启TTS推理webUI，耐心等待界面跳转
跳转到此界面后我们可以详细看一看内容
首先这里面也可以选择模型进行更改，这个设置也很不错
看到下边，需要我们上传10秒以内的音频，注意了，这里是十秒音频，必须和前边训练的声音要一致，前边假如训练的是自己的声音，那这里也要上传自己的声音，而且此次生成的音频语气感情都会参照这10秒内的声音来合成
看旁边，参考音频文本，就填这十秒音频的文本即可，要对应上
下方需要合成的文本，我们可以自己填需要文本转语音的内容，可以长可以短，如果需要短句，则在底部输入，选择要切分的类型，切分好后再粘贴进需要生成的文本里
最后点击合成语音，大功告成！
在这个页面可以预览生成的语音，点击语音条旁边的三个点就可以下载
如果不满意还可以重复生成
文件夹里的output文件夹就是存放所有的输出，我们可以定期删除清理掉，减少磁盘占用
（每次生成的语音都会保存在这里，所以也不用点击下载，会自动保存进文件夹中）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5077a2e0c8f6a09a2271571f0e7d3d5/" rel="bookmark">
			Perl文件锁机制：守护你的数据安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔒 Perl文件锁机制：守护你的数据安全 在多任务和多用户的系统环境中，文件锁是确保数据完整性和一致性的关键机制。Perl作为一种强大的脚本语言，提供了多种文件锁处理方式，以支持并发访问时的安全性。本文将深入探讨Perl中的文件锁机制，通过详细的步骤、丰富的代码示例，教您如何在Perl脚本中实现文件锁。
🌐 Perl文件锁概述 文件锁可以防止多个进程同时写入同一文件，或者在读取文件时防止文件被修改。Perl中的文件锁主要有两种类型：强制性锁（也叫二进制锁）和顾问式锁。
🏗️ 使用强制性锁 强制性锁是通过操作系统强制执行的，确保文件在被修改时不会被其他进程访问。
代码示例：使用sysopen进行强制性锁 use Fcntl 'Fcntl'; open(my $fh, '&gt;', 'file.txt') or die "Cannot open file.txt $!"; fcntl($fh, F_SETLK, flock($fh, LOCK_EX)) or die "Cannot lock file.txt $!"; # 执行文件操作... fcntl($fh, F_SETLK, flock($fh, LOCK_UN)) or die "Cannot unlock file.txt $!"; close($fh); 🛠️ 使用顾问式锁 顾问式锁是一种协作机制，依赖于进程间的自我管理和约定，不通过操作系统强制执行。
代码示例：使用flock进行顾问式锁 open(my $fh, '&gt;', 'file.txt') or die "Cannot open file.txt $!"; # 尝试获取锁 flock($fh, LOCK_SH) or die "Cannot get shared lock on file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5077a2e0c8f6a09a2271571f0e7d3d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d2d38274e4277cb9bf4fdb0422015f4/" rel="bookmark">
			20240710 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤖微软：不会像 OpenAI 一样阻止中国访问 AI 模型
- OpenAI 将于周二（7 月 9 日）开始阻止中国用户访问其 API。
- 微软发言人表示：Azure OpenAI API服务在中国的提供方式没有变化。
- 公司仍然通过部署在中国以外地区的模型向符合条件的中国客户提供访问权限。
- 作为一家独立公司，OpenAI自行做出其决策，微软不受影响。
🔗
🚀通过Claude 的 Artifacts 功能生成的应用程序可以直接分享到任意地方了！
- 任何人都可以打开直接玩耍了
- OpenAI全面落后！
🔗试玩这个小游戏试试：https://claude.site/artifacts/c55cf857-d456-4520-8ee2-206697dfa2a3
🔗 https://blink.csdn.net/details/1753123 🖼️PaintsUndo：输入静态图像 自动帮你生成整个绘画的全过程视频
- 只需要提供一张图片，PaintsUndo会根据提供的图像自动生成对应的绘画全过程视频。
- 不仅限于某一种类型的图像，PaintsUndo可以应用于各种不同类型的图像，生成相应的绘画过程视频。
- 该项目主要是为了研究和再现数字绘画中的绘画行为，从而为数字艺术创作提供新的工具和方法。
- 同一张静态图像可以生成多种不同风格和细节程度的绘画过程视频。
🔗 https://blink.csdn.net/details/1753129
📱Meta AI为移动设备开发紧凑型语言模型MobileLLM
- MobileLLM是为资源受限设备设计的高效语言模型，挑战了大型模型的必要性。
- MobileLLM的创新包括优先考虑模型深度、利用嵌入共享和分组查询注意、采用直接块权重共享技术。
- MobileLLM在基准测试任务上表现优异，3.5亿参数版本在某些任务上与70亿参数模型相当。
🔗 https://www.chinaz.com/ainews/10116.shtml
🎬Odyssey：提供好莱坞级别的 AI 视频生成和编辑工具
- OdysseyML 旨在开发能够生成和导演好莱坞级别视觉效果的AI技术。
- OdysseyML的团队由来自各大知名科技公司的AI研究人员和好莱坞艺术家组成。
- OdysseyML 正在训练四个生成模型，以生成高质量几何图形、逼真的材质、惊人的灯光效果和可控的动作。以便完全控制视觉故事的核心层次。
🔗 官网: https://odyssey.systems/
🔗 https://blink.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d2d38274e4277cb9bf4fdb0422015f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a35f45974f04fde6dc122eb9e13283/" rel="bookmark">
			Profibus_DP转ModbusTCP网关模块连马保与上位机通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Profibus转ModbusTCP网关模块（XD-ETHPB20）广泛应用于工业自动化领域。例如，可以将Profibus网络中的传感器数据转换为ModbusTCP协议，实现数据的实时监控和远程控制。本文介绍了如何利用Profibus转ModbusTCP网关（XD-ETHPB20）模块将带有Profibus_DP协议的马保连接到上位机上实现ModbusTCP通讯。 Profibus转ModbusTCP模块功能和优势：
支持Profibus DP主站、ModbusTCP主站/从站的功能；内置Profibus DP、ModbusTCP协议，实现协议的无缝转换；支持固定IP、DHCP自动获取IP等多种网络配置方式；支持Web配置页面，操作简便，便于用户快速上手；具有良好的稳定性和可靠性，适用于各类工业环境。
Profibus转ModbusTCP网关模块连接马达保护器（马保）与上位机进行通讯，主要涉及硬件连接、配置设置以及数据交互等步骤。以下是一个详细的流程说明：
一、硬件连接
1.确保接口匹配：首先，检查Profibus转ModbusTCP网关模块、马达保护器以及上位机的接口是否匹配，包括电缆类型、接口类型等。
2.物理连接：使用适当的电缆将Profibus转ModbusTCP网关模块与马达保护器连接起来，同时确保网关模块与上位机（如PC、PLC等）之间的连接也是正确的。
二、配置设置
1.导入GSD文件：
将Profibus转ModbusTCP网关模块的GSD文件导入到上位机的配置软件中。GSD文件包含了网关模块的设备描述信息，有助于上位机正确识别网关模块。
在上位机的配置软件中，选择导入GSD文件，并按照软件提示进行安装。
2.添加模块设备：
在上位机的配置软件中，添加Profibus转ModbusTCP网关模块设备，并设置其相关参数，如IP地址、设备名称等。
确保这些参数与网关模块的实际配置相匹配。
3.配置ModbusTCP参数：
在网关模块的配置软件中，设置ModbusTCP通信参数，如波特率（对于TCP协议来说，这个参数实际上是TCP连接的端口号或IP地址及端口组合）、数据位、停止位和校验方式等。这些参数需要与马达保护器的通信参数相匹配。
注意，由于ModbusTCP是基于TCP/IP协议的，因此不需要设置波特率等传统串行通信参数，而是需要设置IP地址和端口号等网络参数。
4.添加数据映射：
在配置软件中，添加数据映射关系，将Profibus协议的数据地址与ModbusTCP协议的数据地址进行映射。这样，当上位机通过ModbusTCP协议访问特定地址时，网关模块能够将其转换为Profibus协议的数据请求，并发送给马达保护器。
确保数据映射的准确性，以避免数据错位或丢失。
5.下载配置：
将配置好的参数下载到Profibus转ModbusTCP网关模块中，并重新启动设备，使其生效。
三、数据交互
1.上位机发送指令：
上位机通过ModbusTCP协议向Profibus转ModbusTCP网关模块发送数据读写请求。
2.网关模块转换：
网关模块接收到ModbusTCP协议的数据请求后，将其转换为Profibus协议的数据请求，并发送给马达保护器。
3.马达保护器响应：
马达保护器接收到Profibus协议的数据请求后，执行相应的操作，并将结果返回给网关模块。
4.网关模块再转换：
网关模块将马达保护器的响应结果转换为ModbusTCP协议的数据格式，并发送给上位机。
5.上位机接收数据：
上位机接收到ModbusTCP协议的数据后，进行解析和处理，以获取所需的信息。
通过以上步骤，Profibus转ModbusTCP网关模块可以成功连接马达保护器与上位机，实现它们之间的数据交互。在实际应用中，还需要注意通信协议的兼容性、设备的兼容性以及通信参数的准确性等问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eeffadc0c2f36934dde9c328d7b8eef/" rel="bookmark">
			【C&#43;&#43;航海王：追寻罗杰的编程之路】关联式容器的底层结构——红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 -&gt; 红黑树
1.1 -&gt; 红黑树的概念
1.2 -&gt; 红黑树的性质
1.3 -&gt; 红黑树节点的定义
1.4 -&gt; 红黑树的结构
1.5 -&gt; 红黑树的插入操作
1.6 -&gt; 红黑树的验证
1.8 -&gt; 红黑树与AVL树的比较
2 -&gt; 红黑树模拟实现STL中的map与set
2.1 -&gt; 红黑树的迭代器
2.2 -&gt; 改造红黑树
2.3 -&gt; map的模拟实现
2.4 -&gt; set的模拟实现
1 -&gt; 红黑树 1.1 -&gt; 红黑树的概念 红黑树，是一种二叉搜索树，但在每个节点上增加了一个存储位表示节点的颜色，可以是Red或Black。通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。
1.2 -&gt; 红黑树的性质 每个节点不是红色就是黑色。根节点是黑色的。如果一个节点是红色的，则它的两个孩子节点是黑色的。对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。每个叶子节点都是黑色的(此处的叶子节点指空节点)。 1.3 -&gt; 红黑树节点的定义 #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;iostream&gt; using namespace std; // 节点的颜色 enum Color { RED, BLACK }; // 红黑树节点的定义 template&lt;class ValueType&gt; struct RBTreeNode { RBTreeNode(const ValueType&amp; data = ValueType()，Color color = RED) : _pLeft(nullptr), _pRight(nullptr), _pParent(nullptr) , _data(data), _color(color) {} RBTreeNode&lt;ValueType&gt;* _pLeft; // 节点的左孩子 RBTreeNode&lt;ValueType&gt;* _pRight; // 节点的右孩子 RBTreeNode&lt;ValueType&gt;* _pParent; // 节点的双亲(红黑树需要旋转，为了实现简单给出该字段) ValueType _data; // 节点的值域 Color _color; // 节点的颜色 }; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eeffadc0c2f36934dde9c328d7b8eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66b9bffb211a91160ca021604d44ae8/" rel="bookmark">
			react启用mobx @decorators装饰器语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react如果没有经过配置，直接使用decorators装饰器语法会报错：
Support for the experimental syntax ‘decorators’ isn’t currently enabled
因为react默认是不支持装饰器语法，需要做一些配置来启用装饰器语法。
step1: 在 tsconfig.json 中启用编译器选项 “experimentalDecorators”: true
vscode点击设置，输入搜索experimentalDecorators
step2: 安装支持修饰器所需依赖。
yarn add -D @babel/core @babel/plugin-proposal-decorators @babel/preset-env 创建.babelrc文件，配置
{ "presets": [ "@babel/preset-env" ], "plugins": [ [ "@babel/plugin-proposal-decorators", { "legacy": true } ] ] } step3: 安装依赖
yarn add -D customize-cra react-app-rewired 在项目根目录下创建 config-overrides.js 并写入以下内容，覆盖默认配置。
const path = require('path') const { override, addDecoratorsLegacy } = require('customize-cra') function resolve(dir) { return path.join(__dirname, dir) } const customize = () =&gt; (config, env) =&gt; { config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66b9bffb211a91160ca021604d44ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a46b1d50ff0446d9ffdedaf2c45bf18/" rel="bookmark">
			Stable Diffusion / huggingface 相关配置问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 `OSError: Can't load tokenizer for 'openai/clip-vit-large-patch14'.`报错解决方法方法1——手动下载方法2——自动下载其他方法（待研究） 2 `huggingface_hub.utils._errors.LocalEntryNotFoundError:`报错解决方法 笔者在配置SD的时候遭遇了许多bug，特此汇总如下： 1 OSError: Can't load tokenizer for 'openai/clip-vit-large-patch14'. 报错 完整报错如下：
OSError: Can't load tokenizer for 'openai/clip-vit-large-patch14'. If you were trying to load it from 'https://huggingface.co/models', make sure you don't have a local directory with the same name. Otherwise, make sure 'openai/clip-vit-large-patch14' is the correct path to a directory containing all relevant files for a CLIPTokenizer tokenizer. 这是由于 huggingface 网站上不去导致的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a46b1d50ff0446d9ffdedaf2c45bf18/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/172/">«</a>
	<span class="pagination__item pagination__item--current">173/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/174/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>