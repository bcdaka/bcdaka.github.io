<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0462778a817fd0ea45228e6131e7a1/" rel="bookmark">
			【算法】单调队列&amp;&amp;单调栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单调队列 用来维护一段区间内的最大值或最小值，例如滑动窗口、区间最值等问题。
基本概念 单调队列是一种存储数据的队列，其中元素的顺序是单调递增或单调递减的。在算法竞赛中，我们一般使用两个单调队列，一个维护单调递增序列，另一个维护单调递减序列。单调队列是一个双端队列。
代码如下：
#include &lt;iostream&gt; #include &lt;deque&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; void output(vector&lt;int&gt;&amp; arr) { int n = arr.size(), len = 0; for (int i = 0; i &lt; n; i++) len += printf("%3d", i); cout &lt;&lt; "\n"; for (int i = 0; i &lt; len; i++)printf("-"); cout &lt;&lt; "\n"; for (int i = 0; i &lt; n; i++) len += printf("%3d", arr[i]); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e0462778a817fd0ea45228e6131e7a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258181cb9284466b80ec7cfeb670adf8/" rel="bookmark">
			探展2024世界人工智能大会之合合信息扫描黑科技～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ⭐️ 前言⭐️ AIGC古籍修复文化遗产焕新⭐️ 高效的文档图像处理解决方案⭐️ AIGC扫描黑科技一键全搞定⭐️ 行业级的大模型加速器⭐️ 结语 ⭐️ 前言 大家好，我是 哈哥（哈哥撩编程） ，这次非常荣幸受邀作为专业观众参加了「2024世界人工智能大会」，感受这场人工智能的科技盛宴。
大家也都知道，在科技日新月异的今天，人工智能（AI）作为新一轮科技革命和产业变革的重要驱动力，正以前所未有的速度改变着我们的世界。而作为全球人工智能领域的顶尖盛会，本次大会不仅汇聚了全球顶尖的科技企业、专家学者及行业精英，更成为了前沿技术、创新产品与应用场景的集中展示平台，引领着未来科技发展的风向标。
也正是基于这样的背景与期待，我特别撰写了这篇 “探展2024世界人工智能大会之合合信息扫描黑科技”。希望通过本次的分享，能够为众多不能够到现场的小伙伴感受人工智能技术的无限魅力与广阔前景。
⭐️ AIGC古籍修复文化遗产焕新 在今年的WAIC有着超过500家国内外的企业参展，展示的内容包括 “大模型”、“算力”、“机器人” 以及一大批与AI技术相结合的产品。
出于对 “历史” 的喜爱，当我了解到大会现场有展台可以做到对现有古籍进行数字技术修复的时候，进入会场的第一时间就去寻找实现了 “古籍修复” 的 “合合信息展台” 。
有些古代的书籍存在脏污、残缺、磨损的情况，对于对古籍的阅读非常的不方便。古籍数字化已经成为文化保护和发展的新方向和新趋势，其尤其强调对古籍文本进行数字化处理，例如数字化输入技术、智能化处理技术、古籍自动句读与标点、古籍词语自动切分、古籍命名实体识别、计算机图像识别等。
而现场展示的 “AIGC古籍修复” 模型，可以通过 智能高清滤镜 算法的加持下，解决古籍文档中存在的文字残缺、破损、肉眼难以辨认的问题。基于待修复区域的内容和位置先验信息，模型可智能学习不同古籍文字风格、纸张背景，对损坏区域的字体内容、风格进行高度还原，确保修复区域的文字风格和背景与原古籍尽量一致，用科技让文化遗产呈现出新的面貌。
⭐️ 高效的文档图像处理解决方案 智能高清滤镜的全新升级，更是为用户提供了专业且高效的文档图像处理解决方案。不论是受拍摄环境影响的光线、阴影、遮挡，以及污渍、折痕等都能够AI一键处理，并进行智能还原高清显现。
在办公场景中，智能高清滤镜可以用于快速的文档数字化。用户只需运用智能手机拍照扫描，智能高清滤镜将自动识别文档内容、优化图像质量，生成高质量的文档电子版，助力无纸化办公，以提高文档传输、存储和管理的效率和质量。
在教育领域，可以用于学生笔记的扫描和整理。无需考虑拍照的混乱背景和反光问题，智能高清滤镜将一键优化图像质量，识别文本信息，生成高清数码版笔记，以提高学生的学习效率和便利性。
在法律和会计领域，可以对法律文件和财务报表进行扫描，高清还原证件和证据材料，优化图像质量和识别文本信息，以提高法律和会计工作的效率和准确性。
总的来讲，"扫描全能王"的“智能高清滤镜2.0”具有更为智能的图像处理能力、更为智慧的场景决策功能，更为强大的版面清晰度和还原度，给用户带来准确、高清、便捷的使用体验，提升生活与生产效率。
⭐️ AIGC扫描黑科技一键全搞定 除此之外，像是这种毫米级核雕文字，使用滤镜提升图像清晰度后，可从核桃上提取出4行仅有1毫米长的微雕文字。山高月小，水落石出。清风徐来、水波不兴。
像是现场演示的山鸟图、上个世纪的家书以及老旧的照片，都可以进行智能处理、高清显现与高清修复。也正是因为如此，“扫描全能王” 被誉为扫描领域的 “懒人相机”！你没听错，这么多且非常强大的功能，都可以通过 “扫描全能王” 一键搞定。
⭐️ 行业级的大模型加速器 大家都知道未来十年看AI，在大模型迅速发展的现在，企业对用于训练的数据语料的需求与日俱增。
合合信息大模型加速器 的文档解析引擎仅仅需要1.5秒便可以解析高达百页的长文档，在表格内容还原、复杂样本处理、多语言文档识别等方面，合合信息大模型“加速器”具备高准确性和稳定性，大幅提升了模型的理解力，并通过其强大的多语言识别、多类型支持能力，为用户提供了高效、准确、实用的文档解析服务。便于用户更好的处理表格、图像、文档，是目前市面上最快的文档解析产品之一。
目前，“合合信息大模型加速器” 已被应用于多家头部大模型厂商的预训练流程。在金融、财经、建筑、医疗等数据密集型领域中建立起“行业级知识库”，帮助企业实现知识资产管理、搜索效率提升，优化业务沟通流程。
⭐️ 结语 以上便是我在现场体验的技术展示与应用，这次体验让我感受到了人工智能的进步，不再是一款傻瓜式的对话机器人，更是可以具像化的科技盛宴。
合合信息是一家人工智能及大数据科技企业，欢迎各位感兴趣的朋友到 textin.com 了解更多关于智能文字识别产品和技术的信息，体验智能图像处理、文字表格识别、文档内容提取等产品。
展望未来，我们满怀信心与期待。相信在不久的将来，人工智能技术将继续引领全球科技革命和产业变革，为我们带来更加便捷、智能、美好的生活体验。让我们携手并进，共同开创人工智能的美好未来！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8c5b9242562943452e276bbed44565/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(012)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
28、pandas.HDFStore.keys函数
28-1、语法
28-2、参数
28-3、功能
28-4、返回值
28-5、说明
28-6、用法
28-6-1、数据准备
28-6-2、代码示例
28-6-3、结果输出
29、pandas.HDFStore.groups函数
29-1、语法
29-2、参数
29-3、功能
29-4、返回值
29-5、说明
29-6、用法
29-6-1、数据准备
29-6-2、代码示例
29-6-3、结果输出 30、pandas.HDFStore.walk函数
30-1、语法
30-2、参数
30-3、功能
30-4、返回值
30-5、说明
30-6、用法
30-6-1、数据准备
30-6-2、代码示例
30-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 28、pandas.HDFStore.keys函数 28-1、语法 # 28、pandas.HDFStore.keys函数 HDFStore.keys(include='pandas') Return a list of keys corresponding to objects stored in HDFStore. Parameters: include str, default ‘pandas’ When kind equals ‘pandas’ return pandas objects. When kind equals ‘native’ return native HDF5 Table objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8c5b9242562943452e276bbed44565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/facf36dcd848175d824c2cf1ba8a3566/" rel="bookmark">
			PHP在线客服系统源码/全开源客服系统源码APP&#43;H5&#43;小程序搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线客服系统源码是一种利用计算机技术实现在线客服功能的软件代码。随着互联网的发展，越来越多的企业意识到在线客服的重要性，因此出现了许多在线客服系统源码。本文将介绍在线客服系统源码的基本功能、实现原理以及应用场景，并对几种常见的在线客服系统源码进行比较和评价。
源码及演示：zxkfym.top
在线客服系统源码的基本功能包括：实时聊天、多渠道接入、智能机器人、消息推送和统计分析。首先，实时聊天是在线客服系统的核心功能，它允许用户与客服人员进行实时的文字、语音或视频交流，解决问题和提供帮助。其次，多渠道接入允许用户通过网页、手机应用、微信公众号等多种渠道与客服人员进行沟通，提高客户服务的便利性和灵活性。再次，智能机器人是在线客服系统的一个重要组成部分，它能够根据用户的问题快速给出答案，并且具备学习和优化的能力，提高客户服务的效率和质量。此外，消息推送功能可以通过短信、邮件、消息推送等方式将重要信息及时送达给客户，增强客户的参与和满意度。最后，统计分析功能可以收集和分析客户的行为数据，为企业提供决策支持和改进客户服务的思路。
在线客服系统源码的实现原理主要包括用户接入、消息传递和数据处理三个环节。首先，用户接入是指用户通过网页、手机应用等方式接入在线客服系统。用户接入之后，在线客服系统会生成一个唯一的用户标识，并将用户的接入信息保存到数据库中。其次，消息传递是指用户与客服人员之间的消息传递过程。用户发送的消息经过在线客服系统的消息服务器，然后传递给客服人员进行处理。客服人员对用户的消息进行回复后，消息服务器将回复消息传递给用户。最后，数据处理是指在线客服系统对用户和客服人员的消息进行处理和分析。在线客服系统会将用户和客服人员的消息保存到数据库中，并进行统计和分析，为企业提供客户服务的决策依据。
在线客服系统源码在各种行业和企业中都有广泛的应用。首先，电子商务行业是在线客服系统的主要应用领域之一。通过在线客服系统，电子商务企业可以与顾客进行实时的沟通和交流，解决问题和提供帮助，提高客户的购物体验和满意度，从而促进销售和客户忠诚度的提升。其次，金融行业也是在线客服系统的重要应用领域之一。金融机构可以通过在线客服系统为客户提供专业的金融咨询和服务，解决客户的问题和困惑，增强客户的信任感和忠诚度。另外，教育、医疗、旅游等行业也可以利用在线客服系统提供更好的客户服务和支持。
在市面上有许多在线客服系统源码供企业选择，其中比较受欢迎的有PHP+MySQL和Java的开源系统。PHP+MySQL开源系统使用简单，扩展性好，适合小型和中型企业使用，并且有很多的开发者和社区支持。Java开源系统具有更强的稳定性和安全性，适合大型企业使用，但开发和维护成本较高。此外，还有一些商业化的在线客服系统源码，它们通常具有更丰富的功能和更好的服务，但需要支付一定的费用。
一、在线客服系统源码的基本原理
在线客服系统源码是基于Web技术和即时通信技术的一种应用。它通过Web页面的形式提供客户与企业客服人员之间的即时互动和沟通。客户可以通过网页表单、聊天窗口或者语音视频等方式与客服人员进行实时对话，获取所需的帮助和支持。
在线客服系统源码的基本原理包括以下几个步骤：
1. 客户访问企业的网站或者应用程序，点击在线客服系统入口。
2. 客户与在线客服系统建立连接，并提供相关的个人信息和问题描述。
3. 客服系统将客户信息和问题转发给相应的客服人员。
4. 客服人员接收到客户信息后，可以通过聊天窗口或者语音视频等方式与客户进行实时对话，解答问题或提供帮助。
5. 在对话过程中，客服人员可以查阅相关的知识库、FAQ等资源，以提供更准确和全面的答案。
6. 客户和客服人员的对话内容会被记录保存，以便后续的跟踪和分析。
二、在线客服系统源码的功能
在线客服系统源码的功能主要包括以下几个方面：
1. 实时对话：客户和客服人员可以通过聊天窗口或者语音视频等方式进行实时对话，提供即时的帮助和支持。
2. 多渠道接入：在线客服系统可以通过Web页面、手机应用、微信公众号等多种渠道接入，方便客户进行咨询和反馈。
3. 智能分流：在线客服系统可以根据客户的问题类型、优先级等信息，自动将问题分配给相应的客服人员，提高工作效率。
4. 知识库管理：在线客服系统可以管理和维护企业的知识库、FAQ等资源，方便客服人员查询和使用，提供更准确和全面的答案。
5. 数据统计和分析：在线客服系统可以对客户的咨询和对话数据进行统计和分析，帮助企业了解客户需求，改进客户服务。
三、在线客服系统源码的应用领域
在线客服系统源码可以广泛应用于各个行业和领域。以下是一些常见的应用领域：
1. 电子商务：在线客服系统可以帮助电子商务企业与顾客进行交流和沟通，提供在线购物咨询、售后服务等支持。
2. 金融服务：在线客服系统可以帮助银行、保险公司等金融机构与客户进行实时对话，提供贷款咨询、理财建议等服务。
3. 教育培训：在线客服系统可以帮助教育培训机构与学生和家长进行沟通，提供课程咨询、学习支持等服务。
4. 医疗健康：在线客服系统可以帮助医疗机构与患者进行实时对话，提供医疗咨询、预约挂号等服务。
四、在线客服系统源码的开发过程
开发一个在线客服系统源码需要以下几个步骤：
1. 需求分析：了解客户的需求和期望，明确系统的功能和要求。
2. 技术选型：选择合适的Web开发框架、即时通信技术等技术方案。
3. 系统设计：设计系统的架构、数据模型和用户界面。
4. 系统开发：根据设计方案，编写程序代码，实现系统的各个功能模块。
5. 测试和调试：对系统进行测试，修复漏洞和错误，确保系统的稳定性和安全性。
6. 部署上线：将系统部署到服务器上，让用户可以访问和使用。
五、在线客服系统源码的未来发展
随着互联网技术的不断发展，在线客服系统源码将会有更多的创新和应用。以下是一些未来可能的发展方向：
1. 人工智能技术的应用：通过引入自然语言处理、机器学习等人工智能技术，提高系统的智能化和自动化水平。
2. 多渠道整合：将在线客服系统与其他渠道的客户服务进行整合，实现全渠道一体化的客户服务体验。
3. 数据驱动的个性化服务：通过分析客户的行为和偏好，为客户提供更个性化的服务和推荐。
4. 语音识别和图像识别技术的应用：通过语音识别和图像识别技术，实现更多样化和便捷化的客户服务方式。
在线客服系统源码的实现基于多种技术，包括前端和后端编程语言、数据库和服务器等。前端部分负责展示界面和与用户的交互，通常使用HTML、CSS和JavaScript等技术进行开发。后端部分负责处理用户请求和与数据库进行交互，通常使用PHP、Java、Python等语言进行开发。数据库用于存储用户信息、对话记录和其他相关数据，常用的数据库管理系统包括MySQL和MongoDB等。服务器用于部署和运行在线客服系统，常用的服务器软件包括Apache和Nginx等。
在线客服系统源码的核心功能包括在线聊天、消息推送、多渠道对接和数据分析等。在线聊天功能允许用户通过文本、语音或视频与客服进行实时交流，提供了更便捷和高效的沟通方式。消息推送功能可以将重要信息和通知及时推送给用户，提高信息传递的效率。多渠道对接功能允许企业将在线客服系统集成到自己的网站、APP或社交媒体平台中，实现多渠道的客户服务。数据分析功能可以对用户行为和客户服务质量进行统计和分析，帮助企业优化客户服务策略和提升客户满意度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/facf36dcd848175d824c2cf1ba8a3566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ac2fda2ea0c0b950770d6d33c48b11/" rel="bookmark">
			使用bypy丝滑传递百度网盘-服务器文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 还在为百度网盘的数据集难以给服务器做同步而痛苦吗，bypy来拯救你了！bypy是一个强大而灵活的百度网盘命令行客户端工具。它是基于Python开发的开源项目，为用户提供了一种通过命令行界面与百度网盘进行交互的方式。使用bypy，可以轻松地执行上传、下载、同步、列出目录内容等操作，这个工具特别适合需要自动化网盘操作或偏好命令行界面的用户。bypy支持增量同步，能有效处理大文件，并提供了丰富的命令选项，我觉得是一个特别优雅的小工具，推荐给大家
安装 首先服务器要有一个python3的环境，然后用pip安装即可
pip3 install bypy 登录百度网盘账号 输入任意指令，初次会让你登录账号
bypy list 进入它给的这个链接，去生成一个验证码
完成验证后，它正确执行了bypy list的指令。然后就可以愉快的操作了
基本操作 列出目录内容:
bypy list [远程目录] 例如: bypy list / 列出根目录内容，不加这个/，也是默认根目录，就跟我们前面看到的效果一样。
bypy会在你的百度网盘里的这个目录里，应用数据/bypy/下面，所以如果你要把网盘的内容通过bypy放到服务器，你需要现在网盘里把数据先移到bypy的目录下。同理，这里上传下载对应的目录都是你百度网盘里应用数据/bypy/这里路径下
上传文件或目录:
bypy upload &lt;本地路径&gt; [远程目录] 例如: bypy upload /home/user/documents /docs
下载文件或目录:
bypy download &lt;远程路径&gt; [本地目录] 例如: bypy download /docs/file.txt /home/user/downloads
不过我更喜欢在服务器进入具体的路径后，再执行download，这样直观一点, 其他指令类同
同步本地目录到云端:
bypy syncup &lt;本地目录&gt; [远程目录] 同步云端目录到本地:
bypy syncdown [远程目录] [本地目录] 比较本地和远程目录:
bypy compare &lt;本地目录&gt; &lt;远程目录&gt; 显示文件信息:
bypy info &lt;远程文件路径&gt; 创建远程目录:
bypy mkdir &lt;远程目录路径&gt; 删除远程文件或目录:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6ac2fda2ea0c0b950770d6d33c48b11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709ef2e43c2580703723a800a8100d97/" rel="bookmark">
			AI：助力开发者翱翔，而非抢夺其舞台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今这个科技飞速发展的时代，人工智能（AI）犹如一股春风，悄然渗透进全球各个行业，尤其在软件开发领域，其影响力日益显著。从初创企业到跨国巨头，无一不在积极探索AI如何重塑编程的面貌，引发了一场关于它究竟是开发者的朋友还是潜在对手的热烈讨论。本文将深入探讨AI对软件工程师的影响，揭示其真实角色，以期为业界同仁提供一份全面的视角。
🗜️AI：开发者的得力助手 AI不是来势汹汹的竞争者，而是软件工程师最可靠的伙伴。在日常编码中，AI凭借智能代码补全、自动错误检测与修复等特性，显著提高了开发效率。AI技术的发展，特别是自然语言处理、机器学习和深度学习的进步，正在成为软件开发者们的得力助手。以下几点展示了AI是如何为开发者赋能的：
智能代码建议：通过分析大量源代码库，AI系统能够预测并提供代码建议，帮助开发者提高编码效率，减少错误。例如，Google的TensorFlow和Microsoft的Visual Studio Code等开发工具，它们内置的AI功能可以根据现有代码结构和上下文，智能推荐代码段，减轻重复工作负担，使开发者能够集中精力应对更具挑战性的问题，如算法优化、架构设计等。这种智能辅助不仅加速了开发进程，还提升了代码质量，减少了后期调试的时间成本。。
自动化测试与调试：AI可以自动识别代码中的潜在bug，并提供修复建议。这不仅节省了人工测试的时间，也提高了软件的质量和稳定性。在软件测试与维护环节，AI同样大显身手。它能自动化测试流程，实时监测性能，迅速定位潜在漏洞，缩短问题解决周期，保证应用的稳定与安全。这意味着，开发者不再需要花费大量时间在繁琐的测试和维护工作中，而是可以将更多精力投入到产品创新和用户体验的优化中，进一步推动软件产品的迭代和进化。
智能文档生成：AI可以自动生成代码注释和文档，减轻了开发者在编写文档上的负担，这也是目前应用最广泛的技术层面，很多人借助AIGC去完成各种文本的撰写，不可否认的是，AI生成的文章确实在质量方面能够符合人们当下的切实需求，并节省出大量时间，对于IT行业从事者来说，更让我们能够更加专注于核心功能的开发，而非报告等相关文档的撰写。
个性化开发环境：AI可以根据开发者的习惯和偏好调整IDE（集成开发环境），提供个性化的编程体验，提升工作效率。
⚖️激发创新的火花 AI的崛起，并非对开发者的威胁，反而成为了激发创新潜能的催化剂。AI擅长数据处理和模式识别，而人类在创意、战略规划和情感理解方面拥有独特优势。在AI的协助下，开发者可以从宏观角度审视项目，探索创新设计思路，推动技术边界的持续扩张。例如，在游戏开发中，AI可以帮助创建更为复杂的虚拟环境和智能NPC（非玩家控制角色），提升玩家的沉浸感；在医疗软件开发中，AI能辅助医生分析病例，提高诊断精度，为患者提供更加个性化的治疗方案。
在AI算法设计与优化中，虽然AI能高效处理计算密集型任务，但构建算法框架、选择最优参数等决策过程，仍需人类智慧的介入。这些判断基于对业务目标的深刻洞察和市场趋势的敏锐感知，是AI目前难以完全模拟的人类特质。因此，AI与开发者的合作，是技术与灵感的完美结合，共同推动着软件领域的创新与发展。
🧰引领职业转型与升级 面对AI的兴起，开发者无需恐惧，而应将其视为职业成长的良机。AI的广泛应用促使开发者持续精进，学会与AI协同作业，掌握数据科学、机器学习等前沿技能，以适应行业变革。这样的自我提升不仅能增强个人竞争力，还能推动整个行业的技术进步和产业升级。例如，随着AI在自然语言处理领域的突破，掌握相关技术的开发者能够开发出更为智能的聊天机器人、语音助手等，满足日益增长的市场需求。
🪜结语：AI与开发者的共生关系 AI与开发者之间的关系，更像是一种互利共生的伙伴关系。AI通过自动化基础任务，释放了开发者的潜力，使他们能够投身于更有价值的工作，如策略规划、创意设计等，进而促进技术创新和个人成长。在这个进程中，开发者应保持开放的学习态度，主动迎接变革，方能在AI时代中立于不败之地。AI的发展为软件开发领域开辟了全新的天地，它并非意在替代开发者，而是致力于成为他们强大的助手，共同书写科技的未来篇章。开发者应把握时机，与AI并肩作战，开启一场充满无限可能的职业冒险，共同探索未知的科技边界。
🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀
以上，就是本期的全部内容啦，若有错误疏忽希望各位大佬及时指出💐
制作不易，希望能对各位提供微小的帮助，可否留下你免费的赞呢🌸
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a47df23b32cb81b9a6f2fccb248ffdc/" rel="bookmark">
			「Pytorch」CopyPaste 数据增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据增广是提升模型泛化能力重要的手段之一，CopyPaste 是一种新颖的数据增强技巧，已经在目标检测和实例分割任务中验证了有效性。利用 CopyPaste，可以合成文本实例来平衡训练图像中的正负样本之间的比例。相比而言，传统图像旋转、随机翻转和随机裁剪是无法做到的。
CopyPaste 主要步骤包括：
随机选择两幅训练图像；随机尺度抖动缩放；随机水平翻转；随机选择一幅图像中的目标子集；粘贴在另一幅图像中随机的位置。 这样就比较好地提升了样本丰富度，同时也增加了模型对环境的鲁棒性。如下图所示，通过在左下角的图中裁剪出来的文本，随机旋转缩放之后粘贴到左上角的图像中，进一步丰富了该文本在不同背景下的多样性。
参考代码：
# !/usr/bin/env python # -*- coding:utf-8 -*- # @Time : 2024.07 # @Author : 绿色羽毛 # @Email : lvseyumao@foxmail.com # @Blog : https://blog.csdn.net/ViatorSun # @Note : import os import cv2 import json import logging import random import numpy as np import matplotlib.pyplot as plt def create_operators(op_param_list, global_config=None): """ create operators based on the config Args: params(list): a dict list, used to create some operators "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a47df23b32cb81b9a6f2fccb248ffdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f761eccd35cd7df1b991775d4cb8d4/" rel="bookmark">
			【PyTorch单点知识】自动求导机制的原理与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 前言1. 自动求导的基本原理2. PyTorch中的自动求导2.1 创建计算图2.2 反向传播2.3 反向传播详解2.4 梯度清零2.5 定制自动求导 3. 代码实例：线性回归的自动求导4. 结论 0. 前言 按照国际惯例，首先声明：本文只是我自己学习的理解，虽然参考了他人的宝贵见解及成果，但是内容可能存在不准确的地方。如果发现文中错误，希望批评指正，共同进步。
在深度学习中，自动求导（Automatic Differentiation, AD）是一项至关重要的技术，它使我们能够高效地计算神经网络的梯度，进而通过反向传播算法更新权重。
PyTorch作为一款动态计算图的深度学习框架，以其灵活性和易用性著称，其自动求导机制是其实现高效、灵活训练的核心。本文将深入探讨PyTorch中的自动求导机制，从原理到实践，通过代码示例来展示其工作流程。
如果对计算图不太了解，可以参考我的往期文章：基于TorchViz详解计算图（附代码）
1. 自动求导的基本原理 自动求导是一种数学方法，用于计算函数的导数。与数值微分相比，自动求导能够提供精确的导数计算结果，同时避免了符号微分中可能出现的手动求导错误。在深度学习中，我们通常关注的是反向模式backward的自动求导，即从输出向输入方向传播梯度的过程。
反向模式自动求导基于链式法则，它允许我们将复杂的复合函数的导数分解成多个简单函数的导数的乘积。在神经网络中，每一层都可以看作是一个简单的函数，通过链式法则，我们可以从前向传播的输出开始，逆向计算每个参数的梯度。
2. PyTorch中的自动求导 PyTorch通过其autograd模块实现了自动求导机制。autograd记录了所有的计算步骤，创建了一个计算图（Computational Graph），并在需要时执行反向传播，计算梯度。
2.1 创建计算图 在PyTorch中，当一个张量（Tensor）的requires_grad=True时，任何对该张量的操作都会被记录在计算图中。例如：
import torch x = torch.ones(2, 2, requires_grad=True) y = x + 2 z = y * y * 3 out = z.mean() print(y.grad_fn) # 查看y的计算节点 print(z.grad_fn) # 查看z的计算节点 输出为：
&lt;AddBackward0 object at 0x000001CADEC6AB60&gt; &lt;MulBackward0 object at 0x000001CADEC6AB60&gt; 在上述代码中，z的计算节点显示了z是如何由y计算得来的，而y的计算节点则显示了y是如何由x计算得来的。这样就形成了一个计算图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f761eccd35cd7df1b991775d4cb8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666979c82e8d6472d12c3492119d10c4/" rel="bookmark">
			Kafka发送对象消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在配置中添加json序列化器 spring: application: name: spring-boot-kafka-base kafka: bootstrap-servers: 192.168.225.128:9092 # 配置生产者序列化 producer: value-serializer: org.springframework.kafka.support.serializer.JsonSerializer # 配置默认的topic template: default-topic: test 发送对象消息 public void sendEvent5(){ kafkaTemplate.sendDefault(null,System.currentTimeMillis(),"k3",User.builder() .age(10) .name("小王") .build()); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e287a16410f05a48646f9f696a4e45/" rel="bookmark">
			SpringBoot前后端交互、全局异常处理：后端异常信息抛到前端显示弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提是前端必须有接收后端信息的载体：比如：ajax的异步接收等等。
后端：
编写后端的统一返回信息类：
/** * 后端统一返回结果 * @param &lt;T&gt; */ @Data public class Result&lt;T&gt; implements Serializable { private Integer code;//1成功，0和其他数字为失败。 private String msg;//错误信息 private T data;//数据 public static &lt;T&gt; Result&lt;T&gt; success(){ Result&lt;T&gt; result = new Result&lt;T&gt;(); result.code=1; return result; } public static &lt;T&gt; Result&lt;T&gt; success(T object){ Result&lt;T&gt; result = new Result&lt;T&gt;(); result.data=object; result.code=1; return result; } public static &lt;T&gt; Result&lt;T&gt; error(String msg){ Result&lt;T&gt; result = new Result&lt;T&gt;(); result.code=0; result.msg=msg; return result; } } 异常基础类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1e287a16410f05a48646f9f696a4e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87405e9647061018ab5243a39bde8a6a/" rel="bookmark">
			《无所不能的JavaScript · prototype 原型链》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢 大家好，我是 【战神刘玉栋】，有10多年的研发经验，致力于前后端技术栈的知识沉淀和传播。 💗
🌻 近期刚转战 CSDN，会严格把控文章质量，绝不滥竽充数，欢迎多多交流。👍
文章目录 写在前面的话快速了解知识介绍prototype 与原型链关于 prototype 继承使用 prototype 添加属性原型链的性能和优化Java 和 JavaScript 面向对象 用法拓展创建对象的N种方式prototype 实现继承扩展原有对象的方法 Demoprototype 基础测试 Demo 总结陈词 写在前面的话 又回到前端系列了，之前写后端和其他内容去了，进度落下，赶紧补一下。
本篇文章介绍一下 JavaScript 里面的一些经典知识点，先以prototype原型链开篇。
让我们开始！
快速了解 【概念说明】
在JavaScript中，每个对象都有一个原型prototype属性，它指向另一个对象。这个被指向的对象也有自己的原型，以此类推，最终形成了一个原型链。原型链的顶端是Object.prototype，它是所有对象的根原型。
当我们访问一个对象的属性时，如果该对象自身没有这个属性，JavaScript会沿着原型链向上查找，直到找到匹配的属性或者到达原型链的末端。
【用代码说话】
直接上一段示例代码：
function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHello = function() { console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`); }; const alice = new Person('Alice', 20); alice.sayHello(); // 输出：Hello, my name is Alice and I am 20 years old.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87405e9647061018ab5243a39bde8a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0db76fda21f3af20e8bcabfbcda7916/" rel="bookmark">
			大数据下的用户研究：深度洞察与精准决策的引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、大数据时代的用户研究新机遇二、大数据用户研究的流程与关键技术三、大数据用户研究的实践案例四、大数据用户研究的挑战与展望《用户研究方法：卓越产品和服务的用户研究技巧》内容及特色读者对象 在当今这个数据爆炸的时代，大数据已成为推动各行各业创新与变革的关键力量。在用户研究领域，大数据的引入不仅极大地拓展了研究的广度和深度，还为我们提供了前所未有的机会去深入了解用户行为、心理及需求，进而指导企业的产品优化、市场策略及客户服务。
一、大数据时代的用户研究新机遇 随着互联网、物联网、社交媒体等技术的飞速发展，用户产生的数据以前所未有的速度增长。这些数据涵盖了用户的基本信息、行为轨迹、偏好选择、社交互动等多个维度，为企业提供了丰富的用户洞察资源。大数据的引入，使得用户研究能够摆脱传统调研方法的局限，实现更加全面、深入、实时的用户洞察。
二、大数据用户研究的流程与关键技术 数据收集：利用先进的爬虫技术、API接口、SDK埋点等多种方式，从多个渠道收集用户数据。这些数据包括用户基本信息、浏览记录、购买行为、社交互动、评论反馈等，形成用户数据仓库。数据处理：对收集到的原始数据进行清洗、去重、转换、标准化等处理，确保数据的准确性和一致性。同时，利用大数据处理技术（如Hadoop、Spark等）对数据进行高效存储与计算，为后续分析提供有力支持。用户画像构建：基于处理后的数据，运用统计分析、聚类分析、关联规则挖掘等方法，构建用户的多维度画像。这些画像包括用户的基本属性（如年龄、性别、地域）、消费习惯（如购买频率、品牌偏好）、兴趣爱好（如阅读偏好、娱乐方式）等，为企业实现精准营销和个性化服务提供基础。行为分析：运用时间序列分析、路径分析、情感分析等技术手段，对用户行为进行深度挖掘。通过分析用户的浏览路径、停留时间、点击率、转化率等指标，揭示用户的行为模式与偏好趋势，为企业优化产品体验、提升用户满意度提供决策依据。预测与决策支持：结合历史数据与实时数据，运用机器学习、深度学习等预测模型，对用户未来的行为进行预测。同时，将预测结果与业务目标相结合，制定针对性的市场策略、产品优化方案及客户服务策略，实现业务增长与用户体验的双重提升。 三、大数据用户研究的实践案例 电商行业：通过分析用户的购买历史、浏览行为、搜索关键词等数据，构建用户画像并推荐个性化商品；利用预测模型预测用户的购买意向，提前备货或调整促销策略。金融行业：利用大数据对客户的信用记录、交易行为、社交媒体互动等多维度数据进行综合分析，评估客户的信用风险与还款能力；基于分析结果制定个性化的贷款方案与风控策略。教育行业：通过收集学生的学习行为、成绩变化、兴趣偏好等数据，分析学生的学习习惯与难点；基于分析结果提供个性化的学习路径与资源推荐，帮助学生提高学习效率与成绩。 四、大数据用户研究的挑战与展望 尽管大数据为用户研究带来了诸多机遇，但其发展过程中也面临着数据隐私保护、数据安全、数据质量等多方面的挑战。为了充分发挥大数据在用户研究中的潜力，我们需要加强数据治理与合规性建设，提升数据处理与分析的精准度与效率；同时，积极探索新技术、新方法在大数据用户研究中的应用，如人工智能、区块链等，以推动用户研究领域的持续创新与发展。
大数据下的用户研究是企业实现精准决策与个性化服务的重要基石。通过充分利用大数据资源与技术手段，我们可以更加深入地理解用户需求与市场趋势，为企业的持续发展与竞争力提升提供有力支持。
《用户研究方法：卓越产品和服务的用户研究技巧》 《用户研究方法：卓越产品和服务的用户研究技巧》一书近期出版，本书是用户研究领域入门标准书籍，是一本带你进入用户研究世界，通过研究用户让您工作更出色的书籍。
内容及特色 本书共 10 章，分为三篇。
第一篇（第 1～5 章）主要介绍用户研究的定义，以及用户研究的基本流程、方法与工具。通过阅读这一篇，读者可以对用户研究建立基本认知，对数据收集方法、分析方法和用户研究工具有基本的了解。
第二篇（第 6～8 章）主要是用户研究在产品开发全流程的具体应用，从用户角度回答业务应该做什么和怎么做的问题。这一篇主要是用户研究的实际应用，可以理解为第一篇基本方法和技巧在产品开发过程中的具体运用。
第三篇（第 9～10 章）先谈用户研究的落地、沉淀，毕竟用户研究的最终目的是通过落地来影响业务。这一篇的最后是我个人对行业的一些思考，汇集了自己从业以来对工作中遇到的常见问题的解决方案。
本书在介绍用户研究基本方法的基础上，重点结合产品开发全流程，对用户研究的应用场景进行了详细阐述，不仅有方法、流程的介绍，也通过对产品开发全流程的用户研究，将方法、流程融入实际工作中，实操性强。另外，本书还融入了我在实际做项目的过程中的经验和思考，在一些需要避坑的地方做了提醒，希望读者能够尽量避坑，更好地将用户研究用到实际工作中。
读者对象 本书的目标读者主要有两类。
第一类目标读者是毕业后立志做用户研究的大学生，或者虽然有工作经历但是初次涉入用户研究领域的职场人。本书将带你进入用户研究的世界。从本书中，你将了解做用户研究的基本流程和实战技巧：
用户研究是做什么的？用户研究能给企业和自己带来哪些价值？
用户研究的基本思路和方法有哪些？每种方法的适用范围如何？
如何将用户研究成果应用到工作中？
第二类目标读者是更为广泛的职场人士，如产品经理、产品策划、运营经理、设计师、人力资源顾问等。为什么这些人也需要了解一些用户研究的方法呢？其实仔细想想，你所服务的对象象，就是你的“用户”。每个职场人都要面对自己的“用户”：产品经理负责的产品是服务用户的，视觉设计师的设计作品是给用户看的，交互设计师的设计方案是给用户使用的，运营经理的运营方案的对象也是用户。要想服务好自己的用户，可能都需要思考一些问题：
我的产品的目标用户是谁？—中国14亿人口中，我的产品应该首先服务好哪些用户呢？
我的用户有哪些需求？哪些需求是主要的，哪些是次要的？—抓不住主要需求，在各个方面平均施力，会使产品沦为“四不像”，用户更不会使用。
我设计的产品使用起来顺畅吗？使用过程中有没有问题？—用户已经越来越挑剔，体验差的产品会被直接弃用。
你可能会好奇，人力资源管理（也就是我们常说的 HR）和行政人员也需要做用户研究吗？其实这对他们来说也是一项加分技能，因为 HR 面对的是公司员工这样的内部用户。例如，腾讯的行政人员就很善于通过研究用户，发现并解决问题。他们发现了会议室预定过程中存在的一个问题：很多时候员工会提前几天在线上预定会议室，但是真正到了会议时间，却没去用，导致真正需要会议室的人定不到地方。据此他们设计了一个巧妙的解决方案：在会议室里贴了一个二维码，如果你发现会议室当前时段有人定了，但此时此刻会议室空着，那么你可以通过扫描二维码一键取消原来的预定，同时自己定下来立刻使用。这个方案很好地解决了问题，提升了会议室的运营效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06d05f86c8b04021a6d7340990379bf/" rel="bookmark">
			国产可图大模型:厚积薄发,GLM3加持质的飞跃,ComfyUI最全指南与SD3综合评比孰更强？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌹大家好！我是安琪！！！
Kolors大模型简 就在上周末，国内大厂快手开源了可图大模型文生图模型，这是由快手可图团队开发的基于潜在扩散的大规模文本到图像生成模型。
• Kolors 是在数10亿图文对下进行训练，
• 在 视觉质量、复杂语义理解、文字生成（中英文字符） 等方面，相比于当前业界开源/闭源模型，都展示出了巨大的优势。特别是在中文文字生成方面领先于当前所有业界模型。
• Kolors 支持中英双语，在中文特色内容理解方面更具竞争力。
研发团队构建了一个包含14种垂类，12个挑战项，总数量为一千多个 prompt 的文生图评估集 KolorsPrompts。在 KolorsPrompts 上，并且收集了 Kolors 与市面上常见的 SOTA 级别的开源/闭源系统的文生图结果，并进行了人工评测和机器评测。
人工评测 研发团队邀请了50个业界领域专家对生成图像打分，评估维度包括：画面质量、图文相关性、整体满意度三个方面。结果表明：Kolors 在整体满意度方面处于最优水平，其中画面质量显著领先其他模型。
机器评测 研发团队采用 MPS(Multi-dimensional Human preference Score) 来模型评估。结果表明：Kolors 实现了最高的MPS 指标，这以结果与人工评估的指标一致。
官方演示 高质量人像 中国元素 复杂语义理解 文字渲染能力 Kolors大模型ComfyUI安装 当前快手已经提供了在线的Kolors文生图服务可使用，不想本地部署的同学可以使用在线服务体验：https://klingai.kuaishou.com/。
（需要Kolors大模型ComfyUI安装包的同学文末可自行扫描获取）
模型安装 如果需要本地部署，则使用社区的ComfyUI-KwaiKolorsWrapper插件实现。
• 首先需要更新ComfyUI到最新版本，然后通过ComfyUI插件管理器安装ComfyUI-KwaiKolorsWrapper。插件地址为：https://github.com/kijai/ComfyUI-KwaiKolorsWrapper。
• 下载ChatGLM3量化模型，并放置在本地目录ComfyUI/models/LLM/checkpoints。模型地址为：https://hf-mirror.com/Kijai/ChatGLM3-safetensors/tree/main 。这里提供了3种量化权重文件，根据本地显存选择合适模型权重。对于小显存建议直接chatglm3-4bit.safetensors。
• 下载Kolors模型，本模型会在首次运行时自动下载（切记科学！！！），并放置在ComfyUI/models/diffusers/Kolors目录下。模型地址为：https://hf-mirror.com/Kwai-Kolors/Kolors/tree/main。
• 加载文末工作流文件，然后重启ComfyUI，即可开始体验。
本地模型结构为：
/ComfyUI/models/LLM/checkpoints │ chatglm3-4bit.safetensors // 4bit、8bit、fb16中选择一个版本 /ComfyUI/models/diffusers/Kolors │ model_index.json │ ├───scheduler │ scheduler_config.json │ ├───text_encoder │ config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c06d05f86c8b04021a6d7340990379bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5c85c53c1fd758ee43814d36e25970/" rel="bookmark">
			大模型笔记2 Longformer for Extractive Summarization任务的模型修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
LongformerForTokenClassification调通
将7分类的预训练模型改为2分类
利用分类标签取出token对应子词
将token转换为完整单词取出
LongformerForTokenClassification调通 对应文档:
https://huggingface.co/docs/transformers/en/model_doc/longformer#transformers.LongformerForTokenClassification
下载预训练模型:
https://huggingface.co/docs/transformers/en/model_doc/longformer#transformers.LongformerForTokenClassification
修改使用模型预测与训练时的输出获取
from transformers import AutoTokenizer, LongformerForTokenClassification
import torch
# tokenizer = AutoTokenizer.from_pretrained("brad1141/Longformer-finetuned-norm")
# model = LongformerForTokenClassification.from_pretrained("brad1141/Longformer-finetuned-norm")
tokenizer = AutoTokenizer.from_pretrained("tmp/Longformer-finetuned-norm")
model = LongformerForTokenClassification.from_pretrained("tmp/Longformer-finetuned-norm")
inputs = tokenizer(
"HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="pt"
)
#预测
with torch.no_grad():
outputs=model(**inputs)
# 如果输出是元组，可以手动解析
if isinstance(outputs, tuple):
logits, = outputs
else:
logits = outputs.logits
predicted_token_class_ids = logits.argmax(-1)
# Note that tokens are classified rather then input words which means that
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a5c85c53c1fd758ee43814d36e25970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f858baed8e066f28edaa6fbb200f274e/" rel="bookmark">
			Idea打包出war包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Idea打包出war包 1.Idea 中选择Project Structure 2.选择Artifaces ---&gt; Web Application: Archive 3.先输入war包名称和打包完成后要保存war包的路径， 然后选择Output Layout 点击+，选择Directory Content.选择 “项目名称_Web_exploded”， 然后Apply, OK. 4. 然后再Idea菜单栏选择Build --&gt; Build Artifacts ,选择刚才创建的， 然后Build，将生成wa包， 可以将它放入服务器Tomcat中，远程访问。 4. Done
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bc2b1200a2fbb872864619463b1109/" rel="bookmark">
			云原生存储：使用MinIO与Spring整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代云原生应用开发中，高效、可靠的存储解决方案是至关重要的。MinIO是一个高性能、分布式的对象存储系统，它与Amazon S3兼容，非常适合在Kubernetes等云原生环境中使用。本文将详细介绍如何在Spring Boot应用中整合MinIO，并提供一些实用的代码示例。
1. MinIO简介 MinIO是一个开源的对象存储服务器，它提供了与Amazon S3兼容的API。MinIO的设计目标是提供高性能和可扩展性，使其成为云原生应用的理想选择。MinIO可以部署在物理服务器、虚拟机、容器以及Kubernetes集群中。
2. 安装与配置MinIO 首先，我们需要安装并运行MinIO服务器。MinIO可以通过多种方式安装，这里我们使用Docker进行安装：
docker run -p 9000:9000 -p 9001:9001 \ -e "MINIO_ROOT_USER=admin" \ -e "MINIO_ROOT_PASSWORD=password" \ minio/minio server /data --console-address ":9001" 上述命令将在本地运行MinIO服务器，并将其API端口映射到9000，控制台端口映射到9001。你可以通过http://localhost:9001访问MinIO的Web控制台。
3. 创建Spring Boot项目 接下来，我们创建一个Spring Boot项目。你可以使用Spring Initializr来生成项目结构：
访问Spring Initializr。选择项目元数据，如Group、Artifact、Name等。添加依赖：Spring Web、Spring Boot DevTools。生成并下载项目。 4. 添加MinIO依赖 在pom.xml文件中添加MinIO的Java客户端依赖：
&lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;8.3.0&lt;/version&gt; &lt;/dependency&gt; 5. 配置MinIO客户端 在Spring Boot应用中配置MinIO客户端。创建一个配置类MinioConfig.java：
import io.minio.MinioClient; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MinioConfig { @Value("${minio.endpoint}") private String endpoint; @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7bc2b1200a2fbb872864619463b1109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a63d7a0cdc392c638cb63c3a0cb778/" rel="bookmark">
			Spring Boot实战：无缝对接OpenAI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot实战：无缝对接OpenAI
在当今的技术领域，人工智能（AI）已经成为一股不可忽视的力量。OpenAI作为其中的佼佼者，提供了强大的API供开发者使用，以实现各种AI功能。本文将详细介绍如何使用Spring Boot无缝对接OpenAI，让你的应用也能轻松拥有AI能力。
一、OpenAI简介
OpenAI是一家致力于推动人工智能发展的研究公司，其目标是确保人工智能的益处广泛而均匀地分布。为了实现这一目标，OpenAI开发了一系列强大的API，供开发者在自己的应用中集成AI功能。
OpenAI的API涵盖了自然语言处理、图像识别、机器翻译等多个领域，其中最为著名的可能是GPT系列模型，它们在文本生成、文本理解等方面表现出色。
二、Spring Boot与OpenAI的无缝对接
Spring Boot是一个流行的Java框架，用于快速开发企业级应用。其简洁的配置和丰富的生态使得Spring Boot成为许多开发者的首选。将Spring Boot与OpenAI对接，可以让你的Java应用轻松拥有AI能力。
三、对接步骤
注册OpenAI账号并获取API密钥
要使用OpenAI的API，首先需要注册一个OpenAI账号，并在Dashboard中获取你的API密钥。这个密钥将用于后续的API调用中，以验证你的身份。
在Spring Boot项目中添加依赖
要在Spring Boot项目中使用OpenAI的API，你需要添加相应的依赖。如果你使用的是Maven，可以在pom.xml文件中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;com.theokanning.openai&lt;/groupId&gt; &lt;artifactId&gt;gpt3-java&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; 注意替换“最新版本”为实际的最新版本号。
配置OpenAI API密钥
在Spring Boot的配置文件（如application.properties或application.yml）中，添加以下配置来设置你的OpenAI API密钥：
openai.api-key=你的API密钥 创建服务类调用OpenAI API
接下来，你可以创建一个服务类来封装对OpenAI API的调用。以下是一个简单的示例，展示了如何使用OpenAI的GPT模型生成文本：
import com.theokanning.openai.OpenAiService; import com.theokanning.openai.completion.CompletionRequest; import com.theokanning.openai.completion.CompletionResponse; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Service; @Service public class OpenAiServiceWrapper { @Value("${openai.api-key}") private String apiKey; private final OpenAiService openAiService; public OpenAiServiceWrapper() { this.openAiService = new OpenAiService(apiKey); } public String generateText(String prompt) { CompletionRequest completionRequest = CompletionRequest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a63d7a0cdc392c638cb63c3a0cb778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3d5500a18320936eecbb72251812ff/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(011)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
25、pandas.HDFStore.get函数
25-1、语法
25-2、参数
25-3、功能
25-4、返回值
25-5、说明
25-6、用法
25-6-1、数据准备
25-6-2、代码示例
25-6-3、结果输出
26、pandas.HDFStore.select函数
26-1、语法
26-2、参数
26-3、功能
26-4、返回值
26-5、说明
26-6、用法
26-6-1、数据准备
26-6-2、代码示例
26-6-3、结果输出 27、pandas.HDFStore.info函数
27-1、语法
27-2、参数
27-3、功能
27-4、返回值
27-5、说明
27-6、用法
27-6-1、数据准备
27-6-2、代码示例
27-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 25、pandas.HDFStore.get函数 25-1、语法 # 25、pandas.HDFStore.get函数 HDFStore.get(key) Retrieve pandas object stored in file. Parameters: key str Returns: object Same type as object stored in file. 25-2、参数 25-2-1、key(必须)：一个字符串，指定了要检索的数据在HDF5文件中的位置或名称，这个key通常对应于你在将数据保存到HDF5文件时所使用的名称或路径。
25-3、功能 用于从HDF5文件中检索(或获取)存储的数据。
25-4、返回值 一般来说，这个函数会返回与key相关联的pandas对象，如DataFrame、Series或其他可能的pandas容器。
具体来说，返回值可以是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be3d5500a18320936eecbb72251812ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f836388675766f8a20cf03925c8efde/" rel="bookmark">
			Android 15 适配之16K Page Size ：为什么它会是最坑的一个适配点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先什么是 Page Size ？一般意义上，页面(Page)指的就是 Linux 虚拟内存管理中使用的最小数据单位，页面大小(Page Size)就是虚拟地址空间中的页面大小， Linux 中进程的虚拟地址空间是由固定大小的页面组成。
Page Size 对于虚拟内存， CPU 的内存管理单元（MMU）会将虚拟地址转换为物理地址，所以虚拟内存最终也会映射到物理内存页面。
而为了实现虚拟内存到物理的映射，两个地址空间都会被划分为多个固定页面，而虚拟空间和物理空间中的页面需要大小相同，通常长度为 4K，为了区分虚拟页面和物理页面，后者一般会被称为页框（page frames ）。
就是每个应用都有自己独特的虚拟地址空间，并且它永远也不要关心其他应用在做什么，占据了哪些真实地址，实际物理地址映射，是由 Linux 内核去管理和分配，虚拟内存也是为什么系统支持多应用同时运行的基础。
剩下的就很简单了，因为 Android 用的是 Linux 内核，所以在这部分逻辑一直以来都是遵循 Linux 的实现，只是 Android 由于「历史因素」限制，一直只支持 4 KB 内存页面大小，而现在为了优化系统内存性能，提高内存密集型工作负载的性能，Android 15 开始将采用 16KB 页面大小的要求。
那前面说了那么多「无用的知识」，核心还是 Android 15 要启动 16K Page Size 了，对于我们来说有什么影响？
先说理论上的正面影响：
系统面临内存压力时缩短应用启动时间：平均缩短 3.16%，某些应用的改进甚至高达 30%降低应用启动时的耗电量：平均减少 4.56%相机启动速度更快：热启动速度平均加快 4.48%，冷启动速度平均加快 6.60%改善系统启动时间：平均改善1.5%（约0.8秒） 那么负面影响是什么？你带有 .so 的 android 项目，很可能需要重新编译带有全新的动态库(.so) 才能正常运行对应功能，不然大概率会 crash 。
至于你的项目里有没有动态库，相信你应该很清楚，如果不清楚，直接把 apk 拖到 Android Studio ，看看 lib 下是否有 so 文件即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f836388675766f8a20cf03925c8efde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4285522fb4d4cc3b72dae1e386380ae/" rel="bookmark">
			MongoDB 全文检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 全文检索 MongoDB 是一个流行的 NoSQL 数据库，以其灵活的数据模型和强大的查询语言而闻名。在 MongoDB 中，全文检索是一种功能，允许用户对存储在数据库中的文本数据进行复杂的搜索。全文检索对于构建搜索引擎、内容推荐系统和文本分析工具等应用非常有用。
什么是全文检索？ 全文检索是一种信息检索技术，它允许用户通过搜索关键字或短语来查找文档中的文本。与传统的基于关键字的搜索不同，全文检索考虑了文本的上下文，可以更准确地返回相关文档。MongoDB 的全文检索功能是基于文本索引的，它为存储在数据库中的文本字段创建索引，以便快速进行搜索。
MongoDB 中的全文检索 在 MongoDB 中，全文检索是通过 $text 操作符实现的。要使用全文检索，首先需要在存储文本的字段上创建文本索引。文本索引是一个特殊类型的索引，它为字段中的每个单词创建一个索引条目。创建文本索引后，可以使用 $text 操作符进行搜索，指定要搜索的关键字或短语。
创建文本索引 要在 MongoDB 中创建文本索引，可以使用 db.collection.createIndex() 方法，将索引类型指定为 text。例如，如果有一个名为 articles 的集合，其中有一个名为 content 的文本字段，可以使用以下命令创建文本索引：
db.articles.createIndex({ content: "text" }) 使用全文检索进行搜索 创建文本索引后，可以使用 $text 操作符进行搜索。例如，要搜索包含 "MongoDB" 和 "全文检索" 的文章，可以使用以下查询：
db.articles.find({ $text: { $search: '"MongoDB" "全文检索"' } }) 此查询将返回包含 "MongoDB" 和 "全文检索" 的文章。请注意，搜索字符串需要用双引号括起来。
全文检索的注意事项 全文检索只支持英文和其他一些拉丁语系语言。对于中文等非拉丁语系语言，需要进行额外的处理，例如分词。全文检索的性能取决于索引的大小和查询的复杂性。对于大型集合，创建和维护文本索引可能会占用大量资源。在进行全文检索时，可以使用一些高级功能，例如权重、短语搜索和模糊搜索。 结论 MongoDB 的全文检索功能为存储在数据库中的文本数据提供了强大的搜索能力。通过创建文本索引和使用 $text 操作符，可以快速准确地搜索包含特定关键字或短语的文档。全文检索是构建现代应用程序的重要工具，可以帮助用户快速找到他们需要的信息。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/178/">«</a>
	<span class="pagination__item pagination__item--current">179/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/180/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>