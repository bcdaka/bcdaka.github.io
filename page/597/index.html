<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec2af6d77055f64f1f580c0063a80a9/" rel="bookmark">
			mac系统占用100多G怎么清除 mac内存系统占用了好多怎么清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac电脑运行速度足以傲视其他电脑系统，不易卡顿死机是苹果电脑的优势，但是其偏小的存储空间令人十分头痛。如果你的mac磁盘容量是仅有12GB，在使用一段时间之后，系统内存很有可能就要占用100多G，很快电脑会出现空间不够用的情况，我们应当定期清理mac系统垃圾，确保有足够的存储空间。本文将帮助大家解决mac系统占用100多G怎么清除以及mac内存系统占用了好多怎么清理的问题。
一、mac系统占用100多G怎么清除
想要清理mac系统存储，我们首先需要了解哪些内容是属于系统存储空间。
1.点击主界面的左上角的苹果的图标，点击关于本机。
2.选择关于本机后，将标签切换至存储空间。从此页面可以看到占用存储空间的所有内容。
CleanMyMac X全新版下载如下:
https://wm.makeding.com/iclk/?zoneid=49983
3.从存储空间分布图中可以得出占用我们空间的有文档、应用程序、系统以及系统数据。macOS系统不可被删除，我们可以清理系统数据来释放我们的存储空间。
系统数据大致可分为系统缓存、软件缓存文件、用户缓存文件，这类系统垃圾文件大部分被隐藏在“资源库”文件夹。我们需要找到并识别相关的文件夹进行清理。
4.在电脑主页面选择“前往”并点击资源库选项。
5.在资源库中找到“Caches”文件夹，这是保存大部分系统软件缓存的文件夹。
6.在Caches选择不需要的文件夹进行删除。可以根据文件夹的名字判断是哪款软件产生的。例如我今天要清除的“com.apple.iTunesCloud”文件夹就是itunes产生的缓存文件。
二、mac内存系统占用了好多怎么清理
当我们的电脑安装了特别多的软件，内存系统会占用很多存储空间，虽然可以通过手动搜索并清理内存系统，但是效率低且耗时长。我还是喜欢用清理软件对系统内存进行清理，比如最近大家都在使用的CleanMyMac X ，一款专业的mac电脑清理软件，不仅可以对系统垃圾进行分类清理，还能实时监控电脑的使用情况。
1.打开CleanMyMac X软件，在主页面中选择清理模块。
2.选择“系统垃圾”功能并运行扫描。
3.扫描结束后，直接点击清理按钮，或你希望对扫描结果进行区分清理，可以点击“查看项目”。
4.在详情页里，可以看到每个软件运行所产生的垃圾，用户可以选择保留部分缓文件不做清理。
三、mac如何卸载软件
如果想要释放更多的存储空间，删除不需要的软件也是一个非常有效的办法。一般用户可以将软件直接拖入废纸篓就能完成软件清理。但是大家不知道还有与软件有关的文件夹仍然被保留在我们的mac中，且占用我们的存储空间。
通过CleanMyMac X的卸载器功能，可以将软件和与其有关的所有一键删除，不留任何痕迹。如下图，小编现在要卸载WPS Office软件，有关的文件有二进制文件、支持文件、偏好设置和图标都可以被删除。
四、总结
以上就是小编向大家介绍mac系统占用100多G怎么清除和mac内存系统占用了好多怎么清理的方法，如。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42be5990a32c7087652e2d862754e9e4/" rel="bookmark">
			链表 --- C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章来详细介绍一下数据结构中的链表。
目录
1.链表的概念及结构
2.链表的分类
3.单链表的实现
4.链表的面试题
5.双向链表的实现
6.顺序表和链表的区别
1.链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
注意:
从上图可看出，链式结构在逻辑上是连续的，但是在物理上不一定连续现实中的结点一般都是从堆上申请出来的从堆上申请的空间，是按照一定的策略来分配的，两次申请的空间可能连续，也可能不连续 2.链表的分类 实际中链表的结构非常多样，以下3种情况组合起来就有8种链表结构，2^3 = 8：
1.单项或者双向
2.带头或者不带头
3.循环或者非循环
虽然有这么多的链表的结构，但是我们实际中最常用的还是两种结构
1.无头单向非循环链表
2.带头双向循环链表
1.无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
2.带头双向循环链表∶结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。
3.单链表的实现 //无头+单行+非循环链表的增删改查实现 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SListNode; // 动态申请一个节点 SListNode* BuySListNode(SLTDataType x); // 单链表打印 void SListPrint(SListNode* plist); // 单链表尾插 void SListPushBack(SListNode** pplist, SLTDataType x); // 单链表的头插 void SListPushFront(SListNode** pplist, SLTDataType x); // 单链表的尾删 void SListPopBack(SListNode** pplist); // 单链表头删 void SListPopFront(SListNode** pplist); // 单链表查找 SListNode* SListFind(SListNode* plist, SLTDataType x); // 单链表在pos位置之后插入x // 分析思考为什么不在pos位置之前插入？因为单链表只能向后访问 void SlistInsertAfter(SListNode* pos, SLTDataType x); // 单链表删除pos位置之后的值 // 分析思考为什么不删除pos位置？因为单链表只能向后访问 void SlistEraseAfter(SListNode* pos); // 单链表的销毁 void SListDestroy(SListNode** pphead); //在pos之前插入 void SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x); //删除pos位置的值 void SListErase(SListNode** pphead, SListNode* pos); 接口实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42be5990a32c7087652e2d862754e9e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04e17afdb1fa11324eece53cc2535ff/" rel="bookmark">
			MySQL免安装版教程(超详细图文教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.下载MySQL压缩包 官方下载地址：https://dev.mysql.com/downloads/mysql/ 这里可以选择版本进行下载
这里不需要登录和注册，直接点击继续下载
二. 安装 1、接下来我们解压文件夹，这时我们解压的文件夹是没有ini文件和data目录，这时我们需要自己创建
2、解压好的文件夹我是放在D盘目录下，新建ini文件和data目录
3、 配置ini文件，配置信息如下
[Client] #设置3306端口 port = 3306 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\mysql-5.7.16-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\mysql-5.7.16-winx64\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB early-plugin-load="" skip-grant-tables [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 4、编辑 my.ini 文件，修改mysql安装目录及数据存放目录。
5、配置环境变量
新建系统变量 MYSQL_HOME 并将 ;%MYSQL_HOME%\bin 添加到 Path 变量值后面 6、以"管理员身份"运行命令提示符cmd
7、安装服务
cd 进入 mysql 目录
运行以下指令，这时会加载一段时间，不要动它（如果太久没反应直接按回车键即可）
mysqld --initialize-insecure --user=mysql 运行以下指令
mysqld --install 启动服务
net start mysql 8、设置 mysql 的 root 密码为 123456，运行以下指令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04e17afdb1fa11324eece53cc2535ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65ad78ca1e0f1881c481a5527a81bc0/" rel="bookmark">
			AIGC时代，我们如何使用“黑科技”，解决图像信息安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在当今社会，图像是信息传播和表达的重要方式之一。但是，随着技术的进步，人们可以轻松使用各种图像编辑软件来篡改、伪造图片，制造出看似真实但实际上虚假的场景。
这种现象无疑是给社会带来了一系列负面影响。首先，大量基于虚假图片产生的诈骗案件层出不穷。通过伪装成真实场景的虚假图片，不法分子能够欺骗受害者，获取他们的个人信息或财产，造成严重经济损失。其次，网络暴力事件也频繁出现。人们可以利用图像编辑软件在无需实际发生的情况下制造虚假事件，散布谣言，并对特定个体或群体进行恶意攻击。这导致了社会的紧张局势和消极情绪的扩散，对人们的心理健康和社会稳定造成了威胁。
最好的解决方法就是，以魔法打败魔法（用科技战胜科技），因此，我们有必要了解下合合信息在世界人工智能大会上为我们推出的图像篡改检测的“黑科技”。
文章目录 前言AI图像篡改检测技术AIGC生成图像引发问题生成式图像鉴别OCR对抗攻击技术推动图像内容安全行业发展标准建立，助力可信AI系统化落地 AI图像篡改检测技术 在我们的日常生活中，我们都会分享一些聊天记录的截屏，一些和亲朋好友之间的红包，转账，但是这些信息是否被篡改过呢？基于这个信息，合合信息专门开展了图像文档的主题研究。研究主题方向包括四个类别，复制移动（一个图片中的信息复制到另一个地方）；拼接（两个毫不相干的图片拼接到一起）；擦除（擦除图像文档里面的一些关键信息）；重打印（在擦除的基础上编辑一些新的文档）。
合合信息的这项技术是基于深度学习的图像篡改检测技术及相关系统，通过学习图像被篡改后统计特征的变化，智能捕捉图像在篡改过程中留下的细微痕迹，并以热力图的形式展示图像区域篡改地点，相关技术已在银行、保险等领域落地应用。
如下合合信息图像篡改检测技术应用效果展示：
“重打印”篡改图片检测：将一张图片输入到合合信息AI图像篡改检测模型中，模型便能够判别这张图像是否被篡改，并且定位图像的篡改区域，效果展示：
合合信息同时提出了一种基于HRNet的编码器－解码器结构的图像真实性鉴别模型，结合图像本身的信息，包括但不限于噪声、频谱等， 从而捕捉到细粒度的视觉差异，达到高精度鉴别效果。
AIGC生成图像引发问题 在前言部分也提到了虚假图像给社会带来的负面问题，在这里普及下什么是AIGC。AIGC（Artificial Intelligence Generated Content），是由人工智能生成的图像内容。近年来，随着深度学习和生成对抗网络（GANs）等技术的快速发展，AIGC在各个领域得到了广泛应用。
那么，它是如何生成图像的呢？
首先，AIGC生成图像的过程通常基于神经网络模型。它使用大规模数据集对模型进行训练，使其具备学习图像特征和样式的能力。然后，通过调整模型的参数和输入噪声，可以生成具有逼真外观的新图像。
除此之外，AIGC生成的图像可以具备多种风格和内容，例如人脸、自然风景、动物等。这些图像在视觉上与真实图像非常相似，往往难以分辨是否为真实拍摄的照片还是由AI生成的。
最重要的一点是，AIGC生成图像的应用领域广泛。在艺术创作方面，艺术家可以利用AIGC生成图像作为灵感源泉，打破传统创作限制；在设计和广告行业中，AIGC生成图像可以用于产品渲染、广告宣传等；在游戏开发领域，AIGC生成图像可以用于场景和角色的设计；在虚拟现实和增强现实技术中，AIGC生成图像可以为用户提供更丰富、逼真的虚拟体验。
所以，这些虚假图像的制作和滥用可能导致信息误导、侵犯我们的隐私等等众多风险。
生成式图像鉴别 上文提到，不法分子可能通过生成的图片去规避版权、身份验证，非法获取利益，给人民群众造成财产损失。
基于此，对于一些生成图和真实图片相似度极高的情况以及生成式图像场景繁多且无法穷举的问题，合合信息在算法中考虑了空域和频域的关联性，将多维度特征进行综合评估。这种综合评估能够更准确地区分生成式图片和真实图片之间的微小差异，从而提高判别的真实性和准确性。
模型结构如下图所示：
当我们输入图片后，模型通过多个空间注意力头来关注空间特征，并使用纹理增强模块放大浅层特征中的细微伪影，增强模型对真实人脸和伪造人脸的感知与判断准确度。
无论是在金融，传媒，还是其他行业，生成式图像检测技术都能降低一定的侵权问题，降低资金盗刷概率，它在反诈骗、版权保护等领域的起到了重大的作用。
OCR对抗攻击技术 什么是OCR呢？
OCR，英文全称为Optical Character Recognition，光学字符识别，它是一种将印刷体或手写体的文字转换为可编辑文本的技术。它通过使用图像处理和模式识别算法，将图像中的字符识别并转化为计算机可读的文本形式。
OCR技术在提取身份证件个人信息方面具有广泛的应用。通过将身份证件图像输入到OCR系统中，可以自动识别和提取身份证上的个人信息，包括姓名、性别、民族、出生日期、身份证号码等。
主要大概包括几个步骤：
图像预处理：对身份证图像进行预处理，包括图像增强、裁剪、去噪等操作，以提高图像质量和字符边缘的清晰度。
区域定位：通过图像处理算法，确定身份证上个人信息所在区域的位置。这些区域通常包括姓名、性别、民族、出生日期、身份证号码等。
字符分割：在确定了个人信息区域后，需要将每个字符从图像中分割出来，以便后续的字符识别。
字符识别：针对每个字符，使用OCR算法将其转换为可读文本。常见的OCR算法包括基于模板匹配的方法、基于深度学习的方法等。这些算法会将字符与事先训练好的模型进行比对，从而确定每个字符的识别结果。
后处理：对于识别出的字符，可能存在错误或不一致。为了提高识别准确性，可以进行后处理操作。比如使用校验算法验证身份证号码的有效性，或者结合字典、语言模型进行错误修正。
因此，基于个人、企业业务的文件资料保密需求，合合信息进行了创新技术探索，研发了OCR对抗攻击技术来进行文档图片“加密”。
下图是合合信息OCR对抗攻击技术应用效果展示，可对关键信息进行遮盖，在不影响肉眼观看的情况下阻止机器自动爬取：
OCR对抗攻击技术可在不影响肉眼观看与判断的情况下，对场景文本或者文档内文本进行扰动，对包含中文、英文、数字等关键信息的内容进行“攻击”，防止第三方通过OCR系统读取并保存图像中所有的文字内容，降低数据泄露的风险，以此达到保护信息的目的。
推动图像内容安全行业发展标准建立，助力可信AI系统化落地 中国信通院牵头启动了《文档图像篡改检测标准》制定工作，旨在建立图像内容安全行业的发展秩序，并为可信AI系统化落地提供支持，合合信息是该标准的重要参与者之一。
标准将聚焦细粒度视觉差异伪造图像鉴别、生成式图像判别、文档图像完整性保护等议题，凝聚行业共识，为行业提供有效的指引。
合合信息作为一家在智能文字识别和智能图像处理领域深耕的公司，在智能文档处理方面取得了认可，并通过中国信通院的评估获得了最高评定等级。
未来，合合信息将与学术和产业合作伙伴共同推动AI图像内容行业的安全可信发展。
文章到这里就先结束了，后续会继续分享相关的知识点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09565d90d3bfba533414152acc530edf/" rel="bookmark">
			【C语言】指针超详细讲解（超级详细！！！快来看快来看！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 初阶指针一、指针的概念二、指针和指针类型1. 为什么指针有多种类型？？2. 指针+-整数的意义是什么？？3. 指针+-指针有什么意义？？4. 得到了变量的地址有什么用呢？？（指针解引用） 三、野指针1. 野指针是什么？？2. 什么情况会造成野指针？？3. 如何能够防止野指针的出现？？ 四、指针和数组五、二级指针 进阶指针一、字符指针二、指针数组1. 指针数组的定义2. 指针数组的使用 三、数组指针1. 如何定义数组指针？？2. 数组的地址和数组首元素的地址的区别 四、函数指针1. 函数指针的定义2. &amp;(函数名) vs（函数名） 五、函数指针数组1. 函数指针数组的定义2. 函数指针数组的使用 六、指向函数指针数组的指针函数指针数组的指针的定义 七、回调函数1. 回调函数的定义2. 回调函数的使用 结尾 初阶指针 一、指针的概念 指针？？是？？ 指针是内存中一个最小单元的编号，也就是地址平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量 所以说:指针就是地址，人们口中的指针变量也是指针。
指针变量？？是？？ 我们可以通过&amp;(取地址操作符）取出变量的内存与实地址，把地址可以存放到一个变量中，这个变量就是指针变量。
int main() { int c = 520; //将520赋给c int* ch = &amp;c;	//将整形c的地址取出来放在ch中 printf("%p", ch); return 0; } 指针变量的大小？？是？？ 指针的大小在32位平台是4个字节，在64位平台是8个字节。
二、指针和指针类型 1. 为什么指针有多种类型？？ 变量有多种类型，那么指针也会也有多种类型吧？？ 是的，不同类型的变量的地址就应该放在对应的指针变量中。
int main() { int a = 0; int* pa = &amp;a; double b = 0; double* pb = &amp;pb; char c = 'w'; char* pc = &amp;c; return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09565d90d3bfba533414152acc530edf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688f3b5d05bb6ac9f73ae9a04b986cf0/" rel="bookmark">
			【大虾送书第三期】《Python高并发与高性能编程: 原理与实践》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
✨写在前面
✨主要内容
✨本书特色
✨关于作者
🦐博客主页：大虾好吃吗的博客
🦐专栏地址：免费送书活动专栏地址
写在前面 Python成为时下技术革新的弄潮儿，全民Python的发展趋势让人们不再满足于简单地运行Python程序，逐步探索其更为广泛的日常应用和高性能设计。以ChatGPT为代表的大模型产品对初级程序开发人员提出了挑战，要想在开发领域站稳脚跟、有发展，必须掌握更高级的技巧和能力。
对于Python开发人员来说，高并发、高性能开发无疑是未来必须走的进阶之路。
目前，市面上关于Java高并发、高性能的书很多，讲解Python基本语法和常规使用的书也很多，但很少有专门针对Python高并发、高性能从实现原理到实践应用系统性讲解的书。鉴于此，笔者决定结合自己的经验对Python语言中的高级编程部分（即高并发、高性能编程的核心实现原理与实践应用）进行剖析，以帮助希望成为Python 高级工程师的你们。
《Python高并发与高性能编程：原理与实践》是一本帮助Python初级码农向高手进阶的专业指导书，可帮助所有Python从业者摆脱因ChatGPT等产品带来的职业危机。
书中不仅对Python必备基础知识进行了解读，对所有的Python高级特性进行原理级剖析，还囊括了大量指导实践的内容，可以帮助读者真正实现高并发、高性能编程。
本书从Python高级基础知识开始，逐步介绍高并发概念在Python语言中的实现过程、高性能特性是如何在Python语言中实现的，最后结合本书作者真实的项目经验，应用Python高并发、高性能特性来解决真实项目开发过程中遇到的问题和优化项。
主要内容 本书主要介绍Python高并发、高性能编程的核心实现原理与代码实现，具体包括如下内容。
Python高并发、高性能编程的步骤和规范。
与Python高并发、高性能编程相关的核心实现原理。
与Python高并发、高性能编程相关的特性在当下主流的Python解释器或虚拟机CPython中的具体表现形式和内存分配策略。
本书特色 在深度解读核心原理的同时，通过实际工作场景的实现方式来加深读者对Python高并发、高性能编程核心原理的理解。
只聚焦于干货内容，对读者实践和学习无用的内容一律不要。
对于重点、难点给出对应的图例和实际案例，以帮助读者理解。
只给出最核心的代码，减轻读者的学习压力。
关于作者 周宇凡（Steafan）
阿里前P8级研发工程师，CSDN认证博客专家，慕课网签约精英讲师。开源项目Nacos、Disruptor、JOL核心贡献者。Python、Java、C全栈研发工程师。精通Python、Java开发，对高并发与高性能的处理有独到的见解，曾自主实现了可承载百万级并发操作的服务，设计并实现了基础并发的组件库。
7月19日19:30，视频号“IT阅读排行榜”观看直播
本次送书三本活动时间：截止到2023-07-24参与方式：关注博主、点赞、收藏并评论“进阶高级Python开发工程师”（单账号最多评论三次） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63cd1041cc43726dc597c7d23c1a58f8/" rel="bookmark">
			苹果电脑Mac怎么创建txt文件？如何设置新建txt的快捷键？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中，经常会需要编辑文字内容，相信很多朋友都和我一样，喜欢用txt来编辑，因为这样编辑的文字是不带任何格式的，在其它地方编辑起来也会方便许多。之前使用Windows电脑时，只要右键就能新建txt文档文件，刚换Mac时，还真找不到新建txt文档文件的入口，本篇文章就为大家介绍如何设置新建txt文档文件的快捷键。
第一种方法：
通常可以直接用Mac的搜索工具Spotlight或Alfred搜索TextEdit，打开文本编辑应用程序即可创建txt文档，若打开文本编辑时出现下方界面，可以通过修改格式来转为txt文件。
修改入口在顶部菜单栏的格式下拉框中，选择“制作纯文本”选项即可。
第二种方法：
首先打开Mac的“自动操作”应用程序，可以用搜索工具Spotlight或Alfred直接搜索Automator。
文稿类型选择“快速操作”后，点击“选取”按钮。
工作流程收到选项选择“没有输入”，位置选项选择“访达.app”。
然后在左侧列表中选择 “实用工具” &gt; “运行AppleScript”，将其拖到右侧空白处。
将里面的代码全部删掉，粘贴下方的代码后，点击黑色三角形运行，然后关闭“自动操作”应用程序，按指示保存文件即可。
on run {input, parameters}
tell application "Finder" set selection to make new file at (get insertion location) end tell return input end run
设置完成后，就可以在顶部菜单栏的访达下拉框中的服务选项下找到新建txt的入口了。
最后打开系统偏好设置，在键盘设置中设置好新建txt的快捷键，就完成所有的操作了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5ce060273eb41a95117fde13e5cac3/" rel="bookmark">
			ERROR: Invalid requirement: ‘==‘ 解决python报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ERROR: Invalid requirement: '=='
错误:无效的要求: '=='
今天安装 selenium包时突然触发这个报错，这个错误通常出现在使用pip安装Python包时，报错的原因是需要注意的是==前后没有空格，若是加空格就会出现上述报错。
例如：
安装指定版本的 selenium比较简单，直接：
pip install selenium==3.141. 在服务器上安装可以：
sudo pip install selenium==3.141. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8557968e6bf802ce8574167712dd1ac/" rel="bookmark">
			【文末送书】AIGC时代的数据分析与可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注博主 Mindtechnist 或加入【智能科技社区】一起学习和分享Linux、C、C++、Python、Matlab，机器人运动控制、多机器人协作，智能优化算法，滤波估计、多传感器信息融合，机器学习，人工智能等相关领域的知识和技术。搜索关注公粽号 《机器和智能》 发送关键词“刷题宝典”即可领取技术大礼包！
博主介绍：
CSDN优质创作者，CSDN实力新星，CSDN内容合伙人；
阿里云社区专家博主；
华为云社区云享专家；
51CTO社区入驻博主，掘金社区入驻博主，支付宝社区入驻博主，博客园博主。
AIGC时代的数据分析与可视化 拆特鸡皮提与Power BI介绍图书推荐与送书活动 专栏：《前沿技术文献与图书推荐》
拆特鸡皮提与Power BI介绍 随着人工智能和自然语言处理的快速发展，自然语言大模型（如拆特鸡皮提）在各个领域中得到了广泛的应用。在数据分析和商业报告制作方面，Power BI作为一款强大的数据分析和可视化工具，结合拆特鸡皮提的能力，可以帮助我们从繁琐的数据处理和报表编制中解脱出来，快速从海量数据中提取关键信息并制作令人惊艳的交互式商业报告。
本文将从拆特鸡皮提和Power BI的基础知识讲起，重点介绍它们在生活中的实际应用，并提供一些实战示例，帮助读者了解如何利用拆特鸡皮提和Power BI进行数据分析和报告制作。
拆特鸡皮提的基础知识
拆特鸡皮提是一种基于深度学习的自然语言处理模型，它可以生成与人类对话类似的自然语言文本。它的训练过程基于大规模的文本语料库，通过学习文本的统计规律和上下文信息来生成具有连贯性和逻辑性的回复。
拆特鸡皮提的应用领域广泛，包括智能客服、智能助手、自动文本回复等。它可以理解用户输入的问题或命令，并生成相应的回答或响应。拆特鸡皮提的强大之处在于它可以处理自然语言的多样性和灵活性，而无需预先编写规则或固定的模板。
Power BI数据分析与可视化实战
Power BI是一款由微软开发的商业智能工具，它提供了丰富的数据分析和可视化功能，帮助用户从各种数据源中提取关键信息，并通过交互式报表和仪表盘进行展示。
数据处理和准备
在进行数据分析和报告制作之前，数据处理和准备是一个关键的步骤。拆特鸡皮提可以帮助我们快速处理和理解大量的文本数据，从中提取关键信息。
import openai text_data = "这里是你的文本数据..." response = openai.Completion.create( engine="text-davinci-003", prompt=text_data, max_tokens=100, temperature=0.7, n=1, stop=None, temperature=0.7 ) processed_data = response.choices[0].text.strip() 在上面的代码示例中，我们使用OpenAI的Python库与拆特鸡皮提进行交互。我们将文本数据作为输入发送给拆特鸡皮提，并获得生成的回复。这个回复可以是关于数据摘要、统计信息或其他相关信息。
数据分析和报告制作
一旦我们对数据进行了处理和准备，就可以使用Power BI来进行数据分析和报告制作。
数据导入和连接
首先，我们需要将数据导入Power BI，并建立数据源连接。Power BI支持多种数据源，包括数据库、Excel、CSV文件等。通过简单的配置，我们可以将数据源与Power BI进行连接。
数据建模和可视化
在数据导入和连接完成后，我们可以开始进行数据建模和可视化。Power BI提供了直观且易于使用的界面，可以帮助我们设计数据模型和创建报表。
通过拖放字段和测量值，我们可以构建数据模型，并将数据可视化为各种图表、表格和仪表盘。这些可视化组件可以根据需要进行交互，以便更好地理解数据和展示结果。
拆特鸡皮提与Power BI的结合应用
结合拆特鸡皮提和Power BI的强大功能，我们可以实现一些有趣的应用场景。
例如，我们可以通过拆特鸡皮提在Power BI中添加一个交互式的自然语言查询功能。用户可以通过输入文本问题或命令，直接与拆特鸡皮提进行交互，并获取相关数据的查询结果。
import openai question = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8557968e6bf802ce8574167712dd1ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626efaaa208c3140ad6058e5c59b54f9/" rel="bookmark">
			Stable Diffusion如何生成高质量的图-prompt写法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Stable Diffusion使用尝试下效果prompt的编写技巧prompt 和 negative promptPrompt格式Prompt规则细节优化Guidance Scale 总结 Stable Diffusion Stable Diffusion是一个开源的图像生成AI系统,由Anthropic公司开发。它基于 Transformer模型架构,可以通过文字描述生成高质量的图像。
Stable Diffusion的主要特点包括:
强大的图像生成能力。它可以根据文本描述生成非常逼真的图像,包括人物、风景、动物等各种主题。对文本的理解能力强。它可以捕捉文本描述的关键信息,转换为视觉上的表现。生成图像分辨率高。它可以生成512x512甚至1024x1024像素的高分辨率图像。开源且易于使用。它建立在开源框架PyTorch等基础上,可以轻松地在GPU及普通电脑上运行。训练数据量大。它的训练数据集包含大量高质量图像,这是它强大能力的重要基础。结果多样化。每次输入相同提示,它都可以生成略有不同的结果,增加了结果的多样性。控制能力强。用户可以通过调整文字提示、超参数等方式控制生成结果。 Stable Diffusion是一种潜在扩散模型（Latent Diffusion Model），能够从文本描述中生成详细的图像。它还可以用于图像修复、图像绘制、文本到图像和图像到图像等任务。简单地说，我们只要给出想要的图片的文字描述在提Stable Diffusion就能生成符合你要求的逼真的图像。Stable Diffusion作为新兴的AI生成模型,拥有强大的图像生成能力,是目前最先进的开源生成模型之一,值得关注。它的出现将推动创作界发生革命性的变化。
使用 尝试下效果 prompt：beautiful girl,bikini,sea,beach,sunshine 生成的效果如下：
效果不太好，我们来学习下prompt如何编写，再看看改善效果。
prompt的编写技巧 prompt 和 negative prompt 描述语分为正向/负向描述，它们也叫tag(标签）或prompt(提示词）
正面提示词：相比Midjourney，SD需要写得更精准和细致，描述少就给AI更多自由发挥空间。
负面提示词：不想让SD生成的内容。
正向：masterpiece, best quality, 画质词，画面描述。
反向：根据画面产出加不想出现的画面。
Prompt格式 第一段：画质tag，画风tag
第二段：画面主体，主体强调，主体细节概括（主体可以是人、事、物、景）画面核心内容
第三段：画面场景细节，或人物细节，embedding tag。画面细节内容
第二段一般提供人数，人物主要特征，主要动作（一般置于人物之前），物体主要特征，主景或景色框架等
Prompt规则细节 提示词的顺序决定了权重的大小,越靠前的词汇权重越大,会对图像生成产生更直接的影响。生成图片分辨率越大,需要的提示词量也越多,否则不同的提示词会产生不一致的效果,相互干扰。使用括号可以精确调整单个词的权重值,提高或降低其对图像生成的影响程度。常用的权重调整范围建议控制在0.25到1.5之间,避免超出这个范围带来负面效果。
方法如下：
(word) - 将权重提高 1.1 倍
((word)) - 将权重提高 1.21 倍（= 1.1 * 1.1）
[word] - 将权重降低至原先的 90.91%
(word:1.5) - 将权重提高 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/626efaaa208c3140ad6058e5c59b54f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e55995eb82ec73c9745bcc0a224c520/" rel="bookmark">
			【数据结构之树】初阶数据结构之树的实现及其各种方式(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 😏专栏导读🤖文章导读🙀树的预备知识🙀二叉树😳树的代码实现及其各类讲解🌲树的结构体初始化 总结 😏专栏导读 👻作者简介：M malloc，致力于成为嵌入式大牛的男人
👻专栏简介：本文收录于 初阶数据结构，本专栏主要内容讲述了初阶的数据结构，如顺序表，链表，栈，队列等等，专为小白打造的文章专栏。
👻相关专栏推荐：LeetCode刷题集，C语言每日一题。
🤖文章导读 本篇文章我将详细的讲解关于树的知识点
🙀树的预备知识 前情介绍
对于大量的输入数据，链表的线性访问时间太慢，不宜使用。本片文章，我将讲述一种简单的数据结构，其大部分操作的时间复杂度为O(log n)。
树
树(tree)可以用几种方式定义。定义树的一种自然的方式是递归的方法。一棵树是一些节点的集合。这个集合可以是空集;若非空，则一棵树由称做根(root)的节点r以及0个或多个非空的(子)树 T1，T2，…，T 组成，这些子中每一的根都被来自根的一条有向的边(edge)所连接。
每一棵子树的根叫做根r的儿子(child)而r每一棵子的根的父亲(parent)。下图是显示用递归定义的典型的树。
从递归定义中我们发现，一棵树是 N 个节点和N - 1条边的集合，其中的一个节点叫做根。存在 N -1条边的结论是由下面的事实得出的，每条边都将某个节点连接到它的父亲，而除去根节点外每一个节点都有一个父亲,如下图所示。
根节点，父亲节点，叶子节点，兄弟节点的详解
在上图的树中，节点A是根结点，节点F有一个父亲A并且有儿子K、L、M。每一个节点可以有任意多个儿子，也可以没有儿子也就是0个，但是只能有一个父亲。没有儿子的节点成为叶子节点(leaf)；上图的叶子节点是B,C,H,I,P,Q,K,L,M和N。具有相同父亲的节点称为兄弟节点(sibing);因此K、L和M都是兄弟。
深度(depth)
首先，根的深度为0。在上图中E节点的深度为1，但是高为2，F的深度为1，高为1，该树的高为3，一个树的深度等于它的最深的树叶的深度；该深度总是等于这颗树的高。
🙀二叉树 二叉树(binary tree)是一棵树，其中每个节点都不能有多于两个的儿子。
二叉树的一个性质是平均二叉树的深度要比 N 小得多这个性质有时很重要。分析表明，这个平均深度为 O(/N).而对于特殊类型的二叉树，即二叉查找树(binary search tree)其深度的平均值是 O(log N)。不幸的是，正如下图中的例子所示，这个深度是可以大到 N -1的。
最坏情况的二叉树
😳树的代码实现及其各类讲解 🌲树的结构体初始化 树的结构
typedef int BTDataType; typedef struct BinaryTreeNode { BTDataType data; struct BinaryTreeNode* left; struct BinaryTreeNode* right; }BTNode; 二叉树，顾名思义就是一个左子树，一个右子树，所以在这里我们定义了一个结构体类型的左子树和右子树。那么是不是还要存放数据呢？对的没错！所以还需要一个数据域data
手动创建一个树和开辟新节点
BTNode* BuyNode(BTDataType x) { BTNode* node = (BTNode*)malloc(sizeof(BTNode)); if (node == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e55995eb82ec73c9745bcc0a224c520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6db814511ee1c06e2c243baed75148/" rel="bookmark">
			Java如何遍历Map对象集合（多种方式）6种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java如何遍历Map对象的4种方法 今天比昨天，更优秀
Map简介 Map是用于保存具有映射关系的数据，保存两组值，key和value，这两组值可以是任何应用类型的数据。Map典型的实现类是HashMap、Hashtable（HashMap子类还有LinkedHashMap）、SortedMap子接口及实现类TreeMap、WeakHashMap、IndentityHashMap等 Map遍历第一种 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); for (Map.Entry &lt;String, String&gt; entry : map.entrySet()) { System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); } 注意：如果Map值是空的则会报错,抛出NullPointerException异常。
Map遍历第二种 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //遍历map中的键 for (String key : map.keySet()) { System.out.println("Key = " + key); } //遍历map中的值 for (Integer value : map.values()) { System.out.println("Value = " + value); } Map遍历第三种（使用Iterator遍历） Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); Iterator&lt;Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a6db814511ee1c06e2c243baed75148/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5be6bff3e8cf8da3c4387be27c052e9/" rel="bookmark">
			Stable Diffusion web UI 运行报错 Error while deserializing header: MetadataIncompleteBuffer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Use --skip-version-check commandline argument to disable this check. ============================================================================== Downloading: "https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned-emaonly.safetensors" to D:\code\ai\sd.webui\webui\models\Stable-diffusion\v1-5-pruned-emaonly.safetensors 2%|█▌ | 86.5M/3.97G [01:44&lt;1:20:22, 866kB/s] Calculating sha256 for D:\code\ai\sd.webui\webui\models\Stable-diffusion\v1-5-pruned-emaonly.safetensors: preload_extensions_git_metadata for 7 extensions took 0.00s 9351bb829b90c2645b2c0f0860aea4b319b69c59544a4bf5120965c33034940c Loading weights [9351bb829b] from D:\code\ai\sd.webui\webui\models\Stable-diffusion\v1-5-pruned-emaonly.safetensors loading stable diffusion model: SafetensorError Traceback (most recent call last): File "threading.py", line 973, in _bootstrap File "threading.py", line 1016, in _bootstrap_inner File "threading.py", line 953, in run File "D:\code\ai\sd.webui\webui\webui.py", line 306, in load_model shared.sd_model # noqa: B018 File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5be6bff3e8cf8da3c4387be27c052e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16eecf6ade0531cdc4102b07985f7fcd/" rel="bookmark">
			Git：从远程仓库拉取最新代码分支合并到本地分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Git 中，你可以使用 git fetch 和 git pull 命令拉取远程仓库的更新。
git fetch git fetch 命令可以让你在合并代码之前查看更新，从而更好地管理你的代码和解决可能的合并冲突。
当然你可以选择在本地创建一个新分支来拉取远程的更新（也可以称之为"临时"分支），然后再将这个新分支合并到你的工作分支。
或者，你也可以选择直接在你的工作分支上拉取远程的更新。
git Pull git pull 命令会立即拉取远程仓库的更新并合并到你的本地分支。这在某些情况下可能会导致合并冲突，因此，如果你需要更多的控制或者想要在合并之前查看更新，那么使用 git fetch + git merge 的方式会更好。
下面分别用命令讲解：
1.git fetch + merge: 获取最新代码到本地，然后手动合并分支 额外建立本地分支
命令展示：
//查看当前远程的版本 git remote -v //获取最新代码到本地临时分支(本地当前分支为[branch]，获取的远端的分支为[origin/branch]) git fetch origin master:master1 [示例1：在本地建立master1分支，并下载远端的origin/master分支到master1分支中] git fetch origin dev:dev1 [示例2：在本地建立dev1分支，并下载远端的origin/dev分支到dev1分支中] //查看版本差异 git diff master1 [示例1：查看本地master1分支与当前分支的版本差异] git diff dev1 [示例2：查看本地dev1分支与当前分支的版本差异] //合并最新分支到本地分支 git merge master1 [示例1：合并本地分支master1到当前分支] git merge dev1 [示例2：合并本地分支dev1到当前分支] //删除本地临时分支 git branch -D master1 [示例1：删除本地分支master1] git branch -D dev1 [示例1：删除本地分支dev1] 注意：严谨操作，推荐这种方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16eecf6ade0531cdc4102b07985f7fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b36ec3497620611450e816f318495f2/" rel="bookmark">
			【云原生｜Docker系列第3篇】Docker镜像的入门实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到Docker入门系列的第三篇博客！在前两篇博客中，我们已经了解了什么是Docker以及如何安装和配置它。本篇博客将重点介绍Docker镜像的概念，以及它们之间的关系。我们还将学习如何拉取、创建、管理和分享Docker镜像，这是使用Docker的重要步骤之一。
Docker镜像是Docker的核心概念之一，它提供了一个可执行的软件包，其中包含了运行应用程序所需的一切：代码、运行时环境、系统工具、库以及依赖项等。
通过学习Docker镜像的概念，您将能够更好地理解Docker的工作原理，并利用Docker提供的强大功能来开发、测试和部署应用程序。接下来，让我们深入探索Docker镜像的世界吧！
目录 1. Docker镜像1.1 Docker镜像的特点1.2 Docker镜像的获取1.2.1 拉取镜像1.2.2 使用Dockerfile构建镜像 1.3 Docker镜像的管理1.3.1 查看镜像列表1.3.2 删除镜像1.3.3 导出和导入镜像 2. 使用Dockerfile定制镜像2.1 Dockerfile定制镜像2.2 Dockerfile指令2.2.1 COPY 复制文件2.2.2 FROM 指定基础镜像2.2.3 RUN 执行命令2.2.4 ADD 更高级的复制文件2.2.5 CMD 容器启动命令2.2.6 WORKDIR 设置工作目录2.2.7 EXPOSE 暴露端口2.2.8 ENV 设置环境变量。 3. Docker镜像的分享和推送3.1 分享Docker镜像3.2 推送Docker镜像 总结 1. Docker镜像 Docker镜像是Docker的核心构建块，它是一个轻量级、可执行的软件包，用于构建和运行容器化应用程序。一个Docker镜像包含了运行应用程序所需的一切，包括应用程序的代码、运行时环境、系统工具、库以及依赖项等。
1.1 Docker镜像的特点 轻量级：Docker镜像采用了分层存储的机制，不同层之间可以共享相同的文件，从而减少了存储空间的占用。可移植性：Docker镜像具有良好的可移植性，可以在不同的主机和环境中运行，无需关注底层操作系统的差异。版本控制：每个Docker镜像都有唯一的标识符，称为镜像ID，可以用于对镜像进行版本控制和管理。可复用性：可以通过基于已有的Docker镜像构建新的镜像，从而实现镜像的复用和扩展。 1.2 Docker镜像的获取 获取Docker镜像通常有两种方式：拉取公共镜像仓库中的镜像，或者通过构建自定义镜像来创建。
1.2.1 拉取镜像 Docker镜像可以从公共的镜像仓库中拉取，最著名的镜像仓库就是Docker Hub。您可以在Docker Hub上找到数以万计的官方和社区维护的Docker镜像。使用docker pull命令可以拉取镜像，命令格式如下：
docker pull &lt;镜像名称&gt;:&lt;标签&gt; 例如，要拉取官方的Ubuntu镜像：
docker pull ubuntu:latest 1.2.2 使用Dockerfile构建镜像 1.3 Docker镜像的管理 在使用Docker时，我们可能需要对镜像进行管理，包括查看镜像列表、删除镜像、导出和导入镜像等操作。
1.3.1 查看镜像列表 要查看本地主机上已有的镜像列表，可以使用docker images命令。该命令将显示镜像的仓库名称、标签、镜像ID、创建时间和大小等信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b36ec3497620611450e816f318495f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a0563ceaa7b7bc3716dce12da2de6d/" rel="bookmark">
			【Python】类型注解 ⑤ ( Union 联合类型注解 | Union 联合类型语法 | 普通 / 容器 变量设置 Union 联合类型注解 | 函数设置 Union 联合类型注解 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Union 联合类型1、数据容器的类型注解问题2、Union 联合类型语法3、代码示例 - 普通变量设置 Union 联合类型注解4、代码示例 - 容器变量设置 Union 联合类型注解5、代码示例 - 函数中设置 Union 联合类型注解 二、完整代码示例 - Union 联合类型 一、Union 联合类型 1、数据容器的类型注解问题 对 list 列表 或 dict 字典 类型 设置 类型注解 ,
如果 list 列表中的元素都是 int 类型 ,
dict 字典 中的 键值对 , 键 Key 类型是 str 字符串类型 , 值 Value 的类型是 int 数字类型 ,
那么 , 可以写成下面的形式 ;
var_list: list[int] = [1, 2, 3] var_dict: dict[str, int] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a0563ceaa7b7bc3716dce12da2de6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a44c70e0565299e152c0e2c89981890/" rel="bookmark">
			【古风女孩-InsCode Stable Diffusion 美图活动一期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 InsCode InsCode是一个集成了在线IDE、在线AI编程、在线算力租赁、在线项目部署以及在线SD 模型使用的综合代码开发平台。不论你是初级软件工程师，还是AI大模型爱好者，InsCode都能帮助你快速编写代码，运行项目。甚至在这里你还可以一键购买算力，训练大模型，开发自己的AI应用程序。
Stable Diffusion介绍 Stable Diffusion是目前最火的AI绘画工具之一，它是一个免费开源的项目。通过Stable Diffusion，可以很轻松的通过文字描述，生成对应的图片。
Stable Diffusion WebUI把Stable Diffusion模型进行了封装，提供更加简洁易操作的界面，自身还可以通过插件等方式获得更多能力。目前使用的最多的是Stable Diffusion WebUI，因为它界面友好，可以很方便的调整各项参数，生成高质量的图片。
接下来我们通过演示来完成古风美女的制作
一、 Stable Diffusion 模型在线使用地址： https://inscode.csdn.net/@inscode/Stable-Diffusion
二、模型相关版本和参数配置： 模型：ghostmix_v11
Lora：
VAE:
采样迭代步数（steps）: 20
采样方法（Sampler）：Euler a
其他详情：
1chinese girl, (ulzzang-6500:0.7), kpop idol, detached sleeves, pink hair, long hair,Chinese clothes ,best quality, (painting:1.5), (hair ornament:1.35), jewelry, earrings, torii, cherry blossoms, lantern light, detailed face, ribbon_trim, (looking at viewer:0.02), nontraditional miko, shiny skin, long sleeves, smile, thick lips, game cg, east asian architecture, (blurry background:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a44c70e0565299e152c0e2c89981890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d005926de8888543c7d1539e6d40821/" rel="bookmark">
			数据结构——B&#43;树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、B+树的概念 B+树是应数据所需而出现的一种B树的变形树。一棵m阶的B+树需要满足下列条件：
每个分支节点最多有m棵子树（孩子节点）；非叶根节点至少有两棵子树，其他每个分支节点至少有⌈m/2⌉棵子树；节点的字数个数与关键字个数相等；所有叶节点包含全部关键字及指向相应记录的指针，叶节点中将关键字按大小顺序排列，并且相邻叶节点按大小顺序相互链接起来；所有分支节点（可视为索引的索引）中仅包含他的各个子节点（即下一级的索引块）中关键字的最大值及指向其子节点的指针。 二、B+树和B树的差异 在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有n+1棵子树。在B+树中，每个节点（非根内部节点）的关键字个数n的范围为⌈m/2⌉~m(而根节点：1~m)；而在B树中，每个节点（非根内部节点）的关键字个数n的范围为⌈m/2⌉-1~m-1(根节点：1~m-1)。在B+树中，叶节点包含了全部关键字，非叶节点中出现的关键字也会出现在叶节点中；而在B树中，最外层的终端节点包含的关键字和其他节点包含的关键字是不重复的。在B+树中，叶节点包含信息，所有非叶节点仅起索引作用，非叶节点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。
三、B+树的查找 B+树中的所有数据均保存在叶子结点，且根结点和内部结点均只是充当控制查找记录的媒介，并不代表数据本身，所有的内部结点元素都同时存在于子结点中，是子节点元素中是最大（或最小）元素。
例如在上图中的B+树中查找55这个关键字，步骤如下：
在根节点中对比55和根节点中的元素[60, 85]，发现55&lt;60，因此应该在第一个结点中继续寻找；同理，比较55和第一个节点中的元素[10, 20, 50, 60]，发现50&lt;55&lt;60，因此55应该存在于第四个结点当中；继续对比55和第四个结点中的元素[55, 60]，找到55，查找成功。当然，也有查找失败的情况，即要查找的元素并不在B+树中。 四、B+树的插入 B+树的插入和B树十分相似，其插入规则如下：
插入的操作全部都在叶子结点上进行，且不能破坏关键字自小而大的顺序；当插入关键字后结点的关键字个数大于m，需要进行“分裂”。
B+树的插入有四种情况： 若被插入关键字所在的结点，其含有关键字数目小于m，则直接插入；若被插入关键字所在的结点，其含有关键字数目等于m，则需要将这个结点分为左右两部分，中间的结点放到父节点中。假设其双亲结点中包含的关键字个数小于 m，则插入操作完成。在第 2 种情况中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。若插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。 举例：
(1) 插入关键字12，此时第一个叶子节点部分[10, 15]关键字的个数&lt;m，可以直接插入：（紫色代表插入的元素）
(2) 插入95，需要插入到最后一个叶子节点部分[85, 91, 97]：
此时该节点的关键字个数大于m，需要进行分裂操作，并且父节点需要插入一个新的关键字：
(3) 插入40，需要插入到第二个叶子节点部分[21, 37, 44]：
此时该节点的关键字个数大于m，需要进行分裂操作，并且父节点需要插入一个新的关键字：
父节点插入新的关键字之后，关键字的个数大于m，也需要进行分裂：
（4）插入100，由于其值比最大值 97 还大，插入之后，从根结点到该结点经过的所有结点中的所有值都要由 97 改为 100。（橙色为修改之后的）
修改完最大值之后，在最后一个节点处插入100：
五、B+树的删除 B+树的删除也和B树十分类似，它有下面几种情况：
找到存储有该关键字所在的结点时，由于该结点中关键字个数&gt;=⌈m/2⌉，做删除操作不会破坏 B+树，则可以直接删除；当删除某结点中最大或者最小的关键字，就会涉及到更改其双亲结点一直到根结点中所有索引值的更改。当删除该关键字，导致当前结点中关键字个数小于 ⌈m/2⌉，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作。第 3 种情况中，如果其兄弟结点没有多余的关键字，则需要同其兄弟结点进行合并。当进行合并时，可能会产生因合并使其双亲结点破坏 B+树的结构，需要依照以上规律处理其双亲结点。 举例：
（1）删除12，包含12的叶子节点的关键字个数为3，当删除12时，关键字个数仍然大于等于⌈m/2⌉,可以直接删除：
（2）删除97，97为整个B+树中元素最大的值，当删除这个元素时，需要修改从97的父节点到根节点中所有涉及到97的值，将其修改为第二大的元素值（在这个例子中第二大的元素为91）：
（3）删除51，此时51所在的结点只有59一个元素，该节点的关键字个数小于⌈m/2⌉，而它的兄弟结点元素个数大于⌈m/2⌉，可以给该节点借一个：
此时第二个叶子节点中的最大关键字为37，因此需要修改其父节点的值：
（4）删除59，此时59所在结点的关键字个数小于⌈m/2⌉：
并且该结点的兄弟结点的个数都为⌈m/2⌉，无法给它借关键字，因此将该结点与兄弟结点进行合并，结点合并之后，需要注意修改祖先节点相关的值：
（5）删除63，此时63所在的结点关键字个数小于⌈m/2⌉，并且兄弟节点无法给该节点提供关键字，因此该节点和其兄弟结点进行合并：
此时从图中可以发现，合并后的结点的父节点应该删除72，这时父节点关键字的个数小于⌈m/2⌉：
并且此时91所在结点的兄弟节点无法给该节点提供关键字，因此该结点和兄弟结点合并，并且需要修改合并后的节点的父节点的关键字值，合并后的结点的关键字个数满足条件。
六、B+树使用场景 B+树是在B树的基础上改造的，它的数据都在叶子节点，同时叶子结点之间还加了指针形成链表，多用于数据库索引。在数据库中通常不只是查询(select)一条记录，如果是多条记录的话，B树要做中序遍历，可能要跨层访问，而B+树由于所有的数据都在叶子节点，不用跨层，同时由于有链表结构只要找到首尾，就能通过链表把数据都读出来。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e4575a1a5a49de86afa23f669189fa/" rel="bookmark">
			微信小程序----一个简单的电影小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最终界面：
电影小程序
首先一共有这些包
app.jion中代码：
{ "pages": [ "pages/index/index", "pages/logs/logs", "pages/geren/geren", "pages/xqy/xqy" ], "window": { "backgroundTextStyle": "light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "Weixin", "navigationBarTextStyle": "black" }, "tabBar": { "color": "#999999", "selectedColor": "#f00000", "backgroundColor": "#efefef", "borderStyle": "black", "position": "bottom", "list": [ { "pagePath": "pages/index/index", "text": "首页", "iconPath": "pages/images/shouye.png", "selectedIconPath": "pages/images/shouye_selected.png" }, { "pagePath": "pages/geren/geren", "text": "个人", "iconPath": "pages/images/wode.png", "selectedIconPath": "pages/images/wode_selected.png" } ] }, "style": "v2", "sitemapLocation": "sitemap.json" } 第二步：我们来写第一个界面index
index.json
{ "usingComponents": {}, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65e4575a1a5a49de86afa23f669189fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732e401668130fe31dcfc88ba906ad51/" rel="bookmark">
			二次元美少女【InsCode Stable Diffusion 美图活动一期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Stable Diffusion 模型在线使用地址
一、背景介绍
二、模板介绍：
三、操作步骤
1.在线运行地址
2.进入在线运行网址，并点击运行及使用
3.购买GPU并创建项目
4.打开工作台并选择算力资源
5.点击下图中所示框框
6.进入Stable Diffusion WebUI
四、参数设置
五、图片生成提示词、反向提示词和图片展示
六、小结
Stable Diffusion 模型在线使用地址 在线运行地址：https://inscode.csdn.net/@inscode/Stable-Diffusion
一、背景介绍 InsCode是一个集成了在线IDE、在线AI编程、在线算力租赁、在线项目部署以及在线SD 模型使用的综合代码开发平台。不论你是初级软件工程师，还是AI大模型爱好者，InsCode都能帮助你快速编写代码，运行项目。甚至在这里你还可以一键购买算力，训练大模型，开发自己的AI应用程序。
二、模板介绍： 此环境主要用于学习和使用Stable Diffusion，已经安装了相关软件和组件库，可直接启动Stable Diffusion WebUI进行创作
Stable Diffusion是目前最火的AI绘画工具之一，它是一个免费开源的项目。通过Stable Diffusion，可以很轻松的通过文字描述，生成对应的图片。
Stable Diffusion WebUI把Stable Diffusion模型进行了封装，提供更加简洁易操作的界面，自身还可以通过插件等方式获得更多能力。目前使用的最多的是Stable Diffusion WebUI，因为它界面友好，可以很方便的调整各项参数，生成高质量的图片。
三、操作步骤 1.在线运行地址 在线运行地址：https://inscode.csdn.net/@inscode/Stable-Diffusion
点击下面连接，直接进入：
InsCode - 让你的灵感立刻落地
2.进入在线运行网址，并点击运行及使用 ​
3.购买GPU并创建项目 ​
4.打开工作台并选择算力资源 这里我们可以看到“已启动”字样，代表着购买成功。
​
5.点击下图中所示框框 ​
为了测试多买了两个，现在已经过期了😭。
​
6.进入Stable Diffusion WebUI ​
红色框框：这里是输入关键词的地方；
黑色框框：生成按钮；
黄色框框：输出图像的区域
四、参数设置 Steps（采样迭代步数）: 20 Sampler（采样方法）: Euler a 采样迭代步数(Steps)Sampling steps：20 生成批次：1 批次数量：1 CFG scale: 7 Size: 512x512 Model（模型）: GuoFeng3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/732e401668130fe31dcfc88ba906ad51/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/596/">«</a>
	<span class="pagination__item pagination__item--current">597/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/598/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>