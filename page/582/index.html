<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619a158a271cf58374886e53e3280791/" rel="bookmark">
			Mac Pro在重装系统时提示“未能与恢复服务器取得联系”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查网络连接：
确保你的Mac Pro连接到稳定的网络。尝试更换其他网络，例如切换到不同的Wi-Fi或使用有线连接。 系统时间校正：
错误的系统时间有时会导致与恢复服务器的连接问题。在恢复模式下打开终端（在实用工具菜单中选择终端）。输入以下命令以校准时间：ntpdate -u time.apple.com然后退出终端并再次尝试重装系统。 使用外部驱动器重装：
使用另一台Mac创建一个启动盘。从App Store下载macOS的安装程序。使用“磁盘工具”将外部USB驱动器格式化为“Mac OS扩展（日志式）”。然后使用“创建安装媒体”工具或createinstallmedia命令将macOS安装到USB驱动器。将USB驱动器连接到Mac Pro并启动，按住Option键直到出现启动选择界面，并选择USB驱动器开始安装。 尝试使用其他恢复模式：
你的Mac Pro支持多种恢复模式，尝试使用“互联网恢复模式”（按住Option-Command-R或Shift-Option-Command-R在开机时）。 检查硬件问题：
这个问题可能是由于硬盘或其他硬件问题导致的。考虑使用“苹果硬件测试”（按住D键在开机时）来检查是否有硬件故障。 寻求专业帮助：
如果上述方法都不能解决问题，建议将Mac Pro带到Apple授权服务提供商或Apple Store进行检查和维修。 请按照上述步骤逐一尝试，希望你的问题能够得到解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c109a2a42b7db1c81c3b1f4b273f27c/" rel="bookmark">
			SpringBoot结合MyBatis 【超详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SpringBoot+老杜MyBatis
一、简单回顾一下MyBatis
二、快速入门
​三、简易插入删除更改
四、查询
①、按其中一个字段查询
②、按所有字段进行查询
​五、详解MyBatis核心配置(复习)
六、结合Web及SpringMVC
2、MyBatis小技巧
一、#{}与${}及模糊查询
二、别名机制与mapper标签
三、插入使用生成的主键值
3、MyBatis参数处理
一、单个简单类型参数
二、Map参数
①、插入信息
②、查询单个汽车信息
③、返回多个Map
④、返回Map,map&gt;
三、实体类参数
四、多参数（@Param）
五、resultMap结果映射
①、使用resultMap进行结果映射（常用）
②、开启驼峰命名规范自动映射
六、获取总记录条数
4、动态SQL(注:使用了驼峰命名规范)
一、if标签
二、where标签
三、trim标签
四、set标签
五、choose where otherwise
六、foreach标签
①批量删除
②批量添加
七、sql、include标签
5、高级映射及延迟加载
一、多对一
二、多对一延迟加载
三、一对多
四、一对多延迟加载
6、MyBatis缓存机制
一、一级缓存
二、二级缓存
7、MyBatis使用PageHelper
一、limit分页
二、PageHelper插件
舞台再大 你不上台 永远是个观众
平台再好 你不参与 永远是局外人
能力再大 你不行动 只能看别人成功
没有人会在乎你付出多少努力 撑得累不累 摔得痛不痛
他们只会看你最后站在什么位置 然后羡慕或鄙夷
1、SpringBoot+老杜MyBatis 一、简单回顾一下MyBatis 核心对象包括以下三个：
SqlSessionFactoryBulider
SqlSessionFactory
SqlSession
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c109a2a42b7db1c81c3b1f4b273f27c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de29c390f255b6fda51554b8b599a35e/" rel="bookmark">
			Mysql添加、删除、主键（外键）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
索引与键的增删改
主键
单独设置主键
删除主键
外键
外键的使用
建表时添加外键
单独添加外键
删除外键
唯一键
索引与键的增删改 主键 主键会自动添加唯一索引，所以主键列不需要添加索引
建表时设置主键
方法1、
create table student( id int primary key ); 方法2、
create table student( id int, primary key (id) ); 单独设置主键 alter table student add primary key(id) 删除主键 alter table student drop primary key; 外键 外键是指引用另外一个表中的一列或多列数据，被引用的列应该具有主键约束或者唯一性约束（简单来说外键是另一个表的主键或者唯一约束）。外键可以有重复的, 可以是空值，用来建立和加强两个表数据之间的连接
外键的使用 外键的使用需要满足下列的条件：
1、两张表必须都是InnoDB表，并且它们没有临时表。
2、建立外键关系的对应列必须具有相似的InnoDB内部数据类型。
3、建立外键关系的对应列必须建立了索引。
创建外键的两种方式：
方式一：在创建表的时候进行添加
方式二：表已经创建好了，继续修改表的结构来添加外键。
建表时添加外键 方法1、
create table teacher( student_id int not null, foreign key(student_id) references student(id) ); alter table teacher add constraint teacher_ref_student(foreignKeyName) foreign key(student_id) references student(id); 方法2、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de29c390f255b6fda51554b8b599a35e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a66f44952f73a8e770be52db8be9b5/" rel="bookmark">
			华为云云耀云服务器L实例评测｜2核2G跑mysql性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一次我们介绍了华为云云耀云服务器L实例的基本信息，从购买到特色都做了简要介绍。但是
很多人看到这个配置又产生了迟疑，主要是因为云耀现在提供的全系是2核，性能吃得消吗？今天我们就来做一个性能测试
环境准备 因为我们购买的是服务器已经有了宝塔镜像，在上期我们已经安装了mysql5.7
当然，因为这里是安装了服务端，而我们决定使用 mysqlslap 来进行测试，所以还需要安装一个客户端
基准测试 读写测试 我们先使用 mysqlslap 来进行一次基准测试
然后笔者在在自己的windows电脑上进行测试，笔者的笔电是一个 11代I7的处理器 + 16G的内存
存储为海力士PC711固态硬盘
那用这台电脑进行mysql基准测试又该如何，笔者也进行了测试
可以看到虽然笔者的计算机论配置核心数以及内存都比云耀云服务器L实例高， 但这个基准测试单次的结果其实并不是很好
接下来我们增加一些参数设定
mysqlslap -uroot -proot --auto-generate-sql --concurrency=100 --number-of-queries=2000 其中，--concurrency 指定并发客户端数量，--number-of-queries 指定总共运行多少次 SQL 语句，我们此处设定100个并发，一共执行2000次sql。我们再来看一下
可以看到2000次查询分散到100个客户端上后，云耀服务器的耗时仅0.49s，然而此时笔电的耗时更短，仅0.29s。我们接下来同样是100客户端，按总查询5000、10000、15000、20000、25000的级别分别测试
其整个对比曲线已经绘制出来如下：
可以看到两者的曲线几乎是一致的，甚至随着运行次数的增多，云耀服务器还能胜出一头。
连接测试 除了持续的性能读写，那么我们还是要负责任的对连接数及并发情况进行一些测试，其命令如下
mysqlslap -uroot -proot --concurrency=100 --number-of-queries=100 --query="SELECT 1" 我们准备以笔记本测一下 1000 连接的情况
然后作为对比，看一下笔记本这边的情况
尽管心里有预期，在高并发的情况下，linux服务器的表现应该会比windows笔电要强，但仍没想到居然产生了10倍的差别。
当我们把并发数提到2000的时候，结果如下：
可以看到云耀云服务器L实例这边比较规整，基本上耗时是1000并发时的两倍，而笔电这边明显耗时几乎达到了3倍。
当我们继续极限测试，将连接数设定到10000时，两边都到达上限了，云服务器这边是线程数上限了，而笔电这边则是连接数超限了。
不过我们都知道现实中，小公司几乎不可能出现高达10000的连接数，真要有这么高的连接，就该做各种分库分表了，所以并不用担心这种场景
总结 经过多轮测试，并以笔者的个人电脑作为对比。不难看出，尽管我们选用的云耀云服务器L实例是最低的2核2G配置，但其实际性能仍然堪比笔者的4核16G + 固态硬盘的笔电，且随着负载量的上升，甚至能产生一些优势。而在面对大量连接的时候，云耀的优势甚至能扩大到几十倍。所以，还真不能直接套用个人计算机的观念，来看待云服务器的配置，其真实性能其实比很多人想象的都更强，尤其是其并发能力，即便选取云耀服务器的最低配置，也有不俗的性能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2efa8739f6a1bea7e76e928681a4e86c/" rel="bookmark">
			【Java 基础篇】Java UDP通信详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UDP（User Datagram Protocol）是一种无连接的网络传输协议，它不像TCP那样需要建立连接和维护状态，因此更加轻量级。UDP适用于那些对数据传输的实时性要求较高，可以容忍一定数据丢失的场景。本文将详细介绍Java中如何使用UDP协议进行网络通信，包括UDP套接字、数据传输、服务器和客户端的创建等。
1. UDP基础知识 1.1. UDP工作原理 UDP是一种面向数据报的协议，它将数据分成小块，每个数据块称为数据报。每个UDP数据报都包含了目标地址和端口号，数据报之间相互独立，不建立连接。UDP的工作原理如下：
发送方将数据分割成数据报，加上目标地址和端口号，然后通过网络发送出去。接收方根据目标地址和端口号接收数据报，然后将数据还原成完整的消息。 1.2. UDP的特点 无连接性：UDP不需要建立连接，发送方直接发送数据，接收方直接接收数据，无需三次握手等连接建立步骤。不可靠性：UDP不保证数据的可靠性和顺序性，数据可能会丢失或乱序。轻量级：UDP的头部开销小，传输效率高。广播和多播：UDP支持广播和多播，可以向多个目标发送数据。 2. Java UDP编程基础 Java提供了用于UDP编程的相关类，主要位于java.net包中。下面是UDP编程的基本步骤：
2.1. 创建UDP套接字 在Java中，可以使用DatagramSocket类来创建UDP套接字，用于发送和接收数据报。
import java.net.*; // 创建UDP套接字 DatagramSocket socket = new DatagramSocket(); 2.2. 发送UDP数据 使用DatagramPacket类来创建要发送的数据报，并将其发送到指定的目标地址和端口。
// 创建要发送的数据 byte[] sendData = "Hello, UDP!".getBytes(); // 指定目标地址和端口 InetAddress serverAddress = InetAddress.getByName("localhost"); int serverPort = 8888; // 创建数据报 DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, serverPort); // 发送数据报 socket.send(sendPacket); 2.3. 接收UDP数据 使用DatagramPacket类来创建一个用于接收数据报的缓冲区，并接收来自指定端口的数据。
// 创建接收数据的缓冲区 byte[] receiveData = new byte[1024]; // 创建接收数据报 DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2efa8739f6a1bea7e76e928681a4e86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711d5698bbad8925ecd811a224950c26/" rel="bookmark">
			改进召回（Retrieval）和引入重排（Reranking）提升RAG架构下的LLM应用效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		改进召回（Retrieval）和引入重排（Reranking）提升RAG架构下的LLM应用效果 原创 ully AI工程化 2023-08-24 21:08
收录于合集
#LLM应用架构3个
#领域技术13个
动手点关注
干货不迷路
如前文LLM应用架构之检索增强（RAG）的缘起与架构介绍，RAG架构很好的解决了当前大模型Prompt learning过程中context window限制等问题，整体架构简明清晰，易于实现，得到了广泛的应用，但实际落地过程中有大量的实际问题需要改进优化。
llamaindex实现下的RAG架构
以RAG召回为例，最原始的做法是通过top-k的方式从向量数据库中检索背景数据然后直接提交给LLM去生成答案，但这样存在检索出来的chunks并不一定完全和上下文相关的问题，最后导致大模型生成的结果质量不佳。
这个问题很大程度上是因为召回相关性不够或者是召回数量太少导致的，从扩大召回这个角度思考，借鉴推荐系统做法，引入粗排或重排的步骤来改进效果。其基本思路就是，原有的top-k向量检索召回扩大召回数目，再引入粗排模型，这里的模型可以是策略，轻量级的小模型，或者是LLM，对召回结果结合上下文进行重排，通过这样的改进模式可以有效提升RAG的效果。
下面介绍llamaindex在这方面的一些具体思路和实现。
1）基于LLM的召回或重排
在逻辑概念上，这种方法使用 LLM 来决定哪些文档/文本块与给定查询相关。prompt由一组候选文档组成，这时LLM 的任务是选择相关的文档集，并用内部指标对其相关性进行评分。为了避免因为大文档chunk化带来的内容分裂，在建库阶段也可做了一定优化，利用summary index对大文档进行索引。
基于 LLM 的检索工作原理简图
在LLM开发中有一个原则就是尽可能的使用大模型的能力，LLM并不只是最后作答，在关键词增强，答案一致性判定等上面都可以使用，在这里就可以利用大模型来判定生成结果最合适的候选问答。如何做好prompt就是关键，这是llamaindex内置的prompt，可以看到，这里用到了大模型的few-shot能力：
​​​​​​​
A list of documents is shown below. Each document has a number next to it along with a summary of the document. A question is also provided.Respond with the numbers of the documents you should consult to answer the question, in order of relevance, as wellas the relevance score.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/711d5698bbad8925ecd811a224950c26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceeb8d10881e345977df0677858e29c7/" rel="bookmark">
			C语言--strcmp函数，strcat函数，strcpy函数详解及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.strcmp函数
1.1函数介绍
1.2函数使用
1.2.1代码
1.2.2运行结果
1.3模拟实现strcmp
1.3.1实现思路
1.3.2代码
1.3.3运行结果
2.strcat函数
2.1函数介绍
2.2函数使用 2.2.1代码
2.2.2运行结果
2.3模拟实现strcat
2.3.1实现思路
2.3.2代码
2.3.3运行结果
3.strcpy函数
3.1函数介绍
3.2函数使用
3.2.1代码 3.2.2运行结果
3.3函数模拟实现strcpy
3.3.1实现思路
3.3.2代码
3.3.3运行结果
1.strcmp函数 1.1函数介绍 strcmp函数是用来比较两个字符串大小的函数，需要引用头文件&lt;string.h&gt;。
int strcmp ( const char * str1, const char * str2 ); strcmp比较两个字符串的大小，一个字符一个字符比较，按ASCLL码比较
标准规定：
第一个字符串大于第二个字符串，则返回大于0的数字
第一个字符串等于第二个字符串，则返回0
第一个字符串小于第二个字符串，则返回小于0的数字
1.2函数使用 1.2.1代码 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char* p1 = "abcdefgh"; char* p2 = "abcdefgh"; char* p3 = "abcde"; char* p4 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceeb8d10881e345977df0677858e29c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf308b10996bc8e27c99c3b7b0c948f/" rel="bookmark">
			Hive中的常用concat函数——concat函数、concat_ws函数和group_concat函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、concat() 1.1、用法：concat(str1,str2,str3,…) 连接参数的函数，返回结果为连接参数的字符串。如果有一个参数为NULL，则返回的结果为NULL。
1.2、示例 concat('a', 'b', 'c') ---- 'abc' concat('a', null, 'c')----null 2、concat_ws() 2.1、用法：concat_ws('分隔符', str1, str2, …) concat()的一个特殊形式，表示concat with separator，两个参数之间加上特定的分隔符。返回的是用指定分隔符连接参数的字符串。如果分割符为null，则返回null，参数为null，则忽略该参数。
2.2、示例 concat_ws("/", "2018", "12", "19")----2018/12/19 concat_ws(":", "22", "47", null)----22:47 concat_ws(null, "22", "47")----null 3、group_concat() 3.1、用法：group_concat(str1, [order by str3], [separator '分隔符']) 把相同组的字符串以特定分隔符连接为一行。
3.2、示例 3.2.1、数据 idname1bob1anna1helen2tom2baby2tom 3.2.2、按id分组，把name连接为1行 select id, group_concat(name) 1bobannahelen2tombabytom 3.2.3、按id分组，把name连接为一行，并按name升序 select id,group_concat(name order by name asc) 1annabobhelen2babytomtom 3.2.4、按id分组，name去重并连接为一行，按name升序，用逗号分隔 select id,group_concat(name order by name asc) 1anna,bob,helen2baby,tom 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad9912445481987b9392714078b1717e/" rel="bookmark">
			数据库实验报告--SQL server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
SQL Server是一种关系型数据库管理系统（RDBMS），由Microsoft开发和维护。它是一款功能强大、稳定可靠的数据库软件，支持事务、数据存储、管理和查询等各种功能，是企业级应用的首选数据库。SQL Server可以在Windows操作系统上运行，并提供了大量的管理工具和API，可以支持多个用户或应用程序同时访问数据库。SQL Server还提供了多种安全功能，包括数据加密、访问控制和身份验证机制等，可以保护数据库的安全性和完整性。此外，SQL Server还支持多种语言和平台，可以方便地与其他应用程序进行集成和交互，可用于各种应用场景，包括Web应用、企业应用、商业智能和数据仓库等。
目录
1 数据库、表的创建与管理
1.1 创建数据库
1.2 创建表
1.3 插入数据
1.4 数据操作
2 数据完整性的设置
2.1 设置外键
2.2 创建unique约束
2.3 创建、删除check约束
2.4 创建、删除规则
3 数据检索
3.1 单表数据查询
3.2 多表查询与子查询
4 索引和视图
4.1 创建索引
4.2 创建视图 4.3 删除索引和视图
5 存储过程和触发器
5.1 创建存储过程
5.2 创建触发器
1 数据库、表的创建与管理 1.1 创建数据库 利用SQL Server Management Studio创建一个名为teaching数据库,初始大小为10MB,增长速度为10%,其他均采用默认设置。
1.2 创建表 在查询编辑器中输入创建表的代码，分别创建student、course、score、teacher、 class、teach_class这6张表
创建student表代码：
create table teaching.dbo.student( studentno nchar(11) not null, sname nvarchar(8) null, sex nchar(1) null, birthday datetime null, classno nchar(7) null, point smallint null, phone nchar(12) null, Email nvarchar(20) null, constraint pk_student primary key (studentno asc)) 创建course表代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad9912445481987b9392714078b1717e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a152fded6298045761b60d0692430539/" rel="bookmark">
			收藏！2023年CCF推荐的『人工智能』领域国际学术会议和期刊目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. A类1.1 CCF-A 会议1.2 CCF-A 期刊 2. B类2.1 CCF-B 会议2.2 CCF-B 期刊 3. C类3.1 CCF-C 会议3.2 CCF-C 期刊 4. 会不会很麻烦啊，一个一个的复制粘贴到这里？NO！全自动结束语 前言 中国计算机学会(CCF)于2023年3月8日发布最新的《中国计算机学会推荐国际学术会议和期刊目录》，目录中，刊物和会议分为A、B、C三类：
A类：即CCF-A，表示国际上极少数的顶级刊物和会议，鼓励我国学者去突破；
B类：即CCF-B，是指国际上著名和非常重要的会议、刊物，代表该领域的较高水平，鼓励国内同行投稿；
C类：即CCF-C，指国际上重要、为国际学术界所认可的会议和刊物。
1. A类 1.1 CCF-A 会议 会议简称会议全称出版社网址AAAIAAAI Conference on Artificial IntelligenceAAAIhttp://dblp.uni-trier.de/db/conf/aaai/NeurIPSConference on Neural Information Processing SystemsMIT Presshttp://dblp.uni-trier.de/db/conf/nips/ACLAnnual Meeting of the Association for Computational LinguisticsACLhttp://dblp.uni-trier.de/db/conf/acl/CVPRIEEE/CVF Computer Vision and Pattern Recognition ConferenceIEEEhttp://dblp.uni-trier.de/db/conf/cvpr/ICCVInternational Conference on Computer VisionIEEEhttp://dblp.uni-trier.de/db/conf/iccv/ICMLInternational Conference on Machine LearningACMhttp://dblp.uni-trier.de/db/conf/icml/IJCAIInternational Joint Conference on Artificial IntelligenceMorgan Kaufmannhttp://dblp.uni-trier.de/db/conf/ijcai/ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a152fded6298045761b60d0692430539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162bb4ff8de96b4de923a4d9691ff7b8/" rel="bookmark">
			【数据结构】二叉树的前序遍历（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：二叉树的前序遍历 题目详情：给你二叉树的根节点 root ，返回它节点值的 前序 遍历；
我们先来看几个示例：
输入：root = [ 1，null，2，3 ]
输出：[ 1，2，3 ]
示例2：
输入：root = [ 1，2 ]
输出：[ 1，2 ]
示例三：
输入：root = [ ]
输出：[ ]
提示：
树中结点数目在范围【0，100】内
-100 &lt;= Node.val &lt;= 100
开始分析： 通过以上的示例我们得知，这道题呢就是把一棵树用前序遍历的方式将结点的值赋给一个数组，然后返回这个数组的指针；
我们之前学过二叉树的前序遍历打印结点的值，现在是将结点的值储存起来，其实原理都一样；
这个是要实现的函数的基本信息；
int* preorderTraversal(struct TreeNode* root, int* returnSize) 思路实现： 我们首先要确定数组的大小，数组的个数等于树中结点的个数，所以我们要先计算树中结点的个数；
int TreeSize(struct TreeNode* root) { return root==NULL?0:TreeSize(root-&gt;left)+TreeSize(root-&gt;right)+1; } //算结点的个数 *returnSize=TreeSize(root); 这个计算树结点个数的函数之前有些过，大体思路就是树结点的总和等于 根结点本身加上左，右子树的结点个数；
然后数组的元素个数知道了就要开始申请动态空间来定义数组了；
//开辟动态空间 int* arr=(int*)malloc(sizeof(int)*(*returnSize)); 直接一个 malloc 拿下，元素类型与树结点的值类型一致；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/162bb4ff8de96b4de923a4d9691ff7b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95aecec327dea571aadaad302bd82cb/" rel="bookmark">
			MySQL什么情况下会死锁，发生了死锁怎么处理呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介，黑夜开发者，CSDN领军人物，全栈领域优质创作者✌，CSDN博客专家，阿里云社区专家博主，2023年6月CSDN上海赛道top4。
🏆数年电商行业从业经验，历任核心研发工程师，项目技术负责人。
🏆本文已收录于PHP专栏：MySQL的100个知识点。
🎉欢迎 👍点赞✍评论⭐收藏
文章目录 🚀一、前言-关于数据库的死锁🚀二、MySQL中哪些情况会发生死锁，请具体说明🔎2.1 事务同时更新多个表🔎2.2 事务嵌套🔎2.3 索引顺序不一致🔎2.4 不同事务同时更新相同的索引 🚀三、发生死锁的举例🚀四、线上发生了死锁应该如何具体操作🔎4.1 监控死锁🔎4.2 终止死锁事务🔎4.3 重试事务🔎4.4 分析死锁原因🔎4.5 防止死锁再次发生🔎4.6 监控和预警 🚀五、总结 🚀一、前言-关于数据库的死锁 数据库的死锁是指不同的事务在获取资源时相互等待，导致无法继续执行的一种情况。当发生死锁时，数据库系统会自动中断其中一个事务，以解除死锁。在数据库中，事务可以分为读事务和写事务。读事务只需要获取读锁，而写事务需要获取写锁。当多个事务同时操作同一组数据时，可能会引发死锁的出现。
🚀二、MySQL中哪些情况会发生死锁，请具体说明 MySQL中会发生死锁的情况主要有以下几种：
🔎2.1 事务同时更新多个表 当一个事务同时更新多个表并且使用了不同的顺序，可能会导致死锁的发生。例如，事务A首先更新表X，然后获取锁，并在未释放锁的情况下尝试更新表Y；而事务B首先更新表Y，然后获取锁，并在未释放锁的情况下尝试更新表X。这种情况下，两个事务会相互等待对方的锁释放，从而形成死锁。
🔎2.2 事务嵌套 当一个事务内部开启了另一个事务，并在内层事务中更新了某个表，而外层事务也需要更新该表的同一行记录时，就有可能发生死锁。因为外层事务需要等待内层事务释放锁，而内层事务需要等待外层事务释放锁。
🔎2.3 索引顺序不一致 当多个事务按照不同的顺序访问相同的数据行，并且使用了不同的索引时，可能会发生死锁。例如，事务A按照索引1的顺序访问数据行，事务B按照索引2的顺序访问同一组数据行，这样两个事务之间就会产生死锁。
🔎2.4 不同事务同时更新相同的索引 当多个事务同时更新相同的索引时，可能会导致死锁。这是因为事务在更新索引时会获取对应的锁，并在未释放锁的情况下尝试更新其他数据，从而形成死锁。
🚀三、发生死锁的举例 假设有两个用户同时操作一个银行账户表，他们分别要进行转账操作。
用户A执行如下事务：
BEGIN; SELECT balance FROM accounts WHERE id = 1; UPDATE accounts SET balance = balance - 500 WHERE id = 1; 用户B执行如下事务：
BEGIN; SELECT balance FROM accounts WHERE id = 2; UPDATE accounts SET balance = balance + 500 WHERE id = 2; 在并发执行时，可能会出现以下情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f95aecec327dea571aadaad302bd82cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87263f35fe13bf45275b4d93186c1c39/" rel="bookmark">
			从零开始—【Mac系统】MacOS配置Java环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统环境说明
Apple M1
macOS Ventura 版本13.5.2
1.下载JDK安装包 Oracle官网下载地址 JDK下载【注：推荐下载JDK8 Oracle官网JDK8下载】
关于JDK、JRE、JVM的关系说明
JDK(Java Development Kit，Java开发工具包) ，是整个JAVA的核心，包括JRE，很多Java工具（javac/java/jdb等）和Java基础类库
JRE(Java Runtime Environment Java运行环境) ，是 JDK 的子集
JVM（Java Virtual Machine，Java虚拟机）, 是JRE的一部分。Java实现跨平台的核心部分，负责解释执行字节码文件，是可运行Java字节码文件的虚拟计算机
JDK、JRE、JVM 之间是什么关系， Java 平台标准中已经明确定义
Java1.8.*版本官方文档地址：https://docs.oracle.com/javase/8/docs/index.html
Oracle has two products that implement Java Platform Standard Edition (Java SE) 8: Java SE Development Kit (JDK) 8 and Java SE Runtime Environment (JRE) 8.↳
JDK 8 is a superset of JRE 8, and contains everything that is in JRE 8, plus tools such as the compilers and debuggers necessary for developing applets and applications.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87263f35fe13bf45275b4d93186c1c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b53d2b7aba65305526b10b6554f6166f/" rel="bookmark">
			【IDEA】未配置 SQL 方言：无法使用SQL提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题内容 SQL提示未配置SQL方言
问题原因 如提示描述，没有配置SQL方言与数据源
解决方法 1、配置SQL方言 路径：配置为工程路径
2、配置数据源 注意：填写数据库信息
3、测试效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1b46edf7a5253f18a1ab4eebf36d41/" rel="bookmark">
			python - 无法使用 pip 安装 playsound
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip install playsound后发现一直报错，报错如下： Collecting playsound
Using cached playsound-1.3.0.tar.gz (7.7 kB)
Installing build dependencies ... done
Getting requirements to build wheel ... error
error: subprocess-exited-with-error
× Getting requirements to build wheel did not run successfully.
│ exit code: 1
╰─&gt; [23 lines of output]
Traceback (most recent call last):
File "D:\Desktop\lib\site-packages\pip\_vendor\pyproject_hooks\_in_process\_in_process.py", line 353, in &lt;module&gt;
main()
File "D:\Desktop\lib\site-packages\pip\_vendor\pyproject_hooks\_in_process\_in_process.py", line 335, in main
json_out['return_val'] = hook(**hook_input['kwargs'])
File "D:\Desktop\lib\site-packages\pip\_vendor\pyproject_hooks\_in_process\_in_process.py", line 118, in get_requires_for_build_wheel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb1b46edf7a5253f18a1ab4eebf36d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4014dfe843ce3e929a775eb4842d1a81/" rel="bookmark">
			如何使用「Mac 电脑端微信」发起视频号直播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截止2023年9月20日，Mac 版微信是没有视频号直播功能的，只有 Windows 微信才有。
那如何用 Mac 进行微信视频号直播呢？ 打开微信视频号助手官网，用微信扫码登录视频号助手后台，可以看到官方明确说明，见下图：
是的，只能先通过视频号认证。才能在 Mac 上开启直播，同时我们也在上图中看到了其它几种直播方式。
那如何进行视频号认证呢？ 打开手机端微信的视频号（发现-视频号-右上角头像一创作者中心-头像下的申请认证）进行认证。认证的条件如下图所示：
可以看到，视频号认证条件有一定门槛。 通过了视频号认证，就能在 Mac 上进行视频号直播了，直播的时候需要使用免费开源的直播推流软件 OBS。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c38b1583ad0dcf4d99ed3aa1536b93c/" rel="bookmark">
			【Java 基础篇】serialVersionUID 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Java 中，serialVersionUID 是一个用于标识序列化类版本的特殊字段。它是一个长整型数值，通常在实现 Serializable 接口的类中使用，用于确保序列化和反序列化的一致性。在本文中，我们将详细解释 serialVersionUID 的作用、用法以及相关的注意事项。
什么是 serialVersionUID？ serialVersionUID 是 Java 序列化机制中的一个字段，用于标识类的版本。当一个类实现了 Serializable 接口（表示该类可以被序列化），编译器会自动生成一个 serialVersionUID 字段，用于表示类的版本号。
private static final long serialVersionUID = 123456789L; serialVersionUID 是一个长整型数值，通常是一个正整数，可以手动指定，也可以由编译器自动生成。该字段的主要作用是用于在反序列化时检查类的版本是否与序列化时的版本一致，以确保反序列化的对象与序列化时的对象是兼容的。
为什么需要 serialVersionUID？ serialVersionUID 的存在是为了处理序列化和反序列化过程中的版本兼容性问题。当一个类被序列化后，它的字节表示可能会存储在磁盘上或通过网络传输到不同的 JVM（Java 虚拟机）。在这种情况下，如果类的结构发生了变化，例如添加了新的字段或方法，那么反序列化时就可能出现版本不一致的问题。
serialVersionUID 的主要作用如下：
版本控制：serialVersionUID 允许开发人员显式地管理类的版本。通过手动指定 serialVersionUID，开发人员可以确保在类的结构发生变化时，仍然能够反序列化旧版本的对象，而不会导致 InvalidClassException。
版本检查：在反序列化时，serialVersionUID 用于验证被序列化的对象是否与当前类的版本兼容。如果版本号不匹配，反序列化操作将失败，以避免数据不一致性。
serialVersionUID 的生成方式 serialVersionUID 可以通过以下方式生成：
手动指定：开发人员可以显式地在类中声明 private static final long serialVersionUID 字段，并手动赋予一个长整型数值。 private static final long serialVersionUID = 123456789L; 自动生成：如果未手动指定 serialVersionUID，Java 编译器将根据类的结构自动生成一个 serialVersionUID。生成算法通常基于类的字段、方法、父类等信息，以确保类结构发生变化时，serialVersionUID 会发生变化。 // 自动生成的 serialVersionUID 示例 private static final long serialVersionUID = -1234567890123456789L; 自动生成的 serialVersionUID 是根据类的结构计算得到的哈希值，通常为负数。由于这个值是基于类的结构生成的，因此不同版本的类将具有不同的 serialVersionUID。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c38b1583ad0dcf4d99ed3aa1536b93c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c35e262b32df1d6ee9f0d21986fa4d/" rel="bookmark">
			数学建模6——路径规划的各种算法(Dijkstra、Floyd、A*、D*、RRT*、LPA*)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文只是简单的介绍一下各路径规划算法的概念和流程，可用于对算法的初步了解，如果要进一步学习，可以在个人理解中找到我推荐的其他博主更为完善的文章。
目录
一、Dijkstra
基本概念
基本流程
个人理解
MATLAB代码
二、Floyd
基本概念
基本流程
个人理解
MATLAB代码
三、A*算法
基本概念
基本流程
个人理解
MATLAB代码
四、D*算法
基本概念
基本流程
个人理解
MATLAB代码
五、RRT*算法
基本概念
基本流程
个人理解
六、LPA*算法
基本概念
基本流程
个人理解
七、D*lite算法
基本概念
基本流程
个人理解
八、各路径规划算法之间的区别（重要）
最后总结
一、Dijkstra 基本概念 Dijkstra算法是一种用于求解图中单源最短路径问题的经典算法。它可以用来找到从一个顶点到其他所有顶点的最短路径。
以下是Dijkstra算法的基本概念：
数据结构：Dijkstra算法使用两个主要的数据结构来实现最短路径的计算（就是两个数据集）： 顶点集合：包含图中所有的顶点。距离集合：记录从起点到每个顶点的最短路径距离。初始化：首先，将起点的距离设置为0，其他顶点的距离设置为无穷大。将起点设置为当前顶点。迭代更新：重复以下步骤，直到所有顶点都被标记为已访问。 选择当前顶点的邻居中距离最短的顶点，设为下一个当前顶点。更新其他邻居的距离，如果通过当前顶点到达邻居的距离比当前记录的距离要短，则更新距离。标记顶点：在每次迭代更新后，将当前顶点标记为已访问，表示已经找到了从起点到该顶点的最短路径。最短路径提取：在所有顶点都被标记为已访问后，就可以提取出从起点到其他所有顶点的最短路径。 Dijkstra算法的基本思想是通过不断更新距离集合中的距离，逐步找到最短路径。它保证每次迭代都会选择当前距离最短的顶点作为下一个当前顶点，并通过该顶点更新其他顶点的距离。最终，得到起点到其他所有顶点的最短路径和对应的距离。
基本流程 Dijkstra算法的基本流程如下：
创建一个距离集合和一个顶点集合。距离集合用于记录从起点到每个顶点的最短路径距离，初始时所有距离设置为无穷大（表示无法到达）。顶点集合用于存储图中的所有顶点。将起点的距离设置为0，并将其标记为当前顶点。迭代更新距离集合，直到所有顶点都被标记为已访问。 a. 遍历当前顶点的所有邻居顶点。 b. 对于每个邻居顶点，计算通过当前顶点到达该邻居顶点的距离，即当前顶点的距离加上从当前顶点到邻居顶点的边的权重。 c. 如果计算得到的距离小于距离集合中记录的距离，则更新距离集合中该邻居顶点的距离。 d. 重复步骤a到c，直到遍历完当前顶点的所有邻居顶点。将当前顶点标记为已访问，表示已经找到了从起点到该顶点的最短路径。选择下一个当前顶点：从未访问的顶点中选择距离最短的顶点作为下一个当前顶点。重复步骤3到5，直到所有顶点都被标记为已访问。最短路径提取：根据距离集合中记录的最短路径距离，可以回溯找到从起点到其他所有顶点的最短路径。 通过以上流程，Dijkstra算法能够逐步更新距离集合中的距离，最终得到从起点到其他所有顶点的最短路径和对应的距离。
个人理解 说白了就是问你：上面的图你怎么走可以把所有的点都走一遍，然后还需要路径长度最短。
这方法给出的答案是：我一个个点去摸索，比如我先从0到2最近，然后再从2开始摸索，发现接下来走1最好，因为0-2-1是5米，但0-2-3是8，0-2-5是10，然后我们确定0-2-1之后，再从1开始摸索，就这样慢慢找，最后找到最短路径。
具体学习可以参考这篇文章：图算法——求最短路径（Dijkstra算法）​​​​​​​
MATLAB代码 %在这个代码中，首先定义了一个带权有向图的邻接矩阵，然后定义了起点和终点。接着，初始化到各个节点的距离、前驱节点和已访问状态。然后，运行Dijkstra算法，找到最短路径和最短距离。最后，使用MATLAB的fprintf函数输出结果。 % 定义带权有向图 n = 5; % 节点数 adj_matrix = [0 10 0 5 0; 0 0 1 2 0; 0 0 0 0 4; 0 3 9 0 2; 7 0 6 0 0]; % 邻接矩阵 % 初始化 start_node = 1; % 起点 end_node = 5; % 终点 dist = inf(1, n); % 到各个节点的距离 prev = zeros(1, n); % 前驱节点 visited = zeros(1, n); % 是否已访问 dist(start_node) = 0; % 运行Dijkstra算法 for i = 1:n % 找到最近的未访问节点 min_dist = inf; for j = 1:n if visited(j) == 0 &amp;&amp; dist(j) &lt; min_dist min_dist = dist(j); curr_node = j; end end % 更新距离和前驱节点 visited(curr_node) = 1; for j = 1:n if adj_matrix(curr_node, j) &gt; 0 &amp;&amp; visited(j) == 0 new_dist = dist(curr_node) + adj_matrix(curr_node, j); if new_dist &lt; dist(j) dist(j) = new_dist; prev(j) = curr_node; end end end end % 输出结果 path = [end_node]; while path(1) ~= start_node path = [prev(path(1)), path]; end fprintf('最短路径：'); fprintf('%d ', path); fprintf('\n最短距离：%d\n', dist(end_node)); 二、Floyd Floyd算法又称为Floyd-Warshall算法，是一种动态规划算法，用于解决任意两点之间的最短路径问题。该算法在图中存在负权边和环的情况下仍然保证正确性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c35e262b32df1d6ee9f0d21986fa4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92aca4baf3dadc751923586aa64bb85/" rel="bookmark">
			深入了解神经网络：构建人工智能的基石
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言：
第一部分：神经元 - 生物的灵感
第二部分：人工神经元 - 数学的力量
第三部分：神经网络 - 层层堆叠
第四部分：训练神经网络 - 损失函数和反向传播算法
结论：
引言： 神经网络是一种受到生物神经系统启发的人工智能模型，它重现了大脑中神经元之间相互连接的方式。神经网络在诸多领域中取得了显著成就，如图像识别、自然语言处理和语音识别等。这篇博客将为您解释神经网络的构造，让您能够理解这个令人着迷的领域的基本工作原理。
第一部分：神经元 - 生物的灵感 在理解神经网络之前，我们首先需要了解神经元，这是神经网络的基本构建块。神经元是生物神经系统的工作单位，也是人工神经网络的灵感来源。
1.神经元的结构：每个神经元都由细胞体、树突和轴突组成。细胞体包含核心部分，树突接收来自其他神经元的信号，而轴突将信号传递给其他神经元。
2.信号传递：神经元之间的通信是通过电化学信号完成的。当信号通过树突传递到细胞体时，如果达到一定阈值，神经元就会触发并将信号传递给下一个神经元。
第二部分：人工神经元 - 数学的力量 现在，让我们将生物神经元的概念转化为数学模型，即人工神经元。人工神经元是神经网络的基本构建块，负责对输入进行处理和传递信号。输入可以类比为神经元的树突，而输出可以类比为神经元的轴突，计算则可以类比为细胞核。
输入和权重：人工神经元接收多个输入，每个输入都有一个相关联的权重，这相当于人工神经网络的记忆。这些权重决定了每个输入对神经元的影响程度。
激活函数：在人工神经元中，激活函数决定了神经元是否激活（发送信号）。常见的激活函数包括Sigmoid、ReLU和Tanh。
RELU激活函数 神经网络:是由大量的节点（或称“神经元”）和之间相互的联接构成。而由两层神经元组成的神经网络称之为--“感知器”（Perceptron）,感知器只能线性划分数据。在输入和权值的线性加权和叠加了一个函数g（激活函数），加权计算公式为：
g(W * x) = z
第三部分：神经网络 - 层层堆叠 现在我们可以将多个人工神经元组合在一起，形成神经网络。神经网络由多个层组成，包括输入层、隐藏层和输出层，也称为多层感知器。
在神经网络中需要默认增加偏置神经元（节点），这些节点是默认存在的。它本质上是一个只含有存储功能，且存储值永远为1的单元。在神经网络的每个层次中，除了输出层以外，都会含有这样一个偏置单元。（如下图）
输入层 隐含层 （每条线对应一个权重） 输出层 输入层：接收原始数据的输入，例如图像像素或文本单词。
隐藏层：这是神经网络的核心部分，包含多个层次的神经元。隐藏层负责从输入中学习特征并生成有用的表示。
输出层：根据学到的特征生成最终的输出，可以是分类标签、数值或其他任务相关的结果。
如何设计：
输入层的节点数：与特征的维度匹配
输出层的节点数：与目标的维度匹配。
中间层的节点数：目前业界没有完善的理论来指导这个决策。一般是根据经验来设置。较好的方法就是预先设定几个可选值，通过切换这几个值来看整个模型的预测效果，选择效果最好的值作为最终选择。
注意事项：
1、设计一个神经网络时，输入层与输出层的节点数往往是固定的，中间层则可以自由指定；
2、神经网络结构图中的拓扑与箭头代表着预测过程时数据的流向，跟训练时的数据流有一定的区别；
3、结构图里的关键不是圆圈（代表“神经元”），而是连接线（代表“神经元”之间的连接）。每个连接线对应一个不同的权重（其值称为权值），这是需要训练得到的。 第四部分：训练神经网络 - 损失函数和反向传播算法 神经网络的关键部分之一是训练过程。在训练中，神经网络通过与真实数据进行比较来调整权重，以使其能够做出准确的预测。
反向传播算法：是训练神经网络的核心算法。它通过计算误差并反向传播，以更新每个神经元的权重和偏差，从而减小预测误差。具体过程如何实现，可以看我的这篇博客：（了解BP神经网络：从原理到应用-CSDN博客）
损失函数：损失函数用于度量预测和实际值之间的差异。训练的目标是最小化损失函数。具体过程如何实现，可以看我的这篇博客：（交叉熵损失函数）
结论： 神经网络是人工智能领域的关键技术，它们的构造基于神经元的灵感，并结合了数学、统计和机器学习的原理。通过构建和训练神经网络，我们能够解决各种各样的问题，从图像识别到自然语言处理。希望这篇博客能够帮助您更好地理解神经网络的构造和工作原理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9535f2c4018447964e8f6b308b3aa59f/" rel="bookmark">
			mysql登录报错：mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 登录报错：
mysql: [Warning] Using a password on the command line interface can be insecure. ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES) 该错误表明 root 用户登录 MySQL 失败，原因是密码错误。
以下是一些可能的解决方案：
检查 root 用户的密码是否正确。确保 root 用户有权访问 MySQL 服务器。如果您使用的是 MySQL 8.0 或更高版本，请确保您已启用密码验证。如果您使用的是 MySQL 8.0 或更高版本，请确保您已正确设置 validate_password 变量。 以下是检查 root 用户密码的步骤：
使用 SELECT CURRENT_PASSWORD() 命令查看 root 用户的当前密码。将当前密码与您尝试登录的密码进行比较。如果密码不匹配，请使用 SET PASSWORD FOR 'root'@'localhost' = 'new_password' 命令重置 root 用户的密码。 以下是检查 root 用户是否有权访问 MySQL 服务器的步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9535f2c4018447964e8f6b308b3aa59f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/581/">«</a>
	<span class="pagination__item pagination__item--current">582/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/583/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>