<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a2d6f163391af6ec8ff50b8df50446/" rel="bookmark">
			android USB接口读写速度测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 1.adb连接android设备
2.usb插入u盘设备（建议使用高性能u盘，否则测试瓶颈可能是u盘，影响测试结果）
3.查看u盘挂载信息
adb shell进入shell状态
df -h查看所有磁盘情况
可以看到最后一行58G的磁盘，即为u盘。主要信息：
FileSystem：/dev/block/vold/public:8,1 Mounted on：/mnt/media_rw/AFA6-1804
开始测试（adb shell状态） 1.测试读取速度 完整指令：dd if=/dev/block/vold/public:8,1 of=/dev/null bs=1024k count=1000
高亮部分以实际为准，使用FileSystem
2.测试写入速度 完整指令：dd if=/dev/zero of=/mnt/media_rw/AFA6-1804/testdata bs=1024k count=1000
高亮部分以实际为准，使用Mounted on 后面需要加一个文件名用于写入，示例中为testdata
USB参数参考 传输速率换算 Mbps（兆比特每秒）和MB/s（兆字节每秒）之间的换算关系是8:1，即1Mbps等于1/8MB/s。12
例如，100Mbps的传输速率等于12.5MB/s。这种换算基于数据传输速率的基本单位，其中1Byte（字节）等于8bits（比特）。
参考：手机磁盘IO读写速度测试（OTG)_/dev/block/vold/public:8-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e495878ff7b6ed8c0ab9b66bcd16528/" rel="bookmark">
			error when starting dev server: Error: listen EACCES: permission denied 0.0.0.0:80
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错：
(base) h@h-virtual-machine:~/work/RuoYi-Vue3$ yarn dev yarn run v1.22.22 $ vite error when starting dev server: Error: listen EACCES: permission denied 0.0.0.0:80 at Server.setupListenHandle [as _listen2] (node:net:1880:21) at listenInCluster (node:net:1945:12) at Server.listen (node:net:2037:7) at httpServer.listen (file:///home/h/work/RuoYi-Vue3/node_modules/vite/dist/node/chunks/dep-4RECYSE1.js:59833:20) error Command failed with exit code 1. info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command. 这个错误通常是由于尝试在非特权端口（如80）上启动服务器而导致的权限被拒绝。这可能是因为你没有足够的权限来监听该端口。
解决方法1：使用 sudo 命令来以管理员权限运行该命令
sudo yarn dev 解决方法2：使用其他端口
yarn dev --port 3000 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd84977d0de31e7924019894600cb5c/" rel="bookmark">
			【Linux网络编程】高级IO——五种IO模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高级IO 1.什么是IO？什么是高效的IO？2.有那些IO的方式？这么多的方式，有那些是高效的？3.五种IO模型4.高级IO重要概念5.非阻塞IO 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.什么是IO？什么是高效的IO？ 在之前我们都知道的input，output不就是IO吗，站在冯诺依曼体系角度我们知道从外设把数据搬到内存这不就是Input吗，把数据从内存拷贝到外设中这不就是output吗。这不就是传说中的IO吗。没错，但是这种理解还不够深刻！
当我们在网络中发送数据的时候是使用read发送，write读取。当我们在进行read读取的时候曾经说过，我们在应用层调用read本质并不是把数据发送到网络中，其实只是把数据从应用层拷贝到传输层的发送缓冲区，所有read本质就是拷贝。当我们调用write读取数据时，其实并不是从网络中读取，而是从传输层的接收缓冲区中把数据从内核中拷贝到应用层，所以write也是拷贝函数。可是你想拷贝就能给你拷贝吗？
你想write，有没有可能发送缓冲区因为流量控制的问题发送缓冲区已经被写满了数据，你想write但当前缓冲区没有空间让你write了。那么此时write操作默认就是阻塞在哪里，直到缓冲区有空间了。write我们写代码到现在见到很少。但是当我们read读取数据的时候，我们被阻塞的情况是非常常见的。
以读为例，说读取就是拷贝这句话没错，但是当你想拷贝就能拷贝吗？万一人家接收缓冲区就没有数据呢？你的read只能阻塞住。所以要记住read、write本质就是拷贝，但是拷贝是有条件的。
所以不用考虑操作系统，就站在read接口使用角度，调用read/recv… 有两种情况
没有数据，就会阻塞住有数据，read/recv… 会在拷贝完成之后进行返回 这个阻塞不就是在等待资源就绪吗。
所以不能简单认为read/recv… 只有拷贝。这是不全面的认识。read/recv… 读取的本质应用要分成两种东西。站在我们角度read/recv…就是input。读取也是同样如此要风两种东西，write/send…就是output。
IO本质：
IO = 等 + 数据拷贝
在系统层面和网络层面IO都叫数据拷贝，就比如写文件的时候，把数据写到文件的过程我们根本不知道，调用write也只是把文件写到操作系统里，然后由操作系统把数据刷新到文件里。同理，我们也没有资格把数据直接写到网络里，只是把数据交给了操作系统，由操作系统帮我们发送。所以我们发现系统和网络在IO的处理上是一至的。在系统的时候我们不说IO=等+数据拷贝，是因为在系统层面等这个事情不直观，访问一个本地文件很快就写完成，很快就读完成了。看不到等。其实有没有等呢？一定要等！今天就知道了，你要读取数据，但数据可能并不在内存中，你必须要等，因为操作系统首先要把数据从外设搬到内存里。而磁盘是外设，所以操作系统要给磁盘下达指令把数据从磁盘中拷贝到内存等工作做完了，然后你才把数据从操作系统拷贝到用户，只不过这个过程太快了，你感受不到。
今天就不一样，在网络通信距离变长了，还要流量控制、拥塞控制等，所以距离一长等的比重就显得明显了，就能感觉到IO=等+数据拷贝了。
什么是高效的IO？
你经常会听别人说我们要高效的IO，凭什么？你IO高效的提高究竟是在做哪方面的提高？
首先数据拷贝这件事情，它的效率是固定的。因为数据拷贝的的本质是从硬件到硬件，该花多少时间就花多少时间，要么就是由你主机上的总线的位宽决定的，要么就是由你网络的带宽决定的。所以这个东西本身就是确定的，只要你能保证你在拷贝的时候它在100%一直在拷贝，它的效率就已经到达上限了。
既然IO = 等 + 数据拷贝，那什么叫做高效IO呢？
其实，只要减少 等待 的比重，即可！
想象一下调用read只花1秒，可是其中有99%的时间都在等待，等待的事件永远是主要矛盾，那么只有1%的时间花在拷贝上，拷贝本身就是从操作系统拷贝到用户，它是从内核到用户。站在硬件角度上就是从内存到内存，这个时间本身就是一个固定时间，站在操作系统角度把数据从外设搬到内存，把硬件上速度拉满它能拷贝多少就是多少。可是在IO大部分时间在等，如果把等和数据拷贝时间反过了，99%在拷贝，1%在等，我调用read很快就能够或者等的比重降的非常低，一调用read就直接返回，那这就叫做高效IO。
而在 等待 这件事情上，我们是需要从软件策略完成的。
read/recv它们策略很简单粗暴，没有数据就等，有数据就拷贝。
2.有那些IO的方式？这么多的方式，有那些是高效的？ 下面讲个小故事理解IO的过程。
我们可能见过别人钓鱼或者自己钓鱼，那么把钓鱼步骤化繁为简，钓鱼分两步
钓鱼 = 等 + 钓
现在有一条河，河里有很多野生鱼，远近闻名，很多人都到这里钓鱼。
张三是出了名的死心眼，一个事情没有得到结果，不会干其他事情，很专注。今天张三到河边钓鱼，把东西都弄好，然后把鱼钩鱼鳔扔到水里，就开始钓鱼了。那什么时候知道鱼咬钩了呢？当鱼鳔上下浮动就说明鱼咬钩了。张三在钓鱼的时候，眼睛死死的盯着鱼鳔，头也不回谁也不理，鱼鳔不动它不懂，鱼鳔动了就把鱼竿拉起来把鱼钓上来。然后继续重复上面过程。
过了一会，张三的朋友李四也来钓鱼，李四看到张三和他打招呼，张三也不理他，于是李四就直接在张三旁边找个地方钓鱼，然后也把鱼钩鱼鳔扔到水里，但是李四这个人啊，他发现鱼鳔没动，就转过头和张三聊天，但张三还是不理他。李四于是拿本书看，然后给别人打个电话等等，然后在看鱼鳔。鱼鳔没有动静，李四就继续一会这样一会那样，然后再看看鱼鳔。鱼鳔动了钓上的鱼然后继续重复上面过程。
所以我们就看到一个场景，有个人钓鱼一动不动，有个人钓鱼一会干这个一会干那个一直在动。
后来来了一个王五，王五看着这两个人很奇怪一个不动一个一直动，并且对他们钓鱼动作很不屑。他在把鱼钩鱼鳔扔到水里之前，顺手在鱼竿底部上绑上一个铃铛，然后把鱼竿扔到水里之后，王五翘起二郎腿，一会和李四聊天，一会玩会手机，一会也看会书，整个过程王五头也不抬，当铃铛响了，他就知道鱼咬钩了，王五也是头也不抬，直接把鱼竿拉起来钓上来一条鱼。然后王五就重复上面过程。
后来河边马路上来了一个小土豪赵六，他并不是拿着一条鱼竿来的，而是开着车拉着一车鱼竿来的，因为这条河不允许用网补鱼。所以他抱着自己带着的鱼竿踉踉跄跄的走到河边，沿途看着三个很奇怪的人，一个一直不动，一个一直在动，还有一个在哪里悠闲的翘着二郎腿做着自己的事情，赵六对他们钓鱼方式不屑一顾，于是赵六抱着一大推鱼竿挑了一个安静的地方，然后把这鱼钩鱼鳔扔到水里，并把鱼竿排的插在岸边，插了100m，然后赵六这个人来来回回的在插满鱼的岸边来回遍历检测，哪一个鱼竿上的鱼鳔动了此时就把鱼竿拉起来把鱼钓起来，然后再把鱼钩鱼鳔扔水里，然后再来回检测。
所以我们目前看到一幅场景，有人一直不动，有人一直在动，有人宛如高人一般头来不抬做着自己的事情有鱼把鱼竿拉起来就行了，有人在河边插满鱼竿在来回检测。
此时在河边马路上来了一辆车，车上坐着上市公司老板田七和他的司机小王，田七这个人很爱钓鱼，但是他今天要去公司开会他没有时间去钓鱼，田七认真分析了一下，我有没有可能根本不是爱钓鱼我就是想吃鱼，于是他让司机小王停车，给小王一个鱼竿、一个桶、一部电话和其他钓鱼工具，然后小王去河边钓鱼，把桶钓满了后，然后给他打电话，我再来接你。于是司机小王就去钓鱼了。然后田七开车走了。小王是一个钓鱼新手，他看张三钓鱼方式很适合它，于是它学着张三样子钓鱼。田七在干着他的事情，小王在和给他钓鱼。当小王把桶钓满了，然后给田七打电话，田七就来了，把桶理的鱼和小王都一带走了。田七也完成了某种上钓鱼
以上是五种人钓鱼方式，从这个故事中。当你看到什么情况的时候，你认为对应的人，钓鱼效率是很高的？
很简单，当你看到一个人钓鱼一直在等一个小时动都没动，那钓鱼效率一定不高。当我看到一个人每隔五分钟就把鱼竿拉起来钓到一条鱼我就觉得他效率高。推向极端，我看到一个人在河边一直挥舞着鱼竿一会就钓上来一条鱼。然后把鱼竿放下去然后又钓上鱼。这个人钓鱼效率特别高。
所以，钓鱼的人，等的比重比较低，单位时间，钓鱼的效率就高！
其次，张三，李四，王五，赵六，田七(小王)谁钓鱼效率最高？
首先张三、李四、王五、田七(小王)它们只有一人一竿，只有赵六是一人多竿。鱼竿多就是了不起。假设赵六100条竿，加上其他的人4条竿。站在鱼的角度头顶上有着104个诱饵，咬到任何一个诱饵概率是一样的，要是咬的话，赵六钓鱼成功概率就是100/104，其他人只是1/104，所以赵六钓鱼时任一鱼竿就绪概率概率就100/104。所以单位时间内任何一个鱼竿就绪概率就是比其他人大。所以站在旁观者看赵六就可能一直有鱼咬竿的事情。所以单位时间内，赵六这种钓鱼方式等的比重比较低，所以赵六钓鱼的效率比较高。
我们把这种一次可以等待多个鱼竿的钓鱼方式叫做多路转接/多路复用
张三 ------&gt; 阻塞IO
李四 ------&gt; 非阻塞IO
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd84977d0de31e7924019894600cb5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd10394c7da441999d3a9b1a75ed20b5/" rel="bookmark">
			【javaSE】内部类（来自类和对象的补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️❤️前言~🥳🎉🎉🎉 hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 💥个人主页：E绵绵的博客
💥所属专栏：JAVASE题目练习 JAVASE知识点专栏 c语言知识点专栏 c语言题目练习
之前我们在讲类和对象时就提到过内部类，不过当时说了等讲完抽象类和接口再讲这个，现在兑现诺言的时候到了，那我们开始内部类的学习吧！
内部类 ❤️❤️内部类是指在一个类的内部定义的另一个类。内部类可以访问外部类的所有成员，包括私有成员。内部类提供了一种封装和组织代码的方式，可以将相关的类和接口放在一起，增加代码的可读性和可维护性。
分为以下四种：
实例（成员）内部类，静态内部类，局部（方法）内部类，匿名内部类。
内部类虽然在外部类里面，但是它编译时内部类会形成单独的字节码文件
实例内部类 ❤️❤️实例内部类的成员变量和成员方法都不能用static修饰。
但存在一个特殊的点：实例内部类中的成员变量也可以用static修饰，只不过那必须加上final修饰使其变为常量才可以用static修饰。
❤️❤️我们要清楚虽然内部类在外部类里面，但实例化外部类并不会同时实例出内部类，所以当实例出外部类后，内部类需要我们主动实例化。
所以实例内部类的实例化需要先创建外部类的实例，然后再通过外部类的实例来创建实例内部类的对象。
例如，如果外部类是Outer，实例内部类是Inner，那么可以通过Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); 来实例化实例内部类.
当然还有另外一种方式也可以实例化实例内部类：Outer.Inner inner=new Outer().new lnner(); ❤️❤️在实例内部类中我们可以访问外部类的所有成员，包括私有成员。具体细节如下：
1. 🎯🎯当外部类和内部类成员不同名时，我们可以在实例内部类中直接使用外部类的成员变量和成员方法，无需前面还要引用：
在上图中InnerClass是实例内部类，我们在该内部类中直接使用了外部类中的成员变量a，但切记注意这里的a前面不能带this，如果带了this就表示这是内部类中的a，但我们内部类中不存在同名的a，所以报错。不带this直接用a时因为内部类没a所以就表示这是外部类中的a。
成员方法跟成员变量同理。
2. 🎯🎯而当内部类和外部类存在同名的成员变量时，内部类直接使用它时会优先选择自己的成员变量。如下：
此时就因为a同名导致直接使用a时优先选择内部类中的a，所以a和this.a都表示内部类中的a，而如果我们硬要使用外部类中的a时，就可以用 外部类的类名.this.a如OutClass.this.a表示这是外部类的a（注意这是特定的语法规则，我也不知道为什么用这样的格式能表示出外部类）.
成员方法跟成员变量同理
❤️❤️而在外部类中我们不能直接访问实例内部类的成员，需要通过创建实例内部类的对象再引用访问。（这个懂得都懂，就不多讲了）
❤️❤️除此之外，到了其他类中我们用内部类对象引用就只能引用其内部方法和变量（不能引用外部类的）
用外部类对象引用也只能引用其方法和变量（不能引用内部类的）
❤️❤️下面我们再看下文案，防止你们没看懂：
静态内部类 ❤️❤️我们现在说一下静态内部类跟实例内部类不同的点吧：
🎯🎯1.静态内部类可以有静态方法和变量，也可以有实例方法和变量。 🎯🎯2.静态内部类的创建不依赖于外部类的实例对象，可以直接通过外部类名创建。
如 OutClass.InnerClass innerClass = new OutClass.InnerClass();（OutClass为外部类，InnerClass为内部类）。
所以因为静态内部类的创建不需要先创建外部类，我们往往用静态内部类比实例内部类多一点。
🎯🎯3. 静态内部类可以直接访问外部类的静态成员，但不能直接访问外部类的非静态成员。如果需要访问外部类的非静态成员，可以通过在内部类中创建外部类的对象来实现。
如添加OutClass outclass=new OutClass（）；而后将在内部类中且原本来自外部类的实例变量和实例方法前加上outclass. 就可以了。
🎯🎯4. 如果在外部类中创建静态内部类的实例，可以省略外部类名，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd10394c7da441999d3a9b1a75ed20b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81efee50a3ea4de5cb52e35d12cc6403/" rel="bookmark">
			LocalAi，Ollama&#43;AnythingLLM搭建部署本地大模型AI知识库，汉化版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AnythingLLM 是一个全栈应用程序，您可以使用商业现成的 LLM 或流行的开源 LLM 和 vectorDB 解决方案来构建私有 ChatGPT，无需任何妥协，您可以在本地运行，也可以远程托管并能够智能聊天以及您提供的任何文件。
AnythingLLM 将您的文档划分为名为workspaces.工作区的功能很像线程，但增加了文档的容器化。工作区可以共享文档，但它们不会相互通信，因此您可以保持每个工作区的上下文干净。
anything-llm：https://github.com/Mintplex-Labs/anything-llm
ollama: https://github.com/ollama/ollama
在本地启动并运行大型语言模型, 根据自己的需求去安装启动大模型。
后面手动汉化迭代了一个版本，后续会发布github，需要请先关注收藏一下哈！
这个 monorepo 包含三个主要部分：
frontend：一个 viteJS + React 前端，您可以运行它来轻松创建和LLM可以使用的所有内容。
server：一个 NodeJS Express 服务器，用于处理所有交互并执行所有向量数据库管理和 LLM 交互。
docker：Docker 说明和构建过程+从源代码构建的信息。
collector：NodeJS Express 服务器，用于处理和解析来自 UI 的文档。
先来几张截图：
本地环境运行，window和mac是有所不同的，踩坑系列后面补上来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1acd3830191c01b6ea748a311198d912/" rel="bookmark">
			【含win&#43;Mac整合包】本地部署Stable Diffusion，超详细（AI 绘画保姆级教程，100%成功部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是stable diffusion? stable diffusion是在2022年发布的基于扩散模型的文本到图像生成模型，起初它只有一堆api供开发者使用，可以说非常难上手，随着2023年5月由AUTOMATIC1111大佬基于SD API开发的SD WebUI的发布，SD第一次有了操作界面，福音，绝对的福音，感谢大佬~
更新到今天，版本号已经来到了1.9.3，功能也是越来越丰富，比如说：
图生图文生图AI动画创作动漫2次元、真人转动漫、动漫转真人、创意二维码、老照片上色、老照片修复等等等等模型训练、模型融合提示词反推 还有很多，就不列举了
ℹ️整合安装包、模型资源见文末~
配置要求 windows电脑 配置要求 mac电脑 配置要求 window 安装 手动安装方式 对于新手不是太推荐，原因如下：
步骤繁琐运行起来经常报错，需要自行查资料解决 具体安装步骤，请参考：
stable diffusion windows 安装
秋叶一键整合包 （重点介绍） 目前最新的整合包版本是sd-webui-aki-v4.8.7，点击这个链接即可直达。整合包的优势就是一键安装即可，无须复杂环境配置。
先下载这个整合包运行 启动器运行依赖-dotnet-6.0.11.exe解压 sd-webui-aki-v4.8.7.7z目录找启动器（可以右键创建桌面快捷方式，方便查找） 双击A绘式启动器打开软件 可点击版本管理标签更新webui的版本，并勾选切换最新的webui版本 回到一键启动tab，点击蓝色的启动按钮即可启动webui 出张图看看：
mac 安装 这个不是重点，可以直接看下面的文章：
Mac本地部署Stable Diffusion，超详细，含踩坑点（AI 绘画保姆级教程，100%成功部署）
相关资源直达 整合包下载地址 整合包下载
模型资源分享 SD1.5 模型资源汇总
SDXL 模型资源整理
插件资源 SD 插件
4x-UltraSharp 放大算法 4x-UltraSharp 放大算法
秋叶炼丹炉整合包 秋叶炼丹炉（整合包）
关于AI绘画技术储备 学好 AI绘画 不论是就业还是做副业赚钱都不错，但要学会 AI绘画 还是要有一个学习规划。最后大家分享一份全套的 AI绘画 学习资料，给那些想学习 AI绘画 的小伙伴们一点帮助！
对于0基础小白入门：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1acd3830191c01b6ea748a311198d912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6270e38839b7869e9e5e9575c67980ad/" rel="bookmark">
			pnpm的安装与配置（Windows/macOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 文章目录 🔥 引言📦 PNPM简介🪟 Windows系统下安装与配置PNPM步骤一：安装Node.js步骤二：安装PNPM步骤三：配置PNPM镜像源（可选，提高下载速度）步骤四：验证安装步骤五：配置环境变量（仅当无法全局访问PNPM时） 🍏 macOS系统下安装与配置PNPM步骤一：安装Homebrew步骤二：安装Node.js步骤三：安装PNPM步骤四：配置PNPM镜像源（可选）步骤五：验证安装 📚 共同部分 🔐 相关链接 🔥 引言 在软件开发的宏伟版图中，包管理器犹如穿梭于代码丛林中的向导，引领着开发者高效穿梭于依赖的迷宫。PNPM，这位新时代的领航者，凭借其革命性的设计哲学，重塑了我们对于依赖管理的认知。它不仅是一场对空间与时间的优雅革命——极大地缩减了开发环境的存储负担，更以闪电般的安装速度，让项目启动迅疾如风。PNPM的出现，是对现代开发流程的一次深刻优化，它让开发者能够更加专注于创意的实现，而非被工具的琐碎束缚。本文旨在为Windows与macOS平台下的开发者铺设一条通往PNPM高效之门的坦途，无论你是处于项目萌芽的初期，还是在维护壮大的系统，PNPM都将是那把开启无缝开发之旅的钥匙。
📦 PNPM简介 PNPM作为新一代的包管理器，通过引入内容可寻址文件系统和硬链接，有效解决了npm存在的重复依赖问题，极大地节省了磁盘空间和提高了安装速度。相比Yarn和npm，PNPM在处理依赖上有其独特的优势：
减少磁盘占用：PNPM通过“只安装一次”的策略，确保每个依赖包在全局存储中只有一个版本，然后通过硬链接或符号链接的方式供各个项目使用，从而大幅度减少了磁盘空间的占用。
提升安装速度：由于大部分依赖已经存在于全局存储中，新项目或现有项目的安装过程主要涉及链接操作，而非重新下载，因此安装速度显著加快。
精确的依赖管理：PNPM通过生成的pnpm-lock.yaml文件，精确记录每个依赖的确切版本和子依赖信息，确保跨环境的一致性，避免“作品在别人机器上无法运行”的问题。
综上所述，不论是Windows还是macOS平台，安装与配置PNPM后，开发者便能立即享用到更高效的依赖管理体验，无论是初始化新项目、添加依赖包还是团队间共享与同步依赖，PNPM都能提供一个既快速又可靠的解决方案，进一步提升开发效率与团队协作的流畅度。
🪟 Windows系统下安装与配置PNPM 步骤一：安装Node.js 首先，访问 Node.js官方网站 获取适用于Windows操作系统的最新稳定版安装程序。在安装过程中，请确保勾选“Add to PATH”选项，这将允许全局访问Node.js和npm工具。 步骤二：安装PNPM 打开命令提示符（CMD）或PowerShell，执行以下命令以全局安装PNPM：npm install --global pnpm 步骤三：配置PNPM镜像源（可选，提高下载速度） 若要切换至国内镜像源，如cnpm或其它国内快速源：pnpm config set registry https://registry.npmmirror.com 步骤四：验证安装 在命令行窗口中输入以下命令检查PNPM版本：pnpm -v 若成功输出PNPM的版本号，则表明已正确安装。 步骤五：配置环境变量（仅当无法全局访问PNPM时） 如果安装Node.js时没有自动设置环境变量，您需手动将PNPM的可执行文件路径添加至系统PATH中： 找到PNPM的安装目录（通常是 %APPDATA%\Roaming\npm 或 %USERPROFILE%\AppData\Local\pnpm），其中包含 pnpm.cmd 文件。将该目录添加至系统的PATH环境变量内。 🍏 macOS系统下安装与配置PNPM 步骤一：安装Homebrew 如果您还未安装Homebrew，打开终端并运行以下命令进行安装：/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/main/install.sh)" 步骤二：安装Node.js 使用Homebrew安装Node.js：brew install node 步骤三：安装PNPM 同样借助Homebrew来安装PNPM：brew install pnpm 步骤四：配置PNPM镜像源（可选） 要更改至国内镜像源，执行：pnpm config set registry https://registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6270e38839b7869e9e5e9575c67980ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d969586f9a9e047aa0e683fd5e287bd/" rel="bookmark">
			国内首发 | CSA大中华区启动《AI安全产业图谱（2024）》调研
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在人工智能（AI）技术的快速发展浪潮中，AI安全已成为全球关注的焦点。为应对AI安全带来的挑战，确保AI技术的健康发展，全球范围内的研究机构、企业和技术社区都在积极探索解决方案。
在这一背景下，CSA大中华区于2023年9月成立了AI安全工作组，汇集了来自中国电信、蚂蚁集团、电子科技大学、华为、百度安全、京东安全等机构的专家，致力于构建一个多方参与、共同治理的AI安全生态系统。
CSA大中华区在AI安全领域开展了多项研究工作并取得显著成果。先后发布了《ChatGPT的安全影响》、《AI安全白皮书》、《全球人工智能治理宣言》等研究成果；与OpenAI、亚马逊、谷歌、微软等行业巨头合作，共同发起了AI安全倡议。此外，由CSA大中华区牵头，联合 OpenAI、蚂蚁集团、科大讯飞、谷歌、微软等数十家单位的多名专家学者共同编写的《生成式AI应用安全测试标准》和《大模型安全测试方法》两项国际标准，在第27届联合国科技大会（联合国科技领域的最高级别会议）上由世界数字技术院（WDTA）发布。这是国际组织首次在生成式AI应用安全、大模型安全领域发布国际标准，为业界提供了统一的测试基准。
此次《AI安全产业图谱（2024）》由CSA大中华区发起，旨在系统收集和分析在AI安全领域活跃的各企业和组织的信息，提供一个全面的AI安全行业概览，为后续研究工作、产业发展、政策制定以及企业用户建设提供参考和支持。
调研对象： 面向AI领域的技术提供商、服务供应商、科研院所、高校及其他相关企业单位。
申报流程： 参与单位需自主填写问卷进行申报。CSA大中华区的专家评审团将对提交的资料进行评选和审核，选出符合的单位入选《AI安全产业图谱（2024）》，图谱将于2024年第三季度发布。
申报通道： 添加CSA微信，获取AI安全产业图谱（2024）调研问卷：
微信：csagcr
问卷截止日期：
2024年5月15日
调研内容 《AI安全产业图谱（2024）》包括以下4个大类，20个小类
一、 AI内生安全 ○数据安全
○模型安全
○供应链安全
二、 AI赋能安全 ○威胁检测与响应
○身份认证和行为分析
○反欺诈与风险控制
○恶意行为检测
○物联网安全
○安全托管服务（MSS）
○AI SecOps
○其他
三、 AI安全服务 ○安全咨询
○评估/审计/认证/测评
○安全培训
四、 AI安全研究 ○AI安全标准制定
○AI前沿技术研究
○创新技术应用及成果转化
○AI伦理与合规治理
○隐私保护
CSA大中华区AI安全系列活动 产业图谱 《AI安全产业图谱（2024）》现正式启动，将于2024年第三季度发布。
线下大会 CSA大中华区将于2024年7月在香港举办与AI安全、数据安全等热点话题相关的安全峰会，邀请CSA大中华区成员、国际研究机构、科技龙头企业及图谱入围单位线下参会，共议AI安全。
访谈调研 CSA大中华区将对图谱部分入围单位的创始人、技术专家进行深度专访，并报道其AI安全相关的产品和服务。
AI安全认证培训课程 CSA大中华区将于7月发布针对个人的AI安全认证培训课程，入选图谱的单位且是CSA大中华区成员单位，将有机会获得首期班培训名额。
行业研究 CSA大中华区将与各成员单位开展研究合作，持续发布AI安全领域的深度研究报告，包括AI模型可信度研究报告、安全开发by AI白皮书、人工智能和安全状况调查报告等。
CSA大中华区AI安全神兽方阵项目预告 《AI安全神兽方阵报告》-分析报告 在AI安全产业图谱的基础上，CSA大中华区将发布《AI安全神兽方阵报告》。报告将分析和总结AI安全领域国内外的技术发展、市场容量、前景及国外企业的发展状况。
往期神兽方阵报告
AI安全神兽方阵-榜单奖项 CSA大中华区将基于原创的神兽方阵模型对AI安全企业的技术领先性、产品成熟度、市场影响力等维度进行综合分析评估，提供综合性的评价，并在神兽方阵中予以形象的定位展示和供市场参考的能力排行。
往期神兽方阵入选企业表彰
第八届云安全联盟大中华区大会-会议活动 《AI安全神兽方阵报告》将在第八届云安全联盟大中华区大会上发布，在大会上对入选AI安全神兽方阵的企业进行荣誉表彰，并提供平台给优秀企业进行品牌展示、宣讲推广与合作对接。
欢迎各方加入CSA大中华区，积极参与CSA大中华区AI安全相关工作，共赴安全、可信、负责任的AI时代新征程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5bf1d709e69e12371584f265ba562bc/" rel="bookmark">
			使用Gradio搭建聊天UI实现质谱AI智能问答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Gradio搭建聊天UI实现质谱AI智能问答 一、调用智谱 AI API二、使用Gradio搭建聊天UI三、将流式处理添加到交互式聊天机器人 一、调用智谱 AI API 1、获取api_key
智谱AI开放平台网址：
https://open.bigmodel.cn/overview
2、安装库pip install zhipuai
3、执行一下代码，调用质谱api进行问答
from zhipuai import ZhipuAI client = ZhipuAI(api_key="xxxxx") # 填写您自己的APIKey while True: prompt = input("user:") response = client.chat.completions.create( model="glm-4", # 填写需要调用的模型名称 messages=[ {"role": "user", "content": prompt} ], ) answer = response.choices[0].message.content print("ZhipuAI:", answer) 二、使用Gradio搭建聊天UI import gradio as gr import random import time from langchain_community.chat_models import ChatZhipuAI from zhipuai import ZhipuAI import configure llm = configure.chat client = ZhipuAI(api_key="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5bf1d709e69e12371584f265ba562bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e5c7147eadd3440e660a8243e906c88/" rel="bookmark">
			11个值得关注的文本转语音AI大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语言模型，尤其是大型语言模型（LLM），本质上已经成为人工智能的代表。然而，他们有一个隐秘的问题。到目前为止，人工智能社区主要在文本数据上训练人工智能，而忽略了音频数据。结果，我们阻碍了LLM，因为我们只教他们如何读/写，但从未教他们如何说/听。
然而值得庆幸的是，一些公司正在改善这个问题。在我们追求更强大的LLM的道路上，我们一路上创造了一些令人难以置信的产品。其中一个产品是一系列令人难以置信的文本转语音 (TTS) 模型，每个模型都有其独特的优势。我们列出了 2024 年（迄今为止）11款最佳 TTS 模型。
如果你正在构建需要语音的应用程序（从新的 GPS 系统到视频游戏甚至 IVR 系统），那么这些应用程序非常适合你！
NSDT工具推荐： Three.js AI纹理开发包 - YOLO合成数据生成器 - GLTF/GLB在线编辑 - 3D模型格式在线转换 - 可编程3D场景编辑器 - REVIT导出3D模型插件 - 3D模型语义搜索引擎 - Three.js虚拟轴心开发包 - 3D模型在线减面 - STL模型在线切割
1、ElevenLabs ElevenLabs 自 2022 年以来一直在生成人工智能语音，重点是合成各种语言听起来尽可能自然的语音。上面的视频展示了他们的技术技能，包括西班牙语、英语、德语、波兰语和法语。
最近，他们发布了 ElevenLabs Dubbing Studio，使你能够为世界各地的人们翻译大量内容。它支持29种语言，甚至连配音工作室的广告都使用ElevenLabs的声音！
你可以免费开始使用 ElevenLabs，他们的 API 配备了用户友好的文档，指导你了解从 Websockets 到 Streaming 的所有内容。
优点：极其自然的声音、独特的配音工作室
最常见的用例：视频、游戏、有声读物、人工智能聊天机器人、一般娱乐
2、Deepgram Deepgram 的 Aura 模型是实时对话文本转语音的巅峰之作。如果你正在创建 IVR 系统或 AI 代理来处理大规模实时对话，Aura 无疑是你的最佳选择。 Deepgram 的 TTS 模型的延迟低于 200 毫秒，可能是人工智能世界中最快的模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e5c7147eadd3440e660a8243e906c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a695f66c738da866fcef84c906581406/" rel="bookmark">
			在微信小程序部署AI模型的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文只是分享思路，不提供可完整运行的项目代码
onnx部署 以目标检测类模型为例，该类模型会输出类别信息，置信度，包含检测框的4个坐标信息
但不是所有的onnx模型都能在微信小程序部署，有些算子不支持，这种情况需要点特殊操作，我暂时不能解决。
微信小程序提供的接口相当于使用onnxruntime的接口运行onnx模型，我们要做的就是将视频帧数据（包含RGBA的一维像素数组）转换成对应形状的数组（比如3*224*224的一维Float32Array），然后调用接口并将图像输入得到运行的结果（比如一个1*10*6的一维Float32Array，代表着10个预测框的类别，置信度和框的4个坐标），然后将结果处理（比如行人检测，给置信度设置一个阈值0.5，筛选置信度大于阈值的数组的index，然后按照index取出相应的类别和框坐标），最后在wxml中显示类别名或置信度或在canvas绘制框。
代码框架 这里采用的是实时帧数据，按预设频率调用一帧数据并后处理得到结果
onLoad主体 onLoad(){ // 创建相机上下文 const context = wx.createCameraContext(); // 定义实时帧回调函数 this.listener=context.onCameraFrame((frame)=&gt;this.CamFramCall(frame)); // 初始化session this.initSession() }, 相机实时帧回调函数 得到的实时帧数据因系统而异，并不固定(这对后面画追踪框的时候不利)
我的处理方法是把帧数据和&lt;camera&gt;组件的长宽比例统一，这样得到坐标后再乘以一个比例系数即可映射到&lt;camera&gt;因为输进去模型的是帧数据，所以返回的追踪框坐标是基于帧数据的，直接画在&lt;camera&gt;上的canvas有可能出现框的位置有偏差
回调函数里的逻辑是设置&lt;camera&gt;的长（我把宽定死到手机屏幕长度的0.9），预处理图片数据，进行推理，关闭监听（至此完成一帧）
CamFramCall(frame){ // 根据实时帧的图片长宽比例设置&lt;camera&gt;组件展示大小 this.setData({ windowHeight:frame.height/frame.width*wx.getSystemInfoSync().windowWidth*0.9 }) var dstInput=new Float32Array(3*this.data.imgH*this.data.imgW).fill(255) // 调用图片预处理函数对实时帧数据进行处理 this.preProcess(frame,dstInput) // 将处理完的数据进行推理得到结果 this.infer(dstInput) console.log('完成一次帧循环') // 关闭监听 this.listener.stop() }, 初始化session 首先得将onnx上传至云端，获得一个存储路径（比如cloud://cloud1-8gcwcxqrb8722e9e.636c-cloud1-8gcwcxqrb8722e9e-1324077753/rtdetrWorker.onnx）
当用户首次使用该小程序时，手机里没有onnx模型的存储，需要从云端下载；而已经非第一次使用该小程序的用户手机里已经保存了之前下载的onnx模型，就无需下载。所以此处代码逻辑是需要检测用户的存储里是否有该onnx模型，不存在就下载，下载完并保存模型文件后就执行下一步；存在就直接执行下一步。
initSession(){ // onnx云端下载路径 const cloudPath='cloud://cloud1-8gcwcxqrb8722e9e.636c-cloud1-8gcwcxqrb8722e9e-1324077753/best.onnx' const lastIndex=cloudPath.lastIndexOf('/') const filename=cloudPath.substring(lastIndex+1) const modelPath=`${wx.env.USER_DATA_PATH}/`+filename // 检测onnx文件是否存在 wx.getFileSystemManager().access({ path:modelPath, // 如果存在就创建session，定时开启监听实时帧 success:(res)=&gt;{ console.log('file already exist') this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a695f66c738da866fcef84c906581406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358f370210f8a830f6a28b6f2b766f3c/" rel="bookmark">
			【状态压缩 动态规划 数论】1799. N 次操作后的最大分数和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及知识点 状态压缩 动态规划 数论
动态规划汇总
LeetCode1799. N 次操作后的最大分数和 给你 nums ，它是一个大小为 2 * n 的正整数数组。你必须对这个数组执行 n 次操作。
在第 i 次操作时（操作编号从 1 开始），你需要：
选择两个元素 x 和 y 。
获得分数 i * gcd(x, y) 。
将 x 和 y 从 nums 中删除。
请你返回 n 次操作后你能获得的分数和最大为多少。
函数 gcd(x, y) 是 x 和 y 的最大公约数。
示例 1：
输入：nums = [1,2]
输出：1
解释：最优操作是：
(1 * gcd(1, 2)) = 1
示例 2：
输入：nums = [3,4,6,8]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/358f370210f8a830f6a28b6f2b766f3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47135ef19859c4e2edc9dce21bab523/" rel="bookmark">
			2024年前端最新vue项目如何打包以及如何变成android、ios应用程序，前端简历项目经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最后 在面试前我花了三个月时间刷了很多大厂面试题，最近做了一个整理并分类，主要内容包括html，css，JavaScript，ES6，计算机网络，浏览器，工程化，模块化，Node.js，框架，数据结构，性能优化，项目等等。
包含了腾讯、字节跳动、小米、阿里、滴滴、美团、58、拼多多、360、新浪、搜狐等一线互联网公司面试被问到的题目，涵盖了初中级前端技术点。
HTML5新特性，语义化
浏览器的标准模式和怪异模式
xhtml和html的区别
使用data-的好处
meta标签
canvas
HTML废弃的标签
IE6 bug，和一些定位写法
css js放置位置和原因
什么是渐进式渲染
html模板语言
meta viewport原理
开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】 ]( )收到很多前端小伙伴私信，问我能不能写一篇vue开发的项目如何打包成android、ios应用,那么今天就带大家走一遍vue开发的项目如何打包，然后如何发布成android、ios安装程序，并安装在自己的手机上。
vue-cli4搭建的项目如何打包 基于vue开发的应用，现在主流的是使用vue/cli的4.x版本搭建的项目，从vue-cli的3.x版本以后，如何修改vue的项目配置呢？
1. 创建vue.config.js
首先，我们需要在项目根目录下创建一个vue.confing.js文件，项目目录如下
2. webpack配置
在vue.config.js中，我们就可以写很多webpack配置，常用的有: 配置端口号，配置跨域服务器代理等。我们需要的主要是配置一个打包的目录publicPath,否则打包出来的apk文件，安装在安卓手机上，可能出现白屏，具体配置如下:
module.exports = {
publicPath: “./”,// 需要配置 否则打包后的apk文件安装在手机可能白屏
devServer: {
port: “6868”, // 配置开发服务器的端口号（打包可以无需配置）
// 配置跨域代理(也可以使用CROS解决跨域)
proxy: {
“/ api”: {
target: “http://192.168.1.1:4343”, // 目标服务器地址
ws: true, // 是否代理websocket
changeOrigin: true, // 是否跨域
pathRewrite: {
“^/api”: ‘’ // url重写
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47135ef19859c4e2edc9dce21bab523/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823ee295c574098db846049a133d9a5d/" rel="bookmark">
			2024年前端最新vue大屏开发系列—列表无缝滚动之vue-seamless-scroll，前端开发关键技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 框架原理真的深入某一部分具体的代码和实现方式时，要多注意到细节，不要只能写出一个框架。
算法方面很薄弱的，最好多刷一刷，不然影响你的工资和成功率😯
在投递简历之前，最好通过各种渠道找到公司内部的人，先提前了解业务，也可以帮助后期优秀 offer 的决策。
要勇于说不，对于某些 offer 待遇不满意、业务不喜欢，应该相信自己，不要因为当下没有更好的 offer 而投降，一份工作短则一年长则 N 年，为了幸福生活要慎重选择！！！
开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
喜欢这篇文章文章的小伙伴们点赞+转发支持，你们的支持是我最大的动力！
yarn 安装： yarn add vue-seamless-scroll
#### 二 使用 全局注册： import Vue from ‘vue’
import scroll from ‘vue-seamless-scroll’
Vue.use(scroll)
局部注册： 注意这里分vue2和veu3注册 vue2: import vueSeamless from ‘vue-seamless-scroll’
vue3；找不到路径所以加了 /src import vueSeamless from ‘vue-seamless-scroll/src’
components: { vueSeamless },
#### 三 简单使用 ``` 四 应用 本文是在“物美智能”源码的基础上进行二次开发完成wumei-smart: 物美智能开源物联网平台，简单易用，可用于搭建物联网平台以及二次开发和学习。适用于智能家居、智慧办公、智慧社区、农业监测、水利监测、工业控制等。
也可以直接在lofTV-Screen代码上直接修改IofTV-Screen: 🔥一个基于 vue、datav、Echart 框架的物联网可视化（大屏展示）模板，提供数据动态刷新渲染、屏幕适应、数据滚动配置，内部图表自由替换、Mixins注入等功能，持续更新…
效果如下，技术点主要使用了
&lt;template&gt; &lt;div v-if="pageflag" class="right_center_wrap beautify-scroll-def" :class="{ 'overflow-y-auto': !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/823ee295c574098db846049a133d9a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e0229991e60674195cbb530220a443/" rel="bookmark">
			JavaWeb实现模拟数据库实现购物车功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一， 创建JavaWeb项目 1.1在空文件里创建一个文件加例如我创建的是web02文件夹 1.2 idea中创建JavaWeb项目 1.3 选择刚刚创建的文件夹 1.4 创建文件初始化工程文件目录 二，创建POJO类 Product类 ，是一共父类后续物品都继承它
package com.best.pojo; // 商品类 public class Product { private int id; private String name; private double price; private Integer quantity; public Product(int id, String name, double price) { this.id = id; this.name = name; this.price = price; this.quantity = 0; } public Integer getQuantity() { return quantity; } public void setQuantity(Integer quantity) { this.quantity = quantity; } public int getId() { return id; } public void setId(int id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e0229991e60674195cbb530220a443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f545a5abf16c7acb75abc2312603d6eb/" rel="bookmark">
			【LeetCode例141】【c语言】环形链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 题目介绍 给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
示例1：
输入以下这条链，head指向值为3的节点
返回值应该为 true
示例2：
输入以下这条链，head指向值为1的节点
返回值应该为 true
示例3：
输入以下这条链，head指向值为1的节点
返回值应该为false
这里放上链接. - 力扣（LeetCode） 2 解题思路 2.1 思路1（逆序法）： （注意：此方法不是最优解）
基本思想就是逆序整个链表时（简单来说就是让箭头掉头指回上一个节点），如果这个链表是带环的，那么指针cur会从头节点开始遍历，最终回到头节点，若链表不带环，则指针cur回不到头节点
由于有些链表不带头节点，所以一开始需要我们手动创建一个哨兵位
我们需要先定义三个指针，负责将箭头转向
接着就是如法炮制
注意，这里nextnode回到了值为2的节点
（注意：nextnode指向NULL时，让循环停止，并且开始检测 cur 是否回到了哨兵位，否则就停不下来了） 此时我们发现 cur 回到了哨兵位，一旦产生这种情况，就证明这个链表是带环的
立马返回 ture 就可以
对于不带环的链表来讲，检测到 cur 没有回到哨兵位，就返回 false
2.2 思路2（快慢指针）： 基本思路就是快慢指针，一个指针跑得快一点，另一个慢一点，让他俩一直随着 next 指针遍历，快指针和慢指针的距离不断缩短，直到两者相遇，就好比两个人绕操场跑步，都是匀速跑，一个块一个慢，如果不记时间的话那么，这两个人一定会相遇，一旦相遇，就说明这个链表是带环的，因为两者速度不一样，跑道是直线的话是一定不会相遇的
（这个方法是最优解）
快指针：一次走两步（每次走一步都要判断一下 fast 和 fast-&gt;next 是否为 NULL，防止出现野指针）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f545a5abf16c7acb75abc2312603d6eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f40d5caaf1126df2c77fb27897a03f/" rel="bookmark">
			【数据结构】--- 深入剖析二叉树（中篇）--- 认识堆&amp;&amp;堆排序&amp;&amp;Topk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Welcome to 9ilk's Code World (๑•́ ₃ •̀๑) 个人主页: 9ilk (๑•́ ₃ •̀๑) 文章专栏： 数据结构之旅 文章目录
🏠 初识堆
📒 堆的概念
📒 堆的性质
🏠 向上调整算法 &amp;&amp; 向下调整算法
📒 向上调整算法
📒 向下调整算法
📒 向上调整 vs 向下调整
🏠 堆的应用场景
📒 堆排序
📒 Top K问题
上篇我们讲解了树以及二叉树，相信小伙伴们对二叉树有了初步的了解，本篇文章我们来了解下由二叉树延伸出来的堆以及堆排序，Top K问题。
🏠 初识堆 我们知道二叉树的顺序结构适合于完全二叉树和满二叉树，而我们今天的主角堆也是个完全二叉树，因此它也是使用顺序结构的数组来存储
📒 堆的概念 堆的概念（来自度娘）：
⚠️
我们这里的堆是一种数据结构，而操作系统虚拟进程地址空间的堆区是操作系统中管理内存的一块区域分段。堆分为大堆和小堆。大堆指的是双亲结点的值域大于孩子结点，小堆指的是双亲结点的值域小于孩子结点。堆只规定了孩子和双亲的关系，并未规定兄弟间的大小关系堆在物理层面是数组，逻辑结构上是二叉树。 📒 堆的性质 堆中某个节点的值总是不大于或不小于其父节点的值
堆总是一棵完全二叉树
🏠 向上调整算法 &amp;&amp; 向下调整算法 对于这样的一个小堆，我们要插入2这个数据，此时不满足小堆的要求，若要调整可能会影响祖先，那有什么方法能解决这个问题呢？这里就要介绍一个新的算法 --- 向上调整算法
📒 向上调整算法 我们先上个动图来感受下 ~ 我们可以看到这个过程是针对某个结点而言的，若要满足小堆，依次拿这个结点向上与它的祖先比较，如果它比祖先小就交换，直到小于它的某个祖先或交换到根结点的位置。
⚠️ 向上调整算法只能帮助我们使根结点的值域最小，而不能保证所有其他结点的大小关系！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f40d5caaf1126df2c77fb27897a03f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc75fc1e2c787c5e82c755b5c8db85f2/" rel="bookmark">
			C&#43;&#43;初阶学习第五弹——类与对象（下）——类与对象的收官战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类与对象（上）：C++初阶学习第三弹——类与对象（上）——初始类与对象-CSDN博客
类与对象（中）：C++初阶学习第四弹——类与对象（中）——刨析类与对象的核心点-CSDN博客
前言：
在前面我们已经学习了C++类与对象的关键操作——默认成员函数，今天我们对之前的内容进行一些补充，同时再来学习几个新的知识点Static成员、友元和内部类
目录
一、构造函数进阶
1.1 构造函数的赋值化
1.2 构造函数的初始化
1.3 explicit关键字
二、static成员
三、友元
3.1 友元函数
3.2 友元类
四、内部类
五、总结
一、构造函数进阶 1.1 构造函数的赋值化 在前面，我们说对一个自定义类型的变量，当我们定义时可以通过构造函数默认初始化，操作如下：
class Date { public: Date(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; int main() { Date d1(); return 0; } 实际上这样的操作并不叫作初始化，更确切的说应该叫赋值化，因为初始化只能有一次，而这个操作却可以多次赋值
比如：
Date(int year, int month, int day) { _year = year; _month = month; _day = day; _year = 3; } 这里就对_year进行了两次赋值，所以这个操作不能称之为初始化，而应该称之为赋值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc75fc1e2c787c5e82c755b5c8db85f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5608ae1f658cf7ca8e8f11ca28fbef/" rel="bookmark">
			2024年前端最新DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】(1)，面试经历分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript js的基本类型有哪些？引用类型有哪些？null和undefined的区别。
如何判断一个变量是Array类型？如何判断一个变量是Number类型？（都不止一种）
Object是引用类型嘛？引用类型和基本类型有什么区别？哪个是存在堆哪一个是存在栈上面的？
JS常见的dom操作api
解释一下事件冒泡和事件捕获
事件委托（手写例子），事件冒泡和捕获，如何阻止冒泡？如何组织默认事件？
对闭包的理解？什么时候构成闭包？闭包的实现方法？闭包的优缺点？
this有哪些使用场景？跟C,Java中的this有什么区别？如何改变this的值？
call，apply，bind
显示原型和隐式原型，手绘原型链，原型链是什么？为什么要有原型链
创建对象的多种方式
实现继承的多种方式和优缺点
new 一个对象具体做了什么
手写Ajax，XMLHttpRequest
变量提升
举例说明一个匿名函数的典型用例
指出JS的宿主对象和原生对象的区别，为什么扩展JS内置对象不是好的做法？有哪些内置对象和内置函数？
attribute和property的区别
document load和document DOMContentLoaded两个事件的区别
JS代码调试
开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
========================================================================
官网地址：戳这里
第二步：添加人大金仓的数据库引擎
==========================================================================
其实就是选择我们本地仓库引入的jar包
如下图：
选择Driver Files，也就是我们本地仓库中kingbase8的jar包
从本地仓库中找到
切换Class
完成后如下图：
点击Apply保存引擎
第三步：输入账号密码连接
======================================================================
先测试连接一下
没有问题就点击OK
第四步：查看数据库
===================================================================
我们需要勾选下All database，不然看不到表数据
总结 我在成长过程中也是一路摸爬滚打，没有任何人的指点，所以走的很艰难。例如在大三的时候，如果有个学长可以阶段性的指点一二，如果有已经工作的师兄可以告诉我工作上需要什么，我应该前面的三年可以缩短一半；后来去面试bat，失败了有5、6次，每次也不知道具体是什么原因，都是靠面试回忆去猜测可能是哪方面的问题，回来学习和完善，当你真正去招人的时候，你就会知道面试记录是多么重要，面试官可以从面试记录里看到你的成长，总是去面试，总是没有成长，就会被定义为缺乏潜力。
开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】](https://bbs.csdn.net/topics/618166371)**
[外链图片转存中…(img-cNFmEWWE-1715006841496)]
[外链图片转存中…(img-mGj9dHiU-1715006841497)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a6d78591551e9c61ce6dbf66f2c509/" rel="bookmark">
			Fireworks AI和MongoDB：依托您的数据，借助优质模型，助力您开发高速AI应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们欣然宣布
MongoDB与 Fireworks AI 正携手合作
让客户能够利用生成式人工智能 (AI)
更快速、更高效、更安全地开展创新活动
Fireworks AI由 Meta旗下 PyTorch团队的行业资深人士于 2022 年底创立，他们在团队中主要负责优化性能、提升开发者体验以及大规模运行 AI 应用。
Fireworks AI 将这些专业知识运用于自己的生产 AI 平台，从而整理并优化了业界优质的开放模型。该公司进行了基准测试，结果表明，在 Fireworks AI 上运行的生成式 AI 模型的推断速度比其他同类平台快 4 倍，吞吐量和规模高出多达 8 倍。
模型属于应用程序堆栈的一部分。然而，开发者要想发挥生成式人工智能的力量，还需要将企业数据引入这些模型中。这正是企业采用 AI 时所面临的一大棘手问题，也是 Fireworks AI 与 MongoDB 开展合作的原因。借助 MongoDB Atlas，开发者可以安全地将运营数据、非结构化数据和向量嵌入进行统一，从而安全打造一致、正确和差异化的 AI 应用程序和体验。
Fireworks AI 和 MongoDB 强强联手，精心整理并优化了各种开源模型，为想要结合企业自身专有数据使用这些模型的开发者提供了解决方案，并且能够快速安全地实现这一切。
Fireworks AI提供快如闪电的模型：将速度、效率和价值“一网打尽” Fireworks AI 凭借快如闪电的推断平台，整理、优化并部署了 40 多种不同的 AI 模型。这些优化措施可以同时节省大量成本、减少延迟、提高吞吐量。他们的平台通过以下方式实现这些效果：
● 现成模型、优化模型和插件：Fireworks AI 提供一系列高质量的文本、嵌入和图像基础模型。开发者可以利用这些模型或者对其进行微调，然后部署自己的模型，再借助 MongoDB Atlas 将自己的专有数据引入模型。
● 微调功能：为了进一步提高模型的准确性和速度，Fireworks AI 还提供了微调服务，该服务可利用命令行界面 (CLI) 从 MongoDB Atlas 等数据库中摄取采用 JSON 格式的对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65a6d78591551e9c61ce6dbf66f2c509/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/379/">«</a>
	<span class="pagination__item pagination__item--current">380/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/381/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>