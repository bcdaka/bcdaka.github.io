<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5979abe2e013d189c3a55a40359bf2f/" rel="bookmark">
			如何基于 Python 快速搭建 QQ 开放平台 QQ 群官方机器人详细教程（更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册 QQ 开放平台账号 账号注册
QQ 机器人：一个机器人可以被添加到 群聊/频道 内对话，QQ 用户也可以直接跟机器人 单独对话。
开发者账号主体要求
单聊对话：【定向邀请】 群聊场景：仅支持企业主体【个人主体暂不支持】 频道场景：企业主体与个人主体均可申请 注册地址：QQ 开放平台(opens new window)
注册创建机器人：获得的开发机器人接入票据 AppID AppSecret Token
创建机器人：https://q.qq.com/#/app/create-bot
开发设置：https://q.qq.com/qqbot/#/developer/developer-setting
查询官方文档 新版机器人官方文档：https://bot.q.qq.com/wiki/develop/api-v2/
GitHub 地址
安装 qq-botpy 环境 更新包的话需要添加 --upgrade 兼容版本：python3.8+
pip install qq-botpy 使用
需要使用的地方import botpy
import botpy 兼容提示
原机器人的老版本qq-bot仍然可以使用，但新接口的支持上会逐渐暂停，此次升级不会影响线上使用的机器人。
基础案例演示 通过继承实现bot.Client, 实现自己的机器人Client
实现机器人相关事件的处理方法,如 on_at_message_create， 详细的事件监听列表，请参考 事件监听.md
定义机器人被@的后自动回复
import botpy from botpy.message import Message class MyClient(botpy.Client): async def on_at_message_create(self, message: Message): await message.reply(content=f"机器人{self.robot.name}收到你的@消息了: {message.content}") 注意：每个事件会下发具体的数据对象，如message相关事件是message.Message的对象 (部分事件透传了后台数据，暂未实现对象缓存)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5979abe2e013d189c3a55a40359bf2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99920cbc009129251dc0df6ed3768f29/" rel="bookmark">
			C语言详解（动态内存管理）2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi~！这里是奋斗的小羊，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~
💥💥个人主页：奋斗的小羊
💥💥所属专栏：C语言
🚀本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为展示我的学习过程及理解。文笔、排版拙劣，望见谅。
目录 前言1、常见动态内存错误1.1 对NULL指针的解引用操作1.2 对动态内存空间的越界访问1.3 对非动态开辟内存使用free释放1.4 使用free释放动态内存的一部分1.5 对同一快动态内存多次释放1.6 动态开辟内存忘记释放（内存泄漏） 2、动态内存经典笔试题分析2.1 题目一2.2 题目二2.3 题目三2.4 题目四 3、柔性数组3.1 什么是柔性数组3.2 柔性数组的特点3.3 柔性数组的使用3.4 柔性数组的优势 总结 前言 总的来说，动态内存管理为我们提供了更加灵活、高效和可扩展的内存管理方式，但动态内存管理函数可能会带来一些风险，主要包括内存泄漏、内存溢出和野指针等问题，我们在使用动态内存管理函数时要多留心，避免风险的出现
1、常见动态内存错误 1.1 对NULL指针的解引用操作 如果我们写的代码不严谨，没有考虑到动态内存分配失败的可能，就会写出类似于下面的代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int* p = (int*)malloc(10 * sizeof(int)); //直接使用指针p int i = 0; for (i = 0; i &lt; 10; i++) { p[i] = i + 1; } return 0; } 这样的代码可能并没有什么问题，但是存在很大的隐患，因为动态内存函数是有可能开辟内存空间失败的，当开辟失败时会返回NULL，而NULL指针是不能解引用的
像VS这样比较强大的编译器会立马检测到并提示你
为了避免这种错误，我们需要对指针p进行判断，再决定是否使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99920cbc009129251dc0df6ed3768f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35aa7e3ffab55c6768ba76317b9554a8/" rel="bookmark">
			Java中的继承与接口详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java编程中，继承和接口是两个重要的概念，它们能够帮助我们构建更加模块化和可扩展的程序。本文将详细解释Java中的继承和接口，包括它们的定义、使用方法以及适合的场景。
1. 继承（Inheritance） 1.1 什么是继承？ 继承是面向对象编程中的一个核心概念，它允许一个类（子类）基于另一个类（父类）来定义自己。子类可以继承父类的字段和方法，并且可以扩展其功能或者重写父类的方法。
1.2 如何定义一个子类？ 在Java中，使用关键字 `extends` 来建立一个类的继承关系。
// 父类 class Animal { void eat() { System.out.println("动物正在吃饭"); } } // 子类 class Dog extends Animal { void bark() { System.out.println("狗在汪汪叫"); } } 在上面的例子中，`Dog` 类继承了 `Animal` 类。现在，`Dog` 类不仅可以调用自己的 `bark()` 方法，还可以调用从 `Animal` 类继承的 `eat()` 方法。
1.3 方法重写（Override） 子类可以根据自己的需要重写（Override）从父类继承过来的方法。
class Cat extends Animal { @Override void eat() { System.out.println("猫正在吃鱼"); } } 在这个例子中，`Cat` 类重写了 `Animal` 类中的 `eat()` 方法，使其输出变为“猫正在吃鱼”。
1.4 访问修饰符和继承 子类继承了父类的字段和方法，但是访问修饰符（如 `private`、`protected`、`public`）会影响子类对父类成员的访问权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35aa7e3ffab55c6768ba76317b9554a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2128f2319d361a443b350d168f3b66b/" rel="bookmark">
			WebGL 绘制三角形示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是大剑师兰特：曾是美国某知名大学计算机专业研究生，现为航空航海领域高级前端工程师；CSDN知名博主，GIS领域优质创作者，深耕openlayers、leaflet、mapbox、cesium，canvas，webgl，echarts等技术开发，欢迎加底部微信（gis-dajianshi），一起交流。
No.内容链接1Openlayers 【入门教程】 - 【源代码+示例300+】 2Leaflet 【入门教程】 - 【源代码+图文示例 150+】 3Cesium 【入门教程】 - 【源代码+图文示例200+】 4MapboxGL【入门教程】 - 【源代码+图文示例150+】 5前端就业宝典 【面试题+详细答案 1000+】 文章目录 原生WebGL API用于绘制图形时相对复杂，因为它要求你直接与GPU通信并管理顶点数据、着色器、纹理等。下面是一个使用原生WebGL API来绘制一个简单三角形的基本示例代码。这个例子假设你已经有了一个HTML页面，其中包含一个&lt;canvas&gt;元素。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;WebGL Triangle&lt;/title&gt; &lt;style&gt; body { margin: 0; } canvas { width: 100%; height: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="myCanvas"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.getElementById('myCanvas'); var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); if (!gl) { alert('WebGL not supported.'); return; } // 配置顶点位置数据 var vertices = [ -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2128f2319d361a443b350d168f3b66b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50cea2c708c650cbca786a730b941cc8/" rel="bookmark">
			百度网盘限速解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 开启P2P下载30秒会员下载体验一次性高速下载服务导入“百度网盘青春版”后下载注册新号参与活动 获取下载直链后使用磁力链接下载不是办法的办法无效、已失效方法免限速客户端、老版本客户端、永久会员下载体验试用客户端，或类似脚本、工具获取下载直链后多线程下载 开启P2P下载 操作步骤：
打开百度网盘桌面端。点击右上角的设置按钮。在设置菜单中，点击“传输”选项。在传输设置页面中，找到“优化速率”选项，点击“去开启”按钮。阅读并同意相关协议。选择“优化速率模式”。最后，点击“确定”按钮，完成设置。 注意事项：
百度网盘的“优化速率”选项打开后可以提高下载速度，其本质就是P2P模式，与BT（BitTorrent）下载非常相似，是从其他用户处共享文件（下载其他用户文件，同时也会上传文件给其他用户）。使用该功能需要同意相关的用户协议，确保了解自己的数据使用情况及隐私保护措施。下载速度可能会得到提升，因为下载请求不仅来自百度网盘的服务器，也可能来自其他同时在线并且拥有你所需文件片段的用户。在享受更快下载速度的同时，也需要承担上传数据给其他用户的成本，即部分上传带宽会被占用。下载提速的实际效果会依据下载资源的热门程度、下载的时间段内在线用户数量等因素有所不同。实际效果相差极大，从毫无提升到提升几十兆不等。为了最大化利用P2P下载优势，推荐将百度网盘设置中的下载数量从“智能”调整为最大数。P2P下载模式下一般会遇到“尾部下载变慢”的现象（因为随着下载进度的推进，能够提供剩余文件片段的用户可能变少），但因为有百度网盘服务器的支持，不会出现断流情况。 30秒会员下载体验 以自然天为单位，每天提供1次30秒的会员下载体验，在当天0点更新体验次数。（现在虽然是所谓玩游戏获得会员下载体验，实际上点击后会在百度网盘内打开一个web游戏，并不需要游玩游戏，直接等待会员下载体验时间结束即可关闭web游戏窗口）
30秒会员下载体验是会员级别的高速下载服务，具有满速的下载速度，具体下载速度跟百度资源存储分布、自己的网络带宽情况有关，一般可以达到十几兆的速度（速度还没提升到极限可能就要结束体验开始限速、速率下降）。
由于体验时间较短，建议配合百度网盘的P2P下载，在出现“尾部下载变慢”的现象时，配合使用。推荐将百度网盘设置中的下载数量从“智能”调整为最大数，从而最大化利用高速下载体验服务。 一次性高速下载服务 导入“百度网盘青春版”后下载 百度网盘青春版是下载不限速的，但初始免费空间仅有10G。下载并打开百度网盘青春版，使用和百度网盘同一账号登录。将百度网盘的数据导入到“百度网盘青春版”，然后再下载，即可满速下载。需要注意的是，每人只有3次导入文件的机会，且文件总大小不能超过百度网盘青春版的容量（免费的为10G）。 注册新号参与活动 在浏览器隐身模式下访问百度网盘官网，关注页面引导提示的新用户活动，比如提供7天免费VIP会员且无下载速度限制。
发现类似长期福利活动或新活动后，可以注册新号（使用邮箱即可注册，但是一般需要手机验证）参加活动。
获取下载直链后使用磁力链接下载 使用浏览器插件或者第三方工具来获取百度网盘的真实的下载链接。使用支持磁力链接的专用下载工具来下载该资源。不推荐使用迅雷，虽然它是最常见的支持磁力链接的下载工具，但是它也和百度网盘一样，是对非会员下载限速的重灾区。但是，其他磁力链接下载工具的人气又不行，故种子的热度低导致下载速度本身就很慢。所以，这是一个两难的选择。 迅雷：国内流行下载工具，支持磁力链接等多种下载方式。qBittorrent：开源、免费BT及磁力链接下载器，功能强大，跨平台使用。BitComet：支持磁力链接的P2P下载软件，具备多种高级功能。uTorrent：轻量级BT客户端，适合低资源占用需求。Photon：体积小、速度快的磁力链接下载工具。Aria2：命令行下载工具，高度可配置，支持多种协议。FlashGet：历史上的流行下载器，兼容磁力链接等下载方式。 不是办法的办法 有条件的可以在局域网搭建NAS，然后挂机下载百度网盘资源即可，时间长也没关系。NAS主打一个方便挂机下载，方便局域网内远程使用。
除了专业NAS设备和系统，可以参考该文章对旧手机进行改造：https://blog.csdn.net/zhiyuan411/article/details/121113175#组建NAS网络存储系统/Web服务器
无效、已失效方法 免限速客户端、老版本客户端、永久会员下载体验试用客户端，或类似脚本、工具 百度网盘在服务器端进行了限速，并且会员下载体验也是在服务器端进行校验。所以，客户端这些改动伎俩通通没有实际效果，即使在客户端显示无限速、显示会员体验，都只是自欺欺人而已。
获取下载直链后多线程下载 比如可以获取下载直链后，使用IDM（Internet Download Manager）对该直链进行多线程下载，但是并不会有实际速率提升效果，因为百度网盘在服务器端进行了限速，多线程的速率总和被限制在了100KB/s左右。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6b3567fff7442fbbf609af97674502/" rel="bookmark">
			MySQL Online DDL原理解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 MySQL原生Online DDL是MySQL数据库提供的一项功能，它允许在不中断数据库服务的情况下执行数据定义语言（DDL）操作。
目录 一、背景与意义二、工作机制1. 准备阶段2. 执行DDL操作3. 完成与清理 三、实现原理与优化四、使用场景与优势五、使用约束与注意事项六、锁在Online DDL中的作用ALGORITHM和LOCK选项ALGORITHM选项LOCK选项 如何使用这些选项注意事项 一、背景与意义 在传统的数据库系统中，执行DDL操作时通常需要锁定表，以防止数据不一致。然而，这种锁定会导致表在DDL操作期间不可用，从而影响数据库的可用性。MySQL原生Online DDL解决了这个问题，它允许DDL操作在表仍然可用时执行，大大提高了数据库的可用性，特别是对于需要24/7高可用性的应用来说，这是一个重要的特性。
二、工作机制 MySQL原生Online DDL的工作机制涉及多个步骤和内部原理：
1. 准备阶段 检查与评估：在执行DDL操作之前，MySQL会进行一系列的检查和评估工作。这包括验证DDL操作的语法正确性、检查用户权限以及评估所需资源等。选择执行策略：根据DDL操作的类型和表的结构，MySQL会选择一个合适的执行策略。这通常涉及决定是使用COPY算法、INPLACE算法还是INSTANT算法。 2. 执行DDL操作 COPY算法：
创建临时表：首先，MySQL会创建一个与原始表结构相似的新临时表。数据拷贝：接着，原始表中的数据会被逐行拷贝到新的临时表中。这个过程可能需要一些时间，具体取决于表的大小和系统的性能。重命名与替换：数据拷贝完成后，临时表会被重命名为原始表的名字，从而替换掉原始表。在这个过程中，原始表会被加上写锁，以阻止对数据进行修改，确保数据的一致性。 INPLACE算法：
直接修改：与COPY算法不同，INPLACE算法直接在原始表上进行修改，无需创建临时表和拷贝数据。记录DML操作：在DDL操作执行期间，如果有DML操作（如INSERT、UPDATE、DELETE）尝试修改表，这些操作会被记录下来。应用DML更改：DDL操作完成后，之前记录的DML更改会被应用到表上，确保数据的完整性和一致性。 INSTANT算法：
元数据修改：对于某些简单的DDL操作（如修改表的默认字符集），INSTANT算法可以直接修改数据字典中的元数据，而无需对表数据进行任何更改。无锁操作：由于只修改元数据，因此这种算法可以在不锁定表的情况下完成，实现了真正的“瞬间”完成DDL操作。 3. 完成与清理 释放资源：DDL操作完成后，系统会释放所有在操作过程中分配的资源，如临时表、内存等。更新统计信息：MySQL会更新与表相关的统计信息，以便优化器能够更好地制定查询计划。通知与日志记录：操作完成后，系统会生成相应的日志记录，以便在必要时进行恢复或审计。同时，也可能通过某种机制（如触发器）通知应用程序DDL操作的完成。 MySQL原生Online DDL通过不同的算法和策略来实现在线修改数据库结构的目标，从而提高了数据库的可用性和灵活性。这些工作原理确保了即使在执行DDL操作时，数据库仍然能够处理正常的DML操作，减少了停机时间和维护成本。
三、实现原理与优化 在线DDL的核心实现原理涉及几个关键环节，同时也有一些关键的优化策略：
构建临时表：为了不影响原表的正常读写，系统会创建一个具备新结构的临时表。这一步骤为后续的DDL操作提供了基础。
数据迁移与实时同步：旧表中的数据会被高效地迁移到临时表中，同时确保数据的实时同步。这种迁移策略旨在保障DDL过程中数据的完整性和一致性，避免数据丢失或损坏。
变更追踪与重播：利用日志机制，系统会追踪DDL执行期间旧表上的数据变更，并将这些变更实时重播到临时表中。这一优化确保了数据在DDL操作完成后的准确性。
无缝切换：当DDL操作完成且数据完全同步后，数据库引擎会在合适的时机将临时表提升为新表，从而实现无缝切换。此后，所有的读写操作都将基于新表进行。
四、使用场景与优势 MySQL原生Online DDL适用于多种场景，如添加或删除列、修改数据类型、添加或删除索引等。这些操作都可以在不中断服务的情况下完成，大大提高了数据库的灵活性和可用性。此外，由于Online DDL减少了停机时间，因此也降低了维护成本和数据丢失的风险。
五、使用约束与注意事项 尽管MySQL 5.7的在线DDL带来了诸多便利，但在实际使用中仍需注意以下几点：
操作支持范围：并非所有类型的DDL操作都支持在线执行。某些特定操作可能仍需要锁定整张表，因此在执行前需确认操作类型。
资源占用：DDL操作期间可能会显著增加系统资源的消耗，特别是在数据迁移和同步阶段。因此，在高负载环境下应谨慎规划并执行此类操作。
测试与验证：为确保数据的完整性和业务的连续性，执行在线DDL之前应进行充分的测试和验证。这包括但不限于数据的备份、恢复以及一致性检查等步骤。
六、锁在Online DDL中的作用 在Online DDL过程中，锁主要用于确保数据的一致性。不同类型的锁对表的可访问性有不同的影响：
共享锁（S锁）：允许多个事务读取同一资源，但不允许写入。在Online DDL中，这可能用于允许读取操作继续进行，同时阻止写入操作。排他锁（X锁）：阻止其他事务读取或写入资源。在DDL操作中，如果需要修改表的结构或数据，则可能需要使用排他锁。 ALGORITHM和LOCK选项 在MySQL中，你可以通过ALGORITHM和LOCK关键字来控制DDL操作的行为。
ALGORITHM选项 INPLACE：这个选项指示MySQL直接在原表上进行修改，而不是创建一个新表。这通常可以减少锁的使用和时间，从而提高并发性。但是，并非所有的DDL操作都支持INPLACE算法。COPY：这个选项告诉MySQL创建一个新表，将原表的数据复制到新表中，然后在新表上执行DDL操作。完成后，新表会替换原表。这个过程中，原表通常会被锁定，以防止数据不一致。COPY算法通常需要更多的时间和资源。DEFAULT：如果不指定ALGORITHM选项，MySQL将选择默认的行为。这通常是尝试使用INPLACE算法，如果不可能，则回退到COPY算法。 LOCK选项 NONE：这个选项指示MySQL在执行DDL操作时不要对表加锁（如果可能的话）。但是，如果DDL操作需要保证数据的一致性，MySQL可能会忽略这个选项并加锁。SHARED：允许读取操作继续进行，但阻止写入操作。EXCLUSIVE：阻止读取和写入操作。这是最强的锁类型，用于确保DDL操作期间数据的一致性。 如何使用这些选项 当你想要执行一个DDL操作时，你可以通过添加ALGORITHM和LOCK选项来控制操作的行为。例如：
ALTER TABLE tbl_name ADD COLUMN col_name col_type, ALGORITHM=INPLACE, LOCK=NONE; 这条命令尝试在原地（INPLACE）添加一个新列，并且尽量不使用锁（LOCK=NONE）。但是，需要注意的是，如果MySQL判断无法保证数据的一致性而不使用锁，它可能会忽略这些选项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6b3567fff7442fbbf609af97674502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8597067e074423fe96932b568487b0/" rel="bookmark">
			粒子群优化（Particle Swarm Optimization, PSO）算法 定义&#43;特性&#43;原理&#43;公式&#43;Python示例代码（带注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言定义特性公式原理PSO算法原理简述数学公式速度更新公式位置更新公式 变量解释 应用案例实现步骤与代码示例实现步骤代码示例（Python） 优化和挑战目前的不足改正方法和解决策略 结论 引言 粒子群优化（PSO）算法是一种基于群体智能原理的优化技术，自1995年由Kennedy和Eberhart提出以来，因其简单、高效的特点而在优化领域得到了广泛应用。它模拟自然界中生物群体的社会行为，如鸟类的群飞，来解决优化问题。在PSO中，每个“粒子”代表解空间中的一个候选解，它通过模拟自然界生物的社会合作和信息共享机制进行搜索。粒子在多维解空间中移动，每个粒子都有一个由其位置向量表示的当前位置和一个速度向量控制其飞行方向和距离，这些属性共同决定了粒子搜索解空间的能力和方式。
粒子的行为受到两个主要因素的影响：个体认知和社会认知。个体认知反映了粒子根据自己历史上找到的最优位置（个体最优）进行自我调整的能力；社会认知则是粒子根据整个粒子群历史上找到的最优位置（全局最优）进行调整的能力。通过这种机制，每个粒子在搜索过程中不断调整自己的速度和位置，既能够探索未知的广阔空间，也能够利用群体的经验精确地定位到全局最优解。
PSO算法的关键在于平衡粒子的探索（exploration）和利用（exploitation）行为：探索使粒子能够访问解空间中新的和未知的区域，而利用则使粒子能够在已知的有希望的区域内搜索更精确的解。通过调节粒子速度更新公式中的参数，如惯性权重、个体学习系数和社会学习系数，可以有效地控制这两种行为，从而在多种优化任务中实现高效且可靠的搜索性能。
定义 粒子群优化（PSO）算法被定义为一种群体智能优化技术，它通过模拟鸟群觅食等自然界群体行为来优化数学或工程问题。该算法通过在解空间中随机初始化一群粒子（潜在的解），然后通过迭代寻找最优解。每个粒子具有位置和速度两个属性，它们代表潜在解及其搜索方向和大小。粒子根据自身的经验（粒子在搜索过程中自己发现的最优位置）以及群体的经验（来源于粒子群体中的最优发现）来更新自己的速度和位置，以期找到全局最优解。
特性 群体智能：PSO算法借鉴自然界中生物群体的行为，特别是鸟群觅食的动态。算法中的每个粒子都模拟一个鸟或鱼，通过个体与群体之间的信息共享来指导搜索过程，寻找最优解。
无需梯度信息：不同于需要计算梯度信息的优化算法（如梯度下降法），PSO直接在解空间中通过粒子的位置和速度更新进行搜索，适用于非线性、不可微或梯度难以计算的优化问题。
参数配置简单：PSO算法相比其他优化算法，如遗传算法（GA）或模拟退火（SA），需要调整的参数较少，主要包括粒子数、惯性权重、以及个体和社会学习因子，简化了算法的使用和调优过程。
自适应性：通过调整惯性权重以及个体和社会学习因子，PSO可以在全局搜索和局部搜索之间动态调整，以适应不同的优化问题和搜索阶段，提高搜索效率和解的质量。
易于并行化：PSO的每个粒子相对独立，粒子间的交互主要通过全局最优和个体最优信息实现，使得算法非常适合并行处理，能够有效利用现代多核处理器和分布式计算资源。
鲁棒性：PSO对初始粒子群的设置不敏感，即使在不理想的初始条件下，也能通过迭代寻找到优化问题的有效解，显示出算法的鲁棒性。
简单易实现：PSO算法的实现相对简单，无需复杂的操作如交叉和变异（遗传算法）或复杂的概率分布更新（模拟退火），使得PSO成为解决优化问题的高效且实用的选择。
公式原理 PSO算法原理简述 粒子群优化（PSO）算法通过模拟自然界中鸟群觅食等群体行为来寻找最优解。在PSO中，每个粒子代表潜在解决方案，它们根据个体经验和群体经验更新自己的速度和位置，以探索全局最优解。
数学公式 速度更新公式 粒子的速度更新遵循以下公式：
v i ( t + 1 ) = w ⋅ v i ( t ) + c 1 ⋅ r 1 ⋅ ( p b e s t i − x i ( t ) ) + c 2 ⋅ r 2 ⋅ ( g b e s t − x i ( t ) ) v_{i}^{(t+1)} = w \cdot v_{i}^{(t)} + c_{1} \cdot r_{1} \cdot (pbest_{i} - x_{i}^{(t)}) + c_{2} \cdot r_{2} \cdot (gbest - x_{i}^{(t)}) vi(t+1)​=w⋅vi(t)​+c1​⋅r1​⋅(pbesti​−xi(t)​)+c2​⋅r2​⋅(gbest−xi(t)​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b8597067e074423fe96932b568487b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310f6aa3fb7e1ef944e3fca96cfad544/" rel="bookmark">
			使用QT制作QQ登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mywidget.cpp
#include "mywidget.h" Mywidget::Mywidget(QWidget *parent) : QWidget(parent) { /********制作一个QQ登录界面*********************/ this-&gt;resize(535,415);//设置登录窗口大小 this-&gt;setFixedSize(535,415);//固定窗口大小 this-&gt;setWindowTitle("QQ");//设置窗口标题 this-&gt;setWindowIcon(QIcon("C:/Users/Administrator/Desktop/pictrue/qq"));//设置窗口图标 this-&gt;setStyleSheet("background-color:white");//背景设置成白色 this-&gt;setWindowFlag(Qt::FramelessWindowHint);//隐藏窗口，设置为纯净窗口 QLabel *lab1=new QLabel(this);//动态图标签 lab1-&gt;resize(535,135);//动态标签大小 QMovie *mv=new QMovie("C:/Users/Administrator/Desktop/pictrue/QQ3");//设置一个动态图对象指针接收动态图 lab1-&gt;setMovie(mv);//将动图设置到lab1标签中 mv-&gt;start();//让动图动起来 lab1-&gt;setScaledContents(true);//让图片自适应标签设置大小 QLabel *lab2=new QLabel(this);//qq图标签 lab2-&gt;resize(94,50);//qq标签大小 lab2-&gt;setPixmap(QPixmap("C:/Users/Administrator/Desktop/pictrue/94x50")); lab2-&gt;setScaledContents(true);//让图片自适应标签设置大小 QPushButton *btn1=new QPushButton("？",this);//设置按钮 btn1-&gt;resize(20,20);//设置按钮大小 btn1-&gt;move(440,0);//设置按钮位置 btn1-&gt;setStyleSheet("background-color:rgb(14,114,240)");//设置按钮背景颜色 QPushButton *btn2=new QPushButton("-",this);//设置最小化按钮 btn2-&gt;resize(20,20);//设置按钮大小 btn2-&gt;move(460,0);//设置按钮位置 btn2-&gt;setStyleSheet("background-color:rgb(14,114,240)");//设置按钮背景颜色 QPushButton *btn3=new QPushButton("x",this);//设置退出按钮 btn3-&gt;resize(20,20);//设置按钮大小 btn3-&gt;move(480,0);//设置按钮位置 btn3-&gt;setStyleSheet("background-color:rgb(14,114,240)");//设置按钮背景颜色 QLabel *lab3=new QLabel(this);//qq头像图标签 lab3-&gt;resize(80,80);//qq标签大小 lab3-&gt;setStyleSheet("background-color:rgb(14,114,240)"); lab3-&gt;setPixmap(QPixmap("C:/Users/Administrator/Desktop/pictrue/QQ")); lab3-&gt;move(228,95);//设置头像位置 lab3-&gt;setScaledContents(true);//让图片自适应标签设置大小 QLabel *lab4=new QLabel(this);//账号图标 lab4-&gt;resize(24,36);//标签大小 lab4-&gt;setPixmap(QPixmap("C:/Users/Administrator/Desktop/pictrue/24x36")); lab4-&gt;move(120,220);//设置位置 lab4-&gt;setScaledContents(true);//让图片自适应标签设置大小 QLineEdit *edit1=new QLineEdit(this); //账户输入行编辑器 edit1-&gt;resize(260,24);//设置行编辑大小 edit1-&gt;move(144,225);//设置位置 edit1-&gt;setPlaceholderText("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310f6aa3fb7e1ef944e3fca96cfad544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610f2bdc9a772e3bc81a80da580bef8f/" rel="bookmark">
			Java 插入Mysql 报错：Column count doesn‘t match value count at row 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误通常发生在你尝试向MySQL数据库插入数据时，指定的列数与提供的值的数量不匹配。这种情况可能由以下几个原因引起：
1. 列数与值数量不匹配：确保你插入的数据中，列的数量与你指定的列数是一致的。如果你在INSERT语句中指定了列名，那么你提供的值的数量必须与列名的数量一致，并且顺序要匹配。
例如，如果你有一个表格的结构如下：
CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50), email VARCHAR(100) ); 如果你执行插入操作，你可以这样做：
INSERT INTO users (username, email) VALUES ('john_doe', 'john@example.com'); 注意，这里列出的列名 `(username, email)` 和提供的值 `'john_doe', 'john@example.com'` 是一一对应的。如果你提供的值数量与列名数量不匹配，就会出现“Column count doesn't match value count at row 1”错误。
2. 自动递增列的处理：如果你的表定义了一个自动递增的主键列（比如上述例子中的 `id` 列），在插入数据时不需要为这个列指定值。数据库会自动为你分配一个唯一的值。因此，你在插入时应该忽略这个列，或者在INSERT语句中不包含这个列。
3. 其他错误：有时候，这个错误可能是因为表的定义和你尝试插入的数据之间存在其他的不匹配，比如数据类型不匹配或者NULL值问题。确保插入的数据类型与表定义的类型兼容，并且没有空值约束被违反。
4.也有可能是sql 语法错误 多逗号少逗号的原因
如果你能提供具体的INSERT语句和表结构的信息，我可以帮你更详细地分析可能的问题所在。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99773f0d770a37046050965878dbd1fc/" rel="bookmark">
			机器学习归一化特征编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特征缩放 因为对于大多数的机器学习算法和优化算法来说，将特征值缩放到相同区间可以使得获取性能更好的模型。就梯度下降算法而言，例如有两个不同的特征，第一个特征的取值范围为1——10，第二个特征的取值范围为1——10000。在梯度下降算法中，代价函数为最小平方误差函数，所以在使用梯度下降算法的时候，算法会明显的偏向于第二个特征，因为它的取值范围更大。在比如，k近邻算法，它使用的是欧式距离，也会导致其偏向于第二个特征。对于决策树和随机森林以及XGboost算法而言，特征缩放对于它们没有什么影响。
常用的特征缩放算法有两种，归一化(normalization)和标准化(standardization)。归一化算法是通过特征的最大最小值将特征缩放到[0,1]区间范围
归一化(Normalization) 归一化是利用特征的最大最小值，为了方便数据处理，将特征的值缩放到[0,1]区间，对于每一列的特征使用min-max函数进行缩放，可以使处理过程更加便捷、快速，计算。
特征归一化的优势 提升收敛速度 ：对于线性model来说，数据归一化后，最优解的寻优过程明显会变得平缓，更容易正确的收敛到最优解。 造成图像的等高线为类似椭圆形状，最优解的寻优过程图像如下：
两个特征区别相差特别大。所形成的等高线比较尖锐。当时用梯度下降法时，很可能要垂直等高线走，需要很多次迭代才能收敛。
而数据归一化之后，损失函数的表达式可以表示为：
其中变量的前面系数几乎一样，则图像的等高线为类似圆形形状，最优解的寻优过程图像如下：
对两个原始特征进行了归一化处理，其对应的等高线相对来说比较圆，在梯度下降时，可以较快的收敛。 提升模型精度：如果我们选用的距离度量为欧式距离，如果数据预先没有经过归一化，那么那些绝对值大的features在欧式距离计算的时候起了决定性作用。 从经验上说，归一化是让不同维度之间的特征在数值上有一定比较性，可以大大提高分类器的准确性。 特征归一化方法MinMaxScaler from sklearn.preprocessing import MinMaxScaler x=[[10001,2],[16020,4],[12008,6],[13131,8]] min_max_scaler = MinMaxScaler() X_train_minmax = min_max_scaler.fit_transform(x)#归一化后的结果 X_train_minmax # 它默认将每种特征的值都归一化到[0，1]之间 MinMaxScaler的实现 X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) X_scaled = X_std * (max - min) + min 这是向量化的表达方式，说明X是矩阵，其中
X_std：将X归一化到[0，1]之间X.min(axis=0)表示列最小值max，min表示MinMaxScaler的参数feature_range参数。即最终结果的大小范围
以下例说明计算过程（max=1，min=0） S11=(10001-10001)/(16020-10001)=0 S21=(16020-10001)/(16020-10001)=1 S31=(12008-10001)/(16020-10001)=0.333444 S41=(13131-10001)/(16020-10001)=0.52002 S12=(2-2)/(8-2)=0 S22=(4-2)/(8-2)=0.33 S32=(6-2)/(8-2)=0.6667 S42=(8-2)/(8-2)=1 数据的标准化 和0-1标准化不同，Z-score标准化利用原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。同样是逐列进行操作，每一条数据都减去当前列的均值再除以当前列的标准差，在这种标准化操作下，如果原数据服从正态分布，处理之后的数据服从标准正态分布。Z-Score标准化计算公式如下：
我们也可通过如下方式对张量进行Z-Score标准化处理。 from sklearn.preprocessing import StandardScaler x=[[10001,2],[16020,4],[12008,6],[13131,8]] ss = StandardScaler() X_train = ss.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99773f0d770a37046050965878dbd1fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e4c178724059ba3d9f502548ed2bf2/" rel="bookmark">
			01 Pytorch 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		paddle不需要放数据到gpu！ 区别：1.batch_norlization 不同
2. 1.数据处理 1.取一个数据，以及计算大小
（剩下的工作，取batch，pytorch会自动做好了）
2.模型相关 如何得到结果
3.模型训练/模型验证: 代码剖析 1.配置文件yaml (字典) #参数配置 config = { "train_path":'/kaggle/input/deepshare-playground/train_behaviour.csv', "test_path":'/kaggle/input/deepshare-playground/test_behaviour.csv', "debug_mode" : False, "epoch" : 20, "batch" : 2048, "lr" : 0.001, "device" : 0, } 使用: config[ '名称' ]
train_df = pd.read_csv(config['train_path']) if config['debug_mode']: train_df = train_df[:1000] test_df = pd.read_csv(config['test_path']) 2.处理数据：定义DataSet 关键：len + getitem(获取单独的一个)
#Dataset构造 class BaseDataset(Dataset): def __init__(self,df): self.df = df self.feature_name = ['user_id','item_id'] #数据编码 self.enc_data() def enc_data(self): #使用enc_dict对数据进行编码 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e4c178724059ba3d9f502548ed2bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd98e9139122b9f354c9af80a1fbf28/" rel="bookmark">
			鸿蒙轻内核A核源码分析系列七 进程管理 (3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文记录下进程相关的初始化函数，如OsSystemProcessCreate、OsProcessInit、OsProcessCreateInit、OsUserInitProcess、OsDeInitPCB、OsUserInitProcessStart等。
1、LiteOS-A内核进程创建初始化通用函数 先看看一些内部函数，不管是初始化用户态进程还是内核态进程，都会使用这些函数，包含进程控制块初始化函数OsInitPCB、进程控制块初始化恢复函数OsDeInitPCB
1.1 进程控制块初始化函数OsInitPCB 进程控制块初始化函数OsInitPCB需要3个参数，第一个参数processCB是进程块指针，第二个参数为进程模式mode，分为内核态进程OS_KERNEL_MODE和用户态进程OS_USER_MODE。第三个参数用于设置进程名称。返回值为初始化成功LOS_OK还是失败LOS_ENOMEM。看下代码，⑴处设置进程控制块的信息，用户态进程还是内核态进程，进程状态设置为初始化状态，线程组编号设置为无效值，设置为默认掩码，定时器编号设置为无效值。⑵处初始化进程的双向链表。如果系统配置支持虚拟内存，则执行⑶判断初始化的进程是否为用户态进程，如果是用户态进程，则创建虚拟地址空间，如果创建失败，则把进程状态设置为未使用状态，然后返回错误码。⑷处表示如果是内核态进程，则指定进程的内核进程虚拟地址空间。有关虚拟地址空间的信息，请参考之前的系列文章。
如果执行CPUP特性，则执行⑸处代码，则为CPUP结构体申请内存空间。⑹处，如果开启了LOSCFG_SECURITY_VID，则V初始化ID映射链表。⑺处，如果开启了安全能力LOSCFG_SECURITY_CAPABILITY，则进行相应的初始化。⑻处为进程设置一个名称。
STATIC UINT32 OsInitPCB(LosProcessCB *processCB, UINT32 mode, const CHAR *name) { ⑴ processCB-&gt;processMode = mode; processCB-&gt;processStatus = OS_PROCESS_STATUS_INIT; processCB-&gt;parentProcessID = OS_INVALID_VALUE; processCB-&gt;threadGroupID = OS_INVALID_VALUE; processCB-&gt;umask = OS_PROCESS_DEFAULT_UMASK; processCB-&gt;timerID = (timer_t)(UINTPTR)MAX_INVALID_TIMER_VID; ⑵ LOS_ListInit(&amp;processCB-&gt;threadSiblingList); LOS_ListInit(&amp;processCB-&gt;childrenList); LOS_ListInit(&amp;processCB-&gt;exitChildList); LOS_ListInit(&amp;(processCB-&gt;waitList)); #ifdef LOSCFG_KERNEL_VM ⑶ if (OsProcessIsUserMode(processCB)) { processCB-&gt;vmSpace = OsCreateUserVmSpace(); if (processCB-&gt;vmSpace == NULL) { processCB-&gt;processStatus = OS_PROCESS_FLAG_UNUSED; return LOS_ENOMEM; } } else { ⑷ processCB-&gt;vmSpace = LOS_GetKVmSpace(); } #endif #ifdef LOSCFG_KERNEL_CPUP ⑸ processCB-&gt;processCpup = (OsCpupBase *)LOS_MemAlloc(m_aucSysMem1, sizeof(OsCpupBase)); if (processCB-&gt;processCpup == NULL) { return LOS_ENOMEM; } (VOID)memset_s(processCB-&gt;processCpup, sizeof(OsCpupBase), 0, sizeof(OsCpupBase)); #endif #ifdef LOSCFG_SECURITY_VID ⑹ status_t status = VidMapListInit(processCB); if (status !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbd98e9139122b9f354c9af80a1fbf28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3efef1b574a92ea358a4a42c53123ea/" rel="bookmark">
			MPLS工作过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据层面：
1) 没有 MPLS 协议，基于 FIB 表正常转发即可
2) 名词：MPLS domain——MPLS 的工作半径
edge LSR(PE)——边界标签交换路由器 工作 mpls 域的边缘，连接域外设备 LSR (P)——标签交换路由器 整体工作 MPLS 域内
3) 当流量进入到第一台 pe 设备时，在没有特快交换之前，路由器基于目标 IP 地址查询本地的 RIB；
之后还要在 LIB 表中对应才能确定流量是否应该压入标签，需要两张表的查询；
在存在特快交换时，流量进入第一pe 时，直接査询FIB 表，表中关联标签号，将直接确定是否压入标签；
流量再到P路由器，接收到流量中若存在标签基于 LFIB 表转发，若没有标签基于 FIB 表即可
流量从最后一台边界离开 MPLS 域时将弹出标签；
存在标签号的流量，进入路由器时，入标签表应该为本地路由器分配的编号，出标签为本地的下游(下一跳)设备分配的标签号；上下游的概念基于数据层面进行标定；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e607dbb3332be552faa1054dce3a191/" rel="bookmark">
			redis的分布式session和本地的session有啥区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在web应用开发中，Session用于在多个请求之间存储用户数据。传统上，Session存储在服务器的内存中，即本地Session。然而，随着应用规模和复杂度的增加，特别是在分布式环境中，本地Session会遇到一些问题。这时，Redis等分布式存储系统就显得尤为重要，用于实现分布式Session存储。
1. 存储位置 本地Session：Session数据存储在Web服务器的内存中。每个服务器都自己的Session存储分布式Session（使用Redis）：Session数据是存储在Redis数据库中的，所有服务器共享同一个Redis实例或集群 2. 可扩展性 本地Session：当应用程序负载增加时，需要通过增加更多的服务器来扩展。但由于Session数据只存在于创建它们的服务器上，因此负载均衡需要确保后续请求被路由到同一台服务器（即“粘性会话”），否则会丢失Session数据。分布式Session：所有服务器共享同一个Session存储，因此任何一台服务器都可以处理用户的请求，不需要“粘性会话”。这使得水平扩展变得更加容易和高效。 3. 数据一致性与持久性 本地Session：如果服务器崩溃或重启，保存在其内存中的Session数据将丢失。分布式Session：Redis通常支持持久化机制（如RDB快照、AOF日志），即使Redis实例重启，也可以恢复Session数据。通过配置高可用性（如Redis Sentinel或集群模式），也可以提高数据的可靠性和可用性。 4. 效率与延迟 本地Session：访问本地内存中的Session数据，速度非常快，延迟极低。分布式Session：需要通过网络访问Redis实例，尽管Redis性能很高，但还是比访问本地内存稍慢，并且依赖网络的稳定性。 5. 管理与维护 本地Session：管理相对简单，因为没有外部依赖，但在分布式环境中带来复杂性。分布式Session：需要维护Redis实例或集群，包括配置、监控、备份等。但在分布式环境中，简化了Session管理。 6. 容错能力 本地Session：单点故障。如果服务器宕机，保存在其内存中的Session数据将丢失。分布式Session：可以配置Redis Sentinel或Redis Cluster实现高可用性，即使部分节点故障，Session数据仍然可用。 7. 跨平台与语言支持 本地Session：通常只能在同一种编程语言和Web框架内使用。例如，Java的Servlet API提供的Session对象。分布式Session：通过统一的Redis接口，不同的编程语言和应用程序可以共享同一个Session数据，实现跨平台数据共享。 结论 选择本地Session还是分布式Session取决于具体需求：
对于小型应用或单机部署，本地Session可能更加简单和高效。对于需要横向扩展、高可用性以及跨平台兼容的大型分布式应用，分布式Session（如使用Redis）是更好的选择。 通过Redis实现分布式Session，可以解决Session的一致性、持久性和扩展性问题，特别适合现代云原生和微服务架构的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2741905ac982466e686900ed2a5e15/" rel="bookmark">
			AI Stable diffusion 报错：稳定扩散模型加载失败，退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能是内存不够，看看你最近是加了新的大的模型，可以把你的stable-diffusion-webui\models\Stable-diffusion目录下的某个ckpt删除掉，可能ckpt太大，无法加载成功；
Stable diffusion model failed to load, exiting
如图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150baf2eab9b4ec7322fbc5ba81a4a9a/" rel="bookmark">
			分布式文件存储 - - - MinIO从入门到飞翔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MinIO从入门到飞翔 文章目录 MinIO从入门到飞翔0、前言1、分布式文件系统2、MinIO 介绍3、 MinIO安装（docker）4、基本概念5、通过代码上传文件到MinIO6、封装MinIO为starter7、在其他项目中集成封装好的模块 0、前言 对象存储是一种数据存储架构，设计用于管理和处理大量非结构化数据。与传统的文件存储和块存储不同，对象存储通过将数据分解为离散的、独立的单元或“对象”来存储每个对象包含数据本身、相关的元数据和一个唯一的标识符。
对象存储对比：
存储方式优点缺点服务器磁盘开发便捷，成本低扩展困难分布式文件系统容易实现扩容复杂度高第三方存储开发简单，功能强大，免维护收费 1、分布式文件系统 分布式文件系统（Distributed File System, DFS）是一种文件系统，它使文件可以跨越多个服务器或存储设备存储和访问。DFS 通过网络将多个存储资源组合成一个统一的文件系统，使用户和应用程序可以像访问本地文件一样透明地访问远程文件。
分布式文件系统的关键特性：
透明性：用户和应用程序可以像访问本地文件一样访问远程文件，感受不到底层的复杂性。高可用性：通过复制和冗余机制，确保即使某些节点或硬件发生故障，数据仍然可用。可扩展性：能够处理随着数据量和用户数增加而增长的需求。容错性：通过数据冗余和错误检测机制，保证系统能继续运行，即使发生部分硬件或网络故障。性能：通过分布式架构，能够有效地处理大量并发访问请求。 2、MinIO 介绍 MinIO 是一个高性能的分布式对象存储系统，兼容 Amazon S3 云存储服务，Min10基于Apache License v2.0开源协议的对象存储服务，可以做为云存储的解决方案用来保存海量的图片，视频，文档。它专为大规模存储基础设施设计，能够高效地存储海量非结构化数据，如图片、视频、日志文件等。MinIO 提供了一组简单的 API，用户可以方便地进行数据存储和管理。
官方文档
MinIO 的关键特性
兼容性： 完全兼容 Amazon S3 API，使用户可以使用现有的 S3 客户端和工具。 高性能： 设计为高性能对象存储系统，能够支持每秒数十GB的数据吞吐量。 可扩展性： 支持横向扩展，允许用户通过添加更多的存储节点来扩展存储容量和性能。 简易部署： 提供简单的安装和配置过程，可以在几分钟内启动和运行。 数据保护： 通过纠删码（Erasure Coding）和位衰减（Bit Rot）保护机制确保数据完整性和持久性。 多租户支持： 支持多用户和多租户环境，提供隔离和权限管理。 Kubernetes 集成： 提供原生的 Kubernetes Operator，方便在 Kubernetes 集群中部署和管理 MinIO。 3、 MinIO安装（docker） 如果你有 Docker 环境，可以通过以下命令快速拉取并运行 MinIO 容器：
拉取镜像
docker pull minio/minio 创建容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/150baf2eab9b4ec7322fbc5ba81a4a9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f307e6b7dd517758bb205ce59ffc1b7/" rel="bookmark">
			C&#43;&#43;的封装(十三)：迭代器问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面讨论了linux风格的链表的做法。那个例子没有用到迭代器。现在把它加上:
class list { public: struct node { pair&lt;node*, node*&gt;link; } handle; list() { handle.link.first=handle.link.second=&amp;handle; } ~list() {} public: struct iterator_st { node *p; }; class iterator : iterator_st{ public: iterator operator++(); iterator operator++(int); iterator operator--(); iterator operator--(int) ; bool operator==(iterator it); }; iterator begin(); iterator end(); }; list部分的代码这里就省略了。参见前文&lt;&lt;C++的封装(十一)：linux风格的链表和稀疏矩阵&gt;&gt;https://blog.csdn.net/aaasssdddd96/article/details/139167455。
list需要创建begin()迭代器和end()迭代器。这两个是iterator类逻辑上的构造函数。这就是iterator的对象工厂了。这部分内容在前文&lt;&lt;C++的封装(十二)：外部构造函数&gt;&gt;https://blog.csdn.net/aaasssdddd96/article/details/139551253也讨论过了。list创建迭代器对象需要访问iterator的私有数据，所以iterator类应当声明list为友元。自然，友元不是唯一的办法，只要能解决好访问的问题，友元不友元无所谓了。这里打算用前文&lt;&lt;C++的封装(十)：数据和代码分离&gt;&gt;中讨论的方法来处理这个问题https://blog.csdn.net/aaasssdddd96/article/details/137865098。所以让class iterator 继承了struct iterator_st。这里想说明，在别人的代码里，看到代码不是自己想象的样子，也不用奇怪，因为有各种不同的实现方法。
有了这些之后，就可以给出一个客户化后的遍历的例子:
struct node { int x; list::node node; static struct node *recast(list::node *p) { struct node *q; list::node node::*r= &amp;node::node; reinterpret_cast&lt;int &amp;&gt;(q)= reinterpret_cast&lt;int &gt;(p)- reinterpret_cast&lt;int&amp;&gt;(r); return q; } }; void disp(list &amp;l) { list::iterator it; node *p; for(it=l.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f307e6b7dd517758bb205ce59ffc1b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307c0724e9749c5b2e56e9d53829bd14/" rel="bookmark">
			MATLAB图像增强方法（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对彩色图像office_1.jpg使用两种方法进行增强。
读入MATLAB自带彩色图像office_1.jpg后，发现其图像总体偏暗，图像的对比度不高，因此可以采用对数变换对其低对比度区进行拉伸，增强图像显示效果。还有一种方法可以通过幂次变换对其进行对比度增强。最后对原始图像及、对数变换后的图像和幂次变换后图像进行显示，显示效果表明达到图像增强的目的。
程序代码如下：
%彩色图像增强方法
clear all;
close all;
clc;
I = imread('office_1.jpg');
I_1 = double(I); %将输入图像由uint8类型转换成double类型
s = log(1+I_1); %对数变换
I_2 = mat2gray(s); %将结果标定为[0 1]范围内的double类的数组
max(I_2(:))
min(I_2(:))
J = im2uint8(I_2); %将数组转换成uint8类型的图像
K=double(I);
K_1=sqrt(K); %幂次运算（开根号）
K_2=mat2gray(K_1);
K_3= im2uint8(I_2); figure,
subplot(1,3,1),imshow(I),title('原始图像');
subplot(1,3,2),imshow(J),title('对数变换增强后图像'); subplot(1,3,3),imshow(K_3),title('幂次变换增强后图像');
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd03559446af1a0d2bd84130628333cb/" rel="bookmark">
			写了6年SQL，推荐快速上手MySQL 的SQL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写了6、7年SQL，有写复杂，有写简单，但总体而言，基础是统一的，。就像编程之需要会加减乘除，用MySQL懂这些SQL就足够了。
目录 1. SELECT 查询2. WHERE 子句3. ORDER BY 子句4. GROUP BY 子句5. HAVING 子句6. JOIN 查询7. 子查询8. INSERT INTO 查询9. UPDATE 查询10. DELETE 查询11. LIMIT 子句12. DISTINCT 关键字 MySQL 查询语句是用于从数据库中检索数据的语句。以下是一些常见的 MySQL 查询语句，并附详细说明和示例： 1. SELECT 查询 基本查询
SELECT column1, column2, ... FROM table_name; 示例：
SELECT first_name, last_name FROM employees; 从 employees 表中选择 first_name 和 last_name 字段。
查询所有列
SELECT * FROM table_name; 示例：
SELECT * FROM employees; 从 employees 表中选择所有列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd03559446af1a0d2bd84130628333cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8f85ac743d5282cb3bd90aadbf4a43/" rel="bookmark">
			STL入门指南：从容器到算法的完美结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
一、什么是STL
二、STL的版本
三、STL的六大组件
1. 容器（Containers）：
2. 算法（Algorithms）：
3. 迭代器（Iterators）：
4. 仿函数（Functors）：
5. 配接器（Adapters）：
6. 空间适配器（Allocators）：
四、STL的重要性
五、如何学习STL
六、STL的缺陷
一、什么是STL STL是C++标准模板库（Standard Template Library）的缩写，是C++标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个包罗数据结构与算法的软件框架。
STL提供了一系列通用的模板类和函数，用于实现常见的数据结构和算法，以及提供一些内置类型的封装和操作。
STL的设计目标是提供高效、灵活和易用的数据结构和算法，为C++程序员提供强大的工具来编写高质量的代码。
STL的设计理念是“泛型编程”，通过模板和一些高级的C++特性来提供通用的数据结构和算法，让程序员能够更加方便地编写和使用高效的代码。使用STL可以有效提高代码的开发效率、可维护性和可移植性，同时还能减少程序员编写底层数据结构和算法的工作量。
二、STL的版本 🌳原始版本：
Alexander Stepanov、Meng Lee 在惠普实验室完成的原始版本，本着开源精神，他们声明允许任何人任意运用、拷贝、修改、传播、商业使用这些代码，无需付费。唯一的条件就是也需要向原始版本一样做开源使用。 HP 版本--所有STL实现版本的始祖。 🌳P. J. 版本：
由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不能公开或修改，缺陷：可读性比较低，符号命名比较怪异。 🌳RW版本：
由Rouge Wage公司开发，继承自HP版本，被C+ + Builder 采用，不能公开或修改，可读性一般。 🌳SGI版本：
由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版本。被GCC(Linux)采用，可移植性好，可公开、修改甚至贩卖，从命名风格和编程风格上看，阅读性非常高。 三、STL的六大组件 1. 容器（Containers）： STL提供了多种容器，包括向量（vector）、链表（list）、双端队列（deque）、队列（queue）、栈（stack）、集合（set）、映射（map）等。这些容器提供了不同的数据存储和组织方式，能够满足各种不同的需求。例如，vector提供了动态数组的功能，list提供了双向链表的功能，map提供了键值对的关联。 2. 算法（Algorithms）： STL包含了各种通用的算法，如排序（sort）、搜索（find）、合并（merge）、计数（count）等。这些算法可以直接用于容器上，无需关心具体的容器类型，使得代码具有良好的复用性和泛化性。 3. 迭代器（Iterators）： 迭代器提供了一种统一的访问容器元素的方式，它相当于一个指向容器元素的指针，可以遍历容器中的元素。STL中的算法通常直接操作迭代器，从而实现了算法与容器的解耦，使得算法可以适用于各种不同类型的容器。 4. 仿函数（Functors）： 仿函数是一种重载了函数调用操作符`()`的类对象，它可以像函数一样被调用，常用于算法中作为回调函数使用。STL中很多算法都可以接受一个仿函数作为参数，以实现灵活的数据处理。 5. 配接器（Adapters）： STL提供了一些适配器，如栈（stack）、队列（queue）、优先队列（priority_queue）等，它们是对底层容器的封装和限制，提供了特定的容器接口。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca8f85ac743d5282cb3bd90aadbf4a43/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/269/">«</a>
	<span class="pagination__item pagination__item--current">270/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/271/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>