<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1681b8f2918635ec797455ca7cba5f4/" rel="bookmark">
			Kafka学习-Java使用Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Kafka1、什么是消息队列offset 2、高性能topicpartition 3、高扩展broker 4、高可用replicas、leader、follower 5、持久化和过期策略6、消费者组7、Zookeeper8、架构图 二、安装Zookeeper三、安装Kafka四、Java中使用Kafka1、引入依赖2、生产者3、消费者4、运行效果 前言 Kafka消息中间件
一、Kafka 1、什么是消息队列 假设我们有两个服务：生产者A每秒能生产200个消息，消费者B每秒能消费100个消息。
那么B服务是处理不了A这么多消息的，那么怎么使B不被压垮的同时还能处理A的消息呢，我们引入一个中间件，即Kafka。（当然着并不能使消费者的处理速度上升）
offset 那么我们可以在B服务中加入一个队列，也就是一个链表，链表的每个节点相当于一条消息，每个节点有一个序号即offset，记录消息的位置。
但是这样也会有个问题，还没有处理的消息是存储在内存中的，如果B服务挂掉，那么消息也就丢失了。
所以我们可以把队列移出，变成一个单独的进程，即使B服务挂掉，消息也不会丢失。
2、高性能 B服务由于性能差，队列中未处理的消息会越来越多，我们可以增加更多的消费者来处理消息，相对的也可以增加更多的生产者来生成消息。
topic 但是，生产者与消费者会争抢同一个队列，没有抢到就要等待，那么怎么解决呢？
我们可以将消息进行分类，每一类消息是一个topic，生产者按消息的类型投递到不同的topic中，消费者也按照不同的topic进行消费。
partition 但是单个topic的消息还是有可能过多，我们可以将单个队列拆分，每段是一个partition分区，每个消费者负责一个partition。
3、高扩展 broker 随着partition过多，所有的partition都在同一个机器上，就可能会导致单机的cpu和内存过高，影响性能，那么我们可以使用多台机器，将partition分散部署在不同的机器上。每台机器就代表一个broker。
我们可以增加broker来缓解服务器的cpu过高的性能问题。
4、高可用 replicas、leader、follower 假如某个broker挂了， 那么其中partition中的消息也就都丢失了，那么这个问题怎么解决呢？
我们可以给partition多加几个副本，统称replicas，并将它们分为leader和follower。
leader负责生产者和消费者的读写，follower只负责同步leader的数据。假如leader挂了，也不会影响follower，随后在follower中选出一个leader，保证消息队列的高可用。
5、持久化和过期策略 在上面讲述了leader挂掉的情况，如果所有的broker都挂了，消息不就都丢失了？
为了解决这个问题，就不能只把数据存在内存中，也要存在磁盘中。
但是如果所有消息一直保存在磁盘中，那磁盘也会被占满，所以引入保留策略。
6、消费者组 如果我想在原有的基础上增加一个消费者，那么它只能跟着最新的offset接着消费，如果我想从某个offset开始消费呢？
我们引入消费者组，实现不同消费者维护自己的消费进度。
7、Zookeeper 上面介绍了很多的组件，每个组件都有自己的状态信息，那么就需要有一个组件去统一维护这些组件的状态信息，于是引入了Zookeeper组件，它会定期与broker通信，获取Kafka集群的状态，判断哪些broker挂了，消费者组消费到哪了等等。
8、架构图 二、安装Zookeeper 1、官网地址
https://zookeeper.apache.org/
2、下载
选择稳定版本下载
3、解压，修改配置文件
解压后，复制 zoo_sample.cfg，重命名为 zoo.cfg
修改数据文件目录位置
4、启动
我们是在windows系统下安装的，运行 bin 目录下的 zkServer.cmd
三、安装Kafka 1、官网地址
https://kafka.apache.org/
2、下载
3、解压，修改配置文件
修改 config 目录下 server.properties 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1681b8f2918635ec797455ca7cba5f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f05f2a241eea420e81f0159005c731/" rel="bookmark">
			安卓模拟器Frida环境搭建 （mumu&#43;adb&#43;frida）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓模拟器Frida环境搭建 （mumu+adb+frida） mumu模拟器安装adb与frida下载mumu+adb+frida配置一般的报错实战 针对apk抓包问题，有的时候Android9已经不适用于现在的需求，需要更高的Android版本，mumu模拟器提供了Android12的版本，这里详细说一下配置过程。 mumu模拟器安装 官网地址：https://mumu.163.com/
下载mumu模拟器
选择自定义安装
安装为自己需要的路径
安装好以后先打开mumu模拟器，开始模拟器的root模式，找到设置中心
在其他里面开启root权限
adb与frida下载 adb下载网址：https://adbdownload.com/
frida下载网址：https://github.com/frida/frida/releases
本人电脑是windows所以选择Windows版本进行下载
frida因为需要搭配本地的pip库使用（注意python版本需要大于3.7），所以服务端需要与本地pip版本进行匹配，例如本地下载为16.0.11的版本，找到frida-server-16.0.11-android-x86_64进行下载
在使用frida工具前，需要在python中安装frida
pip3 install frida pip3 install frida-tools 指定版本情况下命令为
pip3 install frida==16.0.11 pip3 install frida-tools ctrl+r，启动cmd
安装frida所需要库
找到自己的python安装目录下的Scripts文件夹，如果出现frida.exe，说明已经安装成功
frida -h验证
mumu+adb+frida配置 将adb解压出来的文件全部放到mumu模拟器下的shell文件夹中，注意是全部
当前目录下启动cmd，然后去mumu模拟器的问题诊断中找到adb调试端口
cmd中运行连接模拟器(注意后面的16384为mumu模拟器的adb调试端口)
adb.exe connect 127.0.0.1:16384 查看连接的设备 adb.exe devices
将下载的frida-server-16.0.11-android-x86_64解压后放到mumu模拟器shell目录下，与adb同一目录，注意一定是解压后的
将frida上传到模拟器下的/data/local/tmp目录
adb.exe push frida-server-16.0.11-android-x86_64 /data/local/tmp 利用adb中的shell连接上模拟器
adb.exe shell 现在是普通用户，我们需要提升到root权限，输入su（注意mumuMonique输入su后会弹窗让你确认权限，一定要允许）
先进入刚才上传的/data/local/tmp目录
cd /data/local/tmp/ 给frida执行权限
chmod 777 frida-server-16.0.11-android-x86_64 运行
./frida-server-16.0.11-android-x86_64 在mumu模拟器shell目录下再启动一个cmd窗口，注意之前那个窗口不能关，关的话frida就下线了，在新启动的命令行中进行端口转发
adb.exe forward tcp:27043 tcp:27043 随便起一个cmd窗口，使用 frida-ps 命令检查frida是否成功开启
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f05f2a241eea420e81f0159005c731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616ebd4b8377fd9c78ebfced159ba165/" rel="bookmark">
			python 处理图片的10个库（非常详细）零基础入门到精通，收藏这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matplotlib
类型: 数据可视化库
功能: 创建线图、柱状图、散点图、直方图、饼图等多种静态图表，支持子图布局、色彩映射、图例、注解等高级定制。
适用场景: 科研论文、报告、数据分析展示。
import matplotlib.pyplot as plt``import numpy as np``x = np.linspace(0, 2 * np.pi, 400)``y = np.sin(x ** 2)``plt.figure(figsize=(8, 6))``plt.plot(x, y)``plt.title('Sine of Squared X')``plt.xlabel('X', fontsize=14)``plt.ylabel('Y', fontsize=14)``plt.grid(True)``plt.show() PIL/Pillow
类型: 图像处理库
功能: 打开、修改、保存多种格式的图像文件，支持像素级操作、裁剪、旋转、缩放、颜色空间转换、滤镜应用等。
适用场景: 基本图像编辑、批处理、Web开发中的图像预处理。
from PIL import Image, ImageDraw, ImageFont``# 创建一个空白图像``img = Image.new('RGB', (500, 300), color='white')``# 创建绘图对象``draw = ImageDraw.Draw(img)``# 写入文字``font = ImageFont.truetype('arial.ttf', size=50)``text = "Hello, World!"``text_width, text_height = font.getsize(text)``draw.text((img.width // 2 - text_width // 2, img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/616ebd4b8377fd9c78ebfced159ba165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e87f451bf0ca95cab644503a4d42e68/" rel="bookmark">
			【数据结构】第五讲：栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：深情秋刀鱼@-CSDN博客
数据结构专栏：数据结构与算法
源码获取：数据结构: 上传我写的关于数据结构的代码 (gitee.com)
目录
一、栈
1.栈的定义
2.栈的实现
a.栈结构的定义
b.初始化
c.扩容
d.入栈
e.出栈
f.打印
g.取栈顶元素
h.判空
i.获取栈中的元素个数
j.销毁
二、队列 1.队列的定义
2.队列的实现
a.队列结构的定义
b.初始化
c.创建节点
d.入队
e.出队
f.队中的元素个数
g.队列判空
h.队列打印
i.取队头元素
j.取队尾元素
k.销毁
一、栈 1.栈的定义 栈是一种特殊的线性表，其只允许在固定的一段进行插入和删除元素的操作。进行数据的插入和删除元素的操作的一端被称为栈顶，另一端被称为栈底。栈中的数据元素遵循后进先出LIFO（Last in First out）的原则。
2.栈的实现 栈的实现一般可以用数组和链表实现，一般情况下用数组实现更为合适，因为在数组尾部进行插入和删除操作的代价较小。
a.栈结构的定义 typedef int STDataType; //定义栈结构（数组） typedef struct Stack { STDataType* a; //数组栈 int top;	//栈顶 int capacity; //容量 }Stack; b.初始化 void STInit(Stack* pst) { assert(pst); pst-&gt;a = NULL; pst-&gt;capacity = 0; pst-&gt;top = -1; } c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e87f451bf0ca95cab644503a4d42e68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef59e762607509b545ad89294054f395/" rel="bookmark">
			sql server修改数据库文件位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：装数据库的时候将文件位置装在了C盘，C盘分的又比较小，每日数据量增加会导致系统崩溃，没有服务端，只有数据库。
注：1.实体机不要在业务时间操作，拔了网线操作是安全有保障的方法-防止有其他连接，数据写入这些。
2.所有操作先搭测试环境多操作几次，然后再在实体机上操作，毕竟数据很重要，备份也非常重要。
3.不要去移动系统数据库（如master,tempdb…这些），不然整个数据库都会用不了
步骤
下面是将数据库从一个路径转移到另一个路径的常见步骤（以ReportServer为例）:
1.备份数据库
在转移数据库之前，我们首先需要备份数据库，以便在出现任何问题时能够恢复数据。可以使用以下T-SQL语句进行数据库备份:
----1.备份
BACKUP DATABASE [数据库名] TO DISK ='D:\Backup\数据库名.bak' [也可以用块设备的方法备份可以看到更多信息 斜体部分不用操作，了解一下]
[
-----设备块备份
–Use 学生成绩管理
–GO
—Exec sp_addumpdevice ‘disk’,‘备份设备01’,‘d:\backup1\学生成绩管理.bak’
备份数据库命令:
—backup database 学生成绩管理 to 备份设备01
还原数据库
—restore database 学生成绩管理from 备份设备01 with replace
注意:在还原数据库时，必须先关闭要还原的数据库]
—2.先将所需更改的数据库的路径先查询出来再进行关闭
USE [数据库名]; GO SELECT name As [Database Name], physical_name As [File Path], type_desc As [File Type],state_desc FROM sys.master_files WHERE database_id= DB_ID(' [数据库名]'); —3.关闭该数据库
USE master; GO ALTER DATABASE [数据库名] SET OFFLINE WITH ROLLBACK IMMEDIATE; GO 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef59e762607509b545ad89294054f395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38a0edd7f4c66d80cc134f73a3d89b5/" rel="bookmark">
			Hadoop核心技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Hadoop？ Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个分布式文件系统（ Distributed File System），其中一个组件是HDFS（Hadoop Distributed File System）。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。 2.了解Hadoop发展历史 3.了解Hadoop特点 Hadoop 是一个能够对大量数据进行分布式处理的软件框架，并且是以一种可靠、高效、可伸 缩的方式进行处理的，它具有以下几个方面的特性。 a.高可靠性，采用冗余数据存储方式，即使一个副本发生故障，其他副本也可以保证正常对 外提供服务
b.高效性，作为并行分布式计算平台，Hadoop 采用分布式存储和分布式处理两大核心技术，能够高效地处理 PB 级
数据。
c.高可扩展性。Hadoop 的设计目标是可以高效稳定地运行在廉价的计算机集群上，可以扩 展到数以千计的计算机
节点上。
d.高容错性。采用冗余数据存储方式，自动保存数据的多个副本，并且能够自动将失败的任 务进行重新分配
e.成本低。Hadoop 采用廉价的计算机集群，成本比较低，普通用户也很容易用自己的 PC 搭建 Hadoop 运行环境,
运行在 Linux 平台上。Hadoop 是基于 Java 语言开发的，可以较好地运行在 Linux 平台上。
支持多种编程语言。Hadoop 上的应用程序也可以使用其他语言编写，如C。
4.Hadoop生态系统 简介： Hadoop生态系统是一个开源的分布式计算平台，由Apache软件基金会开发并维护。其核心组件主要包括HDFS（Hadoop Distributed File System，Hadoop分布式文件系统）、MapReduce以及YARN（Yet Another Resource Negotiator，另一种资源协调者）。这些组件共同构成了Hadoop分布式计算框架的核心，为用户提供底层细节透明的基础框架。
* HDFS是Hadoop的分布式文件系统，旨在在廉价硬件上存储大型文件。它创建数据块的多个副本，并将它们分布在群集中的计算节点上，这种分布方式既可靠又快速。HDFS最适合那些拥有非常大数据集的应用程序，并且具有高容错性和高吞吐量的特点，适合部署在低廉的硬件上。
* MapReduce是用于编写在Hadoop上运行的应用程序的计算模型和软件框架。这些MapReduce程序能够在大型计算节点群集上并行处理大量数据。
* YARN则是另一个关键组件，负责资源管理和作业调度，使得Hadoop能够更有效地处理各种大数据任务。
除了这些核心组件外，Hadoop生态系统还包括许多其他重要的组件，如HBase（分布式数据库）、Hive（数据仓库）、Pig（一种流数据语言和运行环境）、Mahout（机器学习库）、ZooKeeper（分布式协调服务）等。这些组件各自具有独特的功能和用途，共同构成了强大的Hadoop生态系统，使得大数据处理和分析变得更加高效和灵活。
总的来说，Hadoop生态系统为大数据处理和分析提供了强大的支持和便利，使得用户可以更加轻松地处理和分析海量数据，从而挖掘出更多有价值的信息。
5.Hadoop应用场景 等以上场景。 2.Hadoop集群的搭建及配置 1.安装及配置虚拟机 a.创建Linux虚拟机 b.设置固定IP c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a38a0edd7f4c66d80cc134f73a3d89b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b65057ca51400f1f39ea91faf0c5ae8/" rel="bookmark">
			自行搭建rustdesk服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用介绍 RustDesk 是一款可以平替 TeamViewer 的开源软件，旨在提供安全便捷的自建方案。
描述
跨平台支持：RustDesk可以在Windows、Linux、MacOS以及Android等多个平台上使用，为用户提供了极大的便利，无需担心设备兼容性问题。
安全性：它采用了安全的加密传输技术，确保用户数据的安全。在数据传输过程中，RustDesk会对数据进行加密，以防止数据泄露或被篡改。
高性能和低延迟：RustDesk的高性能和低延迟特性使得用户在进行远程操作时几乎感觉不到延迟，大大提高了用户体验。
多功能性：RustDesk支持多屏幕显示，对于需要同时操作多个屏幕的用户来说非常实用。此外，它还支持文件传输、剪贴板共享以及多种连接方式，包括基于IP的连接和基于域名的连接，以满足不同用户的需求。
易用性：相较于其他远程工具，RustDesk无需繁琐配置，用户只需在受控机上安装RustDesk并获取其ID和密码，然后在主控机上输入这些信息，即可快速建立连接。这种简洁的操作方式使得用户无需专业知识即可轻松上手。
灵活性：用户可以选择使用RustDesk的官方服务器或自建服务器，同时，如果用户有自己的云服务器且服务器带宽足够，那么使用RustDesk的体验将会更加流畅。
特性：
随时随地访问任何设备
支持 Windows、macOS、Linux、iOS、Android、Web 等多个平台。
支持 VP8 / VP9 / AV1 软件编解码器和 H264 / H265 硬件编解码器。
完全掌控数据，轻松自建。
P2P 连接，端到端加密。
在 Windows上可以非管理员不安装运行，根据需要在本地或远程提升权限。
操作简单
前期准备 本文将通过Linux宝塔面板Docker部署RustDesk服务器
应用部署 创建应用目录，我的地址/www/server/rustdesk，为了保证后续操作成功，希望与我的目录设置统一。创建docker-compose.yml配置文件，这里我已经帮大家写好了，直接复制修改即可 version: '3' networks: rustdesk-net: external: false services: hbbs: container_name: hbbs ports: - 21115:21115 - 21116:21116 # 自定义 hbbs 映射端口 - 21116:21116/udp # 自定义 hbbs 映射端口 image: rustdesk/rustdesk-server:latest # 注意这里要加:latest，防止docker镜像缓存未更新的问题 command: hbbs -r xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b65057ca51400f1f39ea91faf0c5ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba16749d2c6312819e3f2e506b806a25/" rel="bookmark">
			vue3项目 - Eslint 配置代码风格（保存格式化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一配置文件 1.1 .eslintrc.cjs // @ts-check const { defineConfig } = require('eslint-define-config') module.exports = defineConfig({ root: true, env: { browser: true, node: true, es6: true }, parser: 'vue-eslint-parser', parserOptions: { parser: '@typescript-eslint/parser', ecmaVersion: 2020, sourceType: 'module', jsxPragma: 'React', ecmaFeatures: { jsx: true } }, extends: [ 'plugin:vue/vue3-recommended', 'plugin:@typescript-eslint/recommended', 'prettier', 'plugin:prettier/recommended' ], rules: { 'vue/no-setup-props-destructure': 'off', 'vue/script-setup-uses-vars': 'error', 'vue/no-reserved-component-names': 'off', '@typescript-eslint/ban-ts-ignore': 'off', '@typescript-eslint/explicit-function-return-type': 'off', '@typescript-eslint/no-explicit-any': 'off', '@typescript-eslint/no-var-requires': 'off', '@typescript-eslint/no-empty-function': 'off', 'vue/custom-event-name-casing': 'off', 'no-use-before-define': 'off', '@typescript-eslint/no-use-before-define': 'off', '@typescript-eslint/ban-ts-comment': 'off', '@typescript-eslint/ban-types': 'off', '@typescript-eslint/no-non-null-assertion': 'off', '@typescript-eslint/explicit-module-boundary-types': 'off', '@typescript-eslint/no-unused-vars': 'off', 'no-unused-vars': 'off', 'space-before-function-paren': 'off', 'vue/attributes-order': 'off', 'vue/one-component-per-file': 'off', 'vue/html-closing-bracket-newline': 'off', 'vue/max-attributes-per-line': 'off', 'vue/multiline-html-element-content-newline': 'off', 'vue/singleline-html-element-content-newline': 'off', 'vue/attribute-hyphenation': 'off', 'vue/require-default-prop': 'off', 'vue/require-explicit-emits': 'off', 'vue/html-self-closing': [ 'error', { html: { void: 'always', normal: 'never', component: 'always' }, svg: 'always', math: 'always' } ], 'vue/multi-word-component-names': 'off', 'vue/no-v-html': 'off', 'vue/require-toggle-inside-transition': 'off' } }) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba16749d2c6312819e3f2e506b806a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ffaad9a42e2a076b9025ff524b0bbbf/" rel="bookmark">
			使用ffmpeg.js在Web上实现流媒体处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ffmpeg.js在Web上实现流媒体处理 项目介绍 ffmpeg.js是一个令人惊奇的开源库，它利用Emscripten将FFmpeg编译成JavaScript，使您可以在浏览器中直接运行这个强大的视频和音频处理工具。这个库特别优化了大小和性能，以适应Web环境，并且同样可以在Node环境中工作。
项目技术分析 通过Emscripten编译，ffmpeg.js实现了在JavaScript中的异步操作，包括Web Workers版本，可以将繁重的处理任务移到后台线程，避免阻塞主线程。这个库提供了多个预编译的构建版本，针对不同的编码需求，如WebM和MP4。此外，它还支持多种文件系统类型，包括内存文件系统（MEMFS）。
项目及技术应用场景 ffmpeg.js广泛适用于各种Web开发场景：
在线视频编辑 - 用户可以直接在浏览器中裁剪、合并或转换视频。实时流媒体处理 - 可用于处理WebRTC或其他实时视频流，进行编码、转码或推流。多媒体教学应用 - 在无需下载安装额外软件的情况下，提供视频处理功能。互动游戏 - 实时捕获和处理用户的视频输入。 项目特点 兼容性广泛 - 支持主流的Web浏览器以及Node.js环境。高效性能 - 利用asm.js优化代码，提高执行效率。易用接口 - 提供与原生FFmpeg类似的API，降低学习成本。多版本选择 - 提供针对不同编码需求的独立构建，如WebM和MP4。跨平台 - 由于是基于JavaScript，可以无缝地在不同操作系统上运行。 要开始使用ffmpeg.js，只需简单的npm install ffmpeg.js命令，然后按照项目文档提供的示例代码，即可轻松集成到您的项目中。
总而言之，ffmpeg.js为Web开发者提供了一个强大而灵活的工具，让在Web上处理多媒体变得简单易行。无论是小型项目还是大型应用，它都能成为您多媒体解决方案的重要组成部分。赶紧尝试一下吧，看看它可以为您带来怎样的新可能！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3998222d2632035aa9f1d2c93ba119/" rel="bookmark">
			TEXT2SQL工具vanna本地化安装和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TEXT2SQL工具vanna本地化安装和应用 Vanna和Text2SQL环境安装和数据准备conda虚拟环境安装数据准备ollama环境准备ollama安装和运行ollama下载模型测试下API方式正常使用 chromaDB的默认的embedding模型准备 vanna脚本跑起来 Vanna和Text2SQL TEXT2SQL即文本转SQL，是利用RAG和LLM来实现输入一段文本，系统自动生成SQL，甚至把数据结果用图表的方式展现出来，以下是一些典型的应用实例：
企业数据分析：企业内部的业务分析师或非技术员工可以通过自然语言提问，如“上个季度销售额最高的五个产品是什么？”Text2SQL系统能够自动将此类问题转换为SQL查询，从数据库中提取所需信息，无需手动编写SQL代码，大大提升了数据分析的效率和易用性。 智能客服系统：在客户服务场景中，Text2SQL可以帮助客服机器人理解用户的问题，比如查询订单状态、退换货政策等，并自动执行数据库查询以提供准确的答案，从而提升客服响应速度和服务质量。 个人助理与智能家居：在智能家居或个人助理应用中，用户可以通过语音或文本提出请求，如“明天早上7点提醒我开会”或“显示最近一周的电费消耗情况”，Text2SQL技术能够解析这些请求并转换成数据库查询指令，与家庭自动化系统或个人日程管理系统交互，实现智能化控制和信息反馈。 电子商务平台：电商平台可以利用Text2SQL快速处理用户的商品搜索请求，如“红色高跟鞋尺码37且价格低于500元”，系统自动构建SQL查询，从商品数据库中筛选出符合条件的商品列表。 金融行业报告生成：在金融分析领域，分析师可以提出复杂的需求，如“统计过去一年内公司A的日均交易量并对比行业平均值”，Text2SQL能够帮助自动生成相应的SQL查询，从海量金融数据中提取所需信息，辅助决策制定。 健康医疗信息查询：在医疗信息系统中，医生或研究人员可以通过自然语言查询患者病历、药物信息或疾病统计数据，Text2SQL能够将这些查询转换为SQL，快速检索电子病历系统或医学数据库中的相关记录。 这些场景展示了Text2SQL如何作为自然语言处理和数据库交互的桥梁，简化数据查询流程，提高数据获取的效率和灵活性。随着自然语言处理技术的进步，Text2SQL的应用将会越来越广泛，为跨领域用户提供更加便捷的数据访问方式。
环境安装和数据准备 此处使用私有化的ollama的环境和本地的向量数据库chromaDB和词向量嵌入模型all-MiniLM-L6-v2来搭建本地化环境，并连接到mysql数据库，进行数据分析。
这里使用的是centos7 ，并有一块11G显存的GeForce GTX 1080 Ti，本文编制的时候，使用的是vanna 0.5.4版本。
conda虚拟环境安装 此处默认已经安装了conda环境，创建虚拟环境：
conda create -n vanna -y python=3.9 激活环境
conda activate vanna 安装包，当然ipykernel可以不安装，看需要
pip install 'vanna[chromadb,ollama,mysql]' pip install ipykernel 数据准备 在待连接的mysql数据库的，demodb数据库中新建表和记录，当然可以在不同数据库里面创建表，并插入不同的数据，根据实际情况可以调整SQL，并调整后续步骤的python代码中连接数据库的内容。
CREATE TABLE IF NOT EXISTS vuser ( `id` INT PRIMARY KEY COMMENT '用户ID', username VARCHAR(50) COMMENT '用户名', email VARCHAR(100) COMMENT '电子邮件', age INT COMMENT '年龄', gender VARCHAR(10) COMMENT '性别（男/女）', city VARCHAR(50) COMMENT '城市' ) COMMENT='用户信息表' CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci; INSERT INTO vuser (`id`, username, email, age, gender, city) VALUES (1, '张三', 'zhangsan@example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3998222d2632035aa9f1d2c93ba119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c564c1d45dbe9ba9a9b90bf1f325cd6/" rel="bookmark">
			一眼十行的阅读方法：Kimi Copilot Chrome 插件详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 在信息爆炸的时代，如何快速有效地筛选和摘要网上的海量内容成为了我们每个人的日常挑战。Chrome 用户有福了，一个名为 Kimi Copilot 的新插件，旨在帮助用户高效管理在线内容，无论是文章、视频还是PDF文件。今天，我们将深入探索这一工具的功能、使用场景以及如何改变我们的阅读习惯。
Kimi Copilot 插件的三大核心功能 Kimi Copilot 插件基于 Kimi Chat 强大的 AI 功能，提供了三大核心用途：
文章摘要: 当你面对长篇幅的网络文章，如技术博客或新闻报道时，Kimi Copilot 能够迅速提供文章内容的精确总结，帮助你抓住主要信息，省去阅读全文的时间。视频内容提取: 对于那些视频长度较长，你又不确定是否值得一看的视频，Kimi Copilot 可以预先为你提供视频的概要总结。支持的平台包括 YouTube 和 Bilibili，让你在投入时间之前，就能大致了解视频的价值和内容。PDF文档分析: 对于经常需要阅读PDF文件的用户，如学术研究人员或数据分析师，Kimi Copilot 提供快速总结功能，能够梳理和呈现文档的关键信息和核心数据，极大地提升阅读和研究效率。 实际应用测试 通过实际测试，Kimi Copilot 在处理具体内容时显示出了卓越的性能。无论是对技术博客的快速摘要，还是对最新上线视频的内容提取，亦或是对学术文档的精炼总结，Kimi Copilot 都能提供准确和高效的服务。
特别是在学术文档的处理上，它不仅能标出文档的主要贡献和方法论，还能根据用户的具体需求定制摘要的重点，确保最相关的信息被凸显。
如何安装和使用 Kimi Copilot 安装和使用 Kimi Copilot 非常简单。Chrome 用户可以直接访问 Chrome 网上应用店，搜索 Kimi Copilot，并点击“添加到 Chrome”，即可免费安装。
使用时，用户需要登录到自己的 Kimi Chat 账户，然后就可以在浏览器中直接一键生成内容摘要。无论是浏览新闻、观看教程视频还是研究学术报告，Kimi Copilot 都能为您的网络生活增添效率和便利。
结论与未来展望 Kimi Copilot 插件的出现代表了 AI 在提升网络浏览效率方面的一个重要步骤。随着 AI 技术的不断进步，未来这类工具可能会变得更加智能和个性化，进一步革新我们的信息消费方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f350fae507e20b2d345fc4118d6848/" rel="bookmark">
			vue&#43;onlyOffice&#43;java : 集成在线编辑word并保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.docker部署onlyOffice 1.1拉取最新版onlyOffice镜像 sudo docker pull onlyoffice/documentserver 1.2运行以下命令运行容器 其中 -v 后的第一部分是挂载自己的linux的哪个目录
# 启动docker容器，默认启动端口为80，可以进行修改 docker run -i -t -d -e TZ="Asia/Shanghai" -p 6831:80 --restart=always \ -v /usr/local/docker/document/logs:/var/log/onlyoffice \ -v /usr/local/docker/document/data:/var/www/onlyoffice/Data \ -v /usr/local/docker/document/lib:/var/lib/onlyoffice \ -v /usr/local/docker/document/db:/var/lib/postgresql onlyoffice/documentserver 运行完容器后开始编写代码
2.前端vue代码： 2.1public文文件夹下index.html引入对应的脚本 其中的ip地址和端口改成自己的
&lt;script type='text/javascript' src='http://192.168.59.164:6831/web-apps/apps/api/documents/api.js'&gt;&lt;/script&gt; 2.2 vue组件代码 &lt;!--onlyoffice 编辑器--&gt; &lt;template&gt; &lt;div id='vabOnlyOffice'&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'VabOnlyOffice', props: { option: { type: Object, default: () =&gt; { return {} }, }, }, data() { return { doctype: '', docEditor: null, } }, beforeDestroy() { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f350fae507e20b2d345fc4118d6848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1614ed12ce7749992d9e2dc6c1367a0a/" rel="bookmark">
			Hive大表join大表如何调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、调优思路1、SQL优化1.1 大小表join1.2 大大表join 2、insert into替换union all3、排序order by换位sort by4、并行执行5、数据倾斜优化6、小文件优化 二、实战2.1 场景2.2 限制所需的字段，间接mapjoin2.2 解决异常值倾斜，如NULL加随机数打散2.3 扩容解决数据倾斜2.3.1 客户表扩大N倍2.3.2 部分倾斜key扩容，大卖家扩容2.3.3 推荐：分而治之：倾斜和非倾斜再union all 在Hive中，优化器会根据统计信息决定是将大表放在前面（Join的左边）还是小表放在前面。通常，优化器会选择数据量较小的表作为驱动表（小表作为左边），因为这样可以减少内存消耗并提高效率。 但是，如果你有特定的需求，比如你知道大部分数据能快速过滤掉，希望减少任务的执行时间，那么你可以强制指定某个表作为小表。在Hive中，可以使用/*+ MAPJOIN(table_name) */ 注释来强制将一个大表作为小表处理。
例如，如果你想要将big_table作为小表：
SELECT /*+ MAPJOIN(big_table) */ a.column1, a.column2, b.column1, b.column2 FROM small_table a JOIN big_table b ON a.common_column = b.common_column; 一、调优思路 1、SQL优化 1.1 大小表join 1、mapjoin,小表使用mapjoin,或者强制hint
2、将大表放后头，原因：Hive假定查询中最后的一个表是大表。它会将其它表缓存起来，然后扫描最后那个表。因此通常需要将小表放前面，或者标记哪张表是大表：/*streamtable(table_name) */
3、过滤无效值：空值、不使用的字段等。
4、不能过滤的空值，将空值转化为随机数避免数据倾斜。
1.2 大大表join 1）创建第二张大表 create table bigtable2( id bigint, t bigint, uid string, keyword string, url_rank int, click_num int, click_url string) row format delimited fields terminated by '\t'; load data local inpath '/opt/module/data/bigtable' into table bigtable2; 2）测试大表直接JOIN insert overwrite table jointable select b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1614ed12ce7749992d9e2dc6c1367a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2f76c97e37ee796c5ed4d8691ac7e1/" rel="bookmark">
			无界AI算法总监邹国平：Midjourney领跑，没有标准答案的文生图，下半场还能怎么卷？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入2024，AI应用落地的步伐悄然加速。
AI文生图产品——连接着千行百业的设计需求，极大地压缩了创意实现的周期——正成为快速掘金的AI领域之一。
AI生图自2022年底开始爆发，过去一年多的时间已经让这条赛道变得内卷起来，前有 Midjourney、DALL·E、Stable Diffusion 稳稳占据头部市场，后有GPT4等多模态大模型随时可能抄后路的危险，再加上诸多类似服务的图像编辑及设计工具也在加快融合"文生图"能力，多方都在对这块最稳定的AIGC赛道虎视眈眈。
在激烈的内卷中，文生图玩家想要“出头”，就必须打出自己的特色来。
作为国内最早一批的AIGC产品落地实践者，无界AI算法总监邹国平有着非常深刻的体会。邹国平给出了一个令人意想不到的答案。
破局的关键就在于“场景”：你面向什么样的场景？你擅长什么场景？在这个场景里，你是否能够深耕到一个非常领先的水平？他向我们抛出了这一连串的问题。 在通用AI模型盛行的今天，为什么文生图领域依旧是个很“吃”场景的命题？
追问之下，谜底揭开：文生图看似相对较低的门槛，却建在审美、设计以及专业场景知识的高山之上。AI文生图比文生文更模糊、更没有标准答案。
最近，51CTO直播栏目《AIGC实战派》有幸邀请到了邹国平老师，在两个小时的交流中，他向我们分享了自己在文生图领域的探索心得与洞察，详细探讨了在文生图下半场如何“卷”出技术壁垒。这次交谈，澄清和刷新了原来大众对于文生图领域的”误解“与认知，其中他提出了几个很有意思的观点：
国外文生图产品Leonardo.AI、yodayo等从定位出发逐渐完成差异化，国内还缺少真正领先的产品Midjourney将工程和产品部分托给Disco diffusion平台，保证了探索模型和算法的专注度Midjourney通过广泛的用户接触和使用，已经形成了一套关于如何描述prompt的范式Sora的技术路线将作为我们的一个重要参考，无论是在图像生成还是视频生成的应用提示词与文生图效果的对齐、生成图像时长的压缩和个性化生成将是文生图产品继续跟进的几个方向文生图作为新兴领域，许多B端客户无法给出需求的准确描述，交付过程是个共同探索与改进的过程为了应对千万级流量情况，我们联合了几家GPU厂商，准备了上万规模的GPU资源进行调度。 以下是整理后的对话内容。
1.Midjourney先发优势太“难杀”，国内追平还需多维度发力 51CTO《AIGC实战派》: Midjourney现在是全球范围内公认的用户最多、效果最好的文生图产品之一。在您看来，国内的文生图产品距离Midjourney还有哪些差距？
邹国平: 差距肯定存在。Midjourney无论是用户体量，还是整体营收完全是遥遥领先的。
相比国内的文生图产品Midjourney的先发优势非常大。回顾Midjourney的发展历程，22年的时候，他们就已经进行了两年多的研发积累。刚开始的第一版产品效果也不理想，但他们通过邀请制去招募用户参与到迭代中，持续改进产品。
22年下半年，Stable Diffusion的技术横空出世，给Midjourney的产品带来了一个爆发点。直到迭代至V4版本，已经呈现出行业标杆级的效果。
Midjourney自身有强大的专注度，完全focus在模型和算法探索领域。至于工程和产品的部分，则更多在Disco diffusion平台上去实现，一来节省了不少的开发成本，其次这个平台带有的社群属性，让Midjourney用户持续裂变，通过口口相传沉淀起庞大的用户基础。
51CTO《AIGC实战派》：在Midjourney迭代到V4之前，国内大概在做什么？
邹国平: 更古老一点的，还没有走到文生图这一步。早期所谓的图像生成，更多的是特效及其他特定场景的生成，不是具体物品的成像。
51CTO《AIGC实战派》: Midjourney V4之后领先在哪？
邹国平: V4版本的生成效果非常出色。特别是在特定领域，已经达到了实际可用的状态。Midjourney在数据处理方面有个非常独特之处，无论是数据质量还是数据标注都非常精细。通过广泛的用户接触和使用，已经形成了一套关于如何描述prompt的范式，这些关键词在构图、风格和艺术家风格的表达中起到了关键作用。
51CTO《AIGC实战派》: 我们现在做国内外文生图领域的比较，像您刚才说的模型、提示词，可能基本算是一个追齐的状态？您觉得我们还差在哪里？
邹国平: 在模型层面，一些国内的模型在特定测试集上已经能够与Midjourney的V5.2版本相媲美，但在广泛的用户场景测试中，我们的数据量还远远不够，所以很难精准的去回答“追平”的问题。因为我们所能进行的测试有限，要进行用户测试，让用户用手投票，这样的用户反馈可能仅有几千例。而Midjourney拥有2000万用户。
所以在小范围上去测，那确实可以说国内产品跟他的效果差不多。但如果要推广到所有的场景，确实是会有差距的。
但像Midjourney这样，能做到领先的，目前还是不太能看到。再往下走，每个环节还有很多工作需要补充。
2. Sora不只给方向，还给正在探索DIT的人吃了“定心丸” 51CTO《AIGC实战派》: 今年2月份，sora出现之后，有没有冲击到现在的AI生图领域？
邹国平: 会有影响的。首先像你刚才所说的，视频的确是流量的高地。国内在做Open-Sora项目时，也是按照既能生成视频也能生成图片的思路去做的。两者在技术上有相通之处。
Sora给了这个领域很大的信心。在此之前，基于DIT的尝试已经有一些，只是效果都没能达到实际可用的水平。Sora证明了端到端的视频生成这条路是能走通的。 51CTO《AIGC实战派》: 从Sora在技术报告中公开的那部分来看，能给图像生成领域带来哪些启发或者值得借鉴的地方？
邹国平: 说到方向的话，大家更多是采用DIT技术构建的模型，比如PixArt文生图模型，展示了在少量参数的模型(0.6B)上也能取得良好效果的可能性。
此外，目前的文生图还不足以实现精准控制。因此，引入额外的控制机制，就像PixArt在第二版本中所增加的功能，是完善模型的关键。这些控制可以平滑地集成到现有功能中，提供强大的设计和创造能力。
例如，在汽车设计中，可以将线稿图的规范与文本描述结合，实现更精确的图像生成控制。
51CTO《AIGC实战派》: 抛开Sora，文生图未来可能有哪些比较热的演进方向？
邹国平: 我从文生图领域目前面临的一些主要问题出发来谈谈。
首先，提示词的精准度和生成效果的对齐是一个需要解决的问题。尽管我们可以将提示词写得非常精细，但图像的细节呈现并不总是像文本描述的那样，典型的如手部细节的处理问题。
其次，生成图像的时间压缩也是一个挑战。目前，生成一张图像可能需要数秒的时间，如果加入更多控制，时间可能会更长。因此，工程上需要探索模型蒸馏和加速手段来提升效率。
最后，个性化生成是另一个重要的应用方向，这往往涉及到相关的参考图像。具体到图片生成，目前相似度的稳定性还有待提高，比如处理logo的自由变换时保持其细节不变等等。 51CTO《AIGC实战派》: 您觉得专有的AI生成工具，会不会被类似Sora这种很强大的通用工具吃掉？
邹国平：通用的文生图能力最终可能会被大型模型所覆盖。像GPT-4 Vision这样的模型已经具备了视觉感知能力，能够识别和描述图片内容，但目前还未实现生成或创造能力。语言模型在认知方面已经达到了高水平，但视觉、理解以及创造的过程则更为复杂。
Sora对OpenAI来说，意义是找到了一个通往世界模型的道路。OpenAI的使命和站位让他不会开发非常垂的产品，他们做的是提供一个平台，类似于乐高积木，让用户根据需求自己去搭建想要的应用。
3.文生图要“卷”出技术壁垒，先要从场景出发 51CTO《AIGC实战派》: 都说文生图的创业门槛低，在现在这么卷的情况之下，大家都很好奇技术圈到底是在卷哪块东西？在什么维度还可以打出差异化，还能拼出技术实力、拼出竞争力来？
邹国平: 我们可以看看，现在领先的文生图产品都是怎么做的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e2f76c97e37ee796c5ed4d8691ac7e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea8057be1870488b717ed55803470121/" rel="bookmark">
			解读计数器算法：原理、Java实现与优劣分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计数器算法的介绍 计数器算法的基本原理是通过一个计数器来记录事件的发生次数。每当一个特定的事件发生时，计数器的值就会增加一。当需要检查这个事件发生的次数时，只需要查看计数器的当前值即可。这种方法简单直观，易于理解和实现。
想象一下，在超市的收银台，每当有一个顾客完成结账，收银员就会在计数器上按一次。这样，店主就可以通过查看计数器的值，知道一天中有多少顾客在这个收银台完成了结账。这就是计数器算法的一个生活中的例子。
计数器算法有很多实际的应用场景，比如网络流量控制、系统性能监控、用户行为统计等。在网络流量控制中，计数器算法可以用来限制在一个特定的时间段内，对一个特定的资源的访问次数。这种方法可以有效地防止资源被过度访问，保证系统的稳定性和可用性。
然而，如何在实际的程序中实现计数器算法呢？下一节，我们将通过一个Java的示例，来详细解释如何实现计数器算法。
使用Java实现计数器算法 在我们的Java示例中，我们将实现一个简单的计数器算法。首先，我们需要创建一个类CounterRateLimiter，它包含一个counter变量，用于存储请求的数量。然后，我们将创建一个方法isOverLimit，判断是否超过限流。
import java.util.concurrent.atomic.AtomicInteger; public class CounterRateLimiter { // 最大请求次数　private final int limit; // 计数器　private AtomicInteger counter = new AtomicInteger(0); public CounterRateLimiter(int limit) { this.limit = limit; } /** * 判断是否超过限流　* @return true:超过限流，false:未超过限流　*/ public boolean isOverLimit() { // 如果当前计数器的值已经超过了限制，那么就返回true，表示超过限流　if (counter.get() &gt;= limit) { return true; } else { // 如果当前计数器的值还没有超过限制，那么就让计数器加1，然后返回false，表示没有超过限流　counter.incrementAndGet(); return false; } } /** * 重置计数器　*/ public void reset() { counter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea8057be1870488b717ed55803470121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aca9cfea86334bf4e7f5125f21335c4/" rel="bookmark">
			如何从 Mac 上清空的垃圾箱中恢复已删除的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Mac 上删除的文件将被移至垃圾箱并保留 30 天，然后才会被永久删除。然而，许多 Mac 用户可能会意外清空垃圾箱，而没有意识到其中包含重要文件。本指南包含从清空的废纸篓中恢复 Mac 上已删除文件的所有有效方法。
当您意识到自己不小心清空了 Mac 上的垃圾箱时，请迅速采取行动并停止使用它；继续使用它会使重要文件面临被新数据覆盖的风险，从而使它们几乎无法恢复。
方法 1：使用数据恢复软件恢复 Mac 上清空的废纸篓 使用数据恢复程序是清空垃圾箱后恢复已删除文件的最快方法。奇客数据恢复Mac版是最好的数据恢复软件之一，具有用户友好的界面来执行 Mac 垃圾恢复。
使用 奇客数据恢复Mac版 工具，您可以恢复意外清空Mac上垃圾箱后永久删除的文件，包括照片、文档、视频、档案等。
奇客数据恢复: 支持1000+数据格式恢复免费下载软件扫描数据，支持文件、照片、视频、邮件、音频等1000+种文件的格式恢复更有电脑/笔记本、回收站、U盘、硬盘等各类存储设备数据丢失恢复https://www.geekersoft.cn/geekersoft-data-recovery.html
请按照以下步骤使用数据恢复软件恢复 Mac 上清空的废纸篓：
第 1 步：扫描丢失和删除的文件
启动适用于 Mac 的 奇客数据恢复Mac版 ，然后选择磁盘或垃圾箱文件夹中的其他磁盘。单击“搜索丢失的文件”。
第 2 步：找到被删除的文件
快速深度扫描后，将显示清空的垃圾箱文件夹中已删除的文件。这款强大的数据恢复软件提供过滤功能，帮助您快速找到所需的可恢复文件。
步骤 3：预览并恢复已删除的文件
如果您需要帮助确定需要哪个已删除的文件，请单击眼睛图标预览文件内容。然后单击“恢复”或“全部恢复”按钮从清空的废纸篓中恢复已删除的文件。
有时，您仍然可以在没有软件的情况下恢复清空的垃圾箱。查看以下三种在 Mac 上恢复垃圾箱的方法。
方法 2：从 Time Machine 备份恢复 Mac 上意外清空的废纸篓 macOS 提供了强大的 Time Machine 程序。它可以将您的 Mac 恢复到特定时间，包括其设置和数据。如果您在时间机器中备份了已删除的文件，则可以在清空垃圾箱后恢复它们。以下是您可以参考的步骤：
第 1 步：将 Time Machine 备份磁盘连接到 Mac。
步骤 2：单击顶部菜单中的 Time Machine 图标，然后选择“浏览 Time Machine 备份”选项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aca9cfea86334bf4e7f5125f21335c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7543513060c7e4f8f18ec20e8f84cc/" rel="bookmark">
			AI大模型探索之路-训练篇20：大语言模型预训练-常见微调技术对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-训练篇1：大语言模型微调基础认知
AI大模型探索之路-训练篇2：大语言模型预训练基础认知
AI大模型探索之路-训练篇3：大语言模型全景解读
AI大模型探索之路-训练篇4：大语言模型训练数据集概览
AI大模型探索之路-训练篇5：大语言模型预训练数据准备-词元化
AI大模型探索之路-训练篇6：大语言模型预训练数据准备-预处理
AI大模型探索之路-训练篇7：大语言模型Transformer库之HuggingFace介绍
AI大模型探索之路-训练篇8：大语言模型Transformer库-预训练流程编码体验
AI大模型探索之路-训练篇9：大语言模型Transformer库-Pipeline组件实践
AI大模型探索之路-训练篇10：大语言模型Transformer库-Tokenizer组件实践
AI大模型探索之路-训练篇11：大语言模型Transformer库-Model组件实践
AI大模型探索之路-训练篇12：语言模型Transformer库-Datasets组件实践
AI大模型探索之路-训练篇13：大语言模型Transformer库-Evaluate组件实践
AI大模型探索之路-训练篇14：大语言模型Transformer库-Trainer组件实践
AI大模型探索之路-训练篇15：大语言模型预训练之全量参数微调
AI大模型探索之路-训练篇16：大语言模型预训练-微调技术之LoRA
AI大模型探索之路-训练篇17：大语言模型预训练-微调技术之QLoRA
AI大模型探索之路-训练篇18：大语言模型预训练-微调技术之Prompt Tuning
AI大模型探索之路-训练篇19：大语言模型预训练-微调技术之Prefix Tuning
目录 系列篇章💥前言一、各大语言模型对比1、因果语言模型2、条件生成模型3、序列分类模型4、文生图模型5、图片分类模型6、图生文模型 二、LoRA技术对比1）优点2）缺点 三、P-Tuning V2技术对比1）优点2）缺点 总结 前言 随着人工智能的迅猛发展，自然语言处理（NLP）在近年来取得了显著的进展。大型语言模型（LLMs）在多种NLP任务中展现了卓越的性能，这得益于它们在大规模文本数据集上进行的预训练和随后的微调过程。这些模型不仅能够理解和生成自然语言，还能在特定任务上通过微调达到令人印象深刻的精度和鲁棒性。本文将深入探讨几种重要的预训练模型，并细致比较目前广泛使用的两种先进微调技术——LoRA和P-Tuning V2。我们将从专业角度分析各自的优势和局限性，并提供一个全景视角，以助开发人员和实践者在选择适合其特定需求的微调策略时做出明智的决策。
一、各大语言模型对比 开发人员可以通过Github和Hugging Face平台访问和了解各种由PEFT支持的预训练语言模型。
通过Github平台，开发者可以访问到PEFT的源代码，深入了解其内部工作原理，并参与到模型优化和改进的过程中。此外，Hugging
Face提供的用户友好界面，不仅使得获取由PEFT支持的预训练语言模型变得异常简单，还提供了丰富的文档和教程，帮助开发者快速上手并应用这些模型。
在Hugging Face平台上，开发者可以轻松地浏览各种由PEFT支持的预训练模型，包括它们在不同的自然语言理解任务上的表现。这些模型覆盖了从通用语言理解到特定领域任务的广泛应用，并且通常包含了详细的模型规格、预训练数据来源以及优化策略的描述。
1、因果语言模型 Causal Language Modeling（因果语言模型）主要的任务是根据当前的上下文预测下一个单词。它是一种生成模型，能够生成类似人类的文本。因果语言模型在处理序列数据时，会考虑前面的上下文信息，但是不会看到未来的信息。
例如，给定一句话的前半部分 "The quick brown fox jumps over ...", 因果语言模型的任务是预测接下来可能出现的词，比如 "the"。这个预测是基于给定上下文的条件概率分布来进行的。 这种模型在很多应用中都非常有用，比如机器翻译、语音识别和文本生成等。
2、条件生成模型 Conditional Generation（条件生成）的模型，主要是在给定一定条件或上下文的情况下，生成特定的输出。在自然语言处理中，条件生成模型常常用来生成符合特定条件的文本。
以**机器翻译**为例，给定一个源语言（例如英语）的句子，条件生成模型的任务就是生成目标语言（例如中文）的句子。这里的“条件” 就是源语言的句子，而生成的目标就是目标语言的句子。 又如**文本摘要**任务，给定一个长篇文章，条件生成模型的任务就是生成该文章的摘要。这里的“条件”就是原始的长篇文章，生成的目标就是简短的摘要。
条件生成模型的一个关键特性是它能够根据不同的输入条件生成不同的输出，因此它在许多需要个性化输出的场景中有广泛的应用，如推荐系统、个性化新闻生成等。
3、序列分类模型 Sequence Classification（序列分类）模型的主要任务是对整个序列进行分类。在这个上下文中，序列可以是一系列的单词（文本数据）、声音信号、时间序列数据等。模型的目标是将输入的序列映射到预定义的类别标签上。
一个典型的例子是情感分析任务。在这个任务中，给定一个文本序列（如一句话或一段评论），序列分类模型会判断这段文本的情感倾向，比如将其分类为“正面”、“负面”或“中立”。这里的序列就是文本中的单词序列，而分类的目标是情感倾向的类别。
其他序列分类的例子还包括：
1）垃圾邮件检测：将邮件序列分类为“垃圾邮件”或“非垃圾邮件”。
2）文本主题分类：将新闻文章、科学论文或其他文档分类到预设的主题类别，
如“体育”、“政治”、“科技”等。
3）蛋白质功能分类：将蛋白质序列根据其生物学功能分类到不同的功能类别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd7543513060c7e4f8f18ec20e8f84cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dedbf367c9963bc0f694839591d471e5/" rel="bookmark">
			Llama 3 五一超级课堂中实践llama3的部署，微调，量化优化部署学习总结：第一部分llama3部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次学习分享基于Llama3-Tutorial（Llama 3 超级课堂）分享，git地址如下
GitHub - SmartFlowAI/Llama3-Tutorial: Llama3-Tutorial（XTuner、LMDeploy、OpenCompass）gLlama3-Tutorial（XTuner、LMDeploy、OpenCompass）. Contribute to SmartFlowAI/Llama3-Tutorial development by creating an account on GitHub.https://github.com/SmartFlowAI/Llama3-Tutorial/此外感谢InternStudio提供的大模型实训平台，还有学习群内小伙伴的相互帮助。
llama3-8b对话模型部署
步骤1：conda环境设置，命令如下 conda create -n llama3 python=3.10
conda activate llama3
conda install pytorch==2.1.2 torchvision==0.16.2 torchaudio==2.1.2 pytorch-cuda=12.1 -c pytorch -c nvidia
步骤2：下载已经训练好的llama3的权重 情况1：单独下载：通过从OpenXLab中获取权重
方法：安装 git-lfs 依赖
# 如果下面命令报错则使用 apt install git git-lfs -y
conda install git-lfs
git-lfs install
下载模型
git clone https://code.openxlab.org.cn/MrCat/Llama-3-8B-Instruct.git Meta-Llama-3-8B-Instruct 情况2：软链接 InternStudio 中的模型（用于InternStudio平台）
方法：
ln -s /root/share/new_models/meta-llama/Meta-Llama-3-8B-Instruct ~/model/Meta-Llama-3-8B-Instruct 步骤3：web demo环境部署 部署SmartFlowAI/Llama3-Tutorial
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dedbf367c9963bc0f694839591d471e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b9b6861501e6fcf467cd24205bdfd70/" rel="bookmark">
			web自动化测试（java&#43;selenium）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
使用selenium IDE 插件：
Java中maven项目管理工具：
使用java语言编写自动化测试脚本（selenium webdriver）：
创建maven项目：
引入selenium框架：
安装chrome浏览器驱动：
编写自动化脚本代码：
自动化打开网页：
基本元素定位：
基本元素操作：
webDriver页面相关获取和操作：
三大等待：
特殊元素的定位和操作：
使用selenium IDE 插件： 在浏览器中打开插件，创建测试脚本
使用selenium IDE可以录制一个从打开百度到搜索腾讯课堂的一个脚本文件，点击run可以自动运行
Java中maven项目管理工具： 使用java语言编写自动化测试脚本（selenium webdriver）： 创建maven项目： 引入selenium框架： 在生成的.xml文件中加入selenium框架代码：
&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java --&gt; &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;3.141.59&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 安装chrome浏览器驱动： 自行下载与chrome浏览器版本相匹配的chromedriver
地址：https://chromedriver.chromium.org/downloads
在脚本代码中设正确的置驱动路径：
//设置Selenium WebDriver启动Chrome浏览器时所需的ChromeDriver路径 System.setProperty("webdriver.chrome.driver", "C:\\IDEA\\Maven-project\\java01\\src\\test\\resource\\chromedriver.exe"); 编写自动化脚本代码： 自动化打开网页： public class Test1 { public static void main(String[] args) { openChrome(); } public static void openChrome(){ //设置Selenium WebDriver启动Chrome浏览器时所需的ChromeDriver路径 System.setProperty("webdriver.chrome.driver", "C:\\IDEA\\Maven-project\\java01\\src\\test\\resource\\chromedriver.exe"); //打开浏览器 ChromeDriver chromeDriver=new ChromeDriver(); //访问百度 chromeDriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b9b6861501e6fcf467cd24205bdfd70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a06afee7f1c66922717d33b7303ff6d/" rel="bookmark">
			YOLO在mac上的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、YOLO的安装1.在GitHub上下载源码：2.配置环境： 二、用YOLO测试视频1.测试下载视频2.用电脑自带摄像头实时监测 三、训练自己的数据集 提示：以下是本篇文章正文内容，下面案例可供参考
一、YOLO的安装 1.在GitHub上下载源码： https://github.com/ultralytics/yolov5/tree/v6.1
2.配置环境： 1.将下载好的压缩包保存至一个没有中文的路径下，点击打开PyCharm，点击open按钮，在路径中找到刚刚的源码保存路径，即可在PyCharm中打开项目。
⚠此时可能会跳出一个框，让你配置环境，先直接关掉。（我们后面再配置环境）
2.打开Anaconda，在左侧选择environments，点击下方create，我创建了一个新环境，命名为yolo5_test。（建议选择python3.9与yolov5适配）
3.打开Pycharm设置Preference
新建Python解释器的环境
4.系列库的安装
(1).打开终端，输入命令进入创建的Anaconda环境
conda activate yolov5_test (yolov5_test是我创建的环境名，需换成你的)
(2).配置torch和torchvision
pip install torch==1.8.1 torchvision==0.9.1 torchaudio==0.8.1 (输入后会自动提示适合你的版本，根据提示更改版本号安装即可）
(3).对照requirements.txt 配置其他所需安装包
pip install -r requirements.txt 这里我失败了，于是分别安装
pip install numpy pip install opencv-python pip install matplotlib pip install pillow pip install PyYAM pip install scipy pip install tqdm pip install requests 5.运行程序
基本测试需要运行detect.py
（这里我运行时出现了bug，发现还有一些包未安装，根据提示又安装了缺少的包）
最终在pycharm中运行结果如下
打开exp查看结果
二、用YOLO测试视频 1.测试下载视频 将视频放入yolov5-6.1/data/images/中，在pycharm中运行detect.py
打开yolov5-6.1/runs/detect/exp查看结果代码如下（示例）：
2.用电脑自带摄像头实时监测 在detect文件最后找到此行代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a06afee7f1c66922717d33b7303ff6d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/370/">«</a>
	<span class="pagination__item pagination__item--current">371/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/372/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>