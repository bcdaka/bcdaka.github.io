<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1a2640d9097e600583f5cdbb7acb75/" rel="bookmark">
			Failed to start bean ‘documentationPluginsBootstrapper‘； nested exception is java.lang.NullPointerEx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误提示是Spring Boot应用在启动过程中抛出的，它涉及到了SpringFox，一个用于Spring Boot的开源API文档工具。错误信息表明在启动'documentationPluginsBootstrapper' bean时出现了问题，具体的异常是java.lang.NullPointerException，这是Java中最常见的运行时异常之一，它发生在试图在程序中使用一个尚未初始化（即，值为null）的对象时。
这个问题可能有几个原因：
SpringFox的版本与Spring Boot的版本不兼容。解决这个问题，你可能需要检查你正在使用的SpringFox和Spring Boot的版本，确保它们是兼容的。在你的Spring Boot应用的配置中，可能没有正确地配置SpringFox。例如，如果你没有在你的应用配置文件（如application.properties或application.yml）中添加SpringFox的base-url，这可能会导致这个错误。 以下是一个如何在Spring Boot应用中配置SpringFox的例子：
springfox: documentation: base-url: http://example.com/api/v2/api-docs host: http://example.com path: / spring: profiles: active: ['!docs', '!documenation'] 在这个例子中，base-url是你的API的基础URL，host是整个URL的主机名，path是API文档的路径。spring.profiles.active属性用于定义在哪个profile中激活SpringFox。
3.确保你的项目中包含了SpringFox的依赖。在你的pom.xml文件中，应该有类似以下的依赖：
&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; 如果你的问题依然存在，那么你可能需要查看更详细的错误堆栈信息，以找出问题的具体原因。这可能需要你提供更多的上下文信息，例如你的Spring Boot和SpringFox的具体版本，以及你的应用的配置文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b159d86906ac3461ed7649e3e45171f6/" rel="bookmark">
			【JavaScript】后端返回的二进制流音频数据或本地音频资源，前端如何播放？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、接口设置 // 语音播放 export const getVoicePlay = (content: string) =&gt; { return requestVoice({ url: '/tts/?text_prompt=' + content, method: 'get', responseType: 'blob', // 返回类型blob }); }; 二、数据处理播放 getVoicePlay(item.content).then((res: any) =&gt; { console.log(res); const blob = new Blob([res], { type: 'audio/wav' }); const localUrl = (window.URL || webkitURL).createObjectURL(blob); const audio = document.createElement('audio'); audio.style.display = 'none'; // 防止影响页面布局 audio.controls = true; document.body.appendChild(audio); audio.src = localUrl; audio.playbackRate = 1.3; // 语速 audio.play(); // 语音播放完毕后，需要手动释放内存 audio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b159d86906ac3461ed7649e3e45171f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/187091131850a3aa6a7ad10b46c4879c/" rel="bookmark">
			腾讯云HAI：人人都可无门槛AI作画！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言关于HAIHAI优势开启HAI使用清理资源体验心得结束语参考文献 前言 随着科技的不断进步和数据驱动的时代到来，越来越多的开发者和数据研究人员需要强大的计算能力来支持他们的工作，尤其是在处理大规模数据、进行机器学习和人工智能等高性能应用方面，对GPU算力的需求变得越来越迫切。作为开发者，我觉得在当前人工智能领域火热不减的情况下，会有越来越多高性能应用的诞生，这些高性能应用是建立在强大的数据和算力的处理上的，虽然也有国内外互联网大厂逐步推出自己的GPU算力服务，但是通过体验了一些知名的GPU算力服务，个人觉得腾讯云推出的高性能应用服务用着不错，感觉这个服务就是给开发者量身打造的无需复杂配置、即开即用的GPU云服务平台。那么本文就来详细分享一下笔者的亲身体验过程，以及从使用中的收获，分享给大家。
关于HAI 先来了解一下腾讯云HAI的产品介绍，根据腾讯云官方的介绍，腾讯云高性能应用服务(Hyper Application Inventor，HAI)，是一款面向 Al、科学计算的 GPU 应用服务产品，为开发者量身打造的澎湃算力平台，以确保用户获得最佳性价比。没有复杂的配置，就可以享受即开即用的GPU云服务体验。
在 HAI 中，使用者可以根据应用智能匹配并推选出最适合的 GPU 算力资源，从而保证在数据科学、LLM（Large Language Model）、AI 作画等高性能应用中获得最佳性价比，而且HAI 的一键部署特性可以让使用者在短短几分钟内构建如 StableDiffusion、ChatGLM 等热门模型的应用环境。对于 AI 研究者来说，直观图形界面会大大降低了调试的复杂度，而且支持jupyterlab、webui 等多种连接方式，帮助开发者轻松探索与创新，甚至只需打开浏览器，HAI 便打开了一片无限可能的高性能应用领域！
另外，HAI的应用场景介绍，其实AI绘画是一种利用深度学习算法进行创作的绘图方式，被广泛应用于数字媒体、游戏、动画、电影、广告等领域。等一下会在下面具体使用环节会体现出来。
HAI优势 通过腾讯云官方的介绍，HAI的核心理念是提供澎湃的算力，以满足开发者和数据科学家们在各种高性能应用中的需求，不管是数据科学、LLM还是AI作画，HAI都能根据应用的需求智能匹配并推选出最适合的GPU算力资源，这可以让开发者不再需要担心算力资源的配置和管理，从而可以专注于应用的开发和优化，提高工作效率。除此之外，HAI自身的优势还有很多，比如在简单易用、快速部署、灵活性强、以及丰富的算力种类等等。
1、简单易用 使用前的准备工作非常简单，简化了关于存储等基础设施的配置过程，极大降低了操作和维护管理的复杂程度，真的是简单易用。
2、快速部署能力 HAI的一键部署特性可以让用户在几分钟内构建热门模型的应用环境成为可能，比如StableDiffusion和ChatGLM等热门模型在HAI平台上的一键部署功能使得用户能够快速搭建这些模型的应用环境，省去了繁琐的配置过程，这极大降低了应用部署的时间和成本，而且支持多种AI环境的快速部署。
3、灵活性强 HAI支持用户登录实例的能力，还可以对AI模型和实例环境进行非常灵活的配置，极大方便使用者对复杂的实际情况的需求，尤其是满足很多实际应用场景。
4、丰富算力种类 据悉HAI提供多种算力配套供使用者选择，使用者可以通过HAI服务详情结合自己实际业务需求进行选择合适的算力套餐，而且HAI还在不断更新这种算力种类，尽最大程度的满足各种实际场景的使用。
开启HAI使用 不在过多废话了，直接开启本文的重头戏，关于HAI的使用。在正式开始使用HAI之前，需要进行一些准备工作，待准备工作做好之后，在进行实际的操作体验。
1、前期准备工作 关于腾讯云账号的问题，本文不在赘述。这里只来讲一下，通过腾讯云账号登录之后，打开进入HAI的主页。
登录完账号之后，就是需要进行申请资格。
登录腾讯云账号之后，如未开通，直接点击申请资格 按钮。
然后进入申请详情页，进行基本信息的填写，具体实际项目如下图所示：
提交申请之后，确保无误的时候，然后从控制台进入。
如果申请资格还未审核通过的时候，直接会提示这种信息：
申请中的时候，HAI的控制台会显示如下图所示的图：
申请资格成功之后，会先收到短信提醒，然后再去控制台进入，需要再签署一个同意授权。
申请成功之后，签署协议。
同意授权之后，就进入算力管理控制台了，
然后去新建算力，如下所示：
然后进入新建购买页面，如下所示：
这里我为了操作利用HAI轻松拿捏AI作画，就选择了如下的服务：
购买成功之后，需要短暂等待，
创建成功之后，就显示具体详情了，如下所示：
点击算力列表，进详情，如下所示：
2、使用HAI 进行文生图模型 可以直接进入算力控制界面，5天年假，周日就请假 ，以下可选择两种方式进入。
进入方式一：
进入方式二：
进入之后，打开控制界面，如下所示：
先来汉化一下，使用 高性能应用服务HAI 部署的 StableDiffusionWebUI 配置简体中文语言包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/187091131850a3aa6a7ad10b46c4879c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9d4decefa6cc670f92657e55c7f0a2/" rel="bookmark">
			Jdk17连接zookeeper报错：127.0.0.1/＜unresolved＞:2181
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 dubbo连接zookeeper报错： org.apache.zookeeper.ClientCnxn : Session 0x0 for server 127.0.0.1/&lt;unresolved&gt;:2181, unexpected error, closing socket connection and attempting reconnect
java.lang.IllegalArgumentException: Unable to canonicalize address 127.0.0.1/&lt;unresolved&gt;:2181 because it's not resolvable
问题原因： Zookeeper对象实例化时，会调用InetSocketAddress的toString方法；而在jdk17中，该方法解析空字符串会拼装/&lt;unresolved&gt;
解决方法: 1、更换jdk17为jdk8；
2、升级本机引入的zookeeper依赖，例如3.9.1版本
&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdaecca8ba7d12484a41615ca35ddcaa/" rel="bookmark">
			超详细 | 哈里斯鹰优化算法原理、实现及其改进与利用(Matlab/Python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试函数为F9
在MATLAB中执行程序结果如下：
在Python中执行程序结果如下：
哈里斯鹰优化算法(Harris Hawks Optimization , HHO)是 Heidari等[1]于2019年提出的一种新型元启发式算法，设计灵感来源于哈里斯鹰在捕食猎物过程中的合作行为以及突然袭击的狩猎风格，算法的寻优过程包括探索、探索与开发转换和开发三个阶段。具有需调参数少、原理简单易实现、局部搜索能力强等优点。在数值和工程优化、图像识别、故障诊断、电网优化设计、等工程领域得到广泛的应用。
本文作者将详细介绍其原理、代码实现，并分析可以进行改进的方向。
00 目录 1 哈里斯鹰优化算法（HHO）原理
2 代码目录
3 算法性能
4 算法的改进与利用
5 源码获取
01 哈里斯鹰优化算法（HHO）原理 HHO算法通过模仿哈里斯鹰在捕食猎物过程中的合作行为以及突然袭击的狩猎风格。HHO算法共有三个阶段，全局探索阶段、全局探索向局部开发转换阶段和局部开发阶段。在HHO 算法中，哈里斯鹰的位置被当作为候选解，迭代的最佳候选解为猎物。
1.1 探索阶段
探索阶段，哈里斯鹰种群个体随机栖息在各地，根据其敏锐的眼睛在沙漠空间中跟踪和探测猎物，通过两种策略对猎物进行等概率的全局搜索，P&lt;0.5时，每只鹰会根据其他成员和猎物位置进行移动，P&gt;=0.5时，哈里斯鹰会随机栖息在种群范围内的某棵树上，其表达式如下：
其中， Urand为第t代种群中随机选择的哈里斯鹰个体；Uprey表示猎物位置；Um表示当前哈里斯鹰种群的平均位置；ub, lb分别为搜索范围上限和下限；rand1234和P均为(0,1)区间内的随机数。
1.2 探索与开发转换阶段
HHO算法根据哈里斯鹰捕猎习性将其捕猎过程划分为探索行为和开发行为，猎物在逃跑过程中能量会逐渐降低，因此采用猎物逃逸能量动态选取探索行为或开发行为进行捕猎，猎物逃逸能量定义为：
其中，E0为猎物的初始逃逸能量，是在(-1,1)之间的随机数，t为当前进化代数，M为种群最大进化代数。当|E|&gt;=1时进入探索阶段，|E|&lt;1时进入开发阶段。
1.3 开发阶段
在找到目标猎物后，哈里斯鹰在开发阶段发起攻击，其会在猎物周围形成一圈围攻，等待突然袭击的机会。然而，实际的捕食过程是复杂的，例如，被围困的猎物可能会逃脱包围圈，哈里斯鹰可以根据猎物的行为作出必要的调整。因此，HHO采用四种策略来模仿哈里斯鹰的狩猎行为，这四种策略分别是软包围、硬包围、渐进式快速俯冲的软包围和渐进式快速俯冲的硬包围。
定义Sp为猎物逃逸概率，其为(0,1)之间的随机数，Sp&lt;0.5表示有逃脱机会，结合猎物逃逸能量|E|和猎物逃逸概率Sp确定狩猎策略。
a. 当0.5 ≤ |E| &lt; 1且Sp ≥ 0.5时-软包围
猎物仍然有逃逸的能量，试图通过随机的跳跃逃出包围圈，此时，鹰使用软包围捕食猎物以使其精疲力尽，从而使鹰可以突击突袭，其更新公式为:
其中，ΔU为猎物位置和当前个体位置之差，J~U(0,2)。
b. 当|E| &lt; 0.5且Sp ≥ 0.5时-硬包围
猎物没有逃逸的能量，也没有逃脱的机会，哈里斯鹰使用硬包围捕食猎物以进行最后突击突袭，其更新公式为:
c. 当0.5 ≤ |E| &lt; 1且Sp &lt; 0.5时-渐进式快速俯冲软包围
猎物有机会从包围圈中逃脱，且有足够能量逃脱鹰的捕捉，但是哈里斯鹰会围绕猎物采用渐进式快速俯冲软包围，并根据猎物的欺骗性行为逐渐纠正其位置和方向，从而选择最佳位置来捕捉猎物，通过以下两个策略实施。当第一个策略无效时，执行第二个策略，其更新公式为:
其中，F(.)是适应度函数；S是元素为(0,1)之间d维随机向量；Levy为莱维飞行策略，其公式为：
d. 当|E| &lt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdaecca8ba7d12484a41615ca35ddcaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f42ace1571fc2d11acb98cbff54686/" rel="bookmark">
			ElasticSearch 实现 全文检索 支持（PDF、TXT、Word、HTML等文件）通过 ingest-attachment 插件实现 文档的检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Attachment 介绍 Attachment 插件是 Elasticsearch 中的一种插件，允许将各种二进制文件（如PDF、Word文档等）以及它们的内容索引到 Elasticsearch 中。插件使用 Apache Tika 库来解析和提取二进制文件的内容。通过使用 Attachment 插件，可以轻松地在 Elasticsearch 中建立全文搜索功能，而无需事先转换二进制文件为文本。
优点：
可以将各种类型的二进制文件以原始形式存储在 Elasticsearch 中。这使得保存和访问二进制文件变得更加简单和高效。
插件使用 Apache Tika 库来解析和提取二进制文件的内容，因此可以提取并存储内容、元数据以及格式化的文本数据。这使得 Elasticsearch 可以轻松地对文档执行全文搜索以及文档内容的其他分析操作。
在 Elasticsearch 中使用 Attachment 插件，可以轻松地实现以下一些功能：搜索文档、生成全文搜索报告、自动标记文件、提取数据并进行分析，在文档中查找特定项等。
缺点：
Attachment 插件对性能有一定的影响，因为执行全文搜索需要解析和提取二进制文件的内容。如果处理大量的二进制文件，可能会影响搜索性能。
Attachment 插件有一些限制，例如插件不支持对二进制文件进行过滤或排除，因此如果文件内容包含敏感信息，则不应使用 Attachment 插件进行索引。
二、初始化 ingest-attachment 1、windows安装 1、先在ES的bin目录下执行命令 安装 ngest-attachment插件
elasticsearch-plugin install ingest-attachment 作者已经安装过了 所以不能重复安装，插件下载过程中会出现
2、Liunx安装 通过官网下载，找到对应的版本号：attachment下载网站
下载好后上传到服务器，进入elasticsearch安装目下的bin目录下。
执行sudo ./elasticsearch-plugin install file:///home/ingest-attachment-7.9.0.zip 即可
重启ES 打印 [apYgDEl] loaded plugin [ingest-attachment] 表示安装成功
3、小结 安装完成后需要重新启动ES
接下来我们需要创建一个关于ingest-attachment的文本抽取管道
PUT /_ingest/pipeline/attachment { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25f42ace1571fc2d11acb98cbff54686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad25e0b3472b4060e4989f2622dd68a1/" rel="bookmark">
			RabbitMQ插件详解：rabbitmq_web_stomp【RabbitMQ 六】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的博客，代码的世界里，每一行都是一个故事 《RabbitMQ Web STOMP：打破界限的消息传递之舞》 前言STOMP协议简介STOMP（Simple Text Oriented Messaging Protocol）协议简介STOMP与WebSocket的关系 WebSocket和RabbitMQWebSocket在现代Web应用中的作用RabbitMQ中支持WebSocket的意义 安装和配置rabbitmq_web_stomp插件安装步骤：配置 RabbitMQ 以支持 Web STOMP： RabbitMQ Web STOMP插件的作用和优势1. 实现实时双向通信2. 轻松集成到Web应用3. 解决浏览器同源策略限制4. 支持异构系统集成5. 提升用户体验6. 灵活的消息传递模式 适用场景websockt可以实现，为啥还要引入这个？实现实时消息传递使用 JavaScript 客户端连接到 Web STOMP：发布消息：订阅消息： 应用场景：即时聊天多用户、多房间的即时聊天示例： 总结：结语 前言 RabbitMQ一直是消息传递的先锋，在其众多插件中，rabbitmq_web_stomp无疑是一颗璀璨的明珠。这个插件为我们提供了基于WebSocket的STOMP协议支持，为实现实时、双向通信打开了崭新的可能性。本文将带你进入RabbitMQ Web STOMP的神奇世界，揭开消息传递的新篇章。
STOMP协议简介 STOMP（Simple Text Oriented Messaging Protocol）协议简介 STOMP（Simple Text Oriented Messaging Protocol）是一种用于在应用程序之间进行异步消息传递的简单文本协议。它设计简单、易于实现，是一种基于文本的协议，以简化消息传递的过程。
STOMP协议的特点包括：
简单性： STOMP协议的设计目标之一是简单性，使其易于实现和使用。
文本协议： STOMP基于文本，消息以文本形式进行编码，便于人类可读，并使其易于调试。
协议独立性： STOMP协议是协议独立的，它可以在多种底层传输协议上运行，例如TCP、WebSocket等。
异步消息传递： STOMP协议支持异步消息传递，允许客户端和服务器通过消息进行通信。
STOMP与WebSocket的关系 WebSocket是一种全双工通信协议，它在客户端和服务器之间提供了实时的、双向的通信通道。相比之下，STOMP是一种简单的文本协议，专注于异步消息传递。
WebSocket和STOMP可以一起使用，将WebSocket作为底层传输协议，而STOMP作为消息传递的协议。通过这种组合，可以在Web应用程序中实现实时的、异步的消息传递。
WebSocket提供了一个持久化的连接，而STOMP定义了一种消息传递的格式和协议。这种组合在实时Web应用程序、聊天应用、通知系统等场景中非常有用，使得浏览器和服务器能够进行实时的双向通信。通常，WebSocket用于底层通信，而STOMP用于定义消息的格式和语义。
WebSocket和RabbitMQ WebSocket在现代Web应用中的作用 WebSocket是一种在Web浏览器和服务器之间提供双向通信的协议。相比于传统的HTTP协议，WebSocket在实时性、效率和性能上提供了更好的解决方案。以下是WebSocket在现代Web应用中的一些主要作用：
实时性： WebSocket允许客户端和服务器之间建立持久性的连接，实现实时双向通信。这使得Web应用程序能够及时推送数据，而不需要客户端轮询服务器。
双向通信： WebSocket提供了双向通信的能力，客户端和服务器可以同时向对方发送消息。这对于实时协作、聊天应用、实时数据展示等场景非常有用。
减少网络延迟： 由于WebSocket建立的是持久连接，相比于传统的HTTP请求-响应模型，减少了每次通信都要建立新连接的开销，降低了网络延迟。
降低服务器负担： WebSocket的持久连接使得服务器不再需要处理大量的短暂连接，降低了服务器的负担，提高了服务器的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad25e0b3472b4060e4989f2622dd68a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da176df9138f55ccba87f351c94ed31/" rel="bookmark">
			ai绘画 ai模型对显卡的要求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI是由很多层计算组成的，每一层计算都无差别地计算所有的节点，甚至是对所有的节点的排列组合。由于没有局部性，运行内存需要能够放得下一整个模型至少一层的运算量。如果运行内存不够大，就得把运算好的数据存储起来，放在外存，然后在外存读出没有运算的数据继续算，那这IO就太频繁了，耗时会很大。
以下是AI模型对显卡的要求参数
ai绘画对显卡的要求： 跑AI画图就是跑算法，跑算法依赖GPU，也就是显卡。
显卡一般需要N卡（Nvidia），不建议A卡（AMD）。
最低配置是Nvidia GTX1060（4G显存以上），勉强能跑AI画图，一张20steps步数的图大概30-60秒生成。
建议配置是Nvidia GTX3060，8G以上。一张20steps步数的图大概10-20秒。
当然，土豪建议直接上GTX 3080，GTX4090，那就更快了，几秒一张图，十几秒四张图。
ai训练模型对显卡的要求： 如果你需要本地炼丹（训练模型），跑ControlNet等，那么建议内存16G以上（不含16G），显存12G以上，显卡芯片3060以上（不含GTX 3060）。
Nvidia 用于 AI 模型训练的高端显卡主要包括以下几种: Nvidia Titan RTX: 这是一款最强大的消费级 GPU，具有高达 72 GB 的显存、4608 个 CUDA 核心和 576 个 Tensor 核心，适用于大型模型的训练和推断。Nvidia GeForce RTX 3090: 这是一款针对游戏和内容创作而设计的 GPU，但它也可以用于 AI 模型训练。它包含了 10496 个 CUDA 核心和 328 个 Tensor 核心，适用于大规模的深度学习任务。Nvidia A100: 这是 Nvidia 的最新数据中心 GPU，具有高达 80 GB 的显存、6912 个 CUDA 核心和 432 个 Tensor 核心，适用于最大规模的 AI 模型训练和推断。Nvidia Quadro RTX 6000: 这是一款专业级 GPU，适用于工程、科学、医疗等领域的 AI 模型训练。它包含 4608 个 CUDA 核心和 576 个 Tensor 核心。 Nvidia Tesla V100: 这是一款用于数据中心和高性能计算的 GPU，适用于大规模的 AI 模型训练和推断。它包含 5120 个 CUDA 核心和 640 个 Tensor 核心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f28a0cb635608e9d22ac3fbe57d4bd4f/" rel="bookmark">
			ES常见查询总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1:查询总数2:查询所有数据3:查询指定条数4:根据ID查询5:一个查询字符串搜索6:match搜索7:term搜索8:bool搜索9:must多条件匹配查询10:Should满足一个条件查询11: must_not必须不匹配查询12:多个字段查询内容13:一个字段查询多个内容14:通配符和正则匹配15:前缀查询16:短语匹配17:范围查询18:字段存在查询 1:查询总数 GET demo_person/_count { "query": { "match_all": {} } } 上述用sql表示：
SELECT COUNT(*) FROM demo_person 2:查询所有数据 GET demo_person/_search { "query": { "match_all": {} } } 上述用sql表示：
SELECT * FROM demo_person 3:查询指定条数 GET demo_person/_search { "size": 20, "query": { "match_all": {} } } 上述用sql表示：
SELECT * FROM demo_person LIMIT 20 4:根据ID查询 GET /demo_person/_doc/1?pretty 上述用sql表示：
SELECT * FROM demo_person WHERE _id = '1' 5:一个查询字符串搜索 GET /demo_person/_search?q=last_name:Smith 上述用sql表示：
SELECT * FROM demo_person WHERE last_name = 'Smith' 6:match搜索 这是一个 Elasticsearch 查询语句，用于在索引为 demo_person 中查询 last_name 字段包含 “Smith” 的文档,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f28a0cb635608e9d22ac3fbe57d4bd4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dad3674e3f34c8552067eb7474bb763/" rel="bookmark">
			利用python&#43;whisper生成视频字幕文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.本地环境2.安装所需要的库3.导入相关库4.获取指定路径下的所有视频文件5.导入模型进行音频识别6.将识别结果转换为srt字幕文件7.完成代码 前言 最近在看一些网课，由于没有字幕看着非常费劲，需要全神贯注的去听。网上很多生成字幕的网站都需要收费，想用某映但是它的智能字幕不允许上传大于两小时的视频。
基于这个问题就想着用openai开源的whisper来试试，最终整体的效果还行，硬件不行识别的有点慢，准确率不算高，但是配合音频基本能理解是什么意思，主要看视频更加轻松了。
注：由于我有很多视频，所以才用python自己写脚本批量处理，如不需要或者觉得写脚本麻烦可以看看WhisperDesktop，它识别更快一点，而且资源占用更低
1.本地环境 GPU：GTX 1650 4G
Cuda：10.1
Python：3.8.0
Pytorch：1.7.1
2.安装所需要的库 在已有的python环境上安装openai-whisper、ffmpeg和zhconv，其中zhconv是用来进行简繁体的。
pip install openai-whisper pip install ffmpeg-python pip install zhconv 3.导入相关库 import whisper import os import datetime,time from zhconv import convert # 简繁体转换 from tqdm import tqdm import imageio # 用来获取视频时长 4.获取指定路径下的所有视频文件 # 获取mp4文件列表 def find_files(path,suffix): """ 用来获取path下的所有suffix格式文件 @params: path - Required : 目标路径 (str) suffix - Required : 视频文件格式 (str) """ mp4_files = [] for root, dirs, files in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dad3674e3f34c8552067eb7474bb763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a080144ca38101c4cae98b9211e8e9dc/" rel="bookmark">
			android studio简易app实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一个使用Android Studio创建的简易App实例。这个App包括一个主页面，一个关于页面和一个设置页面。
步骤1：创建新的Android项目
打开Android Studio，点击"File" -&gt; "New" -&gt; "New Project"。在新的对话框中，选择"Empty Activity"，然后点击"Next"。
在接下来的页面中，填写你的应用名称，应用的包名，选择你的项目的位置，选择Java为项目的语言，并选择最低Android版本为Android 4.0。然后点击"Finish"。
步骤2：创建主页面
在主模块的目录下，右键点击"java"，选择"New"，然后选择"Java Class"。在新的对话框中，输入你的新的类的名称（例如MainActivity），然后点击"OK"。
在新的类中，你需要重写onCreate方法。在这个方法中，你可以添加你的应用的布局文件。例如：
import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } } 步骤3：创建关于页面
在主模块的目录下，右键点击"java"，然后选择"New"，再选择"Java Class"。在新的对话框中，输入"AboutActivity"，然后点击"OK"。在这个新的类中，你需要重写onCreate方法。在这个方法中，你可以添加你的关于页面的布局文件。例如：
import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; public class AboutActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_about); } } 步骤4：创建设置页面
在主模块的目录下，右键点击"java"，然后选择"New"，再选择"Java Class"。在新的对话框中，输入"SettingsActivity"，然后点击"OK"。在这个新的类中，你需要重写onCreate方法。在这个方法中，你可以添加你的设置页面的布局文件。例如：
import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; import androidx.preference.PreferenceFragmentCompat; public class SettingsActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a080144ca38101c4cae98b9211e8e9dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b14fd9e49179b43e2d1a6eaf9a5ca7/" rel="bookmark">
			深度比较Python Streamlit和Gradio，谁是真正的利器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多资料获取 📚 个人网站：ipengtao.com
在构建交互式应用时，选择一个合适的库对于提高开发效率和用户体验至关重要。本文将深入探讨两个流行的Python库，Streamlit和Gradio，从特点、使用方法、定制化程度以及部署分享等方面进行详细对比，并通过丰富的示例代码帮助大家更好地理解它们的功能和优劣。
Streamlit详细介绍 1 特点 简单易用： Streamlit以最小化的代码实现最大的功能，对于快速搭建交互应用非常友好。自动化部署： Streamlit支持一键部署到云端，例如Streamlit Sharing，使得分享和部署变得非常便捷。组件丰富： 提供丰富的组件库，如按钮、滑块、图表等，以及对Markdown和HTML的支持，使用户可以灵活构建界面。 2 示例代码 import streamlit as st # 创建一个简单的交互应用 st.title('Streamlit示例应用') # 添加组件 user_input = st.text_input('请输入文本', '默认文本') button_clicked = st.button('点击我') # 显示结果 st.write(f'用户输入: {user_input}') st.write(f'按钮是否被点击: {button_clicked}') Gradio详细介绍 1 特点 多框架支持： Gradio对多种深度学习框架兼容，包括TensorFlow、PyTorch等，使其成为一个强大的模型部署工具。即时预览： 提供即时预览功能，能够在构建过程中实时查看应用效果，有助于快速迭代。快速迭代： Gradio专注于深度学习模型的快速迭代和参数调整，使开发者能够更专注于模型本身。 2 示例代码 import gradio as gr # 创建一个简单的交互应用 iface = gr.Interface( fn=lambda x: x.upper(), inputs="text", outputs="text", live=True, ) # 启动应用 iface.launch() 对比与选择 1 构建简单应用 Streamlit： 适用于构建简单的交互式应用，通过简洁的API，用户可以快速实现基本功能。Gradio： 同样适用于简单应用，提供即时预览功能，方便用户在构建过程中调整和优化。 2 定制化程度 Streamlit： 提供较高的自由度，用户可以通过添加Markdown、HTML等实现更丰富的界面定制。Gradio： 相对而言更专注于深度学习模型的部署，对于模型的输入输出有一定要求，但在这个框架下，用户可以更专注于模型本身的迭代。 3 部署和分享 Streamlit： 通过Streamlit Sharing等服务，用户能够方便地部署和分享应用。Gradio： 提供快速的即时预览，便于开发者在构建过程中查看应用效果。 应用示例 1 Streamlit示例 import streamlit as st import pandas as pd # 读取数据 data = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b14fd9e49179b43e2d1a6eaf9a5ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457ada56dbb1df3617dafd119b7ac3e3/" rel="bookmark">
			AIGC重塑教育：AI大模型驱动的教育变革与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
引言
AI与教育工作者
​教育资源不平衡
引言 AI正迅猛地改变着我们的生活。 根据高盛发布的一份报告，AI有可能取代3亿个全职工作岗位，影响全球18%的工作岗位。在欧美，或许四分之一的工作可以用AI完成。另一份Statista的报告预测，仅2023年，AI就将创造230万个工作岗位，同时消除180万个工作岗位。
教育领域不可避免地受到AI的影响。 国际象棋领域有句名言：“唯有与智者博弈，才能提高。”这也恰好反映了教育的核心：与优秀者互动、交流和学习，才能提升自我。AI作为难以否认的智者，有潜力成为我们的最佳教师。 AI能提供个性化学习方案，有无限的耐心，可帮助学生战胜困难，实现自我提升。这正是教育追求的目标，也是普通教师难以实现的。例如，国际象棋领域已经有许多基于AI的教练系统，如Chess、Lichess、Chessable等。这些系统可以根据每个学生的水平、进步和偏好，提供定制化的训练计划、反馈和建议。它们还可以模拟不同风格和水平的对手，让学生在实战中提高自己的水平。这些系统不仅可以帮助初学者入门，也可以帮助高手进阶，这在以往是不可想象的。
在AI时代，重复性工作削减，这对教育来说意义重大。AI可能严重影响某些行业，譬如翻译将面临巨大挑战。随着谷歌翻译器、百度翻译器等在线翻译服务的发展，人类翻译员将越来越难以与机器竞争。根据一项研究，谷歌翻译器在英语和法语之间的翻译质量已经达到人类水平。人们逐渐意识到，重复性工作可由机器完成，应将精力投入到创新、思考和学习之中，提升自己的独特价值。因此，教育应更注重培养创造力，而非让学生仅服从规则。善于独立思考、敢于突破的人才能在多元化、快速变化的世界中立足。
显然，在AI的影响下，教育工作者应注重培养学生的创造力和独立思考能力，帮助学生树立正确的价值观。库克曾说：“我并不担心AI让计算机像人类一样思考，而是担心人类像计算机一样思考。”这将使我们在AI时代被机器取代。例如，在艺术领域，生成式AI已经能够生成令人惊叹的作品，如DALL·E的图像生成、OpenAI的文本生成、Magenta的音乐生成等。这些作品虽然具有高度的技术性和创造性，但缺乏人类的情感和创造力。因此，教育工作者应该鼓励学生发挥想象力，创造出有意义和有影响力的作品。
AI与教育工作者 那么，有了AI，是否就不再需要专门的教育工作者了呢？是否意味着教育应该消失了呢？事实并非如此。教育的目的、方式和评估将发生巨大变化，但教育本身不会消失。
教育是一项历史悠久的活动，每当新技术出现时，总有人担忧教育工作者的意义。以大学教育为例，尽管广播、电视和互联网的出现都曾让人们质疑大学教育的必要性，但事实上大学教育依然存在，并不断适应着社会环境与发展趋势。因此，当GPT（Generative Pre-trained Transformer，生成式预训练）模型出现时，我们不能简单地认为大学将消亡。相反，教育将变得更公平，知识获取变得更容易。例如，在线教育平台如Coursera、edX、Udemy等提供了丰富的课程资源，让人们可以随时随地学习自己感兴趣或者需要的知识。这些平台不仅降低了学习成本和门槛，也扩大了学习范围和学习深度。通过这些平台，人们可以接触到来自世界各地、各个领域的优秀教师和专家，获得最新、最前沿的知识和技能。
在这个变革过程中，教师将不再仅仅是知识的传递者，而需承担更多角色。他们将成为学生的引导者、辅导员和心灵导师，帮助学生在信息洪流中保持清晰的思维，更好地理解世界，找到自己的兴趣和价值。例如，在MOOC（Massive Open Online Courses，大规模开放在线课程）中，教师不仅要设计有趣、有效的课程内容和活动，还要激发学生的学习兴趣和参与热情。教师还要通过在线论坛、视频会议、小组项目等方式，与学生交流、互动，解答他们的疑问和困惑，给予他们反馈和建议。此外，教师还要关注学生的心理和情感状态，帮助他们克服学习中的障碍，培养他们的自信心和自主学习能力。
教育将更加综合，注重培养学生的创造力、批判性思维和沟通能力。课堂也将从传统的授课方式转变为更加互动的学习环境，让学生充分参与讨论和实践，提高学习兴趣和效果。在STEM（科学、技术、工程、数学）教育中，AI可以提供更多的模拟和实验场景，让学生可以通过动手操作、探索发现、试错反馈等方式，学习基本的概念和原理。AI还可以提供更多的协作和竞争机会，让学生可以通过团队合作、项目制作、比赛评选等方式，锻炼自己的创造力、批判性思维和沟通能力。
同时，教育将不再局限于学校和课堂，而是融入生活的各个方面。随着AI技术的普及，我们可以随时随地获得知识。教育将更注重培养自主学习能力，让我们在快速发展的世界中保持竞争力。在日常生活中，我们可以通过智能手机、智能音箱、智能眼镜等设备，与AI进行语音或者图像交互，获取我们需要或者感兴趣的信息。我们还可以通过AI来管理自己的时间、任务、健康等，提高效率和生活品质。在工作中，我们可以通过AI来协助完成一些复杂或者重复的工作，提高工作的准确性和效率。我们还可以通过AI来获取最新、最相关的知识和技能，提高专业性和竞争力。
教育资源不平衡 此外，AI将有助于解决教育资源不平衡问题，让更多人享受到优质教育。借助AI技术，我们可以打破地理和语言障碍，让知识和资源在全球范围内自由流动。这将提高全球教育水平，减少教育不平等现象，让更多人获得更好的发展机会。在发展中国家或者偏远地区，由于缺乏合格的教师和设施，很多孩子无法接受基础教育或者高质量教育。通过AI技术，我们可以为这些孩子提供远程教育或者智能辅导，让他们可以接触到优秀的教师和内容，并且根据自己的进度和水平进行个性化学习。AI提供的多语言翻译或者语音识别等功能，还可以让他们跨越语言障碍，与来自不同国家或者具有不同文化背景的人进行交流、合作。
在AI不断渗透到各行各业的时代，教育领域也正在经历一场变革。这不仅重塑了学习者的学习方式，也改变了家长和教育工作者的角色。本书就是在这样的大背景下应运而生的，试图解答一个关键问题：如何在AI浪潮中找到最佳教育策略，保障孩子们在未来社会的竞争力？
我坚信，家长的理解、接纳与参与是孩子们顺利适应AI时代不可或缺的一环。AI可能会让许多人感到不安或恐惧，但通过深入了解其运作机制和可能的影响，相信我们可以将恐惧转化为力量。为此，本书详细解析了AI在教育中的具体应用，以及AI对学习方式的深远影响。
未来的教育中，家长将从传统的孩子和学校的桥梁角色，转变为孩子学习的合作伙伴。家长们需要以新的眼光看待教育，视其为一个终身的、无处不在的过程，并把AI视作这个过程中的重要辅助工具。
希望通过《AIGC重塑教育》这本书，家长能深入理解并掌握在AI时代帮助孩子学习的策略，确保他们能够积极面对AI带来的机遇和挑战，同时避免其潜在的风险。只有全社会共同参与，我们才能充分挖掘AI的潜力，构建一个更加美好的教育环境
《AIGC重塑教育》限时限量5折特价中 点击上方卡片立即下单 推荐语 领跑ChatGPT时代教育和学习行动指南 全面助力教师、家长、学生在未来竞争中遥遥领先 高途教育科技集团大学生业务总经理刘文勇撰写 多位教育家、企业家鼎力推荐 配套视频讲解，持续更新AIGC领域前沿知识 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab5f4887d451e25cb900debf5e31819/" rel="bookmark">
			SpringBoot项目整合达梦数据库（MYSQL 转换 达梦数据库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、达梦数据库的安装和使用
1、达梦数据库下载
2、Windows环境安装达梦数据库
二、MYSQL数据库 迁移至 达梦数据库
1、DM控制台工具：Console
2、DM数据迁移工具：DTS
三、Spring项目整合达梦数据库
1、配置java项目连接达梦，切换数据连接驱动
2、Maven导入达梦数据库驱动包
3、表的实体类映射。【访问形式：模式名.表名】
4、XML文件：查询表【模式名.表名】
​5、MYSQL字段类型与DM数据类型的转换。【DM：达梦数据库】
6、达梦数据库分页插件
7、SQL适配关键字列名
一、达梦数据库的安装和使用 1、达梦数据库下载 产品下载 | 达梦数据库
2、Windows环境安装达梦数据库 参考文章： Windows环境安装达梦数据库_达梦数据库安装-CSDN博客
二、MYSQL数据库 迁移至 达梦数据库 参考文章：MySQL数据迁移至达梦数据库_mysql迁移达梦-CSDN博客
在安装的tool目录下，查找相关的工具：
1、DM控制台工具：Console 服务器配置又该有两种方式：①DM控制台工具修改；②配置文件修改。
方法一：服务器配置：设置系统兼容性(DM控制台工具），兼容MySQL
方法二：（1）查找dm.ini文件
（2）dm.ini修改【#compatibility】的【COMPATIBLE_MODE】=4
(3)重启Dameng服务
2、DM数据迁移工具：DTS 在这里操作：MYSQL数据库迁移至DM数据库
注意：当迁移过程中出现下面问题时，如有触发器或者外键,需要先关掉触发器和外键,然后进行迁移,不然会导致迁移失败。
MYSQL的数据表转换成DM的数据表时，点击转换按钮。如下：
设置【1：迁移策略选项】 设置【2：列映射选项】 3、添加用户：如果导入的DM数据库需要和MYSQL的用户一样，添加ROOT用户。
三、Spring项目整合达梦数据库 1、配置java项目连接达梦，切换数据连接驱动 2、Maven导入达梦数据库驱动包 3、表的实体类映射。【访问形式：模式名.表名】 4、XML文件：查询表【模式名.表名】 5、MYSQL字段类型与DM数据类型的转换。【DM：达梦数据库】 package com.company.common.core.annotation; /** * 数据库类型 * * @author kally * @date 2023/12/13 */ public enum DbType { /** * 数据库类型（类型，描述） */ MYSQL("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ab5f4887d451e25cb900debf5e31819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb0ad226dfcb03ea3e239aca8934169/" rel="bookmark">
			基于jsp的图书馆管理系统的设计与实现 （含源码&#43;sql&#43;视频导入教程&#43;文档）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉文末查看项目功能视频演示+获取源码+sql脚本+视频导入教程视频 1 、功能描述 基于jsp的图书馆管理系统8拥有两种角色，分别为管理员和学生，具体功能如下：
管理员：图书管理、用户管理、违规处理、权限管理、个人信息修改
学生：借阅图书、归还图书、借阅历史、处罚记录、个人信息修改
1.1 背景描述 图书馆管理系统是一种针对图书馆设计的软件系统，旨在简化和改进图书馆资源的管理、借阅和归还流程。该系统通常包括图书信息管理、借阅记录跟踪、预约服务、罚款管理以及读者信息管理等功能。通过该系统，图书管理员能够更有效地管理图书馆藏书，包括采购、编目和库存管理，同时帮助读者更便捷地查找并借阅所需图书。此外，系统还提供了自助借还书服务，缩短了借书排队时间，提高了用户体验。一些系统还整合了电子书馆功能，允许用户在线阅读或下载电子书籍。另外，通过数据分析功能，系统可以为图书馆提供借阅趋势、流行书籍等信息，帮助图书馆优化资源配置。图书馆管理系统的使用不仅提高了图书馆工作效率，也为读者提供了更便捷的服务，促进了图书馆的数字化发展。
2、项目技术 后端框架： Servlet、mvc模式、Javabean
前端框架：Layui、jsp、css、JavaScript、JQuery
2.1 MVC MVC（Model-View-Controller）框架是一种用于构建Web应用程序的软件架构模式。它将应用程序分为三个核心部分：模型（Model）、视图（View）和控制器（Controller）。模型负责处理数据逻辑，包括数据库交互、数据处理和业务规则。视图负责用户界面的呈现，将数据以易于理解的形式展示给用户。控制器充当中间人，接收用户输入并调用相应的模型和视图来完成用户请求。MVC框架使代码分离，提高了应用程序的可维护性和扩展性。开发人员可以独立地修改模型、视图或控制器，而不会影响其他部分。这种分离也有助于多人合作开发项目。MVC框架还促进了前后端的分离，使前端工程师和后端工程师能够更好地协同工作，从而提高了开发效率。
2.2 mysql MySQL是一款Relational Database Management System，直译过来的意思就是关系型数据库管理系统，MySQL有着它独特的特点，这些特点使他成为目前最流行的RDBMS之一，MySQL想比与其他数据库如ORACLE、DB2等，它属于一款体积小、速度快的数据库，重点是它符合本次毕业设计的真实租赁环境，拥有成本低，开发源码这些特点，这也是选择它的主要原因。
3、开发环境 JAVA版本：JDK1.8，其它版本理论上可以IDE类型：IDEA、Eclipse、Myeclipse都可以。推荐IDEA与Eclipsetomcat版本：Tomcat 7.x、8.x、9.x、10.x版本均可数据库版本：MySql 5.xmaven版本：无限制硬件环境：Windows 或者 Mac OS 4、功能截图+视频演示+文档目录 4.1 登录与注册 学生可以通过上述界面登录、注册，注册后会自动分配ID号
4.2 学生模块 借阅图书：学生可以通过关键字模糊查询图书信息，然后借阅图书。借阅图书时，需要判断该学生现已借阅的图书数量，若超过3本，则暂时不能借书；若尚有未缴纳罚金，暂时不能借书；否则点击“确认借阅 ”，即完成借阅。
归还图书：学生可以通过书号归还图书，以及查看当前借书信息
借阅历史：学生可以查看借阅图书历史记录，包括当前已借阅的图书和已归还的图书，记录内容包括读者id、书籍信息和借阅的开始日期以及结束日期；若书籍尚未归还，“结束日期”后会显示“尚未归还”
处罚记录：学生可以查看自己的违规记录，如若相关书籍仍未进行线下归还且学生也未缴纳罚金，则提示尚未缴纳罚金；否则显示该条借阅记录的超期天数。
个人信息修改：学生可以修改个人信息，包括修改姓名、密码、性别、电话等，其中用户id不可修改。
4.3 管理员模块 图书管理：管理员可以通过关键字模糊查询图书信息，还可以对图书进行增加、删除、修改等操作
用户管理：管理员可以通过ID号和姓名查询学生信息，并对学生进行增加、删除、修改等操作，若“黑名单”功能被启用，可以点击“加入黑名单”、“移除黑名单”来控制用户的登录权限。
违规处理：管理员可以根据学生ID查询其违规记录，并缴纳罚款，用户缴纳罚款后，可点击“缴纳罚款”，撤销对该生的处罚，恢复其正常借阅和归还权利；
权限管理：管理员可以设置最长借阅天数和是否开启黑名单功能
个人信息修改：管理员可以个人信息
4.4 项目设计文档目录 5 、核心代码实现 5.1 注册代码 package servelet; import java.io.IOException; import java.io.PrintWriter; import java.lang.reflect.InvocationTargetException; import java.sql.SQLException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb0ad226dfcb03ea3e239aca8934169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1419186022b7934f7b2439400e3981ed/" rel="bookmark">
			AI扩图哪家强？我们实地测试了5款扩图工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI扩图的命运齿轮开始转动了。
近日，“AI扩图”在各个社交平台上频频出圈，#AI扩图#话题，在抖音平台累计播放数超7.8亿次。
何为AI扩图？
AI 扩图功能给我们带来了一个观察世界的新角度。在 AI 的加持下，我们可以看到原本熟悉的专辑封面、视频截图等画面之外「藏」着什么内容。
相关话题#用AI扩图拯救相册废照#、#让人意想不到的AI扩图#，登上抖音热榜前10，累计参与人数分别达16.08万和2.73万。
这些话题的火爆，得益于剪映新上线的“智能扩图”功能。有人表示:“受益了，直接拯救废片”。不过，也有网友反馈:“AI扩图，越扩越废”。
评论区频频翻车的案例让人不得不好奇，AI扩图功能真这么离谱?“头号AI玩家”实测了不同应用中的扩图功能，希望给各位玩家一个参考，或许你也会做出不一样的梗图。
AI的想象力，惊不惊喜?
AI扩图，简单来说，就是将一张照片按照等比例或者自由角度扩展，AI会根据图像的上下文和纹理，预测和补充缺失的部分。
起初，用户在社交平台上分享扩图后的照片，画风还算正常。
AI直接将照片的氛围感拉满，收获网友一片“太酷了”的赞声。
图源:小红书博主“85岁退休老阿姨”
图源:抖音博主“Grrr” 凭借AI的深度学习能力，他们获得了专属的二次创作图片，成为AI扩图的受益者。 但这波AI扩图能够火爆出圈，更重要的是网友们的玩梗能力太强了。 比如，我们都很难揣测，在AI眼中，你到底是人是狗或是其他物种。
图源:小红书博主“数玩青年”
图源:抖音博主“莲妹🪷” 靓仔近照成为了狗子，网友激动地表示，“人模狗样”可能是真的。
图源:抖音博主“芒果推文”、“憶.”
不得不说，AI对人类外貌的想象，果然是有限的。 其他案例也很精彩，评论区大家上传了更多荒谬的照片。网友直呼:“可以可爱，但别变态。”
一朵脚花，图源:抖音博主“吹泡泡、”
扩图就扩图，可没想过要命的 还有在AI的作用下，直接和建筑融为一体，真·如城墙般伟岸。
以实力验证了那句“十年树木，百年树人”:
图源:抖音博主“困困鱼.”
相互拥抱的半身照，在AI眼里直接变成了大人抱小孩。谁懂啊，直接差辈了:
图源:抖音博主“小贰贰”
圆满的结婚照，扩出了第三个人:
图源:抖音博主“寄”
不用多废话，直接让你换个对象:
图源:小红书博主“Stella”
看出来了，AI手下的情侣，大多没有什么好下场。但对单身人士，AI就格外友好。
许愿前:祝我早日脱单。
AI:男友牵着你的手满不满意。
图源:抖音博主“永狐”
你以为就这些?不!AI没有创作瓶颈，只有无限的想象力。
比如，变相利好打工人，让人忍不住道出一声“谢谢你，请假侠”。
当然，一些经典影视剧也难逃被恶搞的命运。
经过二次扩图的甄嬛，还不是得在线打工。
还有类似“职场气势万不可输”:
扩图功能哪家强? 其实在文生图领域，扩图功能并不新颖。
在剪映推出智能扩图之前，美图秀秀、Midjourney、Stability AI、Adobe Photoshop都推出了扩图功能。
当然，网友们玩得再花，不如我们亲自上手试一试。
剪映-智能扩图
在见识过大家的奇葩扩图后，“头号AI玩家”用经典梗图、影视剧名场面进行了一波实测。
打开剪映APP后，点击特效 — 图片玩法 — 智能扩图，就能实现图片扩展。
让我们看看曾经的名场面，会“进阶”到什么程度:
《九品芝麻官》之“我全都要”:AI直接当红娘，恭喜一对新人喜结连理。
如果继续让AI扩图，那么他们可以穿越到现代社会，继续做有情人。
剪映的“智能扩图”功能，在离谱中夹杂着一些合理。至少可以理解，AI根据原图背景的红色，生成了裙子、装饰等“喜庆”相关风格的元素。
经过裁剪的图片，效果是否也这么出其不意?
我们上传了相机实拍的图片，AI进行了第一次扩图:
这么看上去，除了背景变成广角外，出图效果还是很正常的。
但当图像中出现人物元素，需要AI补充完整的时候，AI给出的反馈是这个样的:
直接“返老还童”了，家人们!
但可以看到，AI无法根据手部细节，想象出相应的人物形象，包括鞋子、背包等细节的比例和位置也不太准确。
不过，剪映的智能扩图在想象人物、外貌上有不足之处，对于风景的扩展还是符合原图场景的，至少没有非常突兀。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1419186022b7934f7b2439400e3981ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5ef301bc4b1a868a1656d1e25b7e2c/" rel="bookmark">
			MySQL升级PostgreSQL遇到的常见问题及其解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRUD问题 选择 id 在的逗号分隔的字符串所表示的数组中的行 如果要将字符串用于连接条件，则需要将字符串转换为适当的整数数组。
Select * from table_name where id = any(string_to_array(?, ',')::int[]); string_to_array(?, ',')::int[] 这部分代码的作用是将一个逗号分隔的字符串转换为一个整数数组。? 是一个占位符，你需要在执行这个查询时提供一个实际的值。例如，如果你提供的值是 '1,2,3'，那么 string_to_array(?, ',')::int[] 就会返回一个数组 [1, 2, 3]。
a.id = ANY(...) 这部分代码的作用是检查 a.id 是否在给定的数组中。如果 a.id 的值在数组中，那么这个 WHERE 条件就会为真，相应的行就会被选中。
所以，整个查询的意思是：从 table_name 表中选择那些 id 在给定的逗号分隔的字符串所表示的数组中的行
int可根据需要，替换为 bigint
timestamp日期与字符串比较 List selectList(@Param(“startTime”) String startTime);
使用::双冒号进行类型转换
&lt;select id="selectList" resultType="com.entity.UserInfo" parameterType="java.util.List"&gt; SELECT * from user_info WHERE create_time &amp;gt;= #{startTime}::timestamp and create_time &amp;lt;= '2020-07-07 16:35:02' &lt;/select&gt; PS:
#{startTime}::timestamp 可根据需要，替换为 date
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f5ef301bc4b1a868a1656d1e25b7e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c03015ba4686b4cad8dcd6d38ece016/" rel="bookmark">
			RabbitMQ篇——RabbitMQ死信队列详细介绍，超详细、超全面的技术点剖析！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		死信队列介绍 RabbitMQ是一个流行的开源消息队列中间件，它支持多种消息协议，包括AMQP和MQTT等。RabbitMQ的死信队列（Dead Letter Queue）是一种特殊的队列，用于处理无法被消费者正确处理的消息。
使用背景： 在实际的应用中，可能会遇到一些消息无法被消费者正确处理的情况，比如消息格式错误、消费者处理失败等。如果这些消息一直留在原始队列中，会导致队列堵塞，影响其他消息的消费。为了解决这个问题，RabbitMQ引入了死信队列的概念。
死信队列的介绍： 死信队列是一个专门用于接收无法被消费者正确处理的消息的队列。当消息被投递到死信队列时，可以进行一些特殊的处理操作，比如记录日志、发送告警等。同时，死信队列也可以配置一些特定的参数，比如过期时间、最大长度等，用于控制消息的生命周期。
使用死信队列的好处包括：
提高系统可靠性：将无法处理的消息转移到死信队列，避免消息堆积和影响其他消息的消费。方便消息处理错误的监控：通过监控死信队列中的消息数量和处理速度，可以及时发现和处理消费者的错误。 在使用死信队列时，需要注意以下几点：
配置死信队列：需要在消费者和生产者的队列配置中指定死信队列的名称和参数。消费死信队列：消费者需要单独处理死信队列中的消息，并根据自己的业务逻辑进行处理。记录和监控：需要记录死信队列中的消息信息，并监控死信队列的状态，及时发现和处理问题。 DLX交换机 DLX也是一个正常的交换机，和一般的交换机没有什么的区别，它能在任何队列上被指定，实际上就是设置某一个队列的属性，当这个队列中存在死信时，RabbitMQ将会自动的将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列
死信队列工作流程图 使用死信队列的方法 （1）创建DLX交换机和死信队列
（2）在我们设置过期时间的队列中配置死信交换机和死信队列
原理就是我们队列中的消息如果超过了5秒的时间，则就变成了死信，这条死信就需要找一个接盘侠！
注意最重要的就是这个map中的key不要写错了，然后注意如果试fanout发布订阅模式就不需要配置路由key了
至此，关于死信队列的概念以及如何使用已经介绍完毕，后续还会继续更新相关技术点，敬请期待~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc81497b77e3280d13ae443b6f32f083/" rel="bookmark">
			JAVA的三大版本，你都了解过吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Java
二、JavaSE
三、JavaME
四、JavaEE
一、Java Java是一种跨平台的高级编程语言，由Sun Microsystems（现为Oracle）于1995年首次发布。它的特点包括：
跨平台性：Java代码可以在不同的计算机平台上运行，只需在目标平台上安装Java虚拟机（Java Virtual Machine，JVM）。这使得Java成为一种非常灵活和可移植的语言。
面向对象：Java是一种面向对象的编程语言，它支持封装、继承和多态等面向对象的概念。面向对象的编程风格使得代码更易于维护、扩展和重用。
简单易学：相对于其他编程语言，Java的语法相对简单，易于理解和学习。它采用了C和C++的一些语法特点，但去除了一些复杂和容易出错的特性。
强大的类库：Java提供了丰富的类库，涵盖了各种功能，包括输入输出、网络通信、数据库连接、图形界面等。这些类库可以大大加快开发过程，提高效率。
安全性：Java在设计时注重安全性，有一个安全模型来防止恶意代码的执行。Java的安全模型包括安全沙箱、字节码校验和安全管理器，可以确保应用程序在受到限制的环境中运行。
多线程支持：Java具有内置的多线程支持，可以实现并发编程。这使得开发者可以利用多线程来处理并发任务，提高性能和效率。
大型开发社区：Java拥有庞大的开发社区和丰富的资源，开发者可以轻松地找到教程、文档、框架和工具等支持。
Java在各个领域都有广泛的应用，包括企业级应用、桌面应用、移动应用、游戏开发、嵌入式设备等。它被广泛使用于大型企业级应用的开发，如银行系统、电子商务平台和供应链管理系统等。同时，Java也是Android平台的主要开发语言，被用于开发各种移动应用。
二、JavaSE JavaSE（Java Platform, Standard Edition）是Java平台的标准版本，也是最常用的版本之一。它提供了Java语言的核心库、虚拟机和工具，用于开发普通桌面应用、企业级应用和嵌入式系统等。
JavaSE的主要特点包括：
平台无关性：JavaSE提供了一种跨平台的解决方案，可以在不同的操作系统上运行相同的Java程序。
面向对象：JavaSE完全支持面向对象编程，具有封装、继承、多态等特性，可以提高代码的重用性和可维护性。
强大的库支持：JavaSE提供了丰富的类库，包括输入输出、网络通信、图形界面、数据库访问等功能，开发人员可以利用这些库快速构建应用程序。
内存管理和垃圾回收：JavaSE的虚拟机提供了自动内存管理和垃圾回收机制，可以有效地管理内存资源，减少内存泄漏和垃圾对象的影响。
安全性：JavaSE具有强大的安全性能，在运行时可以对代码进行严格的权限控制，防止恶意代码的执行。
多线程支持：JavaSE支持多线程编程，可以同时执行多个任务，提高程序的并发性和效率。
JavaSE包括了Java语言的基本特性，例如语法、数据类型、流程控制等，同时也包含了大量的类库，如集合框架、输入输出、网络通信等。开发人员可以利用JavaSE来构建各种类型的应用程序，从简单的命令行工具到复杂的企业级应用都可以使用JavaSE进行开发。
三、JavaME JavaME（Java Platform, Micro Edition）是Java平台的微型版本，专门用于嵌入式设备和移动设备的开发。它是JavaSE的子集，针对资源受限的设备进行了优化和精简，适用于低功耗、内存和处理能力有限的设备。JavaME的主要特点包括：
跨平台性：JavaME提供了一种跨平台的解决方案，开发者可以在不同的嵌入式设备和移动设备上运行相同的JavaME应用程序，实现代码的重用和移植性。
硬件适配性：JavaME支持各种嵌入式设备和移动设备，包括智能手机、PDA、嵌入式系统、消费电子产品等。它提供了不同设备的硬件适配层（HardwareAbstractionLayer），使开发者可以方便地访问设备的硬件功能。
轻量级：JavaME针对资源受限的设备进行了优化，提供了轻量级的Java虚拟机（Java Virtual Machine），占用较少的内存和处理能力，适合于低端设备的开发。
应用程序模型：JavaME采用了基于事件驱动的应用程序模型，开发者可以通过事件处理机制来响应设备上的用户操作和状态变化。
丰富的API支持：JavaME提供了丰富的API（Application Programming Interface），包括用户界面、网络通信、数据存储、多媒体等功能，开发者可以利用这些API快速构建嵌入式设备和移动设备的应用程序。
安全性：JavaME具有强大的安全性能，可以在运行时对应用程序进行权限控制和安全沙箱，防止非法访问和恶意代码的执行。
JavaME适用于各种嵌入式设备和移动设备的开发，包括智能手机应用、游戏、嵌入式控制器、电子支付终端等。通过JavaME，开发者可以快速开发出功能丰富、跨平台的嵌入式设备和移动设备应用程序。
四、JavaEE JavaEE（JavaEnterpriseEdition）是Java平台的企业级版本，它提供了一套完整的技术规范和工具，用于开发和部署大规模、高可用性的企业级应用程序。JavaEE的主要特点包括：JavaEE采用了分层架构的设计模式，将应用程序划分为不同的层次，包括表示层、业务逻辑层和持久化层。这种架构模式使得应用程序更易于维护、扩展和重用。
JavaEE使用组件模型来构建应用程序，主要包括企业JavaBean（EnterpriseJavaBeans，EJB）、Servlet、JavaServerPages（JSP）和JavaServerFaces（JSF）等。这些组件提供了丰富的功能和服务，如事务管理、安全性、远程调用等。JavaEE支持分布式计算，可以将应用程序部署在多个物理节点上，实现负载均衡和容错性。通过使用JavaEE的分布式技术，开发者可以构建高可用、可伸缩的企业级应用程序。JavaEE提供了强大的事务管理机制，开发者可以通过声明式事务或编程式事务来管理数据的一致性和隔离性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3bf05c9d82f2e54fc197940959754fd/" rel="bookmark">
			Stable Diffusion动态加载Lora过程中的实验、原理与说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对比实验 显存占用情况 使用StableDiffusionXLPipeline.from_pretrained() 方法SDXL半精度加载显存占用约7G左右。
使用load_lora_weights()加载了5个Lora模型后显存提升到8G，平均每个Lora的大小在200M左右。
使用unload_lora_weights()后显存没有发生变化，还是8G，说明该方法不会清空已经加载到显存的Lora模型，但这时候再调用模型生成图片已经丢失Lora的效果了。
推理耗时 Lora数量耗时（秒）015120224……745 这里使用的Lora平均每个的大小在200M左右，从上表不难发现单个Lora耗时约增加4秒左右。
代码分析与原理说明 1）加载Lora 通过调用load_lora_weights()来加载不同的Lora权重，这些权重的张量都会加载到显存中，但注意只有第一次调用该方法的Lora才会生效，可通过get_active_adapters()查看。
def load_lora_weights( self, pretrained_model_name_or_path_or_dict: Union[str, Dict[str, torch.Tensor]], adapter_name=None, **kwargs ): ... # lora_state_dict 实际执行把tensor加载到显存中，同时返回2个字典记录所添加的lora的名称和配置信息 state_dict, network_alphas = self.lora_state_dict(pretrained_model_name_or_path_or_dict, **kwargs) # state_dict 和 network_alphas 是上面返回的2个参数 # 加载后默认调用的lora是第一次load进来的lora self.load_lora_into_unet( state_dict, network_alphas=network_alphas, unet=getattr(self, self.unet_name) if not hasattr(self, "unet") else self.unet, low_cpu_mem_usage=low_cpu_mem_usage, adapter_name=adapter_name, _pipeline=self, ) self.load_lora_into_text_encoder( state_dict, network_alphas=network_alphas, text_encoder=getattr(self, self.text_encoder_name) if not hasattr(self, "text_encoder") else self.text_encoder, lora_scale=self.lora_scale, low_cpu_mem_usage=low_cpu_mem_usage, adapter_name=adapter_name, _pipeline=self, ) 用一张图来表示load_lora_weights()加载过程，蓝色表示生效的张量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3bf05c9d82f2e54fc197940959754fd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/551/">«</a>
	<span class="pagination__item pagination__item--current">552/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/553/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>