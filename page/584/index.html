<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e5755bc2592a26347d24bdea385a64f/" rel="bookmark">
			前端——HTML中的常用标签详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、HTML
1、HTML标签结构
2、HTML文件结构
（1）、定义
（2）、标签层次结构
二、HTML常见标签
1、注释标签
2、标题标签
3、段落标签
4、换行标签
5、格式化标签
6、图片标签
（1）、定义
（2）、目录结构
7、超链接标签
（1）、定义
（2）、链接的形式
8、表格标签
（1）、定义
（2）、合并单元格
9、列表标签
10、表单标签
（1）、form标签
（2）、input标签
（3）、 label标签
（4）、select标签
（5）、textarea标签
11、无语义标签
一、HTML 1、HTML标签结构 HTML代码是由标签构成的，标签名放到“&lt; &gt;”中。
大部分标签都是成对出现，例如：以&lt;body&gt;为开始标签，以&lt;/body&gt;为结束标签。少数标签只有开始标签的被称为“单标签”。 在开始标签和结束标签之间的是标签的内容。此外开始标签中可能会带有“属性”，id属性相当于给这个标签设置了一个唯一的标识符，不可重复。
2、HTML文件结构 （1）、定义 例：
&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 呵呵 &lt;/body&gt; &lt;/html&gt; html 标签是整个 html 文件的根标签(最顶层标签)head 标签中写页面的属性title 标签中写的是页面的标题body 标签中写的是页面上显示的内容 （2）、标签层次结构 head和body是html的子标签，反之为父标签。title是head的子标签，head 是title的父标签。head和body之间是兄弟关系。 二、HTML常见标签 1、注释标签 例：
&lt;!-- 呵呵 --&gt; 注释语句是不会显示到界面上的，只是为了增加代码的可读性。
2、标题标签 例：
&lt;h1&gt;标题1&lt;/h1&gt; &lt;h2&gt;标题2&lt;/h2&gt; &lt;h3&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; 标题标签有6个，数字越大，字体越小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e5755bc2592a26347d24bdea385a64f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a344d9d41d249e8d423f64f47bdfbd2/" rel="bookmark">
			Java 转换 WebP 图片，使用 webp-imageio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebP 是 Google 推出的一种新型图片格式，相比于传统的 PNG/JPG 图片有着更小体积的优势，在当今 Web 中有着广泛的应用。但是 Java 和 JDK 本身不支持 WebP 图像，不过我们可以使用 webp-imageio 库来支持 WebP 图片。
顺便提一提其他库支持的方式。WebP 最早是这个 webp project of Luciad 库提供支持的，但它需要手动安装对应的动态链接库，非常不方便。qwong/j-webp 项目作者为了解决这个问题，改进了对动态链接库的读取方式，把从java.library.path读取改成了从项目 resource 文件中读取。虽然 qwong/j-webp 项目解决了动态链接库依赖问题，但是它并未对这些代码提供一个良好封装，于是有了 webp-imageio-core 提供一个可用的 jar 包，只要导入项目即可使用。虽然如此，但 webp-imageio-core 并未提供一个开放的 Maven 依赖，稍微有些不便，——所以最终选择了 webp-imageio。
首先加入依赖。
&lt;!-- 支持图片格式 WebP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.sejda.imageio&lt;/groupId&gt; &lt;artifactId&gt;webp-imageio&lt;/artifactId&gt; &lt;version&gt;0.1.6&lt;/version&gt; &lt;/dependency&gt; 读取 WebP 图片 像正常读取 Jpg/Png 那样，无须 import 其他包。
BufferedImage image = ImageIO.read(new File("/home/gc/my_image.webp")); System.out.printf("\nDimension of the image:%dx%d", image.getWidth(), image.getHeight()); 无损压缩 接着我们试试转换 Jpg 到 WebP。首先使用无损格式保存图像，把WebPWriteParam#setCompressionType选项将压缩类型设置为LOSSLESS_COMPRESSION。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a344d9d41d249e8d423f64f47bdfbd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce790706d0cae9a86c879977e5be28f/" rel="bookmark">
			三分钟透彻理解Python中的@staticmethod和@classmethod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三分钟透彻理解Python中的@staticmethod和@classmethod 引入Class MethodStatic Method 这篇博文主要讲解以下问题：
@classmethod和@staticmethod在Python中是什么意思，它们有何区别？我应该在何时使用它们，为什么要使用它们，以及如何使用它们？
@classmethod告诉一个类，这是一个应该被子类继承的方法，或者某种程度上是这样。然而，这样做的目的是什么呢？为什么不直接定义类方法，而不添加@classmethod、@staticmethod或任何@定义呢？
引入 虽然@classmethod和@staticmethod非常相似，但它们在用法上有轻微的区别：classmethod必须将一个类对象的引用作为第一个参数，而staticmethod可以不带任何参数。
Example:
class Date(object): def __init__(self, day=0, month=0, year=0): self.day = day self.month = month self.year = year @classmethod def from_string(cls, date_as_string): day, month, year = map(int, date_as_string.split('-')) date1 = cls(day, month, year) return date1 @staticmethod def is_date_valid(date_as_string): day, month, year = map(int, date_as_string.split('-')) return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999 date2 = Date.from_string('11-09-2012') is_date = Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce790706d0cae9a86c879977e5be28f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a48607d82ad8be515a7375bdc20bbd0/" rel="bookmark">
			nginx配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx配置详解 前言一：nginx.conf原本配置到解释二：整体基本理解全局块：events块：http块： 三：最简单的上线四：nginx优化：1.前端history模式404问题：2.反向代理：如何配置：具体位置：理解：定义多个端口的反向代理： 3.开启gzip：作用：如何配置：具体位置： 4.维护页面：作用：如何配置：具体位置： 5.一个ip上线多个网站：作用：如何配置：具体位置：注意点： 6.动静分离作用：解析：图解：如何配置（其实是优化，因为一般配置会有动静分离）：具体位置： 7.其他优化 五：nginx基础命令：安装，启动，重启，关闭六：其他 前言 对于自己上线项目的前端来说，nginx也是必须要了解和熟悉的，查了很多的nginx文章，看着写的都很详细，但是却没有了整体的概念。这里就重新梳理一遍，也理清思路。
我们在安装nginx之后，会自动生成很多的文件，但是nginx.conf这个文件是我们的核心，如何去正确的修改和优化它是nginx的核心。
首先我们可以先看下原本的配置，你会觉得无所适从，因为感觉这个鬼东西也太多了吧。而且感觉根本就不理解，也不知道该怎么写。下面，就一步一步的教你如何入门到熟悉
一：nginx.conf原本配置到解释 看到这个118行是不是觉得有点害怕
#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a48607d82ad8be515a7375bdc20bbd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009b7345a75bc8e0d9b5a1bbe908979b/" rel="bookmark">
			ORA-00257:archiver error.Connect internal only,until freed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORA-00257:archiver error.Connect internal only,until freed. 1、报错原因 归档满了 2、解决方法 1.查看归档路径 archive log list; Arcive destination USE_DB_RECOVERY_FILE_DEST 此参数代表归档存放路径，本地存放为/opt/oracle…，asm为+archdg
当为以上参数时，代表存放到数据闪回区
2.查看闪回区设置 show parameter recover; db_recovery_file_dest #表示存放路径 db_recovery_file_dest_size #表示可以使用的空间大小 3.设置闪回区大小 alter system set db_recovery_file_dest_size=100G scope=both; 4.查看归档空间使用情况 select * from v$flash_recovery_area_usage; 查看闪回区是否开启
select flashback_on from v$database;
开启闪回
SQL&gt;shutdown immediate;
SQL&gt;startup mount;
SQL&gt;alter database archivelog;
SQL&gt; alter database flashback on;
关闭闪回
SQL&gt;shutdown immediate；
SQL&gt;startup mount;
SQL&gt; alter database flashback off;
5.删除归档日志 su - oracle set ORACLE_ID=orcl rman target / #查看已经存在的归档 list archivelog all; crosscheck archivelog all; #删除 delete archivelog all completed before 'sysdate-1'; #删除一天以前的 delete archivelog all completed before 'trunc(sysdate-1)+2/24'; #检查是否删除 list archivelog all; #本地文件删除归档 cd /opt/oracle/archlog find .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009b7345a75bc8e0d9b5a1bbe908979b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bcafa700a327ad739858a0bb1fe2f0f/" rel="bookmark">
			Spark on YARN 部署搭建详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言 二、SparkOnYarn 本质
2.1 Spark On Yarn 的本质?
2.2 Spark On Yarn 需要啥?
三、配置 spark on yarn 环境
3.1 spark-env.sh 3.2 连接到 YARN 中
3.2.1 bin/pyspark
3.2.2 bin/spark-shell
3.2.3 bin/spark-submit (PI)
四、部署模式 DeployMode 4.1 Cluster 模式
4.2 Client 模式
4.3 两种模式的区别 4.4 测试 4.4.1 client 模式测试 4.4.2 cluster 模式测试 4.5 两种模式总结 五、两种模式详细流程 5.1 Client 模式 5.2 Cluster 模式 一、引言 按照前面环境部署中所了解到的，如果我们想要一个稳定的生产 Spark 环境，那么最优的选择就是构建 HA StandAlone 集群。
不过在企业中，服务器的资源总是紧张的，许多企业不管做什么业务，都基本上会有 Hadoop 集群，也就是会有 YARN 集群。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bcafa700a327ad739858a0bb1fe2f0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e4b2125c03a54b4503db80f666cfeb/" rel="bookmark">
			解决 Axios 跨域问题，轻松实现接口调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨域是指访问另外一个域的资源，由于浏览器的同源策略，默认情况下使用 XMLHttpRequest 和 Fetch 请求时是不允许跨域的。跨域的根本原因是浏览器的同源策略，这是由浏览器对 JavaScript 施加的安全限制。
Axios 跨域常见报错 跨域请求被阻止 (Cross-Origin Request Blocked) ：
这是由浏览器实施的同源策略导致的错误。浏览器在默认情况下不允许从一个源发送请求到另一个源，除非目标服务器明确授权。如果没有采取任何跨域解决方案，浏览器会拦截该请求，并报告此错误。
无法获取响应内容 (No 'Access-Control-Allow-Origin' header is present on the requested resource) ：
当使用 CORS (跨域资源共享) 解决方案时，服务器需要在响应头中添加 Access-Control-Allow-Origin 头信息来指示允许访问资源的来源。如果服务器没有正确配置这个头信息或配置不正确，浏览器会报告此错误，表示未经授权无法获取响应内容。
请求出现网络错误 (Network Error) ：
当跨域请求在发送时出现网络错误（例如目标服务器不可访问、请求超时等），Axios 会捕获这个错误，并将其报告为 "Network Error"。
预检请求失败 (Preflight request failed) ：
当使用 CORS 发起一些复杂的请求（例如带有自定义头信息或使用 PUT、DELETE 等非简单请求类型），浏览器会在发送真实请求之前发送一个 OPTIONS 预检请求。如果服务器没有正确处理 OPTIONS 请求或未返回正确的预检响应头，浏览器会报告 "Preflight request failed" 错误。
代理服务器错误：
如果使用代理服务器作为解决方案，但代理服务器配置有误或不可用，Axios 可能会报告与代理服务器连接相关的错误。
Axios 跨域的解决方法 1. CORS CORS 需要服务器设置 Access-Control-Allow-Origin 响应头，表示该资源可以被指定的域进行跨域访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e4b2125c03a54b4503db80f666cfeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/defd34840d1fe22ca40078da32b303a4/" rel="bookmark">
			树莓派最新的安装，设置与教程，助你一次性设置完毕树莓派。(以macOS为例，包含windows和linux）史上最详细！一次性完成所有设置！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近刚入手了树莓派，但是发现网上的资料总是松松散散，找寻起来很麻烦，正好自己完成了设置和安装，于是写下来作为回顾与教程。本文采用的是无屏幕无网线的方式，不过会介绍其他情况。不定期更新，敬请期待！第一次写csdn blog，很多地方有不足，而且略显啰嗦，请多见谅。
一.树莓派的简单介绍 树莓派，（英语：Raspberry Pi，简写为RPi，别名为RasPi / RPI） [1] 是为学习计算机编程教育而设计，只有信用卡大小的微型电脑，其系统基于Linux。随着Windows 10 IoT的发布，用户可以用上运行Windows的树莓派。
树莓派自问世以来，受众多计算机发烧友和创客的追捧，曾经一“派”难求。别看其外表“娇小”，内“芯”却很强大，视频、音频等功能通通皆有，可谓是“麻雀虽小，五脏俱全”。
（来自百度百科）
二.安装官方外壳与官方风扇： 将官方风扇插入官方壳上盖中，风扇正面朝下，然后将树莓派插入官方壳底座中，确保安装牢固，然后将风扇连线至gpio接口，同时将官方壳盖上。
详细安装视频：
​​​​​​​​​​​​​​
树莓派官方外壳与官方风扇安装视频
风扇接线图：红色线接4号口，黑色线接6号，蓝色线接gpio14。
如图：
三.树莓派系统的安装（以raspberry pi OS 64位为例） 树莓派系统包括很多，这里以64位的raspberry pi os64位为例，3b以上机型强烈推荐安装64位系统，以保证最佳性能。
1.需要准备的工具： 1.树莓派4B一块（运存任意）
2.读卡器一个
3.tf卡一张（建议在16G以上，作者用的是闪迪32GB卡）
4.电脑一个（macos和windows都可以，linux没试过，不过应该可以，本文采用macOS）
5.良好的网络条件
6.树莓派烧录器
2.烧录系统过程： 1. 下载烧录软件 首先去树莓派官方网站（Raspberry Pi OS – Raspberry Pi）下载对应系统的镜像烧录软件。
作者此处用的是MacBook，因此选择for macos版本下载。
2.选择合适的镜像文件 打开树莓派烧录器后，点击CHOOSE OS（选择操作系统）进入系统下载界面，选择你所需要下载的系统并确定。（64位的pi os需要点击raspbe pi os（other），选择raspberry pi os（64-bit））。作者在此选择的是pi os lite（64-bit）。
镜像文件分类介绍：
pi os （32bit/64-bit）：32位或64位的树莓派os系统，带桌面UI
pi os lite：树莓派os系统，不带图形化桌面。
pi os full：带有桌面和预装软件的系统
pi os legacy：基于buster的系统，一般不推荐选择此系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/defd34840d1fe22ca40078da32b303a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4900d7ec27f3d2e05e8b8933853b942/" rel="bookmark">
			springmvc中WebMvcConfigurationSupport中addInterceptor使用详解及方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. addInterceptor简介 在Spring MVC中，WebMvcConfigurationSupport是一个类，可以通过继承它来进行自定义的MVC配置。在这个类中，可以使用addInterceptor方法来添加拦截器到请求处理链中。
下面是关于addInterceptor方法的说明：
java复制代码protected void addInterceptor(InterceptorRegistry registry) addInterceptor方法是WebMvcConfigurationSupport中的方法之一，用于添加拦截器。在子类中重写这个方法，可以向注册表（InterceptorRegistry）中添加拦截器。通过注册表，可以指定拦截器要拦截的路径、优先级等信息。 总之，addInterceptors(InterceptorRegistry registry)：用于注册拦截器。我们可以通过重写这个方法，将自定义的拦截器添加到 registry 中。
2. InterceptorRegistry 方法详解 2.1 addPathPatterns(String… patterns) 通过这个方法，我们可以指定要拦截的请求路径模式，使拦截器只对符合指定路径模式的请求进行拦截。
以下是关于 addPathPatterns 方法的说明：
addPathPatterns 方法接受一个或多个字符串参数作为路径模式。路径模式可以使用通配符来匹配多个路径，例如 "/*" 表示根路径和其子路径都会被拦截。该方法可以在添加拦截器时使用，用于指定需要被拦截器处理的路径。拦截的路径模式将被应用于已经设置的拦截路径上。 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new CustomInterceptor()) .addPathPatterns("/api/**"); // 拦截 /api 下的所有请求 } 在上面的示例中，首先通过 addInterceptor 方法添加了一个自定义拦截器 CustomInterceptor，然后使用 addPathPatterns 方法指定了要拦截的路径模式 /api/**。
这样配置之后，拦截器将会对所有以 /api/ 开头的请求进行拦截处理。
通过使用 addPathPatterns 方法，我们可以更加细粒度地指定拦截器的应用范围，根据具体需求选择性地拦截某些路径。如果不调用 addPathPatterns 方法，则拦截器将对所有请求生效。
2.2 addPathPatterns(List patterns) 通过这个方法，我们可以指定要拦截的请求路径模式列表，使拦截器只对符合指定路径模式的请求进行拦截。
以下是关于 addPathPatterns 方法的说明：
addPathPatterns 方法接受一个字符串列表作为路径模式。
路径模式可以使用通配符来匹配多个路径，例如 "/*" 表示根路径和其子路径都会被拦截。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4900d7ec27f3d2e05e8b8933853b942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14bda27402c134b785b79546652fa7ed/" rel="bookmark">
			SpringBoot使用AOP详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 AOP是什么2 AOP概念3 Springboot中使用AOP4 AOP原理5 应用场景 1 AOP是什么 AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。
利用AOP可对业务逻辑进行增强，在不改变原有逻辑的基础上，在其前后进行处理。降低了耦合性，减少了大量冗余的操作。特别适合用于大量方法都需要进行相同处理的操作。
2 AOP概念 AOP是做了个切面，在不破坏原有方法的基础上，将切面切进去，在其前后进行处理，整体逻辑关系图如下：
切面（Aspect）：一般是指被@Aspect修饰的类，代表着某一具体功能的AOP逻辑。切入点（Pointcut）：选择对哪些方法进行增强。通知（Advice）：对目标方法的增强，有一下五种增强的类型。 环绕通知（@Around）：内部执行方法，可自定义在方法执行的前后操作。前置通知（@Before）：在方法执行前执行。后置通知（@After）：在方法执行后执行。返回通知（@AfterReturning）：在方法返回后执行。异常通知（@AfterThrowing）：在方法抛出异常后执行。 连接点（JoinPoint）：就是那些被切入点选中的方法。这些方法会被增强处理。 对于各种通知的方法、注解等没有什么特别的操作，具体使用会在后面举例。而切入点是选择对哪些方法生效的定义，那怎么知道它选择的是哪些方法呢？因为有多种匹配方式。
表达式类型功能execution()匹配方法，最全的一个args()匹配入参类型@args()匹配入参类型上的注解@annotation()匹配方法上的注解within()匹配类路径@within()匹配类上的注解this()匹配类路径，实际上AOP代理的类target()匹配类路径，目标类@target()匹配类上的注解 用的比较多的是execution()和@annotation
execution(修饰符 返回值类型 方法名（参数）异常)
语法参数描述修饰符可选，如public，protected，写在返回值前，任意修饰符填*号就可以返回值类型必选，可以使用*来代表任意返回值方法名必选，可以用*来代表任意方法参数()代表是没有参数，(…)代表是匹配任意数量，任意类型的参数，当然也可以指定类型的参数进行匹配，如要接受一个String类型的参数，则(java.lang.String), 任意数量的String类型参数：(java.lang.String…)异常可选，语法：throws 异常，异常是完整带包名，可以是多个，用逗号分隔看几个常用的写法
// 所有方法 execution(* *..*(..)) // 指定参数，即入参本身的类型，不能放其接口、父类 execution(* *..*(java.lang.String, java.lang.String) // 指定方法前缀 execution(* *..*.prefix*(..)) // 指定方法后缀 execution(* *..*.*suffix(..)) // 组合，增强所有方法，但是去掉指定前缀和指定后缀的方法 execution(* *..*(..)) &amp;&amp; (!execution(* *..prefix*(..)) || !execution(* *..*suffix(..))) @annotation()
匹配方法上的注解，括号内写注解定义的全路径，所有加了此注解的方法都会被增强。
// 增强被指定注解修饰的方法（所有加了@TestAspect注解的都会被） @annotation(com.banmoon.test.annotation.TestAspect) // 指定前缀的注解修饰的方法 @annotation(com.banmoon.test.annotation.Prefix*) // 指定后缀的注解修饰的方法 @annotation(com.banmoon.test.annotation.*Suffix) 3 Springboot中使用AOP 引入依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14bda27402c134b785b79546652fa7ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fabc9247f7fc1140f311721b3d2c2580/" rel="bookmark">
			从零基础到精通Flutter开发：一步步打造跨平台应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【工具大全】【游戏大全】【神级源码资源网】🤟 前端学习课程：👉【28个案例趣学前端】【400个JS面试题】💅 寻找学习交流、摸鱼划水的小伙伴，请点击【摸鱼学习交流群】 导言 Flutter是一种流行的开发框架，可以用来构建美观、高性能且跨平台的移动应用程序。本文将带领您从零基础开始，逐步学习Flutter开发，直到精通为止。无论您是新手还是有经验的开发者，都能从本文中获得有价值的知识。
第一步：安装和设置Flutter 在这一步中，我们将介绍如何安装Flutter，并进行必要的配置。您将学习如何设置Flutter开发环境，包括安装Flutter SDK和配置开发工具。
下载和安装Flutter SDK配置Flutter开发环境使用Flutter命令行工具 第二步：Hello World！第一个Flutter应用 在这一步中，我们将创建您的第一个Flutter应用程序。您将学会如何构建Flutter应用的基本结构，包括小部件（Widgets）和布局。
创建Flutter项目编写Hello World应用程序运行和调试Flutter应用 第三步：掌握Flutter小部件 Flutter的强大之处在于其丰富的小部件库。在这一步中，我们将深入研究各种Flutter小部件，包括文本、按钮、图像和列表等。
文本和样式按钮和交互列表和网格视图 第四步：处理用户输入 学会如何处理用户的交互操作是Flutter应用的关键部分。在这一步中，我们将讨论如何响应按钮点击、手势和表单输入。
处理按钮点击事件手势检测和处理表单输入和验证 第五步：导航和路由管理 在这一步中，我们将介绍导航和路由管理。您将学会如何在不同屏幕之间导航，并创建适应不同路由的布局。
页面导航和路由命名路由和参数传递自定义路由过渡效果 第六步：状态管理 状态管理是Flutter应用开发中的一个关键概念。我们将讨论有关状态管理的不同方法，包括本地状态管理和全局状态管理。
本地状态管理与StatefulWidget全局状态管理与Provider 第七步：网络请求和数据存储 在这一步中，我们将学习如何进行网络请求，并将数据存储到本地。您将使用Flutter的插件来实现这些功能。
发起HTTP请求与Dio库数据解析与JSON本地数据存储与SharedPreferences 第八步：打包和发布应用 最后一步是将您的Flutter应用程序打包并发布到应用商店。我们将介绍如何生成应用的APK或IPA文件，以及如何提交应用商店审核。
生成APK和IPA文件应用商店发布和审核 结语 通过本文的逐步指导，您将建立起对Flutter开发的坚实基础，并逐渐提升自己的技能，直至成为一名精通Flutter开发的开发者。Flutter的灵活性和性能将使您能够构建出色的跨平台移动应用程序，希望您在学习过程中取得成功！
⭐️ 好书推荐 《从零基础到精通Flutter开发》
【内容简介】
本书分为三部分：第一部分为入门篇（第1-4章），主要介绍Flutter技术的诞生背景、特点、语言及常用组件的使用，通过对本篇的学习，读者可以掌握如何使用Flutter来搭建UI界面；第二部分为进阶篇（第5-11章），主要包含Flutter的手势和事件处理、动画、自定义组件、文件操作和网络请求、路由导航和存储、混合跨平台开发、国际化等，通过对本篇的学习，读者可以对Flutter的整体流程及原理有一个深入的认识；第三部分为实战篇（第12~14章），主要通过一个实战项目把前面介绍的内容整合起来，并且结合Flutter应用发布和Flutter App升级等一条线流程，让读者对开发一个完整的Flutter App有一个整体的了解。
📚 京东购买链接：《从零基础到精通Flutter开发》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b35bf98f53c486ddde78130050e3be/" rel="bookmark">
			第一章 SQL Server 数据库部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人简介：云计算网络运维专业人员，了解运维知识，掌握TCP/IP协议，每天分享网络运维知识与技能。座右铭：海不辞水，故能成其大；山不辞石，故能成其高。 个人主页：小李会科技的主页 目录
一 数据库介绍
（1）使用数据库的必要性
（2）数据库的基本概念 1.数据
2.数据库和数据库表
3.数据库系统和数据库管理系统
（3）数据库的发展史
（4）关系数据库的基本概念
主键的特点：
候选键的特点：
外键的特点：
二 数据完整性规则
三 SQL Server 2016 的版本
四 启动和停止数据库的方法
五 数据库的分类
（1）系统数据库
（2）用户数据库：用户自己创建的
六 主流数据库介绍
六 安装 SQL server 数据库
1.接下来以虚拟机VMware 来演示
2.打开SQL Server 安装中心选择安装​编辑
3. 选择第一个 全新安装SQL Server 独立安装或现有安装添加功能
4. 下一步
5.勾选接受下一步，之后一直点下一步到安装程序文件即可
6.下一步，扩住里面没有亮红都正常
7.点击全选 将R服务和 针对对外部数据和独立不选√然后下一步
​编辑 8.选择混合模式 设置密码 记住自己的sa 点击添加当前用户 下一步​编辑
9.点击安装 等待安装完成 一 数据库介绍 （1）使用数据库的必要性 结构化存储大量数据，便于高效的检索和访问有效地保持数据信息的一致性、完整性，降低数据冗余满足数据共享和安全方面的要求 （2）数据库的基本概念 1.数据 描述事物的符号记录称为数据（Data） 包括数字、文字、图像、声音等
2.数据库和数据库表 不同的记录组织在一起，就形成了“表” 数据库就是表的集合 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b35bf98f53c486ddde78130050e3be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a22f0b12e1f849e99e859d83f074dab/" rel="bookmark">
			Android11.0 生成系统签名.jks文件并对Apk进行签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 V2签名生成.jks签名文件使用命令查看.jks文件Studio引用platform.jks使用platform.jks手动签名APK使用命令查看APK文件签名信息 V2签名 对应用手动进行系统签名，需要platform.pk8，platform.x509.pem，signapk.jar这三个文件，应用的AndroidManifest.xml中需要添加android:sharedUserId=“android.uid.system” ，然后输入以下命令就可得到签名后的apk文件：
java -jar signapk.jar platform.x509.pem platform.pk8 target.apk sign.apk 如果你的应用targetSdkVersion&gt;=30，在7.0以上的设备上安装不成功，会报以下错误：
Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Scanning Failed.: No signature found in package of version 2 or newer for package com.xxx.fotatest] 对于以Android11(Api30）为目标平台，apk必须使用V2及以上签名否则无法安装成功。
下面介绍一种使用系统文件生成.jks签名文件的方式对Apk进行系统签名。
生成.jks签名文件 在源码中进入到/build/target/product/security目录，输入以下命令:
cd build/target/product/security/ // 1.生成 platform.pem openssl pkcs8 -inform DER -nocrypt -in platform.pk8 -out platform.pem // 2.生成 platform.p12 // 别名：systemkey // 密码：123456 openssl pkcs12 -export -in platform.x509.pem -out platform.p12 -inkey platform.pem -password pass:123456 -name systemkey // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a22f0b12e1f849e99e859d83f074dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caffea39eb8b22968c839c47a97a9d97/" rel="bookmark">
			Spring MVC请求处理流程和九大组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spring MVC 请求处理流程Spring MVC 九⼤组件 需求：前端浏览器请求url： http://localhost:8080/demo/handle01，前端⻚⾯显示后台服务器的时间 开发过程 配置DispatcherServlet前端控制器开发处理具体业务逻辑的Handler（@Controller、@RequestMapping）xml配置⽂件配置controller扫描，配置springmvc三⼤件将xml⽂件路径告诉springmvc（DispatcherServlet） Spring MVC 请求处理流程 流程说明
第⼀步：⽤户发送请求⾄前端控制器DispatcherServlet
第⼆步：DispatcherServlet收到请求调⽤HandlerMapping处理器映射器
第三步：处理器映射器根据请求Url找到具体的Handler（后端控制器），⽣成处理器对象及处理器拦截器(如果 有则⽣成)⼀并返回DispatcherServlet
第四步：DispatcherServlet调⽤HandlerAdapter处理器适配器去调⽤Handler
第五步：处理器适配器执⾏Handler
第六步：Handler执⾏完成给处理器适配器返回ModelAndView
第七步：处理器适配器向前端控制器返回 ModelAndView，ModelAndView 是SpringMVC 框架的⼀个底层对象，包括 Model 和 View
第⼋步：前端控制器请求视图解析器去进⾏视图解析，根据逻辑视图名来解析真正的视图。
第九步：视图解析器向前端控制器返回View
第⼗步：前端控制器进⾏视图渲染，就是将模型数据（在 ModelAndView 对象中）填充到 request 域
第⼗⼀步：前端控制器向⽤户响应结果。
Spring MVC 九⼤组件 HandlerMapping（处理器映射器） HandlerMapping 是⽤来查找 Handler 的，也就是处理器，具体的表现形式可以是类，也可以是⽅法。⽐如，标注了@RequestMapping的每个⽅法都可以看成是⼀个Handler。Handler负责具体实际的请求处理，在请求到达后，HandlerMapping 的作⽤便是找到请求相应的处理器Handler 和 Interceptor。
HandlerAdapter（处理器适配器） HandlerAdapter 是⼀个适配器。因为 Spring MVC 中 Handler 可以是任意形式的，只要能处理请求即可。但是把请求交给 Servlet 的时候，由于 Servlet 的⽅法结构都是doService(HttpServletRequest req,HttpServletResponse resp)形式的，要让固定的 Servlet 处理⽅法调⽤ Handler 来进⾏处理，便是HandlerAdapter 的职责。
HandlerExceptionResolver（Handler异常解析器） HandlerExceptionResolver ⽤于处理 Handler 产⽣的异常情况。它的作⽤是根据异常设置ModelAndView，之后交给渲染⽅法进⾏渲染，渲染⽅法会将 ModelAndView 渲染成⻚⾯。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caffea39eb8b22968c839c47a97a9d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d3555bac7cccb41f89a1bdc7fe98ab/" rel="bookmark">
			【Java从入门到精通】这也许就是Java火热的原因吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Java是一种高级的、面向对象的、可跨平台的程序设计语言。Java根据技术类别可划分为以下几类：JavaSE（Standard Edition，标准版）：支持面向桌面、嵌入式和移动设备的应用程序开发；JavaEE（Enterprise Edition，企业版）：支持基于Web的大型企业应用程序开发；JavaME（Mobile Edition，移动版）：支持嵌入式设备和移动设备的应用程序开发 。本文主要讲解JavaSE中的知识点。
Java 语言基础 Java 主类结构1.Java中的基本数据类型2.Java中的变量与常量2.1标识符和关键字2.2声明变量2.3声明常量 3.Java中的运 算 符4.数据类型转换5.Java从入门到精通 Java 主类结构 Java 语言是面向对象的程序设计语言，Java 程序的基本组成单元是类，类体中又包括属性与方法两部分。每一个应用程序都必须包含一个 main()方法，含有 main()方法的类称为主类。下面通过程序来介绍 Java 主类结构。
让我们来看个例子：创建主类并调用其主方法
Eclipse 下依次创建项目 item、包 Number 和类 First。在类体中输入以下代码，实现在控制台上输出“你好 Java”。
package Number; public class First { static String s1 = "你好"; public static void main(String[] args) { String s2 = "Java"; System.out.println(s1); System.out.println(s2); } } 运行结果如下：
你好 Java 注意：代码中的所有标点符号都是英文字符。不要在中文输入法状态下输入标点符号，如双引号和分
号，否则会导致编译错误。文件名必须和类名 First 相同，即 First.java。还要注意大小写，Java 是区分大小写的。
1.Java中的基本数据类型 整数类型简称整型，用来存储整数数值，即没有小数部分的数值。它们可以是正数，也可以是负数。整型数据根据它所占内存大小的不同，可分为 byte、short、int 和 long 4 种类型。它们具有不同的取值范围，可看下表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35d3555bac7cccb41f89a1bdc7fe98ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84bbd268b2b000463fddad5b508c333d/" rel="bookmark">
			【JAVA】异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：paper jie 的博客
本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。
本文录入于《JAVASE语法系列》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。
其他专栏：《JAVA》《算法详解》《C语言》等
目录
什么是异常
异常的体系结构
异常的分类
编译时异常
运行时异常
异常的处理
防御式编程
异常的抛出
异常的捕获
异常声明 throws
try - catch捕获并异常
finally
异常的处理流程
自定义类
什么是异常 在java中，将程序执行过程中发生不正常行为称为异常。比如我们写代码经常遇到的：
算数异常
int a = 10 / 0; 数组越界异常
int[] arr = {1,2,3,4,5}; System.out.println(arr[10]); 空指针异常
int[] arr = null; System.out.println(arr.length); 我们可以发现，java中不同的类型的异常有对应的类来描述。
异常的体系结构 异常种类有很多种，为了对这些异常可以比较好的管理起来，Java内部维护了一个异常的体系结构：
Throwable：异常体系的顶层，还有派生出的两个类，Error和Execption
Error：是java虚拟机JVM无法解决的严重问题，比如：JVM中的内部错误，资源耗尽等。典型代表：StackOverflowErrow和OutofMemoryError，一但发生了程序就会崩溃，没有办法解决。
Execption：异常产生后程序员可以通过代码进行处理，让程序继续运行。
异常的分类 异常可以在编译期间发生，也可以在运行时发生，根据发生的不同时机，可以分为：
编译时异常 在程序编译期间发生的异常，称为编译时异常，也可以叫受查异常
class person { String name; int age; @Override protected Object clone() { return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84bbd268b2b000463fddad5b508c333d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4408233c8aede8f2e08371ee5ea625b4/" rel="bookmark">
			解决明明环境变量没问题,启动idea还是报错The environment variable JAVA HOME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近电脑坏了,公司给安排了新的工位,这个工位电脑上的idea版本是2019,由于2019使用翻译插件不能使用edge的翻译引擎,我就更换了2023,结果安装成功双击发现打不开,并报错The environment variable JAVA HOME (with the value of %JAVA_HOME(你的环境变量路径)%)does not point to a valid jvM installation,大致意思是JAVA_HOME没有指向有效的JVM安装
首先检查你的环境变量,是否有重复,是否路径不对,如果是的话修改环境变量就没问题了,但起初我也以为是环境变量的原因,但是经过n次重装,还把它装到了启动盘(c:),发现根本不是环境变量的问题,我的环境变量压根没问题!!
百度了许多,有说什么不要放在带空格的文件夹的,有说清理appdata文件夹下的缓存的,但都解决不了问题...
终于,在我多次探索中,发现了一个工具,完美的解决了这个问题!!!
这个工具叫JetBrainsToolbox ,下载地址:https://www.jetbrains.com/toolbox-app/
也是JetBrains官方推出的一个软件管理工具。它专用于JetBrains的产品，包括支持软件的更新、维护、回滚、降级等操作，以简单的方法管理用户的工具
首先确认你的java环境变量没问题的情况下,安装这个软件,并在这个软件上安装idea(也可能用安装包安也行,但反正我是直接在这个软件上安装的idea),安装完成后是这个样子,有中文版的,但是我安装的是英文版
然后点击右边的三个点,点击Settings
在Settings中 ,选择Configuration,选择Custom JVM options file location,我大致理解这个的意思是让idea使用idea自带的jvm,而不去读取用户本机的JAVA_HOME/bin,然后我的idea就可以打开了,另外提一嘴,Install location是你自己的idea安装路径,虽然不知道什么原因,但反正我是这么解决了(在别人的帮助下),如果有大佬知道其中缘由还请讲解一下(#^.^#)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac0e98e7a335c6582b0e2c95a855f8c/" rel="bookmark">
			大数据知识点之大数据5V特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据的特征可以浓缩为五个英文单词，Volume(大量）、Variety(多样性）、Velocity(速度）、Value(价值）、Veracity(准确性）。因为是5个特征都是以“V”开头的英文单词，又叫大数据5V特征。
概述：
1、Volume(大量)
即可从数百TB到数十数百PB、甚至EB的规模
2、Variety(多样性)
即大数据包括各种格式和形态的数据
3、Velocity(速度)
数据增长速度快，处理速度也快，获取数据的速度也要快
4、Value(价值)
数据价值密度低，但是商业价值高
5、Veracity(准确性)
即处理的结果要保证一定的准确性
详细描述：
1、Volume
中文翻译是“大量”的意思，顾名思义，就是数据量非常的庞大。而这也是大数据的字面含义。我们知道在表示数据大小的时候，生活中常见的计量单位有KB、MB、GB、TB等，但是在此之上还有其他的单位，例如: PB、EB、ZB、YB、BB、NB、DB等。这些单位之间的换算率都是1024，也正是因此，人们会把每年的10月24日定为程序员节。我们每一个人在互联网上进行各种各样的行为，都会留下数据，而这些数据量虽然不算大，但是在庞大的用户基数下，累计起来的还是非常庞大的。在一个中大型企业中，需要处理的数据规模是很容易达到PB、EB的级别的，而这也正是大数据的第一个特征: 大量。
2、Variety
中文翻译是“多样化”的意思。我们知道学习大数据就是来处理庞大的数据集的，那么组成这个庞大的数据集的数据是可以分为不同的类型的。我们把这些数据大致分为三类：结构化的数据、半结构化的数据和非结构化的数据。
结构化的数据，一般指的是关系型数据库中的数据，例如MySQL、Oracle中的表中的数据。这些数据中，每一行的数据都保持着相同的数据格式，有规律可循，非常容易处理。
半结构化的数据，指的是有一定的结构性，但是比起关系型数据库表中的结构化的数据来说，结构不是那么清晰，处理起来也比结构化的数据略微麻烦。常见的半结构化的数据有json、xml、html等。
非结构化的数据，指的就是没有丝毫结构性可言的数据了。数据没有固定的格式，通常需要我们单独设计程序来处理这些数据，从中提取出来有价值的信息。
而我们在工作中要处理的数据，往往都是以半结构化和非结构化的居多。
3、Value
中文翻译是“价值”的意思。这里其实有两点体现：价值密度低、商业价值高。
大数据相关的技术体系，需要处理的数据量是非常庞大的，动辄PB、EB规模的数据，但是真正具有价值的数据却非常稀少，只有100M，甚至更少。我们就需要从这么庞大的数据集中提取出来这些密度非常低的有价值的数据进行处理。
但是，也就是这些密度非常低的数据，能够发挥出来巨大的商业价值。这点其实也是来推动大数据发展的重要的特征之一，因为这些大数据相关的技术体系可以给商人带来巨大的利益，老板才愿意培养人来从事这个行业；越来越多的人涌入到这个行业，才能够推动这门技术不断的向前发展。
4、Velocity
中文翻译是“速度”的意思。我们要处理的数据集在很多情况下，并不是一潭死水，而是在不断增长的。对于一个企业来说，每天都会新增庞大的数据，这些数据可能来自于用户的操作、可能来自于智能家居、可能来自于各种传感器等，数据的来源非常多，而且数据量的增速也是非常可怕的。以淘宝、京东这类的电商来说，每日新增的数据量达到几百个GB是很正常的事情。在这样快速的数据增长的情况下，也对我们处理数据的速度有了较高的要求了。我们一定要优化我们的业务逻辑，提高处理的速度，才不会造成数据积压。
5、Veracity
中文翻译是“真实性”的意思。大规模的数据量，在处理的时候，对技术体系是有较高的要求的。在还没有形成现有的技术体系的年代，人们在处理庞大的数据集的时候，往往束手无策，要么实效性非常差，要么干脆无法处理。那个时代甚至流行一种做法：随机抽样。随机的从庞大的数据集中抽取一部分出来进行处理，以这样的处理结果，作为整个数据集的处理结果。追求真实性的，可能会多随机几次。但是这个结果其实是不准确的，并不能够体现出这些数据完整的价值，甚至还可能得到错误的结论。但是现在大数据的技术体系相对成熟，我们不再使用这样的随机抽样的方式了。我们就是要对所有的数据进行高效的处理，得出的结论自然也是正确的。
大数据的5V特征是Volume、Velocity、Variety、Veracity和Value，这些特征描述了大数据的规模、速度、多样性、真实性和价值，对于理解和应用大数据具有重要意义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8fae7d70b914ecf4a85a93b334eb42/" rel="bookmark">
			Python 如何降低版本?从 Python3.9降低到 3.8, /anaconda/虚拟环境等.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以 Win10 为例.
查看当前版本命令:
python --version 安装后查看一下版本是否降级成功.
1. Anaconda 环境 打开 cmd
conda install python==3.8 当然,前提是你的环境变量指向的是 anaconda 的路径.
如果长时间下载不成功,可能是镜像不在国内,可以更改为国内的清华镜像:
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes Anaconda 的python 是被管理起来的,要降级很容易,但是自己安装的 python 就不容易了.
2. 虚拟环境 自己开发时为了避免项目间互相影响,避免打包大小而采用 虚拟环境时比较好的一种做法.
在虚拟环境如何降低版本呢?我在网络上找了一圈也没找到办法.
我的解决办法就是新建一个python3.8的虚拟环境.
即使真有办法一个命令从3.9降低到3.8,可能也不保险,谁知道是否有残余呢?还不如重新来过吧.
参考:
pycharm安装虚拟环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1dbbfc78192b08b24f67b9ea58d0b97/" rel="bookmark">
			【hive】行转列—explode()/posexplode()/lateral view 函数使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、lateral view函数二、explode()函数三、posexplode()函数四、行转列使用单列转多行多列转多行 一、lateral view函数 功能:
用于和UDTF函数（explode,split）结合使用，把某一行数据拆分成多行数据，再将多行结果组合成一个支持别名的虚拟表。主要解决select使用UDTF做查询的过程中查询只能包含单个UDTF，不能包含其它字段以及多个UDTF的情况。 语法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias (‘,’ columnAlias)
columnAlias是给udtf(expression)列起的别名。tableAlias 虚拟表的别名。 lateral view函数会将lUDTF生成的结果放到一个虚拟表中，然后这个虚拟表和输入行进行join来达到连接UDTF外的select字段的目的。
使用方式：
举例1：与explode() 函数连用
--测试表的数据结构，可以看到第一列是id(string类型),第二列是rule_array(array&lt;string&gt;类型) &gt; desc test_2; --结果： +-------------+----------------+----------+ | col_name | data_type | comment | +-------------+----------------+----------+ | id | string | | | rule_array | array&lt;string&gt; | | +-------------+----------------+----------+ --查看测试表的内容 &gt; select * from test_2; --结果： +------------+----------------------------------------+ | test_2.id | test_2.rule_array | +------------+----------------------------------------+ | a | ["501","502","503","501","512"] | | b | ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1dbbfc78192b08b24f67b9ea58d0b97/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/583/">«</a>
	<span class="pagination__item pagination__item--current">584/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/585/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>