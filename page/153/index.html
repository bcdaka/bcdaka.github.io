<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a5d1543127ed6ee6e275c75cb11ed0/" rel="bookmark">
			负载均衡的艺术：Eureka驱动的分布式服务网格负载均衡策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负载均衡的艺术：Eureka驱动的分布式服务网格负载均衡策略 在微服务架构的复杂网络中，服务的负载均衡是确保系统稳定性和可扩展性的关键。服务网格（Service Mesh）作为微服务间通信的代理层，承担着流量管理、服务发现、负载均衡等重要职责。Eureka，作为Netflix开源的服务发现框架，虽然不直接提供服务网格的完整实现，但其服务发现能力是构建服务网格负载均衡的基础。本文将深入探讨如何在Eureka中实现服务的分布式服务网格负载均衡，包括服务发现、智能路由、负载均衡算法等关键技术，并提供代码示例。
一、负载均衡：微服务性能的加速器 负载均衡在服务网格中的作用包括：
流量分配：合理分配进入的流量到多个服务实例。性能优化：避免单点过载，提高系统吞吐量。故障隔离：隔离故障实例，保证服务的高可用性。 二、Eureka在服务网格负载均衡中的角色 Eureka可以为服务网格负载均衡提供以下支持：
服务注册与发现：服务实例在Eureka中注册，客户端通过Eureka发现服务实例。健康状态监控：Eureka提供心跳机制，监控服务实例的健康状态。客户端负载均衡：Eureka客户端可以集成到服务网格的Sidecar代理中，实现客户端负载均衡。 三、实现服务网格负载均衡的关键技术 1. 服务发现与健康检查 使用Eureka进行服务发现，并结合健康检查选择健康的服务实例。
// 使用Eureka客户端发现服务实例 public class EurekaServiceDiscovery { private final EurekaClient eurekaClient; public EurekaServiceDiscovery(EurekaClient eurekaClient) { this.eurekaClient = eurekaClient; } public List&lt;InstanceInfo&gt; discoverHealthyInstances(String appName) { return eurekaClient.getInstancesByApp(appName).stream() .filter(instance -&gt; instance.isUp()) .collect(Collectors.toList()); } } 2. 客户端负载均衡 在服务网格的Sidecar代理中实现客户端负载均衡。
// 伪代码，展示客户端负载均衡逻辑 public class ClientSidecarLoadBalancer { private final EurekaServiceDiscovery serviceDiscovery; public ClientSidecarLoadBalancer(EurekaServiceDiscovery serviceDiscovery) { this.serviceDiscovery = serviceDiscovery; } public Server chooseServer(String appName) { List&lt;InstanceInfo&gt; instances = serviceDiscovery.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8a5d1543127ed6ee6e275c75cb11ed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19cccc3fb861d9cfd774298a75e41c4/" rel="bookmark">
			【Qt】信号与槽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 小羊失眠啦.
🎥系列专栏：《C语言》 《数据结构》 《C++》 《Linux》 《Qt》
❤️感谢大家点赞👍收藏⭐评论✍️
一、什么是信号与槽 信号槽，是Qt的核心机制，用来实现对象之间的通信： 即，某个对象，想通知另一个对象去做某件事情时, 这个对象，就发送某个“信号”， 另一个对象收到这个信号后，就去做之前约定好的那个 特定的事情。
信号槽机制有：
1）信号的发送者
2）信号的接受者
3）发送者发送的这个信号（不需要程序员去定义函数体的空壳函数）
4）接收者去执行的某个函数（称为：槽）
我们要做：
1.信号槽需要在使用之前，做好关联（信号和槽之间的关联）
2.发送者在需要的时候，发送这个信号
问题：为什么不直接使用C/C++的回调函数，而去使用信号槽？
1）信号与槽，是松耦合的，信号发送者，不需要去了解接收者的具体信息（有哪些接口等） 回调函数，是紧密耦合，直接调用目标对象的特定函数。
2）信号槽，比回调函数，使用起来更灵活。
信号与槽缺点
使用信号槽，比使用回调函数，运送速度慢： 信号与槽函数执行，可能是异步的（仅使用直连方式连接信号槽时，槽函数才会被同步执行，执行完之后，发送信号（emit)语句之后的代码才会被执行。
使用回调函数，都是同步方式执行的。
二、信号与槽的关联 2.1 connect函数 写法一
使用SIGNAL和SLOT,把信号和槽转换成constchar*字符串
注意：
使用connect关联时，信号和槽，如果有参数，必须带上参数的类型（不需要带参数变量）
可以把QObject::省略，因为MainWindow本身就是QObject的子类，可以直接使用父类的方法。
信号和槽不需要、也不能使用类名进行限定，直接写函数名以及新参列表即可。
写法二
直接使用信号和槽函数的地址，但是要求： 信号和槽的参数个数相同，而且能够进行合适的隐式类型转换，合作就会编译失败
注意：该方式，信号和槽，需要使用类名进行限定！
合法使用：
MainWindow::MainWindow(QWidget*parent) :QMainWindow(parent) ,ui(newUi::MainWindow) { ui-&gt;setupUi(this); connect(ui-&gt;lineEdit, &amp;QLineEdit::textChanged, ui-&gt;label, &amp;QLabel::setText); } 2.2 自动连接 在QtCreator 的设计器中，右键单击控件，选择“转到槽”
再选择信号
然后自动生成一个空的槽函数（自动生成这个槽函数的声明和一个空的实现）：on_信号发送者的对象名_信号名
槽函数的具体实现，需要自己完成。
注意： 也可以直接按照 这个命名规则手写一个槽函数，就可以实现信号槽的关联！ Qt 框架，会通过这个槽函数的命名，来自动识别信号的发送者、信号名 （程序员一般不使用这个方式，虽然是支持的，因为容易出错，而且比较麻烦）
注意：
这种方式连接的信号槽，必须在槽函数对应的访问权限后加 slots
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a19cccc3fb861d9cfd774298a75e41c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1033cce0406c7d0b0245d97f8ccc587/" rel="bookmark">
			Haproxy负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx 四层转发 七层代理
lvs 四层转发内核态 用户态
Haproxy 四层转发，七层转发
1、Haproxy的作用和使用场景 1、场景 主要用户高并发的web场景，可以支出1万个以上的并发请求，高性能的tcp和http的负载均衡器。
2、工作原理 haproxy就像LVS的调度器，高可用即实现两台haproxy服务器一主一备。
3、作用 1、进行四层和七层转发
2、主持https
3、haproxy本身不自带缓存功能，可以在请求当中添加cookie，使用缓存功能
4、支持主备切换（keepalive）
4、特点 可靠性高，稳定性好
可以同时维护4万-5万并发，单位时间内可以处理的最大请求数是2万个（单位时间：1秒或者1分钟）
支持负载均衡算法，虽然不带缓存，但是可以支持会话保持
rr
wrr
leastconn
5、实验 Haproxy安装
#haproxy安装包存放在/opt cd /opt tar -xf haproxy-1.5.19.tar.gz mv haproxy-1.5.19 haproxy cd haproxy/ uname -r #查看本机的内核版本 make TARGET=linux2628 ARCH=x86_64 #TARGET内核版本要低于本机的内核版本，架构是x86_64 make install mkdir /etc/haproxy cd examples cp haproxy.cfg /etc/haproxy 对haproxy配置文件进行设置
vim /etc/haproxy/haproxy.cfg global #4-5行 log /dev/log local0 info log /dev/log local1 notice maxconn 4096 #最大连接数，推荐使用10240,需要系统内核参数修改最大打开文件数 #注释下一行 #chroot /usr/share/haproxy #添加下一行 nbproc 4 #Haproxy的并发线程数，设置的数量最好是CPU的2倍或者和CPU保持一致 defaults #默认参数配置，包括连接配置、监听配置以及代理配置 option httplog #类型 http日志 retries 3 #检查节点服务器3次，连续3次失败，就认为节点服务器不可用 redispatch #服务器负载很高时，自动结束当前队列中处理比较久的连接 maxconn 2000 #最大连接数，不能超过global设置的maxconn #下面三行注释掉，已经不用了 #contimeout #clitimeout #srvtimeout timeout http-request 10s #http请求的默认超时时间 timeout queue 1m #在队列当中请求的超时时间 timeout connect 10s #连接超时时间 timeout client 1m #客户端超时时间 timeout server 1m #服务端超时时间 timeout http-keep-alive 10s #默认长连接的超时时间（不是会话保持） timeout check 10s #检查后端服务器的超时时间 #转发请求的设置，既可以是四层，也可以是七层 #四层和七层择其一，不要都写 #七层转发的配置 listen yang1 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1033cce0406c7d0b0245d97f8ccc587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aaa5a06807f2477b3ccff7d1ed21598/" rel="bookmark">
			C&#43;&#43;初阶：类和对象（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨所属专栏：C++✨✨
✨✨作者主页：嶔某✨✨
类的默认成员函数 默认成员函数就是用户没有显式实现，编译器会⾃动⽣成的成员函数称为默认成员函数。⼀个类，我们不写的情况下编译器会默认⽣成以下6个默认成员函数，需要注意的是这6个中最重要的是前4个，最后两个取地址重载不重要，我们稍微了解⼀下即可。
其次就是C++11以后还会增加两个默认成员函数，移动构造和移动赋值，这个我们后⾯再学习。默认成员函数很重要，也⽐较复杂，我们要从两个⽅⾯去学习：
• 第⼀：我们不写时，编译器默认⽣成的函数⾏为是什么，是否满⾜我们的需求？
• 第⼆：编译器默认⽣成的函数不满⾜我们的需求，我们需要⾃⼰实现，那么如何⾃⼰实现？
初始化和清理 构造函数 构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是构造函数的主要任务并不是开空间创建对象(我们常使⽤的局部对象是栈帧创建时，空间就开好了)，⽽是对象实例化时初始化对象。构造函数的本质是要替代我们以前Stack和Date类中写的Init函数的功能，构造函数⾃动调⽤的特点就完美的替代的了Init。
1. 函数名与类名相同。
2. ⽆返回值。(返回值啥都不需要给，也不需要写void，C++规定如此)
3. 对象实例化时系统会⾃动调⽤对应的构造函数。
4. 构造函数可以重载。
5. 如果类中没有显式定义构造函数，则C++编译器会⾃动⽣成⼀个⽆参的默认构造函数，⼀旦用户显式定义编译器将不再⽣成。
6. ⽆参构造函数、全缺省构造函数、我们不写构造时编译器默认⽣成的构造函数，都叫做默认构造函数。但是这三个函数有且只有⼀个存在，不能同时存在。零参构造（不用传参数的构造函数） == 默认构造
class Date { public: // 1.⽆参构造函数（是默认构造） /*Date() { _year = 1; _month = 1; _day = 1; }*/ // 2.带参构造函数（不是默认构造） /*Date(int year, int month, int day) { _year = year; _month = month; _day = day; }*/ // 3.全缺省构造函数（是默认构造） Date(int year = 1, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aaa5a06807f2477b3ccff7d1ed21598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca4e99fe94e753778f9747eaa1367aa/" rel="bookmark">
			指针！！C语言(第一篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针1 指针变量和地址1.取地址操作符(&amp;)2.指针变量和解引用操作符(*) 指针变量的大小和类型指针的运算特殊指针1.viod*指针2.const修饰指针3.野指针 assert断言指针的使用和传址调用1.strlen的模拟实现2.传值调用和传址调用 指针变量和地址 在认识指针之前，我们先引入一个实际生活的例子，比如我们要找一个小区内的房子，如果我们知道它在具体的几号楼，房间编号是多少的话那我们就很容易找到。那么对照到计算机中，我们知道CPU读取数据也是在内存中读取，存储数据也同样在内存中，如果将内存也分成一个个编号和一个个空间，那我们寻找一个数据岂不是更快更便捷？
其实在计算机中我们同样也是将内存划分为一个个内存单元，一个内存单元取一个字节，也就是8个比特位，每个内存单元也都有一个编号（这个编号就相当于小区房间的门牌号），有了这个内存单元的编号，CPU就可以快速找到一个内存空间。生活中我们把门牌号也叫地址，在计算机中我们把内存单元的编号也称为地址。C语言中给地址起了新的名字叫：指针。所以我们可以理解为：内存单元的编号 = 地址 = 指针。
1.取地址操作符(&amp;) 理解了内存和地址的关系，我们再回到C语言，在C语言中创建变量其实就是向内存申请空间，比如：
2.指针变量和解引用操作符(*) 指针变量：那我们通过取地址操作符(&amp;)拿到的地址是⼀个数值，比如：0x006FFD70，这个数值有时候也是需要存储起来，方便后期再使用的，那我们把这样的地址值存放在哪里呢？答案是：指针变量中。下面展示一些 内联代码片。
#include &lt;stdio.h&gt; int main() { int a = 10; int* p = &amp;a;//取出a的地址并且存在指针变量p中 return 0； } 指针变量也是一种变量，这种变量就是用来存放地址的，存放在指针变量中的值都会理解为地址。
解引用操作符： 当我们把一个变量存储在一个指针变量中，如果我们要使用这个指针变量的话，我们要怎样使用呢?
下面展示一些 内联代码片。
#include &lt;stdio.h&gt; int main() { int a=10; int* pa=&amp;a; *pa=20;//将a中的数值改为20 printf("%d\n",a); return 0; } 在上面的代码中， *pa 的意思就是通过pa中存放的地址，找到指向的空间 *pa其实就是a变量了；所以 *pa = 20，这个操作符就是把a改成了20，也就是通过指针来修改a变量中存的数值。
指针变量的大小和类型 首先我们要知道指针变量也是有大小，指针变量的大小是通过字节来判断的，指针变量的大小取决于地址的大小：
比如：32位平台下地址是32个bit位（即4个字节），64位平台下地址是64个bit位（即8个字节）
虽然所占字节大小与类型无关，但是类型仍然是有意义的，决定了它解引用时候的权限，例如int* pa=&amp;a；char* pc=&amp;a；假如给a重新赋一个值0，就会发现通过调试int类型中的字节全部变为0，而char类型中的字节只有第一个字节变为0。
指针的运算 指针+ - 整数：指针也有运算，例如对于整型指针的加减&amp;a→&amp;a+1，就将指针的地址移动了4个字节，但如果是char类型的话，就只移动1个字节，也就是说不同类型的指针移动的字节大小是不相同的。
指针-指针：指针-指针的绝对值是指针和指针之间元素的个数，但是两个指针指向的是同一块空间才可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca4e99fe94e753778f9747eaa1367aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beed271a723f8224c5c86237258aa064/" rel="bookmark">
			如何将备忘录从 iPhone 传输到Android [4 种方法]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将备忘录从 iPhone 转移到 Android 设备可能因为操作系统差异而显得复杂，但以下方法将帮助您轻松完成这个过程。
方法 1：通过电子邮件将 iPhone 备忘录传输到 Android 此方法适用于那些希望利用现有电子邮件服务来传输较小备忘录文件的用户。您可以将备忘录作为电子邮件附件发送到自己常用的电子邮箱，然后在 Android 设备上登录相同的邮箱账户下载附件。
步骤 1：在 iPhone 上打开“备忘录”应用，选择要传输的备忘录，点击共享图标。
步骤 2：选择“邮件”，输入您的邮箱地址，发送。
步骤 3：在 Android 设备上接收邮件，下载附件。
方法 2：通过云服务迁移备忘录 对于希望在不同设备间无缝同步备忘录的用户，云服务提供了一个便捷的解决方案。例如，如果您使用的是华为手机，可以使用华为云服务来同步备忘录。首先在 iPhone 上开启 iCloud 同步备忘录，然后在 Android 设备上登录相应的云服务账户，下载同步的备忘录。
方法 3：通过第三方应用在 iPhone 和 Android 间共享备忘录 第三方备忘录应用如 Evernote 或 WPS Office 提供了跨平台同步的功能，允许用户在不同操作系统的设备间共享备忘录。您可以在 iPhone 上创建或同步备忘录到这些应用，然后在 Android 设备上登录相同账户，查看和编辑备忘录。
方法 4：通过 Smart Switch 将 Apple 备忘录发送到三星 Smart Switch 是三星提供的一款应用，旨在帮助用户将数据从其他品牌手机迁移到三星手机。对于希望将 iPhone 上的备忘录转移到三星手机的用户，可以通过 iCloud 同步备忘录，然后使用 Smart Switch 应用从 iCloud 导入备忘录。
使用 Coolmuster Mobile Transfer 传输其他文件 Coolmuster Mobile Transfer 是一款强大的数据迁移工具，支持在 iOS 和 Android 设备之间传输多种类型的文件，包括备忘录。该工具提供了一个用户友好的界面，使得数据迁移过程简单快捷。您只需在计算机上安装该程序，连接您的 iPhone 和 Android 设备，选择要传输的文件类型，然后开始迁移过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beed271a723f8224c5c86237258aa064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b49f8ffd38ae11fc678b50aebfd0d6/" rel="bookmark">
			Day53:图论 岛屿数量 岛屿的最大面积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		99. 岛屿数量
时间限制：1.000S 空间限制：256MB
题目描述 给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。
输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。
后续 N 行，每行包含 M 个数字，数字为 1 或者 0。
输出描述 输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。
输入示例 4 5 1 1 0 0 0 1 1 0 0 0 0 0 1 0 0 0 0 0 1 1 输出示例 3 提示信息 根据测试案例中所展示，岛屿数量共有 3 个，所以输出 3。
数据范围：
1 &lt;= N, M &lt;= 50
思路:
注意题目中每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
也就是说斜角度链接是不算了
本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。
在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。
dfs:
import java.util.*; class Main{ public static void main(String[] args){ int n,m; Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b49f8ffd38ae11fc678b50aebfd0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d523971b244f5236c73d795f225ad4d3/" rel="bookmark">
			塑胶件缺胶影响工业生产，云盘科技提供解决方案！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 塑料件的成型检测，主要检测其中的各种高低、形状的柱子、块块、条条之类的。因为有一些产品在成型时，可能柱子没有足够的料，又或者是某个挡块只有一半这样的。所以需要进行一定的检测。
塑胶在注塑加工成型后，出现缺胶缺陷。思普泰克推荐使用云盘高速视觉检测机。
云盘高速视觉检测机，因为需要考虑在高度方向成像，因此常规的正视图成像，可能无法查看其是否有相关的零部件部分。这里有两种方法可以考虑，一是将产品（或相机）倾斜，从侧面来查看产品是否满足要求。另一个是使用3D相机进行拍摄，得到其相关的高度曲线。不过无论使用哪种方法，都有可能面临阴影、阻挡等问题。因此建议使用圆顶无影光源、四面无影光源等无影系列的光源。效果应该会好一点。
检测效果
缺胶
塑胶制品光学筛选机_视觉检测设备_光学筛选机_CCD视觉检测_外观缺陷检测-思普泰克塑胶制品光学筛选机是一种利用光学传感器和图像处理技术进行筛选、分类和检测的设备。这种设备通常用于对塑胶制品进行自动化的质量检测和筛选，以确保产品的质量和一致性。 工作原理--------------------------------------------------------------------------------------------通过光学传感器获取产品表面的图像信息，然后利用https://www.sipotekccd.com/shijuejiance/398.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3bbeb21c3dec086fdca6b3de9bd3916/" rel="bookmark">
			数据结构之初始二叉树（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
二叉树的前置知识（概念、性质、、遍历）
通过上篇文章的学习，我们已经知道什么是二叉树，以及其性质和遍历的方式了。接下来主要是实现代码。
目录
伪创建二叉树
遍历二叉树 获取二叉树中节点的个数 获取二叉树中叶子节点的个数
获取二叉树中第K层节点的个数
获取二叉树的高度 在二叉树中找寻元素 伪创建二叉树 为啥叫伪创建二叉树呢？因为我们现在才刚开始学习二叉树，而创建二叉树是一个非常复杂的过程（树的递归定义的）。因此我们就先手动的来创建二叉树。树是有一个一个的结点组成，因此得先把结点创建出来。树的结点我们采用的是简单的孩子表示法：
// 树的结点 static class TreeNode { public char val; // 数据域 public TreeNode left; // 左子树 public TreeNode right; // 右子树 public TreeNode(char val) { this.val = val; } } 创建的二叉树图形如下：
public TreeNode createBinaryTree() { TreeNode A = new TreeNode('A'); TreeNode B = new TreeNode('B'); TreeNode C = new TreeNode('C'); TreeNode D = new TreeNode('D'); TreeNode E = new TreeNode('E'); TreeNode F = new TreeNode('F'); TreeNode G = new TreeNode('G'); // 根据图形关系把结点之间相连 A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3bbeb21c3dec086fdca6b3de9bd3916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b734a5bfaa8e67e465bcb6395be71b1/" rel="bookmark">
			vue检测页面手指滑动距离，执行回调函数，使用混入的语法，多个组件都可以使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mixin.ts
定义滑动距离的变量和检测触摸开始的方法，滑动方法，并导出两个方法
sendTranslateX.value &gt; 250 &amp;&amp; sendTranslateY.value &lt; -100是向上滑动，满足距离后执行回调函数func，并在一秒内不再触发，一秒后清空距离并允许再次触发。
// touch----mixins import { ref } from "vue"; import { useRouter } from "vue-router"; const userEntityMixin = { setup() { const router = useRouter(); let sendTranslateX = ref(0); let sendTranslateY = ref(0); let sendoriginX = 0; let sendoriginY = 0; const sendTouchStart = event =&gt; { sendoriginX = event.touches[0].screenX; sendoriginY = event.touches[0].screenY; }; let jumpOnce = false; const sendTouchMoveEvent = (e, func) =&gt; { if (sendTranslateX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b734a5bfaa8e67e465bcb6395be71b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c81feb8ee0838d81dd126fe399cb171/" rel="bookmark">
			【OrangePi AIpro】: 探索AI加成的开源硬件魅力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 Orange Pi: 探索开源硬件的魅力引言Orange Pi概述OrangePi AIPro产品介绍试用体验安装前准备开机联网体验 AI 应用样例Image_HDR_Enhance样例CartoonGAN 图像风格迁移 开源项目--给视频人物加上眼线 写在最后负载能力散热效能噪音控制 Orange Pi: 探索开源硬件的魅力 引言 在嵌入式系统的世界里，开源硬件平台如Raspberry Pi和Arduino早已成为创新者、教育者和爱好者的首选。然而，在这个领域中，还有一颗璀璨的明星——Orange Pi。本文将深入探索Orange Pi的起源、特点以及其在教育、项目开发和物联网应用中的潜力。
Orange Pi概述 什么是Orange Pi？
Orange Pi是深圳市橙子科技有限公司开发的一系列开源单板计算机（SBC）。它以提供高性价比的硬件解决方案而闻名，旨在为开发者提供一个功能强大且成本低廉的开发平台。
历史与背景
Orange Pi项目始于2014年，起初是为了与Raspberry Pi竞争，但很快发展出自己的特色。Orange Pi不断推出新的版本，从最初的H2+到后来的Zero Plus2、Orange Pi 4等，每一款都针对不同的需求进行了优化。
OrangePi AIPro产品介绍 特性描述处理器4核64位处理器 + AI处理器AI算力支持8-12TOPS内存8GB / 16GB LPDDR4X存储可外接32GB / 64GB / 128GB / 256GB eMMC模块图形处理器集成显示输出双4K HDMI输出- HDMI输出x2- M.2插槽支持SATA/NVMe SSD 2280- USB 3.0x2- Micro USB（串口打印调试功能）- MIPI摄像头接口x2- 电池接口预留应用领域AI边缘计算、深度视觉学习、视频流AI分析、视频图像分析、自然语言处理、智能小车、机械臂、人工智能、无人机、云计算、AR/VR、智能安防、智能家居等操作系统支持Ubuntu, openEuler用途AI算法原型验证、推理应用开发 详情查看官网链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c81feb8ee0838d81dd126fe399cb171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80999cef80de29592bc90fb8c1894d7/" rel="bookmark">
			VGMShield：揭秘视频生成模型滥用的检测与追踪技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频生成模型，如 Stable Video Diffusion 和 Videocrafter，已经能够生成合理且高分辨率的视频。但这些技术进步也带来了被恶意利用的风险，比如用于制造假新闻或进行政治宣传。因此，来自弗吉尼亚大学和亥姆霍兹信息安全中心（CISPA）的研究团队着手开发了 VGMShield，一套旨在降低视频生成模型滥用风险的综合解决方案：
现实世界中的参与者分为三个不同的实体：创建者（Creator）、修改者（Modifier）和消费者（Consumer）。创建者可能是摄影师或记者，他们上传信息供消费者使用。修改者可能会恶意使用这些图像生成误导消费者的视频。为了解决视频生成模型带来的安全隐患，研究者提出了一个包含假视频检测、假视频来源追踪和滥用预防的综合防御框架。
消费者 (Consumer)、创建者 (Creator) 和修改者 (Modifier) 在信息/内容生成和消费周期中的角色 假视频检测和追踪 潜在的威胁模型基于两个关键因素：视频来源和生成视频所使用的模型。检测任务分为四种场景：在目标检测中，检测器不仅知道可能生成视频的模型，还知道用于生成视频的数据源。这种场景虽然理想化，但为研究者提供了一个起点，以理解在最佳条件下模型的表现。第二，数据盲检测，其中检测器知道视频的来源，但对生成视频使用的数据分布一无所知。模型盲检测则相反，检测器知道数据分布，但不知道使用的是哪种模型。最后，开放检测是一个更为现实和具有挑战性的场景，检测器对数据源和模型都一无所知。
假视频检测和追踪的不同场景，包括数据和模型的知识情况 研究者们在构建假视频检测和追踪方法时，将这个问题转化为了分类任务。他们基于一个关键假设：假视频会在空间维度上展示出异常特征，同时在时间维度上表现出不一致性。为了识别这些异常，研究者们选择了几种预训练的视频识别模型，这些模型能够理解视频的时空动态。他们选用的模型包括 Inflated 3D ConvNet (I3D)、X-CLIP 和 Video Masked Autoencoders (MAE)，每种模型都以其独特的方式处理视频数据。
在检测部分，研究者们根据不同的应用场景调整了模型的训练方法。他们遵循两个基本原则：首先，为了应对开放检测设置，他们确保训练集尽可能多样化，包含了大量的真实和假视频；其次，当任务更加具体时，例如检测器需要识别特定模型或数据分布生成的视频，他们会缩小训练集的范围，使其更贴近实际任务的需求。
在追踪源模型的过程中，研究者们采取了一种假设所有视频均为假视频的方法，并使用多标签分类模型来确定视频可能来源于的九种不同模型之一。与检测任务不同，追踪任务的训练涉及到所有这些模型生成的假视频，这样做可以帮助模型学习到每种模型生成视频的独特特征。
为了验证所提出方法的有效性，研究者采用了两个广泛使用的数据集：WebVid-10M和InternVid，来进行评估。这些数据集拥有大量的视频和相应的文本描述，为训练和评估机器学习模型提供了丰富的资源。研究者进一步收集了所有可用的开源视频生成模型，并针对每一种模型生成了1000个视频，这些视频随后被用于检测和追踪任务。
假视频检测的实验流程 图2展示了假视频检测的实验流程。为了确保真实视频和假视频具有相似的分布特征，研究者们采用了一种特定的方法来生成假视频。这种方法利用了真实视频的第一帧（以及可能伴随的字幕）来生成对应的假视频。这样的处理旨在最小化真实视频和假视频之间的差异，从而使得检测模型不能依赖于其他特征（例如，真实视频总是关于动物的，而假视频总是关于汽车的）。
分类模型由两部分组成：一个作为主干的视频识别模型，以及一个全连接的模型。这个全连接的模型被训练来识别和区分真实视频和假视频。视频识别模型负责提取视频中的关键特征，而全连接层则用于学习如何根据这些特征来区分视频的真实性。通过在真实视频和假视频上训练这个复合模型，研究者们旨在提高检测系统的性能和准确性。这种训练方法有助于模型更好地理解真假视频之间的微妙差异，从而在实际应用中更有效地识别出假视频。
实验的详细参数，包括输入帧数、训练周期、学习率等 研究者展示了在不同数据集和多种生成任务中应用三种检测模型的结果。他们发现，Video Masked Autoencoders（MAE）模型在各种场景下都展现出了稳定性和高效性，尤其是在开放检测设置中，MAE模型的检测准确率显著高于其他模型。
使用不同的检测模型（X-CLIP, MAE, I3D）在 WebVid-10M 数据集上构造视频时的检测结果 MAE 基础的假视频检测模型在 InternVid 数据集上四种设置下的性能 研究者展示了在数据知情和数据不知情两种设置下，使用X-CLIP、I3D和MAE作为后端的追踪模型的性能。特别地，在数据不知情的设置中，即使面对未知数据源的视频，MAE模型仍然能够保持高达90%的准确率，显示出其在追踪任务上的鲁棒性。
在数据感知和数据不可知设置下，使用 Webvid 和 InternVid 数据集的源追踪结果 研究者们采用了Grad-CAM技术来深入分析模型的决策过程。Grad-CAM（梯度类激活映射）是一种可视化技术，它能够展示模型在做出分类决策时所关注的视频区域。通过这种方式，研究者们可以直观地理解检测模型是如何识别出假视频的。
使用 Grad-CAM 展示了 I3D 和 MAE 检测模型在 InternVid-SVD 生成任务中做出检测决定的具体方面 研究者们首先观察了基于I3D和MAE的检测模型，这两种模型在假视频检测上都取得了超过90%的准确率。通过Grad-CAM生成的热图，研究者们发现这些模型主要依赖于视频中的对象来进行判断。例如，I3D模型倾向于关注人脸、栅栏、手指和引擎电池等对象，而MAE模型则集中于识别如下水道盖、人体和手指等异常对象。
源追踪模型依赖于视频中不同位置的特征来确定生成模型 研究者们还注意到，MAE模型在检测时空异常方面表现得更为灵活和敏感。与I3D模型相比，MAE模型不仅能够识别出对象在空间维度上的扭曲，还能够察觉到对象在时间维度上的不连贯性。例如，如果视频中的排水管在连续帧之间发生了明显的形状变化，MAE模型能够捕捉到这种变化，并据此判断视频为假。
通过Grad-CAM的分析，研究者们得出结论，MAE模型之所以在假视频检测上表现更为出色，是因为其能够同时关注视频中的时空异常，而不仅仅是空间上的失真。这一发现对于进一步优化和改进假视频检测技术具有重要意义。
滥用预防 与文本到视频的生成任务相比，图像到视频的生成任务更容易被滥用，因为存在修改者可能恶意使用这些技术。为了防止这种情况，研究者们设计了一种基于对抗性样本的防御机制，专门针对图像到视频的生成任务。
对抗性样本最初是为了解决分类问题而引入的，通过向原始图像中添加对人类视觉不可见但能导致神经网络做出错误判断的小扰动。研究者们采用类似的方法，创建对抗性样本来干扰视频生成模型，使模型的编码器误解输入图像，从而产生不正确和异常的视频帧，保护原始图像不被滥用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80999cef80de29592bc90fb8c1894d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb357bb89c9a6a9e911cadf6bf0d4888/" rel="bookmark">
			【机器人学】2-1.六自由度机器人运动学逆解【附MATLAB机器人逆解代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过上一篇文章​​​​​​六自由度机器人正解已经获得了机器人各连杆间的转换关系。当知道各个连杆的转角1、2、3、4、5、6时可以求出末端执行器的位姿，这个过程称为正向运动学。这篇文章将讨论逆向运动学，即，给定末端执行器的位姿，求解各连杆的转角。在实际生活中逆向运动学更为实用。
现已知末端姿态矩阵和机器人的运动学模型，求解1、2、3、4、5、6。
已知六轴机器人的D-H参数如下所示：
如果不清楚何为改进的DH参数，可以看我的上一篇博客。【机器人学】1-1.六自由度机器人运动学正解 【附MATLAB代码】
关节1关节2关节3关节4关节5关节609000-9090a0042539300d160.700113.39993.60900-9000000000 选用改进型的D-H参数，各矩阵分别如下所示：
设
其中
如果你的机械臂D-H参数结构和我的一致，以上解析解你可以直接使用，如果参数相差不大，可以跟着我的计算思路推导一下你自己的逆解方程，相信你也可以得到正确的结果。
MATLAB仿真验证
function R=AxisAngle_RotMat(Rxyz) theta=(Rxyz(1)^2+Rxyz(2)^2+Rxyz(3)^2)^0.5; if(abs(theta)&lt;1e-8) R=eye(3); return; end r=Rxyz/theta; R=[r(1)^2*(1-cos(theta))+cos(theta) r(1)*r(2)*(1-cos(theta))-r(3)*sin(theta) r(1)*r(3)*(1-cos(theta))+r(2)*sin(theta) r(1)*r(2)*(1-cos(theta))+r(3)*sin(theta) r(2)^2*(1-cos(theta))+cos(theta) r(2)*r(3)*(1-cos(theta))-r(1)*sin(theta) r(1)*r(3)*(1-cos(theta))-r(2)*sin(theta) r(2)*r(3)*(1-cos(theta))+r(1)*sin(theta) r(3)^2*(1-cos(theta))+cos(theta)]; end clc;clear; %带入机器人初始值 d1 = 0.1607; d2 = 0; d3 = 0; d4 = 0.1133; d5 = 0.099; d6 = 0.0936; a1 = 0; a2 = 0; a3 = 0.425; a4 = 0.393; a5 = 0; a6 = 0; %testData1 测试数据 px = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb357bb89c9a6a9e911cadf6bf0d4888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767f936ce25dcbe428502159263270cf/" rel="bookmark">
			XML 解析异常问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 The parser has encountered more than "64000" entity expansions in this document; this is the limit imposed by the JDK.
在运行 Java 应用程序时，出现了 XML 解析异常。具体表现为：
报错信息显示无法创建 StAX（Streaming API for XML）解析器，具体原因是超过了 JDK 默认的 64,000 个实体扩展限制。
以下是日志中的关键部分：
Exception in thread "Thread-6" com.sun.xml.internal.ws.streaming.XMLReaderException: Unable to create StAX reader or writer at com.sun.xml.internal.ws.api.streaming.XMLStreamReaderFactory.create(XMLStreamReaderFactory.java:359) ... Caused by: javax.xml.stream.XMLStreamException: Parser error at [row,col]:[1,1] Message: JAXP00010004: The parser has encountered more than "64000" entity expansions in this document; this is the limit imposed by the JDK.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/767f936ce25dcbe428502159263270cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46f715dce68d25f5516c395e410ff32/" rel="bookmark">
			一些简单的基本知识（与C基本一致）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、注释 1.单行注释：//（快捷键：ctrl+shift+？，可以选择多行）
2.多行注释：/* 文本 */
二、变量 变量的作用是给一段内存空间起名，方便操作内存中的数据。
通过赋予某数据的变量来指代该数据，而不是通过地址指代，因为地址比较复杂。
创建语法：数据类型 变量名称 = 变量初始值（int a = 10;）
eg：
#include &lt;iostream&gt; using namespace std; int main() { int a = 10; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; system("pause"); return 0; } 三、常量 常量用于记录程序中不可更改的数据。
两种定义方式：
1.#define 宏常量：通常在文件上方定义，表示一个常量。
#define 常量名 常量值 2.const修饰的变量：通常在变量前面加关键字const，修饰该变量为常量，不可更改。
const 数据类型 常量名 = 常量值 其中，a，b都为常量，一旦修改就会报错“表达式必须是可修改的左值（出现在赋值符号左边的值）”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd251f36bfcb797ef1428a462984312/" rel="bookmark">
			dhtmlx-gantt甘特图数据展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网文档：甘特图文档
实现效果：
首先需要下载 dhtmlx-gantt组件
npm i dhtmlx-gantt //我项目中使用的是"dhtmlx-gantt": "^8.0.6" 这个版本，不同的版本api或是文档中存在的方法稍有差异 界面引用
&lt;template&gt; &lt;div id="ganttPhtot" ref="ganttPhtot" class="gantt-container" style="height:100%" /&gt; &lt;/template&gt; &lt;script&gt; import gantt from 'dhtmlx-gantt' //引入组件 export default{ data() { return { // 甘特图的数据 tasks: { data: [], links: [] }, } } } &lt;/script&gt; 调用接口获取数据
methods:{ //获取接口数据 getQueryMaturity(){ const {data} = await getMatuity() this.tasks.data = data.row gantt.clearAll() //清空甘特图数据 //gantt.config.scales 这个是设置时间的，根据项目需要，设计年月，或者周天 gantt.config.scales = [ // { unit: 'day', step: 1, date: '%d %M' } // { unit: 'year', step: 1, format: '%Y' } // 显示年份 { unit: 'year', step: 1, format: '%Y' }, // 显示年份 { unit: 'month', step: 1, format: '%M' } // 显示月份 ] gantt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd251f36bfcb797ef1428a462984312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0210b4df285efca7cb8cd2cf5112b831/" rel="bookmark">
			Diffusion【1】：SDSeg——基于Stable Diffusion的单步扩散分割！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言AbstractIntroductionMethodsLatent EstimationConcatenate Latent FusionTrainable Vision Encoder ExperimentDatasets and Evaluation MetricsImplementation DetailsExperimental SettingsInference Stage Main ResultsComparison with State-of-the-ArtsComparison of computing resource and time efficiencyStability EvaluationAblation Study 总结 前言 和大家分享一下我们发表在 MICCAI 2024 （CCF-B，医学图像处理方面的顶会，最后得分 54） 上的论文：Stable Diffusion Segmentation for Biomedical Images with Single-step Reverse Process。
项目主页：
Stable-Diffusion-Seg
欢迎大家在 arxiv 上阅读：
Stable Diffusion Segmentation for Biomedical Images with Single-step Reverse Process
代码已经开源！！！期待您的 Star！！！
Stable Diffusion Segmentation (SDSeg)
Abstract 扩散模型已经在各种生成任务中证明了它们的有效性。然而，当应用于医学图像分割时，这些模型遇到了几个挑战，包括显著的资源和时间需求。它们还需要一个多步骤的逆向过程和多个样本来产生可靠的预测。为了应对这些挑战，我们介绍了第一个潜在扩散分割模型，名为 SDSeg，建立在稳定扩散（SD）之上。SDSeg 采用了一种简单的潜在估计策略，以促进单步逆向过程，并利用潜在融合连接去除了对多个样本的需求。广泛的实验表明，SDSeg 在五个具有不同成像方式的基准数据集上超越了现有的最先进方法。值得注意的是，SDSeg 能够通过单一的逆向步骤和样本生成稳定的预测，体现了模型以其名称所暗示的稳定性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0210b4df285efca7cb8cd2cf5112b831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf49f059a27383247ff9ea727cbbb446/" rel="bookmark">
			easyexcel使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.读取行总数只能使用poi
Path excelFilePath = Paths.get(intput); // Use WorkbookFactory to create a Workbook object from the file Workbook workbook = WorkbookFactory.create(excelFilePath.toFile()); // Iterate over each sheet in the workbook for (Sheet sheet : workbook) { // Print sheet name System.out.println("Sheet Name: " + sheet.getSheetName()); // Get the number of rows in the sheet int rowCount = sheet.getPhysicalNumberOfRows(); System.out.println("Number of Rows: " + rowCount); } // Close the workbook to release resources workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf49f059a27383247ff9ea727cbbb446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297f63971154af967354e1d3cbd54b0a/" rel="bookmark">
			7大要点轻松教你小程序SEO如何优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序优化是一个综合性的过程，涉及多个方面，旨在提升小程序的性能和用户体验等。以下是一些主要的小程序优化策略： 一、性能优化
1. 减少页面跳转次数：合理规划页面结构，尽量在一个页面内完成相关操作，避免频繁跳转。
2. 优化数据加载：采用分页加载数据，避免一次性加载大量数据导致卡顿。提前预加载关键数据，提高响应速度。
3. 代码优化：去除冗余代码，精简逻辑。对复杂计算进行异步处理，避免阻塞页面渲染。
二、界面优化
1. 简洁布局：避免页面元素过多过杂，保持界面清晰简洁。
2. 色彩搭配：选择舒适、协调的颜色组合，提高视觉舒适度。
3. 字体和图标：使用清晰易读的字体，合适大小的图标，方便用户识别和操作。
三、用户体验优化
1. 导航清晰：提供明确的导航栏和返回按钮，让用户清楚知道自己所处的位置和操作路径。
2. 交互友好：按钮和输入框要有明确的反馈效果，如点击变色、输入提示等。
3. 适应不同屏幕尺寸：确保小程序在各种设备上都能正常显示和操作。
四、功能优化
1. 定期更新：根据用户反馈和市场需求，不断改进和增加实用功能。
2. 去除冗余功能：对使用率低或不符合用户需求的功能进行删减。
五、搜索优化
1、数据分析：定期分析用户行为数据，找出效果好的内容和推广方式，持续优化策略。密切关注行业趋势和竞争对手动态，以便及时调整运营策略。
2、关键词优化：选择与业务相关、搜索量大、用户意图明确的关键词。确保关键词合理地出现在标题、描述、内容中，避免过度堆砌。
六、网络优化
1. 压缩数据传输：对传输的数据进行压缩，减少流量消耗和传输时间。
2. 优化接口请求：合理设置请求频率，避免频繁请求导致服务器压力过大。
七、测试优化
1. 多设备测试：在不同型号的手机和平板上进行测试，确保兼容性。
2. 收集用户反馈：通过用户评价和反馈，及时发现问题并进行优化。
您可以根据小程序的具体情况，有侧重地进行优化工作，逐步提升小程序的质量和用户满意度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6975c384c819006f6c0f293f0a954bfa/" rel="bookmark">
			如何从 PC 在Android上安装 APK [三种方法]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		APK（Android Package Kit 的缩写）是Android系统用于安装应用程序的工具。尽管有数百万个应用程序可供您选择，但有时您可能想从其他网站安装应用程序。也许您正在寻找的应用程序已过时，或者在您所在的国家/地区不可用。在这种情况下，您需要先将APK文件下载到您的电脑上，然后将其放到您的手机上。那么问题来了：如何从PC上在Android上安装APK？Android手机的优点之一就是其灵活性。您可以轻松地将APK从PC传输到Android。在这里，我们将向您展示完成工作的3种主要方法。
第1部分：如何使用Coolmuster Android Assistant从PC在Android上安装APK（最简单） 说到如何轻松直接地将APK文件从PC传输到Android手机，Coolmuster Android Assistant是您需要的工具。它是一款功能强大的数据管理软件，可让您轻松地将APK文件、照片、视频、音乐、联系人、通话记录、短信等从计算机传输到Android。
Coolmuster Android Assistant的主要特点：
管理Android应用程序：将应用程序从PC安装到Android，将应用程序从Android导出到PC，从PC卸载Android应用程序。备份和恢复Android：一键将整个Android文件备份到计算机，自由地将备份恢复到任何Android设备。计算机和Android之间传输文件：在计算机和Android之间传输短信、联系人、视频、照片、应用程序、音乐等。电脑发送短信：Android手机可以在电脑上发送、回复、转发短信、查看短信。广泛兼容性：适用于三星、HTC、索尼、华为、摩托罗拉、OnePlus等Android品牌。完全支持Android 10。 下载Coolmuster Android Assistant来尝试一下。
Coolmuster Android Assistant： 在计算机上管理 Android 数据Coolmuster Android Assistant 是一款专业的 Android 管理程序，供 Android 用户在 PC 上自由管理 Android 联系人、短信、媒体、应用程序等 Windows 。通过签到了解更多信息。https://www.coolmuster.cn/android-assistant.html
如何使用Coolmuster Android Assistant从PC在Android上安装APK文件：
第1步：在PC上下载Coolmuster Android Assistant
在计算机上下载并安装Coolmuster Android Assistant，打开它并单击Android Assistant。
第2步：将Android连接到PC
使用USB数据线将Android手机连接到计算机，然后按照屏幕上的说明连接手机。当软件检测到您的设备时，您可以看到如下界面：
第3步：将APK文件安装到Android
单击左侧栏中的“应用程序”，然后单击顶部的“安装”按钮，从计算机中选择APK文件，然后单击“打开”将其放入您的Android手机中。
第2部分：如何通过USB从PC在Android上安装APK文件 默认情况下，您的Android手机不允许您安装商店之外的APK文件。但您可以通过Android手机上的“设置”应用授予权限。然后您就可以通过USB从PC安装APK。
将APK文件从计算机传输到Android后，您需要使用文件管理器应用程序找到APK。此应用程序通常预装在您的Android上。如果您没有，您可以从国内应用市场下载免费的文件管理器。
以下是有关如何从计算机在Android上安装APK的说明：
步骤1：从受信任的网站下载APK文件；您可以将其保存到计算机桌面上，以便轻松找到它。
第2步：在Android上，打开“设置”&gt;“应用程序”&gt;点击菜单图标&gt;“特殊访问权限”&gt;启用“安装未知应用程序”。
如果您的手机运行Android Nougat，步骤为：设置&gt;安全/锁屏和安全&gt;找到设备管理部分&gt;启用未知来源。
步骤3：使用USB数据线将Android手机连接至电脑。在Android上，选择USB选项作为MTP。
步骤4：现在转到计算机上的APK文件，右键单击它并选择发送到&gt;选择您的Android设备。然后APK将开始传输到您的手机。
步骤5：传输完成后，打开Android上的文件管理器。
步骤6：找到从您的计算机传输的APK文件，然后点击“安装”。该应用程序将安装在您的Android上。安装完成后，单击“完成”进行确认。
第3部分：如何通过ADB将APK从PC传输到Android 您还可以使用ADB命令从PC在Android上安装APK。ADB代表Android调试桥，它是一个可让您从计算机在Android上执行各种任务的工具。除了从PC安装APK之外，您还可以使用ADB工具卸载应用程序、无密码解锁Android、重新启动Android进入恢复模式等。
了解如何使用ADB将APK从PC传输到Android：
第1步：在计算机上下载Android Debug Bridge
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6975c384c819006f6c0f293f0a954bfa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/152/">«</a>
	<span class="pagination__item pagination__item--current">153/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/154/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>