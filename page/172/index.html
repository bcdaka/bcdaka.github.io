<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f48f1c79895a174ba30e5815c94330/" rel="bookmark">
			基于Eclipse&#43;Mysql&#43;SSM开发的Eshop在线购物网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Eclipse+Mysql+SSM开发的Eshop在线购物网站
项目介绍💁🏻 在当今数字化时代，电子商务已成为连接消费者与商品服务的核心桥梁。为了满足日益增长的网络购物需求，我们计划开发一款名为“WebShop购物商城”的在线购物平台。该项目旨在打造一个集商品展示、用户交互、便捷支付于一体的综合性电商生态系统。
WebShop购物商城将为用户提供无缝的购物体验，从系统主页的精美设计引导用户探索各类商品，到用户注册与登录流程的简化，确保每位访客都能轻松转化为忠实用户。在商品管理方面，商家可以轻松上架新商品，管理库存，并利用平台工具优化商品展示，吸引更多潜在买家。
此外，我们还特别注重用户服务的提升，引入了余额充值功能，方便用户快速完成支付，并享受更多会员特权。用户可以在商品详情页详细了解产品信息，通过在线联系商家功能直接沟通，解决购物过程中的任何疑问。购物车功能的完善，让用户能够自由挑选心仪商品，并在合适时机进行一键结算，享受便捷购物乐趣。
WebShop购物商城的诞生，不仅是为了满足消费者的多元化购物需求，更是为了推动电商行业的创新发展，为商家和消费者搭建起一座高效、安全、便捷的桥梁。
功能模块 WebShop购物商城功能模块介绍
WebShop购物商城精心设计了多个功能模块，以全方位提升用户的购物体验与商家的运营效率。
一、用户中心模块：该模块集成了用户登录、注册及个人信息管理功能。用户可快速注册账号，享受个性化服务；登录后，可查看订单历史、修改个人资料及密码，确保账户安全。此外，用户还能通过余额充值功能，预存资金以便快速支付，享受更多会员优惠。
二、商品展示与管理模块：此模块为商家提供了强大的商品管理工具。商家可以轻松上传商品信息，包括图片、价格、描述等，并设置库存数量，实现商品的高效上架与管理。同时，平台支持商品分类与搜索功能，帮助用户快速找到所需商品。
三、购物车与结算模块：购物车功能允许用户将心仪商品加入购物车，随时查看、修改或删除商品。当用户决定购买时，可通过购物车结算模块完成支付流程。该模块支持多种支付方式，包括余额支付、第三方支付等，确保交易的安全与便捷。
四、在线联系商家模块：为了增强用户与商家之间的互动，WebShop购物商城特别设置了在线联系商家功能。用户可在商品详情页或订单详情页直接联系商家，咨询商品信息、物流状态或售后服务等问题，获得即时解答。
五、用户评价与反馈模块：购物完成后，用户可对购买的商品及商家服务进行评价与反馈。这些评价将作为其他用户购物参考的重要依据，同时也为商家提供了改进产品与服务的宝贵意见。
综上所述，WebShop购物商城的功能模块设计旨在为用户提供便捷、安全、愉悦的购物体验，同时为商家提供高效、全面的运营支持。
。
页面效果 系统的部分功能模块页面如下所示。
系统主页
用户登录
用户注册
商品管理
上架新商品
用户管理
余额充值
商品详情
在线联系商家
加入购物车
购物车结算
运行教程 编号519-Eshop在线购物网站
系统源码 进入公众号，在右上角有放大镜，就是搜索公众号内全部文章的题目，公众号各类的素材和相关的题目都可以通过这个方法来进行搜索。
输入要自己想要看的题材和对应的素材就可以了，因为的将各个类目的题材，都浓缩在题目里面， 所以只要是标题里面有的，或者涵盖了你的题目素材基本上都可以搜索的到。
关注微信公众号 “letcoding”---》源缘编程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e661c4e376b7e8bbdab97f2f5cf7d76/" rel="bookmark">
			C&#43;&#43;：缺省参数|函数重载|引用|const引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到Harper·Lee的学习笔记！
博主主页传送门：Harper·Lee的博客主页
想要一起进步的uu可以来后台找我哦！
一、缺省参数 1.1 缺省参数的定义 缺省参数：是声明或定义函数时为函数的参数指定⼀个缺省值。在调用该函数时，如果没有指定实参则采⽤该形参的缺省值，否则使用指定的实参。（有些地方把缺省参数叫做默认参数）
#include &lt;iostream&gt; using namespace std; void Func(int a = 0)//行参的后面赋一个常量值或者全局变量值，指定参数值 { cout &lt;&lt; a &lt;&lt; endl; } int main() { Func(); // 没有传参时，使⽤参数的默认值 Func(10); // 传参时，使⽤指定的实参 return 0; } 1.2 缺省参数的分类 1.2.1 全缺省参数 全缺省：全部的行参参数都给缺省值。
#include &lt;iostream&gt; using namespace std; // 全缺省 void Func1(int a = 10, int b = 20, int c = 30)//每个参数都有缺省值 { cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e661c4e376b7e8bbdab97f2f5cf7d76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965b3d2fe5247204594096df5b9d7dcb/" rel="bookmark">
			MMII 的多模态医学图像交互框架：更直观地理解人体解剖结构和疾病
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		医生在诊断和治疗过程中依赖于人体解剖图像，如磁共振成像（MRI），难以全面捕捉人体组织的复杂性，例如组织之间的空间关系、质地、大小等。然而，实时感知有关患者解剖结构和疾病的多模态信息对于医疗程序的成功和患者结果至关重要。本文介绍一个多模态医学图像交互（MMII）框架，允许医学专家在三维空间中与人体组织进行动态的视听交互。在虚拟现实环境中，用户接收到基于物理信息的视听反馈，以提高对解剖结构的空间感知。MMII使用基于模型的声音化方法，从组织的几何和物理属性生成声音，从而消除了手工制作声音设计的需要。
1 多模态MMII 框架 MMII 框架旨在通过多模态交互方式，帮助医疗专家更好地理解和感知人体解剖结构。该框架利用物理建模合成技术，将组织的物理属性和几何形状转换为音频信号，并与可视化模型相结合，为用户提供动态的音频视觉反馈。
1.1 框架结构 MMII 框架包含以下几个关键模块：
可视化模型：该模型将医学图像数据转换为 3D 模型，并通过缩放、颜色变化等方式提供视觉反馈。交互模块：该模块负责接收用户输入，并根据用户与模型的交互方式生成音频视觉反馈。声学模型：该模型根据组织的物理属性和几何形状生成声学模型，并通过物理建模合成技术生成音频信号。 1.2 工作原理 用户通过交互模块与 3D 模型进行交互，例如点击或触摸模型。交互模块将用户输入发送给声学模型，并触发声学模型的计算。声学模型根据组织的物理属性和几何形状生成音频信号，并通过物理建模合成技术生成声音。可视化模型根据用户输入和声学模型的输出提供视觉反馈，例如缩放、颜色变化等。用户通过音频和视觉反馈，更好地感知和理解人体解剖结构。 1.3 框架优势 多模态交互：MMII 框架利用音频和视觉两种模态，为用户提供更丰富的信息，并帮助用户更好地理解和感知人体解剖结构。物理信息：MMII 框架基于组织的物理属性和几何形状生成音频信号，使声音更具有真实感和直观性。动态反馈：MMII 框架可以实时生成音频视觉反馈，帮助用户动态地感知和理解人体解剖结构的变化。易于学习和理解：MMII 框架的用户研究结果表明，用户可以快速学习和理解解剖结构的音频视觉对应关系。 1.4 应用场景 MMII 框架可以应用于多种医学场景，例如：
手术导航：MMII 框架可以帮助医生在手术过程中更好地定位和识别解剖结构，从而提高手术精度和安全性。放射治疗计划：MMII 框架可以帮助医生更好地理解肿瘤的位置和形状，从而制定更精准的放射治疗方案。医学教育：MMII 框架可以帮助医学生更好地理解和学习人体解剖结构。 1.5 未来展望 更多解剖结构：未来研究可以将 MMII 框架应用于更多人体解剖结构，例如心脏、肺部等。更精细的物理模型：未来研究可以进一步改进物理模型，使其更精细、更准确。更复杂的交互方式：未来研究可以探索更复杂的交互方式，例如手势识别、语音识别等。与生理数据结合：未来研究可以将 MMII 框架与生理数据结合，例如心电图、血压等，为用户提供更全面的医学信息。 2 实验 2.1 实验1：多模态对应关系学习 研究目的：评估用户学习将视觉解剖结构表示与其听觉提示关联的能力。实验方法：进行了一项在线问卷调查，参与者通过视频和声音片段模拟 MMII 交互。实验参与者：34 名志愿者，包括具有医学和非医学背景的人。实验结果： 用户能够有效地将视觉和听觉表示的解剖结构进行关联，正确率显著提高（p &lt; 0.001）。
物理建模合成是创建解剖结构的可区分听觉表示的合适方法。
与视觉反馈相比，参与者在使用听觉反馈时感知到的任务负荷更低，表现更好，但认知负荷更高。
2.2 实验2：多模态脑肿瘤定位 研究目的：评估 MMII 在脑肿瘤定位等医学任务中的可用性和准确性。实验方法：开发了一个 VR 应用程序，让神经外科医生和神经放射科医生使用常规视觉交互和 MMII 进行脑肿瘤定位。实验参与者：9 名医学专家，包括神经外科医生和神经放射科医生。实验结果： 与视觉反馈相比，使用 MMII 的脑肿瘤定位精度显著提高（p &lt; 0.05）。
任务负荷没有显著差异，使用多模态交互时任务时间略有增加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965b3d2fe5247204594096df5b9d7dcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48843f9826eeebb89f9799e1e9015fee/" rel="bookmark">
			【人工智能】Transformers之Pipeline（概述）：30w&#43;大模型极简应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​​
目录
一、引言 二、pipeline库
2.1 概述
2.2 使用task实例化pipeline对象
2.2.1 基于task实例化“自动语音识别”
2.2.2 task列表
2.2.3 task默认模型
2.3 使用model实例化pipeline对象
2.3.1 基于model实例化“自动语音识别”
2.3.2 查看model与task的对应关系
三、总结
一、引言 pipeline（管道）是huggingface transformers库中一种极简方式使用大模型推理的抽象，将所有大模型分为语音（Audio）、计算机视觉（Computer vision）、自然语言处理（NLP）、多模态（Multimodal）等4大类，28小类任务（tasks）。共计覆盖32万个模型
本文对pipeline进行整体介绍，之后本专栏以每个task为主题，分别介绍各种task使用方法。
二、pipeline库 2.1 概述 管道是一种使用模型进行推理的简单而好用的方法。这些管道是从库中抽象出大部分复杂代码的对象，提供了专用于多项任务的简单 API，包括命名实体识别、掩码语言建模、情感分析、特征提取和问答。在使用上，主要有2种方法
使用task实例化pipeline对象使用model实例化pipeline对象 2.2 使用task实例化pipeline对象 2.2.1 基于task实例化“自动语音识别” 自动语音识别的task为automatic-speech-recognition：
import os os.environ["HF_ENDPOINT"] = "https://hf-mirror.com" os.environ["CUDA_VISIBLE_DEVICES"] = "2" from transformers import pipeline speech_file = "./output_video_enhanced.mp3" pipe = pipeline(task="automatic-speech-recognition") result = pipe(speech_file) print(result) 2.2.2 task列表 task共计28类，按首字母排序，列表如下，直接替换2.2.1代码中的pipeline的task即可应用：
"audio-classification"：将返回一个AudioClassificationPipeline。"automatic-speech-recognition"：将返回一个AutomaticSpeechRecognitionPipeline。"depth-estimation"：将返回一个DepthEstimationPipeline。"document-question-answering"：将返回一个DocumentQuestionAnsweringPipeline。"feature-extraction"：将返回一个FeatureExtractionPipeline。"fill-mask"：将返回一个FillMaskPipeline：。"image-classification"：将返回一个ImageClassificationPipeline。"image-feature-extraction"：将返回一个ImageFeatureExtractionPipeline。"image-segmentation"：将返回一个ImageSegmentationPipeline。"image-to-image"：将返回一个ImageToImagePipeline。"image-to-text"：将返回一个ImageToTextPipeline。"mask-generation"：将返回一个MaskGenerationPipeline。"object-detection"：将返回一个ObjectDetectionPipeline。"question-answering"：将返回一个QuestionAnsweringPipeline。"summarization"：将返回一个SummarizationPipeline。"table-question-answering"：将返回一个TableQuestionAnsweringPipeline。"text2text-generation"：将返回一个Text2TextGenerationPipeline。"text-classification"("sentiment-analysis"可用别名)：将返回一个 TextClassificationPipeline。"text-generation"：将返回一个TextGenerationPipeline：。"text-to-audio"（"text-to-speech"可用别名）：将返回一个TextToAudioPipeline：。"token-classification"("ner"可用别名)：将返回一个TokenClassificationPipeline。"translation"：将返回一个TranslationPipeline。"translation_xx_to_yy"：将返回一个TranslationPipeline。"video-classification"：将返回一个VideoClassificationPipeline。"visual-question-answering"：将返回一个VisualQuestionAnsweringPipeline。"zero-shot-classification"：将返回一个ZeroShotClassificationPipeline。"zero-shot-image-classification"：将返回一个ZeroShotImageClassificationPipeline。"zero-shot-audio-classification"：将返回一个ZeroShotAudioClassificationPipeline。"zero-shot-object-detection"：将返回一个ZeroShotObjectDetectionPipeline。 2.2.3 task默认模型 针对每一个task，pipeline默认配置了模型，可以通过pipeline源代码查看：
SUPPORTED_TASKS = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48843f9826eeebb89f9799e1e9015fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da709b153a0d30a05f9962b95564b7e/" rel="bookmark">
			数据仓库哈哈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据仓库 基本概念数据库（database）和数据仓库（Data Warehouse）的异同 整体架构分层架构方法论ER模型（建模理论）维度模型 何为分层第一层：数据源（ODS ER模型）设计要点日志表业务表1活动信息表（全量表）2活动规则表（全量表）3一级品类表（全量表）4二级品类表（全量表）5三级品类表（全量表）6编码字典表（全量表）7省份表（全量表）8地区表（全量表）9品牌表（全量表）10购物车表（全量表）11优惠券信息表（全量表）12商品平台属性表（全量表）13商品表（全量表）14商品销售属性值表（全量表）15SPU表（全量表）16营销坑位表（全量表）17营销渠道表（全量表）18购物车表（增量表）19评论表（增量表）20优惠券领用表（增量表）21收藏表（增量表）22订单明细表（增量表）23订单明细活动关联表（增量表）24订单明细优惠券关联表（增量表）25订单表（增量表）26退单表（增量表）27订单状态流水表（增量表）28支付表（增量表）29退款表（增量表）30用户表（增量表）31数据装载脚本 第二层：数据加工（DWD data warehouse detail）事实表设计（事务型事实表） 事务的原子性事实表设计（周期型快照事实表） 从当前表中取数据后再放回去需考虑去重问题，增加retry的容错性事实表设计（累积型快照事实表）分区策略 第三层：数据统计（DWS data warehouse summary 提高性能的关键层）第四层：数据分析（ADS application data service）表的设计（要点）优化（假）1流量主题1.1各渠道流量统计 第五层：共通层（DIM dimension）设计要点是否创建表维度表设计1商品维度表2优惠券维度表3活动（规则）维度表4地区维度表5营销坑位维度表6营销渠道维度表7日期维度表8用户维度表（拉链（压缩）表） CTE : 共通表表达式拉链表设计任务调度器 基本概念 本质是对数据进行加工处理后对外提供数据服务
数据库（database）和数据仓库（Data Warehouse）的异同 数据库用于存储企业基础，核心的业务数据从数据来源进行区分 数据库：企业的业务系统数据仓库：数据库（后台的后台） 从数据存储进行区分 数据库：存储的目的为了可以快速进行数据查询操作
索引 ： SQL
存储方式：行式存储
数据量：不能存储海量数据数据仓库：存储的目的为了可以快速进行统计分析
索引 ： 没有索引（k-v）
存储方式：列式存储
数据量：必须存储海量数据 从数据价值进行区分 数据库 ：保障企业业务系统的执行
事务（回滚）数据仓库 ：统计分析的结果可以为企业的经营决策提供数据依据
没有事务
数据仓库不是数据流转的终点 ：可视化才是数据的终点 整体架构 Spark : 数据的统计分析
数据仓库：数据的统计分析
数据仓库不能直接对接MySQL数据库作为数据源！
数据库不是为了数据仓库服务的。数据仓库如果直接对象数据库，会导致数据库的性能降低数据库不能存储海量数据。数据仓库必须获取海量数据数据库采用行式存储。数据仓库为了提高统计分析效率，所以需要列式存储 数据仓库应该增加自己的数据源
数据仓库的数据源中的数据应该和MySQL数据库中的数据保持一致
数据仓库的数据源应该不断融合（汇总）MySQL数据库中的数据
将数据库的数据汇总的到数据仓库数据源的过程，一般称之为数据同步，也称之为数据采集
分层架构 数据仓库计算周期为1天：1天统计一回数据结果
方法论 ER模型（建模理论） ER（Entity Relationship）（实体关系）模型
采用面向对象的方式设计表（和Java一样）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da709b153a0d30a05f9962b95564b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e924ecfb65017439c9731c9ded83fa60/" rel="bookmark">
			用JavaScript将 NCR（Numeric Character Reference）标记转换为对应字符的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 &amp;#xff0c 、&amp;#11111……是什么鬼？ 最近，要将一些网页内容复制到&lt;textarea&gt;文本框中作进一步处理，发现有些网页内容中包含&amp;#xff0c或&amp;#11111;之类的标记，会被原样复制到&lt;textarea&gt;文本框中。
如果将这些网页内容直接使用document.write()输出，那么&amp;#xff0c之类的标记会自动显示为对应的字符。
这是怎么回事呢？
1 Numeric Character Reference（NCR）简介 在网上查了一下，&amp;#xff0c或&amp;#11111;之类的是一种叫做 Numeric Character Reference（NCR）的标记结构。
1.1 Wikipedia（维基百科）上的解释
Wikipedia（维基百科）上的解释是： A numeric character reference (NCR) is a common markup construct used in SGML and other SGML-based markup languages such as HTML and XML. It consists of a short sequence of characters that, in turn, represent a single character from the Universal Character Set (UCS) of Unicode. NCRs are typically used in order to represent characters that are not directly encodable in a particular document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e924ecfb65017439c9731c9ded83fa60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700c0fbdb11ca2cbd4d74a2573c0d80d/" rel="bookmark">
			【数据结构——链表的深度探索】从实现到应用，保姆级攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构——链表深度探索】从实现到应用，保姆级攻略 🍁1. 链表的介绍🍁2. 链表的实现🍁2.1 单向链表🍁2.1.1 size()🍁2.1.2 display()🍁2.1.3 contains(int key)🍁2.1.4 addFirst(int key)，addLast(int key)，addIndex(int key, int index)🍁2.1.5 remove(int key)，removeAllKey(int key)🍁2.1.6 clear() 🍁2.2 双向链表🍁2.2.1 addFirst(int key)🍁2.2.2 addLast(int key)🍁2.2.3 addIndex(int key, int index)🍁2.2.4 remove(int key)和removeAllKey(int key)🍁2.2.5 clear() 🍁3. Java中LinkedList的使用🍁3.1 LinkedList的创建和使用🍁3.2 LinkedList的遍历 🍁4. ArrayList和LinkedList的区别 🚀欢迎互三👉： 2的n次方_💎💎
🚀所属专栏：数据结构与算法学习💎💎
🍁1. 链表的介绍 链表是数据结构中一种非常重要的基础结构，它不同于数组，链表中的元素在物理存储上并不连续，而是通过指针（或引用）连接在一起。在Java中，链表的应用非常广泛，尤其是在需要动态添加或删除元素的场景中。
🍁2. 链表的实现 🍁2.1 单向链表 单链表中的每个元素都称为节点（Node），每个节点包含两个部分：一部分存储数据（value），另一部分存储指向列表中下一个节点的引用（next）。最后一个节点的next引用为null，表示链表的结束。
所以采用内部类的形式进行创建：
public class MySingleList { static class ListNode { public int value; public ListNode next; public ListNode(int value) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700c0fbdb11ca2cbd4d74a2573c0d80d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08abd7ef1db29edf03ff736c07ea434/" rel="bookmark">
			0MFC基于对话框模式——前置基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 系统记得调成窗口![请添加图片描述](https://i-blog.csdnimg.cn/direct/e77eba56b14b42c8b86f210c72351684.png)基于对话框各部分代表![请添加图片描述](https://i-blog.csdnimg.cn/direct/673d07e6d17f4e528dd01ae8ebfa5b64.png)按钮实现函数方式![请添加图片描述](https://i-blog.csdnimg.cn/direct/2eceddd0cfd84997ad593e47b5337610.png)使用MFC原因 系统记得调成窗口 基于对话框各部分代表 按钮实现函数方式 使用MFC原因 自动设置好窗口实现及窗口回调
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120339f9b9164a54c2ea20f9a20d3de8/" rel="bookmark">
			org.Mm.eg.db安装报错Error in download.file(url, destfile, method, mode = “wb“, ...) :
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 org.Mm.eg.db 是一个生物信息学注释包，物种对应的全基因组注释R包，方便根据EntreZ进行基因的注释分析，它是 Bioconductor 项目的一部分，专门用于存储小鼠（Mus musculus）基因组的注释信息。先安装bioconductor,然后安装org.Mm.eg.db。
#使用 Bioconductor 的包管理器 BiocManager 来安装：
注意
BiocManager::install("org.Mm.eg.db")这个命令需要R4.4,其他版本命令不同，可以更新一下。 #安装Bioconductor if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager") #安装org.Mm.eg.db BiocManager::install("org.Mm.eg.db") 报错 1.update old packages,更新旧安装包 Old packages: 'gert', 'RCurl', 'readr', 'survival', 'XML' Update all/some/none? [a/s/n]: 按a进行更新所有，但是更新失败，寻找解决方案：
以管理员身份运行打开R或Rstudio，重复上面操作按a，更新成功。
2.timeout,没下载完 （1）试图修改参数使时间变长，没成功 url &lt;- "http://example.com/somefile.zip" # 替换为实际的URL destfile &lt;- "/path/to/your/downloaded/file.zip" # 替换为实际的文件路径 download.file(url, destfile, method = "auto", mode = "wb", timeout = 600) （2）直接网页下载到本地，然后导入包，安装成功 下载地址：Bioconductor - org.Mm.eg.dbThe Bioconductor project aims to develop and share open source software for precise and repeatable analysis of biological data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/120339f9b9164a54c2ea20f9a20d3de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e59180d7aef87e5efecfa67e4f3c3051/" rel="bookmark">
			【BUG】Python3｜COPY 指令合并 ts 文件为 mp4 文件时长不对（含三种可执行源代码和解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言源代码FFmpeg的安装1 下载2 安装 前言 参考：
python 合并 ts 视频（三种方法）使用 FFmpeg 合并多个 ts 视频文件转为 mp4 格式 Windows 平台下，用 Python 合并 ts 文件为 mp4 文件常见的有三种方法：
调用 COPY 指令，运行copy /b *.ts output.mp4；需要注意的是[1]，这里提到的 copy 指令应该运行在 cmd 中，而不是 PowerShell 中。因为 Windows 在 PowerShell 的时候运行 copy 指令会调用内置的 Copy-Item 命令，和 cmd 调用的 copy 在用法和功能上都不相同。若你非要在 PowerShell 中运行 CMD 的 COPY 指令，你可以使用cmd /c "copy /b *.ts output.mp4"。Python 文件读写，使用 open, read, write 这些指令去合并，注意打开文件的方式是 rb 和 wb；使用 ffmpeg，运行ffmpeg -f concat -safe 0 -i file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e59180d7aef87e5efecfa67e4f3c3051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b9313b3d6cfd0d59042a50bde26c2a7/" rel="bookmark">
			【微服务】第30节： Redis的主从集群结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IT领域往往都是面试造火箭，实际工作拧螺丝。为了更好的应对面试，让大家能拿到更高的offer✉，我们接下来就讲讲“造火箭”的事情🧑‍🚀。
🔥🔥🔥 包括以下几方面🔽 🎈：
🌈 - Redis - 高级：
📛 -Redis主从（◀️）
🤿 - Redis哨兵 🧩 - Redis分片集群
👨‍💻 - Redis数据结构
♻️ - Redis内存回收
✅ - Redis缓存一致性
1.Redis主从 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。
1.1.主从集群结构 下图就是一个简单的Redis主从集群结构：
如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由：
💠如果是写操作，应该访问master节点，master会自动将数据同步给两个slave节点
💠如果是读操作，建议访问各个slave节点，从而分担并发压力
1.2.搭建主从集群 我们会在同一个虚拟机中利用3个Docker容器来搭建主从集群，容器信息如下：
容器名 角色 IP 映射端口 r1
master
192.168.150.101
7001
r2
slave
192.168.150.101
7002
r3
slave
192.168.150.101
7003
1.2.1.启动多个Redis实例 利用资料提供的docker-compose文件来构建主从集群：
文件内容如下：
version: "3.2" services: r1: image: redis container_name: r1 network_mode: "host" entrypoint: ["redis-server", "--port", "7001"] r2: image: redis container_name: r2 network_mode: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b9313b3d6cfd0d59042a50bde26c2a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1e1a56543950c12a84d4afef32f724/" rel="bookmark">
			全球首款集成GPT-4o的智能眼镜AirGo Vision：AI眼镜的未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在人工智能和大模型技术迅猛发展的今天，AI硬件产品逐渐走入人们的生活。继Meta Ray-Ban智能眼镜之后，Solos公司在最近的香港智能眼镜峰会上发布了全球首款集成GPT-4o的智能眼镜AirGo Vision。本文将深入探讨这款AI智能眼镜的功能、技术特点以及其在市场上的竞争力和未来发展前景。
AI智能眼镜的发展历程 近年来，AI硬件产品如雨后春笋般涌现，从AI Pin到Rabbit R1，然而，许多产品在实际应用中却未能达到预期效果，市场表现乏力。然而，随着内置Llama大模型的Meta Ray-Ban智能眼镜的推出，AI硬件市场迎来了新的转机。AirGo Vision的问世，进一步加剧了这一市场的竞争。
AirGo Vision的技术特点 多模态输入输出能力 AirGo Vision内置了最新的GPT-4o大模型，支持文本、音频和图像的任意组合输入与输出。这意味着用户可以通过语音、视觉等多种方式与眼镜进行互动，实现更加自然的交流。例如，用户在街头只需轻声询问眼前的建筑或物品，AirGo Vision就能实时进行识别并提供详细的背景信息。
实时多语言翻译 AirGo Vision支持25种语言的实时翻译功能，对于经常出国旅行或需要跨语言交流的用户来说，这无疑是一个极具吸引力的功能。通过Whisper消息与事件功能，眼镜还可以将文本转化为语音，为用户提供消息朗读服务，极大地方便了日常使用。
模块化设计与多样化镜框选择 在硬件设计上，AirGo Vision追求轻便和多样化。眼镜的重量仅为34g，同时采用了模块化设计，用户可以根据个人喜好和场合需求更换不同样式的镜框。目前，Solos提供了三种不同款式的镜架和五种不同的镜片，价格在89美元到129美元之间，用户可以自由选择和搭配。
多任务处理能力 AirGo Vision不仅能够处理简单的视觉和语音问题，还具备多任务处理能力。无论是购物、导航还是烹饪，用户都可以通过长按镜框右侧的虚拟按钮或在配套软件上输入文字来获取所需信息。这种强大的多任务处理能力使得用户在日常生活中更加得心应手。
实用性与市场竞争 尽管AirGo Vision在功能上具有诸多亮点，但其市场表现和竞争力仍然面临挑战。Meta Ray-Ban智能眼镜由于硬件质量和内置的高通骁龙AR Gen 1芯片，已经在市场上取得了显著的成功。相比之下，AirGo Vision虽然在轻便性和多模态AI集成方面具有优势，但在硬件配置和独立处理能力上相对较弱。
此外，AirGo Vision的售价预计在249美元以上，尽管比Meta Ray-Ban便宜，但对于消费者来说，这仍是一笔不小的开支。特别是考虑到可能的额外订阅费用，用户在选择时会更加谨慎。
未来展望 尽管当前的AI智能眼镜市场竞争激烈，但其未来发展前景广阔。根据IDC的数据，全球智能眼镜的出货量预计在2025年将达到700万台，年平均增长率超过30%。各大科技巨头如Google和苹果也在积极布局智能眼镜市场，未来的竞争将更加白热化。
AI与智能眼镜的结合，将为用户带来更加便捷和智能化的生活体验。AirGo Vision作为这一领域的新兴产品，有望通过不断优化和提升技术，找到自己的市场定位。
结论 AirGo Vision作为全球首款集成GPT-4o的智能眼镜，通过多模态输入输出、实时多语言翻译和多任务处理等功能，为用户提供了全新的交互体验。然而，其市场表现和竞争力还需时间检验。随着技术的不断进步和市场需求的增加，AI智能眼镜将逐步走入更多人的生活，成为未来智能硬件的重要组成部分。
未来，随着各大科技公司在智能眼镜领域的不断探索和创新，AI智能眼镜市场将迎来更加丰富和多样化的产品，为用户带来更加智能和便捷的生活体验。让我们拭目以待，见证这一科技发展的新篇章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f01b66b7b4c360b888615f3a826f7e/" rel="bookmark">
			C&#43;&#43;的介绍与认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.什么是C++
2.C++的发展历史
3.C++参考文档
4.C++重要性
4.1C++特点
4.2编程语言排行榜
4.3 C++的应用领域
5.C++学习指南
1. 基础知识
2. 面向对象编程（OOP）
3. 泛型编程
4. 标准库（STL）
结束语
前言 学习了C语言的知识，今天小编将进军C++的知识，本篇博客可能略微枯燥，主要是对C++的相关介绍和认识，以及学习路线，下节将正式进入C++的学习。
1.什么是C++ C++起源于C语言，但通过引入面向对象编程（OOP）和泛型编程的特性，使其功能更为丰富和灵活。它被广泛应用于系统/应用程序开发、游戏开发、嵌入式系统等领域，因其性能优越和可扩展性而受到程序员的青睐。
2.C++的发展历史 C++的起源可以追溯到1979年，当时Bjarne Stroustrup(本贾尼·斯特劳斯特卢普，这个翻译的名字不同的地方可能有差异)在贝尔实验室从事计算机科学和软件工程的研究工作。面对项目中复杂的软件开发任务，特别是模拟和操作系统的开发工作，他感受到了现有语言（如C语言）在表达能力、可维护性和可扩展性方面的不足。 1983年，Bjarne Stroustrup在C语言的基础上添加了面向对象编程的特性，设计出了C++语言的雏形，此时的C++已经有了类、封装、继承等核心概念，为后来的面向对象编程奠定了基础。这一年该语言被 正式命名为C++。 在随后的几年中，C++在学术界和工业界的应用逐渐增多。一些大学和研究所开始将C++作为教学和研 究的首选语言，而一些公司也开始在产品开发中尝试使用C++。这一时期，C++的标准库和模板等特性 也得到了进一步的完善和发展。 C++的标准化⼯作于1989年开始，并成立了一个ANSI和ISO（International Standards Organization）国际标准化组织的联合标准化委员会。1994年标准化委员会提出了第一个标准化 案。在该草案中，委员会在保持斯特劳斯特卢普最初定义的所有特征的同时，还增加了部分新特征。 在完成C++标准化的第一个草案后不久，STL（Standard Template Library）是惠普实验室开发的一系 列软件的统称。它是AlexanderStepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。在通过了标准化第一个草案之后，联合标准化委员会投票并通过了将STL包含到C++标准中的提议。STL对C++的扩展超出C++的最初定义范围。虽然在标准中增加STL是个很重要的决定，但也因此延缓了C++标准化的进程。 1997年11月14日，联合标准化委员会通过了该标准的最终草案。1998年，C++的ANSI/IS0标准被投入使用。 3.C++参考文档 https://legacy.cplusplus.com/reference/ https://zh.cppreference.com/w/cpp https://en.cppreference.com/w/ 说明：第一个链接不是C++官方文档，标准也只更新到C++11，但是以头文件形式呈现，内容比较易看好懂。后两个链接分别是C++官方文档的中文版和英文版，信息很全，更新到了最新的C++标准，但是相比第一个不那么易看；几个文档各有优势，可以结合着使用。 4.C++重要性 C++是一种具有广泛应用和深远影响的编程语言，无论是系统开发、游戏编程、还是嵌入式系统，C++都发挥着至关重要的作用。 4.1C++特点 1. 高性能和效率 C++的一个显著特点是其高性能和高效性。通过直接访问硬件和内存，C++允许开发者编写优化的代码，从而实现出色的运行速度和资源管理。这使得C++在需要高性能计算的领域中，如游戏开发、图形渲染和科学计算，成为首选的编程语言。 2. 面向对象编程 C++引入了面向对象编程（OOP）的概念，包括类、继承和多态性。这使得开发者可以通过抽象和封装来提高代码的可维护性和可扩展性。面向对象编程使得复杂系统的设计和实现变得更加直观和模块化。 3. 泛型编程和模板 C++的模板机制允许编写泛型代码，这不仅提高了代码的复用性和灵活性，还减少了冗余代码的编写。通过模板，开发者可以创建通用的数据结构和算法，从而提高开发效率和代码质量。 4. 标准库（STL） C++标准库（STL）提供了丰富的工具集，包括各种容器（如vector、map、set）和算法（如排序、查找）。STL极大地简化了数据管理和操作，使开发者能够专注于核心业务逻辑，而无需从头实现复杂的数据结构和算法。 5. 广泛的应用领域 C++在多个领域中都有着广泛的应用： 系统编程：由于其高效性，C++常用于操作系统、驱动程序和底层系统组件的开发。 游戏开发：C++的高性能和强大的图形处理能力使其成为游戏引擎开发的首选语言，如Unreal Engine和Unity。 嵌入式系统：C++的灵活性和低级硬件访问能力使其适用于嵌入式系统和物联网设备的开发。 - ** 金融工程：在高频交易和金融建模中，C++因其高性能和可靠性被广泛使用。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f01b66b7b4c360b888615f3a826f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e79eb630c4fdfc3ce62f02d7ccd0845/" rel="bookmark">
			从0开始的STM32HAL库学习1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础外设初始化配置步骤 本学习以stm32f103c8t6为主控芯片学习。配合DMK-Keil使用，因为cubeide我还没找到很好的教程，而且用了几次发现不会用，所以还是先学习hal库，等hal库学习完之后再用学习使用cubeide，两者使用应该大差不差，主要还是先会使用cubemx
新建工程 1在主界面选择File--&gt;New Project 或者直接点击ACCEE TO MCU SELECTOR 搜索自己板子的芯片，就可以了，双击创造工程
接下来会到这个界面， 在右边这个芯片中
这种颜色表示不可配置引脚 电源专用引脚以黄色突出显示。其配置不能更改
这种颜色表示你配置了一个I/O口的功能，但是没有初始化相对应的外设功能 引脚处于no mode 状态 绿色表示配置成功
GPIO口的配置 这里只需要把我们的LED对应引脚设置为GPIO_Output即可
我们将PA1上接上一个led灯，将PA1设置为GPIO_Output。
时钟源设置 点到clock_configuration中配置时钟树
其实也就是32的时钟树框图让你配置 默认时钟是使用内部RC振荡器（HSI） 在配置时钟前需要将
RCC配置为外部晶振即crystal resonator
这里也可以将SYS中的debug改为Serial Wire这样就方便调试了。
之后再点到clock_configuration中配置时钟树
将途中所框的改为72，就配置完成了
工程管理 点到Project Manager
需要配置红色框框中的几个配置，分别为文件名，文件存放地址和选择IDE 我是配置成如图所示（IDE选择MDK_ARM就是keil编译器）
注意点：存储目录不可以有中文
接着点到code generator中
勾选红框中所选配置。每个外设都配置单独的.c和.h文件。这样方便我们管理和写代码。
生成代码 点击即可。
代开代码 我们将会看到我们的不少代码以及生成了，我们只需要填写关键代码即可。
我们找到while（1）
while (1) { /* USER CODE END WHILE */ HAL_Delay(500); HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1); /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 将代码设置成这样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e79eb630c4fdfc3ce62f02d7ccd0845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287b942d4545da868e5d07c9105757c1/" rel="bookmark">
			信息学奥赛初赛天天练-43-CSP-J2020基础题-链表、连通图、2进制转10进制、栈、队列、完全二叉树、哈希表应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF文档公众号回复关键字:20240710
2020 CSP-J 选择题
单项选择题（共15题，每题2分，共计30分：每题有且仅有一个正确选项）
7.链表不具有的特点是（）
A.可随机访问任一元素
B.不必事先估计存储空间
C.插入删除不需要移动元素
D.所需空间与线性表长度成正比
8.有 10 个顶点的无向图至少应该有（ ）条边才能确保是一个连通图
A.9
B.10
C.11
D.12
9.二进制数 1011 转换成十进制数是（ ）
A.11
B.10
C.13
D.12
11.下图中所使用的数据结构是（ )
A.栈
B.队列
C.二叉树
D.哈希表
12.独根树的高度为 1。具有 61 个结点的完全二叉树的高度为（ ）
A.7
B.8
C.5
D.6
2 相关知识点
1) 链表
是一种常见的数据结构，它是由一系列节点（Node）组成，每个节点包含两部分：数据域和指针域。数据域用于存储数据，指针域用于存储下一个节点的地址。链表的第一个节点称为头节点（Head），最后一个节点称为尾节点（Tail），尾节点的指针域指向空（NULL）
链表占用空间大小，和链表的长度有关，没增加一个节点，增加一个数据节点和一个指针节点，存储空间和链表长度成正比
随机存取
随机存取（直接存取,Random Access）指的是当存储器中的数据被读取或写入时，所需要的时间与该数据所在的物理地址无关
顺序存取
顺序存取 (Sequential Access)是一种按记录的逻辑顺序进行读、写操作的存取方法，所需要的时间与该数据所在的物理地址有关。
顺序存取表现为:在存取第N个数据时，必须先访问前（N-1）个数据
#include&lt;bits/stdc++.h&gt; using namespace std; /* 随机存取、顺序存取 */ int a[10]={0,1,2,3,4,5,6,7,8,9}; int main(){ cout&lt;&lt;a[9]&lt;&lt;endl;//随机读取下标为9的元素 输出 9 for(int i=0;i&lt;10;i++){//顺序存储 逐一读取 cout&lt;&lt;a[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/287b942d4545da868e5d07c9105757c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba282448b82fd6181a281708871d30a/" rel="bookmark">
			基于springboot&#43;mybatis学生管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于springboot+mybatis学生管理系统 简介： 题目虽然是学生管理系统，但功能包含(学生，教师，管理员),项目基于springboot2.1.x实现的管理系统。
编译环境 ： jdk 1.8
mysql 5.5
tomcat 7
框架 ： springboot2.0
mybatis
jar包管理工具： Maven
编译器 ： IDEA
完成进度： &gt; 完成 系统功能 : 学生信息管理
班级信息管理
教师信息管理
课程信息管理
选课信息管理
考勤信息管理
请假信息管理
成绩信息管理
系统管理
项目截图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b78b8d03c81cc1a5c92567feba401c/" rel="bookmark">
			Java 中的阻塞 IO 和非阻塞 IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中的阻塞 IO 和非阻塞 IO 1、阻塞 IO（Blocking IO）2、非阻塞 IO（Non-blocking IO）3、区别与应用场景4、总结 💖The Begin💖点点关注，收藏不迷路💖 IO（输入输出）操作是一个基础而又关键的部分。在 Java 中，处理 IO 通常涉及到阻塞 IO 和非阻塞 IO 两种模式。本文将介绍这两种模式的概念、特点以及在 Java 编程中的应用场景与区别。
1、阻塞 IO（Blocking IO） 阻塞 IO 是指在进行 IO 操作时，如果数据没有准备好，请求会被阻塞，直到数据准备好并返回给用户线程。
在阻塞 IO 中，读取数据的操作会一直等待直到有数据可供读取或者超时。在 Java 中，传统的 IO 操作（比如基于 InputStream 和 OutputStream 的操作）通常是阻塞的。
示例代码：
InputStream inputStream = socket.getInputStream(); int data = inputStream.read(); // 如果没有数据准备好，此处会阻塞直到有数据可读 2、非阻塞 IO（Non-blocking IO） 非阻塞 IO 则不会等待数据准备就绪，而是立即返回。如果数据还没有准备好，非阻塞 IO 操作会返回一个标志信息告知当前数据未准备好，这样用户线程可以继续做其他事情而不必等待。
在 Java 中，非阻塞 IO 通常使用 NIO（New IO）或者 NIO.2 中的通道（Channel）和缓冲区（Buffer）来实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b78b8d03c81cc1a5c92567feba401c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b675731eb04c855fa7971495fccd93a0/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(014)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
34、pandas.DataFrame.to_parquet函数
34-1、语法
34-2、参数
34-3、功能
34-4、返回值
34-5、说明
34-6、用法
34-6-1、数据准备
34-6-2、代码示例
34-6-3、结果输出
35、pandas.read_sql_table函数
35-1、语法
35-2、参数
35-3、功能
35-4、返回值
35-5、说明
35-6、用法
35-6-1、数据准备
35-6-2、代码示例
35-6-3、结果输出 36、pandas.read_sql_query函数
36-1、语法
36-2、参数
36-3、功能
36-4、返回值
36-5、说明
36-6、用法
36-6-1、数据准备
36-6-2、代码示例
36-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 34、pandas.DataFrame.to_parquet函数 34-1、语法 # 34、pandas.DataFrame.to_parquet函数 DataFrame.to_parquet(path=None, *, engine='auto', compression='snappy', index=None, partition_cols=None, storage_options=None, **kwargs) Write a DataFrame to the binary parquet format. This function writes the dataframe as a parquet file. You can choose different parquet backends, and have the option of compression.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b675731eb04c855fa7971495fccd93a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afc0b436b6137399063d56bfd96a2d0/" rel="bookmark">
			【从零开始实现stm32无刷电机FOC】【理论】【3/6 位置、速度、电流控制】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 PID控制滤波单独位置控制单独速度控制单独电流控制位置-速度-电流串级控制 上一节，通过对SVPWM的推导，我们获得了控制电机转子任意受力的能力。本节，我们选用上节得到的转子dq轴解耦的SVPWM形式，对转子受力进行合理控制，实现FOC电机控制的最终目标：位置、速度、电流控制。
PID控制 看到本节的人，大概率是了解PID（Proportional比例，Integral积分，Derivative微分）控制的，也是本人能力所限，在此不进行完整讲解，也不涉及高级控制方法。
不管是电机的位置还是速度还是电流，都可以视为被控参数。
从直观想法上，当一个被控参数实时值小于目标值时，需要施加外力使被控参数提高。如果施加的外力过大，被控参数会被超调，导致被控参数在目标值附近的振荡幅度越来大；如果施加的外力过小，参数到达目标值的速度又太慢。因此需要得到一个合适的外力，使得被控参数既不会振荡越来越剧烈，调节速度也不会太慢。从这个直观的控制想法就是PID中的P。单纯使用P控制时，设置外力大小=被控参数与目标值的差距*P系数，所谓差距越大施加的外力越大，是很直观的。如果P系数设置的比较小，虽然被控参数不会一直振荡了，可以慢慢稳定到目标值了，但是调节速度太慢了，此时可以加入PID的D控制，使得原先振荡的被控参数快速收缩到目标值。
再从直观想法上去思考D控制，纯P控制下被控参数靠近以及掠过目标值时，一个与速度反方向的纠偏力有助于被控参数在目标值附近产生制动，让被控参数更快地收缩到目标值。这个与速度反方向的纠偏力就是D控制。加入D控制后，控制外力大小=被控参数与目标值的差距*P系数+被控参数速度*D系数。当纯D控制时，由于初始状态下被控参数的速度为0 ，被控参数不会得到外力，由此也可以看出，P控制是提供外力的，D控制是约束外力的。如果D系数选择过大，则轻微的速度就能够引起巨大的外力；如果D系数选择过小，则不足以约束P控制生产的外力，被控参数稳定就慢。
还是从直观想法上去思考I控制，当被控参数存在负载时，单纯的P控制提供的外力可能不足以支撑这个负载，因此可以加上这样一个机制，把被控参数与目标值差距随着时间累计起来，这样就能得到存在负载时被控参数到达目标值所需的动力了。这个机制就是I控制。加入I控制后，控制外力大小=被控参数与目标值的差距*P系数+被控参数速度*D系数+被控参数与目标值差距随时间累计*I系数。
在控制电机时，没有特殊情况下，由于d轴对电机旋转不生成贡献，pid控制可以只控制q轴的力，d轴可以进行控制也可以直接设置输出为0。
滤波 在速度控制和电流控制时，受限于采样精度和频率等，速度和电流是不稳定的且变化比较快，例如下图是电机速度的直接计算值，存在很多锯齿，在真实值附近波动，如果直接使用这样的值，会导致PID输出波动较大，
下图为经过滤波后，比较接近真实值：滤波方法有很多种，比如低通滤波、卡尔曼滤波，本质就是在夹杂了噪音的数据中估计出一个接近真实的值。由于滤波是一个非常大的课题，原理不在本节进行说明，可直接查看后续实践部分的代码，只是在此提醒，输入PID控制器前，需要进行滤波计算。
单独位置控制 位置指的是角度，要注意，有两种物理角度，一个是电机角度，一个是转子角度，两者是不一样的。电机编码器是安装在转子外壳上的，因此编码器获得的是转子外壳的角度，而转子位于内部，由于转子外壳和转子是互相固定的，两种角度有一个固定偏移，安装的时候编码器零度不可能正好对着转子永磁体。编码器角度由编码器提供，转子角度也就能知道了。在后续实践部分会说明怎么获得这个固定偏移，在本节只需完成理论计算部分。合成的磁矢量是作用于转子永磁体的，因此理论计算是在转子角度基础上计算的。
有两种方法可以实现转子的位置控制：
pid法：
直观的思想就是用转子q轴不停地左右拉扯转子，转子一旦偏离目标位置了，就在q轴施加一个反向的力拉扯一下，偏离越大，拉扯力越大，让转子回到目标位置。
优点：q轴能够提供较大的力，位置控制比较迅速有力。
缺点：由于q轴与转子永磁体磁矢量相差90度，因此需要知道转子实时位置（角度）。
由于在有编码器的情况下，转子实时位置很容易获得，因此大部分情况下使用pid控制位置。
单独位置的FOC控制框图如下图。图中的意思是输入一个目标位置，与编码器计算得到的角度进行差值计算，然后输入pid控制器，只控制转子q轴强度，d轴强度直接设置为0，最后将dq轴强度（0~1之间）输入到前文推导得到的SVPWM函数中，输出得到uvw桥臂的pwm占空比。这里要注意的是输入的目标位置 θ i n \theta_{in} θin​可以是转子角度或者编码器角度或者多圈角度，只要与反馈的 θ \theta θ保持同一种角度即可。
d轴强拖：
核心思想是人为控制线圈生成一个目标线圈磁矢量，永磁铁的d轴会被吸引到目标位置。注意该方法是吸引d轴到目标位置。
优点：由于生成的就是目标位置，因此无需知道转子角度，转子自然会被吸引过去。
缺点：切向分力小，轻微切向外力就能让转子明显脱离位置。
单独速度控制 速度控制使用d轴拖动的方法就不合适了，因为d轴拖动就是为了不使用编码器，没了编码器数据就很难计算速度了。速度控制可以使用pid控制方法，但是由于电机旋转过程中速度值变化比较不稳定，而D控制是与被控参数的变化程度成正比，所以一般只使用PI控制。
速度的计算方式非常简单，就是 当前角度 − 上次记录的角度 Δ t \frac{当前角度-上次记录的角度}{\Delta{t}} Δt当前角度−上次记录的角度​。
将目标速度与实时速度的差值输入到PI控制中就能实现速度控制。
单独速度的FOC控制框图如下图。
单独电流控制 电机的电流代表了力矩大小。转子的受力在dq轴解耦后，可以发现只有q轴才对电机旋转生成贡献，只有q轴才产生力矩，因此只需要控制q轴电流即可控制电机力矩。如果对d轴电流也进行控制可以提升电机电流利用率，降低发热，提升电机最高力矩输出。
获得电机电流：
转子dq轴是一个抽象出来的概念，是为了方便解耦转子受力的，无法直接检测dq轴电流，能够直接检测的电流是电机相线电路上的电流，dq轴电流可以根据相线电流计算得到。
相线电流的检测有很多种，最常见的两种方式是：1.电流检测放置在上下桥臂功率管之间，称为在线检测。2.电流检测放置在下桥臂与GND之间，称为低端检测。
由于一个节点流出电流+流入电流=0，因此三个相线只需要两个电流检测单元即可。但是低侧检测最好使用三个电流检测单元，因为当某个桥臂的pwm占空比为1或者接近1时，该下桥臂将没有电流经过或者电流不稳定，三个相线就只剩下一个电流检测能够正常采集电流，有三个电流检测单元后，可以三个都读取电流，根据占空比情况选择其中两个电流值，另一个通过电流总和为0进行计算。在线检测则没有该困扰，因为不管下桥臂是否处于关闭状态，相线始终有电流经过。由于在线检测位置的电压比较大，因此在线检测的电流检测单元需要能够承受较大电压，价格比较高。
获得三个相线电流后，接下来想办法转换为dq轴电流。可以将相线电流投影到dq轴上，这样就能直接得到dq轴电流了，不过目前主流做法是先将dq轴投影到 α \alpha α轴和 β \beta β轴（这步称为clark变换），再将 α \alpha α轴和 β \beta β轴电流投影到dq轴（这步称为park变换），因为在更高级的无位置传感器FOC中会用到 α \alpha α轴和 β \beta β轴电流。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5afc0b436b6137399063d56bfd96a2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed5fcdb4ecd551173cf66b3d7e74087/" rel="bookmark">
			微信小程序之使用上拉加载实现图片懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序中，有2个事件，相信大家都很熟悉
下拉重新加载
上拉加载更多
事件是这么个事件，至于事件触发后干嘛，那就看代码了
首先要在对应得地方xxxxpage.json打开这个
"onReachBottomDistance": 100 至于这个值100还是多少要看你的实际情况，为了不让用户看到默认的框框啥的，应该是设置大一些！
xxxpage.js中
onReachBottom(){ //组件的class="lazyimage" var child =this.selectComponent('.lazyimage'); if(child){ child.onScrollIndex();//告知懒加载组件，触发了上拉触底事件 }else{ console.log(this); } } 然后就是我们的组件代码了 比如命名为lazyimage
lazyimage.js
// components/goodsParse/goodsParse.js Component({ /** * 组件的属性列表 */ properties: { parseData: { type: Array, value: [] }, param: { type: String }, scrollindex:{ type:Number, value:0, default:0 }, lazyload:{ type:Boolean, value:false } }, /** * 组件的初始数据 */ data: { imageCount: 0, imagedatas:[], loadcount:0, current_load_height:0,//本次渲染的图片的总高度 如果本次渲染的总高度不足1500 则会再次渲染per_load_count current_loaded_ok:false,//本次是否渲染完成 per_load_min_height:1500,//每次至少渲染多少高度 per_load_count:3//每次渲染的张数，如果渲染的总高度不足，会继续渲染 }, /** * 组件的方法列表 */ methods: { handleImgtap() { }, onImageLoad(e) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ed5fcdb4ecd551173cf66b3d7e74087/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/171/">«</a>
	<span class="pagination__item pagination__item--current">172/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/173/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>