<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eda28b59615a34b9cd436c28944a68f/" rel="bookmark">
			Computer Vision COMP90086
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Introduction Finding correspondences between keypoints is a critical step in many computer vision applications. It can be used to align images when constructing a panorama from lots of separate photogtraps, and it is used to find point correspondences between keypoints detetected in multiple views of a scene. iuww520iuww520iuww520iuww520iuww520iuww520iuww520iuww520 This assignment uses a dataset generated from many views of the Trevi fountain in Rome. Finding correspondences between detected keypoints is a critical step in the pipeline for reconstructing a 3D representation of the fountain from individual photographs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eda28b59615a34b9cd436c28944a68f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c4c66f351fe1d17551495ea3f38513/" rel="bookmark">
			HTTPS访问是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS（Hypertext Transfer Protocol Secure）是一种安全的网络传输协议，它基于HTTP（Hypertext Transfer Protocol，超文本传输协议）进行工作，但增加了安全性的要求。HTTPS通过在客户端（如浏览器）和服务器之间建立一个加密的通道，来确保传输的数据在网络中不被窃听或篡改。
HTTPS协议的主要特性包括：
数据加密：HTTPS使用SSL（Secure Sockets Layer，安全套接层）或其继任者TLS（Transport Layer Security，传输层安全）协议来对传输的数据进行加密。这意味着，即使在数据被发送和接收的过程中被截获，也无法被未经授权的第三方轻易地读取或理解。
服务器身份验证：HTTPS协议要求服务器在建立加密连接之前，向客户端提供一个数字证书，该证书由受信任的证书颁发机构（CA）签发。客户端会验证证书的有效性，以确保它正在与正确的服务器通信，而不是一个冒名顶替的恶意服务器。
数据完整性：除了加密之外，HTTPS还通过消息认证码（MAC）等机制来确保传输的数据在传输过程中没有被篡改。
端口号：HTTPS通常使用TCP/IP协议的443端口进行通信，而HTTP则使用80端口。
URL前缀：在浏览器地址栏中，HTTPS协议的URL以https://开头，而HTTP协议的URL则以http://开头。
永久免费SSL证书_永久免费https证书_永久免费ssl证书申请-JoySSL真正完全且永久免费！不用您花一分钱，SSL证书免费使用90天，并且还支持连续签发。JoySSL携手全球权威可信顶级根，自研新一代SSL证书，全系列支持90天免费使用。在这里，你可以申请到免费单域名证书、免费多域名证书以及免费通配符证书。部署于国内的验签服务器3-5分钟极速签发，而且只需要简单的域名解析验证，即可让您的网站开启https安全协议。https://www.joyssl.com/certificate/select/free.html?nid=7
HTTPS的普及对于保护用户隐私和数据安全至关重要，特别是在进行在线购物、银行交易或任何需要传输敏感信息的情况下。随着网络安全威胁的不断增加，越来越多的网站和服务开始采用HTTPS协议来保护用户的数据安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05757f411abbc78a07eb0abd0307ac5f/" rel="bookmark">
			http ,https 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http相关知识点
HTTP和HTTPS的主要区别在于安全性方面，但它们之间还有其他一些不同点。以下是HTTP与HTTPS之间的关键区别：
安全性 HTTP：不安全，因为它以明文形式传输数据，这意味着数据在传输过程中可以被拦截、阅读和修改。HTTPS：安全，通过使用SSL/TLS协议对数据进行加密，确保数据传输过程中的隐私和完整性，防止数据被拦截和篡改。 端口 HTTP：默认使用端口80。HTTPS：默认使用端口443。 性能 HTTP：由于没有加密处理，性能相对较好。HTTPS：加密和解密数据需要额外的处理时间，可能会稍微影响性能。但随着技术的进步，这种性能差异越来越小。 URL格式 HTTP：URL以http://开头。HTTPS：URL以https://开头。 SSL/TLS证书 HTTP：不需要SSL/TLS证书。HTTPS：需要SSL/TLS证书来建立安全连接。证书由证书颁发机构（CA）签发，用于验证服务器的身份。 搜索引擎优化（SEO） HTTP：使用HTTP可能对网站的搜索引擎排名产生负面影响。HTTPS：被搜索引擎（如Google）视为正面排名因素，有助于提高网站的SEO排名。 用户信任 HTTP：由于缺乏加密，用户可能对提交到HTTP网站的敏感信息感到不安。HTTPS：加密连接通常会在浏览器地址栏显示锁定图标，增加用户对网站的信任。 现代Web特性 HTTP：某些现代Web特性，如地理位置、推送通知和Service Workers，要求网站使用HTTPS来保护用户数据。HTTPS：支持所有现代Web特性，并鼓励使用这些特性来提供更丰富和安全的用户体验。 工作原理对比 HTTP工作流程：
客户端发送HTTP请求到服务器。服务器处理请求并返回响应。数据在传输过程中不加密。 HTTPS工作流程：
客户端发送HTTPS请求到服务器。服务器发送其SSL证书给客户端。客户端验证证书的有效性。客户端和服务器协商加密算法和会话密钥。使用会话密钥加密后续通信。 总的来说，HTTPS提供了比HTTP更高的安全性和数据保护，是现代网站的推荐选择。随着互联网安全意识的提高，越来越多的网站正在迁移到HTTPS。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d4fd89a5c2970b29b852ce01b1060c/" rel="bookmark">
			http长连接原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http相关知识点
HTTP长连接（HTTP Keep-Alive 或 HTTP persistent connection）是一种用于在单个TCP连接上发送多个HTTP请求/响应的技术，而不是为每个请求/响应对打开一个新的连接。这种方法可以显著提高HTTP通信的效率。让我们深入了解HTTP长连接的原理：
1. 基本原理 连接复用：在一个TCP连接上连续发送多个HTTP请求和响应，而不是为每个请求-响应对建立一个新的TCP连接。减少握手次数：避免了频繁的TCP连接建立和断开，减少了三次握手和四次挥手的次数。降低延迟：减少了建立连接所需的时间，从而降低了整体通信延迟。 2. 实现机制 HTTP/1.0+：
客户端在请求头中添加 Connection: keep-alive服务器在响应头中也返回 Connection: keep-alive连接保持打开状态，可以继续用于后续请求 HTTP/1.1：
默认启用长连接除非明确指定 Connection: close，否则连接将保持打开状态 连接管理：
服务器可以使用 Keep-Alive 头部指定连接的超时时间和最大请求数例如：Keep-Alive: timeout=5, max=1000 3. 工作流程 客户端发送带有 Connection: keep-alive 的HTTP请求服务器响应，同样带有 Connection: keep-alive 头TCP连接保持打开状态客户端可以在同一连接上发送更多请求重复步骤2-4，直到连接关闭 4. 优点 减少延迟：避免了频繁的TCP连接建立和断开降低服务器负载：减少了服务器处理TCP连接的开销提高吞吐量：在同一连接上可以处理更多请求减少网络拥塞：减少了网络中的TCP连接数量 5. 注意事项 资源管理：服务器需要合理管理长连接，避免占用过多资源超时处理：需要设置合适的超时时间，及时关闭不活跃的连接连接数限制：服务器应限制每个客户端的最大连接数兼容性：确保客户端和服务器都支持长连接 6. HTTP/2 和 HTTP/3 的改进 HTTP/2：引入了多路复用，允许在单个TCP连接上并行处理多个请求和响应HTTP/3：基于QUIC协议，提供了更快的连接建立和更好的多路复用支持 总结 HTTP长连接通过复用TCP连接来提高通信效率，减少延迟和服务器负载。它是现代Web通信的重要组成部分，为高效的HTTP通信奠定了基础。随着HTTP/2和HTTP/3的出现，连接管理变得更加高效，但长连接的基本原理仍然适用。在实际应用中，需要根据具体场景合理配置和管理长连接，以获得最佳性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302e82ee0daa041d0c40e36fee6a45e0/" rel="bookmark">
			【Hadoop】集群搭建实战：超详细保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐇明明跟你说过：个人主页
🏅个人专栏：《大数据前沿：技术与应用并进》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、Hadoop简介
2、Hadoop集群概念
3、 Hadoop 集群的工作流程
二、安装环境准备
1、服务器
2、准备环境 三、集群部署 1、nameNode安装
2、dataNode安装 3、访问测试 一、引言 1、Hadoop简介 Hadoop 是一个由 Apache 软件基金会开发的开源框架，专门用于处理和存储海量数据。它以分布式计算为核心，可以在一个计算机集群上高效地处理和分析大规模数据集。Hadoop 的设计目标是提供可靠性、扩展性和分布式存储与计算的能力。以下是 Hadoop 的几个主要组件：
1. Hadoop 分布式文件系统 (HDFS)：
HDFS 是 Hadoop 的存储系统，专为处理大数据量设计。它将数据分割成块，并将这些块分布在集群中的多个节点上。HDFS 提供高吞吐量的数据访问，并通过数据的多副本来确保容错性和高可用性。 2. MapReduce：
MapReduce 是 Hadoop 的计算模型，用于处理和生成大规模数据集。它将任务分为两个阶段：Map 阶段和 Reduce 阶段。Map 阶段将输入数据分割成键值对进行处理，而 Reduce 阶段则汇总这些结果。这个模型非常适合处理大规模的分布式数据。 3. YARN (Yet Another Resource Negotiator)：
YARN 是 Hadoop 的资源管理器，它负责管理集群资源的调度和分配。YARN 允许多个数据处理引擎（如 MapReduce、Spark）在同一个集群上运行，并优化资源使用。 4. Hadoop Common：
Hadoop Common 包含了 Hadoop 框架中使用的通用工具和库。这些工具提供了文件系统和操作系统级别的抽象，以及各种实用程序库来支持 Hadoop 的其他模块。 Hadoop 的主要优势在于它的扩展性和成本效益。通过将数据和计算分布在大量廉价的计算机节点上，Hadoop 能够处理几乎无限量的数据，适合用于大数据分析、日志处理、数据仓库等场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302e82ee0daa041d0c40e36fee6a45e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad7d2cac95700bff32f61e1b9ad296c/" rel="bookmark">
			★ 算法OJ题 ★ 力扣202 - 快乐数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ciallo～(∠・ω&lt; )⌒☆ ~ 今天，我将和大家一起做一道双指针算法题--快乐数~
目录
一 题目
二 算法解析
三 编写算法
一 题目 202. 快乐数 - 力扣（LeetCode）
二 算法解析 题⽬告诉我们，当我们不断重复操作后，⼀定会出现死循环，有两种情况：
情况⼀：⼀直在 1 中死循环，即 1 -&gt; 1 -&gt; 1 -&gt; 1......。情况⼆：在历史的数据中死循环，但始终变不到 1。 因此，只要我们能确定循环中是否一直为1，就能得到结果。
那会不会出现一直没有循环的情况呢~ 以下是一个小证明~：
（鸽巢原理）：有n+1个鸽子，n个巢，则至少有一个巢的鸽子数大于1。
经过⼀次变化之后的最⼤值 9^2 * 10 = 810 ( 2^31-1=2147483647 。选⼀个更⼤的最⼤ 9999999999 )，也就是变化的区间在 [1, 810] 之间；根据鸽巢原理，⼀个数变化 811 次之后，必然会出现重复数；因此，变化的过程最终会⾛到⼀个圈⾥⾯，因此可以⽤快慢指针来解决。 算法思路：
此题有点像链表带环问题，可以用快慢双指针来求解，快慢指针有⼀个特性，就是在⼀个圆圈中，快指针总是会追上慢指针的，也就是说他们总会相遇在⼀个位置上。如果相遇位置的值是 1 ，那么这个数⼀定是快乐数；如果相遇位置不是 1 的话，那么就不是快乐数。
三 编写算法 class Solution { public: int bitsum(int x) // 返回n这个数每⼀位上的平⽅和 { int tmp = 0; int sum = 0; while (x) { tmp = x % 10; sum += tmp * tmp; x /= 10; } return sum; } bool isHappy(int n) { int slow = n, fast = bitsum(n); //若fast也是n的话就不会进循环 while (slow !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad7d2cac95700bff32f61e1b9ad296c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94cec0c7ab73632cba5eaea8c38c9b0a/" rel="bookmark">
			★ 算法OJ题 ★ 力扣11 - 盛水最多的容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ciallo～(∠・ω&lt; )⌒☆ ~ 今天，我将和大家一起做一道双指针算法题--盛水最多的容器~
目录
一 题目
二 算法解析
三 编写算法
一 题目 11. 盛最多水的容器 - 力扣（LeetCode）
二 算法解析 解法1：暴力枚举 算法思路：双层循环，枚举出能构成的所有容器，找出其中容积最⼤的值。（会超时）
解法2：对撞指针 如题目中的示例1：1 8 6 2 5 4 8 3 7
算法思路：
设两个指针 left ， right 分别指向容器的左右两个端点，容器的左边界为 height[left] ，右边界为 height[right] 。
如果此时我们固定⼀个边界，改变另⼀个边界，假设height[left] &lt; height[right]，水的容积：
容器的宽度⼀定变小。由于左边界较小，决定了水的高度。如果改变左边界，新的水面高度不确定，但是⼀定不会超 过右边的柱⼦高度，因此容器的容积可能会增大。如果改变右边界，无论右边界移动到哪里，新的⽔⾯的⾼度⼀定不会超过左边界，也就是不会 超过现在的水面高度，但是由于容器的宽度减小，因此容器的容积⼀定会变小的。 故左边界和其余边界的组合情况都可以舍去。
循环上述过程，每次都可以舍去⼤量不必要的枚举过程，直到 left 与 right 相遇。期间产⽣的所有的容积里面的最大值，就是最终答案。
三 编写算法 class Solution { public: int maxArea(vector&lt;int&gt;&amp; height) { int left = 0, right = height.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94cec0c7ab73632cba5eaea8c38c9b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e02f1c2591ebed62947b8dce625efb2b/" rel="bookmark">
			关于IDEA的快捷键不能使用的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候IDEA的快捷键用不了，这时应该是快捷键发生冲突了，重新设置一下即可。以批量修改变量名称的shift + f6为例（我的这个快捷键用不了）：
初始的rename的快捷键为shift + f6
这个快捷键是冲突的，所以我们需要修改
改成Alt + Shift + F6，不会发生冲突
后续参考这篇文章即可：
【Intellij IDEA2023】批量修改变量名_idea怎么统一改变量名-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f96e8f8fe1364c11fbde5b020098ad/" rel="bookmark">
			基于php&#43;vue&#43;uniapp的医院预约挂号系统小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：PHP框架：php+uniapp数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：PhpStorm 系统展示
后台登录界面
管理员功能界面
用户管理
医生管理
科室分类管理
医生信息管理
预约挂号管理
系统管理
医生功能界面
用户登录界面
系统首页
医生信息界面
医院资讯界面
用户功能界面
用户信息界面
摘要
医院预约挂号系统小程序以php语言，b/s模式以及MySql作为后台运行的数据库。本系统主要包括首页、个人中心、用户管理、医生管理、科室分类管理、医生信息管理、预约挂号管理、系统管理等功能，通过这些功能的实现能够基本满足日常医院预约挂号管理的操作。
本文着重阐述了医院预约挂号系统小程序的分析、设计与实现，首先介绍开发系统和环境配置、数据库的设计，接着说明功能模块的详细实现，最后进行了总结。
研究背景
现代的医院预约挂号系统小程序，也应该摆脱人工管理的模式，使用计算机技术来进行信息管理工作。所以本次系统设计的医院预约挂号管理结合了文字、图像，并能实现医院预约挂号管理的功能，这也是一般医院预约挂号系统小程序的重要的要素。医院预约挂号系统小程序经过几年的实践和总结正在往更深入的方向发展。由此，人们要改善系统功能迫在眉睫。随着科学技术的飞速发展，医院预约挂号系统小程序也要不断完善其工作流程的繁杂性、多样化、管理复杂、收缴费用与设备维护繁琐等存在的问题。所以要通过计算机胜任医院预约挂号管理的工作，使医院预约挂号系统更加准确、方便及快捷。
因此，开发出一套高效率、低差错的医院预约挂号系统是十分必要。本系统主要目的是全面实现医院预约挂号系统小程序数字化，管理员对于用户的所有信息能够全部掌握，而用户能够对自己的医院预约挂号信息能够有一个直观的了解。
关键技术
PHP，原名Hypertext Preprocessor。它是属于内嵌式语言，在服务器上执行嵌入HTML的脚本语言，有点像C语言的风格，运用的比较广泛。Hypertext Preprocessor混合了 Perl 、C、Java和自己创新的语法。综合成比前者执行动态网页更快。与其他的语言相比较，嵌入到HTML执行，效率要比完全生成HTML的CGI要高；PHP又能执行编译后代码，能做到加密、优化代码运行，让代码运行的速度更快。PHP的功能非常强大， CGI有的功能PHP都可以实现，几乎所有流行的数据库和操作系统它都可以支持。C、C++进行程序PHP也是可以用的扩展！
PHP包括：专业专注、源代码开放、免费使用、跨平台性强、快捷、面向对象、效率高、图像处理等特点。
JS-SDK是对之前的 WeixinJSBrige 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放，在很短的时间内获得了极大的关注。从数据监控来看，绝大部分在微信内传播的移动网页都使用到了相关的接口。
JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 微信小程序 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。我们团队把很多技术精力放置在如何帮助平台上的微信小程序开发者解决这个问题。因此我们设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 微信小程序 资源离线存储”。
Vue是一款流行的开源JavaScript框架，用于构建用户界面和单页面应用程序。Vue的核心库只关注视图层，易于上手并且可以与其他库或现有项目轻松整合。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
管理员登陆系统后，可以对首页、个人中心、用户管理、医生管理、科室分类管理、医生信息管理、预约挂号管理、系统管理等功能进行相应操作。在医生管理页面可以对索引、医生工号、医生姓名、性别、头像、电话号码等内容进行详情，修改或删除等操作。在预约挂号管理页面可以对索引、预约编号、医生工号、医生姓名、科室分类、挂号费、图片、预约时间、用户账号、用户姓名、是否支付、审核回复、审核状态等内容进行详情，修改或删除等操作。在医院资讯页面可以对索引、标题、图片等内容进行详情，修改或删除等操作，还可以对轮播图管理进行详细操作。医生登陆系统后，可以对首页、个人中心、预约挂号管理等功能进行相应操作。
用户通过输入账号和密码，选择角色并点击登录进行系统登录操作。用户登陆小程序端，可以对首页、医生信息、医院资讯、我的等功能进行详细操作。在医生信息页面可以查看医生姓名、医生工号、图片、科室分类、挂号费、医生介绍等信息，并根据需要进行立即预约操作。在医院资讯页面可以查看标题、图片、简介、内容等详细信息。在我的页面可以对个人中心，预约挂号等功能进行详细操作。
系统测试
软件测试的方法有好几种，但目前主要采用的是包括以功能为主要测试方向的黑盒测试以及以逻辑为主要测试方向的白盒测试，这是两种不同的测试方法，针对的测试侧重点不同，本课题根据实际需求情况，选择以功能为主要的黑盒测试方法，同时测试是要遵循一定的规则来执行的，一个测试要执行其执行的依据一般是由测试用例来规定的，而测试用例一般是依据需求或说明书来综合制定的，测试在硬件出厂前是十分重要的一个过程，本课题由于时间和精力的关系，选择以实现的功能作为测试要点来进行测试。
结论
在这次毕业设计中，我使用了PHP语言，选择MySQL作为后台数据库进行访问及修改。在设计开始之初，我也在苦恼于系统的逻辑功能的具体实现，因为我对于医院预约挂号管理的概念还较为模糊，其间我也查询了大量的网上资料，清楚了解实际生活中医院预约挂号管理主要面对的对象和管理需要完成的基本功能。
（可运行源码+sql文件+文档）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ac1977a1c0d87c08ee75ae3091dfe3/" rel="bookmark">
			域名证书，泛域名证书，sni
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、证书1.全域名证书2.泛域名证书 二、域名证书的使用1、浏览器请求域名证书流程对全域名证书的请求流程对泛域名证书的请求流程ssl client-hello携带server name 报文 2、浏览器对证书的验证流程 三、域名证书和sni 前言 本文介绍了泛域名证书和全域名证书的区别和使用情况，以及sni的原理。
一、证书 1.全域名证书 域名证书的使用者CN字段和使用者可选名称DNS Name字段没有包含*，该类证书一般是一个证书对应一个网站的ip地址，对应一个或者多个域名(一个证书的DNS Name里面可以包含多个全域名)。
CN字段对应浏览器访问的域名。
DNS Name字段是对CN字段的补充，DNS Name字段可以包含多个域名，浏览器也可以访问DNS Name里面的域名。
2.泛域名证书 域名证书的使用者CN字段和使用者可选名称DNS Name字段包含*，该类证书可以给多个不同的Ip使用，每个ip又可以对应多个域名。
例如： *.csdn.net 中的 *可以是任意内容，a.csdn.net和b.csdn.net都能返回该证书。
但是a.b.csdn.net就不能匹配 *.csdn.net,他只能匹配 *.b.csdn.net。所以泛域名证书 * 只能包含一级域名。
二、域名证书的使用 1、浏览器请求域名证书流程 对全域名证书的请求流程 浏览器将域名封装在ssl client hello报文的扩展项server name中，服务器对域名证书进行匹配，返回域名对应的证书，这就是sni。
对泛域名证书的请求流程 不同的ip 可以导入同一个泛域名证书，通过DNS域名解析就能访问指定的网站。泛域名证书能够减少证书的签发，某一类服务都可以只用一个泛域名证书。
ssl client-hello携带server name 报文 2、浏览器对证书的验证流程 1.证书是否可信
服务器返回证书和证书链，浏览器从自己的内置ca或者从windows等系统的内置ca中通过证书的签发者名称找到对应的根证书，通过证书的公钥对下一级证书进行验签，一直追溯到根证书则证书可信。
2.证书有效性
包括证书是否过期、是否被吊销、密钥长度是否安全、使用的相关算法是否安全。
3.证书域名是否匹配
通过浏览器访问的域名比较CN字段和DNS Name字段看是否匹配。
三、域名证书和sni “SNI"通常指的是"Server Name Indication”，它是一个扩展的TLS/SSL协议功能，用于告知服务器客户端想要连接到哪个特定网站。这对于在同一个IP地址上托管多个安全网站（具有不同的主机名）是必要的。
SNI解决了在同一IP地址上使用多个SSL证书的问题，允许用户通过一个IP地址访问多个加密的HTTP服务。没有SNI，每个域名都需要一个专用的IP地址才能拥有自己的SSL证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16168f8faf653c70a001329ecb13a9d7/" rel="bookmark">
			计算机网络 第1章 概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 计算机网络概念计算机网络的组成计算机网络的功能三种数据交换技术电路交换（Circuit Switching）报文交换（message）分组交换 三种交换方式性能对比计算机网络的分类计算机网络的性能指标性能指标1：速率性能指标2：带宽性能指标3：吞吐量性能指标4：时延性能指标5：时延带宽积性能指标6：往返时延性能指标7：信道利用率 计算机网络分层结构PDU、SDU、PCI的概念协议三要素OSI参考模型TCP/IP模型 计算机网络概念 计算机网络（Computer networking）是一个分散的、自治的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。
计算机网络（简称网络）：由若干结点（node）和连接这些结点的链路（link）组成。
结点可以是计算机、集线器、交换机、路由器等链路可以是有线链路、无线链路集线器(Hub)： 可以把多个结点连接起来，组成一个计算机网络普通民用领域已很少用集线器 交换机（Switch） 可以把多个结点连接起来，组成一个计算机网络家庭、公司、学校通常用交换机组建内部网络 路由器（router） 可以把两个或多个计算机网络互相连接起来，形成规模更大的计算机网络，也可称“互连网”路由器工作在网络层 计算机网络课程中的“路由器”和“家用路由器”有一些区别。
家用路由器=路由器+交换机+其他功能
交换机的作用是组建一个计算机网络，路由器的作作用是连接两个或多个计算机网络。
互联网(因特网,Internet)
ISP：Internet Service Provider，即互联网服务提供商，如中国电信/移动/联通
互联网(因特网,Internet)：由各大ISP和国际机构组建的，覆盖全球范围的互连网(internet)
互联网必须使用TCP/IP协议通信互连网可使用任意协议通信 计算机网络的组成 计算机网络的功能 三种数据交换技术 电路交换（用于电话网络）报文交换（用于电报网络）分组交换（用于现代计算机网络） 电路交换（Circuit Switching） 通过物理线路的连接、动态地分配传输线路资源
电路交换过程：
建立连接（尝试占用通信资源）通信（一直占用通信资源）释放连接（归还通信资源） 电路交换的优点：
数据直达，传输速率高。通信前从主叫端到被叫端建立一条专用的物理通路，在通信的全部时间内，两个用户始终占用端到端的线路资源。 电路交换的缺点：
建立/释放；连接，需要额外的时间开销线路被通信双方独占，利用率低线路分配的灵活性差交换节点不支持“差错控制”（无法发现传输过程中发生的数据错误） 电路交换更适用于：低频次、大量传输数据
计算机之间数据往往是“突发式”传输，即往往会高频词、少量地传输数据。
报文交换（message） 报文交换的优点：
通信前无需建立连接数据以“报文”为单位被交换节点间“存储转发”，通信线路可以灵活分配在通信时间内，两个用户无需独占一整条物理线路。相比于电路交换，线路利用率高交换节点支持“差错控制”（通过校验技术） 报文交换缺点：
报文不定长，不方便存储转发管理长报文的存储转发时间开销大、缓存开销大长报文容易出错、重传代价高 分组交换 报文(不定长)的控制信息包含源地址、目的地址等
分组(定长)的控制信息包含源地址、目的地址：分组号等。
分组交换的优点：
分组前无需建立连接数据以“分组”为单位被交换节点间“存储转发”，通信线路可以灵活分配在通信时间内，两个用户无需独占一整条物理线路。相比于电路交换，线路利用率高交换节点支持“差错控制”（通过校验技术） 相比于报文交换，分组交换改进了如下问题：
分组定长，方便存储转发管理分组的存储转发时间开销小、缓存开销小分组不易出错，重传代价高 分组交换的缺点：
相比于报文交换，控制信息占比增加相比于电路交换，依然存在存储转发时延报文被拆分为多个分组，传输过程中可能出现失序、丢失等问题，增加处理 的复杂度。 虚电路交换技术（基于分组交换）
虚电路交换的过程
建立连接（虚拟电路）通信（分组按序、按已建立好的既定线路发送，通信双方不独占线路）释放连接 三种交换方式性能对比 计算机网络的分类 按分布范围分类
广域网（WAN）城域网（MAN）：与局域网类似局域网（LAN）：交换机个域网（PAN）：蓝牙、zigbee
按传输技术分类
广播式网络：当一台计算机发送数据分组时，广播范围内所有计算机都会收到该分组，并通过检查分组的目的地址决定是否接收该分组。（所有无线网络都是广播式）点对点网络：数据只会从发送方“点对点”发到接受法，精准送达。（路由器转发的数据分组） 按拓扑结构分类
总线形结构：数据“广播式”传送，存在“总线争用”问题(典型代表：集线器连接的设备)环形结构：数据“广播式”传输，通过“令牌”解决总线争用问题，令牌顺环形依次传递，拿到令牌者可使用总线(典型代表：令牌环网流行语2000年以前的局域网技术)星形结构：由中央设备实现数据的“点对点”传输，不存在”总线争用“问题(典型代表：以太网交换机连接的设备)网状结构：数据通过各中间节点逐一存储转发，属于“点到点”传输(典型代表：由众多路由器构建的广域网) 按使用者分类
公用网——向公众开放的网络。如：办宽带、交手机话费即可使用的互联网专用网——仅供某个组织内部使用的网络。如：政府、军队、电力、银行的内部网络。 按传输介质分类
有线网络——如：网线、光纤无线网络——如：5G、WIFI、卫星 计算机网络的性能指标 速率、带宽、吞吐量时延、时延带宽积、往返时延信道利用率 信道（Channel）：表示向某一方向传送信息的通道（信道≠通信线路）一条通信线路在逻辑上旺旺对应一条发送信道和一条接收信道。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16168f8faf653c70a001329ecb13a9d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54cda731157cf4840ded1686efcaeef/" rel="bookmark">
			Super Image 2.1.0 图像处理软件，修复老照片、无损放大、智能修复，本地处理保护隐私
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.一款开源免费、功能强大的图像处理软件
2.支持修复老照片、增大图片尺寸、智能修复等
3.本地处理，无需担心隐私问题
链接：https://pan.quark.cn/s/891ef24f337b
📁大小：163M
🏷标签：#Super Image #图像处理 #安卓 #画质增强 #工具
夸克网盘: https://pan.quark.cn/s/891ef24f337b
中国移动云盘: https://caiyun.139.com/m/i?2gR32FgSpBCfc
UC网盘: https://drive.uc.cn/s/95ab3cb37cad4?public=1
百度网盘: https://pan.baidu.com/s/1at6FuRAWo5ly2eRKggR5MQ?pwd=olxt 提取码: olxt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662a6f4db2b7579e03df9c29622745f0/" rel="bookmark">
			Docker数据卷和Dockerfile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是Docker数据卷 前言：
在下载的镜像中，我们不能够去改变它内部的一些配置，因为docker的镜像文件是已经配置好的，无法改变，我们只能改变镜像启动后的容器里面的内容，但是又因为，容器本来就是一个临时的，当容器停止了，那么我们内部的一些存储的数据也将会丢失，那么docker官方为了能够解决这个临时性的问题而产生了数据卷（volume）这个组件。
Docker 数据卷（Volumes）是 Docker 中用于持久化和共享数据的机制。数据卷使得 Docker 容器可以在容器生命周期之外持久化数据，并且方便在不同容器之间共享数据。具体来说，Docker 数据卷的特点和功能包括：
持久化数据：
数据卷可以将数据从容器内部持久化到宿主机上的文件系统中，这样即使容器被删除，数据仍然存在。 容器之间共享数据：
数据卷可以被多个容器挂载和使用，允许容器之间共享数据。比如，可以用来共享配置文件、数据库数据等。 独立于容器生命周期：
数据卷的生命周期独立于容器。即便容器被删除或重建，数据卷中的数据仍然保留，用户可以在新创建的容器中继续使用这些数据。 易于备份和恢复：
数据卷可以被备份和恢复，通常通过宿主机的文件系统进行。这使得数据的备份和恢复变得相对简单。 数据管理：
可以通过 Docker 命令进行数据卷的管理，包括创建、删除、列出等操作。例如，docker volume create 用于创建数据卷，docker volume rm 用于删除数据卷。 性能和安全性：
数据卷存储在宿主机的文件系统上，通常性能较好。与容器内的临时文件相比，数据卷也提供了更好的数据持久性和安全性。 2、数据卷的指令 1）创建数据卷：
docker volume create 名称 使用这种方式创建的数据卷可也被docker volume管理，如查看，删除等。新建的数据卷被保存在/var/lib/docker/volumes目录下。 2）查看数据卷：
docker volume ls 3）查看数据卷的详细信息：
docker volume inspect 数据卷的名称 4）删除数据卷：
docker volume rm 数据卷名称 3、数据卷的使用 3.1、数据卷挂载 1）创建数据卷
docker volume create 数据卷名称 2）将数据卷挂载到容器
docker run -it --name 定义容器名称 --mount source=数据卷名称,target=容器挂载点（也就是在容器中所存在的文件夹） ubuntu:18.04(需要启动的镜像) 当然也存在简写方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/662a6f4db2b7579e03df9c29622745f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb44258d7fa607cfe967ef531e83907/" rel="bookmark">
			python计算机视觉编程第四章——照相机模型与增强现实
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、针孔照相机模型 针孔照相机模型(有时称为射影照相机模型)是计算机视觉中广泛使用的照相机模型。针孔照相机模型简单,并且具有足够的精确度。这个名字来源于一种类似暗箱机的照相机。该照相机从一个小孔采集射到暗箱内部的光线。在针孔照相机模型中,在光线投影到图像平面之前,从唯一一个点经过，也就是照相机中心C。
1照相机矩阵 照相机矩阵可以分解为: 标定矩阵仅和照相机自身的情况相关,在大多数情况下，倾斜参数s可以设置成0,默认设置 α=1.经过这些假设，标定矩阵变为：
2三维点的投影 创建照相机类，处理对照相机和投影建模所需要的全部操作主要代码：
from numpy import * from scipy import linalg class Camera(object): """ Class for representing pin-hole cameras. """ def __init__(self,P): """ Initialize P = K[R|t] camera model. """ self.P = P self.K = None # calibration matrix self.R = None # rotation self.t = None # translation self.c = None # camera center def project(self,X): """ Project points in X (4*n array) and normalize coordinates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb44258d7fa607cfe967ef531e83907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a17d10598536e790c8d6497bbf5b375/" rel="bookmark">
			sql92语句与sql99语法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景:测试sql92语句与sql99语法的区别
–创建测试表
CREATE table ypg_08161 as
select ‘1’ as id ,‘one’ as c_name
union all
select ‘2’ as id ,‘two’ as c_name
CREATE table ypg_08162 as
select ‘1’ as id ,‘male’ as c_sex
union all
select ‘3’ as id ,‘female’ as c_sex
第一类:inner join
–sql92语法
select a.id, a.c_name, b.c_sex from ypg_08161 a, ypg_08162 b where a.id=b.id;
id c_name c_sex
1 one male
–sql99语法
select a.id, a.c_name, b.c_sex from ypg_08161 a join ypg_08162 b on a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a17d10598536e790c8d6497bbf5b375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ba2999ca8f94698fa6a80be2c186a7/" rel="bookmark">
			使用Ansible实现高效服务器配置管理的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Ansible实现高效服务器配置管理的最佳实践 在现代IT运维中，服务器的配置管理是一个关键环节。传统的手动配置方法不仅耗时耗力，而且容易出错，特别是在规模庞大的服务器集群中，配置的一致性难以保证。Ansible作为一款无代理的自动化运维工具，通过其易用性和灵活性，提供了一种高效的服务器配置管理解决方案。本指南将从基础到高级应用，详细介绍使用Ansible实现高效服务器配置管理的最佳实践。
目录 什么是服务器配置管理？Ansible在配置管理中的优势Ansible环境搭建与基础配置 安装Ansible配置SSH免密登录设置Inventory文件 编写高效的Ansible Playbooks Playbook的基本结构编写高效的任务和剧本使用变量与模板 使用Roles实现模块化配置管理 Roles的基本结构创建和使用RolesAnsible Galaxy的应用 Ansible的安全实践 使用Ansible Vault保护敏感信息控制访问权限 Ansible的性能优化 提升Playbook执行速度高效的任务并行化 错误处理与调试 常见错误类型及解决方案调试与日志管理 Ansible与CI/CD集成Ansible的最佳实践总结结语 什么是服务器配置管理？ 服务器配置管理是指对服务器的操作系统、应用程序、服务以及相关配置进行自动化和标准化的管理过程。其目标是确保服务器配置的一致性、稳定性和安全性。配置管理的关键任务包括：
软件的安装和更新配置文件的管理服务的启动和停止系统安全设置 传统的配置管理依赖于手工操作，容易导致配置不一致、遗漏或错误。随着服务器数量的增加，传统方法显得力不从心。自动化配置管理工具如Ansible应运而生，通过自动化脚本和配置模板，实现服务器配置的标准化和自动化。
Ansible在配置管理中的优势 Ansible在配置管理中的优势主要体现在以下几个方面：
无代理（Agentless）： 无需在受控节点上安装任何代理软件，减少了系统资源的占用和管理复杂度。易用性： Ansible使用简单易懂的YAML语法编写Playbooks，无需编程背景即可上手。模块化： 通过模块（Modules）和角色（Roles），Ansible可以方便地组织和复用配置任务。扩展性： Ansible支持自定义模块和插件，能够满足复杂的配置需求。安全性： Ansible通过SSH或WinRM与受控节点通信，并支持Ansible Vault加密敏感数据。 Ansible环境搭建与基础配置 安装Ansible Ansible的安装过程相对简单，通常通过包管理器即可完成安装。以下是基于不同操作系统的安装方法：
# 在Debian/Ubuntu上安装Ansible sudo apt update sudo apt install ansible -y # 在CentOS/RHEL上安装Ansible sudo yum install ansible -y # 在MacOS上通过Homebrew安装Ansible brew install ansible 安装完成后，可以通过ansible --version命令检查Ansible是否成功安装。
配置SSH免密登录 Ansible默认通过SSH与受控节点通信，为了实现自动化管理，需要配置SSH免密登录。具体步骤如下：
生成SSH密钥对：
ssh-keygen -t rsa -b 2048 将公钥复制到受控节点：
ssh-copy-id user@managed_node_ip 测试连接：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4ba2999ca8f94698fa6a80be2c186a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29d0792236934f4e9162fc2dc5ea9d2/" rel="bookmark">
			「Python程序设计」条件控制：if-elif-else语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在进行程序设计的过程中，基本上遵循的过程是，找出变量和常量，通过python编程语言，设置变量和常量，以及考虑是否需要赋予初始值。
设计变量和常量，其实就是为了模拟和计算我们的现实世界中，需要进行计算的实体。
比如说，我们要计算人口数量，那我们先要定义一个人员的变量，比如说是person。然后把要计算的范围内的person变量，依次相加，最后得出我们需要的人口数量信息，这个是设计变量和常量的过程。
还有些时候，我们需要对参与计算的变量，进行判断。让符合要求的部分，进入到我们的计算过程，这就是条件控制的过程。
比如说，我们在计算人口数量的时候，只想计算性别为男性的这部分数据，得出男性的总人口数量。那我们就需要对person变量，进行判断，如果是男性，就参加计算。如果是女性，或者是异常值的话，就不参加计算。
在日常的程序设计过程中，条件控制是一个经常使用的，用来判断变量和常量是否符合我们计算的需求，是我们对程序进行自由掌控的基础。
我们的程序设计，和程序开发，基本上就是一个计算和控制的过程。通过计算和控制，得出我们所需要的结果。
Python条件语句的执行过程
Python 条件语句是通过一条，或多条语句的执行结果（True 或者 False）来决定执行的代码块。
可以通过下图来简单了解条件语句的执行过程。
以上过程，其实我们可以通过一句话来加深理解，那就是：如果，那么，否则。比如说，如果person是男人（true），那么汇总变量加1，否则（false）结束。
代码的执行过程，如下图所示。
这是用伪代码表示的条件语句执行过程。
if-elif-else语句
Python中if语句的一般形式如下所示：
if condition_1:
statement_block_1
elif condition_2:
statement_block_2
else:
statement_block_3
1、如果 "condition_1" 为 True 将执行 "statement_block_1" 块语句
2、如果 "condition_1" 为False，将判断 "condition_2"
3、如果"condition_2" 为 True 将执行 "statement_block_2" 块语句
4、如果 "condition_2" 为False，将执行"statement_block_3"块语句
Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。
注意：
1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。
2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。
3、在 Python 中没有 switch...case 语句，但在 Python3.10 版本添加了 match...case，功能也类似。
以下是一个简单的 if 实例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c29d0792236934f4e9162fc2dc5ea9d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4caa343370e23da566ebf8083be31a01/" rel="bookmark">
			Vue3组件通信概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件通信分为树组件和跨组件通信
树组件就是有直接关联关系的组件，比如：父子组件、祖孙组件
跨组件没有关联关系的组件：在层级较深的组件调用顶级的组件，比如某个组件传值定义在App.vue里面的组件，比如全局弹窗组件
组件树通信有： props/emit
父组件
&lt;template&gt; &lt;div class="home"&gt; &lt;user-card :user="user" @update-user="updateUser" /&gt; &lt;/div&gt; &lt;/template&gt; ​ &lt;script setup&gt; import { ref } from 'vue' import userCard from '@/components/userCard.vue' const user = ref({ username: '张三', age: 18 }) const updateUser = (data) =&gt; { user.value = { ...user.value, ...data } } &lt;/script&gt; 子组件
&lt;template&gt; &lt;div class="user-card"&gt; &lt;h2&gt;用户信息&lt;/h2&gt; &lt;p&gt;姓名：{{ user.username }}&lt;/p&gt; &lt;p&gt;年龄：{{ user.age }}&lt;/p&gt; &lt;div class="info"&gt; &lt;button @click="$emit('updateUser', { username: 'Alan', age: 23 })"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4caa343370e23da566ebf8083be31a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22207c17952294f7f3f01fd533f3ada3/" rel="bookmark">
			哈希 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. “哈希”是什么？
2. 哈希冲突
3. 哈希函数 3.1 设计原则
3.2 常见哈希函数
4. 解决哈希冲突的两种常见方法
4.1 闭散列
4.2 开散列
4.3 散列表的扩容问题
5. 哈希表的实现 并 封装模拟实现unordered系列容器
6. 哈希的应用
6.1 位图 -- bitset
6.2 布隆过滤器 -- Bloom Filter 1. “哈希”是什么？ 在进入正题之前，先带大家看一下什么是序列式/关联式容器： 比如：vector、list、deque、 forward_list(C++11)等，这些容器统称为序列式容器，因为其底层为线性序列的数据结构，里面存储的是元素本身。
关联式容器也是用来存储数据的，与序列式容器不同的是，其底层为非线性结构，且里面通常存储的是&lt;key, value&gt;结构的键值对。
在C++98中，STL提供了底层为红黑树结构的一系列关联式容器（set/map/multiset/multimap），在查询时效率可达到log_2 N，即使最差情况下也只需要比较红黑树的高度次，相较 序列式容器的线性查找 效率更高；但当树中的节点非常多时（海量数据），查询效率也不理想。
由此可以得到结论：搜索的效率取决于搜索过程中关键码的比较次数。
那么最理想的搜索方法就是：可以不经过任何比较，直接就能将元素找到；或者退而求其次，将整体的比较次数降到最低。
至于如何做到呢，就是本文的重点 —— 哈希：构造一种存储结构，让其可以通过某种方法，使关键码（key）和 其存储位置建立一 一对应的映射关系。
当向该结构中： 插入元素时： 根据待插入元素的关键码，以这种方法得到该元素的存储位置并按此位置进行存放。
搜索元素时： 对元素的关键码进行同样的计算，得到存储位置，在结构中按此位置取元素决定是否搜索成功。
这样的方法就称为：哈希函数（hashfunc）
构造出来的结构称为：哈希表或散列表 如下示例一： 至此，就可以回答最初的问题：“哈希”是什么？—— "哈希" 是一种数据结构和算法的思想，通俗点说就是一种解决问题的思考方式和处理手段；不是某种具体的数据结构或容器。
而在C++11中，STL提供的4个 unordered 系列的关联式容器，其底层结构就是用 哈希思想 实现的。
（关于unordered系列容器的接口使用与红黑树结构的关联式容器使用方式基本类似，此处不赘述，可点击查看在线文档说明：unordered_map ，unordered_set ，unordered_multimap ，unordered_multiset )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22207c17952294f7f3f01fd533f3ada3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b8506e6f3e731e069ff892c1e6dcc8/" rel="bookmark">
			Java-数据结构-链表-LinkedList（二）|ू･ω･` )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本目录：
☛一、LinkedList（无头双向非循环链表的结构）：
☛ 二、LinkedList的模拟实现：
❄️1、操作方法：
▶（1）、display()方法：
▶（2）、size()方法：
▶（3）、contains(int key)方法：
▶（4）、addFirst(int data)方法：
▶（5）、addLast(int data)方法：
▶（6）、addIndex(int index,int data)方法：
▶（7）、remove(int data)方法：
▶（8）、removeAllKey(int data)方法：
❄️2、 总代码：
☛三、Java自带的LinkedList：
❄️1、LinkedList的使用：
♠（1）、LinkedList的构造方法：
♠（2）、LinkedList的常用操作：
▷1、indexOf(Object o)方法：
▷2、lastIndexOf(Object o)方法：
▷3、subList(int fromIndex, int toIndex)方法：
♠（3）、LinkedList的遍历： ▷1、使用sout直接遍历：
▷ 2、使用for-each直接遍历：
▷ 4、使用迭代器逆序遍历：
☛ 四、ArrayList和LinkedList的区别：
☛ 总结： 一、LinkedList（无头双向非循环链表的结构）： 对于我们的无头双向链表的结构呢，因为是双向的所以呢，我们每个节点要有两个存储地址的地方，一个存储数据的地方，这样呢，每一个节点都可以访问它的前一个节点和后一个节点了。
我们来看看它的结构是什么样的并且看看其对于结构代码的实现：
这个呢，就是双向无头非循环链表的节点的结构，其是由这以一个节点构成的。
我们来看看是怎样构成的：
我们结构看完了，我们来看看我们怎样使用代码来实现这个节点，我们来看：
二、LinkedList的模拟实现： ❄️1、操作方法： 我们在双向无头非循环链表中要实现的方法，和我们在单向无头非循环链表中的我们自己实现的方法是差不多的方法，所以我们也可以去实现IList接口，来重写方法，以便于管理。
▶（1）、display()方法： 打印双向无头非循环链表。
我们的display() 方法，还是非常简单的，我们只需要遍历一遍链表就可以了，都用不到prev这个地址，和我们在单行无头非循环链表中的代码是差不多的。我们来看：
▶（2）、size()方法： 返回链表的长度。
这个也和我们之前写单向无头非循环链表的方法是差不多的，我们直接看代码：
▶（3）、contains(int key)方法： 查找链表中是否有key这个数据的节点。
那么这个嘛，你懂得~
▶（4）、addFirst(int data)方法： 头插方法。
对于这个链表的头插方法呢和我们之前的不同，对于我们头插呢，要先把newNode的next放head，之后再把head的prev放newNode，之后我们要把head往前移动，但是呢在执行之前呢，我们要先注意的是，当我们的链表为空的时候呢，我们要把 newNode=head=last，我们来看看我们的思路图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27b8506e6f3e731e069ff892c1e6dcc8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/7/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>