<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78edcd9f8212a8025cea30c69f1b68d2/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(041)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
136、pandas.Series.ne方法
136-1、语法
136-2、参数
136-3、功能
136-4、返回值
136-5、说明
136-6、用法
136-6-1、数据准备
136-6-2、代码示例
136-6-3、结果输出
137、pandas.Series.eq方法
137-1、语法
137-2、参数
137-3、功能
137-4、返回值
137-5、说明
137-6、用法
137-6-1、数据准备
137-6-2、代码示例
137-6-3、结果输出
138、pandas.Series.product方法
138-1、语法
138-2、参数
138-3、功能
138-4、返回值
138-5、说明
138-6、用法
138-6-1、数据准备
138-6-2、代码示例
138-6-3、结果输出
139、pandas.Series.dot方法
139-1、语法
139-2、参数
139-3、功能
139-4、返回值
139-5、说明
139-6、用法
139-6-1、数据准备
139-6-2、代码示例
139-6-3、结果输出
140、pandas.Series.apply方法
140-1、语法
140-2、参数
140-3、功能
140-4、返回值
140-5、说明
140-6、用法
140-6-1、数据准备
140-6-2、代码示例
140-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 136、pandas.Series.ne方法 136-1、语法 # 136、pandas.Series.ne方法 pandas.Series.ne(other, level=None, fill_value=None, axis=0) Return Not equal to of series and other, element-wise (binary operator ne).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78edcd9f8212a8025cea30c69f1b68d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b72713aa86a2d091a4c7844c610d653/" rel="bookmark">
			微信各平台历史版本含下载地址大全（ 安卓 | Windows | MAC ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信-windows-版本历史
https://github.com/tom-snow/wechat-windows-versions/releases 微信-windows-x86版本历史
https://github.com/tom-snow/wechat-windows-versions-x86/releases 微信安卓版本历史
https://github.com/DJB-Developer/wechat-android-history-versions/releases 微信MAC版本历史
https://github.com/zsbai/wechat-versions/releases 安卓平台 软件版本更新日期下载地址微信 8.0.50 Android 版20240702https://dldir1.qq.com/weixin/android/weixin8050android2701_0x2800323e_arm64.apk微信 8.0.50 Android 版20240702https://dldir1.qq.com/weixin/android/weixin8050android2701_0x2800323c_arm64.apk微信 8.0.50 Android 版20240702https://dldir1.qq.com/weixin/android/weixin8050android2700_0x2800323c_arm64.apk微信 8.0.50 Android 版20240702https://dldir1.qq.com/weixin/android/weixin8050android2620_0x2800323c_arm64.apk微信 8.0.49 Android 版20240422https://dldir1.qq.com/weixin/android/weixin8049android2600_0x2800313d_arm64.apk微信 8.0.49 Android 版20240422https://dldir1.qq.com/weixin/android/weixin8049android2600_0x28003133_arm64.apk微信 8.0.48 Android 版20240318https://dldir1.qq.com/weixin/android/weixin8048android2580_0x28003036_arm64.apk微信 8.0.48 Android 版20240318https://dldir1.qq.com/weixin/android/weixin8048android2580_0x28003035_arm64.apk微信 8.0.48 Android 版20240318https://dldir1.qq.com/weixin/android/weixin8048android2580_0x28003033_arm64.apk微信 8.0.47 Android 版20240201https://dldir1.qq.com/weixin/android/weixin8047android2560_0x28002f36_arm64.apk微信 8.0.47 Android 版20240201https://dldir1.qq.com/weixin/android/weixin8047android2560_0x28002f30_arm64.apk微信 8.0.46 Android 版20240123https://dldir1.qq.com/weixin/android/weixin8046android2540_0x28002e34_arm64.apk微信 8.0.45 Android 版20240102https://dldir1.qq.com/weixin/android/weixin8045android2521_0x28002d34_arm64_1.apk微信 8.0.45 Android 版20240102https://dldir1.qq.com/weixin/android/weixin8045android2520_0x28002d33_arm64.apk微信 8.0.44 Android 版20231204https://dldir1.qq.com/weixin/android/weixin8044android2502_0x28002c3f_arm64.apk微信 8.0.44 Android 版20231204https://dldir1.qq.com/weixin/android/weixin8044android2502_0x28002c36_arm64.apk微信 8.0.44 Android 版20231204https://dldir1.qq.com/weixin/android/weixin8044android2501_0x28002c35_arm64.apk微信 8.0.44 Android 版20231204https://dldir1.qq.com/weixin/android/weixin8044android2500_0x28002c34_arm64.apk微信 8.0.43 Android 版20231106https://dldir1.qq.com/weixin/android/weixin8043android2480_0x28002b38_arm64_1.apk微信 8.0.42 Android 版20230922https://dldir1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b72713aa86a2d091a4c7844c610d653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba26cd2f6635426a8d5efec2390fb035/" rel="bookmark">
			Java中定时任务执行的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中定时任务执行的三种方式 1. 普通线程死循环1.1 优点1.2 缺点1.3 示例代码片段 2. 使用定时器 Timer2.1 优点2.2 缺点2.3 示例代码片段 3. 使用定时调度线程池 ScheduledExecutorService3.1 优点3.2 缺点3.3 示例代码片段 💖The Begin💖点点关注，收藏不迷路💖 在Java中，实现定时任务执行的需求非常常见，比如定时清理缓存、定时发送邮件等。Java提供了多种机制来实现这一功能，包括使用普通线程的死循环、Timer类以及ScheduledExecutorService接口。
1. 普通线程死循环 1.1 优点 实现简单，易于理解。 1.2 缺点 消耗CPU资源，因为需要不断检查时间是否到达。难以精确控制时间间隔，尤其是当执行的任务耗时较长时。线程管理复杂，需要手动控制线程的启动、停止等。 1.3 示例代码片段 new Thread(() -&gt; { while (!Thread.currentThread().isInterrupted()) { try { Thread.sleep(1000); // 等待1秒 // 执行定时任务 System.out.println("定时任务执行：" + System.currentTimeMillis()); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }).start(); 2. 使用定时器 Timer 2.1 优点 相对于普通线程死循环，Timer可以更灵活地安排任务执行。
可以安排只执行一次的任务，也可以安排重复执行的任务。
2.2 缺点 Timer线程是Java的单线程定时器，如果有任务执行时间过长，会影响后续任务的执行时间。
Timer的线程安全性问题，如果TimerTask的run方法抛出未检查的异常，Timer会终止所有任务的执行。
2.3 示例代码片段 Timer timer = new Timer(); timer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba26cd2f6635426a8d5efec2390fb035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ed1b069456b9f5a91ea8afbe5fedca/" rel="bookmark">
			【微服务】Spring Cloud Bus的注意事项和常用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 强烈推荐引言关键方面注意事项1. 消息代理选择2. 消息队列配置3. 消息持久化4. 幂等性5. 安全性6. 消息大小7. 性能监控8. 错误处理9. 版本兼容性10. 测试11. 配置同步12. 日志记录 常用示例示例 1: 配置同步配置服务器 (`config-server`)客户端服务 (`client-service`)触发配置刷新 示例 2: 事件广播示例 3: Spring Cloud Bus 整合 RabbitMQ 总结强烈推荐专栏集锦写在最后 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
引言 Spring Cloud Bus 是 Spring Cloud 框架中的一个强大功能，它通过轻量级消息代理（如 RabbitMQ 或 Kafka）连接分布式系统（通常是微服务）。它有助于在微服务架构的不同部分之间进行通信，并有助于跨集群传播状态变化。
关键方面 以下是 Spring Cloud Bus 的一些关键方面：
事件传播：
它使用消息代理来传播配置更改和其他状态更改，确保在不同的微服务实例之间保持一致性。
集中配置管理：
结合 Spring Cloud Config，Spring Cloud Bus 可以在不重启应用程序的情况下刷新多个应用程序实例的配置。例如，当在集中配置库中更新配置属性时，Spring Cloud Bus 可以将更改广播到所有相关服务。
可扩展性：
通过利用消息代理，Spring Cloud Bus 允许在分布式系统中进行可扩展的通信。这在大规模系统中尤为有用，因为服务之间的直接通信可能效率不高。
实现：
要实现 Spring Cloud Bus，通常需要在 Spring Boot 应用程序中包含相关依赖项，配置消息代理，并使用注解标记需要传播的配置更改或事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ed1b069456b9f5a91ea8afbe5fedca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3716300ac946602ffa55fddaff24d1d7/" rel="bookmark">
			NPOI 导出列太多或者数据太多爆内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期.net mvc 开发的项目运行一段时间的项目，突然用户反馈导出数据出现500错误。后面看到日志是内存爆了。我是使用NPOI 组件来进行导出，服务器也有8G内存，之前一直好好的。然后发现导出的execl数据才几万，列大概有2000多列,怎么这么容易爆。
可惜没有办法客户不想加配置，那就只能把数据网硬盘里面搞了。因为从数据库抓出来的数据需要多很多逻辑处理，所以没有办法直接从数据库直接导出到文件。
原本想过使用多个文件最后合并的方式，但是我比较懒不想搞，所以就查了一下 NPOI是支持硬盘存储临时数据的。
好了，下面是代码：
//---------------------------------------创建下载文档---------------------------------------
static IWorkbook workbook = null;
static string NewfileName;
//allen add 20240616使用SXSSFWorkbook方法，这个是放入硬盘的临时文件
public static string CreatModelToExcel1(int columns, DataTable data, string sheetName, bool isColumnWritten, string fileName)
{
fileName = System.AppDomain.CurrentDomain.BaseDirectory + "DownExcel/" + fileName;
NewfileName = System.AppDomain.CurrentDomain.BaseDirectory + "DownExcel/" + fileName;
if (data == null)
{
throw new ArgumentNullException("data");
}
if (string.IsNullOrEmpty(sheetName))
{
throw new ArgumentNullException(sheetName);
}
if (string.IsNullOrEmpty(fileName))
{
throw new ArgumentNullException(fileName);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3716300ac946602ffa55fddaff24d1d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef2a4e63570be95fc30559c6e6973f4/" rel="bookmark">
			LINUX高性能服务器框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.服务器模型：
1). C/S模型
：
此模型就是一个服务器能给多个客户端提供服务，但所以资源都被服务端所占有，客户端想要获取只能通过请求连接服务端去获取。由于客户端的请求访问是异步的，所以需要一个手段进行此类事件的监听，比如SELECT或者是EPOLL，可以只监听服务器套接字，将客户端的客户需求交给子进程去处理，也可以进行同时监听，将连接对面的套接字加入，进行一起监听。
2).P2P模式
此模型放弃了以服务器为中心的观点，改为每个电脑的地位相同，既可以作为客户端，也可以作为服务端。
2.服务器大致框架：
不同差别服务器，其差别一般都于逻辑处理，但大体框架是一样的，如下图：
3.io模型：
I/O模型一般有如下几种：
阻塞I/O：即当客户端发起连接以后，服务端成功连接，但是服务/客户端因为某些原因无法立刻执行，从而被操作系统挂起，直到有消息或者要处理时，才会从等待队列中唤醒。可能被阻塞的I/O有accept(),connect(),send(),recv()等等。
非阻塞I/O：此类不会一直等待，比如可以设置一段事件进行等待，事件发生就立即进行返回。
同步/异步 I/O
4：两种高效的I/O模型：
1.): reactor模型（同步模型）：
如上图：就绪事件准备好之后插入就绪队列，然后唤醒请求队列进行不同的工作状态进行工作。
以同步I/O模拟proactor模式
注意如此，用同步I/O来模拟异步I/O时，发生读事件，将数据进行封装然后储存在队列中，然后注册写事件就绪，而写事件则是队列取出进行回馈返回。
5.高效的并发模式（主要运用线程池）：
1).半同步半异步：
半同步半异步指的就是同步用来处理用户逻辑，异步用来处理I/O事件：
但是上述模型有缺点：
8-11改良后的半同步/半异步模式，每个工作线程都可以通过epoll_wait()。来监听多个SOCKET进行服务。
2).领导/追逐者模式：读者能力有限，请自行 查阅资料
6.优先状态机，用来处理单元之间的逻辑问题：比如先处理什么，再处理什么，接着处理什么。
想象一个如下有限状态机：
下面是利用上述原理进行的分析HTTP请求的状态机。
#include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;assert.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #define BUFFER_SIZE 4096 enum CHECK_STATE { CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER, CHECK_STATE_CONTENT }; enum LINE_STATUS { LINE_OK = 0, LINE_BAD, LINE_OPEN }; enum HTTP_CODE { NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION }; static const char* szret[] = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef2a4e63570be95fc30559c6e6973f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e4e6419cd31ef3bb4c8d4df8f4da75/" rel="bookmark">
			Spring从入门到精通 01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 依赖注入 (Dependency Injection, DI)2. 面向切面编程 (Aspect-Oriented Programming, AOP)3. 事务管理4. 简化 JDBC 开发5. 集成各种框架和技术6. 模块化和扩展性：主要的 Spring 模块：Core Container：AOP 模块：Data Access / Integration 模块：Web 模块：Security 模块：Spring Boot Spring 扩展性事件驱动：自定义注解和组件：集成第三方框架和扩展： Spring 是一个开源的轻量级框架，用于构建企业级应用程序。它最初由 Rod Johnson 在 2002 年创建，并于2003年发布第一个版本。Spring 框架的核心理念是提供全面的基础设施支持，以帮助开发者构建各种 Java 应用程序。
1. 依赖注入 (Dependency Injection, DI) Spring 框架通过依赖注入来管理组件之间的依赖关系，降低了组件之间的耦合度，使得代码更加灵活和可维护。
查看 详解Spring依赖注入
2. 面向切面编程 (Aspect-Oriented Programming, AOP) Spring 提供了对 AOP 的支持，可以帮助开发者将横切关注点（如日志、事务管理等）从核心业务逻辑中分离出来，提高了代码的模块化程度。
查看 详解Spring 面向切面编程
3. 事务管理 Spring 提供了声明式的事务管理，通过注解或 XML 配置可以简化事务管理的配置和使用，支持不同的事务管理器实现。
查看 详解Spring 事务管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e4e6419cd31ef3bb4c8d4df8f4da75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d15f55bac9b6a1063c83043f2e7ed54/" rel="bookmark">
			[Python][Python入门]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0.铺垫1.常量和表达式2.变量3.变量的类型1.整数2.浮点数3.字符串4.布尔 4.动态类型特性5.注释∞.积累 0.铺垫 Python中，一个语句写完了之后，可以加上分号，也可以不加 通常情况下都是不加的，如果加了，也不算错如果把多个语句写到同一行了，此时就需要加上分号a = 10; print(a) 以下为他人实现/整理的一部分有趣的内容 整理了Python的一些非常实用的程序库使用简短的Python代码来实现一些有意思的程序 1.常量和表达式 Python中，类似 2 / 3 2/3 2/3的结果是一个小数，而不是C中的0，这更符合直觉 2.变量 定义变量a = 10 使用变量a = 10; print(a) 修改变量：在 Python 中，修改变量也是使用 = 运算，看起来和定义变量没有明显区别a = 20 print(a) 3.变量的类型 注意：和C/C++等语言不同，Python变量的类型不需要显式指定，而是在赋值的时候确定的 1.整数 默认大小4 Byte和C/C++等语言不同，Python的int类型变量，表示的数据范围是没有上限的，可以根据要表示的数据的大小，自动扩容只要内存足够大，理论上就可以表示无限大小的数据 a = 10 print(type(a)) 2.浮点数 固定大小8 Byte和C/C++等语言不同，Python的小数只有float一种类型，没有double类型但是实际上Python的float就相当于C/C++的double，表示双精度浮点数 a = 0.5 print(type(a)) 3.字符串 使用' '或者" "引起来的，称为字符串，可以用来表示文本 在 Python中，单引号构成的字符串和双引号构成的字符串，没有区别'SnowK'和"SnowK"是完全等价的 Python中，只有字符串类型，没有字符类型a = 'SnowK' print(type(a)) 如果字符串里引号套引号呢？myName = "My name is "SnowK"" 此时中间的"SnowK"，Python就会无法识别解决方案： 如果字符串里包含了双引号，表示字符串就可以用单引号引起来如果字符串里包含了单引号，表示字符串就可以用双引号引起来 如果同时有单引号和双引号，怎么办？myName = 'My 'name' is "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d15f55bac9b6a1063c83043f2e7ed54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3bbc2a2019d51322ca34bd6660c14f/" rel="bookmark">
			[MySQL][访问 -- 使用C API连接]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0.如何下载库？1.Connector/C 使用2.MYSQL接口介绍0.MYSQL结构体1.初始化 -- mysql_init()2.链接数据库 -- mysql_real_connect()3.下发MYSQL命令 -- mysql_query()4.获取执行结果 -- mysql_store_result()5.获取结果行数 -- mysql_num_rows()6.获取结果列数 -- mysql_num_fields7.获取列名mysql_fetch_fields8.获取结果内容 -- mysql_fetch_row9.关闭MYSQL链接 -- mysql_close()10.补充 3.图形化界面推荐 0.如何下载库？ 要使用C语言连接MYSQL，需要使用MYSQL官网提供的库，可以去官网下载也可以通过yum(Centos)或者apt(Ubuntu)直接安装mysql-devel 1.Connector/C 使用 下载的库格式如下： include 包含所有的方法声明lib 包含所有的方法实现(打包成库) . ├── include │ ├── big_endian.h │ ├── byte_order_generic.h │ ├── byte_order_generic_x86.h │ ├── decimal.h │ ├── errmsg.h │ ├── keycache.h │ ├── little_endian.h │ ├── m_ctype.h │ ├── m_string.h │ ├── my_alloc.h │ ├── my_byteorder.h │ ├── my_compiler.h │ ├── my_config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3bbc2a2019d51322ca34bd6660c14f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf1da9656c856e7622c932842b02e41/" rel="bookmark">
			JavaDS —— 排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
就例如上图所示：排序前，红色的5 在黑色的 5 之后，如果在排序后 红色的 5 在黑色的 5 之后就是稳定的，否则就是不稳定的。
稳定的排序算法可以变成不稳定的，但是不稳定的排序算法就不可能变成稳定的排序算法。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
插入排序 直接插入排序 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。实际中我们玩扑克牌时，就用了插入排序的思想。
直接插入排序
直接插入排序会让前面的元素有序，然后不断向后遍历将待排序的元素往前插入即可，直到所有的元素排序完成。
算法思想，首先使用一个大循环，从第二个元素开始遍历数组，因为我们设定第一个元素只用一个本身有序，所以从第二个元素开始排列。
然后接着一个小循环，就是从 i - 1 开始向前遍历，也就是从待排序的元素的前一个已排好的元素开始向前遍历，arr[j+1] = arr[j] ，直到找到恰当的位置将待排序的元素放好（arr[j+1] = tmp）
我们要提前将待排列的元素保存起来。
public static void insertSort(int[] array){ for (int i = 1; i &lt; array.length; i++) { int tmp = array[i]; int j = i - 1; for (; j &gt;= 0; j--) { if(array[j] &gt; tmp) { array[j+1] = array[j]; } else { array[j+1] = tmp; break; } } array[j+1] = tmp; } } 在 j 循环结束后还需要 array[j+1] = tmp; 是因为可能数组首元素的位置就是待排列的元素的位置，因此我们需要加上这一行代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf1da9656c856e7622c932842b02e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a423054128c2874fd3e9119798c3d8e/" rel="bookmark">
			Python中常用运算符的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题 Python的学习中我们常常需要使用一些运算符来使得代码逻辑成立或者或者运行成功，不同的运算符有不同的作用，需要我们区分并正确使用。
2 方法 通过上网搜查以及对日常学习的总结，对部分已经接触过的运算符做以下归纳： =（等于） ==(是否等于) ！
=(不等于) &lt;&gt;(不等于) &gt;(大于) &lt;(小于) &gt;=(大于等于) &lt;=(小于等于) 注意：在python中“=”并不是等于，而是赋值符号，应当从右往左读。
字符串运算符代码如下。
通过实验、实践等证明提出的方法是有效的，是能够解决开头提出的问题。
代码清单 1
字符串连接（+）#输出：ab
print('a'+'b')
重复字符串（*）#输出:aaa
print('a'*3) 索引字符串（[]）#输出:第二个e
a ='hello' print(a[1])
截取字符串([:]) #输出:ell
a ='hello'
print(a[1:4])
格式字符串（%） #输出: hello world
print('hello%s%s'%('wor','ld')) 3 结语 针对运算符使用不当的问题，我们可以通过归纳总结加多实操来尽量规避，虽然在本文中对一些常用的运算符的使用进行了总结但终归只是一部分。在未来的学习中应该及时总结并多实际操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e800c2e209f39b0e535a5a407624417/" rel="bookmark">
			ipsec VPN设备在边界情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
ipsec VPN设备在边界情况
基础配置
AR1
AR2
AR3
PC
边界路由器通测试
IPSEC VPN配置
1.抓流量
AR1
AR3
2.配置IKE的安全提议（五元组）
AR1
AR3
3.配置IKE对等体
AR1
AR2
4.配置IPSEC安全提议
AR1
AR3
5.配置IPSEC的安全策略
AR1
AR3
6.接口调用
测试
ipsec VPN设备在边界情况 AR1和AR3充当两私网的边界设备，AR2充当ISP，要求PC1和PC2通过IPSEC互通
基础配置 AR1 int g 0/0/0 ip add 12.0.0.2 24 int g 0/0/1 ip add 192.168.0.1 24 ip route-static 0.0.0.0 0 12.0.0.1 AR2 int g 0/0/0 ip add 12.0.0.1 24 int g 0/0/1 ip add 21.0.0.1 24 AR3 int g 0/0/0 ip add 23.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e800c2e209f39b0e535a5a407624417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb0dd0c8f718b21e3a3b2d42ee866a4/" rel="bookmark">
			图——图的遍历（DFS与BFS算法详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的文章中我们学习了图的基本概念和存储结构，大家可以通过下面的链接学习：
图的定义和基本术语
图的类型定义和存储结构
这篇文章就来学习一下图的重要章节——图的遍历。
目录
一，图的遍历定义：
二，深度优先搜索(DFS)
连通图的深度优先遍历
邻接矩阵法实现DFS
邻接表法实现DFS
DFS算法效率分析：
非连通图的深度优先遍历
三， 广度优先搜索（BFS）
邻接矩阵法实现BFS
邻接表法实现BFS
BFS算法效率分析：
DFS与BFS算法效率比较
一，图的遍历定义： 从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。
图遍历的实质：找每个顶点的邻接点的过程。
要进行图的遍历，我们需要知道图的特点，从而用合适，高效的方法来实现遍历。
图有哪些特点？
图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 那么，如何避免在遍历时重复访问？
解决思路：
设置辅助数组 visited [n ]，用来标记每个被访问过的顶点。
初始状态为0
被访问，改 visited [i]为1，防止被多次访问。
图常用的遍历有两种：
深度优先搜索（Depth First Search,DFS） 广度优先搜索(Breadth First Search,BFS) 二，深度优先搜索(DFS) 引例：
点亮迷宫中所有的灯，我们会一条道走到头，如果走不动了，再往回退寻找其他没有走过的。
因此我们可以总结DFS的详细归纳：
在访问图中某一起始顶点 v 后，由 v 出发，访问 它的任一邻接顶点 w 1 ； 再从 w 1 出发DFS 邻接 但还 未被访问 过的顶点 w 2 ； 然后再从 w 2 出发，进行类似的访问， … 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。 接着，退回一步， 退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。 如果有， 则访问此顶点，之后再从此顶点出发，进行与前述类似的访问。 如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fb0dd0c8f718b21e3a3b2d42ee866a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da936ab097e90d8aeaedf5523743dc9/" rel="bookmark">
			查找——散列表（哈希表）的查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的文章介绍了线性表及树表的查找算法：
查找的基本概念，线性表的顺序查找
线性表的折半查找与分块查找
查找——树表之二叉排序树
查找—树表之平衡二叉树
这篇文章则介绍散列表（即哈希表）的查找方法。
一，哈希表的构造 基本概念 •优点：查找速度极快O(1),查找效率与元素个数n无关。
例1：
若将学生信息按如下方式存入计算机，如：
将2001011810201的所有信息存入V[01]单元；
将2001011810202的所有信息存入V[02]单元；
……
将2001011810231的所有信息存入V[31]单元 查找2001011810216的信息，可直接访问V[16]！
例2：
数据元素序列(14，23，39，9，25，11)，若规定每个元素k的存储地址H（k）＝k，请画出存储结构图。
如何进行哈希表的查找？
根据哈希函数H（k）＝k
查找key=9,则访问H(9)=9号地址，若内容为9则成功； 若查不到，则返回一个特殊值，如空指针或空记录 我们需要知道以下概念： 哈希方法(杂凑法)
选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；
查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。
哈希函数(杂凑函数)：哈希方法中使用的转换函数。
哈希表(杂凑表)：按上述思想构造的表。
冲 突：不同的关键码映射到同一个哈希地址 。key1 ！=key2，但H(key1)=H(key2)
同义词：具有相同函数值的两个关键字。
具体什么是冲突呢？我们来看一个例子：
冲突是不可避免的，那么我们如何才能减少冲突？
（1）构造好的哈希函数
（2）制定一个好的解决冲突方案
构造好的哈希函数 (a)所选函数尽可能简单，以便提高转换速度;
(b)所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。
构造好的哈希函数，我们需要考虑以下因素：
根据元素集合的特性构造
要求一：地址空间尽量小
要求二：均匀
则有以下方法：
1.直接定址法 2.数字分析法 3.平方取中法 4.折叠法 5.除留余数法 6.随机数法 1. 直接定址法 Hash(key) = a·key + b (a、b为常数)
优点：以关键码key的某个线性函数值为哈希地址，不会产生冲突。
缺点：要占用连续地址空间，空间效率低。 例： {100，300，500，700，800，900}，哈希函数Hash(key)=key/100
2.除留余数法 Hash(key)=key mod p (p是一个整数)
通过计算出散列表中元素除以7得到的余数作为存储地址的位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0da936ab097e90d8aeaedf5523743dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c066c85205ba51e373cd976844a0e172/" rel="bookmark">
			【数据结构】二叉树——顺序结构——堆及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、树 1.1、树的概念和结构 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限节点组成的一个具有层次关系的集合。
树有一个特殊的节点，称为根节点，根节点没有前驱结点。
除根节点外，其余部分被分为M（M&gt;0）个互不相交的集合T1、T2、.....Tm，其中的每一个集合 Ti（1 &lt;= i &lt;= m）又是一颗结构与数类似的子树。每一颗子树的根节点都有且只有一个前驱节点，而可以有0个或者多个后继节点。
树是递归定义的。
在树形结构中，子树之间不能存在交集
子树中存在交集，就不是树形结构了
除了根节点以外，每一个节点有且只有一个父节点
如图，E节点存在两个父节点，该图不是树形结构。
一颗N个节点的树有 N-1条边
1.2、树的相关术语 在树形结构中，有一些相关术语：
父节点（双亲节点）：如果一个节点含有子节点，则这个节点称为其子节点的父节点；如上图：A就是B的父节点。
子节点：一个节点含有的子树的根节点称为该节点的子节点；如上图：B是A的子节点。
节点的度：一个节点存在几个子节点，它的度就是多少；如上图：A的度为6、F的度为2、K的度为0.
树的度：在一个树形结构中，最大的节点的度，称为树的度；如上图：树的度为6。
叶子结点（终端节点）：度为0的节点就是叶子节点；简单来说，就是没有子节点（下一个节点）；如上图：B、C、H、I 等节点都是叶子结点。
分支节点：度不为0的节点称为分支节点；如上图：D、E、F、G 等节点都是分支节点。
兄弟节点：具有相同的父节点的节点称为兄弟节点；如上图：B和C是 兄弟节点。
节点的层次：从树形结构的跟开始定义，跟为第 1 层，跟的子节点为第 2 层，以此类推。
树的高度：树中节点的最大层次；如上图：树的高度是 4 。
节点的祖先：从根到该节点所经过的分支上的所以节点。如上图：A是所有节点的祖先。
路径：一条从树的任意节点出发，沿父节点-子节点连接，到达任意节点的序列。比如上图中A到Q的路径：A-E-J-Q。
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
森林：右m（m&gt;0）个互不相交的树组成的集合称为森林。
1.3、树的表示 树的表示相对于线性表就复杂了，想要存储表示起来就很麻烦了，这里既要保存值域，也要保存节点和节点之间的关系；树有很多中表示方法，就比如：双亲表示法，孩子表示法，孩子双亲表示法以及孩子兄弟表示法等
这里看一下简单的孩子兄弟表示法
struct TreeNode { struct Node* child; // 左边开始的第⼀个孩⼦结点 struct Node* brother; // 指向其右边的下⼀个兄弟结点 int data; // 结点中的数据域 }; 这样的一个树就可以表示成下面这种形式
1.4、树形结构的分类和应用 树形结构分为很多种，具体如上图，
树形结构实际应用：
最典型的就是，计算机存储和管理文件的文件系统。它利用树形结构来组织和管理文件和文件夹。再文件系统中，树结构被广泛利用。通过父节点和子节点之间的关系来表示不同层级的文件和文件夹之间的关系
二、二叉树 2.1、二叉树的概念与结构 二叉树是树形结构的一种。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c066c85205ba51e373cd976844a0e172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3339addbdf5c53dd17761bb1ba565e78/" rel="bookmark">
			【栈和队列】算法题 ---- 力扣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过前面栈和队列的学习，现在来看这些算法题目
一、有效的括号 本题让判断括号是否有效
第一眼看可能没一点思路，但仔细分析一下；
我们学习过栈数据结构，知道栈先进后出的原则，那我们就可以使用啊；把题目的左括号存储起来，让右括号跟左括号一一比较。
思路：
遍历字符串，遇到左括号就括号入栈，遇到右括号就与栈顶数据进行对比，如果配对就继续；如果不配对，就返回false
画图分析：
现在有这样的括号字符串
遍历字符串，第一个是 { 左括号，就入栈
ps接着遍历， [ 依然是左括号，入栈
ps接着遍历， ( 还是左括号，入栈
ps接着遍历， ) 是右括号，与栈顶数据进行比较，括号匹配，出栈
ps接着遍历， ] 是右括号，与栈顶数据比较，括号匹配，出栈
ps接着遍历， } 是右括号，与栈顶数据进行比较，括号匹配，出栈
ps遍历完字符串，再判断栈是否为空？如果为空，就代表所以括号都匹配了；如果栈不为空，括号就不匹配。
此外，再遍历过程中，有依次括号不匹配就要直接返回false
力扣题代码如下：
typedef char SType; typedef struct Stack { SType* arr; int size; // 栈顶 int num; // 空间大小 } Stack; // 初始化 void STInit(Stack* ps) { assert(ps); ps-&gt;arr = NULL; ps-&gt;size = ps-&gt;num = 0; } // 判断栈是否为空 bool STEmpty(Stack* ps) { assert(ps); return ps-&gt;size == 0; } // 入栈 void STPush(Stack* ps, SType x) { assert(ps); // 判断空间大小是否足够 if (ps-&gt;num &lt;= ps-&gt;size) { int newnum = (ps-&gt;num == 0) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3339addbdf5c53dd17761bb1ba565e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b673be4c6968cef04e1c4ca381eb298/" rel="bookmark">
			SpringBoot整合Flink CDC，实时追踪mysql数据变动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❃博主首页 ： 「码到三十五」 ，同名公众号 :「码到三十五」，wx号 : 「liwu0213」 ☠博主专栏 ： &lt;mysql高手&gt; &lt;elasticsearch高手&gt; &lt;源码解读&gt; &lt;java核心&gt; &lt;面试攻关&gt; ♝博主的话 ： 搬的每块砖，皆为峰峦之基；公众号搜索「码到三十五」关注这个爱发技术干货的coder，一起筑基 我们将整合Spring Boot和Apache Flink CDC（Change Data Capture）来实现实时数据追踪。下面是一个基本的实践流程代码，包括搭建Spring Boot项目、整合Flink CDC以及实现数据变动的实时追踪。
文章目录 前言1. MySQL开启Binlog2. 创建Spring Boot项目3. 添加依赖4. 配置Flink和MySQL CDC5. 实现数据实时追踪6. 启动Spring Boot应用7. 运行并测试 前言 Flink CDC（Flink Change Data Capture）是一种基于数据库日志的CDC技术，它实现了一个全增量一体化的数据集成框架。与Flink计算框架相结合，Flink CDC能够高效地实现海量数据的实时集成。其核心功能在于实时监视数据库或数据流中的数据变动，并将这些变动抽取出来，以便进行进一步的处理和分析。借助Flink CDC，用户可以轻松地构建实时数据管道，实时响应和处理数据变动，为实时分析、实时报表和实时决策等场景提供有力支持。
Flink CDC的应用场景广泛，包括但不限于实时数据仓库更新、实时数据同步和迁移以及实时数据处理等。它还能确保数据一致性，并在数据发生变更时准确地进行捕获和处理。此外，Flink CDC支持与多种数据源进行集成，如MySQL、PostgreSQL、Oracle等，并提供了相应的连接器，便于数据的捕获和处理。
接下来，将详细介绍MySQL CDC的使用。MySQL CDC连接器允许从MySQL数据库中读取快照数据和增量数据。
1. MySQL开启Binlog MySQL中开启binlog功能，需要修改配置文件中（如Linux的/etc/my.cnf或Windows的\my.ini）的[mysqld]部分设置相关参数：
[mysqld] server-id=1 # 设置日志格式为行级格式 binlog-format=Row # 设置binlog日志文件的前缀 log-bin=mysql-bin # 指定需要记录二进制日志的数据库 binlog_do_db=testjpa 除了开启binlog功能外，还需要为Flink CDC配置相应的权限，以确保其能够正常连接到MySQL并读取数据。这包括授予Flink CDC连接MySQL的用户必要的权限，如SELECT、REPLICATION SLAVE、REPLICATION CLIENT、SHOW VIEW等。这些权限是Flink CDC读取数据和元数据所必需的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b673be4c6968cef04e1c4ca381eb298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc45fdc25823ccc4aa2ff15f62bc0476/" rel="bookmark">
			【C&#43;&#43;】关联容器探秘：Map与Multimap详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.映射类 map
0. 引入 pair：
1.定义
2.插入
3. 遍历
4.❗operator[]的实现
5. 插入
运用
2.Multimap 类
0. 引入：不去重的 Multi
1. Multimap 不支持 Operator[]
2. Multimap 的删除
1.映射类 map 0. 引入 pair： 在C++中，std::pair是一个非常有用的容器适配器，它属于C++标准模板库(STL)的一部分，主要用于存储两个相关联的数据项。std::pair的设计目的是为了方便地处理需要成对出现的数据，比如坐标点(x, y)、键值对(key, value)等。
std::pair由&lt;utility&gt;头文件提供，它包含两个成员，分别是first和second，这两个成员可以是任意类型的组合。std::pair的声明语法如下：
#include &lt;utility&gt; // 包含std::pair的定义 std::pair&lt;Type1, Type2&gt; myPair; 其中，Type1和Type2是你想要存储的两种类型。
创建pair实例 可以通过构造函数直接初始化std::pair：
std::pair&lt;int, double&gt; p1(1, 2.5); 也可以使用std::make_pair函数：
std::pair&lt;int, double&gt; p2 = std::make_pair(1, 2.5); 访问pair成员 std::pair的成员first和second可以直接访问：
std::pair&lt;int, double&gt; p(1, 2.5); int x = p.first; double y = p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc45fdc25823ccc4aa2ff15f62bc0476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6019b432cebd0bcf01dd4d0078792976/" rel="bookmark">
			pytorch backbone
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介 在PyTorch深度学习中，预训练backbone（骨干网络）是一个常见的做法，特别是在处理图像识别、目标检测、图像分割等任务时。预训练backbone通常是指在大型数据集（如ImageNet）上预先训练好的卷积神经网络（CNN）模型，这些模型能够提取图像中的通用特征，这些特征在多种任务中都是有用的。
1. 常见的预训练Backbone 以下是一些在PyTorch中常用的预训练backbone：
ResNet：由何恺明等人提出的深度残差网络，通过引入残差连接解决了深层网络训练中的梯度消失或梯度爆炸问题。ResNet系列包括ResNet-18、ResNet-34、ResNet-50、ResNet-101、ResNet-152等，数字表示网络的层数。VGG：由牛津大学的Visual Geometry Group提出，特点是使用了多个小卷积核（如3x3）的卷积层和池化层来构建深层网络。VGG系列包括VGG16、VGG19等。MobileNet：专为移动和嵌入式设备设计的轻量级网络，通过深度可分离卷积减少了计算量和模型大小。DenseNet：通过密集连接（dense connections）提高了信息流动和梯度传播效率，进一步增强了特征重用。EfficientNet：通过同时缩放网络的深度、宽度和分辨率来优化网络，实现了在保持模型效率的同时提高准确率。 2. 如何使用预训练Backbone 在PyTorch中，使用预训练backbone通常涉及以下几个步骤：
导入模型：使用PyTorch的torchvision.models模块导入所需的预训练模型。
import torchvision.models as models # 导入预训练的ResNet50模型 resnet50 = models.resnet50(pretrained=True) print(resnet50) 修改模型：根据需要修改模型的最后几层以适应特定的任务（如分类任务中的类别数）。
# 假设我们有一个100类的分类任务 num_ftrs = resnet50.fc.in_features resnet50.fc = torch.nn.Linear(num_ftrs, 100) 冻结backbone：在训练时，可以选择冻结backbone的参数，只训练新添加的层（如分类层），这有助于加快训练速度并防止过拟合。
for param in resnet50.parameters(): param.requires_grad = False # 只对新添加的层设置requires_grad=True resnet50.fc.parameters().requires_grad = True 训练模型：使用适当的数据集和训练策略来训练模型。
评估模型：在测试集上评估模型的性能。
3. 注意事项 使用预训练权重时，应确保输入图像的预处理（如大小调整、归一化等）与预训练时使用的预处理一致。冻结backbone时，应确保模型的其余部分（如新添加的层）有足够的容量来学习任务特定的特征。在某些情况下，解冻backbone的一部分或全部并在目标数据集上进行微调可能会获得更好的性能。 通过以上步骤，可以在PyTorch中有效地利用预训练backbone来解决各种计算机视觉任务。
2 查看模型源码 想查看models.resnet50的源码，可以点击查看pytorch中的官方注释，可以看到源码链接为
vision/torchvision/models/resnet.py at main · pytorch/vision · GitHub
这样就可以看到 class ResNet(nn.Module) 的定义
3 查看权重参数 在PyTorch中，查看深度学习预训练backbone的权重参数可以通过几种方法实现。以下是一些常用的步骤和方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6019b432cebd0bcf01dd4d0078792976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3001a016e931fbe6f94e0b207fbd7820/" rel="bookmark">
			C&#43;&#43;五子棋（未做完，但能玩，而且还不错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码放下面了，关于步骤介绍的我以后再完善一下。
#include&lt;bits/stdc++.h&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;ctime&gt; #include&lt;windows.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #define random(x) (rand()%x) using namespace std; //--------------------------------五子棋------------------------------------// //player_1:o //player_2:x int Game_mode; char qizi[25][25]; HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); //主要模块 void print_checkerboard(){ SetConsoleTextAttribute(handle, FOREGROUND_GREEN | FOREGROUND_INTENSITY); cout&lt;&lt;" "; for(int i=1;i&lt;=20;i++){ cout&lt;&lt;i&lt;&lt;" "; if(i&lt;10) cout&lt;&lt;" "; } cout&lt;&lt;endl; for(int i=1;i&lt;=20;i++){ if(i&lt;10) cout&lt;&lt;" "; cout&lt;&lt;i&lt;&lt;" "; for(int j=1;j&lt;=20;j++){ if(qizi[i][j]=='o'){ SetConsoleTextAttribute(handle, FOREGROUND_BLUE | FOREGROUND_INTENSITY); cout&lt;&lt;qizi[i][j]&lt;&lt;" "; SetConsoleTextAttribute(handle, FOREGROUND_GREEN | FOREGROUND_INTENSITY); }else if(qizi[i][j]=='x'){ SetConsoleTextAttribute(handle, FOREGROUND_RED | FOREGROUND_INTENSITY); cout&lt;&lt;qizi[i][j]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3001a016e931fbe6f94e0b207fbd7820/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/118/">«</a>
	<span class="pagination__item pagination__item--current">119/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/120/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>