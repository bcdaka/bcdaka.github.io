<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42341c5ee58d824c05d6069610d1dc7/" rel="bookmark">
			学习笔记：基于Transformer的时间序列预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 一些准备的说明 为了便于读者理解，笔者将采取一个盾构机掘进参数预测的实际项目进行Transformer模型的说明。此外，该贴更多用于本人的学习记录，适合于对Transformer模型已经有一定了解的读者。此此次外，不定期更新中。
一些参考与图片来源：
Transformer论文链接
transformer的细节到底是怎么样的？
深入理解Transformer及其源码解读
Informer论文链接
1.1 采用的数据 具体的数据在csv中如下，这里只展示部分数据
在本项目中，并非所有参数都有用到，本文的示例中，仅仅用到了
"state": ["刀盘转速(r/min)", "刀盘压力(bar)", "总推进力(KN)", "螺机转速(r/min)"], "action": ["A组推进压力设定(bar)", "B组推进压力设定(bar)", "C组推进压力设定(bar)", "D组推进压力设定(bar)", "推进速度2(mm/min)"], "target": ["VMT导向垂直后(mm)", "VMT导向水平前(mm)", "VMT导向垂直前(mm)", "VMT导向水平后(mm)", "VMT导向水平趋向RP(mm)", "VMT导向垂直趋向RP(mm)"] 这些参数，利用pandas包进行提取。
1.2 时间序列数据的格式 接下来，我们理解一下时间序列数据的格式。
对于某一时刻的数据，应该是类似如下所示的一行1×15的tensor：
[[1.51, 86.656, 69.550, ......(共15个数据)]] 这个数据从左到右分别代表某一时刻中的刀盘转速(r/min)、刀盘压力(bar)、总推进力(KN)、......中15个掘进参数的数据。
若是多个连续时刻的数据，如3个时刻的数据，则应是如下所示3×15的tensor：
[[1.51, 86.656, 69.550, ......(共15个数据)], [1.52, 86.756, 69.650, ......(共15个数据)], [1.53, 86.856, 69.750, ......(共15个数据)]] 注意上面这两组数据是笔者胡乱输入的，数值大小没有什么实际意义，切勿对号入座。
1.3 Transformer的输入与输出 假设我们的batch_size = 32，笔者在接下来全文模型的解读中将以训练流程为例进行说明。目的是希望通过8个过去时刻的数据(8×15)预测2个未来时刻的数据(2×6)。
输入：分为encoder与decoder的输入，尺寸分别为32×8×15与32×2×15输出：只有一个，尺寸为32×2×6 其中32为batch_size，32×8×15可理解为32个batch，每个batch中带有8个过去时刻的数据，15是考虑的掘进参数的数目，如1.1图中的刀盘转速、刀盘压力、总推进力、螺机转速、……等15个参数。
在下面的整体结构示意图中，会在对应的位置标出输入与输出的数据尺寸大小，注意Encoder层的输入与输出的tensor大小是一致的，同理Decoder层的输入与输出。
2 整体结构 注：为了适应时间序列预测，相比于原Transformer模型，将最后一个Softmax层删除
3 输入编码 输入在输入前需进行归一化。
输入数据的流动如下图所示，重点关注维度的变化（15——&gt;512）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42341c5ee58d824c05d6069610d1dc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a86810e654bb6b9c819b78088864c99/" rel="bookmark">
			PVE 安装 windows10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pve 安装教程大家可以参考视频：pve 安装
pve 安装 Windows10 视频教程：pve 安装Windows10
在安装好 pve 后我们就可以进行虚拟机的安装了。当然我们可以自行决定是否有必要进行 win10 的安装。
准备工作 1. 下载 win10 镜像文件：https://msdn.itellyou.cn/
我们在 msdn 选择合适自己的操作系统
需要用迅雷进行下载
2. 下载 pve windows 驱动 Windows VirtIO Drivers: https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso
3. 上传 刚刚下载的两个文件到 pve 创建虚拟机 创建虚拟机
常规设置
3. 操作系统
在使用 CD/DVD 这儿点击 ISO镜像的下拉框，选择刚刚上传的 win10 的镜像
4. 系统 这一项保持不变
5. 磁盘
磁盘这儿我们只是需要设置磁盘大小进行系统安装，后续可以在添加磁盘进行扩容
6. CPU
核心数大家根据自己机器的实际情况进行填写
类别这儿需要将其设置为 host
7. 内存
内存大家根据实际情况进行设置，win10 最低内存是 4G
8. 网络
网络这儿我们需要将防火墙取消勾选
模型保持不变
9. 完成
大家根据上面的步骤就可以成功添加虚拟机了，先不要开机，我们还需要添加 Windows VirtIO Drivers 的驱动镜像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a86810e654bb6b9c819b78088864c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed6a34717d41ae950b8cc8c30fe1f6d/" rel="bookmark">
			15种AI工具帮助您无错误地编写代码，AI自动编写代码非常实用!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI 代码工具已成为 2023 年开发人员的热门选择，各种工具可以利用人工智能来帮助生成高质量的代码。
最著名的工具之一是OpenAI Codex，它可以将自然语言转换为代码并为GitHub Copilot提供支持。OpenAI Codex 可以解释简单的命令，并适用于几乎任何编程任务，使其成为多功能的开发人员工具。
另一个引起关注的工具是DeepMindhttps://www.deepmind.com/的AlphaCodehttps://alphacode.deepmind.com/，它已被证明在某些情况下优于人类编码人员。其他 AI 代码工具也可用，每种工具都有其优点和缺点。
尽管这些工具有好处，但重要的是要注意它们使用起来并不完全安全。研究人员发现，使用人工智能工具的工程师更有可能将安全漏洞引入他们的应用程序。
这可能会导致各种问题，从轻微的不便到严重的安全漏洞。
近年来，人工智能 （AI） 已成为查找和修复软件错误的有力工具。
人工智能驱动的工具可以比人类更快地扫描代码，并识别人类可能错过的模式。
随着人工智能技术的发展，我们希望看到更强大、更有效的人工智能工具来查找和修复软件错误。以下是目前可用的 15 种 AI 工具。
Google AI Test Kitchen：Google AI Test Kitchen是一个用于开发和测试AI驱动的应用程序的平台。它提供了各种工具和资源，帮助开发人员创建和测试可靠且无错误的 AI 应用程序。
AlphaCode是一个可以生成代码的大型语言模型。它可以生成高质量且无错误的代码。
微软的CodeX：微软的CodeX是一种可以生成代码的大型语言模型。它可以生成高质量且无错误的代码。
AI Research Lab：Facebook的AI研究实验室正在开发各种AI工具，可用于查找和修复软件中的错误。这些工具包括：
BugSeer：BugSeer是一种使用机器学习来查找代码中的错误的工具。
BugSpotter：BugSpotter是一种使用机器学习来查找文本中的错误的工具。
BugSniffer ：BugSniffer 是一种使用机器学习来查找图像错误的工具。
Plaid AI：Plaid AI是一家开发AI工具的公司，用于查找和修复软件中的错误。他们的工具包括：
Plaid Detect：Plaid Detect是一种使用机器学习来查找代码中的错误的工具。
Plaid Fix：Plaid Fix 是一种使用机器学习来修复代码中的错误的工具。 随着人工智能技术的发展，我们可以期待看到更强大和有效的工具可用。
这些只是可用于帮助开发人员查找和修复软件中的错误的众多 AI 工具中的一小部分。
Snyk：Snyk是一家开发AI工具的公司，用于查找和修复软件中的安全漏洞。他们的工具包括：
Snyk Code：Snyk Code 是一种使用机器学习来查找代码中的安全漏洞的工具。
Snyk Container：Snyk Container是一种机器学习工具，用于查找容器映像中的安全漏洞。
Snyk Infrastructure：Snyk Infrastructure是一种工具，它使用机器学习来查找基础设施即代码中的安全漏洞。
SonarSource：SonarSource是一家开发AI工具的公司，用于查找和修复软件中的错误和安全漏洞。他们的工具包括：
SonarLint ：SonarLint 是一种与 IDE 集成的工具，用于查找代码中的错误和安全漏洞。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ed6a34717d41ae950b8cc8c30fe1f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e80132ad9cd01b17e89be9f44c180fd/" rel="bookmark">
			Could not install Gradle distribution from ‘https://services.gradle.org/distributions/gradle-7.0.2-b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新安装的AndroidStudio如果Gradle没有成功安装，导入一个项目之后，在自动安装Gradle失败后会出现下面这种错误：
解决办法：打开下放所提示的下载链接，直接下载离线包，找到Gradle安装的目录，比如我的目录是下图
放进去之后如图：
然后重新打开AndroidStudio即可没问题了。下图是没问题的情况：
我的电脑版本：荣耀X14 win11
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05d56e38c9bb4796ea6899b763b74a6/" rel="bookmark">
			CAP理论与ZooKeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZK遵循的是CP原则，即一致性和分区容错性。
ZooKeeper也是一种分布式系统，它在一致性上有人认为它提供的是一种强一致性的服务（通过sync操作），也有人认为是单调一致性（更新时的大多说概念），还有人为是最终一致性（顺序一致性），它在分区容错性和可用性上做了一定折中，这和CAP理论是吻合的。
ZooKeeper从以下几点保证了数据的一致性：
顺序一致性
来自任意特定客户端的更新都会按其发送顺序被提交。也就是说，如果一个客户端将Znode z的值更新为a，在之后的操作中，它又将z的值更新为b，则没有客户端能够在看到z的值是b之后再看到值a（如果没有其他对z的更新）。
原子性
每个更新要么成功，要么失败。这意味着如果一个更新失败，则不会有客户端会看到这个更新的结果。
单一系统映像
一 个客户端无论连接到哪一台服务器，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比 在之前服务器上所看到的更老。当一台服务器出现故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有滞后于故障服务器的服务器都不会接受该 连接请求，除非这些服务器赶上故障服务器。
持久性
一个更新一旦成功，其结果就会持久存在并且不会被撤销。这表明更新不会受到服务器故障的影响。
实时性：在特定的一段时间内，客户端看到的系统需要被保证是实时的（在十几秒的时间里）。在此时间段内，任何系统的改变将被客户端看到，或者被客户端侦测到。
ZK遵循的是CP原则，即一致性和分区容错性，牺牲了可用性，具体牺牲在哪里呢？
1、不能保证每次服务请求的可用性。任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性；但是它不能保证每次服务请求的可用性（注：也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果）。
2、当Leader宕机以后，集群机器马上会进去到新的Leader选举中，但是选举时长在30s — 120s之间，这个选取Leader期间，是不提供服务的，不满足可用性。
经过上面的简单讲解，为什么选举时长，会长达半分钟到2分钟呢？
当然是为了保证一致性，为了保证集群中各个节点数据的一致性，ZK做了两类数据同步，初始化同步和更新同步。
1：当新的Leader选举出来后，各个Follower需要将新的Leader的数据同步到自己的缓存中，这就是初始化同步。
2：当Leader数据被客户端修改后，其会向Follower发出广播，然后各个Follwer会竹筒去同步更新的数据，这是更新同步。
无论是初始化同步还是更新同步，ZK集群为了保证数据的一致性，若发现超过半数的Follower同步超时，则其会再次进行同步，而这个过程中ZK集群同样出去不可用状态。
由于ZK采用的是CP原则，所以其可用性降低，这是其致命的问题，Spring Cloud集成的Eureka采用的就是AP原则，牺牲了一致性，但是保证了可用性。
ZooKeeper提供的一致性服务
很多文章和博客里提到，zookeeper是一种提供强一致性的服务，在分区容错性和可用性上做了一定折中，这和CAP理论是吻合的。但实际上zookeeper提供的只是单调一致性。
假设有2n+1个server，在同步流程中，leader向follower同步数据，当同步完成的follower数量大于 n+1时同步流程结束，系统可接受client的连接请求。如果client连接的并非同步完成的follower，那么得到的并非最新数据，但可以保证单调性。
follower接收写请求后，转发给leader处理；leader完成两阶段提交的机制。向所有server发起提案，当提案获得超过半数（n+1）的server认同后，将对整个集群进行同步，超过半数（n+1）的server同步完成后，该写请求完成。如果client连接的并非同步完成follower，那么得到的并非最新数据，但可以保证单调性。
用分布式系统的CAP原则来分析Zookeeper
C: Zookeeper保证了最终一致性,在十几秒可以Sync到各个节点.
A: Zookeeper保证了可用性,数据总是可用的,没有锁.并且有一大半的节点所拥有的数据是最新的,实时的. 如果想保证取得是数据一定是最新的,需要手工调用Sync()
P: 有2点需要分析的.
节点多了会导致写数据延时非常大,因为需要多个节点同步.
节点多了Leader选举非常耗时, 就会放大网络的问题. 可以通过引入 observer节点缓解这个问题.
zookeeper的CP特性
zookeeper在选举leader时，会停止服务，直到选举成功之后才会再次对外提供服务，这个时候就说明了服务不可用，但是在选举成功之后，因为一主多从的结构，zookeeper在这时还是一个高可用注册中心，只是在优先保证一致性的前提下，zookeeper才会顾及到可用性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f3a0eeded5099fdb1a824b97eb1fb29/" rel="bookmark">
			〖大前端 - 基础入门三大核心之JS篇⑱〗- JavaScript的流程控制语句「break 和 continue语句」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前子专栏 基础入门三大核心篇 是免费开放阶段。推荐他人订阅，可获取扣除平台费用后的35%收益，文末名片加V！说明：该文属于 大前端全栈架构白宝书专栏，目前阶段免费开放，购买任意白宝书体系化专栏可加入TFS-CLUB 私域社区。福利：除了通过订阅"白宝书系列专栏"加入社区获取所有付费专栏的内容之外，还可以通过加入星荐官共赢计划 加入私域社区。 作者：不渴望力量的哈士奇(哈哥)，十余年工作经验, 跨域学习者，从事过全栈研发、产品经理等工作，目前任某金融品类App负责人。荣誉：2022年度博客之星Top4、博客专家认证、全栈领域优质创作者、新星计划导师，“星荐官共赢计划” 发起人。现象级专栏《白宝书系列》作者，文章知识点浅显易懂且不失深度；TFS-CLUB社区创立者，旨在以“赋能 共赢”推动共建技术人成长共同体。 🏆 白宝书系列 🏅 Python全栈白宝书🏅 产品思维训练白宝书🏅 全域运营实战白宝书🏅 大前端全栈架构白宝书 文章目录 🌟 break语句🌟 continue语句 该章节内容不多，就是JavaScrip的两个知识点，break语句 和 continue语句。
🌟 break语句 break即”打断“，表示立即终止循环
在for循环和while循环中都可以使用
break语句的用法：
下面直接举例说明break语句在循环中的用法
在for循环中：
for (var i = 0; i &lt;= 10; i++) { console.log(3); if (i == 5) { break; //当i等于5时，终止循环 } } 运行结果如下：
注意，遇到break后会立即”跳出“循环，不会执行break后面的语句。
比如上面的例子中，把控制台输出语句放在break的后面，输出的结果就不一样了：
在while循环中：
在while循环语句中，break语句通常和while(true) {}搭配使用
关于while(true) {}:
while(true) {}因为判断条件一直是true，所以这是一个死循环，必须加上break来终止循环
下面我们用break语句和while(true) {}结合来实现上篇中的一个例子：寻找最小的满足n2&gt;456789的整数n
var n = 1; while (true) { if (Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f3a0eeded5099fdb1a824b97eb1fb29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbd851edd4f336f977af0f019a699f0/" rel="bookmark">
			IntelliJ IDEA 社区版2021.3配置SpringBoot项目详细教程及错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SpringBoot的定义
二、Spring Boot 优点
三、创建一个springboot的项目
四、使用IDEA创建SpringBoot失败案例
一、SpringBoot的定义 Spring 的诞⽣是为了简化 Java 程序的开发的，⽽ Spring Boot 的诞⽣是为了简化 Spring 程序开发的。 Spring Boot 翻译⼀下就是 Spring 脚⼿架，就是为了快速开发 Spring 框架⽽诞⽣的 Spring Boot 项⽬的⼀大特点：约定⼤于配置。较于Spring需要配置Bean的扫描路径，而SpringBoot就不需要 二、Spring Boot 优点 快速集成框架，Spring Boot 提供了启动添加依赖的功能，⽤于秒级集成各种框架。内置运⾏容器，⽆需配置 Tomcat 等 Web 容器，直接运⾏和部署程序。快速部署项⽬，⽆需外部容器即可启动并运⾏项⽬。可以完全抛弃繁琐的 XML，使⽤注解和配置的⽅式进⾏开发。⽀持更多的监控的指标，可以更好的了解项⽬的运⾏情况。 SpringBoot的核心： 1、快速添加依赖 2、内置web容器 3、自动装配（即SpringBoot自动构建复杂对象，构建好的对象可以直接使用） 三、创建一个springboot的项目 因为我们⽤的 Idea 社区版2021.3，选择安装SpringBoot插件才能创建 Spring Boot 项目。 SpringBoot插件名字为 接下来开始正式创建SpringBoot项目：
1、先选择file-&gt;new-&gt;project
2、选择Spring Initializr，选择国外的默认配置源
3、添加项目的依赖 一般是Web项目，所以我们勾选最基本的 Web选项，选择SpringBoot Devtools用于实现热部署，其他可以等用到的时候再添加。 Spring Boot Devtools：实现热部署
Lombok：Java注解
Spring Web: 外部服务
SpringBoot版本选择后缀不带英文字母的稳定版本，其中低版本的比较稳定 点击下一步，命名自己项目的名字和保存地址，点击finash，等待项目的创建 开始进行启动类初始化：右击 项目名，选择“ Add Framework Support” 如果出现以下蓝色且右上角带有三角形则启动类初始化成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbd851edd4f336f977af0f019a699f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095c635cc818739eb31d3a8ad406be0b/" rel="bookmark">
			PTA Python作业7文件及异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
判断题
单选题
函数题
6-1 jmu-python-判断质数
编程题
7-1 下标异常
7-2 try-except-else异常
7-3 综合题：学生成绩输入及输出
判断题 1-1Python内置的open函数，打开文件的时候可能会产生异常。（T)
1-2二进制文件不能使用记事本程序打开。(F)
1-3Python对文件的操作中，close函数用于文件关闭。(T)
1-4文件打开的默认方式是只读。(T)
1-5以'w'模式打开一个可写的文件，如果文件存在会被覆盖。(T)
1-6read方法只能一次性读取文件中的所有数据。(F)
1-7在try...except...else结构中，如果try块的语句引发了异常则会执行else块中的代码。(F)
1-8在Python异常处理中，只能有一个try，但可以有多个except。(T)
1-9在Python中，如果try语句块发生了一个异常，与该异常匹配的所有except子句均会执行。(F)
1-10在Python异常处理中，在try块发生异常后，会执行第一个该异常匹配的except子句，其他except子句则不再执行。(T)
单选题 2-1打开一个已有文件，然后在文件末尾添加信息，正确的打开方式为（ ）。
A.'r'
B.'w'
C.'a'
D.'w+'
2-2下列方法中，用于获取当前目录的是（ ）。
A.open
B.write
C.getcwd
D.read
2-3若fp1 = open("test.txt","r")
以下哪个读取文件的方式line返回的不是字符串？（）
A.for line in fp1
B.line = fp1.read()
C.line = fp1.readline(
D.line = fp1.readlines()
2-4关于 python 读取文件，下列描述错误的是：
A.关键字 with 会在程序不再需要访问文件或出现异常的情况下，关闭文件 。
B.Python 对数据量没有大小限制，需要读取的文件多大都可以。
C.函数 open()中如果输入参数只有文件名，那么 Python 会在当前执行的 .py 文件的所在目录中查找文件 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/095c635cc818739eb31d3a8ad406be0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203eba1d740c64e94f68f83f5c3fbee5/" rel="bookmark">
			BMS——电池均衡算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 电池均衡功能需求 1.1 基本概念 ​ 在电池簇电芯间容量存在一致性差异时，会导致电池系统整体可用电量下降及SOC估算不准以致出现充放电末端出现跳变。电池均衡的意义就是利用电力电子技术，使锂离子电池单体电压或电池组电压偏差保持在预期的范围内，从而保证每个单体电池在正常的使用时保持相同状态，以避免过充、过放等异常的发生。
1.2 不一致性的来源 ​ 电池由于自身内部差异或外部使用状态不同而形成的电池容量、SOC、内阻和电压等参数不同的现象，称为电池组不一致性。
​ 锂离子电池间的不一致性主要来源于几个方面：
​ 1、生产制造时工艺上的差别和材质的不均，造成电池两极材料的活化程度和厚度、隔板等存在细微的差别，使得内部结构和材质不完全一致；
​ 2、使用过程中，电池组中各个电池电解液密度、温度、自放电程度等的差别也会造成不一致。
​ 3、随着时间的累积，电池不一致性越来越大。
1.3 不一致性的影响 ​ 不一致性主要影响以下几个方面：
​ 1、降低整体容量性能
​ 2、缩短电池使用寿命
​ 3、限制整体充放电功率
​ 4、影响电池安全性能
​ 有实验表明，在使用不一致性较大的电池组时电压波动明显，功率性能有所下降，同时电池组之间的差异进一步加剧，电池利用率和电池寿命会随着差异性的增大而减少。因此，在发现电池有差异时，应当进行处理，以减小不一致性对电池造成的影响，避免形成恶性循环。电池不一致性无法完全消除，但可以通过电池均衡技术使其尽量减小。
2. 电池均衡方法介绍 ​ 电池均衡（Cell Balancing）分为两种：被动均衡（Passive Balancing）与主动均衡（Active Balancing）。
2.1 被动均衡 ​ 被动均衡，运用电阻器件，将高电压或者高荷电量电芯的能量消耗掉，以达到减小不同电芯之间差距的目的，是一种能量的消耗。
​ 被动均衡的优点是电路结构简单，成本较低；缺点是能量利用率低，同时会增加模组的散热。
2.1.1 被动均衡原理 ​ 如果检测到电池不均衡的情况下，被动均衡有选择性地闭合高能量的单体电池放电回路，闭合开关，通过回路中的电阻对电池组中能量较高的电芯进行放电，把偏高的能量消耗掉，以此减小电芯之间的差距最终达到均衡状态。由于这种均衡方式是被动的能量消耗，所以被称为被动均衡。
2.1.2 被动均衡应用 ​ BMS均衡功能的实现主要靠AFE，它里面集成了均衡控制开关以及相关逻辑电路，给用户提供了丰富的诊断和控制接口，如下图（图片来源于中颖的SH367309），方框部分即为均衡电路。
2.2 主动均衡 ​ 主动均衡，运用储能器件等，将荷载较多能量的电芯部分能量转移到能量较少的电芯上去，是能量的转移。
​ 主动均衡的优点是均衡速度快、能量利用率高；缺点是电路较为复杂，成本较高。
2.2.1 主动均衡原理 ​ 主动均衡是将电池组中高能量电池的能量转移到低能量电池上实现能量转移式均衡，以此减小电芯之间的差距最终达到均衡状态。由于是主动式的能量转移，所以称为主动均衡。
2.2.2 主动均衡应用 ​ ETA3000是电池平衡IC，可面向上下两串电池组，其可以通过无限级联，实现3节-24节动力电池组的均衡，ETA3000是主动开关式均衡，其均衡电流可以达到1.5A。ETA3000是钰泰半导体独有专利池内的新型电池均衡器，与传统的无源平衡技术不同，ETA3000利用具有电感器的控制方案来在两个电池之间source和sink电流，直到相邻两节电池电势均等。在传统的线性平衡技术中，会产生较大功耗，而使用ETA3000采用全新的开关式主动均衡技术，其大幅度降低均衡过程中热量的产生，且均衡时间也大大减少。ETA3000在待机M中只消耗电池2uA的工作电流。ETA3000有效地提高了串联电池的性能和寿命。
3. 电池均衡软件算法介绍 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203eba1d740c64e94f68f83f5c3fbee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315a93737307710d61e59c779afcccfa/" rel="bookmark">
			人工智能之配置环境教程二：在Anaconda中创建虚拟环境安装GPU版本的Pytorch及torchvision并在VsCode中使用虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能之配置环境教程二：在Anaconda中创建虚拟环境安装GPU版本的Pytorch及torchvision并在VsCode中使用虚拟环境 作者介绍一. 查看自己电脑的CUDA版本1.1 方式一1.2 方式二 二. 下载安装CUDA三. 查看环境变量四. 创建虚拟环境4.1 使用指令创建虚拟环境4.2 查看Anconda中是否出现创建好的虚拟环境4.3 虚拟环境相关指令 五. 安装GPU版本的Pytorch和torchvision5.1 在线安装5.2 离线安装5.2.1 下载安装torch5.2.2 下载安装torchvision 5.3 验证是否成功安装 六. 在VsCode 中使用虚拟环境6.1 安装Python插件6.2 添加虚拟环境 七. 安装CPU版本的Pytorch和torchvision 作者介绍 孟莉苹，女，西安工程大学电子信息学院，2021级硕士研究生，张宏伟人工智能课题组。
研究方向：机器视觉与人工智能。
电子邮件：2425613875@qq.com
本教程提供需要安装的CUDA11.3、Pytorch1.10.0、torchvision0.11.0的安装包，在下述百度网盘链接中自取！
链接：https://pan.baidu.com/s/18mgO8GtW1UnG6uijnnQvIQ?pwd=0843 提取码：0843
–来自百度网盘超级会员V5的分享
一. 查看自己电脑的CUDA版本 根据以下两种方式，查看自己的电脑是否支持CUDA，如果不支持，那么直接跳到[ 七 ]！
1.1 方式一 1.1 .1 使用快捷键‘win + R’- - -&gt; 输入 cmd - - -&gt; 点击确定
1.1.2 在终端输入指令‘nvidia-smi’ - - -&gt; 查看自己电脑支持的CUDA版本
当前CUDA版本为11.6，表示支持最高版本的CUDA是11.6，向下兼容
1.2 方式二 1.2.1 在桌面右击 - - -&gt; 打开NVIDIA 控制面板
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315a93737307710d61e59c779afcccfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf20b73a6fc1995e8755aa8afa7fbc0/" rel="bookmark">
			对数据结构的初步认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言: 牛牛开始更新数据结构的知识了.本专栏后续会分享用c语言实现顺序表,链表,二叉树,栈和队列,排序算法等相关知识,欢迎友友们互相学习,可以私信互相讨论哦!
🎈个人主页:🎈 :✨✨✨初阶牛✨✨✨
🐻推荐专栏: 🍔🍟🌯 c语言初阶
🔑个人信条: 🌵知行合一
🍉本篇简介:&gt;:讲解数据结构的入门知识,时间复杂度与空间复杂度,以及一些对学习数据结构的建议.
金句分享:
✨最快的脚步不是冲刺,而是坚持!✨
目录 前言:1、数据结构是什么?2、数据结构应该怎么学呢? 算法效率如何衡量?一、 时间复杂度大O的渐进表示法时间复杂度的练习:1.1 常见的时间复杂度:1.2 冒泡排序的时间复杂度1.3 "二分查找"的时间复杂度1.4 递归的时间复杂度:常见量级的比较图 二、空间复杂度 1、数据结构是什么? 数据结构+算法=程序.
数据结构(Data Structure):是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。
例如后面会提到的顺序表,链表这些线性数据结构,还有后面的二叉树树形数据结构等.
算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果.
例如:排序算法.
数据结构与算法对于一个程序员是很重要的,不论对你思考问题的方式还是对你编程的思维都会有很大的好处。同时在找工作时算法也是一个重要考点之一.
2、数据结构应该怎么学呢? 1.多多练习代码.
数据结构的学习并不简单,需要多锻炼代码能力,最怕偷懒,很多时候头脑虽然理解了,但是动起手来写代码会忽略很多细节,导致程序出错,不能光有思路,而代码能力却实现不了就很尴尬了.
2.多画图(这个强烈推荐)
除了代码能力需要锻炼以外,很重要的一点是要有思路,通过画图辅助,可以很好地帮助我们找到思路和理解数据结构中的很多思想,切忌上来就开始码代码,这样对于简单的问题可能可以解决,但是对于稍微复杂的问题可能会让你头痛(大佬除外😂😂),很容易被绕进去,陷入痛苦的调试找bug环节.
画图会让提供给我们清晰的思路,同时,即使出现了bug,也可以很快的找到,清晰可见.写代码只是用于实现思路,思路清晰,代码写起来并不困难.
3.刷题
刷题会锻炼我们的思考能力,解题是一种很灵活的事情.一方面可以巩固我们学的基础知识,另一方面可以拓展思维.
最后,坚持学习才是最重要的.
算法效率如何衡量? 对于一个问题,可以有很多解法,那怎样衡量一个算法的好坏呢?
比谁的代码更简洁吗?
算法的效率主要考虑两点:1.时间复杂度. 2.空间复杂度
一个算法在编译生成可执行文件后,运行时会耗费时间资源和空间(内存)资源 。
从时间和空间两个维度来衡量一个算法的好坏是比较合理的，这就是时间复杂度和空间复杂度。
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。
一、 时间复杂度 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间.
但是从理论上说，这个只有将代码进行测试,并统计时间才能知道.并不能通过计算得到.
但对于每一个算法,我们都去跑一下,这未免显得有些麻烦,我们可以通过算法中的代码估计运行大概的时间,看看属于哪一个量级来衡量它的效率.
算法中的基本操作的执行次数，为算法的时间复杂度。
即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度
理论不是很理解的话,我们来点实际的,找几段代码算算吧!
🌰小试牛刀
你能算出在test1中++count语句最终被执行了多少次吗?
void test1(int N) { int count = 0; //1 for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { ++count; } } //2 for (int k = 1; k &lt; N; k*=2) { ++count; } //3 for (int k = 0; k &lt; 2 * N; k++) { ++count; } //4 int a = 100; while (a--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecf20b73a6fc1995e8755aa8afa7fbc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf03cea3b663cc37cdf48542570f668/" rel="bookmark">
			【PCL】—— 点云配准ICP(Iterative Closest Point)算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数学原理问题定义计算平移计算旋转 案例实现参考 ​ 由于三维扫描仪设备受到测量方式和被测物体形状的条件限制，一次扫描往往只能获取到局部的点云信息，进而需要进行多次扫描，然后每次扫描时得到的点云都有独立的坐标系，不可以直接进行拼接。在逆向工程、计算机视觉、文物数字化等领域中，由于点云的不完整、旋转错位、平移错位等，使得要得到完整点云就需要对多个局部点云进行配准。为了得到被测物体的完整数据模型,需要确定一个合适的坐标变换 ，将从各个视角得到的点集合并到一个统一的坐标系下形成一个完整的数据点云，然后就可以方便地进行可视化等操作，这就是点云数据的配准。
​ 点云配准步骤上可以分为粗配准（Coarse Registration）和精配准（Fine Registration）两个阶段。
​ 粗配准是指在点云相对位姿完全未知的情况下对点云进行配准，找到一个可以让两块点云相对近似的旋转平移变换矩阵，进而将待配准点云数据转换到统一的坐标系内，可以为精配准提供良好的初始值。
​ 精配准是指在粗配准的基础上，让点云之间的空间位置差异最小化，得到一个更加精准的旋转平移变换矩阵。该算法的运行速度以及向全局最优化的收敛性却在很大程度上依赖于给定的初始变换估计以及在迭代过程中对应关系的确立。所以需要各种粗配准技术为ICP算法提供较好的位置，在迭代过程中确立正确对应点集能避免迭代陷入局部极值，决定了算法的收敛速度和最终的配准精度。
​ 比较常见的一种配准算法是迭代最近点算法(Iterative Closest Point, ICP)。ICP算法可以基于四元数求解，也可以基于奇异值分解（SVD）求解，本文主要介绍基于奇异值分解的ICP算法。
ICP算法原理：给定一个参考点集 P P P和一个数据点集 Q Q Q（在给定的初始估计 R R R， t t t），算法为 Q Q Q中的每个点寻找 P P P中对应的最近点，形成匹配点对。然后，将所有匹配点对的欧氏距离之和作为待求解的目标函数，利用奇异值分解求出 R R R和 t t t以使目标函数最小，根据 R R R, t t t转换得到新的 Q ′ Q' Q′，并再次找到对应的点对，如此迭代。
缺点：需要剔除噪声点（距离过大的点对或包含边界点的点对）。基于点对的配准不包括局部形状信息。在每次迭代中搜索最近点非常耗时。计算可能陷入局部最优。
​ 一般来说，ICP可以分为以下四个阶段
对原始点云数据进行采样确定初始对应点集去除错误对应点集坐标变换的求解 数学原理 问题定义 本部分结合了网上的一些资料以及自己的一些理解，可能不一定正确，部分步骤有所省略，具体可参考文末参考文献。
定义两个点云集合 P = { p 1 , p 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf03cea3b663cc37cdf48542570f668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6e8033dc8aaae301a1672ef7378044/" rel="bookmark">
			分割一切？手把手教你部署SAM&#43;LabelStudio实现自动标注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，前言 最近Open-mmlab开源了Playground项目，将最近引起CV界轰动的SAM(Segment Anything Model)模型和Open-mmlab多个视觉框架相结合，可实现多种视觉任务的自动标注，本文将采用Open-mmlab的Playground开源项目，使用SAM和LabelStudio，实现分割任务的半自动标注。
1，Playground官方GitHub地址：
https://github.com/open-mmlab/playground
2，SAM官方GitHub地址：https://github.com/facebookresearch/segment-anything
二，SAM+LabelStudio实现自动标注 经过实测，该项目在Windows10和Linux系统，使用CPU和GPU都可实现部署。
2.1，采用Anaconda创建虚拟环境(python3.9) 创建python3.9版本的基础虚拟环境，虚拟环境名称为rtmdet-sam
conda create -n rtmdet-sam python=3.9 -y 2.2，激活Anaconda虚拟环境 conda activate rtmdet-sam 2.3，下载playground的github库 git clone https://github.com/open-mmlab/playground 注：若因为网络问题git失败，可下载项目解压到本地
2.4，环境配置 2.4.1，安装Pytorch 1，Linux and Windows CUDA 11.3（GPU版本）
pip install torch==1.10.1+cu113 torchvision==0.11.2+cu113 torchaudio==0.10.1 -f https://download.pytorch.org/whl/cu113/torch_stable.html 2，Linux and Windows CPU only（CPU版本）
pip install torch==1.10.1+cpu torchvision==0.11.2+cpu torchaudio==0.10.1 -f https://download.pytorch.org/whl/cpu/torch_stable.html 3，OSX
pip install torch==1.10.1 torchvision==0.11.2 torchaudio==0.10.1 2.4.2，安装工具包 安装opencv-python，pycocotools，matplotlib，onnxruntime，onnx，这里需要注意以下Windows系统安装pycocotools时记得先安装git和visual studio。
pip install opencv-python pycocotools matplotlib onnxruntime onnx 2.4.3，安装SAM pip install git+https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6e8033dc8aaae301a1672ef7378044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68030b3da1292219d7fce32001d07e00/" rel="bookmark">
			Anaconda &#43; Pytorch 超详细安装教程(2023/4/29)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anconda+PyTorch 最新安装教程（2023-04-29） 安装流程1.安装Anaconda装完之后 2.创建pytorch环境3.检查显卡（NVIDIA显卡）（AMD显卡可跳过）4.配置阿里云镜像源进入base环境，键入命令 5.安装pytorch6.测试我遇到的错误1.下载问题解决办法 2.版本问题解决办法安装方法 7.CUDA核心NVIDIA显卡成功图其他显卡安装成功图 安装流程 1.安装Anaconda
2.创建机器学习环境
3.检查显卡，更新驱动
4.配置阿里云镜像源
5.安装pytorch
6.测试
7.CUDA核心
1.安装Anaconda https://www.anaconda.com/download/
直接默认下一步即可
装完之后 按win在“所有应用”中找到Anaconda Prompt
出现（base）表示成功
2.创建pytorch环境 这里面输入python可以看到安装的python版本号，我的是python3.10然后输入exit()回车就好。
创建pytorch虚拟环境，pytorch是环境变量的名字，python=3.10即是之前自己系统python版本。(注意这里的python版本要和自己的版本相同，我的是python3.10)
conda create -n pytorch python=3.10
到这里按y即可
出现这个界面就表示成功了
我们输入activate pytorch（pytorch是你定义的这个环境的名字），左边的环境就从base（基本环境），变成了pytorch环境。
3.检查显卡（NVIDIA显卡）（AMD显卡可跳过） 选择自己的显卡型号（如果有英伟达显卡的话，AMD的显卡不可以实用cuda核心训练，如果是AMD显卡直接用CPU训练就行）
4.配置阿里云镜像源 默认是Anconda国外镜像源，换国内的镜像源下载速度快。
进入base环境，键入命令 conda config --set show_channel_urls yes
在用户文件中找到这里 并用记事本打开
用记事本打开并输入阿里云镜像源
channels: - defaults show_channel_urls: true default_channels: - http://mirrors.aliyun.com/anaconda/pkgs/main - http://mirrors.aliyun.com/anaconda/pkgs/r - http://mirrors.aliyun.com/anaconda/pkgs/msys2 custom_channels: conda-forge: http://mirrors.aliyun.com/anaconda/cloud msys2: http://mirrors.aliyun.com/anaconda/cloud bioconda: http://mirrors.aliyun.com/anaconda/cloud menpo: http://mirrors.aliyun.com/anaconda/cloud pytorch: http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68030b3da1292219d7fce32001d07e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3838a7b9ad32fb250f0f3e253e23b6/" rel="bookmark">
			10个最流行的向量数据库【AI】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矢量数据库是一种将数据存储为高维向量的数据库，高维向量是特征或属性的数学表示。 每个向量都有一定数量的维度，范围从几十到几千不等，具体取决于数据的复杂性和粒度。
推荐：用 NSDT场景设计器 快速搭建3D场景。
矢量数据库（Vector Database）和矢量开发库（Vector Library）都是实现矢量相似性搜索的技术，但它们在功能和可用性上有所不同。 矢量数据库可以存储和更新数据，处理各种类型的数据源，在数据导入期间执行查询，并提供用户友好和企业就绪的功能。 矢量库只能存储数据，只能处理矢量，需要在建立索引之前导入所有数据，并且需要更多的技术专业知识和手动配置。
一些矢量数据库建立在现有库之上，例如 Faiss。 这使他们能够利用库的现有代码和功能，从而节省开发时间和精力。
这些矢量数据库和库用于人工智能 (AI) 应用程序，例如机器学习、自然语言处理和图像识别。 它们有一些共同的特点：
支持向量相似性搜索，它会找到与查询向量最近的 k 个向量，这是通过相似性度量来衡量的。 矢量相似性搜索对于图像搜索、自然语言处理、推荐系统和异常检测等应用非常有用。使用矢量压缩技术来减少存储空间并提高查询性能。 矢量压缩方法包括标量量化、乘积量化和各向异性矢量量化。可以执行精确或近似的最近邻搜索，具体取决于准确性和速度之间的权衡。 精确最近邻搜索提供了完美的召回率，但对于大型数据集可能会很慢。 近似最近邻搜索使用专门的数据结构和算法来加快搜索速度，但可能会牺牲一些召回率。支持不同类型的相似性度量，例如 L2 距离、内积和余弦距离。 不同的相似性度量可能适合不同的用例和数据类型。可以处理各种类型的数据源，例如文本、图像、音频、视频等。 可以使用机器学习模型将数据源转化为向量嵌入，例如词嵌入、句子嵌入、图像嵌入等。 1、Elasticsearch ElasticSearch是一个支持各种类型数据的分布式搜索和分析引擎。 Elasticsearch 支持的数据类型之一是矢量字段，它存储密集的数值矢量。
在 7.10 版本中，Elasticsearch 添加了对将向量索引到专用数据结构的支持，以支持通过 kNN 搜索 API 进行快速 kNN 检索。 在 8.0 版本中，Elasticsearch 添加了对带有向量场的原生自然语言处理 (NLP) 的支持。
2、Faiss Meta的Faiss是一个用于高效相似性搜索和密集向量聚类的库。 它包含搜索任意大小的向量集的算法，直到可能不适合 RAM 的向量集。 它还包含用于评估和参数调整的支持代码。
3、Milvus Milvus是一个开源矢量数据库，可以管理万亿矢量数据集，支持多种矢量搜索索引和内置过滤。
4、Weaviate Weaviate是一个开源向量数据库，允许你存储数据对象和来自你最喜欢的 ML 模型的向量嵌入，并无缝扩展到数十亿个数据对象。
5、Pinecone Pinecone专为机器学习应用程序设计的矢量数据库。 它速度快、可扩展，并支持多种机器学习算法。
Pinecone 建立在 Faiss 之上，Faiss 是一个用于密集向量高效相似性搜索的库。
6、Qdrant Qdrant是一个矢量相似度搜索引擎和矢量数据库。 它提供了一个生产就绪的服务，带有一个方便的 API 来存储、搜索和管理点——带有额外有效负载的矢量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f3838a7b9ad32fb250f0f3e253e23b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b685802c4893561cff0ddcae7e5ed27e/" rel="bookmark">
			头歌大数据——HBase 伪分布式环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第1关：HBASE伪分布式环境搭建 编程要求
好了，到你啦，你需要先按照上次实训——HBase单节点安装的方式将HBase安装在/app目录下，然后根据本关知识配置好伪分布式的HBase，最后点击测评即可通关。
测试说明
程序会检测你的HBase服务和Hadoop服务是否启动，以及伪分布式HBase是否配置正确。
预期输出：
Hadoop 已启动
hbase-env.sh解压路径正确
Hbase已启动
各配置项配置成功！
Hbase的HDFS目录创建成功
伪分布式搭建成功！
答案 mkdir /app cd /opt tar -zxvf hbase-2.1.1-bin.tar.gz -C /app echo $JAVA_HOME vim /app/hbase-2.1.1/conf/hbase-env.sh #在文件内添加： export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111 vim /app/hbase-2.1.1/conf/hbase-site.xml #在文件内添加： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/root/data/hbase/zookeeper&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; vim /etc/profile #在文件内添加： # SET HBASE_enviroment HBASE_HOME=/app/hbase-2.1.1 export PATH=$PATH:$HBASE_HOME/bin #更新配置 source /etc/profile start-dfs.sh start-hbase.sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c86d2294c449b3fa5fb4123b09b99a/" rel="bookmark">
			【超详细版】学习SQL注入看这篇就够了（原理及思路绕过）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL注入原理 1.SQL注入概念及产生原因： 当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。
2.SQL注入的本质： 把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则
3.SQL注入的两个关键点： 1，用户能控制输入的内容； 2，web应用把用户输入的内容带入到数据库执行；
SQL注入基础危害：
）盗取网站的敏感信息;
）绕过网站后台认证 后台登录语句： SELECT * FROM admin WHERE Username=‘user’ and Password=‘pass’ 万能密码：‘or ’1‘ = ’1‘ # ;
）借助SQL注入漏洞提权获取系统权限;
）读取文件信息。
MYSQL数据库注入-常用函数：
（1）user() 返回当前使用数据库的用户，也就是网站配置文件中连接数据库的账号 （2）version() 返回当前数据库的版本 （3）database() 返回当前使用的数据库，只有在use命令选择一个数据库之后，才能查到 （4）group_concat() 把数据库中的某列数据或某几列数据合并为一个字符串 （5）@@datadir 数据库路径 （6）@@version_compile_os 操作系统版本
SQL（联合）注入流程：
?id=1 and 1=1
1、判断有无闭合 and 1=1 and 1=2 //结果和第一个一样说明需要闭合，反之无闭合 有闭合则需要用到 --+闭合
2、猜解字段 order by 10 //采用二分法 3、判断数据回显位置 -1 union select 1，2，3，4，5.... //参数等号后面加-表示不显示当前数据 4、获取当前数据库名、用户、版本 union select version(),database()，user()，4...... 4、获取全部数据库名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c86d2294c449b3fa5fb4123b09b99a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85bf19b9021a8864ce8cc1fb19287827/" rel="bookmark">
			Java七种常用设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、单例模式（Singleton Pattern） 单例模式是（Singleton Pattern）Java中最常用的设计模式之一，它保证一个类仅有一个实例，并提供一个全局访问点。
实现单例模式的核心是将类的构造方法私有化，以防止外部直接通过构造函数创建实例。同时，类内部需要提供一个静态方法或变量来获取该类的唯一实例。
以下是一个简单的单例模式实现：
public class Singleton { private static Singleton instance = null; // 私有构造方法 private Singleton() { } // 静态方法，获取唯一实例 public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 2、工厂模式（Factory Pattern） 工厂模式（Factory Pattern）是Java中常用的一种创建型设计模式，它提供了一种将对象创建的过程封装起来的方法，可以根据不同的参数来创建不同类型的对象。
工厂模式有三种常用的实现方式：简单工厂模式、工厂方法模式和抽象工厂模式。以简单工厂模式为例，实现过程如下：
定义抽象产品类： public abstract class Product { public abstract void use(); } 定义具体产品类： public class ProductA extends Product { @Override public void use() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85bf19b9021a8864ce8cc1fb19287827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6033b50e6e1d5be26da8fc423622f472/" rel="bookmark">
			13种权重的计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		权重计算方法有很多种，不同的方法有不同的特点和适用情况。AHP层次分析法和熵值法在权重计算中属于比较常用的方法。除此之外，还有一些与权重计算相关的方法，今天一文总结了13种与权重计算相关的方法，大家可以对比选择使用。
一、13种权重计算方法 一句话简单描述13种权重计算方法，见下表：
提示：以上13种方法中，模糊综合评价、灰色关联法、TOPSIS法、熵权TOPSIS这4种方法属于综合评价方法，并非主流权重计算方法，本文将一并进行介绍。
接下来，对13种方法进行逐个说明。
二、13种权重计算方法说明
‍（1）AHP层次分析法 AHP层次分析法是一种主观赋权法和客观赋权法相结合的方法，被广泛应用于指标权重的确定。该方法先用专家经验判断指标相对重要程度，再计算权重，比较适合解决难以用定量方法应对的问题。
AHP层次分析法的数据格式比较特殊，需要手工录入判断矩阵，如下表：
上表格显示：门票相对于景色来讲，重要性更高，所以为3分；相反，景色相对于门票来讲，则为0.33333分。交通相对于景色来更重要为2分，其余类似下去。
SPSSAU输出权重计算结果如下：
（2）熵值法 熵值法是客观赋权法当中的一种，熵值是对不确定性的一种度量。熵值法用以确定指标权重的根据是各项指标在数值层面的变异程度，由于对客观数据有着高度依赖，熵值法的运用过程中避免了人为因素对指标权重结果可能造成的偏差。
在进行熵值法之前，如果数据方向不一致时，需要进行提前数据处理，通常为正向化、逆向化两种处理。
SPSSAU输出权重计算结果如下：
（3）因子分析法 因子分析通过信息浓缩大小进行权重计算，使用旋转后方差解释率进行计算。比如提取3个因子，旋转后的方差解释率分别是45.802%，65.517%，75.246%，旋转后累积方差解释率为75.246%。那么归一化（即除累积方差解释率）即得到权重。
权重计算如下表：
（4）主成分分析法 主成分分析法与因子分析法计算权重的原理类似，都根据信息浓缩大小进行权重计算。权重计算是主成分的一类应用场景，其原理在于使用方差解释率进行权重计算。如下图：得到的4个主成分的方差解释率和累积方差解释率：
权重计算如下表：
‍（5）模糊综合评价 模糊综合评价借助模糊数学的一些概念，应用模糊关系合成原理，将一些边界不清、不易定量的因素定量化，进而进行综合性评价的一种方法。
模糊综合评价的数据格式比较特殊，需要注意：1列放1个评价项（比如不满意、比较不满意、满意、非常满意之类的评价项）。如果说各个指标项有着自己的权重，那么就需要单独用一列表示 “ 指标项权重值 ”，如果没有此数据，默认各个指标的权重完全一致。如下图：
SPSSAU输出权重计算结果如下：
‍（6）灰色关联法 灰色关联分析法通过研究数据关联性大小（母序列与特征序列之间的关联程度），通过关联度（即关联性大小）进行度量数据之间的关联程度，从而辅助决策的一种研究方法。
灰色关联法数据格式：母序列单独使用一列标识，每个特征序列都使用1列标识。
SPSSAU输出结果如下：
‍（7）TOPSIS法 TOPSIS法用于研究与理想方案相似性的顺序选优技术，通俗理解即为数据大小有优劣关系，数据越大越优，数据越小越劣，因此结合数据间的大小找出正负理想解以及正负理想解距离，并且在最终得到接近程序C值，并且结合C值排序得出优劣方案排序。
在进行TOPSIS法分析时，数据一定需要全部同趋势正向化，即让所有的数据表示为数字越大越优；如果数据量纲不一致，还需要使用数据归一化解决量纲问题。
SPSSAU输出结果如下：
‍（8）熵权TOPSIS法 熵权TOPSIS法核心在于TOPSIS，但在计算数据时，首先会利用熵值法（熵权法）计算得到各评价指标的权重，并且将评价指标数据与权重相乘，得到新的数据，利用新数据进行TOPSIS法研究。
‍（9）优序图法 优序图法利用数据相对重要性原理进行权重计算，数字越大，其相对重要性会越高。SPSSAU默认对分析项计算出平均值，并且结合平均值的相对大小构建出优序图权重计算表，进而计算得到权重。
SPSSAU输出权重计算结果如下：
‍（10）CRITIC权重 CRITIC权重法是一种客观赋权法。其思想在于用于两项指标，分别是对比强度和冲突性指标。对比强度使用标准差进行表示；冲突性使用相关系数进行表示。权重计算时，对比强度与冲突性指标相乘，并且进行归一化处理，即得到最终的权重。
在进行CRITIC分析之前，通常需要对数据进行量纲化处理，一般建议使用正向化或逆向化处理。
SPSSAU输出权重计算结果如下：
‍（11）独立性权重 独立性权重法是一种客观赋权法。其思想在于利用指标之间的共线性强弱来确定权重。如果说某指标与其它指标的相关性很强，说明信息有着较大的重叠，意味着该指标的权重会比较低，反之该指标的权重会更高。
SPSSAU输出权重计算结果如下：
‍（12）信息量权重 信息量权重法是一种客观赋权法。其思想在于利用数据的变异系数进行权重赋值，如果变异系数越大，说明其携带的信息越大，因而权重也会越大。信息量权重的适用场景较小，通常只用于专家评价打分时使用。
SPSSAU输出权重计算结果如下：
‍（13）DEMATEL Dematel(决策实验室法)，其通过系统中各要素之间的逻辑关系和直接影响矩阵，可以计算出每个要素对其它要素的影响度以及被影响度，从而计算出每个要素的原因度与中心度，作为构造模型的依据，从而确定要素间的因果关系和每个要素在系统中的地位。
DEMATEL的数据格式说明为：第1行为标题，第2行起为数据，数据一定为方阵（即除标题外的数据需要行和列相等），右下三角线数据一定为0。数据格式类似下图。
SPSSAU输出权重计算结果如下：
以上13种分析方法的更详细介绍，可以登录SPSSAU官网，查看每一种方法的帮助手册说明，以及教学视频。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef06ee4b9579c34c3a8d9c1513be2f4/" rel="bookmark">
			关于正则表达式中?=、?!、?＜=、?＜!、?:的理解与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、?=、?!、?＜=、?＜!、?:的解释 1. 先看一下比较官方的解释 (?=pattern)：正向先行断言，表示匹配位置后面必须紧跟着满足 pattern 的字符串，但不包括这个字符串在匹配结果中。(?!pattern)：负向先行断言，表示匹配位置后面不能紧跟着满足 pattern 的字符串，也不包括这个字符串在匹配结果中。(?&lt;=pattern)：正向后行断言，表示匹配位置前面必须是满足 pattern 的字符串，但不包括这个字符串在匹配结果中。(?&lt;!pattern)：负向后行断言，表示匹配位置前面不能是满足 pattern 的字符串，也不包括这个字符串在匹配结果中。(?:pattern)：非捕获型分组，表示将 pattern 包含在一个分组中，但不把这个分组的匹配结果保存到分组编号中。这个分组通常用于表示可选的或重复的子表达式，或者是限制量词的作用范围，而不需要把它们的匹配结果单独提取出来。 2. 再看一下比较通俗易懂的解释： RegExp1(?=RegExp2) 匹配后面是RegExp2 的 RegExp1RegExp1(?!RegExp2) 匹配后面不是RegExp2 的 RegExp1(?&lt;=RegExp2)RegExp1 匹配前面是RegExp2 的 RegExp1(?&lt;!RegExp2)RegExp1 匹配前面不是RegExp2 的 RegExp1(?:RegExp) 这个等下单独解释，与上面的不太一样 是不是有点明白了，其实?=、?!、?＜=、?＜!的意思可以理解为 if 判断，即只有先通过它们（RegExp2）的判断之后，才可以获取到正则（RegExp1）的匹配结果。
3. 零宽度断言 ?=、?!、?＜=、?＜!其实就是正则表达式中的零宽度断言，以上面的举例来解释↓
RegExp2匹配到的内容是不会返回的，也不会消耗匹配到的字符，只会返回RegExp1的匹配结果，这就是零宽度断言，零宽度断言在正则表达式中非常有用，因为它们可以在不改变匹配结果的情况下，对匹配位置前后的内容进行限制或判断。
4. ?: 的解释 (?:) 并不是零宽度断言，而是非捕获组，它跟普通的括号 () 的区别在于，它不会保存匹配到的内容，但是它仍然会消耗字符并返回匹配内容，只是不会保存匹配结果。
()表示捕获分组，它会把匹配到的内容保存到内存中，开发者可以使用$n(n是一个数字)来代表第n个()中匹配到的内容(?:)表示非捕获组，它匹配的内容不会被保存，所以无法使用$n获取，但也因为没有被保存所以节省了一部分内存空间 二、举例 ?= '我喜欢苹果'.replace(/我喜欢(?=苹果)/,'我讨厌') // 匹配 我喜欢苹果 中的 我喜欢 并替换为 我讨厌，因为是零宽度断言所以不包含苹果，故结果为 我讨厌苹果 '我喜欢橘子'.replace(/我喜欢(?=苹果)/,'我讨厌') // 我喜欢后面不是苹果，所以这里正则未通过，匹配不到任何内容，故结果仍为 我喜欢橘子 ?! '我喜欢苹果'.replace(/我喜欢(?!苹果)/,'我讨厌') // 匹配后面不是苹果的我喜欢，正则未通过，故结果仍为 我喜欢苹果 '我喜欢橘子'.replace(/我喜欢(?!苹果)/,'我讨厌') // 正则通过，匹配到 我喜欢 进行替换，因为是零宽度断言所以橘子不在匹配结果中，故结果为 我讨厌橘子 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef06ee4b9579c34c3a8d9c1513be2f4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/606/">«</a>
	<span class="pagination__item pagination__item--current">607/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/608/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>