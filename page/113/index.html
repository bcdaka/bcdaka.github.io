<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f6990bb691127c7de45594338f0470/" rel="bookmark">
			qt表格模型视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 提供了一套强大的模型/视图框架，允许你以一种非常灵活和高效的方式显示和处理数据。在 Qt 中，表格视图（TableView）和模型（TableModel）是这种框架的一部分，常用于显示和编辑表格数据。
以下是一些基本的概念和步骤，帮助你理解如何在 Qt 中使用表格模型和视图：
模型（Model）
模型是数据的抽象表示。在 Qt 中，模型负责存储数据，并提供一种方式来访问这些数据。QAbstractTableModel 是一个常用的基类，用于创建自定义的表格模型。
视图（View）
视图是模型的可视化表示。QTableView 是一个表格视图，显示模型中的数据，并允许用户与数据进行交互。
代理（Delegate）
代理用于自定义视图中的单元格的显示和编辑方式。QStyledItemDelegate 或自定义的 QItemDelegate 可以用于此目的。
编辑器（Editor）
编辑器是用于编辑单元格的组件。例如，QLineEdit 可以用于编辑文本。
选择模型（Selection Model）
选择模型用于管理用户在视图中的选择。
#include "mytablemodel.h" #include &lt;QtMath&gt; #include &lt;QColor&gt; MyTableModel::MyTableModel(QObject *parent) : QAbstractTableModel(parent) { m_columnNum=9; } void MyTableModel::setInitData(QList&lt;CellInfo*&gt;&amp; data) { //重置model数据之前调用beginResetModel，此时会触发modelAboutToBeReset信号 beginResetModel(); //重置model中的数据 m_datas = data; m_rowNum = ceil(data.size()*1.0/m_columnNum); //行数=数据总数/列数，然后向上取整 //数据设置结束后调用endResetModel，此时会触发modelReset信号 endResetModel(); } int MyTableModel::rowCount(const QModelIndex &amp;parent) const { if (parent.isValid()) { return 0; } else { return m_rowNum; } } int MyTableModel::columnCount(const QModelIndex &amp;parent) const { if (parent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f6990bb691127c7de45594338f0470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79129bf8167e434754d9a81f962e3fac/" rel="bookmark">
			网络服务综合项目（一键部署shell脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 主机环境描述 主机名主机地址需要提供的服务content.exam.com172.25.250.101提供基于 httpd/nginx 的 YUM仓库服务ntp.exam.com172.25.250.102提供基于Chronyd 的 NTP 服务mysql.exam.com172.25.250.103提供基于 MySQL 的数据库服务nfs.example.com172.25.250.104提供基于 NFS 的网络文件系统服务dns.exam.com 172.25.250.105提供基于 bind 的 DNS 服务bbs.exam.com172.25.250.106提供基于 Discuz 的论坛服务 注意： 172.25.250.101-172.25.250.105 共 5 个 IP 地址由servera.exam.com服务器进行提供。 172.25.250.106 由 serverb.exam.com 服务器进行提供。
项目需求：
1. 172.25.250.101 主机上的 Web 服务要求提供 www.exam.com Web站点，该站点在任何路由可达 的主机上被访问，页面内容显示为 "Hello，Welcome to www.exam.com !"，并提供 content.exam.com/yum/AppStream和content.exam.com/yum/BaseOS URL 作为网络仓库供所 有主机使用。
2. 172.25.250.102 主机提供基于Chronyd 的 NTP 服务将本主机作为时间服务器，对外提供 NTP 服 务，并设置本服务器为 3 层。
3. 172.25.250.103 主机提供的MySQL 数据库服务，要求使用需求1中提供的仓库进行安装，并将数据 库密码设定为 redhat。创建名称为 bbs 的数据库提供给论坛服务使用。
4. 172.25.250.104 主机提供 NFS 服务，该服务将导出本地的 /bbs 目录作为论坛数据目录，该导出指 定只能论坛所在主机使用，并且开机自动挂载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79129bf8167e434754d9a81f962e3fac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f773f97c3bb3db13f454b5aab12ab436/" rel="bookmark">
			OpenCV 图像处理 轮廓检测基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本原理关键函数和参数注意事项 示例代码示例效果代码详解findContours 函数原型findContours函数变体 基本原理 轮廓发现是图像处理中的一个重要步骤，用于检测物体的边界和形状。
图像预处理：
轮廓发现通常在灰度图像上进行。因此，首先将图像转换为灰度图像。接下来，应用滤波器来减少噪声。常用的滤波器有高斯模糊（Gaussian Blur），它有助于平滑图像并减少噪声。
边缘检测：
在预处理后的图像上应用边缘检测算法。常用的边缘检测算法是Canny边缘检测器，它能有效地检测出图像中的边缘。Canny边缘检测器使用梯度的方向和幅度来找到图像中的边缘。
轮廓提取：
一旦得到二值化的边缘图像，就可以使用OpenCV的findContours函数来提取轮廓。findContours函数将图像中的每一个边缘视为一个轮廓，并返回一个轮廓列表。每个轮廓都由一系列点组成，这些点定义了轮廓的形状。
轮廓的层次结构：
findContours函数不仅可以返回轮廓，还可以返回轮廓的层次结构。这对于包含内嵌轮廓（如嵌套在其他轮廓中的孔洞）的图像非常有用。层次结构信息存储了每个轮廓的父子关系。
关键函数和参数 cv2.findContours(image, mode, method)：
image: 输入的二值图像（通常是边缘检测的结果）。mode: 轮廓检索模式，如cv2.RETR_EXTERNAL（只检测外轮廓）、cv2.RETR_TREE（检测所有轮廓并构建层次结构）。method: 轮廓逼近方法，如cv2.CHAIN_APPROX_SIMPLE（只保存轮廓的必要点）、cv2.CHAIN_APPROX_NONE（保存所有轮廓点）。 cv2.drawContours(image, contours, contourIdx, color, thickness)：
用于在图像上绘制轮廓。
注意事项 图像的预处理：
轮廓发现对输入图像的质量非常敏感。良好的预处理（如去噪、对比度增强等）可以显著提高轮廓检测的效果。
边缘检测器的选择：
边缘检测器的参数（如Canny边缘检测器的阈值）需要根据图像的特征进行调整。
轮廓的近似和表示：
对于复杂的形状，可以使用多边形逼近（如Douglas-Peucker算法）来简化轮廓。
轮廓发现技术广泛应用于对象检测、形状分析、图像分割等领域。在这些应用中，轮廓的精确提取和表示对于后续处理和分析至关重要。
示例代码 在OpenCV中，使用C++进行轮廓发现通常包括以下主要步骤：读取图像、灰度化、边缘检测、轮廓发现和绘制轮廓。以下是一个基本的C++代码示例，展示如何使用OpenCV进行这些操作：
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; int main() { // 读取图像 Mat src = imread("image.jpg"); if (src.empty()) { cout &lt;&lt; "无法加载图像！" &lt;&lt; endl; return -1; } // 转换为灰度图像 Mat gray; cvtColor(src, gray, COLOR_BGR2GRAY); // 应用高斯模糊以去除噪声 Mat blurred; GaussianBlur(gray, blurred, Size(5, 5), 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f773f97c3bb3db13f454b5aab12ab436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711a641fbc4179cab210a87607d1f506/" rel="bookmark">
			【Java题解】以二进制加法的方式来计算两个内容为二进制数字的字符串相加的结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎大家收看，请多多支持🌹
🥰关注小哇，和我一起成长🚀个人主页🚀
👑目录
分析：🚀 数字层面分析⭐
字符串层面分析⭐
代码及运行结果分析:🚀
代码：⭐
运行结果：​编辑⭐
具体分析：⭐
题目 分析： 数字层面分析 先来看在二进制中 1+0==1，0+0==0，1+1==0
如果两个多位的二进制数相加，就还要考虑是否向前一位进1的问题，显然上面的三个式子中只有 1+1==0是需要向前进一位的。
考虑了向前进位的问题，还要考虑当前位的数字相加是否要多加一个来自上一位进的1（即当前位的上一位如果进1了的话，那么当前位相加是需要加上这个进的 1）：
前一位没有进 1前一位进 11和0相加1+0 == 1，不向前一位进11+0+1 == 0，向前进11和1相加1+1 == 0，向前进11+1+1 == 1，向前进10和0相加0+0 == 0，不向前进10+0+1 == 1，不向前进1 因此，我们可以知道1+0、0+0、1+1这三种情况的结果都有两种情况，
并且，当 1+1 相加的时候，一定会向前进一位，
0+0 相加的时候，一定不会进一位，
而 0+1 时，就会有进一位和不进一位两种情况，即它的上一位的两个数相加进了一位，那么0+1才会向前进一位；它的上一位两个数没有向前进位，那么0+1就不会进位
字符串层面分析 计算数字时我们都会右对齐来计算，但是在代码中我们习惯从左到右来分析解决问题，因此我们可以将字符串反转，计算完后在反转回来就能够得到原来的字符串相加的结果
这里需要用到StringBuilder类和StringBuffer类的reverse()方法来反转字符串，它会修改调用的对象，而不是新建一个对象：
str.reverse();//将字符串str反转
两个字符串的长度如果不相同，我们可以给较短的字符串反转之后再末尾添加上'0'来计算，并且不会影响结果。
str.append("hello");//给字符串str尾部追加一个hello
代码及运行结果分析: 代码： import java.util.Scanner; public class Test { public static void main(String[] args) { //：输入两个字符串a和b，字符串内容为二进制数字，求两个字符串相加的结果， // 加法计算方法以二进制方式计算，并返回对应的字符串结果。要求程序尽可能的高效。 //字符串长度不超过100 Scanner in = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/711a641fbc4179cab210a87607d1f506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7c6262c301f8887ae37b9f3baedfb2/" rel="bookmark">
			手机怎么设置不同的ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化日益深入的今天，智能手机已成为我们生活、工作和学习中不可或缺的设备。然而，随着网络应用的广泛和深入，我们有时需要为手机设置不同的IP地址来满足特定需求。比如，避免网络限制、提高网络安全、或者进行网络测试等。本文将详细介绍如何在手机上设置不同的IP地址，帮助读者更好地掌握这一技能。
一、了解IP地址的基本概念 在开始设置之前，我们首先需要了解IP地址的基本概念。IP地址，即互联网协议地址，是分配给连接到互联网的设备的一个数字标签。它用于在网络中唯一标识一个设备，并允许设备之间进行通信。在手机上，我们通常会使用到两种类型的IP地址：动态IP地址和静态IP地址。动态IP地址是由网络自动分配的，而静态IP地址则需要我们手动设置。
二、手机怎么设置不同的IP地址 切换移动数据网络：当手机使用移动数据网络连接互联网时，可以通过简单的操作来更改IP地址。首先，打开手机设置，找到“移动数据”或“蜂窝数据”选项，然后禁用移动数据。等待几秒钟后，重新启用移动数据，此时手机通常会获取到一个新的IP地址。连接不同的WiFi网络：对于连接WiFi网络的手机用户，更改IP地址的方法更为简单。只需打开手机设置，进入“WiFi”选项，断开当前连接的WiFi网络，然后选择并连接另一个WiFi网络。连接成功后，手机的IP地址将自动更改为新WiFi网络分配的IP地址。设置静态IP地址：在某些情况下，我们可能需要为手机设置静态IP地址。首先，从网络管理员或服务提供商那里获取静态IP地址、子网掩码、网关和DNS信息。然后进入Wi-Fi设置，选择“修改网络”或“高级选项”，设置IP为“静态”，输入IP地址等信息，保存设置。使用第三方软件：使用第三方软件，如支持免费试用的虎观代理IP软件，可以连接到不同的城市线路节点，从而更换IP地址。用户只需下载并安装软件，完成注册和登录后，即可在软件内一键更换IP或指定地区更换IP。 三、注意事项 在更改IP地址时，我们需要注意以下几点：
确保操作的安全性和合法性，避免触犯相关法律法规。在设置静态IP地址时，要确保所设置的IP地址与网络中其他设备的IP地址不冲突。在连接WiFi网络时，要确保所连接的网络是安全的，避免连接到不安全的网络导致隐私泄露或网络安全问题。 结尾： 通过以上方法，我们可以轻松地为手机设置不同的IP地址，以满足不同的网络需求。无论是切换移动数据网络、连接不同的WiFi网络还是设置静态IP地址等，都可以帮助我们更好地管理手机的网络连接。希望本文的介绍能够帮助读者更好地掌握这一技能，并在使用手机的过程中更加得心应手。
猜您感兴趣： 手机恢复出厂设置ip地址会变吗
更换手机号，IP地址会随之改变吗？
手机怎么自动切换ip地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33ecd47534205be2964ce98cee55584/" rel="bookmark">
			在 iPhone 15 Pro 上运行 Llama-3.1 8B；使用扩散模型生成类人绘画过程的工具；使用ChatGPT自动生成思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 1: MLX Examples 在 iPhone 15 Pro 上运行 Llama-3.1 8B
基于 MLX 机器学习推理框架轻松将 「Llama-3.1 8B」在 iPhone 15 Pro 上运行🤯 代码已开源！
地址：https://github.com/ml-explore/mlx-swift-examples/pull/98
✨ 2: ProcessPainter ProcessPainter 是使用扩散模型生成类人绘画过程的工具，目前支持推理和部分训练功能。
ProcessPainter 是一种基于动画扩散模型（animatediff）来生成仿人类绘画过程的模型。它的开发过程包括基础和完整推理代码的发布、模型检查点的发布，并计划未来发布训练代码和训练数据集。
绘画过程生成：ProcessPainter 可以模拟人类绘画的步骤，生成逼真的绘画过程。
预训练和微调：绘画模块基于多种传统绘画过程重建方法进行了预训练。通过使用 LoRA（低秩适应）技术，进一步微调模型，取得了非常出色的绘画过程生成效果。
图像参考：通过结合图像参考网络，可以重构现有绘画或完成未完成的绘画过程。
地址：https://github.com/nicolaus-huang/ProcessPainter
✨ 3: MindGeniusAI MindGeniusAI使用ChatGPT自动生成思维导图，并支持节点编辑和自定义。
MindGeniusAI 是一个依托 ChatGPT 的思维导图自动生成工具。它的功能主要包括自动生成思维导图、手动添加节点、删除多余节点、修改节点、以 Markdown 格式渲染和显示结果、导出为图片或 JSON 文件、支持单个节点的 AI 生成内容、编辑现有节点、应用内聊天支持以及文件导入功能。
地址：https://github.com/xianjianlf2/MindGeniusAI
✨ 4: SuperMemory SuperMemory帮助您保存和管理网络内容，创建属于自己的第二大脑。
SuperMemory 是一个帮助用户创建“第二大脑”的工具，相当于一个适用于书签和保存内容的 ChatGPT。它允许用户导入推文或保存网站和内容，通过 Chrome 扩展实现。
地址：https://github.com/supermemoryai/supermemory
✨ 5: Align-Anything Align-Anything 通过各种对齐算法将大模型对齐到人类意图和价值上。
Align-Anything是一个基于DeepSpeed或NeMo（目前正在开发）的开源对齐框架，旨在使各种模态的大模型（如大语言模型LLMs、视觉语言模型VLMs等）与人类的意图和价值观对齐。
Align-Anything框架为研究人员和开发者提供了一个强大的工具，通过对新兴的模型对齐技术进行实验和优化，以便模型的行为更符合人类的预期和需求。
地址：https://github.com/PKU-Alignment/align-anything
更多AI工具，参考国内AiBard123，Github-AiBard123 公众号：每日AI新工具
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698776babeb0729162c30c9dc1de4de8/" rel="bookmark">
			Unity材质球自动遍历所需贴图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity材质球自动遍历所需贴图 文章目录 Unity材质球自动遍历所需贴图一、原理二、用法1.代码：2.使用方法 一、原理 例如一个材质球名为：Decal_Text_Cranes_01_Mat ，
然后从全局遍历出：Decal_Text_Cranes_01_Albedo赋值给材质球的BaseMap,
全局遍历出Decal_Text_Cranes_01_MAODS 赋值给材质球MetallicMap通道，
全局遍历出Decal_Text_Cranes_01_Normal 给材质球NormalMap通道，
**规律：**材质球名字：Decal_Text_Cranes_01_Mat 把后面Mat换成通道名称，就是该材质球的通道贴图
二、用法 1.代码： using UnityEngine; using System.Collections.Generic; using System.IO; using UnityEditor; public class AutoAssignTextureMaps : MonoBehaviour { public List&lt;Material&gt; targetMaterials; // 在Inspector中指定目标材质列表 private Dictionary&lt;string, string&gt; textureMapNames = new Dictionary&lt;string, string&gt; { { "Albedo", "_BaseMap" }, // Base Color { "MAODS", "_MetallicGlossMap" }, // Metallic and Smoothness { "Normal", "_BumpMap" } // Normal Map }; [ContextMenu("_AlphaMat后缀自动补全")] void AssignTextures1( ) { foreach (Material material in targetMaterials) { string baseName = material.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/698776babeb0729162c30c9dc1de4de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9574a6a688497ab3edfd2f7b57d50ac9/" rel="bookmark">
			深入分析 Android ContentProvider (四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深入分析 Android ContentProvider (四)ContentProvider 的最佳实践和注意事项1. 最佳实践1.1. 合理选择 ContentProvider 的使用场景1.2. 高效的 URI 匹配示例：使用 UriMatcher 1.3. 合理使用批量操作和事务示例：批量更新数据 1.4. 使用异步查询和加载示例：使用 RxJava 进行异步查询 1.5. 处理数据变化通知示例：注册 ContentObserver 2. 注意事项2.1. 避免内存泄漏示例：注销 ContentObserver 2.2. 处理并发访问示例：同步块 2.3. 合理配置权限2.4. 处理数据迁移和版本控制示例：数据迁移 3. 总结 深入分析 Android ContentProvider (四) ContentProvider 的最佳实践和注意事项 在使用 ContentProvider 时，遵循最佳实践并注意一些常见问题，可以帮助开发者避免陷阱，并确保应用的稳定性和高效性。以下是一些重要的最佳实践和注意事项。
1. 最佳实践 1.1. 合理选择 ContentProvider 的使用场景 ContentProvider 主要用于以下场景：
跨进程数据共享：在不同应用之间共享数据。统一的数据访问接口：提供标准化的数据操作接口，简化数据访问。数据权限控制：通过权限声明和 URI 授权控制数据访问的安全性。 如果仅在应用内部进行数据操作，使用 ContentProvider 可能会带来不必要的开销。对于这种情况，建议使用更轻量级的本地数据库访问方式，如直接使用 SQLite 或 Room。
1.2. 高效的 URI 匹配 在 ContentProvider 中，使用 UriMatcher 进行 URI 匹配时，应尽量避免不必要的复杂性，并保证匹配过程高效。UriMatcher 可以将不同的 URI 映射到特定的操作或资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9574a6a688497ab3edfd2f7b57d50ac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420b4dac22a5e4aa30027827dffae836/" rel="bookmark">
			CentOS 7 修改DNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、nmcli connection show 命令找到设备名称
# nmcli connection show NAME UUID TYPE DEVICE enp4s0 99559edf-4e0a-4bae-a528-6d75065261e9 ethernet enp4s0 2、nmcli connection modify 命令修改dns
nmcli connection modify enp4s0 ipv4.dns "114.114.114.114 8.8.8.8" 这时候查看/etc/sysconfig/network-scripts/ifcfg-enp4s0已修改了，但是/etc/resolv.conf还没修改
[root@localhost yum.repos.d]# cat /etc/sysconfig/network-scripts/ifcfg-enp4s0 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=no IPV6_AUTOCONF=no IPV6_DEFROUTE=no IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=enp4s0 UUID=99559edf-4e0a-4bae-a528-6d75065261e9 DEVICE=enp4s0 ONBOOT=yes IPADDR=10.100.1.99 PREFIX=24 GATEWAY=10.100.1.1 DNS1=114.114.114.114 DNS2=8.8.8.8 3、使用nmcli connection up命令生效
nmcli connection up enp4s0 成功执行后，/etc/resolv.conf也修改了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe28ce39d773aa55f5bb3a79ab79113f/" rel="bookmark">
			科普文：Linux系统安全加固指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。
列出的所有命令都将需要root特权。以“$”符号开头的单词表示一个变量，不同终端之间可能会有所不同。
选择正确的Linux发行版 选择一个好的Linux发行版有很多因素。
避免分发冻结程序包，因为它们在安全更新中通常很落后
不使用与Systemd机制的发行版。 Systemd包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。
使用musl作为默认的C库。 Musl专注于最小化，这会导致很小的攻击面，而其他C库（例如glibc）过于复杂，容易产生漏洞。例如，与musl中的极少数漏洞相比，glibc中的一百多个漏洞已被公开披露。尽管仅靠披露的CVE本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。
最好默认情况下使用LibreSSL而不是OpenSSL的发行版。OpenSSL包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持OS / 2和VMS支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的Heartbleed漏洞。LibreSSL是OpenBSD团队的OpenSSL分支，它采用了出色的编程实践并消除了很多攻击面。在LibreSSL成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。
用作强化操作系统基础的最佳发行版是Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。
但是，由于Gentoo的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的Musl构建是一个很好的折衷方案。
内核 内核是操作系统的核心，不幸的是很容易受到攻击。正如Brad Spengler曾经说过的那样，可以将其视为系统上最大，最易受攻击的setuid根二进制文件。因此，对内核进行尽可能多的强化非常重要。
Stable vs LTS 内核 Linux内核以两种主要形式发布：稳定和长期支持（LTS）。稳定版本是较新的版本，而LTS发行版本是较老的稳定版本，长期以来一直受支持。选择上述任何一个发行版本都有许多后果。
Linux内核未使用CVE标识安全漏洞。这意味着大多数安全漏洞的修复程序不能向后移植到LTS内核。但是稳定版本包含到目前为止进行的所有安全修复。
但是，有了这些修复程序，稳定的内核将包含更多新功能，因此大大增加了内核的攻击面，并引入了大量新错误。相反，LTS内核的受攻击面较小，因为这些功能没有被不断添加。
此外，稳定的内核还包括更新的强化功能，以减轻LTS内核没有的某些利用。此类功能的一些示例是Lockdown LSM和STACKLEAK GCC插件。
总而言之，在选择稳定或LTS内核时需要权衡取舍。LTS内核具有较少的强化功能，并且并非当时所有的公共错误修复都已向后移植，但是通常它的攻击面更少，并且引入未知错误的可能性也较小。稳定的内核具有更多的强化功能，并且包括所有已知的错误修复，但它也具有更多的攻击面以及引入更多未知错误的机会更大。最后，最好使用较新的LTS分支（如4.19内核）。
Sysctl Sysctl是允许用户配置某些内核设置并启用各种安全功能或禁用危险功能以减少攻击面的工具。要临时更改设置，您可以执行：
sysctl -w $tunable = $value
要永久更改sysctls，您可以将要更改的sysctls添加到/etc/sysctl.conf或/etc/sysctl.d中的相应文件，具体取决于您的Linux发行版。
以下是您应更改的建议sysctl设置。
Kernel self-protection kernel.kptr_restrict=2
内核指针指向内核内存中的特定位置。这些在利用内核方面可能非常有用，但是默认情况下不会隐藏内核指针，例如，通过读取/proc/kallsyms的内容即可轻松发现它们。此设置旨在减轻内核指针泄漏。另外，您可以设置kernel.kptr_restrict = 1以仅从没有CAP_SYSLOG功能的进程中隐藏内核指针。
kernel.dmesg_restrict=1
dmesg是内核日志，它公开了大量有用的内核调试信息，但这通常会泄漏敏感信息，例如内核指针。更改上述sysctl设置会将内核日志限制为CAP_SYSLOG功能。
kernel.printk=3 3 3 3
尽管dmesg_restrict的值，启动过程中内核日志仍将显示在控制台中。能够在引导过程中记录屏幕的恶意软件可能会滥用此恶意软件以获得更高的特权。此选项可防止这些信息泄漏。必须将其与下面描述的某些引导参数结合使用才能完全有效。
kernel.unprivileged_bpf_disabled=1
net.core.bpf_jit_harden=2
eBPF暴露了很大的攻击面，因此需加以限制。这些系统将eBPF限制为CAP_BPF功能（在5.8之前的内核版本上为CAP_SYS_ADMIN），并启用JIT强化技术，例如常量绑定。
dev.tty.ldisc_autoload=0
这将加载TTY行规则限制为CAP_SYS_MODULE功能，以防止非特权的攻击者使用TIOCSETD ioctl加载易受攻击的线路规则，而该TIOCSETD ioctl之前已在许多漏洞利用中被滥用。
vm.unprivileged_userfaultfd=0
userfaultfd() 系统调用经常被滥用以利用“事后使用(use-after-free)”缺陷。因此，该sysctl用于将此syscall限制为CAP_SYS_PTRACE功能。
kernel.kexec_load_disabled=1
kexec是一个系统调用，用于在运行时引导另一个内核。可以滥用此功能来加载恶意内核并在内核模式下获得任意代码执行能力，因此该sysctl设置将被禁用。
kernel.sysrq=4
SysRq密钥向非特权用户公开了许多潜在的危险调试功能。与通常的假设相反，SysRq不仅是物理攻击的问题，而且还可以远程触发。该sysctl的值使其可以使用户只能使用SAK密钥，这对于安全地访问root是必不可少的。或者，您可以简单地将值设置为0以完全禁用SysRq。
kernel.unprivileged_userns_clone=0
用户名称空间是内核中的一项功能，旨在改善沙箱并使非特权用户易于访问它，但是，此功能公开了重要的内核攻击面，以进行特权升级，因此该sysctl将用户名称空间的使用限制为CAP_SYS_ADMIN功能。对于无特权的沙箱，建议使用具有很少攻击面的setuid二进制文件，以最大程度地减少特权升级的可能性。沙箱章节部分将进一步讨论此主题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe28ce39d773aa55f5bb3a79ab79113f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b130489be5ffc4df940ecff8c486e9c/" rel="bookmark">
			全新微软语音合成网页版源码，短视频影视解说配音网页版系统-仿真人语音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码介绍 最新微软语音合成网页版源码，可以用来给影视解说和短视频配音。它是TTS文本转语言，API接口和PHP源码。
这个微软语音合成接口的源码，超级简单，就几个文件搞定。用的是官方的API，试过了，合成速度挺快的。
你平时看的那些短视频，比如电影解说和搞笑视频，用的都是微软的配音员，听起来跟真人差不多，市面上很少有比得上的。
搭建教程 1、首先把压缩包里的index.html这些文件放到你的网站里。
2、改一下getSpeek.php文件里的apikey（就是密钥）和region（地区），用你自己在微软语音合成官网申请的。
3、最后访问一下index.html文件，就能正常跑起来了。
源码链接： 网盘源码 密码：hma8
源码截图： 微软语音合成网页版源码，方便简单！这个系统可以用于短视频和影视解说配音，而且采用了仿真人语音技术，听起来超级自然。
源码也简单，只要几个文件就能轻松搞定。最关键的是，它用的是微软官方的API接口，稳定又可靠。测试过了，语音合成的速度真的快，满足速度的需求。
这个系统还可以和其他网页版系统无缝集成，兼容性特别好。无论你是个人还是企业用户，都能用这个源码快速搭建自己的语音合成平台。
总之，这个微软语音合成网页版源码，对于喜欢短视频和影视解说配音的朋友来说，是个不可多得的好工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2bd915ef0a2b72178f807b64cbc169/" rel="bookmark">
			安装配置Kafka，并使用Java集成Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Kafka的环境要求 首先在安装 Kafka 之前，需要满足的环境要求：
1、Java运行环境
Kafka 是使用 Java 语言编写的，因此需要在安装 Kafka 之前先安装 Java 运行环境。Kafka 支持 Java 8 及以上版本。可以通过以下命令检查 Java 运行环境的版本
java -version 2、ZooKeeper
Kafka 的运⾏环境依赖于 ZooKeeper，Kafka 使用 ZooKeeper 进行分布式协调，因此在安装 Kafka 之前，需要先安装 ZooKeeper。
二、安装ZooKeeper 1、解压安装 在 /usr/local/ 下创建 zookeeper ⽂件夹并进⼊，
将 ZooKeeper 安装包解压到 /usr/local/zookeeper 中即可，
[root@localhost zookeeper]# tar -zxvf /root/apache-zookeeper-3.6.1-bin.tar.gz -C ./ 2、创建一个data目录 这⾥直接在 /usr/local/zookeeper/apache-zookeeper-3.6.1-bin ⽬录中创建⼀个 data ⽬录。
该 data ⽬录地址要配到 ZooKeeper 的配置⽂件中。
3、创建配置文件并修改 进⼊到 zookeeper 的 conf ⽬录，复制 zoo_sample.cfg 得到 zoo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2bd915ef0a2b72178f807b64cbc169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91cc56d4a493def3aabf3047253b0802/" rel="bookmark">
			【JavaScript】`forEach` 方法的详解与实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、`forEach` 方法的基本概念二、基本用法示例三、使用索引与数组参数四、使用 `thisArg` 参数五、常见应用场景六、与其他遍历方法的对比`forEach` vs `map``forEach` vs `filter``forEach` vs `reduce` 七、注意事项和最佳实践八、实战示例 在 JavaScript 中，forEach 方法是数组对象的重要组成部分。它提供了一种简洁、优雅的方式来遍历数组中的每个元素，并对其执行指定操作。本文将详细介绍 forEach 方法的基本概念、用法、常见的应用场景、与其他遍历方法的对比，并提供实战示例，帮助您全面掌握这一强大的工具。
一、forEach 方法的基本概念 forEach 方法用于遍历数组，并对每个元素执行一次给定的回调函数。与传统的 for 循环不同，forEach 方法简化了遍历操作，使代码更为简洁。
语法：
array.forEach(callback(currentValue[, index[, array]])[, thisArg]) callback：对每个元素执行的函数，接收三个参数： currentValue：当前处理的元素。index（可选）：当前处理元素的索引。array（可选）：调用 forEach 方法的数组。 thisArg（可选）：执行回调时用作 this 的值。 二、基本用法示例 下面是一个简单的例子，使用 forEach 方法遍历一个数组并打印每个元素：
const numbers = [1, 2, 3, 4, 5]; numbers.forEach(number =&gt; { console.log(number); }); // 输出: 1 2 3 4 5 在这个示例中，forEach 方法对 numbers 数组中的每个元素执行回调函数，并将当前元素作为参数传递给回调函数。
三、使用索引与数组参数 forEach 方法的回调函数还可以接收当前元素的索引和原数组作为参数。下面是一个使用索引参数的例子：
const fruits = ['apple', 'banana', 'cherry']; fruits.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91cc56d4a493def3aabf3047253b0802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d376c9049f686588b4735f5f6dd1be/" rel="bookmark">
			谷粒商城实战笔记-60-商品服务-API-品牌管理-效果优化与快速显示开关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一，显示状态列改为switch开关二，监听状态改变 首先，把ESLint语法检查关掉，因为这个语法检查过于严格，在控制台输出很多错误信息，干扰开发。
在build目录下下webpack.base.conf.js中，把createLintingRule方法中的代码注释掉。
一，显示状态列改为switch开关 对brand.vue做如下修改。
&lt;el-table-column prop="showStatus" header-align="center" align="center" label="显示状态"&gt; &lt;template slot-scope="scope"&gt; &lt;i class="el-icon-time"&gt;&lt;/i&gt; &lt;el-switch v-model="scope.row.showStatus" active-color="#13ce66" inactive-color="#ff4949"&gt; &lt;/el-switch&gt; &lt;/template&gt; &lt;/el-table-column&gt; 这段代码使用了Element UI框架中的几个关键特性来定义一个表格列，并在其中嵌入了一个开关组件，允许用户改变表格行中的显示状态。
Element UI 的 &lt;el-table-column&gt; 组件:
用于定义表格中的一列。prop 属性指定表格列所绑定的数据属性名。header-align 和 align 属性分别设置表头和单元格内容的对齐方式。label 属性设置列的标题文本。 作用域插槽 (&lt;template slot-scope="scope"&gt;):
允许在表格单元格内使用模板语法来动态渲染内容。scope 对象包含了当前行的数据和其他相关信息。 Vue.js 的双向数据绑定 (v-model):
用于在 &lt;el-switch&gt; 组件和数据模型之间建立双向绑定。当用户改变开关的状态时，会自动更新绑定的数据模型。 Element UI 的 &lt;el-switch&gt; 组件:
提供了一个开关控件，用于切换布尔值。可以通过 active-color 和 inactive-color 属性自定义开关处于不同状态时的颜色。 对brand-add-or-update.vue做如下修改。
①
②
调整表单标签宽度。
二，监听状态改变 给el-switch绑定change事件，用以监听开关状态的变化。
监听事件代码如下。
updateBrandStatus (row) { let {brandId, showStatus } = row; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7d376c9049f686588b4735f5f6dd1be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79687aa66038d88a976daab755b3dca7/" rel="bookmark">
			2024最新 Navicat Premium 17.0.12简体中文版破解激活永久使用（保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2024最新 Navicat Premium 17.0.12 简体中文版破解激活永久使用（保姆级教程） 一、Navicat Premium 17下载二、Navicat Premium 17安装三、激活永久使用 一、Navicat Premium 17下载 官网-安装包
官网地址：https://www.navicat.com.cn/download/navicat-premium
百度网盘-安装包及激活补丁包
链接: https://pan.baidu.com/s/1u_gkRLEUo2hvCmkQWZX5eQ 提取码: a2f6
安装包及激活补丁包文件目录如下图所示：
二、Navicat Premium 17安装 三、激活永久使用 解压或打开“激活补丁(Navicat16、17可用)补丁”压缩包，查看redme激活须知，按照须知操作即可。打开Navicat，如果没有提示试用，则说明成功了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef13d6342bcb179a50b8054925a8120/" rel="bookmark">
			最强模型 Llama 3.1 如期而至！扎克伯格最新访谈：Llama 会成为 AI 界的 Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是开源 AI 的里程碑时刻。
文 | 王启隆
出品丨AI 科技大本营（ID：rgznai100）
本文为 CSDN 编辑整理，未经授权，禁止转载。
今天，Meta AI 的最新最强模型 —— Llama 3.1 如期而至。不仅刷新了开源 AI 模型的天花板，还顺带把闭源的也一并超越了。但是，守约的可不止是 Llama 3.1，还有小扎关于本次发布的最新采访。
在放出采访全文前，我们还是先来了解一下这次的发布有多给力，可谓是 Meta AI 研发团队“全明星”出动：
Meta 生成式 AI 副总裁 Ahmad Al-Dahle 为这次发布做了一些基本的介绍：首先是 4050 亿（Llama 3.1 405B）参数的“超大杯”模型，该模型是迄今为止发布的最大、最强的开源模型，此前在四月份曾进行预览，昨天也是被提前曝光了出来。但事实上，这次 Llama 3.1 还升级了之前发布过的 80 亿和 700 亿参数的模型，它们在性能和功能上都有新的提升。三款模型都支持多种语言。
其中，405B 模型在推理、工具使用、多语言处理、上下文窗口等方面有所改进，其基准测试成绩超过了四月份预览时的数据。如下图表所示，它在最经典的 MMLU（大规模多语言理解）测评里险胜了我们认知中的最强闭源模型，Claude 3.5 Sonnet。
同时，这次升级把三款模型的上下文窗口都扩展到了 128K Token，使模型能够处理更大的代码库或更详尽的参考材料。三款模型都具备工具使用能力、增强的推理能力和改进的系统方法。此外，Meta 与合作伙伴紧密合作，用户现在可在 AWS、Databricks、NVIDIA 和 Groq 旗下的相应平台部署 Llama 3.1。Meta 坚信开源的力量，新推出的模型在更新的许可证下分享，允许开发者使用 Llama 的输出改善其他模型。今日起，Meta AI 的用户将可使用 Llama 3.1，Meta 希望开源 AI 成为行业标准，为生态系统繁荣和解决挑战提供帮助，并期待开发者社区的使用反馈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aef13d6342bcb179a50b8054925a8120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f045324d37361758514fb38a3fbee67/" rel="bookmark">
			大数据-48 Redis 通信协议原理RESP 事件处理机制原理 文件事件 时间事件 Reactor多路复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （正在更新…） 章节内容 上节我们完成了：
Redis的缓存机制Redis的淘汰策略LRU LFU 等机制 通信协议 Redis是单进程+单线程的。应用系统和Redis之间是通过Redis协议（RESP）来进行交互的。 响应模式 概念介绍 Redis 协议位于 TCP 层上，即客户端和Redis实例保持双工的连接。
串行模式 串行化是最简单的模式，客户端与服务端建立长连接。连接通过心跳机制来检测（ping-pong）ACK应答。客户端发送请求，服务端响应，客户端收到响应后，再发起第二个请求，服务端再响应。telnet 和 redis-cli 都属于这种模式，耗时在网络传输且性能较低 双工模式 批量请求，批量响应，请求和响应交叉进行，不会混淆（TCP双工）
pipline 的作用是将一批命令进行打包，然后发送给服务器，服务器执行完后按顺序打包返回。通过pipline，一次pipline中包含多条命令+一次网络时间 我们使用Jedis库可以很轻松的使用 pipline
Jedis redis = new Jedis("h121.wzk.icu", 6379); redis.auth("111111"); Pipeline pipe = jedis.pipelined(); for (int i = 0; i &lt;50000; i++) { pipe.set("key_"+String.valueOf(i),String.valueOf(i)); } // 将封装后一次性发给redis pipe.sync(); 数据格式 Redis 客户端与服务器交互采用序列化协议（RESP）。
请求以字符串的形式来表示要执行的命令的参数
Redis使用特有的数据类型作为回复。
客户端与服务端通过TCP连接来进行数据交互，服务端口号为：6379客户端与服务端发送的命令和数据一律以 \r\n（CRLF）结尾所有参数都是二进制安全（binary safe） 内联格式 可以使用 telnet 工具进行测试，发送一些内容过去
telnet h121.wzk.icu 6379 xxx xxx xxx 处理流程 处理流程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f045324d37361758514fb38a3fbee67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4272bd02a2557bcddf68852b4952af62/" rel="bookmark">
			【初阶数据结构】打破递归束缚：掌握非递归版快速排序与归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初阶数据结构相关知识点可以通过点击以下链接进行学习一起加油！时间与空间复杂度的深度剖析深入解析顺序表:探索底层逻辑深入解析单链表:探索底层逻辑深入解析带头双向循环链表:探索底层逻辑深入解析栈:探索底层逻辑深入解析队列:探索底层逻辑深入解析循环队列:探索底层逻辑树与二叉树：从零开始的奇幻之旅理解堆的特性与应用：深入探索完全二叉树的独特魅力深度解析七大常见排序：掌握底层逻辑与原理 本章将单独分享关于非递归实现快排和归并排序，可以帮助我们更好地理解递归和熟悉使用数据结构。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、非递归实现快速排序二、非递归实现归并排序 一、非递归实现快速排序 void QuickSortNonR(int* a, int begin, int end) { ST s; STInit(&amp;s); STPush(&amp;s, end); STPush(&amp;s, begin); while (!STEmpty(&amp;s)) { int left = STTOP(&amp;s);//先拿出来 STPop(&amp;s); int right= STTOP(&amp;s);//后拿出来 STPop(&amp;s); //单躺排序，一次调整，得到中间keyi值，划分填入 int keyi = PartSort2(a, left, right);	//[left,keyi-1]keyi[keyi+1,right] if (left &lt; keyi - 1) { STPush(&amp;s, keyi - 1); STPush(&amp;s, left); } if (keyi + 1 &lt; right) { STPush(&amp;s, right); STPush(&amp;s, keyi+1); } } STDestroy(&amp;s); } 过程解析:非递归实现快速排序也是需要通过快速排序思想来走的，基本思想是以某数值为基准值，不断将待排序集合分割成两组子序列，采用前序遍历的方法根 左子树 右子树，对于递归的过程中我们知道左子树会演变为新的根，也会分为新根 新左子树 新右子树，然后我们将采用栈来模拟递归的过程，由于栈的特点是后进先出合前序遍历的特性。这里后进代表着左子树，新出代表着该左子树为根演变新左子树和新右子树的过程。然后这里需要范围去定义根(整体范围)、左子树（左边范围）、右子树（右边范围）。这里左子树会不断分为新的左子树和右子树，也意味着产生新的范围，一般来说先取左边(在上)再取右边(在下)，对应着右边先压栈，左边再压栈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4272bd02a2557bcddf68852b4952af62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282e96b84a0b482f61727e026a3e6e3a/" rel="bookmark">
			【C&#43;&#43;】string类（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页~
string类（上）
string类 二、模拟实现string类1、头文件string.h2、常见构造3、容量函数4、访问及遍历5、类对象修改6、流插入流提取重载 二、模拟实现string类 今天我们来实现一下上篇文章中详细介绍过的接口
1、头文件string.h #pragma once #include &lt;iostream&gt; #include &lt;assert.h&gt; //const和非const迭代器 typedef char* iterator; typedef const char* const_iterator; namespace little_monster { class string { public: //重载流输入流提取操作符 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const string&amp; s) { for (auto ch : s) { out &lt;&lt; ch; }//范围for一个一个读取 return out; } friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, string&amp; s) { s.clear();//清理掉原来的资源 char buff[129]; size_t i = 0; char ch; ch = in.get();//获取第一个字符 while (ch !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/282e96b84a0b482f61727e026a3e6e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08f34a21a7962de1e78b91ff490ae11/" rel="bookmark">
			基于PaddleClas的人物年龄分类项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、任务概述
二、算法研发
2.1 下载数据集
2.2 数据集预处理
2.3 安装PaddleClas套件
2.4 算法训练
2.5 静态图导出
2.6 静态图推理
三、小结
一、任务概述 最近遇到个需求，需要将图像中的人物区分为成人和小孩，这是一个典型的二分类问题，打算采用飞桨的图像分类套件PaddleClas来完成算法研发。本文记录相关流程。
二、算法研发 2.1 下载数据集 本文采用MaGaAge_Asian数据集，该数据集主要由亚洲人图片组成，训练集包含40000张图像，验证集包含3495张图像，每张图像都有对应的年龄真值，所有图像均处理成了统一的大小，宽178像素，高218像素。
数据集地址下载链接。数据集部分示例如下图所示：
该数据集本意是用来做年龄预测的，属于一个数值回归任务，本文将其变成二分类任务，以13岁年龄为界限，小于该年龄的属于小孩，大于该年龄的属于成人。这里之所以选择13岁，因为这个任务是需要筛选出长得很“像”小孩的小孩，13岁以上的青少年很多本身已经长的像成人了，因此，选择13岁作为分界线。
下面首先对该数据集进行处理。
2.2 数据集预处理 MaGaAge_Asian数据集每张图片对应的人物年龄存放在list文件夹的两个文件中，其中train_age.txt存放训练集对应的年龄真值，test_age.txt存放验证集对应的年龄真值。下面要写一个脚本，将所有小于13岁的图片移动到一个文件夹内，所有大于等于13岁的图片移动到另一个文件夹内。
#!/usr/bin/env python # -*- encoding: utf-8 -*- ''' @文件 :split_asian.py @说明 :拆分megaage_asian数据集，将小于13岁的移动到一个文件夹，大于等于13岁的移动到另一个文件夹 @时间 :2024/07/16 09:11:16 @作者 :Bin Qian @版本 :1.0 ''' import os import cv2 thr = 13 # 年龄阈值 # 读取年龄列表 agefile = 'megaage_asian/list/test_age.txt' f=open(agefile) ageLst = f.read().splitlines() f.close() # 读取图像 imgFolder = 'megaage_asian/val' imgnames = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08f34a21a7962de1e78b91ff490ae11/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/112/">«</a>
	<span class="pagination__item pagination__item--current">113/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/114/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>