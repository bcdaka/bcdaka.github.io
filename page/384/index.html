<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2931f6e8a274d317866f42ba2680e1dd/" rel="bookmark">
			修复 Android 卡在 Fastboot 模式的 6 种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fastboot模式用于快速更新手机的硬件和软件，而无需进入恢复模式。但有时，您的手机可能会陷入此模式，并且您无法通过某些常规操作退出快速启动模式。您可能担心您的手机不再工作。这时，你很幸运能读到这篇文章，它会告诉你如何修复Android卡在fastboot模式。并且有 6 个选项供您选择。
选项 1：重新启动 Android 手机 您应该做的第一件事是重新启动手机。这是帮助您摆脱快速启动模式的最有效且最简单的方法。而且这种方式不会删除你手机的数据。一般安卓手机可以通过长按“电源”键完成重启。但三星手机需要同时按住“电源”和“音量减小”按钮才能重新启动。
选项 2：取出并重新插入电池 如果您的手机卡在快速启动模式并且具有可拆卸电池，则直接的方法是取出电池并重新插入。首先，打开手机后盖。接下来，取出电池并静置约 30 秒。然后重新插入电池并安装保护盖。现在您可以启动手机了。
选项 3：将电池耗尽 但如果您使用的手机电池不可拆卸，该怎么办？现在，我将为您提供一个解决方案，让您的电池耗尽。并且您的手机将自动关闭。然后，让手机充电一段时间。最后，启动手机检查手机是否退出fastboot模式。
选项 4：使用 ADB 和 Fastboot 工具 使用第三方 ADB 和 Fastboot Tool 也是一个很好的方法，请按照以下步骤操作。
步骤 1：请在您的电脑上下载并安装“ADB and Fastboot Tool”。
步骤 2：找到安装目录，进入ADB文件夹。
步骤 3：长按“Shift”键，在ADB文件夹的空白区域单击鼠标右键。然后，选择“在此处打开命令窗口”选项。
步骤 4：使用USB线将陷入fastboot模式的Android设备与PC连接。
步骤 5：在命令窗口中输入命令“fastboot devices”，然后单击键盘上的“Enter”按钮。
步骤 6：找到您的设备。然后，键入命令“fastboot restart”并按“Enter”。
选项 5：使用 Android 多功能工具 为了解决Android手机卡在fastboot模式的麻烦，我们可以尝试使用Android Multi Tools。它对于所有类型的用户来说都是一个有用的工具。您可以参考以下步骤。
步骤1：下载Android Multi Tools并将其安装在PC上。
步骤 2：通过 USB 数据线将 Android 手机连接至电脑。
步骤3：然后，找到Android Multi Tools文件并运行它。现在屏幕上将显示命令提示符窗口。
步骤4：根据需要按任意数字，我们将按数字9“退出Fastboot模式”以退出fastboot模式并重置我们的设备。
当然，您必须小心不要按错号码，因为这会导致可怕的结果。例如，错误选择数字5或8将删除手机的所有数据。
选项 6：使用苹果手机系统修复 如果以上五种方法都无法帮助您摆脱fastboot模式，我们向您推荐一款非常棒且易于操作的软件，它的目标是修复 30 多种 Android 问题，包括陷入快速启动模式的 Android 问题。在您的 PC 上下载并安装苹果手机系统修复软件，然后按照以下步骤操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2931f6e8a274d317866f42ba2680e1dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73333557fa2307422c6c52f9d98a3bea/" rel="bookmark">
			【AIGC技术】探讨AIGC技术的发展现状和未来趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鱼弦：公众号【红尘灯塔】，CSDN博客专家、内容合伙人、新星导师、全栈领域优质创作者 、51CTO(Top红人+专家博主) 、github开源爱好者（go-zero源码二次开发、游戏后端架构 https://github.com/Peakchen）
AIGC技术：现状、趋势与展望 简介
AIGC（人工智能生成内容）技术是指利用人工智能技术自动生成文本、图像、音频、视频等内容的技术。AIGC技术近年来发展迅速，在各个领域都有着广泛的应用前景。
原理详解
AIGC技术的原理是将图计算和人工智能算法相互融合。图计算使用图结构表示数据，并利用图算法进行数据分析和计算。人工智能算法则利用机器学习、深度学习和自然语言处理等技术来处理和分析数据。在AIGC技术中，图计算可以用于构建和分析关系网络，而人工智能算法可以应用于图上的节点和边的属性进行分析和预测。
应用场景解释
AIGC技术在各个领域都有广泛的应用场景。以下是一些常见的应用场景：
社交网络分析：AIGC技术可以用于分析社交网络中的用户关系、社群发现、信息传播等。金融风险管理：AIGC技术可以应用于金融领域的风险评估、信用评分、反欺诈和交易分析等。健康医疗领域：AIGC技术可以用于医疗数据分析、疾病预测、基因组学研究和药物研发等。智能推荐系统：AIGC技术可以应用于个性化推荐、广告定向和内容推荐等。 算法实现
AIGC技术的实现需要结合图计算和人工智能算法的具体技术和算法。图计算可以使用图数据库和图计算框架，如Neo4j、Apache Giraph和Apache GraphX等。人工智能算法可以使用机器学习和深度学习框架，如Scikit-learn、TensorFlow和PyTorch等。具体的算法实现取决于具体的应用场景和需求。
部署测试搭建实现
AIGC技术的部署和实现需要根据具体的情况进行搭建和测试。一般来说，需要进行以下步骤：
数据准备：收集和准备相关的数据，包括图数据和属性数据。数据预处理：对数据进行清洗、转换和特征提取等预处理操作。搭建图数据库：选择适当的图数据库，并根据数据建立图结构。算法实现：根据具体的需求和算法选择，实现相应的人工智能算法和图算法。模型训练和优化：使用训练数据对模型进行训练，并进行模型参数的优化和调整。部署和测试：将训练好的模型部署到生产环境中，并进行测试和性能评估。 1. 技术应用
AIGC技术在各个领域的应用情况可以概括如下：
媒体和娱乐：AIGC技术可以用于生成新闻文章、广告文案、影视作品、音乐作品等，提高内容创作效率和质量。教育：AIGC技术可以用于生成个性化的学习内容和教学资源，提高教学质量和学生学习效果。电商和零售：AIGC技术可以用于生成商品图片、视频和文案，提高商品推广效果和转化率。金融：AIGC技术可以用于生成金融报告、分析研报等，提高金融分析效率和准确性。医疗：AIGC技术可以用于生成医学影像分析报告、辅助医生诊断等，提高医疗效率和准确性。 AIGC技术在各个领域的应用，将对社会产生深远的影响。例如，AIGC技术可以降低内容创作成本，提高内容质量，促进内容产业的繁荣发展；AIGC技术可以提供个性化的学习内容和教学资源，提高教育质量和学生学习效果；AIGC技术可以提高商品推广效果和转化率，促进电商和零售行业的增长；AIGC技术可以提高金融分析效率和准确性，促进金融行业的健康发展；AIGC技术可以提高医疗效率和准确性，促进医疗水平的提高。
2. 伦理与风险
AIGC技术的发展也带来了一些伦理和风险问题，例如：
内容真实性问题：AIGC技术生成的文本、图像、音频、视频等内容，可能存在虚假、误导性信息。版权问题：AIGC技术生成的文本、图像、音频、视频等内容，可能侵犯他人的版权。伦理偏见问题：AIGC技术生成的文本、图像、音频、视频等内容，可能存在伦理偏见，例如种族歧视、性别歧视等。 为了应对这些伦理和风险问题，需要采取以下措施：
建立健全的AIGC技术伦理规范：制定有关AIGC技术开发、应用和管理的伦理规范，明确AIGC技术开发和应用的边界和底线。加强AIGC技术监管：建立健全的AIGC技术监管体系，对AIGC技术平台和应用进行监管，防止AIGC技术被滥用。提高公众对AIGC技术的认知：加强对公众的AIGC技术教育，提高公众对AIGC技术的认识，帮助公众识别和抵御AIGC技术带来的风险。 3. 未来展望
AIGC技术是人工智能领域发展的重要趋势之一。未来，AIGC技术将继续发展，其应用范围也将更加广泛。AIGC技术将对社会产生更加深远的影响，并将对个人和社会带来新的挑战和机遇。
以下是一些AIGC技术未来发展的潜在可能性：
AIGC技术可以生成更加逼真、更加人性化的内容，为人们提供更加身临其境、更加沉浸式的体验。AIGC技术可以与其他人工智能技术结合，例如机器学习、自然语言处理等，实现更加智能化的内容创作和应用。AIGC技术可以推动内容产业的变革，促进内容创作的民主化和去中心化。 AIGC技术的发展，将对个人和社会带来新的挑战和机遇。个人需要不断学习新知识、提升自身技能，以适应AIGC技术带来的变化。社会需要加强对AIGC技术的监管，防止AIGC技术被滥用，并引导AIGC技术朝着健康的方向发展。
总结
AIGC技术是一项具有巨大潜力的技术，它将对社会产生深远的影响。我们需要积极关注AIGC技术的发展，并采取措施应对AIGC技术带来的伦理和风险问题，推动AIGC技术朝着健康的方向发展，为个人和社会带来更大的福祉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5e5fc1ce7056a5c235c04f92452bf1/" rel="bookmark">
			2024年大数据最全java程序员的AI之路-大数据篇 hadoop安装(1)，已有千人收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
需要这份系统化资料的朋友，可以戳这里获取
查看该目录下是否存在ifcfg-enoXXX的文件，使用vi编辑（刚安装的虚机只有vi），按照下图进行修改。之后按esc 然后wq！保存退出。
在执行service network restart命令重启网络服务。
之后网络应该就配置完毕。然后就可以使用 yum insatll 开始安装自己喜欢的软件把。（在现在这家公司已经练就了一身运维的功夫，真心感觉linux是好用啊）
三、安装jdk
1、Jdk安装很简单，将安装包放到指定目录解压。我是安装在/usr/etc/目录下面
2、设置环境变量，vim /etc/profile
在最后添加下面几行，根据java的安装目录。
JAVA_HOME=/usr/etc/jdk1.8.0_151
CLASSPATH=$JAVA_HOME/lib/
PATH= P A T H : PATH: PATH:JAVA_HOME/bin
export PATH JAVA_HOME CLASSPATH
3、验证环境变量，输入java -version ,如果出现以下内容说明安装成功
四、设置ssh免密登录
集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。
利用 ssh-keygen 生成密钥，并将密钥加入到授权中：
1. cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost
2. ssh-keygen -t rsa # 会有提示，都按回车就可以
3. cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权
Shell 命令
~的含义
在 Linux 系统中，~ 代表的是用户的主文件夹，即 “/home/用户名” 这个目录，如你的用户名为 hadoop，则 ~ 就代表 “/home/hadoop/”。 此外，命令中的 # 后面的文字是注释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b5e5fc1ce7056a5c235c04f92452bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc8c4f3b25c11d4dab1d28c216a9ae85/" rel="bookmark">
			Spark编程基础（Python版）实验三RDD编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、实验环境二、实验流程 一、实验环境 Ubuntu18.04
Spark 2.4.0
Python 3.6.5
二、实验流程 1.PySpark交互式编程 在 spark下创建文件夹sparksqldata，将data01.txt上传到sparksqldata下：
cd /usr/local/spark mkdir sparksqldata cd /bin ./pyspark （1）统计学生人数（即文件的行数）
lines = sc.textFile("file:///usr/local/spark/sparksqldata/Data01.txt") res = lines.map(lambda x:x.split(",")).map(lambda x: x[0]) //获取每行数据的第1列 distinct_res = res.distinct() //去重操作 distinct_res.count()//取元素总个数 (2)统计开设课程总数
lines = sc.textFile("file:///usr/local/spark/sparksqldata/data01.txt") df = lines.map(lambda x:x.split(",")).map(lambda x:x[1]) df1 = df.distinct() df1.count() （3）计算Tom所有课程的平均分
lines = sc.textFile("file:///usr/local/spark/sparksqldata/data01.txt") res = lines.map(lambda x:x.split(",")).filter(lambda x:x[0]=="Tom") res.foreach(print) score = res.map(lambda x:int(x[2])) num = res.count() sum_score = score.reduce(lambda x,y:x+y) avg = sum_score/num print(avg) （4）计算每一个人的选课总数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc8c4f3b25c11d4dab1d28c216a9ae85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5431d1017427302552ae2625026b758c/" rel="bookmark">
			AI智能体｜使用扣子Coze创建AI绘画工作流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是无界生长。
关注微信公众号：无界生长，后台发送暗号“C001”加入组织
今天分享下如何使用Coze（扣子）创建AI绘画工作流，为后续通过Coze创建AI绘画助手做铺垫，学会了的话，欢迎分享转发！
插件介绍 扣子Coze平台集成了超过60种类型的插件，其中包含了AI绘画相关的插件。我们这里使用通义万相这个插件的文生图工具，通过文字描述生成图像。如果你认为通义万相不满足需求，可以尝试使用官方集成的其他绘画插件，或者开发自定义的绘画插件。
输入参数 参数名参数类型参数说明ninteger生成几张图片，默认一张promptstring用户关于图片的描述sizeinteger0:10241024, 1:7201280, 2:1280*720styleinteger0:默认风格, 1:3D卡通, 2:动画, 3:油画, 4:水彩, 5:素描, 6:中国画, 7:扁平插画 返回结果 创建工作流 登陆Coze国内版官网：Coze ，点击“创建工作流”。
填写工作流的名称和描述。
进入工作流编辑页面，默认只有“开始”和“结束”节点，可以在“开始”和“结束”节点之间添加“基础节点”、“插件”、和“工作流”。
配置工作流 “开始”节点：接收大模型从用户输入内容中解析出的参数“文生图”节点：从“开始”节点接收输入参数，生成图片，返回结果“选择器”节点：对“文生图”节点的返回结果做条件判断，如果图片生成成功，走到“图片生成成功”节点，否则走到“图片生成失败”节点“图片生成成功”节点：打印信息，输出“文生图”节点的返回结果中的image_urls内容“图片生成失败”节点：打印信息，输出“文生图”节点的返回结果中的log_id、msg、code内容“结束”节点：生成最终结果，返回变量，由Bot生成回答 试运行工作流 点击右上角的试运行按钮，填写参数，检查工作流运行结果是否符合预期
如果需要反复输入相同参数测试工作流，可以勾选“运行后自动将此数据保存为测试集”，填写测试集名称和描述即可。
发布工作流 试运行工作流通过后，点击右上角的“发布”按钮。（发布工作流必须要试运行通过，否则不允许发布）
发布成功后，可以在工作流界面看到我们制作好的AI绘画工作流了
总结 本文详细的介绍了如何使用通义万相的文生图工具制作AI绘画工作流，并对工作流进行测试和发布。上述工作流通过Coze Bot 发布到了Bot商店，想体验绘画助手可以在Coze或者豆包搜索：无界生长的绘画助手。如果看完还没学会的话，可以私信我。学会了的话，欢迎转发分享给你的朋友们。
我是无界生长，如果你觉得我分享的内容对你有帮助，麻烦点个关注，带你一起玩转AI！
AI学习资料在微信公众号：无界生长，个人微信：wjsz2070
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2ad5400ef40791f1a0dbad98b7ad1e/" rel="bookmark">
			[Collection与数据结构] 七大排序算法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌸个人主页:https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343
🏵️热门专栏:🍕 Collection与数据结构 (90平均质量分)https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482
🧀Java EE(93平均质量分) https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482
🍭MySql数据库(93平均质量分)https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482
感谢点赞与关注~~~
1.概述 1.1 概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
1.2 常见应用 高校排行
商品排序
2. 常见排序 2.1 直接插入排序 从序列的第二个位置开始为基准,把前面的一个元素依次与下一个元素比较,前一个元素大于后一个元素(升序),则交换,如果碰到小于的,则证明前几个元素已经有序了,因为是从第二个元素开始进行插入排序的,直接break掉.
动态演示:
/** * 插入排序 * @param array 传入的数组 */ public static void insertSort(int[] array){ for (int i = 1; i &lt; array.length; i++) {//基准从1开始 for (int j = i-1; j &gt;= 0; j--) { if (array[j] &gt; array[j+1]){//把前面的元素依次比较 swap(j,j+1,array); }else { break;//遇到不符合条件的直接break } } } } private static void swap(int a,int b,int[] array){ int tmp = array[a]; array[a] = array[b]; array[b] = tmp; } 特性总结:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d2ad5400ef40791f1a0dbad98b7ad1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115188cf85171bc7f02e36ae059fc801/" rel="bookmark">
			Java高阶私房菜：JVM性能优化案例及讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
核心思想
优化思考方向
压测环境准备
堆大小配置调优
调优前
调优后
分析结论
垃圾收集器配置调优
调优前
调优后
分析结论
JVM性能优化是一项复杂且耗时的工作，该环节没办法一蹴而就，它需要耐心雕琢，逐步优化至理想状态。“性能调优” 该词是那么的高大上，但其实工作中因投入产出比（ROI）的关系，我们经常不会过多投入到这个工作中，而是更多投入到其他ROI更高的环节上，或有金主爸爸的允许下直接升级设备/服务器的性能，那为什么我们还要大费周章的去讲JVM呢？因为JVM性能调优是性能提升的最后一步，当所有环节都无法加工优化时，就需要在这个环节操刀了，其次就是架不住面试馆的会问呀。
核心思想 任何java业务做性能优化，都需要掌握JVM内部的工作机制和应用程序的特性，当某个节点性能优化接近极致的时候，就需要从局部跳到宏观层面进行分析，考虑自己和团队的ROI。另外缺少业务场景的性能优化都是浮云。
当面试官问到如何开始JVM调优时，就不要直接的回答自己是怎么进行JVM调参的，而是先了解他的意图、基本信息，是否有其他方向优化的可能等等，才能将答案回答到面试官的点中去。
优化思考方向 JVM优化
监控JVM性能：对JVM的运行情况进行监控，以了解应用程序的瓶颈和性能瓶颈，可以使用JVM自带的工具，如jstat、jmap、jstack等，或者第三方工具，如VisualVM、JProfiler等。压测基准指标：对程序进行压测，得出接口对应的吞吐量、响应时间等。外部现象：对用户体验来说，就是响应速度，可以用压测工具jmeter进行压测得出相关性能指标；内部现象：分析GC情况，是JVM性能调优的重要因素，需要掌握GC的工作机制和GC日志的含义，可以使用JVM自带的GC日志或者第三方工具，如GCEasy等来分析GC情况，了解GC的频率、时间、内存占用等情况。调整JVM参数：通过调整堆大小、GC算法、线程池大小等参数来提高应用程序的性能。另外需要注意的点是不同的应用程序和环境可能需要不同的JVM参数配置，比如IO密集型和CPU密集型应用。 二次压测分析
通过调整jvm参数后，二次压测看性能指标提升还是下降。内部检测通过分析GC日志，看吞吐量，GC次数和停顿时间变化等。外部监测主要看接口对应的吞吐量、响应时间长短等。
其他优化方向
优化代码：通过避免不必要的对象创建、减少同步操作、使用缓存等方式来优化代码。但需注意的是代码优化应该遵循“先正确，再优化”的原则，不应该牺牲代码的可读性和可维护性
使用并发编程：使用多线程、线程池等方式来提高并发性能，比如调整线程池的队列长度，存活线程数量等，但需要注意的是并发编程需要考虑线程安全和锁竞争等问题，需要进行正确的设计和实现。
使用缓存：可以使用本地缓存、分布式缓存等方式来提高数据访问性能，但需要注意的是缓存需要考虑缓存一致性和缓存失效等问题，需要进行正确的设计和实现。
避免IO阻塞：使用异步IO、NIO等方式来提高IO性能，例如前面讲解的CompletableFuture异步任务编排，但需要注意的是IO编程需要考虑并发性和可靠性等问题，需要进行正确的设计和实现。
传送门：Java高阶私房菜：快速学会异步编程CompletableFuture-CSDN博客
分布式+集群技术：使用负载均衡+集群技术，提升单节点的处理能力
其他技术...
压测环境准备 测试程序准备
SpringBoot 编写的jar的程序，接口一个返回随机组成的100个以内的对象的list (使用JDK17)
相关代码
@RestController @RequestMapping("/api/product") public class ProductController { @RequestMapping("query") public Map&lt;String, Object&gt; query() throws InterruptedException { int num = (int) (Math.random() * 100) + 1; Byte[] bytes = new Byte[5 * 1024 * 1024]; List&lt;Product&gt; productList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) { Product product = new Product(); product.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/115188cf85171bc7f02e36ae059fc801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697fde1701ef3ea36852a889a8b83143/" rel="bookmark">
			深度学习环境完整安装(Python&#43;Pycharm&#43;Pytorch cpu版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里，我们将引导您逐步完成深度学习环境的完整安装，助您踏上从Python到PyTorch的探索之旅。通过本博客，您将轻松掌握如何设置Python环境、使用Pycharm进行开发以及安装Pytorch，成为一名具备完整深度学习环境的实践者。让我们一起开始吧！
文章目录（如果有会的可以略过）
一、Python安装
（一）Python下载
（二）Python安装
（三）Python验证
二、PyCharm安装
（一）PyCharm下载
（二）PyCharm安装
（三）PyCharm配置
三、PyTorch安装
（一）PyTorch安装
（二）PyTorch验证
四、深度学习案例：YOLOv5训练数据集、图像检测与识别
（一）YOLOv5下载及解压 （二）YOLOv5训练数据集
1.准备工作（新建文件夹）
（1）新建VOCData
（2）新建Annotation、images
2.使用labelImg标注图片
（1）安装labelImg
（2）使用labelImg
（3）相关问题 ①No module named 'sip'报错
②No module named 'libs.resources'报错
3.划分数据集及配置文件修改
（1）划分训练集、验证集及测试集
（2）xml格式转txt格式
（3）配置文件
4.模型训练
（1）开始训练
（2）训练过程
（3）训练时间
（4）相关问题
（5）检测效果
五、参考链接
一、Python安装 Python是一种流行的高级编程语言，以其易学易用、可读性强和强大的标准库而受到广泛欢迎。Python支持多种编程范式，包括面向对象、过程式和函数式编程，可以用于开发各种类型的应用程序。Python的简洁语法和动态类型系统使其成为快速原型开发和数据分析的理想选择。此外，Python还具有丰富的第三方库支持，可以轻松地与其他编程语言集成。无论您是初学者还是经验丰富的开发人员，Python都是一种功能强大且易于使用的编程语言。
（一）Python下载 Python官网，显示下面这个界面。
因为大家都是都是初级程序员，学习的环境都还是比较新手的windows系统，将鼠标光标移动到 Downloads ，点击Windows ，意思就是选择Python安装在你的电脑上的系统类型，之后显示下面这个界面。
看到这个界面有很多很多的版本，给大家简单介绍一下，这里的Latest Python 3 Release - Python 3.11.5，表明的意思是最新的Python3版本 3.11.5，如果大家说噢我就想要最新的，那就无脑冲这个版本！
点击链接之后，等待网页响应，滑到网页最下面，可以看到以下界面。
这里有很多个不同配置的Python安装包，博主这边主要给大家介绍自动安装的安装包。
点击 Windows installer (64-bit) ，就可以下载Python3 3.11.5版本的安装包。
因为这是在Python官网加载的链接并下载，下载速度会比较慢，大家也可以点击我这里的链接去下载。有网盘链接和迅雷种子文件。
初次之外，博主个人还建议使用Python3 3.8.10版本，这个版本相对其他版本来说比较稳定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/697fde1701ef3ea36852a889a8b83143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc26c6316e3f49c42f9bec81aa6baa5/" rel="bookmark">
			ROS2高效学习第十章 -- ros2 高级组件其四之 webots
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ros2 高级组件其四之 webots 1 前言和资料2 正文2.1 webots 引入和学习资料2.2 webots 安装以及样例测试2.3 自编写 webots_demo 3 总结 1 前言和资料 当前，在机器人仿真领域，有两大产品比较突出，一是来自 ros 社区的 gazebo，二是从商业转向开源的 webots。通常情况下，ros 的学习者都会深入研究 gazebo，比如本人之前的 ROS高效进阶系列。但由于 webots 转向开源，加上 ros 的支持，影响力越来越大，ros2 humble 官方 Tutorials 也正式引入了 webots 的内容。
本文先介绍 webots 以及学习资料，然后安装并测试 webots，最后基于 ros2 humble 官方 Tutorials 中 webots 的内容，利用 webots 实现一个差速轮式机器人的运动仿真。
本文参考资料如下：
（1）Simulation-Webots
（2）其他资料见文章内容
2 正文 2.1 webots 引入和学习资料 （1）webots 引入：webots 是来自瑞士的 Cyberbotics 公司（Cyberbotics 官网）推出的机器人仿真软件，旨在降低机器人技术开发的门槛，并加速从理论到实践的转化过程。该平台用户群体非常广泛，涵盖了教育、科研和工业界。2018年以前，webots 是一款商业软件，2018年12月以后，Webots作为开放源码软件在Apache 2.0许可下发布（webots github）。
（2）gazebo 和 webots 的比较：这里我推荐两篇博客，大家大致了解下他们的异同即可。本文不建议读者在这里花费太多时间，适当了解后，尽快学习才是王道！
第一，ROS仿真平台总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fc26c6316e3f49c42f9bec81aa6baa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873ffe689f3cbf5634992ce495526c0d/" rel="bookmark">
			Java重点原理精炼(免费版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java重点原理精炼(免费版) 👏作者简介：大家好，我是 枫度柚子🍁，Java摆烂选手，很高兴认识大家 👀
📕B站: 枫吹过的柚 🍁
📕版本说明: 付费版本可以找UP主私聊，免费版本不再持续更新
🔥如果感觉博主的文章还不错的话，请👍三连支持👍一下博主哦
🛰微信群: 加微信 QaQ-linv
🐧QQ群: 995832569
🔑更新时间: 2024-03-08
目录 文章目录 Java重点原理精炼(免费版)目录简历JD参考Java基础面向过程与面向对象的区别什么是值传递和引用传递String为什么是不可变的String、StringBuilder、StringBuffer的区别深拷贝和浅拷贝equals和==的区别两个对象的hashcode相同，equals一定相同吗final、finally、finalize的区别 集合集合引入ArrayList和LinkedList的区别快速失败(fast fail)CopyOnWriteArrayList底层实现原理HashMap在JDK 7和JDK 8的区别HashMap的put流程HashMap的get流程HashMap的扩容流程ConcurrentHashMap在JDK 7和JDK 8的区别ConcurrentHashMap的put流程ConcurrentHashMap扩容机制ConcurrentHashMap的size方法 多线程多线程引入线程、进程、协程的区别线程的生命周期什么是上下文切换什么是并发线程安全问题run和start的区别线程常用方法什么是线程中断线程的创建方式有哪些为什么要使用线程池线程池的核心参数线程池的工作流程常见的阻塞队列线程池的类型有哪些线程池调优ThreadLocal实现原理 锁机制锁机制引入乐观锁和悲观锁的区别死锁、活锁、饥饿的区别Java死锁如何避免常见的原子类什么是CAS谈一下volatileMonitor机制管程是如何保证同步和互斥的管程中的Mesa模型和Hoare模型谈一下synchronizedsynchronized的锁变化synchronized锁粗化、锁消除什么是AQSJUC可重入锁ReentrantLockJUC共享锁SemaphoreJUC闭锁CountDownLatchJUC循环屏障CyclicBarrierJUC读写锁ReentrantReadWriteLock保证三个线程同时执行并发情况下三个线程依次执行三个线程有序交错执行两个线程交替打印奇偶数 JMM谈一下Java的共享内存模型JMM JVMJVM引入类加载器有哪些什么是双亲委派机制为什么要有双亲委派机制如何打破双亲委派机制Tomcat为什么要打破双亲委派机制JVM类加载过程JVM的重要组成部分和作用对象的创建过程什么是栈上分配垃圾收集算法有哪些什么是STW为什么要进行STW对象的分配策略如何判断对象是否存活/如何判断对象可以被回收什么情况下类会被卸载引用类型有哪几种常见的垃圾收集器JVM如何处理跨代引用JVM常用调参JVM故障分析Arthas常用指令内存溢出和内存泄露的区别常量池的分类类实例化的顺序 MySQLMySQL引入事务的四大特性(ACID)脏写、脏读、不可重复读、幻读事务的隔离级别常见的索引结构MySQL的索引数据结构为什么MySQL要用B+Tree而不用跳表聚簇索引和非聚簇索引InnoDB和MylSAM的区别为什么非主键索引的叶子节点的数据存储的是主键ID为什么建议InnoDB必须设置主键为什么推荐使用自增整型作为主键而不是UUIDMySQL的执行计划怎么看索引什么时候会失效索引优化原则SQL的执行流程MySQL的三个日志Undo的MVCC机制InnoDB的BufferPool缓存机制线上百万数据如何添加索引MySQL中的锁有哪些分库分表 OracleOracle的执行计划怎么看 RedisRedis的数据类型谈一下布隆过滤器Redis为什么这么快Redis为什么要引入多线程什么是IO多路复用Redis的Reactor模型Redis如何获取所有keyRedis持久化有哪几种方式Redis持久化方式如何选择Redis主从复制(同步)原理Redis怎么实现高可用哨兵选主过程Redis Cluster主从选举过程主从选举的脑裂问题缓存雪崩、缓存击穿、缓存穿透热点缓存并发重建数据库和缓存双写不一致Redis分布式锁实现过期键的删除策略内存淘汰策略有哪些 Netty同步和异步的区别阻塞和非阻塞的区别TCP粘包/拆包常见的IO模型Netty有哪些核心组件谈谈你对Netty中Pipeline工作原理理解Netty中提供了哪些线程模型Netty是如何实现零拷贝的 ZookeeperZookeeper的节点类型Zookeeper分布式锁实现Zookeeper的Watcher机制Zookeeper的leader选举过程Zookeeper主备之间的数据同步是同步还是异步的谈一下ZAB协议(原子广播协议)ZAB和Paxos算法的联系与区别 RabbitMQRabbitMQ引入RabbitMQ的工作队列模式RabbitMQ的死信队列和延迟队列RabbitMQ如何避免消息重复消费(RabbitMQ如何保证消息幂等性)RabbitMQ如何保证消息有序RabbitMQ如何处理消息堆积RabbitMQ如何保证消息不丢失RabbitMQ如何保证消息可靠性传输 KafkaKafka引入Kafka的设计Kafka高性能的原因(Kafka为什么这么快)Kafka主备之间采用的是同步复制还是异步复制Kafka的Broker持久化机制Kafka什么情况会丢消息Kafka生产端的发送模式Kafka消费端的消费模式Kafka的消费乱序Kafka副本Leader选举机制Kafka消费者的重平衡(Rebalance)机制分区故障恢复机制Kafka的消息幂等性3种语义的实现Kafka如何保证消息不丢失Kafka如何保证消息有序Kafka如何处理消息堆积谈谈对Kafka零拷贝的理解Kafka的延迟消息Kafka生产端发多条消息，一半成功一半失败怎么办Kafka的事务 RocketMQRocketMQ引入RocketMQ的设计RocketMQ为什么要放弃ZookeeperRocketMQ的消息模型谈谈你对RocketMQ分布式事务原理的理解RocketMQ生产端的发送模式RocketMQ消费端的消费模式RocketMQ的消息确认机制RocketMQ的持久化机制RocketMQ的过期文件删除机制RocketMQ的数据刷盘机制RocketMQ的主从复制原理RocketMQ如何保证消息不丢失NameServer挂了如何保证消息不丢失RocketMQ如何保证消息有序RocketMQ如何处理消息堆积谈谈对RocketMQ零拷贝的理解 Spring谈一下IOC谈一下AOPApplicationContext和BeanFactory的区别Spring启动流程Bean的生命周期Bean的作用域Bean如何保证线程安全循环依赖如何解决事务传播行为Spring如何处理事务谈一下Spring事务机制@Transactional事务失效Spring中的设计模式有哪些@Autowired和@Resource的区别 Spring MVCSpring MVC请求流程Spring和Spring MVC为什么需要父子容器是否可以把所有Bean都通过Spring容器来管理是否可以把我们所需的Bean都放入Spring MVC子容器里面来管理 Spring BootSpring Boot常用注解Spring Boot自动装配原理Jar启动流程如何自定义StarterSpringBoot是如何启动Tomcat的 Spring CloudCAP理论Base理论Spring Cloud核心组件以及作用Eureka的数据同步原理谈一下分布式事务谈谈对Seata的理解 场景题网络调用，串行是10s，修改为并行后能压缩到1s，此时CPU飙升，如何平衡这个点，线程池是怎么设置，qps高的情况下，线程数少就会导致排队出现io爆炸网站首页公告，假设公告id是连续，不间断的，要求使用Redis存储，并且根据评论的时间排序，而且还有分页的功能，请给出你的解决方式，从存储方式和查询方式分析，以及分页怎么获得总数据数，分页怎么分某个文章的评论，要求使用Redis存储，并且根据评论的时间排序，而且还有分页的功能，请给出你的解决方式，从存储方式和查询方式分析，以及分页怎么获得总数据数，分页怎么分 简历JD参考 深入理解volatile、synchronized、Lock、ConcurrentHashMap、线程池等并发编程技术；深入理解JVM、JMM，熟悉内存模型、类加载、垃圾收集器、GC算法等、具有生产JVM调优经验；熟练使用Redis，熟悉其数据类型、持久化、主从复制、集群、缓存一致性等，对分布式锁实现有一定的理解；熟练使用MySQL，熟悉底层数据结构、索引、事务、日志等，具有生产慢SQL调优经验；熟悉Zookeeper，熟悉节点类型、ZAB协议以及分布式锁实现等；熟悉Netty，对Rceator模型、零拷贝、粘/拆包具有一定的理解;熟练使用RabbitMQ、Kafka、RocketMQ，熟悉基础架构、副本同步机制、持久化机制、零拷贝以及常见问题解决方案；熟悉Spring，对IOC、AOP、Bean生命周期、循环依赖等；熟悉Spring Boot，对常用注解、自动装配原理、Jar启动流程、自定义Starter有一定的理解；熟练使用Spring Cloud，对常用组件、分布式事务具有一定的理解;熟悉常规的设计模式，熟悉责任链、工厂、策略等，具有项目落地实践经历; Java基础 面向过程与面向对象的区别 面向过程可以理解为按步骤处理问题面向对象可以理解为将具体事务存在的属性、行为抽象出来，然后去进行实现 什么是值传递和引用传递 值传递是对基本数据类型而言，只进行值的拷贝，不会影响原变量引用传递是对对象而言，不是传递对象的值，而是传递对象的地址，如果副本改变会影响到原对象 String为什么是不可变的 String内部维护的是private final char/byte数组，不可变线程安全 好处 防止被恶意篡改作为HashMap的key可以保证不可变性可以实现字符串常量池，在Java中，创建字符串对象的方式 通过字符串常量进行创建 在字符串常量池判断是否存在，如果存在就返回，不存在就在字符串常量池创建后返回 通过new字符串对象进行创建 在字符串常量池中判断是否存在，如果不存在就创建，再判断堆中是否存在，如果不存在就创建，然后返回该对象，总之要保证字符串常量池和堆中都有该对象 String、StringBuilder、StringBuffer的区别 String内部维护的是private final char/byte数组，不可变线程安全StringBuilder可变，线程不安全，可以使用append进行拼接字符串StringBuffer可变，通过synchronized来保证线程安全，操作和StringBuilder一样 synchronized对于出现在循环中会进行锁粗化，会将锁的范围扩展到整个操作，从而避免频繁进行锁操作造成性能开销 深拷贝和浅拷贝 浅拷贝就是副本对象和原对象都指向同一块内存空间，副本对象的改变会影响到原对象深拷贝就是副本对象和原对象不指向通一块内存空间，会重新开辟一块内存空间给副本对象进行指向 equals和==的区别 ==对于基本类型比较的是值，但是引用类型比较的是内存地址equals取决于子类是否重写，默认和==等价 两个对象的hashcode相同，equals一定相同吗 一般推荐重写equals方法的同时也要重写hashcode方法 两个对象的hashcode相同，equals可能相同两个对象equals相同，hashcode一定相同 final、finally、finalize的区别 final修饰的类不能被继承、属性是常量而且必须初始化、修饰的方法不能被重写finally用于异常处理，finally代码块中的内容一定会执行finalize是Object类的一个方法，当我们调用system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/873ffe689f3cbf5634992ce495526c0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa0b5e43fe702e01e1e12c7c2a5ecc6/" rel="bookmark">
			llama-factory SFT 系列教程 (四)，lora sft 微调后，使用vllm加速推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 文章列表：背景简介llama-factory vllm API 部署融合 lora 模型权重 vllm API 部署HuggingFace API 部署推理API 部署总结 vllm 不使用 API 部署，直接推理数据集 tenplatevllm 代码部署 文章列表： llama-factory SFT系列教程 (一)，大模型 API 部署与使用llama-factory SFT系列教程 (二)，大模型在自定义数据集 lora 训练与部署
llama-factory SFT系列教程 (三)，chatglm3-6B 命名实体识别实战
llama-factory SFT 系列教程 (四)，lora sft 微调后，使用vllm加速推理 背景 llama-factory 提供了 vllm API 部署，但笔者在测试时，发现部署的 vllm API 没有直接用vllm推理的速度快。
简介 首先使用 llama-factory 微调，得到微调后的 lora 权重；由于 vllm 并没有支持所有的模型；
故通用的方式是 将 lora 权重和大模型融合成新的大模型，再由 vllm 推理；
在使用 alpaca 样式的数据集微调时，llama-factory 框架在训练时，会自动在prompt 添加 template 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa0b5e43fe702e01e1e12c7c2a5ecc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61453c515101feecbfa69fe956fe271/" rel="bookmark">
			FloodFill-----洪水灌溉算法（DFS例题详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.图像渲染：
代码详解：
二.岛屿数量：
代码详解：
三.岛屿的最大面积：
代码详解：
四.被围绕的区域：
代码详解：
五.太平洋大西洋水流问题：
代码详解：
FloodFill算法简介：FloodFill（泛洪填充）算法是一种图像处理的基本算法，用于填充连通区域。该算法通常从一个种子点开始，沿着种子点的相邻像素进行填充，直到遇到边界或者其他指定的条件为止。FloodFill 算法的主要应用是在图像编辑软件中实现填充操作，以及在计算机图形学、计算机视觉等领域中进行区域填充。
下面我们通过一些题目来理解这个算法思想：
一.图像渲染： 题目链接：733. 图像渲染 - 力扣（LeetCode）题目描述： 有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。
你也被给予三个整数 sr , sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。
为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。
最后返回 经过上色渲染后的图像 。 ​
对应函数签名如下： 思路：我们从给定的起点开始，进行深度优先搜索（上下左右四个方向）。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。这里我们设置初始方格为target. 代码详解： 解法一：
class Solution { //记录走过的路径，防止走回头路 boolean[][] used; int target; public int[][] floodFill(int[][] image, int sr, int sc, int color) { int m = image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61453c515101feecbfa69fe956fe271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c70c2b9a0e985b0f068b4cad1eb6db2/" rel="bookmark">
			ZooKeeper以及DolphinScheduler的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、ZooKeeper的介绍
数据模型
​编辑 操作使用
①登录客户端
​编辑 ②可以查看下面节点有哪些
③创建新的节点，并指定数据
④查看节点内的数据
⑤、删除节点及数据
特殊点：
运行机制：
二、DolphinScheduler的介绍
架构：
架构说明
该服务内主要包含:
该服务包含：
DolphinScheduler的启动访问和简单运行
①启动该服务，要先启动ZooKeeper
​编辑 ②访问web页面
③安全中心
创建队列
添加租户
④项目管理
⑤数据中心
⑥资源中心
​编辑 ⑦监控中心
一、ZooKeeper的介绍 ZooKeeper是一个具有高可用性的高性能分布式协调服务。
最重要的功能：解决单点故障
官网 ZooKeeper: Because Coordinating Distributed Systems is a Zoo
数据模型 树状结构保存 _____
znode 根节点 节点名称：/ 下面的每一个节点名称：/+路径最多存储1MB 每一级加上面父节点的名称
zk可存储小文件数据，用来保存其他服务的信息，比如保存hdfs的namenode信息，ds的运行信息
ZooKeeper 维护着一个树形层次结构，树中的节点被称为 znode。znode 可以用于存储数据，并且有一个与之相关联的 ACL。ZooKeeper 被设计用来实现协调服务(这类服务通常使用小数据文件),而不是用于大容量数据存储，因此一个 znode 能存储的数据被限制在1MB以内
操作使用 ①登录客户端 /opt/cloudera/parcels/CDH-6.2.1-1.cdh6.2.1.p0.1425774/lib/zookeeper/bin/zkCli.sh
②可以查看下面节点有哪些 ③创建新的节点，并指定数据 create +节点（从根节点开始 ）+数据
例如：create /app 123 ④查看节点内的数据 get 节点名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c70c2b9a0e985b0f068b4cad1eb6db2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2977985b37155f85829c381cb4338f4/" rel="bookmark">
			本地部署大模型ollama&#43;docker&#43;open WebUI/Lobe Chat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 大模型工具Ollama下载安装运行Spring Ai 代码测试加依赖配置写代码 ollama的web&amp;Desktop搭建部署Open WebUI有两种方式Docker DesktopDocker部署Open WebUIDocker部署Lobe Chat可以配置OpenAI的key也可以配置ollama 大模型的选择 本篇基于windows环境下配置 大模型工具Ollama https://ollama.com/
下载 https://ollama.com/download
windows环境下就安装windows版本
安装 点击下载的exe文件进行傻瓜式安装
运行 去ollama官网（models模块下）找大模型的名字，然后复制ollama的运行名字
https://ollama.com/library
ollama run qwen:4b Spring Ai 代码测试 默认ollama会监听11434端口，可以使用下面命令查看
netstat -ano | findstr 11434 可以使用ollama list指令查看本地已经下好的大模型
ollama list 加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-ollama-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 或者使用23版以上的idea，创建spring项目的时候选最新版本，直接勾选上AI模块下的ollama模块
配置 spring: application: name: open-ai-05-ollama ai: ollama: base-url: http://localhost:11434 chat: options: model: qwen:4b 写代码 @RestController public class OllamaController { @Autowired private OllamaChatClient ollamaChatClient; @RequestMapping(value = "/ai/ollama") public Object ollama(@RequestParam(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2977985b37155f85829c381cb4338f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8f572462629265a78232d7206e93b9/" rel="bookmark">
			在windows 11本地搭建RAG数据查询的AI大模型环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，随着人工智能技术的快速发展，越来越多的研究人员和开发者开始关注如何构建强大的AI大模型环境，以支持各种复杂的自然语言处理任务。其中，基于检索-生成器（Retrieval-Augmented Generation，简称RAG）架构的数据查询模型备受关注，因为它能够结合从大规模文本语料库中检索信息和生成自然语言文本的能力，实现更加智能和准确的数据查询。
在本文中，我们将探讨如何在windows 11本地环境中搭建一个RAG数据查询的AI大模型环境。首先，我们需要准备以下工具和资源：
先看配置、无GPU：
CPU：i7 1360p，内存：16G，硬盘：500G
第一步：安装python环境 在 Windows 11 上安装 Python 环境的步骤和说明
以下是在 Windows 11 上安装 Python 环境的详细步骤和说明：
下载 Python 安装程序：首先，打开浏览器，访问 Python 官方网站（https://www.python.org/downloads/），在该页面上找到适用于 Windows 的3.11版本（版本过高会出现各种疑难杂症）的 Python 安装程序，并点击下载。
运行安装程序：下载完成后，双击运行 Python 安装程序。在安装向导中，确保勾选“Add Python x.x to PATH”选项（x.x 表示 Python 的版本号），然后点击“Install Now”按钮。
安装 Python：安装程序将开始安装 Python，等待安装完成。
验证安装：安装完成后，可以在命令提示符或 PowerShell 中输入以下命令来验证 Python 是否成功安装：
python --version 安装 pip：pip 是 Python 的包管理工具，通常与 Python 一起安装。可以在命令提示符或 PowerShell 中输入以下命令来验证 pip 是否成功安装：
pip --version 使用 Python：现在，您可以在命令提示符或 PowerShell 中输入“python”来启动 Python 解释器，并开始编写和运行 Python 代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f8f572462629265a78232d7206e93b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e901d8ef0fa0514f9b52580387f3153/" rel="bookmark">
			[嵌入式AI从0开始到入土]17_Ascend C算子开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[嵌入式AI从0开始到入土]嵌入式AI系列教程 注：等我摸完鱼再把链接补上
可以关注我的B站号工具人呵呵的个人空间，后期会考虑出视频教程，务必催更，以防我变身鸽王。
第1期 昇腾Altas 200 DK上手
第2期 下载昇腾案例并运行
第3期 官方模型适配工具使用
第4期 炼丹炉的搭建（基于Ubuntu23.04 Desktop）
第5期 炼丹炉的搭建（基于wsl2_Ubuntu22.04）
第6期 Ubuntu远程桌面配置
第7期 下载yolo源码及样例运行验证
第8期 在线Gpu环境训练（基于启智ai协作平台）
第9期 转化为昇腾支持的om离线模型
第10期 jupyter lab的使用
第11期 yolov5在昇腾上推理
第12期 yolov5在昇腾上应用
第13期_orangepi aipro开箱测评
第14期 orangepi_aipro小修补含yolov7多线程案例
第15期 orangepi_aipro欢迎界面、ATC bug修复、镜像导出备份
第16期 ffmpeg_ascend编译安装及性能测试
第17期 Ascend C算子开发
未完待续…
文章目录 [嵌入式AI从0开始到入土]嵌入式AI系列教程前言一、环境配置1、CANN包安装2、配置ssh密钥（可选）3、配置git（可选） 二、获取sample样例1、add算子1、KernelLaunch2、Framework3、AclNN 2、Addcdiv算子 三、编写自己的算子1、搭建框架2、 KernelLaunch编写1、myCustom.cpp2、main.cpp3、scripts/gen_data.py 3、 framework编写4、 Aclnn测试 四、torch_npu重新编译（可选）五、常用api问题1、fatal error: register/tilingdata_base.h: No such file or directory 总结 前言 我在24年3月和我的小伙伴一起参加了第一届昇腾AI原生创新精英挑战赛，在这里做一下总结。这里以orangepi Ai Pro为例。
注：我们的代码仓最早将于24.05.10开放，大家可以直接看op_kernel内的compute，kernelLaunch内可能有错，实在来不及改了
代码仓地址：https://gitee.com/toolsmanhehe/acl_ops
一、环境配置 我们基于正常能够使用的镜像作为基础镜像。这里我推荐使用minimal镜像。这样就不用先卸载cann了，甚至你可以直接删除/opt/compress目录，反正咱后面直接远程连接敲代码了，也用不上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e901d8ef0fa0514f9b52580387f3153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f207d1153801f70e174805aa146b94b/" rel="bookmark">
			C# 实现HTTP自承载WebApi服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 自承载服务（HTTP Self-Hosted Service）是一种不依赖于外部 Web 服务器（如 IIS、Apache、Nginx 等）的 HTTP 服务，它直接在自己的进程中监听 HTTP 请求并处理它们。这种服务通常由应用程序自己实现 HTTP 服务器功能，从而允许应用程序直接暴露 HTTP API 或提供 Web 内容。
HTTP 自承载服务在以下场景中特别有用：
小型应用或微服务：对于需要通过网络提供 API 的小型应用或微服务，自承载 HTTP 服务器是一个轻量级的解决方案，它不需要额外的 Web 服务器软件。
嵌入式系统：在嵌入式系统或物联网（IoT）设备中，自承载 HTTP 服务器可以方便地提供远程管理、监控或配置接口。
开发环境和测试：在开发过程中，开发人员可以使用自承载 HTTP 服务器快速搭建 API 原型或测试环境，而无需配置复杂的 Web 服务器。
跨平台兼容性：自承载 HTTP 服务器可以轻松地部署到各种操作系统和平台上，因为它们不依赖于特定的 Web 服务器软件。
在 .NET 框架中，HttpSelfHostServer 是实现 HTTP 自承载服务的一种方式，它属于 ASP.NET Web API 的一部分。通过创建 HttpSelfHostConfiguration 对象并配置路由，开发人员可以轻松地构建和启动自承载 HTTP 服务器。
虽然 HTTP 自承载服务提供了很多便利，但它们也可能不如成熟的 Web 服务器软件那样强大和可扩展。因此，在选择是否使用自承载服务时，需要根据具体的应用场景和需求进行评估。
using System; using System.Collections.Generic; using System.Web.Http; namespace SelfHostSample.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f207d1153801f70e174805aa146b94b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481193d9c73117c32365e79652378b5b/" rel="bookmark">
			C&#43;&#43;必修：类与对象(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：C++学习
贝蒂的主页：Betty’s blog
1. 隐式类型转换 在学习C语言时我们就明白，当我们进行赋值时，如果赋值两边的类型不同时就可能发生隐式类型转换。
1.1. 内置类型 在发生隐式类型转换时，如果都是内置类型就会先开辟一个临时变量，再将右操作数强制类型转换为左操作数的类型，最后用这个临时变量对左操作数进行赋值。注意：这个临时变量具有常性，不可修改。
int main() { double j = 1.1; int i = j;//隐式类型转换 int&amp; a = j;//error const int&amp; b = j;//ok return 0; } 因为临时变量具有常性，所以无法被修改。如果赋值给普通引用就会造成权限的放大，所以只能用常引用。
1.2. 自定义类型 如果将一个内置赋值给自定义类型，那么编译器也会先创造一个自定义类型的**临时变量，**然后用这个内置类型调用构造函数对临时变量初始化，最后用这个临时变量对左操作数进行拷贝构造。。注意：这个临时变量也具有常性，不可修改。
class Date { public: Date(int year = 1, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } Date(const Date&amp; d) { _year = d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481193d9c73117c32365e79652378b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5274d5c8cab1ba8bb171671a716bbc05/" rel="bookmark">
			Llama改进之——SwiGLU激活函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 今天介绍LLAMA模型引入的关于激活函数的改进——SwiGLU1，该激活函数取得了不错的效果，得到了广泛地应用。
SwiGLU是GLU的一种变体，其中包含了GLU和Swish激活函数。
GLU GLU(Gated Linear Units,门控线性单元)2引入了两个不同的线性层，其中一个首先经过sigmoid函数，其结果将和另一个线性层的输出进行逐元素相乘作为最终的输出：
GLU ( x , W , V , b , c ) = σ ( x W + b ) ⊗ ( x V + c ) (1) \text{GLU}(x,W,V,b,c) = \sigma(xW+b) \otimes (xV+c) \tag 1 GLU(x,W,V,b,c)=σ(xW+b)⊗(xV+c)(1)
这里 W , V W,V W,V以及 b , c b,c b,c分别是这两个线性层的参数； σ ( x W + b ) \sigma(xW+b) σ(xW+b)作为门控，控制 x V + c xV+c xV+c的输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5274d5c8cab1ba8bb171671a716bbc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056e1a363d342a9a3b45b9cf408bd3e7/" rel="bookmark">
			【动态规划】路径问题|不同路径I|不同路径II|珠宝的最高价值|下降路径的最小和|最小路径和|
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、不同路径I 62. 不同路径 - 力扣（LeetCode）
💡细节：
1.多开一行和一列（跟一维数组多开一个位置一样），这样方便初始化
2.状态转移方程：注意走一步并不是多一种走的路径，从i-1，j这个位置向下到i，j这个位置走一步，得出dp[i][j]为原来dp[i-1][j]条路径，而不是+1
3.初始化的时候得保证后面的结果是正确的：dp[0][1]=1或者dp[1][0]=1
代码： class Solution { public int uniquePaths(int m, int n) { //细节1.多开一个行和一列：方便初始化 int[][] dp = new int[m+1][n+1];//dp[i][j]:到i,j位置有多少条路径 dp[0][1] = 1;//或者dp[1][0]=1 for (int i = 1; i &lt;=m; i++) { for (int j = 1; j &lt;=n ; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m][n]; } } 二、不同路径II 63. 不同路径 II - 力扣（LeetCode）
💡 细节：没有障碍物就正常相加，有障碍物那么dp[i][j]就为0，就不用管了
class Solution { public int uniquePathsWithObstacles(int[][] ob) { int m = ob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/056e1a363d342a9a3b45b9cf408bd3e7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/383/">«</a>
	<span class="pagination__item pagination__item--current">384/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/385/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>