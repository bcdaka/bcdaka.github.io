<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e107d94532138d177bcdd1e46554ae27/" rel="bookmark">
			【Rust】——高级trait
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💻博主现有专栏：
C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯关联类型在trait定义中指定占位符类型
🎯默认泛型类型参数和运算符重载
🎯完全限定语法与消歧义:调用相同名称的方法
🎯完全限定语法与消歧义：调用相同名称的方法
🎯父trait用于在另一个trait中使用trait的功能
🎯newtype模式用以在外部类型上实现外部trait
🎯关联类型在trait定义中指定占位符类型 关联类型（associated types）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。trait 的实现者会针对特定的实现在这个占位符类型指定相应的具体类型。如此可以定义一个使用多种类型的 trait，直到实现此 trait 时都无需知道这些类型具体是什么。
关联类型则比较适中；它们比本书其他的内容要少见，不过比本章中的很多内容要更常见。
一个带有关联类型的 trait 的例子是标准库提供的 Iterator trait。它有一个叫做 Item 的关联类型来替代遍历的值的类型。
pub trait Iterator { type Item; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; } Item 是一个占位符类型，同时 next 方法定义表明它返回 Option&lt;Self::Item&gt; 类型的值。这个 trait 的实现者会指定 Item 的具体类型，然而不管实现者指定何种类型，next 方法都会返回一个包含了此具体类型值的 Option。
关联类型看起来像一个类似泛型的概念，因为它允许定义一个函数而不指定其可以处理的类型。让我们通过在一个 Counter 结构体上实现 Iterator trait 的例子来检视其中的区别。
impl Iterator for Counter { type Item = u32; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { // --snip-- pub trait Iterator&lt;T&gt; { fn next(&amp;mut self) -&gt; Option&lt;T&gt;; } 区别在于当如示例 19-13 那样使用泛型时，则不得不在每一个实现中标注类型。这是因为我们也可以实现为 Iterator&lt;String&gt; for Counter，或任何其他类型，这样就可以有多个 Counter 的 Iterator 的实现。换句话说，当 trait 有泛型参数时，可以多次实现这个 trait，每次需改变泛型参数的具体类型。接着当使用 Counter 的 next 方法时，必须提供类型注解来表明希望使用 Iterator 的哪一个实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e107d94532138d177bcdd1e46554ae27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce6033dfafee8ee496c15186e20b200/" rel="bookmark">
			大数据-88 Spark 集群 案例学习 Spark Scala 案例 SuperWordCount 计算结果数据写入MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（已更完）Spark（正在更新！） 章节内容 上节完成的内容如下：
Spark案例编写 Scala计算圆周率找共同的好友 Super Word Count 需求背景 给定一段文本将单词全部转换为小写去除标点符号去除停用词count值降序保存结果保存到MySQL额外要求：标点符合和停用词可以自定义 编写代码 先实现到MySQL保存前的内容，我们需要先编写测试一下我们的代码是否正确
package icu.wzk import org.apache.spark.rdd.RDD import org.apache.spark.{SparkConf, SparkContext} object SuperWordCount1 { private val stopWords = "in on to from by a an the is are were was i we you your he his".split("\\s+") private val punctuation = "[\\)\\.,:;'!\\?]" def main(args: Array[String]): Unit = { val conf = new SparkConf() .setAppName("ScalaSuperWordCount1") .setMaster("local[*]") val sc = new SparkContext(conf) sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ce6033dfafee8ee496c15186e20b200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a481069a09456441a3a19c1f55512c84/" rel="bookmark">
			Asp.net 6 使用Nacos 培训文稿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Nacos Nacos 是阿里巴巴开源的一款动态服务发现、配置管理和服务管理平台。它主要用于帮助构建云原生应用。以下是 Nacos 的一些主要功能：
服务发现与服务健康监测：Nacos 提供了动态服务发现的功能，服务可以在 Nacos 上注册和发现，通过 Nacos 注册中心，服务实例可以动态注册和注销，客户端也可以实时感知到服务实例的变化。同时，Nacos 提供了健康检查机制，确保服务的可用性。服务配置管理：Nacos 提供了一个集中化的配置管理平台，支持动态配置更新。开发者可以在 Nacos 上管理应用的配置，通过 Nacos 提供的 API，可以动态地获取和更新配置，确保配置的实时性和一致性。动态 DNS 服务：Nacos 提供了动态 DNS 功能，支持通过 DNS 协议查询服务地址。这样，客户端可以通过简单的 DNS 查询获取服务实例的 IP 地址。服务管理：Nacos 提供了服务的管理功能，包括服务的权重调整、路由规则、流量控制等，帮助开发者更加灵活地管理和调度服务流量。 Nacos 支持的主要功能和特性：
• 多种服务注册与发现协议：支持 HTTP、DNS、gRPC 等多种协议的服务注册与发现。
• 灵活的配置管理：支持命名空间、配置分组、配置历史版本管理等高级配置管理功能。
• 易用的管理界面：提供了友好的 Web 管理界面，方便用户对服务和配置进行管理和监控。
• 高可用和高扩展性：支持集群部署，提供高可用性和高扩展性，能够满足大规模分布式系统的需求。
Nacos 通常被用于微服务架构中，帮助解决服务间通信、配置管理和服务治理等问题，是云原生应用开发的重要工具之一。
集成 Nacos 在项目中安装Nacos Nuget 包：
dotnet add package nacos-sdk-csharp nacos 的AspNetCore 扩展包 dotnet add package nacos-sdk-csharp.AspNetCore nacos 的配置扩展包，不需要统一配置管理可以不安装 dotnet add package nacos-sdk-csharp.Extensions.Configuration 解析yaml文件用的，不需要可以不安装 dotnet add package nacos-sdk-csharp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a481069a09456441a3a19c1f55512c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9c236ea33398da243eddd41fe6c2a7/" rel="bookmark">
			【python】python代码打包工具cx_Freeze的介绍、原理、用法及实战案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，PyQt5和Tkinter桌面开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，云原生K8S，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：python综合应用，基础语法到高阶实战教学
景天的主页：景天科技苑
文章目录 Python中cx_Freeze的详细用法教程cx_Freeze概述cx_Freeze相对于PyInstaller的优点安装cx_Freeze基本用法编写setup.py打包可执行文件注意事项 进阶用法图标设置添加数据文件隐藏控制台窗口打包成单个文件打包实例：使用PyQt5打包前的准备打包过程遇到的问题及解决方案后续步骤调试与故障排除打包后的测试分发维护和更新 总结 Python中cx_Freeze的详细用法教程 cx_Freeze概述 在Python开发中，将脚本打包成独立的可执行文件是一项常见的需求，特别是在需要将程序分发给没有安装Python环境的用户时。cx_Freeze是一个流行的Python库，它可以将Python脚本及其依赖项打包成独立的可执行文件，支持多平台（如Windows、Linux和macOS）。本文将结合实际案例，详细介绍cx_Freeze的安装、配置和使用方法。
官网：https://pypi.org/project/cx-Freeze/
cx_Freeze相对于PyInstaller的优点 在Python中，cx_Freeze和PyInstaller都是流行的打包工具，它们各自具有一些优点和特性。关于cx_Freeze相对于PyInstaller的优点，可以从以下几个方面进行归纳：
配置灵活性：
cx_Freeze通过setup.py文件提供了较高的配置灵活性。开发者可以详细指定打包过程中的各种选项和参数，如程序名称、版本号、图标、依赖项等。这种灵活性使得cx_Freeze能够更精确地满足特定项目的需求。 依赖项管理：
cx_Freeze能够自动检测和打包Python脚本所依赖的模块和库，包括标准库和第三方库。这种自动化的依赖项管理减少了手动配置的工作量，并降低了因遗漏依赖项而导致的错误。 输出格式多样性：
cx_Freeze支持生成多种输出格式，如可执行文件、目录、ZIP归档文件等，以适应不同的部署需求。这种多样性为开发者提供了更多的选择和灵活性。 与Python库的兼容性：
cx_Freeze与许多常见的Python库和框架兼容，包括Tkinter、PyQt、Django等。这意味着开发者可以更容易地将这些库和框架集成到他们的项目中，并使用cx_Freeze进行打包。 社区和文档支持：
尽管PyInstaller在流行度和社区支持方面可能略胜一筹，但cx_Freeze也拥有一个活跃的社区和相对完善的文档。这些资源可以帮助开发者解决在打包过程中遇到的问题。 透明度和可定制性：
cx_Freeze的打包过程相对透明，开发者可以更容易地理解其工作原理并进行必要的定制。这对于需要高度定制打包过程的项目来说是一个重要的优点。 需要注意的是，以上优点并非绝对，因为PyInstaller也具有许多独特的优点和特性。在选择使用哪个打包工具时，开发者应根据自己的项目需求、个人偏好以及工具的特性和限制来做出决策。
此外，随着时间的推移和工具的不断发展，上述优点可能会发生变化。因此，在做出决策之前，建议查阅最新的文档和社区讨论以获取最准确的信息。
安装cx_Freeze 首先，确保你的Python环境已经安装。然后，使用pip命令安装cx_Freeze。在命令行（终端）中运行以下命令：
pip install cx_Freeze 如果你使用的是特定版本的Python，并且需要安装与之兼容的cx_Freeze版本，可以通过指定版本号来安装，例如：
pip install cx_Freeze==6.1 基本用法 编写setup.py 要使用cx_Freeze打包Python脚本，你需要编写一个setup.py文件，该文件告诉cx_Freeze如何打包你的程序。以下是一个基本的setup.py示例：
from cx_Freeze import setup, Executable # 要打包的Python脚本路径 script = "main.py" # 创建可执行文件的配置 exe = Executable( script=script, base=None, # 对于GUI应用，可以设置为"Win32GUI"来隐藏控制台窗口 targetName="MyProgram" # 生成的可执行文件名称 ) # 打包的参数配置 options = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d9c236ea33398da243eddd41fe6c2a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50c8ed4d5e189df19ad93964914a2d7/" rel="bookmark">
			一条sql 在MySQL中是如何执行的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 MySQL 中，SQL 查询的执行涉及多个内存区域和处理步骤，以确保查询能够高效地执行和返回结果。以下是 SQL 查询在 MySQL 中执行时通常会经过的内存路径：
1. 客户端内存 - SQL 文本发送 ：SQL 查询首先从客户端发送到 MySQL 服务器。客户端内存用于存储和发送 SQL 查询文本。
2. 网络缓冲区 - 接收和处理请求 ：SQL 查询通过网络传输到 MySQL 服务器，在服务器端进入网络缓冲区（Network Buffer），等待处理。
3. 解析器和优化器内存 -SQL 解析 ：MySQL 解析器将 SQL 查询解析为语法树。此过程使用解析器内存来存储中间数据结构。
- 查询优化 ：MySQL 优化器会生成多个查询执行计划，并选择最优的执行路径。这一过程使用优化器内存来计算和存储执行计划的相关信息。
4.查询缓存（可选） - 查询缓存检查 ：MySQL 在执行查询之前，会检查是否在查询缓存中已有结果（如果查询缓存启用）。如果查询结果已缓存且未过期，则直接从查询缓存中返回结果，从而跳过后续的处理步骤。
5.表缓存（Table Cache） - 表打开和管理 ：如果查询涉及的表没有被打开，MySQL 将会在表缓存中检查并尝试打开表文件。表缓存内存用于存储已打开表的元数据和文件句柄。
6.内存表（Memory Tables） -内存临时表 ：某些复杂查询，如带有 `GROUP BY`、`ORDER BY`、或 `DISTINCT` 的查询，可能需要 MySQL 在内存中创建临时表来存储中间结果。如果数据量过大，临时表可能会被存储到磁盘。
7.InnoDB 缓冲池（Buffer Pool） -数据页缓存 ：MySQL 使用 InnoDB 缓冲池来缓存表数据和索引页。查询过程中涉及到的表数据首先在缓冲池中查找，如果未命中，则从磁盘加载相应的数据页到缓冲池。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f50c8ed4d5e189df19ad93964914a2d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd8a4e6e34bd623ad1d91d37ae157f8/" rel="bookmark">
			Android常见控件(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言
一、TextView控件
常用属性
二、Button控件
设置点击事件的方式
1.在布局文件中指定onClick的值
2.使用匿名内部类
3.通过实现onClickListener接口
三、ImageView控件
常见属性
src与background的区别
scaleType
1.ScaleType.FIT_CENTER默认
2.ScaleType.FIT_START
3.ScaleType.FIT_END
4.ScaleType.FIT_XY
5.Scale.CENTER
6.ScaleType.CENTER_CROP
7.ScaleType.CENTER_INSIDE
前言 在上一篇中，我们讲解了android中一些常见的界面布局，那么本章我们就来讲解一下在android的一些常用的界面控件。几乎每一个应用程序都是通过界面控件与用户进行交互的，android中给我们提供了丰富的界面控件。
一、TextView控件 TextView控件用于显示文本信息。我们可以在XML布局文件中通过添加属性的方式来控件TextView控件。
常用属性 属性说明android:layout_width设置TextView控件的宽度android:layout_height设置TextView控件的高度android:id设置TextView控件的唯一标识android:background设置控件的背景android:layout_margin设置当前控件与屏幕边界或者周围控件、布局的距离android:padding设置控件与该控件的内容的距离android:textColor设置文本中文字显示的颜色android:textSize设置文本大小，推荐使用sp。android:gravity设置文本内容的文职，如设置成“center”，文本将居中显示android:maxLength设置文本最大长度，超出此长度的文本不显示。android:lines设置文本的行数，超出行数的文本不显示android:maxLines设置文本的最大行数，超出行数的文本不显示android:ellipsize设置当文本超出TextView控件规定的范围时的显示方式。属性值可选为“start”、“middle”、“end”，分别表示当文本超出TextView控件规定的范围时，在文本开始、文本中间或者末尾显示省略号“...”android:drawableTop在文本顶部显示图像，该图像资源可以放在res/drawable文件夹中相应分辨率的目录下，通过 “@drawable/文件名” 调用。类似的属性还有android:drawableLeft、android:drawableRight、android:drawableBotton,分别表示在文本左侧、文本右侧和文本底部android:lineSpacingExtra设置文本的行间距android:textStyle设置文本的样式，bold(粗体）、italic（斜体）、normal（正常） 对于这些TextVIiew属性，我们同样可以使用java中的方法来设置。控件的每一个属性在java中都会有对应的一个方法，例如，TextView控件中的android:text，对于java中的setText()方法。
我们可以来练习一下如何使用。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/v1" android:text="这是一个粗体的文本" android:textSize="20sp" android:background="#4CAF50" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="20sp" android:textStyle="bold"/&gt; &lt;TextView android:id="@+id/v2" android:text="这是一个斜体的文本" android:textSize="20sp" android:background="#FFEB3B" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="20sp" android:textStyle="italic"/&gt; &lt;TextView android:id="@+id/v3" android:text="这是一个正常字体的文本" android:textSize="20sp" android:background="#00BCD4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="20sp" android:textStyle="normal"/&gt; &lt;/LinearLayout&gt; 二、Button控件 Button控件表示按钮，继承于TextView控件， 既可以显示文本，又可以显示图片，同时允许用户通过点击来进行操作，当Button控件被点击后，被按下与弹起的背景会有一个动态切换的效果，这个效果就是点击效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcd8a4e6e34bd623ad1d91d37ae157f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9baa8e6baceb21b08de209833e9bef5/" rel="bookmark">
			用 Swift 写 Android App ？来了解下 Skip 原生级跨平台框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在找资料的时候，机缘巧合发现了一个有趣的商业跨平台框架 Skip ，刚好看到了它发布 1.0 正式版，主要作用是将 Swift 开发引入到 Android 领域，这样 App 就可以共享 Swift 的业务逻辑，在 SwiftUI 中完成 Android App，用 Skip 的话说就是：
“Skip brings Swift app development to Android. Share Swift business logic, or write entire cross-platform apps in SwiftUI.”
至于为什么说是原生级？稍微了解之后，我发现它的理念和思路有点意思，或者说类似的路子国内也有，例如曾经写过的 《uni-app-x 了解过吗？》 ，从思路上看它们都是走的「转译」的路线，当然这个路线成本不低，比如在 uni-app-x 文章的评论区，就有大哥有比较深的感悟：
当然，Skip 和 uni-app-x 比较大的区别在于：它是直接通过 Swift / SwiftUI 去转移为 Kotlin / Compose，所以在语法和兼容成本会更低一点点，因为它只需要实现 Android 平台的转移，iOS 平台本身就是 Native 。
另外，Skip 的可脱离性质才是我觉得最有意思的，这个我们后续会讲到。
至于为什么会想到用 Swift 来做跨平台？因为在 Skip 的产品理念里，移动应用基本是 iOS 先行，而后才考虑 Android，所以用 Swift 做跨平台是它们的最佳实践：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9baa8e6baceb21b08de209833e9bef5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7792bf9d4bd6d8f7163ed890139c7660/" rel="bookmark">
			一个集成物联网、机器学习和大数据实践平台在电气工程课程中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理自《A Platform for Integrating Internet of Things, Machine Learning, and Big Data Practicum in Electrical Engineering Curricula》，由Nandana Jayachandran、Atef Abdrabou、Naod Yamane和Anwer Al-Dulaimi共同撰写，发表于2024年的《Computers》期刊上。以下是对论文主要内容的整理：
1. 引言 论文讨论了物联网(IoT)、人工智能(AI)、特别是机器学习(ML)以及大数据分析在电气工程领域的整合对教育的重要性。强调了将这些技术整合到电气工程课程中，帮助学生适应快速变化的技术环境的必要性。 2. 相关工作 概述了AI和大数据在教育领域的应用，包括自适应电子学习系统、教学模型的创新，以及学习分析技术的应用。讨论了AI在特定领域教育中的应用，例如高级数学教育和软件工程。强调了将AI概念整合到课程中，以及通过实践、动手方法教授AI的重要性。 3. 研究内容和意义 详细介绍了物联网(IoT)、MQTT协议、大数据平台和机器学习(ML)的基本概念和重要性。讨论了这些技术如何为电气工程学生提供必要的知识和技能，以设计和实现智能系统。 4. 研究方法 提出了研究问题：如何设计一个教育工具，为电气工程学生提供IoT与大数据分析结合使用基本ML技术的实践经验？介绍了工具设计方法、功能和课程整合。 工具设计方法：创建了一个基于图形用户界面(GUI)的工具，整合了IoT、大数据和ML，提供了实践操作经验。工具特点：模块化设计，包括IoT数据生成模块、实时流模块和机器学习模块。用户界面：提供了用户友好的界面，帮助学生设置IoT数据生成、实时流和流数据的ML分析。课程学习成果：提出了一系列学习成果，用于评估学生使用该工具时的表现。 4.1 研究问题 主要研究问题集中在如何设计一个教育工具，使电气工程学生能够获得将物联网(IoT)与大数据分析相结合使用基本机器学习(ML)技术的实践经验。次要问题探讨了如何将这样的工具整合到典型的电气工程课程中。 4.2 工具设计方法和特点 设计目标是创建一个基于图形用户界面(GUI)的工具，整合IoT、大数据和机器学习，为电气工程学生提供这些领域的实践经验。工具设计采用迭代结构，通过教育过程纠正错误和发展熟练度。工具设计遵循GUI范例，使学生能够通过逐步选项的方法与工具交云，包括设置真实硬件或合成(虚拟)IoT设备，选择设备类型，添加传感器，并将其配置为MQTT客户端。 4.2.1 IoT数据生成模块
该模块模拟IoT设备或与真实设备交互，输出包含现实和相关传感器读数的MQTT网络数据包。学生可以设置IoT网络设备，添加设备和传感器，并配置它们作为MQTT客户端。支持MQTT协议传输感知数据，包括客户端和MQTT代理。 4.2.2 实时流模块
负责捕获由前一模块生成的IoT数据，并将其流式传输到基于Kafka的大数据分析平台。使用PyShark作为Python模块，用于解析网络数据包。Kafka集成涉及建立集群、创建主题以及与IoT数据生成模块的集成。 4.2.3 机器学习模块
涉及对实时流数据进行机器学习分析，学生可以加载已创建的数据集或实时生成数据集。包括数据预处理、数据集分割、回归和分类任务、模型拟合和优化。 4.2.4 操作程序
描述了工具操作的流程图，从开始新项目或加载现有项目，到配置IoT网络、生成数据、捕获数据、机器学习模型配置和训练。 4.2.5 工具用户界面
提供了用户友好的界面，用于设置IoT数据生成、实时流和流数据的机器学习分析。界面设计包括帮助文本，指导学生了解概念并确保顺畅导航。 4.3 工具在电气工程课程中的整合 讨论了如何将IoT-Edu-ML-Stream工具引入支持IoT、ML和大数据的一般课程，或作为电气工程课程中高级专业课程的一部分。提出了一系列课程学习成果(CLOs)，这些成果可以在使用工具的专门课程或课程组件中实现。讨论了整合的好处，包括学生获得的全面理解，以及工具提供的实践技能。 5. 工具评估 通过调查问卷的形式，评估了IoT-Edu-ML-Stream平台的有效性。调查结果显示学生在使用工具后对IoT概念有了显著的了解，并且实践技能得到了提升。调查包括六个问题，分为三部分：先前知识评估、工具设计用例的有效性评估、工具介绍现实场景的反馈评估。 5.1 工具评估结果 调查结果概览
调查问卷采用五点评分量表，包括六个问题，分为三部分：评估学生先前的知识、工具设计用例的有效性以及工具介绍现实场景的效果。 Q1：先前知识评估
学生对IoT、大数据和ML的先前知识评分显示多样性，平均分为3.62，标准差为1.25。 Q2：IoT概念知识提升
大约65.5%的学生报告在使用工具后在这些主题的基础知识上有显著提升（评为5），约35%的学生表示知识获得很好。没有学生给出低于4的评分。平均评分为4.66，标准差为0.425。 Q3：ML概念理解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7792bf9d4bd6d8f7163ed890139c7660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a35fb53dd833e79f837718ce587bbb/" rel="bookmark">
			揭秘组合模式：设计更智能、更灵活的软件架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树形结构，以表示部分以及整体层次结构。这种模式使得单个对象和组合对象的使用具有一致性。组合模式的核心在于它能够让客户通过统一的接口对单个对象和组合对象进行操作，而不需要关心处理的是个体还是整体。下面将具体介绍组合模式的各个方面：
组成 抽象组件（Component）：定义了所有对象的共有接口，规定了管理子部件的方法，如add、remove和operation等。叶子组件（Leaf）：代表组合结构中的叶节点，没有子节点。它实现了抽象组件接口中的方法，但通常不包含子组件。容器组件（Composite）：可以包含其他组件（包括叶子和其他容器），形成树状结构。同样实现抽象组件接口，并提供管理子组件的具体方法。客户端（Client）：通过抽象组件接口与组合结构交互，无需区分叶子和容器。优点 单一职责：叶子节点和容器节点各自专注于其功能。透明性：客户端统一处理对象，增加代码简洁性。易扩展性：新增组件类型只需符合接口即可融入系统。缺点 设计复杂：增加抽象层和接口使系统复杂。递归性能问题：深层结构可能导致栈溢出或效率降低。适用场景 处理层次结构：文件系统、组织结构。一致处理对象：客户端无差别处理个体和群体。简化新增构件：易于添加新叶子或容器节点。注意事项 优先使用接口：提高系统灵活性和可维护性。解耦创建逻辑：结合工厂模式创建组件。确保接口统一：所有组件遵循相同接口。 总之，组合模式通过将对象组织成树形结构，有效解决了部分与整体的层次结构问题。它让客户端代码在处理复合结构和单个元素时保持一致，大大简化了客户端的使用。不过，实现组合模式也需要考虑设计的复杂度及潜在的性能问题。合理应用组合模式能大幅增强系统的灵活性和扩展性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff92a67494aef783f817b8bf46977c2/" rel="bookmark">
			2024.8.19 学习记录 —— 作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TCP机械臂测试 #include &lt;myhead.h&gt; #define SER_PORT 8888 // 与服务器保持一致 #define SER_IP "192.168.0.114" // 服务器ip地址 int main(int argc, const char *argv[]) { // 创建文件描述符打开键盘文件 int fd = open("/dev/input/event1", O_RDONLY); if (fd == -1) { perror("open error"); return -1; } // 定义结构体接收键盘文件的数据 struct input_event ie; // 创建用于通信的套接字文件描述符 int cfd = socket(AF_INET, SOCK_STREAM, 0); if (cfd == -1) { perror("socket error"); return -1; } printf("cfd = %d\n", cfd); // 连接到服务器 // 填充服务器地址信息结构体 struct sockaddr_in sin; sin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff92a67494aef783f817b8bf46977c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d53cfd9d5af09c9edc2f6e53726b44b9/" rel="bookmark">
			AIGC浪潮中的程序员：日常编码与自我提升的平衡术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的飞速进步，AIGC（人工智能生成内容）技术在软件开发领域的应用日益广泛，它不仅改变了编码工作的方式，更对我们的职业发展路径和技能结构提出了新的要求。在这样一个快速变化的环境中，如何深度平衡日常编码工作与提升式学习，成为了一个亟待解决的重要问题。
一、深入理解AIGC的深层影响 AIGC技术不仅仅是编码的辅助工具，它更是推动软件开发模式变革的关键力量。它通过自动化、智能化的方式，极大地提高了编码效率，但同时也对我们的技能要求、思维方式乃至职业规划产生了深远影响。因此，我们需要深入理解AIGC技术的本质和潜力，认识到它既是挑战也是机遇，从而在工作中主动寻求与AIGC技术的深度融合。
二、构建个性化成长蓝图 为了在AIGC环境下实现深度平衡，我们首先需要构建一张个性化的成长蓝图。
技能定位：明确自己在团队和项目中的技能定位，了解哪些技能是不可或缺的，哪些技能是可以通过AIGC技术来辅助或替代的。基于此，制定针对性的技能提升计划。学习路径：根据技能定位和个人兴趣，规划一条清晰的学习路径。这条路径应涵盖基础知识、进阶技能、前沿技术等多个层面，并注重理论与实践的结合。职业规划：将学习与职业规划相结合，思考自己在未来几年内的职业发展目标。这些目标可以是技术专家、项目经理、团队领导等不同的职业方向，但都应与AIGC技术的发展趋势保持一致。 三、优化工作与学习流程 为了实现深度平衡，我们需要不断优化自己的工作与学习流程。
任务分解与优先级排序：将复杂的编码任务分解成若干个子任务，并根据紧急程度和重要性进行优先级排序。同时，为学习新知识和技术留出专门的时间段，确保工作与学习两不误。高效利用AIGC工具：熟练掌握并高效利用AIGC工具进行编码工作。例如，利用智能代码补全功能提高编码效率；利用代码审查工具发现潜在问题并优化代码质量；利用自动化测试工具减轻测试负担等。反思与总结：在完成每个任务或学习阶段后，及时进行反思和总结。分析自己在工作和学习中的得失，总结经验教训，为未来的工作和学习提供指导。 四、深化学习与创新能力 在AIGC环境下，深化学习与创新能力是我们保持竞争力的关键。
跨学科学习：鼓励我们进行跨学科学习，如数学、物理学、心理学等。这些学科的知识可以为我们提供新的视角和思维方式，有助于解决复杂的技术问题。参与开源项目：加入开源社区，参与开源项目的开发和维护。这不仅可以提升我们的编程能力和团队协作能力，还可以让我们接触到最前沿的技术和解决方案。持续探索未知领域：保持对未知领域的好奇心和探索欲。关注行业动态和技术趋势，尝试将新技术、新方法应用于实际项目中。通过不断的实践和创新，提升自己的技术水平和竞争力。 五、构建学习共同体与支持系统 在AIGC环境下，构建学习共同体与支持系统对于我们的成长至关重要。以下是一些具体的建议：
加入技术社群：加入与自己技术方向相关的社群或论坛，与同行交流经验和心得。通过社群的力量获取最新的技术资讯和解决方案，解决自己在工作和学习中遇到的问题。寻求导师指导：寻找经验丰富、技术精湛的导师进行指导。导师可以为我们提供宝贵的建议和指导，帮助我们少走弯路、快速成长。建立学习伙伴关系：与志同道合的伙伴建立学习伙伴关系。通过共同学习和交流，激发彼此的学习动力和创造力，共同进步。 在AIGC环境下，我们需要不断适应技术变革带来的挑战和机遇。通过深入理解AIGC技术的深层影响、构建个性化成长蓝图、优化工作与学习流程、深化学习与创新能力以及构建学习共同体与支持系统等多方面的努力，我们可以在日常编码工作与提升式学习之间找到深度平衡，实现个人成长和职业发展的双赢局面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd5245ff7affa018160338c461395e5/" rel="bookmark">
			修改了原神4.8版本升级数据表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;原神4.8版本升级数据表&lt;/title&gt; &lt;/head&gt; &lt;style&gt; * { margin: 0; padding: 0; box-sizing: border-box; body { background: #1c3b5c; } a { color: #e6a23c; } } header { width: 99vw; height: 40px; display: flex; justify-content: space-between; align-items: center; background-color: #cbcbcb; position: fixed; /* logo */ figure.logo { width: 262px; height: 50px; /* 缩小 */ transform: scale(0.8); margin-top: 2px; margin-left: -15px; border-radius: 50%; background: #f30303; box-shadow: inset 4px 4px 4px rgba(255, 255, 255, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efd5245ff7affa018160338c461395e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd56c6620cfda86bc814d2f29eca5f6d/" rel="bookmark">
			【iOS】Block底层分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言Block底层结构Block捕获变量原理捕获局部变量（auto、static）全局变量捕获实例`self` Block类型Block的copyBlock作为返回值将Block赋值给__strong指针Block作为Cocoa API中方法名含有usingBlock的方法参数Block作为GCD API的方法参数Block属性的写法 Block访问对象类型的auto变量Block在栈上Block被拷贝到堆上Block从堆上移除 修饰符__block__block内存管理__forwarding指针__block修饰对象类型 Block循环引用解决办法强弱共舞 总结 前言 Block是带有局部变量的匿名函数，函数实现就是代码块里的内容，同样有参数和非返回值，本质是一个封装了函数调用以及函数调用环境的OC对象，因为它内部有isa指针
Block的基本使用请看这两篇文章：
kl 本篇文章着重探究Block这些特性的底层原理
Block底层结构 声明一个最简单的块并调用：
void (^block)(void) = ^{ NSLog(@"Hello World!"); }; block(); 使用xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m命令将OC代码转换成C++代码：
// 原本的代码有各种强制转换，目前不重要，先删去从简 // 声明并实现一个block // void (*block)(void) = ((void (*)(int, int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); block = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA); // 调用执行block // ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); block-&gt;FuncPtr(block); // __main_block_impl_0可以直接转换为__block_impl类型，是因为两个类型的结构体地址是一样的，而且相当于直接把__block_impl里的值都放到__main_block_impl_0里 这些穿插了许多下划线的符号实际上是不同的结构体变量，Block本质就是struct __main_block_impl_0类型的结构体，下图清晰地说明了block的底层结构：
__main_block_impl_0可以直接转换为__block_impl类型，是因为两个类型的结构体地址是一样的（相当于直接把__block_impl里的值都放到__main_block_impl_0里）
所以block.impl-&gt;FuncPtr(block)就相当于block-&gt;FuncPtr(block)
Block捕获变量原理 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制
捕获局部变量（auto、static） auto：自动变量，离开作用域就自动销毁，只存在于局部变量
static：静态局部变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd56c6620cfda86bc814d2f29eca5f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a218dcbc186e665dd99b927fed006bb9/" rel="bookmark">
			神经网络中Linear、MLP和FC的定义和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络是一种计算模型，它受人脑的启发，可以从数据中学习并作出预测或决策。神经网络由多个神经元组成，这些神经元通过加权连接进行交互。下面是对Linear、MLP和FC这三个术语的定义和区别：
Linear (线性层):
线性层是神经网络中最基本的组件之一，它执行线性变换。线性层的作用是将输入向量与权重矩阵相乘，并加上偏置向量，得到输出向量。线性层没有非线性激活函数，因此它不能解决非线性问题，但它是构建更复杂网络的基础。 MLP (多层感知器):
多层感知器是一种前馈神经网络，它由至少三层的神经元组成：输入层、一个或多个隐藏层和输出层。隐藏层和输出层的神经元使用非线性激活函数，如Sigmoid、Tanh或ReLU，使得MLP可以处理复杂的非线性关系。MLP通过在层之间引入非线性激活函数，解决了线性层无法解决的非线性问题。 FC (全连接层):
全连接层是一种特殊的线性层，其中每个神经元与前一层的所有神经元相连。在全连接层中，每个神经元的输出是前一层所有输入的加权和，再加上一个偏置项。全连接层通常用于处理一维数据，如图像的像素值展平后的向量，或者用于连接不同层之间的特征。 区别:
Linear层是MLP和FC的基础，但它本身不能处理复杂的非线性问题。MLP是包含多个线性层（通常是全连接层）和非线性激活函数的网络结构，能够学习复杂的数据模式。FC是MLP中的一种特殊层，它确保了层与层之间的每个神经元都是全连接的。 了解这些组件对于设计和优化神经网络非常重要，因为它们决定了网络可以处理的数据类型和复杂性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/201ff8171ee41178282c51370d0624a3/" rel="bookmark">
			Elasticsearch中磁盘水位线的深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ❃博主首页 ： 「码到三十五」 ，同名公众号 :「码到三十五」，wx号 : 「liwu0213」 ☠博主专栏 ： &lt;mysql高手&gt; &lt;elasticsearch高手&gt; &lt;源码解读&gt; &lt;java核心&gt; &lt;面试攻关&gt; ♝博主的话 ： 搬的每块砖，皆为峰峦之基；公众号搜索「码到三十五」关注这个爱发技术干货的coder，一起筑基 Elasticsearch是一个分布式、高可扩展的搜索引擎，它允许用户将大量数据存储在集群中，并通过高效的查询引擎进行检索。然而，随着数据的增长，如何管理存储空间和确保系统的稳定性变得尤为重要。为此，Elasticsearch引入了磁盘水位线（disk watermark）的概念，以监控和管理磁盘空间的使用。
文章目录 基本概念重要性工作原理配置方法最佳实践和建议总结 基本概念 在Elasticsearch中，磁盘水位线是一种机制，用于监控集群中各个节点的磁盘使用情况。通过设定不同的水位线阈值，Elasticsearch能够在磁盘空间即将耗尽时采取适当的措施，例如停止写入新的数据，或者将数据从高水位节点移动到其他节点。
重要性 磁盘水位线对于Elasticsearch来说至关重要，原因有以下几点：
防止数据丢失：通过监控磁盘使用情况，可以防止由于磁盘空间不足导致的数据丢失。维护系统稳定性：当磁盘空间不足时，Elasticsearch可能会停止写入新的数据，这可能导致系统的性能下降或中断服务。提高数据恢复能力：在数据丢失前，通过预先的警告和预防措施，可以更容易地恢复数据。 工作原理 Elasticsearch的磁盘水位线是基于磁盘使用率的阈值，当磁盘使用率超过这些阈值时，Elasticsearch会采取相应的行动。这些阈值包括：
Low Watermark：当磁盘使用率达到此阈值时，Elasticsearch会停止向该节点分配新的分片,对于新创建的索引主分片不影响，副本分片受影响。默认值为85%，但可以根据需要进行调整。
High Watermark：当磁盘使用率达到此阈值时，Elasticsearch会尝试将现有分片从该节点移动到其他节点,会影响所有分片的分配。默认值为90%，但同样可以根据需要进行调整。
Flood Stage：当磁盘使用率达到此阈值时，Elasticsearch会将节点标记为不可分配，并尝试将所有分片从该节点移动到其他节点,节点上的分片设置为只读索引。默认值为95%，同样可以根据需要进行调整。防止磁盘空间耗尽最后的手段。当磁盘低于 high 水位时，索引块自动释放。
官网解释:
配置方法 在Elasticsearch的配置文件中（通常是elasticsearch.yml），可以设定这些磁盘水位线的阈值。例如：
cluster.routing.allocation.disk.watermark.low: 85% cluster.routing.allocation.disk.watermark.high: 90% cluster.routing.allocation.disk.watermark.flood_stage: 95% 固定值设置:
cluster.routing.allocation.disk.watermark.low: 200g cluster.routing.allocation.disk.watermark.high: 100g cluster.routing.allocation.disk.watermark.flood_stage: 30g 这些配置参数可以根据需要进行调整，以适应不同的存储需求和性能目标。
最佳实践和建议 定期监控：定期检查磁盘水位线的状态和集群的健康状况，确保系统有足够的磁盘空间。备份策略：建立有效的备份策略，以防数据丢失。优化存储：考虑使用更高效的存储解决方案，如SSD，以提高性能和减少磁盘空间的使用。合理规划：在创建索引时，合理规划分片和副本的数量，以减少对磁盘空间的需求。清理无用数据：定期删除无用的旧数据，以释放磁盘空间。 总结 Elasticsearch的磁盘水位线是一种强大的工具，它帮助管理员监控和管理Elasticsearch集群的磁盘使用情况，防止数据丢失和系统性能下降。通过合理配置和使用磁盘水位线，可以确保Elasticsearch集群的稳定性和可靠性。
关注公众号[码到三十五]获取更多技术干货 ! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b14fe7d1ef70dbeb26765f82823eb9f/" rel="bookmark">
			【C语言】冒泡排序保姆级教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言冒泡排序保姆级教学 直奔主题：
拿排升序举例子
第一步：
将想要排序的数组中数值最大的那个数排到该数组的最后
具体实现如下图：
第一步代码实现
for (int i = 1; i &lt; n ; i++)//n为数组大小此处为4 { if (a[i - 1] &gt; a[i])//注意越界，若排降序将大于改为小于即可 { int tmp = a[i - 1]; a[i - 1] = a[i]; a[i] = tmp; exchange = 1; } } 第二步（关键）
由于通过第一步我们已经将最大的数排在了数组最后
因此只需要将数组中第二大的数排到数组的倒数第二个位置
所以这里我们就采用双重循环来控制要排序的区间
这里就是我们要排序的区间从原来的a[0]到a[3]缩小到a[0]到a[2]，
即每次将排序区间中最大的数排到该区间最后后，将该排序区间缩小1；
代码如下：
for (int j = 0; j &lt; n - 1; j++) //此处条件为j &lt; n - 1 可以根据第二个for循环得到，当n为1时依旧要进入第二个for //循环对a[0]与a[1]比较，所以第二个for循环条件n - j 最小应该为2，那么j最大就应该为 n - 2； { for (int i = 1; i &lt; n - j; i++)//注意此处条件变为i &lt; n - j，来达到每次排序完后区间缩小1的目的 { if (a[i - 1] &gt; a[i])//注意越界 { int tmp = a[i - 1]; a[i - 1] = a[i]; a[i] = tmp; } } 冒泡排序的优化 这个双重循环已经可以解决排序问题了，但是可以对它进行优化，使得我们的代码更加健壮（运行时间更短），优化代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b14fe7d1ef70dbeb26765f82823eb9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564677c09845865e5af5df1fa42bb420/" rel="bookmark">
			轻松上手MYSQL：MYSQL权限配置全攻略,打造安全的数据库环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
🌈 个人主页：danci_
🔥 系列专栏：《设计模式》《MYSQL》
💪🏻 制定明确可量化的目标，坚持默默的做事。
✨欢迎加入探索MYSQL权限配置之旅✨
👋 大家好！文本学习和探索MYSQL权限配置。👋 权限配置是保障数据安全与系统稳定的基石。《MySQL权限配置》将带您深入探索权限管理的奥秘，帮助您轻松掌握用户权限的分配与控制技巧。从基本用户设置到复杂的权限策略，本篇文章将为您提供全面的指导，让您在应对各种安全挑战时游刃有余。无论您是初学者还是资深DBA，这里都有您不可错过的实战经验与最佳实践。准备好让您的数据库更安全了吗？让我们一探究竟！
目录
一、环境
二、MySQL8 用户权限
2.1 账号管理权限
2.1.1 连接数据库
2.1.2 账号权限配置
2.2 密码管理
2.3 锁账号配置（含示例）
三、MySQL8 用户资源限制
一、环境 Windows11；Docker （中文下载：Docker中文网 官网，英文下载:Get Started | Docker，安装：一直下一步即可）；Mysql5、Mysql8.0.28。 # 下载镜像 $ docker pull mysql:8.0.28 # 创建容器并运行 $ docker run -itd --name mysql8 -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root -e MYSQL_ROOT_HOST='%' mysql 二、MySQL8 用户权限 在 MySQL8 之前，授权表使用 MyISAM 并且是非事务性的，而在 MySQL8 中，授权表使用 InnoDB 存储引擎并且是事务性的。通过查看创建表的语句（命令：show create table user;）来查看表的存储引擎，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/564677c09845865e5af5df1fa42bb420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee10dae0b532b7d0bfb7029260a477d7/" rel="bookmark">
			IOS 09 R.swift框架和使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R.swift框架主要是实现通过类字段访问字符串，图片，等资源；类似Android那边通过R类访问，好处是有提示，如果缺少资源，直接就是编译错误；OC类似的功能叫R.objc。
添加依赖 添加依赖 #将资源（图片，文件等）生成类，方便到代码中方法 #例如：let icon = R.image.settingsIcon() #let font = R.font.sanFrancisco(size: 42) #let color = R.color.indicatorHighlight() #let viewController = CustomViewController(nib: R.nib.customView) #let string = R.string.localizable.welcomeWithName("Arthur Dent") #https://github.com/mac-cain13/R.swift pod 'R.swift' 还不了解如何使用 CocoaPods 管理依赖的，建议先看前面的文章：IOS 01 CocoaPods 安装与使用
添加完依赖后，看一下Pods文件夹里面是否添加成功。
配置 1.选择targets，在Build Phases标签，添加一个New Run Script Phase脚本。
2.拖拽新的脚本Run Script 到Compile Sources之前。
3.然后写入如下内容：
"$PODS_ROOT/R.swift/rswift" generate "$SRCROOT/R.generated.swift"
4.添加 $SRCROOT/R.generated.swift 到 "Output Files"
5.取消勾选的 "Based on dependency analysis"，以便 R.swift 在每次构建时运行
6.编译项目，就可以看到生成的R.generated.swift文件
7.拖拽R.generated.swift文件到项目根目录，取消勾选Copy items if needed，点击Finish。
使用 添加了字符串，图片等资源后，一定要编译才能访问到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee10dae0b532b7d0bfb7029260a477d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df69f05565434f3ade4def40cf6e1df2/" rel="bookmark">
			HarmonyOS 开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 下载IDE
代码 import { hilog } from '@kit.PerformanceAnalysisKit'; import testNapi from 'libentry.so'; import { router } from '@kit.ArkUI'; import { common, Want } from '@kit.AbilityKit'; @Entry @Component struct Index { @State message: string = 'Hello HarmonyOS!'; private context = getContext(this) as common.UIAbilityContext; // Ability间跳转 async explicitStartAbility() { const want : Want = { deviceId: "", bundleName: "com.example.board", moduleName: "entry", abilityName: "secondAbitily" }; let context = getContext(this) as common.UIAbilityContext; await context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df69f05565434f3ade4def40cf6e1df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac0ef40253b793a104ea52c43cc92624/" rel="bookmark">
			培训学校课程管理系统-计算机毕设Java|springboot实战项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍊作者：计算机毕设匠心工作室
🍊简介：毕业后就一直专业从事计算机软件程序开发，至今也有8年工作经验。擅长Java、Python、微信小程序、安卓、大数据、PHP、.NET|C#、Golang等。
擅长：按照需求定制化开发项目、 源码、对代码进行完整讲解、文档撰写、ppt制作。
🍊心愿：点赞 👍 收藏 ⭐评论 📝
👇🏻 精彩专栏推荐订阅 👇🏻 不然下次找不到哟~
Java实战项目
Python实战项目
微信小程序|安卓实战项目
大数据实战项目
PHP|C#.NET|Golang实战项目
🍅 ↓↓文末获取源码联系↓↓🍅
这里写目录标题 培训学校课程管理系统-选题背景培训学校课程管理系统-技术选型培训学校课程管理系统-视频展示培训学校课程管理系统-图片展示培训学校课程管理系统-代码展示培训学校课程管理系统-文档展示培训学校课程管理系统-结语 培训学校课程管理系统-选题背景 随着信息技术的快速发展，教育行业正经历着前所未有的变革。在线教育和数字化管理工具的兴起，为培训机构提供了新的机遇和挑战。SpringBoot作为一种轻量级的Java企业级应用开发框架，以其快速开发、易于部署和高度可配置性而受到开发者的青睐。在这样的背景下，开发一个基于SpringBoot的培训学校课程管理系统，不仅能够提高教育培训的效率和质量，还能满足现代教育对灵活性和个性化的需求。
尽管市场上存在多种教育培训管理系统，但许多系统仍存在功能单一、用户体验不佳、难以适应多变教学需求等问题。此外，随着大数据、人工智能等技术的融入，现有系统往往难以满足智能化、个性化教学的需求。这些问题不仅影响了教育质量，也限制了培训机构的发展和创新。
本课题旨在设计并实现一个基于SpringBoot的培训学校课程管理系统，该系统将集成先进的教学管理理念，提供灵活的课程设置、智能的资源推荐、以及个性化的学习路径等功能。从理论意义上讲，本课题将探索如何将现代软件工程原理应用于教育培训领域，推动教育技术的发展。从实际意义上讲，该系统将帮助培训机构优化资源配置，提升教学质量，增强竞争力，最终实现教育的个性化和高效化。
培训学校课程管理系统-技术选型 开发语言：Java
数据库：MySQL
系统架构：B/S
后端框架：Spring Boot/SSM(Spring+Spring MVC+Mybatis)
前端：Vue+ElementUI
开发工具：IDEA
培训学校课程管理系统-视频展示 培训学校课程管理系统-计算机毕设Java|springboot实战项目
培训学校课程管理系统-图片展示 培训学校课程管理系统-代码展示 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import your.package.name.model.Course; import your.package.name.service.CourseService; import java.util.List; @RestController @RequestMapping("/courses") public class CourseController { @Autowired private CourseService courseService; // 获取课程列表 @GetMapping public List&lt;Course&gt; listCourses() { return courseService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac0ef40253b793a104ea52c43cc92624/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/40/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>