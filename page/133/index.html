<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6daee13037aed5caa1185f83b944a8fe/" rel="bookmark">
			【AI 大模型】函数调用 Function Calling ② ( Plugins、Actions 扩展 | 函数调用 Function Calling 引入 | 函数调用开发流程 | 代码示例 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Plugins、Actions 扩展1、GPT 大模型缺陷 - 引入 Plugins、Actions 扩展2、Plugins 插件3、Plugins 插件开发流程4、Plugins 插件弊端 - Actions 引入5、Actions 简介 二、ChatGPT 的平替 - Coze、Dify三、函数调用 Function Calling 引入四、函数调用开发流程1、调用 OpenAI 的接口2、函数定义3、大模型回调4、本地代码逻辑5、第二次大模型调用 五、函数调用代码示例 一、Plugins、Actions 扩展 1、GPT 大模型缺陷 - 引入 Plugins、Actions 扩展 GPT 大模型 有如下三种缺陷 :
非全知全能 : 用于训练的都是 公开知识文本 , GPT 不知道 内部 或 保密 知识信息 ;时效性差 : 大模型训练需要 半年 以上的时间 , 使用的都是半年以前的知识 ;没有真逻辑 : 基于概率生成文本 , 无法处理复杂的逻辑问题 ; 为了解决上述三种缺陷 , OpenAI 在 GPT 大模型中引入了 Plugins 和 Actions 两种 扩展机制 , 用于增强模型的功能 , 使 GPT 大模型 能够处理 更复杂 和 特定的 任务 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6daee13037aed5caa1185f83b944a8fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9346da4ef5cb479968e7d086d67a0531/" rel="bookmark">
			huawei USG6001v1学习---防火墙高可靠性（双机热备）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是双机热备 如图：当左图的防火墙发生故障时，整个系统都会收到影响，而右图即使有防火墙发生故障，但是还有一台防火墙做备份，相对于只有一台防火墙，要可靠些。
由于防火墙上不仅需要同步配置信息，还需要同步状态信息（会话表等），所以，防火墙不能
像路由器那样单纯的靠动态协议来实现切换，需要用到双机热备技术。
1，双机 --- 目前双机热备技术仅支持两台防火墙的互备
2，热备 --- 两台设备共同运行，在一台设备出现故障的情况下，另一台设备可以立即替
代原设备
（也存在冷备的概念，仅工作一台设备，备份一台设备，备份设备仅同步配置，并
不工作，只有在主设备出现故障时，再由管理员替换工作，冷备可能会造成较长时
间的业务中断）
配置信息 --- （接口IP地址，路由信息）--- hrp不能同步基本的接口和路由信息，安全策略，
NAT策略....
状态信息：
2.VGMP 在网络学习中，做互为备份时，会使用一种技术---VRRP技术（虚拟路由器冗余技术），让一台设备为主，一台设备为备，当发生故障时，设备的主备角色发生变化，继续替出现故障的设备工作，从而实现备份的效果
但是，vrrp组是相互独立的，一台设备不只有一组VRRP组，发生故障时，其他组不会同步切换，就会发生丢包等情况，当需要同步切换，使用传统的上行链路监控，比较复杂
所以这里可以使用一种协议------VGMP （ vrrp Group Management Protocol ）--- HUAWI的私有协议，来对VRRP组进行统一的切换管理
3.HRP心跳线 HRP --- 华为冗余协议 --- 华为的私有协议 --- 可以同步防火墙上的状态和配置信息
HRP在进行双机热备时，还有一个要求，两台热备设备之间，必须拥有一条链路，用来同步信
息，并且，这条链路必须是三层链路 --- 这条链路在进行数据传递时，不受安全策略的影
响。（注意，如果心跳线是直连的，则不受安全策略的影响，但是，如果中间有中继设备，即
非直连场景，则需要配置安全策略） --- 心跳线 ---- VGMP协议发送的报文也是通过心跳线
传输的。
HRP会周期性的发送心跳报文，只有主设备会发送，周期时间默认为1S，如果备设备在三个周
期时间内默认3S没有收到对方的心跳报文，则认定对方出现故障将以自生为主
HRP三种备份方式
1，自动备份 --- 自动备份配置和状态信息，但是，配置信息可以立即自动备份，状态信息无
法立即备份，只能通过短暂的延迟之后，在进行备份（10S左右）
2，手工备份 --- 由网络管理员手工触发，可以立即同步配置和状态信息
3，快速备份 --- 该备份方式仅针对负载分担的场景。
无法同步配置信息，仅能同步状态信息，并且可以立即同步状态信息。
4.主备场景 1.主备场景 1，FW1被设定为主设备 --- FW1中的VGMP的active组被激活，并且将上下两个VRRP组拉
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9346da4ef5cb479968e7d086d67a0531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1df66e2cbe901b2644aa3b01d09f700/" rel="bookmark">
			【Spark On Hive】—— 基于电商数据分析的项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spark On Hive 详解一、项目配置1. 创建工程2. 配置文件3. 工程目录 二、代码实现2.1 Validator2.2 Class SparkFactory2.3 MySQLConfigFactory2.4 测试调用 Spark On Hive 详解 本文基于Spark重构基于Hive的电商数据分析的项目需求，在重构的同时对Spark On Hive的全流程进行详细的讲解。
所谓的Spark On X指的是从X数据源中获取数据并在Spark进行计算之后，将计算结果导入该数据库或者数仓。获取数据和导入数据的地方可以是不同的。
一、项目配置 1. 创建工程 首先，创建一个空的Maven工程，在创建之后，我们需要检查一系列配置，以保证JDK版本的一致性。同时，我们需要创建出Scala的编码环境。具体可参考以下文章:
Maven工程配置与常见问题解决指南
和
Scala01 —— Scala基础
2. 配置文件 2.1 在Spark On Hive的项目中，我们需要有两个核心配置文件。
pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ybg&lt;/groupId&gt; &lt;artifactId&gt;warehouse_ebs_2&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spark.version&gt;3.1.2&lt;/spark.version&gt; &lt;spark.scala.version&gt;2.12&lt;/spark.scala.version&gt; &lt;hadoop.version&gt;3.1.3&lt;/hadoop.version&gt; &lt;mysql.version&gt;8.0.33&lt;/mysql.version&gt; &lt;hive.version&gt;3.1.2&lt;/hive.version&gt; &lt;hbase.version&gt;2.3.5&lt;/hbase.version&gt; &lt;jackson.version&gt;2.10.0&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spark-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1df66e2cbe901b2644aa3b01d09f700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8d25d84414447aa1788be7e1508a3a/" rel="bookmark">
			Datawhale AI 夏令营——电力需求挑战赛——Task1学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本赛题是一个典型的时间序列问题。时间序列问题是指对按时间顺序排列的数据点进行分析和预测的问题，往往用来做未来的趋势预测。比如，基于历史股票每天的股价，预测未来股票的价格走向。
时间序列预测问题可以通过多种建模方法来解决，包括传统的时间序列模型、机器学习模型和深度学习模型。本次赛题的目标很简单清晰——【训练 时序预测模型 助力电力需求预测】。
打开训练集，查看数据格式。
数据集由字段id（房屋id）、 dt（日标识）、type（房屋类型）、target（实际电力消耗）组成。
编写代码，查看训练集的数据条数。
import csv def count_rows_in_csv(file_path): with open(file_path, mode='r', encoding='utf-8') as csvfile: # 使用csv.reader读取文件，忽略标题行 csv_reader = csv.reader(csvfile) next(csv_reader) # 跳过第一行标题 row_count = sum(1 for row in csv_reader) return row_count # 替换路径 csv_file_path = './data/data283931/train.csv' print(f"CSV文件中的数据条数为: {count_rows_in_csv(csv_file_path)}") 运行，查看结果。
测试集同理。
这里的数据量在百万级别，总共就 68.4 MB，算是比较小的数据集，训练与预测速度都很快。
再来看看整体流程。
1. 导入各种库
# 导入 pandas 库，用于数据处理和分析 import pandas as pd # 导入 numpy 库，用于科学计算和多维数组操作 import numpy as np 2. 读取训练集与测试集
# 使用 read_csv() 函数从文件中读取训练集数据，文件名为 'train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8d25d84414447aa1788be7e1508a3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf481d924a34504956aa7047e175a17/" rel="bookmark">
			展望未来：利用【Python】结合【机器学习】强化数据处理能力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到 破晓的历程的 博客 ⛺️不负时光，不负己✈️ 文章目录 一、引言二、数据清洗与预处理三、特征工程四、数据可视化五、模型训练与评估六、模型部署与优化七、总结 在数据驱动的时代，数据处理与机器学习技术的结合已成为推动业务增长和创新的关键力量。Python，凭借其简洁的语法、丰富的库以及强大的社区支持，在数据处理和机器学习领域占据了举足轻重的地位。本文将深入探讨如何利用Python及其相关库来强化数据处理能力，并通过机器学习技术提升模型性能。 一、引言 数据处理是任何机器学习项目的基石，它决定了后续模型训练的效果和预测的准确性。有效的数据处理能够揭示数据的内在规律，为机器学习模型提供高质量的输入。Python通过其高效的库和框架，如Pandas、NumPy、SciPy以及Scikit-learn等，为数据处理和机器学习提供了强大的支持。
二、数据清洗与预处理 首先，我们来看一个使用Pandas库进行数据清洗的示例。
import pandas as pd # 假设df是已经加载到Pandas DataFrame中的数据集 # 处理缺失值 df.fillna({'age': df['age'].mean(), 'income': 0}, inplace=True) # 检测并处理异常值（以年龄为例） df = df[df['age'].between(0, 120)] # 编码转换（以性别为例，假设性别为'male'和'female'） df['gender'] = pd.Categorical(df['gender']).codes # 数据标准化（以收入为例） from sklearn.preprocessing import StandardScaler scaler = StandardScaler() df['income_scaled'] = scaler.fit_transform(df[['income']]) 数据清洗是数据处理的第一步，也是最重要的一步。它涉及处理缺失值、异常值、重复数据以及不一致的数据格式等问题。Python中的Pandas库是进行数据清洗的得力助手。
缺失值处理：可以使用均值、中位数、众数或特定值来填充数值型缺失值，对于类别型数据则可以使用众数或特定类别（如’Unknown’）来填充。异常值检测与处理：基于统计方法（如标准差、四分位数间距）或基于模型的方法（如孤立森林）来识别和处理异常值。数据标准化与归一化：根据数据的分布特性，选择合适的标准化或归一化方法，使数据在模型训练过程中更加稳定。编码转换：对于类别型数据，使用独热编码、标签编码等方法将其转换为数值型数据，以便机器学习算法能够处理。
三、特征工程 特征工程是提升模型性能的关键步骤。以下是使用Pandas和NumPy进行特征选择和特征变换的示例。
# 假设df已经过预处理 # 特征选择（基于相关性） correlation_matrix = df.corr() high_corr_features = correlation_matrix.index[abs(correlation_matrix['target']) &gt; 0.5] df_selected = df[high_corr_features] # 特征变换（多项式特征） from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf481d924a34504956aa7047e175a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a42d9e97e071aff170e18e588a2010/" rel="bookmark">
			数据结构——顺序表来啦~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、顺序表的概念
二、顺序表的分类
（1）静态顺序表
(2)动态顺序表
三、顺序表的实现
（1）Seqlist.h
（2）Seqlist.c
(3)提示
四、顺序表算法题
1.移除元素
2.删除有序数组中的重复项
3.合并两个有序数组 五、写在最后
一、顺序表的概念 1.顺序表是线性表的一种，线性表包括：顺序表、链表、栈、队列、字符串...
2.顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构；
3.顺序表是对数组的封装，实现“增删查改”。
二、顺序表的分类 （1）静态顺序表 1.概念：使用定长数组存储元素；
2.缺点：空间少了不够用，空间多了浪费；
typedef int SLDatatype; #define N 7 typedef struct Seqlist { SLDatatype arr[N];//定长数组 int size;//有效数据个数 }SL; (2)动态顺序表 typedef int SLdatatype; typrdef struct Seqlist { SLDatatype* arr;//数组 int capacity;//空间容量 int size;//有效数据个数 }SL; 三、顺序表的实现 （1）Seqlist.h #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; //定义动态顺序表结构 typedef int SLDatatype; typedef struct Seqlist { SLdatatype* arr; int capacity; int size; }SL; //初始化 void SLInit(SL*ps); //销毁 void SLDestroy(SL*ps); //打印 void SLPrint(SL* ps); //插入数据 void SLPushFront(SL*ps, SLdatatype x); void SLPushBack(SL*ps,SLDatatype x); void SLInsert(Sl* ps, SLDatatype x ,int pos); //删除数据 void SLPopFront(SL*ps); void SLPopBack(SL*ps); void SLErase(SL*ps, int pos); //寻找数据 int SLFind(SL*ps,SLDatatype x); （2）Seqlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a42d9e97e071aff170e18e588a2010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c90fa055511f5f65ab74f976029c7a2/" rel="bookmark">
			Perl并发编程秘籍：线程间通信的艺术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Perl并发编程秘籍：线程间通信的艺术 在现代软件开发中，多线程编程已成为一种常见的技术，用于提高应用程序的并发性和响应性。在Perl中，线程间的通信是实现并发任务的关键环节。本文将深入探讨Perl中线程间通信的各种机制，并提供详细的代码示例，帮助开发者掌握这一技术。
一、引言 Perl是一种功能强大的脚本语言，支持多线程编程。通过线程，Perl可以同时执行多个任务，从而提高程序的效率。然而，线程间的通信是一个复杂的问题，需要开发者仔细设计和实现。本文将介绍Perl中实现线程间通信的几种主要方法。
二、Perl线程简介 在Perl中，线程是通过threads模块实现的。每个线程都有自己的执行环境，但它们可以共享某些数据结构。线程间的通信主要涉及到共享数据的访问和同步。
三、线程间通信的机制 Perl提供了几种机制来实现线程间的通信：
共享变量：通过在多个线程之间共享某些变量来传递信息。锁（Mutex）：用于同步线程间的访问，确保数据的一致性。条件变量：用于线程间的协调，允许一个线程等待某个条件成立。信号量（Semaphore）：用于控制对共享资源的访问，防止资源竞争。管道（Pipe）：用于线程间的数据传输。 四、共享变量 共享变量是线程间通信的一种简单方式。然而，直接访问共享变量可能会导致数据不一致。因此，通常需要使用锁来同步访问。以下是使用共享变量的示例代码：
use strict; use warnings; use threads; my $counter = 0; my $mutex = threads::shared-&gt;new(\$counter); sub increment { my $count = $mutex-&gt;value; $count++; $mutex-&gt;value($count); } my $t1 = threads-&gt;create(\&amp;increment); my $t2 = threads-&gt;create(\&amp;increment); $t1-&gt;join(); $t2-&gt;join(); print "Counter: $counter\n"; 在这个例子中，$counter是一个共享变量，通过threads::shared创建共享访问。每个线程通过increment函数来增加计数器的值。
五、锁（Mutex） 锁是确保线程安全访问共享资源的一种机制。Perl中的Mutex可以通过threads::shared模块实现。以下是使用锁的示例代码：
use strict; use warnings; use threads; my $counter = 0; my $mutex = threads::shared-&gt;new(\$counter); sub increment { my $lock = $mutex-&gt;lock(); my $count = $counter; $count++; $counter = $count; $lock-&gt;unlock(); } my $t1 = threads-&gt;create(\&amp;increment); my $t2 = threads-&gt;create(\&amp;increment); $t1-&gt;join(); $t2-&gt;join(); print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c90fa055511f5f65ab74f976029c7a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ddc04bbe66ff9e865d534a4af7dfd0/" rel="bookmark">
			【练习】链表题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥 个人主页：Dikz12🔥个人专栏：算法(Java)📕格言：吾愚多不敏，而愿加学欢迎大家👍点赞✍评论⭐收藏 目录
两数相加 题目描述 题解 代码实现 两两交换链表中的节点 题目描述 题解
代码实现 重排链表
题目描述
​编辑 题解
代码实现
合并 K 个升序链表
题目描述 题解
代码实现
链表常用技巧 1. 画图. -&gt; 更加直观和形象.
2. 引入虚拟头结点.
更便于处理边界情况.更方便对于链表的操作. 3. 快慢双指针.
判环找链表中环的入口找链表中倒数第n个结点 链表中常用操作 1. 头插. -&gt; 逆序链表
2. 尾插.
两数相加 源自leetcode的第二题，如果大家是按顺序刷题的话，可能在第二题就怀疑人生了.
题目描述 题解 解法：模拟两数相加过程即可. 两个链表都是逆序存储数字的，即两个链表的个位数、⼗位数等都已经对应，可以直接相加。（如果不是逆序链表，那就需要手动逆序了） 在相加过程中，我们要注意是否产⽣进位，产⽣进位时需要将进位和链表数字⼀同相加。如果产⽣进 位的位置在链表尾部，即答案位数⽐原链表位数⻓⼀位，还需要再 new ⼀个结点储存最⾼位。
代码实现 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode cur1 = l1, cur2 = l2; //指向两个链表的头节点 ListNode newHead = new ListNode(0); //虚拟头节点 ListNode prev = newHead; //进行尾插操作的指针 int ret = 0; //表示进位 while(cur1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72ddc04bbe66ff9e865d534a4af7dfd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8153edbaceee49de2e53e1175a768fd1/" rel="bookmark">
			Java中的Heap（堆）（如果想知道Java中有关堆的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：（Heap）是一种特殊的完全二叉树，它在诸多算法中有着广泛的应用，本文将详细介绍Java中的堆。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.堆的初识
堆的定义
2.堆的存储方式 + 基本结论
（1）堆的存储方式
（2）堆中的基本结论
3.堆的创建
（1）逐个插入元素
（2）批量建堆
4.堆的基本操作
（1）插入操作
（2）删除操作
（3）返回堆顶元素
（4）判断堆是否为空
1.堆的初识 ——堆是一种特殊的完全二叉树，分为最大堆（大顶堆）和最小堆（小顶堆）。最大堆的每个节点的值都大于或等于其子节点的值，最小堆的每个节点的值都小于或等于其子节点的值。
堆常用于实现优先队列（PriorityQueue），在图算法（如Dijkstra最短路径算法和Prim最小生成树算法）中也有重要应用。（读者若有兴趣可以自行了解！）
堆的定义 ——堆是一种特殊的完全二叉树，满足以下两个条件：
完全二叉树：
除了最后一层，其他层的节点都是满的，并且最后一层的节点从左到右连续排列。（如图）
堆性质：
最大堆：每个节点的值都大于或等于其子节点的值。
最小堆：每个节点的值都小于或等于其子节点的值。
堆的这些性质使得堆顶元素（根节点）在最大堆中是最大值，在最小堆中是最小值。这样我们就大致的了解了什么是堆了！
2.堆的存储方式 + 基本结论 （1）堆的存储方式 从堆的概念可知，堆是一棵完全二叉树，通常情况下，堆是通过数组来实现，因为数组可以高效地访问任意位置的元素，并且通过简单的算术操作可以找到父节点和子节点的位置。（如左图a）
但是对于二叉树中非完全二叉树，则不适合使用顺序方式进行存储，因为为了能够还原二叉树，空间中必须要存储空节点，就会导致空间利用率比较低（如右图b）
——这样我们就知道了堆就是将链式结构的完全二叉树转换为数组形式进行存储。
（2）堆中的基本结论 那么了解完了堆的基本存储形式，接下来让我们看看堆中的基本结论，从上文中我们已经提及在堆中我们可以通过简单的算术操作可以找到父节点和子节点的位置，那么如何实现呢？
现在我们假设 i 为节点在数组中的下标，则有：
（1）如果i为0，则i表示的节点为根节点，否则i节点的双亲节点为 (i - 1)/2；
（2）如果2 * i + 1 小于节点个数，则节点i的左孩子下标为2 * i + 1，否则没有左孩子；
（3）如果2 * i + 2 小于节点个数，则节点i的右孩子下标为2 * i + 2，否则没有右孩子；
——读者可以根据上图进行自我验证！！！
这样我们就大致的了解了堆中的基本结论了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8153edbaceee49de2e53e1175a768fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/560aba718874b59c1101bfcbb3bd2e3b/" rel="bookmark">
			python—爬虫爬取电影页面实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个简单的爬虫实例，使用Python的requests库来发送HTTP请求，并使用lxml库来解析HTML页面内容。这个爬虫的目标是抓取一个电影网站，并提取每部电影的主义部分。
首先，确保你已经安装了requests和lxml库。如果没有安装，可以通过pip安装它们：
pip install lxml 安装好lxml库后，就可以在Python代码中通过from lxml import etree来导入etree模块，并使用它提供的各种功能。
然后，我们可以编写如下的爬虫脚本：
import re import fake_useragent import requests from lxml import etree if __name__ == '__main__': # UA伪装 head = { "User-Agent": fake_useragent.UserAgent().random } fp = open("./douban", "w", encoding="utf8") # 1.url for i in range(0,250,25): url = "https://movie.douban.com/top250?start={i}&amp;filter=" # 2.发送请求 response = requests.get(url, headers=head) # 3.获取想要的数据 res_text = response.text # 4.数据解析 tree = etree.HTML(res_text) # 定位所有的li标签 li_list = tree.xpath("//ol[@class='grid_view']/li") for li in li_list: film_name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/560aba718874b59c1101bfcbb3bd2e3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4101fc8cd6ddd95123302fa2870c27cf/" rel="bookmark">
			XMl基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 使⽤Mybatis的注解⽅式，主要是来完成⼀些简单的增删改查功能. 如果需要实现复杂的SQL功能，建议使⽤XML来配置映射语句，也就是将SQL语句写在XML配置⽂件中. 之前，我们学习了，用注解的方式来实现MyBatis
接下来我们学习XML的⽅式
MyBatis XML的⽅式需要以下两步 配置数据库连接字符串和MyBatis 写持久层代码 MyBatis XML配置⽂件 配置连接字符串和MyBatis 此步骤需要进⾏两项设置，数据库连接字符串设置和 MyBatis 的 XML ⽂件配置。 # 数据库连接配置 spring: datasource: url: jdbc:mysql://127.0.0.1:3306/mybatis_test? characterEncoding=utf8&amp;useSSL=false username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # 配置 mybatis xml 的⽂件路径，在 resources/mapper 创建所有表的 xml ⽂件 //mapper是目录,自己设置 //文件名的后缀部分必须是Mapper.xml不能修改,前面可以添加内容 //这里的*代表通配符 mybatis.mapper-locations=classpath:/myBatis/*Mapper.xml mybatis: mapper-locations: classpath:mapper/**Mapper.xml 写持久层代码 持久层代码分两部分 ⽅法定义 Interface ⽅法实现: XXX.xml 添加 mapper 接⼝ 数据持久层的接⼝定义： import com.example.demo.model.UserInfo; import org.apache.ibatis.annotations.Mapper; import java.util.List; @Mapper public interface UserInfoXMlMapper { List&lt;UserInfo&gt; queryAllUser(); } 添加 UserInfoXMLMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4101fc8cd6ddd95123302fa2870c27cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb795c0deca86b99b406f7491a03c707/" rel="bookmark">
			python —— 异常、模块与包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 了解异常异常的捕获方法python模块python包安装第三方包 了解异常 什么是异常
当检测到一个错误时，python解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的“异常”，也就是我们常说的BUG
bug单词的诞生
早期计算机采用大量继电器工作，马克二型计算机就是这样的。
1945年9月9日，下午三点，马克二型计算机无法正常工作了，技术人员试了很多办法，最后定位到第70号继电器出错，负责人哈珀观察这个出错的继电器，发现一只飞蛾躺在中间，已经被继电器打死，她小心地用镊子将蛾子夹出来，用透明胶布贴到“事件记录本”中，并注明“第一个发现虫子的实例”自此之后，引发软件失效的缺陷，便被称为Bug。
异常演示
异常的捕获方法 为什么要捕获异常
世界上没有完美的程序，任何程序在运行的过程中，都有可能出现：异常，也就是bug，
导致程序无法完美运行下去。
我们要做的，不是求程序完美运行。
而是在力所能及的范围内，对可能出现的bug，进行提前准备、提前处理。
这种行为我们称之为：异常处理（捕获 异常）
当我们的程序遇到了BUG,那么接下来有两种情况:
① 整个程序因为一个BUG停止运行
② 对BUG进行提醒,整个程序继续运行
显然在之前的学习中,我们所有的程序遇到BUG就会出现①的这种情况，也就是整个程序直接奔溃但是在真实工作中，我们肯定不能因为一个小的BUG就让整个程序全部奔溃,也就是我们希望的是达到② 的这种情况那这里我们就需要使用到捕获异常
捕获异常的作用在于:提前假设某处会出现异常，做好提前准备，当真的出现异常的时候，可以有后续手段。
异常的传递
python模块 什么是模块
Python 模块(Module)，是一个 Python 文件，以 .py 结尾.模块能定义函数，类和变量，模块里也能包含可执行的代码.
模块的作用:python中有很多各种不同的模块，每一个模块都可以帮助我们快速的实现一些功能，比如实现和时间相关的功能就可以使用time模块我们可以认为一个模块就是一个工具包，每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能.
大白话:模块就是一个Python文件，里面有类、函数、变量等，我们可以拿过来用(导入模块去使用)
模块的导入方式
常用的组合形式如:
● import 模块名
● from 模块名 import 类、变量、方法等
● from 模块名 import *
● import 模块名 as 别名
● from 模块名 import 功能名 as 别名
python包 什么是python包
从物理上看，包就是一个文件夹，在该文件夹下包含了一个**init.py文件**，该文件夹可用于包含多个模块文件
从逻辑上看，包的本质依然是模块
包的作用：
当我们的模块文件越来越多时，包可以帮助我们管理这些模块，包的作用是包含多个模块，但包的本质依然是模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb795c0deca86b99b406f7491a03c707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6176f024c86e6da57d08ec258018b1/" rel="bookmark">
			C&#43;&#43;初阶学习第二弹——入门学习C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.引用
1.1引用的实质
1.2 引用的用法
1.3引用和指针的不同点:
2，内敛函数
3.auto关键字
在上面一章讲解了C++的一些基本语法和命名空间、缺省参数，函数重载和的概念，这篇，我们将讲解C++引用、内敛函数的知识。
1.引用 1.1引用的实质 在我们使用C语言时，遇到一个需要传参的函数时，经常要用到指针这个概念，将一个数据的地址传过去，这样才能在函数中将这个数据进行修改，这个操作是有些繁琐的，在C++中，我们引入了引用的概念，接下来我们就讲解一下引用的用法
引用是对一个变量定义了一个新的名字，而不是定义了一个新的变量，引用的形式就是在一个类型后加一个&amp;
引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空 间，它和它引用的变量共用同一块内存空间。 1.2 引用的用法 注意事项：
1. 引用在 定义时必须初始化
2. 一个变量可以有多个引用
3. 引用一旦引用一个实体，再不能引用其他实体
1、引用修改原来值
2、引用做参数
3、引用做返回值
注意：如果函数返回时，出了函数作用域，如果返回对象还在(还没还给系统)，则可以使用 引用返回，如果已经还给系统了，则必须使用传值返回。
1.3引用和指针的不同点: 1. 引用概念上定义一个变量的别名，指针存储一个变量地址。 、
2. 引用在定义时必须初始化，指针没有要求
3. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何 一个同类型实体
4. 没有NULL引用，但有NULL指针
5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32 位平台下占4个字节)
6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小 2，内敛函数 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调 用建立栈帧的开销，内联函数提升程序运行的效率。
如果在上述函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的 调用。
特性：
1. inline是一种以空间换时间的做法，如果编译器将函数当成内联函数处理，在编译阶段，会 用函数体替换函数调用，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运行效率。
2. inline对于编译器而言只是一个建议，不同编译器关于inline实现机制可能不同，一般建 议：将函数规模较小(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、不是递归、且频繁调用的函数采用inline修饰，否则编译器会忽略inline特性。
3.inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址 了，链接就会找不到。
3.auto关键字 auto关键字是用来方便我们定义变量的，它的用法就是将一个类型过长或者位置类型的变量
通过auto来定义，编译器会根据实际情况自行处理
比如：
类型过长和复杂的时候就可以使用auto
std::map&lt;std::string, std::string&gt;::iterator a; auto b = a; 还有不知道是什么类型变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c6176f024c86e6da57d08ec258018b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f946ea0e65ef13d46888e25a9565d803/" rel="bookmark">
			深入分析 Android ContentProvider (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深入分析 Android ContentProvider (一)1. Android 中的 ContentProvider 设计说明1.1. ContentProvider 的设计初衷1.2. ContentProvider 的基本结构1.3. ContentProvider 的实现示例：实现一个简单的 ContentProvider 1.4. ContentProvider 的使用 2. ContentProvider 的设计优势3. ContentProvider 的注意事项4. 总结 深入分析 Android ContentProvider (一) 1. Android 中的 ContentProvider 设计说明 ContentProvider 是 Android 中四大组件之一，主要用于在不同应用之间共享数据。ContentProvider 提供了一个一致的接口，使得应用能够以一种受控和安全的方式访问和修改存储的数据。通过 ContentProvider，数据可以被跨进程共享，而不必将数据直接暴露给其他应用。
1.1. ContentProvider 的设计初衷 数据共享：在 Android 中，应用之间的直接数据访问是不允许的。ContentProvider 提供了一种标准化的方式，使得应用可以安全地共享数据。数据封装：通过 ContentProvider，数据存取逻辑可以封装在一个单独的组件中，其他组件只需通过 ContentProvider 提供的接口进行数据操作。统一接口：ContentProvider 提供了一个统一的接口，支持多种数据存取方式（如插入、删除、更新、查询），并且支持对数据进行事务操作。 1.2. ContentProvider 的基本结构 一个典型的 ContentProvider 包括以下几个部分：
URI：统一资源标识符，用于定位 ContentProvider 中的数据。MIME 类型：用于标识返回的数据类型。数据存储：实际存储数据的地方，如数据库、文件等。数据操作方法：用于操作数据的标准方法，如 query、insert、update 和 delete。 1.3. ContentProvider 的实现 要实现一个 ContentProvider，需要继承 ContentProvider 类并实现其抽象方法。以下是一个简单的示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f946ea0e65ef13d46888e25a9565d803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c41db2830543885cc2ef15e2daeaf0/" rel="bookmark">
			Go: IM系统接入ws进行消息发送以及群聊功能 (5)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在即时通讯（IM）系统中，实现多媒体消息（如文本、表情包、拍照、图片、音频、视频）的实时传输是一项核心功能随着HTML5和WebSocket技术的发展，现代Web应用能够支持更高效、更实时的通信方式本文将详细探讨如何使用Go语言结合WebSocket技术，在IM系统中实现多媒体消息的发送和接收 基于MVC的目录设计 im-project ├── go.mod ├── main.go 主程序 ├── ctrl 控制器层 │ └── chat.go ├── views 模板层 │ └── chat │ ├── foot.html │ └── x.html 主程序 main.go 核心代码
package main import ( "net/http" "im-project/ctrl" ) func main() { // 1. 绑定请求和处理函数 http.HandleFunc("/chat", ctrl.Chat) http.HandleFunc("/attach/upload", ctrl.Upload) // 2. 指定目录的静态文件 http.Handle("/asset/",http.FileServer(http.Dir("."))) http.Handle("/mnt/",http.FileServer(http.Dir("."))) // 3. 启动 http.ListenAndServe(":80",nil) } 控制器 ctrl/attach.go
package ctrl import ( "net/http" "im-project/util" "os" "strings" "fmt" "time" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0c41db2830543885cc2ef15e2daeaf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f9158e04b59d63d8a0f43b7387fe2b/" rel="bookmark">
			开源模型应用落地-FastAPI-助力模型交互-进阶篇-中间件（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 FastAPI 的高级用法可以为开发人员带来许多好处。它能帮助实现更复杂的路由逻辑和参数处理，使应用程序能够处理各种不同的请求场景，提高应用程序的灵活性和可扩展性。
在数据验证和转换方面，高级用法提供了更精细和准确的控制，确保输入数据的质量和安全性。它还能更高效地处理异步操作，提升应用程序的性能和响应速度，特别是在处理大量并发请求时优势明显。
此外，高级用法还有助于更好地整合数据库操作、实现数据的持久化和查询优化，以及实现更严格的认证和授权机制，保护应用程序的敏感数据和功能。总之,掌握 FastAPI 的高级用法可以帮助开发人员构建出功能更强大、性能更卓越、安全可靠的 Web 应用程序。
本篇学习FastAPI中高级中间件的相关内容，包括添加ASGI中间件、集成的中间件以及一些具体中间件的用法。
二、术语 2.1. middleware函数 middleware函数（中间件）它在每个请求被特定的路径操作处理之前，以及在每个响应返回之前工作。可以用于实现多种通用功能，例如身份验证、日志记录、错误处理、请求处理、缓存等。其主要作用是在请求和响应的处理过程中添加额外的处理逻辑，而无需在每个具体的路由处理函数中重复编写这些逻辑。
一般在碰到以下需求场景时，可以考虑使用中间件来实现：
身份验证：验证请求的身份，如检查 JWT token 或使用 OAuth2 进行验证；日志记录：记录请求和响应的日志，包括请求方法、URL、响应状态码等信息；错误处理：处理应用程序中的异常情况，捕获异常并返回自定义的错误响应；请求处理：对请求进行处理，例如解析请求参数、验证请求数据等；缓存：在中间件中检查缓存中是否存在请求的响应，如果存在则直接返回缓存的响应。 2.2.HTTPSRedirectMiddleware 强制所有传入请求必须是https或wss，否则将会被重定向。
2.3.TrustedHostMiddleware 强制所有传入的请求都正确设置的host请求头。
2.4.GZipMiddleware 处理任何在请求头Accept-Encoding中包含“gzip”的请求为GZip响应。
三、前置条件 3.1. 创建虚拟环境&amp;安装依赖 conda create -n fastapi_test python=3.10 conda activate fastapi_test pip install fastapi uvicorn 四、技术实现 4.1. 自定义中间件 # -*- coding: utf-8 -*- import uvicorn from fastapi import FastAPI, Request, HTTPException from starlette import status app = FastAPI() black_list = ['192.168.102.88'] @app.middleware("http") async def my_middleware(request: Request, call_next): client_host = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f9158e04b59d63d8a0f43b7387fe2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40a4ecfb15a4b7f716014e6e1eff0a0/" rel="bookmark">
			【C&#43;&#43;】类和对象（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页
创作不易，感谢大家的关注！
文章目录 ⭐一、类的默认成员函数💎二、构造函数⏱️三、析构函数🏝️ 四、拷贝构造函数🎄五、赋值运算符重载🏠六、取地址运算符重载🎉const成员 ⭐一、类的默认成员函数 定义：所谓的默认成员函数，就是用户没有显式实现，而编译器会自动生成的成员函数就被称为默认成员函数。
在一个类中，在我们不写的情况下编译器会自动生成以下六个默认成员函数。其中最重要的是前四个，而取地址重载可以作为了解即可。
💎二、构造函数 定义：构造函数是一个特殊的成员函数，其名字与类名相同，在创建类类型对象时由编译器自动调用，保证每一个对象成员都有初始值，并在对象的生命周期内只调用一次。
特点：
1.函数名与类名相同。
2.没有返回值。
3.对象实例化时系统会自动调用对应的构造函数。
4.构造函数可以重载。
功能：
构造函数不是用来构造对象的，它是来完成对象初始化的。
注意事项：
1.如果类中没有显式定义构造函数，那么C++编译器会自动生成一个无参的默认构造函数，一旦用户定义则编译器将不再生成。
2.无参构造函数、全缺省构造函数和当我们不写构造时编译器默认生成的构造函数，都被称为默认构造函
数。但是这三个函数有且仅有一个存在，不能同时存在。
演示代码：
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;iostream&gt; using namespace std; class Date { public: // 1.无参构造函数 Date() { _year = 1; _month = 1; _day = 1; } //2.带参构造函数 Date(int year, int month, int day) { _year = year; _month = month; _day = day; } //3.全缺省构造函数 Date(int year = 1, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; ⏱️三、析构函数 概念：与构造函数的功能相反，析构函数并不是完成对对象本身的销毁，C++规定对象在销毁时会自动调用析构函数，完成对象中资源的清理释放工作。特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40a4ecfb15a4b7f716014e6e1eff0a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11228a6add861c4ea255b5e0c8e01f03/" rel="bookmark">
			【C&#43;&#43;】STL之空间配置器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL之空间配置器 1. 什么是空间配置器2. 为什么需要空间配置器3. SGI-STL空间配置器实现原理3.1 一级空间配置器3.2 二级空间配置器3.2.1 内存池3.2.2 SGI-STL中二级空间配置器设计 3.3 SGI-STL二级空间配置器之空间申请3.4 SGI-STL二级空间配置器之空间回收3.3 空间配置器的默认选择3.4 空间配置器的再次封装3.5 对象的构造与释放 4. 与容器结合5.复习 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1. 什么是空间配置器 空间配置器，顾名思义就是为各个容器高效的管理空间(空间的申请与回收)的，在默默地工作。虽然在常规使用STL时，可能用不到它，但站在学习研究的角度，学习它的实现原理对我们有很大的帮助。
2. 为什么需要空间配置器 前面在模拟实现vector、list、map、unordered_map等容器时，所有需要空间的地方都是通过new申请的，虽然代码可以正常运行，但是有以下不足之处：
空间申请与释放需要用户自己管理，容易造成内存泄漏频繁向系统申请小块内存块，容易造成内存碎片频繁向系统申请小块内存，影响程序运行效率直接使用malloc与new进行申请，每块空间前有额外空间浪费申请空间失败怎么应对代码结构比较混乱，代码复用率不高未考虑线程安全问题 因此需要设计一块高效的内存管理机制
3. SGI-STL空间配置器实现原理 以上提到的几点不足之处，最主要还是：频繁向系统申请小块内存造成的。那什么才算是小块内存？SGI-STL以128作为小块内存与大块内存的分界线，将空间配置器其分为两级结构，一级空间配置器处理大块内存，二级空间配置器处理小块内存。
3.1 一级空间配置器 一级空间配置器原理非常简单，直接对malloc与free进行了封装，并增加了C++中
set_new_handle思想。
template &lt;int inst&gt; class __malloc_alloc_template { private: static void *oom_malloc(size_t); public: // 对malloc的封装 static void * allocate(size_t n) { // 申请空间成功，直接返回，失败交由oom_malloc处理 void *result = malloc(n); if (0 == result) result = oom_malloc(n); return result; } // 对free的封装 static void deallocate(void *p, size_t /* n */) { free(p);} // 模拟set_new_handle // 该函数的参数为函数指针，返回值类型也为函数指针 // void (* set_malloc_handler( void (*f)() ) )() static void (* set_malloc_handler(void (*f)()))() { void (* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return(old); } }; // malloc申请空间失败时代用该函数 template &lt;int inst&gt; void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n) { void (* my_malloc_handler)(); void *result; for (;;) { // 检测用户是否设置空间不足应对措施，如果没有设置，抛异常，模式new的方式 my_malloc_handler = __malloc_alloc_oom_handler; if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; } // 如果设置，执行用户提供的空间不足应对措施 (*my_malloc_handler)(); // 继续申请空间，可能就会申请成功 result = malloc(n); if (result) return(result); } } typedef __malloc_alloc_template&lt;0&gt; malloc_alloc; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11228a6add861c4ea255b5e0c8e01f03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015b874ad4d440e99e105c851b5b4683/" rel="bookmark">
			python实现发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python语言实现发送邮件的功能，如代码所示，可添加附件
import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.mime.application import MIMEApplication from email.utils import COMMASPACE from email.header import Header # 邮件服务器配置 SMTP_SERVER = 'smtp.163.com' #发送邮件服务器：smtp.qq.com，使用SSL，端口号465或587 SMTP_PORT = 587 SMTP_USER = '发件人@163.com' SMTP_PASSWORD = '邮箱授权码' # 收件人和邮件内容配置 TO = ['收件人@163.com'] SUBJECT = '邮件标题' BODY = '邮件正文' # 创建邮件对象 msg = MIMEMultipart() msg['From'] = SMTP_USER msg['To'] = COMMASPACE.join(TO) msg['Subject'] = Header(SUBJECT, 'utf-8') # 添加邮件正文 msg.attach(MIMEText(BODY, 'plain', 'utf-8')) # 添加附件 filename = '111.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015b874ad4d440e99e105c851b5b4683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f6edcb57e5c1a1240147808dbc8f9a/" rel="bookmark">
			【NLP】Jieba中文分词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jieba分词是一个用于中文文本分词的开源工具。它可以将一段连续的中文文本切分成一个一个的词语，这对于中文自然语言处理（NLP）任务如文本分类、情感分析、机器翻译等非常重要。Jieba分词具有以下特点：
支持三种分词模式： 精确模式：试图将句子最精确地切开，适合文本分析。全模式：把句子中所有的可以成词的词语都扫描出来，速度快，但不能解决歧义。搜索引擎模式：在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。 支持自定义词典：用户可以通过添加自定义词典来提高分词的准确性，尤其是对一些专有名词和新词的识别。内置多种分词词典：Jieba自带了多种分词词典，能够识别大量常用词汇。 Jieba基础使用 安装 可以使用pip安装Jieba：
pip install jieba 使用示例 import jieba # 精确模式 text = "我来到北京清华大学" seg_list = jieba.cut(text, cut_all=False) print("精确模式: " + "/ ".join(seg_list)) # 全模式 seg_list = jieba.cut(text, cut_all=True) print("全模式: " + "/ ".join(seg_list)) # 搜索引擎模式 seg_list = jieba.cut_for_search(text) print("搜索引擎模式: " + "/ ".join(seg_list)) 输出：
精确模式: 我/ 来到/ 北京/ 清华大学 全模式: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学 搜索引擎模式: 我/ 来到/ 北京/ 清华/ 华大/ 大学/ 清华大学 通过这种方式，Jieba可以高效地将中文文本分割成词语，为后续的自然语言处理任务提供基础支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f6edcb57e5c1a1240147808dbc8f9a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/132/">«</a>
	<span class="pagination__item pagination__item--current">133/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/134/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>