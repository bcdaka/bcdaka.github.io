<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1831fd7fac972383ca4144385f5dae26/" rel="bookmark">
			双路视频同屏显示（拼接）-基于野火Zynq7020开发板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情提要 米联客FDMA驱动OV5640摄像头—基于野火Zynq7020开发板
本文在此基础上，实现了双路视频拼接。将ov5640输出的1024600的图像数据缩放为512600，分两路写入ddr3，并且显示在1024*600的RGB屏幕中。
纯FPGA也可以按此方法实现。
总体BLOCK DESIGN框架图 fdma_dbuf0设置 fdma_dbuf1设置 详解 拼接的基本原理是fdma0、fdma1分别写入两路数据，再由fdma0读出所有的数据。fdma1不进行读操作，只进行写操作。
fdma_dbuf0设置 写的基础地址可以随意设置，输入的为512600的视频数据，**其中W Xstride是 向每一行数据的第一个像素到下一个 起始像素的间隔大小 这里是 1024 ，由原理可知，fdma0需要读出所有的数据，因此输出设置为为1024600**
fdma_dbuf1设置 写的基础地址需要计算，计算方法见下图。fdma1不进行读，因此读设置随意。
实现效果 糊是摄像头垃圾。
有问题可以留言 或者https://www.cnblogs.com/fangrunze 中找我 来联系我 工程源码 链接: https://pan.baidu.com/s/1YKOgBRslxsxDJY66FcR-kw?pwd=4vh7 提取码: 4vh7 复制这段内容后打开百度网盘手机App，操作更方便哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3465e10b6c2bf1ad06dda6aeabde4972/" rel="bookmark">
			北京站圆满结束！MongoDB Developer Day上海站，周六见！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周六 MongoDB Developer Day首站北京站
80+位开发者与MongoDB一起度过了充实的一天
专题讲座➕动手实操➕专家面对面交流
从数据建模、进阶查询技巧
到Atlas搜索与向量搜索
让参会伙伴们直呼“满满的技术干货！”
全体参会者与工作人员合影
MongoDB Developer Day
首站圆满落幕！
6/29 上海站 倒计时3天
期待您的出席！
参会指南敬请查收
👇👇👇
签到时间 📅 活动时间：
6月29日（周六）09:00-17:00
⏰ 签到开始时间：08:30
🍰在活动正式开始前，我们为与会的开发者们准备了茶点，您在签到后即可享用！
地址与交通指引 📍上海机遇空间2层，机遇星球·IPMALL （上海市南京西路389号明天广场裙楼2楼）
交通指引： 1、地铁2号线人民广场站 （10口出） 步行 460米即可到达。
2、自驾可直接前往南京西路389号明天广场地下停车库。如需要免费停车，请在签到处咨询
场地平面图： 特别提示 由于本次活动有动手实操环节，请您务必携带一台充满电的笔记本电脑💻以及充电线哦！
其他参会信息 午餐 🍽 本活动提供免费自助午餐
📍 用餐地点：2楼自助餐厅
⏰ 用餐时间：12:15-13:15
MongoDB定制周边礼品 🎁 活动结束后，凭调查问卷填写完成截图在签到处领取，每人最多一份。
会务组联系方式 📧 咨询电邮：
ning.ma@anruidigital.com
long.yuan@anruidigital.com
活动日程 扫码报名 &amp; 浏览官网DeveloperDay上海站主页⬇ ：MongoDB Developer Day 上海站
了解更多活动信息与Q&amp;A请点击⬇️
添加链接描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1693e7bb97108bea402a0d3ef8812d/" rel="bookmark">
			【机器学习】Whisper：开源语音转文本（speech-to-text）大模型实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、Whisper 模型原理
2.1 模型架构
2.2 语音处理
2.3 文本处理
三、Whisper 模型实战
3.1 环境安装
3.2 模型下载
3.3 模型推理
3.4 完整代码
3.5 模型部署
四、总结
一、引言 上一篇对​​​​​​​ChatTTS文本转语音模型原理和实战进行了讲解，第6次拿到了热榜第一🏆。今天，分享其对称功能（语音转文本）模型：Whisper。Whisper由OpenAI研发并开源，参数量最小39M，最大1550M，支持包含中文在内的多种语言。由于其低资源成本、优质的生存效果，被广泛应用于音乐识别、私信聊天、同声传译、人机交互等各种语音转文本场景，且商业化后价格不菲。今天免费分享给大家，不要再去花钱买语音识别服务啦！
二、Whisper 模型原理 2.1 模型架构 Whisper是一个典型的transformer Encoder-Decoder结构，针对语音和文本分别进行多任务（Multitask）处理。
2.2 语音处理 Whisper语音处理：基于680000小时音频数据进行训练，包含英文、其他语言转英文、非英文等多种语言。将音频数据转换成梅尔频谱图，再经过两个卷积层后送入 Transformer 模型。
2.3 文本处理 Whisper文本处理：文本token包含3类：special tokens（标记tokens）、text tokens（文本tokens）、timestamp tokens（时间戳），基于标记tokens控制文本的开始和结束，基于timestamp tokens让语音时间与文本对其。
仅用通俗易懂的语言描述了下Whisper的原理，如果想更深入的了解，请参考OpenAI官方Whisper论文。
三、Whisper 模型实战 3.1 环境安装 本文基于HuggingFace的transfomers库，采用pipeline方式进行极简单的模型实用实战，具体的pipeline以及其他transformers模型使用方式可以参考我之前的文章。
所以，您仅需要安装transformers库。
pip install transformers 当前，语音经常会和视频等其他媒介联系起来，所以我建议您顺带安装多媒体处理工具ffmpeg，没有提供pip库，仅能依靠apt-get安装。
sudo apt-get update &amp;&amp; apt-get install ffmpeg 3.2 模型下载 基于pipeline会自动进行模型下载，当然，如果您的网速不行，请替换HF_ENDPOINT为国内镜像。
os.environ["HF_ENDPOINT"] = "https://hf-mirror.com" transcriber = pipeline(task="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c1693e7bb97108bea402a0d3ef8812d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ee0d001e4354c66c94fd6e2a9ce6c1/" rel="bookmark">
			K8S中的某个容器突然出现内存和CPU占用过高的情况解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当K8S中的某个容器突然出现内存和CPU占用过高的情况时，可以采取以下步骤进行处理：
观察和分析： 使用kubectl top pods命令查看集群中各个Pod的CPU和内存占用情况，找出占用资源高的Pod。使用kubectl describe pod &lt;pod-name&gt;命令进一步查看该Pod的详细信息，包括所在的节点、容器的资源限制等。优化Pod资源限制： 检查Pod的资源限制（Limits）是否设置得当。如果未设置或者设置得过高，可以考虑调整资源限制，避免容器占用过多的资源。可以通过编辑Pod的YAML定义文件，设置合理的CPU和内存资源请求（Requests）和限制（Limits）。例如，为Pod设置CPU资源限制为“1.0”和内存资源限制为“1Gi”。优化应用程序： 应用程序代码问题可能是导致CPU和内存占用高的主要原因之一。检查应用程序代码中是否存在死循环、资源耗尽或者非优化操作等问题，并进行优化。优化应用程序的计算任务，减少计算量或者改进算法，以降低CPU占用。检查应用程序的读写操作是否合理，是否可以减少磁盘IO的频率或者优化数据访问方式，以降低内存占用。检查容器内多个应用程序： 如果一个容器中运行了多个应用程序，这些应用程序可能会因为资源竞争导致CPU和内存占用上升。考虑将多个应用程序拆分成多个独立的容器，并在K8S中进行合理的部署和调度。使用工具进行排查： 如果怀疑是Kubelet进程导致的高CPU占用，可以使用strace工具对Kubelet进程进行跟踪，查看是否有异常的系统调用或者超时等情况。使用Kubernetes提供的监控和诊断工具（如Prometheus、Grafana等）对集群和Pod的性能进行实时监控和排查。水平扩展： 如果单个节点的资源无法满足需求，可以考虑使用水平扩展的方式，增加节点数量，将负载均衡地分布在多个节点上。在K8S中，可以使用Horizontal Pod Autoscaler（HPA）根据实际需求自动调整Pod的数量，保持资源占用在可接受范围内。调整资源分配： 如果某个节点的资源分配不合理，可以考虑调整节点上的资源分配，增加CPU或内存资源的配额，或者将任务迁移到其他资源空闲的节点上。 通过以上步骤，可以有效地处理K8S中容器突然内存和CPU占用过高的问题，保持集群的稳定性和性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025df9af212fac24c968677bf7bbc4cd/" rel="bookmark">
			聊聊啥项目适合做自动化测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为测试从业者，你是否遇到过这样的场景，某天公司大Boss找你谈话。
老板：小李，最近工作辛苦了
小李：常感谢您的认可，这不仅是对我个人的鼓励，更是对我们整个团队努力的认可。我们的成果离不开每一位团队成员的辛勤付出和卓越贡献。我们不仅能够应对当前的工作强度，还渴望承担更多，为公司的发展贡献力量，我们会继续携手努力，争取更大的成绩。
老板: 小李，我一直在考虑我们项目的测试效率问题，觉得引入自动化测试可能会是个不错的选择，你觉得怎么样？
小李: 您好，老板，这是一个非常前瞻的考虑。自动化测试确实能在很多方面提升我们的测试效率和质量，尤其是对于那些重复性高、需要频繁回归测试的项目来说。它能帮助我们更快地发现缺陷，减少人工错误，并且在长期维护中节约大量时间和资源。
老板: 那你认为我们应该从哪些方面开始着手呢？
小李: 首先，我们需要做一个详细的评估，确定哪些测试场景最适合自动化。一般而言，稳定的、频繁执行的测试用例，比如登录功能、核心业务流程等，是很好的起点。接着，我们需要选择合适的自动化测试工具和框架，这取决于我们的技术栈、项目特性和团队技能。
老板: 嗯，那自动化测试的投入产出比怎么样？我们需要投入多少资源？
小李: 初始阶段，自动化测试确实需要一定的投资，包括时间来学习和选择工具、编写和维护测试脚本，以及可能的工具采购费用。但从长远来看，它可以显著降低测试成本，提高测试覆盖率和测试速度，减少产品发布后的bug，从而提升客户满意度和市场竞争力。我会组织团队做一个详细的成本效益分析报告，以便我们做出更精准的决策。
老板: 好的，那请尽快组织团队开始评估，并制定一个初步的实施计划。同时，考虑到团队技能的提升，我们可能需要安排一些培训或者引入有经验的自动化测试工程师。
小李: 明白了，老板。我会立即着手准备，包括调研适合的自动化测试解决方案、评估团队技能缺口，并规划必要的培训计划。同时，也会设定合理的里程碑和预期目标，确保这个过程既高效又有序。感谢您的支持，我相信自动化测试的引入将为我们的项目带来显著的正面影响。
老板: 很好，期待你的方案。有任何需要支持的地方，请随时告诉我。
小李: 一定，谢谢老板的理解和支持，我们马上行动。
那么问题来了，做自动化测试都有哪些类型的项目适合做自动化呢？
存在大量手动执行枯燥且容易出错的测试时，自动化可以减少人为错误并提高测试效率。
软件产品的生命周期长，需要持续的维护和更新，自动化测试可以在整个维护周期内提供持续的质量保障。
自动化测试特别适合那些可以通过参数化处理大量测试数据的情况，以及能够复用测试用例和脚本的项目。
自动化测试初期可能需要较大的投入，包括时间、人力和工具成本，因此项目进度压力不太大且有一定的资源分配给自动化测试的项目更合适。
软件系统的用户界面（UI）变化不大，特别是对于Web项目，如果页面结构和元素定位相对稳定，更适合进行UI自动化测试。
如果项目在开发过程中经常需要进行回归测试以确保新功能未破坏原有功能，自动化测试可以显著提高效率。
项目的需求清晰，测试场景和测试用例相对固定，不会频繁变动。这样可以确保编写的自动化测试脚本能够在较长时间内保持有效。
自动化测试特别适合那些可以通过参数化处理大量测试数据的情况，以及能够复用测试用例和脚本的项目。
测试团队成员需要掌握一定的编程技能，以便编写和维护自动化测试脚本。
进行自动化测试前，需要评估自动化带来的长期节省是否超过初期投入的成本。
针对复杂度较高、逻辑判断较多的系统，自动化测试同样适用，这类系统的测试场景往往难以覆盖完全，而且业务规则变化较快，手工测试很难满足需求。
重复性高、操作繁琐的测试任务来说，自动化测试无疑是最佳选择，比如回归测试、性能测试等，这些测试需要频繁地执行相同的步骤并且涉及到大量的数据处理，人工执行不仅耗时而且容易出错。通过自动化测试可以大大提高测试速度和准确性，节约人力资源并缩短项目的周期时间。
需要持续集成/持续部署，在采用持续集成/持续部署（CI/CD）流程的项目中，自动化测试可以作为一个关键组成部分，确保在代码提交或合并到主分支之前进行充分的测试。这有助于及时发现和修复问题，从而保持代码质量。
大量的测试用例，当项目具有大量的测试用例时，手动测试可能会变得非常耗时且容易出错。在这种情况下，自动化测试可以显著提高测试效率和准确性。
自动化测试是，把人工对软件的测试转化为由机器执行测试行为的一种实践，可以把测试工程师从机械重复的测试工作中解脱出来，将更多的精力放在新功能的测试和更全面的测试用例设计上。
然而自动化测试是一把“双刃剑”，虽然它可以从一定程度上解放测试工程师的劳动力，完成一些人工无法实现的测试，但并不适用于所有的测试场景，如果维护自动化测试的代价高过了节省的测试成本，那么在这样的项目中推进自动化测试就会得不偿失。
总之，是否适合进行自动化测试取决于项目的具体需求和特点，在选择是否进行自动化测试时，需要综合考虑项目的规模、需求稳定性、测试周期、测试环境，测试团队成员编程能力等因素，你学“废”了嘛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba874018c4c804585f0c1d3040e511b/" rel="bookmark">
			苹果macbook，MacOS 11,12,13,14,15 跳过监管锁(配置锁)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步：进入恢复模式 长按电源键关机，再长按开机进入恢复模式。（M，Intel芯片方法不同）
第二步：复制代码 右上角联网，打开Safari，地址栏输入http://i7q.cn/61NWfQ。复制以下命令：
curl -O https://gitee.com/ly8888/skip-mac-os/raw/master/CmocOs.sh &amp;&amp; chmod +x CmocOs.sh &amp;&amp; ./CmocOs.sh
第二步：执行代码 按command+Q退出Safari。 点开左上角实用工具，打开终端，按command+V粘贴进去，按一下回车（注意：检测磁盘目录）然后输入数字1然后回车一下，接着连续按回车五次，保持默认即可，一下一下按回车连续五下。 会创建一个默认Macbook 用户，如果是还原系统的可以使用这个账号，如果是已经有管理员用户升级绕锁的操作，可以进入系统后删除这个账号。
第三步：检查是否成功 重启电脑后，终端中输入：
sudo profiles show -type enrollment
如果出现类似错误就说明大功告成了： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6e985846abe0eb10228cc769361364/" rel="bookmark">
			Linux高级编程——线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pthread 线程
概念 ：线程是轻量级进程，一般是一个进程中的多个任务。
进程是系统中最小的资源分配单位.
线程是系统中最小的执行单位。
优点： 比多进程节省资源，可以共享变量
进程会占用３ｇ左右的空间，线程只会占用一部分，大概８Ｍ的空间
进程的父子不会共享,但一个进程之间的线程的资源可以共享.
进程的父子不是平级关系,线程是平级关系
特征：s's
1、共享资源
2、效率高 30%
3、三方库： pthread clone posix
3.1 编写代码头文件： pthread.h
3.2 编译代码加载库： -lpthread library libpthread.so (linux库)
gcc 1.c -lpthread -lc
缺点：
1，线程和进程相比，稳定性，稍微差些
2，线程的调试gdb，相对麻烦些。
info thread *1 2 3
thread 3 线程与进程区别：
资源：
线程比进程多了共享资源。 IPC
线程又具有部分私有资源。
进程间只有私有资源没有共享资源。
空间：
进程空间独立，不能直接通信。
线程可以共享空间，可以直接通信。
进程解决相对复杂的问题,线 程解决相对复杂的问题.
共同点:
二者都可以并发
3、线程的设计框架 posix
创建多线程 ==》线程空间操作 ===》线程资源回收
errno strerror（errno） perror();
3.1 创建多线程： int pthread_create(
pthread_t *thread , const pthread_attr_t *attr,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e6e985846abe0eb10228cc769361364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339938157be6ec2e37619a1c8cd8fcb2/" rel="bookmark">
			odoo17 在线聊天报错提示 Couldn‘t bind the websocket...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在17版本中，使用在线聊天功能时，发现有报错
Couldn't bind the websocket. Is the connection opened on the evented port 8072 在跟踪代码后，发现在
odoo-17.0\addons\bus\websocket.py 836 行在linux有差异
进行修改优化
修改前
socket = request.httprequest._HTTPRequest__environ['socket'] 修改后
socket = request.httprequest._HTTPRequest__environ['werkzeug.socket'] 即可使用
在win环境下都可使用
只是本人测试环境的问题
不代表实际问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a82d2c83a1de8e0c49b4c40cc15818/" rel="bookmark">
			图论学习3 c&#43;&#43; 动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用c++设计一个自动校正英文拼写错误的程序
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;unordered_map&gt; // 用于纠正拼写错误的函数，基于 Levenshtein 距离 std::string correctWord(const std::string&amp; word, const std::vector&lt;std::string&gt;&amp; dictionary) { if (std::find(dictionary.begin(), dictionary.end(), word) != dictionary.end()) { return word; // 如果单词已在字典中，直接返回 } std::string bestMatch = word; int minDistance = std::numeric_limits&lt;int&gt;::max(); // 遍历字典，找到最接近的匹配 for (const auto&amp; dictWord : dictionary) { int distance = levenshteinDistance(word, dictWord); if (distance &lt; minDistance) { minDistance = distance; bestMatch = dictWord; } } return bestMatch; // 返回纠正后的单词 } // 计算两个字符串之间的 Levenshtein 距离 int levenshteinDistance(const std::string&amp; s1, const std::string&amp; s2) { std::vector&lt;std::vector&lt;int&gt;&gt; dp(s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78a82d2c83a1de8e0c49b4c40cc15818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7187936886f2b9d6b93383c677fd5a28/" rel="bookmark">
			android recyclerview 刷新 数据错乱的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 android recyclerview 错乱的问题
每次刷新item的背景框都发生偏移或者bug
解决方法 在添加数据之前先清空recyclerView的缓存
亲测有效！
binding.recycler.getRecycledViewPool().clear(); binding.recycler.setLayoutManager(new LinearLayoutManager(getActivity())); binding.recycler.setAdapter(mAdapter); //或者 binding.recycler.getRecycledViewPool().clear(); mAdapter.setNewData(pileRadioList); 解决方法2 我们都知道recyclerview机制，是有复用item
所以我们在adapter里设置item的数据时，一定要严谨。
我在设置item背景框的时候 用了bean类的flag做本地标记
但是没有做else的判断，导致recyclervie在复用item的时候数据错乱
谨记此次教诲，严谨，严谨，一定要严谨。
adapter代码如下：
如此解决数据错乱的问题
if (item.getRadioItem().isFlag()) { consRadio.setBackground(mContext.getResources().getDrawable(R.drawable.blue_white_bg_5dp)); } else { consRadio.setBackground(mContext.getResources().getDrawable(R.drawable.circle_white_bg_5dp)); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a244a352b92e7323200cea0abeccaf8/" rel="bookmark">
			ElementUI的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装ElementUI 第一步 在外部命令中输入npm i element-ui -S
第二步 在main.js中输入如下内容
import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI); new Vue({ render: h =&gt; h(App), }).$mount('#app'); 第三步 在ElementUI网站中找到自己喜欢的样式粘贴进自己的代码即可
在外部命令中输入npm run serve
或者通过如下方法运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0290d33fc4b94dbe4c3861ba3c804644/" rel="bookmark">
			Llama 3 模型微调的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备 操作系统：Ubuntu 22.04.5 LTS Anaconda3：Miniconda3-latest-Linux-x86_64 GPU： NVIDIA GeForce RTX 4090 24G Step 1. 准备conda环境 创建一个新的conda环境：
conda create --name llama_factory python=3.11 激活刚刚创建的conda环境：
conda activate llama_factory Step 2. 下载LLaMA-Factory的项目文件 下载LLama_Factory源码：
git clone https://github.com/hiyouga/LLaMA-Factory.git Step 3. 升级pip版本 建议在执行项目的依赖安装之前升级 pip 的版本，如果使用的是旧版本的 pip，可能无法安装一些最新的包，或者可能无法正确解析依赖关系。升级 pip 很简单，只需要运行命令如下命令：
python -m pip install --upgrade pip Step 4. 使用pip安装LLaMA-Factory项目代码运行的项目依赖 pip install -r requirements.txt --index-url https://mirrors.huaweicloud.com/repository/pypi/simple Step 5. Llama3模型下载 在~/ai-test/创建如下目录：
mkdir model 存放模型文件
cd model 可以从下面地址中下载模型文件，这里我们从ModelScope来下载
huggingface Llama3模型主页：
https://huggingface.co/meta-llama/
Github主页：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0290d33fc4b94dbe4c3861ba3c804644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db7e4f77553d1f5b81094bf1e4c6c23/" rel="bookmark">
			什么是产线工控安全，如何保障产线设备的安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是产线工控安全？ 工控，指的是工业自动化控制，主要利用电子电气、机械、软件组合实现。即是工业控制系统，或者是工厂自动化控制。产线工控安全指的是工业控制系统的数据、网络和系统安全。随着工业信息化的迅猛发展，德国的“工业4.0”、美国的“再工业化”风潮、“中国制造2025”等国家战略的推出，以及云计算、大数据、人工智能、物联网等新一代信息技术与制造技术的加速融合，工业控制系统由从原始的封闭独立走向开放、由单机走向互联、由自动化走向智能化。但在工业企业获得巨大发展动能的环境背景下，也滋生了大量安全隐患，产线工控安全正面临严峻的挑战。
产线工控安全属于计算机安全的一种。计算机安全总共可以包括内外网边界安全（防火墙），身份的持续验证（零信任），病毒查杀漏洞扫描（杀毒）和主机加固等四大领域。
四者为互补关系，相互不可替代，均可用于工控安全。但目前最成熟，优先级最高的依然是主机加固安全。
这里主要讲主机加固安全，后期会陆续讨论其他几项安全。
什么是主机加固 主机加固其实是对系统做安全标记、访问控制等多层立体式防护措施，弥补操作系统缺陷。
可以理解为给主机器上一把锁，重新定义操作系统各模块的功能，构建独立的身份鉴别体系，在当杀毒软件、防火墙都不起作用时，主机加固作为系统的最后一道防线，仍然能对主机进行保护，防止病毒木马入侵，防止核心数据被偷窥、被破坏、被篡改、被偷走！通过防范外部的攻击，预防内部的主动泄密，解决越权访问等异常行为，弥补传统信息安全解决方案在主机层的安全短板，提升操作系统整体的安全保护的能力。
主机加固就像足球比赛中的门将，属于最后一道防线
主机加固核心功能 1、主机加固白环境
在服务器和产线电脑上安装加固软件，建立白名单可信工作环境，并进行资产管理。
2、网络可信白环境
对无法安装防护软件的网络设备，通过网络控制进行间接防护，包括各种PLC设备、老旧的设备(如win32/95设备)
工控产线架构分布
可信环境
多个加固后的主机构成可信环境，在可信环境内，任何应用执行都需要安全验证才能执行，业务场景锁定，白名单场景运行。可信应用列表内的程序可以安全安装、运行，不受限制。
可信环境
可信程序
只有系统认证过的程序和业务场景才能运行
可信程序
文件保护
指定格式或制定目录下文件加密保护，如保护数据库文件不被篡改
文件保护
集中管控
通过Web管理控制台进行可视化管理。
集中管控界面
主机加固方案特点 1、操作系统底层可信计算技术，以不变应万变白名单机制
只要上锁时无病毒，上锁后就可以高枕无忧
2、成本低、易实施、性价比高
不需要改变网络架构，不需要增添额外设备，成本低效果好
3、不但防病毒、而且数据防偷窥
主机上重要数据，可进行定向保护，不被使用者偷窥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7694adcfc3870818e56f9b921b554d9/" rel="bookmark">
			计算机网络知识整理笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.对网络协议的分层？
2.TCP/IP和UDP之间的区别？
3.建立TCP连接的三次握手？
4.断开TCP连接的四次挥手？
5.TCP协议如何保证可靠性传输？
6.什么是TCP的拥塞控制？
7.什么是HTTP协议？
8.HTTP常用的状态码及其含义？
9.HTTP常用的请求方式用途？
10.HTTP和HTTPS的区别？
11.HTTPS工作原理？
12.HTTPS的传输过程？
13.浏览器输入url到显示主页过程？
14.HTTP版本差异对比？
15.HTTP请求转发和重定向的区别？
16.Cookie和Session区别？
17.什么是Token，Token和Session的区别是什么？
1.对网络协议的分层？ 网络协议分层有三种方式，分别是：七层协议、五层协议、TCP/IP四层协议
ISO七层模型是国际标准化组织制定的一个用于计算机或通信系统间互联的标准体系： 应用层：网络服务与最终用户的一个接口，常见的协议有：HTTP FTP SMTP SNMP DNS.表示层：数据的表示、安全、压缩。，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话.传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有TCP UDP.网络层：进行逻辑地址寻址，实现不同网络之间的路径选择,协议有ICMP IGMP IP等.数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。物理层：建立、维护、断开物理连接。五层协议体系结构各层与ISO七层一致，参考七层。 TCP/IP四层协议结构 应用层：对应于OSI参考模型的（应用层、表示层、会话层）。传输层: 对应OSI的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。网际层：对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。网络接口层：与OSI参考模型的数据链路层、物理层对应。 Ps：五层协议各层作用可参考ISO七层模型，不做赘述
2.TCP/IP和UDP之间的区别？ TCP/IP协议：即传输控制协议，是面向连接的协议，发送数据前需要先建立连接，是可靠的数据传输协议。也就是说，通过TCP协议进行的数据传输没有数据丢失、不会乱序、不会重复。
UDP协议：是TCP/IP协议簇中的一种，是无连接的协议，发送数据前无需建立连接，是非可靠的传输协议。
两者之间的区别：
UDP无连接协议，是不可靠传输协议；TCP面向连接，是可靠的数据传输协议UDP传输的运输协议数据单元是UDP报文或者用户数据报文；TCP传送的运输协议数据单元是TCP报文UDP支持单播、多播、广播；TCP协议只支持点对点传输数据UDP简单，适用很多应用，如多媒体服务；TCP复杂，用于很多应用，如万维网、电子邮件、文件传输等UDP传输数据无序；TCP传输数据有序UDP传输耗时短；TCP传输耗时更长一点。 3.建立TCP连接的三次握手？ TCP协议是可靠数据传输协议，传输数据前建立连接的过程称之为三次握手。过程：客户端向服务器发送SYN -&gt; 服务端接收到后向客户端发送SYN和ACK -&gt; 客户端受到后回执服务端ACK。
第一次握手：主机A的TCP向主机B发出连接请求报文段，其首部中的同步位SYN = 1，并选择序号seq = x；第二次握手：主机B的TCP 收到连接请求报文段后，如同意则发回确认。主机B在确认报文段中应使SYN = 1，使ACK = 1，其确认号 ack = x + 1，自己选择的序号 seq = y。第三次握手：主机A 收到此报文段后向主机B给出确认，其ACK = 1，确认号ack = y + 1。主机A 的TCP通知上层应用进程，连接已经建立。主机B的TCP收到主机A的确认后，也通知其上层应用进程：TCP 连接已经建立。 Ps：为什么不能两次握手呢？是因为三次握手主要是为了防止已失效的连接请求报文段又传输到服务端，数据就会有问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7694adcfc3870818e56f9b921b554d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb97b9e2f449a6a91ea329526eb6cfc/" rel="bookmark">
			Java的NIO体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 NIO1、操作系统级别下的IO模型有哪些？2、Java语言下的IO模型有哪些？3、Java的NIO应用场景？相比于IO的优势在哪？4、Java的IO、NIO、AIO 操作文件读写5、NIO的核心类 :Buffer（缓冲区）、Channel（通道）、Selector（选择器）6、Java NIO中的零拷贝优化支持 NIO 1、操作系统级别下的IO模型有哪些？ 阻塞式 IO (Blocking IO):
当应用程序发起 IO 操作时，如果数据还没有准备好或者无法立即处理，IO 操作会阻塞程序的执行，直到数据准备就绪或者操作完成为止。
非阻塞式 IO (Non-blocking IO):
在非阻塞 IO 模型中，应用程序发起 IO 操作后，会立即返回，无论数据是否就绪或者能否立即处理。这样程序可以继续执行其他任务，而不必等待 IO 操作完成。需要通过轮询或者事件通知等方式来检查 IO 操作的状态。
IO 复用 (IO Multiplexing):
IO 复用模型通过操作系统提供的多路复用机制，如 select、poll 或 epoll，在一个线程中同时监视多个 IO 通道的状态。当其中任意一个 IO 通道就绪时，程序可以进行相应的处理。常见于网络编程中。
信号驱动 IO (Signal-driven IO):
在信号驱动 IO 模型中，应用程序会将 IO 操作请求发送给操作系统，并注册一个信号处理函数。当 IO 操作完成时，操作系统会发送一个信号给应用程序，通知其 IO 操作已完成，然后应用程序可以调用相应的处理函数来处理数据。
异步 IO (Asynchronous IO):
异步 IO 模型中，应用程序发起 IO 操作后立即返回，但是会指定一个回调函数或者事件处理器。当 IO 操作完成时，操作系统会通知应用程序，然后调用指定的回调函数来处理数据。相比非阻塞 IO，异步 IO 不需要程序通过轮询来检查 IO 状态，因此效率更高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fb97b9e2f449a6a91ea329526eb6cfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe48b01e0574b11daf787feb55e631d/" rel="bookmark">
			数据结构 —— 二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.树的概念及结构 1.1树的概念 树是一种非线性的数据结构，它有着多分支，层次性的特点。
由于其形态类似于自然界中倒过来的数，所以我们将这种数据结构称为“树形结构”
注意： 树形结构中，子树之间不能有交集，否它就不是树形结构
1.2 树的相关概念 结点的度：一个结点含有的子树的个数称为该结点的度； 如上图：A的为6 叶结点或终端结点：度为0的结点称为叶结点； 如上图：B、C、H、I...等结点为叶结点 非终端结点或分支结点：度不为0的结点； 如上图：D、E、F、G...等结点为分支结点 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点 兄弟结点：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点 树的度：一棵树中，最大的结点的度称为树的度； 如上图：树的度为6 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推； 树的高度或深度：树中结点的最大层次； 如上图：树的高度为4 堂兄弟结点：双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点 结点的祖先：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先 子孙：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙 森林：由m（m&gt;0）棵互不相交的树的集合称为森林； 1.3树的表示 树的表示我们使用：孩子兄弟表示法
设计一个数的节点，其中包含数据域（存储数据）、指针域（左孩子指针，右兄弟指针）
typedef int DataType; struct Node { struct Node* firstChild1; // 第一个孩子结点 struct Node* pNextBrother; // 指向其下一个兄弟结点 DataType data; // 结点中的数据域 }; 这种数的设计方法，我们可以通过左孩子指针找到 A节点 的第一个孩子(B)，在通过孩子的右兄弟指针把 A节点 的所有孩子都找到
1.4 树在实际中的运用 树在实际中的运用：电脑中的数目录
2.二叉树的概念及结构 2.1二叉树的概念 在实际运用中，二叉树要比树更加实用
二叉树其实就是特殊的一种树，它的每个节点最多有两个子节点，通常被称为左子节点和右子节点
二叉树不存在度大于2的结点 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 2.2现实中的二叉树 2.3特殊的二叉树 满二叉树：二叉树的每一层都是满的（特殊的完全二叉树）完全二叉树：二叉树的最后一层不一定是满的，但是它是连续的 像下面这个二叉树，最后一层并不连续，因此它并非是完全二叉树：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe48b01e0574b11daf787feb55e631d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b1c67c389920f37d8e4583dff67820/" rel="bookmark">
			5款提高工作效率的免费工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SimpleTex SimpleTex是一款用于创建和编辑LaTeX公式的简单工具。它能够识别图片中的复杂公式并将其转换为可编辑的数据格式。该软件提供了一个直观的界面，用户可以在编辑LaTeX代码的同时实时预览公式的效果，无需额外的编译步骤。此外，SimpleTex还支持快速插入图像、MathML、LaTeX等格式到主要的文档编辑软件中，极大地提高了工作效率。
SimpleTex不仅适用于科研工作者、教师和学生，还为视觉障碍人群推出了国内第一款创新的图像识别数学公式盲文辅助工具，可以将目标图片转换为LATEX、MathML、中国国标UTF-8盲文。该软件采用高效的识别算法，支持多种语言和复杂公式的识别与编辑，并提供了公式识别记录和文档编辑器功能，方便用户管理和使用识别结果。
CleverPDF CleverPDF是一款功能强大的PDF处理工具，提供多种在线和桌面版本的服务。它支持将PDF文件转换为Word、Excel、PowerPoint等多种格式，并且可以进行加密、解锁、合并、拆分、添加水印、旋转和压缩等操作。CleverPDF的在线版本完全免费，用户只需上传源文件并下载输出文件即可使用其所有功能。
此外，CleverPDF还提供了桌面版本，支持批量处理和离线操作，适合需要更强大功能和灵活性的用户。桌面版本有付费和免费两种版本，付费版本提供更多高级功能。
CleverPDF自2017年推出以来，凭借其简洁的界面和强大的功能，成为了许多用户的首选PDF处理工具。无论是日常办公还是专业领域，CleverPDF都能提供有效的解决方案。
蜻蜓工具 蜻蜓工具是一个在线工具网站，提供多种免费的在线工具服务。该网站包含开发工具、转换工具、图片视频工具、办公辅助和站长工具等多种功能。这些工具可以帮助用户进行网站分析、优化和监控，提升网站的性能和用户体验。此外，蜻蜓工具还为安全工程师提供了一个安全工作流编排平台，集成了市面中的主流安全工具，方便工程师一键使用，提高工作效率。
ImagesTool ImagesTool 是一款多功能的免费在线图片处理工具，支持多种图片处理功能。ImagesTool 提供了以下主要功能：
图片格式转换：支持将超过60种格式的图片（如PDF、PSD、HEIC、RAW、TIFF等）转换为JPG、WEBP、PNG等常用格式。
图片裁剪和压缩：可以对图片进行裁剪、旋转、翻转，并且支持批量裁剪和压缩图片。
图片加水印：可以添加文本或图片水印，并支持平铺、随机、变量和横幅等不同的水印模式。
图片拼接：支持拼接长图、添加字幕和网格模式，让你能够创建出更大尺寸的图片。
GIF处理：包括GIF裁剪、GIF压缩、GIF倒转、视频转GIF等功能。
视频处理：可以进行视频剪辑并转换为GIF。
读取EXIF信息：可以读取图片的元数据信息。
OfficeAI助手 OfficeAI助手是一款集成在Microsoft Office和WPS中的AI插件，旨在帮助用户解决各种办公问题。它能够自动完成用户指定的任务或公式计算，简化操作流程。具体功能包括：
自动完成任务：用户只需告诉助手要做什么，AI会自动完成对应的功能或公式。
周报整理：自动生成和整理周报。
会议纪要：自动生成会议纪要。
内容总结：对文档内容进行总结。
润色：对文档进行润色和优化。
批量插入图片：支持批量插入图片。
修改单元格大小：支持修改单元格大小。
支持多种公式：如SUM、AVERAGE、COUNT等公式的AI呼叫
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b24463a61c8c7d3bb6d88b1a74c2732/" rel="bookmark">
			# Kafka_深入探秘者（10）：kafka 监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka_深入探秘者（10）：kafka 监控 一、kafka JMX 1、JMX ：全称 Java Managent Extension 在实现 Kafka 监控系统的过程中，首先我们要知道监控的数据从哪来，Kafka 自身提供的监控指标(包括 broker 和主题的指标，集群层面的指标通过各个 broker 的指标累加来获取)都可以通过 JMX(Java Managent Extension) 来进行获取。
在使用 JMX 之前首先要确保 Kafka 开启了 JMX 的功能(默认是关闭的)。
kafka 官网中 http://kafka.apache.org/082/documentation.html#monitoring 解释。
2、添加 JMX_PORT=9999 参数，启动 kafka, 确保 kafka 开启了 Jmx 监控 # 切换到 kafka-01 安装目录： cd /usr/local/kafka/kafka-01/ # 添加 JMX_PORT=9999 参数，启动 kafka, 确保 kafka 开启了 Jmx 监控 JMX PORT-9999 bin/kafka-server-start.sh config/server.properties # 切换到 kafka-02 安装目录： cd /usr/local/kafka/kafka-02/ # 添加 JMX_PORT=9988 参数，启动 kafka, 确保 kafka 开启了 Jmx 监控 JMX PORT-9999 bin/kafka-server-start.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b24463a61c8c7d3bb6d88b1a74c2732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2cb787e890ff026d20b10aa574e6b7e/" rel="bookmark">
			Linux Docker Squid：构建自己的代理服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础环境
ubuntu:
docker
docker-compose
1.准备环境 安装Docker和Docker Compose
# 安装Docker sudo apt-get update sudo apt-get install docker.io # 安装Docker Compose sudo apt-get install docker-compose 2.创建一个Dockerfile来构建Squid代理服务器的Docker镜像。 # 使用官方的Alpine镜像作为基础 FROM alpine:latest # 安装Squid软件包 RUN apk add --no-cache squid # 拷贝Squid配置文件 COPY squid.conf /etc/squid/squid.conf # 暴露Squid监听端口 EXPOSE 3128 # 启动Squid代理服务器 CMD ["squid", "-N"] 3. 创建Squid配置文件 编写Squid的配置文件squid.conf
# 在/etc/squid/squid.conf中添加以下内容 http_port 3128 http_access allow all 4. 编写Docker Compose文件 version: '3' services: squid: build: . ports: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2cb787e890ff026d20b10aa574e6b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3088e5f72b5a8963267801cb47a7455/" rel="bookmark">
			WebKit简介及工作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、WebKit简介 WebKit是一个开源的浏览器引擎，最初由苹果公司开发，用于其Safari浏览器。随着时间的推移，WebKit也被广泛应用于其他多个平台和应用中，包括Google Chrome（桌面版）、Chromium（一个开源项目，用于构建Chrome等浏览器）、Android浏览器以及多种移动设备和嵌入式系统中的浏览器。
WebKit以其高性能、低内存占用和高度可移植性而闻名。它支持HTML5、CSS3和其他现代Web技术，使得开发者能够创建更加丰富和互动的网络应用。
二、WebKit的工作流程 1. 资源加载 当用户在使用基于WebKit的浏览器时，首先发生的是资源的加载过程。这包括HTML文档的下载、JavaScript代码的执行以及各种资源（如图片、视频等）的请求。
HTTP请求：WebKit通过HTTP协议向服务器发送请求，获取所需的资源。资源缓存：为了提高效率，WebKit会将经常访问的资源存储在本地缓存中，以减少重复加载的时间。 2. DOM解析与渲染 一旦资源被加载并解析，WebKit会根据HTML标准解析文档结构，构建DOM树。然后，通过CSS样式表解析文档的布局，并生成布局树（Layout Tree）。最后，WebKit将布局树转换为渲染树（ rendering tree），并进行实际的页面渲染。
DOM解析：WebKit使用解析器读取HTML内容，并将其转换为DOM树。布局排版：根据CSS规则，WebKit计算每个元素的位置和大小，形成布局树。绘制渲染：最后，WebKit将布局树转换为可视化的渲染树，并使用图形API（如WebGL或2D上下文）进行绘制。 3. 性能优化 为了提升用户体验，WebKit在设计时考虑了多种性能优化措施。例如，通过并行处理和多线程渲染技术，可以显著提高页面加载和渲染的速度。此外，WebKit还采用了懒加载、资源重用等策略来优化资源管理和加载时间。
三、结论 WebKit作为一个强大的浏览器引擎，不仅支持广泛的Web标准，还提供了高效的工作流程和丰富的功能扩展。随着Web技术的不断发展，WebKit将继续优化其性能和兼容性，为用户提供更加快速和流畅的网络浏览体验。未来，随着更多创新技术的应用，如机器学习和人工智能，WebKit有望进一步提升其智能化水平，为用户带来更加个性化的浏览体验。
WebKit在最新版本中引入了哪些新特性和改进？ 在最新的WebKit版本中，引入了多项新特性和改进，主要集中在增强Web应用的功能和性能上。可以总结出以下几点：
硬件设备调用的增强：WebKit内核通过三种实现方式增强了对终端硬件设备的调用能力。这包括单点组件的增强、复合组件性能的提升以及平台应用接口性能的优化。这些改进使得Web应用能够在功能和性能上与原生应用相媲美，特别是在摄像头视频采集和显示屏渲染画面等方面。
新的浏览器能力：随着现代浏览器的发展，WebKit也支持了一些新的能力和特性，如本地文件系统访问、系统剪贴板访问、联系人检索、周期性后台同步、屏幕唤醒锁定和网络共享功能等。这些新特性进一步扩展了Web应用的能力，使其更加丰富和便捷。
UI工具包的增强：虽然不是直接关于WebKit的更新，但值得注意的是，整体上Web开发领域对于UI工具包的需求和期望正在增加。开发者需要更强大的UI工具包来简化设计过程，提供一致的行为模式和跨浏览器支持。这表明WebKit在未来可能会继续加强其对UI工具包的支持，以满足开发者的需求。
WebKit在最新版本中主要通过增强硬件设备调用能力、引入新的浏览器特性和改进UI工具包等方面进行了更新和改进。
如何比较WebKit与其他浏览器引擎（如QtWeb、EdgeHTML）的性能和兼容性？ 在比较WebKit与其他浏览器引擎（如QtWeb、EdgeHTML）的性能和兼容性时，我们需要从多个维度进行分析，包括但不限于渲染速度、资源占用、对HTML5等现代Web技术的支持程度以及跨平台兼容性。
渲染速度和资源占用：
WebKit引擎以其高效的渲染能力和低资源占用而闻名。例如，SquirrelFish Extreme引擎就是基于字节码支持标准规范ECMAScript-262的高性能JS引擎，它在之前版本的基础上使用了新技术来获取高效的性能且内存占用小。这使得WebKit非常适合嵌入式平台应用。对于QtWeb（基于WebKit），虽然具体的数据未提及，但其设计目标是实现对MeeGo平台的移植，并能部分支持HTML5技术规范。这表明QtWeb也注重于优化性能和资源管理。 对HTML5等现代Web技术的支持：
WebKit提供了对HTML5新特性的良好支持，如Canvas标签用于二维图形绘制和WebGL用于3D图形渲染。这些特性使得WebKit能够提供丰富的网页内容和交互体验。EdgeHTML引擎，作为微软Edge浏览器的核心，同样强调对HTML5的支持，尤其是在触摸操作和多窗口管理方面表现出色。然而，具体的性能数据和比较在我搜索到的资料中未详细说明。 跨平台兼容性：
WebKit由于其开源性质，被广泛应用于多种操作系统和设备上，从智能手机到嵌入式系统。这种广泛的适用性使得WebKit在跨平台兼容性方面具有优势。QtWeb同样展示了良好的跨平台特性，特别是在嵌入式设备上的应用。而EdgeHTML则主要针对Windows平台，虽然也在尝试扩展到其他设备，但其跨平台能力可能不如基于WebKit的解决方案。 总结来说，WebKit在渲染速度、资源占用以及对现代Web技术的支持方面表现优异，同时具有很好的跨平台兼容性。相比之下，QtWeb和EdgeHTML各有特点，QtWeb在特定平台上表现出色，而EdgeHTML则专注于提供流畅的用户体验。
WebKit在处理大型Web应用时的内存管理策略是什么？ WebKit在处理大型Web应用时的内存管理策略主要涉及到两个方面：磁盘缓存和渲染优化。
磁盘缓存策略：WebKit采用了基于LRU-K算法的磁盘缓存置换算法来管理内存。这种算法结合了最近最少使用（Least Recently Used, LRU）策略和缓存资源的优先级，以防止磁盘缓存存储空间过载。通过设计磁盘缓存快速映射算法，WebKit能够在网络资源的URL与数据之间建立映射关系，从而提高页面加载速度并增强用户体验。实验结果显示，这种方法可以将浏览器加载速度提升3.19倍。
渲染优化策略：针对嵌入式设备计算资源有限的特点，WebKit实施了基于分片后备存储的渲染优化算法。该方法通过将Web页面的渲染区域精确到小的区域上，减少了不必要的区域的重新绘制。这种方法不仅优化了渲染流程，还大大减少了Web页面渲染的时间，从而提高了嵌入式浏览器的页面渲染速度和用户体验。
WebKit在处理大型Web应用时，通过高效的磁盘缓存管理和先进的渲染优化技术，有效地管理内存并提升性能。
WebKit如何利用机器学习和人工智能技术优化用户体验？ WebKit作为一个广泛使用的网页浏览器内核，其优化用户体验的方式主要可以通过机器学习和人工智能技术来实现。以下是几种具体的应用方式：
自适应用户界面设计：通过机器学习技术，WebKit可以分析用户的浏览习惯和偏好，从而动态调整网页的布局和内容展示方式，以适应不同用户的需求。例如，根据用户的操作历史和偏好，自动调整界面元素的位置或大小，使得用户能够更快地找到他们需要的信息。
个性化推荐系统：利用机器学习算法，WebKit可以在用户浏览网页时实时分析其行为模式，并据此提供个性化的网页内容或广告推荐。这种推荐不仅基于用户的历史数据，还可以考虑到用户的实时互动和反馈，从而提高推荐的相关性和准确性。
智能表单优化：在处理用户输入的数据时，如填写表单，WebKit可以使用机器学习算法来预测最佳的表单结构和布局，以减少用户的填写时间和提高数据收集的效率。例如，通过A/B测试或其他机器学习方法来确定哪种表单设计能带来更高的转化率。
错误和异常处理：机器学习可以帮助WebKit更好地理解和预测用户可能遇到的问题，如页面加载失败、兼容性问题等。通过分析大量的用户数据和错误报告，WebKit可以提前识别潜在的问题并进行优化，从而减少这些问题对用户体验的影响。
交互优化：在移动设备上，由于屏幕尺寸和网络延迟的限制，优化用户体验尤为重要。WebKit可以利用机器学习来预测用户的交互模式，并据此优化页面加载和内容渲染的过程，例如通过预加载技术来减少等待时间，或者根据用户的动作模式来优化触摸响应速度。
在移动设备和嵌入式系统中，WebKit的实现方式有哪些差异？ 在移动设备和嵌入式系统中，WebKit的实现方式存在一些差异，主要体现在性能优化、用户界面适配以及开发环境的差异上。
性能优化：在移动设备上，由于硬件资源有限，WebKit需要进行特定的优化以提高渲染效率和响应速度。例如，iPhone上的WebKit表现出比Android更好的性能。这可能是因为苹果公司在其设备上对WebKit进行了特别的调优，以适应iOS平台的特定需求。
用户界面适配：移动设备通常具有不同的屏幕尺寸和分辨率，因此WebKit在这些设备上的实现需要考虑屏幕适配问题。如文献所述，Panelrama框架支持跨设备应用的UI状态同步，并能根据设备特性动态调整UI布局。这种能力使得WebKit能够在不同设备上提供一致的用户体验。
开发环境：对于嵌入式系统，开发者可能更倾向于使用标准化的Web技术来开发应用程序，因为这样可以减少学习成本并利用现有的Web开发技能。例如，使用HTML5和JavaScript可以在多种移动设备上运行应用程序。而在移动设备上，除了标准的Web技术外，还可能需要考虑特定的操作系统API，如iOS或Android提供的API。
跨平台支持：随着Web技术的发展，WebKit也在不断改进以支持更多的平台和设备。例如，提出了一种基于Web组件的跨平台移动应用创建环境，这种环境支持普通用户通过拖放操作快速创建应用程序。这种跨平台的支持使得WebKit能够更容易地被集成到各种不同的开发环境中。
总结来说，WebKit在移动设备和嵌入式系统中的实现差异主要体现在性能优化、用户界面适配以及开发环境的差异上。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/216/">«</a>
	<span class="pagination__item pagination__item--current">217/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/218/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>