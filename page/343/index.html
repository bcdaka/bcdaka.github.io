<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98844f6c7a5d9ed484262f91a8ab7c7d/" rel="bookmark">
			html--瀑布效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;瀑布效果&lt;/title&gt; &lt;style&gt; body { background: #222; color: white; overflow:hidden; } #container { box-shadow: inset 0 1px 0 #444, 0 -1px 0 #000; height: 100vh; width: 100vw; position: absolute; left: 0; top: 0; margin: 0; will-change: transform; -webkit-transform: translateZ(0); transform: translateZ(0); } canvas#waterfall { display: block; margin: 0 auto; width: 30%; height: 55%; will-change: transform; -webkit-transform: translateZ(0); transform: translateZ(0); } .emma { height: 100vh; width: 100%; position: absolute; left: 0; top: 0; margin: 0; } h1 { color: #0af; font-size: 30vw; } canvas#surface { -webkit-animation: fade-in 3000ms forwards; animation: fade-in 3000ms forwards; display: block; left: 0; position: absolute; top: 0; z-index: -1; } @-webkit-keyframes fade-in { 0% { opacity: 0; } 100% { opacity: 1; } } @keyframes fade-in { 0% { opacity: 0; } 100% { opacity: 1; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98844f6c7a5d9ed484262f91a8ab7c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4a8e355008ae46be48ee90e70a33e0/" rel="bookmark">
			合并K个升序链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目 解法一 优先级队列
思想 将每个链表中的一个节点存放到优先级队列中，本题采用小根堆，将小根堆中的根节点取出，插入到最终的链表中，并且将该节点在原链表中的下一个节点插入小根堆中（需要向下调整），直到堆中没有节点为止（即所以链表都已经合并完）。
代码 class Solution { public: struct Less{ bool operator()(ListNode* l1,ListNode* l2){ return l1-&gt;val &gt; l2-&gt;val; } }; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { ListNode* node=new ListNode(0); ListNode* cur=node; priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,Less&gt; q; for(auto&amp; it:lists){ if(it) q.push(it); } while(!q.empty()){ ListNode* tmp=q.top(); q.pop(); cur-&gt;next=tmp; if(tmp-&gt;next) q.push(tmp-&gt;next); cur=cur-&gt;next; } return node-&gt;next; } }; 解法二 归并/分治
思想 将链表两两进行合并，直到合并为一个链表为止。
代码 class Solution { public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { return mergeL(lists,0,lists.size()-1); } ListNode* mergeL(vector&lt;ListNode*&gt;&amp; lists,int l,int r){ if(l&gt;r) return nullptr; if(l==r) return lists[l]; int mid=(l+r)&gt;&gt;1; ListNode* l1=mergeL(lists,l,mid); ListNode* l2=mergeL(lists,mid+1,r); return merge2L(l1,l2); } ListNode* merge2L(ListNode* l1,ListNode* l2){ if(l1==nullptr) return l2; if(l2==nullptr) return l1; if(l1-&gt;val &lt; l2-&gt;val){ l1-&gt;next=merge2L(l1-&gt;next,l2); return l1; } else{ l2-&gt;next=merge2L(l1,l2-&gt;next); return l2; } } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5c90eb3085493d04c022b92b2d56bc/" rel="bookmark">
			通过C语言实现三种版本的快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序 前言一、快速排序的基本思想常见方式通用模块 二、快速排序的特性总结三、三种快速排序的动画展示四、hoare版本快速排序的代码展示普通版本优化版本为什么要优化快速排序代码三数取中法优化代码 五、挖坑法快速排序的代码展示六、前后指针快速排序的代码展示七、非递归实现快速排序的代码展示Stack.hStack.c非递归实现快速排序 八、快速排序的完整代码 前言 推荐一个网站给想要了解或者学习人工智能知识的读者，这个网站里内容讲解通俗易懂且风趣幽默，对我帮助很大。我想与大家分享这个宝藏网站，请点击下方链接查看。
https://www.captainbed.cn/f1
快速排序是一种高效的排序算法，通过选取一个“基准”元素，将数组分为两部分：比基准小的元素和比基准大的元素，然后递归地对这两部分进行排序，从而实现对整个数组的排序。该算法平均时间复杂度为O(nlogn)，最坏情况下为O(n²)，但由于实际应用中很少出现最坏情况，因此快速排序仍然是一种广泛使用的排序算法。
一、快速排序的基本思想 快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。
快速排序的基本思想是采用分治策略，通过选取一个“基准”元素，将待排序的数组分为两个子数组，一个子数组的元素都比基准元素小，另一个子数组的元素都比基准元素大，然后对这两个子数组递归地进行快速排序，从而达到对整个数组排序的目的。
在快速排序的具体实现中，通常选择数组中的一个元素作为基准元素，然后将数组中的其他元素与基准元素进行比较，根据比较结果将元素放到两个子数组中。这个过程可以通过使用双指针技术来实现，一个指针从数组的开头开始向右移动，另一个指针从数组的末尾开始向左移动，当左指针指向的元素小于等于基准元素，且右指针指向的元素大于等于基准元素时，交换这两个元素的位置。当左指针移动到右指针的位置时，整个数组就被划分为了两个子数组。
接下来，对这两个子数组分别进行快速排序。递归地调用快速排序函数，传入子数组的首尾指针作为参数，直到整个数组都被排序完毕。
快速排序的时间复杂度在最坏情况下为O(n²)，即当每次选取的基准元素都是当前数组中的最小或最大元素时，会导致每次划分得到的子数组大小相差很大，从而使得递归树的深度很大，排序效率降低。然而，在实际应用中，由于快速排序的随机性，其平均时间复杂度为O(nlogn)，因此在实际应用中具有很高的效率。
此外，快速排序是一种原地排序算法，只需要常数级别的额外空间，因此在处理大规模数据时具有很大的优势。同时，快速排序也是一种不稳定的排序算法，即相等的元素在排序后可能会改变它们的相对位置。
综上所述，快速排序是一种基于分治策略的排序算法，通过递归地将数组划分为子数组并对其进行排序，实现了对整个数组的排序。虽然在最坏情况下其时间复杂度可能达到O(n²)，但在实际应用中其平均时间复杂度为O(nlogn)，具有很高的效率。同时，快速排序也是一种原地、不稳定的排序算法，适用于处理大规模数据。
常见方式 将区间按照基准值划分为左右两半部分的常见方式有
hoare版本
挖坑法
前后指针版本
通用模块 / 假设按照升序对array数组中[left, right)区间中的元素进行排序 void QuickSort(int array[], int left, int right) { if(right - left &lt;= 1) return; // 按照基准值对array数组的 [left, right)区间中的元素进行划分 int div = partion(array, left, right); // 划分成功后以div为边界形成了左右两部分 [left, div) 和 [div+1, right) // 递归排[left, div) QuickSort(array, left, div); // 递归排[div+1, right) QuickSort(array, div+1, right); } 二、快速排序的特性总结 快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序时间复杂度：O(N*logN)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5c90eb3085493d04c022b92b2d56bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3340934e0b2e86ae3e01035ae89b1c9/" rel="bookmark">
			从菜鸟到大厨：MySQL数据库的美味指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库的操作 创建数据库:
create database 数据库名;
​
数据库语句一般会放在文件中批量执行,但是遇到错误会无法执行,为了避免可能因为重名而造成数据库无法执行下去的情况,会在create database后面加上if not exists来避免报错
​
创建数据库的时候,可以手动指定一下字符集
character set 字符集名字/charset 字符集名字
咱们需要在数据库中保存中文,mysql默认的字符是拉丁文,不支持中文.必须要在创建数据库的时候,手动指定编码方式为支持中文的编码(GBK,UTF8)
​
查看数据库:
show databases;
列出当前mysql服务器上的数据库
选中数据库:
use 数据库名;
删除数据库:
drop database 数据库名;
MySQL表的增删改查 创建表:
create table 表名(列名 类型, 列名 类型…);
如果表名/列名是关键字,那么要用倒引号``引出来
查看所有表:
show tables;
查看当前数据库的所有表
查看指定表的结构:
desc 表名;
删除表:
drop table 表名;
新增数据:
insert into 表名 values(值,值…);
此处的值要与列相匹配
指定列插入:
insert into 表名(列名,列名…) values (值,值…);
一次插入多行记录:
insert into 表名 values (值,值…),(值,值…)…
全列查询:
select * from 表名;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3340934e0b2e86ae3e01035ae89b1c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e65bea13e25fa0900157900f74a29d/" rel="bookmark">
			数学建模——农村公交与异构无人机协同配送优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.题目
2.问题1
1. 问题建模
输入数据
​编辑
2. 算法选择
3.数据导入 3.模型构建
1. 距离计算
2. 优化模型
具体步骤
进一步优化
1. 重新定义问题
2. 变量定义
3. 优化目标
具体步骤
再进一步优化
具体实现步骤
1. 计算距离矩阵
2. 变量定义
3. 约束条件
4. 优化目标
以下是优化模型的具体实现：
1.确保所有约束和目标函数都得到正确实现。
2. 可视化飞行路径和时间表
最终实现结果
1.题目 A题 农村公交与异构无人机协同配送优化
农村地区因其复杂多变的地形、稀疏的道路网络以及分散的配送点，传统配送方式效率低下，成本高昂，难以满足日益增长的配送需求。随着无人机技术迅猛发展和在物流领域的广泛应用，一种全新的配送模式应运而生——农村公交与异构无人机协同配送模式。
农村公交作为地面交通系统的重要组成部分，其覆盖范围广、定时定点运行且成本相对较低，为无人机提供了理想的地面支撑。通过将无人机与农村公交相结合，可以充分利用两者的优势，实现高效协同配送。具体而言，农村公交负责将无人机和货物运送至各个公交站点，这些站点既是无人机的起降点，也是货物的转运中心。无人机则利用自身的空中优势，从公交站点起飞，快速准确地完成到具体配送点的配送任务。
为提升配送效率和灵活性，异构无人机的使用显得尤为重要。异构无人机具有不同的飞行特性、载荷能力和速度，能够根据不同配送需求进行灵活的任务分配。通过合理搭配和调度不同类型的异构无人机，可以实现对复杂多变配送需求的精准应对，提高整体配送效率。
实施同时取送货服务也更能体现农村物流的独特需求。在一次飞行中，无人机能够兼顾多个配送点的送货与取货任务，从而显著提升配送效率，减少周转时间。通过精心策划飞行路径和合理分配任务，能够有效减少无人机的使用次数和飞行频率。
农村公交装载货物和无人机，从配送中心出发，按公交固定路线及公交站点行驶。根据客户需求和无人机性能，精准分配无人机类型及配送任务。无人机在接近客户点的公交站点起飞，按优化路径执行取送货任务，确保高效完成。完成任务后，无人机返回最近站点，搭乘下一次经过该站点的公交进行迅速换电后继续服务该站点附近客户需求点或搭载公交到达其他站点服务其周围需求点，无人机没有任务后搭载公交回到配送中心。整个过程中，无人机与农村公交紧密协作，循环执行配送任务，直至所有任务完成。通过这种模式，能够充分利用地面和空中的优势，提高配送效率，降低成本，满足农村地区日益增长的配送需求。
假设无人机可以在公交站点等待下一班次的公交车，若公交站点处有返回的无人机需要装货，公交车在该站点逗留5分钟时间用于更换无人机电池（不需要充电）及装载货物。无人机产生的费用包括两部分，一是固定费用，只要使用就会产生，与无人机类型有关，二是运输费用，取决于无人机类型及运输过程的飞行里程（从站点起飞至回到站点的飞行里程）。此外，需求点的任务不能拆分，一辆公交车最多可携带两架无人机，每天任务完成后无人机必须回到起始站，不考虑客户点的时间窗，不考虑道路的随机性堵车，公交车的行驶速度为35公里/小时。
请根据附件所给数据解决以下几个问题：
问题1 只考虑使用A类无人机，请给出公交与无人机协同配送方案，使总费用最小；要求给出具体的飞行路径及时刻表。
问题2 三种类型无人机均可使用时，请给出最小费用的协同配送方案。
问题3 在问题2的基础上，如果每个需求点有取货的需求，且取货能获得一定的收入（每公斤0.5元），请给出最佳配送方案。
2.问题1 只考虑使用A类无人机，请给出公交与无人机协同配送方案，使总费用最小；要求给出具体的飞行路径及时刻表
1. 问题建模 输入数据
公交站点数据：包括站点的位置和之间的距离。需求点数据：包括需求点的位置和配送需求。A类无人机性能参数：包括最大飞行距离、载重能力、固定费用和飞行费用。公交发车时间表：公交车的出发和到达时间。 2. 算法选择 3.数据导入 # 公交站点数据 stations_data = pd.DataFrame({ 'Station_ID': [1, 2, 3, 4, 5, 6, 7, 8, 9], 'Longitude': [110.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2e65bea13e25fa0900157900f74a29d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c46d995042c1f694ae92f4289e053a/" rel="bookmark">
			【微信小程序[app.json: 在项目根目录未找到 app.json]】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 微信小程序 刚拉取下来的微信小程序，运行到微信小程序模拟器时出现【[ app.json 文件内容错误] app.json: 在项目根目录未找到 app.json (env: Windows,mp,1.06.2402040; lib: 2.25.3)】 解决办法： 先于此【unpackage ——&gt; dist ——&gt; dev ——&gt; mp-weixin】查之，是否有app.json，若存之，则接与下文而览之；若否之，则君可转之他之文也，继而览之。
（1）找到根目录下的project.config.json文件，并打开它
（2）在project.config.json文件中，添加 [ "miniprogramRoot": "unpackage/dist/dev/mp-weixin/", ] （3）打开微信开发者工具，点击“ 编译 ”即可解决该问题 ​ 于此，谢君观之。若君 兴之所至，观之文末，有谏言者，吾便从谏如流。
书也，吾当复观之，亦采之；语也，吾当俯身倾耳以请，而不负其烦也，亦改之。
止于此，IT之路道阻且长，其术业之迭新亦疾，吾等须相扶相持，始得斯道愈行愈远，愿诸君共勉之~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57fba68c47a7486040caf52d800e3b7b/" rel="bookmark">
			【Python】超详细实例讲解python多线程（threading模块）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是多线程? 线程（thread）是操作系统中能够进行运算的最小单位，包含于进程之中，一个进程可以有多个线程，这意味着一个进程中可以并发多个线程，即为多线程。
对于一个python程序，如果需要同时大量处理多个任务，有使用多进程和多线程两种方法。在python中，实现多线程主要通过threading模块，而多进程主要通过multiprocessing模块。
这两个模块的主要区别是：threading模块基于线程，而multiprocessing模块基于进程。threading模块使用共享内存来实现多线程，所有线程都共享一样的变量（这点在后续的实例中可以感受到）；而multiprocessing基于子进程，每个子进程之间都有独立的变量和数据结构。两者的区别意味着threading更使用于I/O密集型任务（例如需要进行多表格读取操作），multiprocessing模块更适用于包含较多计算的CPU密集型任务（矩阵运算，图片处理类任务）。
需要注意的是，由于python中的GIL锁的存在，Python解释器只允许一个Python进程使用，这意味着对于一个解释器只允许一个进程在运行，这也是为什么threading模块无法适用于CPU密集型这类需要大量CPU资源的任务，因为一个进程的CPU资源有限，无论开启多少个线程，总的资源就只有那些，总耗时不会有太大变化。而multiprocessing模块则可以开多个进程，能够更快速的处理CPU密集型任务。
关于GIL锁和Multiprocessing模块的部分就不继续深入介绍了，本次主要介绍如何使用threading模块实现多线程的相关内容。
线程完整生命周期 一个线程完整的生命周期包括新建——就绪——运行——阻塞——死亡。
新建：即新创建一个线程对象就绪：调用start方法后，线程对象等待运行，什么时候开始运行取决于调度运行：线程处于运行状态阻塞：处于运行状态的线程被堵塞，通俗理解就是被卡住了，可能的原因包括但不限于程序自身调用sleep方法阻塞线程运行，或调用了一个阻塞式I/O方法，被阻塞的进程会等待何时解除阻塞重新运行死亡：线程执行完毕或异常退出，线程对象被销毁并释放内存 主线程与子线程 我们讲的多线程实际上指的就是只在主线程中运行多个子线程，而主线程就是我们的python编译器执行的线程，所有子线程和主线程都同属于一个进程。在未添加子线程的情况下，默认就只有一个主线程在运行，他会将我们写的代码从开头到结尾执行一遍，后文中我们也会提到一些主线程与子线程的关系。
不扯那么多概念了，接下来直接进入正题！
实例1：直接使用Thread创建线程对象 Thread类创建新线程的基本语法如下：
Newthread = Thread(target=function, args=(argument1,argument2,...))
Newthread: 创建的线程对象function: 要执行的函数argument1,argument2: 传递给线程函数的参数，为tuple类型 假设一个任务task(当然task可以替换为其他任何任务，本实例中仅为假设)，这个任务实现的功能是每隔1s打印某个字母，我们使用两个子线程，分别同时打印不同的字母a和b，实例如下：
""" &lt;case1: 直接使用threading中的Thread类创建线程&gt; Date: 2024/5/15 Author: 猫猫不吃sakana """ from threading import Thread import time from time import sleep # 自定义的函数，可以替换成其他任何函数 def task(threadName, number, letter): print(f"【线程开始】{threadName}") m = 0 while m &lt; number: sleep(1) m += 1 current_time = time.strftime('%H:%M:%S', time.localtime()) print(f"[{current_time}] {threadName} 输出 {letter}") print(f"【线程结束】{threadName}") thread1 = Thread(target=task, args=("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57fba68c47a7486040caf52d800e3b7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2cded2e4413803d95c574019f0dfb3/" rel="bookmark">
			C/C&#43;&#43;运行时库和UCRT系统通用运行时库总结及问题实例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、概述
2、不同版本的Visual Studio对应的运行时库说明
3、在Windbg10.0安装目录中获取UCRT通用运行时库
4、微软官网对UCRT通用运行时库的相关说明
5、使用Visual Studio 2017开发软件初期遇到的UCRT通用运行时库问题
6、如何查看软件依赖了哪些C/C++运行时库？
7、将软件从32位升级到64位后，要使用64位UCRT通用运行时库
8、发布软件时未打包C/C++运行时库的项目问题实例
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.htmlVC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C++软件分析工具从入门到精通案例集锦（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/article/details/131405795开源组件及数据库技术（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_12458859.html网络编程与网络问题分享（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_2276111.html 大家在开发C++软件的过程中，会时不时遇到这样或那样的C/C++运行时库相关问题。今天结合多年的C++软件开发经验，给大家详细介绍一下C/C++运行时库以及以api-ms-win-开头的UCRT系统通用运行时库，并给出了项目问题分析实例，以供大家借鉴或参考。
1、概述 使用Visual Studio开发的C++应用程序，在发布时需要将C/C++运行时库一起打包到安装包中，安装时将C/C++运行时库放置到exe主程序的安装目录中。C++应用程序调用的C/C++运行时函数（比如abort、system、strlen、strcpy等）以及C++标准库，都在C/C++运行时库中。C++应用程序依赖这些C/C++运行时库，启动时需要加载这些运行时库。
为啥要带上C/C++运行时库呢？如果机器上安装了Visual Studio，在安装Visual Studio时会自动将对应版本的运行时库拷贝到系统目录C:\Windows\System32（在64位系统中，32位版本的运行时库会拷贝到C:\Windows\SysWOW64目录中）。如果机器上没有安装Visual Studio，系统目录中一般不会有这些C/C++运行时库，如果此时安装目录中也没有，则程序启动时会因为在系统中找不到这些库而启动失败。
2、不同版本的Visual Studio对应的运行时库说明 我们代码中调用的很多C/C++基本库函数都位于C/C++运行时库中，比如abort、system、strlen、strcpy等运行时库函数。一般运行时库是以msvcr（C运行时库）或msvcp（C++运行时库）开头的。
不同版本的Visual Studio携带的C/C++运行时库的名称也不一样，这些运行时库一般要打包到安装程序中，安装时要拷贝到exe主程序的安装目录中。
对于不同版本的Visual Studio对应的运行时库版本，很多人可能分不清楚，会有疑惑，这里详细给大家介绍一下：（以d结尾的是Debug版本的运行时库）
1）VS2010对应的运行时库文件（对应100版本）：msvcp100.dll（msvcp100d.dll）、msvcr100.dll（msvcr100d.dll）；
2）VS2012对应的运行时库文件（对应110版本）：msvcp110.dll（msvcp110d.dll）、msvcr110.dll（msvcr110d.dll）；
3）VS2013对应的运行时库文件（对应120版本）：msvcp120.dll（msvcp120d.dll）、msvcr120.dll（msvcr120d.dll）；
4）VS2017对应的运行时库文件（对应140版本）：msvcp140.dll（msvcp140d.dll）、vcruntime140.dll（vcruntime140d.dll）、u以及UCRT通用运行时库（ucrtbase.dll（ucrtbased.dll）+ 多个以api-ms-win-开头的dll库）。 (VS2017引入了两类新库vcruntime140.dll和UCRT，不再有msvcr140.dll库，只保留了msvcp140.dll库)
在Visual Studio 2015之前的版本中，C/C++运行时库主要由msvcrXXX.dll和msvcpXXX.dll，其中XXX是对应Visual Studio版本对的数字，如上所示。 在Visual Studio 2015中，C/C++运行时库被分离重构，分离成msvcp、vcruntime和UCRT，在Visual Studio 2015及以后的版本中，均使用这种新的结构。
UCRT，全称为The Universal CRT，Windows系统通用运行时库，主要由ucrtbase.dll以及api-ms-win-开头的多个dll库，如下所示：
3、在Windbg10.0安装目录中获取UCRT通用运行时库 使用Visual Studio 2015及以上版本开发的C++应用程序，发布时都要带上这些通用运行时库。这些UCRT通用运行时库可以从Windows SDK中获取。比如可以从安装的Windbg10.0的安装目录中找到这些UCRT通用库，当时Windbg10.0就是使用Windows SDK安装的，所以安装目录中可以找到UCRT运行时库。比如我本机的安装目录：
C:\Program Files (x86)\Windows Kits\10\Redist\10.0.17763.0\ucrt\DLLs
在上述路径中可以找到，如下所示：（可以在Windbg安装目录中以api-ms-win为关键字搜索，找到具体的路径）
可以将这些路径下的通用运行时库拷贝到项目中，发布版本时要将这些运行时库带上。
在这里，给大家重点推荐一下我的几个热门畅销专栏，欢迎订阅：（博客主页还有其他专栏，可以去查看）
专栏1：（该精品技术专栏的订阅量已达到430多个，专栏中包含大量项目实战分析案例，有很强的实战参考价值，广受好评！专栏文章持续更新中，预计更新到200篇以上！欢迎订阅！）
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931
本专栏根据多年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，以图文并茂的方式给出具体的项目问题实战分析实例（很有实战参考价值），带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！
考察一个开发人员的水平，一是看其编码及设计能力，二是要看其软件调试能力！所以软件调试能力（排查软件异常的能力）很重要，必须重视起来！能解决一般人解决不了的问题，既能提升个人能力及价值，也能体现对团队及公司的贡献！
专栏中的文章都是通过项目实战总结出来的，包含大量项目问题实战分析案例，有很强的实战参考价值！专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！
专栏2： C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html
以多年的开发实战经验为基础，总结并讲解一些的C/C++基础与进阶内容，以图文并茂的方式对C++相关知识点进行详细地展开与剖析！专栏涉及了C/C++开发领域多个方面的内容，同时给出C/C++及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！
专栏3： VC++常用功能开发汇总https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d2cded2e4413803d95c574019f0dfb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43dc0e67291fd41053357beba9a76956/" rel="bookmark">
			YOLOv8制作自己的实例分割数据集保姆级教程（包含json转txt）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据准备 首先对原始数据集进行整理，将标注好的图像和标签分别放在两个文件夹中，同时额外新建两个文件夹，用于存放转换完的标签与划分后的数据集。
1.1将json格式文件转换为txt格式 新建json2txt.py文件，将代码中的文件路径修改为自己的路径。
❗❗❗代码中第43行的classes中存放的是自己数据集的分类标签，记得修改成自己的。
import json import os from tqdm import tqdm def convert_label(json_dir, save_dir, classes): json_paths = os.listdir(json_dir) classes = classes.split(',') for json_path in tqdm(json_paths): path = os.path.join(json_dir, json_path) with open(path, 'r') as load_f: json_dict = json.load(load_f) h, w = json_dict['imageHeight'], json_dict['imageWidth'] # save txt path txt_path = os.path.join(save_dir, json_path.replace('json', 'txt')) txt_file = open(txt_path, 'w') for shape_dict in json_dict['shapes']: label = shape_dict['label'] label_index = classes.index(label) points = shape_dict['points'] points_nor_list = [] for point in points: points_nor_list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43dc0e67291fd41053357beba9a76956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41db53590e5e8f0fb9769f568c11c247/" rel="bookmark">
			前端项目部署自动检测更新后通知用户刷新页面（前端实现，技术框架vue、js、webpack）——方案二：轮询去判断服务端的index.html是否跟当前的index.html的脚本hash值一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 当我们重新部署前端项目的时候，如果用户一直停留在页面上并未刷新使用，会存在功能使用差异性的问题，因此，当前端部署项目后，需要提醒用户有去重新加载页面。
技术框架 vue、js、webpack
解决方案 根据打完包之后生成的script src 的hash值去判断，每次打包都会生成唯一的hash值，只要轮询去判断不一样了，那一定是重新部署了
轮询（20s、自己设定时间）服务器的index.html 文件，将新的script数组与旧script数组比较数组内容是否一致（可以将新旧数组拼接后去重，若去重后的数组长度，与旧数组长度不一样，则说明重新部署了），若新旧数组不一致则通知用户刷新页面通过监听visibilitychange事件，在页面隐藏时停止轮询，页面显示立马检测一次更新检测到更新后，停止轮询 （感兴趣的还可去看方案一：编译项目时动态生成一个记录版本号的文件，轮询请求该文件。前端项目部署自动检测更新后通知用户刷新页面（前端实现，技术框架vue、js、webpack）——方案一：编译项目时动态生成一个记录版本号的文件_新版本发布后,怎么用技术手段通知用户刷新页面?-CSDN博客）
效果 页面右下角提示更新：
代码实现 Step1：在src目录下封装 auto-update.js
/* * @Description: 自动更新 */ // const timeData = 60 * 1000 // 检查间隔时间 const timeData = 20 * 1000 // 检查间隔时间 let hidden = false // 页面是否隐藏 let setTimeoutId let needTip = true // 默认开启提示 let oldScript = [] let newScript = [] const getHtml = async () =&gt; { const html = await fetch('/').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41db53590e5e8f0fb9769f568c11c247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04a3d827d5f5d97c4a8e250316e448b/" rel="bookmark">
			算法打卡 Day13（栈与队列）-滑动窗口最大值 &#43; 前 K 个高频元素 &#43; 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Leetcode 239-滑动窗口最大值题目描述解题思路 Leetcode 347-前 K 个高频元素题目描述解题思路 栈与队列总结 Leetcode 239-滑动窗口最大值 题目描述 https://leetcode.cn/problems/sliding-window-maximum/description/
解题思路 在本题中我们使用自定义的单调队列来实现：
pop：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不进行任何操作
push：如果 push 的元素 value 大于入口元素的数值，那么就将队列入口的元素弹出，直到 push 元素的数值小于队列入口元素的数值为止
返回当前窗口的最大值：调用 que.front()
class Solution { private: class MyQueue { public: deque&lt;int&gt; que; //使用deque实现单调队列 void pop(int value) { if (!que.empty() &amp;&amp; value == que.front()) { que.pop_front(); } } void push(int value) { while (!que.empty() &amp;&amp; value &gt; que.back()) { que.pop_back(); } que.push_back(value); } int front() { return que.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c04a3d827d5f5d97c4a8e250316e448b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab66ec4d64aa63df5bee82309e60bda/" rel="bookmark">
			Midjourney &#43; InsightFaceSwap Al 换脸轻松实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 认识 InsightFaceSwap 命令 InsightFace 是一个开源的 2D&amp;3D 深度人脸分析工具箱，在 discord 服务器加入 InsightFaceSwap 机器人和 Midjourney 机器人，可以让它帮助我们进行 AI 换脸。
2. InsightFaceSwap 使用步骤 1、首先我们需要在 discord 添加 lnsightFaceswap 机器人，添加链接：
https://discord.com/oauth2/authorize?client_id=1090660574196674713&amp;permissions=274877945856&amp;scope=bot
保证服务器有 lnsightFaceswap 机器人和 Midjourney 机器人就可以了
2、输入命令/saveid，上传你的目标人脸，比如我这里上传的是彭于晏的脸，意思就是待会我要把彭于晏的脸换到别人身上
idname 的长度限制现在已增加到 10 个字符，并且可以保存的 idname 的最大数量已增加到 20。
3、出现“command sent”和“idname XXX created”字样就代表 id 已经创建成功
4、接着我们开始换脸操作，我需要把雷佳音的照片上传，然后用刚刚我们创建的彭于晏的脸替换，我们输入命令/swapid，在 idname 这里填写刚刚创建的 id 名，按回车等待出图就可以了
5、然后我们就得到了“彭佳音”，你也可以叫他“雷于晏”
🚫 使用 InsightFaceswap 注意事项：
可以使用/listid 来列出目前注册的所有 ID。总数不能超过 20 个。也可以用/delid 和 /delall 命令来删除 ID。
注册的 ID 名字只能用英文和数字，并且不超过 10 个字符。
你可以输入多个 idname，用逗号分割，用来实现多人脸替换的效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab66ec4d64aa63df5bee82309e60bda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62882bf79cdc4722ee5a4dd6b184c0b/" rel="bookmark">
			大数据实训（三）——MapReduce编程实例：词频统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#MapReduce#YARN#hdfs#IDEA#JDK1.8
实验三：Mapreduce词频统计
3.1启动hadoop服务，输入命令：
start-all.sh 3.2在export目录下，创建wordcount目录，在里面创建words.txt文件，向words.txt输入下面内容。
[root@bogon~]# mkdir -p /export/wordcount [root@bogon~]# cd /export/wordcount/ [root@bogon~]# vi words.txt [root@bogon~]# cat words.txt 3.3编辑结束，上传文件到HDFS指定目录
创建/wordcount/input目录，执行命令：
hdfs dfs -mkdir -p /wordcount/input 3.4将在本地/export/wordcount/目录下的words.txt文件，上传到HDFS的/wordcount/input目录，输入命令：
hdfs dfs -put /export/wordcount/words.txt /wordcount/input 在Hadoop WebUI界面查看目录是否创建成功
3.5使用IDEA创建Maven项目MRWordCount
在pom.xml文件里添加hadoop和junit依赖，内容为：
&lt;dependencies&gt; &lt;!--hadoop客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;3.3.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--单元测试框架--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.6创建日志文件：在resources目录里创建log4j.properties文件
log4j.rootLogger=ERROR, stdout, logfile log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.logfile=org.apache.log4j.FileAppender log4j.appender.logfile.File=target/wordcount.log log4j.appender.logfile.layout=org.apache.log4j.PatternLayout log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n 3.7创建词频统计映射器类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f62882bf79cdc4722ee5a4dd6b184c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e268a0c9d21e73feaef93670ae82d64/" rel="bookmark">
			数据库-MySQL 实战项目——学生选课系统数据库设计与实现（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 该项目非常适合MySQL入门学习的小伙伴，博主提供了源码、数据和一些查询语句，供大家学习和参考，代码和表设计有什么不恰当还请各位大佬多多指点。
所需环境 MySQL可视化工具：navicat； 数据库：MySql 5.7/8.0等版本均可； 需求: 学生选课系统主要完成某学校教务系统中选课功能：
学生信息管理教师信息管理课程信息管理教室信息管理选课管理 备注： 每个学生可选多门课程，每门课程有多个学生。每位教师教授一门课程。每个班级有多个学生，每个学生对应一个班级。 其中： 学生包含以下属性：学号、学生姓名、学生性别。
教师包含以下属性：教工号、教师姓名、教师职称。
课程包含以下属性：课程号、课程名、课程学分。
教室包含以下属性：班级编号、学生人数、班级名称。
选课包含以下属性：学生成绩。
二、E-R图 三、关系模式 课程（课程号、课程名、课程学分、教工号）
教师（教工号、教师姓名、教师职称）
选课（课程号、学号、成绩）
学生（学号、学生姓名、学生性别、班级编号）
班级（班级编号、学生人数、班级名称）
备注： 下划线为主键，红色字为外键；
四、数据表的设计 表1：课程 字段
数据类型
长度
备注
课程号
varchar
50
主键
课程名
varchar
50
Not.null
课程学分
int
3
教工号
varchar
50
外键
表2：教师 字段
数据类型
长度
备注
教工号
varchar
50
主键
教师姓名
varchar
50
Not.null
教师职称
varchar
50
表3：学生 字段
数据类型
长度
备注
学号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e268a0c9d21e73feaef93670ae82d64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413f1b1444ba1d7abada65454c559d78/" rel="bookmark">
			前端小案例——登录界面（正则验证, 附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 实现功能： 提供用户名和密码输入框。当用户提交表单时，阻止默认提交行为。使用正则表达式验证用户输入的内容，判断输入的是有效的邮箱地址还是身份证号码。根据验证结果，在输入框下方显示相应的提示信息。 实现逻辑： 当页面加载完成后，通过 document.addEventListener("DOMContentLoaded", function () { ... }); 来监听 DOMContentLoaded 事件，确保页面中的所有元素都已加载完毕。
获取表单元素 .form 并监听其提交事件 form.addEventListener("submit", function (event) { ... });。
在表单提交事件中，首先阻止默认的表单提交行为 event.preventDefault();，以便在验证用户输入后自行处理提交逻辑。
获取用户名输入框元素 userinput 和用于显示验证信息的元素 eer。
定义了两个正则表达式：emailRegex 用于验证邮箱地址，idCardRegex 用于验证身份证号码。
判断用户输入的内容是否符合邮箱地址或身份证号码的格式：
如果是有效的邮箱地址，则在 eer 元素中显示 "有效的邮箱地址"。如果是有效的身份证号码，则在 eer 元素中显示 "有效的身份证号码"。如果都不符合，则在 eer 元素中显示 "请输入有效的邮箱地址或身份证号码"。 最后，根据验证结果，在页面上显示相应的提示信息。
二、项目运行效果 三、全部代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;style&gt; .form { max-width: 350px; display: flex; flex-direction: column; gap: 20px; padding-left: 2em; padding-right: 2em; padding-bottom: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/413f1b1444ba1d7abada65454c559d78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66c3c1b03fd47389d06444d13a3e2af/" rel="bookmark">
			android开发：安卓13Wifi和热点查看与设置功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初级代码游戏的专栏介绍与文章目录-CSDN博客
我的github：codetoys，所有代码都将会位于ctfc库中。已经放入库中我会指出在库中的位置。
这些代码大部分以Linux为目标但部分代码是纯C++的，可以在任何平台上使用。
近日对安卓热点功能做了一些技术验证，目的是想利用手机开热点给设备做初始化，用的是安卓13，简言之：
热点设置功能不可用，不可设置SSID和密码，不可程序控制开启关闭，网上的代码统统都过时了LocalOnlyHotspot不可设置SSID和密码，只能系统随机（因为没有意义，所以也没有验证）wifi开关不能用程序设置，只能呼出配置界面让用户去操作热点开关无法呼出热点手机获取热点IP是可用的热点手机和设备的UDP广播是可用的 下面介绍细节。以下代码基于IDEA生成的默认简单应用，面向android 10，测试手机为android 13。textviewFirst是默认生成的标签，本代码用这个标签来显示结果。
目录
一、相关权限
二、获取wifi状态和呼出wifi设置界面
三、获取热点状态
一、相关权限 本文涉及到的权限如下（可能某些是不必要的）：
在AndroidManifest.xml增加如下设置：
&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; 实测一下应该能去掉几个权限。这里增加了权限之后还需要在程序里检查，如果没有权限就向用户提出授权申请。
启动代码的变量增加：
private static String[] PERMISSION_STORAGE = {"android.permission.ACCESS_WIFI_STATE" , "android.permission.CHANGE_WIFI_STATE" , "android.permission.CHANGE_WIFI_MULTICAST_STATE" , "android.permission.ACCESS_FINE_LOCATION" , "android.permission.ACCESS_COARSE_LOCATION" , "android.permission.INTERNET" }; private static int REQUEST_CODE_PERMISSION_STORAGE = 100; onCreate增加：
if (Build.VERSION.SDK_INT &gt;= 23) { for (String str : PERMISSION_STORAGE) { if (this.checkSelfPermission(str) != PackageManager.PERMISSION_GRANTED) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b66c3c1b03fd47389d06444d13a3e2af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c56d644b2b93eaed14343e212673fb8c/" rel="bookmark">
			【数据结构】【C语言】堆~动画超详细解读！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 什么是堆1.1 堆的逻辑结构和物理结构1.2 堆的访问1.3 堆为什么物理结构上要用数组?1.4 堆数据上的特点 2 堆的实现2.1 堆类型定义2.2 需要实现的接口2.3 初始化堆2.4 销毁堆2.5 堆判空2.6 交换函数2.7 向上调整(小堆)2.8 向下调整(小堆)2.9 堆插入2.10 堆删除2.11 //堆顶 3 完整代码3.1 heap.h3.2 heap.c 1 什么是堆 简单来说堆是二叉树的一种表示方式,它在逻辑上就是一颗完全二叉树,它在物理上却是一个数组,这么说可能有点抽象,我们原来学习的栈,队列,或者说顺序表,链表等等,他们的逻辑结构和物理结构是相同或者相似的,就会比较好理解一些,而在堆这里物理结构和逻辑结构截然不同,理解相对就会比较抽象一些,我们接着看 1.1 堆的逻辑结构和物理结构 逻辑结构即我们想象的结构,就比方说我们早上在图书馆排队的时候,放个包在图书馆门口,人可能都不见了,这个时候我们逻辑上认为我们在排队,但物理上我们同学就可能在吃早饭上厕所啥的逻辑上我们想象这个数组是一个二叉树,并且像二叉树一样访问子节点或者父节点 比方说我给出以下数组,它在逻辑上是这样表示的(当然哈,指针其实是不存在的,只是逻辑上我们看作其是父子关系):
1.2 堆的访问 既然堆是一颗货真价实的二叉树,可我们怎么像二叉树一样,通过父/子节点访问子/父节点呢? 通过父节点访问子节点： 我们假设父节点的下标为3,我们想访问它的子节点,只需要把 父节点的下标 * 2 + 1 或 父节点的下标 * 2 + 2 即可 即 7 或 8 通过子节点访问父节点 我们假设子节点的下标为7,我们想访问它的父节点,只需要把 (子节点的下标 - 1) / 2 即可 即 3我们假设子节点的下表为8,我们想访问它的父节点,依旧只需要把 (子节点的下标 - 1) / 2 即可 依旧是 3 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c56d644b2b93eaed14343e212673fb8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7b29e35551c1ae744dd8644bccb4c94/" rel="bookmark">
			探索移动云：我的ES与Kibana之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言：
如何免费体验移动云产品
登录并完成实名认证
选择试用ECS云主机
安全组配置
安装Elasticsearch和Kibana
安装Elasticsearch
​编辑安装kibana
测试结果
使用感觉
引言： 移动云技术产品的发展已经取得了巨大的进步。云数融合、A1、大数据等技术的应用，为我们带来了前所未有的便利和体验。通过云数融合技术，我们可以将多个云服务整合在一起，实现数据的无缝共享和同步。A1技术则为我们提供了智能化的辅助和个性化的推荐，大大提升了我们的用户体验。而大数据技术的应用，则让我们能够从海量数据中发现规律和趋势，为生活和工作提供更有针对性的解决方案。
在当今数字化时代，云计算已成为企业和个人不可或缺的一部分。作为一位科技爱好者，我一直对云计算技术充满好奇心。最近，我有幸体验了移动云服务，并通过在云主机ECS上安装Elasticsearch（ES）服务和Kibana插件，探索了云端数据分析的奥妙。在这篇文章中，我将在移动云主机服务器上如何安装Elasticsearch和Kibana来进行分析。
如何免费体验移动云产品 登录并完成实名认证 新用户即可登录免费使用1个月的云主机。进入首页查看：
点击免费试用：
选择试用ECS云主机 可以看到有五大方向的免费使用，选择一个自己喜欢的类型，或者是自己需要的，点击0元试用。跳转登录界面，并且完成实名认证后。跳转自动选择云主机参数：
这里我选择的是CentOS7.5，且各种参数人家都给你自动选择好了。确认订单即可。
然后可以看到都是0元，是不是非常开心，然后点击前往支付。
欧克啊，到这里我们就拥有了一台云主机，也称服务器。点击管理控制台，前往控制台查看。
安全组配置 到这里就确实拥有了一台云主机，接下来进行安全组配置。
进入安全组，放开以下端口。
接下来，我们在Xshell上面连接上服务器。
安装Elasticsearch和Kibana 接下来进行安装Elasticsearch和Kibana。
安装Elasticsearch 先修改系统最大可创建文件数：
#打开系统文件： vim /etc/sysctl.conf #配置最大可创建文件数： vm.max_map_count=655360 #配置生效： sysctl -p 将ES压缩包上传至虚拟机之后解压；并重命名，移动到local目录下；
#解压： tar -zxvf elasticsearch-7.17.0-linux-x86_64.tar.gz #重命名： mv elasticsearch-7.17.0 elasticsearch #移动文件夹： mv elasticsearch /usr/local/ 将IK分词器和拼音分词器上传至虚拟机，解压分词器到elasticsearch的plugins目录下；
# 解压ik分词器 unzip elasticsearch-analysis-ik-7.17.0.zip -d /usr/local/elasticsearch/plugins/analysis-ik # 解压拼音分词器 unzip elasticsearch-analysis-pinyin-7.17.0.zip -d /usr/local/elasticsearch/plugins/analysis-pinyin 其实这里服务器还不能识别unzip命令，需要下载
yum install unzip 下载完之后再进行解压并放到对应的目录去，解压成功如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7b29e35551c1ae744dd8644bccb4c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b34c296d41bf1e754738deed5359729/" rel="bookmark">
			【c&#43;&#43;】map和set的模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页：Quitecoder
🔥专栏：c++笔记仓
不断完善红黑树功能，最后封装模拟实现
目录 1.红黑树的改造由insert更改模版参数set和map的insert函数： 2.红黑树的迭代器++的实现：set迭代器：map迭代器find函数： 1.红黑树的改造 在前面的学习中我们知道
set和map是基于红黑树实现的，但是传的参数不一样，如果硬要按上面的参数匹配，我们需要两个红黑树，我们前面实现的红黑树都是pair实现的，下面我们看库中的实现方法：
库的实现取决于第二个模版参数value，这里与前面不一样，这里第二个传参如果是pair，意味着是map类型，传参是key，意味着是set类型
set构架：
namespace myown { template&lt;class K &gt; class set { private: RBTree&lt;K, K&gt; _t; }; } map构架：
namespace myown { template&lt;class K,class T&gt; class map { private: RBTree&lt;K, pair&lt;K,T&gt;&gt; _t; }; } 节点定义：
template&lt;class T&gt; struct RBTreeNode { RBTreeNode&lt;T&gt;* _left; RBTreeNode&lt;T&gt;* _right; RBTreeNode&lt;T&gt;* _parent; T _data; Colour _col; RBTreeNode(const T&amp; data) :_left(nullptr) , _right(nullptr) , _parent(nullptr) , _data(data) ,_col(RED) {} }; 红黑树结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b34c296d41bf1e754738deed5359729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb7ceeac18824b9de7a4046065d1eac/" rel="bookmark">
			matlab如何实现LDLT分解（改进的平方根法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab如何实现LDLT分解（改进的平方根法） 前言一、思路说明二、LDLT分解的函数（.m文件后缀）总结 前言 提示：本篇博客仅提供函数代码，不进行数学推导！需要了解数学推导的uu请移步其他博客！
笔者这学期选修了数值计算这门课程。一次实验报告中需要自行编写LDLT分解的函数，并在脚本文件中调用此函数，返回求得的x、L、D。
可能由于这个方法较为冷门？（瞎猜的，别cue我）网上相关的资料很少，能找到的、不用开vip就能看的文章只有个位数。。。因此能参考的内容实在太少。
求人不如求己！ 自！己！来！
所以笔者的灵感来自于老师已经给出的Cholesky分解、LU分解的函数文件上进行修改，最终完成了LDLT方法的求解函数。（事实上，老师布置这道题的初衷就是希望我们能在他给出的函数文件上进行修改，进而得到LDLT分解的函数）
秉着乐于助人的原则（always），遂把此代码分享在各个平台。愿在世界各地因同样问题正在挠头的你们，能看到这篇博客吧。
ps：笔者是刚入门matlab和数值计算的菜鸟，若以下代码有更加简略的写法，欢迎评论区留言或私信我~
提示：以下是本篇文章正文内容
一、思路说明 1.假设我们要使用LDLT分解解如下一个方程组：
{ 4 x 1 − 2 x 2 − 4 x 3 = 10 − 2 x 1 + 17 x 2 + 10 x 3 = 3 − 4 x 1 + 10 x 2 + 9 x 3 = − 7 \begin{cases} \ 4x_1- 2x_2-4x_3=10\\ \ -2x_1+17x_2+10x_3=3\\ \ -4x_1+10x_2+9x_3=-7 \end{cases} ⎩ ⎨ ⎧​ 4x1​−2x2​−4x3​=10 −2x1​+17x2​+10x3​=3 −4x1​+10x2​+9x3​=−7​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bb7ceeac18824b9de7a4046065d1eac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/342/">«</a>
	<span class="pagination__item pagination__item--current">343/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/344/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>