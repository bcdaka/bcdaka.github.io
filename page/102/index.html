<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d39be3a5019cb1a12d65e014cf81a98/" rel="bookmark">
			【STM32】STM32单片机入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页~
这是一个新的系列，stm32单片机系列，资料都是从网上找的，主要参考江协科技还有正点原子以及csdn博客等资料，以一个一点没有接触过单片机但有一点编程基础的小白视角开始stm32单片机的学习，希望能对也没有学过51直接学32的同学们有一定的作用和帮助
文章内容有很多是自己的理解，希望各位嵌入式大佬们可以看一下文章然后帮忙指正一下错误，感谢！
正片开始
初学stm32单片机 一、准备条件二、外设1、GPIO通用输入输出口2、调试工具3、EXTI外部中断AFIO复用输入输出口 4、TIM定时器5、USART串口6、I2C通信7、SPI通信8、RTC实时时钟 三、创建工程四、分析系统结构五、引脚定义六、启动配置七、最小系统电路 一、准备条件 直接在B站上搜索stm32江协科技，在那里下载安装包，按照2-1和2-2的步骤下载好安装好需要的配件：Keil5MDK以及F1单片机资源，新建好一个工程
啰嗦的我就不再叙述了，这款芯片使用的是STM32F1
内核为ARM Cortex-M3
主频为72MHz
随机存取存储器RAM大小为20K，实际存储介质为SRAM
只读存储器ROM大小为64K，实际存储介质为Flash
标准3.3V供电
SRAM和Flash的位置：
这张图下面再分解
二、外设 在江协科技的PPT中，up为我们整理了整个芯片所有的外设，但有些外设用的比较少，有句话叫做20%的外设可以应用到80%的场景下，所以作为入门博客，我会把常用的外设罗列清楚，不太用的就不再介绍了
每个单片机都要用到的一个外设就是RCC，它负责控制系统时钟和复位相关功能，只要MCU想要驱动程序，必须由RCC来设置初始化时钟，因为静息状态下硬件为了节省功耗是不工作的
除了RCC以外，最常用的就是以下八个外设：
1、GPIO通用输入输出口 单片机芯片引脚大多数都是GPIO口，用来输入和输出，根据引脚的数量分为GPIOA、GPIOB、GPIOC等，GPIOA又分为GPIOA0到GPIOA15，简写问PA0到PA15，16个引脚
GPIO有四种输入模式四种输出模式
输入模式：浮空输入、上拉输入、下拉输入、模拟输入
输出模式：开漏输出、推挽输出、复用开漏输出、复用推挽输出
其中输出模式全部为数字输出，输入模式仅模拟输入为模拟输入，其他都为数字输入
引脚定义图：
可以看到大多数的引脚都为GPIO通用输入输出口
2、调试工具 这一章主要讲怎么调试，有三种调试方式：
（1）串口调试，通过串口通信，电脑使用串口助手显示调试信息
（2）显示屏调试，也就是使用OLED屏调试
（3）Keil调试，也就是使用开发软件进行调试
这里我在学习的过程中不知道串口是什么，在网上搜了一下得出的答案是：多用途的接口，它允许计算机和外部设备之间的数据传输
这里我们更加推荐显示屏调试以及Keil调试，显示屏调试时最简单的，对于学过C语言的同学而言使用Keil软件进行调试应该是比较容易上手的
3、EXTI外部中断 中断是在主程序的运行过程中，出现了特定的中断触发条件（也就是中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后返回原来的位置继续执行程序
当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急选择相应更加紧急的中断源，更紧急的中断源优先级更高，我们可以通过编写程序的方式决定中断源优先级
当一个中断程序正在运行时，优先级更高的中断源申请中断，那么当前程序中断，先执行优先级更高的中断程序
AFIO复用输入输出口 AFIO主要用于引脚复用功能的选择和重定义
它主要完成两个任务：复用功能引脚重映射、中断引脚选择
4、TIM定时器 TIM就是timer，定时器的简写，可以对输入的时钟进行计数，并且在计数值达到设定值时触发中断
时钟：一个周期性的信号，用于为定时器提供一个稳定的、可测量的时间基准。这个时钟信号可以是STM32内部生成的，也可以是外部提供的
根据复杂度和应用场景定时器分为高级定时器、通用定时器、基本定时器三种类型
5、USART串口 USART是一种全双工通用同步（异步）串行收发模块，用于实现数据在微控制器与外部设备之间的串行通信，它支持同步和异步操作，能够独立地进行数据的接收和发送
6、I2C通信 I2C是一种双向、二线制、串行总线标准，用于连接低速外围设备
I2C总线由两根信号线组成，分别是时钟线（由主机设备控制，用于同步数据传输的时钟信号）和数据线（用于在主机和从机之间传输数据）
7、SPI通信 SPI通信以主从方式工作，即一个主机和一个或多个从机之间的通信
SPI也支持全双工通信，主设备和从设备可以同时发送和接收数据
8、RTC实时时钟 RTC模块的工作原理基于一个32位的计数器，该计数器以固定的时间间隔（通常为1秒）递增。当计数器溢出时，会产生一个中断或触发其他事件。在STM32中，RTC模块通常与电源管理模块和备份寄存器配合使用，以实现断电保护和数据恢复功能
三、创建工程 根据视频的步骤安装好后大约就是这样的效果：
四、分析系统结构 这里的系统结构视频中应该已经分析的挺清楚了，但是我第一遍听的时候也是没有听懂，所以搁这里做一个复盘
左上角的Cortex-M3是MCU，引出三根总线，通过ICode总线连接Flash接口，加载程序指令；DCode数据总线也连接Flash，加载数据；System系统总线，连接比如SRAM，存储运行时的变量数据，还有FSMC，FSMC是外接存储，不为我们所要梳理的内容
AHB系统总线用于挂载主要外设，意思是先进高性能总线，挂载着RCC和SDIO，SDIO用于连接外接SD卡，不为我们所要梳理的内容
通过桥接1和桥接2分别接到APB2和APB1两个外设总线上，APB用于连接一般的外设，APB2一般连接外设中比较重要的部分，APB1主要连接外设中稍微不重要的部分
由于MCU主要进行一些重要的工作，某些简单的工作我们不准备使用MCU来进行了，这里给MCU配备了DMA，用来处理一些很简单的程序，比如数据的挪用等简单但是要反复作用的事情，它通过DMA总线连接到总线矩阵上，它与MCU一样有总线的控制权，用于访问外设，当需要搬运数据等的操作时，外设会通过请求线向DMA发出请求，然后DMA就会获得总线控制权，进行操作
五、引脚定义 这份材料是由江协科技up整理出来的，对初学者是友好的，因为一上来就看手册很容易被劝退，stm32的手册又长又多，看起来是很难受的，这里简单梳理一下引脚的作用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d39be3a5019cb1a12d65e014cf81a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ffaace9516002d9a5077118a2a0bcd/" rel="bookmark">
			SpringMVC源码解析(二)：请求执行流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC源码系列文章
SpringMVC源码解析(一)：web容器启动流程
SpringMVC源码解析(二)：请求执行流程
目录 前言DispatcherServlet入口一、获取HandlerExcutionChain(包括Handler)1、获取Handler1.1、通过request获取查找路径1.2、通过查找路径获取HandlerMethod 2、获取执行链(包括Handler、拦截器) 二、获取适配器三、执行Handler（🔥重点）1、获取请求参数1.1、获取参数解析器1.2、解析@RequestBodey请求参数1.2.1、消息转换器1.2.2、RequestBodyAdvice请求增强器 2、执行Controller具体逻辑方法3、返回对象转为响应信息(json)3.1、获取返回值处理器3.2、返回值处理器处理方法3.2.1、消息转换器3.2.2、ResponseBodyAdvice响应增强器 四、拦截器1、执行拦截器preHandle方法2、执行拦截器postHandle方法3、执行拦截器afterCompletion方法 五、异常处理器总结 前言 前文中我们介绍了SpringMVC容器的启动，包括前端控制器DispatcherServlet对象的创建，过滤器添加到Tomcat容器的过滤器集合中，将所有拦截器、跨域配置、消息转换器等配置统一添加到各自集合中，解析@RequestMapping注解生成请求路径和Controller方法的映射map。本章来研究下请求的执行过程。
说到请求过程，那么得先说下入口在哪里？入口肯定是统一分发请求给处理程序的DispatcherServlet，DispatcherServlet归根结底也是Servlet。Tomcat通过请求Mapping映射和Servelt对应关系找到Servelt，调用Servelt之前会执行过滤器链，所有过滤器放行才会走到Servelt真正的执行逻辑。
依照常见的post请求为例 // 接受User对象并返回 @PostMapping("/test") @ResponseBody public User test(@RequestBody User user) { user.setName("李四"); System.out.println(user); return user; } 方法栈调用链 HttpServelt#service分水岭doPost方法，只要找到DispatcherServelt重写的doPost方法就是入口了 本文就不讲过滤器的调用了，因为从DispatcherServelt开始，过滤器链已经执行完成，之前文章Tomcat源码解析(八)：一个请求的执行流程（附Tomcat整体总结）有介绍过。
DispatcherServlet入口 DispatcherServlet的类图如下：
从doPost到doDispatch方法
doPost方法是由DispatcherServelt的父类FrameworkServlet实现的不论post还是get请求都是调用同一个方法processRequest(request, response)对于方法参数request和respons都是Tomcat容器创建的，以前文章Tomcat源码解析(七)：底层如何获取请求url、请求头、json数据？有具体介绍 主要方法doService(request, response) // FrameworkServlet类方法 protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { long startTime = System.currentTimeMillis(); Throwable failureCause = null; ... try { doService(request, response); } catch (ServletException | IOException ex) { failureCause = ex; throw ex; } catch (Throwable ex) { failureCause = ex; throw new NestedServletException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92ffaace9516002d9a5077118a2a0bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f16bb548cf52027f5a74ea871ec8cb5e/" rel="bookmark">
			写代码对人的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 代码是需要跑起来的，不能你写了一段代码运行不了
2 代码过程中有大量的bug，经常异常报错，你需要花费时间去解决
对人的影响就是解决问题的态度得到强化，解决问题要比坚持正确困难，坚持正确只是需要自然而然的努力，就像在宽敞的大路上面慢慢前进，而解决问题是在陡峭的没有开发的山脉上面前行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387794c0d3d4bb1d9275487853541866/" rel="bookmark">
			【数据结构初阶】单链表经典算法题十道（详解&#43;图例）—得道飞升（终篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hi ！
目录
9、 环形链表 ||
10、随机链表的复制
终章
9、 环形链表 || 【图解】 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ typedef struct ListNode ListNode; struct ListNode *detectCycle(struct ListNode *head) { //找相遇节点 ListNode* slow=head; ListNode* fast=head; while(fast&amp;&amp;fast-&gt;next) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast) { //相遇，开始遍历 ListNode* pcur=head; while(slow!=pcur) { slow=slow-&gt;next; pcur=pcur-&gt;next; } return slow; } } return NULL; } 10、随机链表的复制 【图解】 【思路】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/387794c0d3d4bb1d9275487853541866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3ecf2d57b254117202618074bc8b1b/" rel="bookmark">
			Cocos Creator2D游戏开发(5)-飞机大战(3)-手指操作玩家飞机移动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加玩家飞机
1.创建player_node节点
2.将资源中Player图片拖入player_node节点
3.将Player的Position属性值调整为(0,-300) Content Size属性调整为(100 100)
4.点击运行,飞机在屏幕上了
2 用手指拖着飞机跑流程
① 要监听手指按下
②判断手指是否在飞机上
③移动飞机
④监听手指离开
创建一个脚本Player.ts , 场景节点选player_node节点, 将Player.ts拖入右边属性检查器,保存;
Player.ts脚本 import { _decorator, Component, EventTouch, Input, input, UITransform} from 'cc'; const { ccclass, property } = _decorator; @ccclass('Player') export class Player extends Component { private isPress; //是否按下 start() { this.isPress = false; } onLoad() { input.on(Input.EventType.TOUCH_START, this.onTouchStart, this); //注册按下事件 input.on(Input.EventType.TOUCH_MOVE, this.onTouchMove, this); // 注册移动事件 input.on(Input.EventType.TOUCH_END, this.onToucheEnd, this); // 注册离开事件 } onToucheEnd(event: EventTouch) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e3ecf2d57b254117202618074bc8b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c643a33267132abc1c8cf7ca307183/" rel="bookmark">
			Javascript前端面试（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 部分
1. JavaScript 有哪些数据类型，它们的区别？
JavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、
Number、String、Object、Symbol、BigInt。
其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：
●Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了
解决可能出现的全局变量冲突的问题。
●BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数， 使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了
Number 能够表示的安全整数范围。
这些数据可以分为原始数据类型和引用数据类型：
●栈：原始数据类型（Undefined、Null、Boolean、Number、String）
●堆：引用数据类型（对象、数组和函数） 两种类型的区别在于存储位置的不同：
●原始数据类型直接存储在栈（stack）中的简单数据段， 占据空间 小、大小固定，属于被频繁使用数据，所以放入栈中存储；
●引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固 定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈 中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引 用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：
●在数据结构中，栈中数据的存取方式为先进后出。
●堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大 小来规定。
在操作系统中，内存被分为栈区和堆区
●栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的 值等。其操作方式类似于数据结构中的栈。
●堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可 能由垃圾回收机制回收。
2. 数据类型检测的方式有哪些
（1）typeof
其中数组、对象、null 都会被判断为 object，其他判断都正确。
（2）instanceof
instanceof 可以正确判断对象的类型，其内部运行机制是判断在其
原型链中能否找到该类型的原型。
可以看到，instanceof 只能正确判断引用数据类型，而不能判断基 本数据类型。instanceof 运算符可以用来测试一个对象在其原型链
中是否存在一个构造函数的 prototype 属性。
（3） constructor
constructor 有两个作用，一是判断数据的类型，二是对象实例通过 constr cutor 对象访问它的构造函数。需要注意，如果创建一个对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c643a33267132abc1c8cf7ca307183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6f1f5e751c692470ab33d6f589a078/" rel="bookmark">
			【二叉树】—— 算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单值二叉树 题目要求：判断二叉树是不是单值二叉树（就是所以节点的值都相等）。
思路：
利用二叉树的递归思想，判断每一个节点值与其左右子节点的值是否相等，如果遇到空节点，就返回true（说明每一个节点值都相等）；如果遇到节点的值与其左右节点值不相等就返回false；如果该节点的值与其左右子节点的值都相等，就接着递归该节点的左右子树。
代码如下：
bool isUnivalTree(struct TreeNode* root) { if (root == NULL) { return true; } if (root-&gt;left &amp;&amp; root-&gt;left-&gt;val != root-&gt;val) { return false; } if (root-&gt;right &amp;&amp; root-&gt;right-&gt;val != root-&gt;val) { return false; } return isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right); } 二、相同的树 — 对称二叉树 — 另一颗树的子树 2.1、相同的树 判断两个二叉树是否相等
思路：
同时遍历两个二叉树，如果遍历到两个二叉树节点同时为空，就说明这两个二叉树相同；如果其中一个为空而另一个不为空，就说明两个二叉树不相同；如果遍历过程中，遇到两个二叉树节点的值不相等，则两个二叉树不相同。
简单分析一下：
同时遍历这两个二叉树
两个二叉树节点都不为空且值相等，继续遍历其左子树
两个二叉树节点都不为空且值相等，继续遍历其左子树
两个二叉树节点都为空，返回true
先遍历二叉树是2节点的右节点，也为空，这里直接跳过了。
这里回退到1这个节点，接下来遍历1的右子树
遍历到节点都不为空，且值相等，继续遍历 （这因为3的左右节点都为空，就一步带过）
遍历结束，没有遇到一个节点为空一个节点不为空或者值不相等的情况，就返回true。
代码如下：
typedef struct TreeNode TreeNode; bool isSameTree(struct TreeNode* p, struct TreeNode* q) { if (p == NULL &amp;&amp; q == NULL) { return true; } if (p == NULL || q == NULL) { return false; } if (p-&gt;val !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6f1f5e751c692470ab33d6f589a078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad09a19edd0575557cb664b68973493/" rel="bookmark">
			指针！！C语言(第三篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 二维数组传参的本质
二. 函数指针变量和函数指针数组
三. typedef关键字
四. 转移表
五. 回调函数以及qsort使用举例
一. 二维数组传参的本质 🍟首先我们先回顾一下二维数组是怎样传参的？我们需要传入数组名以及行数和列数，这样才能将一个二维数组传入一个函数中，除了这样我们还能怎么办？首先认识一下二维数组传参的本质，我们知道二维数组其实是一维数组组成的，所以二维数组的数组名也是数组首元素的地址，二维数组的首元素的地址就是它的第一行。
所以，根据这个规则我们的传参就可以有另一种方式，如下： //二维数组传参的本质 void test1(int(*p)[5], int r, int c) { for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { printf("%d ", *(*(p + i) + j)); } printf("\n"); } } int main() { int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} }; test1(arr, 3, 5); return 0; } 总结：二维数组传参，形参的部分可以写成数组，也可以写成指针形式。 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ad09a19edd0575557cb664b68973493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6476ac9ce82cef1c0dba701d740461/" rel="bookmark">
			hadoop学习（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.MapReduce
1.1定义：是一个分布式运算程序的编程框架
1.2核心功能：将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个Hadoop集群上。
1.3优点
1）易于编程
它简单的实现一些接口，就可以完成一个分布式程序，这个分布式程序可以分布到大量廉价的PC机器上运行（正是因为这个特点使MapReduce编程变得非常流行）
2）良好扩展性
可以通过简单地增加机器来扩展它的计算能力。
3）高容错性
MapReduce设计的初衷就是使程序能够部署在廉价的PC机器上，这就要求它具有很高的容错性。比如其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行，不至于这个任务运行失败，而且这个过程不需要人工参与，而完全是由Hadoop内部完成的。
4）适合PB级以上海量数据地离线处理
可以实现上千台服务器集群并发工作，提供数据处理能力。
1.4缺点
1）不擅长实时计算
无法像MySQL一样，在毫秒或者秒级内返回结果
2）不擅长流式计算
流式计算的输入数据是动态的，而MapReduce的输入数据集是静态的，不能动态变化。这是因为MapReduce自身的设计特点决定了数据源必须是静态的。
3）不擅长有向无环图计算
每个MapReduce作业的输出结果都会写入到磁盘，会造成大量的磁盘IO，导致性能非常的低下。
1.5MapReduce核心思想
1）分布式的运算程序往往需要分成至少2个阶段。
2）第一个阶段的MapTask并发实例，完全并行运行，互不相干。
3）第二个阶段的ReduceTask并发实例互不相干，但是他们的数据依赖于上一个阶段的所有MapTask并发实例的输出。
4）MapReduce编程模型只能包含一个Map阶段和一个Reduce阶段，如果用户的业务逻辑非常复杂，那就只能多个MapReduce程序，串行运行。
总结：分析WordCount数据流走向深入理解MapReduce核心思想。
1.6 MapReduce进程
一个完整的MapReduce程序在分布式运行时有三类实例进程：
1）MrAppMaster：负责整个程序的过程调度及状态协调。
2）MapTask：负责Map阶段的整个数据处理流程。
3）ReduceTask：负责Reduce阶段的整个数据处理流程。
1.7常用数据反序列类型
1.8 编程规范
编写程序可分为Mapper、Reducer和Driver三部分。
Mapper阶段：
1）自定义的Mapper要继承自己的父类
2）Mapper的业务逻辑写在map（）方法中
3）Mapper的输入、输出数据是K-V对的形式
4）map（）方法（Map Task进程）对每一个k-V调用一次
Reducer阶段
1）自定义的Reduce要继承自己的父类
2）业务逻辑写在reduce（）方法中
3）Reduce的输入数据类型对应Mapper的输出数据类型
4）ReduceTask进程对每一组相同k的&lt;k,v&gt;组调用一次reduce()方法
Driver阶段
相当于YARN集群的客户端，用于提交我们整个程序到YARN集群，提交的是封装了MapReduce程序相关运行参数的job对象。
二、Hadoop序列化
2.1 序列化和反序列化
序列化就是把内存中的对象，转换成字节序列（或其他数据传输协议）以便于存储到磁盘（持久化）和网络传输。 反序列化就是将收到字节序列（或其他数据传输协议）或者是磁盘的持久化数据，转换成内存中的对象。
2.2为何不使用Java的序列化
Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，Header，继承体系等），不便于在网络中高效传输。
2.3 Hadoop序列化的特点
1）紧凑：高效使用存储空间
2）快速：读写数据的额外开销小
3）互操作：支持多语言的交互
2.4 实现bean对象序列化
1）必须实现Writable接口（FlowBean继承Writable接口）
2）反序列化时，需要反射调用空参构造函数，所以必须有空参构造
public FlowBean() { super(); } （3）重写序列化方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac6476ac9ce82cef1c0dba701d740461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44284dd0b36f421d24a1aa0b510ed3d4/" rel="bookmark">
			一篇笔记总结HTML基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基础认识
1、铺垫
2、HTML初认识
（1）HTML骨架
（2） HTML语法规范
二、标签学习
1、排版标签
（1）标题标签
（2）段落标签
（3）换行标签与水平线标签
（4）整体展示
​编辑
2、文本格式化标签 3、媒体标签 （1）路径
（2）图片
（3）音频标签
（4）视频标签 （5）链接标签 4、列表标签
5、表格标签
6、表单标签
（1）基本使用
（2）placeholder属性：文本框占位符
（3）单选功能和默认选中 （4）上传多个文件
（5）按钮 （6）select下拉菜单标签
（7）textarea 文本域标签
（8） label标签
7、语义化标签
（1）没有任何语义的布局标签
（2）有语义的布局标签
8、字符实体
一、基础认识 1、铺垫 HTML、CSS和JavaScript常常一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。大家都知道，网页一般由文字、图片、音频、视频、超链接等组成。而一个HTML文件经过浏览器的解析和渲染之后就变成了用户看到的可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，因此使其成为一种标记语言而不是编程语言。其超文本标记语言（HTML全称HyperTextMarkupLanguage）的名称也表明这一点。
由于市面上的浏览器并不统一，其对应的渲染引擎也大相径庭，因此对于相同代码的解析效果也存在一定的差异。为了保证用户的体验，一般使用web标准进行网页开发。web标准由三部分构成：
构成语言说明结构HTML网页元素和内容表现CSS网页元素的外观和位置等页面样式行为JavaScript网页模拟的定义与页面交互 2、HTML初认识 （1）HTML骨架 HTML是一种标记语言，它通过使用一系列的标签来实现其一系列的功能。而这些标签的排版也并不是杂乱无章的，它们有一定的骨架结构（如整体、头部、标题、主体等）。
可以看到，整个HTML代码都被包含在&lt;html&gt;&lt;/html&gt;标签中。html标签中包含了head（头部）和body（主体） 标签。而head标签中又包含了title（标题）标签。这就是HTML的基础骨架。其中title标签中的内容就对应网页的标题。例如：
（2） HTML语法规范 注释：为代码添加的具有解释性、描述性的信息，主要用来帮助开发人员理解代码。在VS code中一般使用 ctrl+/ 添加注释。
&lt;!-- 这是一个注释 --&gt; 结构构成：标签主要有&lt;、&gt;、/和一些英文字母组成。其中把由&lt;&gt;包起来的单词或者字母叫做标签名。 大多数标签由两部分组成，被称为双标签。前部分是开始标签，后半部分时结束标签。还有一些标签由一部分组成，被称为单标签，单标签无法包裹内容。
&lt;h1&gt;双标签&lt;/h1&gt; &lt;!-- 双标签 --&gt; &lt;hr&gt; &lt;!-- 单标签 --&gt; 标签之间的关系：HTML标签与标签之间的关系可以分为两种：父子关系（嵌套关系）、兄弟关系（并列关系）。很好理解，父子关系就是父标签包裹子标签之间的关系，而兄弟关系两个标签相互并列，共处同级的关系。
二、标签学习 提要：网页一般由文字、图片、音频、视频、超链接组成。而作为一种超文本标记语言，HTML实际上就是通过标签来展现这些内存的。因此，标签的学习可以分为四个部分：排版标签、文本格式化标签、媒体标签、链接标签。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44284dd0b36f421d24a1aa0b510ed3d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ae444a94ebde1cef7e14455d9ec253/" rel="bookmark">
			kafka架构&#43;原理&#43;源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装jdk17 sudo yum -y update sudo wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.rpm sudo yum -y install ./jdk-17_linux-x64_bin.rpm sudo java -version 2.安装kafka How to easily install kafka without zookeeper | Aditya’s Blog 1.kafka架构图 2.kafka producer 在 Kafka 中，一个文件并不直接对应一个分区，但每个分区会有多个文件来存储其数据。
Kafka 存储结构 分区: Kafka 的每个主题（topic）可以有一个或多个分区。每个分区是一个有序的、不可变的消息日志。
日志文件: 每个分区会被存储在一组日志文件中。Kafka 将每个分区的数据分成多个日志段（log segments）文件，这些文件是按时间顺序生成的，文件名中包含文件的创建时间戳和其他信息。
文件结构 分区目录: 每个分区在 Kafka 的日志目录下有一个目录，例如 /tmp/kafka-logs/topic1-0。这个目录的名称中包含了主题名称和分区编号。
日志段文件: 在每个分区目录下，会有多个日志段文件，这些文件通常以 .log 为后缀。例如，00000000000000000000.log、00000000000000000001.log 等。
索引文件: 除了日志文件外，每个日志段还有对应的索引文件 (.index) 和时间戳文件 (.timeindex)，用于加速数据的查找和存取。
示例 假设你有一个主题 my-topic，它有两个分区（0 和 1），在 Kafka 的数据目录下，你会看到类似以下的文件结构：
bash
复制代码
/tmp/kafka-logs/my-topic-0/ 00000000000000000000.log 00000000000000000000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ae444a94ebde1cef7e14455d9ec253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e265dc34fc4b6d3f49bcf54e07c403d1/" rel="bookmark">
			Webpack 从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(创作不易，感谢有你，你的支持，就是我前行的最大动力，如果看完对你有帮助，请留下您的足迹）
目录
一、Webpack 简介
二、Webpack 的核心概念
三、Webpack 的安装与配置
安装 Node.js
安装 Webpack
初始化项目
安装项目依赖的 Webpack
创建项目文件
配置 Webpack
修改 package.json
构建项目
四、加载器（Loaders）的使用
使用 CSS 加载器
使用图片加载器
五、插件（Plugins）的使用
使用 HtmlWebpackPlugin
使用 CleanWebpackPlugin
六、开发服务器（DevServer）
安装 webpack-dev-server
配置 devServer
修改 package.json
启动开发服务器
一、Webpack 简介 Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。它会根据模块的依赖关系，递归地构建一个依赖图（dependency graph），然后将这些模块打包成一个或多个 bundle。
Webpack 的主要目标是将 JavaScript 文件打包在一起用于在浏览器中使用，但它也能够通过 loader 的机制来打包其他资源，如 CSS、图片和 HTML。
二、Webpack 的核心概念 入口（Entry）：Webpack 应该使用哪个模块作为构建其内部依赖图的开始。换句话说，入口起点指示 webpack 应该使用哪个模块作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。
输出（Output）：告诉 Webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e265dc34fc4b6d3f49bcf54e07c403d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e6d8fa966cc5535d3156bf1df72c33e/" rel="bookmark">
			Vue.js中的computed属性：高效的数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤍 前端开发工程师、技术日更博主、已过CET6
🍨 阿珊和她的猫_CSDN博客专家、23年度博客之星前端领域TOP1
🕠 牛客高级专题作者、打造专栏《前端面试必备》 、《2024面试高频手撕题》
🍚 蓝桥云课签约作者、上架课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 摘要：引言：正文：1. computed属性简介2. computed属性的使用方法3. computed属性的应用场景4. 实际应用案例 总结：参考资料： 摘要： 本文将介绍Vue.js中computed属性的特点、作用及其在实际项目中的应用，帮助读者更好地理解computed属性的重要性，提高前端开发的效率。
引言： 在Vue.js开发中，computed属性是一种高效的数据处理方式，它允许开发者计算和返回一个值。本文将带你深入了解computed属性的使用和配置方法。
正文： 1. computed属性简介 computed属性是Vue.js中的一种数据计算方式，它允许开发者定义一个计算属性，并在需要时返回计算后的值。computed属性具有以下特点：
高效的数据处理：computed属性是基于Vue.js的响应式系统实现的，它会在依赖的数据发生变化时自动重新计算。简洁的语法：computed属性使用简洁的语法，使得代码更加简洁和易于阅读。缓存计算结果：computed属性会缓存计算结果，当依赖的数据没有发生变化时，不会重新计算，从而提高性能。 2. computed属性的使用方法 要在Vue.js中使用computed属性，首先需要在组件的data对象中定义依赖的数据，然后在computed属性中定义计算方法。
示例：
export default { data() { return { value1: 1, value2: 2 }; }, computed: { sum() { return this.value1 + this.value2; } } }; 3. computed属性的应用场景 computed属性在实际项目中具有广泛的应用，以下是一些典型的应用场景：
计算属性和数据绑定：使用computed属性计算和返回一个值，并将其绑定到模板中。数据过滤和处理：使用computed属性对数据进行过滤和处理，以满足业务需求。事件处理和交互：使用computed属性计算和返回一个值，并将其绑定到事件处理函数中。 4. 实际应用案例 计算属性在Vue.js中是一个非常有用的功能，它允许你根据其他响应式依赖项动态计算新值。以下是一些实际应用案例：
过滤列表：假设你有一个用户列表，你想要根据用户活跃状态进行过滤。 &lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e6d8fa966cc5535d3156bf1df72c33e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/785cc05969522afb292735fb1e2af008/" rel="bookmark">
			轻松上手MYSQL：JSON函数实现高效数据查询与操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈 个人主页：danci_
🔥 系列专栏：《设计模式》《MYSQL》
💪🏻 制定明确可量化的目标，坚持默默的做事。
✨欢迎加入探索MYSQL字符串函数之旅✨
👋 大家好！文本学习和探索MYSQL的JSON函数。👋 在现代数据处理领域，JSON格式已成为数据交换的标准，而MySQL的JSON函数则为其提供了强大的支持。无论是存储、查询还是操作JSON数据，MySQL JSON函数都能让你事半功倍。本文将带你深入了解这些强大的工具，帮助你实现高效的数据处理与查询。准备好解锁JSON数据的新技能了吗？让我们一起探索MySQL JSON函数的无限可能！
目录
一、JSON_EXTRACT 提取指定数据
二、JSON_UNQUOTE 取消双引号
三、JSON_KEYS 取成员的数组
四、JSON_ARRAY 将参数转为数组
五、JSON_OBJECT 参数转为对象
六、JSON_DEPTH 取JSON深度
七、JSON_LENGTH 取节点长度
八、JSON_CONTAINS 判断是否包含
九、JSON_ARRAY_APPEND 追加值
十、JSON_ARRAY_INSERT 指定位置插入值
十一、JSON_CONTAINS_PATH 判断是否存在
十二、JSON_INSERT 插入数据
十三、JSON_MERGE 多个JSON合并
十四、JSON_MERGE_PATCH 多个JSON替换合并
十五、JSON_MERGE_PRESERVE 多个JSON合并
十六、JSON_OVERLAPS 判断有无相同键或值
十七、JSON_PRETTY 格式化输出
十八、JSON_REMOVE 删除指定数据
十九、JSON_REPLACE 替换数据
二十、JSON_SCHEMA_VALID 验证JSON文档
二十一、JSON_SCHEMA_VALIDATION_REPORT 验证JSON文档
二十二、JSON_SEARCH 查找
二十三、JSON_SET 插入或更新数据
二十四、JSON_STORAGE_FREE 释放空间
二十五、JSON_STORAGE_SIZE 占用字节数
二十六、JSON_TABLE 提取数据
二十七、JSON_TYPE 取类型
二十八、JSON_VALID 验证有校性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/785cc05969522afb292735fb1e2af008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c181163d6e5788df745b6319e909972/" rel="bookmark">
			区块链可投会议CCF B--DSN 2025 截止12.4 附2024年录用率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Conference：The 55th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
CCF level：CCF B
Categories：Network and Information Security
Year：2025
Conference time：Naples, Italy, June 23-26, 2025
录用率：2024年接收率21%（42/204）,其中区块链文章8篇，点击查看详情
Authors are invited to submit original papers on all topics within this broad scope. Example topical areas include but are not limited to the following:
Hardware (e.g., microprocessors, memory systems, systems on chip, I/O devices, storage systems, Trusted Execution Environments (TEEs), edge and mobile devices, data center infrastructure, hardware accelerators, emerging technologies, emerging paradigms like processing in memory &amp; quantum computing)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c181163d6e5788df745b6319e909972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0eabdc772799a7999410b4fea9c421/" rel="bookmark">
			C#华为OD笔试题*3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#华为OD笔试题*3 背景 参加了一下华为OD笔试，共三道题特此记录一下前两道都对了，第三道还在研究之后更新。
代码 题目1 轮转寿司店办活动,假设5盘寿司价格分别为3 14 15 6 5，买其中一盘寿司则赠送下一盘价格小于他的寿司，最低价格不赠送，比如买14价格的寿司 赠送6元的 买5元的赠送3元的，请输出实际商品价值。比如3 14 15 6 5，最终输出为3 20 18 9 8
public static void Main(string[] args) { string line; while ((line = System.Console.ReadLine()) != null) { // 注意 while 处理多个 case string[] tokens = line.Split(' '); if (tokens.Length != 0) { if (tokens.Length == 1) Console.WriteLine(tokens[0]); else { int[] inputArr = tokens.AsEnumerable().Select(o =&gt; Convert.ToInt32(o)).ToArray&lt;int&gt;(); int[] resArr = GetTotalPrice(inputArr); Console.WriteLine(string.Join(" ", resArr)); } } } Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0eabdc772799a7999410b4fea9c421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2fc542a07103444e4da240c2b59373/" rel="bookmark">
			Postman自定义函数：扩展测试脚本功能的秘籍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman自定义函数：扩展测试脚本功能的秘籍 在API测试过程中，Postman的测试脚本功能非常强大，但有时你可能需要执行一些特定的操作或计算，这些操作或计算超出了Postman内置函数的范围。这时，你可以使用Postman的自定义函数功能来扩展测试脚本的能力。本文将详细介绍如何在Postman中创建和使用自定义函数，以及如何通过自定义函数来增强测试脚本的功能。
1. 什么是Postman自定义函数 Postman自定义函数允许你在测试脚本中定义可重用的代码片段。这些函数可以执行复杂的逻辑，进行数据转换，或者调用外部服务。
2. 创建自定义函数 2.1 在脚本编辑器中定义函数 在Postman的测试脚本区域，你可以使用pm.test来定义一个测试用例，使用function关键字来定义一个自定义函数。
// 自定义函数示例：计算两个数的和 function addNumbers(a, b) { return a + b; } // 使用自定义函数 pm.test("Addition Test", function () { var result = addNumbers(5, 3); pm.expect(result).to.equal(8); }); 2.2 使用模块化脚本 Postman允许你将自定义函数保存在单独的脚本文件中，然后在多个请求中重用这些函数。
// 在一个单独的脚本文件中定义函数（例如：utils.js） module.exports = { addNumbers: function(a, b) { return a + b; } }; 然后在测试脚本中引用这个模块：
// 在测试脚本中引用自定义函数模块 const utils = require('utils.js'); pm.test("Addition Test", function () { var result = utils.addNumbers(5, 3); pm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2fc542a07103444e4da240c2b59373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1c8be3b6522f0be4cc977052ee3d85/" rel="bookmark">
			醒醒，别睡了...讲《数据分析pandas库》了—/—＜6＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、
1、长宽格式转换 基于多重索引，Pandas 可以很容易地完成长型、宽型数据格式的相互转换。 1.1 转换为最简格式 stack（）其使用法如下：
stack函数用于将DataFrame中的列转换为行，即将宽格式数据转换为长格式数据。
df.stack( level = -1 :需要处理的索引级别，默认为全部，int/string/list dropna = True :是否删除为缺失值的行 )#转换后的结果可能为 Series 例如下列代码
import pandas as pd # 创建DataFrame data = { 'A': [1, 2, 3], 'B': [4, 5, 6], 'C': [7, 8, 9] } df = pd.DataFrame(data) # 将列转换为行 stacked = df.stack() print(stacked) 其打印结果为： 即stack函数将原本的DataFrame转换为了一个Series对象，每个元素的索引由原先的行索引和列索引组成。 1.2 长宽型格式的自由互转 df.unstack( level = -1 :需要处理的索引级别，默认为全部，int/string/list fill_value :用于填充缺失值的数值 ) 例如下列代码演示：
import pandas as pd # 创建堆叠的数据 data = { ('A', 'x'): [1, 2, 3], ('A', 'y'): [4, 5, 6], ('B', 'x'): [7, 8, 9], ('B', 'y'): [10, 11, 12] } stacked = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1c8be3b6522f0be4cc977052ee3d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d1e6ab3685f5e0004489940d8053c14/" rel="bookmark">
			Postman中的代理艺术：配置与使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman中的代理艺术：配置与使用指南 在API开发和测试过程中，代理服务器常用于捕获、检查、修改请求和响应。Postman作为一个流行的API开发工具，内置了代理服务器功能，使得测试人员可以方便地查看和修改通过代理的流量。本文将详细介绍如何在Postman中配置和使用代理服务器。
代理服务器的作用 在Postman中使用代理服务器可以：
捕获流量：查看和分析所有通过代理的请求和响应。修改请求：在请求发送到服务器之前修改请求头或请求体。修改响应：在响应返回给客户端之前修改响应头或响应体。测试环境：模拟不同的网络环境和服务器行为。 在Postman中配置代理服务器 1. 设置Postman代理 在Postman中，可以通过以下步骤设置代理服务器：
打开Postman。点击左下角的“Settings”齿轮图标。在弹出的设置菜单中选择“Proxy”。 2. 配置代理详细信息 在“Proxy”设置页面，输入代理服务器的详细信息：
Proxy Server：输入代理服务器的地址。Port：输入代理服务器的端口号。Bypass proxy for：设置代理服务器的绕过规则。 // 示例：配置Postman代理 Proxy Server: 192.168.1.100 Port: 8080 Bypass proxy for: localhost, 127.0.0.1, example.com 3. 应用和测试代理设置 配置完成后，点击“Apply”按钮保存设置，并在Postman中发送请求以测试代理是否正常工作。
使用Postman代理服务器捕获流量 1. 发送请求 在配置好代理服务器后，发送请求将自动通过代理服务器。可以在Postman的请求详情中查看经过代理的请求和响应。
2. 查看代理历史 Postman提供了一个“History”页面，可以查看所有通过代理的请求历史。
// 示例：在History页面查看代理请求 // 点击Postman顶部的“History”选项卡 3. 使用拦截器 Postman的拦截器功能允许你在请求发送前或响应返回后修改它们。
// 示例：使用Pre-request Script拦截并修改请求头 pm.request.headers.add({ key: 'X-Custom-Header', value: 'Custom Value' }); 4. 模拟网络条件 Postman允许你模拟不同的网络条件，如延迟、带宽限制等。
// 示例：模拟网络延迟 // 在Postman的“Settings”菜单中选择“Throttling” // 配置网络延迟和带宽限制 结论 在Postman中配置和使用代理服务器是API测试的重要环节。通过本文的详细介绍和示例，读者应该能够理解并掌握在Postman中配置代理服务器的方法，以及如何使用代理服务器捕获和修改流量。
请注意，实际应用中可能需要根据具体的测试需求和网络环境进行调整和优化。正确使用代理服务器不仅可以提高API测试的效率和准确性，还可以帮助测试人员更好地理解和控制API的行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61279fd6b6d4020875d1a58c4a9e881b/" rel="bookmark">
			Window 下Mamba 环境安装踩坑问题汇总及解决方法 （无需绕过selective_scan_cuda）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航 Mamba 及 Vim 安装问题参看本人之前博客：Mamba 环境安装踩坑问题汇总及解决方法Windows 下 Vim 安装问题参看本人之前博客：Window 下 Vim 环境安装踩坑问题汇总及解决方法Linux 下Vmamba 安装教程参看本人之前博客：Vmamba 安装教程（无需更改base环境中的cuda版本）Windows 下 VMamba的安装参看本人之前博客：Windows 下 VMamba 安装教程（无需更改base环境中的cuda版本且可加速） 目录 导航背景Windows 下环境准备Windows 下 `mamba-ssm` 的编译Windows 下 `mamba_ssm` 的编译出现的问题及解决（20240714）1. 基本报错信息2. "M_LOG2E" is undefined3. error C2975: “kIsVariableC_”4. error C2975: “kNRows_” 20240724 更新5. ImportError: DLL load failed 背景 Mamba 官方代码链接为：https://github.com/state-spaces/mamba，在原来博客 “Mamba 环境安装踩坑问题汇总及解决方法” 基础上，不绕过selective_scan_cuda，进行 Mamba 环境安装，这样可以获得和 Linux 一样的速度1。
（安装问题 / 资源自取 / 论文合作想法请+vx：931744281）
Windows 下环境准备 前期环境准备，同原来博客 “Mamba 环境安装踩坑问题汇总及解决方法” ，具体为： conda create -n mamba python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61279fd6b6d4020875d1a58c4a9e881b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/101/">«</a>
	<span class="pagination__item pagination__item--current">102/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/103/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>