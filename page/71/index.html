<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0f742df88f23a0ac79f4b2f55e9a0a/" rel="bookmark">
			学习日志8.7--Security Zone防火墙安全区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全区域实验拓扑开始之前先通过一台主机和防火墙相连，设置主机的IP地址和网关，开启防火墙设置防火墙接口g1/0/1的IP地址为192.168.1.254，将防火墙设置为主机的网关，尝试能不能用主机ping通防火墙。尝试之后，发现失败，不能正常通信。学习之后了解到防火墙的安全区域，才知道不能ping通。
防火墙通过设置不同的安全区域对来自不同的网络流量加以区分，用来表达所连接的网络的安全程度。防火墙会通过将接口划分到一个划定的安全区域，表示这个接口所连接的网络属于一个安全区域。而这个接口本身处于一个Local的安全区域，其所连接的网络又表示一个安全区域。
例如，防火墙将接口4划分到安全区域C之后，表示的是接口4所连接的网络属于安全区域C，而接口4并不属于安全区域C。
防火墙默认的安全区域：Trust（信任区）比如内网公司的内部网络、Untrust（非信任区）比如互联网Internet外网容易受到攻击流量、DMZ（Demilitarized Zone）介于安全与非安全的一种区域比如服务器，既服务内网又服务外网，当被外网攻击的时候服务器容易变成肉鸡攻击内网，介于安全与非安全的区域。
注意，防火墙自己的接口也有安全区域，叫做Local，意味着防火墙的接口是属于Local的安全区域。如果防火墙的接口需要使用，就必须将这个接口划分到安全区域，才能使用，可以理解为划分到安全区域就是对这个接口进行管控，对这个接口通过的流量进行管控，只用防火墙的接口进行管控之后才能被使用。
在刚刚的试验中，因为只是对接口进行IP地址的配置，没有将接口划分进安全区域，所以不能使用，主机也就无法ping通防火墙。
在防火墙中通过命令来查看防火墙的安全区域的配置
命令：&lt;FW01&gt;dis current-configuration，查看当前配置有四个安全区域，分别是：Local安全程度是100、Trust安全程度85、Untrust安全程度5、DMZ安全程度50。可以看到在默认情况下g0/0/0口已经默认属于Trust区域，所以在防火墙上g0/0/0可以不用给g0/0/0划分安全区域，可以直接使用。
那将一个接口划分到安全区域，只要进入这个安全区域，然后添加接口就可以。
命令：[FW01]firewall zone trust，在系统视图下进入安全区域
命令：[FW01-zone-trust]add interface GigabitEthernet 1/0/1，在这个安全区域内添加接口
然后查看配置信息，g1/0/1接口已经添加进Trust安全区域。
现在接口已经划分了安全区域，试验测试一下主机能不能ping通防火墙发现主机还是不能和防火墙连接通信。
发现这个主机所在的网络是Trust的区域，而这个接口g1/0/1是属于Local的区域，在主机通信的时候，相当于从Trust的区域去访问Local的区域。但是每个Local的接口自身是包含一个访问控制安全策略，包括http、https、ping、ssh、snmp、telnet等权限的限制，只有开启这些权限接口才能为这些服务
命令：[FW01-GigabitEthernet1/0/1]service-manage all permit，打开接口g1/0/1的服务权限查看配置情况就已经打开了接口的服务权限。
开启接口下的服务权限之后，再用主机去ping防火墙，通信成功。
接口的服务权限是拦截两个安全区域之间流量来使用的。
注意系统的默认安全区域的优先级（安全程度）是不能更改的
命令：[FW01-zone-trust]set priority 80，设置优先级，后面加数字
提示错误，不能修改（modify）系统安全区域的优先级。
防火墙通过受信任级别来控制他的安全程度，收信任级别越高，其安全程度越高。
防火墙支持自定义安全区域。
命令：[FW01]firewall zone name test1，在系统视图下自定义安全区域后面跟上安全区域的名字test1
查看一下配置，在每个安全区域都有一个id，这个id（4-9）可以自己配置，
命令：[FW01]firewall zone name test2 id 5，创建防火墙区域名字是test2配置的id是5
查看配置。
然后对每一个创建的安全区域都要设置一个安全优先级
命令：[FW01-zone-test1]set priority 15，在之前创建的test1下设置优先级15查看配置情况。
设置好优先级之后，给定义好的安全区域添加接口
注意，一个接口只能设置在一个安全区域内。
命令：[FW01-zone-test1]add interface GigabitEthernet 1/0/1，这里是给自定义的安全区域添加接口为g1/0/1，但是在默认的Trust安全区域内已经添加了g1/0/1，意味着一个接口只能划分在一个安全区域。
这个时候就要undo掉之前设置的接口
命令：[FW01-zone-trust]undo add interface GigabitEthernet 1/0/1，在Trust安全区域下undo掉添加的接口然后查看配置信息，已经取消掉，g1/0/1在Trust区域上
然后在把G1/0/1接口添加到test1上。
命令：[FW01]firewall zone test1，进入到test1安全区域
命令：[FW01-zone-test1]add interface GigabitEthernet 1/0/1，将g1/0/1接口划分到test1查看配置信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c0f742df88f23a0ac79f4b2f55e9a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e011470c22a7d3e98df0117cedcea932/" rel="bookmark">
			MySQL —— 约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL —— 约束 引言not nulluniqueprimary key —— 主键auto_increment复合主键 foreign key —— 外键插入数据删除主表的数据 default 引言 在设计表的时候，有些列是必填项（如果用户不填，那这个数据就没有必要存进数据库），可能表的第一列就是编号需要能自动帮我们排序（这样可以减少用户的填写负担，也减少我们的工作量），又或者我们需要有些数据是不能重复填写的（例如身份证号，每一个人都是独一无二的）等等… 这些需求其实都可以实现，现在我们来学习数据库是如何实现约束的。
not null 表示某一列是不能存储 null 值的，也就是这一列是必填项：
格式：在你定义表的时候，在需要不为空的列旁边加上 not null 即可
我们查看表结构发现 Null 那一列的 id 对应的一行现实 No ，说明定义成功，现在我们插入一个 id 为 空的数据实验一下：
会发现不允许你插入 id 为空的数据。
unique 保证某列的每一行都有一个唯一值，即不可以在某列上出现重复的数据。
语法格式：在你定义表的时候，在需要的列旁边加上 unique 即可
我们来查看表结构：
我们发现 id 那一行的 Key 值被置为了 UNI ，说明 id 是唯一值，如果插入id 相同的数据，数据库会报错：
null 是可以重复的，不受 unique 约束
primary key —— 主键 primary key（也被我们称为主键） 是 not null 和 unique 的结合（即主键约束的列即是非空的也是唯一的），能确保某列(或者两列及以上的列的组合) 有唯一的标识。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e011470c22a7d3e98df0117cedcea932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ff93ac7acb621b2c1c3e7ce76c6e07/" rel="bookmark">
			Maven 核心配置有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Maven 核心配置 项目依赖管理
依赖传播：自动将所有依赖节点加入到项目classpath。依赖优先原则：解决依赖冲突，优先选择最短路径的版本。 依赖特性
可选依赖：通过&lt;optional&gt;true&lt;/optional&gt;标记，表示依赖不是必须的。排除依赖：使用&lt;exclusions&gt;标签排除间接依赖。 依赖范围
compile：默认范围，编译和打包时都依赖。provided：编译时依赖，打包时不包含。runtime：运行时依赖，编译时不依赖，打包时包含。test：仅用于测试，编译和运行测试用例时依赖，不打包。system：依赖于系统路径中的jar，不包含在最终打包中。 手动加入本地仓库
使用mvn install:install-file命令将本地jar包安装到Maven仓库。 项目聚合与继承
聚合：通过父工程统一构建多个模块。继承：子工程继承父工程的配置，避免重复。 依赖管理
在父工程中使用&lt;dependencyManagement&gt;声明依赖，子工程中引入。 项目属性
使用&lt;properties&gt;配置属性参数，简化配置。 构建配置
资源配置：定义资源文件的位置和过滤规则。构建资源：配置构建过程中的资源文件和目标路径。 Maven 常用属性 ${basedir}：项目根目录。${version}：项目版本。${project.build.directory}：构建目录，默认为target。${project.build.sourceEncoding}：源码编码格式。${project.build.sourceDirectory}：源码路径。${project.build.finalName}：输出文件名称。${project.build.outputDirectory}：构建输出目录，默认为target/classes。 Maven 插件使用示例 maven-dependency-plugin：用于将system范围的依赖复制到指定目录。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d60f0bb6dfb71671551b55c59b95479/" rel="bookmark">
			AI绘画Stable Diffusion（SD）常用插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的AI绘画Stable Diffusion（SD）软件插件有很多，可以帮助用户提升创作效率和作品质量。以下是一些常见的插件和扩展：
1. **ControlNet**：通过提供额外的控制机制，使用户能够更精确地控制生成图像的特定部分。
2. **Image2Image**：将现有图像作为输入，通过调整参数生成新的图像。
3. **Textual Inversion**：允许用户通过输入文本描述生成高质量的图像。
4. **LORA (Low-Rank Adaptation)**：一种轻量级的模型适应技术，可以在保持原始模型质量的同时，快速适应新的任务或数据。
5. **Inpainting**：用于修复或修改图像的特定区域，通常用于修复图像中的缺陷或添加新元素。
6. **Outpainting**：扩展图像的边界，生成超出原始图像范围的新内容。
7. **Face Restoration**：专门修复和增强图像中人脸部分的插件。
8. **Super Resolution**：提高图像分辨率，使其更加清晰和详细。
9. **Prompt Engineering**：帮助用户优化输入提示词，使生成的图像更符合预期。
10. **Style Transfer**：将一种图像的风格应用到另一张图像上，实现艺术风格迁移。
这些插件可以单独使用，也可以组合使用，以满足不同的创作需求。如果你对某个插件有特别的需求或疑问，欢迎进一步详细咨询，我可以提供更具体的指导和建议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9a8f9e6ee60d953e737cf4c1571a47a/" rel="bookmark">
			【数据结构】链表从实现到应用，保姆级攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构——链表深度探索】从实现到应用，保姆级攻略 🍁1. 链表的介绍🍁2. 链表的实现🍁2.1 单向链表🍁2.1.1 size()🍁2.1.2 display()🍁2.1.3 contains(int key)🍁2.1.4 addFirst(int key)，addLast(int key)，addIndex(int key, int index)🍁2.1.5 remove(int key)，removeAllKey(int key)🍁2.1.6 clear() 🍁2.2 双向链表🍁2.2.1 addFirst(int key)🍁2.2.2 addLast(int key)🍁2.2.3 addIndex(int key, int index)🍁2.2.4 remove(int key)和removeAllKey(int key)🍁2.2.5 clear() 🍁3. Java中LinkedList的使用🍁3.1 LinkedList的创建和使用🍁3.2 LinkedList的遍历 🍁4. ArrayList和LinkedList的区别 🚀欢迎互三👉： 2的n次方_💎💎
🚀所属专栏：数据结构与算法学习💎💎
🍁1. 链表的介绍 链表是数据结构中一种非常重要的基础结构，它不同于数组，链表中的元素在物理存储上并不连续，而是通过指针（或引用）连接在一起。在Java中，链表的应用非常广泛，尤其是在需要动态添加或删除元素的场景中。
🍁2. 链表的实现 🍁2.1 单向链表 单链表中的每个元素都称为节点（Node），每个节点包含两个部分：一部分存储数据（value），另一部分存储指向列表中下一个节点的引用（next）。最后一个节点的next引用为null，表示链表的结束。
所以采用内部类的形式进行创建：
public class MySingleList { static class ListNode { public int value; public ListNode next; public ListNode(int value) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9a8f9e6ee60d953e737cf4c1571a47a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e154cbb315c57abc4d0e833873d609c9/" rel="bookmark">
			HBase集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBase集群部署安装 在安装HBase之前，一定需要考虑HBase=和Hadoop之间版本的兼容性。由于之前已经安装的是Hadoop3.1.3版本，进入HBase官网Apache HBase ™ Reference Guide查看兼容性，具体兼容表格如下图所示：
从上图可得知，Hadoop3.1.1+版本可搭配HBase2.1.x版本与HBase2.2.x版本，教程挑选的HBase版本为HBase2.2.2，具体安装步骤如下。
HBase中有两个角色，一个是Hmaster，是Hbase集群的管理节点，HRegionServer，主要负责存储数据节点，本次案例的集群配置如下表所示。
集群节点HMasterHRegionServermaster√√slaves1√slaves2√ Hadoop部署 HBase将数据存储在HDFS上，因此部署HBase前需要把Hadoop部署上，具体部署操作参考Hadoop部署文档。Hadoop完全分布式部署
Zookeeper集群部署 Hbase需要Zookeeper工具存储元数据信息，因此部署HBase前，需要把ZK集群部署上，具体部署操作参考Zookeeper部署文档。Zookeeper集群安装部署
HBase集群部署 访问HBase官网下载安装文件hbase-2.2.2-bin.tar.gz文件：https://archive.apache.org/dist/hbase/2.2.2/。
使用XFTP工具上传HBase安装包到master节点的/root/module目录下。
解压Hbase安装包到/usr/local目录下，并修改安装目录名称
cd /root/module tar -zxvf hbase-2.2.2-bin.tar.gz -C /usr/local/ sudo mv /usr/local/hbase-2.2.2 /usr/local/hbase 配置环境变量，将Hbase路径配置到/etc/profile文件中。
vim /etc/profile 在/etc/profile尾部添加HBASE_HOME变量，并把HBase的bin目录追加到PATH中，如下图所示。
export HBASE_HOME=/usr/local/hbase export PATH=$PATH:$HBASE_HOME/bin 重新加载环境变量
source /etc/profile 设置配置文件
Hbase所有的配置文件，在Hbase的conf目录下。
cd /usr/local/hbase/conf ① 配置hbase-site.xml文件，编辑hbase-site.xml文件，在&lt;configuration&gt;标签之间添加以下内容
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/hbase/datta/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;zookeeper.znode.parent&lt;/name&gt; &lt;value&gt;/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/opt/data/zookeeper/zkdata&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;master:2181,slaves1:2181,slaves2:2181&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e154cbb315c57abc4d0e833873d609c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6050dc2efc561d134648bfadd2d88834/" rel="bookmark">
			探索灵办AI：智能办公的好帮手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 随着AI工具的增多，选择合适的AI助手变得尤为重要。ChatGPT的订阅费用高且功能单一，很多小伙伴开始寻找更具性价比和多功能的替代品。灵办AI以其便捷、高效、多功能的特点，成为许多朋友的新宠。
灵办AI助手是一款多功能的全能AI助手，集成了GPT对话、AI解读文件、AI写作、网页翻译、AI搜索等多种功能。它能实时联网，提供代码生成纠错和表格生成等高效办公需求。只需点击浏览器右侧的灵办图标，就能唤醒插件助手，并通过调整侧边栏宽度来个性化设置。
如何使用 可以选择插件版、网页版、客户端、小程序版
这里我推荐大家使用插件版的，在浏览网页时更方便快捷。插件版使用方法也很简单这里以谷歌插件安装使用为例
灵办AI官网上可以看到免费添加到Chrome的按钮
点击“添加到Chrome”按钮并将其固定到工具栏。
最后在网页右侧点击灵办AI小图标注册并登录即可使用
主要功能与特点 1.AI对话 灵办AI支持实时联网，可以解答各种领域的问题。无论是数学运算、代码修正与生成，还是表格生成和生活小妙招，灵办都能为你提供答案。就像有个全能的助手随时待命。这个功能的核心在于它强大的语言模型，能理解和处理各种复杂问题，比如前段时间很火的“9.11和9.8哪个大？”这样简单的问题各大语言模型都翻车了。
无论是进行精确的计算，还是帮你理解比较难懂的概念，灵办AI都能提供清晰而准确的回答。它不仅是一个工具，更像是一个随时待命的小助手，帮助你解决工作和生活中的各种挑战。
2.智能翻译 灵办AI的翻译功能堪称业界领先，能够满足各种翻译需求，让语言障碍不再是问题。无论你是在浏览外文网站、处理PDF文档，还是阅读复杂的学术论文，灵办AI都能提供高质量的翻译服务。它不仅支持网页翻译，还能对PDF文件、论文以及普通文本进行翻译，覆盖了几乎所有常见的文档格式。
我们只需选中需要翻译的文字，点击灵办AI小图标，即可看到翻译功能按钮
也可点击右侧一键翻译全文按钮
自己使用后我发现灵办AI的翻译不仅准确，还能保持文档的原有格式和排版，让翻译后的文档看起来像是原本就是用目标语言写的。这种高效、精准的翻译能力，不仅节省了大量的时间，还提高了工作和学习的效率。无论是日常使用还是专业需求，灵办AI的翻译功能都能带来极大的便利。
3.AI搜索 当我们在使用搜索引擎检索内容时，在页面右侧可以看到灵办AI的小图标，可以帮助你检索全网的内容，总结优质内容并一键生成回答。灵办AI提供无广告的搜索体验，再也不用为搜索结果中的广告烦恼了。
4.AI阅读 灵办AI能够对网页、PDF、WORD、PPT和TXT等多种文件进行快速总结和提炼要点。它高效的摘要功能让你迅速掌握文件的核心内容，大大提升了阅读效率。
在页面右侧我们可以看到有个阅读的小图标，支持阅读当前网页、指定链接或者本地文档
之前可能需要花5-10分钟的时间才能看完的的一篇文章，让灵办AI几秒就帮你把大纲总结出来，几十秒就能了解全文了。
总结 灵办AI 无疑是一款多功能且便捷的工具，为各种工作和学习需求提供了极大的便利。无论你是需要实时解答问题、进行高效的翻译、执行智能搜索，还是快速阅读和生成高质量文案，灵办AI都能全面满足。它的强大功能涵盖了从代码生成到文件解析，从网页翻译到文章撰写，几乎可以解决现代工作和学习中的所有挑战。
通过灵办AI，你不仅可以简化复杂的任务，还能显著提升工作和学习的效率。它真正做到了将多个功能集成在一个平台上，为用户提供了极大的便利。试试灵办AI，你将会发现它不仅是提升工作效率的得力助手，更是你学习过程中不可或缺的好伙伴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af48181e97995a1c93f21bc8ac5f8291/" rel="bookmark">
			【C&#43;&#43;】string类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀个人主页：奋斗的小羊 🚀所属专栏：C++ 很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~ 目录 前言💥1、标准库中的string类💥1.1string类的常用接口💥string类对象常见构造💥string类对象容量操作💥string类对象修改操作💥string类非成员函数 💥1.2auto和范围for💥1.2.1遍历字符串的三种方式💥下标 + [ ] 重载💥迭代器（通用）💥范围for（通用） 前言 C语言中，字符串是以’\0’结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太符合OOP（分装、继承、多态）的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。
在常规工作中，为了简单、方便、快捷，基本都使用string类，很少有人去使用C库中的字符串操作函数。
💥1、标准库中的string类 💥1.1string类的常用接口 💥string类对象常见构造 函数名称功能string()构造空的string类对象，即空字符串string(const char* s)用常量来构造string类对象string(size_t n, char c)string类对象中包含n个字符cstring(const string&amp; s)拷贝构造函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string s1;//构造空的string类对象 string s2("123456");//用常量构造string类对象 string s3(s2);//拷贝构造 return 0; } operator[]：返回字符串中位置 pos 的字符引用，像数组一样修改某个位置的字符： class string { public: char&amp; operator[](size_t i) { assert(i &lt; _size); return _str[i]; } private: char* _str; size_t _size; size_t capactiy; }; 💥string类对象容量操作 函数名称功能size返回字符串有效字符长度length返回字符串有效字符长度resize将有效字符的个数改成n个，多出的空间用字符c填充capacity返回空间总大小reserve提前开空间，避免扩容，为字符串预留空间clear清空有效字符，容量不变empty检测字符串释放为空串，是返回true，否则返回false string类对象的空间不包含字符'/0'void reserve (size_t n = 0)：请求将字符串容量调整为计划的大小更改，长度不超过 n 个字符。如果 n 大于当前字符串容量，则该函数会导致容器将其容量增加到 n 个字符（或更大）。此函数对字符串长度没有影响，并且不能更改其内容。在VS中大了扩容，小了不变size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()clear()只是将string中有效字符清空，不改变底层空间大小resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时，resize(n)用0来填充多出的元素空resize(size_t n, charc)用字符c来填充多出的元素空间。注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变 💥string类对象修改操作 函数功能push_back在字符串后尾插入字符cappend在字符串后追加一个字符串operator+=在字符串后追加字符串c_str返回c格式find + npos从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置rfind从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置substr在str中从pos位置开始，截取n个字符，然后将其返回 在string尾部追加字符时，s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af48181e97995a1c93f21bc8ac5f8291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da109add6f9b94f8d5a063ecc4336967/" rel="bookmark">
			【MYSQL】基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📚博客主页：Zhui_Yi_
🔍：上期回顾：图（下）
❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️
🎇追当今朝天骄，忆顾往昔豪杰。
文章目录 前言一、错误提示二、基础操作1.“数据库”操作I 查看数据库II 创建数据库注意事项if not exists；collate III 选中数据库IV 删除数据库 三、数据类型1.数值类型2. 字符串类型3. 日期类型注意 四、数据库表操作前提1. 查看当前数据库中，有哪些表2. 创建表3. 查看指定表的详细情况4.删除表 前言 错误提示。
数据库的操作：创建数据库、删除数据库
常用数据类型
表的操作：创建表、删除表
一、错误提示 在我们安装完MYSQL后，可能会出现两种情况造成MYSQL闪退。
1.密码错误
2.数据库没有正常启动
但是由于闪退过快，我们不知道到底是那种错误。
我们就可以这样做。
首先，我们要找到MYSQL的安装位置。
右键
点击打开文件位置。
出现下面这种情况。
点击上面搜索栏，输入cmd。
回车。
将任意一个拖进cmd
回车。
这时，我们先输入正确的密码。出现：
无法连接至MYSQL，这就是MYSQL没有正常启动。
这时我们要启动任务管理器。选中标红框的。
找到MYSQL
我们可以看到已停止。我们右键选择开始。
这时，我们再启动一下。
就成功了。
二、基础操作 1.“数据库”操作 此处谈到的数据库，其实指的是数据库软件上，组织数据的“数据集合”。
mysql这样的数据库，称为“关系型数据库”，通过“表”的方式来组织数据的。
I 查看数据库 show databases; 输入上述代码，就会出现下面的东西，有4列。
II 创建数据库 create database 数据库名; 我们此时创建一个名为text的数据库；
我们此时可以再进行查看数据库。
我们可以看到，text确实被创建了。
注意事项 创建数据库的时候，数据库的名字不能和SQL中的关键字重复。
创建数据库的名字也不能和已有的数据库名字重复。
数据库中是不区分大小写的。
但是，order是关键字，但也需要使用，有没有什么方法？
当然有，最简单的方式是换个，也可以给数据库名叫上一个反引号**`**，在键盘esc的下边，tab的上边。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da109add6f9b94f8d5a063ecc4336967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c313b8620360f5d4046eb54c3ff5e068/" rel="bookmark">
			数据结构——排序（1）：插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、排序的概念
二、排列的运用
三、常见的排序算法
四、插入排序
1.直接插入排序
（1）思路
（2）过程图示
（3）代码实现
(4)代码解释
（5）特性
2.希尔排序
（1）思路
（2）过程图示
（3）代码实现
(4)代码解释
（5）特性 （6）时间复杂度
五、写在最后
一、排序的概念 排序就是使一串记录按照其中的某个或某些关键字的大小，递增或递减排列起来的操作。
二、排列的运用 （1）购物筛选排序
（2）院校排名排序
三、常见的排序算法 四、插入排序 插入排序的基本思想是将待排序的记录按其关键码值的大小逐个插入到一个已经排好序的一个有序序列列中，直到所有记录插入完为止，得到一个新的有序序列。
联想我们在实际中玩的扑克牌，就用到了插入排序的思想~
1.直接插入排序 （1）思路 插入到第i个元素时，其前面的元素已经排好序了，此时将第i个元素的大小与第i-1、i-2……个元素的大小进行比较，找到合适的位置，将原来位置上的元素后移，并将第i个元素插入。
（2）过程图示 我们以数组{2，1，3，5，4，8}为例：
①首先end指的是已排好序的最后一个元素；tmp为end之后的元素，即要比较插入的元素。
如图：tmp比end小，那么应该将tmp往前遍历。让end+1位置的数据为end位置的数据，end往前遍历，此时end&lt;0无法再遍历，则跳出循环。
②③继续遍历：随后的两次中tmp均大于end对应的数据，直接进行下一此遍历。
④此时tmp小于end对应的位置，令end+1位置的数据为end位置的数据，end后移继续遍历。此时tmp大于end对应位置的数据，那么令此时end+1位置的数据为tmp。
⑤继续遍历，此时tmp大于end，直接进行下一次遍历。
⑥继续遍历我们发现end指向最后一个数据时，tmp越界了，说明该情况不合理。我们也可以知道在写代码时，end的约束条件应该是&lt;n-1。
至此遍历完成，所有数据也排为了升序。
（3）代码实现 void InsertSort(int* arr, int n) { for(int i = 0 ; i &lt; n - 1; i ++) { int end = i; int tmp = arr[end + 1]; while(end &gt;= 0) { if(tmp &lt; arr[end]) { arr[end+1] = arr[end]; end--; } else { break; } } arr[end+1] = tmp; } } (4)代码解释 ①首先最外层的for循环，用i遍历下标为0 ~ n-2的数据，即最后一个数据没有被遍历（前面有解释，end = i ，且end不能为最后一个数据，因为tmp会越界）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c313b8620360f5d4046eb54c3ff5e068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3449eccc178668cea54086f4bbd6b7ca/" rel="bookmark">
			【数据结构】二叉搜索树（Java &#43; 链表实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi~！这里是奋斗的明志，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~
🌱🌱个人主页：奋斗的明志
🌱🌱所属专栏：数据结构、LeetCode专栏
📚本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为展示我的学习过程及理解。文笔、排版拙劣，望见谅。
这里写目录标题 前言一、二叉搜索树1.概念2.search 搜索或查找3.insert 插入4.删除（难点）4.1 根结点的左子树为空4.2 根结点的右子树为空4.3 根结点的左右子树都不为空4.4 完整代码 5.性能分析 二、1.7 和 java 类集的关系三、搜索1.概念及场景2.模型 前言 Map接口是独立的
实现Iterable接口的集合都是可以使用 for - Each 语句进行打印的
搜索性能会非常高
一、二叉搜索树 1.概念 二叉搜索树又称为二叉排序树，它或者是一棵空树，或者是具以下性质的二叉树：
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
它的左右子树也分别为二叉搜索树
如果中序遍历这棵二叉搜索树，会发现遍历的结果是有序的
接下来就模拟实现一下二叉搜索树
首先，和之前二叉树的实现一样，都是一个节点包括值和指向左右节点的引用（利用孩子兄弟表示法）
public class BinarySearchTree { //首先这棵树是由若干个结点组成的 static class TreeNode { public int val; public TreeNode left; public TreeNode right; //提供构造方法进行初始化 public TreeNode(int val) { this.val = val; } } //根节点 public TreeNode root; } 2.search 搜索或查找 若根节点不为空：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3449eccc178668cea54086f4bbd6b7ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dfb69fa406ae4152af242002ceae9c7/" rel="bookmark">
			MySQL事务隔离级别、InnoDB使用MVCC&#43;各种锁实现了RC和RR事务隔离级别、具体案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务隔离级别 脏读：一个事务读取到另一个未提交事务的更改。不可重复读：一个事务在两次读取同一数据时，发现数据被另一个已提交事务修改了。幻读：一个事务在读取过程中，因其他事务的插入而导致返回的行数不一致，查询到了奇怪的结果 SQL标准定义了如下四个隔离级别，注意是SQL标准，不是MYSQL标准：
READ-UNCOMMITTED(读取 未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。几乎没人用，太不安全了。READ-COMMITTED(RC，读取 已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。经常用，可以确保并发的性能。REPEATABLE-READ(RR，可重复读) ：在事务开始（start TRANSACTION，关闭自动提交）和结束之间（commit，rollback之前），对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。也经常被用，可以确保安全。
虽然标准SQL隔离级别定义是说RR下幻读仍然可能发生，但是在MYSQL的InnoDB下实现的RR隔离级别是解决了幻读问题的发生的，先有个印象，我一开始看也非常懵逼。SERIALIZABLE(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。几乎没人用，事务并发性能太差了。 隔离级别脏读不可重复读幻读READ-UNCOMMITTED,读未提交√√√READ-COMMITTED,读已提交×√√REPEATABLE-READ,可重复读××√SERIALIZABLE,可串行化××× InnoDB使用MVCC+各种锁实现了RC和RR事务隔离级别 重点当然是讲RR的实现，因为他是MySQL默认存储引擎InnoDB的默认隔离级别。下面先说明实现存在的问题，再说解决方法。
下面无特别说明都用RR事务隔离级别做例子。
一致性非锁定读 对于 一致性非锁定读（Consistent Nonlocking Reads）open in new window的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。
在InnoDB引擎中，多版本控制(multi versioning)就是对上面描述的非锁定读的实现。
如果读取的行正被其他事务执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)。
在 Repeatable Read 和 Read Committed 两个隔离级别下，如果是执行普通的 select 语句（不包括 select ... lock in share mode ,select ... for update）则会使用 一致性非锁定读（MVCC，多版本并发控制 (Multi-Version Concurrency Control)）。并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读
一致性非锁定读 代码举例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dfb69fa406ae4152af242002ceae9c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6965bc438c2e664d09fa83b378eb1cc0/" rel="bookmark">
			什么是实时数据仓库？它有哪些不可替代之处？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【实时数据仓库】可以分开来理解：
✅【实时数据】：即能够快速处理数据，且几乎无延迟的提供最新的数据的能力。
✅【仓库管理】：可以理解为对仓库的库存控制、对仓库的存储优化以及协调物流。
那么实时数据仓库就是：用于在数据产生的同时进行存储和分析的数据仓库系统。
它不同于传统的离线数据仓库，后者通常依赖于批量数据处理，存在较大的时间延迟。实时数据仓库则能够即时接收、处理和分析连续流入的数据，几乎无延迟地提供最新的业务反馈。目前市面上能有这样功能的系统就是——仓库管理系统（WMS）。
简道云仓库管理系统（WMS）模板，可以直接查看和使用：https://www.jiandaoyun.com
什么是仓库管理系统（WMS）？ 仓库管理系统（WMS）是一种用于优化仓库运营的软件系统，它负责管理库存、跟踪货物位置、指导拣选和包装、处理订单发货以及监控库存水平。仓库管理系统（WMS）通过自动化和智能化流程，提高仓库作业效率，减少错误，增强库存准确性，并促进供应链协同。
与实时数据仓库对应的就是离线数据仓库。先来看看，离线数据仓库在实时性方面存在以下痛点：
【数据时效性不足】：离线数据仓库通常使用离线再导出的方式去获取数据，这样数据时效性只会延长更长时间，无法满足实时数据分析的需求。在快速变化的市场环境中，这种滞后性会导致企业错失商机或无法及时应对风险。
【查询效率低】：如果是使用离线数据仓库执行查询，则会需要较长时间来处理大量数据，不能通过联网进行快速搜查关键词等。这会影响企业决策的及时性和准确性。
【扩展性和灵活性较低】：离线数据仓库底层涉及多个技术栈和系统组件，如HDFS、YARN、Hive等。这些系统的复杂性和相互依赖导致系统不能够根据企业业务需求进行功能的变化。
因此我们说仓库管理系统（WMS）的实时数据是不可替代，可以从以下这些场景中具体体现。
仓库管理系统（WMS）的实时数据场景： 以下是仓库管理系统（WMS）利用实时数据功能在管理仓库时的六种具体场景及其作用：
✅场景一：快速响应客户需求 在一个忙碌的电商平台中，客户需求会源源不断的增加，如果刚好面临着促销活动或节假日的临近，订单量则会激增，仓库需要迅速且准确地处理每一个订单，以满足客户的即时需求，及时更新客户的新订单。
此时，WMS系统能通过实时数据功能，即时捕捉订单信息并自动分配拣选任务，为每个客户打包相对应的产品、这确保了仓库在最短时间内响应客户需求，减少等待时间，提升客户满意度。
✅场景二：实时库存监控 在仓库管理中当中，实时库存监控能够确保库存的数量和状态。企业需要实时了解每种商品的库存数量、存放位置和状态，以便在市场需要产品时，能够快速响应市场需求。
库存管理系统（WMS）能够即时更新库存信息，包括产品的入库、出库、调拨等操作。这使得管理人员能够随时掌握库存的最新状态，有效避免库存短缺或过剩的情况发生。同时，实时库存数据还可以为企业的采购、生产和销售等决策提供有力支持。
✅场景三：拣选路径优化 拣选作业能够有效提高仓库的效率。传统的拣选作业往往存在路径不合理、耗时较长等问题。
仓库管理系统（WMS）通过实时数据功能，能够分析拣选作业的历史数据和当前库存情况，自动规划最优的拣选路径。这不仅可以减少拣选时间和人力成本，还可以提高拣选作业的准确性和效率。
✅场景四：库存预警与补货 库存预警与补货能够防止库存短缺和保障供应链稳定。企业需要设定合理的库存安全库存水平，并在库存低于安全库存时及时进行补货。
而库存管理系统（WMS）通过实时数据功能，能够实时监控库存数量并与设定的安全库存水平进行比较。一旦库存低于安全库存水平，系统将自动触发补货流程，并生成补货订单。这确保了企业能够及时补充库存，避免库存短缺对生产和销售造成的不利影响。
✅场景五：运输与配送跟踪 当仓库进行完出库环节后，运输与配送是仓库管理的最后一环，将会把产品送到客户的手中。企业需要实时了解货物的运输状态和预计到达时间，以便及时与客户沟通并提供优质的服务。
仓库管理系统（WMS）能够集成GPS和物联网等技术手段，实时跟踪货物的运输状态和位置信息，及时在系统内更新物流信息。这能让企业能够随时掌握货物的运输情况，并及时调整运输计划和配送路线。同时，还可以帮助企业预测货物的到达时间，为客户提供更加准确的物流信息和服务。
✅场景六：仓库作业效率分析 企业需要对仓库的各项作业进行定期评估和分析，以发现潜在的问题并进行改进。而事实数据能够评估仓库作业效率。
WMS通过实时数据功能，能够收集和分析仓库作业的各项数据指标，如拣选效率、库存周转率、订单处理时间等。这些数据不仅可以帮助企业了解仓库作业的实际情况和效率水平，还可以为企业的持续改进和优化提供有力支持
✅场景七：提升员工绩效 一线员工是仓库运作的主体。能够协助WMS系统共同管理产品的出入库。而员工的工作效率和积极性也能直接影响仓库的效率和成本。
仓库管理系统（WMS）不仅包含有员工的所有数据，还包含员工每日工作的时长和数量，这样能够计算出员工的工作情况和业绩数据。这些数据包括拣选效率、出错率、工作时间等。管理人员可以根据实时数据评估员工的绩效表现，并给予相应的奖励或培训。
仓库管理系统（WMS）的不可替代性在于： 1.数据分析能力强大： 仓库管理系统（WMS）的数据分析功能之强大，在于对数据不仅仅是数字的堆砌，而是将海量、复杂的仓库运营数据转化为有价值的信息。它能对库存变动、订单处理、作业效率、员工绩效等多个维度进行深入挖掘和分析。这种分析能力，让WMS能够揭示仓库运营中的规律和趋势，为管理层提供做出决策依据。
2.精准管理库存： 仓库管理系统（WMS）能利用手机，通过条形码、RFID等自动识别技术，确保每一件商品从入库到出库的全过程都能被精确追踪。这不仅避免了人工盘点时的错漏，还大幅提升了库存数据的准确性，让企业随时掌握库存状况，减少过剩或短缺风险。
3.优化作业流程： 系统能自动规划最优的拣选路径、分配工作任务，减少员工在仓库内的无效移动，提高作业效率。同时，支持波次拣选、批量处理等高级功能，让仓库作业更加有序、高效。
4.降低运营成本： 系统通过计划和精细化管理，能够有效减少库存积压、降低损耗率，并优化人力资源配置，减少不必要的人工成本。此外，
5.促进数字化转型： 在数字化的时代，企业纷纷引入大量的系统协助管理企业业务。仓库管理系统（WMS）就是企业能够实现仓储管理数字化转型的关键工具。它不仅提升了仓库内部的运营效率，还通过与其他信息系统的集成（如ERP、OA等），推动了企业整体业务流程的自动化、智能化。
以上就是今天分享的内容，主要是介绍仓库管理系统的实时数据功能，以及仓库管理系统对于企业的必要性和不可替代性，在数字化的时代，企业能够利用系统协助管理仓库和员工，那对企业来说是长远的投资和良好的发展。
希望对大家有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9f0f5712ff9a10c0dbc654a8fd67b7/" rel="bookmark">
			物流仓库安全视频智能管理方案：构建全方位、高效能的防护体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景分析 随着物流行业的快速发展和仓储需求的日益增长，仓库安全成为企业运营中不可忽视的重要环节。传统的人工监控方式不仅效率低下，且难以做到全天候、无死角覆盖，给仓库资产和人员安全带来潜在风险。因此，引入仓库安全视频智能管理方案，成为提升仓库安全管理水平、预防安全事故的必然趋势。
二、方案概述 TSINGSEE青犀EasyCVR视频汇聚管理平台+AI智能分析网关V4构建的仓库安全视频AI智能管理方案，通过集成高清视频监控、智能分析算法、云计算与大数据处理技术，实现对仓库区域的全天候、智能化监控与管理。该方案能够自动识别异常行为、预警潜在风险，并快速响应处理，为仓库安全提供强有力的技术支撑。
三、核心功能 1、高清视频监控
采用高清网络摄像机与NVR（网络视频录像机）相结合的方式，覆盖仓库出入口、货架区、装卸区等关键区域，确保图像清晰、细节可见，为事后追溯提供有力证据。
EasyCVR视频汇聚系统采用先进的图像处理技术和传输协议，能够确保高清、稳定的视频传输。系统支持多种品牌、型号的摄像机接入，具备较强的兼容性与灵活性。
1）远程监控与录像回放：支持7/24小时实时高清视频监控，方便管理人员随时随地查看仓库情况；能根据需求对现场监控视频进行录像，并支持存储、回放，可通过调阅视频录像查看现场事发经过，将视频录像作为追溯责任的证据。
2）多画面视频集中观看：能对外分发RTMP、RTSP、HTTP-FLV、WebSocket-FLV、HLS、WebRTC、WS-FMP4、HTTP-FMP4等格式的视频流，支持在多类型的终端设备上观看，能同时播放多路监控视频流，视频画面1、4、9、16个可选，支持自定义视频轮播。
3）视频存储：将视频数据及其他监控数据存储在云端或本地，实现数据的长期保存和查询；还可以支持对象云存储OSS，通过挂载第三方存储服务商的资源，将视频录像存储在OSS服务中，支持回看与下载等操作。
4）视频汇聚管理：智慧安防监控EasyCVR视频管理平台能在复杂的网络环境中，将前端监控设备进行统一集中接入与汇聚管理。
2、AI智能行为分析
利用AI智能分析网关V4的深度学习算法，对视频画面进行实时分析，自动识别入侵者、违规操作（如吸烟、越界、区域入侵等）、人员跌倒等异常行为，并立即触发警报。算法可按需组合、按场景配置，每个摄像头可同时配置3路算法，支持摄像头轮询与算法轮询任务。
1）人脸识别与访问控制：结合人脸识别技术，对进出仓库的人员进行身份验证，严格控制访问权限，防止未经授权人员进入，增强仓库安全性。
2）区域入侵：自动检测划定区域内是否有人员/车辆进入，检测到该行为将立即触发告警并抓拍，可支持选择人员、电动车、自行车、三轮车、汽车、卡车。
3）越界检测：自动检测人员越过划定警戒线（含方向）的行为，检测到则立即触发告警。
4）人员摔倒：自动识别人员的摔倒行为并自动抓拍和上报告警，提醒管理人员及时查看。
5）抽烟检测：自动检测画面内是否有人员抽烟，检测到抽烟行为将立即抓拍并告警。
3、环境监控与消防预警
集成温湿度、烟雾、火灾等环境传感器，实时监测仓库环境状况，一旦发现异常立即报警，预防火灾、水浸等自然灾害的发生。同时，部署AI智能分析网关V4的烟火识别算法，自动检测仓库及周边环境中是否有烟雾、火焰、火点，并及时告警，提高仓库的消防安全性。
1）烟火检测：检测监控场景下是否有烟雾火焰，支持识别红色、橙色和黄色火焰；支持识别白烟、灰白烟、黄烟、彩烟、黑烟、灰黑烟等不规则的烟雾。
2）室内消防逃生通道占用：自动识别常见占用消防通道的物品（纸皮箱、垃圾桶等杂物），判断消防逃生通道是否被占用。
3）消防车通道占用：是否有机动车违规停放在消防车通道上，并发出告警。
4、异常预警与反馈
即时告警：当系统检测到异常行为或事件时，立即触发告警机制，通过声音、弹窗、短信、邮件等多种方式通知管理人员。
5、系统对接与集成
开放接口：提供标准的API接口，支持与其他仓储管理系统、门禁系统、消防系统等进行无缝对接，实现数据共享与业务联动。定制化开发：根据仓库的实际需求，提供定制化开发服务，确保系统能够完全贴合仓库的业务流程与管理需求。 四、结语 仓库安全视频AI智能管理方案是现代仓储管理的必然选择，它不仅能够显著提升仓库的安全性和管理效率，还能为企业的可持续发展奠定坚实基础。随着技术的不断进步和应用的深入，仓库安全智能管理将朝着更加智能化、自动化、精细化的方向发展，为企业创造更大的价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46f28486041a36fa605fffb4e856d1d/" rel="bookmark">
			全方位教程：接入视频美颜SDK与直播美颜插件的完整步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，小编将为您详细介绍如何接入视频美颜SDK与直播美颜插件的完整步骤。
一、准备工作
开发环境的搭建 在开始集成之前，确保您的开发环境已配置完毕。无论是使用iOS、Android，还是Web开发，您都需要准备好对应的开发工具链，如Xcode、Android Studio或者Web开发工具。
SDK与插件的获取 选择合适的视频美颜SDK和直播美颜插件。常见的提供商有腾讯云、阿里云和美图等。根据您的项目需求，下载对应的SDK和插件包，并且查阅相关的集成文档。
创建账号与申请API密钥 大部分美颜SDK服务需要您在其官网注册账号，并申请API密钥。这些密钥用于认证您的应用，确保服务的合法调用。
二、集成视频美颜SDK
导入SDK 将下载的SDK文件导入到您的项目中。如果是iOS开发，通常需要将SDK的静态库或动态库添加到Xcode的项目中，并确保正确配置了库路径。如果是Android开发，通常需要在build.gradle文件中添加相应的依赖项。
初始化SDK 在应用启动时，初始化美颜SDK。以下是一个伪代码示例：
BeautySDK beautySDK = new BeautySDK(); beautySDK.initialize(context, apiKey); 确保在初始化过程中传入正确的API密钥以及相关的配置参数。
集成美颜功能 VideoFrame frame = getCurrentVideoFrame(); VideoFrame beautifiedFrame = beautySDK.applyBeautyEffect(frame); 此步骤将原始视频帧传递给美颜SDK进行处理，然后获取处理后的美颜视频帧。
三、集成直播美颜插件
插件安装 通常，直播美颜插件是以扩展模块的形式提供的。
配置直播参数 在直播应用中，通常需要配置直播的相关参数，如视频分辨率、帧率等。此时，您可以选择性地启用美颜效果。以下是一个简单的配置示例：
{ "resolution": "720p", "frameRate": 30, "enableBeauty": true, "beautyLevel": 5 } 调用插件接口 在实际的直播过程中，您可以通过调用插件的接口实时调整美颜效果，例如调整美白程度、磨皮程度等。通常，插件会提供一个控制面板或接口供开发者调用。
beautyPlugin.setBeautyLevel(3); beautyPlugin.setWhitenessLevel(2); 这些接口调用可以在直播过程中动态调整，让用户可以根据需要实时更改美颜效果。
总结：
通过上述步骤，您可以轻松地在项目中实现美颜功能，提升视频内容的质量和吸引力。希望这篇教程能为您的开发过程提供有用的参考，助您顺利完成集成工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417614a11f19bc38fd4a360a888d5698/" rel="bookmark">
			怎么将jar注册为windows系统服务详细操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将spring boot项目编译成jar,注册为windows系统服务
在网上了解到,winsw这个开源项目,去github看了下,作者常年维护更新,文档齐全,拥有不少,自己写了个小demo体验了下还不错,然后又运行了一个晚上,没啥问题,遂决定采用它
开源地址
源库地址 https://github.com/winsw/winsw
Releases · winsw/winsw · GitHub
教程所需示例文件地址[https://gitee.com/war110/test-winsw]
教程所需实力文件下载地址[https://gitee.com/war110/test-winsw/releases/tag/v1]
需要准备什么?
在releases下载这个软件的本体,一个exe,一个配置的xml
一个可以正常运行的jar(我是写了个自用的项目,每五秒输出一次日志)
一个win7或者win10的操作系统
注:下载示意,我使用的版本是2.11.0
开始操作如下：
准备好写好的jar,我这个是个刚初始化的spring boo项目,就额外加了个log日志的配置文件,代码仓库如下,exe和xml也在里面
配置xml文件,文件名改成和jar同名文件,例testexe.xml
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;service&gt; &lt;!-- 该服务的唯一标识 --&gt; &lt;id&gt;test-data&lt;/id&gt; &lt;!-- 注册为系统服务的名称 --&gt; &lt;name&gt;SW test Data&lt;/name&gt; &lt;!-- 对服务的描述 --&gt; &lt;description&gt;测试数据生成服务&lt;/description&gt; &lt;!-- 将java程序添加到系统服务 --&gt; &lt;executable&gt;java&lt;/executable&gt; &lt;!-- 执行的参数 --&gt; &lt;arguments&gt;-jar "testexe.jar"&lt;/arguments&gt; &lt;!-- 日志模式 这种是exe帮忙收集产生的日志配置,如果jar自带了log的话,也会输出 --&gt; &lt;!--&lt;logpath&gt;\logs&lt;/logpath&gt; &lt;log mode="roll-by-size"&gt; &lt;!-- 归档文件大小,单位是KB --&gt; &lt;sizeThreshold&gt;3&lt;/sizeThreshold&gt; &lt;keepFiles&gt;8&lt;/keepFiles&gt; &lt;/log&gt;--&gt; &lt;!-- 日志模式 这种是exe不用帮忙收集产生的日志配置 因为jar自带了log输出那一套 --&gt; &lt;log mode="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417614a11f19bc38fd4a360a888d5698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fecd1a8422f0324ade43130bfd6147/" rel="bookmark">
			基于JSP、java、Tomcat三者的项目实战--校园交易平台系统--（实习，答辩皆可用到）--万字爆更
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术支持：JAVA、JSP
服务器：TOMCAT 7.0.86
编程软件：IntelliJ IDEA 2021.1.3 x64
全部文件展示 网页实现功能截图 主页 注册 登录 购物车主页 修改功能 修改成功
添加商品功能 添加成功
添加进入购物车功能 支付功能 支付过的历史清单账单
全部代码 dao-&gt;StudentDAO package dao; import entiy.Product; import entiy.Student; import entiy.Total; import util.DBUtil; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class StudentDAO { public List&lt;Student&gt; findAll() throws Exception { List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); Connection conn = null; PreparedStatement prep = null; ResultSet rst = null; try { conn = DBUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2fecd1a8422f0324ade43130bfd6147/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a2e7eef9e6858a0027424d15e9e99a/" rel="bookmark">
			【LVS】防火墙标签解决轮询错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验：
测试：
实验：
两个服务端下载软件在重启httpd
lvs
标记多端口
多端口自动识别
测试
防火墙标记解决轮回问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0758a6d3c7207c09ab79ebbb9720c3/" rel="bookmark">
			mysql数据库：SQL语言基础和基本查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql数据库：SQL语言基础和基本查询 SQL语言简介 Structured Query Language, 结构化查询语言非过程性语言为加强SQL的语言能力，各厂商增强了过程性语言的特征如：Oracle的PL/SQL 过程性处理能力，SQL Server、Sybase的T-SQLSQL是用来存取关系数据库的语言，具有查询、操纵、定义和控制关系型数据库的四方面功能select * from tab where dt=‘20180808’ SQL分类 DDL 数据定义语言 - Data Definition Language用来定义数据库的对象，如数据表、视图、索引等 DML 数据处理语言 - Data Manipulation Language在数据库表中更新，增加和删除记录如 update， insert， delete DCL 数据控制语言 – Data Control Language指用于设置用户权限和控制事务语句如grant，revoke，if…else，while，begin transaction DQL 数据查询语言 – Data Query Languageselect SELECT语句的使用 SELECT语法是一种用于查询数据库中数据的SQL语句。其基本语法如下：
SELECT column1, column2, ... FROM table_name WHERE condition; 其中，SELECT关键字用于指定要查询的列，可以使用*代表所有列；FROM关键字用于指定要查询的表；WHERE关键字用于指定查询的条件。
select * from student where sex=’男’; INSERT语句的使用 INSERT语句用于向数据库中插入新的数据行。其基本语法如下：
INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0758a6d3c7207c09ab79ebbb9720c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de74a5edb6e1a9289ef010898242d76/" rel="bookmark">
			Android 获取短信验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 获取短信验证 Android 获取短信验证
输入发短信的手机号，点击获取验证码，等接收到验证码后就会自动获取
SmsReceiver.Java
import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.os.Build; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.telephony.SmsMessage; public class SmsReceiver extends BroadcastReceiver { private Handler handler; public SmsReceiver(Handler handler) { this.handler = handler; } @Override public void onReceive(Context context, Intent intent) { // 获取短信类型 String format = intent.getStringExtra("format"); Bundle bundle = intent.getExtras(); // 提前短信消息 Object[] pdus = (Object[]) bundle.get("pdus"); SmsMessage[] messages = new SmsMessage[pdus.length]; if (Build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0de74a5edb6e1a9289ef010898242d76/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/70/">«</a>
	<span class="pagination__item pagination__item--current">71/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/72/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>