<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f950adfca2a170068d3abef0c43db27a/" rel="bookmark">
			解读《生成式人工智能服务管理暂行办法》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《生成式人工智能服务管理暂行办法》 第一章 总　则第二章 技术发展与治理第三章 服务规范第四章 监督检查和法律责任第五章 附　则 以ChatGPT为代表的现象级互联网应用的出现，掀起了人工智能领域新一轮技术浪潮。作为新一代信息技术，生成式人工智能通过对人类“脑力”的无限延伸，赋予人们对于追求美好生活的更大想象空间。与此同时，生成式人工智能被滥用带来的数据泄露、虚假信息等风险挑战也纷至沓来，各国陆续推出或完善针对生成式人工智能的监管方案。
《生成式人工智能服务管理暂行办法》（以下简称《办法》）于2023年5月23日国家互联网信息办公室2023年第12次室务会会议审议通过，并经国家发展和改革委员会、教育部、科学技术部、工业和信息化部、公安部、国家广播电视总局同意，自2023年8月15日起施行。
《办法》是对我国人工智能法律体系与算法治理体系的进一步完善，与《互联网信息服务算法推荐管理规定》、《互联网信息服务深度合成管理规定》在治理思路上一脉相承，在治理制度方面创新推进，坚持从生成式人工智能技术特点出发，提出了一系列针对性的发展与治理措施。
《办法》共5章24条，逐条解读如下。
第一章 总　则 第一条 为了促进生成式人工智能健康发展和规范应用，维护国家安全和社会公共利益，保护公民、法人和其他组织的合法权益，根据《中华人民共和国网络安全法》、《中华人民共和国数据安全法》、《中华人民共和国个人信息保护法》、《中华人民共和国科学技术进步法》等法律、行政法规，制定本办法。
本条款明确了立法目的与依据。
第二条 利用生成式人工智能技术向中华人民共和国境内公众提供生成文本、图片、音频、视频等内容的服务（以下称生成式人工智能服务），适用本办法。
国家对利用生成式人工智能服务从事新闻出版、影视制作、文艺创作等活动另有规定的，从其规定。
行业组织、企业、教育和科研机构、公共文化机构、有关专业机构等研发、应用生成式人工智能技术，未向境内公众提供生成式人工智能服务的，不适用本办法的规定。
本条款明确了适用范围。
第三条 国家坚持发展和安全并重、促进创新和依法治理相结合的原则，采取有效措施鼓励生成式人工智能创新发展，对生成式人工智能服务实行包容审慎和分类分级监管。
本条款明确了原则。
第四条 提供和使用生成式人工智能服务，应当遵守法律、行政法规，尊重社会公德和伦理道德，遵守以下规定：
（一）坚持社会主义核心价值观，不得生成煽动颠覆国家政权、推翻社会主义制度，危害国家安全和利益、损害国家形象，煽动分裂国家、破坏国家统一和社会稳定，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，暴力、淫秽色情，以及虚假有害信息等法律、行政法规禁止的内容；
（二）在算法设计、训练数据选择、模型生成和优化、提供服务等过程中，采取有效措施防止产生民族、信仰、国别、地域、性别、年龄、职业、健康等歧视；
（三）尊重知识产权、商业道德，保守商业秘密，不得利用算法、数据、平台等优势，实施垄断和不正当竞争行为；
（四）尊重他人合法权益，不得危害他人身心健康，不得侵害他人肖像权、名誉权、荣誉权、隐私权和个人信息权益；
（五）基于服务类型特点，采取有效措施，提升生成式人工智能服务的透明度，提高生成内容的准确性和可靠性。
本条款是《办法》的核心条款，详细解读如下：
（1）价值观问题
生成式人工智能具有价值观属性。生成式人工智能模型经过训练后，对一些概念具备了较为稳定的“认知”，围绕相关概念的生成内容往往表现出惊人的一致性。**大模型的生成结果取决于训练语料，语料的选取与标注直接决定了大模型的价值观。**一旦模型在训练过程中引入涉及国家主权、意识形态等方面的有害信息，在模型实际应用中很可能呈现放大化输出。
（2）非歧视性问题
有偏见的数据将导致有偏见的算法。数据集是机器学习、人工智能的基础，如果数据集本身缺乏代表性，就不能够客观地反映现实情况，算法决策就难免有失公允。在生成式人工智能的开发中，需要付出更大努力来收集更少偏见和更具代表性的数据，确保生成内容符合非歧视性要求。
（3）知识产权等商业问题
生成式人工智能在训练过程中，会使用到大量未经授权的素材，并且以黑盒的方式进行加工和输出，引发了一系列的侵权问题，部分还涉及商业机密等。
如，马斯克称微软在未得到用户的同意的情况下，非法利用推特数据训练其人工智能模型，侵犯了用户的隐私和版权。
（4）合法权益保护问题
以ChatGPT为代表的大语言模型主要以人机对话的方式提供服务，用户在使用的时候一般需要注册并登陆。通过收集用户的问题以及用户对输出内容的反馈，可以掌握大量用户的个人隐私信息，深度洞悉用户的心理状体。这样大模型就具备了针对不同用户生成不同内容的能力，可以更具精准、有效的影响用户观点与立场。
（5）真实准确的问题
以ChatGPT为代表的大语言模型生成的内容逻辑性强、结构合理、表述流畅，会在不理解上下文的情况下，以“权威身份”回答问题，经常会出现一本正经胡说八道的情况，容易对用户造成误导（《被ChatGPT骗了！再用ChatGPT可要小心了》），甚至可以用来生成大规模虚假消息。
第二章 技术发展与治理 第五条 鼓励生成式人工智能技术在各行业、各领域的创新应用，生成积极健康、向上向善的优质内容，探索优化应用场景，构建应用生态体系。
支持行业组织、企业、教育和科研机构、公共文化机构、有关专业机构等在生成式人工智能技术创新、数据资源建设、转化应用、风险防范等方面开展协作。
本条款明确了明确政府鼓励人工智能创新发展。
第六条 鼓励生成式人工智能算法、框架、芯片及配套软件平台等基础技术的自主创新，平等互利开展国际交流与合作，参与生成式人工智能相关国际规则制定。
推动生成式人工智能基础设施和公共训练数据资源平台建设。促进算力资源协同共享，提升算力资源利用效能。推动公共数据分类分级有序开放，扩展高质量的公共训练数据资源。鼓励采用安全可信的芯片、软件、工具、算力和数据资源。
本条款强调鼓励芯片、算法、软件和数据的自主创新发展。由于目前芯片主要依赖英伟达公司的GPU卡，算法主要基于谷歌公司的Transfomers算法，软件则主要以pytorch、tensorflow为主，数据方面也缺少高质量的中文语料，因此特别强调芯片、算法、软件和数据资源的自主创新。
第七条 生成式人工智能服务提供者（以下称提供者）应当依法开展预训练、优化训练等训练数据处理活动，遵守以下规定：
（一）使用具有合法来源的数据和基础模型；
（二）涉及知识产权的，不得侵害他人依法享有的知识产权；
（三）涉及个人信息的，应当取得个人同意或者符合法律、行政法规规定的其他情形；
（四）采取有效措施提高训练数据质量，增强训练数据的真实性、准确性、客观性、多样性；
（五）《中华人民共和国网络安全法》、《中华人民共和国数据安全法》、《中华人民共和国个人信息保护法》等法律、行政法规的其他有关规定和有关主管部门的相关监管要求。
本条款是《办法》的关键条款，一是明确了训练数据来源的合法性，来源渠道需合法合规，不得使用窃取或其他非法方式获取的数据；二是明确了数据内容本身的合法性，不得侵害知识产权与个人隐私；三是要求提高训练数据质量。
第八条 在生成式人工智能技术研发过程中进行数据标注的，提供者应当制定符合本办法要求的清晰、具体、可操作的标注规则；开展数据标注质量评估，抽样核验标注内容的准确性；对标注人员进行必要培训，提升尊法守法意识，监督指导标注人员规范开展标注工作。
本条款明确了数据人工标注的要求，人工标注是确保数据内容准确的关键环节。
第三章 服务规范 第九条 提供者应当依法承担网络信息内容生产者责任，履行网络信息安全义务。涉及个人信息的，依法承担个人信息处理者责任，履行个人信息保护义务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f950adfca2a170068d3abef0c43db27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142f8250ae76b5ad121b55eb748d7161/" rel="bookmark">
			【LeetCode】动态规划 刷题训练(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 123. 买卖股票的最佳时机 III题目解析零笔交易一笔交易两笔交易 状态转移方程f[i][j]状态转移方程g[i][j]状态转移方程 初始化完整代码 188. 买卖股票的最佳时机 IV题目解析状态转移方程f[i][j]状态转移方程g[i][j]状态转移方程 初始化完整代码 53. 最大子数组和状态转移方程初始化完整代码 123. 买卖股票的最佳时机 III 点击查看：买卖股票的最佳时机 III
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2：
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/142f8250ae76b5ad121b55eb748d7161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa68576a04259deb3af669562c964d1/" rel="bookmark">
			stable diffusion实践操作-批次出图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 stable diffusion实践操作
文章目录 系列文章目录前言一、批次出图介绍1.1 webUI设置1.2 参数介绍 二、批次出图使用2.1 如何设置2.1 效果展示 总结 前言 本章主要介绍SD批次出图。
想要一次产生多张图片的时候使用。
一、批次出图介绍 1.1 webUI设置 1.2 参数介绍 二、批次出图使用 2.1 如何设置 生成批次和每批数量至少一个为1，
2.1 效果展示 产生了一张合图和4张单独图片。
总结 例如：以上就是今天要讲的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f400a9f025307a74f581762fb4bc74c4/" rel="bookmark">
			构建现代应用：Java中的热门架构概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 三层架构2. Spring框架3. 微服务架构4. Java EE（Enterprise Edition）5. 响应式架构6. 大数据架构7. 领域驱动设计（Domain-Driven Design，DDD）8. 安卓开发架构结论 🎉欢迎来到Java学习路线专栏~构建现代应用：Java中的热门架构概览
☆* o(≧▽≦)o *☆嗨~我是IT·陈寒🍹✨博客主页：IT·陈寒的博客🎈该系列文章专栏：Java学习路线📜其他专栏：Java学习路线 Java面试技巧 Java实战项目 AIGC人工智能 数据结构学习🍹文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️ Java作为一门广泛应用于企业级应用开发的编程语言，拥有众多成熟的架构和框架，用于构建各种规模的应用程序。本文将介绍Java中常用的架构，这些架构在不同场景下都有着卓越的表现，涵盖了传统的三层架构到现代微服务架构的演进。
1. 三层架构 三层架构是一种经典的应用程序架构，将应用程序分为三个主要部分：
表现层（Presentation Layer）： 表现层通常是用户与应用程序交互的界面，可以是Web界面、移动应用程序或桌面应用程序。在Java中，常见的表现层技术包括JavaServer Pages（JSP）、Servlets和现代的前端框架如React和Angular。
业务逻辑层（Business Logic Layer）： 业务逻辑层包含应用程序的核心功能和处理业务逻辑的代码。在Java中，通常使用Java类和EJB（Enterprise JavaBeans）来实现业务逻辑。
数据访问层（Data Access Layer）： 数据访问层负责与数据库或其他数据存储交互，执行数据的读取和写入操作。Java中，常见的数据访问技术包括Java Persistence API（JPA）和Hibernate。
核心概念： 三层架构将应用程序分为三个主要层次，包括表示层（Presentation Layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data Access Layer）。这种架构有助于将应用程序的不同功能分离开来，使其更容易维护和扩展。
优点：
清晰的分层结构。容易维护和扩展。可重用性高。 挑战：
可能存在性能瓶颈。通信开销。 代码示例：
假设我们有一个简单的学生管理系统，我们可以使用三层架构来组织代码。以下是示例代码：
// Presentation Layer public class StudentController { private StudentService studentService; public StudentController() { this.studentService = new StudentService(); } public void addStudent(String name, int age) { studentService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f400a9f025307a74f581762fb4bc74c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54e6a723f2193e2da1b02159c346a29/" rel="bookmark">
			确定Mac\Linux系统的架构类型是 x86-64（amd64），还是 arm64 架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在下载软件或镜像时会有很多版本，那需要根据我们的系统架构选择正确的软件或镜像版本。
要确定你的系统使用的是 x86-64（amd64） 还是 arm64 架构，可以使用以下方法之一：
使用 uname 命令：
打开终端，并运行以下命令：
uname -m 在MAC中：
如果输出结果是 x86_64，则表示你的系统是 x86-64 架构。
如果输出结果是 arm64，则表示你的系统是 arm64 架构。
在 Linux中
如果输出结果是 x86_64，则表示你的系统是 x86-64 架构。
如果输出结果是 aarch64，则表示你的系统是 arm64 架构。
使用 arch 命令：
在终端中运行以下命令：
arch 在MAC中：
如果输出结果是 x86_64，则表示你的系统是 x86-64 架构。
如果输出结果是 arm64，则表示你的系统是 arm64 架构。
在 Linux中
如果输出结果是 x86_64，则表示你的系统是 x86-64 架构。
如果输出结果是 aarch64，则表示你的系统是 arm64 架构。
查看系统信息：system_profiler SPHardwareDataType
在终端中运行以下命令：
在MAC中：
system_profiler SPHardwareDataType 如果输出包含 “Processor Name: Apple M1” 或者 “Chip: Apple M1” ，表示你的系统是 arm64 架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a54e6a723f2193e2da1b02159c346a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6da276bf8d4086e524c5a11ebc52e3/" rel="bookmark">
			【机器学习/人工智能】 大作业：手写数字识别系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 参考的是https://zh.d2l.ai/index.html
代码运行的相关实操移步视频https://www.bilibili.com/video/BV1XP411C7Hs/
一、大作业设计目的与要求 （1）利用所学习的聚类算法完成简单的图像分割系统。
（2）编程并利用相关软件完成大作业测试，得到实验结果。
（3）通过对实验结果的分析得出实验结论，培养学生创新思维和编写实验报告的能力，以及处理一般工程设计技术问题的初步能力及实事求是的科学态度。
（4）利用实验更加直观、方便和易于操作的优势，提高学生学习兴趣，让学生自主发挥设计和实施实验，发挥出学生潜在的积极性和创造性。
（5）通过实验的锻炼，使学生进一步掌握基于卷积神经网络的图像分类问题，也进一步领会学习机器学习知识的重要意义。
二、大作业设计内容 大作业1 :手写数字识别系统。
本项目要求选择机器学习算法设计实现手写数字识别系统。手写数字识别在日常生活中有重要应用，例如汇款单、银行支票的处理，以及邮件的分拣等。手写数字识别通常对精度要求较高，虽然只有10类，但是每个人的字迹不同，要做到精确识别有一定难度。项目的具体要求如下:
(1)使用MNIST手写数字数据集，进行手写数字识别(参考课本P186， 例6.2 )。
(2)选择合适的机器学习算法进行手写数字识别，训练分类模型，要求识别精度尽可能高。
(3)编写简单用户界面，可以加载手写数字图片，并调用算法识别数字。
三、程序开发与运行环境 显卡：NVIDIA显卡，CUDA 11.7。
系统与环境：Windows11操作系统，Anaconda3的base虚拟环境。
IDE：Pycharm Community集成开发环境，Jupyter Notebook
深度学习框架：PyTorch深度学习框架，基于GPU版本。
图形界面框架：PyQt5
四、设计正文 （包括分析与设计思路、各模块流程图、主要算法伪代码等，如有改进或者拓展，请重点用一小节进行说明）
4.1 分析与设计思路与流程图 本次实验任务是使用MNIST手写数据集进行手写数字识别。使用传统的多层感知机等神经网络模型不能很好地解决此类问题，因为这种模型直接读取图像的原始像素，基于图像的原始像素进行分类。然而，图像特征的提取还需要人工设计函数进行提取。所以，卷积神经网络模型可以很好地对图像进行自动的特征提取。
本次大作业使用经典的AlexNet卷积神经网络模型。AlexNet卷积神经网络模型具有以下整体结构：
包含8层变换，包括5层卷积和2层全连接的隐藏层，1个全连接的输出层。其中，第一层的卷积窗口形状为1111，可以支持输入更大的图像。第二层卷积窗口形状减小到55，之后的3层卷积采用33的窗口。在第一、第二、第五个卷积层之后都使用了卷积窗口大小为33、且步幅为2的最大池化。卷积通道数比LeNet大了10倍。在最后一个卷积与池化层后，就是两个输出个数为4096的全连接层，最后输出结果。
1.引入了图像增广、翻转、裁剪等方法，进一步从原始数据集中制作、扩大数据集。
AlexNet流程图如下：
在本实验中，因为运行的是MNIST数据集，所以最后一个全连接层只有10个结点，而非该流程图中的1000。
为了进行图形化的界面展示，还利用PyQt框架设置了前端图形界面。
在训练完成数据集后，将模型写入硬盘文件并保存，以供前端的图形界面调用、读取。
所以，前端的图形界面在初始化过程中，就预先加载好了训练好的模型。用户可以从文件中读入需要识别的手写数字图片，由前端图形界面根据加载好的模型自动给出该手写数字图片的识别结果。所以，本次实验中各个模块的交互逻辑如下图所示。
4.2 主要算法代码 训练模型
import numpy as np # numpy数组库 import math # 数学运算库 import matplotlib.pyplot as plt # 画图库 import torch # torch基础库 import torchvision.datasets as dataset # 公开数据集的下载和管理 import torchvision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd6da276bf8d4086e524c5a11ebc52e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc0279af00c61229d14efa90fc9ee320/" rel="bookmark">
			解决：Collecting package metadata (current_repodata.json)/ Solving environment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Pytorch时报错：
Collecting package metadata (current_repodata.json): - WARNING conda.models.version:get_matcher(556): Using .* with relational operator is superfluous and deprecated and will be removed in a future version of conda. Your spec was 1.7.1.*, but conda is ignoring the .* and treating it as 1.7.1 done Solving environment: unsuccessful initial attempt using frozen solve. Retrying with flexible solve. Solving environment: unsuccessful attempt using repodata from current_repodata.json, retrying with next repodata source. Collecting package metadata (repodata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc0279af00c61229d14efa90fc9ee320/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa833c8b98132abea8cec4877aee4393/" rel="bookmark">
			iOS 常用应用的url scheme
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 应用连接地址idurl scheme微信‎App Store 上的“微信”414478124weixin://淘宝https://itunes.apple.com/cn/app/id387682726?mt=8387682726taobao://QQhttps://itunes.apple.com/cn/app/id444934666?mt=8444934666mqq://百度https://itunes.apple.com/cn/app/id382201985?mt=8382201985BaiduSSO://墨迹天气https://itunes.apple.com/cn/app/id434209233?mt=8434209233rm434209233MojiWeather://UC浏览器https://itunes.apple.com/cn/app/id527109739?mt=8527109739ucbrowser://百度地图https://itunes.apple.com/cn/app/id452186370?mt=8452186370bdmap://今日头条https://itunes.apple.com/cn/app/id529092160?mt=8529092160snssdk141://美团https://itunes.apple.com/cn/app/id423084029?mt=8423084029imeituan://京东https://itunes.apple.com/cn/app/id414245413?mt=8414245413openapp.jdmoble://唯品会https://itunes.apple.com/cn/app/id417200582?mt=8417200582VSSpecialSwitch://大众点评https://itunes.apple.com/cn/app/id351091731?mt=8351091731dianping://支付宝https://itunes.apple.com/cn/app/id333206289?mt=8333206289alipay://手机卫士https://itunes.apple.com/cn/app/id441216572?mt=8441216572systemexpert360://优酷https://itunes.apple.com/cn/app/id336141475?mt=8336141475youku://酷狗音乐https://itunes.apple.com/cn/app/id472208016?mt=8472208016kugouURL://微博https://itunes.apple.com/cn/app/id350962117?mt=8350962117sinaweibo://携程https://itunes.apple.com/cn/app/id379395415?mt=8379395415ctrip://滴滴打车https://itunes.apple.com/cn/app/id554499054?mt=8554499054diditaxi://58同城https://itunes.apple.com/cn/app/id404612543?mt=8404612543wbmain:// 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c6297aebe4fe51c645cfd92694d6d5/" rel="bookmark">
			基于LoRA进行Stable Diffusion的微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基于LoRA进行Stable Diffusion的微调数据集模型下载环境配置微调过程 推理WebUI部署 基于LoRA进行Stable Diffusion的微调 数据集 本次微调使用的数据集为： LambdaLabs的Pokemon数据集
使用git clone命令下载数据集
git clone https://huggingface.co/datasets/lambdalabs/pokemon-blip-captions 数据集一共883条样本，包含两个部分：image（图）和 text（文），如下图所示。
模型下载 git clone https://huggingface.co/runwayml/stable-diffusion-v1-5 环境配置 # 创建一个新的conda环境 conda create -n diffusers python==3.10 # 激活conda环境 conda activate diffusers # 下载模型仓库 git clone https://github.com/huggingface/diffusers # 进入diffusers目录 cd diffusers # 进行安装 pip install . cd examples/text_to_image # 安装环境所需的包 pip install -r requirements.txt 微调过程 微调时只需要使用以下命令运行 train_text_to_image_lora.py 文件即可。需要根据下载的路径文件地址对相应的参数进行修改，如 MODEL_NAME、DATASET_NAME 等；也可以根据GPU资源调整相应的参数，如 train_batch_size、gradient_accumulation_steps 等。
export MODEL_NAME="/data/sim_chatgpt/stable-diffusion-v1-5" export OUTPUT_DIR="./finetune/lora/pokemon" export DATASET_NAME="./pokemon-blip-captions" nohup accelerate launch --mixed_precision="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c6297aebe4fe51c645cfd92694d6d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf09cb0507f3282249294d73af0964e1/" rel="bookmark">
			nginx 配置 ssl 后无法访问 nginx: [emerg] cannot load certificate “*”: BIO_new_file() failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx: [emerg] cannot load certificate “/etc/nginx/ssl/a.pem”: BIO_new_file() failed (SSL: error:0200100D:system library:fopen:Permission denied:fopen(‘/etc/nginx/ssl/a.pem’,‘r’) error:2006D002:BIO routines:BIO_new_file:system lib) 场景 nginx 配置 ssl 后无法访问
1. 确认443端口已开放 2. ssl 证书有效 3. nginx -t 检测正常 nginx -s reload 无异常，其他域名也可以正常访问
使用 systemctl status nginx 查看状态，发现异常
Sep 01 10:42:55 instance-1 systemd[1]: Starting The nginx HTTP and reverse proxy server... Sep 01 10:42:55 instance-1 nginx[5131]: nginx: [emerg] cannot load certificate "/etc/nginx/ssl/a.pem": BIO_new_file() failed (SSL: error:0200100D:system library:fopen:Permission deni...file:system lib) Sep 01 10:42:55 instance-1 nginx[5131]: nginx: configuration file /etc/nginx/nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf09cb0507f3282249294d73af0964e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f30fac454a99849e2f0278c88ceab8/" rel="bookmark">
			《人工智能算法图解》书籍分享（包邮送书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 人工智能介绍书籍分享抽奖包邮送书 人工智能介绍 人工智能算法是一种能够模拟人类智能行为的计算机算法。它通过分析和处理大量的数据，利用机器学习、深度学习和自然语言处理等技术，实现自主学习、推理和决策的能力。
人工智能算法的发展经历了多个阶段和重要的里程碑。以下是人工智能算法发展的主要阶段和关键技术：
逻辑推理阶段：20世纪50年代至70年代，人工智能算法主要集中在逻辑推理和专家系统上。这些算法通过符号推理和规则引擎来模拟人类的思维过程，例如使用规则库和推理机实现的专家系统。
统计学习阶段：20世纪80年代至90年代，人工智能算法逐渐转向统计学习方法。这些方法使用大量的数据进行模型训练，并通过统计分析和概率推断来进行预测和决策。常见的算法包括朴素贝叶斯、决策树、支持向量机等。
机器学习阶段：21世纪初至今，机器学习成为人工智能算法的主流。机器学习算法通过训练模型来从数据中学习，并进行预测和决策。其中，监督学习算法使用标记数据进行模型训练，无监督学习算法从无标记数据中发现模式，强化学习算法通过试错和奖惩机制来学习最优行为策略。
深度学习阶段：近年来，深度学习技术的快速发展使得人工智能算法在图像识别、语音识别、自然语言处理等领域取得了突破性进展。深度学习算法使用多层神经网络模型来进行学习和预测，如卷积神经网络（CNN）和循环神经网络（RNN）等。
书籍分享 "今天，人工智能在我们的生活中随处可见。它能推送我们喜欢的电视节目，帮助我们诊断疑难杂症，还能向我们推荐商品。因此，让我们掌握人工智能的核心算法，拥抱日新月异的智能世界吧。
与那些充斥着公式和术语的教材不同，本书利用丰富的图表、案例和习题，深入浅出地讲解人工智能的基本概念。你只需要具备高中数学基础知识，即可轻松阅读本书。读完本书之后，你将能亲手设计算法来预测银行交易风险，创造艺术作品甚至配置自动驾驶汽车。
主要内容：
●各种人工智能算法的实践场景
●帮助决策的智能搜索算法
●受生物学启发的算法簇
●机器学习与神经网络
●强化学习 与Q-learning
本书重点涵盖的算法簇包括搜索算法、进化算法与群体智能算法。每簇算法由浅入深分.上下两章，上章 基础篇围绕各种实际案例阐述算法设计理念，下章高级篇则带读者思考如何打造更理想的解决方案。同时，本书以典型机器学习工作流为例，讲解线性回归、决策树、神经网络与强化学习等常见算法类别。读完本书，你将能掌握清洗数据、训练模型、测试模型、调优算法等整个学习流程中的关键技巧一-正所谓万变不离其宗， 这将为你以后进一步探索智能世界打下坚实基础。
承接“图解”系列的一贯作风， 本书中不会出现任何复杂的公式，取而代之的是各种实战图例。只需要具备高中数学水平和基础编程知识，你就可顺利解决书中提及的从智能对弈到停车场寻路的各种案例。更棒的是，算法核心代码往往相对独立地运作，不会像真正意义上的工程代码那样复杂，百十行就能轻松解决集装箱自动化配货之类的问题(书中所有样例代码均在Github. 上免费开源)。触手可得的智能解决方案，为什么不试试看呢?
抽奖包邮送书 抽奖送书老规矩（不点赞收藏中奖无效）：注意记得关注博主不然中奖了还不知道！！！
1. 点赞收藏文章2. 评论区留言：人生苦短，我用Python！！！（留言才能进入奖池，每人最多留言三条）3. 周日八点爬虫抽奖5人京东：https://item.jd.com/13056363.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d594cc14c5670bfd93f09f8134fe0ae8/" rel="bookmark">
			基于Python&#43;OpenCV智能答题卡识别系统——深度学习和图像识别算法应用(含Python全部工程源码)&#43;训练与测试数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言总体设计系统整体结构图系统流程图 运行环境Python 环境PyCharm安装OpenCV环境 模块实现1. 信息识别2. Excel导出模块3. 图形用户界面模块4. 手写识别模块 系统测试1. 系统识别准确率2. 系统识别应用 工程源代码下载其它资料下载 前言 本项目基于Python和OpenCV图像处理库，在Windows平台下开发了一个答题卡识别系统。系统运用精巧的计算机视觉算法，实现了批量识别答题卡并将信息导出至Excel表格的功能。这一解决方案使得答题卡的判卷过程变得轻便、高效且准确。
首先，我们以Python语言作为开发基础，结合OpenCV图像处理库，为系统提供了强大的图像处理和分析能力。这使得我们能够在图像中准确地定位答题卡，检测填涂区域，以及识别填涂的内容。
在Windows平台下进行开发，我们能够充分利用操作系统的功能，确保系统在用户环境中的稳定性和兼容性。
系统中的计算机视觉算法经过精心设计，可以可靠地识别答题卡上的填涂信息。从扫描的图像中，我们能够确定哪些选项被填涂，并将这些信息精准地提取出来。
一旦信息被提取，系统能够将这些数据导出至Excel表格，实现了高效的数据整理和统计功能。这使得判卷过程变得高度自动化，减少了繁琐的手动工作，同时也降低了错误的风险。
总结而言，本项目的开发利用了Python语言和OpenCV图像处理库的强大功能，实现了一个全面的答题卡识别系统。通过高效的图像处理和数据导出功能，系统不仅减轻了判卷的负担，还大幅度提高了识别的准确性和效率。这对于教育机构和考试机构来说，都具有极大的实用价值。
总体设计 本部分包括系统整体结构图和系统流程图。
系统整体结构图 系统整体结构如图所示。
系统流程图 系统流程如图所示。
运行环境 本部分包括Python环境、OpenCV环境、图像处理工具包、requests、 base64和xlwt模块 。
Python 环境 需要Python 3.6及以上配置。在Windows环境下下载Anaconda完成Python所需配置，下载地址为https://www.anaconda.com/。
PyCharm安装 在网站https://www.jetbrains.com/pycharm/中下载对应机器的安装包。采用免费社区版下载exe格式文件即可。
OpenCV环境 在PyCharm中安装OpenCV 3.4.15，选择Settings下Project中的Interpreter，单击右上角加号，搜索需要添加的库，选中Specifyversion和3.4.15，单击OK按钮即可。
按如上方法安装imutils、requests和base64。 通过pip install xlwt安装xlwt模块，实现数据写入Excel表格的功能。
模块实现 本项目包括4个模块：信息识别、Excel导出、图形用户界面和手写识别，下面分别介绍各模块的功能及相关代码。
1. 信息识别 基于OpenCV算法，实现对图片中选项信息、学生身份信息的检测。在开始编写系统前，用Photoshop软件绘制用到的答题卡，如图所示。
答题卡中共计50道单选题，每选对1题得2分，漏选提示“漏选”，多选提示“多选”，最后返回成绩和统计错误选项的字典。
学院、班级、学号等信息采用“涂出来”的方式，相比初版系统中“写出来”的方式，识别准确率更高，代码更简单。
具体描述如下：
（1）利用get_position函数，通过上述信息识别算法，拿到身份信息被涂轮廓的重心坐标数组Info和选项信息被涂轮廓重心坐标数组Answer。
图片预处理：将图片做滤波去噪后，进行透视变换，并调整至2400X 2800的统一规格， 如图1~图9所示。
相关代码如下:
#导入相应数据包 import cv2 import matplotlib.pyplot as plt import imutils import numpy as np def cv_show(name, img): #展示图片 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d594cc14c5670bfd93f09f8134fe0ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18e3672b8e011a368079efad4d34ab34/" rel="bookmark">
			AI 绘画Stable Diffusion 研究（八）sd采样方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是风雨无阻。
本期内容：
什么是采样方法 ？采样方法的分类有哪些？怎么选择合适的采样方法？ 在 Stable Diffusion中目前已经有很多采样方法 ，不同的采样方法，出图效果不同。这里将详细介绍这些采样方法，以及在使用 Stable Diffusion 的过程中，怎么选择合适的采样方法。
一、什么是采样方法 ？
在了解采样之前，我们得先了解 一下Stable Diffusion webui 是如何工作的，建议看看我之前的AI 绘画Stable Diffusion 研究（七）sd webui如何工作这篇文章。
我们知道 sd webui 生成图像，大致会经过以下过程：
1、为了生成图像， Stable Diffusion 会在潜在空间中生成一个完全随机的图像
2、噪声预测器会估算图像的噪声
3、噪声预测器从图像中减去预测的噪声
4、这个过程反复重复 N 次以后，会得到一个干净准确的图像
这个去噪的过程，就被称为采样。
采样中使用的方法被称为 Sampling method （采样方法或者是采样器）。
采样步骤 Sampling steps 有什么影响？
采样步骤，那么每个步骤降噪就越小 ，这样可以减少采样过程中的截断误差。
二、采样方法的分类
为了便于使用和理解，我们可以将这些采样方法进行分类：
（1）、经典ODE求解器
包含：Euler \Heun \LMS。
Euler采样器：欧拉采样方法。
Heun采样器：欧拉的一个更准确但是较慢的版本。
LMS采样器：线性多步法，与欧拉采样器速度相仿，但是更准确。
（2）、祖先采样器 （名称中有一个字母 a 的）
包含 :Euler a \ DPM2 a \DPM++2S a \DPM2 a Karras \DPM++2S a Karras
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18e3672b8e011a368079efad4d34ab34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0bd3cfd1cb0e58032c5273d36fa980c/" rel="bookmark">
			通俗地讲讲算法开发和部署的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多学习资料都非常的碎片零散，算法是算法，部署是部署，开发是开发。学了算法不知道它怎么在机器上运行的，学了部署不知道开发是怎么调用它的，学了开发不知道算法要给你个什么玩意儿。
今儿个通俗地梳理一下整个算法开发和部署的流程，用我似懂非懂的理解。
1. 算法开发 简单理解，算法就是一种计算方法，无论是机器学习中的SVM，GBDT还是深度学习中的各种神经网络层，CNN，POOL，CBL，ELAN，SPPF，SPP，CSP，BOTTLENECK等等，都是一种计算方法，好比是一个参数待求的复杂的函数F(x)。需要从输入的数据中提取特征，经由函数映射到一个结果，可能是分类结果，也可能是回归结果。
1.1 明确目的与评估标准 就是我要实现个什么目的，一切都是为了解决真实问题，没有问题，就没有必要去开发，躺平就好。有了问题，就需要有应对方法，选择什么样的算法。而选择什么样的算法，有些前提条件，就是要满足使用要求，就像做土木工程的，盖房子有质量验收标准，比如要求结果墙体垂直度每层楼偏差正负八的话，要求高的话，就尽量用铝合金模板，这种工艺混凝土成型质量好。
算法的选择就像是选施工工艺，评估标准就是结果精度，这个精度可以是精准率、召回率、F1-score、AP值、mAP值、AUC等等。
1.2 算法设计/选型与数据准备 普通工程师选算法，研究员设计算法。工程师，就是个搭积木的，我不创造积木，当然偶尔有些想法能搞些出奇效的组合。
数据准备，需要去获取训练算法模型的数据集。这个活量大、技术含量低，一般外包给别人去做。到底需要多少量的数据，看经验，也看实际算法的结果。业内流传着一句话，决定算法精度的不是算法本身，而是数据，数据越大，效果也会更好，泛化性更强。
数据标签如果格式是VOC/XML的，如果需要转换成YOLO之类的格式的，又或者是CSV的需要转换成VOC的，转来转去，都只是一种形式，就像美少女衣服换来换去，关上灯还是一样的。
1.3 模型训练 有了算法、有了数据，就以训练了。
1.4 模型压缩 弄出来的模型参数量太大，上千万级别挺常见。这一堆参数就像是臃肿的机构，一开始咱也不知道谁能干谁不能干，但咱知道先把人堆起来，神奇的事情发生了，这机构的职能可以正常工作。所以也就暂且不管那些尸位素餐或者爱躺平的家伙了。慢慢地你会发现，能干的人越干越多，不能干的可有可无，浪费国家粮食。是不是像极了大企业大机构里的现象？臃肿就会导致给老百姓办事慢，做事效率低，还费钱。反应到算法上就是，模型占用内存大，模型推理速度慢。
模型剪枝，就是在给这个臃肿的机构裁员，能干的留下，不能干的（反应到参数上就是权重过小）滚蛋，今年裁它丫的50%，就真剩下50%的人（参数）了。工作量就像是水，盛它的小湖小沟少了，就自然要重新分流了。于时剪枝过后，还是要对算法fine-tune一下的。
模型蒸馏，这个还不会，以后弄明白了再说。
模型量化，简单理解为，在机构中以前管理很严格，表面工作很多，每次同事之间有点事情都需要写个报告，繁琐且没必要，耽误事儿。这类比的就是将FP32精度的权重，转换成FP16半精度甚至INT8的。每次有事同事之间不用搞那么仔细，随便说一下就行，这办事效率不就上来了么？但同样也会存在事情没说清楚的情况，导致结果有点偏差。
1.5 模型格式转换
这个世界有很多个国家，也有很多种语言，同样每个行业中也有很多种规范。比如建筑行业中，不同国家的设计标准是不一样的，即使是在中国不同省份的设计标准也有一些差异。这就是这个世界没有大一统整出来的费劲玩意儿，五花八门的框架，Pytorch, Caffe, Tensorflow, Keras, MXNet, Paddle-Paddle...
到模型部署的时候，硬件与软件支持的又有点儿不一样了，这些玩意儿弄出的模型格式不能用了，看不懂了，玩不转了。最后你还是得统一一下标准和格式，是要有GB（国标）还是要用BS（英标）还是要用ASTM（美标），不然承包商都不知道要什么要求干活，监理方也不知道按什么要求验收了。
这里有一个较为通用的格式ONNX，许多家推出深度学习框架的公司一起搞出来的，好比是一个通用标准。OpenVINO, TensorRT等常用的推理框架都支持。
2. 算法部署 2.1 部署框架选择 深度学习的框架有好多久，就像设计规范有好多种，最后要确定一种施工方能够接受的，熟悉的，适应的。有了模型，就好比是建筑业中有了设计，承包商拿到图纸后，得把房子盖起来。盖房子的过程好比是算法部署。
部署有很多种，有部署在服务器，部署在工控机，部署在手机，有的用的TPN（Tensor Processing Unit) / NPU(Neural Processing Unit) ，有的用的GPU(Graphic Processing Uint), 有的用的CPU。不同的平台不同设备资源，好比是干工地的，有的用挖机挖土，有的用人工挖土；打灰的有的用汽车泵打灰，有的人工推个小车打灰；有的工艺速度快，有的速度慢。
针对于不同部署环境，就有了不同的工艺和方法，也就是不同的推理框架。
有OpenVINO, TensorRT, NCNN, MCN, OnnxRuntime, TFLite, PyTorch Mobile等。
2.1 前处理与后处理 在模型训练、测试前是需要将数据进行预处理的，包括有必要的数据仿射变换（缩放、平移、旋转）、标准化、归一化、通道转换（BGR2RGB）等，训练阶段还包括诸如Mosaic, CopyPaste, HSV, RandomCrop, Flip, RandomScale等数据增强的处理。
模型输出的结果，还需要进行数据解码的操作。这些操作在部署是一样需要的。
2.2 模型推理 这些个推理框架封装了算法模型的解析工具，比如TensorRT里面就有NvOnnxParser这个工具，可以将导出的onnx格式的算法进行一个转换。当然也可以，利用TensorRT中内置的网络层重新构建一个算法模型。如果对网络层有定制化需求，也可以写一个TensorRT的插件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0bd3cfd1cb0e58032c5273d36fa980c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9743053267088113953b31110573a9c/" rel="bookmark">
			Docker启动安装nacos（详情讲解，全网最细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 安装之前你需要准备一个mysql，当前安装方式是将数据持久化到数据库中的，这里的部署是单机模式 1、Docker 拉取镜像 docker pull nacos/nacos-server PS：这是拉取最新的nacos版本，如果需要拉取别的版本可以加：版本号（如：docker pull nacos/nacos-server:v2.2.0） 2、挂载目录 mkdir -p /mydata/nacos/logs/ #新建logs目录 mkdir -p /mydata/nacos/conf/	#新建conf目录 PS：这一步是添加映射文件夹，将宿主机的文件映射到nacos容器中 3、启动nacos并复制文件到宿主机，关闭容器 启动容器 docker run -p 8848:8848 --name nacos -d nacos/nacos-server 复制文件 docker cp nacos:/home/nacos/logs/ /mydata/nacos/ docker cp nacos:/home/nacos/conf/ /mydata/nacos/ 关闭容器 docker rm -f nacos PS：这一步启动nacos是为了将nacos里面的文件拷贝出到挂载目录中，这样我们就可以直接修改挂载目录中文件来映射到容器里面去了 4、mysql中创建nacos所需的表 mysql中新建一个库，名字可自定义，这里就用nacos-config从github中找到创建表的文件，在nacos-config库中执行，创建所需的表 5、再次启动nacos docker run -d --name nacos	-p 8848:8848 -p 9848:9848 -p 9849:9849 --privileged=true -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -v /mydata/nacos/logs/:/home/nacos/logs -v /mydata/nacos/conf/:/home/nacos/conf/ --restart=always nacos/nacos-server PS : 复制上面的语句执行失败，可以将上面的执行语句变成一行，如下，可直接复制执行 docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849 --privileged=true -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -v /mydata/nacos/logs/:/home/nacos/logs -v /mydata/nacos/conf/:/home/nacos/conf/ --restart=always nacos/nacos-server 语句讲解 docker run -d ： 启动容器 -d是后台启动并返回容器id的意思–name nacos ：为容器指定一个名称-p 8848:8848 -p 9848:9848 -p 9849:9849 ： 指定端口映射，注意这里的p不能大写，大写是随机端口映射–privileged=true ： 扩大容器内的权限，将容器内的权限变为root权限，不加的话就是普通用户权限，可能会出现cannot open directory-e JVM_XMS=256m ： 为jvm启动时分配的内存-e JVM_XMX=256m ： 为jvm运行过程中分配的最大内存-e MODE=standalone ： 使用 standalone模式（单机模式）,MODE值有cluster（集群）模式/standalone模式两种，MODE必须大写-v /mydata/nacos/logs/:/home/nacos/logs : 将容器的/home/nacos/logs目录挂载到 /mydata/nacos/logs-v /mydata/nacos/conf/:/home/nacos/conf/： 将容器的/home/nacos/conf目录挂载到 /mydata/nacos/conf–restart=always ：重启docker时，自动启动相关容器 注意事项 需要在防火墙开放相关端口，如果你是云服务器，开放安全组，下面提供相关语句 ## 开放端口8848 9848 9849 firewall-cmd --zone=public --add-port=8848/tcp --permanent firewall-cmd --zone=public --add-port=9848/tcp --permanent firewall-cmd --zone=public --add-port=9849/tcp --permanent ## 重启防火墙 firewall-cmd --reload ## 查看所有开启的端口 firewall-cmd --zone=public --list-ports PS：这里有点小问题，重启完防火墙之后，需要重启docker ## 重启docker systemctl restart docker 这里最容易犯错的就是挂载目录对应不上，可以看下自己语句中的-v 后面的目录是否映射正确，博主第一次安装的时候logs里面还有一个logs文件夹，conf里面还有个conf文件夹，导致出错 6、修改配置文件 主要修改的是application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9743053267088113953b31110573a9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36f09c93399ac3f037b8036bc132355/" rel="bookmark">
			【数据结构】C语言队列(详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言: 💥🎈个人主页:​​​​​​Dream_Chaser～ 🎈💥
✨✨专栏:http://t.csdn.cn/oXkBa
⛳⛳本篇内容:c语言数据结构--C语言实现队列
目录
一.队列概念及结构
1.1队列的概念
1.2队列的结构
二.队列的实现
2.1头文件
2.2链式队列的结构定义
2.3队列接口的定义
2.4初始化队列
2.5判断队列是否为空
2.6销毁队列
2.7队尾入队列
2.8队头出队列
2.9获取队列头部元素
2.10获取队列队尾元素
2.11获取队列中有效元素个数
2.12打印队列元素
Test.c
Queue.h
Queue.c
一.队列概念及结构 1.1队列的概念 队列：只允许 在一端进行插入数据操作，在 另一端进行删除数据操作的特殊线性表，队列具有 先进先出 FIFO(First In First Out) 入队列： 进行插入操作的一端称为 队尾 出队列： 进行删除操作的一端称为 队头 1.2队列的结构 二.队列的实现 队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低 2.1头文件 #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdbool.h&gt; #include&lt;stdlib.h&gt; 2.2链式队列的结构定义 typedef int QDataType; typedef struct QueueNode {	QDataType data; struct QueueNode* next; }QNode; typedef struct Queue { QNode* phead; QNode* ptail; int size; }Queue;//表示队列整体,一个是出数据，一个是入数据.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a36f09c93399ac3f037b8036bc132355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcaeaa575f8c54a3f01902e1bdc2aa9b/" rel="bookmark">
			【Spring&#43;SpringMVC&#43;Mybatis】SSM框架的整合、思想、工作原理和优缺点的略微讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀欢迎来到本文🚀
🍉个人简介：陈童学哦，目前学习C/C++、算法、Python、Java等方向，一个正在慢慢前行的普通人。
🏀系列专栏：陈童学的日记
💡其他专栏：C++STL，感兴趣的小伙伴可以看看。
🎁希望各位→点赞👍 + 收藏⭐️ + 留言📝 ​
⛱️万物从心起，心动则万物动🏄‍♂️
前言：SSM框架即是将Spring框架、SpringMVC框架、MyBatis框架整合使用。以简化在web开发中繁琐、重复的操作，让开发人员能够将精力专注于业务处理的开发上它是继SSH之后，目前比较主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。
SSM框架是由什么整合的呢 SSM框架是Spring、Spring MVC 、和Mybatis框架的整合，是标准的MVC模式。标准的SSM框架有四层，分别是dao层（mapper），service层，controller层和view层。使用Spring实现业务对象管理，使用Spring MVC负责请求的转发和视图管理，Mybatis作为数据对象的持久化引擎。
SSM中的Spring框架 Spring是一个轻量级Java开发框架，最早由Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。
SSM中的SpringMVC框架 Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。
SSM中的Mybatis框架 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。
SSM中的四层结构 标准的SSM框架有四层，分别是dao层（mapper），service层，controller层和view层。我们在使用SSM框架时需要知道各层都有什么作用，这样我们在搭建框架的时候才能更加得心应手、事半功倍。
持久层：dao层（mapper） Dao层主要是做数据持久层的工作，负责和数据库进行联络的一些任务在此封装，dao层的设计首先是dao的接口，配置数据源，以及有关数据库连接的参数在spring的配置文件中进行配置。
业务层：service层 service层实现业务的主要逻辑，是系统架构中体现核心价值的部分。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。
表现层：controller层 controller层主要负责具体的业务模块流程的控制，在此层要调用service层的接口来控制业务流程。
SSM框架的思想 SSM框架根据SpringMVC、Spring、MyBatis三者各自的特性及应用场景对其操作的的业务进行了分割，降低了耦合性。
1、Spring框架主要应用于请求的实际业务逻辑处理。2、SpringMVC框架主要应用于用户界面处理，接收用户请求以及展示请求处理结果。3、MyBatis主要应用于数据处理层，根据请求的处理过程的血药中对数据库进行操作。
SSM框架的工作原理 Spring Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。Spring的核心思想是IOC（控制反转），即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。
SpringMVC SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。
MyBatis MyBatis是对JDBC的封装，它让数据库底层操作变的透明。MyBatis的操作都是围绕一个sqlSessionFactory实例展开的。MyBatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。
页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。
SSM框架的优缺点 SSM框架有以下优点：
1、低耦合，高内聚。通过使用IOC容器，依赖注入等技术，SSM框架实现了代码之间的低耦合，提高了代码的可维护性和可扩展性。
2、简化开发。SSM框架提供了一系列的约定和配置，大大简化了Web应用程序的开发，同时也减少了冗余代码的编写。
3、易于测试。SSM框架对代码的低耦合性和高内聚性，使得单元测试和集成测试变得更加容易。
4、支持事务处理。MyBatis提供了数据库事务的管理，Spring提供了事务管理的支持，使得SSM框架可以方便地实现事务管理。
5、开源免费。SSM框架是开源框架，可免费使用，避免了因为框架使用费用而增加项目成本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcaeaa575f8c54a3f01902e1bdc2aa9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3ad4b4b855236898ac3248c4ce4c19/" rel="bookmark">
			探索小程序的世界(专栏导读、基础理论)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章导读 一、为什么要学习小程序开发1.1 低门槛1.2 市场需求1.3 创业机会1.4 技术发展趋势 二、专栏导读2.1 实战系列2.2 工具系列2.3 游戏系列2.4 插件系列 三、基础理论3.1 微信小程序简易教程框架组件API工具 开发者工具项目结构 3.2 app.json配置pageswindowtabbar 3.3 App.jsonLaunchonShowonHideonError注意事项 3.4 页面跳转与传参3.5 小程序JS与普通JS的差异小程序不是运行在浏览器中，所以没有DOM和BOM对象小程序的JS有一些额外的成员小程序的JS是支持CommonJS规范的 3.6 界面层的数据绑定特点使用运算 一、为什么要学习小程序开发 由于微信自身的强势社交属性，以及其对小程序的战略定位（连接人与服务）的前提下进行了持续的大力支持，截至2021年6月，微信官方宣布已经有超过300万个微信小程序。这个数字在不断增长，因为越来越多的开发者和企业选择在微信平台上开发和发布小程序。
1.1 低门槛 相比于传统的App开发，小程序开发门槛较低。你可以使用HTML、CSS和JavaScript等前端技术来开发小程序，而无需学习复杂的移动开发框架和语言。这使得学习小程序开发更加容易上手。
1.2 市场需求 小程序是近年来兴起的一种应用形式，受到了广大用户的喜爱。许多企业和个人都在寻求开发小程序来满足用户需求，因此学习小程序开发将增加你的就业机会和市场竞争力。
1.3 创业机会 小程序开发为创业者提供了一个低成本、快速验证创意的平台。你可以通过开发小程序来验证你的商业模式和产品想法，从而降低创业风险。
1.4 技术发展趋势 小程序作为一种新兴的应用形式，具有很大的发展潜力。随着技术的不断进步和用户需求的不断变化，小程序开发领域将会有更多的机会和挑战。学习小程序开发可以让你跟上技术发展的潮流，并为未来的发展做好准备。
二、专栏导读 微信小程序专栏地址点此访问
2.1 实战系列 基于Java+SpringBoot制作一个校园圈子小程序基于Java+SpringBoot制作一个宿舍报修小程序基于小程序制作一个ChatGPT聊天机器人基于Java+SpringBoot+微信小程序实现奶茶点单系统微信小程序完整项目实战(前端+后端)基于小程序+云开发制作一个文件传输助手小程序基于JavaSpringBoot+uniapp制作一个记账小程序基于Java+SpringBoot制作一个论坛小程序基于微信小程序+爬虫制作一个表情包小程序基于小程序+C#制作一个打卡小程序基于小程序+云开发制作一个菜谱小程序基于小程序+云开发制作一个租房小程序基于Java+SpringBoot制作一个考试答题小程序基于Java+SpringBoot制作一个旅游攻略小程序基于小程序制作一个超酷的个人简历使用小程序制作一个节日祝福生成器使用小程序制作一个时间管理小工具基于小程序+C#制作一个聊天系统基于小程序+C#制作一个小说阅读器使用小程序制作一个音乐播放器使用小程序制作一个核酸检测点查询工具基于小程序实现打卡功能基于小程序+C#实现聊天功能从零开始,开发一个电商微信小程序[前端+后端(c#)]微信小程序电子签名及图片生成基于Java+SpringBoot制作一个社区宠物登记小程序基于Java+SpringBoot制作一个学生公寓管理小程序基于Java+SpringBoot制作一个智能用电小程序 2.2 工具系列 使用小程序制作一个马赛克处理工具使用小程序制作一个世界杯球员识别工具使用小程序实现AI动漫脸特效使用小程序制作一个老照片修复工具，让追忆时光触手可及基于小程序实现人脸数量检测小程序实现文字情绪识别并生成参考回复基于小程序实现人脸识别对比基于小程序实现发送语音消息及转文字使用小程序+C#实现人脸、手势双重识别认证基于小程序实现透明背景人像分割用微信小程序给头像带上小旗帜一文读懂基于小程序的图像识别 2.3 游戏系列 飞翔的圣诞老人使用小程序制作一个足球拼图小游戏使用小程序制作一个2048小游戏使用小程序制作一个飞机大战小游戏使用小程序制作一个电子木鱼，功德+1基于小程序制作一个猜拳小游戏 2.4 插件系列 使用小程序+网页简易实现多客户端实时弹幕使用小程序实现图表(圆饼图、柱状图、折线图)小程序自定义底部导航栏使用小程序实现侧滑抽屉菜单特效使用小程序实现通讯录功能，首字母快捷导航小程序实现瀑布流布局的几种方式微信小程序实现秒杀、拼团、团购等效果小程序实现滑动删除微信小程序实现进度条微信小程序实现自定义弹窗组件微信小程序实现步骤条小程序实现图片上传、数量配置、预览、删除功能 三、基础理论 3.1 微信小程序 简易教程 框架 框架提供了白己的视图层描述语言 WXML和 WXSS，以及基于JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者更加方便的聚焦于数据与逻辑上。
组件 框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发，注意，所有组件与属性都是小写，以连字符-连接。
组件是视图层的基本组成单元。组件自带一些功能与微信风格的样式。一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。 API 框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。
工具 集成了开发调试、代码逻辑及程序发布等功能的官方开发者工具。
开发者工具 功能介绍编辑默认为编辑状态显示，下面的编译为手动编译功能，遇常情况下修改文件后保存会刷新界面显示调试编辑状态的菜单栏与浏览器的调试界面几乎相同，包括控制台、源码、网络等编译修改代码之后，如果没有设置自动检测制新可以在这里手动重新编译后台模拟程序运行到后台，进入后台时再次点击会进入前台执行缓存数据的本地缓存，可以进行清除缓存等操作 项目结构 文件名介绍utils公共脚本目录app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae3ad4b4b855236898ac3248c4ce4c19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133977dff1bfa35fcdd1ed8152987610/" rel="bookmark">
			Java数字转中文大写工具类（拿去即用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具类包括： 数字转中文大写形式，比如一百二十一数字转金额用的大写形式，比如：壹佰贰拾壹转金额形式，比如：壹佰贰拾壹整 package cn.hutool.core.convert; import cn.hutool.core.util.ArrayUtil; import cn.hutool.core.util.StrUtil; /** * 数字转中文类 **/ public class NumberChineseFormatterUtils { /** * 中文形式，奇数位置是简体，偶数位置是记账繁体，0共用 * 使用混合数组提高效率和数组复用 **/ private static final char[] DIGITS = {'零', '一', '壹', '二', '贰', '三', '叁', '四', '肆', '五', '伍', '六', '陆', '七', '柒', '八', '捌', '九', '玖'}; /** * 汉字转阿拉伯数字的 */ private static final ChineseUnit[] CHINESE_NAME_VALUE = { new ChineseUnit(' ', 1, false), new ChineseUnit('十', 10, false), new ChineseUnit('拾', 10, false), new ChineseUnit('百', 100, false), new ChineseUnit('佰', 100, false), new ChineseUnit('千', 1000, false), new ChineseUnit('仟', 1000, false), new ChineseUnit('万', 1_0000, true), new ChineseUnit('亿', 1_0000_0000, true), }; /** * 阿拉伯数字转换成中文,小数点后四舍五入保留两位.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/133977dff1bfa35fcdd1ed8152987610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df29b86246f101e6fed30edc2d167739/" rel="bookmark">
			Unity&#43;讯飞星火大模型&#43;Web api，实现二次元小姐姐AI聊天互动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简述 最近讯飞的星火大模型更新了2.0版本，增强了AI的语言生成能力。毕竟是国产大语言模型，我也尝试使用了一下星火大模型的应用广场，体验还是很不错的。应用广场提供了很多AI助手工具，也支持用户创建自己的AI助手，能力不局限于自然语言生成，也有一些图片生成工具、视频生成工具之类的，总的来说，还是很有意思的。
同时，星火大模型也提供有api服务，可以很方便的集成到自己的应用里。申请api应用的门槛也比较低，简单填写一些信息，就可以申请试用。试用审核大概半个多小时就结束了，官方提供的免费token数量还是比较可观。针对星火大模型V1.5版本以及V2.0版本，各提供了200万的token试用，非常的良心。我的AI二次元小姐姐项目里，使用chatgpt以及一些开源模型的方式，相对来说还是有一定使用门槛，而接入星火大模型门槛就很低了。
本文就简单介绍一下unity端集成星火大模型API的代码实现，让星火大模型驱动我们的AI二次元小姐姐，与大家聊天吧。
2.开通星火大模型服务 本节内容将简单介绍一下如何在讯飞星火大模型官网，申请试用星火大模型，并创建星火大模型的应用。
星火大模型官方地址：讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 (xfyun.cn)
在申请星火大模型服务之前，需要先注册讯飞的账户，使用手机号码验证就可以了，这里不多赘述。在星火大模型官方站点主页，找到【API测试】按钮，可以点击进入API试用申请的页面。
点击【API测试申请】，即可进入API测试申请界面，如图所示：
在API申请界面中，填写必填的信息。这里需要注意一下，申请API测试，需要创建一个讯飞的应用，我们可以填写一个自己实现申请号的应用ID，也可以在申请页面点击创建一个新的应用，创建应用成功之后，我们就能够获得应用的密钥，这个在后面的接口对接会使用的到。
申请提交之后，耐心等待官方审核即可。时间不会太久，我大概是半小时左右，就完成审批，拿到api的试用服务了。
3.对接API服务 星火大模型应用申请完成之后，我们就可以拿到应用的密钥。进入到讯飞开放平台的控制台界面，选择到新创建的星火大模型服务，我们就可以看到服务剩余的token数，以及应用的密钥信息了。这个页面可以切换查看V1.5和V2.0两个版本的token使用情况。
3.1 API对接流程 星火大模型的接口对接，考虑到跨平台的兼容性，这里选择采用web方式对接，根据官方文档的说明，我们首先需要调用鉴权接口，获取到接口授权，然后在使用websocket协议与服务端握手，websocket握手成功后，需要在60秒内发送请求。接口采用的是流式输出模式，需要对根据返回的数据判断，并拼接成完整的回复信息，大致流程如下如所示：
接下来，将描述一下具体的代码实现。
3.2 接口鉴权 根据官方文档的说明，开发者需要自行先在控制台创建应用，利用应用中提供的appid，APIKey， APISecret进行鉴权，生成最终请求的鉴权url，鉴权参数如下：
参数类型必须说明示例hoststring是请求的主机aichat.xf-yun.com(使用时需替换为实际使用的接口地址）datestring是当前时间戳，采用RFC1123格式，时间偏差需控制在300s内Fri, 05 May 2023 10:43:39 GMTauthorizationstring是base64编码的签名信息参考下方生成方式 以下是在unity端实现鉴权url的处理代码：
/// &lt;summary&gt; /// 获取鉴权url /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private string GetAuthUrl() { string date = DateTime.UtcNow.ToString("r"); Uri uri = new Uri(url); StringBuilder builder = new StringBuilder("host: ").Append(uri.Host).Append("\n").// Append("date: ").Append(date).Append("\n").// Append("GET ").Append(uri.LocalPath).Append(" HTTP/1.1"); string sha = HMACsha256(m_XunfeiSettings.m_APISecret, builder.ToString()); string authorization = string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df29b86246f101e6fed30edc2d167739/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/587/">«</a>
	<span class="pagination__item pagination__item--current">588/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/589/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>