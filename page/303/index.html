<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ebf0d6ffbcc5cb2abdd00c404c6d90/" rel="bookmark">
			【C&#43;&#43;】list模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页： Forcible Bug Maker
🔥专栏： STL || C++
目录 前言🌈list需要实现的结构和接口函数🔥List结点类🔥List迭代器类🔥List类==默认成员函数====Iterators迭代器获取====容量接口====List Access元素获取====List对象修饰接口====swap== 结语 前言 本篇博客主要内容：STL库中list的模拟实现。
实现list就和之前的vector和string大不相同了，vector和string的底层结构是顺序表，而list的底层是链表，学习list的底层实现，了解顺序表和链表的区别是至关重要的，如果对这部分内容不太了解，可以参考这篇博客：初阶数据结构-顺序表和链表（C语言）
本篇的list实现中，迭代器的实现是重难点，它不再和以前的实现一样，只是单纯的原生指针，而是一个迭代器模板类。希望大家在了解list迭代器的实现之后，能对STL库中容器的迭代器有着更深的认识。
🌈list需要实现的结构和接口函数 list建议在vector的实现基础上进行，同样涉及到了模板的使用，而且更为复杂。本篇list的模拟实现并不会将接口函数的声明和定义分离，函数体统一实现在模板类内部。我们在定义链表list之前需要两个结构体内容，一个是结点Node，另一个是迭代器ListIterator。
先来看看需要实现的接口函数：
#pragma once #include&lt;iostream&gt; #include&lt;cassert&gt; using namespace std; namespace ForcibleBugMaker { // List的结点类 template&lt;class T&gt; struct ListNode { ListNode(const T&amp; val = T()); ListNode&lt;T&gt;* _pPre; ListNode&lt;T&gt;* _pNext; T _val; }; //List的迭代器类 template&lt;class T, class Ref, class Ptr&gt; class ListIterator { typedef ListNode&lt;T&gt;* PNode; typedef ListIterator&lt;T, Ref, Ptr&gt; Self; public: ListIterator(PNode pNode = nullptr); ListIterator(const Self&amp; l); Ref operator*(); Ptr operator-&gt;(); Self&amp; operator++(); Self operator++(int); Self&amp; operator--(); Self&amp; operator--(int); bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ebf0d6ffbcc5cb2abdd00c404c6d90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a48c5119d4e6022dd463c4af67156cb/" rel="bookmark">
			Codeforces Round 950 (Div. 3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没写题解了，今天来写个题解。
A - 问题 Generator #include "bits/stdc++.h" using namespace std; #define int long long #define endl '\n' #define IOS ios::sync_with_stdio(0),cin.tie(0); #define all(x) x.begin(),x.end() #define pi pair&lt;int,int&gt; #define vi vector&lt;int&gt; #define si set&lt;int&gt; #define mi map&lt;int,int&gt; #define mc map&lt;char,int&gt; #define YES cout&lt;&lt;"Yes"&lt;&lt;endl; #define NO cout&lt;&lt;"No"&lt;&lt;endl; #define pb(x) push_back(x); #define fi first #define sc second #define is insert template&lt;class T&gt;bool chmin(T &amp;a, const T &amp;b) { if (b&lt;a) { a=b; return true; } return false; } template&lt;class T&gt;bool chmax(T &amp;a, const T &amp;b) { if (a&lt;b) { a=b; return true; } return false; } const int INF =1e18; void solve() { int n,m; cin&gt;&gt;n&gt;&gt;m; string s; cin&gt;&gt;s; map&lt;char,int&gt; mp; //int n=s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a48c5119d4e6022dd463c4af67156cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d9e64166ea7966a71f3b21c6d459ca/" rel="bookmark">
			大数据Spark面试冲击题 直拿offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简答题
1.Spark master使用zookeeper进行HA的，有哪些元数据保存在Zookeeper？
答：spark通过这个参数spark.deploy.zookeeper.dir指定master元数据在zookeeper中保存的位置，包括Worker，Driver和Application以及Executors。standby节点要从zk中，获得元数据信息，恢复集群运行状态，才能对外继续提供服务，作业提交资源申请等，在恢复前是不能接受请求的。另外，Master切换需要注意2点
1）在Master切换的过程中，所有的已经在运行的程序皆正常运行！因为Spark Application在运行前就已经通过Cluster Manager获得了计算资源，所以在运行时Job本身的调度和处理和Master是没有任何关系的！
2） 在Master的切换过程中唯一的影响是不能提交新的Job：一方面不能够提交新的应用程序给集群，因为只有Active Master才能接受新的程序的提交请求；另外一方面，已经运行的程序中也不能够因为Action操作触发新的Job的提交请求；
2.Spark master HA 主从切换过程不会影响集群已有的作业运行，为什么？
答：因为程序在运行之前，已经申请过资源了，driver和Executors通讯，不需要和master进行通讯的。
3.Spark on Mesos中，什么是的粗粒度分配，什么是细粒度分配，各自的优点和缺点是什么？
答：1）粗粒度：启动时就分配好资源， 程序启动，后续具体使用就使用分配好的资源，不需要再分配资源；好处：作业特别多时，资源复用率高，适合粗粒度；不好：容易资源浪费，假如一个job有1000个task，完成了999个，还有一个没完成，那么使用粗粒度，999个资源就会闲置在那里，资源浪费。2）细粒度分配：用资源的时候分配，用完了就立即回收资源，启动会麻烦一点，启动一次分配一次，会比较麻烦。
4.如何配置spark master的HA？
1)配置zookeeper
2)修改spark_env.sh文件,spark的master参数不在指定，添加如下代码到各个master节点
export SPARK_DAEMON_JAVA_OPTS="-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=zk01:2181,zk02:2181,zk03:2181 -Dspark.deploy.zookeeper.dir=/spark"
3) 将spark_env.sh分发到各个节点
4)找到一个master节点，执行./start-all.sh，会在这里启动主master,其他的master备节点，启动master命令: ./sbin/start-master.sh 5)提交程序的时候指定master的时候要指定三台master，例如
./spark-shell --master spark://master01:7077,master02:7077,master03:7077
5.Apache Spark有哪些常见的稳定版本，Spark1.6.0的数字分别代表什么意思？
答：常见的大的稳定版本有Spark 1.3,Spark1.6, Spark 2.0 ，Spark1.6.0的数字含义
1）第一个数字：1 major version : 代表大版本更新，一般都会有一些 api 的变化，以及大的优化或是一些结构的改变；
2）第二个数字：6 minor version : 代表小版本更新，一般会新加 api，或者是对当前的 api 就行优化，或者是其他内容的更新，比如说 WEB UI 的更新等等；
3）第三个数字：0
patch version ， 代表修复当前小版本存在的一些 bug，基本不会有任何 api 的改变和功能更新；记得有一个大神曾经说过，如果要切换 spark 版本的话，最好选 patch version 非 0 的版本，因为一般类似于 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26d9e64166ea7966a71f3b21c6d459ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876af010164a96d87b2e48c2ed9374aa/" rel="bookmark">
			opencv快速安装以及各种查看版本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装opencv并查看其版本，直接通过一个可执行文件实现。
#!/bin/bash wget https://codeload.github.com/opencv/opencv/zip/3.4 -O opencv-3.4.zip &amp;&amp; unzip opencv-3.4.zip &amp;&amp; cd opencv-3.4 &amp;&amp; \ mkdir build &amp;&amp; cd build &amp;&amp; \ cmake -D CMAKE_BUILD_TYPE=RELEASE \ -D PYTHON_DEFAULT_EXECUTABLE=/usr/bin/python \ -D PYTHON_INCLUDE_DIR=/usr/include/python3.6 \ -D PYTHON_INCLUDE_DIR2=/usr/include/x86_64-linux-gnu/python3.6m \ -D PYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so \ -D PYTHON3_NUMPY_INCLUDE_DIRS=/usr/lib/python3/dist-packages/numpy/core/include/ \ -D PYTHON3_EXECUTABLE=/usr/lib/python \ -D BUILD_opencv_python2=OFF \ -D CMAKE_INSTALL_PREFIX=/usr/local \ -D INSTALL_C_EXAMPLES=ON \ -D INSTALL_PYTHON_EXAMPLES=ON \ -D WITH_TBB=ON \ -D WITH_V4L=ON \ -D WITH_OPENGL=ON \ -D BUILD_EXAMPLES=ON .. &amp;&amp; make -j"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/876af010164a96d87b2e48c2ed9374aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f689d4171390b8f7ceaf352784e02e7/" rel="bookmark">
			wireshark查看流量图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击 菜单中的 统计 , 选择 IO 图表 项
勾选下面选项..
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb5486e3b61ad2ed79d9f657d6f0ced/" rel="bookmark">
			【机器学习】与【人工智能】的无限创意——【六一儿童节】的科技奇幻旅程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、机器学习与人工智能简介
二、六一儿童节的特殊意义
三、项目概述：智能绘画助手
四、技术栈和工具
五、数据准备
六、模型训练
1. 数据预处理
2. 构建和训练模型
七、智能绘画助手的实现
1. 搭建Flask应用
2. 客户端界面
八、扩展功能与优化
1. 数据增强
2. 增加更多类别
3. 提升模型性能
4. 增强用户交互体验
九、项目总结
十、未来展望
附录：完整代码
1. 数据处理和模型训练
2. Flask 后端
3. HTML 和 JavaScript 前端
每年的六一儿童节是孩子们期盼已久的节日，而随着科技的飞速发展，我们有机会利用前沿技术为孩子们带来更多的乐趣和知识。进入一个奇幻的科技世界，结合机器学习和人工智能技术，通过具体的项目实例，展示如何在六一儿童节为孩子们打造一个智能互动的学习和娱乐体验。
一、机器学习与人工智能简介 在开始我们的项目之前，先简单介绍一下机器学习和人工智能的基本概念。
机器学习是通过数据和算法，让计算机系统在没有明确编程的情况下自主学习和改进的技术。常见的机器学习任务包括分类、回归、聚类等。
人工智能（Artificial Intelligence, AI）是让计算机系统模拟人类智能的技术，包括感知、学习、推理和决策等能力。机器学习是实现人工智能的一种重要手段。
随着这些技术的发展，我们可以创造出各种智能应用，使生活变得更加便捷和有趣。而今天，我们将聚焦于如何利用这些技术为孩子们打造一个充满创意的六一儿童节。
二、六一儿童节的特殊意义 六一儿童节不仅是孩子们欢乐的节日，也是一个促进他们健康成长和全面发展的重要时刻。在这个节日里，家长和教育者们都希望能够通过各种活动激发孩子们的创造力、想象力以及对世界的好奇心。为了让这个节日更加特别，我们将探索如何结合机器学习和人工智能技术，为孩子们带来一个与众不同的六一儿童节体验。
三、项目概述：智能绘画助手 为了让孩子们在六一儿童节尽情发挥创意，我们将构建一个“智能绘画助手”应用。这个应用会利用机器学习和人工智能技术，根据孩子的简单线条或形状，自动生成复杂的图画，增加绘画的趣味性和互动性。
四、技术栈和工具 为了实现这个项目，我们将使用以下技术和工具：
Python：主要编程语言TensorFlow/Keras：深度学习框架OpenCV：计算机视觉库Flask：Web框架，用于构建应用接口HTML/CSS/JavaScript：前端开发技术 五、数据准备 智能绘画助手需要大量的训练数据来学习各种绘画风格和对象。我们将使用开源的绘画数据集，如Quick, Draw! 数据集，它包含了大量手绘的草图。
首先，我们需要下载并处理数据集：
import numpy as np import pandas as pd import os import cv2 import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb5486e3b61ad2ed79d9f657d6f0ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a71ae70327a311a604c183e8a9e851/" rel="bookmark">
			AI新时代——【深度学习】驱动的【AIGC大模型】与【机器学习】的创新融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.机器学习与人工智能的基础
1.机器学习的基本原理
2.人工智能的广泛应用
2.深度学习的崛起
1.深度学习的概念和原理
2.卷积神经网络（CNN）
3.循环神经网络（RNN）
3.AIGC大模型的创新
1.AIGC的概念和应用
2.代表性AIGC大模型
4.四者结合的应用实例
1.基于深度学习的图像生成
2.利用深度学习和AIGC大模型进行文本生成
5.分析与推导过程
1.模型训练与优化
2.性能评估与应用
6.未来展望与挑战
1.深度学习和AIGC大模型的发展方向
2.当前面临的挑战
7.结论
在当今的科技时代，人工智能（AI）已成为推动各行业变革的重要力量。从自动驾驶汽车到智能语音助手，AI技术正在改变我们生活和工作的方方面面。作为AI的核心，机器学习（ML）和深度学习（DL）技术不断取得突破。而近年来，AIGC（AI Generated Content）大模型的出现，更是为内容生成领域带来了前所未有的创新。
1.机器学习与人工智能的基础 1.机器学习的基本原理
机器学习是一种通过数据训练模型，从而实现自动化预测和决策的技术。机器学习的核心思想是通过统计学和计算算法，从大量数据中发现模式和规律，以此来进行预测或分类。常见的机器学习算法包括线性回归、决策树和支持向量机等。
线性回归是一种用于预测数值型数据的算法。它通过拟合一条直线来最小化预测值与实际值之间的误差，从而进行预测。线性回归模型简单易懂，但在处理复杂数据时可能表现不足。
以下是使用Python中的scikit-learn库实现线性回归的具体代码示例：
# 导入必要的库 import numpy as np import matplotlib.pyplot as plt from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score # 生成模拟数据 np.random.seed(0) X = 2 * np.random.rand(100, 1) y = 4 + 3 * X + np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9a71ae70327a311a604c183e8a9e851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f646e3a117e90a0763f400a33bf2a4/" rel="bookmark">
			Linux基础（2）基础命令与vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件的复制和移动 cp 拷贝文件和目录
cp file file_copy --&gt; file 是目标文件，file_copy 是拷贝出来的文件 cp file one --&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file cp file one/file_copy --&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy cp *.txt folder --&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下 -递归的拷贝，拷贝整个目录
基本语法：
cp [选项] 源文件 目标文件 常用选项包括：
-r 或 –recursive： 递归复制整个目录。
-p 或 –preserve： 保留源文件的属性，包括文件权限、所有者、组、时间戳等。
-f 或 –force： 强制复制，覆盖已存在的目标文件。
-i 或 –interactive： 交互式复制，提示是否覆盖已存在的目标文件。
-v 或 –verbose： 显示详细的复制过程。
-u 或 –update： 仅复制源文件中较新的文件到目标目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f646e3a117e90a0763f400a33bf2a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b619962127d3c571221200f31bb827c/" rel="bookmark">
			【MySQL】表的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌎表的基本操作 文章目录：
表的基本操作
创建查看表
创建表
查看表结构
表的修改
表的重命名
表的添加与修改
删除表结构
总结
前言：
在数据库中，数据表是存储和组织数据的基本单位，对于数据表的操作是每个程序员需要烂熟于心的技巧。
🚀创建查看表 ✈️创建表 如果我们需要在 当前数据库下 创建表，可以使用如下SQL指令：
CREATE TABLE [if not exits] table_name ( field1 datatype, field2 datatype, field3 datatype --注意最后一个不带有任何符号-- ) character set 字符集 collate 校验规则 engine 存储引擎; 注意事项：
field 表示列名 datatype 表示列的类型 character set 字符集，如果没有指定字符集，则以所在数据库的字符集为准 collate 校验规则，如果没有指定校验规则，则以所在数据库的校验规则为准 我们在数据库下新建一个表：
其中标蓝色框框的表示的是 数据的类型，后面我们会提。创建表时，不同的存储引擎创建的文件不同，比如我再任意创建一个表，不过这个表的存储引擎为MyISAM。使用这个搜索引擎创建的文件有 xxx.sdi 、xxx.MYD、xxx.MYI 三个文件。
✈️查看表结构 使用如下命令查看 当前数据库 中表结构：
SHOW TABLES; 这条SQL指令我们在上一篇已经说过了，直接用起来就行。如果用户需要查看具体的某张表，我们使用如下SQL语句：
DESC table_name; --查看指定表结构-- 比如，我们查看刚刚创建的user表：
除此之外，查看创建表时的创建语句，我们可以使用如下SQL指令：
SHOW CREATE TABLE table_name \G--\G可以用;代替，\G默认有美化功能-- 这样曾经创建表时对该表的操作也能一清二楚了（这些语句有可能会被SQL优化过）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b619962127d3c571221200f31bb827c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb234041530fd096f3a73a1d3e78dd3/" rel="bookmark">
			数据结构的归并排序（c语言版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.归并排序的基本概念 1.基本概念 归并排序是一种高效的排序算法,它采用了分治的思想。它的基本过程如下:
将待排序的数组分割成两个子数组,直到子数组只有一个元素为止。然后将这些子数组两两归并,得到有序的子数组。不断重复第二步,直到最终得到有序的整个数组。 2.核心思想
归并排序的核心是"分而治之"的思想。通过不断地将数组拆分成更小的子数组,直至子数组只有一个元素,然后再将这些有序的子数组合并起来,最终得到一个有序的数组。
与简单的冒泡排序或选择排序相比,归并排序的时间复杂度为O(nlogn),这使它能够高效地处理大规模的数据集。虽然它需要O(n)的额外空间来存储中间结果,但其优秀的时间复杂度使其成为处理大数据量排序问题的首选算法之一。
总的来说,归并排序是一种强大而高效的排序算法,它体现了分治策略在算法设计中的重要应用。如果您有任何其他问题,欢迎随时向我咨询。
3.优点 优点:
时间复杂度稳定:归并排序的时间复杂度为O(nlogn),不管输入数据的初始状态如何,时间复杂度都是稳定的。这使它能够高效处理大规模数据。
稳定排序:归并排序是一种稳定的排序算法,也就是说,当两个相等的元素出现时,它们在输出序列中的相对顺序与输入序列中的相对顺序一致。这对某些应用场景很重要。
并行计算友好:归并排序的"分而治之"特性使得它很容易并行化,在多核处理器上可以获得很好的性能提升。
4.缺点 缺点:
需要额外空间:归并排序需要额外的内存空间来存储中间结果,空间复杂度为O(n)。这可能成为一个瓶颈,尤其是在内存受限的环境中。
数据交换频繁:归并排序需要频繁地将数据从输入数组复制到临时数组,这在某些情况下可能会降低性能。
无法就地排序:归并排序无法在原数组上就地排序,需要使用额外的空间。这对于某些内存受限的场景可能是个问题。
二.归并排序的功能 归并排序的基本功能就是对一组数据进行排序。具体来说,它可以实现以下几个功能:
将无序的数组或列表排序为有序的数组或列表。归并排序可以将任意大小的输入集合有效地排序,包括大型数据集。
保持数据的相对位置关系。如果输入数据中存在相等的元素,归并排序会保留它们原有的相对顺序,这在某些应用场景中很重要。
支持并行计算。由于归并排序的"分而治之"特性,它非常适合在多核处理器上并行执行,从而获得大幅的性能提升。
可以用于外部排序。当数据量太大无法一次性装入内存时,可以采用外部排序的方式,先将数据划分成多个小块,然后使用归并排序分别对这些小块进行排序,最后合并这些有序块。
可以作为其他算法的子过程。归并排序常被用作其他算法的核心步骤,比如快速排序、外部排序等。
归并排序是一种通用且高效的排序算法,它在各种规模和类型的数据排序中都有重要应用。它的功能十分强大,能够满足绝大多数排序需求。
三.归并排序的代码实现 1.合并两个有序数组 定义三个索引变量 i, j, k，分别用来遍历左数组、右数组和目标数组。使用 while 循环比较左右数组当前元素的大小,将较小的元素依次添加到目标数组中。当左数组或右数组中还有剩余元素时,将它们依次添加到目标数组的末尾。 // 合并两个有序数组 void merge(int arr[], int left[], int left_size, int right[], int right_size, int size) { int i = 0, j = 0, k = 0; while (i &lt; left_size &amp;&amp; j &lt; right_size) { if (left[i] &lt;= right[j]) { arr[k++] = left[i++]; } else { arr[k++] = right[j++]; } } while (i &lt; left_size) { arr[k++] = left[i++]; } while (j &lt; right_size) { arr[k++] = right[j++]; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb234041530fd096f3a73a1d3e78dd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c02ef11ae22517ac65dc57475ea488/" rel="bookmark">
			20240606 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤖ChatGPT、Claude、Perplexity、Gemini 同时都宕机了！
- 6月4日，OpenAI 的 ChatGPT 遭遇“重大中断”，导致客户无法与这家超级实验室的聊天机器人正常对话。
- OpenAI 称于当天 UTC 17:00 解决了宕机问题。
- OpenAI 方面建议，“对于在 chatgpt.com 上使用 ChatGPT 页面的用户，可能需要执行「硬刷新」操作。而对于通过 Mac 应用程序或者我们移动（iOS/Android）应用软件上使用 ChatGPT 的朋友，则不会受到影响。”
- 导致同时宕机的可能原因：
基础设施问题: 这些 AI 模型依赖的基础设施出现大范围问题可能是罪魁祸首。这可能包括云服务提供商（例如 AWS、谷歌云平台或 Azure）出现故障，而这些服务商正是这些模型运行所依赖的。
互联网层面问题: 另一种可能性是互联网层面出现问题，例如大规模的 DNS 宕机或网络路由问题，这些问题会同时影响多个服务。此类问题会扰乱跨越不同地区连接服务器的稳定性。
因宕机导致的高流量: 也不排除最初一个服务（例如 ChatGPT）宕机，导致其他服务（Claude AI 和 Perplexity AI）突然流量激增，从而使它们的系统不堪重负并引发后续宕机。
🔗 “都是调用的 GPT？”ChatGPT、Claude、Perplexity、Gemini 同时都宕机了-CSDN博客 🎁面壁智能免费开放被斯坦福AI团队抄袭的模型！
- MiniCPM-Llama3-V2.5是8B体量的端侧多模态模型，超越Gemini Pro和GPT-4V，支持30多种语言。
- MiniCPM 和 MiniCPM-V 模型对学术研究开放，并允许商业使用，需遵守Apache2.0和《MiniCPM 模型社区许可协议》。
- MiniCPM-Llama3-V2.5具有SOTA的OCR能力，手机端高效运行，图像编码速度快150倍。
‎🔗 https://modelbest.feishu.cn/share/base/form/shrcnpV5ZT9EJ6xYjh3Kx0J6v8g‎‎
🎮Backseat AI：英雄联盟 AI 游戏伴侣 - 该助手能通过语音为玩家提供实时的游戏评论和建议，包括购买建议、对线策略等。
- 玩家可以在比赛中提出任何关于游戏的问题，并立即获得解答。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c02ef11ae22517ac65dc57475ea488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edd6f2a3d1ef83d6911dc633fdbafb6/" rel="bookmark">
			【hive】transform脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档地址：https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Transform
一、介绍二、实现1.脚本上传到本地2.脚本上传到hdfs 三、几个注意点1.脚本名不要写全路径2.using后面语句中，带不带"python"的问题3.py脚本Shebang：#!/usr/bin/env python4.通过约定增强脚本的通用性5.指定python执行包和第三方库路径6.python执行包tar包安装第三方库 一、介绍 和udf差不多的作用，支持用python实现。通过标准输入流从hive读取数据，内部处理完再通过标准输出流将处理结果返回给hive。实现流程上比udf要更简单灵活一些，只需要上传脚本=&gt;add file加载到分布式缓存=&gt;使用。
二、实现 先定义一个名为transform.py的脚本，将传入的两个字段值都+1。
#!/usr/bin/env python import sys for line in sys.stdin: try: x, y = map(float, line.strip().split('\t')) x += 1 y += 1 print('\t'.join(map(str, [x, y]))) except ValueError as e: print('\t'.join([r'\N'] * 2)) 上面对输入流按照\t分隔是因为hive中的数据在传递到py脚本时，多个字段间默认会用\t分隔拼接为字符串，并且空值null会被转为字符串\N。同样将处理结果返回给hive时，如果多个字段，为了hive能够正确解析，也需要用\t拼接输出，单独的\N在hive中也会被重新解释为null。
除了单独的\N会被重新解释为null外，还有一种情况也会被hive解释为null，就是脚本里返回的字段个数小于hive中接收的字段个数时，hive中多余的字段会被赋值为null。
1.脚本上传到本地 这里的本地指的是hive主服务hive server2所在的节点，也就是我们客户端连接的那个机器。
先上传到主服务机器下的某个路径：
# 文件上传路径 [root@node1 HiveLib]# readlink -e transform.py /root/HiveLib/transform.py 上传后通过add file命令将脚本添加到分布式缓存，之后就可以直接使用了。
-- 添加到分布式缓存 add file /root/HiveLib/transform.py; -- 创建一个临时表测试执行 with `table` as ( select '1' as id, '1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edd6f2a3d1ef83d6911dc633fdbafb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83c77cdc8127e8479536d41ec8f66a9/" rel="bookmark">
			数据结构——(java版)包装类与泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 包装类1.1 包装类的概念1.2 装箱/装包1.3 拆箱/拆包1.4 一个面试题： 二 泛型2.1 什么是泛型？2.2 泛型的使用2.3 泛型的上界2.4 泛型实现Comparable接口2.5 擦除机制另外： 一 包装类 1.1 包装类的概念 在java中基本数据类型并不继承于Object，为了在泛型代码中支持基本数据类型，对每一个基本数据类型都对应了一个包装类。
如图所示，除int类型与char类型外，其余的包装类名均是数据类型名首字母大写！ 1.2 装箱/装包 装箱是指将基本数据类型的值转换成包装类类型 进行装箱的方法：valueOf int a = 10; //装箱成Integer类型 Integer i = Integer.valueOf(a); System.out.println(i); Integer i2 = 10; //隐式装箱 System.out.println(i2); 隐式装箱的原理：
如图所示：第一个valueOf方法是我们自己调用的
而第二个valueOf方法是系统默认调用的，即在隐式装箱时，系统默认调用了valueOf方法！
能否装箱成Double封装类？ int a = 10; Double double1 = Double.valueOf(a); 总结：即使不是对应的包装类，也可以进行装箱。 1.3 拆箱/拆包 拆箱即将数据从包装类类型转换成基本数据类型 拆箱的方法：intValue()方法 Integer a3 = 10; int i1 = a3.intValue(); //拆箱 int i2 = a3; //自动拆箱 // 观察本质实现，实际上是调用了intValue()方法.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e83c77cdc8127e8479536d41ec8f66a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8441bb104c028961e66cf5e45c7feff/" rel="bookmark">
			Java——基础快速过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.注释，标识符，关键字 1.1注释 单行注释：// 注释内容（用的最多）
多行注释：/* 注释内容*/（不推荐）
文档注释： /** 文档注释 */（常见于方法和类之上描述方法和类的作用)，可以被javadoc工具解析，生成一套以网页文件形式体现的程序说明文档
注释快捷键：
单行注释：Ctrl+/
多行注释：Ctrl+Shift+/
文档注释：/**+回车
取消注释快捷键：单行注释和多行注释与注释快捷键相同，文档注释选中删除就行
注意：
1. 多行注释不能嵌套使用
2. 不论是单行还是多行注释，都不参与编译，即编译之后生成的.class文件中不包含注释信息。
注释规范：
1. 内容准确: 注释内容要和代码一致, 匹配, 并在代码修改时及时更新.
2. 篇幅合理: 注释既不应该太精简, 也不应该长篇大论.
3. 使用中文: 一般中国公司都要求使用中文写注释, 外企另当别论.
4. 积极向上: 注释中不要包含负能量(例如 领导 SB 等).
1.2标识符 硬性规则：
标识符中可以包含：字母、数字以及 下划线和 $ 符号等等。 注意：标识符不能以数字开头，也不能是关键字，且严格区分大小写。
软性建议：
类名：每个单词的首字母大写(大驼峰)
方法名：首字母小写，后面每个单词的首字母大写(小驼峰)
变量名：与方法名规则相同
定义标识符时尽量少用$符，能不用就不用，避免不必要的麻烦
1.3关键字 2.数据类型与变量 数据类型分为8种基本数据类型和引用数据类型
8种基本数据类型：
注意：
1.不论是在16位系统还是32位系统，int都占用4个字节，long都占8个字节
2.整形和浮点型都是带有符号的 整型默认为int型，浮点型默认为double
3.字符串属于引用类型
变量：
语法格式：
数据类型 变量名 = 初始值; 注意事项：
1. int不论在何种系统下都是4个字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8441bb104c028961e66cf5e45c7feff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f51387cb2b4fe8abc29ff346e83e47/" rel="bookmark">
			ClickHouse内幕（1）数据存储与过滤机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲述ClickHouse中的数据存储结构，包括文件组织结构和索引结构，以及建立在其基础上的数据过滤机制，从Part裁剪到Mark裁剪，最后到基于SIMD的行过滤机制。
数据过滤机制实质上是构建在数据存储格式之上的算法，所以在介绍过滤机制前先介绍下ClickHouse中数据存储格式。
PS：本文基于ClickHouse v24.1
一、数据存储的目录结构 ClickHouse数据存储在目录结构上采用大数据系统常见的分区，然后分区内在进行细分文件的方式。
表中的数据首先按照分区键被划分为多个分区，分区键常采用日期的方式，比如下图中按照月份分区。每次数据批量插入形成一个最小的存储单元，ClickHouse中称为Part，Part归属于某一个分区。
﻿ClickHouse中一个表的所有分区的所有Part放在同一个目录中，Part所属的分区可以根据Part名进行区分，Part的命名方式如下：
partition-id _ min-id _ max-id _ level Part目录内部文件组织形式如下：
primary.idx - 是主键索引文件，记录了每个Mark对应的主键索引值，整个数据集一个.idx文件
[Column].mrk - 记录Mark(Mark在索引结构中介绍)对应的数据在数据文件（.bin文件）中的offset，用于根据Mark定为到数据位置，每个列一个.mrk文件。
[Column].bin - 真实数据文件，每个列一个.bin文件
checksums.txt - part checksum文件，用于校验数据完整性
columns.txt - 元数据，记录列名以及数据类型
count.txt - 元数据，记录该Part总行数，可以用于加速count(*)查询
partition.dat - 分区表达式
minmax_[Column].idx - 某一个列的最大最小值，可以用于加速查询，分区键固定有一个最大最小索引，用于分区裁剪
statistics_(column_name).stat - 列的统计信息，用于查询加速
二、索引结构 每个part形成一个完整的索引结构，整体上Clickhouse的存储是列式的，每个列单独存储（compact模式将多个文件合并成了一个，但本质上是一样的）。Clickhouse索引的大致思路是：首先根据索引列将整个数据集进行排序，这点类似MySQL的联合索引；其次将排序后的数据每隔8192行选取出一行，记录其索引值和序号，并形成稀疏索引，这个序号在Clickhouse中序号被称作Mark，也就是说Mark表示一组数据。
下图是一个二维表（date, city, action）的索引结构，其中（date,city）是索引列，整个part文件的宏观结构如下：
﻿﻿那么查询如何使用索引呢？以下查询为例：
select count(distinct action) where date=toDate(2020-01-01) and city=’bj’ 1.查找primary.idx并找到对应的Mark集合（即数据block集合）
2. 对于要读取的每个列根据.mrk文件定位到Mark对应在数据文件.bin中的数据offset
3.读取到对应的数据，供后续计算
以上为宏观步骤，下面会介绍其具体原理。
三、何时使用索引 在SQL编译阶段，初始化执行Pipeline的时候，ClickHouse会分析待查询的数据，目标是解析出需要读取哪些Part的哪些Mark列表。解析结果如下所示的AnalysisResult。在真正执行的时候，Scan算子直接读取这些Mark列表对应的数据。
struct AnalysisResult { RangesInDataParts parts_with_ranges;	// 最终要扫描的Part列表，以及每个Part的扫描范围（range） Names column_names_to_read;	// 需要读取那些列 // 以下是一些统计信息	UInt64 total_parts = 0;	// Parts总数 UInt64 selected_parts = 0;	// 命中的Part数量 UInt64 selected_ranges = 0;	// 命中的range数量 UInt64 selected_marks = 0;	// 命中的marks总数 UInt64 selected_rows = 0;	// 命中的marks包含的总数据行数 }; 关键堆栈：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f51387cb2b4fe8abc29ff346e83e47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5504aad56f2365011b0816045bf47bd5/" rel="bookmark">
			超级详细Spring AI运用Ollama大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型工具Ollama 官网:https://ollama.com/
Ollama是一个用于部署和运行各种开源大模型的工具;
它能够帮助用户快速在本地运行各种大模型，极大地简化了大模型在本地运行的过程。用户通过执行几条命令就能在本地运行开源大模型，如Lama 2等;
综上，Ollama是一个大模型部署运行工具，在该工具里面可以部署运行各种大模型，方便开发者在本地搭建一套大模型运行环境;
下载:https://ollama.com/download
下载Ollama
说明:Ollama的运行会受到所使用模型大小的影响;
1、例如，运行一个7B(70亿参数)的模型至少需要8GB的可用内存(RAM)，而运行一个13B(130亿参数)的模型需要16GB的内存，33B(330亿参数)的型需要32GB的内存;
2、需要考虑有足够的磁盘空间，大模型的文件大小可能比较大，建议至少为Ollama和其模型预留50GB的磁盘空间3、性能较高的CPU可以提供更好的运算速度和效率，多核处理器能够更好地处理并行任务，选择具有足够核心数的CPU:
4、显卡(GPU):Ollama支持纯CPU运行，但如果电脑配备了NVIDIA GPU，可以利用GPU进行加速，提高模型的运行速度和性能;
命令行使用ollama 打开终端，输入 ollama -h,查看到所有的命令
service ollama start启动allama
输入ollama -v查看当前版本，能输出版本则安装成功
运行模型单行对话 拉取并运行llama2模型
ollama run llama2
直接输入该命令会检查目录下是否有该模型，没有会自动下载，下载好后自动运行该模型
其他模型见library (ollama.com)
# 查看 Ollama 版本 ollama -v # 查看已安装的模型 ollama list # 删除指定模型 ollama rm [modelname] # 模型存储路径 # C:\Users\&lt;username&gt;\.ollama\models ollama run qwen:0.5b
默认Ollama api会监听11434端口，可以使用命令进行查看netstat -ano |findstr 114341
//加依赖 &lt;dependency&gt; &lt;groupld&gt;org.springframework,ai&lt;/groupld&gt; &lt;artifactld&gt;spring-ai-ollama-spring-boot-starter&lt;/artifactld&gt; &lt;/dependency&gt; //写代码 注入OllamaChatClient @Resource private OllamaChatClient ollamaChatClient, //调用call方法 ollamaChatClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5504aad56f2365011b0816045bf47bd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b806438fbabc532eff040a0266d900/" rel="bookmark">
			【C语言】结构体（及位段）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好！感谢支持孔乙己的新作，本文就结构体与大家分析我的思路。
希望能大佬们多多纠正及支持 ！！！
个人主页：爱摸鱼的孔乙己-CSDN博客 欢迎 互粉哦🙈🙈！
目录
1. 声明结构体
1.1. 结构体的声明
1.2. 结构体变量的创建与初始化
1.3. 结构体的特殊声明
1.4. 结构体的自引用
2. 结构体内存对齐
2.1. 对齐规则
2.1.1. 常规内存对齐
2.1.2. 嵌套结构体内存对齐
2.2. 为什么存在结构体对齐
2.2.1. 平台原因（移植原因）
2.2.2. 性能原因
2.2.3. 改善方法
2.3. 修改默认对齐数
3. 结构体实现传参
4 . 位段
4.1. 什么是位段
4.2. 位段的内存分配
4.3. 位段的跨平台问题
4.4. 位段的应用
4.5. 位段注意事项
1. 声明结构体 Leading ~~ 结构体（struct）是一种用户自定义的数据类型，它可以包含多个不同数据类型的成员变量，这些成员变量可以根据需要进行组合，形成一个新的数据类型。结构体可以用来表示现实世界中的复杂数据结构，比如表示一个学生或者一辆车的信息等。
1.1. 结构体的声明 结构体是⼀些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。 例如，描述一个学生的信息：
struct student { char name[20];//姓名 int age;//年龄 char sex[9];//性别 char number[20];//学号 }; 其中，包含学生的姓名、年龄、性别、学号这些字符数组，整形数据等等不同数据类型的成员变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b806438fbabc532eff040a0266d900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d724b5fcc0207d3a427c9160987710e4/" rel="bookmark">
			QT4-QT5升级（3）GBK-UTF-8-乱码“常量中有换行符”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乱码有两种：我命名为汉字乱码+菱形乱码如下：
1.文件编码为： GB2312
打开编码： GB2312
编译后： QString 部分字符串 常量中有换行符 char * 部分字符串 常量中有换行符 在错误字符后添加“11”后编译成功：
文件编码格式：GB2312
debug命令：无/utf-8
QString:菱形乱码
char*： 正常
对于菱形乱码：先把文件编码改成UTF-8,再修改编译过程中的错误。
2.文件编码为： UTF-8
打开编码： UTF-8
debug命令： 无/utf-8
编译后： QString 部分字符串 此字符不允许在标识符中使用 char * 部分字符串 常量中有换行符 修改可编译后：
原始文件编码为： UTF-8
打开编码： UTF-8
debug： QString 部分字符串 不识别 比如“表”
char * 汉字乱码 对于 汉字乱码：先把文件编码改成GB2312,再修改编译过程中的错误。
文件编码转换用notepad
结论：
如果用的变量是QString 文件用UTF-8编码
如果用的变量是char* 文件用GB2312编码
对于UTF-8 下 QString 不识别的字符：可以用英文替换，或者换汉字
对于GB2312 char* 不识别的字符: 替换掉
notes：
1.“-＞“: 非函数声明符后不允许尾随返回类型
2.VS2019 创建文件时：编码为GB2312,
编译时：UTF-8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d724b5fcc0207d3a427c9160987710e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23cfa0219c6143d0eadcff3f6f1e18d9/" rel="bookmark">
			【云原生】Kubernetes----Ingress对外服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
一、K8S对外方式
（一）NodePort
1.作用
2.弊端
3.示例
（二）externalIPs
1.作用
2.弊端
3.示例
（三）LoadBalancer
1.作用
2.弊端
（四）Ingress
二、Ingress的基本概念
（一）基本概念
（二）Ingress组成
1.ingress
2.ingress-controller
3.关系归纳
（三）Ingress的工作原理
（四）访问流程
三、配置Ingress规则
（一）ingress暴露服务方式
（二）方式二搭建
1.获取资源
1.1 获取配置文件
1.2 获取镜像资源
2.修改ClusterRole资源配置
3.修改nginx-ingress-controller配置
4.创建资源
4.1 创建ingress-controller
4.2 创建pod与service
5.创建ingress规则
6.客户端访问
（三）方式三搭建
1.清空环境
2.获取文件
3.创建代理资源
3.1 创建nginx-ingress-controller资源
3.2 创建service资源
4.创建访问资源
4.1 创建Deployment
4.2 创建service
4.3 创建Ingress规则
5.使用客户端进行访问
四、虚拟主机
（一）创建pod资源
（二）创建service资源
（三）创建ingress规则
（四）客户端访问
五、HTPPS代理
（一）获取SSL证书
（二）创建Kubernetes Secret
（三）创建pod资源
（四）创建service
（五）创建ingress规则
（六）客户端访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23cfa0219c6143d0eadcff3f6f1e18d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7a8e0cd116a464246ad7f53bee0330/" rel="bookmark">
			屌炸的文本转语音AI——ChatTTS本地部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 本地部署准备 1.1 下载 ChatTTS 代码
将代码库拷贝到本地，注意要在英文目录下 1.2 通过 modelscope 下载ChatTTS模型 2. 验证
2.1用 jupyter 验证
2.2 编写ttsollama.py代码
2.3 运行 ttsollama.py 2024年5月28日 开源的 ChatTTS 截至 6月5日 20.2k 星
ChatTTS：开源领域最强的文本到语音转换（TTS）模型！它允许用户将文本转换为语音。该模型主要面向学术研究和教育目的，不适用于商业或法律用途。它使用深度学习技术，能够生成自然流畅的语音输出，适合研究和开发语音合成技术的人员使用。
带有情绪控制语音堪比真人，可以方便制作有声小说，如果应用在线对话中很难分辨是否是真人。
在线体验地址：https://huggingface.co/2Noise/ChatTTS
1. 本地部署准备 国内镜像库地址：https://gitee.com/vscene/ChatTTS
1.1 下载 ChatTTS 代码 将代码库拷贝到本地，注意要在英文目录下 &gt; git clone https://gitee.com/vscene/ChatTTS
&gt; cd ChatTTS
&gt; dir 1.2 通过 modelscope 下载ChatTTS模型 运行 python 并输入如下代码, 或者创建 download.py 并输入如下代码( python download.py进行下载)
from modelscope import snapshot_download
model_dir = snapshot_download('pzc163/chatTTS')
如果报错:ModuleNotFoundError: No module named 'modelscope'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d7a8e0cd116a464246ad7f53bee0330/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/302/">«</a>
	<span class="pagination__item pagination__item--current">303/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/304/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>