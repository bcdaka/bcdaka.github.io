<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.133.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大咖的博客">
		<meta property="og:url" content="https://bcdaka.github.io/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="编程大咖">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b90044f72891ba64c49aeaafe075c0/" rel="bookmark">
			Python 数据可视化，怎么选出合适数据的图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据可视化最佳实践 1. 引言：为什么数据可视化最佳实践很重要 数据可视化是数据分析和决策过程中不可或缺的一部分。通过有效的可视化，复杂的数据可以转化为易于理解的信息，从而帮助观众快速做出正确的判断。然而，糟糕的可视化可能会导致误解，甚至误导决策。因此，掌握数据可视化的最佳实践显得尤为重要。
2. 选择合适的图表类型 不同的数据类型需要不同的图表类型来进行有效展示。选择合适的图表类型可以帮助观众更好地理解数据。
类别数据：柱状图、饼状图时间序列数据：折线图、面积图分布数据：直方图、箱线图关系数据：散点图、气泡图成分数据：堆叠柱状图、百分比堆叠图 在选择图表类型时，应考虑数据的性质和你希望传达的信息。例如，使用折线图展示趋势，使用散点图展示相关性。
3. 图表设计原则 设计图表时，遵循一些基本原则可以使图表更加清晰易懂。
简洁明了：避免不必要的装饰元素，确保图表传达的信息直观清晰。避免图表误导：确保数据轴的比例合理，不夸大或缩小数据的差异。使用合适的颜色和标签：颜色应易于区分且不冲突，标签应准确且简洁明了。 4. 常见错误及其避免 在创建数据可视化时，一些常见的错误可能会影响图表的效果。
过度设计：过多的颜色、字体和装饰元素会分散观众的注意力，降低图表的清晰度。数据失真：不正确的比例或选择不当的图表类型可能会导致数据误导。色彩选择不当：色彩搭配不合理可能导致观众难以区分不同类别的数据，或者使部分数据显得过于突出。 5. 实战案例：优化一个现有图表的设计 在这个部分，我们将展示如何优化一个现有的图表设计。以下是一个初始的柱状图示例，以及优化后的版本。
初始版本：
import matplotlib.pyplot as plt # 初始版本的柱状图 categories = ['A', 'B', 'C', 'D'] values = [4, 7, 1, 8] plt.bar(categories, values, color='red') plt.title('Initial Bar Chart') plt.show() 优化版本：
# 优化后的柱状图 plt.bar(categories, values, color='skyblue') plt.title('Optimized Bar Chart') plt.xlabel('Category') plt.ylabel('Value') plt.grid(True, axis='y', linestyle='--', alpha=0.7) plt.show() 在优化后的版本中，我们使用了更柔和的颜色，添加了轴标签和网格线，使图表更易于解读。
6. 总结 掌握数据可视化的最佳实践有助于创建既美观又有效的图表。通过选择合适的图表类型，遵循简洁明了的设计原则，并避免常见错误，你可以显著提高数据可视化的质量。
希望本文提供的建议和示例能帮助你在数据可视化的过程中做出更好的决策，提升图表的表现力和清晰度。如果你对数据可视化有更多的兴趣，欢迎持续关注我们的 Python 绘图专栏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b90044f72891ba64c49aeaafe075c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4868e4ed29dd06e2d9c688a7b3a60bc/" rel="bookmark">
			css实现水滴效果图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果图： &lt;template&gt; &lt;div style="width: 100%;height:500px;padding:20px;"&gt; &lt;div class="water"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return {}; }, watch: {}, created() {}, methods: {}, }; &lt;/script&gt; &lt;style lang='less' scoped&gt; .water { width: 300px; height: 300px; box-shadow: 10px 20px 30px 0px rgba(0, 0, 0, 0.2) inset, 10px 20px 30px rgba(0,0,0,0.3), 15px 15px 30px rgba(0,0,0,0.05), -15px -15px 30px rgba(255,255,255,0.8) inset; border-radius: 59% 41% 71% 29% / 54% 43% 57% 46% ; margin: 0 auto; margin-top:300px; /** box-sizing 用于控制元素的盒模型，决定了元素的宽度和高度是如何计算的； 默认值是content-box, 元素的宽度和高度只包含内容区域， border-box , 元素的宽度和高度包含内容区域，内边距，边框； */ box-sizing: border-box; animation: action 3s linear infinite; } @keyframes action { 0%{ border-radius: 59% 41% 71% 29% / 54% 43% 57% 46% ; } 25%{ border-radius:43% 57% 55% 45% / 63% 37% 63% 37% ; } 50%{ border-radius:37% 63% 39% 61% / 69% 26% 74% 31% ; } 75%{ border-radius:53% 47% 44% 56% / 50% 58% 42% 50% ; } 100%{ border-radius: 59% 41% 71% 29% / 54% 43% 57% 46% ; } } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd7d26c960fd2bb7c96e685aa381ed2/" rel="bookmark">
			基于Python爬虫&#43;机器学习的长沙市租房价格预测研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵‍♂️ 个人主页：@艾派森的个人主页
✍🏻作者简介：Python学习者
🐋 希望大家多多支持，我们一起进步！😄
如果文章对你有帮助的话，
欢迎评论 💬点赞👍🏻 收藏 📂加关注+
写在前面 最近有粉丝问我“什么 AI 工具好”，其实还是得看自己的使用场景，很难说有最好用，只有最合自己胃口的。对我来说，好用的 AI 工具满足几个标准：
使用方便。用的时候不要太麻烦，最好一键就能启用功能丰富。这样可以覆盖绝大多数的使用场景性能一流。决定上限价格实惠。这很重要 以前我用 ChatGPT 最多，主要是当时没别的可选，就它最厉害，但现在大模型之间的性能差距越来越小，所以慢慢地其他工具就一块用了，比如 Claude、Kimi，AI 搜索的 Perplexity，综合起来看，我目前用得频率最高、也是最顺手的 AI 工具反而是一个浏览器插件“灵办 AI”。功能挺多，该有的都有，比如：
AI 对话翻译阅读（网页+文档）联网搜索AI 写作..... 感兴趣的小伙伴点击下方链接即可免费注册使用：（推荐使用电脑）
https://ilingban.com/browser_extension/?from=aps
目录
1.项目背景
2.数据集介绍
3.技术工具
4.实验过程
4.1导入数据
4.2数据预处理
4.3数据可视化
4.4特征工程
4.5构建模型
4.6特征重要性
4.7模型预测 源代码
1.项目背景 在当今数字化快速发展的时代，数据已成为驱动决策和预测未来的重要力量。房地产市场作为国民经济的重要组成部分，其价格的波动不仅直接影响着居民的生活水平，也反映了国家宏观经济的运行状况。长沙市，作为湖南省的省会城市，近年来随着经济的快速发展和城市化进程的加速，租房市场也呈现出蓬勃发展的态势。
然而，租房价格的波动受到多种因素的影响，包括供求关系、地理位置、房屋类型、装修状况、交通便捷性、周边设施等。这些因素之间相互交织，形成了复杂的动态系统，使得租房价格的预测变得尤为困难。传统的预测方法，如基于经验或简单统计的预测，往往难以准确反映市场变化，且难以适应复杂多变的市场环境。
为了更准确地预测长沙市租房价格，本研究将采用基于Python爬虫和机器学习的方法。Python爬虫技术可以从互联网上大量抓取相关的租房数据，包括房源信息、价格、地理位置、房屋类型等，为后续的机器学习模型提供丰富的数据基础。而机器学习技术则可以通过对大量数据的分析和学习，自动发现数据中的规律和模式，从而实现对租房价格的准确预测。
具体来说，本研究将分为以下几个步骤：首先，利用Python爬虫技术从各大租房网站和平台上抓取相关的租房数据；其次，对抓取的数据进行清洗、预处理和特征工程，提取出与租房价格相关的关键特征；然后，选择合适的机器学习算法（如线性回归、决策树、随机森林、神经网络等），构建租房价格预测模型；最后，通过模型训练和验证，不断优化模型参数，提高预测精度。
本研究旨在通过Python爬虫和机器学习技术的结合，实现对长沙市租房价格的准确预测，为政府决策、房地产开发商、租赁企业和租户等提供有价值的参考信息。同时，本研究也将为机器学习在房地产价格预测领域的应用提供新的思路和方法，具有一定的理论意义和实践价值。
2.数据集介绍 本实验数据集来源于房天下官网，通过使用python爬虫获取了长沙市的租房数据
获取了房屋租金、交付方式、房屋户型、房屋面积、装修情况、校区、地址、配套设施、房源亮点等字段信息，具体如下图所示。 3.技术工具 Python版本:3.9
代码编辑器：jupyter notebook
4.实验过程 4.1导入数据 导入数据分析的第三方库并加载数据集
查看数据大小
查看数据基本信息
查看数据描述性统计
4.2数据预处理 统计缺失值情况
发现个别变量存在少量或大量缺失值
这里我们先直接删除“楼层”和“距地铁距离”这两个变量（因为这两个变量缺失值较多），最后统一删除缺失值
处理“房屋租金”变量，只提取出金额数值
处理房屋面积，只提取出数值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd7d26c960fd2bb7c96e685aa381ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f0f2b1a5d384d74475e55cf01512df/" rel="bookmark">
			算法：魔法字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1️⃣要求： 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。
实现 MagicDictionary 类：
MagicDictionary() 初始化对象void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 示例：
输入 ["MagicDictionary", "buildDict", "search", "search", "search", "search"] [[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]] 输出 [null, null, false, true, false, false] 解释 MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict(["hello", "leetcode"]); magicDictionary.search("hello"); // 返回 False magicDictionary.search("hhllo"); // 将第二个 'h' 替换为 'e' 可以匹配 "hello" ，所以返回 True magicDictionary.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f0f2b1a5d384d74475e55cf01512df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b76b91b1e5c6b8e7817c665738a6c50/" rel="bookmark">
			【C&#43;&#43;】哈希(unordered_set、unordered_map)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
unordered系列关联式容器 unordered_set的使用
unordered_map的使用
底层结构
哈希概念
哈希冲突
哈希冲突解决 闭散列
线性探测
插入
扩容
开散列
插入
扩容
前言 💬 hello! 各位铁子们大家好哇。
今日更新了哈希的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
unordered系列关联式容器 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时时间复杂度为O(logN)。在C++11中，STL又提供了4个 unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同， 查询时的时间复杂度为O(1)。
unordered_set的使用 unordered_set、unordered_map跟set和map的使用差不多，只是unordered是无序的，且迭代器是单向的。
unordered_map的使用 unordered_map也是无序的。
unordered_map是存储键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部,unordered_map没有对按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。 unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭 代方面效率较低。unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问 value。 底层结构 unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。
哈希概念 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素 时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即 O(logN)，搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立 一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
当向该结构中：
插入元素：根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放搜索元素：对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置 取元素比较，若关键码相等，则搜索成功 该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称 为哈希表(Hash Table)(或者称散列表) 总结：
哈希思想：值--存储位置建立映射关系。
哈希表：哈希思想实现的数据结构。
例如：数据集合{1，7，6，4，5，9}；
哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。
用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快
哈希冲突 不同关键字通过相同哈希函数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。
哈希冲突解决 解决哈希冲突两种常见的方法是：闭散列和开散列 闭散列 闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有 空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。 线性探测 线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。 插入 通过哈希函数获取待插入元素在哈希表中的位置如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突， 使用线性探测找到下一个空位置，插入新元素 删除 采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素 会影响其他元素的搜索。因此线性探测采用标记的伪删除法来删除一个元素。 如上图，如果采用的是物理删除元素。遇到空就停止，查找31时，可以正常找到。当删除55后，再去找31，就找不到了，因为原本55的位置现在是空，这样就造成31在，但是找不到的情况。所以采用标记法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b76b91b1e5c6b8e7817c665738a6c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e633ee39f0c114216d55b90b3c008d/" rel="bookmark">
			移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——5.string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符串相乘 . - 力扣（LeetCode）
思路：
1.如果两个串有一个首元素为‘0’，则直接返回‘0’
2.设置两层循环，内层第一次循环 用于str插入初始数据
（num2 的各个元素和num1 的最后一个元素相乘的结果）
3.若存在内层第二次循环，则用num2 的各个元素和num1 的倒数第二个元素相乘
依次与str相应位置进行相加，若超出str.size(),则改用push_back进行尾插
4.最后进行reverse（str.begin(),str.end()) 倒置字符串
class Solution { public: string multiply(string num1, string num2) { string str; int flag=0; int num=0; int begin1=0; int begin=0; if(num1[0]=='0'||num2[0]=='0') { str='0'; return str;} for(int i=num1.size()-1;i&gt;=0;i--) { for(int j=num2.size()-1;j&gt;=0;j--) { if(i==num1.size()-1) { num=(num1[i]-'0')*(num2[j]-'0')+flag; if(num&gt;9) flag=num/10; else flag=0; str.push_back(num%10+'0'); if(j==0&amp;&amp;flag!=0) { str.push_back(flag+'0'); flag=0; } } else { num=(num1[i]-'0')*(num2[j]-'0')+flag; if(begin&lt;=str.size()-1) num=num+str[begin]-'0'; if(num&gt;9) flag=num/10; else flag=0; if(begin&lt;=str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e633ee39f0c114216d55b90b3c008d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5d7197bb207147b1c4cbf287d4d354/" rel="bookmark">
			基于Hadoop的汽车大数据分析系统设计与实现【爬虫、数据预处理、MapReduce、echarts、Flask】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ==有需要本项目的代码或文档以及全部资源，或者部署调试可以私信博主==项目介绍爬虫数据概览HIve表设计Cars Database Tables1. cars_data2. annual_sales_volume3. brand_sales_volume4. city_sales_volume5. sales_volume_by_year_and_brand6. sales_distribution_by_env_standard7. average_price_by_brand8. average_price_by_city9. average_mileage_by_brand10. average_down_payment_by_city11. highest_price_model12. lowest_price_model13. most_popular_model_in_city14. most_popular_model_in_brand Hadoop大数据分析系统集成展示大屏可视化系统每文一语 有需要本项目的代码或文档以及全部资源，或者部署调试可以私信博主 项目介绍 本项目旨在构建一个综合性的数据处理和可视化系统，通过整合多种技术高效处理大规模数据。首先，通过网络爬虫从各个来源收集海量数据。这些数据包括标题、品牌、车型、年份、里程、城市、环保标准、售价、首付以及新车含税价等关键字段。这些原始数据被批量收集，需要在有效分析和可视化之前进行处理。
数据收集完成后，接下来是数据预处理阶段。此阶段包括数据清洗、处理缺失值以及将数据格式化为便于上传到Hadoop的结构化格式。之所以选择Hadoop，是因为它能够管理和处理分布在多个节点上的大规模数据集。数据存储在Hadoop的HDFS（Hadoop分布式文件系统）中，可以高效地访问和处理。
为了自动化将数据加载到Hadoop的过程，项目使用了Flume。Flume是一种可靠的服务，能够高效地从多个来源收集、聚合和传输大量日志数据到集中式的数据存储。在本项目中，Flume被配置为自动将预处理后的数据加载到HDFS中，确保数据流入系统的过程顺畅且一致。
数据进入HDFS后，接下来使用Hive进行进一步分析。Hive是一种构建在Hadoop之上的数据仓库基础设施，它允许使用类似SQL的语言HiveQL查询和分析大规模数据集。在此阶段，执行各种分析查询以从数据中提取有意义的见解，例如识别汽车销售趋势、比较品牌表现以及分析不同城市和车型的价格模式。
在Hive中完成分析后，使用Sqoop将结果导出到MySQL数据库。Sqoop是一种设计用于在Hadoop和关系型数据库之间传输数据的工具，能够高效地将Hive查询结果导出到MySQL中。这一步对于将分析后的数据与系统后端集成至关重要，以便进一步处理和可视化。
数据的可视化由Pyecharts负责，这是一种用于创建交互式且视觉吸引力强的图表的Python库。这些可视化图表被设计用于大屏展示，提供了一种直观和交互式的方式来探索数据。图表可能包括柱状图、折线图、饼图以及其他形式的可视化表现方式，使人们更容易理解数据中的趋势和模式。
整个系统使用Python的轻量级Web框架Flask构建。Flask用于开发系统的前端和后端，将所有组件整合为一个连贯的应用程序。系统支持用户注册、修改个人信息、用户交互、主题修改以及点击展示数据等功能。这些特性确保了系统不仅功能齐全，还具有良好的用户体验，为用户提供了一个交互式的平台来探索数据。
总的来说，本项目结合了多种先进技术，创建了一个强大且可扩展的数据处理、分析和可视化系统。从网络爬虫到数据存储、分析，再到前端开发，每个组件都在提供一个满足用户需求的全面解决方案中扮演了至关重要的角色，让用户能够从大规模的汽车数据中获得有价值的见解。
爬虫 数据概览 HIve表设计 Cars Database Tables 1. cars_data ColumnData TypeDescriptionnum_idINT序号titleSTRING标题brandSTRING品牌modelSTRING车型yearINT年份mileageDOUBLE里程，假设单位为万公里citySTRING城市environmental_standardSTRING环保标准priceDOUBLE售价，假设单位为万元down_paymentDOUBLE首付，假设单位为万元price_including_taxDOUBLE新车含税价，假设单位为万元 2. annual_sales_volume ColumnData TypeDescriptionyearINT年份sales_volumeINT销售量 3. brand_sales_volume ColumnData TypeDescriptionbrandSTRING品牌sales_volumeINT销售量 4. city_sales_volume ColumnData TypeDescriptioncitySTRING城市sales_volumeINT销售量 5. sales_volume_by_year_and_brand ColumnData TypeDescriptionyearINT年份brandSTRING品牌sales_volumeINT销售量 6. sales_distribution_by_env_standard ColumnData TypeDescriptionenvironmental_standardSTRING环保标准sales_volumeINT销售量 7. average_price_by_brand ColumnData TypeDescriptionbrandSTRING品牌average_priceDOUBLE平均售价 8. average_price_by_city ColumnData TypeDescriptioncitySTRING城市average_priceDOUBLE平均售价 9. average_mileage_by_brand ColumnData TypeDescriptionbrandSTRING品牌average_mileageDOUBLE平均里程 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc5d7197bb207147b1c4cbf287d4d354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fad26c6e37febae2d60972439687056/" rel="bookmark">
			Node.js 作为 JavaScript 服务器端运行时的特性及其与浏览器环境的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js 作为 JavaScript 服务器端运行时的特性及其与浏览器环境的区别 1. Node.js 的定位 定义：Node.js 是一个基于Chrome V8引擎的JavaScript运行时环境，它允许JavaScript在服务器端执行。目标：Node.js 的目标是利用JavaScript来构建高性能的网络应用程序，特别是在服务器端。特点：它不仅提供了执行JavaScript所需的基础设施，还提供了一套丰富的内置模块和API，如文件系统操作(fs)、网络请求处理(http/https)等。 2. 内置模块的功能 文件系统模块 (fs)：提供了读取、写入、修改文件等操作的方法。网络请求处理模块 (http/https)：允许创建HTTP服务器和客户端，处理请求和响应。其他系统级功能：包括子进程管理(child_process)、加密(crypto)、路径操作(path)等。 3. 与浏览器环境的区别 浏览器环境限制：浏览器出于安全考虑，限制了JavaScript直接访问文件系统或创建网络服务器等功能。Browserify 和 Webpack：这些工具允许使用Node.js样式的模块语法来编写可以在浏览器中运行的代码，但它们不提供Node.js那样的系统级功能。 4. 使用场景 Node.js：适用于构建高性能的服务器端应用程序和服务端API。Browserify/Webpack：适用于组织和管理前端JavaScript代码，以及将模块化的JavaScript代码打包成浏览器可以加载的形式。 5. 小结 Node.js 为JavaScript提供了在服务器端执行的强大能力，包括文件系统操作、网络请求处理等功能。浏览器环境 限制了JavaScript的系统级功能，主要用于前端用户界面交互和逻辑处理。Browserify 和 Webpack 提供了在浏览器中使用模块化JavaScript代码的方法，但不提供Node.js特有的系统级功能。 6. 实践建议 当你需要在服务器端执行JavaScript时，使用Node.js。当你需要在浏览器中组织和管理前端JavaScript代码时，使用Browserify或Webpack。 通过理解Node.js与浏览器环境之间的区别，开发者可以更好地选择合适的工具和技术栈来满足他们的开发需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f45efd6ef9d70c9de507fb7b8c93ca/" rel="bookmark">
			第十五章：高级调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章内容包括：
使用节点污点和pod容忍度组织pod调度到特定节点将节点亲和性规则作为节点选择器的一种替代使用节点亲和性进行多个pod的共同调度使用节点非亲和性来分离多个pod Kubernetes允许你去影响pod被调度到哪个节点。起初，只能通过在pod规范⾥指定节点选择器来实现，后⾯其他的机制逐渐加⼊来扩容这项功能。
1 使用污点和容忍度阻止节点调度到特定节点 ⾸先要介绍的⾼级调度的两个特性是节点污点，以及pod对于污点的容忍度，这些特性被⽤于限制哪些pod可以被调度到某⼀个节点。只有当⼀个pod容忍某个节点的污点，这个pod才能被调度到该节点。
这与使⽤节点选择器和节点亲和性有些许不同，本章后⾯部分会介绍到。节点选择器和节点亲和性规则，是通过明确的在pod中添加的信息，来决定⼀个pod可以或者不可以被调度到哪些节点上。⽽污点则是在不修改已有pod信息的前提下，通过在节点上添加污点信息，来拒绝pod在某些节点上的部署。
1.1 介绍污点和容忍度 默认情况下，一个集群的主节点需要设置污点，这样才能保证控制平面pod才能部署到主节点上。
显示节点的污点信息
可以通过kubectl describe node查看节点的污点信息，如以下代码清单所⽰。
主节点包含⼀个污点，污点包含了⼀个key、value，以及⼀个 effect，表现为&lt;key&gt;=&lt;value&gt;:&lt;effect&gt;。上⾯显⽰的主节点的污点信息，包含⼀个为noderole.kubernetes.io/master的key，⼀个空的value，以及值为NoSchedule的effect。
这个污点将阻⽌pod调度到这个节点上⾯，除⾮有pod能容忍这个污点，⽽通常容忍这个污点的pod都是系统级别pod。
显示pod的污点容忍度
在⼀个通过kubeadm初始化的集群中，kube-proxy集群组件以pod的形式运⾏在每个节点上，其中也包括主节点。因为以pod形式运⾏的主节点组件同时也需要访问Kubernetes服务。为了确保kube-proxy pod也能够运⾏在主节点上，该pod需要添加相应的污点容忍度。
注意 尽管在pod的污点容忍度中显⽰了等号，但是在节点的污点信息中却没有。当污点或者污点容忍度中的value为null时，kubectl故意将污点和污点容忍度进⾏不同形式的显⽰。
了解污点的效果
另外两个在kube-proxy pod上的污点定义了当节点状态是没有ready或者是unreachable时，该pod允许运⾏在该节点多长时间（时间⽤秒来表⽰，这⾥没有显⽰，但是在pod YAML中可以看到）​。这两个污点容忍度使⽤的效果是NoExecute⽽不是NoSchedule。
每⼀个污点都可以关联⼀个效果，效果包含了以下三种：
NoSchedule表⽰如果pod没有容忍这些污点，pod则不能被调度到包含这些污点的节点上。PreferNoSchedule是NoSchedule的⼀个宽松的版本，表⽰尽量阻⽌ pod被调度到这个节点上，但是如果没有其他节点可以调度，pod依然会被调度到这个节点上。NoExecute不同于NoSchedule以及PreferNoSchedule，后两者只在调度期间起作⽤，⽽NoExecute也会影响正在节点上运⾏着的pod。如果在⼀个节点上添加了NoExecute污点，那些在该节点上运⾏着的pod，如果没有容忍这个NoExecute污点，将会从这个节点去除。 如果 节点上运行的Pod 不能容忍这类污点，会马上被驱逐。如果 Pod 能够容忍这类污点，但是在容忍度定义中没有指定 tolerationSeconds， 则 Pod 还会一直在这个节点上运行。如果 Pod 能够容忍这类污点，而且指定了 tolerationSeconds， 则 Pod 还能在这个节点上继续运行这个指定的时间长度。 这段时间过去后，节点生命周期控制器从节点驱除这些 Pod。 1.2 在节点上添加自定义污点 假设你有⼀个单独的Kubernetes集群，上⾯同时有⽣产环境和⾮⽣产环境的流量。其中最重要的⼀点是，⾮⽣产环境的pod不能运⾏在⽣产环境的节点上。可以通过在⽣产环境的节点上添加污点来满⾜这个要求，可以使⽤kubectl taint命令来添加污点：
kubectl taint node node1 node-type=production:NoSchedule 1.3 在pod上添加污点容忍度 为了将⽣产环境pod部署到⽣成环境节点上，pod需要能容忍那些你添加在节点上的污点。你的⽣产环境pod的清单⾥⾯需要增加以下的YAML代码⽚段。
apiVersion: extensions/v1beta1 kind: Deployment metadata: name: prod spec: replicas: 5 template: metadata: labels: app: prod spec: containers: - args: - sleep - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f45efd6ef9d70c9de507fb7b8c93ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59a81b5fdde15633a6795544c198073/" rel="bookmark">
			linux反向代理原理：帮助用户更好地优化网络架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux反向代理原理详解 反向代理是一种在网络架构中常用的技术，尤其在Linux环境下被广泛应用。它可以帮助实现负载均衡、安全防护和请求缓存等功能。本文将深入探讨Linux反向代理的原理、工作机制以及其应用场景。
1. 什么是反向代理 反向代理是指代理服务器接收客户端的请求，然后将请求转发到后端的一个或多个服务器上，最后将服务器的响应返回给客户端。在这个过程中，客户端并不知道实际处理请求的是哪台服务器，这样可以有效隐藏后端服务器的真实地址。
2. 反向代理的工作原理 反向代理的工作流程可以分为以下几个步骤：
客户端请求：客户端向反向代理服务器发送请求，通常是通过HTTP或HTTPS协议。
请求转发：反向代理服务器接收到请求后，根据预设的规则（如负载均衡算法）将请求转发到后端的实际服务器。
后端响应：后端服务器处理请求并返回响应给反向代理服务器。
响应返回：反向代理服务器将后端服务器的响应返回给客户端。
这种结构的好处在于，客户端只需与反向代理交互，而不必直接与后端服务器通信，从而提高了安全性和灵活性。
神龙HTTP-国内HTTP代理IP,动态IP代理服务器,企业爬虫代理IP池定制服务商。【支持免费测试试用】https://h.shenlongip.com/index?did=Alxpnz
3. 反向代理的优点 使用反向代理有以下几个显著优点：
负载均衡：反向代理可以将客户端请求分配到多台后端服务器，从而分散负载，提高整体性能和响应速度。
安全性：反向代理可以隐藏后端服务器的真实IP地址，减少安全风险。它还可以作为防火墙，过滤恶意请求。
缓存功能：反向代理可以缓存后端服务器的响应，减少重复请求，提高访问速度。
SSL终止：反向代理可以处理HTTPS请求的加密和解密，减轻后端服务器的负担。
4. Nginx反向代理配置示例 以下是一个简单的Nginx反向代理配置示例：
server { listen 80; # 监听80端口 server_name example.com; # 服务器域名 location / { proxy_pass http://backend_server; # 将请求转发到后端服务器 proxy_set_header Host $host; # 设置请求头 proxy_set_header X-Real-IP $remote_addr; # 转发客户端真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 添加X-Forwarded-For头 } } 在这个配置中，Nginx会监听80端口，并将所有请求转发到指定的后端服务器（如http://backend_server）。同时，它还会设置一些请求头，以便后端服务器能够获取客户端的真实信息。
5. 反向代理的应用场景 反向代理在实际应用中有多种场景：
网站负载均衡：通过反向代理将用户请求分配到多台Web服务器，提高网站的可用性和性能。
API网关：在微服务架构中，反向代理可以作为API网关，统一管理和路由API请求。
内容分发网络（CDN）：反向代理可以缓存静态内容，提高访问速度，减少后端服务器负担。
总结 反向代理作为一种重要的网络架构技术，在Linux环境中得到了广泛应用。它通过接收客户端请求并转发到后端服务器，提供了负载均衡、安全性和缓存等多种功能。了解反向代理的原理和配置方法，可以帮助用户更好地优化网络架构，提高系统的性能和安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe4c5714600746e617d7c33b58d24c1/" rel="bookmark">
			FL Studio21水果软件中文版破解版安装包怎么下载？2024最新方法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嘿，亲爱的音乐制作人们！👋 如果你还在为寻找一款既强大又易于上手的音乐制作软件而烦恼，那么今天我要为你种草的FL Studio 21中文版绝对是你的不二之选！🚀 作为一个长期使用FL Studio的老用户，让我来带你领略它的全新魅力吧！
【界面升级】🖥️ 得提的是FL Studio 21的新界面设计—它变得更加直观和用户友好。无论是新手还是老手，都能迅速找到所需的功能。新增加的暗色主题不仅美观大方，还能减少长时间工作时对眼睛的压力哦！
FL Studio21汉化版下载网盘链接:
https://pan.quark.cn/s/ce779b75a67f
FL Studio 21 Win-正式版安装包下载如下:
https://wm.makeding.com/iclk/?zoneid=55981
FL Studio 21 Mac-正式版安装包下载如下:
https://wm.makeding.com/iclk/?zoneid=55982
【插件增强】🎛️ 说到音乐制作，怎能不提那些让人爱不释手的插件？FL Studio 21在原有基础上增强了多个插件的功能，比如Edison、Harmor等，让音频编辑和合成更上一层楼。这些小工具的增强使得音乐制作更加精细和专业，绝对能满足各种音乐风格的需求。
【采样器升级】🎤 对于喜欢采样的音乐制作者来说，FL Studio 21的DirectWave样本播放器和Granulizer的改进简直是大福音。现在你可以直接从FL Studio内部导入样本，操作更加便捷；同时Granulizer的新增功能可以让你的样本声音更有层次感和细节表现。
【混音台优化】🎧 混音是音乐制作过程中至关重要的一步，FL Studio 21对混音台进行了优化，增加了更多的效果插槽以及改进了信号流程，使得声音处理更为高效。这对于追求完美音质的你来说，无疑是个好消息！
【MIDI功能强化】🎹 对于键盘手和编曲者来说，FL Studio 21对MIDI功能的强化会让你眼前一亮。新的MIDI特性包括更好的MIDI控制器支持和时间戳记功能，这些都将极大提高你的工作效率并丰富你的音乐表达。
【兼容性与稳定性】💻 但并非最不重要，FL Studio 21的兼容性和稳定性也得到了显著提升。无论你是Windows用户还是macOS用户，都可以享受到流畅无忧的使用体验。而且，FL Studio团队一直在努力修复旧版的bugs，确保每位用户的稳定运行。
【结语】🌟 好啦，关于FL Studio 21中文版本的介绍就到这里啦！希望我的分享能给你带来灵感和帮助。如果你是一位音乐制作爱好者或者专业人士，千万不要错过这款强大的工具。快来加入FL Studio的大家庭，一起创造属于你自己的音乐世界吧！
别忘了，好的工具能让你事半功倍哦！💖 #FLStudio21 #音乐制作 #创作无界 #数字音乐工作站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0557bd184e84618a4cabc89448a9aa33/" rel="bookmark">
			datax和datax-web打包成docker运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 datax和datax-web从一台机器迁移到另一台时，要重新搭建一套运行环境，比较麻烦；打包成docker镜像后迁移就方便多了;
因为我的mysql版本是8，需要在datax的read和write中手动添加8的jdbc驱动
所以我先各自下载好了datax和datax-web，在宿主机上试了一波ok后；
然后手动打包成了docker镜像，方便后续迁移
我的环境
ubuntu22.04
jdk:1.8+
python:3.10.12
maven:3.8.8
docker:26.00
docker-compose:2.24.7
datax-web:2.1.2
打包过程中还是遇到了一些细节问题，比如环境问题，datax自身脚本问题，配置问题等；有一些linux和docker的认知，解决问题会更有方向一些.
镜像制作完，之后要新部署/迁移就方便多了；
实际部署中发现即使手动加入了新的jdbc驱动，但是在执行日志中还是发现有com.mysql.jdbc.Driver旧驱动的warning信息;
要彻底解决需要down datax的代码，将jdbc驱动版本手动调整为8.0+的版本，然后手动打包重新上传包，我重新打包出来后有2G+…
重新打包方案写在下面了
准备工作 datax
https://github.com/alibaba/DataX/tree/datax_v202303
datax-web
https://github.com/WeiYe-Jing/datax-web/tags
down一波datax-web的源码，用idea打开，然后在bin下新增一个health.sh，一会在启动docker容器时让后台常驻（我想的是直接调用原脚本启动，不改原来的启动脚本，所以自己塞了一个进去）；
然后mvn clean install一下,拿到datax-web-2.1.2.tar.gz包；
因为我的mysql是8，datax的read和writer下的lib中没有对应的jdbc驱动，所以需要手动下载塞进去;
另外datax运行需要python环境，所以在声明 FROM python:3.10.12 运行环境后， java环境是手动add进去jdk后，手动配置的env环境，这里准备好jdk8的包即可,下面的docker file中有对应配置;
我的运行环境是python3，所以需要从datax的官网上把对应的python脚本down下来，覆盖到datax-web的指定目录下，这个在我的datax和datax-web直接宿主机部署中有写.
上面步骤都ok后，就可以开始打包镜像了;
我另一篇文章有写datax和datax-web直接在宿主机部署，其实宿主机ok了，剩下的无非就是打包进docker镜像
https://blog.csdn.net/weixin_43944305/article/details/133617114
health.sh
while true do jps | grep "Datax*" sleep 30 done 打包镜像 将准备ok的datax文件夹和datax-web文件夹打包并压缩成tar.gz，然后写一个dockerfile，手动build下就可以用了.
dockerfile
# 基础镜像 FROM python:3.10.12 # author MAINTAINER felix # 创建目录 RUN mkdir -p /app run mkdir -p /app/datax-python3 # work dir workdir /app # 复制文件到路径 add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0557bd184e84618a4cabc89448a9aa33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ad792c386ec2e1d103e1f212979dce/" rel="bookmark">
			微信小程序发布后，报错后端接口连接异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因 本项目是使用uniapp开发，打包发布成微信小程序
微信小程序只能接收https请求本地开发的接口是http请求，微信小程序发布后，报错后端接口连接异常但是运行到微信开发者工具没问题 参考
https://blog.csdn.net/m0_72929753/article/details/132628104
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609d1203927616a94727190ee9a05446/" rel="bookmark">
			vue纯前端使用exceljs导出excel文件手把手教程，非官方文档直粘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有好多私信小伙伴，问我的那篇帖子：
vue纯前端导出excel，包括列表批量导出图片、文件超链接
上篇文章只是将公司的需求代码实现粘贴了进来，对于没有使用过exceljs插件的人来说，确实是有点晦涩的，本文就按自己的理解，一步一步将exceljs插件的使用讲解一下，有不明确或理解错误的地方欢迎指出，促进我进步。
最终实现样式展示： 目录
一、exceljs的安装、引用
二、创建excel工作簿
三、创建excel工作表（sheet栏）
四、为excel工作表定义每列的数据
五、excel设置样式（合并单元格等）
六、excel的行级操作
七、遍历所有行
八、遍历所有单元格
九、向excel中插入图片
十、插入超链接 十一、主图完整代码
一、exceljs的安装、引用 首先执行npm i exceljs，将依赖安装到你的项目中
npm i exceljs 在vue页面中，创建一个方法，将exceljs引入
exportExcel() { const Exceljs = require('exceljs'); // 引入exceljs }, 二、创建excel工作簿 引入成功后，先来创建一个excel工作簿
exportExcel() { const Exceljs = require('exceljs'); // 引入exceljs const workbook = new Exceljs.Workbook();// 创建工作簿 }, 此时，我们增加以下内容，就会下载出一个excel文件啦。
我用了 saveAs 插件下载，安装方式随便搜一下，这里就不赘述了。
exportExcel() { const Exceljs = require('exceljs'); // 引入exceljs const workbook = new Exceljs.Workbook(); // 创建工作簿 // 下载工作簿 workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/609d1203927616a94727190ee9a05446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8f7c8e68ff63ab687a871887673863/" rel="bookmark">
			超越流水线，企业研发规范落地新思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：子丑
内容大纲：
1、研发规范≠流程约束
2、自动化工具→研发规范载体
3、研发规范在工具上的落地示例
4、研发规范的选型方法与常见实践
研发规范≠流程约束 这个故事特别适合研发规范的场景，我们要避免成为把猫绑在柱子上的信众。而要做到这一点，我们先要了解什么是研发规范。
当我们在谈论研发规范时，我们在谈论什么？
有些团队谈起研发规范，会列一个大纲，并制定详尽的规章制度，这些规章制度对他们而言就是研发规范。
这个大纲可能是这样的：
需求管理规范代码管理规范制品管理规范测试管理规范生产发布规范安全研发规范 还有些团队会用如下这种图来描述需求从提出到开发到交付的整个过程，准入准出要求、会涉及到哪些人等，他们以此来描述研发规范。
显然，当我们以第 2 种方式描述研发规范的时候，我们能更好地把控研发过程，能够以终为始地去看研发规范。
研发规范的目标、执行挑战 研发规范是跟随软件工程的产生而产生的。随着软件和团队的规模逐渐扩大，软件危机随之产生，为确保软件按时、按质地交付，需要利用软件工程的思路来解决软件危机，由此产生了研发规范。
因此，研发规范的目标是保障软件按时、按质地交付。
要保证软件按时按质地交付，实现研发规范的目标，我们需要从两方面入手，即优化研发团队内外协同机制和提升研发团队工程交付水平。
在制定研发规范时，有两个常见的误区。
一，只关心协作机制，乐衷于制定各种规则。例如，部署前提交发布审批单，其需经过 ABCD 四人的审批及相关人员的签字，审批单里面需要包括 XYZ 项内容等等。
二，只关心工程交付，乐衷于优化单点实践。例如，要求做单元自动化测试，并强调新增代码单元测试覆盖率要达到 100%。
如果只关心协同机制，那么研发规范很快会变成行为约束和规章制度。但是，研发规范还有另外的作用，即通过规范提升团队的工程实践能力。例如代码评审是为了提升大家对整体领域的理解和学习，自动化测试是为了提升快速验证的能力。
如果只关心工程交付，那么研发规范容易陷入一个个具体的实践，而忽视了整个交付流程，导致一眼障目不见泰山。例如测试团队强调测试自动化的实践，但却忽视了当下测试反馈的瓶颈不在测试自动化水平，而在流程中的部署和审批效率低下。
我们的目的应是既解决了协同问题，同时有提升了团队的工程水平。
自动化工具→研发规范载体 确定了研发规范的目标，我们接下来看如何将目标落地。很多时候，在制定研发规范时，我们会编写包含各类规范的详细文档。但仅靠人力去实现这些规范是不现实的。因此，我们会需求工具的帮助，即利用工具去保障文档描述的规范被执行。
但是，文档与工具的执行之间往往存在一定的差距，这个差距该如何去解决呢？
1、案例 上世纪 60 年代，阿波罗八号飞船的事故很好地阐释了这个问题。工程师汉密尔顿在加班时不慎触发了预发射程序，但好在是在测试状态，没有引发事故。这一事件促使汉密尔顿提出在系统中引入错误检查的想法，但负责人认为这种情况不可能发生。后续正如汉密尔顿所担心的，飞船飞行过程中宇航员误触发了这个程序。幸运的是，备份机制起到了关键的作用，避免了更严重的事故发生。
2、启示 仅靠文档定义规范是行不通的，当面临某个问题时，使用者需要按照文档规定的流程将各项任务串联起来解决，且中间不能出错。因此完全依赖使用者处理问题是不可靠的。正如阿波罗八号的例子，如果系统没有备份机制，要求使用者来处理这些问题将会是非常困难的。所以，工具的组合和连接（即如何正确地使用工具完成某个任务），也应该有相应工具来实现，而不是依靠使用者记住这一系列步骤并确保没有任何错误发生。
这个问题的核心是流程的自动化。
流程是工具自动化的过程，人不是流程本身和驱动者，而是参与方之一。只有这样，我们才能保证研发规范符合设计和成功落地。
3、示例：实现按特性的持续交付 通常情况下，研发规范会如何落地？我们利用名为“按特性持续交付”的案例来进行解释。
某企业有 30 左右的研发团队，架构师希望能确保团队的灵活性和快速响应能力。团队应该能够持续交付产品特性，即将产品特性拆解成各应用的开发任务，实现独立部署，以达到灵活性和快速响应业务需求的目的。
基于此，他们的愿景是，每个产品特性可以独立且快速地开发、测试、发布。每个特性对应一个开发分支，这一分支在开发验证和测试验收阶段发挥作用。只有通过开发验证的分支才能进入测试验收，通过测试验收的分支才能进入评审并合入主干，最终进入生产部署。
上面是我们定义的研发规范的概览，在这个概览下我们做了如下几层定义。
产品的交付粒度是一个产品特性，部署力度是一个应用，开发力度是一个 feature 分支。feature 分支必须经过开发、测试，最后到达部署。在 feature 的整个交付过程中，每个阶段都有准入卡点。比如，如果某个 feature 分支没有经过开发阶段的验证，那么将不能进入测试验收阶段。 4、基于代码库和流水线的解决方案 有了这些规范之后，如果基于代码库和流水线，如何落地呢？
首先，代码库与应用最好一一对应，且代码库会将 master 分支配置为保护分支，其只能被合入，而不能被推送。并且被合入时具有条件限制，其必须通过前面的验证。
其次，我们应该会有两条或三条流水线。此处为开发测试流水线和生产流水线。在开发测试流水线上，开发测试都在这个 feature 分支上。开发测试流水线包含两个部分。第一个部分是开发阶段，它只做了一些构建和单元测试。第二部分是测试阶段，它只做了测试环境的部署以及测试验证。这里，我们是把两个部分是放在 1 条流水线上，即将代码推送到 feature 分支，再进入到单元测试等阶段，如果开发自测通过，确认可以提交测试验证，那么测试可以进入到部署环境阶段，然后进入到测试验证阶段，如果验证通过，则流程结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad8f7c8e68ff63ab687a871887673863/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a8abd0526555eb55498eb04ffe54ca/" rel="bookmark">
			中药文化中药商城系统解决方案毕设毕业设计.web期末作业设计网页.css网页成品参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：黄菊华老师《Vue.js入门与商城开发实战》《微信小程序商城开发》图书作者，CSDN博客专家，在线教育专家，CSDN钻石讲师；专注大学生毕业设计教育和辅导。
所有项目都配有从入门到精通的基础知识视频课程，学习后应对毕业设计答辩。
项目配有对应开发文档、开题报告、任务书、PPT、论文模版等
项目都录了发布和功能操作演示视频；项目的界面和功能都可以定制，包安装运行！！！
如果需要联系我，可以在CSDN网站查询黄菊华老师
在文章末尾可以获取联系方式
页面欣赏 功能清单 用户注册：填写手机账号和密码，注册新用户
登录功能：注册普通账号登录；登录后可以修改用户的基本信息，也可以退出。
关于我们：关于我们、联系我们、加入我们、法律声明
轮播广告：后台设置首页轮播广告图，可以连接到广告页面。
留言反馈：用户填写李哭咽的主题、联系人、电话、邮箱、留言内容；后台管理可以查看留言列表，可以删除留言。
商品库：点击所有商品；支持通过查询来查找所需要商品
商品信息： 点击到商品详情页面，可以查看商品介绍、图片、价格、销售等、详情、已购买用户的评论列表。 商品收藏：在操作信息详情，下方点击“收藏”，进行收藏 商品选购：在商品的详情页面，点击“加入购物车”，也可以直接点击“立即购买”
商品购物车：列出打算下单的商品列表，支持数量增加和减小
商品下单：在购物车列表点击“去结算”，选择或者填写收货地址、确认要下单的商品和数量；填写备注。点击“下单结算”，然后跳转到订单列表 取消订单：在“我的订单”列表中，针对没有付款的订单，点击“取消申请”，删除订单 去付款：：在“我的订单”列表中，点击“去付款”，模拟付款 商品评论：在“我的订单”列表中，已经付款的订单，可以对每个商品，点击“评价”，去打分和填写商品评论. 收货地址管理：录入收货地址、查看所有收货地址，修改收货地址、删除 我的商品收藏：收藏的商品列表，支持删除
信息浏览、收藏、评论：浏览网站的记录
用户信息：姓名、联系方式、邮箱、头像、简介、介绍等，支持随时修改；用户注册的信息后台管理员可见；后台管理员可以删除。
密码修改：修改注册的密码。
退出登录：清除登录的cookie，返回到首页。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb1d6e2a5c1dd5709ebc7d1c1fe5584/" rel="bookmark">
			学生必看！如何用OpenAI最新GPT-4o轻松搞定论文写作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️作者主页：小虚竹
❤️作者简介：大家好,我是小虚竹。2022年度博客之星🏆，Java领域优质创作者🏆，CSDN博客专家🏆，华为云享专家🏆，掘金年度人气作者🏆，阿里云专家博主🏆，51CTO专家博主🏆
❤️技术活，该赏
❤️点赞 👍 收藏 ⭐再看，养成习惯
文章目录 一、GPT功能二、使用 ChatGPT 来生成论文思路操作实战 三、使用ChatGPT来创建提纲四、使用 ChatGPT 查找资料来源五、使用 ChatGPT 写论文六、使用 ChatGPT 协助你编辑论文七、感受 一、GPT功能 GPT-4o知识问答：支持1000+token上下文记忆功能
最强代码大模型Code Copilot：代码自动补全、代码优化建议、代码重构等
DALL-E AI绘画：AI绘画 + 剪辑 = 自媒体新时代
私信虚竹哥，直接使用GPT-4o
二、使用 ChatGPT 来生成论文思路 在动手写论文之前，你需要先理清自己的想法。老师通常会给你一个大致的方向，让你自由发挥自己的思考和分析。
你要做的就是找到一个你感兴趣的切入点来展开写作。如果你最近写过论文，你可能会感到找到一个好的角度并不容易——这时 ChatGPT 就能派上用场了。
只需告诉 ChatGPT 你的论文主题，并尽可能多地提供相关细节（比如你想探讨的内容），接下来的工作就交给 ChatGPT 吧。你可以像这样开始：
你能帮我想一个论文主题吗？我打算写一篇关于领导力的论文。 我希望能把“布莱克和莫顿的管理方格理论”纳入其中，并且想加入一个历史人物的例子。 包括论文主题、简要概述，章节结构，以及可以使用的人物案例的具体例子 操作实战 ChatGPT 4o国内直接访问地址：https://share.xuzhugpt.cloud/
上plus的车
默认就是 gpt-4o大模型
输入：
你能帮我想一个论文主题吗？我打算写一篇关于领导力的论文。 我希望能把“布莱克和莫顿的管理方格理论”纳入其中，并且想加入一个历史人物的例子。 包括论文主题、简要概述，章节结构，以及可以使用的人物案例的具体例子 三、使用ChatGPT来创建提纲 一旦确定了论文主题，接下来就要开始头脑风暴，想清楚你在论文里要写些什么。
为了让写作更顺利，建议你先列一个提纲，把所有想在论文中涉及的主要点都列出来。不过，写提纲通常是个挺费时的过程。
有了 ChatGPT，你只需要让它帮你写提纲就行了。
你可以用 ChatGPT 生成的主题，直接让它写出一个提纲，比如这样：
你能帮我为这篇论文创建一个提纲吗？ 论文的题目是“从布莱克和莫顿的管理方格理论视角分析历史领导力：以亚伯拉罕·林肯为例” 这个提纲很全面，你可以根据需要把它简化成一篇短论文，或者扩展成一篇更长的论文。
如果有不满意的部分，或者想进一步调整提纲，你可以自己修改，也可以给 ChatGPT 提供更多的说明，让它帮你调整。
四、使用 ChatGPT 查找资料来源 既然你已经明确了自己要写什么，现在就需要找到可靠的资料来源来支持你的内容。如果不知道从哪里开始，你可以直接问 ChatGPT。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb1d6e2a5c1dd5709ebc7d1c1fe5584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa343c34c4c535b8fe72c8148a0657b/" rel="bookmark">
			java中nginx负载均衡配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负载均衡的配置，是为了实现程序的高并发和可用性进行服务器访问配置
负载均衡是指将用户的请求分配到多个后端服务器上进行处理，以达到优化资源利用率、提高响应速度和增加系统的可靠性的目的。负载均衡器通常位于用户和服务器之间，接收用户的请求，并根据某种算法将请求分发给合适的后端服务器
在nginx中，可以使用upstream模板来配置后端服务器集群组，并使用server指令指定服务器的地址和参数。然后在server配置中使用proxy_pass 指令请求转发到定义好的服务器群组。
http { upstream backend { server backend1.example.com; server backend2.example.com; server backend3.example.com; # 可以设置权重 server backend4.example.com weight=2; } server { listen 80; location / { proxy_pass http://backend; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } } 在这个upstream 定义了一个名为 backend 的服务器群组。三个服务器通过server指定添加到群组中，第四个服务器有一个额外的weight参数，用于指定更高的权重。意味着负载均衡中将更倾向于分配更多的请求给它。
listen 指令指定了监听的端口。
location / 指定了对于所有请求，使用 proxy_pass 指令转发到定义的服务器群组。
几个 proxy_set_header 指令用于确保正确地转发原始请求信息
轮询算法是最简单的负载均衡算法之一，它按照顺序将请求依次分发给每个后端服务器。当所有服务器都被分配了一次请求后，重新开始下一轮分配。
优点：简单以实现/适应于后端服务器性能相近的情况
缺点：无法考虑服务器的负载情况，不适用于后端服务器性能差异较大的情况。
通过配置， Nginx将以轮询的方式默认分配进入的请求到上面定义的后端服务器，可以通过upstream中添加额外参数来调整负载均衡算法
例如使用：ip_hash保持会话或者使用least_conn进行最少连接数的负载均衡。
配置过程中可以新增健康检查，以确保请求分配给健康的后端服务器，可以使用
ngx_http_upstream_check_module模块实现健康检查 http { upstream backend { server backend1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa343c34c4c535b8fe72c8148a0657b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c72003a5acf1fe448796fedb9fc93f/" rel="bookmark">
			安卓开发- 安卓13 Launcher3 主页布局修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改主页布局 概述 ​ 在 Android 操作系统中，Launcher （主页应用）是用户与设备交互的核心界面之一，它负责显示应用程序列表、提供快捷方式、管理小部件等功能。其中，Launcher3 是 Android 系统默认的启动器应用程序，我们可以通过修改Launcher3的源码，来改变主页应用的样式和布局。下面将结合源码，分析如何修改Launcher3主页的相关样式和布局。
布局构成 ​ Launcher3最核心的类是一个Launcher.java（可以看作是Launcher中的MainActivity），基本上所有操作(包括UI的定制)都集中在这个Activity上。在Launcher.java 中，通过setContentView()设置的布局参数是R.layout.launcher，对应的是launcher.xml文件，它定义了启动器界面的整体结构和组件的位置，我们看下这个布局文件里的内容：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;com.android.launcher3.LauncherRootView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:launcher="http://schemas.android.com/apk/res-auto" android:id="@+id/launcher" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;com.android.launcher3.dragndrop.DragLayer android:id="@+id/drag_layer" android:layout_width="match_parent" android:layout_height="match_parent" android:clipChildren="false" android:clipToPadding="false" android:importantForAccessibility="no"&gt; &lt;com.android.launcher3.views.AccessibilityActionsView android:layout_width="match_parent" android:layout_height="match_parent" android:contentDescription="@string/home_screen" /&gt; &lt;!-- The workspace contains 5 screens of cells --&gt; &lt;!-- DO NOT CHANGE THE ID --&gt; &lt;com.android.launcher3.Workspace android:id="@+id/workspace" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="center" android:theme="@style/HomeScreenElementTheme" launcher:pageIndicator="@+id/page_indicator" /&gt; &lt;!-- DO NOT CHANGE THE ID --&gt; &lt;include android:id="@+id/hotseat" layout="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c72003a5acf1fe448796fedb9fc93f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c176845377607b31628795132557a3c5/" rel="bookmark">
			Mysql8.3.0排序导致分页数据错乱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #业务场景
生产环境
仓库管理，能看到各个仓库的C库位
物料管理，编辑物料，弹框时选择库位时，7页数据，没有C库位，查询条件指定C，能查到数据
本地环境
数据还原到本地
弹框数据在2页与第3页看到C库位数据
总上，两个环境的数量一样，每页的数据确不一样。
初步判断，分页计算错误、页面分页参数参数错误，页面抓接口参数、后端抓sql日志都正常。
最终方案：把同样的sql放到不同的环境执行，发现结果不一样，猜测排序除了问题。
查看排序字段有两个，一个数据都为2，一个数据都为空
总上：Mysql8.3.0排序字段值都一样时，乱入。低版本8.0.37排序字段值都一样时，选用主键asc
SELECT * FROM warehouse_bin wb WHERE 1 = 1 AND wb.`name` LIKE '%C%' ORDER BY ( wb.type + 0 ) ASC,wb.seqNo ASC 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/56/">«</a>
	<span class="pagination__item pagination__item--current">57/621</span>
	<a class="pagination__item pagination__item--next btn" href="/page/58/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>