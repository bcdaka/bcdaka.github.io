<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>leetcode日记（51）不同路径Ⅱ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c2c447903524b22f14d4e44a86b2e0a6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="leetcode日记（51）不同路径Ⅱ">
  <meta property="og:description" content="和上一道题（无障碍物的最短路径）很像，但事实上比上一题多了优化方法
根据上一题改的代码如下，添加了对障碍物的判定，如果有障碍物则将数组值设为0。
class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m=obstacleGrid.size(); int n=obstacleGrid[0].size(); int a[m][n]; for(int i=0;i&lt;m;i&#43;&#43;) for(int j=0;j&lt;n;j&#43;&#43;) a[i][j]=0; for(int i=0;i&lt;n&amp;&amp;obstacleGrid[0][i]==0;i&#43;&#43;) a[0][i]=1; for(int i=0;i&lt;m&amp;&amp;obstacleGrid[i][0]==0;i&#43;&#43;) a[i][0]=1; for(int i=1;i&lt;m;i&#43;&#43;){ for(int j=1;j&lt;n;j&#43;&#43;){ if(obstacleGrid[i][j]==0) a[i][j]=a[i-1][j]&#43;a[i][j-1]; } } return a[m-1][n-1]; } }; 然后看了答案，答案说可以使用滚动数组优化，就又去搜了一下滚动数组的使用方法。
参考了一下63. 不同路径 II(C&#43;&#43;)---动态规划解题(并进行滚动数组思想优化)，琢磨了一下代码，原理是将上面的二维数组优化成了一维，记录开始位置到达每一行末尾的路径数。如有障碍物则直接将数目设为0，然后继续遍历这一行；没有障碍物就将数目设为上一行路径数加上这一行路径数。
需要注意的是遍历方向，按照上面这种思路需要先遍历列再遍历行，如果先遍历行，如果上一行末尾有障碍物那么下一行就通过不了。
class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m=obstacleGrid.size(); int n=obstacleGrid[0].size(); vector&lt;int&gt; a(m); a[0]=!obstacleGrid[0][0]; for(int j=0;j&lt;n;j&#43;&#43;){ for(int i=0;i&lt;m;i&#43;&#43;){ if(obstacleGrid[i][j]) a[i]=0; else if(i&gt;0&amp;&amp;!obstacleGrid[i-1][j]) a[i]&#43;=a[i-1]; cout&lt;&lt;i&lt;&lt;&#34; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T15:03:30+08:00">
    <meta property="article:modified_time" content="2024-07-25T15:03:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">leetcode日记（51）不同路径Ⅱ</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="698" src="https://images2.imgbox.com/e0/a0/3C3Vn7pJ_o.png" width="882"></p> 
<p>和上一道题（无障碍物的最短路径）很像，但事实上比上一题多了优化方法</p> 
<p>根据上一题改的代码如下，添加了对障碍物的判定，如果有障碍物则将数组值设为0。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        int m=obstacleGrid.size();
        int n=obstacleGrid[0].size();
        int a[m][n];
        for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) a[i][j]=0;
        for(int i=0;i&lt;n&amp;&amp;obstacleGrid[0][i]==0;i++) a[0][i]=1;
        for(int i=0;i&lt;m&amp;&amp;obstacleGrid[i][0]==0;i++) a[i][0]=1;
        for(int i=1;i&lt;m;i++){
            for(int j=1;j&lt;n;j++){
                if(obstacleGrid[i][j]==0) a[i][j]=a[i-1][j]+a[i][j-1];
            }
        }
        return a[m-1][n-1];
    }
};</code></pre> 
<p>然后看了答案，答案说可以使用滚动数组优化，就又去搜了一下滚动数组的使用方法。</p> 
<p>参考了一下<a class="link-info" href="https://blog.csdn.net/qq_45732909/article/details/107150945?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172187701016800188525107%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=172187701016800188525107&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-107150945-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E6%80%9D%E6%83%B3&amp;spm=1018.2226.3001.4187" title="63. 不同路径 II(C++)---动态规划解题(并进行滚动数组思想优化)">63. 不同路径 II(C++)---动态规划解题(并进行滚动数组思想优化)</a>，琢磨了一下代码，原理是将上面的二维数组优化成了一维，记录开始位置到达每一行末尾的路径数。如有障碍物则直接将数目设为0，然后继续遍历这一行；没有障碍物就将数目设为上一行路径数加上这一行路径数。</p> 
<p>需要注意的是遍历方向，按照上面这种思路需要先遍历列再遍历行，如果先遍历行，如果上一行末尾有障碍物那么下一行就通过不了。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        int m=obstacleGrid.size();
        int n=obstacleGrid[0].size();
        vector&lt;int&gt; a(m);
        a[0]=!obstacleGrid[0][0];
        for(int j=0;j&lt;n;j++){
            for(int i=0;i&lt;m;i++){
                if(obstacleGrid[i][j]) a[i]=0;
                else if(i&gt;0&amp;&amp;!obstacleGrid[i-1][j]) a[i]+=a[i-1];
                cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;a[i]&lt;&lt;endl;
            }
        }
        return a[m-1];
    }
};</code></pre> 
<p>感觉这个方法很熟悉，前几天的<a class="link-info" href="https://blog.csdn.net/s478527548/article/details/140458972?spm=1001.2014.3001.5501" title="一道题">一道题</a>也用过这种思路（虽然也是看答案知道的就是了）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3154c29c6aa6af0f3b8cd526bd894396/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp集成安卓原生录屏插件以及使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/461b18e2928e3c689add6167fe853673/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VSCode 命令行使用 git commit 无法输入中文</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>