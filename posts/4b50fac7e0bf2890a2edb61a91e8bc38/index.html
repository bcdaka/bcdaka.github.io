<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;第十九弹---string模拟实现(下) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4b50fac7e0bf2890a2edb61a91e8bc38/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;第十九弹---string模拟实现(下)">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
目录
1、修改操作
2、迭代器操作
3、字符串操作 4、非成员函数重载操作
总结
1、修改操作 1、string&amp; operator&#43;= (const char* s);
//尾部插入字符串s
2、string&amp; operator&#43;= (char c);
//尾部插入字符c
3、void push_back (char c);
//尾部插入字符c
4、string&amp; append (const char* s);
//尾部插入(追加)字符串s
5、void insert(size_t pos, char ch);
//在pos位置插入字符c
6、void insert(size_t pos, const char* str);
//在pos位置插入字符串str
7、void erase(size_t pos, size_t len = npos);
//从pos位置删除n个字符
8、void swap(string&amp; s);
//把字符串数据进行交换
void push_back(char c) { // 扩容 容量为0则固定为4 其他则*2 if (_size == _capacity) { reserve(_capacity == 0 ?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T12:50:48+08:00">
    <meta property="article:modified_time" content="2024-05-23T12:50:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;第十九弹---string模拟实现(下)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/c6/c5/wq465YdZ_o.jpg"></p> 
<p style="text-align:center;">✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"><span style="background-color:#ff9900;"> 熬夜学编程的小林</span></a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏： </span><a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】"><span style="background-color:#38d8f0;">【C语言详解】</span></a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】"><span style="background-color:#38d8f0;">【数据结构详解】</span></a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】"><span style="background-color:#a2e043;">【C++详解】</span></a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">1、修改操作</a></p> 
<p id="2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%93%8D%E4%BD%9C" rel="nofollow">2、迭代器操作</a></p> 
<p id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">3、字符串操作 </a></p> 
<p id="4%E3%80%81%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" rel="nofollow">4、非成员函数重载操作</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">1、修改操作</h2> 
<blockquote> 
 <p><strong>1、string&amp; operator+= (const char* s);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//尾部插入字符串s</span><br> 2、string&amp; operator+= (char c);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//尾部插入字符c</span><br> 3、void push_back (char c);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//尾部插入字符c</span><br> 4、string&amp; append (const char* s);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//尾部插入(追加)字符串s</span><br> 5、void insert(size_t pos, char ch);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//在pos位置插入字符c</span><br> 6、void insert(size_t pos, const char* str);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//在pos位置插入字符串str</span><br> 7、void erase(size_t pos, size_t len = npos);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//从pos位置删除n个字符</span><br> 8、void swap(string&amp; s);</strong></p> 
 <p><span style="color:#fe2c24;"><strong>//把字符串数据进行交换</strong></span></p> 
</blockquote> 
<pre><code>void push_back(char c)
{
	// 扩容 容量为0则固定为4 其他则*2
	if (_size == _capacity)
	{
		reserve(_capacity == 0 ? 4 : 2 * _capacity);
	}
	_str[_size] = c;//_size下标插入字符c
	++_size;//将大小+1
	_str[_size] = '\0';//字符串最后位置给标志结束的\0
}
void append(const char* s)
{
	//追加字符串首先得判断空间是否足够
	size_t len = strlen(s);
	if (len &gt; _capacity - _size)//空间不够则扩容
	{
		reserve(_size + len);//大小为原大小+插入字符串长度
	}

	strcpy(_str + _size, s);//将要追加的数据拷贝到原数据尾
	_size += len;//更新字符串大小
}
string&amp; operator+=(char c)
{
	push_back(c);//调用尾插字符函数

	return *this;
}
string&amp; operator+=(const char* str)
{
	append(str);
	return *this;
}
void insert(size_t pos, char ch)
{
	assert(pos &lt;= _size);//断言，小于字符串大小才能进行插入操作

	// 扩容
	if (_size == _capacity)
	{
		reserve(_capacity == 0 ? 4 : 2 * _capacity);
	}
	// end=_size会有无符号与有符号比较问题，因为pos恒大于等于0，end回到-1
	// 无符号与有符号比较 会提升至无符号比较 即end = -1 还会大于pos
	size_t end = _size + 1;
	while (end &gt; pos)//end==pos则循环停止
	{
		_str[end] = _str[end - 1];//将前面的元素往后面一个位置移动
		--end;
	}
	_str[pos] = ch;//pos位置赋值字符ch
	++_size;//更新大小
}

void insert(size_t pos, const char* str)
{
	assert(pos &lt;= _size);//pos小于字符串大小才能进行插入操作

	size_t len = strlen(str);
	if (len &gt; _capacity - _size)//容量不够则扩容
	{
		reserve(_size + len);
	}
	size_t end = _size + len;
	while (end &gt; pos + len - 1)
	{
		_str[end] = _str[end - len];//将原数据向后移动len位置
		--end;
	}
	strncpy(_str + pos, str, len);//不需要拷贝\0因此使用strncpy拷贝len长度到原串
	_size += len;//更新大小
}
void erase(size_t pos, size_t len = npos)
{
	assert(pos &lt; _size);

	if (len == npos || len &gt;= _size - pos)//长度为npos或者大于等于字符串大小-pos即删除整个字符串
	{
		_str[pos] = '\0';//直接在pos位置给\0即可
		_size = pos;//pos为\0下标，刚还为字符串大小
	}
	else//将pos+len位置后的数据拷贝到pos为止
	{
		strcpy(_str + pos, _str + pos + len);
		_size -= len;//更新长度
	}
}
void swap(string&amp; s)//交换类的成员变量即可，
{
	std::swap(_str, s._str);//调用库函数的swap模板函数
	std::swap(_size, s._size);
	std::swap(_capacity, s._capacity);
}</code></pre> 
<h2 id="2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%93%8D%E4%BD%9C">2、迭代器操作</h2> 
<p><strong>注意：暂时我们理解的迭代器实质为指针，但不完全是指针，此处就通过指针来模拟实现。</strong></p> 
<blockquote> 
 <p><strong>typedef char* iterator;//将迭代器定义成char*类型<br> typedef const char* const_iterator;将迭代器定义成const char*类型</strong></p> 
 <p><br><strong>1、const char* begin() const;</strong></p> 
 <p><strong><span style="color:#fe2c24;">//获取指向首元素的const迭代器</span><br> 2、const char* end() const;</strong></p> 
 <p><strong><span style="color:#fe2c24;">//获取指向尾元素的const迭代器</span><br> 3、char* begin();</strong></p> 
 <p><strong><span style="color:#fe2c24;">//获取指向首元素的迭代器</span><br> 4、char* end();</strong></p> 
 <p><span style="color:#fe2c24;"><strong>//获取指向尾元素的迭代器</strong></span></p> 
</blockquote> 
<pre><code>typedef char* iterator;
typedef const char* const_iterator;

const char* begin() const
{
	return (const char*)_str;//返回首元素地址，const修饰因此强转类型
}
const char* end() const
{
	return (const char*)_str + _size;//尾元素下一个位置地址，即\0位置地址
}
char* begin()
{
	return _str;
}
char* end()
{
	return _str + _size;
}</code></pre> 
<h2 id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%C2%A0">3、字符串操作 </h2> 
<blockquote> 
 <p><strong>1、const char* c_str() const;</strong></p> 
 <p><span style="color:#fe2c24;"><strong>//获取C字符串首元素地址</strong></span></p> 
 <p><strong>2、size_t find(char ch, size_t pos = 0) const;</strong></p> 
 <p><strong><span style="color:#fe2c24;">//从pos位置(默认从0位置)找字符ch，找到则返回下标，否则返回npos</span><br> 3、size_t find(const char* sub, size_t pos = 0) const;</strong></p> 
 <p><strong><span style="color:#fe2c24;">//从字符串sub的pos位置找是否有匹配的字符串，找到则返回第一个元素下标，否则返回npos</span><br> 4、string substr(size_t pos = 0, size_t len = npos);</strong></p> 
 <p><span style="color:#fe2c24;"><strong>//从pos位置截取len长度(默认截取整个字符串)的子串</strong></span></p> 
</blockquote> 
<pre><code>const char* c_str() const
{
	return _str;//返回首地址
}
size_t find(char ch, size_t pos = 0) const
{
	assert(pos &lt; _size);//小于字符串大小才能进行查找
	for (size_t i = 0; i &lt; _size; i++)//遍历字符串
	{
		if (_str[i] == ch)
			return i;//找到字符则返回下标
	}
	return npos;
}
size_t find(const char* sub, size_t pos = 0) const
{
	assert(pos &lt; _size);
	const char* p = strstr(sub + pos, _str);//从sub+pos位置找，调用C语言库的找子串函数，找到则返回该值的地址，否则返回NULL
	if (p)//不为空则返回下标，指针相减即为相差个数，即下标
	{
		return p - _str;
	}
	else//为空返回npos
	{
		return npos;
	}
}
string substr(size_t pos = 0, size_t len = npos)
{
	assert(pos &lt; _size);
	string sub;
	if (len &gt;= _size - pos)//长度大于_size-pos即将整个字符串截取，也包括len==npos
	{
		for (size_t i = pos; i &lt; _size; i++)
		{
			sub += _str[i];//追加给sub
		}
	}
	else//否则截取len长度
	{
		for (size_t i = pos; i &lt; len + pos; i++)
		{
			sub += _str[i];
		}
	}
	return sub;
}</code></pre> 
<h2 id="4%E3%80%81%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">4、非成员函数重载操作</h2> 
<blockquote> 
 <p><strong>1、void swap(string&amp; s1, string&amp; s2);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//将类s1数据与类s2数据交换</span><br> 2、bool operator==(const string&amp; s1, const string&amp; s2);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//比较s1与s2是否相等</span><br> 3、bool operator&lt;(const string&amp; s1, const string&amp; s2);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//比较s1是否小于s2</span><br> 4、ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//流插入，即打印字符串s</span><br> 5、istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s);</strong></p> 
 <p><strong><span style="color:#fe2c24;">//流提取，即将输入的内容给s</span><br> 6、istream&amp; getline(istream&amp; in, string&amp; s);</strong></p> 
 <p><span style="color:#fe2c24;"><strong>//获取一行信息，即将输入中回车之前的信息给s</strong></span></p> 
</blockquote> 
<pre><code>void swap(string&amp; s1, string&amp; s2)
{
	s1.swap(s2);//调用类成员交换函数，跟库函数中交换函数重载，先调用类成员函数
}
bool operator==(const string&amp; s1, const string&amp; s2)
{
	int ret = strcmp(s1.c_str(), s2.c_str());//调用C语言比较字符串函数，等于0则相等
	return ret == 0;
}
bool operator&lt;(const string&amp; s1, const string&amp; s2)
{
	int ret = strcmp(s1.c_str(), s2.c_str());
	return ret &lt; 0;
}

ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s)
{
	for (auto ch : s)
	{
		out &lt;&lt; ch;//用范围for变量类
	}
	return out;
}

istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)
{
	s.clear();//清空串s
	char ch = in.get();//C++库中输入函数，读取一个字符给ch
	char buff[128];//先开辟一个128字节空间，减少频繁扩容
	size_t i = 0;
	while (ch != '\n' &amp;&amp; ch != ' ')//流提取不识别空格回车
	{
		buff[i++] = ch;//将字符赋值给buff数组
		if (i == 127)//字符串满了则追加给串s
		{
			buff[127] = '\0';//末尾追加标志符\0
			s += buff;
			i = 0;//再重新赋值字符给buff数组
		}
		ch = in.get();
	}
	if (i &gt; 0)//i&gt;0则再追加数据给s
	{
		buff[i] = '\0';
		s += buff;
	}
	return in;
}
istream&amp; getline(istream&amp; in, string&amp; s)
{
	s.clear();
	char ch = in.get();
	char buff[128];
	size_t i = 0;
	while (ch != '\n')//不识别回车，其他原理同流插入
	{
		buff[i++] = ch;
		if (i == 127)
		{
			buff[127] = '\0';
			s += buff;
			i = 0;
		}
		ch = in.get();
	}
	if (i &gt; 0)
	{
		buff[i] = '\0';
		s += buff;
	}
	return in;
}</code></pre> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p><br> 本篇博客就结束啦，谢谢大家的观看，如果公主少年们有好的建议可以留言喔，谢谢大家啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9144f92489f82a7836791190994a3be3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot项目报错解决：“Error starting ApplicationContext. To display the conditions report re-run ...”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92f1f3b5eab835f38b955ca7d6bf2603/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一键部署！QQ AI 聊天机器人！支持ChatGPT、文心一言、讯飞星火、Bing、Bard、ChatGLM、POE，多账号，人设调教</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>