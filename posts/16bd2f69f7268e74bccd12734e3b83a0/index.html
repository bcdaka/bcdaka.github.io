<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】数组实现队列（详细版） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/16bd2f69f7268e74bccd12734e3b83a0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】数组实现队列（详细版）">
  <meta property="og:description" content="目录
队列的定义
普通顺序队列的劣势——与链队列相比 顺序队列实现方法：
一、动态增长队列
1、初始化队列
2、元素入队
3、判断队列是否为空
4、元素出队
5、获取队首元素
6、获取队尾元素
7、获取队列元素个数
8、销毁队列
总结：
动态增长队列完整测试代码：
二、固定长度队列 1、与动态增长队列的差异
2、判断是否队满 固定长度队列完整测试代码：
本节我们采用数组（顺序表）形式实现队列，学习单链表实现请点击下方链接：
队列—单链表实现（C语言版）-CSDN博客
为了减少数组初始长度过大对内存空间的浪费，本节我们采用动态内存管理，相关函数请的介绍点击下方链接：
动态内存函数（malloc，free，calloc，realloc）-CSDN博客
循环队列的实现：
循环队列（数组实现）-CSDN博客
队列的定义 队列是一种基本的数据结构，它是一种先进先出（First In First Out，FIFO）的线性结构。队列只允许在表的一端进行插入，而在另一端进行删除操作。这就相当于把数据排成一排，先插入的排在前面，后插入的排在后面，之后进行删除操作时也只能从前面依次删除。这种数据结构一般用于需要按照先后顺序进行处理的问题，如模拟系统、计算机网络中的缓存、操作系统中的进程调度等。队列的基本操作包括入队（插入元素到队尾）和出队（从队头删除元素），队列还有一个重要的特性就是队列的长度是动态变化的，随着入队和出队的操作进行不断变化。
​​
普通顺序队列的劣势——与链队列相比 长度固定：普通数组队列的长度是固定的，一旦数组被分配，其长度无法改变。当队列元素数量超过数组长度时，需要进行数组的扩容操作，这会导致性能上的开销。
内存的浪费：因为普通数组队列的长度固定，可能会出现队列中存在空闲的位置，导致内存的浪费。
为了解决上述 问题1，我们在本节中对顺序表采取动态内存管理，在必要时更新数组的长度，以保证顺序队列的长度足够使用。
（补充：问题2 的解决需要使用循环队列，本节内容先为大家介绍一般队列的实现，等同学们对队列有了充分的理解之后，我们下节再进行循环队列的学习。）
顺序队列实现方法： 一、我们首先定义一个数组，数组的头部为队首，尾部为队尾。每当插入一个元素时，就将元素放在队尾，当删除一个元素时，将队首的元素删除。当队列为空时，不能再删除元素。
二、我们采用双指针法时刻记录队列的队首和队尾：
定义一个固定大小的数组作为队列的存储空间，并定义两个指针front和rear分别指向队列的队首和队尾。
初始化队列时，将front和rear都设置为0，表示队列为空。
插入元素时，将元素放入rear指针指向的位置，并将rear指针后移一位。
删除元素时，将front指针后移一位。
判断队列是否为空，只需要判断front和rear是否相等即可。
一、动态增长队列 1、初始化队列 初始化队列时，将front和rear都设置为0，表示队列为空。
typedef int DataType; typedef struct Queue { DataType* a; // 队列的数组 int front, rear; // 队列的头部和尾部位置索引 int size; // 队列中元素的数量 int capacity; // 队列的容量 } Queue; // 初始化队列 void InitQueue(Queue* q) { q-&gt;a = NULL; // 数组指针初始化为NULL q-&gt;front = q-&gt;rear = 0; // 头部和尾部位置索引初始化为0 q-&gt;size = q-&gt;capacity = 0; // 元素数量和容量都初始化为0 } 2、元素入队 // 入队 void QueuePush(Queue* q, DataType x) { assert(q); // 断言q不为NULL if (q-&gt;capacity == q-&gt;rear) { // 如果队列已满，进行扩容操作 int new_capacity = q-&gt;capacity == 0 ?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-01T17:41:54+08:00">
    <meta property="article:modified_time" content="2024-01-01T17:41:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】数组实现队列（详细版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">队列的定义</a></p> 
<p id="%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%8A%A3%E5%8A%BF%E2%80%94%E2%80%94%E4%B8%8E%E9%93%BE%E9%98%9F%E5%88%97%E7%9B%B8%E6%AF%94%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%8A%A3%E5%8A%BF%E2%80%94%E2%80%94%E4%B8%8E%E9%93%BE%E9%98%9F%E5%88%97%E7%9B%B8%E6%AF%94%C2%A0" rel="nofollow">普通顺序队列的劣势——与链队列相比 </a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">顺序队列实现方法：</a></p> 
<p id="%E5%8A%A8%E6%80%81%E5%A2%9E%E9%95%BF%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#%E5%8A%A8%E6%80%81%E5%A2%9E%E9%95%BF%E9%98%9F%E5%88%97" rel="nofollow">一、动态增长队列</a></p> 
<p id="%C2%A01%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#%C2%A01%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97" rel="nofollow"> 1、初始化队列</a></p> 
<p id="%C2%A02%E3%80%81%E5%85%83%E7%B4%A0%E5%85%A5%E9%98%9F-toc" style="margin-left:80px;"><a href="#%C2%A02%E3%80%81%E5%85%83%E7%B4%A0%E5%85%A5%E9%98%9F" rel="nofollow"> 2、元素入队</a></p> 
<p id="%C2%A03%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-toc" style="margin-left:80px;"><a href="#%C2%A03%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" rel="nofollow"> 3、判断队列是否为空</a></p> 
<p id="%C2%A04%E3%80%81%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F-toc" style="margin-left:80px;"><a href="#%C2%A04%E3%80%81%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F" rel="nofollow"> 4、元素出队</a></p> 
<p id="%C2%A05%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#%C2%A05%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0" rel="nofollow"> 5、获取队首元素</a></p> 
<p id="6%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0" rel="nofollow">6、获取队尾元素</a></p> 
<p id="%C2%A07%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A07%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow"> 7、获取队列元素个数</a></p> 
<p id="8%E3%80%81%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97" rel="nofollow">8、销毁队列</a></p> 
<p id="%C2%A0%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow"> 总结：</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">动态增长队列完整测试代码：</a></p> 
<p id="%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">二、固定长度队列 </a></p> 
<p id="1%E3%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%A2%9E%E9%95%BF%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%AE%E5%BC%82-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%A2%9E%E9%95%BF%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%AE%E5%BC%82" rel="nofollow">1、与动态增长队列的差异</a></p> 
<p id="2%E3%80%81%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%98%9F%E6%BB%A1%C2%A0-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%98%9F%E6%BB%A1%C2%A0" rel="nofollow">2、判断是否队满 </a></p> 
<p id="%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">固定长度队列完整测试代码：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>本节我们采用数组（顺序表）形式实现队列，学习单链表实现请点击下方链接：</p> 
<p><a href="https://blog.csdn.net/2301_76606232/article/details/135210622?spm=1001.2014.3001.5501" title="队列—单链表实现（C语言版）-CSDN博客">队列—单链表实现（C语言版）-CSDN博客</a></p> 
<p>为了减少数组初始长度过大对内存空间的浪费，本节我们采用动态内存管理，相关函数请的介绍点击下方链接：</p> 
<p><a href="https://blog.csdn.net/2301_76606232/article/details/133469728?spm=1001.2014.3001.5501" title="动态内存函数（malloc，free，calloc，realloc）-CSDN博客">动态内存函数（malloc，free，calloc，realloc）-CSDN博客</a></p> 
<p>循环队列的实现：</p> 
<p><a href="https://blog.csdn.net/2301_76606232/article/details/135280846?spm=1001.2014.3001.5501" title="循环队列（数组实现）-CSDN博客">循环队列（数组实现）-CSDN博客</a></p> 
<hr> 
<p id="main-toc"><br>  </p> 
<h3 id="%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89">队列的定义</h3> 
<p>队列是一种基本的数据结构，它是一种<strong>先进先出（First In First Out，FIFO）的线性结构</strong>。<strong>队列只允许在表的一端进行插入，而在另一端进行删除操作。</strong>这就相当于把数据排成一排，先插入的排在前面，后插入的排在后面，之后进行删除操作时也只能从前面依次删除。这种数据结构一般用于需要按照先后顺序进行处理的问题，如模拟系统、计算机网络中的缓存、操作系统中的进程调度等。队列的基本操作包括<strong>入队（插入元素到队尾）</strong>和<strong>出队（从队头删除元素）</strong>，队列还有一个重要的特性就是队列的长度是动态变化的，随着入队和出队的操作进行不断变化。</p> 
<p> ​​<img alt="" height="487" src="https://images2.imgbox.com/c9/af/sBvCJf0i_o.png" width="1200"></p> 
<h4 id="%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%8A%A3%E5%8A%BF%E2%80%94%E2%80%94%E4%B8%8E%E9%93%BE%E9%98%9F%E5%88%97%E7%9B%B8%E6%AF%94%C2%A0">普通顺序队列的劣势——与链队列相比 </h4> 
<ol><li> <p>长度固定：普通数组队列的长度是固定的，一旦数组被分配，其长度无法改变。当队列元素数量超过数组长度时，需要进行数组的扩容操作，这会导致性能上的开销。</p> </li><li> <p>内存的浪费：因为普通数组队列的长度固定，可能会出现队列中存在空闲的位置，导致内存的浪费。</p> </li></ol> 
<p>为了解决上述 <strong>问题1</strong>，我们在本节中对顺序表采取动态内存管理，在必要时更新数组的长度，以保证顺序队列的长度足够使用。</p> 
<p> （补充：<strong>问题2 </strong>的解决需要使用循环队列，本节内容先为大家介绍一般队列的实现，等同学们对队列有了充分的理解之后，我们下节再进行循环队列的学习。）</p> 
<hr> 
<h3 id="%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A">顺序队列实现方法：</h3> 
<p>一、我们首先定义一个数组，数组的头部为队首，尾部为队尾。每当插入一个元素时，就将元素放在队尾，当删除一个元素时，将队首的元素删除。当队列为空时，不能再删除元素。</p> 
<p>二、我们采用双指针法时刻记录队列的队首和队尾：</p> 
<ol><li> <p>定义一个固定大小的数组作为队列的存储空间，并定义两个指针front和rear分别指向队列的队首和队尾。</p> </li><li> <p>初始化队列时，将front和rear都设置为0，表示队列为空。</p> </li><li> <p>插入元素时，将元素放入rear指针指向的位置，并将rear指针后移一位。</p> </li><li> <p>删除元素时，将front指针后移一位。</p> </li><li> <p>判断队列是否为空，只需要判断front和rear是否相等即可。</p> 
  <hr><p></p> </li></ol> 
<h3 id="%E5%8A%A8%E6%80%81%E5%A2%9E%E9%95%BF%E9%98%9F%E5%88%97">一、动态增长队列</h3> 
<h4 id="%C2%A01%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97"> 1、初始化队列</h4> 
<p>初始化队列时，将front和rear都设置为0，表示队列为空。</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/35/ab/v9MMmbUd_o.png" width="1200"></p> 
<pre><code>typedef int DataType;

typedef struct Queue
{
    DataType* a; // 队列的数组
    int front, rear; // 队列的头部和尾部位置索引
    int size; // 队列中元素的数量
    int capacity; // 队列的容量
} Queue;

// 初始化队列
void InitQueue(Queue* q)
{
    q-&gt;a = NULL; // 数组指针初始化为NULL
    q-&gt;front = q-&gt;rear = 0; // 头部和尾部位置索引初始化为0
    q-&gt;size = q-&gt;capacity = 0; // 元素数量和容量都初始化为0
}</code></pre> 
<hr> 
<h4 id="%C2%A02%E3%80%81%E5%85%83%E7%B4%A0%E5%85%A5%E9%98%9F"> 2、元素入队</h4> 
<p><img alt="" height="822" src="https://images2.imgbox.com/2b/86/mESd8zSt_o.png" width="1200"></p> 
<pre><code>// 入队
void QueuePush(Queue* q, DataType x)
{
    assert(q); // 断言q不为NULL
    if (q-&gt;capacity == q-&gt;rear)
    {
        // 如果队列已满，进行扩容操作
        int new_capacity = q-&gt;capacity == 0 ? 10 : q-&gt;capacity * 2; // 扩容的大小为原容量的2倍
        DataType* temp = (DataType*)realloc(q-&gt;a, new_capacity * sizeof(DataType)); // 重新分配内存空间
        if (temp == NULL)
        {
            perror("realloc fail"); // 扩容失败，则输出错误信息
            exit(-1); // 退出程序
        }
        q-&gt;capacity = new_capacity; // 更新队列的容量
        q-&gt;a = temp; // 更新数组指针
    }
    q-&gt;a[q-&gt;rear++] = x; // 在尾部插入新元素，并更新尾部位置索引
    q-&gt;size++; // 元素数量加1
}
</code></pre> 
<hr> 
<h4 id="%C2%A03%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"> 3、判断队列是否为空</h4> 
<p>判断队列是否为空，只需要判断front和rear是否相等即可。</p> 
<pre><code>// 判断队列是否为空
bool QueueEmpty(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (q-&gt;front == q-&gt;rear)
    {
        return true; // 头部和尾部位置索引相等，队列为空
    }
    return false; // 队列不为空
}</code></pre> 
<hr> 
<h4 id="%C2%A04%E3%80%81%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F"> 4、元素出队</h4> 
<p> 删除元素时，将front指针后移一位。</p> 
<p><img alt="" height="709" src="https://images2.imgbox.com/1d/40/WiRRZTlo_o.png" width="1200"></p> 
<pre><code>void QueuePop(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        q-&gt;front++; // 更新头部位置索引
        q-&gt;size--; // 元素数量减1
    }
    else
    {
        printf("队列已空，删除失败！\n"); // 队列为空，无法出队
    }
}
</code></pre> 
<hr> 
<h4 id="%C2%A05%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0">5、获取队首元素</h4> 
<pre><code>// 获取队首元素
DataType QueueTop(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        return q-&gt;a[q-&gt;front]; // 返回队首元素的值
    }
    else
    {
        printf("队列已空，获取队头元素失败！\n"); // 队列为空，无法获取队首元素
        exit(-1); // 退出程序
    }
}</code></pre> 
<hr> 
<h4 id="6%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0">6、获取队尾元素</h4> 
<p>队尾指针q-&gt;rear在最后一个元素的下一位，所以我们返回队尾元素时需要返回队尾坐标的前一个坐标所指向的元素。</p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/88/ec/Vc3UrRgo_o.png" width="1200"></p> 
<pre><code>// 获取队尾元素
DataType QueueTail(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        return q-&gt;a[q-&gt;rear - 1]; // 返回队尾元素的值
    }
    else
    {
        printf("队列已空，获取队尾元素失败！\n"); // 队列为空，无法获取队尾元素
        exit(-1); // 退出程序
    }
}</code></pre> 
<hr> 
<h4 id="%C2%A07%E3%80%81%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">7、获取队列元素个数</h4> 
<pre><code>// 获取队列中元素的数量
int QueueSize(Queue* q)
{
    assert(q); // 断言q不为NULL
    return q-&gt;size; // 返回元素数量
}
</code></pre> 
<hr> 
<h4 id="8%E3%80%81%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97">8、销毁队列</h4> 
<pre><code>// 销毁队列
void QueueDestory(Queue* q)
{
    assert(q); // 断言q不为NULL
    free(q-&gt;a); // 释放队列的数组空间
    q-&gt;a = NULL; // 数组指针置为NULL
}</code></pre> 
<hr> 
<h4 id="%C2%A0%E6%80%BB%E7%BB%93%EF%BC%9A">总结：</h4> 
<p> 通过对顺序队列的学习我们可以明显看到顺序队列的缺点。当我们<strong>删除队首元素后</strong>，<strong>由于队列只能从队尾进行增加元素的操作，所以front指针之前的空间不能再进行使用</strong>。</p> 
<p>如果是在<strong>队列长度是固定长度</strong>的情况下，当队尾指针rear到达最大时，队列已满，数组内已经没有空间进行插入操作，但由于此时<strong>front指针前可能还有空余空间</strong>，这时我们就造成了空间的浪费。</p> 
<p>我们把这种现象称为“假溢出”现象。那么通过<strong>数组的循环队列</strong>或者<strong>链队列</strong>我们可以很好的解决此类现象。</p> 
<p>下节我们将对如何用数组实现循环队列进行介绍：<a href="https://blog.csdn.net/2301_76606232/article/details/135280846?spm=1001.2014.3001.5501" title="循环队列（数组实现）-CSDN博客">循环队列（数组实现）-CSDN博客</a></p> 
<p></p> 
<h4 id="%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A">动态增长队列完整测试代码：</h4> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int DataType;

typedef struct Queue
{
    DataType* a; // 队列的数组
    int front, rear; // 队列的头部和尾部位置索引
    int size; // 队列中元素的数量
    int capacity; // 队列的容量
} Queue;

// 初始化队列
void InitQueue(Queue* q)
{
    q-&gt;a = NULL; // 数组指针初始化为NULL
    q-&gt;front = q-&gt;rear = 0; // 头部和尾部位置索引初始化为0
    q-&gt;size = q-&gt;capacity = 0; // 元素数量和容量都初始化为0
}

// 判断队列是否为空
bool QueueEmpty(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (q-&gt;front == q-&gt;rear)
    {
        return true; // 头部和尾部位置索引相等，队列为空
    }
    return false; // 队列不为空
}

// 入队
void QueuePush(Queue* q, DataType x)
{
    assert(q); // 断言q不为NULL
    if (q-&gt;capacity == q-&gt;rear)
    {
        // 如果队列已满，进行扩容操作
        int new_capacity = q-&gt;capacity == 0 ? 10 : q-&gt;capacity * 2; // 扩容的大小为原容量的2倍
        DataType* temp = (DataType*)realloc(q-&gt;a, new_capacity * sizeof(DataType)); // 重新分配内存空间
        if (temp == NULL)
        {
            perror("realloc fail"); // 扩容失败，则输出错误信息
            exit(-1); // 退出程序
        }
        q-&gt;capacity = new_capacity; // 更新队列的容量
        q-&gt;a = temp; // 更新数组指针
    }
    q-&gt;a[q-&gt;rear++] = x; // 在尾部插入新元素，并更新尾部位置索引
    q-&gt;size++; // 元素数量加1
}

// 出队
void QueuePop(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        q-&gt;front++; // 更新头部位置索引
        q-&gt;size--; // 元素数量减1
    }
    else
    {
        printf("队列已空，删除失败！\n"); // 队列为空，无法出队
    }
}

// 获取队首元素
DataType QueueTop(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        return q-&gt;a[q-&gt;front]; // 返回队首元素的值
    }
    else
    {
        printf("队列已空，获取队头元素失败！\n"); // 队列为空，无法获取队首元素
        exit(-1); // 退出程序
    }
}

// 获取队尾元素
DataType QueueTail(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        return q-&gt;a[q-&gt;rear - 1]; // 返回队尾元素的值
    }
    else
    {
        printf("队列已空，获取队尾元素失败！\n"); // 队列为空，无法获取队尾元素
        exit(-1); // 退出程序
    }
}

// 获取队列中元素的数量
int QueueSize(Queue* q)
{
    assert(q); // 断言q不为NULL
    return q-&gt;size; // 返回元素数量
}

// 销毁队列
void QueueDestory(Queue* q)
{
    assert(q); // 断言q不为NULL
    free(q-&gt;a); // 释放队列的数组空间
    q-&gt;a = NULL; // 数组指针置为NULL
}

int main()
{
	Queue q;
	InitQueue(&amp;q);
	QueuePush(&amp;q, 5);
	QueuePush(&amp;q, 6);
	QueuePush(&amp;q, 7);
	QueuePush(&amp;q, 8);
	QueuePush(&amp;q, 9);
	QueuePush(&amp;q, 10);
	DataType x;
	x = QueueTop(&amp;q);
	printf("%d\n", x);
	x = QueueTail(&amp;q);
	printf("%d\n", x);
	QueuePop(&amp;q);
	QueuePop(&amp;q);
	QueuePop(&amp;q);
	QueuePop(&amp;q);
	QueuePop(&amp;q);
	x = QueueTop(&amp;q);
	printf("%d\n", x);
    x = QueueSize(&amp;q);
    printf("%d\n", x);
    QueueDestory(&amp;q);
    return 0;
}</code></pre> 
<hr> 
<h3 id="%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E9%98%9F%E5%88%97%C2%A0">二、固定长度队列 </h3> 
<h4 id="1%E3%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%A2%9E%E9%95%BF%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%AE%E5%BC%82">1、与动态增长队列的差异</h4> 
<p>由于固定长度队列<strong>无需扩容，所以不需要进行动态内存的分配，也</strong><strong>不需要进行销毁队列的操作</strong>。</p> 
<p>同时相对于动态增长的队列，<strong>固定长度的队列需要判断队内元素数量是否达到了队列的最大容量</strong>。由于我们在代码中是<strong>先对队尾指针rear指向的位置添加元素，再对rear进行自增</strong>，更新队尾索引，所以在本代码中队满的判断条件是<strong>rear==MAXLEN</strong>。</p> 
<p><img alt="" height="803" src="https://images2.imgbox.com/42/31/V2D1johz_o.png" width="1200"></p> 
<hr> 
<h4 id="2%E3%80%81%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%98%9F%E6%BB%A1%C2%A0">2、判断是否队满 </h4> 
<p>当对固定长度队列添加元素时，如果当前队列队尾指针已达到数组长度，由于队列只能从队尾添加元素，此时我们不能再为队列添加新的元素。所以在我们为队尾添加元素时，我们首先要判断队列是否已满——即队尾指针是否达到数组容量的最大值。</p> 
<p><img alt="" height="823" src="https://images2.imgbox.com/02/c5/jBH0yQxU_o.png" width="1200"></p> 
<pre><code>//判断队列是否为满
bool QueueFull(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (q-&gt;rear == MAXLEN)
    {
        return true; // 尾部位置达到数组长度最大值，队列为满
    }
    return false; // 队列不为满
}</code></pre> 
<p>明白了以上几点，我们对动态增长队列的代码稍作修改，<strong>添加判断队列是否已满的函数并对增加队列元素作出限制</strong>，就可得到固定长度队列的代码。</p> 
<p></p> 
<h4 id="%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A">固定长度队列完整测试代码：</h4> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

#define MAXLEN 10
typedef int DataType;

typedef struct Queue
{
    DataType a[MAXLEN]; // 队列的数组
    int front, rear; // 队列的头部和尾部位置索引
    int size; // 队列中元素的数量
} Queue;

// 初始化队列
void InitQueue(Queue* q)
{
    assert(q);
    q-&gt;front = q-&gt;rear = 0; // 头部和尾部位置索引初始化为0
    q-&gt;size = 0; // 元素数量初始化为0
}

// 判断队列是否为空
bool QueueEmpty(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (q-&gt;front == q-&gt;rear)
    {
        return true; // 头部和尾部位置索引相等，队列为空
    }
    return false; // 队列不为空
}

//判断队列是否为满
bool QueueFull(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (q-&gt;rear == MAXLEN)
    {
        return true; // 尾部位置达到数组长度最大值，队列为满
    }
    return false; // 队列不为满
}

// 入队
void QueuePush(Queue* q, DataType x)
{
    assert(q); // 断言q不为NULL
    if (!QueueFull(q))//判断队列是否为满
    {
        q-&gt;a[q-&gt;rear++] = x; // 在尾部插入新元素，并更新尾部位置索引
        q-&gt;size++; // 元素数量加1
    }
    else
    {
        printf("队列已满\n");
        exit(-1);
    }
}

// 出队
void QueuePop(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        q-&gt;front++; // 更新头部位置索引
        q-&gt;size--; // 元素数量减1
    }
    else
    {
        printf("队列已空，删除失败！\n"); // 队列为空，无法出队
    }
}

// 获取队首元素
DataType QueueTop(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        return q-&gt;a[q-&gt;front]; // 返回队首元素的值
    }
    else
    {
        printf("队列已空，获取队头元素失败！\n"); // 队列为空，无法获取队首元素
        exit(-1); // 退出程序
    }
}

// 获取队尾元素
DataType QueueTail(Queue* q)
{
    assert(q); // 断言q不为NULL
    if (!QueueEmpty(q))
    {
        return q-&gt;a[q-&gt;rear - 1]; // 返回队尾元素的值
    }
    else
    {
        printf("队列已空，获取队尾元素失败！\n"); // 队列为空，无法获取队尾元素
        exit(-1); // 退出程序
    }
}

// 获取队列中元素的数量
int QueueSize(Queue* q)
{
    assert(q); // 断言q不为NULL
    return q-&gt;size; // 返回元素数量
}


int main()
{
    Queue q;
    InitQueue(&amp;q);
    QueuePush(&amp;q, 5);
    QueuePush(&amp;q, 6);
    QueuePush(&amp;q, 7);
    QueuePush(&amp;q, 8);
    QueuePush(&amp;q, 9);
    QueuePush(&amp;q, 10);
    QueuePush(&amp;q, 5);
    QueuePush(&amp;q, 6);
    QueuePush(&amp;q, 7);
    QueuePush(&amp;q, 8);
    //QueuePush(&amp;q, 9);
    //QueuePush(&amp;q, 10);
    DataType x;
    x = QueueTop(&amp;q);
    printf("%d\n", x);
    x = QueueTail(&amp;q);
    printf("%d\n", x);
    QueuePop(&amp;q);
    QueuePop(&amp;q);
    QueuePop(&amp;q);
    QueuePop(&amp;q);
    QueuePop(&amp;q);
    x = QueueTop(&amp;q);
    printf("%d\n", x);
    x = QueueSize(&amp;q);
    printf("%d\n", x);
    return 0;
}</code></pre> 
<p>如果有同学在部分地方有疑惑，欢迎评论区讨论。</p> 
<p>本节内容告一段落，我们下节博客见。</p> 
<p><a href="https://blog.csdn.net/2301_76606232/article/details/135280846?spm=1001.2014.3001.5501" title="循环队列（数组实现）-CSDN博客">循环队列（数组实现）-CSDN博客</a></p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/31/99/k1EkqCaD_o.jpg" width="231"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb53ed9e05714b21b46733d7e51afe60/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Linux C | 文件I/O】fcntl函数详解 | 设置描述符非阻塞、文件(记录)锁</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e27b6c33926e02711775d5aa3121017/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python pygame贪吃蛇小游戏 (200行完整代码&#43;注释&#43;可运行）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>