<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[MySQL][复核查询][多表查询][自连接][自查询]详细讲解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/eb76d31cc2c29be7c1c81e1f1aadb981/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[MySQL][复核查询][多表查询][自连接][自查询]详细讲解">
  <meta property="og:description" content="目录 1.铺垫&amp;基本查询回顾1.多表查询1.何为笛卡尔积？2.示例 2.自连接1.何为自连接？2.示例 3.子查询1.何为子查询？2.单行子查询3.多行子查询4.多列子查询5.在from子句中使用子查询6.合并查询 1.铺垫&amp;基本查询回顾 前面讲解的MYSQL表的查询都是对一张表进行查询，在实际开发中这远远不够解决多表问题的本质(指导思想) 想办法把多表转化成为单表所以MYSQL中，所有select的问题全部都可以转成单表问题 查询工资高于500或岗位为MANAGER的雇员，同时还要满足他们的姓名首字母为大写的Jselect * from EMP where (sal&gt;500 or job=&#39;MANAGER&#39;) and ename like &#39;J%&#39;; 按照部门号升序而雇员的工资降序排序select * from EMP order by deptno, sal desc; 使用年薪进行降序排序select ename, sal*12&#43;ifnull(comm,0) as &#39;年薪&#39; from EMP order by 年薪 desc; 显示工资最高的员工的名字和工作岗位select ename, job from EMP where sal = (select max(sal) from EMP); 显示工资高于平均工资的员工信息select ename, sal from EMP where sal&gt;(select avg(sal) from EMP); 显示每个部门的平均工资和最高工资select deptno, format(avg(sal), 2) , max(sal) from EMP group by deptno; 显示平均工资低于2000的部门号和它的平均工资select deptno, avg(sal) as avg_sal from EMP group by deptno having avg_sal&lt;2000; 显示每种岗位的雇员总数，平均工资select job,count(*), format(avg(sal),2) from EMP group by job; 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-18T00:05:00+08:00">
    <meta property="article:modified_time" content="2024-07-18T00:05:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[MySQL][复核查询][多表查询][自连接][自查询]详细讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_3" rel="nofollow">1.铺垫&amp;基本查询回顾</a></li><li><a href="#1_42" rel="nofollow">1.多表查询</a></li><li><ul><li><a href="#1_44" rel="nofollow">1.何为笛卡尔积？</a></li><li><a href="#2_49" rel="nofollow">2.示例</a></li></ul> 
  </li><li><a href="#2_65" rel="nofollow">2.自连接</a></li><li><ul><li><a href="#1_67" rel="nofollow">1.何为自连接？</a></li><li><a href="#2_71" rel="nofollow">2.示例</a></li></ul> 
  </li><li><a href="#3_85" rel="nofollow">3.子查询</a></li><li><ul><li><a href="#1_87" rel="nofollow">1.何为子查询？</a></li><li><a href="#2_91" rel="nofollow">2.单行子查询</a></li><li><a href="#3_98" rel="nofollow">3.多行子查询</a></li><li><a href="#4_118" rel="nofollow">4.多列子查询</a></li><li><a href="#5from_130" rel="nofollow">5.在from子句中使用子查询</a></li><li><a href="#6_159" rel="nofollow">6.合并查询</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="1_3"></a>1.铺垫&amp;基本查询回顾</h2> 
<ul><li><font color="red"><strong>前面讲解的MYSQL表的查询都是对一张表进行查询，在实际开发中这远远不够</strong></font></li><li>解决<strong>多表</strong>问题的<font color="red"><strong>本质</strong></font>(指导思想) 
  <ul><li><font color="red"><strong>想办法把多表转化成为单表</strong></font></li><li>所以MYSQL中，所有select的问题全部都可以转成单表问题</li></ul> </li><li>查询工资高于500或岗位为MANAGER的雇员，同时还要满足他们的姓名首字母为大写的J<pre><code class="prism language-mysql">select * from EMP where (sal&gt;500 or job='MANAGER') and ename like 'J%';
</code></pre> </li><li>按照部门号升序而雇员的工资降序排序<pre><code class="prism language-mysql">select * from EMP order by deptno, sal desc;
</code></pre> </li><li>使用年薪进行降序排序<pre><code class="prism language-mysql">select ename, sal*12+ifnull(comm,0) as '年薪' from EMP order by 年薪 desc;
</code></pre> </li><li>显示工资最高的员工的名字和工作岗位<pre><code class="prism language-mysql">select ename, job from EMP where sal = (select max(sal) from EMP);
</code></pre> </li><li>显示工资高于平均工资的员工信息<pre><code class="prism language-mysql">select ename, sal from EMP where sal&gt;(select avg(sal) from EMP);
</code></pre> </li><li>显示每个部门的平均工资和最高工资<pre><code class="prism language-mysql">select deptno, format(avg(sal), 2) , max(sal) from EMP group by deptno;
</code></pre> </li><li>显示平均工资低于2000的部门号和它的平均工资<pre><code class="prism language-mysql">select deptno, avg(sal) as avg_sal from EMP group by deptno having avg_sal&lt;2000;
</code></pre> </li><li>显示每种岗位的雇员总数，平均工资<pre><code class="prism language-mysql">select job,count(*), format(avg(sal),2) from EMP group by job;
</code></pre> </li></ul> 
<hr> 
<h2><a id="1_42"></a>1.多表查询</h2> 
<h3><a id="1_44"></a>1.何为笛卡尔积？</h3> 
<ul><li>实际开发中往往数据来自不同的表，所以需要<font color="red"><strong>多表查询</strong></font><br> <img src="https://images2.imgbox.com/a1/34/bFCt2k70_o.png" alt="请添加图片描述"></li></ul> 
<h3><a id="2_49"></a>2.示例</h3> 
<ul><li>显示雇员名、雇员工资以及所在部门的名字因为上面的数据来自EMP和DEPT表，因此要联合查询 
  <ul><li>其实只要emp表中的deptno = dept表中的deptno字段的记录</li></ul> <pre><code class="prism language-mysql">select EMP.ename, EMP.sal, DEPT.dname from EMP, DEPT where EMP.deptno = DEPT.deptno;
</code></pre> </li><li>显示部门号为10的部门名，员工名和工资<pre><code class="prism language-mysql">select ename, sal,dname from EMP, DEPT where EMP.deptno=DEPT.deptno and DEPT.deptno = 10;
</code></pre> </li><li>显示各个员工的姓名，工资，及工资级别<pre><code class="prism language-mysql">select ename, sal, grade from EMP, SALGRADE where EMP.sal between losal and hisal;
</code></pre> </li></ul> 
<hr> 
<h2><a id="2_65"></a>2.自连接</h2> 
<h3><a id="1_67"></a>1.何为自连接？</h3> 
<ul><li><font color="red"><strong>自连接是指在同一张表内连接查询</strong></font></li></ul> 
<h3><a id="2_71"></a>2.示例</h3> 
<ul><li>显示员工FORD的上级领导的编号和姓名(mgr是员工领导的编号–empno)</li><li><strong>使用子查询</strong><pre><code class="prism language-mysql">select empno,ename from emp where emp.empno=(select mgr from emp where ename='FORD');
</code></pre> </li><li><strong>使用多表查询(自查询)</strong><pre><code class="prism language-mysql"># from emp leader, emp worker，给自己的表起别名，因为要先做笛卡尔积，所以别名可以先识别
select leader.empno,leader.ename from emp leader, emp worker
where leader.empno = worker.mgr and worker.ename='FORD';
</code></pre> </li></ul> 
<hr> 
<h2><a id="3_85"></a>3.子查询</h2> 
<h3><a id="1_87"></a>1.何为子查询？</h3> 
<ul><li>子查询是指嵌入在其他sql语句中的select语句，也叫<font color="red"><strong>嵌套查询</strong></font></li></ul> 
<h3><a id="2_91"></a>2.单行子查询</h3> 
<ul><li><font color="red"><strong>返回一行记录的子查询</strong></font></li><li><strong>示例</strong>：显示SMITH同一部门的员工<pre><code class="prism language-mysql">select * from EMP WHERE deptno = (select deptno from EMP where ename='smith');
</code></pre> </li></ul> 
<h3><a id="3_98"></a>3.多行子查询</h3> 
<ul><li><font color="red"><strong>返回多行记录的子查询</strong></font></li><li><font color="red"><strong>in</strong></font>关键字 
  <ul><li>查询和10号部门的工作岗位相同的雇员的名字，岗位，工资，部门号，但是不包含10自己的</li></ul> <pre><code class="prism language-mysql">select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10) and deptno&lt;&gt;10;
</code></pre> </li><li><font color="red"><strong>all</strong></font>关键字 
  <ul><li>显示工资比部门30的<strong>所有</strong>员工的工资高的员工的姓名、工资和部门号</li><li>以下两种写法结果相同，<strong>感受all的作用</strong></li></ul> <pre><code class="prism language-mysql">select * from emp where sal &gt; (select max(sal) from emp where deptno=30);  
select ename, sal, deptno from EMP where sal &gt; all(select sal from EMP where deptno=30);
</code></pre> </li><li><font color="red"><strong>any</strong></font>关键字 
  <ul><li>显示工资比部门30的<strong>任意</strong>员工的工资高的员工的姓名、工资和部门号(包含自己部门 的员工)</li></ul> <pre><code class="prism language-mysql">select ename, sal, deptno from EMP where sal &gt; any(select sal from EMP where deptno=30);
</code></pre> </li></ul> 
<h3><a id="4_118"></a>4.多列子查询</h3> 
<ul><li>单行子查询是指子查询只返回单列，单行数据；多行子查询是指返回单列多行数据，都是针对单列而言的，<font color="red"><strong>而多列子查询则是指查询返回多个列数据的子查询语句</strong></font></li><li><strong>示例</strong>：查询和SMITH的部门和岗位完全相同的所有雇员，不含SMITH本人<pre><code class="prism language-mysql"># 以下两个写法结果相同，感受in的作用
select ename from EMP where (deptno, job)=(select deptno, job from EMP
where ename='SMITH') and ename &lt;&gt; 'SMITH';

select ename from EMP where (deptno, job) in (select deptno, job from EMP
where ename='SMITH') and ename &lt;&gt; 'SMITH';
</code></pre> </li></ul> 
<h3><a id="5from_130"></a>5.在from子句中使用子查询</h3> 
<ul><li>子查询语句出现在from子句中，这里要用到数据查询的技巧，<font color="red"><strong>把一个子查询当做一个临时表使用</strong></font></li><li><strong>示例：</strong></li><li>显示每个高于自己部门平均工资的员工的姓名、部门、工资、平均工资<pre><code class="prism language-mysql"># 获取各个部门的平均工资，将其看作临时表，再进行笛卡尔积筛选
select ename, deptno, sal, format(asal,2) from EMP, (select avg(sal) asal, deptno from EMP group by deptno) tmp 
where EMP.sal &gt; tmp.asal and EMP.deptno=tmp.deptno;
</code></pre> </li><li>查找每个部门工资最高的人的姓名、工资、部门、最高工资<pre><code class="prism language-mysql">select EMP.ename, EMP.sal, EMP.deptno, ms from EMP, (select max(sal) ms, deptno from EMP group by deptno) tmp
where EMP.deptno=tmp.deptno and EMP.sal=tmp.ms;
</code></pre> </li><li>显示每个部门的信息（部门名，编号，地址）和人员数量 
  <ul><li><strong>方法一：使用多表</strong>(不建议，比较笨&amp;暴力的方法，限制多，要照顾语法)<pre><code class="prism language-mysql">select DEPT.dname, DEPT.deptno, DEPT.loc, count(*) '部门人数' from EMP, DEPT
where EMP.deptno=DEPT.deptno group by DEPT.deptno, DEPT.dname, DEPT.loc;
</code></pre> </li><li><strong>方法二：使用子查询</strong>(也属于多表范畴)<pre><code class="prism language-mysql"># 1. 对EMP表进行人员统计
select count(*), deptno from EMP group by deptno;

# 2. 将上面的表看作临时表
select DEPT.deptno, dname, mycnt, loc from DEPT, (select count(*) mycnt, deptno from EMP group by deptno) tmp where DEPT.deptno=tmp.deptno;
</code></pre> </li></ul> </li></ul> 
<h3><a id="6_159"></a>6.合并查询</h3> 
<ul><li><strong>在实际应用中，<font color="red">为了合并多个select的执行结果</font>，可以使用集合操作符</strong> <font color="red"><strong>union，union all</strong></font></li><li><strong>union</strong>：该操作符用于<font color="red"><strong>取得两个结果集的并集</strong></font>，当使用该操作符时，会<font color="red"><strong>自动去掉结果集中的重复行</strong></font> 
  <ul><li><strong>示例</strong>：将工资大于2500或职位是MANAGER的人找出来</li></ul> <pre><code class="prism language-mysql">mysql&gt; select ename, sal, job from EMP where sal&gt;2500 union
    -&gt; select ename, sal, job from EMP where job='MANAGER';
+-------+---------+-----------+
| ename | sal     | job       |
+-------+---------+-----------+
| JONES | 2975.00 | MANAGER   |
| BLAKE | 2850.00 | MANAGER   |
| SCOTT | 3000.00 | ANALYST   |
| KING  | 5000.00 | PRESIDENT |
| FORD  | 3000.00 | ANALYST   |
| CLARK | 2450.00 | MANAGER   |
+-------+---------+-----------+
</code></pre> </li><li><font color="red"><strong>union all：</strong></font>该操作符用于<font color="red"><strong>取得两个结果集的并集</strong></font>，当使用该操作符时，<font color="red"><strong>不会去掉结果集中的重复行</strong></font> 
  <ul><li>**示例：**将工资大于25000或职位是MANAGER的人找出来</li></ul> <pre><code class="prism language-mysql">mysql&gt; select ename, sal, job from EMP where sal&gt;2500 union all
    -&gt; select ename, sal, job from EMP where job='MANAGER';
+-------+---------+-----------+
| ename | sal     | job       |
+-------+---------+-----------+
| JONES | 2975.00 | MANAGER   |
| BLAKE | 2850.00 | MANAGER   |
| SCOTT | 3000.00 | ANALYST   |
| KING  | 5000.00 | PRESIDENT |
| FORD  | 3000.00 | ANALYST   |
| JONES | 2975.00 | MANAGER   |
| BLAKE | 2850.00 | MANAGER   |
| CLARK | 2450.00 | MANAGER   |
+-------+---------+-----------+
</code></pre> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a9796c83a5333c49f1b3b398284e927/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CTFshow-web入门-rce-web29-124</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65b6d575855362f76d6702a23c58f6ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【AI大数据计算原理与代码实例讲解】流处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>