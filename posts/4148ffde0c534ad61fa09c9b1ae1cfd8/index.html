<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】初识数据结构之复杂度与链表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4148ffde0c534ad61fa09c9b1ae1cfd8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】初识数据结构之复杂度与链表">
  <meta property="og:description" content="【数据结构】初识数据结构之复杂度与链表 🔥个人主页：大白的编程日记
🔥专栏：C语言学习之路
文章目录 【数据结构】初识数据结构之复杂度与链表前言一.数据结构和算法1.1数据结构1.2算法1.3数据结构和算法的重要性 二.时间与空间复杂度2.1算法效率2.2算法的复杂度2.3时间复杂度的概念2.4大O的渐进表示法2.5时间复杂度计算举例 三.空间复杂度四.链表4.1链表的概念及结构4.2链表的分类4.3单链表的实现 后言 前言 哈喽，各位小伙伴大家好！今天我们开启全新的篇章，数据结构。简单来说数据结构就是数据在内存中的管理。今天给大家带来的是数据结构中的复杂度和链表的知识。话不多说，咱们进入正题！向大厂冲锋！
一.数据结构和算法 1.1数据结构 数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的 数据元素的集合。
1.2算法 算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为
输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。
1.3数据结构和算法的重要性 目前校园招聘笔试一般采用Online Judge形式， 一般都是20-30道选择题&#43;2道编程题，或者3-4道编程题。
2020奇安信秋招C/C&#43;&#43;
美团2021校招笔试
网易2021校招笔试C&#43;&#43;开发工程师
可以看出，现在公司对学生代码能力的要求是越来越高了，大厂笔试中几乎全是算法题而且难度大，中小长的笔试中才会有算法题。算法不仅笔试中考察，面试中面试官基本都会让现场写代码。而算法能力短期内无法快速提高了，至少需要持续半年以上算法训练积累，否则真正校招时笔试会很艰难，因此算法要早早准备。
二.时间与空间复杂度 2.1算法效率 如何衡量一个算法的好坏呢？比如对于以下斐波那契数列：
long long Fib(int N) { if(N &lt; 3) return 1; return Fib(N-1) &#43; Fib(N-2); } 斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？这就涉及到算法的复杂度了。
2.2算法的复杂度 复杂度分为空间复杂度和时间复杂度。算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。
因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
时间复杂度
时间复杂度主要衡量一个算法的运行快慢
空间复杂度
空间复杂度主要衡量一个算法运行所需要的额外空间。
在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。所以我们现在更关注算法的时间复杂度。
复杂度在校招中的考察 2.3时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一
个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
运行时间衡量
为啥不用运行时间衡量。因为算法运行的环境不同，跑出来的时间性能自然不同。我的电脑性能更好，相同因素下，表现的性能自然更好，但是我们衡量的是代码本身。 即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。
// 请计算一下Func1中&#43;&#43;count语句总共执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N ; &#43;&#43; i) { for (int j = 0; j &lt; N ; &#43;&#43; j) { &#43;&#43;count; } } for (int k = 0; k &lt; 2 * N ; &#43;&#43; k) { &#43;&#43;count; } int M = 10; while (M--) { &#43;&#43;count; } 我们计算出来的函数就是：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-14T18:38:46+08:00">
    <meta property="article:modified_time" content="2024-06-14T18:38:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】初识数据结构之复杂度与链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>【数据结构】初识数据结构之复杂度与链表</h2> 
<p><img src="https://images2.imgbox.com/91/17/1cYhxsQL_o.gif" alt=""></p> 
<p><font color="pink" size="4"><b>🔥个人主页</b>：<a href="https://blog.csdn.net/2301_81670477?spm=1011.2415.3001.5343"><font color="#33CCCC" size="4"><b>大白的编程日记</b></font></a></font></p> 
<p><font color="pink" size="4">🔥<strong>专栏</strong></font>：<a href="https://blog.csdn.net/2301_81670477/category_12572839.html"><font color="#33CCCC" size="4"><b>C语言学习之路</b></font></a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_0" rel="nofollow">【数据结构】初识数据结构之复杂度与链表</a></li><li><ul><li><a href="#_10" rel="nofollow">前言</a></li><li><a href="#_17" rel="nofollow">一.数据结构和算法</a></li><li><ul><li><a href="#11_18" rel="nofollow">1.1数据结构</a></li><li><a href="#12_21" rel="nofollow">1.2算法</a></li><li><a href="#13_25" rel="nofollow">1.3数据结构和算法的重要性</a></li></ul> 
   </li><li><a href="#_39" rel="nofollow">二.时间与空间复杂度</a></li><li><ul><li><a href="#21_40" rel="nofollow">2.1算法效率</a></li><li><a href="#22_56" rel="nofollow">2.2算法的复杂度</a></li><li><a href="#23_74" rel="nofollow">2.3时间复杂度的概念</a></li><li><a href="#24O_115" rel="nofollow">2.4大O的渐进表示法</a></li><li><a href="#25_169" rel="nofollow">2.5时间复杂度计算举例</a></li></ul> 
   </li><li><a href="#_263" rel="nofollow">三.空间复杂度</a></li><li><a href="#_339" rel="nofollow">四.链表</a></li><li><ul><li><a href="#41_340" rel="nofollow">4.1链表的概念及结构</a></li><li><a href="#42_377" rel="nofollow">4.2链表的分类</a></li><li><a href="#43_394" rel="nofollow">4.3单链表的实现</a></li></ul> 
   </li><li><a href="#_611" rel="nofollow">后言</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_10"></a>前言</h3> 
<blockquote> 
 <p>哈喽，各位小伙伴大家好！今天我们开启全新的篇章，数据结构。简单来说数据结构就是数据在内存中的管理。今天给大家带来的是数据结构中的复杂度和链表的知识。话不多说，咱们进入正题！向大厂冲锋！<br> <img src="https://images2.imgbox.com/5e/d6/v14LL5vj_o.gif" alt=""></p> 
</blockquote> 
<hr> 
<h3><a id="_17"></a>一.数据结构和算法</h3> 
<h4><a id="11_18"></a>1.1数据结构</h4> 
<blockquote> 
 <p>数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的 数据元素的集合。</p> 
</blockquote> 
<h4><a id="12_21"></a>1.2算法</h4> 
<blockquote> 
 <p>算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为<br> 输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。</p> 
</blockquote> 
<h4><a id="13_25"></a>1.3数据结构和算法的重要性</h4> 
<blockquote> 
 <p>目前校园招聘笔试一般采用Online Judge形式， 一般都是20-30道选择题+2道编程题，或者3-4道编程题。<br> <a href="https://www.nowcoder.com/test/35396318/summary" rel="nofollow">2020奇安信秋招C/C++</a><br> <a href="https://www.nowcoder.com/test/28665243/summary" rel="nofollow">美团2021校招笔试</a><br> <a href="https://www.nowcoder.com/test/27977147/summary" rel="nofollow">网易2021校招笔试C++开发工程师</a><br> <img src="https://images2.imgbox.com/f2/c5/nqqdACR2_o.png" alt=""><br> <img src="https://images2.imgbox.com/e0/34/ENonwXls_o.png" alt=""><br> <img src="https://images2.imgbox.com/46/04/W58p4DcH_o.png" alt=""><br> 可以看出，现在公司对学生代码能力的要求是越来越高了，大厂笔试中几乎全是算法题而且难度大，中小长的笔试中才会有算法题。算法不仅笔试中考察，面试中面试官基本都会让现场写代码。而算法能力短期内无法快速提高了，至少需要持续半年以上算法训练积累，否则真正校招时笔试会很艰难，因此算法要早早准备。</p> 
</blockquote> 
<h3><a id="_39"></a>二.时间与空间复杂度</h3> 
<h4><a id="21_40"></a>2.1算法效率</h4> 
<blockquote> 
 <p>如何衡量一个算法的好坏呢？比如对于以下斐波那契数列：</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>
 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？这就涉及到算法的复杂度了。</p> 
</blockquote> 
<h4><a id="22_56"></a>2.2算法的复杂度</h4> 
<blockquote> 
 <p>复杂度分为空间复杂度和时间复杂度。算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。<br> 因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。</p> 
</blockquote> 
<ul><li> <p>时间复杂度<br> 时间复杂度主要衡量一个算法的运行快慢</p> </li><li> <p>空间复杂度<br> 空间复杂度主要衡量一个算法运行所需要的额外空间。</p> </li></ul> 
<p>在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。所以我们现在更关注算法的时间复杂度。</p> 
<ul><li>复杂度在校招中的考察</li></ul> 
<p><img src="https://images2.imgbox.com/3b/9a/bSsqHyJo_o.png" alt=""><br> <img src="https://images2.imgbox.com/9c/dc/Qdd8yCFE_o.png" alt=""></p> 
<h4><a id="23_74"></a>2.3时间复杂度的概念</h4> 
<blockquote> 
 <p>时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一<br> 个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。</p> 
</blockquote> 
<ul><li>运行时间衡量<br> 为啥不用运行时间衡量。因为算法运行的环境不同，跑出来的时间性能自然不同。我的电脑性能更好，相同因素下，表现的性能自然更好，但是我们衡量的是代码本身。</li></ul> 
<p>即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。</p> 
<pre><code class="prism language-c"><span class="token comment">// 请计算一下Func1中++count语句总共执行了多少次？</span>
<span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token operator">++</span>count<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token operator">++</span>count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>M<span class="token operator">--</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token operator">++</span>count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们计算出来的函数就是：<br> <img src="https://images2.imgbox.com/11/90/QTq5ARzi_o.png" alt=""><br> <img src="https://images2.imgbox.com/6e/60/PbEZffjL_o.png" alt=""><br> 那如果现在我们要比较这三个算法的优略，该怎么比呢？</p> 
<p><img src="https://images2.imgbox.com/cd/d1/p6devdfh_o.png" alt=""></p> 
<blockquote> 
 <p>大家发现其实不太好比较，因为除了N可能还有一些系数和常数。那咋办呢？ 这时就可以用我们的大O的渐进表示法进行函数简化。</p> 
</blockquote> 
<h4><a id="24O_115"></a>2.4大O的渐进表示法</h4> 
<blockquote> 
 <p>大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。</p> 
</blockquote> 
<p>推导大O阶方法：</p> 
<ul><li>用常数1取代运行时间中的所有加法常数。<br> 我们想对函数进行大概的估算，那我们就需要保留影响最大的项，所以我们对常数项进行忽略。因为当N很大时，常数项对整个函数式结果的影响不大。<br> <img src="https://images2.imgbox.com/1a/c5/eEqYXTNA_o.png" alt=""><br> 可是当N很小时，常数项的影响反而时更大的。<br> <img src="https://images2.imgbox.com/dc/dd/mSCccO0k_o.png" alt=""></li></ul> 
<blockquote> 
 <p>但是当N很小时，我们认为这三个的性能时一样的，因为CPU的运算速度太快了。每秒至少在上亿次。所以当 N很小时，我们认为他们的性能都一样，所以我们只关注影响最大的一项。忽略常数项。</p> 
</blockquote> 
<ul><li>验证：<br> clock函数可以捕捉程序启动到某处执行的时间，单位时毫秒。</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//程序启动开始执行到这里的时间，单位时毫秒</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sum<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d time:%d"</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span>end<span class="token operator">-</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3c/a1/wofIjFgI_o.png" alt=""><br> 大家发现我们循环一亿次只用了40ms。</p> 
<ul><li> <p>在修改后的运行次数函数中，只保留最高阶项。<br> 忽略常数项后，我们只保留最高阶的项，也就是影响最大的项。</p> </li><li> <p>如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。<br> 因为当N趋向于无穷大的时候，系数可以忽略。我们只关注N很大的情况，N很小的时候没有意义，因为CUP运算速度太快了。可以理解为无穷的倍数还是无穷大。</p> </li></ul> 
<blockquote> 
 <p>通过上面我们会发现大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。</p> 
 <p>另外有些算法的时间复杂度存在最好、平均和最坏情况：<br> 最坏情况：任意输入规模的最大运行次数(上界)<br> 平均情况：任意输入规模的期望运行次数<br> 最好情况：任意输入规模的最小运行次数(下界)</p> 
</blockquote> 
<ul><li>在一个长度为N数组中搜索一个数据x<br> 最好情况：1次找到<br> 最坏情况：N次找到<br> 平均情况：N/2次找到</li></ul> 
<blockquote> 
 <p>在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)</p> 
</blockquote> 
<h4><a id="25_169"></a>2.5时间复杂度计算举例</h4> 
<ul><li>题目一</li></ul> 
<pre><code class="prism language-c"><span class="token comment">// 计算Func3的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">Func3</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
   <span class="token operator">++</span>count<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
   <span class="token operator">++</span>count<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里我们看两个循环分别是N和M次，所以用大O的渐进表示法就是O(N+M).如果一个远远小于另外一个未知数，可以忽略掉。</p> 
<ul><li>题目二：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">// 计算Func4的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">Func4</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
   <span class="token operator">++</span>count<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>基本操作执行了10次，通过推导大O阶方法，时间复杂度为 O(1)。注意O（1）不是代表一次，代表常数次。</p> 
<ul><li>题目三：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">// 计算BubbleSort的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span> end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>end<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里我们要分最好情况和最坏情况看：<br> <img src="https://images2.imgbox.com/53/76/acQhpJg0_o.png" alt="在这里插入图片描述"><br> 最好遍历一遍，最坏遍历n-1遍。而我们只关注最坏情况，所以就是（n-1）*n/2。再用大O的渐进表示法即可。</p> 
<ul><li>题目四：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">// 计算BinarySearch的时间复杂度？</span>
<span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">// [begin, end]：begin和end是左闭右闭区间，因此有=号</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>
			begin <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> x<span class="token punctuation">)</span>
			end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/11/2c/ZLaOEPQv_o.png" alt=""></p> 
<h3><a id="_263"></a>三.空间复杂度</h3> 
<blockquote> 
 <p>空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度 。<br> 空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。<br> 空间复杂度计算规则基本跟实践复杂度类似，也使用大O渐进表示法。<br> 注意：函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。</p> 
</blockquote> 
<p>空间复杂度练习：</p> 
<ul><li>题目一：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">// 计算BubbleSort的空间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span> end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>end<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b5/d4/CfzKKZsQ_o.png" alt=""><br> 使用了常数个额外空间，所以空间复杂度为 O(1)</p> 
<ul><li>题目二：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">// 计算Fibonacci的空间复杂度？</span>
<span class="token comment">// 返回斐波那契数列的前n项</span>
<span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

	<span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span> fibArray <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	fibArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	fibArray<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		fibArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fibArray<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> fibArray<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> fibArray<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>动态开辟了N个空间，空间复杂度为 O(N)</p> 
<ul><li>题目三：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">// 计算阶乘递归Fac的空间复杂度？</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fac</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
 
 <span class="token keyword">return</span> <span class="token function">Fac</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>N<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>递归调用了N次，开辟了N个栈帧，每个栈帧使用了常数个空间。空间复杂度为O(N）</p> 
<p>常见复杂度对比：<br> <img src="https://images2.imgbox.com/1e/18/rv95oMw6_o.png" alt=""></p> 
<h3><a id="_339"></a>四.链表</h3> 
<h4><a id="41_340"></a>4.1链表的概念及结构</h4> 
<blockquote> 
 <p>概念：链表是⼀种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/77/93/9bcKqTVT_o.png" alt=""></p> 
<blockquote> 
 <p>链表的结构跟火车车厢相似，淡季时车次的车厢会相应减少，旺季时车次的车厢会额外增加⼏节。只需要将火车里的某节车厢去掉/加上，不会影响其他车厢，每节车厢都是独力存在的。<br> 车厢是独立存在的，且每节车厢都有车门。想象⼀下这样的场景，假设每节⻋厢的车门都是锁上的状态，需要不同的钥匙才能解锁，每次只能携带⼀把钥匙的情况下如何从车头走到车尾？<br> 最简单的做法：每节车厢里都放⼀把下⼀节车厢的钥匙。</p> 
</blockquote> 
<p>在链表里，每节“车厢”是什么样的呢？<br> <img src="https://images2.imgbox.com/20/c1/2zM8vBDB_o.png" alt=""></p> 
<blockquote> 
 <p>与顺序表不同的是，链表里的每节"车厢"都是独立申请下来的空间，我们称之为“结点/节点”节点的组成主要有两个部分：当前节点要保存的数据和保存下⼀个节点的地址（指针变量）。图中指针变量 plist保存的是第⼀个节点的地址，我们称plist此时“指向”第⼀个节点，如果我们希望plist“指向”第二个节点时，只需要修改plist保存的内容为0x0012FFA0。</p> 
</blockquote> 
<ul><li>为什么还需要指针变量来保存下⼀个节点的位置？<br> 链表中每个节点都是独立申请的（即需要插入数据时才去申请⼀块节点的空间），我们需要通过指针变量来保存下⼀个节点位置才能从当前节点找到下⼀个节点。</li></ul> 
<p>结合前面学到的结构体知识，我们可以给出每个节点对应的结构体代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">SListNode</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//节点数据假设当前保存的节点为整型：</span>
 <span class="token keyword">struct</span> <span class="token class-name">SListNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//指针变量⽤保存下⼀个节点的地址</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数据，也需要保存下⼀个节点的地址（当下⼀个节点为空时保存的地址为空）。</p> 
</blockquote> 
<p>当我们想要从第⼀个节点⾛到最后⼀个节点时，只需要在前⼀个节点拿上下⼀个节点的地址（下⼀个节点的钥匙）就可以了。这就是链表的遍历。</p> 
<ul><li>链表在逻辑上是连续的，在物理结构上不⼀定连续</li><li>节点⼀般是从堆上申请的，动态开辟的。</li><li>从堆上申请来的空间，是按照⼀定策略分配出来的，每次申请的空间可能连续，可能不连续</li><li>哨兵位节点<br> 哨兵位时一个链表的节点，但是这个链表什么也不用做，相当于一个放哨的，可以方便我们头插。</li></ul> 
<h4><a id="42_377"></a>4.2链表的分类</h4> 
<p>链表的结构非常多样，以下情况组合起来就有8种（2 x 2 x 2）链表结构：<br> <img src="https://images2.imgbox.com/b6/c1/AB5qLhnp_o.png" alt=""></p> 
<ul><li>单向或双向<br> <img src="https://images2.imgbox.com/32/84/xtbn3fmu_o.png" alt=""></li><li>带头或不带头<br> <img src="https://images2.imgbox.com/28/0c/BbwmhmZd_o.png" alt=""></li><li>循环不循环<br> <img src="https://images2.imgbox.com/e9/eb/NM7xNT3v_o.png" alt=""></li></ul> 
<p>虽然有这么多的链表的结构，但是我们实际中最常⽤还是两种结构：<br> 单链表和双向带头循环链表</p> 
<blockquote> 
 <ol><li>无头单向非循环链表：结构简单，⼀般不会单独⽤来存数据。实际中更多是作为其他数据结<br> 构的⼦结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。</li><li>带头双向循环链表：结构最复杂，⼀般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使⽤代码实现以后会发现结构会带 来很多优势，实现反而简单了，后⾯我们代码实现了就知道了。</li></ol> 
</blockquote> 
<h4><a id="43_394"></a>4.3单链表的实现</h4> 
<ul><li>定义链表节点<br> 定义链表节点，同时重命名节点结构体和数据类型。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> SLDataType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SListNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> SLDataType<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">SListNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>SLTNode<span class="token punctuation">;</span>
</code></pre> 
<ul><li>链表节点开辟</li></ul> 
<p>我们malloc开辟一个节点，然后判空。</p> 
<pre><code class="prism language-c">SLTNode<span class="token operator">*</span> <span class="token function">SLTBuyNode</span><span class="token punctuation">(</span>SLDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SLTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建新节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>newnode<span class="token punctuation">)</span><span class="token comment">//判断是否为空</span>
	<span class="token punctuation">{<!-- --></span>
		newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//置空</span>
		newnode<span class="token operator">-&gt;</span>SLDataType <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">//赋值</span>
		<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开辟空间失败</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
</code></pre> 
<ul><li>链表尾插<br> 我们开辟一个节点后，对链表判空。<br> 如果链表为空，则让新链表成为头节点。<br> 否则遍历链表找到尾节点，然后让尾节点对接新节点。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPushbak</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> phead<span class="token punctuation">,</span> SLDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言</span>
	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">SLTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>phead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//头节点为空</span>
		<span class="token operator">*</span>phead <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//新节点就是头节点</span>
	<span class="token keyword">else</span><span class="token comment">//头节点不为空</span>
	<span class="token punctuation">{<!-- --></span>
		SLTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> <span class="token operator">*</span>phead<span class="token punctuation">;</span><span class="token comment">//保存头节点</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token comment">//找尾</span>
		<span class="token punctuation">{<!-- --></span>
			pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		pcur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//尾节点对接</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表头插</li></ul> 
<p>开辟新节点，让新节点指针指向头节点。修改新节点为头节点。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPushPrin</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> phead<span class="token punctuation">,</span> SLDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言</span>
	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">SLTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开辟新结点</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token operator">*</span>phead<span class="token punctuation">;</span><span class="token comment">//指向头节点</span>
	<span class="token operator">*</span>phead <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//成为新结点</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表指定位置之后插入<br> 开辟新节点，让新节点指向pos位置后的节点，<br> 再让pos节点指向新节点。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STLInserafter</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> SLDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言</span>
	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">SLTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开辟新空间</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//新节点指向pos后的节点</span>
	pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//pos节点指向新节点</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表尾删<br> 断言检测链表时否为空。<br> 如果只有一个节点，直接free删除后让头节点指向空<br> 否则遍历链表找到倒数第二个节点，free删除尾节点，<br> 再让倒数第二个节点指向空。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STLPopback</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言，链表不能为空</span>
	SLTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> <span class="token operator">*</span>phead<span class="token punctuation">;</span><span class="token comment">//复制头节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//只有一个节点</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">free</span><span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">*</span>phead<span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//删除节点</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token comment">//找尾的前一个结点</span>
		<span class="token punctuation">{<!-- --></span>
			pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">free</span><span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除尾节点</span>
		pcur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//置空</span>
		pcur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表头删</li></ul> 
<p>断言检测链表为空。<br> 先保存当前头节点。<br> 先让头节点的下一个节点成为头节点。<br> 再free释放保存的头节点</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STLPopPrin</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token operator">&amp;&amp;</span><span class="token operator">*</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言</span>
	SLTNode<span class="token operator">*</span><span class="token operator">*</span> pcur <span class="token operator">=</span> <span class="token operator">*</span>phead<span class="token punctuation">;</span><span class="token comment">//复制头节点</span>
	<span class="token operator">*</span>phead <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>phead<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//指向下一个节点</span>
	<span class="token function">free</span><span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除头节点</span>
	pcur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//置空</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表指定位置删除</li></ul> 
<p>断言检测链表是否为空<br> 如果pos位置时头节点，直接头删。<br> 否则遍历找到pos的前节点，让pos前节点指向pos后节点，free删除pos节点</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STLErase</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> phead<span class="token punctuation">,</span> SLTNode<span class="token operator">*</span> pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SLTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> <span class="token operator">*</span>phead<span class="token punctuation">;</span><span class="token comment">//复制头节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pcur<span class="token operator">==</span> pos<span class="token punctuation">)</span><span class="token comment">//pos节点就是头节点</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">STLPopPrin</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//头删</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> pos<span class="token punctuation">)</span><span class="token comment">//找pos前节点</span>
		<span class="token punctuation">{<!-- --></span>
			pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		pcur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//pos前节点指向pos后节点</span>
		<span class="token function">free</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除pos节点</span>
		pos <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//置空</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表指定位置之后删除</li></ul> 
<p>断言检测链表是否为空<br> 保存pos后的节点，让pos节点指向pos的后后节点<br> free删除保存的pos后节点。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STLEraseafter</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span> pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&amp;&amp;</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言</span>
	SLTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//保存pos后节点</span>
	pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//pos指向pos后后节点</span>
	<span class="token function">free</span><span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除pos后节点</span>
	pcur<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表指定位置前插入</li></ul> 
<p>断言检测链表是否为空，开辟新结点<br> 如果pos位置时头节点，直接头插<br> 否则遍历找到pos前节点，让新节点指向pos节点<br> 让pos前节点指向新节点。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STLInser</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> phead<span class="token punctuation">,</span> SLTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> SLDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token operator">&amp;&amp;</span><span class="token operator">*</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//断言</span>
	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">SLTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开辟空间</span>
	SLTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> <span class="token operator">*</span>phead<span class="token punctuation">;</span><span class="token comment">//复制头节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> pcur<span class="token punctuation">)</span><span class="token comment">//头节点位前插</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">SLTPushPrin</span><span class="token punctuation">(</span>phead<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//头插</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> pos<span class="token punctuation">)</span><span class="token comment">//找pos前节点</span>
		<span class="token punctuation">{<!-- --></span>
			pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//移动</span>
		<span class="token punctuation">}</span>
		newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token punctuation">;</span><span class="token comment">//新节点指向pos节点</span>
		pcur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//pos前节点指向新节点</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表的查找<br> 遍历链表每次判断是否要查找的节点即可。</li></ul> 
<pre><code class="prism language-c">SLTNode<span class="token operator">*</span> <span class="token function">STLFind</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> SLDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SLTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> phead<span class="token punctuation">;</span><span class="token comment">//复制头节点</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token comment">//循环遍历</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>SLDataType <span class="token operator">==</span> x<span class="token punctuation">)</span><span class="token comment">//判断是否为目标值</span>
			<span class="token keyword">return</span> pcur<span class="token punctuation">;</span><span class="token comment">//返回目标节点</span>
		pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//不是继续遍历</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_611"></a>后言</h3> 
<blockquote> 
 <p>这就是数据结构中的的复杂度和链表，这些是数据结构的基础，正所谓“基础不牢 地动山摇”。我们要对这些基础多加巩固。今天就分享到这里！感谢各位小伙伴垂阅！咱们下期见！拜拜~</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6f/16/ClH6dWVq_o.gif" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd5cd81f4be165ea01d5714bf0a6897b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 期末复习 习题集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08fe71f5aa7d5a64fec1cc8929146ad7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac电脑-后端开发通用配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>