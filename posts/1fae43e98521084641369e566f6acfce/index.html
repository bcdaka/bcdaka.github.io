<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划：子序列问题（C&#43;&#43;） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1fae43e98521084641369e566f6acfce/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="动态规划：子序列问题（C&#43;&#43;）">
  <meta property="og:description" content="动态规划：子序列问题 前言子序列问题1.最长递增子序列（中等）2.摆动序列（中等）3.最长递增子序列的个数（中等）4.最长数对链（中等）5.最长定差子序列（中等）6.最长的斐波那契子序列的长度（中等）7.最长等差序列（中等）8.等差数列划分II - 子序列（困难） 前言 动态规划往期文章:
动态规划入门：斐波那契数列模型以及多状态动态规划：路径和子数组问题 子序列问题 1.最长递增子序列（中等） 链接：最长递增子序列
题目描述
做题步骤
状态表示
对于线性dp，我们通常采用下面两种表示:
(1)以某个位置为结尾，……
(2)以某个位置为起点，……
这两种方式我们通常采用第一种，以某个位置为结尾，再结合题目要求，我们可以定义状态表示为dp[i]：以i位置为结尾的所有子序列中，最长递增子序列的长度。
状态转移方程
对于以i位置为结尾的子序列，一共有两种可能：
(1)不接在别人后面，就自己一个，dp[i] = 1
(2)接在[0，1，2，……，i - 1]这些位置后面，设0 &lt;= j &lt;= i - 1，能保持子序列递增（nums[j] &lt; nums[i]）就可以接在该位置后面。
从0~i - 1枚举j，看接在那个位置后面长度最大：
即dp[i] = max(dp[i], dp[j] &#43; 1)
初始化
每个位置最小都为1，全都初始化为1。
填表顺序
保证填当前状态时，所需状态已经计算过，填表顺序为从左往右。
返回值
没法直接确定最长子序列的结尾位置，一边dp一边更新最大值。
代码实现 class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); //dp[i]表示以i位置为结尾的最长递增子序列 vector&lt;int&gt; dp(n, 1); int ret = 1; for(int i = 1; i &lt; n; i&#43;&#43;) { //从[0, i-1]看一圈，找接在那个符合条件的位置后面可以让子序列最长 for(int j = 0; j &lt; i; j&#43;&#43;) if(nums[j] &lt; nums[i]) dp[i] = max(dp[i], dp[j] &#43; 1); //看看能不能更新最大 ret = max(ret, dp[i]); } return ret; //时间复杂度：O(N ^ 2) //空间复杂度：O(N) } }; 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-16T20:18:07+08:00">
    <meta property="article:modified_time" content="2023-09-16T20:18:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划：子序列问题（C&#43;&#43;）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>动态规划：子序列问题</h4> 
 <ul><li><ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#_12" rel="nofollow">子序列问题</a></li><li><ul><li><a href="#1_14" rel="nofollow">1.最长递增子序列（中等）</a></li><li><a href="#2_81" rel="nofollow">2.摆动序列（中等）</a></li><li><a href="#3_155" rel="nofollow">3.最长递增子序列的个数（中等）</a></li><li><a href="#4_238" rel="nofollow">4.最长数对链（中等）</a></li><li><a href="#5_299" rel="nofollow">5.最长定差子序列（中等）</a></li><li><a href="#6_360" rel="nofollow">6.最长的斐波那契子序列的长度（中等）</a></li><li><a href="#7_437" rel="nofollow">7.最长等差序列（中等）</a></li><li><a href="#8II___506" rel="nofollow">8.等差数列划分II - 子序列（困难）</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_4"></a>前言</h3> 
<p><strong>动态规划往期文章:</strong></p> 
<ol><li><a href="https://blog.csdn.net/2301_76269963/article/details/132457291?spm=1001.2014.3001.5502">动态规划入门：斐波那契数列模型以及多状态</a></li><li><a href="https://blog.csdn.net/2301_76269963/article/details/132651497?spm=1001.2014.3001.5502">动态规划：路径和子数组问题</a></li></ol> 
<br> 
<h3><a id="_12"></a>子序列问题</h3> 
<h4><a id="1_14"></a>1.最长递增子序列（中等）</h4> 
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/" rel="nofollow">最长递增子序列</a></p> 
<ul><li> <p><strong>题目描述</strong><br> <img src="https://images2.imgbox.com/70/3e/UgecRHfy_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>做题步骤</strong></p> </li></ul> 
<ol><li> <p><strong>状态表示</strong><br> 对于线性dp，我们通常采用下面两种表示:<br> (1)以某个位置为结尾，……<br> (2)以某个位置为起点，……<br> 这两种方式我们通常采用第一种，以某个位置为结尾，再结合题目要求，我们可以定义状态表示为dp[i]：<font color="red">以i位置为结尾的所有子序列中，最长递增子序列的长度。</font></p> </li><li> <p><strong>状态转移方程</strong><br> 对于以i位置为结尾的子序列，一共有两种可能：<br> (1)不接在别人后面，就自己一个，dp[i] = 1<br> (2)接在[0，1，2，……，i - 1]这些位置后面，设0 &lt;= j &lt;= i - 1，<font color="red">能保持子序列递增</font>（nums[j] &lt; nums[i]）就可以接在该位置后面。<br> 从0~i - 1枚举j，看接在那个位置后面长度最大：<br> <font color="red">即dp[i] = max(dp[i], dp[j] + 1)</font></p> </li><li> <p><strong>初始化</strong><br> <font color="red">每个位置最小都为1，全都初始化为1。</font></p> </li><li> <p><strong>填表顺序</strong><br> 保证填当前状态时，所需状态已经计算过，<font color="red">填表顺序为从左往右</font>。</p> </li><li> <p><strong>返回值</strong><br> 没法直接确定最长子序列的结尾位置，<font color="red">一边dp一边更新最大值</font>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//dp[i]表示以i位置为结尾的最长递增子序列</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
       <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//从[0, i-1]看一圈，找接在那个符合条件的位置后面可以让子序列最长</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>       
                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         
            <span class="token comment">//看看能不能更新最大</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N ^ 2)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="2_81"></a>2.摆动序列（中等）</h4> 
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/wiggle-subsequence/" rel="nofollow">摆动序列</a></p> 
<ul><li> <p><strong>题目描述</strong><br> <img src="https://images2.imgbox.com/e3/15/zofzYE3A_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>做题步骤</strong></p> </li></ul> 
<ol><li> <p><strong>状态表示</strong><br> 依据前面的经验，我们依据可以定义状态表示为dp[i]：<font color="red">以i位置为结尾的所有摆动序列中的最大长度</font>。</p> </li><li> <p>状态转移方程<br> 对于长度大于1的摆动序列，其有两种情况：<br> (1)处于上升状态，比如(1, 7, 4, 9)。<br> (2)处于下降状态，比如(1, 17, 10)。<br> 因此我们需要同时记录两种状态，<font color="red">其中f[i]表示以i位置为结尾并处于上升状态的最长摆动序列长度，g[i]表示处于下降状态</font>。<br><br> 摆动序列分析完了，我们再来分析单个位置，一共有两种可能：<br> (1)不接在别人后面，自己玩，dp[i] = 1<br> (2)接在[0，1，2，……，i - 1]这些位置后面，设0 &lt;= j &lt;= i - 1。<br> ①如果<font color="red">接在j位置后处于上升状态</font>(nums[i] - nums[j] &gt; 0)，需要以j位置为结尾并处于下降状态的状态，即<font color="red">f[i] = g[j] + 1</font>。<br> ②如果<font color="red">接在j位置后处于下降状态</font>(nums[i] - nums[j] &lt; 0)，需要以j位置为结尾并处于上升状态的状态，即<font color="red">g[i] = f[j] + 1</font>。</p> </li><li> <p>初始化<br> <font color="red">序列长度最小为1，所有位置全都初始化为1</font>。</p> </li><li> <p>填表顺序<br> 保证填当前状态时，所需状态已经计算过，<font color="red">填表顺序为从左往右</font>。</p> </li><li> <p>返回值<br> 没法直接确定最长摆动序列的结尾，所以<font color="red">一边dp一边更新最大值</font>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//dp[i]表示以i位置为结尾的最长摆动序列长度</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处于上升状态</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">g</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处于下降状态</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录最终结果</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> gap <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">//处于上升</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//处于下降</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//相同的情况为1不用处理</span>
            <span class="token punctuation">}</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>ret<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N ^ 2)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="3_155"></a>3.最长递增子序列的个数（中等）</h4> 
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/" rel="nofollow">最长递增子序列的个数</a></p> 
<ul><li> <p><strong>题目描述</strong><br> <img src="https://images2.imgbox.com/25/ad/MSuFUbpe_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>做题步骤</strong></p> </li></ul> 
<ol><li> <p><strong>状态表示</strong><br> 依据前面的经验，我们可以定义状态表示dp[i]：<font color="red">以i位置为结尾的最长递增子序列个数</font>。</p> </li><li> <p><strong>状态转移方程</strong><br> 要更新当前位置的最长递增子序列个数，无非是看接在那几个位置后面长度最大，但问题就在于现在只有前面位置的序列个数，没有长度，所以我们需要再加一个表来记录长度：<br> (1)<font color="red">count[i]：以i位置为结尾的最长递增子序列个数</font><br> (2)<font color="red">len[i]：以i位置为结尾的最长递增子序列长度</font><br><br> len[i]前面已经讲过，我们分析count[i]：<br> (1)不接在别人后面，最大长度就为1，count[i] = 1<br> (2)接在[0，1，2，……，i - 1]这些位置后面，设0 &lt;= j &lt;= i - 1，<font color="red">能保持子序列递增</font>（nums[j] &lt; nums[i]）就可以接在该位置后面。<br><br> 从0~i - 1枚举j，依据接在那个位置后面的长度进行分析：<br> ①比原来长度小(len[i] &gt; len[j] + 1)，不用管。<br> ②比原来长度大(len[i] &lt; len[j] + 1)，原来的序列个数无论多少都必须狠狠切割了，个数更新为更长的，即<font color="red">count[i] = count[j]</font>。<br> ③和原来长度一样(len[i] == len[j] + 1)，计数增加，即<font color="red">count[i] += count[j]</font>。</p> </li><li> <p><strong>初始化</strong><br> <font color="red">序列长度最小为1，全都初始化为1</font>。</p> </li><li> <p><strong>填表顺序</strong><br> 保证填当前状态时，所需状态已经计算过，<font color="red">填表顺序为从左往右</font>。</p> </li><li> <p><strong>返回值</strong><br> (1)完成了前面的工作，我们知道以每一个位置为结尾的最长递增子序列长度和个数，但是并不知道以那几个位置为结尾的序列最长，所以我们需要<font color="red">一边dp一边更新最大长度max_length</font>。<br> (2)知道了最大长度，我们只需要遍历一次count表，<font color="red">把长度为max_length的序列统计出来即可</font>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findNumberOfLIS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">count</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//f[i]表示以i位置为结尾的最长子序列个数</span>
        <span class="token keyword">auto</span> len <span class="token operator">=</span> count<span class="token punctuation">;</span> <span class="token comment">//g[i]表示以i位置为结尾的最长递增子序列长度</span>
        <span class="token keyword">int</span> max_length <span class="token operator">=</span> len<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">//找到了更加长的</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{<!-- --></span>
                        len<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> len<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//长度相同                 </span>
                        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>               
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            max_length <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>max_length<span class="token punctuation">,</span> len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//返回值</span>
        <span class="token comment">//遍历一次，计算最长序列个数</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      
            <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> max_length<span class="token punctuation">)</span>
                ret <span class="token operator">+=</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N ^ 2)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="4_238"></a>4.最长数对链（中等）</h4> 
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/" rel="nofollow">最长数对链</a></p> 
<ul><li> <p><strong>题目描述</strong><br> <img src="https://images2.imgbox.com/c1/fb/gDDn6l2m_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>做题步骤</strong></p> </li></ul> 
<ol><li> <p><strong>状态表示</strong><br> 依据前面经验，我们定义状态表示dp[i]：<font color="red">以i位置为结尾最长数对链长度</font>。</p> </li><li> <p><strong>状态转移方程</strong><br> 这个题目的分析其实和前面的最长递增子序列基本一致。<br> (1)不接在别人后面，自己玩，dp[i] = 1<br> (2)接在[0，1，2，……，i - 1]这些位置后面，设0 &lt;= j &lt;= i - 1，<font color="red">满足数对链要求</font>（pairs[j][1] &lt; pairs[i][0]）就可以接在该位置后面。<br> 从0~i - 1枚举j，看接在那个位置后面长度最大：<br> <font color="red">即dp[i] = max(dp[i], dp[j] + 1)</font></p> </li><li> <p><strong>初始化</strong><br> <font color="red">长度最小为1，全都初始化为1</font>。</p> </li><li> <p><strong>填表顺序</strong><br> 保证填当前状态时，所需状态已经计算过，<font color="red">填表顺序为从左往右</font>。</p> </li><li> <p><strong>返回值</strong><br> 没法直接确定最长数对链的结尾，所以<font color="red">一边dp一边更新最大值</font>。</p> </li></ol> 
<ul><li><strong>代码实现</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findLongestChain</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> pairs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>              
        <span class="token function">sort</span><span class="token punctuation">(</span>pairs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pairs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//先排序</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> pairs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//dp[i]表示以i位置为终点的最长长度</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//记录最长</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                      
                <span class="token keyword">if</span><span class="token punctuation">(</span>pairs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> pairs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//如果可以接在后面            </span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N ^ 2)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="5_299"></a>5.最长定差子序列（中等）</h4> 
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/" rel="nofollow">最长定差子序列</a></p> 
<ul><li> <p><strong>题目描述</strong><br> <img src="https://images2.imgbox.com/b8/f9/VdHVxUvK_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>做题步骤</strong></p> </li></ul> 
<ol><li> <p><strong>状态表示</strong><br> 依据前面的经验，我们定义状态表示dp[i]：<font color="red">以下标i位置为结尾的最长等差子序列长度</font>。</p> </li><li> <p><strong>状态转移方程</strong><br> 这个题目最好想的做法就是递增子序列的做法，但这样写会超时，我们可以分析一下原因：<br> (1)递增子序列可以接在很多位置的后面。<br> (2)等差子序列只能接在固定的位置后面，比如(1, 2, 3, 4)，difference为1，里面的4只能接在3后面，其它的判断都是多余的。<br><br> 那我们就换一种思路，还是(1, 2, 3, 4)，difference为1这个例子，我们在填4位置的时候，如果能够<font color="red">直接找到以3(arr[i] - difference)为结尾</font>的最长递增子序列就好了。<br> 我们可以<font color="red">把元素arr[i]与dp[i]绑定</font>，创建一个哈希表hash，我们可以直接在这个哈希表中做动态规划，那状态转移方程就为：<br> <font color="red">hash[i] = hash[arr[i] - difference] + 1</font>。</p> </li><li> <p><strong>初始化</strong><br> 在填表的时候，如果前置状态不存在，我们不单独处理(0加1变成1刚好对应自己一个的情况)。因此我们<font color="red">只需要把第⼀个元素放进哈希表中， hash[arr[0]] = 1即可</font>。</p> </li><li> <p><strong>填表顺序</strong><br> 保证填当前状态时，所需状态已经计算过，<font color="red">填表顺序为从左往右</font>。</p> </li><li> <p><strong>返回值</strong><br> 不确定最长等差子序列的结尾，所以<font color="red">一边dp一边更新最大值</font>。</p> </li></ol> 
<ul><li><strong>代码实现</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">longestSubsequence</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> difference<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 创建⼀个哈希表</span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span> <span class="token comment">// {arr[i], dp[i]}</span>
        hash<span class="token punctuation">[</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            hash<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> hash<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> difference<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> hash<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="6_360"></a>6.最长的斐波那契子序列的长度（中等）</h4> 
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/description/" rel="nofollow">最长的斐波那契子序列的长度</a></p> 
<ul><li> <p><strong>题目描述</strong><br> <img src="https://images2.imgbox.com/a8/8f/DvXONIA9_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>做题步骤</strong></p> </li></ul> 
<ol><li> <p><strong>状态表示</strong><br> 依据经验我们可能会定义状态表示为以i位置为结尾的最长斐波那契序列的长度，但这样定义有一个致命的问题：<font color="red">不知道接在某一个位置后能否构成斐波那契序列</font>。<br> 一个元素无法确定，但如果我们知道斐波那契序列的后两个元素，我们就可以推导出前一个元素，从而解决前面的问题。<br> 所以定义一个二维表<font color="red">dp[i][j]：以i，j位置为后两个元素的最长斐波那契序列的长度</font>。</p> </li><li> <p><strong>状态转移方程</strong><br> 规定 i 比 j 小，其中j从[2, n - 1]开始枚举，i从[1, j - 1]开始枚举。<br> 设 nums[i] = b, nums[j] = c ，那么这个<font color="red">序列的前⼀个元素就是 a = c - b</font> ，我们根据 a 的情况讨论：<br> (1)a存在，设其下标为k，并且 a &lt; b，这个时候c可以接在以a、b为结尾的斐波那契序列后面，则<font color="red">dp[i][j] = dp[k][i] + 1</font>。<br> (2)a存在，但是 b &lt; a &lt; c，这个时候只能b和c两个自己构成，<font color="red">dp[i][j] = 2</font>。<br> (3)a不存在，这个时候只能b和c两个自己构成，<font color="red">dp[i][j] = 2</font>。<br><br> 我们发现，在状态转移⽅程中，我们<font color="red">需要确定 a 元素的下标</font>。因此我们可以在 dp 之前，将所有的<font color="red">「元素 + 下标」绑定在⼀起</font>，放到哈希表中。</p> </li><li> <p><strong>初始化</strong><br> <font color="red">长度最小为2，全都初始化为2</font>。</p> </li><li> <p><strong>填表顺序</strong><br> <font color="red">固定最后一个数，枚举倒数第二个数</font>。</p> </li><li> <p><strong>返回值</strong><br> 不确定最长斐波那契子序列的结尾，所以<font color="red">一边dp一边更新最大值</font>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>   
    <span class="token keyword">int</span> <span class="token function">lenLongestFibSubseq</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//i-&gt;j</span>
        <span class="token comment">dp[i][j]表示以i,j为后两个的斐波那契数列最长长度</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> hash<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> former <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">//a b c，a &lt; b 并且a存在</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>former <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span>  hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>former<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>hash<span class="token punctuation">[</span>former<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//斐波那契序列最小为3，为2的情况返回0</span>
        <span class="token keyword">return</span> ret <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">?</span> ret <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N ^ 2)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="7_437"></a>7.最长等差序列（中等）</h4> 
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/" rel="nofollow">最长等差序列</a></p> 
<ul><li> <p><strong>题目描述</strong><br> <img src="https://images2.imgbox.com/9a/8f/rC6Hd8KY_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>做题步骤</strong></p> </li></ul> 
<ol><li> <p><strong>状态表示</strong><br> 和前面一道题类似，只有一个元素无法确定等差序列的样子，我们需要有后面两个元素才能确定，故定义一个二维表<font color="red">dp[i][j]：以i，j为后两个元素的最长等差子序列的长度</font>。</p> </li><li> <p><strong>状态转移方程</strong><br> 规定 i 比 j 小，设 nums[i] = b, nums[j] = c ，那么这个<font color="red">序列的前⼀个元素就是 a = 2 * nums[i] - nums[j] (等差序列的性质捏)</font> ，我们根据 a 的情况讨论：<br> (1)a存在，设其下标为k，这个时候c可以接在以a、b为结尾的序列后面，则<font color="red">dp[i][j] = dp[k][i] + 1</font>。<br> (2)a不存在，这个时候只能b和c两个自己构成，<font color="red">dp[i][j] = 2</font>。<br><br> 我们发现，在状态转移方程中，我们<font color="red">需要确定 a 元素的下标</font>。因此我们可以将所有的<font color="red">「元素 + 下标」绑定在⼀起</font>，放到哈希表中。对于这个题目哈希表有两种方案：<br> (1)<font color="red">在dp前就直接放入哈希表</font>，可能出现重复的元素（这个题目是乱序的，前面一题严格递增），要记录这些重复元素，需要让它们的下标形成一个数组，填表前要先遍历数组找到需要的下标，<font color="red">时间消耗很大，这个方案通过不了</font>。<br> (2)只能<font color="red">采取一边dp一边存入哈希表的方式，在i位置使用完后存入哈希表中</font>，但<font color="red">填表顺序必须固定倒数第二，枚举倒数第一</font>，不能采用上一题固定倒一，枚举倒二的填表方式。我们看这个例子：【0，2，4，4，4，6，8，4，9，4，4】，最后一个4固定，第一个4为倒数第二时，应该去找之前4的下标（这里前面是[0,2],没有4，意味着这个数不应该在哈希表中，但固定倒一，枚举倒二的填表方式使得哈希表中是有保存的，这个时候就完全乱了）</p> </li><li> <p><strong>初始化</strong><br> <font color="red">长度最小为2，全部初始化为2</font>。</p> </li><li> <p><strong>填表顺序</strong><br> <font color="red">填表顺序为固定倒数第二，枚举倒数第一</font>。</p> </li><li> <p><strong>返回值</strong><br> 不确定最长等差序列的结尾，所以<font color="red">一边dp一边更新最大值</font>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//dp[i][j]表示以i，j为结尾的最长等差数列长度</span>
    <span class="token keyword">int</span> <span class="token function">longestArithSeqLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span>       
        hash<span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//倒数第二个</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> former <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>former<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>hash<span class="token punctuation">[</span>former<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            hash<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O（N ^ 2）</span>
        <span class="token comment">//空间复杂度：O（N ^ 2）</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="8II___506"></a>8.等差数列划分II - 子序列（困难）</h4> 
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/arithmetic-slices-ii-subsequence/" rel="nofollow">等差数列划分II - 子序列</a></p> 
<ul><li> <p><strong>题目描述</strong><br> <img src="https://images2.imgbox.com/a5/14/BxDqWxmU_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>做题步骤</strong></p> </li></ul> 
<ol><li> <p><strong>状态表示</strong><br> 和前面一道题一致，只有一个元素无法确定等差序列的样子，我们需要有后面两个元素才能确定，故定义一个二维表<font color="red">dp[i][j]：以i，j为后两个元素的等差子序列个数</font>。</p> </li><li> <p><strong>状态转移方程</strong><br> 首先，这个题目不存在重复的等差子序列，只要组成的元素位置不同就视为不同子序列，比如[7,7,7,7,7]这个数组等差子序列个数高达16个。<br><br> 规定 i 比 j 小，设 nums[i] = b, nums[j] = c ，那么这个<font color="red">序列的前⼀个元素就是 a = 2 * nums[i] - nums[j] </font> ，我们根据 a 的情况讨论：<br> (1)a存在，这个时候c可以接在以a、b为结尾的序列后面。设a下标为k，这里下标情况就和前面不同了，因为可能存在多个a，我们需要用一个下标数组来记录不同位置的a下标，当k &lt; i时(a在i的前面)，<font color="red">dp[i][j] += dp[k][i] + 1</font>，这里的+1表示[a,b,c]这一组，<font color="red">把满足条件的a全部加起来即可</font>。<br> (2)a不存在，这个时候只能b和c两个自己构成，<font color="red">dp[i][j] = 2</font>。<br><br> 我们发现，在状态转移方程中，我们<font color="red">需要确定 a 元素的下标</font>。因此我们可以将所有的<font color="red">「元素 + 下标数组」绑定在⼀起</font>，放到哈希表中。</p> </li><li> <p><strong>初始化</strong><br> 无需初始化，默认为0。</p> </li><li> <p><strong>填表顺序</strong><br> 填表顺序为<font color="red">固定倒一，枚举倒二</font>。</p> </li><li> <p><strong>返回值</strong><br> 定义变量sum，<font color="red">一边dp一边累加</font>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">numberOfArithmeticSlices</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//dp[i][j]表示以i,j为结尾的等差数列个数，规定j &gt; i</span>
        <span class="token comment">//前置可能有存在多个，需要一一加起来</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> hash<span class="token punctuation">;</span> <span class="token comment">//数据和下标数组绑定</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            hash<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">long</span> <span class="token keyword">long</span> former <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//处理数据溢出</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>former<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> k <span class="token operator">:</span> hash<span class="token punctuation">[</span>former<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">//former必须在左边</span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> i<span class="token punctuation">)</span>
                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//这里的1表示[a,b,c]单独一组</span>
                        <span class="token keyword">else</span> <span class="token comment">//当前a下标不满足，后面的也一定不满足，可以直接跳出</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>      
                <span class="token punctuation">}</span>
                sum <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
        <span class="token comment">//相同数据不多的情况下</span>
        <span class="token comment">//时间复杂度：O(N ^ 2)</span>
        <span class="token comment">//空间复杂度：O(N ^ 2)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d028a3c1350fed56182b2f45da25912/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Centos7安装RabbitMQ与使用（超详细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c6d1fcb63915f0ea5c7935cb9b3d445/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构——二叉树提升</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>