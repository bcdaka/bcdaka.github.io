<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java——常用类库 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4dae73fbb22e058f00e706ad2c87c66b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java——常用类库">
  <meta property="og:description" content="Java类库是Java的应用程序接口(API)，通常以包的形式组织类库
1、java.lang:默认导入的包，提供程序设计的常用基础类和接口；
2、java.util:工具类库，提供包含集合框架、集合类、日期时间等工具类；
3、java.io:Java的标准输入输出流；
4、java.applet:实现Java Applet 小程序的类库；
5、java.net:提供实现网络应用与开发的类库；
6、java.sql:提供访问并处理存储在数据源(通常是关系型数据)中的数据；
7、java.awt和java.swing:提供用户构建图形用户界面的类库；
8、java.awt.event:图形界面中用户交互控制和事件相应类库；
字符串String 使用构造方法创建String类的对象 1、String s=new String();//生成一个空字符串
2、String s=new String(&#34;Hello Wrold&#34;);//生成一个有参数的新字符串
3、char a[]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}; String s=new String(a);//所得s=abc
4、char a[]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;} String s=new String(a,2,3);//s=cde //该处方法意思为，读取a的数组从下标为2开始读取，往后读三位
5、byte[] a={54,55,56}; String s=new String(a);//s=&#39;678&#39;因为&#39;6&#39;的unicode码为54
6、byte[] a={54,55,56}; String s=new String(a,1,2);//s=&#39;78&#39; //从下标1开始读取，往后读两位
String创建字符串对象区别：通过双引号自动创建的字符串对象存在于常量池，
通过构造方法创建的1字符串对象存在于堆内存；
String类中的成员方法 1、int n1=&#34;Hello World&#34;.length(); //获取字符串长度
2、String first=new String(&#34;ABC&#34;); sec=new String(&#34;abc&#34;) boolean bol=first.equals(sec);//此时为false
3、String first=new String(&#34;ABC&#34;); sec=new String(&#34;abc&#34;) boolean bol=first.equalsIgnoreCase(sec);//此时为true
4、String first=&#34;computer&#34;; first.startWith(&#34;com&#34;);//返回true,是否以com为前缀 5、String first=&#34;computer&#34;; first.endWith(&#34;ter&#34;);//返回true,是否以ter为后缀">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-19T23:43:56+08:00">
    <meta property="article:modified_time" content="2024-06-19T23:43:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java——常用类库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Java类库是Java的应用程序接口(API)，通常以包的形式组织类库</p> 
<p>                        1、java.lang:默认导入的包，提供程序设计的常用基础类和接口；</p> 
<p>                        2、java.util:工具类库，提供包含集合框架、集合类、日期时间等工具类；</p> 
<p>                        3、java.io:Java的标准输入输出流；</p> 
<p>                        4、java.applet:实现Java Applet 小程序的类库；</p> 
<p>                        5、java.net:提供实现网络应用与开发的类库；</p> 
<p>                        6、java.sql:提供访问并处理存储在数据源(通常是关系型数据)中的数据；</p> 
<p>                        7、java.awt和java.swing:提供用户构建图形用户界面的类库；</p> 
<p>                        8、java.awt.event:图形界面中用户交互控制和事件相应类库；</p> 
<h4 style="background-color:transparent;">字符串String</h4> 
<h5>        使用构造方法创建String类的对象</h5> 
<p>                1、String s=new String();//生成一个空字符串</p> 
<p>                2、String s=new String("Hello Wrold");//生成一个有参数的新字符串</p> 
<p>                3、char a[]={'a','b','c'};       String s=new String(a);//所得s=abc</p> 
<p>                4、char a[]={'a','b','c','d','e','f'}         String s=new String(a,2,3);//s=cde                                                        //该处方法意思为，读取a的数组从下标为2开始读取，往后读三位</p> 
<p>                5、byte[] a={54,55,56};         String s=new String(a);//s='678'因为'6'的unicode码为54</p> 
<p>                6、byte[] a={54,55,56};        String s=new String(a,1,2);//s='78'                                                                  //从下标1开始读取，往后读两位</p> 
<p>        String创建字符串对象区别：通过双引号自动创建的字符串对象存在于常量池，</p> 
<p>                                                      通过构造方法创建的1字符串对象存在于堆内存；</p> 
<h5>        String类中的成员方法</h5> 
<p>                1、int n1="Hello World".length(); //获取字符串长度</p> 
<p>                2、String first=new String("ABC");         sec=new String("abc")                                                             boolean bol=first.equals(sec);//此时为false</p> 
<p>                3、String first=new String("ABC");         sec=new String("abc")                                                             boolean bol=first.equalsIgnoreCase(sec);//此时为true</p> 
<p>                4、String first="computer";  first.startWith("com");//返回true,是否以com为前缀   </p> 
<p>                5、String first="computer";  first.endWith("ter");//返回true,是否以ter为后缀</p> 
<p>                6、public int compareTo(String s);//该方法是用来按照字典顺序对字符串进行比较</p> 
<p>                7、在String中用“==”比较判断两个字符串的引用是否相等，即地址是否相等</p> 
<p>                        而equals方法比较两个字符串的内容是否相等</p> 
<p>                   String  s1="abc",s2="abc";        s1==s2;//返回结果为true，此时用双引号创建字符串，两次出现相同的字符串就不再创建新的对象，直接把s1的值赋给s2，因此你他们两个地址相同。</p> 
<p>                String s3=new String("abc"),s4=new String("abc");   s3==s4;//返回结果为false,因为s3和s4是通过构造方法创建的对象，所以引用不同，是两个不同的对象。而用s3.equals(s4)返回结果为true，因为内容相同。</p> 
<p>                8、public int indexOf(String s);//从第一个字符开始寻找s字串首次出现的位置，返回的是位置的序号</p> 
<p>                9、public String substring(int start,int ends);//返回start开始到end结束截取的字符串</p> 
<p>                10、public String replace(char oldChar,char newChar);//用新字符串代替旧字符串</p> 
<p>                11、String str="Hello",s="Wrold";     String kk=str.concat(s);//字符串拼接</p> 
<p>                12、public void getChars(int start,int end,char c[],int offset)://将字符串从start到end-1位置的字符复制到字符数组c中，并从c的第offset个位置开始存放这些字符。</p> 
<p>                        public void toCharArray(); //将字符串中全部的字符复制到字符数组中，返回该数组的引用。</p> 
<p>                        public byte[] getBytes(); //将字符串转成字符数组</p> 
<pre><code>
public class CharacterDemo {
	public void test(String str) {
           //写一个方法并传一个字符串 
		char[] charArray=str.toCharArray();
            //将传入的字符串复制给字符数组
		for(int i=0;i&lt;charArray.length;i++) {
			if(Character.isDigit(charArray[i])){//判断指定的字符是否为数字
				System.out.println(charArray[i]+"是数字");
				continue;//如果是则当前循环跳出，进入下一次循环，判断下一个字符
			}
			if(Character.isLetter(charArray[i])) {
				if(Character.isUpperCase(charArray[i])) {//判断指定的字符是否是大写字母
					System.out.println(charArray[i]+"是一个大写字母");
				}
				else {
					System.out.println(charArray[i]+"是一个小写字母");
				}
				continue;
			}
			System.out.println(charArray[i]+"不是数字也不是字母");
		}
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		CharacterDemo cd=new CharacterDemo();
		cd.test("HaFo 2023!");
	}

}
</code></pre> 
<p>                13、public String[] split(String regex):返回基于regex拆分此字符串后形成的字符串数组</p> 
<p>                14、valueOf()方法用于将所传的值转为字符串</p> 
<h4>StringBuffer字符串</h4> 
<p>        由于String定义的字符串是不可改变的，只要改变就会生成新的对象，这样非常耗费内存空间，所以提出可改变字符串缓冲类——StringBuffer类，该类可以多次增删改字符串内容而不产生新对象，每个StringBuffer对象都有初始容量，只要字符串长度不超过它的容量，就不需要再分配新的内部缓冲容量，否则容量自动增大。</p> 
<p>        StringBuffer的方法：</p> 
<p>                1、StringBuffer append(type x);//type可以是字符串、字符数组，向StringBuffer创建的对象中添加；</p> 
<p>                2、public StringBuffer reserve();//字符串反转</p> 
<p>                3、public int capacity();//获取缓冲区的大小；</p> 
<pre><code>public class StringBufferDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		StringBuffer sb=new StringBuffer();
		sb.append(123);
		sb.append("abc");
		sb.append("de");
		char x=sb.charAt(1);//索引从0开始，所以是‘2’
		System.out.println("x="+x);
		String temp1=sb.toString();
		System.out.println("temp1="+temp1);
		String temp2=sb.reverse().toString();//反转
		System.out.println("temp2="+temp2);
	}

}
</code></pre> 
<h4>日期类</h4> 
<h5>        Date类</h5> 
<p>                1、public Date()无参构造方法，通过调用System的currentTimeMillis()方法来获取当前的时间戳，这个时间戳是从格林尼治时间1970年1月1日0时0分0秒到当前时间的1毫秒数；</p> 
<p>                2、public long getTime():可以将一个日期类型转换为long类型的数值，返回从格林尼治时间到Date对象所代表的时间之间经过的毫秒数；</p> 
<p>                3、public void setTime(long time):设置一个Date对象所代表从格林尼治时间到time毫秒的时间点；</p> 
<p>                4、public boolean before(Date when):判断Date对象所代表的时间点是否在when所代表的时间点之前 ；publi boolean after(Date when):判断Date对象代表的时间点是否在shen所代表的事件之前；</p> 
<pre><code>import java.util.Date;

public class Test {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Date now=new Date();//获取系统当前时间
		Date when=new Date(10201020097865L);//定义指定的时间
		boolean b1=now.after(when);//当前时间是否在when之后
		boolean b2=now.before(when);//当前时间是否在when之前
		Long d1=now.getTime(),d2=when.getTime();//获取时间的毫秒值
		System.out.println("now的值为："+now+"when的值为："+when);
		System.out.println("b1的值为："+b1+"b2的值为："+b2);
		System.out.println("d1的值为："+d1+"d2的值为："+d2);
	}
}
</code></pre> 
<h5>Calendar类</h5> 
<p>        Calendar用于表示日历，用于对日期进行操作或运算，是被abstract修饰的抽象类，不能new一个对象，只能用成员方法getInstance()来得到一个Calendar对象</p> 
<p>        Calendar rightNow=Calendar.getInstance();</p> 
<p>        1、public void set(int year,int month,int date,int hour,int minute,int second):将该日历对象的年、月、日、小时、分钟、秒分别设置为year、month、date、hour、minute、second</p> 
<p>        2、public int get(int field):返回给定日历字段field的值                                                                                   field可以取值为：Calendar.YEAR:表示年份；                                                                                                              Calendar.MONTH:表示月份；                                                                                                            Calendar.DAY_OF_MONTH:表示一个月中的某天；                                                                          Calendar.HOUR:表示小时；                                                                                                              Calendar.MINUTES:表示分钟；                                                                                                        Calendar.SECOND:表示秒；                                                                                                              Calendar.DAY_OF_YEAR:表示一年中的某天；                                                                                Calendar.DAY_OF_WEEK:表示一个星期中的某天；                                                                        Calendar.DAY_OF_WEEK_IN_MONTH:表示当前月中的第几个星期</p> 
<p>        </p> 
<pre><code>import java.util.Calendar;
import java.util.Date;

public class CalendarDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Calendar calendar=Calendar.getInstance();//现获得一个日历的对象
		calendar.setTime(new Date());//将建立的Date对象传给calendar,且将long类型的毫秒数转换为时间点
		System.out.println("现在的时间为"+new Date());
		String year=String.valueOf(calendar.get(Calendar.YEAR));
		String month=String.valueOf(calendar.get(Calendar.MONTH)+1);
				//这个地方加1是因为月份是从0开始的，即一月=0
		String day=String.valueOf(calendar.get(Calendar.DAY_OF_MONTH));
		String week=String.valueOf(calendar.get(calendar.DAY_OF_WEEK)-1);
				//这个地方减1的原因是，星期是从星期天到星期六，分别对应1-7，但是要从0开始计数为了让值转换为一个从0开始的索引
		System.out.println("当前时间为"+year+"年"+month+"月"+day+"日，星期"+week);
		long year2009=calendar.getTimeInMillis();//获得时间毫秒
		calendar.set(1998,9, 26);//重新给calendar一个时间
		long year1989=calendar.getTimeInMillis();//获得时间毫秒
		long days=(year2009-year1989)/(1000*60*60*24);//毫秒做差后换算为天数
		System.out.println("出生了"+days+"天");
	}

}
</code></pre> 
<h4>包装类</h4> 
<p>        由于六个基本数据类型没法创建对象，因此给六个基本数据类型封装成包装类；</p> 
<p>        Integer、Double、Character、Float、Byte、Long、Short；</p> 
<h5>        Integer：</h5> 
<p>                        1、public Integer(int value):构造一个以value为值的Integer对象</p> 
<p>                        2、public Integer(String s):将s转变为int型数据，并以该数据为值构造一个Integer对象；Integer i1=new Integer("99");即给"99"封装成Integer对象</p> 
<p>                        3、public int intValue()//返回Integer对象对应的int值</p> 
<p>                        4、public static Integer valueOf(int i);返回int 型参数i对应的Integer对象</p> 
<p>                        5、public int compareTo(Integer anotherInteger):在数字上面比较两个Integer对象</p> 
<p>        字符串与数值转换：</p> 
<p>                        1、public static byte parseByte(String s):字符串s转换为byte类型,此处的byte可以是short-parseShort、int-parseInt、long-parseInt、Float-parseFloat、float-parseFloat；</p> 
<p>                        2、public static valueOf(type var):将type类型的变量var转化为字符串，type是八种数据类型都可以；</p> 
<h5>Character:</h5> 
<p>        1、public static boolean isDigit(char ch):判断是否是数字；</p> 
<p>        2、public static boolean isLetter(char ch):判断是否是字母；</p> 
<p>        3、public static boolean isLLetterOrDigit(char ch):判断是否是数字和字母；</p> 
<p>        4、public static boolean isLowerCase(char ch):判断是否是小写字母；</p> 
<p>        5、public static boolean idUpperCase(char ch):判断是否是大写字母；</p> 
<p>        6、public static char toUpperCase(char ch):返回大写字母形式；</p> 
<p>        7、public static char toLowerCase(char ch):返回小写字母形式；</p> 
<h5>装箱与拆箱</h5> 
<p>        装箱：把基本数据类型用对应的包装类封装起来；</p> 
<p>        拆箱：将包装类的对象重新转化为基本数据类型；</p> 
<pre><code>//手动装箱和拆箱
public class IntegerDemo{
public static void main(String[] args){
    int i=0;
    Integer j=new Integer(i);//手动装箱操作
    int k=j.intValue();//手动拆箱操作
    System.out.println(k*k);
}
}

//自动装箱和拆箱
public class IntegerDemo{
    public static void main(String[] args){
        Integer j=100;//将int数据自动转换成Integer对象
        int k=j;//Integer对象自动转换为int数据
        System.out.println(++k);
    }
}</code></pre> 
<h3 style="background-color:transparent;">集合类</h3> 
<p>        数组可以存储同一数据类型的数据，但是长度固定不变，不适合在数组元素数量未知的情况下使用，而集合可以，但是集合只能存放对象；集合存放的是对象的引用(即对象的地址)，对象本身还是存放在堆内存中；集合元素数量是可改变的。</p> 
<h4>        集合简介</h4> 
<p>                Collections接口是集合层次框架的跟接口，是存储单一对象的集合(即每个位置保存的是单一的对象)。</p> 
<p>                        1、Collections接口有两个直接扩展的子类：List和Set</p> 
<p>                                List接口里存放的集合元素是有顺序的、可以重复的，该接口常用的实现类主要有ArrayList、Vector(顺序储存，支持元素的快速访问,但是插入、删除速度慢)，LinkedList(链式储存，元素插入、删除性能好)；</p> 
<p>                                Set接口中不按顺序存放集合元素，不允许重复元素存在，实现的类主要有HasSet、LinkedHashSet、TreeSet;</p> 
<p>                        2、Interator是用于遍历集合元素的接口，相当于指向集合元素的指针。大部分集合类都实现Interator接口，该接口方法</p> 
<p>                                 （1）public boolean hasNext():是否还有下一个元素；</p> 
<p>                                 （2）public Object next():指针移动到下一个元素，并返回下一个元素对象；</p> 
<p>                                 （3）public void remove():删除当前指针指向的元素；</p> 
<p>                        3、Map是另一种集合接口，与Collections接口没有关系，Map集合中存放的是键值对，而不是一个单独的对象，键不能重复，值可以重复。</p> 
<h5>Collection接口</h5> 
<p>        1、add(Object obj)：将对象加入集合中;</p> 
<p>        2、clear()：清除当前集合的所有元素；</p> 
<p>        3、contains(Object obj)：判断当前集合中是否包含obj对象；</p> 
<p>        4、iterator()：得到当前集合的迭代器；</p> 
<p>        5、remove(Object obj)：删除当前集合的obj对象；</p> 
<p>        6、size()：得到当前集合中元素的总数；</p> 
<p>        7、isEmpty()：判断当前集合是否为空；</p> 
<p>        8、toArray()：将当前集合的对象转化为对象数组；</p> 
<h5>Set接口</h5> 
<p>        实现类：1、HashSet:使用哈希表实现Set集合，允许存放null元素，不保证元素的排列顺序</p> 
<p>                       2、AbstractSet:所有Set的实现类直接或间接继承AbstractSet父类；</p> 
<p>                       3、LinkedHasSet:使用链表实现Set集合，用来给元素排序；</p> 
<p>                       4、TreeSet:使用二叉树实现Set集合，用来对元素进行排序；</p> 
<p>        构造方法：1、HasSet():构造出空HashSet对象，也可以给传一个指定集合的参数；</p> 
<pre><code>import java.util.HashSet;
import java.util.Set;

public class SetDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Set set=new HashSet();
		set.add("1");//这个1和后面的1不一样，所以输出的集合元素中有两个1
		set.add("a1");
		set.add("s1");
		set.add(new Double(12.8));
		set.add(new Integer(1));
		set.add("s1");
		System.out.println("set="+set);
        //集合中六个元素，输出五个元素，因为有类型一致的相同元素s1
		for(Object s:set) {
			System.out.println(" "+s);
        //集合的遍历，遍历输出集合中的元素
		}
	}

}
</code></pre> 
<h5>List接口</h5> 
<p>        成员方法：1、add(int index,Object obj):在集合index的位置插入obj对象；</p> 
<p>                           2、set(int index,Object obj):将index位置的元素用对象obj代替；</p> 
<p>                           3、get(int index):返回index位置的元素；</p> 
<p>                           4、listIterator():返回当前集合中元素的列表迭代器对象；</p> 
<p>        实现类： ArrayList、Vector、LinkedList;</p> 
<h5>Map集合</h5> 
<p>        成员方法：1、keySet():返回Map中包含的键的set集合；</p> 
<p>                          2、values():返回Map中包含的值的collection集合；</p> 
<p>                          3、entrySet():返回Map中包含的映射关系(键值对)的set集合；</p> 
<p>                          4、clear():清空整个集合；</p> 
<p>                          5、get(Object obj):根据关键字obj得到对应的值；</p> 
<p>                          6、put(Object key,Object vlaue):将键值对加入到当前的Map中；</p> 
<p>                          7、remove(Object obj):从当前Map中删除key代表的键值对；</p> 
<p>        实现类：1、HasMap采用哈希表算法实现Map接口，不能保证其元素的存储顺序(即不保证放入与取出的顺序一致)，也不允许重复；</p> 
<p>                        HashMap比较常用：</p> 
<p>                             </p> 
<pre><code class="hljs">import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class MapDemo {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Map map=new HashMap();//创建Map的集合
		map.put("studentid","001");//给Map集合中加上参数
		map.put("name", "张三");
		Set keySet=map.keySet();//获取键，产生键的集合
		Iterator keyIterator=keySet.iterator();//创建一个迭代器，指向集合中的键
		while(keyIterator.hasNext()) {
			System.out.print(keyIterator.next()+" ");//遍历集合中的键
		}
		Set entrySet=map.entrySet();//entry的集合
		Iterator entryIterator=entrySet.iterator();//创建一个迭代器，指向整个集合
		while(entryIterator.hasNext()) {
			System.out.print(entryIterator.next()+" ");//遍历集合中的没和对象
		}
		String name=(String) map.get("name");//这个name本身是Object类型，所以需要转换为String类型传给name
		System.out.println(name);
	}

}
</code></pre> 
<p>                       2、TreeMap采用红黑树算法实现Map接口，key会按照自然顺序或定制排序进行排序，也不允许重复；</p> 
<p>                       3、LinkedHasMap采用链表和哈希表算法实现Map接口，key会保证先后添加的顺序，不允许重复；</p> 
<h4>        集合的遍历</h4> 
<h5>                无序集合Set的遍历</h5> 
<p>                        1、迭代器遍历</p> 
<pre><code class="hljs">Iterator it=new Iterator();
while(it.hasNext()){//判断该迭代器中是否还有元素需要迭代，返回true和false
    System.out.println(it.next());//返回迭代器的下一个元素，指针下移
}</code></pre> 
<p>                        2、for-each遍历</p> 
<pre><code class="hljs">for(数据类型 循环变量：需要遍历的集合对象){
    循环体;
}

for(Object ob:list){
    System.out.println(ob);
}</code></pre> 
<h5 style="background-color:transparent;">                有序集合遍历</h5> 
<p>                        1、迭代器遍历</p> 
<pre><code class="hljs">List list=new ArrayList();
list.add("first");
list.add("second");
ListIterator it=list.ListIterator();
while(it.hasnext()){//判断该迭代器中是否还有元素需要迭代，返回true和false
    System.out.println(it.next());//返回迭代器的下一个元素，指针下移
}</code></pre> 
<p>                        2、for-each遍历【和无序遍历一样】</p> 
<p>                        3、for循环</p> 
<pre><code class="hljs">for(int i=0;i&lt;list.size();i++){
    Object obj=list.get(i);
}</code></pre> 
<p>                Map的遍历是先将键赋值给一个Set集合，遍历Set集合</p> 
<h4>Comparable和Comparator接口</h4> 
<h5>        Comparable</h5> 
<p>                Comparable是定义对象本身的内在默认的排序标准；</p> 
<p>                Comparable接口下有一个compareTo的抽象方法；</p> 
<pre><code class="hljs">public interface Comparable&lt;T&gt;{
    public int compareTo(T t);//返回值为一个整数
}//T是指泛型
//返回值大于零，表示当前对象大于t这个对象；等于，则相等；小于，则小于</code></pre> 
<h5>        Comparator       </h5> 
<p>                Comparator是在对象外部定义其他排序标准；</p> 
<p>                Comparator接口下有一个compare的抽象方法；</p> 
<pre><code class="hljs">public inerface Comparator&lt;T&gt;{
    int compare(T t1,T t2);
    //其他方法
}

</code></pre> 
<p>         </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a15a667a9509ae4ca277a7992e26f20/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】遍历二叉树（递归思想）--＞赋源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/535d13419b3c552b96d70a4b3a54e39c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【实战指南】SpringBoot结合Zookeeper/Nacos构建Dubbo微服务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>