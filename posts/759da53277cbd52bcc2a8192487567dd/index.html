<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三步实现Java的SM2前端加密后端解密 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/759da53277cbd52bcc2a8192487567dd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="三步实现Java的SM2前端加密后端解密">
  <meta property="og:description" content="秦医如毒，无药可解。
话不多说，先上需要用到的js文件下载链接 和 jsp前端代码。
第一步：下载两个必备的js文件—— crypto-js.js、sm2.js 。
它们的下载链接如下↓（该网页不魔法上网的话会很卡，毕竟github，建议卡的话就多重新加载几次，我差不多试了8次才进去）：
https://github.com/Saberization/SM2
进入网页，下载后拿取下方↓图片上的两个js就行：
然后，将这两js放到存放静态资源（static）的目录下，我放的是static中的sm2目录（sm2这个目录是我创的）
后面，在jsp的&lt;head&gt;&lt;/head&gt;中引入这两个js文件
&lt;!--jsp引入sm2，实现前端加密--&gt; &lt;script type=&#34;text/javascript&#34; src=&#34;${pageContext.request.contextPath}/static/sm2/crypto-js.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt; &lt;script type=&#34;text/javascript&#34; src=&#34;${pageContext.request.contextPath}/static/sm2/sm2.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt; 第二步：前端jsp代码实现，下方的代码写在jsp页面的&lt;script type=&#34;text/javascript&#34;&gt;&lt;/script&gt;中。
作用是，当调用下方↓函数的时候，会给你传入的值进行加密并返回。
注：【你生成的公钥】的生成方式可以在文章末尾的SM2Utils.java工具类中可以找到，是个main方法，一键生成，简单粗暴
&lt;!--sm2加密函数--&gt; function sm2EncryptPwd(data) { &lt;!--sm2公钥--&gt; var publicKey = &#39;你生成的公钥&#39;; return sm2Encrypt(data, publicKey, 1); } 至此，前端加密结束，进入后端解密环节——
后端需要的jar包是：bcprov-jdk15on-1.68.jar
注意！！！该jar包必须要1.60版本以上的，不然解密的时候会缺少必要的条件！！！并且我用的时候，本地环境是JDK1.8的，其他环境没试过，建议如有不同，先查一下。
&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.68&lt;/version&gt; &lt;/dependency&gt; 第三步：后端代码实现。
导入jar包后，就是必要的工具类实体类：SM2Utils.java
用工具类中我写的 getJieMiJieGuo() 方法解密。
该方法操作起来更简单些，只需要传入加密后的字符串，就可以返回解密的数据。
注: 除getJieMiJieGuo()方法外，其它方法都不是我所写，不保证能解密成功。
其中【你生成的公钥】和【你生成的私钥】可以通过工具类中的方法生成，生成完复制粘贴进去就行
注！后端和前端的公钥要保持一致！因为公钥私钥是配对使用的！
package com.test.common.utils; import org.apache.commons.net.util.Base64; import org.bouncycastle.asn1.gm.GMNamedCurves; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.InvalidCipherTextException; import org.bouncycastle.crypto.engines.SM2Engine; import org.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T12:26:14+08:00">
    <meta property="article:modified_time" content="2024-03-07T12:26:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三步实现Java的SM2前端加密后端解密</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><u>秦医如毒，无药可解。</u></p> 
<p>话不多说，先上需要用到的<strong><em>js文件下载链接  </em></strong>和  <strong><em>jsp前端代码</em></strong>。</p> 
<p><strong>第一步：</strong>下载两个必备的js文件—— <strong>crypto-js.js</strong>、<strong>sm2.js</strong> 。</p> 
<p>它们的下载链接如下↓（该网页不魔法上网的话会很卡，毕竟github，建议卡的话就多重新加载几次，我差不多试了8次才进去）：</p> 
<p><a class="link-info" href="https://github.com/Saberization/SM2" title="https://github.com/Saberization/SM2">https://github.com/Saberization/SM2</a></p> 
<p>进入网页，下载后拿取下方↓图片上的两个js就行：</p> 
<p><img src="https://images2.imgbox.com/f5/69/KiVqWDsf_o.png" alt="f9f5e8b673d246fcbdf9a08d95b7598a.png"></p> 
<p>然后，将这两js放到存放静态资源（static）的目录下，我放的是static中的sm2目录（sm2这个目录是我创的）</p> 
<p>后面，在jsp的&lt;head&gt;&lt;/head&gt;中引入这两个js文件</p> 
<pre><code class="language-javascript">&lt;!--jsp引入sm2，实现前端加密--&gt;
&lt;script type="text/javascript" src="${pageContext.request.contextPath}/static/sm2/crypto-js.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="${pageContext.request.contextPath}/static/sm2/sm2.js" charset="utf-8"&gt;&lt;/script&gt;</code></pre> 
<p><strong>第二步：</strong>前端jsp代码实现，下方的代码写在jsp页面的&lt;script type="text/javascript"&gt;&lt;/script&gt;中。</p> 
<p>作用是，当调用下方↓函数的时候，会给你传入的值进行加密并返回。</p> 
<p><strong>注：【你生成的公钥】的生成方式可以在文章末尾的SM2Utils.java工具类中可以找到，是个main方法，一键生成，简单粗暴</strong></p> 
<pre><code class="language-javascript">&lt;!--sm2加密函数--&gt;
function sm2EncryptPwd(data) {
		&lt;!--sm2公钥--&gt;
		var publicKey = '你生成的公钥';
		return sm2Encrypt(data, publicKey, 1);
}</code></pre> 
<p>至此，<em><u>前端加密结束，进入后端解密环节</u></em>——</p> 
<p>后端需要的jar包是：<strong>bcprov-jdk15on-1.68.jar</strong></p> 
<p><strong>注意！！！</strong><strong>该jar包必须要1.60版本以上的，不然解密的时候会缺少必要的条件！！！并且我用的时候，本地环境是JDK1.8的，其他环境没试过，建议如有不同，先查一下。</strong></p> 
<pre><code class="language-java">&lt;dependency&gt;
  &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
  &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
  &lt;version&gt;1.68&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p><strong>第三步：</strong>后端代码实现。</p> 
<p>导入jar包后，就是必要的工具类实体类：<strong>SM2Utils.java</strong></p> 
<p>用工具类中我写的<em> </em><strong><em>getJieMiJieGuo()</em> </strong>方法解密。</p> 
<p>该方法操作起来更简单些，只需要传入加密后的字符串，就可以返回解密的数据。</p> 
<p><strong>注:</strong> 除<strong><em>getJieMiJieGuo()</em></strong>方法外，其它方法都不是我所写，不保证能解密成功。</p> 
<p>其中【你生成的公钥】和【你生成的私钥】可以通过工具类中的方法生成，生成完复制粘贴进去就行</p> 
<p><strong>注！后端和前端的公钥要保持一致！因为公钥私钥是配对使用的！</strong></p> 
<pre><code class="language-java">package com.test.common.utils;

import org.apache.commons.net.util.Base64;
import org.bouncycastle.asn1.gm.GMNamedCurves;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.SM2Engine;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.spec.ECParameterSpec;
import org.bouncycastle.jce.spec.ECPrivateKeySpec;
import org.bouncycastle.jce.spec.ECPublicKeySpec;
import org.bouncycastle.util.encoders.Hex;

import java.math.BigInteger;
import java.security.*;
import java.security.spec.ECGenParameterSpec;

public class SM2Utils {

    private static final String publicKey = "你生成的公钥";
    private static final String privateKey = "你生成私钥";


    /**
     * 解密，并且获取解密后的字符串
     *
     * @return 秦无解
     */
    public static String getJieMiJieGuo(String cipherData) {
        byte[] cipherDataByte = Hex.decode(cipherData);
        BigInteger privateKeyD = new BigInteger(privateKey, 16);
        X9ECParameters sm2ECParameters1 = GMNamedCurves.getByName("sm2p256v1");
        ECDomainParameters domainParameters1 = new ECDomainParameters(sm2ECParameters1.getCurve(), sm2ECParameters1.getG(), sm2ECParameters1.getN());
        ECPrivateKeyParameters privateKeyParameters = new ECPrivateKeyParameters(privateKeyD, domainParameters1);

        //用私钥解密,SM2Engine.Mode.C1C3C2得加，不然就会报错invalid cipher text
        SM2Engine sm2Engine = new SM2Engine(SM2Engine.Mode.C1C3C2);
        sm2Engine.init(false, privateKeyParameters);

        //processBlock得到Base64格式，记得解码
        byte[] arrayOfBytes = null;
        try {
            arrayOfBytes = Base64.decodeBase64(sm2Engine.processBlock(cipherDataByte, 0, cipherDataByte.length));
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

        //得到明文：SM2 Encryption Test
        return new String(arrayOfBytes);
    }


    /**
     * @Description 生成秘钥对
     * @Author msx
     * @return KeyPair
     */
    public static KeyPair createECKeyPair() {
        //使用标准名称创建EC参数生成的参数规范
        final ECGenParameterSpec sm2Spec = new ECGenParameterSpec("sm2p256v1");

        // 获取一个椭圆曲线类型的密钥对生成器
        final KeyPairGenerator kpg;
        try {
            kpg = KeyPairGenerator.getInstance("EC", new BouncyCastleProvider());
            // 使用SM2算法域参数集初始化密钥生成器（默认使用以最高优先级安装的提供者的 SecureRandom 的实现作为随机源）
            // kpg.initialize(sm2Spec);

            // 使用SM2的算法域参数集和指定的随机源初始化密钥生成器
            kpg.initialize(sm2Spec, new SecureRandom());

            // 通过密钥生成器生成密钥对
            return kpg.generateKeyPair();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * @Description 公钥加密
     * @Author msx
     * @param publicKeyHex SM2十六进制公钥
     * @param data         明文数据
     * @return String
     */
    public static String encrypt1(String publicKeyHex, String data) {
        return encrypt(getECPublicKeyByPublicKeyHex(publicKeyHex), data, 1);
    }

    /**
     * @Description 公钥加密
     * @Author msx
     * @param data         明文数据
     * @return String
     */
    public static String encrypt(String data) {
        return encrypt(getECPublicKeyByPublicKeyHex(publicKey), data, 1);
    }

    /**
     * @Description 公钥加密
     * @Author msx
     * @param publicKey SM2公钥
     * @param data      明文数据
     * @param modeType  加密模式
     * @return String
     */
    public static String encrypt(BCECPublicKey publicKey, String data, int modeType) {
        //加密模式
        SM2Engine.Mode mode = SM2Engine.Mode.C1C3C2;
        if (modeType != 1) {
            mode = SM2Engine.Mode.C1C2C3;
        }
        //通过公钥对象获取公钥的基本域参数。
        ECParameterSpec ecParameterSpec = publicKey.getParameters();
        ECDomainParameters ecDomainParameters = new ECDomainParameters(ecParameterSpec.getCurve(),
                ecParameterSpec.getG(), ecParameterSpec.getN());
        //通过公钥值和公钥基本参数创建公钥参数对象
        ECPublicKeyParameters ecPublicKeyParameters = new ECPublicKeyParameters(publicKey.getQ(), ecDomainParameters);
        //根据加密模式实例化SM2公钥加密引擎
        SM2Engine sm2Engine = new SM2Engine(mode);
        //初始化加密引擎
        sm2Engine.init(true, new ParametersWithRandom(ecPublicKeyParameters, new SecureRandom()));
        byte[] arrayOfBytes = null;
        try {
            //将明文字符串转换为指定编码的字节串
            byte[] in = data.getBytes("utf-8");
            //通过加密引擎对字节数串行加密
            arrayOfBytes = sm2Engine.processBlock(in, 0, in.length);
        } catch (Exception e) {
            System.out.println("SM2加密时出现异常:" + e.getMessage());
            e.printStackTrace();
        }
        //将加密后的字节串转换为十六进制字符串
        return Hex.toHexString(arrayOfBytes);
    }

    /**
     * @Description 私钥解密
     * @Author msx
     * @param privateKeyHex SM2十六进制私钥
     * @param cipherData    密文数据
     * @return String
     */
    public static String decrypt1(String privateKeyHex, String cipherData) {
        return decrypt(getBCECPrivateKeyByPrivateKeyHex(privateKeyHex), cipherData, 1);
    }

    /**
     * @Description 私钥解密
     * @Author msx
     * @param s
     * @param cipherData    密文数据
     * @return String
     */
    public static String decrypt(String s, String cipherData) {
        return decrypt(getBCECPrivateKeyByPrivateKeyHex(privateKey), cipherData, 1);
    }

    /**
     * @Description 私钥解密
     * @Author msx
     * @param privateKey SM私钥
     * @param cipherData 密文数据
     * @param modeType   解密模式
     * @return
     */
    public static String decrypt(BCECPrivateKey privateKey, String cipherData, int modeType) {
        //解密模式
        SM2Engine.Mode mode = SM2Engine.Mode.C1C3C2;
        if (modeType != 1) {
            mode = SM2Engine.Mode.C1C2C3;
        }
        //将十六进制字符串密文转换为字节数组（需要与加密一致，加密是：加密后的字节数组转换为了十六进制字符串）
        byte[] cipherDataByte = Hex.decode(cipherData);
        //通过私钥对象获取私钥的基本域参数。
        ECParameterSpec ecParameterSpec = privateKey.getParameters();
        ECDomainParameters ecDomainParameters = new ECDomainParameters(ecParameterSpec.getCurve(),
                ecParameterSpec.getG(), ecParameterSpec.getN());
        //通过私钥值和私钥钥基本参数创建私钥参数对象
        ECPrivateKeyParameters ecPrivateKeyParameters = new ECPrivateKeyParameters(privateKey.getD(),
                ecDomainParameters);
        //通过解密模式创建解密引擎并初始化
        SM2Engine sm2Engine = new SM2Engine(mode);
        sm2Engine.init(false, ecPrivateKeyParameters);
        String result = null;
        try {
            //通过解密引擎对密文字节串进行解密
            byte[] arrayOfBytes = sm2Engine.processBlock(cipherDataByte, 0, cipherDataByte.length);
            //将解密后的字节串转换为utf8字符编码的字符串（需要与明文加密时字符串转换成字节串所指定的字符编码保持一致）
            result = new String(arrayOfBytes, "utf-8");
        } catch (Exception e) {
            System.out.println("SM2解密时出现异常" + e.getMessage());
        }
        return result;
    }
    //椭圆曲线ECParameters ASN.1 结构
    private static X9ECParameters x9ECParameters = GMNamedCurves.getByName("sm2p256v1");
    //椭圆曲线公钥或私钥的基本域参数。
    private static ECParameterSpec ecDomainParameters = new ECParameterSpec(x9ECParameters.getCurve(), x9ECParameters.getG(), x9ECParameters.getN());

    /**
     * @Description 公钥字符串转换为 BCECPublicKey 公钥对象
     * @Author msx
     * @param pubKeyHex 64字节十六进制公钥字符串(如果公钥字符串为65字节首个字节为0x04：表示该公钥为非压缩格式，操作时需要删除)
     * @return BCECPublicKey SM2公钥对象
     */
    public static BCECPublicKey getECPublicKeyByPublicKeyHex(String pubKeyHex) {
        //截取64字节有效的SM2公钥（如果公钥首个字节为0x04）
        if (pubKeyHex.length() &gt; 128) {
            pubKeyHex = pubKeyHex.substring(pubKeyHex.length() - 128);
        }
        //将公钥拆分为x,y分量（各32字节）
        String stringX = pubKeyHex.substring(0, 64);
        String stringY = pubKeyHex.substring(stringX.length());
        //将公钥x、y分量转换为BigInteger类型
        BigInteger x = new BigInteger(stringX, 16);
        BigInteger y = new BigInteger(stringY, 16);
        //通过公钥x、y分量创建椭圆曲线公钥规范
        ECPublicKeySpec ecPublicKeySpec = new ECPublicKeySpec(x9ECParameters.getCurve().createPoint(x, y), ecDomainParameters);
        //通过椭圆曲线公钥规范，创建出椭圆曲线公钥对象（可用于SM2加密及验签）
        return new BCECPublicKey("EC", ecPublicKeySpec, BouncyCastleProvider.CONFIGURATION);
    }

    /**
     * @Description 私钥字符串转换为 BCECPrivateKey 私钥对象
     * @Author msx
     * @param privateKeyHex 32字节十六进制私钥字符串
     * @return BCECPrivateKey SM2私钥对象
     */
    public static BCECPrivateKey getBCECPrivateKeyByPrivateKeyHex(String privateKeyHex) {
        //将十六进制私钥字符串转换为BigInteger对象
        BigInteger d = new BigInteger(privateKeyHex, 16);
        //通过私钥和私钥域参数集创建椭圆曲线私钥规范
        ECPrivateKeySpec ecPrivateKeySpec = new ECPrivateKeySpec(d, ecDomainParameters);
        //通过椭圆曲线私钥规范，创建出椭圆曲线私钥对象（可用于SM2解密和签名）
        return new BCECPrivateKey("EC", ecPrivateKeySpec, BouncyCastleProvider.CONFIGURATION);
    }

    public static void main(String[] args) {
        String publicKeyHex = null;
        String privateKeyHex = null;
        KeyPair keyPair = createECKeyPair();
        PublicKey publicKey = keyPair.getPublic();
        if (publicKey instanceof BCECPublicKey) {
            //获取65字节非压缩缩的十六进制公钥串(0x04)
            publicKeyHex = Hex.toHexString(((BCECPublicKey) publicKey).getQ().getEncoded(false));
            System.out.println("----&gt;SM2公钥：" + publicKeyHex);
        }
        PrivateKey privateKey = keyPair.getPrivate();
        if (privateKey instanceof BCECPrivateKey) {
            //获取32字节十六进制私钥串
            privateKeyHex = ((BCECPrivateKey) privateKey).getD().toString(16);
            System.out.println("----&gt;SM2私钥：" + privateKeyHex);
        }

        /**
         * 公钥加密
         */
        String data = "=========待加密数据=========";

        //将十六进制公钥串转换为 BCECPublicKey 公钥对象
        String encryptData = encrypt1(publicKeyHex, data);
        System.out.println("----&gt;加密结果：" + encryptData);

        /**
         * 私钥解密
         */
        //将十六进制私钥串转换为 BCECPrivateKey 私钥对象
        data = decrypt1(privateKeyHex, encryptData);
        System.out.println("----&gt;解密结果：" + data);
    }
}

</code></pre> 
<p>最后，在后端接口中调用工具类的解密方法，就可以对前端传来的加密数据进行解密。</p> 
<p>至此，✿✿ヽ(°▽°)ノ✿撒花。</p> 
<p>此章暂时完结。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/efa29c84f9c3b3f455660b31411088c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">开源文生图大模型Playground v2.5发布：超越SD、DALL·E 3和 Midjourney</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b6fbb043077a7994561cf6cdd8bcc1e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端vue项目使用Decimal.js做加减乘除求余运算</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>