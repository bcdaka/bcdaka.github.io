<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL进阶篇】存储对象：视图、存储过程及触发器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cf94e036c6e29d735b760f62bb5570ca/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL进阶篇】存储对象：视图、存储过程及触发器">
  <meta property="og:description" content="一、视图 1、介绍 视图（view）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来定义视图的查询中使用的表（基表），并且是在使用视图时动态生成的。
通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。
2、操作语法 2.1、创建 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]
2.2、查询 查看创建视图语句：SHOW CREATE VIEW 视图名称;
查看视图数据：SELECT * FROM 视图名称.....; 2.3、修改 方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]
方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]
2.4、删除 DROP VIEW [IF EXISTS] 视图名称; #创建视图 create or replace view stu_v as select id,name from student where id&lt;=10; #查询视图 show create view stu_v; select * from stu_v; select * from stu_v where id&lt;3; #修改视图 create or replace view stu_v as select id,name,no from student where id&lt;=10; alter view stu_v as select id,name from student where id&lt;=10; #删除视图 drop view if exists stu_v; 3、检查选项 create or replace view stu_v as select id,name from student where id&lt;=10; select * from stu_v; insert into stu_v values(5,&#39;tom&#39;); #视图并不存储数据，数据在基表当中存储，也就意味着我们插入的数据实际上是插入到student表当中了 insert into stu_v values(15,&#39;tom&#39;); #基表当中会包含这条数据，但是在查询视图时并不包含这条数据，这是因为在创建视图时指定了id&lt;=10，为了避免这种情况的发生可以加上检查选项 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T18:30:52+08:00">
    <meta property="article:modified_time" content="2024-07-22T18:30:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL进阶篇】存储对象：视图、存储过程及触发器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">一、视图</h2> 
<h3>1、介绍</h3> 
<p>视图（view）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来定义视图的查询中使用的表（基表），并且是在使用视图时动态生成的。</p> 
<p>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p> 
<h3>2、操作语法</h3> 
<h4>2.1、创建</h4> 
<blockquote> 
 <p>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]</p> 
</blockquote> 
<h4>2.2、查询 </h4> 
<blockquote> 
 <p>查看创建视图语句：SHOW CREATE VIEW  视图名称;</p> 
 <p>查看视图数据：SELECT * FROM 视图名称.....; </p> 
</blockquote> 
<h4> 2.3、修改</h4> 
<blockquote> 
 <p>方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]</p> 
 <p>方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]</p> 
</blockquote> 
<h4>2.4、删除</h4> 
<blockquote> 
 <p>DROP VIEW [IF EXISTS] 视图名称; </p> 
</blockquote> 
<pre><code class="language-sql">#创建视图
create or replace view stu_v as select id,name from student where id&lt;=10;
#查询视图
show create view stu_v;
select * from stu_v;
select * from stu_v where id&lt;3;
#修改视图
create or replace view stu_v as select id,name,no from student where id&lt;=10;
alter view stu_v as select id,name from student where id&lt;=10;
#删除视图
drop view if exists stu_v;</code></pre> 
<h3> 3、检查选项</h3> 
<pre><code class="language-sql">create or replace view stu_v as select id,name from student where id&lt;=10;
select * from stu_v;
insert into stu_v values(5,'tom');
#视图并不存储数据，数据在基表当中存储，也就意味着我们插入的数据实际上是插入到student表当中了
insert into stu_v values(15,'tom');
#基表当中会包含这条数据，但是在查询视图时并不包含这条数据，这是因为在创建视图时指定了id&lt;=10，为了避免这种情况的发生可以加上检查选项</code></pre> 
<h4>1.1、试图当中的检查选项</h4> 
<p>当使用 WITH CHECK OPTION 子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义 。MySQL允许基于另一个视图创建视图，它还会检查以来视图中的规则一保持一致性。为了确定检查的范围，MySQL提供了两个选项：CASCADED 和 LOCAL,默认值为CASCADED。</p> 
<h5>CASCADED:</h5> 
<pre><code class="language-sql">#CASCADE :
create or replace view stu_v1 as select id,name from student where id&lt;=20;
create or replace view stu_v2 as select id,name from stu_v1 where id&gt;=10 with cascaded check option ;
insert into stu_v2 values(5,'tom');
insert into stu_v2 values(25,'tom');
#都不能插入成功，会检查stu_v2所依赖的底层所有的视图
create or replace view stu_v3 as select id,name from stu_v2 where id&lt;=15;
insert into stu_v3 values(11,'tom');
insert into stu_v3 values(17,'tom');#能执行成功，会在基表中出现该数据，stu_v3视图的条件不需要检查，只需要检查另外两个视图
insert into stu_v3 values(28,'tom');</code></pre> 
<h5>LOCAL: </h5> 
<pre><code class="language-sql">#LOCAL :
create or replace view stu_v_1 as select id,name from student where id&lt;=20;
create or replace view stu_v_2 as select id,name from stu_v_1 where id&gt;=10 with local check option ;
insert into stu_v_2 values(5,'tom');
#需要检查上一个视图的条件但上一个视图没有with check option选项，并且也不满足当前视图的条件
insert into stu_v_2 values(25,'tom');
#满足当前视图的条件，虽然不满足上一个视图的条件，但上一个视图没有with check option选项，因此可以插入
create or replace view stu_v_3 as select id,name from stu_v_2 where id&lt;=15;
insert into stu_v_3 values(11,'tom');
insert into stu_v_3 values(17,'tom');
insert into stu_v_3 values(28,'tom');
#都可以插入进来</code></pre> 
<h3> 4、更新及作用</h3> 
<h4>4.1、视图的更新</h4> 
<p>要使视图更新，视图中的行为与基础表中的行之间必须存在一对一的关系。如果试图中包含一下任何一项，则该视图不可更新：</p> 
<p>1、聚合函数或窗口函数（SUM()、MAX()、MIN()、COUNT()等）</p> 
<p>2、DISTINCT</p> 
<p>3、GROUP BY</p> 
<p>4、HAVING</p> 
<p>5、UNION 与 UNION ALL</p> 
<h4>4.2、视图的作用</h4> 
<p>1、简单：试图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p> 
<p>2、安全：数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。</p> 
<p>3、数据独立：视图可以帮助用户屏蔽真实表结构带来的影响。</p> 
<h2>二、存储过程</h2> 
<h3>1、介绍</h3> 
<p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p> 
<p>存储过程思想上很简单，就是数据库SQL语言层面的代码的封装与重用。</p> 
<h3>2、特点</h3> 
<p>封装、复用；可以接收参数，也可以返回数据；减少网络交互，效率提升。</p> 
<h3 style="background-color:transparent;">3、操作语法</h3> 
<h4>3.1、创建</h4> 
<blockquote> 
 <p>CREATE PROCEDURE 存储过程名称[(参数列表)]</p> 
 <p>BEGIN</p> 
 <p>                --SQL语句</p> 
 <p>END;</p> 
</blockquote> 
<h4>3.2、调用</h4> 
<blockquote> 
 <p>CALL 名称 [(参数)];</p> 
</blockquote> 
<h4>3.3、查看 </h4> 
<blockquote> 
 <p>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUINE_SCHEMA='xxx';#查询指定数据库的存储过程及状态信息</p> 
 <p>SHOW CREATE PROCEDURE 存储过程名称;#查询某个存储过程的定义</p> 
</blockquote> 
<h4>3.4、删除</h4> 
<blockquote> 
 <p>DROP PROCEDURE [IF EXISTS] 存储过程名称; </p> 
</blockquote> 
<pre><code class="language-sql">#创建
create procedure p1()
begin
    select count(*) from student;
end;
#调用
call p1();
#查看
select * from information_schema.ROUTINES where ROUTINE_SCHEMA='test';
show create procedure p1;
#删除
drop procedure if exists p1;</code></pre> 
<p> 注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter 指定SQL的结束符</p> 
<pre><code class="language-sql"> delimiter $$
mysql&gt; create procedure p1()
    -&gt; begin
    -&gt;     select count(*) from student;
    -&gt; end$$
Query OK, 0 rows affected (0.01 sec)</code></pre> 
<h3 style="background-color:transparent;">4、变量</h3> 
<h4 style="background-color:transparent;"> 4.1、系统变量</h4> 
<p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面，分为全局变量（GLOBAL）、会话变量（SESSION）。</p> 
<h5>4.1.1、查看系统变量</h5> 
<blockquote> 
 <p>SHOW [SESSION | GLOBAL] VARIABLES;#查看所有系统变量</p> 
 <p>SHOW [SESSION | GLOBAL] VARIABLES LIKE'....';#可以通过LIKE模糊匹配的方式查找变量</p> 
 <p>SELECT @@[SESSION | GLOBAL] 系统变量名;#查看指定变量的值</p> 
</blockquote> 
<h5>4.1.2、设置系统变量</h5> 
<blockquote> 
 <p>SET [SESSION | GLOBAL] 系统变量名=值;</p> 
 <p>SET @@[SESSION |GLOBAL] 系统变量名=值; </p> 
</blockquote> 
<pre><code class="language-sql">#查询系统变量
show session variables;
show session variables like 'auto%';#查看与事务自动提交相关的变量
select @@session.autocommit;
#设置系统变量
set session autocommit=0;
set @@session.autocommit=1;</code></pre> 
<p>注意：</p> 
<p>1、如果没有指定SESSION/GLOBAL默认是SESSION会话变量；</p> 
<p>2、MySQL服务器重启之后，所设置的全局参数会失效。</p> 
<h4 style="background-color:transparent;">4.2、自定义变量</h4> 
<p>用户自定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。</p> 
<h5 style="background-color:transparent;">4.2.1、用户变量赋值</h5> 
<blockquote> 
 <p>SET @var_name=expr [,@var_name=expr]...;</p> 
 <p>SET @var_name:=expr [,@var_name:=expr]...;</p> 
</blockquote> 
<p>推荐使用:=因为在MySQL中判断相等与赋值都是用的=，为了避免混淆，用:=。 </p> 
<blockquote> 
 <p>SELECT @var_name:=expr [,@var_name:=expr]...;</p> 
 <p>SELECT 字段名 INTO @var_name FROM 表名; </p> 
</blockquote> 
<h5>4.2.2、用户变量使用</h5> 
<blockquote> 
 <p>SELECT @var_name; </p> 
</blockquote> 
<pre><code class="language-sql">#用户变量赋值
set @myname='test';
set @myage:='10',@mygender:='男';
select @mycolor:='black';
select count(*) into @mycount from tb_user
#使用自定义变量
select @myname,@myage,@mygender;</code></pre> 
<p> 注意：用户定义的变量无需对其进行声明或优化，只不过获取到的值为NULL。</p> 
<h4>4.3、局部变量</h4> 
<p>局部变量是根据需要定义在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BIGINT...END块。</p> 
<h5>4.3.1、局部变量的声明</h5> 
<blockquote> 
 <p>DECLARE 变量名 变量类型 [FEFAULT ...];</p> 
</blockquote> 
<p>变量类型就是数据库字段类型：INT、BIGINT、VARCHAR、DATE、TIME等。 </p> 
<h5>4.3.2、局部变量赋值</h5> 
<blockquote> 
 <p>SET 变量名=值;</p> 
 <p>SET 变量名：=值;</p> 
 <p>SELECT 字段名 INTO 变量名 FROM 表名...; </p> 
</blockquote> 
<pre><code class="language-sql">#局部变量的声明和赋值
create procedure p2()
begin
    declare stu_count int default 0;
    set stu_count:=100;
    #select count(*) into stu_count from student;
    select stu_count;
end;
call p2();</code></pre> 
<h3> 5、if判断</h3> 
<h4 style="background-color:transparent;">5.1、语法结构</h4> 
<blockquote> 
 <p>IF 条件1 THEN</p> 
 <p>                ...</p> 
 <p>ELSE 条件2 THEN</p> 
 <p>                ...</p> 
 <p>ELSE</p> 
 <p>                ...</p> 
 <p>END IF;</p> 
</blockquote> 
<pre><code class="language-sql">#需求：更具定义的分数score变量，判断对应等级
#1、score&gt;=85，等级为优秀
#2、score&gt;=60并且score&lt;85，等级为及格
#3、score&lt;60，等级不及格
create procedure p1()
begin
    declare score int default 58;
    declare result varchar(10);
    if score&gt;=85 then
       set result:='优秀';
    elseif score&gt;=60 and score&lt;85 then
       set result:='及格';
    else
        set result:='不及格';
    end if;
    select result;
end;
call p1();</code></pre> 
<h3 style="background-color:transparent;"> 6、存储过程的参数</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>类型</td><td>含义</td><td>备注</td></tr><tr><td>IN</td><td>该类参数作为输入，也就是调用时需要传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table> 
<h4>6.1、语法 </h4> 
<blockquote> 
 <p>CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数值 参数类型])</p> 
 <p>BEGIN</p> 
 <p>        --SQL语句</p> 
 <p>END;</p> 
</blockquote> 
<pre><code class="language-sql">#存储过程中的参数
#1、需求：根据传入参数的分数score，判断对应等级，并返回
#score&gt;=85，等级为优秀
#score&gt;=60并且score&lt;85，等级为及格
#score&lt;60，等级不及格
create procedure p2(in score int,out result varchar(10))
begin
    if score&gt;=85 then
       set result:='优秀';
    elseif score&gt;=60 and score&lt;85 then
       set result:='及格';
    else
        set result:='不及格';
    end if;
end;
call p2(68,@result);
select @result;
#2、将传入的200分制的分数进行换算，换算成百分制，然后返回
create procedure p3(inout score double)
begin
    set score :=score*0.5;
end;
set @score:=78;
call p3(@score);
select @score;</code></pre> 
<h3> 7、case</h3> 
<h4>7.1、语法</h4> 
<p>语法一</p> 
<blockquote> 
 <p>CASE case_value</p> 
 <p>                WHEN then_value1 THEN statement_list1</p> 
 <p>                [WHEN then_value2 THEN statement_list2]</p> 
 <p>                [ELSE statement_list]</p> 
 <p>END CASE;</p> 
</blockquote> 
<p>语法二</p> 
<blockquote> 
 <p>CASE</p> 
 <p>                WHEN search_condition1 THEN statement_list1</p> 
 <p>                [WHEN search_condition2 THEN statement_list2]</p> 
</blockquote> 
<pre><code class="language-sql">#需求：根据传入的月份，判断月份所属的季度（采用case结构）
#1、1-3月份，第一季度
#2、4-6月份，第二季度
#3、7-9月份，第三季度
#4、10-12月份，第四季度
create procedure p4(in month int)
begin
    declare result varchar(10);
    case
        when month&gt;=1 and month&lt;=3 then
         set result:='第一季度';
        when month&gt;=4 and month&lt;=6 then
         set result:='第二季度';
        when month&gt;=7 and month&lt;=9 then
         set result:='第三季度';
        when month&gt;=10 and month&lt;=12 then
         set result:='第四季度';
        else
         set result:='非法参数';
    end case;
    select concat('您输入的月份为：',month,'所属季度：',result);
end;
call p4(16);</code></pre> 
<h3> 8、while循环</h3> 
<p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。</p> 
<p>语法结构：</p> 
<blockquote> 
 <p>#先判定条件，如果条件为true，则执行逻辑，否则不执行</p> 
 <p>WHILE 条件 DO</p> 
 <p>        SQL语句...</p> 
 <p>END WHILE;</p> 
</blockquote> 
<pre><code class="language-sql">#需求：计算从1累加到n的值，n为传入的参数值
#A.定义局部变量，用来记录累加之后的值
#B.每循环一次n-1，知道满足n&lt;0,则不再循环
create procedure p5(in n int)
begin
    declare sum int default 0;
    while n&gt;0 do
        set sum:=sum+n;
        set n:=n-1;
        end while;
    select sum;
end;
call p5(10);</code></pre> 
<h3> 9、repeat循环</h3> 
<p>repeat是有条件的控制语句，当满足条件的时候退出循环。</p> 
<p>语法结构：</p> 
<blockquote> 
 <p>#先执行一次逻辑，然后判断逻辑是否满足，如果满足则退出，反之则进行下一次循环</p> 
 <p>REPEAT</p> 
 <p>        SQL逻辑...</p> 
 <p>        UNTIL 条件</p> 
 <p>END REPEAT;</p> 
</blockquote> 
<pre><code class="language-sql">create procedure p6(in n int)
begin
    declare sum int default 0;
    repeat
        set sum :=sum+n;
        set n :=n-1;
    until n&lt;=0
        end repeat;
    select sum;
end;
call p6(10);</code></pre> 
<h3 style="background-color:transparent;"> 10、loop循环</h3> 
<p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其实现简单的死循环。loop可以配合以下两个语句使用：</p> 
<p><strong>· </strong>LEAVE:退出循环。</p> 
<p><strong>· </strong>ITERATE:必循用在循环中，作用是跳过当前语句剩下的语句，直接进入下一次循环。</p> 
<blockquote> 
 <p>[begin_label:] LOOP</p> 
 <p>        SQL 逻辑...</p> 
 <p>END LOOP [end_lable];</p> 
</blockquote> 
<blockquote> 
 <p>LEAVE lable;#跳出循环</p> 
 <p>ITERATE lable;#进入下一次循环 </p> 
</blockquote> 
<pre><code class="language-sql">#需求：计算从1累加到n的值，n为传入的参数值
#A.定义局部变量，用来记录累加之后的值
#B.每循环一次n-1，知道满足n&lt;0,则不再循环
create procedure p7(in n int)
begin
    declare sum int default 0;
    total:loop
        if n&lt;=0 then
            leave total;
        end if;
        set sum :=sum+n;
        set n :=n-1;
    end loop total;
    select sum;
end;
call p7(10);
#需求：计算从1到n之间偶数的累加值，n为传入的参数值
create procedure p8(in n int)
begin
    declare sum int default 0;
    total:loop
        if n&lt;=0 then
            leave total;
        elseif n%2=1 then
            set n:=n-1;
            iterate total;
        end if;
        set sum :=sum+n;
        set n :=n-2;
    end loop total;
    select sum;
end;
call p8(10);</code></pre> 
<h3>11、游标(cursor) </h3> 
<pre><code class="language-sql">create procedure p9()
begin
    declare stu_count int default 0;
    select * into stu_count from student;
    select stu_count;
end;
call p9();
#会报这样一条错误：The used SELECT statements have a different number of columns</code></pre> 
<p>这个时候就需要游标了。</p> 
<p>游标是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理，游标的使用包括游标的声明、OPEN、FETCH和CLOSE。</p> 
<h4>11.1操作语法</h4> 
<p>声明游标：</p> 
<blockquote> 
 <p>DECLARE 游标名称 CURSOR FOR 查询语句;  </p> 
</blockquote> 
<p>打开游标：</p> 
<blockquote> 
 <p>OPEN 游标名称; </p> 
</blockquote> 
<p> 获取游标记录：</p> 
<blockquote> 
 <p>FETCH 游标名称 INTO 变量[,变量];</p> 
</blockquote> 
<p>关闭游标：</p> 
<blockquote> 
 <p>CLOSE 游标名称; </p> 
</blockquote> 
<h4>11.2、条件处理程序</h4> 
<p>条件处理程序可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法：</p> 
<blockquote> 
 <p>DECLARE handler_action HANDLER condition_value [,condition_vakue]...statement;</p> 
 <p></p> 
 <p>handler_action</p> 
 <p>        CONTINUE:继续执行当前程序</p> 
 <p>        EXIT:终止执行当前程序</p> 
 <p>condition_value</p> 
 <p>        SQLSTATE sqlstate_value:状态码，如02000</p> 
 <p>        SQLWARNING:所有以01开头的SQLSTATE代码的简写</p> 
 <p>        NOT FOUND: 所有以01开头的SQLSTATE代码的简写</p> 
 <p>        SQLEXCEPTION:所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的简写</p> 
</blockquote> 
<pre><code class="language-sql">#需求：根据传入的参数uage，用来查询用户表tb_user中，所有用户年龄小于等于uage的用户姓名（name）和专业（profession）
#并将用户的姓名和专业插入到所创建的一张新表（id，name，profession）中
#A.声明游标，存储查询结果集
#B.创建表结构
#C.开启游标
#D.获取游标中的记录
#E.插入数据到新表中
#F.关闭游标
create procedure p9(in uage int)
begin
    declare u_name varchar(10);
    declare u_profession varchar(20);
    declare u_cursor cursor for select name,profession from tb_user where age&lt;=uage;
    declare exit handler for SQLSTATE '02000' close u_cursor;
    create table if not exists tb_user_pro(
        id int primary key auto_increment,
        name varchar(10) ,
        profession varchar(20)
    );
    open u_cursor;
    while true do
        fetch u_cursor into u_name,u_profession;
        insert into tb_user_pro values(null,u_name,u_profession);
        end while;
    close u_cursor;
end;</code></pre> 
<h2>三、存储函数</h2> 
<p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法：</p> 
<blockquote> 
 <p>CREATE FUNCTION 存储过程名称[(参数列表)]</p> 
 <p>RETURNS type [characteristic ...]</p> 
 <p>BEGIN</p> 
 <p>                --SQL语句</p> 
 <p>                RETURN...;</p> 
 <p>END;</p> 
 <p>characterstic说明：</p> 
 <p>DETERMINISTIC：相同的输入参数总是产生相同的结果</p> 
 <p>NO SQL：不包含SQL语句</p> 
 <p>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</p> 
</blockquote> 
<pre><code class="language-sql">#从1到n的累加
create function fun(n int)
returns int deterministic
begin
    declare sum int default 0;
    while n&gt;0 do
        set sum:=sum+n;
        set n:=n-1;
        end while;
    return sum;
end;
select fun(100);</code></pre> 
<h2 style="background-color:transparent;">四、触发器</h2> 
<p>触发器是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器这种特性可以协作应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p> 
<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，者与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>触发器类型</td><td>NEW和OLD</td></tr><tr><td>INSERT型触发器</td><td>NEW表示将要或已经新增的数据</td></tr><tr><td>UPDATE型触发器</td><td>OLD表示修改之前的数据，NEW表示将要修改或修改后的数据</td></tr><tr><td>DELETE型触发器</td><td>OLD表示将要货已经删除的数据</td></tr></tbody></table> 
<p> 创建：</p> 
<blockquote> 
 <p>CREATE TRIGGER trigger_name</p> 
 <p>BEDORE/AFTER INSERT/UPDATE/DELETE ON table_name FOR EACH ROW</p> 
 <p>BEGIN</p> 
 <p>        trigger_stmt;</p> 
 <p>END;</p> 
</blockquote> 
<p>查看：</p> 
<blockquote> 
 <p> SHOW TRIGGERS;</p> 
</blockquote> 
<p>删除：</p> 
<blockquote> 
 <p>DROP TRIGGER [schema_name.] trigger_name;#如果没有指定schema_name.默认当前数据库 </p> 
</blockquote> 
<pre><code class="language-sql">#需求：通过触发器记录user表的数据变更日志（user_logs），包含增加，修改、删除
create table user_log(
    id int(11) not null auto_increment,
    operation varchar(20) not null comment '操作类型，insert/update/delete',
    operate_time datetime not null comment '操作时间',
    operate_id int(11) not null comment '操作的ID',
    operate_params varchar(500) comment '操作参数',
    primary key (`id`)
)engine=innodb default charset =utf8;
#插入数据的触发器
create trigger insert_trigger
    after insert on tb_user for each row
begin
       insert into user_log(id, operation, operate_time, operate_id, operate_params) values
        (null,'insert',now(),new.id,concat('插入的数据内容为:id=',new.id,'name=',new.name,'phone=',new.phone,'profession=',new.profession));
end;
#插入数据到tb_user表，验证
insert into tb_user values(5,'二秃子',66,'1','12345678910','通信工程');
#修改数据的触发器
create trigger update_trigger
    after update on tb_user for each row
begin
       insert into user_log(id, operation, operate_time, operate_id, operate_params) values
        (null,'update',now(),new.id,concat('更新之前的数据:id=',old.id,'name=',old.name,'phone=',old.phone,'profession=',old.profession,
                                    '更新之后的数据:id=',new.id,'name=',new.name,'phone=',new.phone,'profession=',new.profession));
end;
update tb_user set age =56 where age=55;
#删除数据的触发器
create trigger delete_trigger
    after delete on tb_user for each row
begin
       insert into user_log(id, operation, operate_time, operate_id, operate_params) values
        (null,'delete',now(),old.id,concat('删除之前的数据:id=',old.id,'name=',old.name,'phone=',old.phone,'profession=',old.profession));
end;
delete from tb_user where id=5;
show triggers;</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/349f098d1498aa53cf10fb0e79b0e149/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【 C 】链表相关的项目（2.0）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e6348c287d9c61da4f68f38e2ef5bdbe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python-爬虫实例（2）：获取豆瓣小说分类界面的文本信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>