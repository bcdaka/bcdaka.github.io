<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaEE 第3节 线程安全知识铺垫2 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3062b8a06296fe713c0ae14ef1b24946/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JavaEE 第3节 线程安全知识铺垫2">
  <meta property="og:description" content="Java中线程终止的方式 下面代码我们创建了一个thread线程，如何在main线程（main方法中）终止thread线程？
1、手动标记 public class Threads { public static void main(String[] args) { Thread thread = new Thread(() -&gt; { while (true) { System.out.println(&#34;我是thread线程&#34;); } }); thread.start(); //如何在main线程（main方法中）终止thread线程？ } } 有一个很简单的办法，就是做一个标记：
public class Threads { //定义一个变量，来判断是否终止线程 private static boolean isQuit=true; public static void main(String[] args) { Thread thread = new Thread(() -&gt; { while (isQuit) { System.out.println(&#34;我是thread线程&#34;); } }); thread.start(); System.out.println(&#34;主线程即将终止thread线程的运行&#34;); isQuit=false; System.out.println(&#34;主线程终止了thread线程&#34;); //如何在main线程（main方法中）终止thread线程？ } } 的确，thread线程被终止了：
这种方法可行，但是注意不要把isQuit定义在main方法中，不然会报错：
原因在于我们创建线程用到了lambda表达式（本质还是匿名内部类创建），如果把isQuit定义在main方法内部，那么就会触发变量捕获，提示说isQuit必须是final或者effectively final的，这个细节大家要注意。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T07:52:55+08:00">
    <meta property="article:modified_time" content="2024-08-05T07:52:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaEE 第3节 线程安全知识铺垫2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E4%B8%89%E3%80%81Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%96%B9%E5%BC%8F">Java中线程终止的方式</h2> 
<p>下面代码我们创建了一个thread线程，如何在main线程（main方法中）终止thread线程？</p> 
<h3 id="1%E3%80%81%E6%89%8B%E5%8A%A8%E6%A0%87%E8%AE%B0">1、手动标记</h3> 
<pre><code class="language-java">public class Threads {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&gt; {
            while (true) {
                System.out.println("我是thread线程");
            }
        });

        thread.start();

        //如何在main线程（main方法中）终止thread线程？
    }
}</code></pre> 
<p>有一个很简单的办法，就是做一个标记：</p> 
<pre><code class="language-java">public class Threads {

    //定义一个变量，来判断是否终止线程
    private static boolean isQuit=true;

    public static void main(String[] args) {
        Thread thread = new Thread(() -&gt; {
            while (isQuit) {
                System.out.println("我是thread线程");
            }
        });

        thread.start();

        System.out.println("主线程即将终止thread线程的运行");
        isQuit=false;
        System.out.println("主线程终止了thread线程");
        //如何在main线程（main方法中）终止thread线程？
    }
}</code></pre> 
<p>的确，thread线程被终止了：</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/86/36/lYzLvv2m_o.png" width="399"></p> 
<p>这种方法可行，但是注意不要把isQuit定义在main方法中，不然会报错：</p> 
<p><img alt="" height="501" src="https://images2.imgbox.com/1f/55/dyR1NGUu_o.png" width="1067"></p> 
<blockquote> 
 <p>原因在于我们创建线程用到了lambda表达式（本质还是匿名内部类创建），如果把isQuit定义在main方法内部，那么就会触发变量捕获，提示说isQuit必须是final或者effectively final的，这个细节大家要注意。</p> 
</blockquote> 
<h3 id="2%E3%80%81interrupt()%E5%BB%BA%E7%AB%8B%E6%A0%87%E5%BF%97%E4%BD%8D">2、interrupt()建立标志位</h3> 
<p>除了这种手动创建标志位的方式，Java在Thread类中提供了interrupt（）方法来<u><strong>告诉</strong></u>需要中断的线程你该结束了。</p> 
<p>还是用刚才的代码进行修改：</p> 
<pre><code class="language-java">public class Threads {
    public static void main(String[] args) {

        Thread thread = new Thread(() -&gt; {
            Thread curThread = Thread.currentThread();//这个方法可以获取当前线程的对象！(此时获取的是thread线程的对象)
            //isInterrupted()如果中断了，就返回真，否则返回假
            while (!curThread.isInterrupted()) {
                System.out.println("我是thread线程");
            }
        });

        thread.start();
        System.out.println("主线程即将终止thread线程的运行");
        thread.interrupt();//这个方法把isInterrupted设置成true
        System.out.println("主线程终止了thread线程");
    }
}</code></pre> 
<blockquote> 
 <p>注意：</p> 
 <p>之所以要用currentThread()方法获取当前线程对象，原因在于lambda表达式内部thread线程的对象都还没有创建完成，如果直接使用thread，是会报错的。</p> 
</blockquote> 
<p>通过interrupt方法，我们同样完成了线程的终止。</p> 
<p>细心的小伙伴一定发现，我刚才特意把“告诉”这个关键词进行了加粗、下划线注释，这里肯定是有原因的：</p> 
<blockquote> 
 <p>原因在于Thread类中的interrupt()方法中断线程的方式比较“<strong>柔和</strong>”。</p> 
 <p>它会给线程设置一个中断标志，告诉这个线程你要尽快结束并终止，而不是直接“杀死”这个线程（不是直接终止这个线程）</p> 
</blockquote> 
<p>我们用一个例子演示就明白了：</p> 
<blockquote> 
 <p>编写一个程序：</p> 
 <p>创建一个线程thread，thread线程每隔1秒（总共10次），打印一句话。</p> 
 <p>然后在主线程通过interrupt方法终止这个线程。</p> 
</blockquote> 
<pre><code class="language-java">public class Threads {
    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(() -&gt; {
            Thread curThread = Thread.currentThread();//这个方法可以获取当前线程的对象！(此时获取的是thread线程的对象)
            //isInterrupted()如果中断了，就返回真，否则返回假
            while (!curThread.isInterrupted()) {
                for (int i = 0; i &lt;10 ; i++) {
                    try {
                        System.out.println("开始睡眠"+(i+1)+"次");
                        System.out.println();
                        Thread.sleep(1000);//sleep方法可以让线程进入休眠（不占用cpu）单位是ms
                    } catch (InterruptedException e) {

                        System.out.println("捕获到了中断异常");

                            curThread.interrupt();//重新设置标志位
                    }
                }
            }
        });

        thread.start();
        //主线程休眠2秒，确保子线程tread能成功被调度（因为系统调度是”随机的“）
        Thread.sleep(2000);
        thread.interrupt();//在主线程把thread线程终止
    }
}</code></pre> 
<p>凭直觉，既然调用了interrupt方法，那么thread线程就不可能执行10次对吧，但是：</p> 
<p><img alt="" height="884" src="https://images2.imgbox.com/b4/cc/UJ2L70ab_o.png" width="353"></p> 
<p>为什么？</p> 
<p>不着急，我们慢慢来讲。</p> 
<p>请看这段代码：</p> 
<pre><code class="language-java">//先清楚标志位,然后抛出异常
public class Threads {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&gt; {
            Thread curThread = Thread.currentThread();
            int i = 0;

            while (!curThread.isInterrupted()) {
                try {
                    Thread.sleep(1000);
                    i++;
                    System.out.println("子线程第" + (i + 1) + "次执行");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    System.out.println("捕获到了异常,但是没有做任何操作");

                }
            }
        });

        thread.start();
        Thread.sleep(1000);
        thread.interrupt();//主线程告诉thread线程,你要结束了
    }
}
</code></pre> 
<p>这个程序是创建一个thread线程，每隔一秒打印一次信息。</p> 
<p>然后通过主线程中断thread线程。</p> 
<p>但是执行结果确是一个死循环：</p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/f5/66/FmP5inun_o.png" width="797"></p> 
<p>catch捕获到了异常，所以标志位肯定是设置好了的，即while条件中的<strong>!curThread.isInterrupted()</strong><br> 应该等于false啊，循环应该退出才对，为什么还会死循环呢？</p> 
<h4>*sleep()方法的特殊性</h4> 
<blockquote> 
 <p>原因：</p> 
 <p></p> 
 <p>问题的关键点其实在于Thread.sleep（）这个方法。</p> 
 <p>当一个线程正在睡眠时，如果设置了中断标志位（调用了interrupt方法），那么sleep会</p> 
 <p><strong>清除标志位（即isInterrupted()=flase）<br> 抛出中断异常</strong><br> 小伙伴们可能会觉得有点奇怪在这个设定上，使用thread.interrupt的方法，目的就是为了让thread.isInterrupted()=true，你怎么就又把它恢复成原来的值呢？</p> 
 <p>实际上这就是Java对于中断线程<strong>”柔和“处理的表现</strong>。</p> 
 <p>主线程依靠这种方式"<strong>告诉</strong>"thread线程，你要结束了。</p> 
 <p>至于是否结束，取决与catch语句的具体操作了。</p> 
 <p>如果catch语句只是打印一下异常信息，其他什么都不干，那么就会出现死循环，因为sleep清空了标志位while的条件恢复成了true。</p> 
 <p><strong>假如我们在catch语句中，添加return语句，或者重新设置标志位，那么thread线程就不会出现死循环了</strong>：</p> 
 <pre><code class="language-java">public class Threads {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&gt; {
            Thread curThread = Thread.currentThread();
            int i = 0;

            while (!curThread.isInterrupted()) {
                try {
                    Thread.sleep(1000);
                    i++;
                    System.out.println("子线程第" + (i + 1) + "次执行");
                } catch (InterruptedException e) {
                    e.printStackTrace();
//                    System.out.println("捕获到了异常,但是没有做任何操作");

                    return;//抛出中断异常，那就直接退出线程
                }
            }
        });

        thread.start();
        Thread.sleep(1000);
        thread.interrupt();//主线程告诉thread线程,你要结束了
    }
}
</code></pre> 
 <p>执行结果：</p> 
 <p><img alt="" height="170" src="https://images2.imgbox.com/19/3f/pM77CT4R_o.png" width="850"></p> 
</blockquote> 
<hr> 
<p>如果以上逻辑都理解啊清楚了，那么接下来要讲的这个现象大家就好理解了：</p> 
<p>实际上，上面给的这个程序，不加return，也是<strong>有概率退出死循环</strong>的！</p> 
<p>这并不玄学，听我慢慢把他讲清楚就明白了。</p> 
<blockquote> 
 <p>刚才我们讲了Thread.sleep()这个方法很特殊，它不仅可以<strong>让当前调用它的线程进入休眠</strong>，而且在休眠期间如果其他线程设置了interrupt()标志位，它还会<strong>清除标志位、抛出中断异常</strong>。这是我们刚才所讲到的最重要的知识点。</p> 
 <p>那么有没有这样一种情况：</p> 
 <p>恰好thread线程执行到21行：<img alt="" height="173" src="https://images2.imgbox.com/11/4c/FBqjLuxH_o.png" width="342"></p> 
 <p>主线程执行了thread.interrupt()。那么这个标志位会生效吗？</p> 
 <p>答案当然是不会，因为thread线程已经睡眠了1秒。之后try块肯定不会抛出InterruptedException。</p> 
 <p>进而while的条件成功改成了false，thread线程结束。</p> 
</blockquote> 
<p>出现所谓“<strong>概率</strong>”主要就是因为这两个线程的执行时机是不确定的，既<strong>线程调度的不确定性</strong>。</p> 
<p>具体到这个程序中就是，不知道thread线程中try块的那个位置主线程的interrupt()方法被调度执行。如果在sleep期间，那么就会死循环，如果在sleep完之后，就不会死循环。</p> 
<hr> 
<p style="text-align:center;">完</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/367629214390e3a24b647af7b7aa7ec7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# 实现改造 GooFlow 流程图插件与数据库应用的结合</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f61b07cfa2fc1256868128a810f64dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python酷库之旅-第三方库Pandas(066)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>