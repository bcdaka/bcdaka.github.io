<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法/学习】：记忆化搜索 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2ec2d2064fdd93ae400789205cdb8a8e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法/学习】：记忆化搜索">
  <meta property="og:description" content="✨ 落魄谷中寒风吹，春秋蝉鸣少年归 🌏 📃个人主页：island1314
🔥个人专栏：算法学习
⛺️ 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
​
🚀引言： 基本概念 记忆化搜索（Memoization Search）：是一种通过存储已经遍历过的状态信息，从而避免对同一状态重复遍历的搜索算法。
主要特点和应用场景包括：
避免重复计算： 记忆化搜索算法通过缓存已经计算过的结果，以避免对相同输入进行重复计算。这在递归算法中特别有用，因为递归往往会导致相同的子问题被反复解决。提高效率： 通过保存中间计算结果，记忆化搜索算法能够大幅减少算法的时间复杂度，从指数级别降低到多项式级别。 动态规划： 记忆化搜索在动态规划中经常被使用。动态规划是一种解决优化问题的方法，通常包含递归和子问题重叠的特点。记忆化搜索能够避免重复计算，使得动态规划算法更加高效。
递归算法优化： 记忆化搜索主要用于优化递归算法。在递归调用中，如果存在相同的输入参数，记忆化搜索算法将直接返回已经计算过的结果，而不是重新执行计算。
应用于搜索问题： 记忆化搜索不仅用于动态规划，还可以应用于搜索问题，特别是深度优先搜索中的状态记忆。
经典的例子包括斐波那契数列的递归实现、图的最短路径问题中的递归搜索等。在实现记忆化搜索时，通常需要使用数据结构（如哈希表、数组等）来保存已经计算过的结果。
记忆化搜索和动态规划都是一种用于优化递归算法的技术，它们有很多相似之处，但也存在一些关键的区别
记忆化搜索与递归相同与不同 相同之处：
重叠子问题： 记忆化搜索和动态规划都针对具有重叠子问题性质的问题。这意味着问题可以被划分为许多相似的子问题，这些子问题在解决整体问题时会被多次重复计算。 优化递归： 两者都旨在优化递归算法。递归算法通常会导致相同的子问题被反复解决，而记忆化搜索和动态规划都致力于避免这种重复计算。 缓存中间结果： 记忆化搜索和动态规划都使用某种形式的缓存来存储已经计算过的中间结果，以便在需要时直接返回结果，而不是重新计算。 不同之处：
自顶向下 vs 自底向上： 记忆化搜索是自顶向下的方法，从大问题开始，逐步分解为子问题，并缓存这些子问题的结果。动态规划是自底向上的方法，从最小的子问题开始解决，逐步构建出整个问题的解。递归 vs 迭代： 记忆化搜索通常使用递归实现，通过递归调用来解决问题。动态规划则使用迭代的方式，通过循环来计算并填充表格或数组。状态转移方程 vs 递归调用： 在动态规划中，通常通过状态转移方程来描述问题的子问题之间的关系，从而构建解。而在记忆化搜索中，通常直接使用递归调用来表示问题的分解。使用场景： 记忆化搜索通常更适用于处理问题的子问题规模较小，问题的状态转移方程比较复杂，递推关系不是很明确，问题适合转换为递归形式，并且递归深度不会太深。而动态规划则更适用于处理问题的子问题规模较大的情况，问题的状态转移方程比较简单，递归关系比较明确。问题不太适合转换为递归形式，或者递归深度过大容易导致栈溢出。 总的来说，当递归中出现了大量完全相同的问题时，就会用到记忆化搜索和动态规划去优化递归算法的技术，但它们的实现方式和问题解决的思路有一些不同。在解决问题时，根据具体的情况选择使用记忆化搜索或动态规划能够更好地满足问题的需求。
记忆化搜索的解题步骤 我们在使用记忆化搜索解决问题的时候，其基本步骤如下：
写出问题的动态规划「状态」和「状态转移方程」。
定义一个缓存（数组或哈希表），用于保存子问题的解。
定义一个递归函数，用于解决问题。在递归函数中，首先检查缓存中是否已经存在需要计算的结果，如果存在则直接返回结果，否则进行计算，并将结果存储到缓存中，再返回结果。
在主函数中，调用递归函数并返回结果。
让我们来看一些相关题目，加深对于记忆化搜索的理解吧
1. 斐波那契数 图解：
下面我们写出两种写法
递归写法：
int dfs(int n) { if (n == 0 || n == 1) return n; return dfs(n - 1) &#43; dfs(n - 2); } int fib(int n) { return dfs(n); } 记忆化搜索写法：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T23:22:58+08:00">
    <meta property="article:modified_time" content="2024-08-11T23:22:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法/学习】：记忆化搜索</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="810" src="https://images2.imgbox.com/84/76/4QfUGHdQ_o.jpg" width="1200"></p> 
<p>✨                                                 落魄谷中寒风吹，春秋蝉鸣少年归        🌏 </p> 
<p>📃<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/island1314?spm=1011.2266.3001.5343" title="island1314">island1314</a></p> 
<p> 🔥个人专栏：<a href="https://blog.csdn.net/island1314/category_12688582.html?spm=1001.2014.3001.5482" title="算法学习">算法学习</a></p> 
<p><strong>⛺️</strong> 欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/2c/WRSXfZVO_o.gif">​</p> 
<hr> 
<h3>🚀引言：</h3> 
<h4>基本概念</h4> 
<p><strong>记忆化搜索（Memoization Search）</strong>：是一种通过存储已经遍历过的状态信息，从而避免对同一状态重复遍历的<a href="https://so.csdn.net/so/search?q=%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020" title="搜索算法">搜索算法</a>。</p> 
<blockquote> 
 <p>主要特点和应用场景包括：</p> 
 <ol><li><strong>避免重复计算：</strong> 记忆化搜索算法通过缓存已经计算过的结果，以避免对相同输入进行重复计算。这在递归算法中特别有用，因为递归往往会导致相同的子问题被反复解决。</li><li><strong>提高效率：</strong> 通过保存中间计算结果，记忆化搜索算法能够大幅减少算法的时间复杂度，从指数级别降低到多项式级别。</li></ol> 
 <p><strong>动态规划：</strong> 记忆化搜索在动态规划中经常被使用。动态规划是一种解决优化问题的方法，通常包含递归和子问题重叠的特点。记忆化搜索能够避免重复计算，使得动态规划算法更加高效。<br><strong>递归算法优化：</strong> 记忆化搜索主要用于优化递归算法。在递归调用中，如果存在相同的输入参数，记忆化搜索算法将直接返回已经计算过的结果，而不是重新执行计算。<br> 应用于搜索问题： 记忆化搜索不仅用于动态规划，还可以应用于搜索问题，特别是深度优先搜索中的状态记忆。</p> 
</blockquote> 
<p>经典的例子包括<a href="https://so.csdn.net/so/search?q=%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97&amp;spm=1001.2101.3001.7020" title="斐波那契数列">斐波那契数列</a>的递归实现、图的最短路径问题中的递归搜索等。在实现记忆化搜索时，通常需要使用数据结构（如哈希表、数组等）来保存已经计算过的结果。</p> 
<p>记忆化搜索和动态规划都是一种用于优化递归算法的技术，它们有很多相似之处，但也存在一些关键的区别</p> 
<h4> 记忆化搜索与递归相同与不同</h4> 
<p><span style="color:#956fe7;"><strong>相同之处</strong>：</span></p> 
<blockquote> 
 <ul><li><strong> 重叠子问题：</strong> 记忆化搜索和动态规划都针对具有重叠子问题性质的问题。这意味着问题可以被划分为许多相似的子问题，这些子问题在解决整体问题时会被多次重复计算。</li></ul> 
 <ul><li><strong> 优化递归：</strong> 两者都旨在优化递归算法。递归算法通常会导致相同的子问题被反复解决，而记忆化搜索和动态规划都致力于避免这种重复计算。</li></ul> 
 <ul><li><strong> 缓存中间结果：</strong> 记忆化搜索和动态规划都使用某种形式的缓存来存储已经计算过的中间结果，以便在需要时直接返回结果，而不是重新计算。</li></ul> 
</blockquote> 
<p><span style="color:#956fe7;"><strong>不同之处</strong>：</span></p> 
<blockquote> 
 <ol><li><strong>自顶向下 vs 自底向上：</strong> 记忆化搜索是自顶向下的方法，从大问题开始，逐步分解为子问题，并缓存这些子问题的结果。动态规划是自底向上的方法，从最小的子问题开始解决，逐步构建出整个问题的解。</li><li><strong>递归 vs 迭代：</strong> 记忆化搜索通常使用递归实现，通过递归调用来解决问题。动态规划则使用迭代的方式，通过循环来计算并填充表格或数组。</li><li><strong>状态转移方程 vs 递归调用：</strong> 在动态规划中，通常通过状态转移方程来描述问题的子问题之间的关系，从而构建解。而在记忆化搜索中，通常直接使用递归调用来表示问题的分解。</li><li><strong>使用场景： <span style="color:#b95514;">记忆化搜索</span></strong>通常更适用于处理问题的<strong>子问题规模较小</strong>，问题的<strong>状态转移方程比较复杂，递推关系不是很明确</strong>，问题<strong>适合转换为递归形式，并且递归深度不会太深</strong>。而<span style="color:#b95514;"><strong>动态规划</strong></span>则更适用于处理问题的<strong>子问题规模较大的情况</strong>，问题的<strong>状态转移方程比较简单，递归关系比较明确</strong>。问题<strong>不太适合转换为递归形式，或者递归深度过大容易导致栈溢出</strong>。</li></ol> 
</blockquote> 
<p>总的来说，当递归中出现了大量完全相同的问题时，就会用到<strong>记忆化搜索和动态规划去</strong>优化递归算法的技术，但它们的实现方式和问题解决的思路有一些不同。在解决问题时，根据具体的情况选择使用记忆化搜索或动态规划能够更好地满足问题的需求。</p> 
<h4>记忆化搜索的解题步骤</h4> 
<blockquote> 
 <p>我们在使用记忆化搜索解决问题的时候，其基本步骤如下：</p> 
 <ol><li> <p>写出问题的动态规划「状态」和「状态转移方程」。</p> </li><li> <p>定义一个缓存（数组或哈希表），用于保存子问题的解。</p> </li><li> <p>定义一个递归函数，用于解决问题。在递归函数中，首先检查缓存中是否已经存在需要计算的结果，如果存在则直接返回结果，否则进行计算，并将结果存储到缓存中，再返回结果。</p> </li><li> <p>在主函数中，调用递归函数并返回结果。</p> </li></ol> 
</blockquote> 
<p>让我们来看一些相关题目，加深对于记忆化搜索的理解吧</p> 
<h3>1. <a class="link-info" href="https://leetcode.cn/problems/fibonacci-number/description/" rel="nofollow" title="斐波那契数">斐波那契数</a></h3> 
<p><img alt="" height="807" src="https://images2.imgbox.com/0f/fb/EAuQaoux_o.png" width="1095"></p> 
<p>图解：</p> 
<p><img alt="" height="866" src="https://images2.imgbox.com/bb/63/1hPDJiK4_o.png" width="980"></p> 
<p>下面我们写出两种写法</p> 
<p><strong><span style="color:#4da8ee;">递归写法：</span></strong></p> 
<pre><code class="language-cpp">int dfs(int n)
{
	if (n == 0 || n == 1) return n;
	return dfs(n - 1) + dfs(n - 2);
}

int fib(int n) {
	return dfs(n);
}</code></pre> 
<p><strong><span style="color:#4da8ee;">记忆化搜索写法：</span></strong></p> 
<pre><code class="language-cpp">int memo[31];
int dfs(int n)
{
	//往备忘录里面查找一下
	if (memo[n] != -1) //剪枝
	{
		return memo[n];
	}
	if (n == 0 || n == 1)
	{
		memo[n] = n; //返回之前先放进备忘录里面
		return n;
	}
	memo[n] = dfs(n - 1) + dfs(n - 2); //返回之前先放进备忘录里面
	return dfs(n - 1) + dfs(n - 2);
}


int fib(int n) {
	//初始化为 -1
	memset(memo, -1, sizeof memo);
	return dfs(n);
}
</code></pre> 
<p><strong><span style="color:#4da8ee;">动态规划写法：</span></strong></p> 
<pre><code class="language-cpp">int dp[31];
int fib(int n) {
	dp[0] = 0, dp[1] = 1;
	for (int i = 2; i &lt;= n; i++)
		dp[i] = dp[i - 1] + dp[i - 2];
	return dp[n];
}</code></pre> 
<h3>2. <a href="https://leetcode.cn/problems/unique-paths/submissions/554457154/" rel="nofollow" title="不同路径">不同路径</a></h3> 
<p><img alt="" height="659" src="https://images2.imgbox.com/a8/54/F3oyOU18_o.png" width="1003"></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路：</span></strong></p> 
 <p>       同样这里如果使用普通的递归深度遍历，会有大量重复计算导致时间复杂度过高，所以这里要使用记忆化搜索来辅助递归算法，达到线性的时间复杂度，我们计算每个格子的路径，相当于上面格子的路径加上左边格子的路径一直递推，完成递归的逆推，同样动态规划也是按照这个逻辑顺推过去</p> 
 <p>图解如下：</p> 
 <p><img alt="" height="516" src="https://images2.imgbox.com/00/d1/Km6c7w4N_o.png" width="1200"></p> 
</blockquote> 
<p><span style="color:#956fe7;"><strong>递归写法：（超时）</strong></span></p> 
<pre><code class="language-cpp">int dfs(int i, int j)
{
	if (i == 0 || j == 0) return 0;
	if (i == 1 &amp;&amp; j == 1) return 1; // 起始位置（1，1）为1

	return dfs(i - 1, j) + dfs(i, j - 1); // 只能往右下走
}

int uniquePaths(int m, int n) {
	return dfs(m, n);
}
</code></pre> 
<p><span style="color:#956fe7;"><strong>记忆化搜索：</strong></span></p> 
<pre><code class="language-cpp">int dfs(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; memo)
{
	if (memo[i][j] != 0) return memo[i][j];
	
	if (i == 0 || j == 0) return 0;
	if (i == 1 &amp;&amp; j == 1) {
		memo[i][j] = 1;
		return 1;
	}

	memo[i][j] = dfs(i - 1, j, memo) + dfs(i, j - 1, memo);
	return memo[i][j];
}

int uniquePaths(int m, int n) {
	vector&lt;vector&lt;int&gt;&gt; memo(m + 1, vector&lt;int&gt;(n + 1));
	return dfs(m, n, memo);
}</code></pre> 
<p><strong><span style="color:#956fe7;">动态规划：</span></strong></p> 
<pre><code class="language-cpp">int uniquePaths(int m, int n) {
	vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
	dp[1][1] = 1;
	for (int i = 1; i &lt;= m; i++){
		for (int j = 1; j &lt;= n; j++) {
			if (i == 1 &amp;&amp; j == 1) continue;
			dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
		}
	}
	return dp[m][n];
}</code></pre> 
<h3>3. <a href="https://leetcode.cn/problems/longest-increasing-subsequence/" rel="nofollow" title="最长递增子序列">最长递增子序列</a></h3> 
<p><img alt="" height="352" src="https://images2.imgbox.com/a2/de/8WgdU3qf_o.png" width="1117"></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路：</span></strong></p> 
 <p>  暴力枚举每个起点，然后在每个起点的基础上往后枚举元素，然后记录最大长度即可</p> 
 <p><strong>1、递归函数头 ：int (dfs pos) </strong></p> 
 <ul><li>返回以pos为起点最长递增子序列长度</li></ul> 
 <p><strong>2、递归函数函数体</strong></p> 
 <ul><li>for(i = pos + 1 ~ n ) 找到 max( dfs(i)  + 1 ） 即可</li></ul> 
 <p><strong>3、递归出口：</strong>该题不用递归出口，因为基本不会越界</p> 
</blockquote> 
<p><span style="color:#956fe7;"><strong>递归写法：（超时）</strong></span></p> 
<pre><code class="language-cpp">int dfs(int pos, vector&lt;int&gt;&amp; nums)
{
	int ret = 1; // ret 初始化为 1,为一个字符时就是1
	for (int i = pos + 1; i &lt; nums.size(); i++) {
		if (nums[i] &gt; nums[pos]) { // 找到以 i 为起点的最大
			ret = max(ret, dfs(i, nums) + 1);
		}
	}
	return ret;
}

int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
	int ret = 0;
	for (int i = 0; i &lt; nums.size(); i++) // 以任意位置为起点的最大值
		ret = max(ret, dfs(i, nums)); 
	return ret;
}</code></pre> 
<p><span style="color:#956fe7;"><strong>记忆化搜索：</strong></span></p> 
<pre><code class="language-cpp">int dfs(int pos, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; memo)
{
	if (memo[pos] != 0) return memo[pos]; //剪枝

	int ret = 1; // ret 初始化为 1,为一个字符时就是1
	for (int i = pos + 1; i &lt; nums.size(); i++) {
		if (nums[i] &gt; nums[pos]) { // 找到以 i 为起点的最大
			ret = max(ret, dfs(i, nums , memo) + 1);
		}
	}
	memo[pos] = ret;
	return ret;
}

int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
	int ret = 0, n = nums.size();
	vector&lt;int&gt; memo(n);
	for (int i = 0; i &lt; n; i++) // 以任意位置为起点的最大值
		ret = max(ret, dfs(i, nums, memo)); 
	return ret;
}</code></pre> 
<p><strong><span style="color:#956fe7;">动态规划：</span></strong></p> 
<pre><code class="language-cpp">int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
	int n = nums.size(), ret = 0; //记录dp表内的最大值
	//表示以某个位置为起点的最大值
	vector&lt;int&gt; dp(n, 1); //初始为1
	// 填表顺序：从后往前

	for (int i = n - 1; i &gt;= 0; i--) {
		for (int j = i + 1; j &lt; n; j++) {
			if (nums[j] &gt; nums[i]) {
				dp[i] = max(dp[i], dp[j] + 1);
			}
		}
		ret = max(ret, dp[i]);
	}

	return ret;
}
</code></pre> 
<p></p> 
<h3 style="background-color:transparent;"><strong>4. <a class="link-info" href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/description/" rel="nofollow" title="猜数字大小II">猜数字大小II</a></strong></h3> 
<p><img alt="" height="390" src="https://images2.imgbox.com/0b/c2/m6zoZhxk_o.png" width="1055"></p> 
<p><img alt="" height="898" src="https://images2.imgbox.com/8d/9e/ufUcJaB6_o.png" width="1089"></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路：</span></strong></p> 
 <p>这里我们最简单的办法就是使用dfs暴力搜索每个猜数字的情况，在左右子树中找到较小的数累加，完成比对，加上记忆化搜索即可。</p> 
</blockquote> 
<p><span style="color:#956fe7;"><strong>递归写法：（超时）</strong></span></p> 
<pre><code class="language-cpp">int dfs(int l, int r)
{
	if (l &gt;= r) return 0;
	int ret = INT_MAX;
	for (int head = l; head &lt;= r; head++) //选择头节点
	{
		//获取当前以head为头节点左右子树的最大值，之所以获取最大值，是因为要确保自己能够获胜
		int x = dfs(l, head - 1);
		int y = dfs(head + 1, r);
		ret = min(ret, head + max(x, y)); // 获胜的最小值
	}
	return ret;
}

int getMoneyAmount(int n) {
	return dfs(1, n);
}</code></pre> 
<p><span style="color:#956fe7;"><strong>记忆化搜索：</strong></span></p> 
<pre><code class="language-cpp">int memo[205][205];
int dfs(int l, int r){
	if (l &gt;= r) return 0;
	if (memo[l][r] != 0) return memo[l][r]; //表示已经遍历过了
	
	int ret = INT_MAX;
	for (int head = l; head &lt;= r; head++) //选择头节点
	{
		//获取当前以head为头节点左右子树的最大值，之所以获取最大值，是因为要确保自己能够获胜
		int x = dfs(l, head - 1);
		int y = dfs(head + 1, r);
		ret = min(ret, head + max(x, y)); // 获胜的最小值
	}
	memo[l][r] = ret;
	return ret;
}

int getMoneyAmount(int n) {
	return dfs(1, n);
}</code></pre> 
<h3>5. <a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/" rel="nofollow" title="矩阵中的最长递增路径">矩阵中的最长递增路径</a></h3> 
<p><img alt="" height="732" src="https://images2.imgbox.com/2a/08/RRjKAd6E_o.png" width="1084"></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路：</span></strong></p> 
 <p><span style="color:#0d0016;">       <strong> Dfs：</strong>从一个单元格开始进行深度优先搜索，即可找到从该单元格开始的最长递增路径。对<strong>每个单元格分别进行深度优先搜索之后，即可得到矩阵中的最长递增路径的长度。</strong></span></p> 
 <p><span style="color:#0d0016;">具体可参考 </span><a href="https://blog.csdn.net/island1314/article/details/141022216?spm=1001.2014.3001.5502" title="【算法/学习】：flood算法-CSDN博客">【算法/学习】：flood算法-CSDN博客</a></p> 
 <p>但是这题如果仅仅使用 <span style="color:#0d0016;">朴素深度优先搜索就会超时，因为<strong>进行了大量的重复计算</strong>，同一个单元格会被访问多次，每次访问都要重新计算。由于同一个单元格对应的最长递增路径的长度是固定不变的，故可用记忆化的方法进行优化。用<strong>矩阵 memo 作为缓存矩阵</strong>，已经计算过的单元格的结果存储到缓存矩阵中。</span></p> 
 <p><span style="color:#0d0016;">        <strong>记忆化深度优先搜索：当访问到一个单元格 (i,j) 时，如果 memo[i][j]=0，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果 memo[i][j]=0，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。</strong></span></p> 
</blockquote> 
<p><span style="color:#956fe7;"><strong>递归写法：（超时）</strong></span></p> 
<pre><code class="language-cpp">int n, m;
int dir[4][2] = {
	{-1,0},{1,0},{0,-1},{0,1}
};

int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int i, int j) {
	int ret = 1;
	for (int k = 0; k &lt; 4; k++) {
		int x = i + dir[k][0], y = j + dir[k][1];
		if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; matrix[x][y] &gt; matrix[i][j]) {
			ret = max(ret, dfs(matrix, x, y) + 1);
		}
	}
	return ret;
}


int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
	m = matrix.size(), n = matrix[0].size();
	int ret = 0;
	for (int i = 0; i &lt; m; i++) {
		for (int j = 0; j &lt; n; j++) {
			ret = max(ret, dfs(matrix, i, j));
		}
	}
	return ret;
}</code></pre> 
<p><span style="color:#956fe7;"><strong>记忆化搜索：</strong></span></p> 
<pre><code class="language-cpp">int memo[205][205];
int n, m;
int dir[4][2] = {
	{-1,0},{1,0},{0,-1},{0,1}
};

int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int i, int j) {
	if (memo[i][j] != 0) return memo[i][j];
	int ret = 1;
	for (int k = 0; k &lt; 4; k++) {
		int x = i + dir[k][0], y = j + dir[k][1];
		if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; matrix[x][y] &gt; matrix[i][j]) {
			ret = max(ret, dfs(matrix, x, y) + 1);
		}
	}
	memo[i][j] = ret;
	return ret;
}


int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
	m = matrix.size(), n = matrix[0].size();
	int ret = 0;
	for (int i = 0; i &lt; m; i++) {
		for (int j = 0; j &lt; n; j++) {
			ret = max(ret, dfs(matrix, i, j));
		}
	}
	return ret;
}</code></pre> 
<p></p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0bad7ed33c7a084c634bdf533dbcee3c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java数据结构】---List(LinkedList)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/869b0b852ccb93d03d6d20320a5856b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Linux】编辑器vim入门（概念&#43;模式转换&#43;技巧）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>