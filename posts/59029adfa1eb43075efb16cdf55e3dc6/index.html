<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>原来链表如此简单 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/59029adfa1eb43075efb16cdf55e3dc6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="原来链表如此简单">
  <meta property="og:description" content="由于顺序表（数组）的插入、删除操作需要移动大量的元素，影响了运行效率，因此引入了线性表的链式存储——单链表。单链表通过一组任意的存储单元来存储线性表中的数据元素，不需要使用地址连续的存储单元，因此它不要求在逻辑上相邻的两个元素在物理位置上也相邻，所以单链表是非随机存取结构，不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从第一个结点开始遍历，依次查找。
单链表的基本构成 其中：data表示数据域，用于存放该结点的数据信息；next表示指针域，用于存放相邻下一结点的地址。
单链表中结点类型的描述如下： struct LNode { int data; LNode* next; }; 单链表的基本操作 单链表的查找-按值进行查找 查找值x在单链表L中的结点指针（指针即地址）。
算法思想：从单链表的第一个结点开始，依次比较表中各个结点的数据域的值，若某结点数据域的值等于num，则返回该结点的指针；若整个单链表中没有这样的结点，则返回空。
按值查找结点值的算法如下： LNode *LocateElem(LNode *L, int num) { LNode *p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != num) { p = p-&gt;next; } return p; } 单链表的查找-按位置进行查找 查找单链表L中第 i（i&gt;0）个位置的结点指针。
算法思想：从单链表的第一个结点开始，顺着指针域逐个往下搜索，直到找到第 i 个结点为止，否则返回最后一个结点的指针域NULL。
按位查找结点值的算法如下： LNode *GetElem(LNode *L, int i) { LNode *p = L-&gt;next; if (p == NULL) { return NULL; } int j = 1; while (p !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-26T15:01:11+08:00">
    <meta property="article:modified_time" content="2024-06-26T15:01:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">原来链表如此简单</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>由于顺序表（数组）的插入、删除操作需要移动大量的元素，影响了运行效率，因此引入了线性表的链式存储——单链表。单链表通过一组任意的存储单元来存储线性表中的数据元素，不需要使用地址连续的存储单元，因此它不要求在逻辑上相邻的两个元素在物理位置上也相邻，所以单链表是非随机存取结构，不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从第一个结点开始遍历，依次查找。</p> 
</blockquote> 
<h3><a id="_1"></a>单链表的基本构成</h3> 
<p><img src="https://images2.imgbox.com/68/f0/crAzP37E_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>其中：data表示数据域，用于存放该结点的数据信息；next表示指针域，用于存放相邻下一结点的地址。</p> 
</blockquote> 
<pre><code class="prism language-cpp">单链表中结点类型的描述如下：
<span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> data<span class="token punctuation">;</span>
	LNode<span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_12"></a>单链表的基本操作</h3> 
<h4><a id="_13"></a>单链表的查找-按值进行查找</h4> 
<p>查找值x在单链表L中的结点指针（指针即地址）。</p> 
<blockquote> 
 <p>算法思想：从单链表的第一个结点开始，依次比较表中各个结点的数据域的值，若某结点数据域的值等于num，则返回该结点的指针；若整个单链表中没有这样的结点，则返回空。</p> 
</blockquote> 
<pre><code class="prism language-cpp">按值查找结点值的算法如下：
LNode <span class="token operator">*</span><span class="token function">LocateElem</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	LNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>data <span class="token operator">!=</span> num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_28"></a>单链表的查找-按位置进行查找</h4> 
<p>查找单链表L中第 i（i&gt;0）个位置的结点指针。</p> 
<blockquote> 
 <p>算法思想：从单链表的第一个结点开始，顺着指针域逐个往下搜索，直到找到第 i 个结点为止，否则返回最后一个结点的指针域NULL。</p> 
</blockquote> 
<pre><code class="prism language-cpp">按位查找结点值的算法如下：
LNode <span class="token operator">*</span><span class="token function">GetElem</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	LNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		j<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_48"></a>单链表的建立-头插法</h4> 
<p>所谓头插法建立单链表就是将新结点插入到当前链表的表头，即头结点之后。如图所示：</p> 
<p><img src="https://images2.imgbox.com/83/ab/N2ADPmmZ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>算法思想：首先初始化一个单链表，其头结点为空，然后循环插入新结点*p：将p的next指向头结点的下一个结点，然后将头结点的next指向p。</p> 
</blockquote> 
<pre><code class="prism language-cpp">主要代码：
LNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> LNode<span class="token punctuation">;</span> <span class="token comment">//申请新结点p</span>
p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//给新结点赋值，x是已知值</span>
p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//将原头结点的next指针域值赋值给新结点next指针域</span>
L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//将头结点连接到新结点</span>
</code></pre> 
<pre><code class="prism language-cpp">头插法建立单链表的算法如下：
LNode <span class="token operator">*</span><span class="token function">HeadInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	LNode <span class="token operator">*</span>L <span class="token operator">=</span> <span class="token keyword">new</span> LNode<span class="token punctuation">;</span>  <span class="token comment">//创建头结点</span>
	L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//初始时使头结点指向空</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		LNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> LNode<span class="token punctuation">;</span>
		p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>
		p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> L<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>需要指出的是，头插法建立的单链表中结点的次序和输入数据的顺序不一致，是相反的。若希望两者的顺序是一致的，则可采用尾插法建立单链表。</p> 
</blockquote> 
<h4><a id="_81"></a>单链表的建立-尾插法</h4> 
<p>所谓尾插法建立单链表，就是将新结点插入到当前链表的表尾。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/2d/1d/Xronivyg_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>算法思想：首先初始化一个单链表，然后声明一个尾指针r，让r始终指向当前链表的尾结点，向单链表的尾部插入新的结点*p，将尾指针r的next域指向新结点，再修改尾指针r指向新结点，也就是当前链表的尾结点。最后别忘记插入所有结点之后，将尾结点的指针域置空。</p> 
</blockquote> 
<pre><code class="prism language-cpp">主要代码：
LNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> LNode<span class="token punctuation">;</span> <span class="token comment">//申请新结点p</span>
p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//给新结点赋值，x是已知值</span>
r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//在原尾指针所指结点后插入新结点p</span>
r <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//插入新结点p后，更新尾指针的位置</span>
</code></pre> 
<pre><code class="prism language-cpp">尾插法建立单链表的算法如下：
LNode <span class="token operator">*</span><span class="token function">TailInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	LNode <span class="token operator">*</span>L <span class="token operator">=</span> <span class="token keyword">new</span> LNode<span class="token punctuation">;</span>
	L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	LNode <span class="token operator">*</span>r <span class="token operator">=</span> L<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		LNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> LNode<span class="token punctuation">;</span>
		p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>
		r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
		r <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> L<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_113"></a>单链表的插入</h4> 
<p><strong>情况1：已知相邻结点中的一个（并且是插入后结点的前驱结点X）</strong><br> <img src="https://images2.imgbox.com/2f/e3/7JRJTYTs_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>插入步骤：<br> 1.申请新结点p<br> 2.给新结点p赋值<br> 3.将原X结点的next域值赋值给新结点p的next域<br> 4.将X结点连接到p，即将p赋值给X结点的next域</p> 
</blockquote> 
<pre><code class="prism language-cpp">主要代码：
LNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> LNode<span class="token punctuation">;</span> <span class="token comment">//申请新结点p</span>
p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//给新结点赋值，x是已知值</span>
p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> X<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//将原X结点的next域值赋值给新结点p的next域</span>
X<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//X结点连接到p，即将p赋值给X结点的next域</span>
</code></pre> 
<p><strong>情况2：已知两个相邻结点（前驱结点X，后继结点Y）</strong><br> <img src="https://images2.imgbox.com/e7/34/1raYCHuQ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>插入步骤：<br> 1.申请新结点p<br> 2.给新结点p赋值<br> 3.将X结点连接到p，即将p赋值给X结点的next域<br> 4.将p结点连接到Y，即将Y赋值给p结点的next域</p> 
</blockquote> 
<pre><code class="prism language-cpp">主要代码：
LNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> LNode<span class="token punctuation">;</span> <span class="token comment">//申请新结点p</span>
p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//给新结点赋值，x是已知值</span>
X<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//将X结点连接到p，即将p赋值给X结点的next域</span>
p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> Y<span class="token punctuation">;</span> <span class="token comment">//将p结点连接到Y，即将Y赋值给p结点的next域</span>
</code></pre> 
<h4><a id="_146"></a>单链表的删除</h4> 
<p>将单链表的第 i 个结点删除。</p> 
<blockquote> 
 <p>算法思想：先检查删除位置的合法性，然后从头开始遍历，找到表中的第 i-1 个结点，即被删除结点的前驱结点p，被删除结点为q，修改p的指针域，将其指向q的下一个结点，最后再释放结点q的存储空间。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/7b/81/JMjNJJaR_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>删除步骤：<br> 1.将p结点指向原q结点的后驱，即将q结点的next域值赋值给p结点的next域<br> 2.删除q结点，即调用free函数</p> 
</blockquote> 
<pre><code class="prism language-cpp">主要代码：
从头开始遍历，找到表中的第 i<span class="token operator">-</span><span class="token number">1</span> 个结点（代码过程省略）
q<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//将q结点的next域值赋值给p结点的next域</span>
<span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//删除q结点</span>
</code></pre> 
<p><strong>后续更新《一章了解栈和队列》，各位看官，关注不迷路！！！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/701d71d728f3cd7cf7f8b0b630c574dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高效安全的IPXProxy代理服务：摆脱免费代理的烦恼</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f2987d76f95c6f9003f15698c7db8dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nvm安装详细教程（卸载旧的nodejs，安装nvm、node、npm、cnpm、yarn及环境变量配置）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>