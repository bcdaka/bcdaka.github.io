<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一篇文章教你如何快速上手Spring MVC框架【万字详解|包含常用注解分析讲解】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/902b5a86de8cac9bfaca95911622983e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="一篇文章教你如何快速上手Spring MVC框架【万字详解|包含常用注解分析讲解】">
  <meta property="og:description" content="目录
一.什么是Spring Web MVC
二.Spring MVC的使用
▐ 建立连接
@RestController
@RequestMapping
▐ 传递参数
1.简单类型传参
2.类对象传参（@RequestParam）
3.数组&amp;集合传参
4.JSON传参（@RequestBody）
5.URL中的参数（@PathVariable）
6.上传文件（@RequestPart）
7.Cookie传参（@CookieValue）
8.Session传参（@SessionAttribute）
9.获取Header（@RequestHeader）
▐ 响应 @Controller &amp; @ResponseBody
一.什么是Spring Web MVC 首先引入官方的一段文字：
Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. The formal name, &#34;Spring Web MVC,&#34; comes from the name of its source module (spring-webmvc), but it is more commonly known as &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-14T18:47:25+08:00">
    <meta property="article:modified_time" content="2024-07-14T18:47:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一篇文章教你如何快速上手Spring MVC框架【万字详解|包含常用注解分析讲解】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="226" src="https://images2.imgbox.com/cf/7a/JnPSD02r_o.gif" width="425"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AFSpring%20Web%20MVC-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AFSpring%20Web%20MVC" rel="nofollow">一.什么是Spring Web MVC</a></p> 
<p id="%E4%BA%8C.Spring%20MVC%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.Spring%20MVC%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">二.Spring MVC的使用</a></p> 
<p id="%E2%96%90%C2%A0%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-toc" style="margin-left:40px;"><a href="#%E2%96%90%C2%A0%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5" rel="nofollow">▐ 建立连接</a></p> 
<p id="%40RestController-toc" style="margin-left:80px;"><a href="#%40RestController" rel="nofollow">@RestController</a></p> 
<p id="%40RequestMapping-toc" style="margin-left:80px;"><a href="#%40RequestMapping" rel="nofollow">@RequestMapping</a></p> 
<p id="%E2%96%90%C2%A0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%96%90%C2%A0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" rel="nofollow">▐ 传递参数</a></p> 
<p id="1.%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#1.%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82" rel="nofollow">1.简单类型传参</a></p> 
<p id="2.%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%8F%82%EF%BC%88%40RequestParam%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%8F%82%EF%BC%88%40RequestParam%EF%BC%89" rel="nofollow">2.类对象传参（@RequestParam）</a></p> 
<p id="3.%E6%95%B0%E7%BB%84%26%E9%9B%86%E5%90%88%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#3.%E6%95%B0%E7%BB%84%26%E9%9B%86%E5%90%88%E4%BC%A0%E5%8F%82" rel="nofollow">3.数组&amp;集合传参</a></p> 
<p id="4.JSON%E4%BC%A0%E5%8F%82%EF%BC%88%40RequestBody%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.JSON%E4%BC%A0%E5%8F%82%EF%BC%88%40RequestBody%EF%BC%89" rel="nofollow">4.JSON传参（@RequestBody）</a></p> 
<p id="5.URL%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%40PathVariable%EF%BC%89-toc" style="margin-left:80px;"><a href="#5.URL%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%40PathVariable%EF%BC%89" rel="nofollow">5.URL中的参数（@PathVariable）</a></p> 
<p id="6.%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%EF%BC%88%40RequestPart%EF%BC%89-toc" style="margin-left:80px;"><a href="#6.%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%EF%BC%88%40RequestPart%EF%BC%89" rel="nofollow">6.上传文件（@RequestPart）</a></p> 
<p id="7.Cookie%E4%BC%A0%E5%8F%82%EF%BC%88%40CookieValue%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.Cookie%E4%BC%A0%E5%8F%82%EF%BC%88%40CookieValue%EF%BC%89" rel="nofollow">7.Cookie传参（@CookieValue）</a></p> 
<p id="8.Session%E4%BC%A0%E5%8F%82%EF%BC%88%40SessionAttribute%EF%BC%89-toc" style="margin-left:80px;"><a href="#8.Session%E4%BC%A0%E5%8F%82%EF%BC%88%40SessionAttribute%EF%BC%89" rel="nofollow">8.Session传参（@SessionAttribute）</a></p> 
<p id="%C2%A09.%E8%8E%B7%E5%8F%96Header%EF%BC%88%40RequestHeader%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A09.%E8%8E%B7%E5%8F%96Header%EF%BC%88%40RequestHeader%EF%BC%89" rel="nofollow"> 9.获取Header（@RequestHeader）</a></p> 
<p id="%E2%96%90%C2%A0%E5%93%8D%E5%BA%94%C2%A0-toc" style="margin-left:40px;"><a href="#%E2%96%90%C2%A0%E5%93%8D%E5%BA%94%C2%A0" rel="nofollow">▐ 响应 </a></p> 
<p id="%40Controller%20%26%C2%A0%40ResponseBody-toc" style="margin-left:80px;"><a href="#%40Controller%20%26%C2%A0%40ResponseBody" rel="nofollow">@Controller &amp; @ResponseBody</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AFSpring%20Web%20MVC">一.什么是Spring Web MVC</h2> 
<p>首先引入官方的一段文字：</p> 
<blockquote> 
 <p>Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. The formal name, "Spring Web MVC," comes from the name of its source module (<a href="https://github.com/spring-projects/spring-framework/tree/main/spring-webmvc" title="spring-webmvc">spring-webmvc</a>), but it is more commonly known as "Spring MVC".</p> 
</blockquote> 
<p>翻译为中文：<span style="background-color:#f9eda6;">Spring Web MVC是基于Servlet API的原始Web框架，从一开始就包含在Spring框架中。其正式名称“Spring Web MVC”来自其源模块(Spring -webmvc)的名称，但更常见的名称是“Spring MVC”。 </span></p> 
<p>我们知道 <strong>Servlet </strong>是⼀套<strong>Java Web </strong>开发的规范，是⼀种实现动态⻚⾯的技术。也就是说，<span style="color:#be191c;"><strong><span style="background-color:#fbd4d0;">Spring Web MVC </span></strong></span>是为了简化原有<strong> Java Web </strong>中的原生 <strong>Servlet </strong>操作而产生的一套框架，并且他还有一个更常见的名称，也就是<span style="color:#be191c;"><strong><span style="background-color:#fbd4d0;">Spring MVC </span></strong></span>。</p> 
<p>要理解什么是<span style="color:#be191c;"><strong><span style="background-color:#fbd4d0;">Spring Web MVC </span></strong></span>之前，我们需要先理解什么是<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">MVC</span></strong></span>。</p> 
<p><strong>MVC </strong>是<strong> Model View Controller </strong>的缩写，它是软件⼯程中的⼀种软件架构设计模式，它把软件系统分为模型、视图和控制器三个基本部分。</p> 
<ul><li>View(视图) 指在应⽤程序中专⻔⽤来与浏览器进⾏交互，展⽰数据的资源。</li><li>Model(模型) 是应⽤程序的主体部分，⽤来处理程序中数据逻辑的部分。</li><li>Controller（控制器）可以理解为⼀个分发器，⽤来决定对于视图发来的请求，需要⽤哪⼀个模型来处理，以及处理完后需要跳回到哪⼀个视图。即⽤来连接视图和模型。</li></ul> 
<p>这种软件架构模式大大优化了软件开发效率。</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/d4/98/DA7E1wWd_o.png" width="592"></p> 
<p>而我们知道的，Spring最擅长的事情就是整合，吸收别人的好的部分转为自己的一部分。对于这种优秀的架构模型，Spring对齐也进行了整合，对于整合后的结果也有一个响亮的名字，也就是我们这篇文章的主角——<strong>Spring MVC</strong>。</p> 
<p>换言之，MVC是一种架构设计模式，而Spring MVC是对MVC思想的具体体现。</p> 
<ul><li>MVC：⼀种软件架构设计模式</li><li>Spring MVC：一个Web开发框架，吸收了MVC的这种设计模式。</li></ul> 
<p>我们通过下图可以更好的理解到Spring MVC与MVC之间的对照关系。</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/0e/6b/VCu7likp_o.png" width="642"></p> 
<hr> 
<h2 id="%E4%BA%8C.Spring%20MVC%E7%9A%84%E4%BD%BF%E7%94%A8">二.Spring MVC的使用</h2> 
<p>其实在我们创建一个新的<strong>SpringBoot</strong>项目的时候，在我们选择依赖的时候就可以看见一个<strong>Spring Web</strong>的依赖，这个其实就是我们实际上使用的<strong>Spring MVC</strong>。如下图我们可以看见官方的解释：</p> 
<blockquote> 
 <p>Build web, including RESTful, applications using Spring MVC. Uses Apache Tomcat as the default embedded container.</p> 
</blockquote> 
<p><img alt="" height="292" src="https://images2.imgbox.com/91/ba/H5xYZl9E_o.png" width="487"></p> 
<p>翻译为中文就是：<span style="background-color:#fefcd8;">使用Spring MVC构建web(包括RESTful)应用程序。使用Apache Tomcat作为默认的嵌入式容器。</span></p> 
<p>我们说到Spring MVC是一个web开发框架，那既然是一个Web开发框架，它对于一个Web应用的关注点是什么呢？我们可以大致将Spring MVC要做的三件事总结如下：</p> 
<ol><li>建立连接：将⽤⼾（浏览器）和 Java 程序连接起来，也就是访问⼀个地址能够调⽤到我们的Spring 程序。</li><li>传递参数：⽤⼾请求的时候会带⼀些参数，在程序中要想办法获取到参数，然后进行业务逻辑操作。</li><li>返回结果：执⾏了业务逻辑之后，要把程序执⾏的结果返回给⽤⼾。</li></ol> 
<p>通过以上三部分，用户就可以在浏览器输入URL之后得到用户想要的界面和数据了。对于 Spring MVC 来说，掌握了以上 3 个功能也就相当于掌握了 Spring MVC。</p> 
<h3 id="%E2%96%90%C2%A0%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><strong>▐ </strong>建立连接</h3> 
<p>就笔者的经验之谈，学习Spring MVC其实就是学习了其中的注解，Spring程序往往都是通过各种各样的注解来实现各自的功能的。对于建立连接这样的一个过程中，有俩个注解格外的重要：</p> 
<ul><li>@RestController</li><li>@RequestMapping</li></ul> 
<h4 id="%40RestController">@RestController</h4> 
<p>我们知道<strong>MVC</strong>中<strong>C</strong>代表着就是<strong>Controller</strong>，它主要的用途就是用来接收用户的请求，我们可以打开 <span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">@RestController </span></strong></span>的源码：</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/7a/01/uoP6qSmS_o.png" width="450"></p> 
<p>我们可以看到有一个<span style="background-color:#f9eda6;"> @Target({ElementType.TYPE}) </span>的注解，这个注解的就是表明了<span style="background-color:#f9eda6;"> </span><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">@RestController </span></strong></span>的作用范围，后面括号内跟着的参数<span style="background-color:#f9eda6;"> ElementType.TYPE </span>就表明了这个注解是作用于 “<strong>类</strong>” 上的。那么这个类就相对于MVC架构中的Controller，这个类就可以用来接收用户请求，如下是一个简单的示例：</p> 
<pre><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author Luming
 * @Date 2024/7/9 20:31
 * @Description:
 */
@RestController
public class UserController {
    @RequestMapping("/hello")
    public String hello() {
        return "hello spring mvc";
    }
}
</code></pre> 
<p>有了能接收用户请求的功能还是不够的，用户请求的数据可能是多种多样的，我们如何对于这些不同的请求做出相对应的业务逻辑和响应呢？这就需要另一个注解<strong><span style="color:#be191c;"><span style="background-color:#f9eda6;"> @RequestMapping </span></span></strong>。</p> 
<h4 id="%40RequestMapping">@RequestMapping</h4> 
<p>从字面理解：Request表示请求，Mapping表示映射关系，那么<strong><span style="color:#be191c;"><span style="background-color:#f9eda6;">@RequestMapping </span></span></strong>就是对于用户不同的请求做出相对应的映射操作，即路由映射。</p> 
<p>也就是说这个注解给用户提供了一个路径，只要用户访问了<span style="background-color:#fefcd8;">@RequestMapping </span>中的路径，那这个方法就会被执行，用户就可以得到返回值。</p> 
<p>这样说可能会有一点抽象，我们结合实例来看看，还是用刚才的那个UserController来演示，我们在<span style="background-color:#fefcd8;">@RequestMapping </span>中用<span style="background-color:#f9eda6;"> “/hello” </span>表示了用户请求的路径，那当我们用浏览器来访问这个路径的时候，我们就可以拿到这个方法的返回值，如图：</p> 
<p><img alt="" height="120" src="https://images2.imgbox.com/a2/64/YylgnWjZ_o.png" width="327"></p> 
<p></p> 
<p>（这里是localhost:8080是因为Tomcat服务器的默认端口就是8080，这是可以更改的）</p> 
<p>另外，对于这里还有一些细节部分需要注意，我们打开<strong><span style="background-color:#f9eda6;">@RequestMapping</span></strong>的源码看看：</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/77/2e/NdBwfkJz_o.png" width="412"></p> 
<p>这里同样有一个 @Target的注解，它内部参数是一个数组，数组中有俩个值，分别是<span style="background-color:#f9eda6;">ElementType.TYPE </span>和<span style="background-color:#f9eda6;"> ElementType.METHOD</span>，这也就表明了<strong><span style="background-color:#f9eda6;">@RequestMapping</span></strong>这个注解既可以作用于方法之上，还可以作用于类之上。当修饰类和⽅法时，访问的地址是类路径 + ⽅法路径。</p> 
<ul><li>@RequestMapping标识⼀个类：设置映射请求的请求路径的初始信息</li><li>@RequestMapping标识⼀个⽅法：设置映射请求请求路径的具体信息</li></ul> 
<p>第二个 @Retention 表示注解的生命周期，RUNTIME就表示了他的生命周期是“运行时”。前三个注解常被称为元注解。@AlliasFor可以理解为是起一个别名，对应到图中，"path" 和 "value" 就相对于是同一个内容只不过是名称不一样。</p> 
<ul><li>value: 指定映射的URL</li><li>method: 指定请求的method类型, 如GET, POST等</li><li>consumes: 指定处理请求(request)的提交内容类型(Content-Type)，例如application/json,text/html</li><li>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</li><li>Params: 指定request中必须包含某些参数值时，才让该⽅法处理</li><li>headers: 指定request中必须包含某些指定的header值，才能让该⽅法处理请求</li></ul> 
<div></div> 
<p>我们还是用一个实例来说明，对于刚才的 UserController 我们在这个类之前又加入了一个<strong><span style="background-color:#f9eda6;">@RequestMapping</span></strong>注解，该注解的值为 “/user”。</p> 
<pre><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author Luming
 * @Date 2024/7/9 20:31
 * @Description:
 */
@RequestMapping("/user")
@RestController
public class UserController {
    @RequestMapping("/hello")
    public String hello() {
        return "hello spring mvc";
    }
}</code></pre> 
<p>我们还是像之前那样打开连接，这一次我们会发现报错了，状态码404。</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/a2/24/OtulVWof_o.png" width="598"></p> 
<p>状态码404，从经验上判断基本上是请求路径有问题了。</p> 
<p>那为什么会出现请求路径有误呢？这是因为我们一共有俩个<strong><span style="background-color:#f9eda6;">@RequestMapping</span></strong>注解，而这俩个注解是存在优先级的，即类上的<strong><span style="background-color:#f9eda6;">@RequestMapping</span></strong>注解高于方法上的，因此，我们需要重新调整一下请求路径，将方法的请求路径拼接在类的请求路径之后。这样我们就可以正常得到结果了。</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/0d/e6/SHGsUh3C_o.png" width="368"></p> 
<p>另外，对于注解中路径前的斜杠是可以省略的（但不建议）</p> 
<pre><code class="language-java">@RequestMapping("user")
@RestController
public class UserController {
    @RequestMapping("hello")
    public String hello() {
        return "hello spring mvc";
    }
}</code></pre> 
<p>为了规范，建议大家还是不要省略。</p> 
<p>在刚才源码中，我们可以注意到@RequestMapping中还有其他属性</p> 
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping
@Reflective({ControllerMappingReflectiveProcessor.class})
public @interface RequestMapping {
    String name() default "";

    @AliasFor("path")
    String[] value() default {};

    @AliasFor("value")
    String[] path() default {};

    RequestMethod[] method() default {};

    String[] params() default {};

    String[] headers() default {};

    String[] consumes() default {};

    String[] produces() default {};
}
</code></pre> 
<p>其实我们往往是默认省略掉一些信息的，不管是前文中提到的<span style="background-color:#f9eda6;"> “/user” </span>还是<span style="background-color:#f9eda6;"> “/hello”</span>，他们都是 <strong>value </strong>这个属性的值，只不过在我们值填入一个参数的时候，它默认帮我们匹配上了。对于前文中的例子，其实它的完整写法是这样的：</p> 
<pre><code class="language-java">@RequestMapping("/user")
@RestController
public class UserController {
    @RequestMapping(value = "/hello", method = RequestMethod.GET)
    public String hello() {
        return "hello spring mvc";
    }
}</code></pre> 
<p>我们通过 method 确定了该请求必须是GET请求，否则不进行响应。</p> 
<p>在<strong><span style="color:#be191c;"><span style="background-color:#f9eda6;">@RequestMapping </span></span></strong>中有很多属性：<strong>value表示请求的路径，method表示请求的方式（HTTP报文的请求方式），params表示请求的参数信息... ...</strong></p> 
<p>我们可以注意到源码中，对于 method 的数据类型是一个数组类型</p> 
<p><img alt="" height="126" src="https://images2.imgbox.com/95/dd/DWPPWSUD_o.png" width="433"></p> 
<p>我们打开对应的源码</p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/9a/e6/9ruAqken_o.png" width="443"></p> 
<p>可以发现这些就是HTTP请求方式的枚举类型数组，因此如果我们想要让一个请求拥有多种请求方式的话，就可以在请求数组中加入其他的请求方式，如下：</p> 
<pre><code class="language-java">@RequestMapping("/user")
@RestController
public class UserController {
    @RequestMapping(value = "/hello", method = {RequestMethod.GET, RequestMethod.POST})
    public String hello() {
        return "hello spring mvc";
    }
}</code></pre> 
<p>我们也可以用PostMan来验证一下：</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/4e/cf/kCvntRnk_o.png" width="475"></p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/b8/32/jqZTsXrL_o.png" width="478"></p> 
<p>我们可以看见GET和POST都是可以请求成功拿到返回值的，但是使用其他的请求方式，如PUT的时候就报错了</p> 
<p><img alt="" height="49" src="https://images2.imgbox.com/51/81/NhoNDBeI_o.png" width="611"></p> 
<p><img alt="" height="481" src="https://images2.imgbox.com/f2/59/QJARJeZk_o.png" width="855"></p> 
<p>那有没有方法可以简化这样的操作呢？</p> 
<p>答案是有的，我们可以使用 @GetMapping、@PostMapping 这样的注解直接代替原有的 @RequesMapping ，这样的操作见名知意，可以简化之前的操作。</p> 
<pre><code class="language-java">//    @RequestMapping(value = "/hello", method = {RequestMethod.GET, RequestMethod.POST})
    @GetMapping("/hello")
    @PostMapping("/hello")
    @PutMapping("/hello")</code></pre> 
<ul><li>@GetMapping代表GET请求方式</li><li>@PostMapping代表POST请求方式</li><li>... ...</li></ul> 
<h3 id="%E2%96%90%C2%A0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><strong>▐ </strong>传递参数</h3> 
<p>解决了接收用户请求的问题后又一个问题接踵而至，如何接收用户请求中传递的参数？</p> 
<h4 id="1.%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82">1.简单类型传参</h4> 
<p>在传递参数部分其实和传统的 Servlet 是一样的，我们传过去的是HTTP请求报文，从请求体或者请求头中就可以获得携带的参数，只要传递的参数的 name 和接收的 name 一样就可以拿到数据。</p> 
<p>就比如这里，我们用 String 类型的 username 接收</p> 
<pre><code class="language-java">@RequestMapping("/request")
@RestController
public class RequestController {
    @RequestMapping("/param")
    public String param(String username) {
        return "用户名是：" + username;
    }
}
</code></pre> 
<p>我们使用PostMan进行测试，只要传递的参数名和接收的参数名是一样的，那就可以自动获取到这个数据</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/ff/ff/JnzUz3Aw_o.png" width="604"></p> 
<p>在这里对于接收参数部分，我们往往建议使用包装类进行接收，这样可以避免很多问题，示例如下，这俩部分主要区别在于一个是使用<span style="background-color:#f9eda6;"> Integer </span>的包装类进行接收，一个是使用<span style="background-color:#f9eda6;"> Int </span>类进行接收</p> 
<pre><code class="language-java">    @RequestMapping("/age1")
    public String age1(Integer age) {
        return "年龄为：" + age;
    }
    
    @RequestMapping("/age2")
    public String age2(int age) {
        return "年龄为：" + age;
    }</code></pre> 
<p>这俩者在正常传参的时候，其实效果是一样的</p> 
<p><img alt="" height="237" src="https://images2.imgbox.com/b9/ce/49ze1YFB_o.png" width="526"></p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/df/3f/gAaiovwJ_o.png" width="526"></p> 
<p>我们可以看见都接收到了年龄为19这样的参数，但是假如俩者都不传参呢？</p> 
<p>对于使用包装类型<span style="background-color:#f9eda6;"> Integer </span>的age1方法，它只是没有收到参数，所以数据值为null</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/41/4f/DsXZZiTI_o.png" width="629"></p> 
<p>但是对于使用基础类型<span style="background-color:#f9eda6;"> Int </span>的age2方法，则直接报错了</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/d2/f9/v9ZoMVYS_o.png" width="627"></p> 
<p>在后端程序中也报出了相同的错误</p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/b4/05/kOz8WAsT_o.png" width="1200"></p> 
<p>因此，建议在使用的时候选择包装类型进行传参。</p> 
<p>在传递多个参数时，参数直接相互顺序是不影响的，主要传递的参数名和接收的参数名能对的上就可以：</p> 
<pre><code class="language-java">    @RequestMapping("param2")
    public String nameAndAge(String name, Integer age) {
        return name + "的年龄为：" + age;
    }</code></pre> 
<p> <img alt="" height="299" src="https://images2.imgbox.com/54/74/VzgDB0Rk_o.png" width="556"></p> 
<h4 id="2.%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%8F%82%EF%BC%88%40RequestParam%EF%BC%89">2.类对象传参（@RequestParam）</h4> 
<p>我们也可以将一个类对象作为参数来接收，在对象的类中只需要有对于每个字段的<strong>get</strong>和<strong>set</strong>方法即可</p> 
<pre><code class="language-java">public class Person {
    private String name;
    private Integer age;
    private String passwd;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public Integer getAge() {
        return age;
    }
    
    public void setAge(Integer age) {
        this.age = age;
    }
    
    public String getPasswd() {
        return passwd;
    }
    
    public void setPasswd(String passward) {
        this.passwd = passward;
    }
    
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", passward='" + passwd + '\'' +
                '}';
    }
}</code></pre> 
<pre><code class="language-java">    @RequestMapping("/person")
    public String person(Person person) {
        return person.toString();
    }</code></pre> 
<p>其实使用类来接收参数也只是参数更多一点的情况而已，所以大体情况还是一样的</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/00/2a/3M4dIDVV_o.png" width="574"></p> 
<p>在上述使用的过程中我们需要时刻注意接收的参数名必须和传递的参数名一致，有没有一种办法可以规避这样的问题，使得程序员可以自定义接收的参数名称呢？</p> 
<p>答案是有的，即使用<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">@RequestParam</span></strong></span></p> 
<p>我们知道对于传递的参数，大多都是<span style="background-color:#f9eda6;">key - value</span>形式的键值对，某些特殊的情况下，前端传递的参数<span style="background-color:#f9eda6;"> key </span>和我们后端接收的<span style="background-color:#f9eda6;"> key </span>可以不⼀致，⽐如前端传递了⼀个<span style="background-color:#f9eda6;"> name </span>给后端，⽽后端是使⽤ <span style="background-color:#f9eda6;">username </span>字段来接收的，这样就会出现参数接收不到的情况，如果出现这种情况，我们就可以使⽤<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;"> @RequestParam </span></strong></span>来绑定前后端传参的关系，使得对于传参名称不一样的问题得以解决，就好像是对参数做了重命名一样。</p> 
<p>就比如下面这段代码，我们后端使用的是 username 用来接收参数，为了接收前端传来的 name 参数就可以这样编码：</p> 
<pre><code class="language-java">    @RequestMapping("/name")
    public String username(@RequestParam("name")String username) {
        return "用户名是：" + username;
    }</code></pre> 
<p><img alt="" height="289" src="https://images2.imgbox.com/cd/ce/7IuUKdYZ_o.png" width="585"></p> 
<p>我们打开<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">@RequestParam </span></strong></span>的源码也可以看见这个注解是作用于参数的</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/94/41/QM5G8gYH_o.png" width="532"></p> 
<p>在上图的源码中有这么一行代码</p> 
<pre><code class="language-java">    boolean required() default true;</code></pre> 
<p>这就意味着我们默认一旦使用了这个注解进行参数的重命名，那么这个参数就必须要传过来，是必不可少的了，如果空传就会报错。</p> 
<p>同样，既然是默认的，那么就可以更改，在使用的时候将该属性置为<span style="background-color:#f9eda6;"> false </span>即可。和我们之前讲的@RequestMapping 一样，一旦参数超过一个就得写出每个参数具体的内容了，这里的<span style="background-color:#f9eda6;"> value </span>代表需要接收的参数名</p> 
<pre><code class="language-java">    @RequestMapping("/name")
    public String username(@RequestParam(value = "name", required = false)String username) {
        return "用户名是：" + username;
    }</code></pre> 
<h4 id="3.%E6%95%B0%E7%BB%84%26%E9%9B%86%E5%90%88%E4%BC%A0%E5%8F%82">3.数组&amp;集合传参</h4> 
<p>首先是使用数组进行传参，我们可以发现只要参数名对的上，都是可以接收的 </p> 
<pre><code class="language-java">    @RequestMapping("/arrParam")
    public String arrParam(String[] arrParam) {
        return "数组元素为：" + Arrays.toString(arrParam);
    }</code></pre> 
<p><img alt="" height="323" src="https://images2.imgbox.com/41/8d/3xC9yDw1_o.png" width="592"></p> 
<p>那使用集合呢？</p> 
<pre><code class="language-java">    @RequestMapping("/listParam")
    public String listParam(ArrayList&lt;String&gt; listParam) {
        return "集合元素为：" + listParam;
    }</code></pre> 
<p><img alt="" height="296" src="https://images2.imgbox.com/42/69/3mouGAEF_o.png" width="552"></p> 
<p>我们会发现并没有收到这个参数，返回的值为空，这是因为当Spring接收到这个参数会自动将其绑定认为是一个数组，数组和集合并不相同，因此无法正确收到。为了解决这个问题就还得拿出之前说到的<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;"> @RequestParam </span></strong></span>来进行绑定参数，在前文中我们说到<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;"> @RequestParam </span></strong></span>可以让传递的参数和接收的参数进行绑定，使得即使二者的名称不一样，也可以正确的接收参数。对于该注解的这个特性，用在这里也是非常适合的。</p> 
<p>那么加收<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;"> @RequestParam </span></strong></span>注解之后，就可以发现后端正确的接收到了参数</p> 
<pre><code class="language-java">    @RequestMapping("/listParam")
    public String listParam(@RequestParam("listParam") ArrayList&lt;String&gt; listParam) {
        return "集合元素为：" + listParam;
    }</code></pre> 
<p><img alt="" height="311" src="https://images2.imgbox.com/3c/b6/CJo88arc_o.png" width="588"></p> 
<h4 id="4.JSON%E4%BC%A0%E5%8F%82%EF%BC%88%40RequestBody%EF%BC%89">4.JSON传参（@RequestBody）</h4> 
<p>在上述种种传参方式中，我们会发现使用起来多多少少会有一点不方便。在企业开发中，为了避免各种各样参数传递带来的不便性，为了提供一种统一的数据格式传递方式，JSON应运而生。</p> 
<p>JSON：JavaScript Object Notation 【JavaScript 对象表⽰法】</p> 
<blockquote> 
 <p>JSON是⼀种轻量级的数据交互格式. 它基于 ECMAScript (欧洲计算机协会制定的js规范)的⼀个⼦集，采⽤完全独⽴于编程语⾔的⽂本格式来存储和表⽰数据。--百度百科</p> 
</blockquote> 
<p>简单来说：JSON就是⼀种数据格式，有⾃⼰的格式和语法，使⽤⽂本表⽰⼀个对象或数组的信息，因此JSON本质是字符串，主要负责在不同的语⾔中数据传递和交换，就像XML一样。</p> 
<pre><code class="language-java">{
  "name": "张三",
  "age": 30,
  "isStudent": false,
  "hobbies": ["足球", "阅读", "旅行"],
  "education": {
    "university": "北京大学",
    "degree": "硕士",
    "graduationYear": 2024
  },
  "contact": {
    "email": "zhangsan@example.com",
    "phone": "1234567890"
  }
}</code></pre> 
<p>这段JSON数据描述了一个名为张三的人的信息，包括他的姓名、年龄、是否是学生、爱好、教育背景以及联系方式。</p> 
<p><strong>JSON数据由键值对组成，键和字符串值用双引号包围，数值直接表示，布尔值使用<code><span style="background-color:#f9eda6;">true</span></code>或<code><span style="background-color:#f9eda6;">false</span></code>，数组用方括号<code><span style="background-color:#f9eda6;">[]</span></code>表示，对象用花括号<code><span style="background-color:#f9eda6;">{}</span></code>表示。</strong></p> 
<p>对于使用JSON数据格式传递进来的参数，我们可以将其解析拆分为我们需要的数据格式，如数组、集合、对象等。</p> 
<p><span style="color:#1f2329;">Spring MVC框架也集成了JSON的转换⼯具, 我们可以直接使⽤, 来完成JSON字符串和Java对象的互转</span>。本质上是<span style="background-color:#f9eda6;"> jackson-databind </span>提供的功能, Spring MVC框架中已经把该⼯具包引⼊了进来, 咱们直接使⽤即可。</p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/01/34/8rvmWzgU_o.png" width="597"></p> 
<p>如果不满意框架自带的JSON数据格式转化工具，也只需要在pom.xml中引入我们想使用的工具类即可，在各大开源社区和论坛中有着许多这样的JSON格式转化的工具包。</p> 
<blockquote> 
 <p>例如fastjson、jfire-codejson、struct2json、snack3等，这些项目都是开源的，并且支持不同的编程语言和功能。</p> 
</blockquote> 
<p>笔者这里还是使用框架自带的JSON转化工具<span style="background-color:#f9eda6;">jackson-databind </span>来进行演示</p> 
<pre><code class="language-java">public class JSONUtilTest {
    private static ObjectMapper objectMapper = new ObjectMapper();
    
    public static void main(String[] args) throws JsonProcessingException {
        //对象转JSON
        Person person = new Person();
        person.setName("zhangsan");
        person.setAge(18);
        person.setPasswd("123456");
        
        String json = objectMapper.writeValueAsString(person);
        
        System.out.println(json);
    }
}
</code></pre> 
<p><img alt="" height="140" src="https://images2.imgbox.com/fe/84/zss7Lef0_o.png" width="624"></p> 
<p>同样的，我们也可以将JSON字符串转化为对象</p> 
<pre><code class="language-java">//JSON转对象
String str = "{\"name\":\"zhangsan\",\"age\":18,\"passwd\":\"123456\"}";
Person person = objectMapper.readValue(str, Person.class);</code></pre> 
<p> 使用JSON进行数据传递有以下好处：</p> 
<ul><li>简单易⽤: 语法简单，易于理解和编写，可以快速地进⾏数据交换</li><li>跨平台⽀持: JSON可以被多种编程语⾔解析和⽣成, 可以在不同的平台和语⾔之间进⾏数据交换和传输</li><li>轻量级: 相较于XML格式, JSON数据格式更加轻量级, 传输数据时占⽤带宽较⼩, 可以提⾼数据传输速度</li><li>易于扩展: JSON的数据结构灵活，⽀持嵌套对象和数组等复杂的数据结构，便于扩展和使⽤</li><li>安全性: JSON数据格式是⼀种纯⽂本格式，不包含可执⾏代码, 不会执⾏恶意代码，因此具有较⾼的安全性</li></ul> 
<p>在项目中要接收JSON传递的参数则需要使用<span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;"> @RequestBody </span></strong></span>这个注解，框架则会自动帮我们进行格式转化。</p> 
<pre><code class="language-java">    @RequestMapping("/jsonParam")
    public String jsonParam(@RequestBody Person person) {
        return person.toString();
    }</code></pre> 
<p><img alt="" height="319" src="https://images2.imgbox.com/46/3f/dRWi8JVD_o.png" width="613"></p> 
<h4 id="5.URL%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%40PathVariable%EF%BC%89">5.URL中的参数（@PathVariable）</h4> 
<p>对于上述的参数接收，我们基本上都素在请求体或者说是请求正文中获取的参数，但是很多时候请求的这个链接路径它本身也可以作为参数，对于这样的参数我们该怎么接收呢？</p> 
<p>对于这样的参数，我们通常使用<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;"> @PathVariable </span></strong></span>注解来接收，path variable表示路径变量，和字⾯表达的意思⼀样, 这个注解主要作⽤在请求URL路径上的数据绑定，使用该注解的时候需要注意在请求路径上设置一个占位符用来接收该位置的参数，对应下方代码的就是 {userId} ，然后将其通过<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">@PathVariable </span></strong></span>注解绑定到我们设置的变量上即可。</p> 
<pre><code class="language-java">    @RequestMapping("/pathVariable/{userId}")
    public String pathVariable(@PathVariable("userId") Integer userId) {
        return "用户ID为：" + userId;
    }</code></pre> 
<p><img alt="" height="350" src="https://images2.imgbox.com/a3/5e/ahXOSGiW_o.png" width="594"></p> 
<h4 id="6.%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%EF%BC%88%40RequestPart%EF%BC%89">6.上传文件（@RequestPart）</h4> 
<p>上传文件需要使用 MultipartFile 这个类</p> 
<p><img alt="" height="135" src="https://images2.imgbox.com/65/6a/4Bm0aKVS_o.png" width="464"></p> 
<p>接收到文件后使用其内部的方法就可以保存到本地了</p> 
<pre><code class="language-java">    @RequestMapping("/fileParam")
    public String fileParam(MultipartFile file) throws IOException {
        String originalFilename = file.getOriginalFilename();
        file.transferTo(new File("D:/Users/temp/" + originalFilename));
        return "接收到文件：" + originalFilename;
    }</code></pre> 
<p> <img alt="" height="305" src="https://images2.imgbox.com/4d/f3/9b3z3Lsv_o.png" width="551"></p> 
<p> 在我们的本地也确实是可以看见刚才上传的文件的</p> 
<p><img alt="" height="109" src="https://images2.imgbox.com/54/52/xoQw25u1_o.png" width="512"></p> 
<p>但是假如我们前后端传递的参数名不一致，就会导致无法接收这个文件</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/e3/7e/lKonrdRP_o.png" width="553"></p> 
<p>为了解决这样的问题，我们就可以使用<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;"> @RequestPart </span></strong></span>注解来进行文件的绑定，就像之前用的@RequestParam一样</p> 
<pre><code class="language-java">    @RequestMapping("/fileParam")
    public String fileParam(@RequestPart("file1") MultipartFile file) throws IOException {
        String originalFilename = file.getOriginalFilename();
        file.transferTo(new File("C:/temp/" + originalFilename));
        return "接收到文件：" + originalFilename;
    }</code></pre> 
<h4 id="7.Cookie%E4%BC%A0%E5%8F%82%EF%BC%88%40CookieValue%EF%BC%89">7.Cookie传参（@CookieValue）</h4> 
<p>前文中提到SpringMVC是基于原生的Servlet技术发展的，那么对于Cookie的传参也是兼容了Servlet中的操作，即直接从请求的request中获取</p> 
<pre><code class="language-java">    @RequestMapping("/Cookie1")
    public String getCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie c : cookies) {
                System.out.println(c.getName() + ":" + c.getValue());
            }
        }
        return "Cookie获取成功";
    }</code></pre> 
<p>除此之外，我们还知道Cookie的传递其实也是键值对的形式，我们可以通过<span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">@CookieValue</span></strong></span>注解来直接获取Cookie中某个Key对应的Value，比如下面这段代码就可以获取一段Cookie中username的值</p> 
<pre><code class="language-java">    @RequestMapping("/Cookie2")
    public String getCookie2(@CookieValue("username") String username) {
        System.out.println(username);
        return "Cookie获取成功";
    }</code></pre> 
<h4 id="8.Session%E4%BC%A0%E5%8F%82%EF%BC%88%40SessionAttribute%EF%BC%89">8.Session传参（@SessionAttribute）</h4> 
<p>对于Servlet中的方法，在这里都是兼容可以使用的，以下是简单设置session和获取的示例</p> 
<pre><code class="language-java">    @RequestMapping("/setSession")
    public String setSession(HttpServletRequest request) {
        //参数为true,如果session对象不存在则创建一个，如果存在则直接返回
        HttpSession session = request.getSession(true);
        if (session != null) {
            session.setAttribute("name", "zhangsan");
            session.setAttribute("passwd", "123456");
        }
        return "设置Session成功";
    }
    
    @RequestMapping("/getSession")
    public String getSession(HttpServletRequest request) {
        //参数为false,如果session不存在则返回null
        HttpSession session = request.getSession(false);
        if (session != null) {
            System.out.println(session.getAttribute("name"));
            System.out.println(session.getAttribute("passwd"));
        }
        return "获取Session成功";
    }</code></pre> 
<p>还要一种更简单的写法，对于Session的获取也可以直接通过内置对象HttpSession获取</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/d2/29/Q59Ordwk_o.png" width="375"></p> 
<pre><code class="language-java">    @RequestMapping("/getSession2")
    public String getSession2(HttpSession session) {
        System.out.println(session.getAttribute("name"));
        System.out.println(session.getAttribute("passwd"));
        return "获取Session成功";
    }</code></pre> 
<p>同时我们还可以使用<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">@SessionAttribute</span></strong></span>注解的方式继续简化，该注解可以直接获取到Session种的字段并且绑定到我们的变量上。同之前的注解一样，value对应具体要接收的参数，required表示该参数是否必传。</p> 
<pre><code class="language-java">    @RequestMapping("/getSession3")
    public String getSession3(@SessionAttribute(value = "name", required = false) String name) {
        System.out.println(name);
        return "获取Session成功";
    }</code></pre> 
<h4 id="%C2%A09.%E8%8E%B7%E5%8F%96Header%EF%BC%88%40RequestHeader%EF%BC%89"> 9.获取Header（@RequestHeader）</h4> 
<p>首先是使用Servlet中的方法</p> 
<pre><code class="language-java">    @RequestMapping("/getHeader")
    public String getHeader(HttpServletRequest request) {
        String header = request.getHeader("User-Agent");
        return "User-Agent" + header;
    }</code></pre> 
<p>其次是使用Spring中的<span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">@RequestHeader</span></strong></span>注解</p> 
<pre><code class="language-java">    @RequestMapping("/getHeader2")
    public String getHeader2(@RequestHeader("User-Agent") String header) {
        return "User-Agent" + header;
    }</code></pre> 
<h3 id="%E2%96%90%C2%A0%E5%93%8D%E5%BA%94%C2%A0"><strong>▐ </strong>响应 </h3> 
<p>对于一个后端程序，能够接收用户请求，能够接收用户传递的参数信息，如果还能根据业务逻辑做出响应，就已经可以满足绝大部分的开发需求了。</p> 
<p>假如我们现在有一个录入信息的<strong> html </strong>静态页面，我们想要用户访问<span style="background-color:#f9eda6;"> /response/login </span>这个路径后就可以看见这个页面并且进行操作。</p> 
<p><img alt="" height="73" src="https://images2.imgbox.com/3c/96/vZ0W3uiu_o.png" width="480"></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;个人信息&lt;/title&gt;
    &lt;style&gt;
        div {
            width: 33%;
            margin: 0 auto;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
    &lt;h1&gt;个人信息录入&lt;/h1&gt;
    &lt;form action="" method="post"&gt;
        姓名：&lt;input type="text" name="name"&gt;&lt;br&gt;&lt;br&gt;
        密码：&lt;input type="password" name="password"&gt;&lt;br&gt;&lt;br&gt;
        性别：&lt;label&gt;&lt;input type="radio" name="sex"&gt;男&lt;/label&gt;
        &lt;label&gt;&lt;input type="radio" name="sex"&gt;女&lt;/label&gt;&lt;br&gt;&lt;br&gt;
        年龄：&lt;input type="number" name="age"&gt;&lt;br&gt;&lt;br&gt;
        语言：&lt;label&gt;&lt;input type="checkbox" name="language" value="Java"&gt;Java&lt;/label&gt;
        &lt;label&gt;&lt;input type="checkbox" name="language" value="C"&gt;C&lt;/label&gt;
        &lt;label&gt;&lt;input type="checkbox" name="language" value="lua"&gt;lua&lt;/label&gt;
        &lt;label&gt;&lt;input type="checkbox" name="language" value="Python"&gt;Python&lt;/label&gt;&lt;br&gt;&lt;br&gt;
        照片：&lt;input type="file" name="photo"&gt;&lt;br&gt;&lt;br&gt;
        生日：&lt;input type="date" name="brithday"&gt;&lt;br&gt;&lt;br&gt;
        时间：&lt;input type="time" name="time"&gt;&lt;br&gt;&lt;br&gt;
        日期以及时间：&lt;input type="datetime-local" name="datetime-local"&gt;&lt;br&gt;&lt;br&gt;
        邮箱：&lt;input type="email" name="email"&gt;&lt;br&gt;&lt;br&gt;
        学历：&lt;select name="degree"&gt;
        &lt;option value=""&gt;请选择您的学历...&lt;/option&gt;
        &lt;option value="1"&gt;初中&lt;/option&gt;
        &lt;option value="2"&gt;高中&lt;/option&gt;
        &lt;option value="3"&gt;本科&lt;/option&gt;
        &lt;option value="4"&gt;硕士&lt;/option&gt;
        &lt;option value="5"&gt;博士&lt;/option&gt;
    &lt;/select&gt;&lt;br&gt;&lt;br&gt;
        个人简介：&lt;textarea name="information"cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;
        &lt;input type="hidden" name="id"&gt;
        &lt;!-- 按钮 --&gt;
        &lt;input type="button" value="确认按钮"&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 无意义 --&gt;
        &lt;input type="reset" value="重置"&gt;
        &lt;input type="submit" value="提交"&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>如果我们按照之前的方法去编码，可以完成需求吗？</p> 
<pre><code class="language-java">@RequestMapping("/response")
@RestController
public class ResponseController {
    
    @RequestMapping("/login")
    public String login() {
        return "/login.html";//绝对路径，如果不加“/”就相对于是/response/login.html
    }
}
</code></pre> 
<p>我们会发现程序将这个资源路径作为了文本数据返回到了浏览器</p> 
<p><img alt="" height="140" src="https://images2.imgbox.com/87/1d/0BWetWAF_o.png" width="408"></p> 
<p>其实问题就出现在<strong>@RestController</strong>上，我们再打开它源码会发现<strong>@RestController</strong>是由<strong>@controller</strong>和<strong>@ResponseBody</strong>组成的</p> 
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
    @AliasFor(
        annotation = Controller.class
    )
    String value() default "";
}</code></pre> 
<h4 id="%40Controller%20%26%C2%A0%40ResponseBody" style="background-color:transparent;">@Controller &amp; <strong>@ResponseBody</strong></h4> 
<p>在前文中我们大量使用的<strong>@RestController</strong> 其实主要是返回数据</p> 
<blockquote> 
 <p><strong>@RestController  =  @Controller  +  @ResponseBody</strong></p> 
</blockquote> 
<ul><li>@Controller : 定义⼀个控制器, Spring 框架启动时加载, 把这个对象交给Spring管理.</li><li>@ResponseBody : 定义返回的数据格式为⾮视图, 返回⼀个 text/html 信息</li></ul> 
<p>如果想返回视图的话, 只需要把 <strong>@ResponseBody </strong>去掉就可以了, 也就是<strong> @Controller </strong>。如下所示：</p> 
<pre><code class="language-java">@RequestMapping("/response")
@Controller
public class ResponseController {
    @RequestMapping("/login")
    public String login() {
        return "/login.html";
    }
}</code></pre> 
<p><img alt="" height="290" src="https://images2.imgbox.com/c5/89/KBJGHfZT_o.png" width="535"></p> 
<p>如果加上 @ResponseBody 注解, 该⽅法就会把 "/login.html" 当做⼀个数据返回给浏览器</p> 
<pre><code class="language-java">@RequestMapping("/response")
@Controller
@ResponseBody
public class ResponseController {
    @RequestMapping("/login")
    public String login() {
        return "/login.html";
    }
}</code></pre> 
<p> <img alt="" height="119" src="https://images2.imgbox.com/a9/7a/y6CDGbR5_o.png" width="347"></p> 
<p>如果观察源码，我们得知@ResponseBody既是类注解, ⼜是⽅法注解。如果作⽤在类上, 表⽰该类的所有⽅法, 返回的都是数据, 如果作⽤在⽅法上, 表⽰该⽅法返回的是数据。</p> 
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ResponseBody {
}
</code></pre> 
<p>如果⼀个类的⽅法⾥, 既有返回数据的, ⼜有返回⻚⾯的, 就把 @ResponseBody 注解添加到对应的⽅法上即可</p> 
<pre><code class="language-java">@Controller
public class IndexController {
    @RequestMapping("/index")
    public Object index(){
        return "/index.html";
    }
    @RequestMapping("/returnData")
    @ResponseBody
    public String returnData(){
        return "该⽅法返回数据";
    }
}</code></pre> 
<p> <span style="color:#1f2329;">后端返回数据时, 如果数据中有HTML代码, 也会被浏览器解析</span></p> 
<pre><code class="language-java">    @RequestMapping("/returnHtml")
    @ResponseBody
    public String returnHtml() {
        return "&lt;h1&gt;Hello,HTML~&lt;/h1&gt;";
    }</code></pre> 
<p><img alt="" height="127" src="https://images2.imgbox.com/02/1e/nITT01JR_o.png" width="355"></p> 
<p>包括JSON等数据格式都是支持返回的</p> 
<p>我们也可以通过 HttpServletResponse 这样的内置对象去响应的header</p> 
<pre><code class="language-java">@RequestMapping(value = "/setHeader")
@ResponseBody
public String setHeader(HttpServletResponse response) {
 response.setHeader("MyHeader","MyHeaderValue");
 return "设置Header成功";
}</code></pre> 
<hr> 
<hr> 
<hr> 
<p><img alt="" height="23" src="https://images2.imgbox.com/63/1f/wHCX8buz_o.png" width="23"><strong> 本次的分享就到此为止了，希望我的分享能给您带来帮助，创作不易也欢迎大家三连支持，你们的点赞就是博主更新最大的动力！</strong><img alt="" height="23" src="https://images2.imgbox.com/05/62/WQVWtjCJ_o.png" width="23"><strong>如有不同意见，欢迎评论区积极讨论交流，让我们一起学习进步！</strong><img alt="" height="23" src="https://images2.imgbox.com/9e/0d/vd0CIdMF_o.png" width="23"><strong>有相关问题也可以私信博主，评论区和私信都会认真查看的，我们下次再见</strong><img alt="" height="23" src="https://images2.imgbox.com/60/c2/eSVEVAmy_o.png" width="23"></p> 
<p class="img-center"><img alt="" height="114" src="https://images2.imgbox.com/50/9e/QKbBcPyD_o.gif" width="409"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9cbb5c7cbfcce86f3f5a9572717c3a7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu安装配置全分布式Hbase</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e9a38988ae232afadf58745c776a4276/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">轻松上手MYSQL：掌握MYSQL聚合函数，数据分析不再难</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>