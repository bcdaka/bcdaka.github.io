<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EMQX安装和Java订阅、发布mqtt消息 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/85c0733139487978ee3c7695573ec7d7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="EMQX安装和Java订阅、发布mqtt消息">
  <meta property="og:description" content="一、EMQX介绍 EMQX是大规模分布式MQTT消息服务器，可以高效可靠连接海量物联网设备，实时处理分发消息与事件流数据，助力构建关键业务的物联网与云应用。EMQX 作为物联网应用开发和物联网平台搭建必须用到的基础设施软件，主要在边缘和云端实现物联网设备互联与设备上云，提供物联网设备接入、协议处理、消息路由、数据存储、流数据处理等核心能力。
二、EMQX安装 访问官网下载安装包：下载 EMQX
解压zip文件得到软件目录
运行EMQX，打开cmd命令窗口，进入软件bin目录，输入emqx start命令启动软件
登录emqx控制台，访问http://127.0.0.1:18083/，默认用户名、密码是admin、public。
三、Java实现发送和订阅消息 3.1 创建客户端基础代码 引入pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; 订阅和发布消息相关代码 import org.eclipse.paho.client.mqttv3.*; import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence; public class App { public static void main(String[] args) { String subTopic = &#34;testtopic/#&#34;; String pubTopic = &#34;testtopic/1&#34;; String content = &#34;Hello World&#34;; int qos = 2; String broker = &#34;tcp://127.0.0.1:1883&#34;; String clientId = &#34;emqx_test&#34;; MemoryPersistence persistence = new MemoryPersistence(); try { MqttClient client = new MqttClient(broker, clientId, persistence); // MQTT 连接选项 MqttConnectOptions connOpts = new MqttConnectOptions(); connOpts.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-31T18:16:08+08:00">
    <meta property="article:modified_time" content="2024-01-31T18:16:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">EMQX安装和Java订阅、发布mqtt消息</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="xkbh1">一、EMQX介绍</h4> 
<p id="ue6507788">EMQX是大规模分布式MQTT消息服务器，可以高效可靠连接海量物联网设备，实时处理分发消息与事件流数据，助力构建关键业务的物联网与云应用。EMQX 作为物联网应用开发和物联网平台搭建必须用到的基础设施软件，主要在边缘和云端实现物联网设备互联与设备上云，提供物联网设备接入、协议处理、消息路由、数据存储、流数据处理等核心能力。</p> 
<p id="u84e5f9d4"></p> 
<h4 id="EfiZD" style="background-color:transparent;">二、EMQX安装</h4> 
<p id="u337754ec">访问官网下载安装包：<a href="https://www.emqx.io/zh/downloads?os=Windows" rel="nofollow" title="下载 EMQX">下载 EMQX</a></p> 
<p id="u17aa47c3"></p> 
<p class="img-center"><img alt="" height="711" id="ufe94e190" src="https://images2.imgbox.com/16/9d/wGPIWuRo_o.png" width="1200"></p> 
<p id="u63a159c3">解压zip文件得到软件目录</p> 
<p id="u9c6d1677"></p> 
<p class="img-center"><img alt="" height="288" id="ued802ce3" src="https://images2.imgbox.com/7a/bc/Ts3icZFN_o.png" width="663"></p> 
<p id="uf57b93cc">运行EMQX，打开cmd命令窗口，进入软件bin目录，输入<code>emqx start</code>命令启动软件</p> 
<p id="u690c3f50"></p> 
<p class="img-center"><img alt="" height="113" id="u21ca3338" src="https://images2.imgbox.com/1d/ab/c38QLXAL_o.png" width="428"></p> 
<p id="u8a665e98">登录emqx控制台，访问<a href="http://127.0.0.1:18083/" rel="nofollow" title="http://127.0.0.1:18083/">http://127.0.0.1:18083/</a>，默认用户名、密码是admin、public。</p> 
<p id="u69cb9f25"></p> 
<p class="img-center"><img alt="" height="803" id="u1bd8900f" src="https://images2.imgbox.com/7e/1f/pHK3x8yx_o.png" width="1200"></p> 
<p id="uef59140c"></p> 
<h4 id="WA3Eb" style="background-color:transparent;">三、Java实现发送和订阅消息</h4> 
<h5 id="a1y5T" style="background-color:transparent;">3.1 创建客户端基础代码</h5> 
<ul><li id="ud011a1b0">引入pom依赖</li></ul> 
<pre id="Z0mMM"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt;
    &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt;
    &lt;version&gt;1.2.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<ul><li id="u49714ba9">订阅和发布消息相关代码</li></ul> 
<pre id="dVhoE"><code>import org.eclipse.paho.client.mqttv3.*;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;


public class App {
    public static void main(String[] args) {
        String subTopic = "testtopic/#";
        String pubTopic = "testtopic/1";
        String content = "Hello World";
        int qos = 2;
        String broker = "tcp://127.0.0.1:1883";
        String clientId = "emqx_test";
        MemoryPersistence persistence = new MemoryPersistence();

        try {
            MqttClient client = new MqttClient(broker, clientId, persistence);

            // MQTT 连接选项
            MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setUserName("用户名");
            connOpts.setPassword("密码".toCharArray());

            // 保留会话
            connOpts.setCleanSession(true);

            MqttCallback callback = new OnMessageCallback();

            // 设置回调
            client.setCallback(callback);

            // 建立连接
            System.out.println("Connecting to broker: " + broker);
            client.connect(connOpts);

            System.out.println("Connected");
            System.out.println("Publishing message: " + content);

            // 订阅主题
            client.subscribe(subTopic);

            // 消息发布所需参数
            MqttMessage message = new MqttMessage(content.getBytes());
            message.setQos(qos);

            // 发布消息
            client.publish(pubTopic, message);
            System.out.println("Message published");

//            client.disconnect();
//            System.out.println("Disconnected");
//            client.close();
//            System.exit(0);
        } catch (MqttException me) {
            System.out.println("reason " + me.getReasonCode());
            System.out.println("msg " + me.getMessage());
            System.out.println("loc " + me.getLocalizedMessage());
            System.out.println("cause " + me.getCause());
            System.out.println("excep " + me);
            me.printStackTrace();
        }
    }
}</code></pre> 
<ul><li id="u4f77d85f">接收消息相关代码</li></ul> 
<pre id="kIr5I"><code>import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttMessage;

public class OnMessageCallback implements MqttCallback {
    public void connectionLost(Throwable cause) {
        // 连接丢失后，一般在这里面进行重连
        System.out.println("连接断开，可以做重连");
    }

    public void messageArrived(String topic, MqttMessage message) throws Exception {
        // subscribe后得到的消息会执行到这里面
        System.out.println("接收消息主题:" + topic);
        System.out.println("接收消息Qos:" + message.getQos());
        System.out.println("接收消息内容:" + new String(message.getPayload()));
    }

    public void deliveryComplete(IMqttDeliveryToken token) {
        System.out.println("deliveryComplete---------" + token.isComplete());
    }
}</code></pre> 
<p id="u11c2e910"></p> 
<h5 id="cmjU2" style="background-color:transparent;">3.2 创建客户端进阶代码</h5> 
<ul><li id="uea08d074">引入pom依赖</li></ul> 
<pre id="lw4aA"><code>&lt;!--mqtt--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-stream&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-mqtt&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt;
    &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt;
    &lt;version&gt;1.2.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- fastJSON --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.56&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<ul><li id="uf99f6146">定义发送消息客户端的配置</li></ul> 
<pre id="bpDbv"><code>import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.annotation.IntegrationComponentScan;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.integration.channel.DirectChannel;
import org.springframework.integration.mqtt.core.DefaultMqttPahoClientFactory;
import org.springframework.integration.mqtt.core.MqttPahoClientFactory;
import org.springframework.integration.mqtt.outbound.MqttPahoMessageHandler;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageHandler;

@Configuration
@IntegrationComponentScan
public class MqttSenderConfig {

/**
 * 发布的bean名称
 */
public static final String CHANNEL_NAME_OUT = "mqttOutboundChannel";

/**
 * 客户端与服务器之间的连接意外中断，服务器将发布客户端的"遗嘱"消息
 */
private static final byte[] WILL_DATA;
static {
    WILL_DATA = "offline".getBytes();
}
private static final String username = "admin";
private static final String password = "DCDremote@997";
private static final String url = "tcp://127.0.0.1:1883";
private static final String clientId = "honeywell-server1";
private static final String defaultTopic = "default";

//    @Value("${mqtt.username}")
//    private String username;
//
//    @Value("${mqtt.password}")
//    private String password;
//
//    @Value("${mqtt.url}")
//    private String url;
//
//    @Value("${mqtt.sender.clientId}")
//    private String clientId;
//
//    @Value("${mqtt.sender.topic}")
//    private String defaultTopic;

@Bean
public MqttConnectOptions getMqttConnectOption(){
    MqttConnectOptions mqttConnectOptions=new MqttConnectOptions();
    mqttConnectOptions.setCleanSession(true);
    mqttConnectOptions.setConnectionTimeout(10);
    mqttConnectOptions.setKeepAliveInterval(90);
    mqttConnectOptions.setAutomaticReconnect(true);
    mqttConnectOptions.setUserName(username);
    mqttConnectOptions.setPassword(password.toCharArray());
    mqttConnectOptions.setServerURIs(new String[]{url});
    mqttConnectOptions.setKeepAliveInterval(30);
    return mqttConnectOptions;
}

@Bean
public MqttPahoClientFactory mqttClientsFactory() {
    DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();
    factory.setConnectionOptions(getMqttConnectOption());
    return factory;
}

@Bean
@ServiceActivator(inputChannel = "mqttOutboundChannel")
public MessageHandler  mqttOutbound() {
    MqttPahoMessageHandler messageHandler =  new MqttPahoMessageHandler(clientId, mqttClientsFactory());
    messageHandler.setAsync(true);
    messageHandler.setDefaultTopic(defaultTopic);
    messageHandler.setDefaultQos(1);
    return messageHandler;
}

@Bean
public MessageChannel mqttOutboundChannel() {
    return new DirectChannel();
}
}</code></pre> 
<ul><li id="u96fd96f4">编写接收消息的客户端的相关配置</li></ul> 
<pre id="VJIxH"><code>package org.jianying.emqxstudy.mqtt;


import com.alibaba.fastjson.JSON;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.integration.channel.DirectChannel;
import org.springframework.integration.core.MessageProducer;
import org.springframework.integration.mqtt.core.DefaultMqttPahoClientFactory;
import org.springframework.integration.mqtt.core.MqttPahoClientFactory;
import org.springframework.integration.mqtt.inbound.MqttPahoMessageDrivenChannelAdapter;
import org.springframework.integration.mqtt.support.DefaultPahoMessageConverter;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageHandler;
import org.springframework.messaging.MessagingException;

import java.util.Arrays;
import java.util.List;
import java.util.Map;



@Configuration
public class MqttReceiverConfig {

    final static Logger logger = LoggerFactory.getLogger(MqttReceiverConfig.class);


    /**
     * 订阅的bean名称
     */
    public static final String CHANNEL_NAME_IN = "mqttInboundChannel";

    // 客户端与服务器之间的连接意外中断，服务器将发布客户端的“遗嘱”消息
    private static final byte[] WILL_DATA;

    static {
        WILL_DATA = "offline".getBytes();
    }

    private static final String username = "admin";
    private static final String password = "DCDremote@997";
    private static final String url = "tcp://127.0.0.1:1883";

    // 接收消息的客户端id
    private static final String clientId = "test-server";

    // 接收的消息主题， $SYS/brokers 表示发送的是系统主题
    private static final String defaultTopic = "$SYS/brokers/+/clients/#,hello/info/faceid/#,hello/server/result/#,info_topic";

//    @Value("${mqtt.username}")
//    private String username;
//
//    @Value("${mqtt.password}")
//    private String password;
//
//    @Value("${mqtt.url}")
//    private String url;
//
//    @Value("${mqtt.receiver.clientId}")
//    private String clientId;
//
//    @Value("${mqtt.receiver.topic}")
//    private String defaultTopic;

    @Bean
    public MqttConnectOptions getMqttConnectOptions() {
        MqttConnectOptions mqttConnectOptions = new MqttConnectOptions();
        mqttConnectOptions.setCleanSession(true);
        mqttConnectOptions.setConnectionTimeout(10);
        mqttConnectOptions.setKeepAliveInterval(90);
        mqttConnectOptions.setAutomaticReconnect(true);
        mqttConnectOptions.setUserName(username);
        mqttConnectOptions.setPassword(password.toCharArray());
        mqttConnectOptions.setServerURIs(new String[]{url});
        mqttConnectOptions.setKeepAliveInterval(60);
        return mqttConnectOptions;
    }

    @Bean
    public MqttPahoClientFactory mqttClientFactory() {
        DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();
        factory.setConnectionOptions(getMqttConnectOptions());
        return factory;
    }

    //接收通道
    @Bean
    public MessageChannel mqttInputChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageProducer inbound() {

        List&lt;String&gt; topicList = Arrays.asList(defaultTopic.trim().split(","));
        String[] topics = new String[topicList.size()];
        topicList.toArray(topics);

        MqttPahoMessageDrivenChannelAdapter adapter =
                new MqttPahoMessageDrivenChannelAdapter(clientId, mqttClientFactory(),
                        topics);
        adapter.setCompletionTimeout(10000);
        adapter.setConverter(new DefaultPahoMessageConverter());
        adapter.setQos(1);
        adapter.setOutputChannel(mqttInputChannel());
        return adapter;
    }

    //通过通道获取数据
    @Bean
    @ServiceActivator(inputChannel = "mqttInputChannel")
    public MessageHandler handler() {
        return new MessageHandler() {
            @Override
            public void handleMessage(Message&lt;?&gt; message) throws MessagingException {
                logger.info(("收到消息" + message.getHeaders().get("mqtt_receivedTopic") + message.getPayload()));
                // 主题
                String topic = message.getHeaders().get("mqtt_receivedTopic").toString();
                // 消息体
                Map maps = (Map) JSON.parse(message.getPayload().toString().trim());
                // 判断设备状态
                if (topic.contains("$SYS/brokers") &amp;&amp; !topic.contains("faceid-server") &amp;&amp; !topic.contains("faceid-mqtt-server")) {
                    if (maps.get("clientid").toString().contains("uniwin-mqtt-client")) {

                    }
                } else if (topic.contains("uniwin/server/result/faceid")) { //结果返回
                    if (maps.get("type") != null &amp;&amp; !maps.get("type").equals("")) {

                    }
                } else {
                    System.out.println("info...");
                    if (maps.get("type") != null &amp;&amp; !maps.get("type").equals("")) {
                        String type = maps.get("type").toString();
                        // 设备心跳检测
                        if (type.equals("heart")) {

                        }
                        // 上传打卡记录
                        if (type.equals("note")) {
                        }
                        // 上传设备参数
                        if (type.equals("param_upload")) {
                        }
                    }
                }

            }
        };
    }

}

</code></pre> 
<ul><li id="u45ce847c">编写发送消息的工具类</li></ul> 
<pre id="HtgCt"><code>import org.springframework.integration.annotation.MessagingGateway;
import org.springframework.integration.mqtt.support.MqttHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Component;

@Component
@MessagingGateway(defaultRequestChannel = "mqttOutboundChannel")
public interface MqttGateway {
    /**
     * 发送信息到MQTT服务器
     *
     * @param data 发送的文本
     */
    void sendToMqtt(String data);

    /**
     * 发送信息到MQTT服务器
     *
     * @param topic 主题
     * @param payload 消息主体
     */
    void sendToMqtt(@Header(MqttHeaders.TOPIC) String topic,
                    String payload);

    /**
     * 发送信息到MQTT服务器
     *
     * @param topic 主题
     * @param qos 对消息处理的几种机制。
     * 0 表示的是订阅者没收到消息不会再次发送，消息会丢失。
     * 1 表示的是会尝试重试，一直到接收到消息，但这种情况可能导致订阅者收到多次重复消息。
     * 2 多了一次去重的动作，确保订阅者收到的消息有一次。
     * @param payload 消息主体
     */
    void sendToMqtt(@Header(MqttHeaders.TOPIC) String topic,
                    @Header(MqttHeaders.QOS) int qos,
                    String payload);

}
</code></pre> 
<h5 id="NaiTy" style="background-color:transparent;">3.3 EMQX API使用示例</h5> 
<ul><li id="u0deefdb8">EMQX 提供了 HTTP API 以实现与外部系统的集成，例如查询客户端信息、发布消息和创建规则等。</li><li id="u0957edb5">EMQX 的 HTTP API 服务默认监听 8081 端口，可通过 etc/plugins/emqx_management.conf 配置文件修改监听端口，或启用 HTTPS 监听。EMQX 4.0.0 (opens new window)以后的所有 API 调用均以 api/v4 开头。</li></ul> 
<p id="ub0db8089">详细介绍可以看官方API文档：<a href="https://www.emqx.io/docs/zh/v4.3/advanced/http-api.html" rel="nofollow" title="HTTP API | EMQX 4.3 文档">HTTP API | EMQX 4.3 文档</a></p> 
<p id="u8e3da167">下面的代码是以 v4.3 版本为例，以API调用的方式操作EMQX服务。</p> 
<h6 id="axzZr">3.3.1 消息发布</h6> 
<ul><li id="u27412a6e">请求方式</li></ul> 
<blockquote> 
 <p id="ua012231e">POST <a href="http://localhost:8081" rel="nofollow" title="http://localhost:8081">http://localhost:8081</a>/api/v4/mqtt/publish</p> 
</blockquote> 
<ul><li id="u4f508ab8">请求参数（json数据）</li></ul> 
<table id="KPE2X"><tbody><tr><td> <p id="ue9ba9881">Name</p> </td><td> <p id="ua11d836a">Type</p> </td><td> <p id="ud1a6fa53">Required</p> </td><td> <p id="uf12a853f">Default</p> </td><td> <p id="u905b01a5">Description</p> </td></tr><tr><td> <p id="u45043ed5">topic</p> </td><td> <p id="u2d8d03c8">String</p> </td><td> <p id="u62cd3da2">Optional</p> </td><td></td><td> <p id="u09d4ebf6">主题，与 topics 至少指定其中之一</p> </td></tr><tr><td> <p id="ucde8311e">topics</p> </td><td> <p id="uf2d2e984">String</p> </td><td> <p id="ua6c0f180">Optional</p> </td><td></td><td> <p id="u4ca09eb6">以 , 分割的多个主题，使用此字段能够同时发布消息到多个主题</p> </td></tr><tr><td> <p id="u4b628374">clientid</p> </td><td> <p id="ub877b922">String</p> </td><td> <p id="ud9ebc741">Required</p> </td><td></td><td> <p id="u07d8f662">客户端标识符</p> </td></tr><tr><td> <p id="u369cbddd">payload</p> </td><td> <p id="ud4ac882f">String</p> </td><td> <p id="u436187af">Required</p> </td><td></td><td> <p id="u11b74032">消息正文</p> </td></tr><tr><td> <p id="u65634a1d">encoding</p> </td><td> <p id="ua03577fd">String</p> </td><td> <p id="ue652954c">Optional</p> </td><td> <p id="uf25ff37c">plain</p> </td><td> <p id="u5184b795">消息正文使用的编码方式，目前仅支持 plain 与 base64 两种</p> </td></tr><tr><td> <p id="u78a7e039">qos</p> </td><td> <p id="u95f8a870">Integer</p> </td><td> <p id="u6950458b">Optional</p> </td><td> <p id="u585f032b">0</p> </td><td> <p id="u84c79bb2">QoS 等级</p> </td></tr><tr><td> <p id="u1739cceb">retain</p> </td><td> <p id="u04173e66">Boolean</p> </td><td> <p id="u629da38f">Optional</p> </td><td> <p id="ucb37a9a2">false</p> </td><td> <p id="u7c9394ba">是否为保留消息</p> </td></tr></tbody></table> 
<ul><li id="u92212101">请求成功返回结果</li></ul> 
<table id="PS3SH"><tbody><tr><td> <p id="u1451d13f">Name</p> </td><td> <p id="u3cbf83f6">Type</p> </td><td> <p id="ub6e8d599">Description</p> </td></tr><tr><td> <p id="ue734f679">code</p> </td><td> <p id="u7e0bbc87">Integer</p> </td><td> <p id="ua9772ca7">0</p> </td></tr></tbody></table> 
<ul><li id="u04f32a81">代码示例</li></ul> 
<pre id="bsXGz"><code>public void publiceMessage() {
    // 封装请求体参数
    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put("clientid", "clientId");
    map.put("topic", "pubTopic");
    map.put("payload", "{\"iot_type\":10}");
    map.put("qos", 1);
    // json字符串请求体（注意：不转为json字符串，直接拼接字符串容易报错）
    String requestBody = JsonUtil.obj2string(map);
    // emqx路径
    String emqxApiBaseUrl = "http://127.0.0.1:8081"; // EMQ X API 地址
    try {
        // 构建发布消息的 URL
        String publicConnectionUrl = emqxApiBaseUrl + "/api/v4/mqtt/publish";
        // 创建 URL 对象
        URL url = new URL(publicConnectionUrl);
        // 创建 HttpURLConnection
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        // 设置访问权限（使用Authorization方式）
        connection.setRequestProperty("Authorization", "Basic YWRtaW46cHVibGlj");
        connection.setRequestProperty("Content-Type", "application/json");
        connection.setRequestMethod("POST");
        connection.setDoOutput(true);
        // 将请求体写入连接
        try (OutputStream os = connection.getOutputStream()) {
            byte[] input = requestBody.getBytes(StandardCharsets.UTF_8);
            os.write(input, 0, input.length);
        }
        // 获取响应码
        int responseCode = connection.getResponseCode();
        if (responseCode == HttpURLConnection.HTTP_OK) {
            System.out.println("Successfully public: " + clientId);
        } else {
            System.out.println("Failed to public. Response Code: " + responseCode);
        }
        // 关闭连接
        connection.disconnect();
    } catch (Exception e) {
        e.printStackTrace();
    }
}</code></pre> 
<h6 id="otpLE" style="background-color:transparent;">3.3.2 根据clientid断开并剔除客户端</h6> 
<p id="u558907ef">踢除指定客户端。注意踢除客户端操作会将连接与会话一并终结。</p> 
<ul><li id="u66d6fcb1">请求方式</li></ul> 
<blockquote> 
 <p id="ua7f8b6b2">DELETE <a href="http://localhost:8081" rel="nofollow" title="http://localhost:8081">http://localhost:8081</a>/api/v4/clients/{clientid}</p> 
</blockquote> 
<ul><li id="uea883c8f">请求参数（<strong>Path Parameters）</strong></li></ul> 
<table id="yyX8Q"><tbody><tr><td> <p id="u23677407">Name</p> </td><td> <p id="u73dac8f2">Type</p> </td><td> <p id="uf49df0d5">Required</p> </td><td> <p id="u4bc4aa9d">Description</p> </td></tr><tr><td> <p id="ua3414c5d">clientid</p> </td><td> <p id="u617eb601">String</p> </td><td> <p id="uc067cca5">True</p> </td><td> <p id="u5b2ce10b">ClientID</p> </td></tr></tbody></table> 
<ul><li id="ud72c388a">请求成功结果</li></ul> 
<table id="iwgQM"><tbody><tr><td> <p id="ubf026687">Name</p> </td><td> <p id="u0477418f">Type</p> </td><td> <p id="u420f3f45">Description</p> </td></tr><tr><td> <p id="u4cbc1793">code</p> </td><td> <p id="ue0b9fa3e">Integer</p> </td><td> <p id="ua0bfb39b">0</p> </td></tr></tbody></table> 
<ul><li id="u9976a2fc">代码示例</li></ul> 
<pre id="SEiPR"><code>/**
 * 根据客户端id关闭客户端
 * @param clientId
 */
private void closeClientByClientId(String clientId) {
    String emqxApiBaseUrl = "http://localhost:8081";  // EMQ X API 地址
    try {
        // 对clientId进行编码（避免clientId有特殊字符，比如/）
        String encodedClientId = URLEncoder.encode(clientId, StandardCharsets.UTF_8.toString());

        // 构建关闭连接的 URL
        String closeConnectionUrl = emqxApiBaseUrl + "/api/v4/clients/" + encodedClientId;

        // 创建 URL 对象
        URL url = new URL(closeConnectionUrl);

        // 创建 HttpURLConnection
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();

        // 设置访问权限
        connection.setRequestProperty("authorization", "Basic YWRtaW46cHVibGlj");

        // 设置请求方法为 DELETE
        connection.setRequestMethod("DELETE");

        // 获取响应码
        int responseCode = connection.getResponseCode();

        if (responseCode == HttpURLConnection.HTTP_NO_CONTENT) {
            System.out.println("Successfully closed client connection with clientId: " + clientId);
        } else {
            System.out.println("Failed to close client connection. Response Code: " + responseCode);
        }
        
        // 关闭连接
        connection.disconnect();
    } catch (Exception e) {
        e.printStackTrace();
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a5c67c29a986087fbb88c7beb5ac37d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Transformer模型详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4949c0a23281879ed569198f0c94014b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">midjourney怎么用来设计logo？midjourney商用logo技巧</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>