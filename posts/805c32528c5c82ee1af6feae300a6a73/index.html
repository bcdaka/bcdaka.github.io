<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Python机器学习】回归——局部加权线性回归 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/805c32528c5c82ee1af6feae300a6a73/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Python机器学习】回归——局部加权线性回归">
  <meta property="og:description" content="线性回归有一个问题就是有可能出现过拟合现象，因为它求的是具有最小均方误差的无偏估计。如果模型欠拟合将不能取得最好的预测效果。所以有些方法允许在估计中引入一些偏差，从而降低预测的均方误差。
其中一个方法就是局部加权线性回归（LWLR），在该算法中，我们给待预测点附近的每个点赋予一定的权重，然后在这个子集上基于最小均方差来进行普通的回归，与kNN一样，这种算法每次预测均需要事先选取出对应的数据子集。
该算法解出回归系数w的形式如下：
其中w是一个矩阵，用来给每个数据点赋予权重。
LWLR使用“核”来对附近的点赋予更高的权重。核的类型可以自由选择，最常用的核是高斯核，高斯核对应的权重如下：
这样就构建了一个只包含对角元素的权重矩阵w，并且点x与x(i)越近，w(i,i)将会越大。上述工时包含一个需要用户指定的参数k，它决定了对附近的点赋予多大的权重，这也是使用LWLR时唯一需要考虑的参数。
下面是具体的代码实现：
def lwlr(testPoint,xArr,yArr,k=1.0): xMat=mat(xArr) yMat=mat(yArr).T m=shape(xMat)[0] #创建对角矩阵 weights=mat(eye((m))) for j in range(m): diffMat=testPoint-xMat[j,:] weights[j,j]=exp(diffMat*diffMat.T/(-2.0*k**2)) xTx=xMat.T*(weights*xMat) if linalg.det(xTx)==0.0: print(&#39;行列式为0&#39;) return ws=xTx.I*(xMat.T*(weights*yMat)) return testPoint*ws def lwlrTest(testArr,xArr,yArr,k=1.0): m=shape(testArr)[0] yHat=zeros(m) for i in range(m): yHat[i]=lwlr(testArr[i],xArr,yArr,k) return yHat 上述代码的作用是给定x空间中的任意一点，计算出对应的预测值yHat。函数lwlr()的开头读入数据并创建所需矩阵，之后创建对角权重矩阵weights。权重矩阵时一个方针，阶数等于样本点个数。也就是说，该矩阵为每个样本点初始化了一个权重，接着算法将遍历数据集，计算每个样本点对应的权重值：随着样本点与待预测点距离的递增，权重将以指数级衰减。输入参数k控制衰减的速度。在权重矩阵计算完毕后，就可以得到对回归系数ws的一个估计。
另一个函数是lwlrTest()，用于为数据集中每个点调用lwlr()，这有助于求解k的大小。
载入数据并对单点进行估计：
xArr,yArr=loadDataSet(&#39;ex0.txt&#39;) print(lwlr(xArr[0],xArr,yArr,1.0)) print(lwlr(xArr[0],xArr,yArr,0.001)) 计算拟合曲线并绘图
yHat=lwlrTest(xArr,xArr,yArr,0.003) xMat=mat(xArr) srtInd=xMat[:,1].argsort(0) xSort=xMat[srtInd][:,0,:] import matplotlib.pyplot as plt fig=plt.figure() ax=fig.add_subplot(111) ax.plot(xSort[:,1],yHat[srtInd]) ax.scatter(xMat[:,1].flatten().A[0],mat(yArr).T.flatten().A[0],s=2,c=&#39;red&#39;) plt.show() 可以观察上图的效果。
局部加权线性回归也存在一个问题，那就是增加了计算了，因为它对每个点做预测时都必须使用整个数据集。如果避免这些计算就可以减少程序运行时间，从而环节因计算了增加带来的问题。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-07T10:58:50+08:00">
    <meta property="article:modified_time" content="2024-08-07T10:58:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Python机器学习】回归——局部加权线性回归</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>线性回归有一个问题就是有可能出现过拟合现象，因为它求的是具有最小均方误差的无偏估计。如果模型欠拟合将不能取得最好的预测效果。所以有些方法允许在估计中引入一些偏差，从而降低预测的均方误差。</p> 
<p>其中一个方法就是局部加权线性回归（LWLR），在该算法中，我们给待预测点附近的每个点赋予一定的权重，然后在这个子集上基于最小均方差来进行普通的回归，与kNN一样，这种算法每次预测均需要事先选取出对应的数据子集。</p> 
<p>该算法解出回归系数w的形式如下：</p> 
<p style="text-align:center;"><img alt="\widehat{w}=(X^{T}WX)^{-1}X^{T}Wy" class="mathcode" src="https://images2.imgbox.com/49/64/SGemxhTa_o.png"></p> 
<p>其中w是一个矩阵，用来给每个数据点赋予权重。</p> 
<p>LWLR使用“核”来对附近的点赋予更高的权重。核的类型可以自由选择，最常用的核是高斯核，高斯核对应的权重如下：</p> 
<p style="text-align:center;"><img alt="w(i,i)=exp\left ( \frac{\left | x^{(i)}-x \right |}{-2k^{2}} \right )" class="mathcode" src="https://images2.imgbox.com/eb/9a/OlCQnW4C_o.png"></p> 
<p>这样就构建了一个只包含对角元素的权重矩阵w，并且点x与x(i)越近，w(i,i)将会越大。上述工时包含一个需要用户指定的参数k，它决定了对附近的点赋予多大的权重，这也是使用LWLR时唯一需要考虑的参数。</p> 
<p>下面是具体的代码实现：</p> 
<pre><code class="language-python">def lwlr(testPoint,xArr,yArr,k=1.0):
    xMat=mat(xArr)
    yMat=mat(yArr).T
    m=shape(xMat)[0]
    #创建对角矩阵
    weights=mat(eye((m)))
    for j in range(m):
        diffMat=testPoint-xMat[j,:]
        weights[j,j]=exp(diffMat*diffMat.T/(-2.0*k**2))
    xTx=xMat.T*(weights*xMat)
    if linalg.det(xTx)==0.0:
        print('行列式为0')
        return 
    ws=xTx.I*(xMat.T*(weights*yMat))
    return testPoint*ws

def lwlrTest(testArr,xArr,yArr,k=1.0):
    m=shape(testArr)[0]
    yHat=zeros(m)
    for i in range(m):
        yHat[i]=lwlr(testArr[i],xArr,yArr,k)
    return yHat</code></pre> 
<p>上述代码的作用是给定x空间中的任意一点，计算出对应的预测值yHat。函数lwlr()的开头读入数据并创建所需矩阵，之后创建对角权重矩阵weights。权重矩阵时一个方针，阶数等于样本点个数。也就是说，该矩阵为每个样本点初始化了一个权重，接着算法将遍历数据集，计算每个样本点对应的权重值：随着样本点与待预测点距离的递增，权重将以指数级衰减。输入参数k控制衰减的速度。在权重矩阵计算完毕后，就可以得到对回归系数ws的一个估计。</p> 
<p>另一个函数是lwlrTest()，用于为数据集中每个点调用lwlr()，这有助于求解k的大小。</p> 
<p>载入数据并对单点进行估计：</p> 
<pre><code class="language-python">xArr,yArr=loadDataSet('ex0.txt')
print(lwlr(xArr[0],xArr,yArr,1.0))
print(lwlr(xArr[0],xArr,yArr,0.001))</code></pre> 
<p><img alt="" height="43" src="https://images2.imgbox.com/29/a4/4fS49bY4_o.png" width="300"></p> 
<p>计算拟合曲线并绘图</p> 
<pre><code class="language-python">yHat=lwlrTest(xArr,xArr,yArr,0.003)
xMat=mat(xArr)
srtInd=xMat[:,1].argsort(0)
xSort=xMat[srtInd][:,0,:]

import matplotlib.pyplot as plt
fig=plt.figure()
ax=fig.add_subplot(111)
ax.plot(xSort[:,1],yHat[srtInd])
ax.scatter(xMat[:,1].flatten().A[0],mat(yArr).T.flatten().A[0],s=2,c='red')
plt.show()</code></pre> 
<p><img alt="" height="423" src="https://images2.imgbox.com/48/64/LsvlDOEv_o.png" width="600"></p> 
<p>可以观察上图的效果。</p> 
<p>局部加权线性回归也存在一个问题，那就是增加了计算了，因为它对每个点做预测时都必须使用整个数据集。如果避免这些计算就可以减少程序运行时间，从而环节因计算了增加带来的问题。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e0deecdf539b64b39714685e0e355dc8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">结合傅里叶变换和传统特征提取方法，通过XGBoost检测计算机生成图像</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90d306a5ca189a358d686a73777d4c47/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据与人工智能：数据隐私与安全的挑战_ai 和 数据隐私</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>