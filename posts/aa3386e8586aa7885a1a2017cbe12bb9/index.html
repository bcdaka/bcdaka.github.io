<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java 学习】：内部类详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/aa3386e8586aa7885a1a2017cbe12bb9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java 学习】：内部类详解">
  <meta property="og:description" content="详谈Java内部类 📃📃本文将通过Java内部类 是什么，为什么被广泛使用，以及又该如何去使用这三个方面来详细讲解其相关知识。
文章目录
1. 内部类是什么
2. 为什么要使用内部类
3. 如何使用内部类
🍉成员内部类
🥑静态内部类
🥝局部内部类
🍋‍🟩匿名内部类
📖总结
1. 内部类是什么 🥬🥬🥬当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么这个内部的完整结构最好使用内部类。在 Java 中，可以将一个类定义在另一个类或者一个方法的内部，前者称为内部类，后者称为外部类。内部类也是封装的一种体现。
/** * 外部类 */ public class Outer { //... /** * 内部类 */ class Inner { //... } } 注：
我们一般将内部类分为四种：成员内部类、静态内部类、局部（方法内部类）、匿名内部类。外部类的定义是相对于内部类而言的 2. 为什么要使用内部类 🍈使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。——《Think in java》
🍈也就是说内部类拥有类的基本特征。（eg：可以继承父类，实现接口）在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。
注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，但是这里不推荐使用。
举个例子🌰
/** 1. OuterClass类继承了 A，实现了IFunctionA */ public class OuterClass extends A implements IFunctionA{ /** *	Inner类继承了 B，实现了IFunctionB */ public class InnerClass extends B implements IfunctionB{ // } } 除此之外，内部类还可以：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-04T21:19:46+08:00">
    <meta property="article:modified_time" content="2024-09-04T21:19:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java 学习】：内部类详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="%E8%AF%A6%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB"><strong><span style="color:#956fe7;">详谈Java<a href="https://so.csdn.net/so/search?q=%E5%86%85%E9%83%A8%E7%B1%BB&amp;spm=1001.2101.3001.7020" title="内部类">内部类</a></span></strong></h3> 
<p>📃📃本文将通过Java内部类 是什么，为什么被广泛使用，以及又该如何去使用这三个方面来详细讲解其相关知识。</p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="1.%20%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#1.%20%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">1. 内部类是什么</a></p> 
<p id="2.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:40px;"><a href="#2.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">2. 为什么要使用内部类</a></p> 
<p id="3.%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:40px;"><a href="#3.%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">3. 如何使用内部类</a></p> 
<p id="%F0%9F%8D%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">🍉成员内部类</a></p> 
<p id="%F0%9F%A5%91%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%F0%9F%A5%91%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">🥑静态内部类</a></p> 
<p id="%F0%9F%A5%9D%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%F0%9F%A5%9D%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">🥝局部内部类</a></p> 
<p id="%F0%9F%8D%8B%E2%80%8D%F0%9F%9F%A9%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8B%E2%80%8D%F0%9F%9F%A9%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">🍋‍🟩匿名内部类</a></p> 
<p id="%F0%9F%93%96%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%F0%9F%93%96%E6%80%BB%E7%BB%93" rel="nofollow">📖总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1.%20%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88">1. 内部类是什么</h3> 
<p>🥬🥬🥬当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么这个内部的完整结构最好使用内部类。<strong>在 Java 中，可以将一个类定义在另一个类或者一个方法的内部，前者称为内部类，后者称为外部类。</strong>内部类也是封装的一种体现。</p> 
<pre><code class="language-cpp">/**
* 外部类
*/
public class Outer {
	//...
	/**
	* 内部类
	*/
	class Inner {
		//...
	}
}
</code></pre> 
<blockquote> 
 <p>注：</p> 
 <ul><li>我们一般将内部类分为四种：<code>成员内部类</code>、<code>静态内部类</code>、<code>局部（方法内部类）</code>、<code>匿名内部类</code>。</li><li><code>外部类</code>的定义是相对于<code>内部类</code>而言的</li></ul> 
</blockquote> 
<h3 id="2.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB"><strong>2. 为什么要使用内部类</strong></h3> 
<p>🍈使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<span style="color:#956fe7;"><strong>——《Think in java》</strong></span></p> 
<p>🍈也就是说<strong>内部类拥有类的基本特征</strong>。（eg：可以继承父类，实现接口）在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。</p> 
<p><span style="color:#be191c;"><strong>注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，但是这里不推荐使用。</strong></span></p> 
<p>举个例子🌰</p> 
<pre><code class="language-cpp">/**
 1. OuterClass类继承了 A，实现了IFunctionA
*/
public class OuterClass extends A implements IFunctionA{ 
	/**
	*	Inner类继承了 B，实现了IFunctionB
	*/
	public class InnerClass extends B implements IfunctionB{
	//
	} 
}
</code></pre> 
<p>除此之外，内部类还可以：</p> 
<blockquote> 
 <ol><li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li><li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li><li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li><li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li></ol> 
</blockquote> 
<h3 id="3.%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB">3. 如何使用内部类</h3> 
<p><img alt="" height="915" src="https://images2.imgbox.com/41/09/yubR9y4D_o.png" width="1200"></p> 
<h4 id="%F0%9F%8D%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB">🍉成员内部类</h4> 
<p> 💢💢也叫作实例内部类，是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p> 
<pre><code class="language-cpp">// 实例内部类
class OuterClass {
    public int data1 = 1;
    public static int data2 = 2;
    private int data3 = 3;

    /*成员方法*/
    public void OuterMethod() {
        System.out.println("外部类的outerMethod方法");
    }

    /*静态方法*/
    public static void OuterStaticMethod() {
        System.out.println("外部类的outerStaticMethod静态方法");
    }

    /*同名方法*/
    public void test() {
        System.out.println("OutClass:: test()");
        InnerClass innerClass = new InnerClass();
    }

    class InnerClass{
        public int data1 = 10;
        public int data4 = 4;
        //public static int data5 = 5; // jdk8 不支持这样用，jdk17 支持
        public static final int data5 = 5;
        private int data6 = 6;

        public void InnerShow() {
            //访问内部类属性
            System.out.println("data4：" + data4);
            //内部类访问外部属性
            System.out.println("data3：" + data3); //私有权限的外部类也可以访问
            //当和外部类冲突时，直接引用属性名，是内部类的成员属性
            System.out.println("data1：" + this.data1); // 默认为this
            //当和外部类属性名重叠时，可通过外部类名.this.属性名
            System.out.println("data1：" + OuterClass.this.data1); //访问外部类成员

            // 访问外部类方法
            OuterMethod();
            OuterStaticMethod();
        }

        public void test(){
            System.out.println("InnerClass:: test()");
        }
    }
    /* 	外部类访问内部类信息 */
    public void OuterShow() {
        InnerClass inner = new InnerClass();
        inner.InnerShow();
    }
}


public class Test {
    /*其他类使用成员内部类*/
    public static void main(String[] args) {
        //创造内部类对象，两种实例化方法
        OuterClass outer = new OuterClass(); //外部类对象
        OuterClass.InnerClass inner1 = outer.new InnerClass();

        OuterClass.InnerClass inner2 = new OuterClass().new InnerClass();

        inner1.test();
        inner1.InnerShow();
    }
}</code></pre> 
<p><span style="color:#b95514;"><strong>运行结果如下：</strong></span></p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/00/68/thipMlO7_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;">注：成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</span></p> 
<blockquote> 
 <p><span style="color:#b95514;"><strong>总结：【抓住关键字——实例，作为实例成员存在】</strong></span></p> 
 <ol><li>内部类可以是任何的访问修饰符。由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰符。</li><li>内部类的内部不能有静态信息。</li><li>内部类也是类，该继承的继承、该重写的重写、该重载的重载，this和super随便用。</li><li>外部类访问内部类的信息，必须先实例化内部类，然后 . 访问。</li><li>内部类可以直接使用外部类的任何信息，如果属性或者方法发生冲突（重名），使用Outer.this.成员</li><li>其他类访问内部类：成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在外部类的对象。</li></ol> 
</blockquote> 
<h4></h4> 
<h4 id="%F0%9F%A5%91%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">🥑静态内部类</h4> 
<p> 💢💢Java中的静态内部类是指在一个类的内部定义的另一个类，并且该内部类被声明为静态(static)的。静态内部类与普通内部类的区别在于，静态内部类不依赖于外部类的实例，<strong>可以直接通过外部类名访问</strong>。</p> 
<pre><code class="language-cpp">// 静态内部类
class Outer{
    public int data1 = 1;
    /*外部类定义的属性(重名)*/
    public static int data2 = 2;
    public static int data3 = 3;

    static {
        System.out.println("外部类静态块");
    }

    /*成员方法*/
    public void outerMothod() {
        System.out.println("外部类的成员方法");
    }

    /*静态方法*/
    public static void outerStaticMethod() {
        System.out.println("外部类的静态方法");
    }

    public void test(){
        System.out.println("Out:: test()");
    }

    static class Inner{
        public int data4 = 4;
        public static int data5 = 5;
        public static int data3 = 33; //与外部类同名

        public void InnerShow(){
            // 访问内部类成员属性
            System.out.println("内部类data4："+data4);
            //访问外部类成员属性
            //不重名访问 非静态成员属性
            //System.out.println(data1); //无法直接访问外部非静态成员
            System.out.println("data1：" + new Outer().data1); // 间接访问

            //不重名直接访问 静态成员属性
            System.out.println("外部类data2：" + data2);
            System.out.println("内部的data3："+ data3);
            System.out.println("外部的data3："+ Outer.data3);

        }

        public static void InnerStaticShow() {
            //调用时会先加载Outer类，类加载的时候执行静态代码块
            outerStaticMethod();
        }
    }
    /*外部类的内部如何和内部类打交道*/
    public static void callInner() {
        System.out.println(Inner.data3);
        //System.out.println(Inner.data4); //内部类的非静态成员属性无法直接访问
        System.out.println(new Inner().data4);
        
        Inner.InnerStaticShow();
        new Inner().InnerShow();  //调用内部类非静态成员方法
    }
}

public class Test {
    /* 其他类访问静态内部类 */
    public static void main(String[] args) {
        //访问静态内部类的静态方法，Inner类被加载（类加载的时候执行静态代码块）,此时外部类未被加载，独立存在，不依赖于外部类。
        Outer.Inner.InnerStaticShow();

        // 静态内部类实例化，不用()，相比于实例内部类优点：不需要外部类的引用
        Outer.Inner in = new Outer.Inner();
        in.InnerShow();
    }
}
</code></pre> 
<blockquote> 
 <p><span style="color:#b95514;"><strong>总结：【抓住关键字——static，作为静态成员存在】</strong></span></p> 
 <ol><li>静态内部类可以包含任意的信息，可以被任意访问权限修饰符修饰。</li><li>静态内部类的方法只能访问外部类的static关联的成员。</li><li>静态内部类可以独立存在，不依赖于其他外围类。</li><li>其他类访问内部类的静态信息，直接 Outer.Inner.static成员信息 就可以了。</li><li>其他类实例化内部类 Outer.Inner instance = new Outer.Inner();，然后 instance. 成员信息（属性、方法）即可。</li></ol> 
</blockquote> 
<h4 id="%F0%9F%A5%9D%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB" style="background-color:transparent;">🥝局部内部类</h4> 
<p>💢💢 Java局部内部类是指在一个方法或代码块内部定义的内部类。与成员内部类不同，局部内部类只能在定义它的方法或代码块内部使用，无法在外部访问。</p> 
<pre><code class="language-cpp">public class Out {
    /*属性和方法*/
    private int outVariable = 1;
    /*外部类定义的属性*/
    private int commonVariable = 2;
    /*静态的信息 */
    private static int outStaticVariable = 3;

    /*成员外部方法*/
    public void outerMethod() {
        System.out.println("我是外部类的outerMethod方法");
    }
    /*静态外部方法*/
    public static void outerStaticMethod() {
        System.out.println("我是外部类的outerStaticMethod静态方法");
    }
    /*成员方法，内部定义局部内部类*/
    public void outerCreatMethod(int value) {
        //public int a = 1; // 不行，局部内部类不能有访问权限修饰符
        //static int a = 1; // 也不能有static 修饰
        final int a = 1;
        int a1 = 1; // 默认为final
        /*女性*/
        boolean sex = false;
        //sex = true; // 有且仅有赋值一次

        /*局部内部类，类前不能有访问修饰符*/
        class In {
            private int inVariable = 10;
            private int commonVariable = 20;
            /*局部内部类方法*/
            public void InnerShow() {
                System.out.println("innerVariable:" + inVariable);
                //局部变量
                System.out.println("是否男性:" + sex);
                System.out.println("参数value:" + value);
                //调用外部类的信息
                System.out.println("outerVariable:" + outVariable);
                System.out.println("内部的commonVariable:" + commonVariable);
                System.out.println("外部的commonVariable:" + Out.this.commonVariable);
                System.out.println("outerStaticVariable:" + outStaticVariable);
                outerMethod();
                outerStaticMethod();
            }
        }
        //局部内部类只能在方法内使用
        In in = new In();
        in.InnerShow();
    }

    /* 开始程序 */
    public static void main(String[] args) {
        Out out = new Out();
        out.outerCreatMethod(100);
    }
}</code></pre> 
<blockquote> 
 <p><span style="color:#b95514;"><strong>总结：【抓住关键——作用域，作为方法的局部成员存在】</strong></span></p> 
 <ol><li>局部内部类不能有访问权限修饰符，无法创建静态信息。                                                局部内部类就像是方法里面的一个局部变量一样，是不能有访问权限修饰符和static修饰符的。</li><li>只能在方法内部使用。</li><li>可以直接访问方法内的局部变量和参数。【存在限制，需要 final 或有效的final修饰的】，但是不能更改。 <br> ①直接被final修饰的变量。<br> ②已被赋值且始终未改变的变量（有且仅有赋值一次），引用指向不能改变。注：JDK8以前（不包括8）只能访问被final修饰的变量。</li><li>编译器也有自己独立的字节码文件，命名格式：外部类名字$数字内部类名字.class</li></ol> 
</blockquote> 
<p><span style="color:#fe2c24;">注：当局部内部类的变量修改时，</span>就会产生如下错误：</p> 
<p>Variable ‘xxx’ is accessed from within inner class, needs to be final or effectively final</p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/65/4d/z9BqHQNE_o.png" width="1200"></p> 
<p>传入局部内部类所在方法的参数同理，如果一直不变则可使用，反之则会报错。</p> 
<p><span style="color:#956fe7;"><strong>局部内部类使用的很少,了解即可.</strong></span></p> 
<p></p> 
<h4 id="%F0%9F%8D%8B%E2%80%8D%F0%9F%9F%A9%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">🍋‍🟩匿名内部类</h4> 
<p> 💢💢 Java匿名内部类是一种特殊的内部类，它没有类名，直接在创建对象时定义并实现。通常用于创建只需要使用一次的类对象，可以简化代码，提高代码的可读性和可维护性。</p> 
<ul><li>原本我们需要创建子类或实现类，去继承父类或实现接口，才能重写其中的方法。但是有时候我们这样做了，然而子类和实现类却只使用了一次（定义了一个对象）。这个时候我们就可以使用匿名内部类，不用去写子类和实现类，起到简化代码的作用。</li><li>这样做，把子类继承父类，重写父类中的方法，创建子类对象，合成了一步完成，减少了其中创建子类的过程。或者实现类实现接口，重写接口中的方法，创建实现类对象，合成了一步完成，减少了其中创建实现类的过程。</li></ul> 
<p>🥬匿名内部类是不能有名字的类，他们不能被引用，只能在创建是用 new 语句来声明他们。</p> 
<pre><code class="language-cpp">// 匿名内部类
interface IA{
    void test(); //接口的方法不能有具体实现
}

public class Test {
    public static void main(String[] args) {
        // 匿名内部类对象，下面两种方法都可以
        /*new IA(){
            @Override
            public void test() {
                System.out.println("重写了接口的方法");
            }
        };*/

        IA a = new IA(){
            @Override
            public void test() {
                System.out.println("重写了接口的方法");
            }
        };
        a.test();
    }
}</code></pre> 
<blockquote> 
 <p><span style="color:#b95514;"><strong>总结：【匿名内部类通常继承一个类或实现一个接口】</strong></span></p> 
 <ol><li>匿名内部类没有访问权限修饰符。</li><li>匿名内部类要实现父类或接口的所有抽象方法，其他方法可以根据自己的情况进行重写。</li><li>匿名内部类不应当添加自己的成员，因为匿名类没有类名无法向下转型，父类型的引用无法访问。</li><li>匿名内部类访问方法参数时也有和局部内部类同样的限制。</li><li>匿名内部类没有构造方法。</li><li>匿名类是表达式形式定义的，所以末尾以分号;来结束。</li></ol> 
</blockquote> 
<p></p> 
<hr> 
<h3 id="%F0%9F%93%96%E6%80%BB%E7%BB%93">📖总结</h3> 
<p>具体来说，内部类信息（属性、方法）可以和外部类重名；内部类是具有类的基本特征的独立实体；可以利用访问修饰符隐藏内部类的实施细节，提供了更好的封装；静态内部类使用时可直接使用，不需先创造外部类。</p> 
<blockquote> 
 <p>💞 💞 💞<strong>那么本篇到此就结束，希望我的这篇博客可以给你提供有益的参考和启示，感谢大家支持！！！祝大家天天开心</strong></p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/34/9a/sDfd8MxK_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a215ba530e737dbd8e40819ad5860bf3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言从头学56——学习头文件limits.h</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/730bc81d2503610b72e39b6bd8531ed7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python篇】PyQt5 超详细教程——由入门到精通（序篇）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>