<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;第三十一弹---C&#43;&#43;继承机制深度剖析(下) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/88df7d98cc57d3bc7244a165cf128930/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;第三十一弹---C&#43;&#43;继承机制深度剖析(下)">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
1.菱形继承及菱形虚拟继承 1.1 单继承 单继承：一个子类只有一个直接父类时称这个继承关系为单继承。
Student的直接父类是Person，PostGraduate的直接父类是Student，且都只有一个直接父类，因此均为单继承。
注意：
PostGraduate类只是间接继承了Person，因此依旧为单继承关系。
1.2 多继承 多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承。
Assistant子类既继承了Student父类，又继承了Teacher父类，且均为直接继承，因此为多继承关系。 1.3 菱形继承 菱形继承：菱形继承是多继承的一种特殊情况，如下图：
菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。
在Assistant的对象中Person成员会有两份。 从上图我们可以看到，Assistant 类既继承了 Student 类又继承了 Teacher 类 ，而 Student 类和 Teacher 类又都继承了 Person 类， 因此 Assistant 类中有两份 Person 的成员，这也就是菱形继承所带来的数据冗余和二义性问题。
class Person { public: string _name; // 姓名 }; class Student : public Person { protected: int _num; //学号 }; class Teacher : public Person { protected: int _id; // 职工编号 }; // Assistant有两份Person类，存在数据冗余和二义性问题 class Assistant : public Student, public Teacher { protected: string _majorCourse; // 主修课程 }; 主函数">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T18:48:22+08:00">
    <meta property="article:modified_time" content="2024-08-05T18:48:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;第三十一弹---C&#43;&#43;继承机制深度剖析(下)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;">✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏： </span><a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】">【C++详解】</a></p> 
<h2>1.菱形继承及菱形虚拟继承</h2> 
<h3>1.1 单继承</h3> 
<blockquote> 
 <p>单继承：一个子类<span style="background-color:#fbd4d0;">只有一个直接父类</span>时称这个继承关系为<strong><span style="color:#0d0016;">单继承</span></strong>。</p> 
</blockquote> 
<p><img alt="" height="268" src="https://images2.imgbox.com/59/32/QmSsMJ70_o.png" width="433"></p> 
<p><span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Student</span></span>的直接父类是<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Person</span></span>，<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">PostGraduate</span></span>的直接父类是<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Student</span></span>，且都只有一个直接父类，因此均为单继承。</p> 
<p><strong><span style="color:#fe2c24;">注意：</span></strong></p> 
<p><span style="color:#ed7976;"><span style="background-color:#fbd4d0;">PostGraduate</span></span>类只是间接继承了<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Person</span></span>，因此依旧为单继承关系。</p> 
<h3>1.2 多继承 </h3> 
<blockquote> 
 <p>多继承：一个子类有<span style="background-color:#fbd4d0;">两个或以上直接父类</span>时称这个继承关系为<strong><span style="color:#0d0016;">多继承。</span></strong></p> 
</blockquote> 
<p><img alt="" height="220" src="https://images2.imgbox.com/82/0e/2n6mxzlP_o.png" width="492"></p> 
<p><span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Assistant</span></span>子类既继承了<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Student</span></span>父类，又继承了<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Teacher</span></span>父类，且均为直接继承，因此为多继承关系。 </p> 
<h3>1.3 菱形继承</h3> 
<blockquote> 
 <p>菱形继承：<strong><span style="color:#0d0016;">菱形继承</span></strong>是<span style="background-color:#fbd4d0;">多继承的一种特殊情况</span>，如下图：</p> 
</blockquote> 
<p><img alt="" height="351" src="https://images2.imgbox.com/43/17/SWlrrC8r_o.png" width="691"></p> 
<p>菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有<span style="background-color:#f9eda6;">数据冗余和二义性</span>的问题。<br> 在<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Assistant</span></span>的对象中<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Person</span></span>成员会有两份。 </p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/4a/0f/zKxTilkz_o.png" width="470"></p> 
<blockquote> 
 <p>从上图我们可以看到，<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Assistant </span></span>类既继承了 <span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Student</span></span> 类又继承了 <span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Teacher</span></span> 类 ，而 <span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Student</span></span> 类和 <span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Teacher</span></span> 类又都继承了 <span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Person</span></span> 类， 因此 <span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Assistant</span></span> 类中有两份 <span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Person</span></span> 的成员，这也就是菱形继承所带来的数据冗余和二义性问题。</p> 
</blockquote> 
<p></p> 
<pre><code>class Person
{
public:
	string _name; // 姓名
};
class Student : public Person
{
protected:
	int _num; //学号
};
class Teacher : public Person
{
protected:
	int _id; // 职工编号
};
// Assistant有两份Person类，存在数据冗余和二义性问题
class Assistant : public Student, public Teacher
{
protected:
	string _majorCourse; // 主修课程
};</code></pre> 
<p><span style="background-color:#f9eda6;"> 主函数</span></p> 
<pre><code>int main()
{
	Assistant a;
	// a._name = "peter"; // 这样会有二义性无法明确知道访问的是哪一个
	// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决
	a.Student::_name = "xxx";
	a.Teacher::_name = "yyy";
}</code></pre> 
<p><span style="background-color:#f9eda6;">监视窗口 </span></p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/3e/46/xRnIUouB_o.png" width="1180"></p> 
<p>从监视窗口我们可以看到，<span style="background-color:#fbd4d0;">Assistant类确实有两个_name成员，且不相同，即存在数据冗余问题。</span></p> 
<p><strong><span style="color:#0d0016;">解决办法：</span></strong></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">虚拟继承可以解决菱形继承的二义性和数据冗余的问题</span></strong>。如上面的继承关系，<span style="background-color:#fbd4d0;">在Student和</span><br><span style="background-color:#fbd4d0;">Teacher的继承Person时使用虚拟继承</span>，即可解决问题。需要注意的是，<span style="background-color:#f9eda6;">虚拟继承不要在其他地方去使用。</span></p> 
</blockquote> 
<pre><code>class Person
{
public:
	string _name; // 姓名
};
// 腰部加virtual关键字，构成虚拟继承
class Student : virtual public Person
{
protected:
	int _num; //学号
};
// 腰部加virtual关键字，构成虚拟继承
class Teacher : virtual public Person
{
protected:
	int _id; // 职工编号
};

class Assistant : public Student, public Teacher
{
protected:
	string _majorCourse; // 主修课程
};</code></pre> 
<p><span style="background-color:#f9eda6;">主函数 </span></p> 
<pre><code>int main()
{
	Assistant a;
	a._name = "peter"; 
}</code></pre> 
<p><span style="background-color:#f9eda6;"> 测试结果</span></p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/d6/2d/BAoKCr54_o.png" width="1194"></p> 
<h4>1.3.1 虚拟继承解决数据冗余和二义性的原理</h4> 
<p><br> 为了研究虚拟继承原理，我们给出了一个简化的菱形继承继承体系，再借助内存窗口观察对象成<br> 员的模型。</p> 
<pre><code>class A
{
public:
	int _a;
};
class B : public A
{
public:
	int _b;
};
class C : public A
{
public:
	int _c;
};
class D : public B, public C
{
public:
	int _d;
};</code></pre> 
<p><span style="background-color:#f9eda6;"> 主函数</span></p> 
<pre><code>int main()
{
	D d;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4;
	d._d = 5;
}</code></pre> 
<p>下图是<span style="background-color:#fbd4d0;">菱形继承的内存对象成员模型</span>：这里可以看到数据冗余。</p> 
<p><img alt="" height="477" src="https://images2.imgbox.com/ea/47/xROmSBJy_o.png" width="1033"></p> 
<p><span style="background-color:#f9eda6;">虚拟继承代码 </span></p> 
<pre><code>class A
{
public:
	int _a;
};
class B : virtual public A
{
public:
	int _b;
};
class C : virtual public A
{
public:
	int _c;
};
class D : public B, public C
{
public:
	int _d;
};</code></pre> 
<p><span style="background-color:#f9eda6;"> 主函数</span></p> 
<pre><code>int main()
{
	D d;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4;
	d._d = 5;
}</code></pre> 
<p>下图是菱形虚拟继承的内存对象成员模型：这里可以分析出D对象中<span style="background-color:#fbd4d0;">将A放到了对象组成的最下</span><br><span style="background-color:#fbd4d0;">面</span>，这个A同时属于B和C，那么B和C如何去找到公共的A呢？这里是通过了B和C的两个指针，指<br> 向的一张表。这两个指针叫<strong><span style="color:#0d0016;">虚基表指针</span></strong>，这两个表叫<strong><span style="color:#0d0016;">虚基表</span></strong>。<span style="background-color:#fbd4d0;">虚基表中存的偏移量，通过偏移量</span><br><span style="background-color:#fbd4d0;">可以找到下面的A(虚基类)。</span></p> 
<p> <img alt="" height="435" src="https://images2.imgbox.com/b4/c7/pfuj6swV_o.png" width="1200"></p> 
<p></p> 
<p>B 和 C 对象也满足菱形虚拟继承的对象模型</p> 
<pre><code>int main()
{
    B* pb = &amp;d;
    C* pc = &amp;d;
    return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">画图演示</span></p> 
<p><img alt="" height="362" src="https://images2.imgbox.com/96/40/tLKYVqhp_o.png" width="1038"></p> 
<p>下面是上面的<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">Person</span></span>关系菱形虚拟继承的原理解释：</p> 
<p><img alt="" height="539" src="https://images2.imgbox.com/1b/5a/wRbff2hn_o.png" width="705"></p> 
<p><strong><span style="color:#fe2c24;">总结：</span></strong></p> 
<blockquote> 
 <p>在实践中可以设计多继承，但是切记不要实现菱形继承，因为太复杂，容易出各种问题。</p> 
</blockquote> 
<p></p> 
<h2>2.继承的总结和反思</h2> 
<p></p> 
<ul><li>1. 很多人说<strong><span style="color:#0d0016;">C++语法复杂，其实多继承就是一个体现</span></strong>。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂。所以一般不建议设计出多继承，一定不要设计出菱形继承。否则在复杂度及性能上都有问题。</li><li>2. 多继承可以认为是C++的缺陷之一，很多后来的OO语言都没有多继承，如Java。</li><li>3. 继承和组合</li></ul> 
<p><span style="color:#0d0016;"><strong>        public继承是一种is-a的关系</strong></span>。也就是说<span style="background-color:#fbd4d0;">每个派生类对象都是一个基类对象。</span></p> 
<p><strong><span style="color:#0d0016;">        组合是一种has-a的关系</span></strong>。假设B组合了A，<span style="background-color:#fbd4d0;">每个B对象中都有一个A对象。</span></p> 
<pre><code>// 组合 一个类中的包含另一个类 has-a 关系
class A
{
private:
	int _a;
};

class B
{
private:
	A _aa;
	int _b;
};</code></pre> 
<blockquote> 
 <p>组合和继承很类似，都可以使用其他类的成员，但是组合只能使用public成员，而继承既可以使用public成员，也可以使用protected成员，除此之外还能间接使用private成员。</p> 
</blockquote> 
<p><br><strong><span style="color:#0d0016;">继承</span></strong>允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">白箱复用</span></span>(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">基类的内部细节对子类可见</span></span>(子类可以访问基类保护成员)。继承一定程度<span style="background-color:#f9eda6;">破坏了基类的封装，基类的改变</span>，对派生类有很大的影响。派生类和基类间的<span style="background-color:#f9eda6;">依赖关系很强，耦合度高</span>。</p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">低耦合</span></strong>：类和类之间，模块与模块之间关系不那么紧密，关联不高。</p> 
 <p><strong><span style="color:#0d0016;">高耦合</span></strong>：类和类之间，模块与模块之间关系很紧密，关联很高。</p> 
</blockquote> 
<p><br><strong><span style="color:#0d0016;">对象组合</span></strong>是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">黑箱复用</span></span>(black-box reuse)，因为<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">对象的内部细节是不可见的</span></span>。对象只以“黑箱”的形式出现。组合类之间<span style="background-color:#f9eda6;">没有很强的依赖关系，耦合度低</span>。优先使用对象组合有助于你保持每个类被封装。</p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/6d/db/hkun4Y4t_o.png" width="328"><br> 实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。 </p> 
<p>总结：</p> 
<blockquote> 
 <p>适合is-a关系(学生是人)，就用继承；适合has-a关系(汽车有轮胎)，就用组合；is-a 和 has-a 关系都可以(栈是特殊的链表，栈有链表)，就用组合。</p> 
</blockquote> 
<h2>3.笔试面试题</h2> 
<p><br> 1. 什么是菱形继承？菱形继承的问题是什么？</p> 
<blockquote> 
 <p>        存在四个类，分别是person，student，teacher，assistant，student和teacher分别继承自person，assistant同时继承student和teacher，这种现象就是<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">菱形继承</span></span>，更深层次的说，assistant内部维护了两份person的成员变量，一份来自student，一份来自person，<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">菱形继承是一种特殊的多继承</span></span>。<br>   因为维护了两份person的成员变量，因此，在使用的时候，不知道是使用的来自teacher还是student，因此会存在<span style="background-color:#ffd900;">数据冗余</span>和<span style="background-color:#ffd900;">二义性</span>的问题。</p> 
</blockquote> 
<p><br> 2. 什么是菱形虚拟继承？如何解决数据冗余和二义性的</p> 
<blockquote> 
 <p>        菱形虚拟继承是一种解决菱形继承问题的技术。在 C++ 中，通过虚继承（virtual inheritance）可以确保最基类在菱形继承结构中只被继承一次，从而避免数据冗余和二义性问题。</p> 
 <p>        菱形虚拟继承通过使用virtual关键字来修饰共同的基类，确保了子类在继承多个拥有共同基类的父类时，只会在内存中保留一份基类数据，并且使用唯一的基类指针来访问基类成员，从而解决了数据冗余和二义性的问题。</p> 
</blockquote> 
<p><br> 3. 继承和组合的区别？什么时候用继承？什么时候用组合？</p> 
<blockquote> 
 <p>        public继承是一种is-a的关系，也就是说每一个派生类对象都是一个基类对象，组合是一种has-a的关系，假设B组合了A，每一个B对象中都有一个A对象。继承一定程度上破坏了基类的封装性，基类的改变对于派生类有很大的影响，派生类和基类间的依赖关系很强，耦合度很高。并且这种通过派生类的方式的复用通常被称为白箱复用（white-box reuse）。对象通过组合来获得更多功能，要求被组合的对象有良好定义的接口，这种复用风格称为黑箱复用，组合类之间没有很强的依赖关系，耦合度低。</p> 
 <p>        适合is-a关系(学生是人)，就用继承；适合has-a关系(汽车有轮胎)，就用组合；is-a 和 has-a 关系都可以(栈是特殊的链表，栈有链表)，就用组合。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4bad2ce39700547f2e93220f2fd51053/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据采集与预处理【大数据导论】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d698e9d756861fb9d3440a3a017497b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言文件IO</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>