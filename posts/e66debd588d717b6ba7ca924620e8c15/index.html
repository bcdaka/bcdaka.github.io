<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法从零到精通 (一) ~ 快慢双指针 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e66debd588d717b6ba7ca924620e8c15/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法从零到精通 (一) ~ 快慢双指针">
  <meta property="og:description" content="1. 前言 快慢双指针是一种常用的算法技巧，通常用于解决涉及链表或数组的问题。它的基本思想是使用两个指针，一个移动速度快（快指针），一个移动速度慢（慢指针），来解决特定的问题。这两个指针通常从序列的起始位置开始，并以不同的步伐向前移动，直到达到特定的条件为止。
快慢双指针是指在算法处理过程中，使用两个指针，分别从序列的起始位置出发，按照不同的步伐向前移动，直到满足某种条件。通常快指针的移动速度比慢指针快，这样可以加快算法的执行速度。 判断链表是否有环：快指针每次移动两步，慢指针每次移动一步，如果存在环，快指针最终会追上慢指针。
找到链表的中间节点：快指针每次移动两步，慢指针每次移动一步，当快指针到达链表末尾时，慢指针所在位置即为中间节点。
移除排序数组中的重复项：使用快慢指针，当快指针遇到不同的元素时，将其复制到慢指针位置，然后慢指针前进一步。
2. 我对快慢指针的理解 1. 数组划分 cur：从左到右扫描数组，遍历数组(快指针)dest：已处理的区间内，非零元素的最后一个位置cur(快指针)遇到符合题意的值，把他加入这个区间。一般是先dest&#43;&#43;然后和cur交换 如何做到维护该区间一直到结束，是解题的关键。
// 符合题意 不符合题意 未处理元素 // [0~dest] [dest &#43; 1 ~ cur] [cur &#43; 1 ~ n] 达到最终的目的就是持续这三块区域的关系
2. 判断是否成环 快指针每次移动两步，慢指针每次移动一步，如果存在环，快指针最终会追上慢指针。
3 例题分析 3.1 移动零 (数组划分) public void moveZeroes(int[] nums) { // 符合题意(非0元素) 不符合题意(0) 未处理元素 // [0~dest] [dest &#43; 1 ~ cur] [cur &#43; 1 ~ n] // 要想维护上面的关系到结束，必须让cur遇到符合题意的和dest后一个元素(不符合题意的交换)， // 然后让dest&#43;&#43;(扩大符合题意的范围)，继续维护该区间 int n = nums.length, cur = 0, dest = -1; while(cur !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T22:03:42+08:00">
    <meta property="article:modified_time" content="2024-07-24T22:03:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法从零到精通 (一) ~ 快慢双指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1. 前言</h3> 
<blockquote> 
 <p>快慢双指针是一种常用的算法技巧，通常用于解决涉及链表或数组的问题。它的基本思想是使用两个指针，一个移动速度快（快指针），一个移动速度慢（慢指针），来解决特定的问题。这两个指针通常从序列的起始位置开始，并以不同的步伐向前移动，直到达到特定的条件为止。</p> 
</blockquote> 
<ul><li>快慢双指针是指在算法处理过程中，使用两个指针，分别从序列的起始位置出发，按照不同的步伐向前移动，直到满足某种条件。通常快指针的移动速度比慢指针快，这样可以加快算法的执行速度。</li><li> <p><strong>判断链表是否有环</strong>：快指针每次移动两步，慢指针每次移动一步，如果存在环，快指针最终会追上慢指针。</p> </li><li> <p><strong>找到链表的中间节点</strong>：快指针每次移动两步，慢指针每次移动一步，当快指针到达链表末尾时，慢指针所在位置即为中间节点。</p> </li><li> <p><strong>移除排序数组中的重复项</strong>：使用快慢指针，当快指针遇到不同的元素时，将其复制到慢指针位置，然后慢指针前进一步。</p> </li></ul> 
<h3> 2. 我对快慢指针的理解</h3> 
<h4>1. 数组划分</h4> 
<p><img alt="" height="999" src="https://images2.imgbox.com/48/2f/m7I4LQJn_o.png" width="1200"></p> 
<ol><li>cur：从左到右扫描数组，遍历数组(快指针)</li><li>dest：已处理的区间内，非零元素的最后一个位置</li><li>cur(快指针)遇到符合题意的值，把他加入这个区间。一般是先dest++然后和cur交换</li></ol> 
<p>如何做到维护该区间一直到结束，是解题的关键。</p> 
<pre>// 符合题意           不符合题意            未处理元素
// [0~dest]        [dest + 1 ~ cur]       [cur + 1 ~ n]</pre> 
<p><span style="color:#1c7892;"><strong>达到最终的目的就是持续这三块区域的关系</strong></span></p> 
<h4>2. 判断是否成环</h4> 
<p>快指针每次移动两步，慢指针每次移动一步，如果存在环，快指针最终会追上慢指针。</p> 
<h3>3 例题分析</h3> 
<h4>3.1 移动零 (数组划分)</h4> 
<p><img alt="" height="822" src="https://images2.imgbox.com/fb/75/YoCpFqj1_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d4/36/7hJEu6QS_o.png" width="1200"> </p> 
<pre><code class="language-java">public void moveZeroes(int[] nums) {
        // 符合题意(非0元素)    不符合题意(0)    未处理元素
        // [0~dest]        [dest + 1 ~ cur]       [cur + 1 ~ n]
        // 要想维护上面的关系到结束，必须让cur遇到符合题意的和dest后一个元素(不符合题意的交换)，
        //                        然后让dest++(扩大符合题意的范围)，继续维护该区间
        int n = nums.length, cur = 0, dest = -1;
        while(cur != n){
            if (nums[cur] != 0){//遇到符合题意的，交换来维持三个区间关系
                dest++;
                int temp = nums[dest];
                nums[dest] = nums[cur];
                nums[cur] = temp;
            }
            cur++;
        }
    }</code></pre> 
<h4>3.2 去重</h4> 
<p><img alt="" height="751" src="https://images2.imgbox.com/53/3f/ILhNyH9K_o.png" width="1200"></p> 
<p>下面的图，就是我对上题一步步的分析：</p> 
<p><img alt="" height="999" src="https://images2.imgbox.com/e0/00/zkEaxGH0_o.png" width="1200"></p> 
<p><span style="color:#1a439c;"><strong>只要一直维持这三个区域到结束，就可以解答本题。</strong></span></p> 
<p>如何维持，就成了解答本题的关键。</p> 
<pre><code class="language-java">    /**
     * 思路分析：
     * 1. dest(慢指针)：确定没有重复元素的最后一个位置， cur(快指针)：扫描完的最后一个位置
     * 2. 通过比较快慢指针的内容确定是否重复 (因为非严格递增，相同的都是连续的)
     * 3. 遇到一个不重复元素，就是符合[0 ~ dest]区间，就和dest+1不符合该区间的交换位置
     *
     * @param arr
     * @return
     */
    public static int[] arrayDeduplication(int[] arr) {
        //默认第一个元素不重复
        int n = arr.length, dest = 0, cur = 1;
        while (cur &lt; n) {
            if (arr[cur] != arr[dest]) {//找到一个不符合题意的
                dest++;
                int temp = arr[dest];
                arr[dest] = arr[cur];
                arr[cur] = temp;
            }
            cur++;
        }
        return Arrays.copyOf(arr,dest + 1);
    }

    public static void main(String[] args) {
        int[] arr = {1, 1, 4, 4, 5, 6, 7, 7, 8, 8, 8, 8, 8};
        int[] distinction = arrayDeduplication(arr);
        System.out.println(Arrays.toString(distinction));
        System.out.println(Arrays.toString(arr));
    }</code></pre> 
<h4>3.3 复写零</h4> 
<p><img alt="" height="844" src="https://images2.imgbox.com/0a/f5/koBe7l6X_o.png" width="1200"></p> 
<p>思路分析：</p> 
<p>因为正序会造成覆盖，比如 0 1 2  正序读0索引-&gt;会变成 0 0 1，下次读1索引就被覆盖了。 </p> 
<ol><li>先判断要舍弃的元素。(因为要复写，数组大小不变总要舍去)</li><li>从后往前复写，0写两次，其余写一次</li><li>判断临界情况，防止最后一个为0且数组长度不够</li></ol> 
<p>剩下的内容代码有详细的注释。 </p> 
<pre><code class="language-java">  // 正着写会被覆盖，因此倒序，倒序要确定复写舍弃的元素(复写位置)，最后处理临界：cur越界
    // 1. 通过 0 cur移动两步 和 非0 cur移动一步，确定从dest位置开始复写
    // 2. 倒序开始写，dest读取到0复写 cur写两遍  非0  cur写一遍
    // 3. 处理临界：最后一个修改成0， dest-2  cur-1
    public static void duplicateZeros(int[] arr) {
        //因为读完写，所以dest(慢指针)为0，cur为-1
        int n = arr.length, dest = 0, cur = -1;
        //1.确定dest位置
        while(dest &lt; n){
            if (arr[dest] == 0){//写两边
                cur++;cur++;
            }else {//写一遍
                cur++;
            }
            if (cur &gt;= n - 1) break;//写到最后或者写过(最后一个为0)，dest就不需要读了
            dest++;
        }
        //3. 处理临界
        if (cur == n){
            arr[n - 1] = 0;
            cur--;cur--;
            dest--;
        }
        //此时dest后面就是舍弃的元素
        //2. 倒序复写
        while(dest &gt;= 0){
            if (arr[dest] == 0){//写两边
                arr[cur--] = 0;
                arr[cur--] = 0;
            }else {//写一遍
                arr[cur--] = arr[dest];
            }
            dest--;
        }
    }</code></pre> 
<p> </p> 
<h4>3.4 快乐数（判断环）</h4> 
<p><img alt="" height="1168" src="https://images2.imgbox.com/77/b1/lwLRDXYf_o.png" width="1200"> 通过数字的取平方和来模拟移动，取一次移动一步，俩次移动两步，这样就可以模拟链表。和判断链表是否有环，原理一样，仅需判断链表中元素是否为1即可。</p> 
<p>为什么是必定有环的呢？？？</p> 
<p><span style="color:#1c7892;"><strong>原因就是鸽巢原理，所以数据范围有限的情况下，必定有环。5个人有6个糖，必定有一个人是有两个糖即以上的。</strong></span></p> 
<p><img alt="" height="1074" src="https://images2.imgbox.com/48/af/QA2wRlCg_o.png" width="1200"></p> 
<pre><code class="language-java">public class Test3 {
    //通过数来模拟指针移动，和判断链表是否有环，原理一样
    //仅需判断链表中元素是否为1即可
    //要么是1，要么无限循环的原因就是鸽巢原理，所以数据范围有限的情况下，必定有环
    public boolean isHappy(int n) {
        int slow = n, fast = bitSum(n);
        while(slow != fast){
            slow = bitSum(slow);
            fast = bitSum(bitSum(fast));
        }
        return slow == 1;
    }

    //求一个数各个元素的平方和，相当于移动一次
    private int bitSum(int num){
        int sum = 0;
        while(num != 0){
            int t = num % 10;
            sum += t * t;
            num /= 10;
        }
        return sum;
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21235fcaea58278e1bf5891babab6f6e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】——单链表实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46a935762338d94b8e3d2e473dd89c39/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL中实现动态表单中JSON元素精准匹配的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>