<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从 QWebEnginePage 打印文档 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6a900b7e434c87c1101690191c6d82ed/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="从 QWebEnginePage 打印文档">
  <meta property="og:description" content="QWebEnginePage 是 Qt WebEngine 模块中的一个类，它提供了用于处理网页内容的接口。如果你想要打印 QWebEnginePage 中的内容，你可以使用 QPrinter 和 QPrintDialog 类来实现。
项目配置了 Qt WebEngine 模块，并且在你的.pro文件中包含了相应的配置：
QT &#43;= webenginewidgets
实现代码如下，参考
printme « webenginewidgets « examples - qt/qtwebengine.git - Qt WebEngine
main.cpp
#include &#34;printhandler.h&#34; #include &lt;QApplication&gt; #include &lt;QShortcut&gt; #include &lt;QWebEngineView&gt; int main(int argc, char *argv[]) { QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling); QApplication app(argc, argv); view.setUrl(QUrl(QStringLiteral(&#34;qrc:/index.html&#34;))); view.resize(1024, 750); view.show(); PrintHandler handler; handler.setPage(view.page()); auto printPreviewShortCut = new QShortcut(QKeySequence(Qt::CTRL &#43; Qt::Key_P), &amp;view); auto printShortCut = new QShortcut(QKeySequence(Qt::CTRL &#43; Qt::SHIFT &#43; Qt::Key_P), &amp;view); QObject::connect(printPreviewShortCut, &amp;QShortcut::activated, &amp;handler, &amp;PrintHandler::printPreview); QObject::connect(printShortCut, &amp;QShortcut::activated, &amp;handler, &amp;PrintHandler::print); return app.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-11T18:10:58+08:00">
    <meta property="article:modified_time" content="2024-07-11T18:10:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从 QWebEnginePage 打印文档</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><code>QWebEnginePage</code> 是 Qt WebEngine 模块中的一个类，它提供了用于处理网页内容的接口。如果你想要打印 <code>QWebEnginePage</code> 中的内容，你可以使用 <code>QPrinter</code> 和 <code>QPrintDialog</code> 类来实现。</p> 
<p>项目配置了 Qt WebEngine 模块，并且在你的.pro文件中包含了相应的配置：</p> 
<p><code>QT += webenginewidgets</code></p> 
<p>实现代码如下，参考</p> 
<p><a href="https://code.qt.io/cgit/qt/qtwebengine.git/tree/examples/webenginewidgets/printme?h=5.15" rel="nofollow" id="url_1" title="printme « webenginewidgets « examples - qt/qtwebengine.git - Qt WebEngine">printme « webenginewidgets « examples - qt/qtwebengine.git - Qt WebEngine</a></p> 
<p><code>main.cpp</code></p> 
<pre><code class="language-cpp">#include "printhandler.h"
#include &lt;QApplication&gt;
#include &lt;QShortcut&gt;
#include &lt;QWebEngineView&gt;

int main(int argc, char *argv[])
{
    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    QApplication app(argc, argv);

    view.setUrl(QUrl(QStringLiteral("qrc:/index.html")));
    view.resize(1024, 750);
    view.show();

    PrintHandler handler;
    handler.setPage(view.page());

    auto printPreviewShortCut = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_P), &amp;view);
    auto printShortCut = new QShortcut(QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_P), &amp;view);

    QObject::connect(printPreviewShortCut, &amp;QShortcut::activated, &amp;handler, &amp;PrintHandler::printPreview);
    QObject::connect(printShortCut, &amp;QShortcut::activated, &amp;handler, &amp;PrintHandler::print);

    return app.exec();
}
</code></pre> 
<p>printhandler.h</p> 
<pre><code class="language-cpp">#ifndef PRINTHANDLER_H
#define PRINTHANDLER_H
#include &lt;qapplication.h&gt;
#include &lt;QObject&gt;
#include &lt;QWebEngineView&gt;
#include &lt;QPrinter&gt;
#include &lt;QPrintPreviewDialog&gt;
#include &lt;QEventLoop&gt;
#include &lt;QPrintDialog&gt;
#include &lt;QWidget&gt;
#include &lt;QMainWindow&gt;
#include &lt;QPrinterInfo&gt;
#include "CustomWebEnginePage.h"
#include &lt;qapplication.h&gt;
#include &lt;qtimer.h&gt;
class PrintHandler : public QObject
{
    Q_OBJECT
public:
    explicit PrintHandler(QString printName, QObject *parent = nullptr);

signals:

public slots:

public:
    void setPrintUrl(const QString&amp;  url);
	void setPrintName(const QString&amp; name);
    void printPreview();
    void printDocument(QPrinter *printer);
    void print();
private:
    //void print();
private:
	QString mPrinterName;
	CustomWebEnginePage* mPage;
	QString mUrl;
    bool mInPrintPreview;
	QTimer* waitTimer;
};

#endif // PRINTHANDLER_H
</code></pre> 
<p>printhandler.cpp</p> 
<pre><code class="language-cpp">#include "printhandler.h"
#include &lt;QDebug&gt;
PrintHandler::PrintHandler(QString printName,QObject *parent) : mPrinterName(printName),QObject(parent)
{
    mInPrintPreview=false;
	mPage = new CustomWebEnginePage();
	waitTimer = new QTimer();
	waitTimer-&gt;setInterval(500);
	waitTimer-&gt;setSingleShot(true);
	connect(waitTimer, &amp;QTimer::timeout, this, &amp;PrintHandler::print);
	connect(mPage, &amp;CustomWebEnginePage::loadFinished, waitTimer, static_cast&lt;void(QTimer::*)()&gt;(&amp;QTimer::start));

}

void PrintHandler::setPrintUrl(const QString&amp; url)
{
	mUrl = url;
	mPage-&gt;setUrl(url);
}

void PrintHandler::printPreview()
{
    if (!mPage)
      return;
    if (mInPrintPreview)
      return;
	mInPrintPreview = true;
    QPrinter printer;
    QPrintPreviewDialog preview(&amp;printer, mPage-&gt;view());
    connect(&amp;preview, &amp;QPrintPreviewDialog::paintRequested,
          this, &amp;PrintHandler::printDocument);
    preview.exec();
	mInPrintPreview = false;
}


void PrintHandler::printDocument(QPrinter *printer)
{
    QEventLoop loop;
    bool result;
    auto printPreview = [&amp;](bool success) { result = success; loop.quit(); };
    mPage-&gt;print(printer, std::move(printPreview));
    loop.exec();
    if (!result) {
        QPainter painter;
        if (painter.begin(printer)) {
            QFont font = painter.font();
            font.setPixelSize(15);
            painter.setFont(font);
            painter.drawText(QPointF(10,25),QStringLiteral("Could not generate print preview."));

            painter.end();
        }
    }
}
void PrintHandler::setPrintName(const QString&amp; name)
{
    mPrinterName = name;
}



void PrintHandler::print()
{
    QStringList printerNameList=QPrinterInfo::availablePrinterNames();
    foreach (QString printerStr, printerNameList)
    {
        if(printerStr== mPrinterName)
        {
            QPrinter printer(QPrinter::HighResolution);
			printer.setOutputFormat(QPrinter::NativeFormat);

            printer.setPrinterName(printerStr);
			//打印界面
           /* QPrintDialog dialog(&amp;printer, mPage-&gt;view());
            if (dialog.exec() != QDialog::Accepted)
                return;*/
            printDocument(&amp;printer);
			return;
        }
    }
      qDebug() &lt;&lt; "not find printer";


}
</code></pre> 
<p>对于https的url连接，会出现"你的连接不是专用连接"报警，需要跳过这个报警所以要继承QWebEnginePage做个类</p> 
<p>CustomWebEnginePage.h</p> 
<pre><code class="language-cpp">#pragma once

#include &lt;QWebEnginePage&gt;

class CustomWebEnginePage : public QWebEnginePage
{
	Q_OBJECT

public:
	CustomWebEnginePage();
	~CustomWebEnginePage();
	virtual bool certificateError(const QWebEngineCertificateError &amp;certificateError);
};
</code></pre> 
<p>CustomWebEnginePage.cpp</p> 
<pre><code class="language-cpp">#include "CustomWebEnginePage.h"

CustomWebEnginePage::CustomWebEnginePage()
{
}

CustomWebEnginePage::~CustomWebEnginePage()
{
}


bool CustomWebEnginePage::certificateError(const QWebEngineCertificateError &amp;certificateError)
{
	return true;
}
</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5e47609587c16f0baab215bdf5cdeb26/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">习惯用Windows的设计师又想有类似Raycast的效率工具，怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4686eda218c6a18c997b98dcbde0c346/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Django ORM中的F 对象</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>