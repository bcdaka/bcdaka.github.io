<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java——递归 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/698397f6b49a0ecf3902595cebe1c10b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java——递归">
  <meta property="og:description" content="一、递归介绍 1、什么是递归 递归在Java编程中是指一个方法调用自身的编程技巧。
public static void foo() { //... foo();//方法调用自身 //... } 2、递归用于什么场景 递归是一种常见的算法设计方法，特别适用于解决那些可以分解为相似子问题的问题。常见的递归问题包括阶乘计算、斐波那契数列、树和图的遍历等。
3、递归包含部分 一个递归方法通常由两部分组成：
基准情况（Base Case）：递归过程中终止递归的条件。如果没有基准情况，递归将进入无限循环。递归步骤（Recursive Step）：将问题分解为一个或多个子问题，并调用自身处理这些子问题。 4、递归的优点和缺点 优点：
代码简洁：递归可以使代码更简洁和易读，特别是对于那些自然递归的问题（如树遍历）。自然性：某些问题（如组合数学中的问题）自然适合递归解决。 缺点：
性能问题：递归可能导致较大的栈消耗，特别是在递归深度较深时，可能引发栈溢出错误（StackOverflowError）。复杂性：对于某些问题，递归可能导致重复计算，效率较低；需要进行优化（如使用记忆化或动态规划）。 二、递归详细解释 1、递归详细解释 下面我们用以下例子来介绍递归：
public class Test { public static void test(int n) { if(n &gt; 0) { test(n - 1); } System.out.println(n); } public static void main(String[] args) { test(2); } } 首先是主函数调用 test 方法，传入的参数是 2。这时就会开辟一个 test 函数栈帧，这里的参数 n 值为 2。
然后这里的 test 函数开始依次执行它的方法体的语句，首先就是判断 n &gt; 0，如果 n &gt; 0 为真就调用 test(2 - 1)，可以发现这里 n &gt; 0 为真，所以接着调用 test(2 - 1)，即调用 test(1)， 然后就是开辟下一个 test 函数的栈帧，这里的参数为 1。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-13T11:20:13+08:00">
    <meta property="article:modified_time" content="2024-06-13T11:20:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java——递归</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、递归介绍</h2> 
<h3>1、什么是递归</h3> 
<p>递归在Java编程中是指一个方法调用自身的编程技巧。</p> 
<pre><code class="language-java">    public static void foo() {
		//...
		foo();//方法调用自身
		//...
	}</code></pre> 
<h3>2、递归用于什么场景</h3> 
<p>递归是一种常见的算法设计方法，特别适用于解决那些可以分解为相似子问题的问题。常见的递归问题包括阶乘计算、斐波那契数列、树和图的遍历等。</p> 
<h3>3、递归包含部分</h3> 
<p>一个递归方法通常由两部分组成：</p> 
<ol><li><strong>基准情况（Base Case）</strong>：递归过程中终止递归的条件。如果没有基准情况，递归将进入无限循环。</li><li><strong>递归步骤（Recursive Step）</strong>：将问题分解为一个或多个子问题，并调用自身处理这些子问题。</li></ol> 
<h3>4、递归的优点和缺点</h3> 
<p><strong>优点</strong>：</p> 
<ul><li>代码简洁：递归可以使代码更简洁和易读，特别是对于那些自然递归的问题（如树遍历）。</li><li>自然性：某些问题（如组合数学中的问题）自然适合递归解决。</li></ul> 
<p><strong>缺点</strong>：</p> 
<ul><li>性能问题：递归可能导致较大的栈消耗，特别是在递归深度较深时，可能引发栈溢出错误（StackOverflowError）。</li><li>复杂性：对于某些问题，递归可能导致重复计算，效率较低；需要进行优化（如使用记忆化或动态规划）。</li></ul> 
<h2>二、递归详细解释</h2> 
<h3>1、递归详细解释</h3> 
<p>下面我们用以下例子来介绍递归：</p> 
<pre><code class="language-java">public class Test {
	public static void test(int n) {
		if(n &gt; 0) {
			test(n - 1);
		}
		System.out.println(n);
	}
	public static void main(String[] args) {
		test(2);
	}
}</code></pre> 
<p>首先是主函数调用 test 方法，传入的参数是 2。这时就会开辟一个 test 函数栈帧，这里的参数 n 值为 2。</p> 
<p><img alt="" height="1168" src="https://images2.imgbox.com/42/7c/lA8hnHGs_o.png" width="1200"></p> 
<p>然后这里的 test 函数开始依次执行它的方法体的语句，首先就是判断 n &gt; 0，如果 n &gt; 0 为真就调用 test(2 - 1)，可以发现这里 n &gt; 0 为真，所以接着调用 test(2 - 1)，即调用 test(1)， 然后就是开辟下一个 test 函数的栈帧，这里的参数为 1。</p> 
<p><img alt="" height="1176" src="https://images2.imgbox.com/ef/87/0NcfUUhW_o.png" width="1200"></p> 
<p>然后这里的 test 函数还是要开始依次执行它的方法体的语句，首先还是判断 n &gt; 0，如果 n &gt; 0 为真就调用 test(1 - 1)，可以发现这里 n &gt; 0 为真，所以接着调用 test(1 - 1)，即调用 test(0)， 然后就是开辟下一个 test 函数的栈帧，这里的参数为 0。</p> 
<p><img alt="" height="1175" src="https://images2.imgbox.com/dc/4c/3xJVIafN_o.png" width="1200"></p> 
<p>然后这个参数为 0 的 test 方法还是依次执行方法体的语句，这次 n &gt; 0 为假，所以不再调用 test 方法，执行后面的语句 System.out.println(n); 显示这时 n 的值，我们将在左下角显示。</p> 
<p><img alt="" height="1171" src="https://images2.imgbox.com/9a/d9/8nYxVA3x_o.png" width="1200"></p> 
<p>在这个语句执行完毕后，这个参数为 0 的 test 方法就完成了调用，这个方法就会返回，</p> 
<p><img alt="" height="1182" src="https://images2.imgbox.com/ae/7d/xPLiT8TV_o.png" width="1200"></p> 
<p>然后这个函数栈帧就会被销毁：</p> 
<p><img alt="" height="1170" src="https://images2.imgbox.com/3d/74/M91LZltY_o.png" width="1200"></p> 
<p>然后上面的函数返回就到了参数为 1 的 test 方法方法体内，接下来还会接着执行后面未执行的语句 System.out.println(n); 会打印这时 n 的值，为 1。</p> 
<p><img alt="" height="1175" src="https://images2.imgbox.com/39/96/lFoNqfRU_o.png" width="1200"></p> 
<p>在执行过这个语句后，参数为 1 的 test 方法就完成了调用，它也将返回，然后栈帧被销毁。然后就返回到参数为 2 的 test 方法方法体内，接着执行未执行的语句，打印这时的 n 的值，打印 2。</p> 
<p><img alt="" height="1178" src="https://images2.imgbox.com/8a/5e/paQECCBE_o.png" width="1200"></p> 
<p>在执行完成这个语句后，参数为 2 的 test 方法也会返回，然后它的栈帧也会被销毁。</p> 
<p><img alt="" height="1175" src="https://images2.imgbox.com/71/0f/JVM0ZR5n_o.png" width="1200"></p> 
<p>最终 main 函数也返回，最终程序结束。</p> 
<p>最终的运行结果为：</p> 
<p><img alt="" height="93" src="https://images2.imgbox.com/cc/d0/WNhBgBWQ_o.png" width="93"></p> 
<p><img alt="" height="1187" src="https://images2.imgbox.com/7c/ae/uIopCJXz_o.png" width="1200"></p> 
<p>这张图中的粉色箭头就代表<strong>递进</strong>，蓝色箭头就代表<strong>归来</strong>，所以合称递归。</p> 
<h3>2、递归求阶乘</h3> 
<blockquote> 
 <p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。</p> 
</blockquote> 
<p>例如：</p> 
<p>5! = 5 * 4 * 3 * 2 * 1 = 120</p> 
<p>下面为具体代码：</p> 
<pre><code class="language-java">public class Test {
	public static int factorial(int n) {
		if(n == 1) {
			return 1;
		} else {
			return n * factorial(n - 1);
		}
	}
	public static void main(String[] args) {
		System.out.println("5! = " + factorial(5));
	}
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="37" src="https://images2.imgbox.com/e6/e5/09gGRJ7b_o.png" width="131"></p> 
<p>下面我们详细解释一下：</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/6c/4c/FyEdIhXm_o.png" width="848"></p> 
<p>显然，阶乘是可以一点点将较为复杂的问题转换为一个个较基础的问题的。</p> 
<p><img alt="" height="1168" src="https://images2.imgbox.com/ff/d0/aDARKTmZ_o.png" width="1200"></p> 
<p>可以发现这个递归方法求阶乘就是将数字依次递减一，当数字减到 1 时，函数归来，从 1 依次乘到这个数字，最终得到阶乘的结果。</p> 
<h3>3、递归注意事项</h3> 
<p>我们可以看到递归会在栈区开辟很多空间，如果递归没有结束条件，就会一直开辟空间，最终会造成栈溢出（Stack Overflow），导致程序崩溃。</p> 
<p>所以递归一定要有结束条件，二且要不断逼近结束条件。</p> 
<h2>三、递归使用实例</h2> 
<h3>1、使用递归求斐波那契数列</h3> 
<blockquote> 
 <p>斐波那契数列（Fibonacci sequence）是一个著名的数列，其定义基于以下递推关系：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）</p> 
 <p>这一数列由意大利数学家莱昂纳多·斐波那契（Leonardo Fibonacci）在研究兔子的繁殖问题时引入，因此也被称为“兔子数列”。</p> 
 <p>其数值为：1、1、2、3、5、8、13、21、34……</p> 
</blockquote> 
<p>下面为具体代码：</p> 
<pre><code class="language-java">public class Test {
	public static int fibonacci(int n) {
		if(n == 0) {
			return 0;
		} else if(n == 1) {
			return 1;
		}else {
			return (fibonacci(n - 2) + fibonacci(n - 1));
		}
	}
	public static void main(String[] args) {
		for(int i = 1; i &lt;= 10; i++) {
			System.out.println("第" + i + "项为 " + fibonacci(i));
		}
	}
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/1b/03/vzxWj1eh_o.png" width="191"></p> 
<p>下面为图解，用以 4 为参数调用 fibonacci 方法为例：</p> 
<p><img alt="" height="951" src="https://images2.imgbox.com/f2/6d/5l4VshH0_o.png" width="1200"></p> 
<h3>2、用递归解决猴子吃桃子</h3> 
<blockquote> 
 <p>猴子每天吃一半数目的桃子，再吃一个桃子，已知第十天还没有吃，就只剩下一个桃子了。求第一天有几个桃子。</p> 
 <p>这里的规律就是前一天的桃子是后一天的桃子数加一再乘二。</p> 
</blockquote> 
<pre><code class="language-java">public class Test {
	//day为还剩1个桃子的天数，n是要求有几个桃子的天数
	public static int foo(int day,int n) {
		if(n == day) {
			return 1;
		}
		return (foo(day,n + 1) + 1) * 2;
	}
	public static void main(String[] args) {
		System.out.println(foo(10,1));//第10天还有1个桃子，要求第1天有几个桃子
	}
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="35" src="https://images2.imgbox.com/19/ec/JhkyHntd_o.png" width="72"></p> 
<p>下面为具体图解：</p> 
<p><img alt="" height="564" src="https://images2.imgbox.com/2a/c0/3D4Mn158_o.png" width="1200"></p> 
<h3>3、汉诺塔</h3> 
<blockquote> 
 <ol><li><strong>目标</strong>：将所有圆盘从源柱（源杆，通常称为A）移动到目标柱（目标杆，通常称为C），并遵守以下规则。</li><li><strong>圆盘</strong>：有𝑛n个圆盘，所有圆盘大小不一，且初始状态下所有圆盘都按照从大到小的顺序叠放在源柱上。</li><li><strong>柱子</strong>：有三根柱子，分别称为源柱（A）、辅助柱（B）和目标柱（C）。</li><li><strong>移动规则</strong>： 
   <ul><li>每次只能移动一个圆盘。</li><li>圆盘只能放置在另一根柱子的顶部。</li><li>不能将大圆盘放在小圆盘上方。</li></ul></li></ol> 
</blockquote> 
<p>具体解释可以看我之前的文章《<a href="https://blog.csdn.net/stewie6/article/details/134795391" title="C语言——递归-CSDN博客">C语言——递归-CSDN博客</a>》。</p> 
<pre><code class="language-java">public class Test {
	public static void hanoiTower(int num, String col1, String col2, String col3) {
		if(num == 1) {//如果只有一个盘，直接移动
			System.out.println(col1 + "-&gt;" + col3);
		} else {
			hanoiTower(num - 1, col1, col3, col2);
			System.out.println(col1 + "-&gt;" + col3);
			hanoiTower(num - 1, col2, col1, col3);
		}
	}

	public static void main(String[] args) {
		hanoiTower(3, "源柱", "辅助柱", "目的柱");
	}
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/95/99/1ltP0qNU_o.png" width="207"></p> 
<p>可以发现这是最佳解法，与下面的步骤图一致。</p> 
<p><img alt="" height="1151" src="https://images2.imgbox.com/c3/c9/r0MBN2SJ_o.png" width="1200"></p> 
<p>对于上面的代码，我们开始详细介绍一下：</p> 
<p>就是汉诺塔可以逐步拆解成一个个小问题：</p> 
<p>就像上面的三个盘的情况，我们可以拆解成先将最上面的两个盘移动到辅助柱（中间步骤省略），然后将最底下的盘移动到目的柱，然后再将辅助柱上的两个盘移动到目的柱上（中间步骤省略）。</p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/26/84/hAPrDMgT_o.png" width="378"></p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/09/3d/NUIJHNTf_o.png" width="373"></p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/a8/9d/jQRqOzKA_o.png" width="369"></p> 
<p>可以发现这里的三个盘的情况就分解成了<img alt="" height="240" src="https://images2.imgbox.com/67/f8/TcOuYO5A_o.png" width="860"></p> 
<p>一个盘的情况就可以直接移动到目标盘了。</p> 
<p>然后我们看两个盘的情况：</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/9b/8f/Sh3qDLJm_o.png" width="350"></p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/eb/30/JaTNOno6_o.png" width="344"></p> 
<p><img alt="" height="232" src="https://images2.imgbox.com/06/ef/hVZATZ2O_o.png" width="339"></p> 
<p>可以发现两个盘的情况就变成了三个一个盘的情况：<br><img alt="" height="243" src="https://images2.imgbox.com/46/43/wmh94eal_o.png" width="870"></p> 
<p>这里我们就发现了规律，只要盘数 n 大于一，就将它分解成：</p> 
<p><strong>一次 n - 1 个盘的情况</strong></p> 
<p><strong>一次 1 个盘的情况</strong></p> 
<p><strong>一次 n - 1 个盘的情况</strong></p> 
<p>只要盘数等于一，就直接移动。最终得到以下代码：</p> 
<pre><code class="language-java">public class Test {
	public static void hanoiTower(int num, String col1, String col2, String col3) {
		if(num == 1) {//如果只有一个盘，直接移动
			System.out.println(col1 + "-&gt;" + col3);
		} else {
            //借助col3，将col1上面的n-1个盘移动到col2
			hanoiTower(num - 1, col1, col3, col2);
            //将col1最底的一个盘移动到col3
			System.out.println(col1 + "-&gt;" + col3);
            //借助col1，将col2上面的n-1个盘移动到col3
			hanoiTower(num - 1, col2, col1, col3);
		}
	}

	public static void main(String[] args) {
		hanoiTower(3, "源柱", "辅助柱", "目的柱");
	}
}</code></pre> 
<h2>四、回溯算法</h2> 
<h3>1、回溯算法介绍</h3> 
<p>回溯算法是一种系统化地搜索问题解空间的方法，主要用于解决组合优化问题。它通过递归地构建候选解，并在发现候选解不满足问题条件时回溯，从而尝试其他可能的选择。回溯算法的核心思想是不断尝试和撤销选择，直到找到所有可能的解决方案或者确认无解。</p> 
<h4>1）回溯算法的基本思想</h4> 
<p>回溯算法的基本思想可以概述为以下几点：</p> 
<ol><li><strong>尝试构建解决方案</strong>：从初始状态开始，逐步构建候选解。</li><li><strong>检测约束条件</strong>：在每一步选择后，检测当前候选解是否满足问题的约束条件。</li><li><strong>递归探索</strong>：如果当前候选解部分满足约束条件，则递归地尝试下一步选择。</li><li><strong>回溯及尝试其他选择</strong>：如果当前候选解不满足约束条件或无法继续构建有效解，则回溯到上一步，尝试其他可能的选择。</li><li><strong>终止条件</strong>：当找到一个完整且有效的解时，记录或输出解；当所有可能的选择都尝试完毕且无解时，终止搜索。</li></ol> 
<h4>2）回溯算法的应用场景</h4> 
<p>回溯算法适用于许多经典的计算问题，包括但不限于：</p> 
<ul><li><strong>组合问题</strong>：如八皇后问题、数独、组合和排列生成等。</li><li><strong>路径查找问题</strong>：如迷宫问题、骑士巡逻问题等。</li><li><strong>约束满足问题</strong>：如图着色问题、N皇后问题等。</li><li><strong>子集和问题</strong>：如背包问题、部分和问题等。</li></ul> 
<h4>3）回溯算法的一般框架</h4> 
<p>回溯算法的一般框架通常包括以下步骤：</p> 
<ol><li><strong>定义解空间</strong>：明确问题的解空间，以及解空间的结构。</li><li><strong>选择和约束条件</strong>：定义每一步选择的规则和约束条件。</li><li><strong>递归结构</strong>：通过递归函数构建解空间树，并在每一步选择后递归地继续尝试。</li><li><strong>回溯过程</strong>：在递归函数中进行选择、检测约束条件、递归探索、回溯及尝试其他选择。</li></ol> 
<h3>2、回溯算法实例</h3> 
<p>回溯算法本质上是一种深度优先搜索（DFS）。</p> 
<h4>1）老鼠走迷宫</h4> 
<blockquote> 
 <p>老鼠走迷宫，起点为左上角，终点为右下角，老鼠上下左右走动。0 代表空地，1 代表墙。</p> 
 <p>            {1,1,1,1,1,1,1},<br>             {1,0,0,0,0,0,1},<br>             {1,0,0,0,0,0,1},<br>             {1,1,1,1,0,0,1},<br>             {1,0,0,1,0,0,1},<br>             {1,0,0,1,0,0,1},<br>             {1,0,0,0,0,0,1},<br>             {1,1,1,1,1,1,1}</p> 
 <p><img alt="" height="226" src="https://images2.imgbox.com/8b/6a/dCiQguoy_o.png" width="194"></p> 
</blockquote> 
<p>以下是具体代码：</p> 
<pre><code class="language-java">public class Test {

	//假设1是障碍，0可走，2为找到的通路，3为走过不通
	public static boolean findWay(int[][] map, int row, int col) {
		if(map[6][5] == 2) {//终点为2则可达到终点
			return true;
		} else {//终点不是2则接着找路
			if(map[row][col] == 0) {//当前的位置为0才可继续走

				map[row][col] = 2;//当前位置是0，现在假设可以通过当前位置，把当前位置设为2

				if(findWay(map, row + 1, col)) {//尝试向下走，如果向下走可以，则返回真
					return true;
				} else if(findWay(map, row, col + 1)) {//尝试向右走，如果向右走可以，则返回真
					return true;
				} else if(findWay(map, row - 1, col)) {//尝试向上走，如果向上走可以，则返回真
					return true;
				} else if(findWay(map, row, col - 1)) {//尝试向左走，如果向左走可以，则返回真
					return true;
				} else {//上下左右都不可以走，将此处设为3，表示走过但走不通，然后回溯
					map[row][col] = 3;
					return false;
				}

			} else {//当前位置不是0，则回溯
				return false;
			}
		}
	}

	public static void printMap(int[][] map) {
		for(int i = 0; i &lt; map.length; i++) {
			for(int j = 0; j &lt; map[i].length; j++) {
				if(map[i][j] == 1) {
					System.out.printf("\033[48;5;19m  \033[0m");
				} else if(map[i][j] == 2) {
					System.out.printf("\033[48;5;22m  \033[0m");
				} else {
					System.out.printf("  ");
				}
			}
			System.out.println();
		}
	}

	public static void main(String[] args) {
		int[][] map = {
			{1,1,1,1,1,1,1},
			{1,0,0,0,0,0,1},
			{1,0,0,0,0,0,1},
			{1,1,1,1,0,0,1},
			{1,0,0,1,0,0,1},
			{1,0,0,1,0,0,1},
			{1,0,0,0,0,0,1},
			{1,1,1,1,1,1,1}
		};

		boolean res = findWay(map, 1, 1);
		if(res) {
			printMap(map);
		} else {
			System.out.println("未找到");
		}
		
	}
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/32/39/NjVDUmNb_o.png" width="226"></p> 
<p>可以发现路径是正确的，下面我们进行详细解释：</p> 
<p>首先第一步在主函数调用的 findWayj(map, 1, 1)，执行到 map[row][col] = 2 这句时，（1,1）位置就被设为了2，</p> 
<p><img alt="" height="1184" src="https://images2.imgbox.com/27/78/ulev2gEJ_o.png" width="1200"></p> 
<p>当这个函数执行到上图绿色箭头所指的语句时就会调用 findWay(map, 2, 1)，然后 findWay(map, 2, 1) 会接着执行下面的语句，执行到 map[row][col] = 2 这句时，也会将（2,1）的值设为 2，</p> 
<p><img alt="" height="1194" src="https://images2.imgbox.com/2f/01/3uLlVpv6_o.png" width="1200"></p> 
<p>然后 findWay(map, 2, 1) 执行到上图中绿色箭头所指的语句时，又会调用 findWay(map, 3, 1)：</p> 
<p><img alt="" height="1195" src="https://images2.imgbox.com/37/7c/0nNHYtdT_o.png" width="1200"></p> 
<p>然后 findWay(map, 3, 1) 执行内部代码块，发现执行到上图中的绿色箭头指向的语句，发现条件不满足，就会跳到淡蓝色箭头指向的else语句，然后return false；</p> 
<p><img alt="" height="1198" src="https://images2.imgbox.com/fa/9f/YgheBJS1_o.png" width="1200"></p> 
<p>这时 findWay(map, 3, 1) 函数就返回了，且返回值为false，</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/af/bf/yFIhMbz9_o.png" width="1200"></p> 
<p>然后 findWay(map, 2, 1) 接着执行，因为 findWay(map, 3, 1) 返回的是false，所以 if 后括号的条件语句为假，所以接着尝试else if 中的语句，所以接着调用 findWay(map, 2, 2)，</p> 
<p><img alt="" height="1197" src="https://images2.imgbox.com/7b/7b/xFz2Xkas_o.png" width="1200"></p> 
<p>然后 findWay(map, 2, 2) 接着执行语句，执行到 map[row][col] = 2 语句时，（2,2）的值会被设为2，执行到下图中的绿色箭头指向的语句时，</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/06/6b/VvZ1r1wz_o.png" width="1200"></p> 
<p>又会调用 findWay(map, 3, 2) ，然后会发现又会执行else 中的语句块，因为（3,2）这个位置是墙，然后这个函数返回，</p> 
<p><img alt="" height="1199" src="https://images2.imgbox.com/41/50/45pF7IhR_o.png" width="1200"></p> 
<p>接着就是 findWay(map, 2, 2) 接着尝试向右走，调用 findWay(map, 2, 3)，</p> 
<p><img alt="" height="1198" src="https://images2.imgbox.com/49/f4/2gel7IhG_o.png" width="1200"></p> 
<p>然后执行的 map[row][col] = 2 语句让（2,3）的值设为2，然后执行到上图的绿色箭头指向的位置时，又会调用 findWay(map, 3, 3)，但是因为（3,3）位置是墙，所以 findWay(map, 3, 3) 又会返回false ：</p> 
<p><img alt="" height="1192" src="https://images2.imgbox.com/46/5d/htlVxndR_o.png" width="1200"></p> 
<p>由于返回的是false，所以 findWay(map, 2, 3) 会接着尝试向右走，则会调用 findWay(map, 2, 4)，然后执行到 map[row][col] = 2 语句让（2,4）的值设为2，</p> 
<p><img alt="" height="1189" src="https://images2.imgbox.com/3b/e7/7WTTBZWT_o.png" width="1200"></p> 
<p>然后 findWay(map, 2, 4) 会执行语句，到上图中绿色箭头指的语句时，又会调用 findWay(map, 3, 4)，由于接下来向下走会连续几次，这里稍微跳跃一下，接下来会依次调用 findWay(map, 4, 4) ，findWay(map, 5, 4) ，findWay(map, 6, 4)，</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0b/e0/cARSQEQX_o.png" width="1200"></p> 
<p>然后直到 findWay(map, 7, 4) 就会再次返回，因为（7,4）这里是墙，这时 findWay(map, 6, 4) ，就会尝试向右走， 就会调用 findWay(map, 6, 5)，然后执行到 map[row][col] = 2 语句让（6,5）的值设为2，</p> 
<p><img alt="" height="1195" src="https://images2.imgbox.com/dc/25/zuEnO8s7_o.png" width="1200"></p> 
<p>然后执行到上图的绿色箭头指向的语句，就会调用 findWay(map, 7, 5)，</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e0/2a/mDDyI1qK_o.png" width="1200"></p> 
<p>可以发现 findWay(map, 7, 5) 在执行第一个语句时，会判断 map[6][5] == 2 这个条件，可以发现这个条件是满足的，所以 findWay(map, 7, 5) 会返回 true ，</p> 
<p><img alt="" height="1195" src="https://images2.imgbox.com/22/22/pu31O0iM_o.png" width="1200"></p> 
<p>由于 findWay(map, 7, 5) 返回的是 true ，所以 if 中的条件表达式为真，所以 findWay(map, 6, 5) 会执行return true，也就是返回 true ，</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0d/8f/B6np5ku8_o.png" width="1200"></p> 
<p>由于 findWay(map, 6, 5) 返回的是 true 所以 findWay(map, 6, 4) 这里的else if 的条件表达式为真，所以 findWay(map, 6, 4) 也会返回 true，后面的函数会依次返回true，然后导致前一个函数也返回true，到最后 findWay(map, 1, 1) 返回true 这个递归就结束了，然后</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/60/c6/p4LJWox6_o.png" width="430"></p> 
<p>res 的值为 true 所以打印具体的路径。</p> 
<p>如果我们将打印语句放到findWay函数的第一个语句处，也就是每次调用findWay函数都会打印依次地图，会依次打印以下地图情况：</p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/9c/16/CYvV3jLk_o.png" width="192"><img alt="" height="218" src="https://images2.imgbox.com/18/01/AXRneDqQ_o.png" width="192"><img alt="" height="220" src="https://images2.imgbox.com/08/9b/42mmtfcM_o.png" width="192"></p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/90/61/arg7ILoK_o.png" width="193"><img alt="" height="219" src="https://images2.imgbox.com/e9/cd/cn8OJhRl_o.png" width="196"><img alt="" height="218" src="https://images2.imgbox.com/b6/00/Jsq1LmYM_o.png" width="192"></p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/4c/d0/CM5JfS73_o.png" width="193"><img alt="" height="216" src="https://images2.imgbox.com/9b/d5/XJbXmQla_o.png" width="193"><img alt="" height="228" src="https://images2.imgbox.com/06/b2/dlHB81lh_o.png" width="191"></p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/dc/9b/8VtXnPKD_o.png" width="193"><img alt="" height="223" src="https://images2.imgbox.com/5e/25/0EIauGev_o.png" width="193"><img alt="" height="220" src="https://images2.imgbox.com/e4/f2/eYnb4lMl_o.png" width="193"></p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/0d/94/bPX0NJQW_o.png" width="196"><img alt="" height="220" src="https://images2.imgbox.com/8f/a6/Vjv2x7iF_o.png" width="194"><img alt="" height="219" src="https://images2.imgbox.com/d2/7b/bRAiTwp9_o.png" width="188"></p> 
<p>可以发现与我们分析的一致。</p> 
<p><strong>下面我们将地图改成以下这样，来测试回溯现象：</strong></p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/cd/b4/ES3R0Lr6_o.png" width="198"></p> 
<pre><code class="language-java">public class Test {

	//假设1是障碍，0可走，2为找到的通路，3为走过不通
	public static boolean findWay(int[][] map, int row, int col) {
		if(map[6][5] == 2) {//终点为2则可达到终点
			return true;
		} else {//终点不是2则接着找路
			if(map[row][col] == 0) {//当前的位置为0才可继续走

				map[row][col] = 2;//当前位置是0，现在假设可以通过当前位置，把当前位置设为2

				if(findWay(map, row + 1, col)) {//尝试向下走，如果向下走可以，则返回真
					return true;
				} else if(findWay(map, row, col + 1)) {//尝试向右走，如果向右走可以，则返回真
					return true;
				} else if(findWay(map, row - 1, col)) {//尝试向上走，如果向上走可以，则返回真
					return true;
				} else if(findWay(map, row, col - 1)) {//尝试向左走，如果向左走可以，则返回真
					return true;
				} else {//上下左右都不可以走，将此处设为3，表示走过但走不通，然后回溯
					map[row][col] = 3;
					return false;
				}

			} else {//当前位置不是0，则回溯
				return false;
			}
		}
	}

	public static void printMap(int[][] map) {
		for(int i = 0; i &lt; map.length; i++) {
			for(int j = 0; j &lt; map[i].length; j++) {
				if(map[i][j] == 1) {
					System.out.printf("\033[48;5;19m  \033[0m");
				} else if(map[i][j] == 2) {
					System.out.printf("\033[48;5;22m  \033[0m");
				} else if(map[i][j] == 3){
					System.out.printf("\033[48;5;160m  \033[0m");
				} else{
					System.out.printf("  ");
				}
			}
			System.out.println();
		}
	}

	public static void main(String[] args) {
		int[][] map = {
			{1,1,1,1,1,1,1},
			{1,0,0,0,0,0,1},
			{1,0,1,0,0,0,1},
			{1,1,1,1,0,0,1},
			{1,0,0,1,0,0,1},
			{1,0,0,1,0,0,1},
			{1,0,0,0,0,0,1},
			{1,1,1,1,1,1,1}
		};

		boolean res = findWay(map, 1, 1);
		if(res) {
			printMap(map);
		} else {
			System.out.println("未找到");
		}
		
	}
}</code></pre> 
<p>再次运行代码的结果为：</p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/d9/c5/kyZc9JOg_o.png" width="211"></p> 
<p>这里的红色方块就是回溯导致的，就是当走到（2,1）的位置时，会依次尝试向下，向右，向上，向左走，</p> 
<p><img alt="" height="1195" src="https://images2.imgbox.com/6e/99/Hp2RNbTY_o.png" width="1200"></p> 
<p>就是图中的四个绿色箭头所指的，但是发现这四个方位都不能走通，然后就会执行else中的语句：</p> 
<p><img alt="" height="1192" src="https://images2.imgbox.com/69/41/bAlPRAKs_o.png" width="1200"></p> 
<p>将（2,1）这个位置的值设为3，然后返回false，这个现象就是回溯。</p> 
<h4 style="background-color:transparent;">2）八皇后问题</h4> 
<blockquote> 
 <p><strong>八皇后问题（Eight Queens Problem）</strong>是一个经典的组合优化问题。该问题的目标是在一个8×8的国际象棋棋盘上放置8个皇后，使得任何两个皇后都不能互相攻击。根据国际象棋的规则，皇后可以在水平、垂直和对角线上移动，因此放置的皇后不能位于同一行、同一列或同一对角线上。</p> 
 <p>八皇后问题总共有92个解。</p> 
</blockquote> 
<p>以下是具体代码：</p> 
<pre><code class="language-java">public class EightQueen {

	private int count;//计数，第几个解法

	//求解方法，会依次找到每一个方法，找到一个方法后，会返回然后接着找其他方法
	public void solve(int[][] arr, int row) {
		if(row == 8) {//行数等于8则代表完成了摆放
			printArr(arr);//打印摆放的解法，这里每次找到解都会打印，总计会打印92个解
			return ;//row为8的这个函数栈帧返回，接下来还会再其它的函数栈帧中接着寻找其他解法
		}
		for(int col = 0; col &lt; arr[row].length; col++) {
			if(isValid(arr, row, col)) {//检查当前位置是否合法
				arr[row][col] = 1;//当前位置合法，将皇后放下
				solve(arr, row + 1);//尝试下一行的放法
			}
			arr[row][col] = 0;//将此位置设为0，重置状态，后面无论上面的尝试下一行能不能找到结果，都会重置，
			//找到结果还会重置，则是实现了可以将92个解依次找出的情形
		}
	}

	//检查是否合法，也就是检查是否与前面的棋子冲突
	public boolean isValid(int[][] arr, int row, int col) {
		//
		//
		//
		//        *
		//      | | |
		//    |   |   |
		//  |     |     |
		//|       |      
		// *为当前位置，*上面的是没有放置的行，不用检查，
		// |为需要检查的位置，检查是否有同列的，检查是否有同一个主对角线的，检查是否有同一个副对角线的
		
		//检查是否有同列的
		for(int i = 0; i &lt; row; i++) {//遍历之前行的当前列，查找是否有同列的皇后
			if(arr[i][col] == 1) {//如果有同列的皇后，则返回false
				return false;
			}
		}

		//检查是否有同一个主对角线的
		for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
			if(arr[i][j] == 1) {
				return false;
			}
		}

		//检查是否有同一个副对角线的
		for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; 8; i--, j++) {
			if(arr[i][j] == 1) {
				return false;
			}
		}

		return true;//上面的都满足，则不与前面的皇后冲突
	}

	//打印解法，即打印这个二维数组
	public void printArr(int[][] arr) {
		count++;
		System.out.println("第" + count +"种解法为：");
		for(int i = 0; i &lt; arr.length; i++) {
			for(int j = 0; j &lt; arr[i].length; j++) {
				if(arr[i][j] == 1) {
					System.out.print("\033[48;5;160m  \033[0m");
				} else {
					System.out.print("\033[48;5;39m  \033[0m");
				}
			}
			System.out.println();
		}
	}

	public static void main(String[] args) {
		int[][] arr = new int[8][8];//创建一个二维数组，默认初始化为0

		EightQueen eightQueen = new EightQueen();

		eightQueen.solve(arr,0);
	}
}</code></pre> 
<p>运行结果（因为会打印整整92个解，这里只截取部分）：</p> 
<p><img alt="" height="762" src="https://images2.imgbox.com/d3/bb/kcFKBUX6_o.png" width="243"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4193381c1c6f7ffe6f36aaf0010459db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">源码解析 若依 ，xxljob视频教程，一行一行代码源码解析课程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04c984efea89fab7a4bfdc8659092ff2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[AI Stability] 开源AI新利器：Stable Diffusion 3 Medium震撼发布！文本到图像再升级！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>