<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>继承详解——C&#43;&#43;深度学习解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c0059054d831dcec72ec5a33fae9627d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="继承详解——C&#43;&#43;深度学习解析">
  <meta property="og:description" content="前言 ： 本节内容是讲解面向对象中三大特性之一的继承。 继承是面向对象程序设计中代码复用的一种重要手段。 通过继承， 我们就可以在原本的代码上进行扩展， 而不是重新写一段代码， 让代码变得冗余。 同时， 继承也体现了面向对象程序设计的层次结构，不同于我们以前经常见到的函数的复用， 继承是层次上的复用， 也可以说是类层次的复用。
注：本节讲述的是c&#43;&#43;里面的继承， 适合正在学习c&#43;&#43;的友友们进行观看。
目录
一.什么是继承
1.1继承体系
1.2定义格式
1.3继承方式
二、继承的作用域问题
三、继承的切片问题
四、派生类的默认成员函数
4.1派生类的构造函数：
4.2派生类的析构函数
4.3派生类的拷贝构造函数
4.4派生类的赋值重载
五、继承与友元
六、继承与静态成员
七、菱形继承和菱形虚拟继承
一.什么是继承 1.1继承体系 在继承体系中， 被继承的那个类叫做基类或者父类， 继承来的那个类叫做派生类或者子类
我们通过一个具体的实例来看一下继承是怎么实现类的复用的：
定义一个继承体系：
#include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #include&lt;string&gt; //基类 class Person { public: //构造函数 Person(const string name, const string sex) :_name(name) ,_sex(sex) {} //打印接口 void Print() { cout &lt;&lt; &#34;姓名&#34; &lt;&lt; _name &lt;&lt; &#34; 性别:&#34; &lt;&lt; _sex &lt;&lt; endl; } private: string _name; //姓名 string _sex; //性别 }; //学生类， 子类 class Student : public Person //继承的写法就是 ：&#43; 继承方式 &#43; 继承的基类 { public: Student(string name, string sex, int num) :Person(name, sex) //初始化列表调用基类的构造函数方式 ,_num(num) {} private: int _num; //学号 }; //教师类， 子类 class Teacher : public Person //继承的写法就是 ：&#43; 继承方式 &#43; 继承的基类 { public: Teacher(string name, string sex, int wages) :Person(name, sex) //初始化列表调用基类的构造函数方式 ,_wages(wages) {} private: int _wages; //工资 }; 在这个继承体系里面， 虽然Student和Teacher表面上只定义了_num 或者_wages。但是，Student和Teacher都继承了Person类。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-18T21:02:58+08:00">
    <meta property="article:modified_time" content="2024-05-18T21:02:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">继承详解——C&#43;&#43;深度学习解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>        <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">前言</span></strong></span> ： 本节内容是讲解面向对象中三大特性之一的<span style="color:#be191c;"><strong>继承</strong></span>。 继承是面向对象程序设计中<strong>代码复用的一种重要手段</strong>。 通过继承， 我们就可以在原本的代码上进行扩展， 而不是重新写一段代码， 让代码变得冗余。 同时，<strong><span style="color:#be191c;"> 继承</span>也体现了面向对象程序设计的层次结构</strong>，不同于我们以前经常见到的函数的复用， <strong>继承是层次上的复用， 也可以说是<span style="color:#be191c;">类层次的复用</span></strong>。</p> 
 <p>       <span style="color:#79c6cd;"> <strong>注：本节讲述的是c++里面的继承， 适合正在学习c++的友友们进行观看。</strong></span></p> 
</blockquote> 
<p><span style="color:#79c6cd;"><strong>        </strong></span></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF" rel="nofollow">一.什么是继承</a></p> 
<p id="1.1%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB-toc" style="margin-left:40px;"><a href="#1.1%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB" rel="nofollow">1.1继承体系</a></p> 
<p id="1.2%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#1.2%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F" rel="nofollow">1.2定义格式</a></p> 
<p id="1.3%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#1.3%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F" rel="nofollow">1.3继承方式</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98" rel="nofollow">二、继承的作用域问题</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%89%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E5%88%87%E7%89%87%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E5%88%87%E7%89%87%E9%97%AE%E9%A2%98" rel="nofollow">三、继承的切片问题</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">四、派生类的默认成员函数</a></p> 
<p id="4.1%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#4.1%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">4.1派生类的构造函数：</a></p> 
<p id="4.2%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.2%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">4.2派生类的析构函数</a></p> 
<p id="4.3%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.3%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">4.3派生类的拷贝构造函数</a></p> 
<p id="%C2%A04.4%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%C2%A04.4%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD" rel="nofollow"> 4.4派生类的赋值重载</a></p> 
<p id="%E4%BA%94%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83" rel="nofollow">五、继承与友元</a></p> 
<p id="%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" rel="nofollow">六、继承与静态成员</a></p> 
<p id="%E4%B8%83%E3%80%81%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%92%8C%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%92%8C%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF" rel="nofollow">七、菱形继承和菱形虚拟继承</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF" style="background-color:transparent;">一.什么是继承</h2> 
<h3 id="1.1%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB">1.1继承体系</h3> 
<p>        在继承体系中， 被继承的那个类叫做<span style="color:#be191c;"><strong>基类</strong></span>或者<span style="color:#be191c;"><strong>父类</strong></span>， 继承来的那个类叫做<strong><span style="color:#b95514;">派生类</span></strong>或者<span style="color:#b95514;"><strong>子类</strong></span></p> 
<p>        我们通过一个具体的实例来看一下继承是怎么实现类的复用的：</p> 
<p>定义一个继承体系：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;string&gt;

//基类
class Person 
{
public:
	//构造函数
	Person(const string name, const string sex) 
		:_name(name)
		,_sex(sex)
	{}

	//打印接口
	void Print()
	{
		cout &lt;&lt; "姓名" &lt;&lt; _name &lt;&lt; "    性别:" &lt;&lt; _sex &lt;&lt; endl;
	}

private:
	string _name;        //姓名
	string _sex;         //性别
};


//学生类， 子类
class Student : public Person //继承的写法就是 ：+ 继承方式 + 继承的基类
{
public:
	Student(string name, string sex, int num) 
		:Person(name, sex) //初始化列表调用基类的构造函数方式
		,_num(num)
	{}

private:
	int _num;             //学号
};

//教师类， 子类
class Teacher : public Person  //继承的写法就是 ：+ 继承方式 + 继承的基类 
{
public:
	Teacher(string name, string sex, int wages) 
		:Person(name, sex) //初始化列表调用基类的构造函数方式
		,_wages(wages)
	{}

private:
	int _wages;           //工资
};
</code></pre> 
<p><img alt="" height="562" src="https://images2.imgbox.com/5b/1a/BuYB7KE0_o.png" width="510"></p> 
<p>        在这个继承体系里面， 虽然Student和Teacher表面上只定义了_num 或者_wages。但是，Student和Teacher都继承了Person类。</p> 
<p>        而Person类里面定义了_name, _sex，以及外部接口Print（），  那么Student和Teacher里面就会<span style="color:#be191c;"><strong>隐式</strong></span>的多出来一份Person类的_name, _sex, 以及它的Print（）。 </p> 
<blockquote> 
 <p>        当我们进行Studen类或者Teacher类的实例化的时候， 实例化对象里面就会有继承来的成员变量或者外部接口。 如图实例化一个Student对象:</p> 
 <p>        <img alt="" height="259" src="https://images2.imgbox.com/55/4d/TBiFAa64_o.png" width="378"></p> 
 <p><img alt="" height="479" src="https://images2.imgbox.com/16/08/VtYKty8z_o.png" width="1200"></p> 
</blockquote> 
<p> 所以， 继承就是： <span style="color:#be191c;"><strong>对于子类或者派生类来说。 父类也就是基类有的， 我也有。</strong></span> </p> 
<p></p> 
<h3 id="1.2%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F">1.2定义格式</h3> 
<p> 定义一个继承的格式：</p> 
<p><img alt="" height="593" src="https://images2.imgbox.com/60/72/XPSnjFbR_o.png" width="1200"></p> 
<h3 id="1.3%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">1.3继承方式</h3> 
<p>        派生类使用不同的继承方式从基类继承来的成员，权限是不同的。下面是根据不同方式派生类继承来的成员的权限图：</p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/7d/b0/lAnHJ0pK_o.png" width="1200"></p> 
<p>        上面的图其实总结下来就是可以分为两类：一类是基类里面的private成员、一类是基类里面的public, protected成员。 </p> 
<blockquote> 
 <ul><li>    <span style="color:#be191c;"><strong>    对于基类里面的private成员。 不管派生类使用什么方式继承， 继承后这些成员都在派生类中不可见。</strong></span></li><li><span style="color:#be191c;"><strong>        对于基类里面的非private成员， 看继承方式和这个成员在基类之中的权限哪个小。 这个权限就是派生类中的权限。 比如 student私有继承基类的公有成员。 那么继承后的这个成员就是私有类型。 </strong></span></li></ul> 
</blockquote> 
<p>        <span style="color:#98c091;"><strong>实际上， 我们在实际运用中一般只会用到public继承， 因为private和protected继承来的成员只能在类域中使用， 实际的可维护性不强</strong></span>。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98">二、继承的作用域问题</h2> 
<p>        在继承体系中。 虽然派生类继承了基类。 但是对于派生类的成员变量和基类的成员变量来说， 都有它们自己的作用域。 而且， 假如一个派生类继承了多个基类， 那么每个基类都有一个属于自己的区域。 这就叫类域。</p> 
<blockquote> 
 <p><span style="color:#1c7892;"><strong>        类域可以帮助我们解决继承体系中的重名问题。并且如果基类的私有成员虽然是不可见的， 但它在自己的类域中同样可以被访问。  </strong></span>    </p> 
</blockquote> 
<blockquote> 
 <p>        如果子类和父类中有同名的成员， 那么父类的成员将在自己的类域中隐藏起来。我们直接访问是访问不到的：</p> 
 <pre><code class="language-cpp">class Person 
{
public:
	//打印接口
	void Print()
	{
		cout &lt;&lt; "姓名" &lt;&lt; _name &lt;&lt; "    性别:" &lt;&lt; _sex &lt;&lt; endl;
	}

private:
	string _name = "张三";        //姓名
	string _sex = "男";         //性别
};


class Student : public Person 
{
public:
	void Print() 
	{
		cout &lt;&lt; "学号: " &lt;&lt; _num &lt;&lt; endl;
	}

private:
	int _num = 111;             //学号
};

int main() 
{
	Student stu;
	stu.Print();

}</code></pre> 
 <p><img alt="" height="327" src="https://images2.imgbox.com/9f/53/rPoOrtCr_o.png" width="738"></p> 
 <p></p> 
 <p>        <span style="color:#fe2c24;"><strong>这里要注意的是：</strong></span><span style="color:#1c7892;"><strong>成员函数只要函数名相同， 就会构成隐藏</strong></span></p> 
</blockquote> 
<blockquote> 
 <p>想要访问基类中隐藏在类域中的成员， 那么就要利用域操作符显示的调用：</p> 
 <p><img alt="" height="265" src="https://images2.imgbox.com/16/d7/WrYfJzmt_o.png" width="533"></p> 
</blockquote> 
<blockquote> 
 <p>成员变量的隐藏：</p> 
 <p><img alt="" height="474" src="https://images2.imgbox.com/6e/82/JvKkyb0L_o.png" width="466"></p> 
</blockquote> 
<blockquote> 
 <p>        如果是继承多个父类， 并且父类之间有函数名或者成员变量重名， 那么编译器就会显示目标不明确， 无法编译：</p> 
 <pre><code class="language-cpp">//基类1
class Person1
{
public:
	//打印接口
	void Print()
	{
		cout &lt;&lt; "1:" &lt;&lt; "姓名" &lt;&lt; _name &lt;&lt; "    性别:" &lt;&lt; _sex &lt;&lt; endl;
	}

	string _name = "张三";        //姓名
	string _sex = "男";         //性别
	int _num = 11;
};
//基类2
class Person2
{
public:
	//打印接口
	void Print()
	{
		cout &lt;&lt; "2:" &lt;&lt; "姓名" &lt;&lt; _name &lt;&lt; "    性别:" &lt;&lt; _sex &lt;&lt; endl;
	}

	string _name = "李四";        //姓名
	string _sex = "男";         //性别
	int _num = 22;
};
//基类3
class Person3
{
public:
	//打印接口
	void Print()
	{
		cout &lt;&lt; "3:" &lt;&lt; "姓名" &lt;&lt; _name &lt;&lt; "    性别:" &lt;&lt; _sex &lt;&lt; endl;
	}

	string _name = "王五";        //姓名
	string _sex = "男";         //性别
	int _num = 33;
};

class Student : public Person1, public Person2, public Person3
{
public:

};

int main() 
{
	Student stu;
	stu.Print();

}</code></pre> 
 <p><img alt="" height="292" src="https://images2.imgbox.com/0a/2a/arnOxfCB_o.png" width="708"></p> 
 <p>        想要成功编译就要指定是调用哪个父类接口：</p> 
 <p><img alt="" height="299" src="https://images2.imgbox.com/b6/7e/hWv8cmSs_o.png" width="631"></p> 
</blockquote> 
<h2></h2> 
<h2 id="%E4%B8%89%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E5%88%87%E7%89%87%E9%97%AE%E9%A2%98">三、继承的切片问题</h2> 
<p>        派生类和父类的关系就是：<span style="color:#be191c;"><strong>父类有的， 派生类也有</strong></span>。 </p> 
<p>        并且， <span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">派生类可以给父类进行赋值</span></strong></span>。 这个赋值操作，有一个形象的叫法叫做 <span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">切片</span></strong></span>。</p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/22/02/7QX1YDCf_o.png" width="1061"></p> 
<p>        </p> 
<p>        使用派生类给父类赋值、 父类的指针指向派生类， 父类的引用引用派生类。 这些都是切片操作。 （<span style="color:#be191c;"><strong>注意， 不能派生类的指针或者引用指向父类， 否则不安全， 容易发生野指针。</strong></span>）</p> 
<p>        <img alt="" height="440" src="https://images2.imgbox.com/d1/00/3aHjFuvt_o.png" width="548"></p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">四、派生类的默认成员函数</h2> 
<blockquote> 
 <p>对于一个类来说， 有六个默认成员函数：</p> 
 <ul><li><span style="color:#be191c;"><strong>默认构造函数</strong></span> ： 对于内置类型不做处理， 对自定义类型去调用它的默认构造</li><li><span style="color:#be191c;"><strong>析构函数</strong></span> ： 对于内置类型不做处理， 对于自定义类型去调用它的析构函数</li><li><span style="color:#be191c;"><strong>默认拷贝构造 </strong></span>： 对于内置类型进行浅拷贝， 对于自定义类型去调用它的拷贝构造</li><li><span style="color:#be191c;"><strong>默认赋值重载</strong></span> ： 对于内置类型进行浅拷贝， 对于自定义类型去调用它的赋值重载</li><li><span style="color:#be191c;"><strong>移动构造函数</strong></span> ：移动构造是c++11新增， 涉及右值引用知识点。本篇不会讲到</li><li><span style="color:#be191c;"><strong>移动赋值重载</strong></span> ：移动赋值重载是c++11新增， 涉及右值引用知识点， 本篇不会讲到</li></ul> 
</blockquote> 
<h3 id="4.1%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A">4.1派生类的构造函数：</h3> 
<blockquote> 
 <ul><li><span style="color:#1c7892;"><strong>        对于一个普通的类， 我们只有内置类型和自定义类型。</strong></span><span style="color:#1c7892;"><strong>如果有自定义类型，</strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">这个自定义类型是在初始化列表进行初始化</span></strong></span><span style="color:#1c7892;"><strong>，并且我们可以显示的调用该自定义类型的构造函数， 也可以隐式的调用该自定义类型的构造函数（</strong></span><span style="color:#be191c;"><strong>当隐式调用时， 自定义类型必须有默认构造</strong></span><span style="color:#1c7892;"><strong>）</strong></span>。</li><li>        <span style="color:#1c7892;"><strong>如果是在继承体系中的话， </strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">基类部分的初始化同样是在初始化列表部分</span></strong></span><span style="color:#1c7892;"><strong>。 并且我们同样可以选择显示的调用该自定义类型的构造函数， 或者隐式的调用该自定义类型的构造函数（</strong></span><span style="color:#be191c;"><strong>当隐式调用时， 基类中必须有默认构造</strong></span><span style="color:#1c7892;"><strong>）。</strong></span></li></ul> 
</blockquote> 
<pre><code class="language-cpp">class Person 
{
public:
	//构造函数
	Person(string name, string sex) 
		:_name(name)
		,_sex(sex)
	{
		cout &lt;&lt; "Person()" &lt;&lt; endl;
	}
	string _name = "张三";        //姓名
	string _sex = "男";         //性别
	int _num = 11;
};


class Student : public Person 
{
public:
	Student(string name, string sex, int num) 
		:_num(num)
		,Person(name, sex)
	{
		cout &lt;&lt; "Student()" &lt;&lt; endl;
	}
	int _num = 111;             //学号
};

int main() 
{
	Student stu("李四", "男", 111);

}</code></pre> 
<p><img alt="" height="522" src="https://images2.imgbox.com/2c/30/VHMSB0zK_o.png" width="533"> </p> 
<p>这里需要注意的是 ：<span style="color:#be191c;"><strong>初始化列表的初始化顺序是：先初始化基类， 再初始化自定义类型， 最后初始化内置类型。 而对于基类、 自定义类型、 内置类型， 会按照他们的声明顺序进行初始化。</strong></span></p> 
<h3 id="4.2%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">4.2派生类的析构函数</h3> 
<p>        派生类的析构函数是先析构派生类对象， 再析构基类的对象：</p> 
<p><img alt="" height="1077" src="https://images2.imgbox.com/f5/8e/FkMKgKBn_o.png" width="957"></p> 
<h3 id="4.3%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3派生类的拷贝构造函数</h3> 
<pre><code class="language-cpp">class Person 
{
public:
	//构造函数
	Person(string name, string sex) 
		:_name(name)
		,_sex(sex)
	{
		cout &lt;&lt; "Person()" &lt;&lt; endl;
	}
    
    //拷贝构造
	Person(const Person&amp; per) 
	{
		cout &lt;&lt; "const Person&amp;()" &lt;&lt; endl;
	}

	string _name = "张三";        //姓名
	string _sex = "男";         //性别
	int _num = 11;
};


class Student : public Person 
{
public:
    //构造函数
	Student(string name, string sex, int num) 
		:_num(num)
		,Person(name, sex)
	{
		cout &lt;&lt; "Student()" &lt;&lt; endl;
	}
    
    //拷贝构造
	Student(const Student&amp; stu) 
		:Person(stu)
		,_num(stu._num)
	{
		cout &lt;&lt; "const Student&amp;()" &lt;&lt; endl;
	}

	int _num = 111;             //学号
};

int main() 
{
	Student stu("李四", "男", 111);
	Student st(stu);
}</code></pre> 
<p><img alt="" height="432" src="https://images2.imgbox.com/96/35/pBfmRSiV_o.png" width="536"> </p> 
<h3 id="%C2%A04.4%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD" style="background-color:transparent;"> 4.4派生类的赋值重载</h3> 
<p>        <span style="color:#be191c;"><strong>派生类的赋值重载， 必须调用基类的赋值重载完成复制。</strong></span></p> 
<pre><code class="language-cpp">
class Person 
{
public:
	//构造函数
	Person(string name, string sex) 
		:_name(name)
		,_sex(sex)
	{
		cout &lt;&lt; "Person()" &lt;&lt; endl;
	}
    
    //赋值重载
	void operator=(const Person&amp; per) 
	{
		cout &lt;&lt; "operator=()-Person" &lt;&lt; endl;
	}

	string _name = "张三";        //姓名
	string _sex = "男";         //性别
	int _num = 11;
};


class Student : public Person 
{
public:
    //构造函数
	Student(string name = "张三", string sex = "男", int num = 111)
		:_num(num)
		,Person(name, sex)
	{
		cout &lt;&lt; "Student()" &lt;&lt; endl;
	}

    //赋值重载
	void operator=(const Student&amp; stu) 
	{
		Person::operator=(stu);//调用stu的
		cout &lt;&lt; "operator=()-Student" &lt;&lt; endl;
	}

	int _num = 111;             //学号
};

int main() 
{
	Student stu("张三", "男", 44);
	Student st;
	st = stu;

}</code></pre> 
<p><img alt="" height="744" src="https://images2.imgbox.com/fc/45/2lphE3zy_o.png" width="948"></p> 
<h2 id="%E4%BA%94%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83">五、继承与友元</h2> 
<p>        友元的关系不能继承。基类的友元不能访问子类私有和保护成员。</p> 
<p>        如下为示例:</p> 
<pre><code class="language-cpp">class Person 
{
public:
	friend void Display(const Person&amp; per);
	//构造函数
	Person(string name, string sex) 
		:_name(name)
		,_sex(sex)
	{
		cout &lt;&lt; "Person()" &lt;&lt; endl;
	}

private:
	string _name = "张三";        //姓名
	string _sex = "男";         //性别
	int _num = 11;
};


class Student : public Person 
{
public:
    //构造函数
	Student(string name = "张三", string sex = "男", int num = 111)
		:_num(num)
		,Person(name, sex)
	{
		cout &lt;&lt; "Student()" &lt;&lt; endl;
	}

private:
	int _num = 111;             //学号
};

void Display(const Student&amp; stu)
{
	cout &lt;&lt; "姓名: " &lt;&lt; stu._name &lt;&lt; "  " &lt;&lt; "性别: " &lt;&lt; stu._sex &lt;&lt; "学号: " &lt;&lt; endl;
}


int main() 
{
	Student stu("张三", "男", 44);
	Person st = stu;
}
</code></pre> 
<p><img alt="" height="458" src="https://images2.imgbox.com/bf/51/aKxhQ3W2_o.png" width="423"></p> 
<p>如图， 虽然我们已经在基类中设置了友元。但友元不能继承， 我们在DIsplay函数并不能访问Student中的成员变量。 </p> 
<h2 id="%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">六、继承与静态成员</h2> 
<p><span style="color:#be191c;"><strong>基类如果定义了static静态成员， 则整个继承体系里面只有一个这样的成员。</strong></span></p> 
<pre><code class="language-cpp">
class Person 
{
public:
	//构造函数
	Person(string name, string sex) 
		:_name(name)
		,_sex(sex)
	{
		cout &lt;&lt; "Person()" &lt;&lt; endl;
	}

	string _name = "张三";        //姓名
	string _sex = "男";         //性别
	static int sum;             //定义的静态变量
};
int Person::sum = 100;      //静态变量初始化

class Student : public Person 
{
public:
    //构造函数
	Student(string name = "张三", string sex = "男", int num = 111)
		:_num(num)
		,Person(name, sex)
	{
		cout &lt;&lt; "Student()" &lt;&lt; endl;
	}

	int _num = 111;             //学号
};


int main() 
{
	Student stu("张三", "男", 44);
	Person st = stu;
	cout &lt;&lt; Person::sum &lt;&lt; endl;
}
</code></pre> 
<p><img alt="" height="615" src="https://images2.imgbox.com/0e/fe/8GCxGfLR_o.png" width="1013"></p> 
<h2 id="%E4%B8%83%E3%80%81%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%92%8C%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF">七、菱形继承和菱形虚拟继承</h2> 
<p>        我们先了解一下两个概念之后再了解菱形继承的概念， 这两个概念一个叫单继承， 另一个叫多继承。</p> 
<p>       <span style="color:#be191c;"><strong> 一个派生类只继承了一个基类， 那么这就是一个单继承：</strong></span></p> 
<pre><code class="language-cpp">class A 
{
public:
	A() 
	{
		cout &lt;&lt; "A()" &lt;&lt; endl;
	}
};

//B类继承A
class B : public A
{
public:
	B() 
	{
		cout &lt;&lt; "B()" &lt;&lt; endl;
	}
};

//C类继承B
class C : public B 
{
public:
	C() 
	{
		cout &lt;&lt; "C()" &lt;&lt; endl;
	}
};
</code></pre> 
<p> </p> 
<p><img alt="" height="459" src="https://images2.imgbox.com/dd/93/Jl6GP9Wc_o.png" width="536"></p> 
<p><span style="color:#be191c;"><strong>如果一个派生类继承了多个基类， 那么这就是一个多继承: </strong></span></p> 
<pre><code class="language-cpp">class A 
{
public:
	A() 
	{
		cout &lt;&lt; "A()" &lt;&lt; endl;
	}
};

//B类继承A
class B
{
public:
	B() 
	{
		cout &lt;&lt; "B()" &lt;&lt; endl;
	}
};

//C类继承B
class C
{
public:
	C() 
	{
		cout &lt;&lt; "C()" &lt;&lt; endl;
	}
};

class D : public A, public B, public C
{
public:
	D() 
	{
		cout &lt;&lt; "D()" &lt;&lt; endl;
	}
};
</code></pre> 
<p><img alt="" height="706" src="https://images2.imgbox.com/26/7f/k8hJWyG9_o.png" width="968"></p> 
<p>菱形继承时上面多继承的一种情况, 下面为一个菱形继承的代码：</p> 
<pre><code class="language-cpp">//基类A
class A 
{
public:
	A() 
	{
		cout &lt;&lt; "A()" &lt;&lt; endl;
	}
};

//B类继承A
class B : public A
{
public:
	B() 
	{
		cout &lt;&lt; "B()" &lt;&lt; endl;
	}
};

//C类继承B
class C : public A
{
public:
	C() 
	{
		cout &lt;&lt; "C()" &lt;&lt; endl;
	}
};

class D : public B, public C
{
public:
	D() 
	{
		cout &lt;&lt; "D()" &lt;&lt; endl;
	}
};</code></pre> 
<p> <img alt="" height="490" src="https://images2.imgbox.com/4c/3c/2XnwZ1BF_o.png" width="646"></p> 
<p>如果我们给A类一个成员变量_a：</p> 
<p>那么D类就继承来了两份_a, 如图:</p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/ad/c2/BoAGQS4j_o.png" width="519"></p> 
<p></p> 
<p>在这里利用代码演示一下：</p> 
<pre><code class="language-cpp">class A 
{
public:
	A() 
	{
		cout &lt;&lt; "A()" &lt;&lt; endl;
	}

	int _a;   //定义一个变量_a
};

//B类继承A
class B : public A   //B继承A后， 有一份_a
{
public:
	B() 
	{
		cout &lt;&lt; "B()" &lt;&lt; endl;
	}
};

//C类继承B
class C : public A   //C继承A后， 有一份_a
{
public:
	C() 
	{
		cout &lt;&lt; "C()" &lt;&lt; endl;
	}
};

class D : public B, public C      //D继承B， C类， 这样D中就有了两份_a。
{
public:
	D() 
	{
		cout &lt;&lt; "D()" &lt;&lt; endl;
	}
};
</code></pre> 
<blockquote> 
 <p>vs中变量d的监视窗口：</p> 
 <p><img alt="" height="231" src="https://images2.imgbox.com/08/9c/CsJDm9y1_o.png" width="731"></p> 
</blockquote> 
<p></p> 
<p>        由上面可以看出<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">菱形继承具有数据冗余和二义性的问题</span></strong></span>。 </p> 
<p>        为了解决这个问题， 祖师爷发明了虚拟继承。虚拟继承可以解决二义性和数据冗余的问题。但是使用虚拟继承的地方必须用对， 虚拟继承一般用在<span style="color:#be191c;"><strong>”腰间“</strong></span><strong>，</strong>比如将B类和C类继承A类的方式改成虚拟继承， 那么就可以解决问题。</p> 
<p>---------------------------</p> 
<p><span style="color:#fe2c24;"><strong>接下来就是比较偏向底层的知识。很重要！很重要！很重要！</strong></span></p> 
<p>---------------------------</p> 
<p>下面是我定义的一个菱形继承体系:</p> 
<pre><code class="language-cpp">
class A 
{
public:
	A() 
	{
		cout &lt;&lt; "A()" &lt;&lt; endl;
	}

	int _a;   //定义一个变量_a
};

//B类继承A
class B : public A   //B继承A后， 有一份_a
{
public:
	B() 
	{
		cout &lt;&lt; "B()" &lt;&lt; endl;
	}
	int _b;
};

//C类继承B
class C : public A   //C继承A后， 有一份_a
{
public:
	C() 
	{
		cout &lt;&lt; "C()" &lt;&lt; endl;
	}
	int _c;
};

class D : public B, public C      //D继承B， C类， 这样D中就有了两份_a。
{
public:
	D() 
	{
		cout &lt;&lt; "D()" &lt;&lt; endl;
	}
	int _d;
};

</code></pre> 
<blockquote> 
 <p> 我现在定义一个D类型的实例化对象：</p> 
 <p><img alt="" height="229" src="https://images2.imgbox.com/3e/3f/nDyFiTTR_o.png" width="674"></p> 
 <p><span style="color:#be191c;"><strong>从上面的内存图我们就能比较真实的看到d1的底层存储情况。并且能够看到_a的重复存储。(0x11就是_a)</strong></span></p> 
</blockquote> 
<p></p> 
<p>那么看一下菱形虚拟继承在底层是如何解决这个问题的:</p> 
<pre><code class="language-cpp">
class A 
{
public:
	A() 
	{
		cout &lt;&lt; "A()" &lt;&lt; endl;
	}

	int _a = 0x11;   //定义一个变量_a
};

//B类继承A
class B : virtual public A   //B继承A后， 有一份_a
{
public:
	B() 
	{
		cout &lt;&lt; "B()" &lt;&lt; endl;
	}
	int _b = 0x22;
};

//C类继承B
class C : virtual public A   //C继承A后， 有一份_a
{
public:
	C() 
	{
		cout &lt;&lt; "C()" &lt;&lt; endl;
	}
	int _c = 0x33;
};

//菱形虚拟继承
class D : public B, public C      //D继承B， C类， 这样D中就有了两份_a。
{
public:
	D() 
	{
		cout &lt;&lt; "D()" &lt;&lt; endl;
	}
	int _d = 0x44;
};
</code></pre> 
<p>现在我定义d2， 并观察内存图：</p> 
<p><img alt="" height="733" src="https://images2.imgbox.com/c5/39/2EgvIR6e_o.png" width="1200"></p> 
<p>         图中我们可以观察到虽然菱形继承的问题被解决了， 但是在B类和C类中出现了一些 ”多余“</p> 
<p>的东西。 </p> 
<p>        但是， 这些”多余的东西“其实并不多余， 它们<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">是一个叫做虚基表的指针。 通过这两个框框中存的地址， 就可以找到B类或者C类的虚基表</span></strong></span>。</p> 
<blockquote> 
 <p>        那么什么是虚基表？ <span style="color:#be191c;"><strong>虚基表就是用来寻找虚继承来的数据域的</strong></span>。 对于B类和C类来说， 就是来寻找A类的。 <span style="color:#be191c;"><strong>虚基表里面存放的是一个偏移量， 通过这个偏移量， 我们就可以找到A的数据域</strong></span>。 如下图：</p> 
 <p><img alt="" height="724" src="https://images2.imgbox.com/46/3f/hPKlL959_o.png" width="1200"></p> 
 <p>        我们先看B类的虚基表， 也就是绿框框的虚基表。 这个虚基表中存的是0x14， 那么转化为10进制就是20。我们可以看到， 从图中画黄色四角星的位置到A的数据域正好是20个字节偏移量。 </p> 
 <p>        接下来我们再看C类的虚基表， 也就是蓝框框的虚基表， 这个虚基表中村的是0x0c， 也就是12， 我们可以看到， 从图中画绿色四角形的位置到A的类域正好是12个字节的偏移量。 </p> 
</blockquote> 
<blockquote> 
 <p>        通过以上分析我们知道了菱形虚拟继承如何解决的数据冗余和二义性问题。 但是， 为什么要引入虚基表呢？ D类中的B, C类数据域为什么要找到A类数据域呢？<br>         <span style="color:#be191c;"><strong>当我们使用切片的时候，B， C类就要去寻找A类的数据域。</strong></span></p> 
 <pre><code class="language-cpp">
int main() 
{
	D d2;

	//切片，b中有_b, _a。 所以要找到d2中的B类数据域和A类数据域。 
	B b = d2;
	//同上。
	C c = d2;

}</code></pre> 
 <p> <img alt="" height="343" src="https://images2.imgbox.com/18/3d/XUrBih7C_o.png" width="479"></p> 
</blockquote> 
<p>----------------------</p> 
<p>以上， 就是本节的全部内容。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba2cb0678b4479baa72369ce93c62e8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何使用 GPT 4o API 实现视觉、文本、图像等功能？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e899c6506d75c7ecd2d325066546bbf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ollama &#43; fastgpt搭建本地私有AI大模型智能体工作流（AI Agent Flow）-- windows环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>