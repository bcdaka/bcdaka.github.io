<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】堆的实现（附源码） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0eea0f17a929ba02a63c8fe892190559/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构与算法】堆的实现（附源码）">
  <meta property="og:description" content="目录
一.堆的概念及结构
二.接口实现
A.初始化 Heapinit 销毁 Heapdestroy
B.插入 Heappush 向上调整 AdjustUp
1.Heappush
2.AdjustUp
C.删除 Heappop 向下调整 AdjustDown
D.堆的判空 Heapempty 堆顶数据 Heaptop 堆的大小 Heapsize
三.源码
Heap.h
Heap.c
test.c
一.堆的概念及结构 1.概念
如果有一个关键码的集合K = { ， ， ，…， }，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足： &lt;= 且 &lt;= ( &gt;= 且 &gt;= ) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
2.堆的性质：
A.堆中某个节点的值总是不大于或不小于其父节点的值；
B.堆总是一棵完全二叉树。
其实堆是一种二叉树，通常我们都是用数据表实现，也就是说堆的底层是数组，数组中的小标表示二叉树的节点，所以在实现堆之前，我们有必要了解完全二叉树中节点之间的关系。
1.理解父节点 parent 和子节点 child；
2.了解父节点与子节点之间的关系：
A.parent=（child-1）/2；
B.左孩子child=2*parent&#43;1；
C.右孩子child=2*parent&#43;2。
二.接口实现 A.初始化 Heapinit 销毁 Heapdestroy 这里的初始化和销毁都很简单，相信这对学到堆的人并不是什么难事，和顺序表的操作是一样的，如果实在不理解的话，请看 -&gt; 顺序表
B.插入 Heappush 向上调整 AdjustUp 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-26T22:19:20+08:00">
    <meta property="article:modified_time" content="2023-03-26T22:19:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】堆的实现（附源码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/5b/a1/yY0cxmGt_o.gif" width="240"> </p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">一.堆的概念及结构</a></p> 
<p id="%E4%BA%8C.%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0" rel="nofollow">二.接口实现</a></p> 
<p id="A.%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0%20Heapinit%C2%A0%20%C2%A0%E9%94%80%E6%AF%81%20Heapdestroy-toc" style="margin-left:40px;"><a href="#A.%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0%20Heapinit%C2%A0%20%C2%A0%E9%94%80%E6%AF%81%20Heapdestroy" rel="nofollow">A.初始化  Heapinit   销毁 Heapdestroy</a></p> 
<p id="B.%E6%8F%92%E5%85%A5%20Heappush%20%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%C2%A0%20AdjustUp-toc" style="margin-left:40px;"><a href="#B.%E6%8F%92%E5%85%A5%20Heappush%20%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%C2%A0%20AdjustUp" rel="nofollow">B.插入 Heappush 向上调整  AdjustUp</a></p> 
<p id="1.Heappush-toc" style="margin-left:80px;"><a href="#1.Heappush" rel="nofollow">1.Heappush</a></p> 
<p id="2.AdjustUp-toc" style="margin-left:80px;"><a href="#2.AdjustUp" rel="nofollow">2.AdjustUp</a></p> 
<p id="C.%E5%88%A0%E9%99%A4%20Heappop%C2%A0%20%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%C2%A0%20AdjustDown-toc" style="margin-left:40px;"><a href="#C.%E5%88%A0%E9%99%A4%20Heappop%C2%A0%20%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%C2%A0%20AdjustDown" rel="nofollow">C.删除 Heappop  向下调整  AdjustDown</a></p> 
<p id="D.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA%C2%A0%20Heapempty%C2%A0%20%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%C2%A0%20Heaptop%C2%A0%20%E5%A0%86%E7%9A%84%E5%A4%A7%E5%B0%8F%C2%A0%20Heapsize-toc" style="margin-left:40px;"><a href="#D.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA%C2%A0%20Heapempty%C2%A0%20%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%C2%A0%20Heaptop%C2%A0%20%E5%A0%86%E7%9A%84%E5%A4%A7%E5%B0%8F%C2%A0%20Heapsize" rel="nofollow">D.堆的判空  Heapempty  堆顶数据  Heaptop  堆的大小  Heapsize</a></p> 
<p id="%E4%B8%89.%E6%BA%90%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E6%BA%90%E7%A0%81" rel="nofollow">三.源码</a></p> 
<p id="Heap.h-toc" style="margin-left:80px;"><a href="#Heap.h" rel="nofollow">Heap.h</a></p> 
<p id="Heap.c-toc" style="margin-left:80px;"><a href="#Heap.c" rel="nofollow">Heap.c</a></p> 
<p id="test.c-toc" style="margin-left:0px;"><a href="#test.c" rel="nofollow">test.c</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">一.堆的概念及结构</h2> 
<blockquote> 
 <p>1.概念</p> 
 <p>     如果有一个关键码的集合K = { ， ， ，…， }，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足： &lt;= 且 &lt;= ( &gt;= 且 &gt;= ) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。<br> 2.堆的性质：<br>     A.<span style="background-color:#ffd900;">堆中某个节点的值总是不大于或不小于其父节点的值</span>；<br>     B.<span style="background-color:#ffd900;">堆总是一棵完全二叉树</span>。</p> 
</blockquote> 
<blockquote> 
 <p>其实堆是一种二叉树，通常我们都是用数据表实现，也就是说堆的底层是数组，数组中的小标表示二叉树的节点，所以在实现堆之前，我们<span style="background-color:#ffd900;">有必要了解完全二叉树中节点之间的关系</span>。</p> 
</blockquote> 
<blockquote> 
 <p>1.理解父节点 parent 和子节点 child；</p> 
 <p>2.了解父节点与子节点之间的关系：</p> 
 <p> <span style="background-color:#ffd900;">  A.parent=（child-1）/2；</span></p> 
 <p><span style="background-color:#ffd900;">   B.左孩子child=2*parent+1；</span></p> 
 <p><span style="background-color:#ffd900;">   C.右孩子child=2*parent+2。</span></p> 
 <p><img alt="" height="882" src="https://images2.imgbox.com/02/df/LvIjWQlw_o.png" width="1200"></p> 
</blockquote> 
<h2 id="%E4%BA%8C.%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">二.接口实现</h2> 
<h3 id="A.%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0%20Heapinit%C2%A0%20%C2%A0%E9%94%80%E6%AF%81%20Heapdestroy">A.初始化  Heapinit   销毁 Heapdestroy</h3> 
<blockquote> 
 <p>这里的初始化和销毁都很简单，相信这对学到堆的人并不是什么难事，<span style="background-color:#ffd900;">和顺序表的操作是一样的</span>，如果实在不理解的话，请看 -&gt;  <a class="link-info" href="http://t.csdn.cn/0qWHh" rel="nofollow" title="顺序表">顺序表</a></p> 
</blockquote> 
<h3 id="B.%E6%8F%92%E5%85%A5%20Heappush%20%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%C2%A0%20AdjustUp">B.插入 Heappush 向上调整  AdjustUp</h3> 
<h4 id="1.Heappush">1.Heappush</h4> 
<blockquote> 
 <p>插入数据很简单，直接对数组赋值，然后 size 再加加就行了，但是<span style="background-color:#ffd900;">在插入完数据后，我们得保证它是堆，所以这就需要用到向上调整这个函数。</span></p> 
</blockquote> 
<h4 id="2.AdjustUp">2.AdjustUp</h4> 
<blockquote> 
 <p>假设我们建的是大堆，我们将新插入的节点与它的父节点比较：</p> 
 <p>1.<span style="background-color:#ffd900;">如果比它的父节点大，则与其交换</span>，所以交换后的父节点就成为了子节点，再与其父节点比较，<span style="background-color:#ffd900;">以此类推</span>；</p> 
 <p>2.<span style="background-color:#ffd900;">如果child&lt;=0 则结束循环</span>。</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/88/5c/A2lfr0tO_o.png" width="1200"></p> 
 <p></p> 
</blockquote> 
<pre><code class="language-cpp">void Swap(HPdatatype* p1, HPdatatype* p2)  //交换函数
{
	HPdatatype tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}

void AdjustUp(HPdatatype* arr, int child)   //向上调整
{
	assert(arr);

	int parent = (child - 1) / 2;

	while (child &gt; 0)
	{
		if (arr[child] &gt; arr[parent])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
			break;
	}
}

void Heappush(Heap* php, HPdatatype x)
{
	assert(php);

	if (php-&gt;size == php-&gt;capacity)
	{
		HPdatatype* tmp = (HPdatatype*)realloc(php-&gt;arr, 2 * sizeof(HPdatatype) * php-&gt;capacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(-1);
		}

		php-&gt;arr = tmp;
		php-&gt;capacity *= 2;
	}

	php-&gt;arr[php-&gt;size] = x;
	php-&gt;size++;

	AdjustUp(php-&gt;arr, php-&gt;size - 1);  //注意这里要传size-1，因为size表示的是下一个位置
}</code></pre> 
<h3 id="C.%E5%88%A0%E9%99%A4%20Heappop%C2%A0%20%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%C2%A0%20AdjustDown">C.删除 Heappop  向下调整  AdjustDown</h3> 
<blockquote> 
 <p>1.删除的话，我们是要<span style="background-color:#ffd900;">删除堆顶的数据</span>，因为删除堆尾的数据并没有什么实际意义，<span style="background-color:#ffd900;">删除就是让size--</span>，但是堆顶数据的下标是0，所以在删除前应<span style="background-color:#ffd900;">先交换堆顶和堆尾的数据</span>；</p> 
 <p>2.删除完后，<span style="background-color:#ffd900;">还要保持它还是个堆</span>，不能把后面的顺序搞乱了，要想达到这个目的，就需要使用到<span style="background-color:#ffd900;">向下调整</span>这个函数；</p> 
 <p>3.假设是大堆，<span style="background-color:#ffd900;">向下调整是父节点与其较大的子节点比较，如果较大的那个子节点大于父节点，则二者交换</span>，然后较大的子节点成为了新的父节点，<span style="background-color:#ffd900;">当子节点的下标大于或是等于节点总数，也就是size时，就结束循环。</span></p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/a0/35/F11c24j3_o.png" width="1200"></p> 
 <p> </p> 
</blockquote> 
<h3 id="D.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA%C2%A0%20Heapempty%C2%A0%20%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%C2%A0%20Heaptop%C2%A0%20%E5%A0%86%E7%9A%84%E5%A4%A7%E5%B0%8F%C2%A0%20Heapsize">D.堆的判空  Heapempty  堆顶数据  Heaptop  堆的大小  Heapsize</h3> 
<blockquote> 
 <p>这些接口的实现都非常简单，博主就不在这里讲述了，可以参考后面的源码。</p> 
</blockquote> 
<hr> 
<h2 id="%E4%B8%89.%E6%BA%90%E7%A0%81">三.源码</h2> 
<h4 id="Heap.h">Heap.h</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;time.h&gt;

#define MAX_MIN &lt;   //通过改变这里的符号，可以决定是建大堆还是小堆

typedef int HPdatatype;

typedef struct Heap
{
	HPdatatype* arr;
	int size;
	int capacity;
}Heap;

void Heapinit(Heap* php);

void Swap(HPdatatype* p1, HPdatatype* p2);

void AdjustUp(HPdatatype* arr, int child);  //向上调整

void Heappush(Heap* php, HPdatatype x);

void AdjustDown(HPdatatype* arr, int parent, int n);  //向下调整

void Heappop(Heap* php);

HPdatatype Heaptop(Heap* php);

int Heapsize(Heap* php);

bool Heapempty(Heap* php);

void Heapdestroy(Heap* php);
</code></pre> 
<h4 id="Heap.c">Heap.c</h4> 
<pre><code class="language-cpp">#include "Heap.h"


void Heapinit(Heap* php)
{
	assert(php);

	php-&gt;arr = (HPdatatype*)malloc(sizeof(HPdatatype) * 4);
	if (php-&gt;arr == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	php-&gt;size = 0;
	php-&gt;capacity = 4;
}

void Swap(HPdatatype* p1, HPdatatype* p2)
{
	HPdatatype tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}

///С

void AdjustUp(HPdatatype* arr, int child)
{
	assert(arr);

	int parent = (child - 1) / 2;

	while (child &gt; 0)
	{
		if (arr[child] MAX_MIN arr[parent])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
			break;
	}
}

void Heappush(Heap* php, HPdatatype x)
{
	assert(php);

	if (php-&gt;size == php-&gt;capacity)   //插入前，判断数组是否已满
	{
		HPdatatype* tmp = (HPdatatype*)realloc(php-&gt;arr, 2 * sizeof(HPdatatype) * php-&gt;capacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(-1);
		}

		php-&gt;arr = tmp;
		php-&gt;capacity *= 2;
	}

	php-&gt;arr[php-&gt;size] = x;
	php-&gt;size++;

	AdjustUp(php-&gt;arr, php-&gt;size - 1);  //这里要传size-1
}

void AdjustDown(HPdatatype* arr, int parent, int n)
{
	assert(arr);

	int child = 2 * parent + 1;

	while (child &lt; n)
	{
        //判断较大（较小）的子节点
		if ((child + 1) &lt; n &amp;&amp; arr[child + 1] MAX_MIN arr[child])  
		{
			child++;
		}

		if (arr[child] MAX_MIN arr[parent])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			parent = child;
			child = 2 * parent + 1;
		}
		else
			break;
	}
}

void Heappop(Heap* php)
{
	assert(php);
	assert(php-&gt;size);
	Swap(&amp;php-&gt;arr[0], &amp;php-&gt;arr[php-&gt;size - 1]);
	php-&gt;size--;

	AdjustDown(php-&gt;arr, 0, php-&gt;size);
}

HPdatatype Heaptop(Heap* php)
{
	assert(php);
	assert(php-&gt;size);   //为空时不能取数据

	return php-&gt;arr[0];
}

int Heapsize(Heap* php)
{
	assert(php);

	return php-&gt;size;
}

bool Heapempty(Heap* php)
{
	assert(php);

	return php-&gt;size == 0;  //size==0即为空
}

void Heapdestroy(Heap* php)
{
	assert(php);
	free(php-&gt;arr);
	php-&gt;arr = NULL;
	php-&gt;size = 0;
	php-&gt;capacity = 0;
}</code></pre> 
<h2 id="test.c">test.c</h2> 
<pre><code class="language-cpp">#include "Heap.h"


void testHeap()
{
	Heap hp;
	Heapinit(&amp;hp);

	int i = 0, n = 10;
	int x = 0;
	while (n)
	{
		x = rand() % 100 + 1;

		Heappush(&amp;hp, x);
		n--;
	}
	while (!Heapempty(&amp;hp))
	{
		printf("%d  ", Heaptop(&amp;hp));
		Heappop(&amp;hp);
	}

	printf("\n");
	Heapdestroy(&amp;hp);
}

int main()
{
	srand((unsigned int)time(NULL));
	testHeap();

	return 0;
}</code></pre> 
<hr> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>🐲👻这循环队列的讲解就到这里了，若有错误或是建议欢迎小伙伴们指出。🐯🤖</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>🥰🤩希望小伙伴们可以多多支持博主哦。😍😃</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>😁😄谢谢你的阅读。😼😸</strong></span></p> 
</blockquote> 
<p><img alt="" height="240" src="https://images2.imgbox.com/d6/93/mo7whSrO_o.gif" width="240"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c401c08f6efe76def0b336dad629bbf4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RANSAC算法（仅供学习使用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7674a66f3a0c5e49119d4720b6dbfd98/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【ChatGPT】参加计算机科学考试（GPT-4对比GPT-3.5）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>