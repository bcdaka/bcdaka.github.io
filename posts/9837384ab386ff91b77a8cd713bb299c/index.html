<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HiveSQL题——前后函数(lag/lead) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9837384ab386ff91b77a8cd713bb299c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="HiveSQL题——前后函数(lag/lead)">
  <meta property="og:description" content="目录
一、窗口函数的知识点
1.1 窗户函数的定义
1.2 窗户函数的语法
1.3 窗口函数分类
1.4 前后函数:lag/lead
二、实际案例
2.1 股票的波峰波谷
0 问题描述
1 数据准备
2 数据分析
3 小结
2.2 前后列转换（面试题）
0 问题描述
1 数据准备
2 数据分析
3 小结
一、窗口函数的知识点 1.1 窗户函数的定义 窗口函数可以拆分为【窗口&#43;函数】。窗口函数官网指路：LanguageManual WindowingAndAnalytics - Apache Hive - Apache Software Foundationhttps://cwiki.apache.org/confluence/display/Hive/LanguageManual&#43;WindowingAndAnalytics
窗口：定义函数计算范围（窗口函数：针对分组后的数据，从逻辑角度指定计算的范围，并没有从物理上真正的切分，只有group by 是物理分组，真正意义上的分组）函数：定义函数计算逻辑sql 执行顺序： from -&gt; join -&gt; on -&gt; where -&gt; group by-&gt; with (可以在分组后面加上 with rollup,在分组之后对每个组进行全局汇总) -&gt; select 后面的普通字段，聚合函数-&gt; having(having中可以使用select 字段别名) -&gt; distinct -&gt; order by -&gt; limit 窗口函数执行顺序：窗口函数是作用于select后的结果集。select 的结果集作为窗口函数的输入，但是位于 distcint 之前。窗口函数的执行结果只是在原有的列中单独添加一列，形成新的列，它不会对已有的行或列做修改。 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-11T22:51:47+08:00">
    <meta property="article:modified_time" content="2024-02-11T22:51:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HiveSQL题——前后函数(lag/lead)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:0px;"><a href="#main-toc" rel="nofollow">一、窗口函数的知识点</a></p> 
<p id="1.1%20%E7%AA%97%E6%88%B7%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.1%20%E7%AA%97%E6%88%B7%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.1 窗户函数的定义</a></p> 
<p id="1.2%20%E7%AA%97%E6%88%B7%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.2%20%E7%AA%97%E6%88%B7%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95" rel="nofollow">1.2 窗户函数的语法</a></p> 
<p id="1.3%20%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#1.3%20%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB" rel="nofollow">1.3 窗口函数分类</a></p> 
<p id="1.3%C2%A0%E5%89%8D%E5%90%8E%E5%87%BD%E6%95%B0%3Alag%2Flead-toc" style="margin-left:40px;"><a href="#1.3%C2%A0%E5%89%8D%E5%90%8E%E5%87%BD%E6%95%B0%3Alag%2Flead" rel="nofollow">1.4 前后函数:lag/lead</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B" rel="nofollow">二、实际案例</a></p> 
<p id="2.1%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%B3%A2%E5%B3%B0%E6%B3%A2%E8%B0%B7-toc" style="margin-left:40px;"><a href="#2.1%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%B3%A2%E5%B3%B0%E6%B3%A2%E8%B0%B7" rel="nofollow">2.1 股票的波峰波谷</a></p> 
<p id="0%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#0%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" rel="nofollow">0 问题描述</a></p> 
<p id="1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:80px;"><a href="#1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow">1 数据准备</a></p> 
<p id="2%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90" rel="nofollow">2 数据分析</a></p> 
<p id="3%20%E5%B0%8F%E7%BB%93-toc" style="margin-left:80px;"><a href="#3%20%E5%B0%8F%E7%BB%93" rel="nofollow">3 小结</a></p> 
<p id="2.2%C2%A0%E5%89%8D%E5%90%8E%E5%88%97%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%E5%89%8D%E5%90%8E%E5%88%97%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89" rel="nofollow">2.2 前后列转换（面试题）</a></p> 
<p id="0%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#0%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" rel="nofollow">0 问题描述</a></p> 
<p id="1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:80px;"><a href="#1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow">1 数据准备</a></p> 
<p id="2%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90" rel="nofollow">2 数据分析</a></p> 
<p id="3%20%E5%B0%8F%E7%BB%93-toc" style="margin-left:80px;"><a href="#3%20%E5%B0%8F%E7%BB%93" rel="nofollow">3 小结</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<h2 id="main-toc">一、窗口函数的知识点</h2> 
<h3>1.1 窗户函数的定义</h3> 
<p>         窗口函数可以拆分为【窗口+函数】。窗口函数官网指路：<a class="has-card" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics" rel="nofollow" title="LanguageManual WindowingAndAnalytics - Apache Hive - Apache Software Foundation"><span class="link-card-box"><span class="link-title">LanguageManual WindowingAndAnalytics - Apache Hive - Apache Software Foundation</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/c6/93/7UeAvUMe_o.png" alt="icon-default.png?t=N7T8">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics</span></span></a></p> 
<ul><li><strong>窗口</strong>：<strong>定义函数计算范围</strong>（窗口函数：针对分组后的数据，从逻辑角度指定计算的范围，并没有从物理上真正的切分，只有group by 是物理分组，真正意义上的分组）</li><li><strong>函数</strong>：<strong>定义函数计算逻辑</strong></li><li><strong>sql 执行顺序</strong>：</li></ul> 
<pre><code class="language-sql"> from -&gt;
 join -&gt;
 on -&gt;
 where -&gt;
 group by-&gt;
 with (可以在分组后面加上 with rollup,在分组之后对每个组进行全局汇总) -&gt;
 select 后面的普通字段，聚合函数-&gt; 
 having(having中可以使用select 字段别名) -&gt; 
 distinct -&gt; 
 order by -&gt;
 limit</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>窗口函数执行顺序</strong>：</span><span style="color:#494949;">窗口函数是作用于select后的结果集。select 的结果集作为窗口函数的输入，但是位于 distcint 之前。窗口函数的执行结果只是在原有的列中单独添加一列，形成新的列，它不会对已有的行或列做修改。</span></li></ul> 
<h3 id="1.2%20%E7%AA%97%E6%88%B7%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95">1.2 窗户函数的语法</h3> 
<p><strong>       &lt;窗口函数&gt;window_name  over ( [partition by 字段...]  [order by 字段...]  [窗口子句] )</strong></p> 
<ul><li><strong>window_name</strong>：给窗口指定一个别名。</li><li><strong>over</strong>：用来指定函数执行的窗口范围，如果后面括号中什么都不写，即over() ，意味着窗口包含满足where 条件的所有行，窗口函数基于所有行进行计算。</li><li>符号[] 代表：可选项；  | ： 代表二选一</li><li> <strong>partition by 子句</strong>： 窗口按照哪些字段进行分组，窗口函数在不同的分组上分别执行。分组间互相独立。</li><li><strong>order by 子句</strong>  :每个partition内部按照哪些字段进行排序，如果没有partition ，那就直接按照最大的窗口排序，且默认是按照升序（asc）排列。</li><li><strong>窗口子句</strong>：显示声明范围（不写窗口子句的话，会有默认值）。常用的窗口子句如下：</li></ul> 
<pre><code>    rows between unbounded preceding and  unbounded following; -- 上无边界到下无边界（一般用于求 总和）
    rows between unbounded preceding and current row;  --上无边界到当前记录(累计值)
    rows between 1 preceding and current row; --从上一行到当前行
    rows between 1 preceding and 1 following; --从上一行到下一行
    rows between current row and 1 following; --从当前行到下一行</code></pre> 
<p>    <span style="color:#fe2c24;"><strong> ps: </strong></span>over()里面有order by子句，但没有窗口子句时 ，即： <strong>&lt;窗口函数&gt; over ( partition by 字段... order by 字段... )，此时窗口子句是有默认值的-&gt; <span style="color:#fe2c24;"> rows between unbounded preceding and current row (上无边界到当前行)</span></strong>。</p> 
<p>      此时窗口函数语法：&lt;窗口函数&gt; over ( partition by 字段... order by 字段... ) 等价于</p> 
<p>     &lt;窗口函数&gt; over ( partition by 字段... order by 字段... rows between unbounded preceding and current row)<br>      需要注意有个特殊情况：<strong>当order by 后面跟的某个字段是有重复行的时候</strong>， &lt;窗口函数&gt; over ( partition by 字段... order by 字段... )  <strong>不写窗口子句的情况下，窗口子句的默认值是：range between unbounded preceding and current row(<span style="color:#fe2c24;">上无边界到当前相同行的最后一行</span>)</strong>。</p> 
<p>    因此，遇到order by 后面跟的某个字段出现重复行，且需要计算【上无边界到当前行】，那就需要<strong>手动指定 窗口子句 rows between unbounded preceding and current row </strong>，偷懒省略窗口子句会出问题~</p> 
<p><strong>    总结如下：</strong></p> 
<pre><code class="language-sql">1、窗口子句不能单独出现，必须有order by子句时才能出现。
2、当省略窗口子句时:
   a) 如果存在order by则默认的窗口是unbounded preceding and current row  --当前组的第一行到当前行，即在当前组中，第一行到当前行 
   b) 如果没有order by则默认的窗口是unbounded preceding and unbounded following  --整个组
 </code></pre> 
<p>    <span style="color:#fe2c24;">  <strong>ps:</strong> </span>窗口函数的执行顺序是在where之后，所以如果where子句需要用窗口函数作为条件，需要多一层查询，在子查询外面进行。</p> 
<p>     【例如】求出登录记录出现间断的用户Id</p> 
<pre><code class="language-sql">select
    id
from (
         select
             id,
             login_date,
             lead(login_date, 1, '9999-12-31')
                  over (partition by id order by login_date) next_login_date
             --窗口函数 lead(向后取n行)
             --lead(column1,n,default)over(partition by column2 order by column3) 查询当前行的后边第n行数据，如果没有就为null
         from (--用户在同一天可能登录多次，需要去重
                  select
                      id,
                      date_format(`date`, 'yyyy-MM-dd') as login_date
                  from user_log
                  group by id, date_format(`date`, 'yyyy-MM-dd')
              ) tmp1
     ) tmp2
where  datediff(next_login_date, login_date) &gt;=2
group by id;</code></pre> 
<ul><li> <p>窗口函数本身也有执行顺序：<strong> &lt;窗口函数&gt;over ( partition by  order by   窗口子句 )</strong>的执行顺序：over -&gt; partition by -&gt; order by -&gt; 窗口子句 -&gt; 函数</p> </li></ul> 
<h3 id="1.3%20%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB">1.3 窗口函数分类</h3> 
<p>      哪些函数可以是窗口函数呢？(放在over关键字前面的)</p> 
<ul><li> <h4>聚合函数</h4> </li></ul> 
<pre><code class="language-sql">sum(column) over (partition by .. order by .. 窗口子句);
count(column) over (partition by .. order by .. 窗口子句);
max(column) over  (partition by .. order by .. 窗口子句);
min(column) over (partition by .. order by .. 窗口子句);
avg(column) over (partition by .. order by .. 窗口子句);</code></pre> 
<p style="margin-left:0;text-align:justify;"><span style="color:#fe2c24;"> <strong> 需要注意：</strong></span></p> 
<pre><code class="language-sql">1.count(*)操作时会统计null值，count(column)会过滤掉null值;
2.事实上除了count(*)计算，剩余的聚合函数例如： max(column),min(column),avg(column),count(column) 函数会过滤掉null值</code></pre> 
<p style="margin-left:0;text-align:justify;"><strong> ps : <span style="color:#fe2c24;">高级聚合函数</span>：</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>         collect_list 收集并形成list集合，结果不去重;</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#ff0000;">         </span>collect_set </strong><strong>收集并形成</strong><strong>set</strong><strong>集合，结果去重;</strong> </p> 
<p style="margin-left:0;text-align:justify;"><strong>      举例：</strong></p> 
<pre><code class="language-sql">--每个月的入职人数以及姓名

select 
month(replace(hiredate,'/','-')),
    count(*) as cnt,
    collect_list(name) as name_list
from employee
group by month(replace(hiredate,'/','-'));


/*
输出结果
month  cn  name_list
4	    2	["宋青书","周芷若"]
6	    1	["黄蓉"]
7	    1	["郭靖"]
8	    2	["张无忌","杨过"]
9	    2	["赵敏","小龙女"]

*/</code></pre> 
<ul><li> <h4>排序函数</h4> </li></ul> 
<p><strong><span style="color:#ff0000;">    </span><span style="color:#494949;">  rank() 、row_number() 、dense_rank() 函数不支持自定义窗口子句。</span></strong></p> 
<pre><code class="language-sql">--  顺序排序——1、2、3
row_number() over(partition by .. order by .. )

--  并列排序，跳过重复序号——1、1、3（横向加）
rank() over(partition by .. order by .. )

-- 并列排序，不跳过重复序号——1、1、2（纵向加）
dense_rank()  over(partition by .. order by .. )</code></pre> 
<ul><li> <h4>前后函数 </h4> </li></ul> 
<pre><code class="language-sql">-- 取得column列前边的第n行数据，如果存在则返回，如果不存在，返回默认值default
lag(column,n,default) over(partition by order by) as lag_test
-- 取得column列后边的第n行数据，如果存在则返回，如果不存在，返回默认值default
lead(column,n,default) over(partition by order by) as lead_test</code></pre> 
<ul><li> <h4>头尾函数</h4> </li></ul> 
<pre><code class="language-sql">---当前窗口column列的第一个数值，如果有null值，则跳过
first_value(column,true) over (partition by ..order by.. 窗口子句) 

---当前窗口column列的第一个数值，如果有null值，不跳过
first_value(column,false) over (partition by ..order by.. 窗口子句)

--- 当前窗口column列的最后一个数值，如果有null值，则跳过
last_value(column,true) over (partition by ..order by.. 窗口子句) 

--- 当前窗口column列的最后一个数值，如果有null值,不跳过
last_value(column,false) over (partition by ..order by.. 窗口子句) 

</code></pre> 
<h3 id="1.3%C2%A0%E5%89%8D%E5%90%8E%E5%87%BD%E6%95%B0%3Alag%2Flead">1.4 前后函数:lag/lead</h3> 
<p>       lead和lag函数，这两个函数一般用于计算差值，上面已介绍其语法。<strong><span style="color:#ff0000;">lag</span></strong><strong><span style="color:#ff0000;">和</span></strong><strong><span style="color:#ff0000;">lead</span></strong><strong><span style="color:#ff0000;">函数不支持自定义窗口子句。</span></strong></p> 
<pre><code>-- 取得column列前边的第n行数据，如果存在则返回，如果不存在，返回默认值default
lag(column,n,default) over(partition by order by) as lag_test
-- 取得column列后边的第n行数据，如果存在则返回，如果不存在，返回默认值default
lead(column,n,default) over(partition by order by) as lead_test</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B">二、实际案例</h2> 
<h3 id="2.1%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%B3%A2%E5%B3%B0%E6%B3%A2%E8%B0%B7">2.1 股票的波峰波谷</h3> 
<h4 id="0%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">0 问题描述</h4> 
<p>    求股票的波峰Crest 和 波谷trough</p> 
<pre><code class="language-TypeScript">波峰：当天的股票价格大于前一天和后一天
波谷：当天的股票价格小于前一天和后一天</code></pre> 
<h4 id="1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">1 数据准备</h4> 
<pre><code class="language-sql">create table if not exists table2
(
    id     int comment '股票id',
    dt     string comment '日期',
    price  int comment '价格'
)
    comment '股票价格波动信息';

insert overwrite table table2 values
(1,'2019-01-01',10001),
(1,'2019-01-03',1001),
(1,'2019-01-02',1001),
(1,'2019-01-04',1000),
(1,'2019-01-05',1002),
(1,'2019-01-06',1003),
(1,'2019-01-07',1004),
(1,'2019-01-08',998),
(1,'2019-01-09',997),
(2,'2019-01-01',1002),
(2,'2019-01-02',1003),
(2,'2019-01-03',1004),
(2,'2019-01-04',998),
(2,'2019-01-05',999),
(2,'2019-01-06',997),
(2,'2019-01-07',996);</code></pre> 
<h4 id="2%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90">2 数据分析</h4> 
<p>  此题容易理解，利用lag()和lead()函数便可以解决。</p> 
<pre><code class="language-sql">select
    id,
    dt,
    price,
    case
        when price &gt; lag_price and price &gt; lead_price then 'crest'
        when price &lt; lag_price and price &lt; lead_price then 'trough'
        end as price_type
from (
         select
             id,
             dt,
             price,
             lag(price, 1) over (partition by id order by dt)  as lag_price,
             lead(price, 1) over (partition by id order by dt) as lead_price
         from table2
     ) tmp1;</code></pre> 
<h4 id="3%20%E5%B0%8F%E7%BB%93">3 小结</h4> 
<p>    lead和lag函数一般用于计算当前行与上一行，或者当前行与下一行之间的差值。在用户间断登陆问题中也遇到过此函数。指路：<a class="has-card" href="https://blog.csdn.net/SHWAITME/article/details/135900251?spm=1001.2014.3001.5501" title="HiveSQL题——用户连续登陆-CSDN博客"><span class="link-card-box"><span class="link-title">HiveSQL题——用户连续登陆-CSDN博客</span><span class="link-desc">文章浏览阅读220次，点赞4次，收藏3次。HiveSQL题——用户连续登陆</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/9a/03/WqXMUsXf_o.png">https://blog.csdn.net/SHWAITME/article/details/135900251?spm=1001.2014.3001.5501</span></span></a></p> 
<h3 id="2.2%C2%A0%E5%89%8D%E5%90%8E%E5%88%97%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89">2.2 前后列转换（面试题）</h3> 
<h4>0 问题描述</h4> 
<p>    表temp包含A,B 两列，使用SQL对该B列进行处理，形成C列。按照A列顺序，B列值不变，C列累计技术 B列值变化，则C列重新开始计数，如图所示</p> 
<p>   <img alt="" height="380" src="https://images2.imgbox.com/dd/9f/NPYwmuml_o.png" width="653"></p> 
<h4>1 数据准备</h4> 
<pre><code class="language-sql">with table4 as (
    select 2010 as A,1 as B
    union all
    select 2011 as A,1 as B
    union all
    select 2012 as A,1 as B
    union all
    select 2013 as A,0 as B
    union all
    select 2014 as A,0 as B
    union all
    select 2015 as A,1 as B
    union all
    select 2016 as A,1 as B
    union all
    select 2017 as A,1 as B
    union all
    select 2018 as A,0 as B
    union all
    select 2019 as A,0 as B
)</code></pre> 
<h4>2 数据分析</h4> 
<pre><code class="language-sql">with table4 as (
    select 2010 as A,1 as B
    union all
    select 2011 as A,1 as B
    union all
    select 2012 as A,1 as B
    union all
    select 2013 as A,0 as B
    union all
    select 2014 as A,0 as B
    union all
    select 2015 as A,1 as B
    union all
    select 2016 as A,1 as B
    union all
    select 2017 as A,1 as B
    union all
    select 2018 as A,0 as B
    union all
    select 2019 as A,0 as B
)

select
    A,
    B,
    row_number() over (partition by T order by A) as C
from (
         select
             A,
             B,
             --over (order by A) 本质是 ：over(order by rows between unbounded preceding and current row )
             --省略的是：上无边界到当前行
             sum(change) over (order by A) T
         from (
                  select
                      A,
                      B,
                      -- 向上取一行，取不到的记为0
                      lag(B, 1, 0) over (order by A) as Lag,
                      case
                          when B &lt;&gt; lag(B, 1, 0) over (order by A) then 1
                          else 0
                          end   as change
                  from table4
              ) tmp1
     ) tmp2;</code></pre> 
<h4>3 小结</h4> 
<p>    lead /lag函数常用于差值计算。</p> 
<h2></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3252fa0ee5a0eadccf308cdf95ce1720/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MongoDB聚合：分组统计$group的用法详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ef9dd16d3a353e5405ef1ea12501962e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">工业制造：分布式控制系统（DCS），一文掌握。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>