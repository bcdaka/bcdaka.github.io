<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】map&amp;set详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b501431f3e625f50e71eb02a78413f25/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】map&set详解">
  <meta property="og:description" content="🍁1. Set系列集合 Set接口是一种不包含重复元素的集合。它继承自Collection接口，所以可以使用Collection所拥有的方法，Set接口的实现类主要有HashSet、LinkedHashSet、TreeSet等，它们各自以不同的方式存储元素，但都遵循Set接口的规定。
当你需要确保集合中的元素唯一时。当你不需要保持元素的插入顺序时（除非使用LinkedHashSet）。当你需要元素自然排序或根据自定义排序规则排序时（使用TreeSet）。 🍁1.1 HashSet 当用HashSet实例化对象时，由于底层结构是哈希表，所以元素是无序的，而TreeSet底层是红黑树，是有序的
由于Set系列集合里面不能有重复的元素，在之前我们也了解到，add方法的返回值是boolean类型的，当遇到重复元素，第二次添加就会添加失败
并且Set集合没有索引的概念，不能通过下标的方式进行遍历打印
和之前一样，没有索引的集合可以通过迭代器，增强for，lambda表达式进行遍历
Iterator&lt;String&gt; it = s1.iterator(); while (it.hasNext()){ System.out.print(it.next() &#43; &#34; &#34;); } System.out.println(); for(String s : s1){ System.out.print(s &#43; &#34; &#34;); } System.out.println(); s1.forEach(new Consumer&lt;String&gt;() { @Override public void accept(String s) { System.out.print(s &#43; &#34; &#34;); } }); 🍁1.2 LinkedHashSet LinkedHashSet底层也是哈希表，但是存取元素的顺序是一致的，因为使用了双向链表记录添加顺序
🍁1.3 TreeSet TreeSet是基于红黑树实现的，TreeSet中的元素处于排序状态，因此查找、添加、删除和遍历等操作都能以对数时间复杂度进行。但是，向TreeSet中添加的元素必须实现Comparable接口，或者在创建TreeSet时提供一个Comparator对象，以确保元素可以被正确地排序。
排序规则：Integer,Double等数值类型默认按照从小到大的顺序排序，对于字符，字符串类型，按照ASCII码表中的数字进行升排序 接下来演示一下，创建自定义类型的TreeSet
例如：给出一个Student类，要求按照学生的年龄排序
首先创建好Student类之后，需要实现Comparable接口，然后重写compareTo和toString方法
public class Student implements Comparable&lt;Student&gt;{ public String name; public int age; public Student(String name, int age) { this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T11:28:11+08:00">
    <meta property="article:modified_time" content="2024-08-05T11:28:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】map&amp;set详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<blockquote> 
 <div> 
  <p class="img-center"><img alt="" height="417" src="https://images2.imgbox.com/05/f8/8XkcxRbI_o.gif" width="755"></p> 
 </div> 
</blockquote> 
<p></p> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/56/bc/CvdS7Ybp_o.gif"></p> 
<p></p> 
<h2>🍁<span style="color:#fe2c24;">1. Set系列集合</span></h2> 
<p><code>Set</code>接口是一种不包含重复元素的集合。它继承自<code>Collection</code>接口，所以可以使用Collection所拥有的方法，<code>Set</code>接口的实现类主要有<code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code>等，它们各自以不同的方式存储元素，但都遵循<code>Set</code>接口的规定。</p> 
<blockquote> 
 <ul><li>当你需要确保集合中的元素唯一时。</li><li>当你不需要保持元素的插入顺序时（除非使用<code>LinkedHashSet</code>）。</li><li>当你需要元素自然排序或根据自定义排序规则排序时（使用<code>TreeSet</code>）。</li></ul> 
</blockquote> 
<p class="img-center"><img alt="" height="431" src="https://images2.imgbox.com/26/bb/XIO03OzL_o.png" width="554"></p> 
<p></p> 
<h3>🍁<span style="color:#fe2c24;">1.1 HashSet </span></h3> 
<p>当用HashSet实例化对象时，由于底层结构是哈希表，所以元素是无序的，而TreeSet底层是红黑树，是有序的</p> 
<p class="img-center"><img alt="" height="580" src="https://images2.imgbox.com/77/2a/5m30ham6_o.png" width="1200"></p> 
<p> 由于Set系列集合里面不能有重复的元素，在之前我们也了解到，add方法的返回值是boolean类型的，当遇到重复元素，第二次添加就会添加失败</p> 
<p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/f3/d7/Tp2ePU9v_o.png" width="1200"></p> 
<p></p> 
<p>并且Set集合没有索引的概念，不能通过下标的方式进行遍历打印</p> 
<p> 和之前一样，没有索引的集合可以通过迭代器，增强for，lambda表达式进行遍历</p> 
<p></p> 
<pre><code class="language-java">        Iterator&lt;String&gt; it = s1.iterator();
        while (it.hasNext()){
            System.out.print(it.next() + " ");
        }
        System.out.println();


        for(String s : s1){
            System.out.print(s + " ");
        }
        System.out.println();
        

        s1.forEach(new Consumer&lt;String&gt;() {
            @Override
            public void accept(String s) {
                System.out.print(s + " ");
            }
        });</code></pre> 
<h3> 🍁<span style="color:#fe2c24;">1.2 LinkedHashSet</span></h3> 
<p> LinkedHashSet底层也是哈希表，但是存取元素的顺序是一致的，因为使用了双向链表记录添加顺序</p> 
<p></p> 
<p class="img-center"><img alt="" height="224" src="https://images2.imgbox.com/be/75/YRYo5qtR_o.png" width="1200"></p> 
<h3>🍁1.3 TreeSet</h3> 
<p>TreeSet是基于<span style="color:#fe2c24;"><strong>红黑树</strong></span>实现的，<code>TreeSet</code>中的元素处于排序状态，因此查找、添加、删除和遍历等操作都能以对数时间复杂度进行。但是，<span style="color:#fe2c24;"><strong>向<code>TreeSet</code>中添加的元素必须实现<code>Comparable</code>接口，或者在创建<code>TreeSet</code>时提供一个<code>Comparator</code>对象，以确保元素可以被正确地排序。</strong></span></p> 
<p><span style="background-color:#ffd900;"> 排序规则：Integer,Double等数值类型默认按照从小到大的顺序排序，对于字符，字符串类型，按照ASCII码表中的数字进行升排序 </span></p> 
<p> 接下来演示一下，创建自定义类型的TreeSet</p> 
<p>例如：给出一个Student类，要求按照学生的年龄排序</p> 
<p>首先创建好Student类之后，<span style="background-color:#ffd900;">需要实现Comparable接口，然后重写compareTo和toString方法</span></p> 
<pre><code class="language-java">public class Student implements Comparable&lt;Student&gt;{
    public String name;
    public int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }


    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public int compareTo(Student o) {
        return this.age - o.age;//this.age表示要添加的元素
    }
}</code></pre> 
<p> this.age表示要添加的元素，所以如果返回值是负数，表示要添加的元素是小的，存左边，如果是0，表示元素已经存在，直接舍弃</p> 
<pre><code class="language-java">public class Text2 {
    public static void main(String[] args) {
        Student s1 = new Student("zhang",18);
        Student s2 = new Student("wang",20);
        Student s3 = new Student("li",19);
        TreeSet&lt;Student&gt; treeSet = new TreeSet&lt;&gt;();
        treeSet.add(s1);
        treeSet.add(s2);
        treeSet.add(s3);
        System.out.println(treeSet);
    }
}</code></pre> 
<p> 最终，虽然插入时没有按顺序，由于TreeSet底层是红黑树，所以最终也实现了排序的效果</p> 
<p class="img-center"><img alt="" height="171" src="https://images2.imgbox.com/25/35/EkKfi4v8_o.png" width="1200"></p> 
<p><strong> 比较器排序</strong></p> 
<p>问题：根据字符串长度比较，长度相同再按字典序比较</p> 
<pre><code class="language-java">        //o1:当前要添加的元素
        //o2:红黑树中已经存在的元素
        TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() {
            @Override
            public int compare(String o1, String o2) {
                return (o1.length() - o2.length()) == 0 ? o1.compareTo(o2) : o1.length() - o2.length();
            }
        });
        ts.add("bbcd");
        ts.add("abcde");
        ts.add("abcd");
        System.out.println(ts);</code></pre> 
<p>也就是在创建对象的时候传入比较器进行比较</p> 
<p class="img-center"><img alt="" height="84" src="https://images2.imgbox.com/da/9c/DpdHm0Ev_o.png" width="543"></p> 
<h2>🍁<span style="color:#fe2c24;">2. 单列集合的使用场景分析</span></h2> 
<p>介绍完Set系列集合之后，我们的单列集合就都学习完了，接下来分析一下这写集合的使用场景</p> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>如果集合中元素可重复：</strong><strong>使用ArrayList（基于数组）</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>如果集合中元素可重复并且用到增删操作多余查询:</strong><strong>使用LinkedList</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>如果需要对集合去重：</strong><strong>使用HashSet</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>如果需要在去重的前提下还要保证存取顺序：</strong><strong>使用LinkedHashSet</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>如果需要对集合中的元素进行排序：</strong><strong>使用TreeSet</strong></span></p> 
</blockquote> 
<h2>🍁<span style="color:#fe2c24;">3. Map系列集合</span></h2> 
<p>Map系列的集合称为双列集合</p> 
<blockquote> 
 <p><span style="color:#38d8f0;"><strong>1. 双列集合一次存储一对数据，分别为键和值</strong></span></p> 
 <p><span style="color:#38d8f0;"><strong>2. 键不能重复，值可以重复</strong></span></p> 
 <p><span style="color:#38d8f0;"><strong>3. 键和值是一一对应的，每一个键都对应一个值</strong></span></p> 
 <p><span style="color:#38d8f0;"><strong>4. 键+值整体称为键值对，也叫Entry对象</strong></span></p> 
</blockquote> 
<p> 和Set集合类似，Map是顶层接口，底下有这些实现类</p> 
<p class="img-center"><img alt="" height="279" src="https://images2.imgbox.com/20/4e/dshe6Js1_o.png" width="400"></p> 
<p>以下就是Map集合常用的API</p> 
<p class="img-center"><img alt="" height="408" src="https://images2.imgbox.com/ca/c4/4U07c6Mh_o.png" width="1200"></p> 
<h3>🍁<span style="color:#fe2c24;">3.1 HashMap</span></h3> 
<p>HashMap的底层也是哈希表，和之前的HashSet不同，HashMap中，当插入的key相同时，第二次插入会覆盖原来的value值，同时，如果存储的是自定义类型的对象还需要重写HashCode和equals方法</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/c0/ef/d1Fayqxs_o.png" width="1200">其他方法就不演示了，下面来介绍一下map的遍历</p> 
<p><strong>Map的遍历</strong></p> 
<p>键找值：调用keySet方法，获取所有的key，把返回值放在Set集合中，再遍历Set集合，通过get方法获取每一个key的value</p> 
<pre><code class="language-java">        //获取所有的键，并放在Set集合中
        Set&lt;String&gt; set = map.keySet();
        //遍历set,根据所有的键获取值
        for(String key:set){
            int value = map.get(key);
            System.out.println(key + " = " + value);
        }</code></pre> 
<p><strong>通过键值对对象进行遍历</strong></p> 
<p>调用entrySet方法，把所有键值对对象放在Set集合中，再遍历Set集合</p> 
<p class="img-center"><img alt="" height="244" src="https://images2.imgbox.com/0d/f5/lCYqkvsg_o.png" width="596"></p> 
<p> 可以看出，Entry是Map接口的一个内部接口，所以需要通过Map.Entry的形式调用，也可以直接导入</p> 
<pre>import java.util.Map.Entry;</pre> 
<p>就可以省略Map.</p> 
<p>遍历时，可以直接打印Entry对象，也可以通过get的方式获取key和value        </p> 
<pre><code class="language-java">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
        for(Map.Entry&lt;String,Integer&gt; entry : entries){
            //System.out.println(entry);
            String s = entry.getKey();
            Integer i = entry.getValue();
            System.out.println(s + " = " + i);
        }</code></pre> 
<p>最后还可以通过lambda的形式遍历</p> 
<pre><code class="language-java">        map.forEach(new BiConsumer&lt;String, Integer&gt;() {
            @Override
            public void accept(String key, Integer value) {
                System.out.println(key + " = " + value);
            }
        });

        map.forEach((key, value) -&gt; System.out.println(key + " = " + value));</code></pre> 
<h3>🍁<span style="color:#fe2c24;">3.2 LinkedHashMap</span></h3> 
<p>和LinkedHashSet一样，LinkedHashMap存储的键是有序的（存储顺序和取出顺序一样）</p> 
<p></p> 
<p class="img-center"><img alt="" height="303" src="https://images2.imgbox.com/fe/8d/zHA5SgUC_o.png" width="1200"></p> 
<h3><br> 🍁<span style="color:#fe2c24;">3.3 TreeMap</span></h3> 
<p>TreeMap和TreeSet底层一样，都是红黑树，根据键进行排序，排序规则也是类似的，对于非数值等类型，可以实现Comparable接口，指定比较规则，也可以传入比较器</p> 
<p class="img-center"><img alt="" height="306" src="https://images2.imgbox.com/7e/ef/SHncP3lv_o.png" width="1200"></p> 
<h2>🍁<span style="color:#fe2c24;">4. 面试OJ题练习</span></h2> 
<h3>🍁<span style="color:#fe2c24;">4.1 随机链表的复制</span></h3> 
<p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/" rel="nofollow" title="138. 随机链表的复制">138. 随机链表的复制</a></p> 
<p class="img-center"><img alt="" height="456" src="https://images2.imgbox.com/41/47/sQ0ZCwuD_o.png" width="600"></p> 
<p> 也就是下面这种情况</p> 
<p class="img-center"><img alt="" height="421" src="https://images2.imgbox.com/8c/68/edGZaadH_o.png" width="648"></p> 
<p>如果说直接对链表节点进行复制是不可以的，因为题目中要求的是深拷贝，所以说拷贝后的 节点可能和原来的地址不一样</p> 
<blockquote> 
 <p>思路：遍历原来的链表，每遍历一次都创建一个新的节点，把原来的节点和拷贝的新节点的映射关系使用map存储起来，再通过get方法得到节点，再连接next和random</p> 
</blockquote> 
<p class="img-center"><img alt="" height="393" src="https://images2.imgbox.com/e8/22/z4n4DdZf_o.png" width="803"></p> 
<p></p> 
<pre><code class="language-java">    public Node copyRandomList(Node head) {
        Map&lt;Node, Node&gt; map = new LinkedHashMap&lt;&gt;();
        Node cur = head;
        while (cur != null) {
            Node copy = new Node(cur.val);
            map.put(cur, copy);
            cur = cur.next;
        }
        /*cur = head;
        while (cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }*/


        Set&lt;Node&gt; keySet = map.keySet();
        for (Node curNode : keySet) {
            map.get(curNode).next = map.get(curNode.next);
            map.get(curNode).random = map.get(curNode.random);
        }
        return map.get(head);
    }</code></pre> 
<h3>🍁<span style="color:#fe2c24;">4.2 宝石与石头 </span></h3> 
<p><a href="https://leetcode.cn/problems/jewels-and-stones/" rel="nofollow" title="771. 宝石与石头">771. 宝石与石头</a></p> 
<p class="img-center"><img alt="" height="395" src="https://images2.imgbox.com/8c/e1/vjxFJpuM_o.png" width="600"></p> 
<p> 这一题就可以很好的利用Set集合元素不能重复的特性了，如果不用Set集合，把全部元素异或一遍就可以找到了，而且速度更快，这里只是为了练习一下Set集合的使用，只需要把jewels存一个set，再遍历stones，判断是否有set集合里的元素即可</p> 
<pre><code class="language-java">public class Text {
    public static void main(String[] args) {
        String jewels = "aA";
        String stones = "aAABBBBB";
        System.out.println(numJewelsInStones(jewels, stones));
    }

    public static int numJewelsInStones(String jewels, String stones) {
        Set&lt;Character&gt; set = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; jewels.length(); i++) {
            set.add(jewels.charAt(i));
        }
        int cnt = 0;
        for (int i = 0; i &lt; stones.length(); i++) {
            if (set.contains(stones.charAt(i))) {
                cnt++;
            }
        }
        return cnt;
    }
}</code></pre> 
<h3>🍁<span style="color:#fe2c24;">4.3 前k个高频单词</span></h3> 
<p><a href="https://leetcode.cn/problems/top-k-frequent-words/" rel="nofollow" title="692. 前K个高频单词">692. 前K个高频单词</a></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/96/ec/WEe7ZuPc_o.png" width="500"></p> 
<p><strong> <span style="color:#fe2c24;">思路：前k个高频词，就是经典的topk问题，根据之前我们学到的，就是用小根堆解决，首先统计一下每个单词出现的频率，并通过map存储它们的映射关系，接着创建小根堆，套用之前的模板解决</span></strong></p> 
<pre><code class="language-java">    public List&lt;String&gt; topKFrequent(String[] words, int k) {
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        //统计单词个数并存入map
        for (String s : words) {
            if (map.get(s) == null) {
                map.put(s, 1);
            } else {
                int val = map.get(s);
                map.put(s, ++val);
            }
        }
        //创建根据map的value创建小根堆
        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() {
            @Override
            public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) {
                //相同时根据key创建大根堆，最后反转的时候就可以把字典序靠前的排到前面了
                if (o1.getValue().compareTo(o2.getValue()) == 0) {
                    return o2.getKey().compareTo(o1.getKey());
                }
                return o1.getValue().compareTo(o2.getValue());
            }
        });
        //根据之前讲解的topk问题解决
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
            //先把前K个元素加入大根堆
            if (minHeap.size() &lt; k) {
                minHeap.offer(entry);
            } else {
                Map.Entry&lt;String, Integer&gt; top = minHeap.peek();
                //堆顶元素频率小于后面的
                if (top.getValue().compareTo(entry.getValue()) &lt; 0) {
                    minHeap.poll();
                    minHeap.offer(entry);
                } else if (top.getValue().compareTo(entry.getValue()) == 0) {
                    //堆顶元素等于后面时，堆顶的key字典序大于后面的
                    if (top.getKey().compareTo(entry.getKey()) &gt; 0) {
                        minHeap.poll();
                        minHeap.offer(entry);
                    }
                }
            }
        }
        ArrayList&lt;String&gt; ans = new ArrayList&lt;&gt;();
        //把key存入ArrayList
        for (int i = 0; i &lt; k; i++) {
            ans.add(minHeap.poll().getKey());
        }
        //题目要求出现频率由高到低，进行翻转
        Collections.reverse(ans);
        return ans;
    }</code></pre> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/31/a9/uCDTEvAF_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6caaf218fe3b0749899887c16005942/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【游戏引擎之路】登神长阶（九）——《3D游戏编程大师技巧》：我想成为游戏之神！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f5b311c911c31848bff8d99a1a22741/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Qt】如何搭建Qt开发环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>