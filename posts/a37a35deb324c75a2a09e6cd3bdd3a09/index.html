<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】Java对象的比较 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a37a35deb324c75a2a09e6cd3bdd3a09/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】Java对象的比较">
  <meta property="og:description" content="作者主页：paper jie_博客
本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。
本文录入于《JAVA数据结构》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。
其他专栏：《算法详解》《C语言》《javaSE》等
内容分享：本期将会分享java数据结构中的对象比较
目录
priorityQueue中如何插入对象
元素的比较
基本类型的比较
对象类型的直接比较
对象正确的比较方式
重写equals方法
基于Comparble接口类的比较
基于比较器比较
集合框架中priorityQueue的比较方式
priorityQueue中如何插入对象 我们知道，优先级队列在插入元素时有一个要求：需要可以比较的对象才能插入。这里我们需要知道怎样插入自定义类型对象：
比如我们插入这个student对象：
class student { int age; String name; public student(int age, String name) { this.age = age; this.name = name; } } public class Test { public static void main(String[] args) { PriorityQueue&lt;student&gt; priorityQueue = new PriorityQueue&lt;&gt;(); priorityQueue.offer(new student(12,&#34;小猪佩奇&#34;)); priorityQueue.offer(new student(12,&#34;小猪乔治&#34;)); } 在运行后发现它会报类型不兼容的异常，这是因为在堆中插入元素，为了满足堆的性质，需要进行对象的比较，但是我们的student类型对象时不能直接比较的，所以会报错
​
元素的比较 基本类型的比较 在Java中，基本类型的对象是可以直接进行比较大小的
class TestCompare { public static void main(String[] args) { int a = 10; int b = 20; System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-22T14:02:28+08:00">
    <meta property="article:modified_time" content="2023-10-22T14:02:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】Java对象的比较</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong><span style="color:#4da8ee;">作者主页：</span><strong><span style="color:#4da8ee;"><a href="https://blog.csdn.net/paperjie?type=blog" title="paper jie_博客">paper jie_博客</a></span></strong></strong></p> 
 <p><span style="color:#4da8ee;"><strong>本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>本文录入于《JAVA数据结构》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>其他专栏：《算法详解》《C语言》《javaSE》等</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>内容分享：本期将会分享java数据结构中的对象比较</strong></span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="priorityQueue%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#priorityQueue%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E5%AF%B9%E8%B1%A1" rel="nofollow">priorityQueue中如何插入对象</a></p> 
<p id="%E5%85%83%E7%B4%A0%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#%E5%85%83%E7%B4%A0%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">元素的比较</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">基本类型的比较</a></p> 
<p id="%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83" rel="nofollow">对象类型的直接比较</a></p> 
<p id="%E5%AF%B9%E8%B1%A1%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E5%AF%B9%E8%B1%A1%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F" rel="nofollow">对象正确的比较方式</a></p> 
<p id="%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95" rel="nofollow">重写equals方法</a></p> 
<p id="%E5%9F%BA%E4%BA%8EComparble%E6%8E%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E4%BA%8EComparble%E6%8E%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">基于Comparble接口类的比较</a></p> 
<p id="%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8%E6%AF%94%E8%BE%83" rel="nofollow">基于比较器比较</a></p> 
<p id="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%ADpriorityQueue%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%ADpriorityQueue%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F" rel="nofollow">集合框架中priorityQueue的比较方式</a></p> 
<hr> 
<h2 id="priorityQueue%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E5%AF%B9%E8%B1%A1">priorityQueue中如何插入对象</h2> 
<p>我们知道，优先级队列在插入元素时有一个要求：<strong>需要可以比较的对象才能插入。</strong>这里我们需要知道怎样插入自定义类型对象：</p> 
<p>比如我们插入这个student对象：</p> 
<div> 
 <pre><code class="language-java">class student {
    int age;
    String name;

    public student(int age, String name) {
        this.age = age;
        this.name = name;
    }
}

public class Test {
    public static void main(String[] args) {
        PriorityQueue&lt;student&gt; priorityQueue = new PriorityQueue&lt;&gt;();
        priorityQueue.offer(new student(12,"小猪佩奇"));
        priorityQueue.offer(new student(12,"小猪乔治"));
    }</code></pre> 
</div> 
<p>在运行后发现它会报类型不兼容的异常，这是因为在堆中插入元素，为了满足堆的性质，需要进行对象的比较，但是我们的student类型对象时不能直接比较的，所以会报错</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/18/28/ccxoWrhP_o.png" width="1200">​</p> 
<h2 id="%E5%85%83%E7%B4%A0%E7%9A%84%E6%AF%94%E8%BE%83">元素的比较</h2> 
<h3 id="%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83">基本类型的比较</h3> 
<p>在Java中，基本类型的对象是可以直接进行比较大小的</p> 
<div> 
 <pre><code class="language-java">class TestCompare {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        System.out.println(a &gt; b);
        System.out.println(a &lt; b);
        System.out.println(a == b);
        char c1 = 'A';
        char c2 = 'B';
        System.out.println(c1 &gt; c2);
        System.out.println(c1 &lt; c2);
        System.out.println(c1 == c2);
        boolean b1 = true;
        boolean b2 = false;
        System.out.println(b1 == b2);
        System.out.println(b1 != b2);
    }
}</code></pre> 
</div> 
<h3 id="%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83">对象类型的直接比较</h3> 
<div> 
 <pre><code class="language-java">class Card {
public int rank; // 数值
public String suit; // 花色
public Card(int rank, String suit) {
this.rank = rank;
this.suit = suit;
}
}
public class TestPriorityQueue {
public static void main(String[] args) {
Card c1 = new Card(1, "♠");
Card c2 = new Card(2, "♠");
Card c3 = c1;
//System.out.println(c1 &gt; c2); // 编译报错
System.out.println(c1 == c2); // 编译成功 ----&gt; 打印false，因为c1和c2指向的是不同对象
//System.out.println(c1 &lt; c2); // 编译报错
System.out.println(c1 == c3); // 编译成功 ----&gt; 打印true，因为c1和c3指向的是同一个对象
}
}</code></pre> 
</div> 
<p>这里我们知道，直接进行对象比较的是地址，只有相同才会返回true，不同就会报错。<strong>但是这里为毛==可以比较呢？这就得提到Object类了，因为自定义类也会继承Object类，这个类中提供了equal方法，==的情况下就是用的Object的equal方法。但是这个方式比较的就是引用对象的地址，没有比较对象的内容，这就头疼了。</strong></p> 
<div> 
 <pre><code class="language-java">// Object中equal的实现，可以看到：直接比较的是两个引用变量的地址
public boolean equals(Object obj) {
return (this == obj);
}</code></pre> 
</div> 
<h2 id="%E5%AF%B9%E8%B1%A1%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F">对象正确的比较方式</h2> 
<h3 id="%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95">重写equals方法</h3> 
<div> 
 <pre><code class="language-java">class student {
    int age;
    String name;

    public student(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if(this == obj) {
            return true;
        }
        if(obj == null || !(obj instanceof student)) {
            return false;
        }
        student o = (student) obj;
        return this.age == ((student) obj).age &amp;&amp; this.name.equals(o.name);
    }
}</code></pre> 
</div> 
<p>如果指向一个对象，返回true</p> 
<p>如果传入的是null或者不是student，返回false</p> 
<p>按照类的成员对象比较，只要成员对象相同就返回true</p> 
<p>注意下调其他引用类型的比较也要调用equals</p> 
<p>这里的缺陷就是：equals只能按照相等来比较，不能比较大小</p> 
<h3 id="%E5%9F%BA%E4%BA%8EComparble%E6%8E%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83">基于Comparble接口类的比较</h3> 
<p>Comparable接口的源码：</p> 
<div> 
 <pre><code class="language-java">public interface Comparable&lt;E&gt; {
// 返回值:
// &lt; 0: 表示 this 指向的对象小于 o 指向的对象
// == 0: 表示 this 指向的对象等于 o 指向的对象
// &gt; 0: 表示 this 指向的对象大于 o 指向的对象
int compareTo(E o);
}</code></pre> 
</div> 
<p>对用户自定义类型，想要按照大小比较时，在定义类的时候，实现Comparable接口即可。然后在类中实现compareTo方法：</p> 
<div> 
 <pre><code class="language-java">class student implements Comparable&lt;student&gt;{
    int age;
    String name;

    public student(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public int compareTo(student o) {
        if(o == null) {
            return 1;
        }
        return this.age - o.age;
    }
}</code></pre> 
</div> 
<h3 id="%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8%E6%AF%94%E8%BE%83">基于比较器比较</h3> 
<p>用户自定义比较器类，需要实现Comparator接口：</p> 
<div> 
 <pre><code class="language-java">public interface Comparator&lt;T&gt; {
// 返回值:
// &lt; 0: 表示 o1 指向的对象小于 o2 指向的对象
// == 0: 表示 o1 指向的对象等于 o2 指向的对象
// &gt; 0: 表示 o1 指向的对象等于 o2 指向的对象
int compare(T o1, T o2);
}</code></pre> 
</div> 
<p>这里要注意区分Comparable和Comparator接口</p> 
<p>在自定义比较器类中重写compare方法：</p> 
<div> 
 <pre><code class="language-java">import java.util.Comparator;
class Card {
public int rank; // 数值
public String suit; // 花色
public Card(int rank, String suit) {
this.rank = rank;
this.suit = suit;
}
}
class CardComparator implements Comparator&lt;Card&gt; {
// 根据数值比较，不管花色
// 这里我们认为 null 是最小的
@Override
public int compare(Card o1, Card o2) {
if (o1 == o2) {
return 0;
} if
(o1 == null) {
return -1;
}
if (o2 == null) {
return 1;
} 
return o1.rank - o2.rank;
}
public static void main(String[] args){
Card p = new Card(1, "♠");
Card q = new Card(2, "♠");
Card o = new Card(1, "♠");
// 定义比较器对象
CardComparator cmptor = new CardComparator();
// 使用比较器对象进行比较
System.out.println(cmptor.compare(p, o)); // == 0，表示牌相等
System.out.println(cmptor.compare(p, q)); // &lt; 0，表示 p 比较小
System.out.println(cmptor.compare(q, p)); // &gt; 0，表示 q 比较大
}
}</code></pre> 
</div> 
<p>这里使用Comparator需要导入java.util包</p> 
<h2 id="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%ADpriorityQueue%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F">集合框架中priorityQueue的比较方式</h2> 
<p>集合框架中的PriorityQueue底层使用堆结构，因此其内部的元素必须要能够比大小PriorityQueue采用了：<strong>Comparble和Comparator两种方式。</strong> </p> 
<p>1. Comparble是默认的内部比较方式，如果用户插入自定义类型对象时，该类对象必须要实现Comparble接口，并覆写compareTo方法</p> 
<p>2. 用户也可以选择使用比较器对象，如果用户插入自定义类型对象时，必须要提供一个比较器类，让该类实现Comparator接口并覆写compare方法。 </p> 
<p><strong>JDK中的源码：</strong></p> 
<div> 
 <pre><code class="language-java">
// 用户如果没有提供比较器对象，使用默认的内部比较，将comparator置为null
public PriorityQueue() {
this(DEFAULT_INITIAL_CAPACITY, null);
} 
// 如果用户提供了比较器，采用用户提供的比较器进行比较
public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) {
// Note: This restriction of at least one is not actually needed,
// but continues for 1.5 compatibility
if (initialCapacity &lt; 1)
throw new IllegalArgumentException();
this.queue = new Object[initialCapacity];
this.comparator = comparator;
}
private void siftUp(int k, E x) {
        if (comparator != null)
            siftUpUsingComparator(k, x);
        else
            siftUpComparable(k, x);
    }
private void siftUpComparable(int k, E x) {
        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;
        while (k &gt; 0) {
            int parent = (k - 1) &gt;&gt;&gt; 1;
            Object e = queue[parent];
            if (key.compareTo((E) e) &gt;= 0)
                break;
            queue[k] = e;
            k = parent;
        }
        queue[k] = key;
    }

    @SuppressWarnings("unchecked")
    private void siftUpUsingComparator(int k, E x) {
        while (k &gt; 0) {
            int parent = (k - 1) &gt;&gt;&gt; 1;
            Object e = queue[parent];
            if (comparator.compare(x, (E) e) &gt;= 0)
                break;
            queue[k] = e;
            k = parent;
        }
        queue[k] = x;
    }</code></pre> 
</div> 
<p><strong>画图分析：</strong></p> 
<p><img alt="" height="727" src="https://images2.imgbox.com/48/d7/iU25WRMO_o.png" width="1200">​</p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/37ea205afdf743d93ed9eb0f7a5d0d57/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">超详细 | 差分进化算法原理及其实现(Matlab/Python)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e41cad4f14b2aea5e0f12d36cef46bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】String类对象的创建与字符串常量池的“神秘交易”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>