<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>弗洛伊德(Floyd)算法（C/C&#43;&#43;) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dd14da6f616ede0efc1fdaff233bad96/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="弗洛伊德(Floyd)算法（C/C&#43;&#43;)">
  <meta property="og:description" content="弗洛伊德算法（Floyd&#39;s algorithm），又称为弗洛伊德-沃尔什算法（Floyd-Warshall algorithm），是一种用于在加权图中找到所有顶点对之间最短路径的算法。这个算法适用于有向图和无向图，并且可以处理负权重边，但不能处理负权重循环。
弗洛伊德算法（Floyd-Warshall Algorithm）是一种用于计算图中所有顶点对之间最短路径的动态规划算法。本文将详细介绍弗洛伊德算法的原理，并提供一个C&#43;&#43;实现的示例，以帮助读者理解算法的工作原理和编程技巧。
算法原理 弗洛伊德算法的核心思想是通过逐步寻找并更新所有顶点对之间的最短路径来解决问题。算法使用一个距离矩阵来存储顶点之间的距离，并在每一步中考虑通过一个新的中间顶点来更新这些距离。跟上一篇Dijkstra算法一样的原理，也是通过中转点去更新最短距离。不过Floyd算法处理的是多源的最短路问题。
算法步骤 初始化一个距离矩阵，其中dist[i][j]表示顶点i到顶点j的直接距离。如果i和j不直接相连，则dist[i][j]为无穷大。对于每个顶点k，作为中间顶点，更新dist[i][j]为min(dist[i][j], dist[i][k] &#43; dist[k][j])。 Floyd是经典三重for循环，所以它的时间复杂度为o(n^3)，n是图中顶点的数量。第一层遍历中转点，第二层遍历起点，第三层遍历终点，对于图中点的数量多的情况，Floyd算法的时间复杂度是很高的。
图解算法： 下面我们将以4个点的图进行讲解，图的连边为有向边和无向边的结合。以邻接矩阵的方式进行存储，如果大家喜欢用邻接表存储，也可以使用邻接表，下面介绍两个矩阵，矩阵A表示（i，j）i-&gt;j的最短距离，初始化为inf。矩阵B表示i-&gt;j路径由i到j的中转点，也就是路径上除去起点的第一个点，初始化为-1。
初始： 按照图中的点距离给其赋值，A矩阵i-&gt;i距离都为0，inf为无法到达。B矩阵初始为-1。
第一步： 我们选取一个点（按照顺序选取）把它作为中转点，看看以它为中转点，所能到达的点中有没有产生更小的距离，如果产生了，则更新A矩阵的距离，更新B矩阵的中转点。我们先选取1号点，那么位于1号点的行跟列的值都是不可能变化的，还有就是自己到自己的点也是不会变化的永远是0，图中黄颜色标记的是此步不会改变的点，其他的可能会变。在更新距离的时候我们可以不看图就能更新矩阵，例如下图中2号点到3号点本来为10，我们可以连一个矩阵，以1号点画的两条蓝线为两条边，红色线为剩余2边，我们既然把1号点当作中转点，路径必然为2-1-3，此时距离就是副对角线的顶点值相加2&#43;6=8&lt;10，那么通过1号点绕路的方式距离更短。类似的还有3-&gt;2号点，6&#43;2=8&lt;inf。3-&gt;4号点，10&#43;6=16&lt;inf。4-&gt;3号点，10&#43;6=16&lt;inf。顺便把B矩阵更新完。
更新完后（红色标记为变化的值）： 第二步： 此时把2号结点作为中转结点，看一看能够更新哪一个最短路径，还是跟上一步一样直接看图更新就可以。如下图，4-&gt;1号点，2&#43;4=6&lt;10。1-&gt;4号点，2&#43;4=6&lt;10。3-&gt;4号点，8&#43;4=12&lt;16。4-&gt;3号点，8&#43;4=12&lt;16。对于一些不能更新的值，例如1-&gt;3号点，2&#43;8=10&gt;6，这样的则不能更新。
对于B矩阵，要注意3-&gt;4跟4-&gt;3的路径是相反的，更新是则不能直接修改为2，对于3-&gt;4号点第一个中转点还是1号点。更新完后（红色标记为变化的值）： 第三步： 把3号点作为中转结点，跟前几步一样，继续寻找最短距离。经过更新我们发现3号点作为中转点不能更新任意一个距离，所以A、B矩阵不需要更新。在图中，经过验证我们发现3号点中转距离反而变大，所以不更新。
第四步： 把4号点作为中转点，继续更新最短距离。我们发现跟3号点一样，不能更新任何距离，在A矩阵中除了黄色的点之外，所能连起来的矩形，主对角线顶点值相加都比当前值要大。在图中也可以验证，所以不给予更新。
这样我们就更新完所有点，把所有点都当作中转点更新完一遍，这样就完成了Floyd算法，更新时每次按照顺序把点当作中转点，遍历寻找路径的起点，再遍历寻找终点，算法时间复杂度为o(n^3)。
视频讲解可以看一下B站这位UP主的讲解，点击直达
算法实现： 以下是弗洛伊德算法的C&#43;&#43;实现示例：
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;limits&gt; using namespace std; // 定义图的顶点数 const int N = 100; // 定义无穷大的初始距离 const int INF = numeric_limits&lt;int&gt;::max(); // 弗洛伊德算法的实现 void floydWarshall(vector&lt;vector&lt;int&gt;&gt;&amp; dist) { int n = dist.size(); // 遍历所有顶点作为中间顶点 for (int k = 0; k &lt; n; k&#43;&#43;) { // 遍历所有顶点作为起点 for (int i = 0; i &lt; n; i&#43;&#43;) { // 遍历所有顶点作为终点 for (int j = 0; j &lt; n; j&#43;&#43;) { // 如果通过顶点k可以找到更短的路径，则更新dist[i][j] if (dist[i][k] !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-28T15:18:54+08:00">
    <meta property="article:modified_time" content="2024-08-28T15:18:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">弗洛伊德(Floyd)算法（C/C&#43;&#43;)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>弗洛伊德算法（Floyd's algorithm）</strong>，又称为弗洛伊德-沃尔什算法（Floyd-Warshall algorithm），是一种用于在加权图中找到所有顶点对之间<strong>最短路径的算法</strong>。这个算法适用于<strong>有向图和无向图</strong>，并且可以处理负权重边，但不能处理负权重循环。</p> 
<p>弗洛伊德算法（Floyd-Warshall Algorithm）是一种用于计算图中所有顶点对之间最短路径的<strong>动态规划算法</strong>。本文将详细介绍弗洛伊德算法的原理，并提供一个C++实现的示例，以帮助读者理解算法的工作原理和编程技巧。</p> 
<p style="text-align:center;"><img alt="" height="88" src="https://images2.imgbox.com/d0/13/v6TFP4S7_o.gif" width="704"></p> 
<h4>算法原理</h4> 
<p>弗洛伊德算法的<strong>核心思想</strong>是通过逐步寻找并更新所有顶点对之间的最短路径来解决问题。算法使用一个距离矩阵来存储顶点之间的距离，并在每一步中考虑通过一个新的中间顶点来更新这些距离。跟上一篇Dijkstra算法一样的原理，也是通过中转点去更新最短距离。不过Floyd算法处理的是<strong>多源的最短路问题</strong>。</p> 
<hr> 
<h4>算法步骤</h4> 
<ol><li>初始化一个距离矩阵，其中<code>dist[i][j]</code>表示顶点<code>i</code>到顶点<code>j</code>的直接距离。如果<code>i</code>和<code>j</code>不直接相连，则<code>dist[i][j]</code>为无穷大。</li><li>对于每个顶点<code>k</code>，作为中间顶点，更新<code>dist[i][j]</code>为<code>min(dist[i][j], dist[i][k] + dist[k][j])</code>。</li></ol> 
<p>Floyd是经典三重for循环，所以它的时间复杂度为o(n^3)，n是图中顶点的数量。第一层遍历中转点，第二层遍历起点，第三层遍历终点，对于图中点的数量多的情况，Floyd算法的时间复杂度是很高的。</p> 
<h4>图解算法：</h4> 
<p>下面我们将以4个点的图进行讲解，图的连边为有向边和无向边的结合。以邻接矩阵的方式进行存储，如果大家喜欢用邻接表存储，也可以使用邻接表，下面介绍两个矩阵，<strong>矩阵A</strong>表示（i，j）i-&gt;j的最短距离，初始化为inf。<strong>矩阵B</strong>表示i-&gt;j路径由i到j的中转点，也就是路径上除去起点的第一个点，初始化为-1。</p> 
<h5>初始：</h5> 
<p>按照图中的点距离给其赋值，A矩阵i-&gt;i距离都为0，inf为无法到达。B矩阵初始为-1。</p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/6a/51/VmWR7n0N_o.png" width="992"></p> 
<h5>第一步：</h5> 
<p>我们选取一个点（按照顺序选取）把它作为中转点，看看以它为中转点，所能到达的点中有没有产生更小的距离，如果产生了，则更新A矩阵的距离，更新B矩阵的中转点。我们先选取1号点，那么位于1号点的行跟列的值都是不可能变化的，还有就是自己到自己的点也是不会变化的永远是0，图中黄颜色标记的是此步不会改变的点，其他的可能会变。在更新距离的时候我们可以不看图就能更新矩阵，例如下图中2号点到3号点本来为10，我们可以连一个矩阵，以1号点画的两条蓝线为两条边，红色线为剩余2边，我们既然把1号点当作中转点，路径必然为2-1-3，此时距离就是副对角线的顶点值相加2+6=8&lt;10，那么通过1号点绕路的方式距离更短。类似的还有3-&gt;2号点，6+2=8&lt;inf。3-&gt;4号点，10+6=16&lt;inf。4-&gt;3号点，10+6=16&lt;inf。顺便把B矩阵更新完。</p> 
<p class="img-center"><img alt="" height="320" src="https://images2.imgbox.com/99/a5/uWD0LSL3_o.png" width="364"></p> 
<p>更新完后（红色标记为变化的值）： </p> 
<p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/20/4c/yV4K9Y9L_o.png" width="1003"></p> 
<h5> 第二步：</h5> 
<p>此时把2号结点作为中转结点，看一看能够更新哪一个最短路径，还是跟上一步一样直接看图更新就可以。如下图，4-&gt;1号点，2+4=6&lt;10。1-&gt;4号点，2+4=6&lt;10。3-&gt;4号点，8+4=12&lt;16。4-&gt;3号点，8+4=12&lt;16。对于一些不能更新的值，例如1-&gt;3号点，2+8=10&gt;6，这样的则不能更新。</p> 
<p class="img-center"><img alt="" height="322" src="https://images2.imgbox.com/c2/40/OyZLIAAh_o.png" width="355"></p> 
<p>对于B矩阵，要注意3-&gt;4跟4-&gt;3的路径是相反的，更新是则不能直接修改为2，对于3-&gt;4号点第一个中转点还是1号点。更新完后（红色标记为变化的值）： </p> 
<p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/6b/de/DijFNvdp_o.png" width="997"></p> 
<h5>第三步：</h5> 
<p>把3号点作为中转结点，跟前几步一样，继续寻找最短距离。经过更新我们发现3号点作为中转点不能更新任意一个距离，所以A、B矩阵不需要更新。在图中，经过验证我们发现3号点中转距离反而变大，所以不更新。</p> 
<p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/72/6b/TLEU781k_o.png" width="991"></p> 
<h5>第四步：</h5> 
<p>把4号点作为中转点，继续更新最短距离。我们发现跟3号点一样，不能更新任何距离，在A矩阵中除了黄色的点之外，所能连起来的矩形，主对角线顶点值相加都比当前值要大。在图中也可以验证，所以不给予更新。</p> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/67/47/sWjBMzyK_o.png" width="999"></p> 
<p>这样我们就更新完所有点，把所有点都当作中转点更新完一遍，这样就完成了Floyd算法，更新时每次按照顺序把点当作中转点，遍历寻找路径的起点，再遍历寻找终点，算法时间复杂度为o(n^3)。</p> 
<p>视频讲解可以看一下B站这位UP主的讲解，<a class="link-info" href="https://www.bilibili.com/video/BV1tQ4y147pw/?spm_id_from=333.1007.top_right_bar_window_history.content.click" rel="nofollow" title="点击直达">点击直达</a></p> 
<hr> 
<h4>算法实现：</h4> 
<p>以下是弗洛伊德算法的C++实现示例：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;limits&gt;
using namespace std;

// 定义图的顶点数
const int N = 100;
// 定义无穷大的初始距离
const int INF = numeric_limits&lt;int&gt;::max();

// 弗洛伊德算法的实现
void floydWarshall(vector&lt;vector&lt;int&gt;&gt;&amp; dist) {
    int n = dist.size();
    // 遍历所有顶点作为中间顶点
    for (int k = 0; k &lt; n; k++) {
        // 遍历所有顶点作为起点
        for (int i = 0; i &lt; n; i++) {
            // 遍历所有顶点作为终点
            for (int j = 0; j &lt; n; j++) {
                // 如果通过顶点k可以找到更短的路径，则更新dist[i][j]
                if (dist[i][k] != INF &amp;&amp; dist[k][j] != INF &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
}

int main() {
    int n; // 顶点的数量
    cin &gt;&gt; n;

    vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n, INF)); // 初始化距离矩阵

    // 读取邻接矩阵
    for (int i = 0; i &lt; n; i++) {
        dist[i][i] = 0; // 自己到自己的距离是0
        for (int j = i; j &lt; n; j++) {
            int w;
            cin &gt;&gt; w;
            dist[i][j] = w;
            dist[j][i] = w; // 如果是无向图，需要设置对称的权重
        }
    }

    // 执行弗洛伊德算法
    floydWarshall(dist);

    // 打印所有顶点对之间的最短路径
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (dist[i][j] == INF) {
                cout &lt;&lt; "INF" &lt;&lt; " ";
            } else {
                cout &lt;&lt; dist[i][j] &lt;&lt; " ";
            }
        }
        cout &lt;&lt; endl;
    }

    return 0;
}</code></pre> 
<hr> 
<h4>Floyd与Dijkstra算法比较 </h4> 
<p>迪杰斯特拉算法（Dijkstra's algorithm）和弗洛伊德算法（Floyd-Warshall algorithm）都是图论中用于计算图中最短路径的著名算法。它们在某些方面有相似之处，但在设计和应用上存在显著差异，下面我们将对这两种算法的相同跟不同进行解释。</p> 
<h5>相同点：</h5> 
<ol><li><strong>目的</strong>：<span style="color:#0d0016;">两者都旨在解决最短路径问题。</span></li><li><strong>适用性</strong>：它们都可以用于加权图中的最短路径计算，无论是正权还是负权（只有弗洛伊德算法）。</li></ol> 
<h5>不同点：</h5> 
<ol><li> <h6>问题范围：</h6> 
  <ul><li><strong>迪杰斯特拉算法</strong>：主要用于单元路径的最短路问题，即从单一源点到所有其他顶点的最短路径。</li><li><strong>弗洛伊德算法</strong>：解决的是所有顶点对之间的最短路径问题，即计算图中每一对顶点之间的最短路径。</li></ul></li><li> <h6>时间复杂度：</h6> 
  <ul><li><strong>迪杰斯特拉算法</strong>：具有较高的效率，时间复杂度为O(V^2)（使用朴素实现）或O((V+E) log V)（使用优先队列优化）。（V顶点E条边）</li><li><strong>弗洛伊德算法</strong>：时间复杂度为O(V^3)，因为它需要计算所有顶点对的最短路径。</li></ul></li><li> <h6>实现方式：</h6> 
  <ul><li><strong>迪杰斯特拉算法</strong>：通常使用贪心策略，从一个顶点开始，逐步扩展到邻接顶点，直到找到所有顶点的最短路径。</li><li><strong>弗洛伊德算法</strong>：使用动态规划，通过三层循环迭代地改进路径长度，直到达到最优解。</li></ul></li><li> <h6>对负权边的处理：</h6> 
  <ul><li><strong>迪杰斯特拉算法</strong>：不能处理负权边，因为负权边会破坏算法的贪心选择性质。</li><li><strong>弗洛伊德算法</strong>：可以处理负权边，但图中不能有负权环，否则最短路径问题没有解。</li></ul></li><li> <h6>初始化：</h6> 
  <ul><li><strong>迪杰斯特拉算法</strong>：从源点到其他所有顶点的距离初始化为无穷大，源点到自身的距离为0。</li><li><strong>弗洛伊德算法</strong>：所有顶点到自身的距离初始化为0，其他顶点间的距离初始化为边的权重或无穷大（如果无直接连接）。</li></ul></li></ol> 
<hr> 
<p>本篇详解Floyd算法，如果想看Dijkstra算法的话，可以看博主上一篇博客，针对于Dijkstra算法的详解：<a href="https://blog.csdn.net/m0_73633807/article/details/141271579?spm=1001.2014.3001.5501" title="迪杰斯特拉(Dijkstra)算法（C/C++)-CSDN博客">迪杰斯特拉(Dijkstra)算法（C/C++)-CSDN博客</a></p> 
<p>执笔至此，感触彼多，全文将至，落笔为终，感谢大家的支持。  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c9d0ff7199a30a112d05fd90718c100/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是 AWS CloudWatch？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6cfe050de185c5fe42d265874bd34903/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是美颜SDK？视频美颜API集成与优化技术探索</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>