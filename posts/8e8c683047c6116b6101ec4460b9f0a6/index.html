<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>华为23年笔试题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8e8c683047c6116b6101ec4460b9f0a6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="华为23年笔试题">
  <meta property="og:description" content="消息传输
题目描述 在给定的 m x n (1 &lt;= m, n &lt;= 1000) 网格地图 grid 中，分布着一些信号塔，用于区域间通信。
每个单元格可以有以下三种状态： 值 0 代表空地，无法传递信号； 值 1 代表信号塔 A，在收到消息后，信号塔 A 可以在 1ms 后将信号发送给上下左右四个方向的信号塔；
值 2 代表信号塔 B，在收到消息后，信号塔 B 可以在 2ms 后将信号发送给上下左右四个方向的信号塔。
给定一个坐标 (j, k)，输入保证坐标 (j, k) 位置一定有信号塔。在坐标 (j, k) 位置的信号塔触发一个信号。 要求返回网格地图中所有信号塔收到信号的最短时间，单位为 ms。如果有信号塔无法收到信号，则返回 -1。
输入描述 第一行：网格的列数 n。 第二行：网格的行数 m。 第三行：触发信号的信号塔坐标 (j, k)。 接下来的 m 行：每行包含 n 个整数，表示该行网格中每个位置的信号塔安装信息（通过空格间隔每个状态值）。
输出描述 输出返回 网格地图中所有信号塔收到信号的最小时间，单位为ms。如果不可能，返回-1。
输入示例 3 3 1 0 0 1 2 1 2 1 0 1 2 输出示例 4 思路:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-07T17:43:58+08:00">
    <meta property="article:modified_time" content="2024-09-07T17:43:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">华为23年笔试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>消息传输</p> 
<h6>题目描述</h6> 
<p>在给定的 m x n (1 &lt;= m, n &lt;= 1000) 网格地图 grid 中，分布着一些信号塔，用于区域间通信。</p> 
<p></p> 
<p>每个单元格可以有以下三种状态： </p> 
<p>值 0 代表空地，无法传递信号； </p> 
<p>值 1 代表信号塔 A，在收到消息后，信号塔 A 可以在 1ms 后将信号发送给上下左右四个方向的信号塔；</p> 
<p>值 2 代表信号塔 B，在收到消息后，信号塔 B 可以在 2ms 后将信号发送给上下左右四个方向的信号塔。</p> 
<p></p> 
<p>给定一个坐标 (j, k)，输入保证坐标 (j, k) 位置一定有信号塔。在坐标 (j, k) 位置的信号塔触发一个信号。 </p> 
<p></p> 
<p>要求返回网格地图中所有信号塔收到信号的最短时间，单位为 ms。如果有信号塔无法收到信号，则返回 -1。</p> 
<h6>输入描述</h6> 
<p>第一行：网格的列数 n。 </p> 
<p>第二行：网格的行数 m。 </p> 
<p>第三行：触发信号的信号塔坐标 (j, k)。 </p> 
<p>接下来的 m 行：每行包含 n 个整数，表示该行网格中每个位置的信号塔安装信息（通过空格间隔每个状态值）。</p> 
<h6>输出描述</h6> 
<p>输出返回 网格地图中所有信号塔收到信号的最小时间，单位为ms。如果不可能，返回-1。</p> 
<h6>输入示例</h6> 
<pre><code>3
3
1 0
0 1 2
1 2 1
0 1 2</code></pre> 
<h6>输出示例</h6> 
<pre><code>4</code></pre> 
<p>思路:</p> 
<p>本题我使用的是bfs,time[][]记录每个位置消息到达时间,当前结点的周围基站的<strong>旧的消息</strong>到达时间大于使用当前结点传播的新的消息到达时间时或者周围基站还<strong>没被传播</strong>过消息就把这些满足要求的基站<strong>加入到队列</strong>,并<strong>更新</strong>这些基站的传播时间,借此题复习bfs</p> 
<p>bfs模板:</p> 
<pre><code class="hljs">int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) {
    queue&lt;pair&lt;int, int&gt;&gt; que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair&lt;int ,int&gt; cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i &lt; 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}</code></pre> 
<p>当前题目代码:</p> 
<pre><code class="hljs">
import java.util.*;

class Main {
    static int[][] go = {<!-- -->{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();//列数
        int m = in.nextInt();//行数
    
        int[][] map = new int[m][n];//记录基站位置关系
        int  [][] time = new int[m][n];//-1:没访问 记录到每个结点的最短时间
       for(int i=0;i&lt;time.length;i++){
    Arrays.fill(time[i],-1);
}
        //起始信号塔的横纵坐标
        int x = in.nextInt();
        int y = in.nextInt();
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                int c = in.nextInt();
                map[i][j] = c;
            }
        }

        int s = bfs(map, time, x, y);
        System.out.println(s);
    }

    static int bfs(int[][] map, int[][] time, int x, int y) {
        int max_time = 0;//记录时间
        List&lt;int[]&gt; queue = new LinkedList&lt;&gt;();//定义队列记录坐标
        queue.add(new int[]{x, y});//起始结点加入队列
        time[x][y] = 0;       // 只要加入队列，立刻标记为访问过的节点
        while (!queue.isEmpty()) { // 开始遍历队列里的元素
          //从队列取出元素
            int[] ints =  queue.remove(0);
            int curx = ints[0];
            int cury = ints[1]; //获得当前位置的坐标
            //查询当前基站的传播效率
          int delay= map[curx][cury];
            // 开始向当前节点的四个方向左右上下去遍历
            for (int i = 0; i &lt; go.length; i++) {
                //获得周围结点
                int nextX = curx + go[i][0];
                int nexty = cury + go[i][1];
               // 如果相邻信号塔尚未接收到信号||或者他们应该更早接收到，更新它们的接收时间（当前信号塔的接收时间 + 相邻信号塔的传播延迟），并将它们加入队列。
                if (nextX &lt; 0 || nextX &gt;= map.length || nexty &lt; 0 || nexty &gt;= map[0].length || map[nextX][nexty] == 0) {
                    continue;
                }
                //周围结点的时间
                   int newtime=delay+time[curx][cury];
                if(time[nextX][nexty]==-1||newtime&lt;time[nextX][nexty]){
                    time[nextX][nexty]=newtime;
                    queue.add(new int[]{nextX,nexty});
            
                }

            }

        }
        //bfs结束,查看有没有基站没被访问
        for (int i = 0; i &lt; map.length; i++) {
            for (int j = 0; j &lt; map[i].length; j++) {
                if(map[i][j]&gt;0&amp;&amp;time[i][j]==-1){
                    return -1;
                }
                max_time=Integer.max(max_time,time[i][j]);
            }
        }
      return max_time;
    }


}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b5d8798c736882a528dcd5ddbe84ec8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法【Java】 —— 前缀和</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9219b93aaddef16f12d166b87f2e4de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">力扣 739. 每日温度【经典单调栈题目】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>