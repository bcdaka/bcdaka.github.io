<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Springboot和SpringMVC - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9d4117e28efb39f1cd4fcd140c500a09/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Springboot和SpringMVC">
  <meta property="og:description" content="1.搭建maven Spring直译就是春天的意思，那就是说，有了框架之后就有了春天，是咱们程序员的春天，在以前想要做一个程序，可能需要半年的周期，但是有了框架之后，可能只需要两三个月的时间，大大缩短了开发周期，所以很好用，但是刚开始的时候，想要建立框架就要配置xml文件，但是配置xml文件非常的严格需要有严格的程序，很麻烦，所以现在有了springboot，springboot想要建立框架，需要有jar包，但是还有一个问题是，jar包版本会影响搭建框架，所以要有maven来帮助我们，这样就可以并帮助我们快速的建立一个框架。
下面我们开始建立启动类 直接新建项目，新建项目的时候左边选择new project，右边起好项目名字，语言选择java，Build system选择Maven就可以了，
建好项目之后找settings，在settings里面搜索maven ，路径path选择到bin目录之前的文件夹（这个文件是maven文件，需要下载），第一个需要override覆盖，点一下对号之后选择settings配置文件，直接apply然后ok这样就搭建好了环境
在pom.xml文件中加上jar包，可以从网上找然后刷新一下maven就可以了
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt; &lt;/dependency&gt; 这里用的是下面这个，可以从里面挑选一个使用人多的版本 在java文件夹下面建包，在包下建立一个Application 类，这个类就是启动类，但是需要在类前面加上注解：@SpringBootApplication，在main方法里面写上SpringApplication.run(EasySpringBootAAppliction.class,args);
现在这个Application类就是启动类，只要启动这个类，整个项目就会启动
2.IOC控制反转 java类的对象 //在项目运行阶段，项目需要很多对象完成整体业务 // Springboot提供了很多注解（@Repository（数据访问层），@Controller，@Bean，@Component（其他功能类），@Service(业务类),@RestController（访问层）），让Spring管理这些类的对象的生命周期 //Spring提供了ioc（控制反转）的方式方便获取该对象， //容器和代码之间的控制权反转了，代码中不需要明文获取或者调用方法来得到对象，只需要声明该类需要什么类型的对象即可（标注注解） @Service和RestController不同不能替代，想要进入浏览器只能用后者，前者不可以
@Autowired 在框架之前，如果我们想要获取一个对象，那我们需要手动获取，而且只有在执行到我们的代码的时候才会获取到，但是SpringbootICO就可以完成反转，只要你声明好了需要获取什么类型的对象就可以了，Springboot会给予这个类型的对象，只需要下面这样声明一下就可以了需要有一个@Autowired注解，就会给予这个类型的easys对象，
@Autowired EasyService easys; @ RequestMapping @RequestMapping这个注解是要与前台进行交互，有了这个注解之后在注解后边加上（&#34;名称&#34;），就可以在浏览器使用http://localhost/8080/名称就可以看到执行的结果；
@RestController public class EasyController { //该类中需要EasyService类的对象 //就可以在这个类中只需要声明依赖EasyService这个类就可以，不需要通过代码主动获取EasyService类的对象 //然后只需要一个注解aotuwired //通过识别依赖关系，依赖注入（DI）对应的对象 @Autowired EasyService easys; @Autowired TestA testa; @RequestMapping(&#34;testb&#34;) public String testB(){ testa.test(); return &#34;Easy method&#34;; }} 另外一个类： @Component public class TestA { public void test(){ System.out.println(this); System.out.println(&#34;test method&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-01T20:47:53+08:00">
    <meta property="article:modified_time" content="2024-08-01T20:47:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Springboot和SpringMVC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.搭建maven</h2> 
<p>Spring直译就是春天的意思，那就是说，有了框架之后就有了春天，是咱们程序员的春天，在以前想要做一个程序，可能需要半年的周期，但是有了框架之后，可能只需要两三个月的时间，大大缩短了开发周期，所以很好用，但是刚开始的时候，想要建立框架就要配置xml文件，但是配置xml文件非常的严格需要有严格的程序，很麻烦，所以现在有了springboot，springboot想要建立框架，需要有jar包，但是还有一个问题是，jar包版本会影响搭建框架，所以要有maven来帮助我们，这样就可以并帮助我们快速的建立一个框架。<img alt="" height="795" src="https://images2.imgbox.com/79/41/MaURylaq_o.png" width="1200"></p> 
<h3> 下面我们开始建立启动类</h3> 
<p>直接新建项目，新建项目的时候左边选择new project，右边起好项目名字，语言选择java，Build system选择Maven就可以了，</p> 
<p><img alt="" height="670" src="https://images2.imgbox.com/32/2f/fPUAYn9H_o.png" width="978"></p> 
<p>建好项目之后找settings，在settings里面搜索maven ，路径path选择到bin目录之前的文件夹（这个文件是maven文件，需要下载），第一个需要override覆盖，点一下对号之后选择settings配置文件，直接apply然后ok这样就搭建好了环境</p> 
<p><img alt="" height="902" src="https://images2.imgbox.com/67/a3/BNDUHHzX_o.png" width="1200"></p> 
<p>在pom.xml文件中加上jar包，可以从网上找然后刷新一下maven就可以了</p> 
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;version&gt;2.6.6&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<p>这里用的是下面这个，可以从里面挑选一个使用人多的版本 </p> 
<p><img alt="" height="566" src="https://images2.imgbox.com/23/9b/p76wrGV5_o.png" width="1028"></p> 
<p>在java文件夹下面建包，在包下建立一个Application 类，这个类就是启动类，但是需要在类前面加上注解：@SpringBootApplication，在main方法里面写上SpringApplication.run(EasySpringBootAAppliction.class,args);</p> 
<p>现在这个Application类就是启动类，只要启动这个类，整个项目就会启动</p> 
<h2>2.IOC控制反转</h2> 
<pre>java类的对象
//在项目运行阶段，项目需要很多对象完成整体业务
// Springboot提供了很多注解（@Repository（数据访问层），@Controller，@Bean，@Component（其他功能类），@Service(业务类),@RestController（访问层）），让Spring管理这些类的对象的生命周期
//Spring提供了ioc（控制反转）的方式方便获取该对象，
//容器和代码之间的控制权反转了，代码中不需要明文获取或者调用方法来得到对象，只需要声明该类需要什么类型的对象即可（标注注解）</pre> 
<p>@Service和RestController不同不能替代，想要进入浏览器只能用后者，前者不可以</p> 
<h3>@Autowired</h3> 
<p>在框架之前，如果我们想要获取一个对象，那我们需要手动获取，而且只有在执行到我们的代码的时候才会获取到，但是SpringbootICO就可以完成反转，只要你声明好了需要获取什么类型的对象就可以了，Springboot会给予这个类型的对象，只需要下面这样声明一下就可以了需要有一个@Autowired注解，就会给予这个类型的easys对象，</p> 
<pre><code>    @Autowired
    EasyService easys;</code></pre> 
<h3>@ RequestMapping</h3> 
<p>@RequestMapping这个注解是要与前台进行交互，有了这个注解之后在注解后边加上（"名称"），就可以在浏览器使用http://localhost/8080/名称就可以看到执行的结果；</p> 
<pre><code>@RestController
public class EasyController {
    //该类中需要EasyService类的对象
    //就可以在这个类中只需要声明依赖EasyService这个类就可以，不需要通过代码主动获取EasyService类的对象
    //然后只需要一个注解aotuwired
    //通过识别依赖关系，依赖注入（DI）对应的对象

    @Autowired
    EasyService easys;
    @Autowired
    TestA testa;
    @RequestMapping("testb")
    public  String testB(){
        testa.test();
        return "Easy method";
    }}




另外一个类：  @Component

public class TestA {
 public void test(){
        System.out.println(this);
        System.out.println("test method");
    }
}
</code></pre> 
<p> 在浏览器上会有Easy method，在控制台上会有这个对象，和输出了test method</p> 
<h2>@Bean</h2> 
<p>不能单独使用，要和@Configuration一起使用，这样可以把返回的对象加入到Springbean容器里面，方法名就是bean对象的名字</p> 
<pre><code>@Configuration
public class EasyConfig {
    @Bean(initMethod = "init")         //里面会有一个方法，
    //@Scope("prototype")
    public EasyBean easyBean(){

        return new EasyBean();
    }
}
</code></pre> 
<h2>@Configuration</h2> 
<p>表示这个类就是一个配置类</p> 
<p></p> 
<h2>spring bean的周期</h2> 
<p>Bean生命周期<br>     1）根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean。<br>     2）利用依赖注入完成 Bean 中所有属性值的配置注入。<br>     3) 如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。<br>     4）如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。<br>     5) 当一个 Bean 实现了 ApplicationContextAware 接口并在 Spring 容器中被实例化时，Spring 容器会自动调用该 Bean 的 setApplicationContext 方法，并将应用程序上下文ApplicationContext作为参数传递进来<br>     6）BeanPostProcessor 是 Spring 框架中的一个重要接口，它允许开发者在 Spring 容器创建和初始化 bean 的过程中，对 bean 进行自定义处理。这包括在 bean 实例化之后、属性设置之前（postProcessBeforeInitialization 方法），以及在 bean 初始化之后（postProcessAfterInitialization 方法）执行自定义逻辑</p> 
<p>Spring 容器在创建和初始化每一个 bean 时，都会调用 CustomBeanPostProcessor 中的这两个方法，允许你进行自定义处理<br>         在这一步执行的是postProcessBeforeInitialization方法 <br>     7）InitializingBean 是 Spring 框架中的一个接口，它定义了一个 afterPropertiesSet 方法。当 Spring 容器创建 bean 的所有属性都被设置完成后，会调用这个方法。<br>     8）如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。<br>         initMethod指定的方法必须是void类型，并且不接受任何参数<br>     9）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。<br>     10）如果在 &lt;bean&gt; 中指定了该 Bean 的作用范围为 scope="singleton"，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在 &lt;bean&gt; 中指定了该 Bean 的作用范围为 scope="prototype"，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。<br>         @Scope(scopeName =ConfigurableBeanFactory.SCOPE_PROTOTYPE )<br>         @Scope(scopeName =ConfigurableBeanFactory.SCOPE_SINGLETON)<br>     11）如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</p> 
<pre><code>@Component("easybean")
public class EasyBean implements BeanNameAware, BeanFactoryAware, ApplicationContextAware, InitializingBean, DisposableBean {
    public void init(){
        System.out.println("init method");
    }
    public EasyBean(){
        System.out.println("构造方法");
    }
    TestA testa;
    @Autowired
    public void setTesta(TestA testa){
        System.out.println("注入属性");
        this.testa=testa;
    }

    public void setBeanName(String name) {

    System.out.println("bean   接口的    beanname方法"+name);
    }
    
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        System.out.println("5.-------ApplicationContext接口的setApplicationContext方法"+applicationContext);
    }
//分别在创建对象
    
    public void afterPropertiesSet() throws Exception {
        System.out.println("10.     属性设置完毕");
    }
    
    public void destroy() throws Exception {
        System.out.println("11   回收销毁");
    }
    
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println("4.工厂"+beanFactory);
    }
}




@Component
public class Easy implements BeanPostProcessor {


//    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
//
//
//        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);
//    }
//
//    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
//
//
//        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);
//    }
}
</code></pre> 
<h2><br>     了解springbean生命周期的必要性</h2> 
<p><br>         pring Bean的生命周期定义了从bean的创建、初始化到销毁的一系列过程，以及在这些过程中Spring容器如何与bean进行交互<br>             自定义初始化逻辑：<br>                 通过了解Spring Bean的生命周期，你可以知道何时是执行自定义初始化逻辑的最佳时机。例如，你可能需要在bean的依赖项注入之后立即进行某些设置或启动某些服务。通过使用@PostConstruct注解或者init-method属性，你可以确保这些初始化逻辑在bean的依赖项注入之后执行。<br>             自定义销毁逻辑：<br>                 同样地，当bean不再需要时，你可能需要执行一些清理操作，如关闭资源连接、释放内存等。通过了解Spring Bean的生命周期，你可以知道何时是执行这些销毁逻辑的最佳时机。你可以通过实现DisposableBean接口或使用@PreDestroy注解来定义自定义的销毁方法。<br>             集成第三方库：<br>                 当与第三方库集成时，这些库可能需要在特定的生命周期阶段执行特定的操作。了解Spring Bean的生命周期可以帮助你确定在何处集成这些库，以确保它们能够正常工作。<br>             性能优化：<br>                 通过了解Spring Bean的生命周期，你可以更好地优化你的应用程序的性能。例如，如果你知道某个bean只在特定的请求期间需要，你可以考虑将其声明为作用域为request的bean，这样Spring就不会在整个应用程序的生命周期内都持有它的实例。<br>             调试和排错：<br>                 当应用程序出现问题时，了解Spring Bean的生命周期可以帮助你更快地定位问题。例如，如果你知道某个bean的初始化方法总是被调用，但某些属性没有被正确设置，那么你可以检查这个初始化方法是否有问题，或者检查是否有其他bean在初始化方法之后修改了这些属性。<br>             更好的设计决策：<br>                 了解Spring Bean的生命周期可以帮助你做出更好的设计决策。例如，你可能需要考虑是否将某个功能拆分为多个bean，以及这些bean应该如何相互协作。通过了解生命周期，你可以确定哪些bean应该在其他bean之前或之后创建和销毁。</p> 
<h2>作用域</h2> 
<p>使用方法：scope(value="某一作用域")</p> 
<p> //Spring  Bean（Spring管理的对象）的作用域<br> //singleton  单例模式（默认）<br>     //prototype   每次需要都会来一个新对象<br>     //两次打印对象的结果：<br> //    com.easy.common.TestA@1620b463<br> //test method<br> //com.easy.common.TestA@64655594<br> //test method<br>     //request   meb项目中请求作用域，每次请求都会创建一个新对象<br> //    session会话，一次会话有效时间是30分钟，30分钟之内没请求会自动断开会话，安全退出也会断开会话，一次会话都会创建一个新的对象，管理员让用户下线<br>     //GlobalSession   全局的<br>  </p> 
<h2>3.SpringMVC</h2> 
<p>SpringMVC是基于mvc概念写好一个框架，我们来用，并不是写mvc</p> 
<p>@RestController和@Controller不一样，后者如果返回的是一个字符串，会把字符串解析成地址，前者不会</p> 
<p>做mvc的时候需要thymeleaf（前端架构）依赖（spring-boot-starter-thymeleaf），也是从网络上下载，在resourse文件下创建文件夹templates，在这个文件夹下面创建html文件然后加上引入</p> 
<p>要记住刷新maven！！！！</p> 
<p>然后再编写HTML文件 </p> 
<pre><code class="hljs">@Controller
public class EasyBController {
    @RequestMapping("testM")
    public ModelAndView testM(){
    ModelAndView mav=new ModelAndView();
    mav.setViewName("index");
    mav.addObject("username","张三");
        return  mav;
    }
}</code></pre> 
<p>html文件：</p> 
<pre><code class="hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
index page
&lt;h1 th:text="${username}"&gt;Hello, World!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8bc1971884e76d9d2f741eb12ffc91fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详细说明Java中Map和Set接口的使用方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1eee7d6a6531a0e523b73beba65ebabc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三子棋、井字棋 -python版本代码-C语言版本代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>