<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【监控】spring actuator源码速读 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/eeba1e0135b74ae193a271eaa9d25625/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【监控】spring actuator源码速读">
  <meta property="og:description" content="目录
1.前言
2.先搂一眼EndPoint
3.EndPoint如何被注入
4.EndPoint如何被暴露
4.1.如何通过http暴露
4.2.如何通过jmx暴露
5.EndPoint是怎么实现监控能力的
6.知道这些的意义是什么
1.前言 版本：spring-boot-starter-actuator 2.6.3
阅读源码一定要带着疑问去阅读，这个疑问就是你阅读的主线，不然在浩如烟海的源码里面很容易迷路。我们当前的疑问是什么？之前我们已经聊过spring actuator的使用了：
Spring Boot 监控_springboot 监控-CSDN博客
本文要搞清楚的两个问题在于：
EndPoint是怎么被注入IOC又怎么暴露出去能通过HTTP访问到的？
EndPoint是怎么实现监控能力的？
2.先搂一眼EndPoint 首先我们找一个EndPoint来看看，此处以HealthEndPoint为例。点看源码我们可以看到这个EndPoint被@EndPoint注解所注释，id为health。然后其中的2个方法被@ReadOperation所注释：
这里其实猜都能猜到被@EndPoint注解，然后被注解的类被归类为EndPoint，然后被集中暴露出去，变成可访问的。
3.EndPoint如何被注入 我们是通过stater来引入actuator的，Spring Boot体系内如何注入stater的？那肯定是通过autoConfiguration来的撒。点进actuator的配置文件也可以看到：
于是我们来到spring-boot-starter-actuator来看看，看看它的spring.factories里面注入了些什么：
见名知意了，这些众多的XXXautoConfiguration是拿来做什么的就不必多说了吧，health、metrics......分门别类，各种EndPoint的autoConfiguration。
我们来看看HealthEndpointAutoConfiguration里面做了什么：
其实就是加载了HealthEndpointConfiguration、ReactiveHealthEndpointConfiguration、HealthEndpointWebExtensionConfiguration、HealthEndpointReactiveWebExtensionConfiguration这几个类
@Configuration( proxyBeanMethods = false ) @ConditionalOnAvailableEndpoint( endpoint = HealthEndpoint.class ) @EnableConfigurationProperties({HealthEndpointProperties.class}) @Import({HealthEndpointConfiguration.class, ReactiveHealthEndpointConfiguration.class, HealthEndpointWebExtensionConfiguration.class, HealthEndpointReactiveWebExtensionConfiguration.class}) public class HealthEndpointAutoConfiguration { public HealthEndpointAutoConfiguration() { } } 我们先看HealthEndpointConfiguration，它里面向IOC中注入了health的Registry，HealthContributorRegistry中注册了HealthContributor类型的实体。
我们随便打开一个health的EndPoint，发现它都继承同一个父类：
而这个父类实现了HealthContributor接口：
所以其实就是在将注册器注入IOC的时候，就将所有属于该类型的EndPoint注册到注册器中了。
4.EndPoint如何被暴露 4.1.如何通过http暴露 在SpringBoot体系中，谁来负责http请求？那当然是SpringMVC的DispatcherServlet。把path和对应处理的类注册到DispatcherServlet中就行了。spring actuator就是这样对外通过HTTP的方式暴露EndPoint的。
回到spring.factories，找ManagementContextAutoConfiguration，这个类中完成了通过HTTP的方式来暴露EndPoint的过程：
这个类的代码并不多，我们去掉不要的部分，把和对外暴露EndPoint相关的代码保留，来读一下：
@ManagementContextConfiguration( proxyBeanMethods = false ) @ConditionalOnWebApplication( type = Type.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-18T16:49:46+08:00">
    <meta property="article:modified_time" content="2024-02-18T16:49:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【监控】spring actuator源码速读</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%8F%90%E5%87%BA%E7%96%91%E9%97%AE-toc" style="margin-left:0px;"><a href="#1.%E6%8F%90%E5%87%BA%E7%96%91%E9%97%AE" rel="nofollow">1.前言</a></p> 
<p id="2.%E5%85%88%E6%90%82%E4%B8%80%E7%9C%BCEndPoint-toc" style="margin-left:0px;"><a href="#2.%E5%85%88%E6%90%82%E4%B8%80%E7%9C%BCEndPoint" rel="nofollow">2.先搂一眼EndPoint</a></p> 
<p id="2.EndPoint%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B3%A8%E5%85%A5-toc" style="margin-left:0px;"><a href="#2.EndPoint%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B3%A8%E5%85%A5" rel="nofollow">3.EndPoint如何被注入</a></p> 
<p id="3.EndPoint%E5%A6%82%E4%BD%95%E8%A2%AB%E6%9A%B4%E9%9C%B2-toc" style="margin-left:0px;"><a href="#3.EndPoint%E5%A6%82%E4%BD%95%E8%A2%AB%E6%9A%B4%E9%9C%B2" rel="nofollow">4.EndPoint如何被暴露</a></p> 
<p id="3.1.%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87http%E6%9A%B4%E9%9C%B2-toc" style="margin-left:40px;"><a href="#3.1.%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87http%E6%9A%B4%E9%9C%B2" rel="nofollow">4.1.如何通过http暴露</a></p> 
<p id="3.2.%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87jmx%E6%9A%B4%E9%9C%B2-toc" style="margin-left:40px;"><a href="#3.2.%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87jmx%E6%9A%B4%E9%9C%B2" rel="nofollow">4.2.如何通过jmx暴露</a></p> 
<p id="4.EndPoint%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E8%83%BD%E5%8A%9B%E7%9A%84-toc" style="margin-left:0px;"><a href="#4.EndPoint%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E8%83%BD%E5%8A%9B%E7%9A%84" rel="nofollow">5.EndPoint是怎么实现监控能力的</a></p> 
<p id="5.%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:0px;"><a href="#5.%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">6.知道这些的意义是什么</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%8F%90%E5%87%BA%E7%96%91%E9%97%AE" style="background-color:transparent;">1.前言</h2> 
<p>版本：spring-boot-starter-actuator  2.6.3</p> 
<p>阅读源码一定要带着疑问去阅读，这个疑问就是你阅读的主线，不然在浩如烟海的源码里面很容易迷路。我们当前的疑问是什么？之前我们已经聊过spring actuator的使用了：</p> 
<p><a href="https://blog.csdn.net/Joker_ZJN/article/details/130140761?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170824576616800184167690%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=170824576616800184167690&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-130140761-null-null.nonecase&amp;utm_term=%E7%9B%91%E6%8E%A7&amp;spm=1018.2226.3001.4450" title="Spring Boot 监控_springboot 监控-CSDN博客">Spring Boot 监控_springboot 监控-CSDN博客</a></p> 
<p>本文要搞清楚的两个问题在于：</p> 
<ul><li> <p>EndPoint是怎么被注入IOC又怎么暴露出去能通过HTTP访问到的？</p> </li><li> <p>EndPoint是怎么实现监控能力的？</p> </li></ul> 
<h2 id="2.%E5%85%88%E6%90%82%E4%B8%80%E7%9C%BCEndPoint" style="background-color:transparent;">2.先搂一眼EndPoint</h2> 
<p>首先我们找一个EndPoint来看看，此处以HealthEndPoint为例。点看源码我们可以看到这个EndPoint被@EndPoint注解所注释，id为health。然后其中的2个方法被@ReadOperation所注释：</p> 
<p style="text-align:center;"><img alt="" height="349" src="https://images2.imgbox.com/95/8e/GhwyKUg4_o.png" width="536"></p> 
<p>这里其实猜都能猜到被@EndPoint注解，然后被注解的类被归类为EndPoint，然后被集中暴露出去，变成可访问的。</p> 
<h2 id="2.EndPoint%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B3%A8%E5%85%A5" style="background-color:transparent;">3.EndPoint如何被注入</h2> 
<p>我们是通过stater来引入actuator的，Spring Boot体系内如何注入stater的？那肯定是通过autoConfiguration来的撒。点进actuator的配置文件也可以看到：</p> 
<p style="text-align:center;"><img alt="" height="328" src="https://images2.imgbox.com/e2/d3/p5T9YUeI_o.png" width="272"></p> 
<p>于是我们来到spring-boot-starter-actuator来看看，看看它的spring.factories里面注入了些什么：</p> 
<p>见名知意了，这些众多的XXXautoConfiguration是拿来做什么的就不必多说了吧，health、metrics......分门别类，各种EndPoint的autoConfiguration。</p> 
<p style="text-align:center;"><img alt="" height="243" src="https://images2.imgbox.com/1a/30/6QZtkXPe_o.png" width="550"></p> 
<p>我们来看看HealthEndpointAutoConfiguration里面做了什么：</p> 
<p>其实就是加载了HealthEndpointConfiguration、ReactiveHealthEndpointConfiguration、HealthEndpointWebExtensionConfiguration、HealthEndpointReactiveWebExtensionConfiguration这几个类</p> 
<pre><code class="language-java">@Configuration(
    proxyBeanMethods = false
)
@ConditionalOnAvailableEndpoint(
    endpoint = HealthEndpoint.class
)
@EnableConfigurationProperties({HealthEndpointProperties.class})
@Import({HealthEndpointConfiguration.class, ReactiveHealthEndpointConfiguration.class, HealthEndpointWebExtensionConfiguration.class, HealthEndpointReactiveWebExtensionConfiguration.class})
public class HealthEndpointAutoConfiguration {
    public HealthEndpointAutoConfiguration() {
    }
}</code></pre> 
<p>我们先看HealthEndpointConfiguration，它里面向IOC中注入了health的Registry，HealthContributorRegistry中注册了HealthContributor类型的实体。</p> 
<p style="text-align:center;"><img alt="" height="152" src="https://images2.imgbox.com/a5/f4/J0phCeNF_o.png" width="546"></p> 
<p>我们随便打开一个health的EndPoint，发现它都继承同一个父类：</p> 
<p style="text-align:center;"><img alt="" height="68" src="https://images2.imgbox.com/1b/6d/VBOQVLSP_o.png" width="524"></p> 
<p>而这个父类实现了HealthContributor接口：</p> 
<p style="text-align:center;"><img alt="" height="155" src="https://images2.imgbox.com/70/ad/NaMvDEdK_o.png" width="514"></p> 
<p>所以其实就是在将注册器注入IOC的时候，就将所有属于该类型的EndPoint注册到注册器中了。</p> 
<h2 id="3.EndPoint%E5%A6%82%E4%BD%95%E8%A2%AB%E6%9A%B4%E9%9C%B2" style="background-color:transparent;">4.EndPoint如何被暴露</h2> 
<h3 id="3.1.%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87http%E6%9A%B4%E9%9C%B2">4.1.如何通过http暴露</h3> 
<p>在SpringBoot体系中，谁来负责http请求？那当然是SpringMVC的DispatcherServlet。把path和对应处理的类注册到DispatcherServlet中就行了。spring actuator就是这样对外通过HTTP的方式暴露EndPoint的。</p> 
<p>回到spring.factories，找ManagementContextAutoConfiguration，这个类中完成了通过HTTP的方式来暴露EndPoint的过程：</p> 
<p style="text-align:center;"><img alt="" height="397" src="https://images2.imgbox.com/ed/f2/mCl4VwgV_o.png" width="535"></p> 
<p>这个类的代码并不多，我们去掉不要的部分，把和对外暴露EndPoint相关的代码保留，来读一下：</p> 
<pre><code class="language-java">@ManagementContextConfiguration(
    proxyBeanMethods = false
)
@ConditionalOnWebApplication(
    type = Type.SERVLET
)//只能在Web环境中生效
public class ServletEndpointManagementContextConfiguration {
    public ServletEndpointManagementContextConfiguration() {
    }
​
    @Configuration(
        proxyBeanMethods = false
    )
    @ConditionalOnClass({DispatcherServlet.class})//当SpringMVC存在时向IOC中注入
    public static class WebMvcServletEndpointManagementContextConfiguration {
        public WebMvcServletEndpointManagementContextConfiguration() {
        }
        @Bean
        public ServletEndpointRegistrar servletEndpointRegistrar(WebEndpointProperties properties, ServletEndpointsSupplier servletEndpointsSupplier, DispatcherServletPath dispatcherServletPath) {
            return new ServletEndpointRegistrar(dispatcherServletPath.getRelativePath(properties.getBasePath()), servletEndpointsSupplier.getEndpoints());//核心的一步，将EndPoint和对于的Path注册给DispatcherServlet
        }
    }
}</code></pre> 
<p>最后就是开头我们看见的在HealthEndPoint被@ReadOperation注解的方法，就相当于@RequetMapping，拿来处理读请求的。</p> 
<h3 id="3.2.%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87jmx%E6%9A%B4%E9%9C%B2" style="background-color:transparent;">4.2.如何通过jmx暴露</h3> 
<p>jmx的对外暴露更简单。直接找JmxEndpointAutoConfiguration：</p> 
<p style="text-align:center;"><img alt="" height="281" src="https://images2.imgbox.com/d0/a1/r9ucw9r4_o.png" width="503"></p> 
<p>进去整个逻辑一目了然，去扫Jmx的EndPoint然后注册进mBeanServer里：</p> 
<p style="text-align:center;"><img alt="" height="281" src="https://images2.imgbox.com/aa/01/LaoVB3zh_o.png" width="524"></p> 
<h2 id="4.EndPoint%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E8%83%BD%E5%8A%9B%E7%9A%84" style="background-color:transparent;">5.EndPoint是怎么实现监控能力的</h2> 
<p>spring actuator获取各种监控的值是怎么获取到的？</p> 
<ol><li> <p><strong>内置指标获取：</strong> Spring Boot 提供了一些内置的监控指标获取器，用于获取常见的监控数据，比如 JVM 内存使用情况、系统负载、数据库连接池状态等。这些指标获取器会周期性地获取数据，并将其暴露为 Actuator 端点，以便外部系统或者工具可以通过相应的接口来获取。例如，<code>MemoryHealthIndicator</code> 获取 JVM 内存使用情况，<code>DataSourceHealthIndicator</code> 获取数据库连接池状态等。</p> </li><li> <p><strong>自定义指标获取：</strong> 除了内置的指标获取器外，开发者还可以通过实现 <code>HealthIndicator</code> 接口来自定义监控指标获取器，用于获取应用程序特定的监控数据。<code>HealthIndicator</code> 接口定义了一个 <code>health()</code> 方法，用于返回健康状态信息。开发者可以在 <code>health()</code> 方法中编写自定义的监控逻辑，比如检查某个依赖服务的可用性、计算某个指标的值等。</p> </li><li> <p><strong>JMX 获取：</strong> Spring Actuator 还可以通过 Java Management Extensions (JMX) API 来获取一些系统级的监控数据，比如 JVM 运行时信息、操作系统信息等。Spring Actuator 中的一些监控指标获取器会使用 JMX API 来获取数据，然后将其暴露为 Actuator 端点。例如，<code>JvmInfoContributor</code> 使用 JMX API 来获取 JVM 运行时信息。</p> </li><li> <p><strong>系统调用获取：</strong> 有些监控数据可能需要通过系统调用来获取，比如获取操作系统的 CPU 使用率、磁盘使用情况等。Spring Actuator 中的一些监控指标获取器会使用系统调用来获取这些数据，然后将其暴露为 Actuator 端点。</p> </li></ol> 
<h2 id="5.%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88" style="background-color:transparent;">6.知道这些的意义是什么</h2> 
<p>本文是作者java监控系列文章的第三篇，之前两篇文章我们着重讲了java监控的基石——JMX。</p> 
<p><a href="https://blog.csdn.net/Joker_ZJN/article/details/136096172?spm=1001.2014.3001.5501" title="【JMX】JAVA监控的基石-CSDN博客">【JMX】JAVA监控的基石-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/Joker_ZJN/article/details/136117473?spm=1001.2014.3001.5501" title="详解tomcat中的jmx监控-CSDN博客">详解tomcat中的jmx监控-CSDN博客</a></p> 
<p>在spring actuator里面我们知道了目前市面上一个成熟的框架是如何通过http、JMX等不同方式来对外暴露监控能力的。基本上走到这里我们就已经对JAVA整个的监控技术体系最核心的部分有了认识了。作为监控框架来说核心点有哪些？无非是：</p> 
<ul><li> <p>获取数据</p> </li><li> <p>对外暴露口子</p> </li></ul> 
<p>监控的核心肯定是怎么获取数据以及如何将获取的数据暴露出去，只要这两点搞定了，后面的对接各种可视化平台就很好办了。所有知道为啥这篇文章为啥要关心spring actuator这些地方了吧，主要是看看实现思想。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6343ed1420ed563db4c246470eceafd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">论文aigc总体疑似度多少正常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78b2ffd3243fb3c307c7392c5813aa8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI智能制作ER图技术革新：itBuilder引领数据库设计新篇章</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>