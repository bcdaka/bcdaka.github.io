<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶】探索STL的瑰宝 map与set：高效数据结构的奥秘与技巧 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f43f14c457e901db5080e56e58ee4f00/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;高阶】探索STL的瑰宝 map与set：高效数据结构的奥秘与技巧">
  <meta property="og:description" content="📝个人主页🌹：Eternity._
⏩收录专栏⏪：C&#43;&#43; “ 登神长阶 ”
🤡往期回顾🤡：初步了解 二叉搜索树
🌹🌹期待您的关注 🌹🌹
❀map与set 📒1. 关联式容器📙2. 键值对📕3. 树形结构的关联式容器📜4. set 与 multiset🎩set的概念🎈multiset的概念🧩set的使用🌈set的模板参数列表🌞set的构造🌙set的迭代器⭐set的其他函数操作 📚5. map 与 multimap🎩map的概念🎈multimap的概念🧩map的使用🌈map的模板参数说明🌞map的构造🌙map的迭代器⭐map的其他函数操作 📖6. 总结拓展💧在实际中的应用🔥总结 前言： 在编程的世界里，数据结构的选择往往决定了程序的效率和稳定性。而在C&#43;&#43;的STL（Standard Template Library）库中，map和set无疑是两颗璀璨的瑰宝。它们以其独特的数据存储和检索方式，为我们提供了高效且有序的键值对存储和集合管理方案
map和set不仅拥有自动排序的特性，还提供了丰富的成员函数和迭代器接口，使得我们可以轻松地对其进行操作和管理。无论是在算法竞赛中，还是在日常编程中，它们都是不可或缺的工具
我们将从map和set的定义和特性开始，介绍它们的基本用法和常用成员函数。接着，我们将通过示例代码，展示如何在实际编程中使用它们。同时，我们还将探讨一些常见的错误用法和注意事项，帮助你避免在使用map和set时遇到坑
让我们一起踏上学习 map与set 的旅程，探索它带来的无尽可能！
📒1. 关联式容器 在初阶阶段，我们已经接触过STL中的部分容器，比如：vector、list、deque、
forward_list(C&#43;&#43;11)等，这些容器统称为序列式容器，因为其底层为线性序列的数据结构，里面存储的是元素本身
关联式容器（Associative Containers） 是C&#43;&#43;标准模板库（STL）中的一类重要容器，主要用于存储和快速检索键值对（key-value pairs）形式的数据。这类容器与序列式容器（如vector、deque、list）的主要区别在于，关联式容器中的元素是按照特定的排序准则（通常是键的大小）进行排序的，从而允许通过键来快速查找、插入和删除元素
关联式容器： 也是用来存储数据的，与序列式容器不同的是，其里面存储的是&lt;key, value&gt;结构的键值对，在数据检索时比序列式容器效率更高
📙2. 键值对 概念： 用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量key和value，key代表键值，value表示与key对应的信息，比如我们上一篇所提到的kv模型结构 存在对应关系
SGI-STL中关于键值对的定义：(示例)
template &lt;class T1, class T2&gt; struct pair { typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair(): first(T1()), second(T2()) {} pair(const T1&amp; a, const T2&amp; b) : first(a) , second(b) {} }; 📕3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-21T09:00:00+08:00">
    <meta property="article:modified_time" content="2024-06-21T09:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶】探索STL的瑰宝 map与set：高效数据结构的奥秘与技巧</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>📝个人主页🌹：<a href="https://blog.csdn.net/EterNity_TiMe_?type=blog">Eternity._</a><br> ⏩收录专栏⏪：<a href="http://t.csdnimg.cn/rM7cw" rel="nofollow">C++ “ 登神长阶 ”</a><br> 🤡往期回顾🤡：<a href="http://t.csdnimg.cn/UWeFV" rel="nofollow">初步了解 二叉搜索树</a><br> 🌹🌹期待您的关注 🌹🌹</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/68/3c/ap89CEWp_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f1/e2/kLz71tMi_o.gif" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/89/db/ybq1xW8H_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>❀map与set</h4> 
 <ul><li><a href="#1__23" rel="nofollow">📒1. 关联式容器</a></li><li><a href="#2__31" rel="nofollow">📙2. 键值对</a></li><li><a href="#3__59" rel="nofollow">📕3. 树形结构的关联式容器</a></li><li><a href="#4_set__multiset_66" rel="nofollow">📜4. set 与 multiset</a></li><li><ul><li><a href="#set_67" rel="nofollow">🎩set的概念</a></li><li><a href="#multiset_88" rel="nofollow">🎈multiset的概念</a></li><li><a href="#set_109" rel="nofollow">🧩set的使用</a></li><li><ul><li><a href="#set_110" rel="nofollow">🌈set的模板参数列表</a></li><li><a href="#set_116" rel="nofollow">🌞set的构造</a></li><li><a href="#set_139" rel="nofollow">🌙set的迭代器</a></li><li><a href="#set_173" rel="nofollow">⭐set的其他函数操作</a></li></ul> 
  </li></ul> 
  </li><li><a href="#5_map__multimap_210" rel="nofollow">📚5. map 与 multimap</a></li><li><ul><li><a href="#map_211" rel="nofollow">🎩map的概念</a></li><li><a href="#multimap_220" rel="nofollow">🎈multimap的概念</a></li><li><a href="#map_229" rel="nofollow">🧩map的使用</a></li><li><ul><li><a href="#map_230" rel="nofollow">🌈map的模板参数说明</a></li><li><a href="#map_237" rel="nofollow">🌞map的构造</a></li><li><a href="#map_251" rel="nofollow">🌙map的迭代器</a></li><li><a href="#map_260" rel="nofollow">⭐map的其他函数操作</a></li></ul> 
  </li></ul> 
  </li><li><a href="#6__314" rel="nofollow">📖6. 总结拓展</a></li><li><ul><li><a href="#_315" rel="nofollow">💧在实际中的应用</a></li><li><a href="#_320" rel="nofollow">🔥总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p><strong>前言：</strong> 在编程的世界里，数据结构的选择往往决定了程序的效率和稳定性。而在C++的STL（Standard Template Library）库中，<strong>map和set无疑是两颗璀璨的瑰宝。它们以其独特的数据存储和检索方式，为我们提供了高效且有序的键值对存储和集合管理方案</strong></p> 
<blockquote> 
 <p><code>map</code>和<code>set</code>不仅<strong>拥有自动排序的特性，还提供了丰富的成员函数和迭代器接口，使得我们可以轻松地对其进行操作和管理</strong>。无论是在算法竞赛中，还是在日常编程中，它们都是不可或缺的工具</p> 
</blockquote> 
<p>我们将从map和set的定义和特性开始，<strong>介绍它们的基本用法和常用成员函数。接着，我们将通过示例代码，展示如何在实际编程中使用它们</strong>。同时，我们还将探讨一些常见的错误用法和注意事项，帮助你避免在使用map和set时遇到坑</p> 
<p><strong>让我们一起踏上学习 <code>map</code>与<code>set</code> 的旅程，探索它带来的无尽可能！</strong></p> 
<hr> 
<h2><a id="1__23"></a>📒1. 关联式容器</h2> 
<p>在初阶阶段，<strong>我们已经接触过STL中的部分容器，比如：vector、list、deque、<br> forward_list(C++11)等</strong>，这些容器统称为<strong>序列式容器</strong>，因为<strong>其底层为线性序列的数据结构，里面存储的是元素本身</strong></p> 
<p><strong>关联式容器（Associative Containers）</strong> 是C++标准模板库（STL）中的一类重要容器，<strong>主要用于存储和快速检索键值对（key-value pairs）形式的数据</strong>。这类容器与序列式容器（如vector、deque、list）的主要区别在于，<strong>关联式容器中的元素是按照特定的排序准则（通常是键的大小）进行排序的，从而允许通过键来快速查找、插入和删除元素</strong></p> 
<blockquote> 
 <p><strong>关联式容器：</strong> <strong>也是用来存储数据的</strong>，与序列式容器不同的是，<strong>其里面存储的是&lt;key, value&gt;结构的键值对，在数据检索时比序列式容器效率更高</strong></p> 
</blockquote> 
<hr> 
<h2><a id="2__31"></a>📙2. 键值对</h2> 
<blockquote> 
 <p><strong>概念：</strong> 用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量key和value，key代表键值，value表示与key对应的信息，<strong>比如我们上一篇所提到的kv模型结构</strong> 存在对应关系</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2c/6b/2Aagcnen_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d5/dd/bc3GZV9Y_o.png" alt="在这里插入图片描述"></p> 
<p><strong>SGI-STL中关于键值对的定义：(示例)</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">pair</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> T1 first_type<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> T2 second_type<span class="token punctuation">;</span>
	T1 first<span class="token punctuation">;</span>
	T2 second<span class="token punctuation">;</span>
	
	<span class="token function">pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	
	<span class="token function">pair</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">,</span> <span class="token function">second</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="3__59"></a>📕3. 树形结构的关联式容器</h2> 
<p><strong>根据应用场景的不桶，STL总共实现了两种不同结构的管理式容器：树型结构与哈希结构。</strong></p> 
<blockquote> 
 <ul><li><strong>树型结构的关联式容器主要有四种：map、set、multimap、multiset</strong></li><li><strong>共同点是：使用平衡搜索树(即红黑树)作为其底层结果，容器中的元素是一个有序的序列</strong></li></ul> 
</blockquote> 
<p><strong>关联式容器是C++ STL中一类重要的容器，它们通过键值对的形式存储数据，并支持快速的查找、插入和删除操作。常见的关联式容器包括set、multiset、map和multimap等，它们在不同的应用场景下提供了高效的解决方案</strong></p> 
<hr> 
<h2><a id="4_set__multiset_66"></a>📜4. set 与 multiset</h2> 
<h3><a id="set_67"></a>🎩set的概念</h3> 
<p><strong>概念：</strong> set 是 C++ 标准模板库 (STL) 中的一个关联式容器，它包含的元素是唯一的，且默认情况下元素会按照升序排序。set 的内部实现通常使用红黑树来保持其有序性和唯一性</p> 
<blockquote> 
 <ul><li><strong>set是按照一定次序存储元素的容器</strong></li><li><strong>在set中，元素的value也标识它(value就是key，类型为T)，并且每个value必须是唯一的</strong></li><li>set中的元素<strong>不能在容器中修改(元素总是const)</strong>，但是可以从容器中插入或删除它们</li><li>在内部，set中的元素总是按照其内部比较对象(类型比较)所指示的特定严格弱排序准则进行排序</li><li>set容器通过key访问单个元素的速度通常比unordered_set容器慢，但它们允许根据顺序对子集进行直接迭代</li><li>set在底层是用二叉搜索树(红黑树)实现的</li></ul> 
</blockquote> 
<hr> 
<p><strong>特征：</strong></p> 
<blockquote> 
 <ul><li>与map/multimap不同，map/multimap中存储的是真正的键值对&lt;key, value&gt;，set中只放value，但在底层实际存放的是由&lt;value, value&gt;构成的键值对</li><li>set中插入元素时，只需要插入value即可，不需要构造键值对</li><li>set中的元素不可以重复(因此可以使用set进行去重)</li><li>使用set的迭代器遍历set中的元素，可以得到有序序列</li><li>set中的元素默认按照小于来比较</li><li>set中查找某个元素，时间复杂度为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           l 
          
         
           o 
          
          
          
            g 
           
          
            2 
           
          
         
           n 
          
         
        
          log_2 n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span></span></li><li><strong>set中的元素不允许修改</strong></li><li><strong>set中的底层使用二叉搜索树(红黑树)来实现</strong></li></ul> 
</blockquote> 
<hr> 
<h3><a id="multiset_88"></a>🎈multiset的概念</h3> 
<p><strong>概念：<code>multiset</code> 是 C++ 标准库 中的一个容器，它允许存储重复的元素。与 <code>set</code> 不同，<code>set</code> 中的元素是唯一的，而 <code>multiset</code> 中的元素可以重复</strong></p> 
<blockquote> 
 <p><strong>它与<code>set</code>唯一不同的一点就是 <code>multiset</code> 中的元素可以重复</strong></p> 
</blockquote> 
<p><strong>简单演示一下差别</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 注意：multiset在底层实际存储的是&lt;int, int&gt;的键值对</span>
	multiset<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">s</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="set_109"></a>🧩set的使用</h3> 
<h4><a id="set_110"></a>🌈set的模板参数列表</h4> 
<p><img src="https://images2.imgbox.com/48/8a/ePYsb4mj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong>T: set中存放元素的类型，实际在底层存储&lt;value, value&gt;的键值对</strong></li><li><strong>Compare：set中元素默认按照小于来比较</strong></li><li><strong>Alloc：set中元素空间的管理方式，使用STL提供的空间配置器管理</strong></li></ul> 
</blockquote> 
<hr> 
<h4><a id="set_116"></a>🌞set的构造</h4> 
<table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>set (const Compare&amp; comp = Compare(), const Allocator&amp;= Allocator() )</td><td>构造空的set</td></tr><tr><td>set (InputIterator first, InputIterator last, constCompare&amp; comp = Compare(), const Allocator&amp; =Allocator() )</td><td>用[first, last)区间中的元素构造set</td></tr><tr><td>set ( const set&lt;Key,Compare,Allocator&gt;&amp; x)</td><td>set的拷贝构造</td></tr></tbody></table> 
<p><strong>构造代码实现（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> s1<span class="token punctuation">;</span> <span class="token comment">// 构造空的set</span>
	
	<span class="token comment">// 用[first, last)区间中的元素构造set</span>
	set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">s2</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	
	set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">s3</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// set的拷贝构造</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="set_139"></a>🌙set的迭代器</h4> 
<p><strong>set的迭代器有点多，其中包括正向迭代器，反向迭代器；const迭代器与非const迭代器</strong></p> 
<table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>iterator begin()</td><td>返回set中起始位置元素的迭代器</td></tr><tr><td>iterator end()</td><td>返回set中最后一个元素后面的迭代器</td></tr><tr><td>const_iterator cbegin() const</td><td>返回set中起始位置元素的const迭代器</td></tr><tr><td>const_iterator cend()</td><td>const 返回set中最后一个元素后面的const迭代器</td></tr><tr><td>reverse_iterator rbegin()</td><td>返回set第一个元素的反向迭代器，即end</td></tr><tr><td>reverse_iterator rend()</td><td>返回set最后一个元素下一个位置的反向迭代器，即rbegin</td></tr><tr><td>const_reverse_iterator crbegin() const</td><td>返回set第一个元素的反向const迭代器，即cend</td></tr><tr><td>const_reverse_iterator crend() const</td><td>返回set最后一个元素下一个位置的反向const迭代器，即crbegin</td></tr></tbody></table> 
<p><strong>因而有迭代器的存在，set可以跟方便的遍历整个结构</strong></p> 
<p><strong>迭代器实现（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> s1<span class="token punctuation">;</span>
	set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">s2</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">s3</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 输出s2的遍历结果</span>
	<span class="token keyword">auto</span> it <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> s2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 1 3 4 5 6 7</span>
		it<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="set_173"></a>⭐set的其他函数操作</h4> 
<table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>pair&lt;iterator,bool&gt; insert (const value_type&amp; x )</td><td>在set中插入元素x，实际插入的是&lt;x, x&gt;构成的键值对，如果插入成功，返回&lt;该元素在set中的位置，true&gt;,如果插入失败，说明x在set中已经存在，返回&lt;x在set中的位置，false&gt;</td></tr><tr><td>void erase ( iterator position )</td><td>删除set中position位置上的元素</td></tr><tr><td>size_type erase ( const key_type&amp; x )</td><td>删除set中值为x的元素，返回删除的元素的个数</td></tr><tr><td>void erase ( iterator first,iterator last )</td><td>删除set中[first, last)区间中的元素</td></tr><tr><td>void swap (set&lt;Key,Compare,Allocator&gt;&amp;st );</td><td>交换set中的元素</td></tr><tr><td>void clear ( )</td><td>将set中的元素清空</td></tr><tr><td>iterator find ( const key_type&amp; x ) const</td><td>返回set中值为x的元素的位置</td></tr><tr><td>size_type count ( const key_type&amp; x )</td><td>const 返回set中值为x的元素的个数</td></tr></tbody></table> 
<p>在set的这些函数中，用的最多的就是<code>insert，find，erase</code><br> <img src="https://images2.imgbox.com/6d/52/lXsRpCCb_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>首先<code>insert</code>一般是直接插入元素，或者是一段迭代器区间，在直接插入一个元素时，它的返回值是<code>pair</code></strong></p> 
 <ul><li><strong>当插入成功时，<code>first</code>返回新位置的迭代器，然后<code>second</code>返回<code>true</code>;</strong></li><li><strong>当set中已经存在该元素时，插入失败，<code>first</code>返回已有元素位置的迭代器，然后<code>second</code>返回<code>false</code></strong></li></ul> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/c1/20/fInxXbEV_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong><code>find</code>不用多说，在<code>set</code>中是找到则返回该位置迭代器</strong></li><li><strong>在<code>multiset</code>中是返回第一个该元素位置的迭代器</strong></li></ul> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/53/5e/jbdsLEUy_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li> <p><strong><code>erase</code>在set中主要的作用就是删除该迭代器位置的元素，或者删除迭代器区间</strong></p> </li><li> <p><strong>第二种用法是针对<code>multiset</code>的，<code>multiset</code>可以有重复元素，因此可以返回删除元素的个数</strong></p> </li></ul> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/3f/b4/YqpJw1M8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/83/9c/PxmmBYEl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>这里介绍两个没有见过的函数<code>upper_bound，lower_bound</code></strong></p> 
 <ul><li><strong>lower_bound：返回&gt;=该值元素位置的迭代器</strong></li><li><strong>upper_bound：返回&gt;该值元素位置的迭代器</strong></li></ul> 
</blockquote> 
<p><strong>这两个函数通常可以和erase结合使用删除一段迭代器区间</strong></p> 
<hr> 
<h2><a id="5_map__multimap_210"></a>📚5. map 与 multimap</h2> 
<h3><a id="map_211"></a>🎩map的概念</h3> 
<p><strong>概念：</strong> <code>map</code> 是 C++ 标准库中的一个关联容器，它存储的元素都是键值对（key-value pairs），并且键（key）是唯一的。在<code>map</code>中，键值key通常用于排序和惟一地标识元素，而值value中存储与此键值key关联的内容。键值key和值value的类型可能不同，并且在<code>map</code>的内部，key与value通过成员类型<code>value_type</code>绑定在一起，为其取别名称为<code>pair</code>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">const</span> key<span class="token punctuation">,</span> T<span class="token operator">&gt;</span> value_type<span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <ul><li><strong><code>map</code>支持下标访问符，即在<code>[]</code>中放入key，就可以找到与key对应的value</strong></li><li><strong><code>map</code>通常被实现为二叉搜索树(更准确的说：平衡二叉搜索树(红黑树))</strong></li></ul> 
</blockquote> 
<hr> 
<h3><a id="multimap_220"></a>🎈multimap的概念</h3> 
<p><strong>概念：</strong> <code>multimap</code> 是 C++ 标准库 <map> 中的一个关联容器，它允许存储具有相同键的多个值。与 <code>map</code> 不同，<code>map</code> 中的键是唯一的，而 <code>multimap</code> 中的键可以重复</map></p> 
<p><strong>multimap中的接口可以参考map，功能都是类似的。</strong></p> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <ul><li><strong>multimap中的key是可以重复的</strong></li><li><strong>multimap中的元素默认将key按照小于来比较</strong></li><li><strong>multimap中没有重载<code>operator[]</code>操作</strong></li></ul> 
</blockquote> 
<hr> 
<h3><a id="map_229"></a>🧩map的使用</h3> 
<h4><a id="map_230"></a>🌈map的模板参数说明</h4> 
<p><img src="https://images2.imgbox.com/82/4f/x7jp9kKN_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong>key: 键值对中key的类型</strong></li><li><strong>T： 键值对中value的类型</strong></li><li><strong>Compare: 比较器的类型，默认按小于比较</strong></li></ul> 
</blockquote> 
<hr> 
<h4><a id="map_237"></a>🌞map的构造</h4> 
<table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>map()</td><td>构造一个空的map</td></tr></tbody></table> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token generic-function"><span class="token function">map</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构造一个空的map</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="map_251"></a>🌙map的迭代器</h4> 
<table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>begin()和end()</td><td>begin:首元素的位置，end最后一个元素的下一个位置</td></tr><tr><td>cbegin()和cend()</td><td>与begin和end意义相同，但cbegin和cend所指向的元素不能修改</td></tr><tr><td>rbegin()和rend()</td><td>反向迭代器，rbegin在end位置，rend在begin位置，其++和–操作与begin和end操作移动相反</td></tr><tr><td>crbegin()和crend()</td><td>与rbegin和rend位置相同，操作相同，但crbegin和crend所指向的元素不能修改</td></tr></tbody></table> 
<hr> 
<h4><a id="map_260"></a>⭐map的其他函数操作</h4> 
<table><thead><tr><th>函数声明</th><th>功能简介</th></tr></thead><tbody><tr><td>pair&lt;iterator,bool&gt; insert (const value_type&amp; x )</td><td>在map中插入键值对x，注意x是一个键值对，返回值也是键值对：iterator代表新插入元素的位置，bool代表释放插入成功</td></tr><tr><td>size_type erase ( constkey_type&amp; x )</td><td>删除键值为x的元素</td></tr><tr><td>void erase ( iterator first,iterator last )</td><td>删除[first, last)区间中的元素</td></tr><tr><td>iterator find ( const key_type&amp; x)</td><td>在map中插入key为x的元素，找到返回该元素的位置的迭代器，否则返回end</td></tr><tr><td>const_iterator find ( const key_type&amp; x ) const</td><td>在map中插入key为x的元素，找到返回该元素的位置的const迭代器，否则返回cend</td></tr><tr><td>mapped_type&amp; operator[ ] (constkey_type&amp; k)</td><td>返回去key对应的value</td></tr></tbody></table> 
<hr> 
<p><strong>insert</strong><br> <img src="https://images2.imgbox.com/a6/9c/i7o15rNI_o.png" alt="在这里插入图片描述"><br> <strong>在<code>insert</code>插入中，所需要的元素类型是<code>value_type</code> - &gt; <code>pair</code></strong></p> 
<p><strong>map的成员类型</strong><br> <img src="https://images2.imgbox.com/0b/db/Z6Ns1O2d_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/16/72/zY6fKrxL_o.png" alt="在这里插入图片描述"><br> <strong><code>pair</code>可以支持带参构造，无参构造和拷贝构造</strong></p> 
<p><strong>map插入代码演示：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>string<span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"insert"</span><span class="token punctuation">,</span> <span class="token string">"插入"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"find"</span><span class="token punctuation">,</span> <span class="token string">"查找"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>而一般我们并不会这没写，因为有<code>make_pair</code>的存在，我们往往使用<code>make_pair</code></strong></p> 
<p><img src="https://images2.imgbox.com/c4/10/IPoCOA45_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/13/97/UcoDWIek_o.png" alt="在这里插入图片描述"><br> <strong><code>make_pair</code>是一个函数模板，他可以自己推演类型</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>string<span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token string">"erase"</span><span class="token punctuation">,</span> <span class="token string">"删除"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>operator[ ]</strong><br> <img src="https://images2.imgbox.com/dd/5f/KXA3BhAK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0f/64/CvhbIECG_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong><code>insert</code>：插入成功 pair&lt;新插入key所在节点的iterator， true&gt;插入失败 pair&lt;已经存在的key所在节点的iterator，false&gt;</strong></p> 
</blockquote> 
<p><strong>在使用operator[ ]时，它会自动插入一个元素，在插入成功时，返回该位置的<code>second</code>(默认为0)，在插入失败时，它就会返回已有位置的<code>second</code></strong></p> 
<hr> 
<h2><a id="6__314"></a>📖6. 总结拓展</h2> 
<h3><a id="_315"></a>💧在实际中的应用</h3> 
<p><strong>这里推荐两个题目让大家巩固set与map</strong><br> <a href="https://leetcode.cn/problems/top-k-frequent-words/description/" rel="nofollow">前K个高频单词</a><br> <a href="https://leetcode.cn/problems/intersection-of-two-arrays/submissions/" rel="nofollow">两个数组的交集</a></p> 
<hr> 
<h3><a id="_320"></a>🔥总结</h3> 
<p><strong>随着我们深入探讨STL（Standard Template Library）中的map和set，我们不难发现，这两个容器类型在C++编程中扮演着举足轻重的角色。它们不仅提供了高效的数据存储和检索机制，还通过其独特的性质解决了许多实际问题</strong></p> 
<blockquote> 
 <p><strong>在学习的过程中，我们领略了<code>map</code>如何以键值对的形式存储数据，并通过键来快速检索值。而<code>set</code>则以其独特的元素唯一性特点，为我们提供了一种确保集合中元素不重复的方法，然而学习之路永无止境。对于<code>map</code>和<code>set</code>的理解和应用，仅仅停留在基本的使用层面是远远不够的。我们需要进一步探索它们的高级用法</strong></p> 
</blockquote> 
<p>学习STL中的容器并不仅仅是为了掌握它们的使用方法。更重要的是，<strong>我们要学会如何根据问题的需求选择合适的容器类型，以及如何优化我们的代码以提高程序的性能和可维护性</strong>。在这个过程中，我们将会逐渐领悟到编程的精髓和乐趣，让我们一起在学习的道路上不断前行!</p> 
<p><img src="https://images2.imgbox.com/ce/5f/o3id1lSX_o.gif" alt="在这里插入图片描述"></p> 
<p><strong>希望本文能够为你提供有益的参考和启示，让我们一起在编程的道路上不断前行！<br> 谢谢大家支持本篇到这里就结束了，祝大家天天开心！</strong></p> 
<p><img src="https://images2.imgbox.com/1a/20/jaRCcoof_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f777caab42f50a16d250d684d1fa3c2e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【初阶数据结构】深入解析带头双向循环链表:探索底层逻辑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5de9864fa5e341857e14d1d5074bcf02/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于大数据的农村产权交易与数据可视化平台设计和实现(源码&#43;LW&#43;部署讲解)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>