<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ：如何保证消息的可靠性？ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/47a5810df02298da46f013734a6b3823/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RabbitMQ：如何保证消息的可靠性？">
  <meta property="og:description" content="RabbitMQ基础
RabbitMQ支持的消息模型
SpringBoot集成RabbitMQ
一、发送者的可靠性 消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：
消息从生产者到消费者的每一步都有可能导致消息丢失：
发送消息时丢失：
生产者发送消息时连接 MQ失败生产者发送消息到达 MQ 后未找到 Exchange生产者发送消息到达 MQ 的 Exchange 后，未找到合适的 Queue消息到达 MQ 后，处理消息的进程发生异常。 MQ导致丢失：
消息到达 MQ，保存到队列后，尚未消费就突然宕机。 消费者处理消费时丢失：
消息接收后尚未处理突然宕机消息接收后处理过程中抛出异常 综上 我们要解决消息丢失问题，保证 MQ 的可靠性，就必须从3个方面入手：
确保生产者一定把消息发送到 MQ确保 MQ 不会将消息弄丢确保消费者一定要处理消息 1.1、生产者重试机制 第一种情况：生产者发送消息时，出现了网络故障，导致与MQ的连接中断。为了解决这个问题，SpringAMQP 提供消息发送时重试机制。修改 publisher 模块的配置文件，添加内容如下：
spring: rabbitmq: host: 192.168.137.120 port: 5672 virtual-host: / username: admin password: 123456 connection-timeout: 1s # 设置MQ的连接超时时间 template: retry: enabled: true # 开启超时重试机制 initial-interval: 1000s # 失败后的初始等待时间 multiplier: 1 # 失败后下次等待时长倍数 max-attempts: 3 # 最大重试次数 停止rabbitMQ 服务">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T22:05:03+08:00">
    <meta property="article:modified_time" content="2024-07-23T22:05:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ：如何保证消息的可靠性？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/0b/f8/QCxOu0Ge_o.png" alt=""></p> 
<ul><li> <p><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MzYyNzU3Ng==&amp;mid=2247484013&amp;idx=1&amp;sn=9e0924cb9bcb441a0f3db38beca9f6df&amp;chksm=c3304e3af447c72cd60d4b57d4525c029f60fef9a2ea465c235c687a4645ca4fb3853d1caeee#rd" rel="nofollow">RabbitMQ基础</a></p> </li><li> <p><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MzYyNzU3Ng==&amp;mid=2247484059&amp;idx=1&amp;sn=cac6f8a5791070386b2200ecd96e8411&amp;chksm=c3304eccf447c7dab9f801cf785f39d03ff6b9fefe3fb1b24b40a5f82363c8e66451b41e7cec#rd" rel="nofollow">RabbitMQ支持的消息模型</a></p> </li><li> <p><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MzYyNzU3Ng==&amp;mid=2247484211&amp;idx=1&amp;sn=0b8553c5059bd3e460ece0083f22d877&amp;chksm=c3304f64f447c67276e9fa5b39ee94369a047bdaaa2169d2b7460d85ce31a3c4781a9fc535e4#rd" rel="nofollow">SpringBoot集成RabbitMQ</a></p> </li></ul> 
<h4><a id="_10"></a>一、发送者的可靠性</h4> 
<p>消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：</p> 
<p><img src="https://images2.imgbox.com/78/e6/pCoUQUzC_o.png" alt=""></p> 
<p>消息从生产者到消费者的每一步都有可能导致消息丢失：</p> 
<ul><li> <p>发送消息时丢失：</p> 
  <ul><li>生产者发送消息时连接 <strong>MQ</strong></li><li>失败生产者发送消息到达 <strong>MQ</strong> 后未找到 <strong>Exchange</strong></li><li>生产者发送消息到达 <strong>MQ</strong> 的 <strong>Exchange</strong> 后，未找到合适的 <strong>Queue</strong></li><li>消息到达 <strong>MQ</strong> 后，处理消息的进程发生异常。</li></ul> </li><li> <p>MQ导致丢失：</p> 
  <ul><li>消息到达 <strong>MQ</strong>，保存到队列后，尚未消费就突然宕机。</li></ul> </li><li> <p>消费者处理消费时丢失：</p> 
  <ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul> </li></ul> 
<p><strong>综上</strong> 我们要解决消息丢失问题，保证 <code>MQ</code> 的可靠性，就必须从<code>3</code>个方面入手：</p> 
<ol><li>确保生产者一定把消息发送到 <strong>MQ</strong></li><li>确保 <strong>MQ</strong> 不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ol> 
<h5><a id="11_36"></a>1.1、生产者重试机制</h5> 
<p>第一种情况：生产者发送消息时，出现了网络故障，导致与<code>MQ</code>的连接中断。为了解决这个问题，<code>SpringAMQP</code> 提供消息发送时重试机制。修改 <code>publisher</code> 模块的配置文件，添加内容如下：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.137.120
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>
    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /
    <span class="token key atrule">username</span><span class="token punctuation">:</span> admin
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>
    <span class="token key atrule">connection-timeout</span><span class="token punctuation">:</span> 1s  <span class="token comment"># 设置MQ的连接超时时间</span>
    <span class="token key atrule">template</span><span class="token punctuation">:</span>
      <span class="token key atrule">retry</span><span class="token punctuation">:</span>
        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 开启超时重试机制</span>
        <span class="token key atrule">initial-interval</span><span class="token punctuation">:</span> 1000s <span class="token comment"># 失败后的初始等待时间</span>
        <span class="token key atrule">multiplier</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 失败后下次等待时长倍数</span>
        <span class="token key atrule">max-attempts</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 最大重试次数</span>
</code></pre> 
<p>停止<code>rabbitMQ</code> 服务</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> stop mq
</code></pre> 
<p>测试发送一条消息，查看结果是否有重试机制出现</p> 
<p><img src="https://images2.imgbox.com/70/6b/5iOb7R80_o.png" alt=""></p> 
<blockquote> 
 <p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过<code>SpringAMQP</code>提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p> 
</blockquote> 
<h5><a id="12_70"></a>1.2、生产者确认机制</h5> 
<p>一般情况下，只要生产者与<code>MQ</code> 之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。不过，在少数情况下，也会出现消息发送到<code>MQ</code>之后丢失的现象，比如：</p> 
<ul><li><strong>MQ</strong> 内部处理消息的进程发生了异常</li><li>生产者发送消息到达 <strong>MQ</strong> 后未找到<strong>Exchange</strong></li><li>生产者发送消息到达 <strong>MQ</strong> 的 <strong>Exchange</strong> 后，未找到合适的<strong>Queue</strong>，因此无法路由。</li></ul> 
<p>针对上述情况，<code>RabbitMQ</code> 提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给<code>MQ</code>后，<code>MQ</code> 会根据消息处理的情况返回不同的<strong>回执</strong>。</p> 
<p><img src="https://images2.imgbox.com/4d/d7/QPaQsLXH_o.png" alt=""></p> 
<p>总结如下：</p> 
<ul><li>当消息投递到 <strong>MQ</strong>，但是路由失败时，通过 <strong>Publisher Return</strong> 返回异常信息，同时返回 <strong>ACK</strong> 的确认信息，代表投递成功。</li><li>临时消息投递到了 <strong>MQ</strong>，并且入队成功，返回 <strong>ACK</strong>，告知投递成功。</li><li>持久消息投递到了<strong>MQ</strong>，并且入队完成持久化，返回 <strong>ACK</strong> ，告知投递成功。</li><li>其它情况都会返回 <strong>NACK</strong>，告知投递失败。</li></ul> 
<p>其中<code>ack</code>和 <code>nack</code> 属于 <code>Publisher Confirm</code> 机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于 <code>Publisher Return</code> 机制。<br> 默认两种机制都是关闭状态，需要通过配置文件来开启。</p> 
<h5><a id="13_92"></a>1.3、生产者确认机制实现</h5> 
<h6><a id="131_94"></a>1.3.1、生产者开启确认机制</h6> 
<p>在 <code>publisher</code>模块的 <code>application.yaml</code>中添加配置：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">publisher-confirm-type</span><span class="token punctuation">:</span> correlated <span class="token comment"># 开启publisher confirm 机制，并设置confirm 类型</span>
    <span class="token key atrule">publisher-returns</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 开启publisher return 机制</span>
</code></pre> 
<p>这里<code>publisher-confirm-type</code> 有三种模式可选：</p> 
<ul><li>**none：**关闭 <strong>confirm</strong> 机制。</li><li><strong>simple：</strong> 同步阻塞等待 <strong>MQ</strong> 的回执。</li><li><strong>correlated：</strong> <strong>MQ</strong>异步回调返回回执。</li></ul> 
<p>一般选择 <strong>correlated</strong> 回调机制。</p> 
<h6><a id="132ReturnCallback_113"></a>1.3.2、定义<code>ReturnCallback</code></h6> 
<p>每个<code>RabbitTemplate</code> 只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在<code>publisher</code> 模块定义一个配置类，内容如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>publisher<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">ReturnedMessage</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RabbitTemplate</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">BeansException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">ApplicationContext</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">ApplicationContextAware</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @author db
 * @version 1.0
 * @description MqConfig
 * @since 2023/12/7
 */</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MqConfig</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">RabbitTemplate</span> rabbitTemplate <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnsCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ReturnsCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">returnedMessage</span><span class="token punctuation">(</span><span class="token class-name">ReturnedMessage</span> returnedMessage<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"触发return callback,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"exchange: {}"</span><span class="token punctuation">,</span> returnedMessage<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"routingKey: {}"</span><span class="token punctuation">,</span> returnedMessage<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"message: {}"</span><span class="token punctuation">,</span> returnedMessage<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"replyCode: {}"</span><span class="token punctuation">,</span> returnedMessage<span class="token punctuation">.</span><span class="token function">getReplyCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"replyText: {}"</span><span class="token punctuation">,</span> returnedMessage<span class="token punctuation">.</span><span class="token function">getReplyText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="133ConfirmCallback_155"></a>1.3.3、定义<code>ConfirmCallback</code></h6> 
<p>由于每个消息发送时的处理逻辑不一定相同，因此<code>ConfirmCallback</code>需要在每次发消息时定义。具体来说，是在调用<code>RabbitTemplate</code>中的<code>convertAndSend</code> 方法时，多传递一个参数<code>CorrelationData</code>这里的<code>CorrelationData</code>中包含两个核心的东西：</p> 
<ul><li><strong>id：</strong> 消息的唯一标示，<strong>MQ</strong> 对不同的消息的回执以此做判断，避免混淆。</li><li><strong>SettableListenableFuture：</strong> 回执结果的 <strong>Future</strong> 对象。</li></ul> 
<p>新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback：</code></p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPublisherConfirm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 创建CorrelationData</span>
        <span class="token class-name">CorrelationData</span> correlationData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 给future添加confirmCallback</span>
        correlationData<span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ListenableFutureCallback</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CorrelationData<span class="token punctuation">.</span>Confirm</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFailure</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span>
                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"send message fail"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token class-name">CorrelationData<span class="token punctuation">.</span>Confirm</span> result<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span>
                    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"发送消息成功，收到 ack!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// result.getReason()，String类型，返回nack时的异常描述</span>
                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"发送消息失败，收到 nack, reason : {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getReason</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 发送消息</span>
        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">,</span><span class="token string">"info"</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">,</span>correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>测试结果：</p> 
<p><img src="https://images2.imgbox.com/ea/74/oGAMWWI5_o.png" alt=""></p> 
<p>改变交换机，使用错误的交换机，由于传递的<code>RoutingKey</code> 是错误的，路由失败后，触发了<code>return callback，</code>同时也收到了<code>ack</code>。当我们修改为正确的<code>RoutingKey</code>以后，就不会触发<code>return callback</code>了，只收到<code>ack</code>。而如果连交换机都是错误的，则只会收到<code>nack</code>。<br> <img src="https://images2.imgbox.com/86/35/x2I7KeRM_o.png" alt=""></p> 
<blockquote> 
 <p>注意：开启生产者确认比较消耗<strong>MQ</strong>性能，一般不建议开启。</p> 
</blockquote> 
<h4><a id="MQ_203"></a>二、<code>MQ</code>的可靠性</h4> 
<p>在默认情况下，<code>RabbitMQ</code>会将接收到的信息保存在内存中以降低消息收发的延迟。这样会导致两个问题:</p> 
<ul><li>一旦<strong>MQ</strong>宕机，内存中的消息会丢失。</li><li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发<strong>MQ</strong>阻塞。</li></ul> 
<h5><a id="21_208"></a>2.1、数据持久化</h5> 
<p>为了提升性能，默认情况下<code>MQ</code> 的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p> 
<ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul> 
<p>交换机的持久化：添加交换机时，配置交换机的<code>Durability</code>参数：</p> 
<p><img src="https://images2.imgbox.com/7c/e1/LLiiCIwY_o.png" alt=""></p> 
<p>队列的持久化，添加队列时，配置交换机的<code>Durability</code>参数：</p> 
<p><img src="https://images2.imgbox.com/88/13/5m46Iw66_o.png" alt=""></p> 
<p>队列的持久化，控制台发送消息的时候，可以添加很多参数，而消息的持久化要配置一个<code>properties：</code></p> 
<p><img src="https://images2.imgbox.com/dd/02/1WQqdQmC_o.png" alt=""></p> 
<p><strong>说明</strong>：</p> 
<p>在开启持久化机制以后，如果同时还开启了生产者确认，那么<code>MQ</code>会在消息持久化以后才发送<code>ACK</code> 回执，进一步确保消息的可靠性。不过出于性能考虑，为了减少<code>IO</code> 次数，发送到<code>MQ</code> 的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在<code>100</code>毫秒左右，这就会导致<code>ACK</code> 有一定的延迟，因此建议生产者确认全部采用异步方式。</p> 
<h5><a id="22LazyQueue_234"></a>2.2、LazyQueue</h5> 
<p>在默认情况下，<code>RabbitMQ</code>会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p> 
<ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul> 
<p>一旦出现消息堆积问题，<code>RabbitMQ</code> 的内存占用就会越来越高，直到触发内存预警上限。此时<code>RabbitMQ</code> 会将内存消息刷到磁盘上，这个行为成为<code>PageOut</code>，<code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中<code>RabbitMQ</code>不会再处理新的消息，生产者的所有请求都会被阻塞为了解决这个问题，从<code>RabbitMQ</code>的3.6.0版本开始，就增加了<code>Lazy Queues</code> 的模式，也就是惰性队列。惰性队列的特征如下：</p> 
<ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul> 
<p>控制台配置<code>Lazy</code>模式</p> 
<p>在添加队列的时候，添加<code>x-queue-mod=lazy</code>参数即可设置队列为<code>Lazy</code>模式!</p> 
<p><img src="https://images2.imgbox.com/0c/4f/B4v6jP1l_o.png" alt=""></p> 
<p>代码配置<code>Lazy</code>模式</p> 
<p>利用<code>SpringAMQP</code>声明队列的时候，添加<code>x-queue-mod=lazy</code>参数也可设置队列为<code>Lazy</code>模式：</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">lazyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span>
                <span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"lazy.queue"</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启Lazy模式</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>也可以基于注解来声明队列并设置为<code>Lazy</code>模式：</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">,</span> <span class="token comment">// 创建临时队列</span>
            key <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"user.#"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">//路由key</span>
            exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"topics"</span><span class="token punctuation">,</span>type<span class="token operator">=</span><span class="token string">"topic"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 绑定交换机</span>
            arguments <span class="token operator">=</span> <span class="token annotation punctuation">@Argument</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"x-queue-mod"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"lazy"</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenLazyQueueMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者2接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_281"></a>三、消费者的可靠性</h4> 
<h5><a id="31_283"></a>3.1、消费者确认机制</h5> 
<p>为了确认消费者是否成功处理消息，<code>RabbitMQ</code>提供了消费者确认机制<code>（Consumer Acknowledgement）</code>。即：当消费者处理消息结束后，应该向<code>RabbitMQ</code> 发送一个回执，告知<code>RabbitMQ</code> 自己消息处理状态。回执有三种可选值：</p> 
<ul><li><strong>ack：</strong> 成功处理消息，<strong>RabbitMQ</strong> 从队列中删除该消息。</li><li><strong>nack：</strong> 消息处理失败，<strong>RabbitMQ</strong> 需要再次投递消息。</li><li><strong>reject：</strong> 消息处理失败并拒绝该消息，<strong>RabbitMQ</strong> 从队列中删除该消息。</li></ul> 
<p><img src="https://images2.imgbox.com/c8/98/pBZLxYYm_o.png" alt=""></p> 
<p>一般<code>reject</code> 方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code> 机制捕获，消息处理成功时返回<code>ack</code>，处理失败时返回<code>nack</code>。由于消息回执的处理代码比较统一，因此<code>SpringAMQP</code> 帮我们实现了消息确认。并允许我们通过配置文件设置<code>ACK</code>处理方式，有三种模式：</p> 
<ul><li><strong>none</strong>：不处理。即消息投递给消费者后立刻 <strong>ack</strong>，消息会立刻从 <strong>MQ</strong> 删除。非常不安全，不建议使用。</li><li><strong>manual</strong>：手动模式。需要自己在业务代码中调用 <strong>api</strong> ，发送 <strong>ack</strong> 或 <strong>reject</strong>，存在业务入侵，但更灵活。</li><li><strong>auto</strong>：自动模式。<strong>SpringAMQP</strong> 利用 <strong>AOP</strong> 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 <strong>ack</strong>。当业务出现异常时，根据异常判断返回不同结果： 
  <ul><li>如果是<strong>业务异常</strong>，会自动返回 <strong>nack</strong>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回 <strong>reject</strong>;</li></ul> </li></ul> 
<p>修改<code>SpringAMQP</code>的<code>ACK</code>处理方式：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.137.120
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> admin
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>
    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /
    <span class="token key atrule">connection-timeout</span><span class="token punctuation">:</span> <span class="token number">600000</span>
    <span class="token key atrule">listener</span><span class="token punctuation">:</span>
      <span class="token key atrule">simple</span><span class="token punctuation">:</span>
        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> none  <span class="token comment"># 不做处理</span>
</code></pre> 
<p>修改<code>consumer</code>服务的<code>SpringRabbitListener</code>类中的方法，模拟一个消息处理的异常：</p> 
<pre><code class="prism language-Java">@RabbitListener(queues = "simple.queue")
public void listenSimpleQueueMessage(String msg) throws InterruptedException {
    log.info("spring 消费者接收到消息：【" + msg + "】");
    if (true) {
        throw new MessageConversionException("故意的");
    }
    log.info("消息处理完成");
}
</code></pre> 
<p>测试可以发现：当消息处理发生异常时，消息依然被<code>RabbitMQ</code>删除了。确认机制修改为<code>auto</code>：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.137.120
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> admin
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>
    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /
    <span class="token key atrule">connection-timeout</span><span class="token punctuation">:</span> <span class="token number">600000</span>
    <span class="token key atrule">listener</span><span class="token punctuation">:</span>
      <span class="token key atrule">simple</span><span class="token punctuation">:</span>
        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> auto  <span class="token comment"># 自动ack</span>
</code></pre> 
<p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为 <code>unacked</code>（未确定状态）放行以后，由于抛出的是<strong>消息转换异常</strong>，因此 <code>Spring</code> 会自动返回 <code>reject</code>，所以消息依然会被删除：将异常改为 <code>RuntimeException</code> 类型：</p> 
<pre><code class="prism language-Java">@RabbitListener(queues = "object.queue")
public void listenObjectMessage(Map&lt;String,Object&gt; msg) throws InterruptedException {
    System.out.println("消费者接收到消息：【" + msg + "】");
    throw new RuntimeException("故意的");
}
</code></pre> 
<p>在异常位置打断点，然后再次发送消息测试，程序卡在断点时，可以发现此时消息状态为 <code>unacked</code>（未确定状态）：放行以后，由于抛出的是业务异常，所以 <code>Spring</code>返回 <code>ack</code>，最终消息恢复至 <code>Ready</code> 状态，并且没有被 <code>RabbitMQ</code>删除：当我们把配置改为 <code>auto</code>时，消息处理失败后，会回到 <code>RabbitMQ</code> ，并重新投递到消费者。</p> 
<h5><a id="32_359"></a>3.2、失败重试机制</h5> 
<p>当消费者出现异常后，消息会不断<code>requeue</code>（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次<code>requeue</code>到队列，再次投递，直到消息处理成功为止。极端情况就是消费者一直无法执行成功，那么消息<code>requeue</code>就会无限循环，导致<code>MQ</code>的消息处理飙升，带来不必要的压力</p> 
<p>失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的<code>requeue</code>到<code>MQ</code>队列。</p> 
<p>修改<code>consumer</code>服务的<code>application.yml</code>文件，添加内容：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.137.120
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> admin
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>
    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /
    <span class="token key atrule">connection-timeout</span><span class="token punctuation">:</span> <span class="token number">600000</span>
    <span class="token key atrule">listener</span><span class="token punctuation">:</span>
      <span class="token key atrule">simple</span><span class="token punctuation">:</span>
        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> auto  <span class="token comment"># 不做处理</span>
        <span class="token key atrule">retry</span><span class="token punctuation">:</span>
          <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 开启消费者失败重试</span>
          <span class="token key atrule">initial-interval</span><span class="token punctuation">:</span> 1000ms <span class="token comment"># 初识的失败等待时长为1秒</span>
          <span class="token key atrule">multiplier</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span>
          <span class="token key atrule">max-attempts</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 最大重试次数</span>
          <span class="token key atrule">stateless</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span>
</code></pre> 
<p>重启 <code>consumer</code> 服务，重复之前的测试。可以发现：</p> 
<ul><li>消费者在失败后消息没有重新回到 <strong>MQ</strong> 无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了 <strong>AmqpRejectAndDontRequeueException</strong> 异常。查看 <strong>RabbitMQ</strong> 控制台，发现消息被删除了，说明最后 <strong>SpringAMQP</strong> 返回的是 <strong>reject</strong></li></ul> 
<p><strong>结论：</strong></p> 
<ol><li>开启本地重试时，消息处理过程中抛出异常，不会 <strong>requeue</strong> 到队列，而是在消费者本地重试。</li><li>重试达到最大次数后，<strong>Spring</strong> 会返回 <strong>reject</strong>，消息会被丢弃。</li></ol> 
<h5><a id="33_397"></a>3.3、失败处理策略</h5> 
<p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。因此 <code>Spring</code> 允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code> 接口来定义的，它有3个不同实现：</p> 
<ul><li><strong>RejectAndDontRequeueRecoverer：</strong> 重试耗尽后，直接 <strong>reject</strong>，丢弃消息。默认就是这种方式。</li><li><strong>ImmediateRequeueMessageRecoverer：</strong> 重试耗尽后，返回<strong>nack</strong>，消息重新入队。</li><li><strong>RepublishMessageRecoverer：</strong> 重试耗尽后，将失败消息投递到指定的交换机。</li></ul> 
<p>比较优雅的一种处理方案是 <strong>RepublishMessageRecoverer</strong>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p> 
<p>1）在 <code>consumer</code> 服务中定义处理失败消息的交换机和队列。</p> 
<p>2）定义一个<code>RepublishMessageRecoverer</code>，关联队列和交换机。</p> 
<pre><code class="prism language-Java">package com.itheima.consumer.config;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.retry.MessageRecoverer;
import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;
import org.springframework.context.annotation.Bean;

@Configuration
@ConditionalOnProperty(name = "spring.rabbitmq.listener.simple.retry.enabled", havingValue = "true")
public class ErrorMessageConfig {
    @Bean
    public DirectExchange errorMessageExchange(){
        return new DirectExchange("error.direct");
    }
    @Bean
    public Queue errorQueue(){
        return new Queue("error.queue", true);
    }
    @Bean
    public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){
        return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with("error");
    }

    @Bean
    public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){
        return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");
    }
}
</code></pre> 
<p>消费者如何保证消息一定被消费？</p> 
<p>开启消费者确认机制为<code>auto</code>，由<code>Spring</code>确认消息处理成功后返回<code>ack</code>，异常时返回<code>nack</code>开启消费者失败重试机制，并设置<code>MessageRecoverer</code>多次重试失败后将消息投递给异常交换机，交由人工处理。</p> 
<p>代码地址：<code>https://gitee.com/duan138/practice-code/tree/master/mq-demo</code></p> 
<h4><a id="_452"></a>四、总结</h4> 
<p>要想保证消息的可靠性，就要先知道什么时候消息会丢失？会有三方面分别是：消息到<code>MQ</code>的过程丢失、<code>MQ</code> 自己丢失、<code>MQ</code> 到消费过程中丢失。文章中提到从三方面去保证消息的可靠性。分别是生产者到 <code>RabbitMQ</code>使用事务机制或者<code>Confirm</code>机制；<code>RabbitMQ</code>自身持久化、集群等；<code>RabbitMQ</code>到消费者采用<code>basicAck</code>机制、死信队列、消息补偿机制。</p> 
<p>参考：https://www.bilibili.com/video/BV1mN4y1Z7t9</p> 
<hr> 
<p>改变你能改变的，接受你不能改变的，关注公众号：<strong>程序员康康</strong>，一起成长，共同进步。</p> 

                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8882d0539d3744a4cf74daff8b1f8f35/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用【MATLAB】和【Python】进行【图与网络模型】的高级应用与分析】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e12d2918e6eeb44bc205f78757205157/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">两台低功耗服务器存档</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>