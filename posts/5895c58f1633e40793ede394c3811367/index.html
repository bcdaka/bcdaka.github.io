<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode/NowCoder-栈和队列OJ练习 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5895c58f1633e40793ede394c3811367/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="LeetCode/NowCoder-栈和队列OJ练习">
  <meta property="og:description" content="孜孜不倦：孜孜：勤勉，不懈怠。指工作或学习勤奋不知疲倦。💓💓💓
目录
说在前面
题目一：括号匹配问题
题目二：用队列实现栈
题目三：用栈实现队列
题目四：设计循环队列
SUMUP结尾
说在前面 dear朋友们大家好！💖💖💖我们又见面了，有到了我们数据结构的刷题时间了。我们上次刚学完了栈和队列，现在正好练练手~
👇👇👇
友友们！🎉🎉🎉点击这里进入力扣leetcode学习🎉🎉🎉
​以下是leetcode题库界面：
​​
👇👇👇
🎉🎉🎉点击这里进入牛客网NowCoder刷题学习🎉🎉🎉
​以下是NowCoder题库界面：
​
​​​
题目一：括号匹配问题 题目链接：20. 有效的括号 - 力扣（LeetCode）
题目描述：
​
题目分析：
思路：由于C语言没有单独提供栈的实现，我们首先需要把我们之前写的栈的实现的接口都复制到题当中，接口如下：
typedef char STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; //栈的初始化 void STInit(ST* pst) { assert(pst); pst-&gt;a = NULL; //top指的是栈顶数据的下一个位置 pst-&gt;top = pst-&gt;capacity = 0; } //扩容 static void STCheckCapacity(ST* pst) { if (pst-&gt;top == pst-&gt;capacity) { int NewCapacity = pst-&gt;capacity == 0 ?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-01T13:52:27+08:00">
    <meta property="article:modified_time" content="2024-06-01T13:52:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode/NowCoder-栈和队列OJ练习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#fe2c24;"><strong>孜孜不倦：孜孜：勤勉，不懈怠。指工作或学习勤奋不知疲倦。💓💓💓</strong></span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2-toc" style="margin-left:0px;"><a href="#%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2" rel="nofollow"> 说在前面</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0" rel="nofollow">题目一：括号匹配问题</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%9A%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%9A%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88" rel="nofollow">题目二：用队列实现栈</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E4%B8%89%EF%BC%9A%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E4%B8%89%EF%BC%9A%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97" rel="nofollow">题目三：用栈实现队列</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E5%9B%9B%EF%BC%9A%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E5%9B%9B%EF%BC%9A%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97" rel="nofollow">题目四：设计循环队列</a></p> 
<p id="%C2%A0%C2%A0%E2%80%A2%F0%9F%8C%99Conclude%E7%BB%93%E5%B0%BE-toc" style="margin-left:0px;"><a href="#%C2%A0%C2%A0%E2%80%A2%F0%9F%8C%99Conclude%E7%BB%93%E5%B0%BE" rel="nofollow">SUMUP结尾</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <h2 id="%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2"> 说在前面</h2> 
 <p> dear朋友们大家好！💖💖💖我们又见面了，有到了我们数据结构的刷题时间了。我们上次刚学完了栈和队列，现在正好练练手~</p> 
 <p> 👇👇👇</p> 
 <p><a href="https://leetcode.cn/problemset/" rel="nofollow" title="友友们！🎉🎉🎉点击这里进入力扣leetcode学习🎉🎉🎉">友友们！🎉🎉🎉点击这里进入力扣leetcode学习🎉🎉🎉</a></p> 
 <p><br> ​以下是leetcode题库界面：</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/08/86/QhLy7Y3U_o.png" width="1200">​​</p> 
 <p></p> 
 <p> 👇👇👇</p> 
 <p><a href="https://www.nowcoder.com/exam/company" rel="nofollow" title="🎉🎉🎉点击这里进入牛客网NowCoder刷题学习🎉🎉🎉">🎉🎉🎉点击这里进入牛客网NowCoder刷题学习🎉🎉🎉</a><br> ​以下是NowCoder题库界面：</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/72/5e/VNm8GGQt_o.png" width="1200">​</p> 
</blockquote> 
<p>  <img alt="" height="34" src="https://images2.imgbox.com/51/49/DxrecxFN_o.png" width="486">​​​</p> 
<h3 id="%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0">题目一：括号匹配问题</h3> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/valid-parentheses/description/" rel="nofollow" title="20. 有效的括号 - 力扣（LeetCode）">20. 有效的括号 - 力扣（LeetCode）</a></p> 
<p><strong>题目描述：</strong></p> 
<p><img alt="" height="783" src="https://images2.imgbox.com/88/97/eX6nVmUC_o.png" width="680">​</p> 
<p><strong>题目分析：</strong></p> 
<p><strong><span style="color:#1c7892;"> 思路：</span></strong>由于C语言没有单独提供栈的实现，我们首先需要把我们之前写的栈的实现的接口都复制到题当中，接口如下：</p> 
<pre><code class="language-cpp">typedef char STDataType;

typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;

//栈的初始化
void STInit(ST* pst)
{
	assert(pst);
	pst-&gt;a = NULL;
	//top指的是栈顶数据的下一个位置
	pst-&gt;top = pst-&gt;capacity = 0;
}

//扩容
static void STCheckCapacity(ST* pst)
{
	if (pst-&gt;top == pst-&gt;capacity)
	{
		int NewCapacity = pst-&gt;capacity == 0 ? 4 : 2 * pst-&gt;capacity;
		STDataType* temp = (STDataType*)realloc(pst-&gt;a, NewCapacity * sizeof(STDataType));
		if (temp == NULL)
		{
			perror("realloc operation failed");
			exit(1);
		}
		pst-&gt;a = temp;
		pst-&gt;capacity = NewCapacity;
	}
}

//入栈
void STPush(ST* pst, STDataType x)
{
	assert(pst);
	STCheckCapacity(pst);
	pst-&gt;a[pst-&gt;top++] = x;
}

//出栈
void STPop(ST* pst)
{
	assert(pst &amp;&amp; pst-&gt;top);
	pst-&gt;top--;
}

//获取栈顶元素
STDataType STTop(ST* pst)
{
	assert(pst &amp;&amp; pst-&gt;top);
	return pst-&gt;a[pst-&gt;top - 1];
}

//检测栈是否为空
bool STEmpty(ST* pst)
{
	assert(pst);
	return pst-&gt;top == 0;
}

//获取栈中有效元素个数
int STSize(ST* pst)
{
	assert(pst);
	return pst-&gt;top;
}

//栈的销毁
void STDestroy(ST* pst)
{
	assert(pst);
    free(pst-&gt;a);
	pst-&gt;a = NULL;
	pst-&gt;top = pst-&gt;capacity = 0;
}</code></pre> 
<p>在此基础上我们才能完成题解。</p> 
<p>这题为什么会想到用栈来解决呢？<span style="color:#79c6cd;"><strong>我们可以认为每次得到一个右括号，都和从右边往左的第一个左括号进行匹配</strong></span>，如果匹配成功，就是对的，如果有哪一次匹配失败了，说明不正确，返回false。那么我们观察左括号很明显就有个特点，就是最后输入的左括号要先和右括号匹配，这和我们栈的LIFO（Last In First Out）是一样的。</p> 
<p><strong>比如：</strong></p> 
<p><img alt="" height="36" src="https://images2.imgbox.com/f7/2d/fkuqKXsh_o.png" width="301"></p> 
<p>像上面这个例子，我们可以用栈存放左括号。如果是三种左括号的一种，我们就把它压入栈中，如果是三种右开括号的一种，我们取出栈顶的左括号，和它进行匹配。</p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/eb/c7/jzwIUdzf_o.png" width="554"></p> 
<p>当放入这三个左括号，我们输入了一个右括号，此时我们需要得到栈顶的括号（STTop）和当前右有括号对比看是否匹配。如果匹配成功，我们还需要将这个数据删除，然后继续这个操作，也就是每次对比都会消耗一个左括号。</p> 
<p>     <img alt="" height="167" src="https://images2.imgbox.com/fb/b2/indCCWQC_o.png" width="480"></p> 
<p>显然两个左括号都匹配成功，此时再继续压栈。最后两个右括号刚好也和两个左括号匹配成功，所以最后我们可以判断栈是否为空（STEmpty）来判断是否整体都是匹配成功的。</p> 
<p><strong>代码如下：</strong></p> 
<pre><code class="language-cpp"> bool isValid(char* s) {
     ST st;
     STInit(&amp;st);
     while(*s)
     {
         //左括号入栈
         if(*s == '(' || *s == '[' || *s == '{')
         {
             STPush(&amp;st, *s);
         }
         else//右括号去栈顶左括号尝试匹配
         {
             if(STEmpty(&amp;st))//栈为空
             {
                 STDestroy(&amp;st);
                 return false;
             }
             char top = STTop(&amp;st);
             STPop(&amp;st);
             //匹配失败
             if(*s == ')' &amp;&amp; top != '('
             || *s == ']' &amp;&amp; top != '['
             || *s == '}' &amp;&amp; top != '{')
                 return false;
         }
         s++;
     }
     bool ret = STEmpty(&amp;st);
     STDestroy(&amp;st);
     return ret;
 }</code></pre> 
<p>最后有一个地方需要注意，就是如果我们刚开始就进入右括号，此时没有做括号匹配，那么直接就跳出循环，栈也是为空的，就返回了true，这显然是错误的。所以我们在输入右括号的时候也要判断一下栈是否为空，若为空直接返回false。 </p> 
<p><img alt="" height="34" src="https://images2.imgbox.com/c6/ae/K2eCqo19_o.png" width="486">​</p> 
<h3 id="%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%9A%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">题目二：用队列实现栈</h3> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/" rel="nofollow" title="225. 用队列实现栈 - 力扣（LeetCode）">225. 用队列实现栈 - 力扣（LeetCode）</a></p> 
<p><strong>题目描述：</strong></p> 
<p><img alt="" height="1117" src="https://images2.imgbox.com/58/03/MUYsPml8_o.png" width="682">​</p> 
<p><strong>题目分析：</strong></p> 
<p><span style="color:#1c7892;"><strong> 思路：</strong></span>和题目一同样的，我们需要将队列的实现的所有接口都复制到题目当中，才能在接下来使用队列，接口如下：</p> 
<pre><code class="language-cpp">typedef int QDataType;

typedef struct QueueNode
{
	QDataType val;
	struct QueueNode* next;
}QNode;

typedef struct Queue
{
	struct QueueNode* phead;
	struct QueueNode* ptail;
	int size;
}Queue;

//队列的初始化
void QueueInit(Queue* pq)
{
	assert(pq);
	pq-&gt;phead = NULL;
	pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}

//队尾入队列
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc operation failed");
		exit(1);
	}
	newnode-&gt;next = NULL;
	newnode-&gt;val = x;
	if (pq-&gt;ptail == NULL)
	{
		pq-&gt;phead = pq-&gt;ptail = newnode;
	}
	else
	{
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
	}
	pq-&gt;size++;
}

//队头出队列
void QueuePop(Queue* pq)
{
	assert(pq &amp;&amp; pq-&gt;size);
	if (pq-&gt;phead-&gt;next == NULL)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	else
	{
		QNode* next = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = next;
	}
	pq-&gt;size--;
}

//获取队列有效元素个数
int QueueSize(Queue* pq)
{
	assert(pq);
	return pq-&gt;size;
}

//获取队列头部元素
QDataType QueueFront(Queue* pq)
{
	assert(pq &amp;&amp; pq-&gt;phead);
	return pq-&gt;phead-&gt;val;
}

//获取队列尾部元素
QDataType QueueBack(Queue* pq)
{
	assert(pq &amp;&amp; pq-&gt;ptail);
	return pq-&gt;ptail-&gt;val;
}

//检测队列是否为空
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq-&gt;size == 0;
}

//销毁队列
void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}</code></pre> 
<p>有了上述接口以后，我们思考接下来如何用两个队列实现栈。</p> 
<p>我们知道，栈是<span style="color:#79c6cd;"><strong>后入先出</strong></span>的，而队列是<span style="color:#79c6cd;"><strong>先入先出</strong></span>的。函数需要我们实现栈的基本操作：push（压栈）、pop（弹栈）、top（取栈顶元素）、empty（判空）。对于压栈来说，其实可以直接实现，我们把一个队列的队头当做栈底，队尾入队列（QueuePush）就相当于压栈。问题是如何弹栈呢？队列只能是一端入，另一端出，没办法直接实现删除队尾的数据。这个时候，我们可以借助另一个队列。我们可以将队列中的数据从队头开始都入到另一个队列的中，只留下最后一个队尾的数据，然后再删除这个数据就可以了。</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/15/20/6HqgPFc2_o.jpg" width="678"></p> 
<p>这也是这道题中重要的思想 ，去栈顶元素可以直接用QueueBack实现，而判空就是两个队列都为空即为空，同时要注意压栈应该压入到不为空的队列中，栈顶元素返回的也是不为空的队列中的尾元素，请大家注意。</p> 
<p><strong>代码如下：</strong></p> 
<pre><code class="language-cpp">//创建包含两个队列的匿名结构体
typedef struct {
    Queue q1;
    Queue q2;
} MyStack;

//初始化这两个队列
MyStack* myStackCreate() {
    MyStack* pst = (MyStack*)malloc(sizeof(MyStack));
    QueueInit(&amp;pst-&gt;q1);
    QueueInit(&amp;pst-&gt;q2);
    return pst;
}

压栈，即压入不为空的队列中，如果都为空那就都行
void myStackPush(MyStack* obj, int x) {
    if(!QueueEmpty(&amp;obj-&gt;q1))
    {
        QueuePush(&amp;obj-&gt;q1, x);
    }
    else
    {
        QueuePush(&amp;obj-&gt;q2, x);
    }
}

//弹栈
int myStackPop(MyStack* obj) {
    //假设法，假设q1是空的，若不成立那就q2是空的
    Queue* empty = &amp;obj-&gt;q1;
    Queue* noempty = &amp;obj-&gt;q2;
    if(!QueueEmpty(empty))
    {
        empty = &amp;obj-&gt;q2;
        noempty = &amp;obj-&gt;q1;
    }
    //把不空的队列入到空队列中，并留下最后一个
    while(QueueSize(noempty) - 1)
    {
        QueuePush(empty, QueueFront(noempty));
        QueuePop(noempty);
    }
    int top = QueueFront(noempty);
    QueuePop(noempty);
    return top;
}

//取栈顶元素
int myStackTop(MyStack* obj) {
    if(!QueueEmpty(&amp;obj-&gt;q1))
    {
        return QueueBack(&amp;obj-&gt;q1);
    }
    else
    {
        return QueueBack(&amp;obj-&gt;q2);
    }
}

//判空
bool myStackEmpty(MyStack* obj) {
    return QueueEmpty(&amp;obj-&gt;q1) &amp;&amp; QueueEmpty(&amp;obj-&gt;q2);
}

//销毁栈
void myStackFree(MyStack* obj) {
    QueueDestroy(&amp;obj-&gt;q1);
    QueueDestroy(&amp;obj-&gt;q2);
    free(obj);
}
</code></pre> 
<p><img alt="" height="34" src="https://images2.imgbox.com/74/62/50yd3BiO_o.png" width="486"></p> 
<h3 id="%E9%A2%98%E7%9B%AE%E4%B8%89%EF%BC%9A%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">题目三：用栈实现队列</h3> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" rel="nofollow" title="232. 用栈实现队列 - 力扣（LeetCode）">232. 用栈实现队列 - 力扣（LeetCode）</a></p> 
<p><strong>题目描述：</strong></p> 
<p><img alt="" height="1052" src="https://images2.imgbox.com/77/5a/5BlYF0od_o.png" width="676"></p> 
<p><strong>题目分析：</strong></p> 
<p><strong> <span style="color:#1c7892;">思路1：</span></strong>和队列实现栈是基本类似的，建议大家做了第二题再看这道题。不过这里有个地方不太一样，就是Pop，在队列实现栈中，我们只需要将队列中的数据插入到另外一个队列中，再删除剩下的那一个就行了，<strong>但是栈实现队列，将栈中的数据压栈到另外的一个栈，删除栈底的那个数据后，由于顺序反了，我们还需要将另一个栈的数据再放回来才行。</strong></p> 
<p><img alt="" height="489" src="https://images2.imgbox.com/15/83/ZR7bn01x_o.jpg" width="1200"></p> 
<p>也就是这里会有区别，其他地方其实都和题目二是一样的。</p> 
<p><strong>代码如下： </strong></p> 
<pre><code class="language-cpp">//创建包含两个栈的匿名结构体
typedef struct {
    ST st1;
    ST st2;
} MyQueue;

//初始化结构体
MyQueue* myQueueCreate() {
    MyQueue* pq = (MyQueue*)malloc(sizeof(MyQueue));
    STInit(&amp;pq-&gt;st1);
    STInit(&amp;pq-&gt;st2);
    return pq;
}

//队尾入队列
void myQueuePush(MyQueue* obj, int x) {
    if(!STEmpty(&amp;obj-&gt;st1))
    {
        STPush(&amp;obj-&gt;st1, x);
    }
    else
    {
        STPush(&amp;obj-&gt;st2, x);
    }
}

//队头出队列
int myQueuePop(MyQueue* obj) {
    ST* empty = &amp;obj-&gt;st1;
    ST* noempty = &amp;obj-&gt;st2;
    if(!STEmpty(empty))
    {
        empty = &amp;obj-&gt;st2;
        noempty = &amp;obj-&gt;st1;
    }
    while(STSize(noempty) &gt; 1)
    {
        STPush(empty, STTop(noempty));
        STPop(noempty);
    }
    int top = STTop(noempty);
    STPop(noempty);
    while(STSize(empty))
    {
        STPush(noempty, STTop(empty));
        STPop(empty);
    }
    return top;
}

//获得队头数据
int myQueuePeek(MyQueue* obj) {
    ST* empty = &amp;obj-&gt;st1;
    ST* noempty = &amp;obj-&gt;st2;
    if(!STEmpty(empty))
    {
        empty = &amp;obj-&gt;st2;
        noempty = &amp;obj-&gt;st1;
    }
    while(STSize(noempty) &gt; 1)
    {
        STPush(empty, STTop(noempty));
        STPop(noempty);
    }
    int top = STTop(noempty);
    STPush(empty, STTop(noempty));
    STPop(noempty);
    while(STSize(empty))
    {
        STPush(noempty, STTop(empty));
        STPop(empty);
    }
    return top;
}

//判空
bool myQueueEmpty(MyQueue* obj) {
    return STEmpty(&amp;obj-&gt;st1) &amp;&amp; STEmpty(&amp;obj-&gt;st2);
}

//销毁队列
void myQueueFree(MyQueue* obj) {
    STDestroy(&amp;obj-&gt;st1);
    STDestroy(&amp;obj-&gt;st2);
    free(obj);</code></pre> 
<p><strong><span style="color:#1c7892;">思路2：</span></strong>除了思路1，我们其实还有另外一种方法，<strong><span style="color:#ff9900;">就是将一个栈的栈顶当做队头，入数据，另外一个栈的栈顶当做队尾，出数据：</span></strong></p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/4e/7d/9LyVEHtV_o.jpg" width="663"></p> 
<p>那么入队列就相当于将数据压入到左边的栈（pushst）中，出队列就相当于是删除右边的栈（popst）的栈顶数据，如果右边的栈中没有数据了，再把左边的栈的数据全部导入到右边，这样往复就可以了。 </p> 
<p><strong>代码如下：</strong></p> 
<pre><code class="language-cpp">//创建包含两个栈的匿名结构体
typedef struct {
    ST pushst;
    ST popst;
} MyQueue;

//初始化结构体内容
MyQueue* myQueueCreate() {
    MyQueue* pst = (MyQueue*)malloc(sizeof(MyQueue));
    STInit(&amp;pst-&gt;pushst);
    STInit(&amp;pst-&gt;popst);
    return pst;
}

//队尾入队列
void myQueuePush(MyQueue* obj, int x) {
   STPush(&amp;obj-&gt;pushst, x);//相当于压入pushst中
}

//取得队头数据
int myQueuePeek(MyQueue* obj) {
    if(STEmpty(&amp;obj-&gt;popst))//如果popst中没有数据，就把pushst中的数据导到popst中
    {
        while(!STEmpty(&amp;obj-&gt;pushst))
        {
            STPush(&amp;obj-&gt;popst, STTop(&amp;obj-&gt;pushst));
            STPop(&amp;obj-&gt;pushst);
        }
    }
    return STTop(&amp;obj-&gt;popst);
}

//队头出队列
int myQueuePop(MyQueue* obj) {
    int front = myQueuePeek(obj);//有数据，直接获取，没数据，先将pushst导入
    STPop(&amp;obj-&gt;popst);
    return front;
}

//判空
bool myQueueEmpty(MyQueue* obj) {
    return STEmpty(&amp;obj-&gt;pushst) &amp;&amp; STEmpty(&amp;obj-&gt;popst);
}

//销毁队列
void myQueueFree(MyQueue* obj) {
    STDestroy(&amp;obj-&gt;pushst);
    STDestroy(&amp;obj-&gt;popst);
    free(obj);
}</code></pre> 
<p> <img alt="" height="34" src="https://images2.imgbox.com/e1/d4/IMqxxI3P_o.png" width="486">​</p> 
<h3 id="%E9%A2%98%E7%9B%AE%E5%9B%9B%EF%BC%9A%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">题目四：设计循环队列</h3> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/design-circular-queue/description/" rel="nofollow" title="622. 设计循环队列 - 力扣（LeetCode）">622. 设计循环队列 - 力扣（LeetCode）</a></p> 
<p><strong>题目描述：</strong></p> 
<p><img alt="" height="1144" src="https://images2.imgbox.com/3f/09/KPQ1R5AI_o.png" width="684"></p> 
<p><strong>题目分析：</strong></p> 
<p><span style="color:#1c7892;"><strong> 思路：</strong></span>创建数组，利用模运算使得操作控制在0~k元素范围内，并保证tail不放数据。</p> 
<p><img alt="" height="784" src="https://images2.imgbox.com/15/fd/pNfP1gyW_o.jpg" width="1200"></p> 
<p> 我们一般的队列是用链表实现的，但是对于循环队列，数组的方法可能更好实现，链表的方法并不比数组的方法简单多少。</p> 
<pre><code class="language-cpp">//创建包含数组相关内容的匿名结构体
typedef struct {
    int* arr;
    int head;
    int tail;
    int k;
} MyCircularQueue;

//初始化结构体中的各项数据
MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* st = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    st-&gt;arr = (int*)malloc((k + 1) * sizeof(int));
    st-&gt;head = 0;
    st-&gt;tail = 0;
    st-&gt;k = k;
    return st;
}

//如果head和tail位置相同，循环队列为空
bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj-&gt;head == obj-&gt;tail;
}

//如果head在tail的下一个位置，循环队列为满
bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return obj-&gt;head == (obj-&gt;tail + 1) % (obj-&gt;k + 1); 
}

//队尾入队列
bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if(myCircularQueueIsFull(obj))
        return false;
    obj-&gt;arr[obj-&gt;tail] = value;
    obj-&gt;tail++;
    obj-&gt;tail %= (obj-&gt;k + 1);
    return true;
}

//队头出队列
bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if(myCircularQueueIsEmpty(obj))
        return false;
    obj-&gt;head++;
    obj-&gt;head %= (obj-&gt;k + 1); 
    return true;
}

//取队头数据
int myCircularQueueFront(MyCircularQueue* obj) {
    if(myCircularQueueIsEmpty(obj))
        return -1;
    else
        return obj-&gt;arr[obj-&gt;head];
}

//取队尾数据
int myCircularQueueRear(MyCircularQueue* obj) {
    if(myCircularQueueIsEmpty(obj))
        return -1;
    else
        return obj-&gt;tail == 0 ? obj-&gt;arr[obj-&gt;k] : obj-&gt;arr[obj-&gt;tail - 1];
        //return obj-&gt;arr[(obj-&gt;tail + obj-&gt;k) % (obj-&gt;k + 1)];
}

//销毁队列
void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj-&gt;arr);
    free(obj);
}</code></pre> 
<p><span style="color:#ff9900;"><strong>这道题锻炼并加深了对模运算的理解，</strong></span>对上面每个函数体中的模运算大家一定要理解清楚。那链表的方式为什么复杂呢？原因就是因为，在数组中我们取尾的前一个只要下标-1就可以了，最多再加上模运算，<span style="color:#79c6cd;"><strong>但是对于链表是不好找前一个尾节点的前一个节点的。</strong></span>当然有解决办法，如改用双向链表，或者记录tail的前一个节点prev，也可以重新遍历链表。但是这些解决方法无一不大大增加了代码的复杂度且降低了可读性，所以<span style="color:#79c6cd;"><strong>对于循环链表来说，数组的解决方法是更好的。</strong></span></p> 
<p><img alt="" height="34" src="https://images2.imgbox.com/22/29/2AXBzIMj_o.png" width="486"></p> 
<blockquote> 
 <h2 id="%C2%A0%C2%A0%E2%80%A2%F0%9F%8C%99Conclude%E7%BB%93%E5%B0%BE" style="background-color:transparent;">SUMUP结尾</h2> 
 <p><span style="color:#79c6cd;"><strong>数据结构就像数学题，需要刷题才能对它有感觉。</strong></span>之后还会更新数据结构相关的练习题、面试题，希望大家一起学习，共同进步~</p> 
 <p></p> 
 <p><span style="color:#956fe7;"><strong>如果大家觉得有帮助，麻烦大家点点赞，如果有错误的地方也欢迎大家指出~</strong></span></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2d465c9753d7c1d1ff0943e31e539364/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AIGC】Diffusers:加载管道、模型和调度程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1028fec28fc399d4d9418054775f3b11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">随心笔记，第四更</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>