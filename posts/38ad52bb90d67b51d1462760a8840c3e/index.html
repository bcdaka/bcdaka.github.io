<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>three.js官方案例webgl_loader_fbx.html学习 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/38ad52bb90d67b51d1462760a8840c3e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="three.js官方案例webgl_loader_fbx.html学习">
  <meta property="og:description" content="目录
1.1 添加库引入
1.2 添加必要的组件scene,camera,webrenderer等
1.3 模型加载
1.4 半球光
1.5 动画
1.6 换个自己的fbx模型
1.7 fbx模型和fbx动画关联
1.7 html脚本全部如下
1.8 fbx.js全部脚本如下
1.1 添加库引入 import * as THREE from &#39;three&#39;; import Stats from &#39;three/addons/libs/stats.module.js&#39;; //控制器 import { OrbitControls } from &#39;three/addons/controls/OrbitControls.js&#39;; //fbx模型加载器 import { FBXLoader } from &#39;three/addons/loaders/FBXLoader.js&#39;; 1.2 添加必要的组件scene,camera,webrenderer等 先创建必要的场景scene,相机camera，渲染器webrenderer，控制器controls和灯光DirectionalLight. 性能检测stars， 地面， 网格
自定义属性
let camera, scene, renderer, stats;
function init() { const container = document.createElement( &#39;div&#39; ); document.body.appendChild( container ); //相机 camera = new THREE.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T23:00:00+08:00">
    <meta property="article:modified_time" content="2024-05-27T23:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">three.js官方案例webgl_loader_fbx.html学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="1.1%20%E6%B7%BB%E5%8A%A0%E5%BA%93%E5%BC%95%E5%85%A5-toc" style="margin-left:40px;"><a href="#1.1%20%E6%B7%BB%E5%8A%A0%E5%BA%93%E5%BC%95%E5%85%A5" rel="nofollow">1.1 添加库引入</a></p> 
<p id="1.1%20%E6%B7%BB%E5%8A%A0%E5%BF%85%E8%A6%81%E7%9A%84%E7%BB%84%E4%BB%B6scene%2Ccamera%2Cwebrenderer%E7%AD%89-toc" style="margin-left:40px;"><a href="#1.1%20%E6%B7%BB%E5%8A%A0%E5%BF%85%E8%A6%81%E7%9A%84%E7%BB%84%E4%BB%B6scene%2Ccamera%2Cwebrenderer%E7%AD%89" rel="nofollow">1.2 添加必要的组件scene,camera,webrenderer等</a></p> 
<p id="1.3%20%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD-toc" style="margin-left:40px;"><a href="#1.3%20%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD" rel="nofollow">1.3 模型加载</a></p> 
<p id="1.4%20%E5%8D%8A%E7%90%83%E5%85%89-toc" style="margin-left:40px;"><a href="#1.4%20%E5%8D%8A%E7%90%83%E5%85%89" rel="nofollow">1.4 半球光</a></p> 
<p id="1.5%20%E5%8A%A8%E7%94%BB-toc" style="margin-left:40px;"><a href="#1.5%20%E5%8A%A8%E7%94%BB" rel="nofollow">1.5 动画</a></p> 
<p id="1.6%20%E6%8D%A2%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84fbx%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#1.6%20%E6%8D%A2%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84fbx%E6%A8%A1%E5%9E%8B" rel="nofollow">1.6 换个自己的fbx模型</a></p> 
<p id="1.7%20fbx%E6%A8%A1%E5%9E%8B%E5%92%8Cfbx%E5%8A%A8%E7%94%BB%E5%85%B3%E8%81%94-toc" style="margin-left:40px;"><a href="#1.7%20fbx%E6%A8%A1%E5%9E%8B%E5%92%8Cfbx%E5%8A%A8%E7%94%BB%E5%85%B3%E8%81%94" rel="nofollow">1.7 fbx模型和fbx动画关联</a></p> 
<p id="1.7%20html%E8%84%9A%E6%9C%AC%E5%85%A8%E9%83%A8%E5%A6%82%E4%B8%8B-toc" style="margin-left:40px;"><a href="#1.7%20html%E8%84%9A%E6%9C%AC%E5%85%A8%E9%83%A8%E5%A6%82%E4%B8%8B" rel="nofollow">1.7 html脚本全部如下</a></p> 
<p id="1.8%20fbx.js%E5%85%A8%E9%83%A8%E8%84%9A%E6%9C%AC%E5%A6%82%E4%B8%8B-toc" style="margin-left:40px;"><a href="#1.8%20fbx.js%E5%85%A8%E9%83%A8%E8%84%9A%E6%9C%AC%E5%A6%82%E4%B8%8B" rel="nofollow">1.8 fbx.js全部脚本如下</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1.1%20%E6%B7%BB%E5%8A%A0%E5%BA%93%E5%BC%95%E5%85%A5">1.1 添加库引入</h3> 
<pre><code class="language-javascript">import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
 //控制器
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 //fbx模型加载器
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';</code></pre> 
<p></p> 
<h3 id="1.1%20%E6%B7%BB%E5%8A%A0%E5%BF%85%E8%A6%81%E7%9A%84%E7%BB%84%E4%BB%B6scene%2Ccamera%2Cwebrenderer%E7%AD%89">1.2 添加必要的组件scene,camera,webrenderer等</h3> 
<p>      先创建必要的场景scene,相机camera，渲染器webrenderer，控制器controls和灯光DirectionalLight.   性能检测stars，  地面， 网格</p> 
<p>自定义属性</p> 
<p>let camera, scene, renderer, stats;</p> 
<pre><code class="language-javascript">	function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );
                //相机
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 100, 200, 300 );
                //场景
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xa0a0a0 );
				scene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );//雾
            
                //灯 模拟太阳光
				const dirLight = new THREE.DirectionalLight( 0xffffff, 5 );
				dirLight.position.set( 0, 200, 100 );
				dirLight.castShadow = true;//此属性设置为 true 灯光将投射阴影 注意：这样做的代价比较高，需要通过调整让阴影看起来正确。 查看 DirectionalLightShadow 了解详细信息。 默认值为 false
                //dirLight.shadow 为DirectionalLightShadow 对象，用于计算该平行光产生的阴影
                //.camera 在光的世界里。这用于生成场景的深度图;从光的角度来看，其他物体背后的物体将处于阴影中
				dirLight.shadow.camera.top = 180;
				dirLight.shadow.camera.bottom = - 100;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );

				

				// ground  地面
				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );
                //网格
				const grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
				grid.material.opacity = 0.2;
				grid.material.transparent = true;
				scene.add( grid );


                //WEBGL渲染器
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;//
				container.appendChild( renderer.domElement );
                //控制器
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 100, 0 );
				controls.update();
              
				// stats 性能检测
				stats = new Stats();
				container.appendChild( stats.dom );
   
			}</code></pre> 
<p><img alt="" height="870" src="https://images2.imgbox.com/c5/2b/qXqSfZkK_o.png" width="860"></p> 
<h3 id="1.3%20%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD">1.3 模型加载</h3> 
<pre><code class="language-javascript">function fbxLoad(path){
     // model  加载模型
	const loader = new FBXLoader();
	loader.load( path, function ( object ) {
    console.log(object);
    //动画混合器
	mixer = new THREE.AnimationMixer( object );
    // 返回所传入的剪辑参数的AnimationAction, 根对象参数可选，默认值为混合器的默认根对象。第一个参数可以是动画剪辑(AnimationClip)对象或者动画剪辑的名称
	const action = mixer.clipAction( object.animations[ 0 ] );
	action.play();//动画播放

	object.traverse( function ( child ) {

		if ( child.isMesh ) {

		child.castShadow = true;//对象是否被渲染到阴影贴图中。默认值为false
		child.receiveShadow = true;//材质是否接收阴影。默认值为false

		}

		} );

	scene.add( object );

	} );
}</code></pre> 
<p><img alt="" height="150" src="https://images2.imgbox.com/b2/26/4TY4dIn4_o.png" width="689"></p> 
<p>打印的模型信息如下：<img alt="" height="616" src="https://images2.imgbox.com/d8/68/sYkZTAXp_o.png" width="819"></p> 
<p><img alt="" height="821" src="https://images2.imgbox.com/81/09/o5b18tKh_o.png" width="785"></p> 
<h3 id="1.4%20%E5%8D%8A%E7%90%83%E5%85%89">1.4 半球光</h3> 
<p>HemisphereLight( skyColor : Integer, groundColor : Integer, intensity : Float )</p> 
<p><a href="http://127.0.0.1/ThreeJs/three.js-r163/docs/index.html#api/zh/math/Color" rel="nofollow" title="skyColor">skyColor</a> -（可选）一个表示颜色的 Color 的实例、字符串或数字，默认为一个白色（0xffffff）的 <a href="http://127.0.0.1/ThreeJs/three.js-r163/docs/index.html#api/zh/math/Color" rel="nofollow" title="Color">Color</a> 对象。<br><a href="http://127.0.0.1/ThreeJs/three.js-r163/docs/index.html#api/zh/math/Color" rel="nofollow" title="groundColor">groundColor</a> -（可选）一个表示颜色的 Color 的实例、字符串或数字，默认为一个白色（0xffffff）的 <a href="http://127.0.0.1/ThreeJs/three.js-r163/docs/index.html#api/zh/math/Color" rel="nofollow" title="Color">Color</a> 对象。<br>intensity -（可选）光照强度。默认值为 1</p> 
<pre><code class="language-javascript">//灯 半球光
//光源直接放置于场景之上，光照颜色从天空光线颜色渐变到地面光线颜色
const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 5 );
hemiLight.position.set( 0, 200, 0 );
scene.add( hemiLight );</code></pre> 
<p>加上这个光后，模型明显变量了。<img alt="" height="839" src="https://images2.imgbox.com/77/ca/hgMW84qj_o.png" width="726"></p> 
<h3 id="1.5%20%E5%8A%A8%E7%94%BB">1.5 动画</h3> 
<pre><code class="language-javascript">function animate() {

requestAnimationFrame( animate );
//获取自 .oldTime 设置后到当前的秒数。 同时将 .oldTime 设置为当前时间。
//如果 .autoStart 设置为 true 且时钟并未运行，则该方法同时启动时钟
				const delta = clock.getDelta();//

if ( mixer ) mixer.update( delta );//动画更新

renderer.render( scene, camera );

stats.update();//性能监视器更新

}
init();
animate();</code></pre> 
<h3 id="1.6%20%E6%8D%A2%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84fbx%E6%A8%A1%E5%9E%8B">1.6 换个自己的fbx模型</h3> 
<pre><code class="language-javascript"> fbxLoad('../Models/ren/Arisa/Arisa.fbx');</code></pre> 
<p><img alt="" height="143" src="https://images2.imgbox.com/b1/61/G7lomSO5_o.png" width="363"></p> 
<p>这里模型加载进去小，所以进行了放大100</p> 
<pre><code class="language-javascript">      function fbxLoad(path){
                // model  加载模型
				const loader = new FBXLoader();
				loader.load( path, function ( object ) {
                    console.log(object);
                    //动画混合器
					mixer = new THREE.AnimationMixer( object );
                   // 返回所传入的剪辑参数的AnimationAction, 根对象参数可选，默认值为混合器的默认根对象。第一个参数可以是动画剪辑(AnimationClip)对象或者动画剪辑的名称
                   if(object.animations&gt;0){
                    const action = mixer.clipAction( object.animations[ 0 ] );
					action.play();//动画播放
                   }
					
					object.traverse( function ( child ) {

						if ( child.isMesh ) {

							child.castShadow = true;//对象是否被渲染到阴影贴图中。默认值为false
							child.receiveShadow = true;//材质是否接收阴影。默认值为false

						}

					} );
                    object.position.set(0,0,0);
					object.scale.set(100,100,100);
					scene.add( object );

				} );
            }</code></pre> 
<p><span style="color:#fe2c24;">注意：需要把贴图和fbx放入同一个文件下</span><img alt="" height="533" src="https://images2.imgbox.com/d6/4a/G2aPJHOj_o.png" width="959"></p> 
<p><img alt="" height="1053" src="https://images2.imgbox.com/1b/7c/gz5JNDzA_o.png" width="1200"></p> 
<h3 id="1.7%20fbx%E6%A8%A1%E5%9E%8B%E5%92%8Cfbx%E5%8A%A8%E7%94%BB%E5%85%B3%E8%81%94">1.7 fbx模型和fbx动画关联</h3> 
<p>如果模型和动画不在一个文件里，比如模型是一个fbx,动画是另一个fbx，需要这么加载：</p> 
<pre><code>function fbxLoad(path,aniPath){
                // model  加载模型
				const loader = new FBXLoader();
				loader.load( path, function ( object ) {
                    console.log(object);
                    //动画混合器
					mixer = new THREE.AnimationMixer( object );
                   // 返回所传入的剪辑参数的AnimationAction, 根对象参数可选，默认值为混合器的默认根对象。第一个参数可以是动画剪辑(AnimationClip)对象或者动画剪辑的名称
                //    if(object.animations&gt;0){
                //     const action = mixer.clipAction( object.animations[ 0 ] );
				// 	action.play();//动画播放
                //    }
					
					object.traverse( function ( child ) {

						if ( child.isMesh ) {

							child.castShadow = true;//对象是否被渲染到阴影贴图中。默认值为false
							child.receiveShadow = true;//材质是否接收阴影。默认值为false

						}

					} );
                    object.position.set(0,0,0);
					//object.scale.set(100,100,100);
					scene.add( object );

                     
					const clips={};
					const actions={};
					//加载动画
					loader.load(aniPath,(animations)=&gt;{
						console.log(animations);
						animations.animations.forEach((clip)=&gt;{
							clips[clip.name]=clip;
							actions[clip.name]=mixer.clipAction(clip);
						});
						actions['Take 001'].play(); 
					}) ;  
					             
				} );
            }</code></pre> 
<p>针对后缀的anim的动画文件，目前是需要这么解决<img alt="" height="244" src="https://images2.imgbox.com/8a/9a/N0yoxieX_o.png" width="743"></p> 
<p>我找了个之前Unity工程里用的人物模型，一个fbx里包含了8种风格的人物 和他的6个动作fbx：</p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/56/d6/RDG7kN0E_o.png" width="227"></p> 
<p>为了切换不同人物和不同的动画，增加了一个UI模块：</p> 
<p><img alt="" height="765" src="https://images2.imgbox.com/d7/1f/WYgU0GkS_o.png" width="730"></p> 
<p><img alt="" height="117" src="https://images2.imgbox.com/6a/dc/8KoiRCjd_o.png" width="960"></p> 
<p>把模型和动画加载的函数重构了下：</p> 
<pre><code class="language-javascript"> // model  加载模型
            function fbxLoad(path,aniPath,type){
				 //移除已有的
				 while ( root.children.length &gt; 0 ) {

					const object = root.children[ 0 ];
					object.parent.remove( object );

				}                				
				container.style.display='block';
				percenDiv.style.width=0+"px";//进度条元素长度0
				percenDiv.style.textIndent=0+5+"px";//缩进元素中的首行文本0
				percenDiv.innerHTML=Math.floor(0) +"%";//进度百分比0
				//开始加载
				loader.load( path, function ( object ) {
                    console.log(object);					
					container.style.display='none';					
                    //动画混合器
					mixer = new THREE.AnimationMixer(object);
                   // 返回所传入的剪辑参数的AnimationAction, 根对象参数可选，默认值为混合器的默认根对象。第一个参数可以是动画剪辑(AnimationClip)对象或者动画剪辑的名称
                  //    if(object.animations&gt;0){
                  //     const action = mixer.clipAction( object.animations[ 0 ] );
				  // 	action.play();//动画播放
                   //    }
				   object.position.set(0,0,0);
				   //object.scale.set(100,100,100);
				   root.add( object );

				   ChangePerson2(currenPersonType);
					// object.traverse( function ( child ) {                       
					// 	if ( child.isMesh ) {
					// 		ChangePerson(child,currenPersonType);
					// 		child.castShadow = true;//对象是否被渲染到阴影贴图中。默认值为false
					// 		child.receiveShadow = true;//材质是否接收阴影。默认值为false
							
					// 	}						
					// } );
                 					
					//加载动画
					LoadPersonAnimation(aniPath);
					// loader.load(aniPath,(animations)=&gt;{
					// 	let clipName;
					// 	console.log(animations);
					// 	animations.animations.forEach((clip)=&gt;{
					// 		clips[clip.name]=clip;
					// 		actions[clip.name]=mixer.clipAction(clip);
					// 		clipName=clip.name;
					// 	});
					// 	actions[clipName].play(); 
					// }) ;  
					             
				},function(xhr){
					const percent=xhr.loaded/xhr.total;  
					percenDiv.style.width=percent*400+"px";//进度条元素长度
					percenDiv.style.textIndent=percent*400+5+"px";//缩进元素中的首行文本
					percenDiv.innerHTML=Math.floor(percent*100) +"%";//进度百分比
				} );
            }

			 //加载动画fbx
			 function LoadPersonAnimation(aniPath){
				mixer.stopAllAction ();//停用混合器上所有预定的动作
				loader.load(aniPath,(animations)=&gt;{
					let clipName;
					console.log(animations);
					animations.animations.forEach((clip)=&gt;{
						clips[clip.name]=clip;
						//clipAction返回所传入的剪辑参数的AnimationAction, 根对象参数可选，默认值为混合器的默认根对象。第一个参数可以是动画剪辑(AnimationClip)对象或者动画剪辑的名称。如果不存在符合传入的剪辑和根对象这两个参数的动作, 该方法将会创建一个。传入相同的参数多次调用将会返回同一个剪辑实例。
						actions[clip.name]=mixer.clipAction(clip);
						clipName=clip.name;
					});
					actions[clipName].play(); 
				}) ;  
			 }</code></pre> 
<p>UI监听的两函数：</p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/2f/e6/UmbqW8ZO_o.png" width="680"></p> 
<h3 id="1.7%20html%E8%84%9A%E6%9C%AC%E5%85%A8%E9%83%A8%E5%A6%82%E4%B8%8B">1.7 html脚本全部如下</h3> 
<p>   里面加了一个进度条，这部分我也不是很了解，脚本如下：</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
		&lt;title&gt;three.js webgl - FBX loader&lt;/title&gt;
		&lt;meta charset="utf-8"&gt;
		&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
		&lt;link type="text/css" rel="stylesheet" href="../three.js-r163/examples/main.css"&gt;



		&lt;style&gt;
/* 进度条css样式*/
#container{
		   position: absolute;
		   width: 400px;
		   height: 16px;
		   top: 50%;
		   left: 50%;
		   margin-left: -200px;
		   margin-top: -8px;
		   border-radius: 8px;
		   border: 1px solid #009999;
		   overflow: hidden;

	   }
	   #per{
		   height: 100px;
		   width: 0px;
		   background: #00ffff;
		   color: #00ffff;
		   line-height: 15px;
	   }
		&lt;/style&gt;
		


	&lt;/head&gt;

	&lt;body&gt;
		&lt;div id="info"&gt;
			&lt;a href="https://threejs.org" target="_blank" rel="noopener"&gt;three.js&lt;/a&gt; - FBXLoader&lt;br /&gt;
			Character and animation from &lt;a href="https://www.mixamo.com/" target="_blank" rel="noopener"&gt;Mixamo&lt;/a&gt;
		&lt;/div&gt;

		&lt;div id="container"&gt;
			&lt;!--进度条--&gt;
			&lt;div id="per"&gt;&lt;/div&gt;
		&lt;/div&gt;
		
		&lt;script type="importmap"&gt;
			{
				"imports": {
                    "three": "../three.js-r163/build/three.module.js",  
                    "three/addons/":"../three.js-r163/examples/jsm/"  
				}
			}
		&lt;/script&gt;

		&lt;script type="module" src="fbx.js"&gt;
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h3 id="1.8%20fbx.js%E5%85%A8%E9%83%A8%E8%84%9A%E6%9C%AC%E5%A6%82%E4%B8%8B">1.8 fbx.js全部脚本如下</h3> 
<pre><code class="language-javascript">import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
 //控制器
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 //fbx模型加载器
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
 //引入ui库
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			let camera, scene, renderer, stats;

			const clock = new THREE.Clock();//该对象用于跟踪时间

			let mixer;//动画混合器
            let gui;//ui
			let root;//模型的父物体
			const percenDiv=document.getElementById('per');//获取进度条元素
			const container=document.getElementById('container');//获取进度条元素背景
			//不同人物对象
				 const Persons = {
					'人物1': '01',
					'人物2': '02',
					'人物3': '03',
					'人物4': '04',
					'人物5': '05',
					'人物6': '06',
					'人物7': '07',
					'人物8': '08',				
				};
	
				const params = {
					molecule: '01',
					currentAni:'idle',
				};

				//不同的动画
                const PersonAnis={
					'idle':'idle',
					'Asking Question':'Asking Question',
					'Clapping':'Clapping',
					'Running':'Running',
					'sit':'sit',
					'sit_Clapping':'sit_Clapping',
					'Waving':'Waving'
				}
				
				let  currenPersonType='01';;//当前人物
				let  currentPersonAni='idle';//当前动画
	
			const loader = new FBXLoader();//模型加载器
			const clips={};
			const actions={};

			function init() {
				
				const container = document.createElement( 'div' );
				document.body.appendChild( container );
                //相机
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 100, 200, 300 );
                //场景
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xa0a0a0 );
				scene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );//雾
            
                //灯 模拟太阳光
				const dirLight = new THREE.DirectionalLight( 0xffffff, 5 );
				dirLight.position.set( 0, 200, 100 );
				dirLight.castShadow = true;//此属性设置为 true 灯光将投射阴影 注意：这样做的代价比较高，需要通过调整让阴影看起来正确。 查看 DirectionalLightShadow 了解详细信息。 默认值为 false
                //dirLight.shadow 为DirectionalLightShadow 对象，用于计算该平行光产生的阴影
                //.camera 在光的世界里。这用于生成场景的深度图;从光的角度来看，其他物体背后的物体将处于阴影中
				dirLight.shadow.camera.top = 180;
				dirLight.shadow.camera.bottom = - 100;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );

				root=new THREE.Group();
                scene.add(root);
				

				// ground  地面
				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;//接收阴影
				scene.add( mesh );
                //网格
				const grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
				grid.material.opacity = 0.2;
				grid.material.transparent = true;
				scene.add( grid );


                //WEBGL渲染器
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;//
				container.appendChild( renderer.domElement );
                //控制器
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 100, 0 );
				controls.update();
              
				// stats 性能检测
				stats = new Stats();
				container.appendChild( stats.dom );

				//                   //窗口大小更改监听
             	window.addEventListener( 'resize', onWindowResize );

                //fbxLoad('../Models/Arisa/Arisa.fbx');

				fbxLoad('../Models/ren/man.fbx','../Models/ren/idle.fbx','01');
			   

                             //灯 半球光
                             //光源直接放置于场景之上，光照颜色从天空光线颜色渐变到地面光线颜色
				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 5 );
				hemiLight.position.set( 0, 200, 0 );
				scene.add( hemiLight );
                //scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

                //ui部分
				gui=new GUI();
				gui.add( params, 'molecule', Persons).onChange( ChangePerson2 );//切换不同的人物模型
				gui.add( params, 'currentAni', PersonAnis).onChange( ChangePersonAni );//切换不同的人物模型
				gui.open(); 
			}

         
           
            // model  加载模型
            function fbxLoad(path,aniPath,type){
				 //移除已有的
				 while ( root.children.length &gt; 0 ) {

					const object = root.children[ 0 ];
					object.parent.remove( object );

				}                				
				container.style.display='block';
				percenDiv.style.width=0+"px";//进度条元素长度0
				percenDiv.style.textIndent=0+5+"px";//缩进元素中的首行文本0
				percenDiv.innerHTML=Math.floor(0) +"%";//进度百分比0
				//开始加载
				loader.load( path, function ( object ) {
                    console.log(object);					
					container.style.display='none';					
                    //动画混合器
					mixer = new THREE.AnimationMixer(object);
                   // 返回所传入的剪辑参数的AnimationAction, 根对象参数可选，默认值为混合器的默认根对象。第一个参数可以是动画剪辑(AnimationClip)对象或者动画剪辑的名称
                  //    if(object.animations&gt;0){
                  //     const action = mixer.clipAction( object.animations[ 0 ] );
				  // 	action.play();//动画播放
                   //    }
				   object.position.set(0,0,0);
				   //object.scale.set(100,100,100);
				   root.add( object );

				   ChangePerson2(currenPersonType);
					// object.traverse( function ( child ) {                       
					// 	if ( child.isMesh ) {
					// 		ChangePerson(child,currenPersonType);
					// 		child.castShadow = true;//对象是否被渲染到阴影贴图中。默认值为false
					// 		child.receiveShadow = true;//材质是否接收阴影。默认值为false
							
					// 	}						
					// } );
                 					
					//加载动画
					LoadPersonAnimation(aniPath);
					// loader.load(aniPath,(animations)=&gt;{
					// 	let clipName;
					// 	console.log(animations);
					// 	animations.animations.forEach((clip)=&gt;{
					// 		clips[clip.name]=clip;
					// 		actions[clip.name]=mixer.clipAction(clip);
					// 		clipName=clip.name;
					// 	});
					// 	actions[clipName].play(); 
					// }) ;  
					             
				},function(xhr){
					const percent=xhr.loaded/xhr.total;  
					percenDiv.style.width=percent*400+"px";//进度条元素长度
					percenDiv.style.textIndent=percent*400+5+"px";//缩进元素中的首行文本
					percenDiv.innerHTML=Math.floor(percent*100) +"%";//进度百分比
				} );
            }

			 //加载动画fbx
			 function LoadPersonAnimation(aniPath){
				mixer.stopAllAction ();//停用混合器上所有预定的动作
				loader.load(aniPath,(animations)=&gt;{
					let clipName;
					console.log(animations);
					animations.animations.forEach((clip)=&gt;{
						clips[clip.name]=clip;
						//clipAction返回所传入的剪辑参数的AnimationAction, 根对象参数可选，默认值为混合器的默认根对象。第一个参数可以是动画剪辑(AnimationClip)对象或者动画剪辑的名称。如果不存在符合传入的剪辑和根对象这两个参数的动作, 该方法将会创建一个。传入相同的参数多次调用将会返回同一个剪辑实例。
						actions[clip.name]=mixer.clipAction(clip);
						clipName=clip.name;
					});
					actions[clipName].play(); 
				}) ;  
			 }

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			//
			function animate() {
				requestAnimationFrame( animate );
              //获取自 .oldTime 设置后到当前的秒数。 同时将 .oldTime 设置为当前时间。
//如果 .autoStart 设置为 true 且时钟并未运行，则该方法同时启动时钟
				const delta = clock.getDelta();//
				if ( mixer ) mixer.update( delta );//推进混合器时间并更新动画
				renderer.render( scene, camera );
				stats.update();//性能监视器更新
			}
            init();
			animate();


			// function ChangePerson(child,type){
			// 	currenPersonType=type;
			// 	//fbxLoad('../Models/ren/man.fbx','../Models/ren/'+currentPersonAni+'.fbx',type);
			// 	if(child.name.includes(type)){
			// 		console.log(child.name);

			// 		//这里如果是clone  导致切换时不显示
			// 		child.copy(child).visible=true;
			// 	}else{
			// 		child.visible=false;
			// 	}
			// }

            //切换人物
			function ChangePerson2(type){
				currenPersonType=type;           
				root.traverse( function ( child ) {                       
					if ( child.isMesh ) {
						//ChangePerson(child,type);
						if(child.name.includes(type)){
							console.log(child.name);
							//这里如果是clone  导致切换时不显示
							child.copy(child).visible=true;
						}else{
							child.visible=false;
						}											
					}						
				} );
			}
            //切换人物动画
			function ChangePersonAni(Anitype){
				currentPersonAni=Anitype;
				LoadPersonAnimation('../Models/ren/'+Anitype+'.fbx');								
			}

		
</code></pre> 
<p><img alt="" height="328" src="https://images2.imgbox.com/6e/cf/QzkBrOdU_o.png" width="919"></p> 
<p>运行结果：<img alt="" height="1112" src="https://images2.imgbox.com/a3/3a/kv91bXlr_o.png" width="1039"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/84/QnU3N2BF_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cf968f396c987e5965008edb789c6066/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电脑找不到opencl.dll原因分析及5种详细的解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98e00a77ac371991ce686311f2080403/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">已解决java.lang.annotation.AnnotationFormatError: 注解格式错误的正确解决方法，亲测有效！！！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>