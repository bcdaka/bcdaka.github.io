<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Sql Server】使用row_number over方式进行表分页，数据量达到五千多条记录后，查询变慢需要20多秒的解决方案 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/90ad5296efd08b2e1b774a8273f71e1f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Sql Server】使用row_number over方式进行表分页，数据量达到五千多条记录后，查询变慢需要20多秒的解决方案">
  <meta property="og:description" content="大家好，我是全栈小5，欢迎来到《小5讲堂》。
这是《Sql Server》系列文章，每篇文章将以博主理解的角度展开讲解。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 前言单字段查询多字段查询知识点基本语法分页查询示例示例 SQL 查询 解释注意事项 文章推荐 前言 最近创建了一张表，用于保存名称相关信息。
刚开始是没有加任何索引，数据不多时查询也没什么问题。
等到了表有5千多条记录后，查询变得很慢，设置需要二十多秒。
一起来看下这个博主是如何解决的？或者你们是否有更好的解决方案呢？也欢迎评论区留言。
单字段查询 刚开始给status字段设置索引，没效果。
直接再给time字段添加索引，有效果，查询秒出。
设置索引是占用一定物理空间大小，所以用物理空间大小还速度
1）单字段索引（适合单个字段排序或查询）
2）多字段索引（适合多个字段排序或查询）
【单字段查询】
-- CREATE INDEX time_index ON 目标表 (time) -- 设置表字段索引 select count(1) from 目标表 select * from ( select row_number() over(order by t.time) as rowindex,t.* from ( select * from 目标表 where status=10 ) t ) new_table where rowindex&gt;((1-1)*10) and rowindex&lt;=1*10; 温馨提示：当你的表数据很多的时候，不建议在可视化工具进行索引设置。可通过sql语句的方式
CREATE INDEX 索引名 ON 目标表 (字段1，字段2.。。)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-23T09:09:30+08:00">
    <meta property="article:modified_time" content="2024-08-23T09:09:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Sql Server】使用row_number over方式进行表分页，数据量达到五千多条记录后，查询变慢需要20多秒的解决方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>大家好，我是全栈小5，欢迎来到《小5讲堂》。<br> 这是《Sql Server》系列文章，每篇文章将以博主理解的角度展开讲解。<br> 温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/63/45/F8nms3NG_o.png" alt="在这里插入图片描述"><br> </p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#_13" rel="nofollow">单字段查询</a></li><li><a href="#_40" rel="nofollow">多字段查询</a></li><li><a href="#_56" rel="nofollow">知识点</a></li><li><ul><li><a href="#_59" rel="nofollow">基本语法</a></li><li><a href="#_68" rel="nofollow">分页查询示例</a></li><li><ul><li><a href="#_SQL__72" rel="nofollow">示例 SQL 查询</a></li></ul> 
   </li><li><a href="#_91" rel="nofollow">解释</a></li><li><a href="#_97" rel="nofollow">注意事项</a></li></ul> 
  </li><li><a href="#_114" rel="nofollow">文章推荐</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_7"></a>前言</h2> 
<p>最近创建了一张表，用于保存名称相关信息。<br> 刚开始是没有加任何索引，数据不多时查询也没什么问题。<br> 等到了表有5千多条记录后，查询变得很慢，设置需要二十多秒。<br> 一起来看下这个博主是如何解决的？或者你们是否有更好的解决方案呢？也欢迎评论区留言。</p> 
<h2><a id="_13"></a>单字段查询</h2> 
<p>刚开始给status字段设置索引，没效果。<br> 直接再给time字段添加索引，有效果，查询秒出。</p> 
<p>设置索引是占用一定物理空间大小，所以用物理空间大小还速度<br> 1）单字段索引（适合单个字段排序或查询）<br> 2）多字段索引（适合多个字段排序或查询）</p> 
<p>【单字段查询】</p> 
<pre><code class="prism language-sql"><span class="token comment">-- CREATE INDEX time_index ON 目标表 (time) -- 设置表字段索引</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> 目标表

 <span class="token keyword">select</span> <span class="token operator">*</span> 
 <span class="token keyword">from</span> <span class="token punctuation">(</span>
     <span class="token keyword">select</span> row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> 
     <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> t<span class="token punctuation">.</span><span class="token keyword">time</span><span class="token punctuation">)</span> <span class="token keyword">as</span> rowindex<span class="token punctuation">,</span>t<span class="token punctuation">.</span><span class="token operator">*</span> 
     <span class="token keyword">from</span> <span class="token punctuation">(</span>
         <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 目标表 <span class="token keyword">where</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">10</span>
     <span class="token punctuation">)</span> t
 <span class="token punctuation">)</span> new_table
 <span class="token keyword">where</span> rowindex<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">and</span> rowindex<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> 
<p>温馨提示：当你的表数据很多的时候，不建议在可视化工具进行索引设置。可通过sql语句的方式</p> 
<blockquote> 
 <p>CREATE INDEX 索引名 ON 目标表 (字段1，字段2.。。)</p> 
</blockquote> 
<h2><a id="_40"></a>多字段查询</h2> 
<p>【多字段查询】<br> 支持模糊查询，字段status和name字段组合索引，查询秒出</p> 
<blockquote> 
 <p>where status=10 and name like’%张%’</p> 
</blockquote> 
<pre><code class="prism language-sql"> <span class="token keyword">select</span> <span class="token operator">*</span> 
 <span class="token keyword">from</span> <span class="token punctuation">(</span>
     <span class="token keyword">select</span> row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> 
     <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> t<span class="token punctuation">.</span><span class="token keyword">time</span><span class="token punctuation">)</span> <span class="token keyword">as</span> rowindex<span class="token punctuation">,</span>t<span class="token punctuation">.</span><span class="token operator">*</span> 
     <span class="token keyword">from</span> <span class="token punctuation">(</span>
         <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 目标表 <span class="token keyword">where</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">10</span> <span class="token operator">and</span> name <span class="token operator">like</span><span class="token string">'%张%'</span>
     <span class="token punctuation">)</span> t
 <span class="token punctuation">)</span> new_table
 <span class="token keyword">where</span> rowindex<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">and</span> rowindex<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_56"></a>知识点</h2> 
<p>在 SQL Server 中，<code>ROW_NUMBER()</code> 函数用于为结果集中的每一行分配一个唯一的顺序号。这是一个非常有用的函数，尤其是在分页查询中。以下是有关 <code>ROW_NUMBER()</code> 函数的一些基本说明：</p> 
<h3><a id="_59"></a>基本语法</h3> 
<pre><code class="prism language-sql">ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> partition_expression <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> order_expression<span class="token punctuation">)</span> <span class="token keyword">AS</span> row_number
</code></pre> 
<ul><li><code>PARTITION BY partition_expression</code>：可选项，用于将数据分成不同的组。对于每个组，<code>ROW_NUMBER()</code> 函数将重新开始计数。如果不使用 <code>PARTITION BY</code>，则对整个结果集应用计数。</li><li><code>ORDER BY order_expression</code>：指定排序的列，<code>ROW_NUMBER()</code> 函数将根据这个排序规则分配行号。</li></ul> 
<h3><a id="_68"></a>分页查询示例</h3> 
<p>假设我们有一个员工表 <code>Employees</code>，包含以下字段：<code>EmployeeID</code>, <code>Name</code>, 和 <code>Salary</code>。我们希望对这个表进行分页查询，每页显示 10 条记录，且按薪资降序排序。可以使用 <code>ROW_NUMBER()</code> 函数来实现这一点。</p> 
<h4><a id="_SQL__72"></a>示例 SQL 查询</h4> 
<pre><code class="prism language-sql"><span class="token keyword">WITH</span> EmployeeRank <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> 
        EmployeeID<span class="token punctuation">,</span>
        Name<span class="token punctuation">,</span>
        Salary<span class="token punctuation">,</span>
        ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> RowNum
    <span class="token keyword">FROM</span> Employees
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> 
    EmployeeID<span class="token punctuation">,</span>
    Name<span class="token punctuation">,</span>
    Salary
<span class="token keyword">FROM</span> EmployeeRank
<span class="token keyword">WHERE</span> RowNum <span class="token operator">BETWEEN</span> <span class="token number">11</span> <span class="token operator">AND</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_91"></a>解释</h3> 
<ol><li> <p><strong>CTE（公共表表达式）定义</strong>：我们创建了一个名为 <code>EmployeeRank</code> 的 CTE，其中包含 <code>ROW_NUMBER()</code> 函数来为每一行分配一个行号。排序规则是按 <code>Salary</code> 列降序排列。</p> </li><li> <p><strong>分页查询</strong>：在外部查询中，我们通过 <code>WHERE RowNum BETWEEN 11 AND 20</code> 来提取第 2 页的数据（假设每页 10 条记录）。你可以根据需要调整 <code>BETWEEN</code> 的范围来获取不同页的数据。</p> </li></ol> 
<h3><a id="_97"></a>注意事项</h3> 
<ul><li> <p><strong>性能</strong>：使用 <code>ROW_NUMBER()</code> 函数可能对性能有一定影响，尤其是在处理大型数据集时。确保对排序列进行适当的索引，以优化性能。</p> </li><li> <p><strong>偏移量和限制</strong>：在 SQL Server 2012 及以后的版本中，可以使用 <code>OFFSET-FETCH</code> 子句实现分页查询，这通常更简洁，也可以提高性能。示例如下：</p> <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> 
    EmployeeID<span class="token punctuation">,</span>
    Name<span class="token punctuation">,</span>
    Salary
<span class="token keyword">FROM</span> Employees
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span>
<span class="token keyword">OFFSET</span> <span class="token number">10</span> <span class="token keyword">ROWS</span> <span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token number">10</span> <span class="token keyword">ROWS</span> ONLY<span class="token punctuation">;</span>
</code></pre> <p>这个查询从第 11 行开始，取接下来的 10 行记录。<code>OFFSET</code> 和 <code>FETCH</code> 是 SQL Server 2012 引入的分页功能，更加直观且高效。</p> </li></ul> 
<h2><a id="_114"></a>文章推荐</h2> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/141452073">【Sql Server】使用row_number over方式进行表分页，数据量达到五千多条记录后，查询变慢需要20多秒的解决方案</a></p> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/139258521">【Sql Server】随机查询一条表记录，并重重温回顾下自定义函数的封装和使用</a></p> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/137726316">【Sql Server】锁表如何解锁，模拟会话事务方式锁定一个表然后进行解锁</a></p> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/136648637">【Sql Server】通过Sql语句批量处理数据，使用变量且遍历数据进行逻辑处理</a></p> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/131301694">【新星计划回顾】第六篇学习计划-通过自定义函数和存储过程模拟MD5数据</a></p> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/131104721">【新星计划回顾】第四篇学习计划-自定义函数、存储过程、随机值知识点</a></p> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/136385812">【Sql Server】Update中的From语句，以及常见更新操作方式</a></p> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/136372526">【Sql server】假设有三个字段a,b,c 以a和b分组，如何查询a和b唯一，但是c不同的记录</a></p> 
<p><a href="https://blog.csdn.net/lmy_520/article/details/135869381">【Sql Server】新手一分钟看懂在已有表基础上修改字段默认值和数据类型</a></p> 
<blockquote> 
 <p>总结：温故而知新，不同阶段重温知识点，会有不一样的认识和理解，博主将巩固一遍知识点，并以实践方式和大家分享，若能有所帮助和收获，这将是博主最大的创作动力和荣幸。也期待认识更多优秀新老博主。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfb90b249adbe5baf41da4e0e54795e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深入探索【Hadoop】生态系统：Hive、Pig、HBase及更多关键组件（上）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02cc7f3f6c222e1788f4a8b5c23dc3e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CyberScraper-2077&#43;simple-one-api：使用大模型爬虫</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>