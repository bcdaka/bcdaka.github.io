<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 23：新功能正式公布 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c8c1f780aac736fb77b66c196a5f7273/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 23：新功能正式公布">
  <meta property="og:description" content="最新版本的 Java 开发工具包 23 (JDK) 在最新版本中具有四个新功能。到目前为止值得注意的两个主要功能是 Vector API、Stream Gatherers 的第二个预览以及模式中原始类型的预览 - 例如instanceof和switch。
友情提醒，最新版本将于 9 月 19 日发布。
Vector API
自Java Development Kit 16发布以来， Vector API一直在Java的早期版本中孵化，一直到最新版本22。
这个新版本将引入一个API来帮助表达在运行时编译的向量计算。
是为了在不同支持的 CPU 架构上拥有最佳的向量指令。该提案的一些目标包括提供标准化 API、运行时编译、在x64和AArch64CPU 架构上提供更好的性能、优雅降级、与平台无关以及与 Valhalla 项目保持更多一致该项目旨在增强 Java 对象模型的值对象而是对象。 矢量 API 代码示例
static final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED; void vectorComputation(float[] a, float[] b, float[] c) { int i = 0; int upperBound = SPECIES.loopBound(a.length); for (; i &lt; upperBound; i &#43;= SPECIES.length()) { // FloatVector va, vb, vc; var va = FloatVector.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-18T06:22:48+08:00">
    <meta property="article:modified_time" content="2024-04-18T06:22:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 23：新功能正式公布</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>最新版本的 Java 开发工具包 23 (JDK) 在最新版本中具有四个新功能。到目前为止值得注意的两个主要功能是 Vector API、Stream Gatherers 的第二个预览以及模式中原始类型的预览 - 例如instanceof和switch。</p> 
<p>友情提醒，最新版本将于 9 月 19 日发布。</p> 
<p><strong>Vector API</strong><br> 自Java Development Kit 16发布以来， Vector API一直在Java的早期版本中孵化，一直到最新版本22。<br> 这个新版本将引入一个API来帮助表达在运行时编译的向量计算。</p> 
<ul><li>是为了在不同支持的 CPU 架构上拥有最佳的向量指令。</li><li>该提案的一些目标包括提供标准化 API、运行时编译、在x64和AArch64CPU 架构上提供更好的性能、优雅降级、与平台无关以及与 Valhalla 项目保持更多一致</li><li>该项目旨在增强 Java 对象模型的值对象而是对象。</li></ul> 
<p>矢量 API 代码示例</p> 
<pre><code class="code-highlight"><span class="code-line line-number">
</span><span class="code-line line-number">static final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;
</span><span class="code-line line-number">
</span><span class="code-line line-number">void vectorComputation(float[] a, float[] b, float[] c) {
</span><span class="code-line line-number">    int i = 0;
</span><span class="code-line line-number">    int upperBound = SPECIES.loopBound(a.length);
</span><span class="code-line line-number">    for (; i &lt; upperBound; i += SPECIES.length()) {
</span><span class="code-line line-number">        // FloatVector va, vb, vc;
</span><span class="code-line line-number">        var va = FloatVector.fromArray(SPECIES, a, i);
</span><span class="code-line line-number">        var vb = FloatVector.fromArray(SPECIES, b, i);
</span><span class="code-line line-number">        var vc = va.mul(va)
</span><span class="code-line line-number">                   .add(vb.mul(vb))
</span><span class="code-line line-number">                   .neg();
</span><span class="code-line line-number">        vc.intoArray(c, i);
</span><span class="code-line line-number">    }
</span><span class="code-line line-number">    for (; i &lt; a.length; i++) {
</span><span class="code-line line-number">        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;
</span><span class="code-line line-number">    }
</span><span class="code-line line-number">}
</span></code></pre> 
<p><strong>流收集器和流 API</strong><br> 如果您还记得，流收集器<a href="https://openjdk.org/jeps/473?ref=coderoasis.com" rel="nofollow">Stream Gatherers</a>是 Java Development Kid 22 版本中预览的一部分。现在它将完全添加到 JDK 23 中。</p> 
<ul><li>Stream Gatherers 将增强<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/package-summary.html?ref=coderoasis.com" rel="nofollow">Stream API</a>以支持自定义操作。</li><li>它们还允许流管道以当前内置操作难以实现的方式帮助转换数据。</li><li>这样做的目标是使流管道更加灵活和富有表现力——这也将允许自定义操作来操纵无限大小的流。</li></ul> 
<p>使用 <a href="https://openjdk.org/jeps/466?ref=coderoasis.com" rel="nofollow">类文件 API</a> 的目的是提供一个用于处理类文件的 API:</p> 
<ul><li>该 API 跟踪 <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html?ref=coderoasis.com" rel="nofollow">Java 虚拟机规范</a>定义的类文件格式。</li><li>这也意味着它将使 JDK 组件能够迁移到标准 API，并删除 Java 开发工具包的<a href="https://asm.ow2.io/?ref=coderoasis.com" rel="nofollow">ASM 库</a>副本。</li></ul> 
<p>类文件 API 添加了一些微调 :</p> 
<ul><li>包括简化类 CodeBuilder ，</li><li>默认情况下包含字节码指令的工厂方法，包括低级工厂、中级工厂和基本块的高级构建器。</li></ul> 
<p>下面是 ASM CodeBuilder 与 Java CodeBuilder 的一些示例代码。</p> 
<p>ASM CodeBuilder 代码示例</p> 
<pre><code class="code-highlight"><span class="code-line line-number">
</span><span class="code-line line-number">ClassWriter classWriter = ...;  
</span><span class="code-line line-number">MethodVisitor mv = classWriter.visitMethod(0, "fooBar", "(ZI)V", **null**, **null**);  
</span><span class="code-line line-number">mv.visitCode();  
</span><span class="code-line line-number">mv.visitVarInsn(ILOAD, 1);  
</span><span class="code-line line-number">Label label1 = **new** Label();  
</span><span class="code-line line-number">mv.visitJumpInsn(IFEQ, label1);  
</span><span class="code-line line-number">mv.visitVarInsn(ALOAD, 0);  
</span><span class="code-line line-number">mv.visitVarInsn(ILOAD, 2);  
</span><span class="code-line line-number">mv.visitMethodInsn(INVOKEVIRTUAL, "Foo", "foo", "(I)V", false);  
</span><span class="code-line line-number">Label label2 = **new** Label();  
</span><span class="code-line line-number">mv.visitJumpInsn(GOTO, label2);  
</span><span class="code-line line-number">mv.visitLabel(label1);  
</span><span class="code-line line-number">mv.visitVarInsn(ALOAD, 0);  
</span><span class="code-line line-number">mv.visitVarInsn(ILOAD, 2);  
</span><span class="code-line line-number">mv.visitMethodInsn(INVOKEVIRTUAL, "Foo", "bar", "(I)V", false);  
</span><span class="code-line line-number">mv.visitLabel(label2);  
</span><span class="code-line line-number">mv.visitInsn(RETURN);  
</span><span class="code-line line-number">mv.visitEnd();  
</span></code></pre> 
<p>Java CodeBuilder 示例代码</p> 
<pre><code class="code-highlight"><span class="code-line line-number">
</span><span class="code-line line-number">ClassBuilder classBuilder = ...;  
</span><span class="code-line line-number">classBuilder.withMethod("fooBar", MethodTypeDesc.of(CD\_**void**, CD\_**boolean**, CD\_**int**), flags,  
</span><span class="code-line line-number">                        methodBuilder -&gt; methodBuilder.withCode(codeBuilder -&gt; {  
</span><span class="code-line line-number">    Label label1 = codeBuilder.newLabel();  
</span><span class="code-line line-number">    Label label2 = codeBuilder.newLabel();  
</span><span class="code-line line-number">    codeBuilder.iload(1)  
</span><span class="code-line line-number">        .ifeq(label1)  
</span><span class="code-line line-number">        .aload(0)  
</span><span class="code-line line-number">        .iload(2)  
</span><span class="code-line line-number">        .invokevirtual(ClassDesc.of("Foo"), "foo", MethodTypeDesc.of(CD\_**void**, CD\_**int**))  
</span><span class="code-line line-number">        .**goto**\_(label2)  
</span><span class="code-line line-number">        .labelBinding(label1)  
</span><span class="code-line line-number">        .aload(0)  
</span><span class="code-line line-number">        .iload(2)  
</span><span class="code-line line-number">        .invokevirtual(ClassDesc.of("Foo"), "bar", MethodTypeDesc.of(CD\_**void**, CD\_**int**))  
</span><span class="code-line line-number">        .labelBinding(label2);  
</span><span class="code-line line-number">        .**return**\_();  
</span><span class="code-line line-number">});  
</span></code></pre> 
<p>在 Java Development Kit 23 中，</p> 
<ol><li> <p>Java CodeBuilder 删除了与低级方法重复的中级方法，或者更糟糕的是，不经常使用的中级方法。</p> </li><li> <p>同时您重命名其余的中级方法以提高可用性。</p> </li><li> <p>他们还完善了 ClassSignature 班级模型。这意味着它已得到改进，可以更准确地对superclasses和的通用签名进行建模superinterfaces。</p> </li></ol> 
<p>根据此功能背后的 OpenJDK 提案，Java 平台应该定义和实现一个标准的类文件 API，该 API 与类文件格式一起发展，该格式可以轻松地更改或发展大约每六个月一次。</p> 
<p><strong>模式中的原始类型</strong><br> 正如前面提到的，随着 Java Development Kit 23 的最新计划功能和版本的发布，我们获得了另一个对于 Java 开发人员来说非常值得注意的预览功能： <a href="https://openjdk.org/jeps/455?ref=coderoasis.com" rel="nofollow">primitive types in patterns, instanceof,  switch</a>. </p> 
<p>此功能将通过允许：</p> 
<ul><li>模式上下文中的原始类型模式来显着增强模式匹配。</li><li>然后我们扩展instanceof 和 switch 来处理所有原始类型。</li><li>这还包括在嵌套和顶级上下文中使用原始类型模式的模式匹配： 提供易于使用的构造，消除由于不安全的强制转换而丢失信息的风险</li><li>其他目标包括将模式类型与 对齐 instanceof、 instanceof 与安全转换对齐以及</li><li>允许 switch 处理任何原始类型的值。</li></ul> 
<p>原始类型Primitive Type代码案例：</p> 
<p><a href="https://www.jdon.com/73344.html" rel="nofollow">https://www.jdon.com/73344.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b823726889510a5f54ca739840218a5d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java Map遍历的六种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02c646c2142ec683aa2658eb5ee8b3b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle-数据库升级到19C用户登录报错问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>