<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【基础算法总结】前缀和二 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/78228fa68256a20543844c12a11d965d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【基础算法总结】前缀和二">
  <meta property="og:description" content="前缀和二 1.和为 K 的子数组2.和可被 K 整除的子数组3.连续数组4. 矩阵区域和 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.和为 K 的子数组 题目链接：560. 和为 K 的子数组
题目分析：
子数组是连续的！
算法原理：
解法一：暴力枚举
定位一个下标然后从前往后遍历，两层for循环把所有子数组都找出来，把和为k的数组个数统计一下。肯定能解决问题，但时间复杂度是O(N^2)。并且这道题要注意范围是从负数到整数，因此定位一个下标从前往后走，即使找到了也不能停下，还要继续往后面找。万一后面数是0呢，万一后面数加起来是0呢。所以每次都要找到结尾！
以前也做过找子数组和的问题，那个时候用的是滑动窗口，本质就是同向双指针，right不往回走，但是今天这道题就不行了，滑动窗口的使用：数组要具有单调性或者说数组内都是正整数(大于0)才能用！
这道题数组里面可能有0，可能有负数，现在left和right指向一个区间了，但是区间内部可能还有符合的，right必须要回去才行，因此 不能用滑动窗口优化。
解法二：前缀和
以i位置为结尾的所有子数组
我们暴力枚举是以某点为起点的子数组。这里我们以某点为结尾的子数组。
只看前面到这个点为结尾而不看从这个位置往后，也是可以把所有子数组都枚举出来的。那以某个点为结尾的子数组中找到和为K的子数组有多少个，然后把所有情况加起来。
我们把它抽象出来，先看以i为结尾的子数组，后面先不看
如果是直接从i往前找和等于K的就和暴力枚举没区别了，此时引入前缀和思想。当枚举到i位置时，我已经知道以i为结尾的前缀和，假设是 sum[i], 此时我们需要找一个区间和为K，那仅需找一个前缀和让它等于 sum[i]-K 不就可以了嘛 。
这样就转化为 在【0，n-1】区间内，有多少个前缀和等于 sum【i】- K
如果直接把前缀和数组搞出来然后找i位置之前有多少个前缀和等于sum[i]-k
，那还需要从前到i位置遍历，这样就比暴力枚举时间复杂度还高。没有必要。如果要快速查找一个东西可以使用哈希表。
因此解法二：前缀和&#43;哈希表
细节问题：
1.前缀和加入哈希表的时机？
第一种就是把所有前缀和都算出来都加入到hash表在找，这种方式有问题，我要找i位置之前这样把i位置之后的和也加入到哈希表了，是有问题的。
在计算i位置之前，哈希表里面只保存 [0,i-1] 位置的前缀和，计算完i位置之和，才把i位置的前缀和加入哈希表。
2.不用真的创建一个前缀和数组，用一个变量 sum 来标记前一个位置的前缀和即可
3.如果到i位置整个前缀和等于K？
那是不是要去[0,-1] 去找0，但是没有这个区间，但是[0,i]等于k也是一种情况，因此hash表特殊处理 hash[0]=1
class Solution { public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int,int&gt; hash;//统计前缀和出现次数 hash[0]=1; int sum=0,ret=0; for(auto&amp; x:nums) { sum&#43;=x; //计算当前位置前缀和 if(hash.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-28T09:59:19+08:00">
    <meta property="article:modified_time" content="2024-05-28T09:59:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【基础算法总结】前缀和二</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>前缀和二</h4> 
 <ul><li><a href="#1_K__8" rel="nofollow">1.和为 K 的子数组</a></li><li><a href="#2_K__83" rel="nofollow">2.和可被 K 整除的子数组</a></li><li><a href="#3_141" rel="nofollow">3.连续数组</a></li><li><a href="#4__204" rel="nofollow">4. 矩阵区域和</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/94/3e/3Vtajz6W_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>点赞</strong>👍👍<strong>收藏</strong>🌟🌟<strong>关注</strong>💖💖<br> <font color="red"><strong>你的支持是对我最大的鼓励，我们一起努力吧!😃😃</strong></font></p> 
</blockquote> 
<h2><a id="1_K__8"></a>1.和为 K 的子数组</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/" rel="nofollow">560. 和为 K 的子数组</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/22/36/kNFJLG7C_o.png" alt="在这里插入图片描述"><br> 子数组是连续的！<br> <img src="https://images2.imgbox.com/11/c3/6HBDg7ls_o.png" alt="在这里插入图片描述"><br> <strong>算法原理：</strong></p> 
<p><strong>解法一：暴力枚举</strong></p> 
<p>定位一个下标然后从前往后遍历，两层for循环把所有子数组都找出来，把和为k的数组个数统计一下。肯定能解决问题，但时间复杂度是O(N^2)。并且这道题要注意范围是从负数到整数，因此定位一个下标从前往后走，即使找到了也不能停下，还要继续往后面找。万一后面数是0呢，万一后面数加起来是0呢。所以每次都要找到结尾！</p> 
<p><img src="https://images2.imgbox.com/54/54/4wuhqgXm_o.png" alt="在这里插入图片描述"><br> 以前也做过找子数组和的问题，那个时候用的是滑动窗口，本质就是同向双指针，right不往回走，但是今天这道题就不行了，<strong>滑动窗口的使用：数组要具有单调性或者说数组内都是正整数(大于0)才能用！</strong></p> 
<p>这道题数组里面可能有<strong>0</strong>，可能有<strong>负数</strong>，现在left和right指向一个区间了，但是区间内部可能还有符合的，right必须要回去才行，因此 <strong>不能用滑动窗口优化。</strong></p> 
<p><img src="https://images2.imgbox.com/6a/f8/4H9az7ez_o.png" alt="在这里插入图片描述"><br> <strong>解法二：前缀和</strong></p> 
<p><strong>以i位置为结尾的所有子数组</strong></p> 
<p>我们暴力枚举是以某点为起点的子数组。这里我们以某点为结尾的子数组。<br> 只看前面到这个点为结尾而不看从这个位置往后，也是可以把所有子数组都枚举出来的。那以某个点为结尾的子数组中找到和为K的子数组有多少个，然后把所有情况加起来。</p> 
<p><img src="https://images2.imgbox.com/20/3d/Dlhw26kR_o.png" alt="在这里插入图片描述"><br> 我们把它抽象出来，先看以i为结尾的子数组，后面先不看</p> 
<p>如果是直接从i往前找和等于K的就和暴力枚举没区别了，此时引入前缀和思想。当枚举到i位置时，我已经知道以i为结尾的前缀和，假设是 sum[i], 此时我们需要找一个区间和为K，那仅需找一个前缀和让它等于 sum[i]-K 不就可以了嘛 。</p> 
<p><img src="https://images2.imgbox.com/e1/78/B2pnPY5f_o.png" alt="在这里插入图片描述"></p> 
<p>这样就转化为 <strong>在【0，n-1】区间内，有多少个前缀和等于 sum【i】- K</strong><br> <img src="https://images2.imgbox.com/15/81/3pu5TnOT_o.png" alt="在这里插入图片描述"></p> 
<p>如果直接把前缀和数组搞出来然后找i位置之前有多少个前缀和等于sum[i]-k<br> ，那还需要从前到i位置遍历，这样就比暴力枚举时间复杂度还高。没有必要。如果要快速查找一个东西可以使用哈希表。<br> <img src="https://images2.imgbox.com/96/70/ea9M323Y_o.png" alt="在这里插入图片描述"><br> 因此<strong>解法二：前缀和+哈希表</strong></p> 
<p>细节问题：<br> <strong>1.前缀和加入哈希表的时机？</strong></p> 
<p>第一种就是把所有前缀和都算出来都加入到hash表在找，这种方式有问题，我要找i位置之前这样把i位置之后的和也加入到哈希表了，是有问题的。</p> 
<p><strong>在计算i位置之前，哈希表里面只保存 [0,i-1] 位置的前缀和，计算完i位置之和，才把i位置的前缀和加入哈希表。</strong></p> 
<p><strong>2.不用真的创建一个前缀和数组，用一个变量 sum 来标记前一个位置的前缀和即可</strong></p> 
<p><strong>3.如果到i位置整个前缀和等于K？</strong><br> 那是不是要去[0,-1] 去找0，但是没有这个区间，但是[0,i]等于k也是一种情况，因此hash表特殊处理 hash[0]=1</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span><span class="token comment">//统计前缀和出现次数</span>
        hash<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x<span class="token operator">:</span>nums<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            sum<span class="token operator">+=</span>x<span class="token punctuation">;</span> <span class="token comment">//计算当前位置前缀和</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>sum<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> ret<span class="token operator">+=</span>hash<span class="token punctuation">[</span>sum<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//统计个数</span>
            hash<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="2_K__83"></a>2.和可被 K 整除的子数组</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/" rel="nofollow">974. 和可被 K 整除的子数组</a></p> 
<p><strong>题目描述：</strong></p> 
<p><img src="https://images2.imgbox.com/d1/b1/CZC3FGAB_o.png" alt="在这里插入图片描述"></p> 
<p>这道题和上一道题没什么区别，一个让找和为k的子数组，一个让找能够被k整除的子数组。</p> 
<p><strong>算法原理：</strong></p> 
<p><strong>解法一：暴力枚举</strong><br> 枚举出所有子数组，然后找到符合条件的子数组！</p> 
<p>在说解法二之前有两个补充知识：</p> 
<p><strong>1.同余定理</strong></p> 
<p><img src="https://images2.imgbox.com/4b/4a/YvFhV12S_o.png" alt="在这里插入图片描述"></p> 
<p>2.<strong>C++，java 【负数 % 正数】的结果以及修正</strong></p> 
<p>在C++，java 中 <strong>负数 % 正数 = 负数</strong> 如果得到一个正数呢？<br> 修正：<strong>(a%p+p)%p</strong> 负数-&gt;正数，正数即使多加了也会模掉结果不会变。</p> 
<p>有了这两个就可以开始解法二了，这道题解法和前面一模一样</p> 
<p><strong>解法二：前缀和+哈希表</strong></p> 
<p>转化成以i结尾的子数组找子数组和能被k整除。<br> 使用前缀和思想，得到以i为结尾的所有元素的和 sum[i] ，我们现在也知道i位置之前所有下标的前缀和，因此在i为结尾的子数组中找一个子数组和能被k整除，可以转换成 <strong>[0，i-1]找有多少个前缀和余数等于 （sum % k + k）% k (余数可能为负修正一下）</strong></p> 
<p><img src="https://images2.imgbox.com/e1/70/LgQwVDXf_o.png" alt="在这里插入图片描述"><br> 在使用哈希表 hash&lt;int,int&gt; 记录前缀和的余数 和 次数。<br> 这里的细节问题和上面的一模一样。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">subarraysDivByK</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span>
        hash<span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">%</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//0%k这个数的余数</span>

        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x<span class="token operator">:</span> nums<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            sum<span class="token operator">+=</span>x<span class="token punctuation">;</span><span class="token comment">// 算出当前位置前缀和</span>
            <span class="token keyword">int</span> mod<span class="token operator">=</span><span class="token punctuation">(</span>sum<span class="token operator">%</span>k<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token operator">%</span>k<span class="token punctuation">;</span><span class="token comment">//修正后的余数</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span><span class="token punctuation">)</span> ret<span class="token operator">+=</span>hash<span class="token punctuation">[</span>mod<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//统计结果</span>
            hash<span class="token punctuation">[</span>mod<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="3_141"></a>3.连续数组</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/contiguous-array/description/" rel="nofollow">525. 连续数组</a></p> 
<p><strong>题目描述：</strong></p> 
<p><img src="https://images2.imgbox.com/a1/71/2WHvzsoI_o.png" alt="在这里插入图片描述"></p> 
<p>题目很简单就是让找包含相同1和0个数的最大子数组的长度</p> 
<p><strong>算法原理：</strong><br> 这道题如果统计子数组中1和0个数，是很难的。对于这道题，我们可以使用 <strong>正难则反</strong> ，正面解决麻烦转化一下在求解。<br> 转化：<br> <strong>1.将所有的 0 修改成 -1</strong><br> <strong>2.在数组中，找出最长的子数组，使子数组中所有元素的和为0</strong><br> <img src="https://images2.imgbox.com/00/9a/23YlHZ8d_o.png" alt="在这里插入图片描述"></p> 
<p>前面有道题是在数组种找和为k的子数组，这里解题思想是完全一样，转换成找和为0子数组。</p> 
<p><strong>解法：前缀和+哈希表</strong></p> 
<p>不过细节有些差别。</p> 
<p><strong>1.哈希表中存的是什么</strong></p> 
<p>这道题让找的是数组的长度。因此hash&lt;int，int&gt; 前面是前缀和，后面是<strong>下标</strong>！</p> 
<p><strong>2.前缀和什么时候存入哈希表</strong></p> 
<p>在使用sum[i]之后，在丢入哈希表</p> 
<p><strong>3.如果有重复的 &lt;sum,i&gt; 怎么办</strong><br> 以i为结尾然后找的过程中出现以j为结尾的前缀和相等，但是因为我们要找到的是最长子数组长度，我们只保存前面的 &lt;sum,j&gt;</p> 
<p><img src="https://images2.imgbox.com/f5/7b/85FZIlnj_o.png" alt="在这里插入图片描述"></p> 
<p><strong>4.默认前缀和为0的情况，哈希表如何存</strong></p> 
<p>以i为结尾的子数组本身前缀和等于0，这时我们去的是【0，-1】区间找，以前存的是个数hash[0]=1默认有一个，今天这里是<strong>hash[0]=-1</strong>，存的是下标<br> <img src="https://images2.imgbox.com/6d/da/tBeHPk4W_o.png" alt="在这里插入图片描述"><br> <strong>5.长度如何计算</strong></p> 
<p><img src="https://images2.imgbox.com/df/a4/jLyc0Zrg_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span>
        hash<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 默认有一个前缀和为0的情况</span>

        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            sum<span class="token operator">+=</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">)</span> ret<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span>i<span class="token operator">-</span>hash<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> hash<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="4__204"></a>4. 矩阵区域和</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/matrix-block-sum/description/" rel="nofollow">1314. 矩阵区域和</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/7c/b0/uLkBdtV9_o.png" alt="在这里插入图片描述"><br> 这道题让返回一个数组，数组内每个下标的和是某一个区域的和。具体如下<br> 通过两个例子，就可以理解上面的意思<br> <img src="https://images2.imgbox.com/60/7b/YHKTnVtk_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到求answer数组每个下标的值其实就是在求mat子矩阵的和！<br> 关于子矩阵的和前面我们写过一道二维数组前缀和模板，可以用哪里的思想。</p> 
<p><strong>算法原理：</strong></p> 
<p><strong>解法：前缀和</strong></p> 
<p>不要死记模板，自己分析。<br> 如果要求子矩阵D的和，我们算出A+B+C+D的和，然后减去A+B的和，再减去A+C的和，但是多减了A的和，因此在加上一个A的和，最终就是区域D的和。但是前提是要知道A+B的和，A+C的和。</p> 
<p><img src="https://images2.imgbox.com/8c/25/NZDtBFRK_o.png" alt="在这里插入图片描述"></p> 
<p>因此预先处理一个前缀和数组</p> 
<p><img src="https://images2.imgbox.com/67/9e/kow3Bvgo_o.png" alt="在这里插入图片描述"><br> 预处理之后就该使用数组了<br> <img src="https://images2.imgbox.com/35/ab/Xmqr3P5D_o.png" alt="在这里插入图片描述"><br> 不用死记硬背我们自己也是可以推出来的，这里【x1，y1】,【x2，y2】我们要根基题意看是哪里。</p> 
<p><img src="https://images2.imgbox.com/fb/02/Owu9XowN_o.png" alt="在这里插入图片描述"><br> 但这里有些问题，上面的前缀和数组我们是从数组下标从【1，1】开始的。所以公式没有越界情况。但是这道题数组下标是从0开始的！</p> 
<p>对于一维数组下标从0开始好解决，我们直接对第一个位置特殊处理一下。对于二维数组呢。如果把模板改成从0下标开始边界太难控制 ，因此我们多申请一行一列！让下标从1开始，那样上面的公式也不用大改了。<br> 然后我们改一下下标标映射关系</p> 
<p><img src="https://images2.imgbox.com/c4/bb/mwVH6fLi_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">matrixBlockSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> mat<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> m<span class="token operator">=</span>mat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">=</span>mat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 1.预处理前缀和数组</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>mat<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment">// 2.使用</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">ret</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> x1<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y1<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> x2<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y2<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">[</span>y2<span class="token punctuation">]</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>x1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y2<span class="token punctuation">]</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">[</span>y1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>x1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token keyword">return</span>  ret<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58ed312e34fd69c797c4dda5564f75b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL】库的操作&#43;表的操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a024a63462ac7c5bd9d9acf5adc3f2c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ollama&#43;open-webui，本地部署自己的大模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>