<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;11】C&#43;&#43;11新纪元：深入探索右值引用与移动语义 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ab05938845532dc69473150b92314018/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;11】C&#43;&#43;11新纪元：深入探索右值引用与移动语义">
  <meta property="og:description" content="📝个人主页🌹：Eternity._
⏩收录专栏⏪：C&#43;&#43; “ 登神长阶 ”
🤡往期回顾🤡：位图与布隆过滤器
🌹🌹期待您的关注 🌹🌹
❀C&#43;&#43;11 📒1. C&#43;&#43;11简介📜2. 统一的列表初始化🌸{ }初始化🌺initializer_list 📚3. decltype与新容器 array🎩decltype🎈新容器 array 📝4. 右值引用和移动语义⛰️左值引用和右值引用🌄左值引用与右值引用比较🌞右值引用使用场景和意义⭐完美转发 📙5. 新的类功能📖6. 总结 前言：在C&#43;&#43;的悠久历史中，每一次标准的更新都如同为这门强大的编程语言注入了新的活力。C&#43;&#43;11，作为这一进程中的一个重要里程碑，不仅带来了众多新特性，还深刻改变了C&#43;&#43;编程的范式，其中右值引用（Rvalue References）无疑是最为引人注目的特性之一
在传统的C&#43;&#43;编程中，我们习惯于通过左值（Lvalues）来引用和操作对象，这些左值通常指向具有持久身份的对象。然而，随着C&#43;&#43;应用的日益复杂和对性能要求的不断提高，如何高效地处理临时对象（即右值，Rvalues）成为了亟待解决的问题。C&#43;&#43;11引入的右值引用，正是为了填补这一空白，它允许我们直接引用即将被销毁的临时对象，从而开启了C&#43;&#43;编程的新纪元
本篇将带您深入探索C&#43;&#43;11中的右值引用及其相关特性，包括移动语义（MoveSemantics）、完美转发（Perfect Forwarding）等。我们将从基础概念讲起，逐步深入到实际应用和最佳实践，旨在帮助您全面理解并掌握这一强大的编程工具
让我们一起踏上学习的旅程，探索它带来的无尽可能！
📒1. C&#43;&#43;11简介 C&#43;&#43;11是C&#43;&#43;编程语言的一个重大更新版本，也被称为C&#43;&#43;标准第三版，正式名称为ISO/IEC 14882:2011 - Information technology – Programming languages – C&#43;&#43;
相比于C&#43;&#43;98/03，C&#43;&#43;11则带来了数量可观的变化，其中包含了约140个新特性，以及对C&#43;&#43;03标准中约600个缺陷的修正，这使得C&#43;&#43;11更像是从C&#43;&#43;98/03中孕育出的一种新语言。相比较而言，C&#43;&#43;11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个重点去学习
C&#43;&#43;11标准的发布对C&#43;&#43;编程产生了深远的影响，推动了C&#43;&#43;语言的现代化和性能提升。随着各大主流编译器（如GCC、Clang、MSVC等）对C&#43;&#43;11语法的支持逐渐完善，越来越多的项目开始采用C&#43;&#43;11标准进行开发。同时，相关的技术书籍和教程也相继更新，以支持C&#43;&#43;11的新特性
总之，C&#43;&#43;11是C&#43;&#43;编程语言发展历程中的一个重要里程碑，它带来了众多新特性和改进，为C&#43;&#43;程序员提供了更加强大和灵活的工具来编写高效、可维护的代码
C&#43;&#43;11介绍
📜2. 统一的列表初始化 在C&#43;&#43;11及以后的版本中，引入了统一的列表初始化（Uniform Initialization）或称为初始化列表（Initialization List），这是一种新的初始化语法，使用大括号{}来初始化变量。统一的列表初始化不仅提高了代码的一致性和可读性，还解决了之前初始化语法中的一些歧义和限制
🌸{ }初始化 在C&#43;&#43;98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定
代码示例 (C&#43;&#43;)：
// C&#43;&#43;98 struct Pxt { int _x; int _y; }; int main() { Pxt p = { 1, 2 }; return 0; } C&#43;&#43;11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定义的类型，使用初始化列表时，可添加等号(=)，也可不添加">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-29T18:27:29+08:00">
    <meta property="article:modified_time" content="2024-07-29T18:27:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;11】C&#43;&#43;11新纪元：深入探索右值引用与移动语义</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>📝个人主页🌹：<a href="https://blog.csdn.net/EterNity_TiMe_?type=blog">Eternity._</a><br> ⏩收录专栏⏪：<a href="http://t.csdnimg.cn/rM7cw" rel="nofollow">C++ “ 登神长阶 ”</a><br> 🤡往期回顾🤡：<a href="http://t.csdnimg.cn/IBHPF" rel="nofollow">位图与布隆过滤器</a><br> 🌹🌹期待您的关注 🌹🌹</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e1/9e/nDqsrkDL_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b4/1e/a3fdcaYQ_o.gif" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/94/7a/Bm1pLgmn_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>❀C++11</h4> 
 <ul><li><a href="#1_C11_26" rel="nofollow">📒1. C++11简介</a></li><li><a href="#2__37" rel="nofollow">📜2. 统一的列表初始化</a></li><li><ul><li><a href="#__40" rel="nofollow">🌸{ }初始化</a></li><li><a href="#initializer_list_123" rel="nofollow">🌺initializer_list</a></li></ul> 
  </li><li><a href="#3_decltype_array_166" rel="nofollow">📚3. decltype与新容器 array</a></li><li><ul><li><a href="#decltype_167" rel="nofollow">🎩decltype</a></li><li><a href="#_array_189" rel="nofollow">🎈新容器 array</a></li></ul> 
  </li><li><a href="#4__204" rel="nofollow">📝4. 右值引用和移动语义</a></li><li><ul><li><a href="#_214" rel="nofollow">⛰️左值引用和右值引用</a></li><li><a href="#_276" rel="nofollow">🌄左值引用与右值引用比较</a></li><li><a href="#_342" rel="nofollow">🌞右值引用使用场景和意义</a></li><li><a href="#_429" rel="nofollow">⭐完美转发</a></li></ul> 
  </li><li><a href="#5__483" rel="nofollow">📙5. 新的类功能</a></li><li><a href="#6__520" rel="nofollow">📖6. 总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<p><strong>前言：在C++的悠久历史中，每一次标准的更新都如同为这门强大的编程语言注入了新的活力。C++11，作为这一进程中的一个重要里程碑，不仅带来了众多新特性，还深刻改变了C++编程的范式，其中右值引用（Rvalue References）无疑是最为引人注目的特性之一</strong></p> 
<blockquote> 
 <p><strong>在传统的C++编程中，我们习惯于通过左值（Lvalues）来引用和操作对象，这些左值通常指向具有持久身份的对象。然而，随着C++应用的日益复杂和对性能要求的不断提高，如何高效地处理临时对象（即右值，Rvalues）成为了亟待解决的问题。C++11引入的右值引用，正是为了填补这一空白，它允许我们直接引用即将被销毁的临时对象，从而开启了C++编程的新纪元</strong></p> 
</blockquote> 
<p>本篇将带您深入探索C++11中的右值引用及其相关特性，包括移动语义（MoveSemantics）、完美转发（Perfect Forwarding）等。我们将从基础概念讲起，逐步深入到实际应用和最佳实践，旨在帮助您全面理解并掌握这一强大的编程工具</p> 
<p><strong>让我们一起踏上学习的旅程，探索它带来的无尽可能！</strong></p> 
<hr> 
<h2><a id="1_C11_26"></a>📒1. C++11简介</h2> 
<blockquote> 
 <p><strong>C++11是C++编程语言的一个重大更新版本，也被称为C++标准第三版，正式名称为ISO/IEC 14882:2011 - Information technology – Programming languages – C++</strong></p> 
</blockquote> 
<p><strong>相比于C++98/03，C++11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中约600个缺陷的修正，这使得C++11更像是从C++98/03中孕育出的一种新语言。相比较而言，C++11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个重点去学习</strong></p> 
<blockquote> 
 <p><strong>C++11标准的发布对C++编程产生了深远的影响，推动了C++语言的现代化和性能提升。随着各大主流编译器（如GCC、Clang、MSVC等）对C++11语法的支持逐渐完善，越来越多的项目开始采用C++11标准进行开发。同时，相关的技术书籍和教程也相继更新，以支持C++11的新特性</strong></p> 
</blockquote> 
<p><strong>总之，C++11是C++编程语言发展历程中的一个重要里程碑，它带来了众多新特性和改进，为C++程序员提供了更加强大和灵活的工具来编写高效、可维护的代码</strong></p> 
<p><a href="https://en.cppreference.com/w/cpp/11" rel="nofollow">C++11介绍</a></p> 
<hr> 
<h2><a id="2__37"></a>📜2. 统一的列表初始化</h2> 
<blockquote> 
 <p><strong>在C++11及以后的版本中，引入了统一的列表初始化（Uniform Initialization）或称为初始化列表（<code>Initialization List</code>），这是一种新的初始化语法，使用大括号{}来初始化变量。统一的列表初始化不仅提高了代码的一致性和可读性，还解决了之前初始化语法中的一些歧义和限制</strong></p> 
</blockquote> 
<hr> 
<h3><a id="__40"></a>🌸{ }初始化</h3> 
<blockquote> 
 <p><strong>在C++98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定</strong></p> 
</blockquote> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// C++98</span>
<span class="token keyword">struct</span> <span class="token class-name">Pxt</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> _x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Pxt p <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<blockquote> 
 <p><strong>C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定义的类型，使用初始化列表时，可添加等号(=)，也可不添加</strong></p> 
</blockquote> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// C++11</span>
<span class="token keyword">struct</span> <span class="token class-name">Pxt</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> _x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">{<!-- --></span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	Pxt p<span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	<span class="token comment">// C++11中列表初始化也可以适用于new表达式中</span>
	<span class="token keyword">int</span><span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>我们的自定义创建的对象也可以使用列表初始化方式调用构造函数初始化</strong></p> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_day</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Date(int year, int month, int day)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// old style</span>
	
	<span class="token comment">// C++11支持的列表初始化，这里会调用构造函数初始化</span>
	Date d2<span class="token punctuation">{<!-- --></span> <span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">29</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	Date d3 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// 这里的 vector 和上面的 Date 不太一样</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>列表初始化时，必须要跟对应的构造函数参数个数匹配，<code>Data</code>中只能有三个参数，但是<code>vector</code>的参数可以有很多个，列表初始化也支持隐式类型转换</strong></p> 
</blockquote> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>Data<span class="token operator">&gt;</span> vd <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">{<!-- --></span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h3><a id="initializer_list_123"></a>🌺initializer_list</h3> 
<blockquote> 
 <p><strong><code>initializer_list</code> 是 C++11 引入的一个特性，它提供了一种方式来初始化容器类对象或函数参数列表，使得可以使用花括号 { } 来直接初始化对象或传递参数。<code>initializer_list</code> 是一个轻量级的模板类，它用于表示一个给定类型的值的数组，但大小是固定的，且生命周期与包含它的对象相同</strong></p> 
</blockquote> 
<p><a href="http://www.cplusplus.com/reference/initializer_list/initializer_list/" rel="nofollow">initializer_list介绍文档</a></p> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span> <span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// initializer_list</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a9/0a/Fjj5tZhN_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/11/5a/sZsvCvD4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/eb/e2/SCjTPz1w_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>注意：initializer_list的迭代器就是原生指针</strong></p> 
</blockquote> 
<hr> 
<blockquote> 
 <p><code>std::initializer_list</code>一般是作为构造函数的参数，C++11对STL中的不少容器就增加 <code>std::initializer_list</code>作为参数的构造函数，这样初始化容器对象就更方便了。也可以作为<code>operator=</code>的参数，这样就可以用大括号赋值</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/66/a4/zMlnHwV7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/78/4a/eQeblBqG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/77/42/FGYvvMGh_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>我们当初在模拟实现这些STL容器时，并没有实现<code>initializer_list</code>，今天我们以vector为例子，实现一下<code>initializer_list</code>的构造</strong></p> 
</blockquote> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token function">vector</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">reverse</span><span class="token punctuation">(</span>lt<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="3_decltype_array_166"></a>📚3. decltype与新容器 array</h2> 
<h3><a id="decltype_167"></a>🎩decltype</h3> 
<blockquote> 
 <p><strong>decltype 是 C++11 引入的一个关键字，它作为操作符用于查询表达式的数据类型。这个操作符主要用于泛型编程中，特别是在模板编程中，当需要推导表达式的类型但又不想实际执行该表达式时，decltype 显得尤为有用</strong></p> 
</blockquote> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span>
	
	<span class="token keyword">decltype</span><span class="token punctuation">(</span>x <span class="token operator">*</span> y<span class="token punctuation">)</span> ret<span class="token punctuation">;</span> <span class="token comment">// ret的类型是double</span>
	<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span> p<span class="token punctuation">;</span> <span class="token comment">// p的类型是int*</span>
	
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>关键字<code>decltype</code>将变量的类型声明为表达式指定的类型</strong></p> 
<hr> 
<h3><a id="_array_189"></a>🎈新容器 array</h3> 
<blockquote> 
 <p><strong>在C++中，<code>std::array</code> 是一个固定大小的容器，它提供了类似于数组的接口，但它是标准库的一部分，因此提供了更多的安全性和灵活性。<code>std::array</code> 定义在头文件 <code>&lt;array&gt;</code> 中，是一个模板类，可以存储任何类型的固定数量元素</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/05/04/NHGg8DW0_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp">array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span> <span class="token comment">// a[10]</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> 
<span class="token comment">// 因为有vector的存在，让array的出现有点“小丑”，而且vector 似乎比array好用</span>
</code></pre> 
<blockquote> 
 <p><strong>因为有<code>vector</code>的存在，让<code>array</code>的出现有点“小丑”，而且<code>vector</code> 似乎比<code>array</code>好用，这里我就不细说了，想了解的朋友可以了解一下</strong></p> 
</blockquote> 
<p><a href="https://legacy.cplusplus.com/reference/array/array/?kw=array" rel="nofollow">array介绍文档</a></p> 
<hr> 
<h2><a id="4__204"></a>📝4. 右值引用和移动语义</h2> 
<p><strong>右值引用</strong></p> 
<blockquote> 
 <ul><li>在C++中，表达式根据它们是否可以被修改分为左值（lvalue）和右值（rvalue）。左值是可以被取地址的表达式，通常对应于具有持久状态的实体（如变量）。而右值则是不可以被取地址的临时对象或字面值，它们通常表示计算的结果或函数返回的临时对象。</li><li>右值引用是C++11引入的一种新类型的引用，它通过类型后加&amp;&amp;来表示。右值引用可以绑定到右值上，但也可以绑定到左值上（需要std::move来显式转换）。右值引用的主要目的是允许函数或操作以“移动”而不是“复制”的方式处理资源，这通常意味着资源的所有权从源对象转移到目标对象，源对象则变为一个安全可销毁的状态。</li></ul> 
</blockquote> 
<p><strong>移动语义</strong></p> 
<blockquote> 
 <p>移动语义允许对象通过转移其资源（如动态分配的内存）而不是复制它们来初始化或赋值另一个对象。这通常是通过一个特殊的成员函数——移动构造函数和移动赋值操作符来实现的。这两个函数都接受右值引用作为参数，表示它们可以从一个即将被销毁的对象中“窃取”资源。</p> 
 <ul><li><strong>移动构造函数：</strong> 接受一个右值引用参数，用于初始化新对象，通过转移源对象的资源而不是复制它们，从而避免不必要的资源分配和复制。</li><li><strong>移动赋值操作符：</strong> 同样接受一个右值引用参数，用于将一个对象的资源转移到另一个已经存在的对象上，并将源对象置于一个可析构的状态。</li></ul> 
</blockquote> 
<hr> 
<h3><a id="_214"></a>⛰️左值引用和右值引用</h3> 
<p><strong>左值引用</strong></p> 
<blockquote> 
 <p>左值是一个表示数据的表达式(如变量名或解引用的指针)，<strong>我们可以获取它的地址+可以对它赋<br> 值，左值可以出现赋值符号的左边，右值不能出现在赋值符号左边</strong>。定义时const修饰符后的左<br> 值，不能给他赋值，但是可以取它的地址。<strong>左值引用就是给左值的引用，给左值取别名</strong></p> 
</blockquote> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// p、b、c、*p都是左值</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

	<span class="token comment">// 对上面左值的左值引用</span>
	<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&amp;</span> rp <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> rb <span class="token operator">=</span> b<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rc <span class="token operator">=</span> c<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> pvalue <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>右值引用</strong></p> 
<blockquote> 
 <p>右值也是一个表示数据的表达式，如：<strong>字面常量、表达式返回值，函数返回值(这个不能是左值引用返回)</strong> 等等，<strong>右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，右值不能取地址</strong>。右值引用就是对右值的引用，给右值取别名</p> 
</blockquote> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 常见的右值</span>
	<span class="token number">10</span><span class="token punctuation">;</span>
	x <span class="token operator">+</span> y<span class="token punctuation">;</span>
	<span class="token function">fmin</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 对右值的右值引用</span>
	<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rr1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span><span class="token operator">&amp;&amp;</span> rr2 <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
	<span class="token keyword">double</span><span class="token operator">&amp;&amp;</span> rr3 <span class="token operator">=</span> <span class="token function">fmin</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>左操作数必须为左值，否则就会报错</strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 这里编译会报错：error C2106: “=”: 左操作数必须为左值</span>
	<span class="token number">10</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	x <span class="token operator">+</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">fmin</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <ul><li>不能用一个值能不能修改来区分左右值，右值是不能取地址的</li><li>给右值取别名后，会导致右值被存储到特定位置，且<strong>可以取到该位置的地址</strong></li></ul> 
</blockquote> 
<hr> 
<h3><a id="_276"></a>🌄左值引用与右值引用比较</h3> 
<p><strong>左值引用：</strong></p> 
<blockquote> 
 <ul><li>左值引用只能引用左值，不能引用右值</li><li>但是const左值引用既可引用左值，也可引用右值</li></ul> 
</blockquote> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 左值引用只能引用左值，不能引用右值。</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ra1 <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// ra为a的别名</span>
	<span class="token comment">//int&amp; ra2 = 10; // 编译失败，因为10是右值</span>
	
	<span class="token comment">// const左值引用既可引用左值，也可引用右值。</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ra3 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ra4 <span class="token operator">=</span> a<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>右值引用：</strong></p> 
<blockquote> 
 <ul><li>右值引用只能右值，不能引用左值</li><li>但是右值引用可以<code>move</code>以后的左值</li></ul> 
</blockquote> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 右值引用只能右值，不能引用左值。</span>
	<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> r1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	
	<span class="token comment">// error C2440: “初始化”: 无法从“int”转换为“int &amp;&amp;”</span>
	<span class="token comment">// message : 无法将左值绑定到右值引用</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> r2 <span class="token operator">=</span> a<span class="token punctuation">;</span>
	
	<span class="token comment">// 右值引用可以引用move以后的左值</span>
	<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> r3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>move</strong></p> 
<blockquote> 
 <p><strong>当你对一个对象使用<code>move</code>时，你实际上是在告诉编译器：“这个对象我之后可能不再需要了，或者我可以接受它处于某种未定义状态，所以你可以安全地‘窃取’它的资源。”，从而变成<code>将亡值</code>，然后，编译器会寻找接收该对象的函数是否支持移动语义（即是否有一个接受右值引用的构造函数或赋值运算符）</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9b/e0/LWxew3Uz_o.png" alt="在这里插入图片描述"></p> 
<p><strong>代码示例 (C++)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
	string s3 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/56/klUVvX7M_o.png" alt="在这里插入图片描述"><br> <strong>直接将s1中的资源“移动”到了s3中</strong></p> 
<hr> 
<h3><a id="_342"></a>🌞右值引用使用场景和意义</h3> 
<blockquote> 
 <p><strong>右值引用让我们能够在一些函数中直接使用右值，而不用开空间而节省资源，而在STL的很多容器中也够重载了右值引用</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f4/d4/ugSBEN0i_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/86/bb/DVyZduro_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>右值引用的使用可以让很多场景得到更高的效率来实现功能</strong></p> 
</blockquote> 
<p><strong>移动构造，移动赋值代码示例 (string为例)：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 移动构造</span>
<span class="token function">string</span><span class="token punctuation">(</span>string<span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span>
	<span class="token operator">:</span><span class="token function">_str</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">,</span><span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">,</span><span class="token function">_capacity</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"string(string&amp;&amp; s) -- 移动语义"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 移动赋值</span>
string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>string<span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"string&amp; operator=(string&amp;&amp; s) -- 移动语义"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>左值引用做参数可以减少拷贝，提高效率的使用场景和价值，但是当函数返回对象是一个局部变量，出了函数作用域就不存在了，就不能使用左值引用返回，只能传值返回</strong></p> 
<p><strong>代码示例 ：</strong></p> 
<pre><code class="prism language-cpp">string <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	string ret<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> val <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
		x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		ret <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token char">'0'</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">reverse</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ret<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	string ret <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/06/0a/AzMRijTP_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong><code>to_string</code>的返回值是一个右值，用这个右值构造ret2，如果没有移动构造，调用就会匹配调用拷贝构造，因为const左值引用是可以引用右值的，这里就是一个<code>深拷贝</code></strong></li><li><strong>移动构造本质是将参数右值的资源窃取过来，占位已有，那么就不用做深拷贝了，所以它叫做移动构造，就是窃取别人的资源来构造自己，而移动构造中没有新开空间，拷贝数据，所以效率就提高了</strong></li><li><strong>如果既有拷贝构造又有移动构造调用就会匹配调用移动构造，因为编译器会选择最匹配的参数调用。那么这里就是一个移动语义</strong></li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/44/cb/CMrkj3zf_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<blockquote> 
 <p>有些场景下，可能真的需要用右值去引用左值实现移动语义。<strong>当需要用右值引用引用一个左值时，可以通过<code>move</code>函数将左值转化为右值</strong>。该函数名字具有迷惑性，<strong>它并不搬移任何东西，唯一的功能就是将一个左值强制转化为右值引用，然后实现移动语义</strong></p> 
</blockquote> 
<p><strong>代码示例 ：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span> <span class="token punctuation">(</span>value_type<span class="token operator">&amp;&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	list<span class="token operator">&lt;</span>pxt<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> lt<span class="token punctuation">;</span>
	pxt<span class="token double-colon punctuation">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 这里调用的是拷贝构造</span>
	lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 下面调用都是移动构造</span>
	lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"2222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/73/93/zmkKtgiE_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_429"></a>⭐完美转发</h3> 
<blockquote> 
 <p><strong>“完美转发”（Perfect Forwarding）是C++11及以后版本中引入的一个特性，它允许函数模板以完全相同的类型（包括const限定符和引用类型）转发其参数到另一个函数或模板。这通常通过模板和std::forward函数实现</strong></p> 
</blockquote> 
<hr> 
<p><strong>模板中的&amp;&amp; 万能引用</strong></p> 
<blockquote> 
 <p><strong>我们写代码测试一下，如果是右值引用就调用函数打印右值引用，如果是左值引用就调用函数打印左值引用</strong></p> 
</blockquote> 
<p><strong>代码示例 ：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"左值引用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const 左值引用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"右值引用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const 右值引用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Fun</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右值</span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左值</span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右值</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const 左值</span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const 右值</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>神奇的一幕发生了，我们运行发现结果全是左值引用</strong><br> <img src="https://images2.imgbox.com/f6/07/Yu1gA4Qk_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>我们有以下结论：</strong></p> 
 <ul><li>模板中的&amp;&amp;不代表右值引用，而是万能引用，其既能接收左值又能接收右值</li><li>模板的万能引用只是提供了能够接收同时接收左值引用和右值引用的能力</li><li>但是引用类型的唯一作用就是限制了接收的类型，后续使用中都退化成了左值</li></ul> 
</blockquote> 
<p><strong>那我们如何能够在传递过程中保持它的左值或者右值的属性, 就需要用我们用到完美转发</strong></p> 
<hr> 
<p><strong>完美转发</strong></p> 
<blockquote> 
 <p><strong><code>forward</code> 它允许函数模板将参数转发到另一个函数时，保持其值类别（左值或右值）不变。这是通过模板的隐式类型转换和引用折叠规则实现的，完美转发在传参的过程中保留对象原生类型属性</strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Fun</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7c/b9/IKEQH2mP_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="5__483"></a>📙5. 新的类功能</h2> 
<p><strong>C++11在原来的基础上新增了两个默认成员函数：移动构造函数和移动赋值运算符重载</strong></p> 
<blockquote> 
 <p><strong>关于这两个函数需要注意:</strong></p> 
 <ul><li>如果你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任<br> 意一个。那么编译器会自动生成一个默认移动构造。默认生成的移动构造函数，对于内置类<br> 型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动构造，<br> 如果实现了就调用移动构造，没有实现就调用拷贝构造。</li><li>如果你没有自己实现移动赋值重载函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中<br> 的任意一个，那么编译器会自动生成一个默认移动赋值。默认生成的移动构造函数，对于内<br> 置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动赋<br> 值，如果实现了就调用移动赋值，没有实现就调用拷贝赋值。(默认移动赋值跟上面移动构造<br> 完全类似)</li><li>如果你提供了移动构造或者移动赋值，编译器不会自动提供拷贝构造和拷贝赋值</li></ul> 
</blockquote> 
<hr> 
<p><strong>禁止生成默认函数的关键字delete</strong></p> 
<blockquote> 
 <p>如果能想要限制某些默认函数的生成，在C++98中，是该函数设置成private，并且只声明补丁<br> 已，这样只要其他人想要调用就会报错。在C++11中更简单，只需在该函数声明加上=delete即<br> 可，该语法指示编译器不生成对应函数的默认版本，称<code>=delete</code>修饰的函数为删除函数</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	string _name<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="6__520"></a>📖6. 总结</h2> 
<p><strong>在探索C++11的广阔特性时，右值引用无疑是一个令人兴奋且意义深远的新特性。它不仅为C++带来了移动语义和完美转发的能力，还极大地增强了C++代码的性能和灵活性。通过深入学习和实践右值引用，我们学会了如何更有效地管理资源，减少了不必要的拷贝操作，从而提高了程序的运行效率</strong></p> 
<blockquote> 
 <p>在学习过程中，我们见证了右值引用如何与移动构造函数、移动赋值操作符以及std::move函数等配合使用，共同构建起了一套完整的移动语义体系。这套体系不仅优化了STL容器的性能，还为我们编写高性能的C++代码提供了强有力的支持</p> 
</blockquote> 
<p><strong>随着C++标准的不断演进，我们期待看到更多基于右值引用的新特性和优化，C++11的内容我们还没有完全了解，愿我们都能保持好奇心和求知欲，不断探索C++的无限可能，我们下期见！</strong></p> 
<p><img src="https://images2.imgbox.com/1a/80/tEehFq7M_o.gif" alt="在这里插入图片描述"></p> 
<p><strong>希望本文能够为你提供有益的参考和启示，让我们一起在编程的道路上不断前行！<br> 谢谢大家支持本篇到这里就结束了，祝大家天天开心！</strong></p> 
<p><img src="https://images2.imgbox.com/65/b0/a6Swju7v_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4dbcfbca19c60aee1bc3efbf6fb68f17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">保姆级教程 ！SQL Server数据库的备份和还原</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c9eac1e747cefcb55d1fa5660d48cb9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">7月29（信息差）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>