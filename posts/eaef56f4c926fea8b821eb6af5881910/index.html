<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从分布式存储到持久卷：【Cloud Native】存储的进化与实战策略 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/eaef56f4c926fea8b821eb6af5881910/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="从分布式存储到持久卷：【Cloud Native】存储的进化与实战策略">
  <meta property="og:description" content="🐇明明跟你说过：个人主页
🏅个人专栏：《未来已来：云原生之旅》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、云原生概念简述
2、存储在云原生环境中的重要性 二、云原生存储概述
1、云原生存储的定义与特性 2、与传统存储架构的对比 三、云原生存储的解决方案
1、持久卷（Persistent Volumes）
1.1、概念与工作原理
1.2、在Kubernetes中的应用案例 1.2.1、PV创建
1.2.2、PVC创建
1.2.3、在Pod中调用
1.2.4、工作原理
2、分布式存储系统
2.1、Ceph、GlusterFS、Rook等
2.2、分布式存储的优势与挑战
一、引言 1、云原生概念简述 云原生（Cloud Native）是一个近年来在云计算领域备受关注的概念，它代表了一种构建和运行应用程序的新型技术体系和方法论。
定义：
云原生是一种将应用程序设计、开发、部署和管理与云计算环境紧密结合的理念。它强调应用程序从设计之初就应当考虑到云的环境，充分利用云平台的弹性、分布式和自动化优势。云原生不仅仅是简单地将应用迁移到云上，而是利用云原生技术重新构思和设计应用，使其能够更高效地运行和扩展。
核心特点：
容器化：云原生应用通常采用容器化技术，如Docker，将应用程序及其所有依赖打包到一个独立的运行环境中，保证应用在不同环境中运行的一致性。容器化技术提高了应用的可移植性、可部署性和隔离性。微服务架构：云原生应用倾向于采用微服务架构，将应用拆分为一系列小的、独立的服务单元，每个服务专注于独立的业务功能。这种架构提高了应用的灵活性、可扩展性和可维护性。DevOps与持续交付：云原生应用强调DevOps文化和持续交付方法，通过自动化构建、测试和部署流程，实现快速迭代和频繁更新。这种敏捷的开发和交付方式使得应用能够更快地响应市场需求和用户反馈。 2、存储在云原生环境中的重要性 1. 数据持久性和一致性：
应用程序的容器可以快速启动和销毁，但数据需要持久保存。云原生环境中的存储解决方案（如持久卷）确保数据不会因容器的生命周期而丢失，并且在多节点、多区域中保持一致性。 2. 高可用性和灾备：
云原生存储通常具有内置的高可用性和灾难恢复机制。通过多副本、数据分片和地理分布，确保数据在硬件故障、网络中断或其他灾难情况下仍能被快速恢复和访问。 3. 扩展性：
随着应用程序和数据量的增长，存储解决方案需要具备横向扩展能力。云原生存储利用云平台的弹性资源，实现无缝扩展，满足动态的存储需求。 4. 性能优化：
云原生存储系统通常提供多种存储类型（如对象存储、块存储、文件存储）和不同的性能等级，以满足不同应用的需求。根据具体的工作负载特性，可以选择合适的存储类型和优化策略，提高数据访问和处理的效率。 二、云原生存储概述 1、云原生存储的定义与特性 定义
云原生存储是一种存储架构，专门为在容器化、微服务和动态编排环境中运行的应用程序而设计。它支持自动化管理和动态扩展，能够满足云原生应用的高性能、高可用性和高弹性的需求。
特性
1. 弹性和可扩展性：
支持根据需求动态扩展和缩减存储容量和性能，适应应用负载的变化。能够在多租户环境中隔离资源，确保资源分配的公平性和效率。 2. 自动化管理：
提供自动化的存储配置、管理和优化功能，减少手动干预。支持通过API进行存储资源的动态管理，便于与DevOps流程和工具集成。 3. 高性能：
支持不同的存储类型（如块存储、文件存储、对象存储）和性能层次，以满足不同应用的需求。提供低延迟、高吞吐量的数据访问性能，适应高并发的访问请求。 4. 可编排性：
深度集成容器编排系统（如Kubernetes），支持持久卷（Persistent Volumes, PV）和持久卷声明（Persistent Volume Claims, PVC）等资源类型的管理。支持存储类（StorageClass）定义，简化不同存储配置的使用。 5. 成本优化：
提供按需付费模式，帮助企业优化存储成本。支持数据生命周期管理，将不常用的数据转移到成本更低的存储层。 2、与传统存储架构的对比 云原生存储：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-30T07:30:00+08:00">
    <meta property="article:modified_time" content="2024-07-30T07:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从分布式存储到持久卷：【Cloud Native】存储的进化与实战策略</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1080" src="https://images2.imgbox.com/f3/0e/ZUoH0deh_o.jpg" width="1200"></p> 
<p style="text-align:center;">🐇明明跟你说过：<a href="https://blog.csdn.net/weixin_53269650?spm=1011.2415.3001.5343" title="个人主页">个人主页</a></p> 
<p style="text-align:center;">🏅个人专栏：<a href="https://blog.csdn.net/weixin_53269650/category_12701571.html?spm=1001.2014.3001.5482" title="《未来已来：云原生之旅》">《未来已来：云原生之旅》</a>🏅</p> 
<p style="text-align:center;">🔖行路有良友，便是天堂🔖</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80" rel="nofollow">一、引言</a></p> 
<p id="1%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E8%BF%B0" rel="nofollow">1、云原生概念简述</a></p> 
<p id="2%E3%80%81%E5%AD%98%E5%82%A8%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%C2%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%AD%98%E5%82%A8%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%C2%A0" rel="nofollow">2、存储在云原生环境中的重要性 </a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E6%A6%82%E8%BF%B0" rel="nofollow">二、云原生存储概述</a></p> 
<p id="1%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E6%80%A7%C2%A0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E6%80%A7%C2%A0" rel="nofollow">1、云原生存储的定义与特性 </a></p> 
<p id="2%E3%80%81%E4%B8%8E%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%8E%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">2、与传统存储架构的对比    </a></p> 
<p id="%E4%B8%89%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">三、云原生存储的解决方案</a></p> 
<p id="1%E3%80%81%E6%8C%81%E4%B9%85%E5%8D%B7%EF%BC%88Persistent%20Volumes%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%8C%81%E4%B9%85%E5%8D%B7%EF%BC%88Persistent%20Volumes%EF%BC%89" rel="nofollow">1、持久卷（Persistent Volumes）</a></p> 
<p id="1.1%E3%80%81%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#1.1%E3%80%81%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">1.1、概念与工作原理</a></p> 
<p id="1.2%E3%80%81%E5%9C%A8Kubernetes%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%C2%A0-toc" style="margin-left:80px;"><a href="#1.2%E3%80%81%E5%9C%A8Kubernetes%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%C2%A0" rel="nofollow">1.2、在Kubernetes中的应用案例 </a></p> 
<p id="1.2.1%E3%80%81PV%E5%88%9B%E5%BB%BA-toc" style="margin-left:120px;"><a href="#1.2.1%E3%80%81PV%E5%88%9B%E5%BB%BA" rel="nofollow">1.2.1、PV创建</a></p> 
<p id="1.2.2%E3%80%81PVC%E5%88%9B%E5%BB%BA-toc" style="margin-left:120px;"><a href="#1.2.2%E3%80%81PVC%E5%88%9B%E5%BB%BA" rel="nofollow">1.2.2、PVC创建</a></p> 
<p id="1.2.3%E3%80%81%E5%9C%A8Pod%E4%B8%AD%E8%B0%83%E7%94%A8-toc" style="margin-left:120px;"><a href="#1.2.3%E3%80%81%E5%9C%A8Pod%E4%B8%AD%E8%B0%83%E7%94%A8" rel="nofollow">1.2.3、在Pod中调用</a></p> 
<p id="1.2.4%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:120px;"><a href="#1.2.4%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">1.2.4、工作原理</a></p> 
<p id="2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F" rel="nofollow">2、分布式存储系统</a></p> 
<p id="2.1%E3%80%81Ceph%E3%80%81GlusterFS%E3%80%81Rook%E7%AD%89-toc" style="margin-left:80px;"><a href="#2.1%E3%80%81Ceph%E3%80%81GlusterFS%E3%80%81Rook%E7%AD%89" rel="nofollow">2.1、Ceph、GlusterFS、Rook等</a></p> 
<p id="2.2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E6%8C%91%E6%88%98-toc" style="margin-left:80px;"><a href="#2.2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E6%8C%91%E6%88%98" rel="nofollow">2.2、分布式存储的优势与挑战</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80">一、引言</h2> 
<h3 id="1%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E8%BF%B0">1、云原生概念简述</h3> 
<blockquote> 
 <p><span style="color:#fe2c24;">云原生（Cloud Native）</span>是一个近年来在云计算领域备受关注的概念，它代表了一种构建和运行应用程序的新型技术体系和方法论。</p> 
</blockquote> 
<p><span style="background-color:#c7e6ea;">定义：</span><br> 云原生是一种将应用程序设计、开发、部署和管理与云计算环境紧密结合的理念。它强调应用程序从设计之初就应当考虑到云的环境，充分利用云平台的弹性、分布式和自动化优势。云原生不仅仅是简单地将应用迁移到云上，而是利用云原生技术重新构思和设计应用，使其能够更高效地运行和扩展。</p> 
<p></p> 
<p><span style="background-color:#c7e6ea;">核心特点：</span></p> 
<ol><li><strong>容器化：</strong>云原生应用通常采用容器化技术，如Docker，将应用程序及其所有依赖打包到一个独立的运行环境中，保证应用在不同环境中运行的一致性。容器化技术提高了应用的可移植性、可部署性和隔离性。</li><li><strong>微服务架构：</strong>云原生应用倾向于采用微服务架构，将应用拆分为一系列小的、独立的服务单元，每个服务专注于独立的业务功能。这种架构提高了应用的灵活性、可扩展性和可维护性。</li><li><strong>DevOps与持续交付：</strong>云原生应用强调DevOps文化和持续交付方法，通过自动化构建、测试和部署流程，实现快速迭代和频繁更新。这种敏捷的开发和交付方式使得应用能够更快地响应市场需求和用户反馈。</li></ol> 
<p> </p> 
<p class="img-center"><img alt="" height="690" src="https://images2.imgbox.com/d6/5d/Po0dVikk_o.png" width="1200"></p> 
<p> </p> 
<h3 id="2%E3%80%81%E5%AD%98%E5%82%A8%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%C2%A0">2、存储在云原生环境中的重要性<span id="cke_bm_4651C"> </span></h3> 
<p><span style="background-color:#cbe0f1;">1. 数据持久性和一致性：</span></p> 
<ul><li>应用程序的容器可以快速启动和销毁，但数据需要持久保存。云原生环境中的存储解决方案（如持久卷）确保数据不会因容器的生命周期而丢失，并且在多节点、多区域中保持一致性。</li></ul> 
<p><br><span style="background-color:#cbe0f1;">2. 高可用性和灾备：</span></p> 
<ul><li>云原生存储通常具有内置的高可用性和灾难恢复机制。通过多副本、数据分片和地理分布，确保数据在硬件故障、网络中断或其他灾难情况下仍能被快速恢复和访问。</li></ul> 
<p><br><span style="background-color:#cbe0f1;">3. 扩展性：</span></p> 
<ul><li>随着应用程序和数据量的增长，存储解决方案需要具备横向扩展能力。云原生存储利用云平台的弹性资源，实现无缝扩展，满足动态的存储需求。</li></ul> 
<p><br><span style="background-color:#cbe0f1;">4. 性能优化：</span></p> 
<ul><li>云原生存储系统通常提供多种存储类型（如对象存储、块存储、文件存储）和不同的性能等级，以满足不同应用的需求。根据具体的工作负载特性，可以选择合适的存储类型和优化策略，提高数据访问和处理的效率。</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="837" src="https://images2.imgbox.com/ed/a5/csQmmNVf_o.png" width="1200"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E6%A6%82%E8%BF%B0"><strong>二、云原生存储概述</strong></h2> 
<h3 id="1%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E6%80%A7%C2%A0"><strong>1、</strong>云原生存储的定义与特性<span id="cke_bm_11855C"> </span></h3> 
<p><strong><span style="background-color:#c7e6ea;">定义</span></strong><br> 云原生存储是一种存储架构，专门为在容器化、微服务和动态编排环境中运行的应用程序而设计。它支持自动化管理和动态扩展，能够满足云原生应用的高性能、高可用性和高弹性的需求。</p> 
<p><strong><span style="background-color:#cbe0f1;">特性</span></strong><br><span style="background-color:#d4e9d5;">1. 弹性和可扩展性：</span></p> 
<ul><li>支持根据需求动态扩展和缩减存储容量和性能，适应应用负载的变化。</li><li>能够在多租户环境中隔离资源，确保资源分配的公平性和效率。</li></ul> 
<p><br><span style="background-color:#d4e9d5;">2. 自动化管理：</span></p> 
<ul><li>提供自动化的存储配置、管理和优化功能，减少手动干预。</li><li>支持通过API进行存储资源的动态管理，便于与DevOps流程和工具集成。</li></ul> 
<p><br><span style="background-color:#d4e9d5;">3. 高性能：</span></p> 
<ul><li>支持不同的存储类型（如块存储、文件存储、对象存储）和性能层次，以满足不同应用的需求。</li><li>提供低延迟、高吞吐量的数据访问性能，适应高并发的访问请求。</li></ul> 
<p><br><span style="background-color:#d4e9d5;">4. 可编排性：</span></p> 
<ul><li>深度集成容器编排系统（如<span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">Kubernetes</span></span>），支持持久卷（<span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">Persistent Volumes, PV</span></span>）和持久卷声明（<span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">Persistent Volume Claims, PVC</span></span>）等资源类型的管理。</li><li>支持存储类（<span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">StorageClass</span></span>）定义，简化不同存储配置的使用。</li></ul> 
<p><br><span style="background-color:#d4e9d5;">5. 成本优化：</span></p> 
<ul><li>提供按需付费模式，帮助企业优化存储成本。</li><li>支持数据生命周期管理，将不常用的数据转移到成本更低的存储层。</li></ul> 
<p class="img-center"><img alt="" height="918" src="https://images2.imgbox.com/12/f0/Iez18tJk_o.png" width="1200"></p> 
<h3 id="2%E3%80%81%E4%B8%8E%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0%C2%A0%C2%A0%C2%A0">2、与传统存储架构的对比    </h3> 
<p><span style="background-color:#f9eda6;">云原生存储：</span></p> 
<ul><li>强调自动化管理和自服务，通过API进行动态配置和操作。</li><li>使用软件定义存储（SDS）技术，实现灵活的存储资源分配和管理。</li><li>数据通常分布在多个节点和地理位置，使用分布式文件系统或对象存储系统。</li></ul> 
<p><br><span style="background-color:#f9eda6;">传统存储架构：</span></p> 
<ul><li>依赖专用硬件和存储设备，配置和管理相对复杂。</li><li>使用传统的存储协议和接口（如SAN、NAS）进行数据存储和访问。</li><li>数据通常集中存储在特定的存储设备或数据中心，扩展性受到物理限制。</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="1021" src="https://images2.imgbox.com/4a/68/m8Wr2tGT_o.png" width="1200"></p> 
<h2 id="%E4%B8%89%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">三、<strong>云原生存储的解决方案</strong></h2> 
<h3 id="1%E3%80%81%E6%8C%81%E4%B9%85%E5%8D%B7%EF%BC%88Persistent%20Volumes%EF%BC%89"><strong>1、持久卷（Persistent Volumes）</strong></h3> 
<h4 id="1.1%E3%80%81%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" style="background-color:transparent;"><strong>1.1、概念与工作原理</strong></h4> 
<blockquote> 
 <p><span style="color:#fe2c24;">持久卷（Persistent Volumes，PV）</span>是Kubernetes中的一种存储资源，专门为解决容器化应用的数据持久化需求而设计。PV独立于Pod的生命周期，确保数据在Pod重新调度或删除后仍然存在。持久卷与持久卷声明<span style="color:#fe2c24;">（Persistent Volume Claims，PVC）</span>配合使用，提供一种声明式的存储管理方式。</p> 
</blockquote> 
<p><strong>概念</strong><br><span style="background-color:#d4e9d5;">Persistent Volume (PV)：</span></p> 
<ul><li>持久卷是由集群管理员预先配置的存储资源，代表实际的存储。PV有不同的存储类型（如NFS、iSCSI、云存储等），并包含存储容量、访问模式等属性。</li><li>PV是一种集群资源，可以由多个Pod共享。</li></ul> 
<p><br><span style="background-color:#f9eda6;">Persistent Volume Claim (PVC)：</span></p> 
<ul><li>持久卷声明是用户对存储资源的请求，类似于Pod对计算资源的请求。用户通过PVC声明所需的存储容量、访问模式等。</li><li>PVC由Kubernetes动态绑定到合适的PV上，满足用户的存储需求。</li></ul> 
<p class="img-center"><img alt="" height="928" src="https://images2.imgbox.com/cf/3a/8zdcriqU_o.png" width="1200"></p> 
<p><strong>工作原理</strong><br><span style="background-color:#dad5e9;">1. PV的创建：</span></p> 
<ul><li>集群管理员根据实际需求，预先配置和创建PV。每个PV包含存储容量、访问模式（如ReadWriteOnce、ReadOnlyMany、ReadWriteMany）和存储类型等信息。</li></ul> 
<p><br><span style="background-color:#dad5e9;">2. PVC的声明：</span></p> 
<ul><li>用户在应用配置文件中定义PVC，指定所需的存储容量和访问模式。PVC是声明式的，描述了应用对存储资源的需求。</li></ul> 
<p><br><span style="background-color:#dad5e9;">3. PVC与PV的绑定：</span></p> 
<ul><li>Kubernetes控制器监控PVC的创建事件，根据PVC的请求参数，查找并绑定合适的PV。如果找到符合条件的PV，PVC和PV会自动绑定在一起。如果没有合适的PV，PVC会保持Pending状态，直到有合适的PV可用。</li><li>绑定后，PV的状态变为Bound，PVC也变为Bound状态。</li></ul> 
<p><br><span style="background-color:#dad5e9;">4. 在Pod中使用PVC：</span></p> 
<ul><li>在Pod的配置文件中，用户可以引用已绑定的PVC，将其挂载到Pod的文件系统中。这样，Pod可以像使用本地文件系统一样访问持久化存储。</li><li>多个Pod可以共享同一个PVC（取决于访问模式），实现数据共享和持久化。</li></ul> 
<p><br><span style="background-color:#dad5e9;">5. PV的回收：</span></p> 
<ul><li>当PVC不再需要时，用户可以删除PVC。根据PV的回收策略（Reclaim Policy），PV会执行不同的操作： 
  <ul><li><span id="cke_bm_40058C"> </span><strong>Retain：</strong>PV会保留数据，需要管理员手动回收和清理。</li><li><span id="cke_bm_40468C"> </span><strong>Recycle：</strong>PV会执行基本的清理操作（如删除文件），然后重新变为Available状态。</li><li><span id="cke_bm_40918C"> </span><strong>Delete：</strong>PV及其数据会被删除，存储资源释放。</li></ul></li></ul> 
<p><span id="cke_bm_43036C"> </span></p> 
<p class="img-center"><img alt="" height="1108" src="https://images2.imgbox.com/d7/d4/VtYRisD8_o.png" width="1200"></p> 
<p></p> 
<h4 id="1.2%E3%80%81%E5%9C%A8Kubernetes%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%C2%A0">1.2、在Kubernetes中的应用案例<span id="cke_bm_45922C"> </span></h4> 
<h5 id="1.2.1%E3%80%81PV%E5%88%9B%E5%BB%BA" style="background-color:transparent;">1.2.1、PV创建</h5> 
<pre><code class="hljs">apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  nfs:
    path: /path/to/nfs
    server: nfs-server.example.com</code></pre> 
<p> </p> 
<ul><li><strong>nfs</strong> 
  <ul><li><span id="cke_bm_48000C"> </span>指定使用NFS存储。</li><li><span id="cke_bm_48272C"> </span>path: /path/to/nfs 
    <ul><li><span id="cke_bm_48521C"> </span><span id="cke_bm_48661C"> </span>NFS服务器上的共享目录路径。 </li></ul></li><li><span id="cke_bm_49193C"> </span>server: nfs-server.example.com 
    <ul><li><span id="cke_bm_49465C"> </span><span id="cke_bm_49702C"> </span>NFS服务器的地址。</li></ul></li></ul></li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="883" src="https://images2.imgbox.com/8c/2d/ozDTtPbb_o.png" width="1200"></p> 
<h5 id="1.2.2%E3%80%81PVC%E5%88%9B%E5%BB%BA">1.2.2、PVC创建</h5> 
<pre><code class="hljs">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: example-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi</code></pre> 
<ul><li><strong>ReadWriteOnce：</strong>这个PVC请求的访问模式。ReadWriteOnce表示这个卷可以被单个节点以读写模式挂载。</li><li><strong>storage：</strong>10Gi 请求的存储容量为10GiB。</li></ul> 
<h5 id="1.2.3%E3%80%81%E5%9C%A8Pod%E4%B8%AD%E8%B0%83%E7%94%A8">1.2.3、在Pod中调用</h5> 
<pre><code class="hljs">apiVersion: v1
kind: Pod
metadata:
  name: example-pod
spec:
  containers:
    - name: example-container
      image: nginx
      volumeMounts:
        - mountPath: "/usr/share/nginx/html"
          name: example-storage
  volumes:
    - name: example-storage
      persistentVolumeClaim:
        claimName: example-pvc</code></pre> 
<ul><li><strong>mountPath: "/usr/share/nginx/html" </strong>指定卷在容器内的挂载路径，这里是nginx的默认静态文件目录。</li><li><strong>name: example-storage </strong>指定与卷定义关联的名称。</li><li><strong>name: example-storage</strong> 卷的名称，与volumeMounts中的name匹配。</li><li><strong>claimName: example-pvc</strong> 引用已创建的PVC，挂载相应的存储卷。</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="769" src="https://images2.imgbox.com/36/3a/1HN9VZMi_o.png" width="1200"></p> 
<h5 id="1.2.4%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">1.2.4、工作原理</h5> 
<p><span style="background-color:#dad5e9;">Pod创建时：</span></p> 
<ul><li>Kubernetes会根据Pod定义中的volumes部分，找到名称为example-storage的卷，并将其与PVC example-pvc关联。</li><li>example-pvc已经绑定到一个符合要求的PersistentVolume (PV)，因此这个PV将被挂载到Pod中。</li></ul> 
<p><br><span style="background-color:#dad5e9;">容器启动时：</span></p> 
<ul><li>在Pod中定义的容器启动时，Kubernetes会根据volumeMounts部分，将与example-storage相关联的卷挂载到容器的/usr/share/nginx/html路径。</li><li>容器内的应用（如nginx）将能够访问这个挂载路径上的数据，并使用这个持久存储。</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="1015" src="https://images2.imgbox.com/08/a3/xP26iEjo_o.png" width="1200"></p> 
<h3 id="2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F">2、<strong>分布式存储系统</strong></h3> 
<h4 id="2.1%E3%80%81Ceph%E3%80%81GlusterFS%E3%80%81Rook%E7%AD%89">2.1、Ceph、GlusterFS、Rook等</h4> 
<p><span style="background-color:#ffd7b9;">Ceph</span><br><strong>概述</strong></p> 
<ul><li>Ceph是一个开源的分布式存储系统，提供高性能、高可用性和可扩展性。它可以统一存储块设备、文件系统和对象存储，适用于各种规模的存储需求。</li></ul> 
<p><strong>特性</strong></p> 
<ol><li><strong>去中心化架构：</strong>Ceph采用CRUSH算法（Controlled Replication Under Scalable Hashing）进行数据分布，避免单点故障。</li><li><strong>自我修复：</strong>系统能够自动检测和修复数据损坏，确保数据的完整性。</li><li><strong>高扩展性：</strong>可以从几台节点扩展到数千台节点，存储容量几乎无限。</li><li><strong>统一存储：</strong>支持块存储（RBD）、对象存储（RADOS Gateway）和文件系统存储（CephFS）。</li></ol> 
<p><strong>用例</strong></p> 
<ul><li>OpenStack的后端存储</li><li>高性能计算（HPC）环境</li><li>云存储服务 </li></ul> 
<p>  <img alt="" height="846" src="https://images2.imgbox.com/df/a8/3K6TFB5o_o.png" width="1200"> </p> 
<p><span style="background-color:#d4e9d5;">GlusterFS</span><br><strong>概述</strong></p> 
<ul><li>GlusterFS是一个开源的分布式文件系统，专注于高可用性和可扩展性。它使用用户态操作，不需要内核模块，简化了部署和维护。</li></ul> 
<p><strong>特性</strong></p> 
<ol><li><strong>弹性可扩展性：</strong>可以轻松扩展存储容量，通过添加新的存储节点实现水平扩展。</li><li><strong>高可用性：</strong>通过多副本机制和自我修复功能，确保数据的高可用性。</li><li><strong>无元数据服务器：</strong>通过散列算法直接定位数据，消除了元数据服务器的瓶颈。</li><li><strong>多协议支持：</strong>支持NFS、SMB、以及原生GlusterFS协议等多种访问方式。</li></ol> 
<p><br><strong>用例</strong></p> 
<ul><li>大数据分析和处理</li><li>媒体内容存储和流媒体服务</li><li>备份和灾难恢复解决方案</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="963" src="https://images2.imgbox.com/2f/cb/3V1HEuFj_o.png" width="1200"></p> 
<p> </p> 
<p><span style="background-color:#cbe0f1;">Rook</span><br><strong>概述</strong></p> 
<ul><li>Rook是一个开源的云原生存储编排器，专为Kubernetes设计，旨在自动化存储集群的部署、管理和扩展。Rook提供了对Ceph等存储系统的支持，使其与Kubernetes无缝集成。</li></ul> 
<p><strong>特性</strong></p> 
<ol><li><strong>云原生设计：</strong>原生支持Kubernetes，通过Custom Resource Definitions (CRDs)和Operators来管理存储集群。</li><li><strong>自动化操作：</strong>自动执行存储集群的部署、配置、扩展和自愈操作，减少运维负担。</li><li><strong>多存储后端支持：</strong>目前支持Ceph，并计划支持更多的存储系统，如NFS、CockroachDB等。</li><li><strong>高可用性：</strong>通过Kubernetes的高可用性和容错机制，确保存储服务的稳定性。</li></ol> 
<p><br><strong>用例</strong></p> 
<ul><li>Kubernetes集群的持久化存储解决方案</li><li>动态存储卷管理</li><li>集群中的数据持久化和高可用性服务</li></ul> 
<p class="img-center"><img alt="" height="670" src="https://images2.imgbox.com/67/a4/oQWkenf0_o.png" width="1200"></p> 
<h4 id="2.2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E6%8C%91%E6%88%98">2.2、分布式存储的优势与挑战</h4> 
<p><strong>优势</strong><br><span style="background-color:#ffd7b9;">高可用性</span></p> 
<ul><li><strong>冗余和复制：</strong>分布式存储系统通常通过数据复制和冗余来确保高可用性，即使某些节点出现故障，数据仍然可用。</li><li><strong>自动故障恢复：</strong>系统可以自动检测和恢复故障节点，确保数据持续可用。</li></ul> 
<p><br><span style="background-color:#d4e9d5;">可扩展性</span></p> 
<ul><li><strong>水平扩展：</strong>可以通过添加更多的存储节点来增加存储容量和处理能力，适应业务增长需求。</li><li><strong>弹性扩展：</strong>系统能够动态地调整资源，以满足不同的工作负载需求。</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="787" src="https://images2.imgbox.com/cb/85/Em5T3tWN_o.png" width="1200"></p> 
<p> </p> 
<p><strong>挑战</strong><br><span style="background-color:#c7e6ea;">复杂性</span></p> 
<ul><li><strong>系统管理：</strong>分布式存储系统的部署、配置和管理比集中式存储复杂，需要专业技能和工具。</li><li><strong>故障排查：</strong>故障排查和调试更加复杂，因为涉及多个节点和网络。</li></ul> 
<p><br><span style="background-color:#cbe0f1;">网络依赖</span></p> 
<ul><li><strong>网络延迟：</strong>数据传输依赖于网络性能，网络延迟和带宽限制可能影响系统性能。</li><li><strong>带宽需求：</strong>数据复制和同步需要消耗大量网络带宽，可能对网络造成负担。</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="532" src="https://images2.imgbox.com/cb/32/FZ33KVIJ_o.png" width="1176"></p> 
<blockquote> 
 <p>💕💕💕每一次的分享都是一次成长的旅程，感谢您的陪伴和关注。希望这些关于云原生的文章能陪伴您走过技术的一段旅程，共同见证成长和进步！😺😺😺</p> 
 <p></p> 
 <p>🧨🧨🧨让我们一起在技术的海洋中探索前行，共同书写美好的未来！！！  </p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c6202b56dcc3318de861c87d9172e1b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中的网络编程：从Socket到NIO</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf8b57ca4dd0e8d7dd96c906489c125e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【保姆级教程】免费域名注册 &amp; Cloudflare 域名解析 &amp; Ngnix端口转发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>