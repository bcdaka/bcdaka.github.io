<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】红黑树——领略天才的想法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/049ccaf5d4a8d36ffcc68139b85d920e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】红黑树——领略天才的想法">
  <meta property="og:description" content="个人主页：东洛的克莱斯韦克-CSDN博客 祝福语：愿你拥抱自由的风 目录
二叉搜索树
AVL树
红黑树概述
性质详解
效率对比
旋转操作
元素操作
代码实现
二叉搜索树 【数据结构】二叉搜索树-CSDN博客
AVL树 【数据结构】AVL树——平衡二叉搜索树-CSDN博客
红黑树概述 概念
在二叉搜索树的基础上符合一下性质便是红黑树
每一个节点不是红色就是黑色
根节点一定是黑色
空节点一定是黑色
父亲节点和孩子节点不能是连续的红色节点
每一条根节点至空节点路径上的黑色节点的数量一定相等
​
性质详解 理解路径
红黑树中，一条完整路径不是从叶子节点溯源至根节点，而是从空节点溯源至根节点
​
理解最长和最短路径
如果全是黑色节点，红黑树就是一颗满二叉树，因为每条路径的黑色节点数量相等
​
那么这颗树的每条完整路径都是最短路径，
如果在一条路径上红黑节点间隔（不允许连续的有红色节点），那么该路径为最长路径。
​
红黑树规则
那么最长路径是最短路径的两倍。这便是红黑树的平衡规则。
满二叉树的平衡条件是左右子树高度差为0，AVL树的平衡条件是左右子树高度差小于等于 1，相比于前两棵树平衡条件，红黑树是一种弱平衡。
红黑树和AVL树一样，只要保证自己的平衡规则不被打破，就能使自己不退化为类似于链表的结构。
退化成类似链表的结构——插入的数据接近有序或插入大量的数据不够随机或进行了一些插入删除等操作。
效率对比 查找效率
从直觉上讲，红黑树只是维持一种弱平衡，在最坏情况下，红黑树的高度是AVL树高度的两倍，那么红黑树查找数据的效率也应该比AVL树低两倍才对，为什么我们认为红黑树是一种更优的数据结构呢？下面小编带大家算笔账
2的40次方是一万亿，也就是说用满二叉树存一万亿个数据高度为40。AVL树是有高度差的，所以最坏情况下会查找40多次，而红黑树最坏情况下会找80多次。
那么对于cpu而言，找40多次和找80多次有区别吗？答案是没有的，现在的cpu每秒钟可以运算十亿次甚至几百亿。
可以理解为，在查找数据的效率上AVL树和红黑树是一样的。那么，红黑树的优势在哪里呢？
插入删除效率
不管是红黑树还是AVL树，如果打破平衡都需要旋转这一操作恢复平衡，旋转所付出的时间复杂度为。对于AVL树而言，需要溯源更新平衡因子，对于红黑树而言，需要溯源更新节点颜色，溯源更新最坏情况下是从叶子节点更新到根节点，所付出的时间复杂度为。
因为AVL树的高度差小于等于1，平衡很容易被打破，要维持平衡就需要不断地付出和来维持平衡。
那么红黑树维持弱平衡就不需要总是付出这样地代价，所以红黑树是一种更优的数据结构
旋转操作 旋转操作不是AVL树或红黑树特有的，旋转一次的本质是让二叉搜索树的某棵子树的高度减一。
对于红黑树而言，最长路径是最短路径的二倍加一，就意味着打破平衡，需要通过旋转让最长路径上的某棵子树高度减一来恢复平衡。旋转后需要更新节点的颜色，具体要怎么控制颜色下面细讲，现在看一下旋转操作吧
左单旋：新节点插入较高右子树的右侧——对fathernode
​
void RevolveLeft(node *&amp; fathernode)//左单旋 { node* cur = fathernode-&gt;_right; //父亲节点的右孩子 fathernode-&gt;_right = cur-&gt;_left; //更改指向关系 if (cur-&gt;_left !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T14:01:37+08:00">
    <meta property="article:modified_time" content="2024-05-27T14:01:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】红黑树——领略天才的想法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>个人主页：<a href="https://blog.csdn.net/2301_79796701?spm=1000.2115.3001.5343" title="东洛的克莱斯韦克-CSDN博客">东洛的克莱斯韦克-CSDN博客</a></strong>  </p> 
 <p></p> 
 <p><strong>祝福语：愿你拥抱自由的风       </strong></p> 
 <p></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" rel="nofollow">二叉搜索树</a></p> 
<p id="AVL%E6%A0%91-toc" style="margin-left:0px;"><a href="#AVL%E6%A0%91" rel="nofollow">AVL树</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A6%82%E8%BF%B0" rel="nofollow">红黑树概述</a></p> 
<p id="%E6%80%A7%E8%B4%A8%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E6%80%A7%E8%B4%A8%E8%AF%A6%E8%A7%A3" rel="nofollow">性质详解</a></p> 
<p id="%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94-toc" style="margin-left:0px;"><a href="#%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94" rel="nofollow">效率对比</a></p> 
<p id="%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C" rel="nofollow">旋转操作</a></p> 
<p id="%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C" rel="nofollow">元素操作</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">代码实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</h2> 
<p></p> 
<p><a href="https://blog.csdn.net/2301_79796701/article/details/139104202?spm=1001.2014.3001.5501" title="【数据结构】二叉搜索树-CSDN博客">【数据结构】二叉搜索树-CSDN博客</a></p> 
<p></p> 
<h2 id="AVL%E6%A0%91">AVL树</h2> 
<p></p> 
<p><a href="https://blog.csdn.net/2301_79796701/article/details/139193271?spm=1001.2014.3001.5501" title="【数据结构】AVL树——平衡二叉搜索树-CSDN博客">【数据结构】AVL树——平衡二叉搜索树-CSDN博客</a></p> 
<p></p> 
<h2 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A6%82%E8%BF%B0">红黑树概述</h2> 
<blockquote> 
 <p><strong>概念</strong></p> 
</blockquote> 
<p>在二叉搜索树的基础上符合一下性质便是红黑树</p> 
<p><strong><span style="background-color:#38d8f0;">每一个节点不是红色就是黑色</span></strong></p> 
<p><strong><span style="background-color:#38d8f0;">根节点一定是黑色</span></strong></p> 
<p><strong><span style="background-color:#38d8f0;">空节点一定是黑色</span></strong></p> 
<p><strong><span style="background-color:#38d8f0;">父亲节点和孩子节点不能是连续的红色节点</span></strong></p> 
<p><strong><span style="background-color:#38d8f0;">每一条根节点至空节点路径上的黑色节点的数量一定相等</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/94/1c/lvnY60OC_o.png">​</p> 
<h2 id="%E6%80%A7%E8%B4%A8%E8%AF%A6%E8%A7%A3">性质详解</h2> 
<blockquote> 
 <p><strong>理解路径</strong></p> 
</blockquote> 
<p>红黑树中，一条完整路径不是从叶子节点溯源至根节点，而是从空节点溯源至根节点</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/22/4d/KI8C3ppy_o.png">​</p> 
<blockquote> 
 <p><strong>理解最长和最短路径</strong></p> 
</blockquote> 
<p>如果全是黑色节点，红黑树就是一颗满二叉树，因为每条路径的黑色节点数量相等</p> 
<p><img alt="" src="https://images2.imgbox.com/9a/cb/sZhesTCu_o.png">​</p> 
<p>那么这颗树的每条完整路径都是最短路径，</p> 
<p>如果在一条路径上红黑节点间隔（不允许连续的有红色节点），那么该路径为最长路径。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/d5/EvHphTpd_o.png">​</p> 
<blockquote> 
 <p><strong>红黑树规则</strong></p> 
</blockquote> 
<p>那么<span style="color:#ed7976;">最长路径是最短路径的两倍</span>。这便是红黑树的平衡规则。</p> 
<p>满二叉树的平衡条件是左右子树高度差为0，AVL树的平衡条件是左右子树高度差小于等于 1，相比于前两棵树平衡条件，红黑树是一种<span style="color:#ed7976;">弱平衡</span>。</p> 
<p>红黑树和AVL树一样，只要保证自己的平衡规则不被打破，就能使自己不退化为类似于链表的结构。</p> 
<p>退化成类似链表的结构——插入的数据接近有序或插入大量的数据不够随机或进行了一些插入删除等操作。</p> 
<h2 id="%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94">效率对比</h2> 
<blockquote> 
 <p><strong>查找效率</strong></p> 
</blockquote> 
<p>从直觉上讲，红黑树只是维持一种弱平衡，在最坏情况下，红黑树的高度是AVL树高度的两倍，那么红黑树查找数据的效率也应该比AVL树低两倍才对，为什么我们认为红黑树是一种更优的数据结构呢？下面小编带大家算笔账</p> 
<p>2的40次方是一万亿，也就是说用满二叉树存一万亿个数据高度为40。AVL树是有高度差的，所以最坏情况下会查找40多次，而红黑树最坏情况下会找80多次。</p> 
<p>那么对于cpu而言，找40多次和找80多次有区别吗？答案是没有的，现在的cpu每秒钟可以运算十亿次甚至几百亿。</p> 
<p>可以理解为，<span style="color:#ed7976;">在查找数据的效率上AVL树和红黑树是一样的</span>。那么，红黑树的优势在哪里呢？</p> 
<blockquote> 
 <p><strong>插入删除效率</strong></p> 
</blockquote> 
<p>不管是红黑树还是AVL树，如果打破平衡都需要<span style="color:#ed7976;">旋转</span>这一操作恢复平衡，旋转所付出的时间复杂度为<img alt="O(1)" class="mathcode" src="https://images2.imgbox.com/f9/d5/E6SFE2Z8_o.png">。对于AVL树而言，需要溯源更新平衡因子，对于红黑树而言，需要溯源更新节点颜色，<span style="color:#ed7976;">溯源更新</span>最坏情况下是从叶子节点更新到根节点，所付出的时间复杂度为<img alt="O(logN)" class="mathcode" src="https://images2.imgbox.com/92/fd/QyubwznN_o.png">。</p> 
<p>因为AVL树的高度差小于等于1，平衡很容易被打破，要维持平衡就需要不断地付出<img alt="O(1)" class="mathcode" src="https://images2.imgbox.com/63/e1/orgWjnF6_o.png">和<img alt="O(logN)" class="mathcode" src="https://images2.imgbox.com/f8/6f/V0ADXv7F_o.png">来维持平衡。</p> 
<p>那么红黑树维持弱平衡就不需要<span style="color:#ed7976;">总是</span>付出这样地代价，所以红黑树是一种更优的数据结构</p> 
<h2 id="%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C">旋转操作</h2> 
<p>旋转操作不是AVL树或红黑树特有的，<span style="color:#ed7976;">旋转一次的本质是让二叉搜索树的某棵子树的高度减一</span>。</p> 
<p>对于红黑树而言，最长路径是最短路径的二倍加一，就意味着打破平衡，需要通过旋转让最长路径上的某棵子树高度减一来恢复平衡。旋转后需要更新节点的颜色，具体要怎么控制颜色下面细讲，现在看一下旋转操作吧</p> 
<blockquote> 
 <p id="%E5%B7%A6%E5%8D%95%E6%97%8B"><strong>左单旋：新节点插入较高右子树的右侧——对fathernode</strong></p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/bb/72/osAz6oMX_o.png">​</p> 
<pre><code class="language-cpp">void RevolveLeft(node *&amp; fathernode)//左单旋      
{
	node* cur = fathernode-&gt;_right; //父亲节点的右孩子
 
	fathernode-&gt;_right = cur-&gt;_left; //更改指向关系
 
	if (cur-&gt;_left != nullptr) //特殊情况
		cur-&gt;_left-&gt;_FatherNode = fathernode;//更改指向关系
 
	cur-&gt;_FatherNode = fathernode-&gt;_FatherNode;//更改指向关系
 
	if (fathernode-&gt;_FatherNode != nullptr) //为空是特殊情况，
	{
 
		if (fathernode-&gt;_FatherNode-&gt;_right == fathernode)
		{
			fathernode-&gt;_FatherNode-&gt;_right = cur;//更改指向关系
		}
		else
		{
			fathernode-&gt;_FatherNode-&gt;_left = cur;//更改指向关系
		}
 
	}
 
	cur-&gt;_left = fathernode;//更改指向关系
 
	fathernode-&gt;_FatherNode = cur;//更改指向关系
 
 
}</code></pre> 
<blockquote> 
 <p id="%E5%8F%B3%E5%8D%95%E6%97%8B"><strong>右单旋：新节点插入较高左子树的左侧——对fathernode</strong></p> 
</blockquote> 
<pre><code class="language-cpp">void RevolveRight(node *&amp; fathernode) //右单旋
{
	node* cur = fathernode-&gt;_left; //父亲节点的左节点
 
	fathernode-&gt;_left = cur-&gt;_right;//更新指向关系
 
	if (cur-&gt;_right != nullptr) //特殊情况
		cur-&gt;_right-&gt;_FatherNode = fathernode;//更新指向关系
 
	cur-&gt;_FatherNode = fathernode-&gt;_FatherNode;//更新指向关系
 
	if (fathernode-&gt;_FatherNode != nullptr)//特殊情况
	{
 
		if (fathernode-&gt;_FatherNode-&gt;_right == fathernode)
		{
			fathernode-&gt;_FatherNode-&gt;_right = cur;//更新指向关系
		}
		else
		{
			fathernode-&gt;_FatherNode-&gt;_left = cur;//更新指向关系
		}
 
	}
 
 
	cur-&gt;_right = fathernode;//更新指向关系
	fathernode-&gt;_FatherNode = cur;//更新指向关系
 
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f2/66/IBG5pexM_o.png">​</p> 
<blockquote> 
 <p id="%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B"><strong>左右双旋：新节点插入在较高左子树的右侧——先对fathernodeL左单旋再对fathernodeLR右单旋</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/d0/qfBiFDjC_o.png">​</p> 
<blockquote> 
 <p id="%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B"><strong>右左双旋：新节点插入再较高右子树的左侧——先对fathernodeR右单旋再对fathernodeRL左单旋</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a5/37/f245xhtj_o.png">​</p> 
<h2 id="%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C">元素操作</h2> 
<p>我们再来理解一下红黑树两条核心性质</p> 
<p><strong><span style="background-color:#38d8f0;">父亲节点和孩子节点不能是连续的红色节点</span></strong></p> 
<p><strong><span style="background-color:#38d8f0;">每一条根节点至空节点路径上的黑色节点的数量一定相等</span></strong></p> 
<p>红黑树插入的新节点应该是黑色还是红色呢？</p> 
<p>也就是说，插入红色节点可能会破坏第一条性质，插入黑色节点会破坏第二条性质。第一条性质被破坏只影响了当前路径，而第二条性质被破坏影响的是所有路径。所以<span style="color:#ed7976;">插入新节点的颜色是红色</span>。</p> 
<p>如果新插入节点的父亲节点是黑色，那么不会破坏任何性质，如果新插入节点的父亲节点是红色该怎么办呢？</p> 
<blockquote> 
 <p><strong>颜色管理</strong></p> 
</blockquote> 
<p>下面介绍红黑树如何通过管理颜色来判断是否需要旋转，为了方便讨论讨论，给以下节点起个别名，</p> 
<p>父亲节点：Father</p> 
<p>孩子节点：child（父亲节点的孩子节点）</p> 
<p>祖父节点：grandfather（父亲节点的父亲节点）</p> 
<p>叔叔节点：uncle（如果父亲节点是祖父节点的左孩子，叔叔节点就是祖父节点的右孩子，反之亦然）</p> 
<p>如果新节点的父亲节点为黑，插入成功。如果父亲节点为红，需要溯源更新颜色，规则如下：</p> 
<p><span style="color:#ed7976;">如果uncle存在且为红色，Father和uncle变为黑色，grandfather变为黑色，让grandfather变为child，继续溯源更新</span>。</p> 
<p><span style="color:#ed7976;">如果更新至整棵树的根节点（Father为空），让根节点置黑，或uncle为空或uncle黑色，停止溯源更新</span>（uncle为空或uncle黑色后面会讨论）。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/88/5d/sxfMLsyj_o.png"></p> 
<p>如果<span style="color:#ed7976;">uncle不存在，或uncle存在且为黑，说明红黑树的平衡被打破了，此时就不需要溯源更新颜色了，需要旋转来恢复红黑树的平衡，旋转之后再更新Father，grandfather或child的颜色</span></p> 
<p><strong>右单旋颜色更新：</strong></p> 
<p>Father成为了根需要变成黑色节点，Father旋转之前的孩子节点为黑，该孩子会成为grandfather左孩子，grandfather需要变成红节点。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/fa/XUuWXXDy_o.png"></p> 
<p>为什么Father旋转之前的孩子节点为黑呢？因为数据是一个一个插入的，新节点只会和一条路径上的父亲节点冲突，如果这是一颗正常的红黑树，Father旋转之前的孩子节点只能为黑色。Father作为根是黑色的，Father的孩子节点也只能是红色的。下面的旋转也一样</p> 
<p><strong>左单旋颜色更新：</strong></p> 
<p>还是和右单旋一样，Father成了根需要变成黑色，grandfather需要变成红色。<img alt="" src="https://images2.imgbox.com/f6/87/wLVlX05E_o.png"></p> 
<p><strong>双旋颜色更新：</strong></p> 
<p>无论是左右双旋还是右左双旋，最终都是child变成了根，grandfather和Father变成了child的左右孩子，grandfatjie作为孩子需要变成红色。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fe/e7/yF0lFbeF_o.png"></p> 
<h2 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h2> 
<p><a href="https://blog.csdn.net/2301_79796701/article/details/138844019?spm=1001.2014.3001.5502" title="【C++】详解C++的模板-CSDN博客">【C++】详解C++的模板-CSDN博客</a></p> 
<pre><code class="language-cpp">enum Color { RED, BLACK };    

template &lt;class K&gt;
class RBTreeNode
{
public:

	
	typedef RBTreeNode &lt;K&gt; node_type;   

	K _ky;   
	node_type* _left;
	node_type* _right;
	node_type* _FatherNode;  
	Color _color;

	RBTreeNode(const K&amp; key)
		:_ky(key)
		,_left(nullptr)
		,_right(nullptr)
		, _FatherNode(nullptr)  
		,_color(RED)
	{
	}

};

template &lt;class K&gt; 
class RBTree
{
public:

	typedef RBTreeNode &lt;K&gt; node_type;

	RBTree()
		:_root(nullptr)    
	{
	}

	bool Insert(const K&amp; key)//插入元素     
	{
		//
		//

		if (nullptr == _root) //是否是空树
		{
			_root = new node_type(key);
			_root-&gt;_color = BLACK;     
			return true;
		
		}
		//
		node_type* cur = _root;
		node_type* fathernode = nullptr;  
		
		while (cur)
		{
			if (cur-&gt;_ky &lt; key)    
			{
				fathernode = cur;  
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_ky &gt; key)     
			{
				fathernode = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}

		}


		cur = new node_type(key); //新插入节点 
		if (fathernode-&gt;_ky &lt; cur-&gt;_ky)    
		{
			fathernode-&gt;_right = cur;
			cur-&gt;_FatherNode = fathernode;

		}
		else
		{
			fathernode-&gt;_left = cur;
			cur-&gt;_FatherNode = fathernode;
		}


		while (fathernode &amp;&amp; fathernode-&gt;_color == RED)  
		{
			node_type* grandfather_node = fathernode-&gt;_FatherNode;
			node_type* unclenode = nullptr;

			if (fathernode == grandfather_node-&gt;_left) //父亲节点是祖父节点的左孩子
			{
				 unclenode = grandfather_node-&gt;_right; //叔叔节点是祖父节点的右孩子

				 if (unclenode == nullptr || unclenode-&gt;_color == BLACK)
				 {
					 if (cur == fathernode-&gt;_left)  
					 {
						 RevolveRight(fathernode);
						 fathernode-&gt;_color = BLACK;
						 grandfather_node-&gt;_color = RED; 
					 }
					 else if (cur == fathernode-&gt;_right)
					 {
						 RevolveLeft(fathernode);
						 RevolveRight(cur);

						 cur-&gt;_color = BLACK;   
						 grandfather_node-&gt;_color = RED;     
					 }
				 }
		        else
				{
					fathernode-&gt;_color = BLACK; //父亲变黑
					unclenode-&gt;_color = BLACK;  //叔叔变黑
					grandfather_node-&gt;_color = RED; //爷爷变红
					 
					cur = grandfather_node;
					fathernode = cur-&gt;_FatherNode; 
					
				}

			}
			else//父亲节点是祖父节点的右孩子
			{
				unclenode = grandfather_node-&gt;_left; //叔叔节点是祖父节点的左孩子       

				if (unclenode == nullptr || unclenode-&gt;_color == BLACK)
				{
					if (cur == fathernode-&gt;_right)
					{
						RevolveLeft(fathernode);   
						fathernode-&gt;_color = BLACK;
						grandfather_node-&gt;_color = RED;
					}
					else if (cur == fathernode-&gt;_left)
					{
						RevolveRight(fathernode);
						RevolveLeft(cur);     
						
						cur-&gt;_color = BLACK;
						grandfather_node-&gt;_color = RED;
					}
				}
				else  
				{
					fathernode-&gt;_color = BLACK; //父亲变黑
					unclenode-&gt;_color = BLACK;  //叔叔变黑
					grandfather_node-&gt;_color = RED; //爷爷变红

					cur = grandfather_node;
					fathernode = cur-&gt;_FatherNode;
				
				}
			}
			
		  



	
		}


		_root-&gt;_color = BLACK;  
		return true;

	}







private:
	void RevolveLeft(node_type*&amp; fathernode)//左单旋        
	{
		node_type* cur = fathernode-&gt;_right;  

		fathernode-&gt;_right = cur-&gt;_left;

		if (cur-&gt;_left != nullptr)
			cur-&gt;_left-&gt;_FatherNode = fathernode;

		cur-&gt;_FatherNode = fathernode-&gt;_FatherNode;

		if (fathernode-&gt;_FatherNode != nullptr)
		{
			if (fathernode-&gt;_FatherNode-&gt;_right == fathernode)
			{
				fathernode-&gt;_FatherNode-&gt;_right = cur;
			}
			else
			{
				fathernode-&gt;_FatherNode-&gt;_left = cur;
			}
		}

		cur-&gt;_left = fathernode;
		fathernode-&gt;_FatherNode = cur;

	}



	void RevolveRight(node_type*&amp; fathernode) //右单旋 
	{
		node_type* cur = fathernode-&gt;_left;  

		fathernode-&gt;_left = cur-&gt;_right;

		if (cur-&gt;_right != nullptr)
			cur-&gt;_right-&gt;_FatherNode = fathernode;

		cur-&gt;_FatherNode = fathernode-&gt;_FatherNode;

		if (fathernode-&gt;_FatherNode != nullptr)
		{
			if (fathernode-&gt;_FatherNode-&gt;_right == fathernode)
			{
				fathernode-&gt;_FatherNode-&gt;_right = cur;
			}
			else
			{
				fathernode-&gt;_FatherNode-&gt;_left = cur;
			}
		}

		cur-&gt;_right = fathernode;
		fathernode-&gt;_FatherNode = cur;

	}



	node_type* _root;
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba563198fc5a0e7a8b427f7959c8d61e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;系列——————类和对象（上）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e97488eb5ddf3a9f6e327bd240bf3599/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【vscode 怎么实现ctrl&#43;鼠标左键点击模组，能够进入PYTHONPATH(第三方)的模组里面】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>