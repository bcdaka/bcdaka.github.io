<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kafka的分区副本机制 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9b960031cbb42602ff1271d28e37376d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Kafka的分区副本机制">
  <meta property="og:description" content="目录
生产者的分区写入策略
轮询策略
随机策略
按key分配策略
乱序分区
自定义分区策略
实现步骤：
消费者组Rebalance机制
Rebalance触发时机
Rebalance的不良影响
消费者分区分配策略
Range范围分配策略
RoundRobin轮询策略
Stricky粘性分配策略
生产者的分区写入策略 轮询策略随机策略按key写入策略自定义分区策略 轮询策略 默认的策略，也是使用最多的策略，可以最大限度保证所有的消息平均分配到每一个分区。
如果在生产消息的时候，key为null,则使用轮询算法均衡的分配分区。
随机策略 随机策略，就是随机的将每条消息随机的分配到每个分区。
按key分配策略 按key分配策略，有可能会出现数据倾斜，例如：某个key包含了大量的数据，因为key的值所有的数据都分配到了一个分区，造成分区的消息数量远远大于其他分区。
乱序分区 轮询和随机策略都会导致一个问题，就是生产到kafka的数据都是乱序存储的，而按照key存储的也是一定程度上的有序，也是局部有序，但又有可能导致数据倾斜，所以要结合实际情况取舍。
在Kafka中生产者是有写入策略，如果topic有多个分区，就会将数据分散在不同的partition中存储
当partition数量大于1的时候，数据（消息）会打散分布在不同的partition中
如果只有一个分区，消息是有序的
自定义分区策略 实现步骤： 1.自定义分区器
public class KeyWithRandomPartitioner implements Partitioner { private Random r; @Override public void configure(Map&lt;String, ?&gt; configs) { r = new Random(); } @Override public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) { // cluster.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-07T17:02:00+08:00">
    <meta property="article:modified_time" content="2024-06-07T17:02:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kafka的分区副本机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84%E5%88%86%E5%8C%BA%E5%86%99%E5%85%A5%E7%AD%96%E7%95%A5-toc" style="margin-left:40px;"><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84%E5%88%86%E5%8C%BA%E5%86%99%E5%85%A5%E7%AD%96%E7%95%A5" rel="nofollow">生产者的分区写入策略</a></p> 
<p id="%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5" rel="nofollow">轮询策略</a></p> 
<p id="%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5" rel="nofollow">随机策略</a></p> 
<p id="%E6%8C%89key%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%E6%8C%89key%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5" rel="nofollow">按key分配策略</a></p> 
<p id="%E4%B9%B1%E5%BA%8F%E5%88%86%E5%8C%BA-toc" style="margin-left:80px;"><a href="#%E4%B9%B1%E5%BA%8F%E5%88%86%E5%8C%BA" rel="nofollow">乱序分区</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5" rel="nofollow">自定义分区策略</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A" rel="nofollow">实现步骤：</a></p> 
<p id="%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84Rebalance%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84Rebalance%E6%9C%BA%E5%88%B6" rel="nofollow">消费者组Rebalance机制</a></p> 
<p id="Rebalance%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA-toc" style="margin-left:120px;"><a href="#Rebalance%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA" rel="nofollow">Rebalance触发时机</a></p> 
<p id="Rebalance%E7%9A%84%E4%B8%8D%E8%89%AF%E5%BD%B1%E5%93%8D-toc" style="margin-left:120px;"><a href="#Rebalance%E7%9A%84%E4%B8%8D%E8%89%AF%E5%BD%B1%E5%93%8D" rel="nofollow">Rebalance的不良影响</a></p> 
<p id="%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-toc" style="margin-left:40px;"><a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5" rel="nofollow">消费者分区分配策略</a></p> 
<p id="Range%E8%8C%83%E5%9B%B4%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-toc" style="margin-left:120px;"><a href="#Range%E8%8C%83%E5%9B%B4%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5" rel="nofollow">Range范围分配策略</a></p> 
<p id="RoundRobin%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5-toc" style="margin-left:120px;"><a href="#RoundRobin%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5" rel="nofollow">RoundRobin轮询策略</a></p> 
<p id="Stricky%E7%B2%98%E6%80%A7%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-toc" style="margin-left:120px;"><a href="#Stricky%E7%B2%98%E6%80%A7%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5" rel="nofollow">Stricky粘性分配策略</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84%E5%88%86%E5%8C%BA%E5%86%99%E5%85%A5%E7%AD%96%E7%95%A5">生产者的分区写入策略</h3> 
<ul><li>轮询策略</li><li>随机策略</li><li>按key写入策略</li><li>自定义分区策略</li></ul> 
<h4 id="%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5">轮询策略</h4> 
<p><img alt="" height="252" src="https://images2.imgbox.com/cf/35/JaSdW6k7_o.png" width="388"></p> 
<p>默认的策略，也是使用最多的策略，可以最大限度保证所有的消息平均分配到每一个分区。</p> 
<p>如果在生产消息的时候，key为null,则使用轮询算法均衡的分配分区。</p> 
<h4 id="%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5">随机策略</h4> 
<p>随机策略，就是随机的将每条消息随机的分配到每个分区。</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/bc/f5/myduGRwK_o.png" width="456"></p> 
<h4 id="%E6%8C%89key%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">按key分配策略</h4> 
<p>按key分配策略，有可能会出现数据倾斜，例如：某个key包含了大量的数据，因为key的值所有的数据都分配到了一个分区，造成分区的消息数量远远大于其他分区。</p> 
<h4 id="%E4%B9%B1%E5%BA%8F%E5%88%86%E5%8C%BA">乱序分区</h4> 
<p>                轮询和随机策略都会导致一个问题，就是生产到kafka的数据都是乱序存储的，而按照key存储的也是一定程度上的有序，也是局部有序，但又有可能导致数据倾斜，所以要结合实际情况取舍。</p> 
<ul><li> <p>在Kafka中生产者是有写入策略，如果topic有多个分区，就会将数据分散在不同的partition中存储</p> </li><li> <p>当partition数量大于1的时候，数据（消息）会打散分布在不同的partition中</p> </li><li> <p>如果只有一个分区，消息是有序的</p> </li></ul> 
<h4 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5">自定义分区策略</h4> 
<p><img alt="" height="249" src="https://images2.imgbox.com/91/a8/58QC5aHq_o.png" width="369"></p> 
<h5 id="%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A">实现步骤：</h5> 
<p>1.自定义分区器</p> 
<pre><code class="language-java">public class KeyWithRandomPartitioner implements Partitioner {

    private Random r;

    @Override
    public void configure(Map&lt;String, ?&gt; configs) {
        r = new Random();
    }

    @Override
    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {
        // cluster.partitionCountForTopic 表示获取指定topic的分区数量
        return r.nextInt(1000) % cluster.partitionCountForTopic(topic);
    }

    @Override
    public void close() {
    }
}
</code></pre> 
<p>2.在kafka生产者配置中，自定义使用自定义分区器的类名</p> 
<pre><code class="language-java">props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, KeyWithRandomPartitioner.class.getName());</code></pre> 
<p></p> 
<h3 id="%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84Rebalance%E6%9C%BA%E5%88%B6">消费者组Rebalance机制</h3> 
<p>        Kafka的Rebalance称之为再平衡，是kafka确保Consumer group下所有consumer如何达成一致，分配订阅的topic的每个分区的机制。</p> 
<h5 id="Rebalance%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA">Rebalance触发时机</h5> 
<p>1.消费者组中consumer的个数发生变化。</p> 
<p>例如：有新的consumer加入到消费者组，或者是某个consumer停止了。</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/1c/d8/7TqoF8Sy_o.png" width="755"></p> 
<p>2.订阅的topic的个数发生变化</p> 
<p>消费者可以订阅多个主题，假设当前的消费者组订阅了三个主题，但有一个主题突然被删除了，此时也需要发生再均衡。</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/07/d0/RekIyCmQ_o.png" width="687"></p> 
<p>3.订阅的topic分区数发生变化</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/77/61/hWm9Pq2N_o.png" width="806"></p> 
<h5 id="Rebalance%E7%9A%84%E4%B8%8D%E8%89%AF%E5%BD%B1%E5%93%8D" style="background-color:transparent;"><br> Rebalance的不良影响</h5> 
<ol><li>发生Rebalance时，consumer group下的所有consumer都会协调在一起共同参与，Kafka使用分配策略尽可能达到最公平的分配</li><li>Rebalance过程会对consumer group产生非常严重的影响，Rebalance的过程中所有的消费者都将停止工作，直到Rebalance完成</li></ol> 
<p></p> 
<h3 id="%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">消费者分区分配策略</h3> 
<h3></h3> 
<h5 id="Range%E8%8C%83%E5%9B%B4%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">Range范围分配策略</h5> 
<p style="margin-left:0;">Range范围分配策略是Kafka默认的分配策略，它可以确保每个消费者消费的分区数量是均衡的。</p> 
<p style="margin-left:0;">注意：Rangle范围分配策略是针对每个Topic的。</p> 
<p style="margin-left:0;"><strong>配置</strong></p> 
<p style="margin-left:0;"><strong>算法公式</strong></p> 
<p style="margin-left:0;">n = 分区数量 / 消费者数量</p> 
<p style="margin-left:0;">m = 分区数量 % 消费者数量</p> 
<p style="margin-left:0;">前m个消费者消费n+1个</p> 
<p style="margin-left:0;">剩余消费者消费n个</p> 
<p style="margin-left:0;"><img alt="" height="392" src="https://images2.imgbox.com/3a/b8/Exhqbv5D_o.png" width="914"></p> 
<p style="margin-left:0;"><img alt="" height="433" src="https://images2.imgbox.com/0b/5d/ZuJqkRaa_o.png" width="863"></p> 
<h5 id="RoundRobin%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5" style="margin-left:0px;">RoundRobin轮询策略</h5> 
<p style="margin-left:0;">RoundRobin轮询策略是将消费者以及消费者的所订阅的所有topic的所有partitions按照字典序排序（topic和分区的hashcode进行排序）。然后通过轮询方式逐个将分区以此分配给每个消费者。</p> 
<p style="margin-left:0;"><strong>配置</strong></p> 
<blockquote> 
 <p style="margin-left:0;">配置消费者的partition.assignment.strategy为org.apache.kafka.clients.consumer.RoundRobinAssignor</p> 
</blockquote> 
<p style="margin-left:0;"><img alt="" height="377" src="https://images2.imgbox.com/90/23/AwXHz4E8_o.png" width="846"></p> 
<h5 id="Stricky%E7%B2%98%E6%80%A7%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5" style="margin-left:0px;">Stricky粘性分配策略</h5> 
<p style="margin-left:0;">从Kafka 0.11x开始，引入此类分配策略，<strong>主要目的：</strong></p> 
<ol><li>分区分配尽可能均匀</li><li>在发生rebalance的时候，分区的分配尽可能与上一次分配保持相同</li></ol> 
<p style="margin-left:0;">没有发生rebalance时，Striky粘性分配策略和RoundRobin分配策略类似。</p> 
<p style="margin-left:0;"><img alt="" height="405" src="https://images2.imgbox.com/f0/cc/tRnsHgUd_o.png" width="873"></p> 
<p style="margin-left:0;">上面如果consumer2崩溃了，此时需要进行rebalance。如果是Range分配和轮询分配都会重新进行分配，例如：<img alt="" height="437" src="https://images2.imgbox.com/cf/95/FaBvOEBt_o.png" width="882"></p> 
<p style="margin-left:0;">通过上图，我们发现，consumer0和consumer1原来消费的分区大多发生了改变。接下来我们再来看下粘性分配策略。</p> 
<p style="margin-left:0;"><img alt="" height="443" src="https://images2.imgbox.com/9e/53/lCOe6n3G_o.png" width="903"></p> 
<p style="margin-left:0;">        我们发现，Striky粘性分配策略，保留rebalance之前的分配结果。这样，只是将原先consumer2负责的两个分区再均匀分配给consumer0、consumer1。这样可以明显减少系统资源的浪费，例如：之前consumer0、consumer1之前正在消费某几个分区，但由于rebalance发生，导致consumer0、consumer1需要重新消费之前正在处理的分区，导致不必要的系统开销。（例如：某个事务正在进行就必须要取消了）        </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ec2e0a130e78fca1a59cb4fc6326ae9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue3 &#43; TS &#43; Antd &#43; Pinia 从零搭建后台系统(二) Ajax &#43; Router</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4fc70240d26f531fe1025886b288968b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用CSS自定义浏览器滚动条 (webkit 已最新支持 scrollbar-width)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>