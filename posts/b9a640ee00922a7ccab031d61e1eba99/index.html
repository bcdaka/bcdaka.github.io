<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端进阶｜详细讲讲函数柯里化 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b9a640ee00922a7ccab031d61e1eba99/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端进阶｜详细讲讲函数柯里化">
  <meta property="og:description" content="前言： 柯里化(Currying)和反柯里化(Uncurrying)在JavaScript中总感觉属于一种不温不火的存在，甚至有些开发者在提起柯里化和反柯里化时，竟然会有点生疏不懂。其实不然，对于它们的概念可能在日常开发中不太提到，但是它们的思想和用法，却在前端开发中经常借鉴和使用，它可以帮助我们写出更加优雅、灵活的代码。本文会首先介绍柯里化的概念、实现原理和应用场景，欢迎收藏&#43;关注哦 💕 🌈🌈文章目录
前言：
一、什么是柯里化
二、实现原理
三、应用场景
计算器函数
校验函数
组合函数
四、柯里化的优缺点 优点：
缺点： 举例演示：
五、总结 一、什么是柯里化 JavaScript函数柯里化是一种将使用多个参数的函数转换为一系列使用一个参数的函数的技术。该技术的名称来自于数学家Haskell Curry。柯里化的主要思想是通过传递函数的一部分参数来创建一个新的函数，该函数接受剩余的参数，并返回结果。
通过柯里化，我们可以将一个接受多个参数的函数转换为一个接受一个参数的函数序列。这意味着我们可以先传递一部分参数，然后传递剩余的参数，或者分别传递参数，以此灵活地处理函数的调用。 例如，下面是一个接受两个参数的普通函数：
function add(x, y) { return x &#43; y; } 通过柯里化，我们可以将上述函数转换为一系列多个函数的调用：
function add(x) { return function(y) { return x &#43; y; } } 这样，我们可以按照以下方式调用柯里化后的函数：
let add5 = add(5); add5(3); // 返回 8 通过柯里化，我们可以轻松地创建具有更高可复用性和灵活性的函数。它在函数式编程中经常被使用，并且可以用于创建高阶函数和函数组合。
二、实现原理 函数柯里化的实现原理是利用闭包和递归。
具体步骤如下：
创建一个高阶函数，用于接受原函数的参数，并返回一个新函数。在新函数内部，使用闭包来保存已经传入的参数。在新函数内部，使用递归或者循环，判断是否所有参数都已经传入。若是，则执行原函数，并返回结果；若否，则继续返回新函数，接受下一个参数。 通过这样的方式，就可以实现柯里化函数。
以下是一个简单的示例代码展示柯里化的实现：
function curry(fn) { return function curried(...args) { if (args.length &gt;= fn.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T10:48:28+08:00">
    <meta property="article:modified_time" content="2024-07-17T10:48:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端进阶｜详细讲讲函数柯里化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="%C2%A0%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h3> 
<blockquote> 
 <p id="2mlnl"><strong>柯里化</strong>(<code>Currying</code>)和<strong>反柯里化</strong>(<code>Uncurrying</code>)在<code>JavaScript</code>中总感觉属于一种不温不火的存在，甚至有些开发者在提起柯里化和反柯里化时，竟然会有点<strong>生疏</strong>不懂。其实不然，对于它们的概念可能在日常开发中不太提到，但是它们的思想和用法，却在前端开发中经常借鉴和使用，它可以帮助我们写出更加优雅、灵活的代码。本文会首先介绍<strong>柯里化的概念</strong>、<strong>实现原理</strong>和<strong>应用场景</strong>，<strong>欢迎收藏+关注哦 💕</strong> </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/05/47/FkcFx250_o.jpg"></p> 
<p id="main-toc">🌈🌈<strong>文章目录</strong></p> 
<p id="%C2%A0%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%AF%E9%87%8C%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%AF%E9%87%8C%E5%8C%96" rel="nofollow">一、什么是柯里化</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">二、实现原理</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">三、应用场景</a></p> 
<p id="%E8%AE%A1%E7%AE%97%E5%99%A8%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E8%AE%A1%E7%AE%97%E5%99%A8%E5%87%BD%E6%95%B0" rel="nofollow">计算器函数</a></p> 
<p id="%C2%A0%E6%A0%A1%E9%AA%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%A0%A1%E9%AA%8C%E5%87%BD%E6%95%B0" rel="nofollow"> 校验函数</a></p> 
<p id="%C2%A0%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0" rel="nofollow"> 组合函数</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%C2%A0" rel="nofollow">四、柯里化的优缺点 </a></p> 
<p id="%E4%BC%98%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E7%82%B9%EF%BC%9A" rel="nofollow">优点：</a></p> 
<p id="%E7%BC%BA%E7%82%B9%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%BC%BA%E7%82%B9%EF%BC%9A%C2%A0" rel="nofollow">缺点： </a></p> 
<p id="%E4%B8%BE%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%BE%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">举例演示：</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93%C2%A0" rel="nofollow">五、总结 </a></p> 
<p style="text-align:center;"><br><img alt="" src="https://images2.imgbox.com/be/af/QRv1U0Ll_o.gif"></p> 
<h3 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%AF%E9%87%8C%E5%8C%96">一、什么是柯里化</h3> 
<blockquote> 
 <p><code>JavaScript</code>函数柯里化是一种将使用多个参数的函数转换为<span style="color:#ff9900;"><strong>一系列使用一个参数的函数</strong></span>的技术。该技术的名称来自于数学家<code>Haskell Curry</code>。柯里化的主要思想是<span style="color:#ff9900;"><strong>通过传递函数的一部分参数来创建一个新的函数，该函数接受剩余的参数，并返回结果</strong></span>。</p> 
</blockquote> 
<blockquote> 
 <p>通过柯里化，我们可以将一个接受多个参数的函数转换为一个接受一个参数的函数序列。这意味着我们可以先传递一部分参数，然后传递剩余的参数，或者分别传递参数，以此灵活地处理函数的调用。 </p> 
</blockquote> 
<p>例如，下面是一个接受两个参数的普通函数：</p> 
<pre><code class="language-javascript">function add(x, y) {
  return x + y;
}</code></pre> 
<p><strong>通过柯里化，我们可以将上述函数转换为一系列多个函数的调用：</strong></p> 
<pre><code class="language-javascript">function add(x) {
  return function(y) {
    return x + y;
  }
}</code></pre> 
<p>这样，我们可以按照以下方式调用柯里化后的函数：</p> 
<pre><code class="language-javascript">let add5 = add(5);
add5(3); // 返回 8</code></pre> 
<blockquote> 
 <p>通过柯里化，我们可以轻松地创建具有更高<strong>可复用性</strong>和<strong>灵活性</strong>的函数。它在函数式编程中经常被使用，并且可以用于创建<strong>高阶函数</strong>和函数组合。</p> 
</blockquote> 
<h3 id="%C2%A0%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">二、实现原理</h3> 
<p>函数柯里化的实现原理是利用<span style="color:#ff9900;"><strong>闭包</strong></span>和<span style="color:#ff9900;"><strong>递归</strong></span>。</p> 
<p>具体步骤如下：</p> 
<blockquote> 
 <ul><li>创建一个<strong>高阶函数</strong>，用于接受原函数的参数，并返回一个新函数。</li><li>在新函数内部，使用<strong>闭包</strong>来保存已经传入的参数。</li><li>在新函数内部，使用<strong>递归</strong>或者<strong>循环</strong>，判断是否所有参数都已经传入。若是，则执行原函数，并返回结果；若否，则继续返回新函数，接受下一个参数。</li></ul> 
</blockquote> 
<p>通过这样的方式，就可以实现柯里化函数。</p> 
<p>以下是一个简单的示例代码展示柯里化的实现：</p> 
<pre><code class="language-javascript">function curry(fn) {
  return function curried(...args) {
    if (args.length &gt;= fn.length) {
      return fn.apply(this, args);
    } else {
      return function (...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

// 原函数
function add(x, y, z) {
  return x + y + z;
}

// 柯里化后的函数
const curriedAdd = curry(add);

// 柯里化函数的调用
curriedAdd(1)(2)(3); // 返回 6

// 也可以一次传入多个参数
curriedAdd(1, 2)(3); // 返回 6</code></pre> 
<blockquote> 
 <p>在上述代码中，<span style="color:#494949;"><code><span style="background-color:#ffd900;">curry</span></code><span style="background-color:#ffd900;"> </span></span>函数是一个高阶函数，用于接受原函数并返回柯里化后的函数。<code><span style="background-color:#ffd900;">curried</span></code><span style="background-color:#ffd900;"> </span>函数是柯里化后的函数，在每次调用时判断传入的参数数量是否满足执行原函数的条件。</p> 
</blockquote> 
<blockquote> 
 <p>通过递归调用，每次返回一个新的函数，直到传入的参数数量满足原函数的要求，然后执行原函数并返回结果。这样就实现了函数的柯里化。</p> 
</blockquote> 
<h3 id="%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">三、应用场景</h3> 
<p>下面是几个常见的例子：</p> 
<h4 id="%E8%AE%A1%E7%AE%97%E5%99%A8%E5%87%BD%E6%95%B0">计算器函数</h4> 
<blockquote> 
 <p>假设我们有一个计算器函数，用于执行简单的数学运算，例如加法、乘法等。我们可以通过柯里化的方式创建一个特定的计算器函数，只执行特定的运算。比如，我们可以创建一个柯里化的加法函数，它接收一个初始值，并返回一个新的函数，用于执行加法运算。</p> 
</blockquote> 
<pre><code class="language-javascript">function add(x) {
  return function (y) {
    return x + y;
  };
}

const addTen = add(10);
console.log(addTen(5)); // 输出 15
console.log(addTen(10)); // 输出 20</code></pre> 
<h4 id="%C2%A0%E6%A0%A1%E9%AA%8C%E5%87%BD%E6%95%B0"> 校验函数</h4> 
<blockquote> 
 <p>柯里化函数在校验数据时也非常有用。比如，我们可以创建一个柯里化的校验函数，它接收一个校验规则和待校验的数据，并返回一个新的函数。这个新函数可以在不同的场景中使用，并根据校验规则对待校验数据进行验证。</p> 
</blockquote> 
<pre><code class="language-javascript">function validate(rule) {
  return function (data) {
    // 执行校验规则并返回结果
    // ...
  };
}

const validateEmail = validate("email");
console.log(validateEmail("example@example.com")); // 输出 true

const validateNumber = validate("number");
console.log(validateNumber("10")); // 输出 false</code></pre> 
<h4 id="%C2%A0%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0"> 组合函数</h4> 
<blockquote> 
 <p>函数组合是函数式编程中的一个重要概念。柯里化函数可以帮助我们实现函数的组合。比如，我们有两个函数 <code><span style="background-color:#ffd900;">g</span></code><span style="background-color:#ffd900;"> </span>和<span style="background-color:#ffd900;"> </span><code><span style="background-color:#ffd900;">f</span></code>，我们可以使用柯里化函数将它们组合在一起，创建一个新的函数<span style="background-color:#ffd900;"> </span><code><span style="background-color:#ffd900;">h</span></code>，执行<span style="background-color:#ffd900;"> </span><code><span style="background-color:#ffd900;">g</span></code><span style="background-color:#ffd900;"> </span>的结果作为<span style="background-color:#ffd900;"> </span><code><span style="background-color:#ffd900;">f</span></code><span style="background-color:#ffd900;"> </span>的输入。</p> 
</blockquote> 
<pre><code class="language-javascript">function addTwo(x) {
  return x + 2;
}

function multiplyByThree(x) {
  return x * 3;
}

const compose = (f, g) =&gt; (x) =&gt; f(g(x));

const addTwoAndMultiplyByThree = compose(multiplyByThree, addTwo);
console.log(addTwoAndMultiplyByThree(4)); // 输出 18</code></pre> 
<blockquote> 
 <p>这些只是函数柯里化的一些应用场景示例，实际上，函数柯里化可以在很多场景中发挥作用，特别是在函数式编程中。它可以简化代码、提高代码的可读性和可重用性，同时也提供了更大的灵活性和抽象能力。</p> 
</blockquote> 
<h3 id="%E5%9B%9B%E3%80%81%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%C2%A0">四、柯里化的优缺点 </h3> 
<h4 id="%E4%BC%98%E7%82%B9%EF%BC%9A">优点：</h4> 
<blockquote> 
 <ol><li><strong>提高函数复用性</strong>：通过柯里化，我们可以创建更加通用的函数，可以根据需要传递不同的参数，从而实现更好的复用性。</li><li><strong>延迟执行</strong>：柯里化可以延迟函数的执行，通过传递部分参数，我们可以预先设置一些参数，并在需要的时候再传递剩余的参数。这种灵活性可以帮助我们管理代码的执行顺序和逻辑。</li><li><strong>部分参数应用</strong>：柯里化可以让我们先传递一部分参数，得到一个新的函数，然后可以用于不同场景的调用。这样就可以通过共享一部分参数来减少重复代码。</li></ol> 
</blockquote> 
<h4 id="%E7%BC%BA%E7%82%B9%EF%BC%9A%C2%A0">缺点： </h4> 
<blockquote> 
 <ol><li><strong>难以理解和维护</strong>：柯里化使得函数变得更加复杂，可能会增加代码的复杂性和难以理解。特别是当多次嵌套柯里化函数时，代码可读性会降低，对于维护和调试可能带来困难。</li><li><strong>性能影响</strong>：由于柯里化会生成多个函数闭包，可能会导致一些性能消耗。每次柯里化都会创建一个新的函数，这可能会增加函数对象的内存开销。</li></ol> 
</blockquote> 
<h4 id="%E4%B8%BE%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A">举例演示：</h4> 
<p>用一个简单的例子来说明柯里化的优点和缺点： </p> 
<pre><code class="language-javascript">function add(x, y, z) {
  return x + y + z;
}

// 柯里化前的调用
add(1, 2, 3); // 返回 6

// 柯里化后的调用
function curriedAdd(x) {
  return function(y) {
    return function(z) {
      return x + y + z;
    }
  }
let addCurried = curriedAdd();
let addCurried2 = addCurried(2);
addCurried2(3); // 返回 6</code></pre> 
<p>在这个例子中，柯里化后的函数可以根据需要逐步传递参数，实现部分参数的应用，从而提高了函数的复用性。但同时，柯里化也使代码变得更加复杂，特别是在需要传递多个参数的情况下。</p> 
<h3 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93%C2%A0">五、总结 </h3> 
<blockquote> 
 <p>在本篇文章中，我们深入探讨了JavaScript函数柯里化的实现原理和应用场景。函数柯里化是一种将多个参数的函数转化为接收一个参数的函数序列的技术，通过这种方式，我们可以实现更加灵活和高复用性的函数。</p> 
</blockquote> 
<blockquote> 
 <p>我们实践了几种常见的实现函数柯里化的方法，通过学习这些方法，我们可以将函数柯里化应用于日常开发中，从而提高代码的可维护性和可扩展性。无论是在函数式编程还是在其他编程范式中，函数柯里化都是一个强大的工具。 </p> 
</blockquote> 
<blockquote> 
 <p>总而言之，函数柯里化在前端开发中对<strong>参数传递灵活性</strong>、<strong>简化复杂函数</strong>、<strong>提高代码复用性</strong>、<strong>构建可组合函数</strong>以及<strong>实现延迟执行</strong>和<strong>懒加载</strong>等方面起到了积极的作用，提升了前端开发的效率和代码质量。但同时柯里化有时候也使代码变得更加<strong>复杂</strong>，特别是在需要传递多个参数的情况下，因此面对柯里化，我们应具体问题具体分析，适时适度的选择使用它。 </p> 
</blockquote> 
<p>希望通过这篇文章，我们都能够理解函数柯里化的概念，并且能够熟练地使用它来编写更加优雅和高效的JavaScript代码。通过函数柯里化，我们可以将复杂的问题分解为简单的函数组合，使代码更易于理解和维护。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b5/e0/YmtfihnD_o.gif"> </p> 
<blockquote> 
 <p>🚀 个人简介：7年开发经验，信息系统项目管理师、CSDN优质创作者、阿里云专家博主，华为云云享专家，分享前端后端相关技术与工作常见问题~</p> 
 <p>💟 作    者：码喽的自我修养❣️<br> 📝 专    栏：<a href="https://blog.csdn.net/2301_78542842/category_12657025.html" title="javascript深入研究">javascript深入研究</a><br> 🌈 若有帮助，还请<span style="color:#333333;"><strong><span style="background-color:#ffd900;"> </span><em><span style="background-color:#ffd900;">关注➕点赞➕收藏  </span></em></strong></span>，不行的话我再努努力💪💪💪 </p> 
</blockquote> 
<blockquote> 
 <p> 更多专栏订阅推荐：</p> 
 <p>👍 <a href="http://t.csdnimg.cn/4Cw5v" rel="nofollow" title="前端工程搭建">前端工程搭建</a><br> 💕 <a href="https://blog.csdn.net/2301_78542842/category_12662200.html?spm=1001.2014.3001.5482" title="vue从基础到起飞">vue从基础到起飞</a></p> 
 <p>✈️ <a href="https://blog.csdn.net/2301_78542842/category_12727467.html" title="HTML5与CSS3">HTML5与CSS3</a></p> 
 <p>⭐️ <a href="https://blog.csdn.net/2301_78542842/category_12711819.html" title="uniapp与微信小程序">uniapp与微信小程序</a></p> 
 <p>📝 <a href="https://blog.csdn.net/2301_78542842/category_12665119.html?spm=1001.2014.3001.5482" title="前端工作常见问题汇总">前端工作常见问题汇总</a></p> 
 <p>✍️ <a href="https://blog.csdn.net/2301_78542842/category_12696325.html?spm=1001.2014.3001.5482" title="GIS地图与大数据可视化">GIS地图与大数据可视化</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/928e07a767b968dbbd6eec8d740a8d76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">运动控制：步进电机同步带传动距离计算</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a34710378bb5954dd1a94a3ce4d60b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据仓库的一致性维度</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>