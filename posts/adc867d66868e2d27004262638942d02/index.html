<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法】Cordic算法的原理及matlab/verilog应用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/adc867d66868e2d27004262638942d02/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法】Cordic算法的原理及matlab/verilog应用">
  <meta property="og:description" content="一、前言 单片机或者FPGA等计算能力弱的嵌入式设备进行加减运算还是容易实现，但是想要计算三角函数（sin、cos、tan），甚至双曲线、指数、对数这样复杂的函数，那就需要费些力了。通常这些函数的计算需要通者查找表或近似计算（如泰勒级数逼近）等技术来转换为硬件易于实现的方式。
CORDIC(Coordinate Rotation Digital Computer, 坐标旋转数字计算方法)算法就是一种化繁为简的算法，通过基本的加减和移位运算代替乘法运算，逐渐逼近目标值，得出函数的数值解。
二、Cordic算法理论推导 理论推导参考：CORDIC算法理论详解_cordic算法详解-CSDN博客，这篇博客的推导仔细而全面。
Cordic算法的基石在于一个规律：从tan45°开始，角度每减半，tan值也接近减半。这一规律直接将三角函数运算变成2的幂运算，而这在数字电路中可直接用移位运算来实现。
三、Cordic算法 matlab实现 由于Cordic旋转角度有限（-99.88°，99.88°），因此对于在第二三象限的目标角度，需要做预处理。一般常用的两种方式：1，第二象限逆时针旋转90°到第一象限，第三象限顺时针旋转90°到第四象限，然后按cordic算法参与计算；2，第二象限顺时针旋转180°到第四象限，第三象限顺时针旋转180°到第一象限，然后按cordic算法参与计算。后面分别用这两种方法进行了matlab实现。
3.1 已知相位（角度）求坐标（正弦余弦） function [sin_theta,cos_theta] = cordic_sincos(theta,n) % n:iterations % theta: -180~180 tan_table = 2.^-(0 : n-1); angle_rad_lut = atan(tan_table); %angle_deg_lut = rad2deg( atan(tan_table) ); k = 1; for i = 0 : n-1 k = k*(1/sqrt(1 &#43; 2^(-2*i))); end x = k; y = 0; theta_tar = theta*pi/180; % to be rad z=theta_tar; % preprocess if (theta_tar &gt; pi/2) theta_tar = theta_tar - pi; sign_x = -1; sign_y = -1; elseif (theta_tar &lt; -pi/2) theta_tar = theta_tar &#43; pi; sign_x = -1; sign_y = -1; else sign_x = 1; sign_y = 1; end for i = 0 : n-1 if (z &gt; 0) d =1; else d=-1; end x_temp = x; y_temp =y; z_temp = z; x= x_temp - d*y_temp*2^(-i); y = y_temp &#43; d*x_temp*2^(-i); z = z_temp - d*angle_rad_lut(i&#43;1); end sin_theta = sign_y*y; cos_theta = sign_x*x; end 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-06T07:54:24+08:00">
    <meta property="article:modified_time" content="2024-06-06T07:54:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法】Cordic算法的原理及matlab/verilog应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、前言</h2> 
<p>单片机或者FPGA等计算能力弱的嵌入式设备进行加减运算还是容易实现，但是想要计算三角函数（sin、cos、tan），甚至双曲线、指数、对数这样复杂的函数，那就需要费些力了。通常这些函数的计算需要通者查找表或近似计算（如泰勒级数逼近）等技术来转换为硬件易于实现的方式。</p> 
<p>CORDIC(Coordinate Rotation Digital Computer, 坐标旋转数字计算方法)算法就是一种化繁为简的算法，通过基本的加减和移位运算代替乘法运算，逐渐逼近目标值，得出函数的数值解。</p> 
<h2>二、Cordic算法理论推导</h2> 
<p>理论推导参考：<a href="https://blog.csdn.net/yindq1220/article/details/127164087?spm=1001.2014.3001.5506" title="CORDIC算法理论详解_cordic算法详解-CSDN博客">CORDIC算法理论详解_cordic算法详解-CSDN博客</a>，这篇博客的推导仔细而全面。</p> 
<p>Cordic算法的基石在于一个规律：从tan45°开始，角度每减半，tan值也接近减半。这一规律直接将三角函数运算变成2的幂运算，而这在数字电路中可直接用移位运算来实现。</p> 
<h2>三、Cordic算法 matlab实现</h2> 
<p>由于Cordic旋转角度有限（-99.88°，99.88°），因此对于在第二三象限的目标角度，需要做预处理。一般常用的两种方式：1，第二象限逆时针旋转90°到第一象限，第三象限顺时针旋转90°到第四象限，然后按cordic算法参与计算；2，第二象限顺时针旋转180°到第四象限，第三象限顺时针旋转180°到第一象限，然后按cordic算法参与计算。后面分别用这两种方法进行了matlab实现。</p> 
<h4>3.1 已知相位（角度）求坐标（正弦余弦）</h4> 
<pre><code class="language-Matlab">function [sin_theta,cos_theta] = cordic_sincos(theta,n)
% n:iterations
% theta: -180~180
tan_table = 2.^-(0 : n-1);
angle_rad_lut = atan(tan_table);
%angle_deg_lut = rad2deg( atan(tan_table) );
 
k = 1;
for i = 0 : n-1
    k = k*(1/sqrt(1 + 2^(-2*i)));
end
 

x = k;
y = 0;
theta_tar = theta*pi/180;  % to be rad
z=theta_tar;
 
% preprocess
if (theta_tar &gt; pi/2)  
    theta_tar = theta_tar - pi;
    sign_x = -1;
    sign_y = -1;
elseif (theta_tar &lt; -pi/2)
    theta_tar = theta_tar + pi;
    sign_x = -1;
    sign_y = -1;
else
    sign_x = 1;
    sign_y = 1;
end
     
 for i = 0 : n-1   
         if (z &gt; 0)  
             d =1;
         else
             d=-1;
         end
        x_temp = x;
        y_temp =y;
        z_temp = z;
        x= x_temp - d*y_temp*2^(-i);
        y = y_temp + d*x_temp*2^(-i);
        z = z_temp - d*angle_rad_lut(i+1);
        
end
    

    sin_theta = sign_y*y;
    cos_theta = sign_x*x;

end</code></pre> 
<h4>3.2 已知坐标求相位</h4> 
<pre><code class="language-Matlab">function [theta] = cordic_sincos(x,y,n)
%function:know coordinate,calculate theta
% n:iterations
% theta: -180~180

tan_table = 2.^-(0 : n-1);
angle_rad_lut = atan(tan_table);
 

z = 0;
 
% preprocess
if (x&lt;0 &amp;&amp; y&gt;0)  
    x_vec = y;
    y_vec = -x;
    theta_shift =-pi/2;
elseif (x&lt;0 &amp;&amp; y&lt;0)
    x_vec = -y;
    y_vec = x;
    theta_shift =pi/2;
else
    x_vec = x;
    y_vec = y;
    theta_shift =0;
end
     
 for i = 0 : n-1   
         if (y_vec &gt; 0)  
             d = -1;
         else
             d=1;
         end
        x_temp = x_vec;
        y_temp =y_vec;
        z_temp = z;
        x_vec= x_temp - d*y_temp*2^(-i);
        y_vec = y_temp + d*x_temp*2^(-i);
        z = z_temp + d*angle_rad_lut(i+1);
        
end
    

    theta = rad2deg(-z - theta_shift);


end</code></pre> 
<h2>四、cordic算法的verilog实现</h2> 
<p>待实现</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe98f5b3e55709f4136981f297125ca8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">湖南（品牌控价）源点调研 手机价格管理对品牌的影响分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ddaa2ae20ed4e3f58c9cfff52b415c28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">植物大战僵尸杂交版2.0.88最新版安装包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>