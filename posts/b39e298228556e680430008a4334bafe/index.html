<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【QT】事件分发器 &amp; 事件过滤器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b39e298228556e680430008a4334bafe/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【QT】事件分发器 & 事件过滤器">
  <meta property="og:description" content="qt 系统 - 事件分发器 and 事件过滤器 一、事件分发器1. 事件分发器概念2. 事件分发器工作原理 二、事件过滤器 一、事件分发器 1. 事件分发器概念 在 Qt 中，事件分发器(Event Dispatcher) 是一个核心概念，用于处理 GUI 应用程序中的事件。事件分发器负责将事件从⼀个对象传递到另⼀个对象，直到事件被处理或被取消。每个继承自 QObject 类或 QObject 类本身都可以在本类中重写 bool event(QEvent *e) 函数，来实现相关事件的捕获和拦截。
2. 事件分发器工作原理 在 Qt 中，我们发送的事件都是传给了 QObject 对象，更具体点是传给了 QObject 对象的 event() 函数。所有的事件都会进入到这个函数里面，那么我们处理事件就要重写这个 event() 函数。event() 函数本⾝不会去处理事件，而是根据 事件类型（type值）调用不同的事件处理函数。事件分发器就是工
作在应用程序向下分发事件的过程中，如下图：
如上图，事件分发器⽤于分发事件。在此过程中，事件分发器也可以做拦截操作。事件分发器主要是通过 bool event(QEvent *e) 函数来实现。其返回值为布尔类型，若为 ture，代表拦截，不向下分发。
Qt 中的事件是封装在 QEvent 类中，在 Qt 助手中输入 QEvent 可以查看其所包括的事件类型，如下图示：
示例代码：
1、在 “widget.h” 头⽂件中声明 ⿏标点击事件 和 事件分发器；如下图⽰：
class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); // 鼠标点击事件 void mousePressEvent(QMouseEvent* event); // 通过事件分发器拦截鼠标按下事件 bool event(QEvent* event); private: Ui::Widget *ui; }; 2、在 “widget.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T14:27:14+08:00">
    <meta property="article:modified_time" content="2024-07-25T14:27:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【QT】事件分发器 &amp; 事件过滤器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>qt 系统 - 事件分发器 and 事件过滤器</h4> 
 <ul><li><a href="#_3" rel="nofollow">一、事件分发器</a></li><li><ul><li><a href="#1__6" rel="nofollow">1. 事件分发器概念</a></li><li><a href="#2__12" rel="nofollow">2. 事件分发器工作原理</a></li></ul> 
  </li><li><a href="#_87" rel="nofollow">二、事件过滤器</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>一、事件分发器</h2> 
<h3><a id="1__6"></a>1. 事件分发器概念</h3> 
<p>在 Qt 中，事件分发器(Event Dispatcher) 是一个核心概念，用于处理 GUI 应用程序中的事件。事件分发器负责将事件从⼀个对象传递到另⼀个对象，直到事件被处理或被取消。每个继承自 <strong>QObject</strong> 类或 <strong>QObject</strong> 类本身都可以在本类中重写 <strong>bool event(QEvent</strong> *<strong>e)</strong> 函数，来实现相关事件的捕获和拦截。</p> 
<h3><a id="2__12"></a>2. 事件分发器工作原理</h3> 
<p>在 Qt 中，我们发送的事件都是传给了 <strong>QObject</strong> 对象，更具体点是传给了 <strong>QObject</strong> 对象的 <strong>event()</strong> 函数。所有的事件都会进入到这个函数里面，那么我们处理事件就要重写这个 <strong>event()</strong> 函数。<strong>event()</strong> 函数本⾝不会去处理事件，而是根据 事件类型（type值）调用不同的事件处理函数。事件分发器就是工<br> 作在应用程序向下分发事件的过程中，如下图：</p> 
<p><img src="https://images2.imgbox.com/1d/93/mO9uIqEY_o.png" alt="在这里插入图片描述"></p> 
<p>如上图，事件分发器⽤于分发事件。在此过程中，事件分发器也可以做拦截操作。事件分发器主要是通过 <strong>bool event(QEvent</strong> *<strong>e)</strong> 函数来实现。其返回值为布尔类型，若为 ture，代表拦截，不向下分发。</p> 
<p>Qt 中的事件是封装在 <strong>QEvent</strong> 类中，在 Qt 助手中输入 <strong>QEvent</strong> 可以查看其所包括的事件类型，如下图示：</p> 
<p><img src="https://images2.imgbox.com/63/53/z5lFcHK3_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/1b/31/QWmpGlah_o.png" alt="在这里插入图片描述"></p> 
<p><strong>示例代码：</strong></p> 
<p>1、在 “widget.h” 头⽂件中声明 ⿏标点击事件 和 事件分发器；如下图⽰：</p> 
<pre><code>			class Widget : public QWidget
			{
			    Q_OBJECT
			
			public:
			    Widget(QWidget *parent = nullptr);
			    ~Widget();
			
			    // 鼠标点击事件
			    void mousePressEvent(QMouseEvent* event);
			
			    // 通过事件分发器拦截鼠标按下事件
			    bool event(QEvent* event);
			
			private:
			    Ui::Widget *ui;
			};
</code></pre> 
<p>2、在 “widget.cpp” ⽂件中实现 ⿏标点击事件 和 拦截事件；</p> 
<pre><code>			#include &lt;QDebug&gt;
			#include &lt;QMouseEvent&gt;
			void Widget::mousePressEvent(QMouseEvent *event)
			{
			    if(event-&gt;button() == Qt::LeftButton) {
			        qDebug() &lt;&lt; "鼠标左键被按下！";
			    }
			}
			
			bool Widget::event(QEvent *event)
			{
			    if(event-&gt;type() == QEvent::MouseButtonPress) {
			        qDebug() &lt;&lt; "Event 中鼠标被按下！";
			        return true; // return true 代表不向下分发
			    }
			    // 其它事件交给父类处理（默认处理）
			    return false;
			}
</code></pre> 
<p>执行效果如下，当鼠标左键点击窗口时，就会执行 <strong>event</strong> 函数，而不会执行 <strong>mousePressEvent</strong> 函数：</p> 
<p><img src="https://images2.imgbox.com/db/cf/JZ2MOjgG_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_87"></a>二、事件过滤器</h2> 
<p>在 Qt 中，⼀个对象可能经常要查看或拦截另外⼀个对象的事件，如对话框想要拦截按键事件，不让别的组件接收到，或者修改按键的默认值等。通过上面的学习，我们已经知道，Qt 创建了 <strong>QEvent</strong> 事件对象之后，会调用 <strong>QObject</strong> 的 <strong>event()</strong> 函数处理事件的分发。显然，我们可以在 <strong>event()</strong> 函数 中实现拦<br> 截的操作。由于 <strong>event()</strong> 函数是 <strong>protected</strong> 的，因此，需要继承已有类。如果组件很多，就需要重写很多个 <strong>event()</strong> 函数。这当然相当麻烦，更不用说重写 <strong>event()</strong> 函数还得小心一堆问题。好在 Qt 提供了另外⼀种机制来达到这一目的：<strong>事件过滤器</strong>。</p> 
<p>事件过滤器是在应用程序分发到 <strong>event</strong> 事件分发器之前，再做⼀次更高级的拦截。如下图示：</p> 
<p><img src="https://images2.imgbox.com/44/ee/5zjl5EkH_o.png" alt="在这里插入图片描述"></p> 
<p>事件过滤器的⼀般使用步骤：</p> 
<ul><li>安装事件过滤器；</li><li>重写事件过滤器函数：<strong>eventfilter()</strong></li></ul> 
<p><strong>代码示例：</strong></p> 
<p>1、设计 UI 文件，拖入一个 label，如下图示；</p> 
<p><img src="https://images2.imgbox.com/2b/e6/mDHhMJJ4_o.png" alt="在这里插入图片描述"></p> 
<p>3、在项目新添加⼀个类：<strong>MyLabel</strong>；</p> 
<p>先选中项目名称 <strong>QEvent_2</strong>，点击⿏标右键，选择 add new … ，弹出如下对话框，选择 Choose 即可：</p> 
<p><img src="https://images2.imgbox.com/9e/e5/l1OhdJjx_o.png" alt="在这里插入图片描述"></p> 
<p>4、选择：Choose … 后，弹出如下界面，按照如下形式创建即可：</p> 
<p><img src="https://images2.imgbox.com/96/9f/dMbBFFUx_o.png" alt="在这里插入图片描述"></p> 
<p>5、此时项目中会新添加我们刚新建的头文件和cpp文件；<br> 6、在 UI 文件中选中 <strong>Label</strong>，右键 ------&gt; 提升为…；当点击 "提升为… " 之后，弹出如下对话框：</p> 
<p><img src="https://images2.imgbox.com/3b/a9/vYrMqKmB_o.png" alt="在这里插入图片描述"></p> 
<p>接下来按照下图选择即可：</p> 
<p><img src="https://images2.imgbox.com/b6/17/PZ5LSui3_o.png" alt="在这里插入图片描述"></p> 
<p>7、在 “mylabel.h” 中声明 ⿏标点击事件 和 事件分发器：</p> 
<pre><code>			#include &lt;QWidget&gt;
			#include &lt;QLabel&gt;
			
			class myLabel : public QLabel
			{
			    Q_OBJECT
			public:
			    explicit myLabel(QWidget *parent = nullptr);
			    
			    // 鼠标点击事件
			    void mousePressEvent(QMouseEvent* event);
			    
			    // 事件分发器
			    bool event(QEvent* e);
			};
</code></pre> 
<p>8、在 “mylabel.cpp” ⽂件中实现⿏标点击事件和事件分发器；</p> 
<pre><code>			#include &lt;QMouseEvent&gt;
			#include &lt;QDebug&gt;
			
			myLabel::myLabel(QWidget *parent) : QLabel(parent)
			{}
			
			void myLabel::mousePressEvent(QMouseEvent *event)
			{
			    QString str = QString("鼠标按下: x = %1, y = %2").arg(event-&gt;x()).arg(event-&gt;y());
			    qDebug() &lt;&lt; str.toUtf8().data();
			}
			
			bool myLabel::event(QEvent *e)
			{
			    // 如果是鼠标按下，在event事件分发时拦截操作
			    if(e-&gt;type() == QEvent::MouseButtonPress) {
			        QMouseEvent* event = static_cast&lt;QMouseEvent*&gt;(e);
			        QString str = QString("Event 函数中鼠标按下: x = %1, y = %2").arg(event-&gt;x()).arg(event-&gt;y());
			        qDebug() &lt;&lt; str.toUtf8().data();
			
			        return true; // 返回true，代表用户自己处理，不向下分发
			    }
			
			    return QLabel::event(e); // 其他事件交给父类处理
			}
</code></pre> 
<p>9、在 “widget.h” 头文件中声明事件过滤器函数；</p> 
<pre><code>			class Widget : public QWidget
			{
			    Q_OBJECT
			
			public:
			    Widget(QWidget *parent = nullptr);
			    ~Widget();
			    
			    // 声明 eventfilter 事件
			    bool eventFilter(QObject* obj, QEvent* e);
			
			private:
			    Ui::Widget *ui;
			};
</code></pre> 
<p>10、在 “widget.cpp” ⽂件中实现事件过滤器的两个步骤；</p> 
<pre><code>			#include &lt;QEvent&gt;
			#include &lt;QMouseEvent&gt;
			#include &lt;QDebug&gt;
			
			Widget::Widget(QWidget *parent)
			    : QWidget(parent)
			    , ui(new Ui::Widget)
			{
			    ui-&gt;setupUi(this);
			    
			    // 1. 给label安装事件过滤器，this：当前窗口安装事件过滤器
			    ui-&gt;label-&gt;installEventFilter(this);
			}
			
			// 2. 重写eventfilter事件
			bool Widget::eventFilter(QObject *obj, QEvent *e)
			{
			    // 判断控件
			    if(obj == ui-&gt;label) {
			        if(e-&gt;type() == QEvent::MouseButtonPress) {
			            QMouseEvent* event = static_cast&lt;QMouseEvent*&gt;(e);
			            QString str = QString("事件过滤器中鼠标按下：x = %1, y = %2").arg(event-&gt;x()).arg(event-&gt;y());
			            qDebug() &lt;&lt; str.toUtf8().data();
			            
			            return true;
			        }
			    }
			    // 其它交给父类处理
			    return QWidget::eventFilter(obj, e);
			}
</code></pre> 
<p>执行效果如下，当在标签中点击鼠标时不会执行 event 函数，而会执行 eventfilter 函数：</p> 
<p><img src="https://images2.imgbox.com/7d/97/6Dm9V6kG_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13db66866b3b7bd79f5bb2121ab599b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">go-kratos 学习笔记(7) 服务发现服务间通信grpc调用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82925323e7cca20f43dafffa11536870/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python-爬虫实例（4）：获取b站的章若楠的视频</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>