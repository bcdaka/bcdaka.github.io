<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;修炼之路之智能指针 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/83f3d6d5b534863a786ef9a73e13150f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c&#43;&#43;修炼之路之智能指针">
  <meta property="og:description" content="目录
一：智能指针的必要性 二：C&#43;&#43;11和boost中智能指针的关系
三：智能指针的使用及原理
1.RAII
2.智能指针的原理
3.底层实现 四：内存泄露 接下来的日子会顺顺利利，万事胜意，生活明朗-----------林辞忧 一：智能指针的必要性 int div() { int a, b; cin &gt;&gt; a &gt;&gt; b; if (b == 0) throw invalid_argument(&#34;除0错误&#34;); return a / b; } void Func() { // 1、如果p1这里new 抛异常会如何？ // 2、如果p2这里new 抛异常会如何？ // 3、如果div调用这里又会抛异常会如何？ int* p1 = new int; int* p2 = new int; cout &lt;&lt; div() &lt;&lt; endl; delete p1; delete p2; } int main() { try { Func(); } catch (exception&amp; e) { cout &lt;&lt; e.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-04T22:33:30+08:00">
    <meta property="article:modified_time" content="2024-09-04T22:33:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;修炼之路之智能指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%B8%80%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%C2%A0" rel="nofollow">一：智能指针的必要性 </a></p> 
<p id="%E4%BA%8C%EF%BC%9AC%2B%2B11%E5%92%8Cboost%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%EF%BC%9AC%2B%2B11%E5%92%8Cboost%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">二：C++11和boost中智能指针的关系</a></p> 
<p id="%E4%B8%89%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%E4%B8%89%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86" rel="nofollow">三：智能指针的使用及原理</a></p> 
<p id="1.RAII-toc" style="margin-left:80px;"><a href="#1.RAII" rel="nofollow">1.RAII</a></p> 
<p id="2.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#2.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">2.智能指针的原理</a></p> 
<p id="3.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:80px;"><a href="#3.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">3.底层实现 </a></p> 
<p id="%E5%9B%9B%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%C2%A0" rel="nofollow">四：内存泄露 </a></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/99/88/NuG2uXoQ_o.png"></p> 
<p>接下来的日子会顺顺利利，万事胜意，生活明朗-----------林辞忧 </p> 
<h3 id="%E4%B8%80%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%C2%A0">一：智能指针的必要性 </h3> 
<pre><code class="language-cpp">int div()
{
	int a, b;
	cin &gt;&gt; a &gt;&gt; b;
	if (b == 0)
		throw invalid_argument("除0错误");
	return a / b;
}
void Func()
{
	// 1、如果p1这里new 抛异常会如何？
	// 2、如果p2这里new 抛异常会如何？
	// 3、如果div调用这里又会抛异常会如何？
	int* p1 = new int;
	int* p2 = new int;
	cout &lt;&lt; div() &lt;&lt; endl;
	delete p1;
	delete p2;
}
int main()
{
	try
	{
		Func();
	}
	catch (exception&amp; e)
	{
		cout &lt;&lt; e.what() &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
<p>这里对于p1这里new抛异常时，会在main函数中捕获到异常进行处理，Func函数后面的代码不再执行，这里还不会出现啥问题的，如果是p2这里new抛异常时，也会在main函数中捕获到异常进行处理，此时后面的代码不再执行，造成p1没有释放，即内存泄露，对于div调用时抛异常，p1和p2都没有释放也造成内存泄露。因此对于抛异常时，对于动态申请的数据是很难做到全部释放，不会内存泄露的，此时就可以使用智能指针来解决上述问题</p> 
<h3 id="%E4%BA%8C%EF%BC%9AC%2B%2B11%E5%92%8Cboost%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB">二：C++11和boost中智能指针的关系</h3> 
<p>1. C++ 98 中产生了第一个智能指针auto_ptr.<br> 2. C++ boost给出了更实用的scoped_ptr和shared_ptr和weak_ptr.<br> 3. C++ TR1，引入了shared_ptr等。不过注意的是TR1并不是标准版。<br> 4. C++ 11，引入了unique_ptr和shared_ptr和weak_ptr。需要注意的是unique_ptr对应boost<br> 的scoped_ptr。并且这些智能指针的实现原理是参考boost中的实现的。</p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/a1/b3/ZY9u9e5f_o.png" width="1200"></p> 
<h3 id="%E4%B8%89%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86">三：智能指针的使用及原理</h3> 
<h4 id="1.RAII">1.RAII</h4> 
<p>RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内<br> 存、文件句柄、网络连接、互斥量等等）的简单技术</p> 
<p><span style="color:#fe2c24;">在对象构造时获取资源</span>，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在<br><span style="color:#fe2c24;">对象析构的时候释放资源</span>。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做<br> 法有两大好处：<br> 不需要显式地释放资源。<br> 采用这种方式，对象所需的资源在其生命期内始终保持有效</p> 
<h4 id="2.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86">2.智能指针的原理</h4> 
<p>1.SmartPtr指针可以解引用，也可以通过-&gt;去访问所指空间中的内容，因此：AutoPtr模板类中还得需要将* 、-&gt;重载下，才可让其像指针一样去使用</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
class SmartPtr
{
public:
	SmartPtr(T*ptr=nullptr)
		:_ptr(ptr)
	{}

	~SmartPtr()
	{
		if(_ptr)
		delete _ptr;
	}

	T&amp; operator*()
	{
		return *(_ptr);
	}

	T* operator-&gt;()
	{
		return _ptr;
	}
private:
	T* _ptr;
};

struct Date
{
	int _year;
	int _month;
	int _day;

	/*Date(int year=1,int month=1,int day=1)
	{}*/
};
int main()
{
	SmartPtr&lt;int&gt; sp1(new int);
	*sp1 = 10;
	cout &lt;&lt; *sp1 &lt;&lt; endl;
	SmartPtr&lt;Date&gt; sparray(new Date);
	// 需要注意的是这里应该是sparray.operator-&gt;()-&gt;_year = 2018;
	// 本来应该是sparray-&gt;-&gt;_year这里语法上为了可读性，省略了一个-&gt;
	sparray-&gt;_year = 2018;
	sparray-&gt;_month = 1;
	sparray-&gt;_day = 1;
}</code></pre> 
<p> 2.使用auto_ptr来管理</p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/65/58/X4tjPoY7_o.png" width="1200"></p> 
<p>这时在拷贝时就会发现程序崩溃的，这是因为<span style="color:#fe2c24;">拷贝时，管理权限转移，被拷贝悬空</span>，ap1指针被置为空，此时在访问就会访问空指针的 </p> 
<p>3.使用unique_ptr来管理</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/73/08/UfvXnofJ_o.png" width="608"></p> 
<p>4.使用shared_ptr来管理</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/d2/c2/ibm4YgVd_o.png" width="706"></p> 
<p> 5.当管理多个对象时</p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/eb/85/PvT86U37_o.png" width="1200"></p> 
<p>这时发现会使程序崩溃，因为底层默认为delete,这时不匹配就会出错，此时就可以使用定制删除器来解决问题</p> 
<p><img alt="" height="72" src="https://images2.imgbox.com/68/c9/NIC9ixCt_o.png" width="821"></p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/ee/9e/xgAXBMzD_o.png" width="1038"></p> 
<p>可以给个可调用对象，如lambda表达式，仿函数，函数指针</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
struct DeleteArray
{
	void operator()(T*ptr)
	{
		delete[] ptr;
	}
};

struct Fclose
{
	void operator()(FILE* file)
	{
		cout &lt;&lt; "fclose:" &lt;&lt; file &lt;&lt; endl;
		fclose(file);
	}
};
int main()
{
	//定制删除器
	
	unique_ptr&lt;Date,DeleteArray&lt;Date&gt;&gt; up1(new Date[5]);
	unique_ptr&lt;FILE,Fclose&gt; up2(fopen("Text.cpp","r"));
	//提供一个特化的版本
	unique_ptr&lt;Date[]&gt; up3(new Date[3]);

	shared_ptr&lt;Date[]&gt; sp1(new Date[2]);
	shared_ptr&lt;FILE&gt;sp2(fopen("Text.cpp","r"),Fclose());
	shared_ptr&lt;Date&gt; sp3 = make_shared&lt;Date&gt;(2024,9,4);

	return 0;
}</code></pre> 
<h4 id="3.%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%C2%A0">3.底层实现 </h4> 
<p>1.auto_ptr关键函数</p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/07/7d/90mflnpG_o.png" width="736"></p> 
<p>2.unique_ptr关键函数</p> 
<p><img alt="" height="87" src="https://images2.imgbox.com/8c/4c/cV6Sn5A6_o.png" width="695"></p> 
<p>3.shared_ptr</p> 
<p>shared_ptr的原理：是通过引用计数的方式来实现多个shared_ptr对象之间共享资源。<br> 1. shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共<br> 享。<br> 2. 在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减1<br> 3. 如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；<br> 4. 如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对<br> 象就成野指针了。<br> 5. 引用计数支持多个拷贝管理同一个资源，最后一个析构对象释放资源 </p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/56/d8/99yRgWB6_o.png" width="1108"></p> 
<pre><code class="language-cpp">#include &lt;functional&gt;
namespace mjw
{
	template&lt;class T&gt;
	class shared_ptr
	{
	public:
		shared_ptr(T* ptr=nullptr)
			:_ptr(ptr)
			,_pcount(new int(1))
		{}

		template&lt;class D&gt;
		shared_ptr(T*ptr,D del)
			:_ptr(ptr)
			,_pcount(new int(1))
			,_del(del)
		{}

		//sp2(sp1)
		shared_ptr(const shared_ptr&lt;T&gt;&amp; sp)
			:_ptr(sp._ptr)
			, _pcount(sp._pcount)
		{
			(*_pcount)++;
		}

		void release()
		{
			if (--(*_pcount) == 0)
			{
				//delete _ptr;
				_del(_ptr);
				delete _pcount;

				_ptr = nullptr;
				_pcount = nullptr;
			}
		}

		//sp1=sp3
		shared_ptr&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
		{
			if (_ptr != sp._ptr)//防止自己给自己赋值
			{
				release();
				_ptr = sp._ptr;
				_pcount = sp._pcount;
				(*_pcount)++;
			}

			return *this;
		}

		~shared_ptr()
		{
			release();
		}
		T* get()
		{
			return _ptr;
		}

		int use_count() const
		{
			return *_pcount;
		}

		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}
	private:
		T* _ptr;
		int* _pcount;
		function&lt;void(T* ptr)&gt; _del = [](T * ptr){delete ptr; };
	};
}</code></pre> 
<p>4.shared_ptr的循环引用</p> 
<pre><code class="language-cpp">struct ListNode
{
	std::shared_ptr&lt;ListNode&gt; _next;
	std::shared_ptr&lt;ListNode&gt; _prev;

	~ListNode()
	{
		cout &lt;&lt; "~ListNode()" &lt;&lt; endl;
	}
};

int main()
{
	// 循环引用 -- 内存泄露
	std::shared_ptr&lt;ListNode&gt; n1(new ListNode);
	std::shared_ptr&lt;ListNode&gt; n2(new ListNode);

	n1-&gt;_next = n2;
	n2-&gt;_prev = n1;

	return 0;
}</code></pre> 
<p><img alt="" height="643" src="https://images2.imgbox.com/92/7c/NruXLWfc_o.png" width="1200"></p> 
<p>此时就需要使用weak_ptr来解决</p> 
<p>// weak_ptr不支持管理资源，不支持RAII<br> //std::weak_ptr&lt;ListNode&gt; wp(new ListNode);</p> 
<pre><code class="language-cpp">struct ListNode
{
	/*std::shared_ptr&lt;ListNode&gt; _next;
	std::shared_ptr&lt;ListNode&gt; _prev;*/

	//不增加引用计数
	std::weak_ptr&lt;ListNode&gt; _next;
	std::weak_ptr&lt;ListNode&gt; _prev;

	~ListNode()
	{
		cout &lt;&lt; "~ListNode()" &lt;&lt; endl;
	}
};</code></pre> 
<p>node1-&gt;_next = node2和node2-&gt;_prev = node1时weak_ptr的_next和_prev不会增加node1和node2的引用计数。 </p> 
<p> 5.weak_ptr的简单实现</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
class weak_ptr
{
public:
	weak_ptr()
	{}

	weak_ptr(const shared_ptr&lt;T&gt;&amp; sp)
		:_ptr(sp.get())
	{}

	weak_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
	{
		_ptr = sp.get();

		return *this;
	}
private:
	T* _ptr=nullptr;
};</code></pre> 
<h3 id="%E5%9B%9B%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%C2%A0">四：内存泄露 </h3> 
<p>什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内<br> 存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对<br> 该段内存的控制，因而造成了内存的浪费。<br> 内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现<br> 内存泄漏会导致响应越来越慢，最终卡死。</p> 
<p>内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄<br> 漏检测工具</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/730bc81d2503610b72e39b6bd8531ed7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python篇】PyQt5 超详细教程——由入门到精通（序篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/87948d2ace3a57000748ba3e68d29655/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">怎么摆脱非自然链接？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>