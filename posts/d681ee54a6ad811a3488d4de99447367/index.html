<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C:每日一练：单身狗（2.0版本） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d681ee54a6ad811a3488d4de99447367/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C:每日一练：单身狗（2.0版本）">
  <meta property="og:description" content="前言： 今天在刷题的时候突然看到一道题，疑似一位故题。仔细一看，欸！这不是就是单身狗的升级版吗？我想那必须再安排一篇，不过由于本篇文章与上一篇单身狗文章所涉及的知识点基本相同，所以还请大家见谅！
我写的开心，大家也看个乐呵！不过还请单身的人不要介意，单纯觉得比较有意思，无意冒犯！毕竟连小编自己都是单身狗。
后续小编也会尽快更新完指针相关知识点！
一、题目： 在一场专为情侣们策划的盛宴中，竟然有两名单身者悄然混入。宴会的主人感到十分不悦，并寻求你的帮助，希望你能运用你敏锐的洞察力，协助她识破并找出这两名不合规矩的单身者。
（无意冒犯，只是提供一个题目的背景）
例如：
有数组的元素是：1，2，3，4，5，6，1，2，3，4，5，7
只有6和7只出现1次，要找出6和7.
二、代码展示（无注释的） 如果有想先自己思考的可以先看一看这个代码，后面也会有解析
#include &lt;stdio.h&gt; int find(int num) { int index = 0; while ((num &amp; 1) == 0 &amp;&amp; index &lt; 32) { num &gt;&gt;= 1; index&#43;&#43;; } return index; } void single(int arr[], int sz, int* n1, int* n2) { int Re = 0; for (int i = 0; i &lt; sz; i&#43;&#43;) { Re ^= arr[i]; } int index = find(Re); *n1 = *n2 = 0; for (int i = 0; i &lt; sz; i&#43;&#43;) { if (((arr[i] &gt;&gt; index) &amp; 1) == 1) *n1 ^= arr[i]; else *n2 ^= arr[i]; } int main() { int arr[] = {1,2,3,4,5,6,1,2,3,4,5,7}; int n1, n2; int sz = sizeof(arr) / sizeof(arr[0]); single(arr, sz, &amp;n1, &amp;n2); printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-22T21:25:24+08:00">
    <meta property="article:modified_time" content="2024-08-22T21:25:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C:每日一练：单身狗（2.0版本）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="5703a68c899f40cd85d54a77087f8f5f.gif" src="https://images2.imgbox.com/8a/9b/lMX942l5_o.gif"></h2> 
<h2>前言：</h2> 
<p>今天在刷题的时候突然看到一道题，疑似一位故题。仔细一看，欸！这不是就是单身狗的升级版吗？我想那必须再安排一篇，不过由于本篇文章与上一篇单身狗文章所涉及的知识点基本相同，所以还请大家见谅！</p> 
<p>我写的开心，大家也看个乐呵！不过还请单身的人不要介意，单纯觉得比较有意思，无意冒犯！毕竟连小编自己都是单身狗。</p> 
<p>后续小编也会尽快更新完指针相关知识点！</p> 
<h2>一、题目：</h2> 
<p>在一场专为<strong>情侣们</strong>策划的盛宴中，竟然有<strong>两名单身者</strong>悄然混入。宴会的主人感到十分不悦，并寻求你的帮助，希望你能运用你敏锐的洞察力，协助她识破并<strong>找出这两名不合规矩的单身者。</strong></p> 
<p>（无意冒犯，只是提供一个题目的背景）</p> 
<p>例如：</p> 
<p>有数组的元素是：1，2，3，4，5，6，1，2，3，4，5，7</p> 
<p>只有6和7只出现1次，要找出6和7.</p> 
<h2>二、代码展示（无注释的）</h2> 
<p>如果有想先自己思考的可以先看一看这个代码，后面也会有解析</p> 
<pre><code>#include &lt;stdio.h&gt;
int find(int num) {
    int index = 0;
    while ((num &amp; 1) == 0 &amp;&amp; index &lt; 32) {
        num &gt;&gt;= 1;
        index++;
    }
    return index;
}
void single(int arr[], int sz, int* n1, int* n2) {
    int Re = 0;
    for (int i = 0; i &lt; sz; i++) {
        Re ^= arr[i];
    }
    int index = find(Re);
    *n1 = *n2 = 0;
    for (int i = 0; i &lt; sz; i++) {
        if (((arr[i] &gt;&gt; index) &amp; 1) == 1) 
            *n1 ^= arr[i];    
        else 
            *n2 ^= arr[i];
  
}
int main() {
    int arr[] = {1,2,3,4,5,6,1,2,3,4,5,7};
    int n1, n2;
    int sz = sizeof(arr) / sizeof(arr[0]);
    single(arr, sz, &amp;n1, &amp;n2);
    printf("两只单身狗分别是：%d 和 %d\n", n1, n2);
    return 0;
}</code></pre> 
<h2>三、题解思路：</h2> 
<blockquote> 
 <p><strong>1.关于算法，我们依然使用的是异或运算，因为异或运算相同为0，所以将数组中所有的数字进行异或操作，最终得到的结果就是那两个只出现一次的数字的异或值。</strong></p> 
 <p>例如：</p> 
 <p>举个例子： int arr[ ] = {1,1,2}</p> 
 <p>初始re = 0；</p> 
 <p>re = re ^ 1 = 1；此时re = 1；</p> 
 <p>re = re ^ 1 = 1 ^ 1 = 0;此时re = 0；</p> 
 <p>re = re ^ 2 = 0 ^ 2 = 2;此时re = 2；所以只出现一次的数字是2</p> 
</blockquote> 
<blockquote> 
 <p><strong>2.找到这个异或结果中为 1 的某一位。根据异或运算不同为1，这一位为 1 说明在这一位上，那两个只出现一次的数字是不同的。</strong></p> 
 <p>例如：数组{1,1,2}<br> 异或运算：1^1^2 = 2;<br> 0010   2的二进制<br>  异或的结果是0010，从右向左找1的位置<br> 0000   0的二进制<br> 0010   2的二进制<br> 0000^0010 = 0010 (异或运算相同为0，不同为1)<br> 我们可以发现0在这一位上的数字是0，2在这一位上的数字是2，说明结果为1的这一位，两个只出现一次的数字是不同的。</p> 
</blockquote> 
<blockquote> 
 <p><strong>3.根据这一位将数组中的数字分为两组。一组是这一位为 1 的数字，另一组是这一位为 0 的数字。</strong></p> 
 <p><strong>再对这两组数字分别进行异或操作，就可以得到那两个只出现一次的数字。</strong></p> 
</blockquote> 
<blockquote> 
 <p>例如，数组为{1,2,3,1,2,4}</p> 
 <p>第一步，将所有数字异或:1 ^ 2 ^ 3 ^ 1 ^ 2 ^ 4=7（二进制为0111 ）</p> 
 <p>第二步，找到异或结果中为 1 的一位，从右往左数第一位为 1 </p> 
 <p>第三步，根据这一位将数字分组：</p> 
 <ul><li>这一位为 1 的数字:{3,4}</li><li>这一位为 0 的数字:{1,2,1,2}</li></ul> 
</blockquote> 
<blockquote> 
 <p>{1，2，3，1，2，4}异或过程</p> 
 <p>1 ^ 2 = 0001^0010 = 0011 = 3；</p> 
 <p>3 ^ 3 = 0011^0011 = 0000 = 0;</p> 
 <p>0 ^ 1 = 0000^0001 = 0001 = 1;</p> 
 <p>1 ^ 2 = 0001^0010 = 0011 = 3;</p> 
 <p>3 ^ 4 = 0011^0100 = 0111 = 7;</p> 
 <p>所以  1 ^ 2 ^ 3 ^ 1 ^ 2 ^ 4 = 7。</p> 
</blockquote> 
<h2>四、函数介绍</h2> 
<p><strong>1.main函数</strong></p> 
<pre><code>int main() 
{
    int arr[] = {1,2,3,4,5,6,1,2,3,4,5,7};
    int n1, n2;
    int sz = sizeof(arr) / sizeof(arr[0]);
    single(arr, sz, &amp;n1, &amp;n2);
    printf("两只单身狗分别是：%d 和 %d\n", n1, n2);
    return 0;
}</code></pre> 
<ul><li><strong> 数组的输入：</strong>int arr[] = {1,2,3,4,5,6,1,2,3,4,5,7};</li><li><strong>数组元素个数计算：</strong> int sz = sizeof(arr) / sizeof(arr[0]);</li><li><strong>调用函数：</strong> single(arr, sz, &amp;n1, &amp;n2);</li></ul> 
<p><strong>2.single函数</strong></p> 
<pre><code>void single(int arr[], int sz, int* n1, int* n2) {
    int Re = 0;
    for (int i = 0; i &lt; sz; i++) {
        Re ^= arr[i];
    }
    int index = find(Re);
    *n1 = *n2 = 0;
    for (int i = 0; i &lt; sz; i++) {
        if (((arr[i] &gt;&gt; index) &amp; 1) == 1) {
            *n1 ^= arr[i];
        }
        else {
            *n2 ^= arr[i];
        }
    }
}</code></pre> 
<p><strong>single函数作用：</strong>找出数组中两个只出现一次的数字</p> 
<p>第一个for循环实现数组中所有元素的异或运算</p> 
<p>第二个for循环用于根据索引值，将数组分为两组并分别进行异或运算</p> 
<p> int index = find(Re);将索引值传给find函数</p> 
<p><strong>3.find函数</strong></p> 
<pre><code>int find(int num) {
    int index = 0;
    while ((num &amp; 1) == 0 &amp;&amp; index &lt; 32) {
        num &gt;&gt;= 1;
        index++;
    }
    return index;
}</code></pre> 
<p><strong> find函数</strong>用于找到一个数的二进制表示中从右往左第一个为 1 的位的索引</p> 
<h2>五：代码展示（含注释）</h2> 
<pre><code>#include &lt;stdio.h&gt;
int find(int num)
    int index = 0;
   
    while ((num &amp; 1) == 0 &amp;&amp; index &lt; 32)  // 当前二进制位为 0 并且索引小于 32
    {
        
        num &gt;&gt;= 1;//实现二进制中每位检查
        index++;
    }
    return index;// 返回第一个结果为 1 的位的索引
}
void single(int arr[], int sz, int* n1, int* n2) 
    int Re = 0;
    // 对数组中所有数字进行异或操作，得到两个只出现一次数字的异或结果
    for (int i = 0; i &lt; sz; i++) 
    {
        Re ^= arr[i];
    }
    int index = find(Re);// 找到上述异或结果中第一个为 1 的位的索引
    *n1 = *n2 = 0;
    // 根据找到的索引位，将数组数字分为两组并分别异或
    for (int i = 0; i &lt; sz; i++) 
    {
        if (((arr[i] &gt;&gt; index) &amp; 1) == 1) // 判断当前数字在指定索引位是否为 1
            *n1 ^= arr[i];   
        else 
            *n2 ^= arr[i];  
    }
}
int main() 
{
    int arr[] = { 1, 2, 3, 2, 1, 4 };
    int n1, n2;
    int sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素
    single(arr, sz, &amp;n1, &amp;n2);//函数调用
    printf("两只单身狗分别是：%d 和 %d\n", n1, n2);
    return 0;
}</code></pre> 
<p> <img alt="d7715019c6ad4dd5ac0c518fc65d2eed.gif" src="https://images2.imgbox.com/d5/8e/tyzKE6Bm_o.gif"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/505b44d54af84112c8bc1c9e578a8c90/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kafka之RecordAccumulator</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6197d85dd1c75857defccb8c8983c900/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">KT来袭，打造沉浸式体验的聚合性web3应用平台</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>