<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【排序算法】—— 归并排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/942a7fd17bd203f2a925cb07bdd16db4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【排序算法】—— 归并排序">
  <meta property="og:description" content="归并排序时间复杂度O(NlongN)，空间复杂度O(N)，是一种稳定的排序，其次可以用来做外排序算法，即对磁盘(文件)上的数据进行排序。
目录
一、有序数组排序
二、排序思路
三、递归实现
四、非递归实现
一、有序数组排序 要理解归并排序的核心逻辑我们得先看懂下面一个题：
刚接触这个题的时候，大家可能会想把他俩写到一个数组里面然后再写一个排序算法，这是一个比较容易想到也是比较蛮力的一种方法，但是这里有一个特点这两个数组是有序的。所以有一个很巧妙的方法。
使用两个变量分别记录他们的下标，并从零下标开始，比较他们下标对应下的值把小的那个先放进去新数组里面，然后把他的下标移到下一位。然后重复进行该操作，直到把其中的一个遍历完。
当然此时还没有完全排完序，当其中一组遍历完后，还有另一组剩余的的元素没有放在新数组内，因为无法确定那一组会先遍历完所以我们俩组都需要检查一遍，检查他们的下标并把剩余元素放在新数组内。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; int main() { int ar1[] = { 1,2,3,4 }; int ar2[] = { 3,4,5,6,7 }; int sz1 = sizeof(ar1)/sizeof(int), sz2 = sizeof(ar2) / sizeof(int); int* arr = (int*)malloc(sizeof(int) * (sz1 &#43; sz2)); assert(arr); int i = 0, j = 0, t = 0; while (i &lt; sz1 &amp;&amp; j &lt; sz2) { if (ar1[i] &lt; ar2[j]) arr[t&#43;&#43;] = ar1[i&#43;&#43;]; else arr[t&#43;&#43;] = ar2[j&#43;&#43;]; } while (i &lt; sz1) arr[t&#43;&#43;] = ar1[i&#43;&#43;]; while (j &lt; sz2) arr[t&#43;&#43;] = ar2[j&#43;&#43;]; for (int i = 0; i &lt; sz1 &#43; sz2; i&#43;&#43;) printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-18T16:52:26+08:00">
    <meta property="article:modified_time" content="2024-07-18T16:52:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【排序算法】—— 归并排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        归并排序时间复杂度O(NlongN)，空间复杂度O(N)，是一种稳定的排序，其次可以用来做<span style="color:#fe2c24;"><strong>外排序算法</strong></span>，即对磁盘(文件)上的数据进行排序。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F" rel="nofollow">一、有序数组排序</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF" rel="nofollow">二、排序思路</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow">三、递归实现</a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow">四、非递归实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">一、有序数组排序</h2> 
<p>要理解归并排序的核心逻辑我们得先看懂下面一个题：</p> 
<p><img alt="" height="232" src="https://images2.imgbox.com/6f/82/v11G8xsA_o.png" width="958"></p> 
<p>         刚接触这个题的时候，大家可能会想把他俩写到一个数组里面然后再写一个<span style="color:#ff9900;"><u>排序算法</u></span>，这是一个比较容易想到也是比较<u>蛮力</u>的一种方法，但是这里有一个特点这两个数组是有序的。所以有一个很巧妙的方法。</p> 
<p>        使用两个变量分别记录他们的下标，并从零下标开始，比较他们下标对应下的值把小的那个先放进去新数组里面，然后把他的下标移到下一位。然后重复进行该操作，直到把其中的一个遍历完。<br>         <u>当然此时还没有完全排完序，当其中一组遍历完后，还有另一组剩余的的元素没有放在新数组内，因为无法确定那一组会先遍历完所以我们俩组都需要检查一遍，检查他们的下标并把剩余元素放在新数组内</u>。</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
int main()
{
	int ar1[] = { 1,2,3,4 };
	int ar2[] = { 3,4,5,6,7 };
	int sz1 = sizeof(ar1)/sizeof(int), sz2 = sizeof(ar2) / sizeof(int);
	int* arr = (int*)malloc(sizeof(int) * (sz1 + sz2));
	assert(arr);
	int i = 0, j = 0, t = 0;
	while (i &lt; sz1 &amp;&amp; j &lt; sz2)
	{
		if (ar1[i] &lt; ar2[j])
			arr[t++] = ar1[i++];
		else
			arr[t++] = ar2[j++];
	}
	while (i &lt; sz1)
		arr[t++] = ar1[i++];
	while (j &lt; sz2)
		arr[t++] = ar2[j++];
	for (int i = 0; i &lt; sz1 + sz2; i++)
		printf("%d ", arr[i]);
	return 0;
}</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF">二、排序思路</h2> 
<p>        通过理解上面那个题，那么对于一个乱序的数组，我们可以把一分为二，先让两个小数组有序然后再用上面的方法合并。那么如何让这两个小数组有序呢，同样的可以把他们分别再拆开，变成四个小组，然后继续一直往下拆，<span style="color:#ff9900;">直到拆到只有一个元素</span>，那么它<span style="color:#ff9900;">必然是有序</span>的，最后进行进行一一合并，这整个的思路有点像<u><strong><span style="color:#fe2c24;">二叉树的后续遍历</span></strong></u>。</p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/66/7e/nxHJKGJ2_o.png" width="1200"></p> 
<p>动图：</p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/7b/d8/H1G2qfRW_o.gif" width="811"></p> 
<h2 id="%E4%B8%89%E3%80%81%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">三、递归实现</h2> 
<p>        在分析的过程中，我们就可以感受到使用递归可以很好的解决这个问题。<u>在做分割的时候，最好是选择从中间位置开始</u>，这样避免的递归深度太深。在处理递归问题的时候还要注意一个点，就是<span style="color:#fe2c24;">递归的结束条件</span>，这里递归什么时候结束呢？通过上面的分析当数组只分割成单个元素的时候它必然是有序的，那么递归结束条件就是当分割的小数组只有一个元素的时候返回。</p> 
<p>代码示例:</p> 
<pre><code class="language-cpp">void _MergeSort(int* arr, int* tmp, int left, int right)
{
	if (left &gt;= right)
		return;
	int key = (left + right) / 2;
	int begin1 = left, end1 = key;
	int begin2 = key + 1, end2 = right;
	_MergeSort(arr, tmp, begin1, end1);
	_MergeSort(arr, tmp, begin2, end2);
	int i = left;
	while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
	{
		if (arr[begin1] &lt; arr[begin2])
			tmp[i++] = arr[begin1++];
		else
			tmp[i++] = arr[begin2++];
	}
	while (begin1 &lt;= end1)
		tmp[i++] = arr[begin1++];
	while (begin2 &lt;= end2)
		tmp[i++] = arr[begin2++];
	memcpy(arr + left, tmp + left, sizeof(int) * (right - left + 1));
}
void MergeSort(int* arr, int size)//归并排序——递归
{
	int* tmp = (int*)malloc(sizeof(int) * size);
	assert(tmp);
	_MergeSort(arr, tmp, 0, size - 1);
	free(tmp);
}</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">四、非递归实现</h2> 
<p>        把递归转为非递归可以防止函数栈针开的太多导致栈溢出。在把递归转为非递归时第一想到的应该是使用栈结构来辅助完成。但是对于这个排序使用栈来实现非递归还是比较复杂，也根本用不着。</p> 
<p>思路：</p> 
<p>        gap：表示分割的每个小数组中储存的元素个数。</p> 
<p>        size：表示整个大数的长度</p> 
<p>        首先我们仿照<span style="color:#ff9900;">广度优先</span>的思想去合并，因为<u><em>刚开始只有单个元素自己作为一个数组(即gap=1)的时候才有序，所以从最后一层开始两两合并成一个</em></u>，那么接下来gap=2的小数组就变得有序，合并完gap=2的的数组后，同理gap=4的小数组变得有序，对它们进行两两合并，直到<span style="color:#fe2c24;"><strong>gap&gt;=size</strong></span>。</p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/6e/7a/fRsmwCz3_o.png" width="1200"></p> 
<p>代码示例: </p> 
<pre><code class="language-cpp">void MergeSortNoF(int* arr, int sz)
{
	int* tmp = (int*)malloc(sizeof(int) * sz);
	assert(tmp);
	int gap = 1;
	while (gap &lt; sz)
	{
		for (int i = 0; i &lt; sz; i += gap * 2)
		{
			int j = i;
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + 2 * gap - 1;
			if (begin2 &gt;= sz)
				break;
			if (end2 &gt;= sz)
				end2 = sz - 1;
			while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
			{
				if (arr[begin1] &lt;= arr[begin2])
					tmp[j++] = arr[begin1++];
				else
					tmp[j++] = arr[begin2++];
			}
			while (begin1 &lt;= end1)
				tmp[j++] = arr[begin1++];
			while (begin2 &lt;= end2)
				tmp[j++] = arr[begin2++];
			memmove(arr + i, tmp + i, sizeof(int) * (end2 - i + 1));
		}
		gap*=2;
	}
}</code></pre> 
<p>细节：</p> 
<p>        无论是递归还是非递归都需要开辟一块空间tmp来储存合并后的元素，最后把tmp上的数据拷贝给原数组，使用memmove函数比较便捷。</p> 
<p>区间越界问题：</p> 
<p>        (1)、[begin1, end1]    [begin2, <span style="color:#fe2c24;">end2</span>] </p> 
<p>        (2)、[begin1, end1]    [<span style="color:#fe2c24;">begin2</span>, <span style="color:#fe2c24;">end2</span>] </p> 
<p>        (3)、[begin1, <span style="color:#fe2c24;">end1</span>]    [<span style="color:#fe2c24;">begin2</span>, <span style="color:#fe2c24;">end2</span>] </p> 
<p>        以上红色表示越界，这是越界可能出现的所有情况，观察发现出现(2)，(3)种情况的时候并不需要做合并，直接break;怎么写条件呢？因为end1越界begin2一定越界，所有用一个if(begin2&gt;=sz)就可以表示(2)，(3)种情况。</p> 
<p>        至于第一种情况，我们还是要合并的但需要调整end2为sz-1，所以有一下代码：</p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/35/58/rjgMAQZH_o.png" width="922"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85010a86f66e29ed5c4c4ed0a5348e11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 8的变革：函数式编程和Lambda表达式探索</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d42274c4dd5b7f6468d602d36bb67eec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于dom4j主节点的xmlns无法写入的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>