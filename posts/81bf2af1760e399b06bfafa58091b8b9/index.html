<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之模板方法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/81bf2af1760e399b06bfafa58091b8b9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="设计模式之模板方法">
  <meta property="og:description" content="在软件开发中，我们经常会遇到一些算法步骤固定但某些步骤需要由子类具体实现的场景。为了避免重复代码并确保逻辑一致性，模板方法模式（Template Method Pattern） 提供了一种优雅的解决方案。本文将详细探讨模板方法模式的定义、应用场景、优点以及如何在实际项目中使用这一模式来编写更加灵活和可维护的代码。
一、模板方法模式概述 模板方法模式是一种行为型设计模式，它允许你在父类中定义一个算法的骨架，并将某些步骤的实现延迟到子类中。这样一来，子类可以重新定义算法的某些步骤，而不会改变算法的整体结构。
1.1 模板方法模式的结构 模板方法模式主要包括以下几个部分：
抽象类（Abstract Class）：定义算法的骨架，并包含一个模板方法（template method）。模板方法定义了算法的步骤，并调用抽象方法来完成这些步骤。具体子类（Concrete Classes）：继承抽象类，实现其未实现的抽象方法，从而完成算法的具体步骤。 下图展示了模板方法模式的典型结构：
┌────────────────────┐ │ AbstractClass │ │────────────────────│ │&#43; templateMethod() │ │────────────────────│ │&#43; primitiveOperation1() │ │&#43; primitiveOperation2() │ └────────────────────┘ ▲ │ ┌────────────────────┐ │ ConcreteClass │ │────────────────────│ │&#43; primitiveOperation1() │ │&#43; primitiveOperation2() │ └────────────────────┘ 1.2 模板方法模式的优点 代码复用：将通用的算法逻辑放在抽象类中，避免子类之间重复相同的代码。控制流程：抽象类中的模板方法控制着整个算法的流程，确保逻辑的一致性，而具体的实现细节则由子类来提供。灵活性：子类可以根据需要覆盖父类中的方法，从而改变或扩展算法的某些步骤。 二、模板方法模式的应用场景 模板方法模式适用于以下场景：
算法步骤固定：当一个算法的步骤在高层次上是固定的，但某些步骤需要在子类中实现时，可以使用模板方法模式。避免重复代码：在多个子类中存在相似的代码或逻辑时，可以将相同的部分提取到父类中，而将不同的部分留给子类实现。标准化流程：当需要确保某个操作流程在各个子类中保持一致性时，可以使用模板方法模式来统一流程。 三、模板方法模式的实现 接下来，我们通过一个简单的例子来展示如何在实际开发中使用模板方法模式。
假设我们正在开发一个文档处理系统，不同类型的文档（如Word文档、PDF文档）有相似的处理流程，但每种文档格式的读取和保存方式不同。我们可以使用模板方法模式来实现这一需求。
3.1 定义抽象类 首先，我们定义一个抽象类DocumentProcessor，它包含了处理文档的通用步骤（读取、处理、保存），并定义了一个模板方法processDocument()。
public abstract class DocumentProcessor { // 模板方法，定义了处理文档的步骤 public final void processDocument() { openDocument(); parseDocument(); saveDocument(); } // 抽象方法，由子类实现 protected abstract void openDocument(); protected abstract void parseDocument(); protected abstract void saveDocument(); } 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-09T14:30:00+08:00">
    <meta property="article:modified_time" content="2024-08-09T14:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之模板方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在软件开发中，我们经常会遇到一些算法步骤固定但某些步骤需要由子类具体实现的场景。为了避免重复代码并确保逻辑一致性，<strong>模板方法模式（Template Method Pattern）</strong> 提供了一种优雅的解决方案。本文将详细探讨模板方法模式的定义、应用场景、优点以及如何在实际项目中使用这一模式来编写更加灵活和可维护的代码。</p> 
<h5><a id="_2"></a>一、模板方法模式概述</h5> 
<p>模板方法模式是一种行为型设计模式，它允许你在父类中定义一个算法的骨架，并将某些步骤的实现延迟到子类中。这样一来，子类可以重新定义算法的某些步骤，而不会改变算法的整体结构。</p> 
<h6><a id="11__6"></a>1.1 模板方法模式的结构</h6> 
<p>模板方法模式主要包括以下几个部分：</p> 
<ul><li><strong>抽象类（Abstract Class）</strong>：定义算法的骨架，并包含一个模板方法（template method）。模板方法定义了算法的步骤，并调用抽象方法来完成这些步骤。</li><li><strong>具体子类（Concrete Classes）</strong>：继承抽象类，实现其未实现的抽象方法，从而完成算法的具体步骤。</li></ul> 
<p>下图展示了模板方法模式的典型结构：</p> 
<pre><code>┌────────────────────┐
│  AbstractClass     │
│────────────────────│
│+ templateMethod()  │
│────────────────────│
│+ primitiveOperation1()  │
│+ primitiveOperation2()  │
└────────────────────┘
        ▲
        │
┌────────────────────┐
│ ConcreteClass       │
│────────────────────│
│+ primitiveOperation1() │
│+ primitiveOperation2() │
└────────────────────┘
</code></pre> 
<h6><a id="12__33"></a>1.2 模板方法模式的优点</h6> 
<ul><li><strong>代码复用</strong>：将通用的算法逻辑放在抽象类中，避免子类之间重复相同的代码。</li><li><strong>控制流程</strong>：抽象类中的模板方法控制着整个算法的流程，确保逻辑的一致性，而具体的实现细节则由子类来提供。</li><li><strong>灵活性</strong>：子类可以根据需要覆盖父类中的方法，从而改变或扩展算法的某些步骤。</li></ul> 
<h5><a id="_39"></a>二、模板方法模式的应用场景</h5> 
<p>模板方法模式适用于以下场景：</p> 
<ul><li><strong>算法步骤固定</strong>：当一个算法的步骤在高层次上是固定的，但某些步骤需要在子类中实现时，可以使用模板方法模式。</li><li><strong>避免重复代码</strong>：在多个子类中存在相似的代码或逻辑时，可以将相同的部分提取到父类中，而将不同的部分留给子类实现。</li><li><strong>标准化流程</strong>：当需要确保某个操作流程在各个子类中保持一致性时，可以使用模板方法模式来统一流程。</li></ul> 
<h5><a id="_47"></a>三、模板方法模式的实现</h5> 
<p>接下来，我们通过一个简单的例子来展示如何在实际开发中使用模板方法模式。</p> 
<p>假设我们正在开发一个文档处理系统，不同类型的文档（如Word文档、PDF文档）有相似的处理流程，但每种文档格式的读取和保存方式不同。我们可以使用模板方法模式来实现这一需求。</p> 
<h6><a id="31__53"></a>3.1 定义抽象类</h6> 
<p>首先，我们定义一个抽象类<code>DocumentProcessor</code>，它包含了处理文档的通用步骤（读取、处理、保存），并定义了一个模板方法<code>processDocument()</code>。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">DocumentProcessor</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 模板方法，定义了处理文档的步骤</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">processDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">openDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">parseDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">saveDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 抽象方法，由子类实现</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">openDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">parseDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">saveDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="32__73"></a>3.2 实现具体子类</h6> 
<p>接下来，我们为不同的文档类型（如Word和PDF）创建具体的子类，分别实现抽象方法。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordDocumentProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">DocumentProcessor</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">openDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Opening Word document..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">parseDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Parsing Word document..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">saveDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Saving Word document..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PdfDocumentProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">DocumentProcessor</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">openDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Opening PDF document..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">parseDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Parsing PDF document..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">saveDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Saving PDF document..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="33__113"></a>3.3 使用模板方法模式</h6> 
<p>最后，我们可以在客户端代码中使用模板方法模式来处理不同类型的文档。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TemplateMethodDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">DocumentProcessor</span> wordProcessor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WordDocumentProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        wordProcessor<span class="token punctuation">.</span><span class="token function">processDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">DocumentProcessor</span> pdfProcessor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PdfDocumentProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pdfProcessor<span class="token punctuation">.</span><span class="token function">processDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出结果将会是：</p> 
<pre><code>Opening Word document...
Parsing Word document...
Saving Word document...
Opening PDF document...
Parsing PDF document...
Saving PDF document...
</code></pre> 
<p>通过这种方式，我们可以确保处理文档的流程在所有文档类型中保持一致，而具体的实现细节则可以根据文档类型进行定制。</p> 
<h5><a id="_142"></a>四、模板方法模式的实际应用与注意事项</h5> 
<p>模板方法模式在各种需要标准化流程的场景中都有广泛的应用，例如：</p> 
<ul><li><strong>框架开发</strong>：在开发框架时，模板方法模式可以用来定义通用的处理流程，并将定制化的部分留给框架的用户实现。</li><li><strong>工作流引擎</strong>：在工作流系统中，可以使用模板方法模式来定义通用的工作流处理步骤，而将具体的任务执行方式交给子类实现。</li><li><strong>游戏开发</strong>：在游戏开发中，模板方法模式可以用来定义通用的游戏逻辑（如初始化、更新、渲染），而具体的实现则根据游戏类型不同进行定制。</li></ul> 
<p>然而，在使用模板方法模式时需要注意以下几点：</p> 
<ul><li><strong>父类与子类的耦合性</strong>：模板方法模式容易导致父类与子类之间的紧密耦合，如果算法步骤频繁变化，可能需要频繁修改父类和子类。</li><li><strong>抽象类的设计</strong>：父类中的模板方法应尽量保持简洁，避免在父类中实现过多的具体逻辑，否则容易导致代码复杂度增加。</li></ul> 
<h5><a id="_155"></a>五、总结</h5> 
<p>模板方法模式通过将算法的固定部分抽象到父类中，并将变化的部分延迟到子类中实现，提供了一种标准化流程和代码复用的有效方式。它在实际开发中非常有用，特别是在处理有相似步骤但需要定制化处理的业务逻辑时。</p> 
<p>通过合理应用模板方法模式，可以使代码结构更加清晰，避免重复代码，并确保业务流程的一致性。然而，在使用时也需要注意模式的局限性，并根据实际需求进行权衡和调整。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa42b7cb28ff6fe5c289523559ddb8d1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">宠物健康管理新纪元：智能听诊器革新体验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c0ec863403d7801855089e492d62e503/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">每天一个数据分析题（四百七十六）- 线性回归建模</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>