<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——常见简答题汇总 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0f306ad1a8c8d410588dd3f2c2e24f09/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——常见简答题汇总">
  <meta property="og:description" content="目录
1、绪论
2、线性表
3、栈、队列和数组
4、串 5、树与二叉树
6、图
7、查找
8、排序
1、绪论 什么是数据结构？
数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三个方面：逻辑结构、存储结构、数据的运算。
逻辑结构有：集合（数据元素除属于“同一个集合”外，别无其他关系）；
线性结构（数据元素之间只存在一对一的关系）；
树形结构（数据元素之间存在一对多的关系）；
图状结构或网状结构（数据元素之间存在多对多的关系）。
存储结构有：顺序存储、链式存储、索引存储、散列存储。
四种存储结构的优缺点是什么?
顺序存储：
优点：可以实现随机存取，每个元素占用最少的存储空间；
缺点：只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。
链式存储：
优点：不会出现碎片现象，能充分利用所有存储单元；
缺点：每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。
索引存储：
优点：检索速度快；
缺点：附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，
因而会花费较多的时间。
散列存储：
优点：检索、增加和删除结点的操作都很快；
缺点：若散列函数不好，则可能出现存储单元的冲突，而解决冲突会增加时间和空间的开销。
算法的基本概念？
算法（Algorithm）是对特定问题求解步骤的一种描述。
算法的五个特性：
有穷性、确定性、可行性、输入、输出。
“好”算法应达到以下目标：
正确性、可读性、健壮性、高效率与低存储量需求。 时间复杂度的计算？
点击跳转到时间复杂度的计算
常见的渐近时间复杂度为
O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O()&lt;O()&lt;O()&lt;O(n!)&lt;O()
2、线性表 顺序表在插入或删除时一般需要移动元素，如果想不移动多个元素就实现插入和删除，应该如何处理？
插入元素时，直接将新元素插入在第n&#43;1个位置；删除第i个元素时，将第n个元素补到第i个位置。
请简要说明线性表的顺序存储结构和链式存储结构在数据插入、数据删除、数据查找、存储空间占用等方面的优缺点。
顺序表在插入和删除时需要移动很多数据，时间耗费高；而链式存储不需要移动数据，时间耗费低。
顺序表分配空间的大小不好确定，要根据经验；而链式存储时按照需要分配，不会浪费空间。
顺序表查找元素时，支持用下标查找，时间耗费低；链式存储方式查找时只能从前往后顺序进行查找和比较，时间耗费高。
链式存储结构中，头指针和头结点之间的区分？引入头结点有什么优点呢？
不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。
引入头结点后，可以带来两个优点：
①由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
②无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。
循环双链表的判空条件是什么？
当循环双链表为空表时，head-&gt;next=head 并且 head-&gt;prior=head;
3、栈、队列和数组 说明线性表、栈和队列的异同点？
相同点：
都是线性结构，都是逻辑结构的概念。都可以用顺序存储和链式存储。
不同点：
①运算规则不同，线性表支持随机存取。栈只允许在一端进行插入、删除运算，因而是后进先出（LIFO)。队列是只允许一端进行插入，另一端进行删除运算，因而是先进先出（FIFO)。
②用途不同，栈用于子程调用和保护现场。队列用于多道作业处理、指令寄存及其他运算等。
栈初始化是栈顶指针S.top==-1，栈空和栈满的条件是什么？
栈空：S.top==-1
栈满：S.top==MaxSize-1
共享栈两个栈顶指针都指向栈顶元素，第一种情况top0=-1时0号栈为空，top1=MaxSize时1号栈为空。第二种情况top0=0时0号栈为空，top1=MaxSize-1时1号栈为空。判满条件分别是什么？ 判满条件：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-05T09:13:43+08:00">
    <meta property="article:modified_time" content="2024-03-05T09:13:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——常见简答题汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E7%BB%AA%E8%AE%BA-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%BB%AA%E8%AE%BA" rel="nofollow">1、绪论</a></p> 
<p id="2%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8" rel="nofollow">2、线性表</a></p> 
<p id="3%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84" rel="nofollow">3、栈、队列和数组</a></p> 
<p id="4%E3%80%81%E4%B8%B2%C2%A0-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E4%B8%B2%C2%A0" rel="nofollow">4、串 </a></p> 
<p id="5%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">5、树与二叉树</a></p> 
<p id="6%E3%80%81%E5%9B%BE-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%9B%BE" rel="nofollow">6、图</a></p> 
<p id="7%E3%80%81%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E6%9F%A5%E6%89%BE" rel="nofollow">7、查找</a></p> 
<p id="8%E3%80%81%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E6%8E%92%E5%BA%8F" rel="nofollow">8、排序</a></p> 
<hr> 
<h3 id="1%E3%80%81%E7%BB%AA%E8%AE%BA">1、绪论</h3> 
<p>什么是数据结构？</p> 
<blockquote> 
 <p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三个方面：逻辑结构、存储结构、数据的运算。</p> 
 <p>逻辑结构有：集合（数据元素除属于“同一个集合”外，别无其他关系）；</p> 
 <p>                     线性结构（数据元素之间只存在一对一的关系）；</p> 
 <p>                     树形结构（数据元素之间存在一对多的关系）；</p> 
 <p>                     图状结构或网状结构（数据元素之间存在多对多的关系）。</p> 
 <p>存储结构有：顺序存储、链式存储、索引存储、散列存储。</p> 
</blockquote> 
<p>四种存储结构的优缺点是什么?</p> 
<blockquote> 
 <p>顺序存储：</p> 
 <p>        优点：可以实现随机存取，每个元素占用最少的存储空间；</p> 
 <p>        缺点：只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</p> 
 <p>链式存储：</p> 
 <p>        优点：不会出现碎片现象，能充分利用所有存储单元；</p> 
 <p>        缺点：每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</p> 
 <p>索引存储：</p> 
 <p>        优点：检索速度快；</p> 
 <p>        缺点：附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，</p> 
 <p>                   因而会花费较多的时间。</p> 
 <p>散列存储：</p> 
 <p>        优点：检索、增加和删除结点的操作都很快；</p> 
 <p>        缺点：若散列函数不好，则可能出现存储单元的冲突，而解决冲突会增加时间和空间的开销。</p> 
</blockquote> 
<p>算法的基本概念？</p> 
<blockquote> 
 <p>算法（Algorithm）是对特定问题求解步骤的一种描述。</p> 
 <p>算法的五个特性：</p> 
 <p>        有穷性、确定性、可行性、输入、输出。</p> 
 <p>“好”算法应达到以下目标：</p> 
 <p>        正确性、可读性、健壮性、高效率与低存储量需求。 </p> 
</blockquote> 
<p> 时间复杂度的计算？</p> 
<blockquote> 
 <p><a class="link-info" href="https://blog.csdn.net/m0_73139998/article/details/133684686" title="点击跳转到时间复杂度的计算">点击跳转到时间复杂度的计算</a></p> 
 <p>常见的渐近时间复杂度为</p> 
 <p>        O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(<img alt="n^{2}" class="mathcode" src="https://images2.imgbox.com/b2/68/VVFJML9t_o.png">)&lt;O(<img alt="n^{3}" class="mathcode" src="https://images2.imgbox.com/f6/28/QwhwkdfH_o.png">)&lt;O(<img alt="2^{n}" class="mathcode" src="https://images2.imgbox.com/d5/24/0aLLobfa_o.png">)&lt;O(n!)&lt;O(<img alt="n^{n}" class="mathcode" src="https://images2.imgbox.com/95/29/9AGufIT2_o.png">)</p> 
</blockquote> 
<h3 id="2%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8">2、线性表</h3> 
<p>顺序表在插入或删除时一般需要移动元素，如果想不移动多个元素就实现插入和删除，应该如何处理？</p> 
<blockquote> 
 <p>插入元素时，直接将新元素插入在第n+1个位置；删除第i个元素时，将第n个元素补到第i个位置。</p> 
</blockquote> 
<p>请简要说明线性表的顺序存储结构和链式存储结构在数据插入、数据删除、数据查找、存储空间占用等方面的优缺点。</p> 
<blockquote> 
 <p>顺序表在插入和删除时需要移动很多数据，时间耗费高；而链式存储不需要移动数据，时间耗费低。</p> 
 <p>顺序表分配空间的大小不好确定，要根据经验；而链式存储时按照需要分配，不会浪费空间。</p> 
 <p>顺序表查找元素时，支持用下标查找，时间耗费低；链式存储方式查找时只能从前往后顺序进行查找和比较，时间耗费高。</p> 
</blockquote> 
<p>链式存储结构中，头指针和头结点之间的区分？引入头结点有什么优点呢？</p> 
<blockquote> 
 <p>不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</p> 
 <p>引入头结点后，可以带来两个优点：</p> 
 <p>        ①由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</p> 
 <p>        ②无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。</p> 
</blockquote> 
<p>循环双链表的判空条件是什么？</p> 
<blockquote> 
 <p>当循环双链表为空表时，head-&gt;next=head 并且 head-&gt;prior=head;</p> 
</blockquote> 
<h3 id="3%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84">3、栈、队列和数组</h3> 
<p>说明线性表、栈和队列的异同点？</p> 
<blockquote> 
 <p>相同点：</p> 
 <p>        都是线性结构，都是逻辑结构的概念。都可以用顺序存储和链式存储。</p> 
 <p>不同点：</p> 
 <p>        ①运算规则不同，线性表支持随机存取。栈只允许在一端进行插入、删除运算，因而是后进先出（LIFO)。队列是只允许一端进行插入，另一端进行删除运算，因而是先进先出（FIFO)。</p> 
 <p>        ②用途不同，栈用于子程调用和保护现场。队列用于多道作业处理、指令寄存及其他运算等。</p> 
</blockquote> 
<p>栈初始化是栈顶指针S.top==-1，栈空和栈满的条件是什么？</p> 
<blockquote> 
 <p>栈空：S.top==-1</p> 
 <p>栈满：S.top==MaxSize-1</p> 
</blockquote> 
<p>共享栈两个栈顶指针都指向栈顶元素，第一种情况top0=-1时0号栈为空，top1=MaxSize时1号栈为空。第二种情况top0=0时0号栈为空，top1=MaxSize-1时1号栈为空。判满条件分别是什么？ </p> 
<blockquote> 
 <p>判满条件：</p> 
 <p>        第一种：top1-top0==1（两个指针<span style="background-color:#ffd900;">相邻</span>，因为插入时先移指针再插入元素）</p> 
 <p>        第二种：top0-top1==1（两个指针<span style="background-color:#ffd900;">错开相邻</span>，因为插入时先插入元素再移动指针）</p> 
</blockquote> 
<p>当1、2、3、4顺序进栈时，列出所有可能的出栈顺序？</p> 
<blockquote> 
 <p>有14种（<img alt="\frac{1}{n+1}C_{2n}^{n}" class="mathcode" src="https://images2.imgbox.com/20/42/kBboDWFW_o.png">用卡特兰数计算）</p> 
 <p>①全进之后再出，只有1种：4321</p> 
 <p>②进三个开始出，只有3种：3421、3241、3214</p> 
 <p>③进二个开始出，只有5种：2431、2341、2134、2143、2134</p> 
 <p>④进一个开始出，只有5种：1431、1324、1342、1234、1243 </p> 
</blockquote> 
<p>顺序队列的入队出现“假上溢/假溢出”是怎样产生的?解决途径是什么？为了区分队空还是队满的情况，有哪三种处理方式？ </p> 
<blockquote> 
 <p> 一般的一维数组队列的尾指针已经到了数组的上界，不能再有入队操作，但其实数组中还有空位置，这就叫“假溢出”。采用循环队列是解决假溢出的途径。</p> 
 <p>为了区分是队空还是队满的情况，有三种处理方式：</p> 
 <p>        ①牺牲一个单元来区分队空还是队满入队时少用一个队列单元，这是一种较为普遍的做法。队满条件：（Q.rear+1)%MaxSize==Q.front。队空条件：Q.rear==Q.front。队列中元素的个数：（Q.rear-Q.front+MaxSize)%MaxSize。</p> 
 <p>        ②类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size==0；堆满的条件是Q.size==MaxSize。这两种情况都有Q.front==Q.rear。</p> 
 <p>        ③类型中增设tag数据成员，以区分是队满还是队空。tag等于0时，若因删除导致Q.front==Q.rear，则为队空；tag等于1时,若因插入导致Q.front==Q.rearz，则为堆满。</p> 
</blockquote> 
<p>稀疏矩阵压缩存储策略有哪两种？</p> 
<blockquote> 
 <p>链式存储：十字链表法。</p> 
 <p>顺序存储：三元组&lt;i（行），j（列），v（值）&gt;,失去了数组随机存储的特性。</p> 
</blockquote> 
<p>将稀疏矩阵换成对应的三元组(<span style="background-color:#ffd900;">行列从0，0或者从1，1开始记得备注清楚</span>），将稀疏矩阵转为十字链表呢？反向转换成稀疏矩阵呢？</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" height="206" src="https://images2.imgbox.com/67/ca/pDEProCr_o.png" width="714"></p> 
</blockquote> 
<p> 广义表会基本操作？</p> 
<blockquote> 
 <p>考点：</p> 
 <p>        ①求表头（取第一个元素）</p> 
 <p>        ②求表尾（除去第一个元素）</p> 
 <p>        ③求长度（所含元素个数）</p> 
 <p>        ④求深度（数左括号或右括号个数）</p> 
 <p>例1：广义表((a,b,c,d))的表头是（a,b,c,d)  表尾是 （）</p> 
 <p>例2：广义表L=((a,b,c))，则L的长度和深度分别是 1  和  2</p> 
 <p>例3：广义表L=(a,(b,c))，进行Tail(L)操作后结果是 ((b,c))</p> 
 <p>//例4从最里层函数往外求</p> 
 <p>例4：广义表A=(a,b,(c,d),(e,(f,g)))，则Head(Tail(Head(Tail(Tail(A)))))的值为 d        </p> 
</blockquote> 
<p>画出广义表（a，（x，y），（（x）））的存储结构 ？</p> 
<blockquote> 
 <p><img alt="" height="334" src="https://images2.imgbox.com/b1/ca/Eck00dQh_o.png" width="757"></p> 
</blockquote> 
<h3 id="4%E3%80%81%E4%B8%B2%C2%A0">4、串 </h3> 
<p>设有主串S='aabaabaabaac'，模式串P='aabaac'。（1）求出P的next数组。（2）试给出KMP算法的匹配过程。</p> 
<blockquote> 
 <p>（1）P的next数组如下所示：</p> 
 <p><img alt="" height="117" src="https://images2.imgbox.com/67/d7/iRvhyt9V_o.png" width="494"></p> 
 <p>（2）KMP算法的匹配过程如下：</p> 
 <p><img alt="" height="364" src="https://images2.imgbox.com/50/67/u7XtYxML_o.png" width="815"></p> 
</blockquote> 
<p>串'ababaaababaa'的nextval数组为？</p> 
<blockquote> 
 <p><img alt="" height="137" src="https://images2.imgbox.com/71/27/hZdYE8OH_o.png" width="772"></p> 
</blockquote> 
<h3 id="5%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91">5、树与二叉树 </h3> 
<p>一棵二叉树分别用顺序存储和链式存储表示？</p> 
<blockquote> 
 <p>注：其中0表示不存在的空结点，数组存储的开始下标建议从1开始。</p> 
 <p><img alt="" height="223" src="https://images2.imgbox.com/6d/da/bgCvIiye_o.png" width="583"></p> 
 <p><img alt="" height="239" src="https://images2.imgbox.com/20/6e/exRa1GfU_o.png" width="588"></p> 
</blockquote> 
<p>试写出如图所示的二叉树分别按先序、中序、后序、层序遍历时得到的结点序列？</p> 
<blockquote> 
 <p><img alt="" height="163" src="https://images2.imgbox.com/6f/47/3TLr5Bzh_o.png" width="149"></p> 
 <p>先序：ABDEC</p> 
 <p>中序：DBEAC</p> 
 <p>后序：DEBCA</p> 
 <p>层序：ABCDE</p> 
</blockquote> 
<p>由遍历序列构造二叉树（三种情况：先序和中序、后序和中序、层序和中序 ）？<span style="background-color:#ffd900;">关键点：先确定根，然后通过中序分左右子树</span></p> 
<blockquote> 
 <p>例如：求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树</p> 
 <p><img alt="" height="209" src="https://images2.imgbox.com/10/5c/fArjc5rF_o.png" width="579"></p> 
</blockquote> 
<p>请画出与下面二叉树相对应的中序线索二叉链表（不带头结点）？</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/22/MqICCPy6_o.png"></p> 
</blockquote> 
<p>请画出与下面二叉树相对应的中序线索二叉树链式存储结构（带头结点）？</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/18/WVJC88OD_o.png"></p> 
</blockquote> 
<p>一棵树双亲表示法、孩子表示法、孩子兄弟表示法怎么表示 ？</p> 
<blockquote> 
 <p><img alt="" height="344" src="https://images2.imgbox.com/63/68/6MT5P8pe_o.png" width="712"></p> 
 <p><img alt="" height="392" src="https://images2.imgbox.com/8a/27/v0Ap5xxG_o.png" width="789"></p> 
</blockquote> 
<p> 用“左孩子右兄弟”的方法将一棵树转换为二叉树？将森林转换成一棵二叉树？</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9f/80/P4nUYVSA_o.png"></p> 
 <p style="text-align:center;"><img alt="" height="355" src="https://images2.imgbox.com/ab/25/CHMPjk57_o.png" width="715"></p> 
</blockquote> 
<p>哈夫曼树如何构造？带权路径长度（WPL）是多少？各个字符编码为？</p> 
<blockquote> 
 <p><img alt="" height="345" src="https://images2.imgbox.com/01/7a/A3ktOyXS_o.png" width="797"></p> 
</blockquote> 
<p>设给定权集w={5,7,2,3,6,8,9}，试构造关于w的一棵哈夫曼树，并求其加权路径长度WPL。 </p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f7/ba/Mdf6Qt8E_o.png"></p> 
</blockquote> 
<h3 id="6%E3%80%81%E5%9B%BE">6、图</h3> 
<p>图的邻接矩阵存储有什么特点？</p> 
<blockquote> 
 <p style="text-align:left;">①无向图邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需要存储上（或下）三角矩阵的元素。</p> 
 <p style="text-align:left;">②对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是顶点i的度TD（Vi）。</p> 
 <p style="text-align:left;">③对于有向图，邻接矩阵第i行非零元素（或非∞元素）的个数正好是顶点i的出度OD（Vi）；第i列非零元素（或非∞元素）的个数正好是顶点i的入度ID（Vi）。</p> 
 <p style="text-align:left;">④用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</p> 
 <p style="text-align:left;">⑤稠密图适合使用邻接矩阵的存储表示。</p> 
 <p style="text-align:left;">⑥设图G的邻接矩阵为A，<img alt="A^{n}" class="mathcode" src="https://images2.imgbox.com/ac/c4/YZ4QQq99_o.png">的元素<img alt="A^{n}[i][j]" class="mathcode" src="https://images2.imgbox.com/47/71/ztQLjzvW_o.png">等于由顶点i到顶点j的长度为n的路径的树目。</p> 
</blockquote> 
<p>图的邻接表存储有什么特点？</p> 
<blockquote> 
 <p style="text-align:left;">①若G为无向图，则所需的存储空间为O(|V|+2|E|)；若G为有向图，则所需的存储空间为O(|V|+|E|)。</p> 
 <p style="text-align:left;">②对于稀疏图，采用邻接表表示将极大地节省存储空间。</p> 
 <p style="text-align:left;">③在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</p> 
 <p style="text-align:left;">④在有向图的邻接表表示中，求一个给定顶点的出度只需要计算其邻接表中结点的个数；但求其结点的入度则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。</p> 
 <p style="text-align:left;">⑤图的邻接表表示并不唯一，以为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</p> 
</blockquote> 
<p>如何对无环有向图中的顶点号重新安排可使得该图的邻接矩阵中所有的1都集中到对角线以上？</p> 
<blockquote> 
 <p>按各顶点的出度进行排序，n个顶点的有向图，其顶点的最大出度是n-1，最小出度为0，这样排序后，出度最大的顶点编号为1，出度最小的顶点编号为n。之后，进行调整，即只要存在弧&lt;i,j&gt;，就不管顶点j的出度是否大于顶点i的出度，都把i编号在顶点j的编号之前，因为只有<img alt="i\leq j" class="mathcode" src="https://images2.imgbox.com/dc/1b/QIAU4oHz_o.png">，弧&lt;i,j&gt;对应的1才能出现在邻接矩阵的上三角。 </p> 
</blockquote> 
<p> 判断有向图中是否存在回路，有什么方法？简要介绍</p> 
<blockquote> 
 <p>①拓扑排序。因为拓扑排序先是从AOV网中选择一个没有前驱的顶点输出，从网中删除该顶点和所有以它为起点的有向边。一种重复这种操作，直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</p> 
 <p>②深度优先遍历。从有向图的某个顶点v出发进行深度优先遍历时，若在DFS(v)结束之前出现一条从顶点u到顶点v的回边，且u在生成树上是v的子孙，则有向图必定存在包含顶点v和顶点u的环。</p> 
</blockquote> 
<p>已知道图的顶点和边的集合时，能画出图的形状？</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/75/70/OGsCdObD_o.png"></p> 
</blockquote> 
<p>已知有向图和无向图，画出对应的邻接矩阵？</p> 
<blockquote> 
 <p><img alt="" height="175" src="https://images2.imgbox.com/27/4f/fou3Lwoi_o.png" width="756"></p> 
</blockquote> 
<p>带权图的邻接矩阵怎么画呢？</p> 
<blockquote> 
 <p><img alt="" height="194" src="https://images2.imgbox.com/58/c1/RqaR9N5z_o.png" width="516"></p> 
</blockquote> 
<p>已知道有向图和无向图，让你画出对应的邻接表你会画吗？</p> 
<blockquote> 
 <p><img alt="" height="579" src="https://images2.imgbox.com/8b/90/BsL5Xwd0_o.png" width="751"></p> 
</blockquote> 
<p>图G=(V,E)以邻接表存储，如下图所示，试画出图G的深度优先生成树和广度优先生成树（假设从结点1开始遍历）,深度优先序列和广度优先序列呢？</p> 
<blockquote> 
 <p><img alt="" height="182" src="https://images2.imgbox.com/81/50/2WkdSDyj_o.png" width="749"></p> 
 <p><img alt="" height="267" src="https://images2.imgbox.com/b1/cd/yx96sdwa_o.png" width="890"></p> 
</blockquote> 
<p>如何使用Prim算法构造最小生成树，给出构造过程？</p> 
<blockquote> 
 <p><img alt="" height="436" src="https://images2.imgbox.com/85/67/eO0E74cL_o.png" width="751"></p> 
</blockquote> 
<p> 如何使用Kruskal算法构造最小生成树，给出构造过程？</p> 
<blockquote> 
 <p><img alt="" height="410" src="https://images2.imgbox.com/7d/49/hajMxzOF_o.png" width="708"></p> 
</blockquote> 
<p>请简要介绍Prim算法和Kruskal算法的构造过程，时间复杂度，适用于哪类图？</p> 
<blockquote> 
 <p>①Prim算法的执行非常类似于寻找图的最短路径的Dijkstra算法。初始时从图中任取一顶点加入树T，之后选择一个与当前T中顶点集合距离最近的顶点，并将改顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中的所有顶点都并入T，得到的T就是最小生成树。</p> 
 <p>Prim算法的时间复杂度为<img alt="O(|v|^{2})" class="mathcode" src="https://images2.imgbox.com/9b/06/2GP3wt9B_o.png"> ，不依赖于|E|，因此它适用于求解边稠密的图的最小生成树。</p> 
 <p>②Kruskal是一种按权值的递增次序选择合适的边来构造最小生成树的方法。初始时为只有n个顶点而无边的非连通图T={V,{}}，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入T，否则舍弃此边而选择下一条权值最小的边。以此类推，直至T中所有顶点都在一个连通分量上。</p> 
 <p>Kruskal构造最小生成树时间复杂度为<img alt="O(|E|\log _{2}|E|)" class="mathcode" src="https://images2.imgbox.com/01/1f/kIhAL7ph_o.png">,适合于边稀疏而顶点多的图。</p> 
</blockquote> 
<p>简述Dijkstra算法和Floyd算法，并说一下分别适用于什么图和不适合什么图？</p> 
<blockquote> 
 <p>①Dijkstra算法求单源最短路径，利用贪心策略，在已经求得最短路径得基础上，求更长距离的最短路径。适合于稀疏图，求解有回路的带权图的最短路径，也可以求任意两个顶点的最短路径，不适合求 带负权值的最短路径问题。</p> 
 <p>②Floyd算法求任意两个顶点的最短路径，利用动态规划的思想。适用于稠密图，允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。</p> 
</blockquote> 
<p> 给定一个有向无环图，让写出拓扑排序的结果为？</p> 
<blockquote> 
 <p>以下图的拓扑排序结果为{1，2，4，3，5}</p> 
 <p><img alt="" height="592" src="https://images2.imgbox.com/b2/fa/o2PvbXUK_o.png" width="802"></p> 
</blockquote> 
<p>给定一个AOE网，求出其关键路径，该工程完成的最少时间？</p> 
<blockquote> 
 <p>关键路径为（v1,v3,v4,v6)，最少时间为a2+a5+a7=8</p> 
 <p><img alt="" height="348" src="https://images2.imgbox.com/58/2b/Iqiz46Us_o.png" width="953"></p> 
</blockquote> 
<p>请比较AOE网与AOV网。</p> 
<blockquote> 
 <p>AOV网：顶点用来表示活动。AOV网的边无权值，仅表示顶点的前后关系。AOV网是用来分析工程需要花多少时间完成，或是为了缩短时间需要加快哪些活动等问题。</p> 
 <p>AOE网：顶点用来表示事件，边表示活动。边上的权值用来表示活动持续的事件。 AOE网是用来表示活动之间的制约关系。</p> 
</blockquote> 
<p>关键路径和关键活动。</p> 
<blockquote> 
 <p>关键路径：从源点到汇点的所有路径中，具有最大路径长度的路径被称为关键路径。</p> 
 <p>关键活动：关键路径上的活动。</p> 
 <p>特点：关键活动的最早开始时间等于最迟开始时间。</p> 
 <p>对于关键路径，需要注意以下几点：</p> 
 <p>1、关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。</p> 
 <p>2、网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能缩短工期的目的。 </p> 
</blockquote> 
<h3 id="7%E3%80%81%E6%9F%A5%E6%89%BE">7、查找</h3> 
<p>有序顺序表中的元素依次为017，094，154，170，275，503，509，512，553，612，677，765，897，908。1）试画出对其进行折半查找的判定树。2）若查找275或684的元素，将依次与表中的哪些元素比较？3）计算查找成功的平均查找长度和查找不成功的平均查找长度。</p> 
<blockquote> 
 <p><img alt="" height="644" src="https://images2.imgbox.com/61/ee/ouGI3CHD_o.png" width="976"></p> 
</blockquote> 
<p>按照序列{40，72，38，35，67，51，90，8，55，21}建立一棵二叉排序树，画出该树，并求出在等概率的情况下，查找成功的平均查找长度。</p> 
<blockquote> 
 <p><img alt="" height="306" src="https://images2.imgbox.com/51/16/3lvOXEp5_o.png" width="689"></p> 
</blockquote> 
<p>一棵二叉树按先序遍历得到的序列为（50，38，30，45，40，48，70，60，75，80），试画出该二叉排序树，并求出等概率下查找成功和查找失败的平均查找长度。</p> 
<blockquote> 
 <p><img alt="" height="554" src="https://images2.imgbox.com/3d/a0/MP1c1zhW_o.png" width="1030"></p> 
</blockquote> 
<p>给定一个关键字集合{25，18，34，9，14，27，42，51，38}，假定查找各关键字的概率相同，请画出其最佳排序树。</p> 
<blockquote> 
 <p><img alt="" height="368" src="https://images2.imgbox.com/6c/90/Kq8psZnW_o.png" width="1007"></p> 
</blockquote> 
<p>依次把结点（34，23，15，98，115，28，107）插入初始状态为空的平衡二叉排序树，使得在每次插入后保持该树仍然是平衡二叉树。请依次画出每次插入后所形成的平衡二叉排序树。</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/60/34/hQaIB9Tl_o.png"></p> 
</blockquote> 
<p>顺序表顺序查找、折半查找、分块查找的3种查找方法比较：</p> 
<blockquote> 
 <p>上述3种查找方法的比较如下：</p> 
 <p>1、就平均查找长度而言，折半查找的平均查找长度最小，分块查找次之，顺序表查找最大。</p> 
 <p>2、就表的结构而言，顺序表查找对有序表、无需表均适用，折半查找仅适用于有序表，而分块查找要求表中元素至少是分块有序的。</p> 
 <p>3、就表的存储结构而言，顺序查找和分块查找可以适用于顺序表和链表两种存储结构，而折半查找只适用于以顺序表作为存储结构的表。</p> 
 <p>4、分块查找综合了顺序查找和折半查找的优点，既能较快速地查找，又能适应动态变化的要求。 </p> 
</blockquote> 
<p>对长度为<img alt="2^{k}-1" class="mathcode" src="https://images2.imgbox.com/d9/29/pTC5Zhyn_o.png">的有序表进行折半查找，在成功查找时，最少需要多少次关键字比较？最多需要多少次关键字比较？查找失败时的平均比较次数是多少？</p> 
<blockquote> 
 <p>当查找的记录正好处于中间位置时，关键字的比较次数最少，所以折半查找在成功查找时最少需要1次关键字比较。</p> 
 <p>折半查找在成功查找时最多关键字比较次数为判定树的高度，即<img alt="log_{2}(2^{k}-1+1)=k" class="mathcode" src="https://images2.imgbox.com/d4/e9/UmWDgmQ7_o.png">，折半查找在不成功查找时比较过程落在外部结点中，将判定树看成是一颗满二叉树，所有外部结点的高度为k+1，其关键字比较次数为k，所以查找失败时的平均比较次数是k次。 </p> 
</blockquote> 
<p>简述平衡二叉树中插入新结点导致不平衡进行调整的4种形态和调整方法。</p> 
<blockquote> 
 <p>在平衡二叉树中插入新结点可能导致不平衡，调整成平衡二叉树的4种形态如下，后面是调整方法。</p> 
 <p>LL型调整：在结点的左子树的左子树上插入新结点导致不平衡。（右单旋转）</p> 
 <p>RR型调整：在结点的右子树的右子树上插入新结点导致不平衡。（左单旋转）</p> 
 <p>LR型调整：在结点的左子树的右子树上插入新结点导致不平衡。（先左后右双旋转）</p> 
 <p>RL型调整：在结点的右子树的左子树上插入新节点导致不平衡。  （先右后左双旋转）</p> 
</blockquote> 
<p>红黑树的定义和性质？</p> 
<blockquote> 
 <p>一棵红黑树是满足如下红黑性质的二叉排序树：（记：<span style="color:#fe2c24;">左根右，根叶黑，不红红，黑路同</span>）</p> 
 <p>1、每个结点或是红色，或是黑色的。</p> 
 <p>2、根结点是黑色的。</p> 
 <p>3、叶结点（虚构的外部结点、NULL结点）都是黑色的。</p> 
 <p>4、不存在两个相邻的红结点 （即红结点的父结点和孩子结点均是黑色的）。</p> 
 <p>结论1：从根到叶结点的最长路径不大于最短路径的2倍。</p> 
 <p>结论2：有n个内部结点的红黑树的高度<img alt="h\leq 2\log _{2}(n+1)" class="mathcode" src="https://images2.imgbox.com/bc/dc/1kv5Ilto_o.png">。</p> 
</blockquote> 
<p>m阶的B+树与m阶的B树的主要差异有哪些？</p> 
<blockquote> 
 <p>1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有n+1棵子树。</p> 
 <p>2）在B+树中，每个结点（非根内部结点）的关键字个数n的范围是<img alt="\left \lceil m/2 \right \rceil\leqslant n\leqslant m" class="mathcode" src="https://images2.imgbox.com/63/5b/w0WpZGXo_o.png">（而根结点：<img alt="2\leq n\leq m" class="mathcode" src="https://images2.imgbox.com/74/ad/eS1TlomK_o.png">）；而在B树中，每个结点（非根内部结点）的关键字个数n的范围是<img alt="\left \lceil m/2 \right \rceil-1\leqslant n\leqslant m-1" class="mathcode" src="https://images2.imgbox.com/b9/8d/dM1EqkSk_o.png">（根结点：<img alt="1\leq n\leq m-1" class="mathcode" src="https://images2.imgbox.com/7e/37/9YJHLO32_o.png">）。</p> 
 <p>3）在B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。</p> 
 <p>4）在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</p> 
</blockquote> 
<p>使用散列函数H(key)=key%11，把一个整数值转换成散列表下标，现在要把数据{1，13，12，34，38，33，27，22}依次插入散列表。1）使用线性探测法来构造散列表。2）使用链地址法构造散列表。试针对这两种情况，分别确定查找成功所需的平均查找长度，及查找不成功所需的平均查找长度。</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/93/06/YEay82FQ_o.png"></p> 
</blockquote> 
<p> 已知一组关键字为{26，36，41，38，44，15，68，12，6，51，25}，用链地址法解决冲突，假设装填因子α=0.75，散列函数的形式为H(key)=key%P，回答以下问题：1）构造出散列函数。2）分别计算出等概率情况下查找成功和查找失败的平均查找长度（查找失败的计算中只将与关键字的比较次数计算在内即可）。</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7c/71/tbrS4zlH_o.png"></p> 
</blockquote> 
<p>设散列表为HT[0...12]，即表的大小为m=13。现采用双散列法解决冲突，散列函数和再散列函数分别为：<img alt="H_{0}(key)=(key)mod13" class="mathcode" src="https://images2.imgbox.com/f7/2b/9kYnneBb_o.png"><img alt="H_{i}=(H_{i-1}+REV(key+1)mod11+1)mod13); i=1,2,3,.....,m-1" class="mathcode" src="https://images2.imgbox.com/bf/ec/uJv8wcBb_o.png">。其中，函数REV(x)表示颠倒十进制数x的各位，如REV(37)=73,REV(7)=7等。若插入的关键码序列为（2，8，31，20，19，18，53，27），请回答：1）画出插入这8个关键码后的散列表。2）计算查找成功的平均查找长度ASL。</p> 
<blockquote> 
 <p><img alt="" height="382" src="https://images2.imgbox.com/48/8c/m6nggdg6_o.png" width="960"></p> 
</blockquote> 
<h3 id="8%E3%80%81%E6%8E%92%E5%BA%8F">8、排序 </h3> 
<p>直接插入排序和折半插入排序的相同点和区别？</p> 
<blockquote> 
 <p>①相同点：二者都将待插入元素插入前面的有序子表。排序的总趟数取决于元素个数n，两者都是n-1趟。元素的移动次数都取决于初始序列，二者相同。适用辅助空间的数量都是O(1)。都是稳定的排序算法。</p> 
 <p>②区别：确定当前记录在前面有序子表中的位置时，直接插入排序采用顺序查找法，而折半插入排序采用折半查找法。折半插入排序的比较次数与序列初态无关，为<img alt="O(nlog_{2}n)" class="mathcode" src="https://images2.imgbox.com/82/c5/CMHGhdWi_o.png">；而直接插入排序的比较次数与序列初态有关，为<img alt="O(n)~O(n^{2})" class="mathcode" src="https://images2.imgbox.com/ba/65/vOaANQnm_o.png">。</p> 
</blockquote> 
<p>比较直接插入排序算法和希尔排序算法的不同点？</p> 
<blockquote> 
 <p>直接插入排序算法是稳定的，更适合于原始元素基本有序的情况。若采用折半查找而不是顺序查找待插入元素的插入位置时，可减少元素比较的次数，但移动元素的次数没有减少；在采用顺序查找待插入元素的位置时也适用于链式存储结构。</p> 
 <p>希尔排序算法是不稳定的；元素的总比较次数和移动次数都比直接插入排序时要少，n越大时，效果越明显；增量序列d可以有不同的取法，但有两个共同的特征，即最后一个增量必须是1，增量序列中的值没有除1之外的公因子；希尔排序不适用于链式结构。</p> 
</blockquote> 
<p>指出堆和二叉排序树的区别。</p> 
<blockquote> 
 <p>以小根堆为例，堆的特点是双亲结点的关键字必然小于等于孩子结点的关键字，而两个孩子结点的关键字没有次序规定。而二叉排序中，每个双亲结点的关键字均大于左子数结点的关键字，每个双亲结点的关键字均小于右子树结点的关键字，也就是说，每个双亲结点的左、右孩子的关键字有次序关系。</p> 
</blockquote> 
<p>堆排序是否是一种稳定的排序算法？为什么？</p> 
<blockquote> 
 <p>堆排序是一种不稳定的排序方法。因为在堆调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对相同的关键字而言，就可能出现排在后面的关键字被交换到前面的情况。 </p> 
</blockquote> 
<p>将快速排序算法改为非递归算法时通常使用一个栈，若把栈换位队列会对最终排序结果有什么影响？</p> 
<blockquote> 
 <p> 在执行快速排序算法时，用栈保存每趟快速排序划分后左、右子区段的首、尾地址，其目的是为了在处理子区段未排序子序列时能够知道其范围，这样才能对该子序列进行排序（排序过程中可能产生新的左、右区段），但这与处理子序列的先后顺序没什么关系，而仅仅起存储作用。因此，用队列同样可以存储子区段的首、尾地址，即可以取代栈的作用，在执行快速排序算法时，把栈换为队列不会产生任何影响。</p> 
</blockquote> 
<p>哪些排序算法会受初始关键字分布的影响？</p> 
<blockquote> 
 <p>当排序记录序列按关键字顺序有序时，直接插入排序和起泡排序能达到 <img alt="O(n)" class="mathcode" src="https://images2.imgbox.com/4b/30/vQm1H4F3_o.png">的时间复杂度；而对于快速排序而言，这是最不好的情况，此时的时间性能变为<img alt="O(n^{2})" class="mathcode" src="https://images2.imgbox.com/04/2e/PtDNVYUh_o.png">，因此时应该尽量避免的情况。</p> 
 <p>另外，简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。</p> 
</blockquote> 
<p>给出关键字序列{4，5，1，2，6，3}的直接插入排序过程。</p> 
<blockquote> 
 <p><img alt="" height="255" src="https://images2.imgbox.com/d7/5c/CvHLyoBc_o.png" width="735"></p> 
</blockquote> 
<p>给出关键字序列{50，26，38，80，70，90，8，30，40，20}的希尔排序过程（取增量序列为d={5,3,1},排序结果为从小到大排列。</p> 
<blockquote> 
 <p><img alt="" height="149" src="https://images2.imgbox.com/69/b6/0MbRw09Z_o.png" width="759"></p> 
</blockquote> 
<p>要对{<!-- --><u>49</u>，27，13，76，97，65，38，49}进行冒泡排序，给出每一趟的排序过程？</p> 
<blockquote> 
 <p>冒泡排序思想：从前往后，两两比较，小的往前放。</p> 
 <p>第一趟排序：27 13 <u>49</u> 76 65 38 49 97</p> 
 <p>第二趟排序：13 27 <u>49</u> 65 38 49 76 97</p> 
 <p>第三趟排序：13 27 <u>49</u> 38 49 65 76 97</p> 
 <p>第四趟排序：13 27 38 <u>49</u> 49 65 76 97</p> 
 <p>排序结束，最终结果为{13，27，38，<u>49</u>，49，65，76，97}。</p> 
</blockquote> 
<p>要对{49，38，65，97，76，13，27，49}进行快速排序，给出每一趟的排序过程？</p> 
<blockquote> 
 <p><img alt="" height="755" src="https://images2.imgbox.com/7d/b1/y8yMjbZ0_o.png" width="710"></p> 
</blockquote> 
<p>要对{2，<u>2</u>，3，5，4，1}简单选择排序，给出每一趟的排序过程？</p> 
<blockquote> 
 <p>第一趟：{1，<u>2</u>，3，5，4，2}</p> 
 <p>第二趟：{1，<u>2</u>，3，5，4，2}</p> 
 <p>第三趟：{1，<u>2</u>，2，5，4，3}</p> 
 <p>第四趟：{1，<u>2</u>，2，3，4，5}</p> 
 <p>第五趟：{1，<u>2</u>，2，3，4，5}</p> 
</blockquote> 
<p>判断序列{11，78，35，62，29，56，48，97，80，35}是否为堆，不是堆请调整为堆。</p> 
<blockquote> 
 <p>该序列不是堆，需要调整为堆。</p> 
 <p>调整后的大根堆为{97，80，56，78，35，35，48，62，11，29}</p> 
 <p>小根堆为{11，29，35，62，35，56，48，97，80，78}</p> 
</blockquote> 
<p>给出序列{72，87，61，23，94，16，05，58} 小根堆和大根堆排序序列，并分别给出排序过程。</p> 
<blockquote> 
 <p>大根堆排序序列为：{94，87，61，58，72，16，05，23}</p> 
 <p>第一趟：{72，87，61，58，94，16，05，23}</p> 
 <p>第二趟：{72，87，61，58，94，16，05，23}（这里因为第三个结点符合大根堆所以没动）</p> 
 <p>第三趟：{72，94，61，58，87，16，05，23}</p> 
 <p>第四趟：{94，72，61，58，87，16，05，23}</p> 
 <p>第五趟：{94，87，61，58，72，16，05，23}</p> 
 <p>小根堆排序序列为：{05，23，16，68，94，72，61，87}</p> 
 <p>第一趟：{72，87，61，23，94，16，05，58}</p> 
 <p>第二趟：{72，87，05，23，94，16，61，58}</p> 
 <p>第三趟：{72，23，05，87，94，16，61，58}</p> 
 <p>第四趟：{05，23，72，87，94，16，61，58}</p> 
 <p>第五趟：{05，23，72，58，94，16，61，87}</p> 
 <p>第六趟：{05，23，16，68，94，72，61，87}</p> 
</blockquote> 
<p>已知序列{503，87，512，61，908，170，897，275，653，462}，采用2路归并排序法对该序列做升序时需要几趟排序？给出每一趟的结果。</p> 
<blockquote> 
 <p><img alt="" height="223" src="https://images2.imgbox.com/97/05/IyoBkrLv_o.png" width="851"></p> 
</blockquote> 
<p>设待排序的排序码序列为{12，2，16，30，28，10，16*，20，6，18}，试写出使用基数排序方法每趟排序后的结果，并说明做了多少次排序码的比较。</p> 
<blockquote> 
 <p><img alt="" height="798" src="https://images2.imgbox.com/8c/9b/AxtioXcH_o.png" width="943"></p> 
</blockquote> 
<p>从时间复杂度、空间复杂度、稳定性方面评价各种排序算法？ </p> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/8a/37/ZM4I1pku_o.png"></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/693793e0fb5507767cbd607de61d5020/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio如何修改JDK版本和获知使用的Java版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3faf30028b031354f20df42cbcc3fa01/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于FastAPI构造一个AI模型部署应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>