<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】单元测试覆盖率工具lcov的使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/36fef12873571e7f50bf0f8d3cf995ea/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】单元测试覆盖率工具lcov的使用">
  <meta property="og:description" content="本文首发于 ❄️慕雪的寒舍
本文讲述了如何在C&#43;&#43;代码中使用单元测试覆盖率工具lcov，以及gcov命令的使用。版本是lcov 2.0和gcov 11.4.0。
写在前面：lcov是我在实习期间初次接触到的工具，当时在配置的时候就遇到了大量中文互联网没有任何记录的问题。绝大部分博客对lcov工具的介绍仅停留在安装，并没有对它的使用和报告分析做出更进一步的详解，这也是慕雪撰写本文的原因。希望这篇文章能对需要使用lcov工具却又苦于没有引导教程的老哥提供一丝丝帮助。
1. 安装 安装lcov的方式比较简单，去github上下载官方的安装包就可以了。
# ubuntu安装依赖项 sudo apt-get install -y perl libcapture-tiny-perl libdatetime-perl libdatetime-format-dateparse-perl wget # 下载 wget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz # 解压 tar -zxvf lcov-2.0.tar.gz cd lcov-2.0 # 安装 sudo make install 安装完毕后查看版本号，成功出现版本号则代表安装成功。
❯ lcov --version lcov: LCOV version 2.0-1 更详细的lcov安装教程详见本站【Linux】lcov2.0安装和perl修改镜像源一文。另外，本文演示所用的单元测试框架Gtest也建议安装一下。需要说明的是，lcov的报告并不依赖于Gtest或任何测试框架，只要函数被调用、代码被运行了，它就可以生成覆盖率报告。
2. 基本命令 2.1. 手工执行 lcov的基本使用方式如下：
首先我们需要用g&#43;&#43;命令编译gtest写出来的单元测试代码，使用-lgtest -lgtest_main -pthread链接gtest库和pthread库。选项-ftest-coverage可以让g&#43;&#43;编译器在代码中插入额外的指令，来确认某部分的代码是否执行了，一般要和-fprofile-arcs连用才能产生完整的覆盖率报告。
程序运行后会产生.gcda、.gcov和.gcno文件，记录了覆盖率信息，lcov依赖于这些文件产生最终的html覆盖率报告。
g&#43;&#43; -std=c&#43;&#43;17 test.cpp -o test \ -lgtest -lgtest_main -pthread \ -fprofile-arcs -ftest-coverage -fprofile-update=atomic g&#43;&#43;命令最后的-fprofile-update=atomic是lcov 2.0中需要新增的一个编译选项，否则运行lcov的时候会有告警（具体记不清了，最初的记录里面忘记写这一块的内容了）。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-28T07:12:10+08:00">
    <meta property="article:modified_time" content="2024-08-28T07:12:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】单元测试覆盖率工具lcov的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>本文首发于 <a href="https://blog.musnow.top/posts/2798538265/?f=csdn" rel="nofollow">❄️慕雪的寒舍</a></p> 
</blockquote> 
<p>本文讲述了如何在C++代码中使用单元测试覆盖率工具lcov，以及gcov命令的使用。版本是<code>lcov 2.0</code>和<code>gcov 11.4.0</code>。</p> 
<blockquote> 
 <p>写在前面：lcov是我在实习期间初次接触到的工具，当时在配置的时候就遇到了大量中文互联网没有任何记录的问题。<strong>绝大部分博客对lcov工具的介绍仅停留在安装，并没有对它的使用和报告分析做出更进一步的详解</strong>，这也是慕雪撰写本文的原因。希望这篇文章能对需要使用lcov工具却又苦于没有引导教程的老哥提供一丝丝帮助。</p> 
</blockquote> 
<h3><a id="1__5"></a>1. 安装</h3> 
<p>安装lcov的方式比较简单，去github上下载官方的安装包就可以了。</p> 
<pre><code class="prism language-bash"><span class="token comment"># ubuntu安装依赖项</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> perl libcapture-tiny-perl libdatetime-perl libdatetime-format-dateparse-perl <span class="token function">wget</span>
<span class="token comment"># 下载</span>
<span class="token function">wget</span> https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz
<span class="token comment"># 解压</span>
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> lcov-2.0.tar.gz
<span class="token builtin class-name">cd</span> lcov-2.0
<span class="token comment"># 安装</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<p>安装完毕后查看版本号，成功出现版本号则代表安装成功。</p> 
<pre><code class="prism language-bash">❯ lcov <span class="token parameter variable">--version</span>
lcov: LCOV version <span class="token number">2.0</span>-1
</code></pre> 
<p>更详细的lcov安装教程详见本站<a href="https://blog.musnow.top/posts/1274282021" rel="nofollow">【Linux】lcov2.0安装和perl修改镜像源</a>一文。另外，本文演示所用的单元测试框架<a href="https://blog.musnow.top/posts/852447913" rel="nofollow">Gtest</a>也建议安装一下。需要说明的是，lcov的报告并不依赖于Gtest或任何测试框架，只要函数被调用、代码被运行了，它就可以生成覆盖率报告。</p> 
<h3><a id="2__30"></a>2. 基本命令</h3> 
<h4><a id="21__32"></a>2.1. 手工执行</h4> 
<p>lcov的基本使用方式如下：</p> 
<p>首先我们需要用g++命令编译gtest写出来的单元测试代码，使用<code>-lgtest -lgtest_main -pthread</code>链接gtest库和pthread库。选项<code>-ftest-coverage</code>可以让g++编译器在代码中插入额外的指令，来确认某部分的代码是否执行了，一般要和<code>-fprofile-arcs</code>连用才能产生完整的覆盖率报告。</p> 
<p>程序运行后会产生<code>.gcda</code>、<code>.gcov</code>和<code>.gcno</code>文件，记录了覆盖率信息，lcov依赖于这些文件产生最终的html覆盖率报告。</p> 
<pre><code class="prism language-bash">g++ <span class="token parameter variable">-std</span><span class="token operator">=</span>c++17 test.cpp <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span> <span class="token punctuation">\</span>
	<span class="token parameter variable">-lgtest</span> <span class="token parameter variable">-lgtest_main</span> <span class="token parameter variable">-pthread</span> <span class="token punctuation">\</span>
	-fprofile-arcs -ftest-coverage -fprofile-update<span class="token operator">=</span>atomic
</code></pre> 
<p><code>g++</code>命令最后的<code>-fprofile-update=atomic</code>是lcov 2.0中需要新增的一个编译选项，否则运行lcov的时候会有告警（具体记不清了，最初的记录里面忘记写这一块的内容了）。</p> 
<p>使用如上方式编译了单元测试的代码了之后，就可以执行lcov命令来生成报告了</p> 
<pre><code class="prism language-bash">lcov <span class="token parameter variable">--capture</span> <span class="token punctuation">\</span>
		 <span class="token parameter variable">--rc</span> <span class="token assign-left variable">branch_coverage</span><span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>
		 <span class="token parameter variable">--directory</span> <span class="token builtin class-name">.</span> <span class="token punctuation">\</span>
		 --output-file coverage.info <span class="token punctuation">\</span>
		 --ignore-errors mismatch
</code></pre> 
<p>这个命令最终会生成一个<code>coverage.info</code>信息文件。其中<code>--rc branch_coverage=1</code>是用于开启分支检测的，不指定这个选项，输出的文件中将不包含<strong>分支覆盖率</strong>信息，只会有行覆盖率信息。选项<code>--ignore-errors mismatch</code>是因为lcov 2.0版本出现了一些问题，经常会找不到某些函数的符号表（不知道啥情况，lcov 1.6没有此告警），会有mismatch错误，需要将其忽略。</p> 
<p>生成了<code>coverage.info</code>文件之后，再使用genhtml命令将其转化为最终的html报告，输出到<code>coverage_report</code>目录中。</p> 
<pre><code class="prism language-bash">genhtml coverage.info <span class="token punctuation">\</span>
			<span class="token parameter variable">--rc</span> <span class="token assign-left variable">branch_coverage</span><span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>
			--output-directory coverage_report
</code></pre> 
<p>一切顺利的话，执行了这些命令，你就可以在当前目录下的<code>coverage_report</code>子目录中找到lcov的html报告了。</p> 
<h4><a id="22_makefile_70"></a>2.2. makefile</h4> 
<p>我们可以把上述命令写入一个makefile中，这样可以方便我们执行命令。更新了测试源码之后，使用<code>make locv</code>就可以生成最新的覆盖率报告。</p> 
<pre><code class="prism language-makefile">test:test.cpp
	g++ -std=c++17 test.cpp -o test -lgtest -lgtest_main -pthread -fprofile-arcs -ftest-coverage -fprofile-update=atomic

lcov:test.cpp
	g++ -std=c++17 test.cpp -o test -lgtest -lgtest_main -pthread -fprofile-arcs -ftest-coverage -fprofile-update=atomic &amp;&amp; \
	./test &amp;&amp; \
	gcov -b -c -o . test.cpp &amp;&amp; \
	lcov --capture \
		 --rc branch_coverage=1 \
		 --directory . \
		 --output-file coverage_all.info \
		 --ignore-errors mismatch &amp;&amp; \
	genhtml coverage.info \
			--rc branch_coverage=1 \
			--ignore-errors mismatch \
			--output-directory coverage_report &amp;&amp; \
	rm *.info

.PHONY:cl
cl:
	sudo rm -rf test *.gcno *.gcda *.gcov out
</code></pre> 
<h3><a id="3_Demo_98"></a>3. Demo演示</h3> 
<h4><a id="31_demo_100"></a>3.1. 基本demo</h4> 
<p>下面是一个最简单的C++代码，以及对应的测试处理，首先在<code>main.hpp</code>里面定义了一个最基础的相减函数</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 相减函数</span>
<span class="token keyword">int</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>随后，在test.cpp中引用这个头文件并调用Sub函数</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;gtest/gtest.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"main.hpp"</span></span>

<span class="token function">TEST</span><span class="token punctuation">(</span>SubTest<span class="token punctuation">,</span> SubTest1<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 期望 result 等于 1</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token double-colon punctuation">::</span>testing<span class="token double-colon punctuation">::</span><span class="token function">InitGoogleTest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">RUN_ALL_TESTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用上文提到的命令，编译和创建lcov报告。在lcov命令的最后输出中，会包含如下覆盖率信息</p> 
<pre><code>Overall coverage rate:
  lines......: 50.3% (83 of 165 lines)
  functions......: 46.3% (44 of 95 functions)
  branches......: 42.9% (24 of 56 branches)
</code></pre> 
<p>因为我用的是WSL2，可以方便的直接打开报告生成目录，查看<code>index.html</code>文件。</p> 
<p><img src="https://images2.imgbox.com/25/60/oXyNc5CA_o.png" alt="image.png"></p> 
<p>可以看到，报告中列出了所有涉及到的文件，以及这些文件的行覆盖率，分支覆盖率，执行次数。</p> 
<p><img src="https://images2.imgbox.com/06/87/mYvryMwJ_o.png" alt="image.png"></p> 
<p>但是！这里面有大量C++库函数以及gtest库的代码，我们自己的代码反而被掩盖过去了，这肯定不是我们想要的结果。毕竟不是自己写的代码都不需要测试覆盖率。所以我们需要做点操作，屏蔽掉所有库函数的报告。</p> 
<p>将上文的lcov命令的最终输出文件改成<code>coverage_all.info</code></p> 
<pre><code class="prism language-bash">lcov <span class="token parameter variable">--capture</span> <span class="token punctuation">\</span>
		 <span class="token parameter variable">--rc</span> <span class="token assign-left variable">branch_coverage</span><span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>
		 <span class="token parameter variable">--directory</span> <span class="token builtin class-name">.</span> <span class="token punctuation">\</span>
		 --output-file coverage_all.info <span class="token punctuation">\</span>
		 --ignore-errors mismatch
</code></pre> 
<p>然后在genhtml命令<strong>之前</strong>，执行如下命令。这个命令会处理原本生成的全量数据，把里面我们不想要的东西全都删除掉，再生成一个<code>coverage.info</code>文件。</p> 
<pre><code class="prism language-bash">lcov <span class="token parameter variable">--remove</span> coverage_all.info <span class="token punctuation">\</span>
	<span class="token string">'*/usr/include/*'</span> <span class="token string">'*/usr/lib/*'</span> <span class="token string">'*/usr/lib64/*'</span> <span class="token punctuation">\</span>
	<span class="token string">'*/usr/local/include/*'</span> <span class="token string">'*/usr/local/lib/*'</span> <span class="token string">'*/usr/local/lib64/*'</span> <span class="token punctuation">\</span>
	<span class="token parameter variable">--rc</span> <span class="token assign-left variable">branch_coverage</span><span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>
	--output-file coverage.info <span class="token punctuation">\</span>
	--ignore-errors unused <span class="token punctuation">\</span>
	--ignore-errors mismatch 
</code></pre> 
<p>随后再执行genhtml命令，这一次生成的报告文件就只有我们自己的代码了。</p> 
<pre><code class="prism language-bash">genhtml coverage.info <span class="token punctuation">\</span>
			<span class="token parameter variable">--rc</span> <span class="token assign-left variable">branch_coverage</span><span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>
			--output-directory coverage_report
</code></pre> 
<p><img src="https://images2.imgbox.com/69/84/dPbAqje7_o.png" alt="image.png"></p> 
<p>进入报告中看，其实这里还是有一个需要排除的项目的，即<code>test.cpp</code>是单元测试的文件，我们也不需要关注单元测试这个文件本身的覆盖率正常不，当前我们只需要关注<code>main.hpp</code>这个功能源码文件的覆盖率。</p> 
<blockquote> 
 <p>可以将<code>test.cpp</code>也写入上文的<code>--remove</code>选项之后，这样它也会被过滤掉。实际项目中，直接过滤单元测试代码文件的目录即可。</p> 
</blockquote> 
<p>另外，使用这个命令，lcov会在输出中报告没有被匹配上的地址，可以用<code>--ignore-errors unused</code>来屏蔽这个告警。</p> 
<pre><code>lcov: WARNING: ('unused') 'exclude' pattern '*/usr/lib/*' is unused.
lcov: WARNING: ('unused') 'exclude' pattern '*/usr/lib64/*' is unused.
        (use "lcov --ignore-errors unused,unused ..." to suppress this warning)
lcov: WARNING: ('unused') 'exclude' pattern '*/usr/local/lib/*' is unused.
        (use "lcov --ignore-errors unused,unused ..." to suppress this warning)
lcov: WARNING: ('unused') 'exclude' pattern '*/usr/local/lib64/*' is unused.
        (use "lcov --ignore-errors unused,unused ..." to suppress this warning)
</code></pre> 
<h4><a id="32__202"></a>3.2. 报告基本分析</h4> 
<p><img src="https://images2.imgbox.com/ec/78/EmTterHB_o.png" alt="image.png"></p> 
<p>点开main.hpp文件，可以看到如下报告。其中右上角是当前文件的覆盖率信息，然后会展示文件的源码：</p> 
<ul><li>源码每一行之前的数字是这一行被运行了几次；</li><li>底色为<strong>橙色</strong>标注的，就是没有被覆盖的行；</li><li>蓝色标注的，则是被覆盖了的行；</li></ul> 
<p>在每一个if语句的分支点，也会产生一个<code>分支覆盖率</code>报告，这里显示的<code>[+,-]</code>代表if条件为true的分支被命中了，为false的分支没有命中。在测试代码中我使用的是<code>Sub(3, 2)</code>来调用该函数，参数a是大于b的（命中true分支），也和这里的分支覆盖报告相符。</p> 
<p><img src="https://images2.imgbox.com/2d/8d/qFlCrvRB_o.png" alt="image.png"></p> 
<p>这样我们就可以知道，当前需要怎么补充测试用例了。我们需要补充一个b比a大或者相等的测试用例，追加如下测试调用。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;gtest/gtest.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"main.hpp"</span></span>

<span class="token function">TEST</span><span class="token punctuation">(</span>SubTest<span class="token punctuation">,</span> SubTest1<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 期望 result 等于 1</span>
    <span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 期望 result 等于 2</span>
    <span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 期望 result 等于 0</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token double-colon punctuation">::</span>testing<span class="token double-colon punctuation">::</span><span class="token function">InitGoogleTest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">RUN_ALL_TESTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>再次编译执行，重新查看报告。此时可以看到，我们的main.hpp已经实现了100%的覆盖。</p> 
<p><img src="https://images2.imgbox.com/5c/bc/6qEbTmti_o.png" alt="image.png"></p> 
<p>删除其他测试，留一个b比a大的测试用例。此时可以看到，分支覆盖显示为<code>[-,+]</code>，代表我们当前分支的false条件被命中了，但是true条件没有。</p> 
<p><img src="https://images2.imgbox.com/c8/d6/3qRuXxYN_o.png" alt="image.png"></p> 
<p>简单总结，单个分支覆盖率中<code>[]</code>的逗号左侧是true，右侧是false；<code>+</code>代表覆盖，<code>-</code>代表没有覆盖，<code>#</code>代表这个分支没有被执行。</p> 
<h4><a id="33__246"></a>3.3. 多条件判断</h4> 
<p>上面的if语句中我们只写了一个判断条件，实际场景中判断条件不止一个的情况还是经常出现的，给Sub函数新增一个参数，再来进行测试。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdbool&gt;</span></span>
<span class="token comment">// 相减函数，默认是A-B，第三个参数为是否要返回绝对值</span>
<span class="token keyword">int</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">bool</span> isAbs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> a <span class="token operator">&amp;&amp;</span> isAbs<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试用例如下</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;gtest/gtest.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"main.hpp"</span></span>

<span class="token function">TEST</span><span class="token punctuation">(</span>SubTest<span class="token punctuation">,</span> SubTest1<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 传入false代表我们想a-b，不需要绝对值</span>
    <span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 期望 result 等于 -2</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token double-colon punctuation">::</span>testing<span class="token double-colon punctuation">::</span><span class="token function">InitGoogleTest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">RUN_ALL_TESTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里可以看到，在if语句左侧的分支覆盖率条件的<code>[]</code>里面多了一对加减，这里多的就是isAbs这个判断条件，分支覆盖率中的每一个判断条件都有一个true/false分支，两两一对，从左到右的顺序和我们的判断条件中的条件顺序是一致的。</p> 
<p>在上面的测试用例中，我们传入了b大于a的值，同时isAbs是false，命中了<code>b &gt; a</code>为true的分支，和isAbs为false的分支。</p> 
<p><img src="https://images2.imgbox.com/df/0e/I9nmQVJd_o.png" alt="image.png"></p> 
<p>新增一个测试用例，这一次命中的是isAbs为true的分支。</p> 
<pre><code class="prism language-cpp">	<span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>报告中，isAbs为true的分支也变成了<code>+</code>代表已命中，符合预期。</p> 
<p><img src="https://images2.imgbox.com/00/f8/nK5wo6kz_o.png" alt="image.png"></p> 
<p>再添加一个a比b大的测试用例，即可将该函数的所有分支覆盖完毕。</p> 
<pre><code>	EXPECT_EQ(Sub(6, 4, true), 2);
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/94/uc9yT4j0_o.png" alt="image.png"></p> 
<h3><a id="4_gcov_307"></a>4. 引入gcov命令</h3> 
<h4><a id="41__309"></a>4.1. 基本使用</h4> 
<p>接下来给大家引入gcov命令的使用，gcov命令可以生成更加详细的关于某个分支为什么没有被覆盖的说明。比如未覆盖的异常分支在生成的<code>源文件.gcov</code>文件中就会显示出来。</p> 
<p>gcov命令和gcc/g++是同源的，只要你的系统上安装了gcc，那就会有gcov命令。二者的版本号输出都是一致的。</p> 
<pre><code>❯ gcov --version          
gcov (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    
❯ gcc --version 
gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre> 
<p>执行过lcov命令后，在构建目录下会产生很多的<code>.gcov</code>文件，和我们自己的代码的<code>.gcda</code>文件</p> 
<pre><code class="prism language-bash">❯ <span class="token function">ls</span>
alloc_traits.h.gcov    gtest-assertion-result.h.gcov  main.hpp              stl_iterator_base_funcs.h.gcov  test.gcda
basic_string.h.gcov    gtest.h.gcov                   main.hpp.gcov         stl_iterator_base_types.h.gcov  test.gcno
basic_string.tcc.gcov  gtest-internal.h.gcov          makefile              <span class="token builtin class-name">test</span>                            tuple.gcov
char_traits.h.gcov     gtest-port.h.gcov              move.h.gcov           test.cpp                        type_traits.h.gcov
coverage_report        gtest-printers.h.gcov          new_allocator.h.gcov  test.cpp.gcov                   unique_ptr.h.gcov
</code></pre> 
<p>我们可以使用gcov命令，把这些文件文件转换成可读报告。</p> 
<pre><code class="prism language-bash">gcov <span class="token parameter variable">-b</span> <span class="token parameter variable">-c</span> <span class="token parameter variable">-o</span> .gcda文件所在路径 cpp源文件路径
</code></pre> 
<p>比如这里我们要处理的是<code>test.gcda</code>，命令如下。</p> 
<pre><code class="prism language-bash">gcov <span class="token parameter variable">-b</span> <span class="token parameter variable">-c</span> <span class="token parameter variable">-o</span> <span class="token builtin class-name">.</span> test.cpp
</code></pre> 
<p>这个命令会生成一个<code>源文件名.gcov</code>文件，文件中就会有详细的文字说明了。比如<code>main.hpp.gcov</code>文件中的描述如下，有每一个分支被命中的次数，后面有个括号是这个分支的说明。</p> 
<p>文件中第一列的<code>-:</code>代表这一行不统计命中次数，第一列<code>数字:</code>代表这一行被执行的次数（注意要和第二列的代码行号区分开）。</p> 
<pre><code>        -:    0:Source:main.hpp
        -:    0:Graph:./test.gcno
        -:    0:Data:./test.gcda
        -:    0:Runs:1
        -:    1:#include &lt;cstdbool&gt;
        -:    2:// 相减函数，默认是A-B，第三个参数为是否要返回绝对值
function _Z3Subiib called 3 returned 100% blocks executed 100%
        3:    3:int Sub(int a, int b, bool isAbs)
        -:    4:{
        3:    5:    if (b &gt; a &amp;&amp; isAbs)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        -:    6:    {
        1:    7:        return b - a;
        -:    8:    }
        2:    9:    return a - b;
        -:   10:}
</code></pre> 
<p>文件中的<code>(fallthrough)</code>代表当前if分支被跳过。比如下面的代码中，fallthrough的意思就是当<strong>a不等于b</strong>的时候，分支A会被跳过，走到分支B中。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">// A</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// B</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的例子中，当b小于等于a或者isAbs为假的时候，<code>return b - a;</code>就会被跳过，落到<code>return a - b;</code>分支中。</p> 
<p>这里将isAbs改成一个函数调用，函数本身参数不变</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdbool&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;exception&gt;</span></span>

<span class="token keyword">bool</span> <span class="token function">isAbsFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">bool</span> isAbs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 当a为100的时候抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"a should not be 100."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> isAbs<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 相减函数，默认是A-B，第三个参数为是否要返回绝对值</span>
<span class="token keyword">int</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">bool</span> isAbs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&gt;</span> a <span class="token operator">&amp;&amp;</span> <span class="token function">isAbsFunc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> isAbs<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此时分支覆盖率报告如下。因为我们当前的a并不等于100，所以一直命中的都是<code>a == 100</code>为false的分支，符合预期。但是这里会有一个额外的分支未覆盖情况，即throw这一行也出现了一个分支，且<code>[]</code>里面的两个符号都是<code>#</code>，<strong>代表这一行没有被运行</strong>。</p> 
<p><img src="https://images2.imgbox.com/25/7a/kjEuL3Lg_o.png" alt="image.png"></p> 
<p>我们可以用gcov命令来看看throw这一行的分支覆盖情况。可以看到这里提示<code>never executed</code>，没有运行。</p> 
<pre><code class="prism language-gcov">        -:    0:Source:main.hpp
        -:    0:Graph:./test.gcno
        -:    0:Data:./test.gcda
        -:    0:Runs:1
        -:    1:#include &lt;cstdbool&gt;
        -:    2:#include &lt;exception&gt;
        -:    3:
function _Z9isAbsFunciib called 2 returned 100% blocks executed 50%
        2:    4:bool isAbsFunc(int a, int b, bool isAbs)
        -:    5:{
        -:    6:    // 当a为100的时候抛出异常
        2:    7:    if (a == 100)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:    8:    {
    #####:    9:        throw std::invalid_argument("a should not be 100.");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -:   10:    }
        2:   11:    return isAbs;
        -:   12:}
        -:   13:
        -:   14:// 相减函数，默认是A-B，第三个参数为是否要返回绝对值
function _Z3Subiib called 3 returned 100% blocks executed 100%
        3:   15:int Sub(int a, int b, bool isAbs)
        -:   16:{
        3:   17:    if (b &gt; a &amp;&amp; isAbsFunc(a, b, isAbs))
branch  0 taken 2 (fallthrough)
branch  1 taken 1
call    2 returned 2
branch  3 taken 1 (fallthrough)
branch  4 taken 1
branch  5 taken 1 (fallthrough)
branch  6 taken 2
        -:   18:    {
        1:   19:        return b - a;
        -:   20:    }
        2:   21:    return a - b;
        -:   22:}

</code></pre> 
<p>那我们加一个a等于100的测试用例呢？</p> 
<pre><code class="prism language-cpp">    <span class="token comment">// 期望抛出异常</span>
    <span class="token function">EXPECT_ANY_THROW</span><span class="token punctuation">(</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此时gcov文件会是如下模样，我们<code>a == 100</code>的两个分支都命中了，但是你会发现，它有一个<code>branch 3 taken 0 (throw)</code>为0次命中，没有被覆盖上。</p> 
<pre><code class="prism language-gcov">function _Z9isAbsFunciib called 3 returned 67% blocks executed 88%
        3:    4:bool isAbsFunc(int a, int b, bool isAbs)
        -:    5:{
        -:    6:    // 当a为100的时候抛出异常
        3:    7:    if (a == 100)
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        -:    8:    {
        1:    9:        throw std::invalid_argument("a should not be 100.");
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
call    4 returned 0
call    5 never executed
        -:   10:    }
        2:   11:    return isAbs;
        -:   12:}
</code></pre> 
<p>在lcov报告中也是如此，会显示有一个没有覆盖的<code>(throw)</code>抛异常分支。</p> 
<p><img src="https://images2.imgbox.com/a0/56/Ufw9RbM7_o.png" alt="image.png"></p> 
<h4><a id="42_lcovstd_503"></a>4.2. lcov过滤std库函数造成的分支</h4> 
<p>这就涉及到lcov的一个不那么容易找到的设置了，当时百度了老久，最后还是去Github翻issue才得到的答案。下面贴出几个相关的issue</p> 
<ul><li><a href="https://github.com/linux-test-project/lcov/issues/101">https://github.com/linux-test-project/lcov/issues/101</a>；</li><li><a href="https://github.com/linux-test-project/lcov/issues/108">https://github.com/linux-test-project/lcov/issues/108</a>；</li><li><a href="https://github.com/linux-test-project/lcov/issues/75">https://github.com/linux-test-project/lcov/issues/75</a>；</li></ul> 
<p>简而言之，lcov支持过滤掉这类由<strong>std库</strong>造成的无法覆盖的异常分支。只需要在lcov命令和genhtml命令中加上<code>--filter branch</code>选项即可。添加了这个命令后，可以看到throw这一行的分支被过滤不显示了。</p> 
<p><img src="https://images2.imgbox.com/d0/37/IAk8WUmg_o.png" alt="image.png"></p> 
<p>即便我们没有命中<code>a == 100</code>的情况，throw这一行也不会出现<code>[##]</code>的未命中分支。</p> 
<p><img src="https://images2.imgbox.com/da/33/oMOChS8D_o.png" alt="image.png"></p> 
<p>再举个map的emplace的例子，代码如下</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">EmplaceMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> mapValue<span class="token punctuation">;</span>
    mapValue<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试代码</p> 
<pre><code class="prism language-cpp"><span class="token function">TEST</span><span class="token punctuation">(</span>EmplaceMapTest<span class="token punctuation">,</span>EmplaceMapTest1<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">EXPECT_NO_THROW</span><span class="token punctuation">(</span><span class="token function">EmplaceMap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">EXPECT_NO_THROW</span><span class="token punctuation">(</span><span class="token function">EmplaceMap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，如果不加上<code>--filter branch</code>过滤选项，在lcov报告中，即便这一行是完全不存在任何分支的，也会出现一个未覆盖的情况。</p> 
<p><img src="https://images2.imgbox.com/b6/4a/F2CPHmZx_o.png" alt="image.png"></p> 
<p>生成的gcov文件如下，这里会有一个不知道什么由来的branch 4没有被覆盖到。</p> 
<pre><code class="prism language-gcov">function _Z10EmplaceMapii called 2 returned 100% blocks executed 100%
        2:    6:void EmplaceMap(int key, int value)
        -:    7:{
        2:    8:    static std::map&lt;int, std::set&lt;int&gt;&gt; mapValue;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0
call    5 returned 1
call    6 returned 1
call    7 returned 1
        2:    9:    mapValue[key].emplace(value);
call    0 returned 2
call    1 returned 2
        2:   10:}
        -:   11:
</code></pre> 
<p>加上了<code>--filter branch</code>过滤选项之后，这一行则完全不会有分支覆盖率信息。这才是我们预期的输出，因为我们不应该关注不是我们自己写的代码（比如std库和第三方库）中的分支。</p> 
<p><img src="https://images2.imgbox.com/8e/26/4MxDvYUB_o.png" alt="image.png"></p> 
<p>另外，过滤选项默认只对常见的cpp头文件起效。对诸如<code>.inl</code>这种头文件是不起效果的。可以使用如下命令，修改默认的<code>c_file_extensions</code>后缀名配置，添加你需要的文件后缀。</p> 
<pre><code class="prism language-bash"><span class="token parameter variable">--rc</span> <span class="token assign-left variable">c_file_extensions</span><span class="token operator">=</span>c,cpp,hpp,h,inl
</code></pre> 
<p>关联issue：<a href="https://github.com/linux-test-project/lcov/issues/250">https://github.com/linux-test-project/lcov/issues/250</a>。</p> 
<h3><a id="5_lcov_578"></a>5. 一些lcov报告问题的记录</h3> 
<p>经过上面的步骤，想必你已经知道怎么去使用lcov了。下面是我在使用lcov过程中遇到的一些报告的共性问题，记录于此，经供参考。</p> 
<h4><a id="51_lcov_582"></a>5.1. lcov屏蔽语法</h4> 
<p>lcov本身也支持通过在代码中添加注释的方式来屏蔽一些代码的覆盖率检测。屏蔽的语法分为单行代码和多行屏蔽。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// LCOV_EXCL_BR_START</span>
   多行代码
<span class="token comment">// LCOV_EXCL_BR_STOP</span>

单行代码 <span class="token comment">// LCOV_EXCL_BR_LINE</span>
</code></pre> 
<p>在实际代码中，<strong>可能会有一些linux库函数调用这类难以复现失败场景</strong>的函数调用，又没有办法被过滤掉的分支。这种情况就可以在注明原因以后，使用lcov的屏蔽注释将其屏蔽掉，让最终生成的报告里面没有这些难以覆盖的错误情况。</p> 
<h4><a id="52_assert_596"></a>5.2. assert假分支无法覆盖</h4> 
<p>如下图所示，lcov的assert始终只会覆盖假的分支，因为分支为真的时候就直接程序终止了。</p> 
<p><img src="https://images2.imgbox.com/38/4d/UFXJUx0Q_o.png" alt="image.png"></p> 
<p>Gtest中有一个<code>EXPECT_DEATH</code>可以用来测试assert为真的情况，但即便使用了这个宏，lcov和gcov依旧无法生成命中的报告。所以，推荐的做法是在编译<strong>单元测试代码</strong>的时候使用<code>-DNDEBUG</code>宏直接禁用所有assert，这样就不会有关于assert的分支覆盖率报告了。</p> 
<h4><a id="53_trylock_604"></a>5.3. trylock分支覆盖</h4> 
<p>一般情况下，在我们的测试场景中不太好复现<code>try_lock()</code>函数调用失败的分支，这需要有一个多线程的场景，但多线程操作共享资源的运行顺序本身就是不可预知的，不太好在单元测试中构建出一个一定冲突的场景来。</p> 
<p><img src="https://images2.imgbox.com/67/45/DIwStRTm_o.png" alt="image.png"></p> 
<p>这时候可以用一种黑魔法，在单元测试中，<strong>取出类的私有成员变量mutex</strong>，将其lock了之后，再去调用包含<code>try_lock()</code>调用和判断的函数。函数调用完毕后，再unlock解锁。</p> 
<p>如下是这个黑魔法的源码和使用示例，注意只有g++使用<code>-std=c++17</code>之后才支持编译这个代码。在windows的vs2019下这个特性是编译不过的，即便设置了C++17也不行，可能是我的配置不对。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token comment">// C++17才支持，通过友元和元组，取出任意成员变量</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">auto</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Member<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">StealMember</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">friend</span> <span class="token keyword">auto</span> <span class="token function">StealClass</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span>Member<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用示例：</span>
<span class="token comment">// // 1.友元函数声明，TestClass是我们需要操作的目标类。</span>
<span class="token keyword">auto</span> <span class="token function">StealClass</span><span class="token punctuation">(</span>TestClass <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// // 2.在下面的模板中添加需要的私有函数或成员。</span>
<span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">StealMember</span><span class="token operator">&lt;</span>TestClass<span class="token punctuation">,</span>
                         <span class="token operator">&amp;</span>TestClass<span class="token double-colon punctuation">::</span>GetA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TestClass<span class="token double-colon punctuation">::</span>_a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TestClass<span class="token double-colon punctuation">::</span>_b<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// // 3.在需要的函数中使用如下方式取成员变量。</span>
<span class="token keyword">void</span> <span class="token function">TestFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	TestClass <span class="token function">t1</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">300.23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> tp <span class="token operator">=</span> <span class="token function">StealClass</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构建元组</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"GetA: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"_a:   "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个代码首先声明了友元函数，StealClass会被声明成TestClass的友元函数，从而可以读取到该类的私有成员。随后在实例化StealMember模板的时候，指定了目标类和其私有成员，这样StealClass函数就可以在调用的时候，给我们返回一个包含私有成员指针的<strong>元组</strong>。</p> 
<blockquote> 
 <p>重点来了：C++在实例化模板的时候，不会去检查成员的访问限定符。</p> 
</blockquote> 
<p>有了元组，就可以用<code>std::get&lt;元组内元素下标&gt;(元组对象)</code>的方式取出元组的某一个成员，即私有成员的指针。有了私有成员的指针之后，我们就可以使用<code>对象.(*私有成员指针)</code>的方式访问到一个私有成员变量或者成员函数了。</p> 
<p>关于这个特性的更多介绍，可以参考下面的资料</p> 
<ul><li><a href="https://www.bilibili.com/video/BV11x4y1i7ed/" rel="nofollow">【C++】C++私有成员劫持技巧-哔哩哔哩</a>;</li><li><a href="https://mp.weixin.qq.com/s/hTKOBFLmwPoBD7_o7QYlRw" rel="nofollow">访问私有成员——从技术实现的角度破坏"封装" 性</a>;</li></ul> 
<p>咋样，是不是很“黑魔法”呢？</p> 
<h4><a id="54_string_654"></a>5.4. string相加的时候会有大量无法覆盖的异常分支</h4> 
<p>如下图所示，这个函数中调用了string的相加操作，造成了大量的没有覆盖的异常分支。</p> 
<p><img src="https://images2.imgbox.com/2c/a0/hWgOBdAQ_o.png" alt="image.png"></p> 
<p>在gcov报告中可以更详细的看到没有被覆盖的分支都是什么，大多都是和<code>throw</code>有关的。</p> 
<pre><code class="prism language-gcov">function _Z16test_string_plusRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_ called 2 returned 100% blocks executed 69%
        2:   48:void test_string_plus(const string&amp; local ,const string&amp; remote)
        -:   49:{
        2:   50:    static string recv_msg;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0
call    5 returned 1
call    6 returned 1
call    7 returned 1
        2:   51:    static_cast&lt;void&gt;(recv_msg.assign("/" + (local &lt; remote ? local + "_" + remote : remote + "_" + local)));
call    0 returned 2
branch  1 taken 1 (fallthrough)
branch  2 taken 1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 1
branch  7 taken 1 (fallthrough)
branch  8 taken 0 (throw)
call    9 returned 1
branch 10 taken 1 (fallthrough)
branch 11 taken 0 (throw)
call   12 returned 1
branch 13 taken 1 (fallthrough)
branch 14 taken 0 (throw)
call   15 returned 2
branch 16 taken 2 (fallthrough)
branch 17 taken 0 (throw)
call   18 returned 2
call   19 returned 2
call   20 returned 2
branch 21 taken 1 (fallthrough)
branch 22 taken 1
call   23 returned 1
branch 24 taken 1 (fallthrough)
branch 25 taken 1
call   26 returned 1
call   27 never executed
branch 28 never executed
branch 29 never executed
call   30 never executed
branch 31 never executed
branch 32 never executed
call   33 never executed
        2:   52:}
</code></pre> 
<p>可当前我已经添加了过滤命令了，为什么没有生效呢？</p> 
<p>实际上，将上面的代码改成下面的if/else逻辑，就不会有这么多的异常分支了。</p> 
<p><img src="https://images2.imgbox.com/b7/20/mVDlBO5j_o.png" alt="image.png"></p> 
<p>这是我的猜想：lcov的过滤命令在检测到某一行中有用户定义的判断条件<code>local &lt; remote</code>的时候就会失效，<strong>因为可能会错误过滤掉用户自己的分支</strong>。与其错报一万不可少报一个，于是就把所有的异常分支都展现出来了。</p> 
<p>将<strong>三目运算符</strong>改成if/else了之后，用户定义的判断条件和string的相加操作隔离开了，就能正常进行过滤了。所以，在编写优化分支覆盖率的代码的时候，可以考虑将</p> 
<h3><a id="6_The_end_723"></a>6. The end</h3> 
<p>其实在最开始的时候我记录了更多lcov相关的错误，但大部分错误都可以使用<code>--filter branch</code>选项过滤掉，且有一部分错误在我当前的环境中并没有被复现出来，故此不记录于本文中。</p> 
<p>如果你遇到了本文没有记录的问题，欢迎在评论区留言交流。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92df7c52be1749001814d85d2db96c60/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据仓库系列10：如何处理维度表中的变化类型?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d14161535bf4ddc1dbb0178c06952c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python知识点：如何使用Elasticsearch与Elasticsearch-py进行全文检索</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>