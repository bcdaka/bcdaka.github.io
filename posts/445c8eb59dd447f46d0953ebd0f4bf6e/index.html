<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端React篇之哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/445c8eb59dd447f46d0953ebd0f4bf6e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端React篇之哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？">
  <meta property="og:description" content="目录 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？setState()案例需求总结 forceUpdate()案例需求总结 props改变案例需求总结 context改变案例需求总结 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？ 在React中，以下方法会触发重新渲染：
setState()：当调用组件的setState方法并传入新的状态值时，React会触发重新渲染。forceUpdate()：可以强制组件重新渲染，不管组件的状态是否发生变化。props改变：当组件接收到新的props时，它会进行重新渲染。context改变：如果使用了context API，在context值发生变化时，会触发依赖于该context的组件重新渲染。 当React组件重新渲染时，render方法会执行以下操作：
比较虚拟DOM：React会比较前后两次渲染生成的虚拟DOM树，找出差异。计算需要更新的部分：React会确定哪些部分需要进行实际的DOM更新。应用更新：React将只更新需要更改的部分，而不是整个DOM树。这种优化称为“协调”（Reconciliation）。调用生命周期方法：如果有需要，React会调用相应的生命周期方法，如componentDidUpdate，以便进行一些额外的操作。 总的来说，重新渲染过程包括对比虚拟DOM、计算更新部分以及应用更新，以确保只有必要的部分会被实际更新，从而提高性能和效率。
setState() setState是React组件中用于更新状态的方法。当调用setState并传入新的状态值时，React会自动比较新旧状态的差异，并执行相应的更新操作。
在实际工作项目中，setState通常用于处理以下需求：
用户交互：当用户与页面进行交互时，组件的状态可能需要更新，如表单输入、按钮点击等。
数据获取和异步操作：当组件依赖的数据发生变化或进行异步操作后返回新的数据时，可以通过setState更新组件的状态，从而触发重新渲染。
条件渲染：通过更新组件的状态，可以实现条件渲染，根据不同的状态值显示不同的内容。
案例需求 假设我们有一个计数器组件，点击按钮后计数器的值会递增。需要实现以下功能：
初始计数器的值为0。点击按钮后，计数器的值加1。将计数器的值显示在页面上。 import React, { useState } from &#39;react&#39; function App() { const [count, setCount] = useState(0) const increment = () =&gt; { setCount(count &#43; 1) } return ( &lt;div&gt; &lt;h1&gt;Counter: {count}&lt;/h1&gt; &lt;button onClick={increment}&gt;增加&lt;/button&gt; &lt;/div&gt; ) } export default App 首先，使用React的useState钩子函数声明一个名为count的状态变量，并将其初始值设置为0。创建一个名为increment的函数，当按钮被点击时，这个函数会在当前计数的基础上加1，并通过调用setCount来更新计数器的值。在组件的返回值中，将计数器的值以文本形式显示在页面上，并将increment函数作为按钮的点击事件处理函数。 在调用setState方法时，传入的新状态不会立即生效，而是在下一次React的重新渲染过程中才会生效。React会使用新的状态值重新渲染组件，并只更新需要更新的部分，以提升性能。setState方法可以接受一个对象或一个函数作为参数。当传入一个函数时，React会将当前状态作为参数传递给这个函数，函数返回的结果将作为新的状态值。在使用函数更新状态时，应该使用回调函数的形式确保获取到最新的状态值。例如：setCount(prevCount =&gt; prevCount &#43; 1)。 总结 在React中，setState方法用于更新组件的状态，并触发重新渲染。通过setState方法，我们可以根据不同的需求更新组件的状态，使得页面能够及时显示最新的数据和交互效果。在使用setState时，需要注意更新状态的方式和时机，以及遵循React的一些规范和最佳实践，以保证代码的可读性、性能和可靠性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-08T07:45:00+08:00">
    <meta property="article:modified_time" content="2024-03-08T07:45:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端React篇之哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_React__render__3" rel="nofollow">哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</a></li><li><ul><li><a href="#setState_20" rel="nofollow">setState()</a></li><li><ul><li><a href="#_31" rel="nofollow">案例需求</a></li><li><a href="#_68" rel="nofollow">总结</a></li></ul> 
   </li><li><a href="#forceUpdate_70" rel="nofollow">forceUpdate()</a></li><li><ul><li><a href="#_78" rel="nofollow">案例需求</a></li><li><a href="#_119" rel="nofollow">总结</a></li></ul> 
   </li><li><a href="#props_121" rel="nofollow">props改变</a></li><li><ul><li><a href="#_127" rel="nofollow">案例需求</a></li><li><a href="#_188" rel="nofollow">总结</a></li></ul> 
   </li><li><a href="#context_192" rel="nofollow">context改变</a></li><li><ul><li><a href="#_197" rel="nofollow">案例需求</a></li><li><a href="#_244" rel="nofollow">总结</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_React__render__3"></a>哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h2> 
<p>在React中，以下方法会触发重新渲染：</p> 
<ol><li><strong>setState()</strong>：当调用组件的setState方法并传入新的状态值时，React会触发重新渲染。</li><li><strong>forceUpdate()</strong>：可以强制组件重新渲染，不管组件的状态是否发生变化。</li><li><strong>props改变</strong>：当组件接收到新的props时，它会进行重新渲染。</li><li><strong>context改变</strong>：如果使用了context API，在context值发生变化时，会触发依赖于该context的组件重新渲染。</li></ol> 
<p>当React组件重新渲染时，<code>render</code>方法会执行以下操作：</p> 
<ol><li><strong>比较虚拟DOM</strong>：React会比较前后两次渲染生成的虚拟DOM树，找出差异。</li><li><strong>计算需要更新的部分</strong>：React会确定哪些部分需要进行实际的DOM更新。</li><li><strong>应用更新</strong>：React将只更新需要更改的部分，而不是整个DOM树。这种优化称为“协调”（Reconciliation）。</li><li><strong>调用生命周期方法</strong>：如果有需要，React会调用相应的生命周期方法，如componentDidUpdate，以便进行一些额外的操作。</li></ol> 
<p>总的来说，重新渲染过程包括对比虚拟DOM、计算更新部分以及应用更新，以确保只有必要的部分会被实际更新，从而提高性能和效率。</p> 
<h3><a id="setState_20"></a>setState()</h3> 
<p><code>setState</code>是React组件中用于更新状态的方法。当调用<code>setState</code>并传入新的状态值时，React会自动比较新旧状态的差异，并执行相应的更新操作。</p> 
<p>在实际工作项目中，<code>setState</code>通常用于处理以下需求：</p> 
<ol><li> <p>用户交互：当用户与页面进行交互时，组件的状态可能需要更新，如表单输入、按钮点击等。</p> </li><li> <p>数据获取和异步操作：当组件依赖的数据发生变化或进行异步操作后返回新的数据时，可以通过<code>setState</code>更新组件的状态，从而触发重新渲染。</p> </li><li> <p>条件渲染：通过更新组件的状态，可以实现条件渲染，根据不同的状态值显示不同的内容。</p> </li></ol> 
<h4><a id="_31"></a>案例需求</h4> 
<p>假设我们有一个计数器组件，点击按钮后计数器的值会递增。需要实现以下功能：</p> 
<ol><li>初始计数器的值为0。</li><li>点击按钮后，计数器的值加1。</li><li>将计数器的值显示在页面上。</li></ol> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Counter<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>increment<span class="token punctuation">}</span><span class="token operator">&gt;</span>增加<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App
</code></pre> 
<ol><li>首先，使用React的<code>useState</code>钩子函数声明一个名为<code>count</code>的状态变量，并将其初始值设置为0。</li><li>创建一个名为<code>increment</code>的函数，当按钮被点击时，这个函数会在当前计数的基础上加1，并通过调用<code>setCount</code>来更新计数器的值。</li><li>在组件的返回值中，将计数器的值以文本形式显示在页面上，并将<code>increment</code>函数作为按钮的点击事件处理函数。</li></ol> 
<blockquote> 
 <ol><li>在调用<code>setState</code>方法时，传入的新状态不会立即生效，而是在下一次React的重新渲染过程中才会生效。React会使用新的状态值重新渲染组件，并只更新需要更新的部分，以提升性能。</li><li><code>setState</code>方法可以接受一个对象或一个函数作为参数。当传入一个函数时，React会将当前状态作为参数传递给这个函数，函数返回的结果将作为新的状态值。</li><li>在使用函数更新状态时，应该使用回调函数的形式确保获取到最新的状态值。例如：<code>setCount(prevCount =&gt; prevCount + 1)</code>。</li></ol> 
</blockquote> 
<h4><a id="_68"></a>总结</h4> 
<p>在React中，<code>setState</code>方法用于更新组件的状态，并触发重新渲染。通过<code>setState</code>方法，我们可以根据不同的需求更新组件的状态，使得页面能够及时显示最新的数据和交互效果。在使用<code>setState</code>时，需要注意更新状态的方式和时机，以及遵循React的一些规范和最佳实践，以保证代码的可读性、性能和可靠性。</p> 
<h3><a id="forceUpdate_70"></a>forceUpdate()</h3> 
<p>在React中，组件的渲染是由组件的状态（state）和属性（props）驱动的。当组件的状态或属性发生变化时，React会执行重新渲染，更新组件的UI展示。通常情况下，React会根据状态和属性的变化自动触发重新渲染，但有时候我们需要手动触发重新渲染，这时就可以使用<code>forceUpdape()</code>方法。</p> 
<p>在实际工作项目中，可能会遇到以下情况需要使用<code>forceUpdate()</code>方法：</p> 
<ol><li>当组件的状态更新依赖于外部因素，而不是通过<code>setState()</code>方法触发的。</li><li>当组件的某些内部状态无法通过<code>setState()</code>来管理，但需要触发重新渲染。</li></ol> 
<h4><a id="_78"></a>案例需求</h4> 
<p>假设我们有一个按钮组件，点击按钮时需要在组件内部记录点击次数并重新渲染。我们可以使用<code>forceUpdate()</code>方法实现该功能。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">clickCount</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleButtonClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleButtonClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleButtonClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>clickCount <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment">// 修改内部状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 强制重新渲染组件</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token keyword">this</span><span class="token punctuation">.</span>handleButtonClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Click Me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>Click Count<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>clickCount<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App

</code></pre> 
<p>以上代码是一个按钮组件，内部有一个<code>clickCount</code>的状态，记录了按钮被点击的次数。在构造函数中初始化了状态为0，并绑定了按钮的点击事件处理函数<code>handleButtonClick</code>。在<code>handleButtonClick</code>函数中，每次点击按钮时，通过直接修改内部状态<code>clickCount</code>的值来增加点击次数。然后，通过调用<code>forceUpdate()</code>方法，强制执行重新渲染，以便更新UI展示。</p> 
<blockquote> 
 <ol><li>使用<code>forceUpdate()</code>方法时，需要谨慎，因为它会绕过React的状态管理机制，可能导致性能问题和不可预测的行为。尽量避免使用<code>forceUpdate()</code>，除非确实有必要。</li><li>在大多数情况下，应该优先考虑使用<code>setState()</code>来管理组件的状态，并依赖React的自动重新渲染机制。</li><li>如果组件的状态更新是由组件外部的因素驱动的（例如父组件的状态发生改变），可以通过将状态作为属性传递给内部组件来触发重新渲染，而不是使用<code>forceUpdate()</code>。</li></ol> 
</blockquote> 
<h4><a id="_119"></a>总结</h4> 
<p><code>forceUpdate()</code>方法是React提供的一种手动触发组件重新渲染的方式。它允许绕过React的自动重新渲染机制，强制执行组件的更新。但需要注意，使用<code>forceUpdate()</code>可能引起性能问题和不可预测的行为，所以应该谨慎使用，并优先考虑使用<code>setState()</code>来管理组件的状态。</p> 
<h3><a id="props_121"></a>props改变</h3> 
<p>在React中，组件的<code>props</code>是从父组件传递给子组件的数据。当父组件的<code>props</code>发生变化时，子组件会接收新的<code>props</code>，并进行重新渲染。这是因为React会自动比较新旧<code>props</code>的值，并根据变化情况来决定是否重新渲染组件。</p> 
<p>在实际工作项目中，我们经常需要根据不同的数据源来渲染不同的组件。当这些数据源发生变化时，我们希望相应的组件能够获取最新的数据，并进行重新渲染，以确保界面的正确展示。</p> 
<h4><a id="_127"></a>案例需求</h4> 
<p>假设我们有一个名为<code>User</code>的组件，它接收一个<code>name</code>属性，并将其显示在界面上。我们希望当<code>name</code>属性发生变化时，<code>User</code>组件能够重新渲染，以显示最新的<code>name</code>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> User

</code></pre> 
<p>在另一个父组件中，我们可以通过更改<code>name</code>属性的值来触发<code>User</code>组件的重新渲染。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> User <span class="token keyword">from</span> <span class="token string">'./User'</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 模拟异步更新name属性</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Jane'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>User name<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App
</code></pre> 
<p>在上述代码中，父组件<code>App</code>通过<code>this.state.name</code>的值控制了<code>User</code>组件接收的<code>name</code>属性。初始情况下，<code>name</code>属性的值为’John’。在<code>componentDidMount</code>生命周期方法中，通过设置定时器模拟异步操作，2秒后将<code>name</code>属性的值更改为’Jane’。这会触发<code>User</code>组件的重新渲染，并将新的<code>name</code>值显示在界面上。</p> 
<blockquote> 
 <ol><li>当父组件的<code>props</code>发生变化时，子组件会重新渲染，但子组件内部的状态不会受到影响。如果需要在子组件内部响应<code>props</code>的变化，可以使用生命周期方法<code>componentDidUpdate()</code>来进行逻辑处理。</li><li>在<code>User</code>组件中，使用了<code>this.props.name</code>来获取<code>name</code>属性的值。通过<code>props</code>可以将数据从父组件传递到子组件，并在子组件中使用。</li><li>在实际应用中，可以根据需要使用不同的生命周期方法来处理<code>props</code>的变化，例如<code>componentDidUpdate()</code>或<code>useEffect()</code>（对应函数式组件）。</li></ol> 
</blockquote> 
<h4><a id="_188"></a>总结</h4> 
<p>React组件在接收到新的<code>props</code>时会进行重新渲染。通过在父组件改变<code>props</code>的值，可以触发子基本概念:<br> 在React中，组件的属性（props）是从父组件传递给子组件的数据。当父组件更新传递给子组件的属性时，子组件会根据新的属性值进行重新渲染。</p> 
<h3><a id="context_192"></a>context改变</h3> 
<p>在React中，Context API允许我们在组件树中传递数据，而不必手动通过props一层层传递。当使用了Context API，并且某个组件订阅了特定的context值，当该context值发生变化时，订阅了该值的组件会自动重新渲染，以显示最新的数据。</p> 
<p>在实际工作项目中，我们可能会使用Context API来传递全局的数据、主题、用户身份认证等信息。当这些全局数据发生变化时，我们希望依赖于这些数据的组件能够及时更新，以反映最新的状态。</p> 
<h4><a id="_197"></a>案例需求</h4> 
<p>假设我们有一个主题切换功能，用户可以选择不同的主题来改变应用的外观。我们需要使用Context API来传递当前主题的信息，并在主题发生变化时，自动重新渲染依赖于主题的组件。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> createContext<span class="token punctuation">,</span> useState<span class="token punctuation">,</span> useContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>theme<span class="token punctuation">,</span> setTheme<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> <span class="token function-variable function">toggleTheme</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">setTheme</span><span class="token punctuation">(</span><span class="token parameter">prevTheme</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>prevTheme <span class="token operator">===</span> <span class="token string">'light'</span> <span class="token operator">?</span> <span class="token string">'dark'</span> <span class="token operator">:</span> <span class="token string">'light'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span> theme<span class="token punctuation">,</span> toggleTheme <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>主题切换器<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>toggleTheme<span class="token punctuation">}</span><span class="token operator">&gt;</span>切换主题<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>ThemedContent <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">ThemedContent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> theme <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ThemeContext<span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">background</span><span class="token operator">:</span> theme <span class="token operator">===</span> <span class="token string">'light'</span> <span class="token operator">?</span> <span class="token string">'#f0f0f0'</span> <span class="token operator">:</span> <span class="token string">'#333'</span><span class="token punctuation">,</span> <span class="token literal-property property">color</span><span class="token operator">:</span> theme <span class="token operator">===</span> <span class="token string">'light'</span> <span class="token operator">?</span> <span class="token string">'#333'</span> <span class="token operator">:</span> <span class="token string">'#f0f0f0'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>这是一个主题内容<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App
</code></pre> 
<p>在上述代码中，我们创建了一个<code>ThemeContext</code>，并在<code>App</code>组件中使用<code>useState</code>来管理当前主题的状态。通过<code>ThemeContext.Provider</code>将主题信息传递给子组件。当用户点击按钮切换主题时，会触发<code>toggleTheme</code>函数更新主题状态，从而导致<code>ThemedContent</code>组件重新渲染。</p> 
<p>在<code>ThemedContent</code>组件中，通过<code>useContext(ThemeContext)</code>来订阅<code>ThemeContext</code>中的主题信息。根据当前主题的值，动态改变内容区域的背景色和文字颜色，实现主题切换的效果。</p> 
<blockquote> 
 <ol><li>使用Context API可以避免props层层传递的繁琐过程，但应该谨慎使用，避免滥用全局状态。</li><li>当Context值发生变化时，只有订阅了该值的组件会重新渲染，其他未订阅的组件不会受影响。</li><li>在实际项目中，可以将Context用于管理全局状态、主题、用户认证等共享数据，以提高组件之间的通信和数据传递效率。</li></ol> 
</blockquote> 
<h4><a id="_244"></a>总结</h4> 
<p>使用Context API可以方便地在React应用中传递全局数据，当Context值发生变化时，订阅了该值的组件会重新渲染。在实际工作中，可以根据需要利用Context来管理全局状态，实现组件之间的数据共享和通信。</p> 
<blockquote> 
 <p>持续学习总结记录中，回顾一下上面的内容：<br> <strong>在React中，组件的重新渲染可以通过<code>setState()</code>、<code>forceUpdate()</code>、props或state的改变、父组件的重新渲染以及context的改变来触发。当组件重新渲染时，React会执行<code>render</code>方法，生成新的虚拟DOM树。然后，React会比较新旧的虚拟DOM树，找出差异，计算需要更新的部分，最后只更新这些部分到实际的DOM上。这个过程确保了只有必要的部分会被实际更新，从而提高性能和效率。</strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62e44fd8460ffd568046f6b9d4f361fa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用真实数据告诉你前10大AI对话工具排行！（国内&#43;国外篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9fb62c1c1438f5667e09f837af8085c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# List使用详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>