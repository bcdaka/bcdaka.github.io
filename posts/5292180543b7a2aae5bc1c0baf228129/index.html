<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈希表与统计——594、350、554、609、454(2简3中) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5292180543b7a2aae5bc1c0baf228129/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="哈希表与统计——594、350、554、609、454(2简3中)">
  <meta property="og:description" content="594. 最长和谐子序列（简单） 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
解法一、哈希统计 如果不存在键，放入1。如果存在键，更新数量。如果存在num&#43;1或者-1的键，更新最大值。
class Solution { public int findLHS(int[] nums) { HashMap&lt;Integer,Integer&gt; hm = new HashMap&lt;&gt;(); int max = 0; for(int num : nums){ if(!hm.containsKey(num)){ hm.put(num,1); }else{ hm.put(num,hm.get(num) &#43; 1); } if(hm.containsKey(num&#43;1)){ max = Math.max(max,hm.get(num) &#43; hm.get(num&#43;1)); } if(hm.containsKey(num-1)){ max = Math.max(max,hm.get(num) &#43; hm.get(num-1)); } } return max; } } 解法二、排序&#43;滑动窗口 滑窗和双指针做法到底什么差别orzzzz
class Solution { public int findLHS(int[] nums) { Arrays.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-04T16:23:43+08:00">
    <meta property="article:modified_time" content="2024-09-04T16:23:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈希表与统计——594、350、554、609、454(2简3中)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h3 style="background-color:transparent;"><a href="https://leetcode.cn/problems/longest-harmonious-subsequence/" rel="nofollow" title="594. 最长和谐子序列">594. 最长和谐子序列</a>（简单）</h3> 
<blockquote> 
 <p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 <strong>正好是 <code>1</code></strong> 。</p> 
 <p>现在，给你一个整数数组 <code>nums</code> ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p> 
 <p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p> 
</blockquote> 
<h4>解法一、哈希统计</h4> 
<p>如果不存在键，放入1。如果存在键，更新数量。如果存在num+1或者-1的键，更新最大值。</p> 
<pre><code class="language-java">class Solution {
    public int findLHS(int[] nums) {
        HashMap&lt;Integer,Integer&gt; hm = new HashMap&lt;&gt;();
        int max = 0;
        for(int num : nums){
            if(!hm.containsKey(num)){
                hm.put(num,1);
            }else{
                hm.put(num,hm.get(num) + 1);
            }
            if(hm.containsKey(num+1)){
                max = Math.max(max,hm.get(num) + hm.get(num+1));
            }
            if(hm.containsKey(num-1)){
                max = Math.max(max,hm.get(num) + hm.get(num-1));
            }
        }
        return max;
    }
}</code></pre> 
<p><img alt="" height="734" src="https://images2.imgbox.com/1e/99/YNO9FbHL_o.png" width="1200"> </p> 
<h4>解法二、排序+滑动窗口</h4> 
<p>滑窗和双指针做法到底什么差别orzzzz</p> 
<pre><code class="language-java">class Solution {
    public int findLHS(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length, ans = 0;
        for (int i = 0, j = 0; j &lt; n; j++) {
            while (i &lt; j &amp;&amp; nums[j] - nums[i] &gt; 1) i++;
            if (nums[j] - nums[i] == 1) ans = Math.max(ans, j - i + 1);
        }
        return ans;
    }
}</code></pre> 
<h3 style="background-color:transparent;"><br><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/" rel="nofollow" title="350. 两个数组的交集 II">350. 两个数组的交集 II</a>（简单）</h3> 
<blockquote> 
 <p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 </p> 
</blockquote> 
<h4>解法一、排序</h4> 
<pre><code class="language-java">class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int i = 0,j = 0;
        int n1 = nums1.length,n2 = nums2.length;
        while(i &lt; n1 &amp;&amp; j &lt; n2){
            while(i &lt; n1 &amp;&amp; j &lt; n2&amp;&amp; nums1[i] &lt; nums2[j])i++;
            while(i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; nums1[i] &gt; nums2[j])j++;
            while(i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; nums1[i] == nums2[j]){
                res.add(nums1[i]);
                i++;
                j++;
            }
        }
        int[] r = new int[res.size()];
        for(int k = 0;k &lt; res.size();k++){
            r[k] = res.get(k);
        }
        return r;
    }
}</code></pre> 
<p><img alt="" height="710" src="https://images2.imgbox.com/d8/61/DlL2jPnL_o.png" width="1200"> </p> 
<h4> 解法二、哈希</h4> 
<p>不过其实感觉如果是哈希的话，直接用数组（桶计数）就挺好的，遍历一个++，遍历另一个--</p> 
<pre><code class="language-java">class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if (nums1.length &gt; nums2.length) {
            return intersect(nums2, nums1);
        }
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int num : nums1) {
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        }
        int[] intersection = new int[nums1.length];
        int index = 0;
        for (int num : nums2) {
            int count = map.getOrDefault(num, 0);
            if (count &gt; 0) {
                intersection[index++] = num;
                count--;
                if (count &gt; 0) {
                    map.put(num, count);
                } else {
                    map.remove(num);
                }
            }
        }
        return Arrays.copyOfRange(intersection, 0, index);
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/intersection-of-two-arrays-ii/solutions/327356/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre> 
<p></p> 
<h3 style="background-color:transparent;"><a href="https://leetcode.cn/problems/brick-wall/" rel="nofollow" title="554. 砖墙">554. 砖墙</a>（中等）</h3> 
<blockquote> 
 <p>你的面前有一堵矩形的、由 <code>n</code> 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p> 
 <p>你现在要画一条 <strong>自顶向下 </strong>的、穿过 <strong>最少 </strong>砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</strong></p> 
 <p>给你一个二维数组 <code>wall</code> ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code> 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p> 
</blockquote> 
<h4>解法一、哈希表</h4> 
<p>本质上还是统计题。需要转化思维，算穿过的砖最少，也就是算穿过缝隙最多。例如，对于用例</p> 
<pre>wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
</pre> 
<p>相当于统计1/3/5/6 、 3/4/6 、 1/4/6 、 2/6 、 3/4/6 、 1/4/5/6 中除了6以外，哪个数字出现最多，这个数字也就是代码里面的max。要注意对于不在边缘划线的条件，需要通过哈希表移除最大值的方式达到，而不能在最后的for循环里设置if。</p> 
<p>此外有个细节：多写一个循环遍历哈希表值里最大值，比在第一个for里算要快。</p> 
<pre><code class="language-java">class Solution {
    public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) {
        int num = wall.size();
        int max = 0,sum = 0;
        HashMap&lt;Integer,Integer&gt; hm = new HashMap&lt;&gt;();
        for(List&lt;Integer&gt; bricks : wall){
            sum = 0;
            for(int brick : bricks){
                sum+=brick;
                if(!hm.containsKey(sum)){
                    hm.put(sum,1);
                }else{
                    hm.put(sum,hm.get(sum) + 1);
                }
            }
        }
        hm.remove(sum);
        for(int t : hm.values()){
            max = Math.max(max,t);
        }
        return num - max;
    }
}</code></pre> 
<p><img alt="" height="730" src="https://images2.imgbox.com/44/b7/C1qtomQT_o.png" width="1200"> </p> 
<h3> <br><a href="https://leetcode.cn/problems/find-duplicate-file-in-system/" rel="nofollow" title="609. 在系统中查找重复文件">609. 在系统中查找重复文件</a>（中等）</h3> 
<blockquote> 
 <p>给你一个目录信息列表 <code>paths</code> ，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按 <strong>任意顺序</strong> 返回。</p> 
 <p>一组重复的文件至少包括 <strong>两个 </strong>具有完全相同内容的文件。</p> 
 <p><strong>输入 </strong>列表中的单个目录信息字符串的格式如下：</p> 
 <ul><li><code>"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"</code></li></ul> 
 <p>这意味着，在目录 <code>root/d1/d2/.../dm</code> 下，有 <code>n</code> 个文件 ( <code>f1.txt</code>, <code>f2.txt</code> ... <code>fn.txt</code> ) 的内容分别是 ( <code>f1_content</code>, <code>f2_content</code> ... <code>fn_content</code> ) 。注意：<code>n &gt;= 1</code> 且 <code>m &gt;= 0</code> 。如果 <code>m = 0</code> ，则表示该目录是根目录。</p> 
 <p><strong>输出 </strong>是由 <strong>重复文件路径组</strong> 构成的列表。其中每个组由所有具有相同内容文件的文件路径组成。文件路径是具有下列格式的字符串：</p> 
 <ul><li><code>"directory_path/file_name.txt"</code></li></ul> 
</blockquote> 
<h4 style="background-color:transparent;"> 解法一、哈希</h4> 
<p>（备注写在前面）官方做法里的键值对是String--List&lt;String&gt;</p> 
<p>遍历给的字符串组，对于每一个固定的字符串，用空格分割。此时的temp[0]是地址，之后的都是文件名和内容。把内容context作为键存入哈希，值则是对应的list中下标，方便每个文件找到自己在res中的位置。</p> 
<p>这里有一个问题：如果重复时再存的话，第一次重复需要存两个，其余只需要存一个。所以不妨逆向思维，先把所有的都存进去，再删去不重复的（即size == 1）。</p> 
<p>但是，尤其对于size == 1情况下的删除细节，也出过很多问题。最初时尝试了for的int i循环，但由于一边遍历一边删，它的size很快就变小了，也就是会访问过界。第二次时尝试了for-each循环，结果报错java.util.ConcurrentModificationException</p> 
<pre><code class="language-java">        for(List&lt;String&gt; list : res){
            if(list.size() == 1)res.remove(list);
        }</code></pre> 
<p> 经检查，发现是遍历器和remove的删除问题，事故原因溯至轮子（源码）的某个值更新出现差错。于是再进行优化。解决方法有两种，两种都依旧是for的int i循环①每次删除操作后，i--②从后往前遍历。</p> 
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) {
        List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;();
        HashMap&lt;String,Integer&gt; hm = new HashMap&lt;&gt;();
        for(String s : paths){
            String[] temp = s.split(" ");
            for(int i = 1;i &lt; temp.length;i++){
                String context = temp[i].substring(temp[i].indexOf('(')+1);
                StringBuilder sb = new StringBuilder();
                sb.append(temp[0]).append('/').append(temp[i].substring(0,temp[i].indexOf('(')));
                if(hm.containsKey(context)){//如果已经存在
                    res.get(hm.get(context)).add(sb.toString());//取出对应
                }else{//放进去
                    hm.put(context,res.size());
                    List&lt;String&gt; tempList = new LinkedList&lt;&gt;();
                    tempList.add(sb.toString());
                    res.add(tempList);
                }
            }
        }
         for(int i = res.size()-1;i &gt;= 0;i--){
            if(res.get(i).size() == 1)res.remove(i);
        }
        return res;
    }
}</code></pre> 
<p><img alt="" height="726" src="https://images2.imgbox.com/c6/e5/eVDOuVOY_o.png" width="1200"></p> 
<p></p> 
<h3 style="background-color:transparent;"><a href="https://leetcode.cn/problems/4sum-ii/" rel="nofollow" title="454. 四数相加 II">454. 四数相加 II</a>(中等)</h3> 
<blockquote> 
 <p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p> 
 <ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul> 
</blockquote> 
<h4>解法一、哈希</h4> 
<p>两两分组判断，时间复杂度O（n^2）</p> 
<pre><code class="language-java">class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        HashMap&lt;Integer,Integer&gt; hm = new HashMap&lt;&gt;();
        int res = 0;
        for(int num1 : nums1){
            for(int num2 : nums2){
                int sumAB = num1 + num2;
                if(!hm.containsKey(sumAB)){
                    hm.put(sumAB,1);
                }else{
                    hm.put(sumAB,hm.get(sumAB)+1);
                }
            }
        }
        for(int num3 : nums3){
            for(int num4 : nums4){
                int sumCD = -num3-num4;
                if(hm.containsKey(sumCD)){
                    res+= hm.get(sumCD);
                }
            }
        }
        return res;
    }
}</code></pre> 
<h4> <img alt="" height="756" src="https://images2.imgbox.com/4d/c1/8lAlE7gl_o.png" width="1200"></h4> 
<h4 style="background-color:transparent;">解法二、桶排序</h4> 
<p>时间复杂度差太多了。。第一个for循环之前确认范围，第一个for循环统计数量，第二个for循环查找符合条件的数量并加入res。原理没变，数据结构优化了</p> 
<pre><code class="language-java">import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int[] n1 = getMaxMin(nums1);
        int[] n2 = getMaxMin(nums2);
        int[] n3 = getMaxMin(nums3);
        int[] n4 = getMaxMin(nums4);
        int maxSum = Math.max(n1[0] + n2[0], -n3[1] - n4[1]);
        int minSum = Math.min(n1[1] + n2[1], -n3[0] - n4[0]);
        int[] map = new int[maxSum - minSum + 1];
        for (int i : nums1) {
            for (int j : nums2) {
                map[i + j - minSum] ++ ;
            }
        }
        int count = 0;
        for (int i : nums3) {
            for (int j : nums4) {
                count += map[- i - j - minSum];
            }
        }
        return count;
    }
    public int[] getMaxMin (int[] nums) {
        int[] num = Arrays.copyOf(nums, nums.length);
        Arrays.sort(num);
        int min = num[0];
        int max = num[nums.length - 1];
        return new int[] {max, min};
    }
}</code></pre> 
<h4><img alt="" height="774" src="https://images2.imgbox.com/eb/58/pbIt3gOK_o.png" width="1200"> </h4> 
<hr> 
<h3 style="background-color:transparent;">碎碎念</h3> 
<ul><li>594重要的思路转换——能够删除任何数，就是能够选择任何想要的数。滑动窗口很有意思，虽然没搞懂和双指针根本上的差别。应该只是基于双指针实现？这附近埋个思考。</li><li>554的思路转换很有意思。技术力感觉还好，配得上中等题。</li><li>609写起来太冗余复杂了，但是也很有趣。确实感觉到细节处理能力上升了，而且一开始打好代码框架确实很重要</li><li>454看了下题解才学会二二分组来着。</li><li>其实还有个18，但是太难了，今天没睡午觉有点困，不想做。。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c4e0a79584ea3e4053b7fdda102296e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">828华为云征文｜Flexus X实例搭配华为云EulerOS，快速部署MySQL并执行读写性能测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07f6aeabd7acbd8cac6ec3a8cad1ed6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华芯邦碳化硅SIC MOSFET性能卓越应用在新能源汽车充电领域，更在其高达235°C的环境中依然保持坚韧，175度的高温下依然能够稳定工作，不会因过热而失效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>