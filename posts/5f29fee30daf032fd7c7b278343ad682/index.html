<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】优先级队列（堆） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5f29fee30daf032fd7c7b278343ad682/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】优先级队列（堆）">
  <meta property="og:description" content="目录
1、优先级队列
1.1 概念
2、优先级队列的底层
2、1 堆的概念
2、2 堆的存储方式
2、3堆的创建
2.3.1 堆向下调整
2.3.2堆的创建
2.4 堆的插入与删除
2.4.1 堆的插入
2.4.2 堆的删除
3.常用接口介绍
3.1 PriorityQueue的特性
3.2 PriorityQueue 的构造方法 3.3 PriorityQueue 常用的成员方法
3.4 优先级队列的运用 -Oj题
1、优先级队列 1、1 概念 前面介绍过队列，队列是一种先进先出(FIFO)的数据结构，但有些情况下，操作的数据可能带有优先级，一般出队列时，可能需要优先级高的元素先出队列。
在这种情况下，数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象。这种数据结构就是优先级队列(Priority Queue)。
2、优先级队列的底层 优先级队列实现的使用的工具为二叉堆较普遍，JDK1.8中的PriorityQueue底层就使用了二叉堆这种数据结构，而堆实际就是在完全二叉树的基础上进行了一些调整。
2、1 堆的概念 如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储 在一 个一维数组中，并满足：Ki = K2i&#43;1 且 Ki &gt;= K2i&#43;2) i = 0，1，2…，则称为小堆(或大 堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
堆的性质：
结构性： 堆总是一棵完全二叉树。一个堆结构将由一个（Comparable对象的）数组和一个代表当前堆的大小的整数组成
堆序性： 堆中某个节点的值总是不大于或不小于其父节点的值；
2、2 堆的存储方式 从堆的概念可知，堆是一棵完全二叉树，因此可以层序的规则采用顺序的方式来高效存储
【注意】：对于非完全二叉树，则不适合使用顺序方式进行存储，因为为了能够还原二叉树，空间中必须要存储空节点，就会导致空间利用率比较低。
将元素存储到数组中后,通过数组对应下标，找出二叉树的父子关系；
节点下标关系左节点leftChild = parent *2 &#43; 1右节点rightChild = parent *2 &#43; 2父节点parent = ( child -1) / 2 则有：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-26T18:51:14+08:00">
    <meta property="article:modified_time" content="2024-08-26T18:51:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】优先级队列（堆）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">1、优先级队列</a></p> 
<p id="1.1%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.1%20%E6%A6%82%E5%BF%B5" rel="nofollow">1.1 概念</a></p> 
<p id="2%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%95%E5%B1%82-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%95%E5%B1%82" rel="nofollow">2、优先级队列的底层</a></p> 
<p id="2%E3%80%811%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2%E3%80%811%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">2、1 堆的概念</a></p> 
<p id="2%E3%80%812%20%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2%E3%80%812%20%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F" rel="nofollow">2、2 堆的存储方式</a></p> 
<p id="2%E3%80%813%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#2%E3%80%813%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">2、3堆的创建</a></p> 
<p id="2.3.1%20%E5%A0%86%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4-toc" style="margin-left:80px;"><a href="#2.3.1%20%E5%A0%86%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4" rel="nofollow">2.3.1 堆向下调整</a></p> 
<p id="2.3.2%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><a href="#2.3.2%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">2.3.2堆的创建</a></p> 
<p id="2.4%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#2.4%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4" rel="nofollow">2.4 堆的插入与删除</a></p> 
<p id="2.4.1%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#2.4.1%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">2.4.1 堆的插入</a></p> 
<p id="2.4.2%20%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#2.4.2%20%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">2.4.2 堆的删除</a></p> 
<p id="3.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#3.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D" rel="nofollow">3.常用接口介绍</a></p> 
<p id="3.1%20PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#3.1%20PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">3.1 PriorityQueue的特性</a></p> 
<p id="3.2%20PriorityQueue%20%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20PriorityQueue%20%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">3.2 PriorityQueue 的构造方法 </a></p> 
<p id="3.3%20PriorityQueue%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.3%20PriorityQueue%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95" rel="nofollow">3.3 PriorityQueue 常用的成员方法</a></p> 
<p id="3.4%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%90%E7%94%A8%20-Oj%E9%A2%98-toc" style="margin-left:40px;"><a href="#3.4%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%90%E7%94%A8%20-Oj%E9%A2%98" rel="nofollow">3.4 优先级队列的运用 -Oj题</a></p> 
<hr> 
<h2 id="1%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">1、优先级队列</h2> 
<h3 id="1.1%20%E6%A6%82%E5%BF%B5">1、1 概念</h3> 
<p>前面介绍过队列，<strong>队列是一种先进先出(FIFO)的数据结构</strong>，<strong>但有些情况下，操作的数据可能带有优先级，一般出队列时，可能需要优先级高的元素先出队列。</strong></p> 
<p>在这种情况下，<strong>数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象。</strong>这种数据结构就是<strong><span style="background-color:#ffd900;">优先级队列(Priority Queue)。</span></strong></p> 
<h2 id="2%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%95%E5%B1%82" style="background-color:transparent;">2、优先级队列的底层</h2> 
<p>优先级队列实现的使用的工具为<strong>二叉堆</strong>较普遍，JDK1.8中的<strong>PriorityQueue底层就使用了<span style="background-color:#ffd900;">二叉</span><span style="background-color:#ffd900;">堆</span>这种数据结构</strong>，而堆实际就是在完全二叉树的基础上进行了一些调整。</p> 
<h3 id="2%E3%80%811%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5">2、1 堆的概念</h3> 
<p>如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储 在一 个一维数组中，并满足：Ki = K2i+1 且 Ki &gt;= K2i+2) i = 0，1，2…，<strong>则称为小堆(或大 堆)。将根节点最大的堆叫做<span style="color:#be191c;">最大堆或大根堆</span>，根节点最小的堆叫做<span style="color:#be191c;">最小堆或小根堆。</span></strong></p> 
<p><strong><span style="color:#fe2c24;">堆的性质：</span></strong></p> 
<blockquote> 
 <ul><li><strong>结构性：</strong></li></ul> 
 <p><span style="color:#be191c;"><strong>堆总是一棵完全二叉树。一个堆结构将由一个（Comparable对象的）数组和一个代表当前堆的大小的整数组成</strong></span></p> 
 <ul><li><strong>堆序性：</strong></li></ul> 
 <p><span style="color:#be191c;"><strong>堆中某个节点的值总是不大于或不小于其父节点的值；</strong></span></p> 
</blockquote> 
<h3 id="2%E3%80%812%20%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">2、2 堆的存储方式</h3> 
<p>从堆的概念可知<strong>，堆是一棵完全二叉树，因此可以层序的规则采用顺序的方式来高效存储</strong></p> 
<p>【注意】：对于非完全二叉树，则不适合使用顺序方式进行存储，因为为了能够还原二叉树，空间中必须要存储空节点，就会导致空间利用率比较低。</p> 
<p>将元素存储到数组中后,通过数组对应下标，找出二叉树的父子关系；</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>节点</strong></td><td><strong>下标关系</strong></td></tr><tr><td><strong>左节点</strong></td><td><strong>leftChild = parent *2 + 1</strong></td></tr><tr><td><strong>右节点</strong></td><td><strong>rightChild = parent *2 + 2</strong></td></tr><tr><td><strong>父节点</strong></td><td><strong>parent = ( child -1) / 2</strong></td></tr></tbody></table> 
<p><img alt="" height="570" src="https://images2.imgbox.com/4d/39/1SNLzYjZ_o.jpg" width="1199"></p> 
<blockquote> 
 <p>则有：</p> 
 <ol><li>如果i为0，则 i 表示的节点为根节点，否则i节点的双亲节点为 (i - 1)/2</li><li>如果2 * i + 1 小于节点个数，则节点i的左孩子下标为2 * i + 1，否则没有左孩子</li><li>如果2 * i + 2 小于节点个数，则节点i的右孩子下标为2 * i + 2，否则没有右孩子 </li></ol> 
</blockquote> 
<h3 id="2%E3%80%813%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA">2、3堆的创建</h3> 
<h4 id="2.3.1%20%E5%A0%86%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4">2.3.1 堆向下调整</h4> 
<p>对于集合{ 27,15,19,18,28,34,65,49,25,37 }中的数据，如果将其创建成堆呢？ </p> 
<p><strong>向下过程(以小堆为例)：</strong></p> 
<p>1、让parent标记需要调整的节点，child标记parent的左孩子(注意：parent如果有孩子一定先是有左孩子)</p> 
<p>2、如果parent的左孩子存在，即:child &lt; size， 进行以下操作，直到parent的左孩子不存在 parent右孩子是否存在，存在找到左右孩子中最小的孩子，让child进行标将parent与较小的孩子child比较，</p> 
<ul><li>如果： parent小于较小的孩子child，调整结束</li><li>否则：交换parent与较小的孩子child，交换完成之后，parent中大的元素向下移动，可能导致子树不满足对的性质，因此需要继续向下调整，即parent = child；child = parent*2+1; 然后继续2。</li></ul> 
<p>代码：</p> 
<pre><code class="language-java">public void shiftDown(int[] array, int parent) {
// child先标记parent的左孩子，因为parent可能右左没有右
        int child = 2 * parent + 1;
        int size = array.length;
        while (child &lt; size) {
// 如果右孩子存在，找到左右孩子中较小的孩子,用child进行标记
            if(child+1 &lt; size &amp;&amp; array[child+1] &lt; array[child]){
                child += 1;
            }
// 如果双亲比其最小的孩子还小，说明该结构已经满足堆的特性了
            if (array[parent] &lt;= array[child]) {
                break;
            }else{
// 将双亲与较小的孩子交换
                int t = array[parent];
                array[parent] = array[child];
                array[child] = t;
// parent中大的元素往下移动，可能会造成子树不满足堆的性质，因此需要继续向下调整
                parent = child;
                child = parent * 2 + 1;
            }
        }

    }</code></pre> 
<p>【注意】：</p> 
<p>在调整以parent为根的二叉树时，必须要满足parent的左子树和右子树已经是堆了才可以向下调整。</p> 
<p><span style="color:#fe2c24;">时间复杂度分析</span>： 最坏的情况即图示的情况，从根一路比较到叶子，比较的次数为完全二叉树的高度，即时间复杂度为 <img alt="O(log_2{n})" class="mathcode" src="https://images2.imgbox.com/47/2e/InNJCqbC_o.png"></p> 
<h4 id="2.3.2%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA">2.3.2堆的创建</h4> 
<p>那对于普通的序列{ 1,5,3,8,7,6 }，即根节点的左右子树不满足堆的特性，又该如何调整呢？</p> 
<pre><code class="language-java">public static void createHeap(int[] array) {
// 找倒数第一个非叶子节点，从该节点位置开始往前一直到根节点，遇到一个节点，应用向下调整
        int root = ((array.length-2)&gt;&gt;1);
        for (; root &gt;= 0; root--) {
            shiftDown(array, root);
        }
    }</code></pre> 
<p> 建堆的时间复杂度</p> 
<p>因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明(时间复杂度本来看的就是 近似值，多几个节点不影响最终结果)：</p> 
<p><img alt="" height="390" src="https://images2.imgbox.com/50/5d/9gwHZUy5_o.jpg" width="700"></p> 
<p><strong>因此：建堆的时间复杂度为O(N)。 </strong></p> 
<h3 id="2.4%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4" style="background-color:transparent;">2、4 堆的插入与删除</h3> 
<h4 id="2.4.1%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5">2.4.1 堆的插入</h4> 
<p>堆的插入总共需要两个步骤：</p> 
<blockquote> 
 <ol><li>先将元素放入到底层空间中(注意：空间不够时需要扩容)</li><li>将最后新插入的节点向上调整，直到满足堆的性质</li></ol> 
</blockquote> 
<p>参考代码： </p> 
<pre><code class="language-java">//插入，arr 是存储数据的数组，size 是有效元素个数
    public void insert(int num) {
        if (size &gt;= arr.length) {
            grow();
        }
        arr[size++] = num;
        int last = size - 1;
        shiftUp(last);
    }
 
    //扩容
    private void grow() {
        arr = Arrays.copyOf(arr,arr.length * 2);
    }
 
    //向上调整
    public void shiftUp(int child) {
        int parent = (child - 1) / 2;
        while (child &gt; 0) {
            //因为本来就是一个小根堆，所以只需将插入得值与父节点的值比较
            if (arr[child] &lt; arr[parent]) {
                int tmp = arr[child];
                arr[child] = arr[parent];
                arr[parent] = tmp;
 
                child = parent;
                parent = parent = (child - 1) / 2;
            } else {
                break;
            }
        }
    }</code></pre> 
<h4 id="2.4.2%20%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4">2.4.2 堆的删除</h4> 
<p>注意：<strong>堆的删除一定删除的是堆顶元素</strong>。具体如下：</p> 
<blockquote> 
 <ol><li>将堆顶元素对堆中最后一个元素交换</li><li> 将堆中有效数据个数减少一个</li><li> 对堆顶元素进行向下调整</li></ol> 
</blockquote> 
<p><img alt="" height="388" src="https://images2.imgbox.com/00/74/aGtThfPm_o.jpg" width="1200"></p> 
<pre><code class="language-java">//删除，arr 是存储数据的数组，size 是有效元素个数
    public int poll() {
        int tmp = arr[0];
        arr[0] = arr[--size];
        shiftDown(arr,0);
        return tmp;
    }
//向下调整,建小顶堆
    public void shiftDown(int[] arr, int parent) {
        int child = parent * 2 + 1;
        while (child &lt; size) {
            if (child + 1 &lt; size &amp;&amp; arr[child + 1] &lt; arr[child]) {
                child += 1;
            }
            if (arr[parent] &lt;= arr[child] ) {
                break;
            } else {
                int tmp = arr[parent];
                arr[parent] = arr[child];
                arr[child] = tmp;
                parent = child;//交换之后需要接着向下调整
                child = parent * 2 + 1;
            }
        }
    }</code></pre> 
<h2 id="3.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D" style="background-color:transparent;">3、常用接口介绍</h2> 
<h3 id="3.1%20PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7">3.1 PriorityQueue的特性</h3> 
<p><span style="color:#fe2c24;"><strong>Java集合框架中提供了PriorityQueue和PriorityBlockingQueue两种类型的优先级队列</strong></span>，PriorityQueue是线程不安全的，PriorityBlockingQueue是线程安全的，本文主要介绍PriorityQueue。</p> 
<p>当我们在使用 Java 自带的集合 PriorityQueue 时，需要注意： </p> 
<blockquote> 
 <ul><li>使用 PriorityQueue 时导入PriorityQueue 所在的包</li><li>PriorityQueue 中放置的元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常 </li><li>PriorityQueue 中不能插入null对象，否则会抛出 NullPointerException </li><li>PriorityQueue 底层使用了堆数据结构 </li><li>PriorityQueue 默认情况下是小堆 </li><li>默认情况下，PriorityQueue队列是小堆，如果需要大堆需要用户提供比较器 </li></ul> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">用户自己定义的比较器：直接实现Comparator接口，然后重写该接口中的compare方法即可 </span></strong></p> 
<blockquote> 
 <p>import java.util.Comparator;<br> class IntCmp implements Comparator&lt;Integer&gt;{<!-- --><br>     @Override<br>     public int compare(Integer o1, Integer o2) {<!-- --><br>         return o2-o1;<br>     }<br> }</p> 
</blockquote> 
<h3 id="3.2%20PriorityQueue%20%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0">3.2 PriorityQueue 的构造方法 </h3> 
<p>目前我们只介绍 PriorityQueue 常用的几种构造方法</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td><strong>构造器</strong></td><td><strong>功能介绍</strong></td></tr><tr><td><strong>PriorityQueue ( )</strong></td><td><strong>创建一个空的优先级队列，默认容量是 11 </strong></td></tr><tr><td><strong>PriorityQueue ( int initialCapacity)</strong></td><td> <p><strong>创建一个初始容量为 initialCapacity 的优先级队列</strong></p> <p><strong>注意:initialCapacity 不能小于1，否则会抛IllegalArgumentException 异常 </strong></p> </td></tr><tr><td><strong>PriorityQueue ( Collection&lt;? extends E&gt;c)</strong></td><td><strong>用一个集合来创建优先级队列 </strong></td></tr></tbody></table> 
<blockquote> 
 <pre> static void TestPriorityQueue(){
// 创建一个空的优先级队列，底层默认容量是11
        PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;();
// 创建一个空的优先级队列，底层的容量为initialCapacity
        PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;(100);
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(4);
        list.add(3);
        list.add(2);
        list.add(1);
// 用ArrayList对象来构造一个优先级队列的对象
// q3中已经包含了三个元素
        PriorityQueue&lt;Integer&gt; q3 = new PriorityQueue&lt;&gt;(list);
        System.out.println(q3.size());
        System.out.println(q3.peek());
    }</pre> 
</blockquote> 
<h3 id="3.3%20PriorityQueue%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">3.3 PriorityQueue 常用的成员方法</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td><strong>方法名   </strong></td><td><strong>功能介绍</strong></td></tr><tr><td><strong>boolean offer(E e) </strong></td><td><strong>插入元素，插入成功返回 true ，否则返回 false。如果 e 对象为空，抛出 NullPointerException 异常。空间不够会扩容</strong></td></tr><tr><td><strong>E peek() </strong></td><td><strong>查看堆顶元素并返回，如果优先级队列为空则返回null</strong></td></tr><tr><td><strong>E poll()</strong></td><td><strong> 查看堆顶元素并返回，如果优先级队列为空则返回null</strong></td></tr><tr><td><strong>E poll()  </strong></td><td><strong> 删除堆顶元素并返回，如果优先级队列为空则返回null</strong></td></tr><tr><td><strong>int size()   </strong></td><td><strong>获取优先级队列有效元素的个数</strong></td></tr><tr><td><strong>void clear() </strong></td><td><strong> 清空优先级队列里面的元素</strong></td></tr><tr><td><strong>boolean isEmpty() </strong></td><td><strong> 判断优先级是否为空，为空返回true，否则返回false</strong></td></tr></tbody></table> 
<pre><code class="language-java">static void TestPriorityQueue2(){
        int[] arr = {4,1,9,2,8,0,7,3,6,5};
// 一般在创建优先级队列对象时，如果知道元素个数，建议就直接将底层容量给好
// 否则在插入时需要不多的扩容
// 扩容机制：开辟更大的空间，拷贝元素，这样效率会比较低
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(arr.length);
        for (int e: arr) {
            q.offer(e);
        }
        System.out.println(q.size()); // 打印优先级队列中有效元素个数
        System.out.println(q.peek()); // 获取优先级最高的元素
// 从优先级队列中删除两个元素之和，再次获取优先级最高的元素
        q.poll();
        q.poll();
        System.out.println(q.size()); // 打印优先级队列中有效元素个数
        System.out.println(q.peek()); // 获取优先级最高的元素
        q.offer(0);
        System.out.println(q.peek()); // 获取优先级最高的元素
// 将优先级队列中的有效元素删除掉，检测其是否为空
        q.clear();
        if(q.isEmpty()){
            System.out.println("优先级队列已经为空!!!");
        }
        else{
            System.out.println("优先级队列不为空");
        }
    }
</code></pre> 
<p> 在JDK 1.8中，PriorityQueue的扩容方式：</p> 
<blockquote> 
 <ul><li>如果容量小于64时，是按照oldCapacity的2倍方式扩容的 </li><li>如果容量大于等于64，是按照oldCapacity的1.5倍方式扩容的</li><li>如果容量超过MAX_ARRAY_SIZE，按照MAX_ARRAY_SIZE来进行扩容</li></ul> 
</blockquote> 
<h3 id="3.4%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%90%E7%94%A8%20-Oj%E9%A2%98">3.4 优先级队列的运用 -Oj题</h3> 
<p>优先级队列经常用来解决 top-k 的问题。</p> 
<p>接下来我们就用 top-k 完成一道面试题</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/smallest-k-lcci/description/" rel="nofollow" title="​​​​​​top-k问题：最小的k个数">​​​​​​top-k问题：最小的k个数</a></p> 
<pre><code class="language-java"> class Solution {
        public int[] smallestK(int[] arr, int k) {
// 参数检测
            if(null == arr || k &lt;= 0)
                return new int[0];
            PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(arr.length);
// 将数组中的元素依次放到堆中
            for(int i = 0; i &lt; arr.length; ++i){
                q.offer(arr[i]);
            }
// 将优先级队列的前k个元素放到数组中
            int[] ret = new int[k];
            for(int i = 0; i &lt; k; ++i){
                ret[i] = q.poll();
            }
            return ret;
        }

    }</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b622360ee844109e3632cb62987184bf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Cloud Stream与Kafka（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/807ca9f3d94fad3bc63f5f54743fd848/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GAMES104：09高级动画技术：动画树、IK和表情动画-学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>