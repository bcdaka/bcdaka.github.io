<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java--方法的使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c93480f62c9690e34f688476dff95894/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java--方法的使用">
  <meta property="og:description" content="1.1什么是方法 方法顾名思义就是解决问题的办法，在程序员写代码的时候，会遇到很多逻辑结构一样，解决相同问题时，每次都写一样的代码，这会使代码看起来比较绒余，代码量也比较多，为了解决这个问题，我们把代码逻辑相同的代码写成一个方法，当我们解决相同问题时，直接调用这个方法，这会使代码看起来简洁明了。
方法：在Java中就是一个代码片段，与C语言中的函数类似。
方法存在的意义:
1. 是能够模块化的组织代码(当代码规模比较复杂的时候 ).
2. 做到代码被重复使用, 一份代码可以在多个位置使用.
3. 让代码更好理解更简单.
4. 直接调用现有方法开发, 不必重复造轮子.
举个列子：当我们需要求一个数的阶乘时
public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int x= scanner.nextInt(); for (int i = x-1; i &gt;=1 ; i--) { x*=i; } System.out.println(x); } 你可能会写出这样的代码，是不是看见循环就烦，当我们学会方法就会写出下面这种简洁的代码
public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int x= scanner.nextInt(); System.out.println(fac1(x)); } 是不是看着简洁多了
2.方法的基本格式 // 方法定义 public static 方法返回值 方法名称（[参数类型 形参 ...]){ 方法体代码; [return 返回值]; } // 方法调用 返回值变量 = 方法名称(实参.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-04T13:02:16+08:00">
    <meta property="article:modified_time" content="2024-05-04T13:02:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java--方法的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.1什么是方法</h2> 
<blockquote> 
 <p>方法顾名思义就是解决问题的办法，在程序员写代码的时候，会遇到很多逻辑结构一样，解决相同问题时，每次都写一样的代码，这会使代码看起来比较绒余，代码量也比较多，为了解决这个问题，我们把代码逻辑相同的代码写成一个方法，当我们解决相同问题时，直接调用这个方法，这会使代码看起来简洁明了。</p> 
</blockquote> 
<p>方法：在Java中就是一个代码片段，与C语言中的<span style="background-color:#ffd900;">函数类似</span>。</p> 
<p>方法存在的意义:</p> 
<p>1. 是能够模块化的组织代码(当代码规模比较复杂的时候 ).</p> 
<p>2. 做到代码被重复使用, <span style="background-color:#e7fafa;">一份代码可以在多个位置使用</span>.</p> 
<p>3. 让代码更好理解更简单.</p> 
<p>4. 直接调用现有方法开发, <span style="background-color:#ffd900;">不必重复造轮子</span>.</p> 
<p></p> 
<p>举个列子：当我们需要求一个数的阶乘时</p> 
<pre><code>    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int x= scanner.nextInt();
        for (int i = x-1; i &gt;=1 ; i--) {
            x*=i;
        }
        System.out.println(x);
    }</code></pre> 
<p>你可能会写出这样的代码，是不是看见循环就烦，当我们学会方法就会写出下面这种简洁的代码</p> 
<pre><code>   public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int x= scanner.nextInt();
        System.out.println(fac1(x));
    }</code></pre> 
<p>是不是看着简洁多了</p> 
<p></p> 
<h2>2.方法的基本格式</h2> 
<pre><code>// 方法定义
public static 方法返回值 方法名称（[参数类型 形参 ...]){
 方法体代码;
 [return 返回值];
}
// 方法调用
返回值变量 = 方法名称(实参...);</code></pre> 
<p>接下来来个实例：</p> 
<pre><code>public static int fac1(int x){
    for (int i = x-1; i &gt;=1 ; i--) {
        x*=i;
    }
    return x;
}
——————————————————————————————————————————————————

    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int x= scanner.nextInt();
        System.out.println(fac1(x));
    }</code></pre> 
<p>横线上面是方法的定义，下面是方法的调用；</p> 
<p><span style="color:#fe2c24;">注意事项 ：</span></p> 
<p>1. 方法定义时, 参数可以没有. 每个参数要指定类型</p> 
<p>2. 方法定义时, 返回值也可以没有, 如果没有返回值, 则返回值类型应写成 void</p> 
<p>3. 方法定义时的参数称为 "形参", 方法调用时的参数称为 "实参".</p> 
<p>4. 方法的定义必须在类之中, 代码书写在调用位置的上方或者下方均可.</p> 
<p>5. Java 中没有 "函数声明" 这样的概念.</p> 
<h2></h2> 
<h2>3.方法的执行过程</h2> 
<p>1.定义方法的时候, 不会执行方法的代码. 只有调用的时候才会执行.</p> 
<p>2.当方法被调用的时候, 会将实参赋值给形参.</p> 
<p>3.参数传递完毕后, 就会执行到方法体代码.</p> 
<p>4.当方法执行完毕之后(遇到 return 语句), 就执行完毕, 回到方法调用位置继续往下执行. </p> 
<p>5.一个方法可以被多次调用.</p> 
<p></p> 
<h2>4.实参和形参</h2> 
<p>在定义方法时，参数类型（形参）可以有多个或者一个也没有</p> 
<p>在调用方法时传递的参数叫做实参，参数要与方法的形参匹配（参数的个数和类型）</p> 
<p><span style="background-color:#ff9900;">形参是实参的一份临时拷贝</span>，即调用方法时创建，方法结束后销毁</p> 
<p>举个例子：交换两个数</p> 
<pre><code>public static void swap(int x,int y){
        int t=x;
        x=y;
        y=t;
}
    
    
    public static void main(String[] args) {
        int x=10;
        int y=20;
        System.out.println("交换前:x="+x+"y="+y);
        swap(x,y);
        System.out.println("交换后:x="+x+"y="+y);
    }</code></pre> 
<p>这样写结果是不是交换了呢？肯定不是</p> 
<p><img alt="" height="126" src="https://images2.imgbox.com/2b/0c/LTtAjeRV_o.png" width="727"></p> 
<p>主要原因还是因为形参只是实参的一份临时拷贝</p> 
<p>那就没办法交换两个数了呗，交换两个数要传引用数据类型</p> 
<p>比如数组就是引用数据类型</p> 
<pre><code>    public static void swap1(int arr[]){
        int x=arr[0];
        arr[0]=arr[1];
        arr[1]=x;
    }

    public static void main(String[] args) {
        int []arr={1,2};
        System.out.println("交换前arr[0]="+arr[0]+" arr[1]="+arr[1]);
        swap1(arr);
        System.out.println("交换后arr[0]="+arr[0]+" arr[1]="+arr[1]);
    }</code></pre> 
<p></p> 
<p></p> 
<h2>5.没有返回值的方法</h2> 
<p>没有返回值的方法即方法的返回值类型void</p> 
<p>例如：</p> 
<pre><code>   public static void print(){
        System.out.println("hhhhhh");
    }
    
    public static void main(String[] args) {
        print();
    }</code></pre> 
<p>同时，刚才的交换两个数也是没有返回值的方法</p> 
<p>如果想要在某个条件下提前结束方法，也可以在满足条件后直接return</p> 
<p></p> 
<h2>6.方法的重载</h2> 
<p>当我们想要一个函数的功能，实现多种参数时，我们就可以使用方法的重载</p> 
<p>例子：</p> 
<p>我们使用add方法时，即想实现两个整形的相加，又想实现两个double类型的相加，但是两种方法都是用作加法，记方法名又太麻烦，所以我们会选择重载</p> 
<pre><code>    public static int add(int x,int y){
        return x+y;
    }
    public static double add(double x,double y){
        return x+y;
    }

    public static void main(String[] args) {
        System.out.println(add(1,2));
        System.out.println(add(1.2,2.2));
    }</code></pre> 
<p>方法名都是add，方法名相同，但是实现的功能不同，就叫做方法的重载</p> 
<p></p> 
<p><strong><span style="background-color:#98c091;">重载的规则：</span></strong></p> 
<p>1.针对同一个类</p> 
<p>2.方法名相同</p> 
<p>3.方法的参数不同(参数个数或者参数类型)</p> 
<p>4.方法的返回值类型不影响重载.</p> 
<p></p> 
<h2>7.方法的递归</h2> 
<p><span style="background-color:#6eaad7;">什么是递归：</span></p> 
<p>一个方法在执行过程中调用自身, 就称为 "递归"</p> 
<p>经典例子：斐波那契数列</p> 
<pre><code>public static int fib1(int x){
        if(x==1||x==2){
            return 1;
        }
        else{
            return fib1(x-1)+fib1(x-2);
        }
}</code></pre> 
<p>求斐波那契数列的第几个数时，这个数是前两个斐波那契数之和，而第一个和第二个斐波那契数是1，再求第x个斐波那契数时，需要先求前两个斐波那契数，当x为1或2时，返回1</p> 
<p><img alt="" height="743" src="https://images2.imgbox.com/f5/4c/zdQkXdNe_o.png" width="1200"></p> 
<p>红色箭头代表递的过程，蓝色箭头代表归的过程</p> 
<p><span style="background-color:#cbe0f1;">小结：</span></p> 
<p><span style="background-color:#cbe0f1;">1.</span>递归是一种重要的编程解决问题的方式.</p> 
<p>2.有些问题天然就是使用递归方式定义的(例如斐波那契数列, 二叉树等), 此时使用递归来解就很容易.</p> 
<p>3.有些问题使用递归和使用非递归(循环)都可以解决. 那么此时更推荐使用循环, 相比于递归, 非递归程序更加高效</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6db865fca4001fcf13d4ad75809810c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Hadoop】--基于hadoop和hive实现聊天数据统计分析，构建聊天数据分析报表[17]</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/056e1a363d342a9a3b45b9cf408bd3e7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【动态规划】路径问题|不同路径I|不同路径II|珠宝的最高价值|下降路径的最小和|最小路径和|</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>