<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式软件--51单片机 DAY 4 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e046a1b36f0a41ecac36e928ad66a385/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="嵌入式软件--51单片机 DAY 4">
  <meta property="og:description" content="一、蜂鸣器 当电流通过线圈时会产生电磁场，电磁场与永磁体相互作用，从而使金属膜产生震动而发声。为使金属膜持续震动，蜂鸣器需要使用震荡电路进行驱动。有些蜂鸣器元件内部自带震荡驱动电路，这种蜂鸣器叫做有源蜂鸣器（Active Buzzer，自激式蜂鸣器）；而有些则不带震荡驱动电路，这种蜂鸣器叫做无源蜂鸣器（Passive Buzzer，它激式蜂鸣器）。
1.原理图 2.软件实现 Int_Buzzer.h
#ifndef __INT_BUZZER_H__ #define __INT_BUZZER_H__ #include &lt;STC89C5xRC.H&gt; #define BUZZ P46 /** * @brief 蜂鸣器响0.1s * */ void Int_Buzzer_Buzz(); #endif /* __INT_BUZZER_H__ */ Int_Buzzer.c
#include &#34;Int_Buzzer.h&#34; #include &#34;Util.h&#34; void Int_Buzzer_Buzz() { unsigned char counter = 100; while (counter) { BUZZ = ~BUZZ; Delay1ms(1); --counter; } } main.c #include &#34;Int_DigitalTube.h&#34; #include &#34;Int_MatrixKey.h&#34; #include &#34;Int_Buzzer.h&#34; int main() { u8 key_pressed = 0; Int_DigitalTube_Init(); Int_DigitalTube_DisplayNum(key_pressed); while (1) { key_pressed = Int_MatrixKey_CheckKey(); if (key_pressed) { Int_DigitalTube_DisplayNum(key_pressed); Int_Buzzer_Buzz(); //按键提示音 } Int_DigitalTube_Refresh(); } } 二、中断系统 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-06T18:17:43+08:00">
    <meta property="article:modified_time" content="2024-09-06T18:17:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式软件--51单片机 DAY 4</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、蜂鸣器</h2> 
<p>当电流通过线圈时会产生电磁场，电磁场与永磁体相互作用，从而使金属膜产生震动而发声。为使金属膜持续震动，蜂鸣器需要使用震荡电路进行驱动。有些蜂鸣器元件内部自带震荡驱动电路，这种蜂鸣器叫做有源蜂鸣器（Active Buzzer，自激式蜂鸣器）；而有些则不带震荡驱动电路，这种蜂鸣器叫做无源蜂鸣器（Passive Buzzer，它激式蜂鸣器）。</p> 
<h3>1.原理图</h3> 
<p><img alt="" height="525" src="https://images2.imgbox.com/e5/59/MExX0NB4_o.png" width="729"></p> 
<h3 style="background-color:transparent;">2.软件实现</h3> 
<p><strong><strong>Int_Buzzer</strong></strong><strong><strong>.h</strong></strong></p> 
<pre><code class="hljs">#ifndef __INT_BUZZER_H__
#define __INT_BUZZER_H__
#include &lt;STC89C5xRC.H&gt;
#define BUZZ P46

/**
 * @brief 蜂鸣器响0.1s
 *
 */
void Int_Buzzer_Buzz();

#endif /* __INT_BUZZER_H__ */</code></pre> 
<p> Int_Buzzer.c</p> 
<pre><code class="hljs">#include "Int_Buzzer.h"
#include "Util.h"

void Int_Buzzer_Buzz()
{
    unsigned char counter = 100;

    while (counter) {
        BUZZ = ~BUZZ;
        Delay1ms(1);
        --counter;
    }
}</code></pre> 
<p>main.c </p> 
<pre><code class="hljs">#include "Int_DigitalTube.h"
#include "Int_MatrixKey.h"
#include "Int_Buzzer.h"
int main()
{
    u8 key_pressed = 0;
    Int_DigitalTube_Init();
    Int_DigitalTube_DisplayNum(key_pressed);
    while (1) {
        key_pressed = Int_MatrixKey_CheckKey();
        if (key_pressed) {
            Int_DigitalTube_DisplayNum(key_pressed);
            Int_Buzzer_Buzz(); //按键提示音
        }

        Int_DigitalTube_Refresh();
    }
}</code></pre> 
<p> </p> 
<h2>二、中断系统</h2> 
<h3>1.概念</h3> 
<p>中断系统是单片机用于处理外部紧急事件的一种机制。中断系统工作的大致流程如下图所示：当CPU正在处理某项任务时，外部发生了某个紧急事件，此时CPU会暂停当前的工作，转而去处理这个紧急事件，处理完之后，再回到原来被中断的位置，继续处理原来的工作。</p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/b1/5c/TAbhm1eP_o.png" width="442"></p> 
<p style="margin-left:.0001pt;">中断系统使单片机能够实时响应外部事件，提高了系统的灵活性和响应能力。</p> 
<p><strong><strong>中断源</strong></strong></p> 
<p>中断源是指能够引发中断的事件。</p> 
<p><strong><strong>中断标志位</strong></strong></p> 
<p>中断标志位用于标识某个中断是否发生，每个中断源都有一个与之对应的中断标志位。当某个中断发生时，相应的中断标位就会置为1，当CPU检测到标志位时，就会处理相应的中断。当中断处理完毕后，中断标志位需要复位（置0），以便接收下一次中断，有些中断源的标志位，会在CPU处理完中断后，自动复位，而有些则需要开发者手动复位，在使用中断时，需要注意查看手册说明。</p> 
<p><strong><strong>中断服务程序</strong></strong></p> 
<p>中断服务程序指处理中断的逻辑，当某个中断标志位置1时，CPU会自动执行相应的中断服务程序。</p> 
<p><strong><strong>中断优先级</strong></strong></p> 
<p>中断优先级是指在多个中断同时发生时，单片机响应中断的先后顺序，并且高优先级的中断可以打断低优先级的中断。</p> 
<p>中断源：</p> 
<p>STC89C52RC共有8个中断源，8个中断源可分为3类，3个类别分别是外部中断（4个）、定时器中断（3个）、串口中断（1个）。</p> 
<h3>2.外部中断</h3> 
<p>外部中断是指由单片机外部的紧急事件触发的中断，通过向单片机的特定引脚发送特定的信号触发。STC89C52RC共提供了4个外部中断引脚，分别是INT0，INT1，INT2，INT3，如下图所示。</p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/60/e3/y6wok2Ub_o.png" width="267"></p> 
<p>51单片机的外部中断支持两种触发方式，分别是<strong><strong>低电平触发</strong></strong>和<strong><strong>下降沿触发</strong></strong>。</p> 
<h3>3.定时器中断</h3> 
<p>定时器中断是指由单片机内部的定时器触发的中断。</p> 
<p>定时器是大多数单片机都具备的一个功能模块，用于实现定时任务。其用法是，设置一个定时值，然后开始计时，待计时结束后，触发相应的定时器中断，开发者可以在中断服务程序中编写定时任务的逻辑。</p> 
<p>STC89C52RC共有三个定时器，分别是Timer0、Timer1、Timer2，每个定时器都有一个相对应的中断。</p> 
<h3>4.串口中断</h3> 
<p>串口中断是由单片机串口触发的中断。</p> 
<p>串口是单片机用于收发数据的重要接口之一，当单片机通过串口接收到数据或者发送完数据后都会触发相应的中断。</p> 
<p style="margin-left:.0001pt;">STC89C52RC的串口引脚为TxD和RxD，其中TxD用于发送数据，RxD用于接收数据，如下图所示。</p> 
<h3 style="margin-left:.0001pt;"><img alt="" height="253" src="https://images2.imgbox.com/c6/21/0xPIsa8Z_o.png" width="257"><br> 5.中断服务程序</h3> 
<p>中断服务程序是指用于处理中断的一段代码，当中断发生时，CPU就会暂停当前程序的执行，转而执行对应的中断服务程序，处理完中断后再恢复到原来的程序。</p> 
<p>STC89C52RC共有8个中断源，分为4个外部中断、3个定时器中断和1个串口中断，开发者可以为每个中断源声明相应的中断服务程序，中断服务程序的声明语法如下。</p> 
<p><img alt="" height="537" src="https://images2.imgbox.com/13/72/tgMyZ5Q9_o.png" width="1200"></p> 
<h3>6.中断优先级</h3> 
<p>STC89C52RC共有四个中断优先级，每个中断源都可以单独设置优先级。若多个中断同时发生，优先级高的会被优先处理；若两个中断的优先级相同，则根据其中断号决定处理顺序，中断号越小越优先。</p> 
<p>除此之外，高优先级的中断还可以打断低优先级的中断，也就是说当CPU正在处理一个中断时，又发生了另外一个优先级比它还高的中断，此时CPU会暂停原来中断的服务程序，转而去处理这个高优先级的中断，处理完之后，再回到原来低优先级的中断服务程序。这个机制叫做中断嵌套，STC89C52RC支持两级中断嵌套。</p> 
<h2>三、外部中断</h2> 
<p>需求：使用外部中断的方式，一键控制LED灯的亮灭。</p> 
<h3>1.硬件设计</h3> 
<p>若想通过外部中断的方式检测按钮，必须将按钮接入4个外部中断引脚之一，如下图所示，可以看到SW3可用于触发外部中断0。</p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/42/2f/PZoJ4IjR_o.png" width="1044"></p> 
<h3>2.使用说明</h3> 
<h4>（1）启用中断</h4> 
<p>默认情况，CPU会屏蔽所有中断请求，也就是说CPU不会响应任何中断请求，要使用中断，必须先进行启用。</p> 
<p>每个中断源是否被启用，是由单片机内部的两个寄存器控制的，这两个寄存器分别是<strong><strong>IE</strong></strong>（Interrupt Enable，中断允许）寄存器和<strong><strong>XICON</strong></strong>（Auxiliary Interrupt Control，辅助中断控制）寄存器。</p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/63/aa/KtsRq8X5_o.png" width="1200"></p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/eb/48/kSRlO3wb_o.png" width="472"></p> 
<p>从上图可以看出，STC89C52系列的中断系统具有两级控制，首先是EA总控制位，其次是每个中断源各自的控制位。因此若需要启用某个中断，需要先将总控制位EA置位1，再将该中断自身的控制位置为1。//EA=1</p> 
<h4>（2）配置外部中断触发方式</h4> 
<p>STC89C52系列的外部中断支持两种触发方式，分别是低电平触发和下降沿触发，4个外部中断各需要1个控制位用于设置触发方式，这4个控制位分布于如下两个寄存器中，分别是<strong><strong>XICON</strong></strong>（Auxiliary Interrupt Control，辅助中断控制）寄存器中、<strong><strong>TCON（</strong></strong>Timer 0 and 1 Control<strong><strong>）</strong></strong>寄存器，如下图所示。</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/e0/75/GgAbIV6S_o.png" width="978"></p> 
<p style="margin-left:.0001pt;">4个控制位的具体作用可参考下图（STC89C52系列中断系统结构图）。</p> 
<p style="margin-left:.0001pt;"><img alt="" height="640" src="https://images2.imgbox.com/59/17/L1Do2ytj_o.png" width="544"></p> 
<h4 style="margin-left:.0001pt;">（3）配置中断优先级</h4> 
<p>STC89C52系列的中断系统支持四个优先级，所以每个中断源的优先级都需要通过2个控制位进行配置，8个中断源共需要16个控制位，这16个控制位分布在如下3个寄存器中，分别是<strong><strong>IPH</strong></strong>（Interrupt Priority High，中断优先级高位）寄存器，<strong><strong>IP</strong></strong>（Interrupt Priority Low，中断优先级低位）寄存器，<strong><strong>XICON</strong></strong>（Auxiliary Interrupt Control，辅助中断控制）寄存器。</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/8c/08/efuJHfVn_o.png" width="1096"></p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/25/0c/eQSAwBec_o.png" width="460"></p> 
<h4>（4）定义中断服务程序</h4> 
<p>外部中断0到外部中断3的中断号分别是：0、2、6、7，以外部中断0为例，其中断服务程序应定义为</p> 
<pre><code class="language-cpp">void INT0_Handler() interrupt 0

{

}</code></pre> 
<h3 style="background-color:transparent;">3.软件设计</h3> 
<p>实现思路：</p> 
<p>（1）启用外部中断0</p> 
<pre><code class="language-cpp">//打开中断总开关
EA=1；
//打开外部中断0开关
EX0=1；</code></pre> 
<p>（2）配置外部中断0的触发方式</p> 
<p>下降沿触发</p> 
<pre><code class="language-cpp">IT0=1；
</code></pre> 
<p>（3）只有一个中断，优先级不考虑</p> 
<p>（4）中断服务程序</p> 
<pre><code class="language-cpp">void INT0_Func() interrupt 0
{
 LED0=~LED0;
}</code></pre> 
<p>完整代码：</p> 
<pre><code class="language-cpp">#include &lt;STC89C5xRC.H&gt; //包含STC89C52的头文件

#define LED0   P00

void Init_INT0()
{
    // 打开中断总开关
    EA = 1;

    // 打开外部中断0开关
    EX0 = 1;

    // 配置外部中断为下降沿触发
    IT0 = 1;
}

void main()
{
    Init_INT0();
    while (1);
}

/**
 * @brief 中断函数中打开LED0，代表当触发中断时，LED0会打开。
 *        根据我们之前的设置，当按下SW3时，P32为低电平，此时LED0打开。
 *
 *        interrupt 0表示0号中断触发时执行该函数的逻辑
 *        如果用C语言编程，中断查询次序就是中断号
 */
void INT0_Func() interrupt 0
{
    // 中断中打开LED0
    LED0 = ~LED0;
}</code></pre> 
<h2>四、定时器中断--闪烁LED灯</h2> 
<h3>1.需求：</h3> 
<p>使用定时器中断的方式实现LED闪烁，具体要求是使用定时器0令LED1每1秒钟闪烁一次。</p> 
<p style="margin-left:.0001pt;">定时器的基本工作原理，是使用一个n位的脉冲计数器，对时钟信号的脉冲进行计数，每个脉冲加1，当脉冲计数器达到最大值（2n）时，也就是溢出时，触发定时器中断。</p> 
<h3 style="margin-left:.0001pt;">2.启用定时器中断</h3> 
<p><img alt="" height="353" src="https://images2.imgbox.com/62/c4/1gPuuApt_o.png" width="1200"></p> 
<pre><code class="language-cpp">//中断总开关
EA=1;
//定时器0中断开关
ET0=1;</code></pre> 
<p>选择定时器工作模式</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:70.9pt;"> <p><strong><strong>M1</strong></strong></p> </td><td style="vertical-align:top;width:70.85pt;"> <p><strong><strong>M0</strong></strong></p> </td><td style="vertical-align:top;width:269.35pt;"> <p><strong><strong>工作模式</strong></strong></p> </td></tr><tr><td style="background-color:#f1f1f1;width:70.9pt;"> <p><strong><strong>0</strong></strong></p> </td><td style="background-color:#f1f1f1;width:70.85pt;"> <p>0</p> </td><td style="background-color:#f1f1f1;width:269.35pt;"> <p>工作模式0（13位）</p> </td></tr><tr><td style="vertical-align:top;width:70.9pt;"> <p><strong><strong>0</strong></strong></p> </td><td style="vertical-align:top;width:70.85pt;"> <p>1</p> </td><td style="vertical-align:top;width:269.35pt;"> <p>工作模式1（16位）</p> </td></tr><tr><td style="background-color:#f1f1f1;width:70.9pt;"> <p><strong><strong>1</strong></strong></p> </td><td style="background-color:#f1f1f1;width:70.85pt;"> <p>0</p> </td><td style="background-color:#f1f1f1;width:269.35pt;"> <p>工作模式2（8位自动重装载）</p> </td></tr><tr><td style="vertical-align:top;width:70.9pt;"> <p><strong><strong>1</strong></strong></p> </td><td style="vertical-align:top;width:70.85pt;"> <p>1</p> </td><td style="vertical-align:top;width:269.35pt;"> <p>工作模式3（双8位）</p> </td></tr></tbody></table> 
<p>计算脉冲初始值</p> 
<p>假如现在需要定时1ms，那么1ms需要的脉冲个数应为0.001/(12/11059200)，因此定时器的初始值应为65536-0.001/(12/11059200)，大约等于64614。</p> 
<p>计算完毕后，需要将该值赋予TL0（低8位）和TH0（高8位），如下。</p> 
<p style="margin-left:.0001pt;"><span style="background-color:#ececec;"><span style="color:#001080;">TL0</span> <span style="color:#000000;">=</span> <span style="color:#098658;">64614</span><span style="color:#3b3b3b;">;</span></span></p> 
<p style="margin-left:.0001pt;"><span style="background-color:#ececec;"><span style="color:#001080;">TH0</span> <span style="color:#000000;">=</span> <span style="color:#098658;">64614</span> <span style="color:#000000;">&gt;&gt;</span> <span style="color:#098658;">8</span><span style="color:#3b3b3b;">;</span></span></p> 
<p style="margin-left:.0001pt;"><span style="color:#3b3b3b;">启动定时器</span></p> 
<p style="margin-left:.0001pt;"></p> 
<p>在做完上述配置后，还需最后一步——启动定时器，启动之后定时器才会开始工作。定时器的启动可由单片机内部的寄存器控制，也可由单片机的外部引脚控制。具体控制逻辑如下图所示。</p> 
<p>当GATE=0时，外部引脚（INT0，P3.2）无效，此时只能由内部寄存器TR0控制，当TR0=1时，脉冲计数器开始计数，TR0=0时，停止计数。</p> 
<p>当GATE=1时，外部引脚（INT0，P3.2）生效，此时只有当内部寄存器TR0和外部引脚INT0都为1时，脉冲计数器才开始计数，否则停止计数。</p> 
<p><img alt="" height="430" src="https://images2.imgbox.com/62/a8/FnOwIgHq_o.png" width="514"></p> 
<h3>3.定义中断服务程序</h3> 
<p style="margin-left:.0001pt;"><span style="background-color:#ececec;"><span style="color:#0000ff;">void</span> <span style="color:#795e26;">Timer0_Hander</span><span style="color:#3b3b3b;">() </span><span style="color:#0000ff;">interrupt</span> <span style="color:#098658;">1</span></span></p> 
<p style="margin-left:.0001pt;"><span style="background-color:#ececec;"><span style="color:#3b3b3b;">{<!-- --></span></span></p> 
<p style="margin-left:.0001pt;"><span style="background-color:#ececec;">    <span style="color:#008000;">//编写定时任务逻辑</span></span></p> 
<p style="margin-left:.0001pt;"><span style="background-color:#ececec;"><span style="color:#3b3b3b;">}</span></span></p> 
<h3 style="margin-left:.0001pt;"><span style="color:#3b3b3b;">4.软件设计</span></h3> 
<h4>（1）启用定时器中断</h4> 
<pre><code class="language-cpp">EA=1;
ET0=1;</code></pre> 
<h4>（2）选择定时器0的工作模式</h4> 
<p>GATE=0 C/T=0 M1=0 M0=1</p> 
<p>C/T是TMOD寄存器中定时器0的控制位，选择定时器C/T应为0.</p> 
<p>故，TMOD寄存器低四位是0001，高四位保持原值。</p> 
<p>TMOD&amp;=0xF0;//高四位不变，低四位归零。</p> 
<p>TMOD|=0x01;//高四位不变，最低位变1.</p> 
<h4>（3）启动定时器</h4> 
<p><img alt="" height="419" src="https://images2.imgbox.com/e3/49/hJcjjVce_o.png" width="1200"></p> 
<p>GATE已经设置为0，只要TR0=1,即可启动。</p> 
<h4>（4）定义中断服务程序</h4> 
<pre><code class="language-cpp">void Timer0_Hander() interrupt 1
{
static unsigned int count = 0;

    //重新状态脉冲计数器
    TL0 = 64614;
    TH0 = 64614 &gt;&gt; 8;

    //统计中断次数
    if (count++ &gt;= 500) {
        LED1  = ~LED1;
        count = 0;
    }
}</code></pre> 
<h3 style="background-color:transparent;">5.完整代码</h3> 
<p>Dri_Timer0.c</p> 
<pre><code class="language-cpp">#include "Dri_Timer0.h"
#include &lt;STC89C5xRC.H&gt;
void Dri_Timer0_Init()
{
    EA=1;//总开关
    ET0=1;//定时器0开关
    //定时器0工作方式
    TMOD&amp;=0xF0;
    TMOD|=0x01;
    //脉冲计数器初始值
    TL0=64614;
    TH0=64614&gt;&gt;8;
    //启动定时器
    TR0=1;

}</code></pre> 
<p>Dri_Timer0.h</p> 
<pre><code class="language-cpp">#ifndef __DRI_TIMER0_H__
#define __DRI_TIMER0_H__

void Dri_Timer0_Init();//定时器0开关，启动函数

#endif /* __DRI_TIMER0_H__ */</code></pre> 
<p>main.c</p> 
<pre><code class="language-cpp">#include &lt;STC89C5xRC.H&gt;
#include "Dri_Timer0.h"
#include "Com_Util.h"
#define LED1 P00
void main()
{
     Dri_Timer0_Init();
     while(1);
}
//定时中断服务程序
void Timer0_Hander() interrupt 0
{
    LED1=~LED1;
    Com_Util_Delay1ms(500);
}</code></pre> 
<h3>6.定时器封装</h3> 
<p>为使定时器使用起来更加方便和通用，我们可以将定时器代码进一步封装。</p> 
<h4 style="background-color:transparent;">（1）思路</h4> 
<p>初始化定时器--&gt;中断服务程序，轮询调用函数.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/76c001e5ef17e545276dab622483c100/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">代码随想录：377. 组合总和 Ⅳ</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9756f6539b5e2c952aa6e3b41d499f1f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【LeetCode】：面试题 16.05. 阶乘尾数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>