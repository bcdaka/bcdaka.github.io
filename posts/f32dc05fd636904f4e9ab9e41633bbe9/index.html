<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】——双链表的实现（赋源码） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f32dc05fd636904f4e9ab9e41633bbe9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】——双链表的实现（赋源码）">
  <meta property="og:description" content="双链表的概念和结构 双链表的全称叫做：带头双向循环链表
它的结构示意图如下
注意：这⾥的“带头”跟前⾯我们说的单链表的“头结点”是两个概念，实际前⾯的在单链表阶段称呼不严谨，但是为了读者们更好的理解就直接称为单链表的头结点。 带头链表⾥的头结点，实际为“哨兵位”，哨兵位结点不存储任何有效元素，只是站在这⾥“放哨的”也可以认为是用来占位置滴！！！
双链表的实现 首先先在结构体当中输入需要的数据，则有如下的数据是需要的
结构体中的数据 typedef int LTDataType;//方便对数据类型进行统一的替换 typedef struct ListNode ListNode;//对结构体的名称重新命名交ListNode struct ListNode { LTDataType data; ListNode* next; ListNode* prev; }; 则上面的图可以变成这样
双链表新结点的创建及双链表的初始化 ListNode* LTBuyNode(LTDataType x) { ListNode* newnode = (ListNode*)malloc(sizeof(ListNode));//一个结构体的大小 if (newnode == NULL) { perror(&#34;malloc fail!&#34;); exit(1); } newnode-&gt;data = x; newnode-&gt;next = newnode-&gt;prev = newnode; return newnode;//返回头结点 } 链表的初始化需要一个创建的新的结点作为哨兵位
//void LTInit(ListNode** pphead) //{ //	//创建一个头结点即“哨兵位” //	*pphead = LTBuyNode(-1); //} ListNode* LTInit() { ListNode* phead = LTBuyNode(-1); return phead; } //上面是两种初始化的方法 //第一种需要传递一个二级指针 在上面的代码当中，我们只需要创建一个头结点来保证第一个“头”存在即可。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T08:52:56+08:00">
    <meta property="article:modified_time" content="2024-07-24T08:52:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】——双链表的实现（赋源码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>双链表的概念和结构</h2> 
<p>双链表的全称叫做：<span style="color:#956fe7;"><strong>带头双向循环链表</strong></span></p> 
<p>它的结构示意图如下</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/7c/6e/yHuErDgP_o.png" width="1200"></p> 
<p>注意：这⾥的“带头”跟前⾯我们说的单链表的“头结点”是两个概念，实际前⾯的在单链表阶段称呼不严谨，但是为了读者们更好的理解就直接称为单链表的头结点。 </p> 
<p>带头链表⾥的头结点，实际为“<span style="color:#ff9900;"><strong>哨兵位</strong></span>”，哨兵位结点不存储任何有效元素，只是站在这⾥“放哨的”也可以认为是用来占位置滴！！！</p> 
<h2>双链表的实现</h2> 
<p>首先先在结构体当中输入需要的数据，则有如下的数据是需要的</p> 
<h3>结构体中的数据</h3> 
<pre><code>typedef int LTDataType;//方便对数据类型进行统一的替换
typedef struct ListNode ListNode;//对结构体的名称重新命名交ListNode
struct ListNode
{
	LTDataType data;
	ListNode* next;
	ListNode* prev;
};
</code></pre> 
<p>则上面的图可以变成这样</p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/0a/5c/AN0Pb0HV_o.png" width="1200"></p> 
<h2>双链表新结点的创建及双链表的初始化</h2> 
<pre><code>ListNode* LTBuyNode(LTDataType x)
{
	ListNode* newnode = (ListNode*)malloc(sizeof(ListNode));//一个结构体的大小
	if (newnode == NULL)
	{
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = newnode-&gt;prev = newnode;

	return newnode;//返回头结点
}</code></pre> 
<p>链表的初始化需要一个创建的新的结点作为哨兵位</p> 
<pre><code>//void LTInit(ListNode** pphead)
//{
//	//创建一个头结点即“哨兵位”
//	*pphead = LTBuyNode(-1);
//}

ListNode* LTInit()
{
	ListNode* phead = LTBuyNode(-1);
	return phead;
}

//上面是两种初始化的方法
//第一种需要传递一个二级指针
</code></pre> 
<p>在上面的代码当中，我们只需要创建一个头结点来保证第一个“头”存在即可。</p> 
<blockquote> 
 <p>插入<br> 第一个参数传一级还是二级，要看phead指向的结点会不会改变<br> 如果发生改变，那么pphead的改变要影响实参，传二级<br> 如果不发生改变，pphead不会影响实参，传一级</p> 
</blockquote> 
<h2>双链表的尾插</h2> 
<pre><code>//尾插
void LTPushBack(ListNode* phead, LTDataType x)
{
	assert(phead);
	//创建需要插入的结点
    //上面初始化的newnode是头结点，这个newnode是尾插的结点
	ListNode* newnode = LTBuyNode(x);

	newnode-&gt;next = phead;
	newnode-&gt;prev = phead-&gt;prev;

	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}</code></pre> 
<p><img alt="" height="757" src="https://images2.imgbox.com/f6/55/nE5oDIbC_o.png" width="1200"></p> 
<blockquote> 
 <p><strong> 上面的顺序是不能改变的，否则无法让新结点找到原来链表的位置</strong></p> 
</blockquote> 
<p>这边测试一下我们的尾插代码依次插入1 2 3 4  </p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/08/27/3fHuYvZG_o.png" width="1000"></p> 
<h2> 双链表的头插</h2> 
<pre><code>//头插
void LTPushFront(ListNode* phead, LTDataType x)
{
	assert(phead);
	ListNode* newnode = LTBuyNode(x);

	newnode-&gt;next = phead-&gt;next;
	newnode-&gt;prev = phead;

	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>头插和尾插是类似的 ，</strong></span><span style="color:#0d0016;">不过有一个特殊的地方</span></p> 
<p><span style="color:#fe2c24;"><strong>头插是头插在哨兵位和第一个真正的结点中间</strong></span></p> 
<p><img alt="" height="618" src="https://images2.imgbox.com/c5/a6/fc6MlDMl_o.png" width="1200"></p> 
<blockquote> 
 <p>同样的，上面的顺序位置是不能改变的</p> 
</blockquote> 
<p>测试头插代码</p> 
<p><span style="color:#ff9900;"><strong>这个代码是在上面尾插代码基础上的操作</strong></span></p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/93/e4/7e7qcOn0_o.png" width="801"></p> 
<h2> 双链表的尾删</h2> 
<pre><code>//尾删
void LTPopBack(ListNode* phead)
{
	assert(phead);
	assert(!Empty(phead));

	ListNode* del = phead-&gt;prev;
	ListNode* prev = del-&gt;prev;

	prev-&gt;next = phead;
	phead-&gt;prev = prev;

	free(del);
	del = NULL;
}</code></pre> 
<p><img alt="" height="744" src="https://images2.imgbox.com/4a/3f/CDSXpTrB_o.png" width="1200"> 这边仍然是在尾插的基础上的操作</p> 
<p>这边我们进行了五次尾删，所以代码assert断言了！</p> 
<p><img alt="" height="444" src="https://images2.imgbox.com/17/a4/mZTfW7vl_o.png" width="1200"></p> 
<p>将一次尾删注释，下面就是尾删的效果 </p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/4f/30/XCcDH4Br_o.png" width="714"></p> 
<h2>双链表的头删 </h2> 
<pre><code>//头删
void LTPopFront(ListNode* phead)
{
	assert(phead);
	assert(!Empty(phead));
	ListNode* del = phead-&gt;next;
	del-&gt;next-&gt;prev = phead;
	phead-&gt;next = del-&gt;next;

	free(del);
	del = NULL;
}</code></pre> 
<p><img alt="" height="702" src="https://images2.imgbox.com/60/f5/QaTIzRsX_o.png" width="1200"></p> 
<p>这个仍然是在尾插的基础上操作的，如果继续删除，跟上面的情况一样assert断言报错 </p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/99/91/L5j77Vwf_o.png" width="949"></p> 
<p><strong>以上就是最基础的增删 ，下面开始加大难度！</strong></p> 
<h2><strong>双链表中查找数据pos</strong></h2> 
<pre><code>//找相同数据
ListNode* LTFind(ListNode* phead, LTDataType x)
{
	assert(phead);
	ListNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		if (pcur-&gt;data == x)
		{
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;
}</code></pre> 
<p><img alt="" height="693" src="https://images2.imgbox.com/ec/71/va8VMV3a_o.png" width="1200"></p> 
<p>这边我们查找的是数据3，所以我们可以找到 </p> 
<p> <img alt="" height="434" src="https://images2.imgbox.com/37/c9/XyDwbbie_o.png" width="759"></p> 
<p>这个在链表中没有数据6，所以我们没有找到相关的数据 </p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/d0/6c/9j0Sdat3_o.png" width="812"></p> 
<h2> 在pos之后插入结点</h2> 
<p>这个和尾插以及头插其实是类似的，这里主要是寻找到pos结点，然后插入想要的数据</p> 
<pre><code>//在pos之后插入结点
void LTInsert(ListNode* pos, LTDataType x)
{
    assert(pos);

    ListNode* newnode = LTBuyNode(x);

    newnode-&gt;next = pos-&gt;next;
    newnode-&gt;prev = pos;

    pos-&gt;next-&gt;prev = newnode;
    pos-&gt;next = newnode;
}</code></pre> 
<p>在3的后面插入数据10 </p> 
<p> <img alt="" height="234" src="https://images2.imgbox.com/74/2c/JxiK5OWU_o.png" width="650"></p> 
<h2>删除pos结点 </h2> 
<pre><code>​//删除指定位置节点
void LTErase(ListNode* pos)
{
	assert(pos);
	// pos-&gt;prev  pos   pos-&gt;next

	pos-&gt;prev-&gt;next = pos-&gt;next;
	pos-&gt;next-&gt;prev = pos-&gt;prev;

	free(pos);
	pos = NULL;
}

​</code></pre> 
<p><img alt="" height="315" src="https://images2.imgbox.com/b5/50/wpK0s3X4_o.png" width="846"></p> 
<h2>双链表的销毁 </h2> 
<p>这里我们提供了两种的销毁方法，两种方法基本是类似的</p> 
<pre><code>//销毁
void LTDesTroy(ListNode** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	ListNode* pcur = (*pphead)-&gt;next;
	while (pcur != *pphead)
	{
		ListNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	//销毁哨兵位结点
	free(*pphead);
	*pphead = NULL;
	pcur = NULL;
}
//为了更好的记忆，我们让销毁也传递一级指针
void LTDesTroy2(ListNode* phead)//传一级，需要手动将plist置为NULL
{
	assert(phead);
	ListNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		ListNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	free(phead);
	phead = pcur = NULL;
}</code></pre> 
<p><strong>最后我们将双向链表的源码附上</strong></p> 
<blockquote> 
 <p><strong>list.h</strong></p> 
</blockquote> 
<pre><code>#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int LTDataType;
typedef struct ListNode ListNode;
struct ListNode
{
	LTDataType data;
	ListNode* next;
	ListNode* prev;
};

ListNode* LTBuyNode(LTDataType x);
//为了保存接口的一致性
//
//初始化
//void LTInit(ListNode** pphead);
ListNode* LTInit();  

//
void LTPrint(ListNode* phead);

bool Empty(ListNode* phead);

//插入
//第一个参数传一级还是二级，要看phead指向的结点会不会改变
//如果发生改变，那么pphead的改变要影响实参，传二级
//如果不发生改变，pphead不会影响实参，传一级

//尾插
void LTPushBack(ListNode* phead, LTDataType x);

//头插
void LTPushFront(ListNode* phead, LTDataType x);

//尾删
void LTPopBack(ListNode* phead);

//头删
void LTPopFront(ListNode* phead);

//在pos之后插入结点
void LTInsert(ListNode* pos, LTDataType x);

//删除指定位置的结点
void LTErase(ListNode* pos);

//找数据
ListNode* LTFind(ListNode* phead, LTDataType x);

//销毁
void LTDesTroy(ListNode** pphead);
void LTDesTroy2(ListNode* phead);//传一级，需要手动将plist置为NULL</code></pre> 
<blockquote> 
 <p> List.c</p> 
</blockquote> 
<pre><code>#include"List.h"

ListNode* LTBuyNode(LTDataType x)
{
	ListNode* newnode = (ListNode*)malloc(sizeof(ListNode));
	if (newnode == NULL)
	{
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = newnode-&gt;prev = newnode;

	return newnode;
}
//初始化

//void LTInit(ListNode** pphead)
//{
//	//创建一个头结点即“哨兵位”
//	*pphead = LTBuyNode(-1);
//}
ListNode* LTInit()
{
	ListNode* phead = LTBuyNode(-1);
	return phead;
}

//打印
void LTPrint(ListNode* phead)
{
	ListNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}

bool Empty(ListNode* phead)
{
	assert(phead);
	return phead-&gt;next == phead;
}

//尾插
void LTPushBack(ListNode* phead, LTDataType x)
{
	assert(phead);
	//创建需要插入的结点
	ListNode* newnode = LTBuyNode(x);

	newnode-&gt;next = phead;
	newnode-&gt;prev = phead-&gt;prev;

	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}
//头插
void LTPushFront(ListNode* phead, LTDataType x)
{
	assert(phead);
	ListNode* newnode = LTBuyNode(x);

	newnode-&gt;next = phead-&gt;next;
	newnode-&gt;prev = phead;

	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}

//尾删
void LTPopBack(ListNode* phead)
{
	assert(phead);
	assert(!Empty(phead));

	ListNode* del = phead-&gt;prev;
	ListNode* prev = del-&gt;prev;

	prev-&gt;next = phead;
	phead-&gt;prev = prev;

	free(del);
	del = NULL;
}

//头删
void LTPopFront(ListNode* phead)
{
	assert(phead);
	assert(!Empty(phead));
	ListNode* del = phead-&gt;next;
	del-&gt;next-&gt;prev = phead;
	phead-&gt;next = del-&gt;next;

	free(del);
	del = NULL;
}
//找相同数据
ListNode* LTFind(ListNode* phead, LTDataType x)
{
	assert(phead);
	ListNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		if (pcur-&gt;data == x)
		{
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;
}

//在pos之后插入结点
void LTInsert(ListNode* pos, LTDataType x)
{
	assert(pos);

	ListNode* newnode = LTBuyNode(x);

	newnode-&gt;next = pos-&gt;next;
	newnode-&gt;prev = pos;

	pos-&gt;next-&gt;prev = newnode;
	pos-&gt;next = newnode;
}

//删除指定位置节点
void LTErase(ListNode* pos)
{
	assert(pos);
	// pos-&gt;prev  pos   pos-&gt;next

	pos-&gt;prev-&gt;next = pos-&gt;next;
	pos-&gt;next-&gt;prev = pos-&gt;prev;

	free(pos);
	pos = NULL;
}

//销毁
void LTDesTroy(ListNode** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	ListNode* pcur = (*pphead)-&gt;next;
	while (pcur != *pphead)
	{
		ListNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	//销毁哨兵位结点
	free(*pphead);
	*pphead = NULL;
	pcur = NULL;
}

void LTDesTroy2(ListNode* phead)
{
	assert(phead);
	ListNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		ListNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	free(phead);
	phead = pcur = NULL;
}</code></pre> 
<blockquote> 
 <p>test.c </p> 
</blockquote> 
<p></p> 
<pre><code>#include"List.h"
void test()
{
	创建双向链表变量
	//ListNode* plist = NULL;
	//LTInit(&amp;plist);
	ListNode* plist = LTInit();

	LTPushBack(plist, 1);
	LTPushBack(plist, 2);
	LTPushBack(plist, 3);
	LTPushBack(plist, 4);
	LTPrint(plist);

	ListNode* pos = LTFind(plist, 3);
	LTInsert(pos, 10);
	LTPrint(plist);

	pos = LTFind(plist, 3);
	LTErase(pos);
	LTPrint(plist);

	/*LTPopFront(plist);
	LTPrint(plist);
	LTPopFront(plist);
	LTPrint(plist);
	LTPopFront(plist);
	LTPrint(plist);
	LTPopFront(plist);
	LTPrint(plist);*/

	/*LTPushFront(plist, 1);
	LTPrint(plist);
	LTPushFront(plist, 2);
	LTPrint(plist);
	LTPushFront(plist, 3);
	LTPrint(plist);
	LTPushFront(plist, 4);
	LTPrint(plist);*/

	/*LTPopBack(plist);
	LTPrint(plist);
	LTPopBack(plist);
	LTPrint(plist);
	LTPopBack(plist);
	LTPrint(plist);
	LTPopBack(plist);
	LTPrint(plist);
	LTPopBack(plist);
	LTPrint(plist);*/

	/*if (pos == NULL)
	{
		printf("没有找到\n");
	}
	else
	{
		printf("找到了\n");
	}*/

	LTDesTroy(&amp;plist);
	//LTDesTroy2(plist);
	//plist = NULL;


	
}

int main()
{
	test();
	return 0;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6916d15a800e9ca7e032e06aa788bf93/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python酷库之旅-第三方库Pandas(042)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6302e95864fd1b4fccb9bb6e30a301a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 实现分页的几种方式详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>