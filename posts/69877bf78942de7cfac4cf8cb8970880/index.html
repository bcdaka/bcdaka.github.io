<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】list 容器的增删改查---模拟实现（图例超详细解析！！！） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/69877bf78942de7cfac4cf8cb8970880/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】list 容器的增删改查---模拟实现（图例超详细解析！！！）">
  <meta property="og:description" content="目录
一、前言
二、 list 容器的模拟实现思
✨ 模块分析
✨ 作用分析
三、list的节点类设计 四、list 的迭代器类设计
⭐ 迭代器类--存在的意义
⭐ 迭代器类--模拟实现
💦 模板参数 和 成员变量
💦 构造函数 💦 &#43;&#43;运算符的重载 💦 -- 运算符的重载
💦 重载 != 和 ==
💦 * 运算符的重载
💦 -&gt; 运算符的重载
💦 迭代器类 总体代码
五、list 结构的完善
🥝成员变量和模板参数 🍍 默认成员函数
⚡构造函数
⚡拷贝构造
⚡迭代器区间构造 ⚡n个相同元素构造 ⚡赋值重载 ⚡析构函数
🍇迭代器相关函数
⚡begin 和 end 🍓访问容器相关函数
⚡fron 和 back 🍑增删改查相关函数
⚡insert -- 插入
⚡erase
⚡push_back 和 pop_back
⚡push_front 和 pop_front">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-12T09:22:14+08:00">
    <meta property="article:modified_time" content="2024-06-12T09:22:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】list 容器的增删改查---模拟实现（图例超详细解析！！！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">一、前言</a></p> 
<p id="%E4%BA%8C%E3%80%81%20list%20%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%9D-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%20list%20%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%9D" rel="nofollow">二、 list 容器的模拟实现思</a></p> 
<p id="%E2%9C%A8%20%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E2%9C%A8%20%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90" rel="nofollow">✨ 模块分析</a></p> 
<p id="%C2%A0%E2%9C%A8%20%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%C2%A0%E2%9C%A8%20%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90" rel="nofollow"> ✨ 作用分析</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81list%E7%9A%84%E8%8A%82%E7%82%B9%E7%B1%BB%E8%AE%BE%E8%AE%A1%C2%A0-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81list%E7%9A%84%E8%8A%82%E7%82%B9%E7%B1%BB%E8%AE%BE%E8%AE%A1%C2%A0" rel="nofollow"> 三、list的节点类设计 </a></p> 
<p id="%E5%9B%9B%E3%80%81list%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81list%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E8%AE%BE%E8%AE%A1" rel="nofollow">四、list 的迭代器类设计</a></p> 
<p id="%C2%A0%E2%AD%90%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB--%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89-toc" style="margin-left:40px;"><a href="#%C2%A0%E2%AD%90%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB--%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89" rel="nofollow"> ⭐ 迭代器类--存在的意义</a></p> 
<p id="%C2%A0%E2%AD%90%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB--%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E2%AD%90%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB--%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow"> ⭐ 迭代器类--模拟实现</a></p> 
<p id="%C2%A0%F0%9F%92%A6%20%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%20%E5%92%8C%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%20%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%20%E5%92%8C%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" rel="nofollow">💦 模板参数 和 成员变量</a></p> 
<p id="%F0%9F%92%A6%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:80px;"><a href="#%F0%9F%92%A6%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">💦 构造函数 </a></p> 
<p id="%F0%9F%92%A6%C2%A0%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%C2%A0-toc" style="margin-left:80px;"><a href="#%F0%9F%92%A6%C2%A0%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%C2%A0" rel="nofollow">💦 ++运算符的重载 </a></p> 
<p id="%C2%A0%F0%9F%92%A6%C2%A0--%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%C2%A0--%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD" rel="nofollow">💦 -- 运算符的重载</a></p> 
<p id="%C2%A0%F0%9F%92%A6%C2%A0%E9%87%8D%E8%BD%BD%20!%3D%20%E5%92%8C%20%3D%3D-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%C2%A0%E9%87%8D%E8%BD%BD%20!%3D%20%E5%92%8C%20%3D%3D" rel="nofollow">💦 重载 != 和 ==</a></p> 
<p id="%C2%A0%F0%9F%92%A6%C2%A0*%20%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%C2%A0*%20%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD" rel="nofollow">💦 * 运算符的重载</a></p> 
<p id="%C2%A0%F0%9F%92%A6%20-%3E%20%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%20-%3E%20%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD" rel="nofollow">💦 -&gt; 运算符的重载</a></p> 
<p id="%C2%A0%F0%9F%92%A6%C2%A0%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%20%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%C2%A0%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%20%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81" rel="nofollow">💦 迭代器类 总体代码</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81list%20%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%8C%E5%96%84-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81list%20%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%8C%E5%96%84" rel="nofollow"> 五、list 结构的完善</a></p> 
<p id="%F0%9F%A5%9D%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%A5%9D%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%C2%A0" rel="nofollow">🥝成员变量和模板参数 </a></p> 
<p id="%F0%9F%8D%8D%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8D%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">🍍 默认成员函数</a></p> 
<p id="%E2%9A%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E2%9A%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">⚡构造函数</a></p> 
<p id="%C2%A0%E2%9A%A1%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%9A%A1%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0" rel="nofollow"> ⚡拷贝构造</a></p> 
<p id="%E2%9A%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8C%BA%E9%97%B4%E6%9E%84%E9%80%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%9A%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8C%BA%E9%97%B4%E6%9E%84%E9%80%A0%C2%A0" rel="nofollow">⚡迭代器区间构造 </a></p> 
<p id="%E2%9A%A1n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%9E%84%E9%80%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%9A%A1n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%9E%84%E9%80%A0%C2%A0" rel="nofollow">⚡n个相同元素构造 </a></p> 
<p id="%E2%9A%A1%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%9A%A1%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%C2%A0" rel="nofollow">⚡赋值重载 </a></p> 
<p id="%E2%9A%A1%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E2%9A%A1%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">⚡析构函数</a></p> 
<p id="%C2%A0%F0%9F%8D%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" rel="nofollow"> 🍇迭代器相关函数</a></p> 
<p id="%E2%9A%A1begin%20%E5%92%8C%20end%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%9A%A1begin%20%E5%92%8C%20end%C2%A0" rel="nofollow">⚡begin 和 end </a></p> 
<p id="%C2%A0%F0%9F%8D%93%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%93%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" rel="nofollow"> 🍓访问容器相关函数</a></p> 
<p id="%E2%9A%A1fron%20%E5%92%8C%20back%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%9A%A1fron%20%E5%92%8C%20back%C2%A0" rel="nofollow">⚡fron 和 back </a></p> 
<p id="%C2%A0%F0%9F%8D%91%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%91%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" rel="nofollow"> 🍑增删改查相关函数</a></p> 
<p id="%E2%9A%A1insert%20--%20%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E2%9A%A1insert%20--%20%E6%8F%92%E5%85%A5" rel="nofollow">⚡insert -- 插入</a></p> 
<p id="%E2%9A%A1erase-toc" style="margin-left:80px;"><a href="#%E2%9A%A1erase" rel="nofollow">⚡erase</a></p> 
<p id="%E2%9A%A1push_back%20%E5%92%8C%20pop_back-toc" style="margin-left:80px;"><a href="#%E2%9A%A1push_back%20%E5%92%8C%20pop_back" rel="nofollow">⚡push_back 和 pop_back</a></p> 
<p id="%E2%9A%A1push_front%20%E5%92%8C%20pop_front-toc" style="margin-left:80px;"><a href="#%E2%9A%A1push_front%20%E5%92%8C%20pop_front" rel="nofollow">⚡push_front 和 pop_front</a></p> 
<p id="%C2%A0%F0%9F%8D%89%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%89%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" rel="nofollow"> 🍉容量相关函数</a></p> 
<p id="%E2%9A%A1size-toc" style="margin-left:80px;"><a href="#%E2%9A%A1size" rel="nofollow">⚡size</a></p> 
<p id="%E2%9A%A1empty-toc" style="margin-left:80px;"><a href="#%E2%9A%A1empty" rel="nofollow">⚡empty</a></p> 
<p id="%E2%9A%A1resize-toc" style="margin-left:80px;"><a href="#%E2%9A%A1resize" rel="nofollow">⚡resize</a></p> 
<p id="%E2%9A%A1clear-toc" style="margin-left:80px;"><a href="#%E2%9A%A1clear" rel="nofollow">⚡clear</a></p> 
<p id="%E5%85%AD%E3%80%81list%C2%A0%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81list%C2%A0%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81" rel="nofollow">六、list 容器的模拟实现整体代码</a></p> 
<p id="%F0%9F%8D%88list.h%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%88list.h%C2%A0" rel="nofollow">🍈list.h </a></p> 
<p id="%F0%9F%8D%91list.cpp-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%91list.cpp" rel="nofollow">🍑list.cpp</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%85%B1%E5%8B%89-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E5%85%B1%E5%8B%89" rel="nofollow">七、共勉</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2><span style="color:#0d0016;"><strong>一、前言</strong></span></h2> 
<blockquote> 
 <p>       <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;"> STL</span></strong></span> 中的<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;"> list</span></strong></span> 是一个<span style="color:#956fe7;"><strong>带头双向循环链表</strong></span>，作为<span style="color:#0d0016;"><strong>链表的终极形态</strong></span>，各项操作性能都很优秀，尤其是 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list 中迭代器</span></strong></span>的设计更是让人<span style="color:#0d0016;"><strong>拍案叫绝</strong></span>，如此优秀的容器究竟是如何实现的呢？本文将会带大家一起从<span style="color:#956fe7;"><strong>0~1 去模拟实现STL库中的 </strong></span><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list 容器</span></strong></span>，以便于让大家更好的巩固之前学习过的 <span style="color:#956fe7;"><strong>缺省参数、封装、类的6大默认函数</strong></span>等。</p> 
 <p><br> 如果大家还有<span style="color:#0d0016;"><strong>不太了解 </strong></span><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list  容器</span></strong></span>的可以先<span style="color:#0d0016;"><strong>看看两篇文章：</strong></span><br><strong>1️⃣：<a class="link-info" href="https://blog.csdn.net/weixin_45031801/article/details/138534695" title="带头双向循环链表详解">带头双向循环链表详解</a><br> 2️⃣：<a class="link-info" href="https://blog.csdn.net/weixin_45031801/article/details/139361653" title="list 容器最全解析">list 容器最全解析</a></strong></p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%20list%20%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%9D"><span style="color:#0d0016;"><strong>二、 list 容器的模拟实现思</strong></span></h2> 
<p class="img-center"><img alt="" height="607" src="https://images2.imgbox.com/29/70/l1K5jRfb_o.png" width="961"></p> 
<h3 id="%E2%9C%A8%20%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90"><span style="color:#0d0016;"><strong>✨ 模块分析</strong></span></h3> 
<blockquote> 
 <p> 根据 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list 容器图</span></strong></span>可以分析一下 <span style="color:#0d0016;"><strong>模拟实现</strong></span> <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list容器</span></strong></span> <span style="color:#956fe7;"><strong>都要准备什么？</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="366" src="https://images2.imgbox.com/a8/23/uqWcfxHh_o.png" width="1137"></p> 
<ul><li><span style="color:#0d0016;"><strong> </strong></span><span style="color:#956fe7;"><strong>存储元素需要结点</strong></span><span style="color:#0d0016;"><strong>---&gt;</strong></span><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">结点类</span></strong></span></li><li> <span style="color:#956fe7;"><strong>使用迭代器访问结点</strong></span><span style="color:#0d0016;"><strong>---&gt;</strong></span><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">迭代器类</span></strong></span></li><li> <span style="color:#956fe7;"><strong>总体</strong></span><span style="color:#0d0016;"><strong>---&gt;</strong></span><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list类</span></strong></span></li></ul> 
<h3 id="%C2%A0%E2%9C%A8%20%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90"><span style="color:#0d0016;"><strong> ✨ 作用分析</strong></span></h3> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong> 1️⃣</strong></span><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">：节点类</span></strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/bd/28/lNB0WBDc_o.png" width="989"></p> 
<p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">作用：</span></strong></span>存储 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list容器</span></strong></span> 的元素，因为list里面要<span style="color:#956fe7;"><strong>存储各种类型的元素</strong></span>，所以结点类需要定义成<strong><span style="color:#956fe7;">模版</span>。</strong>结点类中的成员变量则是有三个，分别是：指向<span style="color:#be191c;"><strong>前一个结点</strong></span>的_<strong><span style="color:#956fe7;">prev</span></strong>指针，指向<span style="color:#be191c;"><strong>后一个结点</strong></span>的_<span style="color:#956fe7;"><strong>next</strong></span>指针，<span style="color:#be191c;"><strong>存储结点元素</strong></span>的<span style="color:#956fe7;"><strong>_data</strong></span>变量。</p> 
<hr> 
<blockquote> 
 <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">2️⃣: 迭代器类 </span></strong></span></p> 
</blockquote> 
<ul><li>此时大家可以思考这样一个问题，<strong>在<span style="color:#956fe7;">模拟实现vector类</span>时，我们是直接用<span style="color:#be191c;">结点指针作为迭代器来使用的</span>，并没有自己实现迭代器类。<span style="color:#be191c;"><span style="background-color:#fef2f0;">list中为什么需要单独实现迭代器类？</span></span></strong></li></ul> 
<p class="img-center"><img alt="" height="642" src="https://images2.imgbox.com/4d/d9/LfP1ypmH_o.png" width="1141"></p> 
<p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">原因：</span></strong></span>如上图所示。<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">vector容器</span></strong></span><span style="color:#0d0016;"><strong>是数组</strong></span>，它的<span style="color:#956fe7;"><strong>空间是连续的</strong></span>，所以结点<span style="color:#0d0016;"><strong>指针完全可以通过自增的方式来指向下一个结点</strong></span>。可是<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list容器</span></strong></span><span style="color:#0d0016;"><strong>是链表</strong></span>，它的<span style="color:#956fe7;"><strong>空间并不连续</strong></span>，自然<span style="color:#0d0016;"><strong>不可能直接通过结点指针的自增来指向下一个链表结点</strong></span>，所以我们才<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">需要自己实现迭代器类，并且重载自增与自减运算符，这样就可以通过迭代器的自增或自减来指向前后结点了。</span></strong></span></p> 
<hr> 
<blockquote> 
 <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">3️⃣<strong> ：list类</strong></span></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="613" src="https://images2.imgbox.com/3b/84/XJPYruZk_o.png" width="1023"></p> 
<p> <strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">作用：</span></span><span style="color:#0d0016;">实现链表各项功能的类，为主要部分</span></strong></p> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81list%E7%9A%84%E8%8A%82%E7%82%B9%E7%B1%BB%E8%AE%BE%E8%AE%A1%C2%A0"><span style="color:#0d0016;"><strong> 三、list的节点类设计 </strong></span></h2> 
<blockquote> 
 <p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">list本身</span></span> 和<span style="color:#be191c;"><span style="background-color:#fef2f0;"> list的结点</span></span> 是<span style="color:#956fe7;">两个不同的结构</span>，需要分开设计。以下是list的节</strong><strong>点结构： </strong> </p> 
</blockquote> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/62/49/hUzlhzWz_o.png" width="989"></p> 
<pre><code class="hljs">/*ListNode.h*/
namespace xas_list
{
	template&lt;class T&gt;
	struct ListNode
	{
		ListNode&lt;T&gt;* _prev; //节点的前指针
		ListNode&lt;T&gt;* _next; //节点的后指针
		T _data;            //节点的数据
 
		ListNode(const T&amp; x= T())//初始化列表进行初始化
			:_prev(nullptr)
			,_next(nullptr)
			,_data(x)
		{}
		
	};
}</code></pre> 
<blockquote> 
 <p>        首先，我们在<span style="color:#0d0016;"><strong>自己的命名空间内模拟实现 list</strong></span>（为了防止与库冲突），上面的代码就是<span style="color:#0d0016;"><strong>list节点的结构</strong></span>。<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">在这里是用并没有使用 class，因为 struct 默认访问权限是 public，又因为节点是需要经常访问的，所以使用struct更好。</span></strong></span></p> 
 <p>        我们将这个类加上<span style="color:#956fe7;"><strong> template&lt;class T&gt;</strong></span> 后，就能够实现节点存储不同类型的数据，这也是<span style="color:#956fe7;"><strong>C++模板</strong></span>的好处。</p> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81list%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span style="color:#0d0016;"><strong>四、list 的迭代器类设计</strong></span></h2> 
<h3 id="%C2%A0%E2%AD%90%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB--%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span style="color:#0d0016;"><strong> ⭐ 迭代器类--存在的意义</strong></span></h3> 
<blockquote> 
 <p>       之前 <span style="color:#956fe7;"><strong>模拟实现 string </strong></span>和 <span style="color:#956fe7;"><strong>vector </strong></span>时都<span style="color:#0d0016;"><strong>没有</strong></span>说要实现一个<span style="color:#0d0016;"><strong>迭代器类</strong></span>，<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">为什么实现list的时候就需要实现一个迭代器类了呢？</span></strong></span></p> 
</blockquote> 
<ul><li> 因为 <span style="color:#956fe7;"><strong>string </strong></span>和 <span style="color:#956fe7;"><strong>vector</strong></span> 对象都将其<span style="color:#0d0016;"><strong>数据存储在了一块连续的内存空间</strong></span>，我们通过<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">指针进行自增、自减以及解引用等操作</span></strong></span>，就可以对相应位置的数据进行一系列操作，因此string和vector当中的迭代器就是原生指针。</li></ul> 
<p class="img-center"><img alt="" height="249" src="https://images2.imgbox.com/ce/2f/Bl5gJBCW_o.png" width="1111"></p> 
<ul><li> 但是对于 <span style="color:#956fe7;"><strong>list</strong></span> 来说，其<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">各个结点在内存当中的位置是随机</span></strong></span>的，<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">并不是连续的</span></strong></span>，<span style="color:#0d0016;"><strong>我们不能仅通过结点指针的自增、自减以及解引用等操作对相应结点的数据进行操作。</strong></span></li></ul> 
<p class="img-center"><img alt="" height="387" src="https://images2.imgbox.com/75/30/Fmnt68fA_o.png" width="1107"></p> 
<ul><li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;"> 而迭代器的意义就是</span></strong></span>，让<span style="color:#0d0016;"><strong>使用者</strong></span>可以<span style="color:#956fe7;"><strong>不必关心容器的底层实现</strong></span>，可以用简单统一的方式对容器内的数据进行访问。</li><li>既然 <span style="color:#956fe7;"><strong>list </strong></span>的<span style="color:#0d0016;"><strong>结点指针的行为不满足迭代器定义</strong></span>，那么我们可以对<span style="color:#0d0016;"><strong>这个结点指针进行封装</strong></span>，<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">对结点指针的各种运算符操作进行重载</span></strong></span>，使得我们可以用和string和vector当中的迭代器一样的方式使用list当中的迭代器。例如，当你使用<span style="color:#956fe7;"><strong> list 当中的迭代器进行自增操作时，实际上执行了p = p-&gt;next语句，只是你不知道而已。</strong></span></li></ul> 
<blockquote> 
 <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">总结：</span></strong></span><span style="color:#0d0016;"><strong>list迭代器类</strong></span>，实际上就是对<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">结点指针进行了封装</span></strong></span>，对其各种<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">运算符进行了重载</span></strong></span>，<span style="color:#0d0016;"><strong>使得结点指针的各种行为看起来和普通指针一样</strong></span>。（<span style="color:#956fe7;"><strong>例如，对结点指针自增就能指向下一个结点） </strong></span></p> 
</blockquote> 
<h3 id="%C2%A0%E2%AD%90%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB--%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span style="color:#0d0016;"><strong> ⭐ 迭代器类--模拟实现</strong></span></h3> 
<h4 id="%C2%A0%F0%9F%92%A6%20%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%20%E5%92%8C%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span style="color:#0d0016;"><strong> 💦 模板参数 和 成员变量</strong></span></h4> 
<ul><li> 我们为 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">迭代器类</span></strong></span> 设置了 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">三个模板参数</span></strong></span>，<span style="color:#956fe7;"><strong>为什么有三个模板参数？</strong></span></li></ul> 
<pre><code class="hljs">template&lt;class T, class Ref, class Ptr&gt;</code></pre> 
<ul><li> 在<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;"> list</span></strong></span> 的模拟实现当中，我们 typedef 了两个迭代器类型，<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">普通迭代器</span></strong></span> 和 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">const迭代器</span></strong></span>。</li></ul> 
<pre><code class="hljs">typedef _list_iterator&lt;T, T&amp;, T*&gt; iterator;
typedef _list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;
</code></pre> 
<ul><li>这里我们就可以看出，<span style="color:#956fe7;"><strong>迭代器类 </strong></span>的模板参数列表当中的 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">Ref</span></strong></span> 和 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">Ptr</span></strong></span> 分别代表的是 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">引用类型（T&amp;）</span></strong></span> 和 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">指针类型（T *）</span></strong></span>。 </li><li>当我们使用 <span style="color:#0d0016;"><strong>普通迭代器</strong></span> 时，编译器就会实例化出一个 <span style="color:#0d0016;"><strong>普通迭代器 对象</strong></span>；当我们使用<span style="color:#0d0016;"><strong> const迭代器时</strong></span>，编译器就会实例化出一个<span style="color:#0d0016;"><strong> const迭代器对象</strong></span>。 </li><li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">若该迭代器类不设计三个模板参数，那么就不能很好的区分-- 普通迭代器 和-- const迭代器。 </span></strong></span></li></ul> 
<hr> 
<ul><li>因为 <span style="color:#956fe7;"><strong>结点类</strong></span> 和 <span style="color:#956fe7;"><strong>迭代器类</strong></span> 自身的类型<span style="color:#0d0016;"><strong>名太长</strong></span>，写起来太麻烦，所以我们用 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">typedef关键字</span></strong></span> 给这两个类型<span style="color:#0d0016;"><strong>取了别名</strong></span>。</li><li>我们为 <span style="color:#956fe7;"><strong>结点类</strong></span> 的类型取的别名是 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">Node</span></strong></span>，为 <span style="color:#956fe7;"><strong><span style="background-color:#fef2f0;">迭代器类</span></strong></span> 取的别名是 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">Self</span></strong></span>。</li><li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">迭代器类</span></strong></span> 中的<span style="color:#0d0016;"><strong>成员变量只有一个</strong></span>，那就是<span style="color:#956fe7;"><strong> 结点类类型的指针</strong></span> <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">_node</span></strong></span>，因为 <span style="color:#0d0016;"><strong>迭代器的本质就是指针。</strong></span></li></ul> 
<pre><code class="hljs">template&lt;typename T, typename Ref, typename Ptr&gt;
struct _list_iterator 
{
	typedef ListNode&lt;T&gt; Node;                //为结点类取别名
	typedef _list_iterator&lt;T, Ref, Ptr&gt; self;  //为正向迭代器类取别名

    //成员变量
	Node* _node;                             //指向结点的指针
}</code></pre> 
<h4 id="%F0%9F%92%A6%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0"><span style="color:#0d0016;">💦 构造函数 </span></h4> 
<blockquote> 
 <p>      <span style="color:#be191c;"><strong>迭代器类</strong></span> 实际上就是对 <span style="color:#956fe7;"><strong><span style="background-color:#fef2f0;">结点指针进行了封装</span></strong></span>，其成员变量就只有一个，那就是结点指针，其<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">构造函数</span></strong></span><span style="color:#0d0016;"><strong>直接根据所给结点指针构造一个迭代器对象</strong></span>即可。</p> 
</blockquote> 
<pre><code class="hljs">//正向迭代器构造函数
_list_iterator(Node* node = nullptr)       // 默认构造函数
			:_node(node)
		{}</code></pre> 
<h4 id="%F0%9F%92%A6%C2%A0%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%C2%A0"><span style="color:#0d0016;">💦 ++运算符的重载 </span></h4> 
<blockquote> 
 <p><span style="color:#be191c;"><strong>        自增运算符</strong></span>的 <span style="color:#0d0016;"><strong>重载</strong></span> 是<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">迭代器类的核心</span></strong></span>。<span style="color:#956fe7;"><strong>前置++</strong></span>重载中，要让当前<span style="color:#0d0016;"><strong>迭代器指向下一个结点后，再把迭代器返回</strong></span>。<span style="color:#956fe7;"><strong>后置++</strong></span>中是<span style="color:#0d0016;"><strong>把当前迭代器用临时变量保存一份，再把迭代器指向下一个结点，然后返回临时变量。</strong></span><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">注意：</span></span><span style="color:#956fe7;">重载后置++或后置--时，必须在函数参数列表加一个int变量，这是语法规定。</span></strong></p> 
</blockquote> 
<ul><li><span style="color:#956fe7;"><strong>重载前置++ </strong></span>和 <span style="color:#956fe7;"><strong>后置++</strong></span> 时的<span style="color:#0d0016;"><strong>返回值有所不同</strong></span>，<span style="color:#0d0016;"><strong><span style="background-color:#fef2f0;">前置++返回值类型是</span></strong></span><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">--------迭代器类型的引用</span></strong></span>，而<span style="color:#0d0016;"><strong><span style="background-color:#fef2f0;">后置++返回值类型是</span></strong></span><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">------ 迭代器类型。</span></strong></span></li><li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">前置++</span></strong></span>中，返回的是对 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">this</span></strong><strong style="color:#4d4d4d;"><span style="background-color:#fef2f0;"> </span></strong><span style="background-color:#fef2f0;"><strong>的解引用</strong></span></span><span style="color:#4d4d4d;">，</span><span style="color:#be191c;"><strong style="color:#4d4d4d;"><span style="background-color:#fef2f0;">this并不是局部变量</span></strong></span><span style="color:#4d4d4d;">，</span><span style="color:#956fe7;"><strong>函数结束后依然存在，所以可以返回它的引用，减少值拷贝次数。</strong></span></li><li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">后置++</span></strong></span>中，返回的 <strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">temp</span></span> </strong>是函数中创建的<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">局部对象</span></strong></span>，在<span style="color:#956fe7;"><strong>函数结束后会被销毁</strong></span>，<span style="color:#0d0016;"><strong>所以返回值类型不可以是引用。这里就必须通过值拷贝来返回值。</strong></span></li></ul> 
<pre><code class="hljs">//重载前置++
//返回迭代器对象自身的引用
//因为对象自身并不是该函数中的局部对象

self&amp; operator++() 
{
	_node = _node-&gt;_next;
	return *this;
}
</code></pre> 
<pre><code class="hljs">//重载后置++
//此时需要返回temp对象，而不是引用
//因为temp对象是局部的对象
//函数结束后就被释放

self operator++(int a) 
{
	self temp(*this);
	_node = _node-&gt;_next;
	return temp;
}</code></pre> 
<h4 id="%C2%A0%F0%9F%92%A6%C2%A0--%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span style="color:#0d0016;"><strong> 💦 -- 运算符的重载</strong></span></h4> 
<blockquote> 
 <p>   前置--和后置--关于函数的返回类型跟重载++类似，这里就不再赘述。</p> 
</blockquote> 
<pre><code class="hljs">
//重载前置--
self&amp; operator--() 
{
	_node = _node-&gt;_prev;
	return *this;
}</code></pre> 
<pre><code class="hljs">//重载后置--
self operator--(int a) 
{
	self temp(*this);
	_node = _node-&gt;_prev;
	return temp;
}</code></pre> 
<h4 id="%C2%A0%F0%9F%92%A6%C2%A0%E9%87%8D%E8%BD%BD%20!%3D%20%E5%92%8C%20%3D%3D"><span style="color:#0d0016;"><strong> 💦 重载 != 和 ==</strong></span></h4> 
<blockquote> 
 <p>       这里只需要比较<span style="color:#0d0016;"><strong>_node</strong></span><span style="color:#956fe7;"><strong>是否相同</strong></span>即可，因为<span style="color:#0d0016;"><strong>_node</strong></span><span style="color:#956fe7;"><strong>本身就是指向结点的指针</strong></span>，保存着结点的地址，只要地址相同，那自然就是同一个结点了</p> 
</blockquote> 
<pre><code class="hljs">//重载!=
bool operator!=(const self&amp; s)const 
{
	return _node != s._node;
}

//重载==
bool operator==(const self&amp; s)const 
{
	return _node == s._node;
}</code></pre> 
<h4 id="%C2%A0%F0%9F%92%A6%C2%A0*%20%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span style="color:#0d0016;"> <strong>💦 </strong>* 运算符的重载</span></h4> 
<blockquote> 
 <p>       当我们使用 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">解引用操作符</span></strong></span> 时，是<span style="color:#0d0016;"><strong>想得到该位置的数据内容</strong></span>。因此，我们直接返回当前结点指针所指结点的数据即可，但是这里需要<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">使用引用返回</span></strong></span>，<span style="color:#956fe7;"><strong>因为解引用后可能需要对数据进行修改。</strong></span></p> 
</blockquote> 
<pre><code class="hljs">//重载*
//返回迭代器指向的结点的值域

// T&amp; operator*()

Ref operator*() 
{
	return _node-&gt;_data;
}</code></pre> 
<h4 id="%C2%A0%F0%9F%92%A6%20-%3E%20%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span style="color:#0d0016;"><strong> 💦 -&gt; 运算符的重载</strong></span></h4> 
<blockquote> 
 <p>   有时候，<span style="color:#0d0016;"><strong>实例化的模板参数是自定义类型</strong></span>，我们想要像 指针 一样访问访问自定义类型力的成员变量，这样显得更通俗易懂，所以就要<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">重载 -&gt; 运算符</span></strong></span>，<strong><span style="color:#956fe7;">它的返回值是 T* </span></strong></p> 
</blockquote> 
<p><strong>想想如下场景：</strong> </p> 
<p>当 <span style="color:#956fe7;"><strong>list容器</strong></span> 当中的<span style="color:#0d0016;"><strong>每个结点存储的不是内置类型</strong></span>，而是<span style="color:#0d0016;"><strong>自定义类型</strong></span>，例如<span style="color:#956fe7;"><strong>数据存储类</strong></span>，那么当我们拿到一个位置的迭代器时，我们可能会使用 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">-&gt;运算符访问 Data 的成员</span></strong></span>： </p> 
<pre><code class="hljs">struct Data
{
	Data(int a = int(), double b = double(), char c = char())
		:_a(a)
		, _b(b)
		, _c(c)
	{}

	int _a;
	double _b;
	char _c;
};

void TestList()
{
	list&lt;Data&gt; lt;
	lt.push_back(Data(1, 2.2, 'A'));

	auto it = lt.begin();
	cout &lt;&lt; (*it)._a &lt;&lt; endl;	//不使用 operator-&gt;() 比较别扭
	cout &lt;&lt; it.operator-&gt;()-&gt;_b &lt;&lt; endl;	//这种写法是真实调用情况
	cout &lt;&lt; it-&gt;_c &lt;&lt; endl;	//编译器直接优化为 it-&gt;
}

int main()
{
	TestList();
	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="505" src="https://images2.imgbox.com/a2/48/9vCq3gLY_o.png" width="1081"></p> 
<ul><li><span style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">operator-&gt;()</span></code><span style="background-color:#fef2f0;"> </span></strong></span>存在的意义：<strong>使得 <code>迭代器</code> 访问自定义类型中的成员时更加方便</strong></li><li>如果没有这个函数，只能通过 <span style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">(*迭代器).成员</span></code></strong></span> 的方式进行成员访问，很不方便</li></ul> 
<blockquote> 
 <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">注意：</span></strong></span> <span style="color:#956fe7;"><strong>编译器将 </strong></span><span style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">迭代器.operator-&gt;()-&gt;成员</span></code></strong></span><span style="color:#956fe7;"><strong> 直接优化为 </strong></span><span style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">迭代器-&gt;成员</span></code></strong></span></p> 
</blockquote> 
<ul><li> 对于<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;"> -&gt; 运算符的重载</span></strong></span> ，我们直接<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">返回结点当中所存储数据的地址</span></strong></span>即可。</li></ul> 
<pre><code class="hljs">// 重载 -&gt; 操作符 ---实现指针访问元素
// T* operator-&gt;()

Ptr operator-&gt;()
{
	return &amp;_node-&gt;date;
}</code></pre> 
<h4 id="%C2%A0%F0%9F%92%A6%C2%A0%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%20%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span style="color:#0d0016;"><strong> 💦 迭代器类 总体代码</strong></span></h4> 
<pre><code class="hljs">namespace xas_list
{
	template&lt;class T,class Ref,class Ptr&gt;
	struct _list_iterator
	{
		typedef ListNode&lt;T&gt; Node;
		typedef _list_iterator&lt;T, Ref, Ptr&gt; self;
		Node* _node;
        
        //迭代器构造函数
		_list_iterator(Node* x)
			:_node(x)
		{}
 
        //重载*号 —— 实现解引用操作
		Ref operator*()
		{
			return _node-&gt;_data;
		}
 
        //重载-&gt;操作符 —— 实现指针访问元素
		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}
 
		//++it 重载前置++ —— 让链表能够像数组一样去++操作，访问元素
		self&amp; operator++()
		{
			_node = _node-&gt;_next;//前置++返回的是++之后的值，直接让当前位置的结点指向下一个节点
			return *this;
		}
 
		//it++ 重载后置++ —— （这里需要加上int作为一个站位符，与前置++区分）
		self operator++(int)
		{
			self tmp(*this);
			_node = _node-&gt;_next;//后置++返回的是++之前的值，需要保存当前节点，再指向下一个节点
			return tmp;
		}
 
		//--it 重载前置-- —— 让链表能够像数组一样去--操作，访问元素
		self&amp; operator--()
		{
			_node = _node-&gt;_prev;//前置--返回的是--之后的值，直接让当前位置的结点指向前一个节点
			return *this;
		}
 
		//it-- 重载后置-- ——（这里需要加上int作为一个站位符，与前置--区分）
		self operator--(int)
		{
			self tmp(*this);
			_node = _node-&gt;_prev;//后置--返回的是--之前的值，需要保存当前节点，再指向下一个节点
			return tmp;
		}
 
        //重载==
		bool operator==(const self&amp; it)const
		{
			return _node == it._node;
		}
 
        //重载!=
		bool operator!=(const self&amp; it)const
		{
			return _node != it._node;
		}
	
	};
}</code></pre> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81list%20%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%8C%E5%96%84"><span style="color:#0d0016;"><strong> 五、list 结构的完善</strong></span></h2> 
<blockquote> 
 <p><strong>      上面我们对 <span style="color:#956fe7;">节点结构</span>、<span style="color:#956fe7;">正向迭代器</span>实现原理及注意点一一做了介绍，最后一步也是最重要的一步，那就是将<span style="color:#be191c;"><span style="background-color:#fef2f0;">list结构完善起来，实现list的功能</span></span>。</strong> </p> 
</blockquote> 
<h3 id="%F0%9F%A5%9D%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%C2%A0"><span style="color:#0d0016;"><strong>🥝成员变量和模板参数 </strong></span></h3> 
<ul><li>因为 <span style="color:#be191c;"><strong>list</strong> </span>可以<span style="color:#0d0016;"><strong>存储各种类型的元素</strong></span>，因此 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list </span></strong></span><span style="color:#0d0016;"><strong>类要设置为模板，T就是存储的元素的类型</strong></span>。</li><li>因为 <span style="color:#956fe7;"><strong>结点类</strong></span> 和 <span style="color:#956fe7;"><strong>迭代器类</strong></span> 的类名太长，所以用<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;"> typedef</span></strong></span> 关键为它们<strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">取了别名</span></span></strong>。这里迭代器的三个参数之所以设置为<strong>&lt;T , T&amp; , T*&gt;</strong>，是因为list类只给出了一个模板参数，<span style="color:#0d0016;">而迭代器类应该有三个，因此用<strong> T&amp; 和 T* </strong>作为另外两个参数。</span></li></ul> 
<pre><code class="hljs">//带头结点的双向链表
template&lt;class T&gt;
class list 
{
	typedef ListNode&lt;T&gt; Node;
public:
	typedef _list_iterator&lt;T, T&amp;, T*&gt; Iterator;                   //正向迭代器
    typedef _list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;

private:

	Node* _head;              //指向头结点的指针

}</code></pre> 
<h3 id="%F0%9F%8D%8D%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong>🍍 默认成员函数</strong></span></h3> 
<h4 id="%E2%9A%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong>⚡构造函数</strong></span></h4> 
<blockquote> 
 <p> <strong>  list 的成员变量是 一个节点类，在构造头节点时，需要将这单个头节点构造成一个双向循环链表；</strong></p> 
</blockquote> 
<p class="img-center"><img alt="" height="268" src="https://images2.imgbox.com/e2/f5/6zErqdjU_o.png" width="813"></p> 
<pre><code class="hljs">//构造函数
list()
{
	_head = new Node;     //new一个节点出来
	_head-&gt;_prev = _head; 
	_head-&gt;_next = _head; //_prev 和 _next 同时指向了头结点，形成了双向循链表
}</code></pre> 
<h4 id="%C2%A0%E2%9A%A1%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span style="color:#0d0016;"><strong> ⚡拷贝构造</strong></span></h4> 
<blockquote> 
 <p><strong>       拷贝构造是用一个已有对象去构造出另一个对象，首先将待构造对象进行初始化，然后利用迭代器区间去构造一个和 lt1 一样的临时的 tmp 对象，再进行数据的交换，达到深拷贝的目的。</strong>  </p> 
</blockquote> 
<pre><code class="hljs">//拷贝构造 --- 现代写法 lt2(lt1)
list(const list&lt;T&gt;&amp; lt)
{
	_head = new Node;
	_head-&gt;_prev = _head;
	_head-&gt;_next = _head;
	list&lt;T&gt; tmp(lt.begin(), lt.end());
	std::swap(_head, tmp._head);
}</code></pre> 
<p class="img-center"><img alt="" height="548" src="https://images2.imgbox.com/e0/4a/nzck200C_o.png" width="1109"></p> 
<h4 id="%E2%9A%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8C%BA%E9%97%B4%E6%9E%84%E9%80%A0%C2%A0"><span style="color:#0d0016;">⚡迭代器区间构造 </span></h4> 
<blockquote> 
 <p>   由于<strong>list</strong>可以<strong>存储各种类型的元素</strong>，所以区间构造时自然也会用到<strong>各种类型的迭代器</strong>，因此区间构造也应该定义为模版，需要给出模版参数列表。具体实现和上一个函数是差不多的。</p> 
</blockquote> 
<pre><code class="hljs">//迭代器区间构造
template&lt;class iterator&gt;
list(iterator first, iterator last)
{
	_head = new Node;
	_head-&gt;_prev = _head;
	_head-&gt;_next = _head;
 
	while (first != last)
	{
		push_back(*first);//尾插数据，会根据不同类型的迭代器进行调用
		++first;
	}
}</code></pre> 
<h4 id="%E2%9A%A1n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%9E%84%E9%80%A0%C2%A0"><span style="color:#0d0016;"><strong>⚡n个相同元素构造 </strong></span></h4> 
<blockquote> 
 <p>      通过用 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">n 个 val 来对对象进行初始化</span></strong></span>，需要注意这里的 <span style="color:#0d0016;"><strong>T( )是一个匿名对象</strong></span>，作为 val 的缺省参数，因为我们并不知道传给val的是一个对象还是一个整形（或其他），给缺省参数的好处在于，对于自定义类型编译器会去调用自定义类型的构造函数来对val进行初始化，如果是内置类型，它也是有自己的构造函数</p> 
</blockquote> 
<pre><code class="hljs">//用n个val个构造      			   
list(int n, const T&amp; val = T())        			   
{												   
	_head = new Node;
	_head-&gt;_prev = _head;
	_head-&gt;_next = _head;
	for (int i = 0; i &lt; n; i++)
	{
		push_back(val);
	}
}</code></pre> 
<h4 id="%E2%9A%A1%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%C2%A0"><span style="color:#0d0016;">⚡赋值重载 </span></h4> 
<blockquote> 
 <p>         将赋值运算符重载的<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">参数定义为 list 类型的对象而不是对象的引用</span></strong></span>，传参时会<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">发生值拷贝。</span></strong></span></p> 
 <p>         <span style="color:#0d0016;"><strong>因此我们可以把 list对象 的 this指针 和 拷贝出来的参数 L 指向头结点的指针交换</strong></span>，这样 t<span style="color:#956fe7;"><strong>his指针 就直接指向了拷贝出来的L的头结点。L则指向了list对象的头结点</strong></span>，<span style="color:#0d0016;"><strong>在函数结束后，作为局部对象的L将被销毁，它指向的空间也会被释放。</strong></span></p> 
</blockquote> 
<pre><code class="hljs">//传统写法
list&lt;T&gt;&amp; operator=(const list&lt;T&gt;&amp; lt)
{
	if (this != &amp;lt) //避免自己给自己赋值
	{
		clear(); //清空容器
		for (const auto&amp; e : lt)
		{
			push_back(e); //将容器lt当中的数据一个个尾插到链表后面
		}
	}
	return *this; //支持连续赋值
}
</code></pre> 
<h4 id="%E2%9A%A1%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong>⚡析构函数</strong></span></h4> 
<blockquote> 
 <p> 对对象进行析构时，首先调用clear函数清理容器当中的数据，然后将头结点释放，最后将头指针置空即可。</p> 
</blockquote> 
<pre><code class="hljs">//析构函数
~list()
{
	clear(); //清理容器
	delete _head; //释放头结点
	_head = nullptr; //头指针置空
}
</code></pre> 
<h3 id="%C2%A0%F0%9F%8D%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong> 🍇迭代器相关函数</strong></span></h3> 
<h4 id="%E2%9A%A1begin%20%E5%92%8C%20end%C2%A0"><span style="color:#0d0016;"><strong>⚡</strong>begin 和 end </span></h4> 
<blockquote> 
 <p>         首先我们应该明确的是：<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">begin 函数返回的是第一个有效数据的迭代器，end函数返回的是最后一个有效数据的下一个位置的迭代器。</span></strong></span></p> 
 <p>        对于 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">list</span></strong></span> 这个 <span style="color:#0d0016;"><strong>带头双向循环链</strong></span><span style="color:#333333;"><strong>表</strong></span> 来说，其第一个有效数据的迭代器就是使用头结点后一个结点的地址构造出来的迭代器，而其最后一个有效数据的下一个位置的迭代器就是使用头结点的地址构造出来的迭代器。（最后一个结点的下一个结点就是头结点）</p> 
</blockquote> 
<pre><code class="hljs">iterator begin()
{
	//返回使用头结点后一个结点的地址构造出来的普通迭代器
	return iterator(_head-&gt;_next);
}
iterator end()
{
	//返回使用头结点的地址构造出来的普通迭代器
	return iterator(_head);
}
</code></pre> 
<ul><li>当然，还需要重载一对用于 <span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">const对象</span></strong></span> 的 begin函数 和 end函数。</li></ul> 
<pre><code class="hljs">const_iterator begin() const
{
	//返回使用头结点后一个结点的地址构造出来的const迭代器
	return const_iterator(_head-&gt;_next);
}
const_iterator end() const
{
	//返回使用头结点的地址构造出来的普通const迭代器
	return const_iterator(_head);
}
</code></pre> 
<h3 id="%C2%A0%F0%9F%8D%93%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong> 🍓访问容器相关函数</strong></span></h3> 
<h4 id="%E2%9A%A1fron%20%E5%92%8C%20back%C2%A0"><span style="color:#0d0016;"><strong>⚡fron 和 back </strong></span></h4> 
<blockquote> 
 <p>        front 和 back 函数分别用于获取第一个有效数据和最后一个有效数据，因此，<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">实现front和back函数时，直接返回第一个有效数据和最后一个有效数据的引用即可。 </span></strong></span></p> 
</blockquote> 
<pre><code class="hljs">T&amp; front()
{
	return *begin(); //返回第一个有效数据的引用
}
T&amp; back()
{
	return *(--end()); //返回最后一个有效数据的引用
}
</code></pre> 
<ul><li>当然，这也需要重载一对用于const对象 的front函数 和 back函数，因为 const对象 调用front和back函数后所得到的数据不能被修改。</li></ul> 
<pre><code class="hljs">const T&amp; front() const
{
	return *begin(); //返回第一个有效数据的const引用
}

const T&amp; back() const
{
	return *(--end()); //返回最后一个有效数据的const引用
}
</code></pre> 
<h3 id="%C2%A0%F0%9F%8D%91%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong> 🍑增删改查相关函数</strong></span></h3> 
<h4 id="%E2%9A%A1insert%20--%20%E6%8F%92%E5%85%A5"><span style="color:#0d0016;"><strong>⚡insert -- 插入</strong></span></h4> 
<blockquote> 
 <p>insert函数可以在所给迭代器之前插入一个新结点。 </p> 
</blockquote> 
<p class="img-center"><img alt="" height="464" src="https://images2.imgbox.com/51/25/v2xL0fmJ_o.gif" width="1200"></p> 
<ul><li>先根据所给迭代器得到该位置处的结点指针<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">cur</span></strong></span>，然后通过<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">cur</span></strong></span>指针找到前一个位置的结点指针<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">prev</span></strong></span>，接着根据所给数据x构造一个待插入结点，之后再建立新结点与<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">cur</span></strong></span>之间的双向关系，最后建立新结点与<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">prev</span></strong></span>之间的双向关系即可。</li></ul> 
<pre><code class="hljs">//插入函数
void insert(iterator pos, const T&amp; x)
{
	assert(pos._node); //检测pos的合法性

	node* cur = pos._node; //迭代器pos处的结点指针
	node* prev = cur-&gt;_prev; //迭代器pos前一个位置的结点指针
	node* newnode = new Node(x); //根据所给数据x构造一个待插入结点

	//建立newnode与cur之间的双向关系
	newnode-&gt;_next = cur;
	cur-&gt;_prev = newnode;
	//建立newnode与prev之间的双向关系
	newnode-&gt;_prev = prev;
	prev-&gt;_next = newnode;
}
</code></pre> 
<h4 id="%E2%9A%A1erase"><span style="color:#0d0016;"><strong>⚡erase</strong></span></h4> 
<blockquote> 
 <p>     先根据所给迭代器得到该位置处的结点指针<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">cur</span></strong></span>，然后通过<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">cur</span></strong></span>指针找到前一个位置的结点指针<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">prev</span></strong></span>，以及后一个位置的结点指针<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">next</span></strong></span>，紧接着释放<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">cur</span></strong></span>结点，最后建立<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">prev</span></strong></span>和<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">next</span></strong></span>之间的双向关系即可。 </p> 
</blockquote> 
<p class="img-center"><img alt="" height="464" src="https://images2.imgbox.com/ab/c5/jNPp47fy_o.gif" width="1200"></p> 
<pre><code class="hljs">//删除函数
iterator erase(iterator pos)
{
	assert(pos._node); //检测pos的合法性
	assert(pos != end()); //删除的结点不能是头结点

	node* cur = pos._node; //迭代器pos处的结点指针
	node* prev = cur-&gt;_prev; //迭代器pos前一个位置的结点指针
	node* next = cur-&gt;_next; //迭代器pos后一个位置的结点指针

	delete cur; //释放cur结点

	//建立prev与next之间的双向关系
	prev-&gt;_next = next;
	next-&gt;_prev = prev;
	
	return iterator(next); //返回所给迭代器pos的下一个迭代器
}
</code></pre> 
<h4 id="%E2%9A%A1push_back%20%E5%92%8C%20pop_back"><span style="color:#0d0016;"><strong>⚡push_back 和 pop_back</strong></span></h4> 
<blockquote> 
 <p>push_back函数就是在头结点前插入结点，而pop_back就是删除头结点的前一个结点。 </p> 
</blockquote> 
<pre><code class="hljs">//尾插
void push_back(const T&amp; x)
{
	insert(end(), x); //在头结点前插入结点
}
//尾删
void pop_back()
{
	erase(--end()); //删除头结点的前一个结点
}
</code></pre> 
<h4 id="%E2%9A%A1push_front%20%E5%92%8C%20pop_front"><span style="color:#0d0016;"><strong>⚡push_front 和 pop_front</strong></span></h4> 
<blockquote> 
 <p> push_front函数就是在第一个有效结点前插入结点，而pop_front就是删除第一个有效结点。</p> 
</blockquote> 
<pre><code class="hljs">//头插
void push_front(const T&amp; x)
{
	insert(begin(), x); //在第一个有效结点前插入结点
}
//头删
void pop_front()
{
	erase(begin()); //删除第一个有效结点
}
</code></pre> 
<h3 id="%C2%A0%F0%9F%8D%89%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong> 🍉容量相关函数</strong></span></h3> 
<h4 id="%E2%9A%A1size"><span style="color:#0d0016;"><strong>⚡size</strong></span></h4> 
<blockquote> 
 <p>size函数用于获取当前容器当中的有效数据个数，因为list是链表，所以只能通过遍历的方式逐个统计有效数据的个数。 </p> 
</blockquote> 
<pre><code class="hljs">size_t size() const
{
	size_t sz = 0; //统计有效数据个数
	const_iterator it = begin(); //获取第一个有效数据的迭代器
	while (it != end()) //通过遍历统计有效数据个数
	{
		sz++;
		it++;
	}
	return sz; //返回有效数据个数
}
</code></pre> 
<h4 id="%E2%9A%A1empty"><span style="color:#0d0016;">⚡empty</span></h4> 
<blockquote> 
 <p> empty函数用于判断容器是否为空，我们直接判断该容器的begin函数和end函数所返回的迭代器，是否是同一个位置的迭代器即可。（此时说明容器当中只有一个头结点）</p> 
</blockquote> 
<pre><code class="hljs">bool empty() const
{
	return begin() == end(); //判断是否只有头结点
}
</code></pre> 
<h4 id="%E2%9A%A1resize"><span style="color:#0d0016;"><strong>⚡resize</strong></span></h4> 
<p> <strong>resize函数的规则：</strong></p> 
<blockquote> 
 <ol><li>若当前容器的size小于所给n，则尾插结点，直到size等于n为止。</li><li>若当前容器的size大于所给n，则只保留前n个有效数据。</li></ol> 
</blockquote> 
<ul><li>实现resize函数时，不要直接调用size函数获取当前容器的有效数据个数，因为当你调用size函数后就已经遍历了一次容器了，而如果结果是size大于n，那么还需要遍历容器，找到第n个有效结点并释放之后的结点。 </li></ul> 
<pre><code class="hljs">void resize(size_t n, const T&amp; val = T())
{
	iterator i = begin(); //获取第一个有效数据的迭代器
	size_t len = 0; //记录当前所遍历的数据个数
	while (len &lt; n&amp;&amp;i != end())
	{
		len++;
		i++;
	}
	if (len == n) //说明容器当中的有效数据个数大于或是等于n
	{
		while (i != end()) //只保留前n个有效数据
		{
			i = erase(i); //每次删除后接收下一个数据的迭代器
		}
	}
	else //说明容器当中的有效数据个数小于n
	{
		while (len &lt; n) //尾插数据为val的结点，直到容器当中的有效数据个数为n
		{
			push_back(val);
			len++;
		}
	}
}
</code></pre> 
<h4 id="%E2%9A%A1clear"><span style="color:#0d0016;">⚡clear</span></h4> 
<blockquote> 
 <p> clear函数用于清空容器，我们通过遍历的方式，逐个删除结点，只保留头结点即可。</p> 
</blockquote> 
<pre><code class="hljs">void clear()
{
	iterator it = begin();
	while (it != end()) //逐个删除结点，只保留头结点
	{
		it = erase(it);
	}
}
</code></pre> 
<h2 id="%E5%85%AD%E3%80%81list%C2%A0%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81"><span style="color:#0d0016;"><strong>六、list 容器的模拟实现整体代码</strong></span></h2> 
<h3 id="%F0%9F%8D%88list.h%C2%A0"><span style="color:#0d0016;"><strong>🍈list.h </strong></span></h3> 
<pre><code class="hljs">#pragma once
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;
using std::ostream;
using std::istream;
using std::cin;
using std::cout;
using std::endl;

// 为了避免和库里的 list 产生冲突，在自己的命名空间内实现 list
// 带头---双向---循环---链表
namespace xas_list
{
	// 通过模板能够实现不同类型的数据存储
	template&lt;class T&gt;
	// 链表节点的构造
	struct ListNode
	{
		ListNode&lt;T&gt;* _next;   // 指向后面节点的指针
		ListNode&lt;T&gt;* _prev;   // 指向前面节点的指针
		T _data;              // 一个节点中的数据

		// 构造函数
		ListNode(const T&amp; x = T())
			:_next(nullptr)
			,_prev(nullptr)
			,_data(x)
		{}
	};

	// 模拟实现迭代器
	template&lt;class T, class Ref, class Ptr&gt;
	// 模式一个迭代器 类型
	struct _list_iterator
	{
		typedef ListNode&lt;T&gt; Node;       // 为节点类 取别名

		//只要用自己的类型，就对其typedef成self，方便后续使用
		typedef _list_iterator&lt;T, Ref, Ptr&gt; self;   // 为正向迭代器类 取别名

		// 成员变量
		Node* _node;                     // _node 表示一个节点
		

		_list_iterator(Node* node = nullptr)       // 默认构造函数
			:_node(node)
		{}

		// ++it 重载前置++ —— 让链表能够像数组一样去++操作，访问元素
		// 注意：这里的 this 不是局部变量，函数结束不会被销毁，可以使用引用返回，减少拷贝次数
		self&amp; operator++()
		{
			//前置++返回的是++之后的值，直接让当前位置的结点指向下一个节点
			_node = _node-&gt;_next;
			return *this;
		}

		//重载后置++
		//此时需要返回temp对象，而不是引用
		//因为temp对象是局部的对象
		//函数结束后就被释放

		//it++ 重载后置++ —— （这里需要加上int作为一个站位符，与前置++区分）
		self operator++(int a)
		{
			self temp(*this);
			_node = _node-&gt;_next; //后置++返回的是++之前的值，需要保存当前节点，再指向下一个节点
			return temp;
		}


		//重载前置--
		self&amp; operator--() 
		{
			_node = _node-&gt;_prev;
			return *this;
		}
		//重载后置--
		self operator--(int a) 
		{
			self temp(*this);
			_node = _node-&gt;_prev;
			return temp;
		}

		// 赋值重载重载  * 
		//返回迭代器指向的结点的值域
		Ref operator*()
		{
			return _node-&gt;_data;
		}

		// 重载 -&gt; 操作符 ---实现指针访问元素
		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;date;
		}

		// 赋值重载 !=
		bool operator!=(const self&amp; s)  const
		{
			return _node != s._node;
		}

		// 赋值重载 ==
		bool operator==(const self&amp; s)  const
		{
			return _node == s._node;
		}
	};


	template&lt;class T&gt;
	// 创建一个 list 类
	class list
	{
		typedef ListNode&lt;T&gt; Node;            // 重新命名节点(结构体)的名称
	public:

		typedef _list_iterator&lt;T, T&amp;, T*&gt; iterator;  // 为 迭代器类型取 别名
		typedef _list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;

		// 正向迭代器 和 正向 const 迭代器
		iterator begin();
		iterator end();
		const_iterator begin()const;
		const_iterator end()const;

		// 默认成员函数
		list();                             // 构造函数   --- 无参构造
		list(int n, const T&amp; val = T());    // 用 n个val 构造
		template&lt;class iterator&gt;
		list(iterator first, iterator last) // 迭代器区间构造
		{
			empty_init();
			while (first != last)
			{
				push_back(*first);
				++first;
			}

		}
		~list();                            // 析构函数
		list(list&lt;T&gt;&amp; lt);                  // 拷贝构造
		void empty_init();                  // 初始化一个循环链表
		list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt);     // 赋值运算符符重载


		// 容量相关的函数
		size_t size() const;                // 计算节点的有效个数
		bool Empty()const;                  // 判空 不为空时，返回 true
		void clear();                       // 清空数据
		void resize(size_t n, const T&amp; val = T());    // 设置list对象的有效元素个数


		// 访问容器相关函数
		T&amp; front();                         // 返回第一个有效数据
		T&amp; back();                          // 返回最后一个有效数据
		const T&amp; front() const;                   
		const T&amp; back() const;


		// 修改容器内容的相关函数
		void push_back(const T&amp; x);                 // 尾插
		iterator insert(iterator pos, const T&amp; x);  // 插入
		void push_front(const T&amp; x);                // 头插
		iterator erase(iterator pos);               // 删除
		void pop_back();                            // 尾删
		void pop_front();                           // 头删
		void swap(list&lt;T&gt;&amp; temp);                   // 交换函数

	private:
		Node* _head;
	};

	// 打印函数
	void printf_list(const list&lt;int&gt;&amp; lt);
}</code></pre> 
<h3 id="%F0%9F%8D%91list.cpp"><span style="color:#0d0016;"><strong>🍑list.cpp</strong></span></h3> 
<pre><code class="hljs">#include "list.h"

template&lt;class T&gt;
xas_list::list&lt;T&gt;::list()    // 构造函数   --- 无参构造
{
	_head = new Node;     //申请创建一个新的节点  --- 双向循环
	_head-&gt;_next = _head;  
	_head-&gt;_prev = _head;
}

template&lt;class T&gt;       // 用 n个val 进行构造
xas_list::list&lt;T&gt;::list(int n, const T&amp; val)
{
	// 创建一个空节点
	_head = new Node;
	// 形成一个带头双向循环链表
	_head-&gt;_prev = _head;
	_head-&gt;_next = _head;

	for (int i = 0; i &lt; n; i++)
	{
		push_back(val);
	}
}



template&lt;class T&gt;
xas_list::list&lt;T&gt;::~list()                     // 析构函数
{
	clear();

	delete _head;

	_head = nullptr;

}

// 初始化一个循环链表
template&lt;class T&gt;
void xas_list::list&lt;T&gt;::empty_init()
{
	//申请创建一个新的节点  --- 双向循环
	_head = new Node;
	_head-&gt;_next = _head;
	_head-&gt;_prev = _head;
}

template&lt;class T&gt;
xas_list::list&lt;T&gt;::list( list&lt;T&gt;&amp; lt)
{
	//申请创建一个新的节点  --- 双向循环
	empty_init();

	for (auto&amp; e : lt)
	{
		push_back(e);
	}
}

template&lt;class T&gt;
void xas_list::list&lt;T&gt;::swap(list&lt;T&gt;&amp; temp)
{
	std::swap(_head, temp._head);
}


// lt1 = lt2;  --- 赋值重载
template&lt;class T&gt;
xas_list::list&lt;T&gt;&amp; xas_list::list&lt;T&gt;::operator=(list&lt;T&gt; lt)
{
	//if (this != &amp;lt)  // 判断一下是否有给自己赋值
	//{
	//	// 将lt1 先清空，再将lt2 插入到 lt1中
	//	// 注意 this 指针
	//	clear();
	//	for (const auto&amp; e : lt)
	//	{
	//		push_back(e);
	//	}
	//}
	swap(lt);
	return *this;
}


template&lt;class T&gt;
void xas_list::list&lt;T&gt;::clear()        // 清空数据
{
	//复用erase
	iterator it = begin();
	while (it != end())
	{
		it = erase(it);//用it接收删除后的下一个结点的位置
	}
}


// 正向迭代器 
// begin迭代器指向的是正方向第一个有效结点，也就是头结点的下一个结点。
// 因为有 哨兵位的存在
template&lt;class T&gt;
typename xas_list::list&lt;T&gt;::iterator xas_list::list&lt;T&gt;::begin()
{
	return iterator(_head-&gt;_next);
}


// end迭代器指向的是正方向最后一个有效结点的下一个结点，也就是头结点。
template&lt;class T&gt;
typename xas_list::list&lt;T&gt;::iterator xas_list::list&lt;T&gt;::end()
{
	return iterator(_head);
}

template&lt;class T&gt;
typename xas_list::list&lt;T&gt;::const_iterator xas_list::list&lt;T&gt;::begin()const
{
	return const_iterator(_head-&gt;_next);
}

template&lt;class T&gt;
typename xas_list::list&lt;T&gt;::const_iterator xas_list::list&lt;T&gt;::end()const
{
	return const_iterator(_head);
}

template&lt;class T&gt;
// ListNode(const T&amp; x = T())  这里的 T() 的给一个缺省值
void xas_list::list&lt;T&gt;::push_back(const T&amp; x)   // 尾插
{
	// 创建一个新的节点  ----  Node
	//Node* newnode = new Node(x);
	//Node* tail = _head-&gt;_prev;     // 找尾节点--------头节点的前一个节点

	 进行尾插
	//tail-&gt;_next = newnode;
	//newnode-&gt;_prev = tail;
	//newnode-&gt;_next = _head;
	//_head-&gt;_prev = newnode;

	insert(end(), x);
}

// 头插
template&lt;class T&gt;
void xas_list::list&lt;T&gt;::push_front(const T&amp; x)
{
	insert(begin(), x);
}


// 插入
template&lt;class T&gt;
typename xas_list::list&lt;T&gt;::iterator xas_list::list&lt;T&gt;::insert(iterator pos, const T&amp; x)
{
	// 保存当前节点
	Node* cur = pos._node;
	Node* prev = cur-&gt;_prev;

	// 创建一个新的节点
	Node* newnode = new Node(x);

	prev-&gt;_next = newnode;
	newnode-&gt;_prev = prev;
	newnode-&gt;_next = cur;
	cur-&gt;_prev = newnode;

	return iterator(newnode);
}

// 删除
template&lt;class T&gt;
typename xas_list::list&lt;T&gt;::iterator xas_list::list&lt;T&gt;::erase(iterator pos)
{
	assert(pos != end());

	Node* cur = pos._node;
	Node* prev = cur-&gt;_prev;
	Node* next = cur-&gt;_next;

	prev-&gt;_next = next;
	next-&gt;_prev = prev;
	// 删除当前位置
	delete cur;
	return iterator(next);
}

// 尾删
template&lt;class T&gt;
void xas_list::list&lt;T&gt;::pop_back()
{
	erase(--end());
}

// 头删
template&lt;class T&gt;
void  xas_list::list&lt;T&gt;::pop_front()
{
	erase(begin());
}

// 判断 list 的有效链表个数
template&lt;class T&gt;
size_t xas_list::list&lt;T&gt;::size() const
{
	size_t count = 0;
	list&lt;T&gt;::const_iterator it = begin();
	while (it != end())
	{
		count++;
		it++;
	}
	return count;
}

// 判断 list 是否为空
template&lt;class T&gt;
bool xas_list::list&lt;T&gt;::Empty() const
{
	return _head-&gt;_next == _head;
}

template&lt;class T&gt;
void xas_list::list&lt;T&gt;::resize(size_t n, const T&amp; val)
{
	list&lt;T&gt;::iterator it = begin(); //获取第一个有效数据的迭代器
	size_t len = 0; //记录当前所遍历的数据个数
	while (len &lt; n &amp;&amp; it != end())
	{
		len++;
		it++;
	}
	if (len == n) //说明容器当中的有效数据个数大于或是等于n
	{
		while (it != end()) //只保留前n个有效数据
		{
			it = erase(it); //每次删除后接收下一个数据的迭代器
		}
	}
	else //说明容器当中的有效数据个数小于n
	{
		while (len &lt; n) //尾插数据为val的结点，直到容器当中的有效数据个数为n
		{
			push_back(val);
			len++;
		}
	}
}

template&lt;class T&gt;
T&amp; xas_list::list&lt;T&gt;::front()
{
	return *begin();
}

template&lt;class T&gt;
T&amp; xas_list::list&lt;T&gt;::back()
{
	return *(--end());
}

template&lt;class T&gt;
const T&amp; xas_list::list&lt;T&gt;::front() const
{
	return *begin();
}

template&lt;class T&gt;
const T&amp; xas_list::list&lt;T&gt;::back() const
{
	return *(--end());
}


// 打印对应的链表
void xas_list::printf_list(const list&lt;int&gt;&amp; lt)
{
	list&lt;int&gt;::const_iterator it = lt.begin();

	while (it != lt.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
	cout &lt;&lt; endl;
}


// 遍历的测试
void test1()
{
	xas_list::list&lt;int&gt; lt(5,6);
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	lt.push_back(5);

	lt.push_front(0);
	// 头删
	lt.pop_back();
	// 尾删
	lt.pop_front();

	// -------------迭代器测试------------------// 
	cout &lt;&lt; "迭代器的测试" &lt;&lt; endl;
	xas_list::list&lt;int&gt;::iterator it = lt.begin();
	while (it != lt.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; "范围for的测试" &lt;&lt; endl;
	// -------------范围 for 测试------------------// 
	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	

	cout &lt;&lt; "清空数据" &lt;&lt; endl;
	// 清空数据
	lt.clear();
	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

}


void test2()
{
	xas_list::list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	lt.push_back(5);
	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; "拷贝构造" &lt;&lt; endl;
	xas_list::list&lt;int&gt; copy(lt);

	for (auto e : copy)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; "赋值重载" &lt;&lt; endl;
	xas_list::list&lt;int&gt; lt1;
	lt1.push_back(10);
	lt1.push_back(20);
	lt1.push_back(33);

	lt = lt1;
	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

}


// const 迭代器
void test3()
{
	xas_list::list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);

	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	xas_list::list&lt;int&gt; l3(arr, arr + 10); //迭代器区间构造
	cout &lt;&lt; l3.size() &lt;&lt; endl;
	cout &lt;&lt; l3.Empty() &lt;&lt; endl;
	l3.resize(12,2);
	cout &lt;&lt; l3.back() &lt;&lt; endl;
	cout &lt;&lt; l3.front() &lt;&lt; endl;
	printf_list(l3);
}



int main()
{
	test3();
	return 0;
	
}</code></pre> 
<h2 id="%E4%B8%83%E3%80%81%E5%85%B1%E5%8B%89"><span style="color:#0d0016;"><strong>七、共勉</strong></span></h2> 
<p><strong>      以下就是我对 <span style="color:#be191c;"><span style="background-color:#fef2f0;">list容器 的模拟实现</span></span> 的理解，如果有不懂和发现问题的小伙伴，请在评论区说出来哦，同时我还会继续更新对<span style="color:#be191c;"><span style="background-color:#fef2f0;"> C++stack</span></span> 的理解，<span style="color:#956fe7;">请持续关注我哦！！！</span></strong><span style="color:#956fe7;">  </span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/95/b3/7FSOA0LQ_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5d7337b74d3a31a09b1dd2ddc8f307c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024年陕西省人工智能(大数据)产业链链主企业申报条件程序、材料和时间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3851cc32a86fd0dba8a03ce994fb202/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习-监督学习6大核心算法技术精讲与代码实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>