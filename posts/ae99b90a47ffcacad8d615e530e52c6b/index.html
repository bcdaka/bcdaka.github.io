<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C#】WebSoket 演示（使用websocket-sharp库） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ae99b90a47ffcacad8d615e530e52c6b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C#】WebSoket 演示（使用websocket-sharp库）">
  <meta property="og:description" content="Example 3服务器&#43; Example1 客户端
示例3
此源代码片段包含了如何使用WebSocketSharp库来创建一个HTTP服务器，并提供WebSocket服务。 分析整个代码，我们可以归纳出以下关键信息：
导入了一系列重要的命名空间，包括系统配置、加密库、文本、WebSocket等。
定义了Example3名称空间和包含Main方法的Program类，作为HTTP服务器和WebSocket服务的入口点。
HTTP服务器使用4649端口实例化，同时注释掉的代码展示了其他可能的方式来实例化HTTP服务器（包括带安全连接的https，以及监听不同网络地址和端口的服务器实例）。
当服务器运行在DEBUG模式下，可以设置日志级别、响应等待时间以及清理策略。
注释掉的代码示例说明了如何设置服务器的SSL配置，以及如何设置基本或摘要型的HTTP身份验证。
服务器利用HttpServer.DocumentRootPath设置了文档根目录路径。
通过OnGet事件处理程序来处理HTTP GET请求，可以读取文件并根据文件内容类型设置响应头和正文。
服务器添加了Echo和Chat两个WebSocket服务。
注释掉的代码中包括了WebSocket服务的详细初始化示例，例如设置协议、校验器和对服务器发送的Cookie进行校验等。
服务器启动并开始监听，在控制台上显示一些运行信息。
最后，通过读取输入来停止HTTP服务器
综上所述，本段代码提供了使用WebSocketSharp库创建符合个人需要的HTTP服务器与WebSocket服务的多种示例和配置方法。通过此代码，可以开启一个支持WebSocket通信的服务器，并可通过相关配置来实现安全连接、HTTP认证和基于文档根路径的内容服务能力。
App.config文件
下面代码初始化一个基于WebSocketSharp库的WebSocket服务器，它允许客户端通过WebSocket协议连接进行通信，并提供HTTP服务，可以响应基于HTTP的GET请求。提供静态文件服务和WebSocket回显(Echo)/聊天(Chat)服务。支持通过不同方式指定服务的地址和端口，包含了调试模式下的日志等级设置，以及生产模式下的SSL/TLS证书配置和HTTP认证机制的配置，但这些功能默认是被注释掉的。服务器通过控制台命令启动和停止，并能在控制台输出当前服务的状态信息。
using System; // 引入System命名空间 using System.Configuration; // 引入System.Configuration命名空间，用于访问配置文件 using System.Security.Cryptography.X509Certificates; // 引入System.Security.Cryptography.X509Certificates命名空间，用于处理证书 using System.Text; // 引入System.Text命名空间，包含编码和字符集的功能 using WebSocketSharp; // 引入WebSocketSharp命名空间，一个实现WebSocket协议的C#库 using WebSocketSharp.Net; // 引入WebSocketSharp.Net命名空间，提供网络相关的功能 using WebSocketSharp.Server; // 引入WebSocketSharp.Server命名空间，用于创建和管理WebSocket服务器 // 定义了一个名为Example3的命名空间 namespace Example3 { // 定义了一个Program类 public class Program { // 主函数 public static void Main (string[] args) { // 创建HttpServer类的新实例。 // // 如果需要提供安全连接（即HTTPS），应使用带有&#39;secure&#39;参数设置为true // 或者带有https协议的HTTP URL来创建新实例。 var httpsv = new HttpServer (4649); // 在4649端口上实例化HttpServer // var httpsv = new HttpServer (5963, true); // 使用SSL在5963端口上实例化HttpServer（代码暂时被注释） // 下面的被注释的代码块展示了其他创建HttpServer实例的方式。 // 例如绑定到所有IP地址、绑定到IPv6地址、通过具体IP实例化等等。 /*注释掉的代码展示了多种不同的方法来创建HttpServer的实例，包括监听不同的网络接口（所有网络、IPv4回环地址、IPv6回环地址）、监听不同的端口（常规端口、安全端口）、以及支持安全连接（SSL/TLS）。代码被注释意味着虽然是可用的选项，但当前不是活动状态。这些代码为开发者提供了灵活性，在不同场景下快速调整服务器监听的网络接口和端口。*/ // 使用SSL，在5963端口上创建一个支持安全连接的HttpServer实例（代码被注释） // var httpsv = new HttpServer (5963, true); // 在所有网络接口的4649端口上创建HttpServer实例（代码被注释） // var httpsv = new HttpServer (System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-10T22:41:18+08:00">
    <meta property="article:modified_time" content="2024-05-10T22:41:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C#】WebSoket 演示（使用websocket-sharp库）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/52/fe/wBgItAJQ_o.png" alt="fabc738911d3aa0daa9d03b8cef1ca66.png"></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/d8/dc/e3mNraHD_o.png" alt="a59c7776742e213c865ec6fbde1391b4.png"></p> 
 <p style="text-align:center;">Example 3服务器+ Example1 客户端</p> 
 <p style="text-align:center;"><strong>示例3</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/64/b6/qf5ZJVV4_o.png" alt="e8badb8b216a23199da67800248b24fb.png"></p> 
 <p>此源代码片段包含了如何使用<code>WebSocketSharp</code>库来创建一个HTTP服务器，并提供WebSocket服务。 分析整个代码，我们可以归纳出以下关键信息：</p> 
 <ol><li><p>导入了一系列重要的命名空间，包括系统配置、加密库、文本、WebSocket等。</p></li><li><p>定义了<code>Example3</code>名称空间和包含<code>Main</code>方法的<code>Program</code>类，作为HTTP服务器和WebSocket服务的入口点。</p></li><li><p>HTTP服务器使用4649端口实例化，同时注释掉的代码展示了其他可能的方式来实例化HTTP服务器（包括带安全连接的https，以及监听不同网络地址和端口的服务器实例）。</p></li><li><p>当服务器运行在<code>DEBUG</code>模式下，可以设置日志级别、响应等待时间以及清理策略。</p></li><li><p>注释掉的代码示例说明了如何设置服务器的SSL配置，以及如何设置基本或摘要型的HTTP身份验证。</p></li><li><p>服务器利用<code>HttpServer.DocumentRootPath</code>设置了文档根目录路径。</p></li><li><p>通过<code>OnGet</code>事件处理程序来处理HTTP GET请求，可以读取文件并根据文件内容类型设置响应头和正文。</p></li><li><p>服务器添加了<code>Echo</code>和<code>Chat</code>两个WebSocket服务。</p></li><li><p>注释掉的代码中包括了WebSocket服务的详细初始化示例，例如设置协议、校验器和对服务器发送的Cookie进行校验等。</p></li><li><p>服务器启动并开始监听，在控制台上显示一些运行信息。</p></li><li><p>最后，通过读取输入来停止HTTP服务器</p></li></ol> 
 <p>综上所述，本段代码提供了使用WebSocketSharp库创建符合个人需要的HTTP服务器与WebSocket服务的多种示例和配置方法。通过此代码，可以开启一个支持WebSocket通信的服务器，并可通过相关配置来实现安全连接、HTTP认证和基于文档根路径的内容服务能力。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/08/e9/FViPNf5R_o.jpg" alt="57a67985fe5803c188c48885a2b2ebac.jpeg"></p> 
 <p style="text-align:center;">App.config文件<br></p> 
 <p style="text-align:left;">下面代码初始化一个<strong>基于WebSocketSharp库的WebSocket服务器，它允许客户端通过WebSocket协议连接进行通信，并提供HTTP服务，可以响应基于HTTP的GET请求。提供静态文件服务和WebSocket回显(Echo)/聊天(Chat)服务。</strong>支持通过不同方式指定服务的地址和端口，包含了调试模式下的日志等级设置，以及生产模式下的SSL/TLS证书配置和HTTP认证机制的配置，但这些功能默认是被注释掉的。服务器通过控制台命令启动和停止，并能在控制台输出当前服务的状态信息。</p> 
 <pre class="has"><code class="language-cs">using System; // 引入System命名空间
using System.Configuration; // 引入System.Configuration命名空间，用于访问配置文件
using System.Security.Cryptography.X509Certificates; // 引入System.Security.Cryptography.X509Certificates命名空间，用于处理证书
using System.Text; // 引入System.Text命名空间，包含编码和字符集的功能
using WebSocketSharp; // 引入WebSocketSharp命名空间，一个实现WebSocket协议的C#库
using WebSocketSharp.Net; // 引入WebSocketSharp.Net命名空间，提供网络相关的功能
using WebSocketSharp.Server; // 引入WebSocketSharp.Server命名空间，用于创建和管理WebSocket服务器


// 定义了一个名为Example3的命名空间
namespace Example3
{
  // 定义了一个Program类
  public class Program
  {
    // 主函数
    public static void Main (string[] args)
    {
      // 创建HttpServer类的新实例。
      //
      // 如果需要提供安全连接（即HTTPS），应使用带有'secure'参数设置为true
      // 或者带有https协议的HTTP URL来创建新实例。


      var httpsv = new HttpServer (4649); // 在4649端口上实例化HttpServer
      // var httpsv = new HttpServer (5963, true); // 使用SSL在5963端口上实例化HttpServer（代码暂时被注释）


      // 下面的被注释的代码块展示了其他创建HttpServer实例的方式。
      // 例如绑定到所有IP地址、绑定到IPv6地址、通过具体IP实例化等等。
      /*注释掉的代码展示了多种不同的方法来创建HttpServer的实例，包括监听不同的网络接口（所有网络、IPv4回环地址、IPv6回环地址）、监听不同的端口（常规端口、安全端口）、以及支持安全连接（SSL/TLS）。代码被注释意味着虽然是可用的选项，但当前不是活动状态。这些代码为开发者提供了灵活性，在不同场景下快速调整服务器监听的网络接口和端口。*/
      // 使用SSL，在5963端口上创建一个支持安全连接的HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (5963, true); 
        // 在所有网络接口的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (System.Net.IPAddress.Any, 4649); 
        // 在所有网络接口的5963端口上创建支持SSL的HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (System.Net.IPAddress.Any, 5963, true); 
        // 在所有IPv6地址的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (System.Net.IPAddress.IPv6Any, 4649); 
         // 在所有IPv6地址的5963端口上创建支持SSL的HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (System.Net.IPAddress.IPv6Any, 5963, true);
         // 通过HTTP协议，在所有网络接口的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("http://0.0.0.0:4649");
        // 通过HTTPS协议，在所有网络接口的5963端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("https://0.0.0.0:5963");
        // 通过HTTP协议，在所有IPv6地址的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("http://[::0]:4649");
        // 通过HTTPS协议，在所有IPv6地址的5963端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("https://[::0]:5963"); 
        // 在回环接口（localhost）的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (System.Net.IPAddress.Loopback, 4649); 
        // 在回环接口（localhost）的5963端口上创建支持SSL的HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (System.Net.IPAddress.Loopback, 5963, true); 
        // 在IPv6回环接口（localhost）的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (System.Net.IPAddress.IPv6Loopback, 4649); 
        // 在IPv6回环接口（localhost）的5963端口上创建支持SSL的HttpServer实例（代码被注释）
        // var httpsv = new HttpServer (System.Net.IPAddress.IPv6Loopback, 5963, true); 
        // 通过HTTP协议，在localhost的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("http://localhost:4649"); 
        // 通过HTTPS协议，在localhost的5963端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("https://localhost:5963"); 
        // 通过HTTP协议，在127.0.0.1（IPv4回环地址）的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("http://127.0.0.1:4649"); 
         // 通过HTTPS协议，在127.0.0.1（IPv4回环地址）的5963端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("https://127.0.0.1:5963");
        // 通过HTTP协议，在[::1]（IPv6回环地址）的4649端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("http://[::1]:4649"); 
        // 通过HTTPS协议，在[::1]（IPv6回环地址）的5963端口上创建HttpServer实例（代码被注释）
        // var httpsv = new HttpServer ("https://[::1]:5963");


#if DEBUG
      // 若是处于DEBUG模式，以下参数会被设置。
      httpsv.Log.Level = LogLevel.Trace; // 日志级别被设置为Trace


      // 以下是在DEBUG模式下可能会设置的其他参数。
       // 更改响应WebSocket Ping或Close的等待时间为2秒（代码被注释）
      // httpsv.WaitTime = TimeSpan.FromSeconds (2); 
      // httpsv.KeepClean = false; // 不定期移除不活跃的WebSocket会话（代码被注释）


#endif
        /*被注释掉的代码展示了如何对HttpServer实例进行配置，包括配置安全连接（设置服务器证书）、提供HTTP认证（设置认证方案，用户凭证查找函数）以及解决等待处于TIME_WAIT状态的套接字的问题。被注释意味着这些配置在当前不被应用，这些代码为开发者提供了灵活性，在不同场景下快速调整服务器的配置。*/
      // 若要启用具有安全性的连接（SSL/TLS），需要取消以下部分的注释，
      // 并指定服务器证书的路径与密码。
        // 提供安全连接
        /*
        var cert = ConfigurationManager.AppSettings["ServerCertFile"]; // 获取服务器证书文件路径
        var passwd = ConfigurationManager.AppSettings["CertFilePassword"]; // 获取服务器证书文件密码
        httpsv.SslConfiguration.ServerCertificate = new X509Certificate2 (cert, passwd); // 创建X509证书实例并设置为服务器证书（代码段被注释）
        */


        // 提供HTTP认证（基础认证/摘要认证）
        /*
        httpsv.AuthenticationSchemes = AuthenticationSchemes.Basic; // 设置认证方案为基础认证
        httpsv.Realm = "WebSocket Test"; // 设置领域/域名为"WebSocket Test"
        httpsv.UserCredentialsFinder = id =&gt; {
            var name = id.Name; // 获取用户名


            // 返回用户名、密码以及角色
            return name == "nobita"
                ? new NetworkCredential (name, "password", "gunfighter")
                : null; // 如果找不到用户的凭证，则返回null（代码段被注释）
        };
        */


        // 解决等待处于TIME_WAIT状态的套接字问题
        // httpsv.ReuseAddress = true; // 设置可重用地址（代码被注释）


 


      // 设置文档根路径。
      httpsv.DocumentRootPath = ConfigurationManager.AppSettings["DocumentRootPath"];


      // 设置HTTP GET请求处理事件。
        httpsv.OnGet += (sender, e) =&gt; { // 为httpsv实例的OnGet事件绑定一个事件处理程序
            var req = e.Request; // 获取请求对象
            var res = e.Response; // 获取响应对象


            var path = req.RawUrl; // 获取请求的RawUrl属性，即原始请求路径


            if (path == "/") // 如果请求路径是根目录
            path += "index.html"; // 则将路径改为"index.html"


            byte[] contents; // 定义一个字节数组来存放文件内容


            if (!e.TryReadFile (path, out contents)) { // 尝试读取指定路径的文件内容到contents数组中
            res.StatusCode = (int) HttpStatusCode.NotFound; // 如果文件不存在，设置响应状态码为404（未找到）


            return; // 结束事件处理
            }


            // 以下根据请求文件的类型设置Content-Type响应头
            if (path.EndsWith(".html")) { // 如果文件是HTML文件
            res.ContentType = "text/html"; // 设置响应内容类型为text/html
            res.ContentEncoding = Encoding.UTF8; // 设置响应内容的编码为UTF-8
            }
            else if (path.EndsWith(".js")) { // 如果文件是JavaScript文件
            res.ContentType = "application/javascript"; // 设置响应内容类型为application/javascript
            res.ContentEncoding = Encoding.UTF8; // 同样设置编码为UTF-8
            }


            res.ContentLength64 = contents.LongLength; // 设置响应内容的长度


            res.Close(contents, true); // 将内容发送给客户端并关闭响应
        };


      // 添加WebSocket服务。
      httpsv.AddWebSocketService&lt;Echo&gt; ("/Echo"); // 添加Echo服务
      httpsv.AddWebSocketService&lt;Chat&gt; ("/Chat"); // 添加Chat服务
      // WebSocket服务的初始化（如果需要初始化参数）。下面的多个注释代码块用于配置服务。


      httpsv.Start(); // 启动HttpServer


      // 如果服务器已经开始监听，则输出一些基本的服务信息。
      if (httpsv.IsListening) {
        Console.WriteLine ("Listening on port {0}, and providing WebSocket services:", httpsv.Port);
        foreach (var path in httpsv.WebSocketServices.Paths)
          Console.WriteLine ("- {0}", path); // 输出提供服务的路径
      }


      Console.WriteLine ("\nPress Enter key to stop the server..."); // 提示按下回车停止服务器
      Console.ReadLine (); // 等待用户输入


      httpsv.Stop (); // 停止HttpServer
    }
  }
}</code></pre> 
 <p>启动服务：<br></p> 
 <pre class="has"><code class="language-diff">Listening on port 4649, and providing WebSocket services:
- /Echo
- /Chat


Press Enter key to stop the server...</code></pre> 
 <p>下面代码定义了一个<strong>名为<code>Chat</code>的类，该类继承自<code>WebSocketBehavior</code>类，用于处理WebSocket服务器的一个聊天服务</strong>。在新的WebSocket连接建立时获取用户名，并向所有已连上的会话广播该用户已上线的消息。当收到消息时，将该用户的用户名和消息内容进行拼装，并广播给所有已连上的会话。当WebSocket连接断开时，广播该用户已下线的消息。整个<code>Chat</code>类就是一个简单的聊天室服务的实现。</p> 
 <pre class="has"><code class="language-cs">using System; // 引用System命名空间
using System.Threading; // 引用System.Threading命名空间，提供多线程相关的功能
using WebSocketSharp; // 引用WebSocketSharp命名空间，一个实现WebSocket协议的C#库
using WebSocketSharp.Server; // 引用WebSocketSharp.Server命名空间，用于创建和管理WebSocket服务器


// 定义Example3名字空间
namespace Example3
{
  // 定义公共类Chat，继承自WebSocketBehavior
  public class Chat : WebSocketBehavior
  {
    private string _name; // 私有字符串变量，表示聊天的用户名
    private static int _number = 0; // 私有静态整型变量，与用户名关联
    private string _prefix; // 私有字符串变量，表示用户名前缀


    // 构造函数
    public Chat ()
    {
      _prefix = "anon#"; // 默认的用户名前缀是“anon#”
    }


    // Prefix 属性的get和set方法
    public string Prefix {
      get {
        return _prefix;
      }


      set {
        _prefix = !value.IsNullOrEmpty () ? value : "anon#";
      }
    }


    // 获取用户名的私有方法
    private string getName ()
    {
      var name = Context.QueryString["name"]; // 获取QueryString中的"name"字段的值作为用户名


      return !name.IsNullOrEmpty () ? name : _prefix + getNumber (); // 如果"name"字段非空，则用户名为其值，否则，用户名为前缀+_number
    }


    // 获取_number的私有方法，并使用Interlocked增量操作该变量，保证线程安全
    private static int getNumber ()
    {
      return Interlocked.Increment(ref _number);
    }


    // 覆盖基类的OnClose方法，该方法在WebSocket连接关闭时被调用
    protected override void OnClose (CloseEventArgs e)
    {
      if (_name == null)
        return;


      var fmt = "{0} got logged off..."; // 定义消息格式
      var msg = String.Format (fmt, _name); // 格式化消息字符串


      Sessions.Broadcast (msg); // 向所有连接的会话广播消息
    }


    // 覆盖基类的OnMessage方法，该方法在收到WebSocket消息时被调用
    protected override void OnMessage (MessageEventArgs e)
    {
      var fmt = "{0}: {1}"; // 定义消息格式
      var msg = String.Format (fmt, _name, e.Data); // 格式化消息字符串


      Sessions.Broadcast (msg); // 向所有连接的会话广播消息
    }


    // 覆盖基类的OnOpen方法，该方法在建立新的WebSocket连接后立即被调用
    protected override void OnOpen ()
    {
      _name = getName (); // 获取用户名


      var fmt = "{0} has logged in!"; // 定义消息格式
      var msg = String.Format (fmt, _name); // 格式化消息字符串


      Sessions.Broadcast (msg); // 向所有连接的会话广播消息
    }
  }
}</code></pre> 
 <p>下面代码定义了名为<code>Echo</code>的类，该类继承自<code>WebSocketBehavior</code>，用于处理WebSocket服务器上的回声服务。当<code>Echo</code>服务的WebSocket连接收到客户端送来的消息时，它简单地将相同的消息数据直接返回给客户端。这个类通常用于测试客户端与服务器的连接是否正常，检查消息的去程和回程延迟。</p> 
 <pre class="has"><code class="language-cs">using System; // 引入System命名空间
using WebSocketSharp; // 引入WebSocketSharp命名空间，一个实现WebSocket协议的C#库
using WebSocketSharp.Server; // 引入WebSocketSharp.Server命名空间，用于创建和管理WebSocket服务器


// 定义Example3名字空间
namespace Example3
{
  // 定义公共类Echo，继承自WebSocketBehavior
  public class Echo : WebSocketBehavior
  {
    // 覆盖基类的OnMessage方法，该方法在收到WebSocket消息时被调用
    protected override void OnMessage(MessageEventArgs e)
    {
      Send(e.Data); // 将收到的消息数据发送回客户端，实现回声（echo）功能
    }
  }
}</code></pre> 
 <p style="text-align:center;"><strong>示例1</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/c8/67/Jg0YBa6C_o.png" alt="af6eaed453175458d653b19ba0efa8e9.png"></p> 
 <p style="text-align:left;">这段代码展示了如何<strong>使用<code>WebSocketSharp</code>库创建一个WebSocket客户端，连接到WebSocket服务器，并发送和接收消息。</strong>它提供了<strong>处理打开连接、接收消息、发生错误以及关闭连接的事件处理程序</strong>。代码还包括了调试相关的设置，以及一些被注释的代码块来展示如何配置WebSocket客户端（例如SSL证书验证、发送凭证、处理cookies等），但这些部分目前并未启用。用户通过控制台可以输入消息发送到服务器，输入"exit"来关闭程序。</p> 
 <pre class="has"><code class="language-cs">using System; // 引入System命名空间，它是最基础的命名空间
using System.Threading; // 引入多线程相关的命名空间
using WebSocketSharp; // 引入WebSocketSharp库，它提供了WebSocket协议的实现
using WebSocketSharp.Net; // 引入网络相关的命名空间


namespace Example // 定义一个名为Example的命名空间
{
  public class Program // 定义一个公共类Program
  {
    public static void Main (string[] args) // 主函数，程序入口点
    {
        // 创建 WebSocket 类的新实例。
       //
       // WebSocket类继承了System.IDisposable接口，因此可以
       // 使用using 语句。 WebSocket 连接将被关闭
       // 当控件离开 using 块时关闭状态 1001（离开）。
       //
       // 如果您想通过安全连接连接到服务器，
       // 您应该使用 wss 方案 WebSocket URL 创建一个新实例。


      using (var ws = new WebSocket ("ws://localhost:4649/Echo")) // 创建一个WebSocket实例连接到指定的服务端地址和端口
      //using (var ws = new WebSocket ("wss://localhost:5963/Echo"))
      //using (var ws = new WebSocket ("ws://localhost:4649/Chat"))
      //using (var ws = new WebSocket ("wss://localhost:5963/Chat"))
      //using (var ws = new WebSocket ("ws://localhost:4649/Chat?name=nobita"))
      //using (var ws = new WebSocket ("wss://localhost:5963/Chat?name=nobita"))
      {
        // 设置WebSocket事件


        ws.OnOpen += (sender, e) =&gt; ws.Send ("Hi, there!"); // 当WebSocket连接建立时，发送一条消息"Hi, there!"


        ws.OnMessage += (sender, e) =&gt; { // 当从服务端接收到消息时，执行该事件
            var fmt = "[WebSocket Message] {0}"; // 定义一个格式字符串
            var body = !e.IsPing ? e.Data : "A ping was received."; // 如果接收到的不是Ping消息，则输出数据，否则输出"A ping was received."


            Console.WriteLine (fmt, body); // 将消息输出到控制台
          };


        ws.OnError += (sender, e) =&gt; { // 当发生错误时，执行该事件
            var fmt = "[WebSocket Error] {0}"; // 定义一个格式字符串


            Console.WriteLine (fmt, e.Message); // 将错误信息输出到控制台
          };


        ws.OnClose += (sender, e) =&gt; { // 当WebSocket连接关闭时，执行该事件
            var fmt = "[WebSocket Close ({0})] {1}"; // 定义一个格式字符串


            Console.WriteLine (fmt, e.Code, e.Reason); // 将关闭信息输出到控制台
          };
  
#if DEBUG
        // 调试时设置的额外选项
        ws.Log.Level = LogLevel.Trace; // 设置日志级别


        // 设置等待Ping或Close的响应时间为10秒（代码被注释）
        // ws.WaitTime = TimeSpan.FromSeconds (10);


        // 当接收到ping时触发WebSocket.OnMessage事件（代码被注释）
        // ws.EmitOnPing = true;
#endif


        // 开启消息压缩功能
        // ws.Compression = CompressionMethod.Deflate; //（代码被注释）


        // 验证服务器证书（代码段被注释）
        /*
        ws.SslConfiguration.ServerCertificateValidationCallback =
          (sender, certificate, chain, sslPolicyErrors) =&gt; {
            // 省略了输出证书信息的代码
            return true; // 如果服务器证书有效
          };
         */


        // 发送HTTP认证信息（基础认证或摘要认证）（代码被注释）
        // ws.SetCredentials ("nobita", "password", false);


        // 发送来源页首部（代码被注释）
        // ws.Origin = "http://localhost:4649";


        // 发送cookies（代码被注释）
        // ws.SetCookie (new Cookie ("name", "nobita"));
        // ws.SetCookie (new Cookie ("roles", "\"idiot, gunfighter\""));


        // 通过HTTP代理服务器连接（代码被注释）
        // ws.SetProxy ("http://localhost:3128", "nobita", "password");


        // 开启重定向（代码被注释）
        // ws.EnableRedirection = true;


        ws.Connect (); // 连接到服务器


        // 异步连接到服务器（代码被注释）
        // ws.ConnectAsync ();


        Console.WriteLine ("\nType 'exit' to exit.\n"); // 输出提示信息


        while (true) { // 开始一个循环，持续监听输入
          Thread.Sleep (1000); // 线程休眠1秒
          Console.Write ("&gt; "); // 控制台输出"&gt; "


          var msg = Console.ReadLine (); // 读取用户输入


          if (msg == "exit") // 如果输入的是"exit"
            break; // 跳出循环


          ws.Send (msg); // 将输入的消息发送到WebSocket服务器
        }
      }
    }
  }
}</code></pre> 
 <p style="text-align:center;"><strong>示例2</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/ec/5b/LOtJ3aDh_o.png" alt="e5bf9e54135c4af7463802cc6cd95997.png"></p> 
 <p style="text-align:left;">这段代码演示了如何使用<code>WebSocketSharp</code>库创建一个WebSocket服务器，并监听特定的端口（例如4649）。服务器被配置为提供两种WebSocket服务：Echo和Chat。服务器的日志级别在调试模式下被设置为Trace，以便记录详细信息，方便开发者调试。此外，代码还包含了一些注释掉的部分，展示了如何进行更多高级配置，例如配置SSL/TLS安全连接，启用HTTP基础或摘要认证，设置地址重用，定制WebSocket服务的初始化参数等。其中大多数配置目前都被注释了，所以不会生效。服务器启动后，会打印正在监听的端口和提供的WebSocket服务路径。代码的最后部分等待用户按回车键来停止服务器。</p> 
 <pre class="has"><code class="language-cs">using System; // 使用System命名空间，包含基本的类定义和类型。
using System.Configuration; // 引用配置管理相关的类，如读取配置文件等。
using System.Security.Cryptography.X509Certificates; // 引用安全性和加密相关的类，特别是处理X509证书。
using WebSocketSharp; // 引用WebSocketSharp库，它提供实现WebSocket协议的类。
using WebSocketSharp.Net; // 引用网络相关的类。
using WebSocketSharp.Server; // 引用WebSocket服务器相关的类。


namespace Example2 // 定义一个名为Example2的命名空间。
{
  public class Program // 定义一个公共类Program。
  {
    public static void Main (string[] args) // 主函数，程序的入口点。
    {
      // 创建一个新的WebSocketServer实例。
      var wssv = new WebSocketServer (4649); // 初始化一个监听端口为4649的WebSocket服务器实例。
      //var wssv = new WebSocketServer (5963, true); // （被注释）同时指出此服务器为安全连接（wss）。


        //var wssv = new WebSocketServer (System.Net.IPAddress.Any, 4649); // 使用任意IPv4地址。
        //var wssv = new WebSocketServer (System.Net.IPAddress.Any, 5963, true); // 使用任意IPv4地址和提供安全连接。


        //var wssv = new WebSocketServer (System.Net.IPAddress.IPv6Any, 4649); // 使用任意IPv6地址。
        //var wssv = new WebSocketServer (System.Net.IPAddress.IPv6Any, 5963, true); // 使用任意IPv6地址和提供安全连接。


        //var wssv = new WebSocketServer ("ws://0.0.0.0:4649"); // 使用IPv4通配地址。
        //var wssv = new WebSocketServer ("wss://0.0.0.0:5963"); // 使用IPv4通配地址和提供安全连接。


        //var wssv = new WebSocketServer ("ws://[::0]:4649"); // 使用IPv6通配地址。
        //var wssv = new WebSocketServer ("wss://[::0]:5963"); // 使用IPv6通配地址和提供安全连接。


        //var wssv = new WebSocketServer (System.Net.IPAddress.Loopback, 4649); // 使用本机回环地址IPv4。
        //var wssv = new WebSocketServer (System.Net.IPAddress.Loopback, 5963, true); // 使用本机回环地址IPv4和提供安全连接。


        //var wssv = new WebSocketServer (System.Net.IPAddress.IPv6Loopback, 4649); // 使用本机回环地址IPv6。
        //var wssv = new WebSocketServer (System.Net.IPAddress.IPv6Loopback, 5963, true); // 使用本机回环地址IPv6和提供安全连接。


        //var wssv = new WebSocketServer ("ws://localhost:4649"); // 使用localhost和端口4649。
        //var wssv = new WebSocketServer ("wss://localhost:5963"); // 使用localhost和端口5963提供安全连接。


        //var wssv = new WebSocketServer ("ws://127.0.0.1:4649"); // 使用IPv4的本机回环地址和端口4649。
        //var wssv = new WebSocketServer ("wss://127.0.0.1:5963"); // 使用IPv4的本机回环地址和端口5963提供安全连接。


        //var wssv = new WebSocketServer ("ws://[::1]:4649"); // 使用IPv6的本机回环地址和端口4649。
        //var wssv = new WebSocketServer ("wss://[::1]:5963"); // 使用IPv6的本机回环地址和端口5963提供安全连接。






#if DEBUG
      // 更改日志级别（只有在调试模式下起作用）。
      wssv.Log.Level = LogLevel.Trace; // 设置日志级别为Trace（追踪），目的是显示尽可能多的调试信息。


      // 更改WebSocket Ping或Close回应的等待时间（代码被注释）。
      // wssv.WaitTime = TimeSpan.FromSeconds (2);


      // 不定期移除非活动会话（代码被注释）。
      // wssv.KeepClean = false;
#endif
      // 提供安全连接（代码段被注释）。
      /*
      var cert = ConfigurationManager.AppSettings["ServerCertFile"]; // 从配置文件获取证书文件路径。
      var passwd = ConfigurationManager.AppSettings["CertFilePassword"]; // 从配置文件获取证书密码。
      wssv.SslConfiguration.ServerCertificate = new X509Certificate2 (cert, passwd); // 创建证书实例并应用于服务器的SSL配置。
       */


      // 提供HTTP认证（基础/摘要）（代码段被注释）。
      /*
      wssv.AuthenticationSchemes = AuthenticationSchemes.Basic; // 设置认证方案为Basic（基础认证）。
      wssv.Realm = "WebSocket Test"; // 设置认证域为"WebSocket Test"。
      wssv.UserCredentialsFinder = id =&gt; { // 设置用户凭据查找函数。
          var name = id.Name; // 获取用户名。


          // 返回用户名、密码和角色。
          return name == "nobita" // 如果用户名为"nobita"，则返回凭据。
                 ? new NetworkCredential (name, "password", "gunfighter")
                 : null; // 如果用户凭据未找到，返回null。
        };
       */


      // 解决等待处于TIME_WAIT状态的套接字（代码被注释）。
      // wssv.ReuseAddress = true;


      // 添加WebSocket服务。
      wssv.AddWebSocketService&lt;Echo&gt; ("/Echo"); // 添加名为"/Echo"的WebSocket回音服务。
      wssv.AddWebSocketService&lt;Chat&gt; ("/Chat"); // 添加名为"/Chat"的WebSocket聊天服务。


      // 添加WebSocket服务并进行初始化（代码段被注释）。
        // 用初始化方案添加WebSocket服务（以下代码被注释，并没有在实际程序中运行）。
        /*
        wssv.AddWebSocketService&lt;Chat&gt; (
        "/Chat",
        s =&gt; {
            s.Prefix = "Anon#"; // 设置聊天服务的前缀。


            // 发送包含子协议名称的Sec-WebSocket-Protocol头。
            s.Protocol = "chat"; // 为聊天服务设置子协议。


            // 忽略Sec-WebSocket-Extensions头。
            s.IgnoreExtensions = true; // 忽略WebSocket扩展。


            // 在接收到ping时发出WebSocket.OnMessage事件。
            s.EmitOnPing = true; // 允许ping消息触发OnMessage事件。


            // 验证Origin头。
            s.OriginValidator = val =&gt; {
                // 检查Origin头的值，如果有效则返回true。
                Uri origin;
                return !val.IsNullOrEmpty()
                    &amp;&amp; Uri.TryCreate(val, UriKind.Absolute, out origin)
                    &amp;&amp; origin.Host == "localhost"; // 如果来源是localhost，则认为是有效的。
            };


            // 验证cookies。
            s.CookiesValidator = (req, res) =&gt; {
                // 检查请求中的cookies，并在必要时设置要发送给客户端的cookies。
                foreach (var cookie in req) {
                cookie.Expired = true; // 将请求中的所有cookie设置为过期。
                res.Add(cookie); // 将过期的cookie添加到响应中。
                }
                return true; // 如果验证有效则返回true。
            };
        }
        );
        */


      wssv.Start (); // 启动WebSocket服务器。


      // 如果WebSocket服务器正在监听，则输出信息。
      if (wssv.IsListening) {
        Console.WriteLine ("Listening on port {0}, and providing WebSocket services:", wssv.Port); // 打印监听端口及服务信息。


        // 循环通过WebSocket服务器提供的服务路径，并打印出来。
        foreach (var path in wssv.WebSocketServices.Paths)
          Console.WriteLine ("- {0}", path); // 打印服务路径。
      }


      Console.WriteLine ("\nPress Enter key to stop the server..."); // 提示按回车键停止服务器。
      Console.ReadLine (); // 等待用户输入回车键。


      wssv.Stop (); // 停止WebSocket服务器。
    }
  }
}</code></pre> 
 <p style="text-align:center;"><strong>笔记</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/e3/35/biCNVaPV_o.png" alt="68635649ca738c4b174a0e2aded3d4cf.png"></p> 
 <p><img src="https://images2.imgbox.com/13/f2/nkVh2Bih_o.png" alt="71a6b49677888a8937eccae70615117b.png"></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/0c/e3/F8siIaER_o.png" alt="8c9e48b975b5a130232f4610be8b1e59.png"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/421a7e00b39999e01c32020d077d9834/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">macos brew python3 error: externally-managed-environment</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a06afee7f1c66922717d33b7303ff6d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLO在mac上的安装和使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>