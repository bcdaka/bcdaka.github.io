<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android显示系统SurfaceFlinger详解 超级干货 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3d87482f1aa775a080af755d7ef6b182/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Android显示系统SurfaceFlinger详解 超级干货">
  <meta property="og:description" content="本文详细讲解了Android显示系统SurfaceFlinger，文中通过示例代码介绍的非常详细。对大家的学习或工作具有一定的参考借鉴价值，需要的朋友可以参考下
目录 一、Android系统启动二、SurfaceFlinger代码剖析[Android 11] 1.【执行文件-surfaceflinger】2.【动态库-libsurfaceflinger.so】3. 服务启动配置文件：/frameworks/native/services/surfaceflinger/surfaceflinger.rc4. Surface 创建过程 ①FramebufferNativeWindow②应用程序的本地窗口 - Surface③Surface的创建④SurfaceFlinger服务框架： 一、Android系统启动 Android设备从按下开机键到桌面显示画面，大致过程如下图流程：
开机显示桌面、从桌面点击 App 图标到 Activity显示在屏幕上的过程又是怎样的呢？下面介绍Android系统中的“画家” - SurfaceFlinger.
SurfaceFlinger 启动过程：
二、SurfaceFlinger代码剖析[Android 11] 代码路径：/frameworks/native/services/surfaceflinger/
SurfaceFlinger二进制分成surfaceflinger可执行文件（main入口）和libsurfaceflinger.so库文件（功能实现），由main_surfaceflinger.cpp文件编译而成，Android.bp代码模块编译配置如下：
1.【执行文件-surfaceflinger】 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-16T15:08:07+08:00">
    <meta property="article:modified_time" content="2024-01-16T15:08:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android显示系统SurfaceFlinger详解 超级干货</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>本文详细讲解了Android显示系统SurfaceFlinger，文中通过示例代码介绍的非常详细。对大家的学习或工作具有一定的参考借鉴价值，需要的朋友可以参考下</p> 
<p></p> 
<h6>目录</h6> 
<ul><li><a href="https://www.jb51.net/article/232330.htm#_label0" rel="nofollow" title="一、Android系统启动">一、Android系统启动</a></li><li><a href="https://www.jb51.net/article/232330.htm#_label1" rel="nofollow" title="二、SurfaceFlinger代码剖析[Android 11]">二、SurfaceFlinger代码剖析[Android 11]</a> 
  <ul><li><a href="https://www.jb51.net/article/232330.htm#_lab2_1_0" rel="nofollow" title="1.【执行文件-surfaceflinger】">1.【执行文件-surfaceflinger】</a></li><li><a href="https://www.jb51.net/article/232330.htm#_lab2_1_1" rel="nofollow" title="2.【动态库-libsurfaceflinger.so】">2.【动态库-libsurfaceflinger.so】</a></li><li><a href="https://www.jb51.net/article/232330.htm#_lab2_1_2" rel="nofollow" title="3. 服务启动配置文件：/frameworks/native/services/surfaceflinger/surfaceflinger.rc">3. 服务启动配置文件：/frameworks/native/services/surfaceflinger/surfaceflinger.rc</a></li><li><a href="https://www.jb51.net/article/232330.htm#_lab2_1_3" rel="nofollow" title="4. Surface 创建过程">4. Surface 创建过程</a> 
    <ul><li><a href="https://www.jb51.net/article/232330.htm#_label3_1_3_0" rel="nofollow" title="①FramebufferNativeWindow">①FramebufferNativeWindow</a></li><li><a href="https://www.jb51.net/article/232330.htm#_label3_1_3_1" rel="nofollow" title="②应用程序的本地窗口 - Surface">②应用程序的本地窗口 - Surface</a></li><li><a href="https://www.jb51.net/article/232330.htm#_label3_1_3_2" rel="nofollow" title="③Surface的创建">③Surface的创建</a></li><li><a href="https://www.jb51.net/article/232330.htm#_label3_1_3_3" rel="nofollow" title="④SurfaceFlinger服务框架：">④SurfaceFlinger服务框架：</a></li></ul></li></ul></li></ul> 
<p><a name="_label0"></a></p> 
<h3 id="heading-0">一、Android系统启动</h3> 
<p>Android设备从按下开机键到桌面显示画面，大致过程如下图流程：</p> 
<p></p> 
<p class="img-center"><img alt="" height="661" src="https://images2.imgbox.com/39/ae/CSyIdHeV_o.jpg" width="1009"></p> 
<p>开机显示桌面、从桌面点击 App 图标到 Activity显示在屏幕上的过程又是怎样的呢？下面介绍Android系统中的“画家” - SurfaceFlinger.</p> 
<p>SurfaceFlinger 启动过程：</p> 
<p></p> 
<p class="img-center"><img alt="" height="654" src="https://images2.imgbox.com/f9/f2/0t2lFWXj_o.jpg" width="1038"></p> 
<p><a name="_label1"></a></p> 
<h3 id="heading-1">二、SurfaceFlinger代码剖析[Android 11]</h3> 
<p>代码路径：/frameworks/native/services/surfaceflinger/</p> 
<p>SurfaceFlinger二进制分成surfaceflinger可执行文件（main入口）和libsurfaceflinger.so库文件（功能实现），由main_surfaceflinger.cpp文件编译而成，Android.bp代码模块编译配置如下：</p> 
<p><a name="_lab2_1_0"></a></p> 
<h4 id="heading-2">1.【执行文件-surfaceflinger】</h4> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> </td><td> <p><code>...cc_binary {<!-- --></code></p> <p><code>    </code><code>name: </code><code>"surfaceflinger"</code><code>,</code></p> <p><code>    </code><code>defaults: [</code><code>"surfaceflinger_defaults"</code><code>],</code></p> <p><code>    </code><code>init_rc: [</code><code>"surfaceflinger.rc"</code><code>],</code></p> <p><code>    </code><code>srcs: [</code><code>"main_surfaceflinger.cpp"</code><code>],</code></p> <p><code>    </code><code>whole_static_libs: [</code></p> <p><code>        </code><code>"libsigchain"</code><code>,</code></p> <p><code>    </code><code>],</code></p> <p><code>    </code><code>shared_libs: [</code></p> <p><code>        </code><code>"android.frameworks.displayservice@1.0"</code><code>,</code></p> <p><code>        </code><code>"android.hardware.configstore-utils"</code><code>,</code></p> <p><code>        </code><code>"android.hardware.configstore@1.0"</code><code>,</code></p> <p><code>        </code><code>"android.hardware.graphics.allocator@2.0"</code><code>,</code></p> <p><code>        </code><code>"libbinder"</code><code>,</code></p> <p><code>        </code><code>"libcutils"</code><code>,</code></p> <p><code>        </code><code>"libdisplayservicehidl"</code><code>,</code></p> <p><code>        </code><code>"libhidlbase"</code><code>,</code></p> <p><code>        </code><code>"libhidltransport"</code><code>,</code></p> <p><code>        </code><code>"liblayers_proto"</code><code>,</code></p> <p><code>        </code><code>"liblog"</code><code>,</code></p> <p><code>        </code><code>"libsurfaceflinger"</code><code>,</code></p> <p><code>        </code><code>"libtimestats_proto"</code><code>,</code></p> <p><code>        </code><code>"libutils"</code><code>,</code></p> <p><code>    </code><code>],</code></p> <p><code>    </code><code>static_libs: [</code></p> <p><code>        </code><code>"libserviceutils"</code><code>,</code></p> <p><code>        </code><code>"libtrace_proto"</code><code>,</code></p> <p><code>    </code><code>],</code></p> <p><code>    </code><code>ldflags: [</code><code>"-Wl,--export-dynamic"</code><code>],</code></p> <p></p> <p><code>    </code><code>// TODO(b/71715793): These version-scripts are required due to the use of</code></p> <p><code>    </code><code>// whole_static_libs to pull in libsigchain. To work, the files had to be</code></p> <p><code>    </code><code>// locally duplicated from their original location</code></p> <p><code>    </code><code>// $ANDROID_ROOT/art/sigchainlib/</code></p> <p><code>    </code><code>multilib: {<!-- --></code></p> <p><code>        </code><code>lib32: {<!-- --></code></p> <p><code>            </code><code>version_script: </code><code>"version-script32.txt"</code><code>,</code></p> <p><code>        </code><code>},</code></p> <p><code>        </code><code>lib64: {<!-- --></code></p> <p><code>            </code><code>version_script: </code><code>"version-script64.txt"</code><code>,</code></p> <p><code>        </code><code>},</code></p> <p><code>    </code><code>},</code></p> <p><code>}...</code></p> </td></tr></tbody></table> 
<p>SurfaceFlinger可执行二进制文件surfaceflinger由main_surfaceflinger.cpp文件独立编译而成，主要负责搭建进程启动环境：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> </td><td> <p><code>int</code> <code>main(</code><code>int</code><code>, </code><code>char</code><code>**) {<!-- --></code></p> <p><code>    </code><code>signal(SIGPIPE, SIG_IGN);</code></p> <p></p> <p><code>    </code><code>// 从8.0开始，Android提供了hidl机制，将原先直接由JNI-&gt;Native-&gt;HAL的接口调用形式，统一规范成hidl service/client交互形式。</code></p> <p><code>    </code><code>// 该方式从一方面规范和统一了Android Framework和HAL的调用机制，但实际从项目维度，这种调用方式对性能上开销，将比直接调用的方式要花费更多的时间。</code></p> <p><code>    </code><code>hardware::configureRpcThreadpool(</code><code>1</code> <code>/* maxThreads */</code><code>,</code></p> <p><code>            </code><code>false</code> <code>/* callerWillJoin */</code><code>);</code></p> <p></p> <p><code>    </code><code>startGraphicsAllocatorService();</code></p> <p></p> <p><code>    </code><code>// When SF is launched in its own process, limit the number of</code></p> <p><code>    </code><code>// binder threads to 4.</code></p> <p><code>    </code><code>ProcessState::self()-&gt;setThreadPoolMaxThreadCount(</code><code>4</code><code>);</code></p> <p></p> <p><code>    </code><code>// start the thread pool</code></p> <p><code>    </code><code>sp&lt;ProcessState&gt; ps(ProcessState::self());</code></p> <p><code>    </code><code>ps-&gt;startThreadPool();</code></p> <p></p> <p><code>    </code><code>// 创建SurfaceFlinger对象，由强指针指向。</code></p> <p><code>    </code><code>// SurfaceFlinger继承RefBase类，所以此处一旦new出对象赋给sp指针后，将立刻出发SurfaceFlinger类的onFirstRef方法的调用。</code></p> <p><code>    </code><code>// instantiate surfaceflinger</code></p> <p><code>    </code><code>sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::createSurfaceFlinger();</code></p> <p></p> <p><code>    </code><code>setpriority(PRIO_PROCESS, </code><code>0</code><code>, PRIORITY_URGENT_DISPLAY);</code></p> <p></p> <p><code>    </code><code>set_sched_policy(</code><code>0</code><code>, SP_FOREGROUND);</code></p> <p></p> <p><code>    </code><code>// Put most SurfaceFlinger threads in the system-background cpuset</code></p> <p><code>    </code><code>// Keeps us from unnecessarily using big cores</code></p> <p><code>    </code><code>// Do this after the binder thread pool init</code></p> <p><code>    </code><code>if</code> <code>(cpusets_enabled()) set_cpuset_policy(</code><code>0</code><code>, SP_SYSTEM);</code></p> <p></p> <p><code>    </code><code>// SurfaceFlinger类正式初始化</code></p> <p><code>    </code><code>// initialize before clients can connect</code></p> <p><code>    </code><code>flinger-&gt;init();</code></p> <p></p> <p><code>    </code><code>// SurfaceFlinger向ServiceManager注册Binder服务，</code></p> <p><code>    </code><code>// 这样在其他进程中可以通过getService+SERVICE_NAME来获取SurfaceFlinger服务，继而可以和SurfaceFlinger类进行Binder通信。</code></p> <p><code>    </code><code>// publish surface flinger</code></p> <p><code>    </code><code>sp&lt;IServiceManager&gt; sm(defaultServiceManager());</code></p> <p><code>    </code><code>sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, </code><code>false</code><code>,</code></p> <p><code>                   </code><code>IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);</code></p> <p></p> <p><code>    </code><code>//里面的new DisplayService()方法调用HIDL定义接口 Return&lt;sp&lt;IDisplayEventReceiver &gt;&gt; getEventReceiver() override;</code></p> <p><code>    </code><code>startDisplayService(); </code><code>// dependency on SF getting registered above</code></p> <p></p> <p><code>    </code><code>if</code> <code>(SurfaceFlinger::setSchedFifo(</code><code>true</code><code>) != NO_ERROR) {<!-- --></code></p> <p><code>        </code><code>ALOGW(</code><code>"Couldn't set to SCHED_FIFO: %s"</code><code>, strerror(errno));</code></p> <p><code>    </code><code>}</code></p> <p></p> <p><code>    </code><code>// SurfaceFlinger类进入主循环（此处注意SurfaceFlinger类未继承Threads类，不遵循Threads类的接口执行顺序）</code></p> <p><code>    </code><code>// run surface flinger in this thread</code></p> <p><code>    </code><code>flinger-&gt;run();</code></p> <p></p> <p><code>    </code><code>return</code> <code>0</code><code>;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>HIDL接口介绍可以参考：<a href="https://source.android.google.cn/reference/hidl/" rel="nofollow" title="HIDL 接口文档  |  Android 开源项目  |  Android Open Source Project">HIDL 接口文档  |  Android 开源项目  |  Android Open Source Project</a></p> 
<p><a name="_lab2_1_1"></a></p> 
<h4 id="heading-3">2.【动态库-libsurfaceflinger.so】</h4> 
<p>Android.bp代码模块编译配置如下：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> </td><td> <p><code>...cc_library_shared {<!-- --></code></p> <p><code>    </code><code>name: </code><code>"libsurfaceflinger"</code><code>,</code></p> <p><code>    </code><code>defaults: [</code><code>"libsurfaceflinger_defaults"</code><code>],</code></p> <p><code>    </code><code>cflags: [</code></p> <p><code>        </code><code>"-fvisibility=hidden"</code><code>,</code></p> <p><code>        </code><code>"-Werror=format"</code><code>,</code></p> <p><code>        </code><code>"-DREDUCE_VIDEO_WORKLOAD"</code><code>,</code></p> <p><code>        </code><code>"-DUSE_AML_HW_ACTIVE_MODE"</code><code>,</code></p> <p><code>    </code><code>],</code></p> <p><code>    </code><code>srcs: [</code></p> <p><code>        </code><code>":libsurfaceflinger_sources"</code><code>,</code></p> <p><code>    </code><code>],</code></p> <p><code>    </code><code>logtags: [</code><code>"EventLog/EventLogTags.logtags"</code><code>],</code></p> <p><code>    </code><code>include_dirs: [</code></p> <p><code>        </code><code>"frameworks/native/vulkan/vkjson"</code><code>,</code></p> <p><code>        </code><code>"frameworks/native/vulkan/include"</code><code>,</code></p> <p><code>        </code><code>"hardware/amlogic/gralloc/amlogic"</code><code>,</code></p> <p><code>        </code><code>"hardware/amlogic/hwcomposer/tvp"</code><code>,</code></p> <p><code>        </code><code>"hardware/amlogic/gralloc"</code><code>,</code></p> <p><code>    </code><code>],</code></p> <p><code>    </code><code>static_libs: [</code></p> <p><code>        </code><code>"libomxutils_static@2"</code><code>,</code></p> <p><code>        </code><code>"libamgralloc_ext_static@2"</code><code>,</code></p> <p><code>    </code><code>],</code></p> <p><code>    </code><code>cppflags: [</code></p> <p><code>        </code><code>"-fwhole-program-vtables"</code><code>, </code><code>// requires ThinLTO</code></p> <p><code>    </code><code>],</code></p> <p><code>    </code><code>lto: {<!-- --></code></p> <p><code>        </code><code>thin: </code><code>true</code><code>,</code></p> <p><code>    </code><code>},</code></p> <p><code>}...</code></p> </td></tr></tbody></table> 
<p>上面提到的createSurfaceFlinger()中会调用new SurfaceFlinger()，然后会执行到：onFirstRef()：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>void</code> <code>SurfaceFlinger::onFirstRef()</code></p> <p><code>{<!-- --></code></p> <p><code>    </code><code>mEventQueue.init(</code><code>this</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>onFirstRef() 中会创建 Handler 并初始化: /frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>//MessageQueue.cpp</code></p> <p><code>void</code> <code>MessageQueue::init(</code><code>const</code> <code>sp&lt;SurfaceFlinger&gt;&amp; flinger)</code></p> <p><code>{<!-- --></code></p> <p><code>    </code><code>mFlinger = flinger;</code></p> <p><code>    </code><code>mLooper = </code><code>new</code> <code>Looper(</code><code>true</code><code>);</code></p> <p><code>    </code><code>mHandler = </code><code>new</code> <code>Handler(*</code><code>this</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>然后会执行到 SurfaceFlinger::init()，该方法主要功能是：</p> 
<ul><li>初始化 EGL</li><li>创建 HWComposer</li><li>初始化非虚拟显示屏</li><li>启动 EventThread 线程</li><li>启动开机动画</li></ul> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> <p>70</p> <p>71</p> <p>72</p> <p>73</p> <p>74</p> <p>75</p> <p>76</p> <p>77</p> <p>78</p> <p>79</p> <p>80</p> <p>81</p> <p>82</p> <p>83</p> </td><td> <p><code>// Do not call property_set on main thread which will be blocked by init</code></p> <p><code>// Use StartPropertySetThread instead.</code></p> <p><code>void</code> <code>SurfaceFlinger::init() {<!-- --></code></p> <p><code>    </code><code>ALOGI(  </code><code>"SurfaceFlinger's main thread ready to run. "</code></p> <p><code>            </code><code>"Initializing graphics H/W..."</code><code>);</code></p> <p><code>    </code><code>Mutex::Autolock _l(mStateLock);</code></p> <p><code>    </code><code>// 对于CompositionEngine 属性进行设置， 创建RenderEngine对象</code></p> <p><code>    </code><code>// Get a RenderEngine for the given display / config (can't fail)</code></p> <p><code>    </code><code>// TODO(b/77156734): We need to stop casting and use HAL types when possible.</code></p> <p><code>    </code><code>// Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display.</code></p> <p><code>    </code><code>mCompositionEngine-&gt;setRenderEngine(renderengine::RenderEngine::create(</code></p> <p><code>            </code><code>renderengine::RenderEngineCreationArgs::Builder()</code></p> <p><code>                </code><code>.setPixelFormat(static_cast&lt;int32_t&gt;(defaultCompositionPixelFormat))</code></p> <p><code>                </code><code>.setImageCacheSize(maxFrameBufferAcquiredBuffers)</code></p> <p><code>                </code><code>.setUseColorManagerment(useColorManagement)</code></p> <p><code>                </code><code>.setEnableProtectedContext(enable_protected_contents(</code><code>false</code><code>))</code></p> <p><code>                </code><code>.setPrecacheToneMapperShaderOnly(</code><code>false</code><code>)</code></p> <p><code>                </code><code>.setSupportsBackgroundBlur(mSupportsBlur)</code></p> <p><code>                </code><code>.setContextPriority(useContextPriority</code></p> <p><code>                        </code><code>? renderengine::RenderEngine::ContextPriority::HIGH</code></p> <p><code>                        </code><code>: renderengine::RenderEngine::ContextPriority::MEDIUM)</code></p> <p><code>                </code><code>.build()));</code></p> <p><code>    </code><code>mCompositionEngine-&gt;setTimeStats(mTimeStats);</code></p> <p></p> <p><code>    </code><code>LOG_ALWAYS_FATAL_IF(mVrFlingerRequestsDisplay,</code></p> <p><code>            </code><code>"Starting with vr flinger active is not currently supported."</code><code>);　　</code><code>//创建HWComposer对象并传入一个name属性，再通过mCompositionEngine-&gt;setHwComposer设置对象属性。</code></p> <p><code>    </code><code>mCompositionEngine-&gt;setHwComposer(getFactory().createHWComposer(getBE().mHwcServiceName));</code></p> <p><code>    </code><code>mCompositionEngine-&gt;getHwComposer().setConfiguration(</code><code>this</code><code>, getBE().mComposerSequenceId);　　</code><code>//processDisplayHotplugEventsLocked(); 处理 任何初始热插拔和显示更改的结果　　//在此方法中主要有调用 initScheduler(displayId);</code></p> <p><code>    </code><code>// Process any initial hotplug and resulting display changes.</code></p> <p><code>    </code><code>processDisplayHotplugEventsLocked();</code></p> <p><code>    </code><code>const</code> <code>auto display = getDefaultDisplayDeviceLocked();</code></p> <p><code>    </code><code>LOG_ALWAYS_FATAL_IF(!display, </code><code>"Missing internal display after registering composer callback."</code><code>);</code></p> <p><code>    </code><code>LOG_ALWAYS_FATAL_IF(!getHwComposer().isConnected(*display-&gt;getId()),</code></p> <p><code>                        </code><code>"Internal display is disconnected."</code><code>);</code></p> <p></p> <p><code>    </code><code>if</code> <code>(useVrFlinger) {<!-- --></code></p> <p><code>        </code><code>auto vrFlingerRequestDisplayCallback = [</code><code>this</code><code>](bool requestDisplay) {<!-- --></code></p> <p><code>            </code><code>// This callback is called from the vr flinger dispatch thread. We</code></p> <p><code>            </code><code>// need to call signalTransaction(), which requires holding</code></p> <p><code>            </code><code>// mStateLock when we're not on the main thread. Acquiring</code></p> <p><code>            </code><code>// mStateLock from the vr flinger dispatch thread might trigger a</code></p> <p><code>            </code><code>// deadlock in surface flinger (see b/66916578), so post a message</code></p> <p><code>            </code><code>// to be handled on the main thread instead.</code></p> <p><code>            </code><code>static_cast&lt;</code><code>void</code><code>&gt;(schedule([=] {<!-- --></code></p> <p><code>                </code><code>ALOGI(</code><code>"VR request display mode: requestDisplay=%d"</code><code>, requestDisplay);</code></p> <p><code>                </code><code>mVrFlingerRequestsDisplay = requestDisplay;</code></p> <p><code>                </code><code>signalTransaction();</code></p> <p><code>            </code><code>}));</code></p> <p><code>        </code><code>};</code></p> <p><code>        </code><code>mVrFlinger = dvr::VrFlinger::Create(getHwComposer().getComposer(),</code></p> <p><code>                                            </code><code>getHwComposer()</code></p> <p><code>                                                    </code><code>.fromPhysicalDisplayId(*display-&gt;getId())</code></p> <p><code>                                                    </code><code>.value_or(</code><code>0</code><code>),</code></p> <p><code>                                            </code><code>vrFlingerRequestDisplayCallback);</code></p> <p><code>        </code><code>if</code> <code>(!mVrFlinger) {<!-- --></code></p> <p><code>            </code><code>ALOGE(</code><code>"Failed to start vrflinger"</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p></p> <p><code>    </code><code>// initialize our drawing state</code></p> <p><code>    </code><code>mDrawingState = mCurrentState;</code></p> <p></p> <p><code>    </code><code>// set initial conditions (e.g. unblank default device)</code></p> <p><code>    </code><code>initializeDisplays();</code></p> <p></p> <p><code>    </code><code>char</code> <code>primeShaderCache[PROPERTY_VALUE_MAX];</code></p> <p><code>    </code><code>property_get(</code><code>"service.sf.prime_shader_cache"</code><code>, primeShaderCache, </code><code>"1"</code><code>);</code></p> <p><code>    </code><code>if</code> <code>(atoi(primeShaderCache)) {<!-- --></code></p> <p><code>        </code><code>getRenderEngine().primeCache();</code></p> <p><code>    </code><code>}</code></p> <p></p> <p><code>    </code><code>// Inform native graphics APIs whether the present timestamp is supported:</code></p> <p></p> <p><code>    </code><code>const</code> <code>bool presentFenceReliable =</code></p> <p><code>            </code><code>!getHwComposer().hasCapability(hal::Capability::PRESENT_FENCE_IS_NOT_RELIABLE);</code></p> <p><code>    </code><code>mStartPropertySetThread = getFactory().createStartPropertySetThread(presentFenceReliable);</code></p> <p></p> <p><code>    </code><code>if</code> <code>(mStartPropertySetThread-&gt;Start() != NO_ERROR) {<!-- --></code></p> <p><code>        </code><code>ALOGE(</code><code>"Run StartPropertySetThread failed!"</code><code>);</code></p> <p><code>    </code><code>}</code></p> <p></p> <p><code>    </code><code>ALOGV(</code><code>"Done initializing"</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>首先看下如何创建 HWComposer：<code>frameworks/native/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp</code></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>//make_unique 相当于 new,(能够取代new 而且无需 delete pointer，有助于代码管理)。</code></p> <p><code>std::unique_ptr&lt;HWComposer&gt; DefaultFactory::createHWComposer(</code><code>const</code> <code>std::string&amp; serviceName) {<!-- --></code></p> <p><code>    </code><code>return</code> <code>std::make_unique&lt;android::impl::HWComposer&gt;(serviceName);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>对于CompositionEngine进行初始化:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>std::unique_ptr&lt;compositionengine::CompositionEngine&gt; DefaultFactory::createCompositionEngine() {<!-- --></code></p> <p><code>      </code><code>return</code> <code>compositionengine::impl::createCompositionEngine();</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>同样是通过make_unique创建了 CompositionEngine对象：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>std::unique_ptr&lt;compositionengine::CompositionEngine&gt; createCompositionEngine() {<!-- --></code></p> <p><code>     </code><code>return</code> <code>std::make_unique&lt;CompositionEngine&gt;();</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>再回到flinger-&gt;init()中processDisplayHotplugEventsLocked(); 处理任何初始热插拔和显示更改的结果，在此方法中主要有调用 initScheduler(displayId)：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> </td><td> <p><code>void</code> <code>SurfaceFlinger::initScheduler(DisplayId primaryDisplayId) {<!-- --></code></p> <p><code>    </code><code>if</code> <code>(mScheduler) {<!-- --></code></p> <p><code>        </code><code>// In practice it's not allowed to hotplug in/out the primary display once it's been</code></p> <p><code>        </code><code>// connected during startup, but some tests do it, so just warn and return.</code></p> <p><code>        </code><code>ALOGW(</code><code>"Can't re-init scheduler"</code><code>);</code></p> <p><code>        </code><code>return</code><code>;</code></p> <p><code>    </code><code>}</code></p> <p></p> <p><code>    </code><code>auto currentConfig = HwcConfigIndexType(getHwComposer().getActiveConfigIndex(primaryDisplayId));</code></p> <p><code>    </code><code>mRefreshRateConfigs =</code></p> <p><code>            </code><code>std::make_unique&lt;scheduler::RefreshRateConfigs&gt;(getHwComposer().getConfigs(</code></p> <p><code>                                                                    </code><code>primaryDisplayId),</code></p> <p><code>                                                            </code><code>currentConfig);</code></p> <p><code>    </code><code>mRefreshRateStats =</code></p> <p><code>            </code><code>std::make_unique&lt;scheduler::RefreshRateStats&gt;(*mRefreshRateConfigs, *mTimeStats,</code></p> <p><code>                                                          </code><code>currentConfig, hal::PowerMode::OFF);</code></p> <p><code>    </code><code>mRefreshRateStats-&gt;setConfigMode(currentConfig);</code></p> <p></p> <p><code>    </code><code>mPhaseConfiguration = getFactory().createPhaseConfiguration(*mRefreshRateConfigs);</code></p> <p><code>　　 </code><code>// 处创建Scheduler对象</code></p> <p><code>    </code><code>// start the EventThread</code></p> <p><code>    </code><code>mScheduler =</code></p> <p><code>            </code><code>getFactory().createScheduler([</code><code>this</code><code>](bool enabled) { setPrimaryVsyncEnabled(enabled); },</code></p> <p><code>                                         </code><code>*mRefreshRateConfigs, *</code><code>this</code><code>);</code></p> <p><code>    </code><code>//创建app链接 和 sf链接    mAppConnectionHandle =</code></p> <p><code>            </code><code>mScheduler-&gt;createConnection(</code><code>"app"</code><code>, mPhaseConfiguration-&gt;getCurrentOffsets().late.app,</code></p> <p><code>                                         </code><code>impl::EventThread::InterceptVSyncsCallback());</code></p> <p><code>    </code><code>mSfConnectionHandle =</code></p> <p><code>            </code><code>mScheduler-&gt;createConnection(</code><code>"sf"</code><code>, mPhaseConfiguration-&gt;getCurrentOffsets().late.sf,</code></p> <p><code>                                         </code><code>[</code><code>this</code><code>](nsecs_t timestamp) {<!-- --></code></p> <p><code>                                             </code><code>mInterceptor-&gt;saveVSyncEvent(timestamp);</code></p> <p><code>                                         </code><code>});</code></p> <p></p> <p><code>    </code><code>mEventQueue-&gt;setEventConnection(mScheduler-&gt;getEventConnection(mSfConnectionHandle));</code></p> <p><code>    </code><code>mVSyncModulator.emplace(*mScheduler, mAppConnectionHandle, mSfConnectionHandle,</code></p> <p><code>                            </code><code>mPhaseConfiguration-&gt;getCurrentOffsets());</code></p> <p></p> <p><code>    </code><code>mRegionSamplingThread =</code></p> <p><code>            </code><code>new</code> <code>RegionSamplingThread(*</code><code>this</code><code>, *mScheduler,</code></p> <p><code>                                     </code><code>RegionSamplingThread::EnvironmentTimingTunables());</code></p> <p><code>    </code><code>// Dispatch a config change request for the primary display on scheduler</code></p> <p><code>    </code><code>// initialization, so that the EventThreads always contain a reference to a</code></p> <p><code>    </code><code>// prior configuration.</code></p> <p><code>    </code><code>//</code></p> <p><code>    </code><code>// This is a bit hacky, but this avoids a back-pointer into the main SF</code></p> <p><code>    </code><code>// classes from EventThread, and there should be no run-time binder cost</code></p> <p><code>    </code><code>// anyway since there are no connected apps at this point.</code></p> <p><code>    </code><code>const</code> <code>nsecs_t vsyncPeriod =</code></p> <p><code>            </code><code>mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(currentConfig).getVsyncPeriod();</code></p> <p><code>    </code><code>mScheduler-&gt;onPrimaryDisplayConfigChanged(mAppConnectionHandle, primaryDisplayId.value,</code></p> <p><code>                                              </code><code>currentConfig, vsyncPeriod);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>详细看下app、sf的链接:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>Scheduler::ConnectionHandle Scheduler::createConnection(</code></p> <p><code>         </code><code>const</code> <code>char</code><code>* connectionName, nsecs_t phaseOffsetNs,</code></p> <p><code>         </code><code>impl::EventThread::InterceptVSyncsCallback interceptCallback) {<!-- --></code></p> <p><code>     </code><code>auto vsyncSource = makePrimaryDispSyncSource(connectionName, phaseOffsetNs);   </code></p> <p><code>     </code><code>auto eventThread = std::make_unique&lt;impl::EventThread&gt;(std::move(vsyncSource), std::move(interceptCallback));  </code></p> <p><code>     </code><code>return</code> <code>createConnection(std::move(eventThread));</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>可以看到创建了DispSyncSource对象，且构造方法传入了四个值，dispSync对象，phaseOffset偏移量，traceVsync为true，name就是 app或 sf</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>DispSyncSource::DispSyncSource(DispSync* dispSync, nsecs_t phaseOffset, bool traceVsync,</code></p> <p><code>                                 </code><code>const</code> <code>char</code><code>* name)</code></p> <p><code>        </code><code>: mName(name),</code></p> <p><code>          </code><code>mValue(base::StringPrintf(</code><code>"VSYNC-%s"</code><code>, name), </code><code>0</code><code>), </code><code>//对mValue进行了赋值，systrace上我们看到的 VSYNC-app VSYNC-sf 标签就是它</code></p> <p><code>          </code><code>mTraceVsync(traceVsync),  </code><code>//mTraceVsync为true,在onDispSyncEvent方法中</code></p> <p><code>          </code><code>mVsyncOnLabel(base::StringPrintf(</code><code>"VsyncOn-%s"</code><code>, name)),</code></p> <p><code>          </code><code>mDispSync(dispSync),</code></p> <p><code>          </code><code>mPhaseOffset(base::StringPrintf(</code><code>"VsyncOffset-%s"</code><code>, name), phaseOffset)   </code><code>//对mPhaseOffset进行初始化 vsync信号到来时候，sf、app的偏移量</code></p> </td></tr></tbody></table> 
<p>所以我们在systrace上面看到的 VSYNC-app/VSYNC-sf 驼峰 0 1变化，来源于这个。</p> 
<p></p> 
<p class="img-center"><img alt="" height="86" src="https://images2.imgbox.com/5b/58/CqtltMxD_o.jpg" width="538"></p> 
<p>创建EventThread对象，传入sf 或 app 相关联的vsyncSource对象:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>auto eventThread = std::make_unique&lt;impl::EventThread&gt;(std::move(vsyncSource),                                                           std::move(interceptCallback));</code></p> </td></tr></tbody></table> 
<p>说明：</p> 
<ul><li>1）每个ConnectionHandle 对象里有个 id，作为 Scheduler 对象中 mConnections 属性（map&lt;id, Connection&gt;）的键值，Connection 对象中又包含 ConnectionHandle、EventThreadConnection、EventThread 3个属性。</li><li>2）mScheduler-&gt;getEventConnection(mSfConnectionHandle) 中，以 mSfConnectionHandle 的 id 为键值，在 Scheduler 的 mConnections（unordered_map&lt;int64_t, Connection&gt;）中找到对应的Connection，并返回其 EventThreadConnection 成员属性。</li><li>3）getHwComposer().registerCallback() 中，依次调用 HwComposer、Device 的registerCallback() 方法，并在 Device 中 将 SurfaceFlinger 对象封装到 ComposerCallbackBridge 中；对于封装后的对象，依次调用 Composer、IComposerClient 的 registerCallback() 方法，注入到 IComposerClient 的实现类中。</li></ul> 
<p>相关问题：</p> 
<ul><li>① 屏幕刷新速率比系统帧速率快:</li></ul> 
<p>此时，在前缓冲区内容全部映射到屏幕上之后，后缓冲区尚未准备好下一帧，屏幕将无法读取下一帧，所以只能继续显示当前一帧的图形，造成一帧显示多次，也就是卡顿。</p> 
<ul><li>② 系统帧速率比屏幕刷新率快</li></ul> 
<p>此时，屏幕未完全把前缓冲区的一帧映射到屏幕，而系统已经在后缓冲区准备好了下一帧，并要求读取下一帧到屏幕，将会导致屏幕上半部分是上一帧的图形，而下半部分是下一帧的图形，造成屏幕上显示多帧，也就是屏幕撕裂。</p> 
<p>为了解决上述问题，Android显示系统一般会有多级缓冲，即在屏幕刷新的同时在另外一个buffer准备下一帧数据，以此提高性能：</p> 
<p></p> 
<p class="img-center"><img alt="" height="570" src="https://images2.imgbox.com/88/25/lv10H5fv_o.jpg" width="912"></p> 
<ul><li>前缓冲区：用来显示内容到屏幕的帧缓冲区</li><li>后缓冲区：用于后台合成下一帧图形的帧缓冲区</li><li>垂直同步（VSync）：当屏幕从缓冲区扫描完一帧到屏幕上之后，开始扫描下一帧之前，发出的一个同步信号，该信号用来切换前缓冲区和后缓冲区。</li><li>屏幕刷新率（HZ）：代表屏幕在一秒内刷新屏幕的次数，Android手机一般为60HZ（也就是1秒刷新60帧，大约16.67毫秒刷新1帧）</li><li>系统帧速率（FPS）：代表了系统在一秒内合成的帧数，该值的大小由系统算法和硬件决定。</li></ul> 
<p><a name="_lab2_1_2"></a></p> 
<h4 id="heading-4">3. 服务启动配置文件：/frameworks/native/services/surfaceflinger/surfaceflinger.rc</h4> 
<p>上面发现服务配置文件也在Android.mk中被加载：LOCAL_INIT_RC := surfaceflinger.rc</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>service surfaceflinger /system/bin/surfaceflinger</code></p> <p><code>    </code><code>class</code> <code>core animation</code></p> <p><code>    </code><code>user system</code></p> <p><code>    </code><code>group graphics drmrpc readproc</code></p> <p><code>    </code><code>onrestart restart zygote</code></p> <p><code>    </code><code>writepid /dev/stune/foreground/tasks</code></p> <p><code>    </code><code>socket pdx/system/vr/display/client     stream </code><code>0666</code> <code>system graphics u:object_r:pdx_display_client_endpoint_socket:s0</code></p> <p><code>    </code><code>socket pdx/system/vr/display/manager    stream </code><code>0666</code> <code>system graphics u:object_r:pdx_display_manager_endpoint_socket:s0</code></p> <p><code>    </code><code>socket pdx/system/vr/display/vsync      stream </code><code>0666</code> <code>system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0</code></p> </td></tr></tbody></table> 
<p><a name="_lab2_1_3"></a></p> 
<h4 id="heading-5">4. Surface 创建过程</h4> 
<p></p> 
<p class="img-center"><img alt="" height="465" src="https://images2.imgbox.com/a1/56/SFILjjVN_o.jpg" width="1060"></p> 
<p>Surface 创建的过程就是 Activity 显示的过程，在 ActivityThread.handleResumeActivity() 中调用了 Activity.makeVisible()具体实现：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>void</code> <code>makeVisible() {<!-- --></code></p> <p><code>    </code><code>if</code> <code>(!mWindowAdded) {<!-- --></code></p> <p><code>        </code><code>ViewManager wm = getWindowManager();</code><code>//此处 getWindowManager 获取的是 WindowManagerImpl 对象</code></p> <p><code>        </code><code>wm.addView(mDecor, getWindow().getAttributes());</code></p> <p><code>        </code><code>mWindowAdded = </code><code>true</code><code>;</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>mDecor.setVisibility(View.VISIBLE);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>WindowManagerImpl.java：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>public</code> <code>void</code> <code>addView(</code><code>@NonNull</code> <code>View view, </code><code>@NonNull</code> <code>ViewGroup.LayoutParams params) {<!-- --></code></p> <p><code>    </code><code>applyDefaultToken(params);</code></p> <p><code>    </code><code>mGlobal.addView(view, params, mDisplay, mParentWindow);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>WindowManagerGlobal.java：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> </td><td> <p><code>public</code> <code>void</code> <code>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {<!-- --></code></p> <p><code>    </code><code>...</code></p> <p><code>    </code><code>final</code> <code>WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</code></p> <p><code>    </code><code>//创建 ViewRootImpl</code></p> <p><code>    </code><code>ViewRootImpl root = </code><code>new</code> <code>ViewRootImpl(view.getContext(), display);</code></p> <p><code>    </code><code>view.setLayoutParams(wparams);</code></p> <p><code>    </code><code>mViews.add(view);</code></p> <p><code>    </code><code>mRoots.add(root);</code></p> <p><code>    </code><code>mParams.add(wparams);</code></p> <p><code>    </code><code>//设置 View</code></p> <p><code>    </code><code>root.setView(view, wparams, panelParentView);</code></p> <p><code>    </code><code>...</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>创建 ViewRootImpl：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> </td><td> <p><code>public</code> <code>ViewRootImpl(Context context, Display display) {<!-- --></code></p> <p><code>   </code><code>//获取 IWindowSession的代理类</code></p> <p><code>    </code><code>this</code><code>(context, display, WindowManagerGlobal.getWindowSession(),</code></p> <p><code>            </code><code>false</code> <code>/* useSfChoreographer */</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>WindowManagerGlobal.java：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> </td><td> <p><code>@UnsupportedAppUsage</code></p> <p><code>    </code><code>public</code> <code>static</code> <code>IWindowSession getWindowSession() {<!-- --></code></p> <p><code>        </code><code>synchronized</code> <code>(WindowManagerGlobal.</code><code>class</code><code>) {<!-- --></code></p> <p><code>            </code><code>if</code> <code>(sWindowSession == </code><code>null</code><code>) {<!-- --></code></p> <p><code>                </code><code>try</code> <code>{<!-- --></code></p> <p><code>                    </code><code>// Emulate the legacy behavior.  The global instance of InputMethodManager</code></p> <p><code>                    </code><code>// was instantiated here.</code></p> <p><code>                    </code><code>// TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage</code></p> <p><code>                    </code><code>//获取 IMS 的代理类</code></p> <p><code>                    </code><code>InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();</code></p> <p><code>                    </code><code>IWindowManager windowManager = getWindowManagerService();</code></p> <p><code>                    </code><code>//经过 Binder 调用，最终调用 WMS</code></p> <p><code>                    </code><code>sWindowSession = windowManager.openSession(</code></p> <p><code>                            </code><code>new</code> <code>IWindowSessionCallback.Stub() {<!-- --></code></p> <p><code>                                </code><code>@Override</code></p> <p><code>                                </code><code>public</code> <code>void</code> <code>onAnimatorScaleChanged(</code><code>float</code> <code>scale) {<!-- --></code></p> <p><code>                                    </code><code>ValueAnimator.setDurationScale(scale);</code></p> <p><code>                                </code><code>}</code></p> <p><code>                            </code><code>});</code></p> <p><code>                </code><code>} </code><code>catch</code> <code>(RemoteException e) {<!-- --></code></p> <p><code>                    </code><code>throw</code> <code>e.rethrowFromSystemServer();</code></p> <p><code>                </code><code>}</code></p> <p><code>            </code><code>}</code></p> <p><code>            </code><code>return</code> <code>sWindowSession;</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<p>WindowManagerService.openSession：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>// -------------------------------------------------------------</code></p> <p><code>    </code><code>// IWindowManager API</code></p> <p><code>    </code><code>// -------------------------------------------------------------</code></p> <p></p> <p><code>    </code><code>@Override</code></p> <p><code>    </code><code>public</code> <code>IWindowSession openSession(IWindowSessionCallback callback) {<!-- --></code></p> <p><code>        </code><code>//创建session对象</code></p> <p><code>        </code><code>return</code> <code>new</code> <code>Session(</code><code>this</code><code>, callback);</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<p>再次经过 Binder 将数据写回 app 进程，则获取的便是 Session 的代理对象 IWindowSession。</p> 
<p>创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法:</p> 
<p>ViewRootImpl：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> </td><td> <p><code>public</code> <code>void</code> <code>setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {<!-- --></code></p> <p><code>  </code><code>synchronized</code> <code>(</code><code>this</code><code>) {<!-- --></code></p> <p><code> </code> </p> <p><code>    </code><code>requestLayout(); </code><code>//详见下面分析</code></p> <p><code>    </code><code>...</code></p> <p><code>    </code><code>//通过 Binder调用，进入 system 进程的 Session</code></p> <p><code> </code><code>　　　　res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,                            　　　　　　　　getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,                            　　　　　　　　mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                            　　　　　　　　mAttachInfo.mDisplayCutout, inputChannel,                            　　　　　　　　mTempInsets, mTempControls);</code></p> <p><code>    </code><code>...</code></p> <p><code>  </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Session.java</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> </td><td> <p><code>@Override</code></p> <p><code>    </code><code>public</code> <code>int</code> <code>addToDisplayAsUser(IWindow window, </code><code>int</code> <code>seq, WindowManager.LayoutParams attrs,</code></p> <p><code>            </code><code>int</code> <code>viewVisibility, </code><code>int</code> <code>displayId, </code><code>int</code> <code>userId, Rect outFrame,</code></p> <p><code>            </code><code>Rect outContentInsets, Rect outStableInsets,</code></p> <p><code>            </code><code>DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</code></p> <p><code>            </code><code>InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) {<!-- --></code></p> <p><code>        </code><code>//调用WMS的addWindow方法    </code></p> <p><code>        </code><code>return</code> <code>mService.addWindow(</code><code>this</code><code>, window, seq, attrs, viewVisibility, displayId, outFrame,</code></p> <p><code>                </code><code>outContentInsets, outStableInsets, outDisplayCutout, outInputChannel,</code></p> <p><code>                </code><code>outInsetsState, outActiveControls, userId);</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<p>WindowManagerService.java：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> <p>70</p> <p>71</p> <p>72</p> <p>73</p> <p>74</p> <p>75</p> <p>76</p> <p>77</p> <p>78</p> <p>79</p> <p>80</p> <p>81</p> <p>82</p> <p>83</p> </td><td> <p><code>public</code> <code>int</code> <code>addWindow(Session session, IWindow client, </code><code>int</code> <code>seq,</code></p> <p><code>            </code><code>LayoutParams attrs, </code><code>int</code> <code>viewVisibility, </code><code>int</code> <code>displayId, Rect outFrame,</code></p> <p><code>            </code><code>Rect outContentInsets, Rect outStableInsets,</code></p> <p><code>            </code><code>DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</code></p> <p><code>            </code><code>InsetsState outInsetsState, InsetsSourceControl[] outActiveControls,</code></p> <p><code>            </code><code>int</code> <code>requestUserId) {<!-- --></code></p> <p><code>        </code><code>Arrays.fill(outActiveControls, </code><code>null</code><code>);</code></p> <p><code>        </code><code>int</code><code>[] appOp = </code><code>new</code> <code>int</code><code>[</code><code>1</code><code>];</code></p> <p><code>        </code><code>final</code> <code>boolean</code> <code>isRoundedCornerOverlay = (attrs.privateFlags</code></p> <p><code>                </code><code>&amp; PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY) != </code><code>0</code><code>;</code></p> <p><code>        </code><code>int</code> <code>res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,</code></p> <p><code>                </code><code>appOp);</code></p> <p><code>        </code><code>if</code> <code>(res != WindowManagerGlobal.ADD_OKAY) {<!-- --></code></p> <p><code>            </code><code>return</code> <code>res;</code></p> <p><code>        </code><code>}</code></p> <p></p> <p><code>        </code><code>WindowState parentWindow = </code><code>null</code><code>;</code></p> <p><code>        </code><code>final</code> <code>int</code> <code>callingUid = Binder.getCallingUid();</code></p> <p><code>        </code><code>final</code> <code>int</code> <code>callingPid = Binder.getCallingPid();</code></p> <p><code>        </code><code>final</code> <code>long</code> <code>origId = Binder.clearCallingIdentity();</code></p> <p><code>        </code><code>final</code> <code>int</code> <code>type = attrs.type;</code></p> <p></p> <p><code>        </code><code>synchronized</code> <code>(mGlobalLock) {<!-- --></code></p> <p><code>            </code><code>if</code> <code>(!mDisplayReady) {<!-- --></code></p> <p><code>                </code><code>throw</code> <code>new</code> <code>IllegalStateException(</code><code>"Display has not been initialialized"</code><code>);</code></p> <p><code>            </code><code>}</code></p> <p><code>...</code></p> <p><code>            </code><code>//创建 WindowState</code></p> <p><code>            </code><code>final</code> <code>WindowState win = </code><code>new</code> <code>WindowState(</code><code>this</code><code>, session, client, token, parentWindow,</code></p> <p><code>                    </code><code>appOp[</code><code>0</code><code>], seq, attrs, viewVisibility, session.mUid, userId,</code></p> <p><code>                    </code><code>session.mCanAddInternalSystemWindow);</code></p> <p><code>            </code><code>if</code> <code>(win.mDeathRecipient == </code><code>null</code><code>) {<!-- --></code></p> <p><code>                </code><code>// Client has apparently died, so there is no reason to</code></p> <p><code>                </code><code>// continue.</code></p> <p><code>                </code><code>ProtoLog.w(WM_ERROR, </code><code>"Adding window client %s"</code></p> <p><code>                        </code><code>+ </code><code>" that is dead, aborting."</code><code>, client.asBinder());</code></p> <p><code>                </code><code>return</code> <code>WindowManagerGlobal.ADD_APP_EXITING;</code></p> <p><code>            </code><code>}</code></p> <p></p> <p><code>            </code><code>if</code> <code>(win.getDisplayContent() == </code><code>null</code><code>) {<!-- --></code></p> <p><code>                </code><code>ProtoLog.w(WM_ERROR, </code><code>"Adding window to Display that has been removed."</code><code>);</code></p> <p><code>                </code><code>return</code> <code>WindowManagerGlobal.ADD_INVALID_DISPLAY;</code></p> <p><code>            </code><code>}</code></p> <p></p> <p><code>            </code><code>// 调整 WindowManager的LayoutParams 参数</code></p> <p><code>            </code><code>final</code> <code>DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();</code></p> <p><code>            </code><code>displayPolicy.adjustWindowParamsLw(win, win.mAttrs, callingPid, callingUid);</code></p> <p></p> <p><code>            </code><code>res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</code></p> <p><code>            </code><code>if</code> <code>(res != WindowManagerGlobal.ADD_OKAY) {<!-- --></code></p> <p><code>                </code><code>return</code> <code>res;</code></p> <p><code>            </code><code>}</code></p> <p></p> <p><code>            </code><code>// 打开输入通道</code></p> <p><code>            </code><code>final</code> <code>boolean</code> <code>openInputChannels = (outInputChannel != </code><code>null</code></p> <p><code>                    </code><code>&amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == </code><code>0</code><code>);</code></p> <p><code>            </code><code>if</code>  <code>(openInputChannels) {<!-- --></code></p> <p><code>                </code><code>win.openInputChannel(outInputChannel);</code></p> <p><code>            </code><code>}</code></p> <p></p> <p><code>...</code></p> <p><code>            </code><code>displayContent.getInputMonitor().setUpdateInputWindowsNeededLw();</code></p> <p></p> <p><code>            </code><code>boolean</code> <code>focusChanged = </code><code>false</code><code>;</code></p> <p><code>            </code><code>//当该窗口能接收按键事件，则更新聚焦窗口</code></p> <p><code>            </code><code>if</code> <code>(win.canReceiveKeys()) {<!-- --></code></p> <p><code>                </code><code>focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</code></p> <p><code>                        </code><code>false</code> <code>/*updateInputWindows*/</code><code>);</code></p> <p><code>                </code><code>if</code> <code>(focusChanged) {<!-- --></code></p> <p><code>                    </code><code>imMayMove = </code><code>false</code><code>;</code></p> <p><code>                </code><code>}</code></p> <p><code>            </code><code>}</code></p> <p></p> <p><code>            </code><code>if</code> <code>(imMayMove) {<!-- --></code></p> <p><code>                </code><code>displayContent.computeImeTarget(</code><code>true</code> <code>/* updateImeTarget */</code><code>);</code></p> <p><code>            </code><code>}</code></p> <p><code>...</code></p> <p><code>        </code><code>}</code></p> <p></p> <p><code>        </code><code>Binder.restoreCallingIdentity(origId);</code></p> <p></p> <p><code>        </code><code>return</code> <code>res;</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<p>创建 SurfaceSession 对象，并将当前 Session 添加到 WMS.mSessions 成员变量。</p> 
<p>Session.java：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> </td><td> <p><code>void</code> <code>windowAddedLocked(String packageName) {<!-- --></code></p> <p><code>        </code><code>mPackageName = packageName;</code></p> <p><code>        </code><code>mRelayoutTag = </code><code>"relayoutWindow: "</code> <code>+ mPackageName;</code></p> <p><code>        </code><code>if</code> <code>(mSurfaceSession == </code><code>null</code><code>) {<!-- --></code></p> <p><code>            </code><code>if</code> <code>(DEBUG) {<!-- --></code></p> <p><code>                </code><code>Slog.v(TAG_WM, </code><code>"First window added to "</code> <code>+ </code><code>this</code> <code>+ </code><code>", creating SurfaceSession"</code><code>);</code></p> <p><code>            </code><code>}</code></p> <p><code>            </code><code>mSurfaceSession = </code><code>new</code> <code>SurfaceSession();</code></p> <p><code>            </code><code>ProtoLog.i(WM_SHOW_TRANSACTIONS, </code><code>"  NEW SURFACE SESSION %s"</code><code>, mSurfaceSession);</code></p> <p><code>            </code><code>mService.mSessions.add(</code><code>this</code><code>);</code></p> <p><code>            </code><code>if</code> <code>(mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) {<!-- --></code></p> <p><code>                </code><code>mService.dispatchNewAnimatorScaleLocked(</code><code>this</code><code>);</code></p> <p><code>            </code><code>}</code></p> <p><code>        </code><code>}</code></p> <p><code>        </code><code>mNumWindow++;</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<p>SurfaceSession 的创建会调用 JNI，在 JNI 调用 nativeCreate()。</p> 
<p>android_view_SurfaceSession.cpp：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> </td><td> <p><code>static</code> <code>jlong nativeCreate(JNIEnv* env, jclass clazz) {<!-- --></code></p> <p><code>    </code><code>SurfaceComposerClient* client = </code><code>new</code> <code>SurfaceComposerClient();</code></p> <p><code>    </code><code>client-&gt;incStrong((</code><code>void</code><code>*)nativeCreate);</code></p> <p><code>    </code><code>return</code> <code>reinterpret_cast&lt;jlong&gt;(client);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> </td><td> <p><code>static</code> <code>jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,</code></p> <p><code>        </code><code>jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</code></p> <p><code>        </code><code>jobject metadataParcel) {<!-- --></code></p> <p><code>    </code><code>ScopedUtfChars name(env, nameStr);</code></p> <p><code>    </code><code>sp&lt;SurfaceComposerClient&gt; client;</code></p> <p><code>    </code><code>if</code> <code>(sessionObj != NULL) {<!-- --></code></p> <p><code>        </code><code>client = android_view_SurfaceSession_getClient(env, sessionObj);</code></p> <p><code>    </code><code>} </code><code>else</code> <code>{<!-- --></code></p> <p><code>        </code><code>client = SurfaceComposerClient::getDefault();</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>SurfaceControl *parent = reinterpret_cast&lt;SurfaceControl*&gt;(parentObject);</code></p> <p><code>    </code><code>sp&lt;SurfaceControl&gt; surface;</code></p> <p><code>    </code><code>LayerMetadata metadata;</code></p> <p><code>    </code><code>Parcel* parcel = parcelForJavaObject(env, metadataParcel);</code></p> <p><code>    </code><code>if</code> <code>(parcel &amp;&amp; !parcel-&gt;objectsCount()) {<!-- --></code></p> <p><code>        </code><code>status_t err = metadata.readFromParcel(parcel);</code></p> <p><code>        </code><code>if</code> <code>(err != NO_ERROR) {<!-- --></code></p> <p><code>          </code><code>jniThrowException(env, </code><code>"java/lang/IllegalArgumentException"</code><code>,</code></p> <p><code>                            </code><code>"Metadata parcel has wrong format"</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p></p> <p><code>    </code><code>status_t err = client-&gt;createSurfaceChecked(</code></p> <p><code>            </code><code>String8(name.c_str()), w, h, format, &amp;surface, flags, parent, std::move(metadata));</code></p> <p><code>    </code><code>if</code> <code>(err == NAME_NOT_FOUND) {<!-- --></code></p> <p><code>        </code><code>jniThrowException(env, </code><code>"java/lang/IllegalArgumentException"</code><code>, NULL);</code></p> <p><code>        </code><code>return</code> <code>0</code><code>;</code></p> <p><code>    </code><code>} </code><code>else</code> <code>if</code> <code>(err != NO_ERROR) {<!-- --></code></p> <p><code>        </code><code>jniThrowException(env, OutOfResourcesException, NULL);</code></p> <p><code>        </code><code>return</code> <code>0</code><code>;</code></p> <p><code>    </code><code>}</code></p> <p></p> <p><code>    </code><code>surface-&gt;incStrong((</code><code>void</code> <code>*)nativeCreate);</code></p> <p><code>    </code><code>return</code> <code>reinterpret_cast&lt;jlong&gt;(surface.get());</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>通过以上JNI接口获取SurfaceComposerClient 对象，作为跟 SurfaceFlinger 通信的代理对象。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> </td><td> <p><code>void</code> <code>SurfaceComposerClient::onFirstRef() {<!-- --></code></p> <p><code>    </code><code>//getComposerService() 将返回 SF 的 Binder 代理端的 BpSurfaceFlinger 对象</code></p> <p><code>    </code><code>sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());</code></p> <p><code>    </code><code>if</code> <code>(sf != nullptr &amp;&amp; mStatus == NO_INIT) {<!-- --></code></p> <p><code>        </code><code>sp&lt;ISurfaceComposerClient&gt; conn;</code></p> <p><code>        </code><code>//调用 SF 的 createConnection()</code></p> <p><code>        </code><code>conn = sf-&gt;createConnection();</code></p> <p><code>        </code><code>if</code> <code>(conn != nullptr) {<!-- --></code></p> <p><code>            </code><code>mClient = conn;</code></p> <p><code>            </code><code>mStatus = NO_ERROR;</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>比如截屏接口就会通过SurfaceControl调用到其中的capture 接口：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> </td><td> <p><code>status_t ScreenshotClient::capture(</code><code>const</code> <code>sp&lt;IBinder&gt;&amp; display, ui::Dataspace reqDataSpace,</code></p> <p><code>                                   </code><code>ui::PixelFormat reqPixelFormat, </code><code>const</code> <code>Rect&amp; sourceCrop,</code></p> <p><code>                                   </code><code>uint32_t reqWidth, uint32_t reqHeight, bool useIdentityTransform,</code></p> <p><code>                                   </code><code>ui::Rotation rotation, bool captureSecureLayers,</code></p> <p><code>                                   </code><code>sp&lt;GraphicBuffer&gt;* outBuffer, bool&amp; outCapturedSecureLayers) {<!-- --></code></p> <p><code>    </code><code>sp&lt;ISurfaceComposer&gt; s(ComposerService::getComposerService());</code></p> <p><code>    </code><code>if</code> <code>(s == nullptr) </code><code>return</code> <code>NO_INIT;</code></p> <p><code>    </code><code>status_t ret = s-&gt;captureScreen(display, outBuffer, outCapturedSecureLayers, reqDataSpace,</code></p> <p><code>                                    </code><code>reqPixelFormat, sourceCrop, reqWidth, reqHeight,</code></p> <p><code>                                    </code><code>useIdentityTransform, rotation, captureSecureLayers);</code></p> <p><code>    </code><code>if</code> <code>(ret != NO_ERROR) {<!-- --></code></p> <p><code>        </code><code>return</code> <code>ret;</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>return</code> <code>ret;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>然后具体看下核心的SurfaceFlinger实现：</p> 
<p>SurfaceFlinger.cpp：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> </td><td> <p><code>sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection() {<!-- --></code></p> <p><code>    </code><code>//创建一个Client</code></p> <p><code>    </code><code>const</code> <code>sp&lt;Client&gt; client = </code><code>new</code> <code>Client(</code><code>this</code><code>);</code></p> <p><code>    </code><code>return</code> <code>client-&gt;initCheck() == NO_ERROR ? client : nullptr;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>回到之前，创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法。在 setView() 中调用了 requestLayout() 方法，现在具体来看下这个方法调用流程：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Override</code></p> <p><code>    </code><code>public</code> <code>void</code> <code>requestLayout() {<!-- --></code></p> <p><code>        </code><code>if</code> <code>(!mHandlingLayoutInLayoutRequest) {<!-- --></code></p> <p><code>            </code><code>checkThread();</code></p> <p><code>            </code><code>mLayoutRequested = </code><code>true</code><code>;</code></p> <p><code>            </code><code>scheduleTraversals();</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> </td><td> <p><code>@UnsupportedAppUsage</code></p> <p><code>    </code><code>void</code> <code>scheduleTraversals() {<!-- --></code></p> <p><code>        </code><code>if</code> <code>(!mTraversalScheduled) {<!-- --></code></p> <p><code>            </code><code>mTraversalScheduled = </code><code>true</code><code>;</code></p> <p><code>            </code><code>mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();　　　　　　　</code><code>//启动TraversalRunnable</code></p> <p><code>            </code><code>mChoreographer.postCallback(</code></p> <p><code>                    </code><code>Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, </code><code>null</code><code>);</code></p> <p><code>            </code><code>notifyRendererOfFramePending();</code></p> <p><code>            </code><code>pokeDrawLockIfNeeded();</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>final</code> <code>class</code> <code>TraversalRunnable </code><code>implements</code> <code>Runnable {<!-- --></code></p> <p><code>    </code><code>@Override</code></p> <p><code>    </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>        </code><code>doTraversal();</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> </td><td> <p><code>void</code> <code>doTraversal() {<!-- --></code></p> <p><code>        </code><code>if</code> <code>(mTraversalScheduled) {<!-- --></code></p> <p><code>            </code><code>mTraversalScheduled = </code><code>false</code><code>;</code></p> <p><code>            </code><code>mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</code></p> <p></p> <p><code>            </code><code>if</code> <code>(mProfile) {<!-- --></code></p> <p><code>                </code><code>Debug.startMethodTracing(</code><code>"ViewAncestor"</code><code>);</code></p> <p><code>            </code><code>}</code></p> <p><code>  </code><code>　　　　　　</code><code>//调用performTraversals             performTraversals();</code></p> <p><code>if</code> <code>(mProfile) {<!-- --></code></p> <p><code>                </code><code>Debug.stopMethodTracing();</code></p> <p><code>                </code><code>mProfile = </code><code>false</code><code>;</code></p> <p><code>            </code><code>}</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> <p>70</p> <p>71</p> <p>72</p> <p>73</p> <p>74</p> <p>75</p> <p>76</p> <p>77</p> <p>78</p> <p>79</p> <p>80</p> <p>81</p> <p>82</p> <p>83</p> <p>84</p> <p>85</p> <p>86</p> <p>87</p> <p>88</p> <p>89</p> <p>90</p> <p>91</p> <p>92</p> <p>93</p> </td><td> <p><code>private</code> <code>void</code> <code>performTraversals() {<!-- --></code></p> <p><code>        </code><code>// cache mView since it is used so much below...</code></p> <p><code>        </code><code>final</code> <code>View host = mView; </code><code>//它就是 DecorView</code></p> <p><code>...</code></p> <p><code>        </code><code>if</code> <code>(mFirst || windowShouldResize || viewVisibilityChanged || cutoutChanged || params != </code><code>null</code></p> <p><code>                </code><code>|| mForceNextWindowRelayout) {<!-- --></code></p> <p><code>            </code><code>mForceNextWindowRelayout = </code><code>false</code><code>;</code></p> <p></p> <p><code>            </code><code>if</code> <code>(isViewVisible) {<!-- --></code></p> <p><code>                </code><code>// If this window is giving internal insets to the window</code></p> <p><code>                </code><code>// manager, and it is being added or changing its visibility,</code></p> <p><code>                </code><code>// then we want to first give the window manager "fake"</code></p> <p><code>                </code><code>// insets to cause it to effectively ignore the content of</code></p> <p><code>                </code><code>// the window during layout.  This avoids it briefly causing</code></p> <p><code>                </code><code>// other windows to resize/move based on the raw frame of the</code></p> <p><code>                </code><code>// window, waiting until we can finish laying out this window</code></p> <p><code>                </code><code>// and get back to the window manager with the ultimately</code></p> <p><code>                </code><code>// computed insets.</code></p> <p><code>                </code><code>insetsPending = computesInternalInsets &amp;&amp; (mFirst || viewVisibilityChanged);</code></p> <p><code>            </code><code>}</code></p> <p><code>...</code></p> <p><code>            </code><code>try</code> <code>{<!-- --></code></p> <p><code>                </code><code>if</code> <code>(DEBUG_LAYOUT) {<!-- --></code></p> <p><code>                    </code><code>Log.i(mTag, </code><code>"host=w:"</code> <code>+ host.getMeasuredWidth() + </code><code>", h:"</code> <code>+</code></p> <p><code>                            </code><code>host.getMeasuredHeight() + </code><code>", params="</code> <code>+ params);</code></p> <p><code>                </code><code>}</code></p> <p></p> <p><code>                </code><code>if</code> <code>(mAttachInfo.mThreadedRenderer != </code><code>null</code><code>) {<!-- --></code></p> <p><code>                    </code><code>// relayoutWindow may decide to destroy mSurface. As that decision</code></p> <p><code>                    </code><code>// happens in WindowManager service, we need to be defensive here</code></p> <p><code>                    </code><code>// and stop using the surface in case it gets destroyed.</code></p> <p><code>                    </code><code>if</code> <code>(mAttachInfo.mThreadedRenderer.pause()) {<!-- --></code></p> <p><code>                        </code><code>// Animations were running so we need to push a frame</code></p> <p><code>                        </code><code>// to resume them</code></p> <p><code>                        </code><code>mDirty.set(</code><code>0</code><code>, </code><code>0</code><code>, mWidth, mHeight);</code></p> <p><code>                    </code><code>}</code></p> <p><code>                    </code><code>mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);</code></p> <p><code>                </code><code>}</code></p> <p><code>                </code><code>// 关键函数relayoutWindow</code></p> <p><code>                </code><code>relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</code></p> <p></p> <p><code>                </code><code>if</code> <code>(DEBUG_LAYOUT) Log.v(mTag, </code><code>"relayout: frame="</code> <code>+ frame.toShortString()</code></p> <p><code>                        </code><code>+ </code><code>" cutout="</code> <code>+ mPendingDisplayCutout.get().toString()</code></p> <p><code>                        </code><code>+ </code><code>" surface="</code> <code>+ mSurface);</code></p> <p></p> <p><code>                </code><code>// If the pending {@link MergedConfiguration} handed back from</code></p> <p><code>                </code><code>// {@link #relayoutWindow} does not match the one last reported,</code></p> <p><code>                </code><code>// WindowManagerService has reported back a frame from a configuration not yet</code></p> <p><code>                </code><code>// handled by the client. In this case, we need to accept the configuration so we</code></p> <p><code>                </code><code>// do not lay out and draw with the wrong configuration.</code></p> <p><code>                </code><code>if</code> <code>(!mPendingMergedConfiguration.equals(mLastReportedMergedConfiguration)) {<!-- --></code></p> <p><code>                    </code><code>if</code> <code>(DEBUG_CONFIGURATION) Log.v(mTag, </code><code>"Visible with new config: "</code></p> <p><code>                            </code><code>+ mPendingMergedConfiguration.getMergedConfiguration());</code></p> <p><code>                    </code><code>performConfigurationChange(mPendingMergedConfiguration, !mFirst,</code></p> <p><code>                            </code><code>INVALID_DISPLAY </code><code>/* same display */</code><code>);</code></p> <p><code>                    </code><code>updatedConfiguration = </code><code>true</code><code>;</code></p> <p><code>                </code><code>}</code></p> <p></p> <p><code>            </code><code>} </code><code>catch</code> <code>(RemoteException e) {<!-- --></code></p> <p><code>            </code><code>}</code></p> <p><code>...</code></p> <p><code>        </code><code>}</code></p> <p></p> <p><code>        </code><code>boolean</code> <code>cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</code></p> <p></p> <p><code>        </code><code>if</code> <code>(!cancelDraw) {<!-- --></code></p> <p><code>            </code><code>if</code> <code>(mPendingTransitions != </code><code>null</code> <code>&amp;&amp; mPendingTransitions.size() &gt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                </code><code>for</code> <code>(</code><code>int</code> <code>i = </code><code>0</code><code>; i &lt; mPendingTransitions.size(); ++i) {<!-- --></code></p> <p><code>                    </code><code>mPendingTransitions.get(i).startChangingAnimations();</code></p> <p><code>                </code><code>}</code></p> <p><code>                </code><code>mPendingTransitions.clear();</code></p> <p><code>            </code><code>}</code></p> <p></p> <p><code>            </code><code>//开始绘制，其中调用了draw(fullRedrawNeeded);</code></p> <p><code>            </code><code>performDraw();</code></p> <p><code>        </code><code>} </code><code>else</code> <code>{<!-- --></code></p> <p><code>            </code><code>if</code> <code>(isViewVisible) {<!-- --></code></p> <p><code>                </code><code>// Try again</code></p> <p><code>                </code><code>scheduleTraversals();</code></p> <p><code>            </code><code>} </code><code>else</code> <code>if</code> <code>(mPendingTransitions != </code><code>null</code> <code>&amp;&amp; mPendingTransitions.size() &gt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                </code><code>for</code> <code>(</code><code>int</code> <code>i = </code><code>0</code><code>; i &lt; mPendingTransitions.size(); ++i) {<!-- --></code></p> <p><code>                    </code><code>mPendingTransitions.get(i).endChangingAnimations();</code></p> <p><code>                </code><code>}</code></p> <p><code>                </code><code>mPendingTransitions.clear();</code></p> <p><code>            </code><code>}</code></p> <p><code>        </code><code>}</code></p> <p></p> <p><code>        </code><code>if</code> <code>(mAttachInfo.mContentCaptureEvents != </code><code>null</code><code>) {<!-- --></code></p> <p><code>            </code><code>notifyContentCatpureEvents();</code></p> <p><code>        </code><code>}</code></p> <p></p> <p><code>        </code><code>mIsInTraversal = </code><code>false</code><code>;</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<p>再看下relayoutWindow的实现：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> </td><td> <p><code>...        </code><code>if</code> <code>(mSurfaceControl.isValid()) {<!-- --></code></p> <p><code>            </code><code>if</code> <code>(!useBLAST()) {<!-- --></code></p> <p><code>                </code><code>//先创建一个本地Surface,然后调用copyFrom   将SurfaceControl信息拷贝到Surface中</code></p> <p><code>                </code><code>mSurface.copyFrom(mSurfaceControl);</code></p> <p><code>            </code><code>} </code><code>else</code> <code>{<!-- --></code></p> <p><code>                </code><code>final</code> <code>Surface blastSurface = getOrCreateBLASTSurface(mSurfaceSize.x,</code></p> <p><code>                    </code><code>mSurfaceSize.y);</code></p> <p><code>                </code><code>// If blastSurface == null that means it hasn't changed since the last time we</code></p> <p><code>                </code><code>// called. In this situation, avoid calling transferFrom as we would then</code></p> <p><code>                </code><code>// inc the generation ID and cause EGL resources to be recreated.</code></p> <p><code>                </code><code>if</code> <code>(blastSurface != </code><code>null</code><code>) {<!-- --></code></p> <p><code>                    </code><code>mSurface.transferFrom(blastSurface);</code></p> <p><code>                </code><code>}</code></p> <p><code>            </code><code>}</code></p> <p><code>        </code><code>} </code><code>else</code> <code>{<!-- --></code></p> <p><code>            </code><code>destroySurface();</code></p> <p><code>        </code><code>}....</code></p> </td></tr></tbody></table> 
<p>SurfaceControl 类可以看作是一个 wrapper 类，最后会执行 copyFrom() 将其返回给 App 客户端：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> </td><td> <p><code>@UnsupportedAppUsage</code></p> <p><code>    </code><code>public</code> <code>void</code> <code>copyFrom(SurfaceControl other) {<!-- --></code></p> <p><code>        </code><code>if</code> <code>(other == </code><code>null</code><code>) {<!-- --></code></p> <p><code>            </code><code>throw</code> <code>new</code> <code>IllegalArgumentException(</code><code>"other must not be null"</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p></p> <p><code>        </code><code>long</code> <code>surfaceControlPtr = other.mNativeObject;</code></p> <p><code>        </code><code>if</code> <code>(surfaceControlPtr == </code><code>0</code><code>) {<!-- --></code></p> <p><code>            </code><code>throw</code> <code>new</code> <code>NullPointerException(</code></p> <p><code>                    </code><code>"null SurfaceControl native object. Are you using a released SurfaceControl?"</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p></p> <p><code>        </code><code>//通过JNI获取源SurfaceControl</code></p> <p><code>        </code><code>long</code> <code>newNativeObject = nativeGetFromSurfaceControl(mNativeObject, surfaceControlPtr);</code></p> <p></p> <p><code>        </code><code>synchronized</code> <code>(mLock) {<!-- --></code></p> <p><code>            </code><code>if</code> <code>(newNativeObject == mNativeObject) {<!-- --></code></p> <p><code>                </code><code>return</code><code>;</code></p> <p><code>            </code><code>}</code></p> <p><code>            </code><code>if</code> <code>(mNativeObject != </code><code>0</code><code>) {<!-- --></code></p> <p><code>                </code><code>nativeRelease(mNativeObject);</code></p> <p><code>            </code><code>}</code></p> <p><code>            </code><code>//保存到全局mNativeObject用于外部调用</code></p> <p><code>            </code><code>setNativeObjectLocked(newNativeObject);</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> </td></tr></tbody></table> 
<blockquote> 
 <p>Surface 显示过程总结：</p> 
</blockquote> 
<p>在 App 进程中创建 PhoneWindow 后会创建 ViewRoot。ViewRoot 的创建会创建一个 Surface，这个 Surface 其实是空的，通过与 WindowManagerService 通信 copyFrom() 一个NativeSurface 与 SurfaceFlinger 通信时。</p> 
<blockquote> 
 <p>关于Native Window：</p> 
</blockquote> 
<p>Native Window是OpenGL与本地窗口系统之间搭建了桥梁。整个GUI系统至少需要两种本地窗口：</p> 
<ul><li>（1）面向管理者（SurfaceFlinger）</li></ul> 
<p>SurfaceFlinger是系统中所有UI界面的管理者，需要直接或间接的持有“本地窗口”，此本地窗口是FramebufferNativeWindow。</p> 
<ul><li>（2）面向应用程序</li></ul> 
<p>这类本地窗口是Surface。</p> 
<p>正常情况按照SDK向导生成APK应用程序，是采用Skia等第三方图形库，而对于希望使用OpenGL ES来完成复杂界面渲染的应用开发者来说，Android也提供封装的GLSurfaceView（或其他方式）来实现图形显示。</p> 
<p><a name="_label3_1_3_0"></a></p> 
<h5 id="heading-6">①FramebufferNativeWindow</h5> 
<p>EGL需要通过本地窗口来为OpenGL/OpenGL ES创建环境。由于OpenGL/ES对多平台支持，考虑到兼容性和移植性。不同平台的本地窗口EGLNativeWindowType数据类型不同。</p> 
<p>Android平台的数据类型是ANativeWindow，像是一份“协议”，规定了一个本地窗口的形态和功能。ANativeWindow是FramebufferNativeWindow的父类。</p> 
<p>Android中，由于多缓冲技术，EGLNativeWindowType所管理的缓冲区最少2个，最大3个。</p> 
<p>FramebufferNativeWindow初始化需要Golloc支持，步骤如下：</p> 
<ul><li>加载GRALLOC_HARDWARE_MODULE_ID模块，参见上节。</li><li>分别打开fb和gralloc设备，打开后的设备由全局变量fbDev和grDev管理。</li><li>根据设备的属性来给FramebufferNativeWindow赋初值。</li><li>根据FramebufferNativeWindow的实现来填充ANativeWindow中的“协议”</li><li>其他一些必要的初始化</li></ul> 
<p><a name="_label3_1_3_1"></a></p> 
<h5 id="heading-7">②应用程序的本地窗口 - Surface</h5> 
<p>Surface也继承了ANativeWindow</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>class</code> <code>Surface : </code><code>public</code> <code>ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt;</code></p> </td></tr></tbody></table> 
<p>Surface是面向Android系统中所有UI应用程序的，即它承担着应用进程中的UI显示需求。</p> 
<p>需要面向上层实现（主要是Java层）提供绘制图像的画板。SurfaceFlinger需要收集系统中所有应用程序绘制的图像数据，然后集中显示到物理屏幕上。Surface需要扮演相应角色，本质上还是由SurfaceFlinger服务统一管理的，涉及到很多跨进程的通信细节。</p> 
<p><a name="_label3_1_3_2"></a></p> 
<h5 id="heading-8">③Surface的创建</h5> 
<p>Surface将通过mGraphicBufferProducer来获取buffer,这些缓冲区会被记录在mSlots中数据中。mGraphicBufferProducer这一核心成员的初始化流程如下：</p> 
<p>ViewRootImpl持有一个Java层的Surface对象（mSurface）。</p> 
<p>ViewRootImpl向WindowManagerService发起relayout请求，此时mSurface被赋予真正的有效值，将辗转生成的SurfaceControl通过Surface.copyFrom()函数复制到mSurface中。</p> 
<p>由此，Surface由SurfaceControl管理，SurfaceControl由SurfaceComposerClient创建。SurfaceComposerClient获得的匿名Binder是ISurfaceComposer，其服务端实现是SurfaceFlinger。而Surface依赖的IGraphicBufferProducer对象在Service端的实现是BufferQueue。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>class</code> <code>SurfaceFlinger : </code></p> <p><code>  </code><code>public</code> <code>BinderService&lt;SurfaceFlinger&gt;, </code><code>//在ServiceManager中注册为SurfaceFlinger</code></p> <p><code>  </code><code>public</code> <code>BnSurfaceComposer,</code><code>//实现的接口却叫ISurfaceComposer</code></p> </td></tr></tbody></table> 
<p><a name="_label3_1_3_3"></a></p> 
<h5 id="heading-9">④SurfaceFlinger服务框架：</h5> 
<p>Buffer，Consumer，Producer是“生产者-消费者”模型中的3个参与对象，如何协调好它们的工作是应用程序能否正常显示UI的关键。</p> 
<p>Buffer是BufferQueue，Producer是应用程序，Consumer是SurfaceFlinger。</p> 
<p></p> 
<p class="img-center"><img alt="" height="565" src="https://images2.imgbox.com/29/c5/dLaEXdsP_o.jpg" width="1072"></p> 
<p>Surface内部提供一个BufferQueue，与上层和SurfaceFlinger形成一个生产者消费者模型，上层对应Producer，SurfaceFlinger对应Consumer。三者通过Buffer产生联系，每个Buffer都有四种状态：</p> 
<ul><li>Free：可被上层使用;</li><li>Dequeued：出列，正在被上层使用;</li><li>Queued：入列，已完成上层绘制，等待SurfaceFlinger合成;</li><li>Acquired：被获取，SurfaceFlinger正持有该Buffer进行合成;</li></ul> 
<p>如此循环，形成一个Buffer被循环使用的过程（FREE-&gt; DEQUEUED-&gt;QUEUED-&gt;ACQUIRED-&gt;FREE）。</p> 
<p>BufferQueue中的mSlots数组用于管理期内的缓冲区，最大容器是32。数据缓冲区的空间是动态分配的，应用程序与SurfaceFlinger都是使用OpenGL ES来完成UI显示。Layer类在SurfaceFlinger中表示“层”，通俗地讲就是代表了一个“画面”，最终物理屏幕上的显示结果就是通过对系统中同时存在的所有“画面”进行处理叠加而成。</p> 
<p>到此这篇关于Android显示系统SurfaceFlinger详解的文章就介绍到这了。希望对大家的学习有所帮助，也希望大家多多支持脚本之家。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a8174eed2810952c382bf15339588cf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python调用MATLAB程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a12e88a253bc820a176fa235d191d22/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android音频系统AudioFlinger详解 超级干货</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>