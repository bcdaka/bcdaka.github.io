<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一篇文章带你解析完整数据结构-----满满干活值得收藏 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2fc61f5ecf87763beb94296ae6e48fec/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="一篇文章带你解析完整数据结构-----满满干活值得收藏">
  <meta property="og:description" content="数据结构是计算机科学中的一个重要分支，它涉及到计算机存储、组织数据的方式。以下是数据结构的主要知识点：
基本概念 数据（Data）。数据元素（Data Element)：数据项（Data Item）：数据对象（Data Object）：数据结构（Data Structure）：
逻辑结构（Logical Structure）
物理结构（Physical Structure）或存储结构
抽象数据类型（Abstract Data Type, ADT）
抽象数据类型（Abstract Data Type, ADT）
当然，让我们更详细地探讨数据结构的基本概念： 数据结构的分类 逻辑结构： 集合结构线性结构树形结构图形结构 物理结构（存储结构）： 顺序存储结构链式存储结构索引存储结构散列存储结构 常见数据结构 线性表 数组链表 单链表双链表循环链表 栈队列 循环队列链队列 树形结构 二叉树 满二叉树完全二叉树平衡二叉树（AVL树）二叉查找树（BST） 多路树 B树B&#43;树红黑树 堆 最大堆最小堆 哈夫曼树 图形结构 邻接矩阵邻接表十字链表邻接多重表 集合 并查集 算法 排序算法 冒泡排序选择排序插入排序快速排序归并排序堆排序希尔排序 查找算法 顺序查找二分查找哈希查找 算法评价 时间复杂度空间复杂度 其他 递归动态规划贪心算法回溯法
以上是数据结构的基本知识点，每个知识点下都包含了大量的详细内容，需要深入学习和实践才能掌握。 高级数据结构 跳表（Skip List）伸展树（Splay Tree）Treap（树堆）Trie（前缀树）后缀树B树及其变体（B树、B&#43;树、B*树）斐波那契堆配对堆（Pairing Heap）布隆过滤器（Bloom Filter）计数位数组（Counting Bloom Filter）Cuckoo哈希LSM树（Log-Structured Merge-Tree）跳跃表（Skip List） 特殊数据结构 并查集（Union-Find）线段树（Segment Tree）树状数组（Binary Indexed Tree / Fenwick Tree）平衡树（如2-3树、红黑树）区间树（Interval Tree）优先队列（基于堆实现） 数据结构在特定领域的应用 图算法在网络分析中的应用数据结构在数据库索引中的应用数据结构在算法竞赛中的应用 数据结构与算法的结合 动态规划中的状态存储结构贪心算法中的数据选择结构回溯算法中的状态表示结构 现代数据结构趋势 分布式数据结构并行数据结构数据结构在内存数据库中的应用 数据结构的实现和优化 缓存优化内存管理数据压缩技术 数据（Data） 定义：数据是信息的表示形式，可以是数字、文本、图像、声音等。特性： 可处理性：数据必须能被计算机程序处理。可表示性：数据需要以某种形式存在，如二进制、字符等。 数据元素（Data Element） 定义：数据元素是数据的基本单元，它可以是单个值或一组值的集合。例子：在数据库中，一条记录可以是一个数据元素，它包含了多个数据项，如姓名、地址、电话号码等。 数据项（Data Item） 定义：数据项是数据元素中的最小单位，不能再被分割。例子：在一个学生的信息记录中，学号、姓名、性别等每个单独的信息都是数据项。 数据对象（Data Object） 定义：数据对象是具有相同性质的数据元素的集合，它可以是整个数据集或数据集的一部分。例子：所有员工的工资记录可以构成一个数据对象。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-10T18:21:29+08:00">
    <meta property="article:modified_time" content="2024-08-10T18:21:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一篇文章带你解析完整数据结构-----满满干活值得收藏</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>数据结构是计算机科学中的一个重要分支，它涉及到计算机存储、组织数据的方式。以下是数据结构的主要知识点：</p> 
<h2><a id="_1"></a>基本概念</h2> 
<ol><li><strong>数据（Data）</strong>。</li><li><strong>数据元素（Data Element)</strong>：</li><li><strong>数据项（Data Item）</strong>：</li><li><strong>数据对象（Data Object）</strong>：</li><li><strong>数据结构（Data Structure）</strong>：<br> 逻辑结构（Logical Structure）<br> 物理结构（Physical Structure）或存储结构<br> 抽象数据类型（Abstract Data Type, ADT）<br> 抽象数据类型（Abstract Data Type, ADT）<br> 当然，让我们更详细地探讨数据结构的基本概念：</li></ol> 
<h4><a id="_14"></a>数据结构的分类</h4> 
<ol><li><strong>逻辑结构</strong>： 
  <ul><li><strong>集合结构</strong></li><li><strong>线性结构</strong></li><li><strong>树形结构</strong></li><li><strong>图形结构</strong></li></ul> </li><li><strong>物理结构（存储结构）</strong>： 
  <ul><li><strong>顺序存储结构</strong></li><li><strong>链式存储结构</strong></li><li><strong>索引存储结构</strong></li><li><strong>散列存储结构</strong></li></ul> </li></ol> 
<h4><a id="_25"></a>常见数据结构</h4> 
<ol><li><strong>线性表</strong> 
  <ul><li><strong>数组</strong></li><li><strong>链表</strong> 
    <ul><li>单链表</li><li>双链表</li><li>循环链表</li></ul> </li><li><strong>栈</strong></li><li><strong>队列</strong> 
    <ul><li>循环队列</li><li>链队列</li></ul> </li></ul> </li><li><strong>树形结构</strong> 
  <ul><li><strong>二叉树</strong> 
    <ul><li>满二叉树</li><li>完全二叉树</li><li>平衡二叉树（AVL树）</li><li>二叉查找树（BST）</li></ul> </li><li><strong>多路树</strong> 
    <ul><li>B树</li><li>B+树</li><li>红黑树</li></ul> </li><li><strong>堆</strong> 
    <ul><li>最大堆</li><li>最小堆</li></ul> </li><li><strong>哈夫曼树</strong></li></ul> </li><li><strong>图形结构</strong> 
  <ul><li><strong>邻接矩阵</strong></li><li><strong>邻接表</strong></li><li><strong>十字链表</strong></li><li><strong>邻接多重表</strong></li></ul> </li><li><strong>集合</strong> 
  <ul><li><strong>并查集</strong></li></ul> </li></ol> 
<h4><a id="_57"></a>算法</h4> 
<ul><li><strong>排序算法</strong> 
  <ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>快速排序</li><li>归并排序</li><li>堆排序</li><li>希尔排序</li></ul> </li><li><strong>查找算法</strong> 
  <ul><li>顺序查找</li><li>二分查找</li><li>哈希查找</li></ul> </li></ul> 
<h4><a id="_70"></a>算法评价</h4> 
<ul><li><strong>时间复杂度</strong></li><li><strong>空间复杂度</strong></li></ul> 
<h4><a id="_73"></a>其他</h4> 
<ul><li><strong>递归</strong></li><li><strong>动态规划</strong></li><li><strong>贪心算法</strong></li><li><strong>回溯法</strong><br> 以上是数据结构的基本知识点，每个知识点下都包含了大量的详细内容，需要深入学习和实践才能掌握。</li></ul> 
<h4><a id="_82"></a>高级数据结构</h4> 
<ul><li><strong>跳表（Skip List）</strong></li><li><strong>伸展树（Splay Tree）</strong></li><li><strong>Treap（树堆）</strong></li><li><strong>Trie（前缀树）</strong></li><li><strong>后缀树</strong></li><li><strong>B树及其变体（B树、B+树、B*树）</strong></li><li><strong>斐波那契堆</strong></li><li><strong>配对堆（Pairing Heap）</strong></li><li><strong>布隆过滤器（Bloom Filter）</strong></li><li><strong>计数位数组（Counting Bloom Filter）</strong></li><li><strong>Cuckoo哈希</strong></li><li><strong>LSM树（Log-Structured Merge-Tree）</strong></li><li><strong>跳跃表（Skip List）</strong></li></ul> 
<h4><a id="_96"></a>特殊数据结构</h4> 
<ul><li><strong>并查集（Union-Find）</strong></li><li><strong>线段树（Segment Tree）</strong></li><li><strong>树状数组（Binary Indexed Tree / Fenwick Tree）</strong></li><li><strong>平衡树（如2-3树、红黑树）</strong></li><li><strong>区间树（Interval Tree）</strong></li><li><strong>优先队列（基于堆实现）</strong></li></ul> 
<h4><a id="_103"></a>数据结构在特定领域的应用</h4> 
<ul><li><strong>图算法在网络分析中的应用</strong></li><li><strong>数据结构在数据库索引中的应用</strong></li><li><strong>数据结构在算法竞赛中的应用</strong></li></ul> 
<h4><a id="_107"></a>数据结构与算法的结合</h4> 
<ul><li><strong>动态规划中的状态存储结构</strong></li><li><strong>贪心算法中的数据选择结构</strong></li><li><strong>回溯算法中的状态表示结构</strong></li></ul> 
<h4><a id="_111"></a>现代数据结构趋势</h4> 
<ul><li><strong>分布式数据结构</strong></li><li><strong>并行数据结构</strong></li><li><strong>数据结构在内存数据库中的应用</strong></li></ul> 
<h4><a id="_115"></a>数据结构的实现和优化</h4> 
<ul><li><strong>缓存优化</strong></li><li><strong>内存管理</strong></li><li><strong>数据压缩技术</strong></li></ul> 
<p><img src="https://images2.imgbox.com/3d/ab/ydcmGtzy_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Data_121"></a>数据（Data）</h4> 
<ul><li><strong>定义</strong>：数据是信息的表示形式，可以是数字、文本、图像、声音等。</li><li><strong>特性</strong>： 
  <ul><li><strong>可处理性</strong>：数据必须能被计算机程序处理。</li><li><strong>可表示性</strong>：数据需要以某种形式存在，如二进制、字符等。</li></ul> </li></ul> 
<h4><a id="Data_Element_126"></a>数据元素（Data Element）</h4> 
<ul><li><strong>定义</strong>：数据元素是数据的基本单元，它可以是单个值或一组值的集合。</li><li><strong>例子</strong>：在数据库中，一条记录可以是一个数据元素，它包含了多个数据项，如姓名、地址、电话号码等。</li></ul> 
<h4><a id="Data_Item_129"></a>数据项（Data Item）</h4> 
<ul><li><strong>定义</strong>：数据项是数据元素中的最小单位，不能再被分割。</li><li><strong>例子</strong>：在一个学生的信息记录中，学号、姓名、性别等每个单独的信息都是数据项。</li></ul> 
<h4><a id="Data_Object_132"></a>数据对象（Data Object）</h4> 
<ul><li><strong>定义</strong>：数据对象是具有相同性质的数据元素的集合，它可以是整个数据集或数据集的一部分。</li><li><strong>例子</strong>：所有员工的工资记录可以构成一个数据对象。<br> <img src="https://images2.imgbox.com/9b/78/9r359tSq_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="Data_Structure_136"></a>数据结构（Data Structure）</h4> 
<ul><li><strong>定义</strong>：数据结构是数据对象中数据元素之间关系的描述，它定义了数据的组织、管理和存储方式。</li><li><strong>重要性</strong>：良好的数据结构可以提高数据处理的效率，减少存储空间的需求。</li></ul> 
<h4><a id="Logical_Structure_139"></a>逻辑结构（Logical Structure）</h4> 
<ul><li><strong>定义</strong>：逻辑结构是指数据元素之间的逻辑关系，它不依赖于数据在计算机中的存储方式。</li><li><strong>分类</strong>： 
  <ul><li><strong>集合结构</strong>：数据元素之间没有特定的关系，它们只是简单地属于同一个集合。</li><li><strong>线性结构</strong>：数据元素之间存在一对一的关系，如数组、链表、栈和队列。</li><li><strong>树形结构</strong>：数据元素之间存在一对多的层次关系，如树和二叉树。</li><li><strong>图形结构</strong>：数据元素之间存在多对多的关系，如网状结构和图。</li></ul> </li></ul> 
<h4><a id="Physical_Structure_146"></a>物理结构（Physical Structure）或存储结构</h4> 
<ul><li><strong>定义</strong>：物理结构是指数据在计算机存储器中的实际表示方式。</li><li><strong>分类</strong>： 
  <ul><li><strong>顺序存储结构</strong>： 
    <ul><li>数据元素在内存中连续存放，通过索引直接访问。</li><li>优点：访问速度快。</li><li>缺点：插入和删除操作可能需要移动大量元素。</li></ul> </li><li><strong>链式存储结构</strong>： 
    <ul><li>数据元素可以分散存储，通过指针连接。</li><li>优点：插入和删除操作不需要移动其他元素。</li><li>缺点：访问速度相对较慢，因为需要通过指针遍历。</li></ul> </li><li><strong>索引存储结构</strong>： 
    <ul><li>通过建立索引表来快速访问数据元素。</li><li>优点：可以快速定位数据元素。</li><li>缺点：索引表本身需要额外的存储空间。</li></ul> </li><li><strong>散列存储结构</strong>： 
    <ul><li>通过散列函数直接计算出数据元素的存储地址。</li><li>优点：通常可以实现快速的插入和查找操作。</li><li>缺点：散列函数的设计和冲突解决策略较为复杂。<br> <img src="https://images2.imgbox.com/0e/04/obA3xqOl_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> </li></ul> 
<h4><a id="Abstract_Data_Type_ADT_166"></a>抽象数据类型（Abstract Data Type, ADT）</h4> 
<ul><li><strong>定义</strong>：抽象数据类型是一组数据和施加于其上的一组操作的总称，它定义了数据的逻辑特性及其操作接口，而不涉及具体的实现细节。</li><li><strong>例子</strong>：栈、队列、列表等都是抽象数据类型的例子。</li><li><strong>特性</strong>： 
  <ul><li><strong>数据抽象</strong>：只关注数据的逻辑特性，而不关心数据在计算机中的具体表示。</li><li><strong>封装性</strong>：数据和操作被封装在一起，对外提供统一的接口。<br> 理解这些概念是深入学习和应用数据结构的基础。在实际编程中，选择合适的数据结构对于编写高效、可维护的代码至关重要。</li></ul> </li></ul> 
<h4><a id="Abstract_Data_Type_ADT_174"></a>抽象数据类型（Abstract Data Type, ADT）</h4> 
<ul><li><strong>定义</strong>：一个数学模型以及定义在此模型上的一组操作。</li><li><strong>举例</strong>：栈、队列、线性表、树等。<br> 数据结构的分类主要基于数据元素之间的关系，可以分为两大类：逻辑结构和物理结构。以下是对这两大类数据结构分类的详细解释：</li></ul> 
<h4><a id="_178"></a>逻辑结构</h4> 
<p>逻辑结构是数据对象中数据元素之间的逻辑关系，与数据的存储无关，是抽象的。逻辑结构主要分为以下几种：</p> 
<h5><a id="_180"></a>集合结构</h5> 
<ul><li><strong>定义</strong>：集合结构中的数据元素之间除了“属于同一个集合”的关系外，没有其他关系。</li><li><strong>特点</strong>：数据元素之间没有顺序或层次关系，可以看作是一个无序的集合。<br> <img src="https://images2.imgbox.com/99/c1/7oG7uX9t_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="_184"></a>线性结构</h5> 
<ul><li><strong>定义</strong>：线性结构中的数据元素之间存在一对一的关系。</li><li><strong>特点</strong>： 
  <ul><li> <p>数据元素有先后顺序，除了第一个和最后一个元素外，每个元素有且只有一个前驱和后继。</p> </li><li> <p>常见的线性结构包括数组、链表、栈和队列。</p> </li><li> <p><strong>数组</strong>：一种连续的存储结构，元素在内存中连续存放，通过索引直接访问。</p> </li><li> <p><strong>链表</strong>：一种非连续的存储结构，元素通过指针连接，可以是单向链表、双向链表或循环链表。</p> </li><li> <p><strong>栈</strong>：一种后进先出（LIFO）的数据结构，只允许在一端进行插入和删除操作。</p> </li><li> <p><strong>队列</strong>：一种先进先出（FIFO）的数据结构，允许在一端插入元素，在另一端删除元素。</p> </li></ul> </li></ul> 
<h5><a id="_194"></a>树形结构</h5> 
<ul><li><strong>定义</strong>：树形结构中的数据元素之间存在一对多的层次关系。</li><li><strong>特点</strong>： 
  <ul><li> <p>每个元素可以有多个后继，但只能有一个前驱（根节点除外）。</p> </li><li> <p>常见的树形结构包括二叉树、多叉树、堆、平衡树等。</p> </li><li> <p><strong>二叉树</strong>：每个节点最多有两个子节点的树结构，包括满二叉树、完全二叉树、平衡二叉树（AVL树）、二叉查找树（BST）等。</p> </li><li> <p><strong>多叉树</strong>：每个节点可以有多个子节点的树结构，如B树、B+树、红黑树等。</p> </li><li> <p><strong>堆</strong>：一种特殊的树形结构，通常用于实现优先队列，分为最大堆和最小堆。</p> </li></ul> </li></ul> 
<h5><a id="_203"></a>图形结构</h5> 
<ul><li><strong>定义</strong>：图形结构中的数据元素之间存在多对多的关系。</li><li><strong>特点</strong>： 
  <ul><li>数据元素之间没有固定的顺序，可以是任意复杂的网络结构。</li><li>常见的图形结构包括无向图、有向图、加权图、网络等。</li></ul> </li></ul> 
<h4><a id="_208"></a>物理结构（存储结构）</h4> 
<p>物理结构是指数据在计算机中的实际存储方式，它依赖于逻辑结构。物理结构主要分为以下几种：<br> <img src="https://images2.imgbox.com/1e/96/nBHajqzw_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_211"></a>顺序存储结构</h5> 
<ul><li><strong>定义</strong>：顺序存储结构中，数据元素在内存中连续存放，通常利用数组实现。</li><li><strong>特点</strong>： 
  <ul><li>访问速度快，通过索引直接访问。</li><li>插入和删除操作可能需要移动大量元素，效率较低。</li></ul> </li></ul> 
<h5><a id="_216"></a>链式存储结构</h5> 
<ul><li><strong>定义</strong>：链式存储结构中，数据元素可以分散存储，通过指针连接。</li><li><strong>特点</strong>： 
  <ul><li>插入和删除操作不需要移动其他元素，效率较高。</li><li>访问速度相对较慢，因为需要通过指针遍历。</li></ul> </li></ul> 
<h5><a id="_221"></a>索引存储结构</h5> 
<ul><li><strong>定义</strong>：索引存储结构通过建立索引表来快速访问数据元素。</li><li><strong>特点</strong>： 
  <ul><li>可以快速定位数据元素。</li><li>索引表本身需要额外的存储空间。</li></ul> </li></ul> 
<h5><a id="_226"></a>散列存储结构</h5> 
<ul><li><strong>定义</strong>：散列存储结构通过散列函数直接计算出数据元素的存储地址。</li><li><strong>特点</strong>： 
  <ul><li>通常可以实现快速的插入和查找操作。</li><li>散列函数的设计和冲突解决策略较为复杂。<br> 每种逻辑结构都可以采用不同的物理结构来实现，不同的实现方式会有不同的性能特点。在设计数据结构时，需要根据具体的应用场景和需求来选择合适的逻辑结构和物理结构。</li></ul> </li></ul> 
<p>当然，以下是一些常见数据结构的简单代码示例。这些示例将使用Python语言，因为它简单且易于理解。</p> 
<h4><a id="_234"></a>数组（顺序存储结构）</h4> 
<pre><code class="prism language-python"><span class="token comment"># Python中的列表可以看作是动态数组</span>
array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment"># 访问元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 3</span>
<span class="token comment"># 修改元素</span>
array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2, 10, 4, 5]</span>
<span class="token comment"># 添加元素</span>
array<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2, 10, 4, 5, 6]</span>
<span class="token comment"># 删除元素</span>
<span class="token keyword">del</span> array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2, 4, 5, 6]</span>
</code></pre> 
<h4><a id="_250"></a>链表（链式存储结构）</h4> 
<pre><code class="prism language-python"><span class="token comment"># 定义链表节点</span>
<span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token builtin">next</span>
<span class="token comment"># 创建链表</span>
head <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># 遍历链表</span>
current <span class="token operator">=</span> head
<span class="token keyword">while</span> current<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    current <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token builtin">next</span>
</code></pre> 
<h4><a id="_267"></a>栈（线性结构，后进先出）</h4> 
<pre><code class="prism language-python"><span class="token comment"># 使用列表实现栈</span>
stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment"># 入栈</span>
stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># 出栈</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 3</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2]</span>
</code></pre> 
<h4><a id="_279"></a>队列（线性结构，先进先出）</h4> 
<pre><code class="prism language-python"><span class="token comment"># 使用collections.deque实现队列</span>
<span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 入队</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># 出队</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span>  <span class="token comment"># 输出 deque([2, 3])</span>
</code></pre> 
<h4><a id="_292"></a>二叉树（树形结构）</h4> 
<pre><code class="prism language-python"><span class="token comment"># 定义二叉树节点</span>
<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right
<span class="token comment"># 创建二叉树</span>
root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># 前序遍历</span>
<span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> node<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        preorderTraversal<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        preorderTraversal<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>  <span class="token comment"># 输出 1 2 3</span>
</code></pre> 
<p>这些示例展示了如何使用Python实现和操作基本的数据结构。在实际应用中，这些数据结构可能会更加复杂，并且需要更多的功能和方法。</p> 
<p>常见的数据结构主要分为以下几类，每一类都有其特定的用途和操作：<br> <img src="https://images2.imgbox.com/67/be/1Gqdp3QQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_316"></a>线性结构</h4> 
<ol><li><strong>数组（Array）</strong>： 
  <ul><li>特点：固定大小的顺序存储结构，元素在内存中连续存放。</li><li>操作：随机访问、插入（可能需要移动元素）、删除（可能需要移动元素）。</li></ul> </li><li><strong>链表（Linked List）</strong>： 
  <ul><li>特点：动态大小的链式存储结构，元素通过指针连接。</li><li>操作：插入（不需要移动元素）、删除（不需要移动元素，但需要找到前驱节点）、遍历。</li><li><strong>单向链表</strong>：每个节点只有一个指向下一个节点的指针。</li><li><strong>双向链表</strong>：每个节点有两个指针，分别指向前一个和后一个节点。</li><li><strong>循环链表</strong>：链表的最后一个节点指向第一个节点，形成一个环。</li></ul> </li><li><strong>栈（Stack）</strong>： 
  <ul><li>特点：后进先出（LIFO）的数据结构。</li><li>操作：压栈（push）、出栈（pop）、查看栈顶元素。</li></ul> </li><li><strong>队列（Queue）</strong>： 
  <ul><li>特点：先进先出（FIFO）的数据结构。</li><li>操作：入队（enqueue）、出队（dequeue）、查看队首元素。</li></ul> </li></ol> 
<h4><a id="_332"></a>树形结构</h4> 
<ol><li><strong>二叉树（Binary Tree）</strong>： 
  <ul><li>特点：每个节点最多有两个子节点。</li><li>操作：遍历（前序、中序、后序）、查找、插入、删除。</li><li><strong>二叉查找树（BST）</strong>：左子树的所有节点都比当前节点小，右子树的所有节点都比当前节点大。</li><li><strong>平衡二叉树（AVL）</strong>：任何节点的两个子树的高度差不超过1。</li></ul> </li><li><strong>堆（Heap）</strong>： 
  <ul><li>特点：特殊的完全二叉树，通常用于实现优先队列。</li><li>操作：插入、删除最大/最小元素。</li></ul> </li><li><strong>B树（B-Tree）</strong>： 
  <ul><li>特点：多路平衡查找树，用于磁盘存储。</li><li>操作：插入、删除、查找。</li></ul> </li></ol> 
<h4><a id="_344"></a>图形结构</h4> 
<ol><li><strong>图（Graph）</strong>： 
  <ul><li>特点：由节点（顶点）和边组成的数据结构，用于表示对象间多对多的关系。</li><li>操作：遍历（深度优先搜索DFS、广度优先搜索BFS）、路径查找。</li><li><strong>无向图</strong>：边没有方向。</li><li><strong>有向图</strong>：边有方向。</li><li><strong>加权图</strong>：边有权重。</li></ul> </li></ol> 
<h4><a id="_351"></a>其他结构</h4> 
<ol><li><strong>哈希表（Hash Table）</strong>： 
  <ul><li>特点：通过哈希函数将键映射到表中一个位置来访问记录，用于快速查找。</li><li>操作：插入、删除、查找。</li></ul> </li><li><strong>集合（Set）</strong>： 
  <ul><li>特点：存储不重复元素的集合。</li><li>操作：添加、删除、查找。</li></ul> </li><li><strong>字典（Dictionary）</strong>： 
  <ul><li>特点：键值对集合，通常通过哈希表实现。</li><li>操作：插入、删除、查找。<br> 这些数据结构在不同的编程语言中有不同的实现方式，它们的应用范围广泛，从简单的数据存储到复杂的数据处理都有它们的身影。<br> 当然，以下是一些常见数据结构的简单代码示例。这些示例将使用Python语言，因为它简单且易于理解。</li></ul> </li></ol> 
<h4><a id="_363"></a>数组（顺序存储结构）</h4> 
<pre><code class="prism language-python"><span class="token comment"># Python中的列表可以看作是动态数组</span>
array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment"># 访问元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 3</span>
<span class="token comment"># 修改元素</span>
array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2, 10, 4, 5]</span>
<span class="token comment"># 添加元素</span>
array<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2, 10, 4, 5, 6]</span>
<span class="token comment"># 删除元素</span>
<span class="token keyword">del</span> array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2, 4, 5, 6]</span>
</code></pre> 
<h4><a id="_379"></a>链表（链式存储结构）</h4> 
<pre><code class="prism language-python"><span class="token comment"># 定义链表节点</span>
<span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token builtin">next</span>
<span class="token comment"># 创建链表</span>
head <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># 遍历链表</span>
current <span class="token operator">=</span> head
<span class="token keyword">while</span> current<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    current <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token builtin">next</span>
</code></pre> 
<h4><a id="_396"></a>栈（线性结构，后进先出）</h4> 
<pre><code class="prism language-python"><span class="token comment"># 使用列表实现栈</span>
stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment"># 入栈</span>
stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># 出栈</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 3</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2]</span>
</code></pre> 
<h4><a id="_408"></a>队列（线性结构，先进先出）</h4> 
<pre><code class="prism language-python"><span class="token comment"># 使用collections.deque实现队列</span>
<span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 入队</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># 出队</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span>  <span class="token comment"># 输出 deque([2, 3])</span>
</code></pre> 
<h4><a id="_421"></a>二叉树（树形结构）</h4> 
<pre><code class="prism language-python"><span class="token comment"># 定义二叉树节点</span>
<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right
<span class="token comment"># 创建二叉树</span>
root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># 前序遍历</span>
<span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> node<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        preorderTraversal<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        preorderTraversal<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>  <span class="token comment"># 输出 1 2 3</span>
</code></pre> 
<p>这些示例展示了如何使用Python实现和操作基本的数据结构。在实际应用中，这些数据结构可能会更加复杂，并且需要更多的功能和方法。<br> 当然，这里有一些更复杂的数据结构的代码示例。<br> <img src="https://images2.imgbox.com/9b/cf/3cVAEV14_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Hash_Table_444"></a>哈希表（Hash Table）</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">HashTable</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">10</span>
        self<span class="token punctuation">.</span>table <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>size
    <span class="token keyword">def</span> <span class="token function">_hash</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> key <span class="token operator">%</span> self<span class="token punctuation">.</span>size
    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> self<span class="token punctuation">.</span>_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> self<span class="token punctuation">.</span>_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> pair <span class="token keyword">in</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> pair<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
<span class="token comment"># 示例</span>
hash_table <span class="token operator">=</span> HashTable<span class="token punctuation">(</span><span class="token punctuation">)</span>
hash_table<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
hash_table<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>hash_table<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 1</span>
</code></pre> 
<h4><a id="Set_470"></a>集合（Set）</h4> 
<pre><code class="prism language-python"><span class="token comment"># Python中的集合就是一种数据结构</span>
fruits <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token string">"cherry"</span><span class="token punctuation">}</span>
<span class="token comment"># 添加元素</span>
fruits<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"mango"</span><span class="token punctuation">)</span>
<span class="token comment"># 删除元素</span>
fruits<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span>
<span class="token comment"># 查找元素</span>
<span class="token keyword">if</span> <span class="token string">"apple"</span> <span class="token keyword">in</span> fruits<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Yes, we have apple."</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="Dictionary_482"></a>字典（Dictionary）</h4> 
<pre><code class="prism language-python"><span class="token comment"># Python中的字典就是一种数据结构</span>
my_dict <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">"city"</span><span class="token punctuation">:</span> <span class="token string">"New York"</span><span class="token punctuation">}</span>
<span class="token comment"># 访问元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>my_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 John</span>
<span class="token comment"># 添加或修改元素</span>
my_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Doe"</span>
<span class="token comment"># 删除元素</span>
<span class="token keyword">del</span> my_dict<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span>
</code></pre> 
<h4><a id="Priority_Queue_493"></a>优先队列（Priority Queue）</h4> 
<pre><code class="prism language-python"><span class="token keyword">from</span> heapq <span class="token keyword">import</span> heappush<span class="token punctuation">,</span> heappop
<span class="token comment"># 定义一个优先队列</span>
priority_queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment"># 插入元素（元素可以是元组，其中第一个元素是优先级，第二个元素是要存储的数据）</span>
heappush<span class="token punctuation">(</span>priority_queue<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"task 1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
heappush<span class="token punctuation">(</span>priority_queue<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"task 2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
heappush<span class="token punctuation">(</span>priority_queue<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"task 3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 取出优先级最高的元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>heappop<span class="token punctuation">(</span>priority_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 (1, "task 3")</span>
</code></pre> 
<p>这些示例展示了如何使用Python实现和操作更复杂的数据结构。在实际应用中，这些数据结构可能会更加复杂，并且需要更多的功能和方法。<br> 树形结构是一类重要的数据结构，它们在计算机科学中广泛用于存储和检索数据。以下是树形结构的详细介绍：</p> 
<h4><a id="_507"></a>树形结构</h4> 
<h5><a id="_508"></a>二叉树</h5> 
<ul><li><strong>定义</strong>：二叉树是一种特殊的树形结构，每个节点最多有两个子节点。</li></ul> 
<h6><a id="_510"></a>满二叉树</h6> 
<ul><li><strong>定义</strong>：满二叉树是一种特殊的二叉树，除了叶子节点外，每个节点都有两个子节点。</li></ul> 
<h6><a id="_512"></a>完全二叉树</h6> 
<ul><li><strong>定义</strong>：完全二叉树是一种特殊的二叉树，除了最底层外，所有层都被完全填满，且最底层的节点都靠左排列。</li></ul> 
<h6><a id="AVL_514"></a>平衡二叉树（AVL树）</h6> 
<ul><li><strong>定义</strong>：平衡二叉树是一种特殊的二叉树，它满足任何节点的两个子树的高度差不超过1。<br> <img src="https://images2.imgbox.com/ea/4f/13vM8dn6_o.png" alt="在这里插入图片描述"></li></ul> 
<h6><a id="BST_517"></a>二叉查找树（BST）</h6> 
<ul><li><strong>定义</strong>：二叉查找树是一种特殊的二叉树，左子树上所有节点的值都小于当前节点的值，右子树上所有节点的值都大于当前节点的值。</li></ul> 
<h5><a id="_519"></a>多路树</h5> 
<ul><li><strong>定义</strong>：多路树是一种特殊的树形结构，每个节点可以有多个子节点。</li></ul> 
<h6><a id="B_521"></a>B树</h6> 
<ul><li><strong>定义</strong>：B树是一种特殊的树形结构，用于数据库索引和文件系统。它是一种多路搜索树，每个节点可以有多个子节点。</li></ul> 
<h6><a id="B_523"></a>B+树</h6> 
<ul><li><strong>定义</strong>：B+树是一种特殊的树形结构，它是B树的变种，所有叶子节点包含所有的键值，且所有的叶子节点通过指针连接。</li></ul> 
<h6><a id="_525"></a>红黑树</h6> 
<ul><li><strong>定义</strong>：红黑树是一种特殊的树形结构，它满足以下性质：每个节点要么是红色，要么是黑色；根节点是黑色；每个叶子节点（NIL节点）是黑色；如果一个节点是红色，则它的两个子节点都是黑色；对每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li></ul> 
<h5><a id="_527"></a>堆</h5> 
<ul><li><strong>定义</strong>：堆是一种特殊的树形结构，通常用于实现优先队列。</li></ul> 
<h6><a id="_529"></a>最大堆</h6> 
<ul><li><strong>定义</strong>：最大堆是一种特殊的堆，每个节点的值都大于或等于其子节点的值。</li></ul> 
<h6><a id="_531"></a>最小堆</h6> 
<ul><li><strong>定义</strong>：最小堆是一种特殊的堆，每个节点的值都小于或等于其子节点的值。</li></ul> 
<h5><a id="_533"></a>哈夫曼树</h5> 
<ul><li><strong>定义</strong>：哈夫曼树是一种特殊的树形结构，它是一种带权路径长度最短的二叉树，常用于数据压缩。</li></ul> 
<h4><a id="_535"></a>图形结构</h4> 
<h5><a id="_536"></a>邻接矩阵</h5> 
<ul><li><strong>定义</strong>：邻接矩阵是一种特殊的图形结构，它使用二维数组来表示图中顶点之间的关系。</li></ul> 
<h5><a id="_538"></a>邻接表</h5> 
<ul><li><strong>定义</strong>：邻接表是一种特殊的图形结构，它使用链表来表示图中顶点之间的关系。</li></ul> 
<h5><a id="_540"></a>十字链表</h5> 
<ul><li><strong>定义</strong>：十字链表是一种特殊的图形结构，它使用双向链表来表示图中顶点之间的关系，并且在每个顶点的链表中包含指向其父节点的指针。</li></ul> 
<h5><a id="_542"></a>邻接多重表</h5> 
<ul><li><strong>定义</strong>：邻接多重表是一种特殊的图形结构，它使用多重链表来表示图中顶点之间的关系。</li></ul> 
<h4><a id="_544"></a>集合</h4> 
<h5><a id="_545"></a>并查集</h5> 
<ul><li><strong>定义</strong>：并查集是一种特殊的集合结构，它用于处理一些不交集的合并及查询问题。<br> 以上是树形结构的基本概念和分类。在实际应用中，树形结构可以根据具体需求进行扩展和变种。</li></ul> 
<p>排序算法是计算机科学中的一种基本算法，用于将一组数据按照特定的顺序进行排列。排序算法可以分为内部排序和外部排序，内部排序是在内存中进行的排序，而外部排序是在硬盘等外部存储设备上进行的排序。常见的内部排序算法包括冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序和希尔排序等。下面将详细介绍这些排序算法的原理和实现。<br> <img src="https://images2.imgbox.com/c5/f7/eGqOfHEw_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_553"></a>冒泡排序</h4> 
<h5><a id="_554"></a>原理</h5> 
<p>冒泡排序的基本思想是通过相邻元素的比较和交换，将最大（或最小）的元素逐渐“冒泡”到数组的末尾。</p> 
<h5><a id="_556"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
</code></pre> 
<h4><a id="_565"></a>选择排序</h4> 
<h5><a id="_566"></a>原理</h5> 
<p>选择排序的基本思想是每次从未排序的部分中选择最小（或最大）的元素，放到已排序部分的末尾。</p> 
<h5><a id="_568"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        min_index <span class="token operator">=</span> i
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                min_index <span class="token operator">=</span> j
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
</code></pre> 
<h4><a id="_579"></a>插入排序</h4> 
<h5><a id="_580"></a>原理</h5> 
<p>插入排序的基本思想是将一个记录插入到已排序好的有序表中，从而得到一个新的、记录数增1的有序表。</p> 
<h5><a id="_582"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        key <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token keyword">and</span> key <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            j <span class="token operator">-=</span> <span class="token number">1</span>
        arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key
</code></pre> 
<h4><a id="_594"></a>快速排序</h4> 
<h5><a id="_595"></a>原理</h5> 
<p>快速排序的基本思想是通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后再分别对这两部分记录继续进行排序，以达到整个序列有序。</p> 
<h5><a id="_597"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> arr
    pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span>
    left <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr <span class="token keyword">if</span> x <span class="token operator">&lt;</span> pivot<span class="token punctuation">]</span>
    middle <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr <span class="token keyword">if</span> x <span class="token operator">==</span> pivot<span class="token punctuation">]</span>
    right <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr <span class="token keyword">if</span> x <span class="token operator">&gt;</span> pivot<span class="token punctuation">]</span>
    <span class="token keyword">return</span> quick_sort<span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> middle <span class="token operator">+</span> quick_sort<span class="token punctuation">(</span>right<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_608"></a>归并排序</h4> 
<p><img src="https://images2.imgbox.com/c3/95/OT3G4sb0_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_610"></a>原理</h5> 
<p>归并排序的基本思想是将待排序的记录序列分为若干个子序列，分别对每个子序列进行排序，再将已排序好的子序列合并，得到一个有序的记录序列。</p> 
<h5><a id="_612"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> arr
    mid <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
    left <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
    right <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> j <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
    result<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    result<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
</code></pre> 
<h4><a id="_635"></a>堆排序</h4> 
<p><img src="https://images2.imgbox.com/88/5b/YqeSzttg_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_637"></a>原理</h5> 
<p>堆排序的基本思想是将待排序的序列构造成一个大顶堆（或小顶堆），此时，整个序列的最大（或最小）值就是堆顶的根节点。将堆顶的根节点与堆数组的末尾元素进行交换，此时末尾元素就是最大（或最小）值。然后将剩余的序列重新构造成一个堆，重复以上操作</p> 
<pre><code class="prism language-c">def <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token operator">:</span>
    largest <span class="token operator">=</span> i  # Initialize largest as root
    l <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span>     # left <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span>
    r <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span>     # right <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">2</span>

    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Check <span class="token keyword">if</span> left child of root exists and is</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">greater</span> <span class="token expression">than root</span></span>
    <span class="token keyword">if</span> l <span class="token operator">&lt;</span> n and arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token operator">:</span>
        largest <span class="token operator">=</span> l

    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Check <span class="token keyword">if</span> right child of root exists and is</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">greater</span> <span class="token expression">than the largest so far</span></span>
    <span class="token keyword">if</span> r <span class="token operator">&lt;</span> n and arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token operator">:</span>
        largest <span class="token operator">=</span> r

    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Change root<span class="token punctuation">,</span> <span class="token keyword">if</span> needed</span></span>
    <span class="token keyword">if</span> largest <span class="token operator">!=</span> i<span class="token operator">:</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  # swap

        <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Heapify the root<span class="token punctuation">.</span></span></span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span>

def <span class="token function">heap_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">:</span>
    n <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>

    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Build a max heap</span></span>
    <span class="token keyword">for</span> i in <span class="token function">range</span><span class="token punctuation">(</span>n <span class="token comment">// 2 - 1, -1, -1):</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span>

    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">One by one extract elements</span></span>
    <span class="token keyword">for</span> i in <span class="token function">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  # swap
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Example usage<span class="token operator">:</span></span></span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>
<span class="token function">heap_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Sorted array is"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>

</code></pre> 
<p>)</p> 
<h5><a id="_687"></a>直到整个序列有序实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    largest <span class="token operator">=</span> i  <span class="token comment"># Initialize largest as root</span>
    l <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span>     <span class="token comment"># left = 2*i + 1</span>
    r <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span>     <span class="token comment"># right = 2*i + 2</span>
    <span class="token comment"># See if left child of root exists and is</span>
    <span class="token comment"># greater than root</span>
    <span class="token keyword">if</span> l <span class="token operator">&lt;</span> n <span class="token keyword">and</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>
        largest <span class="token operator">=</span> l
    <span class="token comment"># See if right child of root exists and is</span>
    <span class="token comment"># greater than the largest so far</span>
    <span class="token keyword">if</span> r <span class="token operator">&lt;</span> n <span class="token keyword">and</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>
        largest <span class="token operator">=</span> r
    <span class="token comment"># Change root, if needed</span>
    <span class="token keyword">if</span> largest <span class="token operator">!=</span> i<span class="token punctuation">:</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment"># swap</span>
        <span class="token comment"># Heapify the root.</span>
        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
    <span class="token comment"># Build a max heap</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token comment"># One by one extract elements</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment"># swap</span>
        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_716"></a>希尔排序</h4> 
<p><img src="https://images2.imgbox.com/0b/6b/7oVhFmoB_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_718"></a>原理</h5> 
<p>希尔排序（也称为“递减增量排序”）的基本思想是将整个无序序列分割成若干个子序列，分别进行直接插入排序。待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p> 
<h5><a id="_720"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
    gap <span class="token operator">=</span> n <span class="token operator">//</span> <span class="token number">2</span>
    <span class="token comment"># 希尔排序</span>
    <span class="token keyword">while</span> gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>gap<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            j <span class="token operator">=</span> i
            <span class="token keyword">while</span> j <span class="token operator">&gt;=</span> gap <span class="token keyword">and</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">:</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span>
                j <span class="token operator">-=</span> gap
            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp
        gap <span class="token operator">//=</span> <span class="token number">2</span>
</code></pre> 
<p>这些排序算法各有优缺点，选择哪种排序算法取决于具体的需求和应用场景。例如，快速排序和堆排序的平均和最坏时间复杂度较低，但快速排序在最坏情况下的时间复杂度为O(n^2)，而堆排序和归并排序的时间复杂度始终为O(n log n)。插入排序和选择排序的时间复杂度为O(n^2)，但它们在小型数据集上的性能可能优于其他排序算法。希尔排序的时间复杂度介于O(n log n)和O(n^2)之间，但它对于已经部分排序的数据集效果较好。<br> 查找算法是计算机科学中用于在数据集中查找特定元素的方法。以下是一些常见的查找算法：</p> 
<h4><a id="_738"></a>顺序查找</h4> 
<p><img src="https://images2.imgbox.com/b4/45/pYdKfY3D_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_740"></a>原理</h5> 
<p>顺序查找是最简单的查找方法，它从数据集的开始处逐个比较每个元素，直到找到目标元素或查找完毕。</p> 
<h5><a id="_742"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">sequential_search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">:</span>
            <span class="token keyword">return</span> i  <span class="token comment"># 返回找到元素的索引</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token comment"># 如果没有找到元素，返回-1</span>
</code></pre> 
<h4><a id="_750"></a>二分查找</h4> 
<h5><a id="_751"></a>原理</h5> 
<p>二分查找是一种在有序数组中查找特定元素的搜索算法。它通过将搜索区间分成两半，然后确定目标值是在较小的子区间还是较大的子区间，以此类推，直到找到目标值或搜索区间为空。</p> 
<h5><a id="_753"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    low <span class="token operator">=</span> <span class="token number">0</span>
    high <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
    mid <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        <span class="token comment"># 检查中间元素</span>
        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>
            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> x<span class="token punctuation">:</span>
            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> mid  <span class="token comment"># 目标值在中间</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token comment"># 目标值不在数组中</span>
</code></pre> 
<h4><a id="_770"></a>哈希查找</h4> 
<p><img src="https://images2.imgbox.com/67/ea/BidOFxFb_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_772"></a>原理</h5> 
<p>哈希查找使用哈希表（哈希表是一种通过哈希函数将键映射到表中一个位置的数据结构）来存储数据，从而实现快速的查找。</p> 
<h5><a id="_774"></a>实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">HashTable</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>size <span class="token operator">=</span> size
        self<span class="token punctuation">.</span>table <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>size
    <span class="token keyword">def</span> <span class="token function">_hash</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> key <span class="token operator">%</span> self<span class="token punctuation">.</span>size
    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> self<span class="token punctuation">.</span>_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> self<span class="token punctuation">.</span>_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> pair <span class="token keyword">in</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> pair<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
<span class="token comment"># Example usage:</span>
hash_table <span class="token operator">=</span> HashTable<span class="token punctuation">(</span><span class="token punctuation">)</span>
hash_table<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
hash_table<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>hash_table<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 1</span>
</code></pre> 
<p>这些查找算法各有优缺点，选择哪种查找算法取决于具体的需求和应用场景。例如，顺序查找适用于无序数组，而二分查找适用于有序数组。哈希查找适用于大规模数据集，但需要额外的空间来存储哈希表。<br> 算法评价是评估算法性能的重要手段，主要包括时间复杂度和空间复杂度两个方面。<br> <img src="https://images2.imgbox.com/7f/35/SxD4OOmX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_803"></a>时间复杂度</h4> 
<p>时间复杂度是衡量算法运行时间的一个指标，它描述了算法执行过程中基本操作的执行次数与输入规模之间的关系。通常使用大O符号（O）来表示时间复杂度。</p> 
<ul><li><strong>最好情况</strong>：算法执行过程中基本操作执行次数最少的情况。</li><li><strong>最坏情况</strong>：算法执行过程中基本操作执行次数最多的情况。</li><li><strong>平均情况</strong>：算法执行过程中基本操作执行次数的平均情况。</li></ul> 
<h4><a id="_808"></a>空间复杂度</h4> 
<p>空间复杂度是衡量算法执行过程中所需内存空间的一个指标，它描述了算法执行过程中所需内存空间与输入规模之间的关系。通常使用大O符号（O）来表示空间复杂度。</p> 
<ul><li><strong>最好情况</strong>：算法执行过程中所需内存空间最少的情况。</li><li><strong>最坏情况</strong>：算法执行过程中所需内存空间最多的情况。</li><li><strong>平均情况</strong>：算法执行过程中所需内存空间的平均情况。</li></ul> 
<h4><a id="_813"></a>举例</h4> 
<h5><a id="_814"></a>冒泡排序</h5> 
<ul><li>时间复杂度：最好情况O(n)，最坏情况O(n<sup>2)，平均情况O(n</sup>2)</li><li>空间复杂度：O(1)</li></ul> 
<h5><a id="_817"></a>快速排序</h5> 
<ul><li>时间复杂度：最好情况O(n log n)，最坏情况O(n^2)，平均情况O(n log n)</li><li>空间复杂度：O(log n)（递归栈空间）</li></ul> 
<h5><a id="_820"></a>哈希查找</h5> 
<ul><li>时间复杂度：平均情况O(1)，最坏情况O(n)（哈希表中没有足够的空位，导致大量冲突）</li><li>空间复杂度：O(n)（需要一个大小为n的哈希表）<br> 通过分析算法的时间复杂度和空间复杂度，可以对算法的性能有一个大致的了解，并选择最合适的算法来解决问题。</li></ul> 
<p><img src="https://images2.imgbox.com/09/d0/HcFurziZ_o.png" alt="在这里插入图片描述"><br> 当然，以下是一些常见查找算法的简单代码示例。这些示例将使用Python语言，因为它简单且易于理解。</p> 
<h4><a id="_828"></a>顺序查找</h4> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">sequential_search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">:</span>
            <span class="token keyword">return</span> i  <span class="token comment"># 返回找到元素的索引</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token comment"># 如果没有找到元素，返回-1</span>
<span class="token comment"># 示例</span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>
index <span class="token operator">=</span> sequential_search<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"元素13在索引</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>index<span class="token punctuation">}</span></span><span class="token string">处找到。"</span></span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_840"></a>二分查找</h4> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    low <span class="token operator">=</span> <span class="token number">0</span>
    high <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
    mid <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        <span class="token comment"># 检查中间元素</span>
        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>
            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> x<span class="token punctuation">:</span>
            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> mid  <span class="token comment"># 目标值在中间</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token comment"># 目标值不在数组中</span>
<span class="token comment"># 示例</span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>
index <span class="token operator">=</span> binary_search<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"元素13在索引</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>index<span class="token punctuation">}</span></span><span class="token string">处找到。"</span></span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/99/cf/00B6XTK9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_862"></a>哈希查找</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">HashTable</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>size <span class="token operator">=</span> size
        self<span class="token punctuation">.</span>table <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>size
    <span class="token keyword">def</span> <span class="token function">_hash</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> key <span class="token operator">%</span> self<span class="token punctuation">.</span>size
    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> self<span class="token punctuation">.</span>_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> self<span class="token punctuation">.</span>_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> pair <span class="token keyword">in</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> pair<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
<span class="token comment"># 示例</span>
hash_table <span class="token operator">=</span> HashTable<span class="token punctuation">(</span><span class="token punctuation">)</span>
hash_table<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
hash_table<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>hash_table<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 1</span>
</code></pre> 
<p>这些示例展示了如何使用Python实现和操作基本的查找算法。在实际应用中，这些算法可能会更加复杂，并且需要更多的功能和方法。</p> 
<p>这些算法是计算机科学中的高级算法，它们在解决特定类型的问题时非常有用。下面是对这些算法的简要介绍：</p> 
<h4><a id="Recursion_891"></a>递归（Recursion）</h4> 
<p>递归是一种算法设计技术，其中一个函数调用自身来解决问题。递归通常用于解决那些可以分解为较小版本的问题。</p> 
<h5><a id="_893"></a>示例：计算阶乘</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="Dynamic_Programming_901"></a>动态规划（Dynamic Programming）</h4> 
<p>动态规划是一种将复杂问题分解为更小的、相似的子问题，并存储这些子问题的解，以避免重复计算的方法。<img src="https://images2.imgbox.com/5c/ea/aE4QKGbx_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_904"></a>示例：斐波那契数列</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> n
    a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b
    <span class="token keyword">return</span> b
</code></pre> 
<h4><a id="Greedy_Algorithm_914"></a>贪心算法（Greedy Algorithm）</h4> 
<p>贪心算法是一种在每一步选择中都采取当前状态下最优（即看起来最有利）的选择，从而希望导致全局最优解的算法。</p> 
<h5><a id="_916"></a>示例：零钱兑换</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>coin<span class="token punctuation">,</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token keyword">if</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<h4><a id="Backtracking_926"></a>回溯法（Backtracking）</h4> 
<p>回溯法是一种通过尝试所有可能的解决方案，并在发现无效的解决方案时回退到上一步的方法。</p> 
<h5><a id="_928"></a>示例：八皇后问题</h5> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    board <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">def</span> <span class="token function">isSafe</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> queen<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> queen <span class="token keyword">or</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> queen <span class="token keyword">or</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> row <span class="token operator">==</span> col <span class="token operator">-</span> queen<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> row <span class="token operator">==</span> queen <span class="token operator">-</span> col<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> col <span class="token operator">&gt;=</span> n<span class="token punctuation">:</span>
            solutions<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> isSafe<span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token string">'Q'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Q'</span>
                solve<span class="token punctuation">(</span>col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
                board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    solutions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    solve<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> solutions
</code></pre> 
<p>这些算法在实际编程中非常有用，可以帮助解决各种复杂问题。在实际应用中，这些算法可能会更加复杂，并且需要更多的功能和方法。</p> 
<p>当然，下面我将更详细地介绍这些高级数据结构，并提供相应的代码示例。<br> <img src="https://images2.imgbox.com/85/f0/k3PKqCQ4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Skip_List_955"></a>跳表（Skip List）</h4> 
<p>跳表是一种可以实现快速查找、插入和删除操作的数据结构。它通过在原始链表中插入多个辅助链表来提高查找效率。</p> 
<h5><a id="_957"></a>示例</h5> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">SkipListNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span>forward <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>backward <span class="token operator">=</span> <span class="token boolean">None</span>
<span class="token keyword">class</span> <span class="token class-name">SkipList</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>p <span class="token operator">=</span> p
        self<span class="token punctuation">.</span>head <span class="token operator">=</span> SkipListNode<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>level <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">def</span> <span class="token function">_random_level</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        level <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>p <span class="token keyword">and</span> level <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>level_max<span class="token punctuation">:</span>
            level <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> level
    <span class="token keyword">def</span> <span class="token function">_get_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>head
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>level<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> key<span class="token punctuation">:</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> node
    <span class="token keyword">def</span> <span class="token function">_insert_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> node<span class="token punctuation">.</span>key <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>level <span class="token operator">+=</span> <span class="token number">1</span>
            node<span class="token punctuation">.</span>forward <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>level
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>forward<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
        new_node <span class="token operator">=</span> SkipListNode<span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
        new_node<span class="token punctuation">.</span>backward <span class="token operator">=</span> node
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>level<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> key<span class="token punctuation">:</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                new_node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> node
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                new_node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>backward <span class="token operator">=</span> new_node
            node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new_node
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>forward<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>forward<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> SkipListNode<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>level <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>level<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_random_level<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>_insert_node<span class="token punctuation">(</span>self<span class="token punctuation">.</span>head<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>_get_node<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> node<span class="token punctuation">.</span>key <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>level<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">:</span>
                    node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>backward <span class="token operator">=</span> node<span class="token punctuation">.</span>backward
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>backward<span class="token punctuation">:</span>
                        node<span class="token punctuation">.</span>backward<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                    node<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">while</span> self<span class="token punctuation">.</span>level <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>forward<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>level <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>_get_node<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> node<span class="token punctuation">.</span>key <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val
</code></pre> 
<h4><a id="Splay_Tree_1025"></a>伸展树（Splay Tree）</h4> 
<p>伸展树是一种自平衡二叉搜索树，它通过不断地旋转树中的节点来使频繁访问的节点移动到树的最顶部。</p> 
<h5><a id="_1027"></a>示例</h5> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">SplayTreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
<span class="token keyword">class</span> <span class="token class-name">SplayTree</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token keyword">def</span> <span class="token function">_splay</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">while</span> node<span class="token punctuation">.</span>parent <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token keyword">is</span> node<span class="token punctuation">:</span>
                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
            当然，下面我将继续介绍剩下的数据结构，并提供相应的代码示例。
<span class="token comment">### Trie（前缀树）</span>
Trie是一种树形结构，它通过将字符串中的字符作为节点的键值，来高效地存储和检索字符串。
<span class="token comment">#### 示例</span>
```python
<span class="token keyword">class</span> <span class="token class-name">TrieNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
        self<span class="token punctuation">.</span>is_end_of_word <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token keyword">class</span> <span class="token class-name">Trie</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        <span class="token keyword">for</span> char <span class="token keyword">in</span> word<span class="token punctuation">:</span>
            <span class="token keyword">if</span> char <span class="token keyword">not</span> <span class="token keyword">in</span> node<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>char<span class="token punctuation">]</span> <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>char<span class="token punctuation">]</span>
        node<span class="token punctuation">.</span>is_end_of_word <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        <span class="token keyword">for</span> char <span class="token keyword">in</span> word<span class="token punctuation">:</span>
            <span class="token keyword">if</span> char <span class="token keyword">not</span> <span class="token keyword">in</span> node<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>char<span class="token punctuation">]</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>is_end_of_word
    <span class="token keyword">def</span> <span class="token function">starts_with</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        <span class="token keyword">for</span> char <span class="token keyword">in</span> prefix<span class="token punctuation">:</span>
            <span class="token keyword">if</span> char <span class="token keyword">not</span> <span class="token keyword">in</span> node<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>char<span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre> 
<h4><a id="_1083"></a>后缀树</h4> 
<p>后缀树是一种树形结构，它用于高效地处理后缀表达式和后缀字符串。</p> 
<p>后缀树（Suffix Tree）是一种用于处理字符串的数据结构，它能够高效地解决与字符串匹配相关的问题，如查找子串、计算后缀数组、实现后缀自动机等。以下是后缀树相关的一些知识点：</p> 
<h4><a id="httpsiblogcsdnimgcndirect94773ea058d04bd6bcae4bffe84a97d5png_1087"></a>基本概念<img src="https://images2.imgbox.com/54/82/q4dYcIgu_o.png" alt="在这里插入图片描述"></h4> 
<ol><li><strong>后缀</strong>：字符串中从任意位置开始到末尾的所有字符组成的子串。</li><li><strong>后缀数组</strong>：一个数组，其中的每个元素是一个后缀的索引，使得后缀树中对应的后缀的起始位置为该数组元素的值。</li><li><strong>后缀链接</strong>：在后缀树中，每个节点的所有后缀通过后缀链接相连，形成一个循环链表。</li><li><strong>外部路径</strong>：从根节点到某个后缀的路径，该路径上的节点按字符顺序排列，形成该后缀的编码。</li></ol> 
<h4><a id="_1093"></a>后缀树构建算法</h4> 
<ul><li><strong>后缀树构建</strong>：从空字符串开始，逐渐构建后缀树，每次添加一个字符，直到字符串结束。</li><li><strong>最长公共前后缀（LCP）</strong>：在构建过程中，每个后缀与它之前添加的字符串的最长公共前后缀。</li></ul> 
<h4><a id="_1096"></a>后缀树的应用</h4> 
<p><img src="https://images2.imgbox.com/6a/c1/XUlFEzM1_o.png" alt="在这里插入图片描述"></p> 
<ol><li><strong>子串查找</strong>：通过后缀树可以快速找到字符串中是否包含某个子串。</li><li><strong>字符串匹配</strong>：后缀树可以用于实现字符串匹配算法，如KMP算法。</li><li><strong>后缀数组计算</strong>：后缀树可以直接用于计算后缀数组，不需要额外存储。</li><li><strong>后缀自动机</strong>：后缀树是后缀自动机的一种实现方式，可以用于处理一些复杂的字符串匹配问题。</li></ol> 
<h4><a id="_1103"></a>后缀树的性质</h4> 
<ol><li><strong>高效性</strong>：后缀树可以在多项式时间内构建，并且支持高效的子串查找操作。</li><li><strong>平衡性</strong>：后缀树的高度与字符串长度成对数关系，保证了树的高度不会太高。</li><li><strong>编码特性</strong>：后缀树中的外部路径可以用来编码后缀，从而实现后缀数组的计算。</li></ol> 
<h4><a id="_1107"></a>后缀树的构建方法</h4> 
<ul><li>** Ukkonen 算法**：一种高效的后缀树构建算法，时间复杂度为O(n)。</li><li><strong>线段树构建法</strong>：通过线段树来实现后缀树的构建，时间复杂度为O(n log n)。<br> 后缀树是一种非常有用的数据结构，它在字符串处理和算法竞赛中经常被使用。了解后缀树的相关知识点对于解决与字符串匹配相关的问题非常有帮助。</li></ul> 
<pre><code class="prism language-c">class SuffixTreeNode<span class="token operator">:</span>
    def <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token operator">:</span>
        self<span class="token punctuation">.</span>start <span class="token operator">=</span> start
        self<span class="token punctuation">.</span>end <span class="token operator">=</span> end
        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

class SuffixTree<span class="token operator">:</span>
    def <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token operator">:</span>
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token function">SuffixTreeNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>text <span class="token operator">=</span> text
        self<span class="token punctuation">.</span><span class="token function">construct_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    def <span class="token function">construct_tree</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token keyword">for</span> i in <span class="token function">range</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>
            self<span class="token punctuation">.</span><span class="token function">insert_suffix</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre> 
<pre><code>def insert_suffix(self, start):
    node = self.root
    i = start
    while i &lt; len(self.text):
        if self.text[i] not in node.children:
            node.children[self.text[i]] = SuffixTreeNode(i, len(self.text))
        else:
            child = node.children[self.text[i]]
            j = child.start
            while j &lt;= child.end and self.text[i] == self.text[j]:
                i += 1
                j += 1
            if j &lt;= child.end:
                return
            node = child
            child = node.children[self.text[i]]
            if child is None:
                child = SuffixTreeNode(i, len(self.text))
                node.children[self.text[i]] = child
            node.start = i
            node.end = len(self.text)
            del node.children[self.text[i]]
            node.children[self.text[i]] = child
        i += 1

def search(self, word):
    node = self.root
    i = 0
    while i &lt; len(word):
        if word[i] not in node.children:
            return False
        child = node.children[word[i]]
        j = child.start
        while j &lt;= child.end and word[i] == self.text[j]:
            i += 1
            j += 1
        if j &lt;= child.end:
            return True
        node = child
        i += 1
    return False
</code></pre> 
<h4><a id="BBBB_1172"></a>B树及其变体（B树、B+树、B*树）</h4> 
<p>B树是一种自平衡的多路搜索树，它通过平衡子树来提高查找效率。B+树和B<em>树是B树的变种，它们分别用于索引和磁盘存储。<br> B树及其变体（B树、B+树、B</em>树）是用于磁盘或外部存储的数据结构，它们通过平衡子树来提高查找效率。这些数据结构在数据库索引、文件系统和操作系统中都有广泛的应用。以下是B树及其变体的相关知识点：</p> 
<h4><a id="B_1175"></a>B树</h4> 
<ol><li><strong>定义</strong>：B树是一种自平衡的树形数据结构，用于存储关键字。</li><li><strong>特性</strong>： 
  <ul><li>每个节点最多有m个子节点。</li><li>每个节点至少有[m/2]个子节点（除了根节点和叶子节点）。</li><li>所有叶子节点都在同一层，不包含关键字。</li><li>非叶子节点至少包含[m/2]个关键字。</li></ul> </li><li><strong>操作</strong>： 
  <ul><li>插入：将新关键字插入到B树中。</li><li>删除：从B树中删除一个关键字。</li><li>查找：在B树中查找一个关键字。</li></ul> </li></ol> 
<h4><a id="B_1186"></a>B+树</h4> 
<ol><li><strong>定义</strong>：B+树是B树的变种，它在B树的基础上对节点进行了扩展。</li><li><strong>特性</strong>： 
  <ul><li>所有的关键字都存储在叶子节点中。</li><li>非叶子节点只包含关键字信息，不包含实际的数据。</li><li>叶子节点包含所有的关键字信息，以及指向含有这些关键字记录的指针。</li><li>所有的叶子节点都位于同一层，且叶子节点之间有指针连接。</li></ul> </li><li><strong>操作</strong>： 
  <ul><li>插入：与B树类似，但所有关键字都存储在叶子节点中。</li><li>删除：与B树类似，但需要处理指针连接。</li><li>查找：与B树类似，但所有查找操作都终止于叶子节点。<br> <img src="https://images2.imgbox.com/d9/64/Ett0e5zy_o.png" alt="在这里插入图片描述"></li></ul> </li></ol> 
<h4><a id="B_1198"></a>B*树</h4> 
<ol><li><strong>定义</strong>：B*树是B+树的变种，它引入了额外的平衡条件。</li><li><strong>特性</strong>： 
  <ul><li>每个节点至少有[m/2]个关键字。</li><li>所有叶子节点都在同一层，不包含关键字。</li><li>非叶子节点至少包含[m/2]个关键字。</li><li>所有非叶子节点的指针都指向叶子节点。</li></ul> </li><li><strong>操作</strong>： 
  <ul><li>插入：与B树类似，但需要保持更多的平衡条件。</li><li>删除：与B树类似，但需要处理更多的平衡条件。</li><li>查找：与B树类似，但所有查找操作都终止于叶子节点。</li></ul> </li></ol> 
<h4><a id="_1209"></a>应用</h4> 
<ol><li><strong>数据库索引</strong>：B树及其变体用于实现数据库索引，以加速数据的查找和排序。</li><li><strong>文件系统</strong>：在文件系统中，B树及其变体用于文件和目录的存储和检索。</li></ol> 
<h4><a id="_1212"></a>优点</h4> 
<ul><li><strong>平衡性</strong>：B树及其变体通过平衡子树来提高查找效率。</li><li><strong>减少磁盘I/O</strong>：通过将数据分散存储在多个节点中，减少了磁盘I/O操作。</li></ul> 
<h4><a id="_1215"></a>缺点</h4> 
<ul><li><strong>空间复杂度</strong>：B树及其变体需要额外的空间来存储指针。</li><li><strong>插入和删除操作复杂</strong>：在B树及其变体中，插入和删除操作可能需要调整树的结构，以保持树的平衡。<br> 了解B树及其变体的知识对于理解数据库索引和文件系统的工作原理非常有帮助。在实际应用中，选择哪种树结构取决于具体的需求和性能考虑。<br> 当然，下面我将提供一些B树及其变体的代码示例。</li></ul> 
<h4><a id="B_1220"></a>B树</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">BTreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> leaf<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>leaf <span class="token operator">=</span> leaf
        self<span class="token punctuation">.</span>keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">class</span> <span class="token class-name">BTree</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> BTreeNode<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>t <span class="token operator">=</span> t
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>root<span class="token punctuation">.</span>leaf<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>root <span class="token operator">=</span> self<span class="token punctuation">.</span>_split_child<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>_search_key<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            self<span class="token punctuation">.</span>root <span class="token operator">=</span> self<span class="token punctuation">.</span>_insert_non_full<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">_search_key</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> x <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>keys<span class="token punctuation">)</span> <span class="token keyword">and</span> key <span class="token operator">&gt;</span> x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>keys<span class="token punctuation">)</span> <span class="token keyword">and</span> key <span class="token operator">==</span> x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> x<span class="token punctuation">.</span>leaf<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_search_key<span class="token punctuation">(</span>x<span class="token punctuation">.</span>child<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">_insert_non_full</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        i <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>keys<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">while</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token keyword">and</span> key <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            i <span class="token operator">-=</span> <span class="token number">1</span>
        x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>child<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>_split_child<span class="token punctuation">(</span>x<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> x
    <span class="token keyword">def</span> <span class="token function">_split_child</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> i<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        y <span class="token operator">=</span> BTreeNode<span class="token punctuation">(</span>leaf<span class="token operator">=</span>x<span class="token punctuation">.</span>leaf<span class="token punctuation">)</span>
        x<span class="token punctuation">.</span>child<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>
        x<span class="token punctuation">.</span>keys<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        y<span class="token punctuation">.</span>keys <span class="token operator">=</span> x<span class="token punctuation">.</span>child<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">[</span>self<span class="token punctuation">.</span>t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
        x<span class="token punctuation">.</span>child<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>keys <span class="token operator">=</span> x<span class="token punctuation">.</span>child<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">[</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
        y<span class="token punctuation">.</span>child <span class="token operator">=</span> x<span class="token punctuation">.</span>child<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>child
        x<span class="token punctuation">.</span>child<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> x
</code></pre> 
<h4><a id="B_1268"></a>B+树</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">BPlusTreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> leaf<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>leaf <span class="token operator">=</span> leaf
        self<span class="token punctuation">.</span>keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">class</span> <span class="token class-name">BPlusTree</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> BPlusTreeNode<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>t <span class="token operator">=</span> t
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>root<span class="token punctuation">.</span>leaf<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>root <span class="token operator">=</span> self<span class="token punctuation">.</span>_split_child<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>_search_key<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            self<span class="token punctuation">.</span>root <span class="token operator">=</span> self<span class="token punctuation">.</span>_insert_non_full<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">_search_key</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> x <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>keys<span class="token punctuation">)</span> <span class="token keyword">and</span> key <span class="token operator">&gt;</span> x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>keys<span class="token punctuation">)</span> <span class="token keyword">and</span> key <span class="token operator">==</span> x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> x<span class="token punctuation">.</span>leaf<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_search_key<span class="token punctuation">(</span>x<span class="token punctuation">.</span>child<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">_insert_non_full</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        i <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>keys<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">while</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token keyword">and</span> key <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            i <span class="token operator">-=</span> <span class="token number">1</span>
        x<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>child<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>_split_child<span class="token punctuation">(</span>x<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> x
    <span class="token keyword">def</span> <span class="token function">_split_child</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> i<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        y <span class="token operator">=</span> BPlusTreeNode<span class="token punctuation">(</span>leaf<span class="token operator">=</span>x<span class="token punctuation">.</span>leaf<span class="token punctuation">)</span>
        x<span class="token punctuation">.</span>child<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>
        x<span class="token punctuation">.</span>keys<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        y<span class="token punctuation">.</span>keys <span class="token operator">=</span> x<span class="token punctuation">.</span>child<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

</code></pre> 
<h4><a id="_1315"></a>斐波那契堆</h4> 
<p>斐波那契堆是一种自平衡堆，它通过斐波那契数列的性质来实现高效的插入和删除操作。<br> <img src="https://images2.imgbox.com/59/72/QBPIpStk_o.png" alt="在这里插入图片描述"></p> 
<p>斐波那契堆（Fibonacci Heap）是一种用于实现优先队列的数据结构，它在许多算法中都有应用，尤其是在需要频繁进行合并和删除最小元素的场景中。斐波那契堆以其高效的合并和提取最小元素操作而著称。以下是斐波那契堆的相关知识点：</p> 
<h4><a id="_1322"></a>基本概念</h4> 
<ol><li><strong>节点</strong>：斐波那契堆中的每个元素都对应一个节点。</li><li><strong>子树</strong>：每个节点都可能有一个或多个子节点。</li><li><strong>根列表</strong>：斐波那契堆由一个或多个根节点组成，根节点不包含在父节点的子树中。</li><li><strong>最小堆属性</strong>：斐波那契堆总是保持一个最小堆属性，即堆中任意节点的父节点都大于或等于它。</li><li><strong>合并操作</strong>：合并两个斐波那契堆，合并后的新堆包含原堆的所有元素。</li><li><strong>提取最小元素</strong>：从堆中提取最小元素，并保持堆的性质不变。</li></ol> 
<h4><a id="_1329"></a>性质</h4> 
<ol><li><strong>高效性</strong>：斐波那契堆的合并和提取最小元素操作的时间复杂度都是O(1)。</li><li><strong>非最小堆属性</strong>：斐波那契堆不总是保持最小堆属性，但在进行插入、删除最小元素和合并操作后，可以通过维护最小堆属性来优化提取最小元素操作。</li><li><strong>非平衡性</strong>：斐波那契堆的节点数和子树数可能不成比例，这使得它在某些情况下比二叉堆更有效率。</li></ol> 
<h4><a id="_1333"></a>操作</h4> 
<p><img src="https://images2.imgbox.com/d5/a7/d51UHk9m_o.png" alt="在这里插入图片描述"></p> 
<ol><li><strong>插入</strong>：将新节点插入到堆中，保持堆的性质不变。</li><li><strong>删除最小元素</strong>：提取堆中的最小元素，并重新组织堆以保持性质。</li><li><strong>合并</strong>：将两个斐波那契堆合并为一个堆。</li></ol> 
<h4><a id="_1339"></a>应用</h4> 
<p>斐波那契堆在各种算法中都有应用，特别是在需要频繁进行合并和删除最小元素的场景中。例如，在Dijkstra算法中，斐波那契堆可以用来高效地找到最小路径权重。</p> 
<h4><a id="_1341"></a>实现</h4> 
<p>斐波那契堆的实现相对复杂，涉及多种操作和属性维护。常见的实现包括：</p> 
<ul><li><strong>斐波那契堆的合并</strong>：通过链接（linking）和合并（consolidation）操作来实现。</li><li><strong>斐波那契堆的提取最小元素</strong>：通过旋转（rotating）和合并（consolidation）操作来实现。<br> 斐波那契堆是一种高效的数据结构，但它的实现细节较为复杂，需要对堆的操作和性质有深入的理解。在实际应用中，斐波那契堆可以提供比其他优先队列实现（如二叉堆）更优的性能。</li></ul> 
<p>斐波那契堆（Fibonacci Heap）和二叉堆（Binary Heap）都是用于实现优先队列的数据结构，但它们在某些操作上具有不同的性能特点。斐波那契堆的优势主要体现在以下几个方面：</p> 
<ol><li><strong>合并操作</strong>： 
  <ul><li><strong>斐波那契堆</strong>：合并两个斐波那契堆的时间复杂度是O(1)，这是因为斐波那契堆使用了一种称为“链接”（linking）的简单操作，该操作可以将两个堆合并成一个堆，而不需要重新排序。</li><li><strong>二叉堆</strong>：合并两个二叉堆的时间复杂度是O(n)，因为在合并时需要将一个堆中的所有元素插入到另一个堆中，这通常涉及到元素的下沉和上浮操作，以保持堆的性质。</li></ul> </li><li><strong>提取最小元素</strong>： 
  <ul><li><strong>斐波那契堆</strong>：提取最小元素的时间复杂度是O(1)，这是因为斐波那契堆使用了一种称为“提取最小元素”（extract-min）的简单操作，该操作可以在常数时间内完成。</li><li><strong>二叉堆</strong>：提取最小元素的时间复杂度是O(log n)，因为在提取最小元素时需要进行元素的下沉操作，以保持堆的性质。</li></ul> </li><li><strong>插入操作</strong>： 
  <ul><li><strong>斐波那契堆</strong>：插入操作的时间复杂度是O(1)，这是因为斐波那契堆使用了一种称为“插入”（insert）的简单操作，该操作可以在常数时间内完成。</li><li><strong>二叉堆</strong>：插入操作的时间复杂度也是O(1)，因为二叉堆的插入操作只需要将新元素添加到堆的末尾。</li></ul> </li><li><strong>删除操作</strong>： 
  <ul><li><strong>斐波那契堆</strong>：删除操作的时间复杂度是O(1)，这是因为斐波那契堆使用了一种称为“删除”（delete）的简单操作，该操作可以在常数时间内完成。</li><li><strong>二叉堆</strong>：删除操作的时间复杂度是O(log n)，因为在删除操作中需要找到待删除元素的父节点，并进行下沉和上浮操作，以保持堆的性质。<br> 总的来说，斐波那契堆在合并和提取最小元素操作上具有明显的优势，这些操作在许多算法中都是关键步骤。然而，二叉堆在插入和删除操作上具有更简单的实现，并且在实际应用中可能更加直观和易于理解。因此，选择哪种堆取决于具体的应用场景和性能需求。<br> 斐波那契堆的实现相对复杂，因为它们涉及多种操作和属性维护。下面是一个简单的斐波那契堆的Python代码示例，展示了如何实现斐波那契堆的基本操作。</li></ul> </li></ol> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">FibonacciHeapNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key
        self<span class="token punctuation">.</span>degree <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>mark <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token keyword">class</span> <span class="token class-name">FibonacciHeap</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>min_node <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>trees <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> FibonacciHeapNode<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>min_node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>min_node <span class="token operator">=</span> node
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>trees<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>min_node<span class="token punctuation">]</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>trees<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">extract_min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>min_node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        min_node <span class="token operator">=</span> self<span class="token punctuation">.</span>min_node
        <span class="token keyword">if</span> min_node<span class="token punctuation">.</span>child<span class="token punctuation">:</span>
            <span class="token keyword">for</span> child <span class="token keyword">in</span> min_node<span class="token punctuation">.</span>child<span class="token punctuation">:</span>
                child<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
                self<span class="token punctuation">.</span>trees<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> min_node<span class="token punctuation">.</span>parent<span class="token punctuation">:</span>
            min_node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>child<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>min_node<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> min_node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>child<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>trees<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>min_node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>child<span class="token punctuation">)</span>
        <span class="token keyword">if</span> min_node <span class="token keyword">in</span> self<span class="token punctuation">.</span>nodes<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>min_node<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>min_node<span class="token punctuation">.</span>child<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>min_node <span class="token operator">=</span> self<span class="token punctuation">.</span>min_node<span class="token punctuation">.</span>child<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>min_node <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>consolidate<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> min_node<span class="token punctuation">.</span>key
    <span class="token keyword">def</span> <span class="token function">consolidate</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        trees <span class="token operator">=</span> self<span class="token punctuation">.</span>trees
        <span class="token keyword">while</span> trees<span class="token punctuation">:</span>
            node <span class="token operator">=</span> trees<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>trees<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                trees<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> tree <span class="token keyword">in</span> trees<span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                        <span class="token keyword">continue</span>
                    node <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> tree<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">:</span>
                        node<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> node
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>degree <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
                        <span class="token keyword">break</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        node <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
                    <span class="token keyword">for</span> child <span class="token keyword">in</span> tree<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                        child<span class="token punctuation">.</span>parent <span class="token operator">=</span> node
                        node<span class="token punctuation">.</span>child<span class="token punctuation">.</span>append<span class="token punctuation">(</span>child<span class="token punctuation">)</span>
                    node<span class="token punctuation">.</span>degree <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
                    node<span class="token punctuation">.</span>child<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
                    trees<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>tree<span class="token punctuation">)</span>
        <span class="token keyword">for</span> tree <span class="token keyword">in</span> trees<span class="token punctuation">:</span>
            node <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            <span class="token keyword">while</span> node<span class="token punctuation">.</span>child<span class="token punctuation">:</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>child<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>min_node <span class="token operator">=</span> node
            self<span class="token punctuation">.</span>trees<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">decrease_key</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> new_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> new_key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        node<span class="token punctuation">.</span>key <span class="token operator">=</span> new_key
        parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent
        <span class="token keyword">if</span> parent <span class="token keyword">and</span> node<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> parent<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>cascading_cut<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
        <span class="token keyword">if</span> node<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>min_node<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>min_node <span class="token operator">=</span> node
    <span class="token keyword">def</span> <span class="token function">cut</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
        parent<span class="token punctuation">.</span>child<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>trees<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span>
        node<span class="token punctuation">.</span>degree <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">def</span> <span class="token function">cascading_cut</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent
        <span class="token keyword">if</span> parent<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>cascading_cut<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>other<span class="token punctuation">.</span>nodes<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>trees<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>other<span class="token punctuation">.</span>trees<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>min_node <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> other<span class="token punctuation">.</span>min_node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>min_node <span class="token operator">=</span> self<span class="token punctuation">.</span>nodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>min_node <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">else</span> other<span class="token punctuation">.</span>min_node
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>trees<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>min_node<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>        self.trees.append([other.min_node])
        if self.min_node.key &gt; other.min_node.key:
            self.min_node = other.min_node
        self.consolidate()
def delete(self, node):
    self.decrease_key(node, -float('inf'))
    self.extract_min()
def find_min(self):
    return self.min_node.key if self.min_node else None
</code></pre> 
<h2><a id="Example_usage_1470"></a>Example usage:</h2> 
<p>fib_heap = FibonacciHeap()<br> fib_heap.insert(10)<br> fib_heap.insert(5)<br> fib_heap.insert(15)<br> print(fib_heap.find_min()) # Output: 5<br> min_key = fib_heap.extract_min()<br> print(min_key) # Output: 5<br> print(fib_heap.find_min()) # Output: 10<br> fib_heap.decrease_key(fib_heap.nodes[1], 8)<br> print(fib_heap.find_min()) # Output: 8<br> ``<br> 这个代码示例提供了一个简单的斐波那契堆实现，包括插入、提取最小元素、减少键值、合并和删除操作。请注意，这个实现可能不是最优的，并且可能需要进一步的优化和错误检查。在实际应用中，斐波那契堆的实现会更加复杂，并且需要更多的功能和方法来确保堆的性质和操作的效率。</p> 
<p><img src="https://images2.imgbox.com/ab/69/oiFe15qy_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Pairing_Heap_1495"></a>配对堆（Pairing Heap）</h4> 
<p>配对堆是一种堆数据结构，它通过将相邻的堆合并来实现高效的插入和删除操作。<br> 配对堆（Pairing Heap）是一种堆数据结构，它使用了一种称为“合并”（pairing）的操作来保持堆的性质。配对堆的设计目标是在插入和删除最小元素操作上具有较高的效率。以下是配对堆的相关知识点：</p> 
<h4><a id="_1498"></a>基本概念</h4> 
<ol><li><strong>节点</strong>：配对堆中的每个元素都对应一个节点。</li><li><strong>根列表</strong>：配对堆由一个或多个根节点组成，根节点不包含在父节点的子树中。</li><li><strong>最小堆属性</strong>：配对堆总是保持一个最小堆属性，即堆中任意节点的父节点都大于或等于它。</li><li><strong>合并操作</strong>：配对堆通过合并两个堆来实现合并操作，合并后的新堆包含原堆的所有元素。</li><li><strong>插入操作</strong>：将新节点插入到堆中，保持堆的性质不变。</li><li><strong>删除最小元素</strong>：从堆中删除最小元素，并重新组织堆以保持性质。</li></ol> 
<h4><a id="_1505"></a>性质</h4> 
<ol><li><strong>高效性</strong>：配对堆的合并和提取最小元素操作的时间复杂度都是O(1)。</li><li><strong>非最小堆属性</strong>：配对堆不总是保持最小堆属性，但在进行插入、删除最小元素和合并操作后，可以通过维护最小堆属性来优化提取最小元素操作。</li><li><strong>非平衡性</strong>：配对堆的节点数和子树数可能不成比例，这使得它在某些情况下比二叉堆更有效率。</li><li><img src="https://images2.imgbox.com/7e/4e/fGneTAtp_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="_1511"></a>操作</h4> 
<ol><li><strong>插入</strong>：将新节点插入到堆中，保持堆的性质不变。</li><li><strong>删除最小元素</strong>：从堆中删除最小元素，并重新组织堆以保持性质。</li><li><strong>合并</strong>：将两个配对堆合并为一个堆。</li></ol> 
<h4><a id="_1515"></a>应用</h4> 
<p><img src="https://images2.imgbox.com/0e/7e/q1D7kK7H_o.png" alt="在这里插入图片描述"></p> 
<p>配对堆在需要频繁进行合并和删除最小元素的场景中非常有用。例如，在Dijkstra算法中，配对堆可以用来高效地找到最小路径权重。</p> 
<h4><a id="_1519"></a>实现</h4> 
<p>配对堆的实现相对简单，涉及的主要操作包括：</p> 
<ul><li><strong>插入</strong>：通过将新节点添加到根列表的末尾来实现。</li><li><strong>删除最小元素</strong>：通过将最小元素的父节点设置为None，并将最小元素的子节点移动到根列表的末尾来实现。</li><li><strong>合并</strong>：通过将一个堆的根节点设置为另一个堆的根节点的子节点来实现。<br> 配对堆是一种高效的数据结构，但它的实现细节较为简单，需要对堆的操作和性质有深入的理解。在实际应用中，配对堆可以提供比其他优先队列实现（如二叉堆）更优的性能。</li></ul> 
<p>配对堆（Pairing Heap）的实现相对简单，以下是一个简单的Python代码示例，展示了如何实现配对堆的基本操作。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">PairingHeapNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key
        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>
<span class="token keyword">class</span> <span class="token class-name">PairingHeap</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        new_node <span class="token operator">=</span> PairingHeapNode<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>root <span class="token operator">=</span> new_node
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> new_node
            new_node<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>root
            self<span class="token punctuation">.</span>root <span class="token operator">=</span> new_node
    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other_heap<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> other_heap<span class="token punctuation">.</span>root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>root <span class="token operator">=</span> other_heap<span class="token punctuation">.</span>root
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> other_heap<span class="token punctuation">.</span>root
            other_heap<span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>root
            self<span class="token punctuation">.</span>root <span class="token operator">=</span> self<span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token builtin">next</span>
    <span class="token keyword">def</span> <span class="token function">find_min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        min_node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        <span class="token keyword">while</span> min_node<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> min_node<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> min_node<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
                min_node <span class="token operator">=</span> min_node<span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">return</span> min_node<span class="token punctuation">.</span>key
    <span class="token keyword">def</span> <span class="token function">extract_min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        min_node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> min_node<span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>root <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>
        min_node<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">return</span> min_node<span class="token punctuation">.</span>key
    <span class="token keyword">def</span> <span class="token function">decrease_key</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> new_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> new_key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        node<span class="token punctuation">.</span>key <span class="token operator">=</span> new_key
        parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent
        <span class="token keyword">if</span> parent <span class="token keyword">and</span> node<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> parent<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>cascading_cut<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
        <span class="token keyword">if</span> node<span class="token punctuation">.</span>child<span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>child<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
            self<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>PairingHeap<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">cut</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">:</span>
        parent<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token boolean">None</span> <span class="token keyword">if</span> parent<span class="token punctuation">.</span>child <span class="token operator">==</span> node <span class="token keyword">else</span> parent<span class="token punctuation">.</span>child<span class="token punctuation">.</span><span class="token builtin">next</span>
        node<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>PairingHeap<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">cascading_cut</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent
        <span class="token keyword">if</span> parent<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>cascading_cut<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
<span class="token comment"># Example usage:</span>
heap <span class="token operator">=</span> PairingHeap<span class="token punctuation">(</span><span class="token punctuation">)</span>
heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>find_min<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># Output: 5</span>
min_key <span class="token operator">=</span> heap<span class="token punctuation">.</span>extract_min<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>min_key<span class="token punctuation">)</span>  <span class="token comment"># Output: 5</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>find_min<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># Output: 10</span>
heap<span class="token punctuation">.</span>decrease_key<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>root<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>find_min<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># Output: 8</span>
</code></pre> 
<p>这个代码示例提供了一个简单的配对堆实现，包括插入、提取最小元素、减少键值和合并操作。请注意，这个实现可能不是最优的，并且可能需要进一步的优化和错误检查。在实际应用中，配对堆的实现会更加复杂，并且需要更多的功能和方法来确保堆的性质和操作的效率。<br> <img src="https://images2.imgbox.com/09/67/hqW4LXVW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Bloom_Filter_1606"></a>布隆过滤器（Bloom Filter）</h4> 
<p>布隆过滤器是一种概率数据结构，它用于检测一个元素是否属于一个集合。</p> 
<h4><a id="Counting_Bloom_Filter_1608"></a>计数位数组（Counting Bloom Filter）</h4> 
<p>计数位数组是一种改进的布隆过滤器，它通过维护一个计数数组来提高检测的准确性。</p> 
<h4><a id="Cuckoo_1610"></a>Cuckoo哈希</h4> 
<p>Cuckoo哈希是一种哈希表实现，它通过多次哈希和重新插入来处理哈希冲突。</p> 
<h4><a id="LSMLogStructured_MergeTree_1612"></a>LSM树（Log-Structured Merge-Tree）</h4> 
<p>LSM树是一种用于处理大量数据的树形结构，它通过将数据分为多个层次来提高处理效率。<br> 这些代码示例展示了如何使用Python实现和操作这些高级数据结构。在实际应用中，这些数据结构可能会更加复杂，并且需要更多的功能和方法。</p> 
<p><img src="https://images2.imgbox.com/20/38/PTsNz7xW_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60d6ec3b62597608f3b538a7acf7172d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java全栈解密：从JVM内存管理到Spring框架，揭秘垃圾回收、类加载机制与Web开发精髓的全方位旅程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df48e663ee2fa7c721c1af51b3313d2a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构初阶】队列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>