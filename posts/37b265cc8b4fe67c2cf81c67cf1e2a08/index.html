<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker数据卷和资源控制 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/37b265cc8b4fe67c2cf81c67cf1e2a08/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="docker数据卷和资源控制">
  <meta property="og:description" content="目录
数据卷
实现数据卷
宿主机和容器之间进行数据共享
容器与容器之间进行数据共享
容器互联
docker容器的资源控制
cpu
1.设置cpu资源控制（比重）
2. 设置cpu的资源占用比（权重）
3.设置容器绑定cpu
内存
1.内存限制
磁盘
1.磁盘读写速度的限制
2.磁盘的读写次数限制
清理docker的磁盘空间的命令
练习
数据卷 数据卷的目的：
1. 实现容器和宿主机之间数据共享：数据卷又叫挂载卷，就是把容器内的目录和宿主机的目录进行挂载，实现数据文件共享
2. 为了保证数据的持久化：容器的生命周期有限，一旦重启，所有对容器内部文件数据的修改以及保存的数据都会被初始化，所以为了防止数据修饰，重要的组件一定会做数据卷。
实现数据卷 宿主机和容器之间进行数据共享 创建宿主机与容器之间的数据卷
docker run -itd --name test1 -v /opt/test1:/opt/test2 centos:7 /bin/bash
-v 指定
注意点：
1. 左边的test1是宿主机目录 ，右边的test2是容器内的目录
2. 加不加 / ，都是目录，而不是文件。如果不存在，宿主机和容器都会自动创建目录
3. 以宿主机的目录为标准，同步的是宿主机目录的内容到容器内
4. 挂载之后，容器内的目录的权限默认是读写权限都有
设置容器内的数据卷目录只读权限
docker run -itd --name test1 -v /opt/test1:/opt/test2:ro centos:7 /bin/bash
容器与容器之间进行数据共享 容器之间会需要共享数据，最简单的方法就是使用数据卷容器。可以提供容器内的一个目录，专门用来供其他容器进行挂载。
docker run -itd --name test1 -v /opt/test1 -v /opt/test2 centos:7 /bin/bash 在容器内部创建两个目录">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-14T17:23:23+08:00">
    <meta property="article:modified_time" content="2024-08-14T17:23:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker数据卷和资源控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%95%B0%E6%8D%AE%E5%8D%B7-toc" style="margin-left:0px;"><a href="#%E6%95%B0%E6%8D%AE%E5%8D%B7" rel="nofollow">数据卷</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8D%B7-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8D%B7" rel="nofollow">实现数据卷</a></p> 
<p id="%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%92%8C%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-toc" style="margin-left:80px;"><a href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%92%8C%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB" rel="nofollow">宿主机和容器之间进行数据共享</a></p> 
<p id="%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-toc" style="margin-left:80px;"><a href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB" rel="nofollow">容器与容器之间进行数据共享</a></p> 
<p id="%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94-toc" style="margin-left:80px;"><a href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94" rel="nofollow">容器互联</a></p> 
<p id="docker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#docker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6" rel="nofollow">docker容器的资源控制</a></p> 
<p id="cpu-toc" style="margin-left:40px;"><a href="#cpu" rel="nofollow">cpu</a></p> 
<p id="1.%E8%AE%BE%E7%BD%AEcpu%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%EF%BC%88%E6%AF%94%E9%87%8D%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.%E8%AE%BE%E7%BD%AEcpu%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%EF%BC%88%E6%AF%94%E9%87%8D%EF%BC%89" rel="nofollow">1.设置cpu资源控制（比重）</a></p> 
<p id="2.%20%E8%AE%BE%E7%BD%AEcpu%E7%9A%84%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%AF%94%EF%BC%88%E6%9D%83%E9%87%8D%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.%20%E8%AE%BE%E7%BD%AEcpu%E7%9A%84%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%AF%94%EF%BC%88%E6%9D%83%E9%87%8D%EF%BC%89" rel="nofollow">2. 设置cpu的资源占用比（权重）</a></p> 
<p id="3.%E8%AE%BE%E7%BD%AE%E5%AE%B9%E5%99%A8%E7%BB%91%E5%AE%9Acpu-toc" style="margin-left:80px;"><a href="#3.%E8%AE%BE%E7%BD%AE%E5%AE%B9%E5%99%A8%E7%BB%91%E5%AE%9Acpu" rel="nofollow">3.设置容器绑定cpu</a></p> 
<p id="%E5%86%85%E5%AD%98-toc" style="margin-left:40px;"><a href="#%E5%86%85%E5%AD%98" rel="nofollow">内存</a></p> 
<p id="1.%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6-toc" style="margin-left:80px;"><a href="#1.%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6" rel="nofollow">1.内存限制</a></p> 
<p id="%E7%A3%81%E7%9B%98-toc" style="margin-left:40px;"><a href="#%E7%A3%81%E7%9B%98" rel="nofollow">磁盘</a></p> 
<p id="1.%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E7%9A%84%E9%99%90%E5%88%B6-toc" style="margin-left:80px;"><a href="#1.%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E7%9A%84%E9%99%90%E5%88%B6" rel="nofollow">1.磁盘读写速度的限制</a></p> 
<p id="2.%E7%A3%81%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6-toc" style="margin-left:80px;"><a href="#2.%E7%A3%81%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6" rel="nofollow">2.磁盘的读写次数限制</a></p> 
<p id="%E6%B8%85%E7%90%86docker%E7%9A%84%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%91%BD%E4%BB%A4-toc" style="margin-left:0px;"><a href="#%E6%B8%85%E7%90%86docker%E7%9A%84%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%91%BD%E4%BB%A4" rel="nofollow">清理docker的磁盘空间的命令</a></p> 
<p id="%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#%E7%BB%83%E4%B9%A0" rel="nofollow">练习</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>数据卷</h2> 
<p>数据卷的目的：</p> 
<p>1. 实现容器和宿主机之间数据共享：数据卷又叫挂载卷，就是把容器内的目录和宿主机的目录进行挂载，实现数据文件共享</p> 
<p>2. 为了保证数据的持久化：容器的生命周期有限，一旦重启，所有对容器内部文件数据的修改以及保存的数据都会被初始化，所以为了防止数据修饰，重要的组件一定会做数据卷。</p> 
<h3 id="%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8D%B7">实现数据卷</h3> 
<h4 id="%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%92%8C%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB">宿主机和容器之间进行数据共享</h4> 
<p>创建宿主机与容器之间的数据卷</p> 
<p>docker run -itd --name test1 -v /opt/test1:/opt/test2 centos:7 /bin/bash</p> 
<p>-v 指定</p> 
<p>注意点：</p> 
<p>1. 左边的test1是宿主机目录 ，右边的test2是容器内的目录</p> 
<p>2. 加不加 / ，都是目录，而不是文件。如果不存在，宿主机和容器都会自动创建目录</p> 
<p>3. 以宿主机的目录为标准，同步的是宿主机目录的内容到容器内</p> 
<p>4. 挂载之后，容器内的目录的权限默认是读写权限都有</p> 
<p>设置容器内的数据卷目录只读权限</p> 
<p>docker run -itd --name test1 -v /opt/test1:/opt/test2:ro centos:7 /bin/bash</p> 
<h4 id="%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB">容器与容器之间进行数据共享</h4> 
<p>容器之间会需要共享数据，最简单的方法就是使用数据卷容器。可以提供容器内的一个目录，专门用来供其他容器进行挂载。</p> 
<p>docker run -itd --name test1 -v /opt/test1 -v /opt/test2 centos:7 /bin/bash   在容器内部创建两个目录</p> 
<p>docker run -itd --name test2 <span style="color:#fe2c24;">--volumes-from</span> test1 centos:7 /bin/bash  容器与容器数据共享</p> 
<h4 id="%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94">容器互联</h4> 
<p>容器与容器之间建立一条专门的网络通道，容器与容器之间通过这个通道互相通信。</p> 
<p>建立通道之后，容器之间可以通过容器名进行通信，容器之间不需要暴露端口，也不依赖宿主机的ip。在容器内部可以通过容器名直接访问另一个容器，可以简化容器之间的连接配置。</p> 
<p>指定网络，我们要先创建自定义网络。</p> 
<p>docker network create --subent=192.168.10.0/24 --opt "com.docker.network.bridge.name"="docker2" xy102     自定义网络</p> 
<p>docker run -itd --name n1 --network=xy102 nginx:1.22 </p> 
<p>docker run -itd --name n2 --network=xy102 nginx:1.22</p> 
<p>docker exec -it n1 bash 进入容器</p> 
<p>然后两个容器可以互相访问容器名</p> 
<h2 id="docker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6">docker容器的资源控制</h2> 
<p>docker通过cgroup来控制容器的资源配额，包括cpu、内存、磁盘三大方面。</p> 
<p>cgroup全称control group，它是Linux内核提供的可以限制、记录、隔离进程所使用的物理资源（cpu、内存、磁盘IO）的机制</p> 
<h3 id="cpu">cpu</h3> 
<h4 id="1.%E8%AE%BE%E7%BD%AEcpu%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%EF%BC%88%E6%AF%94%E9%87%8D%EF%BC%89" style="background-color:transparent;">1.设置cpu资源控制（比重）</h4> 
<p>是按进程占用cpu的时间来进行计算</p> 
<p>查看cpu限制步骤：</p> 
<p>首先docker ps 查看容器的container id并复制 </p> 
<p>然后cd /sys/fs/cgroup/cpu/docker/</p> 
<p>然后cd 把上面的container id复制过来并用tab键补齐</p> 
<p>cd 246fb9e648f7893e5db24b5ced6a4136044bc6c8b3a7d3a6fa429e2861cd3dc1/</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a4/7b/4caf7WsS_o.png"></p> 
<p>cat cpu.cfs_quota_us 显示-1</p> 
<p>表示系统没有对该进程进行cpu的限制</p> 
<p>cat cpu.cfs_period_us  显示100000微妙=100毫秒=0.1秒</p> 
<p>在每个使用cpu的周期内，容器可以用指定的比例使用cpu时间</p> 
<p></p> 
<p>设置cpu资源控制步骤</p> 
<p>设置cpu限制命令（比重，默认100000就是100%）</p> 
<p>docker run -itd --name test1 --cpu-quota 50000 -v /etc/yum.repos.d/:/etc/yum.repos.d/ centos:7 /bin/bash</p> 
<p>然后docker exec -it test1 bash 进入容器</p> 
<p>安装epel源 yum -y install epel-release （如果宿主机有epel需要先删掉）</p> 
<p>注：如果要删，可以先 rm -rf *删除，然后执行docker cp /etc/yum.repos.d/Centos-7.repo test1:/etc/yum.repos.d/ 远程复制 然后再下载epel源</p> 
<p> 安装模拟软件 yum -y install stress</p> 
<p>模拟cpu的压力 stress -c 4 </p> 
<p>注：这里每次模拟都需要重新都安装一遍</p> 
<p>然后top查看  或者 docker top test1</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b7/1e/4Md07fjO_o.png"></p> 
<p>pid：容器内的进程在宿主机上的进程号，ppid：在容器内部的进程号</p> 
<h4 id="2.%20%E8%AE%BE%E7%BD%AEcpu%E7%9A%84%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%AF%94%EF%BC%88%E6%9D%83%E9%87%8D%EF%BC%89">2. 设置cpu的资源占用比（权重）</h4> 
<p>--cpu-shares 默认值是1024，如果要设置，必须是1024的倍数或者1024的除数</p> 
<p>实验步骤：</p> 
<p>docker run -itd --name test2 --cpu-shares 512 -v /etc/yum.repos.d/:/etc/yum.repos.d/ centos:7 /bin/bash</p> 
<p>然后docker exec -it test1 bash 进入容器</p> 
<p>安装epel源 yum -y install epel-release （如果宿主机有epel需要先删掉）</p> 
<p>注：如果要删，可以先 rm -rf *删除，然后执行docker cp /etc/yum.repos.d/Centos-7.repo test1:/etc/yum.repos.d/ 远程复制 然后再下载epel源</p> 
<p> 安装模拟软件 yum -y install stress</p> 
<p>模拟cpu的压力 stress -c 4 </p> 
<p>注：这里每次模拟都需要重新都安装一遍</p> 
<p>然后top查看  或者 docker top test1</p> 
<h4 id="3.%E8%AE%BE%E7%BD%AE%E5%AE%B9%E5%99%A8%E7%BB%91%E5%AE%9Acpu">3.设置容器绑定cpu</h4> 
<p>--cpuset-cpus </p> 
<p>docker run -itd --name test4 --cpuset-cpus 0,2 centos:7 /bin/bash</p> 
<p>cpu的限制和绑定cpu一般是一起使用的。</p> 
<h3 id="%E5%86%85%E5%AD%98">内存</h3> 
<h4 id="1.%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6">1.内存限制</h4> 
<p>--memory=      简写-m 512m  或者 -m 1g</p> 
<p>单位是小写，也可以限制容器使用交换空间swap</p> 
<p>--memory-swap=512M/1g</p> 
<p>命令：docker run -itd --name test5 -m 512m  --memory-swap=1g centos:7 /bin/bash</p> 
<p>-m 512m --memory-swap=1g</p> 
<p>内存限制是512M，交换空间限制的大小是1g-512m=512m</p> 
<p>--memory-swap=0 或者不写</p> 
<p>容器使用swap交换分区的大小是限制的内存值的两倍，就是1g</p> 
<p>-m 512m --memory-swap=512m</p> 
<p>如果两个值一样表示容器不能使用swap交换分区</p> 
<p>-m 512m --memory-swap=1</p> 
<p>内存还是受限制512m，但使用交换分区不再受限制，宿主机有多少swqp空间，容器就可以用多少</p> 
<p>模拟命令：stress --vm 2 --vm-bytes 512M --vm-hang 0  模拟两个进程，分别占用内存512m一共1运行</p> 
<h3 id="%E7%A3%81%E7%9B%98">磁盘</h3> 
<h4 id="1.%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E7%9A%84%E9%99%90%E5%88%B6">1.磁盘读写速度的限制</h4> 
<p>docker run -itd --name test5 --device-read-bps /dev/sda:1M centos:7 /bin/bash</p> 
<p>容器在磁盘上每秒只能读1M</p> 
<p>这里可以用大写K、M、G 或者小写kb、mb、gb</p> 
<p>docker run -itd --name test5 --device-write-bps /dev/sda:1M centos:7 /bin/bash</p> 
<p>容器在磁盘上每秒只能写1M</p> 
<h4 id="2.%E7%A3%81%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6">2.磁盘的读写次数限制</h4> 
<p>docker run -itd --name test5 --device-read-iops /dev/sda:100 centos:7 /bin/bash</p> 
<p>docker run -itd --name test5 --device-write-iops /dev/sda:100 centos:7 /bin/bash</p> 
<h2 id="%E6%B8%85%E7%90%86docker%E7%9A%84%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%91%BD%E4%BB%A4">清理docker的磁盘空间的命令</h2> 
<p>docker system prune -a</p> 
<p>清理容器的残留，删除停止运行的容器，删除无用的数据卷和网络。</p> 
<h3 id="%E7%BB%83%E4%B9%A0">练习</h3> 
<p>1.设置3个权重 256 768 2048，并且3个容器设置绑定到cpu 0</p> 
<p>docker run -itd --name test1 --cpu-shares 512 --cpuset-cpus 0 -v /etc/yum.repos.d/:/etc/yum.repos.d/ centos:7 /bin/bash</p> 
<p>docker run -itd --name test2 --cpu-shares 768 --cpuset-cpus 0 -v /etc/yum.repos.d/:/etc/yum.repos.d/ centos:7 /bin/bash</p> 
<p>docker run -itd --name test3 --cpu-shares 2048 --cpuset-cpus 0 -v /etc/yum.repos.d/:/etc/yum.repos.d/ centos:7 /bin/bash</p> 
<p>实验结果</p> 
<p>top查看</p> 
<p><img alt="" src="https://images2.imgbox.com/5f/39/wtdMoVaa_o.png"></p> 
<p>docker stats 查看<img alt="" src="https://images2.imgbox.com/53/49/neREx3NC_o.png"></p> 
<p>2.绑定到指定的cpu 1 设置占用的cpu的比重是25%，同时限制内存使用率512m</p> 
<p>docker run -itd --name test4 --cpu-quota 25000 --cpuset-cpus 1 -m 512 --memory-swap=512m -v /etc/yum.repos.d/:/etc/yum.repos.d/ centos:7 /bin/bash</p> 
<p>实验结果</p> 
<p>top查看</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/69/c1/KibNLhYK_o.png"></p> 
<p>docker stats 查看<img alt="" src="https://images2.imgbox.com/89/bc/tt8cG3F0_o.png"></p> 
<p>free -h查看</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bd/c0/xFfEEWep_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d969a0ac93796f5de7023a1c227941de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IOS 03 纯代码封装自定义View控件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d854b322328022317d467bcfd14f173f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WPF Border 妙用，切图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>