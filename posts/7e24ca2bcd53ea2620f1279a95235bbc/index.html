<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux系统编程：TCP，UDP协议特点，粘包，wireshark抓包 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7e24ca2bcd53ea2620f1279a95235bbc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Linux系统编程：TCP，UDP协议特点，粘包，wireshark抓包">
  <meta property="og:description" content="1.Loop本地回环
Loop本地回环，特指一组以127开头的IP地址范围（即127.0.0.1至127.255.255.254），其中127.0.0.1是最为知名的成员，被誉为本地回环地址（Loop back address）。这一地址类别超脱于常规的IP地址分类之外，它象征着设备内部的虚拟接口，因此被视为一种理论上永不失效的网络连接。即便是在未安装物理网卡的情况下，用户也能通过ping命令成功访问此地址，这在Windows等操作系统中同样适用。
主要功能与应用：
网络配置自检：通过ping 127.0.0.1，用户可以快捷地验证本机网卡及IP协议栈的安装与配置状态。若响应成功，则表明基础网络设置无误。
应用程序资源调用：在SERVER/CLIENT架构的应用 程序中，当服务器与客户端位于同一台机器且缺乏外部SERVER时，可将SERVER资源部署于本机，并通过将SERVER的IP设置为127.0.0.1来实现资源的本地调用，确保程序顺畅运行。
2.解决TCP/IP通信中的粘包问题：
粘包现象概述：TCP因其流式传输特性，常面临粘包问题。即，多个独立的数据包可能在传输或接收过程中被合并处理，导致数据边界模糊。
成因分析：
发送端：为提高效率，TCP可能将多个小数据包合并为一个大包发送，若连续发送的数据量较小，则更易发生粘包。
接收端：若用户进程处理不及时，接收缓冲区内的多个数据包可能相互粘连，待后续数据到达时一并处理。
解决方案：
特定结束符法：在数据包末尾添加特定字符作为结束标志，接收方据此划分数据包界限。但需留意避免数据包内容中自然出现相同字符导致的误判。
固定数据大小法：约定数据包固定大小，不足部分以填充字符补齐。此方法简单但灵活性欠佳，且可能增加网络负担。
自定义数据协议：在TCP基础上构建包含数据头与数据体的自定义协议层。数据头中记录数据体大小等关键信息，接收方据此解析并提取数据体，有效避免粘包问题。此方法虽复杂，但高度灵活，适用于多种复杂场景。
3.recv和send函数说明
recv函数
功能描述：
recv 函数用于从已连接的套接字接收数据。
函数原型：
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
参数说明：
sockfd：套接字描述符，用于标识要接收数据的套接字。
buf：指向缓冲区的指针，用于存储接收到的数据。
len：缓冲区长度，指定接收数据的最大字节数。
flags（可选）：指定接收数据的额外选项，如MSG_WAITALL（等待所有数据到达）和MSG_DONTWAIT（非阻塞模式）等。
返回值：
成功时，返回接收到的字节数。
如果连接被正常关闭，则返回0。
如果发生错误，则返回-1，并设置相应的errno以指示错误类型。
注意事项：
recv函数是阻塞的，可通过设置套接字为非阻塞模式或使用select/poll/epoll等机制避免阻塞。
由于网络延迟、拥塞等原因，recv可能无法一次性接收全部数据，需编写循环接收。
接收到的数据可能因TCP/IP协议栈的分片或重新排序而需要重组或解析。
send函数
功能描述：
send 函数用于实现数据的发送功能。
函数原型：
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
ssize_t send(int sockfd, const void *buf, size_t len, int flags);">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-23T20:28:14+08:00">
    <meta property="article:modified_time" content="2024-08-23T20:28:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux系统编程：TCP，UDP协议特点，粘包，wireshark抓包</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.Loop本地回环</p> 
<p>Loop本地回环，特指一组以127开头的IP地址范围（即127.0.0.1至127.255.255.254），其中127.0.0.1是最为知名的成员，被誉为本地回环地址（Loop back address）。这一地址类别超脱于常规的IP地址分类之外，它象征着设备内部的虚拟接口，因此被视为一种理论上永不失效的网络连接。即便是在未安装物理网卡的情况下，用户也能通过ping命令成功访问此地址，这在Windows等操作系统中同样适用。</p> 
<p>主要功能与应用：</p> 
<p>网络配置自检：通过ping 127.0.0.1，用户可以快捷地验证本机网卡及IP协议栈的安装与配置状态。若响应成功，则表明基础网络设置无误。</p> 
<p>应用程序资源调用：在SERVER/CLIENT架构的应用 程序中，当服务器与客户端位于同一台机器且缺乏外部SERVER时，可将SERVER资源部署于本机，并通过将SERVER的IP设置为127.0.0.1来实现资源的本地调用，确保程序顺畅运行。</p> 
<p>2.解决TCP/IP通信中的粘包问题：</p> 
<p>粘包现象概述：TCP因其流式传输特性，常面临粘包问题。即，多个独立的数据包可能在传输或接收过程中被合并处理，导致数据边界模糊。</p> 
<p>成因分析：<br> 发送端：为提高效率，TCP可能将多个小数据包合并为一个大包发送，若连续发送的数据量较小，则更易发生粘包。<br> 接收端：若用户进程处理不及时，接收缓冲区内的多个数据包可能相互粘连，待后续数据到达时一并处理。<br> 解决方案：<br> 特定结束符法：在数据包末尾添加特定字符作为结束标志，接收方据此划分数据包界限。但需留意避免数据包内容中自然出现相同字符导致的误判。<br> 固定数据大小法：约定数据包固定大小，不足部分以填充字符补齐。此方法简单但灵活性欠佳，且可能增加网络负担。<br> 自定义数据协议：在TCP基础上构建包含数据头与数据体的自定义协议层。数据头中记录数据体大小等关键信息，接收方据此解析并提取数据体，有效避免粘包问题。此方法虽复杂，但高度灵活，适用于多种复杂场景。</p> 
<p style="text-align:center;"> <img src="https://images2.imgbox.com/bb/4c/RYaZTVg1_o.png" alt="32c1abca85a94a12ab8fdc205a9ab480.png"></p> 
<p> </p> 
<p>3.recv和send函数说明</p> 
<p>recv函数</p> 
<p>功能描述：</p> 
<p>recv 函数用于从已连接的套接字接收数据。</p> 
<p>函数原型：</p> 
<p>#include &lt;sys/types.h&gt;</p> 
<p>#include &lt;sys/socket.h&gt;</p> 
<p>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</p> 
<p>参数说明：</p> 
<p>sockfd：套接字描述符，用于标识要接收数据的套接字。</p> 
<p>buf：指向缓冲区的指针，用于存储接收到的数据。</p> 
<p>len：缓冲区长度，指定接收数据的最大字节数。</p> 
<p>flags（可选）：指定接收数据的额外选项，如MSG_WAITALL（等待所有数据到达）和MSG_DONTWAIT（非阻塞模式）等。</p> 
<p>返回值：</p> 
<p>成功时，返回接收到的字节数。</p> 
<p>如果连接被正常关闭，则返回0。</p> 
<p>如果发生错误，则返回-1，并设置相应的errno以指示错误类型。</p> 
<p>注意事项：</p> 
<p>recv函数是阻塞的，可通过设置套接字为非阻塞模式或使用select/poll/epoll等机制避免阻塞。</p> 
<p>由于网络延迟、拥塞等原因，recv可能无法一次性接收全部数据，需编写循环接收。</p> 
<p>接收到的数据可能因TCP/IP协议栈的分片或重新排序而需要重组或解析。</p> 
<p>send函数</p> 
<p>功能描述：</p> 
<p>send 函数用于实现数据的发送功能。</p> 
<p>函数原型：</p> 
<p>#include &lt;sys/types.h&gt;</p> 
<p>#include &lt;sys/socket.h&gt;</p> 
<p>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</p> 
<p>参数说明：</p> 
<p>sockfd：套接字描述符，指向已打开并连接到远端地址的套接字。</p> 
<p>buf：指向要发送数据的缓冲区的指针。</p> 
<p>len：指定要发送的数据的字节数。</p> 
<p>flags：发送操作的控制标志，通常设置为0，但可指定特定标志修改send行为。</p> 
<p>返回值：</p> 
<p>成功时，返回实际发送的字节数，可能小于请求发送的字节数。</p> 
<p>如果发送过程中出现错误，返回-1，并设置相应的errno以指示错误类型。</p> 
<p>注意事项：</p> 
<p>send函数在大多数情况下是阻塞的，可通过设置套接字为非阻塞模式或使用select/poll/epoll等机制避免阻塞。</p> 
<p>TCP/IP协议保证数据的完整性和顺序性，但发送的数据可能被分成多个数据包传输。</p> 
<p>由于网络延迟、拥塞等原因，send可能无法立即发送所有数据，需编写循环发送。</p> 
<p>在非阻塞套接字上，send可能返回小于请求发送的字节数的值，表示只有部分数据被发送，需再次调用send发送剩余数据。</p> 
<p>4.TCP协议的特点<br> 面向连接：TCP在传输数据之前，需要先建立连接，即三次握手过程，确保数据的可靠传输。<br> 可靠性：TCP通过序列号、确认应答、超时重传、流量控制、拥塞控制等机制，确保数据的可靠传输。<br> 有序性：TCP保证数据包的顺序与发送顺序一致，即接收方会按照发送方的发送顺序接收数据。<br> 面向字节流：TCP把数据看成一连串无结构的字节流，不保留数据包的边界，适合传输大量数据。<br> 速度慢：由于TCP的可靠性机制，如确认应答、超时重传等，会导致其传输速度相对较慢。<br> 5.UDP协议的特点<br> 无连接：UDP在传输数据之前不需要建立连接，直接发送数据报，减少了开销和延迟。<br> 不可靠性：UDP不保证数据的可靠性，不会进行确认应答、超时重传等操作，因此可能会出现数据丢失、乱序等问题。<br> 面向数据报：UDP保留了数据包的边界，每个UDP数据包都是独立的，适合传输少量数据或需要快速响应的应用。<br> 速度快：由于UDP没有TCP的可靠性机制，因此其传输速度相对较快。<br> 资源消耗少：UDP的头部开销小，只有8个字节，相比TCP的20个字节头部开销要小很多，因此资源消耗较少。<br> 总结：<br> TCP适合需要高可靠性、有序性、面向字节流传输的应用场景，如文件传输、网页浏览等。<br> UDP适合对实时性要求高、对可靠性要求不高的应用场景，如视频直播、在线游戏等。</p> 
<p>6.wireshark抓包</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/31/b8/qyyOHiyz_o.png" alt="200baf798f2a461f9ca0db48e9bc54a6.png"></p> 
<p> tcp3次握手</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/fd/b8/BbFjzBss_o.png" alt="b3c3b0bb5f7c4bfc9c586ffc0049301a.png"></p> 
<p> tcp4次挥手</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/8c/76/nys6nXdP_o.png" alt="f0793378ca074312ab77d3a9956d9be3.png"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00ffcfab7ebd03ef0ccf20a469455108/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">密码生成器（HTML&#43;CSS&#43;JavaScript）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/770caeb40ee201466af47a43f730175a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言程序设计（初识C语言后部分）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>