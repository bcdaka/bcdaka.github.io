<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43; STL】模拟实现 string - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0441b98173cac62988a19756f2a521ae/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43; STL】模拟实现 string">
  <meta property="og:description" content="标题：【C&#43;&#43; :: STL】手撕 STL _string
@水墨不写bug
（图片来源于网络）
C&#43;&#43;标准模板库（STL）中的string是一个可变长的字符序列，它提供了一系列操作字符串的方法和功能。
本篇文章，我们将模拟实现STL的string类的部分功能，以增强对STL的熟练度，了解STL容器的工作原理，积累项目经验，也为将来自主实现和改造容器奠定坚实的基础。
STL的string类是一个模板，而我们为了方便实现，以达到练习的目的，我们暂时先实现一个成员变量为（下图示）的string类。 char* _str; size_t _size;//字符串长度，不加上\0 size_t _capacity; C&#43;&#43; STL的string类提供了以下常用的成员函数和接口：
构造函数和赋值操作函数接口：
默认构造函数：创建一个空字符串。带string参数的构造函数：将一个string对象复制到另一个string对象中。带字符数组参数的构造函数：将字符数组转换为string对象。带整数参数的构造函数：将整数转换为字符串。赋值操作符：用另一个string对象、字符数组或字符来赋值。 访问字符串内容相关函数接口：
at()：返回指定位置的字符。operator[]：返回指定位置的字符。front()：返回第一个字符。back()：返回最后一个字符。c_str()：返回一个以空字符结尾的字符数组。 修改字符串内容接口：
insert()：在指定位置插入字符、字符串或字符数组。erase()：删除指定位置的字符。replace()：替换指定位置的字符串或字符。append()：在字符串末尾添加字符、字符串或字符数组。clear()：清空字符串。 字符串操作接口：
size() 或 length()：返回字符串的长度。empty()：判断字符串是否为空。find()：查找指定字符串或字符的位置。substr()：返回指定位置和长度的子字符串。compare()：比较两个字符串 （具体用法在上一篇讲解：【Cpp::STL】标准模板库_ string详解） （一）头文件 我们在C语言阶段实现声明和定义分离的时候，只是单一的把函数的定义放在.c（源）文件，把函数的声明，头文件的包含，宏定义等放在.h（头）文件。
但是，在C&#43;&#43;，不仅要遵守以上的规则，由于类的出现，需要域作用限定符（：：）来限定方位；由于成员的访问权限的出现，需要考虑访问权限的问题；此外不同类型的成员的定义的位置也有讲究，比如静态成员尽量不要直接定义在头文件中，因为这会引发 多次包含多文件 在链接时的 头文件内的对象的重定义问题。
本文根据STL标准模板库的功能，给出头文件，包括string类的定义，众多成员函数，部分非成员函数（流插入，流提取的重载），并在后半节详细讲解各个函数的实现思路。
#define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cassert&gt; using namespace std; namespace ddsm { class string { friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s1); public: //迭代器 typedef char* iterator; typedef const char* const_iterator; iterator begin(); const_iterator begin() const; iterator end(); const_iterator end() const; //传参构造,默认构造，给默认值为空串，巧妙 string(const char* str = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-09T08:47:11+08:00">
    <meta property="article:modified_time" content="2024-06-09T08:47:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43; STL】模拟实现 string</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><strong>标题：【C++ :: STL】手撕 STL _string</strong></p> 
<p style="text-align:center;"><strong><a class="link-info" href="https://blog.csdn.net/2301_79465388?spm=1000.2115.3001.5343" title="@水墨不写bug">@水墨不写bug</a></strong></p> 
<hr> 
<p style="text-align:right;"><strong><img alt="" src="https://images2.imgbox.com/73/5d/MqgXzc2c_o.png"></strong>（图片来源于网络）</p> 
<hr> 
<blockquote> 
 <p>       <strong> C++标准模板库（STL）中的string是一个可变长的字符序列，它提供了一系列操作字符串的方法和功能。</strong></p> 
</blockquote> 
<p>        本篇文章，我们将模拟实现STL的string类的部分功能，以增强对STL的熟练度，了解STL容器的工作原理，积累项目经验，也为将来自主实现和改造容器奠定坚实的基础。</p> 
<p>        STL的string类是一个模板，而我们为了方便实现，以达到练习的目的，我们暂时先实现一个成员变量为（下图示）的string类。    </p> 
<pre><code class="language-cpp">char* _str;
size_t _size;//字符串长度，不加上\0
size_t _capacity;
		</code></pre> 
<hr> 
<blockquote> 
 <p><strong>C++ STL的string类提供了以下常用的成员函数和接口：</strong></p> 
 <ol><li> <p><strong>构造函数和赋值操作函数接口：</strong></p> 
   <ul><li>默认构造函数：创建一个空字符串。</li><li>带string参数的构造函数：将一个string对象复制到另一个string对象中。</li><li>带字符数组参数的构造函数：将字符数组转换为string对象。</li><li>带整数参数的构造函数：将整数转换为字符串。</li><li>赋值操作符：用另一个string对象、字符数组或字符来赋值。</li></ul></li><li> <p><strong>访问字符串内容相关函数接口：</strong></p> 
   <ul><li>at()：返回指定位置的字符。</li><li>operator[]：返回指定位置的字符。</li><li>front()：返回第一个字符。</li><li>back()：返回最后一个字符。</li><li>c_str()：返回一个以空字符结尾的字符数组。</li></ul></li><li> <p><strong>修改字符串内容接口：</strong></p> 
   <ul><li>insert()：在指定位置插入字符、字符串或字符数组。</li><li>erase()：删除指定位置的字符。</li><li>replace()：替换指定位置的字符串或字符。</li><li>append()：在字符串末尾添加字符、字符串或字符数组。</li><li>clear()：清空字符串。</li></ul></li><li> <p><strong>字符串操作接口：</strong></p> 
   <ul><li>size() 或 length()：返回字符串的长度。</li><li>empty()：判断字符串是否为空。</li><li>find()：查找指定字符串或字符的位置。</li><li>substr()：返回指定位置和长度的子字符串。</li><li>compare()：比较两个字符串</li></ul></li></ol> 
</blockquote> 
<p> （具体用法在上一篇讲解：<a class="link-info" href="https://blog.csdn.net/2301_79465388/article/details/139012712?spm=1001.2014.3001.5501" title="【Cpp::STL】标准模板库_ string详解">【Cpp::STL】标准模板库_ string详解</a>） </p> 
<hr> 
<h2>（一）头文件</h2> 
<p>        我们在C语言阶段实现声明和定义分离的时候，只是单一的把函数的定义放在.c（源）文件，把函数的声明，头文件的包含，宏定义等放在.h（头）文件。</p> 
<p>        但是，在C++，不仅要遵守以上的规则，由于类的出现，需要域作用限定符（：：）来限定方位；由于成员的访问权限的出现，需要考虑访问权限的问题；此外不同类型的成员的定义的位置也有讲究，比如静态成员尽量不要直接定义在头文件中，因为这会引发  多次包含多文件   在链接时的  头文件内的对象的重定义问题。</p> 
<blockquote> 
 <p>        <strong>本文根据STL标准模板库的功能，给出头文件，包括string类的定义，众多成员函数，部分非成员函数（流插入，流提取的重载），并在后半节详细讲解各个函数的实现思路。</strong></p> 
 <pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#pragma once
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cassert&gt;
using namespace std;

namespace ddsm 
{
	class string 
	{
		friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s1);
	public:
		//迭代器
		typedef char* iterator;
		typedef const char* const_iterator;
		iterator begin();
		const_iterator begin() const;
		iterator end();
		const_iterator end() const;

		//传参构造,默认构造，给默认值为空串，巧妙
		string(const char* str = "");
		string(const string&amp; s);//copy constructor
		//string&amp; operator=(const string&amp; s);传统写法
		string&amp; operator=(const char* s);
		string&amp; operator=(string s);//现代写法

		//析构
		~string();
		//C类型字符串
		const char* c_str() const;

		//保留
		void reserve(int n);
		string&amp; push_back(const char ch);//尾插字符
		string&amp; append(const char* str);//尾插字符串

		string&amp; operator+=(char ch);
		string&amp; operator+=(const char* str);

		string&amp; insert(size_t pos, const char ch);
		string&amp; insert(size_t pos, const char* str);
		
		//缺省值代表最一般的情况
		string&amp; erase(size_t pos = 0,size_t len = npos);
	
		//找一个字符
		size_t find(const char ch, size_t pos = 0);
		//找一个子串
		size_t find(const char* str, size_t pos = 0);
		void swap(string&amp; s);

		string substr(size_t pos = 0,size_t len = npos);
	
		string&amp; clear();
	private:
		char* _str;
		size_t _size;//字符串长度，不加上\0
		size_t _capacity;
		
		//特例，const静态整形对象可声明定义和一,但是可能造成链接时的错误
		static size_t npos;
	};
	istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s);
	

};</code></pre> 
 <p></p> 
</blockquote> 
<h2>（二）string类的功能实现</h2> 
<h3>（1）默认成员函数</h3> 
<h4>i，构造函数</h4> 
<blockquote> 
 <p>        我们知道，构造函数的作用是<strong>在对象实例化时初始化对象</strong>，对于string类对象，含有三个基本成员变量：</p> 
 <pre><code class="language-cpp">        char* _str;
		size_t _size;//字符串长度，不加上\0
		size_t _capacity;</code></pre> 
 <p>        经过分析，我们得知在构造函数内部，需要申请动态的堆区空间给_str;需要根据_str的长度变化来动态更新_size；同时根据申请的动态空间的长度来更新_capacity。</p> 
 <p>        于是，我们理所当然的想到这样写构造函数：</p> 
 <pre><code class="language-cpp">string::string(const char* str = "")
// 缺省参数为一个空字符串，如果不传参，空字符串就是一个单独的'\0'
	:_size(strlen(str))
    ,_capacity(strlen(str))
{
	_str = new char[_size + 1];
	strcpy(_str, str);
}</code></pre> 
 <p>        但是，这种简单易懂的写法也暴露出了弊端：多次无意义的重复调用strlen，这会造成额外的消耗。于是，为了减少strlen的调用次数，我们考虑这样修改:</p> 
 <p>        </p> 
 <pre><code class="language-cpp">string::string(const char* str)
	:_size(strlen(str))
    ,_capacity(_size)
{
	_str = new char[_size + 1];
	strcpy(_str, str);
}</code></pre> 
 <p>        这样修改虽然解决了strlen重复无意义调用的问题，但是也带来了新的问题：</p> 
 <p>程序稳定性下降的问题：</p> 
 <p><strong>￥￥</strong>我们知道：初始化列表的初始化顺序是成员函数在类中的声明顺序：按照此例：</p> 
 <pre><code class="language-cpp">        char* _str;
		size_t _size;//字符串长度，不加上\0
		size_t _capacity;</code></pre> 
 <p>        先初始化_size,再初始化_capacity；在这种背景下，如果代码有一些微小的改变，或许就会造成意想不到的问题。</p> 
 <p>        如果改变成员变量的顺序，那么初始化列表就会按照不同的顺序初始化。具体来说，如果_capacity在_size之前，初始化列表就会先初始化_capacity：</p> 
 <pre><code class="language-cpp">        char* _str;
		size_t _capacity;
		size_t _size;//字符串长度，不加上\0
</code></pre> 
 <p>        这时_size还没有初始化，是随机值，那么就造成了_capacity为随机值的问题。</p> 
 <p>解决这个问题其实很简单，将对_capacity的初始化放入函数体：</p> 
 <pre><code class="language-cpp">string::string(const char* str)
	//strlen较低效，调用一次用size记录返回值
	//size/capacity不包含\0，但是其需要存储
	:_size(strlen(str))
{
	_str = new char[_size + 1];
	_capacity = _size;
	strcpy(_str, str);
}</code></pre> 
 <p>        这样就确定了是先初始化_size,再初始化_capacity。<strong>￥￥</strong></p> 
 <p></p> 
 <p><strong>        （将声明和定义分离，需要将缺省参数放在声明处，同时函数名之前需要加上域作用限定符，表示这个函数在你实现的string类里面声明过。）</strong></p> 
</blockquote> 
<h4>ii，析构函数</h4> 
<blockquote> 
 <p>         析构函数的作用是：清理资源。</p> 
 <p>由于比较简单，这里直接给出实现：</p> 
 <pre><code class="language-cpp">//析构
string::~string()
{
	if(_str)
		delete[] _str;
	_size = _capacity = 0;
	_str = nullptr;
}</code></pre> 
 <p><strong>（函数名之前需要加上域作用限定符，表示这个函数在你实现的string类里面声明过。）</strong></p> 
</blockquote> 
<h4>iii，拷贝构造</h4> 
<blockquote> 
 <p>       拷贝构造，完成创建对象时的初始化。</p> 
 <p>一般情况下，我们会这样写：</p> 
 <pre><code class="language-cpp">//拷贝构造
string::string(const string&amp; s)
{
	char* tem = new char[s._capacity+1];//多开一个，存储'\0'
	strcpy(tem, s._str);
    
	delete[] _str;//销毁原空间

	_str = tem;
	_size = s._size;
	_capacity = s._capacity;
}</code></pre> 
 <p>但是，其实有更简单的写法：</p> 
 <pre><code class="language-cpp">void string::swap(string&amp; s)
{
	//调用模板swap交换内置类型，损失不大
	std::swap(_str, s._str);
	std::swap(_capacity, s._capacity);
	std::swap(_size, s._size);
}
//拷贝构造的现代写法
string::string(const string&amp; s)
	:_str(nullptr)
{
	string tem(s._str);
	swap(tem);
}</code></pre> 
 <p>仔细分析，我们其实在无形之中让构造函数给我们“打工”了：</p> 
 <pre><code class="language-cpp">string tem(s._str);</code></pre> 
 <p>就是用拷贝对象的字符串来构造一个tem对象，而这个tem对象就是我们需要的，所以我们实现一个swap函数，将*this与tem完全交换，同时tem在出作用域时也会自动析构，同样也达到了拷贝构造的目的。</p> 
</blockquote> 
<h4>iv，赋值重载</h4> 
<blockquote> 
 <p>赋值重载：实现对象之间的赋值。</p> 
 <p>我们一般会这样实现：</p> 
 <pre><code class="language-cpp">//赋值重载
string&amp; string::operator=(const char* s)
{
	int len = strlen(s);
	char* tem = new char[len + 1];
	strcpy(tem, s);

	delete[] _str;
	_str = tem;
	_size = _capacity = len;

	return *this;
}</code></pre> 
 <p> 但是，同样也有更简单的写法：</p> 
 <pre><code class="language-cpp">void string::swap(string&amp; s)
{
	//调用模板swap交换内置类型，损失不大
	std::swap(_str, s._str);
	std::swap(_capacity, s._capacity);
	std::swap(_size, s._size);
}

//赋值重载的现代写法 
string&amp; string::operator=(string tem)
{
	//自动调用拷贝构造
	swap(tem);
	//出作用域自动完成析构
	return *this;
}</code></pre> 
 <p>在无形之中，我们让拷贝构造为我们“打工”。</p> 
 <p>我们通过传值传参，拷贝构造一个临时对象tem，这个tem就是我们需要的，所以完全交换*this就得到了构造的对象，同时tem出作用域也会自动析构。</p> 
</blockquote> 
<h3>（2）迭代器</h3> 
<blockquote> 
 <p>         对于迭代器，本质上是一个指针，也可以是一个类（对指针的封装），在这里，我们不妨用指针来作为迭代器：</p> 
 <pre><code class="language-cpp">//声明：
typedef char* iterator;
typedef const char* const_iterator;
iterator begin();
const_iterator begin() const;
iterator end();
const_iterator end() const;</code></pre> 
 <pre><code class="language-cpp">    //定义
	string::iterator string::begin()
	{
		return _str;
	}
	string::const_iterator string::begin() const
	{
		return _str;
	}
	string::iterator string::end()
	{
		return _str + _size;
	}
	string::const_iterator string::end() const
	{
		return _str + _size;
	}</code></pre> 
 <p>        const迭代器用于const对象调用；普通迭代器用于普通迭代器调用。</p> 
 <p><strong>普通迭代器可读可写，const迭代器只可读不可写。</strong></p> 
</blockquote> 
<h3>（3）容量和长度</h3> 
<blockquote> 
 <h4 style="background-color:transparent;"> i.reserve()</h4> 
 <p>       <strong> 改变string的容量，若要求值n大于现在的容量，则容量扩大到n；若要求值小于等于现有容量，则改变容量。</strong></p> 
 <p><strong>        reserve对于size没有影响，不会改变string的内容。</strong></p> 
 <p>实现如下：</p> 
 <pre><code class="language-cpp">//保留指定容量,容量只增不减
void string::reserve(int n)
{
	//要求保留的大于现有容量,需要扩容
	if (n &gt; _capacity)
	{
		char* tem = new char[n + 1];
		// 申请新空间完毕,转移数据
		strcpy(tem, _str);
		delete[] _str;

		_str = tem;
		_capacity = n;
		//reserve不改变size
	}
}</code></pre> 
 <h4>ii,resize()</h4> 
 <pre><code class="language-cpp">    //resize()不改变capacity，可能改变size
	void string::resize(int size,int ch)
    //size为设定值，_size为现有值
	{
		if (size &lt; _size)
		{
			_size = size;
			_str[size] = '\0';
		}
		else if (size &gt; _size)
		{
			if (size &gt; _capacity)
			{
				reserve(size);
			}
			int i = _size;
			while (i != size)
			{
				_str[i++] = '\0';
			}
			_size = size;
			_str[_size] = '\0';
		}
	}
</code></pre> 
 <p>       <strong> 如果设定值小于现有值，减小_size，相当于截断_str；</strong></p> 
 <p><strong>        如果设定值等于现有值，不做处理；</strong></p> 
 <p><strong>        如果设定值大于现有值，有三种情况：</strong></p> 
 <p><strong>                size &lt;_capacity:        不扩容，并在[ _size,size)之间补0；</strong></p> 
 <p><strong>                size == _capacity:        不扩容，并在[ _size,size)之间补0；</strong></p> 
 <p><strong>                size &gt; _capzcity:        扩容，并在[ _size,size)之间补0；</strong></p> 
</blockquote> 
<h3>（4）元素访问</h3> 
<blockquote> 
 <h4><strong> i,operator[]</strong></h4> 
 <p>        下标的随机访问：</p> 
 <pre><code class="language-cpp">//声明
char&amp; operator[](size_t pos);
const char&amp; operator[](size_t pos) const;</code></pre> 
 <pre><code class="language-cpp">//定义
char&amp; string::operator[](size_t pos)
{
	assert(pos &gt;= 0 &amp;&amp; pos &lt; _size);
	return _str[pos];
}
const char&amp; string::operator[](size_t pos) const
{
	assert(pos &gt;= 0 &amp;&amp; pos &lt; _size);
	return _str[pos];
}</code></pre> 
 <p>对于at，front，back可以复用operator[]来实现。</p> 
</blockquote> 
<h3 style="background-color:transparent;">（5）修改方式</h3> 
<blockquote> 
 <h4>i,push_back()</h4> 
 <p>        实现尾插字符，实现如下：</p> 
 <pre><code class="language-cpp">//尾插字符,由于是一个一个插入，扩容不能太频繁，所以采用二倍扩容
string&amp; string::push_back(const char ch)
{
	if (_size == _capacity)
		//不一定需要扩容，若长度等于容量，再次插入需要扩容
	{
		int Newcapacity = _capacity == 0 ? 4 : 2 * _capacity;
		reserve(Newcapacity);
	}
	//扩容完毕，尾插字符
	_str[_size++] = ch;
	_str[_size] = '\0';

	return *this;
}</code></pre> 
 <p>        这里使用了一个扩容技巧，就是二倍扩容。</p> 
 <h4>ii，append()</h4> 
 <p>        追加，这里简化为追加一段字符串。</p> 
 <pre><code class="language-cpp">//尾插字符串，直接reserve到指定长度字符串
string&amp; string::append(const char* str)
{
	int len = strlen(str);
	if (len + _size &gt; _capacity)
	{
		reserve(len + _size);//不改变size
	}
	//扩容完毕
	strcpy(_str + _size, str);
	_size += len;

	return *this;
}</code></pre> 
 <p>        首先要先保存原来的len，这样如果需要扩容，在扩容完毕之后，只需更新_size为原_size+=len即可。</p> 
 <p>        否则，如果不保存len，在需要扩容的情况下，就会出现问题了：</p> 
 <p>##</p> 
 <p>（）</p> 
 <p>##</p> 
 <h4><strong>iii，operator+=复用上两函数即可</strong></h4> 
 <p><strong>        </strong><strong>尾插一个字符</strong></p> 
 <pre><code class="language-cpp">string&amp; string::operator+=(char ch)
{
	push_back(ch);
	return *this;
}
</code></pre> 
 <p><strong>        尾插一个字符串</strong></p> 
 <pre><code class="language-cpp">string&amp; string::operator+=(const char* str)
{
	append(str);
	return *this;
}</code></pre> 
 <h4><strong>iv，insert()</strong></h4> 
 <p><strong>        <span style="color:#0d0016;">在任意位置插入一个字符</span></strong></p> 
 <pre><code class="language-cpp">//插入一个字符
//用push_back逻辑来扩容
string&amp; string::insert(size_t pos, const char ch)
{
    assert(pos &gt;= 0 &amp;&amp; pos &lt;= _size);

	if (_size == _capacity)
	{
		int Newcapacity = _capacity == 0 ? 4 : 2 * _capacity;
		reserve(Newcapacity);//不改变size
	}

	int end = _size+1;
    //细节问题，int与size_t参与比较，
	//int隐式类型转化为size_t
    //size_t(-1)会变成很大的整数

	while(end&gt;pos)
	{
		_str[end] = _str[end-1];
		--end;
	}
	_str[pos] = ch;
	_size += 1;

	return *this;
}</code></pre> 
 <hr>         
 <strong>在任意位置插入一个字符串</strong> 
 <pre><code class="language-cpp">//插入一个字符串
//用reserve逻辑扩容
string&amp; string::insert(size_t pos, const char* str)
{
    assert(pos &gt;= 0 &amp;&amp; pos &lt;= _size);

	int len = strlen(str);
	if (len + _size &gt; _capacity)
	{
		reserve(len+_size);
	}
	int end = _size + len;
	while (end&gt;pos+len-1)
	{
		_str[end] = _str[end - len];
		--end;
	}
	memmove(_str + pos, str, len);

	_size += len;

	return *this;
}</code></pre> 
 <h4><strong>v,erase()</strong></h4> 
 <p><strong>        在任意位置处删除长度为len的字符串：</strong></p> 
 <pre><code class="language-cpp">string&amp; string::erase(size_t pos, size_t len)
	//两种情况；删除部分string，pos之后全删
{
    assert(pos &gt;= 0 &amp;&amp; pos &lt;= _size);

	if ((len == npos) ||(pos + len &gt;= _size))//全删的情况
	{
		_str[pos] = '\0';
		_size = pos;
	}
	else
	//删除部分string
	{
		int end = pos + len;
		while (_str[end]!='\0')
		{
			_str[end - len] = _str[end];
			++end;
		}
		_str[end-len] = '\0';
	}
	return *this;
}</code></pre> 
 <p></p> 
</blockquote> 
<h3>（6）串操作</h3> 
<blockquote> 
 <h4 style="background-color:transparent;">i,find()</h4> 
 <p>       <strong> 找字符</strong></p> 
 <pre><code class="language-cpp">size_t string::find(const char ch, size_t pos)
{
	for (size_t i = pos; i &lt; _size; ++i)
	{
		if (_str[i] == ch)
		{
			return i;
		}
	}
	return npos;
}</code></pre> 
 <p>        <strong>找字符串</strong></p> 
 <p><strong>        用到了strstr（）：字符串匹配函数。</strong></p> 
 <pre><code class="language-cpp">size_t string::find(const char* str, size_t pos)
{
	char* ret = strstr(_str, str);
	return (size_t)(ret - _str);
}</code></pre> 
 <h4><strong>ii,c_str()</strong></h4> 
 <p><strong>        返回C类型的字符串：</strong></p> 
 <pre><code class="language-cpp">const char* string::c_str() const
{
	return _str;
}</code></pre> 
 <h4>iii，substr()</h4> 
 <p>        得到字符串的子串：</p> 
 <pre><code class="language-cpp">
	string string::substr(size_t pos, size_t len)
	{
    	assert(pos &gt;= 0 &amp;&amp; pos &lt;= _size);

		if ((len == npos) || (pos + len &gt;= _size))
		{
			string sub(_str + pos);
			return sub;
		}
		else
		{ 
			string sub;
			sub.reserve(len);
			for (size_t i = 0; i &lt; len; ++i)
			{
				sub._str[i] = _str[pos + i];
			}
			sub._str[len] = '\0';
			sub._size =sub._capacity =  len;
			
			return sub;
		}
	}</code></pre> 
 <p></p> 
</blockquote> 
<h3>（7）成员常量</h3> 
<blockquote> 
 <pre><code class="language-cpp">//特例，const静态整形对象可声明定义和一,但是可能造成链接时的错误
const static size_t npos = -1;</code></pre> 
 <p>        无符号整数size_t(-1)是一个很大的整数。</p> 
</blockquote> 
<h3>（8）流插入和流提取</h3> 
<blockquote> 
 <h4>i,operator&lt;&lt;()</h4> 
 <pre><code class="language-cpp">ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s)
{
	for (size_t i = 0; i &lt; s._size; ++i)
	{
		cout &lt;&lt; s._str[i];
	}
	cout &lt;&lt; endl;
	return out;
}</code></pre> 
 <h4>ii,operator&gt;&gt;()</h4> 
 <p>        cin的get（）函数可以提取空白字符和‘\n’，这也是循环逻辑结束的条件。</p> 
 <pre><code class="language-cpp">//流提取改进，用buf临时数组，防止string频繁扩容
istream&amp; operator&gt;&gt;(istream&amp; in,string&amp; s)
{
	s.clear();
	char buff[128] = { 0 };
	char ch = in.get();
	int i = 0;
	while(ch != ' ' &amp;&amp; ch != '\n')
	{
		buff[i++] = ch;
		ch = in.get();

		if (i == 127)
		{
			buff[i] = '\0';
			s += buff;
			i = 0;
		}
	}

	buff[i] = '\0';
	if (i != 0)
	{
		s += buff;
	}
	return in;
}</code></pre> 
 <p>        整体使用了用临时栈区数组的方式来减少扩容次数，提高效率。</p> 
</blockquote> 
<hr> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>完~</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>未经作者同意禁止转载 </strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f00e2b7618037ee89040207855d889e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用AI制作历史解说视频：GPT &#43; MidJourney &#43; PiKa &#43; FunSound &#43; 剪映</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c696454929b670decdfb7728fc55942/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Redis】解决 Redis 运行在 Protected Mode 下的 DENIED 错误：消除 Redis 受保护模式的完美方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>