<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>十大基础算法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/65bc61f30c074f0fd8c3f2911c5d9075/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="十大基础算法">
  <meta property="og:description" content="一、选择排序 过程简单描述：
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为选择排序。
为方便理解我还准备了动图：
.
public class SelectionSort { public static void main(String[] args) { int[] arr = {5, 3, 6, 8, 1, 7, 9, 4, 2}; //定义内外两层循环，从最外层循环第一个值开始匹配，内层循环从外层循环加以开始向后匹配 //如果遇到小的值就进行交换 //外层循环到倒数第二为止，内层循环到倒数第一为止 for (int i = 0; i &lt; arr.length-1; i&#43;&#43;) { int min = i; for (int j = i&#43;1; j &lt; arr.length; j&#43;&#43;) { if(arr[i]&gt;=arr[j]){ min = j; int temp = arr[i]; arr[i] = arr[min]; arr[j] = temp; } } } CommonUtils.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-01T11:02:16+08:00">
    <meta property="article:modified_time" content="2023-07-01T11:02:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">十大基础算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、选择排序</h2> 
<p><strong>过程简单描述：</strong><br> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为<strong>选择排序</strong>。</p> 
<p>为方便理解我还准备了动图：</p> 
<p>.</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/dd/06/R5ewttVM_o.gif"></p> 
<pre><code class="language-java">public class SelectionSort {

    public static void main(String[] args) {
        int[] arr = {5, 3, 6, 8, 1, 7, 9, 4, 2};
        //定义内外两层循环，从最外层循环第一个值开始匹配，内层循环从外层循环加以开始向后匹配
        //如果遇到小的值就进行交换
        //外层循环到倒数第二为止，内层循环到倒数第一为止
        for (int i = 0; i &lt; arr.length-1; i++) {
            int min = i;
            for (int j = i+1; j &lt; arr.length; j++) {
                if(arr[i]&gt;=arr[j]){
                    min = j;
                    int temp = arr[i];
                    arr[i] = arr[min];
                    arr[j] = temp;
                }
            }
        }
        CommonUtils.print(arr);
    }
}</code></pre> 
<p>性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序</p> 
<h2>二、插入排序</h2> 
<p>我们在玩打牌的时候，你是怎么整理那些牌的呢？一种简单的方法就是一张一张的来，将每一张牌插入到<strong>其他已经有序</strong>的牌中的适当位置。当我们给无序数组做排序的时候，为了要插入元素，我们需要腾出空间，将其余所有元素在插入之前都向右移动一位，这种算法我们称之为<strong>插入排序</strong>。</p> 
<p><strong>过程简单描述：</strong></p> 
<p>1、从数组第2个元素开始抽取元素。</p> 
<p>2、把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边。</p> 
<p>3、继续选取第3，4，….n个元素,重复步骤 2 ，选择适当的位置插入。</p> 
<p>为方便理解我还准备了动图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/6f/sXEqVsza_o.gif"></p> 
<pre><code class="language-java">public class InsertionSort {
    public static void main(String[] args) {
        int[] a = { 9, 3, 1, 4, 6, 8, 7, 5, 2 };
        for (int i = 1; i &lt; a.length; i++) {
            //内层比较是从外层的赋值为起始点
            //该值会和它前面的值比较，如果比前面的值小就交换
            for (int j = i;j&gt;0; j--) {
                if(a[j]&lt;a[j-1]){
                    CommonUtils.swap(a,j,j-1);
                }
            }
        }
        CommonUtils.print(a);
    }
}</code></pre> 
<h2>三、冒泡排序</h2> 
<p>1、把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置….</p> 
<p>我们对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来之后，排在最右的元素就会是最大的数。</p> 
<p>除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。</p> 
<p>为方便理解我还准备了动图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/be/d9/jK8myUME_o.gif"></p> 
<pre><code class="language-java">public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {5, 3, 6, 8, 1, 7, 9, 4, 2};
        for (int i = 0; i &lt; arr.length; i++) {
            //内层循环像指针一样指导着程序运行
            for (int j = 0; j &lt; arr.length-i-1; j++) {

                if(arr[j]&gt;arr[j+1]){
                    CommonUtils.swap(arr,j,j+1);
                }
            }
        }

        CommonUtils.print(arr);
    }
}</code></pre> 
<h2>四、希尔排序</h2> 
<p>希尔排序可以说是<strong>插入排序</strong>的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。</p> 
<p>希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。</p> 
<p>希尔排序的思想是采用<strong>插入排序</strong>的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p> 
<p>为方便理解我还准备了图片：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/eb/a0/NnLh9tAY_o.jpg"></p> 
<pre><code class="language-java">public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {5, 3, 6, 8, 1, 7, 9, 4, 2};
        int h = arr.length/2;
        for (int gap = h; gap &gt; 0; gap--) {//间隔的循环
            for (int j = 0; j &lt; arr.length-gap; j++) {
                if(arr[j]&gt;arr[j+gap]){
                    CommonUtils.swap(arr,j,j+gap);
                }
            }

        }

        CommonUtils.print(arr);
    }
}</code></pre> 
<h2>五、归并排序</h2> 
<p>将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。</p> 
<p>通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。</p> 
<p>为方便理解我还准备了动图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1b/cd/GjJYQLNq_o.gif"></p> 
<pre><code class="language-java">public class MergeSort {

    public static void main(String[] args) {
        int[] arr = {1,4,7,8,3,6,9};
        sort(arr, 0, arr.length-1);

        CommonUtils.print(arr);
    }
    static void sort(int[] arr, int left, int right) {
        if(left==right){
            return;
        }
        int mid = left + (right-left)/2;
        sort(arr,left,mid);
        sort(arr,mid+1,right);
        merge(arr,left,mid+1,right);
    }


    //先定义合并的方法
    static void merge(int[] arr, int leftPtr, int rightPtr, int rightBound) {
        int i = leftPtr;
        int j = rightPtr;
        int mid = rightPtr -1;
        int[] temp = new int[rightBound - leftPtr + 1];
        int tempPtr = 0;

        //进行比较赋值
        while (i&lt;=mid&amp;&amp;j&lt;=rightBound){
            if(arr[i]&gt;arr[j]){
                temp[tempPtr]=arr[j];
                j++;
                tempPtr++;
            }else {
                temp[tempPtr]=arr[i];
                i++;
                tempPtr++;
            }
        }

        //将未放入临时数组的数放入临时数组
        while(i&lt;=mid) temp[tempPtr++] = arr[i++];
        while(j&lt;=rightBound) temp[tempPtr++] = arr[j++];

        //数组复制
        for (int i1 = 0; i1 &lt; temp.length; i1++) {
            arr[leftPtr+i1]=temp[i1];
        }
    }
}</code></pre> 
<h2>六、快速排序</h2> 
<p>我们从数组中选择一个元素，我们把这个元素称之为<strong>中轴元素</strong>吧，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是<strong>有序的</strong>。也就是说，我们无需再移动中轴元素的位置。</p> 
<p>从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素都处于<strong>有序的位置</strong>。</p> 
<p>为方便理解我还准备了动图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b7/db/h9zfCjC4_o.gif"></p> 
<pre><code class="language-java">public class QuickSort {

    public static void main(String[] args) {
        int[] arr = {1,5,7,6,4};
        sort(arr,0,arr.length-1);

        CommonUtils.print(arr);
    }

    static void sort(int[] arr, int leftBound, int rightBound) {
        if(leftBound&gt;=rightBound) {
            return;
        }
        int mid = partition(arr, leftBound, rightBound);
        sort(arr,leftBound,mid-1);
        sort(arr,mid+1,rightBound);
    }

    static int partition(int[] arr, int leftBound, int rightBound) {
        int left = leftBound;
        int mid = rightBound;
        int right = rightBound-1;

        while (left&lt;=right){
            //1、这两个指针分别寻找小于标杆和大于标杆的数，找到以后指针停止
            //2、交换两边指针停止位置的数
            //3、将标杆放到中间的位置
            while (left&lt;=right&amp;&amp;arr[left]&lt;=arr[mid]){
                left++;
            }
            while (left&lt;=right&amp;&amp;arr[right]&gt;arr[mid]){
                right--;
            }
            if(left&lt;right){
                CommonUtils.swap(arr,left,right);
            }
        }
        //把标杆放中间
        CommonUtils.swap(arr,left,rightBound);
        return left;
    }
}</code></pre> 
<h2>七、计数排序</h2> 
<p>计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。</p> 
<p>基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。</p> 
<p>为方便理解我还准备了动图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/be/f7/SXeVBhFu_o.gif"></p> 
<pre><code class="language-java">public class CountSort {
    public static void main(String[] args) {

        int[] arr = {2, 4, 2, 3, 7, 1, 1, 0, 0, 5, 6, 9, 8, 5, 7, 4, 0, 9};

        int[] result = sort(arr);

        CommonUtils.print(result);

    }
    public static int[] sort(int[] arr) {
        int[] temp = new int[10];
        for (int a : arr) {
            temp[a]++;
        }

        int[] result = new int[arr.length];
        int r = 0;
        for (int i = 0; i &lt; temp.length; i++) {

            while (temp[i]&gt;0){
                result[r]=i;
                r++;
                temp[i]--;
            }
        }
        return result;
    }
}</code></pre> 
<h2>八、桶排序</h2> 
<p>桶排序就是把最大值和最小值之间的数进行瓜分，例如分成  10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去，再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。</p> 
<p>之后每个桶里面的数据就是有序的了，我们在进行合并汇总。</p> 
<p>为方便理解我还准备了图片：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f8/a8/xsGBZRQw_o.jpg"></p> 
<pre><code class="language-java">public class BucketSort {

    public static void main(String[] args) {

        int[] arr = {2, 4, 2, 3, 7,0};

        int[] result = sort(arr);

        CommonUtils.print(result);

    }

    public static int[] sort(int[] arr) {
        int max = findMax(arr);
        int mini = findMini(arr);
        int group = (max-mini)/5+1;
        List&lt;List&lt;Integer&gt;&gt; totalBucket = new LinkedList&lt;&gt;();

        //初始化桶
        for (int i = 0; i &lt; group; i++) {
            totalBucket.add(new LinkedList&lt;Integer&gt;());
        }

        for (int i = 0; i &lt; arr.length; i++) {
            //得到所在区间
            int i1 = (arr[i] - mini) / (max - mini);
            //向所在区间添加元素
            totalBucket.get(i1).add(arr[i]);
        }

        //复制结果
        for (List&lt;Integer&gt; integers : totalBucket) {
            Collections.sort(integers);
        }




        //复制结果
        int[] result = new int[arr.length];
        int r = 0;
        for (int i = 0; i &lt; totalBucket.size(); i++) {
            for (int i1 = 0; i1 &lt; totalBucket.get(i).size(); i1++) {
                result[r]= totalBucket.get(i).get(i1);
                r++;
            }
        }
        return result;
    }

    public static int findMax(int[] arr) {
        int max = arr[0];
        for (int i : arr) {
            if(i&gt;max){
                max = i;
            }
        }
        return max;
    }

    public static int findMini(int[] arr) {
        int mini = arr[0];
        for (int i : arr) {
            if(i&lt;mini){
                mini = i;
            }
        }
        return mini;
    }
}</code></pre> 
<h2>九、基数排序</h2> 
<p>基数排序的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……</p> 
<p>排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。</p> 
<p>由于某位数（个位/十位….，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了</p> 
<p>为方便理解我还准备了动图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/80/2a/ij8a9yhj_o.gif"></p> 
<pre><code class="language-java">public class RadioSort {
    public static void main(String[] args) {
        int[] arr = {5, 3, 6, 8, 100, 7, 9, 4, 20};
        sort(arr);
        CommonUtils.print(arr);
    }

    public static int[] sort(int[] arr) {
       if(arr==null||arr.length==2) {
           return arr;
       }
       int max = findMax(arr);
       int num = 1;
       while (max/10&gt;0){
           max= max/10;
           num++;
       }

        List&lt;List&lt;Integer&gt;&gt; totalBucket = new LinkedList&lt;&gt;();

        //初始化桶
        for (int i = 0; i &lt; 10; i++) {
            totalBucket.add(new LinkedList&lt;Integer&gt;());
        }
        for (int i = 0; i &lt; num; i++) {
            //放入对应的桶
            for (int j = 0; j &lt; arr.length; j++) {
                int location = (arr[j] / (int)Math.pow(10,i)) % 10;
                totalBucket.get(location).add(arr[j]);
            }


            int k = 0;
            for (List&lt;Integer&gt; integers : totalBucket) {
                for (Integer integer : integers) {
                    arr[k++]=integer;
                }
                integers.clear();
            }


        }



        return arr;
    }


    public static int findMax(int[] arr) {
        int max = arr[0];
        for (int i : arr) {
            if(i&gt;max){
                max = i;
            }
        }
        return max;
    }
}</code></pre> 
<h2>十、堆排序</h2> 
<p>堆的特点就是堆顶的元素是一个<strong>最值</strong>，大顶堆的堆顶是最大值，小顶堆则是最小值。</p> 
<p>堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。</p> 
<p>为方便理解我还准备了动图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3f/0f/UJeaslAE_o.gif"></p> 
<pre><code class="language-java">public class HeadSort {
    public static void main(String[] args) {
        int[] arr = {5, 3, 6, 8, 100, 7, 9, 4, 20};
        int n = arr.length;
         //构建大顶堆
         for (int i = (n - 2) / 2; i &gt;= 0; i--) {
             sort(arr, i, n - 1);
         }

         //进行堆排序
        for (int i = n - 1; i &gt;= 1; i--) {
            // 把堆顶元素与最后一个元素交换
            int temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            // 把打乱的堆进行调整，恢复堆的特性
            sort(arr, 0, i - 1);
         }

        CommonUtils.print(arr);
    }


    public static void sort(int[] arr,int parent, int n) {
        int child = 2*parent+1;

        while (child&lt;n){

            //如果右节点大于左节点这把指针只想左节点
            if(child+1&lt;n&amp;&amp;arr[child]&lt;arr[child+1]){
                child++;
            }
            //比较子节点和父节点的大小
            if(arr[child]&gt;arr[parent]){
                CommonUtils.swap(arr,child,parent);
            }
            parent = child;
            child = 2*parent+1;
        }
    }

}
</code></pre> 
<p></p> 
<h2></h2> 
<h2>总结</h2> 
<h3>公共代码：</h3> 
<pre><code class="language-java">public class CommonUtils {
   public static void print(int[] arr) {
        for(int i=0; i&lt;arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
   }


    public  static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}</code></pre> 
<h3>性质：</h3> 
<p>用一张图汇总了10大排序算法的性质</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/81/7b/il55aZPP_o.jpg"></p> 
<p></p> 
<p></p> 
<h2>参考文章：</h2> 
<p><a href="https://blog.csdn.net/weixin_51609435/article/details/122982075" title="堆排序详细图解（通俗易懂）_右大臣的博客-CSDN博客">堆排序详细图解（通俗易懂）_右大臣的博客-CSDN博客</a></p> 
<p><a href="https://www.cnblogs.com/itsharehome/p/11058010.html" rel="nofollow" title="https://www.cnblogs.com/itsharehome/p/11058010.html">https://www.cnblogs.com/itsharehome/p/11058010.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04e13a0ef90ea69c6fbb95e37f73aab8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据湖Iceberg介绍和使用(集成Hive、SparkSQL、FlinkSQL)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab29768572a491e759204e79fb4692d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023年最新IDEA中 Java程序 | Java&#43;Kotlin混合开发的程序如何打包成jar包和exe文件(gradle版本)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>