<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pg数据库和mysql区别 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b4d5e9defb824a3c26e0590dc140bfb8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="pg数据库和mysql区别">
  <meta property="og:description" content="区别一 PostgreSQL (通常称为 PG) 和 MySQL 都是广泛使用的关系型数据库管理系统 (RDBMS)。虽然它们都是用于存储和管理数据的关系数据库，但它们在一些方面有很大的区别，如下所述：
数据类型：PostgreSQL 支持更多的数据类型，如范围类型、网络地址类型、JSON 和 XML 数据类型等，而 MySQL 则不支持这些类型。
扩展性：PostgreSQL 具有很高的扩展性，可以使用自定义数据类型、函数和操作符来扩展其功能。而 MySQL 的扩展性较差，需要使用插件或存储过程来实现类似的功能。
ACID 兼容性：PostgreSQL 是完全 ACID 兼容的数据库，而 MySQL 只在特定的存储引擎 (如 InnoDB) 中支持 ACID。
多版本并发控制 (MVCC)：PostgreSQL 使用 MVCC 来提供高级事务隔离级别，这意味着多个事务可以同时读取和写入数据库，而不会相互干扰。MySQL 也支持 MVCC，但其实现方式不同。
存储引擎：MySQL 支持多个存储引擎，包括 MyISAM 和 InnoDB 等。每种存储引擎都有自己的特点和优缺点。PostgreSQL 仅支持单个存储引擎。
SQL 标准兼容性：PostgreSQL 更加符合 SQL 标准，而 MySQL 在某些方面采用了自己的实现方式。
性能：在一些特定的使用场景下，MySQL 的性能可能更好。但在复杂的查询和高并发的情况下，PostgreSQL 可能表现更好。
总之，PG 和 MySQL 都是出色的关系型数据库管理系统，具有不同的特点和优劣。选择哪个取决于具体的需求和使用场景。
区别二 简介
PostgreSQL
PostgreSQL是一个开源的关系型数据库管理系统，以其高度的可扩展性、ACID兼容性（支持原子性、一致性、隔离性和持久性）以及丰富的功能集而闻名。它支持多种操作系统，包括Linux、Windows、Mac OS等，而且具有强大的社区支持。 MySQL
MySQL也是一个开源的关系型数据库管理系统，其特点在于速度快、易于使用以及广泛的社区支持。它最初是由瑞典的开发者创建的，后来被Sun Microsystems收购，现在隶属于Oracle。
适用场景
PostgreSQL
复杂查询和事务处理：PostgreSQL在处理复杂查询和大量事务时表现出色，适用于需要高度数据完整性和一致性的应用程序，如金融系统或企业级应用。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-11T23:21:50+08:00">
    <meta property="article:modified_time" content="2024-03-11T23:21:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pg数据库和mysql区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>区别一</h2> 
<p>PostgreSQL (通常称为 PG) 和 MySQL 都是广泛使用的关系型数据库管理系统 (RDBMS)。虽然它们都是用于存储和管理数据的关系数据库，但它们在一些方面有很大的区别，如下所述：</p> 
<ol><li> <p>数据类型：PostgreSQL 支持更多的数据类型，如范围类型、网络地址类型、JSON 和 XML 数据类型等，而 MySQL 则不支持这些类型。</p> </li><li> <p>扩展性：PostgreSQL 具有很高的扩展性，可以使用自定义数据类型、函数和操作符来扩展其功能。而 MySQL 的扩展性较差，需要使用插件或存储过程来实现类似的功能。</p> </li><li> <p>ACID 兼容性：PostgreSQL 是完全 ACID 兼容的数据库，而 MySQL 只在特定的存储引擎 (如 InnoDB) 中支持 ACID。</p> </li><li> <p>多版本并发控制 (MVCC)：PostgreSQL 使用 MVCC 来提供高级事务隔离级别，这意味着多个事务可以同时读取和写入数据库，而不会相互干扰。MySQL 也支持 MVCC，但其实现方式不同。</p> </li><li> <p>存储引擎：MySQL 支持多个存储引擎，包括 MyISAM 和 InnoDB 等。每种存储引擎都有自己的特点和优缺点。PostgreSQL 仅支持单个存储引擎。</p> </li><li> <p>SQL 标准兼容性：PostgreSQL 更加符合 SQL 标准，而 MySQL 在某些方面采用了自己的实现方式。</p> </li><li> <p>性能：在一些特定的使用场景下，MySQL 的性能可能更好。但在复杂的查询和高并发的情况下，PostgreSQL 可能表现更好。</p> </li></ol> 
<p>总之，PG 和 MySQL 都是出色的关系型数据库管理系统，具有不同的特点和优劣。选择哪个取决于具体的需求和使用场景。</p> 
<h2><a id="_19"></a>区别二</h2> 
<ol><li>简介<br> PostgreSQL<br> PostgreSQL是一个开源的关系型数据库管理系统，以其高度的可扩展性、ACID兼容性（支持原子性、一致性、隔离性和持久性）以及丰富的功能集而闻名。它支持多种操作系统，包括Linux、Windows、Mac OS等，而且具有强大的社区支持。</li></ol> 
<p>MySQL<br> MySQL也是一个开源的关系型数据库管理系统，其特点在于速度快、易于使用以及广泛的社区支持。它最初是由瑞典的开发者创建的，后来被Sun Microsystems收购，现在隶属于Oracle。</p> 
<ol start="2"><li>适用场景<br> PostgreSQL<br> 复杂查询和事务处理：PostgreSQL在处理复杂查询和大量事务时表现出色，适用于需要高度数据完整性和一致性的应用程序，如金融系统或企业级应用。<br> 地理信息系统（GIS）：PostGIS是一个用于地理空间对象的开源空间数据库扩展，使得PostgreSQL成为处理地理信息的首选。<br> 大数据和数据仓库：PostgreSQL的分区表、并行查询和流复制等功能，使其成为处理大数据和数据仓库方面的强力工具。<br> MySQL<br> Web应用程序：由于其高性能和易用性，MySQL是许多Web应用程序的首选数据库，特别是在需要处理大量读操作的情况下。<br> 小型企业应用：对于规模相对较小的企业应用程序，MySQL提供了一个稳定、经济高效的解决方案。<br> 快速开发和迭代：MySQL具有较低的学习曲线，因此适用于快速开发和迭代的项目。</li><li>性能比较<br> PostgreSQL<br> 复杂查询和事务：PostgreSQL在处理复杂查询和高并发事务时表现出色，这得益于其MVCC（多版本并发控制）实现。<br> 扩展性：具有良好的扩展性，可以通过添加额外的节点来提高性能。<br> MySQL<br> 读取性能：MySQL在处理大量读操作时表现优异，尤其是在使用索引时。<br> 写入性能：MySQL的写入性能也很好，但在某些情况下可能会受到锁的影响。</li><li>数据模型和功能<br> PostgreSQL<br> 复杂数据类型：支持诸如数组、JSON、XML等复杂数据类型，使其适用于处理半结构化数据。<br> 触发器和存储过程：提供了强大的触发器和存储过程功能，使得可以在数据库层面实现复杂的业务逻辑。<br> MySQL<br> 简单而高效的索引：MySQL提供了简单但高效的索引机制，可以很好地支持大量的读操作。<br> 存储引擎：MySQL支持多种存储引擎，例如InnoDB、MyISAM等，可以根据应用程序的需求选择最合适的引擎。</li><li>安全性<br> PostgreSQL<br> 高级安全性功能：PostgreSQL提供了诸如行级安全、列级安全等高级安全功能，可以帮助您更好地保护数据。<br> SSL支持：提供了SSL支持，确保数据在传输过程中的安全性。<br> MySQL<br> 基本安全功能：MySQL也提供了基本的安全功能，但相对于PostgreSQL来说可能略显简单。<br> SSL支持：和PostgreSQL一样，MySQL也支持SSL。</li><li>总结和选择指南<br> 在选择适合您项目的数据库时，需要考虑以下几点：</li></ol> 
<p>数据模型和功能需求：如果您的应用需要复杂的数据模型和强大的功能集，PostgreSQL可能是更好的选择。<br> 性能需求：根据应用程序的读写比例和事务处理需求，选择合适的数据库以保证性能。<br> 安全性需求：如果数据安全对您的应用至关重要，您可能会更倾向于选择PostgreSQL。<br> 开发团队熟悉度：考虑开发团队的经验和熟悉度，以便选择一个他们能够高效利用的数据库。</p> 
<p>函数区别</p> 
<p>文章目录<br> 一、格式区别<br> 二、符号区别<br> 三、自增区别<br> 四、函数区别<br> 五、数据类型转化（针对于PostgreSQL）</p> 
<p>首先PostgreSQL有一个模式的概念。<br> 一、格式区别<br> 和Oracle一样,PostgreSQL也是严格区分大小写。<br> 1<br> 二、符号区别<br> 和Oracle一样PostgreSQL中，" " 双引号是区分库名，关键字等，而MySQL则是反单引号(tab键上方的键)，pg查询时字符类型的字段必须使用单引号，而MySQL带有优化器（不是必须）。<br> 1<br> 三、自增区别<br> MySQL中使用auto_increment ，在需要的列指定自增，而pg中需要设置自增序列。</p> 
<p>（1）使用SQL语句<br> ①创建表时</p> 
<pre><code class="prism language-bash">CREATE table infisa_template_config<span class="token punctuation">(</span>id serial <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>②表已存在</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>--设置序列从1开始，自增1--<span class="token operator">&gt;</span>
CREATE SEQUENCE user_id_seq START WITH <span class="token number">1</span>  
INCREMENT BY <span class="token number">1</span>  NO MINVALUE  NO MAXVALUE  CACHE <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>--设置序列--<span class="token operator">&gt;</span>
ALTER table user ALTER <span class="token function">column</span> <span class="token function">id</span> SET DEFAULT nextval<span class="token punctuation">(</span><span class="token string">'user_id_seq'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>(2)使用可视化工具<br> 连接navicat15（或者使用DBeaver）</p> 
<p>点击序列</p> 
<p>可以通过可视化界面新建序列</p> 
<p>注：同步数据的话，推荐通过sql方式新建序列。</p> 
<p>四、函数区别<br> (1)时间转化</p> 
<pre><code class="prism language-sql">①时间转字符串：

MySQL: date_format<span class="token punctuation">(</span>a<span class="token punctuation">.</span>tag_create_date<span class="token punctuation">,</span>‘<span class="token operator">%</span>Y<span class="token operator">-</span><span class="token operator">%</span>m<span class="token operator">-</span><span class="token operator">%</span>d <span class="token operator">%</span>H:<span class="token operator">%</span>i:<span class="token operator">%</span>s’<span class="token punctuation">)</span>

PostgreSQL: to_char<span class="token punctuation">(</span>a<span class="token punctuation">.</span>tag_create_date<span class="token punctuation">,</span>‘yyyy<span class="token operator">-</span>mm<span class="token operator">-</span>dd HH:MM:SS’<span class="token punctuation">)</span>

②字符串转时间：

MySQL: date_format<span class="token punctuation">(</span>a<span class="token punctuation">.</span>tag_create_date<span class="token punctuation">,</span>‘<span class="token operator">%</span>Y<span class="token operator">-</span><span class="token operator">%</span>m<span class="token operator">-</span><span class="token operator">%</span>d <span class="token operator">%</span>H:<span class="token operator">%</span>i:<span class="token operator">%</span>s’<span class="token punctuation">)</span>

PostgreSQL: to_date<span class="token punctuation">(</span>a<span class="token punctuation">.</span>tag_create_date<span class="token punctuation">,</span>‘yyyy<span class="token operator">-</span>mm<span class="token operator">-</span>dd HH:MM:SS’<span class="token punctuation">)</span>
</code></pre> 
<p>(2) IFNULL()函数</p> 
<pre><code class="prism language-bash">MySQL: IFNULL<span class="token punctuation">(</span>a.idm,‘’<span class="token punctuation">)</span>

PostgreSQL: COALESCE<span class="token punctuation">(</span>a.id,‘’<span class="token punctuation">)</span>
</code></pre> 
<p>(3) sysdate()函数</p> 
<pre><code class="prism language-bash">MySQL: SELECT sysdate<span class="token punctuation">(</span><span class="token punctuation">)</span>

PostgreSQL: SELECT now<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>(4) find_in_set()函数（允许在逗号分隔的字符串列表中查找指定字符串的位置）</p> 
<pre><code class="prism language-bash">MySQL: SELECT t.dept_id FROM sys_dept t WHERE find_in_set<span class="token punctuation">(</span>‘100’, ancestors<span class="token punctuation">)</span>

PostgreSQL: SELECT t.dept_id FROM sys_dept t WHERE ‘100’ <span class="token operator">=</span> ANY <span class="token punctuation">(</span>string_to_array<span class="token punctuation">(</span>ancestors, ‘,’<span class="token punctuation">))</span>
</code></pre> 
<p>(5)group_concat()函数</p> 
<pre><code class="prism language-bash">MySQL: <span class="token keyword">select</span> a.name,group_concat<span class="token punctuation">(</span>distinct city<span class="token punctuation">)</span>from user_city a group by a.name<span class="token punctuation">;</span>

PostgreSQL: <span class="token keyword">select</span> a.name,array_to_string<span class="token punctuation">(</span>array_agg<span class="token punctuation">(</span>distinct a.city<span class="token punctuation">)</span>,‘,’<span class="token punctuation">)</span>from user_city a group by a.name<span class="token punctuation">;</span>
</code></pre> 
<p>(6)LIMIT</p> 
<pre><code class="prism language-bash">MySQL: <span class="token keyword">select</span> id,name from hospital.ods_user_basic limit <span class="token number">10,2</span><span class="token punctuation">;</span>

PostgreSQL: <span class="token keyword">select</span> id,name from hospital.ods_user_basic limit <span class="token number">10</span> offset <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> 
<p>（7）DISTINCT</p> 
<pre><code class="prism language-bash">MYSQL: <span class="token keyword">select</span> DISTINCT b.id from hospital.ods_user_basic as b

PostgreSQL: <span class="token keyword">select</span> DISTINCT ON <span class="token punctuation">(</span>b.id<span class="token punctuation">)</span> b.* from hospital.ods_user_basic as b

<span class="token punctuation">(</span>注：pg中祛重+排序 ，使用distinct on <span class="token punctuation">(</span>列1<span class="token punctuation">)</span> order by 列1 <span class="token punctuation">)</span>
</code></pre> 
<p>（8）MyBatis-Plus整合MySQL、PostgreSQL，LIKE使用<br> MySQL：</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>select <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"checkReportPage"</span> <span class="token assign-left variable">resultMap</span><span class="token operator">=</span><span class="token string">"reportResultMap"</span><span class="token operator">&gt;</span>
   SELECT
   *
   FROM
   infisa_medical_report
   WHERE <span class="token assign-left variable">is_deleted</span><span class="token operator">=</span><span class="token number">0</span> AND status <span class="token operator">=</span> <span class="token number">1</span> AND name LIKE concat<span class="token punctuation">(</span><span class="token string">'%'</span>,<span class="token comment">#{handleTask.name},'%')</span>
<span class="token operator">&lt;</span>/select<span class="token operator">&gt;</span>
</code></pre> 
<p>PostgreSQL:</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>select <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"checkReportPage"</span> <span class="token assign-left variable">resultMap</span><span class="token operator">=</span><span class="token string">"reportResultMap"</span><span class="token operator">&gt;</span>
   SELECT
   *
   FROM
   infisa_medical_report
   WHERE <span class="token assign-left variable">is_deleted</span><span class="token operator">=</span><span class="token number">0</span> AND status <span class="token operator">=</span> <span class="token number">1</span> AND name like concat<span class="token punctuation">(</span><span class="token string">'%'</span>,<span class="token comment">#{handleTask.name}::varchar,'%')</span>
<span class="token operator">&lt;</span>/select<span class="token operator">&gt;</span>
</code></pre> 
<p>（注：pg必须指定模糊查询列的数据类型，否则会报错）</p> 
<p>五、数据类型转化（针对于PostgreSQL）<br> MySQL、Oracle等都是默认对数据类型进行了隐式的转换，在其他数据库varchar等字符串类型和数字可以进行自动的隐式转换，但是PG确没有这么处理，官方文档中也有针对pg的数据转换方式。</p> 
<p>解决办法：<br> ①强转（在查询字段上指定数据类型）</p> 
<pre><code class="prism language-bash">a.a1 <span class="token operator">=</span> b.b1::int8 或者 a.a1::varchar <span class="token operator">=</span> b.b1
</code></pre> 
<p>②隐式类型转化（创建类型转换）</p> 
<pre><code class="prism language-bash">–注:创建cast需要有pg_cast系统表的权限
–注:当创建类型转换使用自动隐式转换的话如果出现多个匹配的转换此时pg会因为不知道选择哪一个去处理类型转换而报错，
–如果出现多个隐式自动转换都匹配此时还是需要手动添加转换以达到效果，或者删除多余的类型转换
CREATE CAST <span class="token punctuation">(</span>INTEGER AS VARCHAR<span class="token punctuation">)</span> WITH INOUT AS IMPLICIT<span class="token punctuation">;</span>
CREATE CAST <span class="token punctuation">(</span>VARCHAR AS INTEGER<span class="token punctuation">)</span> WITH INOUT AS IMPLICIT<span class="token punctuation">;</span>
CREATE CAST <span class="token punctuation">(</span>BIGINT AS VARCHAR<span class="token punctuation">)</span> WITH INOUT AS IMPLICIT<span class="token punctuation">;</span>
CREATE CAST <span class="token punctuation">(</span>VARCHAR AS BIGINT<span class="token punctuation">)</span> WITH INOUT AS IMPLICIT<span class="token punctuation">;</span>
</code></pre> 
<p>附：<br> ③查询当前类型转化：</p> 
<pre><code class="prism language-bash">–这个查询是当前所有的CAST，具体字段的定义同样可以参阅PG数据库官方文档里的描述
<span class="token keyword">select</span>
<span class="token punctuation">(</span>select typname from pg_type where oid <span class="token operator">=</span> t.castsource<span class="token punctuation">)</span> as “castsource”,
<span class="token punctuation">(</span>select typname from pg_type where oid <span class="token operator">=</span> t.casttarget<span class="token punctuation">)</span> as “casttarget”,
castcontext,
castmethod
from pg_cast as t
</code></pre> 
<p>④删除类型转化：</p> 
<pre><code class="prism language-bash">DROP CAST <span class="token punctuation">(</span>varchar as bigint<span class="token punctuation">)</span><span class="token punctuation">;</span> DROP CAST <span class="token punctuation">(</span>bigint as varchar<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa55493d630c2132fc2840678ba18bfc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java各种规则引擎</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f6e68a434fe32fc6378ce9d932dba12/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解码人工智能的幽默：理解其背后的误解与挑战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>