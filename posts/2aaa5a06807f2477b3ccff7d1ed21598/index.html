<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;初阶：类和对象（二） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2aaa5a06807f2477b3ccff7d1ed21598/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;初阶：类和对象（二）">
  <meta property="og:description" content="✨✨所属专栏：C&#43;&#43;✨✨
✨✨作者主页：嶔某✨✨
类的默认成员函数 默认成员函数就是用户没有显式实现，编译器会⾃动⽣成的成员函数称为默认成员函数。⼀个类，我们不写的情况下编译器会默认⽣成以下6个默认成员函数，需要注意的是这6个中最重要的是前4个，最后两个取地址重载不重要，我们稍微了解⼀下即可。
其次就是C&#43;&#43;11以后还会增加两个默认成员函数，移动构造和移动赋值，这个我们后⾯再学习。默认成员函数很重要，也⽐较复杂，我们要从两个⽅⾯去学习：
• 第⼀：我们不写时，编译器默认⽣成的函数⾏为是什么，是否满⾜我们的需求？
• 第⼆：编译器默认⽣成的函数不满⾜我们的需求，我们需要⾃⼰实现，那么如何⾃⼰实现？
初始化和清理 构造函数 构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是构造函数的主要任务并不是开空间创建对象(我们常使⽤的局部对象是栈帧创建时，空间就开好了)，⽽是对象实例化时初始化对象。构造函数的本质是要替代我们以前Stack和Date类中写的Init函数的功能，构造函数⾃动调⽤的特点就完美的替代的了Init。
1. 函数名与类名相同。
2. ⽆返回值。(返回值啥都不需要给，也不需要写void，C&#43;&#43;规定如此)
3. 对象实例化时系统会⾃动调⽤对应的构造函数。
4. 构造函数可以重载。
5. 如果类中没有显式定义构造函数，则C&#43;&#43;编译器会⾃动⽣成⼀个⽆参的默认构造函数，⼀旦用户显式定义编译器将不再⽣成。
6. ⽆参构造函数、全缺省构造函数、我们不写构造时编译器默认⽣成的构造函数，都叫做默认构造函数。但是这三个函数有且只有⼀个存在，不能同时存在。零参构造（不用传参数的构造函数） == 默认构造
class Date { public: // 1.⽆参构造函数（是默认构造） /*Date() { _year = 1; _month = 1; _day = 1; }*/ // 2.带参构造函数（不是默认构造） /*Date(int year, int month, int day) { _year = year; _month = month; _day = day; }*/ // 3.全缺省构造函数（是默认构造） Date(int year = 1, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; 7.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T17:08:08+08:00">
    <meta property="article:modified_time" content="2024-07-15T17:08:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;初阶：类和对象（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><img alt="" height="676" src="https://images2.imgbox.com/fc/08/HDCdlJuC_o.jpg" width="1024"></p> 
 <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> 
 <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> 
</blockquote> 
<h2>类的默认成员函数</h2> 
<p>默认成员函数就是用户没有显式实现，编译器会⾃动⽣成的成员函数称为默认成员函数。⼀个类，我们不写的情况下编译器会默认⽣成以下<strong>6个默认成员函数</strong>，需要注意的是这6个中最重要的是前4个，最后两个取地址重载不重要，我们稍微了解⼀下即可。<img alt="" height="790" src="https://images2.imgbox.com/e8/2f/MqBaNHhf_o.png" width="1200"></p> 
<p>  其次就是C++11以后还会增加两个默认成员函数，<strong>移动构造和移动赋值</strong>，这个我们后⾯再学习。默认成员函数很重要，也⽐较复杂，我们要从两个⽅⾯去学习：</p> 
<blockquote> 
 <p>• 第⼀：我们不写时，编译器默认⽣成的函数⾏为是什么，是否满⾜我们的需求？<br> • 第⼆：编译器默认⽣成的函数不满⾜我们的需求，我们需要⾃⼰实现，那么如何⾃⼰实现？</p> 
</blockquote> 
<h3>初始化和清理</h3> 
<h4>构造函数</h4> 
<blockquote> 
 <p>构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是<span style="color:#be191c;"><strong>构造函数的主要任务并不是开空间创建对象(我们常使⽤的局部对象是栈帧创建时，空间就开好了)</strong></span>，⽽是对象实例化时<strong>初始化对象</strong>。构造函数的本质是要替代我们以前Stack和Date类中写的Init函数的功能，构造函数⾃动调⽤的特点就完美的替代的了Init。</p> 
</blockquote> 
<p>1. 函数名与类名相同。<br> 2. ⽆返回值。(返回值啥都不需要给，也不需要写void，C++规定如此)<br> 3. 对象实例化时系统会⾃动调⽤对应的构造函数。<br> 4. 构造函数可以重载。<br> 5. 如果类中没有显式定义构造函数，则C++编译器会⾃动⽣成⼀个⽆参的默认构造函数，⼀旦用户显式定义编译器将不再⽣成。<br> 6. ⽆参构造函数、全缺省构造函数、我们不写构造时编译器默认⽣成的构造函数，<strong>都叫做默认构造函数。</strong>但是这三个函数有且只有⼀个存在，<strong>不能同时存在</strong>。零参构造（不用传参数的构造函数） == 默认构造</p> 
<pre><code class="language-cpp">class Date
{
public:
	// 1.⽆参构造函数（是默认构造）
	/*Date()
	{
		_year = 1;
		_month = 1;
		_day = 1;
	}*/
	// 2.带参构造函数（不是默认构造）
	/*Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}*/
	// 3.全缺省构造函数（是默认构造）
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};</code></pre> 
<p>7. 我们不写，编译器默认⽣成的构造，对内置类型成员变量（int double char……）的初始化没有要求，也就是说是是否初始化是不确定的，看编译器。对于⾃定义类型成员变量（class struct……） ，要求调⽤这个成员变量的默认构造函数初始化。如果这个成员变量没有默认构造函数，那么就会报错。这时我们要初始化这个成员变量，需要⽤<strong>初始化列表</strong>才能解决。</p> 
<pre><code class="language-cpp">typedef int STDataType;
class Stack
{
public :
	Stack(int n = 4)
	{
		_a = (STDataType*)malloc(sizeof(STDataType) * n);
		if (nullptr == _a)
		{
			perror("malloc申请空间失败");
			return;
		} _
			capacity = n;
		_top = 0;
	}
private:
	STDataType * _a;
	size_t _capacity;
	size_t _top;
};
// 两个Stack实现队列
class MyQueue
{
public :
	//编译器默认⽣成MyQueue的构造函数调⽤了Stack的构造，完成了两个成员的初始化
private:
	Stack pushst;
	Stack popst;
};</code></pre> 
<h4>析构函数</h4> 
<blockquote> 
 <p>析构函数与构造函数功能相反，析构函数不是完成对对象本⾝的销毁，⽐如局部对象是存在栈帧的，函数结束栈帧销毁，他就释放了，不需要我们管，C++规定对象在销毁时会⾃动调⽤析构函数，完成对象中资源的清理释放⼯作。析构函数的功能类⽐我们之前Stack实现的Destroy功能，⽽像Date没有Destroy，其实就是没有资源需要释放，所以严格说Date是不需要析构函数的。</p> 
</blockquote> 
<p>1. 析构函数名是在类名前加上字符~。<br> 2. ⽆参数⽆返回值。(这⾥跟构造类似，也不需要加void)<br> 3. <strong>⼀个类只能有⼀个析构函数</strong>。若未显式定义，系统会<strong>⾃动⽣成默认的析构函数。</strong><br> 4. 对象⽣命周期结束时，系统会⾃动调⽤析构函数。<br> 5. 和构造函数类似，<strong>我们不写编译器⾃动⽣成的析构函数对内置类型成员不做处理，⾃定类型成员会调⽤他的析构函数。</strong><br> 6. 还需要注意的是我们显示写析构函数，对于⾃定义类型成员也会调⽤他的析构，也就是说<strong>⾃定义类型成员⽆论什么情况都会⾃动调⽤析构函数。</strong><br> 7. 如果类中没有<strong>申请资源（malloc）</strong>时，析构函数可以不写，直接使⽤编译器⽣成的默认析构函数，如Date；如果默认⽣成的析构就可以⽤，也就不需要显⽰写析构，如MyQueue（调用了Stack的析构函数）；但是有资源申请时，⼀定要⾃⼰写析构，否则会造成资源（内存）泄漏，如Stack。<br> 8. <strong>⼀个局部域的多个对象，C++规定后定义的先析构。</strong></p> 
<pre><code class="language-cpp">	~Stack()
	{
		free(_a);
		_a = nullptr;
		_capacity = _top = 0;
	}</code></pre> 
<h3>拷贝复制</h3> 
<h4>拷贝构造函数</h4> 
<blockquote> 
 <p>如果⼀个构造函数的<span style="color:#be191c;"><strong>第⼀个参数是⾃⾝类类型的引⽤，</strong></span><strong><span style="color:#be191c;">且任何额外的参数都有默认值</span></strong>，则此构造函数也叫做拷⻉构造函数，也就是说拷⻉构造是⼀个特殊的构造函数。</p> 
</blockquote> 
<p>1. 拷⻉构造函数<strong>是构造函数的⼀个重载</strong>。<br> 2. 拷⻉构造函数的参数只有⼀个且必须是类类型对象的引⽤，使⽤<strong>传值⽅式</strong>编译器直接报错，因为<span style="color:#be191c;"><strong>语法逻辑上会引发⽆穷递归调⽤。</strong></span><br> 3. C++规定⾃定义类型对象进⾏拷⻉⾏为必须调⽤拷⻉构造，所以这⾥<span style="color:#be191c;"><strong>⾃定义类型传值传参和传值返回都会调⽤拷⻉构造完成，所以这里会引发无穷递归。</strong></span></p> 
<pre><code class="language-cpp">	date(date d)//E0408	类 "date" 的复制构造函数不能带有 "date" 类型的参数
	{	
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}</code></pre> 
<p>4. 若未显式定义拷⻉构造，编译器会⽣成⾃动⽣成拷⻉构造函数。⾃动⽣成的拷⻉构造对内置类型成员变量会完成<strong>值拷⻉/浅拷⻉(⼀个字节⼀个字节的拷⻉)</strong>，对⾃定义类型成员变量会调⽤他的拷⻉构造。<br> 5. 像Date这样的类成员变量全是内置类型且没有指向什么资源，编译器⾃动⽣成的拷⻉构造就可以完成需要的拷⻉，所以不需要我们显⽰实现拷⻉构造。像Stack这样的类，虽然也都是内置类型，但是_a指向了资源，编译器⾃动⽣成的拷⻉构造完成的值拷⻉/浅拷⻉不符合我们的需求，所以需要我们⾃⼰实现深拷⻉(对指向的资源也进⾏拷⻉)。像MyQueue这样的类型内部主要是⾃定义类型Stack成员，编译器⾃动⽣成的拷⻉构造会调⽤Stack的拷⻉构造，也不需要我们显⽰实现<br> MyQueue的拷⻉构造。</p> 
<pre><code class="language-cpp">	Stack(const Stack&amp; s)
	{
		_a = (STDataType*)malloc(sizeof(STDataType) * s._capacity);
		if (_a != nullptr)
		{
			perror("maollc is fail");
			return;
		}
		memcpy(_a, s._a, sizeof(STDataType) * s._top);
		_capacity = s._capacity;
		_top = s._top;
	}</code></pre> 
<p>6. 传值返回会产⽣⼀个临时对象调⽤拷⻉构造，传值引⽤返回，返回的是返回对象的别名(引⽤)，没有产⽣拷⻉。<strong>但是如果返回对象是⼀个当前函数局部域的局部对象，函数结束就销毁了，那么使⽤引⽤返回是有问题的，这时的引⽤相当于⼀个野引⽤，类似⼀个野指针⼀样。传引⽤返回可以减少拷⻉，<span style="color:#be191c;">但是⼀定要确保返回对象，在当前函数结束后还在，才能⽤引⽤返回。</span></strong></p> 
<h4>赋值重载</h4> 
<h5>运算符重载</h5> 
<p>• 当运算符被⽤于类类型的对象时，C++语⾔<strong>允许我们通过运算符重载的形式指定新的含义</strong>。C++规定类类型对象使⽤运算符时，必须转换成调⽤对应运算符重载，若没有对应的运算符重载，则会编译报错。<br> • 运算符重载是具有特名字的函数，他的名字是<strong>由operator和后⾯要定义的运算符共同构成</strong>。和其他函数⼀样，它也具有其返回类型和参数列表以及函数体。<br> • 重载运算符函数的参数个数和该运算符作⽤的运算对象数量⼀样多。<strong>⼀元运算符有⼀个参数，⼆元运算符有两个参数，⼆元运算符的左侧运算对象传给第⼀个参数，右侧运算对象传给第⼆个参数。</strong><br> • 如果⼀个<strong>重载运算符函数是成员函数</strong>，则<strong>它的第⼀个运算对象默认传给隐式的this指针，因此运算符重载作为成员函数时，参数⽐运算对象少⼀个。</strong><br> • 运算符重载以后，其<strong>优先级和结合性</strong>与对应的<strong>内置类型运算符保持⼀致。</strong><br> • 不能通过连接语法中没有的符号来创建新的操作符：⽐如operator@。<br> • <strong>.*     ::     sizeof    ?:（三目）   .</strong>    注意以上5个运算符不能重载。</p> 
<pre><code class="language-cpp">class A
{ 
public :
void func()
{
    cout &lt;&lt; "A::func()" &lt;&lt; endl;
}
};
typedef void(A::* PF)(); //成员函数指针类型
int main()
{
	// C++规定成员函数要加&amp;才能取到函数指针
	PF pf = &amp;A::func;
	A obj;//定义A类对象obj
	// 对象调⽤成员函数指针时，使⽤.*运算符
	(obj.*pf)();
	return 0;
}</code></pre> 
<p><br> • 重载操作符⾄少有⼀个类类型参数，不能通过运算符重载改变内置类型对象的含义，如：</p> 
<pre><code class="language-cpp">	int operator+(int x, int y)
	{
		return x - y;
	}</code></pre> 
<p>• ⼀个类需要重载哪些运算符，是看哪些运算符<strong>重载后有意义</strong>，⽐如Date类重载operator-(const date&amp; d1,const date&amp; d2)就有意义，但是重载operator+(const date&amp; d1,const date&amp; d2)就没有意义，重载operator+(const date&amp; d1,int x)也是有意义的。<br> • 重载++运算符时，有前置++和后置++，运算符重载函数名都是operator++，⽆法很好的区分。<br> C++规定，<strong>后置++重载时，增加⼀个int形参（不传参数只作为区分），跟前置++构成函数重载，</strong>⽅便区分。</p> 
<pre><code class="language-cpp">date&amp; operator++()
{
    cout &lt;&lt; "前置++" &lt;&lt; endl;
    //...
    return *this;
}
date operator++(int)
{
    Date tmp;
    cout &lt;&lt; "后置++" &lt;&lt; endl;
    //...
    return tmp;
}</code></pre> 
<p>• 重载&lt;&lt;和&gt;&gt;时，需要重载为全局函数，因为重载为成员函数，this指针默认抢占了第⼀个形参位<br> 置，第⼀个形参位置是左侧运算对象，调⽤时就变成了对象&lt;&lt;cout，不符合使⽤习惯和可读性。<br> 重载为全局函数把ostream/istream放到第⼀个形参位置就可以了，第⼆个形参位置当类类型对<br> 象。</p> 
<pre><code class="language-cpp">class date
{
	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const date&amp; d);
private:
	int _year;
	int _month;
	int _day;
};

ostream&amp; operator&lt;&lt;(ostream&amp; out,const date&amp; d)
{
	out &lt;&lt; d._year &lt;&lt; " " &lt;&lt; d._month &lt;&lt; " " &lt;&lt; d._day &lt;&lt; endl;
	return out;
}</code></pre> 
<h5>赋值运算符重载</h5> 
<blockquote> 
 <p>赋值运算符重载是⼀个默认成员函数，<strong>⽤于完成两个<span style="color:#be191c;">已经存在的对象</span>直接的拷⻉赋值</strong>，这⾥要注意跟拷⻉构造区分，拷⻉构造⽤于⼀个对象拷⻉<span style="color:#be191c;"><strong>初始化</strong></span>给另⼀个要创建的对象。</p> 
</blockquote> 
<p>1. 赋值运算符重载是⼀个运算符重载，规定必须重载为<strong>成员函数</strong>。赋值运算重载的参数建议写成<br> const当前类类型引⽤，否则会传值传参会有拷⻉<br> 2. 有返回值，且建议写成当前类类型引⽤，引⽤返回可以提⾼效率，有返回值⽬的是为了<strong>⽀持连续赋值场景。</strong><br> 3. 没有显式实现时，编译器会⾃动⽣成⼀个<strong>默认赋值运算符重载</strong>，默认赋值运算符重载⾏为跟默认构造函数类似，对内置类型成员变量会完成<strong>值拷⻉/浅拷⻉(⼀个字节⼀个字节的拷⻉)</strong>，对⾃定义类型成员变量会调⽤他的拷⻉构造。</p> 
<pre><code class="language-cpp">	date&amp; operator=(const date&amp; d)
	{
		if (&amp;d != this)
		{
			_year = d._year;
			_month = d._month;
			_day = d._day;
		}
		return *this;
	}</code></pre> 
<p>4. 像Date这样的类成员变量全是内置类型且没有指向什么资源，编译器⾃动⽣成的赋值运算符重载就可以完成需要的拷⻉，所以不需要我们显⽰实现赋值运算符重载。像Stack这样的类，虽然也都是内置类型，但是_a指向了资源，编译器⾃动⽣成的赋值运算符重载完成的值拷⻉/浅拷⻉不符合我们的需求，所以需要我们⾃⼰实现深拷⻉(对指向的资源也进⾏拷⻉)。像MyQueue这样的类型内部主要是⾃定义类型Stack成员，编译器⾃动⽣成的赋值运算符重载会调⽤Stack的赋值运算符重载，也不需要我们显⽰实现MyQueue的赋值运算符重载。</p> 
<pre><code class="language-cpp">	Stack&amp; operator=(const Stack&amp; s)
	{
		if (this != &amp;s)
		{
			memcpy(_a, s._a, sizeof(STDataType) * s._top);
			_capacity = s._capacity;
			_top = s._top;
		}
		return *this;
	}</code></pre> 
<h3>取地址重载</h3> 
<h4>const成员函数</h4> 
<p>• 将const修饰的成员函数称之为const成员函数，const修饰成员函数放到成员函数参数列表的后<br> ⾯。<br> • <strong>const实际修饰该成员函数隐含的this指针</strong>，表明<strong>在该成员函数中不能对类的任何成员进⾏修改</strong>。<br> const修饰Date类的Print成员函数，Print隐含的this指针由 Date* const this 变为 const Date* const this    <a href="https://blog.csdn.net/2301_80194476/article/details/136586054?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172103367216800188534073%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=172103367216800188534073&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-136586054-null-null.nonecase&amp;utm_term=const&amp;spm=1018.2226.3001.4450" title="C语言指针从入门到基础详解">C语言指针从入门到基础详解</a>（指针常量&amp;常量指针）</p> 
<pre><code class="language-cpp">//void Print(const Date* const this) const
void Print() const
{
    cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
}</code></pre> 
<h4>取地址运算符重载</h4> 
<p>取地址运算符重载分为普通取地址运算符重载和const取地址运算符重载，⼀般这两个函数编译器⾃动⽣成的就可以够我们⽤了，不需要去显⽰实现。除⾮⼀些很特殊的场景，⽐如我们不想让别⼈取到当前类对象的地址，就可以⾃⼰实现⼀份，胡乱返回⼀个地址。</p> 
<pre><code class="language-cpp">class Date
{
public :
	Date * operator&amp;()
	{
		 return this;
		// return nullptr;
		// return (Date*)00267011;
	}
	const Date * operator&amp;() const
	{
		 return this;
		// return nullptr;
		// return (Date*)00267011;
	}
private:
	int _year; // 年
	int _month; // ⽉
	int _day; // ⽇
};</code></pre> 
<p style="text-align:center;"> <strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aca4e99fe94e753778f9747eaa1367aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">指针！！C语言(第一篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1033cce0406c7d0b0245d97f8ccc587/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Haproxy负载均衡</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>