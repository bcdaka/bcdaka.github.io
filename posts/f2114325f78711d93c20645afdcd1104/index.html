<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的优先级队列（PriorityQueue）（如果想知道Java中有关优先级队列的知识点，那么只看这一篇就足够了！） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f2114325f78711d93c20645afdcd1104/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中的优先级队列（PriorityQueue）（如果想知道Java中有关优先级队列的知识点，那么只看这一篇就足够了！）">
  <meta property="og:description" content="前言：优先级队列（Priority Queue）是一种抽象数据类型，其中每个元素都关联有一个优先级，元素按照优先级顺序进行处理。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.优先队列的初识
（1）优先级队列的定义
（2）PriorityQueue的特性
2.优先级队列的模拟实现
3.优先级队列中常用API
（1）创建优先级队列
（2）插入/删除/获取优先级最高的元素/获取个数/清空/判断是否为空
4.优先级队列的使用
1. 任务调度
2. 事件驱动模拟
3. 图算法
4. 数据流处理
1.优先队列的初识 （1）优先级队列的定义 在开始学习Java中优先级队列的使用之前，先让我们了解一下什么是Java中的优先级队列（PriorityQueue）：
优先级队列（Priority Queue）是一种抽象数据类型，其中每个元素都关联有一个优先级，元素按照优先级顺序进行处理。与标准队列不同，优先级队列中的元素处理顺序并非按插入顺序，而是按照优先级高低来决定。
如果读者看了优先级队列的定义之后还是不是太理解什么是优先级队列，那么现在我们使用一个日常生活中的例子来帮助你理解：
——例如在医院急诊室，虽然你可能先到，但是医生会根据病人的病情严重程度来决定治疗顺序。病情严重的病人（例如，心脏病发作的病人）会被优先治疗，而病情较轻的病人（例如，轻微的感冒）会被安排在后面。
这样我相信读者就对优先级队列有了初步的认识了！！！
（2）PriorityQueue的特性 Java集合框架中提供了PriorityQueue和PriorityBlockingQueue两种类型的优先级队，而对于PriorityQueue是线程不安全的，PriorityBlockingQueue是线程安全的，而本文我们主要介绍是PriorityQueue。
其在Java集合框架中的关系图为：
关于PriorityQueue的使用要注意：
1. 使用时必须导入PriorityQueue所在的包，即：
import java.util.PriorityQueue; 2. PriorityQueue中放置的元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出ClassCastException异常；
3. 不能插入null对象，否则会抛出NullPointerException；
4. 没有容量限制，可以插入任意多个元素，其内部可以自动扩容；
5. 插入和删除元素的时间复杂度为O（logN）；
6. PriorityQueue底层使用了堆数据结构；
7. PriorityQueue默认情况下是小堆---即每次获取到的元素都是最小的元素；
至此，我们通过上述对Java中的优先级队列的简单讲述，我们就大致的了解了什么是Java中的优先级队列了！
2.优先级队列的模拟实现 在了解完了什么是Java中的优先级队列之后，现在让我们想想看如何去自我实现一个Java中的优先级队列呢？
——这里我们已经在每处加上了注释，希望读者可以跟随着注释进行理解代码：
package Demo1; import java.util.Arrays; // 堆的自我实现 - 创建堆 &#43; 插入数据 &#43; 删除数据 &#43; 返回堆顶元素 &#43; 判断是否为空 public class MyPriorityQueue { public int[] elem; // 存储堆元素的数组 public int useSize; // 当前堆中元素的个数 // 初始化堆 public MyPriorityQueue(int[] array) { elem = new int[11]; // 初始化堆的容量 for (int i = 0; i &lt; array.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T21:54:26+08:00">
    <meta property="article:modified_time" content="2024-07-24T21:54:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的优先级队列（PriorityQueue）（如果想知道Java中有关优先级队列的知识点，那么只看这一篇就足够了！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>        前言：优先级队列（Priority Queue）是一种抽象数据类型，其中每个元素都关联有一个优先级，元素按照优先级顺序进行处理。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/4f/podLtHYn_o.jpg"></p> 
 <p><strong>✨✨<span style="color:#ff9900;">✨这里是秋刀鱼不做梦的BLOG</span></strong></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本文大致的讲解内容：</strong></span></p> 
<p style="text-align:center;"><span style="color:#a2e043;"><strong><img alt="" src="https://images2.imgbox.com/ab/c9/9mCnPcVJ_o.png"></strong></span></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E8%AF%86-toc" style="margin-left:0px;"><strong><a href="#1.%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E8%AF%86" rel="nofollow">1.优先队列的初识</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">        （1）优先级队列的定义</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">        （2）PriorityQueue的特性</a></strong></p> 
<p id="2.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><strong><a href="#2.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">2.优先级队列的模拟实现</a></strong></p> 
<p id="3.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E4%B8%AD%E5%B8%B8%E7%94%A8API-toc" style="margin-left:0px;"><strong><a href="#3.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E4%B8%AD%E5%B8%B8%E7%94%A8API" rel="nofollow">3.优先级队列中常用API</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">        （1）创建优先级队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E6%8F%92%E5%85%A5%2F%E5%88%A0%E9%99%A4%2F%E8%8E%B7%E5%8F%96%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E9%AB%98%E7%9A%84%E5%85%83%E7%B4%A0%2F%E8%8E%B7%E5%8F%96%E4%B8%AA%E6%95%B0%2F%E6%B8%85%E7%A9%BA%2F%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E6%8F%92%E5%85%A5%2F%E5%88%A0%E9%99%A4%2F%E8%8E%B7%E5%8F%96%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E9%AB%98%E7%9A%84%E5%85%83%E7%B4%A0%2F%E8%8E%B7%E5%8F%96%E4%B8%AA%E6%95%B0%2F%E6%B8%85%E7%A9%BA%2F%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" rel="nofollow">        （2）插入/删除/获取优先级最高的元素/获取个数/清空/判断是否为空</a></strong></p> 
<p id="4.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><strong><a href="#4.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">4.优先级队列的使用</a></strong></p> 
<p id="1.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6-toc" style="margin-left:80px;"><strong><a href="#1.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6" rel="nofollow">1. 任务调度</a></strong></p> 
<p id="2.%20%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%8B%9F-toc" style="margin-left:80px;"><strong><a href="#2.%20%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%8B%9F" rel="nofollow">2. 事件驱动模拟</a></strong></p> 
<p id="3.%20%E5%9B%BE%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#3.%20%E5%9B%BE%E7%AE%97%E6%B3%95" rel="nofollow">3. 图算法</a></strong></p> 
<p id="4.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><strong><a href="#4.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86" rel="nofollow">4. 数据流处理</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E8%AF%86"><span style="color:#956fe7;">1.优先队列的初识</span></h2> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span style="color:#956fe7;">        </span><span style="color:#4da8ee;">（1）优先级队列的定义</span></h3> 
<p>   <strong>    </strong> 在开始学习Java中优先级队列的使用之前，先让我们了解一下什么是Java中的优先级队列（PriorityQueue）：</p> 
<blockquote> 
 <p>      <span style="color:#ff9900;"><strong>  优先级队列（Priority Queue）是一种抽象数据类型，其中每个元素都关联有一个优先级，元素按照优先级顺序进行处理。与标准队列不同，优先级队列中的元素处理顺序并非按插入顺序，而是按照优先级高低来决定。</strong></span></p> 
</blockquote> 
<p>        如果读者看了优先级队列的定义之后还是不是太理解什么是优先级队列，那么现在我们使用一个日常生活中的例子来帮助你理解：</p> 
<p><span style="color:#38d8f0;"><strong>        ——例如在医院急诊室，虽然你可能先到，但是医生会根据病人的病情严重程度来决定治疗顺序。病情严重的病人（例如，心脏病发作的病人）会被优先治疗，而病情较轻的病人（例如，轻微的感冒）会被安排在后面。</strong></span></p> 
<p><span style="color:#38d8f0;"><strong>        </strong></span>这样我相信读者就对优先级队列有了初步的认识了！！！</p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7"><span style="color:#4da8ee;">        （2）PriorityQueue的特性</span></h3> 
<p><strong>       </strong> Java集合框架中提供了PriorityQueue和PriorityBlockingQueue两种类型的优先级队，而对于PriorityQueue是线程不安全的，PriorityBlockingQueue是线程安全的，而本文我们主要介绍是PriorityQueue。</p> 
<p><span style="color:#ffd900;"><strong>其在Java集合框架中的关系图为：</strong></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7b/46/aHSHx0w0_o.png"></p> 
<p><span style="color:#fe2c24;"><strong>关于PriorityQueue的使用要注意：</strong></span></p> 
<p>     <strong>   <span style="color:#fe2c24;">1. </span>使用时必须导入PriorityQueue所在的包，即：</strong></p> 
<pre><code class="language-java">import java.util.PriorityQueue;</code></pre> 
<p><strong>        <span style="color:#fe2c24;">2. </span>PriorityQueue中放置的元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出ClassCastException异常；</strong></p> 
<p><strong>       <span style="color:#fe2c24;"> 3. </span>不能插入null对象，否则会抛出NullPointerException；</strong></p> 
<p><strong>        <span style="color:#fe2c24;">4.</span> 没有容量限制，可以插入任意多个元素，其内部可以自动扩容；</strong></p> 
<p><strong>        <span style="color:#fe2c24;">5. </span>插入和删除元素的时间复杂度为O（logN）；</strong></p> 
<p><strong>        <span style="color:#fe2c24;">6. </span>PriorityQueue底层使用了堆数据结构；</strong></p> 
<p><strong>      <span style="color:#fe2c24;">  7.</span> PriorityQueue默认情况下是小堆---即每次获取到的元素都是最小的元素；</strong></p> 
<p></p> 
<p><strong>        至此，我们通过上述对Java中的优先级队列的简单讲述，我们就大致的了解了什么是Java中的优先级队列了！</strong></p> 
<p></p> 
<h2 id="2.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span style="color:#956fe7;"><strong>2.</strong>优先级队列的模拟实现</span></h2> 
<p>        在了解完了什么是Java中的优先级队列之后，现在让我们想想看如何去自我实现一个Java中的优先级队列呢？</p> 
<p><span style="color:#ffd900;"><strong>——这里我们已经在每处加上了注释，希望读者可以跟随着注释进行理解代码：</strong></span></p> 
<pre><code class="language-java">package Demo1;

import java.util.Arrays;

// 堆的自我实现 - 创建堆 + 插入数据 + 删除数据 + 返回堆顶元素 + 判断是否为空
public class MyPriorityQueue {
    public int[] elem; // 存储堆元素的数组
    public int useSize; // 当前堆中元素的个数

    // 初始化堆
    public MyPriorityQueue(int[] array) {
        elem = new int[11]; // 初始化堆的容量
        for (int i = 0; i &lt; array.length; i++) {
            elem[i] = array[i]; // 将传入的数组元素放入堆中
            useSize++; // 更新堆中元素的个数
        }
        makeBigHeap(array, useSize); // 创建大根堆
    }

    // 整体创建堆
    public void makeBigHeap(int[] array, int useSize) {
        // 从最后一个非叶子节点开始向上调整
        for (int parent = (useSize - 1 - 1) / 2; parent &gt;= 0; parent--) {
            shiftDown(parent, useSize); // 对每个非叶子节点进行下沉操作
        }
    }

    // 下沉操作
    private void shiftDown(int root, int useSize) {
        int child = 2 * root + 1; // 左子节点索引
        while (child &lt; useSize) { // 遍历堆
            // 如果右子节点存在且右子节点的值大于左子节点的值，选择右子节点
            if (child + 1 &lt; useSize &amp;&amp; elem[child] &lt; elem[child + 1]) {
                child++;
            }
            // 如果当前节点的值小于子节点的值，交换它们
            if (elem[root] &lt; elem[child]) {
                swap(root, child);
                root = child; // 更新根节点为被交换的子节点
                child = 2 * root + 1; // 更新左子节点的索引
            } else {
                break; // 如果根节点的值不小于任何子节点，退出循环
            }
        }
    }

    // 在堆中插入元素
    private boolean isFull() {
        return useSize == elem.length; // 判断堆是否满了
    }

    public void offer(int val) {
        if (isFull()) {
            elem = Arrays.copyOf(elem, 2 * elem.length); // 扩容
        }
        elem[useSize] = val; // 将新元素放入堆的末尾
        shiftUp(useSize); // 上浮操作调整堆
        useSize++; // 更新堆中元素的个数
    }

    // 上浮操作
    private void shiftUp(int child) {
        int parent = (child - 1) / 2; // 计算父节点的索引
        while (parent &gt;= 0) {
            // 如果当前节点的值大于父节点的值，交换它们
            if (elem[parent] &lt; elem[child]) {
                swap(parent, child);
                child = parent; // 更新子节点为被交换的父节点
                parent = (child - 1) / 2; // 更新父节点的索引
            } else {
                break; // 如果当前节点的值不大于父节点的值，退出循环
            }
        }
    }

    // 删除堆中元素
    public void poll() {
        if (isEmpty()) {
            throw new RuntimeException("堆中元素为空！"); // 如果堆为空，抛出异常
        }
        swap(0, useSize - 1); // 将堆顶元素与最后一个元素交换
        useSize--; // 更新堆中元素的个数
        shiftDown(0, useSize); // 对堆顶元素进行下沉操作
    }

    // 获取堆顶元素
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("堆中元素为空！"); // 如果堆为空，抛出异常
        }
        return elem[0]; // 返回堆顶元素
    }

    // 判断堆是否为空
    private boolean isEmpty() {
        return useSize == 0; // 如果堆中没有元素，返回 true
    }

    // 交换数组中的两个元素
    private void swap(int pos1, int pos2) {
        int temp = elem[pos1];
        elem[pos1] = elem[pos2];
        elem[pos2] = temp;
    }
}
</code></pre> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 初始化一个整数数组
        int[] array = {1, 4, 2, 7, 9, 10, 5, 6, 8, 3};
        
        // 创建一个优先级队列实例
        MyPriorityQueue myPriorityQueue = new MyPriorityQueue(array);
        
        // 向优先级队列中插入多个元素
        myPriorityQueue.offer(5);
        myPriorityQueue.offer(3);
        myPriorityQueue.offer(8);
        myPriorityQueue.offer(1);

        // 打印堆顶元素
        System.out.println(myPriorityQueue.peek());

        // 删除堆顶元素
        myPriorityQueue.poll();
        
        // 判断堆是否为空，并打印结果（注意这里原代码并未打印结果，需手动添加打印语句）
        System.out.println("堆是否为空: " + myPriorityQueue.isEmpty());
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>从中我们可以看到我们使用堆这个数据结果来自我实现了从 - 创建堆 - 插入数据 - 删除数据 - 返回堆顶元素 - 判断是否为空等优先队列中的操作。至此我们完成了自我实现Java中的优先级队列（PriorityQueue）。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>如果对于堆这种数据结构不了解的读者，可以阅读----------&gt;</strong></span><a href="https://blog.csdn.net/2302_80198073/article/details/140574991" title="Java中的Heap（堆）（如果想知道Java中有关堆的知识点，那么只看这一篇就足够了！）-CSDN博客">Java中的Heap（堆）（如果想知道Java中有关堆的知识点，那么只看这一篇就足够了！）-CSDN博客</a></p> 
<p></p> 
<h2 id="3.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E4%B8%AD%E5%B8%B8%E7%94%A8API"><span style="color:#956fe7;"><strong>3.</strong>优先级队列中常用API</span></h2> 
<p>        通过上面的学习，我们已经了解了什么是Java中的优先级队列，并且自我实现了优先级队列，现在让我们看看Java中内置的优先级队列该如何使用吧！</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span style="color:#4da8ee;">        （1）创建优先级队列</span></h3> 
<p><span style="color:#ffd900;"><strong><code>PriorityQueue</code>类提供了多种构造方法，允许创建不同配置的优先级队列。</strong></span></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:660px;"><thead><tr><th><span style="color:#956fe7;">构造器</span></th><th><span style="color:#ff9900;">功能</span></th></tr></thead><tbody><tr><td><strong>PriorityQueue()</strong></td><td>创建一个空的优先级队列，默认容量是11</td></tr><tr><td><strong>PriorityQueue(int initialCapacity)</strong></td><td>创建一个初始容量为initialCapacity的优先级队列，注意：<br> initialCapacity不能小于1，否则IllegalArgumentException异常</td></tr><tr><td><strong>PriorityQueue(Collection&lt;? extends E&gt; c)</strong></td><td> <p>用一个集合来创建优先级队列</p> </td></tr></tbody></table> 
<p><strong><span style="color:#a2e043;">例子：</span></strong></p> 
<pre><code class="language-java">import java.util.PriorityQueue;

public class PriorityQueueDemo {
    public static void main(String[] args) {
        // 默认初始容量的优先级队列
        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
        
        // 指定初始容量的优先级队列
        PriorityQueue&lt;Integer&gt; pqWithCapacity = new PriorityQueue&lt;&gt;(20);
        
        // 使用比较器的优先级队列
        PriorityQueue&lt;Integer&gt; pqWithComparator = new PriorityQueue&lt;&gt;(new CustomComparator());
    }
}
</code></pre> 
<p><strong>        ——这样我们就会常见Java中的优先级队列了！</strong></p> 
<p>在了解了如何创建一个优先级队列之后，接下来让我们看一下如何去操作这个创建的优先级队列。</p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E6%8F%92%E5%85%A5%2F%E5%88%A0%E9%99%A4%2F%E8%8E%B7%E5%8F%96%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E9%AB%98%E7%9A%84%E5%85%83%E7%B4%A0%2F%E8%8E%B7%E5%8F%96%E4%B8%AA%E6%95%B0%2F%E6%B8%85%E7%A9%BA%2F%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">      <span style="color:#4da8ee;">  （2）插入/删除/获取优先级最高的元素/获取个数/清空/判断是否为空</span></h3> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:660px;"><thead><tr><th><span style="color:#956fe7;">函数名</span></th><th><span style="color:#ff9900;">功能</span></th></tr></thead><tbody><tr><td><strong>boolean offer(E e)</strong></td><td>插入元素e，插入成功返回true，如果e对象为空，抛出NullPointerException异常，时间复杂度O（logN），注意：空间不够时候会进行扩容</td></tr><tr><td><strong>E peek()</strong></td><td>获取优先级最高的元素，如果优先级队列为空，返回null</td></tr><tr><td><strong>E poll()</strong></td><td>移除优先级最高的元素并返回，如果优先级队列为空，返回null</td></tr><tr><td><strong>int size()</strong></td><td>获取有效元素的个数</td></tr><tr><td><strong>void clear()</strong></td><td>清空</td></tr><tr><td><strong>boolean isEmpty()</strong></td><td>检测优先级队列是否为空，空返回true</td></tr></tbody></table> 
<p><span style="color:#a2e043;"><strong>例子：</strong></span></p> 
<pre><code class="language-java">import java.util.PriorityQueue;

public class Test {
    public static void main(String[] args) {
        // 初始化一个整数数组
        int[] arr = {4, 1, 9, 2, 8, 0, 7, 3, 6, 5};

        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(arr.length);
        
        // 将数组中的元素添加到优先级队列中
        for (int e : arr) {
            q.offer(e);
        }
        
        // 打印优先级队列中有效元素的个数
        System.out.println(q.size());
        
        // 获取并打印优先级队列中优先级最高的元素（即最小值，因为是最小堆）
        System.out.println(q.peek());
        
        // 从优先级队列中删除两个元素
        q.poll();
        q.poll();
        
        // 打印删除两个元素后，优先级队列中有效元素的个数
        System.out.println(q.size());
        
        // 获取并打印当前优先级最高的元素
        System.out.println(q.peek());
        
        // 向优先级队列中插入一个新的元素
        q.offer(0);
        
        // 获取并打印插入新元素后的优先级最高的元素
        System.out.println(q.peek());
        
        // 清空优先级队列中的所有有效元素
        q.clear();
        
        // 检测优先级队列是否为空，并打印结果
        if (q.isEmpty()) {
            System.out.println("优先级队列已经为空!!!");
        } else {
            System.out.println("优先级队列不为空");
        }
    }
}
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/66/70/jW847H0p_o.png"></p> 
<p>     <strong>   ——这样我们就大致的了解了如何操作Java中的优先级队列了！！！</strong></p> 
<p></p> 
<h2 id="4.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span style="color:#956fe7;"><strong>4.</strong>优先级队列的使用</span></h2> 
<p>     <span style="color:#ff9900;"><strong>   优先级队列（Priority Queue）是一种特殊的数据结构，用于处理具有优先级的元素。它的主要特点是能够高效地插入元素并以优先级顺序访问和删除元素。以下是优先级队列的一些主要应用场景：</strong></span></p> 
<h4 id="1.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6">1. <strong>任务调度</strong></h4> 
<ul><li> <p><strong>场景</strong>: 操作系统和调度系统常常需要管理多个任务，每个任务具有不同的优先级。</p> </li><li> <p><strong>用法</strong>: 优先级队列可以用来实现任务调度系统，其中优先级高的任务会被优先执行。比如，操作系统的进程调度器会使用优先级队列来决定哪个进程应该优先获得 CPU 时间。</p> </li></ul> 
<h4 id="2.%20%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%8B%9F">2. <strong>事件驱动模拟</strong></h4> 
<ul><li> <p><strong>场景</strong>: 在模拟系统（如网络仿真或离散事件模拟）中，事件会在未来的某个时间点发生。</p> </li><li> <p><strong>用法</strong>: 优先级队列用于存储和处理这些事件，确保在模拟中按事件的发生时间顺序处理它们。</p> </li></ul> 
<h4 id="3.%20%E5%9B%BE%E7%AE%97%E6%B3%95">3. <strong>图算法</strong></h4> 
<ul><li> <p><strong>场景</strong>: 在计算图的最短路径（如 Dijkstra 算法）或最小生成树（如 Prim 算法）时，需要按边的权重或节点的距离进行操作。</p> </li><li> <p><strong>用法</strong>: 使用优先级队列可以有效地管理和访问图中的边或节点，以支持这些算法的高效执行。</p> </li></ul> 
<h4 id="4.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86">4. <strong>数据流处理</strong></h4> 
<ul><li> <p><strong>场景</strong>: 数据流中的数据可能具有不同的重要性或优先级。</p> </li><li> <p><strong>用法</strong>: 在处理实时数据流时，优先级队列可以用来根据数据的优先级顺序处理数据。</p> </li></ul> 
<p><strong>这样我们就大致的了解了Java中的优先级队列在日常中的使用地方了！</strong></p> 
<p></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本篇文章的全部内容了~~~</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65f482ce8ef605df024bbd5df44ecdb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">力扣最热一百题——4.移动零</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21235fcaea58278e1bf5891babab6f6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】——单链表实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>