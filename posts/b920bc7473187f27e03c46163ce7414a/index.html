<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>语音深度鉴伪识别项目实战：基于深度学习的语音深度鉴伪识别算法模型(二)音频数据预处理及去噪算法&#43;Python源码应用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b920bc7473187f27e03c46163ce7414a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="语音深度鉴伪识别项目实战：基于深度学习的语音深度鉴伪识别算法模型(二)音频数据预处理及去噪算法&#43;Python源码应用">
  <meta property="og:description" content="前言 深度学习技术在当今技术市场上面尚有余力和开发空间的，主流落地领域主要有：视觉，听觉，AIGC这三大板块。
目前视觉板块的框架和主流技术在我上一篇基于Yolov7-LPRNet的动态车牌目标识别算法模型已有较为详细的解说。与AIGC相关联的，其实语音模块在近来市场上面活跃空间很大。
从智能手机的语音助手到智能家居中的语音控制系统，再到银行和电信行业的语音身份验证，语音技术的应用日益广泛。那么对应现在ACG技术是可以利用原音频去进行训练学习，从而得到相对应的声音特征，从而进行模仿，甚至可以利用人工智能生成的语音可以以假乱真，给社会带来了严重的安全隐患。
当前，语音深度鉴伪识别技术已经取得了一定的进展。研究人员利用机器学习和深度学习方法，通过分析语音信号的特征，开发出了一系列鉴伪算法。
然而，随着生成大模型和其他语音合成技术的不断进步，伪造语音的逼真度也在不断提高，使得语音鉴伪任务变得愈加复杂和具有挑战性。本项目系列文章将从最基础的语音数据存储和详细分析开始，由于本系列专栏是有详细解说过深度学习和机器学习内容的，音频数据处理和现主流技术语音分类模型和编码模型将会是本项目系列文章的主体内容，具体本项目系列要讲述的内容可参考下图：
语音模型的内容不是那么好掌握的，包含大量的数学理论知识以及大量的计算公式原理需要推理。且如果不进行实际操作很难够理解我们写的代码究极在神经网络计算框架中代表什么作用。不过我会尽可能将知识简化，转换为我们比较熟悉的内容。
我将尽力让大家了解并熟悉神经网络框架，保证能够理解通畅以及推演顺利的条件之下，尽量不使用过多的数学公式和专业理论知识。以一篇文章快速了解并实现该算法，以效率最高的方式熟练这些知识。希望有需求的小伙伴不要错过笔者精心打造的专栏。
上篇文章详细解答了所有音频常见存储载体和其特征，以及音频的数据保存形态有哪些？具体数据可视化展示为何种形式？这类问题，对音频数据认知打下了坚实的基础。那么第二章我们就应该对音频数据预处理有大致的了解，从噪音的种类再到各个去噪算法依次了解，那么我们的语音深度鉴伪识别才算入门。
一、音频存储载体 由于音频存储是根据音频数据编码来的，上篇文章已经几乎把所有的音频编码算法都讲解了，固不再重复将每个音频存储载体具体信息详细，只作概览：
综合比较 格式压缩类型音质文件大小主要应用优点缺点WAV无压缩高大音频编辑高质量文件大FLAC无损压缩高中音频存储高质量，文件较小文件仍较大ALAC无损压缩高中苹果设备高质量，兼容苹果跨平台支持少MP3有损压缩中小音乐存储、传输文件小，支持广泛音质低AAC有损压缩中高小流媒体、移动设备高效压缩，音质好普及度略低OGG Vorbis有损压缩中高小游戏音频、流媒体高质量，开源支持较少DSD无压缩极高极大高保真音频超高保真度文件极大，支持有限AIFF无压缩高大苹果设备高质量文件大Opus有损压缩高小流媒体、实时通信低延迟，高质量存储应用少 二、音频数据预处理 既然我们现在已经通过python去尝试了构建一个wav音频文件，自然我们也可以通过编码方式对原有音频进行数据处理，使其音频质量，如后续有建模的必要这会是关键步骤，一切模型都离不开数据质量。和图片去噪的方式也是大相径庭，那么现在我们来实践操作。首先，确保安装了pydub库和ffmpeg：
pip install pydub sudo apt-get install ffmpeg 如果需要更细粒度的控制，需要使用numpy和scipy生成纯音乐。
pip install numpy scipy soundfile 生成音乐片段：
import numpy as np import soundfile as sf def generate_sine_wave(frequency, duration, sample_rate=44100): &#34;&#34;&#34;生成指定频率和持续时间的正弦波&#34;&#34;&#34; t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) return 0.5 * np.sin(2 * np.pi * frequency * t) # 定义音符（频率）和节拍（秒） notes = { &#39;C4&#39;: 261.63, &#39;D4&#39;: 293.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-31T16:56:50+08:00">
    <meta property="article:modified_time" content="2024-05-31T16:56:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">语音深度鉴伪识别项目实战：基于深度学习的语音深度鉴伪识别算法模型(二)音频数据预处理及去噪算法&#43;Python源码应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<p>深度学习技术在当今技术市场上面尚有余力和开发空间的，主流落地领域主要有：视觉，听觉，AIGC这三大板块。</p> 
<p>目前视觉板块的框架和主流技术在我上一篇基于Yolov7-LPRNet的动态车牌目标识别算法模型已有较为详细的解说。与AIGC相关联的，其实语音模块在近来市场上面活跃空间很大。</p> 
<p>从智能手机的语音助手到智能家居中的语音控制系统，再到银行和电信行业的语音身份验证，语音技术的应用日益广泛。那么对应现在ACG技术是可以利用原音频去进行训练学习，从而得到相对应的声音特征，从而进行模仿，甚至可以利用人工智能生成的语音可以以假乱真，给社会带来了严重的安全隐患。</p> 
<p>当前，语音深度鉴伪识别技术已经取得了一定的进展。研究人员利用机器学习和深度学习方法，通过分析语音信号的特征，开发出了一系列鉴伪算法。</p> 
<p>然而，随着生成大模型和其他语音合成技术的不断进步，伪造语音的逼真度也在不断提高，使得语音鉴伪任务变得愈加复杂和具有挑战性。本项目系列文章将从最基础的语音数据存储和详细分析开始，由于本系列专栏是有详细解说过深度学习和机器学习内容的，音频数据处理和现主流技术语音分类模型和编码模型将会是本项目系列文章的主体内容，具体本项目系列要讲述的内容可参考下图：<br> <img src="https://images2.imgbox.com/99/ee/FrDQGXRx_o.png" alt="在这里插入图片描述">语音模型的内容不是那么好掌握的，包含大量的数学理论知识以及大量的计算公式原理需要推理。且如果不进行实际操作很难够理解我们写的代码究极在神经网络计算框架中代表什么作用。不过我会尽可能将知识简化，转换为我们比较熟悉的内容。</p> 
<p>我将尽力让大家了解并熟悉神经网络框架，保证能够理解通畅以及推演顺利的条件之下，尽量不使用过多的数学公式和专业理论知识。以一篇文章快速了解并实现该算法，以效率最高的方式熟练这些知识。希望有需求的小伙伴不要错过笔者精心打造的专栏。</p> 
<p>上篇文章详细解答了所有音频常见存储载体和其特征，以及音频的数据保存形态有哪些？具体数据可视化展示为何种形式？这类问题，对音频数据认知打下了坚实的基础。那么第二章我们就应该对音频数据预处理有大致的了解，从噪音的种类再到各个去噪算法依次了解，那么我们的语音深度鉴伪识别才算入门。</p> 
<h2><a id="_17"></a>一、音频存储载体</h2> 
<p>由于音频存储是根据音频数据编码来的，上篇文章已经几乎把所有的音频编码算法都讲解了，固不再重复将每个音频存储载体具体信息详细，只作概览：<br> <img src="https://images2.imgbox.com/d5/da/zePqVsmi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_21"></a>综合比较</h3> 
<table><thead><tr><th>格式</th><th>压缩类型</th><th>音质</th><th>文件大小</th><th>主要应用</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>WAV</td><td>无压缩</td><td>高</td><td>大</td><td>音频编辑</td><td>高质量</td><td>文件大</td></tr><tr><td>FLAC</td><td>无损压缩</td><td>高</td><td>中</td><td>音频存储</td><td>高质量，文件较小</td><td>文件仍较大</td></tr><tr><td>ALAC</td><td>无损压缩</td><td>高</td><td>中</td><td>苹果设备</td><td>高质量，兼容苹果</td><td>跨平台支持少</td></tr><tr><td>MP3</td><td>有损压缩</td><td>中</td><td>小</td><td>音乐存储、传输</td><td>文件小，支持广泛</td><td>音质低</td></tr><tr><td>AAC</td><td>有损压缩</td><td>中高</td><td>小</td><td>流媒体、移动设备</td><td>高效压缩，音质好</td><td>普及度略低</td></tr><tr><td>OGG Vorbis</td><td>有损压缩</td><td>中高</td><td>小</td><td>游戏音频、流媒体</td><td>高质量，开源</td><td>支持较少</td></tr><tr><td>DSD</td><td>无压缩</td><td>极高</td><td>极大</td><td>高保真音频</td><td>超高保真度</td><td>文件极大，支持有限</td></tr><tr><td>AIFF</td><td>无压缩</td><td>高</td><td>大</td><td>苹果设备</td><td>高质量</td><td>文件大</td></tr><tr><td>Opus</td><td>有损压缩</td><td>高</td><td>小</td><td>流媒体、实时通信</td><td>低延迟，高质量</td><td>存储应用少</td></tr></tbody></table> 
<h2><a id="_34"></a>二、音频数据预处理</h2> 
<p>既然我们现在已经通过python去尝试了构建一个wav音频文件，自然我们也可以通过编码方式对原有音频进行数据处理，使其音频质量，如后续有建模的必要这会是关键步骤，一切模型都离不开数据质量。和图片去噪的方式也是大相径庭，那么现在我们来实践操作。首先，确保安装了<code>pydub</code>库和<code>ffmpeg</code>：</p> 
<pre><code class="prism language-bash">pip <span class="token function">install</span> pydub
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ffmpeg
</code></pre> 
<p>如果需要更细粒度的控制，需要使用<code>numpy</code>和<code>scipy</code>生成纯音乐。</p> 
<pre><code class="prism language-bash">pip <span class="token function">install</span> numpy scipy soundfile
</code></pre> 
<p><strong>生成音乐片段</strong>：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> soundfile <span class="token keyword">as</span> sf

<span class="token keyword">def</span> <span class="token function">generate_sine_wave</span><span class="token punctuation">(</span>frequency<span class="token punctuation">,</span> duration<span class="token punctuation">,</span> sample_rate<span class="token operator">=</span><span class="token number">44100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""生成指定频率和持续时间的正弦波"""</span>
    t <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> duration<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sample_rate <span class="token operator">*</span> duration<span class="token punctuation">)</span><span class="token punctuation">,</span> endpoint<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0.5</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi <span class="token operator">*</span> frequency <span class="token operator">*</span> t<span class="token punctuation">)</span>

<span class="token comment"># 定义音符（频率）和节拍（秒）</span>
notes <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">'C4'</span><span class="token punctuation">:</span> <span class="token number">261.63</span><span class="token punctuation">,</span>
    <span class="token string">'D4'</span><span class="token punctuation">:</span> <span class="token number">293.66</span><span class="token punctuation">,</span>
    <span class="token string">'E4'</span><span class="token punctuation">:</span> <span class="token number">329.63</span><span class="token punctuation">,</span>
    <span class="token string">'F4'</span><span class="token punctuation">:</span> <span class="token number">349.23</span><span class="token punctuation">,</span>
    <span class="token string">'G4'</span><span class="token punctuation">:</span> <span class="token number">392.00</span><span class="token punctuation">,</span>
    <span class="token string">'A4'</span><span class="token punctuation">:</span> <span class="token number">440.00</span><span class="token punctuation">,</span>
    <span class="token string">'B4'</span><span class="token punctuation">:</span> <span class="token number">493.88</span><span class="token punctuation">,</span>
    <span class="token string">'C5'</span><span class="token punctuation">:</span> <span class="token number">523.25</span>
<span class="token punctuation">}</span>

<span class="token comment"># 定义乐曲：每个音符和相应的持续时间（秒）</span>
melody <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">'C4'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'D4'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'E4'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'F4'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">'G4'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'A4'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'B4'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'C5'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>

<span class="token comment"># 生成乐曲</span>
sample_rate <span class="token operator">=</span> <span class="token number">44100</span>
song <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> note<span class="token punctuation">,</span> duration <span class="token keyword">in</span> melody<span class="token punctuation">:</span>
    tone <span class="token operator">=</span> generate_sine_wave<span class="token punctuation">(</span>notes<span class="token punctuation">[</span>note<span class="token punctuation">]</span><span class="token punctuation">,</span> duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>
    song <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>song<span class="token punctuation">,</span> tone<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 保存生成的纯音乐</span>
sf<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'pure_music.wav'</span><span class="token punctuation">,</span> song<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"纯音乐生成完毕并保存为pure_music.wav"</span><span class="token punctuation">)</span>

</code></pre> 
<p>我们可以通过使用<code>matplotlib</code>和<code>librosa.display</code>库绘制音频波形图和梅尔频谱图，来帮助我们更好观测音频数据特征：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">import</span> librosa<span class="token punctuation">.</span>display

<span class="token keyword">def</span> <span class="token function">plot_waveform_and_spectrogram</span><span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span class="token punctuation">:</span>
    audio_data<span class="token punctuation">,</span> sample_rate <span class="token operator">=</span> librosa<span class="token punctuation">.</span>load<span class="token punctuation">(</span>file_path<span class="token punctuation">,</span> sr<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>

    <span class="token comment"># 绘制波形图</span>
    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    librosa<span class="token punctuation">.</span>display<span class="token punctuation">.</span>waveshow<span class="token punctuation">(</span>audio_data<span class="token punctuation">,</span> sr<span class="token operator">=</span>sample_rate<span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Waveform'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Time (s)'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Amplitude'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 计算梅尔频谱图</span>
    mel_spectrogram <span class="token operator">=</span> librosa<span class="token punctuation">.</span>feature<span class="token punctuation">.</span>melspectrogram<span class="token punctuation">(</span>y<span class="token operator">=</span>audio_data<span class="token punctuation">,</span> sr<span class="token operator">=</span>sample_rate<span class="token punctuation">,</span> n_mels<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">)</span>
    log_mel_spectrogram <span class="token operator">=</span> librosa<span class="token punctuation">.</span>power_to_db<span class="token punctuation">(</span>mel_spectrogram<span class="token punctuation">,</span> ref<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">)</span>

    <span class="token comment"># 绘制梅尔频谱图</span>
    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    librosa<span class="token punctuation">.</span>display<span class="token punctuation">.</span>specshow<span class="token punctuation">(</span>log_mel_spectrogram<span class="token punctuation">,</span> sr<span class="token operator">=</span>sample_rate<span class="token punctuation">,</span> x_axis<span class="token operator">=</span><span class="token string">'time'</span><span class="token punctuation">,</span> y_axis<span class="token operator">=</span><span class="token string">'mel'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Mel-Spectrogram'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token builtin">format</span><span class="token operator">=</span><span class="token string">'%+2.0f dB'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 示例：绘制WAV文件的波形图和频谱图</span>
file_path <span class="token operator">=</span> <span class="token string">'pure_music.wav'</span>
plot_waveform_and_spectrogram<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/b5/60/Ph25KjuH_o.png" alt="在这里插入图片描述"></p> 
<p>接下来我们通过引入不同的噪音种类，认识噪音种类并尝试辨别哪些噪音种类，最后进行音频去噪。</p> 
<h3><a id="21_132"></a>2.1噪音种类</h3> 
<p>每种噪音的特征和来源不同，可能会对音频信号的质量产生不同的影响。<br> <img src="https://images2.imgbox.com/39/06/jYRp4jmj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="211__136"></a>2.1.1. 白噪音</h4> 
<p>我们来尝试制作白噪音，从制作过程中就能看到特征种类：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> soundfile <span class="token keyword">as</span> sf

<span class="token keyword">def</span> <span class="token function">generate_white_noise</span><span class="token punctuation">(</span>duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""生成指定持续时间的白噪音"""</span>
    noise <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sample_rate <span class="token operator">*</span> duration<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> noise

<span class="token comment"># 生成5秒白噪音</span>
sample_rate <span class="token operator">=</span> <span class="token number">44100</span>
duration <span class="token operator">=</span> <span class="token number">5.0</span>
white_noise <span class="token operator">=</span> generate_white_noise<span class="token punctuation">(</span>duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

<span class="token comment"># 保存白噪音</span>
sf<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'white_noise.wav'</span><span class="token punctuation">,</span> white_noise<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

</code></pre> 
<p>该白噪音一听就能够辨别出来，十分明显。听起来像“嘶嘶”声，类似电视没有信号时的声音。</p> 
<h4><a id="212_162"></a>2.1.2.粉红噪音</h4> 
<p>听起来比白噪音柔和，常用于声音测试和治疗。类似自然环境中的各种声音，如风声、流水声等。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> soundfile <span class="token keyword">as</span> sf

<span class="token keyword">def</span> <span class="token function">generate_pink_noise</span><span class="token punctuation">(</span>duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""生成指定持续时间的粉红噪音"""</span>
    white <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>sample_rate <span class="token operator">*</span> duration<span class="token punctuation">)</span><span class="token punctuation">)</span>
    fft <span class="token operator">=</span> np<span class="token punctuation">.</span>fft<span class="token punctuation">.</span>rfft<span class="token punctuation">(</span>white<span class="token punctuation">)</span>
    fft <span class="token operator">=</span> fft <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>fft<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    pink <span class="token operator">=</span> np<span class="token punctuation">.</span>fft<span class="token punctuation">.</span>irfft<span class="token punctuation">(</span>fft<span class="token punctuation">)</span>
    <span class="token keyword">return</span> pink

<span class="token comment"># 生成5秒粉红噪音</span>
sample_rate <span class="token operator">=</span> <span class="token number">44100</span>
duration <span class="token operator">=</span> <span class="token number">5.0</span>
pink_noise <span class="token operator">=</span> generate_pink_noise<span class="token punctuation">(</span>duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

<span class="token comment"># 保存粉红噪音</span>
sf<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'pink_noise.wav'</span><span class="token punctuation">,</span> pink_noise<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

</code></pre> 
<h4><a id="213Brown_Noise_188"></a>2.1.3.棕色噪音（Brown Noise）</h4> 
<p>听起来更低沉和柔和，比粉红噪音更温和。自然环境中的低频声音，如雷声、海浪声等。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> soundfile <span class="token keyword">as</span> sf

<span class="token keyword">def</span> <span class="token function">generate_brown_noise</span><span class="token punctuation">(</span>duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""生成指定持续时间的棕色噪音"""</span>
    white <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>sample_rate <span class="token operator">*</span> duration<span class="token punctuation">)</span><span class="token punctuation">)</span>
    brown <span class="token operator">=</span> np<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span>white<span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>sample_rate<span class="token punctuation">)</span>
    <span class="token keyword">return</span> brown

<span class="token comment"># 生成5秒棕色噪音</span>
sample_rate <span class="token operator">=</span> <span class="token number">44100</span>
duration <span class="token operator">=</span> <span class="token number">5.0</span>
brown_noise <span class="token operator">=</span> generate_brown_noise<span class="token punctuation">(</span>duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

<span class="token comment"># 保存棕色噪音</span>
sf<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'brown_noise.wav'</span><span class="token punctuation">,</span> brown_noise<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

</code></pre> 
<p>还有更多噪音这里暂且不作更多生成展示，不同类型的噪音在日常生活和各种技术应用中都可能出现，后续处理这些噪声方面会介绍的更加详细。最主要的我们需要花更多的时间去学习如何运用去噪算法，如何选着合适的去噪算法，达到想要的去噪效果。</p> 
<h3><a id="22_213"></a>2.2去噪算法</h3> 
<p>不同类型的噪音需要采用不同的去噪算法才能达到效果，下面我们来看看都有哪些去噪算法，都可以适用哪些噪音：<br> <img src="https://images2.imgbox.com/e6/54/3DJ6f5PZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="221Spectral_Subtraction_217"></a>2.2.1.频谱减法（Spectral Subtraction）</h4> 
<p>频谱减法（Spectral Subtraction）是一种经典的音频去噪技术，用于从噪声污染的信号中减去估计的噪声频谱，以恢复原始的干净信号。该算法最初由 S. Boll 于1979年提出，是一种简单且有效的去噪方法，广泛应用于语音处理、音频增强等领域。</p> 
<p>频谱减法利用了噪声信号在频谱上的统计特性，假设噪声是平稳的或缓慢变化的，因此其频谱特性在时间上保持相对稳定。通过估计噪声的频谱并将其从受噪声污染的音频信号中减去，可以在一定程度上恢复原始信号。</p> 
<p><strong>用途</strong>：</p> 
<ul><li><strong>语音增强</strong>：提高语音信号的可懂度和清晰度，常用于电话通信、语音识别和助听器等领域。</li><li><strong>音频修复</strong>：去除录音中的背景噪音，如风声、交通噪音等，改善音频质量。</li><li><strong>预处理步骤</strong>：在许多音频处理任务中，频谱减法可以作为预处理步骤，以提高后续处理的效果。</li></ul> 
<p>频谱减法的核心思想是估计噪声频谱并将其从受污染信号的频谱中减去：</p> 
<ol><li> <p><strong>预处理</strong>：</p> 
  <ul><li><strong>短时傅里叶变换（STFT）</strong>：将时域信号转换为频域信号，分解为若干帧，每帧进行傅里叶变换，得到每帧的频谱。</li></ul> </li><li> <p><strong>估计噪声频谱</strong>：</p> 
  <ul><li><strong>静音段估计</strong>：在信号的静音段或环境噪声段提取噪声频谱的平均值。假设噪声在这些段中是平稳的。</li><li><strong>平滑估计</strong>：使用平滑方法估计噪声频谱，通常采用时间平均或指数加权平均。</li></ul> </li><li> <p><strong>频谱减法</strong>：</p> 
  <ul><li><strong>频谱减法计算</strong>：对每一帧信号，计算其幅值谱并减去估计的噪声幅值谱：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             ∣ 
            
           
             S 
            
           
             ( 
            
           
             f 
            
           
             ) 
            
           
             ∣ 
            
           
             = 
            
           
             m 
            
           
             a 
            
           
             x 
            
           
             ( 
            
           
             ∣ 
            
           
             Y 
            
           
             ( 
            
           
             f 
            
           
             ) 
            
           
             ∣ 
            
           
             − 
            
           
             ∣ 
            
           
             N 
            
           
             ( 
            
           
             f 
            
           
             ) 
            
           
             ∣ 
            
           
             , 
            
           
             0 
            
           
             ) 
            
           
          
            |S(f)|=max(|Y(f)|-|N(f)|,0) 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span style="margin-right: 0.0576em;" class="mord mathnormal">S</span><span class="mopen">(</span><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">∣</span><span style="margin-right: 0.2222em;" class="mord mathnormal">Y</span><span class="mopen">(</span><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span style="margin-right: 0.109em;" class="mord mathnormal">N</span><span class="mopen">(</span><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="mclose">)</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></span><br> 其中,|Y(f)|是受噪声污染的信号的幅值谱，∣<em>N</em>(<em>f</em>)∣ 是估计的噪声幅值谱， ∣𝑆(𝑓)∣是去噪后的信号的幅值谱。</li></ul> </li><li> <p><strong>相位恢复</strong>：使用原始信号的相位谱<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            θ 
           
          
            Y 
           
          
         
           ( 
          
         
           f 
          
         
           ) 
          
         
        
          θ_{Y}(f) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span style="margin-right: 0.0278em;" class="mord mathnormal">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right: 0.2222em;" class="mord mathnormal mtight">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="mclose">)</span></span></span></span></span>​和去噪后的幅值谱 ∣𝑆(𝑓)∣ 重构频域信号：</p> 
  <ul><li><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             S 
            
           
             ( 
            
           
             f 
            
           
             ) 
            
           
             = 
            
           
             ∣ 
            
           
             S 
            
           
             ( 
            
           
             f 
            
           
             ) 
            
           
             ∣ 
            
            
            
              e 
             
             
             
               j 
              
              
              
                θ 
               
              
                Y 
               
              
             
               ( 
              
             
               f 
              
             
               ) 
              
             
            
           
          
            S(f)=|S(f)|e^{jθ_{Y}(f)} 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0576em;" class="mord mathnormal">S</span><span class="mopen">(</span><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.188em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span style="margin-right: 0.0576em;" class="mord mathnormal">S</span><span class="mopen">(</span><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.938em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right: 0.0572em;" class="mord mathnormal mtight">j</span><span class="mord mtight"><span style="margin-right: 0.0278em;" class="mord mathnormal mtight">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.3567em; margin-left: -0.0278em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span style="margin-right: 0.2222em;" class="mord mathnormal mtight">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1433em;"><span class=""></span></span></span></span></span></span><span class="mopen mtight">(</span><span style="margin-right: 0.1076em;" class="mord mathnormal mtight">f</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul> </li><li> <p><strong>逆变换</strong>：</p> 
  <ul><li><strong>逆短时傅里叶变换（ISTFT）</strong>：将去噪后的频域信号通过逆短时傅里叶变换转换回时域信号，得到去噪后的时域信号。</li></ul> </li></ol> 
<p>那么首先我们对我们生成的纯音乐添加白噪音：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> soundfile <span class="token keyword">as</span> sf
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token comment"># 读取纯音乐文件</span>
pure_music<span class="token punctuation">,</span> sample_rate <span class="token operator">=</span> sf<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token string">'pure_music.wav'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">generate_white_noise</span><span class="token punctuation">(</span>duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""生成指定持续时间的白噪音"""</span>
    noise <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sample_rate <span class="token operator">*</span> duration<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> noise

<span class="token comment"># 获取纯音乐的持续时间</span>
duration <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pure_music<span class="token punctuation">)</span> <span class="token operator">/</span> sample_rate

<span class="token comment"># 生成与纯音乐长度相同的噪音</span>
white_noise <span class="token operator">=</span> generate_white_noise<span class="token punctuation">(</span>duration<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

<span class="token comment"># 将白噪音添加到纯音乐</span>
white_noise_music <span class="token operator">=</span> pure_music <span class="token operator">+</span> <span class="token number">0.1</span> <span class="token operator">*</span> white_noise  <span class="token comment"># 0.1表示噪音的强度，可以调整</span>

<span class="token comment"># 保存合成后的音频</span>
sf<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'pure_music_with_white_noise.wav'</span><span class="token punctuation">,</span> white_noise_music<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>

</code></pre> 
<p>合成之后的音频听起来噪声是很明显的，此时我们可以通过特征可视化看到区别：</p> 
<p>为加噪音之前:<br> <img src="https://images2.imgbox.com/33/68/1AepJRPx_o.png" alt="在这里插入图片描述">加入噪音之后：</p> 
<p><img src="https://images2.imgbox.com/4e/15/R1YRSOiH_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/21/be/DYxjqVcQ_o.png" alt="在这里插入图片描述"></p> 
<p>现在我们再用去噪算法进行去噪处理：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">spectral_subtraction</span><span class="token punctuation">(</span>noisy_signal<span class="token punctuation">,</span> noise_signal<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 计算短时傅里叶变换（STFT）</span>
    noisy_stft <span class="token operator">=</span> librosa<span class="token punctuation">.</span>stft<span class="token punctuation">(</span>noisy_signal<span class="token punctuation">)</span>
    noise_stft <span class="token operator">=</span> librosa<span class="token punctuation">.</span>stft<span class="token punctuation">(</span>noise_signal<span class="token punctuation">)</span>

    <span class="token comment"># 计算噪声的平均频谱</span>
    noise_spectrum <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>noise_stft<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdims<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

    <span class="token comment"># 对每一帧信号进行频谱减法</span>
    magnitude <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>noisy_stft<span class="token punctuation">)</span>
    phase <span class="token operator">=</span> np<span class="token punctuation">.</span>angle<span class="token punctuation">(</span>noisy_stft<span class="token punctuation">)</span>
    clean_spectrum <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>magnitude <span class="token operator">-</span> noise_spectrum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token comment"># 重构频域信号</span>
    clean_stft <span class="token operator">=</span> clean_spectrum <span class="token operator">*</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token number">1j</span> <span class="token operator">*</span> phase<span class="token punctuation">)</span>

    <span class="token comment"># 逆STFT得到时域信号</span>
    clean_signal <span class="token operator">=</span> librosa<span class="token punctuation">.</span>istft<span class="token punctuation">(</span>clean_stft<span class="token punctuation">)</span>
    <span class="token keyword">return</span> clean_signal
</code></pre> 
<p>处理之后对比如下所示，大家可以听视频感觉，噪音还是有所降低的，但是不多：<br> <img src="https://images2.imgbox.com/67/48/GQBoSIhz_o.png" alt="在这里插入图片描述">### 2.2.2自适应滤波（Adaptive Filtering）</p> 
<p>自适应滤波是一种动态调整滤波器参数以最小化输出误差的信号处理技术。它广泛应用于各种需要实时调整和优化的系统中。自适应滤波器根据输入信号的统计特性不断更新其参数，因而能够在非平稳环境中有效工作。一般适用于背景噪声（Background Noise）、电磁干扰噪声（Electromagnetic Interference Noise）、语音噪声（Speech Noise）、回声（Echo）、噪声尖峰（Impulse Noise）这五种噪音。</p> 
<h5><a id="_323"></a>具体算法逻辑</h5> 
<p>自适应滤波器通过最小均方（LMS）算法调整滤波器系数以最小化误差。常见的自适应滤波算法包括LMS和RLS（递归最小二乘）。</p> 
<h6><a id="LMS_327"></a>LMS算法</h6> 
<p>LMS算法是一种简单且有效的自适应滤波算法，其主要步骤如下：</p> 
<ol><li> <p><strong>初始化</strong>：</p> 
  <ul><li>设定滤波器系数初始值为零或随机值。</li><li>设定步长因子 <em>μ</em> 以控制更新速度。</li></ul> </li><li> <p><strong>迭代更新</strong>：</p> 
  <ul><li>对于每一个输入信号样本： 
    <ul><li>计算滤波器输出y(n)： 𝑦(𝑛)=𝑤(𝑛)𝑇𝑥(𝑛)，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              w 
             
            
              ( 
             
            
              n 
             
            
              ) 
             
            
           
             w(n) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0269em;" class="mord mathnormal">w</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 是滤波器系数向量，𝑥(𝑛)$ 是输入信号向量。</li><li>计算误差e(n):e(n)=d(n)-y(n),其中𝑑(𝑛)​ 是期望信号。</li><li>更新滤波器系数:w(n+1)=w(n)+2μe(n)x(n)$</li></ul> </li></ul> </li><li> <p><strong>停止条件</strong>：</p> 
  <ul><li>通常设定迭代次数或达到误差最小值时停止。</li></ul> </li><li> 
  <ul><li></ul> </li></ol> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">lms_filter</span><span class="token punctuation">(</span>noisy_signal<span class="token punctuation">,</span> reference_signal<span class="token punctuation">,</span> mu<span class="token punctuation">,</span> num_taps<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>noisy_signal<span class="token punctuation">)</span>
    w <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_taps<span class="token punctuation">)</span>
    y <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    e <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_taps<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        x <span class="token operator">=</span> noisy_signal<span class="token punctuation">[</span>i<span class="token operator">-</span>num_taps<span class="token punctuation">:</span>i<span class="token punctuation">]</span>
        y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>w<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
        e<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> reference_signal<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        w <span class="token operator">=</span> w <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> mu <span class="token operator">*</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> x
    
    <span class="token keyword">return</span> e  <span class="token comment"># 返回误差信号作为去噪后的信号</span>
</code></pre> 
<p>在自适应滤波算法中去噪效果受到步长因子 (𝜇<em>μ</em>) 和滤波器长度 (num_taps)影响尤其重要，如果这些参数设置不当，可能会导致滤波效果不佳，甚至使噪声加重。可以通过：</p> 
<ol><li><strong>调整步长因子</strong>：步长因子 (𝜇<em>μ</em>) 决定了滤波器系数的更新速度，过大或过小的步长因子都可能影响滤波效果。</li><li><strong>增加滤波器长度</strong>：较长的滤波器可以捕捉更多的信号特征，但也增加了计算复杂度。</li><li><strong>使用参考信号</strong>：在实际应用中，通常需要一个参考信号作为期望信号 (𝑑(𝑛)<em>d</em>(<em>n</em>))。如果没有理想信号，可以尝试使用噪声信号的估计值。</li><li><strong>预处理和后处理</strong>：在滤波前后进行适当的预处理和后处理，例如平滑、归一化等。</li></ol> 
<p>这几种处理方法，我更推荐前面三种方法，简单高效。其中在自适应滤波应用中，参考信号的选择取决于具体的应用场景和目标。</p> 
<pre><code class="prism language-python"><span class="token comment"># 读取音频文件</span>
noisy_signal<span class="token punctuation">,</span> sample_rate <span class="token operator">=</span> librosa<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'pure_music_with_white_noise.wav'</span><span class="token punctuation">,</span> sr<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
noise_signal<span class="token punctuation">,</span> _ <span class="token operator">=</span> librosa<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'pure_music_with_white_noise.wav'</span><span class="token punctuation">,</span> sr<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
reference_signal<span class="token punctuation">,</span> _ <span class="token operator">=</span> librosa<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'pure_music.wav'</span><span class="token punctuation">,</span> sr<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>  <span class="token comment"># 使用参考信号</span>
<span class="token comment"># 自适应滤波参数</span>
mu <span class="token operator">=</span> <span class="token number">0.00001</span>   <span class="token comment"># 步长因子</span>
num_taps <span class="token operator">=</span> <span class="token number">512</span>  <span class="token comment"># 滤波器长度</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/12/7a/gplbhszF_o.png" alt="在这里插入图片描述"></p> 
<p>期望信号是仿真中不考虑噪声影响的系统输出，在实际中我们是无法获得的，只能在仿真中得到。期望信号与具体的应用场合有关。比如在胎儿的心音检测中。输入信号x(n)=sm(n)+sb(n),其中sm为孕妇的心音信号，sb为胎儿的心音信号。此时自适应滤波器要输出的是胎儿的心音信号sb(n)。因此此时可以将x(n)看做是期望输出信号，sm为输入信号，这样，通过自适应滤波器之后就得到实际需要的sb(n)了。x(n)可以通过放置在胎儿位置的传感器得到，sm可以通过放置在远离胎儿的位置的传感器得到。</p> 
<p>实际上，基于维纳滤波的问题都涉及到期望信号的理解。很多人往往会问，要是知道了期望输出信号，还需要滤波做什么呢？实际上不完全是这么回事的。如果从去相关的角度，就非常好理解期望信号的问题了。</p> 
<p>期望信号是仿真中不考虑噪声影响的系统输出，在实际中我们是无法获得的，只能在仿真中得到。期望信号与具体的应用场合有关。比如在胎儿的心音检测中。输入信号x(n)=sm(n)+sb(n),其中sm为孕妇的心音信号，sb为胎儿的心音信号。此时自适应滤波器要输出的是胎儿的心音信号sb(n)。因此此时可以将x(n)看做是期望输出信号，sm为输入信号，这样，通过自适应滤波器之后就得到实际需要的sb(n)了。x(n)可以通过放置在胎儿位置的传感器得到，sm可以通过放置在远离胎儿的位置的传感器得到。</p> 
<p>实际上，基于维纳滤波的问题都涉及到期望信号的理解。很多人往往会问，要是知道了期望输出信号，还需要滤波做什么呢？实际上不完全是这么回事的。如果从去相关的角度，就非常好理解期望信号的问题了。</p> 
<h5><a id="_394"></a>提取纯噪声</h5> 
<p>从录音中提取纯噪声部分通常涉及识别和分离音频中的噪声段有:</p> 
<p>手动方法</p> 
<ol><li><strong>试听音频</strong>：手动试听音频文件，找到没有目标信号的噪声段。</li><li><strong>音频剪辑工具</strong>：使用音频剪辑工具（如Audacity），手动剪切和提取噪声段。</li></ol> 
<p>自动方法</p> 
<ol><li><strong>静音检测</strong>：通过检测音频中的静音段或低能量段，自动识别可能的噪声段。</li><li><strong>语音活动检测（VAD）</strong>：使用语音活动检测算法，识别和提取无语音活动的段落作为噪声参考信号。</li></ol> 
<p>我们也可以通过计算音频信号的短时能量，设定能量阈值从而提取低能量段的音频信号，也就是大概率为噪音信号，再将所有噪声段合并成一个信号。</p> 
<pre><code class="prism language-python"><span class="token comment"># 计算音频信号的短时能量和零交叉率</span>
frame_length <span class="token operator">=</span> <span class="token number">2048</span>
hop_length <span class="token operator">=</span> <span class="token number">512</span>

<span class="token comment"># 短时能量</span>
energy <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>
    np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>noisy_signal<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span>frame_length<span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>noisy_signal<span class="token punctuation">)</span><span class="token punctuation">,</span> hop_length<span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 零交叉率</span>
zcr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>
    librosa<span class="token punctuation">.</span>feature<span class="token punctuation">.</span>zero_crossing_rate<span class="token punctuation">(</span>noisy_signal<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span>frame_length<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>noisy_signal<span class="token punctuation">)</span><span class="token punctuation">,</span> hop_length<span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 标准化能量</span>
energy <span class="token operator">=</span> energy <span class="token operator">/</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>energy<span class="token punctuation">)</span>

<span class="token comment"># 设定能量阈值和ZCR阈值</span>
energy_threshold <span class="token operator">=</span> <span class="token number">0.02</span>
zcr_threshold <span class="token operator">=</span> <span class="token number">0.1</span>

<span class="token comment"># 找到低能量段和高ZCR段的索引</span>
low_energy_indices <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>energy <span class="token operator">&lt;</span> energy_threshold<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
high_zcr_indices <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>zcr <span class="token operator">&gt;</span> zcr_threshold<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

<span class="token comment"># 提取低能量段和高ZCR段的音频信号</span>
noise_segments <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> idx <span class="token keyword">in</span> np<span class="token punctuation">.</span>intersect1d<span class="token punctuation">(</span>low_energy_indices<span class="token punctuation">,</span> high_zcr_indices<span class="token punctuation">)</span><span class="token punctuation">:</span>
    start <span class="token operator">=</span> idx <span class="token operator">*</span> hop_length
    end <span class="token operator">=</span> start <span class="token operator">+</span> frame_length
    noise_segments<span class="token punctuation">.</span>append<span class="token punctuation">(</span>noisy_signal<span class="token punctuation">[</span>start<span class="token punctuation">:</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 检查是否找到任何低能量段和高ZCR段</span>
<span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>noise_segments<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token comment"># 将所有噪声段合并成一个信号</span>
    pure_noise <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>noise_segments<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token comment"># 如果没有找到低能量段和高ZCR段，可以使用白噪声作为默认参考信号</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"没有找到低能量段和高ZCR段，使用白噪声作为参考信号"</span><span class="token punctuation">)</span>
    duration <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>noisy_signal<span class="token punctuation">)</span> <span class="token operator">/</span> sample_rate
    pure_noise <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sample_rate <span class="token operator">*</span> duration<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 保存提取的噪声段</span>
sf<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'extracted_noise.wav'</span><span class="token punctuation">,</span> pure_noise<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span>
</code></pre> 
<p>然后再次去噪即可，不过自适应滤波并不适合去噪白噪音，固大家可以自行尝试其他噪音去噪效果。<br> 本篇文章先写到此，内热太多也不好一下再继续写接下来三种算法。本系列将从最基础的音频数据认知开始一直讲解到最终完成整个语音深度鉴别模型的落地使用，对此项目感兴趣的，对此领域感兴趣的不要错过，多谢大家的支持！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/859e42617ed9b1c196317caf0a9cd439/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">银河麒麟v10操作系统安装dm8数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6224ff9859beff3fdb6da88f6ced09c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机图形学入门05：投影变换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>