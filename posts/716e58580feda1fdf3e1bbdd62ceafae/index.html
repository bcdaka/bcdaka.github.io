<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 8 Stream API 中的 peek() 方法详解，以及需要注意的坑。 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/716e58580feda1fdf3e1bbdd62ceafae/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 8 Stream API 中的 peek() 方法详解，以及需要注意的坑。">
  <meta property="og:description" content="震惊 java一个大坑, 被老板约谈了。 引言 在Java 8中，Stream API引入了许多强大的函数式编程特性，极大地增强了我们对集合数据进行操作的能力。其中一个很有用的方法就是peek()，本文将详细介绍其功能及应用场景。
peek() 方法简介 peek() 是Java 8 Stream API中的一个中间操作方法，它的主要功能是对流中的每个元素执行一个操作（可以是获取、修改或打印等），而不影响流的整体处理流程。这意味着即使使用了peek()，流也可以继续进行后续的映射、过滤或其他操作。
&lt;T&gt; Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action); 参数action是一个Consumer接口的实现，它接受一个泛型参数T，并对其执行某种操作。
示例一：简单使用 peek() 打印元素（） import java.util.Arrays; import java.util.List; import java.util.stream.Stream; public class PeekExample { public static void main(String[] args) { List&lt;String&gt; addrList = Arrays.asList(&#34;AAA&#34;); addrList.stream() .filter(Objects::nonNull) .peek(info -&gt; { System.out.println(&#34;Processing Element: &#34; &#43; info); }).collect(Collectors.toList()); // 输出：Processing Element: AAA } } 在这个例子中，我们首先创建了一个包含一个元素&#34;AAA&#34;的列表，并将其转换为流。随后使用filter()方法去除可能存在的空元素（在此例中其实无需过滤，因为已知元素不为空）。关键在于peek()方法的应用，它接收一个lambda表达式，每当流中的元素被访问时，就执行该表达式，从而实现了打印当前处理元素的功能。
有坑的点：删除流终止操作，将会不执行。 import java.util.Arrays; import java.util.List; import java.util.stream.Stream; public class PeekExample { public static void main(String[] args) { List&lt;String&gt; addrList = Arrays.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-03T16:51:48+08:00">
    <meta property="article:modified_time" content="2024-04-03T16:51:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 8 Stream API 中的 peek() 方法详解，以及需要注意的坑。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_java__0"></a>震惊 java一个大坑, 被老板约谈了。</h2> 
<h3><a id="_2"></a>引言</h3> 
<p>在Java 8中，Stream API引入了许多强大的函数式编程特性，极大地增强了我们对集合数据进行操作的能力。其中一个很有用的方法就是<code>peek()</code>，本文将详细介绍其功能及应用场景。</p> 
<h3><a id="peek__6"></a><code>peek()</code> 方法简介</h3> 
<p><code>peek()</code> 是Java 8 Stream API中的一个中间操作方法，它的主要功能是对流中的每个元素执行一个操作（可以是获取、修改或打印等），而不影响流的整体处理流程。这意味着即使使用了<code>peek()</code>，流也可以继续进行后续的映射、过滤或其他操作。</p> 
<pre><code class="prism language-java"><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数<code>action</code>是一个Consumer接口的实现，它接受一个泛型参数T，并对其执行某种操作。</p> 
<h4><a id="_peek__16"></a>示例一：简单使用 <code>peek()</code> 打印元素（）</h4> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span></span><span class="token class-name">Stream</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PeekExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> addrList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"AAA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        addrList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token operator">::</span><span class="token function">nonNull</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>info <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Processing Element: "</span> <span class="token operator">+</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 输出：Processing Element: AAA</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们首先创建了一个包含一个元素"AAA"的列表，并将其转换为流。随后使用<code>filter()</code>方法去除可能存在的空元素（在此例中其实无需过滤，因为已知元素不为空）。关键在于<code>peek()</code>方法的应用，它接收一个lambda表达式，每当流中的元素被访问时，就执行该表达式，从而实现了打印当前处理元素的功能。</p> 
<h4><a id="_39"></a>有坑的点：删除流终止操作，将会不执行。</h4> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span></span><span class="token class-name">Stream</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PeekExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> addrList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"AAA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        addrList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token operator">::</span><span class="token function">nonNull</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>info <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Processing Element: "</span> <span class="token operator">+</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出：</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这段代码中peek不会被执行，并且不会打印</strong>。</p> 
<blockquote> 
 <p>peek()方法是 Strean 接口中的一个中间操作，它允许你在流的每 个元素上执行一个操作，但是这个操作是在最终的终端操作(如<br> forEach,collect,limit 等)执行 前进行的。 然而，如果 peek()是流中唯一的操作，那么它实际上不会执行。这是因为<br> peek ()本身并不是一个 终端操作，它不会触发流的执行。在 jav 8 及以后的版本中，流的执行是情性的，这意味着流操作<br> 不会立即执行，而是在遇到终端操作时才会实际执行</p> 
</blockquote> 
<h4><a id="_peek__67"></a>示例二：结合 <code>peek()</code> 进行调试</h4> 
<p><code>peek()</code>方法的一个常见用途是在调试时查看流中的元素状态，而不会影响到流的最终处理结果。</p> 
<pre><code class="prism language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numbers <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
numbers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 将每个数乘以2</span>
       <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Mapped value: "</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 过滤出能被3整除的数</span>
       <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Filtered value: "</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 收集到List中</span>
</code></pre> 
<p>在上述代码中，我们在映射和过滤操作之间插入了两次<code>peek()</code>，分别用来查看映射后的值和过滤后的值，这对于理解流的处理过程非常有帮助。</p> 
<p>总结起来，<code>peek()</code>方法就像是一个观察者，可以在不影响流整体处理的情况下，让我们有机会在每个元素上执行一些额外的操作，例如日志记录、临时计算、调试信息打印等。但它并不改变流的原始内容，也不决定流的最终输出结果。要得到流的处理结果，还需要进一步调用诸如<code>collect()</code>, <code>forEach()</code>, <code>reduce()</code>等终端操作方法。</p> 
<h3><a id="_84"></a>需要注意的坑</h3> 
<h4><a id="peek__85"></a>坑一：peek() 不影响流的生成和消费</h4> 
<p>peek()是一个中间操作，它并不会终止流的处理流程，因此如果不跟一个终端操作（如collect(), forEach(), count()等），则peek()中的操作虽然会被执行，但整个流式处理链的结果不会有任何产出。换言之，只有当流被消耗时，peek()里的操作才会真正发生。</p> 
<h4><a id="peek__88"></a>坑二：peek() 的执行次数取决于下游操作</h4> 
<p>peek()方法中的动作会在流的每个元素上执行一次，但具体执行多少次取决于下游的终端操作。例如，如果你在排序(sorted())前使用了peek()，而在排序后又使用了一次peek()，则同一个元素可能会被两次peek()。</p> 
<h4><a id="peek_91"></a>坑三：并发流中的peek()行为</h4> 
<p>对于并行流，peek()操作的执行顺序没有保证，而且可能会多次执行（取决于JVM的具体调度）。如果你在并行流中依赖peek()的顺序性或唯一性，可能会遇到意想不到的问题。</p> 
<h4><a id="_94"></a>坑四：资源管理</h4> 
<p>如果在peek()中打开了一些资源（如文件、数据库连接等），但在peek()内部并未妥善关闭它们，可能会导致资源泄露。因为在没有终端操作的情况下，流可能不会立即执行，资源也就无法及时释放。</p> 
<h4><a id="_97"></a>坑五：对流元素的修改可能无效</h4> 
<p>peek()通常用于读取或打印流元素，而不是修改它们。虽然理论上可以尝试在peek()中修改元素，但由于流的惰性求值和可能的不可变性，这样的修改可能不会反映到源集合或后续流操作中。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d45c98c91d43a4bb6a3676d9f887ddf7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql不区分大小写配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03f54b20523660fb73fc973ab44df51c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">25个Android酷炫开源UI框架，2024吊打面试官系列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>