<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的内部类（如果想知道Java中有关内部类的知识点，那么只看这一篇就足够了！） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d9d1755bbd756a5d97e2c0fbb98b371c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中的内部类（如果想知道Java中有关内部类的知识点，那么只看这一篇就足够了！）">
  <meta property="og:description" content="前言：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么这个内部的完整结构最好使用内部类。在 Java 中，可以将一个类定义在另一个类或者一个方法的内部，前者称为内部类，后者称为外部类。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文的大致内容：
目录
1.内部类的分类及作用
（1）成员内部类（Member Inner Class）
（2）静态内部类（Static Nested Class）
（3）局部内部类（Local Inner Class）
（4）匿名内部类（Anonymous Inner Class）
内部类的作用总结：
2.实例内部类
（1）实例内部类的大致定义形式：
（2）实例内部类对象的创建
（3）综合案例
3.静态内部类
（1）静态内部类的大致定义形式：
（2）静态内部类对象的创建
（3）综合案例
4.局部内部类
（1）局部内部类的大致定义形式：
（2）局部内部类对象的创建
（3）综合案例
5.匿名内部类
（1）匿名内部类的大致定义形式：
（2）局部内部类对象的创建
（3）综合案例
1.内部类的分类及作用 在前言中我们已经大致的了解了Java中的内部类，但是在开始学习各种内部类之前，先让我们了解一下有哪些内部类及各个内部类的作用，根据其定义位置和特性，内部类可以分为以下几种主要类型：
（1）成员内部类（Member Inner Class） ——定义位置： 成员内部类定义在一个类的内部，作为该类的成员，与类的其他成员（字段、方法等）处于同一层次。
——作用： 成员内部类可以访问外部类的所有成员（包括私有成员），并且可以被外部类的方法调用。它通常用于与外部类有密切关系的场景，如实现某种数据结构的迭代器或者实现某种特定逻辑的辅助类。
（2）静态内部类（Static Nested Class） ——定义位置： 静态内部类使用 static 关键字修饰，与外部类的实例无关，通常定义在外部类的内部作为静态成员。
——作用： 静态内部类可以直接通过外部类的类名访问，不需要依赖外部类的实例。它通常用于组织和封装与外部类紧密相关的辅助功能，例如工具类或者单例模式的实现。
（3）局部内部类（Local Inner Class） ——定义位置： 局部内部类定义在方法内部，作为方法的局部变量。
——作用： 局部内部类的作用域仅限于所在方法内部，通常用于封装一些复杂的逻辑或者需要单次使用的类定义。它可以访问方法的参数和局部变量，但是这些变量必须声明为 final 或者是实际上的 final（即不可再被修改）。
（4）匿名内部类（Anonymous Inner Class） ——定义位置： 匿名内部类没有显式的类名，在创建对象的同时直接实现类的定义。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-20T16:12:14+08:00">
    <meta property="article:modified_time" content="2024-06-20T16:12:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的内部类（如果想知道Java中有关内部类的知识点，那么只看这一篇就足够了！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>      <strong>  前言：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么这个内部的完整结构最好使用内部类。在 Java 中，可以将一个类定义在另一个类或者一个方法的内部，前者称为内部类，后者称为外部类。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/17/e9/e1ARL2XW_o.jpg"></p> 
 <p><strong>✨<span style="color:#ff9900;">✨✨这里是秋刀鱼不做梦的BLOG</span></strong></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本文的大致内容：</strong></span></p> 
<p><img alt="" src="https://images2.imgbox.com/66/65/bbX6NvAV_o.png"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8-toc" style="margin-left:0px;"><strong><a href="#1.%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8" rel="nofollow">1.内部类的分类及作用</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Member%20Inner%20Class%EF%BC%89-toc" style="margin-left:80px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Member%20Inner%20Class%EF%BC%89" rel="nofollow">        （1）成员内部类（Member Inner Class）</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Static%20Nested%20Class%EF%BC%89-toc" style="margin-left:80px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Static%20Nested%20Class%EF%BC%89" rel="nofollow">        （2）静态内部类（Static Nested Class）</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Local%20Inner%20Class%EF%BC%89-toc" style="margin-left:80px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Local%20Inner%20Class%EF%BC%89" rel="nofollow">        （3）局部内部类（Local Inner Class）</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%884%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Anonymous%20Inner%20Class%EF%BC%89-toc" style="margin-left:80px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%884%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Anonymous%20Inner%20Class%EF%BC%89" rel="nofollow">        （4）匿名内部类（Anonymous Inner Class）</a></strong></p> 
<p id="%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:80px;"><strong><a href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">内部类的作用总结：</a></strong></p> 
<p id="2.%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:0px;"><strong><a href="#2.%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">2.实例内部类</a></strong></p> 
<p id="%EF%BC%881%EF%BC%89%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%881%EF%BC%89%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A" rel="nofollow">（1）实例内部类的大致定义形式：</a></strong></p> 
<p id="%EF%BC%882%EF%BC%89%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%882%EF%BC%89%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">（2）实例内部类对象的创建</a></strong></p> 
<p id="%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B" rel="nofollow">（3）综合案例</a></strong></p> 
<p id="3.%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:0px;"><strong><a href="#3.%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">3.静态内部类</a></strong></p> 
<p id="%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A" rel="nofollow">（1）静态内部类的大致定义形式：</a></strong></p> 
<p id="%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">（2）静态内部类对象的创建</a></strong></p> 
<p id="%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B" rel="nofollow">（3）综合案例</a></strong></p> 
<p id="4.%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:0px;"><strong><a href="#4.%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">4.局部内部类</a></strong></p> 
<p id="%EF%BC%881%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%881%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A" rel="nofollow">（1）局部内部类的大致定义形式：</a></strong></p> 
<p id="%EF%BC%882%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%882%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">（2）局部内部类对象的创建</a></strong></p> 
<p id="%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B" rel="nofollow">（3）综合案例</a></strong></p> 
<p id="5.%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:0px;"><strong><a href="#5.%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">5.匿名内部类</a></strong></p> 
<p id="%EF%BC%881%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%881%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A" rel="nofollow">（1）匿名内部类的大致定义形式：</a></strong></p> 
<p id="%EF%BC%882%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%882%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">（2）局部内部类对象的创建</a></strong></p> 
<p id="%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B" rel="nofollow">（3）综合案例</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8"><span style="color:#956fe7;">1.内部类的分类及作用</span></h2> 
<p><strong>        在前言中我们已经大致的了解了Java中的内部类，但是在开始学习各种内部类之前，先让我们了解一下有哪些内部类及各个内部类的作用，根据其定义位置和特性，内部类可以分为以下几种主要类型：</strong></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Member%20Inner%20Class%EF%BC%89"><span style="color:#4da8ee;">        </span><span style="color:#4da8ee;">（1）成员内部类（Member Inner Class）</span></h4> 
<p><span style="color:#4da8ee;">   </span>     <span style="color:#a2e043;">——</span><span style="color:#a2e043;"><strong>定义位置：</strong></span> 成员内部类定义在一个类的内部，作为该类的成员，与类的其他成员（字段、方法等）处于同一层次。</p> 
<p>      <span style="color:#a2e043;">  ——<strong>作用：</strong></span> 成员内部类可以访问外部类的所有成员（包括私有成员），并且可以被外部类的方法调用。它通常用于与外部类有密切关系的场景，如实现某种数据结构的迭代器或者实现某种特定逻辑的辅助类。</p> 
<p></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Static%20Nested%20Class%EF%BC%89"><span style="color:#4da8ee;">        </span><span style="color:#4da8ee;">（2）静态内部类（Static Nested Class）</span></h4> 
<p>        <span style="color:#a2e043;">——<strong>定义位置：</strong></span> 静态内部类使用 <code>static</code> 关键字修饰，与外部类的实例无关，通常定义在外部类的内部作为静态成员。</p> 
<p>     <span style="color:#a2e043;">   ——<strong>作用：</strong></span> 静态内部类可以直接通过外部类的类名访问，不需要依赖外部类的实例。它通常用于组织和封装与外部类紧密相关的辅助功能，例如工具类或者单例模式的实现。</p> 
<p></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Local%20Inner%20Class%EF%BC%89"><span style="color:#4da8ee;">        </span><span style="color:#4da8ee;">（3）局部内部类（Local Inner Class）</span></h4> 
<p>   <span style="color:#a2e043;">     ——<strong>定义位置：</strong> </span>局部内部类定义在方法内部，作为方法的局部变量。</p> 
<p>      <span style="color:#a2e043;">  ——<strong>作用：</strong></span> 局部内部类的作用域仅限于所在方法内部，通常用于封装一些复杂的逻辑或者需要单次使用的类定义。它可以访问方法的参数和局部变量，但是这些变量必须声明为 <code>final</code> 或者是实际上的 <code>final</code>（即不可再被修改）。</p> 
<p></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%884%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Anonymous%20Inner%20Class%EF%BC%89"><span style="color:#4da8ee;">        </span><span style="color:#4da8ee;">（4）匿名内部类（Anonymous Inner Class）</span></h4> 
<p>      <span style="color:#a2e043;">  ——<strong>定义位置：</strong></span> 匿名内部类没有显式的类名，在创建对象的同时直接实现类的定义。</p> 
<p><span style="color:#a2e043;">        ——<strong>作用：</strong></span> 匿名内部类通常用于创建只需一次使用的类的实例，例如实现接口或抽象类的匿名实现。它简化了代码的编写，使得代码更加紧凑和易于理解。</p> 
<h4 id="%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%9A"><span style="color:#fe2c24;">内部类的作用总结：</span></h4> 
<blockquote> 
 <ul><li><strong>提高封装性和组织性：</strong> 内部类可以访问外部类的私有成员，有助于将相关的功能封装在一起，提高代码的模块化和可维护性。</li><li><strong>实现复杂设计模式：</strong> 内部类在实现一些复杂的设计模式或者数据结构时特别有用，如迭代器模式、工厂模式等。</li><li><strong>实现回调函数和事件处理：</strong> 匿名内部类常用于实现回调函数和事件处理，使得代码更加灵活和可扩展。</li><li><strong>提供更好的代码结构和可读性：</strong> 合理使用内部类可以使得代码结构更加清晰和易于理解，尤其是在处理复杂逻辑或者嵌套关系较多的情况下。</li></ul> 
</blockquote> 
<p><span style="color:#ff9900;"><strong>        </strong></span><span style="color:#ff9900;"><strong>通过上边对于每个内部类的大致讲解，我相信读者对于内部类已经有了一些初步的理解，但是光是看上面这些生硬冰冷的文字，我相信读者可能还是不能很好的理解Java中的内部类，那么接下来让我们对上面的各个内部类进行一一讲解。</strong></span></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>       —— 为了方便读者理解，我们每个内部类都会采用先介绍其定义的方式，然后介绍如何创建其内部类的对象，最后使用一个综合的案例加深理解的流程讲解每个内部类。</strong></span></p> 
<p></p> 
<h2 id="2.%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB"><span style="color:#956fe7;"><strong>2.</strong>实例内部类</span></h2> 
<p>     <strong>   在Java中，实例内部类（也称为非静态内部类）是定义在另一个类（外部类）内部的类，并且这个内部类会隐式地持有一个对外部类实例的引用。</strong></p> 
<h4 id="%EF%BC%881%EF%BC%89%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A"><span style="color:#ffd900;"><strong>（1）实例内部类的大致定义形式：</strong></span></h4> 
<pre><code class="language-java">//外部类
public class OuterClass {
    //外部类成员变量
    private int outerField;

    //外部类成员方法
    public void outerMethod() {
        System.out.println("Outer method");
    }

    //内部类
    public class InstanceInnerClass {
        //内部类成员变量
        private int innerField;

        //内部类成员方法
        public void innerMethod() {
            
        }
    }
}
</code></pre> 
<p>    <span style="color:#38d8f0;"><strong>    以上就是实例内部类的大致定义形式，也就是说如果我们需要一个实例内部类的话，我们就会像上述那样定义一个外部类，然后定义一个其内部类。</strong></span></p> 
<p></p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><strong><span style="color:#ffd900;">（2）</span></strong><span style="color:#ffd900;"><strong>实例内部类对象的创建</strong></span></h4> 
<p>        <strong>根据上边的代码，我们现在在测试类中创建其内部类的实例：</strong></p> 
<pre><code class="language-java">	public class TestInnerClass {  
	    public static void main(String[] args) {  

	        // 创建外部类实例  
	        OuterClass outer = new OuterClass();  

	        // 通过外部类实例创建内部类实例  
	        OuterClass.InstanceInnerClass inner = outer.new InstanceInnerClass();  
	    }  
	}</code></pre> 
<p>        <span style="color:#38d8f0;"><strong>我们会发现，如果想要创建实例内部类，那么我们就必须先创建外部类的实例对象，在创建内部类的实例对象。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注意事项：</strong></span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>        1. 外部类中的任何成员都可以在实例内部类方法中直接访问<br>         2. 实例内部类所处的位置与外部类成员位置相同，因此也受public、private等访问限定符的约束<br>         3. 在实例内部类方法中访问同名的成员时，优先访问自己的，如果要访问外部类同名的成员，必须：外部类名称.this.同名成员 来访问<br>         4. 实例内部类对象必须在先有外部类对象前提下才能创建<br>         5. 实例内部类的非静态方法中包含了一个指向外部类对象的引用<br>         6. 外部类中，不能直接访问实例内部类中的成员，如果要访问必须先要创建内部类的对象。</strong></span></p> 
</blockquote> 
<h4 id="%EF%BC%883%EF%BC%89%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span style="color:#ffd900;">（3）综合案例</span></h4> 
<p>   <span style="color:#ff9900;">   <strong>  现在让我们通过一个简单的例子来演示Java中实例内部类的使用。假设我们有一个外部类 <code>Car</code> 表示汽车，汽车有品牌和颜色属性，并且每辆汽车可以有一个内部类 <code>Engine</code> 表示其引擎。</strong></span></p> 
<pre><code class="language-java">// 外部类 Car
public class Car {
    private String brand;
    private String color;

    // 构造方法
    public Car(String brand, String color) {
        this.brand = brand;
        this.color = color;
    }

    // 外部类的方法
    public void displayInfo() {
        System.out.println("Car brand: " + brand);
        System.out.println("Car color: " + color);
    }

    // 内部类 Engine
    public class Engine {
        private int horsepower;

        // 构造方法
        public Engine(int horsepower) {
            this.horsepower = horsepower;
        }

        // 内部类的方法
        public void start() {
            System.out.println("Engine started! Horsepower: " + horsepower);
        }
    }
}
</code></pre> 
<p><span style="color:#a2e043;"><strong>在这个例子中：</strong></span></p> 
<blockquote> 
 <ul><li><code>Car</code> 类是外部类，它有两个私有属性 <code>brand</code> 和 <code>color</code>，以及一个构造方法用于初始化这些属性。</li><li><code>Car</code> 类中有一个方法 <code>displayInfo()</code>，用于显示汽车的品牌和颜色。</li><li><code>Car</code> 类内部定义了一个实例内部类 <code>Engine</code>，表示汽车的引擎。<code>Engine</code> 类有一个私有属性 <code>horsepower</code> 表示马力，并有一个构造方法初始化这个属性。</li><li><code>Engine</code> 类中有一个方法 <code>start()</code>，用于启动引擎并显示其马力。</li></ul> 
</blockquote> 
<p><span style="color:#ff9900;"><strong>下面是如何在 <code>Main</code> 类中使用 <code>Car</code> 类及其内部类 <code>Engine</code> 的示例：</strong></span></p> 
<pre><code class="language-java">// 主类 Main
public class Main {
    public static void main(String[] args) {
        // 创建外部类的对象
        Car myCar = new Car("Toyota", "Red");

        // 调用外部类的方法
        myCar.displayInfo();

        // 创建内部类的对象
        Car.Engine engine = myCar.new Engine(150);

        // 调用内部类的方法
        engine.start();
    }
}
</code></pre> 
<p><span style="color:#a2e043;"><strong>在 <code>Main</code> 类的 <code>main</code> 方法中：</strong></span></p> 
<blockquote> 
 <ul><li>首先创建了外部类 <code>Car</code> 的对象 <code>myCar</code>，并传入品牌 "Toyota" 和颜色 "Red"。</li><li>调用外部类的方法 <code>displayInfo()</code>，显示汽车的品牌和颜色。</li><li>创建了内部类 <code>Engine</code> 的对象 <code>engine</code>，使用语法 <code>myCar.new Engine(150)</code>，表示该引擎有150马力。</li><li>调用内部类 <code>Engine</code> 的方法 <code>start()</code>，启动引擎并显示其马力。</li></ul> 
</blockquote> 
<p>这样我们就大致的了解完了Java中的实例内部类了。</p> 
<p></p> 
<h2 id="3.%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span style="color:#956fe7;">3.静态内部类</span></h2> 
<p>       <strong> 静态内部类（Static Inner Class）在Java中是指定义在另一个类内部并使用 <code>static</code> 修饰的类。</strong></p> 
<h4 id="%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A"><span style="color:#ffd900;"><strong>（1）静态内部类的大致定义形式：</strong></span></h4> 
<pre><code class="language-java">public class OuterClass {
    // 外部类的成员变量和方法
    private static int outerStaticField;
    private int outerInstanceField;

    public static void outerStaticMethod() {
        // 外部类的静态方法
    }

    // 静态内部类
    public static class StaticInnerClass {
        // 内部类的成员变量和方法
        private int innerField;

        public void innerMethod() {
            
        }
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>以上就是静态内部类的大致定义形式，和实例内部类的大致相同，只不过在定义静态内部类时，加上了static关键词。</strong></span></p> 
<p></p> 
<h4 id="%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><strong><span style="color:#ffd900;">（2）静态</span></strong><span style="color:#ffd900;"><strong>内部类对象的创建</strong></span></h4> 
<p><strong>        根据上边的代码，我们现在在测试类中创建其内部类的实例：</strong></p> 
<pre><code class="language-java">    public static void main(String[] args) {
        // 创建静态内部类的实例
        StaticInnerClass innerObject = new StaticInnerClass();

    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>我们会发现，相较于实例内部类而言，静态内部类不需要依赖外部类的实例而可以被实例化和使用。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注意事项：</strong></span></p> 
<blockquote> 
 <p><span style="color:#38d8f0;"><strong>     </strong></span><span style="color:#fe2c24;"><strong>   </strong><strong>1.在静态内部类中只能访问外部类中的静态成员</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>        </strong><strong>2.创建静态内部类对象时，不需要先创建外部类对象</strong></span></p> 
</blockquote> 
<h4><span style="color:#ffd900;">（3）综合案例</span></h4> 
<p> <span style="color:#ff9900;"><strong>       让我们通过一个简单的例子来演示Java中静态内部类的使用。假设我们有一个外部类 <code>Outer</code> 表示外部容器，里面包含一个静态内部类 <code>Inner</code>，用来表示容器内部的元素。</strong></span></p> 
<pre><code class="language-java">// 外部类 Outer
public class Outer {
    private static String outerField = "Outer's static field";

    // 外部类的静态方法
    public static void outerStaticMethod() {
        System.out.println("Outer's static method");
    }

    // 静态内部类 Inner
    public static class Inner {
        private String innerField;

        // 内部类的构造方法
        public Inner(String innerField) {
            this.innerField = innerField;
        }

        // 内部类的方法
        public void display() {
            System.out.println("Inner's method: " + innerField);
            System.out.println("Accessing outer's static field: " + outerField);
            outerStaticMethod();
        }
    }

    public static void main(String[] args) {
        // 创建静态内部类的实例
        Inner innerObject = new Inner("Inner's field");

        // 调用内部类的方法
        innerObject.display();
    }
}
</code></pre> 
<p><span style="color:#a2e043;"><strong>在这个例子中：</strong></span></p> 
<blockquote> 
 <ul><li><code>Outer</code> 是外部类，它包含了一个静态成员变量 <code>outerField</code> 和一个静态方法 <code>outerStaticMethod()</code>。</li><li><code>Inner</code> 是静态内部类，使用 <code>static</code> 关键字修饰，可以直接通过外部类的类名访问，即 <code>Outer.Inner</code>。</li><li><code>Inner</code> 类有一个私有成员变量 <code>innerField</code> 和一个公共方法 <code>display()</code>，在 <code>display()</code> 方法中可以访问外部类的静态成员变量和静态方法。</li></ul> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>在 <code>main</code> 方法中：</strong></span></p> 
<blockquote> 
 <ul><li><code>Outer</code> 是外部类，它包含了一个静态成员变量 <code>outerField</code> 和一个静态方法 <code>outerStaticMethod()</code>。</li><li><code>Inner</code> 是静态内部类，使用 <code>static</code> 关键字修饰，可以直接通过外部类的类名访问，即 <code>Outer.Inner</code>。</li><li><code>Inner</code> 类有一个私有成员变量 <code>innerField</code> 和一个公共方法 <code>display()</code>，在 <code>display()</code> 方法中可以访问外部类的静态成员变量和静态方法。</li></ul> 
</blockquote> 
<p>这样我们就大致的了解完了Java中的静态内部类了。</p> 
<p></p> 
<h2 id="4.%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span style="color:#956fe7;">4.局部内部类</span></h2> 
<p>     <strong>   局部内部类（Local Inner Class）是定义在方法内部的类，它只在方法内部可见和有效。局部内部类具有以下特点：</strong></p> 
<blockquote> 
 <p></p> 
 <ul><li>只能在方法内部声明，作用范围仅限于所属方法内部。</li><li>可以访问所在方法的局部变量，但是这些变量必须声明为 <code>final</code> 或者是事实上的 <code>final</code> 变量（即不能再被赋值的变量）。</li><li>可以访问所在类的所有成员，包括私有成员，并且可以访问外部类的所有成员。</li><li>不能包含静态成员（包括静态方法、静态变量、静态初始化块）。</li></ul> 
</blockquote> 
<h4 id="%EF%BC%881%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A"><span style="color:#ffd900;"><strong>（1）局部内部类的大致定义形式：</strong></span></h4> 
<pre><code class="language-java">public class OuterClass {
    private int outerField = 10;

    public void outerMethod() {
        final int localVar = 20; // 局部变量，必须为 final 或事实上的 final

        // 局部内部类 LocalInnerClass
        class LocalInnerClass {
            public void innerMethod() {
                System.out.println("Accessing local variable: " + localVar);
                System.out.println("Accessing outer field: " + outerField);
                outerMethod(); // 可以访问外部类的方法
            }
        }
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>以上就是局部内部类的大致定义形式，我们会发现其只能在方法内部声明，作用范围仅限于所属方法内部。并且该内部类在日常生活中基本不会定义与使用。</strong></span></p> 
<p></p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><strong><span style="color:#ffd900;">（2）局部</span></strong><span style="color:#ffd900;"><strong>内部类对象的创建</strong></span></h4> 
<p><strong>        根据上边的代码，我们现在创建其内部类的实例：</strong></p> 
<pre><code class="language-java">public class OuterClass {
    private int outerField = 10;

    public void outerMethod() {
        final int localVar = 20; // 局部变量，必须为 final 或事实上的 final

        // 局部内部类 LocalInnerClass
        class LocalInnerClass {
            public void innerMethod() {
                System.out.println("Accessing local variable: " + localVar);
                System.out.println("Accessing outer field: " + outerField);
            }
        }

        // 创建局部内部类的实例
        LocalInnerClass innerObject = new LocalInnerClass();
        innerObject.innerMethod();
    }

    public static void main(String[] args) {
        OuterClass outerObject = new OuterClass();
        outerObject.outerMethod();
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>        从上边的代码中我们会发现，局部内部类的实例化代码通常直接在包含它的方法内部进行，因为局部内部类的作用范围仅限于所在方法内部。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注意事项：</strong></span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>        </strong></span><span style="color:#fe2c24;"><strong>1. 局部内部类只能在所定义的方法体内部使用</strong></span><br><span style="color:#fe2c24;"><strong>        </strong></span><span style="color:#fe2c24;"><strong>2. 不能被public、static等修饰符修饰</strong></span><br><span style="color:#fe2c24;"><strong>        </strong></span><span style="color:#fe2c24;"><strong>3. 编译器也有自己独立的字节码文件，命名格式：外部类名字$数字内部类名字.class</strong></span><br><span style="color:#fe2c24;"><strong>        </strong></span><span style="color:#fe2c24;"><strong>4. 几乎不会使用</strong></span></p> 
</blockquote> 
<h4><span style="color:#ffd900;">（3）综合案例</span></h4> 
<p>    <span style="color:#ff9900;"><strong>    以下是一个简单的例子，演示了如何在Java中使用局部内部类。假设我们有一个外部类 <code>Calculator</code> 表示计算器，其中有一个方法用来计算两个整数的和，同时使用局部内部类来实现一个简单的日志记录功能。</strong></span></p> 
<pre><code class="language-java">public class Calculator {
    public int add(int a, int b) {
        // 局部内部类 LogRecorder，用于记录日志
        class LogRecorder {
            public void logAddition(int num1, int num2, int result) {
                System.out.println("Adding " + num1 + " and " + num2);
                System.out.println("Result: " + result);
            }
        }

        // 执行加法运算
        int result = a + b;

        // 创建局部内部类 LogRecorder 的实例
        LogRecorder logger = new LogRecorder();
        // 记录日志
        logger.logAddition(a, b, result);

        // 返回加法结果
        return result;
    }

    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        int sum = calculator.add(5, 3);
        System.out.println("Sum: " + sum);
    }
}
</code></pre> 
<p><span style="color:#a2e043;"><strong>在这个例子中：</strong></span></p> 
<blockquote> 
 <ul><li><code>Calculator</code> 是外部类，包含了一个方法 <code>add(int a, int b)</code> 用于计算两个整数的和。</li><li>在 <code>add(int a, int b)</code> 方法内部定义了一个局部内部类 <code>LogRecorder</code>，用于记录加法运算的日志。</li><li><code>LogRecorder</code> 类有一个方法 <code>logAddition(int num1, int num2, int result)</code>，在这个方法中输出了加法操作的参数和结果。</li><li>在 <code>add(int a, int b)</code> 方法中，首先执行加法运算得到结果 <code>result</code>，然后创建了 <code>LogRecorder</code> 类的实例 <code>logger</code>，并调用其方法记录加法的操作日志。</li><li><code>main</code> 方法中创建了 <code>Calculator</code> 的实例，并调用 <code>add(int a, int b)</code> 方法进行加法计算，最后输出了计算结果。</li></ul> 
</blockquote> 
<p>这样我们就大致的了解完了Java中的局部内部类了。</p> 
<p></p> 
<h2 id="5.%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span style="color:#956fe7;">5.匿名内部类</span></h2> 
<p>    <strong>    匿名内部类是一种没有显式定义类名的局部内部类，在使用时直接创建它的实例。它通常用于简化代码，特别是在创建实现某个接口或者继承某个类的对象时非常方便。</strong></p> 
<p><span style="color:#fe2c24;"><strong>特点和用法：</strong></span></p> 
<blockquote> 
 <ul><li> <p><strong>没有显式类名：</strong> 匿名内部类没有类名，它是在创建对象时定义类的实现或者继承，然后立即实例化。</p> </li><li> <p><strong>用途：</strong></p> 
   <ul><li><strong>实现接口：</strong> 可以通过匿名内部类直接实现接口并创建接口的实例对象。</li><li><strong>继承类：</strong> 可以通过匿名内部类直接继承一个类并实例化子类对象。</li></ul></li><li> <p><strong>语法：</strong> 匿名内部类的语法是在创建对象时使用 <code>new</code> 关键字后，跟上一个类或者接口名，并使用一对大括号 <code>{}</code> 包括内部类的具体实现。</p> </li></ul> 
</blockquote> 
<h4 id="%EF%BC%881%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F%EF%BC%9A"><span style="color:#ffd900;"><strong>（1）匿名内部类的大致定义形式：</strong></span></h4> 
<pre><code class="language-java">interface Greeting {
    void greet();
}

public class Main {
    public static void main(String[] args) {
        // 使用匿名内部类创建接口的实例
        Greeting greeting = new Greeting() {
            @Override
            public void greet() {
                System.out.println("Hello, world!");
            }
        };

        // 调用接口方法
        greeting.greet();
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>以上就是匿名内部类的大致定义形式，</strong></span><span style="color:#38d8f0;"><strong>匿名内部类的使用通常是在需要创建某个接口的实例对象或者继承某个类并实现其方法的场景下非常有用。</strong></span></p> 
<p></p> 
<h4><strong><span style="color:#ffd900;">（2）局部</span></strong><span style="color:#ffd900;"><strong>内部类对象的创建</strong></span></h4> 
<p><span style="color:#ffd900;"><strong>     </strong></span><span style="color:#a2e043;"><strong>   </strong><strong>对于匿名内部类，我们通常不会对其进行实例化，匿名内部类的实例化代码通常是在需要的地方直接使用，并且通常用于一次性的场景。</strong></span></p> 
<h4><span style="color:#ffd900;">（3）综合案例</span></h4> 
<p>      <strong><span style="color:#ff9900;">  以下是一个简单的例子，演示了在Java中如何使用匿名内部类。假设我们有一个接口 <code>Animal</code> 表示动物，其中定义了一个抽象方法 <code>makeSound()</code>，我们可以使用匿名内部类来创建 <code>Animal</code> 接口的实例对象并实现其方法。</span></strong></p> 
<pre><code class="language-java">// 定义一个接口
interface Animal {
    void makeSound();
}

public class Main {
    public static void main(String[] args) {
        // 使用匿名内部类创建接口的实例
        Animal dog = new Animal() {
            @Override
            public void makeSound() {
                System.out.println("Dog: Woof!");
            }
        };

        // 调用接口方法
        dog.makeSound();

        // 使用匿名内部类创建接口的另一个实例
        Animal cat = new Animal() {
            @Override
            public void makeSound() {
                System.out.println("Cat: Meow!");
            }
        };

        // 调用接口方法
        cat.makeSound();
    }
}
</code></pre> 
<p><span style="color:#a2e043;"><strong>在这个例子中：</strong></span></p> 
<blockquote> 
 <ul><li><code>Animal</code> 是一个接口，定义了一个抽象方法 <code>makeSound()</code>。</li><li>在 <code>main</code> 方法中，通过使用匿名内部类创建了两个 <code>Animal</code> 接口的实例对象：<code>dog</code> 和 <code>cat</code>。</li><li>每一个匿名内部类都实现了 <code>makeSound()</code> 方法，分别输出 "Dog: Woof!" 和 "Cat: Meow!"。</li><li>调用每个实例对象的 <code>makeSound()</code> 方法来输出相应的声音。</li></ul> 
</blockquote> 
<p>这样我们就大致的了解完了Java中的匿名内部类了。</p> 
<p><span style="color:#4da8ee;"><strong>        这样我们就将Java中所有的内部类学习完了，通过上边的学习，我们知道在Java中，内部类是嵌套在其他类（外部类）中的类，它可以访问其外部类的所有成员，包括私有成员。并且内部类提供了一种逻辑上组织类的方式，可以实现更加复杂和灵活的设计模式。</strong></span></p> 
<p></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本篇文章的全部内容了~~~</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03c7e426e03c6855d63415252eee8ae0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">汽车信息安全硬件讨论:SE vs HSM</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/efd48b986725836cc91d367222f024b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">物联网边缘网关在物联网应用中有哪些优势？天拓四方</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>