<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ElasticSearch 实现 全文检索 支持（PDF、TXT、Word、HTML等文件）通过 ingest-attachment 插件实现 文档的检索 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/25f42ace1571fc2d11acb98cbff54686/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="ElasticSearch 实现 全文检索 支持（PDF、TXT、Word、HTML等文件）通过 ingest-attachment 插件实现 文档的检索">
  <meta property="og:description" content="一、Attachment 介绍 Attachment 插件是 Elasticsearch 中的一种插件，允许将各种二进制文件（如PDF、Word文档等）以及它们的内容索引到 Elasticsearch 中。插件使用 Apache Tika 库来解析和提取二进制文件的内容。通过使用 Attachment 插件，可以轻松地在 Elasticsearch 中建立全文搜索功能，而无需事先转换二进制文件为文本。
优点：
可以将各种类型的二进制文件以原始形式存储在 Elasticsearch 中。这使得保存和访问二进制文件变得更加简单和高效。
插件使用 Apache Tika 库来解析和提取二进制文件的内容，因此可以提取并存储内容、元数据以及格式化的文本数据。这使得 Elasticsearch 可以轻松地对文档执行全文搜索以及文档内容的其他分析操作。
在 Elasticsearch 中使用 Attachment 插件，可以轻松地实现以下一些功能：搜索文档、生成全文搜索报告、自动标记文件、提取数据并进行分析，在文档中查找特定项等。
缺点：
Attachment 插件对性能有一定的影响，因为执行全文搜索需要解析和提取二进制文件的内容。如果处理大量的二进制文件，可能会影响搜索性能。
Attachment 插件有一些限制，例如插件不支持对二进制文件进行过滤或排除，因此如果文件内容包含敏感信息，则不应使用 Attachment 插件进行索引。
二、初始化 ingest-attachment 1、windows安装 1、先在ES的bin目录下执行命令 安装 ngest-attachment插件
elasticsearch-plugin install ingest-attachment 作者已经安装过了 所以不能重复安装，插件下载过程中会出现
2、Liunx安装 通过官网下载，找到对应的版本号：attachment下载网站
下载好后上传到服务器，进入elasticsearch安装目下的bin目录下。
执行sudo ./elasticsearch-plugin install file:///home/ingest-attachment-7.9.0.zip 即可
重启ES 打印 [apYgDEl] loaded plugin [ingest-attachment] 表示安装成功
3、小结 安装完成后需要重新启动ES
接下来我们需要创建一个关于ingest-attachment的文本抽取管道
PUT /_ingest/pipeline/attachment { &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-14T22:23:17+08:00">
    <meta property="article:modified_time" content="2023-12-14T22:23:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ElasticSearch 实现 全文检索 支持（PDF、TXT、Word、HTML等文件）通过 ingest-attachment 插件实现 文档的检索</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Attachment 介绍</h2> 
<p>Attachment 插件是 Elasticsearch 中的一种插件，允许将各种二进制文件（如PDF、Word文档等）以及它们的内容索引到 Elasticsearch 中。插件使用 Apache Tika 库来解析和提取二进制文件的内容。通过使用 Attachment 插件，可以轻松地在 Elasticsearch 中建立全文搜索功能，而无需事先转换二进制文件为文本。</p> 
<p><strong>优点：</strong></p> 
<blockquote> 
 <ol><li> <p>可以将各种类型的二进制文件以原始形式存储在 Elasticsearch 中。这使得保存和访问二进制文件变得更加简单和高效。</p> </li><li> <p>插件使用 Apache Tika 库来解析和提取二进制文件的内容，因此可以提取并存储内容、元数据以及格式化的文本数据。这使得 Elasticsearch 可以轻松地对文档执行全文搜索以及文档内容的其他分析操作。</p> </li><li> <p>在 Elasticsearch 中使用 Attachment 插件，可以轻松地实现以下一些功能：搜索文档、生成全文搜索报告、自动标记文件、提取数据并进行分析，在文档中查找特定项等。</p> </li></ol> 
</blockquote> 
<p><strong>缺点：</strong></p> 
<blockquote> 
 <ol><li> <p>Attachment 插件对性能有一定的影响，因为执行全文搜索需要解析和提取二进制文件的内容。如果处理大量的二进制文件，可能会影响搜索性能。</p> </li><li> <p>Attachment 插件有一些限制，例如插件不支持对二进制文件进行过滤或排除，因此如果文件内容包含敏感信息，则不应使用 Attachment 插件进行索引。</p> </li></ol> 
</blockquote> 
<p></p> 
<h2>二、初始化 ingest-attachment</h2> 
<h3>1、windows安装</h3> 
<p> 1、先在ES的bin目录下执行命令 安装 ngest-attachment插件</p> 
<pre><code class="language-java">elasticsearch-plugin install ingest-attachment</code></pre> 
<p><img alt="" height="635" src="https://images2.imgbox.com/5b/38/HYe34yDv_o.png" width="1129"></p> 
<p>作者已经安装过了 所以不能重复安装，插件下载过程中会出现</p> 
<p><img alt="" height="81" src="https://images2.imgbox.com/8f/7f/tH040Z2z_o.png" width="619"></p> 
<h3>2、Liunx安装 </h3> 
<p>通过官网下载，找到对应的版本号：<a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/plugins/index.html" rel="nofollow" title="attachment下载网站">attachment下载网站</a></p> 
<blockquote> 
 <p>下载好后上传到服务器，进入elasticsearch安装目下的bin目录下。<br> 执行sudo ./elasticsearch-plugin install file:///home/ingest-attachment-7.9.0.zip 即可<br> 重启ES  打印 [apYgDEl] loaded plugin [ingest-attachment] 表示安装成功</p> 
</blockquote> 
<h3>3、小结</h3> 
<p>安装完成后需要重新启动ES</p> 
<p>接下来我们需要创建一个关于ingest-attachment的文本抽取管道</p> 
<pre><code class="language-java">PUT /_ingest/pipeline/attachment
{
    "description": "Extract attachment information",
    "processors": [
        {
            "attachment": {
                "field": "content",
                "ignore_missing": true
            }
        },
        {
            "remove": {
                "field": "content"
            }
        }
    ]
}</code></pre> 
<p>后续我们的文件需要base64后储存到 attachment.content 索引字段中</p> 
<h2>三、如何应用？</h2> 
<h3>1、通过命令语句简易检索</h3> 
<p># 创建一个ES 索引 并且添加一些测试数据</p> 
<pre><code class="language-java">POST /pdf_data/_doc?pretty
{

  "id": "3",

  "name": "面试题文件1.pdf",

  "age": 18,

  "type": "file",

  "money": 1111,

  "createBy": "阿杰",

  "createTime": "2022-11-03T10:41:51.851Z",

  "attachment": {

    "content": "面试官：如何保证消息不被重复消费啊？如何保证消费的时候是幂等的啊？Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？",

    "date": "2022-11-02T10:41:51.851Z",

    "language": "en"

  }
}</code></pre> 
<p># 通过插入的文档内容为条件进行检索</p> 
<pre><code class="language-java"># 简单 单条件查询 文档内容检索
GET /pdf_data/_search
{
  "query": {
    "match": {
      "attachment.content": "面试官：如何保证消息不被重复消费啊？如何保证消费的时候是幂等的啊？"
    }
  }
}</code></pre> 
<h3>2、整合java代码实现ES通过ingest-attachment进行全文检索</h3> 
<h4><strong> 1、首先将文件转为BASE64进行ES数据插入</strong></h4> 
<pre><code class="language-java">/**
     * 将文件 文档信息储存到数据中
     * @param file
     * @return
     */
    @PostMapping("/insertFile")
    @ApiOperation(value="创建索引ES-传入ES索引-传入文件", notes="创建索引ES-传入ES索引-传入文件")
    public IndexResponse insertFile(@RequestAttribute("file") MultipartFile file,@RequestParam("indexName")String indexName){
        FileObj fileObj = new FileObj();
        fileObj.setId(String.valueOf(System.currentTimeMillis()));
        fileObj.setName(file.getOriginalFilename());
        fileObj.setType(file.getName().substring(file.getName().lastIndexOf(".") + 1));
        fileObj.setCreateBy(RandomNameGenerator.generateRandomName());
        fileObj.setCreateTime(String.valueOf(System.currentTimeMillis()));
        fileObj.setAge(RandomNameGenerator.getAge());
        fileObj.setMoney(RandomNameGenerator.getMoney());
        // 文件转base64
        byte[] bytes = new byte[0];
        try {
            bytes = file.getBytes();
            //将文件内容转化为base64编码
            String base64 = Base64.getEncoder().encodeToString(bytes);
            fileObj.setContent(base64);

           IndexResponse indexResponse=  ElasticsearchUtil.upload(fileObj,indexName);
            if (0==indexResponse.status().getStatus()){
                // 索引创建并插入数据成功
                System.out.println("索引创建并插入数据成功");
            }
            return indexResponse;

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }</code></pre> 
<h4> 2、创建索引、插入数据，并且将文档数据抽取到管道中</h4> 
<pre><code class="language-java">    @Autowired
    private RestHighLevelClient restHighLevelClient;

    private  static  RestHighLevelClient levelClient;

    @PostConstruct
    public void initClient() {
        levelClient = this.restHighLevelClient;
    }

/**
     * 创建索引并插入数据
     * @param file
     * @param indexName
     * @return
     * @throws IOException
     */
    public static IndexResponse upload(FileObj file,String indexName) throws IOException {
        // TODO 创建前需要判断当前文档是否已经存在
        if (!isIndexExist(indexName)) {
            CreateIndexRequest request = new CreateIndexRequest(indexName);
        // 如果需要ik分词器就添加配置，不需要就注释掉 
            // 添加 IK 分词器设置  ik_max_word
//            request.settings(Settings.builder()
//                    .put("index.analysis.analyzer.default.type", "ik_max_word")
//                    .put("index.analysis.analyzer.default.use_smart", "true")
//            );
            
            // 添加 IK 分词器设置 ik_smart 
            request.settings(Settings.builder()
                    .put("index.analysis.analyzer.default.type", "ik_smart")
            );
            CreateIndexResponse response = levelClient.indices().create(request, RequestOptions.DEFAULT);
            log.info("执行建立成功？" + response.isAcknowledged());
        }
        IndexRequest indexRequest = new IndexRequest(indexName);
        //上传同时，使用attachment pipline进行提取文件
        indexRequest.source(JSON.toJSONString(file), XContentType.JSON);
        indexRequest.setPipeline("attachment");
        IndexResponse indexResponse= levelClient.index(indexRequest,RequestOptions.DEFAULT);
        System.out.println(indexResponse);
        return indexResponse;
    }</code></pre> 
<h4 style="background-color:transparent;">  3、其他代码补充</h4> 
<p>   ES Config 配置类 </p> 
<pre><code class="language-java">/**
 * ES配置类
 * author: 阿杰
 */
@Configuration
public class ElasticSearchClientConfig {

    /**
     * ES 地址：127.0.0.1:9200
     */
    @Value("${es.ip}")
    private String hostName;

    @Bean
    public RestHighLevelClient restHighLevelClient() {
        String[] points = hostName.split(",");
        HttpHost[] httpHosts = new HttpHost[points.length];
        for (int i = 0; i &lt; points.length; i++) {
            String point = points[i];
            httpHosts[i] = new HttpHost(point.split(":")[0], Integer.parseInt(point.split(":")[1]), "http");
        }
        RestHighLevelClient client = new RestHighLevelClient(
                RestClient.builder(httpHosts));
        return client;
    }

    @Bean
    public ElasticsearchUtil elasticSearchUtil() {
        return new ElasticsearchUtil();
    }


}</code></pre> 
<p>数据插入使用的实体类</p> 
<pre><code class="language-java">/**
 * author: 阿杰
 */
@Data
public class FileObj {
    /**
     * 用于存储文件id
     */
    String id;
    /**
     * 文件名
     */
    String name;
    /**
     * 文件的type，pdf，word，or txt
     */
    String type;
    /**
     * 数据插入时间
     */
    String createTime;
    /**
     * 当前数据所属人员
     */
    String createBy;

    /**
     * 当前数据所属人员的年龄
     */
    int age;

    /**
     * 当前数据所属人员的资产
     */
    int money;

    /**
     * 文件转化成base64编码后所有的内容。
     */
    String content;
}</code></pre> 
<h2> 四、补充一点</h2> 
<p><code>QueryBuilders.matchPhraseQuery</code> 和 <code>QueryBuilders.matchQuery</code> 都是 Elasticsearch Java API 中用于构建查询的方法，它们在使用上有以下区别：</p> 
<ol><li> <p><strong>匹配方式不同</strong>：</p> 
  <ul><li><code>matchPhraseQuery</code> 是短语匹配查询，它会将输入的文本作为一个短语进行匹配。短语匹配要求查询的字段包含输入的短语且顺序一致。</li><li><code>matchQuery</code> 是多词项匹配查询，它会将输入的文本根据分词器进行分词，并对分词结果进行匹配。匹配结果是包含输入的任意词项的文档。</li></ul></li><li> <p><strong>查询方式不同</strong>：</p> 
  <ul><li><code>matchPhraseQuery</code> 使用短语查询方式，它会对输入的短语进行关键词匹配，精确匹配所有词项并保留顺序。</li><li><code>matchQuery</code> 使用与布尔查询相似的查询方式，它会将输入的文本进行分词，并生成与分词结果匹配的查询条件。</li></ul></li><li> <p><strong>分词不同</strong>：</p> 
  <ul><li><code>matchPhraseQuery</code> 不会对输入的短语进行分词，而是将输入的短语作为整个短语进行匹配。</li><li><code>matchQuery</code> 会对输入的文本进行分词，并将分词结果作为关键词进行匹配。</li></ul></li></ol> 
<p>下面是使用示例：</p> 
<pre><code>import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.index.query.QueryBuilder;

// 使用 matchPhraseQuery 进行短语匹配查询
QueryBuilder matchPhraseQueryBuilder = QueryBuilders.matchPhraseQuery("fieldName", "input phrase");

// 使用 matchQuery 进行多词项匹配查询
QueryBuilder matchQueryBuilder = QueryBuilders.matchQuery("fieldName", "input text");
</code></pre> 
<p></p> 
<p>根据实际需求，选择合适的查询方式来构建你的查询条件。如果需要精确匹配全部词项且保留顺序，使用 <code>matchPhraseQuery</code>；如果需要简单的多词项匹配，使用 <code>matchQuery</code>。</p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>完整代码可通过：</strong></span> <a class="link-info" href="https://download.csdn.net/download/lijie0213/88505859" title="完整代码包下载">完整代码包下载</a></p> 
<p></p> 
<p>制作不易，给个小赞！</p> 
<p>                  </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad25e0b3472b4060e4989f2622dd68a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RabbitMQ插件详解：rabbitmq_web_stomp【RabbitMQ 六】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fdaecca8ba7d12484a41615ca35ddcaa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超详细 | 哈里斯鹰优化算法原理、实现及其改进与利用(Matlab/Python)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>