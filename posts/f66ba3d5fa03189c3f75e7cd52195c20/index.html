<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大数据最新计算机视觉项目实战-驾驶员疲劳检测_计算机视觉疲劳检测，大数据开发面试题大全 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f66ba3d5fa03189c3f75e7cd52195c20/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="大数据最新计算机视觉项目实战-驾驶员疲劳检测_计算机视觉疲劳检测，大数据开发面试题大全">
  <meta property="og:description" content="既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
需要这份系统化资料的朋友，可以戳这里获取
(lStart, lEnd) = FACIAL_LANDMARKS_68_IDXS[“left_eye”]
(rStart, rEnd) = FACIAL_LANDMARKS_68_IDXS[“right_eye”]
然后我们通过关键点只取两个ROI区域，就是左眼区域和右眼区域。 print(“[INFO] starting video stream thread…”)
vs = cv2.VideoCapture(args[“video”])
随后我们将视频读进来。 while True:
# 预处理
frame = vs.read()[1]
if frame is None:
break
(h, w) = frame.shape[:2]
width=1200
r = width / float(w)
dim = (width, int(h * r))
frame = cv2.resize(frame, dim, interpolation=cv2.INTER_AREA)
gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
将视频的展示框放大一点，这里很关键就是如果视频的框框设置的太小的话，可能无法检测到人脸。然后我们就把宽设置成了1200，然后对长度也同比例就行resize操作。最后转换成灰度图。 rects = detector(gray, 0)
这里面检测到人脸，将人脸框的四个坐标拿到手。注意就是必须要是对灰度图进行处理。 for rect in rects: # 获取坐标 shape = predictor(gray, rect) shape = shape_to_np(shape) 在这里进行人脸框遍历，然后检测68关键点。 def shape_to_np(shape, dtype=“int”):">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-12T02:43:16+08:00">
    <meta property="article:modified_time" content="2024-05-12T02:43:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大数据最新计算机视觉项目实战-驾驶员疲劳检测_计算机视觉疲劳检测，大数据开发面试题大全</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/d7/05/wLZXDvLC_o.png" alt="img"><br> <img src="https://images2.imgbox.com/42/3e/vPuiLC1z_o.png" alt="img"><br> <img src="https://images2.imgbox.com/f3/ad/EW0W5BcZ_o.png" alt="img"></p> 
<p><strong>既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！</strong></p> 
<p><strong>由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新</strong></p> 
<p><strong><a href="https://bbs.csdn.net/forums/4f45ff00ff254613a03fab5e56a57acb">需要这份系统化资料的朋友，可以戳这里获取</a></strong></p> 
<p>(lStart, lEnd) = FACIAL_LANDMARKS_68_IDXS[“left_eye”]<br> (rStart, rEnd) = FACIAL_LANDMARKS_68_IDXS[“right_eye”]</p> 
<pre><code>
然后我们通过关键点只取两个ROI区域，就是左眼区域和右眼区域。



</code></pre> 
<p>print(“[INFO] starting video stream thread…”)<br> vs = cv2.VideoCapture(args[“video”])</p> 
<pre><code>
随后我们将视频读进来。



</code></pre> 
<p>while True:<br> # 预处理<br> frame = vs.read()[1]<br> if frame is None:<br> break<br> (h, w) = frame.shape[:2]<br> width=1200<br> r = width / float(w)<br> dim = (width, int(h * r))<br> frame = cv2.resize(frame, dim, interpolation=cv2.INTER_AREA)<br> gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</p> 
<pre><code>
将视频的展示框放大一点，这里很关键就是如果视频的框框设置的太小的话，可能无法检测到人脸。然后我们就把宽设置成了1200，然后对长度也同比例就行resize操作。最后转换成灰度图。



</code></pre> 
<p>rects = detector(gray, 0)</p> 
<pre><code>
这里面检测到人脸，将人脸框的四个坐标拿到手。注意就是必须要是对灰度图进行处理。



</code></pre> 
<pre><code>for rect in rects:
	# 获取坐标
	shape = predictor(gray, rect)
	shape = shape_to_np(shape)
</code></pre> 
<pre><code>
在这里进行人脸框遍历，然后检测68关键点。



</code></pre> 
<p>def shape_to_np(shape, dtype=“int”):<br> # 创建68*2<br> coords = np.zeros((shape.num_parts, 2), dtype=dtype)<br> # 遍历每一个关键点<br> # 得到坐标<br> for i in range(0, shape.num_parts):<br> coords[i] = (shape.part(i).x, shape.part(i).y)<br> return coords</p> 
<pre><code>
这里就是提取关键点的坐标。



</code></pre> 
<pre><code>	leftEye = shape[lStart:lEnd]
	rightEye = shape[rStart:rEnd]
	leftEAR = eye_aspect_ratio(leftEye)
	rightEAR = eye_aspect_ratio(rightEye)
</code></pre> 
<pre><code>
然后我们把左眼和右眼分别求了一下EAR数值。这里的`eye_aspect_ratio`函数就是计算EAR数值的。



</code></pre> 
<p>def eye_aspect_ratio(eye):<br> # 计算距离，竖直的<br> A = dist.euclidean(eye[1], eye[5])<br> B = dist.euclidean(eye[2], eye[4])<br> # 计算距离，水平的<br> C = dist.euclidean(eye[0], eye[3])<br> # ear值<br> ear = (A + B) / (2.0 * C)<br> return ear</p> 
<pre><code>
其中`dist.euclidean`表示计算欧式距离，和公式中计算EAR数值一摸一样。



</code></pre> 
<pre><code>	ear = (leftEAR + rightEAR) / 2.0

	# 绘制眼睛区域
	leftEyeHull = cv2.convexHull(leftEye)
	rightEyeHull = cv2.convexHull(rightEye)
	cv2.drawContours(frame, [leftEyeHull], -1, (0, 255, 0), 1)
	cv2.drawContours(frame, [rightEyeHull], -1, (0, 255, 0), 1)
</code></pre> 
<pre><code>
然后对于左眼和右眼都进行了EAR求解然后求了一个平均值，然后根据凸包的概念，对眼睛区域进行了绘图。将左眼区域和右眼区域绘图出来。



</code></pre> 
<pre><code>	if ear &lt; EYE_AR_THRESH:
		COUNTER += 1

	else:
		# 如果连续几帧都是闭眼的，总数算一次
		if COUNTER &gt;= EYE_AR_CONSEC_FRAMES:
			TOTAL += 1

		# 重置
		COUNTER = 0

	# 显示
	cv2.putText(frame, "Blinks: {}".format(TOTAL), (10, 30),
		cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
	cv2.putText(frame, "EAR: {:.2f}".format(ear), (300, 30),
		cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

cv2.imshow("Frame", frame)
key = cv2.waitKey(10) &amp; 0xFF

if key == 27:
	break
</code></pre> 
<p>vs.release()<br> cv2.destroyAllWindows()</p> 
<pre><code>
最后进行了一次阈值判断，如果EAR连续三帧都小于0.3，那么我们就把TOTAL加一，这样记录一次闭眼的过程。然后最后将EAR数值和TOTAL的数值展示在视频当中。最后完成整体的训练。


### 🌟项目结果展示


![在这里插入图片描述](https://img-blog.csdnimg.cn/10447afa2e3d4b4ea21e27d74c74d5a9.png)  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/a64e5e5c8ab04d7fb07e6d90154f2fdf.png)


### 🌟项目改进方向（打哈欠检测疲劳方法）


我们知道在疲劳检测当中，光光检测眨眼可能不是特别准确，因此我们还要在其他可以展示驾驶员疲劳的点来结合展示驾驶员是否处于疲劳驾驶阶段。我们了解到还可以通过嘴巴打哈欠，和点头来展示驾驶员是否疲劳。我们首先来考虑嘴巴打哈欠。  
 首先我们来看一下嘴巴的关键点。  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/ae32477caa3a4c6eaff75a5fc5c56816.png)  
 我们使用对眨眼检测的方法继续对嘴巴使用同样的方法检测是否张嘴！对应公式是：  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/393f53a6a75c4f1aa53ff6097d86ccb9.png)



</code></pre> 
<p>def mouth_aspect_ratio(mouth):<br> A = np.linalg.norm(mouth[2] - mouth[9]) # 51, 59<br> B = np.linalg.norm(mouth[4] - mouth[7]) # 53, 57<br> C = np.linalg.norm(mouth[0] - mouth[6]) # 49, 55<br> mar = (A + B) / (2.0 * C)<br> return mar</p> 
<pre><code>
这里面我们选择的是嘴部区域内的六个点，来判断驾驶员是否进行了张嘴！



</code></pre> 
<p>MAR_THRESH = 0.5<br> MOUTH_AR_CONSEC_FRAMES = 3</p> 
<pre><code>
同样我们也要设置一个阈值，解释同对眨眼检测的时候一样。



</code></pre> 
<p>(mStart, mEnd) = FACIAL_LANDMARKS_68_IDXS[“mouth”]</p> 
<pre><code>
首先我们取到68关键点中对应的嘴部区域。



</code></pre> 
<p>mouth = shape[mStart:mEnd]<br> mar = mouth_aspect_ratio(mouth)</p> 
<pre><code>
然后通过函数`mouth_aspect_ratio`来计算出来mar数值！然后进行凸包检测，并且要画出来。



</code></pre> 
<pre><code>	mouthHull = cv2.convexHull(mouth)
	cv2.drawContours(frame, [mouthHull], -1, (0, 255, 0), 1)
</code></pre> 
<pre><code>

</code></pre> 
<pre><code>	left = rect.left()#绘制出来人脸框
	top = rect.top()
	right = rect.right()
	bottom = rect.bottom()
	cv2.rectangle(frame, (left, top), (right, bottom), (0, 255, 0), 3)
</code></pre> 
<pre><code>
这里面我们要加上一点就是说我们要绘制出来人脸框框！



</code></pre> 
<pre><code>	if mar &gt; MAR_THRESH:  # 张嘴阈值0.5
		mCOUNTER += 1
		cv2.putText(frame, "Yawning!", (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
	else:
		# 如果连续3次都小于阈值，则表示打了一次哈欠
		if mCOUNTER &gt;= MOUTH_AR_CONSEC_FRAMES:  # 阈值：3
			mTOTAL += 1
		# 重置嘴帧计数器
		mCOUNTER = 0
	cv2.putText(frame, "Yawning: {}".format(mTOTAL), (150, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
	cv2.putText(frame, "mCOUNTER: {}".format(mCOUNTER), (300, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
	cv2.putText(frame, "MAR: {:.2f}".format(mar), (480, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
</code></pre> 
<pre><code>
然后进行判断，并且在视频当中展示出来！


### 🌟项目改进方向（点头检测疲劳）


检测流程：  
 **2D人脸关键点检测；3D人脸模型匹配；求解3D点和对应2D点的转换关系；根据旋转矩阵求解欧拉角。**  
 一个物体相对于相机的姿态可以使用旋转矩阵和平移矩阵来表示。  
 !](https://bbs.csdn.net/forums/4f45ff00ff254613a03fab5e56a57acb)


1. 欧拉角  
 简单来说，欧拉角就是物体绕坐标系三个坐标轴(x,y,z轴）的旋转角度。
2. 世界坐标系和其他坐标系的转换  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c143c5b1c2f47fa9070c0a2cef4b832.png)世界坐标系到相机坐标系转换：  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/df8b66028ea74964b0466abc7c8bc8b8.png)  
 相机坐标系到像素坐标系转换：  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/dcdc7dd651b74c4c952b82e431b1772b.png)  
 因此像素坐标系和世界坐标系的关系如下：  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/04481c9af12844d3acb36b4b40d14ced.png)  
 然后我们根据论文来定义一下：



</code></pre> 
<p>object_pts = np.float32([[6.825897, 6.760612, 4.402142], #33左眉左上角<br> [1.330353, 7.122144, 6.903745], #29左眉右角<br> [-1.330353, 7.122144, 6.903745], #34右眉左角<br> [-6.825897, 6.760612, 4.402142], #38右眉右上角<br> [5.311432, 5.485328, 3.987654], #13左眼左上角<br> [1.789930, 5.393625, 4.413414], #17左眼右上角<br> [-1.789930, 5.393625, 4.413414], #25右眼左上角<br> [-5.311432, 5.485328, 3.987654], #21右眼右上角<br> [2.005628, 1.409845, 6.165652], #55鼻子左上角<br> [-2.005628, 1.409845, 6.165652], #49鼻子右上角<br> [2.774015, -2.080775, 5.048531], #43嘴左上角<br> [-2.774015, -2.080775, 5.048531],#39嘴右上角<br> [0.000000, -3.116408, 6.097667], #45嘴中央下角<br> [0.000000, -7.415691, 4.070434]])#6下巴角</p> 
<p>K = [6.5308391993466671e+002, 0.0, 3.1950000000000000e+002,<br> 0.0, 6.5308391993466671e+002, 2.3950000000000000e+002,<br> 0.0, 0.0, 1.0]# 等价于矩阵[fx, 0, cx; 0, fy, cy; 0, 0, 1]</p> 
<h2><a id="uvk1_k2_p1_p2_k3_304"></a>图像中心坐标系(uv)：相机畸变参数[k1, k2, p1, p2, k3]</h2> 
<p>D = [7.0834633684407095e-002, 6.9140193737175351e-002, 0.0, 0.0, -1.3073460323689292e+000]<br> reprojectsrc = np.float32([[10.0, 10.0, 10.0],<br> [10.0, 10.0, -10.0],<br> [10.0, -10.0, -10.0],<br> [10.0, -10.0, 10.0],<br> [-10.0, 10.0, 10.0],<br> [-10.0, 10.0, -10.0],<br> [-10.0, -10.0, -10.0],<br> [-10.0, -10.0, 10.0]])</p> 
<h2><a id="12_314"></a>绘制正方体12轴</h2> 
<p>line_pairs = [[0, 1], [1, 2], [2, 3], [3, 0],<br> [4, 5], [5, 6], [6, 7], [7, 4],<br> [0, 4], [1, 5], [2, 6], [3, 7]]</p> 
<pre><code>
其中`reprojectsrc`和`line_pairs`这两个属于矩形和矩形连接框框的操作。后续会用得到。



</code></pre> 
<p>cam_matrix = np.array(K).reshape(3, 3).astype(np.float32)<br> dist_coeffs = np.array(D).reshape(5, 1).astype(np.float32)</p> 
<pre><code>
这里我们对K和D矩阵进行了reshape了一下！



</code></pre> 
<p>def get_head_pose(shape): # 头部姿态估计<br> # （像素坐标集合）填写2D参考点，注释遵循https://ibug.doc.ic.ac.uk/resources/300-W/<br> # 17左眉左上角/21左眉右角/22右眉左上角/26右眉右上角/36左眼左上角/39左眼右上角/42右眼左上角/<br> # 45右眼右上角/31鼻子左上角/35鼻子右上角/48左上角/54嘴右上角/57嘴中央下角/8下巴角<br> image_pts = np.float32([shape[17], shape[21], shape[22], shape[26], shape[36],<br> shape[39], shape[42], shape[45], shape[31], shape[35],<br> shape[48], shape[54], shape[57], shape[8]])<br> # solvePnP计算姿势——求解旋转和平移矩阵：<br> # rotation_vec表示旋转矩阵，translation_vec表示平移矩阵，cam_matrix与K矩阵对应，dist_coeffs与D矩阵对应。<br> _, rotation_vec, translation_vec = cv2.solvePnP(object_pts, image_pts, cam_matrix, dist_coeffs)<br> # projectPoints重新投影误差：原2d点和重投影2d点的距离（输入3d点、相机内参、相机畸变、r、t，输出重投影2d点）<br> reprojectdst, _ = cv2.projectPoints(reprojectsrc, rotation_vec, translation_vec, cam_matrix, dist_coeffs)<br> reprojectdst = tuple(map(tuple, reprojectdst.reshape(8, 2))) # 以8行2列显示</p> 
<pre><code># 计算欧拉角calc euler angle
# 参考https://docs.opencv.org/2.4/modules/calib3d/doc/camera\_calibration\_and\_3d\_reconstruction.html#decomposeprojectionmatrix
rotation_mat, _ = cv2.Rodrigues(rotation_vec)  # 罗德里格斯公式（将旋转矩阵转换为旋转向量）
pose_mat = cv2.hconcat((rotation_mat, translation_vec))  # 水平拼接，vconcat垂直拼接
# decomposeProjectionMatrix将投影矩阵分解为旋转矩阵和相机矩阵
_, _, _, _, _, _, euler_angle = cv2.decomposeProjectionMatrix(pose_mat)

pitch, yaw, roll = [math.radians(_) for _ in euler_angle]
</code></pre> 
<p><img src="https://images2.imgbox.com/20/47/X00i6gzR_o.png" alt="img"><br> <img src="https://images2.imgbox.com/34/61/0235fPyq_o.png" alt="img"><br> <img src="https://images2.imgbox.com/42/94/IWzDam7F_o.png" alt="img"></p> 
<p><strong>既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！</strong></p> 
<p><strong>由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新</strong></p> 
<p><strong><a href="https://bbs.csdn.net/forums/4f45ff00ff254613a03fab5e56a57acb">需要这份系统化资料的朋友，可以戳这里获取</a></strong></p> 
<p>e]</p> 
<p>[外链图片转存中…(img-wTOgMn5D-1715452964284)]<br> [外链图片转存中…(img-3Cr3tL1z-1715452964284)]<br> [外链图片转存中…(img-uYj0Eb11-1715452964284)]</p> 
<p><strong>既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！</strong></p> 
<p><strong>由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新</strong></p> 
<p><strong><a href="https://bbs.csdn.net/forums/4f45ff00ff254613a03fab5e56a57acb">需要这份系统化资料的朋友，可以戳这里获取</a></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3df78b67619609be098356be24ea4bcf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据最新【数据结构】八大排序算法详解_数据结构排序算法(2)，2024年最新教你如何增加拿到BAT大厂offer几率</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff904b8091ad54e89162d41b22ef87c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据进阶（一）：4个最受欢迎的大数据可视化工具（抛砖引玉篇）_silver bullet 图表工具(1)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>