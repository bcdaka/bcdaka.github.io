<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL】详解数据库约束、聚合查询和联合查询 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/76e745a8e4119bfd6fef05efff86feaf/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL】详解数据库约束、聚合查询和联合查询">
  <meta property="og:description" content="数据库约束 约束类型 数据库的约束类型主要包括以下几种：
主键约束（Primary Key Constraint）：确保表中的每一行都有唯一的标识，且不能为NULL。
外键约束（Foreign Key Constraint）：确保表中的数据与另一个表中的数据保持一致性，维护数据之间的关系。
唯一约束（Unique Constraint）：确保字段中的所有值都是唯一的，不允许重复。
检查约束（Check Constraint）：限制某一列中的值符合特定条件，如数值范围、字符串格式等。
非空约束（NOT NULL Constraint）：确保某一列不能包含NULL值，必须有实际数据。
默认约束（Default Constraint）：为字段设置默认值，在插入记录时若未提供该字段的值，则会使用默认值。
这些约束保证了数据库中的数据完整性和一致性，是设计数据库时的重要组成部分。
使用案例 主键约束（Primary Key Constraint）
主键约束用于唯一标识表中的每一行，并确保其值不为NULL。
CREATE TABLE Students ( StudentID INT PRIMARY KEY, StudentName VARCHAR(20) ); 对于整数类型的主键，常配搭自增长auto_increment来使用。插入数据对应字段不给值时，使用最大值&#43;1。
StudentID INT PRIMARY KEY auto_increment,
外键约束（Foreign Key Constraint）
外键约束用于维护不同表之间的关系，确保引用的数据存在。
CREATE TABLE Courses ( CourseID INT PRIMARY KEY, CourseName VARCHAR(100) ); CREATE TABLE Enrollments ( EnrollmentID INT PRIMARY KEY, StudentID INT, CourseID INT, FOREIGN KEY (StudentID) REFERENCES Students(StudentID), FOREIGN KEY (CourseID) REFERENCES Courses(CourseID) ); 唯一约束（Unique Constraint）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T22:27:10+08:00">
    <meta property="article:modified_time" content="2024-08-11T22:27:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL】详解数据库约束、聚合查询和联合查询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>数据库约束</h2> 
<h3>约束类型</h3> 
<p>数据库的约束类型主要包括以下几种：</p> 
<ol><li> <p><strong>主键约束（Primary Key Constraint）</strong>：确保表中的每一行都有唯一的标识，且不能为NULL。</p> </li><li> <p><strong>外键约束（Foreign Key Constraint）</strong>：确保表中的数据与另一个表中的数据保持一致性，维护数据之间的关系。</p> </li><li> <p><strong>唯一约束（Unique Constraint）</strong>：确保字段中的所有值都是唯一的，不允许重复。</p> </li><li> <p><strong>检查约束（Check Constraint）</strong>：限制某一列中的值符合特定条件，如数值范围、字符串格式等。</p> </li><li> <p><strong>非空约束（NOT NULL Constraint）</strong>：确保某一列不能包含NULL值，必须有实际数据。</p> </li><li> <p><strong>默认约束（Default Constraint）</strong>：为字段设置默认值，在插入记录时若未提供该字段的值，则会使用默认值。</p> </li></ol> 
<p>这些约束保证了数据库中的数据完整性和一致性，是设计数据库时的重要组成部分。</p> 
<p></p> 
<h3>使用案例</h3> 
<p><strong>主键约束（Primary Key Constraint）</strong><br> 主键约束用于唯一标识表中的每一行，并确保其值不为NULL。</p> 
<pre><code class="language-sql">CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    StudentName VARCHAR(20)
);
</code></pre> 
<p>对于整数类型的主键，常配搭自增长auto_increment来使用。插入数据对应字段不给值时，使用最大值+1。</p> 
<blockquote> 
 <p>StudentID INT PRIMARY KEY auto_increment,</p> 
</blockquote> 
<p><strong>外键约束（Foreign Key Constraint）</strong><br> 外键约束用于维护不同表之间的关系，确保引用的数据存在。</p> 
<pre><code class="language-sql">CREATE TABLE Courses (
    CourseID INT PRIMARY KEY,
    CourseName VARCHAR(100)
);

CREATE TABLE Enrollments (
    EnrollmentID INT PRIMARY KEY,
    StudentID INT,
    CourseID INT,
    FOREIGN KEY (StudentID) REFERENCES Students(StudentID),
    FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
);
</code></pre> 
<p> <strong>唯一约束（Unique Constraint）</strong><br> 唯一约束确保字段值的唯一性，不能重复，但允许NULL值。</p> 
<pre><code class="language-sql">CREATE TABLE Users (
    UserID INT PRIMARY KEY,
    Email VARCHAR(100) UNIQUE
);
</code></pre> 
<p><strong>检查约束（Check Constraint）</strong><br> 检查约束用于确保字段值满足特定条件。</p> 
<pre><code class="language-sql">CREATE TABLE Products (
    ProductID INT PRIMARY KEY,
    Price DECIMAL(10, 2) CHECK (Price &gt;= 0)
);
</code></pre> 
<p><strong>非空约束（NOT NULL Constraint）</strong><br> 非空约束确保某一列的值不能为空。</p> 
<pre><code class="language-sql">CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    EmployeeName VARCHAR(100) NOT NULL
);
</code></pre> 
<p><strong>默认约束（Default Constraint）</strong><br> 默认值约束在插入新记录时指定列的默认值。</p> 
<pre><code class="language-sql">CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    OrderDate DATETIME DEFAULT CURRENT_TIMESTAMP
);
</code></pre> 
<p>这些约束在创建和管理数据库表时非常重要，有助于维护数据的完整性和准确性。</p> 
<p></p> 
<h2>聚合查询</h2> 
<h3>聚合函数</h3> 
<p>常见的统计总数、计算平局值等操作，可以使用聚合函数来实现，常见的聚合函数有：</p> 
<ol><li>COUNT()：计算行数或非NULL值的数量。</li><li>SUM()：计算数值型列的总和。</li><li>AVG()：计算数值型列的平均值。</li><li>MAX()：返回指定列中的最大值。</li><li>MIN()：返回指定列中的最小值。</li><li>GROUP_CONCAT()（某些数据库）：将多行的值连接成一个字符串。</li><li>VARIANCE()：计算数值型列的方差。</li><li>STDDEV()：计算数值型列的标准差。</li></ol> 
<p>这些聚合函数用于对一组数据进行汇总和分析，是数据库查询的重要工具。</p> 
<p></p> 
<h3>使用案例</h3> 
<p><strong>COUNT()</strong><br><code>COUNT()</code> 函数用于计算表中的行数或特定列中非NULL值的数量。</p> 
<ul><li>用法： 
  <ul><li>计算总行数：<code>SELECT COUNT(*) FROM 表名;</code></li><li>计算某列非NULL值的数量：<code>SELECT COUNT(列名) FROM 表名;</code></li></ul></li></ul> 
<p>示例：</p> 
<pre><code class="language-sql">SELECT COUNT(*) FROM Employees;  -- 计算员工总数
SELECT COUNT(EmployeeID) FROM Employees;  -- 计算非NULL的员工ID数量
</code></pre> 
<p><strong>SUM()</strong><br><code>SUM()</code> 函数用于计算数值型列的总和。</p> 
<ul><li>用法：<code>SELECT SUM(列名) FROM 表名;</code></li></ul> 
<p>示例：</p> 
<pre><code class="language-sql">SELECT SUM(Salary) FROM Employees;  -- 计算所有员工的工资总和
</code></pre> 
<p><strong>AVG()</strong><br><code>AVG()</code> 函数用于计算数值型列的平均值。</p> 
<ul><li>用法：<code>SELECT AVG(列名) FROM 表名;</code></li></ul> 
<p>示例：</p> 
<pre><code class="language-sql">SELECT AVG(Salary) FROM Employees;  -- 计算所有员工的平均工资
</code></pre> 
<p><strong>MAX()</strong><br><code>MAX()</code> 函数用于返回指定列中的最大值。</p> 
<ul><li>用法：<code>SELECT MAX(列名) FROM 表名;</code></li></ul> 
<p>示例：</p> 
<pre><code class="language-sql">SELECT MAX(Salary) FROM Employees;  -- 找到最高的工资
</code></pre> 
<p><strong>MIN()</strong><br><code>MIN()</code> 函数用于返回指定列中的最小值。</p> 
<ul><li>用法：<code>SELECT MIN(列名) FROM 表名;</code></li></ul> 
<p>示例：</p> 
<pre><code class="language-sql">SELECT MIN(Salary) FROM Employees;  -- 找到最低的工资
</code></pre> 
<p>这些聚合函数可以单独使用，也可以与 <code>GROUP BY</code> 子句结合使用，以对结果进行分组和汇总分析。</p> 
<h3>GROUP BY子句</h3> 
<p>SELECT 中使用 GROUP BY 子句可以对指定列进行分组查询。需要满足：使用 GROUP BY 进行分组查询时，SELECT 指定的字段必须是“分组依据字段”，其他字段若想出现在SELECT 中则必须包含在聚合函数中。</p> 
<blockquote> 
 <p>select column1, sum(column2), .. from table group by column1,column3;</p> 
</blockquote> 
<h3>HAVING </h3> 
<p>GROUP BY 子句进行分组以后，需要对分组结果再进行条件过滤时，不能使用 WHERE 语句，而需要用HAVING。</p> 
<p><strong>使用案例</strong></p> 
<p>下面是一个结合聚合函数、<code>GROUP BY</code> 和 <code>HAVING</code> 的使用案例。</p> 
<p>假设我们有一个名为 <code>Sales</code> 的表，其中包含以下字段：</p> 
<ul><li><code>SalesID</code>：销售记录的唯一标识</li><li><code>SalesAmount</code>：销售金额</li><li><code>SalesPerson</code>：销售人员的名称</li><li><code>SalesDate</code>：销售日期</li></ul> 
<p>我们想要查询每个销售人员的总销售金额和平均销售金额，并且只返回那些总销售金额超过 10,000 的销售人员。</p> 
<p>以下是相应的 SQL 查询示例：</p> 
<pre><code class="language-sql">SELECT 
    SalesPerson,
    SUM(SalesAmount) AS TotalSales,
    AVG(SalesAmount) AS AverageSales
FROM 
    Sales
GROUP BY 
    SalesPerson
HAVING 
    SUM(SalesAmount) &gt; 10000;
</code></pre> 
<p>在这个查询中：</p> 
<ul><li><code>GROUP BY SalesPerson</code> 将结果按销售人员进行分组。</li><li><code>SUM(SalesAmount)</code> 计算每个销售人员的总销售金额。</li><li><code>AVG(SalesAmount)</code> 计算每个销售人员的平均销售金额。</li><li><code>HAVING SUM(SalesAmount) &gt; 10000</code> 筛选出总销售金额超过 10,000 的销售人员。</li></ul> 
<p>这个案例展示了如何结合聚合函数和 <code>GROUP BY</code> 与 <code>HAVING</code> 条件来分析数据。</p> 
<p></p> 
<h2 style="background-color:transparent;">联合查询</h2> 
<p>实际开发中往往数据来自不同的表，所以需要多表联合查询。多表查询是对多张表的数据取笛卡尔积：</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/21/31/DXX7x9vv_o.png" width="425"></p> 
<p><strong>注意：</strong>关联查询可以对关联表使用别名。</p> 
<h3 style="background-color:transparent;">内连接</h3> 
<blockquote> 
 <p>select 字段 from 表1 别名1 [inner] join 表2 别名2 on 连接条件 and 其他条件;<br> select 字段 from 表1 别名1,表2 别名2 where 连接条件 and 其他条件;</p> 
</blockquote> 
<h3 style="background-color:transparent;">外连接 </h3> 
<p>外连接分为左外连接和右外连接。如果联合查询，左侧的表完全显示我们就说是左外连接；右侧的表完全显示我们就说是右外连接。</p> 
<blockquote> 
 <p>-- 左外连接，表1完全显示<br> select 字段名  from 表名1 left join 表名2 on 连接条件;<br> -- 右外连接，表2完全显示<br> select 字段 from 表名1 right join 表名2 on 连接条件;</p> 
</blockquote> 
<h3 style="background-color:transparent;">自连接 </h3> 
<p>自连接是指在同一张表连接自身进行查询。</p> 
<blockquote> 
 <p>select 字段名 from 表1 as 别名 ，表1 as 别名 where 连接条件 and 其他条件；</p> 
</blockquote> 
<h3 style="background-color:transparent;">联合查询使用案例</h3> 
<p>下面是一个关于数据库中联合查询（也称为联接查询）的案例，结合多个表进行数据检索。</p> 
<p>假设我们有两个表：</p> 
<ol><li> <p><strong>Customers</strong> 表</p> 
  <ul><li><code>CustomerID</code>：客户唯一标识</li><li><code>CustomerName</code>：客户姓名</li><li><code>ContactNumber</code>：联系方式</li></ul></li><li> <p><strong>Orders</strong> 表</p> 
  <ul><li><code>OrderID</code>：订单唯一标识</li><li><code>OrderDate</code>：订单日期</li><li><code>CustomerID</code>：关联的客户ID（外键）</li><li><code>TotalAmount</code>：订单总金额</li></ul></li></ol> 
<p>我们希望查询每个客户的订单信息，包括客户姓名和订单总金额。</p> 
<p>以下是结合 <code>INNER JOIN</code> 的 SQL 查询示例：</p> 
<pre><code class="language-sql">SELECT 
    Customers.CustomerName,
    Orders.TotalAmount
FROM 
    Customers
INNER JOIN 
    Orders ON Customers.CustomerID = Orders.CustomerID;
</code></pre> 
<p>在这个查询中：</p> 
<ul><li><code>INNER JOIN</code> 用于将 <code>Customers</code> 表和 <code>Orders</code> 表连接起来。</li><li>连接条件是 <code>ON Customers.CustomerID = Orders.CustomerID</code>，即通过客户ID来匹配订单和客户信息。</li><li>选择了 <code>Customers.CustomerName</code> 和 <code>Orders.TotalAmount</code> 来显示客户姓名和相应的订单总金额。</li></ul> 
<p>这个案例展示了如何在数据库中使用联合查询来获取来自多个表的相关数据。</p> 
<p></p> 
<h2 style="background-color:transparent;">子查询</h2> 
<p>子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询</p> 
<p>1、单行子查询：返回一行记录的子查询</p> 
<p>2、多行子查询：返回多行记录的子查询</p> 
<ul><li>[NOT] IN关键字</li><li>[NOT] EXISTS关键字</li></ul> 
<h3 style="background-color:transparent;">子查询案例</h3> 
<p>下面是一个关于数据库中子查询的案例，展示如何使用子查询来获取相关数据。</p> 
<p>假设我们有两个表：</p> 
<ol><li> <p><strong>Employees</strong> 表</p> 
  <ul><li><code>EmployeeID</code>：员工唯一标识</li><li><code>EmployeeName</code>：员工姓名</li><li><code>DepartmentID</code>：员工所在部门的ID</li><li><code>Salary</code>：员工工资</li></ul></li><li> <p><strong>Departments</strong> 表</p> 
  <ul><li><code>DepartmentID</code>：部门唯一标识</li><li><code>DepartmentName</code>：部门名称</li></ul></li></ol> 
<p>现在，我们想要查询那些工资高于该部门平均工资的员工姓名和工资。我们可以通过子查询来实现这个目标。</p> 
<p>以下是相应的 SQL 查询示例：</p> 
<pre><code class="language-sql">SELECT 
    EmployeeName, 
    Salary 
FROM 
    Employees
WHERE 
    Salary &gt; (
        SELECT 
            AVG(Salary) 
        FROM 
            Employees 
        WHERE 
            DepartmentID = Employees.DepartmentID
    );
</code></pre> 
<p>在这个查询中：</p> 
<ul><li>外层查询从 <code>Employees</code> 表中选择 <code>EmployeeName</code> 和 <code>Salary</code>。</li><li>子查询 <code>(SELECT AVG(Salary) FROM Employees WHERE DepartmentID = Employees.DepartmentID)</code> 计算每个部门的平均工资。</li><li>外层查询的 <code>WHERE</code> 子句中，条件 <code>Salary &gt; (子查询)</code> 用于过滤出工资高于该部门平均工资的员工。</li></ul> 
<p>这个案例展示了如何在数据库中使用子查询来进一步筛选和获取数据。</p> 
<p></p> 
<h2>合并查询</h2> 
<p>在实际应用中，为了合并多个select的执行结果，可以使用集合操作符 union，union all。使用UNION和UNION ALL时，前后查询的结果集中，字段需要一致。</p> 
<ul><li>union</li></ul> 
<p>该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中的重复行。</p> 
<ul><li>union all</li></ul> 
<p>该操作符用于取得两个结果集的并集。当使用该操作符时，不会去掉结果集中的重复行。</p> 
<p></p> 
<h3>合并查询案例</h3> 
<p>合并查询通常是指使用 <code>UNION</code> 运算符将多个 SELECT 查询的结果合并在一起。下面是一个关于数据库中合并查询的案例。</p> 
<p>假设我们有两个表：</p> 
<ol><li> <p><strong>Customers</strong> 表</p> 
  <ul><li><code>CustomerID</code>：客户唯一标识</li><li><code>CustomerName</code>：客户姓名</li><li><code>ContactNumber</code>：联系方式</li></ul></li><li> <p><strong>Suppliers</strong> 表</p> 
  <ul><li><code>SupplierID</code>：供应商唯一标识</li><li><code>SupplierName</code>：供应商姓名</li><li><code>ContactNumber</code>：联系方式</li></ul></li></ol> 
<p>我们希望从这两个表中获取所有联系人姓名，无论是客户还是供应商。可以使用 <code>UNION</code> 查询来合并两个表中的联系人的姓名。</p> 
<p>以下是相应的 SQL 查询示例：</p> 
<pre><code class="language-sql">SELECT 
    CustomerName AS ContactName 
FROM 
    Customers
UNION
SELECT 
    SupplierName AS ContactName 
FROM 
    Suppliers;
</code></pre> 
<p>在这个查询中：</p> 
<ul><li>第一个 <code>SELECT</code> 查询从 <code>Customers</code> 表中选取 <code>CustomerName</code>，并将其重命名为 <code>ContactName</code>。</li><li>第二个 <code>SELECT</code> 查询从 <code>Suppliers</code> 表中选取 <code>SupplierName</code>，同样将其重命名为 <code>ContactName</code>。</li><li><code>UNION</code> 将两个查询的结果合并在一起，自动去除重复的值。</li></ul> 
<p>请注意，使用 <code>UNION</code> 时，两个查询的列数和数据类型必须相匹配。</p> 
<p>这个案例展示了如何在数据库中使用合并查询来获取来自多个表的相关数据。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/14f9c57ae8995fb3f36233003ed4a884/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JQuery实现地图坐标拾取和地址模糊查询</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cc7ea1b2675e49c999da993c00516c78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面试官：MongoDB是什么，它有什么特性与使用场景？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>