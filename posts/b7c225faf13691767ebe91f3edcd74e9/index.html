<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端工程化09-webpack静态的模块化打包工具(未完结) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b7c225faf13691767ebe91f3edcd74e9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端工程化09-webpack静态的模块化打包工具(未完结)">
  <meta property="og:description" content="9.1、开发模式的进化历史 webpacks是一个非常非常的强大的一个工具，相应的这个东西的学习也是有一定的难度的，里边的东西非常的多，里面涉及到的
概念的话也是非常非常的多的。
这个东西既然非常重要，那么在我们前端到底处于怎样的一个地位呢？
有些人学习到这个阶段已经分不清楚了，到底什么是node,什么是npm/什么是webpack,所以我们有必要了解下前端开发的架构图
目前我们前端比较流行的三大框架，Vue/React/Angular/,国内用Angular的非常少，如果公司需要你会，那么可以研究下，如果不
是就没有必要把太多的精力放到、Angular上，本身这个东西的需求比较少，岗位也比较少，那么这个时候你花费更多时间学习
Angular是没有什么太大的回报的，但是不可否认Angular是一个非常优秀的框架，他里边的架构设计也是非常优秀的~后续聊，目
前我们国内用的最多的还是Vue和React
我们目前的开发模式已经不是以前的那种模式，我先创建一个index.html，然后写标签写内容，下几个js文件，引入到项目里，在
写对应的js,写css什么的
现在的模式，假如你现在要开发一个旅游项目，先考虑用什么包管理工具，用npm还是用yarn,之后在确定给你的项目用到的打包
工具webpack,然后在当前的架构下边确定用什么前端框架开发，比如Vue,React,Angular,在写具体的代码，有人说了，那我不会
搭建这个架构怎么办，这个不需要担心，因为现在，你不管去开发Vue项目还是开发React这个项目，他们都有对应的脚手架来帮
助你进行快速开发，所谓的脚手架，不管是Vue的还是React的他们呢都是基于Webpack的。
9.2、Webpack使用Node内置的Path模块 path模块是node的内置模块，通常用于对路径和文件进行处理，提供了很多好用的方法
我们知道在Mac OS、Linux和window上的路径时不一样的
window上会使用 \或者 \ 来作为文件路径的分隔符，当然目前也支持 /；在Mac OS、Linux的Unix操作系统上使用 / 来作为文件路径的分隔符； 那么如果我们在window上使用 \ 来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办呢？
显示路径会出现一些问题；所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块； 可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）
Linux和Mac OS都实现了POSIX接口；Window部分电脑实现了POSIX接口； 9.3、path模块常见的API 从路径中获取信息
dirname：获取文件的父文件夹；basename：获取文件名；extname：获取文件扩展名； 路径的拼接：path.join
如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；这个时候我们可以使用path.join函数； 拼接绝对路径：path.resolve
path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径；给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径；如果在处理完所有给定path的段之后，还没有生成绝对路径，则使用当前工作目录；生成的路径被规范化并删除尾部斜杠，零长度path段被忽略；如果没有path传递段，path.resolve()将返回当前工作目录的绝对路径； 9.4、path模块在webpack中的使用 9.5、正确认识webpack 事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：
比如开发过程中我们需要通过模块化的方式来开发；比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6&#43;、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码；比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率；比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化；等等 但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：
这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular；但是事实上，这三大框架的创建过程我们都是==借助于脚手架（CLI）==的；事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、TypeScript、打包优化等的； 工程化章节会去学习一些webpack的高级特性
9.6、脚手架依赖于webpack 9.7、Webpack到底是什么呢？ 我们先来看一下官方的解释：
webpack is a static module bundler for modern JavaScript applications. webpack是一个静态的模块化打包工具，为现代的JavaScript应用程序；">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-30T23:50:43+08:00">
    <meta property="article:modified_time" content="2024-06-30T23:50:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端工程化09-webpack静态的模块化打包工具(未完结)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="91_0"></a>9.1、开发模式的进化历史</h3> 
<p>webpacks是一个非常非常的强大的一个工具，相应的这个东西的学习也是有一定的难度的，里边的东西非常的多，里面涉及到的</p> 
<p>概念的话也是非常非常的多的。</p> 
<p>这个东西既然非常重要，那么在我们前端到底处于怎样的一个地位呢？</p> 
<p>有些人学习到这个阶段已经分不清楚了，到底什么是node,什么是npm/什么是webpack,所以我们有必要了解下前端开发的架构图</p> 
<p>目前我们前端比较流行的三大框架，Vue/React/Angular/,国内用Angular的非常少，如果公司需要你会，那么可以研究下，如果不</p> 
<p>是就没有必要把太多的精力放到、Angular上，本身这个东西的需求比较少，岗位也比较少，那么这个时候你花费更多时间学习</p> 
<p>Angular是没有什么太大的回报的，但是不可否认Angular是一个非常优秀的框架，他里边的架构设计也是非常优秀的~后续聊，目</p> 
<p>前我们国内用的最多的还是Vue和React</p> 
<p>我们目前的开发模式已经不是以前的那种模式，我先创建一个index.html，然后写标签写内容，下几个js文件，引入到项目里，在</p> 
<p>写对应的js,写css什么的</p> 
<p>现在的模式，假如你现在要开发一个旅游项目，先考虑用什么包管理工具，用npm还是用yarn,之后在确定给你的项目用到的打包</p> 
<p>工具webpack,然后在当前的架构下边确定用什么前端框架开发，比如Vue,React,Angular,在写具体的代码，有人说了，那我不会</p> 
<p>搭建这个架构怎么办，这个不需要担心，因为现在，你不管去开发Vue项目还是开发React这个项目，他们都有对应的脚手架来帮</p> 
<p>助你进行快速开发，所谓的脚手架，不管是Vue的还是React的他们呢都是基于Webpack的。</p> 
<p><img src="https://images2.imgbox.com/df/fb/Pa3Ynqz9_o.png" alt="image-20240629235709605"></p> 
<h3><a id="92WebpackNodePath_32"></a>9.2、Webpack使用Node内置的Path模块</h3> 
<p><strong>path模块是node的内置模块，通常用于对路径和文件进行处理，提供了很多好用的方法</strong></p> 
<p><strong>我们知道在Mac OS、Linux和window上的路径时不一样的</strong></p> 
<ul><li>window上会使用 \或者 \ 来作为文件路径的分隔符，当然目前也支持 /；</li><li>在Mac OS、Linux的Unix操作系统上使用 / 来作为文件路径的分隔符；</li></ul> 
<p><strong>那么如果我们在window上使用 \ 来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办呢？</strong></p> 
<ul><li>显示路径会出现一些问题；</li><li>所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块；</li></ul> 
<p>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）</p> 
<ul><li>Linux和Mac OS都实现了POSIX接口；</li><li>Window部分电脑实现了POSIX接口；</li></ul> 
<h3><a id="93pathAPI_51"></a>9.3、path模块常见的API</h3> 
<p><strong>从路径中获取信息</strong></p> 
<ul><li>dirname：获取文件的父文件夹；</li><li>basename：获取文件名；</li><li>extname：获取文件扩展名；</li></ul> 
<p><strong>路径的拼接：path.join</strong></p> 
<ul><li>如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；</li><li>这个时候我们可以使用path.join函数；</li></ul> 
<p><strong>拼接绝对路径：path.resolve</strong></p> 
<ul><li>path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径；</li><li>给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径；</li><li>如果在处理完所有给定path的段之后，还没有生成绝对路径，则使用当前工作目录；</li><li>生成的路径被规范化并删除尾部斜杠，零长度path段被忽略；如果没有path传递段，</li><li>path.resolve()将返回当前工作目录的绝对路径；</li></ul> 
<p><img src="https://images2.imgbox.com/92/d4/abLFtA0n_o.png" alt="image-20240630221719340"></p> 
<h3><a id="94pathwebpack_74"></a>9.4、path模块在webpack中的使用</h3> 
<p><img src="https://images2.imgbox.com/50/89/U0bR8wT3_o.png" alt="image-20240630221909697"></p> 
<h3><a id="95webpack_78"></a>9.5、正确认识webpack</h3> 
<p><strong>事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：</strong></p> 
<ul><li>比如开发过程中我们需要通过<mark>模块化的方式</mark>来开发；</li><li>比如也会使用一些<mark>高级的特性来加快我们的开发效率或者安全性</mark>，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码；</li><li>比如开发过程中，我们还希望<mark>实时的监听文件的变化</mark>来并且<mark>反映到浏览器上</mark>，提高开发的效率；</li><li>比如开发完成后我们还需要将<mark>代码进行压缩、合并以及其他相关的优化；</mark></li><li>等等</li></ul> 
<p><strong>但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：</strong></p> 
<ul><li>这是因为目前前端开发我们通常都会直接使用三大框架来开发：<mark>Vue、React、Angular；</mark></li><li>但是事实上，这三大框架的创建过程我们都是==借助于脚手架（CLI）==的；</li><li>事实上Vue-CLI、create-react-app、Angular-CLI都是<mark>基于webpack</mark>来帮助我们支持模块化、less、TypeScript、打包优化等的；</li></ul> 
<p><strong>工程化章节会去学习一些webpack的高级特性</strong></p> 
<h3><a id="96webpack_96"></a>9.6、脚手架依赖于webpack</h3> 
<p><img src="https://images2.imgbox.com/a3/bc/87GCRRmj_o.png" alt="image-20240630222627042"></p> 
<h3><a id="97Webpack_100"></a>9.7、Webpack到底是什么呢？</h3> 
<p><strong>我们先来看一下官方的解释：</strong></p> 
<ul><li>webpack is a <mark>static module bundler</mark> for <mark>modern</mark> JavaScript applications.</li></ul> 
<p><strong>webpack是一个静态的模块化打包工具，为现代的JavaScript应用程序；</strong></p> 
<ul><li><mark>打包bundler</mark>：webpack可以将帮助我们进行打包，所以它是一个打包工具</li><li><mark>静态的static</mark>：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）；</li><li><mark>模块化module</mark>：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等；</li><li><mark>现代的modern</mark>：我们前端说过，正是因为现代前端开发面临各种各样的问题，才催生了webpack的出现和发展；</li></ul> 
<p><strong>Webpack官网的图片</strong></p> 
<p><img src="https://images2.imgbox.com/60/bc/zYsUrq4y_o.png" alt="image-20240630223224320"></p> 
<h3><a id="98Vue_117"></a>9.8、Vue项目加载的文件有哪些呢？</h3> 
<p><strong>JavaScript的打包：</strong></p> 
<ul><li>将ES6转换成ES5的语法；</li><li>TypeScript的处理，将其转换成JavaScript；</li></ul> 
<p><strong>Css的处理：</strong></p> 
<ul><li>CSS文件模块的加载、提取；</li><li>Less、Sass等预处理器的处理；</li></ul> 
<p><strong>资源文件img、font：</strong></p> 
<ul><li>图片img文件的加载；</li><li>字体font文件的加载；</li></ul> 
<p><strong>HTML资源的处理：</strong></p> 
<ul><li>打包HTML资源文件；</li></ul> 
<p><strong>处理vue项目的SFC文件.vue文件；</strong></p> 
<h3><a id="91Webpack_140"></a>9.1、Webpack的使用前提</h3> 
<p><strong>webpack的官方文档是https://webpack.js.org/</strong></p> 
<ul><li>webpack的中文官方文档是https://webpack.docschina.org/</li><li>DOCUMENTATION：文档详情，也是我们最关注的</li></ul> 
<p><strong>Webpack的运行是依赖Node环境的，所以我们电脑上必须有Node环境</strong></p> 
<ul><li>所以我们需要先安装Node.js，并且同时会安装npm；</li><li>我当前电脑上的node版本是v16.15.1，npm版本是8.11.0（你也可以使用nvm或者n来管理Node版本）；</li><li>Node官方网站：https://nodejs.org/</li></ul> 
<p><img src="https://images2.imgbox.com/ea/e6/sdVu2sEc_o.png" alt="image-20240630223732485"></p> 
<h3><a id="92Webpack_155"></a>9.2、Webpack的安装</h3> 
<p><strong>webpack的安装目前分为两个</strong>：webpack、webpack-cli</p> 
<p>注意：从webpack4版本开始，你要想安装webpack就必须要同时安装俩东西。这个webpack-cli在用的时候是我们在命令行中使用webpack,必须要用的一个东西,</p> 
<p>这个东西的作用是他会识别我们的命令行，假如说你是通过代码的方式来使用webpack的，比如const webpack=require(“webpack”) ,webpack.compile(),编译某</p> 
<p>个文件，如果我自己写代码打包，那就不需要webpack-cli,但是我们目前使用webpack都是在命令行输入命令<code>webpack --entry</code>,</p> 
<p>为了识别这个命令,都是webpack-cli在做的，</p> 
<p><strong>那么它们是什么关系呢？</strong></p> 
<ul><li>执行webpack命令，会执行node_modules下的.bin目录下的webpack；</li><li>webpack在执行时是依赖webpack-cli的，如果没有安装就会报错；</li><li>而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程；</li><li>所以在安装webpack时，我们需要同时安装webpack-cli（第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的vue-service-cli的东西）</li></ul> 
<p><img src="https://images2.imgbox.com/7b/76/Wcb1wp3Q_o.png" alt="image-20240630224035525"></p> 
<pre><code class="prism language-sh"><span class="token function">npm</span> <span class="token function">install</span> webpack webpack-cli –g <span class="token comment"># 全局安装</span>
<span class="token function">npm</span> <span class="token function">install</span> webpack webpack-cli –D <span class="token comment"># 局部安装</span>
</code></pre> 
<p>全局安装在那敲命令都能用</p> 
<p>那一般来说，是局部安装多还是全局安装多一点</p> 
<ul><li>一般是局部安装多一点，<mark>为什么？</mark></li></ul> 
<p>假如说你的电脑里边有仨项目，分别是Vue2的、Vue3的项目、React的项目，这个三个项目都需要进行打包，但是不可能他们依赖的webpack版本完全一样，大概率是不一样的。所以每个项目里边有自己webpack</p> 
<h3><a id="93webpack_189"></a>9.3、创建局部的webpack</h3> 
<p><strong>前面我们直接执行webpack命令使用的是全局的webpack，如果希望使用局部的可以按照下面的步骤来操作。</strong></p> 
<p>第一步：创建package.json文件，用于管理项目的信息、库依赖等</p> 
<pre><code class="prism language-sh"><span class="token function">npm</span> init
</code></pre> 
<p>第二步：安装局部的webpack</p> 
<pre><code class="prism language-sh"><span class="token function">npm</span> <span class="token function">install</span> webpack webpack-cli <span class="token parameter variable">-D</span>
</code></pre> 
<p>第三步：使用局部的webpack</p> 
<pre><code class="prism language-sh">npx webpack
</code></pre> 
<p>第四步：在package.json中创建scripts脚本，执行脚本打包即可</p> 
<p><img src="https://images2.imgbox.com/bb/c3/0JJPNujO_o.png" alt="image-20240630232720319"></p> 
<pre><code class="prism language-sh"><span class="token function">npm</span> run build
</code></pre> 
<h3><a id="94Webpack_219"></a>9.4、Webpack的默认打包</h3> 
<p>我们可以通过webpack进行打包，之后运行<strong>打包之后</strong>的代码</p> 
<ul><li>在目录下直接执行 webpack 命令 
  <ul><li>webpack</li></ul> </li></ul> 
<p><strong>生成一个dist文件夹，里面存放一个main.js的文件，就是我们打包之后的文件：</strong></p> 
<ul><li>这个文件中的代码被压缩和丑化了；</li><li>另外我们发现代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚我们打包后的文件是否需要转成ES5之前的语法，后续我们需要通过babel来进行转换和设置；</li></ul> 
<p><strong>我们发现是可以正常进行打包的，但是有一个问题，webpack是如何确定我们的入口的呢？</strong></p> 
<ul><li>事实上，当我们运行webpack时，webpack会查找当前目录下的 src/index.js作为入口；</li><li>所以，如果当前项目中没有存在src/index.js文件，那么会报错；</li></ul> 
<p><strong>当然，我们也可以通过配置来指定入口和出口</strong></p> 
<pre><code class="prism language-sh"><span class="token comment">#改index.js生成的文件名</span>
npx webpack <span class="token parameter variable">--entry</span> ./src/main.js --output-filename ./bundle.js
<span class="token comment">#改生成的dist目录名</span>
npx webpack <span class="token parameter variable">--entry</span> ./src/main.js --output-filename ./bundle.js  --output-path ./build
</code></pre> 
<p>但是一般这个目录太长了，我们不会这么写的，都是配置一个配置文件</p> 
<h3><a id="95Webpack_247"></a>9.5、Webpack配置文件</h3> 
<p>在通常情况下，webpack需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然是不可以的。</p> 
<p>我们可以在根目录下创建一个webpack.config.js文件，来作为webpack的配置文件：</p> 
<p><img src="https://images2.imgbox.com/da/1d/n3JdS10w_o.png" alt="image-20240630232930846"></p> 
<p>继续执行webpack命令，依然可以正常打包</p> 
<pre><code class="prism language-sh"><span class="token function">npm</span> run build
</code></pre> 
<pre><code class="prism language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">"./src/main.js"</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">"bundle.js"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./build"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96ddb0e03582810ce2d3854127eef412/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据开发中如何计算用户留存及SQL示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f76cf1d5164bda37fd23e3cd228be5d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BFS：Floodfill算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>