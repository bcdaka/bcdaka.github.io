<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>课程设计---哈夫曼树的编码与解码（Java详解） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6bff9e9a5fae5b838338c2198472d10d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="课程设计---哈夫曼树的编码与解码（Java详解）">
  <meta property="og:description" content="目录
一.设计任务&amp;&amp;要求：
二.方案设计报告：
2.1 哈夫曼树编码&amp;译码的设计原理：
2.3设计目的：
2.3设计的主要过程：
2.4程序方法清单：
三.整体实现源码：
四.运行结果展示：
五.总结与反思：
一.设计任务&amp;&amp;要求： 题目要求：测试数据是一段任意的英文，也可以是一段完整的中文，采用哈夫曼算法进行编码，可输出对应的字符编码的解码
哈夫曼编码是一种最优变长码，即带权路径最小。这种编码有很强的应用背景，是数据压缩中的一个重要理论依据。对输入的一串文字符号实现哈夫曼编码，再对哈夫曼编码生成的代码串进行译码，输出字符串。要求完成以下功能：
1.针对给定的字符串，建立哈夫曼树。
2.生成哈夫曼编码。
3.对编码字符串译码。
二.方案设计报告： 2.1 哈夫曼树编码&amp;译码的设计原理： 哈夫曼编译码器的主要功能是先建立哈夫曼树，然后利用建好的哈夫曼树生成哈夫曼编码后进行译码。在数据通信中，通常需要将传送文字转换成由二进制字符0，1组成的二进制串，称之为编码。构建一个哈夫曼树，设定哈夫曼树中的左分支为0，右分支代表1，则从根结点到每个叶子节点所经过的路径组成的0和1的序列便为该节点对应字符的编码，称之为哈夫曼编码。最简单的二进制编码方式是等长编码。若采用不等长编码，让出现频率高的字符具有较短的编码，让出现频率低的字符具有较长的编码，这样可以有效缩短传送文字的总长度。哈夫曼树则是用于构造使编码总长最短，最节省空间成本的编码方案。 2.3设计目的： (1) 巩固和加深对数据结构课程所学知识的理解，了解并掌握数据结构与算法的设计方法；
(2) 初步掌握软件开发过程的问题分析、系统设计、程序编码、测试等基本方法和技能；
(3) 提高综合运用所学的理论知识和方法，独立分析和解决问题的能力；
(4) 训练用系统的观点和软件开发一般规范进行软件开发，培养软件工作者所应具备的科学的工作方法和作风；
(5) 培养查阅资料，独立思考问题的能力。
2.3设计的主要过程： 1.哈夫曼树叶子节点的创建
叶子节点需要存储字符，及其出现的频率，指向左右子树的指针和将来字符所编码成的二进制数字。这里用一个静态内部来来初始化树的叶子节点：
//用一个静态内部类来初始化树的节点 static class Node{ char ch; //记录字符 int freq; //统计每个字符出现的频次 Node left; Node right; String code; //编码 public Node(char ch) { this.ch = ch; } public Node(int freq, Node left, Node right) { this.freq = freq; this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-19T19:28:38+08:00">
    <meta property="article:modified_time" content="2024-06-19T19:28:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">课程设计---哈夫曼树的编码与解码（Java详解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E8%AE%BE%E8%AE%A1%E4%BB%BB%E5%8A%A1%26%26%E8%A6%81%E6%B1%82%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E8%AE%BE%E8%AE%A1%E4%BB%BB%E5%8A%A1%26%26%E8%A6%81%E6%B1%82%EF%BC%9A" rel="nofollow">一.设计任务&amp;&amp;要求：</a></p> 
<p id="%E4%BA%8C.%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A%EF%BC%9A" rel="nofollow">二.方案设计报告：</a></p> 
<p id="2.1%20%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81%26%E8%AF%91%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.1%20%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81%26%E8%AF%91%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A" rel="nofollow">2.1 哈夫曼树编码&amp;译码的设计原理：</a></p> 
<p id="2.3%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.3%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%EF%BC%9A" rel="nofollow">2.3设计目的：</a></p> 
<p id="2.3%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.3%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">2.3设计的主要过程：</a></p> 
<p id="2.4%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95%E6%B8%85%E5%8D%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.4%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95%E6%B8%85%E5%8D%95%EF%BC%9A" rel="nofollow">2.4程序方法清单：</a></p> 
<p id="%E4%B8%89.%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%EF%BC%9A" rel="nofollow">三.整体实现源码：</a></p> 
<p id="%E5%9B%9B.%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA%EF%BC%9A" rel="nofollow">四.运行结果展示：</a></p> 
<p id="%E4%BA%94.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D%EF%BC%9A" rel="nofollow">五.总结与反思：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E8%AE%BE%E8%AE%A1%E4%BB%BB%E5%8A%A1%26%26%E8%A6%81%E6%B1%82%EF%BC%9A" style="background-color:transparent;">一.设计任务&amp;&amp;要求：</h2> 
<p style="margin-left:.0001pt;text-align:justify;">题目要求：测试数据是一段任意的英文，也可以是一段完整的中文，采用哈夫曼算法进行编码，可输出对应的字符编码的解码</p> 
<p style="margin-left:.0001pt;text-align:left;"><a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81&amp;spm=1001.2101.3001.7020" title="哈夫曼编码">哈夫曼编码</a><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">是一种最优变长码，即带权路径最小。这种编码有很强的应用背景，是数据压缩中的一个重要理论依据。对输入的一串文字符号实现哈夫曼编码，再对哈夫曼编码生成的代码串进行译码，输出字符串。要求完成以下功能：</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;">1.</span><span style="background-color:#ffffff;">针对给定的字符串，建立哈夫曼树。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;">2.</span><span style="background-color:#ffffff;">生成哈夫曼编码。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;">3.</span><span style="background-color:#ffffff;">对编码</span><span style="background-color:#ffffff;">字符串</span><span style="background-color:#ffffff;">译码</span><span style="background-color:#ffffff;">。</span></p> 
<h2 id="%E4%BA%8C.%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A%EF%BC%9A" style="background-color:transparent;margin-left:.0001pt;text-align:justify;">二.方案设计报告：</h2> 
<h3 id="2.1%20%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81%26%E8%AF%91%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A" style="margin-left:.0001pt;text-align:justify;">2.1 哈夫曼树编码&amp;译码的设计原理：</h3> 
<ul><li style="margin-left:.0001pt;text-align:justify;">哈夫曼编译码器的主要功能是先建立哈夫曼树，然后利用建好的哈夫曼树生成哈夫曼编码后进行译码。在数据通信中，通常需要将传送文字转换成由二进制字符0，1组成的二进制串，称之为编码。构建一个哈夫曼树，设定哈夫曼树中的左分支为0，右分支代表1，则从根结点到每个叶子节点所经过的路径组成的0和1的序列便为该节点对应字符的编码，称之为哈夫曼编码。最简单的二进制编码方式是等长编码。若采用不等长编码，让出现频率高的字符具有较短的编码，让出现频率低的字符具有较长的编码，这样可以有效缩短传送文字的总长度。哈夫曼树则是用于构造使编码总长最短，最节省空间成本的编码方案。</li><li style="margin-left:.0001pt;text-align:justify;"> <h3 id="2.3%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%EF%BC%9A" style="background-color:transparent;">2.3设计目的：</h3> </li><li style="margin-left:.0001pt;text-align:justify;"> <p>(1) 巩固和加深对数据结构课程所学知识的理解，了解并掌握数据结构与算法的设计方法；<br> (2) 初步掌握软件开发过程的问题分析、系统设计、程序编码、测试等基本方法和技能；<br> (3) 提高综合运用所学的理论知识和方法，独立分析和解决问题的能力；<br> (4) 训练用系统的观点和软件开发一般规范进行软件开发，培养软件工作者所应具备的科学的工作方法和作风；<br> (5) 培养查阅资料，独立思考问题的能力。</p> </li></ul> 
<h3 id="2.3%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B%EF%BC%9A" style="background-color:transparent;margin-left:.0001pt;text-align:justify;">2.3设计的主要过程：</h3> 
<p>     1.哈夫曼树叶子节点的创建</p> 
<p>叶子节点需要存储字符，及其出现的频率，指向左右子树的指针和将来字符所编码成的二进制数字。这里用一个静态内部来来初始化树的叶子节点：</p> 
<pre><code class="language-java">  //用一个静态内部类来初始化树的节点
    static class Node{
        char ch;     //记录字符
        int freq;    //统计每个字符出现的频次
        Node left;
        Node right;
        String code;  //编码

        public Node(char ch) {
            this.ch = ch;
        }

        public Node(int freq, Node left, Node right) {
            this.freq = freq;
            this.left = left;
            this.right = right;
        }

        //判断是否是叶子节点-&gt;哈夫曼树是满二叉树
        boolean isLeaf(){
            return left == null;
        }

        public char getCh() {
            return ch;
        }

        public void setCh(char ch) {
            this.ch = ch;
        }

        public int getFreq() {
            return freq;
        }

        public void setFreq(int freq) {
            this.freq = freq;
        }
        //重写的toString 方法只需要打印字符和其对应的频次即可
        @Override
        public String toString() {
            return "Node{" +
                    "ch=" + ch +
                    ", freq=" + freq +
                    '}';
        }
    }</code></pre> 
<p style="text-align:justify;">      2.构建哈夫曼树</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 构建过程：首先要统计每个字符出现的频率①.将统计了出现频率的字符，放入优先级队列中，利用优先级队列的特点，将字符按照出现的频率从小到大排序②.每次出队两个频次最低的元素，给它们找一个父亲节点③.将父亲节点放入队列中，重复②~③两个步骤④.当队列中只剩一个元素时，哈夫曼树就构建完了 </p> 
<pre><code class="language-java"> //构造哈夫曼树
        //-&gt;由于这里是一个自定义的类，我们需要传入比较器，按照节点的频次进行比较
        PriorityQueue&lt;Node&gt; q = new PriorityQueue&lt;&gt;(
                //通过Comparator 的方法来获得Node节点的其中一个属性
                Comparator.comparingInt(Node::getFreq)
        );
        for(Node node : hash.values()){
            q.offer(node);
        }
        while(q.size() &gt;= 2){
            Node x = q.poll();
            Node y = q.poll();
            int freq = x.freq + y.freq;
            q.offer(new Node(freq,x,y));
        }</code></pre> 
<p style="text-align:justify;">       3.哈夫曼编码</p> 
<p style="margin-left:.0001pt;text-align:justify;">通过将每个叶子节点保存好的字符编码利用StringBuilder中的append（）方法拼接起来后返回即可</p> 
<pre><code class="language-java"> //编码操作：
    public String encode(){
        char[] chars = str.toCharArray();
        StringBuilder sb = new StringBuilder();
        for(char c : chars){
            sb.append(hash.get(c).code);
        }
        return sb.toString();
    }</code></pre> 
<p style="text-align:justify;">     4.哈夫曼译码</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"> <span style="background-color:#ffffff;"><span style="color:#080808;">从根节点开始，寻找数字对应的字符编码,如果是0向右走，如果是数字1向左走，如果没有走到头(一个字符的编码结尾)，每一步数字的索引cur++，每找到一个编码字符，在将node重置为根节点,接着重个节点开始继续往下寻找,一直找到字符串末尾即可</span></span></span></p> 
<pre><code class="language-java"> /**
     *  从根节点开始，寻找数字对应的字符
     *  数字是0 向右走，数字是1 向左走
     *  如果没有走到头，每一步数字的索引 cur++
     *  走到头就可以 找到编码字符，再将node 重置为根节点
     * @param str
     * @return
     */
    //解码操作：
    public String decode(String str){
        char[] chars = str.toCharArray();
        StringBuilder sb = new StringBuilder();
        int cur = 0;
        Node node = root;

        while(cur &lt; chars.length){
            if(!node.isLeaf()){//非叶子节点
                if(chars[cur] == '0'){//向左走
                    node = node.left;
                }else if(chars[cur] == '1'){//向右走
                    node =node.right;
                }
                //每走完一步 cur++;
                cur++;

                if(node.isLeaf()){
                    sb.append(node.ch);
                    //每找到一个叶子节点，就重置后再次查找，直到遍历完整个数组
                    node = root;
                }
            }
        }
        return sb.toString();
    }</code></pre> 
<ul><li style="margin-left:.0001pt;text-align:left;"><span style="color:#080808;"><span style="background-color:#ffffff;">大致模块图：</span></span></li></ul> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="391" src="https://images2.imgbox.com/29/ca/vHDvdzcO_o.png" width="560"></p> 
<p style="margin-left:.0001pt;text-align:left;">设计流程图：</p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="1200" src="https://images2.imgbox.com/ab/f0/ZTv6ANiC_o.png" width="1098"></p> 
<h3 id="2.4%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95%E6%B8%85%E5%8D%95%EF%BC%9A" style="background-color:transparent;margin-left:.0001pt;text-align:left;">2.4程序方法清单：</h3> 
<p style="margin-left:.0001pt;text-align:left;">①.构造哈夫曼树：public HuffmanTree(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">}//这里我选择在函数的构造方法中将哈夫曼树给先构造完</p> 
<p style="margin-left:.0001pt;text-align:left;">②.编码：public String encode(){};</p> 
<p style="margin-left:.0001pt;text-align:left;">③.解码:pulbic String decode(){};</p> 
<p style="margin-left:.0001pt;text-align:left;">④.找到编码，并计算其对应的bit位：private int findCode(Node node,StringBuilder code){};</p> 
<p style="margin-left:.0001pt;text-align:left;">⑤.打印菜单:menu(){};</p> 
<p style="margin-left:.0001pt;text-align:justify;">⑥.测试函数：main(){};</p> 
<p style="margin-left:.0001pt;text-align:justify;">模块展示：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="299" src="https://images2.imgbox.com/4f/6f/i8Q1OxSP_o.png" width="386"></p> 
<h2 id="%E4%B8%89.%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%EF%BC%9A" style="background-color:transparent;margin-left:.0001pt;text-align:justify;">三.整体实现源码：</h2> 
<pre><code class="language-java">import java.util.*;

public class HuffmanTree {

    //用一个静态内部类来初始化树的节点
    static class Node{
        char ch;     //记录字符
        int freq;    //统计每个字符出现的频次
        Node left;
        Node right;
        String code;  //编码

        public Node(char ch) {
            this.ch = ch;
        }

        public Node(int freq, Node left, Node right) {
            this.freq = freq;
            this.left = left;
            this.right = right;
        }

        //判断是否是叶子节点-&gt;哈夫曼树是满二叉树
        boolean isLeaf(){
            return left == null;
        }

        public char getCh() {
            return ch;
        }

        public void setCh(char ch) {
            this.ch = ch;
        }

        public int getFreq() {
            return freq;
        }

        public void setFreq(int freq) {
            this.freq = freq;
        }
        //重写的toString 方法只需要打印字符和其对应的频次即可
        @Override
        public String toString() {
            return "Node{" +
                    "ch=" + ch +
                    ", freq=" + freq +
                    '}';
        }
    }


    String str;
    Node root;
    Map&lt;Character,Node&gt; hash = new HashMap&lt;&gt;();

    public HuffmanTree(){

    }
    public HuffmanTree(String str){
        this.str = str;
        //统计字符出现的频次
        char[] chars = str.toCharArray();
        for(char ch : chars){
            if(!hash.containsKey(ch)){
                hash.put(ch,new Node(ch));
            }
            Node node = hash.get(ch);
            node.freq++;
        }
        for(Node node : hash.values()){
            System.out.println(node);
        }
        //构造哈夫曼树
        //-&gt;由于这里是一个自定义的类，我们需要传入比较器，按照节点的频次进行比较
        PriorityQueue&lt;Node&gt; q = new PriorityQueue&lt;&gt;(
                //通过Comparator 的方法来获得Node节点的其中一个属性
                Comparator.comparingInt(Node::getFreq)
        );
        for(Node node : hash.values()){
            q.offer(node);
        }
        while(q.size() &gt;= 2){
            Node x = q.poll();
            Node y = q.poll();
            int freq = x.freq + y.freq;
            q.offer(new Node(freq,x,y));
        }
        root = q.poll();
        //System.out.println(root);
        //计算每个字符的编码 以及其一共包含的bit位
        System.out.println("输出编码信息:");
        int sum = findCode(root,new StringBuilder());
        for(Node node : hash.values()){
            //打印节点及其编码信息
            System.out.println(node + " " + node.code);
        }
        System.out.println("总共占有的bit位是：" + sum);
    }
    //找到编码，并计算其对应的bit位
    private int findCode(Node node,StringBuilder code){
        int sum = 0;
        if(node.isLeaf()){
            //找到编码 并计算字符串编码后所占的bits
            node.code = code.toString();
            sum = node.freq * code.length();
        }else{
            sum += findCode(node.left,code.append("0"));
            code.deleteCharAt(code.length() - 1);

            sum += findCode(node.right,code.append("1"));
            code.deleteCharAt(code.length() - 1);
        }
        return sum;
    }

    //编码操作：
    public String encode(){
        char[] chars = str.toCharArray();
        StringBuilder sb = new StringBuilder();
        for(char c : chars){
            sb.append(hash.get(c).code);
        }
        return sb.toString();
    }


    /**
     *  从根节点开始，寻找数字对应的字符
     *  数字是0 向右走，数字是1 向左走
     *  如果没有走到头，每一步数字的索引 cur++
     *  走到头就可以 找到编码字符，再将node 重置为根节点
     * @param str
     * @return
     */
    //解码操作：
    public String decode(String str){
        char[] chars = str.toCharArray();
        StringBuilder sb = new StringBuilder();
        int cur = 0;
        Node node = root;

        while(cur &lt; chars.length){
            if(!node.isLeaf()){//非叶子节点
                if(chars[cur] == '0'){//向左走
                    node = node.left;
                }else if(chars[cur] == '1'){//向右走
                    node =node.right;
                }
                //每走完一步 cur++;
                cur++;

                if(node.isLeaf()){
                    sb.append(node.ch);
                    //每找到一个叶子节点，就重置后再次查找，直到遍历完整个数组
                    node = root;
                }
            }
        }
        return sb.toString();
    }

    static final int all_block_nums = 100;
    public static void memu() throws InterruptedException {
        //菜单加载页面
        for(int i = 0;i &lt; all_block_nums;i++){
            System.out.printf("\r[%d%%]&gt;",i*100/(all_block_nums-1));
            for(int j = 1;j &lt;= i*20/(all_block_nums);j++){
                System.out.print("▉");
                Thread.sleep(2);
            }
        }
        System.out.println();
        System.out.println("-------------------------------------------");
        System.out.println("----------                     ------------");
        System.out.println("--------    欢迎使用哈夫曼编码      ----------");
        System.out.println("---------     1.编码与解码          ---------");
        System.out.println("----------    0.退出              ----------");
        System.out.println("-------------------------------------------");
    }

    public static void main(String[] args) throws InterruptedException {
        Scanner sc = new Scanner(System.in);
        while(true){
            memu();
            String str = "0000";
            System.out.println("请选择:");
            int input = sc.nextInt();
            switch (input){
                case 0:
                    System.out.println("你选择了退出程序~~~");
                    break;
                case 1 :
                    System.out.println("你选择了编码与解码");
                    System.out.println("请输入要编码的字符串：");
                    String in = sc.next();
                    HuffmanTree huffmanTree = new HuffmanTree(in);
                    str = huffmanTree.encode();
                    System.out.println("编码后的字符串为:");
                    System.out.println(str);

                    System.out.println("将刚才编码好的字符串进行解码：");
                    String cur = huffmanTree.decode(str);
                    System.out.println("解码后的字符串：");
                    System.out.println(cur);
            }
            if(input == 0) break;
        }
    }
}</code></pre> 
<blockquote> 
 <h2 id="%E5%9B%9B.%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA%EF%BC%9A" style="background-color:transparent;">四.运行结果展示：</h2> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/78/x7jzcHvh_o.gif"></p> 
<h2 id="%E4%BA%94.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D%EF%BC%9A" style="background-color:transparent;">五.总结与反思：</h2> 
<p>这次课程设计的心得体会通过实践我的收获如下：<br> ① 巩固和加深了对数据结构的理解，提高综合运用本课程所学知识的能力。<br> ② 培养了我选用参考书，查阅手册及文献资料的能力。培养独立思考，深入研究，分析问题、解决问题的能力。<br> ③ 通过实际编译系统的分析设计、编程调试，掌握应用软件的分析方法和工程设计方法。<br> ④ 通过课程设计，培养了我严肃认真的工作作风，逐步建立正确的生产观念、经济观念和全局观念。</p> 
<p>通过本次数据结构的课设计，我学习了很多在上课没懂的知识，并对求哈夫曼树及哈夫曼编码/译码的算法有了更加深刻的了解，更巩固了课堂中学习有关于哈夫曼编码的知识，真正学会一种算法了。当求解一个算法时,不是拿到问题就不加思索地做，而是首先要先对它有个大概的了解，接着再详细地分析每一步怎么做，无论自己以前是否有处理过相似的问题，只要按照以上的步骤，必会顺利地做出来。</p> 
<p><strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/4a/05/ypkBx2c1_o.gif"></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c53cd966850e6cbb26dae19fe7d06fa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">20240620 每日AI必读资讯</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db77f4d55a2ed6aaa6e69439d5814840/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;初阶路】--- 类和对象(中)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>