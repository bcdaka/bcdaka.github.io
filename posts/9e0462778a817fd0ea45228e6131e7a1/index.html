<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法】单调队列&amp;&amp;单调栈 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9e0462778a817fd0ea45228e6131e7a1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法】单调队列&&单调栈">
  <meta property="og:description" content="一、单调队列 用来维护一段区间内的最大值或最小值，例如滑动窗口、区间最值等问题。
基本概念 单调队列是一种存储数据的队列，其中元素的顺序是单调递增或单调递减的。在算法竞赛中，我们一般使用两个单调队列，一个维护单调递增序列，另一个维护单调递减序列。单调队列是一个双端队列。
代码如下：
#include &lt;iostream&gt; #include &lt;deque&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; void output(vector&lt;int&gt;&amp; arr) { int n = arr.size(), len = 0; for (int i = 0; i &lt; n; i&#43;&#43;) len &#43;= printf(&#34;%3d&#34;, i); cout &lt;&lt; &#34;\n&#34;; for (int i = 0; i &lt; len; i&#43;&#43;)printf(&#34;-&#34;); cout &lt;&lt; &#34;\n&#34;; for (int i = 0; i &lt; n; i&#43;&#43;) len &#43;= printf(&#34;%3d&#34;, arr[i]); cout &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-09T12:05:31+08:00">
    <meta property="article:modified_time" content="2024-07-09T12:05:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法】单调队列&amp;&amp;单调栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;"><strong>一、单调队列</strong></h2> 
<p>   用来<strong>维护一段区间内的最大值或最小值</strong>，例如<code>滑动窗口</code>、<code>区间最值</code>等问题。</p> 
<h3 style="background-color:transparent;">基本概念</h3> 
<p>单调队列是一种<strong>存储数据的队列</strong>，其中元素的顺序是<strong>单调递增或单调递减</strong>的。在算法竞赛中，我们一般使用两个单调队列，一个维护单调递增序列，另一个维护单调递减序列。单调队列是一个<strong>双端队列</strong>。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

void output(vector&lt;int&gt;&amp; arr) {
	int n = arr.size(), len = 0;
	for (int i = 0; i &lt; n; i++) len += printf("%3d", i);
	cout &lt;&lt; "\n";
	
	for (int i = 0; i &lt; len; i++)printf("-");
	cout &lt;&lt; "\n";
	
	for (int i = 0; i &lt; n; i++) len += printf("%3d", arr[i]);
	cout &lt;&lt; "\n";
}

int main(){
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	vector&lt;int&gt; arr;
	deque&lt;int&gt; q;
	for (int i = 0, a; i &lt; n; i++) {
		cin &gt;&gt; a;
		arr.push_back(a);
	}
	output(arr);
	for (int i = 0; i &lt; n; i++) {
		while (!q.empty() &amp;&amp; arr[q.back()] &gt; arr[i])q.pop_back();
		q.push_back(i); //压入下标
		if (i - q.front() == k) q.pop_front(); //弹出队头
		printf("[%d, %d] = arr[%d] = %d \n",
			max(i - k + 1, 0), i,
			q.front(),arr[q.front()]);
	}
}</code></pre> 
<h4><img alt="" height="459" src="https://images2.imgbox.com/05/d0/ofMQxqWd_o.png" width="551"></h4> 
<h3>滑动窗口</h3> 
<p><a href="https://www.acwing.com/problem/content/156/" rel="nofollow" title="154. 滑动窗口 - AcWing题库">154. 滑动窗口 - AcWing题库</a></p> 
<p>滑动窗口是一类问题，需要在一个长度为n的序列中，找到所有<strong>长度为k的连续子序列中的最大值或最小值</strong>。使用单调队列可以在O(n)的时间复杂度内解决该问题。</p> 
<p><strong>具体做法如下：</strong></p> 
<blockquote> 
 <p>（1）将前k个元素插入单调队列中，并记录队列的最大值或最小值。<br> （2）从第k+1个元素开始，每次将一个新的元素插入单调队列中。<br> （3）插入时，先将队列中所有小于等于该元素的队尾元素出队，保证队列中的元素单调递减。<br> （4）将该元素插入队尾，并记录队列的最大值或最小值。<br> （5）将长度为k的子序列的最大值或最小值输出即可。</p> 
</blockquote> 
<h4>方法1：（数组实现）</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 1e6 + 10;
int q[N], a[N]; //数组q用来存下标
int main() {
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];

	//找滑动窗口最小值
	int hh = 0, tt = -1;
	for (int i = 0; i &lt; n; i++) {
		if (i - q[hh] == k) hh++; //队头弹出元素
		while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt; a[i]) tt--; //队尾弹出元素
		q[++tt] = i; //压入下标
		if (i - k + 1 &gt;= 0)printf("%d ", a[q[hh]]);
	}
	printf("\n");
	//找滑动窗口最大值
	hh = 0, tt = -1;
	for (int i = 0; i &lt; n; i++) {
		if (i - q[hh] == k) hh++; //队头弹出元素
		while (hh &lt;= tt &amp;&amp; a[q[tt]] &lt; a[i]) tt--; //队尾弹出元素
		q[++tt] = i; //压入下标
		if (i - k + 1 &gt;= 0)printf("%d ", a[q[hh]]);
	}
	return 0;
}
</code></pre> 
<h4>方法2：（双端队列）</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	vector&lt;int&gt; arr(n);
	deque&lt;int&gt; q;
	for (int i = 0; i &lt; n; i++)cin &gt;&gt; arr[i];
	for (int i = 0; i &lt; n; i++) {
		if (i - q.front() == k) q.pop_front();
		while (!q.empty() &amp;&amp; arr[q.back()] &gt; arr[i])q.pop_back();
		q.push_back(i);
		if (i - k + 1 &gt;= 0) cout &lt;&lt; arr[q.front()] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	q.clear();
	for (int i = 0; i &lt; n; i++) {
		if (i - q.front() == k) q.pop_front();
		while (!q.empty() &amp;&amp; arr[q.back()] &lt; arr[i])q.pop_back();
		q.push_back(i);
		if (i - k + 1 &gt;=0) cout &lt;&lt; arr[q.front()] &lt;&lt; " ";
	}
	return 0;
}
</code></pre> 
<p></p> 
<h3>区间最值</h3> 
<p><a href="https://www.acwing.com/problem/content/137/" rel="nofollow" title="135. 最大子序和 - AcWing题库">135. 最大子序和 - AcWing题库</a></p> 
<p>需要在一个长度为n的序列中，找到所有<strong>长度为k的子序列中的最大值或最小值</strong>。使用单调队列可以在O(n)的时间复杂度内解决该问题。</p> 
<p>其实现方法与上面类似，但是需要注意：</p> 
<ul><li>区间最值问题是在<strong>不限制子序列连续性</strong>的情况下，找到子序列中的最大值或最小值。</li><li>而滑动窗口问题则是在<strong>限制子序列必须连续</strong>的情况下，找到所有长度为k的子序列中的最大值或最小值。</li></ul> 
<h4 style="background-color:transparent;">方法1：（数组实现）</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;

typedef long long LL;

const int N = 1e6 + 10;
int q[N];
LL s[N];
int main()
{
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	//处理为前缀和序列
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; s[i];
		s[i] += s[i - 1];
	}
	LL res = -1e10;
	int hh = 0, tt = 0;
	for (int i = 1; i &lt;= n; i++) {
		if (i - q[hh] &gt; m) hh++;
		res = max(res, s[i] - s[q[hh]]);
		while (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt--;
		
		q[++tt] = i;
	}
	cout &lt;&lt; res &lt;&lt; "\n";
	return 0;
}
</code></pre> 
<h4>方法2：（双端队列）</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long LL;

int main()
{
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	//处理前缀和
	vector&lt;LL&gt; s(n + 1);
	s.push_back(0);
	deque&lt;LL&gt; q;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; s[i];
		s[i] += s[i - 1];
	}
	q.push_back(0);
	LL res = -1e6;
	for (int i = 1; i &lt;= n; i++) {
		if (i - q.front() &gt; m) q.pop_front();
		res = max(res, s[i] - s[q.front()]);
		while (!q.empty() &amp;&amp; s[q.back()] &gt;= s[i]) q.pop_back();
		q.push_back(i);
	}
	cout &lt;&lt; res &lt;&lt; "\n";
	return 0;
}

</code></pre> 
<h2 style="background-color:transparent;"><br> 二、单调栈</h2> 
<h3 style="background-color:transparent;">基本概念</h3> 
<p>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得<strong>每次新元素入栈后，栈内的元素都保持有序</strong>（单调递增或单调递减），即<strong>从队首不弹出元素的单调队列就是单调栈。</strong></p> 
<p><strong>作用：用于找最近小于关系（单调递增）和最近大于关系（单调递减）</strong></p> 
<p><strong>代码如下：</strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

void output(vector&lt;int&gt;&amp; arr) {
	int n = arr.size(), len = 0;
	for (int i = 0; i &lt; n; i++) len += printf("%3d", i);
	cout &lt;&lt; "\n";
	
	for (int i = 0; i &lt; len; i++)printf("-");
	cout &lt;&lt; "\n";
	
	for (int i = 0; i &lt; n; i++) len += printf("%3d", arr[i]);
	cout &lt;&lt; "\n";
}

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; arr;
	arr.push_back(-1); //假如极小值为-1
	stack&lt;int&gt; s;
	for (int i = 0, a; i &lt; n; i++) {
		cin &gt;&gt; a;
		arr.push_back(a);
	}
	arr.push_back(-1); //假如极小值为-1
	vector&lt;int&gt; l(arr.size() + 1), r(arr.size() + 1);
	output(arr);

	//右侧
	for (int i = 0;  i &lt; arr.size(); i++) {
		while (!s.empty() &amp;&amp; arr[s.top()] &gt; arr[i]) {
			r[s.top()] = i;
			s.pop();
		}
		s.push(i);
	}

	//左侧 (倒着扫描)
	while (!s.empty()) s.pop();
	for (int i = arr.size() - 1; i &gt;= 0; i--) {
		while (!s.empty() &amp;&amp; arr[s.top()] &gt; arr[i]) {
			l[s.top()] = i;
			s.pop();
		}
		s.push(i);
	}

	for (int i = 1; i &lt;= n; i++) {
		printf("arr[%d] = %d, right : arr[%d] = %d, left : arr[%d] = %d\n",
			i, arr[i],
			r[i], arr[r[i]],
			l[i], arr[l[i]]);
	}
	return 0;
}
</code></pre> 
<p><img alt="" height="467" src="https://images2.imgbox.com/b0/45/55ZzVFnh_o.png" width="898"></p> 
<p></p> 
<p><strong>数组实现单调栈：</strong></p> 
<p><strong><a class="link-info" href="https://www.acwing.com/problem/content/832/" rel="nofollow" title="830. 单调栈">830. 单调栈</a></strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
const int N = 10010;

int stk[N], tt ;
int main()
{
	int n;
	cin &gt;&gt; n;
	while(n--)
	{
	    int x;
	    cin&gt;&gt;x;
	    while(tt&amp;&amp;stk[tt]&gt;=x) tt--;
	    if(tt==0) printf("-1 ");
	    else printf("%d ",stk[tt]);
	    stk[++tt]=x;
	}
	return 0;
}</code></pre> 
<p></p> 
<h2>三、总结</h2> 
<p><strong>单调队列：</strong>擅长维护区间<strong>【最大/最小】</strong>值，最小值对应单调递增队列</p> 
<p><strong>单调栈：</strong>擅长维护最近<strong>【大于/小于】</strong>关系，</p> 
<blockquote> 
 <p>从左侧先入栈就是维护左侧最近关系</p> 
 <p>从右侧先入栈，就是维护右侧最近关系。</p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/258181cb9284466b80ec7cfeb670adf8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">探展2024世界人工智能大会之合合信息扫描黑科技～</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9fe2ed1eb6c006e49d07a2964d504388/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">跟《经济学人》学英文：2024年6月29日这期 A new lab and a new paper reignite an old AI debate</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>