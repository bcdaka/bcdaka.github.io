<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【LeetCode力扣】297. 二叉树的序列化与反序列化 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ad5355c3d3d72cbf67492e12a9dd0740/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【LeetCode力扣】297. 二叉树的序列化与反序列化">
  <meta property="og:description" content="目录
1、题目介绍
2、解题思路 2.1、详细过程图解
2.2、代码描述 2.3、完整代码
1、题目介绍 原题链接：297. 二叉树的序列化与反序列化 - 力扣（LeetCode）
示例 1：
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
示例 2：
输入：root = [ ]
输出：[ ]
示例 3：
输入：root = [1]
输出：[1]
示例 4：
输入：root = [1,2]
输出：[1,2]
提示：
树中结点数在范围 [0, 104] 内-1000 &lt;= Node.val &lt;= 1000 2、解题思路 二叉树序列化就是将内存中的二叉树变成硬盘中的字符串形式，并且要求每个二叉树能够对应一个唯一的字符串。
二叉树反序列化就是将这个唯一字符串在内存中还原回对应的二叉树。
2.1、详细过程图解 这里采用先序遍历完成序列化。只要理解了一种遍历的序列化，其他遍历（包括不限于中序遍历、后序遍历、层次遍历）的序列化都是依葫芦画瓢了。
先说规则：
通过先序遍历的顺序进行访问二叉树，假如访问到结点1，就将1写入字符串中，同理结点2就是写入2到节点中如果遇到空结点则在字符串中存入一个标识符号，这里我采用井号 # 来表述空结点。同时两个节点之间需要使用下划线 _ 隔开，也可以理解为表示一个结点值的结束。 序列化过程图解：
开始时字符串str为空。按照先序遍历，首先是访问结点1，所以此时字符串中存入了1和表示结点值结束的下划线 _。
str[ ]= &#34;1_&#34;
接着先序遍历访问到结点2，继续将2和下划线_拼接进字符串str中。
str[ ]= &#34;1_2_&#34;
接着先序遍历访问到空结点，此时将表示空姐点的标识符号井号#下划线_拼接进字符串str中。
str[ ]= &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-15T10:00:00+08:00">
    <meta property="article:modified_time" content="2023-10-15T10:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【LeetCode力扣】297. 二叉树的序列化与反序列化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/41/90/Okao0jul_o.png"> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D" rel="nofollow">1、题目介绍</a></p> 
<p id="2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">2、解题思路 </a></p> 
<p id="2.1%E3%80%81%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3-toc" style="margin-left:40px;"><a href="#2.1%E3%80%81%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3" rel="nofollow">2.1、详细过程图解</a></p> 
<p id="2.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0%C2%A0-toc" style="margin-left:40px;"><a href="#2.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0%C2%A0" rel="nofollow">2.2、代码描述 </a></p> 
<p id="%C2%A02.3%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%C2%A02.3%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow"> 2.3、完整代码</a></p> 
<p style="text-align:center;"><br><img alt="" src="https://images2.imgbox.com/5d/04/nhWgR8wC_o.gif"></p> 
<p> </p> 
<h2 id="1%E3%80%81%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">1、题目介绍</h2> 
<p>原题链接：<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/?envType=list&amp;envId=ixRuNo8f" rel="nofollow" title="297. 二叉树的序列化与反序列化 - 力扣（LeetCode）">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/d3/cf/CcxnmJYQ_o.png" width="1016"></p> 
<p> <strong>示例 1：</strong></p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/51/12/3ubwQUky_o.jpg" width="442"></p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>输入：</strong>root = [1,2,3,null,null,4,5]</p> 
 <p style="margin-left:0;text-align:justify;"><strong>输出：</strong>[1,2,3,null,null,4,5]</p> 
</blockquote> 
<p><strong>示例 2：</strong></p> 
<blockquote> 
 <p><strong>输入：</strong>root = [ ]</p> 
 <p style="margin-left:0;text-align:justify;"><strong>输出：</strong>[ ]</p> 
</blockquote> 
<p><strong>示例 3：</strong></p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>输入：</strong>root = [1]</p> 
 <p style="margin-left:0;text-align:justify;"><strong>输出：</strong>[1]</p> 
</blockquote> 
<p><strong>示例 4：</strong></p> 
<blockquote> 
 <p></p> 
 <p style="margin-left:0;text-align:justify;"><strong>输入：</strong>root = [1,2]</p> 
 <p style="margin-left:0;text-align:justify;"><strong>输出：</strong>[1,2]</p> 
</blockquote> 
<p><strong>提示：</strong></p> 
<ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul> 
<h2 id="2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0">2、解题思路 </h2> 
<blockquote> 
 <p>二叉树序列化就是将内存中的二叉树变成硬盘中的字符串形式，并且要求每个二叉树能够对应一个唯一的字符串。</p> 
 <p>二叉树反序列化就是将这个唯一字符串在内存中还原回对应的二叉树。</p> 
</blockquote> 
<h3 id="2.1%E3%80%81%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3">2.1、详细过程图解</h3> 
<blockquote> 
 <p>这里采用<strong>先序遍历</strong>完成序列化。只要理解了一种遍历的序列化，其他遍历（包括不限于中序遍历、后序遍历、层次遍历）的序列化都是依葫芦画瓢了。</p> 
 <p>先说规则：</p> 
 <ul><li>通过先序遍历的顺序进行访问二叉树，假如访问到结点1，就将1写入字符串中，同理结点2就是写入2到节点中</li><li>如果遇到空结点则在字符串中存入一个标识符号，这里我采用<strong>井号</strong> # 来表述空结点。</li><li>同时两个节点之间需要使用<strong>下划线 </strong>_ 隔开，也可以理解为表示一个结点值的结束。</li></ul> 
</blockquote> 
<p><strong>序列化过程图解：</strong></p> 
<blockquote> 
 <p>开始时字符串str为空。按照先序遍历，首先是访问结点1，所以此时字符串中存入了1和表示结点值结束的下划线 _。</p> 
 <p>str[ ]= "1_"</p> 
</blockquote> 
<p class="img-center"><img alt="" height="293" src="https://images2.imgbox.com/bb/3e/1MGUV0ld_o.png" width="415"></p> 
<blockquote> 
 <p>接着先序遍历访问到结点2，继续将2和下划线_拼接进字符串str中。</p> 
 <p>str[ ]= "1_2_"</p> 
</blockquote> 
<p class="img-center"><img alt="" height="270" src="https://images2.imgbox.com/45/f1/i7h1dcEa_o.png" width="419"></p> 
<blockquote> 
 <p>接着先序遍历访问到空结点，此时将表示空姐点的标识符号井号#下划线_拼接进字符串str中。</p> 
 <p>str[ ]= "1_2_#_"</p> 
</blockquote> 
<p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/0f/d1/qFKmrjnh_o.png" width="463"></p> 
<blockquote> 
 <p>同理依次进行遍历</p> 
 <p>str[ ]= "1_2_#_#_"</p> 
</blockquote> 
<p class="img-center"><img alt="" height="292" src="https://images2.imgbox.com/5e/5e/IkerpnBo_o.png" width="422"></p> 
<blockquote> 
 <p>通过依次遍历最后得到str字符串</p> 
 <p>str[ ]= "1_2_#_#_3_4_#_#_5_#_#_"</p> 
 <p>这个str字符串即为二叉树的序列化，而用字符串通过先序遍历还原回二叉树就成为反序列化。</p> 
</blockquote> 
<p><strong>反序列化过程图解：</strong></p> 
<blockquote> 
 <p>str从前往后遍历，按照先序遍历【头左右】的顺序还原回二叉树。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="245" src="https://images2.imgbox.com/ab/23/1oHcytey_o.png" width="413"></p> 
<p class="img-center"><img alt="" height="305" src="https://images2.imgbox.com/d9/d2/BOwhZRjl_o.png" width="411"></p> 
<p class="img-center"><img alt="" height="332" src="https://images2.imgbox.com/c1/3e/cHairbxW_o.png" width="388"></p> 
<p class="img-center"><img alt="" height="290" src="https://images2.imgbox.com/1f/17/dj8LlPeR_o.png" width="391"></p> 
<p class="img-center"><img alt="" height="313" src="https://images2.imgbox.com/dd/cb/H64eyRni_o.png" width="401"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="359" src="https://images2.imgbox.com/76/18/G8iYl92s_o.png" width="377"></p> 
<p> </p> 
<blockquote> 
 <p> 依次遍历str最终完成还原回原二叉树。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/e5/7d/UYH72fxh_o.png" width="434"></p> 
<p> </p> 
<h3 id="2.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0%C2%A0">2.2、代码描述 </h3> 
<blockquote> 
 <p>使用递归将二叉树按照先序遍历生成对应的<strong>序列化字符串ret。</strong></p> 
</blockquote> 
<pre><code class="language-java">    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null)   //等于空时返回井号标识符
        {
            return "#_";
        }
        String res = root.val + "_";  //将结点值与下划线_拼接
        res += serialize(root.left);  //将左子树返回的字符串拼接到当前的ret后
        res += serialize(root.right); //将右子树返回的字符串拼接到当前的ret后
        return ret;
    }</code></pre> 
<blockquote> 
 <p>使用split方法对字符串进行拆分，拆分出来的值放入一个数组中，再用队列依次接收数组的 值。</p> 
</blockquote> 
<pre><code class="language-java">    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] val = data.split("_");  //将data字符串按照下划线_为分隔符对字符串进行拆分
        Queue&lt;String&gt; queue = new  LinkedList&lt;&gt;(); //队列
        for(int i = 0;i &lt; val.length; i++) 
        {
            queue.add(val[i]);   //将拆分出来的值依次入队
        }
        return reconPreOrder(queue);  //返回队列
    }</code></pre> 
<blockquote> 
 <p>将得到的队列依次出队，通过递归判断是否为空标识符井号#，是则返回null，否则将值存入新开辟的头结点root中，再通过递归方式创建左子树以及右子树。最后将头结点root返回，即完成二叉树的反序列化。</p> 
</blockquote> 
<pre><code class="language-java">    public static TreeNode reconPreOrder(Queue&lt;String&gt; queue)
    {
        String val = queue.poll();   //出队
        if(val.equals("#"))   //等于#则返回null
        {
            return null;
        }
        TreeNode root = new TreeNode(Integer.valueOf(val));   //创建头结点存放val值
        root.left = reconPreOrder(queue);   //从递归中获取左子树信息
        root.right = reconPreOrder(queue);  //从递归中获取右子树信息

        return root;   //最后返回头结点
    }</code></pre> 
<h3 id="%C2%A02.3%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"> 2.3、完整代码</h3> 
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null)
        {
            return "#_";
        }
        String res = root.val + "_";
        res += serialize(root.left);
        res += serialize(root.right);
        return res;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] val = data.split("_");
        Queue&lt;String&gt; queue = new  LinkedList&lt;&gt;();
        for(int i = 0;i &lt; val.length; i++)
        {
            queue.add(val[i]);
        }
        return reconPreOrder(queue);
    }

    public static TreeNode reconPreOrder(Queue&lt;String&gt; queue)
    {
        String val = queue.poll();
        if(val.equals("#"))
        {
            return null;
        }
        TreeNode root = new TreeNode(Integer.valueOf(val));
        root.left = reconPreOrder(queue);
        root.right = reconPreOrder(queue);

        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));</code></pre> 
<p class="img-center"><img alt="" height="305" src="https://images2.imgbox.com/0e/fd/spwqq4Ml_o.png" width="851"></p> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#fe2c24;">彩蛋：</span></strong></span></p> 
<blockquote> 
 <p>在查看其他题解时发现了一个有趣的解题方法（请勿模仿）哈哈哈哈哈</p> 
</blockquote> 
<p> </p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/af/cf/v82yDTNq_o.png" width="672"></p> 
<hr> 
<p> </p> 
<p><strong>关于二叉树遍历的精讲：</strong></p> 
<p><a class="has-card" href="https://blog.csdn.net/zzzzzhxxx/article/details/133609612?spm=1001.2014.3001.5502" title="【算法与数据结构】二叉树的三种遍历代码实现（上）—— 用递归序知识点讲解_Hacynn的博客-CSDN博客"><span class="link-card-box"><span class="link-title">【算法与数据结构】二叉树的三种遍历代码实现（上）—— 用递归序知识点讲解_Hacynn的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/d1/2c/tdNJYVKX_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/zzzzzhxxx/article/details/133609612?spm=1001.2014.3001.5502</span></span></a><a class="has-card" href="https://blog.csdn.net/zzzzzhxxx/article/details/133669283?spm=1001.2014.3001.5502" title="【算法与数据结构】二叉树的三种遍历代码实现（下）—— 非递归方式实现（大量图解）-CSDN博客"><span class="link-card-box"><span class="link-title">【算法与数据结构】二叉树的三种遍历代码实现（下）—— 非递归方式实现（大量图解）-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/da/bf/VPsLvTdW_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/zzzzzhxxx/article/details/133669283?spm=1001.2014.3001.5502</span></span></a></p> 
<p> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/0a/Qeeydeu0_o.gif"></p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58f4ed279a1a6bd7b7bd223ce96959b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[入门一]C# webApi创建、与发布、部署、api调用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec93398f019073fc8d7d7eab8437b2ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学生信息管理系统——JAVA</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>