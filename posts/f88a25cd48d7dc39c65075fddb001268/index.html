<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】第十六弹---C语言实现希尔排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f88a25cd48d7dc39c65075fddb001268/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】第十六弹---C语言实现希尔排序">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
目录
1、希尔排序( 缩小增量排序 )
1.1、预排序实现
1.2、希尔排序代码实现
1.3、代码测试
1.4、时空复杂度分析
1.5、性能比较
总结
上一弹我们学习了直接插入排序，通过时空复杂度分析，时间复杂度为O(N^2)，一般情况效率较低，有没有对直接插入排序进行优化的排序呢？？？没错，我们这一弹讲解的排序就是对直接插入排序的优化的排序！！！
1、希尔排序( 缩小增量排序 ) 希尔排序是一种基于插入排序的算法，通过引入增量的概念来改进插入排序的性能
希尔排序法又称缩小增量法。希尔排序法的基本思想是：将原始列表分成多个子列表，先对每个子列表进行插入排序，然后逐渐减少子列表的数量，使整个列表趋向于部分有序，最后当整个列表作为一个子列表进行插入排序时，由于已经部分有序，所以排序效率高。这个过程中，每次排序的子列表是通过选择不同的“增量”来确定的。
动图如下： 实现思路
预排序直接插入排序 1.1、预排序实现 预排序：
根据当前增量，数组被分为若干子序列，这些子序列的元素在原数组中间隔着固定的增量。对每个子序列应用插入排序。
假设当前增量为5：
首先，增量为5，我们将数组元素分为增量（5）个子序列，每个子序列由原数组中相隔增量位置上的元素组成。所以我们有如下子序列：
子序列1: 9，4
子序列2: 1，8
子序列3: 2，6
子序列4: 5，3
子序列5: 7，5
然后对每个子序列进行独立的插入排序：
子序列1排序后：4，9
子序列2排序后：1，8
子序列3排序后：2，6
子序列2排序后：3，5
子序列3排序后：5，7
一趟排序之后的数组：
4 1 2 3 5 9 8 6 5 7
完成了一轮希尔排序，此时整个数组并不完全有序，但是已经比原始的数组更接近有序了。然后减小增量，通常是将原来的增量除以2（或者除以3&#43;1），现在选择下一个增量为 2，按照此排序规则继续预排序即可，直到增量为1时，则为直接插入排序，此时则排序完成。
一个子序列排序实现：
int gap; int end; int tmp = a[end &#43; gap]; while (end &gt;= 0) { if (a[end] &gt; tmp) { a[end &#43; gap] = a[end]; end-=gap; } else { break; } } a[end &#43; gap] = tmp; 与直接插入代码不同的是，这里对end所加减的均为gap；">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-15T12:52:43+08:00">
    <meta property="article:modified_time" content="2024-06-15T12:52:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】第十六弹---C语言实现希尔排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/7f/05/vFNbxXlb_o.jpg"></p> 
<p style="text-align:center;">✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏：</span> <a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】">【C++详解】</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.1%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%20%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%20)-toc" style="margin-left:0px;"><a href="#1.1%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%28%20%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%20%29" rel="nofollow">1、希尔排序( 缩小增量排序 )</a></p> 
<p id="1.1%E3%80%81%E9%A2%84%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#1.1%E3%80%81%E9%A2%84%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0" rel="nofollow">1.1、预排序实现</a></p> 
<p id="1.2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#1.2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">1.2、希尔排序代码实现</a></p> 
<p id="1.1.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#1.1.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95" rel="nofollow">1.3、代码测试</a></p> 
<p id="1.4%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#1.4%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">1.4、时空复杂度分析</a></p> 
<p id="1.2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#1.2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">1.5、性能比较</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p id="main-toc">上一弹我们学习了直接插入排序，通过时空复杂度分析，时间复杂度为O(N^2)，一般情况效率较低，有没有对直接插入排序进行优化的排序呢？？？没错，我们这一弹讲解的排序就是对直接插入排序的优化的排序！！！<br>  </p> 
<h2 id="1.1%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%20%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%20)">1、希尔排序( 缩小增量排序 )</h2> 
<p></p> 
<p>希尔排序是一种基于插入排序的算法，通过引入<strong>增量</strong>的概念来改进插入排序的性能</p> 
<blockquote> 
 <p><span style="color:#fe2c24;">希尔排序</span>法又<span style="color:#fe2c24;">称缩小增量法</span>。希尔排序法的基本思想是：<strong>将原始列表分成多个子列表</strong>，<strong>先对每个子列表进行插入排序</strong>，然后逐渐减少子列表的数量，<strong>使整个列表趋向于部分有序</strong>，最后当整个列表作为一个子列表进行插入排序时，由于已经部分有序，所以排序效率高。这个过程中，每次排序的子列表是通过选择不同的<span style="color:#fe2c24;">“增量”</span>来确定的。</p> 
</blockquote> 
<p></p> 
<p><span style="color:#fe2c24;">动图如下： </span></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a8/af/BXIBJrAd_o.gif"></p> 
<h3></h3> 
<p><strong>实现思路</strong></p> 
<blockquote> 
 <ol><li><strong>预排序</strong></li><li>直接插入排序</li></ol> 
</blockquote> 
<h3></h3> 
<h3 id="1.1%E3%80%81%E9%A2%84%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0">1.1、预排序实现</h3> 
<p></p> 
<p><strong><span style="color:#0d0016;">预排序：</span></strong></p> 
<blockquote> 
 <p><strong>根据当前增量，数组被分为若干子序列，这些子序列的元素在原数组中间隔着固定的增量。对每个子序列应用插入排序。</strong></p> 
</blockquote> 
<p>假设当前<strong><span style="color:#fe2c24;">增量为5：</span></strong></p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/1c/0f/0G1Ghb46_o.png" width="683"></p> 
<p>首先，增量为5，我们将数组元素分为增量（5）个子序列，每个子序列由原数组中相隔增量位置上的元素组成。所以我们有如下子序列：</p> 
<blockquote> 
 <p>子序列1: 9，4<br> 子序列2: 1，8<br> 子序列3: 2，6</p> 
 <p>子序列4: 5，3<br> 子序列5: 7，5</p> 
</blockquote> 
<p><br> 然后对每个子序列进行独立的插入排序：</p> 
<blockquote> 
 <p>子序列1排序后：4，9<br> 子序列2排序后：1，8<br> 子序列3排序后：2，6</p> 
 <p>子序列2排序后：3，5<br> 子序列3排序后：5，7</p> 
</blockquote> 
<p>一趟排序之后的数组：</p> 
<blockquote> 
 <p>4 1 2 3 5 9 8 6 5 7</p> 
</blockquote> 
<p></p> 
<p>完成了一轮希尔排序，此时整个数组并不完全有序，<strong>但是已经比原始的数组更接近有序了。然后减小增量，通常是将原来的增量除以2（或者除以3+1）</strong>，现在选择下一个增量为 2，按照此排序规则继续预排序即可，直到增量为1时，则为直接插入排序，此时则排序完成。</p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>一个子序列排序实现：</strong></span></p> 
<pre><code>int gap;
int end;
int tmp = a[end + gap];
while (end &gt;= 0)
{
	if (a[end] &gt; tmp)
	{
		a[end + gap] = a[end];
		end-=gap;
	}
	else
    {
		break;
    }
}
a[end + gap] = tmp;

</code></pre> 
<p>与直接插入代码不同的是，这里对end所加减的均为gap；</p> 
<p>单次插入完成后，<strong>我们来控制单个子序列的整个过程</strong>，每实现一次排序，下一次插入的数据为<strong>end+gap。</strong></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>单趟排序实现：</strong></span></p> 
<pre><code>int gap;

for (int i = 0; i &lt; n-gap; i += gap)
{
	int end = i;
	int tmp = a[end + gap];
	while (end &gt;= 0)
	{
		if (a[end] &gt; tmp)
		{
			a[end + gap] = a[end];
			end -= gap;
		}
		else
        {
			break;
	    }
    }
	a[end + gap] = tmp;
}
</code></pre> 
<p>这里for循环的条件为<strong><span style="color:#fe2c24;"> <code>i &lt;n-gap </code>防止数组越界.</span></strong></p> 
<p>完成单个子序列的排序后，我们再对<strong><span style="color:#0d0016;">整个子序列排序：</span></strong></p> 
<pre><code>int gap;
for (int j = 0; j &lt; gap; j++)
{
	for (int i = 0; i &lt; n - gap; i += gap)
	{
		int end = i;
		int tmp = a[end + gap];
		while (end &gt;= 0)
		{
			if (a[end] &gt; tmp)
			{
				a[end + gap] = a[end];
				end -= gap;
			}
			else
            {
				break;
		    }
       }
		a[end + gap] = tmp;
	}
}
</code></pre> 
<p><span style="color:#fe2c24;">外层循环<code>（for (int j = 0; j &lt; gap; j++)）</code>意在对每个以gap为间隔的分组进行遍历。</span></p> 
<p></p> 
<p><strong><span style="color:#0d0016;">优化：</span></strong></p> 
<blockquote> 
 <p><strong>这串代码三层循环的逻辑是按照每一组排序完成后再进行下一组排序的，事实上我们可以不需要最外层的循环。</strong></p> 
</blockquote> 
<pre><code>int gap = 3;
	
for (int i = 0; i &lt; n - gap; i++)
{
	int end = i;
	int tmp = a[end + gap];
	while (end &gt;= 0)
	{
		if (a[end] &gt; tmp)
		{
			a[end + gap] = a[end];
			end -= gap;
		}
		else
        {
			break;
	    }
    }
	a[end + gap] = tmp;
}
</code></pre> 
<p>这里我们将原先代码中的<code>i += gap</code>修改为<code>i++</code>，<strong>意味着这次不是按照一组一组进行了，是一次排序完每个组的第二个元素，再进行下一个元素的排序。</strong> </p> 
<p></p> 
<h3 id="1.2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">1.2、希尔排序代码实现</h3> 
<p>我们先对预排序的增量进行分析：</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>gap越大，大的值更快调到后面，小的值更快调到前面，越不接近有序。<br> gap越小，大的值更慢调到后面，小的值更慢调到前面，越接近有序。<br> 当gap为1，就是直接插入排序。</strong></span></p> 
</blockquote> 
<p>所以在实现希尔排序时，给gap固定值是行不通的。</p> 
<blockquote> 
 <p>因此，gap的值是应该随着n来变化的，实现多次预排。为了满足gap最终为1，博主推荐的方式是先将gap赋值成n，然后在排序的时候将gap赋值成<strong><span style="color:#fe2c24;">gap/3+1(或者gap/2)</span></strong>。</p> 
</blockquote> 
<pre><code>void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap &gt; 1)
	{
		gap = gap / 3 + 1;//博主写的是/3+1也可以是gap/2
		for (int i = 0; i &lt; n - gap; i++)
		{
			int end = i;
			int tmp = a[end + gap];
			while (end &gt;= 0)
			{
				if (a[end] &gt; tmp)
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
                {
					break;
                }
			}
			a[end + gap] = tmp;
		}
	}
}
</code></pre> 
<p><strong><span style="color:#0d0016;">这里无论gap是奇数还是偶数，这里gap最终都会除以到值为1。</span></strong></p> 
<p>在这里：</p> 
<blockquote> 
 <p><span style="color:#fe2c24;">gap&gt;1</span>时是预排序，目的<span style="color:#fe2c24;">让其接近有序</span>。<br><span style="color:#fe2c24;">gap=1时是直接插入排序，目的让其有序。</span><br> 在gap=1时，已经十分接近有序了。</p> 
</blockquote> 
<p>这里gap预排序次数还是有点多，因此我们可以再次进行修改，让gap每次除以3，<span style="color:#fe2c24;">为了使gap最后能回到1，我们进行加一处理。</span></p> 
<p></p> 
<p><span style="color:#fe2c24;"> 注意：</span></p> 
<blockquote> 
 <p>1. 此处都是每隔gap进行插入。</p> 
 <p>2. gap不是一定为gap/3 + 1，也可以是gap /2 ，原因是当gap等于1的时候就是直接插入排序，进行一次排序即可变成有序，所以只要最后的gap为1都是可以的。 </p> 
</blockquote> 
<h3 id="1.1.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95">1.3、代码测试</h3> 
<p></p> 
<p><span style="color:#fe2c24;">测试代码：</span></p> 
<pre><code>//测试希尔排序
int main()
{
	int a[] = { 9,8,7,6,5,4,3,2,1,0 };//给一组数据
	int sz = sizeof(a) / sizeof(a[0]);//计算数组元素个数
	printf("排序前：\n");
	ArrayPrint(a, sz);
	ShellSort(a, sz);
	printf("排序后：\n");
	ArrayPrint(a, sz);
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;">测试结果：</span></p> 
<p></p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/6b/96/g3GnfZFD_o.png" width="746"></p> 
<p></p> 
<h3 id="1.4%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">1.4、时空复杂度分析</h3> 
<blockquote> 
 <p>希尔排序的时间复杂度并不固定，它依赖于所选择的间隔序列（增量序列）。直到今天，已经有多种不同的间隔序列被提出来，每种都有自己的性能特点。</p> 
</blockquote> 
<p>《数据结构(C语言版)》--- 严蔚敏<br>  </p> 
<p><img alt="" height="375" src="https://images2.imgbox.com/aa/71/DOS1NR12_o.png" width="1200"></p> 
<p>《数据结构-用面相对象方法与C++描述》--- 殷人昆<br><img alt="" height="417" src="https://images2.imgbox.com/a2/37/BEi96MnC_o.png" width="1200"></p> 
<p><strong><span style="color:#0d0016;">时间复杂度：</span></strong></p> 
<p>因为咋们的gap是按照Knuth提出的方式取值的，而且Knuth进行了大量的试验统计，<strong><span style="color:#38d8f0;">我们暂时就按照：O(N^1.25) 到  O(1.6* N^1.25) 来算。</span></strong></p> 
<p></p> 
<p><strong><span style="color:#0d0016;">空间复杂度：</span></strong></p> 
<p><strong><span style="color:#38d8f0;">插入排序的空间复杂度为O(1)，因为它是一个原地排序算法，不需要额外的存储空间来排序。</span></strong></p> 
<p></p> 
<p></p> 
<h3 id="1.2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">1.5、性能比较</h3> 
<p>我们在前面一弹提到了<strong><span style="color:#0d0016;">clock()函数可以获取程序启动到函数调用时之间的CPU时钟周期数</span></strong>，我们在这里通过具体的排序算法来进行比较性能。</p> 
<p><span style="color:#fe2c24;">注意：clock()函数的头文件是#include&lt;time.h&gt;，时间的单位为毫秒。</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">性能比较的思想是通过比较两个函数所运行的时间大小。通过clock计算排序前的程序运行的时间，再计算排序结束程序运行的时间，时间的差值则为排序运行的时间。</span></strong></p> 
</blockquote> 
<p><span style="color:#38d8f0;"><strong>尽量使用release模式进行测试，因为release效率更高。</strong></span></p> 
<p><strong><span style="color:#0d0016;">测试代码：</span></strong></p> 
<pre><code>void TestOP()
{
	srand(time(0));//随机数种子
	const int N = 100000;
	int* a1 = (int*)malloc(sizeof(int) * N);//动态开辟N个元素
	int* a2 = (int*)malloc(sizeof(int) * N);
	for (int i = 0; i &lt; N; ++i)
	{
		a1[i] = rand() + i;//随机数只有3万，为了更加随机再加上i
		a2[i] = a1[i];
	}
    //clock计算程序运行到此时的时间 毫秒
	int begin1 = clock();//排序前程序运行时间
	InsertSort(a1, N);
	int end1 = clock();//排序后程序运行时间
	int begin2 = clock();
	ShellSort(a2, N);
	int end2 = clock();
	printf("InsertSort:%d\n", end1 - begin1);//程勋运行时间的差值即排序运行的时间
	printf("ShellSort:%d\n", end2 - begin2);
	free(a1);//释放空间
	free(a2);
}
</code></pre> 
<p><strong><span style="color:#0d0016;">当N为10万时，release版本测试出来的结果： </span></strong></p> 
<p> <img alt="" height="225" src="https://images2.imgbox.com/d4/57/jSfjgwsk_o.png" width="517"></p> 
<p> <strong><span style="color:#0d0016;">当N为100万时，release版本测试出来的结果： </span></strong></p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/06/82/0jFt99kM_o.png" width="494"></p> 
<blockquote> 
 <p><strong><span style="color:#38d8f0;">明显能够看到希尔排序的效率比直接插入排序的效率高很多，当N为10万的时候，希尔排序是直接插入排序的18倍，当N为10万的时候，希尔排序是直接插入排序的20倍。</span></strong></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>希尔排序的特性总结：</strong></span></p> 
<blockquote> 
 <p>时间复杂度：O(N²)</p> 
 <p>空间复杂度：O(1)</p> 
 <p>稳定性：不稳定</p> 
 <p>复杂性：简单</p> 
</blockquote> 
<h3 id="%E6%80%BB%E7%BB%93">总结</h3> 
<p><br> 本篇博客就结束啦，谢谢大家的观看，如果公主少年们有好的建议可以留言喔，谢谢大家啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5734373fea79b5ef5070ab67cb984ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">等待 chrome.storage.local.get() 完成</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2f144d8e88d82653c609d2c3bd750702/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;小病毒1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>