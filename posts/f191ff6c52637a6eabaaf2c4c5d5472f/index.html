<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java LeetCode篇-二叉树经典解法（实现：判断平衡二叉树、找两个节点最近的祖先等） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f191ff6c52637a6eabaaf2c4c5d5472f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java LeetCode篇-二叉树经典解法（实现：判断平衡二叉树、找两个节点最近的祖先等）">
  <meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 平衡二叉树
1.1 实现判断平衡二叉树的思路
1.2 代码实现判断平衡二叉树
2.0 二叉树的层序遍历
2.1 实现二叉树层序遍历的思路 2.2 代码实现二叉树层序遍历
3.0 二叉树的最近公共祖先
3.1 实现二叉树的最近公共祖先的思路
3.2 代码实现二叉树的最近公共祖先
4.0 根据二叉树创建字符串
4.1 实现根据二叉树创建字符串的思路
4.2 代码实现根据二叉树创建字符串
1.0 平衡二叉树 题目：
给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
示例 1：
输入：root = [3,9,20,null,null,15,7] 输出：true OJ链接：
110. 平衡二叉树
1.1 实现判断平衡二叉树的思路 具体思路为：只需要判断当前节点的左右子树最大深度差是否大于 1 即可。利用递归的方式，来获取当前节点的最大深度，利用该节点的深度与另一个兄弟节点进行比较，若差值的绝对值对于 1 时，说明不是平衡二叉树。
1.2 代码实现判断平衡二叉树 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-11T20:59:32+08:00">
    <meta property="article:modified_time" content="2023-12-11T20:59:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java LeetCode篇-二叉树经典解法（实现：判断平衡二叉树、找两个节点最近的祖先等）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong> </p> 
</blockquote> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/ca/50/B8V43lWd_o.jpg" width="400"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/01/24/4e4xEHaE_o.gif"></p> 
<p style="text-align:center;"> </p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        1.0 平衡二叉树</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%9D%E8%B7%AF" rel="nofollow">        1.1 实现判断平衡二叉树的思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        1.2 代码实现判断平衡二叉树</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">        2.0 二叉树的层序遍历</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">2.1 实现二叉树层序遍历的思路 </a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">        2.2 代码实现二叉树层序遍历</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88" rel="nofollow">        3.0 二叉树的最近公共祖先</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.1%20%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.1%20%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84%E6%80%9D%E8%B7%AF" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.1%20%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84%E6%80%9D%E8%B7%AF" rel="nofollow">3.1 实现二叉树的最近公共祖先的思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88" rel="nofollow">        3.2 代码实现二叉树的最近公共祖先</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">        4.0 根据二叉树创建字符串</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%80%9D%E8%B7%AF" rel="nofollow">        4.1 实现根据二叉树创建字符串的思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">        4.2 代码实现根据二叉树创建字符串</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">        1.0 平衡二叉树</h2> 
<blockquote> 
 <p><strong>题目：</strong></p> 
 <p><strong>        给定一个二叉树，判断它是否是高度平衡的二叉树。</strong></p> 
 <p><strong>本题中，一棵高度平衡二叉树定义为：</strong></p> 
 <blockquote> 
  <p><strong>一个二叉树<em>每个节点 </em>的左右两个子树的高度差的绝对值不超过 1 。</strong></p> 
 </blockquote> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/42/d2/mT1CazWo_o.jpg" width="242"></p> 
 <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>true</pre> 
 <p><strong>OJ链接：</strong></p> 
 <p></p> 
 <p><a href="https://leetcode.cn/problems/balanced-binary-tree/" rel="nofollow" title="110. 平衡二叉树">110. 平衡二叉树</a></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%9D%E8%B7%AF">        1.1 实现判断平衡二叉树的思路</h3> 
<p>       <strong> 具体思路为：<span style="color:#fe2c24;">只需要判断当前节点的左右子树最大深度差是否大于 1 即可。利用递归的方式，来获取当前节点的最大深度，利用该节点的深度与另一个兄弟节点进行比较，若差值的绝对值对于 1 时，说明不是平衡二叉树</span>。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">        1.2 代码实现判断平衡二叉树</h3> 
<blockquote> 
 <pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        recursion(root);
        return sign;
    }

    public boolean sign = true;
    public int recursion(TreeNode node) {
        if(node == null) {
            return 0;
        }
        int l = recursion(node.left);
        int r = recursion(node.right);
        if(l &lt; r) {
            int temp = l;
            l = r;
            r = temp;
        }
        if(l - r &gt; 1) {
            sign = false;
        }
        return l + 1;

    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" style="background-color:transparent;">        2.0 二叉树的层序遍历</h2> 
<blockquote> 
 <p>        <strong>给你二叉树的根节点 <code>root</code> ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</strong></p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="193" src="https://images2.imgbox.com/da/62/Y4kufVzy_o.jpg" width="177"></p> 
 <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[3],[9,20],[15,7]]</pre> 
 <p><strong>OJ链接：</strong></p> 
 <p></p> 
 <p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" rel="nofollow" title="102. 二叉树的层序遍历">102. 二叉树的层序遍历</a></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E8%B7%AF%C2%A0">         2.1 实现二叉树层序遍历的思路 </h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">利用层序遍历来进行按照从上到下，从左到右的顺序来访问每一层的节点</span>。</strong></p> 
<p><strong>        简单分析如何实现层序遍历：利用了队列的数据结构的特点，先进先出。那么先从根节点出发，将其压入队列中，接着判断从队列中弹出来的节点的左右孩子；若该节点的左孩子不为 null 时，将其压入队列中；若右孩子不为 null 时，将其压入队列中。循环往复，循环条件终止条件为：当队列为空时，说明已经把该树遍历完毕了。</strong></p> 
<p><strong>        回来再来看，<span style="color:#fe2c24;">需要将不同层级的节点放到不同的容器中，那么就可以利用每一层节点的个数来实现将不同的层级的节点放到不同的容器中。简单来说，就是当前的层级有多少个节点数，然后将这些的节点收集到同一个容器中，实现该效果可以利用压入队列中的节点个数为循环条件，将其放到同一的容器中</span>。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">        2.2 代码实现二叉树层序遍历</h3> 
<blockquote> 
 <pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        if(root == null) {
            return new ArrayList();
        }
        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();
        LinkedList&lt;TreeNode&gt; queue = new LinkedList();
        queue.offer(root);
        while (!queue.isEmpty()) {

            List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();
            int size = queue.size();
            for (int i = 0; i &lt; size; i++) {
                TreeNode poll = queue.poll();
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if (poll.right != null) {
                    queue.offer(poll.right);
                }
                list1.add(poll.val);
            }
            list.add(list1);
        }
        return list;
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88" style="background-color:transparent;">        3.0 二叉树的最近公共祖先</h2> 
<blockquote> 
 <p><strong>题目：</strong></p> 
 <p><strong>        给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</strong></p> 
 <p><strong><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" rel="nofollow" title="百度百科">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</strong></p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/2f/97/7VTEBIzY_o.png" width="200"></p> 
 <pre><strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
<strong>输出：</strong>3
<strong>解释：</strong>节点 5 和节点 1 的最近公共祖先是节点 3 。
</pre> 
 <p><strong><font face="monospace">OJ链接:</font></strong></p> 
 <p></p> 
 <p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" rel="nofollow" title="236. 二叉树的最近公共祖先">236. 二叉树的最近公共祖先</a></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.1%20%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84%E6%80%9D%E8%B7%AF">         3.1 实现二叉树的最近公共祖先的思路</h3> 
<p>        <strong>具体思路为：一般分为两种情况，</strong></p> 
<p><strong>        <span style="color:#fe2c24;">第一种，p 直接就是 q 的祖先或者 q 直接就是 p 的祖先。</span></strong></p> 
<blockquote> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/c0/aa/VWsMIMOK_o.png" width="200"></p> 
 <pre><strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
<strong>输出：</strong>5
<strong>解释：</strong>节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</pre> 
 <p>        <strong>这属于是第一种情况，<span style="color:#fe2c24;">节点 5 就是节点 4 的最近公共祖先。因此节点 5 必定在节点 4 之前，所以只要遍历找到节点 5 ，就可以直接返回该节点，不需要再遍历下去了。当且仅当一个节点不为 null ，另一个节点为 null 时，肯定属于第一种情况</span>。</strong></p> 
</blockquote> 
<p><strong>        <span style="color:#fe2c24;">第二种，互不为对方的祖先。</span></strong></p> 
<blockquote> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/e9/e2/ddkn04NE_o.png" width="200"></p> 
 <pre><strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
<strong>输出：</strong>3
<strong>解释：</strong>节点 5 和节点 1 的最近公共祖先是节点 3 。</pre> 
 <p>        <strong>这属于第二种情况，<span style="color:#fe2c24;">互不为对方的祖先。这也简单，只要通过递归来找到当前根节点的左右节点为 q 或者 p ，或者在当前的根节点中左右子树中可以找到的 q 或者 p 时，那么说明 q 与 p 同时都不为 null 时，当前的根节点就是他们最近的祖先节点</span>。这就是属于第二种情况。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">        3.2 代码实现二叉树的最近公共祖先</h3> 
<blockquote> 
 <pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == p || root == null || root == q) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left != null &amp;&amp; right != null) {
            return root;
        }
        return (left != null ? left : right);
        
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" style="background-color:transparent;">        4.0 根据二叉树创建字符串</h2> 
<blockquote> 
 <p><strong>题目：</strong></p> 
 <p><strong>        给你二叉树的根节点 <code>root</code> ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。</strong></p> 
 <p><strong>空节点使用一对空括号对 <code>"()"</code> 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</strong></p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="198" src="https://images2.imgbox.com/c3/39/mApi9DSV_o.jpg" width="192"></p> 
 <pre><strong>输入：</strong>root = [1,2,3,4]
<strong>输出：</strong>"1(2(4))(3)"
<strong>解释：</strong>初步转化后得到 "1(2(4)())(3()())" ，但省略所有不必要的空括号对后，字符串应该是"1(2(4))(3)" 。</pre> 
 <p><strong>OJ链接：</strong></p> 
 <p></p> 
 <p><a href="https://leetcode.cn/problems/construct-string-from-binary-tree/" rel="nofollow" title="606. 根据二叉树创建字符串">606. 根据二叉树创建字符串</a></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%80%9D%E8%B7%AF">        4.1 实现根据二叉树创建字符串的思路</h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">利用前序遍历得到的每一个节点的值拼接到可变字符串中，在拼接之前需要加上左括号，根节点开始从左子树遍历，若左子树遍历完，需要原路返回，判断当前节点的右子树有无节点，若有节点，则发生的是子问题过程了；若没有节点了，最后需要在可变中字符串拼接上右括号。</span></strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">        4.2 代码实现根据二叉树创建字符串</h3> 
<blockquote> 
 <pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public String tree2str(TreeNode root) {
        recursion(root);
        return  string.substring(1,string.length()-1);

    }
    public StringBuilder string = new StringBuilder();
    public void recursion(TreeNode node) {
        string.append("(");
        string.append(node.val);
        if (node.left != null) {
            recursion(node.left);
        }else if(node.right != null) {
            string.append("()");
        }
        if (node.right != null) {
            recursion(node.right);
        }
        string.append(")");
    }   
}</code></pre> 
 <p></p> 
</blockquote> 
<p style="text-align:center;"> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3a/a8/ydiwShux_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b29f84e2d96057df6b0a643985c59af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nginx正则表达式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d787148e4d44be34cceb9cffe7f68679/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hadoop-hdfs简介及常用命令详解（超详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>