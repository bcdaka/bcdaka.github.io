<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【一步一步了解Java系列】：子类继承以及代码块的初始化 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0513ac6b5b3c5c03d24b6d898058de3e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【一步一步了解Java系列】：子类继承以及代码块的初始化">
  <meta property="og:description" content="看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
继承的概念以及继承存在的意义
Java中的继承是一种面向对象编程（OOP）的基本概念，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。继承提供了一种机制，使得子类可以扩展或修改父类的行为。
意义：
首先，继承是面向对象编程的核心特性之一，它体现了面向对象设计的原则，如封装、抽象、继承和多态。其次继承可以提高代码的复用率，让子类继承运用到父类的一些数据和方法。还可以实现多态，使一个接口呈现不同的功能实现。还有实现程序的扩展性可以在一个代码的基础上进行扩展等等功能。当然继承还有好多意义，这里使列举不完的。
子类继承 讲到继承我们首先还是先了解子类，那么子类和父类如何分辨，还有如何继承，接下来都会讲到，我们先看一下下面的代码：
在这段代码中Animal为父类，Dog是子类，首先我们在生活中的逻辑上就是狗一定是动物，而动物不一定是狗，这就说明动物的范围更大，所以Animal是父类，Dog是子类。然后再从语法上分析，首先我们看到extends这个关键字，那么这个就代表继承，那么我们看到一个类使用了这个关键字就说明它就是这个关键字后面那个类的子类，extends后面的就是父类。比如： ** class Dog extends Animal{}**，那么Dog就为子类，Animal就是父类。
public class Animal { String type; int age; public void eat(){ System.out.println(&#34;吃食物&#34;); } public void speak(){ System.out.println(&#34;发出叫声&#34;); } } class Dog extends Animal{ String name; public Dog(String name){ type=&#34;狗&#34;; this.name=name; System.out.println(&#34;他是一只&#34;&#43;type&#43;&#34; 它的名字为:&#34;&#43;name); } public static void main(String[] args) { Dog dog=new Dog(&#34;旺财&#34;); dog.speak(); dog.eat(); } } 然后我们从上面的代码中也是发现子类能够使用父类的成员变量或给其赋值，也可以调用父类的成员方法。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-01T09:07:27+08:00">
    <meta property="article:modified_time" content="2024-06-01T09:07:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【一步一步了解Java系列】：子类继承以及代码块的初始化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>看到这句话的时候证明：此刻你我都在努力</strong><br> <strong>加油陌生人</strong><br> <img src="https://images2.imgbox.com/02/96/66G7Q0ut_o.png" alt="微信图片编辑_20240229212205.png"><br><strong>个人主页：</strong><a href="https://blog.csdn.net/2302_81249757?type=lately"><strong>Gu Gu Study</strong></a><strong><br><strong>专栏：</strong><a href="https://blog.csdn.net/2302_81249757/category_12656486.html?spm=1001.2014.3001.5482"><strong>一步一步了解Java</strong></a><br><br> 喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹</strong><br> <br><strong>喜欢的话可以点个赞谢谢了。</strong><br> <strong>作者：小闭</strong></p> 
<hr> 
<p>继承的概念以及继承存在的意义<br> <strong>Java中的继承是一种面向对象编程（OOP）的基本概念，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。继承提供了一种机制，使得子类可以扩展或修改父类的行为。</strong><br> 意义：<br> <strong>首先，继承是面向对象编程的核心特性之一，它体现了面向对象设计的原则，如封装、抽象、继承和多态。其次继承可以提高代码的复用率，让子类继承运用到父类的一些数据和方法。还可以实现多态，使一个接口呈现不同的功能实现。还有实现程序的扩展性可以在一个代码的基础上进行扩展等等功能。当然继承还有好多意义，这里使列举不完的。</strong></p> 
<hr> 
<h3><a id="_16"></a>子类继承</h3> 
<p>讲到继承我们首先还是先了解子类，那么子类和父类如何分辨，还有如何继承，接下来都会讲到，我们先看一下下面的代码：<br> 在这段代码中Animal为父类，Dog是子类，首先我们在<strong>生活中的逻辑上就是狗一定是动物，而动物不一定是狗，这就说明动物的范围更大，所以Animal是父类，Dog是子类</strong>。然后再从语法上分析，首先我们看到extends这个关键字，那么这个就代表继承，那么我们看到一个类使用了这个关键字就说明它就是这个关键字后面那个类的<strong>子类</strong>，extends后面的就是<strong>父类</strong>。比如： ** class Dog extends Animal{}**，那么Dog就为子类，Animal就是父类。</p> 
<pre><code>public class Animal {
    String type;
    int age;


    public void eat(){
        System.out.println("吃食物");
    }

    public void speak(){
        System.out.println("发出叫声");
    }

}


class Dog extends Animal{
   String name;
   public Dog(String name){
       type="狗";

       this.name=name;
       System.out.println("他是一只"+type+" 它的名字为:"+name);

   }

    public static void main(String[] args) {
        Dog dog=new Dog("旺财");
        dog.speak();
        dog.eat();

    }

        }
</code></pre> 
<p><img src="https://images2.imgbox.com/72/bc/7oAPm24g_o.png" alt="image.png"><br> 然后我们从上面的代码中也是发现<strong>子类能够使用父类的成员变量或给其赋值，也可以调用父类的成员方法</strong>。</p> 
<p>然后我们进入到第二个知识点：如果父类中包含构造方法时，子类要不要也定义一个构造方法，如何构造？那会不会与父类的构造方法冲突呢？我们接下来往下看：</p> 
<pre><code>public class Animal {
    String type;
    int age;
public Animal(String type,int age){

    this.type=type;
    this.age=age;

}

    public void eat(){
        System.out.println("吃食物");
    }

    public void speak(){
        System.out.println("发出叫声");
    }

}


class Dog extends Animal{
    String name;

    public Dog(String type, int age, String name) {
        super(type, age);
        this.name = name;
    }

    public static void main(String[] args) {

        Dog dog=new Dog("狗",2,"旺财");
        System.out.println("他是一只"+dog.type+" 它的名字为:"+dog.name);
        dog.speak();
        dog.eat();

    }

}
</code></pre> 
<p>如上：我们这次在父类加上构造方法，那么我们就必须<strong>在子类里先完成父类的构造方法，否则编译器会报错</strong><br> <img src="https://images2.imgbox.com/8c/85/9YZtqU6r_o.png" alt="image.png"><br> 那么该如何正确的定义子类的构造方法呢？<br> 那就是像上面的代码一样使用<strong>super</strong>关键字。<br> 那么接下来我们就来了解一下super关键字。</p> 
<h4><a id="super_105"></a>super</h4> 
<p>super关键字，在我现学的阶段有两个作用</p> 
<ol><li><strong>访问父类成员</strong>：当你在子类中重写了父类的方法或访问了父类的属性时，你可以使用super来明确地调用父类中的版本。例如：</li></ol> 
<pre><code>复制
class Parent {
    void show() {
        System.out.println("Parent's show()");
    }
}

class Child extends Parent {
    void show() {
        super.show(); // 调用父类的show()方法
        System.out.println("Child's show()");
    }
}
</code></pre> 
<ol start="2"><li><strong>调用父类的构造方法</strong>：在子类的构造方法中，你可以使用super()来调用父类的构造方法。这通常在构造方法的第一行进行，以确保在子类对象的初始化过程中，父类的状态也被正确地初始化。</li></ol> 
<pre><code>class Parent {
    Parent() {
        System.out.println("Parent's constructor");
    }
}

class Child extends Parent {
    Child() {
        super(); // 调用父类的构造方法
        System.out.println("Child's constructor");
    }
}
</code></pre> 
<p>第二点就是我所说的可以调用父类构造方法，注意super的调用必须在第一位。<br> 然后现在回过头来是不是就发现上面的代码就可以理解了</p> 
<hr> 
<h4><a id="superthis_145"></a>super和this的对比</h4> 
<p>相同点：</p> 
<ol><li>都是Java中的关键字。</li><li>都只能在类的非静态方法里使用，用来访问类的非静态成员方法或成员变量。</li><li>他们都要放在方法的第一句，这就注定他们不能同时出现在一个方法里。</li></ol> 
<p>不同点：</p> 
<ol><li><strong>this关键字</strong>： 
  <ul><li>this指的是当前对象的引用。</li><li>它用于当前对象的方法或构造方法中，来引用当前对象的成员（属性、方法）。</li><li>this可以用来调用当前类的其他构造方法（使用this()语法）。</li><li>this可以用来区分成员变量和局部变量，当它们具有相同的名称时。</li></ul> </li></ol> 
<p>示例：</p> 
<pre><code>class Example {
    int value;
    
    Example(int value) {
        this.value = value; // 使用this来引用当前对象的成员变量
    }
    
    void setValue(int value) {
        this.value = value; // 使用this来明确区分成员变量和参数
    }
}
</code></pre> 
<ol start="2"><li><strong>super关键字</strong>： 
  <ul><li>super指的是当前对象的直接父类对象的引用。</li><li>它用于访问父类的成员，特别是当子类重写了父类的方法或变量时。</li><li>super用于调用父类的构造方法（使用super()语法）。</li><li>super可以用来引用父类的类型，这在泛型和继承中特别有用。</li></ul> </li></ol> 
<p>示例：</p> 
<pre><code>class Parent {
    void show() {
        System.out.println("Parent's show()");
    }
}

class Child extends Parent {
    void show() {
        super.show(); // 调用父类的方法
    }
    
    Child() {
        super(); // 调用父类的构造方法
    }
}
</code></pre> 
<p>总结区别：</p> 
<ul><li>this是指向当前对象的引用。</li><li>super是指向当前对象的父类对象的引用。</li><li>this用于引用当前类的成员或调用其他构造方法。</li><li>super用于引用父类的成员或调用父类的构造方法。</li><li>this通常用于当前类的作用域内。</li><li>super通常用于子类中，与父类交互。</li></ul> 
<hr> 
<h5><a id="_210"></a>代码块的初始化与构造方法实现的先后顺序</h5> 
<p>那么现在我们了解一下代码块。代码块分为静态代码块和示例代码块，总所周知代码块和构造方法都可以给对象的成员赋值，那么他们赋值的顺序我们真的了解吗？接下来我们就可以来探索一下。<br> <strong>静态代码块</strong><br> 说到静态那么我们肯定要有static关键字了，我们来看一下这段代码：</p> 
<p><img src="https://images2.imgbox.com/34/d7/pzKR4yRx_o.png" alt="image.png"><br> 中间的static的花括号里的就是静态代码块。</p> 
<hr> 
<p><strong>实例代码块</strong><br> <img src="https://images2.imgbox.com/76/82/1UEwFvoC_o.png" alt="image.png"><br> 这样一个单独的花括号，或者没有花括号都算是实例代码块。</p> 
<hr> 
<p>然后构造方法大家都是知道的。</p> 
<pre><code>public Test(){

    System.out.println("执行了构造方法");


}
</code></pre> 
<hr> 
<p>那么他们执行的顺序是什么呢？我们继续往下看代码：</p> 
<pre><code>public class Test {
    String name="haha";
    int age=18;

    static{
        System.out.println("执行了静态代码块");

    }


public Test(){

    System.out.println("执行了构造方法");


}


    {
        System.out.println("执行了实例代码块");

    }
    
    
}

class Main{

    public static void main(String[] args) {
        Test test=new Test();
    }

}
</code></pre> 
<p><img src="https://images2.imgbox.com/a3/ea/9uiLeQ95_o.png" alt="image.png"><br> 如上我们得出结论：在一个类中我们的初始化顺序是： <strong>静态代码块----&gt;实例代码块----&gt;构造方法</strong>。</p> 
<p>那么我们又联想到，子类在实例化的时候会先实现父类的构造方法，那么如果在子类中实例化的顺序又是怎样呢？</p> 
<pre><code>public class Test {
    String name="haha";
    int age=18;

    static{
        System.out.println("执行了父类的静态代码块");

    }


public Test(){

    System.out.println("执行了父类的构造方法");


}


    {
        System.out.println("执行了父类实例代码块");

    }


}


class Test1 extends Test{

String type="狗";

static{
    System.out.println("执行了子类的静态代码块");
}


public Test1(){

    System.out.println("执行了子类的构造方法");

}



    {
        System.out.println("执行了子类的实例代码块");
    }

}



class Main{

    public static void main(String[] args) {
        Test test1=new Test1();
    }

}
</code></pre> 
<p><img src="https://images2.imgbox.com/ca/9e/qi6f5wYe_o.png" alt="image.png"><br> 又如上面代码又得出一个结论：<br> 子类的初始化顺序为：<strong>父类静态代码块----&gt;子类的静态代码块----&gt;父类的实例代码块----&gt;父类的构造方法</strong><br> <strong>----&gt;子类的实例代码块----&gt;子类的构造方法</strong></p> 
<p><strong>文章已到末尾，喜欢的话可以点个赞哦！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86f9c5fa3f7f851cb7029ab5fef626e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MES系统的功能、架构及应用价值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f746a9cb0f8d4adb506d4e349ca1a8c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】二叉树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>