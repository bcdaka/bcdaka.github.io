<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】程序环境，预处理，编译，汇编，链接详细介绍，其中预处理阶段重点讲解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/642582f67b7b9b7568640ac313205ee0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C语言】程序环境，预处理，编译，汇编，链接详细介绍，其中预处理阶段重点讲解">
  <meta property="og:description" content="目录
程序环境
翻译环境
1. 翻译环境的两个过程
2. 编译过程的三个阶段 执行环境 预处理(预编译) 1. 预定义符号
2. #define 2.1 用 #define 定义标识符(符号)
2.2 用 #define 定义宏 2.3 #define 的替换规则 2.4 # 和 ## 的用法
2.5 宏和函数
2.6 #undef
3. 命令行定义
4. 条件编译
5. 文件包含
5.1 两种头文件的包含
5.2 嵌套文件包含
程序环境 在ANSI C(标准C)的任何一种实现中，存在两个不同的环境。
1. 翻译环境，在这个环境中源代码被转换为可执行的机器指令。
2. 执行环境，它用于实际执行代码。
.
我们写出的C语言代码是文本信息，计算机不能直接理解，计算机是执行二进制指令的，翻译环境负责将C语言代码转成二进制指令，执行环境负责执行二进制代码。
翻译环境 1. 翻译环境的两个过程 1. 一个工程可以有多个.c(源文件)文件，每个源文件都会单独经过编译器处理生成自己对应的目标文件(.obj)，这个过程叫做编译。
2. 多个目标文件和链接库经过链接器的处理，最后生成可执行程序，这个过程叫做链接。
链接库的意思是链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。
2. 编译过程的三个阶段 翻译环境分为编译和链接两部分，编译又有预处理，编译，汇编三个阶段。
1. 预处理：gcc -E test.c -o test.i">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T17:23:26+08:00">
    <meta property="article:modified_time" content="2024-08-02T17:23:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】程序环境，预处理，编译，汇编，链接详细介绍，其中预处理阶段重点讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83-toc" style="margin-left:0px;"><a href="#%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83" rel="nofollow">程序环境</a></p> 
<p id="%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83-toc" style="margin-left:0px;"><a href="#%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83" rel="nofollow">翻译环境</a></p> 
<p id="1.%20%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#1.%20%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%BF%87%E7%A8%8B" rel="nofollow">1. 翻译环境的两个过程</a></p> 
<p id="2.%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%C2%A0-toc" style="margin-left:40px;"><a href="#2.%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%C2%A0" rel="nofollow">2. 编译过程的三个阶段 </a></p> 
<p id="%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%C2%A0" rel="nofollow">执行环境 </a></p> 
<p id="%E9%A2%84%E5%A4%84%E7%90%86(%E9%A2%84%E7%BC%96%E8%AF%91)%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%A2%84%E5%A4%84%E7%90%86%28%E9%A2%84%E7%BC%96%E8%AF%91%29%C2%A0" rel="nofollow">预处理(预编译) </a></p> 
<p id="1.%20%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7-toc" style="margin-left:40px;"><a href="#1.%20%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7" rel="nofollow">1. 预定义符号</a></p> 
<p id="2.%20%23define%C2%A0-toc" style="margin-left:40px;"><a href="#2.%20%23define%C2%A0" rel="nofollow">2. #define </a></p> 
<p id="2.1%20%E7%94%A8%20%23define%20%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6(%E7%AC%A6%E5%8F%B7)-toc" style="margin-left:80px;"><a href="#2.1%20%E7%94%A8%20%23define%20%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6%28%E7%AC%A6%E5%8F%B7%29" rel="nofollow">2.1 用 #define 定义标识符(符号)</a></p> 
<p id="2.2%20%E7%94%A8%20%23define%20%E5%AE%9A%E4%B9%89%E5%AE%8F%C2%A0-toc" style="margin-left:80px;"><a href="#2.2%20%E7%94%A8%20%23define%20%E5%AE%9A%E4%B9%89%E5%AE%8F%C2%A0" rel="nofollow">2.2 用 #define 定义宏 </a></p> 
<p id="2.3%20%23define%20%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99%C2%A0-toc" style="margin-left:80px;"><a href="#2.3%20%23define%20%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99%C2%A0" rel="nofollow">2.3 #define 的替换规则 </a></p> 
<p id="2.4%20%23%20%E5%92%8C%20%23%23%20%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.4%20%23%20%E5%92%8C%20%23%23%20%E7%9A%84%E7%94%A8%E6%B3%95" rel="nofollow">2.4 # 和 ## 的用法</a></p> 
<p id="2.5%20%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.5%20%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0" rel="nofollow">2.5 宏和函数</a></p> 
<p id="2.6%20%23undef-toc" style="margin-left:80px;"><a href="#2.6%20%23undef" rel="nofollow">2.6 #undef</a></p> 
<p id="3.%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#3.%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89" rel="nofollow">3. 命令行定义</a></p> 
<p id="4.%20%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91-toc" style="margin-left:40px;"><a href="#4.%20%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91" rel="nofollow">4. 条件编译</a></p> 
<p id="5.%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-toc" style="margin-left:40px;"><a href="#5.%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB" rel="nofollow">5. 文件包含</a></p> 
<p id="5.1%20%E4%B8%A4%E7%A7%8D%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB-toc" style="margin-left:80px;"><a href="#5.1%20%E4%B8%A4%E7%A7%8D%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB" rel="nofollow">5.1 两种头文件的包含</a></p> 
<p id="5.2%C2%A0%E5%B5%8C%E5%A5%97%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-toc" style="margin-left:80px;"><a href="#5.2%C2%A0%E5%B5%8C%E5%A5%97%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB" rel="nofollow">5.2 嵌套文件包含</a></p> 
<hr id="hr-toc"> 
<p style="text-align:center;"></p> 
<h2 id="%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83">程序环境</h2> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>在ANSI C(标准C)的任何一种实现中，存在两个不同的环境。</strong></span></p> 
 <p>1. 翻译环境，在这个环境中源代码被转换为可执行的机器指令。</p> 
 <p>2. 执行环境，它用于实际执行代码。</p> 
 <p>.</p> 
 <p>我们写出的C语言代码是文本信息，计算机不能直接理解，计算机是执行二进制指令的，翻译环境负责将C语言代码转成二进制指令，执行环境负责执行二进制代码。</p> 
</blockquote> 
<hr> 
<p></p> 
<h2 id="%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83">翻译环境</h2> 
<h3 id="1.%20%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%BF%87%E7%A8%8B">1. 翻译环境的两个过程</h3> 
<blockquote> 
 <p>1. 一个工程可以有多个.c(源文件)文件，每个源文件都会单独经过编译器处理生成自己对应的目标文件(.obj)，这个过程叫做编译。</p> 
 <p>2. 多个目标文件和链接库经过链接器的处理，最后生成可执行程序，这个过程叫做链接。</p> 
 <p>链接库的意思是链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。</p> 
 <p><img alt="" height="536" src="https://images2.imgbox.com/84/45/GsqTT0PK_o.png" width="730"></p> 
</blockquote> 
<h3 id="2.%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%C2%A0">2. 编译过程的三个阶段 </h3> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>翻译环境分为编译和链接两部分，编译又有预处理，编译，汇编三个阶段。</strong></span></p> 
 <p><img alt="" height="511" src="https://images2.imgbox.com/d8/08/NxlX4X8O_o.png" width="1190"></p> 
 <p>1. 预处理：gcc -E test.c -o test.i</p> 
 <p>预处理完成之后就停下来，预处理之后产生的结果都放在test.i文件中。</p> 
 <p>2. 编译：gcc -S test.c</p> 
 <p>编译完成之后就停下来，结果保存在test.s中。</p> 
 <p>3. 汇编：gcc -c test.c</p> 
 <p>汇编完成之后就停下来，结果保存在test.o中。</p> 
 <p>.</p> 
 <p><span style="color:#956fe7;"><strong>符号</strong></span></p> 
 <p><img alt="" height="128" src="https://images2.imgbox.com/d6/99/I60vIX98_o.png" width="583"></p> 
 <p>1. 查看符号，这些符号都是全局的。</p> 
 <p><img alt="" height="315" src="https://images2.imgbox.com/4c/67/E25W8fcR_o.png" width="583"></p> 
 <p>2. 每个源文件自己编译阶段符号汇总，汇编阶段形成符号表(符号，对应地址)，链接进行所有源文件的符号表合并(相同符号合并，函数定义的符号的地址为有效地址，函数声明的符号的地址为无效地址，选取有效地址)。</p> 
 <p>比如：下图main.c符号表中_sum地址是无效的，合并的时候选择sum.c符号表的_sum地址。</p> 
 <p><img alt="" height="250" src="https://images2.imgbox.com/73/c7/6q9b4v60_o.png" width="1013"></p> 
</blockquote> 
<hr> 
<p></p> 
<h2 id="%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%C2%A0">执行环境 </h2> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>程序执行的过程：</strong></span></p> 
 <p>1. 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排(例如单片机的烧录)，也可能是通过可执行代码置入只读内存来完成。</p> 
 <p>2. 程序的执行便开始。接着便调用main函数。 </p> 
 <p>3. 开始执行程序代码。这个时候程序将使用一个运行时堆栈(stack)也就是函数栈帧，存储函数的局部变量和返回地址。程序同时也可以使用静态(static)内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。</p> 
 <p>4. 终止程序。正常终止main函数；也有可能是意外终止。</p> 
</blockquote> 
<hr> 
<p></p> 
<h2 id="%E9%A2%84%E5%A4%84%E7%90%86(%E9%A2%84%E7%BC%96%E8%AF%91)%C2%A0">预处理(预编译) </h2> 
<h3 id="1.%20%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7">1. 预定义符号</h3> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>以下预定义符号会在预处理阶段被替换。</strong></span></p> 
 <p>__FILE__ 替换为当前进行编译的源文件名称</p> 
 <p>__LINE__ 替换为当前的行号</p> 
 <p>__DATE__ 替换为文件被编译的日期</p> 
 <p>__TIME__ 替换为文件被编译的时间</p> 
 <p>__STDC__ 如果编译器遵循ANSI C，其值为1，否则未定义</p> 
 <p>.</p> 
 <p><img alt="" height="185" src="https://images2.imgbox.com/12/4c/0NBYDQ5j_o.png" width="386"></p> 
 <p><img alt="" height="213" src="https://images2.imgbox.com/97/f2/MzxMoBZu_o.png" width="361"></p> 
</blockquote> 
<h3 id="2.%20%23define%C2%A0">2. #define </h3> 
<h4 id="2.1%20%E7%94%A8%20%23define%20%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6(%E7%AC%A6%E5%8F%B7)">2.1 用 #define 定义标识符(符号)</h4> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>语法：</strong></span></p> 
 <pre><code class="language-cpp">#define name stuff</code></pre> 
 <p><span style="color:#4da8ee;"><strong>例子：</strong></span></p> 
 <p><span style="color:#0d0016;">用 MAX 代表1000。</span></p> 
 <pre><code class="language-cpp">#define MAX 1000</code></pre> 
 <p>为 register 这个关键字，创建一个简短的名字。</p> 
 <pre><code class="language-cpp">#define reg register</code></pre> 
 <p>用更形象的符号来替换一种实现。</p> 
 <pre><code class="language-cpp">#define do_forever for(;;)</code></pre> 
 <p>在写 case 语句的时候自动把 break 写上。</p> 
 <pre><code class="language-cpp">#define CASE break;case</code></pre> 
 <p>如果定义的 stuff 过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。</p> 
 <pre><code class="language-cpp">#define DEBUG_PRINT printf("file:%s\tline:%d\t\
                            date:%s\ttime:%s\n" ,\
                            __FILE__,__LINE__ ,\
                            __DATE__,__TIME__ )</code></pre> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>提问：在define定义标识符的时候，要不要在最后加上;</strong></span></p> 
 <p>答：不会直接报错，但没必要加，因为</p> 
 <p>1. 这只是单纯的替换，如果你加了分号，万一代码那边也写了分号，就会出现两个分号。</p> 
 <p>2. 不方便进行运算和逻辑执行，替换后你多一个分号有时候会影响原先代码的逻辑。</p> 
</blockquote> 
<h4 id="2.2%20%E7%94%A8%20%23define%20%E5%AE%9A%E4%B9%89%E5%AE%8F%C2%A0">2.2 用 #define 定义宏 </h4> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>语法：</strong></span></p> 
 <p>其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在 stuff 中。</p> 
 <pre><code class="language-cpp">#define name(parament-list) stuff </code></pre> 
 <p><span style="color:#4da8ee;"><strong>用法：</strong></span></p> 
 <pre><code class="language-cpp">#define MAX(x, y) (x&gt;y ? x : y)</code></pre> 
 <p>这个写法其实不够严谨，因为传进来的可能是多项式，所以尽量加上括号。</p> 
 <pre><code class="language-cpp">#define MAX(x, y) ((x)&gt;(y) ? (x) : (y))</code></pre> 
 <p>这个替换会发生在预处理阶段。</p> 
 <p><img alt="" height="352" src="https://images2.imgbox.com/fa/d2/YubShNHF_o.png" width="981"></p> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>带副作用的宏参数 </strong></span></p> 
 <pre><code class="language-cpp">x+1;//不带副作用
x++;//带有副作用</code></pre> 
 <p>例子</p> 
 <pre><code class="language-cpp">#define MAX(a, b)  ( (a) &gt; (b) ? (a) : (b) )
 
x = 5;
y = 8;
z = MAX(x++, y++);</code></pre> 
 <p>z 就会替换为 z = ( (x++) &gt; (y++) ? (x++) : (y++));</p> 
 <p>副作用就是表达式求值的时候出现的永久性效果。</p> 
</blockquote> 
<h4 id="2.3%20%23define%20%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99%C2%A0">2.3 #define 的替换规则 </h4> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>在程序中扩展 #define 定义的符号和宏时，需要涉及几个步骤。</strong></span></p> 
 <p>1. 在调用宏时，首先对参数进行检查，看看是否包含任何由 #define 定义的符号。如果有，那它们首先被替换，替换后的文本被插入到程序中原来文本的位置。</p> 
 <p>2. 然后参数被宏的值所替换。</p> 
 <p>3. 最后，再次对结果文件进行扫描，看看它是否包含任何由 #define 定义的符号。如果有，就重复上述处理过程。</p> 
 <p><span style="color:#4da8ee;"><strong>注意：</strong></span></p> 
 <p>1. 宏参数和 #define 定义中可以出现其他 #define 定义的符号。但是宏不能出现递归。</p> 
 <p>2. 当预处理器搜索 #define 定义的符号时，字符串常量的内容并不被搜索。</p> 
</blockquote> 
<h4 id="2.4%20%23%20%E5%92%8C%20%23%23%20%E7%9A%84%E7%94%A8%E6%B3%95">2.4 # 和 ## 的用法</h4> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>1. # 的用法：把宏的参数插入到字符串中。</strong></span></p> 
 <p>例子：</p> 
 <pre><code class="language-cpp">#define PRINT(n) printf("the value of n is %d\n", n)

int main()
{
    int a = 10;
    PRINT(a);
    
    int b = 20;
    PRINT(b);

    return 0;
}</code></pre> 
 <p>问题：字符串中的n没有被替换。</p> 
 <p><img alt="" height="108" src="https://images2.imgbox.com/c4/5c/xgSmfa4d_o.png" width="296"></p> 
 <p>解决办法：在 n 前面加一个 #</p> 
 <pre><code class="language-cpp">#define PRINT(n) printf("the value of "#n" is %d\n", n)

int main()
{
    int a = 10;
    PRINT(a);
    
    int b = 20;
    PRINT(b);

    return 0;
}</code></pre> 
 <p><img alt="" height="127" src="https://images2.imgbox.com/31/9c/6PgrpQdH_o.png" width="355"></p> 
 <p>题外话：字符串的双引号是可以连接的。</p> 
 <p>比如：</p> 
 <p><img alt="" height="199" src="https://images2.imgbox.com/98/03/EiUz44pz_o.png" width="284"><img alt="" height="118" src="https://images2.imgbox.com/94/e3/wjEjon25_o.png" width="142"></p> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>2. ## 的用法：可以把位于它两边的符号合成一个符号。</strong></span></p> 
 <p>例子：</p> 
 <p>将 a 和 b 连起来变成 ab。</p> 
 <pre><code class="language-cpp">#define CAT(x, y) x##y

int main()
{
    int ab = 10;
    printf("%d\n", CAT(a, b));
    printf("%d\n", ab);

    return 0;
}</code></pre> 
 <p><img alt="" height="129" src="https://images2.imgbox.com/03/18/E5pVksij_o.png" width="164"></p> 
</blockquote> 
<h4 id="2.5%20%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0">2.5 宏和函数</h4> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>宏的优点</strong></span></p> 
 <p><span style="color:#494949;">1. 执行简单的运算时，选择用宏而不是函数。</span></p> 
 <p>原因：</p> 
 <p>用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多，所以宏比函数在程序的规模和速度方面更胜一筹。</p> 
 <p>函数的参数必须声明为特定的类型，宏是类型无关的，所以函数只能在类型合适的表达式上使用。</p> 
 <p>2. 宏的参数可以出现类型，但是函数做不到。</p> 
 <pre><code class="language-cpp">#define MALLOC(num, type) (type*)malloc(num*sizeof(type))

MALLOC(10, int);
//预处理器替换之后：
(int*)malloc(10*sizeof(int));</code></pre> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>宏的缺点</strong></span></p> 
 <p>1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。</p> 
 <p>2. 宏是没法调试的。</p> 
 <p>3. 宏由于类型无关，也就不够严谨。</p> 
 <p>4. 宏可能会带来运算符优先级的问题，导致程容易出现错。</p> 
 <hr> 
 <span style="color:#4da8ee;"><strong>宏与函数对比</strong></span> 
 <p><img alt="" height="979" src="https://images2.imgbox.com/ff/03/eIuyXvwc_o.png" width="865"></p> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>命名约定</strong></span></p> 
 <p>1. 宏名全部大写</p> 
 <p>2. 函数名不要全部大写</p> 
</blockquote> 
<h4 id="2.6%20%23undef">2.6 #undef</h4> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>这条指令用于移除一个宏定义。</strong></span></p> 
 <p>如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。</p> 
 <p>例子：</p> 
 <p><img alt="" height="217" src="https://images2.imgbox.com/1a/1b/q87W3CnH_o.png" width="323"><img alt="" height="60" src="https://images2.imgbox.com/27/f3/EGXnioGt_o.png" width="272"></p> 
</blockquote> 
<h3 id="3.%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89">3. 命令行定义</h3> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>许多 C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。</strong></span></p> 
 <p>例子：</p> 
 <pre><code class="language-cpp"> #include &lt;stdio.h&gt;
 int main()
 {
     int array [ARRAY_SIZE];
     int i = 0;
     for(i = 0; i&lt; ARRAY_SIZE; i ++)
     {
         array[i] = i;
     }
     for(i = 0; i&lt; ARRAY_SIZE; i ++)
     {
         printf("%d " ,array[i]);
     }
     printf("\n");
     return 0;
 }</code></pre> 
 <p>编译指令：</p> 
 <pre><code class="language-cpp">gcc -D ARRAY_SIZE=10 programe.c</code></pre> 
</blockquote> 
<h3 id="4.%20%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91">4. 条件编译</h3> 
<blockquote> 
 <p>在编译一个程序的时候，条件编译指令可以将一条语句或一组语句进行编译或者放弃编译。</p> 
 <p><span style="color:#4da8ee;"><strong>常见的条件编译指令：</strong></span></p> 
 <p>1. 单分支的条件编译，常量表达式由预处理器求值。</p> 
 <pre><code class="language-cpp"> #if 常量表达式
    //...
 #endif
 
如：
#define __DEBUG__ 1

#if __DEBUG__
     //..
#endif</code></pre> 
 <p>2. 多分支的条件编译</p> 
 <pre><code class="language-cpp">#if 常量表达式
    //...
#elif 常量表达式
    //...
#else
    //...
#endif</code></pre> 
 <p>3. 判断是否被定义，各自有两种写法。</p> 
 <pre><code class="language-cpp">#if defined(symbol)
    //...
#endif

#ifdef symbol
    //...
#endif

#if !defined(symbol)
    //...
#endif

#ifndef symbol
    //...
#endif</code></pre> 
 <p>4. 嵌套指令</p> 
 <pre><code class="language-cpp">#if defined(OS_UNIX)
    #ifdef OPTION1
        unix_version_option1();
    #endif
    #ifdef OPTION2
        unix_version_option2();
    #endif
#elif defined(OS_MSDOS)
    #ifdef OPTION2
        msdos_version_option2();
    #endif
#endif</code></pre> 
</blockquote> 
<h3 id="5.%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB">5. 文件包含</h3> 
<h4 id="5.1%20%E4%B8%A4%E7%A7%8D%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB">5.1 两种头文件的包含</h4> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>本地文件包含</strong></span></p> 
 <pre><code class="language-cpp">#include "filename"</code></pre> 
 <p>查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件，如果找不到就提示编译错误。</p> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>库文件包含</strong></span></p> 
 <pre><code class="language-cpp">#include &lt;filename.h&gt;</code></pre> 
 <p>查找策略：查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。</p> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>题外话</strong></span></p> 
 <p>1. 其实库文件包含也能用双引号，但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。</p> 
 <p>2. #include 指令可以使另外一个文件被编译，就像它实际出现于一样。</p> 
 <p>这种替换的方式很简单：预处理器先删除这条指令，并用包含文件的内容替换。</p> 
 <p>这样一个源文件被包含10次，那就实际被编译10次。</p> 
</blockquote> 
<h4 id="5.2%C2%A0%E5%B5%8C%E5%A5%97%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB">5.2 嵌套文件包含</h4> 
<blockquote> 
 <p><img alt="" height="557" src="https://images2.imgbox.com/db/31/DMUy5sfa_o.png" width="936"></p> 
 <p>comm.h 和 comm.c 是公共模块。</p> 
 <p>test1.h 和 test1.c 使用了公共模块。</p> 
 <p>test2.h 和 test2.c 使用了公共模块。</p> 
 <p>test.h 和 test.c 使用了 test1 模块和 test2 模块。</p> 
 <p>这样最终程序中就会出现两份 comm.h 的内容，这样就造成了文件内容的重复。</p> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>解决办法有两种</strong></span></p> 
 <p>1. 条件编译</p> 
 <pre><code class="language-cpp">#ifndef __TEST_H__

#define __TEST_H__
... //头文件的内容

#endif   
</code></pre> 
 <p>2. 头文件开头写：</p> 
 <pre><code class="language-cpp">#pragma once</code></pre> 
 <p>这样就可以避免头文件的重复引入。</p> 
</blockquote> 
<p><a href="https://gitee.com/lin-yuheng123/code_c" rel="nofollow" title="林宇恒/code_c - 码云 - 开源中国 (gitee.com)">林宇恒/code_c - 码云 - 开源中国 (gitee.com)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7de7f48d33f974982ab775f5db7bf05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【CSDN平台BUG】markdown图片链接格式被手机端编辑器自动破坏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/933dedec218ede2ee5da2ae4cb6143fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">认真学习JVM中类加载过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>