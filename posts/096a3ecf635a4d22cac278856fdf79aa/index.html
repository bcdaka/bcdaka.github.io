<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【RabbitMQ 实战】10 消息持久化和存储原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/096a3ecf635a4d22cac278856fdf79aa/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【RabbitMQ 实战】10 消息持久化和存储原理">
  <meta property="og:description" content="一、持久化 1.1 持久化对象 rabbitmq的持久化分为三个部分：
交换器的持久化。队列的持久化。消息的持久化。 1.1.1 交换器持久化 交换器的持久化是通过在声明交换器时， 指定Durability参数为durable实现的。若交换器不设置持久化，在rabbitmq服务重启之后，相关的交换器元数据会丢失，但消息不会丢失，只是不能将消息发送到这个交换器中。
所以在声明交换器时，都要设置持久化。在web监控创建时，默认也是持久化模式，指定持久化模式带有标识“D”。
springboot监听器，实现交换器持久化示例
1.1.2 队列持久化 队列的持久化是通过在声明队列时， 指定Durability参数为durable实现的。若队列不设置持久化，在rabbitmq服务重启之后，相关队列的元数据和消息数据同时丢失。若队列设置持久化，只能保证队列本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将消息设置为持久化。在web监控创建时，默认也是持久化模式，指定持久化模式带有标识“D”。
springboot监听器，实现队列持久化示例
1.1.3 消息持久化 消息的持久化可以通过消息的投递模式来实现，属于代码层面上的。可以控制每一条消息是否久化。
但是将所有消息都设置为持久化，会严重影响rabbitmq服务器性能，写入磁盘的速度比写入内存的速度慢得不只一点点。所以对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。
springboot代码设置消息的持久化示例
1.2 总结要点 交换器、队列、消息都可以设置是否持久化。交换器和队列持久化的含义是元数据持久化。消息持久化的含义是消息本身持久化。 将交换器、队列、消息都设置了持久化之后能百分之百保证数据不丢失吗？答案是不能
从消费者来说，如果在订阅消费队列时将 autoAck 参数设置为 true，那么当消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。这种情况很好解决，将autoAck 参数设置为 false，并进行手动确认。在持久化的消息正确存入rabbitmq之后，还需要有一段时间(虽然很短，但是不可忽视) 才能存入磁盘之中。如果在这段时间内rabbitmq服务节点发生了宕机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。这种情况可以使用镜像队列来解决。 二、存储机制 前面提到的消息持久化，其实是在rabbitmq的“持久层”中完成的。不管是持久化的消息，还是非持久化的消息都可以被写入到磁盘。
持久化的消息在到达队列时就入盘，而且还可以设置持久化的消息在内存中也保存一份备份，这么做可以提高业务效率，当内存吃紧时会从内存中清除。非持久化的消息一般只保存在内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存空间。 2.1 存储方式 持久层是一个逻辑上的概念，实际包含两个部分：
队列索引 (rabbit_queue_index)：负责维护队列中落盘消息的信息，包括消息的存储地点、消息在队列中的位置、是否已被交付给消费者、是否已被消费者 ack 等。每个队列都有与之对应的一个队列索引。消息存储(rabbit_msg_store)：而消息存储是以键值对的形式存储消息，它被所有队列共享，所以在每个节点中有且只有一个。从技术层面上来说，rabbit_msg_store 具体还可以分两类： msg_store_persistent ：负责持久化消息的持久化，重启后消息不会丢失。msg_store_transient：负责非持久化消息的持久化，重启后消息会丢失。
我们一般说消息存储，是习惯性地将 msg_store_persistent 和 msg_store_transient 看成 rabbit_msg_store 一个整体。 I have no name!@ed73deb9f1c5:/bitnami/rabbitmq/mnesia/rabbit@stats/msg_stores/vhosts/9PIHRMVSJH6VBOR100H7141ZT$ ls -al drwxr-xr-x. 2 1001 root 19 Oct 7 02:57 msg_store_persistent drwxr-xr-x. 2 1001 root 19 Oct 7 02:57 msg_store_transient 存在队列索引里的好处？">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-10T10:32:43+08:00">
    <meta property="article:modified_time" content="2023-10-10T10:32:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【RabbitMQ 实战】10 消息持久化和存储原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>一、持久化</h2> 
<h3><a id="11__2"></a>1.1 持久化对象</h3> 
<p>rabbitmq的持久化分为三个部分：</p> 
<ul><li>交换器的持久化。</li><li>队列的持久化。</li><li>消息的持久化。</li></ul> 
<h4><a id="111__7"></a>1.1.1 交换器持久化</h4> 
<ul><li>交换器的持久化是通过在声明交换器时， 指定Durability参数为durable实现的。</li><li>若交换器不设置持久化，在rabbitmq服务重启之后，相关的交换器元数据会丢失，但消息不会丢失，只是不能将消息发送到这个交换器中。<br> 所以在声明交换器时，都要设置持久化。</li><li>在web监控创建时，默认也是持久化模式，指定持久化模式带有标识“D”。<br> <img src="https://images2.imgbox.com/d4/05/6KyysnEA_o.png" alt="在这里插入图片描述"><br> springboot监听器，实现交换器持久化示例<br> <img src="https://images2.imgbox.com/24/1c/pTcx40Nn_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="112__15"></a>1.1.2 队列持久化</h4> 
<ul><li>队列的持久化是通过在声明队列时， 指定Durability参数为durable实现的。</li><li>若队列不设置持久化，在rabbitmq服务重启之后，相关队列的元数据和消息数据同时丢失。</li><li>若队列设置持久化，只能保证队列本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。<strong>要确保消息不会丢失，需要将消息设置为持久化</strong>。</li><li>在web监控创建时，默认也是持久化模式，指定持久化模式带有标识“D”。<br> <img src="https://images2.imgbox.com/71/18/GqP1H8wG_o.png" alt="在这里插入图片描述"><br> springboot监听器，实现队列持久化示例<br> <img src="https://images2.imgbox.com/08/62/7gsaHXSN_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="113__23"></a>1.1.3 消息持久化</h4> 
<p>消息的持久化可以通过消息的投递模式来实现，属于代码层面上的。可以控制每一条消息是否久化。<br> 但是将所有消息都设置为持久化，会严重影响rabbitmq服务器性能，写入磁盘的速度比写入内存的速度慢得不只一点点。所以对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。<br> <img src="https://images2.imgbox.com/8d/94/xEzbz3xC_o.png" alt="在这里插入图片描述"><br> springboot代码设置消息的持久化示例<br> <img src="https://images2.imgbox.com/e4/7b/ju8uXRm2_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12__29"></a>1.2 总结要点</h3> 
<ul><li>交换器、队列、消息都可以设置是否持久化。交换器和队列持久化的含义是元数据持久化。消息持久化的含义是消息本身持久化。</li></ul> 
<p>将交换器、队列、消息都设置了持久化之后能百分之百保证数据不丢失吗？答案是不能</p> 
<ul><li>从消费者来说，如果在订阅消费队列时将 autoAck 参数设置为 true，那么当消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。这种情况很好解决，将autoAck 参数设置为 false，并进行手动确认。</li><li>在持久化的消息正确存入rabbitmq之后，还需要有一段时间(虽然很短，但是不可忽视) 才能存入磁盘之中。如果在这段时间内rabbitmq服务节点发生了宕机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。这种情况可以使用<strong>镜像队列</strong>来解决。</li></ul> 
<h2><a id="_35"></a>二、存储机制</h2> 
<p>前面提到的消息持久化，其实是在rabbitmq的“持久层”中完成的。不管是持久化的消息，还是非持久化的消息都可以被写入到磁盘。</p> 
<ul><li>持久化的消息在到达队列时就入盘，而且还可以设置持久化的消息在内存中也保存一份备份，这么做可以提高业务效率，当内存吃紧时会从内存中清除。</li><li>非持久化的消息一般只保存在内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存空间。</li></ul> 
<h3><a id="21__39"></a>2.1 存储方式</h3> 
<p>持久层是一个逻辑上的概念，实际包含两个部分：</p> 
<ul><li>队列索引 (rabbit_queue_index)：负责维护队列中落盘消息的信息，包括消息的存储地点、消息在队列中的位置、是否已被交付给消费者、是否已被消费者 ack 等。每个队列都有与之对应的一个队列索引。</li><li>消息存储(rabbit_msg_store)：而消息存储是以键值对的形式存储消息，它被所有队列共享，所以在每个节点中有且只有一个。从技术层面上来说，rabbit_msg_store 具体还可以分两类： 
  <ul><li>msg_store_persistent ：负责持久化消息的持久化，重启后消息不会丢失。</li><li>msg_store_transient：负责非持久化消息的持久化，重启后消息会丢失。<br> 我们一般说消息存储，是习惯性地将 msg_store_persistent 和 msg_store_transient 看成 rabbit_msg_store 一个整体。</li></ul> </li></ul> 
<pre><code class="prism language-bash">I have no name<span class="token operator">!</span>@ed73deb9f1c5:/bitnami/rabbitmq/mnesia/rabbit@stats/msg_stores/vhosts/9PIHRMVSJH6VBOR100H7141ZT$ <span class="token function">ls</span> <span class="token parameter variable">-al</span>
drwxr-xr-x. <span class="token number">2</span> <span class="token number">1001</span> root   <span class="token number">19</span> Oct  <span class="token number">7</span> 02:57 msg_store_persistent
drwxr-xr-x. <span class="token number">2</span> <span class="token number">1001</span> root   <span class="token number">19</span> Oct  <span class="token number">7</span> 02:57 msg_store_transient
</code></pre> 
<ul><li>存在队列索引里的好处？<br> 性能上的优化。相比存在消息存储里，直接存在队列索引仅需进行一次写操作。而存储在消息存储中的消息则需要两次写操，先写一次索引，再写一次消息存储，因此会有一定的性能提升。<br> 注意事项：</li><li>若消息直接存在队列索引中，则当消息通过exchange同时路由到多个队列时，此消息会被写到每个队列的索引文件中。</li><li>若消息是存在消息存储中，就仅仅只有一个副本。</li></ul> 
<h3><a id="22__60"></a>2.2 存储文件</h3> 
<ul><li>上面提到的消息，是包括<strong>消息体</strong>、<strong>属性</strong>和 <strong>headers</strong>，可以直接存储在队列索引中，也可以保存在消息存储中。</li><li>rabbitmq启动后，会针对每个vhost会启动两个进程：msg_store_persistent和msg_store_transient，这两个进程作为服务端负责将消息写入文件，从文件读取消息。 
  <ul><li>msg_store_persistent负责将<strong>持久化消息</strong>写入文件与从文件中读取消息。</li><li>msg_store_transient负责<strong>非持久化消息</strong>写入文件与从文件中读取消息。</li></ul> </li><li>默认存储文件位置：通过日志可以看到存储文件地址，包含queues、msg_store_persistent、msg_store_transient 这3个文件夹。如下图，我这里是指定了存储文件地址。</li></ul> 
<pre><code class="prism language-bash">I have no name<span class="token operator">!</span>@ed73deb9f1c5:/bitnami/rabbitmq/mnesia/rabbit@stats/msg_stores/vhosts/9PIHRMVSJH6VBOR100H7141ZT$ <span class="token function">ls</span> <span class="token parameter variable">-al</span>
total <span class="token number">16</span>
drwxr-xr-x. <span class="token number">5</span> <span class="token number">1001</span> root  <span class="token number">125</span> Oct  <span class="token number">7</span> 02:57 <span class="token builtin class-name">.</span>
drwxr-xr-x. <span class="token number">4</span> <span class="token number">1001</span> root   <span class="token number">72</span> Oct  <span class="token number">7</span> 01:15 <span class="token punctuation">..</span>
-rw-r--r--. <span class="token number">1</span> <span class="token number">1001</span> root   <span class="token number">83</span> Oct  <span class="token number">7</span> 01:15 .config
drwxr-xr-x. <span class="token number">2</span> <span class="token number">1001</span> root   <span class="token number">19</span> Oct  <span class="token number">7</span> 02:57 msg_store_persistent
drwxr-xr-x. <span class="token number">2</span> <span class="token number">1001</span> root   <span class="token number">19</span> Oct  <span class="token number">7</span> 02:57 msg_store_transient
drwxr-xr-x. <span class="token number">3</span> <span class="token number">1001</span> root   <span class="token number">38</span> Oct  <span class="token number">7</span> 01:18 queues
-rw-r--r--. <span class="token number">1</span> <span class="token number">1001</span> root <span class="token number">5464</span> Oct  <span class="token number">7</span> 02:57 recovery.dets
-rw-r--r--. <span class="token number">1</span> <span class="token number">1001</span> root    <span class="token number">9</span> Oct  <span class="token number">7</span> 02:57 .vhost
</code></pre> 
<p>上面的地址/bitnami/rabbitmq/mnesia/rabbit@stats，是队列的数据存放目录，这个在在哪里找呢，可以通过日志来查看，如下图所示：<br> <img src="https://images2.imgbox.com/02/6f/hjaAK3Oh_o.png" alt="在这里插入图片描述"><br> 日志中还显示了，9PIHRMVSJH6VBOR100H7141ZT这个目录，对应着virtual01这个vhost的目录。对于rabbitmq来说，每一个租户vhost的消息存储，都是放在不同的目录的<br> <img src="https://images2.imgbox.com/a2/2e/kTo24kye_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="221_idx_83"></a>2.2.1 队列索引.idx文件</h4> 
<p>rabbit_queue_index 中以顺序(文件名从 0 开始累加) 的段文件来进行存储，后缀为“ .idx "。</p> 
<p>每个段文件中包含定的 SEGMENT_ENTRY_COUNT 条记录，SEGMENT_ENTRY_COUNT 默认值为16384字节。<br> 每个rabbit_queue_index 从磁盘中读取消息的时候至少要在内存中维护一个段文件，所以设置queue_index_embed_msgs_below参数指定阈值大小时要格外谨慎，一点点增大也可能会引起内存爆炸式的增长。</p> 
<h4><a id="222_rdq_88"></a>2.2.2 消息存储.rdq文件</h4> 
<p>经过 rabbit_msg_store 处理的所有消息都会以追加的方式写入到文件中，当一个文件的大小超过指定的限制 (file_size_lmit)后，关闭这个文件再创建一个新的文件以供新的消息写入，文件后缀是“ .rdq ”。<br> 文件名从0开始进行累加，所以文件名最小的文件也是最老的文件。<br> 如下所示0.rdq文件</p> 
<pre><code class="prism language-bash">I have no name<span class="token operator">!</span>@ed73deb9f1c5:/bitnami/rabbitmq/mnesia/rabbit@stats/msg_stores/vhosts/628WB79CIFDYO9LJI6DKMI09L/msg_store_persistent$ <span class="token function">ls</span> <span class="token parameter variable">-al</span>
total <span class="token number">0</span>
drwxr-xr-x. <span class="token number">2</span> <span class="token number">1001</span> root  <span class="token number">19</span> Oct  <span class="token number">7</span> 02:57 <span class="token builtin class-name">.</span>
drwxr-xr-x. <span class="token number">4</span> <span class="token number">1001</span> root <span class="token number">111</span> Oct  <span class="token number">7</span> 02:57 <span class="token punctuation">..</span>
-rw-r--r--. <span class="token number">1</span> <span class="token number">1001</span> root   <span class="token number">0</span> Oct  <span class="token number">7</span> 02:57 <span class="token number">0</span>.rdq
</code></pre> 
<p>在进行消息的存储时，rabbitmq会在ETS (Erlang Term Storage) 表中记录消息在文件中的位置映射 (Index) 和文件的相关信息 (FileSummary)。</p> 
<ul><li>读取文件信息： 
  <ul><li>在读取消息的时候，先根据消息的 ID (msg_id)找到对应存储的文件。</li><li>若文件存在并且未被锁住，则直接打开文件，从指定位置读取消息的内容。</li><li>若文件不存在，或被锁住，则发送请求由 rabbit_msg_store 进行处理。</li></ul> </li><li>删除文件信息：</li><li>消息的删除只是从 ETS 表删除指定消息的相关信息，同时更新消息对应的存储文件的相关信息。</li><li>执行消息删除操作时，不会立即对在文件中的消息进行删除，先是标记为垃圾数据。 
  <ul><li>若一个文件中都是垃圾数据时，则删除文件。</li><li>若一个文件中存在有效数据，则触发垃圾回收机制，进行文件合并选择性删除。</li></ul> </li><li>垃圾回收文件合并机制： 
  <ul><li>当检测到前后两个文件中的有效数据可以合并在一个文件中，并且所有的垃圾数据的大小和所有文件(至少有3 个文件存在的情况下)的数据大小的比值超过设置的值 GARBAGE_ERACTION (默认值为 0.5) 时，才会触发垃圾回收将两个文件合并。</li></ul> </li></ul> 
<h4><a id="223__111"></a>2.2.3 垃圾回收机制（文件合并）</h4> 
<p>文件合并前提：<br> 执行合并的两个文件一定是逻辑上相邻的两个文件。<br> 文件合并流程：</p> 
<ul><li>第一步，执行合并时首先锁定这两个文件。</li><li>第二步，先对前面文件中的有效数据进行整理。</li><li>第三步，再将后面文件的有效数据写入到前面的文件。</li><li>第四步，更新消息在 ETS 表中的记录。</li><li>第五步，最后删除后面的文件。</li></ul> 
<h3><a id="23__122"></a>2.3 存储原理</h3> 
<ul><li>从3.5.0版本开始，较小的消息是直接存储在队列索引.rdx中。</li><li>较大的消息存在.rdq队列文件中</li></ul> 
<p>如下图所示，我发布的消息，消息比较小时，在0.idx中，即存在索引中<br> 下面是通过查看0.idx，发现里面有消息的正文内容<br> <img src="https://images2.imgbox.com/41/49/6ukEcqBH_o.png" alt="在这里插入图片描述"><br> 当消息体比较大时，存放的是rdq文件时面<br> <img src="https://images2.imgbox.com/9e/93/L1WC0uvC_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在进行消息的存储时，rabbitmq会在ETS表中记录消息在文件中的映射，以及文件的相关信息。</li><li>消息读取时，根据消息ID找到该消息所存储的文件，在文件中的偏移量，然后打开文件进行读取。</li><li>消息的删除只是从ETC表删除指定消息的相关信息，同时更新消息对应存储的文件的相关信息（更新文件有效数据大小）。</li></ul> 
<h4><a id="231__135"></a>2.3.1 生产者消息写入原理</h4> 
<p>每个队列则看成是一个客户端，当生产者发送的消息达到队列时，向服务端请求写，写入过程如下：</p> 
<ul><li>第一步，rabbitmq启动后，针对每个vhost开启两个进程，msg_store_persistent进程和msg_store_transient进程。两进程作为服务端，每个队列作为客户端。</li><li>第二步，当生产者发送消息到队列时，每个队列都会向两进程发起写入请求。</li><li>第三步，两进程开始往磁盘里写入消息。 
  <ul><li>msg_store_persistent进程将持久化消息写入到服务器的msg_store_persistent目录下，文件名称依次为0.rdq、1.rdq、2.rdq等等。</li><li>msg_store_transient进程将非持久化消息写入到服务器的msg_store_transient目录下，文件名称依次为0.rdq、1.rdq、2.rdq等等。<br> <img src="https://images2.imgbox.com/d6/f2/ROawxCrs_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h4><a id="232__144"></a>2.3.2 消费者消息读取原理</h4> 
<ul><li>第一步，消费者向队列获取消息体。</li><li>第二步，队列汇聚消息ID去找落盘文件。 
  <ul><li>若文件存在，且未被锁住，则直接读取文件内容，返回消息给消费者。</li><li>若文件不存在，或已被锁住，则让rabbit_msg_store进程处理。</li></ul> </li><li>第三步，队列向两进程发起请求，进程先是通过GC进程去查看文件是否被锁住，同时也会清理垃圾，进行有效数据合并。 
  <ul><li>若被锁住则解锁，获取消息，返回给消费者。</li><li>若清理垃圾后，发现还是没有此消息，则向rabbitmq其他节点发送询问请求。</li></ul> </li><li>第四步，其他节点会根据消息ID挨个寻找，直至将rabbitmq集群每个节点找遍，之后返回结果给消费者。</li></ul> 
<p><img src="https://images2.imgbox.com/89/50/e06DF6FT_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df5d99effe6efa40a45cf60eddcfbb35/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">邻域搜索（Neighborhood Search ，NS）、大邻域搜索(Large NS , LNS)和自适应大邻域搜索（Adaptive LNS, ALNS）算法的联系与区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee74ef7b3b9e70bad402d55a0fa78869/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 读取 通达信 数据 pytdx</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>