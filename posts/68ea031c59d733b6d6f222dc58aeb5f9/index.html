<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法练习题17——leetcode54螺旋矩阵 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/68ea031c59d733b6d6f222dc58aeb5f9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法练习题17——leetcode54螺旋矩阵">
  <meta property="og:description" content="题目描述 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
代码 import java.util.*; class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { // 用于存储螺旋顺序遍历的结果 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); // 如果矩阵为空，直接返回空的结果列表 if (matrix == null || matrix.length == 0) return result; // 获取矩阵的行数 m 和列数 n int m = matrix.length; // 行数 int n = matrix[0].length; // 列数 // 初始化四个边界，用于控制螺旋遍历的范围 int top = 0; // 上边界 int bottom = m - 1; // 下边界 int left = 0; // 左边界 int right = n - 1; // 右边界 // 当上、下、左、右边界没有相互交错时，继续遍历 while (top &lt;= bottom &amp;&amp; left &lt;= right) { // 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-07T16:57:45+08:00">
    <meta property="article:modified_time" content="2024-09-07T16:57:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法练习题17——leetcode54螺旋矩阵</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>题目描述</h2> 
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p> 
<p><img alt="" height="861" src="https://images2.imgbox.com/e1/16/EhNScxHY_o.png" width="957"></p> 
<h2> 代码</h2> 
<pre><code class="hljs">import java.util.*;

class Solution {
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
        // 用于存储螺旋顺序遍历的结果
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        
        // 如果矩阵为空，直接返回空的结果列表
        if (matrix == null || matrix.length == 0) return result;

        // 获取矩阵的行数 m 和列数 n
        int m = matrix.length;      // 行数
        int n = matrix[0].length;   // 列数
        
        // 初始化四个边界，用于控制螺旋遍历的范围
        int top = 0;                // 上边界
        int bottom = m - 1;         // 下边界
        int left = 0;               // 左边界
        int right = n - 1;          // 右边界
        
        // 当上、下、左、右边界没有相互交错时，继续遍历
        while (top &lt;= bottom &amp;&amp; left &lt;= right) {
            // 1. 从左到右遍历当前的上边界
            for (int i = left; i &lt;= right; i++) {
                result.add(matrix[top][i]);  // 添加当前上边界的元素
            }
            top++;  // 上边界向下收缩一行，表示这一行已经处理完

            // 2. 从上到下遍历当前的右边界
            for (int i = top; i &lt;= bottom; i++) {
                result.add(matrix[i][right]);  // 添加当前右边界的元素
            }
            right--;  // 右边界向左收缩一列，表示这一列已经处理完

            // 3. 从右到左遍历当前的下边界（仅当 top &lt;= bottom 时）
            //    这里很重要！因为我们已经处理了上边界并将其收缩，
            //    所以在遍历下边界之前，需要确认是否还有剩余的行待遍历。
            if (top &lt;= bottom) {
                for (int i = right; i &gt;= left; i--) {
                    result.add(matrix[bottom][i]);  // 添加当前下边界的元素
                }
                bottom--;  // 下边界向上收缩一行，表示这一行已经处理完
            }

            // 4. 从下到上遍历当前的左边界（仅当 left &lt;= right 时）
            //    这里同样很重要！因为我们已经处理了右边界并将其收缩，
            //    所以在遍历左边界之前，需要确认是否还有剩余的列待遍历。
            if (left &lt;= right) {
                for (int i = bottom; i &gt;= top; i--) {
                    result.add(matrix[i][left]);  // 添加当前左边界的元素
                }
                left++;  // 左边界向右收缩一列，表示这一列已经处理完
            }
        }
        
        // 返回螺旋顺序遍历的结果列表
        return result;
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/87e92db61d788e171e24e5f96f8de241/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Qt】qt发布Release版本,打包.exe可执行文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b5d8798c736882a528dcd5ddbe84ec8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法【Java】 —— 前缀和</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>