<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】—— 线程控制的基本介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b66c3f2950eef09a0f37965cc3a183d3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Linux】—— 线程控制的基本介绍">
  <meta property="og:description" content="目录
（一）POSIX线程库
（二）创建线程
2.1 线程ID及进程地址空间布局
（三）线程终止
（四）分离线程
（一）POSIX线程库 POSIX线程库（POSIX Threads Library），通常简称为Pthreads，是一个为POSIX操作系统（包括UNIX和类UNIX系统如Linux）提供线程支持的库。Pthreads定义了一组API，允许程序员创建、管理、同步和销毁线程。 与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以“pthread_”打头的 要使用这些函数库，要通过引入头文&lt;pthread.h&gt; 链接这些线程函数库时要使用编译器命令的“-lpthread”选项 （二）创建线程 【函数介绍】 功能：创建一个新的线程 原型 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void * (*start_routine)(void*), void *arg); 参数 thread:返回线程ID attr:设置线程的属性，attr为NULL表示使用默认属性 start_routine:是个函数地址，线程启动后要执行的函数 arg:传给线程启动函数的参数 返回值：成功返回0；失败返回错误码 错误检查：
对于Pthreads函数，如果调用失败，通常会返回一个非零的错误代码，你可以使用这个错误代码来查询具体是什么错误发生了。为了将错误代码映射到人类可读的错误消息，你可以使用strerror或pthread_strerror函数（如果可用）。
另外，Pthreads库确实为每个线程提供了一个私有的errno变量，这允许线程安全地访问errno。然而，对于Pthreads函数本身来说，直接检查返回值通常是更好的做法，因为这样可以避免任何可能的线程间干扰，并且通常更加高效。
【代码示例】 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; using namespace std; int g_val = 0; void *threadRun1(void *args) { while (true) { sleep(1); cout &lt;&lt; &#34;t1 thread...&#34; &lt;&lt; getpid() &lt;&lt; &#34; &amp;g_val: &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-07T10:06:24+08:00">
    <meta property="article:modified_time" content="2024-06-07T10:06:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】—— 线程控制的基本介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93" rel="nofollow">（一）POSIX线程库</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B" rel="nofollow">（二）创建线程</a></p> 
<p id="2.1%C2%A0%E7%BA%BF%E7%A8%8BID%E5%8F%8A%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%E7%BA%BF%E7%A8%8BID%E5%8F%8A%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80" rel="nofollow">2.1 线程ID及进程地址空间布局</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2" rel="nofollow">（三）线程终止</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B" rel="nofollow">（四）分离线程</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%EF%BC%88%E4%B8%80%EF%BC%89POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93">（一）<span style="color:#333333;">POSIX</span><span style="color:#333333;">线程库 </span></h2> 
<blockquote> 
 <p>POSIX线程库（POSIX Threads Library），通常简称为Pthreads，是一个为POSIX操作系统（包括UNIX和类UNIX系统如Linux）提供线程支持的库。Pthreads定义了一组API，允许程序员创建、管理、同步和销毁线程。 </p> 
</blockquote> 
<ul><li><span style="color:#777777;">与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以</span><span style="color:#777777;">“pthread_”</span><span style="color:#777777;">打头的 </span></li><li><span style="color:#777777;">要使用这些函数库，要通过引入头文</span><span style="color:#777777;">&lt;pthread.h&gt; </span></li><li><span style="color:#777777;">链接这些线程函数库时要使用编译器命令的</span><span style="color:#777777;">“-lpthread”</span><span style="color:#777777;">选项</span></li></ul> 
<hr> 
<h2 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">（二）<span style="color:#333333;">创建线程</span></h2> 
<p><strong>【函数介绍】 </strong></p> 
<pre><code class="language-cpp">功能：创建一个新的线程

原型
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                    void * (*start_routine)(void*), void *arg);

参数
    thread:返回线程ID
    attr:设置线程的属性，attr为NULL表示使用默认属性
    start_routine:是个函数地址，线程启动后要执行的函数
    arg:传给线程启动函数的参数

返回值：成功返回0；失败返回错误码</code></pre> 
<p><span style="color:#333333;">错误检查</span>：</p> 
<ol><li> <p><strong>对于Pthreads函数，如果调用失败，通常会返回一个非零的错误代码，你可以使用这个错误代码来查询具体是什么错误发生了。为了将错误代码映射到人类可读的错误消息，你可以使用<code>strerror</code>或<code>pthread_strerror</code>函数（如果可用）。</strong></p> </li><li> <p></p> <p><strong>另外，Pthreads库确实为每个线程提供了一个私有的<span style="color:#777777;">errno</span>变量，这允许线程安全地访问<span style="color:#777777;">errno</span>。然而，对于Pthreads函数本身来说，直接检查返回值通常是更好的做法，因为这样可以避免任何可能的线程间干扰，并且通常更加高效。</strong></p> </li></ol> 
<p> <strong>【代码示例】 </strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

using namespace std;

int g_val = 0; 

void *threadRun1(void *args)
{
    while (true)
    {
        sleep(1);
        cout &lt;&lt; "t1 thread..." &lt;&lt; getpid() &lt;&lt; " &amp;g_val: " &lt;&lt; &amp;g_val &lt;&lt; " , g_val: " &lt;&lt; g_val &lt;&lt; endl;
    }
}

void *threadRun2(void *args)
{
    while (true)
    {
        sleep(1);
        cout &lt;&lt; "t2 thread..." &lt;&lt; getpid()  &lt;&lt; " &amp;g_val: " &lt;&lt; &amp;g_val &lt;&lt; " , g_val: " &lt;&lt; g_val++ &lt;&lt; endl;
    }
}

int main()
{
    pthread_t t1, t2;

    pthread_create(&amp;t1, nullptr, threadRun1, nullptr);
    pthread_create(&amp;t1, nullptr, threadRun2, nullptr);

    while (true)
    {
        sleep(1);
        cout &lt;&lt; "main thread..." &lt;&lt; getpid()  &lt;&lt; " &amp;g_val: " &lt;&lt; &amp;g_val &lt;&lt; " , g_val: " &lt;&lt; g_val &lt;&lt; endl;
    }
}</code></pre> 
<hr> 
<h3 id="2.1%C2%A0%E7%BA%BF%E7%A8%8BID%E5%8F%8A%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80">2.1 <span style="color:#333333;">线程</span><span style="color:#333333;">ID</span><span style="color:#333333;">及进程地址空间布局 </span></h3> 
<ol><li><span style="color:#777777;">pthread_ create</span><span style="color:#777777;">函数会产生一个线程</span><span style="color:#777777;">ID</span><span style="color:#777777;">，存放在第一个参数指向的地址中。该线程</span><span style="color:#777777;">ID</span><span style="color:#777777;">和前面说的线程</span><span style="color:#777777;">ID不是一回事。 </span></li><li><span style="color:#777777;">前面讲的线程</span><span style="color:#777777;">ID</span><span style="color:#777777;">属于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。 </span></li><li><span style="color:#777777;">pthread_ create</span><span style="color:#777777;">函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程</span><span style="color:#777777;">ID</span><span style="color:#777777;">，属于NPTL</span><span style="color:#777777;">线程库的范畴。线程库的后续操作，就是根据该线程</span><span style="color:#777777;">ID</span><span style="color:#777777;">来操作线程的。 </span></li><li><span style="color:#777777;">线程库</span><span style="color:#777777;">NPTL</span><span style="color:#777777;">提供了</span><strong><span style="color:#777777;">pthread_ self</span></strong><span style="color:#777777;">函数，可以获得线程自身的</span><span style="color:#777777;">ID</span><span style="color:#777777;">：</span></li></ol> 
<p><strong>【函数介绍】 </strong></p> 
<pre><code class="language-cpp">pthread_t pthread_self(void);</code></pre> 
<p><span style="color:#333333;">错误检查</span>：</p> 
<ul><li>如果成功，<code>pthread_self</code> 返回调用线程的线程 ID。如果发生错误，这个函数没有定义错误码返回机制，因为它总是应该成功。</li></ul> 
<p>  <strong>【代码示例】 </strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;pthread.h&gt;  
#include &lt;unistd.h&gt;

using namespace std;

void* threadRun(void* arg) {  
    pthread_t id = pthread_self(); // 获取当前线程的 ID  
    cout &lt;&lt; "the thread ID is :  " &lt;&lt; id &lt;&lt; endl;  
  
    sleep(1);  
  
    return nullptr;  
}  
  
int main() {  
    pthread_t tid;  
    int ret;  
  
    // 创建线程  
    ret = pthread_create(&amp;tid, nullptr, threadRun, nullptr);  
    if (ret != 0) {  
        cerr &lt;&lt; "Error: pthread_create() failed with error " &lt;&lt; ret &lt;&lt; endl;  
        return 1;  
    }  
  
    // 等待线程完成  
    pthread_join(tid, nullptr);  
  
    cout &lt;&lt; "Main thread exiting." &lt;&lt; endl;  
    return 0;  
}</code></pre> 
<hr> 
<p> <span style="color:#333333;">pthread_t 到底是什么类型呢？取决于实现。对于</span><span style="color:#333333;">Linux</span><span style="color:#333333;">目前实现的</span><span style="color:#333333;">NPTL</span><span style="color:#333333;">实现而言，</span><span style="color:#333333;">pthread_t</span><span style="color:#333333;">类型的线程</span><span style="color:#333333;">ID</span><span style="color:#333333;">，本质<strong>就是一个进程地址空间上的一个地址</strong>。 </span></p> 
<p class="img-center"><img alt="" height="687" src="https://images2.imgbox.com/04/27/3La9wVsM_o.png" width="973"></p> 
<hr> 
<h2 id="%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2">（三）线程终止</h2> 
<div> 
 <span style="color:#333333;">如果需要只终止某个线程而不终止整个进程</span> 
 <span style="color:#333333;">,</span> 
 <span style="color:#333333;">可以有三种方法</span> 
 <span style="color:#333333;">: </span> 
</div> 
<ul><li><strong><span style="color:#777777;">1. </span><span style="color:#777777;">从线程函数</span><span style="color:#777777;">return</span><span style="color:#777777;">。这种方法对主线程不适用</span><span style="color:#777777;">,</span><span style="color:#777777;">从</span><span style="color:#777777;">main</span><span style="color:#777777;">函数</span><span style="color:#777777;">return</span><span style="color:#777777;">相当于调用</span><span style="color:#777777;">exit</span><span style="color:#777777;">。 </span></strong></li></ul> 
<pre><code class="language-cpp">#define NUM 10

void *threadrun(void *args)
{
    char *name = (char*)args;
    while (true)
    {
        cout &lt;&lt; "new thread run, the new thread name is : " &lt;&lt; name   &lt;&lt; endl;
        sleep(3);
        break;
    }
    delete name;
    return  nullptr;
}

int main()
{
    pthread_t tids[NUM];
    for(int i= 0; i&lt; NUM; ++i){
        char *tname = new char[64];
        snprintf(tname,64,"thread-%d",i+1);
        pthread_create(tids+i,nullptr,threadrun,tname);
    }

    void *ret = nullptr;
    for(int i= 0; i&lt; NUM; ++i){
        int n = pthread_join(tids[i],nullptr);
        if(n != 0) cerr &lt;&lt; "pthread_join error" &lt;&lt; endl;

        cout &lt;&lt; "thread quit: " &lt;&lt;(uint64_t)ret &lt;&lt; endl;
    }
    cout &lt;&lt; "all thread quit..."&lt;&lt;endl; 

    return 0;
}</code></pre> 
<ul><li><strong><span style="color:#777777;">2. </span><span style="color:#777777;">线程可以调用pthread_ exit终止自己。 </span></strong></li></ul> 
<p><strong>【函数介绍】 </strong></p> 
<pre><code class="language-cpp">功能：线程终止
原型
    void pthread_exit(void *value_ptr);
参数
    value_ptr:value_ptr不要指向一个局部变量。

返回值：无返回值，跟进程一样，线程结束的时候无法返回到它的调用者（自身）</code></pre> 
<ul><li><span style="color:#333333;">需要注意</span><span style="color:#333333;">,pthread_exit</span><span style="color:#333333;">或者</span><span style="color:#333333;">return</span><span style="color:#333333;">返回的指针所指向的内存单元必须是全局的或者是用</span><span style="color:#333333;">malloc</span><span style="color:#333333;">分配的</span><span style="color:#333333;">,</span><span style="color:#333333;">不能在线程函数的栈上分配,</span><span style="color:#333333;">因为当其它线程得到这个返回指针时线程函数已经退出了。 </span></li></ul> 
<p> <strong>【代码示例】 </strong></p> 
<pre><code class="language-cpp">#define NUM 10

void *threadrun(void *args)
{
    char *name = (char*)args;
    while (true)
    {
        cout &lt;&lt; "new thread run, the new thread name is : " &lt;&lt; name   &lt;&lt; endl;
        sleep(3);
        break;
    }
    delete name;
    pthread_exit((void*)1); 
}

int main()
{
    pthread_t tids[NUM];
    for(int i= 0; i&lt; NUM; ++i){
        char *tname = new char[64];
        snprintf(tname,64,"thread-%d",i+1);
        pthread_create(tids+i,nullptr,threadrun,tname);
    }

    void *ret = nullptr;
    for(int i= 0; i&lt; NUM; ++i){
        int n = pthread_join(tids[i],nullptr);
        if(n != 0) cerr &lt;&lt; "pthread_join error" &lt;&lt; endl;

        cout &lt;&lt; "thread quit: " &lt;&lt;(uint64_t)ret &lt;&lt; endl;
    }
    cout &lt;&lt; "all thread quit..."&lt;&lt;endl; 

    return 0;
}</code></pre> 
<ul><li><strong><span style="color:#777777;">3. </span><span style="color:#777777;">一个线程可以调用</span><span style="color:#777777;">pthread_ cancel</span><span style="color:#777777;">终止同一进程中的另一个线程。 </span></strong></li></ul> 
<p><strong>【函数介绍】 </strong></p> 
<pre><code class="language-cpp">功能：取消一个执行中的线程
原型
    int pthread_cancel(pthread_t thread);
参数
    thread:线程ID

返回值：成功返回0；失败返回错误码</code></pre> 
<p>  <strong>【代码示例】 </strong></p> 
<pre><code class="language-cpp">void *threadRun(void* args)
{
    const char*name = static_cast&lt;const char *&gt;(args);

    int cnt = 5;
    while(cnt)
    {
        cout &lt;&lt; name &lt;&lt; " is running: " &lt;&lt; cnt-- &lt;&lt; " obtain self id: " &lt;&lt; pthread_self() &lt;&lt; endl;
        sleep(1);
    }

    pthread_exit((void*)11); 

    // PTHREAD_CANCELED; #define PTHREAD_CANCELED ((void *) -1)
}

int main()
{
    pthread_t tid;
    pthread_create(&amp;tid, nullptr, threadRun, (void*)"thread 1");
    sleep(3);

    pthread_cancel(tid);

    void *ret = nullptr;
    pthread_join(tid, &amp;ret);
    cout &lt;&lt; " new thread exit : " &lt;&lt; (int64_t)ret &lt;&lt; "quit thread: " &lt;&lt; tid &lt;&lt; endl;
    return 0;
}</code></pre> 
<p><strong>【输出结果】（三秒后取消操作）</strong></p> 
<p class="img-center"><img alt="" height="161" src="https://images2.imgbox.com/40/2d/0Qywtphb_o.png" width="787"></p> 
<hr> 
<blockquote> 
 <p><span style="color:#333333;">其次就是在上述代码中，使用了线程等待函数，那为什么需要线程等待？ </span> </p> 
</blockquote> 
<ul><li><span style="color:#777777;">已经退出的线程，其空间没有被释放，仍然在进程的地址空间内。 </span></li><li><span style="color:#777777;">创建新的线程不会复用刚才退出线程的地址空间。 </span></li></ul> 
<p> <strong>【函数介绍】</strong></p> 
<pre><code class="language-cpp">功能：等待线程结束

原型
    int pthread_join(pthread_t thread, void **value_ptr);

参数
thread:线程ID
value_ptr:它指向一个指针，后者指向线程的返回值

返回值：成功返回0；失败返回错误码</code></pre> 
<div> 
 <span style="color:#333333;">调用该函数的线程将挂起等待</span> 
 <span style="color:#333333;">,</span> 
 <span style="color:#333333;">直到</span> 
 <span style="color:#333333;">id</span> 
 <span style="color:#333333;">为</span> 
 <span style="color:#333333;">thread</span> 
 <span style="color:#333333;">的线程终止。</span> 
 <span style="color:#333333;">thread</span> 
 <span style="color:#333333;">线程以不同的方法终止</span> 
 <span style="color:#333333;">,</span> 
 <span style="color:#333333;">通过</span> 
 <span style="color:#333333;">pthread_join</span> 
 <span style="color:#333333;">得到的终止状态是不同的，总结如下: </span> 
</div> 
<ul><li><span style="color:#777777;">1. </span><span style="color:#777777;">如果</span><span style="color:#777777;">thread</span><span style="color:#777777;">线程通过</span><span style="color:#777777;">return</span><span style="color:#777777;">返回</span><span style="color:#777777;">,value_ ptr</span><span style="color:#777777;">所指向的单元里存放的是</span><span style="color:#777777;">thread</span><span style="color:#777777;">线程函数的返回值。 </span></li><li><span style="color:#777777;">2. </span><span style="color:#777777;">如果</span><span style="color:#777777;">thread</span><span style="color:#777777;">线程被别的线程调用</span><span style="color:#777777;">pthread_ cancel</span><span style="color:#777777;">异常终掉</span><span style="color:#777777;">,value_ ptr</span><span style="color:#777777;">所指向的单元里存放的是常数PTHREAD_ CANCELED。 </span></li><li><span style="color:#777777;">3. </span><span style="color:#777777;">如果</span><span style="color:#777777;">thread</span><span style="color:#777777;">线程是自己调用</span><span style="color:#777777;">pthread_exit</span><span style="color:#777777;">终止的</span><span style="color:#777777;">,value_ptr</span><span style="color:#777777;">所指向的单元存放的是传给</span><span style="color:#777777;">pthread_exit</span><span style="color:#777777;">的参数。 </span></li><li><span style="color:#777777;">4. </span><span style="color:#777777;">如果对</span><span style="color:#777777;">thread</span><span style="color:#777777;">线程的终止状态不感兴趣</span><span style="color:#777777;">,</span><span style="color:#777777;">可以传</span><span style="color:#777777;">NULL</span><span style="color:#777777;">给</span><span style="color:#777777;">value_ ptr</span><span style="color:#777777;">参数。</span></li></ul> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/92/e5/MiFz8Lnf_o.png" width="1109"></p> 
<hr> 
<h2 id="%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B">（四）<span style="color:#333333;">分离线程</span></h2> 
<p></p> 
<ul><li><span style="color:#777777;">默认情况下，新创建的线程是</span><span style="color:#777777;">joinable</span><span style="color:#777777;">的，线程退出后，需要对其进行</span><span style="color:#777777;">pthread_join</span><span style="color:#777777;">操作，否则无法释放资源，从而造成系统泄漏。 </span></li><li><span style="color:#777777;">如果不关心线程的返回值，</span><span style="color:#777777;">join</span><span style="color:#777777;">是一种负担，这个时候，我们可以告诉系统，当线程退出时，自动释放线程资源。</span></li></ul> 
<p> <strong>【函数介绍】</strong></p> 
<pre><code class="language-cpp">int pthread_detach(pthread_t thread);</code></pre> 
<p><strong>【代码示例】 </strong></p> 
<pre><code class="language-cpp">void* threadRun(void* args) {   
    sleep(2);  
    cout &lt;&lt; "线程任务已完成\n";  
    return nullptr;  
}  
  
int main() {  
    pthread_t tid;  
    int ret;  
  
    // 创建线程  
    ret = pthread_create(&amp;tid, nullptr, threadRun, nullptr);  
    if (ret) {  
        cerr &lt;&lt; "Error: pthread_create() failed\n";  
        return 1;  
    }  
  
    // 分离线程  
    pthread_detach(tid);  
  
    // 主线程继续执行  
    cout &lt;&lt; "主线程继续执行...\n";  
  
    // 主线程休眠一段时间以便观察分离线程的输出  
    sleep(3);  
  
    // 主线程结束，分离线程的资源会在其完成后由系统自动回收  
    return 0;  
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70799c369af147ea489c479b54b51ab4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;进阶】深入STL之list：高效双向链表的使用技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c25d2c2c48ec580f17f4445abb3524b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Stable-Diffusion的WebUI部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>