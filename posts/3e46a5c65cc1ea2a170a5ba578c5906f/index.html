<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>“爆炸性更新！JDK 17携全新语法特性强势来袭，开发者必看的升级亮点“（1） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3e46a5c65cc1ea2a170a5ba578c5906f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="“爆炸性更新！JDK 17携全新语法特性强势来袭，开发者必看的升级亮点“（1）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：Java进化论
目录
背景 yield关键字 var关键字 空指针异常 密封类
接口中的私有方法
instanceof关键字
背景 Java 8 虽然曾经是使用最广泛的版本，但由于它不再是受支持的版本（除非通过付费支持计划），很多公司已经开始或完成了向 Java 11 或 Java 17 的迁移。
需要注意的是，具体使用哪个版本可能因公司而异，一些公司可能因为特定的技术需求、框架兼容性、成本因素或内部政策而选择停留在某个版本。然而，趋势是向着最新的 LTS 版本迁移，以获取最新的安全补丁、性能提升和新功能。
上面是 AI对 有关Java17是否会成为以后常用的开发版本 的看法。也许在不久的将来就会代替Java11成为新的常用开发版本，因此我们程序员也要开始学习Java17的相关语法变动。
下面是官方对Java17的相关改动。
yield关键字 我们要想在多种不同情况下，返回不同的值，会用 switch 语句来解决。
例如：用一个 ret 来接收不同情况的值。
public class Test { public static void main(String[] args) { int n = 1; int ret = 0; switch (n) { case 1: ret = 1; break; case -1: ret = -1; break; case 0: ret = 0; break; } System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-09T16:29:44+08:00">
    <meta property="article:modified_time" content="2024-07-09T16:29:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">“爆炸性更新！JDK 17携全新语法特性强势来袭，开发者必看的升级亮点“（1）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<a class="link-info" href="https://blog.csdn.net/2301_80854132/category_12701347.html" title="Java进化论">Java进化论</a></strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%83%8C%E6%99%AF%C2%A0-toc" style="margin-left:0px;"><a href="#%E8%83%8C%E6%99%AF%C2%A0" rel="nofollow">背景 </a></p> 
<p id="yield%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0-toc" style="margin-left:0px;"><a href="#yield%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0" rel="nofollow">yield关键字 </a></p> 
<p id="var%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0-toc" style="margin-left:0px;"><a href="#var%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0" rel="nofollow">var关键字 </a></p> 
<p id="%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%C2%A0" rel="nofollow">空指针异常 </a></p> 
<p id="%E5%AF%86%E5%B0%81%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E5%AF%86%E5%B0%81%E7%B1%BB" rel="nofollow">密封类</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95" rel="nofollow">接口中的私有方法</a></p> 
<p id="instanceof%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">instanceof关键字</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E8%83%8C%E6%99%AF%C2%A0" style="background-color:transparent;"><span style="color:#fe2c24;">背景 </span></h2> 
<p><img alt="" height="1148" src="https://images2.imgbox.com/8a/69/rX3qoChr_o.png" width="1200"></p> 
<blockquote> 
 <p>Java 8 虽然曾经是使用最广泛的版本，但由于它不再是受支持的版本（除非通过付费支持计划），很多公司已经开始或完成了向 Java 11 或 Java 17 的迁移。</p> 
 <p>需要注意的是，具体使用哪个版本可能因公司而异，一些公司可能因为特定的技术需求、框架兼容性、成本因素或内部政策而选择停留在某个版本。然而，趋势是向着最新的 LTS 版本迁移，以获取最新的安全补丁、性能提升和新功能。</p> 
</blockquote> 
<p>上面是 AI对 有关Java17是否会成为以后常用的开发版本 的看法。也许在不久的将来就会代替Java11成为新的常用开发版本，因此我们程序员也要开始学习Java17的相关语法变动。</p> 
<p>下面是官方对Java17的相关改动。</p> 
<h2 id="yield%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0"><span style="color:#fe2c24;">yield关键字 </span></h2> 
<p>我们要想在多种不同情况下，返回不同的值，会用 switch 语句来解决。</p> 
<p>例如：用一个 ret 来接收不同情况的值。</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        int n = 1;
        int ret = 0;
        switch (n) {
            case 1:
                ret = 1;
                break;
            case -1:
                ret = -1;
                break;
            case 0:
                ret = 0;
                break;
        }
        System.out.println(n);
    }
}</code></pre> 
<p>上面是正常的 switch 语句，下面来看简写版的 switch 语句。</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        int n = 1;
        // 不能使-&gt;两边的值全部一样
        int ret = switch (n) {
            case 1 -&gt; 1;
            case -1 -&gt; -1;
            case 0 -&gt; 0;
            default -&gt; 100;
        };
        System.out.println(n);
    }
}</code></pre> 
<p>注意：switch 语句中 -&gt; 两边的值不能全部一样。如果上面的代码把 default 语句去掉的话，那么就会出现语法错误。下面是代码的结果：</p> 
<p><img alt="" height="803" src="https://images2.imgbox.com/0f/07/4QFVUoej_o.png" width="1061"></p> 
<p>如果不想使用指向符 -&gt; 可以使用yield来代替：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        int n = 1;
        // 不能使-&gt;两边的值全部一样
        int ret = switch (n) {
            case 1 : yield 1;
            case -1: yield  -1;
            case 0: yield 0;
            default: yield 100;
        };
        System.out.println(n);
    }
}</code></pre> 
<p>注意：这里也和上面一样，不能出现全部一样的。</p> 
<p>简化之后的 -&gt; 其后可以跟着代码块，并且把 yield 关键字当成 return 使用。</p> 
<pre><code class="language-java">Class Test {
    public static void main(String[] args) {
        int number = 4;
        // 不能使-&gt;两边的值全部一样
        int result = switch (number) {
            case 1 -&gt; 1;
            case 2 -&gt; 2;
            case 3 -&gt; 3;
            case 4 -&gt; {
                System.out.println("It's a four!");
                yield 4; // 使用yield关键字从代码块返回一个值
            }
            default -&gt; 1;
        };
        System.out.println(result); // 输出: It's a four! 和 40
    }
}
</code></pre> 
<p>相对来说，我们平时都是写的完整版的switch语句，所以这个更新我们了解即可。 </p> 
<h2 id="var%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0"><span style="color:#fe2c24;">var关键字 </span></h2> 
<p>从Java10开始，var关键字就开始被引入了。其功能就是使我们的代码更加简洁！如下所示：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 顺序表模拟实现二维数组
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();
    }
}</code></pre> 
<p>但是如果我们要用顺序表模拟实现三维甚至是四维数组呢？难道也是用一个一个的去实现吗？所以Java10 开始就引入了var 关键字，实现对类型的简化。如下所示：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 顺序表模拟实现二维数组
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();
        // 根据后面的泛型推导前面的 var 是个啥
        var list2 = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    }
}</code></pre> 
<p>其实这个与泛型的有点类似，泛型是根据前面的类型来推导后面的类型是个啥，而 var 是根据我们写后面的类型来推导我们的类型是个啥。 </p> 
<p>但凡事都有两面性，既然可以方便我们简写类型，那么也就有要注意的地方： </p> 
<blockquote> 
 <p>1. 不能用来声明字段。</p> 
 <p>2. 不能用来声明方法参数。</p> 
 <p>3. 不能用来声明方法的返回类型。</p> 
 <p>4. var声明的变量必须初始化，并且不能初始化为null。</p> 
</blockquote> 
<p>其实也挺好理解的。首先，得把<span style="color:#4da8ee;">第四点</span>给理解了：为啥 var声明的变量必须初始化 ？因为我们是<span style="color:#a2e043;">通过后面的初始化内容来推导前面的类型的</span>。如果不初始化，就不能推导出前面的类型是个啥？同理：你把 引用数据类型 初始化为null，那么编译器又怎么根据后面的内容推导出前面是个啥呢？Integer？String？还是自定义类型呢？</p> 
<p>第四点知道了，其余的也就都理解了。我们学过字段是会被默认初始化的。如果是基本数据类型倒还好，但如果是引用数据类型呢？还是会被初始化为null。但这里可能有小伙伴有疑问：把字段全部初始化不就行了嘛？即使没意义但初始化的时候也不影响啊。举个很简单的例子：我们在实现自定义的链表时，如果链表的头被初始化了，那么我们怎么判断这个链表是否为空呢？因此，var不能用来声明字段。同理：方法的参数和返回类型是我们事先确定的。但是如果使用var的话，就代表我们事先是不确定的，这就互相矛盾了。</p> 
<h2 id="%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%C2%A0"><span style="color:#fe2c24;">空指针异常 </span></h2> 
<p>对于空指针异常的抛出，Java 8 只会给出哪里抛出了空指针异常，而没有把为什么会出现空指针异常告诉我们。Java 17就改善了这个方面。下面给出了两者对于空指针的异常的抛出示例：</p> 
<p>Java 8 ：</p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/82/d4/byTaLiDM_o.png" width="1200"></p> 
<p>Java 17 ： </p> 
<p><img alt="" height="549" src="https://images2.imgbox.com/2c/87/bQkO241l_o.png" width="1200"></p> 
<h2 id="%E5%AF%86%E5%B0%81%E7%B1%BB" style="background-color:transparent;"><span style="color:#fe2c24;">密封类</span></h2> 
<p>当我们使用关键字 final 去修饰一个类时，这个被修饰的类就变成完全封闭的状态了，不存在有类可以继承它，那么这个类就被称为密封类。密封类一般应用在类和接口中，对接口和类的实现和继承进行约束。 JDK17提供了一个新的关键字： sealed 。密封类除了可以被该关键字 sealed 修饰之外，还可以在声明这个关键词的末尾用 permits 表示要开放给哪些类型来继承。如下所示：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/65/d3/CmrWuBRn_o.png" width="1055"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7c/3a/3PMyixeD_o.png" width="1071"></p> 
<p>根据不同的需求，处理上面的方式也不同：</p> 
<p>1、把Dog类也加上 sealed 限制 ，并且同样要开放给其他类。也就说，Dog类也是有继承限制的。</p> 
<p>2、如果Dog类想成为最后一级类的话（就是不想还有其他类继承Dog类的话），只能用关键字 non-sealed 和 final 修饰。这两种修饰的意义不同：non-sealed 修饰代表的是这个类没有限制，也就类似于开放这个类的意思；而 final 修饰代表的是这个类不可被继承的类。其实也就是处理两种极限问题：可以让所有类继承它，没有类能够继承它。</p> 
<p>注意：sealed 修饰的类一定要有子类。因为我们会在修饰的这个类的末尾声明上可以继承它的类，因此sealed修饰的类一定是会有子类的。</p> 
<p>同样这个继承也是可以实现多个的：</p> 
<pre><code class="language-java">sealed abstract class Animal permits Dog{
    public String name;
    public int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public abstract void eat();
}

sealed class Dog extends Animal permits PetDog{
    public Dog(String name, int age) {
        super(name, age);
    }
    @Override
    public void eat() {
        System.out.println(name+" 正在吃狗粮~");
    }
}

non-sealed class PetDog extends Dog{
    public PetDog(String name, int age) {
        super(name, age);
    }
}</code></pre> 
<h2 id="%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span style="color:#fe2c24;">接口中的私有方法</span></h2> 
<p>Java 8以前的Java版本，所有的接口只能是抽象方法。但从Java 8开始接口中可以有默认方法</p> 
<p>被实现，以及静态方法被实现。</p> 
<p><img alt="" height="929" src="https://images2.imgbox.com/1a/0c/K804ADv0_o.png" width="940"></p> 
<p>从Java 9 开始，进一步允许在接口中定义私有方法和私有静态方法的实现。 </p> 
<p><img alt="" height="945" src="https://images2.imgbox.com/ba/09/WVCXNNbl_o.png" width="921"></p> 
<p>总结：Java 17 中可以有私有的静态方法和私有的方法，以及默认的方法它们的实现。 </p> 
<h2 id="instanceof%E5%85%B3%E9%94%AE%E5%AD%97" style="background-color:transparent;"><span style="color:#fe2c24;">instanceof关键字</span></h2> 
<p>instanceof关键字，我们前面在学习多态时，使用来判断 某个对象是否为该类型（或者其子类）的一个实例。</p> 
<p>现在对其改进的效果如下：</p> 
<pre><code class="language-java">if (obj instanceof String) {
    String str = (String)obj;
    .......
}</code></pre> 
<p>上面的instanceof语法一共做了三件事：</p> 
<p>1. 判断是否为String类型；</p> 
<p>2. 如果是，转成String类型；</p> 
<p>3. 创建一个名为str 的临时变量来接收转换的结果； </p> 
<p>也就是说，下面的代码和上面的代码的效果是一样的：</p> 
<pre><code class="language-java">// obj是否为String类型，如果是创建临时变量str
if (obj instanceof String str) {

}
</code></pre> 
<p>还有更多关于Java 17的更新知识，我们会随着学习的深入，继续开始学习。好啦！本期  “爆炸性更新！JDK 17携全新语法特性强势来袭，开发者必看的升级亮点“（1）的学习之旅就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9caea515560d1fd29ce8c3385f812c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux安装Weblogic 14.1.1.0.0保姆级教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b85bc3b9c5b0ae7bd9be2a84699b9212/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vagrant配合VirtualBox搭建虚拟机</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>