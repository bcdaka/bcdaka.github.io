<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构入门（C语言版）图的概念和功能函数实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3d790bd7b3ffd8be0bf560d23b61208f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构入门（C语言版）图的概念和功能函数实现">
  <meta property="og:description" content="图的概念和功能函数实现 前言1.图的定义和术语1.1 定义1.2 常用术语 2.图的存储结构2.1 图的数组(邻接矩阵)存储表示2.2 图的邻接表存储表示 3.图的遍历3.1 深度优先搜索3.2 广度优先搜索3.3 示例 4.连通网的最小生成树4.1 克鲁斯卡尔(Kruskal)算法4.2 普里姆(Prim)算法 5.图的建立及其接口函数的实现结语 前言 图是一种比线性表和树更复杂的数据结构。在线性表中,数据元素之间仅有线性关系每个元素只有一个直接前驱和一个直接后继。在树形结构中,数据元素之间存在明显的层次关系，并且每层的元素可能和下一层的多个元素(即其孩子结点)相邻,但只能和上一层的个元素(即其双亲结点)相邻。而在图形结构中,结点之间的关系可以是任意的，图中任意两个元素之间都可能相邻。图的应用极为广泛，俗话说“千言万语不如一张图”,因此图是计拿机应用过程中对实际问题进行数学抽象和描述的强有力的工具。图论是专门研究图的性质的一个数学分支,在离散数学中占有极为重要的地位。图论注重研究图的纯数学性质,而数据结构中对图的讨论则侧重于在计算机中如何表示图以及如何实现图的操作和应用等。
1.图的定义和术语 1.1 定义 图(graph)由一个顶点(vertex)的有穷非空集 V(G)和一个弧(arc)的集合 E(G)组成通常记作 G-(V,E)。图中的顶点即为数据结构中的数据元素,孤的集合 E实际上是定义在顶点集合上的一个关系。以下用有序对(u,w)表示从到w 的一条弧(arc)。孤有方向性,需以一带箭头的线段表示,通常称 (没有箭头的出发端)为弧尾(tail)或始点(initianode),称w(带箭头的终止端)为弧头(head)或终点(terminal node),此时的图称为有向图(digraph)。若图中从 乙到w 有一条弧,同时从w到也有一条弧,则以无序对(v,w)代替这两个有序对(v，w)和(w，v),表示 v和w 之间的一条边。此时的图在顶点之间不再强调方向性的特征,称为无向图(undigraph)。
例如图(a)中的 G，是有向图G1=(V1,{A1})
其中:
V1={A,C,B,F,D,E,G}
A1={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;}
图(b)中的 G2为无向图G2=(V2,{E2})
其中:
V2={A,B,C,D,E,F}
E ={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F),(C,D),(E,F),(C,E)}
注意：有向图的边用&lt;&gt;,无向图的边用（）
在实际应用中，图的弧或边往往与具有一定意义的数相关,称这些数为“权(weight)”。分别称带权的有向图和无向图为有向网(network)和无向网,如图©和(d)所示。
1.2 常用术语 稀疏图和稠密图
假设用 n 表示图中顶点数目,用 e 表示边或弧的数目。若不考虑顶点到其自身的弧或边,则对于无向图,边数 e 的取值范围是 0到 n(n-1)/2。称具有 n(n-1)/2条边的无向图为完全图(completed graph)。对于有向图,弧的数目 e的取值范围是到n(n-1)。称具有 n(n-1)条弧的有向图为有向完全图。若 e&lt;nlogn,则称为稀疏图(sparse graph),反之称为稠密图(dense graph)。
子图
假设有两个图G=(V,{E})和G’=(V’,{E’})如果V’属于V且E’属于E,则称G’为G的子图(subgraph)。如下图
度、入度和出度
若 u一&gt;v是图中一条弧,则称u邻接到v,或v邻接自u。图中所邻接到该顶点v的弧(即以它为弧头的弧)的数目,称为该顶点的入度(indegree),记作 ID(v);反之,从某顶点u出发的弧(即邻接自该顶点的弧)的数目,称为该顶点的出度(outdegree),记作 OD(u)。顶点 v的入度和出度之和称为该顶点的总度,简称为度(degree),记作 TD(v).">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-06T18:04:47+08:00">
    <meta property="article:modified_time" content="2023-08-06T18:04:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构入门（C语言版）图的概念和功能函数实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/28/cb/dH4uFrDg_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>图的概念和功能函数实现</h4> 
 <ul><li><a href="#_3" rel="nofollow">前言</a></li><li><a href="#1_5" rel="nofollow">1.图的定义和术语</a></li><li><ul><li><a href="#11__6" rel="nofollow">1.1 定义</a></li><li><a href="#12__20" rel="nofollow">1.2 常用术语</a></li></ul> 
  </li><li><a href="#2_41" rel="nofollow">2.图的存储结构</a></li><li><ul><li><a href="#21__43" rel="nofollow">2.1 图的数组(邻接矩阵)存储表示</a></li><li><a href="#22__48" rel="nofollow">2.2 图的邻接表存储表示</a></li></ul> 
  </li><li><a href="#3_52" rel="nofollow">3.图的遍历</a></li><li><ul><li><a href="#31__54" rel="nofollow">3.1 深度优先搜索</a></li><li><a href="#32__60" rel="nofollow">3.2 广度优先搜索</a></li><li><a href="#33__63" rel="nofollow">3.3 示例</a></li></ul> 
  </li><li><a href="#4_74" rel="nofollow">4.连通网的最小生成树</a></li><li><ul><li><a href="#41_Kruskal_82" rel="nofollow">4.1 克鲁斯卡尔(Kruskal)算法</a></li><li><a href="#42_Prim_87" rel="nofollow">4.2 普里姆(Prim)算法</a></li></ul> 
  </li><li><a href="#5_93" rel="nofollow">5.图的建立及其接口函数的实现</a></li><li><a href="#_256" rel="nofollow">结语</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>前言</h2> 
<p>图是一种比线性表和树更复杂的数据结构。在线性表中,数据元素之间仅有<strong>线性关系每个元素</strong>只有<strong>一个直接前驱</strong>和<strong>一个直接后继</strong>。在树形结构中,数据元素之间存在明显的层次关系，并且每层的元素可能和下一层的多个元素(即其孩子结点)相邻,但只能和上一层的个元素(即其双亲结点)相邻。而在图形结构中,结点之间的关系可以是任意的，图中任意两个元素之间都可能相邻。图的应用极为广泛，俗话说“千言万语不如一张图”,因此图是计拿机应用过程中对实际问题进行数学抽象和描述的强有力的工具。图论是专门研究图的性质的一个数学分支,在离散数学中占有极为重要的地位。图论注重研究图的纯数学性质,而数据结构中对图的讨论则侧重于在计算机中如何表示图以及如何实现图的操作和应用等。</p> 
<h2><a id="1_5"></a>1.图的定义和术语</h2> 
<h3><a id="11__6"></a>1.1 定义</h3> 
<p><strong>图(graph)<strong>由一个顶点(vertex)的有穷非空集 V(G)和一个弧(arc)的集合 E(G)组成通常记作 G-(V,E)。图中的</strong>顶点即为数据结构中的数据元素</strong>,孤的集合 E实际上是定义在顶点集合上的一个关系。以下用有序对(u,w)表示从到w 的一条弧(arc)。孤有方向性,需以一带箭头的线段表示,通常称 (没有箭头的出发端)为<strong>弧尾(tail)<strong>或</strong>始点(initianode)</strong>,称w(带箭头的终止端)为弧头(head)或终点(terminal node),此时的图称为<strong>有向图(digraph)</strong>。若图中从 乙到w 有一条弧,同时从w到也有一条弧,则以无序对(v,w)代替这两个有序对(v，w)和(w，v),表示 v和w 之间的一条边。此时的图在顶点之间不再强调方向性的特征,称为<strong>无向图(undigraph)</strong>。<br> 例如图(a)中的 G，是有向图G1=(V1,{A1})<br> 其中:<br> V1={A,C,B,F,D,E,G}<br> A1={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;}<br> 图(b)中的 G2为无向图G2=(V2,{E2})<br> 其中:<br> V2={A,B,C,D,E,F}<br> E ={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F),(C,D),(E,F),(C,E)}<br> <code>注意：有向图的边用&lt;&gt;,无向图的边用（）</code><br> 在实际应用中，图的弧或边往往与具有一定意义的数相关,称这些数为“<strong>权</strong>(weight)”。分别称带权的有向图和无向图为<strong>有向网</strong>(network)和<strong>无向网</strong>,如图©和(d)所示。<br> <img src="https://images2.imgbox.com/49/4a/qqWKtIfe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12__20"></a>1.2 常用术语</h3> 
<p><strong>稀疏图和稠密图</strong></p> 
<p>假设用 n 表示图中顶点数目,用 e 表示边或弧的数目。若不考虑顶点到其自身的弧或边,则对于无向图,<strong>边数 e 的取值范围是 0到 n(n-1)/2</strong>。称<strong>具有 n(n-1)/2条边的无向图为完全图</strong>(completed graph)。对于有向图,弧的数目 e的取值范围是到n(n-1)。称<strong>具有 n(n-1)条弧的有向图为有向完全图</strong>。若 <strong>e&lt;nlogn</strong>,则称为<strong>稀疏图</strong>(sparse graph),<strong>反之称为稠密图</strong>(dense graph)。</p> 
<p><strong>子图</strong></p> 
<p>假设有两个图G=(V,{E})和G’=(V’,{E’})如果V’属于V且E’属于E,则称G’为G的子图(subgraph)。如下图<br> <img src="https://images2.imgbox.com/1e/09/WRciW4J6_o.png" alt="在这里插入图片描述"><br> <strong>度、入度和出度</strong></p> 
<p>若 u一&gt;v是图中一条弧,则称<strong>u邻接到v,或v邻接自u</strong>。图中所邻接到该顶点v的弧(即以它为弧头的弧)的数目,称为该顶点的<strong>入度</strong>(indegree),记作 ID(v);反之,从某顶点u出发的弧(即邻接自该顶点的弧)的数目,称为该顶点的<strong>出度</strong>(outdegree),记作 OD(u)。顶点 v的入度和出度之和称为该顶点的总度,简称为<strong>度</strong>(degree),记作 TD(v).例如,图G1中顶点 B的入度ID(B)=2,出度 OD(B)=3,度 TD(B)=5。无向图中顶点的度定义为与该顶点相连的边的数目。</p> 
<p><strong>路径和回路</strong></p> 
<p>若有向图G中k+1个顶点之间都有弧存在(即&lt;v0,v1&gt;,&lt;v1,v2&gt;,…&lt;v(k-1),vk&gt;是图G中的弧),则这个顶点的序列{v0,v1,v2,…,vk}为从顶点。到顶点v0到vk的一条<strong>有向路径</strong>，路径中弧的数目定义为<strong>路径长度</strong>。若<strong>序列中的顶点都不相同,则为简单路径</strong>。对无向图,相邻顶点之间存在边的k+1个顶点序列构成一条长度为k的无向路径。如果v0和vk是同一个顶点，则是一条由某个顶点出发又回到自身的路径,称这种路径为<strong>回路</strong>或<strong>环</strong>(cycle)。</p> 
<p><strong>连通图和连通分量</strong><br> <strong>若无向图中任意两个顶点之间都存在一条无向路径,则称该无向图为连通图</strong>。<strong>对有向图而言,若图中任意两个顶点之间都存在一条有向路径,则称该有向图为强连通图</strong>。例如,图G2为连通图,图G1为非强连通图。<strong>非连通图中各个连通子图称为该图的连通分量</strong>。如图(b)为由两个连通分量构成的非连通图(a)所示为图G1的4个强连通分量。<br> <img src="https://images2.imgbox.com/d4/f4/5PRKxIuU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_41"></a>2.图的存储结构</h2> 
<p>图是一种典型的复杂结约,图中顶点可能同任章一个其他的项点之间有关系。因此图没有顺序存储表示的结构。</p> 
<h3><a id="21__43"></a>2.1 图的数组(邻接矩阵)存储表示</h3> 
<p>邻接矩阵是用于描述图中顶点之间关系（及弧或边的权）的矩阵。</p> 
<p>图G1和图G2的邻接矩阵分别如图(a)和(b)所示。由于一般情况下,图中都没有邻接到自身的弧;因此矩阵中的主对角线为全零。由于无向图中的一条边视为一对藏洲无向图的邻接矩阵必然是对称矩阵。网的邻接矩阵的定义中,当vi到vj有弧相邻接时；a i，j的值应为该弧上的权值否则为如图(d)所示为有向网的邻接矩阵。<br> <img src="https://images2.imgbox.com/4a/dc/eyv9eKos_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22__48"></a>2.2 图的邻接表存储表示</h3> 
<p>邻接表(adjacency list)是图的一种链式存储表示方法,它类似于树的孩子链表。<br> 从图中可见，在有向的邻接表中,从同一顶点出发的弧链接在同一链表中,邻接表中结点的个数恰为图中弧的数目,而在无向图的邻接表中,同一条边有两个结点,分别出现在和它相关的两个顶点的链表中,因此无向图的邻接表中结点个数是边数的两倍。在邻接表中,顶点表结点的排列次序决于建立图结构时输人信息的次序。<br> <img src="https://images2.imgbox.com/f0/ff/ClM0M2xP_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3_52"></a>3.图的遍历</h2> 
<p>与二叉树和树的遍历类似,图结构也有遍历操作,即从某个顶点出发,沿着某条路径对图中其余顶点进行访问,且使每一个顶点只被访问一次。然而,图的遍历要比树的遍历复杂得多,因为在图中和同一顶点有弧或边相通的顶点之间也可能有弧或边，则在访问了某个而点之后,可能顺着某条回路又回到该顶点。例如图G2,由于图中存在回路,因此从而点A 出发,在访问了 B,C之后,又可以访问到顶点 A。为了避免同一顶点被重复访向多次,则在遍历过程中,必须为已经被访问过的顶点加上标识,以便再次途经这样的顶点时不再重访。为此,需附设一维数组 visited[o…n-1],令其每个分量对应图中一个顶点,各分量的初值均置为“FALSE”或“0”,一且访问了某个顶点，便将 visited 中相应分量的值置为“TRUE”或“被访问时的次序号”。通常,对图进行遍历可有两种搜索路径:<strong>深度优先搜索和广度优先搜索</strong>,以下分别讨论之。</p> 
<h3><a id="31__54"></a>3.1 深度优先搜索</h3> 
<p><strong>深度优先搜索</strong>(depth first search)遍历类似于树的先根遍历，可以看成是树的先根遍历的推广。</p> 
<p>假设初始状态是图中所有顶点均未被访问,则从某个顶点艺出发,首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先遍历图,直至图中所有和 有路径相的顶点都被访问到,若此时尚有其他顶点未被访问,则另选一个未被访问过的顶点作起始点,重复上述过程,直至图中所有顶点都被访问到为止。</p> 
<p>显然,深度优先搜索是一个递归的过程。可将图的深度优先搜索遍历和树的先根遍历相比较,图中遍历的起始顶点对应于树的根结点,起始顶点的邻接点 wi对应于树根各孩子结点,从邻接点出发的遍历对应于从子树根出发的遍历,不同的是,树中各子树互不相交,因此对任一子树的遍历决不会访问到其他子树中的结点,而从图中某一邻接点 wi开始的遍历有可能访问到起始点的其他邻接点 wj，因此在图的遍历算法中必须强调“从各个未被访问的邻接点起进行遍历”。</p> 
<h3><a id="32__60"></a>3.2 广度优先搜索</h3> 
<p><strong>广度优先搜索</strong>(breadth first search)的基本思想是:从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点,然后分别从这些邻接点出发依次访问它们的邻接点,并使得“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问,直至图中所有已被访问的顶点的邻接点都被访问到。如若此时图中尚有顶点未被访问,则需另选一个未曾被访问过的顶点作为新的起始点,重复上述过程,直至图中所有顶点都被访问到为止。换句话说,广度优先搜索遍历图的过程是以v为起始点,由近至远，依次访问和v有路径相通且路径长度为 1,2,…的顶点。</p> 
<h3><a id="33__63"></a>3.3 示例</h3> 
<p><img src="https://images2.imgbox.com/58/e3/AexiXRmx_o.png" alt="在这里插入图片描述"><br> <strong>深度优先搜索</strong><br> <img src="https://images2.imgbox.com/92/74/6NXpvkBJ_o.png" alt="在这里插入图片描述"><br> 从v3开始遍历<br> 顺序为：v3-&gt;v2-&gt;v4-&gt;v9-&gt;v1-&gt;v6-&gt;v5-&gt;v8-&gt;v7<br> <strong>广度优先搜索</strong><br> <img src="https://images2.imgbox.com/df/e0/9pTw869o_o.png" alt="在这里插入图片描述"><br> 从v3开始遍历<br> 顺序为：v3-&gt;v2-&gt;v1-&gt;v6-&gt;v4-&gt;v5-&gt;v9-&gt;v8-&gt;v7</p> 
<h2><a id="4_74"></a>4.连通网的最小生成树</h2> 
<p>在一个含有 n 个顶点的连通图中,必能从中选出n1条边构成一个极小连通子图,它含有图中全部 n 个顶点，但只有足以构成一棵树的 n-1条边,称这棵树为连通图的生成树。连通网的最小生成树则为权值和取最小的生成树。</p> 
<p>如果用一个连通网表示 个居民点和各个居民点之间可能架设的通信线路,则网中每一条边上的权值可表示架设这条线路所需经费。由于在 个居民点间架构通信网只需架设n-1条线路,则工程队面临的问题是架设哪几条线路能使总的工程费用最低。这个问题等价于,在含有 n 个顶点的连通网中选择n一1条边,构成一棵极小连通子图,并使该连通子图中n-1条边上权值之和达到最小,则称这棵连通子图为连通网的最小生成树。</p> 
<p>例如下图所示为连通网和它的三棵权值总和分别为 43、36 和 64 的生成树，其中以图©所示生成树的权值总和最小,且为图(a)中连通网的最小生成树。<br> <img src="https://images2.imgbox.com/82/9d/XP0XnZ0H_o.png" alt="在这里插入图片描述"><br> 那么如何构造连通网的最小生成树?以下介绍求得最小生成树的两种算法：</p> 
<h3><a id="41_Kruskal_82"></a>4.1 克鲁斯卡尔(Kruskal)算法</h3> 
<p>克鲁斯卡尔算法的基本思想为:为使生成树上总的权值之和达到最小,应使每一条边上的权值尽可能小,自然应从权值最小的边选起,直至选出 #一1 条权值最小的边为止，然这n一1条边必须不构成回路。因此并非每一条居当前权值最小的边都可选。</p> 
<p>具体做法如下，首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中去,并使森林中不产生回路,直至该森林变成一棵树为止。例如,对图(a)所示连通网按克鲁斯卡尔算法构造最小生成树的过程如图 7.12 所示,在选择权值最小(分别为 2、3 和4)的 3 条边之后,下一条权值最小的边是(c,e),但由于顶点c和e已在同一棵树上,加上边(c,e)将产生回路,因此不可取。同理权值为 6 的边(c,f)也不取。之后在选择了权值分别为7和8的边之后权值为10的边(b,c)也不可取，最后选择(a,b)。至此图中7个顶点都已落在同一棵树上,最小生成树构造完毕。从上述过程可见对上图(a)所示连通网,不可能再找到权值总和小于 36 的生成树了。<br> <img src="https://images2.imgbox.com/34/96/LO37TdhF_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42_Prim_87"></a>4.2 普里姆(Prim)算法</h3> 
<p>普里姆算法的基本思想是: 首先选取图中任意一个顶点v作为生成树的根,之后继续往生成树中添加顶点 w则在顶点 w 和顶点v之间必须有边，且该边上的权值应在所有和v相邻接的边中属最小。在一般情况下,从尚未落在生成树上的顶点中选取加入生成树的顶点应满足下列条件; 它和生成树上的顶点之间的边上的权值是在连接这两类顶点(一类是已落在生成树上的顶点,另一类是尚未落在生成树上的顶点)的所有边中权值属最小。例如对图(a)所示的连通网,假设从顶点 a 开始构建最小生成树。此时只有顶点 a 在生成树中,其余顶点 b、c、d、e、f、g 均不在生成树上。连接这两类顶点的边有(a,b)、(a,f)和(a,g),其中以边(a,b)的权值最小,则选择边(a,b)之后,顶点b加入到生成树中,之后在链接<br> (a,b)和{c,d,e,f,g)这两类顶点的边集{(b,c),(b,f),(a,f),(a,g)}中,选择权值最小(=7)的边(b,f)加人到生成树中,之后应在链接顶点(c,d,e,g)的边集{(b,c),(f,c),(f,e),(f,g),(a,g)}中选择权值最小的边(f,e)…,依此类推,直至所有顶点都落到生成树上为止。上述构筑生成树的过程如下图所示:<br> <img src="https://images2.imgbox.com/9b/d9/GxUhpfcy_o.png" alt="在这里插入图片描述"><br> 比较以上两个算法可见，克鲁斯卡尔算法主要对“边”进行操作,其时间复杂度为O(e),而普里姆算法主要对“顶点”进行操作,其时间复杂度为 O(n^2)。因此前者适于稀疏图,后适于稠密图。</p> 
<h2><a id="5_93"></a>5.图的建立及其接口函数的实现</h2> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_VERTICES</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token comment">// 邻接表中的边节点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">EdgeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> dest<span class="token punctuation">;</span><span class="token comment">//目标顶点</span>
    <span class="token keyword">struct</span> <span class="token class-name">EdgeNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token comment">//源顶点</span>
<span class="token punctuation">}</span> EdgeNode<span class="token punctuation">;</span>

<span class="token comment">// 邻接表中的顶点节点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">VertexNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span><span class="token comment">//顶点值</span>
    EdgeNode<span class="token operator">*</span> edges<span class="token punctuation">;</span><span class="token comment">//边值</span>
    <span class="token keyword">int</span> visited<span class="token punctuation">;</span><span class="token comment">//访问标记</span>
<span class="token punctuation">}</span> VertexNode<span class="token punctuation">;</span>

<span class="token comment">// 图结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Graph</span> <span class="token punctuation">{<!-- --></span>
    VertexNode vertices<span class="token punctuation">[</span>MAX_VERTICES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//顶点集合</span>
    <span class="token keyword">int</span> numVertices<span class="token punctuation">;</span><span class="token comment">//图中顶点下标数</span>
<span class="token punctuation">}</span> Graph<span class="token punctuation">;</span>

<span class="token comment">// 初始化图</span>
<span class="token keyword">void</span> <span class="token function">initGraph</span><span class="token punctuation">(</span>Graph<span class="token operator">*</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    graph<span class="token operator">-&gt;</span>numVertices <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_VERTICES<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>edges <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 添加顶点</span>
<span class="token keyword">void</span> <span class="token function">addVertex</span><span class="token punctuation">(</span>Graph<span class="token operator">*</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token operator">-&gt;</span>numVertices <span class="token operator">&lt;</span> MAX_VERTICES<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        VertexNode<span class="token operator">*</span> vertex <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>graph<span class="token operator">-&gt;</span>numVertices<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vertex<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        graph<span class="token operator">-&gt;</span>numVertices<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"图已满，无法添加更多顶点\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 添加边</span>
<span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span>Graph<span class="token operator">*</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> dest<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>src <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> src <span class="token operator">&lt;</span> graph<span class="token operator">-&gt;</span>numVertices <span class="token operator">&amp;&amp;</span> dest <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dest <span class="token operator">&lt;</span> graph<span class="token operator">-&gt;</span>numVertices<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        EdgeNode<span class="token operator">*</span> newEdge <span class="token operator">=</span> <span class="token punctuation">(</span>EdgeNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>EdgeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        newEdge<span class="token operator">-&gt;</span>dest <span class="token operator">=</span> dest<span class="token punctuation">;</span>
        newEdge<span class="token operator">-&gt;</span>next <span class="token operator">=</span> graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">.</span>edges<span class="token punctuation">;</span>
        graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">.</span>edges <span class="token operator">=</span> newEdge<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"顶点索引无效\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 深度优先遍历递归函数</span>
<span class="token keyword">void</span> <span class="token function">dfsRecursive</span><span class="token punctuation">(</span>Graph<span class="token operator">*</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> vertex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    EdgeNode<span class="token operator">*</span> edge <span class="token operator">=</span> graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">.</span>edges<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>edge <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> dest <span class="token operator">=</span> edge<span class="token operator">-&gt;</span>dest<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>visited<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">dfsRecursive</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        edge <span class="token operator">=</span> edge<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 深度优先遍历</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>Graph<span class="token operator">*</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> startVertex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> graph<span class="token operator">-&gt;</span>numVertices<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">dfsRecursive</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> startVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 广度优先遍历</span>
<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span>Graph<span class="token operator">*</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> startVertex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> queue<span class="token punctuation">[</span>MAX_VERTICES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> graph<span class="token operator">-&gt;</span>numVertices<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>startVertex<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>startVertex<span class="token punctuation">]</span><span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">[</span>rear<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> startVertex<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>front <span class="token operator">&lt;</span> rear<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> vertex <span class="token operator">=</span> queue<span class="token punctuation">[</span>front<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        EdgeNode<span class="token operator">*</span> edge <span class="token operator">=</span> graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">.</span>edges<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>edge <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> dest <span class="token operator">=</span> edge<span class="token operator">-&gt;</span>dest<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>visited<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                graph<span class="token operator">-&gt;</span>vertices<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                queue<span class="token punctuation">[</span>rear<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> dest<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            edge <span class="token operator">=</span> edge<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Graph graph<span class="token punctuation">;</span>
    <span class="token function">initGraph</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>graph<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> numVertices<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入图中的顶点数: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>numVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numVertices<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入顶点的值 %d: "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addVertex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>graph<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> numEdges<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入图中的边数: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>numEdges<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numEdges<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> src<span class="token punctuation">,</span> dest<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入边的源顶点和目标顶点 %d: "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>src<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>graph<span class="token punctuation">,</span> src<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> startVertex<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入遍历的起始顶点: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>startVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"深度优先遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>graph<span class="token punctuation">,</span> startVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"广度优先遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>graph<span class="token punctuation">,</span> startVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>我们插入下面的一个简单的有向图<br> <img src="https://images2.imgbox.com/7e/f9/TYSnP2Of_o.png" alt="在这里插入图片描述"><br> 输出结果如下：<br> <img src="https://images2.imgbox.com/7d/3e/wjRAyCkp_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_256"></a>结语</h2> 
<p>这篇文章关于概念理论的介绍摘录自严蔚敏和陈文博的《数据结构及应用算法教程(修订版)》<br> 有兴趣的小伙伴可以关注作者，如果觉得内容不错，请给个一键三连吧，蟹蟹你哟！！！<br> 制作不易，如有不正之处敬请指出<br> 感谢大家的来访，UU们的观看是我坚持下去的动力<br> 在时间的催化剂下，让我们彼此都成为更优秀的人吧！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/369d7004ac2ac8184e95e8a0dc576ef0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全网最清晰JAVA NIO，看一遍就会</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac743ff9b4182e920a803215746f21e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（C语言版）力扣（LeetCode）题库1-5题解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>