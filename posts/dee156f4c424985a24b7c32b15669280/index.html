<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】free()函数详解(动态内存释放函数) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dee156f4c424985a24b7c32b15669280/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C语言】free()函数详解(动态内存释放函数)">
  <meta property="og:description" content="🦄个人主页:修修修也
🎏所属专栏:C语言
⚙️操作环境:Visual Studio 2022
目录
一.free()函数简介
1.函数功能
2.函数参数
void * ptr
3.函数返回值
4.函数头文件
二.free()函数的具体使用
1.使用free()函数完成malloc()开辟空间的释放
2.使用free()函数完成calloc()开辟空间的释放
3.使用free()函数完成realloc()开辟空间的释放
三.free()函数常见使用误区
1.对非动态开辟内存使用free释放
2.使用free释放一块动态内存的一部分
3.对同一块动态内存多次释放
4.动态开辟内存后忘记释放
结语
一.free()函数简介 我们先来看一下cplusplus.com - The C&#43;&#43; Resources Network网站上free()函数的基本信息：
1.函数功能 可以看到,free()函数的功能是:释放以前由malloc(),calloc(),realloc()函数动态开辟的内存空间.使其可以重新被分配.
2.函数参数 该函数有1个参数,是:
void free (void* ptr); void * ptr 该参数的类型是无类型指针(void*),它指向先前由malloc(),calloc(),realloc()动态分配的内存块,它的作用是告诉函数要释放的内存块的起始位置.
3.函数返回值 函数的返回值类型是空(void),它表示函数在运行结束后不需要返回值.
4.函数头文件 该函数包含在头文件&lt;stdlib.h&gt;中.
二.free()函数的具体使用 free()函数的使用场景是:当我们先前使用了malloc(),calloc(),realloc()函数开辟了动态内存空间,我们在不再使用这块空间时就应该及时使用free()函数将它释放掉,以免造成内存泄漏.
内存泄漏：如果动态开辟的内存没有被释放，那么这些内存就会一直占用系统资源，从而导致内存泄漏。内存泄漏会导致程序运行速度变慢，甚至崩溃。
1.使用free()函数完成malloc()开辟空间的释放 如下,我们使用free()函数将malloc()开辟空间的释放掉:
给free()函数传入:malloc()函数动态开辟的指针(即p).
int main() { int* p = (int*)malloc(sizeof(int)*10); //开辟10个整型大小空间 if (p == NULL) //如果开辟失败,则打印错误原因 { //打印错误原因的一个方式 printf(&#34;%s\n&#34;, strerror(errno)); } else { int i = 0; for (i = 0; i &lt; 10; i&#43;&#43;) //遍历赋值并打印这10个整型空间 { *(p &#43; i) = i; printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-29T19:56:28+08:00">
    <meta property="article:modified_time" content="2023-10-29T19:56:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】free()函数详解(动态内存释放函数)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>🦄<strong>个人主页</strong>:<a href="https://blog.csdn.net/weixin_72357342?type=blog" title="修修修也">修修修也</a></p> 
 <p>🎏<strong>所属专栏</strong>:<a href="https://blog.csdn.net/weixin_72357342/category_12452473.html" title="C语言">C语言</a></p> 
 <p>⚙️<strong>操作环境</strong>:<strong>Visual Studio 2022</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/03/05/JT87Zlvo_o.gif"></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E4%B8%80.free()%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80.free%28%29%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B" rel="nofollow"> 一.free()函数简介</a></p> 
<p id="1.%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#1.%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD" rel="nofollow">1.函数功能</a></p> 
<p id="2.%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" rel="nofollow">2.函数参数</a></p> 
<p id="void%20*%20ptr-toc" style="margin-left:80px;"><a href="#void%20*%20ptr" rel="nofollow">void * ptr</a></p> 
<p id="3.%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:40px;"><a href="#3.%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow">3.函数返回值</a></p> 
<p id="4.%E5%87%BD%E6%95%B0%E5%A4%B4%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#4.%E5%87%BD%E6%95%B0%E5%A4%B4%E6%96%87%E4%BB%B6" rel="nofollow">4.函数头文件</a></p> 
<p id="%E4%BA%8C.free()%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.free%28%29%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8" rel="nofollow">二.free()函数的具体使用</a></p> 
<p id="1.%E4%BD%BF%E7%94%A8free()%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90malloc()%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#1.%E4%BD%BF%E7%94%A8free%28%29%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90malloc%28%29%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE" rel="nofollow">1.使用free()函数完成malloc()开辟空间的释放</a></p> 
<p id="2.%E4%BD%BF%E7%94%A8free()%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90calloc()%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#2.%E4%BD%BF%E7%94%A8free%28%29%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90calloc%28%29%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE" rel="nofollow">2.使用free()函数完成calloc()开辟空间的释放</a></p> 
<p id="3.%E4%BD%BF%E7%94%A8free()%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90realloc()%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#3.%E4%BD%BF%E7%94%A8free%28%29%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90realloc%28%29%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE" rel="nofollow">3.使用free()函数完成realloc()开辟空间的释放</a></p> 
<p id="%E4%B8%89.free()%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E8%AF%AF%E5%8C%BA-toc" style="margin-left:0px;"><a href="#%E4%B8%89.free%28%29%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E8%AF%AF%E5%8C%BA" rel="nofollow">三.free()函数常见使用误区</a></p> 
<p id="1.%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#1.%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE" rel="nofollow">1.对非动态开辟内存使用free释放</a></p> 
<p id="2.%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86-toc" style="margin-left:40px;"><a href="#2.%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86" rel="nofollow">2.使用free释放一块动态内存的一部分</a></p> 
<p id="3.%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#3.%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE" rel="nofollow">3.对同一块动态内存多次释放</a></p> 
<p id="4.%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%90%8E%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#4.%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%90%8E%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE" rel="nofollow">4.动态开辟内存后忘记释放</a></p> 
<p id="%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD" rel="nofollow">结语</a></p> 
<hr id="hr-toc"> 
<h2>一.free()函数简介</h2> 
<p>我们先来看一下<a href="https://legacy.cplusplus.com/" rel="nofollow" title="cplusplus.com - The C++ Resources Network">cplusplus.com - The C++ Resources Network</a>网站上<strong>free()函数</strong>的基本信息：</p> 
<p><img alt="" height="573" src="https://images2.imgbox.com/d5/e5/HiQtGnPx_o.png" width="1148"></p> 
<h3 id="1.%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD">1.函数功能</h3> 
<blockquote> 
 <p>可以看到,<strong>free()函数</strong>的功能是:<span style="color:#fe2c24;"><strong>释放以前由malloc(),calloc(),realloc()函数动态开辟的内存空间.使其可以重新被分配.</strong></span></p> 
</blockquote> 
<h3 id="2.%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">2.函数参数</h3> 
<p>该函数有<strong>1个参数</strong>,是:</p> 
<pre><code class="language-cpp">void free (void* ptr);</code></pre> 
<h4 id="void%20*%20ptr">void * ptr</h4> 
<blockquote> 
 <p>该<strong>参数的类型</strong>是<span style="color:#fe2c24;"><strong>无类型指针(void*)</strong></span>,它<span style="color:#fe2c24;"><strong>指向先前由malloc(),calloc(),realloc()动态分配的内存块</strong></span>,它的作用是<strong>告诉函数要释放的内存块的起始位置</strong>.</p> 
</blockquote> 
<h3 id="3.%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">3.函数返回值</h3> 
<blockquote> 
 <p>函数的<strong>返回值类型</strong>是<span style="color:#fe2c24;"><strong>空(void)</strong></span>,它表示函数在运行结束后<strong>不需要返回值</strong>.</p> 
</blockquote> 
<h3 id="4.%E5%87%BD%E6%95%B0%E5%A4%B4%E6%96%87%E4%BB%B6">4.函数头文件</h3> 
<blockquote> 
 <p>该函数包含在<strong>头文件&lt;stdlib.h&gt;</strong>中.</p> 
</blockquote> 
<h2 id="%E4%BA%8C.free()%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8">二.free()函数的具体使用</h2> 
<p>free()函数的使用场景是:当我们先前<strong>使用了malloc(),calloc(),realloc()函数开辟了动态内存空间</strong>,我们在<strong>不再使用这块空间时</strong>就应该<strong><span style="color:#fe2c24;">及时使用free()函数将它释放掉</span></strong>,以免造成内存泄漏.</p> 
<blockquote> 
 <p><strong>内存泄漏：如果动态开辟的内存没有被释放，那么这些内存就会一直占用系统资源，从而导致内存泄漏。内存泄漏会导致程序运行速度变慢，甚至崩溃。</strong></p> 
</blockquote> 
<h3 id="1.%E4%BD%BF%E7%94%A8free()%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90malloc()%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE">1.使用free()函数完成malloc()开辟空间的释放</h3> 
<p>如下,我们使用free()函数<strong>将malloc()开辟空间的释放掉</strong>:</p> 
<p>给free()函数传入:<strong><span style="background-color:#fbd4d0;">malloc()函数动态开辟的指针</span></strong>(即p).</p> 
<pre><code class="language-cpp">int main()
{
    int* p = (int*)malloc(sizeof(int)*10);    //开辟10个整型大小空间
    if (p == NULL)       //如果开辟失败,则打印错误原因
    {
        //打印错误原因的一个方式
        printf("%s\n", strerror(errno));
    }
    else
    {
        int i = 0;
        for (i = 0; i &lt; 10; i++)    //遍历赋值并打印这10个整型空间
        {
            *(p + i) = i;
            printf("%d ", *(p + i));
        }
        //可以正常使用p指针来操作这片空间了
    }

    free(p);    //释放p的内存空间
    p = NULL;         //将指针p置为NULL,防止其变成野指针

    return 0;
}</code></pre> 
<p>在vs编译器中运行查看结果:</p> 
<p><img alt="" height="885" src="https://images2.imgbox.com/61/9f/CdOijZXB_o.png" width="965"></p> 
<blockquote> 
 <p>虽然这里free()将malloc()动态开辟的内存释放后好像也没有发生什么变化,但如果我们因此<strong>不释放之前malloc()动态开辟的空间</strong>,那么<span style="color:#fe2c24;"><strong>这块空间就会一直占用着内存</strong></span>,既没有用,也没法让其他人使用.</p> 
</blockquote> 
<blockquote> 
 <p>还有一点需要注意的是,我们<strong>在free()完p指向的空间后</strong>,最好<span style="color:#fe2c24;"><strong>将p的内容置为NULL</strong></span>,否则<strong>这块空间已经被释放掉了</strong>,但你<strong>还保存着这块空间的地址</strong>,后续如果不小心再<strong>访问p</strong>的话,就会<strong>造成非法访问</strong>.</p> 
</blockquote> 
<hr> 
<h3 id="2.%E4%BD%BF%E7%94%A8free()%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90calloc()%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE">2.使用free()函数完成calloc()开辟空间的释放</h3> 
<p>如下,我们使用free()函数<strong>将calloc()开辟空间的释放掉</strong>:</p> 
<p>给free()函数传入:<strong><span style="background-color:#fbd4d0;">calloc()动态开辟的内存指针</span></strong>(即p).</p> 
<pre><code class="language-cpp">int main()
{
    int* p = (int*)calloc(10,sizeof(int));    //开辟10个整型大小空间
    if (p == NULL)       //如果开辟失败,则打印错误原因
    {
        //打印错误原因的一个方式
        printf("%s\n", strerror(errno));
    }
    else
    {
        int i = 0;
        for (i = 0; i &lt; 10; i++)    //遍历并打印这10个整型空间
        {
            printf("%d ", *(p + i));//因为calloc()开辟的空间会自动初始化,所以我们可以不初始化这块空间,直接打印
        }
        //可以正常使用p指针来操作这片空间了
    }

    free(p);    //释放p的内存空间
    p = NULL;         //将指针p置为NULL,防止其变成野指针

    return 0;
}

</code></pre> 
<p>在vs编译器中运行查看结果:</p> 
<p><img alt="" height="910" src="https://images2.imgbox.com/80/a2/TbXnzqsC_o.png" width="959"></p> 
<p>释放calloc()开辟的空间和malloc()一样,看不出来必要性,但却是非常有必要的.</p> 
<hr> 
<h3 id="3.%E4%BD%BF%E7%94%A8free()%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90realloc()%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E9%87%8A%E6%94%BE">3.使用free()函数完成realloc()开辟空间的释放</h3> 
<p>如下,我们使用free()函数<strong>将realloc()开辟空间的释放掉</strong>:</p> 
<p>分别给free()函数传入:<strong><span style="background-color:#fbd4d0;">realloc()扩容后的内存块指针</span></strong>(即p).</p> 
<pre><code class="language-cpp">int main()
{
    int* p = (int*)calloc(10,sizeof(int));    //开辟10个整型大小空间
    if (p == NULL)       //如果开辟失败,则打印错误原因
    {
        //打印错误原因的一个方式
        printf("%s\n", strerror(errno));
    }
    else
    {
        int i = 0;
        for (i = 0; i &lt; 10; i++)    //遍历并打印这10个整型空间
        {
            printf("%d ", *(p + i));//因为calloc()开辟的空间会自动初始化,所以我们可以不初始化这块空间,直接打印
        }
        //可以正常使用p指针来操作这片空间了
    }
    printf("\n");
    p = (int*)realloc(p, 15 * sizeof(int));//将这块空间扩容到15个整型
    if (p == NULL)
    {
        printf("%s\n", strerror(errno));
    }
    else
    {
        int i = 0;
        for (i = 0; i &lt; 15; i++)    //遍历并打印这15个整型空间
        {
            printf("%d ", *(p + i));
        }
    }

    free(p);    //释放p的内存空间
    p = NULL;         //将指针p置为NULL,防止其变成野指针

    return 0;
}
</code></pre> 
<p>在vs编译器中运行查看结果:</p> 
<p><img alt="" height="1087" src="https://images2.imgbox.com/a3/55/Jm6bStdt_o.png" width="1200"></p> 
<blockquote> 
 <p>由<strong>realloc()扩容的内存块</strong>,<span style="color:#fe2c24;"><strong>扩容前的数据会保留</strong></span>,但<span style="color:#fe2c24;"><strong>新扩容的空间不会初始化</strong></span>,因此<strong>后面五个元素打印出的值是随机值.</strong></p> 
</blockquote> 
<hr> 
<h2 id="%E4%B8%89.free()%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E8%AF%AF%E5%8C%BA">三.free()函数常见使用误区</h2> 
<h3 id="1.%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE">1.对非动态开辟内存使用free释放</h3> 
<p>因为<strong>p是由编译器分配到栈区</strong>的,<strong>不属于堆区</strong>,因此<span style="color:#fe2c24;"><strong>不能使用free释放</strong></span>.</p> 
<pre><code class="language-cpp">void test()
{
    int a = 10;
    int *p = &amp;a;
    free(p);      //p不是动态开辟的,不能释放
}</code></pre> 
<p> 使用vs2022测试一下:</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/07/aa/r7w7DMzU_o.png" width="501"></p> 
<blockquote> 
 <p>可以看到,该错误导致了程序出错.</p> 
 <p>而图中的<strong>报错"已执行断点指令"则是因为代码执行过程中出现了未定义的非法行为</strong>.</p> 
</blockquote> 
<hr> 
<h3 id="2.%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">2.使用free释放一块动态内存的一部分</h3> 
<p>如下代码:</p> 
<pre><code class="language-cpp">void test()
{
    int *p = (int *)malloc(100);
    p++;
    free(p);        //p不再指向动态内存的起始位置
}</code></pre> 
<p> 在vs2022中测试一下:</p> 
<p><img alt="" height="612" src="https://images2.imgbox.com/5d/ef/g0SV9F8c_o.png" width="938"></p> 
<p>可以看到,该错误导致了<strong>程序异常终止</strong>.</p> 
<hr> 
<h3 id="3.%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE">3.对同一块动态内存多次释放</h3> 
<p>如下代码:</p> 
<pre><code class="language-cpp">void test()
{
    int *p = (int *)malloc(100);
    free(p);
    free(p);     //重复释放
}</code></pre> 
<p> 在vs2022中进行测试:<img alt="" height="608" src="https://images2.imgbox.com/e4/ca/RGIPG604_o.png" width="923"></p> 
<p>可以看到,该错误导致了<strong>程序出错</strong>.</p> 
<blockquote> 
 <p>这里列出了<strong>两个防止重复释放的小技巧</strong>:</p> 
 <ul><li><strong>在设计时尽量遵从:谁开辟,谁回收的原则</strong></li><li><strong>在free完后立刻将原动态开辟的指针置为NULL.</strong></li></ul> 
</blockquote> 
<hr> 
<h3 id="4.%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%90%8E%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE">4.动态开辟内存后忘记释放</h3> 
<p>如下代码:</p> 
<pre><code class="language-cpp">void test()
{
    int *p = (int *)malloc(100);
    if(NULL != p)
    {
        *p = 20;
    }
    //没有释放!
}

int main()
{
    test();
}</code></pre> 
<p> 如果动态开辟的内存忘记释放,程序不会报错,但<strong>会造成内存泄漏</strong>!</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>忘记释放不再使用的动态开辟的空间会造成内存泄漏.</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><strong>内存泄漏：如果动态开辟的内存没有被释放，那么这些内存就会一直占用系统资源，从而导致内存泄漏。内存泄漏会导致程序运行速度变慢，甚至崩溃。</strong></p> 
</blockquote> 
<p>因此:</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>动态开辟的空间一定要释放,并且正确释放!</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>动态开辟的空间一定要释放,并且正确释放!</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>动态开辟的空间一定要释放,并且正确释放!</strong></span></p> 
</blockquote> 
<hr> 
<h2 id="%E7%BB%93%E8%AF%AD" style="background-color:transparent;">结语</h2> 
<p><strong>希望这篇free()函数详解能对大家有所帮助,欢迎大佬们留言或私信与我交流.</strong></p> 
<p><strong>有关更多动态开辟相关知识可以移步:</strong></p> 
<p><strong><a class="link-info has-card" href="https://blog.csdn.net/weixin_72357342/article/details/134099965?spm=1001.2014.3001.5502" title="【C语言】内存的动态分配与释放"><span class="link-card-box"><span class="link-title">【C语言】内存的动态分配与释放</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/7a/7e/QKevDxNJ_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/weixin_72357342/article/details/134099965?spm=1001.2014.3001.5502</span></span></a></strong></p> 
<p><strong>学海漫浩浩,我亦苦作舟!关注我,大家一起学习,一起进步!</strong></p> 
<blockquote> 
 <p>相关文章推荐</p> 
 <p><a href="https://blog.csdn.net/weixin_72357342/article/details/133971625?spm=1001.2014.3001.5502" title="【C语言】malloc()函数详解(动态内存开辟函数)">【C语言】malloc()函数详解(动态内存开辟函数)</a></p> 
 <p><a href="https://blog.csdn.net/weixin_72357342/article/details/133975646" title="【C语言】realloc()函数详解(动态内存开辟函数)">【C语言】realloc()函数详解(动态内存开辟函数)</a></p> 
 <p><a href="https://blog.csdn.net/weixin_72357342/article/details/133975677" title="【C语言】calloc()函数详解(动态内存开辟函数)">【C语言】calloc()函数详解(动态内存开辟函数)</a></p> 
 <p><a href="https://blog.csdn.net/weixin_72357342/article/details/133975657" title="【C语言】free()函数详解(动态内存释放函数)">【C语言】free()函数详解(动态内存释放函数)</a></p> 
 <p><a href="https://blog.csdn.net/weixin_72357342/article/details/132104889?spm=1001.2014.3001.5502" title="【C语言】memcpy()函数">【C语言】memcpy()函数</a></p> 
 <p><a href="https://blog.csdn.net/weixin_72357342/article/details/133953145?spm=1001.2014.3001.5502" title="【数据结构实战项目】C语言实现数据结构顺序表万字详解(附完整运行代码)">【数据结构实战项目】C语言实现数据结构顺序表万字详解(附完整运行代码)</a></p> 
 <p><a href="https://blog.csdn.net/weixin_72357342/article/details/133822893?spm=1001.2014.3001.5502" title="【实用编程技巧】不想改bug?初学者必须学会使用的报错函数assert!(断言函数详解)">【实用编程技巧】不想改bug?初学者必须学会使用的报错函数assert!(断言函数详解)</a></p> 
</blockquote> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a4/af/R9eagzrd_o.jpg">​</p> 
<hr> 
<p><strong>C语言动态内存开辟相关库函数思维导图:</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/77/c0/pFPiOimn_o.png">​</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4ca067afff5b7731974c0d0db7798b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java后端返回数据给前端时去除值为空或NULL的属性、忽略某些属性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b78a544f01a9165480f0203247d44a92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MAC安装stable diffusion</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>