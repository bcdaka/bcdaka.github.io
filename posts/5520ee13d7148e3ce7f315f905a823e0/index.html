<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c＋＋初阶知识——类和对象（中） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5520ee13d7148e3ce7f315f905a823e0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c＋＋初阶知识——类和对象（中）">
  <meta property="og:description" content="目录
1.类的默认成员函数
2.构造函数 3.析构函数 4.拷贝构造函数
5.运算符重载 5.1 赋值运算符重载 5.2 使用运算符重载等特性实现日期类
6.取地址运算符重载
6.1 const成员函数 6.2 取地址运算符重载
1.类的默认成员函数 默认成员函数就是⽤⼾没有显式实现，编译器会⾃动⽣成的成员函数称为默认成员函数。⼀个类，我们不写的情况下编译器会默认⽣成以下6个默认成员函数，需要注意的是这6个中最重要的是前4个，最后两个取地址重载不重要，我们稍微了解⼀下即可。其次就是C&#43;&#43;11以后还会增加两个默认成员函数，移动构造和移动赋值，这个我们后⾯再讲解。默认成员函数很重要，也⽐较复杂，我们要从两个⽅⾯去学习：
第一：我们不写时，编译器默认⽣成的函数⾏为是什么，是否满⾜我们的需求。 第二：编译器默认⽣成的函数不满⾜我们的需求，我们需要⾃⼰实现，那么如何⾃⼰实现？
2.构造函数 构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是构造函数的主要任务并不是开空间创建对象(我们常使⽤的局部对象是栈帧创建时，空间就开好了)，⽽是对象实例化时初始化对象。构造函数的本质是要替代我们以前Stack和Date类中写的Init函数的功能，构造函数⾃动调⽤的特点就完美的替代的了Init。
构造函数的特点：
（1）函数名与类名相同。
（2）⽆返回值。 (返回值啥都不需要给，也不需要写void，不要纠结，C&#43;&#43;规定如此)
（3）对象实例化时系统会⾃动调⽤对应的构造函数。
（4）构造函数可以重载。
（5）如果类中没有显式定义构造函数，则C&#43;&#43;编译器会⾃动⽣成⼀个⽆参的默认构造函数，⼀旦⽤户显式定义编译器将不再⽣成。
（6）⽆参构造函数、全缺省构造函数、我们不写构造时编译器默认⽣成的构造函数，都叫做默认构造函数。但是这三个函数有且只有⼀个存在，不能同时存在。⽆参构造函数和全缺省构造函数虽然构成函数重载，但是调⽤时会存在歧义。要注意很多同学会认为默认构造函数是编译器默认⽣成那个叫默认构造，实际上⽆参构造函数、全缺省构造函数也是默认构造，总结⼀下就是不传实参就可以调⽤的构造就叫默认构造。
（7）我们不写，编译器默认⽣成的构造，对内置类型成员变量的初始化没有要求，也就是说是是否初始化是不确定的，看编译器。对于⾃定义类型成员变量，要求调⽤这个成员变量的默认构造函数初始化。如果这个成员变量，没有默认构造函数，那么就会报错，我们要初始化这个成员变量，需要⽤初始化列表才能解决，初始化列表，我们下个章节再细细讲解。
说明：C&#43;&#43;把类型分成内置类型(基本类型)和⾃定义类型。内置类型就是语⾔提供的原⽣数据类型，如：int/char/double/指针等，⾃定义类型就是我们使⽤class/struct等关键字⾃⼰定义的类型。
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;iostream&gt; using namespace std; class Date { public: // 1.⽆参构造函数 Date() { _year = 1; _month = 1; _day = 1; } // 2.带参构造函数 Date(int year, int month, int day) { _year = year; _month = month; _day = day; } // 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-16T03:41:14+08:00">
    <meta property="article:modified_time" content="2024-07-16T03:41:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c＋＋初阶知识——类和对象（中）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#1.%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">1.类的默认成员函数</a></p> 
<p id="2.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:0px;"><a href="#2.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">2.构造函数 </a></p> 
<p id="3.%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:0px;"><a href="#3.%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">3.析构函数 </a></p> 
<p id="4.%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#4.%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">4.拷贝构造函数</a></p> 
<p id="5.%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0-toc" style="margin-left:0px;"><a href="#5.%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0" rel="nofollow">5.运算符重载 </a></p> 
<p id="5.1%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0-toc" style="margin-left:40px;"><a href="#5.1%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0" rel="nofollow">5.1 赋值运算符重载 </a></p> 
<p id="5.2%20%E4%BD%BF%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%AD%89%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%97%A5%E6%9C%9F%E7%B1%BB-toc" style="margin-left:40px;"><a href="#5.2%20%E4%BD%BF%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%AD%89%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%97%A5%E6%9C%9F%E7%B1%BB" rel="nofollow">5.2 使用运算符重载等特性实现日期类</a></p> 
<p id="%C2%A06.%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px;"><a href="#%C2%A06.%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow"> 6.取地址运算符重载</a></p> 
<p id="6.1%C2%A0const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:40px;"><a href="#6.1%C2%A0const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">6.1 const成员函数 </a></p> 
<p id="6.2%20%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#6.2%20%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">6.2 取地址运算符重载</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" style="background-color:transparent;">1.类的默认成员函数</h2> 
<p>       默认成员函数就是⽤⼾没有显式实现，编译器会⾃动⽣成的成员函数称为默认成员函数。⼀个类，我们不写的情况下编译器会默认⽣成以下6个默认成员函数，需要注意的是这6个中最重要的是前4个，最后两个取地址重载不重要，我们稍微了解⼀下即可。其次就是C++11以后还会增加两个默认成员函数，移动构造和移动赋值，这个我们后⾯再讲解。默认成员函数很重要，也⽐较复杂，我们要从两个⽅⾯去学习：</p> 
<p>第一：<strong>我们不写时，编译器默认⽣成的函数⾏为是什么，是否满⾜我们的需求。</strong> </p> 
<p>第二<strong>：编译器默认⽣成的函数不满⾜我们的需求，我们需要⾃⼰实现，那么如何⾃⼰实现？</strong></p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/41/15/ulXE9yeP_o.png" width="1200"></p> 
<h2 id="2.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0">2.构造函数 </h2> 
<p>构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是构造函数的主要任务并不是开空间创建对象(我们常使⽤的局部对象是栈帧创建时，空间就开好了)，⽽是对象实例化时初始化对象。构造函数的本质是要替代我们以前Stack和Date类中写的Init函数的功能，构造函数⾃动调⽤的特点就完美的替代的了Init。</p> 
<p><strong>构造函数的特点</strong>：</p> 
<p>（1）函数名与类名相同。</p> 
<p>（2）⽆返回值。 (返回值啥都不需要给，也不需要写void，不要纠结，C++规定如此)</p> 
<p>（3）对象实例化时系统会⾃动调⽤对应的构造函数。</p> 
<p>（4）构造函数可以重载。</p> 
<p>（5）如果类中没有显式定义构造函数，则C++编译器会⾃动⽣成⼀个⽆参的默认构造函数，⼀旦⽤户显式定义编译器将不再⽣成。</p> 
<p>（6）⽆参构造函数、全缺省构造函数、我们不写构造时编译器默认⽣成的构造函数，都叫做默认构造函数。但是这三个函数有且只有⼀个存在，不能同时存在。⽆参构造函数和全缺省构造函数虽然构成函数重载，但是调⽤时会存在歧义。要注意很多同学会认为默认构造函数是编译器默认⽣成那个叫默认构造，实际上⽆参构造函数、全缺省构造函数也是默认构造，总结⼀下就是<strong>不传实参就可以调⽤的构造就叫默认构造</strong>。</p> 
<p>（7）我们不写，编译器默认⽣成的构造，对内置类型成员变量的初始化没有要求，也就是说是是否初始化是不确定的，看编译器。对于⾃定义类型成员变量，要求调⽤这个成员变量的默认构造函数初始化。如果这个成员变量，没有默认构造函数，那么就会报错，我们要初始化这个成员变量，需要⽤初始化列表才能解决，初始化列表，我们下个章节再细细讲解。</p> 
<p><strong>说明：C++把类型分成内置类型(基本类型)和⾃定义类型。内置类型就是语⾔提供的原⽣数据类型，如：int/char/double/指针等，⾃定义类型就是我们使⽤class/struct等关键字⾃⼰定义的类型</strong>。</p> 
<p></p> 
<p>  </p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1 
#include&lt;iostream&gt;
using namespace std;
class Date
{
public:
	// 1.⽆参构造函数
	Date()
	{
		_year = 1;
		_month = 1;
		_day = 1;
	}
	// 2.带参构造函数
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	// 3.全缺省构造函数
	/*Date(int year = 1, int month = 1, int day = 1)
	{
	_year = year;
	_month = month;
	_day = day;
	}*/
	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "/" &lt;&lt; _month &lt;&lt; "/" &lt;&lt; _day &lt;&lt; endl;
		
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	// 如果留下三个构造中的第⼆个带参构造，第⼀个和第三个注释掉
	// 编译报错：error C2512: “Date”: 没有合适的默认构造函数可⽤
	Date d1;
	// 调⽤默认构造函数
	Date d2(2025, 1, 1); // 调⽤带参的构造函数
	// 注意：如果通过⽆参构造函数创建对象时，对象后⾯不⽤跟括号，否则编译器⽆法
	// 区分这⾥是函数声明还是实例化对象
	// warning C4930: “Date d3(void)”: 未调⽤原型函数(是否是有意⽤变量定义的?)
	Date d3();
	d1.Print();
	d2.Print();
	return 0;
}</code></pre> 
<h2 id="3.%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0">3.析构函数 </h2> 
<p>析构函数与构造函数功能相反，析构函数不是完成对对象本⾝的销毁，⽐如局部对象是存在栈帧的，函数结束栈帧销毁，他就释放了，不需要我们管，C++规定对象在销毁时会⾃动调⽤析构函数，完成对象中资源的清理释放⼯作。析构函数的功能类⽐我们之前Stack实现的Destroy功能，⽽像Date没有Destroy，其实就是没有资源需要释放，所以严格说Date是不需要析构函数的。</p> 
<p><strong>析构函数的特点</strong>：</p> 
<p>（1）析构函数名是在类名前加上字符 ~。</p> 
<p>(2)⽆参数⽆返回值。 (这⾥跟构造类似，也不需要加void)</p> 
<p>(3)⼀个类只能有⼀个析构函数。若未显式定义，系统会⾃动⽣成默认的析构函数。</p> 
<p>(4)对象⽣命周期结束时，系统会⾃动调⽤析构函数。</p> 
<p>(5)跟构造函数类似，我们不写编译器⾃动⽣成的析构函数对内置类型成员不做处理，⾃定类型成员会调⽤他的析构函数。</p> 
<p>(6)还需要注意的是我们显⽰写析构函数，对于⾃定义类型成员也会调⽤他的析构，也就是说⾃定义类型成员⽆论什么情况都会⾃动调⽤析构函数。</p> 
<p>(7)如果类中没有申请资源时，析构函数可以不写，直接使⽤编译器⽣成的默认析构函数，如Date；<strong>如果默认⽣成的析构就可以⽤，也就不需要显⽰写析构</strong>，如MyQueue；但是<strong>有资源申请时，⼀定要⾃⼰写析构，否则会造成资源泄漏</strong>，如Stack。</p> 
<p>(8)⼀个局部域的多个对象，C++规定后定义的先析构。</p> 
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Data
{
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Data d1;
	Data d2;//先析构d2


	return 0;
}</code></pre> 
<h2 id="4.%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.拷贝构造函数</h2> 
<p>    如果⼀个构造函数的第⼀个参数是⾃⾝类类型的引⽤，且任何额外的参数都有默认值，则此构造函数也叫做拷⻉构造函数，也就是说拷⻉构造是⼀个特殊的构造函数。</p> 
<p><strong>拷贝构造函数的特点</strong>：</p> 
<p>1. 拷⻉构造函数是构造函数的⼀个重载。</p> 
<p>2.拷⻉构造函数的第一个参数必须是类类型对象的引⽤，使⽤传值⽅式编译器直接报错，因为语法逻辑上会引发⽆穷递归调⽤。</p> 
<p><img alt="" height="557" src="https://images2.imgbox.com/5c/d3/jBuuJfug_o.png" width="1017"></p> 
<p>3.C++规定⾃定义类型对象进⾏拷⻉⾏为必须调⽤拷⻉构造，所以这⾥⾃定义类型传值传参和传值返回都会调⽤拷⻉构造完成。</p> 
<p>4.若未显式定义拷⻉构造，编译器会⽣成⾃动⽣成拷⻉构造函数。⾃动⽣成的拷⻉构造对内置类型成员变量会完成值拷⻉/浅拷⻉(⼀个字节⼀个字节的拷⻉)，对⾃定义类型成员变量会调⽤他的拷⻉构造。</p> 
<p>5.如果一个自定义类型的成员变量全是内置类型且没有指向什么资源，编译器⾃动⽣成的拷⻉构造就可以完成需要的拷⻉，所以不需要我们显⽰实现拷⻉构造。像Stack这样的类，虽然也都是内置类型，但是_a指向了资源，编译器⾃动⽣成的拷⻉构造完成的值拷⻉/浅拷⻉不符合我们的需求，所以需要我们⾃⼰实现深拷⻉(对指向的资源也进⾏拷⻉)。像MyQueue这样的类型内部主要是⾃定义类型Stack成员，编译器⾃动⽣成的拷⻉构造会调⽤Stack的拷⻉构造，也不需要我们显⽰实现<br> MyQueue的拷⻉构造。这⾥还有⼀个⼩技巧，<strong>如果⼀个类显示实现了析构并释放资源，那么他就<br> 需要显⽰写拷⻉构造，否则就不需要</strong>。</p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/b9/25/L68WKnuj_o.png" width="787"></p> 
<p>6.传值返回会产⽣⼀个临时对象调⽤拷⻉构造，传值引⽤返回，返回的是返回对象的别名(引⽤)，没有产⽣拷⻉。但是如果返回对象是⼀个当前函数局部域的局部对象，函数结束就销毁了，那么使⽤引⽤返回是有问题的，这时的引⽤相当于⼀个野引⽤，类似⼀个野指针⼀样。<strong>传引⽤返回可以减少拷⻉，但是⼀定要确保返回对象，在当前函数结束后还在，才能⽤引⽤返回</strong>。</p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/7e/54/CTSbD33N_o.png" width="816"></p> 
<h2 id="5.%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0">5.运算符重载 </h2> 
<p>（1）当运算符被⽤于类类型的对象时，C++语⾔允许我们通过运算符重载的形式指定新的含义。C++规定类类型对象使⽤运算符时，必须转换成调⽤对应运算符重载，若没有对应的运算符重载，则会编译报错。</p> 
<p>（2）运算符重载是具有特名字的函数，他的名字是由operator和后⾯要定义的运算符共同构成。和其他函数⼀样，它也具有其返回类型和参数列表以及函数体。</p> 
<p>（3）重载运算符函数的参数个数和该运算符作⽤的运算对象数量⼀样多。<strong>⼀元运算符有⼀个参数，⼆元运算符有两个参数，⼆元运算符的左侧运算对象传给第⼀个参数，右侧运算对象传给第⼆个参数</strong>。</p> 
<p>（4）如果⼀个重载运算符函数是成员函数，则它的第⼀个运算对象默认传给隐式的this指针，因此运算符重载作为成员函数时，参数⽐运算对象少⼀个。</p> 
<p>（5）运算符重载以后，其优先级和结合性与对应的内置类型运算符保持⼀致。</p> 
<p>（6）不能通过连接语法中没有的符号来创建新的操作符：⽐如operator@。</p> 
<p>（7）<img alt="" height="32" src="https://images2.imgbox.com/04/60/gclzT9np_o.png" width="367"></p> 
<p> 注意以上5个运算符不能重载。(<strong>选择题⾥⾯常考</strong>，⼤家要记⼀下)• 重载操作符⾄少有⼀个类类型参数，不能通过运算符重载改变内置类型对象的含义，如： intoperator+(int x, int y)</p> 
<p>（8）⼀个类需要重载哪些运算符，是看哪些运算符重载后有意义，⽐如Date类重载operator-就有意义，但是重载operator+就没有意义。</p> 
<h3 id="5.1%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0">5.1 赋值运算符重载 </h3> 
<p>   赋值运算符重载是⼀个默认成员函数，⽤于完成两个已经存在的对象直接的拷⻉赋值，这⾥要注意跟拷⻉构造区分，拷⻉构造⽤于⼀个对象拷⻉初始化给另⼀个要创建的对象。</p> 
<p><strong>赋值运算符重载的特点</strong>：</p> 
<p>（1）赋值运算符重载是⼀个运算符重载，规定必须重载为成员函数。赋值运算重载的参数建议写成const 当前类类型引⽤，否则会传值传参会有拷⻉</p> 
<p>（2）有返回值，且建议写成当前类类型引⽤，引⽤返回可以提⾼效率，有返回值⽬的是为了⽀持连续赋值场景。</p> 
<p>（3）没有显式实现时，编译器会⾃动⽣成⼀个默认赋值运算符重载，默认赋值运算符重载⾏为跟默认构造函数类似，对内置类型成员变量会完成值拷⻉/浅拷⻉(⼀个字节⼀个字节的拷⻉)，对⾃定义类型成员变量会调⽤他的拷⻉构造。</p> 
<p>（4）像Date这样的类成员变量全是内置类型且没有指向什么资源，编译器⾃动⽣成的赋值运算符重载就可以完成需要的拷⻉，所以不需要我们显⽰实现赋值运算符重载。像Stack这样的类，虽然也都是内置类型，但是_a指向了资源，编译器⾃动⽣成的赋值运算符重载完成的值拷⻉/浅拷⻉不符合我们的需求，所以需要我们⾃⼰实现深拷⻉(对指向的资源也进⾏拷⻉)。像MyQueue这样的类型内部主要是⾃定义类型Stack成员，编译器⾃动⽣成的赋值运算符重载会调⽤Stack的赋值运算符重载，也不需要我们显⽰实现MyQueue的赋值运算符重载。这⾥还有⼀个⼩技巧，如果⼀个类显示实现了析构并释放资源，那么他就需要显⽰写赋值运算符重载，否则就不需要。</p> 
<h3 id="5.2%20%E4%BD%BF%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%AD%89%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%97%A5%E6%9C%9F%E7%B1%BB">5.2 使用运算符重载等特性实现日期类</h3> 
<p>Data.h :</p> 
<pre><code class="hljs">#pragma once
#include&lt;iostream&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;
using namespace std;

class Data
{
public:
	Data(int year = 1900, int month = 1, int day = 1);
	bool CheckData()
	{
		if (_day&lt;1 || _day&gt;GetMonthDay(_year, _month) || 1 &lt; _month &gt; 12)
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	Data(const Data&amp; d1)
	{
		_year = d1._year;
	   _month = d1._month;
		 _day =d1._day;
	}
	void print();

	int GetMonthDay(int year, int month)
	{
		assert(month &gt; 0 &amp;&amp; month &lt; 13);
		static int MonthDay[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
	
	
	if (month == 2 &amp;&amp; ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || (year % 400 == 0)))
	{
		return 29;
	}
		return MonthDay[month];
	}//默认内联

	bool operator&lt;(const Data&amp; d) const;
	bool operator&lt;=(const Data&amp; d) const;
	bool operator&gt;(const Data&amp; d) const;
	bool operator&gt;=(const Data&amp; d) const;
	bool operator==(const Data&amp; d) const;
	bool operator!=(const Data&amp; d) const;

	Data operator+(int day);
	Data&amp; operator+=(int day);
	Data operator-(int day);
	Data&amp; operator-=(int day);

	Data operator++(int);//后置
	Data&amp; operator++();

	Data operator--(int);//后置
	Data&amp; operator--();

	int operator-(const Data&amp; d);

private:
	int _year;
	int _month;
	int _day;
};
</code></pre> 
<p>Data.cpp :</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include"Data.h"
Data Data::operator-(int day)
{
   
	Data tmp = *this;
	tmp += day;
	return tmp;
}

Data&amp; Data::operator-=(int day)
{
	if (day &lt; 0)
	{
		return *this += (-day);
	}
	_day -= day;
	while(_day &lt; 0)
	{
		_month--;
		if (_month == 0)
		{
			_year--;
			_month = 12;
		}
		_day += GetMonthDay(_year, _month);
	}
	return *this;
}

Data Data::operator+(int day)
{
	
	Data tmp=*this;
	tmp += day;
	/*while (tmp._day &gt; GetMonthDay(tmp._year, tmp._month))
	{
		tmp._day -= GetMonthDay(tmp._year, tmp._month);
		tmp._month++;
		if (tmp._month == 13)
		{
			tmp._year++;
			tmp._month = 1;
		}
	}*/
	return tmp;
}
//+号重载不需要改变对象的值
//所以不能传this指针回去
//而使用中间变量的话，由于这个中间变量是一个
//局部对象，出了作用域就销毁,所以我们不能使用引用返回
//否则会造成野引用

Data&amp; Data::operator+=(int day)
{
	if (day &lt; 0)
	{
		*this -= (-day);
		return *this;
	}
	_day += day;
	while(_day &gt; GetMonthDay(_year, _month))
	{
		_day -= GetMonthDay(_year, _month);
		_month++;
		if (_month == 13)
		{
			_year++;
			_month = 1;
		}
	}
	return *this;
}
//+=需要改变对象的值
//传引用返回是因为this指向的对象出了作用域
//仍然存在，而刚好传引用是比传值更加高效的做法

Data::Data(int year, int month, int day)
{
	_year = year;
	_month = month;
	_day = day;
	if (!CheckData())
	{
		cout &lt;&lt; "非法日期:";
		print();

	}
}
//构造成员函数
void Data::print()
{
	cout &lt;&lt; _year &lt;&lt; "/" &lt;&lt; _month &lt;&lt; "/" &lt;&lt; _day &lt;&lt; endl;
}
//输出成员函数


bool Data::operator&lt;(const Data&amp; d) const
{
	if(_year &lt; d._year)
	{
		return true;
	}
	else if (_year == d._year)
	{
		if (_month &lt; d._month)
		{
			return true;
		}
		else if (_month == d._month)
		{
			if (_day &lt; d._day)
			{
				return true;
			} 
		}
	}
	return false;
}
bool Data::operator&lt;=(const Data&amp; d) const
{
	return *this &lt; d || *this == d;
}
bool Data::operator&gt;(const Data&amp; d) const
{
	return !(*this &lt;= d);
}
bool Data::operator&gt;=(const Data&amp; d) const
{
	return !(*this &lt; d);
}
bool Data::operator==(const Data&amp; d) const
{
	return _year == d._year &amp;&amp; _month == d._month &amp;&amp; _day == d._day;
}
bool Data::operator!=(const Data&amp; d) const
{
	return !(*this == d);
}

Data Data::operator++(int)//后置
{
	Data tmp = *this;
		*this += 1;
		return tmp;

}
Data Data::operator--(int)//后置
{
	Data tmp = *this;
	*this -= 1;
	return tmp;
}
Data&amp; Data::operator--()
{
	*this -= 1;
	return *this;
}
Data&amp; Data::operator++()
{
	*this += 1;
	return *this;
}

int Data::operator-(const Data&amp; d)
{
	int flag = 1;
	Data max = *this;
	Data min = d;
	if (d &gt; *this)
	{
		max = d;
		min = *this;
		flag = -1;
	}
	int n = 0;
	while (min != max)
	{
		++min;
		++n;
	}
	return flag * n;
}
</code></pre> 
<p>test.c :</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include"Data.h"
int main()
{
	/*Data d1(2024, 7, 15);
	d1.print();
	Data d2 = d1;
	d2.print();
	Data d3(d1+10100);
	d3.print();*/
	Data d1(2024, 7, 15);
	Data d2(2024, 9, 8);
	
	cout &lt;&lt; d2-d1 &lt;&lt; endl;
	/*Data ret = d1++;
	ret.print();
	d1.print();
	d1 += -100;
	d1.print();*/
	

	return 0;
}</code></pre> 
<h2 id="%C2%A06.%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"> 6.取地址运算符重载</h2> 
<h3 id="6.1%C2%A0const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%C2%A0">6.1 const成员函数 <br></h3> 
<p>（1）将const修饰的成员函数称之为const成员函数，const修饰成员函数放到成员函数参数列表的后⾯。</p> 
<p>（2）const实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进⾏修改。const 修饰Date类的Print成员函数，<strong>Print隐含的this指针由Date* const this变为了const Date* const this</strong>.</p> 
<pre><code class="hljs">#include&lt;iostream&gt;
using namespace std;
class Date
{
public:
Date(int year = 1, int month = 1, int day = 1)
{
_year = year;
_month = month;
_day = day;
}
// void Print(const Date* const this) const
void Print() const
{
cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
}
private:
int _year;
int _month;
int _day;
};
int main()
{
// 这⾥⾮const对象也可以调⽤const成员函数是⼀种权限的缩⼩
Date d1(2024, 7, 5);
d1.Print();
const Date d2(2024, 8, 5);
d2.Print();
return 0;</code></pre> 
<h3 id="6.2%20%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" style="background-color:transparent;">6.2 取地址运算符重载</h3> 
<p>取地址运算符重载分为普通取地址运算符重载和const取地址运算符重载，⼀般这两个函数编译器⾃动⽣成的就可以够我们⽤了，不需要去显⽰实现。除⾮⼀些很特殊的场景，⽐如我们不想让别⼈取到当前类对象的地址，就可以⾃⼰实现⼀份，胡乱返回⼀个地址。</p> 
<pre><code class="hljs">class Date
{
public :
Date* operator&amp;()
{
return this;
// return nullptr;
}
const Date* operator&amp;()const
{
return this;
// return nullptr;
}
private :
int _year ; // 年
int _month ; // ⽉
int _day ; // ⽇
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8841edf05a7a90af37c4bd76ad23684b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于香橙派 AIpro搭建二维码分类模型及其Flask服务—探索OPi AIpro新一代AI开发板出色性能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1bd6f070ff6bc702fde19575a8957d66/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[MySQL][表的增删查改][二][Retrieve][SELECT][WHERE]详细讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>