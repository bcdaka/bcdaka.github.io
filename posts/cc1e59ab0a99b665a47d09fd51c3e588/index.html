<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;干货铺】C&#43;&#43;中的IO流和文件操作 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cc1e59ab0a99b665a47d09fd51c3e588/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;干货铺】C&#43;&#43;中的IO流和文件操作">
  <meta property="og:description" content="=========================================================================
个人主页点击直达：小白不是程序媛
C&#43;&#43;系列专栏：C&#43;&#43;干货铺
代码仓库：Gitee
=========================================================================
目录
C语言的输入输出
流是什么？
C&#43;&#43;的IO流
C&#43;&#43;标准IO流
C&#43;&#43;文件IO流
文本文件读写
二进制文件的读写
stringstream的简单介绍
将数值类型数据格式化为字符串 字符串拼接
​编辑序列化和反序列化结构数据
C语言的输入输出 C语言中我们用到的最频繁的输入输出方式就是scanf ()与printf()。
scanf(): 从标准输入设备(键盘)读取数据，并将值存放在变量中。printf(): 将指定的文字/字符串输出到标准输出设备(屏幕)。 注意宽度输出和精度输出控制。C语言借助了相应的缓冲区来进行输入与输出。
如下图所示： 对输入输出缓冲区的理解：
1.可以屏蔽掉低级I/O的实现，低级I/O的实现依赖操作系统本身内核的实现，所以如果能够屏
蔽这部分的差异，可以很容易写出可移植的程序。
2.可以使用这部分的内容实现“行”读取的行为，对于计算机而言是没有“行”这个概念，有了这
部分，就可以定义“行”的概念，然后解析缓冲区的内容，返回一个“行”。
流是什么？ “流”即是流动的意思，是物质从一处向另一处流动的过程，是对一种有序连续且具有方向性的数据（ 其单位可以是bit,byte,packet ）的抽象描述。C&#43;&#43;流是指信息从外部输入设备（如键盘）向计算机内部（如内存）输入和从内存向外部输出设备（显示器）输出的过程。这种输入输出的过程被形象的比喻为“流”。它的特性是：有序连续、具有方向性 。 C&#43;&#43;的IO流 C&#43;&#43;系统实现了一个庞大的类库，其中ios为基类，其他类都是直接或间接派生自ios类
C&#43;&#43;标准IO流 C&#43;&#43;标准库提供了4个全局流对象cin、cout、cerr、clog，使用cout进行标准输出，即数据从内
存流向控制台(显示器)。使用cin进行标准输入即数据通过键盘输入到程序中，同时C&#43;&#43;标准库还
提供了cerr用来进行标准错误的输出，以及clog进行日志的输出，从上图可以看出，cout、
cerr、clog是ostream类的三个不同的对象，因此这三个对象现在基本没有区别，只是应用场景不
同。在使用时候必须要包含文件并引入std标准命名空间。
注意：
1. cin为缓冲流。键盘输入的数据保存在缓冲区中，当要提取时，是从缓冲区中拿。如果一次输入过多，会留在那儿慢慢用，如果输入错了，必须在回车之前修改，如果回车键按下就无法挽回了。只有把输入缓冲区中的数据取完后，才要求输入新的数据。2. 输入的数据类型必须与要提取的数据类型一致，否则出错。出错只是在流的状态字state中对应位置位（置1），程序继续。3. 空格和回车都可以作为数据之间的分格符，所以多个数据可以在一行输入，也可以分行输入。但如果是字符型和字符串，则空格（ASCII码为32）无法用cin输入，字符串中也不能有空格。回车符也无法读入。4. cin和cout可以直接输入和输出内置类型数据，原因：标准库已经将所有内置类型的输入和输出全部重载了。 对于自定义类型，如果要支持cin和cout的标准输入输出，需要对&lt;&lt;和&gt;&gt;进行重载。 6. 在线OJ中的输入和输出： 对于IO类型的算法，一般都需要循环输入
输出：严格按照题目的要求进行，多一个少一个空格都不行。
连续输入时，vs系列编译器下在输入ctrl&#43;Z时结束
// 单个元素循环输入 while(cin&gt;&gt;a) { // ... } // 多个元素循环输入 while(c&gt;&gt;a&gt;&gt;b&gt;&gt;c) { // ... } // 整行接收 while(cin&gt;&gt;str) { // .">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-27T17:26:47+08:00">
    <meta property="article:modified_time" content="2024-01-27T17:26:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;干货铺】C&#43;&#43;中的IO流和文件操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><strong>=========================================================================</strong></p> 
<p style="text-align:center;"><span style="color:#fe2c24;"><strong>个人主页点击直达：<a class="link-info" href="https://blog.csdn.net/qq_55119554?spm=1000.2115.3001.5343" title="小白不是程序媛">小白不是程序媛</a></strong></span></p> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>C++系列专栏：<a class="link-info" href="https://blog.csdn.net/qq_55119554/category_12451779.html?spm=1001.2014.3001.5482" title="C++干货铺">C++干货铺</a></strong></span></p> 
<p style="text-align:center;"><span style="color:#956fe7;"><strong>代码仓库：<a class="link-info" href="https://gitee.com/LiuDaChengzi" rel="nofollow" title="Gitee">Gitee</a></strong></span></p> 
<p style="text-align:center;"><strong>=========================================================================</strong></p> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fc/f2/qIh1GSwf_o.gif"></h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><strong><a href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" rel="nofollow"><span style="color:#ff9900;">C语言的输入输出</span></a></strong></p> 
<p id="%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><strong><a href="#%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow"><span style="color:#ff9900;">流是什么？</span></a></strong></p> 
<p id="C%2B%2B%E7%9A%84IO%E6%B5%81-toc" style="margin-left:0px;"><strong><a href="#C%2B%2B%E7%9A%84IO%E6%B5%81" rel="nofollow"><span style="color:#ff9900;">C++的IO流</span></a></strong></p> 
<p id="C%2B%2B%E6%A0%87%E5%87%86IO%E6%B5%81-toc" style="margin-left:40px;"><a href="#C%2B%2B%E6%A0%87%E5%87%86IO%E6%B5%81" rel="nofollow">C++标准IO流</a></p> 
<p id="C%2B%2B%E6%96%87%E4%BB%B6IO%E6%B5%81-toc" style="margin-left:40px;"><a href="#C%2B%2B%E6%96%87%E4%BB%B6IO%E6%B5%81" rel="nofollow">C++文件IO流</a></p> 
<p id="%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99-toc" style="margin-left:80px;"><a href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99" rel="nofollow">文本文件读写</a></p> 
<p id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99" rel="nofollow">二进制文件的读写</a></p> 
<p id="stringstream%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><strong><a href="#stringstream%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" rel="nofollow"><span style="color:#ff9900;">stringstream的简单介绍</span></a></strong></p> 
<p id="%E5%B0%86%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%B0%86%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%C2%A0" rel="nofollow">将数值类型数据格式化为字符串 </a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-toc" style="margin-left:40px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5" rel="nofollow">字符串拼接</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE" rel="nofollow">​编辑序列化和反序列化结构数据</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2><span style="color:#ff9900;">C语言的输入输出</span></h2> 
<p>C语言中我们用到的最频繁的输入输出方式就是<strong>scanf ()</strong>与<strong>printf()</strong>。</p> 
<blockquote> 
 <ul><li><strong>scanf():</strong> 从标准输入设备(键盘)读取数据，并将值存放在变量中。</li><li><strong>printf():</strong> 将指定的文字/字符串输出到标准输出设备(屏幕)。</li></ul> 
</blockquote> 
<p>注意宽度输出和精度输出控制。C语言借助了相应的缓冲区来进行输入与输出。</p> 
<p>如下图所示： </p> 
<p><img alt="" height="566" src="https://images2.imgbox.com/e5/52/5BKcsEG7_o.png" width="857"> </p> 
<p><strong>对输入输出缓冲区的理解：</strong></p> 
<blockquote> 
 <p>1.可以屏蔽掉低级I/O的实现，低级I/O的实现依赖操作系统本身内核的实现，所以如果能够屏<br> 蔽这部分的差异，可以很容易写出可移植的程序。<br> 2.可以使用这部分的内容实现“行”读取的行为，对于计算机而言是没有“行”这个概念，有了这<br> 部分，就可以定义“行”的概念，然后解析缓冲区的内容，返回一个“行”。</p> 
</blockquote> 
<hr> 
<h2 id="%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" style="background-color:transparent;"><span style="color:#ff9900;">流是什么？</span></h2> 
<blockquote> 
 <ul><li><strong>“流”</strong>即是流动的意思，是物质从一处向另一处流动的过程，是对一种有序连续且具有方向性的数据（ 其单位可以是<strong>bit,byte,packet</strong> ）的抽象描述。</li><li>C++流是指信息从外部输入设备（如键盘）向计算机内部（如内存）输入和从内存向外部输出设备（显示器）输出的过程。这种输入输出的过程被形象的比喻为“流”。</li><li>它的特性是：<strong>有序连续、具有方向性 。</strong></li></ul> 
</blockquote> 
<hr> 
<h2 id="C%2B%2B%E7%9A%84IO%E6%B5%81" style="background-color:transparent;"><span style="color:#ff9900;">C++的IO流</span></h2> 
<p>C++系统实现了一个庞大的类库，其中<strong>ios为基类</strong>，其他类都是<strong>直接或间接派生自ios类</strong></p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/7b/15/N5XkLdZr_o.png" width="891"></p> 
<h3 id="C%2B%2B%E6%A0%87%E5%87%86IO%E6%B5%81">C++标准IO流</h3> 
<p>C++标准库提供了4个全局流对象cin、cout、cerr、clog，使用cout进行标准输出，即数据从内<br> 存流向控制台(显示器)。使用cin进行标准输入即数据通过键盘输入到程序中，同时C++标准库还<br> 提供了cerr用来进行标准错误的输出，以及clog进行日志的输出，从上图可以看出，cout、<br> cerr、clog是ostream类的三个不同的对象，因此这三个对象现在基本没有区别，只是应用场景不<br> 同。在使用时候必须要包含文件并引入std标准命名空间。</p> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <ul><li>1. cin为缓冲流。键盘输入的数据保存在缓冲区中，当要提取时，是从缓冲区中拿。如果一次输入过多，会留在那儿慢慢用，如果输入错了，必须在回车之前修改，如果回车键按下就无法挽回了。只有把输入缓冲区中的数据取完后，才要求输入新的数据。</li><li>2. 输入的数据类型必须与要提取的数据类型一致，否则出错。出错只是在流的状态字state中对应位置位（置1），程序继续。</li><li>3. 空格和回车都可以作为数据之间的分格符，所以多个数据可以在一行输入，也可以分行输入。但如果是字符型和字符串，则空格（ASCII码为32）无法用cin输入，字符串中也不能有空格。回车符也无法读入。</li><li>4. cin和cout可以直接输入和输出内置类型数据，原因：标准库已经将所有内置类型的输入和输出全部重载了。</li></ul> 
</blockquote> 
<p><img alt="" height="486" src="https://images2.imgbox.com/c8/88/JbJ0D6yy_o.png" width="805"> <img alt="" height="526" src="https://images2.imgbox.com/c3/c0/e2Gr7J4L_o.png" width="856"></p> 
<p>对于自定义类型，如果要支持cin和cout的标准输入输出，<strong>需要对&lt;&lt;和&gt;&gt;进行重载。</strong> </p> 
<ul><li>6. 在线OJ中的输入和输出：</li></ul> 
<blockquote> 
 <p>对于IO类型的算法，一般都需要循环输入<br> 输出：严格按照题目的要求进行，多一个少一个空格都不行。<br> 连续输入时，vs系列编译器下在输入<strong>ctrl+Z</strong>时结束</p> 
</blockquote> 
<pre><code class="hljs">// 单个元素循环输入
while(cin&gt;&gt;a)
{
  // ...
}
// 多个元素循环输入
while(c&gt;&gt;a&gt;&gt;b&gt;&gt;c)
{
  // ...
}
// 整行接收
while(cin&gt;&gt;str)
{
  // ...
}</code></pre> 
<ul><li>7. istream类型对象转换为逻辑条件判断值</li></ul> 
<pre><code class="hljs">istream&amp; operator&gt;&gt; (int&amp; val);
explicit operator bool() const;</code></pre> 
<blockquote> 
 <p>实际上我们看到使用while(cin&gt;&gt;i)去流中提取对象数据时，调用的是operator&gt;&gt;，返回值是<br> istream类型的对象，那么这里可以做逻辑条件值，源自于istream的对象又调用了operator<br> bool，operator bool调用时如果接收流失败，或者有结束标志，则返回false。</p> 
</blockquote> 
<h3 id="C%2B%2B%E6%96%87%E4%BB%B6IO%E6%B5%81">C++文件IO流</h3> 
<p>C++根据文件内容的数据格式分为二进制文件和文本文件。采用文件流对象操作文件的一般步<br> 骤：</p> 
<blockquote> 
 <p>1. 定义一个文件流对象</p> 
 <ul><li>ifstream ifile(只输入用)</li><li>ofstream ofile(只输出用)</li><li>fstream iofile(既输入又输出用)</li></ul> 
 <p>2. 使用文件流对象的成员函数打开一个磁盘文件，使得文件流对象和磁盘文件之间建立联系<br> 3. 使用提取和插入运算符对文件进行读写操作，或使用成员函数进行读写<br> 4. 关闭文件 </p> 
</blockquote> 
<h4 id="%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">文本文件读写</h4> 
<pre><code class="hljs">//文本文件读写

#include&lt;string&gt;
#include&lt;fstream&gt;
//包含头文件
int main()
{
	//创建文件输出流对象
	ofstream fout;
	//打开文件
	//若文件不存在则创建一个新文件进行写入
	fout.open("test.txt");
	//判断文件是否打开
	if (fout.is_open()==false)
	{
		cout &lt;&lt; "打开文件失败" &lt;&lt; endl;
	}
	//对文件进行写入
	fout &lt;&lt; "2024/1/27";
	//关闭文件
	fout.close();
	cout &lt;&lt; "文件写入完成" &lt;&lt; endl;


	//创建文件出入流对象
	ifstream fin;
	string buffer;
	//打开文件
	fin.open("test.txt");
	//判断文件是否存在
	if (fin.is_open() == false)
	{
		cout &lt;&lt; "打开文件失败" &lt;&lt; endl;
	}
	//读取文件中的内容，并且打印
	while (getline(fin, buffer))
	{
		cout &lt;&lt; buffer &lt;&lt; endl;
	}
	cout &lt;&lt; "文件读取完毕" &lt;&lt; endl;
	//关闭文件
	fin.close();
	return 0;
}
</code></pre> 
<p><img alt="" height="576" src="https://images2.imgbox.com/6c/e2/lq6VqXNO_o.png" width="1154"> </p> 
<h4 id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99">二进制文件的读写</h4> 
<pre><code class="hljs">//二进制文件的读写
#include&lt;fstream&gt;
struct st_girl
{
	char name[31];//姓名
	int no;//编号
	char memo[301];//备注
	double weight;//体重
}girl;
int main()
{
	//创建文件输出流对象
	ofstream fout;
	//以二进制的形式打开文件
	fout.open("test.dat", ios::app | ios::binary);
	//判断文件是否打开
	if (fout.is_open() == false)
	{
		cout &lt;&lt; "打开文件失败" &lt;&lt; endl;
	}
	 girl = { "西施",3,"中国历史第一美女",45.8 };
	 //以字符串的形式写入
	 fout.write((const char *) &amp; girl, sizeof(st_girl));
	 cout &lt;&lt; "二进制写入完成" &lt;&lt; endl;
	 //关闭文件
	 fout.close();

	 //创建文件流入对象
	 ifstream fin;
	 //以二进制的形式打开文件
	 fin.open("test.dat", ios::in | ios::binary);
	 //检查文件是否打开
	 if (fin.is_open() == false)
	 {
		 cout &lt;&lt; "打开文件失败" &lt;&lt; endl;
	 }
	 //对文件一字符串的形式进行读取
	 while (fin.read((char*)&amp;girl, sizeof(girl)))

	 {
		 cout &lt;&lt; "name = " &lt;&lt; girl.name &lt;&lt; endl &lt;&lt; " no = " &lt;&lt; girl.no &lt;&lt; endl
			 &lt;&lt; "memo = " &lt;&lt; endl &lt;&lt; "weigth = " &lt;&lt; girl.weight &lt;&lt; endl;
	 }
	 cout &lt;&lt; "以二进制的形式读取结束" &lt;&lt; endl;
	 //关闭文件
	 fin.close();
	return 0;
}</code></pre> 
<p> <img alt="" height="682" src="https://images2.imgbox.com/57/db/YB3h1drv_o.png" width="1105"></p> 
<blockquote> 
 <p>注意：自定义类型中的成员不可以使用STL中的容器，像对于字符使用string来存贮；在同一个进程中写完文件立刻进行读取文件，程序因浅拷贝造成异常；在一个进程中进行写文件，另一个进程中读文件，会造成野指针；因为string的底层是个字符指针，读写文件只会进行浅拷贝。</p> 
</blockquote> 
<hr> 
<h2 id="stringstream%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" style="background-color:transparent;"><span style="color:#ff9900;">stringstream的简单介绍</span></h2> 
<p>在C语言中，如果想要将一个整形变量的数据转化为字符串格式，如何去做？</p> 
<blockquote> 
 <p>1. 使用itoa()函数<br> 2. 使用sprintf()函数</p> 
</blockquote> 
<p>但是两个函数在转化时，都得需要先给出保存结果的空间，那空间要给多大呢，就不太好界定，<br> 而且转化格式不匹配时，可能还会得到错误的结果甚至程序崩溃。 </p> 
<pre><code class="hljs">int main()
{
	int n = 123456789;
	char s1[32];
	_itoa(n, s1, 10);
	char s2[32];
	sprintf(s2, "%d", n);
	char s3[32];
	sprintf(s3, "%f", n);
	return 0;
}</code></pre> 
<p>在C++中，可以使用stringstream类对象来避开此问题。</p> 
<blockquote> 
 <p>在程序中如果想要使用stringstream，必须要包含头文件。在该头文件下，标准库三个类：<br><strong>istringstream、ostringstream 和 stringstream，</strong>分别用来进行流的输入、输出和输入输出操作，下面主要介绍stringstream。</p> 
</blockquote> 
<h3 id="%E5%B0%86%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%C2%A0">将数值类型数据格式化为字符串 </h3> 
<pre><code class="hljs">#include&lt;sstream&gt;
int main()
{
	int a = 12345678;
	string sa;
	// 将一个整形变量转化为字符串，存储到string类对象中
	stringstream s;
	s &lt;&lt; a;
	s &gt;&gt; sa;
	cout &lt;&lt; typeid(sa).name() &lt;&lt; endl;
	cout &lt;&lt; sa &lt;&lt; endl;

	// clear()
// 注意多次转换时，必须使用clear将上次转换状态清空掉
// stringstreams在转换结尾时(即最后一个转换后),会将其内部状态设置为badbit
// 因此下一次转换是必须调用clear()将状态重置为goodbit才可以转换
// 但是clear()不会将stringstreams底层字符串清空掉

// s.str("");
// 将stringstream底层管理string对象设置成"",
// 否则多次转换时，会将结果全部累积在底层string对象中
	s.str("");
	s.clear();
	double d = 12.34;
	s &lt;&lt; d;
	s &gt;&gt; sa;
	cout &lt;&lt; typeid(sa).name() &lt;&lt; endl;
	cout &lt;&lt; sa &lt;&lt; endl;

	return 0;
}</code></pre> 
<p> <img alt="" height="651" src="https://images2.imgbox.com/4f/a7/WjA6728b_o.png" width="1200"></p> 
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">字符串拼接</h3> 
<pre><code class="hljs">int main()
{
	stringstream sstream;
	// 将多个字符串放入 sstream 中
	sstream &lt;&lt; "first" &lt;&lt; " " &lt;&lt; "string,";
	sstream &lt;&lt; " second string";
	cout &lt;&lt; "strResult is: " &lt;&lt; sstream.str() &lt;&lt; endl;
	// 清空 sstream
	sstream.str("");
	sstream &lt;&lt; "third string";
	cout &lt;&lt; "After clear, strResult is: " &lt;&lt; sstream.str() &lt;&lt; endl;
	return 0;
}</code></pre> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE"><img alt="" height="444" src="https://images2.imgbox.com/a9/27/1xkEmK9T_o.png" width="661">序列化和反序列化结构数据</h3> 
<pre><code class="hljs">struct ChatInfo
{
	string _name; // 名字
	int _id;    // id
	Date _date;  // 时间
	string _msg;  // 聊天信息
};
int main()
{
	// 结构信息序列化为字符串
	ChatInfo winfo = { "张三", 135246, { 2022, 4, 10 }, "晚上一起看电影吧"
	};
	ostringstream oss;
	oss &lt;&lt; winfo._name &lt;&lt; " " &lt;&lt; winfo._id &lt;&lt; " " &lt;&lt; winfo._date &lt;&lt; " "
		&lt;&lt; winfo._msg;
	string str = oss.str();
	cout &lt;&lt; str &lt;&lt; endl &lt;&lt; endl;
	// 我们通过网络这个字符串发送给对象，实际开发中，信息相对更复杂，
	  // 一般会选用Json、xml等方式进行更好的支持
	// 字符串解析成结构信息
	ChatInfo rInfo;
	istringstream iss(str);
	iss &gt;&gt; rInfo._name &gt;&gt; rInfo._id &gt;&gt; rInfo._date &gt;&gt; rInfo._msg;
	cout &lt;&lt; "-------------------------------------------------------"
		&lt;&lt; endl;
	cout &lt;&lt; "姓名：" &lt;&lt; rInfo._name &lt;&lt; "(" &lt;&lt; rInfo._id &lt;&lt; ") ";
	cout &lt;&lt; rInfo._date &lt;&lt; endl;
	cout &lt;&lt; rInfo._name &lt;&lt; ":&gt;" &lt;&lt; rInfo._msg &lt;&lt; endl;
	cout &lt;&lt; "-------------------------------------------------------"
		&lt;&lt; endl;
	return 0;
}</code></pre> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <ul><li>1. stringstream实际是在其底层维护了一个string类型的对象用来保存结果。</li><li>2. 多次数据类型转化时，一定要用clear()来清空，才能正确转化，但clear()不会将stringstream底层的string对象清空。</li><li>3. 可以使用s. str("")方法将底层string对象设置为""空字符串。</li><li>4. 可以使用s.str()将让stringstream返回其底层的string对象。</li><li>5. stringstream使用string类对象代替字符数组，可以避免缓冲区溢出的危险，而且其会对参数类型进行推演，不需要格式化控制，也不会出现格式化失败的风险，因此使用更方便，更安全。 </li></ul> 
</blockquote> 
<hr> 
<p>今天给大家分享介绍了C++中的IO流和文件操作。如果觉得文章还不错的话，可以三连支持一下，<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>还有很多有趣的文章，欢迎小伙伴们前去点评，您的三连支持就是我前进的动力！ </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e06bfce4d2f0beada874ee721c450568/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">神器 VS Code，超详细 Python 配置使用指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e37aa2c45a7af2a1f002936be8c4087e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能顶会ICLR 2024热门研究方向大揭秘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>