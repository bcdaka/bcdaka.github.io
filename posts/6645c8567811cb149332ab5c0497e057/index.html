<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; —— 关于类和对象（上） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6645c8567811cb149332ab5c0497e057/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43; —— 关于类和对象（上）">
  <meta property="og:description" content="1.类的定义格式 1. class为定义类的关键字，Stack为类的名字，{}中为类的主体，注意类定义结束时后⾯分号不能省略。
class Stack { } 类体中内容称为类的成员：类中的变量称为类的属性或成员变量; 类中的函数称为类的方法或者成员函数，class关键字定义与结构体非常类似，只不过是比结构体能多定义一个方法 / 成员函数
2. 为了区分成员变量，⼀般习惯上成员变量会加一个特殊标识，如成员变量前面或者后面加_ 或者 m开头，注意C&#43;&#43;中这个并不是强制的，看个人习惯或者要求
class zjh { public: void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } }; class zjh { private: int _year; // year_ m_year int _month; int _day; }; 成员变量只要定义在类里面就可以，没有其他限制
3. C&#43;&#43;中struct也可以定义类，C&#43;&#43;兼容C中struct的用法，同时struct升级成了类，明显的变化是
struct中可以定义函数，⼀般情况下我们还是推荐用class定义类
Struct zjh { public: void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } }; class与struct的区别是 ：class的默认访问限定符是私有的，而struct的默认访问限定符是公有的">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T11:38:22+08:00">
    <meta property="article:modified_time" content="2024-07-26T11:38:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; —— 关于类和对象（上）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.类的定义格式</h2> 
<p><strong>1. class为定义类的关键字，Stack为类的名字，{}中为类的主体，注意类定义结束时后⾯分号不能省略。</strong></p> 
<pre><code class="language-cpp">class Stack 
{

}</code></pre> 
<p><strong>类体中内容称为类的成员：类中的变量称为类的<span style="color:#fe2c24;">属性</span><span style="color:#0d0016;">或</span><span style="color:#fe2c24;">成员变量</span>; 类中的函数称为类的<span style="color:#fe2c24;">方法</span><span style="color:#0d0016;">或者</span><span style="color:#fe2c24;">成员函数，</span><span style="color:#0d0016;">class关键字定义与结构体非常类似，只不过是比结构体能多定义一个方法 / 成员函数</span></strong></p> 
<p><br><strong>2. 为了区分成员变量，⼀般习惯上<span style="color:#fe2c24;">成员变量</span>会加一个<span style="color:#fe2c24;">特殊标识</span>，如成员变量<span style="color:#fe2c24;">前面或者后面加_ 或者 m开头</span>，注意C++中这个并不是强制的，看个人习惯或者要求</strong></p> 
<pre><code class="language-cpp">class zjh
{
    public:
    void Init(int year, int month, int day)
        {
            _year = year;
            _month = month;
            _day = day;
        }
};</code></pre> 
<pre><code class="language-cpp">class zjh
{
    private:
        int _year; // year_ m_year
        int _month;
        int _day;
};</code></pre> 
<p><strong> 成员变量只要定义在类里面就可以，没有其他限制</strong></p> 
<p><br><strong>3. C++中<span style="color:#fe2c24;">struct也可以定义类</span>，C++兼容C中struct的用法，同时struct升级成了类，明显的变化是<br> struct中可以定义函数，⼀般情况下我们还是推荐用class定义类</strong></p> 
<pre><code class="language-cpp">Struct zjh
{
    public:
    void Init(int year, int month, int day)
        {
            _year = year;
            _month = month;
            _day = day;
        }
};</code></pre> 
<p><strong>class与struct的区别是 ：class的默认访问限定符是<span style="color:#fe2c24;">私有</span>的，而struct的默认访问限定符是<span style="color:#fe2c24;">公有</span>的</strong></p> 
<p><br><strong>4.  定义在类里面的成员函数默认为inline（内联函数）</strong></p> 
<p></p> 
<hr> 
<h2>2.访问限定符</h2> 
<p><strong>1. 是C++的⼀种实现封装的方式，用类将对象的属性与方法结合在⼀块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用</strong></p> 
<p><br><strong>2.  public（公有）修饰的成员在类外可以直接被访问；protected和private（受保护的/私有）修饰的成员在类外不能直接被访问，protected和private是⼀样的，以后继承章节才能体现出他们的区别。</strong></p> 
<p><br><strong>3. 访问权限作用域从该访问限定符<span style="color:#fe2c24;">出现的位置开始</span>直到<span style="color:#fe2c24;">下⼀个访问限定符出现时为止</span>，如果后面<span style="color:#fe2c24;">没有</span>访问限定符，作用域就到 }即类结束。</strong> </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
class Stack
{
    //公有
    public:
    // 成员函数
        void Init(int n = 4);
        int a = 0;
    //私有
    private:
    // 成员变量
        int* array;
        size_t capacity;
        size_t top;
};</code></pre> 
<p><strong>上面的代码的访问权限作用域就是从 public到private之间的距离，如果没有private的话那么此代码的访问权限作用域就是<span style="color:#fe2c24;">从public到 }; 结束</span></strong></p> 
<p><br><strong>4. class定义成员<span style="color:#fe2c24;">没有</span>被访问限定符修饰时默认为private（私有），struct默认为public（公有）</strong></p> 
<p><br><strong>5. ⼀般<span style="color:#fe2c24;">成员变量</span>都会被限制为private/protected（私有/受保护的），需要给别⼈使用的成员函数会放为public（公有）</strong></p> 
<p><strong>6.访问限定符可以出现多次，但是实际中一般只会出现一对public和private</strong></p> 
<p></p> 
<hr> 
<h2>3.类域</h2> 
<p><strong>1. 类定义了⼀个新的作用域，类的所有成员都在类的作用域中，<span style="color:#fe2c24;">在类体外定义成员</span>时，需要使⽤ :: 作用域操作符指明成员属于哪个类域</strong></p> 
<p><br><strong>2. 类域影响的是编译的查找规则，下面程序中Init如果<span style="color:#fe2c24;">不指定</span>类域Stack，那么编译器就把Init当成<span style="color:#fe2c24;">全局函数</span>，那么编译时，找不到array等成员的声明/定义在哪里，就会报错</strong></p> 
<p><strong>指定类域Stack，就是知道Init是成员函数，当前域找不到的array等成员，就会到类域中去查找</strong></p> 
<pre><code class="language-cpp">// 声明和定义分离，需要指定类域
void Stack::kiana
{
    int a = 12;
   
}

int main()
  {
    
    st.kiana();
    return 0;
}</code></pre> 
<p></p> 
<hr> 
<h2>4.类的实例化</h2> 
<p><strong>1.<span style="color:#fe2c24;"> </span><span style="color:#0d0016;">实例化：用类类型在物理内存中</span><span style="color:#fe2c24;">创建一个对象的过程</span>，称为类实例化出对象</strong></p> 
<pre><code class="language-cpp">int main()
  {
    // Date类实例化出对象d1和d2
    Date d1;
    Date d2;
    d1.Init(2024, 3, 31);
    d1.Print();
    d2.Init(2024, 7, 5);
    d2.Print();
    return 0;
  }</code></pre> 
<p><br><strong>2.  类是对象进行的⼀种描述，是⼀个模型⼀样的东西，限定了类有哪些成员变量，这些成员变量只是声明，<span style="color:#fe2c24;">没有分配空间</span>，用类<span style="color:#fe2c24;">实例化出对象</span>时，才会<span style="color:#fe2c24;">分配空间</span></strong></p> 
<p><br><strong>3. <span style="color:#fe2c24;">⼀个</span>类可以实例化出<span style="color:#fe2c24;">多个</span>对象，实例化出的对象占用实际的物理空间，存储类成员变量</strong></p> 
<p><strong>打个比方：类实例化出对象就像现实中使⽤建筑设计图造房子，类就像是<span style="color:#fe2c24;">设计图</span>，而实例化就像是用设计图修建出了房子</strong></p> 
<p><strong>同样类就像设计图⼀样，<span style="color:#fe2c24;">不能存储数据</span>，实例化出的对象<span style="color:#fe2c24;">分配空间</span></strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
class Date
{
    public:
    void Init(int year, int month, int day)
        {
            _year = year;
            _month = month;
            _day = day;
        }
    void Print()
        {
            cout &lt;&lt; _year &lt;&lt; "/" &lt;&lt; _month &lt;&lt; "/" &lt;&lt; _day &lt;&lt; endl;
        }
    private:
    // 这⾥只是声明，没有开空间
            int _year;
            int _month;
            int _day;
};


int main()
  {
    // Date类实例化出对象d1和d2
    Date d1;
    Date d2;
    d1.Init(2024, 3, 31);
    d1.Print();
    d2.Init(2024, 7, 5);
    d2.Print();
    return 0;
  }</code></pre> 
<hr> 
<h2>5.对齐规则</h2> 
<p><strong><span style="background-color:#38d8f0;">C++的对齐规则和C语言的对齐规则一模一样</span></strong></p> 
<p><strong>1. 第⼀个成员在与结构体偏移量为0的地址处</strong></p> 
<p><strong>2.其他成员变量要对⻬到某个数字（对齐数）的整数倍的地址处</strong></p> 
<p><strong>3.注意：对齐数 = 编译器默认的⼀个对齐数 与 该成员大小的较小值</strong></p> 
<p><strong>4.VS中默认的对齐数为8</strong></p> 
<p><strong>5.结构体总大小为：最大对齐数（所有变量类型最⼤者与默认对齐参数取最小）的整数倍</strong></p> 
<p><strong>6.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍</strong></p> 
<pre><code class="language-cpp">// 计算⼀下A/B/C实例化的对象是多⼤？ 8个字节
class A
{
    public:
    void Print()
        {
            cout &lt;&lt; _ch &lt;&lt; endl;
        }
        private:

        char _ch;//1
            //中间间隔3个字节
        int _i;//4
};</code></pre> 
<pre><code class="language-cpp">class B //一个字节
{
    public:
    void Print()
        {
            //...
        }
};


class C //一个字节
{};</code></pre> 
<p><strong>这段代码虽然B和C里面没有内容，但是大小都为一个字节，因为一个字节都没有就表示没有开辟过空间，无法证明存在过</strong></p> 
<hr> 
<h2>6.this指针</h2> 
<p><strong>1. C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成</strong></p> 
<p><strong>2. 编译器编译后，类的成员函数默认都会在<span style="color:#fe2c24;">形参第⼀个位置</span>，增加⼀个<span style="color:#fe2c24;">当前类类型</span>的指针，叫做<span style="color:#fe2c24;">this指针</span></strong></p> 
<p><strong>比如Date类的Init的真实原型为， void Init(<span style="color:#fe2c24;">Date* const this</span> ,  int year, int month ,  int day)</strong></p> 
<p><strong><span style="background-color:#38d8f0;">但是我们不能显示的写出来，因为他是隐含的，我们不能抢了编译器的活。但是我们可以直接在类里面用</span></strong></p> 
<p><strong>3.  类的成员函数中<span style="color:#fe2c24;">访问成员变量</span>，本质都是<span style="color:#fe2c24;">通过this指针访问</span>的，如Init函数中给_year赋值， this-&gt;_year = year;</strong></p> 
<p><strong>4. C++规定不能在<span style="color:#fe2c24;">实参和形参</span>的位置显示的写this指针(编译时编译器会处理)，但是可以在函数体内显示使用this指针</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9bd1677460c9c39107bfa8530395b488/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; --＞ string类的使用（详细介绍）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f9bf5d23cf266c49f6aa5a44b5502b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端三大主流框架Vue React Angular有何不同？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>