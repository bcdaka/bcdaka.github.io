<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉搜索树（Java &#43; 链表实现） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3449eccc178668cea54086f4bbd6b7ca/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】二叉搜索树（Java &#43; 链表实现）">
  <meta property="og:description" content="Hi~！这里是奋斗的明志，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~
🌱🌱个人主页：奋斗的明志
🌱🌱所属专栏：数据结构、LeetCode专栏
📚本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为展示我的学习过程及理解。文笔、排版拙劣，望见谅。
这里写目录标题 前言一、二叉搜索树1.概念2.search 搜索或查找3.insert 插入4.删除（难点）4.1 根结点的左子树为空4.2 根结点的右子树为空4.3 根结点的左右子树都不为空4.4 完整代码 5.性能分析 二、1.7 和 java 类集的关系三、搜索1.概念及场景2.模型 前言 Map接口是独立的
实现Iterable接口的集合都是可以使用 for - Each 语句进行打印的
搜索性能会非常高
一、二叉搜索树 1.概念 二叉搜索树又称为二叉排序树，它或者是一棵空树，或者是具以下性质的二叉树：
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
它的左右子树也分别为二叉搜索树
如果中序遍历这棵二叉搜索树，会发现遍历的结果是有序的
接下来就模拟实现一下二叉搜索树
首先，和之前二叉树的实现一样，都是一个节点包括值和指向左右节点的引用（利用孩子兄弟表示法）
public class BinarySearchTree { //首先这棵树是由若干个结点组成的 static class TreeNode { public int val; public TreeNode left; public TreeNode right; //提供构造方法进行初始化 public TreeNode(int val) { this.val = val; } } //根节点 public TreeNode root; } 2.search 搜索或查找 若根节点不为空：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-07T17:24:39+08:00">
    <meta property="article:modified_time" content="2024-08-07T17:24:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉搜索树（Java &#43; 链表实现）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>Hi~！这里是奋斗的明志，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~<br> 🌱🌱个人主页：<a href="https://blog.csdn.net/2201_75724363?spm=1011.2415.3001.5343">奋斗的明志</a><br> 🌱🌱所属专栏：<a href="https://blog.csdn.net/2201_75724363/category_12736398.html?spm=1001.2014.3001.5482">数据结构、LeetCode专栏</a></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/64/c1/ZJ8hqx0a_o.gif" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>📚本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为展示我的学习过程及理解。文笔、排版拙劣，望见谅。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0b/14/C0RSdICt_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>这里写目录标题</h4> 
 <ul><li><a href="#_16" rel="nofollow">前言</a></li><li><a href="#_24" rel="nofollow">一、二叉搜索树</a></li><li><ul><li><a href="#1_26" rel="nofollow">1.概念</a></li><li><a href="#2search__56" rel="nofollow">2.search 搜索或查找</a></li><li><a href="#3insert__92" rel="nofollow">3.insert 插入</a></li><li><a href="#4_134" rel="nofollow">4.删除（难点）</a></li><li><ul><li><a href="#41__138" rel="nofollow">4.1 根结点的左子树为空</a></li><li><a href="#42__156" rel="nofollow">4.2 根结点的右子树为空</a></li><li><a href="#43__172" rel="nofollow">4.3 根结点的左右子树都不为空</a></li><li><a href="#44__187" rel="nofollow">4.4 完整代码</a></li></ul> 
   </li><li><a href="#5_251" rel="nofollow">5.性能分析</a></li></ul> 
  </li><li><a href="#17__java__263" rel="nofollow">二、1.7 和 java 类集的关系</a></li><li><a href="#_267" rel="nofollow">三、搜索</a></li><li><ul><li><a href="#1_269" rel="nofollow">1.概念及场景</a></li><li><a href="#2_285" rel="nofollow">2.模型</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_16"></a>前言</h2> 
<blockquote> 
 <p>Map接口是独立的<br> 实现Iterable接口的集合都是可以使用 for - Each 语句进行打印的</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c5/62/3xRSHnn3_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>搜索性能会非常高</p> 
</blockquote> 
<h2><a id="_24"></a>一、二叉搜索树</h2> 
<h3><a id="1_26"></a>1.概念</h3> 
<p>二叉搜索树又称为二叉排序树，它或者是一棵空树，或者是具以下性质的二叉树：</p> 
<blockquote> 
 <p><mark>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值</mark><br> <mark>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值</mark><br> <mark>它的左右子树也分别为二叉搜索树</mark></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3b/b3/fc2WWswM_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><code>如果中序遍历这棵二叉搜索树，会发现遍历的结果是有序的</code></p> 
</blockquote> 
<p>接下来就模拟实现一下二叉搜索树</p> 
<p>首先，和之前二叉树的实现一样，都是一个节点包括值和指向左右节点的引用（利用孩子兄弟表示法）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearchTree</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//首先这棵树是由若干个结点组成的</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>
        <span class="token comment">//提供构造方法进行初始化</span>
        <span class="token keyword">public</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//根节点</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2search__56"></a>2.search 搜索或查找</h3> 
<p><img src="https://images2.imgbox.com/28/54/cFSc8gOx_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>若根节点不为空：<br> 如果 查找key == 根节点的值 返回true<br> 如果 查找key &gt; 根节点的值 在其右子树查找<br> 如果 查找key &lt; 根节点的值 在其左子树查找</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">/**
     * search 搜索的意思
     *
     * @param val
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>算法从根节点开始，根据当前节点的值与 val 的大小关系，决定是向左子树还是向右子树移动，直到找到匹配的节点或者搜索到空节点为止。因为每一步都是根据节点值的大小进行移动，而树的高度（树的深度）是 log(n) 级别的（其中 n 是树中节点的数量），所以在平均情况下，search 方法的时间复杂度是 O(log n)。</p> 
</blockquote> 
<h3><a id="3insert__92"></a>3.insert 插入</h3> 
<blockquote> 
 <p>如果该树为空树，即 根节点 == null 直接实例化一个结点，进行插入</p> 
</blockquote> 
<blockquote> 
 <p>如果树不是空树，按照查找逻辑确定插入位置，插入新的节点<br> <img src="https://images2.imgbox.com/9d/06/huS1aN2Y_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//判断是否是空树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//定义一个前驱结点</span>
        <span class="token class-name">TreeNode</span> parent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">//定义一个临时节点</span>
        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//插入的这个结点</span>
        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;</span> parent<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            parent<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> parent<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            parent<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>这个方法用于向二叉搜索树中插入一个新的节点，如果节点已经存在则不插入。插入操作首先需要找到要插入位置的父节点，然后根据 val 的大小决定是插入为左子节点还是右子节点。与 search 方法类似，插入操作的时间复杂度也取决于树的高度。在平均情况下，插入一个节点的时间复杂度也是 O(log n)。</p> 
</blockquote> 
<h3><a id="4_134"></a>4.删除（难点）</h3> 
<p><strong>设待删除结点为cur，待删除节点的双亲结点为parent</strong></p> 
<h4><a id="41__138"></a>4.1 根结点的左子树为空</h4> 
<p><strong><code>cur.left == null</code></strong></p> 
<ul><li><strong><code>cur 是 root，则 root == cur.right</code></strong></li></ul> 
<p><img src="https://images2.imgbox.com/d9/7a/4qSHl5v2_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong><code>cur 不是 root ，cur 是 parent.left，则 parent.left = cur.right</code></strong></li></ul> 
<p><img src="https://images2.imgbox.com/c4/1e/Msx50dGx_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e9/33/yToUxd55_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong><code>cur 不是 root ，cur 是 parent.right，则 parent.right = cur.right</code></strong></li></ul> 
<p><img src="https://images2.imgbox.com/ce/e6/U0DHp9yj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="42__156"></a>4.2 根结点的右子树为空</h4> 
<p><strong><code>cur.right == null</code></strong></p> 
<ul><li><strong><code>cur 是 root，则 root = cur.left</code></strong></li></ul> 
<p><img src="https://images2.imgbox.com/7a/e5/9BIsYRuh_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong><code>cur 不是 root ，cur 是 parent.left，则 parent.left = cur.left</code></strong></li></ul> 
<p><img src="https://images2.imgbox.com/f7/ef/YU0nqIrg_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong><code>cur 不是 root ，cur 是 parent.right，则 parent.right = cur.left</code></strong></li></ul> 
<p><img src="https://images2.imgbox.com/c5/21/RThibuXa_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="43__172"></a>4.3 根结点的左右子树都不为空</h4> 
<p><strong><code>cur.left != null &amp;&amp; cur.right != null</code></strong></p> 
<blockquote> 
 <p>需要使用替换法进行删除，即在它的右子树中寻找中序下的第一个结点(关键码最小)，用它的值填补到被 删除节点中，再来处理该结点的删除问题</p> 
</blockquote> 
<ul><li>删除结点的左树的最大值，替换当前删除的结点（一定没有左子树）</li><li>删除结点的右树的最小值，替换当前删除的结点（一定没有右子树）</li></ul> 
<p>【情况一】</p> 
<p><img src="https://images2.imgbox.com/78/cb/4NYuJBya_o.png" alt="在这里插入图片描述"></p> 
<p>【情况二】</p> 
<p><img src="https://images2.imgbox.com/a7/c3/pqxO7TH1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="44__187"></a>4.4 完整代码</h4> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 删除这个结点
     * 利用替换的思路
     *
     * @param val
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//首先需要查找该树有没有该值</span>
        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> parent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//如果等于的话，说明该树有该值</span>
                <span class="token function">removeNode</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//进行覆盖的方法，删除结点</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> parent<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                root <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                parent<span class="token punctuation">.</span>left <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                parent<span class="token punctuation">.</span>right <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                root <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                parent<span class="token punctuation">.</span>left <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                parent<span class="token punctuation">.</span>right <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">TreeNode</span> t <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token class-name">TreeNode</span> tp <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                tp <span class="token operator">=</span> t<span class="token punctuation">;</span>
                t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            cur<span class="token punctuation">.</span>val <span class="token operator">=</span> t<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tp<span class="token punctuation">.</span>left <span class="token operator">==</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                tp<span class="token punctuation">.</span>left <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                tp<span class="token punctuation">.</span>right <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="5_251"></a>5.性能分析</h3> 
<p><code>插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。</code><br> 对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的深度 的函数，即结点越深，则比较次数越多。<br> <code>但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树：</code></p> 
<p><img src="https://images2.imgbox.com/d4/23/xsq87aLg_o.png" alt="在这里插入图片描述"></p> 
<p>最优情况下，二叉搜索树为完全二叉树，其平均比较次数为： log2N 最差情况下，二叉搜索树退化为单支树，其平均比较次数为： <img src="https://images2.imgbox.com/f1/e1/QsDKor2E_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>问题：如果退化成单支树，二叉搜索树的性能就失去了。那能否进行改进，不论按照什么次序插入关键码，都可以 是二叉搜索树的性能最佳？</p> 
</blockquote> 
<h2><a id="17__java__263"></a>二、1.7 和 java 类集的关系</h2> 
<p><code>TreeMap 和 TreeSet 即 java 中利用搜索树实现的 Map 和 Set</code>；实际上用的是<code>红黑树，而红黑树是一棵近似平衡的 二叉搜索树</code>，即在二叉搜索树的基础之上 + 颜色以及红黑树性质验证，关于红黑树的内容后序再进行介绍</p> 
<h2><a id="_267"></a>三、搜索</h2> 
<h3><a id="1_269"></a>1.概念及场景</h3> 
<p><strong>Map和set是一种专门用来进行搜索的容器或者数据结构，其搜索的效率与其具体的实例化子类有关。以前常见的 搜索方式有：</strong></p> 
<ol><li>直接遍历，时间复杂度为O(N)，<code>元素如果比较多效率会非常慢</code></li><li>二分查找，时间复杂度为o(log N) ,<code>但搜索前必须要求序列是有序的</code></li></ol> 
<p><strong>上述排序比较适合静态类型的查找，即一般不会对区间进行插入和删除操作了，而现实中的查找比如：</strong></p> 
<ol><li>根据姓名查询考试成绩</li><li>通讯录，即根据姓名查询联系方式</li><li>不重复集合，即需要先搜索关键字是否已经在集合中</li></ol> 
<p><strong>可能在查找时进行一些插入和删除的操作，即动态查找，那上述两种方式就不太适合了，本节介绍的Map和Set是 一种适合动态查找的集合容器。</strong></p> 
<h3><a id="2_285"></a>2.模型</h3> 
<p><strong>一般把搜索的数据称为关键字（Key），和关键字对应的称为值（Value），将其称之为Key-value的键值对，所以 模型会有两种：</strong></p> 
<p><strong>纯 key 模型，比如：</strong></p> 
<ul><li>有一个英文词典，快速查找一个单词是否在词典中 。</li><li>快速查找某个名字在不在通讯录中</li></ul> 
<p><strong>Key-Value 模型，比如：</strong></p> 
<ul><li>统计文件中每个单词出现的次数，统计结果是每个单词都有与其对应的次数： &lt;单词，单词出现的次数&gt; 。</li><li>梁山好汉的江湖绰号：每个好汉都有自己的江湖绰号</li></ul> 
<p><strong>而Map中存储的就是key-value的键值对， Set中只存储了Key。</strong></p> 
<p><img src="https://images2.imgbox.com/1a/22/oojbWwoK_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/8b/7f/KwS0zQeH_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f3/10/NTGC0dvg_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2dfb69fa406ae4152af242002ceae9c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL事务隔离级别、InnoDB使用MVCC&#43;各种锁实现了RC和RR事务隔离级别、具体案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c313b8620360f5d4046eb54c3ff5e068/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构——排序（1）：插入排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>