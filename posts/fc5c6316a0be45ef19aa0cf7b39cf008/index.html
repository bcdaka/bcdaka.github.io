<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java设计模式和面向对象编程思想 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fc5c6316a0be45ef19aa0cf7b39cf008/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="java设计模式和面向对象编程思想">
  <meta property="og:description" content="Java设计模式和面向对象编程思想是软件开发中的核心概念，对于构建可维护、可扩展的软件系统至关重要。下面是对这两个主题的知识点总结：
面向对象编程（OOP）思想 封装：将数据（属性）和操作这些数据的方法（行为）封装在一起，隐藏内部实现细节，仅通过公共接口与外部交互。这有助于减少代码间的耦合度，提高模块化。
继承：允许创建分层次的类结构，子类可以继承父类的属性和方法，并可添加或覆盖它们。这支持代码复用，增强了软件的可扩展性。
多态：同一接口可以被不同的类以不同方式实现，即子类可以根据需要覆盖父类的方法。多态提高了代码的灵活性和可维护性。
抽象：通过抽象类或接口来定义对象的基本形态和行为，不关注具体实现。抽象让程序员专注于对象的接口而非其实现细节。
面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，强调将程序设计中的各种要素封装进对象中，通过对象的交互来设计和实现应用程序。OOP的核心思想主要围绕以下几个基本原则：
1. 封装（Encapsulation） 封装是将对象的状态（数据成员/属性）和行为（成员方法/函数）捆绑在一起，并对外界隐藏其内部实现细节的过程。通过设置访问权限（如Java中的public、private、protected），可以控制对对象内部数据的直接访问，从而保护数据的完整性，减少错误，并增强模块间的独立性。
2. 继承（Inheritance） 继承允许一个类（子类/派生类）继承另一个类（父类/基类）的属性和方法，实现代码的复用。子类可以继承父类的所有非私有属性和方法，并可以增加或重写父类的方法以适应更具体的需求。这有助于建立类的层次结构，促进软件的模块化设计。
3. 多态（Polymorphism） 多态意味着一个接口可以有多种实现方式，或者一个类实例的相同消息可以产生多种响应。在Java等面向对象语言中，多态主要通过方法重写（Override）和接口实现来体现。它使得代码更加灵活和可扩展，因为可以在运行时根据对象的实际类型来决定调用哪个方法，而不是在编译时确定。
4. 抽象（Abstraction） 抽象是指将复杂的系统分解为更简单的组成部分，关注关键特性和行为，忽略不必要的细节。在OOP中，抽象类或接口用来定义一个或多个类的共同属性和操作，但不提供具体实现。抽象类不能被实例化，其目的是为了被子类继承。接口则完全由抽象方法组成，强制实现类遵循某种规范或协议。
实践中的应用 模块化：通过封装和抽象，将复杂系统分解为小的、相互独立的模块，便于管理和维护。代码复用：继承减少了重复代码，提高了开发效率和代码质量。灵活性与扩展性：多态和抽象使得系统容易适应变化，增加新功能或修改现有功能时不会对整个系统造成太大影响。设计模式：许多经典的设计模式（如单例、工厂、策略等）都是基于OOP原则，用于解决特定设计问题，提升软件设计的优雅性和健壮性。 综上所述，面向对象编程思想通过封装、继承、多态和抽象四大原则，促进了软件的模块化、灵活性、可维护性和代码复用，是现代软件开发不可或缺的基础。
Java设计模式 设计模式是在特定情境下解决常见设计问题的标准化解决方案。它们分为三大类：创建型、结构型和行为型模式。
Java设计模式是软件开发中解决常见设计问题的通用解决方案，分为三大类：创建型、结构型和行为型模式。以下是这些模式的详细知识点总结：
创建型模式（Creational Patterns） 单例模式（Singleton）
目的：确保一个类只有一个实例，并提供一个全局访问点。实现：使用私有构造函数、静态私有实例和公开的静态方法确保只创建一个对象。 工厂方法模式（Factory Method）
目的：定义一个用于创建对象的接口，但让子类决定实例化哪一个类。实现：声明一个用于创建对象的接口，让子类决定具体的类。 抽象工厂模式（Abstract Factory）
目的：为创建一组相关或相互依赖的对象提供一个接口，而无需指定它们的 concrete 类。实现：定义接口用于创建一系列相关或相互依赖的对象，而不需要指定它们的具体类。 建造者模式（Builder）
目的：将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。实现：使用Builder类逐步构建产品对象，Director负责管理构建过程。 原型模式（Prototype）
目的：通过复制现有的实例来创建新的对象，以减少创建新对象的成本。实现：实现Cloneable接口，重写clone()方法以深拷贝或浅拷贝对象。 结构型模式（Structural Patterns） 适配器模式（Adapter）
目的：将一个类的接口转换为客户期望的另一个接口，使原本不兼容的类可以一起工作。实现：创建一个适配器类，继承或组合原有类，并实现目标接口。 桥接模式（Bridge）
目的：将抽象部分与实现部分分离，使它们可以独立变化。实现：定义抽象类和实现类，通过组合而非继承来实现二者之间的松耦合。 装饰器模式（Decorator）
目的：动态地给一个对象添加一些额外的职责，而不改变其结构。实现：创建装饰器类，包装原有的对象，并可以添加额外的行为。 组合模式（Composite）
目的：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。实现：定义Component接口，声明操作，Composite类实现Component并管理子组件。 外观模式（Facade）
目的：为子系统中的一组接口提供一个一致的高层接口，简化客户端与子系统的交互。实现：创建一个Facade类，该类提供了简化的方法来调用子系统中的复杂操作。 享元模式（Flyweight）
目的：运用共享技术有效地支持大量细粒度的对象。实现：创建Flyweight类存储共享状态，客户端通过Factory获取Flyweight对象，外部状态由客户端维护。 行为型模式（Behavioral Patterns） 观察者模式（Observer）
目的：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。实现：Subject（被观察者）维护Observer（观察者）列表，状态改变时通知所有观察者。 模板方法模式（Template Method）
目的：定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。实现：在父类中定义模板方法，具体步骤留给子类去实现。 策略模式（Strategy）
目的：定义一系列算法，将每一个算法封装起来，并使它们可以互相替换。实现：定义策略接口，具体策略类实现接口，Context使用策略。 迭代器模式（Iterator）
目的：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。实现：定义Iterator接口，聚合类实现创建Iterator的方法。 责任链模式（Chain of Responsibility）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-12T17:01:24+08:00">
    <meta property="article:modified_time" content="2024-06-12T17:01:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java设计模式和面向对象编程思想</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Java设计模式和面向对象编程思想是软件开发中的核心概念，对于构建可维护、可扩展的软件系统至关重要。下面是对这两个主题的知识点总结：</p> 
<h4><img alt="" height="1200" src="https://images2.imgbox.com/1e/83/nHxo97lY_o.png" width="1200"></h4> 
<h4>面向对象编程（OOP）思想</h4> 
<ol><li> <p><strong>封装</strong>：将数据（属性）和操作这些数据的方法（行为）封装在一起，隐藏内部实现细节，仅通过公共接口与外部交互。这有助于减少代码间的耦合度，提高模块化。</p> </li><li> <p><strong>继承</strong>：允许创建分层次的类结构，子类可以继承父类的属性和方法，并可添加或覆盖它们。这支持代码复用，增强了软件的可扩展性。</p> </li><li> <p><strong>多态</strong>：同一接口可以被不同的类以不同方式实现，即子类可以根据需要覆盖父类的方法。多态提高了代码的灵活性和可维护性。</p> </li><li> <p><strong>抽象</strong>：通过抽象类或接口来定义对象的基本形态和行为，不关注具体实现。抽象让程序员专注于对象的接口而非其实现细节。</p> </li></ol> 
<p>面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，强调将程序设计中的各种要素封装进对象中，通过对象的交互来设计和实现应用程序。OOP的核心思想主要围绕以下几个基本原则：</p> 
<h4>1. 封装（Encapsulation）</h4> 
<p>封装是将对象的状态（数据成员/属性）和行为（成员方法/函数）捆绑在一起，并对外界隐藏其内部实现细节的过程。通过设置访问权限（如Java中的public、private、protected），可以控制对对象内部数据的直接访问，从而保护数据的完整性，减少错误，并增强模块间的独立性。</p> 
<h4>2. 继承（Inheritance）</h4> 
<p>继承允许一个类（子类/派生类）继承另一个类（父类/基类）的属性和方法，实现代码的复用。子类可以继承父类的所有非私有属性和方法，并可以增加或重写父类的方法以适应更具体的需求。这有助于建立类的层次结构，促进软件的模块化设计。</p> 
<h4>3. 多态（Polymorphism）</h4> 
<p>多态意味着一个接口可以有多种实现方式，或者一个类实例的相同消息可以产生多种响应。在Java等面向对象语言中，多态主要通过方法重写（Override）和接口实现来体现。它使得代码更加灵活和可扩展，因为可以在运行时根据对象的实际类型来决定调用哪个方法，而不是在编译时确定。</p> 
<h4>4. 抽象（Abstraction）</h4> 
<p>抽象是指将复杂的系统分解为更简单的组成部分，关注关键特性和行为，忽略不必要的细节。在OOP中，抽象类或接口用来定义一个或多个类的共同属性和操作，但不提供具体实现。抽象类不能被实例化，其目的是为了被子类继承。接口则完全由抽象方法组成，强制实现类遵循某种规范或协议。</p> 
<h4>实践中的应用</h4> 
<ul><li><strong>模块化</strong>：通过封装和抽象，将复杂系统分解为小的、相互独立的模块，便于管理和维护。</li><li><strong>代码复用</strong>：继承减少了重复代码，提高了开发效率和代码质量。</li><li><strong>灵活性与扩展性</strong>：多态和抽象使得系统容易适应变化，增加新功能或修改现有功能时不会对整个系统造成太大影响。</li><li><strong>设计模式</strong>：许多经典的设计模式（如单例、工厂、策略等）都是基于OOP原则，用于解决特定设计问题，提升软件设计的优雅性和健壮性。</li></ul> 
<p>综上所述，面向对象编程思想通过封装、继承、多态和抽象四大原则，促进了软件的模块化、灵活性、可维护性和代码复用，是现代软件开发不可或缺的基础。</p> 
<h2>Java设计模式</h2> 
<p>设计模式是在特定情境下解决常见设计问题的标准化解决方案。它们分为三大类：创建型、结构型和行为型模式。</p> 
<p><img alt="" height="312" src="https://images2.imgbox.com/80/01/7jRZLl7W_o.png" width="597"></p> 
<p>Java设计模式是软件开发中解决常见设计问题的通用解决方案，分为三大类：创建型、结构型和行为型模式。以下是这些模式的详细知识点总结：</p> 
<p><img alt="" height="607" src="https://images2.imgbox.com/5b/e6/9U9MCUTb_o.png" width="1200"></p> 
<h4>创建型模式（Creational Patterns）</h4> 
<ol><li> <p><strong>单例模式（Singleton）</strong></p> 
  <ul><li>目的：确保一个类只有一个实例，并提供一个全局访问点。</li><li>实现：使用私有构造函数、静态私有实例和公开的静态方法确保只创建一个对象。</li></ul></li><li> <p><strong>工厂方法模式（Factory Method）</strong></p> 
  <ul><li>目的：定义一个用于创建对象的接口，但让子类决定实例化哪一个类。</li><li>实现：声明一个用于创建对象的接口，让子类决定具体的类。</li></ul></li><li> <p><strong>抽象工厂模式（Abstract Factory）</strong></p> 
  <ul><li>目的：为创建一组相关或相互依赖的对象提供一个接口，而无需指定它们的 concrete 类。</li><li>实现：定义接口用于创建一系列相关或相互依赖的对象，而不需要指定它们的具体类。</li></ul></li><li> <p><strong>建造者模式（Builder）</strong></p> 
  <ul><li>目的：将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</li><li>实现：使用Builder类逐步构建产品对象，Director负责管理构建过程。</li></ul></li><li> <p><strong>原型模式（Prototype）</strong></p> 
  <ul><li>目的：通过复制现有的实例来创建新的对象，以减少创建新对象的成本。</li><li>实现：实现Cloneable接口，重写clone()方法以深拷贝或浅拷贝对象。</li></ul></li></ol> 
<h4>结构型模式（Structural Patterns）</h4> 
<ol><li> <p><strong>适配器模式（Adapter）</strong></p> 
  <ul><li>目的：将一个类的接口转换为客户期望的另一个接口，使原本不兼容的类可以一起工作。</li><li>实现：创建一个适配器类，继承或组合原有类，并实现目标接口。</li></ul></li><li> <p><strong>桥接模式（Bridge）</strong></p> 
  <ul><li>目的：将抽象部分与实现部分分离，使它们可以独立变化。</li><li>实现：定义抽象类和实现类，通过组合而非继承来实现二者之间的松耦合。</li></ul></li><li> <p><strong>装饰器模式（Decorator）</strong></p> 
  <ul><li>目的：动态地给一个对象添加一些额外的职责，而不改变其结构。</li><li>实现：创建装饰器类，包装原有的对象，并可以添加额外的行为。</li></ul></li><li> <p><strong>组合模式（Composite）</strong></p> 
  <ul><li>目的：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</li><li>实现：定义Component接口，声明操作，Composite类实现Component并管理子组件。</li></ul></li><li> <p><strong>外观模式（Facade）</strong></p> 
  <ul><li>目的：为子系统中的一组接口提供一个一致的高层接口，简化客户端与子系统的交互。</li><li>实现：创建一个Facade类，该类提供了简化的方法来调用子系统中的复杂操作。</li></ul></li><li> <p><strong>享元模式（Flyweight）</strong></p> 
  <ul><li>目的：运用共享技术有效地支持大量细粒度的对象。</li><li>实现：创建Flyweight类存储共享状态，客户端通过Factory获取Flyweight对象，外部状态由客户端维护。</li></ul></li></ol> 
<h4>行为型模式（Behavioral Patterns）</h4> 
<ol><li> <p><strong>观察者模式（Observer）</strong></p> 
  <ul><li>目的：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li><li>实现：Subject（被观察者）维护Observer（观察者）列表，状态改变时通知所有观察者。</li></ul></li><li> <p><strong>模板方法模式（Template Method）</strong></p> 
  <ul><li>目的：定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。</li><li>实现：在父类中定义模板方法，具体步骤留给子类去实现。</li></ul></li><li> <p><strong>策略模式（Strategy）</strong></p> 
  <ul><li>目的：定义一系列算法，将每一个算法封装起来，并使它们可以互相替换。</li><li>实现：定义策略接口，具体策略类实现接口，Context使用策略。</li></ul></li><li> <p><strong>迭代器模式（Iterator）</strong></p> 
  <ul><li>目的：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li><li>实现：定义Iterator接口，聚合类实现创建Iterator的方法。</li></ul></li><li> <p><strong>责任链模式（Chain of Responsibility）</strong></p> 
  <ul><li>目的：将请求的处理分散到多个对象中，每个对象根据情况决定是否处理请求或将其传递给下一个对象。</li><li>实现：创建处理请求的Handler类，每个Handler持有下一个Handler的引用。</li></ul></li><li> <p><strong>命令模式（Command）</strong></p> 
  <ul><li>目的：将请求封装为一个对象，从而使可以用不同的请求、队列或日志来参数化其他对象。</li><li>实现：定义Command接口，ConcreteCommand实现接口执行具体操作，Invoker调用Command。</li></ul></li><li> <p><strong>状态模式（State）</strong></p> 
  <ul><li>目的：允许对象在其内部状态改变时改变其行为，对象看起来似乎修改了它的类。</li><li>实现：定义State接口和具体状态类，Context持有一个State引用，根据状态改变行为。</li></ul></li><li> <p><strong>访问者模式（Visitor）</strong></p> 
  <ul><li>目的：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li><li>实现：定义Visitor接口和具体访问者，Element定义接受访问者的方法，Composite和Leaf实现Element接口。</li></ul></li></ol> 
<p>掌握这些设计模式，可以帮助Java开发者编写出更灵活、可维护、易于扩展的代码。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d63d9c83a9d25afcc4bfdf443c97d46f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mysql中使用where 1=1有什么问题吗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50aacc4126a74fad4a1b5877d3d657b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title"># RocketMQ 实战：模拟电商网站场景综合案例（六）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>