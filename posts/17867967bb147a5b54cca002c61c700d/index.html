<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 入门 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/17867967bb147a5b54cca002c61c700d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43; 入门">
  <meta property="og:description" content="前言 c&#43;&#43;的发展史： C&#43;&#43;的起源可以追溯到1979年，当时Bjarne Stroustrup在贝尔实验室开始开发一种名为“C with Classes”的语言。以下是C&#43;&#43;发展的几个关键阶段：
1979年：Bjarne Stroustrup在贝尔实验室开始开发“C with Classes”。1983年：语言正式命名为C&#43;&#43;，添加类、继承、函数重载等特性。1985年：发布《The C&#43;&#43; Programming Language》一书，标志C&#43;&#43;的正式发布。1998年：发布第一个国际标准版本C&#43;&#43;98。2011年：发布C&#43;&#43;11，加入自动类型推导、lambda表达式、智能指针等新特性。2014年：发布C&#43;&#43;14，进行小幅改进。2017年：发布C&#43;&#43;17，新增结构化绑定、std::optional等特性。2020年：发布C&#43;&#43;20，引入概念、协程、模块等重大更新。 C&#43;&#43;的演进不断增加新特性，提升性能和编程效率，适应现代开发需求。
一 命名空间： 在C语言中我们定义变量函数rand但是它是&lt;stdli.b&gt;库里面的函数，这时编译器无法区分它到底是库里面的函数还是全局变量rand，那么它们发生就会冲突，因为C语言规定定义的变量不能与库里面的函数和那32个关键字一样，如果我因为某种需求需要定义一样的变量那这时候就会出错，这时候c&#43;&#43;中的namespace就是为了针对此类问题
namespace：
定义：namespace 是 C&#43;&#43; 中的一个关键字，用于定义命名空间。命名空间是一个逻辑上分组的机制，主要用来解决命名冲突问题。通过使用命名空间，可以将相同名称的标识符（如变量、函数、类等）放在不同的命名空间中，从而避免冲突。
命名空间定义：
#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; namespace bit { int rand = 10; } int main() { printf(&#34;%d&#34;, bit::rand); return 0; } 输出：
首先我们来定义一个命名空间需要使用到namespace关键字后面需要跟一个命名空间(结束后不需要加;)，其中命名空间可以是函数变量类型。要访问命名空间中的成员，可以使用 :: 运算符
using命名：
我们在程序中频繁的使用命名空间里面的特定变量那需要输出多少个就需要多少个::运算符(作用域解析运算符)，那c&#43;&#43;用using可以直接访问a而不需要bit::前缀。就很好的解决了这个问题
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; namespace bit { int rand = 10; int a = 0; } using bit::a; //using bit::rand; int main() { printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-24T18:54:26+08:00">
    <meta property="article:modified_time" content="2024-06-24T18:54:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言 c++的发展史：</h2> 
<p>C++的起源可以追溯到1979年，当时Bjarne Stroustrup在贝尔实验室开始开发一种名为“C with Classes”的语言。以下是C++发展的几个关键阶段：</p> 
<ol><li><strong>1979年</strong>：Bjarne Stroustrup在贝尔实验室开始开发“C with Classes”。</li><li><strong>1983年</strong>：语言正式命名为C++，添加类、继承、函数重载等特性。</li><li><strong>1985年</strong>：发布《The C++ Programming Language》一书，标志C++的正式发布。</li><li><strong>1998年</strong>：发布第一个国际标准版本C++98。</li><li><strong>2011年</strong>：发布C++11，加入自动类型推导、lambda表达式、智能指针等新特性。</li><li><strong>2014年</strong>：发布C++14，进行小幅改进。</li><li><strong>2017年</strong>：发布C++17，新增结构化绑定、std::optional等特性。</li><li><strong>2020年</strong>：发布C++20，引入概念、协程、模块等重大更新。</li></ol> 
<p>C++的演进不断增加新特性，提升性能和编程效率，适应现代开发需求。</p> 
<h2>一 命名空间：</h2> 
<p>在C语言中我们定义变量函数rand但是它是&lt;stdli.b&gt;库里面的函数，这时编译器无法区分它到底是库里面的函数还是全局变量rand，那么它们发生就会冲突，因为C语言规定定义的变量不能与库里面的函数和那32个关键字一样，如果我因为某种需求需要定义一样的变量那这时候就会出错，这时候c++中的namespace就是为了针对此类问题</p> 
<p class="img-center"><img alt="" height="572" src="https://images2.imgbox.com/5b/6d/CRu8kcRp_o.png" width="759"></p> 
<p>namespace：</p> 
<p>定义：<code>namespace</code> 是 C++ 中的一个关键字，用于定义命名空间。命名空间是一个逻辑上分组的机制，主要用来解决命名冲突问题。通过使用命名空间，可以将相同名称的标识符（如变量、函数、类等）放在不同的命名空间中，从而避免冲突。</p> 
<p>命名空间定义：</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
namespace bit
{
	int rand = 10;
}
	

int main()
{
	printf("%d", bit::rand);
	return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="104" src="https://images2.imgbox.com/66/96/sVZ2SYoU_o.png" width="859"></p> 
<p>首先我们来定义一个命名空间需要使用到namespace关键字后面需要跟一个命名空间(<span style="color:#0d0016;">结束后不需要加</span><span style="color:#fe2c24;"><strong>;</strong></span><span style="color:#0d0016;">)，其中命名空间可以是函数变量类型。</span>要访问命名空间中的成员，可以使用<span style="color:#fe2c24;"> <code>::</code> </span>运算符</p> 
<p>using命名：</p> 
<p>我们在程序中频繁的使用命名空间里面的特定变量那需要输出多少个就需要多少个<span style="color:#fe2c24;"><strong>::</strong></span>运算符(作用域解析运算符)，那c++用using可以直接访问a而不需要bit<code>::</code>前缀。就很好的解决了这个问题</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

namespace bit
{
	int rand = 10;
	int a = 0;
}
using bit::a;
//using bit::rand;
int main()
{
	printf("%d\n",bit::rand);
	printf("%d", a);
	return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/35/1e/KLpX4HrJ_o.png" width="862"></p> 
<p>如果我们用被注释过的代码呢，你们觉得它会不会报错？答案是“会” 原因是rand本来是库函数但是它在命名空间里面所以不会报错，但是现在using想让rand变为全局变量那这不又与库函数冲突了嘛</p> 
<p>using namespace 命名：</p> 
<p>上面using命名规则就是把你a变量给释放出来而这个就是不管你三七二十一全给它释放出来，但是<br> 但是在编写项目的过程中就容易发生冲突了，所以我还是推荐用什么释放什么，或者带着 <code>::</code> 来明确指定变量是来自哪个 namespace 的</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

namespace bit
{
	int rand = 250;
	int a = 300;
}
using namespace::bit;
int main()
{
	printf("%d\n",rand);
	printf("%d", a);
	return 0;
}</code></pre> 
<p>输出</p> 
<p><img alt="" height="110" src="https://images2.imgbox.com/eb/cf/YOamt4pB_o.png" width="858"></p> 
<p>命名空间嵌套：</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

namespace bit
{
	int rand = 10;
	namespace abt
	{
		int b = 11;
	}
}
	

int main()
{
	printf("%d\n", bit::rand);
	printf("%d", bit::abt::b);
	return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="117" src="https://images2.imgbox.com/ea/02/iKBMgfb5_o.png" width="870"></p> 
<blockquote> 
 <p>在同一个工程文件中如果有多个相同的命名空间那到最后都会和到一起的</p> 
</blockquote> 
<h2>二 c++中输入输出：</h2> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
	cout &lt;&lt; "Hello World" &lt;&lt; endl;
	return 0;
}</code></pre> 
<p>在初识c++时是不是总是以为最上面的两行代码是每次写代码都要加上去，其实是因为要在 C++ 中执行任何输入和输出操作，我们需要使用 iostream 头文件。如果没有 &lt;iostream&gt; 头文件，我们就无法从用户那里获取输入或打印任何输出。第二行中我们只是不知道为什么要写个std </p> 
<p><strong>std:: </strong>是个<strong>命名空间标示符</strong>，C++<strong>标准库中的函数或者对象</strong>都是在<span style="color:#fe2c24;">命名空间std</span>中定义的，所以我们要使用标准函数库中的函数或对象都要使用std来限定。如果说需要调用要调用C++标准库时，要写上<strong>std::</strong></p> 
<h2>三 缺省参数：</h2> 
<p>缺省参数是指在函数声明时，为参数指定一个默认值。在调用该函数时，如果省略了该参数，编译器会自动使用默认值。</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
void Fun(int a = 10)
{
	cout &lt;&lt; a &lt;&lt; endl;
}
int main()
{
	//cout &lt;&lt; "Hello World" &lt;&lt; endl;
	Fun();//没传参数就用形参的指定默认值
	Fun(100);//传参数就用实参的值
	return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/1a/c8/WLskkuiX_o.png" width="865"></p> 
<p>全缺省参数：</p> 
<p>完整默认参数，也称为完全默认参数，是指为函数的所有参数分配默认值。这意味着，如果函数的调用者省略了任何参数，则将使用相应的默认值。</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
void Fun(int a = 10 , int b = 200 , int c = 300)
{
	cout &lt;&lt; a  &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; c &lt;&lt; endl;
}
int main()
{
	//cout &lt;&lt; "Hello World" &lt;&lt; endl;
	Fun();
	return 0;
}</code></pre> 
<p>半缺省参数：</p> 
<p>部分默认参数涉及仅为函数参数的子集分配默认值。其余参数没有默认值，必须由调用者提供。</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
void Fun(int a = 10 , int b = 200 , int c)
{
	cout &lt;&lt; a  &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; c &lt;&lt; endl;
}
int main()
{
	//cout &lt;&lt; "Hello World" &lt;&lt; endl;
	Fun(100 , 20 , 30);
	return 0;
}</code></pre> 
<blockquote> 
 <p>1. 半缺省参数必须从右往左依次来给出，不能间隔着给</p> 
 <p>2. 缺省参数不能在函数声明和定义中同时出现</p> 
 <p>3. 缺省值必须是常量或者全局变量</p> 
 <p>4. C语言不支持（编译器不支持）</p> 
</blockquote> 
<h2>四 函数重载：</h2> 
<p>函数重载：是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这 些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同，常用来处理实现功能类似数据类型 不同的问题。</p> 
<p>参数类型不同：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
void Swap(int a , int b)
{
	cout &lt;&lt; a  &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
}
void Swap(double a , float b)
{
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
}
int main()
{
	//cout &lt;&lt; "Hello World" &lt;&lt; endl;
	Swap(10 , 20);
	Swap(11.0 , 200.0);
	return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/04/84/QyM672YQ_o.png" width="853"></p> 
<p>参数个数不同：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
void Swap()
{
	cout &lt;&lt; "f()" &lt;&lt; endl;
}
void Swap(char b)
{
	cout &lt;&lt; b &lt;&lt; endl;
}
int main()
{
	//cout &lt;&lt; "Hello World" &lt;&lt; endl;
	Swap();
	Swap('b');
	return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/2f/37/m5lt6ZXF_o.png" width="881"></p> 
<p>参数顺序不同：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
void Swap(int a, char b)
{
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
}
void Swap(char b, int a)
{
	cout &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; a &lt;&lt; endl;
}
int main()
{
	//cout &lt;&lt; "Hello World" &lt;&lt; endl;
	Swap(10 , 'a');
	Swap('b', 200.0);
	return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="171" src="https://images2.imgbox.com/26/c4/l7LCsTpZ_o.png" width="878"></p> 
<h2>五 引用：</h2> 
<p>引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空 间，它和它引用的变量共用同一块内存空间。</p> 
<p>语法：</p> 
<blockquote> 
 <p>数据类型&amp; 引用名  = 引用实体</p> 
</blockquote> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
	int a = 200;
	int&amp; b = a;//b是a的引用
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
	return 0;
}</code></pre> 
<p>引用类型和引用实体必须是<span style="color:#fe2c24;">同种类型</span>又因为它们是<span style="color:#fe2c24;">共用同一块空间</span>所以不管是a或b变量谁改变那都会一起改变</p> 
<p>输出：</p> 
<p>   地址:</p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/c5/a3/bMPH2sBQ_o.png" width="881"></p> 
<p>  值：</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/70/48/RAPCC7SO_o.png" width="879"></p> 
<blockquote> 
 <p>引用在<span style="color:#fe2c24;">定义时必须要初始化</span></p> 
 <p>一个变量可以有多个引用</p> 
 <p>引用一旦引用一个实体就不能再引用另外一个实体</p> 
</blockquote> 
<p>常引用：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
int mian()
{
 //权力的放大
const int a = 200;
int&amp; b = a;//引用
cout &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; b &lt;&lt; endl;
return 0;
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="126" src="https://images2.imgbox.com/01/91/scxg09PB_o.png" width="800"></p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
int mian()
{
//权力的缩小
int i = 10;
const int&amp; j = i;
cout &lt;&lt; i &lt;&lt; endl;
cout &lt;&lt; j &lt;&lt; endl;
return 0;
}</code></pre> 
<p>输出：<img alt="" height="135" src="https://images2.imgbox.com/be/24/uMJeaH6k_o.png" width="860"></p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
int mian()
{
//权力的平移
const int q = 101;
const int&amp; w = q;
cout &lt;&lt; q &lt;&lt; endl;
cout &lt;&lt; w &lt;&lt; endl;
return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/07/29/7mCuaA9f_o.png" width="879"></p> 
<p><span style="color:#fe2c24;">综上所述权力可以平移 缩小但是不能放大。</span></p> 
<p><span style="color:#0d0016;">引用与指针的比较：</span></p> 
<p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p> 
<p>引用和指针的不同点:</p> 
<p>1. 引用概念上定义一个变量的别名，指针存储一个变量地址。</p> 
<p>2. 引用在定义时必须初始化，指针没有要求</p> 
<p>3. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何 一个同类型实体</p> 
<p>4. 没有NULL引用，但有NULL指针</p> 
<p>5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32 位平台下占4个字节)</p> 
<p>6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</p> 
<p>7. 有多级指针，但是没有多级引用</p> 
<p>8. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理</p> 
<p>9. 引用比指针使用起来相对更安全</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d232b3fa75e0291dfe030b9ea612084/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SwiftUI 6.0（iOS 18/macOS 15）关于颜色 Color 的新玩法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61af2ce5776b61baba5b4a1c565bcd7d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pytorch之视频流猫狗识别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>