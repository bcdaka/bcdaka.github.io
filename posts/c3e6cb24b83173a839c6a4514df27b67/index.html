<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript 中的面向对象编程---＞构造函数---＞原型对象与原型链，由浅入深详细讲解！ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c3e6cb24b83173a839c6a4514df27b67/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JavaScript 中的面向对象编程---＞构造函数---＞原型对象与原型链，由浅入深详细讲解！">
  <meta property="og:description" content="前言：哈喽，大家好，我是前端菜鸟的自我修养！今天给大家分享JavaScript 中的面向对象编程---&gt;构造函数---&gt;原型对象与原型链，由浅入深详细讲解！并提供具体代码帮助大家深入理解，彻底掌握！原创不易，如果能帮助到带大家，欢迎收藏&#43;关注哦 💕
🌈🌈文章目录
一、编程思想
1.面向过程
2.面向对象
二、构造函数
三、原型对象与原型链
1.原型对象
2.constructor 属性
3.对象原型
4.原型继承
5.原型链
一、编程思想 目标：学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。
1.面向过程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。
举个栗子：蛋炒饭
2.面向对象 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。
在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。
面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。
面向对象的特性：
封装性
继承性
多态性
二、构造函数 对比以下通过面向对象的构造函数实现的封装：
&lt;script&gt; function Person() { this.name = &#39;佚名&#39; // 设置名字 this.setName = function (name) { this.name = name } // 读取名字 this.getName = () =&gt; { console.log(this.name) } } ​ // 实例对像，获得了构造函数中封装的所有逻辑 let p1 = new Person() p1.setName(&#39;小明&#39;) console.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-08T08:36:40+08:00">
    <meta property="article:modified_time" content="2024-07-08T08:36:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript 中的面向对象编程---＞构造函数---＞原型对象与原型链，由浅入深详细讲解！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>前言</strong>：哈喽，大家好，我是前端菜鸟的自我修养！今天给大家分享JavaScript 中的面向对象编程---&gt;构造函数---&gt;原型对象与原型链，由浅入深详细讲解！并提供具体代码帮助大家深入理解，彻底掌握！<strong>原创不易，如果能帮助到带大家，欢迎收藏+关注哦 💕</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/94/d9/ym6j76VI_o.jpg"></p> 
<p id="main-toc">🌈🌈<strong>文章目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3" rel="nofollow">一、编程思想</a></p> 
<p id="1.%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#1.%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B" rel="nofollow">1.面向过程</a></p> 
<p id="2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" rel="nofollow">2.面向对象</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">二、构造函数</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="nofollow">三、原型对象与原型链</a></p> 
<p id="1.%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#1.%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1" rel="nofollow">1.原型对象</a></p> 
<p id="2.constructor%20%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#2.constructor%20%E5%B1%9E%E6%80%A7" rel="nofollow">2.constructor 属性</a></p> 
<p id="3.%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B-toc" style="margin-left:40px;"><a href="#3.%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B" rel="nofollow">3.对象原型</a></p> 
<p id="4.%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#4.%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF" rel="nofollow">4.原型继承</a></p> 
<p id="5.%E5%8E%9F%E5%9E%8B%E9%93%BE-toc" style="margin-left:40px;"><a href="#5.%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="nofollow">5.原型链</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2c/6e/yEfAMvJ9_o.gif"></p> 
<h2 id="%E4%B8%80%E3%80%81%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3">一、编程思想</h2> 
<blockquote> 
 <p>目标：学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。</p> 
</blockquote> 
<h3 id="1.%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">1.面向过程</h3> 
<p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p> 
<p>举个栗子：蛋炒饭</p> 
<p><img alt="" height="257" src="https://images2.imgbox.com/4b/ea/rrZ6bJlo_o.png" width="1200"></p> 
<h3 id="2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">2.面向对象</h3> 
<p>面向对象是把事务分解成为一个个<strong>对象</strong>，然后由对象之间分工与合作。</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/63/df/jXYhNSgP_o.png" width="1078"></p> 
<p>在面向对象程序开发思想中，<span style="color:#ff9900;"><strong>每一个对象都是功能中心</strong></span>，具有明确分工。</p> 
<p>面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</p> 
<p>面向对象的特性：</p> 
<blockquote> 
 <ul><li> <p><span style="color:#ff9900;">封装性</span></p> </li></ul> 
 <ul><li> <p><span style="color:#ff9900;">继承性</span></p> </li><li> <p><span style="color:#ff9900;">多态性</span></p> </li></ul> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">二、构造函数</h2> 
<p>对比以下通过<strong>面向对象</strong>的构造函数实现的封装：</p> 
<pre><code class="language-javascript"> &lt;script&gt;
    function Person() {
      this.name = '佚名'
      // 设置名字
      this.setName = function (name) {
        this.name = name
      }
      // 读取名字
      this.getName = () =&gt; {
        console.log(this.name)
      }
    }
  ​
    // 实例对像，获得了构造函数中封装的所有逻辑
    let p1 = new Person()
    p1.setName('小明')
    console.log(p1.name)
  ​
    // 实例对象
    let p2 = new Person()
    console.log(p2.name)
  &lt;/script&gt;</code></pre> 
<blockquote> 
 <p><strong>封装</strong>是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。</p> 
 <p>同样的将变量和函数<strong>组合</strong>到了一起并能通过<strong> this</strong> 实现数据的<strong>共享</strong>，所不同的是<span style="color:#ff9900;"><strong>借助构造函数创建出来的实例对象之</strong></span></p> 
 <p><span style="color:#ff9900;"><strong>间是彼此不影响的。</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><strong>总结：</strong></p> 
 <ol><li> <p>构造函数体现了<strong>面向对象的封装特性</strong></p> </li><li> <p>构造函数实例创建的对象<strong>彼此独立</strong>、互不影响</p> </li></ol> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE">三、原型对象与原型链</h2> 
<h3 id="1.%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1">1.原型对象</h3> 
<blockquote> 
 <p>构造函数通过原型分配的函数是所有对象所共享的。</p> 
</blockquote> 
<blockquote> 
 <ul><li> <p>JavaScript 规定，每一个构造函数都有一个<span style="color:#ff9900;"><strong> prototype </strong></span>属性，<strong>指向另一个对象</strong>，所以我们也称为<span style="color:#ff9900;"><strong>原型对象</strong></span></p> </li><li> <p>这个对象可以<strong>挂载函数</strong>，对象实例化<strong>不会多次创建原型上函数</strong>，节约内存</p> </li><li> <p>我们可以把那些<strong>不变的方法</strong>，直接定义在 <strong>prototype 对象</strong>上，这样<strong>所有对象的实例就可以共享这些方法</strong>。</p> </li><li> <p><strong>构造函数</strong>和<strong>原型对象中的this</strong> 都指向 <strong>实例化的对象</strong></p> </li></ul> 
</blockquote> 
<pre><code class="language-javascript">  
  &lt;script&gt;
    function Person() {
      
    }
  ​
    // 每个函数都有 prototype 属性
    console.log(Person.prototype)
  &lt;/script&gt;</code></pre> 
<blockquote> 
 <p>了解了 JavaScript 中构造函数与原型对象的关系后，再来看<strong>原型对象具体的作用</strong>，如下代码所示：</p> 
</blockquote> 
<pre><code class="language-javascript">  
  &lt;script&gt;
    function Person() {
      // 此处未定义任何方法
    }
  ​
    // 为构造函数的原型对象添加方法
    Person.prototype.sayHi = function () {
      console.log('Hi~');
    }
    
    // 实例化
    let p1 = new Person();
    p1.sayHi(); // 输出结果为 Hi~
  &lt;/script&gt;</code></pre> 
<blockquote> 
 <p>构造函数 <code>Person</code> 中未定义任何方法，这时实例对象调用了<strong>原型对象中的方法 <code>sayHi</code></strong>，接下来改动一下代码：</p> 
</blockquote> 
<pre><code class="language-javascript">  
  &lt;script&gt;
    function Person() {
      // 此处定义同名方法 sayHi
      this.sayHi = function () {
        console.log('嗨!');
      }
    }
  ​
    // 为构造函数的原型对象添加方法
    Person.prototype.sayHi = function () {
      console.log('Hi~');
    }
  ​
    let p1 = new Person();
    p1.sayHi(); // 输出结果为 嗨!
  &lt;/script&gt;</code></pre> 
<blockquote> 
 <p>构造函数 <code>Person</code> 中定义与原型对象中<strong>相同名称</strong>的方法，这时实例对象调用则是<strong>构造函中的方法 <code>sayHi</code></strong>。</p> 
</blockquote> 
<blockquote> 
 <p>通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：<strong><span style="color:#ff9900;">当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享</span>。</strong></p> 
</blockquote> 
<pre><code class="language-javascript">  
  &lt;script&gt;
    function Person() {
      // 此处定义同名方法 sayHi
      this.sayHi = function () {
        console.log('嗨!' + this.name)
      }
    }
  ​
    // 为构造函数的原型对象添加方法
    Person.prototype.sayHi = function () {
      console.log('Hi~' + this.name)
    }
    // 在构造函数的原型对象上添加属性
    Person.prototype.name = '小明'
  ​
    let p1 = new Person()
    p1.sayHi(); // 输出结果为 嗨!
    
    let p2 = new Person()
    p2.sayHi()
  &lt;/script&gt;</code></pre> 
<blockquote> 
 <p>总结：<strong>结合构造函数原型的特征，实际开发中往往会将封装的功能函数添加到原型对象中。</strong></p> 
</blockquote> 
<h3 id="2.constructor%20%E5%B1%9E%E6%80%A7"><strong>2.constructor 属性</strong></h3> 
<blockquote> 
 <p>在哪里？==&gt; 每个原型对象里面都有个<strong>constructor 属性（constructor 构造函数）</strong></p> 
</blockquote> 
<blockquote> 
 <p>作用：该属性指向<strong>该原型对象的构造函数</strong>， 简单理解，就是指向我的爸爸，我是有爸爸的孩子</p> 
</blockquote> 
<p><strong>使用场景：</strong></p> 
<blockquote> 
 <p>如果有多个对象的方法，我们可以给原型对象采取<strong>对象形式赋值.</strong></p> 
 <p></p> 
 <p>但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了</p> 
 <p></p> 
 <p>此时，我们可以在修改后的原型对象中，<strong>添加一个 constructor 指向原来的构造函数</strong>。</p> 
</blockquote> 
<h3 id="3.%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B">3.对象原型</h3> 
<blockquote> 
 <p>对象都会有一个属性<span style="color:#ff9900;"> <strong>proto</strong></span> 指向构造函数的 <strong>prototype</strong> 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <strong>proto</strong> 原型的存在。</p> 
</blockquote> 
<p>注意：</p> 
<blockquote> 
 <ul><li> <p><strong>proto</strong> 是JS非标准属性</p> </li><li> <p><strong>[[prototype]]</strong>和<strong>proto</strong>意义相同</p> </li><li> <p>用来表明当前实例对象<strong>指向哪个原型对象prototype</strong></p> </li><li> <p><strong>proto</strong>对象原型里面也有一个 <strong>constructor</strong>属性，指向<strong>创建该实例对象的构造函数</strong></p> </li></ul> 
</blockquote> 
<h3 id="4.%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF">4.原型继承</h3> 
<blockquote> 
 <p>继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是<strong>借助原型对象实现继承</strong>的特性。</p> 
</blockquote> 
<p>龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义。</p> 
<pre><code class="language-javascript">  
  &lt;body&gt;
    &lt;script&gt;
      // 继续抽取   公共的部分放到原型上
      // const Person1 = {
      //   eyes: 2,
      //   head: 1
      // }
      // const Person2 = {
      //   eyes: 2,
      //   head: 1
      // }
      // 构造函数  new 出来的对象 结构一样，但是对象不一样
      function Person() {
        this.eyes = 2
        this.head = 1
      }
      // console.log(new Person)
      // 女人  构造函数   继承  想要 继承 Person
      function Woman() {
  ​
      }
      // Woman 通过原型来继承 Person
      // 父构造函数（父类）   子构造函数（子类）
      // 子类的原型 =  new 父类  
      Woman.prototype = new Person()   // {eyes: 2, head: 1} 
      // 指回原来的构造函数
      Woman.prototype.constructor = Woman
  ​
      // 给女人添加一个方法  生孩子
      Woman.prototype.baby = function () {
        console.log('宝贝')
      }
      const red = new Woman()
      console.log(red)
      // console.log(Woman.prototype)
      // 男人 构造函数  继承  想要 继承 Person
      function Man() {
  ​
      }
      // 通过 原型继承 Person
      Man.prototype = new Person()
      Man.prototype.constructor = Man
      const pink = new Man()
      console.log(pink)
    &lt;/script&gt;
  &lt;/body&gt;</code></pre> 
<h3 id="5.%E5%8E%9F%E5%9E%8B%E9%93%BE">5.原型链</h3> 
<blockquote> 
 <p>基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将<span style="color:#ff9900;"><strong>原型对象的链状结构关系</strong></span>称为<span style="color:#ff9900;"><strong>原型链</strong></span></p> 
</blockquote> 
<pre></pre> 
<pre><code class="language-javascript"> &lt;body&gt;
    &lt;script&gt;
      // function Objetc() {}
      console.log(Object.prototype)
      console.log(Object.prototype.__proto__)
  ​
      function Person() {
  ​
      }
      const ldh = new Person()
      // console.log(ldh.__proto__ === Person.prototype)
      // console.log(Person.prototype.__proto__ === Object.prototype)
      console.log(ldh instanceof Person)
      console.log(ldh instanceof Object)
      console.log(ldh instanceof Array)
      console.log([1, 2, 3] instanceof Array)
      console.log(Array instanceof Object)
    &lt;/script&gt;
  &lt;/body&gt;</code></pre> 
<blockquote> 
 <p>① 当访问一个对象的属性（包括方法）时，<strong>首先查找这个对象自身有没有该属性</strong>。</p> 
 <p>② 如果没有就查找它的原型（也就是 <strong>proto</strong>指向的<strong> prototype 原型对象</strong>）</p> 
 <p>③ 如果还没有就查找<strong>原型对象的原型</strong>（Object的原型对象）</p> 
 <p>④ 依此类推一直找到 Object 为止（<strong>null</strong>）</p> 
 <p>⑤ <strong>proto</strong>对象原型的意义就在于<strong>为对象成员查找机制提供一个方向，或者说一条路线</strong></p> 
 <p>⑥ 可以使用 instanceof 运算符用于检测<strong>构造函数的 prototype </strong>属性是否出现在<strong>某个实例对象的原型链上</strong></p> 
</blockquote> 
<p>  好了，本文就到这里吧，<strong><u>点个关注</u></strong>再走嘛~ </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/81/c8/efMk4iTe_o.gif"></p> 
<blockquote> 
 <p>🚀 个人简介：7年开发经验，某大型国企前端负责人，信息系统项目管理师、CSDN优质创作者、阿里云专家博主，华为云云享专家，分享前端相关技术与工作常见问题~<br> 💟 作    者：前端菜鸟的自我修养❣️<br> 📝 专    栏：<a class="link-info" href="https://blog.csdn.net/2301_78542842/category_12657025.html" title="javascript深入研究">javascript深入研究</a><br> 🌈 若有帮助，还请<strong> <em><span style="color:#333333;"><span style="background-color:#ffd900;">关注➕点赞➕收藏  </span></span></em></strong>，不行的话我再努努力💪💪💪 </p> 
</blockquote> 
<blockquote> 
 <p> 更多专栏订阅推荐：</p> 
 <p>👍 <a href="http://t.csdnimg.cn/4Cw5v" rel="nofollow" title="前端工程搭建">前端工程搭建</a><br> 💕 <a href="https://blog.csdn.net/2301_78542842/category_12662200.html?spm=1001.2014.3001.5482" title="vue从基础到起飞">vue从基础到起飞</a></p> 
 <p>📝 <a href="https://blog.csdn.net/2301_78542842/category_12665119.html?spm=1001.2014.3001.5482" title="前端工作常见问题汇总">前端工作常见问题汇总</a></p> 
 <p>✍️ <a href="https://blog.csdn.net/2301_78542842/category_12696325.html?spm=1001.2014.3001.5482" title="GIS地图与大数据可视化">GIS地图与大数据可视化</a></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8b/80/UwKgfyUE_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7532d04cd401449854019958fdb61599/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux修改内核实现禁止被ping</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72225ef7c16ceb708999855e01ada168/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【机器学习】Datawhale-AI夏令营分子性质AI预测挑战赛-基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>