<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数学建模】——【python】实现【最短路径】【最小生成树】【复杂网络分析】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/935098a634182cec759253e76dc36aa0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数学建模】——【python】实现【最短路径】【最小生成树】【复杂网络分析】">
  <meta property="og:description" content="目录
1. 最短路径问题 - 绘制城市间旅行最短路径图
题目描述：
要求：
示例数据：
python 代码实现
实现思想：
要点：
2. 最小生成树问题 - Kruskal算法绘制MST
题目描述：
要求：
示例数据：
python代码实现
实现思想：
要点：
3. 结合最短路径与最小生成树的复杂网络分析
题目描述：
python代码
实现思想： 要点：
总结三个问题
专栏：数学建模学习笔记
上一篇：【数学建模】图与网络模型的学习
本篇是题目练习
1. 最短路径问题 - 绘制城市间旅行最短路径图 题目描述： 假设有一个包含多个城市及其之间距离的列表（或图结构），其中每个城市是图中的一个节点，城市之间的距离是边的权重。使用Dijkstra算法或Floyd-Warshall算法（视情况而定，如果图中节点数较多，推荐使用Dijkstra；如果需要求出所有点对间的最短路径，则使用Floyd-Warshall）来计算并绘制出从一个指定城市到其他所有城市的最短路径图。
要求： （1）使用Python编程，可以利用networkx库来构建图和处理图算法。
（2）绘制结果应包含所有节点（城市）和表示最短路径的边，边的粗细或颜色可以表示距离长短。
（3）标注每条边的权重（距离）。
（4）城市的数量N通过键盘输入，城市之间的距离通过随机数生成。
示例数据： # 城市间的距离矩阵（假设为完全图，即任意两城市间都有直接路径） distances = [ [0, 5, 10, 15], [5, 0, 3, 8], [10, 3, 0, 6], [15, 8, 6, 0] ] # 假设城市名称为 A, B, C, D">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T23:37:46+08:00">
    <meta property="article:modified_time" content="2024-07-24T23:37:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数学建模】——【python】实现【最短路径】【最小生成树】【复杂网络分析】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%C2%A0%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%20-%20%E7%BB%98%E5%88%B6%E5%9F%8E%E5%B8%82%E9%97%B4%E6%97%85%E8%A1%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%9B%BE-toc" style="margin-left:0px;"><a href="#1.%C2%A0%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%20-%20%E7%BB%98%E5%88%B6%E5%9F%8E%E5%B8%82%E9%97%B4%E6%97%85%E8%A1%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%9B%BE" rel="nofollow">1. 最短路径问题 - 绘制城市间旅行最短路径图</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A" rel="nofollow">题目描述：</a></p> 
<p id="%E8%A6%81%E6%B1%82%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E8%A6%81%E6%B1%82%EF%BC%9A" rel="nofollow">要求：</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%9A" rel="nofollow">示例数据：</a></p> 
<p id="python%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#python%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">python 代码实现</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">实现思想：</a></p> 
<p id="%E8%A6%81%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%A6%81%E7%82%B9%EF%BC%9A" rel="nofollow">要点：</a></p> 
<p id="2.%C2%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%20-%20Kruskal%E7%AE%97%E6%B3%95%E7%BB%98%E5%88%B6MST-toc" style="margin-left:0px;"><a href="#2.%C2%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%20-%20Kruskal%E7%AE%97%E6%B3%95%E7%BB%98%E5%88%B6MST" rel="nofollow">2. 最小生成树问题 - Kruskal算法绘制MST</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A" rel="nofollow">题目描述：</a></p> 
<p id="%E8%A6%81%E6%B1%82%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E8%A6%81%E6%B1%82%EF%BC%9A" rel="nofollow">要求：</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%9A" rel="nofollow">示例数据：</a></p> 
<p id="python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">python代码实现</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">实现思想：</a></p> 
<p id="%E8%A6%81%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%A6%81%E7%82%B9%EF%BC%9A" rel="nofollow">要点：</a></p> 
<p id="3.%C2%A0%E7%BB%93%E5%90%88%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#3.%C2%A0%E7%BB%93%E5%90%88%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90" rel="nofollow">3. 结合最短路径与最小生成树的复杂网络分析</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A" rel="nofollow">题目描述：</a></p> 
<p id="python%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#python%E4%BB%A3%E7%A0%81" rel="nofollow">python代码</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A%C2%A0" rel="nofollow">实现思想： </a></p> 
<p id="%E8%A6%81%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%A6%81%E7%82%B9%EF%BC%9A" rel="nofollow">要点：</a></p> 
<p id="%E6%80%BB%E7%BB%93%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98" rel="nofollow">总结三个问题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p class="img-center"><img alt="ce6fbd68767d465bbe94b775b8b811db.png" height="126" src="https://images2.imgbox.com/be/cc/lOSWx39w_o.png" width="126"></p> 
<p class="img-center"><img alt="731bd47804784fa2897220a90a387b28.gif" height="89" src="https://images2.imgbox.com/5e/04/AVTKJS9m_o.gif" width="283"></p> 
<blockquote> 
 <p>专栏：<a href="https://blog.csdn.net/2303_77720864/category_12707137.html" title="数学建模学习笔记">数学建模学习笔记</a></p> 
 <p>上一篇：【<a class="link-info" href="https://blog.csdn.net/2303_77720864/article/details/140646447?spm=1001.2014.3001.5501" title="数学建模】图与网络模型的学习">数学建模】图与网络模型的学习</a></p> 
 <p>本篇是题目练习</p> 
</blockquote> 
<h2 id="1.%C2%A0%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%20-%20%E7%BB%98%E5%88%B6%E5%9F%8E%E5%B8%82%E9%97%B4%E6%97%85%E8%A1%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%9B%BE" style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. 最短路径问题 - 绘制城市间旅行最短路径图</strong></strong></h2> 
<h3 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A" style="margin-left:.0001pt;text-align:justify;"><strong><strong>题目描述：</strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">假设有一个包含多个城市及其之间距离的列表（或图结构），其中每个城市是图中的一个节点，城市之间的距离是边的权重。使用Dijkstra算法或Floyd-Warshall算法（视情况而定，如果图中节点数较多，推荐使用Dijkstra；如果需要求出所有点对间的最短路径，则使用Floyd-Warshall）来计算并绘制出从一个指定城市到其他所有城市的最短路径图。</p> 
<h4 id="%E8%A6%81%E6%B1%82%EF%BC%9A" style="margin-left:.0001pt;text-align:justify;"><strong><strong>要求：</strong></strong></h4> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">（1）使用Python编程，可以利用networkx库来构建图和处理图算法。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（2）绘制结果应包含所有节点（城市）和表示最短路径的边，边的粗细或颜色可以表示距离长短。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（3）标注每条边的权重（距离）。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（4）城市的数量N通过键盘输入，城市之间的距离通过随机数生成。</p> 
</blockquote> 
<h4 id="%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%9A" style="margin-left:.0001pt;text-align:justify;"><strong><strong>示例数据：</strong></strong></h4> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"># 城市间的距离矩阵（假设为完全图，即任意两城市间都有直接路径）  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">distances = [  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    [0, 5, 10, 15],  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    [5, 0, 3, 8],  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    [10, 3, 0, 6],  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    [15, 8, 6, 0]  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">]  </p> 
 <p style="margin-left:.0001pt;text-align:justify;"># 假设城市名称为 A, B, C, D</p> 
</blockquote> 
<h3 id="python%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">python 代码实现</h3> 
<pre><code>import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.font_manager as fm

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei']  # 使用黑体
plt.rcParams['axes.unicode_minus'] = False  # 解决负号显示问题

# 输入城市数量
N = int(input("请输入城市数量: "))

# 生成随机的距离矩阵，距离在1到20之间
distances = np.random.randint(1, 21, size=(N, N))
np.fill_diagonal(distances, 0)  # 对角线距离为0

# 打印生成的距离矩阵
print("城市间的距离矩阵：")
print(distances)

# 创建图并添加边
G = nx.Graph()

# 添加节点
cities = [chr(i) for i in range(65, 65 + N)]  # 使用A, B, C...表示城市
G.add_nodes_from(cities)

# 添加边及其权重
for i in range(N):
    for j in range(i + 1, N):
        G.add_edge(cities[i], cities[j], weight=distances[i][j])

# 输入起始城市
start_city = input(f"请输入起始城市({', '.join(cities)}): ")

# 使用Dijkstra算法计算从起始城市到所有其他城市的最短路径
lengths, paths = nx.single_source_dijkstra(G, source=start_city)

# 打印最短路径信息
print("从起始城市到其他城市的最短路径：")
for target in cities:
    print(f"{start_city}到{target}的最短路径为{paths[target]}，距离为{lengths[target]}")

# 获取从起始城市到最后一个城市的最短路径
end_city = cities[-1]
shortest_path = paths[end_city]

# 绘制图形
pos = nx.spring_layout(G)

# 创建绘图区域
fig, ax = plt.subplots()

# 绘制所有节点
nx.draw_networkx_nodes(G, pos, node_size=500, ax=ax)

# 绘制所有边并根据权重调整颜色和宽度
edges = G.edges(data=True)
edge_colors = [edge[2]['weight'] for edge in edges]
edge_widths = [edge[2]['weight'] / 5 for edge in edges]
edges_drawn = nx.draw_networkx_edges(G, pos, edgelist=edges, width=edge_widths, edge_color=edge_colors, edge_cmap=plt.cm.Blues, ax=ax)

# 绘制最短路径的边，使用不同颜色和宽度
path_edges = [(shortest_path[i], shortest_path[i + 1]) for i in range(len(shortest_path) - 1)]
nx.draw_networkx_edges(G, pos, edgelist=path_edges, width=2, edge_color='r', ax=ax)

# 绘制节点标签
nx.draw_networkx_labels(G, pos, font_size=12, font_color='black', ax=ax)

# 绘制边标签
edge_labels = {(edge[0], edge[1]): edge[2]['weight'] for edge in edges}
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, ax=ax)

# 创建颜色映射条
sm = plt.cm.ScalarMappable(cmap=plt.cm.Blues, norm=plt.Normalize(vmin=min(edge_colors), vmax=max(edge_colors)))
sm.set_array([])  # 仅用于显示色条
fig.colorbar(sm, ax=ax, label='距离')

# 显示图形
plt.title(f"从城市 {start_city} 到城市 {end_city} 的最短路径图")
plt.axis('off')
plt.show()
</code></pre> 
<blockquote> 
 <p>请输入城市数量: 5<br> 城市间的距离矩阵：<br> [[ 0  3  6  1 16]<br>  [18  0  9 11  3]<br>  [16  2  0  5 11]<br>  [ 9  8  1  0 17]<br>  [ 2  7  1  3  0]]<br> 请输入起始城市(A, B, C, D, E): A<br> 从起始城市到其他城市的最短路径：<br> A到A的最短路径为['A']，距离为0<br> A到B的最短路径为['A', 'B']，距离为3<br> A到C的最短路径为['A', 'C']，距离为6<br> A到D的最短路径为['A', 'D']，距离为1<br> A到E的最短路径为['A', 'B', 'E']，距离为6</p> 
</blockquote> 
<p><img alt="" height="480" src="https://images2.imgbox.com/31/a9/ZIlbYtqQ_o.png" width="640"></p> 
<h3 id="%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A">实现思想：</h3> 
<blockquote> 
 <ol><li> <p><strong>图的表示与构建</strong>：</p> 
   <ul><li>使用图数据结构表示城市和它们之间的距离。节点表示城市，边的权重表示城市之间的距离。</li><li>通过一个距离矩阵来表示各城市间的距离。</li></ul></li><li> <p><strong>Dijkstra算法</strong>：</p> 
   <ul><li>用于计算从一个指定城市（源城市）到其他所有城市的最短路径。</li><li>该算法适用于无负权边的图，通过贪心策略找到最短路径。</li></ul></li><li> <p><strong>可视化</strong>：</p> 
   <ul><li>使用 <code>networkx</code> 库构建图并计算最短路径。</li><li>使用 <code>matplotlib</code> 库绘制图形，展示所有城市及其间的最短路径。</li></ul></li></ol> 
</blockquote> 
<h3 id="%E8%A6%81%E7%82%B9%EF%BC%9A">要点：</h3> 
<blockquote> 
 <ol><li> <p><strong>构建随机距离矩阵</strong>：</p> 
   <ul><li>随机生成一个 <code>N x N</code> 的矩阵，表示 <code>N</code> 个城市间的距离。对角线元素为0（表示城市与自身的距离为0）。</li></ul></li><li> <p><strong>构建图并添加边</strong>：</p> 
   <ul><li>使用 <code>networkx.Graph()</code> 创建图对象。</li><li>使用嵌套的 <code>for</code> 循环，将矩阵中的距离作为边的权重添加到图中。</li></ul></li><li> <p><strong>计算最短路径</strong>：</p> 
   <ul><li>使用 <code>nx.single_source_dijkstra</code> 函数，计算从指定源城市到所有其他城市的最短路径和路径长度。</li></ul></li><li> <p><strong>绘制图形</strong>：</p> 
   <ul><li>使用 <code>nx.spring_layout</code> 生成图节点的布局。</li><li>使用 <code>nx.draw</code> 和 <code>nx.draw_networkx_edge_labels</code> 绘制图和边的权重。</li><li>突出显示最短路径，使用不同颜色或加粗显示。</li></ul></li></ol> 
</blockquote> 
<h2 id="2.%C2%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%20-%20Kruskal%E7%AE%97%E6%B3%95%E7%BB%98%E5%88%B6MST" style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. 最小生成树问题 - Kruskal算法绘制MST</strong></strong></h2> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>题目描述：</strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">给定一个无向带权图，使用Kruskal算法找到并绘制该图的最小生成树（MST）。最小生成树是图中的一个子图，它包含图中所有顶点且边的权重之和最小。</p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>要求：</strong></strong></h4> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">（1）使用networkx库来处理图结构。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（2）绘制结果应清晰地展示MST中的所有边和顶点，并且可以通过边的颜色或粗细来区分MST中的边与其他边。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（3）标注MST的总权重。</p> 
</blockquote> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>示例数据：</strong></strong></h4> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"># 边列表，每个元素是一个三元组(起点, 终点, 权重)  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">edges = [  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    ('A', 'B', 1),  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    ('A', 'C', 4),  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    ('A', 'D', 7),  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    ('B', 'C', 2),  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    ('B', 'D', 5),  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    ('C', 'D', 3),  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    ('C', 'E', 6),  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">    ('D', 'E', 8)  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">]</p> 
</blockquote> 
<h3 id="python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">python代码实现</h3> 
<pre><code>import networkx as nx
import matplotlib.pyplot as plt

# 边列表，每个元素是一个三元组(起点 终点 权重)
edges = [
    ('A', 'B', 1),
    ('A', 'C', 4),
    ('A', 'D', 7),
    ('B', 'C', 2),
    ('B', 'D', 5),
    ('C', 'D', 3),
    ('C', 'E', 6),
    ('D', 'E', 8)
]

# 构建图
G = nx.Graph()
G.add_weighted_edges_from(edges)

# 使用Kruskal算法计算MST
mst = nx.minimum_spanning_tree(G, algorithm='kruskal')

# 绘制图
pos = nx.spring_layout(G)
plt.figure(figsize=(10, 8))

# 绘制原始图
nx.draw(G, pos, with_labels=True, node_size=500, node_color="lightblue", alpha=0.6)
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

# 绘制MST
nx.draw(mst, pos, with_labels=True, node_size=500, node_color="lightgreen", edge_color="red", width=2)
labels_mst = nx.get_edge_attributes(mst, 'weight')
nx.draw_networkx_edge_labels(mst, pos, edge_labels=labels_mst)

# 计算MST的总权重
total_weight = mst.size(weight='weight')
plt.title(f"Minimum Spanning Tree (Total Weight: {total_weight})")
plt.show()
</code></pre> 
<p><img alt="" height="800" src="https://images2.imgbox.com/dc/42/WHWpGhcF_o.png" width="1000"></p> 
<h3>实现思想：</h3> 
<blockquote> 
 <ol><li> <p><strong>图的表示与构建</strong>：</p> 
   <ul><li>使用图数据结构表示城市和它们之间的距离。节点表示城市，边的权重表示城市之间的距离。</li><li>使用边列表表示图，其中每个元素是一个三元组 <code>(起点, 终点, 权重)</code>。</li></ul></li><li> <p><strong>Kruskal算法</strong>：</p> 
   <ul><li>用于找到图的最小生成树（MST）。</li><li>通过贪心策略，逐步选择权重最小的边，构建权重和最小的树。</li></ul></li><li> <p><strong>可视化</strong>：</p> 
   <ul><li>使用 <code>networkx</code> 库构建图并计算MST。</li><li>使用 <code>matplotlib</code> 库绘制图形，展示MST的所有节点和边。</li></ul></li></ol> 
</blockquote> 
<h3>要点：</h3> 
<blockquote> 
 <ol><li> <p><strong>定义边列表</strong>：</p> 
   <ul><li>创建一个包含边的列表，每个元素是一个三元组 <code>(起点, 终点, 权重)</code>。</li></ul></li><li> <p><strong>构建图并添加边</strong>：</p> 
   <ul><li>使用 <code>networkx.Graph()</code> 创建图对象。</li><li>使用 <code>G.add_weighted_edges_from(edges)</code> 添加边到图中。</li></ul></li><li> <p><strong>计算MST</strong>：</p> 
   <ul><li>使用 <code>nx.minimum_spanning_tree(G, algorithm='kruskal')</code> 计算图的最小生成树。</li></ul></li><li> <p><strong>绘制图形</strong>：</p> 
   <ul><li>使用 <code>nx.spring_layout</code> 生成图节点的布局。</li><li>使用 <code>nx.draw</code> 和 <code>nx.draw_networkx_edge_labels</code> 绘制原始图及其边的权重。</li><li>突出显示MST，使用不同颜色或加粗显示。</li></ul></li></ol> 
</blockquote> 
<h2 id="3.%C2%A0%E7%BB%93%E5%90%88%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90" style="margin-left:.0001pt;text-align:justify;"><strong><strong>3. 结合最短路径与最小生成树的复杂网络分析</strong></strong></h2> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>题目描述：</strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">考虑一个大型交通网络，其中节点代表城市，边代表道路，边的权重代表道路的长度或旅行时间。首先，使用Kruskal算法找出这个网络的最小生成树（代表最基本的交通网络框架）。然后，在此MST的基础上，选择一个“核心城市”作为起点，使用Dijkstra算法找出从该城市到其他所有城市的最短路径。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>要求：</strong></strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">（1）绘制两个图：一个是MST，另一个是以核心城市为中心的最短路径图（可以只显示与核心城市直接相连的最短路径）。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（2）MST图中应清晰区分MST边和非MST边。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（3）最短路径图中，最短路径的边可以用特殊颜色或加粗显示，并标注核心城市到各城市的最短路径长度。</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>示例数据：</strong></strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">自行设计更复杂的数据集。</p> 
</blockquote> 
<h3 id="python%E4%BB%A3%E7%A0%81">python代码</h3> 
<pre><code>import networkx as nx
import matplotlib.pyplot as plt
from matplotlib import font_manager

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei']  # 使用黑体
plt.rcParams['axes.unicode_minus'] = False  # 解决坐标轴负号显示问题

# 边列表，每个元素是一个三元组(起点, 终点, 权重)
edges = [
    ('A', 'B', 1),
    ('A', 'C', 4),
    ('A', 'D', 7),
    ('B', 'C', 2),
    ('B', 'D', 5),
    ('C', 'D', 3),
    ('C', 'E', 6),
    ('D', 'E', 8)
]

# 构建图
G = nx.Graph()
G.add_weighted_edges_from(edges)

# 使用Kruskal算法计算MST
mst = nx.minimum_spanning_tree(G, algorithm='kruskal')

# 使用Dijkstra算法计算最短路径
core_city = 'A'
lengths, paths = nx.single_source_dijkstra(mst, source=core_city)

# 绘制MST
pos = nx.spring_layout(G)
plt.figure(figsize=(20, 8))

plt.subplot(121)
nx.draw(G, pos, with_labels=True, node_size=500, node_color="lightblue", alpha=0.6)
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

nx.draw(mst, pos, with_labels=True, node_size=500, node_color="lightgreen", edge_color="red", width=2)
labels_mst = nx.get_edge_attributes(mst, 'weight')
nx.draw_networkx_edge_labels(mst, pos, edge_labels=labels_mst)
total_weight = mst.size(weight='weight')
plt.title(f"最小生成树 (总权重: {total_weight})")

# 绘制最短路径图
plt.subplot(122)
nx.draw(mst, pos, with_labels=True, node_size=500, node_color="lightblue")
labels_mst = nx.get_edge_attributes(mst, 'weight')
nx.draw_networkx_edge_labels(mst, pos, edge_labels=labels_mst)

for target in lengths:
    if target == core_city:
        continue
    path = paths[target]
    edges_in_path = [(path[i], path[i + 1]) for i in range(len(path) - 1)]
    nx.draw_networkx_edges(mst, pos, edgelist=edges_in_path, width=2, edge_color='r')
    path_length = lengths[target]
    plt.text(pos[path[-1]][0], pos[path[-1]][1], f"{path_length:.2f}", fontsize=12, color='red')

plt.title(f"从核心城市 {core_city} 出发的最短路径")

plt.show()
</code></pre> 
<p><img alt="" height="800" src="https://images2.imgbox.com/58/1e/Qtj3YdJ4_o.png" width="1200"></p> 
<h3 id="%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A%C2%A0">实现思想： </h3> 
<blockquote> 
 <ol><li> <p><strong>图的表示与构建</strong>：</p> 
   <ul><li>使用图数据结构表示城市和它们之间的距离。节点表示城市，边的权重表示城市之间的距离。</li><li>使用边列表表示图，其中每个元素是一个三元组 <code>(起点, 终点, 权重)</code>。</li></ul></li><li> <p><strong>计算MST</strong>：</p> 
   <ul><li>使用 Kruskal算法计算图的最小生成树（MST）。</li></ul></li><li> <p><strong>计算最短路径</strong>：</p> 
   <ul><li>在MST的基础上，使用Dijkstra算法计算核心城市到其他所有城市的最短路径。</li></ul></li><li> <p><strong>可视化</strong>：</p> 
   <ul><li>绘制两个图：一个是MST，一个是核心城市的最短路径图。</li><li>使用 <code>networkx</code> 库构建图并计算MST和最短路径。</li><li>使用 <code>matplotlib</code> 库绘制图形，展示MST和最短路径。</li></ul></li></ol> 
</blockquote> 
<h3>要点：</h3> 
<blockquote> 
 <ol><li> <p><strong>定义边列表</strong>：</p> 
   <ul><li>创建一个包含边的列表，每个元素是一个三元组 <code>(起点, 终点, 权重)</code>。</li></ul></li><li> <p><strong>构建图并添加边</strong>：</p> 
   <ul><li>使用 <code>networkx.Graph()</code> 创建图对象。</li><li>使用 <code>G.add_weighted_edges_from(edges)</code> 添加边到图中。</li></ul></li><li> <p><strong>计算MST</strong>：</p> 
   <ul><li>使用 <code>nx.minimum_spanning_tree(G, algorithm='kruskal')</code> 计算图的最小生成树。</li></ul></li><li> <p><strong>计算最短路径</strong>：</p> 
   <ul><li>使用 <code>nx.single_source_dijkstra(mst, source=core_city)</code> 在MST上计算核心城市到其他城市的最短路径。</li></ul></li><li> <p><strong>绘制图形</strong>：</p> 
   <ul><li>使用 <code>nx.spring_layout</code> 生成图节点的布局。</li><li>使用 <code>plt.figure</code> 创建绘图窗口。</li><li>使用 <code>nx.draw</code> 和 <code>nx.draw_networkx_edge_labels</code> 绘制MST及其边的权重。</li><li>突出显示最短路径，使用不同颜色或加粗显示路径边。</li></ul></li></ol> 
</blockquote> 
<h2 id="%E6%80%BB%E7%BB%93%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98">总结三个问题</h2> 
<p><img alt="" height="230" src="https://images2.imgbox.com/60/32/6fLlHGWI_o.png" width="230"></p> 
<p>这三个问题分别涉及图论中的最短路径问题、最小生成树问题以及结合这两种方法的复杂网络分析。第一个问题使用Dijkstra算法计算并可视化了从一个指定城市到其他所有城市的最短路径，第二个问题使用Kruskal算法找到并绘制了一个无向带权图的最小生成树，第三个问题在最小生成树的基础上，使用Dijkstra算法计算并展示了从核心城市到其他所有城市的最短路径。每个问题都结合了图的构建、算法的应用和结果的可视化。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7be16c6692c1e7e237228f18a3f6641e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DNS(域名解析协议)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7144b9d22022bc7bb56f5c18893641b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于微信小程序的健康饮食系统/健康饮食管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>