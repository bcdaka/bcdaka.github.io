<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>企业级Web服务器性能优化实践指南 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/39cd9968cf53f7d7778eb327f617b94b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="企业级Web服务器性能优化实践指南">
  <meta property="og:description" content="目录
引言
一、 Web服务器基础与发展历程
1.互联网与Web服务发展简史
2. Apache与Nginx的性能对比
2.1 Apache服务器
2.2 Nginx服务器
3. 用户访问体验的重要性
3.1 用户速度体验原则
3.2 影响用户体验的因素
4. 服务端I/O流程与性能
4.1 I/O基本概念
4.2 磁盘I/O
4.3 网络I/O
5. I/O模型详解
5.1 I/O模型相关概念
5.2 网络I/O模型
5.3 I/O模型的比较
6. 零拷贝
6.1零拷贝的概念
6.2零拷贝相关技术
二、 Nginx架构与安装
1.Nginx 架构概述
1.1 Nginx 简介
1.2 核心特性
1.3 进程模型
2.Nginx 安装 2.1 安装前的准备
2.2 编译安装Nginx
2.3.nginx启动文件编写
3平滑升级和回滚
3.1平滑升级流程
3.2.平滑升级
三、Nginx核心配置与优化
1. 配置文件结构
2. 全局配置
3.核心配置
3.1.新建一个 PC web 站点
3.2.root和alias">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-21T16:10:33+08:00">
    <meta property="article:modified_time" content="2024-08-21T16:10:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">企业级Web服务器性能优化实践指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BC%95%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E5%BC%95%E8%A8%80" rel="nofollow">引言</a></p> 
<p id="%E4%B8%80%E3%80%81%20Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%20Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B" rel="nofollow">一、 Web服务器基础与发展历程</a></p> 
<p id="1.%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8EWeb%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2-toc" style="margin-left:80px;"><a href="#1.%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8EWeb%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2" rel="nofollow">1.互联网与Web服务发展简史</a></p> 
<p id="2.%20Apache%E4%B8%8ENginx%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#2.%20Apache%E4%B8%8ENginx%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94" rel="nofollow">2. Apache与Nginx的性能对比</a></p> 
<p id="2.1%20Apache%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:120px;"><a href="#2.1%20Apache%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">2.1 Apache服务器</a></p> 
<p id="2.2%20Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:120px;"><a href="#2.2%20Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">2.2 Nginx服务器</a></p> 
<p id="3.%20%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E4%BD%93%E9%AA%8C%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7-toc" style="margin-left:80px;"><a href="#3.%20%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E4%BD%93%E9%AA%8C%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7" rel="nofollow">3. 用户访问体验的重要性</a></p> 
<p id="3.1%20%E7%94%A8%E6%88%B7%E9%80%9F%E5%BA%A6%E4%BD%93%E9%AA%8C%E5%8E%9F%E5%88%99-toc" style="margin-left:120px;"><a href="#3.1%20%E7%94%A8%E6%88%B7%E9%80%9F%E5%BA%A6%E4%BD%93%E9%AA%8C%E5%8E%9F%E5%88%99" rel="nofollow">3.1 用户速度体验原则</a></p> 
<p id="3.2%20%E5%BD%B1%E5%93%8D%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E7%9A%84%E5%9B%A0%E7%B4%A0-toc" style="margin-left:120px;"><a href="#3.2%20%E5%BD%B1%E5%93%8D%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E7%9A%84%E5%9B%A0%E7%B4%A0" rel="nofollow">3.2 影响用户体验的因素</a></p> 
<p id="4.%20%E6%9C%8D%E5%8A%A1%E7%AB%AFI%2FO%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%80%A7%E8%83%BD-toc" style="margin-left:80px;"><a href="#4.%20%E6%9C%8D%E5%8A%A1%E7%AB%AFI%2FO%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%80%A7%E8%83%BD" rel="nofollow">4. 服务端I/O流程与性能</a></p> 
<p id="4.1%20I%2FO%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:120px;"><a href="#4.1%20I%2FO%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">4.1 I/O基本概念</a></p> 
<p id="4.2%20%E7%A3%81%E7%9B%98I%2FO-toc" style="margin-left:120px;"><a href="#4.2%20%E7%A3%81%E7%9B%98I%2FO" rel="nofollow">4.2 磁盘I/O</a></p> 
<p id="4.3%20%E7%BD%91%E7%BB%9CI%2FO-toc" style="margin-left:120px;"><a href="#4.3%20%E7%BD%91%E7%BB%9CI%2FO" rel="nofollow">4.3 网络I/O</a></p> 
<p id="5.%20I%2FO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3-toc" style="margin-left:80px;"><a href="#5.%20I%2FO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3" rel="nofollow">5. I/O模型详解</a></p> 
<p id="5.1%20I%2FO%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:120px;"><a href="#5.1%20I%2FO%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">5.1 I/O模型相关概念</a></p> 
<p id="5.2%20%E7%BD%91%E7%BB%9CI%2FO%E6%A8%A1%E5%9E%8B-toc" style="margin-left:120px;"><a href="#5.2%20%E7%BD%91%E7%BB%9CI%2FO%E6%A8%A1%E5%9E%8B" rel="nofollow">5.2 网络I/O模型</a></p> 
<p id="5.3%20I%2FO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:120px;"><a href="#5.3%20I%2FO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">5.3 I/O模型的比较</a></p> 
<p id="6.%20%E9%9B%B6%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#6.%20%E9%9B%B6%E6%8B%B7%E8%B4%9D" rel="nofollow">6. 零拷贝</a></p> 
<p id="6.1%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:120px;"><a href="#6.1%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">6.1零拷贝的概念</a></p> 
<p id="6.2%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF-toc" style="margin-left:120px;"><a href="#6.2%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF" rel="nofollow">6.2零拷贝相关技术</a></p> 
<p id="%E4%BA%8C%E3%80%81%C2%A0Nginx%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%89%E8%A3%85-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%C2%A0Nginx%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%89%E8%A3%85" rel="nofollow">二、 Nginx架构与安装</a></p> 
<p id="1.Nginx%20%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0-toc" style="margin-left:80px;"><a href="#1.Nginx%20%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0" rel="nofollow">1.Nginx 架构概述</a></p> 
<p id="1.1%20Nginx%20%E7%AE%80%E4%BB%8B-toc" style="margin-left:120px;"><a href="#1.1%20Nginx%20%E7%AE%80%E4%BB%8B" rel="nofollow">1.1 Nginx 简介</a></p> 
<p id="1.2%20%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-toc" style="margin-left:120px;"><a href="#1.2%20%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7" rel="nofollow">1.2 核心特性</a></p> 
<p id="1.3%20%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B-toc" style="margin-left:120px;"><a href="#1.3%20%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B" rel="nofollow">1.3 进程模型</a></p> 
<p id="2.Nginx%20%E5%AE%89%E8%A3%85%C2%A0-toc" style="margin-left:80px;"><a href="#2.Nginx%20%E5%AE%89%E8%A3%85%C2%A0" rel="nofollow">2.Nginx 安装 </a></p> 
<p id="2.1%20%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87-toc" style="margin-left:120px;"><a href="#2.1%20%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87" rel="nofollow">2.1 安装前的准备</a></p> 
<p id="2.2%20%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Nginx-toc" style="margin-left:120px;"><a href="#2.2%20%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Nginx" rel="nofollow">2.2 编译安装Nginx</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E7%BC%96%E8%BE%914%E3%80%81nginx%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99-toc" style="margin-left:120px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E7%BC%96%E8%BE%914%E3%80%81nginx%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99" rel="nofollow">2.3.nginx启动文件编写</a></p> 
<p id="3%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E5%92%8C%E5%9B%9E%E6%BB%9A-toc" style="margin-left:80px;"><a href="#3%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E5%92%8C%E5%9B%9E%E6%BB%9A" rel="nofollow">3平滑升级和回滚</a></p> 
<p id="3.1%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B-toc" style="margin-left:120px;"><a href="#3.1%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B" rel="nofollow">3.1平滑升级流程</a></p> 
<p id="3.2.%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7-toc" style="margin-left:120px;"><a href="#3.2.%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7" rel="nofollow">3.2.平滑升级</a></p> 
<p id="%E4%B8%89%E3%80%81Nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81Nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96" rel="nofollow">三、Nginx核心配置与优化</a></p> 
<p id="1.%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" rel="nofollow">1. 配置文件结构</a></p> 
<p id="2.%20%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.%20%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE" rel="nofollow">2. 全局配置</a></p> 
<p id="3%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B" rel="nofollow">3.核心配置</a></p> 
<p id="3.1.%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%20PC%20web%20%E7%AB%99%E7%82%B9-toc" style="margin-left:120px;"><a href="#3.1.%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%20PC%20web%20%E7%AB%99%E7%82%B9" rel="nofollow">3.1.新建一个 PC web 站点</a></p> 
<p id="root%E5%92%8Calias-toc" style="margin-left:120px;"><a href="#root%E5%92%8Calias" rel="nofollow">3.2.root和alias</a></p> 
<p id="3.3.location%20%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8-toc" style="margin-left:120px;"><a href="#3.3.location%20%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8" rel="nofollow">3.3.location 的详细使用</a></p> 
<p id="3.4Nginx%20%E8%B4%A6%E6%88%B7%E8%AE%A4%E8%AF%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><a href="#3.4Nginx%20%E8%B4%A6%E6%88%B7%E8%AE%A4%E8%AF%81%E5%8A%9F%E8%83%BD" rel="nofollow">3.4Nginx 账户认证功能</a></p> 
<p id="3.5%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2-toc" style="margin-left:120px;"><a href="#3.5%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2" rel="nofollow">3.5自定义错误页面</a></p> 
<p id="3.4.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97-toc" style="margin-left:120px;"><a href="#3.4.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97" rel="nofollow">3.4.自定义错误日志</a></p> 
<p id="3.5.%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-toc" style="margin-left:120px;"><a href="#3.5.%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8" rel="nofollow">3.5.检测文件是否存在</a></p> 
<p id="3.6.%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%C2%A0-toc" style="margin-left:120px;"><a href="#3.6.%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%C2%A0" rel="nofollow">3.6.长连接配置 </a></p> 
<p id="3.7.%E4%BD%9C%E4%B8%BA%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%C2%A0-toc" style="margin-left:120px;"><a href="#3.7.%E4%BD%9C%E4%B8%BA%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%C2%A0" rel="nofollow">3.7.作为下载服务器配置 </a></p> 
<p id="%E5%9B%9B%E3%80%81Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE" rel="nofollow">四、Nginx 高级配置</a></p> 
<p id="1.Nginx%20%E7%8A%B6%E6%80%81%E9%A1%B5-toc" style="margin-left:80px;"><a href="#1.Nginx%20%E7%8A%B6%E6%80%81%E9%A1%B5" rel="nofollow">1.Nginx 状态页</a></p> 
<p id="2.Nginx%20%E5%8E%8B%E7%BC%A9%E5%8A%9F%E8%83%BD%C2%A0-toc" style="margin-left:80px;"><a href="#2.Nginx%20%E5%8E%8B%E7%BC%A9%E5%8A%9F%E8%83%BD%C2%A0" rel="nofollow">2.Nginx 压缩功能 </a></p> 
<p id="3.Nginx%20%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:80px;"><a href="#3.Nginx%20%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">3.Nginx 变量使用 </a></p> 
<p id="3.1%E3%80%81%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F-toc" style="margin-left:120px;"><a href="#3.1%E3%80%81%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F" rel="nofollow">3.1、内置变量</a></p> 
<p id="%E4%BA%94%E3%80%81Nginx%20Rewrite%20%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81Nginx%20Rewrite%20%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD" rel="nofollow">五、Nginx Rewrite 相关功能</a></p> 
<p id="1.ngx_http_rewrite_module%20%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4%C2%A0-toc" style="margin-left:80px;"><a href="#1.ngx_http_rewrite_module%20%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4%C2%A0" rel="nofollow">1.ngx_http_rewrite_module 模块指令 </a></p> 
<p id="1.1.if%E6%8C%87%E4%BB%A4-toc" style="margin-left:120px;"><a href="#1.1.if%E6%8C%87%E4%BB%A4" rel="nofollow">1.1.if指令</a></p> 
<p id="1.2.set%20%E6%8C%87%E4%BB%A4-toc" style="margin-left:120px;"><a href="#1.2.set%20%E6%8C%87%E4%BB%A4" rel="nofollow">1.2.set 指令</a></p> 
<p id="%C2%A01.3.break%E6%8C%87%E4%BB%A4-toc" style="margin-left:120px;"><a href="#%C2%A01.3.break%E6%8C%87%E4%BB%A4" rel="nofollow"> 1.3.break指令</a></p> 
<p id="1.4.return%20%E6%8C%87%E4%BB%A4-toc" style="margin-left:120px;"><a href="#1.4.return%20%E6%8C%87%E4%BB%A4" rel="nofollow">1.4.return 指令</a></p> 
<p id="2.rewrite%20%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#2.rewrite%20%E6%8C%87%E4%BB%A4" rel="nofollow">2.rewrite 指令</a></p> 
<p id="2.1.%20rewrite%20flag%20%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D-toc" style="margin-left:120px;"><a href="#2.1.%20rewrite%20flag%20%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D" rel="nofollow">2.1. rewrite flag 使用介绍</a></p> 
<p id="2.2.%E5%9F%9F%E5%90%8D%E6%B0%B8%E4%B9%85%EF%BC%88permanent%EF%BC%89%E4%B8%8E%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%88redirect%EF%BC%89-toc" style="margin-left:120px;"><a href="#2.2.%E5%9F%9F%E5%90%8D%E6%B0%B8%E4%B9%85%EF%BC%88permanent%EF%BC%89%E4%B8%8E%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%88redirect%EF%BC%89" rel="nofollow">2.2.域名永久（permanent）与临时重定向（redirect）</a></p> 
<p id="%E5%85%AD%E3%80%81Nginx%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81Nginx%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD" rel="nofollow">六、Nginx 反向代理功能</a></p> 
<p id="1.%E5%AE%9E%E7%8E%B0%20http%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#1.%E5%AE%9E%E7%8E%B0%20http%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" rel="nofollow">1.实现 http 反向代理</a></p> 
<p id="1.1.http%20%E5%8D%8F%E8%AE%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%C2%A0-toc" style="margin-left:120px;"><a href="#1.1.http%20%E5%8D%8F%E8%AE%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%C2%A0" rel="nofollow">1.1.http 协议反向代理 </a></p> 
<p id="1.2.%E6%8C%87%E5%AE%9A%20location%20%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-toc" style="margin-left:120px;"><a href="#1.2.%E6%8C%87%E5%AE%9A%20location%20%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" rel="nofollow">1.2.指定 location 实现反向代理</a></p> 
<p id="2.%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB-toc" style="margin-left:80px;"><a href="#2.%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB" rel="nofollow">2.反向代理实现动静分离</a></p> 
<p id="2.1.%20tcp%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%C2%A0-toc" style="margin-left:120px;"><a href="#2.1.%20tcp%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%C2%A0" rel="nofollow">2.1. tcp负载均衡配置参数 </a></p> 
<p id="2.2.udp%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%3A%20DNS-toc" style="margin-left:120px;"><a href="#2.2.udp%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%3A%20DNS" rel="nofollow">2.2.udp 负载均衡实例: DNS</a></p> 
<p id="3.%E5%AE%9E%E7%8E%B0%20FastCGI%C2%A0-toc" style="margin-left:80px;"><a href="#3.%E5%AE%9E%E7%8E%B0%20FastCGI%C2%A0" rel="nofollow">3.实现 FastCGI </a></p> 
<p id="3.1%E3%80%81Nginx%E4%B8%8Ephp-fpm%E5%9C%A8%E5%90%8C%E4%B8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%C2%A0-toc" style="margin-left:120px;"><a href="#3.1%E3%80%81Nginx%E4%B8%8Ephp-fpm%E5%9C%A8%E5%90%8C%E4%B8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%C2%A0" rel="nofollow">3.1、Nginx与php-fpm在同一服务器 </a></p> 
<p id="3.2.%C2%A0php%E7%9A%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%EF%BC%88php%E7%9A%84%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97%EF%BC%89-toc" style="margin-left:120px;"><a href="#3.2.%C2%A0php%E7%9A%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%EF%BC%88php%E7%9A%84%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97%EF%BC%89" rel="nofollow">3.2. php的动态扩展模块（php的缓存模块）</a></p> 
<p id="%E4%B8%83%E3%80%81nginx%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC-toc" style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81nginx%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC" rel="nofollow">七、nginx二次开发版本</a></p> 
<p id="1.%C2%A0openresty-toc" style="margin-left:80px;"><a href="#1.%C2%A0openresty" rel="nofollow">1. openresty</a></p> 
<p id="2.%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85openresty-toc" style="margin-left:80px;"><a href="#2.%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85openresty" rel="nofollow">2.编译安装openresty</a></p> 
<p id="%E5%85%AB%E3%80%81%E7%BB%93%E8%AF%AD-toc" style="margin-left:40px;"><a href="#%E5%85%AB%E3%80%81%E7%BB%93%E8%AF%AD" rel="nofollow">八、结语</a></p> 
<h3>引言</h3> 
<hr> 
<p>在数字化时代，企业网站的性能直接关联到用户体验和业务成果。高性能的Web服务器不仅能够应对日益增长的用户访问量，还能保证数据的快速处理和传输。本文将深入探讨如何通过优化Web服务器配置，实现企业级服务的高性能目标。</p> 
<h3 id="%E4%B8%80%E3%80%81%20Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B" style="background-color:transparent;">一、 Web服务器基础与发展历程</h3> 
<hr> 
<h4 id="1.%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8EWeb%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2">1.互联网与Web服务发展简史</h4> 
<p>自1993年中国接入Internet以来，互联网服务经历了飞速的发展。从最初的中国黄页、阿里巴巴的创建，到淘宝、支付宝的诞生，再到天猫的更名和阿里巴巴集团的上市，每一个里程碑都标志着互联网服务的一次重大进步。</p> 
<p>Web服务器作为互联网信息服务的核心，也经历了不断的技术革新。从Apache的经典Web服务端到Nginx的高性能服务端，技术的演进使得Web服务器能够更好地应对高并发、高可用性的需求。</p> 
<h4 id="2.%20Apache%E4%B8%8ENginx%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">2. Apache与Nginx的性能对比</h4> 
<h5 id="2.1%20Apache%E6%9C%8D%E5%8A%A1%E5%99%A8">2.1 Apache服务器</h5> 
<p>Apache服务器以其稳定性和广泛的社区支持而闻名。它通过不同的模型（如prefork、worker、event）来处理Web请求，适应不同的应用场景。</p> 
<p>Apache prefork 模型</p> 
<ul><li>预派生模式，有一个主控制进程，然后生成多个子进程，使用select模型，最大并发1024</li><li>每个子进程有一个独立的线程响应用户请求</li><li>相对比较占用内存，但是比较稳定，可以设置最大和最小进程数</li><li>是最古老的一种模式,也是最稳定的模式，适用于访问量不是很大的场景</li></ul> 
<p>优点：稳定</p> 
<p>缺点：每个用户请求需要对应开启一个进程,占用资源较多，并发性差,不适用于高并发场景</p> 
<p> <img alt="" height="379" src="https://images2.imgbox.com/45/78/srwV2DBi_o.png" width="896"></p> 
<p> Apache worker 模型</p> 
<ul><li>一种多进程和多线程混合的模型</li><li>有一个控制进程，启动多个子进程</li><li>每个子进程里面包含固定的线程</li><li>使用线程程来处理请求</li><li>当线程不够使用的时候会再启动一个新的子进程,然后在进程里面再启动线程处理请求</li><li>由于其使用了线程处理请求，因此可以承受更高的并发</li></ul> 
<p>优点：相比prefork 占用的内存较少，可以同时处理更多的请求</p> 
<p>缺点：使用keepalive的长连接方式，某个线程会一直被占据，即使没有传输数据，也需要一直等待到超 时才会被释放。如果过多的线程，被这样占据，也会导致在高并发场景下的无服务线程可用（该问题在 prefork模式下，同样会发生）</p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/55/00/kWZ8XQ6K_o.png" width="849"></p> 
<p> <strong>Apache event</strong><strong>模型</strong></p> 
<ul><li>Apache 中最新的模式， 2012 年发布的 apache 2.4.X 系列正式支持 event 模型 , 属于事件驱动模型 (epoll) 每个进程响应多个请求，在现在版本里的已经是稳定可用的模式</li><li>它和 worker 模式很像，最大的区别在于，它解决了 keepalive 场景下长期被占用的线程的资源浪费问题（某些线程因为被keepalive ，空挂在哪里等待，中间几乎没有请求过来，甚至等到超时）</li><li>event MPM 中，会有一个专门的线程来管理这些 keepalive 类型的线程</li><li>当有真实请求过来的时候，将请求传递给服务线程，执行完毕后，又允许它释放。这样增强了高并发场景下的请求处理能力</li></ul> 
<p>优点：单线程响应多请求，占据更少的内存，高并发下表现更优秀，会有一个专门的线程来管理<br> keepalive类型的线程，当有真实请求过来的时候，将请求传递给服务线程，执行完毕后，又允许<br> 它释放<br> 缺点：没有线程安全控制</p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/85/2b/TEuFCYzm_o.png" width="927"></p> 
<h5 id="2.2%20Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8">2.2 Nginx服务器</h5> 
<p>Nginx以其轻量级、高并发处理能力而受到青睐。它的事件驱动模型和高效的内存管理机制，使其在处理静态内容和代理服务时表现卓越。</p> 
<h4 id="3.%20%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E4%BD%93%E9%AA%8C%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">3. 用户访问体验的重要性</h4> 
<h5 id="3.1%20%E7%94%A8%E6%88%B7%E9%80%9F%E5%BA%A6%E4%BD%93%E9%AA%8C%E5%8E%9F%E5%88%99">3.1 用户速度体验原则</h5> 
<p>用户对网页加载速度的容忍度非常有限。根据1-3-10原则：</p> 
<ul><li><strong>1秒</strong>内完成加载的网页提供最佳用户体验。</li><li><strong>1-3秒</strong>内加载完成的网页用户体验较好。</li><li><strong>3-10秒</strong>内加载完成的网页用户体验较差。</li><li>超过<strong>10秒</strong>未能加载完成的网页，用户将难以接受，可能导致大量用户流失。</li></ul> 
<h5 id="3.2%20%E5%BD%B1%E5%93%8D%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E7%9A%84%E5%9B%A0%E7%B4%A0">3.2 影响用户体验的因素</h5> 
<p>客户端因素</p> 
<ul><li><strong>硬件配置</strong>：客户端设备的处理能力影响页面渲染速度。</li><li><strong>网络速率</strong>：用户的网络连接速度直接关系到数据加载时间。</li><li><strong>地理距离</strong>：客户端与服务端的物理距离影响数据传输延迟。</li></ul> 
<p>服务器因素</p> 
<ul><li><strong>网络速率</strong>：服务端的网络带宽和稳定性对响应速度至关重要。</li><li><strong>硬件配置</strong>：服务器的CPU、内存和存储性能直接影响处理能力。</li><li><strong>架构设计</strong>：服务端的软件架构和代码优化对性能有显著影响。</li><li><strong>应用程序工作模式</strong>：如Apache和Nginx的不同工作模式对并发处理能力有差别。</li><li><strong>并发数量</strong>：服务端能够同时处理的请求数量。</li><li><strong>I/O性能</strong>：磁盘和网络I/O性能影响数据处理和传输效率。</li></ul> 
<h4 id="4.%20%E6%9C%8D%E5%8A%A1%E7%AB%AFI%2FO%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%80%A7%E8%83%BD"><strong>4. 服务端I/O流程与性能</strong></h4> 
<p>服务端的I/O（输入/输出）性能是决定Web服务器响应速度的关键因素之一。了解服务端I/O流程对于优化Web服务器性能至关重要。</p> 
<h5 id="4.1%20I%2FO%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">4.1 I/O基本概念</h5> 
<p>I/O是计算机中处理数据输入和输出的过程。在Web服务器中，I/O通常涉及磁盘I/O和网络I/O，它们共同决定了数据处理和传输的效率。</p> 
<h5 id="4.2%20%E7%A3%81%E7%9B%98I%2FO">4.2 磁盘I/O</h5> 
<p>磁盘I/O涉及从磁盘读取或写入数据的过程。它包括以下几个关键步骤：</p> 
<ul><li><strong>寻道时间</strong>：磁头移动到正确的磁道上所需的时间。</li><li><strong>旋转延迟</strong>：磁盘旋转到数据所在扇区所需的时间。</li><li><strong>数据传输时间</strong>：从磁盘读取数据到内存或相反过程所需的时间。</li></ul> 
<p>4.2.1 磁盘性能指标</p> 
<ul><li><strong>IOPS</strong>（每秒输入/输出操作数）：衡量磁盘性能的主要指标，表示单位时间内系统能处理的I/O请求数量。</li></ul> 
<p>4.2.2 磁盘I/O计算方法</p> 
<p>对于不同转速的磁盘，可以通过以下公式计算其最大IOPS：</p> 
<ul><li>7200转磁盘：IOPS=1000寻道时间+平均旋转延迟时间IOPS=寻道时间+平均旋转延迟时间1000​</li><li>10000转磁盘：调整上述公式中的转速参数即可。</li></ul> 
<h5 id="4.3%20%E7%BD%91%E7%BB%9CI%2FO" style="background-color:transparent;">4.3 网络I/O</h5> 
<p>网络I/O涉及通过网络传输数据的过程。它包括以下步骤：</p> 
<ol><li><strong>获取请求数据</strong>：客户端与服务器建立连接并发出请求。</li><li><strong>构建响应</strong>：服务器接收请求，并在用户空间处理客户端的请求。</li><li><strong>返回数据</strong>：服务器将构建好的响应通过内核空间的网络I/O发送回客户端。</li></ol> 
<p>4.3.1 网络I/O性能影响因素</p> 
<ul><li><strong>带宽</strong>：网络连接的最大数据传输速率。</li><li><strong>延迟</strong>：数据从客户端发送到服务器，再从服务器返回客户端所需的时间。</li><li><strong>丢包率</strong>：网络中数据包丢失的比例，影响数据传输的可靠性。</li></ul> 
<h4 id="5.%20I%2FO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3">5. I/O模型详解</h4> 
<p>在现代Web服务器和应用程序的设计中，I/O模型对于性能和可伸缩性起着至关重要的作用。理解不同的I/O模型可以帮助我们更好地编写高效、可扩展的代码。</p> 
<h5 id="5.1%20I%2FO%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">5.1 I/O模型相关概念</h5> 
<p>5.1.1 同步与异步</p> 
<ul><li><strong>同步(Synchronous)</strong>：调用者在等待操作完成期间，不会接收到任何完成状态的通知，需要主动查询操作是否完成。</li><li><strong>异步(Asynchronous)</strong>：被调用者在操作完成时，通过状态、通知或回调机制主动通知调用者。</li></ul> 
<p>5.1.2 阻塞与非阻塞</p> 
<ul><li><strong>阻塞(Blocking)</strong>：在I/O操作完成之前，调用者无法执行其他任务。</li><li><strong>非阻塞(Non-blocking)</strong>：调用者在发起I/O请求后可以立即返回，无需等待操作完成。</li></ul> 
<h5 id="5.2%20%E7%BD%91%E7%BB%9CI%2FO%E6%A8%A1%E5%9E%8B" style="background-color:transparent;">5.2 网络I/O模型</h5> 
<p>5.2.1 阻塞型I/O模型</p> 
<ul><li>用户线程发起I/O请求后，必须等待操作完成才能继续执行其他任务。</li><li>优点：实现简单，CPU资源占用低。</li><li>缺点：在高并发场景下效率低，因为每个连接都需要独立的线程或进程。</li></ul> 
<p><img alt="" height="337" src="https://images2.imgbox.com/78/15/qlpyoTF0_o.png" width="734"></p> 
<p>5.2.2 非阻塞型I/O模型</p> 
<ul><li>用户线程发起I/O请求后立即返回，通过轮询机制不断检查I/O操作是否完成。</li><li>优点：可以在单个线程内处理多个I/O请求。</li><li>缺点：频繁的轮询可能导致CPU资源浪费。</li></ul> 
<p><img alt="" height="366" src="https://images2.imgbox.com/98/f6/d8SYBUog_o.png" width="750"></p> 
<p>5.2.3 多路复用I/O模型 </p> 
<ul><li>通过系统调用（如select、poll、epoll）同时监控多个I/O请求。</li><li>优点：可以在单个线程内高效地处理大量并发连接。</li><li>缺点：在连接数较少时，效率可能不如多线程模型。</li></ul> 
<p> <img alt="" height="406" src="https://images2.imgbox.com/63/2a/ybbBMPrg_o.png" width="762"></p> 
<p>5.2.4 信号驱动式I/O模型</p> 
<ul><li>通过信号通知机制，在数据就绪时通知应用程序进行I/O操作。</li><li>优点：减少了无数据时的轮询，提高了效率。</li><li>缺点：在大量I/O操作时，信号队列可能溢出。</li></ul> 
<p> <img alt="" height="384" src="https://images2.imgbox.com/0a/aa/YtlLlOpr_o.png" width="737"></p> 
<p>5.2.5 异步I/O模型</p> 
<ul><li>内核在I/O操作完成时主动通知应用程序。</li><li>优点：应用程序可以在等待I/O时执行其他任务，充分利用了系统资源。</li><li>缺点：实现复杂，需要操作系统的底层支持。</li></ul> 
<p> <img alt="" height="346" src="https://images2.imgbox.com/8a/ed/NGXBY8s3_o.png" width="720"></p> 
<h5 id="5.3%20I%2FO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83">5.3 I/O模型的比较</h5> 
<p>5.3.1 性能对比</p> 
<ul><li>阻塞型I/O模型在低并发场景下简单易用，但在高并发场景下效率较低。</li><li>非阻塞型和多路复用I/O模型在高并发场景下表现更好，但实现复杂度较高。</li><li>异步I/O模型提供了最高的效率和可伸缩性，但需要更多的系统资源和复杂的编程模型。</li></ul> 
<p><img alt="" height="405" src="https://images2.imgbox.com/0f/9e/KObbp88D_o.png" width="711"></p> 
<p>5.3.2 实际应用选择</p> 
<ul><li>对于低并发需求，可以选择阻塞型I/O模型。</li><li>对于需要处理大量并发连接的服务器，多路复用或异步I/O模型更为合适。</li></ul> 
<h4 id="6.%20%E9%9B%B6%E6%8B%B7%E8%B4%9D">6. 零拷贝</h4> 
<h5 id="6.1%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5">6.1零拷贝的概念</h5> 
<p>在传统的Linux系统中，标准I/O操作（如read和write）通常涉及数据在用户空间和内核空间之间的多次拷贝。这种数据拷贝过程不仅消耗CPU资源，而且随着数据量的增加，性能瓶颈也变得更加明显。</p> 
<p>零拷贝是一种减少或消除数据在用户空间和内核空间之间拷贝的技术。它并不是完全没有拷贝，而是尽可能减少不必要的数据复制操作，从而提高效率。</p> 
<h5 id="6.2%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF">6.2零拷贝相关技术</h5> 
<p>6.2.1 MMAP (Memory Mapping)</p> 
<p>内存映射（MMAP）是一种允许进程通过内存地址空间直接访问文件内容的技术。使用mmap系统调用，文件内容被映射到进程的地址空间，避免了read和write调用中的额外数据拷贝。</p> 
<p><img alt="" height="679" src="https://images2.imgbox.com/9f/99/U4SRcjYS_o.png" width="1107"></p> 
<p>6.2.2 SENDFILE</p> 
<p>SENDFILE是一种高效的数据传输系统调用，它允许内核直接将文件数据发送到网络套接字，无需将数据先复制到用户空间的缓冲区。这种方式显著减少了数据拷贝的开销。</p> 
<p> <img alt="" height="685" src="https://images2.imgbox.com/3f/ce/LGEKRuJ4_o.png" width="1117"></p> 
<p>6.2.3 DMA辅助的SENDFILE</p> 
<p>某些系统支持使用直接内存访问（DMA）来辅助SENDFILE操作，进一步提高数据传输的效率。</p> 
<p> <img alt="" height="652" src="https://images2.imgbox.com/f4/5e/AIhfLqUu_o.png" width="1105"></p> 
<h3 id="%E4%BA%8C%E3%80%81%C2%A0Nginx%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%89%E8%A3%85" style="background-color:transparent;">二、 Nginx架构与安装</h3> 
<hr> 
<h4 id="1.Nginx%20%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0">1.Nginx 架构概述</h4> 
<h5 id="1.1%20Nginx%20%E7%AE%80%E4%BB%8B">1.1 Nginx 简介</h5> 
<p>Nginx（发音为“engine X”）最初由俄罗斯程序员Igor Sysoev开发，并于2004年首次公开发布。它以高稳定性、丰富的功能集和低资源消耗而闻名。</p> 
<h5 id="1.2%20%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7">1.2 核心特性</h5> 
<ul><li><strong>模块化设计</strong>：易于扩展和定制。</li><li><strong>高可靠性</strong>：支持平滑重载配置文件和升级程序，无需中断服务。</li><li><strong>低内存消耗</strong>：优化的内存管理机制。</li><li><strong>事件驱动</strong>：高效的事件处理机制，支持大量并发连接。</li></ul> 
<h5 id="1.3%20%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B">1.3 进程模型</h5> 
<p>Nginx采用多进程模型，主要由Master进程和Worker进程组成：</p> 
<ul><li><strong>Master进程</strong>：负责管理Worker进程，读取和验证配置文件，处理信号等。</li><li><strong>Worker进程</strong>：实际处理网络请求，执行具体业务逻辑。</li></ul> 
<h4 id="2.Nginx%20%E5%AE%89%E8%A3%85%C2%A0">2.Nginx 安装 </h4> 
<h5 id="2.1%20%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87">2.1 安装前的准备</h5> 
<pre><code>#下载并解压所需的安装包
[root@nginx ~]# ls
公共  下载             echo-nginx-module-0.63         nginx-1.26.1
模板  音乐             echo-nginx-module-0.63.tar.gz  nginx-1.26.1.tar.gz
视频  桌面             eth160.nmconnection            test.sh
图片  anaconda-ks.cfg  nginx-1.24.0
文档  clear_mnt        nginx-1.24.0.tar.gz

#解决依赖
[root@nginx ~]#dnf install gcc pcre-devel zlib-devel openssl-devel -y
[root@nginx ~]# cd nginx-1.24.0/

</code></pre> 
<h5 id="2.2%20%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Nginx">2.2 编译安装Nginx</h5> 
<pre><code class="language-bash">#对nginx编译
[root@nginx nginx-1.24.0]# ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --add-module=/root/echo-nginx-module-0.63 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module

#找到makefile文件进行安装
[root@nginx nginx-1.24.0]# ls
auto     CHANGES.ru  configure  html     Makefile  objs    src
CHANGES  conf        contrib    LICENSE  man       README
[root@nginx nginx-1.24.0]# make &amp;&amp; make install</code></pre> 
<h5 id="%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E7%BC%96%E8%BE%914%E3%80%81nginx%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99">2.3.nginx启动文件编写</h5> 
<pre><code class="language-bash">[root@nginx nginx-1.24.0]# vim /lib/systemd/system/nginx.service


[Unit]
Description=The NGINX HTTP and reverse proxy server
After=syslog.target network-online.target remote-fs.target nss.lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=/usr/local/nginx/logs/nginx.pid
ExecStartPre=/usr/local/nginx/sbin/nginx -t
ExecStart=/usr/local/nginx/sbin/nginx
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true 

[Install]
WantedBy=multi-user.target
</code></pre> 
<h4 id="3%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E5%92%8C%E5%9B%9E%E6%BB%9A">3平滑升级和回滚</h4> 
<p>有时候我们需要对Nginx版本进行升级以满足对其功能的需求，例如添加新模块，需要新功能，而此时 Nginx又在跑着业务无法停掉，这时我们就可能选择平滑升级</p> 
<h5 id="3.1%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B">3.1平滑升级流程</h5> 
<p><img alt="" height="357" src="https://images2.imgbox.com/1a/42/RYNhYVu1_o.png" width="1200"></p> 
<p><img alt="" height="462" src="https://images2.imgbox.com/06/c2/wM9ejPRf_o.png" width="1040"></p> 
<ul><li>将旧Nginx二进制文件换成新Nginx程序文件（注意先备份)</li><li>向master进程发送USR2信号</li><li>master进程修改pid文件名加上后缀.oldbin,成为nginx.pid.oldbin</li><li>master进程用新Nginx文件启动新master进程成为旧master的子进程,系统中将有新旧两个Nginx主进程共同提供Web服务,当前新的请求仍然由旧Nginx的worker进程进行处理,将新生成的master进程的PID存放至新生成的pid文件nginx.pid</li><li>向旧的Nginx服务进程发送WINCH信号，使旧的Nginx worker进程平滑停止</li><li>向旧master进程发送QUIT信号，关闭老master，并删除Nginx.pid.oldbin文件</li><li>如果发现升级有问题,可以回滚∶向老master发送HUP，向新master发送QUIT</li></ul> 
<h5 id="3.2.%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7" style="background-color:transparent;">3.2.平滑升级</h5> 
<p id="4.2.1%20%E8%A7%A3%E5%8E%8B%E6%96%B0%E7%89%88%E6%9C%ACNGINX%E7%BC%96%E8%AF%91" style="background-color:transparent;">3.2.1 解压新版本NGINX编译</p> 
<pre><code class="language-bash">[root@nginx ~]# tar -xzf nginx-1.26.1.tar.gz
[root@nginx ~]# cd nginx-1.26.1/
[root@nginx nginx-1.26.1]# ls
auto     CHANGES.ru  configure  html     Makefile  objs    src
CHANGES  conf        contrib    LICENSE  man       README
[root@nginx nginx-1.26.1]# ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --add-module=/root/echo-nginx-module-0.63 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module
[root@nginx nginx-1.26.1]# make
</code></pre> 
<p id="4.2.2%20%E6%8B%B7%E8%B4%9D%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84%E6%96%B0%E8%84%9A%E6%9C%AC">3.2.2 拷贝编译好的新脚本</p> 
<pre><code class="language-bash">[root@nginx nginx-1.26.1]# cp objs/nginx /usr/local/nginx/sbin/nginx.new
[root@nginx nginx-1.26.1]# nginx
[root@nginx nginx-1.26.1]# mv nginx nginx.old
[root@nginx nginx-1.26.1]# mv nginx nginx.new</code></pre> 
<p id="4.2.3%20kill%20-s%20USR2%E5%AE%9E%E7%8E%B0%20%E6%8C%82%E8%B5%B7%E6%97%A7%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%90%AF%E6%96%B0%E8%BF%9B%E7%A8%8B" style="background-color:transparent;">3.2.3.挂起旧进程开启新进程</p> 
<pre><code class="language-bash">[root@nginx nginx-1.26.1]# ps aux | grep nginx
avahi        889  0.0  0.1  15524  6300 ?        Ss   16:23   0:00 avahi-daemon: running [nginx.local]
root        2113  0.0  0.0   9868   988 ?        Ss   17:22   0:00 nginx: master process nginx
nobody      2114  0.0  1.2  54740 45804 ?        S    17:22   0:00 nginx: worker process
nobody      2115  0.3  1.2  54740 45804 ?        S    17:22   0:00 nginx: worker process
root        2117  0.0  0.0 221812  2316 pts/1    S+   17:22   0:00 grep --color=auto nginx

[root@nginx nginx-1.26.1]# kill -USR2 2113
[root@nginx nginx-1.26.1]# kill -WINCH 2113
[root@nginx nginx-1.26.1]# curl -I 172.25.254.100
HTTP/1.1 200 OK
Server: nginx/1.26.1
Date: Tue, 20 Aug 2024 09:33:43 GMT
Content-Type: text/html
Content-Length: 18
Last-Modified: Thu, 15 Aug 2024 14:59:01 GMT
Connection: keep-alive
Keep-Alive: timeout=60
ETag: "66be17b5-12"
Accept-Ranges: bytes
</code></pre> 
<p>3.2.4.回滚</p> 
<pre><code class="language-bash">[root@nginx nginx-1.26.1]# ps aux | grep nginx
avahi        889  0.0  0.1  15524  6300 ?        Ss   16:23   0:00 avahi-daemon: running [nginx.local]
root        2113  0.0  0.0   9868   988 ?        Ss   17:22   0:00 nginx: master process nginx
nobody      2114  0.0  1.2  54740 45804 ?        S    17:22   0:00 nginx: worker process
nobody      2115  0.3  1.2  54740 45804 ?        S    17:22   0:00 nginx: worker process
root        2117  0.0  0.0 221812  2316 pts/1    S+   17:22   0:00 grep --color=auto nginx
[root@nginx nginx-1.26.1]# kill -HUP 2113
[root@nginx nginx-1.26.1]# kill -WINCH 2117
[root@nginx nginx-1.26.1]# curl -I 172.25.254.100
HTTP/1.1 200 OK
Server: nginx/1.24.0
Date: Tue, 20 Aug 2024 09:35:43 GMT
Content-Type: text/html
Content-Length: 18
Last-Modified: Thu, 15 Aug 2024 14:59:01 GMT
Connection: keep-alive
Keep-Alive: timeout=60
ETag: "66be17b5-12"
Accept-Ranges: bytes
</code></pre> 
<h3 id="%E4%B8%89%E3%80%81Nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96" style="background-color:transparent;">三、Nginx核心配置与优化</h3> 
<hr> 
<h4 id="1.%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" style="background-color:transparent;">1. 配置文件结构</h4> 
<p>Nginx的配置文件通常分为以下几个部分：</p> 
<ul><li><strong>全局块</strong>：设置影响整个Nginx服务器的配置，如用户、工作进程数等。</li><li><strong>events块</strong>：配置事件相关的设置，如使用哪种事件模型。</li><li><strong>http块</strong>：定义与HTTP协议相关的配置，如日志格式、MIME类型、静态资源缓存等。</li><li><strong>server块</strong>：定义虚拟主机的配置，可以包含多个location定义。</li></ul> 
<h4 id="2.%20%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">2. 全局配置</h4> 
<p>Main 全局配置段常见的配置指令分类</p> 
<ul><li>正常运行必备的配置</li><li>优化性能相关的配置</li><li>用于调试及定位问题相关的配置</li><li>事件驱动相关的配置</li></ul> 
<pre><code class="language-bash">#用户和组配置
user nginx;        #user：定义Nginx进程运行的用户，出于安全考虑，建议使用非root用户
worker_processes auto;        #worker_processes：定义工作进程的数量。设置为auto可以让Nginx根据CPU核心数自动设置。


#事件驱动模型
events {
    use epoll;  # Linux下推荐使用epoll
    worker_connections 100000;  # 每个工作进程的最大连接数
}
#use：指定使用的事件驱动方法，epoll是Linux下高性能的选择。
#worker_connections：定义单个工作进程可以处理的最大连接数。


#错误日志和PID文件
error_log /var/log/nginx/error.log warn;        #error_log：定义错误日志文件的路径和日志级别，warn表示只记录警告及以上级别的日志。
pid /var/run/nginx.pid;        #pid：定义Nginx主进程的PID文件存放位置。</code></pre> 
<p>实现 nginx 的高并发配置</p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/be/6f/9qURoofP_o.png" width="710"></p> 
<pre><code class="language-bash">[root@nginx ~]# vim /etc/security/limits.conf

# End of file
nginx           -        nofile          100000

</code></pre> 
<p><img alt="" height="501" src="https://images2.imgbox.com/eb/48/5KJbUFIe_o.png" width="680"></p> 
<p>开放最大并发数为100000</p> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf/nginx.conf

events {
    use epoll;  
    worker_connections 100000;  
}

[root@nginx ~]# nginx -s reload</code></pre> 
<p>http 配置块</p> 
<blockquote> 
 <p><br> #在响应报文中将指定的文件扩展名映射至MIME对应的类型<br> include /etc/nginx/mime.types;<br> default_type application/octet-stream; #除mime.types中的类型外<br> #指定其它文件的默认MIME类型，浏览<br> 器一般会提示下载<br> types {<!-- --><br>         text/html html;<br>         image/gif gif;<br>         image/jpeg jpg;</p> 
 <p>}</p> 
</blockquote> 
<h4 id="3%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B" style="background-color:transparent;"><strong>3.核心配置</strong></h4> 
<p>基于不同的IP、不同的端口以及不用得域名实现不同的虚拟主机，依赖于核心模块 ngx_http_core_module实现。</p> 
<h5 id="3.1.%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%20PC%20web%20%E7%AB%99%E7%82%B9" style="background-color:transparent;">3.1.新建一个 PC web 站点</h5> 
<pre><code class="language-bash">#定义子配置文件路径
[root@nginx ~]# vim /usr/local/nginx/conf/nginx.conf

http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65 60;
    keepalive_requests 500;

    #gzip  on;
    include "/usr/local/nginx/conf.d/*.conf";        #在配置文件的最后面添加此行,否则会导致前面的命令无法生效

#创建虚拟主机网站配置
[root@nginx ~]# mkdir -p /usr/local/nginx/conf.d
[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf
server {
     listen 80;

     server_name www.timinglee.org;

     root /data/web/html;

      index index.html;

}</code></pre> 
<p>测试</p> 
<p><img alt="" height="51" src="https://images2.imgbox.com/13/cf/61N1pAOi_o.png" width="584"></p> 
<h5 id="root%E5%92%8Calias" style="background-color:transparent;">3.2.root和<strong>alias</strong></h5> 
<p>root：指定web的家目录，在定义location的时候，文件的绝对路径等于 root+location</p> 
<p>alias：定义路径别名，会把访问的路径重新定义到其指定的路径,文档映射的另一种机制;仅能用于 location上下文,此指令使用较少</p> 
<blockquote> 
 <p>root  #给定的路径对应于location中的/uri左侧的/</p> 
 <p>alias  #给定的路径对应于location中的/uri的完整路径</p> 
</blockquote> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf

server {
        listen 80;
        server_name www.timinglee.org;
        root /data/web/html;
        index index.html;

        location /web {
                alias /data/web/html;
        }
}

[root@nginx ~]# nginx -s reload
[root@nginx ~]# echo this is alias &gt; /data/web/html/index.html 

#测试
[root@nginx ~]# curl 172.25.254.100/web/
this is alias

</code></pre> 
<h5 id="3.3.location%20%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8" style="background-color:transparent;">3.3.location 的详细使用</h5> 
<ul><li>在一个server中location配置段可存在多个，用于实现从uri到文件系统的路径映射；</li><li>ngnix会根据用户请求的URI来检查定义的所有location，按一定的优先级找出一个最佳匹配，</li><li>而后应用其配置在没有使用正则表达式的时候，nginx会先在server中的多个location选取匹配度最高的一个uri</li><li>uri是用户请求的字符串，即域名后面的web文件路径</li><li>然后使用该location模块中的正则url和字符串，如果匹配成功就结束搜索，并使用此location处理此请求。</li></ul> 
<p>Location 基本语法</p> 
<ul><li><code>=</code>：精确匹配，要求请求的URI和模式完全一致。</li><li><code>~</code>：区分大小写的正则表达式匹配。</li><li><code>~*</code>：不区分大小写的正则表达式匹配。</li><li><code>^~</code>：如果请求的URI以该模式开始，优先使用此规则，并且匹配是区分大小写的。</li></ul> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf

server {
        listen 80;
        server_name www.timinglee.org;
        root /data/web/html;
        index index.html;

        location /test {
                root /data/web1;
        }

        location = /test {
                root /data/web2;
        }

        location ^~ /t {
                root /data/web3;
        }

        location ~\.html$ {
                root /data/web4;
        }

        location ~* .HTML$ {
                root /data/web5;
        }
}

[root@nginx ~]# nginx -s reload
[root@nginx ~]# echo web1 &gt; /data/web1/test/index.html
[root@nginx ~]# echo web2 &gt; /data/web2/test/index.html
[root@nginx ~]# echo web3 &gt; /data/web3/test/index.html
[root@nginx ~]# echo web4 &gt; /data/web4/test/index.html
[root@nginx ~]# echo web5 &gt; /data/web5/test/index.html
</code></pre> 
<p>测试访问目录时其优先值：</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/ae/7d/KogBwyQy_o.png" width="561"></p> 
<p>将4和5的位置调换</p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/a7/0b/IxvEUlU0_o.png" width="480"></p> 
<p><img alt="" height="110" src="https://images2.imgbox.com/aa/c1/7YKRxaCC_o.png" width="571"></p> 
<p>由此可知4和5的优先级相同,谁在前面先访问谁。所以先注释掉4，5</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/53/7e/LujpvSr6_o.png" width="549"></p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/0d/93/Isfzx7fG_o.png" width="431"></p> 
<p>变成了1，所以在1，2，3中1的优先级最高。注释掉1</p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/b1/08/styZmEDa_o.png" width="425"></p> 
<p><img alt="" height="91" src="https://images2.imgbox.com/fd/82/MuVNuUUs_o.png" width="496"></p> 
<p>此时又变成了3</p> 
<p>最终我们可知：<strong>精确匹配  &gt;  (~,~*)  &gt;  不带符号  &gt;  ^~</strong></p> 
<h5 id="3.4Nginx%20%E8%B4%A6%E6%88%B7%E8%AE%A4%E8%AF%81%E5%8A%9F%E8%83%BD" style="background-color:transparent;">3.4Nginx 账户认证功能</h5> 
<p>先创建用户认证文件</p> 
<pre><code class="language-bash">[root@nginx ~]# htpasswd -cm /usr/local/nginx/.htpasswd admin 
New password: 
Re-type new password: 
Adding password for user admin
[root@nginx ~]# cat /usr/local/nginx/.htpasswd 
admin:$apr1$2kxH6wDv$TLLJg4BDm/yBpHrhh7R7G.
[root@nginx ~]#  htpasswd -m /usr/local/nginx/.htpasswd lee
New password: 
Re-type new password: 
Adding password for user lee
[root@nginx ~]# cat /usr/local/nginx/.htpasswd 
admin:$apr1$2kxH6wDv$TLLJg4BDm/yBpHrhh7R7G.
lee:$apr1$L7hH2RAv$pppr0yfcb9oVSzdONCBar0</code></pre> 
<p>然后编辑子配置文件添加用户认证的参数</p> 
<pre><code class="language-bash">server {
        listen 80;
        server_name www.timinglee.org;
        root /data/web/html;
        index index.html;

        location  /lee {
                root /data/web;
                auth_basic "login password !!";
                auth_basic_user_file "/usr/local/nginx/.htpasswd";
        }

}
</code></pre> 
<p>测试</p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/8e/c3/UoLWapdU_o.png" width="676"></p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/af/a4/ig8FVGdH_o.png" width="581"></p> 
<h5 id="3.5%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2" style="background-color:transparent;">3.5自定义错误页面</h5> 
<p>创建文件</p> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf 

server {
        listen 80;
        server_name www.timinglee.org;
        root /data/web/html;
        index index.html;
        error_page 404 /40x.html;
      
        location  /lee {
                root /data/web;
                auth_basic "login password !!";
                auth_basic_user_file "/usr/local/nginx/.htpasswd";
        }

        location = /40x.html {
                root /data/web/errorpage;
        }
}

[root@nginx ~]# mkdir -p /data/web/errorpage
[root@nginx ~]# echo error page &gt; /data/web/errorpage/40x.html
</code></pre> 
<p>测试</p> 
<p>访问不存在的页面</p> 
<p><img alt="" height="122" src="https://images2.imgbox.com/b7/1f/xKptqaJM_o.png" width="557"></p> 
<h5 id="3.4.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97" style="background-color:transparent;">3.4.自定义错误日志</h5> 
<p>编辑子配置文件添加自定义错误日志的参数和访问成功日志的参数，定义错误和访问日志路径</p> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf 

server {
        listen 80;
        server_name www.timinglee.org;
        root /data/web/html;
        index index.html;
        error_page 404 /40x.html;
        error_log /var/log/timinglee.org/error.log;
}

[root@nginx ~]# nginx -s reload
[root@nginx ~]#  mkdir -p /var/log/timinglee.org</code></pre> 
<p>测试</p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/bd/8a/XllVvDCr_o.png" width="926"></p> 
<h5 id="3.5.%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8">3.5.检测文件是否存在</h5> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf

server {
        listen 80;
        server_name www.timinglee.org;
        root /data/web/html;
        index index.html;
        error_page 404 /40x.html;
        error_log /var/log/timinglee.org/error.log;
        access_log /var/log/timinglee.org/access.log;
        try_files $uri $uri.html $uri/index.html /error/default.html;
}

[root@nginx ~]# nginx -s reload
[root@nginx ~]# echo error default &gt; /data/web/html/error/default.html </code></pre> 
<p>测试： </p> 
<p>该文件不存在</p> 
<p><img alt="" height="55" src="https://images2.imgbox.com/e5/f7/MoFKzRKF_o.png" width="680"></p> 
<h5 id="3.6.%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%C2%A0">3.6.长连接配置 </h5> 
<pre><code class="language-bash">http {
    .........

    #keepalive_timeout  0;
    keepalive_timeout  65;        #这个链接在未请求的时候保持65s后断开
    keepalive_requests 2;        #该链接允许请求访问两次

    .........
}

[root@nginx ~]# yum install telnet -y
[root@nginx ~]# telnet  www.timinglee.org 80
Trying 172.25.254.100...
Connected to www.timinglee.org.
Escape character is '^]'.
GET / HTTP/1.1
Host: www.timinglee.org
</code></pre> 
<p>测试</p> 
<p>回车两次，一次构建报文建立连接，二次发送</p> 
<p> 只允许访问两次<img alt="" height="332" src="https://images2.imgbox.com/e7/71/8Bf1sVYW_o.png" width="642"></p> 
<h5 id="3.7.%E4%BD%9C%E4%B8%BA%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%C2%A0" style="background-color:transparent;">3.7.作为下载服务器配置 </h5> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf 

server {
        listen 80;
        server_name www.timinglee.org;
        root /data/web/html;
        index index.html;

        location /download {
                root /dta/web;
                autoindex on;        #自动索引功能
                autoindex_localtime on;        #on表示显示本机时间而非GMT(格林威治)时间        #默认为off显 示GMT时间
                autoindex_exact_size off;       #计算文件确切大小（单位bytes）        #此为默认值,off只显示 大概大小（单位kb、mb、gb）
                limit_rate 1024k;          #限速,默认不限速（为0）
        }
}

[root@nginx ~]# nginx -s reload
[root@nginx ~]# mkdir /data/web/download/</code></pre> 
<p>测试</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/e0/5d/owL8rJx8_o.png" width="676"></p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/a3/1e/yHaeUGp6_o.png" width="910"></p> 
<h3 id="%E5%9B%9B%E3%80%81Nginx%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE" style="background-color:transparent;">四、Nginx 高级配置</h3> 
<hr> 
<h4 id="1.Nginx%20%E7%8A%B6%E6%80%81%E9%A1%B5" style="background-color:transparent;">1.Nginx 状态页</h4> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/status.conf

server {
        listen 80;
        server_name status.timinglee.org;
        root /data/web/html;
        index index.html;

        location /status {
                stub_status;
                allow 172.25.254.1;
                deny all;
        }
}

[root@nginx ~]# nginx -s reload
</code></pre> 
<p>测试</p> 
<p><img alt="" height="177" src="https://images2.imgbox.com/96/fe/35tGx0CA_o.png" width="629"></p> 
<h4 id="2.Nginx%20%E5%8E%8B%E7%BC%A9%E5%8A%9F%E8%83%BD%C2%A0" style="background-color:transparent;">2.Nginx 压缩功能 </h4> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf/nginx.conf

http {
    ..............

     gzip  on;        #启用或禁用gzip压缩，默认关闭
    gzip_comp_level 5;        #压缩比由低到高从1到9，默认为1，值越高压缩后文件越小，但是消耗cpu比较高。
    gzip_min_length 1k;          #gzip压缩的最小文件，小于设置值的文件将不会压缩
    gzip_http_version 1.1;          #启用压缩功能时，协议的最小版本，默认HTTP/1.1
    gzip_vary on;        #如果启用压缩，是否在响应报文首部插入“Vary: Accept-Encoding”,一般建议打开
    gzip_types text/plain application/javascript application/x-javascript text/cssapplication/xml text/javascript application/x-httpd-php image/gif image/png;        #指明仅对哪些类型的资源执行压缩操作;默认为gzip_types text/html，不用显示指定，否则出错

    ..............
}

[root@nginx ~]# nginx -s reload
[root@nginx ~]# echo hello timinglee &gt; /data/web/html/small.html 
[root@nginx ~]# du -sh /usr/local/nginx/logs/access.log 
12K	/usr/local/nginx/logs/access.log
[root@nginx ~]# cat /usr/local/nginx/logs/access.log &gt; /data/web/html/big.html

</code></pre> 
<p>测试</p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/7e/70/HKb4y76g_o.png" width="810"></p> 
<h4 id="3.Nginx%20%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%C2%A0" style="background-color:transparent;">3.Nginx 变量使用 </h4> 
<ul><li>nginx的变量可以在配置文件中引用，作为功能判断或者日志等场景使用</li><li>变量可以分为内置变量和自定义变量</li><li>内置变量是由nginx模块自带，通过变量可以获取到众多的与客户端访问相关的值。</li></ul> 
<h5 id="3.1%E3%80%81%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F">3.1、内置变量</h5> 
<pre><code class="language-bash">server {
    listen 80;
    server_name var.timinglee.org;
    root /data/web/html;
    index index.html;

    location /var {
        default_type text/html;   
        echo $remote_addr;        #存放了客户端的地址，注意是客户端的公网IP
        echo $args;          #变量中存放了URL中的所有参数    
        echo $is_args;        #如果有参数为? 否则为空
        echo $document_root;        #保存了针对当前资源的请求的系统根目录
        echo $document_uri;        #保存了当前请求中不包含参数的URI，注意是不包含请求的指令
        echo $host;          #存放了请求的host名称
        echo $remote_port;        #客户端请求Nginx服务器时随机打开的端口，这是每个客户端自己的端口
        echo $remote_user;        #客户端请求Nginx服务器时随机打开的端口，这是每个客户端自己的端口
        echo $request_method;        请求资源的方式，GET/PUT/DELETE等
        echo $request_filename;         #当前请求的资源文件的磁盘路径，由root或alias指令与URI请求生成的文件绝对路径
        echo $request_uri;          #包含请求参数的原始URI，不包含主机名
        echo $scheme;        #请求的协议
        echo $server_protocol;         #保存了客户端请求资源使用的协议的版本
        echo $server_addr;         #保存了服务器的IP地址
        echo $server_name;          #虚拟主机的主机名
        echo $server_port;        #虚拟主机的端口号
        echo $http_user_agent;         #客户端浏览器的详细信息
        echo $http_cookie;        #客户端的所有cookie信息
        echo $cookie_key2;        #name为任意请求报文首部字部cookie的key名
        set $timinglee lee;        #自定义参数
        echo $timinglee;        #打印自定义参数

    }
}
</code></pre> 
<p>测试</p> 
<p><img alt="" height="552" src="https://images2.imgbox.com/38/ec/BOjVTtoq_o.png" width="936"></p> 
<h3 id="%E4%BA%94%E3%80%81Nginx%20Rewrite%20%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD" style="background-color:transparent;">五、Nginx Rewrite 相关功能</h3> 
<hr> 
<ul><li> Nginx服务器利用 ngx_http_rewrite_module 模块解析和处理rewrite请求</li><li>此功能依靠 PCRE(perl compatible regular expression)，因此编译之前要安装PCRE库</li><li>rewrite是nginx服务器的重要功能之一，用于实现URL的重写，URL的重写是非常有用的功能</li><li>比如它可以在我们改变网站结构之后，不需要客户端修改原来的书签，也无需其他网站修改我们的链接，就可以设置为访问</li><li>另外还可以在一定程度上提高网站的安全性。</li></ul> 
<h4 id="1.ngx_http_rewrite_module%20%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4%C2%A0" style="background-color:transparent;">1.ngx_http_rewrite_module 模块指令 </h4> 
<h5 id="1.1.if%E6%8C%87%E4%BB%A4" style="background-color:transparent;">1.1.if指令</h5> 
<ul><li>Nginx的if语法仅能使用if做单次判断</li><li>可以使用正则表达式对变量进行匹配，匹配成功时if指令认为条件为true，否则认为false</li></ul> 
<pre><code class="language-bash">server {
    listen 80;
    server_name var.timinglee.org;
    root /data/web/html;
    index index.html;

        location /test2 {
                if ( !-e $request_filename){
                echo "$request_filename is exist";
        }
}

[root@nginx ~]# nginx -s reload</code></pre> 
<p>测试</p> 
<p><img alt="" height="150" src="https://images2.imgbox.com/ca/1b/UUH6dYjW_o.png" width="722"></p> 
<h5 id="1.2.set%20%E6%8C%87%E4%BB%A4">1.2.set 指令</h5> 
<ul><li>指定key并给其定义一个变量，变量可以调用Nginx内置变量赋值给key</li><li>另外set定义格式为set $key value，value可以是text, variables和两者的组合</li></ul> 
<h5 id="%C2%A01.3.break%E6%8C%87%E4%BB%A4"> 1.3.break指令</h5> 
<ul><li>用于中断当前相同作用域(location)中的其他Nginx配置</li><li>与该指令处于同一作用域的Nginx配置中，位于它前面的配置生效</li><li>位于后面的 ngx_http_rewrite_module 模块中指令就不再执行</li><li>Nginx服务器在根据配置处理请求的过程中遇到该指令的时候，回到上一层作用域继续向下读取配置</li><li>该指令可以在server块和locationif块中使用</li></ul> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vars.conf

        location /break {
                default_type text/html;
                set $name zpy;
                echo $name;
                if ( $http_user_agent = "curl/7.76.1" ){
                break;
                }
                set $id 666;
                echo $id;
        }


[root@nginx ~]# nginx -s reload
</code></pre> 
<p>测试</p> 
<p><img alt="" height="177" src="https://images2.imgbox.com/19/69/RTpv5ZyC_o.png" width="772"></p> 
<h5 id="1.4.return%20%E6%8C%87%E4%BB%A4" style="background-color:transparent;">1.4.return 指令</h5> 
<p>return用于完成对请求的处理，并直接向客户端返回响应状态码，比如:可以指定重定向URL(对于特殊重 定向状态码，301/302等) 或者是指定提示文本内容(对于特殊状态码403/500等)，处于此指令后的所有配 置都将不被执行，return可以在server、if 和 location块进行配置</p> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vars.conf
  
      location /return {
                default_type text/html;
                if ( !-e $request_filename){
                return 301 http://www.baidu.com;
                }
                echo "$request_filename is exist";
        }

[root@nginx ~]# nginx -s reload
</code></pre> 
<p>测试</p> 
<p><img alt="" height="430" src="https://images2.imgbox.com/ab/d1/VRLdmHPT_o.png" width="682"></p> 
<h4 id="2.rewrite%20%E6%8C%87%E4%BB%A4" style="background-color:transparent;">2.rewrite 指令</h4> 
<p>通过正则表达式的匹配来改变URI，可以同时存在一个或多个指令，按照顺序依次对URI进行匹配， rewrite主要是针对用户请求的URL或者是URI做具体处理</p> 
<h5 id="2.1.%20rewrite%20flag%20%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">2.1. rewrite flag 使用介绍</h5> 
<p>利用nginx的rewrite的指令，可以实现url的重新跳转，rewrite有四种不同的flag，分别是redirect(临时 重定向302)、permanent(永久重定向301)、break和last。其中前两种是跳转型的flag，后两种是代理型</p> 
<ul><li>跳转型指由客户端浏览器重新对新地址进行请求</li><li>代理型是在WEB服务器内部实现跳转</li></ul> 
<h5 id="2.2.%E5%9F%9F%E5%90%8D%E6%B0%B8%E4%B9%85%EF%BC%88permanent%EF%BC%89%E4%B8%8E%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%88redirect%EF%BC%89" style="background-color:transparent;">2.2.域名永久（permanent）与临时重定向（redirect）</h5> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vars.conf
 
       location / {
                root /data/web/var;
                index index.html;
                rewrite / http://www.timinglee.com permanent;
                #rewrite / http://www.timinglee.com redirect;
        }

[root@nginx ~]# nginx -s reload
</code></pre> 
<p>测试</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/25/bc/zV11kAa8_o.png" width="614"></p> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vars.conf
 
       location / {
                root /data/web/var;
                index index.html;
                #rewrite / http://www.timinglee.com permanent;
                rewrite / http://www.timinglee.com redirect;
        }

[root@nginx ~]# nginx -s reload
</code></pre> 
<p>测试</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/d8/ce/QY1yJgG4_o.png" width="529"></p> 
<h3 id="%E5%85%AD%E3%80%81Nginx%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD" style="background-color:transparent;">六、Nginx 反向代理功能</h3> 
<hr> 
<h4 id="1.%E5%AE%9E%E7%8E%B0%20http%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" style="background-color:transparent;">1.实现 http 反向代理</h4> 
<p>反向代理：reverse proxy，指的是代理外网用户的请求到内部的指定的服务器，并将数据返回给用户的 一种方式，这是用的比较多的一种方式。</p> 
<p>Nginx 除了可以在企业提供高性能的web服务之外，另外还可以将 nginx 本身不具备的请求通过某种预 定义的协议转发至其它服务器处理，不同的协议就是Nginx服务器与其他服务器进行通信的一种规范</p> 
<h5 id="1.1.http%20%E5%8D%8F%E8%AE%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%C2%A0" style="background-color:transparent;">1.1.http 协议反向代理 </h5> 
<p>将用户对域 www.timinglee.org 的请求转发给后端服务器处理 </p> 
<p>新建两台主机172.25.254.10和20，做后端服务器</p> 
<pre><code class="language-bash">[root@web1 ~]# yum install httpd -y
[root@web1 ~]# echo test 172.25.254.10 &gt; /var/www/html/index.html


[root@web2 ~]# yum install httpd -y
[root@web2 ~]# vim /etc/httpd/conf/httpd.conf 

# Change this to Listen on a specific IP address, but note that if
# httpd.service is enabled to run at boot time, the address may not be
# available when the service starts.  See the httpd.service(8) man
# page for more information.
#
#Listen 12.34.56.78:80
Listen 8080

[root@web2 ~]# systemctl restart httpd
[root@web2 ~]# echo test 172.25.254.20 &gt; /var/www/html/index.html</code></pre> 
<h5 id="1.2.%E6%8C%87%E5%AE%9A%20location%20%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" style="background-color:transparent;">1.2.指定 location 实现反向代理</h5> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf

server {
        listen 80;
        server_name www.timinglee.org;

        location / {
                proxy_pass http://172.25.254.10:80;
        }

        location /static {
                proxy_pass http://172.25.254.20:8080;
        }

}

[root@nginx ~]# nginx -s reload
</code></pre> 
<p>测试</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/eb/5a/sZ89xUJ1_o.png" width="665"></p> 
<h4 id="2.%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB" style="background-color:transparent;">2.反向代理实现动静分离</h4> 
<pre><code class="language-bash">[root@web1 ~]# yum install php -y
[root@web1 ~]# vim /var/www/html/index.php

&lt;?php
        phpinfo();
?&gt;

[root@web1 ~]# systemctl restart httpd
</code></pre> 
<pre><code class="language-bash">[root@nginx ~]# vim /usr/local/nginx/conf.d/vhost.conf

server {
       listen 80;
       server_name www.timinglee.org; 

       location ~\.php$ {
                proxy_pass http://172.25.254.10:80;
        }

        location /static {
                proxy_pass http://172.25.254.20:8080;
        }
}

[root@nginx ~]# nginx -s reload</code></pre> 
<p>测试</p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/3f/9a/OVUbDN9B_o.png" width="831"></p> 
<p>3.实现 Nginx 四层负载均衡</p> 
<p>Nginx在1.9.0版本开始支持tcp模式的负载均衡，在1.9.13版本开始支持udp协议的负载，udp主要用于 DNS的域名解析，其配置方式和指令和http 代理类似，其基于ngx_stream_proxy_module模块实现tcp 负载，另外基于模块ngx_stream_upstream_module实现后端服务器分组转发、权重分配、状态监测、 调度算法等高级功能。</p> 
<h5 id="2.1.%20tcp%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%C2%A0" style="background-color:transparent;">2.1. tcp负载均衡配置参数 </h5> 
<pre><code class="language-bash">stream {                    #定义stream相关的服务；                            
Context:main
    upstream backend {         #定义后端服务器                              
        hash $remote_addr consistent;             #定义调度算法   
        server backend1.example.com:12345 weight=5;  #定义具体server
        server 127.0.0.1:12345  max_fails=3 fail_timeout=30s;
        server unix:/tmp/backend3;
 }
    upstream dns {                                   
        server 10.0.0.1:53;                     #定义后端服务器     
        server dns.example.com:53;               #定义具体server
 }

server {                                         #定义server
    listen 12345;                                 #监听IP:PORT
        proxy_connect_timeout 1s;                 #连接超时时间   
        proxy_timeout 3s;                         #转发超时时间 
        proxy_pass backend;                       #转发到具体服务器组   
}

server {
     listen 127.0.0.1:53 udp reuseport;
         proxy_timeout 20s;
         proxy_pass dns;
 }
 
server {
     listen [::1]:12345;
         proxy_pass unix:/tmp/stream.socket;
 }

</code></pre> 
<h5 id="2.2.udp%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%3A%20DNS">2.2.udp 负载均衡实例: DNS</h5> 
<p>后端服务器安装 DNS</p> 
<pre><code class="language-bash">[root@web1 ~]# dnf install bind -y
[root@web1 ~]# vim /etc/named.conf 

options {
        listen-on port 53 { any; };
        listen-on-v6 port 53 { ::1; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        secroots-file   "/var/named/data/named.secroots";
        recursing-file  "/var/named/data/named.recursing";
        allow-query     { any; };

        recursion yes;

        dnssec-validation no;

[root@web1 ~]# vim /etc/named.rfc1912.zones
[root@web1 ~]# cd /var/named/
[root@web1 named]# cp named.localhost timinglee.org.zone -p
[root@web1 named]# vim timinglee.org.zone

zone "timinglee.org" IN {
        type master;
        file "timinglee.org.zone";
        allow-update { none; };
};


$TTL 1D
@       IN SOA  ns.timinglee.org. root.timinglee.org. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      ns.timinglee.org.
ns      A       172.25.254.10
www     A       172.25.254.10
~                                      
[root@web1 named]# systemctl restart named</code></pre> 
<p>测试</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/97/8f/83rRD096_o.png" width="869"></p> 
<pre><code class="language-bash">[root@web1 named]# scp -p /etc/named.{conf,rfc1912.zones} 172.25.254.20:/etc
[root@web1 named]# scp -p /var/named/timinglee.org.zone 172.25.254.20:/var/named/timinglee.org.zone
[root@web2 ~]# vim /var/named/timinglee.org.zone
$TTL 1D
@       IN SOA   ns.timinglee.org. root.timinglee.org. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      ns.timinglee.org.
ns      A       172.25.254.20
www     A       172.25.254.20

[root@web2 ~]# systemctl restart named</code></pre> 
<p>测试</p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/04/ac/TolfKMXn_o.png" width="806"></p> 
<h4 id="3.%E5%AE%9E%E7%8E%B0%20FastCGI%C2%A0">3.实现 FastCGI </h4> 
<p>CGI的由来：</p> 
<p>最早的Web服务器只能简单地响应浏览器发来的HTTP请求，并将存储在服务器上的HTML文件返回给浏 览器，也就是静态html文件，但是后期随着网站功能增多网站开发也越来越复杂，以至于出现动态技 术，比如像php(1995年)、java(1995)、python(1991)语言开发的网站，但是nginx/apache服务器并不 能直接运行 php、java这样的文件，apache实现的方式是打补丁，但是nginx缺通过与第三方基于协议实 现，即通过某种特定协议将客户端请求转发给第三方服务处理，第三方服务器会新建新的进程处理用户 的请求，处理完成后返回数据给Nginx并回收进程，最后nginx在返回给客户端，那这个约定就是通用网 关接口(common gateway interface，简称CGI)，CGI（协议） 是web服务器和外部应用程序之间的接口 标准，是cgi程序和web服务器之间传递信息的标准化接口。</p> 
<p>为什么会有FastCGI？</p> 
<p>CGI协议虽然解决了语言解析器和 Web Server 之间通讯的问题，但是它的效率很低，因为 Web Server 每收到一个请求都会创建一个CGI进程，PHP解析器都会解析php.ini文件，初始化环境，请求结束的时候 再关闭进程，对于每一个创建的CGI进程都会执行这些操作，所以效率很低，而FastCGI是用来提高CGI性 能的，FastCGI每次处理完请求之后不会关闭掉进程，而是保留这个进程，使这个进程可以处理多个请 求。这样的话每个请求都不用再重新创建一个进程了，大大提升了处理效率。</p> 
<p>什么是PHP-FPM？</p> 
<p>PHP-FPM(FastCGI Process Manager：</p> 
<ul><li>FastCGI进程管理器)是一个实现了Fastcgi的程序，并且提供进程管理的功能</li><li>进程包括master进程和worker进程。master进程只有一个，负责监听端口，接受来自web server 的请求</li><li>worker进程一般会有多个，每个进程中会嵌入一个PHP解析器，进行PHP代码的处理</li></ul> 
<h5 id="3.1%E3%80%81Nginx%E4%B8%8Ephp-fpm%E5%9C%A8%E5%90%8C%E4%B8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%C2%A0" style="background-color:transparent;">3.1、Nginx与php-fpm在同一服务器 </h5> 
<p>重新编译安装ngin增加两个模块</p> 
<pre><code class="language-bash">[root@nginx ~]# ls
公共  anaconda-ks.cfg                nginx-1.24.0.tar.gz
模板  clear_mnt                      nginx-1.26.1
视频  echo-nginx-module-0.63         nginx-1.26.1.tar.gz
图片  echo-nginx-module-0.63.tar.gz  openresty-1.25.3.1.tar.gz
文档  eth160.nmconnection            php-8.3.9.tar.bz2
下载  memcache-8.2.tgz               php-8.3.9.tar.gz
音乐  memc-nginx-module-0.20.tar.gz  srcache-nginx-module-0.33.tar.gz
桌面  nginx-1.24.0                   test.sh
[root@nginx ~]# tar zxf memc-nginx-module-0.20.tar.gz 
[root@nginx ~]# tar zxf php-8.3.9.tar.gz 
[root@nginx ~]# tar zxf srcache-nginx-module-0.33.tar.gz 
[root@nginx ~]# tar zxf openresty-1.25.3.1.tar.gz 
[root@nginx nginx-1.26.1]# ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --add-module=/root/echo-nginx-module-0.63 --add-module=/root/memc-nginx-module-0.20 --add-module=/root/srcache-nginx-module-0.33 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module
[root@nginx nginx-1.26.1]# make &amp;&amp; make install
[root@nginx nginx-1.26.1]# systemctl daemon-reload
[root@nginx nginx-1.26.1]# systemctl restart nginx
</code></pre> 
<p>源码编译PHP</p> 
<pre><code class="language-bash">[root@nginx ~]# cd php-8.3.9/
[root@nginx php-8.3.9]# yum install -y bzip2 systemd-devel libxml2-devel sqlite-devel libpng-devel libcurl-devel
[root@nginx ~]# rpm -ivh oniguruma-devel-6.9.6-1.el9.5.x86_64.rpm
[root@nginx php-8.3.9]# ./configure --prefix=/usr/local/php --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-curl --with-iconv --with-mhash --with-zlib --with-openssl --enable-mysqlnd --with-mysqli --with-pdo-mysql --disable-debug --enable-sockets --enable-soap --enable-xml --enable-ftp --enable-gd --enable-exif --enable-mbstring --enable-bcmath --with-fpm-systemd
[root@nginx php-8.3.9]# make &amp;&amp; make install
</code></pre> 
<p>php相关配置优化 </p> 
<pre><code class="language-bash">[root@nginx php-8.3.9]# cd /usr/local/php/etc/
[root@nginx etc]# cp -p php-fpm.conf.default php-fpm.conf
[root@nginx etc]# cd php-fpm.d/
[root@nginx php-fpm.d]# cp www.conf.default www.conf -p 
[root@nginx php-fpm.d]# vim www.conf

;                            a specific port;
;   'port'                 - to listen on a TCP socket to all addresses
;                            (IPv6 and IPv4-mapped) on a specific port;
;   '/path/to/unix/socket' - to listen on a unix socket.
; Note: This value is mandatory.
listen = 0.0.0.0:9000

#更改时区
[root@nginx php-fpm.d]# cd 
[root@nginx ~]# cd php-8.3.9/
[root@nginx php-8.3.9]# cp php.ini-production  /usr/local/php/etc/php.ini
[root@nginx php-8.3.9]# vim /usr/local/php/etc/php.ini

[Date]
; Defines the default timezone used by the date functions
; https://php.net/date.timezone
date.timezone = Asia/Shanghai</code></pre> 
<p> 生成启动脚本</p> 
<pre><code class="language-bash">[root@nginx ~]# cd php-8.3.9/sapi/fpm/
[root@nginx fpm]# cp php-fpm.service /lib/systemd/system/
[root@nginx fpm]# vim /lib/systemd/system/php-fpm.service 

# Mounts the /usr, /boot, and /etc directories read-only for processes invoked by this unit.
#ProtectSystem=full

[root@nginx fpm]# systemctl daemon-reload
[root@nginx fpm]# systemctl start php-fpm
</code></pre> 
<p>添加环境变量</p> 
<pre><code class="language-bash">[root@nginx fpm]# vim ~/.bash_profile 

# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs
export PATH=$PATH:/usr/local/nginx/sbin:/usr/local/php/bin:/usr/local/php/sbin

[root@nginx fpm]# source ~/.bash_profile</code></pre> 
<p>php测试页面</p> 
<pre><code class="language-bash">[root@nginx fpm]# mkdir -p /data/web/php
[root@nginx fpm]# cd /data/web/php/
[root@nginx php]# vim index.php

&lt;?php
    phpinfo()
?&gt;</code></pre> 
<p>PHP结合nginx，Nginx配置转发</p> 
<pre><code class="language-bash">[root@nginx php]# cd
[root@nginx ~]# cd nginx-1.26.1/
[root@nginx nginx-1.26.1]# vim  /usr/local/nginx/conf/nginx.conf

 include "/usr/local/nginx/conf.d/*.conf";

[root@nginx nginx-1.26.1]# mkdir -p /usr/local/nginx/conf.d
[root@nginx nginx-1.26.1]# vim /usr/local/nginx/conf.d/vhosts.conf
server {
        listen 80;
        server_name www.timingzpy.org;
        root /data/web/html;
        index index.html;

        location ~ \.php$ {
                root /data/web/php;
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_index index.php;
                include fastcgi.conf;
        }
}

[root@nginx nginx-1.26.1]# nginx -s reload
</code></pre> 
<p>测试</p> 
<p><img alt="" height="589" src="https://images2.imgbox.com/cf/8c/LcOjKbT6_o.png" width="887"></p> 
<h5 id="3.2.%C2%A0php%E7%9A%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%EF%BC%88php%E7%9A%84%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97%EF%BC%89">3.2. php的动态扩展模块（php的缓存模块）</h5> 
<p><img alt="" height="267" src="https://images2.imgbox.com/33/13/LCjpy5Ar_o.png" width="837"></p> 
<p>配置php使其支持memcache</p> 
<p>添加并解压memcache的功能模块</p> 
<pre><code class="language-bash">[root@nginx ~]# tar zxf memcache-8.2.tgz 
[root@nginx ~]# ls
公共                           memc-nginx-module-0.20.tar.gz
模板                           nginx-1.24.0
视频                           nginx-1.24.0.tar.gz
图片                           nginx-1.26.1
文档                           nginx-1.26.1.tar.gz
下载                           oniguruma-devel-6.9.6-1.el9.5.x86_64.rpm
音乐                           openresty-1.25.3.1
桌面                           openresty-1.25.3.1.tar.gz
anaconda-ks.cfg                package.xml
clear_mnt                      php-8.3.9
echo-nginx-module-0.63         php-8.3.9.tar.bz2
echo-nginx-module-0.63.tar.gz  php-8.3.9.tar.gz
eth160.nmconnection            srcache-nginx-module-0.33
memcache-8.2                   srcache-nginx-module-0.33.tar.gz
memcache-8.2.tgz               test.sh
memc-nginx-module-0.20
</code></pre> 
<p>安装memcache模块</p> 
<pre><code class="language-bash">[root@nginx ~]# cd memcache-8.2/
[root@Nginx memcache-8.2]# yum install autoconf -y
[root@nginx memcache-8.2]# phpize
Configuring for:
PHP Api Version:         20230831
Zend Module Api No:      20230831
Zend Extension Api No:   420230831
[root@nginx memcache-8.2]# ./configure &amp;&amp; make &amp;&amp; make install
[root@nginx memcache-8.2]# ls /usr/local/php/lib/php/extensions/no-debug-non-zts-20230831/
memcache.so  opcache.so
[root@nginx memcache-8.2]# systemctl restart php-fpm.service </code></pre> 
<p>复制测试文件到nginx发布目录中</p> 
<pre><code class="language-bash">[root@nginx memcache-8.2]# cp example.php memcache.php /data/web/php/
[root@nginx memcache-8.2]# vim /data/web/php/memcache.php 

define('ADMIN_USERNAME','admin');       // Admin Username
define('ADMIN_PASSWORD','lee');         // Admin Password
define('DATE_FORMAT','Y/m/d H:i:s');
define('GRAPH_SIZE',200);
define('MAX_ITEM_DUMP',50);

$MEMCACHE_SERVERS[] = '127.0.0.1:11211'; // add more as an array
$MEMCACHE_SERVERS[] = 'mymemcache-server2:11211'; // add more as an array</code></pre> 
<p>配置php加载memcache模块</p> 
<pre><code class="language-bash">[root@nginx memcache-8.2]# vim /usr/local/php/etc/php.ini 

;zend_extension=opcache
extension=memcache
;;;;;;;;;;;;;;;;;;;
; Module Settings ;
;;;;;;;;;;;;;;;;;;;

[root@nginx memcache-8.2]# systemctl restart php-fpm.service</code></pre> 
<p>部署memcached </p> 
<pre><code class="language-bash">[root@nginx memcache-8.2]# dnf install memcached -y
[root@nginx memcache-8.2]# systemctl enable --now memcached.service
[root@nginx memcache-8.2]# cat /etc/sysconfig/memcached 
PORT="11211"
USER="memcached"
MAXCONN="1024"
CACHESIZE="64"
OPTIONS="-l 127.0.0.1,::1"
</code></pre> 
<p>测试</p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/68/06/zjnKX43K_o.png" width="776"></p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/0e/10/5YLpkfu7_o.png" width="866"></p> 
<h3 id="%E4%B8%83%E3%80%81nginx%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC" style="background-color:transparent;">七、nginx二次开发版本</h3> 
<hr> 
<h4 id="1.%C2%A0openresty" style="background-color:transparent;">1. openresty</h4> 
<p>Nginx 是俄罗斯人发明的， Lua 是巴西几个教授发明的，中国人章亦春把 LuaJIT VM 嵌入到 Nginx 中， 实现了 OpenResty 这个高性能服务端解决方案</p> 
<p>OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方 模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服 务和动态网关。</p> 
<p>OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言 调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高 性能 Web 应用系统。</p> 
<p>OpenResty 由于有功能强大且方便的的API,可扩展性更强,如果需要实现定制功能,OpenResty是个不错的 选择</p> 
<h4 id="2.%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85openresty"><strong style="color:#4f4f4f;font-size:18px;font-weight:bold;">2.编译安装openresty</strong></h4> 
<pre><code class="language-bash"> [root@nginx ~]# dnf -yq install gcc pcre-devel openssl-devel perl
[root@Nginx ~]#useradd -r -s /sbin/nologin nginx

[root@Nginx ~]#cd /usr/local/src

[root@Nginx src]#wget https://openresty.org/download/openresty-1.17.8.2.tar.gz

[root@Nginx src]#tar zxf openresty-1.17.8.2.tar.gz

[root@Nginx src]#cd openresty-1.17.8.2/

[root@Nginx openresty-1.17.8.2]#./configure --prefix=/apps/openresty --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with_http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module

[root@Nginx openresty-1.17.8.2]#make &amp;&amp; make install

[root@Nginx openresty-1.17.8.2]#ln -s /usr/local/openresty/bin/* /usr/bin/

[root@Nginx openresty-1.17.8.2]#openresty -v

nginx version: openresty/1.17.8.2
</code></pre> 
<h3 id="%E5%85%AB%E3%80%81%E7%BB%93%E8%AF%AD" style="background-color:transparent;">八、结语</h3> 
<hr> 
<ul><li><strong>理解配置的重要性</strong>：Nginx 的配置不仅影响服务器的性能，还直接关系到网站的可用性和安全性。合理配置可以显著提高服务器的响应速度和处理能力。</li><li> <p><strong>性能优化</strong>：通过启用压缩、调整缓存策略、优化负载均衡等措施，可以进一步提升 Nginx 的性能，减少资源消耗，提高并发处理能力。</p> </li><li> <p><strong>安全性考虑</strong>：在配置过程中，应始终考虑到安全性，如使用 HTTPS、配置防火墙规则、以及实施访问控制等，以保护服务器和用户数据的安全。</p> </li><li> <p><strong>持续监控与维护</strong>：服务器配置不是一成不变的，需要根据实际运行情况进行持续的监控和调整。定期检查日志、更新软件、以及优化配置是保持服务器长期稳定运行的关键。</p> </li><li> <p><strong>利用社区资源</strong>：Nginx 拥有一个活跃的开源社区，当遇到问题时，可以利用社区资源，如论坛、文档、教程等，获取帮助和最佳实践。</p> </li></ul> 
<p>通过深入理解Web服务器的工作原理和配置优化，企业可以构建出既高效又稳定的Web服务平台。Nginx作为一种高性能的Web服务器，通过合理的配置和应用零拷贝技术，能够显著提升企业Web服务的性能和用户体验。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/295ac7776e57448a6fff7ebec52b6209/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">tomcat相关</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9b7283cac9ce417d29bb62f75bccadb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Elasticsearch 安全通信配置（SSL/TLS）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>