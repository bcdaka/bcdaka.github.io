<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL】字节跳动MySQL连环40问（网图） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/08542a1b7d65b054725f06e709af051b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL】字节跳动MySQL连环40问（网图）">
  <meta property="og:description" content="本文首发于 ❄️慕雪的寒舍
字节MySQL连环40问，网图
虽然感觉这玩意和字节跳动没关系，但是管他的？直接开始回答！
1.MySQL中有哪几种锁？ 会的不全，所以查的GPT
MySQL中有多种类型的锁，主要包括以下几种：
共享锁（Shared Lock）：也称为读锁，多个会话可以同时持有共享锁，并且不互斥。共享锁适用于读取操作，多个会话可以并发读取同一份数据而不会产生冲突。排他锁（Exclusive Lock）：也称为写锁，排他锁与其他任何锁都互斥，只有一个会话可以持有排他锁。排他锁适用于写入或修改操作，确保在某个会话持有排他锁的时候，其他会话无法同时进行写入操作。记录锁（Record Lock）：记录锁（行锁）是针对某条记录的锁定，用于保护特定记录的完整性。在使用InnoDB存储引擎时，读取或修改某条记录时会自动给该记录加上记录锁，其他会话则无法对该记录进行并发写入或删除操作。Gap锁：Gap锁是InnoDB引擎的一种锁机制，用于防止幻读。它锁定了一个范围，但不包含实际的记录，用于防止其他会话在这个范围内插入新记录，以避免幻读现象的发生。表锁（Table Lock）：表锁是对整个表格进行锁定，可以在某些特殊情况下使用，但会阻塞其他会话的读取和写入操作。在需要并发读写的情况下，表锁的性能较低，因此一般不推荐使用。 除此之外，还有一个NEXT-KEY锁：
NEXT-KEY 锁是 InnoDB 存储引擎中的一种锁机制，用于解决幻读问题。它是通过将 Gap 锁和 记录锁 组合而成的。
具体来说，当一个事务在 InnoDB 表中执行范围查询时，如使用 &lt;、&lt;=、&gt;、&gt;= 等操作符，InnoDB 引擎会为查询涉及到的范围加上 NEXT-KEY 锁。这个 NEXT-KEY 锁包含两部分：
Gap 锁：锁定了查询范围内的间隙（Gap），防止其他事务向该范围内插入新的记录。记录锁：锁定了满足查询条件的记录，防止其他事务对这些记录进行并发修改或删除。 通过使用 NEXT-KEY 锁，InnoDB 可以有效地避免幻读现象的发生。它保证了在一个事务读取一个范围的数据时，其他事务无法并发地在该范围内插入新的记录，从而保证了读取的一致性。
需要注意的是，NEXT-KEY 锁只在事务隔离级别为可重复读（REPEATABLE READ）或更高级别时使用（MySQL默认隔离级别为可重复读）。在较高的并发环境下，使用 NEXT-KEY 锁可能会增加锁冲突的概率，因此在设计数据库和查询时需要考虑到锁的开销和事务的隔离级别。
2.MySQL中有哪些不同的表格？ 这个也是GPT回答的，注意，表格和存储引擎不是同一个概念！
在MySQL中，有以下几种不同的表格类型：
MyISAM：MyISAM是旧版本MySQL的默认表格类型。它提供了快速的读取速度，适用于大量的并发读取操作。不过，MyISAM不支持事务处理和崩溃恢复功能。InnoDB：InnoDB是一种支持事务处理和崩溃恢复功能的表格类型。它提供了行级锁定和外键约束等高级功能，适用于需要数据完整性和并发写入操作的场景。InnoDB是MySQL 5.5版本后的默认表格类型。Memory：Memory（也称为Heap）表格是将数据存储在内存中的临时表格类型。它在读取和写入方面非常快速，但它的数据是临时的，当数据库服务器重启时，表格中的数据将会丢失。Archive：Archive表格是一种高度压缩的表格类型，适用于存储大量历史数据和归档数据。它对于读取操作不太有效，但在大量写入和存储空间方面具有优势。CSV：CSV表格允许将数据以CSV（逗号分隔值）格式存储在文件中，支持导入和导出数据。它不支持索引，事务处理和其他高级特性。 除了以上列举的几种常见的表格类型外，MySQL还支持其他一些特殊用途的表格类型，如Partitioned（分区表格）和Federated（联合表格）等。
表格和存储引擎是同一个东西吗？并不是！ 在关系型数据库中，表格（Table）是指一个逻辑上的数据结构，用来组织和存储数据。一张表格由若干列（Column）和若干行（Row）组成，每列定义了一种数据类型和一个字段名，表格中的每一行则代表一个实体或记录，每个单元格存储着对应列的一个数值或字符串。
存储引擎（Storage Engine）则是指实现了数据库的表格和索引等功能的底层软件模块，它负责将表格数据存储到磁盘、跟踪并处理事务、执行查询语句等任务。不同的存储引擎具有各自的特点和优缺点，在不同场景下选择合适的存储引擎可以提高数据库的性能和可靠性。
3.MyISAM和InnoDB的区别？ MyISAM
不支持事务；采用非聚簇索引，普通索引和主键索引的形式相同；一张表包含三个本地文件； InnoDB
支持事务；采用聚簇索引，普通索引存放的是主键索引中的key值，需要回表查询；可以用索引覆盖来优化；一张表包含两个本地文件； 4.InnoDB支持的四种事务隔离级别和区别 四种隔离级别：读未提交，读已提交，可重复读，串行化；
这部分直接去看我的MySQL索引博客，里面详细介绍了区别，这里就不重写一遍了；
5.CHAR和VARCHAR的区别 char是定长字符串，最长255；varchar是变长字符串，最长65535；这就意味着varchar需要更多空间来存放当前字符串长度等信息，并且会根据当前字符串长度动态开辟空间大小，不会有额外的存储空间浪费；而char是定死的空间，char(8)里面即便只有一个字符也会占用八个的空间（会用空格进行补齐）；在字符串长度确定的情况下，比如计算长度确定的MD5，那就可以用char定长存储；长度不确定的情况下，比如人名、邮箱等信息，可以采用varchar； 顺带说一下varchar和text的区别；需要进行索引的长文可以用TEXT进行存储（注意，只有MyISAM支持全文索引）
存储空间：VARCHAR列存储的内容长度是可变的，而TEXT列可以存储大量的可变长度的文本数据。VARCHAR在存储时会根据实际存储的内容长度进行调整，而TEXT没有固定的最大长度限制，可以用来存储非常长的文本。由于TEXT可以存储更大的数据量，因此它通常占用更多的存储空间。查询性能：由于VARCHAR具有固定的最大长度限制，数据库可以更好地优化和管理存储空间，这可能会在某些情况下提升查询性能。而TEXT由于其可变长度和大容量，可能会对某些查询操作稍有影响。索引和排序：VARCHAR可以被索引和排序，这意味着可以根据这些列进行快速搜索和排序操作。而TEXT类型通常不直接支持索引和排序，需要额外的配置和处理才能实现类似的功能。 如下user1表做测试，会发现我们无法给TEXT类型上普通索引。给出的提示是，BLOG/TEXT类型不能在没有指定长度的时候上索引；因为你的长度不确定，如果MySQL将一个几万字的TEXT存到内存里面作为索引节点，那么就会占用过多的内存空间。
MariaDB [hello_mysql]&gt; desc user1; &#43;-------&#43;------------------&#43;------&#43;-----&#43;---------&#43;-------&#43; | Field | Type | Null | Key | Default | Extra | &#43;-------&#43;------------------&#43;------&#43;-----&#43;---------&#43;-------&#43; | id | int(10) unsigned | NO | PRI | NULL | | | name | varchar(200) | NO | | NULL | | | info | text | NO | | NULL | | &#43;-------&#43;------------------&#43;------&#43;-----&#43;---------&#43;-------&#43; 3 rows in set (0.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-31T09:45:49+08:00">
    <meta property="article:modified_time" content="2024-08-31T09:45:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL】字节跳动MySQL连环40问（网图）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>本文首发于 <a href="https://blog.musnow.top/?f=csdn" rel="nofollow">❄️慕雪的寒舍</a></p> 
</blockquote> 
<p>字节MySQL连环40问，网图</p> 
 
<p><img src="https://images2.imgbox.com/15/fc/gqXP2J8P_o.jpg" alt="QQ图片20230915081943"></p> 
<p>虽然感觉这玩意和字节跳动没关系，但是管他的？直接开始回答！</p> 
<h3><a id="1MySQL_9"></a>1.MySQL中有哪几种锁？</h3> 
<blockquote> 
 <p>会的不全，所以查的GPT</p> 
</blockquote> 
<p>MySQL中有多种类型的锁，主要包括以下几种：</p> 
<ol><li>共享锁（Shared Lock）：也称为<strong>读锁</strong>，多个会话可以同时持有共享锁，并且不互斥。共享锁适用于读取操作，多个会话可以并发读取同一份数据而不会产生冲突。</li><li>排他锁（Exclusive Lock）：也称为<strong>写锁</strong>，排他锁与其他任何锁都互斥，只有一个会话可以持有排他锁。排他锁适用于写入或修改操作，确保在某个会话持有排他锁的时候，其他会话无法同时进行写入操作。</li><li>记录锁（Record Lock）：记录锁（<strong>行锁</strong>）是针对某条记录的锁定，用于保护特定记录的完整性。在使用InnoDB存储引擎时，读取或修改某条记录时会自动给该记录加上记录锁，其他会话则无法对该记录进行并发写入或删除操作。</li><li>Gap锁：Gap锁是InnoDB引擎的一种锁机制，<strong>用于防止幻读</strong>。它锁定了一个范围，但不包含实际的记录，用于防止其他会话在这个范围内插入新记录，以避免幻读现象的发生。</li><li>表锁（Table Lock）：表锁是对整个表格进行锁定，可以在某些特殊情况下使用，但会阻塞其他会话的读取和写入操作。在需要并发读写的情况下，表锁的性能较低，因此一般不推荐使用。</li></ol> 
<p>除此之外，还有一个NEXT-KEY锁：</p> 
<p>NEXT-KEY 锁是 InnoDB 存储引擎中的一种锁机制，用于<strong>解决幻读</strong>问题。它是通过将 Gap 锁和 记录锁 组合而成的。</p> 
<p>具体来说，当一个事务在 InnoDB 表中执行范围查询时，如使用 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 等操作符，InnoDB 引擎会为查询涉及到的范围加上 NEXT-KEY 锁。这个 NEXT-KEY 锁包含两部分：</p> 
<ol><li>Gap 锁：锁定了查询范围内的间隙（Gap），防止其他事务向该范围内插入新的记录。</li><li>记录锁：锁定了满足查询条件的记录，防止其他事务对这些记录进行并发修改或删除。</li></ol> 
<p>通过使用 NEXT-KEY 锁，InnoDB 可以有效地避免幻读现象的发生。它保证了在一个事务读取一个范围的数据时，<strong>其他事务无法并发地在该范围内插入新的记录</strong>，从而保证了读取的一致性。</p> 
<p>需要注意的是，NEXT-KEY 锁只在事务隔离级别为<strong>可重复读</strong>（REPEATABLE READ）或更高级别时使用（MySQL默认隔离级别为可重复读）。在较高的并发环境下，使用 NEXT-KEY 锁可能会增加锁冲突的概率，因此在设计数据库和查询时需要考虑到锁的开销和事务的隔离级别。</p> 
<h3><a id="2MySQL_34"></a>2.MySQL中有哪些不同的表格？</h3> 
<blockquote> 
 <p>这个也是GPT回答的，注意，表格和存储引擎不是同一个概念！</p> 
</blockquote> 
<p>在MySQL中，有以下几种不同的表格类型：</p> 
<ol><li>MyISAM：MyISAM是旧版本MySQL的默认表格类型。它提供了快速的读取速度，适用于大量的并发读取操作。不过，MyISAM不支持事务处理和崩溃恢复功能。</li><li>InnoDB：InnoDB是一种支持事务处理和崩溃恢复功能的表格类型。它提供了行级锁定和外键约束等高级功能，适用于需要数据完整性和并发写入操作的场景。InnoDB是<strong>MySQL 5.5版本后</strong>的默认表格类型。</li><li>Memory：Memory（也称为Heap）表格是将数据存储在内存中的临时表格类型。它在读取和写入方面非常快速，但它的数据是临时的，当数据库服务器重启时，表格中的数据将会丢失。</li><li>Archive：Archive表格是一种高度压缩的表格类型，适用于存储大量历史数据和归档数据。它对于读取操作不太有效，但在大量写入和存储空间方面具有优势。</li><li>CSV：CSV表格允许将数据以CSV（逗号分隔值）格式存储在文件中，支持导入和导出数据。它不支持索引，事务处理和其他高级特性。</li></ol> 
<p>除了以上列举的几种常见的表格类型外，MySQL还支持其他一些特殊用途的表格类型，如Partitioned（分区表格）和Federated（联合表格）等。</p> 
<ul><li>表格和存储引擎是同一个东西吗？并<strong>不是</strong>！</li></ul> 
<p>在关系型数据库中，表格（Table）是指一个逻辑上的数据结构，用来组织和存储数据。一张表格由若干列（Column）和若干行（Row）组成，每列定义了一种数据类型和一个字段名，表格中的每一行则代表一个实体或记录，每个单元格存储着对应列的一个数值或字符串。</p> 
<p>存储引擎（Storage Engine）则是指实现了数据库的表格和索引等功能的底层软件模块，它负责将表格数据存储到磁盘、跟踪并处理事务、执行查询语句等任务。不同的存储引擎具有各自的特点和优缺点，在不同场景下选择合适的存储引擎可以提高数据库的性能和可靠性。</p> 
<h3><a id="3MyISAMInnoDB_54"></a>3.MyISAM和InnoDB的区别？</h3> 
<p>MyISAM</p> 
<ul><li>不支持事务；</li><li>采用非聚簇索引，普通索引和主键索引的形式相同；</li><li>一张表包含三个本地文件；</li></ul> 
<p>InnoDB</p> 
<ul><li>支持事务；</li><li>采用聚簇索引，普通索引存放的是主键索引中的key值，需要回表查询；可以用索引覆盖来优化；</li><li>一张表包含两个本地文件；</li></ul> 
<h3><a id="4InnoDB_68"></a>4.InnoDB支持的四种事务隔离级别和区别</h3> 
<p>四种隔离级别：读未提交，读已提交，可重复读，串行化；</p> 
<p>这部分直接去看我的<a href="https://blog.musnow.top/posts/3474107655/" rel="nofollow">MySQL索引</a>博客，里面详细介绍了区别，这里就不重写一遍了；</p> 
<h3><a id="5CHARVARCHAR_74"></a>5.CHAR和VARCHAR的区别</h3> 
<ul><li>char是定长字符串，最长255；varchar是变长字符串，最长65535；</li><li>这就意味着varchar需要更多空间来存放当前字符串长度等信息，并且会根据当前字符串长度动态开辟空间大小，不会有额外的存储空间浪费；</li><li>而char是定死的空间，<code>char(8)</code>里面即便只有一个字符也会占用八个的空间（会用空格进行补齐）；</li><li>在字符串长度确定的情况下，比如计算长度确定的MD5，那就可以用char定长存储；长度不确定的情况下，比如人名、邮箱等信息，可以采用varchar；</li></ul> 
<p>顺带说一下varchar和text的区别；需要进行索引的长文可以用TEXT进行存储（注意，只有MyISAM支持全文索引）</p> 
<ol><li>存储空间：VARCHAR列存储的内容长度是可变的，而TEXT列可以存储大量的可变长度的文本数据。VARCHAR在存储时会根据实际存储的内容长度进行调整，而TEXT没有固定的最大长度限制，可以用来存储非常长的文本。由于TEXT可以存储更大的数据量，因此它通常占用更多的存储空间。</li><li>查询性能：由于VARCHAR具有固定的最大长度限制，数据库可以更好地优化和管理存储空间，这可能会在某些情况下提升查询性能。而TEXT由于其可变长度和大容量，可能会对某些查询操作稍有影响。</li><li>索引和排序：VARCHAR可以被索引和排序，这意味着可以根据这些列进行快速搜索和排序操作。而TEXT类型通常不直接支持索引和排序，需要额外的配置和处理才能实现类似的功能。</li></ol> 
<p>如下user1表做测试，会发现我们无法给TEXT类型上普通索引。给出的提示是，<code>BLOG/TEXT</code>类型不能在没有指定长度的时候上索引；因为你的长度不确定，如果MySQL将一个几万字的TEXT存到内存里面作为索引节点，那么就会占用过多的内存空间。</p> 
<pre><code>MariaDB [hello_mysql]&gt; desc user1;
+-------+------------------+------+-----+---------+-------+
| Field | Type             | Null | Key | Default | Extra |
+-------+------------------+------+-----+---------+-------+
| id    | int(10) unsigned | NO   | PRI | NULL    |       |
| name  | varchar(200)     | NO   |     | NULL    |       |
| info  | text             | NO   |     | NULL    |       |
+-------+------------------+------+-----+---------+-------+
3 rows in set (0.001 sec)
MariaDB [hello_mysql]&gt; alter table user1 add index(info);
ERROR 1170 (42000): BLOB/TEXT column 'info' used in key specification without a key length
</code></pre> 
<p>即便在创建列的时候给定了TEXT的长度，依旧不能创建索引。</p> 
<pre><code>MariaDB [hello_mysql]&gt; alter table user1 add info1 TEXT(20) NOT NULL;
Query OK, 0 rows affected (0.002 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [hello_mysql]&gt; desc user1;
+-------+------------------+------+-----+---------+-------+
| Field | Type             | Null | Key | Default | Extra |
+-------+------------------+------+-----+---------+-------+
| id    | int(10) unsigned | NO   | PRI | NULL    |       |
| name  | varchar(200)     | NO   |     | NULL    |       |
| info  | text             | NO   |     | NULL    |       |
| info1 | tinytext         | NO   |     | NULL    |       |
+-------+------------------+------+-----+---------+-------+
4 rows in set (0.001 sec)

MariaDB [hello_mysql]&gt; alter table user1 add index(info1);
ERROR 1170 (42000): BLOB/TEXT column 'info1' used in key specification without a key length
</code></pre> 
<p>正确的写法如下，需要在创建索引的时候，括号指定索引的长度；比如<code>index(info1(10))</code>含义就是给info1列的前10个字符建立索引。只要TEXT里面存放的文本前10个字符重复率低，那么这个索引就是有意义的！</p> 
<pre><code>MariaDB [hello_mysql]&gt; alter table user1 add index(info1(10));
Query OK, 0 rows affected (0.007 sec)
Records: 0  Duplicates: 0  Warnings: 0
</code></pre> 
<h3><a id="6_133"></a>6.主键和候选键(码)有啥区别？</h3> 
<p>候选键是一些可以选用（备选）为主键或者唯一键的类型；</p> 
<p>比如一个学生表里面，包含学生主键的INT自增ID，学生学号，学生身份证，学生姓名，学生性别等等信息；在这个表里面，除了主键这个INT的ID，我们还可以把学生的学号和学生的身份证作为主键或者唯一键，因为他们都包含唯一性！</p> 
<p>这时候，这些可以作为主键的列，就叫做候选键；</p> 
<ul><li>候选键也需要保持唯一性</li><li>候选键需要遵循最小原则，不能是某一个聚合唯一标识的子集；（比如我需要用<strong>部门ID和部门内员工ID</strong>来唯一标识一个员工，此时部门ID就不能作为这个员工表的候选键，因为在整个表中部门ID会重复）</li></ul> 
<p>在《数据库系统概率》这门课里面，会把键称作为码，本质上是一个东西。</p> 
<blockquote> 
 <p>到底是谁把key翻译成码的？真无语😒</p> 
</blockquote> 
<h3><a id="7myisamchk_148"></a>7.myisamchk是用来干什么的</h3> 
<p>一个命令行工具（在bash下使用，不是在MySQL命令行使用）</p> 
<blockquote> 
 <p>Myisamchk是MyISAM表维护的一个非常实用的工具。可以使用myisamchk实用程序来获得有关数据库表的信息或检查、修复、优化他们。myisamchk适用MyISAM表(对应.MYI和.MYD文件的表)。</p> 
</blockquote> 
<p>这个命令了解即可，下面是两篇使用博客。有需要再去深入学习用法</p> 
<p>http://www.4u4v.net/myisamchk-gadgets-manual.html</p> 
<p>https://www.cnblogs.com/analyzer/articles/1381538.html</p> 
<h3><a id="8TIMESTAMP_160"></a>8.如果表中有一列定义为TIMESTAMP会发生什么</h3> 
<p>TIMESTAMP底层一般是4个字节，在MySQL里面进行查询的时候，会根据系统时区，转成可读时间进行输出。包括使用cpp devel包获取到的也是可读时间；</p> 
<p>因为只有4个字节，所以TIMESTAMP最多能表示 <code>1970-01-01 00:00:01</code>到<code>2038-01-19 03:14:07</code>，这也是一个2038年问题，需要改成8字节存储才能存放更长的时间。</p> 
<p>另外，如果你想更加精确的标识时间，而不依赖于MySQL对时间戳的自动转换，那么就可以用BIGINT或者DECIMAL类型来存放时间戳数字，再在应用层进行时间戳和可读时间之间的转换。</p> 
<h3><a id="9_168"></a>9.怎么看到表格定义的所有索引</h3> 
<p>两种方式都可以</p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span>
<span class="token keyword">show</span> <span class="token keyword">keys</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="10LIKE_177"></a>10.LIKE声明中的%是什么意思</h3> 
<p>代表通配符，匹配所有字符串。下面举几个例子</p> 
<pre><code>查询 '张%'
    张丽丽
    张扣扣
    张三
    张阿斯顿

查询 '%张%'
	里张里
    十大张撒打发

查询 '%张'
	xx张
	xxxxx张
</code></pre> 
<p>需要注意，只有<code>关键字%</code>的使用方式才能用上索引，另外两种匹配方式无法使用索引！</p> 
<h3><a id="11_199"></a>11.列对比运算符是什么</h3> 
<pre><code>等于 =
不等于 &lt;&gt; !=
大于和大于等于  &gt; &gt;=
小于和小于等于  &lt; &lt;=
区间 BETWEEN .. AND ...
是否在列表中 IN
模糊匹配 LIKE
NULL比较 IS NULL, IS NOT NULL
</code></pre> 
<h3><a id="12BLOBTEXT_212"></a>12.BLOB和TEXT有什么区别？</h3> 
<p>GPT说的：</p> 
<ol><li>存储容量：BLOB可以存储二进制数据，而TEXT只能存储纯文本数据。</li><li>字符集排序规则：BLOB没有字符集排序规则，而TEXT有，默认为字符集的排序规则。</li><li>数据排序和比较：BLOB会按二进制方式进行排序和比较，而TEXT会按字符排序规则进行排序和比较。</li><li>存储方式：BLOB数据以二进制形式存储，没有字符集转换；而TEXT数据会根据字符集进行转换和存储。</li><li>索引：在MySQL中，BLOB和TEXT列可以有索引，但有一些限制。BLOB列或前缀索引的最大长度是768字节，对于UTF-8字符集是255个字符。而TEXT列或前缀索引的最大长度是3072字节，在UTF-8字符集中是1024个字符。</li><li>默认值：BLOB和TEXT列不能具有默认值。</li></ol> 
<p>总的来说，BLOB适合存储二进制数据，例如图像、音频或视频文件等。而TEXT适合存储纯文本数据，如长文本、文章内容等。根据具体的需求，你可以选择适当的数据类型来存储相应的数据。</p> 
<blockquote> 
 <p>实际上，把图片、音频这些静态资源存入数据库是不合理的……</p> 
</blockquote> 
<h3><a id="13MySQL_fetch_arrayMySQL_fetch_obj_227"></a>13.MySQL_fetch_array和MySQL_fetch_obj有什么区别？</h3> 
<p>PHP里面的函数，不学，直接跳过</p> 
<h3><a id="14MyISAM_231"></a>14.MyISAM表格将在那里存储？并且还提供其存储格式？</h3> 
<p>在linux下，MyISAM表格以文件形式存储在数据目录下的对应数据库目录中。每个表格对应一个.MYD数据文件（用于存储表格数据）和一个.MYI索引文件（用于存储表格索引），以及一个.frm表格定义文件（包含表格定义信息，如字段名、数据类型等）</p> 
<p>MyISAM使用一种称为“静态行格式”的存储格式来存储表格数据。这种格式用于在磁盘上保存由定长行组成的表格，每个行定长，占用相同的存储空间，以便更快地读取和写入数据。MyISAM表格还支持动态行格式，这种格式允许可变行长度，因此可以更有效地存储可变长度的数据类型（如VARCHAR，TEXT等）。</p> 
<h3><a id="15MySQLDISTINCT_237"></a>15.MySQL如何优化DISTINCT?</h3> 
<p>使用索引，减少查询行数来优化去重操作</p> 
<h3><a id="1650_241"></a>16.如何显示前50行？</h3> 
<p>查询语句后带上limit就可以</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表名 <span class="token keyword">limit</span> <span class="token number">50</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="17_249"></a>17.可以使用多少列创建索引？</h3> 
<p>根据实际使用场景来确定用几列，并没有固定限制。理论上来说需要保持最小原则，不要包含多余的无效列（除非你需要用来进行索引优化，减少回表操作）</p> 
<h3><a id="18nowcurrent_date_253"></a>18.now和current_date有什么区别？</h3> 
<p>now会返回一直到时分秒的信息，current_date只会返回当日日期</p> 
<h3><a id="19_257"></a>19.什么是非标准字符串类型</h3> 
<blockquote> 
 <p>GPT</p> 
</blockquote> 
<p>非标准字符串类型是指在数据库中没有明确定义或标准化的字符串数据类型。这些类型通常是特定数据库管理系统（DBMS）或应用程序开发框架所支持的扩展。由于不同的DBMS和框架有各自的特性和需求，可能会引入额外的非标准字符串类型以满足特定的数据存储和操作需求。</p> 
<p>举例来说，MySQL数据库在其标准字符串类型中包含了CHAR、VARCHAR、TEXT等。而非标准字符串类型可能是根据具体需求和扩展开发的，如JSON、XML、BLOB、CLOB等。这些非标准类型在一些特定场景中使用广泛，例如存储非结构化的文本数据、大型二进制数据、以及存储和查询复杂的结构化数据等。</p> 
<p>需要注意的是，非标准字符串类型在不同的DBMS和开发框架之间可能存在差异，并且在跨平台和迁移时可能会出现兼容性问题。因此，在使用非标准字符串类型时，建议仔细了解相关的文档和规范，并评估其对应用程序的影响和可移植性。</p> 
<h3><a id="20SQL_267"></a>20.什么是通用SQL函数</h3> 
<p>以下列举了一些常见的通用SQL函数：</p> 
<ol><li>聚合函数：如SUM、AVG、COUNT、MIN、MAX等，用于对数据进行统计和聚合计算。</li><li>字符串函数：如CONCAT、SUBSTRING、UPPER、LOWER、LENGTH等，用于处理和操作字符串数据。</li><li>数值函数：如ABS、ROUND、CEILING、FLOOR等，用于执行数值计算和转换。</li><li>日期和时间函数：如DATE, TIME, YEAR, MONTH, DAY等，用于处理日期和时间数据的计算和格式化。</li><li>条件函数：如IF, CASE WHEN, COALESCE等，用于根据条件执行不同的逻辑和返回不同的结果。</li><li>类型转换函数：如CAST、CONVERT等，用于在不同的数据类型之间进行转换。</li></ol> 
<p>这只是一小部分通用SQL函数的例子，实际上还有很多其他的函数可用于不同的数据处理和查询需求。需要注意的是，尽管这些函数在大多数DBMS中都存在，但某些特定的DBMS可能会提供额外的函数或有稍微不同的语法，因此在使用函数时应查阅相应的文档和规范以确保兼容性和正确性。</p> 
<h3><a id="21MySQL_280"></a>21.MySQL支持事务吗？</h3> 
<p>肯定支持，这个问题第四点就已经详细问了</p> 
<h3><a id="22MySQL_284"></a>22.MySQL里面记录货币用什么类型好？</h3> 
<p>因为浮点数的精度问题，可以用BIGINT来存放以<strong>分</strong>为单位的货币，实际调用的时候再加上小数点，来保证数据准确。</p> 
<p>如果不用BIGINT，那就需要用DECIMAL来存放货币。</p> 
<blockquote> 
 <p>B站冲浪看到的</p> 
</blockquote> 
<h3><a id="23MySQL_292"></a>23.MySQL有关权限的表有那几个</h3> 
<p>在MySQL中，有几个与权限相关的系统表和视图，用于管理用户、角色和权限。以下是一些常见的权限相关的表和视图：</p> 
<ol><li>mysql.user：这个表包含了MySQL实例上的所有用户账户信息，包括用户名、密码等。该表记录了每个用户的全局权限。</li><li>mysql.db：这个表记录了用户对数据库级别的权限。它指定了哪个用户对哪个数据库具有什么样的权限。</li><li>mysql.tables_priv：这个表记录了用户对表级别的权限。它存储了用户对某个具体表的权限信息（如SELECT、INSERT、UPDATE、DELETE等）。</li><li>mysql.columns_priv：这个表记录了用户对列级别的权限。它存储了用户对表中某个具体列的权限信息。</li><li>mysql.procs_priv：这个表记录了用户对存储过程和函数的权限。</li><li>mysql.roles：这个表存储了角色的相关信息，包括角色名、角色的创建者等。</li></ol> 
<p>除了上述的表之外，MySQL还提供了一些权限相关的视图，这些视图可以方便地查看用户、角色和权限的信息，如：</p> 
<ul><li>information_schema.USER_PRIVILEGES：显示所有用户的权限信息。</li><li>information_schema.SCHEMA_PRIVILEGES：显示所有数据库的权限信息。</li><li>information_schema.TABLE_PRIVILEGES：显示所有表的权限信息。</li><li>information_schema.COLUMN_PRIVILEGES：显示所有列的权限信息。</li></ul> 
<p>如下是个使用示例</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>USER_PRIVILEGES<span class="token punctuation">;</span>
</code></pre> 
<p>这些表和视图可以通过查询相应的系统表或视图来查看和管理用户、角色和权限。请注意，具体的系统表和视图名称可能因MySQL版本和配置而有所不同。为了确保准确性，请参考MySQL官方文档或特定版本的文档。</p> 
<h3><a id="24_318"></a>24.列的字符串类型可以是什么</h3> 
<p>TEXT CHAR VARCHAR，详见第五点</p> 
<h3><a id="25MySQL_322"></a>25.MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？</h3> 
<blockquote> 
 <p>没见过这种业务，只能问GPT</p> 
</blockquote> 
<p>对于一个MySQL作为发布系统存储的场景，处理每天超过五万条增量数据并且需要保持三年的数据，以下是一些优化建议：</p> 
<ol><li>数据库硬件和配置优化： 
  <ul><li>硬件性能：确保数据库服务器具备足够的计算、内存和存储资源，以处理高负载的写入和读取操作。</li><li>存储设备：使用高性能的存储设备（如SSD）来提高写入和读取速度。</li><li>MySQL参数调优：根据实际情况调整MySQL的配置参数，例如设置合理的缓冲区大小、并发连接数、查询缓存等。</li></ul> </li><li>数据库架构优化： 
  <ul><li>分库分表：考虑将数据进行分库分表来分担单个数据库的负载压力。根据数据的特点和访问模式，合理划分数据到不同的库表中。</li><li>索引优化：根据查询需求创建合适的索引，以加快查询速度。避免过多的索引和冗余索引，以减少维护成本。</li><li>分区表：如果数据的时间范围有明显的界限，可以考虑使用MySQL的分区表功能，将数据按时间范围进行分区，提高查询性能和维护效率。</li></ul> </li><li>数据写入优化： 
  <ul><li>批量插入：使用批量插入方式（如INSERT INTO … VALUES (), (), ()…）来减少单条插入的开销，提高写入性能。</li><li>事务处理：将多个写入操作放在一个事务中，确保数据的一致性和完整性，减少IO开销。</li></ul> </li><li>数据归档和压缩： 
  <ul><li>数据归档：对于历史数据，可以将其归档到独立的存储介质中，例如将旧数据迁移到归档数据库或者离线存储系统中以减轻主数据库的负载。</li><li>数据压缩：对于不频繁查询的历史数据，可以考虑使用压缩算法（例如MySQL的压缩表功能或者第三方压缩库）进行存储，以减少存储空间占用。</li></ul> </li><li>监控和优化工具： 
  <ul><li>使用监控工具实时监测数据库的性能指标，如查询速度、磁盘使用、锁等情况，及时发现潜在的性能瓶颈并进行调优。</li><li>使用性能优化工具，如Explain分析、慢查询日志等，来找出慢查询和低效的SQL语句，并进行优化。</li></ul> </li></ol> 
<p>以上是一些常见的优化建议，具体优化方案还需要根据实际场景和需求进行调整。同时，建议在进行优化前，充分了解应用的读写特征、数据访问模式和业务需求，以便有针对性地进行优化工作。</p> 
<h3><a id="26_349"></a>26.锁的优化策略？</h3> 
<h3><a id="27_351"></a>27.索引的底层实现和优化？</h3> 
<p>底层用B+实现，优化索引方式见索引博客 https://blog.musnow.top/posts/3474107655/</p> 
<h3><a id="28_355"></a>28.什么情况下有索引但是无法使用</h3> 
<p>索引失效，见索引博客 https://blog.musnow.top/posts/3474107655/</p> 
<h3><a id="29MySQL_359"></a>29.实践中如何优化MySQL</h3> 
<p>太宽泛了，不好回答</p> 
<ul><li>索引优化</li><li>分表</li><li>事务隔离性选择</li></ul> 
<h3><a id="30_367"></a>30.优化数据库的办法？</h3> 
<p>和29题重合，不做回答</p> 
<h3><a id="31_371"></a>31.简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）</h3> 
<p>见索引博客 https://blog.musnow.top/posts/3474107655/</p> 
<h3><a id="32_375"></a>32.数据库的事务是什么</h3> 
<p>见事务博客 https://blog.musnow.top/posts/2200233148/</p> 
<h3><a id="33SQL_379"></a>33.SQL注入漏洞的产生和原因，如何防止</h3> 
<p>SQL注入漏洞是一种常见的安全漏洞，它可以使攻击者通过构造恶意的SQL语句来绕过应用程序的输入验证，进而执行非法的数据库操作或获取敏感信息。以下是SQL注入漏洞产生的原因和一些防止方法：</p> 
<ol><li>原因： 
  <ul><li>不正确的输入验证：当应用程序没有对用户的输入进行充分验证和过滤时，攻击者可以通过输入特定的字符或语句来修改SQL语句的结构，从而执行恶意操作。</li><li>拼接字符串构造SQL语句：如果应用程序使用拼接字符串的方式构造SQL查询语句，并且未对用户输入进行正确的转义处理，就容易受到SQL注入攻击。</li></ul> </li><li>防止方法： 
  <ul><li>使用参数化查询或预编译语句：参数化查询将用户输入作为参数传递给SQL语句，而不是直接拼接字符串。这样可以通过数据库驱动程序自动处理转义和编码，有效防止SQL注入攻击。</li><li>输入验证和过滤：对用户的输入数据进行验证和过滤，只接受符合规范的数据。可以使用白名单、黑名单、正则表达式等方法进行输入验证和过滤。</li><li>最小权限原则：在数据库中为应用程序使用的账号设置最小权限，即只授予应用程序完成必要操作所需的最低权限，避免攻击者利用注入漏洞进行更危险的操作。</li><li>不要直接暴露数据库错误信息：在生产环境中，不要将详细的数据库错误信息返回给用户，以防止攻击者从中获取关键信息。可以记录错误日志并给用户一个友好的错误提示。</li><li>定期更新和修补数据库和应用程序：及时安装数据库和应用程序的安全补丁，以修复已知的漏洞，并确保使用最新的安全措施。</li></ul> </li></ol> 
<p>总之，为了防止SQL注入漏洞，关键是要对用户输入数据进行合理验证、过滤和转义处理，并使用参数化查询或预编译语句来构造SQL语句。同时，保持应用程序和数据库的安全性，并及时更新和修补已知的安全漏洞。</p> 
<h3><a id="34_395"></a>34.如何为表中字段选择合适数据类型</h3> 
<p>肯定是根据具体情况回答</p> 
<h3><a id="35_399"></a>35.存储时期？</h3> 
<p>感觉这道题有问题，不管他</p> 
<h3><a id="36_403"></a>36.索引相关问题？</h3> 
<p>和31重合，不回答</p> 
<h3><a id="37MySQL_407"></a>37.解释MySQL中外连接、内连接、自连接的区别</h3> 
<ol><li>内连接（INNER JOIN）： 
  <ul><li>内连接返回两个表中满足连接条件的记录，即只返回两个表中能够匹配的行。</li><li>内连接使用一个连接谓词（JOIN）或者在FROM子句中使用逗号（,）来表示。</li><li>内连接可以根据指定的连接条件将两个表中的列进行匹配。如果未提供连接条件，则会返回两个表的笛卡尔积。</li><li>语法示例：SELECT * FROM 表1 INNER JOIN 表2 ON 表1.列 = 表2.列;</li></ul> </li><li>外连接（OUTER JOIN）： 
  <ul><li>外连接将返回两个表中满足连接条件的记录，并且还包括不满足连接条件的记录。</li><li>外连接分为左外连接（LEFT JOIN）和右外连接（RIGHT JOIN）。</li><li>左外连接返回左表中的所有记录，以及右表中与左表满足连接条件的记录。如果右表中没有匹配的记录，则会返回NULL值。</li><li>右外连接返回右表中的所有记录，以及左表中与右表满足连接条件的记录。如果左表中没有匹配的记录，则会返回NULL值。</li><li>语法示例： 
    <ul><li>左外连接：SELECT * FROM 表1 LEFT JOIN 表2 ON 表1.列 = 表2.列;</li><li>右外连接：SELECT * FROM 表1 RIGHT JOIN 表2 ON 表1.列 = 表2.列;</li></ul> </li></ul> </li><li>自连接（SELF JOIN）： 
  <ul><li>自连接是指将表视为两个独立的实例，使用别名来区分它们，然后根据某些条件将它们连接在一起。</li><li>自连接通常用于在同一个表中根据某种关系进行数据查询。</li><li>语法示例：SELECT 别名1.列, 别名2.列 FROM 表 别名1, 表 别名2 WHERE 别名1.列 = 别名2.列;</li></ul> </li></ol> 
<p>总结：</p> 
<ul><li>内连接返回两个表中匹配的记录，外连接返回满足连接条件的记录以及不满足连接条件的记录，而自连接是对同一个表进行连接操作。</li><li>内连接和外连接需要使用JOIN关键字，而自连接使用同一个表的别名进行连接。</li><li>内连接和外连接可以根据连接条件将两个表进行关联，而自连接可以根据表中的某些条件进行关联。</li></ul> 
<h3><a id="38MySQL_433"></a>38.MySQL中事务回滚机制描述</h3> 
<p>见事务博客 https://blog.musnow.top/posts/2200233148/</p> 
<h3><a id="39SQL_437"></a>39.SQL语言包含哪几部分？每部分都有哪些操作关键字</h3> 
<p>包括DQL数据查询语言，DML数据操作语言（增删改），数据控制语言DCL用来管理数据库，事务控制语言TCL用来控制事务，数据定义语言DDL用来创建删除表</p> 
<ol><li>数据查询语言（Data Query Language，DQL）：用于从数据库中查询和检索数据。常用的操作关键字包括： 
  <ul><li>SELECT：用于从一个或多个表中选择数据列以进行查询。</li><li>FROM：指定要查询的表。</li><li>WHERE：用于指定查询的条件。</li><li>GROUP BY：按照指定的列对结果进行分组。</li><li>HAVING：用于指定对分组后的结果进行筛选的条件。</li><li>ORDER BY：指定结果集的排序方式。</li></ul> </li><li>数据操作语言（Data Manipulation Language，DML）：用于对数据库中的数据进行增加、修改和删除操作。常用的操作关键字包括： 
  <ul><li>INSERT INTO：向表中插入新的行或数据。</li><li>UPDATE：更新表中已有的数据。</li><li>DELETE FROM：从表中删除指定的行或数据。</li></ul> </li><li>数据定义语言（Data Definition Language，DDL）：用于创建、修改和删除数据库和表结构。常用的操作关键字包括： 
  <ul><li>CREATE DATABASE：创建新的数据库。</li><li>CREATE TABLE：创建新的数据表。</li><li>ALTER TABLE：修改已存在的数据表结构。</li><li>DROP DATABASE：删除现有的数据库。</li><li>DROP TABLE：删除现有的数据表。</li></ul> </li><li>数据控制语言（Data Control Language，DCL）：用于管理数据库中的用户权限和访问权限。常用的操作关键字包括： 
  <ul><li>GRANT：授予用户特定的权限。</li><li>REVOKE：撤销用户的权限。</li></ul> </li><li>事务控制语言（Transaction Control Language，TCL）：用于管理数据库的事务处理。常用的操作关键字包括： 
  <ul><li>COMMIT：提交一个事务，使其永久生效。</li><li>ROLLBACK：回滚一个事务，撤销之前的操作，使其不生效。</li><li>SAVEPOINT：在事务中设置保存点，以便在需要时进行回滚。</li></ul> </li></ol> 
<h3><a id="40_466"></a>40.完整性的约束包括那些？</h3> 
<p>原子性、隔离性、持久性；这里说的完整性应该就是一致性；</p> 
<p>具体的解释依旧是去看事务的博客 https://blog.musnow.top/posts/2200233148/</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e094c51bd1cd94a1c5ee814d98c053b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络基础知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bd07acf36a24aab6435b30ef9ed1ff8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot 整合 Sentinel 实现流量控制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>