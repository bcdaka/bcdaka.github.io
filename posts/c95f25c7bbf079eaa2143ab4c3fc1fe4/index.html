<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构 最小生成树 prim算法（普里姆算法）C语言实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c95f25c7bbf079eaa2143ab4c3fc1fe4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构 最小生成树 prim算法（普里姆算法）C语言实现">
  <meta property="og:description" content="普里姆（prim）算法 一、定义二、思路三、代码实现四、代码解析 一、定义 普里姆算法是一种构造性算法。假设G = (V， E)是一个具有n个顶点的带权连通图，T = (U，TE)是最小生成树，其中U是T的顶点集，TE是T的边集，则由G构造从起始点v出法的最小生成树T的步骤如下：
初始化U = { v }，以v到其他顶点的所有边为侯选边。重复以下步骤(n - 1)次，使得其他(n - 1)个顶点被加入U中。 （1）. 从候选边中挑选权值最小的边加入TE，设该边在V—U中的顶点是k，将k加入U中。
（2）. 考察当前V—U中的所有顶点j，修改侯选边，若(k，j)的权值小于原来和顶点关联的侯选边，则用(k，j)取代后者作为侯选边。
二、思路 我们可以将定义理解为：将图的所有顶点分为两类，A类（保存已经查找过的顶点），B类（保存未查找过的顶点），从任一顶点开始，并将其从B类移至A类，然后开始寻找B类中（的顶点）到A类顶点之间权值最小的顶点，将其从B类中移至A类，重复上述操作，直至B类中没有顶点。所走过的顶点和边就是该连通图的最小生成树。
由此图为例：
初始状态
A类 = { }
B类 = { 0, 1, 2, 3, 4, 5, 6 }
假设从顶点2开始遍历
A类 = { 2 }
B类 = { 0, 1, 3, 4, 5, 6 }
遍历第一次后
A类 = {2, 3 }
B类 = { 0, 1, 4, 5, 6 }">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-11-24T21:55:58+08:00">
    <meta property="article:modified_time" content="2022-11-24T21:55:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构 最小生成树 prim算法（普里姆算法）C语言实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>普里姆（prim）算法</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、定义</a></li><li><a href="#_10" rel="nofollow">二、思路</a></li><li><a href="#_48" rel="nofollow">三、代码实现</a></li><li><a href="#_95" rel="nofollow">四、代码解析</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、定义</h2> 
<p>普里姆算法是一种构造性算法。假设G = (V， E)是一个具有n个顶点的带权连通图，T = (U，TE)是最小生成树，其中U是T的顶点集，TE是T的边集，则由G构造从起始点v出法的最小生成树T的步骤如下：</p> 
<ol><li>初始化U = { v }，以v到其他顶点的所有边为侯选边。</li><li>重复以下步骤(n - 1)次，使得其他(n - 1)个顶点被加入U中。</li></ol> 
<p>（1）. 从候选边中挑选权值最小的边加入TE，设该边在V—U中的顶点是k，将k加入U中。<br> （2）. 考察当前V—U中的所有顶点j，修改侯选边，若(k，j)的权值小于原来和顶点关联的侯选边，则用(k，j)取代后者作为侯选边。</p> 
<h2><a id="_10"></a>二、思路</h2> 
<p>我们可以将定义理解为：将图的所有顶点分为两类，A类（保存已经查找过的顶点），B类（保存未查找过的顶点），从任一顶点开始，并将其从B类移至A类，<strong>然后开始寻找B类中（的顶点）到A类顶点之间权值最小的顶点，将其从B类中移至A类</strong>，重复上述操作，直至B类中没有顶点。所走过的顶点和边就是该连通图的最小生成树。</p> 
<p>由此图为例：<br> <img src="https://images2.imgbox.com/13/b7/DZfX7jIg_o.png" alt="一个带权连通图"><br> 初始状态</p> 
<blockquote> 
 <p>A类 = { }<br> B类 = { 0, 1, 2, 3, 4, 5, 6 }</p> 
</blockquote> 
<p>假设从顶点2开始遍历</p> 
<blockquote> 
 <p>A类 = { 2 }<br> B类 = { 0, 1, 3, 4, 5, 6 }</p> 
</blockquote> 
<p>遍历第一次后</p> 
<blockquote> 
 <p>A类 = {2, 3 }<br> B类 = { 0, 1, 4, 5, 6 }</p> 
</blockquote> 
<p>遍历第二次后</p> 
<blockquote> 
 <p>A类 = { 1, 2, 3 }<br> B类 = { 0, 4, 5, 6 }</p> 
</blockquote> 
<p>由此类推，直至B类中无顶点。</p> 
<blockquote> 
 <p>A类 = { 0, 1, 2, 3, 4, 5, 6 }<br> B类 = { }</p> 
</blockquote> 
<p>图型讲解如下：<br> 假设从顶点2开始遍历。<br> <img src="https://images2.imgbox.com/84/26/ChN1uQ0f_o.png" alt="在这里插入图片描述"><br> 寻找B类到A类顶点之间权值最小的顶点（在现有的两条边寻找权值最小的边）。（上图为顶点3）将其添加至A类顶点中。<br> <img src="https://images2.imgbox.com/bc/53/pq3SOWqK_o.png" alt="在这里插入图片描述"><br> 步骤同上。在现有的三条边（权值为12的边已经遍历过所以不计入）中寻找权值最小的边。（上图为顶点1）将其添加至A类中。<strong>大家注意在这里我们去掉了权值为18的边，这是因为从顶点1可以通过权值为14的边到达顶点6，从顶点3可以通过权值为18的边到达顶点6，根据定义我们要寻找顶点间权值最小的边，所以我们用权值为14的边替换权值为18的边。</strong><br> <img src="https://images2.imgbox.com/2a/b7/6p85V5o6_o.png" alt="在这里插入图片描述"><br> 步骤同上。在现有的三条边中寻找权值最小的边。（上图为顶点6）将其添加至A类。<strong>大家注意在这里增加顶点6，之后我们本应该可以获得一条从顶点6到顶点4权值为24的边，但是由于我们有从顶点3到顶点4的权值为22的边，所以根据定义，我们无需添加顶点6到顶点4权值为24的边</strong><br> <img src="https://images2.imgbox.com/cd/35/CjcN2vgv_o.png" alt="在这里插入图片描述"><br> 重复上述步骤。我们就可以通过prim算法得到最终的最小生成树。<br> <img src="https://images2.imgbox.com/70/3a/2TxsT9ny_o.png" alt="在这里插入图片描述"><br> 看完了讲解，接下来让我们看看prim算法的代码实现吧！</p> 
<h2><a id="_48"></a>三、代码实现</h2> 
<pre><code class="prism language-c">\<span class="token operator">*</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXV</span> <span class="token expression"><span class="token operator">&lt;</span>最大顶点数<span class="token operator">&gt;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INF</span> <span class="token expression"><span class="token number">32767</span>      </span><span class="token comment">//定义无穷大</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> no<span class="token punctuation">;</span>            <span class="token comment">//顶点的编号</span>
	InfoType info<span class="token punctuation">;</span>    <span class="token comment">//顶点的其他信息</span>
<span class="token punctuation">}</span>VertexType<span class="token punctuation">;</span>           <span class="token comment">//顶点的类型</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> edges<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//邻接矩阵数组</span>
	<span class="token keyword">int</span> n<span class="token punctuation">,</span> e<span class="token punctuation">;</span>                <span class="token comment">//顶点数，边数</span>
	VertexType vexs<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//存放顶点信息</span>
<span class="token punctuation">}</span>MGraph<span class="token punctuation">;</span>                   <span class="token comment">//完整的图邻接矩阵类型</span>
<span class="token operator">*</span>\
<span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span>MGraph g<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//传入一个邻接矩阵，和起始顶点</span>
    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> closest<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> min<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>          <span class="token comment">//给lowcost[]和closest[]置初值</span>
        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        closest<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    lowcost<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>           <span class="token comment">//找出n-1个顶点</span>
        min<span class="token operator">=</span>INF<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>     <span class="token comment">//在(V-U)中找出离U最近的顶点k</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                min<span class="token operator">=</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                k<span class="token operator">=</span>j<span class="token punctuation">;</span>            <span class="token comment">//k记录最近顶点的编号</span>
            <span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  边(%d,%d)权为:%d\n"</span><span class="token punctuation">,</span> closest<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>
        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">//标记k已经加入U</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    <span class="token comment">//对(V-U)中的顶点j进行调整</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                closest<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>    <span class="token comment">//修改数组lowcost和closest</span>
            <span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_95"></a>四、代码解析</h2> 
<p>初看代码相信很多人都是一头雾水，接下来就让我们对代码进行刨析。<br> 我们先将上述的带权连通图转化成邻接矩阵为后续讲解做准备。</p> 
<blockquote> 
 <p>{ 0 , 28, INF, INF, INF, 10, INF }<br> { 28, 0, 16, INF, INF, INF, 14 }<br> { INF, 16, 0, 12, INF, INF, INF}<br> { INF, INF, 12, 0, 22, INF, 18 }<br> { INF, INF, INF, 22, 0, 25, 24 }<br> { 10, INF, INF, INF, 25, 0, INF}<br> { INF, 14, INF, 18, 24, INF, 0}</p> 
</blockquote> 
<p>首先让我们一起看看这几句代码</p> 
<pre><code class="prism language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>          <span class="token comment">//给lowcost[]和closest[]置初值</span>
	lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	closest<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这三行代码时我们整个算法的开始。那么这三行代码是在表达什么意思呢？<br> 假设我们从顶底2开始，那么循环结束两个数组的值为</p> 
<blockquote> 
 <p>lowcost[] = { INF, 16, 0, 12, INF, INF, INF }<br> closest[] = { 2, 2, 2, 2, 2, 2, 2}</p> 
</blockquote> 
<p>我们尝试着这样去理解一下。<br> lowcost数组中的每一个元素，我们将它理解为，A类元素到B类元素的最短距离。（无穷大表示目前还不能通过A类元素到达B类元素，0表示已经遍历过该顶点）<br> 例如：</p> 
<ul><li>lowcost数组的第一个元素为INF，表示顶点2没有到达顶点0的路径。</li><li>lowcost数组的第二个元素为16，这表示顶点2到顶点1的路径为16。</li></ul> 
<p>那么肯定有人有一个疑问为什么这里说的都是顶点2到其他的顶点的路径，那么请大家看看下面这句话。</p> 
<p>closest数组中的每一个元素，我们将它理解为，lowcost数组中的边是哪一个顶点的邻边。或者也可以理解为A类元素暂且只有顶点为2的元素。</p> 
<ul><li>比如lowcost中第四个元素时权值为12的边，这条边是顶点2的临边。</li></ul> 
<p>那么为什么这样去做，请大家跟着我一起继续向下看。</p> 
<p>在分析了算法的开始之后，让我们看看接下来的几行代码</p> 
<pre><code class="prism language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>           <span class="token comment">//循环n-1次 找出n-1个顶点</span>
	min<span class="token operator">=</span>INF<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>     <span class="token comment">//在(V-U)中找出离U最近的顶点k</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	min<span class="token operator">=</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            k<span class="token operator">=</span>j<span class="token punctuation">;</span>            <span class="token comment">//k记录最近顶点的编号</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  边(%d,%d)权为:%d\n"</span><span class="token punctuation">,</span> closest<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>
    lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">//标记k已经加入U</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    <span class="token comment">//对(V-U)中的顶点j进行调整</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    		lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        	closest<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>    <span class="token comment">//修改数组lowcost和closest</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接下来让我们来看看大的for循环中的第一个小循环。</p> 
<pre><code class="prism language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>     <span class="token comment">//在(V-U)中找出离U最近的顶点k</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	min<span class="token operator">=</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        k<span class="token operator">=</span>j<span class="token punctuation">;</span>            <span class="token comment">//k记录最近顶点的编号</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个循环的意思为找出现有边中权值最小的边。并用k记录该边所连接的顶点。<br> 那么在接下来输出（或其他操作）时我们就可以将这条边完整的输出出来。</p> 
<pre><code class="prism language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  边(%d,%d)权为:%d\n"</span><span class="token punctuation">,</span> closest<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>之后就到了整段代码的第二个核心。（那么什么是第一个核心，等我们一起看完整段代码后就会浮出水面）</p> 
<pre><code class="prism language-c">lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">//标记k已经加入U</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    <span class="token comment">//对(V-U)中的顶点j进行调整</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        closest<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>    <span class="token comment">//修改数组lowcost和closest</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>首先我们先将lowcost数组中最小边连接的顶点置0，表示该点已经加入A类。<br> 然后大家注意这个if判断语句中的条件。</p> 
<blockquote> 
 <p>g.edges[k][j] &lt; lowcost[j]</p> 
</blockquote> 
<p>如果新顶点的邻边比现有待选边的权值小，就将其替换。目的还是为了确保下一次能找到最小边。<br> 整段代码第一次执行结束后，让我们再来看看lowcost数组和closest的值。</p> 
<blockquote> 
 <p>lowcost[] = { INF, 16, 0, 0, 22, INF, 18 }<br> closest[] = { 2, 2, 2, 2, 3, 2, 3 }</p> 
</blockquote> 
<p>这样下来我们不仅将新的顶点添加了进来（lowcost数组中索引为3的顶点值为0），还将新顶点的临边添加进来，最后还保证了待选边的最小特征。<br> 好了，prim算法的讲解到此结束。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cde7c0c87e8b3fce31a97c152e2129d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言代码：玫瑰花</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8886136393ee0856f56750f308613ad6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">anaconda完全卸载方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>