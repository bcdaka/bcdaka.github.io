<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【云原生】Kubernetes----Ingress对外服务 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/23cfa0219c6143d0eadcff3f6f1e18d9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【云原生】Kubernetes----Ingress对外服务">
  <meta property="og:description" content="目录
引言
一、K8S对外方式
（一）NodePort
1.作用
2.弊端
3.示例
（二）externalIPs
1.作用
2.弊端
3.示例
（三）LoadBalancer
1.作用
2.弊端
（四）Ingress
二、Ingress的基本概念
（一）基本概念
（二）Ingress组成
1.ingress
2.ingress-controller
3.关系归纳
（三）Ingress的工作原理
（四）访问流程
三、配置Ingress规则
（一）ingress暴露服务方式
（二）方式二搭建
1.获取资源
1.1 获取配置文件
1.2 获取镜像资源
2.修改ClusterRole资源配置
3.修改nginx-ingress-controller配置
4.创建资源
4.1 创建ingress-controller
4.2 创建pod与service
5.创建ingress规则
6.客户端访问
（三）方式三搭建
1.清空环境
2.获取文件
3.创建代理资源
3.1 创建nginx-ingress-controller资源
3.2 创建service资源
4.创建访问资源
4.1 创建Deployment
4.2 创建service
4.3 创建Ingress规则
5.使用客户端进行访问
四、虚拟主机
（一）创建pod资源
（二）创建service资源
（三）创建ingress规则
（四）客户端访问
五、HTPPS代理
（一）获取SSL证书
（二）创建Kubernetes Secret
（三）创建pod资源
（四）创建service
（五）创建ingress规则
（六）客户端访问">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-05T17:46:43+08:00">
    <meta property="article:modified_time" content="2024-06-05T17:46:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【云原生】Kubernetes----Ingress对外服务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%BC%95%E8%A8%80" rel="nofollow">引言</a></p> 
<p id="%E4%B8%80%E3%80%81K8S%E5%AF%B9%E5%A4%96%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81K8S%E5%AF%B9%E5%A4%96%E6%96%B9%E5%BC%8F" rel="nofollow">一、K8S对外方式</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89NodePort-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89NodePort" rel="nofollow">（一）NodePort</a></p> 
<p id="1.%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.%E4%BD%9C%E7%94%A8" rel="nofollow">1.作用</a></p> 
<p id="2.%E5%BC%8A%E7%AB%AF-toc" style="margin-left:80px;"><a href="#2.%E5%BC%8A%E7%AB%AF" rel="nofollow">2.弊端</a></p> 
<p id="3.%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.%E7%A4%BA%E4%BE%8B" rel="nofollow">3.示例</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89externalIPs-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89externalIPs" rel="nofollow">（二）externalIPs</a></p> 
<p id="1.%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.%E4%BD%9C%E7%94%A8" rel="nofollow">1.作用</a></p> 
<p id="2.%E5%BC%8A%E7%AB%AF-toc" style="margin-left:80px;"><a href="#2.%E5%BC%8A%E7%AB%AF" rel="nofollow">2.弊端</a></p> 
<p id="3.%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.%E7%A4%BA%E4%BE%8B" rel="nofollow">3.示例</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89LoadBalancer-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89LoadBalancer" rel="nofollow">（三）LoadBalancer</a></p> 
<p id="1.%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.%E4%BD%9C%E7%94%A8" rel="nofollow">1.作用</a></p> 
<p id="2.%E5%BC%8A%E7%AB%AF-toc" style="margin-left:80px;"><a href="#2.%E5%BC%8A%E7%AB%AF" rel="nofollow">2.弊端</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89Ingress-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89Ingress" rel="nofollow">（四）Ingress</a></p> 
<p id="%E4%BA%8C%E3%80%81Ingress%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Ingress%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">二、Ingress的基本概念</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">（一）基本概念</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89Ingress%E7%BB%84%E6%88%90-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89Ingress%E7%BB%84%E6%88%90" rel="nofollow">（二）Ingress组成</a></p> 
<p id="1.ingress-toc" style="margin-left:80px;"><a href="#1.ingress" rel="nofollow">1.ingress</a></p> 
<p id="2.ingress-controller-toc" style="margin-left:80px;"><a href="#2.ingress-controller" rel="nofollow">2.ingress-controller</a></p> 
<p id="3.%E5%85%B3%E7%B3%BB%E5%BD%92%E7%BA%B3-toc" style="margin-left:80px;"><a href="#3.%E5%85%B3%E7%B3%BB%E5%BD%92%E7%BA%B3" rel="nofollow">3.关系归纳</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89Ingress%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89Ingress%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">（三）Ingress的工作原理</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B" rel="nofollow">（四）访问流程</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AEIngress%E8%A7%84%E5%88%99-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AEIngress%E8%A7%84%E5%88%99" rel="nofollow">三、配置Ingress规则</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89ingress%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89ingress%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E6%96%B9%E5%BC%8F" rel="nofollow">（一）ingress暴露服务方式</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E6%96%B9%E5%BC%8F%E4%BA%8C%E6%90%AD%E5%BB%BA-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%96%B9%E5%BC%8F%E4%BA%8C%E6%90%AD%E5%BB%BA" rel="nofollow">（二）方式二搭建</a></p> 
<p id="1.%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;"><a href="#1.%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90" rel="nofollow">1.获取资源</a></p> 
<p id="1.1%20%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:120px;"><a href="#1.1%20%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">1.1 获取配置文件</a></p> 
<p id="1.2%20%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F%E8%B5%84%E6%BA%90-toc" style="margin-left:120px;"><a href="#1.2%20%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F%E8%B5%84%E6%BA%90" rel="nofollow">1.2 获取镜像资源</a></p> 
<p id="2.%E4%BF%AE%E6%94%B9ClusterRole%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.%E4%BF%AE%E6%94%B9ClusterRole%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE" rel="nofollow">2.修改ClusterRole资源配置</a></p> 
<p id="3.%E4%BF%AE%E6%94%B9nginx-ingress-controller%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#3.%E4%BF%AE%E6%94%B9nginx-ingress-controller%E9%85%8D%E7%BD%AE" rel="nofollow">3.修改nginx-ingress-controller配置</a></p> 
<p id="4.%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;"><a href="#4.%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90" rel="nofollow">4.创建资源</a></p> 
<p id="4.1%20%E5%88%9B%E5%BB%BAingress-controller-toc" style="margin-left:120px;"><a href="#4.1%20%E5%88%9B%E5%BB%BAingress-controller" rel="nofollow">4.1 创建ingress-controller</a></p> 
<p id="4.2%20%E5%88%9B%E5%BB%BApod%E4%B8%8Eservice-toc" style="margin-left:120px;"><a href="#4.2%20%E5%88%9B%E5%BB%BApod%E4%B8%8Eservice" rel="nofollow">4.2 创建pod与service</a></p> 
<p id="5.%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#5.%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99" rel="nofollow">5.创建ingress规则</a></p> 
<p id="6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE" rel="nofollow">6.客户端访问</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%B9%E5%BC%8F%E4%B8%89%E6%90%AD%E5%BB%BA-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%B9%E5%BC%8F%E4%B8%89%E6%90%AD%E5%BB%BA" rel="nofollow">（三）方式三搭建</a></p> 
<p id="1.%E6%B8%85%E7%A9%BA%E7%8E%AF%E5%A2%83-toc" style="margin-left:80px;"><a href="#1.%E6%B8%85%E7%A9%BA%E7%8E%AF%E5%A2%83" rel="nofollow">1.清空环境</a></p> 
<p id="2.%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6" rel="nofollow">2.获取文件</a></p> 
<p id="3.%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;"><a href="#3.%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E8%B5%84%E6%BA%90" rel="nofollow">3.创建代理资源</a></p> 
<p id="3.1%20%E5%88%9B%E5%BB%BAnginx-ingress-controller%E8%B5%84%E6%BA%90-toc" style="margin-left:120px;"><a href="#3.1%20%E5%88%9B%E5%BB%BAnginx-ingress-controller%E8%B5%84%E6%BA%90" rel="nofollow">3.1 创建nginx-ingress-controller资源</a></p> 
<p id="3.2%20%E5%88%9B%E5%BB%BAservice%E8%B5%84%E6%BA%90-toc" style="margin-left:120px;"><a href="#3.2%20%E5%88%9B%E5%BB%BAservice%E8%B5%84%E6%BA%90" rel="nofollow">3.2 创建service资源</a></p> 
<p id="4.%E5%88%9B%E5%BB%BA%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;"><a href="#4.%E5%88%9B%E5%BB%BA%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90" rel="nofollow">4.创建访问资源</a></p> 
<p id="4.1%20%E5%88%9B%E5%BB%BADeployment-toc" style="margin-left:120px;"><a href="#4.1%20%E5%88%9B%E5%BB%BADeployment" rel="nofollow">4.1 创建Deployment</a></p> 
<p id="4.2%20%E5%88%9B%E5%BB%BAservice-toc" style="margin-left:120px;"><a href="#4.2%20%E5%88%9B%E5%BB%BAservice" rel="nofollow">4.2 创建service</a></p> 
<p id="4.3%20%E5%88%9B%E5%BB%BAIngress%E8%A7%84%E5%88%99-toc" style="margin-left:120px;"><a href="#4.3%20%E5%88%9B%E5%BB%BAIngress%E8%A7%84%E5%88%99" rel="nofollow">4.3 创建Ingress规则</a></p> 
<p id="5.%E4%BD%BF%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#5.%E4%BD%BF%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE" rel="nofollow">5.使用客户端进行访问</a></p> 
<p id="%E5%9B%9B%E3%80%81%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA" rel="nofollow">四、虚拟主机</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BApod%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BApod%E8%B5%84%E6%BA%90" rel="nofollow">（一）创建pod资源</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BAservice%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BAservice%E8%B5%84%E6%BA%90" rel="nofollow">（二）创建service资源</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99" rel="nofollow">（三）创建ingress规则</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE" rel="nofollow">（四）客户端访问</a></p> 
<p id="%E4%BA%94%E3%80%81HTPPS%E4%BB%A3%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81HTPPS%E4%BB%A3%E7%90%86" rel="nofollow">五、HTPPS代理</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E8%8E%B7%E5%8F%96SSL%E8%AF%81%E4%B9%A6-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E8%8E%B7%E5%8F%96SSL%E8%AF%81%E4%B9%A6" rel="nofollow">（一）获取SSL证书</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BAKubernetes%20Secret-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BAKubernetes%20Secret" rel="nofollow">（二）创建Kubernetes Secret</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BApod%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BApod%E8%B5%84%E6%BA%90" rel="nofollow">（三）创建pod资源</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%9B%E5%BB%BAservice-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%9B%E5%BB%BAservice" rel="nofollow">（四）创建service</a></p> 
<p id="%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99" rel="nofollow">（五）创建ingress规则</a></p> 
<p id="%EF%BC%88%E5%85%AD%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E5%85%AD%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE" rel="nofollow">（六）客户端访问</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%AE%9E%E7%8E%B0BasicAuth-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%AE%9E%E7%8E%B0BasicAuth" rel="nofollow">六、实现BasicAuth</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6" rel="nofollow">（一）创建认证文件</a></p> 
<p id="1.%E4%B8%8B%E8%BD%BDhtpasswd%E5%B7%A5%E5%85%B7-toc" style="margin-left:80px;"><a href="#1.%E4%B8%8B%E8%BD%BDhtpasswd%E5%B7%A5%E5%85%B7" rel="nofollow">1.下载htpasswd工具</a></p> 
<p id="2.%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6" rel="nofollow">2.创建认证文件</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BASecret-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BASecret" rel="nofollow">（二）创建Secret</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BApod%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BApod%E8%B5%84%E6%BA%90" rel="nofollow">（三）创建pod资源</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%9B%E5%BB%BAservice-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%9B%E5%BB%BAservice" rel="nofollow">（四）创建service</a></p> 
<p id="%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%B5%84%E6%BA%90" rel="nofollow">（五）创建ingress资源</a></p> 
<p id="%E4%B8%83%E3%80%81Nginx%E9%87%8D%E5%86%99-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81Nginx%E9%87%8D%E5%86%99" rel="nofollow">七、Nginx重写</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>引言</h2> 
<p>随着Kubernetes在云原生应用领域的广泛应用，如何高效地管理集群的外部流量成为了许多开发者和管理员面临的挑战。在Kubernetes中，Ingress提供了一个标准化的方式来管理外部流量到集群内部服务的路由，从而简化了流量管理的复杂性。本文将介绍Ingress的基本概念、工作原理以及如何使用Ingress来优化你的Kubernetes集群的流量路由</p> 
<h2 id="%E4%B8%80%E3%80%81K8S%E5%AF%B9%E5%A4%96%E6%96%B9%E5%BC%8F">一、K8S对外方式</h2> 
<p>在Kubernetes（k8s）中，使外部应用能够访问集群内的服务主要有四种方式</p> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89NodePort">（一）NodePort</h3> 
<h4 id="1.%E4%BD%9C%E7%94%A8">1.作用</h4> 
<p>NodePort服务类型将服务暴露在每个Kubernetes节点的相同端口上。外部用户可以通过访问任何节点的IP地址和该端口来访问服务。</p> 
<h4 id="2.%E5%BC%8A%E7%AB%AF">2.弊端</h4> 
<p>NodePort背后就是Kube-Proxy，Kube-Proxy是沟通service网络、Pod网络和节点网络的桥梁。<br> 测试环境使用还行，当有几十上百的服务在集群中运行时，NodePort的端口管理就是个灾难。因为每个端口只能是一种服务，端口范围只能是 30000-32767</p> 
<h4 id="3.%E7%A4%BA%E4%BE%8B">3.示例</h4> 
<pre><code class="language-cs">[root@master01 pod]#vim deployment.yaml 
[root@master01 pod]#cat deployment.yaml 
apiVersion: apps/v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx  
spec:
  containers:
  - name: nginx
    image: nginx:1.18.0
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Service             #创建service
metadata:
  name: nginx-svc
  labels:
    app: nginx
spec:
  type: NodePort          #type类型为NodePort，用于对外提供服务
  ports:
  - port: 80
    targetPort: 80 
  selector:
    app: nginx
</code></pre> 
<p>执行完yaml文件之后，查看地址与映射端口</p> 
<pre><code class="language-cs">[root@master01 pod]#kubectl apply -f pod.yaml 
pod/nginx-pod created
service/nginx-svc created
[root@master01 pod]#
[root@master01 pod]#kubectl get pod -owide
NAME        READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES
nginx-pod   1/1     Running   0          14s   10.244.2.3   node02   &lt;none&gt;           &lt;none&gt;
[root@master01 pod]#kubectl get svc
NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        17d
nginx-svc    NodePort    10.96.131.227   &lt;none&gt;        80:30425/TCP   31s
#使用客户端访问任意节点的30425端口


</code></pre> 
<p>使用客户端进行访问</p> 
<pre><code class="language-cs">[root@nfs ~]#curl 192.168.83.30:30425  -I
HTTP/1.1 200 OK
Server: nginx/1.18.0
Date: Mon, 03 Jun 2024 06:55:53 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 21 Apr 2020 14:09:01 GMT
Connection: keep-alive
ETag: "5e9efe7d-264"
Accept-Ranges: bytes</code></pre> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89externalIPs">（二）externalIPs</h3> 
<h4>1.作用</h4> 
<p>Kubernetes中的externalIPs允许将一个或多个外部IP地址直接绑定到一个Kubernetes服务上，从而可以通过这些外部IP地址直接访问该服务</p> 
<h4>2.弊端</h4> 
<p>当使用externalIPs时，外部流量将直接通过指定的IP地址进入集群，这可能增加了集群的安全风险。攻击者可能会利用这些外部IP地址对集群进行攻击，如拒绝服务攻击（DoS）、中间人攻击（MITM）等。<strong>不支持负载均衡和故障转移</strong></p> 
<h4>3.示例</h4> 
<pre><code class="language-cs">[root@master01 pod]#cat pod02.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod02
  labels:
    app: nginx  
spec:
  nodeName: node02        
#pod需要使用节点亲和，指定pod建立在externalIPs指定nodeIP地址之外
#同样IP可能导致网络数据包的路由变得混乱，使得Kubernetes集群内外的网络无法正确区分和处理流量
#如果使用deployment建立的pod，则externalIPs只会非本节点的pod实例
  containers:
  - name: nginx
    image: nginx:1.18.0
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-svc02
  labels:
    app: nginx
spec: 
  externalIPs:          #指定pod绑定地址
  - 192.168.83.40       #绑定到node01节点的IP上
  ports:
  - port: 80
    targetPort: 80 
  selector:
    app: nginx</code></pre> 
<p>创建后，查看服务</p> 
<pre><code class="language-cs">[root@master01 pod]#kubectl apply -f pod02.yaml 
pod/nginx-pod02 created
service/nginx-svc02 created
[root@master01 pod]#kubectl get pod nginx-pod02
[root@master01 pod]#kubectl get pod nginx-pod02 -owide
NAME          READY   STATUS    RESTARTS   AGE     IP          NODE     NOMINATED NODE   READINESS GATES
nginx-pod02   1/1     Running   0          5s   10.244.2.4     node02   &lt;none&gt;           &lt;none&gt;
[root@master01 pod]#kubectl get svc nginx-svc02 
NAME          TYPE        CLUSTER-IP     EXTERNAL-IP     PORT(S)   AGE
nginx-svc02   ClusterIP   10.96.42.161   192.168.83.40   80/TCP    14s</code></pre> 
<p>客户端直接访问节点即可</p> 
<pre><code class="language-cs">[root@nfs ~]#curl 192.168.83.40  -I
HTTP/1.1 200 OK
Server: nginx/1.18.0
Date: Mon, 03 Jun 2024 07:08:42 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 21 Apr 2020 14:09:01 GMT
Connection: keep-alive
ETag: "5e9efe7d-264"
Accept-Ranges: bytes</code></pre> 
<h3 id="%EF%BC%88%E4%B8%89%EF%BC%89LoadBalancer">（三）<strong>LoadBalancer</strong></h3> 
<h4><strong>1.作用</strong></h4> 
<p>LoadBalancer服务类型允许外部负载均衡器将流量路由到Kubernetes集群中的服务。</p> 
<p>这种方式通常用于云服务提供商（如AWS、Azure、GCP等），它们可以自动创建一个负载均衡器并为其分配一个外部IP地址。</p> 
<h4>2.弊端</h4> 
<p>这种用法仅用于在公有云服务提供商的云平台上设置 Service 的场景。受限于云平台，且通常在云平台部署LoadBalancer还需要额外的费用</p> 
<h3 id="%EF%BC%88%E5%9B%9B%EF%BC%89Ingress">（四）Ingress</h3> 
<ul><li>Ingress是Kubernetes中的一个API对象，它管理外部访问到集群内服务的HTTP和HTTPS路由规则。</li><li>通常与Ingress Controller一起使用，Ingress Controller是一个反向代理服务器，负责实现Ingress定义的路由规则。</li><li>Ingress可以基于域名、路径或其他HTTP请求属性进行流量路由。</li><li>配置Ingress需要创建Ingress对象并定义路由规则，同时还需要部署Ingress Controller。</li><li>Ingress提供了比LoadBalancer更高级的路由和流量管理功能。</li></ul> 
<h2 id="%E4%BA%8C%E3%80%81Ingress%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">二、Ingress的基本概念</h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">（一）基本概念</h3> 
<p>在Kubernetes中，Ingress是一个API对象，它用于定义集群外部访问内部服务的规则。通过Ingress，可以配置基于主机名、路径等条件的路由规则，将外部流量转发到集群内的一个或者多个service。Ingress提供了一种统一的、声明式的方式来管理外部流量，使得流量路由更加灵活和可配置。</p> 
<p>Ingress资源本身不会进行任何网络流量的路由，它依赖于Ingress控制器（如Nginx Ingress Controller、HAProxy Ingress Controller、Traefik等）来根据Ingress资源中定义的规则进行实际的路由</p> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89Ingress%E7%BB%84%E6%88%90" style="background-color:transparent;">（二）Ingress组成</h3> 
<h4 id="1.ingress">1.ingress</h4> 
<blockquote> 
 <ul><li><strong>定义</strong>：Ingress是一个Kubernetes API对象，通常使用YAML文件进行配置。它主要的作用是定义请求如何转发到集群内部服务的规则。</li><li><strong>功能</strong>：Ingress提供了负载均衡、SSL和基于名称的虚拟托管。通过Ingress，可以定义服务外部可访问的URL、负载均衡流量、SSL/TLS配置，以及基于名称的虚拟主机。</li><li><strong>特点</strong>：Ingress可以被视为一种配置模板，用于描述外部访问集群内部服务的方式。它定义了集群外部流量如何进入集群内各个服务的路由规则，但它本身无法直接实现这些路由。</li></ul> 
</blockquote> 
<h4 id="2.ingress-controller">2.ingress-controller</h4> 
<blockquote> 
 <ul><li><strong>定义</strong>：Ingress Controller是具体实现Ingress规则的程序。它与Kubernetes API交互，动态地感知集群中Ingress规则的变化，并按照这些规则生成相应的配置文件（例如Nginx的配置文件）。</li><li><strong>功能</strong>：Ingress Controller负责处理实际的流量转发工作，确保外部请求能够正确地路由到集群内部的Service。它实现了反向代理及负载均衡的功能，确保外部请求能够高效地路由到集群内部的服务。</li><li><strong>特点</strong>：Ingress Controller监听Ingress资源对象的变更，并根据Ingress规则进行配置。通常，Ingress Controller通过负载均衡器（如Nginx、Traefik等）来实现其功能。</li></ul> 
 <p>ingress-controller并不是k8s自带的组件，实际上ingress-controller只是一个统称，用户可以选择不同的ingress-controller实现</p> 
 <p>目前，由k8s维护的ingress-controller只有google云的GCE与ingress-nginx两个，其他还有很多第三方维护的ingress-controller，具体可以参考官方文档。</p> 
 <p>但是不管哪一种ingress-controller，实现的机制都大同小异，只是在具体配置上有差异。</p> 
 <p>一般来说，ingress-controller的形式都是一个pod，里面跑着daemon程序和反向代理程序。daemon负责不断监控集群的变化，根据 ingress对象生成配置并应用新配置到反向代理</p> 
 <p>比如ingress-nginx就是动态生成nginx配置，动态更新upstream，并在需要的时候reload程序应用新配置。为了方便，后面的例子都以k8s官方维护的ingress-nginx为例。</p> 
</blockquote> 
<h4 id="3.%E5%85%B3%E7%B3%BB%E5%BD%92%E7%BA%B3">3.关系归纳</h4> 
<blockquote> 
 <ul><li>Ingress定义了请求转发的规则，这些规则描述了外部流量如何进入集群内的各个服务。</li><li>Ingress Controller负责实现这些规则，并与Kubernetes API交互，动态地感知并应用Ingress规则的变化。</li><li>要使Ingress资源生效，集群中必须有一个正在运行的Ingress Controller来读取这些规则并相应地进行流量转发。</li></ul> 
 <p><strong>总结：</strong>ingress-controller才是负责具体转发的组件，通过各种方式将它暴露在集群入口，外部对集群的请求流量会先到 ingress-controller， 而ingress对象是用来告诉ingress-controller该如何转发请求，比如哪些域名、哪些URL要转发到哪些service等等</p> 
</blockquote> 
<h3 id="%EF%BC%88%E4%B8%89%EF%BC%89Ingress%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">（三）Ingress的工作原理</h3> 
<p>Ingress的工作原理可以简单概括为以下几个步骤</p> 
<p><strong>监听Ingress对象</strong>：Ingress Controller通过Kubernetes API服务器监听Ingress对象的变化。当新的Ingress对象被创建、更新或删除时，Ingress Controller能够感知到这些变化。</p> 
<p><strong>解析Ingress规则</strong>：Ingress Controller解析Ingress对象中定义的规则。这些规则包括主机名、路径、后端服务等信息，用于确定如何将流量路由到集群内的不同服务。</p> 
<p><strong>生成配置</strong>：Ingress Controller将解析后的规则转化为特定负载均衡器（如Nginx、HAProxy等）可以理解的配置。这些配置通常包括反向代理设置、负载均衡策略、SSL/TLS配置等。再写到nginx-ingress-controller的pod里，这个ingress-controller的pod里运行着一个Nginx服务，控制器会把生成的 nginx配置写入 /etc/nginx.conf文件中</p> 
<p><strong>动态更新</strong>：Ingress Controller能够实时响应Ingress对象的变化，并动态更新其配置。这意味着当Ingress规则发生变化时，无需重启Ingress Controller或整个集群，流量路由将自动更新以适应新的规则。</p> 
<h3 id="%EF%BC%88%E5%9B%9B%EF%BC%89%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B">（四）访问流程</h3> 
<p><img alt="" height="596" src="https://images2.imgbox.com/63/67/MDjGNpa8_o.png" width="1200"></p> 
<blockquote> 
 <p>1.客户端访问域名，通过DNS解析到Ingress-confoller所在的节点</p> 
 <p>2.同时客户端向Ingress-confoller所在的节点发送HTTP/HTTPS请求</p> 
 <p>3.Ingress-confoller通过Ingress的配置信息(URL、域名等)，确定将请求转发到哪一个service，而后根据service关联的pod地址，决定Ingress-confoller将请求转发到pod当中。</p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AEIngress%E8%A7%84%E5%88%99">三、配置Ingress规则</h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89ingress%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E6%96%B9%E5%BC%8F">（一）ingress暴露服务方式</h3> 
<p>ingress 暴露服务的方式有以下三种</p> 
<p><strong>方式一：Deployment+LoadBalancer 模式的 Service</strong></p> 
<blockquote> 
 <p>这是公有云环境中非常常见的方式。在Kubernetes集群中，可以使用Deployment来部署Ingress Controller的Pod，并创建一个类型为LoadBalancer的Service来将Pod暴露到外部。在公有云环境中，当创建LoadBalancer类型的Service时，云提供商通常会为你自动创建一个负载均衡器（例如AWS的ELB，Azure的LB等），并且通常还会为你分配一个公网IP地址。你只需要将你的域名解析到这个公网IP地址，就可以通过Ingress来访问你的服务了</p> 
 <p></p> 
 <p><strong>优点</strong>：</p> 
 <ol><li><strong>自动化与便捷性</strong>：在公有云环境中，创建LoadBalancer类型的Service会自动为你创建负载均衡器，并分配公网IP，简化了配置过程。</li><li><strong>高可用性</strong>：负载均衡器通常具有容错和故障转移的能力，保证服务的稳定性。</li><li><strong>易于扩展</strong>：可以根据需求动态调整LoadBalancer的配置，如增加后端节点等。</li></ol> 
 <p><strong>缺点</strong>：</p> 
 <ol><li><strong>成本</strong>：在公有云环境中，使用LoadBalancer通常需要支付额外的费用。</li><li><strong>环境限制</strong>：这种方式主要适用于公有云环境，对于自建Kubernetes集群或者私有云环境可能不适用</li></ol> 
</blockquote> 
<p><strong>方式二：DaemonSet+HostNetwork+nodeSelector</strong></p> 
<p><img alt="" height="537" src="https://images2.imgbox.com/7f/8c/v3BQ8JjB_o.png" width="1200"></p> 
<blockquote> 
 <p>这种方式下，Ingress Controller以DaemonSet的方式部署，通过nodeSelector选择特定的节点运行。同时，使用HostNetwork将Ingress Controller的Pod与宿主机的网络打通，直接使用宿主机的80/443端口来提供服务。这样，Ingress Controller所在的节点就起到了边缘节点的作用，可以直接接受外部请求，并将请求转发到集群内的服务。这种方式的优点是请求链路简单，性能较好。但是，由于Ingress Controller直接占用了宿主机的端口，所以一个节点上通常只能运行一个Ingress Controller的Pod。</p> 
 <p></p> 
 <p><strong>优点</strong>：</p> 
 <ol><li><strong>性能优越</strong>：由于直接使用宿主机的网络和端口，请求链路简单，性能较好。</li><li><strong>配置简单</strong>：通过DaemonSet和nodeSelector可以很方便地将Ingress Controller部署到指定的节点上。</li><li><strong>适合大并发环境</strong>：对于需要处理大量并发请求的生产环境，这种方式具有更好的性能表现。</li></ol> 
 <p><strong>缺点</strong>：</p> 
 <ol><li><strong>资源限制</strong>：由于Ingress Controller直接占用了宿主机的端口，因此一个节点上通常只能运行一个Ingress Controller的Pod。</li><li><strong>安全性</strong>：由于Ingress Controller直接暴露在公网上，需要特别注意安全性问题，如防止DDoS攻击等。</li><li><strong>可移植性差</strong>：使用HostNetwork和特定节点的方式使得Ingress Controller的部署与特定环境紧密相关，不利于跨环境部署和迁移。</li></ol> 
</blockquote> 
<p><strong>方式三：Deployment+NodePort模式的Service</strong></p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/7b/4e/syYxX2TX_o.png" width="1200"></p> 
<blockquote> 
 <p>在这种方式下，Ingress Controller仍然以Deployment的方式部署，但是关联的Service的类型是NodePort。NodePort类型的Service会将Pod的端口映射到集群中每个节点的特定端口上。然后，你可以通过任意节点的IP地址和该节点上的映射端口来访问Ingress Controller。由于NodePort映射的端口是随机选择的，因此通常还需要在集群外部再部署一个负载均衡器来将流量分发到各个节点上。这种方式适用于节点IP地址相对固定的环境，但需要注意的是，由于NodePort类型的Service在节点之间进行了NAT转发，因此在请求量很大时可能会对性能产生一定的影响。</p> 
 <p></p> 
 <p><strong>优点</strong>：</p> 
 <ol><li><strong>灵活性</strong>：NodePort类型的Service可以灵活地将Pod的端口映射到集群中每个节点的特定端口上，便于外部访问。</li><li><strong>适用于固定IP环境</strong>：在节点IP地址相对固定的环境中，这种方式可以很方便地暴露服务。</li></ol> 
 <p><strong>缺点</strong>：</p> 
 <ol><li><strong>性能损耗</strong>：由于NodePort类型的Service在节点之间进行了NAT转发，因此在请求量很大时可能会对性能产生一定的影响。</li><li><strong>需要额外配置</strong>：通常需要在集群外部再部署一个负载均衡器来将流量分发到各个节点上，增加了配置的复杂性。</li><li><strong>端口管理</strong>：由于NodePort映射的端口是随机选择的，可能会与现有应用或服务产生冲突，需要进行端口管理。</li></ol> 
</blockquote> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E6%96%B9%E5%BC%8F%E4%BA%8C%E6%90%AD%E5%BB%BA">（二）方式二搭建</h3> 
<p><span style="color:#fe2c24;"><strong>DaemonSet+HostNetwork+nodeSelector</strong></span></p> 
<h4 id="1.%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90">1.获取资源</h4> 
<h5 id="1.1%20%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1.1 获取配置文件</h5> 
<blockquote> 
 <p>官方下载地址<br> https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml</p> 
 <p>官方无法下载的话，可用国内的 gitee</p> 
 <p>https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/mandatory.yaml</p> 
</blockquote> 
<pre><code class="language-cs">[root@master01 ingress]#wget https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/mandatory.yaml
--2024-06-03 16:40:40--  https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/mandatory.yaml
正在解析主机 gitee.com (gitee.com)... 180.76.198.77
正在连接 gitee.com (gitee.com)|180.76.198.77|:443... 已连接。
已发出 HTTP 请求，正在等待回应... 200 OK
长度：6635 (6.5K) [text/plain]
正在保存至: “mandatory.yaml”

100%[============================================================================&gt;] 6,635       --.-K/s 用时 0s      

2024-06-03 16:40:41 (735 MB/s) - 已保存 “mandatory.yaml” [6635/6635])
[root@master01 ingress]#ls
mandatory.yaml
[root@master01 ingress]#wc -l mandatory.yaml 
293 mandatory.yaml
</code></pre> 
<h5 id="1.2%20%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F%E8%B5%84%E6%BA%90">1.2 获取镜像资源</h5> 
<p>事先准备好镜像，防止执行yaml文件过程中下载镜像失败，导致无法进入工作状态</p> 
<pre><code class="language-cs">//在node01节点上下载
[root@node01 ~]#docker pull quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0
0.30.0: Pulling from kubernetes-ingress-controller/nginx-ingress-controller
......


//在node02节点上下载
[root@node02 ~]#docker pull quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0
0.30.0: Pulling from kubernetes-ingress-controller/nginx-ingress-controller
......</code></pre> 
<h4 id="2.%E4%BF%AE%E6%94%B9ClusterRole%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE">2.修改ClusterRole资源配置</h4> 
<pre><code class="language-cs">[root@master01 ingress]#vim mandatory.yaml
......
 91   - apiGroups:
 92       - "extensions"
 93       - "networking.k8s.io"    #0.25版本以前，需要添加此段
 94     resources:
 95       - ingresses
 96     verbs:
 97       - get
 98       - list
 99       - watch
100   - apiGroups:
101       - "extensions"
102       - "networking.k8s.io"     #0.25版本以前，需要添加此段
103     resources:
104       - ingresses/status
105     verbs:
106       - update
......
---------------------------------------------------------------   
ClusterRole的规则部分，用于定义哪些API资源可以被特定的用户或用户组访问，以及可以进行哪些操作
91-99行：定义第一个规则组：
apiGroups: 定义了资源所属的API组。这里指定了两个API组："extensions" 和 "networking.k8s.io"
resources: 定义具体的资源类型，允许对Ingress资源（用于HTTP/HTTPS路由）进行操作
verbs：定义了可以对资源进行的操作。get（获取资源信息）、list（列出所有资源）和watch（监视资源变化）

100-106行：定义第二个规则组
ingresses/status：允许对Ingress资源的状态进行操作
verbs: update，允许更新

在Kubernetes1.18及以后的版本中，extensions/v1beta1 Ingress已经被废弃，并在Kubernetes 1.22版本中完全移除。
Kubernetes集群版本是1.18或更高，使用networking.k8s.io/v1 API组，并且通常不需要在Role或ClusterRole中包含extensions API组
</code></pre> 
<h4 id="3.%E4%BF%AE%E6%94%B9nginx-ingress-controller%E9%85%8D%E7%BD%AE">3.修改<strong>nginx-ingress-controller配置</strong></h4> 
<p><strong>指定 nginx-ingress-controller 运行在 node02 节点</strong></p> 
<p><strong>①添加node02节点标签</strong></p> 
<pre><code class="language-cs">[root@master01 ingress]#kubectl label nodes node02 china=zg
node/node02 labeled
#添加标签
[root@master01 ingress]#kubectl get nodes node02 --show-labels   #查看标签
NAME     STATUS   ROLES    AGE   VERSION    LABELS
node02   Ready    &lt;none&gt;   18d   v1.20.11   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,china=zg,kubernetes.io/arch=amd64,kubernetes.io/hostname=node02,kubernetes.io/os=linux</code></pre> 
<p><strong>②修改 Deployment 为 DaemonSet ，指定节点运行，并开启 hostNetwork 网络</strong></p> 
<pre><code class="language-cs">[root@master01 ingress]#vim mandatory.yaml
......
190 apiVersion: apps/v1
191 kind: DaemonSet                                
#修改资源类型为DaemonSet，需要在每个指定的节点上运行ingress-controller，标签选择时可以选择多个节点
192 metadata:
193   name: nginx-ingress-controller
194   namespace: ingress-nginx
195   labels:
196     app.kubernetes.io/name: ingress-nginx
197     app.kubernetes.io/part-of: ingress-nginx
198 spec:
199 #  replicas: 1      #注释或删除replicas
200   selector:
201     matchLabels:
.......
204   template:
......
212     spec:
213       # wait up to five minutes for the drain of connections
214       #terminationGracePeriodSeconds: 300    
#定义pod被强制杀死之前应该等待多长时间来优雅地关闭。此处不需要，注释掉
215       hostNetwork: true   #开启HostNetwork，使Pod与宿主机之前的网络建立隧道
216       serviceAccountName: nginx-ingress-serviceaccount
217       nodeSelector:
218         china: zg           #更换指定节点标签
219       containers:
220         - name: nginx-ingress-controller
221           image: quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0
......

</code></pre> 
<h4 id="4.%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90">4.创建资源</h4> 
<h5 id="4.1%20%E5%88%9B%E5%BB%BAingress-controller">4.1 创建ingress-controller</h5> 
<pre><code class="language-cs">[root@master01 ingress]#kubectl apply -f mandatory.yaml 
namespace/ingress-nginx created
configmap/nginx-configuration created
configmap/tcp-services created
configmap/udp-services created
........
[root@master01 ingress]#kubectl get pod -n ingress-nginx -owide
NAME                             READY   STATUS    RESTARTS   AGE    IP              NODE     NOMINATED NODE   READINESS GATES
nginx-ingress-controller-2n7f6   1/1     Running   0          144m   192.168.83.50   node02   &lt;none&gt;           &lt;none&gt;
</code></pre> 
<p><img alt="" height="717" src="https://images2.imgbox.com/68/a5/cxBG0vW4_o.png" width="1200"></p> 
<p>在node02节点过滤80端口</p> 
<pre><code class="language-cs">[root@node02 ~]#netstat -antulp |grep :80
tcp      0    0 0.0.0.0:80      0.0.0.0:*      LISTEN     62842/nginx: master 
tcp6     0    0 :::80           :::*           LISTEN     62842/nginx: master
-------------------------------------------------------------------------------
虽然80端口已经开启，但是使用客户端进行访问会出现404报错，因为它只是ingress-nginx在监听宿主机的80端口，本身不提供web服务


[root@node02 ~]#netstat -lntp | grep nginx
tcp    0    0 0.0.0.0:80            0.0.0.0:*       LISTEN    62842/nginx: master 
tcp    0    0 0.0.0.0:8181          0.0.0.0:*       LISTEN    62842/nginx: master 
tcp    0    0 0.0.0.0:443           0.0.0.0:*       LISTEN    62842/nginx: master 
tcp    0    0 127.0.0.1:10245       0.0.0.0:*       LISTEN    62787/nginx-ingress 
tcp    0    0 127.0.0.1:10246       0.0.0.0:*       LISTEN    62842/nginx: master 
tcp    0    0 127.0.0.1:10247       0.0.0.0:*       LISTEN    62842/nginx: master 
tcp6   0    0 :::10254              :::*            LISTEN    62787/nginx-ingress 
tcp6   0    0 :::80                 :::*            LISTEN    62842/nginx: master 
tcp6   0    0 :::8181               :::*            LISTEN    62842/nginx: master 
tcp6   0    0 :::443                :::*            LISTEN    62842/nginx: master
-----------------------------------------------------------------------------------
由于配置了hostnetwork，nginx已经在node主机本地监听80/443/8181端口。
其中8181是nginx-controller 默认配置的一个default backend（Ingress 资源没有匹配的 rule 对象时，流量就会被导向这个 default backend）。
这样，只要访问node主机有公网IP，就可以直接映射域名来对外网暴露服务了。
如果要nginx高可用的话，可以在多个node上部署，并在前面再搭建一套LVS+keepalived做负载均衡</code></pre> 
<h5 id="4.2%20%E5%88%9B%E5%BB%BApod%E4%B8%8Eservice">4.2 创建pod与service</h5> 
<p>此时需要在node02节点上创建一个pod</p> 
<pre><code class="language-cs">[root@master01 ingress]#vim pod.yaml 
[root@master01 ingress]#cat pod.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: nginx01-ingress
  labels:
    run: nginx-run
spec:
  nodeName: node02
  containers:
  - name: nginx
    image: nginx:1.20.2
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: in-ng-svc
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 80
  selector:
    run: nginx-run</code></pre> 
<p>创建完毕后，此时四层的服务已经设置完毕</p> 
<pre><code class="language-cs">[root@master01 ingress]#kubectl apply -f pod.yaml 
pod/nginx01-ingress created
service/in-ng-svc created
[root@master01 ingress]#kubectl get pod,svc -owide
NAME                  READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES
pod/nginx01-ingress   1/1     Running   0          12s   10.244.2.6   node02   &lt;none&gt;           &lt;none&gt;

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE   SELECTOR
service/in-ng-svc    NodePort    10.96.9.79   &lt;none&gt;        80:32169/TCP   12s   run=nginx-run
service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP        18d   &lt;none&gt;
[root@master01 ingress]#curl 10.96.9.79 -I
HTTP/1.1 200 OK
Server: nginx/1.20.2
Date: Mon, 03 Jun 2024 12:54:15 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 16 Nov 2021 14:44:02 GMT
Connection: keep-alive
ETag: "6193c3b2-264"
Accept-Ranges: bytes
[root@master01 ingress]#kubectl exec -it nginx01-ingress bash
root@nginx01-ingress:/# echo "this is ingress-nginx" &gt;/usr/share/nginx/html/index.html 
#自定义访问界面
root@nginx01-ingress:/# exit
exit
[root@master01 ingress]#curl 10.96.9.79
this is ingress-nginx
#自定义一个访问界面 
</code></pre> 
<h4 id="5.%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99">5.创建ingress规则</h4> 
<pre><code class="language-cs">[root@master01 ingress]#vim ingress.yaml
[root@master01 ingress]#cat ingress.yaml
apiVersion: networking.k8s.io/v1     #Kubernetes网络扩展API的版本1，它定义了Ingress资源。
kind: Ingress                        #定义了资源的类型
metadata:
  name: nginx-ingress
spec:
  rules:                             #定义Ingress规则，将HTTP/HTTPS请求路由到集群内的服务
  - host: www.ingress.com            #指定规则适用的主机名
    http:                            #定义了 HTTP 相关的配置。
      paths:                         #定义了 HTTP 请求的路径和它们应该被路由到的后端服务
      - path: /                      #指定了匹配的路径，这里使用了/，表示匹配所有路径
        pathType: Prefix             #定义了路径匹配的类型。Prefix表示路径是基于前缀的匹配
        backend:                     #定义了当请求匹配上述路径时应该被路由到的后端服务
          service:                   #定义了后端服务的配置，即指定转发带哪一个service
            name: in-ng-svc          #后端服务的名称，即service的名称
            port:                    #定义了后端服务的端口配置
              number: 80             #指定后端服务的端口号
---------------------------------------------------------------------------------
'host: www.ingress.com'
#当请求的Host头部为www.ingress.com时，这个规则会被应用。

'pathType类型'
#Exact
精确匹配。只有当请求的路径与定义的路径完全相同时才进行路由。
如果path定义为/exact-path，并且pathType设置为 Exact
那么只有当请求的URL路径也是/exact-path 时，该请求才会被路由到对应的后端服务。
类似于nginx配置文件中的location = /path

#Prefix
前缀匹配。如果请求的路径以定义的路径为前缀，则进行路由。
类似于nginx配置文件中的location ^~ /path

#ImplementationSpecific
实现特定匹配。此选项告诉Ingress控制器使用其实现特定的方式进行路径选择,这通常是默认值。
由于这是依赖于Ingress 控制器的实现方式，所以并没有统一的匹配规则。
不同的Ingress控制器可能会有不同的行为。
如果没有在Ingress资源中明确指定pathType，那么可能会默认使用ImplementationSpecific
使用ImplementationSpecific路径类型时，需要确保了解所使用Ingress控制器的具体实现和配置要求
由于ImplementationSpecific的行为可能因控制器而异，因此在切换控制器或更新控制器版本时，
需要仔细测试和验证路径匹配的行为是否仍然符合预期
</code></pre> 
<p>创建规则</p> 
<pre><code class="language-cs">[root@master01 ingress]#kubectl apply -f ingress.yaml 
ingress.networking.k8s.io/nginx-ingress created
[root@master01 ingress]#kubectl get ingress
NAME            CLASS    HOSTS             ADDRESS   PORTS   AGE
nginx-ingress   &lt;none&gt;   www.ingress.com             80      27s
</code></pre> 
<p>进入ingress规则进行查看</p> 
<pre><code class="language-cs">[root@master01 ingress]#kubectl exec -it nginx-ingress-controller-2n7f6 -n ingress-nginx bash
bash-5.0$ egrep -e 'server_name' -e 'start server' -e 'end server' /etc/nginx/nginx.conf 
	server_names_hash_max_size      1024;
	server_names_hash_bucket_size   64;
	# Reverse proxies can detect if a client provides a X-Request-ID header, and pass it on to the backend server.
	server_name_in_redirect off;
	## start server _
		server_name _ ;
	## end server _
	## start server www.ingress.com
		server_name www.ingress.com;
	## end server www.ingress.com;
#自动添加域名信息
#从start server www.ingress.com到end server www.ingress.com之间包含此域名用于反向代理的配置
</code></pre> 
<h4 id="6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE">6.客户端访问</h4> 
<pre><code class="language-cs">[root@nfs ~]#vim /etc/hosts
[root@nfs ~]#grep '192.168.83.50' /etc/hosts
192.168.83.50 node02 www.ingress.com
#添加客户端域名解析信息，使用域名进行访问，触发ingress规则
[root@nfs ~]#curl www.ingress.com
this is ingress-nginx
#自定义的web访问界面</code></pre> 
<h3 id="%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%B9%E5%BC%8F%E4%B8%89%E6%90%AD%E5%BB%BA">（三）方式三搭建</h3> 
<p><span style="color:#fe2c24;"><strong>Deployment+NodePort模式的Service</strong></span></p> 
<h4 id="1.%E6%B8%85%E7%A9%BA%E7%8E%AF%E5%A2%83"><strong><span style="color:#0d0016;">1.清空环境</span></strong></h4> 
<p><span style="color:#0d0016;"><strong>清空之前的操作信息防止pod运行冲突</strong></span></p> 
<pre><code class="language-cs">[root@master01 ingress]#kubectl delete -f pod.yaml 
pod "nginx01-ingress" deleted
service "in-ng-svc" deleted
[root@master01 ingress]#kubectl delete -f ingress.yaml 
ingress.networking.k8s.io "nginx-ingress" deleted
[root@master01 ingress]#kubectl delete -f mandatory.yaml </code></pre> 
<h4 id="2.%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6">2.获取文件</h4> 
<p>下载 nginx-ingress-controller 和 ingress-nginx 暴露端口配置文件，</p> 
<blockquote> 
 <p>官方下载地址</p> 
 <p>https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml</p> 
 <p>国内 gitee 资源地址 </p> 
 <p>https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/mandatory.yaml</p> 
 <p>https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml</p> 
</blockquote> 
<pre><code class="language-cs">[root@master01 data]#mkdir in-nodeport
[root@master01 data]#cd in-nodeport/
[root@master01 in-nodeport]#wget https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml
[root@master01 in-nodeport]#wget https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/mandatory.yaml
[root@master01 in-nodeport]#ls
mandatory.yaml  service-nodeport.yaml</code></pre> 
<h4 id="3.%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E8%B5%84%E6%BA%90">3.创建代理资源</h4> 
<h5 id="3.1%20%E5%88%9B%E5%BB%BAnginx-ingress-controller%E8%B5%84%E6%BA%90"><strong>3.1 创建nginx-ingress-controller资源</strong></h5> 
<pre><code class="language-cs">[root@master01 in-nodeport]#vim mandatory.yaml</code></pre> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/6f/cc/s7tjMdzo_o.png" width="1200"></p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/15/e1/Tut9Gz4D_o.png" width="1200"></p> 
<pre><code class="language-cs">[root@master01 in-nodeport]#kubectl apply -f mandatory.yaml 
#创建nginx-ingress-controller资源
#以pod的形式在ingress-nginx命名空间运行
[root@master01 in-nodeport]#kubectl get pod -owide -n ingress-nginx 
NAME                                        READY   STATUS    RESTARTS   AGE    IP             NODE     NOMINATED NODE   READINESS GATES
nginx-ingress-controller-54b86f8f7b-vj8rl   1/1     Running   0          153m   10.244.1.214   node01   &lt;none&gt;           &lt;none&gt;
</code></pre> 
<h5 id="3.2%20%E5%88%9B%E5%BB%BAservice%E8%B5%84%E6%BA%90" style="background-color:transparent;">3.2 创建service资源</h5> 
<p>查看service-nodeport.yaml 文件，都是默认内容，直接创建即可</p> 
<pre><code class="language-cs">[root@master01 in-nodeport]#cat service-nodeport.yaml 
apiVersion: v1
kind: Service
metadata:
  name: ingress-nginx
  namespace: ingress-nginx      #所在命名空间，需要先执行mandatory.yaml文件创建
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
spec:
  type: NodePort
  ports:
    - name: http
      port: 80
      targetPort: 80
      protocol: TCP
    - name: https
      port: 443
      targetPort: 443
      protocol: TCP
  selector:
    app.kubernetes.io/name: ingress-nginx         
    app.kubernetes.io/part-of: ingress-nginx
#此标签是nginx-ingress-controller的标签，该service绑定该标签，
#将nginx-ingress-controller以NodePort的形式暴露出去
---
</code></pre> 
<p><img alt="" height="306" src="https://images2.imgbox.com/29/9a/AJ3rX5Eg_o.png" width="1200"></p> 
<p>创建service资源</p> 
<pre><code class="language-cs">[root@master01 in-nodeport]#kubectl apply -f service-nodeport.yaml
[root@master01 in-nodeport]#kubectl get svc -n ingress-nginx 
NAME                    TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                      AGE
service/ingress-nginx   NodePort   10.96.43.71   &lt;none&gt;        80:31705/TCP,443:32391/TCP   31s
[root@master01 in-nodeport]#kubectl describe svc -n ingress-nginx 
Name:                     ingress-nginx
Namespace:                ingress-nginx
Labels:                   app.kubernetes.io/name=ingress-nginx
                          app.kubernetes.io/part-of=ingress-nginx
Annotations:              &lt;none&gt;
Selector:                 app.kubernetes.io/name=ingress-nginx,app.kubernetes.io/part-of=ingress-nginx
Type:                     NodePort
IP Families:              &lt;none&gt;
IP:                       10.96.43.71
IPs:                      10.96.43.71
Port:                     http  80/TCP
TargetPort:               80/TCP
NodePort:                 http  31705/TCP
Endpoints:                10.244.1.214:80
Port:                     https  443/TCP
TargetPort:               443/TCP
NodePort:                 https  32391/TCP
Endpoints:                10.244.1.214:443   #后端关联地址为nginx-ingress-controller地址
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &lt;none&gt;</code></pre> 
<h4 id="4.%E5%88%9B%E5%BB%BA%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90">4.创建访问资源</h4> 
<h5 id="4.1%20%E5%88%9B%E5%BB%BADeployment">4.1 创建Deployment</h5> 
<pre><code class="language-cs">[root@master01 in-nodeport]#vim deployment.yaml 
[root@master01 in-nodeport]#cat deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx01-ingress
  labels:
    nginx-label: nginx01
spec:
  replicas: 2
  selector:
    matchLabels:
     nginx-label: nginx01
  template:
    metadata:
      labels:
        nginx-label: nginx01
    spec:
      containers:
      - name: nginx
        image: nginx:1.18.0
        ports:
        - containerPort: 80
[root@master01 in-nodeport]#kubectl apply -f deployment.yaml 
deployment.apps/nginx01-ingress created
[root@master01 in-nodeport]#kubectl get pod -owide
NAME                               READY   STATUS    RESTARTS   AGE   IP             NODE     NOMINATED NODE   READINESS GATES
nginx01-ingress-5d89744488-g7v6w   1/1     Running   0          8s    10.244.2.7     node02   &lt;none&gt;           &lt;none&gt;
nginx01-ingress-5d89744488-x66jh   1/1     Running   0          8s    10.244.1.215   node01   &lt;none&gt;           &lt;none&gt;
------------------------------------------------------------------------------------
#自定义web访问界面
[root@master01 in-nodeport]#kubectl exec -it nginx01-ingress-5d89744488-g7v6w bash
root@nginx01-ingress-5d89744488-g7v6w/~# echo "this is web01" &gt;/usr/share/nginx/html/index.html 
root@nginx01-ingress-5d89744488-g7v6w/~# exit
exit
[root@master01 in-nodeport]#kubectl exec -it nginx01-ingress-5d89744488-x66jh bash
root@nginx01-ingress-5d89744488-x66jh:/# echo "this is web02" &gt;/usr/share/nginx/html/index.html
root@nginx01-ingress-5d89744488-x66jh:/# exit
exit
</code></pre> 
<h5 id="4.2%20%E5%88%9B%E5%BB%BAservice" style="background-color:transparent;">4.2 创建service</h5> 
<pre><code class="language-cs">[root@master01 in-nodeport]#vim service.yaml 
[root@master01 in-nodeport]#cat service.yaml 
apiVersion: v1
kind: Service
metadata:
  name: in-ng-svc
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    nginx-label: nginx01
[root@master01 in-nodeport]#kubectl apply -f service.yaml 
service/in-ng-svc created
[root@master01 in-nodeport]#kubectl get svc in-ng-svc 
NAME        TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
in-ng-svc   NodePort   10.96.174.168   &lt;none&gt;        80:32502/TCP   10s</code></pre> 
<h5 id="4.3%20%E5%88%9B%E5%BB%BAIngress%E8%A7%84%E5%88%99">4.3 创建Ingress规则</h5> 
<pre><code class="language-cs">[root@master01 in-nodeport]#vim ingress.yaml
[root@master01 in-nodeport]#cat ingress.yaml
apiVersion: networking.k8s.io/v1     #网络API组的v1版本。
kind: Ingress                        #创建一个Ingress 资源
metadata:
  name: nginx-ingress-test
spec:
  rules:                       #定义ingress规则
  - host: www.china.com        #指定当HTTP请求的Host头部为www.benet.com时触发规则
    http:                      #定义HTTP路由规则  
      paths:                   #定义路径列表及其对应的后端服务
      - path: /                #定义要匹配的路径。这里使用了根路径，也就是web服务的站点目录
        pathType: Prefix       #表示使用前缀匹配方式
        backend:               #定义与上述路径匹配时应该路由到的后端服务
          service:             #指定后端服务的名称
            name: in-ng-svc    #
            port:              #定义后端服务的端口
              number: 80       #端口号为80
-------------------------------------------------------------------------------------
#上述文件表示，客户端通过www.china.com访问时，会触发定义的ingress规则，
#而后通过ingress-controller转发到指定的后端服务(service)当中，后端服务再将请求转发给绑定的pod
[root@master01 in-nodeport]#kubectl apply -f ingress.yaml
ingress.networking.k8s.io/nginx-ingress-test created
[root@master01 in-nodeport]#kubectl get ingress
NAME                 CLASS    HOSTS           ADDRESS   PORTS   AGE
nginx-ingress-test   &lt;none&gt;   www.china.com             80      9s
</code></pre> 
<h4 id="5.%E4%BD%BF%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE">5.使用客户端进行访问</h4> 
<pre><code class="language-cs">//master01查看ingress的service对外暴露的端口
[root@master01 in-nodeport]#kubectl get svc -n ingress-nginx 
NAME            TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx   NodePort   10.96.43.71   &lt;none&gt;        80:31705/TCP,443:32391/TCP   137m

//客户端使用nginx-ingress-controller的service对外暴露的端口进行访问
[root@nfs ~]#cat /etc/hosts |grep www.china.com
192.168.83.40 node01 www.china.com     
#添加客户端的域名解析，IP地址为nginx-ingress-controller的pod所以节点的IP地址
[root@nfs ~]#curl www.china.com:31705 
this is web01
[root@nfs ~]#curl www.china.com:31705
this is web02
[root@nfs ~]#curl www.china.com:31705
this is web01
[root@nfs ~]#curl www.china.com:31705
this is web02
----------------------------------------------------------------------------------
可以看到，访问的方式，是以轮询的方式，发送到deployment管理的pod上。因为，它的数据流向是
1.用户将请求发送到ingress-controller，而后ingress-controller根据请求的Hosst头部信息，
也就是www.china.com触发ingress规则
2.ingress-controller通过ingress规则，获取到关联的service，以及endpoints关联地址
3.service会将流量平均分配，而后将地址返回给ingress-controller
4.ingress-controller最后将请求发送给合适的pod</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA">四、虚拟主机</h2> 
<p>Ingress HTTP 代理访问虚拟主机，使用同一个nginx-ingress-controller，根据不同的域名，代理到不同的后端服务</p> 
<p>例如访问www.china.com触发规则后，代理到service-01；访问www.zg.com触发规则二</p> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BApod%E8%B5%84%E6%BA%90">（一）创建pod资源</h3> 
<p>创建两个不同的pod资源，或者两个不同的deployment资源</p> 
<pre><code class="language-cs">[root@master01 vhost]#cat pod.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: nginx-01
  labels:
    nginx: nginx01
spec:
  containers: 
  - name: nginx
    image: nginx:1.18.0
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: nginx-02
  labels:
    nginx: nginx02
spec:   
  containers: 
  - name: nginx
    image: nginx:1.18.0
    ports:
    - containerPort: 80
[root@master01 vhost]#kubectl apply -f pod.yaml 
pod/nginx-01 created
pod/nginx-02 created
[root@master01 vhost]#kubectl get pod -owide
NAME        READY  STATUS  RESTARTS  AGE  IP            NODE     NOMINATED NODE   READINESS GATES
nginx-01    1/1    Running  0        14s  10.244.2.8    node02   &lt;none&gt;           &lt;none&gt;
nginx-02    1/1    Running  0        13s  10.244.1.216  node01   &lt;none&gt;           &lt;none&gt;</code></pre> 
<p>自定义web访问页面</p> 
<pre><code class="language-cs">[root@master01 vhost]#kubectl exec -it nginx-01 bash
root@nginx-01:/# echo "this is nginx-01" &gt;/usr/share/nginx/html/index.html 
root@nginx-01:/# exit
exit
[root@master01 in-nodeport]#kubectl exec -it nginx-02 bash
root@nginx-02:/# echo "this is nginx-02" &gt;/usr/share/nginx/html/index.html
root@nginx-02:/# exit
exit
[root@master01 vhost]#curl 10.244.2.8
this is nginx-01
[root@master01 vhost]#curl 10.244.1.216
this is nginx-02
</code></pre> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BAservice%E8%B5%84%E6%BA%90">（二）创建service资源</h3> 
<pre><code class="language-cs">[root@master01 vhost]#vim service.yaml 
[root@master01 vhost]#cat service.yaml 
apiVersion: v1
kind: Service
metadata:
  name: service-01
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    nginx: nginx01         #使用标签选择，关联的pod为nginx-01
---
apiVersion: v1
kind: Service
metadata:
  name: service-02
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    nginx: nginx02         #使用标签选择，关联的pod为nginx-02
[root@master01 vhost]#kubectl apply -f service.yaml 
service/service-01 created
service/service-02 created
[root@master01 vhost]#kubectl get svc
NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
service-01   ClusterIP   10.96.198.216   &lt;none&gt;        80/TCP    11s
service-02   ClusterIP   10.96.89.179    &lt;none&gt;        80/TCP    11s
</code></pre> 
<h3 id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99">（三）创建ingress规则</h3> 
<pre><code class="language-cs">[root@master01 vhost]#cat ingress.yaml 
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-vhost-ingress
spec:
  rules:
  - host: www.chinese.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service: 
            name: service-01
            port:
              number: 80
  - host: www.zg.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service: 
            name: service-02
            port:
              number: 80
[root@master01 vhost]#kubectl apply -f ingress.yaml 
ingress.networking.k8s.io/nginx-vhost-ingress created
[root@master01 vhost]#kubectl get ingress nginx-vhost-ingress 
NAME                  CLASS    HOSTS                        ADDRESS   PORTS   AGE
nginx-vhost-ingress   &lt;none&gt;   www.chinese.com,www.zg.com             80      12s</code></pre> 
<h3 id="%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE">（四）客户端访问</h3> 
<pre><code class="language-cs">[root@nfs ~]#cat /etc/hosts |grep www.chinese.com
192.168.83.40 node01 www.china.com www.chinese.com www.zg.com
#同样在客户端添加解析信息，而后使用nginx-ingress-controller的31705端口访问
[root@nfs ~]#curl www.chinese.com:31705
this is nginx-01
[root@nfs ~]#curl www.chinese.com:31705
this is nginx-01
[root@nfs ~]#curl www.zg.com:31705
this is nginx-02
[root@nfs ~]#curl www.zg.com:31705</code></pre> 
<h2 id="%E4%BA%94%E3%80%81HTPPS%E4%BB%A3%E7%90%86">五、HTPPS代理</h2> 
<p>要实现 HTTPS 代理，你需要在Ingress 对象中配置 SSL 证书，并确保 Ingress 控制器支持 HTTPS</p> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E8%8E%B7%E5%8F%96SSL%E8%AF%81%E4%B9%A6">（一）获取SSL证书</h3> 
<p>可以从证书颁发机构（CA）购买 SSL 证书，或者使用 Let's Encrypt 等服务获取免费证书</p> 
<pre><code class="language-cs">[root@master01 data]#mkdir /data/https
[root@master01 data]#cd /data/https
[root@master01 data]#openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=nginxsvc/O=nginxsvc"
Generating a 2048 bit RSA private key
....................................+++
........+++
writing new private key to 'tls.key'
-----
[root@master01 https]#ls
tls.crt  tls.key
[root@master01 https]#
--------------------------------------------------------------------------------
openssl req #OpenSSL命令行工具的一个子命令，用于创建和处理PKCS#10 证书签名请求以及自签名证书
-x509       #指定要生成一个自签名的证书，而不是一个证书签名请求（CSR）。
-sha256     #使用SHA-256哈希算法来签名证书。
-nodes      #在生成私钥时不加密它。这意味着私钥将以明文形式存储在tls.key文件中
-days 365   #设置证书的有效期为 365 天（一年）。
-newkey rsa:2048  #在生成证书的同时，也生成一个新的RSA私钥，其长度为2048位。
-keyout tls.key   #指定私钥的输出文件名为 tls.key。
-out tls.crt      #指定证书的输出文件名为 tls.crt。
-subj "/CN=nginxsvc/O=nginxsvc"  #设置证书的主题（Subject）字段。
CN（通用名称）被设置为 nginxsvc，O（组织）也被设置为 nginxsvc。通常，CN 应该是域名或服务器名称</code></pre> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BAKubernetes%20Secret">（二）<strong>创建Kubernetes Secret</strong></h3> 
<p>将 SSL 证书和私钥存储在 Kubernetes Secret 中，以便 Ingress 控制器可以访问它们</p> 
<pre><code class="language-cs">[root@master01 https]#kubectl create secret tls my-tls-secret --key tls.key --cert tls.crt
secret/my-tls-secret created
[root@master01 https]#kubectl get secret my-tls-secret 
NAME            TYPE                DATA   AGE
my-tls-secret   kubernetes.io/tls   2      16s
[root@master01 https]#kubectl describe secret my-tls-secret 
Name:         my-tls-secret
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  kubernetes.io/tls

Data
====
tls.crt:  1143 bytes
tls.key:  1708 bytes
----------------------------------------------------------------------------------------
kubectl               #Kubernetes 的命令行工具，用于与集群进行交互。
create secret tls     #指示 kubectl 创建一个 TLS 类型的 Secret。
my-tls-secret         #要创建的 Secret 的名称。
--key tls.key         #指定私钥文件的路径。文件处在当前路径
--cert tls.crt        #指定证书文件的路径。同样，文件处在当前路径</code></pre> 
<h3 id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BApod%E8%B5%84%E6%BA%90">（三）创建pod资源</h3> 
<p>使用deployment控制器创建，或者直接创建pod</p> 
<pre><code class="language-cs">[root@master01 https]#vim pod-https.yaml 
[root@master01 https]#cat pod-https.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-https
  labels:
    nginx: nginx-https
spec:
  containers: 
  - name: nginx
    image: nginx:1.18.0
    ports:
    - containerPort: 80
[root@master01 https]#kubectl apply -f pod-https.yaml 
pod/nginx-https created
[root@master01 https]#kubectl get pod nginx-https -owide
NAME          READY  STATUS   RESTARTS AGE  IP          NODE    NOMINATED NODE  READINESS GATES
nginx-https   1/1    Running  0        12s  10.244.2.9  node02  &lt;none&gt;          &lt;none&gt;</code></pre> 
<p>自定义web界面</p> 
<pre><code class="language-cs">[root@master01 https]#kubectl exec -it nginx-https bash
root@nginx-https:/# echo "this is nginx-https" &gt;/usr/share/nginx/html/index.html 
root@nginx-https:/# exit
exit
[root@master01 https]#curl 10.244.2.9
this is nginx-https</code></pre> 
<h3 id="%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%9B%E5%BB%BAservice">（四）创建service</h3> 
<pre><code class="language-cs">[root@master01 https]#vim service-https.yaml 
[root@master01 https]#cat service-https.yaml 
apiVersion: v1
kind: Service
metadata:
  name: service-https
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    nginx: nginx-https
[root@master01 https]#kubectl apply -f service-https.yaml 
service/service-https created
[root@master01 https]#kubectl get svc service-https 
NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
service-https   ClusterIP   10.96.128.206   &lt;none&gt;        80/TCP    13s
</code></pre> 
<h3 id="%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%A7%84%E5%88%99">（五）创建ingress规则</h3> 
<pre><code class="language-cs">[root@master01 https]#vim ingress-https.yaml 
[root@master01 https]#cat ingress-https.yaml 
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-https-ingress
spec:
  tls:
  - hosts:                       #这是一个列表，指定了哪些主机名应该使用此TLS配置
    - www.https.com              #指定使用该TSL的主机名称为www.https.com，可以定义多个
    secretName: my-tls-secret    #引用Secret，该Secret包含TLS私钥和证书
  rules:
  - host: www.https.com          #与tls中hosts字段定义的主机名一致
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service: 
            name: service-https  #指定后端service名称
            port:
              number: 80
[root@master01 https]#kubectl apply -f ingress-https.yaml 
ingress.networking.k8s.io/nginx-https-ingress created
[root@master01 https]#kubectl get ingress nginx-https-ingress
NAME                  CLASS    HOSTS           ADDRESS       PORTS     AGE
nginx-https-ingress   &lt;none&gt;   www.https.com   10.96.43.71   80, 443   20s
</code></pre> 
<h3 id="%EF%BC%88%E5%85%AD%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE">（六）客户端访问</h3> 
<p>在客户端添加域名信息，使用https访问443端口映射的主机端口</p> 
<blockquote> 
 <p>使用虚拟机客户端的web浏览器</p> 
 <p>或者在物理机的 C:\Windows\System32\drivers\etc\hosts 文件添加www.https.com的解析信息</p> 
 <p>而后使用物理机浏览器访​问https://www.https.com:映射端口</p> 
</blockquote> 
<pre><code class="language-cs">[root@nfs ~]#cat /etc/hosts |grep www.https.com
192.168.83.40 node01 www.china.com www.chinese.com www.zg.com www.https.com
#添加客户端的解析信息，而后使用虚拟机的web浏览器访问

//在master节点，查看443端口映射的宿主机端口
[root@master01 https]#kubectl get svc -n ingress-nginx 
NAME            TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx   NodePort   10.96.43.71   &lt;none&gt;        80:31705/TCP,443:32391/TCP   3h10m
#使用浏览器访问https://www.https.com:32391端口</code></pre> 
<p><img alt="" height="1002" src="https://images2.imgbox.com/0d/24/QvD6YfS8_o.png" width="1200"></p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/82/0a/dBRCXqwQ_o.png" width="800"></p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/f2/1a/VOyjaEX7_o.png" width="1004"></p> 
<h2 id="%E5%85%AD%E3%80%81%E5%AE%9E%E7%8E%B0BasicAuth">六、实现BasicAuth</h2> 
<p>BasicAuth是一种用于在客户端和服务器之间进行身份验证的协议，特别是用于HTTP请求的身份验证</p> 
<p>BasicAuth通过在HTTP请求头中添加一个“Authorization”字段来进行身份验证。这个字段包含了一个Base64编码的用户名和密码信息</p> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6">（一）创建认证文件</h3> 
<h4 id="1.%E4%B8%8B%E8%BD%BDhtpasswd%E5%B7%A5%E5%85%B7">1.下载htpasswd工具</h4> 
<pre><code class="language-cs">[root@master01 https]#mkdir /data/basicauth
[root@master01 https]#cd /data/basicauth/
[root@master01 basicauth]#yum install httpd-tools.x86_64 -y
#下载httpd-tools工具包，使用htpasswd命令生成证书文件</code></pre> 
<h4 id="2.%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6">2.创建认证文件</h4> 
<pre><code class="language-cs">[root@master01 basicauth]#htpasswd -c auth xiaoming
New password:                       #输入密码
Re-type new password:               #确认密码
Adding password for user xiaoming
[root@master01 basicauth]#ls
auth                                #生成的证书文件名称为auth
------------------------------------------------------------------------------
htpasswd #用于创建和更新存储用户名和密码的文件的实用工具
-c       #创建一个新的密码文件
auth     #存储用户信息的文件，文件名称固定为auth
xiaoming #添加到密码文件中的用户名，回车之后下面输入密码</code></pre> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BASecret">（二）创建Secret</h3> 
<p>创建 secret 资源存储用户密码的认证文件</p> 
<pre><code class="language-cs">[root@master01 basicauth]#kubectl create secret generic basic-auth --from-file=auth
secret/basic-auth created
[root@master01 basicauth]#kubectl get secrets basic-auth 
NAME         TYPE     DATA   AGE
basic-auth   Opaque   1      15s
[root@master01 basicauth]#kubectl describe secrets basic-auth 
Name:         basic-auth
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  Opaque

Data
====
auth:  47 bytes</code></pre> 
<h3>（三）创建pod资源</h3> 
<pre><code class="language-cs">[root@master01 basicauth]#vim pod-auth.yaml 
[root@master01 basicauth]#cat pod-auth.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: nginx-auth
  labels:
    nginx: nginx-auth
spec:
  containers: 
  - name: nginx
    image: nginx:1.18.0
    ports:
    - containerPort: 80
[root@master01 basicauth]#kubectl apply -f pod-auth.yaml 
pod/nginx-auth created
[root@master01 basicauth]#kubectl get pod nginx-auth -owide
NAME         READY   STATUS    RESTARTS   AGE   IP             NODE     NOMINATED NODE   READINESS GATES
nginx-auth   1/1     Running   0          19s   10.244.1.217   node01   &lt;none&gt;           &lt;none&gt;
[root@master01 basicauth]#kubectl exec -it nginx-auth bash
root@nginx-auth:/# echo "this is auth" &gt;/usr/share/nginx/html/index.html
root@nginx-auth:/# exit
exit
#自定义web界面</code></pre> 
<h3>（四）创建service</h3> 
<pre><code class="language-cs">[root@master01 basicauth]#cat service-auth.yaml 
apiVersion: v1
kind: Service
metadata:
  name: service-auth
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    nginx: nginx-auth
[root@master01 basicauth]#kubectl apply -f pod-auth.yaml 
pod/nginx-auth created
[root@master01 basicauth]#kubectl apply -f service-auth.yaml 
service/service-auth created
[root@master01 basicauth]#kubectl get svc service-auth 
NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
service-auth   ClusterIP   10.96.127.61   &lt;none&gt;        80/TCP    15s
</code></pre> 
<h3 id="%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%9B%E5%BB%BAingress%E8%B5%84%E6%BA%90">（五）创建ingress资源</h3> 
<pre><code class="language-cs">[root@master01 basicauth]#vim ingress-auth.yaml 
[root@master01 basicauth]#cat ingress-auth.yaml 
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-auth-ingress
  annotations:
    nginx.ingress.kubernetes.io/auth-type: basic
    #指定认证类型为基本认证（basic）
    nginx.ingress.kubernetes.io/auth-secret: basic-auth
    #指定包含基本认证凭据的Secret资源名称basic-auth
    nginx.ingress.kubernetes.io/auth-realm: 'Authentication Required - xiaoming'
    #定义了当用户需要认证时显示的领域（realm）名称，即认证窗口提示信息
spec:
  rules:
  - host: www.auth.com             #指定主机名触发条件
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service: 
            name: service-auth     #关联的后端服务service
            port:
              number: 80
</code></pre> 
<p><img alt="" height="701" src="https://images2.imgbox.com/d1/a2/u7cmmX4W_o.png" width="1200"></p> 
<p>添加解析信息后，使用web浏览器进行访问</p> 
<pre><code class="language-cs">[root@nfs ~]#cat /etc/hosts |grep www.auth.com
192.168.83.40 node01 www.auth.com</code></pre> 
<p>添加完解析信息后，使用浏览器访问80映射的主机端口，即www.auth.com:31705</p> 
<p><img alt="" height="821" src="https://images2.imgbox.com/9e/ee/hI8gbrau_o.png" width="1200"></p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/f5/59/VbYrSZRG_o.png" width="1198"></p> 
<h2 id="%E4%B8%83%E3%80%81Nginx%E9%87%8D%E5%86%99">七、Nginx重写</h2> 
<blockquote> 
 <p>当域名更新之后，可以使用重写功能，使旧域名，跳转到新的域名当中</p> 
 <p>例如当访问www.old.com时，使用重写功能跳转到www.new.com</p> 
</blockquote> 
<p>#metadata.annotations 配置说明</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/0d/23/R37c0M5u_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>nginx.ingress.kubernetes.io/rewrite-target: &lt;字符串&gt;</strong></p> 
 <p>此注解允许你修改目标服务的请求 URI。这对于重写来自 Ingress 的流量路径特别有用，尤其是当你想将流量映射到后端服务的不同路径时。</p> 
 <p>&lt;字符串&gt; 通常是一个包含捕获组的正则表达式，这些捕获组会被替换为实际请求路径中的相应部分。</p> 
 <p><strong>nginx.ingress.kubernetes.io/ssl-redirect: &lt;布尔值&gt;</strong></p> 
 <p>默认情况下，如果 Ingress 资源配置了 TLS 证书（通过 tls 部分），并且此注解设置为 true，则所有非 SSL 请求都将被重定向到 SSL（HTTPS）。</p> 
 <p>&lt;布尔值&gt; 可以是 true 或 false。如果设置为 false，即使配置了 TLS 证书，非 SSL 请求也不会被重定向。</p> 
 <p><strong>nginx.ingress.kubernetes.io/force-ssl-redirect: &lt;布尔值</strong>&gt;</p> 
 <p>即使 Ingress 资源没有配置 TLS 证书，将此注解设置为 true 也会强制将所有请求重定向到 HTTPS。</p> 
 <p>&lt;布尔值&gt; 可以是 true 或 false。请注意，将此注解设置为 true 时，你需要确保 Nginx Ingress Controller 能够处理 HTTPS 请求（例如，通过前端代理或负载均衡器终止 SSL）。</p> 
 <p><strong>nginx.ingress.kubernetes.io/app-root: &lt;字符串&gt;</strong></p> 
 <p>如果你的应用程序部署在根路径（/）之外，但你想将所有根路径的流量重定向到该应用程序的实际路径，可以使用此注解。</p> 
 <p>&lt;字符串&gt; 是你的应用程序的实际根路径（例如，/myapp/）。</p> 
 <p><strong>nginx.ingress.kubernetes.io/use-regex: &lt;布尔值&gt;</strong></p> 
 <p>此注解指示 Ingress 资源中定义的路径是否使用正则表达式进行匹配。</p> 
 <p>&lt;布尔值&gt; 可以是 true 或 false。如果设置为 true，paths 下的 path 字段将被视为正则表达式进行匹配</p> 
</blockquote> 
<p>以auth为例，使旧的域名访问时，跳转到该域名</p> 
<pre><code class="language-cs">[root@master01 data]#mkdir /data/rewrite
[root@master01 data]#cd  /data/rewrite/
[root@master01 rewrite]#vim ingress-rewrite.yaml
[root@master01 rewrite]#cat ingress-rewrite.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-rewrite
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: http://www.auth.com:31705
#重写目标URL，重写为http://www.auth.com:31705
spec:
  rules:
  - host: www.rewrite.com  #流量应该匹配的主机名，访问该主机名，将会被重写
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-rewrite
            port:
              number: 80
[root@master01 rewrite]#kubectl apply -f ingress-rewrite.yaml 
ingress.networking.k8s.io/nginx-rewrite created
[root@master01 rewrite]#kubectl get ingress nginx-rewrite 
NAME            CLASS    HOSTS             ADDRESS       PORTS   AGE
nginx-rewrite   &lt;none&gt;   www.rewrite.com   10.96.43.71   80      25s
</code></pre> 
<p>添加解析信息之后使用浏览器访问</p> 
<pre><code class="language-cs">[root@nfs ~]#cat /etc/hosts |grep www.rewrite.com
192.168.83.40 node01 www.auth.com www.rewrite.com</code></pre> 
<p><img alt="" height="821" src="https://images2.imgbox.com/3b/8c/JPbVLWcu_o.png" width="1200"></p> 
<p>更多的重写机制，可以查阅官方文档，或者nginx重写规则进行查看</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d7a8e0cd116a464246ad7f53bee0330/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">屌炸的文本转语音AI——ChatTTS本地部署教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d724b5fcc0207d3a427c9160987710e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT4-QT5升级（3）GBK-UTF-8-乱码“常量中有换行符”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>