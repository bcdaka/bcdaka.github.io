<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux高级编程——线程 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4e6e985846abe0eb10228cc769361364/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Linux高级编程——线程">
  <meta property="og:description" content="pthread 线程
概念 ：线程是轻量级进程，一般是一个进程中的多个任务。
进程是系统中最小的资源分配单位.
线程是系统中最小的执行单位。
优点： 比多进程节省资源，可以共享变量
进程会占用３ｇ左右的空间，线程只会占用一部分，大概８Ｍ的空间
进程的父子不会共享,但一个进程之间的线程的资源可以共享.
进程的父子不是平级关系,线程是平级关系
特征：s&#39;s
1、共享资源
2、效率高 30%
3、三方库： pthread clone posix
3.1 编写代码头文件： pthread.h
3.2 编译代码加载库： -lpthread library libpthread.so (linux库)
gcc 1.c -lpthread -lc
缺点：
1，线程和进程相比，稳定性，稍微差些
2，线程的调试gdb，相对麻烦些。
info thread *1 2 3
thread 3 线程与进程区别：
资源：
线程比进程多了共享资源。 IPC
线程又具有部分私有资源。
进程间只有私有资源没有共享资源。
空间：
进程空间独立，不能直接通信。
线程可以共享空间，可以直接通信。
进程解决相对复杂的问题,线 程解决相对复杂的问题.
共同点:
二者都可以并发
3、线程的设计框架 posix
创建多线程 ==》线程空间操作 ===》线程资源回收
errno strerror（errno） perror();
3.1 创建多线程： int pthread_create(
pthread_t *thread , const pthread_attr_t *attr,">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-28T18:00:07+08:00">
    <meta property="article:modified_time" content="2024-06-28T18:00:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux高级编程——线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>pthread 线程<br>    </h2> 
<blockquote> 
 <p>    概念 ：线程是轻量级进程，一般是一<span style="color:#fe2c24;">个进程中的多个任务</span>。<br>                 进程是系统中最小的资源分配单位.<br>                 线程是系统中最小的执行单位。</p> 
</blockquote> 
<p><strong>  优点：</strong> 比多进程节省资源，可以共享变量</p> 
<p>进程会占用３ｇ左右的空间，线程只会占用一部分，大概８Ｍ的空间</p> 
<p>进程的父子不会共享,但一个进程之间的线程的资源可以共享.</p> 
<p>进程的父子不是平级关系,线程是平级关系</p> 
<p><strong> 特征：s's</strong><br>     1、共享资源<br>     2、效率高  30%<br>     3、三方库： pthread  clone   posix<br>             3.1 编写代码头文件： pthread.h<br>             3.2 编译代码加载库： -lpthread   library <br>             libpthread<span style="color:#956fe7;">.so  (linux库)</span><br>             gcc 1.c -lpthread     <span style="color:#956fe7;">-lc</span><br><strong>    缺点：</strong><br>     1，线程和进程相比，稳定性，稍微差些<br>     2，线程的调试gdb，相对麻烦些。<br>         info thread <br>         *1  <br>         2 <br>         3<br>         thread 3 <br>         <br><strong>线程与进程区别：</strong></p> 
<p>    资源：<br>         线程比进程多了共享资源。  IPC<br>         线程又具有部分私有资源。<br>         进程间只有私有资源没有共享资源。<br>     空间：<br>         进程空间独立，不能直接通信。<br>         线程可以共享空间，可以直接通信。</p> 
<p>       进程解决相对复杂的问题,线 程解决相对复杂的问题.</p> 
<p><strong>共同点:</strong></p> 
<p>二者都可以并发</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/04/cd/yl5So0PD_o.png" width="478"></p> 
<h3>3、线程的设计框架  posix<br>     </h3> 
<p>创建多线程 ==》线程空间操作 ===》线程资源回收<br> errno   strerror（errno）  perror();<br>   </p> 
<h5> 3.1 创建多线程：</h5> 
<p><br>     int pthread_create(<br>        <span style="color:#a2e043;"> pthread_t *thread </span>,  <span style="color:#956fe7;">const pthread_attr_t *attr,</span><br>        <span style="color:#4da8ee;"> void *(*start_routine) (void *), </span><span style="color:#ff9900;">void *arg)</span>;<br>     功能：该函数可以创建指定的一个线程。<br>     参数<span style="color:#a2e043;">：thread 线程id</span>，需要实现定义并由该函数返回。<br>         <span style="color:#956fe7;">  attr   线程属性</span>，一般是NULL，表示默认属性。<br>        <span style="color:#4da8ee;">   start_routine      </span>指向指针函数的函数指针。<br>                   本质上是一个函数的名称即可。称为<br> th                回调函数,是线程的执行空间。<br> {<!-- --><br> }<br>           <span style="color:#ff9900;">arg  回调函数的参数</span>，即参数3的指针函数参数。<br>  </p> 
<p> 返回值：成功 0<br>                 失败 错误码</p> 
<p>注意：一次pthread_create执行只能创建一个线程。<br>       每个进程至少有一个线程称为主线程。<br>    <span style="color:#ffd7b9;"> </span><span style="color:#1c7331;">  主线程退出则所有创建的子线程都退出。暂时先用while(1); </span><br>       主线程必须有子线程同时运行才算多线程程序。<br>   <span style="color:#ad720d;">    线程id是线程的唯一标识</span>，是CPU维护的一组数字。<br>       pstree 查看系统中多线程的对应关系。<br>       多个子线程可以执行同一回调函数。<br>   <strong>  ps -eLf </strong>查看线程相关信息Low Weigth Process<br><strong>    ps -eLo pid,ppid,lwp,stat,comm</strong></p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;string.h&gt;
#include&lt;pthread.h&gt;
void *th1(void*arg)
{
	while(1)
	{

	printf("发送视频\n");
	sleep(1);
	}
}

void *th2(void*arg)
{
	while(1)
	{
		printf("接受控制\n");
	}
}

int main(int argc, const char *argv[])
{
	pthread_t tid1,tid2;
	pthread_create(&amp;tid1,NULL,th1,NULL);
	pthread_create(&amp;tid2,NULL,th2,NULL);
	while(1);

	return 0;
}</code></pre> 
<ol><li><code>main</code> 函数开始执行。</li><li>使用 <code>pthread_create</code> 创建了两个线程 <code>tid1</code> 和 <code>tid2</code>。</li><li><code>th1</code> 线程开始执行其无限循环，并在每次迭代中打印 "发送视频"，然后暂停一秒。</li><li>同时（几乎是同时），<code>th2</code> 线程也开始执行其无限循环，不断打印 "接受控制"。</li><li>因为两个线程是并发执行的，所以它们之间没有固定的打印顺序。这取决于操作系统调度器的决策，哪个线程在何时获得CPU时间片。</li><li><code>main</code> 函数中的 <code>while(1);</code> 是一个空循环，它使主线程保持活动状态，防止程序立即退出。然而，这个空循环并没有为程序提供任何有用的功能，通常你可能会使用某种形式的线程同步或等待（如 <code>pthread_join</code>）来确保主线程在所有其他线程完成后才退出。</li></ol> 
<p>此时输出是乱的,是由于</p> 
<ul><li>线程调度是由操作系统控制的，它决定哪个线程在何时运行。这取决于许多因素，包括线程优先级、系统负载、可用的CPU核心数量等。</li><li>由于两个线程都在无限循环中，并且没有同步机制（如互斥锁、条件变量等），所以它们会尽可能快地交替执行（或并行执行，如果系统有多个CPU核心），导致输出看起来没有规律。</li></ul> 
<h4>2、pthread_t pthread_self(void); unsigned long int; %lu  获取线程号</h4> 
<p><br>    功能：获取当前线程的线程id<br>    参数：无<br>    返回值：成功 返回当前线程的线程id<br>                失败  -1；<br>             syscall(SYS_gettid);<br> 这个方法重启后失效<br> alias gcc='gcc -g -pthread '<br> unalias gcc </p> 
<p>永久起作用<br> cd ~ //家目录<br> vim .bashrc<br> alias gcc='gcc -g -pthread '  :wq</p> 
<p>source .bashrc  生效</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
void *th1 (void*arg)
{
    while(1)
    {
        printf("发送视频 %lu\n",pthread_self());
        sleep(1);
    }
}

void *th2 (void*arg)
{
    while(1)
    {
        printf("接受控制 %lu\n",pthread_self());
        sleep(1);
    }
}

int main(int argc, char *argv[])
{
    pthread_t tid1,tid2;
    pthread_create(&amp;tid1,NULL,th1,NULL);
    pthread_create(&amp;tid2,NULL,th2,NULL);
    printf("main th %lu\n",pthread_self());
    while(1);
    return 0;
}
</code></pre> 
<ul><li>使用<code>pthread_create</code>创建两个线程：<code>tid1</code>（运行<code>th1</code>）和<code>tid2</code>（运行<code>th2</code>）。</li><li>打印主线程的ID。</li><li>使用<code>while(1);</code>使主线程进入无限循环，以保持程序运行。否则，当主线程结束时，程序可能会立即终止，导致其他线程也被终止</li></ul> 
<p>练习题：<br>     设计一个多线程程序，至少有三个子线程<br>     每个线程执行不同的任务，并实时打印执行<br>     过程，同时表明身份。</p> 
<p>    eg: ./a.out  ==&gt;tid =xxx...  zheng ...<br>                     tid2 = xxx wozai.<br>                     tid3 = xxx  wozai ssss</p> 
<h4><br> 线程的退出：</h4> 
<p>1.直接用return;   </p> 
<p>2： 自行退出 ==》自杀  ==》子线程自己退出<br>         exit(1);<br>         void <span style="color:#4da8ee;">pthread_exit</span>(void *retval);  exit  return p;<br>         功能：子线程自行退出<br>         参数： retval 线程退出时候的返回状态，临死遗言。<br>         返回值：无</p> 
<p>            th<br>             {<!-- --><br>                 int a =10;</p> 
<p>                pthread_exit(&amp;a);<br>             }<br>             join(,&amp;ret)</p> 
<pre><code class="language-cs">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
void *th1 (void*arg)
{
    int i =10;
    while(i--)
    {
        printf("发送视频 %lu\n",pthread_self());
        sleep(1);
    }
    pthread_exit(NULL);//return NULL;
}

void *th2 (void*arg)
{
    int i = 10;
    while(i--)
    {
        printf("接受控制 %lu\n",pthread_self());
        sleep(1);
    }
    pthread_exit(NULL);
}

int main(int argc, char *argv[])
{
    pthread_t tid1,tid2;
    pthread_create(&amp;tid1,NULL,th1,NULL);
    pthread_create(&amp;tid2,NULL,th2,NULL);
    printf("main th %lu\n",pthread_self());
    while(1);
    return 0;
}</code></pre> 
<p><br>     3. 强制退出 ==》他杀  ==》主线程结束子线程<br>         int <span style="color:#ff9900;">pthread_cancel(</span>pthread_t thread);<br>         功能：请求结束一个线程  (在主线程种调用 写入某个线程id号,可以关闭该线程)<br>         参数：thread 请求结束一个线程tid(想要关闭的线程id号)<br>         返回值：成功 0<br>                 失败 -1；</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
void *th1 (void*arg)
{
    while(1)
    {
        printf("发送视频\n");
        sleep(1);
    }
}

void *th2 (void*arg)
{
    while(1)
    {
        printf("接受控制\n");
        sleep(1);
    }
}

int main(int argc, char *argv[])
{
    pthread_t tid1,tid2;
    pthread_create(&amp;tid1,NULL,th1,NULL);
    pthread_create(&amp;tid2,NULL,th2,NULL);
    int i = 0 ;
    while(1)
    {

        i++;
        if(3 == i )
        {
            pthread_cancel(tid1);
        }
        
        if(5 ==i)
        {
        
            pthread_cancel(tid2);
        }
        sleep(1);
    }
    return 0;
}</code></pre> 
<p><img alt="" height="170" src="https://images2.imgbox.com/c6/64/ciUxJzG0_o.png" width="369"></p> 
<p>作业：<br>     创建一个多线程程序，至少有10个子线程，<br>     每个线程有会打印不同的数据，同时表明身份。</p> 
<h4>    <br>     线程的回收</h4> 
<p><br>     1、线程的回收机制 ====》不同与进程没有孤儿线程和僵尸线程。<br>                                     ====》主线程结束任意生成的子线程都会结束。<br>                                       ====》 子线程的结束不会影响主线程的运行。<br>     char * retval ; retval++; 1 <br>     int * retval; </p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/0c/87/L0eKkrmI_o.png" width="1174"></p> 
<p><strong>    int pthread_join(<span style="color:#ff9900;">pthread_t thread</span>,<span style="color:#4da8ee;"> void **retval</span>);</strong>    <br>   功能：通过该函数可以将指定的线程资源回收，该函数具有<span style="color:#fe2c24;">阻塞等待功能，</span>如果指定的线程没有结束，则回收线程会阻塞。<br>   参数<span style="color:#ff9900;">：thread </span> 要回收的子线程tid<br>               <span style="color:#4da8ee;">retval </span> 要回收的子线程返回值/状态。==》ptread_exit(值);<br>   返回值：成功 0<br>                  失败 返回一个错误号,是一个大于零的数；</p> 
<p>                  失败可以用</p> 
<p>          <img alt="" height="122" src="https://images2.imgbox.com/84/63/GepYhpYy_o.png" width="602">     </p> 
<p> </p> 
<pre><code class="language-cs">#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
void *th1 (void*arg)
{
    int i = 10;
    while(i--)
    {
        printf("发送视频\n");
        sleep(1);
    }
}

void *th2 (void*arg)
{
    int i = 10;
    while(i--)
    {
        printf("接受控制\n");
        sleep(1);
    }
}

int main(int argc, char *argv[])
{
    pthread_t tid1,tid2;
    pthread_create(&amp;tid1,NULL,th1,NULL);
    int ret = pthread_create(&amp;tid2,NULL,th2,NULL);
    if(ret!=0)
    {
       // perror()
       fprintf(stderr,"error %s\n",strerror(ret));//exit();
    }
    pthread_join(tid1,NULL);
    pthread_join(tid2,NULL);
    return 0;
}
</code></pre> 
<p></p> 
<p>子线程的回收策略：<br>   1、如果预估子线程可以有限范围内结束则正常用pthread_join等待回收。<br>   2、如果预估子线程可能休眠或者阻塞则等待一定时间后强制回收。<br>   3、如果子线程已知必须长时间运行则，不再回收其资源。<br>   <br>   </p> 
<h3><br>   线程的参数，返回值<br>   </h3> 
<p>1、传参数<br>         <br>     <span style="color:#fe2c24;">传整数</span> ===》int add(int a,int b);  ///a b 形参<br>                 add(x,y);    x y 实参 </p> 
<p>        pthread_create(&amp;tid,NULL,fun,x);</p> 
<p>        fun ==&gt;void * fun(void * arg);<br>         <br>     练习：创建一个子线程并向该线程中传入一个字符在<br>           线程中打印输出。<br>           在此基础上向子线程中传入一个字符串，并在<br>           子线程中打印输出。</p> 
<p>          <br>           add(int a, int b)<br>           {<!-- --><br>             int c = a+b;<br>             char buf[]=""<br>             return c;<br>           }<br>                     5<br>           int d = add(2,3);</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

void* th(void* arg)
{
    static int a =20;
    return &amp;a;
}

int main(int argc, char *argv[])
{
    pthread_t tid;
    void* ret;
    pthread_create(&amp;tid,NULL,th,NULL);
    pthread_join(tid,&amp;ret);
    printf("ret %d\n",*(int*)ret);
    return 0;
}</code></pre> 
<p><br>    <span style="color:#fe2c24;"> 传字符串</span><br>         栈区字符数组：<br>         字符串常量：<br>         char *p = "hello";<br>         堆区字符串；<br>             char *pc = (char *)malloc(128);<br>             ptread_create(&amp;tid,NULL,fun,pc);</p> 
<p>            pthread_join(tid,NULL);</p> 
<p>            free(pc);<br>         <br>             fun(void *arg)<br>             {<!-- --><br>                 char * pc = (char *)arg    ;<br>                 printf("%s \n",pc);<br>                         %c<br>             }</p> 
<p>栈区</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

void* th(void* arg)
{
    static char buf[256]={0};
    strcpy(buf,"要消亡了\n");
    return buf;
}

int main(int argc, char *argv[])
{
    pthread_t tid;
    void* ret;
    pthread_create(&amp;tid,NULL,th,NULL);
    pthread_join(tid,&amp;ret);
    printf("ret %s\n",(char*)ret);
    return 0;
}</code></pre> 
<p>堆区:</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

void* th(void* arg)
{
    char * tmp = (char* )arg;
    strcpy(tmp,"hello");
    return tmp;
}

int main(int argc, char *argv[])
{
    pthread_t tid;

    char * p = (char*)malloc(50);
    void* ret;
    pthread_create(&amp;tid,NULL,th,p);
    pthread_join(tid,&amp;ret);
    printf("ret %s\n",(char*)ret);
    free(p);
    return 0;
}
</code></pre> 
<p>  </p> 
<p></p> 
<p><span style="color:#fe2c24;"> 传结构体</span><br>     1、定义结构体类型<br>     2、用结构体定义变量<br>     3、向pthread_create传结构体变量<br>     4、从fun子线程中获取结构体数据</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
typedef struct 
{
    char * p;
    int a;
}TH_ARG;
void* th(void* arg)
{
    TH_ARG * tmp = (TH_ARG* )arg;
    strcpy(tmp-&gt;p,"hello");
    //strcpy( ((TH_ARG*)arg)-&gt;p ,"hello");
    tmp-&gt;a +=10;
    return tmp;
}

int main(int argc, char *argv[])
{
    pthread_t tid;
    int a  =20;
    char * p = (char*)malloc(50);
    TH_ARG arg;
    arg.a = a;
    arg.p = p;
    void* ret;
    pthread_create(&amp;tid,NULL,th,&amp;arg);
    pthread_join(tid,&amp;ret);
    printf("ret %s %d\n",((TH_ARG*)ret)-&gt;p,((TH_ARG*)ret)-&gt;a);
    free(p);
    return 0;
}
</code></pre> 
<p></p> 
<p>练习：<br>     定义一个包含不同数据类型的测试结构体<br>     并向子线程传参数，同时在子线程中打印输出。</p> 
<p><br>     定义一个回调函数可以完成计算器的功能<br>     定义一个数据结构体可以一次传入不同的数据<br>     和计算方式并将结果打印输出。<br>     //2 + 3.6 <br>     // 2 + 3  2+3<br>     // 8 * 6<br>     typedef strcut<br>     {<!-- --><br>         float a;<br>         float b;<br>         char c;//+ - * / <br>         float d;<br>     }JSQ;<br>     <br>     </p> 
<p>返回值：pthread_exit(0) ===&gt;pthread_exit(9);<br>         pthread_join(tid,NULL); ===&gt;pthread_join(tid,?);<br> 10;<br> -10;<br> int * p =malloc(4);<br> *p = -10;<br> 1、pthread_exit(?) ==&gt;? = void * retval;<br>                           纯地址</p> 
<p>2、pthread_join(tid,?) ==&gt;? = void **retval;<br>                             地址的地址<br> 原理：子线程退出的时候，可以返回一个内存地址<br>       改值所在的内存中可以存储任何数据，只要<br>       地址存在，则数据都可以正常返回。<br>     <br>     地址有三种：<br>     0、栈区变量  错误，子线程结束该地址失效。<br>     1、全局变量  失去意义，本质可以直接访问。</p> 
<p>    2、静态变量 <br>     3、堆区变量</p> 
<p><br>       主线程通过一个地址形式的变量来接受子进程<br>       返回的地址变量就可以将该地址中的数据取到。</p> 
<p>    练习：从子线程中申请一块堆区内存并存字符串<br>       将该字符串以返回值形式返回到主线程并打印输出。<br>           <br>  </p> 
<h3><strong>   设置分离属性，目的线程消亡，自动回收空间。</strong><br>   </h3> 
<p></p> 
<p>主线程没有空,才设置分离属性来回收.</p> 
<p><strong> attribute</strong></p> 
<p><strong> int pthread_attr_init(pthread_attr_t *attr)</strong>;<br>     功能，初始化一个attr的变量<br>     参数：attr，需要变量来接受初始值<br>     返回：0  成功，<br>     非0 错误；<br>        int pthread_attr_destroy(pthread_attr_t *attr);<br>       功能：销毁attr变量。<br>       attr，属性变量<br>       返回：0  成功，<br>     非0 错误；<br>        <br>        <br><strong>    man -k </strong><br>  <strong>    int pthread_attr_setdetachstate(pthread_attr_t *attr<br> , int detachstate);</strong><br>     功能：把一个线程设置成相应的属性<br>     参数，attr，属性变量，有init函数初始化他。<br>     detachstate：有2个可选值，<br>     <br>     PTHREAD_CREATE_DETACHED：设置分离属性。<br>     <br>     第二种设置分离属性：<br><strong>int pthread_deatch(pthread_t thread);</strong><br>     功能，设置分离属性<br>     参数，线程id号，填自己的id<br>     <br>     do{<!-- --><br>     <br>     <br>     }while()</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
void* th(void* arg)
{
    pthread_detach(pthread_self());
    return NULL;
}

int main(int argc, char *argv[])
{
    pthread_t tid;
    int i = 0 ;
    for(i=0;i&lt;50000;i++)
    {
        int ret = pthread_create(&amp;tid,NULL,th,NULL);
        if(ret!=0)
        {
            break;
        }
       // pthread_detach(tid);
    }
    printf("%d \n",i);
    return 0;
}
</code></pre> 
<p><br> void pthread_cleanup_push(void (*routine)(void *)， void *arg);</p> 
<p>    功能：注册一个线程清理函数<br>     参数，routine，线程清理函数的入口<br>         arg，清理函数的参数。<br>     返回值，无<br>         <br> void pthread_cleanup_pop(int execute);<br>     功能：调用清理函数<br>     execute，非0  执行清理函数<br>             0 ，不执行清理<br>             <br>     返回值，无</p> 
<p>do<br> {<!-- --></p> 
<p>}while(1)</p> 
<p>process                thread<br> fork                pthread_create <br> getpid,ppid,        pthread_self<br> exit,                pthread_exit <br> wait,waitpid,        pthread_join <br> kill,                pthread_cancel<br> atexit                 pthread_clean,<br> exec                system---&gt;fork-&gt;exec (ls)<br>                     <br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/339938157be6ec2e37619a1c8cd8fcb2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">odoo17 在线聊天报错提示 Couldn‘t bind the websocket...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bba874018c4c804585f0c1d3040e511b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">苹果macbook，MacOS 11,12,13,14,15 跳过监管锁(配置锁)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>