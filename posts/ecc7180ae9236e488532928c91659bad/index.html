<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之探索“栈”的奥秘 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ecc7180ae9236e488532928c91659bad/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之探索“栈”的奥秘">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
栈的有关概念
栈的使用 栈的模拟实现
栈的应用场景
改变元素的序列
将递归转化为循环 栈的相关刷题 20. 有效的括号
150. 逆波兰表达式求值
牛客网——JZ31 栈的压入、弹出序列
155. 最小栈
栈的有关概念 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈。 出栈：栈的删除操作叫做出栈。
下面是栈以及其有关操作的图示：
栈的使用 栈的基本方法 方法功能Stack()构造一个空的栈E push(E e)将e入栈，并返回eE pop()得到并删除栈顶元素E peek()获取栈顶元素int size()获取栈中有效元素的个数boolean empty()检测栈是否为空 下面是上面方法的使用：
public class Test { public static void main(String[] args) { // 构造方法：构造一个空栈 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 判断栈是否为空 System.out.println(stack.empty()); // 开始往栈区增加元素：压栈/入栈 stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); // 获取栈顶元素 System.out.println(stack.peek()); // 得到并删除栈顶元素 System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-19T00:00:00+08:00">
    <meta property="article:modified_time" content="2024-06-19T00:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之探索“栈”的奥秘</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<strong><a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A0%88%E7%9A%84%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">栈的有关概念</a></p> 
<p id="%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">栈的使用 </a></p> 
<p id="%E6%A0%88%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">栈的模拟实现</a></p> 
<p id="%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">栈的应用场景</a></p> 
<p id="%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97-toc" style="margin-left:40px;"><a href="#%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97" rel="nofollow">改变元素的序列</a></p> 
<p id="%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF%C2%A0" rel="nofollow">将递归转化为循环 </a></p> 
<p id="%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3%E5%88%B7%E9%A2%98%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3%E5%88%B7%E9%A2%98%C2%A0" rel="nofollow">栈的相关刷题 </a></p> 
<p id="20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-toc" style="margin-left:40px;"><a href="#20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7" rel="nofollow">20. 有效的括号</a></p> 
<p id="150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-toc" style="margin-left:40px;"><a href="#150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC" rel="nofollow">150. 逆波兰表达式求值</a></p> 
<p id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94JZ31%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97-toc" style="margin-left:40px;"><a href="#%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94JZ31%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97" rel="nofollow">牛客网——JZ31 栈的压入、弹出序列</a></p> 
<p id="155.%20%E6%9C%80%E5%B0%8F%E6%A0%88-toc" style="margin-left:40px;"><a href="#155.%20%E6%9C%80%E5%B0%8F%E6%A0%88" rel="nofollow">155. 最小栈</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%A0%88%E7%9A%84%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5"><span style="color:#fe2c24;">栈的有关概念</span></h2> 
<p>栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。</p> 
<p>压栈：栈的插入操作叫做进栈/压栈/入栈。 出栈：栈的删除操作叫做出栈。</p> 
<p>下面是栈以及其有关操作的图示：</p> 
<p><img alt="" height="901" src="https://images2.imgbox.com/43/e5/ADTITwJr_o.png" width="1200"></p> 
<p><img alt="" height="741" src="https://images2.imgbox.com/5a/4d/XapCuK6r_o.png" width="1200"></p> 
<h2 id="%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0"><span style="color:#fe2c24;">栈的使用 </span></h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   栈的基本方法 
 </caption><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>Stack()</td><td>构造一个空的栈</td></tr><tr><td>E push(E e)</td><td>将e入栈，并返回e</td></tr><tr><td>E pop()</td><td>得到并删除栈顶元素</td></tr><tr><td>E peek()</td><td>获取栈顶元素</td></tr><tr><td>int size()</td><td>获取栈中有效元素的个数</td></tr><tr><td>boolean empty()</td><td>检测栈是否为空</td></tr></tbody></table> 
<p>下面是上面方法的使用：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 构造方法：构造一个空栈
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        // 判断栈是否为空
        System.out.println(stack.empty());
        // 开始往栈区增加元素：压栈/入栈
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.push(4);
        stack.push(5);
        // 获取栈顶元素
        System.out.println(stack.peek());
        // 得到并删除栈顶元素
        System.out.println(stack.pop());
        // 获取栈中有效的元素个数
        int size = stack.size();
        System.out.println(size);
        // 开始利用pop方法遍历栈
        for (int i = 0; i &lt; size; i++) {
            // 得到并删除栈顶元素
            System.out.println(stack.pop());
        }
        // 判断栈是否为空
        System.out.println(stack.empty());
    }
}
</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="395" src="https://images2.imgbox.com/c4/3b/Yu6919EQ_o.png" width="873"></p> 
<h2 id="%E6%A0%88%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span style="color:#fe2c24;">栈的模拟实现</span></h2> 
<p>模拟栈，就只需要实现模拟我们上面使用的那几种方法即可。</p> 
<p>下面是用数组模拟栈的实现：</p> 
<pre><code class="language-java">// 用数组模拟实现栈
public class MyStack {
   public int[] elem;
   public int usedSzie;

   public MyStack() {
       // 为了方便测试给三个空间
       this.elem = new int[3];
   }

   // 入栈
   public boolean push(int val) {
       // 先判断栈空间是否满了
       if (this.usedSzie == this.elem.length) {
           return false;
       }
       this.elem[(this.usedSzie)++] = val;
       return true;
   }

   // 出栈
   public int pop() throws StackIsEmptyException {
       // 先判断栈是否为空
       if (empty()) {
           throw new StackIsEmptyException("栈为空异常!");
       } else {
          this.usedSzie--;
          return this.elem[this.usedSzie];
       }
   }

   // 获取栈顶元素
   public int peek() {
       // 先判断栈是否为空
       if (empty()) {
           throw new StackIsEmptyException("栈为空异常!");
       } else {
           return this.elem[this.usedSzie-1];
       }
   }

   public int size() {
       return this.usedSzie;
   }

   public boolean empty() {
       return this.usedSzie == 0;
   }
}
</code></pre> 
<p>异常代码：</p> 
<pre><code class="language-java">public class MyStackIsEmptyException extends RuntimeException {
    public MyStackIsEmptyException(String msg) {
        super(msg);
    }
    public MyStackIsEmptyException() {
        super();
    }
}
</code></pre> 
<p>除了用数组之外，还可以用链表来模拟实现：</p> 
<pre><code class="language-java">// 用链表来模拟实现栈
public class MyStack {
    public LinkedList&lt;Integer&gt; linkedList;

    public MyStack () {
        this.linkedList = new LinkedList&lt;&gt;();
    }

    // 入栈
    public void push(int val) {
        // 直接尾插就行
        this.linkedList.addLast(val);
    }

    // 出栈
    public int pop() throws MyStackIsEmptyException {
        // 先判断链表是否为空
        if (empty()) {
            throw new MyStackIsEmptyException("栈为空异常！");
        }
        // 移除最后一个节点
        int ret = this.linkedList.getLast(); // 得到最后一个元素
        this.linkedList.removeLast();
        return ret;
    }

    // 获取栈顶元素
    public int peek() throws MyStackIsEmptyException {
        // 先判断链表是否为空
        if (empty()) {
            throw new MyStackIsEmptyException("栈为空异常！");
        }
        return this.linkedList.getLast();
    }

    public int size() {
        return this.linkedList.size();
    }

    public boolean empty() {
        return this.linkedList.size() == 0;
    }
}
</code></pre> 
<p>当然，这里的链表没有自己实现，而是用的Java自身提供的。那么也意味着上面的数组实现，可以用顺序表来模拟，也是一样的。 </p> 
<h2 id="%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#fe2c24;">栈的应用场景</span></h2> 
<h3 id="%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97"><span style="color:#38d8f0;">改变元素的序列</span></h3> 
<p>例1： </p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/ea/ed/VbAD9pqm_o.png" width="1200"></p> 
<p>我们知道栈要遵循一个规律：先进后出，后进先出。那么只要 先进去的 在 后进去的 前面出来，则肯定是错误的。</p> 
<blockquote> 
 <p>A选项，正确。当1进去栈，接着再出来，后面的接着全部进去，再一个一个的出来，那么结果就是 1、4、3、2。</p> 
 <p>B选项，正确。1进去，接着2进去，再出来，一直循环这个过程到全部元素进去，最后1再出来，那么结果就是2、3、4、1。 </p> 
 <p>C选项，错误。3 要出来，说明1 和 2肯定已经进去了。既然3出去了，栈中就只有1和2了，并且2在栈顶，那么就不可能出现1 比 2先出去的情况。</p> 
 <p>D选项，正确。3 要出来，肯定 1 和 2 进去了。接着 4再进去、出来。最后就是2 出来，1出来。那么结果就是3、4、2、1。</p> 
</blockquote> 
<p>例2：</p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/65/1b/IltZOVCC_o.png" width="1200"></p> 
<p>这个答案就很明显了是B。</p> 
<h3 id="%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF%C2%A0"><span style="color:#38d8f0;">将递归转化为循环 </span></h3> 
<p>例如：逆序打印单链表。</p> 
<p>正常打印单链表是从头节点开始一直遍历到 null 就停下。但是现在要逆序打印，就是从尾节点开始打印这个单链表。</p> 
<p>方式一，递归：</p> 
<pre><code class="language-java">    // 逆序打印节点的值
    public void printList(ListNode head) {
        //if (head == null) {
        //    // 抛异常
        //}
        // 找到尾节点就停止
        if (head.next != null) {
            printList(head.next);
        }
        System.out.print(head.val+" ");
    }</code></pre> 
<p>方式二，栈：</p> 
<p>要逆序打印单链表，就是从尾节点开始打印，而尾节点是后面进来的。即后面来的先打印，前面的后打印。这个就可以用栈来实现。</p> 
<pre><code class="language-java">    public void printList(ListNode head) {
        /*if (head == null) {
            // 抛异常
        }*/
        // 创建一个栈
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        // 遍历链表，把链表的节点放到栈中
        while (head != null) {
            stack.push(head.val);
            head = head.next;
        }
        // 开始用栈来打印
        while (!stack.empty()) {
            System.out.print(stack.pop()+" ");
        }
    }
</code></pre> 
<h2 id="%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3%E5%88%B7%E9%A2%98%C2%A0"><span style="color:#fe2c24;">栈的相关刷题 </span></h2> 
<h3 id="20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><a class="link-info" href="https://leetcode.cn/problems/valid-parentheses/" rel="nofollow" title="20. 有效的括号">20. 有效的括号</a></h3> 
<blockquote> 
 <p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p> 
 <p>有效字符串需满足：</p> 
 <ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>s = "()"
<strong>输出：</strong>true
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>s = "()[]{}"
<strong>输出：</strong>true
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>s = "(]"
<strong>输出：</strong>false

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li></ul> 
</blockquote> 
<p>括号不匹配有三种情况：</p> 
<p>1、左括号比右括号多</p> 
<p>2、右括号比左括号多</p> 
<p>3、左右括号不匹配 </p> 
<p>当我们去遍历这个字符串时，会发现一个规律：后遇到的左括号 会比 前遇到的左括号 先匹配。</p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/34/e9/pa8GGRuZ_o.png" width="1094"></p> 
<p>思路： 先遇到的左括号储存到栈中，直至遇到了右括号，再将栈顶元素拿出来和这个右括号进行匹配，看看是否成功。 成功就继续往后走，失败则返回false。直至遍历完成或者栈为空（右括号多于左括号）。</p> 
<pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        // 创建一个栈
        Stack&lt;Character&gt;  stack = new Stack&lt;&gt;();
        // 遍历字符串
        for (int i = 0; i &lt; s.length(); i++) {
            char ch = s.charAt(i);
            // 如果遇到左括号就入栈，如果遇到右括号就出栈
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            }else {
                // 出栈匹配
                // 判断栈是否为空
                if (stack.empty()) {
                    return false;
                } else {
                    // 开始匹配
                    char x = stack.pop();
                    // 如果匹配说明符合要求，继续往后走
                    if (x == '(' &amp;&amp; ch == ')') {
                        continue;
                    } else if (x == '[' &amp;&amp; ch == ']') {
                        continue;
                    } else if (x == '{' &amp;&amp; ch == '}') {
                        continue;
                    } else {
                        return false;
                    } 
                }
            }
        }
        // 判断栈是否为空
        if (stack.empty()) {
            // 栈为空说明全部匹配成功了
            return true;
        } else {
            // 还有括号没有匹配
            return false;
        } 
    }
}</code></pre> 
<h3 id="150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><a class="link-info" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/" rel="nofollow" title="150. 逆波兰表达式求值">150. 逆波兰表达式求值</a></h3> 
<p><a class="link-info" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" rel="nofollow" title="逆波兰表达式的介绍">逆波兰表达式的介绍</a></p> 
<blockquote> 
 <p>给你一个字符串数组 <code>tokens</code> ，表示一个根据逆波兰表示法表示的算术表达式。</p> 
 <p>请你计算该表达式。返回一个表示表达式值的整数。</p> 
 <p><strong>注意：</strong></p> 
 <ul><li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>tokens = ["2","1","+","3","*"]
<strong>输出：</strong>9
<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>tokens = ["4","13","5","/","+"]
<strong>输出：</strong>6
<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
<strong>输出：</strong>22
<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>"+"</code>、<code>"-"</code>、<code>"*"</code> 或 <code>"/"</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul> 
</blockquote> 
<p>逆波兰表达式（也称为后缀表达式）的计算通常与栈密切相关，因为栈能够非常自然地处理这种后进先出的操作顺序。不过，理论上讲，不使用栈也可以实现逆波兰表达式的计算，但可能需要更复杂的逻辑和额外的数据结构来模拟栈的功能。</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/7a/b1/eCGRcJcq_o.png" width="1200"></p> 
<p>思路：用栈来实现逆波兰表达式。遍历字符串数组，当遇到数字，则入栈；遇到运算符，则将栈顶的元素弹出作为右操作数，再将栈顶的元素弹出作为左操作数，计算完的值再入栈。</p> 
<pre><code class="language-java">class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();
        // 遍历字符串数组
        for (int i = 0; i &lt; tokens.length; i++) {
            // 判断这个字符串是否为数字
            // 数字难判断，但运算符很简单，因此可以转换角度来判断运算符
            if (!isOperator(tokens[i])) {
                // 是数字就入栈
                stack.push(tokens[i]);
            } else {
                // 开始运算
                int y = Integer.parseInt(stack.pop()); // 右操作数
                int x = Integer.parseInt(stack.pop()); // 左操作数 
                int result = 0;
                switch (tokens[i]) {
                    case "+" :
                        result = x+y;
                        break;
                    case "-" :
                        result = x-y;
                        break;
                    case "*" :
                        result = x*y;
                        break;
                    case "/" :
                        result = x/y;
                        break;
                }
                // 运算完的结果返回到栈中
                Integer j = result;
                stack.push(j.toString());
            }
        }
        // 返回栈中最后剩余的元素
        return Integer.parseInt(stack.pop());
    }
    private boolean isOperator(String s) {
        // 如果不是+、-、*、/，那就是数字字符
        return s.equals("+") || s.equals("-") || s.equals("*") || s.equals("/");
    }
}</code></pre> 
<p>注意：我们平常写的运算表达式是属于中缀表达式，即运算符在两个运算数的中间位置，还有前缀表达式和后缀表达式。我们这里的逆波兰表达式就是后缀表达式，即运算符在两个运算数的后面，而前缀表达式就是在两个运算数的前面，也称为波兰表达式。</p> 
<p>下面是中缀表达式转后缀表达式的详细过程：</p> 
<blockquote> 
 <p>9+(3-1) * 3+8 / 2，这个就是我们平常写的表达式。</p> 
 <p>转换成后缀表达式：<br> 1、将所有的运算符与运算数之间加上（）。即：((9+((3-1) * 3))+(8 / 2))<br> 2、将所有的运算符提到本级括号的外边去。即：((9((3 1)-  3)*)+(8 2) / )+<br> 3、最后将所有的括号全部去掉，就是后缀表达式。即：9 3 1 -  3 * + 8 2 / +</p> 
 <p>按照栈的特点去计算这个表达式的过程如下： </p> 
 <p><img alt="" height="688" src="https://images2.imgbox.com/f4/ea/CbwdGuB3_o.png" width="1200"></p> 
</blockquote> 
<h3 id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94JZ31%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><a class="link-info" href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="牛客网——JZ31 栈的压入、弹出序列">牛客网——JZ31 栈的压入、弹出序列</a></h3> 
<blockquote> 
 <p><strong>描述</strong></p> 
 <p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p> 
 <p>1. 0&lt;=pushV.length == popV.length &lt;=1000</p> 
 <p>2. -1000&lt;=pushV[i]&lt;=1000</p> 
 <p>3. pushV 的所有数字均不相同</p> 
 <p><strong>示例1</strong></p> 
 <p>输入：</p> 
 <pre>[1,2,3,4,5],[4,5,3,2,1]</pre> 
 <p>返回值：</p> 
 <pre>true</pre> 
 <p>说明：</p> 
 <pre>可以通过push(1)=&gt;push(2)=&gt;push(3)=&gt;push(4)=&gt;pop()=&gt;push(5)=&gt;pop()=&gt;pop()=&gt;pop()=&gt;pop()
这样的顺序得到[4,5,3,2,1]这个序列，返回true      </pre> 
 <p><strong>示例2</strong></p> 
 <p>输入：</p> 
 <pre>[1,2,3,4,5],[4,3,5,1,2]</pre> 
 <p>返回值：</p> 
 <pre>false
</pre> 
 <p>说明：</p> 
 <pre>由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false   </pre> 
</blockquote> 
<p>思路：模拟第一个数组入栈出栈时的样子，与第二个数组对比，看结果是否一致。</p> 
<pre><code class="language-java">public boolean IsPopOrder (int[] pushV, int[] popV) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int j = 0;
        // 将第一个数组入栈，与第二个数组进行对比，看是否一致
        for (int i = 0; i &lt; pushV.length; i++) {
            int x = stack.push(pushV[i]);
            if (x != popV[j]) {
                continue;
            } else {
                // 一致就继续往后比较，直至栈为空
                while (!stack.empty()) {
                    if (stack.peek() == popV[j]) {
                        stack.pop();
                        j++;
                    } else {
                        break;
                    }
                }
            } 
        }
        if (stack.empty()) {
            return true;
        }
        return false;
    }</code></pre> 
<h3 id="155.%20%E6%9C%80%E5%B0%8F%E6%A0%88"><a class="link-info" href="https://leetcode.cn/problems/min-stack/description/" rel="nofollow" title="155. 最小栈">155. 最小栈</a></h3> 
<blockquote> 
 <p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p> 
 <p>实现 <code>MinStack</code> 类:</p> 
 <ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul> 
 <p></p> 
 <p><strong>示例 1:</strong></p> 
 <pre><strong>输入：</strong>
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

<strong>输出：</strong>
[null,null,null,null,-3,null,0,-2]

<strong>解释：</strong>
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li></ul> 
</blockquote> 
<p>思路：既想要保持原数据不变，又要时刻维护最小数据，一个栈肯定是做不到的，要两个栈，一个普通栈，来存储元素，一个最小栈，来维护最小元素。</p> 
<pre><code class="language-java">class MinStack {

    Stack&lt;Integer&gt; stack; // 普通栈
    Stack&lt;Integer&gt; minStack; // 最小栈

    public MinStack() {
       stack = new Stack&lt;&gt;(); // 普通栈
       minStack = new Stack&lt;&gt;(); // 最小栈
    }
    
    public void push(int val) {
        // 首先得判断这个最小栈中是否有元素。
        // 如果啥也没有，那么第一个元素肯定是要入栈的
        // 因为第一个元素肯定既是最大的，也是最小的
        if (minStack.empty()) {
            minStack.push(val);
        } else {
            if (minStack.peek() &gt;= val) {
                minStack.push(val);
            }
        }
        // 普通栈就无需判断
        stack.push(val);
    }
    
    public void pop() {
        // 这里虽然删除的是普通栈的栈顶元素，
        // 但是如果普通栈的栈顶元素和最小栈一样，
        // 那么两者都得删除
    
        // 注意：这里的比较要用 equals，下面有解释
        if (stack.peek().equals(minStack.peek())) {
            stack.pop();
            minStack.pop();
        } else {
            stack.pop();
        }
    }
    
    public int top() {
        // 这里拿的是普通栈的栈顶元素
        return stack.peek();
    }
    
    public int getMin() {
        // 这里拿的是最小栈的栈顶元素
        return minStack.peek();
    }
}</code></pre> 
<p>注意：</p> 
<p>1、这里题目明确的说了   <code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用 。</p> 
<p>2、这里的比较之所以要用 equals() 方法，是因为当 LeetCode 给的测试用例不在 -128~127 之间时，会分配两个不同的对象。如果我们用 == 去比较的话，肯定是 false ，因此就只有两种解决方法：1、用 equals() 方法进行比较；2、将一方进行拆包的操作之后，再去比较两者之间的关系。</p> 
<p>下面这篇文章就讲述了 第二点中的来源：<a class="link-info" href="https://blog.csdn.net/2301_80854132/article/details/139441620?spm=1001.2014.3001.5502" title="同一个数字，但不同的对象">同一个数字，但不同的对象</a></p> 
<p>以上就是关于栈的经典题型了。总体难度虽然用栈来解决不是很大，但是要想到用栈的知识去解决，还是挺难的。所以栈的基本知识不能，但做题想到用栈解决就很难了。</p> 
<p>好啦！本期  数据结构之栈  的学习之旅就到此结束了！相信通过这篇文章的学习，你对栈的了解将会更进一步！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f589b225a13929da1aa155ae0a8cdd54/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">爬虫笔记12——网页爬取数据写入json文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b6a0e730e5be8e9b455822144137368/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RabbitMQ实践——使用死信机制对异常消息进行处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>