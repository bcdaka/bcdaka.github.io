<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql的mvcc详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bd14205301d7bbb85bd276f3eeabff0f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="mysql的mvcc详解">
  <meta property="og:description" content="一 MVCC的作用 1.1 mvcc的作用 1.MVCC（Multiversion Concurrency Control）多版本并发控制。即通过数据行的多个版本管理来实现数据库的并发控制，使得在InnoDB事务隔离级别下执行一致性读操作有了保障。
2.mysql中的InnoDB中实现了MVCC主要是为了提高数据库的并发性能，在无锁的情况下也能处理读写并发，大大提高数据库的并发度。
3..MySQl中只有InnoDB支持MVCC，其他存储引擎不支持
4.为了查询一些正在被其他事务更新的值的时候，能够查到它们被更新之前的值，这样做就能在查询的时候不必等待更新事务的提交。
在InnoDB中，会对增删改操作自动添加排它锁，因此两个事务不会出现脏写的情况，也就是不会出现两个事务交叉着对同一条记录进行修改，必须等待第一个事务提交才能进行第二个事务。
1.2 快照读与当前读的区别与联系 1.MVCC在InnoDB中的实现主要是为了提高数据库的并发性能，用更好的方式处理读写冲突，做到即使有读写冲突，也能不加锁实现非堵塞并发读，这个读指的是快照读而不是当前读。
2.当前读实质上是一种加锁的操作，是悲观锁的体现；而MVCC是采用乐观锁的一种方式
1.3 快照读 1.快照读，顾名思义读取的是一份快照数据，所以读到的并不一定是最新数据，可能是历史数据。
2.简单的select查询就是快照读，不加锁非阻塞读，降低数据库的开销。
3.但是快照读在隔离级别是串行化级别是没有意义的，因为串行化的sql都是排队执行的，不存在并发，所以就会变成当前读。
1.4 当前读 当前读获取的数据是最新数据，而且在读取时不能被其他修改的，所以会对读取的记录加锁来控制。
加锁的SELECT（共享或排它锁）或者对数据进行增删改操作（自动添加排它锁）都会进行当前读。
select * from ajisun where id &gt; 1 lock in share mode;// 或者select * from ajisun where id &gt;1 for update; 1.5 mvcc可以解决问题 读写之间的堵塞问题，提高事务的并发读写能力
降低了死锁的概率，MVCC采用了乐观锁的方式，读取数据的时候不需要加锁，对于写操作，也只要锁定必要的行
解决快照读问题，当查询数据库某个时间节点的快照的时候，只能查看到在这个节点之前提交的事务的结果而看不到时间点之后事务提交的更新结果
1.6 mvcc面试题：mvcc是怎么实现的 mvcc 是多版本并发控制，通过生成记录的历史版本解决幻读问题，并提高数据库的性能，无锁实现读写并发操作。
1.mvcc 的实现主要是通过三个隐藏字段，undo log以及readView 实现的。
2.三个隐藏字段分别是隐藏主键，事务ID，回滚指针。
3.undo log是各个事务修改同一条记录的时候生成的历史记录，方便回滚，同时会生成一条版本链。
4.readView是事务在进行快照读的时候生成的记录快照，用于判断数据的可见性。
5.描述readView 可见性判断规则。
二 MVCC实现原理 2.1 原理 ​ MVCC的实现依赖于：隐藏字段、Undo log、Read View 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-28T15:42:49+08:00">
    <meta property="article:modified_time" content="2023-09-28T15:42:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql的mvcc详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 MVCC的作用</h2> 
<h3>1.1 mvcc的作用</h3> 
<p>1<span style="color:#fe2c24;"><strong>.MVCC（Multiversion Concurrency Control）多版本并发控制</strong></span>。即<strong><span style="color:#fe2c24;">通过数据行的多个版本管理来实现数据库的并发控制</span></strong>，使得在InnoDB事务隔离级别下执行<code>一致性读</code>操作有了保障。</p> 
<p>2.mysql中的InnoDB中实现了<span style="color:#fe2c24;"><strong>MVCC主要是为了提高数据库的并发性能，在无锁的情况下也能处理读写并发</strong></span>，大大提高数据库的并发度。</p> 
<p>3..MySQl中只有InnoDB支持MVCC，其他存储引擎不支持</p> 
<p>4.为了查询一些正在被其他事务更新的值的时候，能够查到它们被更新之前的值，这样做就能在查询的时候不必等待更新事务的提交。</p> 
<p><span style="color:#fe2c24;"><strong>在InnoDB中，会对增删改操作自动添加排它锁，因此两个事务不会出现脏写的情况，也就是不会出现两个事务交叉着对同一条记录进行修改，必须等待第一个事务提交才能进行第二个事务。</strong></span></p> 
<h3>1.2 快照读与当前读的区别与联系</h3> 
<p>1.MVCC在InnoDB中的实现主要是<span style="color:#fe2c24;"><strong>为了提高数据库的并发性能，用更好的方式处理读写冲突</strong></span>，做到即使有读写冲突，也能<span style="color:#fe2c24;"><strong>不加锁实现非堵塞并发读，这个读指的是<code>快照读</code>而不是<code>当前读。</code></strong></span></p> 
<p>2<span style="color:#fe2c24;"><strong>.当前读实质上是一种加锁的操作，是悲观锁的体现；而MVCC是采用乐观锁的一种方式</strong></span></p> 
<h3><span style="color:#fe2c24;"><strong>1.3 快照读</strong></span></h3> 
<p>1.快照读，顾名思义读取的是一份快照数据，所以读到的并不一定是最新数据，可能是历史数据。</p> 
<p>2.简单的select查询就是快照读，不加锁非阻塞读，降低数据库的开销。</p> 
<p>3.但是快照读在隔离级别是串行化级别是没有意义的，因为串行化的sql都是排队执行的，不存在并发，所以就会变成当前读。</p> 
<h3><span style="color:#fe2c24;"><strong>1.4 当前读</strong></span></h3> 
<p>当前读获取的数据是最新数据，而且在读取时不能被其他修改的，所以会对读取的记录加锁来控制。</p> 
<p><code>加锁的SELECT（共享或排它锁）</code>或者<code>对数据进行增删改操作（自动添加排它锁）</code>都会进行<code>当前读。</code></p> 
<pre><code>select * from ajisun where id &gt; 1 lock in share mode;</code><code>// 或者</code><code>select * from ajisun where id &gt;1 for update;</code></pre> 
<h3 style="background-color:transparent;">1.5 mvcc可以解决问题</h3> 
<ol><li> <p><strong>读写之间的堵塞问题</strong>，提高事务的并发读写能力</p> </li><li> <p><strong>降低了死锁的概率</strong>，MVCC采用了乐观锁的方式，读取数据的时候不需要加锁，对于写操作，也只要锁定必要的行</p> </li><li> <p><strong>解决快照读问题</strong>，当查询数据库某个时间节点的快照的时候，只能查看到在这个节点之前提交的事务的结果而看不到时间点之后事务提交的更新结果</p> </li></ol> 
<h3>1.6 mvcc面试题：mvcc是怎么实现的</h3> 
<p>mvcc 是多版本并发控制，通过生成记录的历史版本解决幻读问题，并提高数据库的性能，无锁实现读写并发操作。</p> 
<p>1.mvcc 的实现主要是通过三个隐藏字段，undo log以及readView 实现的。</p> 
<p>2.三个隐藏字段分别是隐藏主键，事务ID，回滚指针。</p> 
<p>3.undo log是各个事务修改同一条记录的时候生成的历史记录，方便回滚，同时会生成一条版本链。</p> 
<p>4.readView是事务在进行快照读的时候生成的记录快照，用于判断数据的可见性。</p> 
<p>5.描述readView 可见性判断规则。</p> 
<h2>二  MVCC实现原理</h2> 
<h3>2.1 原理</h3> 
<p>​ MVCC的实现依赖于：<span style="color:#fe2c24;"><strong><code>隐藏字段</code>、<code>Undo log</code>、<code>Read View</code> </strong></span></p> 
<h3 style="background-color:transparent;"><span style="color:#fe2c24;"><strong>2.2 undo log</strong></span></h3> 
<h4><span style="color:#fe2c24;"><strong>2.2.1 undo Log的作用</strong></span></h4> 
<p>所谓的版本链就是在MVCC中，多个事务对同一行记录进行更新会产生多个历史快照，这些记录保存在Undo Log里，这些undo日志通过回滚指针串联在一起。</p> 
<p>undo log就是回滚日志，在insert/update/delete变更操作的时候生成的记录方便回滚。</p> 
<p>当进行insert操作的时候，产生的undo lo<span style="color:#fe2c24;"><strong>g只有在事务回滚的时候需要，如果不回滚在事务提交之后就会被删除。</strong></span></p> 
<p>当进行update和delete的时候，产生的undo log不仅仅在事务回滚的时候需要，在快照读的时候也是需要的，所以不会立即删除，<span style="color:#fe2c24;"><strong>只有等不再用到这个日志的时候才会被mysql purge线程统一处理掉（delete操作也只是打一个删除标记，并不是真正的删除)。</strong></span></p> 
<h4><span style="color:#fe2c24;"><strong>2.2.2 undo Log的组成</strong></span></h4> 
<p>​ undo log的版本链，对于使用InnoDB存储引擎的表来说，它的聚簇记录中包含两个必要的索引列：</p> 
<p>1.trx_id：每次事务对聚簇记录进行修改的时候，就会将该事务的id复制给<code>trx_id</code>隐藏列</p> 
<p>2.roll_pointer：每次对每条聚簇索引进行改动的时候，<span style="color:#fe2c24;"><strong>都会将旧的版本信息写入<code>undo log</code>中，通过回滚指针就能找到记录修改前的信息。</strong></span></p> 
<h4><span style="color:#fe2c24;"><strong>2.2.3 undo Log的案例</strong></span></h4> 
<p>1.假设两个事务id分别为10、20的事务分别对这条记录进行<code>Update</code>操作。</p> 
<p><img alt="" height="497" src="https://images2.imgbox.com/7e/97/pbDwFFmW_o.png" width="1172"></p> 
<p>2.每次对记录进行改动，都会记录一条<code>undo log</code>，每个<code>undo log</code>都包含创建它的事务id，每条undo log都会有一个<code>roll pointer</code>（<strong>INSERT操作不会有，因为插入没有更新的版本</strong>），这些<code>undo log</code>通过<code>roll pointer</code>连接起来，串成一个链表，这个链表就成为<code>undo log 版本链。</code></p> 
<p><code>3.如下图：</code></p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/de/3b/VGqqUz4K_o.png" width="842"></p> 
<h3 style="background-color:transparent;">2.3 隐藏字段</h3> 
<p>除了我们正常业务涉及的字段外，InnoDB在内部向数据库表中添加三个隐藏字段:</p> 
<p><strong>1.DB_TRX_ID</strong>：6-byte的事务ID。插入或更新行的最后一个事务的事务ID</p> 
<p><strong>2.DB_ROLL_PTR</strong>：7-byte的回滚指针。就是指向对应某行记录的上一个版本，在undo log中使用。</p> 
<p><strong>3.DB_ROW_ID</strong>：6-byte的隐藏主键。如果数据表中没有主键，那么InnoDB会自动生成单调递增的隐藏主键（表中有主键或者非NULL的UNIQUE键时都不会包含 DB_ROW_ID列）。</p> 
<p>如上面的表没有设计primary key,其中id/name/city是我们的业务字段，那么加上隐藏字段应该如下</p> 
<p> <img alt="" height="112" src="https://images2.imgbox.com/3c/3e/vc3Bjq49_o.png" width="942"></p> 
<h3>2.4  ReadView</h3> 
<h4>2.4.1 ReadView的作用</h4> 
<p><span style="color:#fe2c24;"><strong>ReadView 是事务快照读的时候产生的数据读视图</strong></span>，在该事务执行快照读的那一刻，会生成一个数据系统当前的快照，记录并维护系统当前活跃事务的id，事务的id值是递增的。</p> 
<p><code>Read View</code><strong>就是事务在使用MVCC机制在进行快照读操作时产生的快照，</strong><span style="color:#fe2c24;"><strong>ReadView 的最大作用就是判断数据的可见性，当某个事务执行快照读的时候，会对此记录创建一个ReadView 的视图</strong></span>，在整个事务期间根据某些条件判断该事务能够看到的版本链上的哪条历史数据。</p> 
<h4>2.4.2  ReadView的组成</h4> 
<ol><li> <p><strong>creator_id</strong>：创建这个Read View的事务id</p> </li><li> <p><strong>trx_ids</strong>：表示创建这个Read View的时候正在活跃的事务id列表</p> </li><li> <p><strong>up_limit_id</strong>：活跃的事务中最小的id</p> </li><li> <p><strong>low_limit_id</strong>：表示生成low_limit_id时系统应该分配给下一个事务的<code>id</code>值，low_limit_id是<strong>系统最大</strong>的事务id（而不是活跃的最大事务id）</p> </li></ol> 
<p><span style="color:#fe2c24;"><strong>***low_limit_id并不是trx_ids的最大值而是系统能够分配的事务id最大值，事务id是递增分配的，并且只有事务在进行增删改操作的时候才会分配事务ID。比如现在有1 2 5三个事务，那么id为5的事务提交后，一个新事务在生成ReadView的时候，trx_ids就包括1 2，up_limit_id就是1，low_limit_id就是6</strong></span></p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/e9/1d/OEeNjGD8_o.png" width="727"></p> 
<p>此时如果有事务创建Read View，则</p> 
<ul><li><strong>trx_ids</strong>=[trx2, trx3, trx5, trx8]</li><li><strong>up_limit_id</strong>=trx2</li><li><strong>low_limit_id</strong>=<strong>trx8+1</strong></li></ul> 
<h4>2.4.3  ReadView的判断流程</h4> 
<p>当查询一条数据的时候，系统</p> 
<ol><li>首先获取查询操作的事务的版本号</li><li>获取当前系统的<code>ReadView</code></li><li>将查询到的数据与<code>ReadView</code>中的事务版本号进行比较</li><li>如果不符合<code>ReadView</code>的规则，则通过<code>回滚指针</code>形成的<code>Undo Log版本链</code>从<code>undo log</code>中获取符合规则的历史快照</li><li>返回符合规则的数据</li></ol> 
<p>快照记录创建这个<strong><span style="color:#fe2c24;">Read View的事务id、活跃的事务中最小的id、系统最大的事务id，并且InnoDB会为每个事务构建了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID</span></strong>（活跃指的是启动了还没有提交），等到访问某条记录的时候，就可以<strong>根据上面记录的内容判断记录版本对当前事务可不可见</strong>：</p> 
<p>1.如果<code>Read View</code>的<code>creator_id</code>和<code>当前事务的id</code>相同，则意味着当前事务在访问它修改过的id，所以该记录版本可以被事务访问</p> 
<p>2.如果<code>当前访问版本记录的trx_id</code>小于<code>Read View</code>的<code>up_limit_id</code>，则意味着<strong>修改该数据版本的事务已经提交</strong>，所以该版本的记录可以被当前事务访问</p> 
<p>3.如果<code>当前访问版本记录的trx_id</code>大于等于<code>Read View</code>的<code>low_limit_id</code>，则意味着<strong>创建该数据版本的事务是在<code>ReadView</code>生成之后才出现的</strong>，因此当前事务不能访问</p> 
<p>4.如果<code>当前访问版本记录的trx_id</code>在<code>Read View</code>的<code>up_limit_id</code>和<code>low_limit_id</code>之间，则需要判断trx_id是否在<code>Read View</code>的<code>trx_ids</code>活跃事务列表中，如果在则说明事务还没有提交当前事务不能访问，否则可以访问</p> 
<p><strong>5.如果</strong><strong>某个版本对当前事务不可见，那么顺着版本链找到下个版本记录，然后继续上面的对比规则，直到找到版本链中的最后一个版本，如果最后一个版本都不可见，那么该条记录对此事务完全不可见，也就查不到这个记录。</strong></p> 
<h3 style="background-color:transparent;"><strong>2.5 不同隔离级别使用Readview</strong></h3> 
<p><strong>1.读未提交</strong>：能够读取未提交的事务修改的数据，所以直接读取最新的记录就可以，不必使用MVCC</p> 
<p><strong>2.读已提交</strong>：不能读取未提交的事务修改的数据，并且不能进行重复读取，事务中，每次快照读都会新生成一个快照和ReadView,这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</p> 
<p><strong>3.可重复读</strong>：不能读取未提交的事务修改的数据，并且能进行重复读取，所以<strong>只在第一次查询的时候获取一次<code>ReadView</code>，之后查询都只查看已经生成的<code>ReadView副本</code></strong></p> 
<p><strong>4.可串行化</strong>：InnoDB规定使用加锁的方式来访问记录，通过加锁的方式让所有sql都串行化执行了，也是读最新的，不存在快照读ReadView。</p> 
<p><a href="https://www.cnblogs.com/tod4/p/17384677.html" rel="nofollow" title="https://www.cnblogs.com/tod4/p/17384677.html">https://www.cnblogs.com/tod4/p/17384677.html</a></p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDYzMzM5MA==&amp;mid=2247484049&amp;idx=1&amp;sn=6c5c4c8cf2a089535c40ac4617387218&amp;chksm=cfd8ef50f8af66463764ff186e72a236bf6a833da321c77b2ae40a3b26f96e8f43e1050fc773#rd" rel="nofollow" title="MySQL进阶系列：多版本并发控制mvcc的实现">MySQL进阶系列：多版本并发控制mvcc的实现</a></p> 
<h3><strong>2.6  mvcc解决幻读问题</strong></h3> 
<p>MySQL在<code>Repeatable Read</code>隔离级别下是可以解决幻读问题的，解决的方案有两种：</p> 
<p>1.使用MVCC进行快照读，写使用<code>临键锁。</code><span style="color:#fe2c24;"><strong>添加的临键锁不会影响快照读，只会影响到<code>想要获取锁的读操作</code></strong></span></p> 
<p>2.读写加锁，也就是使用可串行化的隔离模式。</p> 
<h4>2.6.1 mvcc解决幻读</h4> 
<p>读操作利用<code>多版本并发控制</code>（<code>MVCC</code>），写操作加<code>锁。</code></p> 
<p><strong><span style="color:#fe2c24;"><code>MVCC</code>就是生成一个<code>ReadView</code>，通过<code>ReadView</code>能够找到符合条件的记录版本（历史版本由<code>undo log</code>提供查询），</span>查询语句执行查询已经提交的事务做出的更改，对于没由提交的事务和<code>ReadView</code>创建之后的事务做出的更改是看不到的</strong>。而写操作肯定是针对的<code>最新版本的记录</code>，因此<strong>读记录的历史版本和写操作的最新记录版本并不会冲突</strong>，也就是<strong>采用MVCC时，读写操作并不会冲突。</strong></p> 
<p>普通的SELECT语句在READ COMMITTED 和 REPEATABLE READ隔离级别下的读操作就是利用MVCC进行的读</p> 
<p>1.READ COMMITTED：由于不会读取没有提交的事务修改的数据版本，因此避免了脏读问题</p> 
<p>2.REPEATABLE READ：由于不会读取<code>Read View</code>创建之后的事务更改的数据(一个事务只有在第一次执行SELECT语句才会生成一个<code>Read View</code>，之后的SELECT语句都在复用)，因此避免了可重复读和<code>幻读问题。</code></p> 
<h4>2.6.2 通过加锁的方式</h4> 
<p>读、写操作都采用加锁的方式</p> 
<p>在一些业务场景中，不允许读取数据的历史版本，即每次都需要去读取磁盘中最新的数据，这样也就意味着<code>读操作</code>也需要和<code>写操作</code>一样排队执行。</p> 
<p>如此一来，<code>脏读</code>和<code>不可重复读</code>问题都得到了解决，因为读操作和写操作的串行执行，不会出现<strong>一个事务读取另一个未提交事务的数据</strong>以及<strong>一个事务读取过程中另一个事务修改数据提交导致前一个事务前后读取数据不一致的情况（第二个事务根本无法开始）</strong>。</p> 
<p>****但是，<code>幻读</code>问题有些尴尬，试想一个事务在进行读操作，因此给表中的一定范围内的数据加锁，但是另一个事务要写的这个<code>幻影数据</code>可不在这个范围里面，也就是两个读写操作并不会冲突，仍然会出现<code>幻读问题</code>，<span style="color:#fe2c24;"><strong>解决这一个问题的办法就是写操作使用<code>临键锁</code></strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee8ed62200758c9ae925d56e186f2cd8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle物化视图（Materialized View）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d50e4916e6c7c1bd7324c5b4c93adb36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【腾讯云 TDSQL-C Serverless 产品体验】基于TDSQL-C Serverless最佳实践助力企业降本增效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>