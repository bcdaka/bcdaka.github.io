<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;初阶】C&#43;&#43;模板编程入门：探索泛型编程的奥秘 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4e632a092c19035743f651053f200fc2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;初阶】C&#43;&#43;模板编程入门：探索泛型编程的奥秘">
  <meta property="og:description" content="📝个人主页🌹：Eternity._
⏩收录专栏⏪：C&#43;&#43; “ 登神长阶 ”
🤡往期回顾🤡：C&#43;&#43;内存管理
🌹🌹期待您的关注 🌹🌹
❀C&#43;&#43;模板初阶 📒1. 为什么需要模板？📒2. 函数模板🌈函数模板概念🌈函数模板的原理🌈函数模板的实例化🌙隐式实例化🌞显式实例化 🌈模板参数的匹配原则 📒3. 类模板🎈类模板的定义格式🎩类模板的实例化 🔥4. 总结拓展拓展：🐫驼峰命名法 前言：在C&#43;&#43;编程世界中，模板是一个强大的工具，它使得程序员能够编写更加通用、灵活和可重用的代码。通过模板，我们可以编写与类型无关的代码，这些代码可以在编译时根据所需的具体类型进行实例化。本文将带你走进C&#43;&#43;模板的初阶世界，探索泛型编程的基石
泛型编程： 编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。
📒1. 为什么需要模板？ 我们来看看之前如何实现一个交换函数
// 函数重载 void Swap(int&amp; left, int&amp; right) { int temp = left; left = right; right = temp; } void Swap(double&amp; left, double&amp; right) { double temp = left; left = right; right = temp; } void Swap(char&amp; left, char&amp; right) { char temp = left; left = right; right = temp; } int main() { int a = 1, b = 9; double c = 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-30T08:00:00+08:00">
    <meta property="article:modified_time" content="2024-05-30T08:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;初阶】C&#43;&#43;模板编程入门：探索泛型编程的奥秘</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>📝个人主页🌹：<a href="https://blog.csdn.net/EterNity_TiMe_?type=blog">Eternity._</a><br> ⏩收录专栏⏪：<a href="http://t.csdnimg.cn/rM7cw" rel="nofollow">C++ “ 登神长阶 ”</a><br> 🤡往期回顾🤡：<a href="http://t.csdnimg.cn/HHuNe" rel="nofollow">C++内存管理</a><br> 🌹🌹期待您的关注 🌹🌹</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2d/87/nkwPpbH6_o.gif" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6a/09/C2utMhGd_o.gif" alt="在这里插入图片描述"><br> </p> 
<div class="toc"> 
 <h4>❀C++模板初阶</h4> 
 <ul><li><a href="#1__15" rel="nofollow">📒1. 为什么需要模板？</a></li><li><a href="#2__60" rel="nofollow">📒2. 函数模板</a></li><li><ul><li><a href="#_61" rel="nofollow">🌈函数模板概念</a></li><li><a href="#_83" rel="nofollow">🌈函数模板的原理</a></li><li><a href="#_90" rel="nofollow">🌈函数模板的实例化</a></li><li><ul><li><a href="#_95" rel="nofollow">🌙隐式实例化</a></li><li><a href="#_120" rel="nofollow">🌞显式实例化</a></li></ul> 
   </li><li><a href="#_144" rel="nofollow">🌈模板参数的匹配原则</a></li></ul> 
  </li><li><a href="#3__171" rel="nofollow">📒3. 类模板</a></li><li><ul><li><a href="#_174" rel="nofollow">🎈类模板的定义格式</a></li><li><a href="#_220" rel="nofollow">🎩类模板的实例化</a></li></ul> 
  </li><li><a href="#4__231" rel="nofollow">🔥4. 总结拓展</a></li><li><ul><li><a href="#_232" rel="nofollow">拓展：🐫驼峰命名法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p><strong>前言：在C++编程世界中，模板是一个强大的工具，它使得程序员能够编写更加通用、灵活和可重用的代码。通过模板，我们可以编写与类型无关的代码，这些代码可以在编译时根据所需的具体类型进行实例化。本文将带你走进C++模板的初阶世界，探索泛型编程的基石</strong></p> 
<blockquote> 
 <p><strong>泛型编程：</strong> 编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。</p> 
</blockquote> 
<hr> 
<h2><a id="1__15"></a>📒1. 为什么需要模板？</h2> 
<p>我们来看看之前如何实现一个交换函数</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 函数重载</span>
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">int</span> temp <span class="token operator">=</span> left<span class="token punctuation">;</span>
	 left <span class="token operator">=</span> right<span class="token punctuation">;</span>
	 right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 	 <span class="token keyword">double</span> temp <span class="token operator">=</span> left<span class="token punctuation">;</span>
	 left <span class="token operator">=</span> right<span class="token punctuation">;</span>
	 right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">char</span> temp <span class="token operator">=</span> left<span class="token punctuation">;</span>
	 left <span class="token operator">=</span> right<span class="token punctuation">;</span>
	 right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> c <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">8.9</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> e <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token char">'b'</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">Swap</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">Swap</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <ul><li>我们虽然能用函数重载来解决这个问题，但是函数代码冗余</li><li>仅仅是类型的不同，每当出现新类型时，就需要增加对应的函数</li><li>代码的可维护性比较低，一个出错可能所有的重载均出错</li></ul> 
</blockquote> 
<p><strong>在编程中，我们经常遇到需要处理不同类型数据的场景。为了处理这些类型，我们通常需要编写多个函数或类，<code>每个函数或类都针对特定的数据类型进行实现。这不仅增加了代码的冗余度，也降低了代码的可维护性和可重用性</code>。模板的引入就是为了解决这个问题。通过使用模板，我们可以编写与类型无关的代码，这些代码可以在编译时根据所需的具体类型进行实例化，从而生成针对特定类型的代码</strong></p> 
<hr> 
<h2><a id="2__60"></a>📒2. 函数模板</h2> 
<h3><a id="_61"></a>🌈函数模板概念</h3> 
<p>根据上面的示例代码我们能够用模板修改</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 T temp <span class="token operator">=</span> left<span class="token punctuation">;</span>
	 left <span class="token operator">=</span> right<span class="token punctuation">;</span>
	 right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-cpp">格式：<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>  T 表示类型
</code></pre> 
<p>template &lt; typename T&gt; <code>声明了一个模板参数T，它表示任意类型</code> 。在函数参数和返回类型中，我们都使用了T，这样该函数就可以处理任何类型的数据了<br> <strong>有了这个函数就能实现上述三个交换函数</strong></p> 
<blockquote> 
 <p><strong>注意：</strong> typename是用来定义模板参数关键字，也可以使用class<br> (切记：<code>不能使用struct代替class</code>)</p> 
</blockquote> 
<hr> 
<h3><a id="_83"></a>🌈函数模板的原理</h3> 
<blockquote> 
 <p><code>函数模板是一个蓝图，它本身并不是函数</code>，是编译器用使用方式产生特定具体类型函数的模具。所以其实<code>模板就是将本来应该我们做的重复的事情交给了编译器</code></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/80/ad/MuSUUjFh_o.png" alt="在这里插入图片描述"><br> 在编译器编译阶段，对于模板函数的使用，<code>编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用</code>。比如：<strong>当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此</strong></p> 
<hr> 
<h3><a id="_90"></a>🌈函数模板的实例化</h3> 
<blockquote> 
 <p>用不同类型的参数使用函数模板时，称为函数模板的实例化<br> <strong>模板参数实例化分为：<code>隐式实例化</code>和<code>显式实例化</code></strong></p> 
</blockquote> 
<hr> 
<h4><a id="_95"></a>🌙隐式实例化</h4> 
<p><strong>隐式实例化：让编译器根据实参推演模板参数的实际类型</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 隐式实例化</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> a2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> d1 <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">,</span> d2 <span class="token operator">=</span> <span class="token number">20.0</span><span class="token punctuation">;</span>
	<span class="token function">Add</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> a2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Add</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 在这里要注意一点，在模板中，编译器一般不会进行类型转换操作</span>
	<span class="token comment">//Add(a1, d1); false</span>
	<span class="token comment">// 虽然编译器不会进行类型转换，但是我们能自己来强制转化或者显式实例化</span>
	<span class="token function">Add</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>模板参数列表中只有一个T时，无法将两个类型不同的放在一起推演，编译器无法确定此处到底该将T确定什么类型而报错</strong></p> 
<hr> 
<h4><a id="_120"></a>🌞显式实例化</h4> 
<p><strong>显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 显式实例化</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> a2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> d1 <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">,</span> d2 <span class="token operator">=</span> <span class="token number">20.0</span><span class="token punctuation">;</span>
	<span class="token comment">// 显式实例化</span>
	<span class="token generic-function"><span class="token function">Add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <ul><li>如果类型不匹配，编译器会尝试进行隐式类型转换</li><li>如果无法转换成功编译器将会报错</li></ul> 
</blockquote> 
<hr> 
<h3><a id="_144"></a>🌈模板参数的匹配原则</h3> 
<blockquote> 
 <p>模板参数的匹配原则：</p> 
 <ul><li>🌹一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数</li><li>🌸对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板</li><li>🌻模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</li></ul> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">// 专门处理int的加法函数</span>
<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 通用加法函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">Add</span><span class="token punctuation">(</span>T left<span class="token punctuation">,</span> T right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1314</span><span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 与非模板函数匹配，优先调用非模板函数</span>
	<span class="token generic-function"><span class="token function">Add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1314.0</span><span class="token punctuation">,</span> <span class="token number">520.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用编译器特化的Add版本</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong><code>int Add</code>能够和<code>T Add</code>同时存在，在调用函数时若参数和非模板函数匹配，那么编译器会优先调用非模板函数若非模板函数；不匹配或模板函数更匹配，那么编译器会优先调用模板函数</strong></p> 
</blockquote> 
<hr> 
<h2><a id="3__171"></a>📒3. 类模板</h2> 
<blockquote> 
 <p><strong>类模板是对一批仅成员数据类型不同的类的抽象。通过为这一批类组成的类家族创建一个类模板，并提供一套程序代码，程序员可以生成多种具体的类，从而显著提高编程效率</strong></p> 
</blockquote> 
<h3><a id="_174"></a>🎈类模板的定义格式</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Tn</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">pxt</span><span class="token comment">//类模板名</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 类内成员定义</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们来定义一个简单的顺序表</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Vector</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Vector</span><span class="token punctuation">(</span>size_t capacity <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_pData</span><span class="token punctuation">(</span><span class="token keyword">new</span> T<span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_capacity</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token comment">// 使用析构函数演示：在类中声明，在类外定义。</span>
	<span class="token operator">~</span><span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t pos<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> _size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> _pData<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	T<span class="token operator">*</span> _pData<span class="token punctuation">;</span>
	size_t _size<span class="token punctuation">;</span>
	size_t _capacity<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 注意：类模板中函数放在类外进行定义时，需要加模板参数列表</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">//这里不要忘记带上</span>
Vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_pData<span class="token punctuation">)</span>
		<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _pData<span class="token punctuation">;</span>
	_size <span class="token operator">=</span> _capacity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>关于类模板其实就是将原来实际类型的位置变成<code>T</code></strong></p> 
<h3><a id="_220"></a>🎩类模板的实例化</h3> 
<p><strong>类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类</strong></p> 
<p><strong>关于<code>类模板的实例化必须显示实例化，类模板没有隐式推演</code></strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// Vector类名，Vector&lt;int&gt;才是类型</span>
Vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
Vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="4__231"></a>🔥4. 总结拓展</h2> 
<h3><a id="_232"></a>拓展：🐫驼峰命名法</h3> 
<p><strong>🐫驼峰命名法（CamelCase）：</strong> 是电脑程序编写时常用的一套命名规则，<strong>通过混合使用大小写字母来构成变量、函数、类名等的名字。这种命名方式有助于提高代码的可读性和可维护性</strong></p> 
<blockquote> 
 <p>驼峰命名法在多种编程语言中都有广泛应用，如Java、C#、JavaScript、Python等。在编写代码时，<strong>根据命名对象的类型（如变量、函数、类等）选择合适的驼峰命名法可以提高代码的可读性和可维护性！！！</strong></p> 
</blockquote> 
<hr> 
<p><strong>🐼命名规则：</strong> 当变量名、函数名或类名由多个单词组成时，第一个单词以小写字母开始，从第二个单词开始以后的每个单词的首字母都采用大写字母。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 例如：</span>
myFirstName
printEmployeePaychecks
</code></pre> 
<hr> 
<p><strong>🐋驼峰命名法的分类</strong></p> 
<p><strong>🐟小驼峰法（lower camel case）：</strong></p> 
<blockquote> 
 <ul><li>命名规则：第一个单词首字母小写，后续单词首字母大写</li><li>使用场景：常用于<code>变量名、方法名、属性名</code>等</li><li>示例：myStudentCount、getUserName()、userModel</li></ul> 
</blockquote> 
<p><strong>🐬大驼峰法（upper camel case）：</strong></p> 
<blockquote> 
 <ul><li>命名规则：所有单词的首字母均大写。</li><li>使用场景：常用于<code>类名、接口名、常量名</code>等。</li><li>示例：DataBaseUser、UserService</li></ul> 
</blockquote> 
<hr> 
<p><strong>🐷优点</strong></p> 
<blockquote> 
 <ul><li><strong>可读性好：</strong> 驼峰命名法通过大小写来区分单词，使得代码更容易阅读和理解</li><li><strong>易于书写和记忆：</strong> 采用统一的命名规则可以提高代码的一致性和可维护性</li><li><strong>符合编程语言的习惯：</strong> 通过明确的命名规则，可以减少变量、函数、类等名称之间的冲突</li></ul> 
</blockquote> 
<hr> 
<p><strong>🐨注意事项</strong></p> 
<blockquote> 
 <ul><li>在使用驼峰命名法时，需要<strong>注意单词之间的分隔，避免使用下划线或其他特殊字符</strong></li><li>对于类名、接口名等，建议使用大驼峰法，以突出其重要性</li><li>在编写代码时，应保持命名的一致性，避免混用不同的命名方式</li></ul> 
</blockquote> 
<p><strong>总之，驼峰命名法是一种简单、清晰、易读的命名方式，在程序编写中被广泛使用。通过合理使用驼峰命名法，可以提高代码的可读性和可维护性，降低编程错误率</strong></p> 
<hr> 
<p><strong>总结：</strong><br> <strong>在完成C++模板初阶的学习之后，我们可以深刻地感受到模板在C++编程中的强大与灵活性。模板作为C++编程语言的一个重要特性，为我们提供了一种在编译时生成特定类型代码的机制，从而实现了代码的重用和泛型编程。下节我们将进入C++ STL，对STL进行深入发掘</strong></p> 
<p><img src="https://images2.imgbox.com/79/b4/k4j9G0z3_o.gif" alt="在这里插入图片描述"><br> <strong>谢谢大家支持本篇到这里就结束了，祝大家天天开心！</strong><br> <img src="https://images2.imgbox.com/be/87/XFtVRfoK_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b270afcb26e8ca08a679a4e77d52c29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【架构之路】聊聊什么是微服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bf89cf13e1b8dd3031ab6d6b2564922/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Go 1.23新特性前瞻</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>