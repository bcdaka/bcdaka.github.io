<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构奇妙旅程之二叉平衡树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0f42211bcb5faf6a0ad8de6411be44fe/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构奇妙旅程之二叉平衡树">
  <meta property="og:description" content="꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏：xiaoxie的JAVA系列专栏——CSDN博客●&#39;ᴗ&#39;σσணღ*
我的目标:&#34;团团等我💪( ◡̀_◡́ ҂)&#34; ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 &#43; 收藏⭐️ &#43; 留言📝​&#43;关注（互三必回）!
一.二叉平衡树 1.二叉平衡树的概念 二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
它的左右子树也分别为二叉搜索树
从上述概念以及图中可以看出，二叉搜索树具有以下特性：
1. 二叉搜索树中最左侧的节点是树中最小的节点，最右侧节点一定是树中最大的节点
2. 采用中序遍历遍历二叉搜索树，可以得到一个有序的序列 2.二叉搜索树的主要操作 1. 查询 2.插入 1.插入的为一颗空树 直接插入即可
2.. 如果树不是空树，按照查找逻辑确定插入位置，插入新结点 根据二叉搜索树的性质插入节点,&#34;左小右大&#34;
对于树中的任意节点 n，其左子树中的所有节点的值都小于 n 的值，其右子树中的所有节点的值都大于 n 的值。在插入新节点时，需要按照二叉搜索树的性质找到合适的位置插入，保持树的有序性。插入节点后，需要调整树的结构，保证树仍然是一个二叉搜索树。 3.删除 假设删除节点cur那么cur有以下几种情况
1.cur 的左孩子为空,右孩子不为空,
2.cur 的右孩子为空,左孩子不为空.
3.cur 的左右孩子均为空.
4.cur 的左右孩子均不为空.
接下来博主将会通过画图的形式来演示这四种情况该如何删除节点
1.cur 的左孩子为空,右孩子不为空 2.cur 的右孩子为空,左孩子不为空. 3. cur 的左右孩子均为空. 4.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-10T12:42:21+08:00">
    <meta property="article:modified_time" content="2024-03-10T12:42:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构奇妙旅程之二叉平衡树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱<br> ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ ა<a href="https://blog.csdn.net/xiaoxie8023?spm=1000.2115.3001.5343" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶<br><a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/xiaoxie8023/article/details/134417887?spm=1001.2014.3001.5501" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 系列专栏：<a href="https://blog.csdn.net/xiaoxie8023/category_12482318.html?spm=1001.2014.3001.5482" title="xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*">xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*</a><br><span style="color:#fe2c24;"><strong>我的目标:"团团等我💪( ◡̀_◡́ ҂)" </strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!</strong></span></p> 
</blockquote> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/10/94/LYfwttNd_o.png" width="1080"></p> 
<h2>一.二叉平衡树</h2> 
<h3>1.二叉平衡树的概念</h3> 
<p>二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:</p> 
<p>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值</p> 
<p>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值</p> 
<p>它的左右子树也分别为二叉搜索树</p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/90/08/0l0LG8HV_o.png" width="1200"></p> 
<p>从上述概念以及图中可以看出，二叉搜索树具有以下特性：</p> 
<p>1. 二叉搜索树中最左侧的节点是树中最小的节点，最右侧节点一定是树中最大的节点</p> 
<p>2. 采用中序遍历遍历二叉搜索树，可以得到一个有序的序列 </p> 
<h3>2.二叉搜索树的主要操作</h3> 
<h4>1. 查询</h4> 
<p><img alt="" height="568" src="https://images2.imgbox.com/b2/be/FrE5gI1S_o.png" width="1200"></p> 
<h3>2.插入</h3> 
<h4>1.插入的为一颗空树</h4> 
<p>直接插入即可</p> 
<h4>2.. 如果树不是空树，按照查找逻辑确定插入位置，插入新结点</h4> 
<p>根据二叉搜索树的性质插入节点,"<strong><span style="color:#fe2c24;">左小右大</span></strong>"</p> 
<ol><li>对于树中的任意节点 n，其左子树中的所有节点的值都小于 n 的值，其右子树中的所有节点的值都大于 n 的值。</li><li>在插入新节点时，需要按照二叉搜索树的性质找到合适的位置插入，保持树的有序性。</li><li>插入节点后，需要调整树的结构，保证树仍然是一个二叉搜索树。</li></ol> 
<h3><span style="color:#0d0016;">3.删除</span></h3> 
<p>假设删除节点<strong><span style="color:#fe2c24;">cur</span></strong><span style="color:#0d0016;">那么</span><strong><span style="color:#fe2c24;">cur</span></strong><span style="color:#0d0016;">有以下几种情况</span></p> 
<p><span style="color:#0d0016;">1.cur 的左孩子为空,右孩子不为空,</span></p> 
<p><span style="color:#0d0016;">2.cur 的右孩子为空,左孩子不为空.</span></p> 
<p><span style="color:#0d0016;">3.cur 的左右孩子均为空.</span></p> 
<p><span style="color:#0d0016;">4.cur 的左右孩子均不为空.</span></p> 
<p><span style="color:#0d0016;">接下来博主将会通过画图的形式来演示这四种情况该如何删除节点</span></p> 
<h4><span style="color:#0d0016;">1.cur 的左孩子为空,右孩子不为空</span></h4> 
<h4><img alt="" height="762" src="https://images2.imgbox.com/28/69/9R0NEJHQ_o.png" width="1200"> 2.<span style="color:#0d0016;">cur 的右孩子为空,左孩子不为空.</span></h4> 
<p><img alt="" height="650" src="https://images2.imgbox.com/a0/eb/8WbYboWb_o.png" width="1200"></p> 
<h4>3. <span style="color:#0d0016;">cur 的左右孩子均为空.</span></h4> 
<p><img alt="" height="552" src="https://images2.imgbox.com/86/b0/FVM77Ggt_o.png" width="1200"></p> 
<h4>4. <span style="color:#0d0016;">cur 的左右孩子均不为空.</span></h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c3/c6/Zlq9so9G_o.png" width="1200"></p> 
<p>1.假设我们需要删除节点70,我们首先需要通过遍历二叉搜索树,找到70这个节点的对应位置.</p> 
<p>2.我们发现70这个节点,左右孩子均不为空,这个时候就不可以通过简单的删除就可以了,我们需要用到替换法,即在它的右子树中寻找中序下的第一个结点(关键码最小)，用它的值填补到被 删除节点中，再来处理该结点的删除问题.</p> 
<p>2.1这里解释一下为什么是在它的右子树中寻找中序下的第一个结点(关键码最小),当需要删除一个节点时，如果该节点有右子树，则可以在右子树中找到中序遍历下的第一个节点（即右子树中最小的节点）来替代当前节点。这是因为右子树中的所有节点都大于当前节点，而右子树中最小的节点又小于右子树中的所有其他节点，所以用右子树中的最小节点来替代当前节点可以保持二叉搜索树的性质不变。</p> 
<p>3.找到"<strong><span style="color:#fe2c24;">替罪羊</span></strong>"节点<strong><span style="color:#fe2c24;"> t </span></strong>后我们就需要<span style="color:#0d0016;">把要删除的节点cur使他的值等于</span><strong><span style="color:#fe2c24;">t </span>.</strong></p> 
<p><strong>4.最后删除节点t即可.</strong></p> 
<h3>4.二叉搜索树基本操作的Java代码实现</h3> 
<pre><code class="language-java">public class BinarySearchTree {
    public static class TreeNode {
        public TreeNode left;
        public TreeNode right;
        public int val;
        public TreeNode(int val) {
            this.val = val;
        }
    }
    public TreeNode root;
    /**
     * 查询节点是否存在
     * @author xiaoxie
     * @date 2024/3/6 10:44
     * @param val
     * @return boolean
     */
    public boolean search(int val) {
        if(root == null) {
            System.out.println();
            return false;
        }
        TreeNode cur = root;
        while (cur != null) {
            if(val &lt; cur.val) {
                cur = cur.left;
            } else if (val &gt; cur.val) {
                cur = cur.right;
            }else {
                System.out.println("找到了");
                return true;
            }
        }
        System.out.println("该节点"+val+"不存在");
        return false;
    }
    /**
     * 插入节点
     * @author xiaoxie
     * @date 2024/3/6 10:47
     * @param val
     */
    public void insertTreeNode(int val) {
        TreeNode node = new TreeNode(val);
        if(root == null) {
            root = node;
            return;
        }
        TreeNode parent = null;
        TreeNode cur = root;
        while (cur != null) {
            if(node.val &lt; cur.val) {
                parent = cur;
                cur = cur.left;
            } else if (node.val &gt; cur.val) {
                parent = cur;
                cur = cur.right;
            }else {
                System.out.println("节点值 " + val + " 已经存在于树中，不进行插入操作");
                return;
            }
        }
        //cur = null
        if(node.val &lt; parent.val) {
            parent.left = node;
        }else {
            parent.right = node;
        }
    }
    /**
     * 删除节点
     * 可以使用替罪羊的方法来实现
     * @author xiaoxie
     * @date 2024/3/6 12:15
     * @param val
     * @return boolean
     */
    public boolean remove(int val) {
        //首先先找到是哪一个节点
        if(root == null) {
            return false;
        }
        TreeNode parent = null;
        TreeNode cur = root;
        while (cur != null) {
            if(cur.val &gt; val) {
                parent = cur;
                cur = cur.left;
            } else if (cur.val &lt; val) {
                parent = cur;
                cur = cur.right;
            }else {
                break;
            }
        }
        //cur == null 说明要删除的节点不在二叉搜索树上
        if(cur == null) {
            return false;
        }
        // cur有多种情况
        //1.cur 没有左右孩子
        //2.cur 只有左孩子
        //3.cur 只有右孩子

        //4.cur 有左右孩子 -- 需要使用替罪羊的方法来删除
        if(cur.right != null &amp;&amp; cur.left != null) {
            TreeNode t = cur.right;
            TreeNode tp = cur;
            while (t.left != null) {
                tp = t;
                t = t.left;
            }
            cur.val = t.val;//使要删除的节点的值等于替罪羊节点
            //删除替罪羊节点
            if(tp.left == t) {
                tp.left = t.right;
            }else {//出现tp.right = t 的情况,t节点一开始就是叶子节点
                tp.right = t.right;
            }
        }else {
            //cur 只有右孩子
            if(cur.left == null &amp;&amp; cur.right != null){
                if(parent == null) {
                    root = cur.right;
                }else {
                    if(parent.val &lt; cur.val) {
                        parent.right = cur.right;
                    }else {
                        parent.left = cur.right;
                    }
                }
            }//cur 只有左孩子
            else if (cur.left != null &amp;&amp; cur.right == null) {
                if(parent == null) {
                    root = cur.left;
                }else {
                    if(parent.val &lt; cur.val) {
                        parent.right = cur.left;
                    }else {
                        parent.left = cur.left;
                    }
                }
            }
            //cur 没有左右孩子
            else  {
                if(parent == null) {
                    root = null;
                }else {
                    if(parent.val &lt; cur.val) {
                        parent.right = null;
                    }else {
                        parent.left = null;
                    }
                }
            }
        }
        return true;
    }
</code></pre> 
<h3> 5.性能分析</h3> 
<p>插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。 对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的深度 的函数，即结点越深，则比较次数越多。 但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树：</p> 
<h4>1.最优情况下，二叉搜索树为完全二叉树</h4> 
<p><img alt="" height="602" src="https://images2.imgbox.com/b1/bb/B3QmeNQb_o.png" width="1170"></p> 
<p>其平均比较次数为：log N;</p> 
<h4>2.最差情况下，二叉搜索树退化为单支树</h4> 
<p><img alt="" height="884" src="https://images2.imgbox.com/90/f3/qZZmoSIG_o.png" width="1188"></p> 
<p> 其平均比较次数为: 2 / N</p> 
<p>问题：如果退化成单支树，二叉搜索树的性能就失去了。那能否进行改进，不论按照什么次序插入关键码，都可以 是二叉搜索树的性能最佳？</p> 
<p>那就需要用到AVL树了通过旋转来使二叉搜索树变成完全二叉树的形式,这里博主就不过多的赘述了,如果感兴趣,可以为博主点上一个关注,在下一篇文章中,博主将详细解读AVL树</p> 
<p>感谢你的阅读!</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6cd6e032caec46f8de594dc30d6b374a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio下载安装及完全卸载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec070b528ce8cdb09622d886063d9011/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NLP:spacy库安装与zh_core_web_sm配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>