<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot3 实现webclient 通用方法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5016c9c35278f4757275233a3cd7fa43/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="SpringBoot3 实现webclient 通用方法">
  <meta property="og:description" content="前言： Spring Boot WebClient 是 Spring Framework 5 中引入的一个新的响应式 Web 客户端，用于异步和响应式地与外部服务进行通信。它是基于 Project Reactor 的响应式编程模型构建的，提供了比传统的 RestTemplate 更现代和强大的功能
介绍： 响应式编程模型：WebClient 是基于响应式编程模型的，这意味着它可以非阻塞地执行网络请求，并且能够与流式数据交互。这使得 WebClient 在处理大量并发请求时具有更高的性能和可伸缩性。
异步操作：WebClient 支持异步操作，这意味着它可以在等待网络响应的同时继续执行其他任务。这有助于提高应用程序的响应能力和吞吐量。
强大的 API：WebClient 提供了一个简洁而强大的 API，用于构建 HTTP 请求和接收响应。它支持多种 HTTP 方法（如 GET、POST、PUT、DELETE 等），并提供了丰富的功能来处理请求头、请求体、响应体等。
流式处理：WebClient 支持流式处理响应数据，这意味着它可以在接收响应数据的同时进行处理，而不需要将整个响应加载到内存中。这有助于处理大型响应数据，并减少内存使用。
错误处理：WebClient 提供了强大的错误处理机制，可以方便地处理网络请求中出现的错误和异常情况。它支持自定义错误处理器，可以根据需要定义错误处理逻辑。
集成性：WebClient 可以轻松地与 Spring Boot 的其他组件集成，如 Spring Data、Spring Security 等。这使得在构建基于微服务的响应式应用程序时更加方便和灵活。
替代 RestTemplate：虽然 RestTemplate 在以前的 Spring 版本中广泛使用，但 WebClient 被视为其现代替代品。WebClient 提供了更强大和灵活的功能，并且更适合与响应式编程模型一起使用
一、引包 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-23T11:15:44+08:00">
    <meta property="article:modified_time" content="2024-04-23T11:15:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot3 实现webclient 通用方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>前言：</h4> 
<p>Spring Boot WebClient 是 Spring Framework 5 中引入的一个新的响应式 Web 客户端，用于异步和响应式地与外部服务进行通信。它是基于 Project Reactor 的响应式编程模型构建的，提供了比传统的 RestTemplate 更现代和强大的功能</p> 
<h4>介绍：</h4> 
<ol><li> <p><strong>响应式编程模型</strong>：WebClient 是基于响应式编程模型的，这意味着它可以非阻塞地执行网络请求，并且能够与流式数据交互。这使得 WebClient 在处理大量并发请求时具有更高的性能和可伸缩性。</p> </li><li> <p><strong>异步操作</strong>：WebClient 支持异步操作，这意味着它可以在等待网络响应的同时继续执行其他任务。这有助于提高应用程序的响应能力和吞吐量。</p> </li><li> <p><strong>强大的 API</strong>：WebClient 提供了一个简洁而强大的 API，用于构建 HTTP 请求和接收响应。它支持多种 HTTP 方法（如 GET、POST、PUT、DELETE 等），并提供了丰富的功能来处理请求头、请求体、响应体等。</p> </li><li> <p><strong>流式处理</strong>：WebClient 支持流式处理响应数据，这意味着它可以在接收响应数据的同时进行处理，而不需要将整个响应加载到内存中。这有助于处理大型响应数据，并减少内存使用。</p> </li><li> <p><strong>错误处理</strong>：WebClient 提供了强大的错误处理机制，可以方便地处理网络请求中出现的错误和异常情况。它支持自定义错误处理器，可以根据需要定义错误处理逻辑。</p> </li><li> <p><strong>集成性</strong>：WebClient 可以轻松地与 Spring Boot 的其他组件集成，如 Spring Data、Spring Security 等。这使得在构建基于微服务的响应式应用程序时更加方便和灵活。</p> </li><li> <p><strong>替代 RestTemplate</strong>：虽然 RestTemplate 在以前的 Spring 版本中广泛使用，但 WebClient 被视为其现代替代品。WebClient 提供了更强大和灵活的功能，并且更适合与响应式编程模型一起使用</p> </li></ol> 
<h4>一、引包</h4> 
<pre><code> &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.0.0&lt;/version&gt;
    &lt;/parent&gt;

 &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

          &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
        &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre> 
<h4>二、通用方法</h4> 
<pre><code>package com.zc.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.List;

/**
 * @author zc
 * @date 2024/4/15 16:52
 * @desc
 */
@Component
public class WebClientUtil {

    private final WebClient webClient;

    @Autowired
    public WebClientUtil(WebClient.Builder webClientBuilder) {
         this.webClient = webClientBuilder.
                baseUrl("http://127.0.0.1:30003").
                build();
    }

    /**
     * get方法
     * @param url
     * @param responseType
     * @return
     * @param
     */
    public &lt;T&gt; T get(String url, Class&lt;T&gt; responseType) {
        return webClient.get().
                uri(url).
                accept(MediaType.APPLICATION_JSON).
                retrieve().
                bodyToMono(responseType).
                block();
    }

    /**
     * get多条数据
     * @param url
     * @param responseType
     * @return
     * @param &lt;T&gt;
     */
    public &lt;T&gt; List&lt;T&gt; list(String url, Class&lt;T&gt; responseType){
        return webClient.get().
                uri(url).
                accept(MediaType.APPLICATION_JSON).
                retrieve().
                bodyToFlux(responseType).collectList().block();
    }

    /**
     * post方法
     * @param url
     * @param requestBody
     * @param responseType
     * @return
     * @param
     */
    public &lt;T&gt; T post(String url, Object requestBody, Class&lt;T&gt; responseType) {
        return webClient.post().
                uri(url).
                contentType(MediaType.APPLICATION_JSON).
                bodyValue(requestBody).
                accept(MediaType.APPLICATION_JSON).
                retrieve().
                bodyToMono(responseType).
                block();
    }

    /**
     * put方法
     * @param url
     * @param requestBody
     * @param responseType
     * @return
     * @param
     */
    public &lt;T&gt; T put(String url, Object requestBody, Class&lt;T&gt; responseType){
        return webClient.put().
                uri(url).
                contentType(MediaType.APPLICATION_JSON).
                bodyValue(requestBody).
                accept(MediaType.APPLICATION_JSON).
                retrieve().
                bodyToMono(responseType).
                block();
    }

    /**
     * 删除方法
     * @param url
     * @param responseType
     * @return
     * @param
     */
    public &lt;T&gt; T delete(String url, Class&lt;T&gt; responseType){
        return webClient.delete().
                uri(url).
                accept(MediaType.APPLICATION_JSON).
                retrieve().
                bodyToMono(responseType).
                block();
    }
}
</code></pre> 
<h4>三、测试</h4> 
<p>客户端：</p> 
<pre><code>import com.alibaba.fastjson.JSON;
import com.zc.Application;
import com.zc.bean.HostDiffBean;
import com.zc.util.WebClientUtil;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.Date;
import java.util.List;

/**
 * @author zc
 * @date 2024/2/23 10:40
 * @desc
 */
@SpringBootTest(classes = Application.class)
public class TestFF {

    @Autowired
    private WebClientUtil webClientUtil;

    @Test
    public void test(){
        List&lt;HostDiffBean&gt; list= webClientUtil.list("compare/hostInfo?pageSize=10&amp;pageNum=1", HostDiffBean.class);
        System.out.println(JSON.toJSON(list));

        HostDiffBean hostDiffBean = new HostDiffBean();
        hostDiffBean.setIp("127.0.0.1");
        hostDiffBean.setHIp("127.0.0.2");
        hostDiffBean.setCreateTime(new Date());
        hostDiffBean.setSerialNumber("123");
        hostDiffBean.setHDeviceNo("no123");
        hostDiffBean.setDeviceNo("NO456");
        String result = webClientUtil.post("compare/hostInfo/add", hostDiffBean, String.class);
        System.out.println(result);
    }
}
</code></pre> 
<p>服务端：</p> 
<pre><code>import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.neusoft.bean.*;
import com.neusoft.service.HostDataCompareService;
import io.swagger.annotations.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * @author zc
 * @date 2024/3/14 15:00
 * @desc
 */
@RestController
@RequestMapping("/compare")
@Api(value = "数据对比接口", tags = "数据对比接口")
public class DataCompareController {

    @Autowired
    private HostDataCompareService hostDataCompareService;

    @GetMapping("/hostInfo")
    @ApiOperation(value = "宿主机数量差异查询", notes = "宿主机数量差异查询")
    public List&lt;HostInfoBean&gt; getHostInfoBeans(@RequestParam(name = "pageSize") @Validated @ApiParam(value = "每页数", required = true) Integer pageSize,
                                               @RequestParam(name = "pageNum") @Validated @ApiParam(value = "页数", required = true) Integer pageNum) {
        Page&lt;HostInfoBean&gt; list = hostDataCompareService.getHostInfoBeans(pageSize, pageNum);
        return list.getRecords();
    }

    @PostMapping("/hostInfo/add")
    @ApiOperation(value = "宿主机数量差异查询", notes = "宿主机数量差异查询")
    public String addHostInfoBeans(@RequestBody HostDiffBean hostDiffBean){
        return "success";
    }
}</code></pre> 
<p>结果：</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/52/1e/R2lJjwmb_o.png" width="1200"></p> 
<p></p> 
<h4>四、参考</h4> 
<p><a href="https://blog.csdn.net/weixin_35688430/article/details/119750922" title="SpringBoot - 网络请求客户端WebClient使用详解_springboot webclient-CSDN博客">SpringBoot - 网络请求客户端WebClient使用详解_springboot webclient-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/099ba5096bba8b06b65a5a581d5d7247/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端缓存】localStorage是同步还是异步的？为什么？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65e0b010e28080537d28d858dd5ebef0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript中的map()方法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>