<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;提高编程-07】----C&#43;&#43; STL常用算法之遍历算法和算术生成算法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f87dcc320ee58d62ae775b61d5306372/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;提高编程-07】----C&#43;&#43; STL常用算法之遍历算法和算术生成算法">
  <meta property="og:description" content="🎩 欢迎来到技术探索的奇幻世界👨‍💻
📜 个人主页：@一伦明悦-CSDN博客
✍🏻 作者简介： C&#43;&#43;软件开发、Python机器学习爱好者
🗣️ 互动与支持：💬评论 👍🏻点赞 📂收藏 👀关注&#43;
如果文章有所帮助，欢迎留下您宝贵的评论，
点赞加收藏支持我，点击关注，一起进步！
前言 STL（Standard Template Library）是C&#43;&#43;标准库的一部分，提供了丰富的数据结构和算法，用于处理数据和实现常见的计算任务。STL中的算法分为几类，包括遍历算法、修改算法、排序算法、查找算法、数值算法等，每类算法都有其特定的应用场景和功能。
正文 01-遍历算法之for_each用法 for_each 是一种遍历算法，用于对指定范围内的每个元素执行特定操作。它的使用方式相对简单，但需要传入一个函数或函数对象作为操作的执行体。以下是关于 for_each 的详细介绍和用法示例：
for_each 用法详解
语法
template &lt;class InputIterator, class Function&gt; Function for_each(InputIterator first, InputIterator last, Function f); InputIterator：表示容器或范围的起始位置的迭代器。Function：表示执行的操作，可以是函数或函数对象（仿函数）。 参数
first：表示要处理的范围的起始位置。last：表示要处理的范围的结束位置，不包含在范围内。f：表示要执行的操作，可以是函数或函数对象。 功能
for_each 对 [first, last) 范围内的每个元素执行 f 操作。
返回值
返回值类型为 Function，通常是传入的函数或函数对象 f。
示例
假设有一个整数数组 numbers，我们想要将每个元素加倍并输出结果。可以这样使用 for_each：
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void doubleAndPrint(int x) { std::cout &lt;&lt; x * 2 &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-16T16:48:48+08:00">
    <meta property="article:modified_time" content="2024-06-16T16:48:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;提高编程-07】----C&#43;&#43; STL常用算法之遍历算法和算术生成算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="34889d2e7fec4a02bb0ae3a22b011a2a.png" src="https://images2.imgbox.com/87/b8/I53wC2mQ_o.png"></p> 
<blockquote> 
 <p style="text-align:center;"><u>🎩 <span style="color:#511b78;"><strong>欢迎来到技术探索的奇幻世界</strong></span>👨‍💻</u></p> 
 <p style="text-align:center;"><u>📜 <strong>个人主页</strong></u><a href="https://blog.csdn.net/m0_64336780" title="：">：</a><a href="https://blog.csdn.net/m0_59951855?type=lately" title="@一伦明悦-CSDN博客">@一伦明悦-CSDN博客</a></p> 
 <p style="text-align:center;"><u>✍🏻 <strong>作者简介</strong></u>： <span style="color:#1a439c;"><strong>C++软件开发、Python机器学习爱好者</strong></span></p> 
 <p style="text-align:center;"><u>🗣️ </u><strong><u>互动与支持</u>：</strong><span style="color:#1a439c;">💬<strong>评论 </strong>     👍🏻<strong>点赞 </strong>     📂<strong>收藏 </strong>    👀<strong>关注+</strong></span></p> 
 <p style="text-align:center;"><span style="color:#1a439c;"><u><em><strong>如果文章有所帮助，欢迎留下您宝贵的评论，</strong></em></u></span></p> 
 <p style="text-align:center;"><span style="color:#1a439c;"><u><em><strong>点赞加收藏支持我，点击关注，一起进步！</strong></em></u></span></p> 
</blockquote> 
<h2 style="background-color:transparent;"><strong>前言</strong></h2> 
<blockquote> 
 <p>       STL（Standard Template Library）是C++标准库的一部分，提供了丰富的数据结构和算法，用于处理数据和实现常见的计算任务。STL中的算法分为几类，包括遍历算法、修改算法、排序算法、查找算法、数值算法等，每类算法都有其特定的应用场景和功能。</p> 
</blockquote> 
<h2>正文</h2> 
<h3 style="background-color:transparent;">01-遍历算法之for_each用法</h3> 
<blockquote> 
 <p>  <code>for_each</code> 是一种遍历算法，用于对指定范围内的每个元素执行特定操作。它的使用方式相对简单，但需要传入一个函数或函数对象作为操作的执行体。以下是关于 <code>for_each</code> 的详细介绍和用法示例：</p> 
 <p><code>for_each</code> 用法详解</p> 
 <p style="background-color:transparent;">语法</p> 
 <pre><code class="language-cpp">template &lt;class InputIterator, class Function&gt;
Function for_each(InputIterator first, InputIterator last, Function f);
</code></pre> 
 <ul><li><code>InputIterator</code>：表示容器或范围的起始位置的迭代器。</li><li><code>Function</code>：表示执行的操作，可以是函数或函数对象（仿函数）。</li></ul> 
 <p>参数</p> 
 <ul><li><code>first</code>：表示要处理的范围的起始位置。</li><li><code>last</code>：表示要处理的范围的结束位置，不包含在范围内。</li><li><code>f</code>：表示要执行的操作，可以是函数或函数对象。</li></ul> 
 <p>功能</p> 
 <p><code>for_each</code> 对 <code>[first, last)</code> 范围内的每个元素执行 <code>f</code> 操作。</p> 
 <p>返回值</p> 
 <p>返回值类型为 <code>Function</code>，通常是传入的函数或函数对象 <code>f</code>。</p> 
 <p>示例</p> 
 <p>假设有一个整数数组 <code>numbers</code>，我们想要将每个元素加倍并输出结果。可以这样使用 <code>for_each</code>：</p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

void doubleAndPrint(int x) {
    std::cout &lt;&lt; x * 2 &lt;&lt; " ";
}

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // 使用 for_each 执行操作
    std::for_each(numbers.begin(), numbers.end(), doubleAndPrint);

    return 0;
}
</code></pre> 
 <p>输出结果将是 <code>2 4 6 8 10</code>，这里 <code>doubleAndPrint</code> 函数就是传入 <code>for_each</code> 的操作函数。在实际使用中，可以根据需要定义不同的操作函数或使用 lambda 表达式作为 <code>for_each</code> 的操作体。</p> 
 <p>注意事项</p> 
 <ul><li><code>for_each</code> 并不会改变容器中元素的值，它只是对每个元素执行操作。</li><li>传入的操作函数或函数对象应符合对应的参数和返回值要求，以确保正确执行操作。</li></ul> 
 <p>通过灵活运用 <code>for_each</code> 算法，可以简化遍历操作的代码，提高代码的可读性和维护性。</p> 
</blockquote> 
<p>下面给出具体代码分析应用过程</p> 
<p>这段代码展示了如何使用 <code>for_each</code> 算法进行遍历操作，分别使用普通函数和函数对象作为操作体。让我简要解释一下这部分代码：</p> 
<ol><li> <p><strong>头文件包含</strong>：</p> <pre><code>#include &lt;algorithm&gt;
#include &lt;vector&gt;
</code></pre> <p>这里包含了使用到的标准库头文件 <code>&lt;algorithm&gt;</code> 和 <code>&lt;vector&gt;</code>。</p> </li><li> <p><strong>普通函数 <code>print01</code></strong>：</p> <pre><code>void print01(int val)
{
    cout &lt;&lt; val &lt;&lt; " ";
}
</code></pre> <p><code>print01</code> 是一个普通函数，用于打印传入的整数 <code>val</code>。</p> </li><li> <p><strong>函数对象 <code>print02</code></strong>：</p> <pre><code>class print02
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};
</code></pre> <p><code>print02</code> 是一个函数对象（也称为仿函数），重载了函数调用运算符 <code>operator()</code>，用于打印传入的整数 <code>val</code>。</p> </li><li> <p><strong><code>test01</code> 函数</strong>：</p> <pre><code>void test01() {
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++)
    {
        v.push_back(i);
    }

    // 使用 for_each 算法调用普通函数 print01
    for_each(v.begin(), v.end(), print01);
    cout &lt;&lt; endl;

    // 使用 for_each 算法调用函数对象 print02
    for_each(v.begin(), v.end(), print02());
    cout &lt;&lt; endl;
}
</code></pre> 
  <ul><li>在 <code>test01</code> 函数中，首先创建了一个 <code>vector&lt;int&gt;</code> 容器 <code>v</code>，并将整数 0 到 9 添加到容器中。</li><li>然后使用 <code>for_each</code> 算法分别调用了 <code>print01</code> 和 <code>print02</code> 函数对象，对容器 <code>v</code> 中的每个元素执行打印操作。</li></ul></li><li> <p><strong><code>main</code> 函数</strong>：</p> <pre><code>int main() {
    test01();
    system("pause");
    return 0;
}
</code></pre> <p><code>main</code> 函数调用了 <code>test01</code> 函数，展示了 <code>for_each</code> 算法的基本用法和不同操作体的应用。</p> </li></ol> 
<p>总结：</p> 
<ul><li>这段代码演示了如何使用 <code>for_each</code> 算法对容器进行遍历操作，可以通过普通函数或函数对象来定义具体的操作。</li><li>函数对象的使用使得可以在一个地方定义多个不同的操作，增加了代码的灵活性和可复用性。</li><li><code>for_each</code> 算法不会修改容器中的元素，只是对每个元素执行指定的操作，这符合算法的设计初衷。</li></ul> 
<p>通过这样的方式，可以简化遍历操作的代码实现，并使代码更加清晰和易于维护。</p> 
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
//普通函数
void print01(int val)
{
	cout &lt;&lt; val &lt;&lt; " ";
}
//函数对象
class print02
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; " ";
	}
};
//for_each算法基本用法
void test01() {
	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}
	//遍历算法
	for_each(v.begin(), v.end(), print01);
	cout &lt;&lt; endl;
	for_each(v.begin(), v.end(), print02());
	cout &lt;&lt; endl;
}
int main() {
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h3 style="background-color:transparent;">02-遍历算法之transform用法</h3> 
<blockquote> 
 <p>        <code>transform</code> 是另一种常用的STL遍历算法，与 <code>for_each</code> 不同的是，它不仅可以对容器中的每个元素执行操作，还可以将操作的结果存储到另一个容器或同一容器的不同位置。以下是关于 <code>transform</code> 的详细介绍和用法示例：</p> 
 <p><code>transform</code> 用法详解</p> 
 <p>语法</p> 
 <pre><code class="language-cpp">template &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
OutputIterator transform(InputIterator first1, InputIterator last1,
                         OutputIterator result, UnaryOperation op);
</code></pre> 
 <ul><li><code>InputIterator</code>：表示容器或范围的起始位置的迭代器。</li><li><code>OutputIterator</code>：表示结果存储位置的迭代器。</li><li><code>UnaryOperation</code>：表示执行的操作，通常是一个函数对象（一元函数）。</li></ul> 
 <p>参数</p> 
 <ul><li><code>first1</code>：表示要处理的范围的起始位置。</li><li><code>last1</code>：表示要处理的范围的结束位置，不包含在范围内。</li><li><code>result</code>：表示操作结果的存储位置，可以是另一个容器的 <code>begin()</code> 迭代器或插入位置迭代器。</li><li><code>op</code>：表示要执行的操作，通常是一个函数对象，接受一个参数并返回结果。</li></ul> 
 <p>功能</p> 
 <p><code>transform</code> 对 <code>[first1, last1)</code> 范围内的每个元素应用 <code>op</code> 操作，并将结果存储到 <code>result</code> 指定的位置。</p> 
 <p>返回值</p> 
 <p>返回一个指向存储结果的迭代器 <code>result + (last1 - first1)</code>。</p> 
 <p>示例</p> 
 <p>假设有一个整数数组 <code>numbers</code>，我们想要将每个元素加倍并存储到另一个数组 <code>doubled_numbers</code> 中。可以这样使用 <code>transform</code>：</p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

// 定义一个函数对象，用于将元素加倍
struct Double {
    int operator()(int x) const { return x * 2; }
};

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; doubled_numbers;

    // 使用 transform 执行操作
    std::transform(numbers.begin(), numbers.end(), std::back_inserter(doubled_numbers), Double());

    // 输出结果
    for (auto num : doubled_numbers) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
 <p>        输出结果将是 <code>2 4 6 8 10</code>，这里 <code>Double</code> 是一个函数对象，作为 <code>transform</code> 的操作体。在实际使用中，也可以使用 lambda 表达式或其他函数对象来定义操作体 <code>op</code>。</p> 
 <p>注意事项</p> 
 <ul><li><code>transform</code> 可以将操作的结果存储到另一个容器（如示例中的 <code>doubled_numbers</code>），这对于在算法中生成新的数据集合非常有用。</li><li>操作体 <code>op</code> 必须是一个一元函数，接受一个参数并返回操作后的结果。</li><li>如果 <code>result</code> 容器的大小不足以容纳结果，则程序行为未定义；通常情况下应使用 <code>std::back_inserter</code> 等函数来动态扩展容器大小。</li></ul> 
 <p>        通过 <code>transform</code> 算法，可以将处理数据和存储结果有效地分离，提高了代码的模块化和可维护性，是处理数据转换和映射的常用工具之一。</p> 
</blockquote> 
<p>下面给出代码分析应用过程：</p> 
<p>这段代码演示了如何使用 <code>transform</code> 算法来对一个容器中的元素进行转换，并将结果存储到另一个容器中。让我来简要解释一下：</p> 
<ol><li> <p><strong>头文件包含</strong>：</p> <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
</code></pre> <p>这里包含了使用到的标准库头文件 <code>&lt;vector&gt;</code> 和 <code>&lt;algorithm&gt;</code>。</p> </li><li> <p><strong>函数对象 <code>TransForm</code></strong>：</p> <pre><code class="language-cpp">class TransForm
{
public:
    int operator()(int val)
    {
        return val;
    }
};
</code></pre> <p><code>TransForm</code> 是一个函数对象（仿函数），重载了函数调用运算符 <code>operator()</code>，用于对传入的整数 <code>val</code> 进行转换操作。在这个例子中，它实际上是一个恒等函数，返回原始的输入值。</p> </li><li> <p><strong>函数对象 <code>MyPrint</code></strong>：</p> <pre><code class="language-cpp">class MyPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};
</code></pre> <p><code>MyPrint</code> 是另一个函数对象，用于打印传入的整数 <code>val</code>。</p> </li><li> <p><strong><code>test01</code> 函数</strong>：</p> <pre><code class="language-cpp">void test01()
{
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++)
    {
        v.push_back(i);
    }

    vector&lt;int&gt; vTarget; // 目标容器
    vTarget.resize(v.size()); // 目标容器需要提前开辟空间

    // 使用 transform 算法对容器 v 中的每个元素应用 TransForm，并将结果存储到 vTarget 中
    transform(v.begin(), v.end(), vTarget.begin(), TransForm());

    // 使用 for_each 算法打印 vTarget 中的每个元素
    for_each(vTarget.begin(), vTarget.end(), MyPrint());
}
</code></pre> 
  <ul><li>在 <code>test01</code> 函数中，首先创建了一个 <code>vector&lt;int&gt;</code> 容器 <code>v</code>，并向其中插入整数 0 到 9。</li><li>创建了另一个 <code>vector&lt;int&gt;</code> 容器 <code>vTarget</code> 作为目标容器，并调整其大小以匹配 <code>v</code> 的大小。</li><li>使用 <code>transform</code> 算法对容器 <code>v</code> 中的每个元素应用 <code>TransForm</code> 函数对象，并将结果存储到 <code>vTarget</code> 中。</li><li>最后，使用 <code>for_each</code> 算法和 <code>MyPrint</code> 函数对象打印 <code>vTarget</code> 中的每个元素。</li></ul></li><li> <p><strong><code>main</code> 函数</strong>：</p> <pre><code class="language-cpp">int main() {
    test01();
    system("pause");
    return 0;
}
</code></pre> <p><code>main</code> 函数调用了 <code>test01</code> 函数，展示了 <code>transform</code> 算法的基本用法和将操作结果存储到另一个容器的实际应用。</p> </li></ol> 
<p>总结：</p> 
<ul><li><code>transform</code> 算法能够对一个容器中的元素进行操作，并将结果存储到另一个容器或同一容器的不同位置，比如示例中的 <code>vTarget</code>。</li><li>使用函数对象（如 <code>TransForm</code> 和 <code>MyPrint</code>）可以灵活定义操作，增强代码的可复用性和可维护性。</li><li>需要注意的是，目标容器在使用 <code>transform</code> 算法之前需要预先分配足够的空间，以确保存储结果的正确性。</li></ul> 
<p>通过这样的方式，可以有效地进行数据转换和处理，使代码更加清晰和模块化。</p> 
<pre><code class="language-cpp">#include&lt;vector&gt;
#include&lt;algorithm&gt;
//常用遍历算法 搬运 transform
class TransForm
{
public:
	int operator()(int val)
	{
		return val;
	}
};
class MyPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; " ";
	}
};
void test01()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}
	vector&lt;int&gt;vTarget; //目标容器
	vTarget.resize(v.size()); // 目标容器需要提前开辟空间
	transform(v.begin(), v.end(), vTarget.begin(), TransForm());
	for_each(vTarget.begin(), vTarget.end(), MyPrint());
}
int main() {
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h3 style="background-color:transparent;">03-算术生成算法之accumulate用法</h3> 
<blockquote> 
 <p>        <code>accumulate</code> 是另一个常用的STL算法，用于计算序列中元素的累加值。以下是关于 <code>accumulate</code> 的详细介绍和用法示例：</p> 
 <p><code>accumulate</code> 用法详解</p> 
 <p>语法</p> 
 <pre><code class="language-cpp">template &lt;class InputIterator, class T&gt;
T accumulate(InputIterator first, InputIterator last, T init);
</code></pre> 
 <ul><li><code>InputIterator</code>：表示容器或范围的起始位置的迭代器。</li><li><code>T</code>：表示累加结果的类型，通常是元素类型的累加结果类型。</li><li><code>init</code>：表示初始值，累加的起始点。</li></ul> 
 <p>参数</p> 
 <ul><li><code>first</code>：表示要累加的范围的起始位置。</li><li><code>last</code>：表示要累加的范围的结束位置，不包含在范围内。</li><li><code>init</code>：表示累加的初始值，累加从这个值开始。</li></ul> 
 <p>功能</p> 
 <p><code>accumulate</code> 对 <code>[first, last)</code> 范围内的元素进行累加，初始值为 <code>init</code>，并返回累加的结果。</p> 
 <p>返回值</p> 
 <p>返回累加后的结果，类型为 <code>T</code>。</p> 
 <p>示例</p> 
 <p>假设有一个整数数组 <code>numbers</code>，我们想要计算数组中所有元素的累加和。可以这样使用 <code>accumulate</code>：</p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt; // 包含 accumulate 函数

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // 使用 accumulate 计算累加和
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);

    std::cout &lt;&lt; "Sum of elements: " &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
 <p>输出结果将是 <code>Sum of elements: 15</code>。在这个例子中，<code>accumulate</code> 函数将整数数组 <code>numbers</code> 中的所有元素累加起来，初始值为 <code>0</code>。</p> 
 <p>注意事项</p> 
 <ul><li><code>accumulate</code> 可以用于各种数据类型，不限于整数。</li><li>初始值 <code>init</code> 的类型必须与累加结果的类型相容，通常为整数或浮点数。</li><li>如果范围 <code>[first, last)</code> 是空的，<code>accumulate</code> 将直接返回初始值 <code>init</code>。</li></ul> 
 <p>        通过 <code>accumulate</code> 算法，可以方便地计算序列中元素的累加和，是处理累加操作的常用工具之一。</p> 
</blockquote> 
<p> 下面给出具体代码分析应用过程：</p> 
<p>这段代码展示了如何使用 <code>accumulate</code> 算法来计算整数向量中所有元素的累加和。让我来简要解释一下：</p> 
<ol><li> <p><strong>头文件包含</strong>：</p> <pre><code class="language-cpp">#include &lt;numeric&gt;
#include &lt;vector&gt;
</code></pre> <p>这里包含了使用到的标准库头文件 <code>&lt;numeric&gt;</code> 和 <code>&lt;vector&gt;</code>。</p> </li><li> <p><strong><code>test01</code> 函数</strong>：</p> <pre><code class="language-cpp">void test01()
{
    vector&lt;int&gt; v;
    for (int i = 0; i &lt;= 100; i++) {
        v.push_back(i);
    }
    int total = accumulate(v.begin(), v.end(), 0);
    cout &lt;&lt; "total = " &lt;&lt; total &lt;&lt; endl;
}
</code></pre> 
  <ul><li>在 <code>test01</code> 函数中，首先创建了一个 <code>vector&lt;int&gt;</code> 容器 <code>v</code>，并使用循环将整数 0 到 100 插入到向量中。</li><li>调用 <code>accumulate</code> 算法计算了容器 <code>v</code> 中所有元素的累加和。参数解释如下： 
    <ul><li><code>v.begin()</code> 和 <code>v.end()</code> 表示累加的范围是从容器 <code>v</code> 的开头到末尾（不包括末尾）。</li><li><code>0</code> 是累加的初始值，即从0开始累加。</li></ul></li><li>将计算得到的总和 <code>total</code> 输出到标准输出流 <code>cout</code> 中。</li></ul></li><li> <p><strong><code>main</code> 函数</strong>：</p> <pre><code class="language-cpp">int main() {
    test01();
    system("pause");
    return 0;
}
</code></pre> <p><code>main</code> 函数调用了 <code>test01</code> 函数，展示了 <code>accumulate</code> 算法的使用方式和计算结果的输出。</p> </li></ol> 
<p>总结：</p> 
<ul><li><code>accumulate</code> 算法能够方便地对容器中的元素进行累加操作，从而计算它们的总和。</li><li>初始值 <code>0</code> 确保了即使容器为空，也能正确返回初始值作为累加结果。</li><li>使用 <code>accumulate</code> 算法可以避免显式使用循环来计算累加和，简化了代码并提高了可读性。</li></ul> 
<p>通过这样的方式，可以快速、有效地处理需要累加操作的情况，适用于各种数据类型和复杂度的累加需求。</p> 
<pre><code class="language-cpp">#include &lt;numeric&gt;
#include &lt;vector&gt;
void test01()
{
	vector&lt;int&gt; v;
	for (int i = 0; i &lt;= 100; i++) {
		v.push_back(i);
	}
	int total = accumulate(v.begin(), v.end(), 0);
	cout &lt;&lt; "total = " &lt;&lt; total &lt;&lt; endl;
}
int main() {
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h3 style="background-color:transparent;">04-算术生成算法之fill用法</h3> 
<blockquote> 
 <p>       <code>fill</code> 是STL中的一个算法，用于将指定范围内的所有元素设置为给定的值。以下是关于 <code>fill</code> 的详细介绍和用法示例：</p> 
 <p><code>fill</code> 用法详解</p> 
 <p>语法</p> 
 <pre><code class="language-cpp">template &lt;class ForwardIterator, class T&gt;
void fill (ForwardIterator first, ForwardIterator last, const T&amp; value);
</code></pre> 
 <ul><li><code>ForwardIterator</code>：表示容器或范围的起始位置的迭代器类型。</li><li><code>T</code>：表示要填充的值的类型。</li><li><code>first</code>：表示要填充的范围的起始位置。</li><li><code>last</code>：表示要填充的范围的结束位置，不包含在范围内。</li><li><code>value</code>：表示要填充到范围中的值。</li></ul> 
 <p>参数</p> 
 <ul><li><code>first</code>：要填充的范围的起始位置。</li><li><code>last</code>：要填充的范围的结束位置，不包含在范围内。</li><li><code>value</code>：要填充到范围中的值。</li></ul> 
 <p>功能</p> 
 <p><code>fill</code> 算法用指定的值 <code>value</code> 填充 <code>[first, last)</code> 范围内的所有元素。</p> 
 <p>返回值</p> 
 <p>无。</p> 
 <p>示例</p> 
 <p>假设有一个整数数组 <code>numbers</code>，我们想要将数组中的所有元素设置为 <code>0</code>。可以这样使用 <code>fill</code>：</p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // 包含 fill 函数

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // 使用 fill 将数组中所有元素设置为 0
    std::fill(numbers.begin(), numbers.end(), 0);

    // 打印填充后的结果
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
 <p>输出结果将是 <code>0 0 0 0 0</code>。在这个例子中，<code>fill</code> 函数将整数数组 <code>numbers</code> 中的所有元素都设置为 <code>0</code>。</p> 
 <p>注意事项</p> 
 <ul><li><code>fill</code> 可以用于各种数据类型，不限于整数。</li><li>使用 <code>fill</code> 算法可以有效地初始化或重置容器中的元素。</li><li><code>fill</code> 不检查 <code>last</code> 迭代器是否在范围内，使用时应保证范围有效。</li></ul> 
 <p>通过 <code>fill</code> 算法，可以方便地将容器中的元素设置为指定值，是处理填充操作的常用工具之一。</p> 
</blockquote> 
<p> 下面给出具体代码分析应用过程：</p> 
<p>这段代码演示了如何使用 <code>fill</code> 算法来填充整数向量中的所有元素为指定的值。让我来简要解释一下：</p> 
<ol><li> <p><strong>头文件包含</strong>：</p> <pre><code class="language-cpp">#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
</code></pre> <p>这里包含了使用到的标准库头文件 <code>&lt;numeric&gt;</code>, <code>&lt;vector&gt;</code>, <code>&lt;algorithm&gt;</code> 和 <code>&lt;iostream&gt;</code>。</p> </li><li> <p><strong>自定义函数对象 <code>myPrint</code></strong>：</p> <pre><code class="language-cpp">class myPrint {
public:
    void operator()(int val) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
};
</code></pre> <p><code>myPrint</code> 是一个重载了函数调用运算符 <code>()</code> 的类，用于在 <code>for_each</code> 算法中打印每个元素的值。</p> </li><li> <p><strong><code>test01</code> 函数</strong>：</p> <pre><code class="language-cpp">void test01() {
    std::vector&lt;int&gt; v;
    v.resize(10);  // 调整向量大小为10个元素

    // 使用 fill 算法将向量 v 中的所有元素设置为 100
    std::fill(v.begin(), v.end(), 100);

    // 使用 for_each 算法和自定义的 myPrint 函数对象打印向量中的每个元素
    std::for_each(v.begin(), v.end(), myPrint());
    std::cout &lt;&lt; std::endl;
}
</code></pre> 
  <ul><li>在 <code>test01</code> 函数中，首先创建了一个大小为 10 的整数向量 <code>v</code>。</li><li>使用 <code>fill</code> 算法将向量 <code>v</code> 中的所有元素设置为 <code>100</code>。<code>v.begin()</code> 表示填充的起始位置，<code>v.end()</code> 表示填充的结束位置（不包含在范围内）。</li><li>使用 <code>for_each</code> 算法和自定义的 <code>myPrint</code> 函数对象，遍历打印向量 <code>v</code> 中的每个元素值。</li></ul></li><li> <p><strong><code>main</code> 函数</strong>：</p> <pre><code class="language-cpp">int main() {
    test01();
    system("pause");
    return 0;
}
</code></pre> <p><code>main</code> 函数调用了 <code>test01</code> 函数，展示了 <code>fill</code> 算法的使用方式和填充后的输出结果。</p> </li></ol> 
<p>总结：</p> 
<ul><li><code>fill</code> 算法通过指定的值将容器中的指定范围内的所有元素进行填充。</li><li>在本例中，<code>fill</code> 将整数向量 <code>v</code> 中的所有元素设置为 <code>100</code>。</li><li>使用函数对象 <code>myPrint</code> 可以在遍历过程中自定义操作，这里用于打印每个元素。</li><li><code>fill</code> 是初始化或重置容器元素的有效工具，能够简化代码并提高可读性。</li></ul> 
<p>通过这样的方式，可以快速、方便地对容器中的元素进行填充操作，适用于各种数据类型和填充需求。</p> 
<pre><code class="language-cpp">#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; " ";
	}
};
void test01()
{
	vector&lt;int&gt; v;
	v.resize(10);
	//填充
	fill(v.begin(), v.end(), 100);
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
}
int main() {
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h2 style="background-color:transparent;">总结  </h2> 
<blockquote> 
 <ul><li><strong>遍历算法</strong>帮助在容器内迭代元素并执行操作，如输出、转换或计算。</li><li><strong>算术生成算法</strong>用于填充或生成容器的元素，常用于初始化和重置操作。</li><li>这些算法能够显著减少代码量并提高可读性，是C++中处理数据和容器操作的强大工具。</li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7a641162274ed7c5c528d863c035ef3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter 实现StackAllocator简化FFI局部变量的内存管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d95f6e99bf9824b7be5ee92c38cfc58/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">趣味C语言——【关机代码】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>