<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python实战开发及案例分析（9）—— 决策树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9ab32b53729c7434006c874107ca303a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python实战开发及案例分析（9）—— 决策树">
  <meta property="og:description" content="决策树是一种用于分类和回归的机器学习模型。它通过学习一系列的决策规则将数据分成不同的类别或预测数值。决策树在构建时依赖于属性选择度量，如信息增益、基尼系数等。
在Python中，我们可以使用scikit-learn库来快速构建和使用决策树模型。下面是一个基于决策树的分类和回归的案例分析。
案例分析：决策树分类 我们将使用scikit-learn的决策树分类器对鸢尾花数据集进行分类。鸢尾花数据集包含了三种鸢尾花的四个特征（花萼和花瓣的长度和宽度），并需要根据这些特征对鸢尾花的种类进行分类。
Python 实现：
from sklearn import datasets from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import classification_report, confusion_matrix import matplotlib.pyplot as plt from sklearn import tree # 加载鸢尾花数据集 iris = datasets.load_iris() X, y = iris.data, iris.target # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) # 创建决策树分类器并训练 clf = DecisionTreeClassifier(random_state=42) clf.fit(X_train, y_train) # 预测测试集结果 y_pred = clf.predict(X_test) # 输出混淆矩阵和分类报告 print(confusion_matrix(y_test, y_pred)) print(classification_report(y_test, y_pred)) # 绘制决策树 plt.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T20:59:34+08:00">
    <meta property="article:modified_time" content="2024-05-06T20:59:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python实战开发及案例分析（9）—— 决策树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        决策树是一种用于分类和回归的机器学习模型。它通过学习一系列的决策规则将数据分成不同的类别或预测数值。决策树在构建时依赖于属性选择度量，如信息增益、基尼系数等。</p> 
<p>        在Python中，我们可以使用<code>scikit-learn</code>库来快速构建和使用决策树模型。下面是一个基于决策树的分类和回归的案例分析。</p> 
<h4>案例分析：决策树分类</h4> 
<p>        我们将使用<code>scikit-learn</code>的决策树分类器对鸢尾花数据集进行分类。鸢尾花数据集包含了三种鸢尾花的四个特征（花萼和花瓣的长度和宽度），并需要根据这些特征对鸢尾花的种类进行分类。</p> 
<p><strong>Python 实现：</strong></p> 
<pre><code class="language-python">from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
from sklearn import tree

# 加载鸢尾花数据集
iris = datasets.load_iris()
X, y = iris.data, iris.target

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 创建决策树分类器并训练
clf = DecisionTreeClassifier(random_state=42)
clf.fit(X_train, y_train)

# 预测测试集结果
y_pred = clf.predict(X_test)

# 输出混淆矩阵和分类报告
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

# 绘制决策树
plt.figure(figsize=(12, 8))
tree.plot_tree(clf, feature_names=iris.feature_names, class_names=iris.target_names, filled=True)
plt.show()
</code></pre> 
<p><strong>解释：</strong></p> 
<ul><li><code>DecisionTreeClassifier</code>：用于创建决策树分类模型。</li><li><code>plot_tree</code>：绘制决策树，展示决策路径。</li></ul> 
<h4>案例分析：决策树回归</h4> 
<p>        决策树也可以用于回归问题。在这个案例中，我们将使用波士顿房价数据集来预测房屋的价格。</p> 
<p><strong>Python 实现：</strong></p> 
<pre><code class="language-python">from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# 加载波士顿房价数据集
boston = datasets.load_boston()
X, y = boston.data, boston.target

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 创建决策树回归模型并训练
regressor = DecisionTreeRegressor(random_state=42)
regressor.fit(X_train, y_train)

# 预测测试集结果
y_pred = regressor.predict(X_test)

# 计算均方误差
mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error: {mse:.2f}")

# 绘制特征重要性
plt.figure(figsize=(8, 6))
plt.barh(boston.feature_names, regressor.feature_importances_)
plt.xlabel("Feature Importance")
plt.ylabel("Feature Name")
plt.title("Feature Importance in Decision Tree Regression")
plt.show()
</code></pre> 
<p><strong>解释：</strong></p> 
<ul><li><code>DecisionTreeRegressor</code>：用于创建决策树回归模型。</li><li><code>mean_squared_error</code>：计算模型预测的均方误差，用于评估回归模型的性能。</li></ul> 
<h4>结论</h4> 
<p>        决策树模型通过构建一系列决策规则为分类和回归问题提供了强大的模型能力。它的优势包括可解释性强和适用于处理类别或数值型数据。</p> 
<ul><li><strong>分类问题</strong>：通过分割不同特征空间，可以有效地分类鸢尾花数据集。</li><li><strong>回归问题</strong>：通过预测连续数值，为房价预测提供了简单有效的方法。</li></ul> 
<p>        然而，决策树模型容易过拟合，需要通过剪枝、设置深度和样本数量等参数进行调节。在实际应用中，结合交叉验证和其他技术可以提高模型的泛化能力。</p> 
<p>        继续深入探讨决策树模型，我们可以讨论更多的决策树相关技术，如剪枝、特征重要性以及基于集成学习的随机森林和梯度提升树。</p> 
<h4>决策树剪枝</h4> 
<p>        决策树容易过拟合，为了解决这一问题，可以进行预剪枝或后剪枝。</p> 
<ul><li><strong>预剪枝</strong>：在构建过程中通过设置参数（如<code>max_depth</code>, <code>min_samples_split</code>等）限制树的生长。</li><li><strong>后剪枝</strong>：先生成完整的树，然后在验证集上进行剪枝。</li></ul> 
<h5>预剪枝示例</h5> 
<p>        通过设置<code>max_depth</code>限制树的最大深度，避免过拟合。</p> 
<pre><code class="language-python">from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
from sklearn import tree

# 加载鸢尾花数据集
iris = datasets.load_iris()
X, y = iris.data, iris.target

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 设置预剪枝参数
clf = DecisionTreeClassifier(random_state=42, max_depth=3, min_samples_split=4, min_samples_leaf=2)
clf.fit(X_train, y_train)

# 预测测试集结果
y_pred = clf.predict(X_test)

# 输出混淆矩阵和分类报告
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

# 绘制决策树
plt.figure(figsize=(12, 8))
tree.plot_tree(clf, feature_names=iris.feature_names, class_names=iris.target_names, filled=True)
plt.show()
</code></pre> 
<h4>决策树特征重要性</h4> 
<p>        通过查看特征的重要性，可以了解哪些特征对分类结果影响最大。</p> 
<pre><code class="language-python"># 使用鸢尾花数据集和决策树分类器
clf = DecisionTreeClassifier(random_state=42, max_depth=3, min_samples_split=4, min_samples_leaf=2)
clf.fit(X_train, y_train)

# 打印特征重要性
print("Feature importances:", clf.feature_importances_)

# 可视化特征重要性
plt.figure(figsize=(8, 6))
plt.barh(iris.feature_names, clf.feature_importances_)
plt.xlabel("Feature Importance")
plt.ylabel("Feature Name")
plt.title("Feature Importance in Decision Tree Classification")
plt.show()
</code></pre> 
<h4>案例分析：使用随机森林进行分类</h4> 
<p>        随机森林是由多个决策树构成的集成模型，可以通过组合多个决策树的预测结果来提高模型性能和稳定性。它还可以帮助减小单个决策树的过拟合风险。</p> 
<p><strong>Python 实现：</strong></p> 
<pre><code class="language-python">from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# 加载鸢尾花数据集
iris = datasets.load_iris()
X, y = iris.data, iris.target

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 创建随机森林分类器并训练
rf_clf = RandomForestClassifier(n_estimators=100, random_state=42)
rf_clf.fit(X_train, y_train)

# 预测测试集结果
y_pred = rf_clf.predict(X_test)

# 输出混淆矩阵和分类报告
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

# 可视化特征重要性
plt.figure(figsize=(8, 6))
sns.barplot(x=rf_clf.feature_importances_, y=iris.feature_names)
plt.xlabel("Feature Importance")
plt.ylabel("Feature Name")
plt.title("Feature Importance in Random Forest Classification")
plt.show()
</code></pre> 
<h4>案例分析：使用梯度提升树（Gradient Boosting Trees）进行分类</h4> 
<p>        梯度提升树是一种集成学习方法，通过逐步构建多个弱模型（决策树）来提高预测精度。</p> 
<p><strong>Python 实现：</strong></p> 
<pre><code class="language-python">from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# 加载鸢尾花数据集
iris = datasets.load_iris()
X, y = iris.data, iris.target

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 创建梯度提升分类器并训练
gb_clf = GradientBoostingClassifier(n_estimators=100, random_state=42)
gb_clf.fit(X_train, y_train)

# 预测测试集结果
y_pred = gb_clf.predict(X_test)

# 输出混淆矩阵和分类报告
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

# 可视化特征重要性
plt.figure(figsize=(8, 6))
sns.barplot(x=gb_clf.feature_importances_, y=iris.feature_names)
plt.xlabel("Feature Importance")
plt.ylabel("Feature Name")
plt.title("Feature Importance in Gradient Boosting Classification")
plt.show()
</code></pre> 
<h4>结论</h4> 
<ul><li><strong>剪枝</strong>：通过预剪枝或后剪枝技术可以减小决策树的过拟合风险，得到更稳健的模型。</li><li><strong>特征重要性</strong>：决策树模型可以用于评估不同特征对分类结果的重要性。</li><li><strong>集成模型</strong>： 
  <ul><li><strong>随机森林</strong>：通过组合多个决策树，减少了单一决策树的过拟合风险，通常能获得更好的预测效果。</li><li><strong>梯度提升树</strong>：通过逐步构建多个弱模型来提高预测精度，适用于复杂的分类和回归问题。</li></ul></li></ul> 
<p>        这些技术使得决策树及其变种模型在实际机器学习问题中具有广泛的应用。</p> 
<p>        继续深入探讨更多与决策树相关的技术和案例，我们可以学习基于决策树的其他集成方法，如极端随机树（ExtraTrees），并探讨决策树的具体应用案例。</p> 
<h4>案例分析：使用极端随机树（ExtraTrees）进行分类</h4> 
<p>        极端随机树是一种随机森林的变种，与随机森林不同，极端随机树在构建树时不是选择最佳分割点，而是随机选择分割点，从而增加多样性并加速计算。</p> 
<p><strong>Python 实现：</strong></p> 
<pre><code class="language-python">from sklearn.ensemble import ExtraTreesClassifier
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# 加载鸢尾花数据集
iris = datasets.load_iris()
X, y = iris.data, iris.target

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 创建极端随机树分类器并训练
et_clf = ExtraTreesClassifier(n_estimators=100, random_state=42)
et_clf.fit(X_train, y_train)

# 预测测试集结果
y_pred = et_clf.predict(X_test)

# 输出混淆矩阵和分类报告
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

# 可视化特征重要性
plt.figure(figsize=(8, 6))
sns.barplot(x=et_clf.feature_importances_, y=iris.feature_names)
plt.xlabel("Feature Importance")
plt.ylabel("Feature Name")
plt.title("Feature Importance in Extra Trees Classification")
plt.show()
</code></pre> 
<h4>案例分析：决策树在客户流失预测中的应用</h4> 
<p><strong>项目背景</strong>：客户流失是指客户停止使用某种产品或服务。为了保留更多的客户，可以通过决策树模型对客户进行分类，预测哪些客户更可能流失。</p> 
<p><strong>数据集</strong>：使用著名的 <code>Telco Customer Churn</code> 数据集。</p> 
<p><strong>Python 实现：</strong></p> 
<pre><code class="language-python">import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# 加载数据集
url = 'https://raw.githubusercontent.com/IBM/telco-customer-churn-on-icp4d/master/data/Telco-Customer-Churn.csv'
df = pd.read_csv(url)

# 删除不必要的列
df.drop(['customerID'], axis=1, inplace=True)

# 处理分类数据
label_encoders = {}
for column in df.select_dtypes(include='object').columns:
    le = LabelEncoder()
    df[column] = le.fit_transform(df[column])
    label_encoders[column] = le

# 定义特征和标签
X = df.drop(['Churn'], axis=1)
y = df['Churn']

# 标准化数据
scaler = StandardScaler()
X = scaler.fit_transform(X)

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 创建随机森林模型并训练
rf_clf = RandomForestClassifier(n_estimators=100, random_state=42)
rf_clf.fit(X_train, y_train)

# 预测测试集结果
y_pred = rf_clf.predict(X_test)

# 输出混淆矩阵和分类报告
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

# 可视化特征重要性
plt.figure(figsize=(8, 6))
feature_names = df.drop(['Churn'], axis=1).columns
sns.barplot(x=rf_clf.feature_importances_, y=feature_names)
plt.xlabel("Feature Importance")
plt.ylabel("Feature Name")
plt.title("Feature Importance in Customer Churn Prediction")
plt.show()
</code></pre> 
<h4>案例分析：使用LightGBM进行分类</h4> 
<p><strong>项目背景</strong>：LightGBM（Light Gradient Boosting Machine）是由微软开发的梯度提升框架，具有更快的训练速度和更好的准确性。</p> 
<p><strong>Python 实现：</strong></p> 
<p>安装 <code>lightgbm</code>：</p> 
<pre><code class="language-python">pip install lightgbm
</code></pre> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-python">import lightgbm as lgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# 加载数据集
url = 'https://raw.githubusercontent.com/IBM/telco-customer-churn-on-icp4d/master/data/Telco-Customer-Churn.csv'
df = pd.read_csv(url)

# 删除不必要的列
df.drop(['customerID'], axis=1, inplace=True)

# 处理分类数据
label_encoders = {}
for column in df.select_dtypes(include='object').columns:
    le = LabelEncoder()
    df[column] = le.fit_transform(df[column])
    label_encoders[column] = le

# 定义特征和标签
X = df.drop(['Churn'], axis=1)
y = df['Churn']

# 标准化数据
scaler = StandardScaler()
X = scaler.fit_transform(X)

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 创建LightGBM模型并训练
lgb_train = lgb.Dataset(X_train, y_train)
params = {
    'objective': 'binary',
    'boosting_type': 'gbdt',
    'metric': 'binary_logloss',
    'num_leaves': 31,
    'learning_rate': 0.05,
    'verbose': 0
}
gbm = lgb.train(params, lgb_train, num_boost_round=100)

# 预测测试集结果
y_pred_prob = gbm.predict(X_test)
y_pred = (y_pred_prob &gt; 0.5).astype(int)

# 输出混淆矩阵和分类报告
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

# 可视化特征重要性
plt.figure(figsize=(8, 6))
feature_importance = gbm.feature_importance()
sns.barplot(x=feature_importance, y=feature_names)
plt.xlabel("Feature Importance")
plt.ylabel("Feature Name")
plt.title("Feature Importance in Customer Churn Prediction using LightGBM")
plt.show()
</code></pre> 
<h4>结论</h4> 
<p>        在这几种案例分析中，我们展示了不同的集成学习方法在决策树上的扩展和应用：</p> 
<ul><li><strong>极端随机树</strong>：通过随机分割点和数据采样构建，增加模型多样性并提高效率。</li><li><strong>客户流失预测</strong>：决策树模型在预测分类问题中具有较好的表现，适用于客户流失预测等场景。</li><li><strong>LightGBM</strong>：一种高效的梯度提升方法，能显著提高训练速度和预测性能。</li></ul> 
<p>        通过这些不同的集成方法和决策树扩展模型，可以更有效地解决分类和回归问题，特别是对大型数据集和复杂特征的预测。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/286f1997ec260dc58c14254c03c16b4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AIGC-音频生产十大主流模型技术原理及优缺点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8579744da36bbc7208a6565ee54f191a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Parallels Desktop 19 for mac(pd虚拟机)v19.3.0(54924)安装激活图文教程含2024最新激活秘钥</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>