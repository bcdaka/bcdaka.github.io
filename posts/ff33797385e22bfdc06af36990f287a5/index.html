<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【动态规划】【状态压缩】【2次选择】【广度搜索】1494. 并行课程 II - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ff33797385e22bfdc06af36990f287a5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【动态规划】【状态压缩】【2次选择】【广度搜索】1494. 并行课程 II">
  <meta property="og:description" content="作者推荐 视频算法专题
本文涉及知识点 动态规划汇总
状态压缩 广度优先搜索
LeetCode1494. 并行课程 II 给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 relations 中， relations[i] = [xi, yi] 表示一个先修课的关系，也就是课程 xi 必须在课程 yi 之前上。同时你还有一个整数 k 。
在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。
请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。
示例 1：
输入：n = 4, relations = [[2,1],[3,1],[1,4]], k = 2
输出：3
解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。
示例 2：
输入：n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2
输出：4
解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-05T07:00:00+08:00">
    <meta property="article:modified_time" content="2024-02-05T07:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【动态规划】【状态压缩】【2次选择】【广度搜索】1494. 并行课程 II</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>作者推荐</h2> 
<p><a href="https://blog.csdn.net/he_zhidan/category_12541620.html">视频算法专题</a></p> 
<h2><a id="_2"></a>本文涉及知识点</h2> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135704784">动态规划汇总</a><br> 状态压缩 广度优先搜索</p> 
<h2><a id="LeetCode1494__II_6"></a>LeetCode1494. 并行课程 II</h2> 
<p>给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 relations 中， relations[i] = [xi, yi] 表示一个先修课的关系，也就是课程 xi 必须在课程 yi 之前上。同时你还有一个整数 k 。<br> 在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。<br> 请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。<br> 示例 1：<br> 输入：n = 4, relations = [[2,1],[3,1],[1,4]], k = 2<br> 输出：3<br> 解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。<br> 示例 2：<br> 输入：n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2<br> 输出：4<br> 解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。<br> 示例 3：<br> 输入：n = 11, relations = [], k = 2<br> 输出：6<br> 提示：<br> 1 &lt;= n &lt;= 15<br> 1 &lt;= k &lt;= n<br> 0 &lt;= relations.length &lt;= n * (n-1) / 2<br> relations[i].length == 2<br> 1 &lt;= xi, yi &lt;= n<br> xi != yi<br> 所有先修关系都是不同的，也就是说 relations[i] != relations[j] 。<br> 题目输入的图是个有向无环图。</p> 
<h2><a id="_30"></a>状态压缩</h2> 
<p>15门课程。枚举最后一次选择（选择1到15门） 和之前的选择（0到15门）。共多少种可能。暴力做法是：2<sup>30</sup>。</p> 
<h3><a id="___32"></a>枚举第一门课 第二门课第三门课 的可能</h3> 
<p>不包括0，共7种可能。<br> const int iMaxMask = (1 &lt;&lt; 3)-1;<br> for (int mask = iMaxMask; mask; mask = (mask - 1) &amp; iMaxMask)<br> {<!-- --><br> char sz1[100],sz2[100];<br> _itoa_s(mask, sz1, 2);<br> _itoa_s(iMaxMask - mask, sz2, 2);<br> std::cout &lt;&lt; “最后一次选择:\t” &lt;&lt; sz1 &lt;&lt; " 之前的选择:\t" &lt;&lt; sz2 &lt;&lt; std::endl;<br> }<br> 最后一次选择: 111 之前的选择: 0<br> 最后一次选择: 110 之前的选择: 1<br> 最后一次选择: 101 之前的选择: 10<br> 最后一次选择: 100 之前的选择: 11<br> 最后一次选择: 11 之前的选择: 100<br> 最后一次选择: 10 之前的选择: 101<br> 最后一次选择: 1 之前的选择: 110</p> 
<h3><a id="_50"></a>枚举第一、三、四</h3> 
<p>不包括0，共7种可能，不需要枚举16种可能。自动忽略了不可能存在的状态2。<br> const int iMaxMask = 1+4+8;</p> 
<p>最后一次选择: 111 之前的选择: 0<br> 最后一次选择: 110 之前的选择: 1<br> 最后一次选择: 101 之前的选择: 10<br> 最后一次选择: 100 之前的选择: 11<br> 最后一次选择: 11 之前的选择: 100<br> 最后一次选择: 10 之前的选择: 101<br> 最后一次选择: 1 之前的选择: 110</p> 
<h3><a id="iMaxMask_02n_61"></a>枚举iMaxMask [0,2<sup>n</sup>)</h3> 
<p>总时间复杂度是:O(3<sup>n</sup>) 3<sup>15</sup>大约1.4e7。注意剪枝，否则容易超时。</p> 
<h2><a id="_63"></a>动态规划</h2> 
<h3><a id="_64"></a>动态规划的状态表示</h3> 
<p>pre记录i学期能够完成的课程，dp记录i+1学期可以完成的课程。vHasDo记录已经完成的状态。状态没必要重复处理，i1&lt;i2，如果某种状态i1学期能处理，那没必要i2学期处理。<br> <strong>空间复杂度</strong>:状态数 ,2<sup>n</sup><br> <strong>时间复杂度</strong>: O(3<sup>n</sup>)</p> 
<h3><a id="_68"></a>动态规划的转移方程</h3> 
<p>当前学期的课程，必须满足三个条件：<br> 一，课程数小于等于k。<br> 二，所有前置课程都已经完成。<br> 三，这些课程没学习过。可以省略，会被淘汰。<br> 预处理：<br> vPre[i] 表示第i门课需要的前面状态。<br> vNext[mask] 记录完成mask课程后，能够学习的课程。</p> 
<h3><a id="_76"></a>动态规划的初始值</h3> 
<p>pre={0}</p> 
<h3><a id="_78"></a>动态规划的填表顺序</h3> 
<p>i从0到大</p> 
<h3><a id="_80"></a>动态规划的返回值</h3> 
<p>pre 包括(1&lt;&lt;n)-1时的i。</p> 
<h2><a id="_83"></a>代码</h2> 
<h3><a id="_84"></a>核心代码</h3> 
<pre><code class="prism language-cpp"><span class="token comment">//通过 x &amp;= (x-1)实现</span>
<span class="token keyword">int</span> <span class="token function">bitcount</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> countx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		countx<span class="token operator">++</span><span class="token punctuation">;</span>
		x <span class="token operator">&amp;=</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> countx<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> <span class="token function">minNumberOfSemesters</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> relations<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> <span class="token keyword">int</span> iMaskCount <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vPre</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v <span class="token operator">:</span> relations<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			vPre<span class="token punctuation">[</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vNext</span><span class="token punctuation">(</span>iMaskCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> iMaskCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>vPre<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> vPre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					vNext<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pre <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">vHasDo</span><span class="token punctuation">(</span>iMaskCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> dp<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> iPre <span class="token operator">:</span> pre<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>iPre <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> iMaskCount<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> i<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">const</span> <span class="token keyword">int</span> iRemain <span class="token operator">=</span> <span class="token punctuation">(</span>iMaskCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> iPre<span class="token punctuation">;</span>
				<span class="token keyword">const</span> <span class="token keyword">int</span> iCanSel <span class="token operator">=</span> iRemain<span class="token operator">&amp;</span> vNext<span class="token punctuation">[</span>iPre<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">auto</span> Add <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> cur<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">const</span> <span class="token keyword">int</span> iNew <span class="token operator">=</span> cur <span class="token operator">|</span> iPre<span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vHasDo<span class="token punctuation">[</span>iNew<span class="token punctuation">]</span><span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						dp<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>iNew<span class="token punctuation">)</span><span class="token punctuation">;</span>
						vHasDo<span class="token punctuation">[</span>iNew<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bitcount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>iCanSel<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">Add</span><span class="token punctuation">(</span>iCanSel<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> cur <span class="token operator">=</span> iCanSel<span class="token punctuation">;</span> cur<span class="token punctuation">;</span> cur <span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> iCanSel<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>					
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bitcount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>cur<span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						<span class="token function">Add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			pre<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_159"></a>测试用例</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Assert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t1<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> t2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>t1 <span class="token operator">==</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Assert</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v1<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">Assert</span><span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>	
	<span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> relations<span class="token punctuation">;</span>
	<span class="token punctuation">{<!-- --></span>
		Solution sln<span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> relations <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> res <span class="token operator">=</span> sln<span class="token punctuation">.</span><span class="token function">minNumberOfSemesters</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> relations<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">Assert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">{<!-- --></span>
		Solution sln<span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> relations <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> res <span class="token operator">=</span> sln<span class="token punctuation">.</span><span class="token function">minNumberOfSemesters</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> relations<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">Assert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">{<!-- --></span>
		Solution sln<span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">,</span> relations <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> res <span class="token operator">=</span> sln<span class="token punctuation">.</span><span class="token function">minNumberOfSemesters</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> relations<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">Assert</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_208"></a>动态规划</h2> 
<p><strong>剪枝</strong> 忽略非法的前者状态。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//通过 x &amp;= (x-1)实现</span>
<span class="token keyword">int</span> <span class="token function">bitcount</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> countx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		countx<span class="token operator">++</span><span class="token punctuation">;</span>
		x <span class="token operator">&amp;=</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> countx<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ELE</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">ELE2</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">MinSelf</span><span class="token punctuation">(</span>ELE<span class="token operator">*</span> seft<span class="token punctuation">,</span> <span class="token keyword">const</span> ELE2<span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">*</span>seft <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">*</span>seft<span class="token punctuation">,</span><span class="token punctuation">(</span>ELE<span class="token punctuation">)</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ELE</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">MaxSelf</span><span class="token punctuation">(</span>ELE<span class="token operator">*</span> seft<span class="token punctuation">,</span> <span class="token keyword">const</span> ELE<span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">*</span>seft <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">*</span>seft<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> <span class="token function">minNumberOfSemesters</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> relations<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> <span class="token keyword">int</span> iMaskCount <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span>		
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vPre</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v <span class="token operator">:</span> relations<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			vPre<span class="token punctuation">[</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vNext</span><span class="token punctuation">(</span>iMaskCount<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vLen</span><span class="token punctuation">(</span>iMaskCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> iMaskCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			vLen<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">bitcount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>vPre<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> vPre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					vNext<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vRet</span><span class="token punctuation">(</span>iMaskCount<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		vRet<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> iMaskCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>		
            <span class="token keyword">if</span><span class="token punctuation">(</span>vRet<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">100</span> <span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
			<span class="token keyword">const</span> <span class="token keyword">int</span> iNeedStudy <span class="token operator">=</span> <span class="token punctuation">(</span>iMaskCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> i<span class="token punctuation">;</span><span class="token comment">//未学课程</span>
			<span class="token keyword">const</span> <span class="token keyword">int</span> iCanStudy <span class="token operator">=</span> iNeedStudy <span class="token operator">&amp;</span> vNext<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//只能学前置课程已学的课程</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>vLen<span class="token punctuation">[</span>iCanStudy<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">MinSelf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vRet<span class="token punctuation">[</span>i<span class="token operator">|</span> iCanStudy<span class="token punctuation">]</span><span class="token punctuation">,</span> vRet<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> iCanStudy<span class="token punctuation">;</span> j<span class="token punctuation">;</span> j<span class="token operator">=</span> iCanStudy <span class="token operator">&amp;</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span><span class="token comment">//i是已学课程，j是本学期将学的课程	</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bitcount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token punctuation">)</span>j<span class="token punctuation">)</span> <span class="token operator">!=</span> k <span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token function">MinSelf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vRet<span class="token punctuation">[</span>i <span class="token operator">|</span> j<span class="token punctuation">]</span><span class="token punctuation">,</span> vRet<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>	
		<span class="token keyword">return</span> vRet<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="20232_283"></a>2023年2月第一版</h2> 
<p>class Solution {<!-- --><br> public:<br> int minNumberOfSemesters(int n, vector&lt;vector&gt;&amp; relations, int k) {<!-- --><br> m_iN = n;<br> m_iK = k;<br> m_iMaskNum = 1 &lt;&lt; n;<br> m_vPreCourse.resize(n);<br> for (const auto&amp; v : relations)<br> {<!-- --><br> m_vPreCourse[v[1] - 1] |= (1 &lt;&lt; (v[0] - 1));<br> } <br> m_vMinSemesters.resize(m_iMaskNum, m_iNotMay);<br> vector pre(1);<br> m_vMinSemesters[0] = 0;<br> for (int iSem = 0;; iSem++)<br> {<!-- --><br> vector dp;<br> for (const auto&amp; pr : pre)<br> {<!-- --><br> if (pr + 1 == m_iMaskNum)<br> {<!-- --><br> return iSem;<br> }<br> int iCanStudy = GetCanStudy(pr); <br> dfs(dp, pr, iCanStudy, iCanStudy, k,-1);<br> }<br> pre.swap(dp);<br> }<br> return 0;<br> }<br> inline int GetCanStudy(int preMask)const<br> {<!-- --><br> int iCanStudy = 0;<br> for (int n = 0; n &lt; m_iN; n++)<br> {<!-- --><br> if (preMask &amp; (1 &lt;&lt; n))<br> {//之前已经学习<br> continue;<br> }<br> if ((m_vPreCourse[n] &amp; preMask) != m_vPreCourse[n])<br> {//先行课程没有学习<br> continue;<br> }<br> iCanStudy |= (1 &lt;&lt; n);<br> }<br> return iCanStudy;<br> }<br> void dfs(vector&amp; dp, const int&amp; preMask, const int&amp; iCanStudy, int iRemain, int iLeve,int iPreN)<br> {<!-- --><br> if ((0 == iLeve) || (0 == iRemain))<br> {<!-- --><br> const int iNewMask = preMask |(iCanStudy - iRemain );<br> if (m_iNotMay != m_vMinSemesters[iNewMask])<br> {<!-- --><br> return;<br> }<br> dp.push_back(iNewMask);<br> m_vMinSemesters[iNewMask] = m_vMinSemesters[preMask] + 1;<br> return;<br> }<br> for (int n = iPreN+1; n &lt; m_iN; n++)<br> {<!-- --><br> if (iRemain &amp; (1 &lt;&lt; n))<br> {<!-- --><br> dfs(dp, preMask, iCanStudy, iRemain -(1 &lt;&lt; n ), iLeve - 1,n);<br> } <br> }<br> }<br> vector m_vPreCourse;<br> vector m_vMinSemesters;<br> int m_iMaskNum;<br> int m_iK;<br> int m_iN;<br> const int m_iNotMay = 1000 * 1000;<br> };</p> 
<h2><a id="20232_359"></a>2023年2月第二版</h2> 
<p>class Solution {<!-- --><br> public:<br> int minNumberOfSemesters(int n, vector&lt;vector&gt;&amp; relations, int k) {<!-- --><br> m_iN = n;<br> m_iK = k;<br> m_iMaskNum = 1 &lt;&lt; n;<br> m_vPreCourse.resize(n);<br> for (const auto&amp; v : relations)<br> {<!-- --><br> m_vPreCourse[v[1] - 1] |= (1 &lt;&lt; (v[0] - 1));<br> } <br> m_vMinSemesters.resize(m_iMaskNum, m_iNotMay);<br> vector pre(1);<br> m_vMinSemesters[0] = 0;<br> for (int iSem = 0;; iSem++)<br> {<!-- --><br> vector dp;<br> for (const auto&amp; pr : pre)<br> {<!-- --><br> if (pr + 1 == m_iMaskNum)<br> {<!-- --><br> return iSem;<br> }<br> int iCanStudy = GetCanStudy(pr); <br> dfs(dp, pr, iCanStudy, iCanStudy, k, iCanStudy);<br> }<br> pre.swap(dp);<br> }<br> return 0;<br> }<br> inline int GetCanStudy(int preMask)const<br> {<!-- --><br> int iCanStudy = 0;<br> for (int n = 0; n &lt; m_iN; n++)<br> {<!-- --><br> if (preMask &amp; (1 &lt;&lt; n))<br> {//之前已经学习<br> continue;<br> }<br> if ((m_vPreCourse[n] &amp; preMask) != m_vPreCourse[n])<br> {//先行课程没有学习<br> continue;<br> }<br> iCanStudy |= (1 &lt;&lt; n);<br> }<br> return iCanStudy;<br> }<br> void dfs(vector&amp; dp, const int&amp; preMask, const int&amp; iCanStudy, int iRemain, int iLeve,int iCanSel)<br> {<!-- --><br> if ((0 == iLeve) || (0 == iCanSel))<br> {<!-- --><br> const int iNewMask = preMask |(iCanStudy - iRemain );<br> if (m_iNotMay != m_vMinSemesters[iNewMask])<br> {<!-- --><br> return;<br> }<br> dp.push_back(iNewMask);<br> m_vMinSemesters[iNewMask] = m_vMinSemesters[preMask] + 1;<br> return;<br> }<br> while (iCanSel)<br> {<!-- --><br> const int iNextCanSel = (iCanSel - 1)&amp; iCanSel;<br> const int n = iCanSel - iNextCanSel;<br> iCanSel = iNextCanSel;<br> dfs(dp, preMask, iCanStudy, iRemain-n, iLeve - 1, iCanSel);<br> } <br> }<br> vector m_vPreCourse;<br> vector m_vMinSemesters;<br> int m_iMaskNum;<br> int m_iK;<br> int m_iN;<br> const int m_iNotMay = 1000 * 1000;<br> };</p> 
<h2><a id="20237_436"></a>2023年7月版</h2> 
<p>using namespace std;</p> 
<p>template<br> void OutToConsoleInner(const vector&amp; vec, const string&amp; strSep = " ")<br> {<!-- --><br> for (int i = 0; i &lt; vec.size(); i++)<br> {<!-- --><br> if (0 != i % 25)<br> {<!-- --><br> std::cout &lt;&lt; strSep.c_str();<br> }<br> std::cout &lt;&lt; setw(3) &lt;&lt; setfill(’ ') &lt;&lt; vec[i];<br> if (0 == (i + 1) % 25)<br> {<!-- --><br> std::cout &lt;&lt; std::endl;<br> }<br> else if (0 == (i + 1) % 5)<br> {<!-- --><br> std::cout &lt;&lt; strSep.c_str();<br> }<br> }<br> }</p> 
<p>class CConsole<br> {<!-- --><br> public:</p> 
<pre><code>template&lt;class T&gt;
static void Out(const vector&lt;T&gt;&amp; vec, const string&amp; strColSep = " ", const string&amp; strRowSep = "\r\n")
{
	OutToConsoleInner(vec, strColSep);
	std::cout &lt;&lt; strRowSep.c_str();
}

template&lt;class T&gt;
static void Out(const vector&lt;vector&lt;T&gt;&gt;&amp; matrix, const string&amp; strColSep = " ", const string&amp; strRowSep = "\r\n")
{
	for (int i = 0; i &lt; matrix.size(); i++)
	{
		OutToConsoleInner(matrix[i], strColSep);
		std::cout &lt;&lt; strRowSep.c_str();
	}
}

template&lt;class T&gt;
static void Out(const std::map&lt;T, std::vector&lt;int&gt; &gt;&amp; mTopPointToPoints, const string&amp; strColSep = " ", const string&amp; strRowSep = "\r\n")
{
	for (auto kv : mTopPointToPoints)
	{
		std::cout &lt;&lt; kv.first &lt;&lt; ":";
		OutToConsoleInner(kv.second, strColSep);
		std::cout &lt;&lt; strRowSep.c_str();
	}
}


static void Out(const  std::string&amp; t, const string&amp; strColSep = " ", const string&amp; strRowSep = "\r\n")
{
	std::cout &lt;&lt; t.c_str() &lt;&lt; strColSep.c_str();
}

template&lt;class T  &gt;
static void Out(const T&amp; t, const string&amp; strColSep = " ", const string&amp; strRowSep = "\r\n")
{
	std::cout &lt;&lt; t &lt;&lt; strColSep.c_str();
}
</code></pre> 
<p>};</p> 
<p>void GenetateSum(vector&amp; sums, const vector&amp; nums)<br> {<!-- --><br> sums.push_back(0);<br> for (int i = 0; i &lt; nums.size(); i++)<br> {<!-- --><br> sums.push_back(nums[i] + sums[i]);<br> }<br> }</p> 
<p>//[iBegin，iEnd]之和<br> long long Total(int iBegin, int iEnd)<br> {<!-- --><br> return (long long)(iBegin + iEnd) * (iEnd - iBegin + 1) / 2;<br> }</p> 
<p>class CLadderhlp<br> {<!-- --><br> public:<br> CLadderhlp(int ladders)<br> {<!-- --><br> m_uLadderNum = ladders;<br> }<br> void AddNeedBick(int iNeedBick)<br> {<!-- --><br> if (0 == m_uLadderNum)<br> {<!-- --><br> return;<br> }<br> if (m_ladders.size() &lt; m_uLadderNum)<br> {<!-- --><br> m_ladders.push(iNeedBick);<br> m_iEaqualBicks += iNeedBick;<br> return;<br> }<br> int iTop = m_ladders.top();<br> if (iTop &gt;= iNeedBick)<br> {<!-- --><br> return;<br> }<br> m_iEaqualBicks -= iTop;<br> m_iEaqualBicks += iNeedBick;<br> m_ladders.pop();<br> m_ladders.push(iNeedBick);<br> }<br> std::priority_queue&lt;int, vector, std::greater &gt; m_ladders;<br> unsigned int m_uLadderNum;<br> long long m_iEaqualBicks = 0;<br> };</p> 
<p>struct CPeo<br> {<!-- --><br> CPeo(string strName, CPeo* pParent = nullptr)<br> {<!-- --><br> m_strName = strName;<br> m_pParent = pParent;<br> }<br> string m_strName;<br> vector&lt;CPeo*&gt; m_childs;<br> CPeo* m_pParent = nullptr;<br> };</p> 
<p>class CNeighborTable<br> {<!-- --><br> public:<br> void Init(const vector&lt;vector&gt;&amp; edges)<br> {<!-- --></p> 
<pre><code>}
vector&lt;vector&lt;int&gt;&gt; m_vTable;
</code></pre> 
<p>};</p> 
<p>//通过 x &amp;= (x-1)实现<br> int bitcount(unsigned x) {<!-- --><br> int countx = 0;<br> while (x) {<!-- --><br> countx++;<br> x &amp;= (x - 1);<br> }<br> return countx;<br> }</p> 
<p>int bitcount(unsigned long long x) {<!-- --><br> int countx = 0;<br> while (x) {<!-- --><br> countx++;<br> x &amp;= (x - 1);<br> }<br> return countx;<br> }</p> 
<p>class CRange<br> {<!-- --><br> public:<br> template<br> CRange(const T&amp; v)<br> {<!-- --><br> m_iBegin = 0;<br> m_iEnd = v.size();<br> }<br> bool In(int iIndex)<br> {<!-- --><br> return (iIndex &gt;= m_iBegin) &amp;&amp; (iIndex &lt; m_iEnd);<br> }<br> const int End()<br> {<!-- --><br> return m_iEnd;<br> }<br> protected:<br> int m_iBegin;<br> int m_iEnd;<br> };</p> 
<p>template<br> class CTrie<br> {<!-- --><br> public:<br> CTrie() :m_vPChilds(iTypeNum)<br> {<!-- --></p> 
<pre><code>}
template&lt;class IT&gt;
void Add(IT begin, IT end)
{
	CTrie&lt;iTypeNum, cBegin&gt;* pNode = this;
	for (; begin != end; ++begin)
	{
		pNode = pNode-&gt;AddChar(*begin).get();
	}
}
template&lt;class IT&gt;
bool Search(IT begin, IT end)
{
	if (begin == end)
	{
		return true;
	}

	if ('.' == *begin)
	{
		for (auto&amp; ptr : m_vPChilds)
		{
			if (!ptr)
			{
				continue;
			}
			if (ptr-&gt;Search(begin + 1, end))
			{
				return true;
			}
		}
	}

	auto ptr = GetChild(*begin);
	if (nullptr == ptr)
	{
		return false;
	}
	return ptr-&gt;Search(begin + 1, end);
}
</code></pre> 
<p>protected:<br> std::shared_ptr AddChar(char ch)<br> {<!-- --><br> if ((ch &lt; cBegin) || (ch &gt;= cBegin + iTypeNum))<br> {<!-- --><br> return nullptr;<br> }<br> const int index = ch - cBegin;<br> auto ptr = m_vPChilds[index];<br> if (!ptr)<br> {<!-- --><br> m_vPChilds[index] = std::make_shared&lt;CTrie&lt;iTypeNum, cBegin&gt;&gt;();<br> }<br> return m_vPChilds[index];<br> }<br> std::shared_ptr GetChild(char ch)const<br> {<!-- --><br> if ((ch &lt; cBegin) || (ch &gt;= cBegin + iTypeNum))<br> {<!-- --><br> return nullptr;<br> }<br> return m_vPChilds[ch - cBegin];<br> }<br> std::vector&lt;std::shared_ptr&gt; m_vPChilds;<br> };</p> 
<p>class CWords<br> {<!-- --><br> public:<br> void Add(const string&amp; word)<br> {<!-- --><br> m_strStrs.insert(word);<br> }<br> bool Search(const string&amp; word)<br> {<!-- --><br> return Search(m_strStrs.begin(), m_strStrs.end(), 0, word.length(), word);<br> }<br> protected:<br> bool Search(std::set::const_iterator begin, std::set::const_iterator end, int iStrBegin, int iStrEnd, const string&amp; str)<br> {<!-- --><br> int i = iStrBegin;<br> for (; (i &lt; iStrEnd) &amp;&amp; (str[i] != ‘.’); i++);<br> auto it = std::equal_range(begin, end, str, [&amp;iStrBegin, &amp;i](const string&amp; s, const string&amp; sFind)<br> {<!-- --><br> return s.substr(iStrBegin, i - iStrBegin) &lt; sFind.substr(iStrBegin, i - iStrBegin);<br> });<br> if (i == iStrBegin)<br> {<!-- --><br> it.first = begin;<br> it.second = end;<br> }<br> if (it.first == it.second)<br> {<!-- --><br> return false;<br> }<br> if (i == iStrEnd)<br> {<!-- --><br> return true;<br> }<br> if (i + 1 == iStrEnd)<br> {<!-- --><br> return true;<br> }<br> string tmp = str;<br> for (char ch = ‘a’; ch &lt;= ‘z’; ch++)<br> {<!-- --><br> tmp[i] = ch;<br> auto ij = std::equal_range(it.first, it.second, tmp, [&amp;ch, &amp;i](const string&amp; s, const string&amp; sFind)<br> {<!-- --><br> return s[i] &lt; sFind[i];<br> });<br> if (ij.first == ij.second)<br> {<!-- --><br> continue;<br> }</p> 
<pre><code>		if (Search(ij.first, ij.second, i + 1, iStrEnd, str))
		{
			return true;
		}
	}
	return false;
}

std::set&lt;string&gt; m_strStrs;
</code></pre> 
<p>};<br> class WordDictionary {<!-- --><br> public:<br> WordDictionary() {<!-- --><br> for (int i = 0; i &lt; 26; i++)<br> {<!-- --><br> m_str[i] = std::make_unique();<br> }<br> }</p> 
<pre><code>void addWord(string word) {
	m_str[word.length()]-&gt;Add(word);
}

bool search(string word) {
	return m_str[word.length()]-&gt;Search(word);
}
std::unique_ptr&lt;CWords&gt; m_str[26];
</code></pre> 
<p>};</p> 
<p>template<br> class C1097Int<br> {<!-- --><br> public:<br> C1097Int(long long llData = 0) :m_iData(llData% MOD)<br> {<!-- --></p> 
<pre><code>}
C1097Int  operator+(const C1097Int&amp; o)const
{
	return C1097Int(((long long)m_iData + o.m_iData) % MOD);
}
C1097Int&amp; operator+=(const C1097Int&amp; o)
{
	m_iData = ((long long)m_iData + o.m_iData) % MOD;
	return *this;
}
C1097Int&amp; operator-=(const C1097Int&amp; o)
{
	m_iData = (m_iData + MOD - o.m_iData) % MOD;
	return *this;
}
C1097Int  operator-(const C1097Int&amp; o)
{
	return C1097Int((m_iData + MOD - o.m_iData) % MOD);
}
C1097Int  operator*(const C1097Int&amp; o)const
{
	return((long long)m_iData * o.m_iData) % MOD;
}
C1097Int&amp; operator*=(const C1097Int&amp; o)
{
	m_iData = ((long long)m_iData * o.m_iData) % MOD;
	return *this;
}
bool operator&lt;(const C1097Int&amp; o)const
{
	return m_iData &lt; o.m_iData;
}
C1097Int pow(int n)const
{
	C1097Int iRet = 1, iCur = *this;
	while (n)
	{
		if (n &amp; 1)
		{
			iRet *= iCur;
		}
		iCur *= iCur;
		n &gt;&gt;= 1;
	}
	return iRet;
}
C1097Int PowNegative1()const
{
	return pow(MOD - 2);
}
int ToInt()const
{
	return m_iData;
}
</code></pre> 
<p>private:<br> int m_iData = 0;;<br> };</p> 
<p>template<br> int operator+(int iData, const C1097Int&amp; int1097)<br> {<!-- --><br> int iRet = int1097.operator+(C1097Int(iData)).ToInt();<br> return iRet;<br> }</p> 
<p>template<br> int&amp; operator+=(int&amp; iData, const C1097Int&amp; int1097)<br> {<!-- --><br> iData = int1097.operator+(C1097Int(iData)).ToInt();<br> return iData;<br> }</p> 
<p>template<br> int operator*(int iData, const C1097Int&amp; int1097)<br> {<!-- --><br> int iRet = int1097.operator*(C1097Int(iData)).ToInt();<br> return iRet;<br> }</p> 
<p>template<br> int&amp; operator*=(int&amp; iData, const C1097Int&amp; int1097)<br> {<!-- --><br> iData = int1097.operator*(C1097Int(iData)).ToInt();<br> return iData;<br> }</p> 
<p>template<br> void MinSelf(T* seft, const T&amp; other)<br> {<!-- --><br> *seft = min(*seft, other);<br> }</p> 
<p>template<br> void MaxSelf(T* seft, const T&amp; other)<br> {<!-- --><br> *seft = max(*seft, other);<br> }</p> 
<p>int GetNotRepeateNum(int len, int iHasSel)<br> {<!-- --><br> if (0 == len)<br> {<!-- --><br> return 1;<br> }<br> if ((0 == iHasSel) &amp;&amp; (1 == len))<br> {<!-- --><br> return 10;<br> }<br> int iRet = 1;<br> if (iHasSel &gt; 0)<br> {<!-- --><br> for (int tmp = 10 - iHasSel; (tmp &gt;= 2) &amp;&amp; len; tmp–, len–)<br> {<!-- --><br> iRet *= tmp;<br> }<br> }<br> else<br> {<!-- --><br> iRet *= 9;<br> len–;<br> for (int tmp = 9; (tmp &gt;= 2) &amp;&amp; len; len–, tmp–)<br> {<!-- --><br> iRet *= tmp;<br> }<br> }<br> return iRet;<br> }</p> 
<p>int GCD(int n1, int n2)<br> {<!-- --><br> int t1 = min(n1, n2);<br> int t2 = max(n1, n2);<br> if (0 == t1)<br> {<!-- --><br> return t2;<br> }<br> return GCD(t2 % t1, t1);<br> }</p> 
<p>void CreateMaskVector(vector&amp; v, const int* const p, int n)<br> {<!-- --><br> const int iMaxMaskNum = 1 &lt;&lt; n;<br> v.resize(iMaxMaskNum);<br> for (int i = 0; i &lt; n; i++)<br> {<!-- --><br> v[1 &lt;&lt; i] = p[i];<br> }<br> for (int mask = 1; mask &lt; iMaxMaskNum; mask++)<br> {<!-- --><br> const int iSubMask = mask &amp; (-mask);<br> v[mask] = v[iSubMask] + v[mask - iSubMask];<br> }<br> }</p> 
<p>class CMaxLineTree<br> {<!-- --><br> public:<br> CMaxLineTree(int iArrSize) :m_iArrSize(iArrSize), m_vData(iArrSize * 4)<br> {<!-- --></p> 
<pre><code>}
//iIndex 从0开始
void Modify(int iIndex, int iValue)
{
	Modify(1, 1, m_iArrSize, iIndex + 1, iValue);
}
//iNeedQueryLeft iNeedQueryRight 从0开始
int Query(const int iNeedQueryLeft, const int iNeedQueryRight)
{
	return Query(1, 1, m_iArrSize, iNeedQueryLeft + 1, iNeedQueryRight + 1);
}
</code></pre> 
<p>protected:<br> int Query(const int iTreeNodeIndex, const int iRecordLeft, const int iRecordRight, const int iNeedQueryLeft, const int iNeedQueryRight)<br> {<!-- --><br> if ((iNeedQueryLeft &lt;= iRecordLeft) &amp;&amp; (iNeedQueryRight &gt;= iRecordRight))<br> {<!-- --><br> return m_vData[iTreeNodeIndex];<br> }<br> const int iMid = (iRecordLeft + iRecordRight) / 2;<br> int iRet = 0;<br> if (iNeedQueryLeft &lt;= iMid)<br> {<!-- --><br> iRet = Query(iTreeNodeIndex * 2, iRecordLeft, iMid, iNeedQueryLeft, iNeedQueryRight);<br> }<br> if (iNeedQueryRight &gt; iMid)<br> {<!-- --><br> iRet = max(iRet, Query(iTreeNodeIndex * 2 + 1, iMid + 1, iRecordRight, iNeedQueryLeft, iNeedQueryRight));<br> }<br> return iRet;<br> }<br> void Modify(int iTreeNodeIndex, int iLeft, int iRight, int iIndex, int iValue)<br> {<!-- --><br> if (iLeft == iRight)<br> {<!-- --><br> m_vData[iTreeNodeIndex] = max(m_vData[iTreeNodeIndex], iValue);<br> return;<br> }<br> const int iMid = (iLeft + iRight) / 2;<br> if (iIndex &lt;= iMid)<br> {<!-- --><br> Modify(iTreeNodeIndex * 2, iLeft, iMid, iIndex, iValue);<br> }<br> else<br> {<!-- --><br> Modify(iTreeNodeIndex * 2 + 1, iMid + 1, iRight, iIndex, iValue);<br> }<br> m_vData[iTreeNodeIndex] = max(m_vData[iTreeNodeIndex * 2], m_vData[iTreeNodeIndex * 2 + 1]);<br> }<br> const int m_iArrSize;<br> std::vector m_vData;<br> };</p> 
<p>class CMaxLineTreeMap<br> {<!-- --><br> public:<br> CMaxLineTreeMap(int iArrSize) :m_iArrSize(iArrSize)<br> {<!-- --></p> 
<pre><code>}
//iIndex 从0开始
void Modify(int iIndex, int iValue)
{
	Modify(1, 1, m_iArrSize, iIndex + 1, iValue);
}
//iNeedQueryLeft iNeedQueryRight 从0开始
int Query(const int iNeedQueryLeft, const int iNeedQueryRight)
{
	return Query(1, 1, m_iArrSize, iNeedQueryLeft + 1, iNeedQueryRight + 1);
}
</code></pre> 
<p>protected:<br> int Query(const int iTreeNodeIndex, const int iRecordLeft, const int iRecordRight, const int iNeedQueryLeft, const int iNeedQueryRight)<br> {<!-- --><br> if ((iNeedQueryLeft &lt;= iRecordLeft) &amp;&amp; (iNeedQueryRight &gt;= iRecordRight))<br> {<!-- --><br> return m_mData[iTreeNodeIndex];<br> }<br> const int iMid = (iRecordLeft + iRecordRight) / 2;<br> int iRet = 0;<br> if (iNeedQueryLeft &lt;= iMid)<br> {<!-- --><br> iRet = Query(iTreeNodeIndex * 2, iRecordLeft, iMid, iNeedQueryLeft, iNeedQueryRight);<br> }<br> if (iNeedQueryRight &gt; iMid)<br> {<!-- --><br> iRet = max(iRet, Query(iTreeNodeIndex * 2 + 1, iMid + 1, iRecordRight, iNeedQueryLeft, iNeedQueryRight));<br> }<br> return iRet;<br> }<br> void Modify(int iTreeNodeIndex, int iLeft, int iRight, int iIndex, int iValue)<br> {<!-- --><br> if (iLeft == iRight)<br> {<!-- --><br> m_mData[iTreeNodeIndex] = max(m_mData[iTreeNodeIndex], iValue);<br> return;<br> }<br> const int iMid = (iLeft + iRight) / 2;<br> if (iIndex &lt;= iMid)<br> {<!-- --><br> Modify(iTreeNodeIndex * 2, iLeft, iMid, iIndex, iValue);<br> }<br> else<br> {<!-- --><br> Modify(iTreeNodeIndex * 2 + 1, iMid + 1, iRight, iIndex, iValue);<br> }<br> m_mData[iTreeNodeIndex] = max(m_mData[iTreeNodeIndex * 2], m_mData[iTreeNodeIndex * 2 + 1]);<br> }<br> const int m_iArrSize;<br> std::unordered_map&lt;int, int&gt; m_mData;<br> };</p> 
<p>template<br> class CSumLineTree<br> {<!-- --><br> public:<br> CSumLineTree(int iEleSize) :m_iEleSize(iEleSize), m_vArr(m_iEleSize * 4), m_vChildAdd(m_iEleSize * 4)<br> {<!-- --></p> 
<pre><code>}
void Add(int iLeftIndex, int iRightIndex, int iValue)
{
	Add(1, 1, m_iEleSize, iLeftIndex + 1, iRightIndex + 1, iValue);
}
T Query(int iLeftIndex, int iRightIndex)
{
	return Query(1, 1, m_iEleSize, iLeftIndex + 1, iRightIndex + 1);
}
</code></pre> 
<p>private:<br> T Query(int iNode, int iDataLeft, int iDataRight, int iOpeLeft, int iOpeRight)<br> {<!-- --><br> if ((iOpeLeft &lt;= iDataLeft) &amp;&amp; (iOpeRight &gt;= iDataRight))<br> {<!-- --><br> return m_vArr[iNode];<br> }<br> Fresh(iNode, iDataLeft, iDataRight);<br> const int iMid = iDataLeft + (iDataRight - iDataLeft) / 2;<br> T ret(0);<br> if (iMid &gt;= iOpeLeft)<br> {<!-- --><br> ret += Query(iNode * 2, iDataLeft, iMid, iOpeLeft, iOpeRight);<br> }<br> if (iMid + 1 &lt;= iOpeRight)<br> {<!-- --><br> ret += Query(iNode * 2 + 1, iMid + 1, iDataRight, iOpeLeft, iOpeRight);<br> }<br> return ret;<br> }<br> /* 暴力解法<br> void Add(int iNode, int iDataLeft, int iDataRight, int iOpeLeft, int iOpeRight, int iValue)<br> {<!-- --><br> m_vArr[iNode] += T(iValue)*(min(iDataRight, iOpeRight) - max(iDataLeft, iOpeLeft)+1);<br> if (iDataLeft == iDataRight)<br> {<!-- --><br> return;<br> }<br> const int iMid = iDataLeft + (iDataRight - iDataLeft) / 2;<br> if (iMid &gt;= iOpeLeft)<br> {<!-- --><br> Add(iNode * 2, iDataLeft, iMid, iOpeLeft, iOpeRight, iValue);<br> }<br> if (iMid + 1 &lt;= iOpeRight)<br> {<!-- --><br> Add(iNode * 2 + 1, iMid + 1, iDataRight, iOpeLeft, iOpeRight, iValue);<br> }<br> }<br> */<br> void Fresh(int iNode, int iDataLeft, int iDataRight)<br> {<!-- --><br> const int iMid = iDataLeft + (iDataRight - iDataLeft) / 2;<br> if (m_vChildAdd[iNode] != 0)<br> {<!-- --><br> Add(iNode * 2, iDataLeft, iMid, iDataLeft, iMid, m_vChildAdd[iNode]);<br> Add(iNode * 2 + 1, iMid + 1, iDataRight, iMid + 1, iDataRight, m_vChildAdd[iNode]);<br> m_vChildAdd[iNode] = 0;<br> }<br> }<br> //懒惰法<br> void Add(int iNode, int iDataLeft, int iDataRight, int iOpeLeft, int iOpeRight, int iValue)<br> {<!-- --><br> m_vArr[iNode] += T(iValue) * (min(iDataRight, iOpeRight) - max(iDataLeft, iOpeLeft) + 1);<br> if ((iOpeLeft &lt;= iDataLeft) &amp;&amp; (iOpeRight &gt;= iDataRight))<br> {<!-- --><br> m_vChildAdd[iNode] += T(iValue);<br> return;<br> }</p> 
<pre><code>	Fresh(iNode, iDataLeft, iDataRight);
	const int iMid = iDataLeft + (iDataRight - iDataLeft) / 2;
	if (iMid &gt;= iOpeLeft)
	{
		Add(iNode * 2, iDataLeft, iMid, iOpeLeft, iOpeRight, iValue);
	}
	if (iMid + 1 &lt;= iOpeRight)
	{
		Add(iNode * 2 + 1, iMid + 1, iDataRight, iOpeLeft, iOpeRight, iValue);
	}
}

const int m_iEleSize;
vector&lt;T&gt; m_vArr;
vector&lt;int&gt; m_vChildAdd;
</code></pre> 
<p>};</p> 
<p>template<br> class CTreeArr<br> {<!-- --><br> public:<br> CTreeArr(int iSize) :m_vData(iSize + 1)<br> {<!-- --></p> 
<pre><code>}
void Add(int index, T value)
{
	index++;
	while (index &lt; m_vData.size())
	{
		m_vData[index] += value;
		index += index &amp; (-index);
	}
}
T Sum(int index)
{
	index++;
	T ret = 0;
	while (index)
	{
		ret += m_vData[index];
		index -= index &amp; (-index);
	}
	return ret;
}
T Get(int index)
{
	return Sum(index) - Sum(index - 1);
}
</code></pre> 
<p>private:<br> vector m_vData;<br> };</p> 
<p>//iCodeNum 必须大于等于可能的字符数<br> template<br> class CHashStr {<!-- --><br> public:<br> CHashStr(string s, int iCodeNum, int iCodeBegin = 1, char chBegin = ‘a’) {<!-- --><br> m_c = s.length();<br> m_vP.resize(m_c + 1);<br> m_vP[0] = 1;<br> m_vHash.resize(m_c + 1);<br> for (int i = 0; i &lt; m_c; i++)<br> {<!-- --><br> const int P = iCodeBegin + iCodeNum;<br> m_vHash[i + 1] = m_vHash[i] * P + s[i] - chBegin + iCodeBegin;<br> m_vP[i + 1] = m_vP[i] * P;<br> }<br> }<br> //包括left right<br> int GetHash(int left, int right)<br> {<!-- --><br> return (m_vHash[right + 1] - m_vHash[left] * m_vP[right - left + 1]).ToInt();<br> }<br> inline int GetHash(int right)<br> {<!-- --><br> return m_vHash[right + 1].ToInt();<br> }<br> int GetHashExincludeRight(int left, int right)<br> {<!-- --><br> return (m_vHash[right ] - m_vHash[left] * m_vP[right - left ]).ToInt();<br> }<br> inline int GetHashExincludeRight(int right)<br> {<!-- --><br> return m_vHash[right].ToInt();<br> }<br> int m_c;<br> vector&lt;C1097Int&gt; m_vP;<br> vector&lt;C1097Int&gt; m_vHash;<br> };</p> 
<p>template<br> class C2HashStr<br> {<!-- --><br> public:<br> C2HashStr(string s) {<!-- --><br> m_pHash1 = std::make_unique&lt;CHashStr&lt;&gt;&gt;(s, 26);<br> m_pHash2 = std::make_unique &lt; CHashStr&gt;(s, 27, 0);<br> }<br> //包括left right<br> long long GetHash(int left, int right)<br> {<!-- --><br> return (long long)m_pHash1-&gt;GetHash(left, right) * (MOD2 + 1) + m_pHash2-&gt;GetHash(left, right);<br> }<br> long long GetHash(int right)<br> {<!-- --><br> return (long long)m_pHash1-&gt;GetHash(right) * (MOD2 + 1) + m_pHash2-&gt;GetHash(right);<br> }<br> //包括Left，不包括Right<br> long long GetHashExincludeRight(int left, int right)<br> {<!-- --><br> return (long long)m_pHash1-&gt;GetHashExincludeRight(left, right) * (MOD2 + 1) + m_pHash2-&gt;GetHashExincludeRight(left, right);<br> }<br> long long GetHashExincludeRight(int right)<br> {<!-- --><br> return (long long)m_pHash1-&gt;GetHashExincludeRight(right) * (MOD2 + 1) + m_pHash2-&gt;GetHashExincludeRight(right);<br> }<br> private:<br> std::unique_ptr&lt;CHashStr&lt;&gt;&gt; m_pHash1;<br> std::unique_ptr&lt;CHashStr&gt; m_pHash2;<br> };</p> 
<p>template<br> class CDynaHashStr {<!-- --><br> public:<br> CDynaHashStr(int iCodeNum, int iCodeBegin = 1, char chBegin = ‘a’) :m_iUnit(iCodeNum + iCodeBegin), m_iP(1), m_iBegin(iCodeBegin - chBegin)<br> {<!-- --></p> 
<pre><code>}
inline void push_back(const char&amp; ch)
{
	const int iNum = ch + m_iBegin;
	m_iHash *= m_iUnit;
	m_iHash += iNum;
	m_iP *= m_iUnit;
}
inline void push_front(const char&amp; ch)
{
	const int iNum = ch + m_iBegin;
	m_iHash += m_iP * iNum;
	m_iP *= m_iUnit;
}
inline int GetHash() const
{
	return m_iHash;
}
const int m_iUnit;
const int m_iBegin;
C1097Int&lt;MOD&gt; m_iHash;
C1097Int&lt;MOD&gt; m_iP;
</code></pre> 
<p>};</p> 
<p>template<br> class C2DynaHashStr {<!-- --><br> public:<br> C2DynaHashStr(int iCodeNum, int iCodeBegin = 1, char chBegin = ‘a’)<br> {<!-- --><br> m_pHash1 = new CDynaHashStr&lt;&gt;(iCodeNum, iCodeBegin, chBegin);<br> m_pHash2 = new CDynaHashStr(iCodeNum, iCodeBegin, chBegin);<br> }<br> ~C2DynaHashStr()<br> {<!-- --><br> delete m_pHash1;<br> delete m_pHash2;<br> }<br> inline void push_back(const char&amp; ch)<br> {<!-- --><br> m_pHash1-&gt;push_back(ch);<br> m_pHash2-&gt;push_back(ch);<br> }<br> inline void push_front(const char&amp; ch)<br> {<!-- --><br> m_pHash1-&gt;push_front(ch);<br> m_pHash2-&gt;push_front(ch);<br> }<br> long long Hash()const<br> {<!-- --><br> return (long long)MOD2 * m_pHash1-&gt;m_iHash.ToInt() + m_pHash2-&gt;m_iHash.ToInt();<br> }<br> bool operator==(const C2DynaHashStr&amp; other) const<br> {<!-- --><br> return (m_pHash1-&gt;m_iHash.ToInt() == other.m_pHash1-&gt;m_iHash.ToInt()) &amp;&amp; (m_pHash2-&gt;m_iHash.ToInt() == other.m_pHash2-&gt;m_iHash.ToInt());<br> }<br> CDynaHashStr&lt;&gt;* m_pHash1;<br> CDynaHashStr* m_pHash2;<br> };<br> namespace NSort<br> {<!-- --><br> template<br> bool SortVecVec(const vector&amp; v1, const vector&amp; v2)<br> {<!-- --><br> return v1[ArrIndex] &lt; v2[ArrIndex];<br> };<br> }</p> 
<p>namespace NCmp<br> {<!-- --><br> template<br> bool Less(const std::pair&lt;Class1, int&gt;&amp; p, Class1 iData)<br> {<!-- --><br> return p.first &lt; iData;<br> }</p> 
<pre><code>template&lt;class Class1&gt;
bool  Greater(const std::pair&lt;Class1, int&gt;&amp; p, Class1 iData)
{
	return p.first &gt; iData;
}

template&lt;class _Ty1, class _Ty2&gt;
class CLessPair
{
public:
	bool operator()(const std::pair&lt;_Ty1, _Ty2&gt;&amp; p1, const std::pair&lt;_Ty1, _Ty2&gt;&amp; p2)const
	{
		return p1.first &lt; p2.first;
	}
};

template&lt;class _Ty1, class _Ty2&gt;
class CGreatePair
{
public:
	bool operator()(const std::pair&lt;_Ty1, _Ty2&gt;&amp; p1, const std::pair&lt;_Ty1, _Ty2&gt;&amp; p2)const
	{
		return p1.first &gt; p2.first;
	}
};
</code></pre> 
<p>}</p> 
<p>class CIndexVector<br> {<!-- --><br> public:<br> template<br> CIndexVector(vector&amp; data)<br> {<!-- --><br> for (int i = 0; i &lt; data.size(); i++)<br> {<!-- --><br> m_indexs.emplace_back(i);<br> }<br> std::sort(m_indexs.begin(), m_indexs.end(), [data](const int&amp; i1, const int&amp; i2)<br> {<!-- --><br> return data[i1] &lt; data[i2];<br> });<br> }<br> int GetIndex(int index)<br> {<!-- --><br> return m_indexs[index];<br> }<br> private:<br> vector m_indexs;<br> };</p> 
<p>class CMedian<br> {<!-- --><br> public:<br> void AddNum(int iNum)<br> {<!-- --><br> m_queTopMin.emplace(iNum);<br> MakeNumValid();<br> MakeSmallBig();<br> }<br> void Remove(int iNum)<br> {<!-- --><br> if (m_queTopMax.size() &amp;&amp; (iNum &lt;= m_queTopMax.top()))<br> {<!-- --><br> m_setTopMaxDel.insert(iNum);<br> }<br> else<br> {<!-- --><br> m_setTopMinDel.insert(iNum);<br> }</p> 
<pre><code>	PopIsTopIsDel(m_queTopMin, m_setTopMinDel);
	PopIsTopIsDel(m_queTopMax, m_setTopMaxDel);
	MakeNumValid();
	MakeSmallBig();
}
double Median()
{
	const int iMaxNum = m_queTopMin.size() - m_setTopMinDel.size();
	const int iMinNum = m_queTopMax.size() - m_setTopMaxDel.size();
	if (iMaxNum &gt; iMinNum)
	{
		return m_queTopMin.top();
	}
	return ((double)m_queTopMin.top() + m_queTopMax.top()) / 2.0;
}
template&lt;class T&gt;
void PopIsTopIsDel(T&amp; que, std::unordered_multiset&lt;int&gt;&amp; setTopMaxDel)
{
	while (que.size() &amp;&amp; (setTopMaxDel.count(que.top())))
	{
		setTopMaxDel.erase(setTopMaxDel.find(que.top()));
		que.pop();
	}
}
void MakeNumValid()
{
	const int iMaxNum = m_queTopMin.size() - m_setTopMinDel.size();
	const int iMinNum = m_queTopMax.size() - m_setTopMaxDel.size();
	//确保两个队的数量
	if (iMaxNum &gt; iMinNum + 1)
	{
		int tmp = m_queTopMin.top();
		m_queTopMin.pop();
		m_queTopMax.emplace(tmp);
		PopIsTopIsDel(m_queTopMin, m_setTopMinDel);
	}
	if (iMinNum &gt; iMaxNum)
	{
		int tmp = m_queTopMax.top();
		m_queTopMax.pop();
		m_queTopMin.push(tmp);
		PopIsTopIsDel(m_queTopMax, m_setTopMaxDel);
	}
}
void MakeSmallBig()
{
	if (m_queTopMin.empty() || m_queTopMax.empty())
	{
		return;
	}
	while (m_queTopMin.top() &lt; m_queTopMax.top())
	{
		const int iOldTopMin = m_queTopMin.top();
		const int iOldTopMax = m_queTopMax.top();
		m_queTopMin.pop();
		m_queTopMax.pop();
		m_queTopMin.emplace(iOldTopMax);
		m_queTopMax.emplace(iOldTopMin);
		PopIsTopIsDel(m_queTopMin, m_setTopMinDel);
		PopIsTopIsDel(m_queTopMax, m_setTopMaxDel);
	}
}
std::priority_queue&lt;int&gt; m_queTopMax;
std::priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; m_queTopMin;
std::unordered_multiset&lt;int&gt; m_setTopMaxDel, m_setTopMinDel;
</code></pre> 
<p>};</p> 
<p>template<br> class CDistanceGrid<br> {<!-- --><br> public:<br> CDistanceGrid(const vector&lt;vector&gt;&amp; grid) :m_grid(grid), m_r(grid.size()), m_c(grid[0].size())<br> {<!-- --></p> 
<pre><code>}
//单源路径 D 算法 ,时间复杂度:r*c*log(r*c)
inline int Dis(int r1, int c1, int r2, int c2)
{
	vector&lt;vector&lt;int&gt;&gt; vDis(iMaxRow, vector&lt;int&gt;(iMaxCol, INT_MAX));

	auto Add = [&amp;vDis, this](std::priority_queue&lt;pair&lt;int, int&gt;, vector&lt;std::pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt;&amp; queCur, int iDis, int r, int c)
	{
		const int iRowColMask = iMaxCol * r + c;
		if (iDis &gt;= vDis[r][c])
		{
			return;
		}
		queCur.emplace(iDis, iRowColMask);
		vDis[r][c] = iDis;
	};
	auto Move = [&amp;](std::priority_queue&lt;pair&lt;int, int&gt;, vector&lt;std::pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt;&amp; queCur, int iDis, int r, int c)
	{
		if ((r &lt; 0) || (r &gt;= m_r))
		{
			return;
		}
		if ((c &lt; 0) || (c &gt;= m_c))
		{
			return;
		}
		if (m_grid[r][c] &lt; 1)
		{
			return;
		}
		Add(queCur, iDis, r, c);
	};

	std::priority_queue&lt;pair&lt;int, int&gt;, vector&lt;std::pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; que;
	Add(que, 0, r1, c1);
	while (que.size())
	{
		const int iDis = que.top().first;
		const int iStart = que.top().second;
		que.pop();
		const int r = iStart / iMaxCol;
		const int c = iStart % iMaxCol;
		if ((r == r2) &amp;&amp; (c == c2))
		{
			return iDis;
		}
		if (iDis &gt; vDis[r][c])
		{
			continue;
		}

		Move(que, iDis + 1, r + 1, c);
		Move(que, iDis + 1, r - 1, c);
		Move(que, iDis + 1, r, c + 1);
		Move(que, iDis + 1, r, c - 1);
	}

	return -1;
}
</code></pre> 
<p>private:<br> virtual bool IsCanMoveStatue(int r, int c)<br> {<!-- --><br> return m_grid[r][c] &gt;= 1;<br> }<br> const int m_r;<br> const int m_c;<br> const vector&lt;vector&gt;&amp; m_grid;</p> 
<p>};</p> 
<p>class CBFSGridDist<br> {<!-- --><br> public:<br> CBFSGridDist(const vector&lt;vector&gt;&amp; bCanVisit, int r, int c) :m_bCanVisit(bCanVisit), m_r(m_bCanVisit.size()), m_c(m_bCanVisit[0].size())<br> {<!-- --><br> m_vDis.assign(m_r, vector(m_c, INT_MAX / 2));<br> Dist(r, c);<br> }<br> bool Vilid(const int r, const int c)<br> {<!-- --><br> if ((r &lt; 0) || (r &gt;= m_r))<br> {<!-- --><br> return false;<br> }<br> if ((c &lt; 0) || (c &gt;= m_c))<br> {<!-- --><br> return false;<br> }<br> return true;<br> }<br> const vector&lt;vector&gt;&amp; Dis()const<br> {<!-- --><br> return m_vDis;<br> }<br> const vector&lt;vector&gt;&amp; m_bCanVisit;<br> private:<br> //INT_MAX/2 表示无法到达<br> void Dist(int r, int c)<br> {<!-- --><br> m_vDis.assign(m_r, vector(m_c, INT_MAX / 2));<br> vector&lt;vector&gt; vHasDo(m_r, vector(m_c));<br> std::queue&lt;std::pair&lt;int, int&gt;&gt; que;<br> auto Add = [&amp;](const int&amp; r, const int&amp; c, const int&amp; iDis)<br> {<!-- --><br> if (!Vilid(r, c))<br> {<!-- --><br> return;<br> }<br> if (vHasDo[r][c])<br> {<!-- --><br> return;<br> }<br> if (!m_bCanVisit[r][c])<br> {<!-- --><br> vHasDo[r][c] = true;<br> return;<br> }<br> if (iDis &gt;= m_vDis[r][c])<br> {<!-- --><br> return;<br> }</p> 
<pre><code>		que.emplace(r, c);
		m_vDis[r][c] = iDis;
		vHasDo[r][c] = true;
	};
	Add(r, c, 0);
	while (que.size())
	{
		const int r = que.front().first;
		const int c = que.front().second;
		que.pop();
		const int iDis = m_vDis[r][c];
		Add(r + 1, c, iDis + 1);
		Add(r - 1, c, iDis + 1);
		Add(r, c + 1, iDis + 1);
		Add(r, c - 1, iDis + 1);
	}

}
vector&lt;vector&lt;int&gt;&gt; m_vDis;
const int m_r;
const int m_c;
</code></pre> 
<p>};</p> 
<p>class C2BNumTrieNode<br> {<!-- --><br> public:<br> C2BNumTrieNode()<br> {<!-- --><br> m_childs[0] = m_childs[1] = nullptr;<br> }<br> bool GetNot0Child(bool bFirstRight)<br> {<!-- --><br> auto ptr = m_childs[bFirstRight];<br> if (ptr &amp;&amp; (ptr-&gt;m_iNum &gt; 0))<br> {<!-- --><br> return bFirstRight;<br> }<br> return !bFirstRight;<br> }<br> int m_iNum = 0;<br> C2BNumTrieNode* m_childs[2];<br> };</p> 
<p>template<br> class C2BNumTrie<br> {<!-- --><br> public:<br> C2BNumTrie()<br> {<!-- --><br> m_pRoot = new C2BNumTrieNode();<br> }<br> void Add(int iNum)<br> {<!-- --><br> m_setHas.emplace(iNum);<br> C2BNumTrieNode* p = m_pRoot;<br> for (int i = iLeveNum - 1; i &gt;= 0; i–)<br> {<!-- --><br> p-&gt;m_iNum++;<br> bool bRight = iNum &amp; (1 &lt;&lt; i);<br> if (nullptr == p-&gt;m_childs[bRight])<br> {<!-- --><br> p-&gt;m_childs[bRight] = new C2BNumTrieNode();<br> }<br> p = p-&gt;m_childs[bRight];<br> }<br> p-&gt;m_iNum++;<br> }<br> void Del(int iNum)<br> {<!-- --><br> auto it = m_setHas.find(iNum);<br> if (m_setHas.end() == it)<br> {<!-- --><br> return;<br> }<br> m_setHas.erase(it);<br> C2BNumTrieNode* p = m_pRoot;<br> for (int i = iLeveNum - 1; i &gt;= 0; i–)<br> {<!-- --><br> p-&gt;m_iNum–;<br> bool bRight = iNum &amp; (1 &lt;&lt; i);<br> p = p-&gt;m_childs[bRight];<br> }<br> p-&gt;m_iNum–;<br> }<br> int MaxXor(int iNum)<br> {<!-- --><br> C2BNumTrieNode* p = m_pRoot;<br> int iRet = 0;<br> for (int i = iLeveNum - 1; i &gt;= 0; i–)<br> {<!-- --><br> bool bRight = !(iNum &amp; (1 &lt;&lt; i));<br> bool bSel = p-&gt;GetNot0Child(bRight);<br> p = p-&gt;m_childs[bSel];<br> if (bSel == bRight)<br> {<!-- --><br> iRet |= (1 &lt;&lt; i);<br> }<br> }<br> return iRet;<br> }<br> C2BNumTrieNode* m_pRoot;<br> std::unordered_multiset m_setHas;<br> };</p> 
<p>struct SValueItem<br> {<!-- --><br> SValueItem()<br> {<!-- --></p> 
<pre><code>}
SValueItem(int iValue)
{
	m_iCoefficient = iValue;
}
SValueItem operator*(const SValueItem&amp; o)const
{
	SValueItem ret(m_iCoefficient * o.m_iCoefficient);
	int i = 0, j = 0;
	while ((i &lt; m_vVars.size()) &amp;&amp; (j &lt; o.m_vVars.size()))
	{
		if (m_vVars[i] &lt; o.m_vVars[j])
		{
			ret.m_vVars.emplace_back(m_vVars[i]);
			i++;
		}
		else
		{
			ret.m_vVars.emplace_back(o.m_vVars[j]);
			j++;
		}
	}
	ret.m_vVars.insert(ret.m_vVars.end(), m_vVars.begin() + i, m_vVars.end());
	ret.m_vVars.insert(ret.m_vVars.end(), o.m_vVars.begin() + j, o.m_vVars.end());
	return ret;
}
bool operator&lt;(const SValueItem&amp; o)const
{
	if (m_vVars.size() == o.m_vVars.size())
	{
		return m_vVars &lt; o.m_vVars;
	}
	return m_vVars.size() &gt; o.m_vVars.size();
}
vector&lt;std::string&gt; m_vVars;
int m_iCoefficient = 1;//系数、倍率
std::string ToString()const
{
	std::ostringstream os;
	os &lt;&lt; m_iCoefficient;
	for (const auto&amp; s : m_vVars)
	{
		os &lt;&lt; "*" &lt;&lt; s;
	}
	return os.str();
}
</code></pre> 
<p>};</p> 
<p>struct SValue<br> {<!-- --><br> SValue()<br> {<!-- --></p> 
<pre><code>}
SValue(int iValue)
{
	SValueItem item;
	item.m_iCoefficient = iValue;
	m_items.emplace(item);
}
SValue(std::string strName)
{
	SValueItem item;
	item.m_vVars.emplace_back(strName);
	m_items.emplace(item);
}
SValue operator-(const SValue&amp; o)const
{
	SValue ret;
	ret.m_items = m_items;
	for (auto it : o.m_items)
	{
		ret -= it;
	}
	return ret;
}
SValue operator+(const SValue&amp; o)const
{
	SValue ret;
	ret.m_items = m_items;
	for (auto it : o.m_items)
	{
		ret += it;
	}
	return ret;
}
SValue operator*(const SValue&amp; o)const
{
	SValue ret;
	for (const auto it : m_items)
	{
		for (const auto ij : o.m_items)
		{
			ret += it * ij;
		}
	}
	return ret;
}
SValue&amp; operator+=(const SValueItem&amp; item)
{
	auto it = m_items.find(item);
	if (m_items.end() == it)
	{
		m_items.emplace(item);
	}
	else
	{
		auto tmp = *it;
		tmp.m_iCoefficient += item.m_iCoefficient;
		m_items.erase(it);
		m_items.emplace(tmp);
	}
	return *this;
}
SValue&amp; operator-=(const SValueItem&amp; item)
{
	auto it = m_items.find(item);
	if (m_items.end() == it)
	{
		auto tmp = item;
		tmp.m_iCoefficient *= -1;
		m_items.emplace(tmp);
	}
	else
	{
		auto tmp = *it;
		tmp.m_iCoefficient -= item.m_iCoefficient;
		m_items.erase(it);
		m_items.emplace(tmp);
	}
	return *this;
}
vector&lt;std::string&gt; ToStrings()const
{
	vector&lt;std::string&gt; vRet;
	for (const auto&amp; item : m_items)
	{
		if (0 == item.m_iCoefficient)
		{
			continue;
		}
		vRet.emplace_back(item.ToString());
	}
	return vRet;
}
std::set&lt;SValueItem&gt; m_items;
</code></pre> 
<p>};</p> 
<p>class CDelIndexs<br> {<!-- --><br> public:<br> CDelIndexs()<br> {<!-- --></p> 
<pre><code>}
CDelIndexs(int iSize)
{
	Init(iSize);
}
void Init(int iSize)
{
	m_bDels.assign(iSize, false);
	m_vNext.resize(iSize);
	for (int i = 0; i &lt; iSize; i++)
	{
		m_vNext[i] = i + 1;
	}
}
void Del(int index)
{
	if ((index &lt; 0) || (index &gt;= m_vNext.size()))
	{
		return;
	}
	if (m_bDels[index])
	{
		return;
	}
	m_bDels[index] = true;

}
void SetCur(int index)
{
	if (index &lt; 0)
	{
		m_iCur = m_vNext.size();
	}
	else
	{
		m_iCur = FreshCur(index);
	}
}
int NextIndex()
{
	if (m_iCur &gt;= m_vNext.size())
	{
		return -1;
	}
	auto ret = m_iCur;
	SetCur(m_vNext[m_iCur]);
	return ret;
}
</code></pre> 
<p>private:<br> int FreshCur(int index)<br> {<!-- --><br> if (index &gt;= m_vNext.size())<br> {<!-- --><br> return m_vNext.size();<br> }<br> if (!m_bDels[index])<br> {<!-- --><br> return index;<br> }</p> 
<pre><code>	return m_vNext[index] = FreshCur(m_vNext[index]);
}
int m_iCur = 0;
vector&lt;bool&gt; m_bDels;
vector&lt;int&gt; m_vNext;
</code></pre> 
<p>};</p> 
<p>class CUnionFind<br> {<!-- --><br> public:<br> CUnionFind(int iSize) :m_vNodeToRegion(iSize)<br> {<!-- --><br> for (int i = 0; i &lt; iSize; i++)<br> {<!-- --><br> m_vNodeToRegion[i] = i;<br> }<br> m_iConnetRegionCount = iSize;<br> }<br> int GetConnectRegionIndex(int iNode)<br> {<!-- --><br> int&amp; iConnectNO = m_vNodeToRegion[iNode];<br> if (iNode == iConnectNO)<br> {<!-- --><br> return iNode;<br> }<br> return iConnectNO = GetConnectRegionIndex(iConnectNO);<br> }<br> void Union(int iNode1, int iNode2)<br> {<!-- --><br> const int iConnectNO1 = GetConnectRegionIndex(iNode1);<br> const int iConnectNO2 = GetConnectRegionIndex(iNode2);<br> if (iConnectNO1 == iConnectNO2)<br> {<!-- --><br> return;<br> }<br> m_iConnetRegionCount–;<br> if (iConnectNO1 &gt; iConnectNO2)<br> {<!-- --><br> UnionConnect(iConnectNO1, iConnectNO2);<br> }<br> else<br> {<!-- --><br> UnionConnect(iConnectNO2, iConnectNO1);<br> }<br> }</p> 
<pre><code>bool IsConnect(int iNode1, int iNode2)
{
	return GetConnectRegionIndex(iNode1) == GetConnectRegionIndex(iNode2);
}
int GetConnetRegionCount()const
{
	return m_iConnetRegionCount;
}
vector&lt;int&gt; GetNodeCountOfRegion()//各联通区域的节点数量
{
	const int iNodeSize = m_vNodeToRegion.size();
	vector&lt;int&gt; vRet(iNodeSize);
	for (int i = 0; i &lt; iNodeSize; i++)
	{
		vRet[GetConnectRegionIndex(i)]++;
	}
	return vRet;
}
</code></pre> 
<p>private:<br> void UnionConnect(int iFrom, int iTo)<br> {<!-- --><br> m_vNodeToRegion[iFrom] = iTo;<br> }<br> vector m_vNodeToRegion;//各点所在联通区域的索引,本联通区域任意一点的索引，为了增加可理解性，用最小索引<br> int m_iConnetRegionCount;<br> };</p> 
<p>class CUnionFindMST<br> {<!-- --><br> public:<br> CUnionFindMST(const int iNodeSize) :m_uf(iNodeSize)<br> {<!-- --></p> 
<pre><code>}
void AddEdge(const int iNode1, const int iNode2, int iWeight)
{
	if (m_uf.IsConnect(iNode1, iNode2))
	{
		return;
	}
	m_iMST += iWeight;
	m_uf.Union(iNode1, iNode2);
}
void AddEdge(const vector&lt;int&gt;&amp; v)
{
	AddEdge(v[0], v[1], v[2]);
}
int MST()
{
	if (m_uf.GetConnetRegionCount() &gt; 1)
	{
		return -1;
	}
	return m_iMST;
}
</code></pre> 
<p>private:<br> int m_iMST = 0;<br> CUnionFind m_uf;<br> };</p> 
<p>class CNearestMST<br> {<!-- --><br> public:<br> CNearestMST(const int iNodeSize) :m_bDo(iNodeSize), m_vDis(iNodeSize, INT_MAX), m_vNeiTable(iNodeSize)<br> {<!-- --></p> 
<pre><code>}
void Init(const vector&lt;vector&lt;int&gt;&gt;&amp; edges)
{
	for (const auto&amp; v : edges)
	{
		Add(v);
	}
}
void Add(const vector&lt;int&gt;&amp; v)
{
	m_vNeiTable[v[0]].emplace_back(v[1], v[2]);
	m_vNeiTable[v[1]].emplace_back(v[0], v[2]);
}
int MST(int start)
{
	int next = start;
	while ((next = AddNode(next)) &gt;= 0);
	return m_iMST;
}
int MST(int iNode1, int iNode2, int iWeight)
{
	m_bDo[iNode1] = true;
	for (const auto&amp; it : m_vNeiTable[iNode1])
	{
		if (m_bDo[it.first])
		{
			continue;
		}
		m_vDis[it.first] = min(m_vDis[it.first], (long long)it.second);
	}
	m_iMST = iWeight;

	int next = iNode2;
	while ((next = AddNode(next)) &gt;= 0);
	return m_iMST;
}
</code></pre> 
<p>private:<br> int AddNode(int iCur)<br> {<!-- --><br> m_bDo[iCur] = true;<br> for (const auto&amp; it : m_vNeiTable[iCur])<br> {<!-- --><br> if (m_bDo[it.first])<br> {<!-- --><br> continue;<br> }<br> m_vDis[it.first] = min(m_vDis[it.first], (long long)it.second);<br> }</p> 
<pre><code>	int iMinIndex = -1;
	for (int i = 0; i &lt; m_vDis.size(); i++)
	{
		if (m_bDo[i])
		{
			continue;
		}
		if ((-1 == iMinIndex) || (m_vDis[i] &lt; m_vDis[iMinIndex]))
		{
			iMinIndex = i;
		}
	}
	if (-1 != iMinIndex)
	{
		if (INT_MAX == m_vDis[iMinIndex])
		{
			m_iMST = -1;
			return -1;
		}
		m_iMST += m_vDis[iMinIndex];
	}

	return iMinIndex;
}
vector&lt;bool&gt; m_bDo;
vector&lt;long long&gt; m_vDis;
vector &lt; vector&lt;std::pair&lt;int, int&gt;&gt;&gt; m_vNeiTable;
long long m_iMST = 0;
</code></pre> 
<p>};</p> 
<p>typedef pair&lt;long long, int&gt; PAIRLLI;<br> class CDis<br> {<!-- --><br> public:<br> static void Dis(vector&amp; vDis, int start, const vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; vNeiB)<br> {<!-- --><br> std::priority_queue&lt;PAIRLLI, vector, greater&gt; minHeap;<br> minHeap.emplace(0, start);<br> while (minHeap.size())<br> {<!-- --><br> const long long llDist = minHeap.top().first;<br> const int iCur = minHeap.top().second;<br> minHeap.pop();<br> if (-1 != vDis[iCur])<br> {<!-- --><br> continue;<br> }<br> vDis[iCur] = llDist;<br> for (const auto&amp; it : vNeiB[iCur])<br> {<!-- --><br> minHeap.emplace(llDist + it.second, it.first);<br> }<br> }</p> 
<pre><code>}
</code></pre> 
<p>};</p> 
<p>class CNearestDis<br> {<!-- --><br> public:<br> CNearestDis(int iSize) :m_iSize(iSize), DIS(m_vDis), PRE(m_vPre)<br> {<!-- --></p> 
<pre><code>}
void Cal(int start, const vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; vNeiB)
{
	m_vDis.assign(m_iSize, -1);
	m_vPre.assign(m_iSize, -1);
	vector&lt;bool&gt; vDo(m_iSize);//点是否已处理
	auto AddNode = [&amp;](int iNode)
	{
		//const int iPreNode = m_vPre[iNode];
		long long llPreDis = m_vDis[iNode];

		vDo[iNode] = true;
		for (const auto&amp; it : vNeiB[iNode])
		{
			if (vDo[it.first])
			{
				continue;
			}

			if ((-1 == m_vDis[it.first]) || (it.second + llPreDis &lt; m_vDis[it.first]))
			{
				m_vDis[it.first] = it.second + llPreDis;
				m_vPre[it.first] = iNode;
			}
		}

		long long llMinDis = LLONG_MAX;
		int iMinIndex = -1;
		for (int i = 0; i &lt; m_vDis.size(); i++)
		{
			if (vDo[i])
			{
				continue;
			}
			if (-1 == m_vDis[i])
			{
				continue;
			}
			if (m_vDis[i] &lt; llMinDis)
			{
				iMinIndex = i;
				llMinDis = m_vDis[i];
			}
		}
		return (LLONG_MAX == llMinDis) ? -1 : iMinIndex;
	};

	int next = start;
	m_vDis[start] = 0;
	while (-1 != (next = AddNode(next)));
}
void Cal(const int start, vector&lt;vector&lt;int&gt;&gt;&amp; edges)
{
	vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; vNeiB(m_iSize);
	for (int i = 0; i &lt; edges.size(); i++)
	{
		const auto&amp; v = edges[i];
		vNeiB[v[0]].emplace_back(v[1], v[2]);
		vNeiB[v[1]].emplace_back(v[0], v[2]);
	}
	Cal(start, vNeiB);
}
const vector&lt;long long&gt;&amp; DIS;
const vector&lt;int&gt;&amp; PRE;
</code></pre> 
<p>private:<br> const int m_iSize;<br> vector m_vDis;//各点到起点的最短距离<br> vector m_vPre;//最短路径的前一点<br> };</p> 
<p>class CNeiBo2<br> {<!-- --><br> public:<br> CNeiBo2(int n, vector&lt;vector&gt;&amp; edges, bool bDirect)<br> {<!-- --><br> m_vNeiB.resize(n);<br> for (const auto&amp; v : edges)<br> {<!-- --><br> m_vNeiB[v[0]].emplace_back(v[1]);<br> if (!bDirect)<br> {<!-- --><br> m_vNeiB[v[1]].emplace_back(v[0]);<br> }<br> }<br> }<br> vector&lt;vector&gt; m_vNeiB;<br> };</p> 
<p>struct SDecimal<br> {<!-- --><br> SDecimal(int iNum = 0, int iDeno = 1)<br> {<!-- --><br> m_iNum = iNum;<br> m_iDeno = iDeno;<br> int iGCD = GCD(abs(m_iNum), abs(m_iDeno));<br> m_iNum /= iGCD;<br> m_iDeno /= iGCD;<br> if (m_iDeno &lt; 0)<br> {<!-- --><br> m_iDeno = -m_iDeno;<br> m_iNum = -m_iNum;<br> }<br> }<br> SDecimal operator*(const SDecimal&amp; o)const<br> {<!-- --><br> return SDecimal(m_iNum * o.m_iNum, m_iDeno * o.m_iDeno);<br> }<br> SDecimal operator/(const SDecimal&amp; o)const<br> {<!-- --><br> return SDecimal(m_iNum * o.m_iDeno, m_iDeno * o.m_iNum);<br> }<br> SDecimal operator+(const SDecimal&amp; o)const<br> {<!-- --><br> const int iGCD = GCD(m_iDeno, o.m_iDeno);<br> const int iDeno = m_iDeno * o.m_iDeno / iGCD;<br> return SDecimal(m_iNum * (iDeno / m_iDeno) + o.m_iNum * (iDeno / o.m_iDeno), iDeno);<br> }<br> SDecimal operator-(const SDecimal&amp; o)const<br> {<!-- --><br> const int iGCD = GCD(m_iDeno, o.m_iDeno);<br> const int iDeno = m_iDeno * o.m_iDeno / iGCD;<br> return SDecimal(m_iNum * (iDeno / m_iDeno) - o.m_iNum * (iDeno / o.m_iDeno), iDeno);<br> }<br> bool operator==(const SDecimal&amp; o)const<br> {<!-- --><br> return (m_iNum == o.m_iNum) &amp;&amp; (m_iDeno == o.m_iDeno);<br> }<br> bool operator&lt;(const SDecimal&amp; o)const<br> {<!-- --><br> auto tmp = *this - o;<br> return tmp.m_iNum &lt; 0;<br> }<br> int m_iNum = 0;//分子<br> int m_iDeno = 1;//分母<br> };</p> 
<p>struct point {<!-- --><br> double x, y;<br> point(double i, double j) :x(i), y(j) {}<br> };</p> 
<p>//算两点距离<br> double dist(double x1, double y1, double x2, double y2) {<!-- --><br> return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));<br> }</p> 
<p>//计算圆心<br> point CircleCenter(point&amp; a, point&amp; b, int r) {<!-- --><br> //算中点<br> point mid((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);<br> //AB距离的一半<br> double d = dist(a.x, a.y, mid.x, mid.y);<br> //计算h<br> double h = sqrt(r * r - d * d);<br> //计算垂线<br> point ba(b.x - a.x, b.y - a.y);<br> point hd(-ba.y, ba.x);<br> double len = sqrt(hd.x * hd.x + hd.y * hd.y);<br> hd.x /= len, hd.y /= len;<br> hd.x *= h, hd.y *= h;<br> return point(hd.x + mid.x, hd.y + mid.y);<br> }</p> 
<p>class C01LineTree<br> {<!-- --><br> public:<br> C01LineTree(const vector&amp; nums) :m_iEleSize(nums.size())<br> {<!-- --><br> m_arr.resize(m_iEleSize * 4);<br> Init(nums, 1, 1, m_iEleSize);<br> m_vNeedFreshChilds.assign(m_iEleSize * 4, false);<br> }<br> void Rotato(int iLeftZeroIndex, int iRightZeroIndex)<br> {<!-- --><br> int iRotatoLeft = iLeftZeroIndex + 1;<br> int iRotatoRight = iRightZeroIndex + 1;<br> Rotato(1, 1, m_iEleSize, iRotatoLeft, iRotatoRight);<br> }<br> int Query()<br> {<!-- --><br> return m_arr[1];<br> }<br> private:<br> void Rotato(int iSaveIndex, int iDataBegin, int iDataEnd, int iRotatoLeft, int iRotatoRight)<br> {<!-- --><br> if ((iRotatoLeft &lt;= iDataBegin) &amp;&amp; (iRotatoRight &gt;= iDataEnd))<br> {//整个范围需要更新<br> RotatoSelf(iSaveIndex, iDataBegin, iDataEnd);<br> return;<br> }<br> int iMid = iDataBegin + (iDataEnd - iDataBegin) / 2;<br> if (m_vNeedFreshChilds[iSaveIndex])<br> {<!-- --><br> RotatoSelf(iSaveIndex * 2, iDataBegin, iMid);<br> RotatoSelf(iSaveIndex * 2 + 1, iMid + 1, iDataEnd);<br> m_vNeedFreshChilds[iSaveIndex] = false;<br> }<br> if (iMid &gt;= iRotatoLeft)<br> {<!-- --><br> Rotato(iSaveIndex * 2, iDataBegin, iMid, iRotatoLeft, iRotatoRight);<br> }<br> if (iMid + 1 &lt;= iRotatoRight)<br> {<!-- --><br> Rotato(iSaveIndex * 2 + 1, iMid + 1, iDataEnd, iRotatoLeft, iRotatoRight);<br> }<br> m_arr[iSaveIndex] = m_arr[iSaveIndex * 2] + m_arr[iSaveIndex * 2 + 1];<br> }<br> void RotatoSelf(int iSaveIndex, int iDataBegin, int iDataEnd)<br> {<!-- --><br> //总数量 - 翻转后0(翻转前1）的数量<br> m_arr[iSaveIndex] = (iDataEnd - iDataBegin + 1) - m_arr[iSaveIndex];<br> //懒惰法，标记本节点的子孙节点没更新<br> m_vNeedFreshChilds[iSaveIndex] = !m_vNeedFreshChilds[iSaveIndex];<br> }<br> void Init(const vector&amp; nums, int iSaveIndex, int iDataBegin, int iDataEnd)<br> {<!-- --><br> if (iDataBegin == iDataEnd)<br> {<!-- --><br> m_arr[iSaveIndex] = nums[iDataBegin - 1];<br> return;<br> }<br> int iMid = iDataBegin + (iDataEnd - iDataBegin) / 2;<br> Init(nums, iSaveIndex * 2, iDataBegin, iMid);<br> Init(nums, iSaveIndex * 2 + 1, iMid + 1, iDataEnd);<br> m_arr[iSaveIndex] = m_arr[iSaveIndex * 2] + m_arr[iSaveIndex * 2 + 1];<br> }<br> const int m_iEleSize;<br> vector m_arr;<br> vector m_vNeedFreshChilds;<br> };</p> 
<p>/*<br> struct TreeNode {<!-- --><br> int val;<br> TreeNode *left;<br> TreeNode *right;<br> TreeNode(int x) : val(x), left(NULL), right(NULL) {}<br> TreeNode(int x, int iLeft) : val(x), left(new TreeNode(iLeft)), right(nullptr) {}<br> TreeNode(int x, int iLeft, int iRghit) : val(x), left(new TreeNode(iLeft)), right(new TreeNode(iRghit)) {}<br> };</p> 
<p>namespace NTree<br> {<!-- --><br> TreeNode* Init(const vector&amp; nums, int iNull = 10000)<br> {<!-- --><br> if (0 == nums.size())<br> {<!-- --><br> return nullptr;<br> }<br> vector&lt;TreeNode*&gt; ptrs(nums.size() + 1), ptrParent(1);<br> for (int i = 0; i &lt; nums.size(); i++)<br> {<!-- --><br> if (iNull == nums[i])<br> {<!-- --><br> continue;<br> }<br> const int iNO = i + 1;<br> ptrs[iNO] = new TreeNode(nums[i]);<br> ptrParent.emplace_back(ptrs[iNO]);<br> if (1 == iNO)<br> {<!-- --><br> continue;<br> }<br> if (iNO &amp; 1)<br> {//奇数是右支<br> ptrParent[iNO / 2]-&gt;right = ptrs[iNO];<br> }<br> else<br> {<!-- --><br> ptrParent[iNO / 2]-&gt;left = ptrs[iNO];<br> }<br> }<br> return ptrs[1];<br> }<br> }<br> */</p> 
<p>class Solution {<!-- --><br> public:<br> int minNumberOfSemesters(int n, vector&lt;vector&gt;&amp; relations, int k) {<!-- --><br> m_iMaskNum = 1 &lt;&lt; n;<br> vector dp(m_iMaskNum,1000*1000),vPre(m_iMaskNum);<br> for (const auto&amp; v : relations)<br> {<!-- --><br> vPre[1 &lt;&lt; (v[1] - 1)] |= (1 &lt;&lt; (v[0] - 1));<br> }<br> dp[0] = 0;<br> for (int i = 0; i &lt; m_iMaskNum; i++)<br> {<!-- --><br> vPre[i] = vPre[i &amp; (-i)] | vPre[i &amp; (i - 1)];<br> if ((i | vPre[i]) != i)<br> {<!-- --><br> continue;//非发课程：前置课程没学<br> }<br> unsigned int uCanStudy = vPre[i] ^ i;<br> if (bitcount(uCanStudy) &lt;= k)<br> {<!-- --><br> dp[i ] = min(dp[i ], dp[i- uCanStudy] + 1);<br> continue;<br> }<br> for (unsigned int uStudy = uCanStudy; uStudy; uStudy = uCanStudy &amp; (uStudy - 1))<br> {<!-- --><br> if (bitcount(uStudy) &lt;= k)<br> {<!-- --><br> dp[i] = min(dp[i ], dp[i - uStudy] + 1);<br> }<br> }<br> }<br> return dp.back();<br> }<br> int m_iMaskNum;<br> };<br> .</p> 
<p><img src="https://images2.imgbox.com/90/fa/6RtTOCL5_o.gif" alt=""></p> 
<h2><a id="_2483"></a>扩展阅读</h2> 
<h4><a id="_2485"></a>视频课程</h4> 
<p>有效学习：明确的目标 及时的反馈 拉伸区（难度合适），可以先学简单的课程，请移步CSDN学院，听白银讲师（也就是鄙人）的讲解。<br> <a href="https://edu.csdn.net/course/detail/38771">https://edu.csdn.net/course/detail/38771</a></p> 
<p>如何你想快</p> 
<p>速形成战斗了，为老板分忧，请学习C#入职培训、C++入职培训等课程<br> <a href="https://edu.csdn.net/lecturer/6176">https://edu.csdn.net/lecturer/6176</a></p> 
<h4><a id="_2495"></a>相关下载</h4> 
<p>想高屋建瓴的学习算法，请下载《喜缺全书算法册》doc版<br> <a href="https://download.csdn.net/download/he_zhidan/88348653">https://download.csdn.net/download/he_zhidan/88348653</a></p> 
<table><thead><tr><th>我想对大家说的话</th></tr></thead><tbody><tr><td>闻缺陷则喜是一个美好的愿望，早发现问题，早修改问题，给老板节约钱。</td></tr><tr><td>子墨子言之：事无终始，无务多业。也就是我们常说的专业的人做专业的事。</td></tr><tr><td>如果程序是一条龙，那算法就是他的是睛</td></tr></tbody></table> 
<h4><a id="_2505"></a>测试环境</h4> 
<p>操作系统：win7 开发环境： VS2019 <strong>C++17</strong><br> 或者 操作系统：win10 开发环境： VS2022 <strong>C++17</strong><br> 如无特殊说明，本<strong>算法</strong>用**C++**实现。</p> 
<p><img src="https://images2.imgbox.com/43/24/loSJbOln_o.gif" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8138ec0ed1f2d750b5e65b870de9dca9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio:Gradle Sync issues解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ddfdd560bebc52e6cec5c8fd17c333a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Stable Diffusion原理详解（附代码实现）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>