<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RSA加密，公钥、私钥的生成，前端使用公钥加密，JSEncrypt返回值为false的原因以及解决方法，XML转换Pkcs1、8 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0f5e91e8e2b4d38977a17e38a47607b2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RSA加密，公钥、私钥的生成，前端使用公钥加密，JSEncrypt返回值为false的原因以及解决方法，XML转换Pkcs1、8">
  <meta property="og:description" content="RSA加密 非对称加密算法，两个且不同的Key，一个公开，一个私密，公开加密，私密解密。
特点：
原文短，加密后密文长
生成相对较慢
安全性超强
生成公钥、私钥 我们使用.net进行生成公钥、私钥。
使用RSA.ToXmlString(Boolean) 方法生成公钥以及私钥，方法中接收一个参数，true 表示同时包含 RSA 公钥和私钥；false 表示仅包含公钥，需要注意的是这里生成的是XML格式。
RSACryptoServiceProvider rSA = new(); string pubKey = rSA.ToXmlString(false);//公钥 string priKey = rSA.ToXmlString(true);//私钥 后端使用 在后端加密解密需要引入RSACryptoServiceProvider 类，该类提供了对RSA算法的实现执行非对称加密和解密，同时，该类是不可被继承的。
RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); RSA加密 加密调用Encrypt(Byte[], Boolean)方法，第一个参数为需要加密的数据，是一个byte[]格式，返回同样为一个byte[]格式。
byte[] cipherbytes; rsa.FromXmlString(pubKey); cipherbytes = rsa.Encrypt(Encoding.UTF8.GetBytes(source), false); var b = Convert.ToBase64String(cipherbytes); RSA解密 解密调用Decrypt(Byte[], Boolean)方法，第一个参数为要解密的数据，是一个byte[]格式，返回同样为一个byte[]格式。
rsa.FromXmlString(priKey); byte[] cipherbytex; cipherbytex = rsa.Decrypt(Convert.FromBase64String(b), false); var c = Encoding.UTF8.GetString(cipherbytex); 前端vue使用后端传递的公钥加密 我这里使用的加密库为JSEncrypt库，安装JSEncrypt库。
npm install jsencrypt -D
在页面中对其引用。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-13T20:49:53+08:00">
    <meta property="article:modified_time" content="2023-10-13T20:49:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RSA加密，公钥、私钥的生成，前端使用公钥加密，JSEncrypt返回值为false的原因以及解决方法，XML转换Pkcs1、8</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>RSA加密</h2> 
<p>非对称加密算法，两个且不同的Key，一个公开，一个私密，公开加密，私密解密。</p> 
<blockquote> 
 <p><strong>特点：</strong></p> 
 <p><strong>原文短，加密后密文长</strong></p> 
 <p><strong>生成相对较慢</strong></p> 
 <p><strong>安全性超强</strong></p> 
</blockquote> 
<h3>生成公钥、私钥</h3> 
<p>我们使用.net进行生成公钥、私钥。</p> 
<p>使用RSA.ToXmlString(Boolean) 方法生成公钥以及私钥，方法中接收一个参数，<code>true</code> 表示同时包含 RSA 公钥和私钥；<code>false</code> 表示仅包含公钥，需要注意的是这里生成的是XML格式。</p> 
<pre><code class="language-cs">RSACryptoServiceProvider rSA = new();
string pubKey = rSA.ToXmlString(false);//公钥
string priKey = rSA.ToXmlString(true);//私钥</code></pre> 
<h3 style="background-color:transparent;">后端使用 </h3> 
<p>在后端加密解密需要引入RSACryptoServiceProvider 类，该类提供了对RSA算法的实现执行非对称加密和解密，同时，该类是不可被继承的。</p> 
<pre><code class="language-cs">RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();</code></pre> 
<h4>RSA加密</h4> 
<p>加密调用Encrypt(Byte[], Boolean)方法，第一个参数为需要加密的数据，是一个byte[]格式，返回同样为一个byte[]格式。</p> 
<pre><code class="language-cs">byte[] cipherbytes;
rsa.FromXmlString(pubKey);
cipherbytes = rsa.Encrypt(Encoding.UTF8.GetBytes(source), false);
var b = Convert.ToBase64String(cipherbytes);</code></pre> 
<h4>RSA解密</h4> 
<p>解密调用Decrypt(Byte[], Boolean)方法，第一个参数为要解密的数据，是一个byte[]格式，返回同样为一个byte[]格式。</p> 
<pre><code class="language-cs">rsa.FromXmlString(priKey);
byte[] cipherbytex;
cipherbytex = rsa.Decrypt(Convert.FromBase64String(b), false);
var c = Encoding.UTF8.GetString(cipherbytex);</code></pre> 
<h3>前端vue使用后端传递的公钥加密</h3> 
<p>我这里使用的加密库为JSEncrypt库，安装JSEncrypt库。</p> 
<blockquote> 
 <p>npm install jsencrypt -D</p> 
</blockquote> 
<p> 在页面中对其引用。</p> 
<pre><code class="language-javascript">import {JSEncrypt} from 'jsencrypt'</code></pre> 
<p><span style="color:#fe2c24;">需要注意 ：.net生成的公钥与私钥是XML格式，而前端JSEncrypt库使用时需要Pkcs8格式，我们这里需要在后端处理一下公钥再传递给前端，不然前端返回密文的时候为falae。</span></p> 
<h4><span style="color:#0d0016;">后端将XML格式转换为Pkcs8格式</span></h4> 
<p>我们需要在程序包管理控制台中安装XC.RSAUtil包</p> 
<blockquote> 
 <p>NuGet\Install-Package XC.RSAUtil -Version 1.3.6</p> 
</blockquote> 
<p>这个包包含了几种转换的格式：</p> 
<p>XML转<span style="color:#0d0016;">Pkcs1</span></p> 
<blockquote> 
 <p>RsaKeyConvert.PrivateKeyXmlToPkcs1（）私钥</p> 
 <p>RsaKeyConvert.PublicKeyXmlToPem（）公钥</p> 
</blockquote> 
<p>XML转<span style="color:#0d0016;">Pkcs8</span></p> 
<blockquote> 
 <p>RsaKeyConvert.PrivateKeyXmlToPkcs8（）私钥</p> 
 <p>RsaKeyConvert.PublicKeyXmlToPem（）公钥</p> 
</blockquote> 
<p><span style="color:#0d0016;">Pkcs1转XML</span> </p> 
<blockquote> 
 <p>RsaKeyConvert.PrivateKeyPkcs1ToXml（）私钥</p> 
 <p>RsaKeyConvert.PublicKeyPemToXml（）公钥</p> 
</blockquote> 
<p><span style="color:#0d0016;">Pkcs8转XML</span> </p> 
<blockquote> 
 <p>RsaKeyConvert.PrivateKeyPkcs8ToXml（）私钥</p> 
 <p>RsaKeyConvert.PublicKeyPemToXml（）公钥</p> 
</blockquote> 
<p>我这里使用RsaKeyConvert.PublicKeyXmlToPem（） ，再将转换的值传递给前端，前端就能使用JSEncrypt进行RSA加密了。</p> 
<pre><code class="language-cs">string pubKey = rSA.ToXmlString(false);//公钥
string priKey = rSA.ToXmlString(true);//私钥
var keyList = RsaKeyConvert.PublicKeyXmlToPem(pubKey);//将xml格式转换为Pkcs8
return new { keyList };</code></pre> 
<h4> 前端加密</h4> 
<p>虽然我们前端是可以解密的，但是处于安全考虑，我们只用将公钥传递给前端就可以了，私钥是不传递的，私钥是用于解码使用公钥加密的密文。</p> 
<p>我们使用JSEncrypt库主要使用其中的几个方法：</p> 
<blockquote> 
 <p>setPublicKey（'获取的公钥'）设置公钥</p> 
 <p>setPrivateKey（'获取的私钥'）设置私钥</p> 
 <p>encrypt（'加密内容'）加密</p> 
 <p>decrypt（'解密内容'）解密</p> 
</blockquote> 
<p> 这里我们使用公钥对对456进行加密。</p> 
<pre><code class="language-javascript">postFdd().then(res =&gt; {
	console.log(res)
	var encryptor = new JSEncrypt()
	encryptor.setPublicKey(res.keyList)
	var rsaPassWord = encryptor.encrypt('456')
	// encryptor.setPrivateKey(res.priKey) //设置秘钥
	// var uncrypted = decrypt.decrypt(encryptor) //解密之前拿公钥加密的内容
	console.log(rsaPassWord)
})</code></pre> 
<p>我们打印出来可以看到 keyList是为<span style="color:#0d0016;">Pkcs8格式，priKey是为XML格式，而下面那一段字段就是我们加密出来的密文。</span></p> 
<p><img alt="" height="82" src="https://images2.imgbox.com/82/d7/TT4DaCVM_o.png" width="647"></p> 
<h4>XML的格式以及<span style="color:#0d0016;">Pkcs8格式</span></h4> 
<p><span style="color:#0d0016;">XML开头为</span>&lt;RSAKeyValue&gt;&lt;Modulus&gt;</p> 
<p><span style="color:#0d0016;">Pkcs8格式开头为-----BEGIN PUBLIC KEY-----</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f6d787a69353a26e494ed4c515310ec1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">八大排序算法(含时间复杂度、空间复杂度、算法稳定性)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e29aa2a1b4c75f70d7bce4eda2b9ae6c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决报错 java.sql.SQLNonTransientConnectionException: Could not create connection to database server</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>