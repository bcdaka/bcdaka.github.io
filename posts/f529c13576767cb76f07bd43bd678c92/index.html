<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java sort用法详解（二维数组排序，List＜＞排序,lambada表达式，自定义类型排序） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f529c13576767cb76f07bd43bd678c92/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java sort用法详解（二维数组排序，List＜＞排序,lambada表达式，自定义类型排序）">
  <meta property="og:description" content="目录
前言：
一维数组降序：
方法1.Comparator接口：
代码实现：
方法2.Collections.reverseOrder()：
代码实现： 二维数组排序：
代码如下：
List&lt;&gt;排序：
代码如下：
自定义类型比较排序：
按照年龄逆序排序：
按照姓名升序排序：
lambada表达式简写：
一维数组逆序代码：
二维数组排序代码：
List&lt;&gt;排序代码：
自定义类型排序：
结语：
前言： 由于最近刷一些比赛真题时，发现有一些题要先排序一下后面才能用贪心之类的算法解决，在比赛上面自己实现一个排序算法有点浪费时间（当然不是指冒泡插入之类的简单排序，太慢了😭），考虑到java中Arrays类中有sort方法我们可以引用sort来排序，升序简单那降序呢，一维数组会排序那二维数组和List&lt;&gt;呢? 本文章就是为了解决这些问题，希望对友友有所帮助。💕💕💕
我相信来看这个的一般都是有急用吧😭😭😭（作者曾经也是），如果很急的话直接看代码实现，直接模仿着写即可，其他的都是一些知识点的讲解。
要想使用sort排序，排序的对象必须实现comparable接口才行，由于Comparable不太灵活故本文章不做详细介绍。
一位数组的基本类型sort方法都能排序（升序）。
可以说的是一维数组降序和二维数组排序都是通过如下sort的重载方法即传入一个比较器（参数是泛型的不能是基本类型）。
一维数组降序： 声明:为了方便叙述下面采用int和Integer进行叙述其他类似。
经过多次尝试和查阅许多资料得出：要想把一维数组逆序如果是基本类型的话要把它变成包装类，
基本类型实现不了。
方法1.Comparator接口： 实现Comparator接口可以说是最常用的一种自定义排序操作了，它比Comparable更加灵活，想要根据什么比较直接自己实现就行，下面我们就开始对它的介绍💕：
Comparator是一个接口，既然接口那么我们实现它必须要重写它的抽象方法compare，必须要重写这一个（这个接口只有这一个方法）。
如果不实现就是出现如下错误。 实现比较器Comparator接口，上面&lt; T &gt;代表这是一个泛型（如果对泛型还不是很了解的话也没关系我们可以先会用就行），注意：泛型只能接受类，所有的基本数据类型必须使用包装类！，这就代表了我们要实现一维数组的逆序必须要把基本类型换成其包装类才行。否则会报如下错误。
代码实现： import java.util.Arrays; import java.util.Comparator; class cmp implements Comparator&lt;Integer&gt;{ @Override public int compare(Integer o1,Integer o2){ return o2 - o1; } } public class Test1 { public static void main(String[] args) { Integer[] nums = {1,2,3,4,5}; Arrays.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T12:50:40+08:00">
    <meta property="article:modified_time" content="2024-05-27T12:50:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java sort用法详解（二维数组排序，List＜＞排序,lambada表达式，自定义类型排序）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BC%95%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%BC%95%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E9%99%8D%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E9%99%8D%E5%BA%8F%EF%BC%9A" rel="nofollow">一维数组降序：</a></p> 
<p id="%E6%96%B9%E6%B3%951.Comparator%E6%8E%A5%E5%8F%A3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%951.Comparator%E6%8E%A5%E5%8F%A3%EF%BC%9A" rel="nofollow">方法1.Comparator接口：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">代码实现：</a></p> 
<p id="%E6%96%B9%E6%B3%952.Collections.reverseOrder()-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%952.Collections.reverseOrder%28%29" rel="nofollow">方法2.Collections.reverseOrder()：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%C2%A0" rel="nofollow">代码实现： </a></p> 
<p id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">二维数组排序：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow">代码如下：</a></p> 
<p id="List%3C%3E%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#List%3C%3E%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">List&lt;&gt;排序：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow">代码如下：</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">自定义类型比较排序：</a></p> 
<p id="%E6%8C%89%E7%85%A7%E5%B9%B4%E9%BE%84%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%8C%89%E7%85%A7%E5%B9%B4%E9%BE%84%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">按照年龄逆序排序：</a></p> 
<p id="%E6%8C%89%E7%85%A7%E5%A7%93%E5%90%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%8C%89%E7%85%A7%E5%A7%93%E5%90%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">按照姓名升序排序：</a></p> 
<p id="lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%86%99%EF%BC%9A-toc" style="margin-left:0px;"><a href="#lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%86%99%EF%BC%9A" rel="nofollow">lambada表达式简写：</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E9%80%86%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E9%80%86%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">一维数组逆序代码：</a></p> 
<p id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">二维数组排序代码：</a></p> 
<p id="%C2%A0List%3C%3E%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0List%3C%3E%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">List&lt;&gt;排序代码：</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">自定义类型排序：</a></p> 
<p id="%E7%BB%93%E8%AF%AD%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD%EF%BC%9A" rel="nofollow">结语：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%BC%95%E8%A8%80%EF%BC%9A">前言：</h2> 
<p>由于最近刷一些比赛真题时，发现有一些题要先排序一下后面才能用贪心之类的算法解决，在比赛上面自己实现一个排序算法有点浪费时间（当然不是指冒泡插入之类的简单排序，太慢了😭），考虑到java中Arrays类中有sort方法我们可以引用sort来排序，升序简单那降序呢，一维数组会排序那二维数组和List&lt;&gt;呢? 本文章就是为了解决这些问题，希望对友友有所帮助。💕💕💕</p> 
<p><span style="color:#fe2c24;"><strong>我相信来看这个的一般都是有急用吧😭😭😭（作者曾经也是），如果很急的话直接看代码实现，直接模仿着写即可，其他的都是一些知识点的讲解。</strong></span></p> 
<p>要想使用sort排序，排序的对象必须实现comparable接口才行，由于Comparable不太灵活故本文章不做详细介绍。</p> 
<p>一位数组的基本类型sort方法都能排序（升序）。</p> 
<p><img alt="" height="684" src="https://images2.imgbox.com/5f/fc/uziEPoQ9_o.png" width="707"></p> 
<p><span style="color:#fe2c24;"><strong>可以说的是一维数组降序和二维数组排序都是通过如下sort的重载方法即传入一个比较器（参数是泛型的不能是基本类型）。</strong></span></p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/c0/21/5VgJidDy_o.png" width="1200"></p> 
<h2 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E9%99%8D%E5%BA%8F%EF%BC%9A">一维数组降序：</h2> 
<p><strong>声明:为了方便叙述下面采用int和Integer进行叙述其他类似。</strong></p> 
<p><strong>经过多次尝试和查阅许多资料得出：要想把一维数组逆序如果是基本类型的话要把它变成包装类，</strong></p> 
<p><strong>基本类型实现不了。</strong></p> 
<h3 id="%E6%96%B9%E6%B3%951.Comparator%E6%8E%A5%E5%8F%A3%EF%BC%9A">方法1.Comparator接口：</h3> 
<p>实现Comparator接口可以说是最常用的一种自定义排序操作了，它比Comparable更加灵活，想要根据什么比较直接自己实现就行，下面我们就开始对它的介绍💕：</p> 
<p>Comparator是一个接口，既然接口那么我们实现它必须要重写它的<span style="color:#fe2c24;"><strong>抽象方法compare</strong></span>，<span style="color:#fe2c24;"><strong>必须要重写这一个（这个接口只有这一个方法）</strong></span>。</p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/32/1e/yQtN0p5p_o.png" width="895"></p> 
<p>如果不实现就是出现如下错误。 </p> 
<p> <img alt="" height="442" src="https://images2.imgbox.com/09/92/SBaXwUjJ_o.png" width="1200"></p> 
<p>实现比较器Comparator接口，上面&lt; T &gt;代表这是一个泛型（如果对泛型还不是很了解的话也没关系我们可以先会用就行）<span style="color:#fe2c24;"><strong>，注意：泛型只能接受类，所有的基本数据类型必须使用包装类！，这就代表了我们要实现一维数组的逆序必须要把基本类型换成其包装类才行。否则会报如下错误。</strong></span></p> 
<p><img alt="" height="43" src="https://images2.imgbox.com/5f/db/km2ZKX5g_o.png" width="1120"></p> 
<h4 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">代码实现：</h4> 
<pre><code class="language-java">import java.util.Arrays;
import java.util.Comparator;
class cmp implements Comparator&lt;Integer&gt;{
    @Override
    public int compare(Integer o1,Integer o2){
        return o2 - o1;
    }
}
public class Test1 {
    public static void main(String[] args) {
        Integer[] nums = {1,2,3,4,5};
        Arrays.sort(nums,new cmp());
        for(int i = 0;i &lt; nums.length;i++){
            System.out.print(nums[i] + " ");
        }
    }
}</code></pre> 
<p>效果如下：</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/7a/1d/zuL7SOGl_o.png" width="1149"></p> 
<p>如果想要升序的话就o1 - o2.  </p> 
<h3 id="%E6%96%B9%E6%B3%952.Collections.reverseOrder()">方法2.Collections.reverseOrder()：</h3> 
<p> 这个我是从别人那里看到的，因为这个好像整洁一点故也把他写进来（还是推荐Comparator</p> 
<p>），源码如下，我们可以看到其实是传入一个比较器（Comparator）。注意要importCollections这个类。其源代码如下图。</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/df/3c/FBekdtYf_o.png" width="1064"></p> 
<h4 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%C2%A0">代码实现： </h4> 
<pre><code class="language-java">import java.util.Arrays;
import java.util.Collections;
public class Main{
    public static void main(String[] args) {
        Integer[] nums = {1,2,3,4,5};
        Arrays.sort(nums, Collections.reverseOrder());
        for(int i = 0;i &lt; nums.length;i++){
            System.out.print(nums[i] + " ");
        }
    }
}</code></pre> 
<p> 不过很可惜的是这样像int这样的基本类型还是不行🈚。</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/32/48/JxfEcXob_o.png" width="1200"></p> 
<h2 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%9A">二维数组排序：</h2> 
<p>二维数组这里只介绍Comparator方法，这个是最常用的并且作者只会这个😭，如果有大佬补充的话非常感谢🙇‍</p> 
<h3 id="%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">代码如下：</h3> 
<p><span style="color:#fe2c24;">是不是非常神奇，这其实说明int[]在内部可能是把它当作类来看的。</span></p> 
<pre><code class="language-java">import java.util.Arrays;
import java.util.Comparator;
class cmp implements Comparator&lt;int[]&gt; {
    @Override
    public int compare(int[] o1,int[] o2){
        return o1[0] - o2[0];
    }
}
public class Main {
    public static void main(String[] args) {
        int[][] nums = {<!-- -->{1,7},{2,6},{3,9},{8,2},{2,5}};
        Arrays.sort(nums,new cmp());
        for(int i = 0;i &lt; nums.length;i++){
            for(int j = 0;j &lt; nums[i].length;j++) {
                System.out.print(nums[i][j] + " ");
            }
            System.out.println();
        }
    }
}</code></pre> 
<p>结果如下我们是按照一行的第一个元素进行排序，显然这样做我们的结果是对的😎😎😎 </p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/5e/cf/RmddhgdG_o.png" width="1200"></p> 
<p>相信到这里友友们是不是发现新大陆了呢，按照每行的第几个数组来排序就改对应的o1和o2的下标即可如果想要逆序的话只需把o1 - o2 改为 o2 - o1即可。</p> 
<p><strong>多维类似，因为用的比较少故这里不再展开</strong>☆*: .｡. o(≧▽≦)o .｡.:*☆。</p> 
<h2 id="List%3C%3E%E6%8E%92%E5%BA%8F%EF%BC%9A">List&lt;&gt;排序：</h2> 
<p>在刷力扣的友友应该有这方面的需求，这类题目一般都是深搜DFS和回溯，要你返回这样的类型或者题目给你这样的类型。不先排个序的话会非常麻烦😫😫😫。这个List排序和上面的数组排序类似，这里写下是因为可能有的友友不知道List类中本来就有个sort方法可以用来排序List&lt;&gt;.</p> 
<p><strong><span style="color:#fe2c24;">下面图片来自List官方文档，要想排序List&lt;&gt;就要调用List类中的sort方法，万幸的是它也可以传入比较器这意味这通用性会更强。</span></strong></p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/ea/88/vXULEyDF_o.png" width="1200"></p> 
<p>要想实现List.sort()排序就要创建一个比较类cmp(名字随便)，cmp实现Comparator接口，在接口中传入List&lt;&gt;中的数据类型，注意不是传入List&lt;Integer&gt;可能有的友友会这么认为，但这是错误的❌。</p> 
<h3>代码如下：</h3> 
<pre><code class="language-java">import java.util.Comparator;
import java.util.List;
import java.util.ArrayList;
class cmp implements Comparator&lt;Integer&gt;{
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1 - o2;
    }
}
public class Test1 {
    public static void main(String[] args) {
        List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
        ret.add(4);
        ret.add(3);
        ret.add(2);
        ret.add(1);
        ret.sort(new cmp());
        for(Integer x:ret){
            System.out.print(x + " ");
        }
    }
}</code></pre> 
<p>其运行结果如下：显然正确😎😎😎</p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/a4/3d/tpdrQHYP_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h2 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%EF%BC%9A">自定义类型比较排序：</h2> 
<p><span style="color:#fe2c24;"><strong>声明：为了方便叙述我们自定义一个Person类里面有int类型的年龄，String类型的姓名。</strong></span></p> 
<p>在更多情况下我们还是想直接用sort来排序自定义类型，下面我给出java对象比较的三种方式如下图：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>覆写的方法</td><td>说明</td></tr><tr><td>Object.equals</td><td>因为所有类都是继承自Object的，所以直接覆写即可，不过只能比较相等与否。</td></tr><tr><td>Comparable.compareTo</td><td>需要手动实现接口，侵入性比较强，但一旦实现，每次用该类都有顺序，属于内部顺序。</td></tr><tr><td>Comparator.compare</td><td>需要实现一个比较器对象，对待比较类的侵入性弱，但对算法代码实现侵入性强。</td></tr></tbody></table> 
<p>equals不是用在sort中的，只是如果想要就自定义类型使用&gt;,&lt;,==,的话就必须要重写equals方法。</p> 
<p><span style="color:#fe2c24;">在自定义类中基本用的都是自己实现一个比较器故下面不讲Comparable（只能比较一个，后续如果要修改很麻烦不方便），都是使用Comparator。</span></p> 
<p>由于本文章主要讲解自定义类型sort排序，其它的一些细节问题不过多描述还请见谅❤️。</p> 
<p>如果直接用sort的话编译能通过但会报如下错误，右边为Person类。</p> 
<p><img alt="" height="1189" src="https://images2.imgbox.com/81/b5/9jbTrhi5_o.png" width="1200"></p> 
<h3 id="%E6%8C%89%E7%85%A7%E5%B9%B4%E9%BE%84%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%9A">按照年龄逆序排序：</h3> 
<p>代码如下：</p> 
<pre><code class="language-java">import java.util.Arrays;
import java.util.Comparator;

class Person{
    int age;
    String name;
    public Person(int age,String name){
        this.age = age;
        this.name = name;
    }
    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}
class cmp implements Comparator&lt;Person&gt;{
    public int compare(Person o1,Person o2){
        return o2.age - o1.age;
    }
}
public class Test2 {
    public static void main(String[] args) {
        Person person1 = new Person(1,"cc");
        Person person2 = new Person(3,"bb");
        Person person3 = new Person(2,"aa");
        Person[] array = new Person[3];
        array[0] = person1;
        array[1] = person2;
        array[2] = person3;
        Arrays.sort(array,new cmp());
        for(int i = 0;i &lt; array.length;i++){
            System.out.println(array[i]);
        }
    }
}
</code></pre> 
<p>效果如下：</p> 
<p>之所以能println出来这样是因为我们在Person类中重写了toString方法。</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/0f/1a/3ogLhmCL_o.png" width="1200"></p> 
<p>升序就不用说了。</p> 
<h3 id="%E6%8C%89%E7%85%A7%E5%A7%93%E5%90%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%9A">按照姓名升序排序：</h3> 
<p>为了使文章更加简洁下面只给出比较器，友友们自己替换一下即可。name是String类型要比较大小直接调用compareTo方法即可。</p> 
<pre><code class="language-java">class cmp implements Comparator&lt;Person&gt;{
    public int compare(Person o1,Person o2){
        return o1.name.compareTo(o2.name);
    }
}</code></pre> 
<p>结果如下：</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/87/c1/sKExEP6O_o.png" width="1200"></p> 
<h2 id="lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%86%99%EF%BC%9A">lambada表达式简写：</h2> 
<p>这个lambada表达式简写是我在看别人题解时看到的，说实话第一次看到有点震惊，如果对这个很熟悉的话用sort来实现各种排序将写的非常快。由于文章篇幅有限下面直接给出用法不解释原理，大家可以先模仿等后续学到lambada表达式就水到渠成了👍👍👍</p> 
<p>下面是lambada的语法实在不想看的话可以跳过会用就行👌</p> 
<p>Lambada表达式的语法：</p> 
<p><span style="color:#fe2c24;">基本语法: (parameters) -&gt; expression 或 (parameters) -&gt;{ statements}</span></p> 
<p>Lambda表达式由三部分组成：</p> 
<blockquote> 
 <p><strong>（1）paramaters：类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明也可不声明而由JVM隐含的推断。另外当只有一个推断类型时可以省略掉圆括号。 </strong></p> 
 <p><strong>（2）-&gt;：可理解为“被用于”的意思。</strong></p> 
 <p><strong>（3）方法体：可以是表达式也可以是代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不返回，这里的代码块等同于方法的方法体。如果是表达式，也可以返回一个值或者什么都不反回。</strong></p> 
</blockquote> 
<h3 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E9%80%86%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A">一维数组逆序代码：</h3> 
<pre><code class="language-java">public class Test4 {
    public static void main(String[] args) {
        Integer[] nums = {1,7,4,2,9,6,4};
        Arrays.sort(nums,(o1,o2)-&gt; o2 - o1);
        for(int i = 0;i &lt; nums.length;i++){
            System.out.print(nums[i] + " ");
        }
    }
}</code></pre> 
<p>结果如下：</p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/fb/fb/n0Ah6uNO_o.png" width="1200"></p> 
<h3 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A">二维数组排序代码：</h3> 
<pre><code class="language-java">import java.util.Arrays;
public class Test5 {
    public static void main(String[] args) {
        int[][] nums = {<!-- -->{1,3},{2,7},{6,7},{4,1},{3,9}};
        Arrays.sort(nums,(o1,o2)-&gt;o1[0] - o2[0]);
        for(int i = 0;i &lt; nums.length;i++){
            for(int j = 0;j &lt; nums[i].length;j++){
                System.out.print(nums[i][j] + " ");
            }
            System.out.println();
        }

    }
}</code></pre> 
<p>效果如下：</p> 
<p><img alt="" height="442" src="https://images2.imgbox.com/cc/98/kjBkCzQZ_o.png" width="1200"></p> 
<h3 id="%C2%A0List%3C%3E%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%9A">List&lt;&gt;排序代码：</h3> 
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;
public class Test6 {
    public static void main(String[] args) {
        List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
        ret.add(1);
        ret.add(2);
        ret.add(3);
        ret.add(4);
        ret.sort((o1,o2)-&gt;o2 - o1);
        for(Integer x:ret){
            System.out.print(x + " ");
        }
    }
}</code></pre> 
<p> 结果如下：</p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/eb/d9/0CNqNjbf_o.png" width="1200"></p> 
<h3 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F%EF%BC%9A">自定义类型排序：</h3> 
<p>这个有点多且上面代码给过了这里直接给图片啦！</p> 
<p><img alt="" height="1145" src="https://images2.imgbox.com/cd/a3/y4IQWVgG_o.png" width="1200"></p> 
<p>到这已经把Java当中sort常用的排序已经全部给出，说实话整理出来还是挺不容易的😫😫😫，查阅资料等等这篇博客我整理了将近一周的时间希望对大家有所帮助❤️❤️❤️。</p> 
<h2 id="%E7%BB%93%E8%AF%AD%EF%BC%9A">结语：</h2> 
<p><strong>其实写博客不仅仅是为了教大家，同时这也有利于我巩固知识点，和做一个学习的总结，由于作者水平有限，对文章有任何问题还请指出，非常感谢。如果大家有所收获的话还请不要吝啬你们的点赞收藏和关注，这可以激励我写出更加优秀的文章。</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0d/de/Nzi3ERPi_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d9f6968c8b24f445cb0ecf057d350e15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;/STL】vector（常见接口、模拟实现、迭代器失效）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c48a9b4bebbb96e29e96810765ccc29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【前端】web移动端进行监控是否完播 | 视频完播率设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>