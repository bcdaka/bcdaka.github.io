<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言课设】经典植物大战僵尸丨完整开发教程&#43;笔记&#43;源码 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/66ccc93cd31c8b8b4cf7219acbd4a83a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C语言课设】经典植物大战僵尸丨完整开发教程&#43;笔记&#43;源码">
  <meta property="og:description" content="前言 植物对抗僵尸是一款经典小游戏，初学者可以从零开始开发自己的版本，这将是一次令人期待的经历！它可以作为课程设计的一部分，也可以用来快速提升项目开发技能。
视频教程&#43;素材资源 点击进入B站：（视频教程&#43;素材资源）
说明：项目演示视频，在上面链接里的第一个视频，下面只展示项目截图..
项目准备 安装Visual Studio的任意版本（推荐VS2019社区版、VS2022社区版）
安装easyx图形库（官网下载地址）
领取项目素材（回复“植物大战僵尸”，即可领取）
创建项目 使用VS创建项目，使用空项目模板：
导入素材 ： 在项目目录下，创建res文件夹，把解压后的素材拷贝到res目录下。 实现游戏初始场景 代码如下（需要逐行代码视频讲解，可回复“代码讲解“）。
#include &lt;stdio.h&gt; #include &lt;graphics.h&gt; #include &#34;tools.h&#34; #include &lt;mmsystem.h&gt; #pragma comment(lib, &#34;winmm.lib&#34;) #define WIN_WIDTH 900 #define WIN_HEIGHT 600 enum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUT }; IMAGE imgBg; IMAGE imgBar; IMAGE imgCards[ZHI_WU_COUT]; IMAGE* imgZhiWu[ZHI_WU_COUT][20]; int curZhiWu; int curX, curY; //当前选中植物在移动过程中的坐标 struct zhiWu { int type; // &gt;=1 0:没有植物 int frameIndex; }; struct zhiWu map[3][9]; int sunshine; int sunshineTable[ZHI_WU_COUT] = { 100, 50 }; void gameInit() { loadimage(&amp;imgBg, &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-21T20:59:05+08:00">
    <meta property="article:modified_time" content="2024-02-21T20:59:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言课设】经典植物大战僵尸丨完整开发教程&#43;笔记&#43;源码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>植物对抗僵尸是一款经典小游戏，初学者可以从零开始开发自己的版本，这将是一次令人期待的经历！它可以作为课程设计的一部分，也可以用来快速提升项目开发技能。</p> 
<p></p> 
<h3>视频教程+素材资源</h3> 
<p><strong><span style="color:#fe2c24;">点击进入B站：（<a class="link-info" href="https://www.bilibili.com/video/BV1vM4y1X7Kb/?share_source=copy_web&amp;vd_source=92de6f1e7d99047f4214ddc6e5de25a5" rel="nofollow" title="视频教程+素材资源">视频教程+素材资源</a>）</span></strong><br> 说明：项目演示视频，在上面链接里的第一个视频，下面只展示项目截图..</p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/ab/a2/SFyOZfkn_o.png" width="862"></p> 
<p></p> 
<h3>项目准备</h3> 
<ul><li> <p>安装Visual Studio的任意版本（推荐<a href="https://so.csdn.net/so/search?q=VS2019&amp;spm=1001.2101.3001.7020" title="VS2019">VS2019</a>社区版、VS2022社区版）</p> </li></ul> 
<ul><li> <p>安装easyx图形库（<a href="https://easyx.cn/download/EasyX_20220901.exe" rel="nofollow" title="官网下载地址">官网下载地址</a>）</p> </li></ul> 
<ul><li> <p>领取项目素材（回复“植物大战僵尸”，即可领取）</p> </li></ul> 
<h3><a name="t2"></a>创建项目</h3> 
<p>使用VS创建项目，使用空项目模板：</p> 
<h3><img alt="" height="577" src="https://images2.imgbox.com/a6/7b/giMUOFZW_o.png" width="883"></h3> 
<h3></h3> 
<h3>导入素材 ：</h3> 
<h6 style="background-color:transparent;">在项目目录下，创建res文件夹，把解压后的素材拷贝到res目录下。</h6> 
<p><img alt="" height="197" src="https://images2.imgbox.com/a9/97/ppwvBoVy_o.png" width="695"></p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/3f/e6/n0y9oZJC_o.png" width="781"></p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/62/93/hrjgApvP_o.png" width="779"></p> 
<h3 style="background-color:transparent;">实现游戏初始场景</h3> 
<p>代码如下（需要逐行代码视频讲解，可回复“代码讲解“）。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;graphics.h&gt;
#include "tools.h"
#include &lt;mmsystem.h&gt;
#pragma comment(lib, "winmm.lib")
 
#define WIN_WIDTH    900
#define WIN_HEIGHT    600
 
enum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUT };
IMAGE imgBg;
IMAGE imgBar;
IMAGE imgCards[ZHI_WU_COUT];
IMAGE* imgZhiWu[ZHI_WU_COUT][20];
int curZhiWu;
int curX, curY; //当前选中植物在移动过程中的坐标
 
struct zhiWu {
    int type;   // &gt;=1  0:没有植物
    int frameIndex;
};
struct zhiWu  map[3][9];
int sunshine;
int sunshineTable[ZHI_WU_COUT] = { 100, 50 };
 
void gameInit() {
    loadimage(&amp;imgBg, "res/bg.jpg");
    loadimage(&amp;imgBar, "res/bar.png");
    sunshine = 150;
    curZhiWu = 0;
    memset(imgZhiWu, 0, sizeof(imgZhiWu));
    memset(map, 0, sizeof(map));
 
    char name[64];
    for (int i = 0; i &lt; ZHI_WU_COUT; i++) {
        sprintf_s(name, sizeof(name), "res/Cards/card_%d.png", i + 1);
        loadimage(&amp;imgCards[i], name);
 
        for (int j = 0; j &lt; 20; j++) {
            sprintf_s(name, sizeof(name), "res/zhiwu/%d/%d.png", i, j + 1);
            imgZhiWu[i][j] = new IMAGE;
            loadimage(imgZhiWu[i][j], name);
            if (imgZhiWu[i][j]-&gt;getwidth() == 0) {
                delete imgZhiWu[i][j];
                imgZhiWu[i][j] = NULL;
            }
        }
    }
 
    initgraph(WIN_WIDTH, WIN_HEIGHT, 1);
    // 设置字体：
    LOGFONT f;
    gettextstyle(&amp;f);                     // 获取当前字体设置
    f.lfHeight = 30;                      // 设置字体高度为 48
    f.lfWidth = 15;
    strcpy(f.lfFaceName, "Segoe UI Black");
    f.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  
    settextstyle(&amp;f);                     // 设置字体样式
    setbkmode(TRANSPARENT);
    setcolor(BLACK);
 
    mciSendString("play res/bg.mp3 repeat", 0, 0, 0);
}
 
void updateWindow() {
    BeginBatchDraw();
 
    putimage(0, 0, &amp;imgBg);
    putimagePNG(250, 0, &amp;imgBar);
 
    for (int i = 0; i &lt; ZHI_WU_COUT; i++) {
        int x = 338 + i * 64;
        int y = 6;
        putimage(x, y, &amp;imgCards[i]);
    }
 
    if (curZhiWu &gt; 0) {  // 绘制正在移动的植物
        IMAGE* img = imgZhiWu[curZhiWu - 1][0];
        putimagePNG(curX - img-&gt;getwidth() * 0.5, curY - img-&gt;getheight() * 0.5, img);
    }
 
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 9; j++) {
            if (map[i][j].type &gt; 0) {
                int x = 260 + j * 81.6;    // (msg.x - 260) / 81.6;
                int y = 180 + i * 103.6 + 14; // (msg.y - 210) / 103.6;
                int zhiWuIndex = map[i][j].type;
                int frameIndex = map[i][j].frameIndex;
                putimagePNG(x, y, imgZhiWu[zhiWuIndex - 1][frameIndex]);
            }
        }
    }
 
    char scoreText[8];
    sprintf_s(scoreText, sizeof(scoreText), "%d", sunshine);
    outtextxy(282 - 10 + 4, 50 + 15 + 2, scoreText);
    EndBatchDraw();
}
 
void userClick() {
    ExMessage msg;
    static int status = 0;
    if (peekmessage(&amp;msg)) {
        if (msg.message == WM_LBUTTONDOWN) {
            if (msg.x &gt; 338 &amp;&amp; msg.x &lt; 338 + 64 * ZHI_WU_COUT &amp;&amp; msg.y&gt;6 &amp;&amp; msg.y &lt; 96) {
                int index = (msg.x - 338) / 64;
                printf("%d\n", index);
                status = 1;
                curZhiWu = index + 1; // 1， 2 
                curX = msg.x;
                curY = msg.y;
            }
        }
        else if (msg.message == WM_MOUSEMOVE &amp;&amp; status == 1) {
            curX = msg.x;
            curY = msg.y;
        }
        else if (msg.message == WM_LBUTTONUP &amp;&amp; status == 1) {
            printf("up\n");
            if (msg.x &gt; 260 &amp;&amp; msg.y &lt; 995 &amp;&amp; msg.y &gt; 180 &amp;&amp; msg.y &lt; 491) {
                if (sunshine &gt;= sunshineTable[curZhiWu - 1]) {
                    sunshine -= sunshineTable[curZhiWu - 1];
                    int col = (msg.x - 260) / 81.6;
                    int row = (msg.y - 210) / 103.6;
                    printf("[%d,%d]\n", row, col);
                    if (map[row][col].type == 0) {
                        map[row][col].type = curZhiWu;
                        map[row][col].frameIndex = 0;
                    }
                }
            }
            status = 0;
            curZhiWu = 0;
        }
    }
}
 
void updateGame() {
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 9; j++) {
            if (map[i][j].type &gt; 0) {
                map[i][j].frameIndex++;
                if (imgZhiWu[map[i][j].type - 1][map[i][j].frameIndex] == NULL) {
                    map[i][j].frameIndex = 0;
                }
            }
        }
    }
}
 
int main(void) {
    gameInit();
 
    int timer = 0;
    bool flag = true;
    while (1) {
        userClick();
        timer += getDelay();
        if (timer &gt; 20) {
            timer = 0;
            flag = true;
        }
        if (flag) {
            flag = false;
            updateWindow();
            updateGame();
        }
    }
 
    return 0;
}</code></pre> 
<p></p> 
<h3 style="background-color:transparent;">添加启动菜单</h3> 
<p>创建菜单界面，代码如下：</p> 
<pre><code class="language-cpp">void startUI() {
    IMAGE imgBg, imgMenu1, imgMenu2;
    loadimage(&amp;imgBg, "res/menu.png");
    loadimage(&amp;imgMenu1, "res/menu1.png");
    loadimage(&amp;imgMenu2, "res/menu2.png");
    int flag = 0;
    while (1) {
        BeginBatchDraw();
        putimage(0, 0, &amp;imgBg);
        putimagePNG(474, 75, flag ? &amp;imgMenu2 : &amp;imgMenu1);
 
        ExMessage msg;
        if (peekmessage(&amp;msg)) {
            if (msg.message == WM_LBUTTONDOWN &amp;&amp;
                msg.x &gt; 474 &amp;&amp; msg.x &lt; 474 + 300 &amp;&amp; msg.y &gt; 75 &amp;&amp; msg.y &lt; 75 + 140) {
                flag = 1;
                EndBatchDraw();
            }
            else if (msg.message == WM_LBUTTONUP &amp;&amp; flag) {
                return;
            }
        }
        EndBatchDraw();
    }
}</code></pre> 
<h4 style="background-color:transparent;">在main函数中调用菜单，代码如下：</h4> 
<pre><code class="language-cpp">int main(void) {
    gameInit();
    startUI();
    int timer = 0;
    bool flag = true;
    while (1) {
        userClick();
        timer += getDelay();
        if (timer &gt; 20) {
            timer = 0;
            flag = true;
        }
        if (flag) {
            flag = false;
            updateWindow();
            updateGame();
        }
    }
 
    return 0;
}</code></pre> 
<h3>生产阳光</h3> 
<p><br> 熟悉植物大战僵尸的同学都知道，种植植物才能消灭僵尸，但是种植植物，需要先具备一定数量的阳光值。初始的阳光值很小。</p> 
<p><strong>有两种方式生成阳光：</strong></p> 
<p><strong>第一种，</strong>随机降落少量的阳光；</p> 
<p><strong>第二种，</strong>通过种植向日葵，让向日葵自动生产阳光。我们先实现第一种方式。</p> 
<p>定义一个结构体，来表示阳光球。因为阳光是以旋转的方式运动的，所以定义一个图片帧数组，通过循环播放图片帧来实现旋转效果。</p> 
<pre><code class="language-cpp">IMAGE imgSunshineBall[29]; 
struct sunshineBall { 
    int x, y;
    int frameIndex;
    bool used;
    int destY;
    int timer = 0;
};
struct sunshineBall balls[10];</code></pre> 
<p>在gameInit函数中，初始化阳光帧数组。</p> 
<pre><code class="language-cpp">    memset(balls, 0, sizeof(balls));
    for (int i = 0; i &lt; 29; i++) {
        sprintf_s(name, sizeof(name), "res/sunshine/%d.png", i + 1);
        loadimage(&amp;imgSunshineBall[i], name);
    }</code></pre> 
<p>创建阳光，代码如下。</p> 
<pre><code class="language-cpp">void createSunshine() {
    int ballMax = sizeof(balls) / sizeof(balls[0]);
 
    static int frameCount = 0;
    static int fre = 400;
    frameCount++;
    if (frameCount &gt;= fre) {
        fre = 200 + rand() % 200;  
        frameCount = 0;
        int i;
        for (i = 0; i &lt; ballMax &amp;&amp; balls[i].used; i++);
        if (i &gt;= ballMax) return;
 
        balls[i].used = true;
        balls[i].frameIndex = 0;
        balls[i].x = 260 + rand() % (905 - 260);
        balls[i].y = 60;
        balls[i].destY = 180 + (rand() % 4) * 90 + 20;
        balls[i].timer = 0;
    }
}</code></pre> 
<p>修改阳光的位置和帧序号，代码如下。</p> 
<pre><code class="language-cpp">void updateSunshine() {
    int ballMax = sizeof(balls) / sizeof(balls[0]);
 
    for (int i = 0; i &lt; ballMax; i++) {
        if (balls[i].used) {
            balls[i].frameIndex = (balls[i].frameIndex + 1) % 29;
            if(balls[i].timer == 0) balls[i].y += 2;
            if (balls[i].y &gt;= balls[i].destY) {
                balls[i].timer++;
                if (balls[i].timer &gt; 100) balls[i].used = false;
            }
        }
    }
}</code></pre> 
<p>在updateGame函数中调用以上两个函数 ，以创建阳光并更新阳光的状态。</p> 
<pre><code class="language-cpp">createSunshine();
updateSunshine();</code></pre> 
<p>在updateWindow函数中，渲染阳光。</p> 
<pre><code class="language-cpp">for (int i = 0; i &lt; 10; i++) {
    if (balls[i].used) {
        putimagePNG(balls[i].x, balls[i].y, &amp;imgSunshineBall[balls[i].frameIndex]);
    }
}</code></pre> 
<h3>收集阳光</h3> 
<p>当“阳光球”出现的时候，用户点击阳光球，就可以“收集”这个阳光，当前总的阳光值就会增加25点。在原版的植物大战僵尸游戏中，阳光球被收集后，会慢慢移动到顶部的“工具栏”的左侧。这个阳光球的“移动过程”，我们后续再实现。</p> 
<p>定义一个全局变量，表示当前总的阳光值。</p> 
<pre><code class="language-cpp">int sunshine;</code></pre> 
<p>在初始化gameInit中，设置一个初始值。</p> 
<pre><code class="language-cpp">sunshine = 150;</code></pre> 
<p>创建收集阳光的函数，如下：</p> 
<pre><code class="language-cpp">void collectSunshine(ExMessage* msg) {
    int count = sizeof(balls) / sizeof(balls[0]);
    int w = imgSunshineBall[0].getwidth();
    int h = imgSunshineBall[0].getheight();
    for (int i = 0; i &lt; count; i++) {
        if (balls[i].used) {
            int x = balls[i].x;
            int y = balls[i].y;
            if (msg-&gt;x &gt; x &amp;&amp; msg-&gt;x &lt; x + w &amp;&amp; msg-&gt;y &gt; y &amp;&amp; msg-&gt;y &lt; y + h) {
                balls[i].used = false;
                sunshine += 25;
                mciSendString("play res/sunshine.mp3", 0, 0, 0);
            }
        }
    }
}</code></pre> 
<p>在用户点击处理中，调用收集阳光的函数。</p> 
<pre><code class="language-cpp">#include &lt;mmsystem.h&gt;
#pragma comment(lib, "winmm.lib")
 
void userClick() {
    ExMessage msg;
    static int status = 0;
    if (peekmessage(&amp;msg)) {
        if (msg.message == WM_LBUTTONDOWN) {
            if (msg.x &gt; 338 &amp;&amp; msg.x &lt; 338 + 65 * ZHI_WU_COUNT &amp;&amp; msg.y &lt; 96) {
                int index = (msg.x - 338) / 65;
                status = 1;
                curZhiWu = index + 1;
            } else {
                collectSunshine(&amp;msg);
            }
        }
        // ...... 
    }
}</code></pre> 
<h3>显示当前总的阳光值</h3> 
<p>在gameInit初始化中，设置字体。</p> 
<pre><code class="language-cpp">LOGFONT f;
gettextstyle(&amp;f);                     // 获取当前字体设置
f.lfHeight = 30;                      // 设置字体高度为 48
f.lfWidth = 15;
strcpy(f.lfFaceName, "Segoe UI Black");
f.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  
settextstyle(&amp;f);                     // 设置字体样式
setbkmode(TRANSPARENT);
setcolor(BLACK);</code></pre> 
<p>在updateWindow中绘制阳光值。</p> 
<pre><code class="language-cpp">char scoreText[8];
sprintf_s(scoreText, sizeof(scoreText), "%d", sunshine);
outtextxy(276, 67, scoreText);</code></pre> 
<h3>创建僵尸</h3> 
<p>创建僵尸的数据模型。这里一共创建了10个僵尸，这10个僵尸全部被消灭后，这个关卡就胜利了。</p> 
<pre><code class="language-cpp"> 
struct zm {
    int x, y; 
    int frameIndex;
    bool used;
    int speed;
};
struct zm zms[10];
IMAGE imgZM[22];</code></pre> 
<p>僵尸数组，以及僵尸序列帧图片数组，在gameInit函数中进行初始化，如下。（注意：把僵尸的素材图片保存到src/zm目录下。）</p> 
<pre><code class="language-cpp">memset(zms, 0, sizeof(zms));
srand(time(NULL));
 
for (int i = 0; i &lt; 22; i++) {
    sprintf_s(name, sizeof(name), "res/zm/%d.png", i + 1);
    loadimage(&amp;imgZM[i], name);
}</code></pre> 
<p>创建僵尸，代码如下：</p> 
<pre><code class="language-cpp">void createZM() {
    static int zmFre = 500;
    static int count = 0;
    count++;
    if (count &gt; zmFre) {
        zmFre = rand() % 200 + 300;
        count = 0;
 
        int i;
        int zmMax = sizeof(zms) / sizeof(zms[0]);
        for (i = 0; i &lt; zmMax &amp;&amp; zms[i].used; i++);
        if (i &lt; zmMax) {
            zms[i].used = true;
            zms[i].x = WIN_WIDTH;
            zms[i].y = 180 + (1 + rand() % 3) * 100 - 8;
            zms[i].speed = 1;
        }
    }
}</code></pre> 
<p>更新僵尸的数据（僵尸的图片帧序号、僵尸的位置），代码如下：</p> 
<pre><code class="language-cpp">void updateZM() {
    int zmMax = sizeof(zms) / sizeof(zms[0]);
 
    static int count1 = 0;
    count1++;
    if (count1 &gt; 2) {
        count1 = 0;
        for (int i = 0; i &lt; zmMax; i++) {
            if (zms[i].used) {
                zms[i].x -= zms[i].speed;
                if (zms-&gt;x &lt; 236 - 66) {
                    printf("GAME OVER!\n");
                    MessageBox(NULL, "over", "over", 0); //TO DO
                    break;
                }
            }
        }
    }
    
    static int count2 = 0;
    count2++;
    if (count2 &gt; 4) {
        count2 = 0;
        for (int i = 0; i &lt; zmMax; i++) {
            if (zms[i].used) {
                zms[i].frameIndex = (zms[i].frameIndex + 1) % 22;
            }
        }
    }
}</code></pre> 
<p>在updateGame函数中，创建僵尸并更新僵尸数据，如下：</p> 
<pre><code class="language-cpp">createZM();
updateZM();</code></pre> 
<p>创建绘制僵尸的接口, 如下：</p> 
<pre><code class="language-cpp">void drawZM() {
    int zmCount = sizeof(zms) / sizeof(zms[0]);
    for (int i = 0; i &lt; zmCount; i++) {
        if (zms[i].used) {
            IMAGE* img = &amp;imgZM[zms[i].frameIndex];
            int x = zms[i].x;
            int y = zms[i].y - img-&gt;getheight();
            putimagePNG(x, y, img);
        }
    }
}</code></pre> 
<p>在updateWindow函数中，绘制僵尸，如下：</p> 
<pre><code class="language-cpp">drawZM();</code></pre> 
<p>实现阳光球的飞跃<br> 现在的实现效果是，阳光被点击后，阳光球直接消失了！而原版的植物大战僵尸中，阳光被点击后，阳光会自动飞向左上角的位置，飞到终点后，阳光值才增加25点。我们的实现方式是，阳光球每次飞跃4个点，直到飞到终点，如下图：</p> 
<p><img alt="" height="481" src="https://images2.imgbox.com/a6/d7/ZTVG3a2d_o.png" width="582"><br> 给阳光的结构体添加两个成员，表示飞跃过程中的偏移量：</p> 
<pre><code class="language-cpp">struct sunshineBall { 
    int x, y;
    int frameIndex;
    bool used;
    int destY;
    int timer;
 
    //添加以下两个成员
    float xOff;
    float yOff;
};</code></pre> 
<p>在阳光被创建时，把变异量设置为0， 如下：</p> 
<pre><code class="language-cpp">void createSunshine() {
    int ballMax = sizeof(balls) / sizeof(balls[0]);
    static int frameCount = 0;
    static int fre = 200;
    frameCount++;
    if (frameCount &gt;= fre) {
        //...略
        balls[i].xOff = 0;
        balls[i].yOff = 0;
    }
 
}</code></pre> 
<p>阳光被点击后，马上修改阳光球的xoff和yoff:</p> 
<pre><code class="language-cpp">#include &lt;math.h&gt;
 
void collectSunshine(ExMessage* msg) {
    int count = sizeof(balls) / sizeof(balls[0]);
    int w = imgSunshineBall[0].getwidth();
    int h = imgSunshineBall[0].getheight();
    for (int i = 0; i &lt; count; i++) {
        if (balls[i].used) {
            int x = balls[i].x;
            int y = balls[i].y;
            if (msg-&gt;x &gt; x &amp;&amp; msg-&gt;x &lt; x + w &amp;&amp;
                msg-&gt;y &gt;y &amp;&amp; msg-&gt;y &lt; y + h) {
                balls[i].used = false;
                sunshine += 25;
                mciSendString("play res/sunshine.mp3", 0, 0, 0);
                
                // 设置初始偏移量
                float destX = 262;
                float destY = 0;
                float angle = atan((y - destY) / (x - destX));
                balls[i].xOff = 4 * cos(angle);
                balls[i].yOff = 4 * sin(angle);
            }
        }
    }
}</code></pre> 
<p>在阳光飞跃过程中更新阳光的位置，如下：（注意是在飞跃过程中，不断计算偏移量，效果更好。）</p> 
<pre><code class="language-cpp">void updateSunshine() {
    int ballMax = sizeof(balls) / sizeof(balls[0]);
    for (int i = 0; i &lt; ballMax; i++) {
        if (balls[i].used) {
           //略...
        }
        else if (balls[i].xOff) {
            float destX = 263;
            float destY = 0;
            float angle = atan((balls[i].y - destY) / (balls[i].x - destX));
            balls[i].xOff = 4 * cos(angle);
            balls[i].yOff = 4 * sin(angle);
 
            balls[i].x -= balls[i].xOff;
            balls[i].y -= balls[i].yOff;
            if (balls[i].y &lt; 0 || balls[i].x &lt; 262) {
                balls[i].xOff = 0;
                balls[i].yOff = 0;
                sunshine += 25; 
            }
        }
    }
}</code></pre> 
<p>删除原来被点击后，立即更新阳光值的代码。</p> 
<pre><code class="language-cpp">//sunshine += 25;</code></pre> 
<p>修改渲染阳光的判断条件，如下：</p> 
<pre><code class="language-cpp">for (int i = 0; i &lt; ballMax; i++) {
    if (balls[i].used 
            || balls[i].xOff) { //添加这个条件
        IMAGE* img = &amp;imgSunshineBall[balls[i].frameIndex];
        putimagePNG(balls[i].x, balls[i].y, img);
    }
}</code></pre> 
<p>此时已经能够实现阳光的飞跃了，但是飞跃动作太慢了，后期我们再优化。</p> 
<h3><a name="t10"></a>发射豌豆</h3> 
<p>僵尸靠近时，已经种植的植物豌豆就会自动发射“子弹”，我们先为子弹定义数据类型，如下：</p> 
<pre><code class="language-cpp">struct bullet {
    int x, y;
    int row;
    bool used;
    int speed;
};
struct bullet bullets[30];
IMAGE imgBulletNormal;</code></pre> 
<p>在gameInit函数中，初始化“豌豆子弹池”和子弹的图片，如下：</p> 
<pre><code class="language-cpp">loadimage(&amp;imgBulletNormal, "res/bullets/bullet_normal.png");
memset(bullets, 0, sizeof(bullets));</code></pre> 
<p>在僵尸结构体中，添加成员row, 表示该僵尸所在的“行”，方便后续的判断。也可以不加，直接根据僵尸的y坐标来计算。</p> 
<pre><code class="language-cpp">struct zm {
    int x, y; 
    int frameIndex;
    bool used;
    int speed;
 
    int row; //0..2
};</code></pre> 
<p>在createZM函数中，创建僵尸的时候，设置row成员的值，如下：</p> 
<pre><code class="language-cpp">......
if (i &lt; zmMax) {
    zms[i].used = true;
    zms[i].x = WIN_WIDTH;
 
    zms[i].row = rand() % 3; // 0..2;
    zms[i].y = 172 + (1 + zms[i].row) * 100;
 
    zms[i].speed = 1;
}
......  </code></pre> 
<p>创建shoot函数，实现豌豆发射子弹，如下：</p> 
<pre><code class="language-cpp">void shoot() {
    int zmCount = sizeof(zms) / sizeof(zms[0]);
    int directions[3] = { 0 }; 
    int dangerX = WIN_WIDTH - imgZM[0].getwidth();
    for (int i = 0; i &lt; zmCount; i++) {
        if (zms[i].used &amp;&amp; zms[i].x &lt; dangerX) {
            directions[zms[i].row] = 1;
        }
    }
 
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 9; j++) {
            if (map[i][j].type == WAN_DOU+1 &amp;&amp; directions[i]) {
                static int count = 0;
                count++;
                if (count &gt; 20) {
                    count = 0;
                    int k;
                    int maxCount = sizeof(bullets) / sizeof(bullets[0]);
                    for (k = 0; k &lt; maxCount &amp;&amp; bullets[k].used; k++);
                    if (k &lt; maxCount) {
                        bullets[k].row = i;
                        bullets[k].speed = 4;
                        bullets[k].used = true;
 
                        int zwX = 260 + j * 81.6;    // (msg.x - 260) / 81.6;
                        int zwY = 180 + i * 103.6 + 14; // (msg.y - 210) / 103.6;
 
                        bullets[k].x = zwX + imgZhiWu[map[i][j].type - 1][0]-&gt;getwidth()-10;
                        bullets[k].y = zwY + 5;
                    }
                }
            }
        }
    }
}</code></pre> 
<p>更新子弹的位置，如下：</p> 
<pre><code class="language-cpp">void updateBullets() {
    int countMax = sizeof(bullets) / sizeof(bullets[0]);
    for (int i = 0; i &lt; countMax; i++) {
        if (bullets[i].used) {
            bullets[i].x += bullets[i].speed;
            if (bullets[i].x &gt; WIN_WIDTH) {
                bullets[i].used = false;
            }
        }
    }
}</code></pre> 
<p>在updateGame函数中，发射子弹并更新子弹的位置，如下：</p> 
<pre><code class="language-cpp">shoot();
updateBullets();</code></pre> 
<p>在updateWindow中绘制子弹，如下：</p> 
<pre><code class="language-cpp">int bulletMax = sizeof(bullets) / sizeof(bullets[0]);
for (int i = 0; i &lt; bulletMax; i++) {
    if (bullets[i].used) {
        putimagePNG(bullets[i].x, bullets[i].y, &amp;imgBulletNormal);
    }
}</code></pre> 
<h3>子弹和僵尸的碰撞</h3> 
<p>子弹碰到僵尸之后，子弹会“爆炸”，同时僵尸会“掉血”。我们先给僵尸添加血量成员。</p> 
<pre><code class="language-cpp">struct zm {
     //略...
    int blood;
};</code></pre> 
<p>并在创建僵尸的时候，把血量初始化为100，如下：</p> 
<pre><code class="language-cpp">//...
zms[i].speed = 1;
zms[i].blood = 100;</code></pre> 
<p>子弹在碰到僵尸之后才会爆炸，并显示爆炸图片：</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/58/ab/MwOWl1EB_o.png" width="216"></p> 
<p>所以，我们在子弹的结构体中添加两个成员，分别表示当前是否已经爆炸，以及爆炸的帧图片序号，如下：</p> 
<pre><code class="language-cpp">struct bullet {
    //...
    bool blast;
    int frameIndex; 
};
IMAGE imgBulletBlast[4];</code></pre> 
<p>在gameInit函数中对子弹帧图片数组，进行初始化，如下：</p> 
<pre><code class="language-cpp">loadimage(&amp;imgBulletBlast[3], "res/bullets/bullet_blast.png");
for (int i = 0; i &lt; 3; i++) {
    float k = (i + 1) * 0.2;
    loadimage(&amp;imgBulletBlast[i], "res/bullets/bullet_blast.png", 
        imgBulletBlast[3].getwidth()*k,
        imgBulletBlast[3].getheight()*k, true);
}</code></pre> 
<p>在发射子弹shoot函数中，对子弹的blast和帧序号frameIndex进行初始化，如下：</p> 
<pre><code class="language-cpp">bullets[k].row = i;
bullets[k].speed = 4;
bullets[k].used = true;
 
bullets[k].blast = false;
bullets[k].blastTime = 0;</code></pre> 
<p>在更新子弹的updateBullets函数中，更新子弹爆炸的帧序号，如下：</p> 
<pre><code class="language-cpp">bullets[i].x += bullets[i].speed;
if (bullets[i].x &gt; WIN_WIDTH) {
    bullets[i].used = false;
}
 
if (bullets[i].blast) {
    bullets[i].blastTime++;
    if (bullets[i].blastTime &gt;= 4) {
        bullets[i].used = false;
    }
}</code></pre> 
<p>进行碰撞检测，检查子弹和僵尸是否发生碰撞，如下：</p> 
<pre><code class="language-cpp">void collisionCheck() {
    int bCount = sizeof(bullets) / sizeof(bullets[0]);
    int zCount = sizeof(zms) / sizeof(zms[0]);
    for (int i = 0; i &lt; bCount; i++) {
        if (bullets[i].used == false || bullets[i].blast)continue;
        for (int k = 0; k &lt; zCount; k++) {
            int x1 = zms[k].x + 80;
            int x2 = zms[k].x + 110;
            if (bullets[i].row == zms[k].row &amp;&amp; bullets[i].x &gt; x1 &amp;&amp; bullets[i].x &lt; x2) {
                zms[i].blood -= 20;
                bullets[i].blast = true;
                bullets[i].speed = 0;
            }
        }
        
    }
}</code></pre> 
<p>在updateGame函数中，调用碰撞检测函数，如下：</p> 
<pre><code class="language-cpp">collisionCheck();</code></pre> 
<p>渲染子弹的爆炸效果，如下：</p> 
<pre><code class="language-cpp">int bulletMax = sizeof(bullets) / sizeof(bullets[0]);
for (int i = 0; i &lt; bulletMax; i++) {
    if (bullets[i].used) {
        if (bullets[i].blast) {
            IMAGE* img = &amp;imgBulletBlast[bullets[i].blastTime];
            int x = bullets[i].x + 12 - img-&gt;getwidth() / 2;
            int y = bullets[i].y + 12 - img-&gt;getheight() / 2;
            putimagePNG(x, y, img);
 
            /*bullets[i].used = false;*/
        }
        else {
            putimagePNG(bullets[i].x, bullets[i].y, &amp;imgBulletNormal);
        }
        
    }
}</code></pre> 
<h3>僵尸死亡</h3> 
<p>僵尸被豌豆子弹击中后，会“掉血”，血量掉光了，就直接KO了，同时变成一堆“黑沙”。</p> 
<p>给僵尸结构体添加dead成员，表示是否已经死亡，另外添加一个图片帧数组，用来表示变成成黑沙的过程。</p> 
<pre><code class="language-cpp">struct zm {
    ......
    bool dead;
};
IMAGE imgZmDead[20];</code></pre> 
<p>在gameInit中对这个图片帧数组进行初始化。</p> 
<pre><code class="language-cpp">for (int i = 0; i &lt; 20; i++) {
    sprintf_s(name, sizeof(name), "res/zm_dead/%d.png", i + 1);
    loadimage(&amp;imgZmDead[i], name);
}</code></pre> 
<p>在碰撞检测中对僵尸的血量做检测，如果血量降到0，就设置为死亡状态。如下：</p> 
<pre><code class="language-cpp">void collisionCheck() {
    int bCount = sizeof(bullets) / sizeof(bullets[0]);
    int zCount = sizeof(zms) / sizeof(zms[0]);
    for (int i = 0; i &lt; bCount; i++) {
        if (bullets[i].used == false || bullets[i].blast)continue;
        for (int k = 0; k &lt; zCount; k++) {
            int x1 = zms[k].x + 80;
            int x2 = zms[k].x + 110;
            if (zms[k].dead==false &amp;&amp;  //添加这个条件
                    bullets[i].row == zms[k].row &amp;&amp; bullets[i].x &gt; x1 &amp;&amp; bullets[i].x &lt; x2) {
                zms[k].blood -= 20;
                bullets[i].blast = true;
                bullets[i].speed = 0;
                
                //对血量进行检测
                if (zms[k].blood &lt;= 0) {
                    zms[k].dead = true;
                    zms[k].speed = 0;
                    zms[k].frameIndex = 0;
                }
                break;
            }
        }
    }
}</code></pre> 
<p>僵尸死亡后，在updateZM中，更新僵尸的状态（变成黑沙发）。如下：</p> 
<pre><code class="language-cpp">static int count2 = 0;
count2++;
if (count2 &gt; 4) {
    count2 = 0;
    for (int i = 0; i &lt; zmMax; i++) {
        if (zms[i].used) {
            //判断是否已经死亡
            if (zms[i].dead) {
                zms[i].frameIndex++;
                if (zms[i].frameIndex &gt;= 20) {
                    zms[i].used = false;
                }
            }
            else {
                zms[i].frameIndex = (zms[i].frameIndex + 1) % 22;
            }
        }
    }
}</code></pre> 
<p>绘制僵尸的黑沙状态，如下：</p> 
<pre><code class="language-cpp">void drawZM() {
    int zmCount = sizeof(zms) / sizeof(zms[0]);
    for (int i = 0; i &lt; zmCount; i++) {
        if (zms[i].used) {
            //选择对应的渲染图片
            IMAGE* img = (zms[i].dead) ? imgZmDead : imgZM;
            img += zms[i].frameIndex;
 
            int x = zms[i].x;
            int y = zms[i].y - img-&gt;getheight();
            putimagePNG(x, y, img);
        }
    }
}</code></pre> 
<h3><a href="https://www.bilibili.com/video/BV1vM4y1X7Kb/?share_source=copy_web&amp;vd_source=07605986f1c13ab3786dec350495a673" rel="nofollow" title="后续的内容，点击这里看完整的实现">后续的内容，点击这里看完整的实现</a></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00ded654fb8631baf216c7f04f534ba3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL Server —— While语句循环</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/331b032c7e569ce6634cdfcab7429483/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu22部署MySQL5.7详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>