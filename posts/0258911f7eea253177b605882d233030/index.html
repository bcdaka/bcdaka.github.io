<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>atcoder abc357 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0258911f7eea253177b605882d233030/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="atcoder abc357">
  <meta property="og:description" content="A Sanitize Hands 问题：
思路：前缀和，暴力，你想咋做就咋做
代码：
#include &lt;iostream&gt; using namespace std; const int N = 2e5 &#43; 10; int n, m; int a[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i &#43;&#43; ) { cin &gt;&gt; a[i]; } int ans = 0; for(int i = 1; i &lt;= n; i &#43;&#43; ) { m -= a[i]; ans = i; if(m &lt;= 0) break; } if(m &lt; 0) cout &lt;&lt; ans - 1; else cout &lt;&lt; ans; return 0; } B Uppercase and Lowercase">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-10T21:47:00+08:00">
    <meta property="article:modified_time" content="2024-06-10T21:47:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">atcoder abc357</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>A Sanitize Hands </p> 
<p>问题：<br><img alt="" height="206" src="https://images2.imgbox.com/b6/12/6XnDdOA1_o.png" width="1200"></p> 
<p>思路：前缀和，暴力，你想咋做就咋做</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int N = 2e5 + 10;

int n, m;
int a[N];

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++ ) {
        cin &gt;&gt; a[i];
    }
    
    int ans = 0;
    for(int i = 1; i &lt;= n; i ++ ) {
        m -= a[i];
        ans = i;
        if(m &lt;= 0) break;
    }
    
    if(m &lt; 0) cout &lt;&lt; ans - 1;
    else cout &lt;&lt; ans;
    return 0;    
}</code></pre> 
<p>B Uppercase and Lowercase</p> 
<p>问题：</p> 
<p><img alt="" height="99" src="https://images2.imgbox.com/95/36/I8KHEKzc_o.png" width="1200"></p> 
<p>思路：大小写转换，这里有个问题，为什么我的转换最后都变成数字了，先留个疑问</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 2e5 + 10;

string str;

int main() {
    cin &gt;&gt; str;
    int cnt1 = 0, cnt2 = 0;
    for(auto t: str) {
        if(t &gt;= 'a' &amp;&amp; t &lt;= 'z') cnt1 ++;
        else cnt2 ++;
    }
    
    if(cnt1 &gt;= cnt2)
    transform(str.begin(),str.end(),str.begin(),::tolower);
    else 
    transform(str.begin(),str.end(),str.begin(),::toupper);
    cout&lt;&lt;str&lt;&lt;endl;
    return 0;
}</code></pre> 
<p>C Sierpinski carpet</p> 
<p>问题：<img alt="" height="264" src="https://images2.imgbox.com/76/33/aJaNBgWe_o.png" width="1090"></p> 
<p>思路：阴间题，第一眼递归，但是不想求太多坐标，于是想到把图全变成‘#’最后填充'.'</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

const int N = pow(3, 6) + 10;

char g[N][N];
int n;

int main() {
    cin &gt;&gt; n;
    int len = pow(3, n);
    for(int i = 1; i &lt;= len; i ++ ) {
        for(int j = 1; j &lt;= len; j ++ ) {
            g[i][j] = '#';
        }
    }
    
    for(int level = 1; level &lt;= n; level ++ ) {
        for(int i = 1 + pow(3, level - 1); i &lt;= len; i += pow(3, level)) {
            for(int j = 1 + pow(3, level - 1); j &lt;= len; j += pow(3, level)) {
                for(int k = i; k &lt;= i + pow(3, level - 1) - 1; k ++ ) {
                    for(int u = j; u &lt;= j + pow(3, level - 1) - 1; u ++ ) {
                        g[k][u] = '.';
                    }
                }
            }
        }
    }
    
    for(int i = 1; i &lt;= len; i ++ ) {
        for(int j = 1; j &lt;= len; j ++ ) {
            cout &lt;&lt; g[i][j];
        }
        cout &lt;&lt; endl;
    }
    return 0;
}</code></pre> 
<p>D 88888888</p> 
<p>问题：<br><img alt="" height="210" src="https://images2.imgbox.com/2a/9a/RKQrHBL2_o.png" width="1077"></p> 
<p>思路：逆元，快速幂，对原式子变形后发现最后的结果实际上就是x 乘上一个等比数列，这是碰见的第一道逆元的题目，也明确了我对逆元的认识，由于 a / b % mod != (a % mod/ b % mod) % mod，而直接除的话会造成精度丢失，因此我们可以把除法变成乘法，根据费马小定理如果b和p互质，那么b的逆元就等于b ^ p - 2 因此可以快速幂求逆元</p> 
<p>代码：<br>  </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int mod = 998244353;

long long x;

int get(long long a) {
    int cnt = 0;
    while(a) {
        a /= 10;
        cnt ++;
    }
    return cnt;
}

long long qmi(long long a, long long b) {
    long long res = 1;
    while(b) {
        if(b &amp; 1) res = ((res % mod) * (a % mod)) % mod;
        b &gt;&gt;= 1;
        a = (a % mod * a % mod) % mod;
    }
    return res;
}

int main() {
    cin &gt;&gt; x;
    int len = get(x);
    long long part1 = x % mod;
    long long a = qmi(10, (long long)len);
    long long b = qmi(a, x);
    b --;
    long long c = qmi(a - 1, 998244353 - 2);
    long long part2 = (b % mod * c % mod) % mod;
    cout &lt;&lt; (part1 * part2) % mod;
    return 0;
}</code></pre> 
<p>E Reachability in Functional Graph</p> 
<p>问题：<br><img alt="" height="329" src="https://images2.imgbox.com/f8/c1/imgPkgJ2_o.png" width="1200"></p> 
<p>思路：考虑如果题目是一颗树的话那么直接一个记忆化即可，但是该题会出现环，因此考虑缩点，记得开long long</p> 
<p>据说这是基环树板子，回头学一下基环树</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;stack&gt;
#include &lt;map&gt;

using namespace std;

const int N = (2e5 + 10) * 2;

stack&lt;int&gt; stk;
int n;
int val[N], ne[N], h[N], idx;
int dfn[N], low[N], id[N], _size[N], scc_cnt, ts;
int cnt[N];
bool ins[N], st[N];
long long ans = 0;

void add(int a, int b) {
    val[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

void tarjan(int u) {
    dfn[u] = low[u] = ++ ts;
    stk.push(u);
    ins[u] = true;
    for(int i = h[u]; i != -1; i = ne[i]) {
        int j = val[i];
        if(!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if(ins[j]) low[u] = min(low[u], dfn[j]);
    }
    
    if(dfn[u] == low[u]) {
        ++ scc_cnt;
        int y;
        do {
            y = stk.top();
            stk.pop();
            ins[y] = false;
            id[y] = scc_cnt;
            _size[scc_cnt] ++;
        } while (y != u);
    }
}

void dfs(int u) {
    for(int i = h[u]; i != -1; i = ne[i]) {
        int j = val[i];
        if(!st[j]) {
            dfs(j);
            st[j] = true;
        }
        cnt[u] += cnt[j];
        ans += _size[u] * cnt[j];
    }
}

int main() {
    memset(h, -1, sizeof h);
    cin &gt;&gt; n;
    scc_cnt = n;
    for(int i = 1; i &lt;= n; i ++ ) {
        int x;
        cin &gt;&gt; x;
        add(i, x);
    }
    
    for(int i = 1; i &lt;= n; i ++ ) if(!dfn[i]) tarjan(i);
    for(int i = 1; i &lt;= n; i ++ ) cnt[id[i]] = _size[id[i]];
    map&lt;pair&lt;int, int&gt;, int&gt; ma;
    for(int i = 1; i &lt;= n; i ++ ) {
        for(int j = h[i]; j != -1; j = ne[j]) {
            int k = val[j];
            if(id[i] != id[k] &amp;&amp; !ma[{i, k}]) {
                add(id[i], id[k]);
                ma[{i, k}] ++;
            }
        }
    }
    
    memset(st, 0, sizeof st);
    for(int i = scc_cnt; i &gt; n; i -- ) {
        if(!st[i]) {
            st[i] = true;
            dfs(i);
        }
    }
    for(int i = scc_cnt; i &gt; n; i -- ) ans += (long long)_size[i] * (_size[i] - 1);
    cout &lt;&lt; ans + n;
    return 0;
}</code></pre> 
<p>F two sequence queries</p> 
<p>题目：</p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/10/08/rW43q12N_o.png" width="857"></p> 
<p>思路：对sigema a*b做一点变形 设a加上了x，b加上了y </p> 
<p>原式 = sigema (a + x) (b + y) = sigema a * b + y * a + x * b + x * y</p> 
<p>于是题目变成了区间修改区间查询，显然线段树lazytag板子</p> 
<p>代码：这里代码只a了21个数据，应该是哪里没有mod到位或者什么细节没有注意到，短时间内不改了，到期末了</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int N = 2e5 + 10;
const int mod = 998244353;

int n, m;
struct node{
    unsigned long long l, r;
    unsigned long long suma, sumb, sumab;
    unsigned long long taga, tagb;
}tr[4 * N];

void pushup(int u) {
    tr[u].suma = (tr[u &lt;&lt; 1].suma + tr[u &lt;&lt; 1 | 1].suma) % mod;
    tr[u].sumb = (tr[u &lt;&lt; 1].sumb + tr[u &lt;&lt; 1 | 1].sumb) % mod;
    tr[u].sumab = (tr[u &lt;&lt; 1].sumab + tr[u &lt;&lt; 1 | 1].sumab) % mod;
}

void pushdown(int u) {
    tr[u &lt;&lt; 1].sumab = (tr[u &lt;&lt; 1].sumab + tr[u].taga * tr[u &lt;&lt; 1].sumb + tr[u].tagb * tr[u &lt;&lt; 1].suma + tr[u].taga * tr[u].tagb * (tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1)) % mod;
    tr[u &lt;&lt; 1 | 1].sumab = (tr[u &lt;&lt; 1 | 1].sumab + tr[u].taga * tr[u &lt;&lt; 1 | 1].sumb + tr[u].tagb * tr[u &lt;&lt; 1 | 1].suma + tr[u].taga * tr[u].tagb * (tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1)) % mod;

    tr[u &lt;&lt; 1].suma = (tr[u &lt;&lt; 1].suma + (tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1) * tr[u].taga) % mod;
    tr[u &lt;&lt; 1 | 1].suma = (tr[u &lt;&lt; 1 | 1].suma + (tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1) * tr[u].taga) % mod;
    tr[u &lt;&lt; 1].taga = (tr[u &lt;&lt; 1].taga + tr[u].taga) % mod;
    tr[u &lt;&lt; 1 | 1].taga = (tr[u &lt;&lt; 1 | 1].taga + tr[u].taga) % mod;
    tr[u].taga = 0;
    tr[u &lt;&lt; 1].sumb = (tr[u &lt;&lt; 1].sumb + (tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1) * tr[u].tagb) % mod;
    tr[u &lt;&lt; 1 | 1].sumb = (tr[u &lt;&lt; 1 | 1].sumb + (tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1) * tr[u].tagb) % mod;
    tr[u &lt;&lt; 1].tagb = (tr[u &lt;&lt; 1].tagb + tr[u].tagb) % mod;
    tr[u &lt;&lt; 1 | 1].tagb = (tr[u &lt;&lt; 1 | 1].tagb + tr[u].tagb) % mod;
    tr[u].tagb = 0;
}

void build(int u, int l, int r) {
    tr[u].l = l, tr[u].r = r;
    if(l == r) return;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid);
    build(u &lt;&lt; 1 | 1, mid + 1, r);
}

void add(int u, int p, int x, int type) {
    if(tr[u].l == tr[u].r) {
        if(type == 1) tr[u].suma = x;
        else if(type == 2) tr[u].sumb = x;
        tr[u].sumab = (tr[u].suma * tr[u].sumb) % mod;
    } else {
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if(p &lt;= mid) add(u &lt;&lt; 1, p, x, type);
        else add(u &lt;&lt; 1 | 1, p, x, type);
        pushup(u);
    }
}

void modify(int u, int l, int r, unsigned long long d, int type) {
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) {
        if(type == 1) {
            tr[u].suma = (tr[u].suma + d * (tr[u].r - tr[u].l + 1)) % mod;
            tr[u].taga = (tr[u].taga + d) % mod;
            tr[u].sumab = (tr[u].sumab + d * tr[u].sumb) % mod;
        } else if(type == 2) {
            tr[u].sumb = (tr[u].sumb + d * (tr[u].r - tr[u].l + 1)) % mod;
            tr[u].tagb = (tr[u].tagb + d) % mod;
            tr[u].sumab = (tr[u].sumab + d * tr[u].suma) % mod;
        }
    } else {
        pushdown(u);
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if(mid &gt;= l) modify(u &lt;&lt; 1, l, r, d, type);
        if(mid &lt; r) modify(u &lt;&lt; 1 | 1, l, r, d, type);
        pushup(u);
    }
}

long long query(int u, int l, int r) {
    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) {
        return tr[u].sumab;
    } else {
        pushdown(u);
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        long long res = 0;
        if(mid &gt;= l) res = query(u &lt;&lt; 1, l, r);
        if(mid &lt; r) res = (res + query(u &lt;&lt; 1 | 1, l, r)) % mod;
        return res;
    }
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    build(1, 1, n);
    for(int i = 1; i &lt;= n; i ++ ) {
        int x;
        cin &gt;&gt; x;
        add(1, i, x % mod, 1);
    }    
    for(int i = 1; i &lt;= n; i ++ ) {
        int x;
        cin &gt;&gt; x;
        add(1, i, x % mod, 2);
    }

    while(m -- ) {
        int op;
        cin &gt;&gt; op;
        if(op == 1) {
            int l, r;
            unsigned long long d;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;
            modify(1, l, r, d % mod, 1);
        } else if(op == 2) {
            int l, r, d;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;
            modify(1, l, r, d % mod, 2);
        } else {
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; query(1, l, r) &lt;&lt; endl;
        }
    }
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42abfea05e7147bef6ef19af1a405fc7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jmeter分布式、测试报告、并发数计算、插件添加方式、常用图表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b6b9d516c4b77d2ae9aeb5f7af14951/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端实现流文件下载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>