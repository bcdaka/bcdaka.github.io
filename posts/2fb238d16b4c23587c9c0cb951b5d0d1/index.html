<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【c&#43;&#43;初阶】类与对象（中） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2fb238d16b4c23587c9c0cb951b5d0d1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【c&#43;&#43;初阶】类与对象（中）">
  <meta property="og:description" content="✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅
✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨
🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿
🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟
🌟🌟 追风赶月莫停留 🌟🌟
🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀
🌟🌟 平芜尽处是春山🌟🌟
🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟
🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿
✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨
✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅
🍋类与对象 🍑类的默认成员函数🍑构造函数🍍定义🍍特点🍍实际用法 🍑析构函数🍍定义🍍特点🍍实际用法 🍑拷贝构造函数🍍定义🍍特点🍍实际用法 🍑赋值重载函数🍍运算符重载🍌定义🍌特点🍌实际用法 🍍赋值运算符重载 🍑取地址及const取地址操作符重载 🍑类的默认成员函数 上一个篇章，我讲解了类的基本概念和一些简单的语法，今天我就来讲解类中重要的几个成员函数，这几个成员函数，在我们今后学习过程对我们有非常大的重用，今天就单独拿出来，详细的为大家讲解。
类里面大致有六个成员函数：
初始化和清理：起初始化作用的成员函数，是构造函数。起清理作用的成员函数，是析构函数。
拷贝赋值：起拷贝作用的成员函数，是拷贝函数。起赋值作用的成员函数，是赋值重载。赋值重载又分为运算符重载和函数重载。
取地址重载： 大家可以按照字面意思理解。
🍑构造函数 🍍定义 构造函数是一种特殊的方法，主要用于在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。构造函数的名称应与类的名称完全相同，它不具有任何类型，也没有返回值。构造函数的主要目的是在创建对象时执行一些初始化操作，确保对象在创建时处于正确的状态。
构造函数是一个特殊的成员函数，需要注意的是构造函数虽然名称叫构造，但是构造函数的主要任务并不是看空间创建对象，而是初始化对象。
🍍特点 函数名与类名相同。无返回值。对象实例化时编译器自动调用对应的构造函数。构造函数可以重载。构造函数可以带参数，这使得程序员能够在创建对象时提供初始值，这种带参数的构造被称为带参构造函数。如果在类中没有显示定义构造函数，系统会自动提供一个默认构造函数，这个默认构造函数不会执行任何操作，所有的成员变量都将使用其默认值进行初始化。无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。 注意：
8. 我们不写构造函数，编译器默认生成的那个函数，叫默认构造函数。
9. 无参构造函数也可以叫默认构造函数。
10. 全缺省函数也可以叫默认构造函数。
默认构造还有一个缺陷：C&#43;&#43;把类型分成内置类型(基本类型)和自定义类型。内置类型就是语言提供的数据类型，如：int/char/double等等，自定义类型就是我们自己根据语法规则重新定义的class/struct等等。系统只会处理自定义类型，而不会处理内置类型成员。但是在C&#43;&#43;11 中针对内置类型成员不初始化的缺陷，又打了补丁，即：内置类型成员变量在类中声明时可以给默认值。
🍍实际用法 现在我们根据上面构造函数的特点实际用代码给大家演示： 构造函数名称与类名相同，且无返回值。
构造函数可以重载，在这里也就是一个带参数，一个不带参数。
调用无参构造函数时，对象后面不用跟括号，否则就成了函数声明。 如：
这样写就不是调用该函数了，只是声明了v3函数，该函数无参，返回一个Add类型的对象。
现在针对默认构造解释： 在类中没有显示定义时，从上图中可以看出left和right是随机值。这是系统默认生成了默认构造。
上图中，程序成功运行，也就是说全缺省构造函数也是相当于默认构造函数，但是半缺省不是默认构造函数。
当有显示定义构造后，系统就不会生成默认的构造函数，这里就会报错。
上面在构造函数特点中写到，“C&#43;&#43;11 中针对内置类型成员不初始化的缺陷，又打了补丁，即：内置类型成员变量在类中声明时可以给默认值。” 在C&#43;&#43;11中类里面自定义类型可以在声明时赋初值但是自定义类型还不可以。
🍑析构函数 🍍定义 析构函数是C&#43;&#43;中的一个特殊成员函数，它在对象的生命周期结束时自动被调用。析构函数的主要任务是释放对象在生命周期中可能获取的所有资源，如动态分配的内存等等。
析构函数与构造函数的功能相反，。析构函数不是完成对象本身的销毁。局部对象销毁工作时由编译器完成，而对象在销毁时会自动调用析构函数，完成对象中资源的清理
🍍特点 析构函数名与类名相同，只不过需要在名前加字符~。无参数和无返回值。一个类只能有一个析构函数，若未显示定义，系统会自动生成默认的析构函数。注意：析构函数不能重载。对象生命周期结束时，C&#43;&#43;编译系统自动调用析构函数。析构函数的执行顺序与构造函数相反。首先构造的对象，最后析构，最后构造的对象，首先析构。 🍍实际用法 普通写法： 这是普通函数的写法，没有涉及到空间的释放。当然也可以不写。没有空间使用时，都可以使用系统提供的默认析构函数就可以了。
有空间释放的析构函数的写法：
这就是栈中析构函数的写法。
析构函数与构造函数的执行顺序：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-30T16:32:27+08:00">
    <meta property="article:modified_time" content="2024-03-30T16:32:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【c&#43;&#43;初阶】类与对象（中）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/c3/e1/7eceQSEA_o.gif" alt="请添加图片描述"></p> 
<p>✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅<br> ✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨<br> 🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿<br> 🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟<br> 🌟🌟 <font color="#FF7F50" size="6" face="STCAiYUN"> <em><strong>追风赶月莫停留</strong></em> </font>🌟🌟<br> 🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀<br> 🌟🌟<font color="#FF7F50" size="6" face="STCAiYUN"> <em><strong>平芜尽处是春山</strong></em></font>🌟🌟<br> 🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟<br> 🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿<br> ✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨<br> ✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅</p> 
<p></p> 
<div class="toc"> 
 <h4><font color="#FF7F50" size="7" face="STCAiYUN">🍋类与对象</font></h4> 
 <ul><li><a href="#_21" rel="nofollow">🍑类的默认成员函数</a></li><li><a href="#_38" rel="nofollow">🍑构造函数</a></li><li><ul><li><a href="#_39" rel="nofollow">🍍定义</a></li><li><a href="#_45" rel="nofollow">🍍特点</a></li><li><a href="#_62" rel="nofollow">🍍实际用法</a></li></ul> 
  </li><li><a href="#_119" rel="nofollow">🍑析构函数</a></li><li><ul><li><a href="#_120" rel="nofollow">🍍定义</a></li><li><a href="#_124" rel="nofollow">🍍特点</a></li><li><a href="#_132" rel="nofollow">🍍实际用法</a></li></ul> 
  </li><li><a href="#_155" rel="nofollow">🍑拷贝构造函数</a></li><li><ul><li><a href="#_156" rel="nofollow">🍍定义</a></li><li><a href="#_170" rel="nofollow">🍍特点</a></li><li><a href="#_177" rel="nofollow">🍍实际用法</a></li></ul> 
  </li><li><a href="#_216" rel="nofollow">🍑赋值重载函数</a></li><li><ul><li><a href="#_217" rel="nofollow">🍍运算符重载</a></li><li><ul><li><a href="#_219" rel="nofollow">🍌定义</a></li><li><a href="#_222" rel="nofollow">🍌特点</a></li><li><a href="#_229" rel="nofollow">🍌实际用法</a></li></ul> 
   </li><li><a href="#_257" rel="nofollow">🍍赋值运算符重载</a></li></ul> 
  </li><li><a href="#const_274" rel="nofollow">🍑取地址及const取地址操作符重载</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_21"></a>🍑类的默认成员函数</h2> 
<p>上一个篇章，我讲解了类的基本概念和一些简单的语法，今天我就来讲解类中重要的几个成员函数，这几个成员函数，在我们今后学习过程对我们有非常大的重用，今天就单独拿出来，详细的为大家讲解。</p> 
<p>类里面大致有六个成员函数：</p> 
<ol><li> <p>初始化和清理：起初始化作用的成员函数，是构造函数。起清理作用的成员函数，是析构函数。</p> </li><li> <p>拷贝赋值：起拷贝作用的成员函数，是拷贝函数。起赋值作用的成员函数，是赋值重载。赋值重载又分为运算符重载和函数重载。</p> </li><li> <p>取地址重载： 大家可以按照字面意思理解。</p> </li></ol> 
<h2><a id="_38"></a>🍑构造函数</h2> 
<h3><a id="_39"></a>🍍定义</h3> 
<p>构造函数是一种特殊的方法，主要用于在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。构造函数的名称应与类的名称完全相同，它不具有任何类型，也没有返回值。构造函数的主要目的是在创建对象时执行一些初始化操作，确保对象在创建时处于正确的状态。</p> 
<p>构造函数是一个特殊的成员函数，需要注意的是构造函数虽然名称叫构造，但是构造函数的主要任务并不是看空间创建对象，而是初始化对象。</p> 
<h3><a id="_45"></a>🍍特点</h3> 
<ol><li>函数名与类名相同。</li><li>无返回值。</li><li>对象实例化时编译器自动调用对应的构造函数。</li><li>构造函数可以重载。</li><li>构造函数可以带参数，这使得程序员能够在创建对象时提供初始值，这种带参数的构造被称为带参构造函数。</li><li><li>如果在类中没有显示定义构造函数，系统会自动提供一个默认构造函数，这个默认构造函数不会执行任何操作，所有的成员变量都将使用其默认值进行初始化。无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。</li></ol> 
<p><mark>注意</mark>：<br> 8. 我们不写构造函数，编译器默认生成的那个函数，叫默认构造函数。<br> 9. 无参构造函数也可以叫默认构造函数。<br> 10. 全缺省函数也可以叫默认构造函数。</p> 
<p>默认构造还有一个缺陷：C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语言提供的数据类型，如：int/char/double等等，自定义类型就是我们自己根据语法规则重新定义的class/struct等等。系统只会处理自定义类型，而不会处理内置类型成员。但是在C++11 中针对内置类型成员不初始化的缺陷，又打了补丁，即：内置类型成员变量在类中声明时可以给默认值。</p> 
<h3><a id="_62"></a>🍍实际用法</h3> 
<ol><li>现在我们根据上面构造函数的特点实际用代码给大家演示：</li></ol> 
<p><img src="https://images2.imgbox.com/60/4b/m73N3yZQ_o.png" alt="在这里插入图片描述"><br> 构造函数名称与类名相同，且无返回值。</p> 
<p>构造函数可以重载，在这里也就是一个带参数，一个不带参数。</p> 
<ol start="2"><li>调用无参构造函数时，对象后面不用跟括号，否则就成了函数声明。</li></ol> 
<p>如：</p> 
<p><img src="https://images2.imgbox.com/3a/f5/apMbvz91_o.png" alt="在这里插入图片描述"><br> 这样写就不是调用该函数了，只是声明了v3函数，该函数无参，返回一个Add类型的对象。</p> 
<ol start="3"><li>现在针对默认构造解释：</li></ol> 
<p><img src="https://images2.imgbox.com/d6/f4/mCEgsuRw_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e8/74/QaOqWnCl_o.png" alt="在这里插入图片描述"></p> 
<p>在类中没有显示定义时，从上图中可以看出left和right是随机值。这是系统默认生成了默认构造。</p> 
<ol start="5"><li></ol> 
<p><img src="https://images2.imgbox.com/24/6e/MWJDZzRq_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c4/55/tPD3o7ln_o.png" alt="在这里插入图片描述"></p> 
<p>上图中，程序成功运行，也就是说全缺省构造函数也是相当于默认构造函数，但是半缺省不是默认构造函数。</p> 
<ol start="6"><li></ol> 
<p><img src="https://images2.imgbox.com/61/6d/FiXpVZxl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/78/8b/735XahcE_o.png" alt="在这里插入图片描述"></p> 
<p>当有显示定义构造后，系统就不会生成默认的构造函数，这里就会报错。</p> 
<ol start="7"><li>上面在构造函数特点中写到，“C++11 中针对内置类型成员不初始化的缺陷，又打了补丁，即：内置类型成员变量在类中声明时可以给默认值。”</li></ol> 
<p><img src="https://images2.imgbox.com/c3/d2/KoNAlQ9d_o.png" alt="在这里插入图片描述"></p> 
<p>在C++11中类里面自定义类型可以在声明时赋初值但是自定义类型还不可以。</p> 
<h2><a id="_119"></a>🍑析构函数</h2> 
<h3><a id="_120"></a>🍍定义</h3> 
<p>析构函数是C++中的一个特殊成员函数，它在对象的生命周期结束时自动被调用。析构函数的主要任务是释放对象在生命周期中可能获取的所有资源，如动态分配的内存等等。</p> 
<p>析构函数与构造函数的功能相反，。析构函数不是完成对象本身的销毁。局部对象销毁工作时由编译器完成，而对象在销毁时会自动调用析构函数，完成对象中资源的清理</p> 
<h3><a id="_124"></a>🍍特点</h3> 
<ol><li>析构函数名与类名相同，只不过需要在名前加字符~。</li><li>无参数和无返回值。</li><li>一个类只能有一个析构函数，若未显示定义，系统会自动生成默认的析构函数。<mark>注意</mark>：析构函数不能重载。</li><li>对象生命周期结束时，C++编译系统自动调用析构函数。</li><li>析构函数的执行顺序与构造函数相反。首先构造的对象，最后析构，最后构造的对象，首先析构。</li></ol> 
<h3><a id="_132"></a>🍍实际用法</h3> 
<ol><li>普通写法：</li></ol> 
<p><img src="https://images2.imgbox.com/a8/76/kaG34dgp_o.png" alt="在这里插入图片描述"><br> 这是普通函数的写法，没有涉及到空间的释放。当然也可以不写。没有空间使用时，都可以使用系统提供的默认析构函数就可以了。</p> 
<ol start="2"><li> <p>有空间释放的析构函数的写法：<br> <img src="https://images2.imgbox.com/af/f6/h95fwOie_o.png" alt="在这里插入图片描述"><br> 这就是栈中析构函数的写法。</p> </li><li> <p>析构函数与构造函数的执行顺序：</p> </li></ol> 
<p><img src="https://images2.imgbox.com/c7/95/3YWcXBhL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/56/b0/kmM7f3MJ_o.png" alt="在这里插入图片描述"></p> 
<p>大家从上图中应该就可以看出，析构函数和构造函数的执行顺序是相反。</p> 
<h2><a id="_155"></a>🍑拷贝构造函数</h2> 
<h3><a id="_156"></a>🍍定义</h3> 
<p>拷贝构造函数是一个特殊的构造函数，用于创建一个新对象作为现有对象的副本。</p> 
<p>拷贝构造函数大家可以从字面来理解，什么是拷贝，不就是复制吗，专业语就是赋值，下面会为大家详细解释。</p> 
<p>拷贝构造函数只有单个形参，该形参是对本类型对象的引用（一般常用const修饰），在用已存在的类类型对象创建新对象时由编译器自动调用。</p> 
<p>但是需要注意的是拷贝有深拷贝和浅拷贝。大致的说就是有部分开了空间，就需要深拷贝。没有开空间就只要浅拷贝。</p> 
<h3><a id="_170"></a>🍍特点</h3> 
<ol><li>拷贝构造函数是构造函数的一个重载形式。</li><li>无返回值但有一个参数。</li><li>拷贝分为浅拷贝和深拷贝。</li><li>每个类都存在拷贝构造函数，尽管不显示定义，编译器会提供默认的拷贝构造函数。</li><li>拷贝构造函数的参数只有一个且必须是类类型对象的引用，使用传值方式编译器直接报错，因为会引起无限递归</li></ol> 
<h3><a id="_177"></a>🍍实际用法</h3> 
<ol><li>浅拷贝，也就是没有占用空间：</li></ol> 
<p><img src="https://images2.imgbox.com/3e/d2/geJv0zRv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/be/46/DWorAv1t_o.png" alt="在这里插入图片描述"></p> 
<p>该类中拷贝构造就如上图所写，拷贝构造有两种写法。</p> 
<ol start="2"><li>深拷贝，占用空间：</li></ol> 
<p><img src="https://images2.imgbox.com/17/34/mZo3lbIT_o.png" alt="在这里插入图片描述"><br> 典型的拷贝构造函数，就是栈中的拷贝构造函数，由于栈是占用空间的，它的拷贝构造是一定会深拷贝。</p> 
<p>当然还有一种特殊的情况，就是队列，队列虽然也占用了空间，但是实际上它是调用栈的拷贝构造函数，大家有兴趣可以去试试。</p> 
<ol start="3"><li>传值引发的无限递归拷贝：</li></ol> 
<p><img src="https://images2.imgbox.com/d1/1a/DNksaN4j_o.png" alt="在这里插入图片描述"><br> 错误写法就是传值拷贝，会引发无限递归。</p> 
<p>过程：</p> 
<p><img src="https://images2.imgbox.com/37/94/DjY1HJ1I_o.png" alt="在这里插入图片描述"><br> 值传递是会调用拷贝构造。</p> 
<p>传值拷贝本身并不会直接导致程序无限递归，无限递归是由于函数不断的调用自身，且没有适当结束的条件，就形成了无限递归。</p> 
<p>为了防止这种错误，拷贝构造必须使用指针或者引用，不过现在常用的是引用，很少指针。</p> 
<p>总结：</p> 
<ol><li>内置类型成员完成值拷贝。</li><li>自定义类型成员调用这个成员的拷贝构造（前提是有一个成员的拷贝构造，如：队列调用栈的拷贝构造）。</li><li>顺序表、链表、二叉树等等的类，都需要深拷贝。</li></ol> 
<h2><a id="_216"></a>🍑赋值重载函数</h2> 
<h3><a id="_217"></a>🍍运算符重载</h3> 
<h4><a id="_219"></a>🍌定义</h4> 
<p>运算符重载是C++中一项强大的特性，它允许程序员重新定义或重载大部分C++内置的运算符，以便它们能用于用户自定义的类型。通过运算符重载，可以使自定义类型的对象像内置类型一样使用运算符，从而提高代码的可读性和易用性。</p> 
<h4><a id="_222"></a>🍌特点</h4> 
<ol><li>不能通过连接其他符号来创建新的操作符：比如operator@</li><li>重载操作符必须有一个类类型参数</li><li>用于内置类型的运算符，其含义不能改变，例如：内置的整型+，不 能改变其含义。</li><li>作为类成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this</li><li>（.* :: sizeof ? : .） ， 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。</li></ol> 
<h4><a id="_229"></a>🍌实际用法</h4> 
<ol><li>内置类型对象可以直接使用各种运算符，内置类型都是简单类型。</li></ol> 
<p><img src="https://images2.imgbox.com/e7/3d/VVxszAEK_o.png" alt="在这里插入图片描述"><br> 2. 自定义类型需要用关键字才能用运算符：</p> 
<p><img src="https://images2.imgbox.com/74/bd/Nc7rI0WJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f0/31/clYJ4hWT_o.png" alt="在这里插入图片描述"><br> 下面那种是operator不放在类里面的写法，不过operator基本都写在类里面，所以还有一种写法：<br> <img src="https://images2.imgbox.com/bd/a2/wgz8yY8T_o.png" alt="在这里插入图片描述"></p> 
<p>当然不仅仅只有这一种，还有减法等等。<br> <img src="https://images2.imgbox.com/46/a6/ttVYnIFo_o.png" alt="在这里插入图片描述"><br> 大家从程序执行结果来看运算符==是看两者是否相等，相等返回1，不相等返回0。而&lt;和&gt;也是同样如此。返回的都是布尔值。</p> 
<p>实际上operator是一个函数，如:</p> 
<p><img src="https://images2.imgbox.com/a8/a8/fQgZV9c1_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f9/64/2Bhr1CnL_o.png" alt="在这里插入图片描述"><br> 这就是operator在类中的写法。</p> 
<p>有的人可能会问传过去的不是两个参数吗，为什么在operator中只接收了一个参数？问出这个问题的可能是忘了C++中的this指针，this指针已经指向了第一个参数，所以不用传第一个参数过去。</p> 
<h3><a id="_257"></a>🍍赋值运算符重载</h3> 
<ol><li>参数类型：const T&amp;，传递引用可以提高传参效率</li><li>返回值类型：T&amp;，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值</li><li>检测是否自己给自己赋值</li><li>返回*this ：要复合连续赋值的含义</li></ol> 
<p><img src="https://images2.imgbox.com/5c/31/97YCcilw_o.png" alt="在这里插入图片描述"></p> 
<p>上图中就是赋值运算符重载的写法。</p> 
<p>赋值运算符只能重载成类的成员函数不能重载成全局函数，否则就要传同等数量的参数了。</p> 
<p>在前面有写了默认构造函数和默认析构函数等等，这里赋值运算符重载，也是有相关默认赋值运算符重载，用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝，内置类型成员变量是直接赋值的，而自定义类型成员变量需要调用对应类的赋值运算符重载完成赋值。对于一些没有涉及到资源管理的可以用系统默认的赋值运算符重载，而涉及到的就必须自己重新写，比如栈等等。</p> 
<h2><a id="const_274"></a>🍑取地址及const取地址操作符重载</h2> 
<p>这两个默认成员函数一般不用重新定义 ，编译器默认会生成。</p> 
<p><img src="https://images2.imgbox.com/52/b2/mrT9LBc2_o.png" alt="在这里插入图片描述"><br> 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需<br> 要重载，比如想让别人获取到指定的内容！</p> 
<p>本次所写到的六个类的默认成员函数的知识点，到此就写完了，如果有些知识点我写的有误或者没写到，欢迎大家指正！！！</p> 
<p><img src="https://images2.imgbox.com/1c/85/2n8DVm27_o.gif" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/84/d1/wGsZSUBC_o.gif" alt="请添加图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8a4729515d1f840292a4016b77248a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python | 单变量时间序列分析与预测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/64d91074edb7f0a1082f94816c2482df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode使用eslint</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>