<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【初阶数据结构】栈和队列（附题目） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e3c08c8126b643efc134f9beebb2e407/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【初阶数据结构】栈和队列（附题目）">
  <meta property="og:description" content="目录
1.栈
1.1栈的概念及结构
1.2栈的实现
1.2.2实现结构的选择
a.数组
b.链表
c.更优的选择
1.2.3实现结构
a.栈的结构体
b.栈的初始化
c.栈的销毁
d.入栈
e.出栈 f.获取栈顶元素
g.获取栈中有效元素个数 h.检测队列是否为空，如果为空返回非零结果，如果非空返回0 2.队列
2.1队列的概念及结构
2.2队列的实现
2.2.1.实现结构的选择
2.2.2.实现结构的选择
a.单个队列节点的结构体
b.维护队列的结构体
c.队列的初始化
d.销毁队列 e.队尾入队列 f.队头出队列 g.获取队列头部元素 h.获取队列队尾元素
i.获取队列中有效元素个数
j.检测队列是否为空，如果为空返回非零结果，如果非空返回0 3.栈和队列面试题
1. 括号匹配问题。OJ链接
2. 用队列实现栈。OJ链接
3. 用栈实现队列。OJ链接
4. 设计循环队列。OJ链接
4.概念选择题
4.1题目
4.2答案
5.附录源码：
5.1栈：
Stack.h
Stack.c
5.2队列
Queue.h
Queue.c
1.栈 1.1栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈在逻辑上仍然是线性的，但是与顺序表、链表不同，栈只能在栈顶入数据，在栈底出数据，不能在任意位置进行操作，栈顶与栈底是根据功能命名的，没有严格规定首部是栈顶，尾部是栈底。
1.2栈的实现 1.2.2实现结构的选择 在数据结构之前的学习中，我们已经学习了链式与数组这两种存储的结构，栈的实现一般都可以使用数组或者链表实现。相对而言数组的结构实现更优一些。因为数组在尾上插入数据的 代价比较小。
a.数组 对于数组而言，如果我们将头部作为栈底，那么压栈出栈就需要挪动许多数据，算法复杂度为较大，因此我们一般将数组头部作为栈顶，尾部作为栈底.
b.链表 与数组不同，对于单链表而言，如果我们将链表的尾部作为栈底，我们是无法直接访问链表尾部的，同时进行压栈、出栈时，我们还需要找到尾节点的前一个节点，这样使用链表构建栈就会相当麻烦，读者读到这里，可能会认为找前一个节点麻烦，这是由于单链表结构的固有缺陷导致的，那我们直接使用双向链表，不就好了吗？确实，找前一个节点不麻烦了，但是为了解决这个问题，使用了双向链表，那么我们每个节点就多出一个需要维护的节点，空间损耗就大了，而且找尾节点还是需要遍历的，总得来说，我们花费的代价就太大了。因此将链表的尾部作为栈底并不是一个明智的选择。因此我们还是使用单链表（不带头），只不过将单链表第一个有效节点处，作为栈顶。这样我们进行压栈、出栈就方便了。
c.更优的选择 数组与链表两种结构看上去各有千秋，不过，实际上有数组去实现栈会更优一些。有的读者可能会认为如果是动态开辟数组的话，不是会有扩容上的消耗吗？同时不是还有将数据迁移到新的空间上的消耗吗？确实，如果仅看这些，按需申请的链表似乎更优一些，但是扩容调用的是系统上的资源，运行很快，并且一次扩容都是按倍扩，扩容的次数并不会很多，更重要的是数组的CPU的高速缓存更好（涉及知识点较多，这里便不展开了），因此，这里笔者主要使用数组来实现栈。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-30T07:17:24+08:00">
    <meta property="article:modified_time" content="2024-05-30T07:17:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【初阶数据结构】栈和队列（附题目）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%A0%88-toc" style="margin-left:0px;"><a href="#1.%E6%A0%88" rel="nofollow">1.栈</a></p> 
<p id="1.1%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.1%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.1栈的概念及结构</a></p> 
<p id="1.2%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#1.2%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">1.2栈的实现</a></p> 
<p id="1.2.2%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:80px;"><a href="#1.2.2%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9" rel="nofollow">1.2.2实现结构的选择</a></p> 
<p id="a.%E6%95%B0%E7%BB%84-toc" style="margin-left:120px;"><a href="#a.%E6%95%B0%E7%BB%84" rel="nofollow">a.数组</a></p> 
<p id="b.%E9%93%BE%E8%A1%A8-toc" style="margin-left:120px;"><a href="#b.%E9%93%BE%E8%A1%A8" rel="nofollow">b.链表</a></p> 
<p id="c.%E6%9B%B4%E4%BC%98%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:120px;"><a href="#c.%E6%9B%B4%E4%BC%98%E7%9A%84%E9%80%89%E6%8B%A9" rel="nofollow">c.更优的选择</a></p> 
<p id="1.2.3%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.2.3%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84" rel="nofollow">1.2.3实现结构</a></p> 
<p id="a.%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:120px;"><a href="#a.%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">a.栈的结构体</a></p> 
<p id="b.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:120px;"><a href="#b.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">b.栈的初始化</a></p> 
<p id="c.%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:120px;"><a href="#c.%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">c.栈的销毁</a></p> 
<p id="d.%E5%85%A5%E6%A0%88-toc" style="margin-left:120px;"><a href="#d.%E5%85%A5%E6%A0%88" rel="nofollow">d.入栈</a></p> 
<p id="e.%E5%87%BA%E6%A0%88%C2%A0-toc" style="margin-left:120px;"><a href="#e.%E5%87%BA%E6%A0%88%C2%A0" rel="nofollow">e.出栈 </a></p> 
<p id="f.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-toc" style="margin-left:120px;"><a href="#f.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0" rel="nofollow">f.获取栈顶元素</a></p> 
<p id="g.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%C2%A0-toc" style="margin-left:120px;"><a href="#g.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%C2%A0" rel="nofollow">g.获取栈中有效元素个数 </a></p> 
<p id="h.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0%C2%A0-toc" style="margin-left:120px;"><a href="#h.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0%C2%A0" rel="nofollow">h.检测队列是否为空，如果为空返回非零结果，如果非空返回0 </a></p> 
<p id="2.%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#2.%E9%98%9F%E5%88%97" rel="nofollow">2.队列</a></p> 
<p id="2.1%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.1%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">2.1队列的概念及结构</a></p> 
<p id="2.2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2队列的实现</a></p> 
<p id="2.2.1.%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:80px;"><a href="#2.2.1.%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9" rel="nofollow">2.2.1.实现结构的选择</a></p> 
<p id="2.2.2.%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:80px;"><a href="#2.2.2.%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9" rel="nofollow">2.2.2.实现结构的选择</a></p> 
<p id="a.%E5%8D%95%E4%B8%AA%E9%98%9F%E5%88%97%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:120px;"><a href="#a.%E5%8D%95%E4%B8%AA%E9%98%9F%E5%88%97%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">a.单个队列节点的结构体</a></p> 
<p id="b.%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:120px;"><a href="#b.%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">b.维护队列的结构体</a></p> 
<p id="c.%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:120px;"><a href="#c.%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">c.队列的初始化</a></p> 
<p id="d.%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:120px;"><a href="#d.%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">d.销毁队列 </a></p> 
<p id="e.%E9%98%9F%E5%B0%BE%E5%85%A5%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:120px;"><a href="#e.%E9%98%9F%E5%B0%BE%E5%85%A5%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">e.队尾入队列 </a></p> 
<p id="f.%E9%98%9F%E5%A4%B4%E5%87%BA%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:120px;"><a href="#f.%E9%98%9F%E5%A4%B4%E5%87%BA%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">f.队头出队列 </a></p> 
<p id="g.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0%C2%A0-toc" style="margin-left:120px;"><a href="#g.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0%C2%A0" rel="nofollow">g.获取队列头部元素 </a></p> 
<p id="h.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:120px;"><a href="#h.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0" rel="nofollow">h.获取队列队尾元素</a></p> 
<p id="i.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:120px;"><a href="#i.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow">i.获取队列中有效元素个数</a></p> 
<p id="j.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0%C2%A0-toc" style="margin-left:120px;"><a href="#j.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0%C2%A0" rel="nofollow">j.检测队列是否为空，如果为空返回非零结果，如果非空返回0 </a></p> 
<p id="3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">3.栈和队列面试题</a></p> 
<p id="1.%20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E3%80%82OJ%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#1.%20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E3%80%82OJ%E9%93%BE%E6%8E%A5" rel="nofollow">1. 括号匹配问题。OJ链接</a></p> 
<p id="2.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E3%80%82OJ%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#2.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E3%80%82OJ%E9%93%BE%E6%8E%A5" rel="nofollow">2. 用队列实现栈。OJ链接</a></p> 
<p id="3.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%82OJ%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#3.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%82OJ%E9%93%BE%E6%8E%A5" rel="nofollow">3. 用栈实现队列。OJ链接</a></p> 
<p id="4.%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E3%80%82OJ%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#4.%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E3%80%82OJ%E9%93%BE%E6%8E%A5" rel="nofollow">4. 设计循环队列。OJ链接</a></p> 
<p id="4.%E6%A6%82%E5%BF%B5%E9%80%89%E6%8B%A9%E9%A2%98-toc" style="margin-left:0px;"><a href="#4.%E6%A6%82%E5%BF%B5%E9%80%89%E6%8B%A9%E9%A2%98" rel="nofollow">4.概念选择题</a></p> 
<p id="4.1%E9%A2%98%E7%9B%AE-toc" style="margin-left:40px;"><a href="#4.1%E9%A2%98%E7%9B%AE" rel="nofollow">4.1题目</a></p> 
<p id="4.2%E7%AD%94%E6%A1%88-toc" style="margin-left:40px;"><a href="#4.2%E7%AD%94%E6%A1%88" rel="nofollow">4.2答案</a></p> 
<p id="5.%E9%99%84%E5%BD%95%E6%BA%90%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#5.%E9%99%84%E5%BD%95%E6%BA%90%E7%A0%81%EF%BC%9A" rel="nofollow">5.附录源码：</a></p> 
<p id="5.1%E6%A0%88%EF%BC%9A-toc" style="margin-left:40px;"><a href="#5.1%E6%A0%88%EF%BC%9A" rel="nofollow">5.1栈：</a></p> 
<p id="Stack.h-toc" style="margin-left:80px;"><a href="#Stack.h" rel="nofollow">Stack.h</a></p> 
<p id="Stack.c-toc" style="margin-left:80px;"><a href="#Stack.c" rel="nofollow">Stack.c</a></p> 
<p id="5.2%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#5.2%E9%98%9F%E5%88%97" rel="nofollow">5.2队列</a></p> 
<p id="Queue.h-toc" style="margin-left:80px;"><a href="#Queue.h" rel="nofollow">Queue.h</a></p> 
<p id="Queue.c-toc" style="margin-left:80px;"><a href="#Queue.c" rel="nofollow">Queue.c</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%A0%88">1.栈</h2> 
<h3 id="1.1%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.1栈的概念及结构</h3> 
<p>栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。<strong>进行数据插入和删除操作的一端称为栈顶，另一端称为栈底</strong>。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。</p> 
<p>压栈：栈的插入操作叫做进栈/压栈/入栈，<strong>入数据在栈顶</strong>。</p> 
<p>出栈：栈的删除操作叫做出栈。<strong>出数据也在栈顶。</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="370" src="https://images2.imgbox.com/7e/99/gijQREW1_o.png" width="800"></p> 
<p>栈在逻辑上仍然是线性的，但是与顺序表、链表不同，栈只能在栈顶入数据，在栈底出数据，不能在任意位置进行操作，栈顶与栈底是根据功能命名的，没有严格规定首部是栈顶，尾部是栈底。</p> 
<h3 id="1.2%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0">1.2栈的实现</h3> 
<h4 id="1.2.2%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9">1.2.2实现结构的选择</h4> 
<p>在数据结构之前的学习中，我们已经学习了链式与数组这两种存储的结构，栈的实现一般都可以使用<strong>数组或者链表实现。</strong>相对而言数组的结构实现更优一些。因为数组在尾上插入数据的 代价比较小。</p> 
<h5 id="a.%E6%95%B0%E7%BB%84"><strong>a.数组</strong></h5> 
<p></p> 
<p>对于数组而言，如果我们将头部作为栈底，那么压栈出栈就需要挪动许多数据，算法复杂度为较大，因此我们一般将数组头部作为栈顶，尾部作为栈底.</p> 
<p class="img-center"><img alt="" height="218" src="https://images2.imgbox.com/38/d5/myREN2jT_o.png" width="800"></p> 
<h5 id="b.%E9%93%BE%E8%A1%A8">b.链表</h5> 
<p>与数组不同，对于单链表而言，如果我们将链表的尾部作为栈底，我们是无法直接访问链表尾部的，同时进行压栈、出栈时，我们还需要找到尾节点的前一个节点，这样使用链表构建栈就会相当麻烦，读者读到这里，可能会认为找前一个节点麻烦，这是由于单链表结构的固有缺陷导致的，那我们直接使用双向链表，不就好了吗？确实，找前一个节点不麻烦了，但是为了解决这个问题，使用了双向链表，那么我们每个节点就多出一个需要维护的节点，空间损耗就大了，而且找尾节点还是需要遍历的，总得来说，我们花费的代价就太大了。因此将链表的尾部作为栈底并不是一个明智的选择。因此我们还是使用单链表（不带头），只不过将单链表第一个有效节点处，作为栈顶。这样我们进行压栈、出栈就方便了。</p> 
<p class="img-center"><img alt="" height="573" src="https://images2.imgbox.com/5b/13/VYWIcYWh_o.png" width="800"></p> 
<p></p> 
<h5 id="c.%E6%9B%B4%E4%BC%98%E7%9A%84%E9%80%89%E6%8B%A9">c.更优的选择</h5> 
<p>数组与链表两种结构看上去各有千秋，不过，实际上有数组去实现栈会更优一些。有的读者可能会认为如果是动态开辟数组的话，不是会有扩容上的消耗吗？同时不是还有将数据迁移到新的空间上的消耗吗？确实，如果仅看这些，按需申请的链表似乎更优一些，但是扩容调用的是系统上的资源，运行很快，并且一次扩容都是按倍扩，扩容的次数并不会很多，更重要的是数组的CPU的高速缓存更好（涉及知识点较多，这里便不展开了），因此，这里笔者主要使用数组来实现栈。</p> 
<p></p> 
<p class="img-center"><img alt="" height="874" src="https://images2.imgbox.com/f6/43/ZTdnDS48_o.png" width="800"></p> 
<h4 id="1.2.3%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84">1.2.3实现结构</h4> 
<h5 id="a.%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93">a.栈的结构体</h5> 
<p>静态的结构在实践用到的地方并不多，因此我们实现动态增长的栈。栈的结构体中,_a指向动态开辟的数组空间，_top用来指向栈顶元素或者栈顶元素的下一个位置，_capacity用来表示栈的容量</p> 
<pre><code class="language-cpp">// 支持动态增长的栈
typedef int STDataType;

typedef struct Stack
{
	STDataType* _a;
	int _top;		// 栈顶
	int _capacity;  // 容量 
}Stack;</code></pre> 
<h5 id="b.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">b.栈的初始化</h5> 
<p>栈的初始化中，需要注意的是_top的初始值初始化为-1与初始化为0是截然不同的。我们的惯性思考会认为没有数据就是0,但是_top此处并不是单纯的表示数据个数的，我们知道数组能访问到最小下表是0，如果_top是表示指向栈顶数据的，那么当_top初始化为0，表示没有数据，当数组内有一个数据时，为了表示有一个数据，我们就将_top+1吗？这样似乎浪费空间了，因此如果_top是表示指向栈顶数据，我们就将_top初始化为-1，如果_top指向栈顶数据的下一个位置，我们就将_top始化为 0，这时的_top就还可以表示表示数组元素的个数了。笔者接下来实现栈的结构，_top指向栈顶元素的下一个位置。</p> 
<pre><code class="language-cpp">// 初始化栈 
void StackInit(Stack* ps)
{
	assert(ps);

	ps-&gt;_a = NULL;

	// top指向栈顶数据的下一个位置
	ps-&gt;_top = 0;

	// top指向栈顶数据
	//ps-&gt;_top = -1;

	ps-&gt;_capacity = 0;
}</code></pre> 
<h5 id="c.%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81">c.栈的销毁</h5> 
<pre><code class="language-cpp">// 销毁栈 
void StackDestroy(Stack* ps)
{
	assert(ps);

	free(ps-&gt;_a);
	ps-&gt;_a = NULL;
	ps-&gt;_capacity = ps-&gt;_top = 0;
}</code></pre> 
<h5 id="d.%E5%85%A5%E6%A0%88">d.入栈</h5> 
<p>入栈之前，我们需要先判断数组的空间是否足够，如果不足，我们再扩容，因为_top指向的是栈顶元素的下一个数据，一次插入时的_top当前指向的位置就是要插入数据的位置。之后_top再加一。</p> 
<pre><code class="language-cpp">// 入栈 
void StackPush(Stack* ps, STDataType data)
{
	assert(ps);

	//扩容
	if(ps-&gt;_capacity == ps-&gt;_top)
	{
        //对于第一次开辟空间，先初始化4个字节空间，之后每次扩容，扩大两倍
		int newcapacity = ps-&gt;_capacity == 0 ? 4 : 2 * ps-&gt;_capacity;
		STDataType* newnode = (STDataType*)realloc(ps-&gt;_a, newcapacity * sizeof(STDataType));

		if (NULL == newnode)
		{
			perror("StackInit:realloc");
			exit(1);
		}

		ps-&gt;_a = newnode;
        //更新容量的记录值
		ps-&gt;_capacity = newcapacity;
	}

	ps-&gt;_a[ps-&gt;_top] = data;
	ps-&gt;_top++;
}
</code></pre> 
<h5 id="e.%E5%87%BA%E6%A0%88%C2%A0">e.出栈 </h5> 
<pre><code class="language-cpp">// 出栈 
void StackPop(Stack* ps)
{

	assert(ps);
	assert(ps-&gt;_top &gt; 0);

	ps-&gt;_top--;

}</code></pre> 
<h5 id="f.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0">f.获取栈顶元素</h5> 
<pre><code class="language-cpp">// 获取栈顶元素 
STDataType StackTop(Stack* ps)
{

	assert(ps);
	assert(ps-&gt;_top &gt; 0);

	return ps-&gt;_a[ps-&gt;_top - 1];
}</code></pre> 
<h5 id="g.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%C2%A0">g.获取栈中有效元素个数 </h5> 
<pre><code class="language-cpp">// 获取栈中有效元素个数 
int StackSize(Stack* ps)
{
	assert(ps);

	return ps-&gt;_top;
}</code></pre> 
<h5 id="h.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0%C2%A0">h.检测队列是否为空，如果为空返回非零结果，如果非空返回0 </h5> 
<pre><code class="language-cpp">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
bool StackEmpty(Stack* ps)
{
	assert(ps);

	return ps-&gt;_top == 0;
}</code></pre> 
<h2 id="2.%E9%98%9F%E5%88%97">2.队列</h2> 
<h3 id="2.1%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">2.1队列的概念及结构</h3> 
<p>队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾 出<strong>队列</strong>：进行删除操作的一端称为<strong>队头</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="205" src="https://images2.imgbox.com/7f/7d/Sae7E89c_o.png" width="800"></p> 
<h3 id="2.2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">2.2队列的实现</h3> 
<h4 id="2.2.1.%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9">2.2.1.实现结构的选择</h4> 
<p>队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数 组头上出数据时，就需要挪动数据，效率会比较低。</p> 
<p class="img-center"><img alt="" height="513" src="https://images2.imgbox.com/b8/14/S8s6MqpK_o.png" width="800"></p> 
<p></p> 
<h4 id="2.2.2.%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9">2.2.2.实现结构的选择</h4> 
<p>另外扩展了解一下，实际中我们有时还会使用一种队列叫循环队列。如操作系统课程讲解生产者消费者模型 时可以就会使用循环队列（涉及到许多其他知识，这里便不过多介绍）。环形队列可以使用数组实现，也可以使用循环链表实现。</p> 
<p class="img-center"><img alt="" height="518" src="https://images2.imgbox.com/a7/36/ke6BGe3H_o.png" width="800"></p> 
<p class="img-center"><img alt="" height="396" src="https://images2.imgbox.com/8d/84/J3YFSaga_o.png" width="800"></p> 
<h5 id="a.%E5%8D%95%E4%B8%AA%E9%98%9F%E5%88%97%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93">a.单个队列节点的结构体</h5> 
<pre><code class="language-cpp">typedef int QDataType;

// 链式结构：表示队列 
typedef struct QListNode
{
	struct QListNode* _next;
	QDataType _data;
}QNode;</code></pre> 
<h5 id="b.%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93">b.维护队列的结构体</h5> 
<p>与栈不同，在实现队列时，以入队列为例，我们需要传尾指针，如果要改变尾节点还要传对应的二级指针，同时如果队列现在一个节点都没有，我们还需要传对应头指针的二级指针。总得来说，各种接口的使用似乎非常不便，针对这种问题，我们专门创建一个结构体去维护头指针与尾指针。调用接口时，我们只需要传入这个结构体的指针就可以了。这样我们就可以通过访问结构体来改变对应的头尾指针。此外加上_size记录数据个数</p> 
<p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/02/3f/NhO9ChPa_o.png" width="800"></p> 
<p class="img-center"><img alt="" height="169" src="https://images2.imgbox.com/e9/a5/gz683yKk_o.png" width="800"></p> 
<pre><code class="language-cpp">// 队列的结构 
typedef struct Queue
{
	QNode* _front;
	QNode* _rear;
	int _size;
}Queue;</code></pre> 
<h5 id="c.%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">c.队列的初始化</h5> 
<p>传入专门维护的结构体初始化。</p> 
<pre><code class="language-cpp">// 初始化队列 
void QueueInit(Queue* q)
{
	q-&gt;_front = NULL;

	q-&gt;_rear = NULL;

	q-&gt;_size = 0;
}</code></pre> 
<h5 id="d.%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97%C2%A0">d.销毁队列 </h5> 
<p>循环遍历节点，挨个释放</p> 
<pre><code class="language-cpp">// 销毁队列 
void QueueDestroy(Queue* q)
{
	assert(q);

	QNode* cur = q-&gt;_front;
	while(cur)
	{
		QNode* next = cur-&gt;_next;
		free(cur);

		cur = next;
	}

	q-&gt;_front = q-&gt;_rear = NULL;
	q-&gt;_size = 0;
}</code></pre> 
<h5 id="e.%E9%98%9F%E5%B0%BE%E5%85%A5%E9%98%9F%E5%88%97%C2%A0">e.队尾入队列 </h5> 
<p>如果队列内没有节点时，在入队列时，还需要该表头结点。</p> 
<pre><code class="language-cpp">// 队尾入队列 
void QueuePush(Queue* q, QDataType data)
{
	assert(q);

	QNode* newnode = (QNode*)malloc(sizeof(QNode));

	if (NULL == newnode)
	{
		perror("QueuePush:malloc failed");
		exit(1);
	}

	newnode-&gt;_data = data;
	newnode-&gt;_next = NULL;

	if (NULL == q-&gt;_rear)
	{
		q-&gt;_front = q-&gt;_rear = newnode;
	}

	else
	{
		q-&gt;_rear-&gt;_next = newnode;
		q-&gt;_rear = newnode;
	}

	q-&gt;_size++;
}</code></pre> 
<h5 id="f.%E9%98%9F%E5%A4%B4%E5%87%BA%E9%98%9F%E5%88%97%C2%A0">f.队头出队列 </h5> 
<p>出队列之前需要判断是否队列中是否存在数据，没有数据，无法出数据。如果队列队列中只有一个数据，出完数据，还需要改变头结点。</p> 
<pre><code class="language-cpp">// 队头出队列 
void QueuePop(Queue* q)
{
	assert(q);
	assert(q-&gt;_size);

	QNode* next = q-&gt;_front-&gt;_next;
	free(q-&gt;_front);
	q-&gt;_front = next;

	if (q-&gt;_size == 1)
	{
		q-&gt;_rear = NULL;
	}

	q-&gt;_size--;

}</code></pre> 
<h5 id="g.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0%C2%A0">g.获取队列头部元素 </h5> 
<p>首先判断头指针是否为空，不为空才可以获取头部元素。</p> 
<pre><code class="language-cpp">// 获取队列头部元素 
QDataType QueueFront(Queue* q)
{
	assert(q);
	assert(q-&gt;_front);

	return q-&gt;_front-&gt;_data;
}</code></pre> 
<h5 id="h.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0">h.获取队列队尾元素</h5> 
<p>首先判断尾指针是否为空，不为空才可以获取尾部元素。</p> 
<pre><code class="language-cpp">// 获取队列队尾元素 
QDataType QueueBack(Queue* q)
{
	assert(q);
	assert(q-&gt;_rear);

	return q-&gt;_rear-&gt;_data;

}</code></pre> 
<h5 id="i.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">i.获取队列中有效元素个数</h5> 
<pre><code class="language-cpp">// 获取队列中有效元素个数 
int QueueSize(Queue* q)
{
	assert(q);

	return q-&gt;_size;
}</code></pre> 
<h5 id="j.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0%C2%A0">j.检测队列是否为空，如果为空返回非零结果，如果非空返回0 </h5> 
<pre><code class="language-cpp">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
bool QueueEmpty(Queue* q)
{
	assert(q);

	return q-&gt;_size == 0;
}
</code></pre> 
<h2 id="3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98">3.栈和队列面试题</h2> 
<h3 id="1.%20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E3%80%82OJ%E9%93%BE%E6%8E%A5">1. 括号匹配问题。<a class="link-info" href="https://leetcode.cn/problems/valid-parentheses/description/" rel="nofollow" title="OJ链接">OJ链接</a></h3> 
<p class="img-center"><img alt="" height="652" src="https://images2.imgbox.com/9a/71/zRLhg6HN_o.png" width="800"></p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/cd/d3/bntADqfA_o.png" width="800"></p> 
<p>这一道题，要求左括号与对应的右括号匹配，当取出字符串中的右括号时，需要与当前右括号的前面第一个左括号括号比对，如果是对应的左括号，则匹配成功，取下一个右括号，并且取前面第一个左括号匹配（已经匹配的左括号不再参与匹配）。我们发现我们总是需要取离右括号最近的左括号（相对其他左括号顺序靠后的元素）。匹配后，已匹配的括号不参加，下次匹配据需向“左找”。</p> 
<p>因此根据题意，我们这里可以创建栈，循环遍历字符数组，如果当前是左括号，则入栈，如果是右括号，那么这时，我们就取栈顶的元素（由于栈是后入先出栈，因此栈顶的元素就是左边离右括号最近的左括号），与右括号匹配，如果匹配则，将匹配的左括号出栈，继续循环，如果不匹配，则结束遍历。</p> 
<p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/42/52/jeRjVb9J_o.png" width="829"></p> 
<pre><code class="language-cpp">#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdio.h&gt;


// 支持动态增长的栈
typedef int STDataType;

typedef struct Stack
{
	STDataType* _a;
	int _top;		// 栈顶
	int _capacity;  // 容量 
}Stack;

// 初始化栈 
void StackInit(Stack* ps)
{
	ps-&gt;_a = NULL;
	ps-&gt;_capacity = ps-&gt;_top = 0;
}

// 入栈 
void StackPush(Stack* ps, STDataType data)
{
	assert(ps);
	if(ps-&gt;_capacity == ps-&gt;_top)
	{
		int newcapacity = ps-&gt;_capacity == 0 ? 4 : 2 * ps-&gt;_capacity;
		STDataType* newnode = (STDataType*)realloc(ps-&gt;_a, newcapacity * sizeof(STDataType));

		if (NULL == newnode)
		{
			perror("StackInit:realloc");
			exit(1);
		}
		ps-&gt;_a = newnode;
		ps-&gt;_capacity = newcapacity;
	}

	ps-&gt;_a[ps-&gt;_top] = data;
	ps-&gt;_top++;
}

// 出栈 
void StackPop(Stack* ps)
{

	assert(ps);
	assert(ps-&gt;_top &gt; 0);

	ps-&gt;_top--;

}

// 获取栈顶元素 
STDataType StackTop(Stack* ps)
{

	assert(ps);
	assert(ps-&gt;_top &gt; 0);

	return ps-&gt;_a[ps-&gt;_top - 1];
}

// 获取栈中有效元素个数 
int StackSize(Stack* ps)
{
	assert(ps);

	return ps-&gt;_top;
}

// 检测栈是否为空，如果为空返回0，如果不为空返回非零结果
bool StackEmpty(Stack* ps)
{
	assert(ps);
	return ps-&gt;_top;
}

// 销毁栈 
void StackDestroy(Stack* ps)
{
	assert(ps);
	free(ps-&gt;_a);
	ps-&gt;_a = NULL;
	ps-&gt;_capacity = ps-&gt;_top = 0;
}


bool isValid(char* s)
{
    Stack p;
    StackInit(&amp;p);
    while(*s)
    {
        if(*s == '(' || *s == '{' || *s == '[')//左括号入栈
        {
            StackPush(&amp;p,*s);
        }
        else
        {
            if(!StackEmpty(&amp;p))//右括号入栈前不能没有左括号，否则一定会出现不匹配的情况
            {
                StackDestroy(&amp;p);
                return false;
            }

            char top = 0;
            top = StackTop(&amp;p);

            if(top == '(' &amp;&amp; *s != ')'||top == '{' &amp;&amp; *s != '}'||top == '[' &amp;&amp; *s != ']')//括号不匹配返回false
            {
                StackDestroy(&amp;p);
                return false;
            }

            StackPop(&amp;p);//匹配成功，将匹配的左括号出栈
        }

        s++;//移动到下一个括号
    }

    int ret = !StackEmpty(&amp;p);//判断栈内是否为空，为空说明存在未匹配的左括号
    StackDestroy(&amp;p);
    
    return ret;
}</code></pre> 
<h3 id="2.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E3%80%82OJ%E9%93%BE%E6%8E%A5">2. 用队列实现栈。<a class="link-info" href="https://leetcode.cn/problems/implement-stack-using-queues/description/" rel="nofollow" title="OJ链接">OJ链接</a></h3> 
<p class="img-center"><img alt="" height="573" src="https://images2.imgbox.com/ab/8b/KjGcduYQ_o.png" width="800"></p> 
<p>这一题，我们需要根据队列先进先出的性质实现栈后进先出的性质，题目给了我们两个队列，因此这题就是通过将数据在两个列类之间转移来完成的，问题的关键就在于如何转移数据。</p> 
<p class="img-center"><img alt="" height="482" src="https://images2.imgbox.com/5e/d4/CYAxPvo4_o.png" width="800"></p> 
<p>如果说队列中已经有数据，为了出4，这是我们就可以将1、2、3入队列入到q2中，这时我们就可以出q1中的4，达到后进先出的效果，之后加入我们入栈5,6呢？我们又将5,6入到哪个队列中呢？</p> 
<p class="img-center"><img alt="" height="538" src="https://images2.imgbox.com/56/81/aFNqL6YO_o.png" width="500"></p> 
<p>假如们入到 q1,中，这时如果我们将5入到q2,再出6,似乎没什么问题，那么这是如果我们不出6，我们还需要继续导入数据呢？</p> 
<p class="img-center"><img alt="" height="241" src="https://images2.imgbox.com/d4/56/1G80hnIv_o.png" width="728"></p> 
<p>这是我们发现，面对两个都不为空的队列，我们再想入数据，我们必须先遍历已经存储的数据进行，判断当数据较多时，我们就会发现复杂度以及程序的逻辑性都不会太好。因此，为了避免这一混乱的情况发生，我们必须保证将数据入到不为空的队列，这样出数据将数据导到空队列中，出完数量后，就又保持两队列一空一不为空了。</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include"stdbool.h"

typedef int QDataType;

// 链式结构：表示队列 
typedef struct QListNode
{
	struct QListNode* _next;
	QDataType _data;
}QNode;

// 队列的结构 
typedef struct Queue
{
	QNode* _front;
	QNode* _rear;
	int _size;
}Queue;
void QueueInit(Queue* q)
{
	q-&gt;_front = NULL;

	q-&gt;_rear = NULL;

	q-&gt;_size = 0;
}

// 队尾入队列 
void QueuePush(Queue* q, QDataType data)
{
	assert(q);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));

	if (NULL == newnode)
	{
		perror("QueuePush:malloc failed");
		exit(1);
	}

	newnode-&gt;_data = data;
	newnode-&gt;_next = NULL;

	if (0 == q-&gt;_size)
	{
		q-&gt;_front = q-&gt;_rear = newnode;
	}
	else
	{
		q-&gt;_rear-&gt;_next = newnode;
		q-&gt;_rear = q-&gt;_rear-&gt;_next;
	}
	q-&gt;_size++;
}

// 队头出队列 
void QueuePop(Queue* q)
{
	assert(q);
	assert(q-&gt;_size);

	QNode* next = q-&gt;_front-&gt;_next;
	free(q-&gt;_front);
	q-&gt;_front = next;

	if (q-&gt;_size == 1)
	{
		q-&gt;_rear = NULL;
	}

	q-&gt;_size--;

}

// 获取队列头部元素 
QDataType QueueFront(Queue* q)
{
	assert(q);
	assert(q-&gt;_size);

	return q-&gt;_front-&gt;_data;
}

// 获取队列队尾元素 
QDataType QueueBack(Queue* q)
{
	assert(q);
	assert(q-&gt;_size);

	return q-&gt;_rear-&gt;_data;

}

// 获取队列中有效元素个数 
int QueueSize(Queue* q)
{
	assert(q);

	return q-&gt;_size;
}

// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
bool QueueEmpty(Queue* q)
{
	assert(q);

	return q-&gt;_size == 0;
}

// 销毁队列 
void QueueDestroy(Queue* q)
{
	assert(q);
    
	QNode* cur = q-&gt;_front;
	while(cur)
	{
		QNode* next = cur-&gt;_next;
		free(cur);

		cur = next;
	}

	q-&gt;_front = q-&gt;_rear = NULL;
	q-&gt;_size = 0;
}
typedef struct {
    Queue q1;
    Queue q2;
} MyStack;


MyStack* myStackCreate() {
    MyStack*pst = (MyStack*)malloc(sizeof(MyStack));
//创建模拟的栈时，只能malloc动态创建，不能静态开辟，否则出了函数，开辟空间会被收回
//也不能使用static, 否则多次调用函数，值会一直保存，会出问题。
    if(NULL == pst)
    {
        perror("malloc");
        exit(1);
    }

    QueueInit(&amp;pst-&gt;q1);
    QueueInit(&amp;pst-&gt;q2);

    return pst;
}

void myStackPush(MyStack* obj, int x) {
    if(!QueueEmpty(&amp;obj-&gt;q1))
    {
        QueuePush(&amp;obj-&gt;q1,x);
    }

    else
    {
         QueuePush(&amp;obj-&gt;q2,x);
    }
}

int myStackPop(MyStack* obj) {
    //假设法
    Queue* empty = &amp;(obj-&gt;q1);
    Queue* nonempty = &amp;(obj-&gt;q2);
    if(!QueueEmpty(&amp;(obj-&gt;q1)))
    {
        nonempty = &amp;(obj-&gt;q1);
        empty = &amp;(obj-&gt;q2);
    }

    //不为空的队列前size-1导走，删除最后一个就是栈顶数据
    while(QueueSize(nonempty) &gt; 1)
    {
        QueuePush(empty,QueueFront(nonempty));
        QueuePop(nonempty);
    }

    int top = QueueFront(nonempty);
    QueuePop(nonempty);

    return  top;
}

int myStackTop(MyStack* obj) {
    if(!QueueEmpty(&amp;(obj-&gt;q1)))
    {
       return QueueBack(&amp;(obj-&gt;q1));
    }
    else
    {
       return QueueBack(&amp;(obj-&gt;q2));
    }
}

bool myStackEmpty(MyStack* obj) {
    //两个队列都为空才是空
    return QueueEmpty(&amp;(obj-&gt;q1))&amp;&amp;QueueEmpty(&amp;(obj-&gt;q2));
}

void myStackFree(MyStack* obj) {

    QueueDestroy(&amp;(obj-&gt;q1));
    QueueDestroy(&amp;(obj-&gt;q2));

    free(obj);
}

/**
 * Your MyStack struct will be instantiated and called as such:
 * MyStack* obj = myStackCreate();
 * myStackPush(obj, x);
 
 * int param_2 = myStackPop(obj);
 
 * int param_3 = myStackTop(obj);
 
 * bool param_4 = myStackEmpty(obj);
 
 * myStackFree(obj);
*/</code></pre> 
<p class="img-center"><img alt="" height="332" src="https://images2.imgbox.com/06/93/znl2fIkt_o.png" width="800"></p> 
<p>需要注意的是最后销毁时，要先销毁队列对应的空间，在销毁存储两个队列指针的空间。</p> 
<h3 id="3.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%82OJ%E9%93%BE%E6%8E%A5">3. 用栈实现队列。<a class="link-info" href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" rel="nofollow" title="OJ链接">OJ链接</a></h3> 
<p class="img-center"><img alt="" height="534" src="https://images2.imgbox.com/d5/c6/cQ3utQD6_o.png" width="800"></p> 
<p class="img-center"><img alt="" height="812" src="https://images2.imgbox.com/f1/64/YDcTZcDD_o.png" width="984"></p> 
<p class="img-center"><img alt="" height="395" src="https://images2.imgbox.com/6b/fb/IT2ekgmr_o.png" width="800"></p> 
<p>对于这一题，如果我们沿用用队列实现栈的思路，似乎也可以，我们将先将其他数据入到另一个栈中，再留下要出栈的数据出栈。但是我们要入栈时，我们不能在入到非空的栈中，因为这样，出数据的时候，顺序就完全乱了，对此，我们可以将原数据再倒回原数据中，再向非空栈中入数据。这样就没问题了，但是这样就比较麻烦了。</p> 
<p class="img-center"><img alt="" height="361" src="https://images2.imgbox.com/46/6e/d564lZbH_o.png" width="600"></p> 
<p>根据观察，我们发现其实在将数据到到空栈是，原数据顺序会倒过来，这是我们再出栈，就直接实现了先进先出的效果。</p> 
<p class="img-center"><img alt="" height="446" src="https://images2.imgbox.com/47/e4/iYpu5J9j_o.png" width="700"></p> 
<p></p> 
<p>因此我们将两个栈分成一个专门出数据，一个专门入数据，当出数据栈popst为空，我们就将入数据栈pushst数据全部导到popst中（必须一次性将所有数据全部导入，否则顺序就乱了。）入数据时，直接往对应栈入就行了。</p> 
<p class="img-center"><img alt="" height="413" src="https://images2.imgbox.com/73/98/OCau1eqU_o.png" width="800"></p> 
<pre><code class="language-cpp">#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdio.h&gt;


// 支持动态增长的栈
typedef int STDataType;

typedef struct Stack
{
	STDataType* _a;
	int _top;		// 栈顶
	int _capacity;  // 容量 
}Stack;
// 初始化栈 
void StackInit(Stack* ps)
{
	ps-&gt;_a = NULL;
	ps-&gt;_capacity = ps-&gt;_top = 0;
}

// 入栈 
void StackPush(Stack* ps, STDataType data)
{
	assert(ps);
	if(ps-&gt;_capacity == ps-&gt;_top)
	{
		int newcapacity = ps-&gt;_capacity == 0 ? 4 : 2 * ps-&gt;_capacity;
		STDataType* newnode = (STDataType*)realloc(ps-&gt;_a, newcapacity * sizeof(STDataType));

		if (NULL == newnode)
		{
			perror("StackInit:realloc");
			exit(1);
		}
		ps-&gt;_a = newnode;
		ps-&gt;_capacity = newcapacity;
	}

	ps-&gt;_a[ps-&gt;_top] = data;
	ps-&gt;_top++;
}

// 出栈 
void StackPop(Stack* ps)
{

	assert(ps);
	assert(ps-&gt;_top &gt; 0);

	ps-&gt;_top--;

}

// 获取栈顶元素 
STDataType StackTop(Stack* ps)
{

	assert(ps);
	assert(ps-&gt;_top &gt; 0);

	return ps-&gt;_a[ps-&gt;_top - 1];
}

// 获取栈中有效元素个数 
int StackSize(Stack* ps)
{
	assert(ps);

	return ps-&gt;_top;
}

// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
bool StackEmpty(Stack* ps)
{
	assert(ps);
	return ps-&gt;_top == 0;
}

// 销毁栈 
void StackDestroy(Stack* ps)
{
	assert(ps);
	free(ps-&gt;_a);
	ps-&gt;_a = NULL;
	ps-&gt;_capacity = ps-&gt;_top = 0;
}

typedef struct {
    Stack pushst;
    Stack popst;
} MyQueue;


MyQueue* myQueueCreate() {
    MyQueue* q1 = (MyQueue*)malloc(sizeof(MyQueue));
    StackInit(&amp;q1-&gt;pushst);
    StackInit(&amp;q1-&gt;popst);
    return q1;
}

void myQueuePush(MyQueue* obj, int x) {
//实现入队列数据
    StackPush(&amp;obj-&gt;pushst,x);
}


int myQueuePeek(MyQueue* obj) {
    if(StackEmpty(&amp;obj-&gt;popst))
    {
        //倒数据
//实现出队列数据
        while(!StackEmpty(&amp;obj-&gt;pushst))//专门出数据的栈为空，就先导入一下数据
        {
            StackPush(&amp;obj-&gt;popst,StackTop(&amp;obj-&gt;pushst));
            StackPop(&amp;obj-&gt;pushst);
        }

    }

    return StackTop(&amp;obj-&gt;popst);
}

int myQueuePop(MyQueue* obj) {
//出队列队头数据
    int front = myQueuePeek(obj);
    StackPop(&amp;obj-&gt;popst);

    return front;

}

bool myQueueEmpty(MyQueue* obj) {
//两个栈都为空，队列才为空
    return StackEmpty(&amp;obj-&gt;pushst)&amp;&amp;StackEmpty(&amp;obj-&gt;popst);
}

void myQueueFree(MyQueue* obj) {
//先释放对应栈空间，再释放队列对应空间
    StackDestroy(&amp;obj-&gt;pushst);
    StackDestroy(&amp;obj-&gt;popst);
    free(obj);
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/</code></pre> 
<h3 id="4.%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E3%80%82OJ%E9%93%BE%E6%8E%A5">4. 设计循环队列。<a class="link-info" href="https://leetcode.cn/problems/design-circular-queue/description/" rel="nofollow" title="OJ链接">OJ链接</a></h3> 
<p class="img-center"><img alt="" height="530" src="https://images2.imgbox.com/ce/de/bmoD9jpX_o.png" width="800"></p> 
<p>这道题目的意思就是队列的的空间大小是固定的，这些空间可以重复使用，看到这一题的循环结构，也许有的读者会想到链表，认为链表的结构完成这一题会比数组简单，但是实际上并不是这样的，笔者这里先以数组完成这题，链表的不便后文讲解。</p> 
<p>首先假设要插入的空间K是4，这是如果我们开辟4个空间，head、tail都初始化为0，push一个数据，tail++,pop一个数据，head++，当tail、head值大于K,通过%K,实现回环，这样head == tail时，就代表数组为空的情况了，但是，我们发现如果数组满时也会出现head == tail，这就是我们说的假溢出的情况了。</p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/99/31/K0IemAFE_o.png" width="1200"></p> 
<p>为了解决这个问题，笔者有两种方法，一种是创建size专门记录数组元素个数；还有一种是多开一个空间。笔者接下来重点介绍第二种（对于这类问题一些官方解答更喜欢用第二种方法）。</p> 
<p class="img-center"><img alt="" height="565" src="https://images2.imgbox.com/18/37/sYmUiMrn_o.png" width="800"></p> 
<p>如上图，其他不变，只是我们判断数组满到条件变成了（tail+1）%(k+1) == head;这是为什么呢？我们知道，head是指向队列的头，tail指向尾的下一位，因为我们多开了一个空间，并且是按序的空出空间，因此，当数组满时，尾的空间后面就是空空间，tail指向它，这时如果tail再向前走一步，就与head相等，不过这时，为了避免出现越界的情况，tail+1需要%（K+1），这就相当于tail+1&gt;5时，tail+1-5，tail回到数组开头，同时数组越界的情况是相对与数组总长的，因此这里是%（k+1）不是%k.</p> 
<p class="img-center"><img alt="" height="396" src="https://images2.imgbox.com/96/99/t366jwZz_o.png" width="800"></p> 
<pre><code class="language-cpp">

typedef struct {//创建结构体存储需要用到的值方便维护
    int k;
    int head;
    int tail;
    int* a;
} MyCircularQueue;


MyCircularQueue* myCircularQueueCreate(int k) {//初始化结构体

   MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
   obj-&gt;a = (int*)malloc((k + 1) * sizeof(int));
   obj-&gt;head = 0;
   obj-&gt;tail = 0;
   obj-&gt;k = k;

   return obj;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {

    return obj-&gt;head == obj-&gt;tail;//head == tail为空
 
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {

   return (obj-&gt;tail + 1)%(obj-&gt;k + 1) == obj-&gt;head;//(tail + 1)%(k + 1) == head 为满

}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {

    if(myCircularQueueIsFull(obj))
    {
        return false;
    }

    else
    {
        obj-&gt;a[obj-&gt;tail] = value;
        obj-&gt;tail = (obj-&gt;tail + 1) % (obj-&gt;k + 1);//防止越界
        return true;
    }
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {

    if(myCircularQueueIsEmpty(obj))
    {
        return false;
    }

        obj-&gt;head = (obj-&gt;head + 1) % (obj-&gt;k + 1);//防止head越界
        return true;

}

int myCircularQueueFront(MyCircularQueue* obj) {

    if(myCircularQueueIsEmpty(obj))//为空取不到队头的数据
    {
        return -1;
    }
    else
    {
        return obj-&gt;a[obj-&gt;head];
    }
}

int myCircularQueueRear(MyCircularQueue* obj) {

    if(myCircularQueueIsEmpty(obj))//为空取不到队尾的数据
    {
        return -1;
    }
    else
    {
        return obj-&gt;a[(obj-&gt;tail-1 + obj-&gt;k + 1) % (obj-&gt;k + 1)];
    }
}



void myCircularQueueFree(MyCircularQueue* obj) {

    free(obj-&gt;a);
    free(obj);

}

/**
 * Your MyCircularQueue struct will be instantiated and called as such:
 * MyCircularQueue* obj = myCircularQueueCreate(k);
 * bool param_1 = myCircularQueueEnQueue(obj, value);
 
 * bool param_2 = myCircularQueueDeQueue(obj);
 
 * int param_3 = myCircularQueueFront(obj);
 
 * int param_4 = myCircularQueueRear(obj);
 
 * bool param_5 = myCircularQueueIsEmpty(obj);
 
 * bool param_6 = myCircularQueueIsFull(obj);
 
 * myCircularQueueFree(obj);
*/</code></pre> 
<p>这里需要特别注意的是，当我们取队尾的数据时，由于tail是指向队尾数据的下一位，因此如果tail在数组头，tail-1取队尾就会出现负数的情况，因此与（tail+1）%(k+1)类似，我们要将（tail+1 +k+1）%(k+1)，这样就可以避免出现，负数的情况，如果tail不在队头这样处理也不会有问题。</p> 
<p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/78/9b/FVVWZmqV_o.png" width="400"></p> 
<p class="img-center"><img alt="" height="363" src="https://images2.imgbox.com/43/7f/p7eBCipW_o.png" width="800"></p> 
<p>那么回到一开始的问题，为什么笔者说，使用链表不像看上去那样简单呢？首先，用链表形成循环队列，不像数组那样直接申请一块空间方便，其次由于tail是指向尾的下一个位置，因此我们如果想要找尾会很麻烦，对此可以使用双向链表、遍历寻找尾、专门创建变量记录tail前一个节点，总的来说，使用链表不光没有什么实质的好处，反而还会有不少麻烦。当然，如果读者想要用链表完成，也不无不可。</p> 
<p class="img-center"><img alt="" height="264" src="https://images2.imgbox.com/4d/73/PmR1oR7v_o.png" width="600"></p> 
<h2 id="4.%E6%A6%82%E5%BF%B5%E9%80%89%E6%8B%A9%E9%A2%98">4.概念选择题</h2> 
<h3 id="4.1%E9%A2%98%E7%9B%AE">4.1题目</h3> 
<blockquote> 
 <p>1.一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出栈的顺序是（ ）。</p> 
 <p>A 12345ABCDE</p> 
 <p>B EDCBA54321</p> 
 <p>C ABCDE12345</p> 
 <p>D 54321EDCBA</p> 
 <p></p> 
 <p>2.若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）</p> 
 <p>A 1,4,3,2</p> 
 <p>B 2,3,4,1</p> 
 <p>C 3,1,4,2</p> 
 <p>D 3,4,2,1</p> 
 <p></p> 
 <p>3.循环队列的存储空间为 Q(1:100) ，初始状态为 front=rear=100 。经过一系列正常的入队与退队操作 后， front=rear=99 ，则循环队列中的元素个数为（ ）</p> 
 <p>A 1</p> 
 <p>B 2</p> 
 <p>C 99</p> 
 <p>D 0或者100</p> 
 <p></p> 
 <p>4.以下( )不是队列的基本运算？</p> 
 <p>A 从队尾插入一个新元素</p> 
 <p>B 从队列中删除第i个元素</p> 
 <p>C 判断一个队列是否为空</p> 
 <p>D 读取队头元素的值</p> 
 <p></p> 
 <p>5.现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为？(假设 队头不存放数据)</p> 
 <p>A (rear - front + N) % N + 1</p> 
 <p>B (rear - front + N) % N</p> 
 <p>C ear - front) % (N + 1)</p> 
 <p>D (rear - front + N) % (N - 1)</p> 
</blockquote> 
<h3 id="4.2%E7%AD%94%E6%A1%88">4.2答案</h3> 
<blockquote> 
 <p>1.B  //依次入栈，入完再出栈，后入先出</p> 
 <p>2.C  //不可能出现2不出，就出到1</p> 
 <p>3.D  //属于没有多开一个空间的方法，相等时可能为空，可能满。</p> 
 <p>4.B</p> 
 <p>5.B</p> 
</blockquote> 
<h2 id="5.%E9%99%84%E5%BD%95%E6%BA%90%E7%A0%81%EF%BC%9A">5.附录源码：</h2> 
<h3 id="5.1%E6%A0%88%EF%BC%9A">5.1栈：</h3> 
<h4 id="Stack.h">Stack.h</h4> 
<pre><code class="language-cpp">#pragma once
#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdio.h&gt;


// 支持动态增长的栈
typedef int STDataType;

typedef struct Stack
{
	STDataType* _a;
	int _top;		// 栈顶
	int _capacity;  // 容量 
}Stack;

// 初始化栈 
void StackInit(Stack* ps);

// 入栈 
void StackPush(Stack* ps, STDataType data);

// 出栈 
void StackPop(Stack* ps);

// 获取栈顶元素 
STDataType StackTop(Stack* ps);

// 获取栈中有效元素个数 
int StackSize(Stack* ps);

// 检测栈是否为空，如果为空返回0 ，如果不为空返回非零结果
bool StackEmpty(Stack* ps);

// 销毁栈 
void StackDestroy(Stack* ps);
</code></pre> 
<h4 id="Stack.c">Stack.c</h4> 
<pre><code class="language-cpp">#include"Stack.h"

// 初始化栈 
void StackInit(Stack* ps)
{
	assert(ps);

	ps-&gt;_a = NULL;

	// top指向栈顶数据的下一个位置
	ps-&gt;_top = 0;

	// top指向栈顶数据
	//ps-&gt;_top = -1;

	ps-&gt;_capacity = 0;
}

// 入栈 
void StackPush(Stack* ps, STDataType data)
{
	assert(ps);

	//扩容
	if(ps-&gt;_capacity == ps-&gt;_top)
	{
		int newcapacity = ps-&gt;_capacity == 0 ? 4 : 2 * ps-&gt;_capacity;
		STDataType* newnode = (STDataType*)realloc(ps-&gt;_a, newcapacity * sizeof(STDataType));

		if (NULL == newnode)
		{
			perror("StackInit:realloc");
			exit(1);
		}

		ps-&gt;_a = newnode;
		ps-&gt;_capacity = newcapacity;
	}

	ps-&gt;_a[ps-&gt;_top] = data;
	ps-&gt;_top++;
}

// 出栈 
void StackPop(Stack* ps)
{

	assert(ps);
	assert(ps-&gt;_top &gt; 0);

	ps-&gt;_top--;

}

// 获取栈顶元素 
STDataType StackTop(Stack* ps)
{

	assert(ps);
	assert(ps-&gt;_top &gt; 0);

	return ps-&gt;_a[ps-&gt;_top - 1];
}

// 获取栈中有效元素个数 
int StackSize(Stack* ps)
{
	assert(ps);

	return ps-&gt;_top;
}

// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
bool StackEmpty(Stack* ps)
{
	assert(ps);

	return ps-&gt;_top == 0;
}

// 销毁栈 
void StackDestroy(Stack* ps)
{
	assert(ps);

	free(ps-&gt;_a);
	ps-&gt;_a = NULL;
	ps-&gt;_capacity = ps-&gt;_top = 0;
}
</code></pre> 
<h3 id="5.2%E9%98%9F%E5%88%97">5.2队列</h3> 
<h4 id="Queue.h">Queue.h</h4> 
<pre><code class="language-cpp">#pragma once
#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include"stdbool.h"

typedef int QDataType;

// 链式结构：表示队列 
typedef struct QListNode
{
	struct QListNode* _next;
	QDataType _data;
}QNode;

// 队列的结构 
typedef struct Queue
{
	QNode* _front;
	QNode* _rear;
	int _size;
}Queue;

// 初始化队列 
void QueueInit(Queue* q);

// 队尾入队列 
void QueuePush(Queue* q, QDataType data);

// 队头出队列 
void QueuePop(Queue* q);

// 获取队列头部元素 
QDataType QueueFront(Queue* q);

// 获取队列队尾元素 
QDataType QueueBack(Queue* q);

// 获取队列中有效元素个数 
int QueueSize(Queue* q);

// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
bool QueueEmpty(Queue* q);

// 销毁队列 
void QueueDestroy(Queue* q);
</code></pre> 
<h4 id="Queue.c">Queue.c</h4> 
<pre><code class="language-cpp">#include"queue.h"


// 初始化队列 
void QueueInit(Queue* q)
{
	q-&gt;_front = NULL;

	q-&gt;_rear = NULL;

	q-&gt;_size = 0;
}

// 队尾入队列 
void QueuePush(Queue* q, QDataType data)
{
	assert(q);

	QNode* newnode = (QNode*)malloc(sizeof(QNode));

	if (NULL == newnode)
	{
		perror("QueuePush:malloc failed");
		exit(1);
	}

	newnode-&gt;_data = data;
	newnode-&gt;_next = NULL;

	if (NULL == q-&gt;_rear)
	{
		q-&gt;_front = q-&gt;_rear = newnode;
	}

	else
	{
		q-&gt;_rear-&gt;_next = newnode;
		q-&gt;_rear = newnode;
	}

	q-&gt;_size++;
}

// 队头出队列 
void QueuePop(Queue* q)
{
	assert(q);
	assert(q-&gt;_size);

	QNode* next = q-&gt;_front-&gt;_next;
	free(q-&gt;_front);
	q-&gt;_front = next;

	if (q-&gt;_size == 1)
	{
		q-&gt;_rear = NULL;
	}

	q-&gt;_size--;

}

// 获取队列头部元素 
QDataType QueueFront(Queue* q)
{
	assert(q);
	assert(q-&gt;_front);

	return q-&gt;_front-&gt;_data;
}

// 获取队列队尾元素 
QDataType QueueBack(Queue* q)
{
	assert(q);
	assert(q-&gt;_rear);

	return q-&gt;_rear-&gt;_data;

}

// 获取队列中有效元素个数 
int QueueSize(Queue* q)
{
	assert(q);

	return q-&gt;_size;
}

// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
bool QueueEmpty(Queue* q)
{
	assert(q);

	return q-&gt;_size == 0;
}

// 销毁队列 
void QueueDestroy(Queue* q)
{
	assert(q);

	QNode* cur = q-&gt;_front;
	while(cur)
	{
		QNode* next = cur-&gt;_next;
		free(cur);

		cur = next;
	}

	q-&gt;_front = q-&gt;_rear = NULL;
	q-&gt;_size = 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe020409b156bbcb621ae2168c5db36f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flink系列一：flink光速入门 (^_^)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/106b30d0de75fd6b6c7821016a69e8d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI大模型探索之路-实战篇11： Function Calling技术整合：强化Agent智能数据分析平台功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>