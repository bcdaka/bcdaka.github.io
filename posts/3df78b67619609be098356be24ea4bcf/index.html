<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大数据最新【数据结构】八大排序算法详解_数据结构排序算法(2)，2024年最新教你如何增加拿到BAT大厂offer几率 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3df78b67619609be098356be24ea4bcf/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="大数据最新【数据结构】八大排序算法详解_数据结构排序算法(2)，2024年最新教你如何增加拿到BAT大厂offer几率">
  <meta property="og:description" content="网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化资料的朋友，可以戳这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
}
**注意：** 该算法在具体实现时并不是先对一个子序列完成所有插入排序操作，再对另一个子序列进行，而是从第一个子序列的第二个元素开始顺序扫描整个待排序序列，当前待排序元素属于哪一个子序列，就在它相应的的子序列中进行排序。因而各个子序列地元素将会轮流出现，即算法将在每一个子序列中轮流进行插入排序。 **希尔排序总结：** &gt; &gt; 在希尔排序开始时增量（gap）较大，分组越多，每组的元素越少，因此各组内直接插入较快。后来增量逐渐缩小，分组数逐渐减少，每组内的元素个数越多，直接插入越慢，但是越接近有序。 &gt; 时间复杂度在O(nlogn) ~ O(n^2) 之间，最好时间复杂度为O(n^1.3)， 最坏时间复杂度为O(n^2)。 &gt; 空间复杂度为O(1)。 &gt; 希尔排序是一种不稳定的排序算法。 &gt; &gt; &gt; ### 2. 选择类排序 选择类排序的基本思想是，在第 i 趟的序列中选择第 i 小的元素作为有序序列的第 i 个元素。该算法的关键就在于，如何从剩余的待排序序列中找出最小或最大的元素。 #### 2.1 简单选择排序 **动图演示：** ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210509190545640.gif#pic_center) &gt; &gt; 基本思路：从第一个元素开始，从头向尾遍历，标记序列中最小的元素，待所有元素对比完之后与第一个元素交换；然后继续从第二个元素开始继续比较，直到完成最后只有两个元素的交换。 &gt; &gt; &gt; **代码实现：** void SelectSort(int* array, int sz)
{
for (int i = 0; i &lt; sz- 1; &#43;&#43;i)
{
// 找当前区间中最大元素的位置
int maxPos = 0;
for (int j = 1; j &lt; sz- i; &#43;&#43;j)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-12T00:15:55+08:00">
    <meta property="article:modified_time" content="2024-05-12T00:15:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大数据最新【数据结构】八大排序算法详解_数据结构排序算法(2)，2024年最新教你如何增加拿到BAT大厂offer几率</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/7a/16/tcywpm1i_o.png" alt="img"><br> <img src="https://images2.imgbox.com/8a/13/ndPrURKY_o.png" alt="img"></p> 
<p><strong>网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。</strong></p> 
<p><strong><a href="https://bbs.csdn.net/forums/4f45ff00ff254613a03fab5e56a57acb">需要这份系统化资料的朋友，可以戳这里获取</a></strong></p> 
<p><strong>一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！</strong></p> 
<p>}</p> 
<pre><code>
**注意：** 该算法在具体实现时并不是先对一个子序列完成所有插入排序操作，再对另一个子序列进行，而是从第一个子序列的第二个元素开始顺序扫描整个待排序序列，当前待排序元素属于哪一个子序列，就在它相应的的子序列中进行排序。因而各个子序列地元素将会轮流出现，即算法将在每一个子序列中轮流进行插入排序。


**希尔排序总结：**



&gt; 
&gt;  在希尔排序开始时增量（gap）较大，分组越多，每组的元素越少，因此各组内直接插入较快。后来增量逐渐缩小，分组数逐渐减少，每组内的元素个数越多，直接插入越慢，但是越接近有序。  
&gt;   时间复杂度在O(nlogn) ~ O(n^2) 之间，最好时间复杂度为O(n^1.3)， 最坏时间复杂度为O(n^2)。  
&gt;   空间复杂度为O(1)。  
&gt;   希尔排序是一种不稳定的排序算法。
&gt; 
&gt; 
&gt; 


### 2. 选择类排序


  选择类排序的基本思想是，在第 i 趟的序列中选择第 i 小的元素作为有序序列的第 i 个元素。该算法的关键就在于，如何从剩余的待排序序列中找出最小或最大的元素。


#### 2.1 简单选择排序


**动图演示：**


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210509190545640.gif#pic_center)



&gt; 
&gt; 基本思路：从第一个元素开始，从头向尾遍历，标记序列中最小的元素，待所有元素对比完之后与第一个元素交换；然后继续从第二个元素开始继续比较，直到完成最后只有两个元素的交换。
&gt; 
&gt; 
&gt; 


**代码实现：**



</code></pre> 
<p>void SelectSort(int* array, int sz)<br> {<!-- --><br> for (int i = 0; i &lt; sz- 1; ++i)<br> {<!-- --><br> // 找当前区间中最大元素的位置<br> int maxPos = 0;<br> for (int j = 1; j &lt; sz- i; ++j)<br> {<!-- --><br> if (array[j] &gt; array[maxPos])<br> maxPos = j;<br> }<br> //加一层判断，若最大元素就在待排序序列的末尾就无需交换<br> if (maxPos != sz- i - 1)<br> {<!-- --><br> Swap(&amp;array[maxPos], &amp;array[sz- i - 1]);<br> }<br> }<br> }</p> 
<pre><code>
  上面的代码在每一次遍历过程将最大值找到并将其放在待排序序列末尾，其实还可以对其进行优化，就是再一次的遍历过程中既找到最大值也找到最小值，并将这两个值放在合适的位置上。


**简单选择排序代码优化：**



</code></pre> 
<p>void SelectSortOP(int* array, int sz)<br> {<!-- --><br> int begin = 0, end = sz- 1; // [begin, end]<br> while (begin &lt; end)<br> {<!-- --><br> // 在[begin, end]区间中找最大和最小的元素<br> int maxPos = begin, minPos = begin;<br> int j = begin + 1;</p> 
<pre><code>	while (j &lt;= end)
	{
		if (array[j] &gt; array[maxPos])
			maxPos = j;

		if (array[j] &lt; array[minPos])
			minPos = j;

		++j;
	}

	// 如果最大元素不在区间最后的位置
	if (maxPos != end)
		Swap(&amp;array[maxPos], &amp;array[end]);

	// 如果end位置存储的刚好是最小的元素，上面的交换就将最小的元素位置更改了---maxPos
	// 最小元素的位置发生了改变，则必须要更新minPos
	if (minPos == end)
		minPos = maxPos;

	// 如果最小元素不在区间起始的位置
	if (minPos != begin)
		Swap(&amp;array[minPos], &amp;array[begin]);

	++begin;
	--end;
}
</code></pre> 
<p>}</p> 
<pre><code>
**注意：** 对简单选择排序的优化代码，一定要注意待排序序列的末尾刚好存放的最小元素，或者首部存放的是最大元素，在发生交换时就会出现错误。假设说末位存放着最小元素，当你先将最大元素交换到末位，此时最大元素已经就位，然后要将最小元素放在首位，可是最小元素的标记指向着末位，当你再完成最小元素的交换时就会发现把刚换过来的最大元素交换到了前面。所以说，一定要注意最大元素或最小元素标记的改变。


**简单选择排序总结：**



&gt; 
&gt; 简单选择排序很容易理解，但是它的效率实在太低，很少使用。  
&gt;  时间复杂度为O(n^2)  
&gt;  空间复杂度为O(1)  
&gt;  简单选择排序是不稳定的
&gt; 
&gt; 
&gt; 


#### 2.2 堆排序


  堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是排升序要建大堆，排降序建小堆。


**想要完成堆排序，首先要通过向下调整算法将二叉树这样的数据结构建成一个堆，然后再利用堆删除的思想完成排序。**


#### 2.2.1 堆向下调整算法


  假若现在给你一个数组，逻辑上看做一颗完全二叉树。我们通过从根节点开始的向下调整算法可以把它调整成一个小堆。**向下调整算法有一个前提：左右子树必须是一个堆，才能调整**。



</code></pre> 
<p>int array[] = {27,15,19,18,28,34,65,49,25,37};</p> 
<pre><code>
![在这里插入图片描述](https://img-blog.csdnimg.cn/4594adb5bbfb48d6b2eae65c63758a39.png)



</code></pre> 
<p>void Swap(HPDataType* left, HPDataType* right)<br> {<!-- --><br> HPDataType temp = *left;<br> *left = *right;<br> *right = temp;<br> }<br> void AdjustDown(Heap* hp,int n,int parent)<br> {<!-- --><br> int child = parent * 2 + 1; //调整结点的左孩子<br> while (child &lt; n) //当child大于结点个数时调整完毕<br> {<!-- --><br> //判断是否有右孩子并且右孩子大于左孩子<br> if (child + 1 &lt; n&amp;&amp;hp-&gt;array[child] &lt; hp-&gt;array[child + 1])<br> {<!-- --><br> child += 1;<br> }<br> if (hp-&gt;array[child]&gt;hp-&gt;array[parent])<br> {<!-- --><br> Swap(&amp;hp-&gt;array[child], &amp;hp-&gt;array[parent]); //若孩子大于父亲则交换<br> //继续向下调整继续判断<br> parent = child;<br> child = parent * 2 + 1;<br> }<br> else<br> {<!-- --><br> return;<br> }<br> }<br> }</p> 
<pre><code>
#### 2.2.2 堆排序


  在堆建立完毕之后，利用堆删除思想来进行排序，建堆和堆删除中都用到了向下调整，因此掌握了向下调整，就可以完成堆排序。


  **思路：** 1）完成建堆，让其拥有父亲结点大于孩子结点的特性（或者父亲结点小于孩子结点）  
       2）交换根结点与最后一个孩子结点，那么此时最大的结点就来到了堆的最后一位，将堆的元素个数减一，然后在从根结点（刚交换上去的结点）完成向下调整算法。《**注意：** 堆的顺序结构是用数组实现的，所以说将堆元素个数减一并不是将其删除，而是将其放在了数组的最后一个位置》  
       3）一直持续到最后两个结点将其完成交换即可完成堆排序。



</code></pre> 
<p>void Swap(HPDataType* left, HPDataType* right)<br> {<!-- --><br> HPDataType temp = *left;<br> *left = *right;<br> *right = temp;<br> }<br> void AdjustDown(int* array, int root, int sz)<br> {<!-- --><br> // 用child标记parent较大的孩子，默认先标记parent的左孩子<br> // 先标记左孩子的原因是：如果parent有孩子，parent一定是先有左孩子，然后才有右孩子<br> int parent = root;<br> int child = parent * 2 + 1;<br> while (child &lt; sz)<br> {<!-- --><br> // 找parent中较大的孩子：用parent左右孩子比较<br> // 必须先保证parent的右孩子存在<br> if (child + 1 &lt; sz &amp;&amp; array[child + 1] &gt; array[child])<br> {<!-- --><br> child += 1;<br> }<br> // 检测parent是否满足堆的性质<br> if (array[parent] &lt; array[child])<br> {<!-- --><br> Swap(&amp;array[parent], &amp;array[child]);<br> parent = child;<br> child = parent * 2 + 1;<br> }<br> else<br> {<!-- --><br> break;<br> }<br> }</p> 
<p>}</p> 
<p>void HeapSort(int* array, int sz)<br> {<!-- --><br> int root = sz - 2 / 2;<br> // 1. 建堆<br> // 注意从倒数第一个非叶子节点的位置开始使用堆调整，一直调整到根节点的位置<br> for (int i = root; i &gt;= 0; --i)<br> {<!-- --><br> AdjustDown(array, i, sz);<br> }<br> // 2. 排序—&gt;利用堆删除的思想进行排序<br> for (int i = sz - 1; i &gt; 0; --i)<br> {<!-- --><br> Swap(&amp;array[0], &amp;array[i]);<br> AdjustDown(array, 0, i);<br> }<br> }</p> 
<pre><code>
**堆排序的时间代价主要花费在建堆和排序上；**


**建堆的时间复杂度：**  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/66791488d193457280114cec4308e547.png)  
 因此：建堆的时间复杂度为O(n)。


**排序的时间复杂度：**  
   首先要明白的是建好堆之后，然后通过堆删除的思想来排序。而堆删除的思路是怎样？先将根结点与最后一个结点交换，然后把根结点放在数组地末位，然后数组元素减一，再将刚换上去地结点去执行向下调整算法，直到将所有地元素都交换完毕。我们发现对于每一个元素都要执行一次向下调整算法，而向下调整算法向下走的是单支树，所以**向下调整算法的时间复杂度为O(logn)，那么对于n个节点来说，完成整个排序的时间复杂度就为O(nlogn)。**



&gt; 
&gt; 所以，堆排序的时间复杂度为O(n)+O(nlogn)，因为大O的渐进表示法的表示，**堆排序的时间复杂度为O(nlogn)**  
&gt;  空间复杂度为O(1)  
&gt;  堆排序是一种不稳定的排序算法。
&gt; 
&gt; 
&gt; 


### 3. 交换类排序


  交换类排序算法的基本思想为，将待排序序列的元素两两比较，只要发现逆序就进行交换，知道没有逆序为止。如果要将整个序列调整为递增序列，那么元素之间是递减关系就为逆序。冒泡排序和快速排序就是典型的交换类排序算法。


#### 3.1 冒泡排序


**动图演示：**


![在这里插入图片描述](https://img-blog.csdnimg.cn/a5e3abf018e74af8a5c3ac1891fb393a.gif#pic_center)  
   冒泡排序也叫做“相邻比逆法”，即在扫描待排序记录序列时顺次比较相邻两个元素大小，如果逆序就交换位置。如果以将序列调整成升序为例，则逆序为两个关键字是降序序列。


  具体地，各趟排序过程如下：



&gt; 
&gt;  第1趟比较第1和第2个元素，如果逆序就交换，再依次比较第2个和第3个元素、第3个和第 4 个…若是逆序则交換。经过该趟比较和交换，最大的数必然“沉到”最后一个位置。  
&gt;   第2趟用同样的方法，在前面的 n-1 个元素中依次进行比较和交换，第2大的数“沉到”倒数第2个位置上。  
&gt;   第 i 趟仍用同样方法，在剩下的 n-i+1 个元素中依次进行比较和交换，第 i 大的数“沉到”倒数第 i 个位置上。  
&gt;   重复此过程，直到 i=n-1最后一趟比较完为止。
&gt; 
&gt; 
&gt; 


**代码实现：**



</code></pre> 
<p>void BubbleSort(int* array, int sz)<br> {<!-- --><br> // 控制冒泡的趟数<br> for (int i = 0; i &lt; sz- 1; ++i) // -1的目的是可以少冒一趟，因为最后一次冒泡区间中只剩余一个元素<br> {<!-- --><br> // 具体冒泡的方式：用相邻位置的元素进行比较，如果不满足条件，就进行交换<br> // j：表示后一个元素的下标，j要取到最后一个元素<br> for (int j = 1; j &lt; sz- i; ++j) // -1目的：j最多只能取到冒泡区间的倒数第二个元素<br> {<!-- --><br> if (array[j-1] &gt; array[j])<br> Swap(&amp;array[j], &amp;array[j - 1]);<br> }<br> }<br> }</p> 
<pre><code>
  同样我们可以对上面的代码进行优化，优化的点在哪呢？就是万一在排序的过程中序列已经顺序了，那就没有必要再冒泡下去了，此时我们便设置一个标记 flag ，每次冒泡前将其设置为0，若在一趟冒泡中发生了元素交换，就说明元素并没有顺序，便将其改为1，若在一趟冒泡中没有发生任何元素的交换，就说明该序列顺序，那么 flag 就不会被更改，然后就直接退出最外层的循环，完成了冒泡排序。



</code></pre> 
<p>void BubbleSortOP(int* array, int sz)<br> {<!-- --><br> int flag = 0;<br> for (int i = 0; i &lt; sz- 1; ++i) // -1的目的是可以少冒一趟，因为最后一次冒泡区间中只剩余一个元素<br> {<!-- --><br> flag = 0; // 该趟冒泡还没有比较，因此将falg设置为0<br> for (int j = 1; j &lt; sz- i; ++j) // -1目的：j最多只能取到冒泡区间的倒数第二个元素<br> {<!-- --><br> if (array[j - 1] &gt; array[j])<br> {<!-- --><br> Swap(&amp;array[j], &amp;array[j - 1]);<br> flag = 1; // 在该趟冒泡时区间还无序<br> }<br> }<br> if (!flag)<br> return;<br> }<br> }</p> 
<pre><code>
**冒泡排序总结：**



&gt; 
&gt;  冒泡排序在最好的情况下是序列为顺序，那么外层循环只进行一次就结束整个排序过程，最好的时间复杂度位O(n)，但在最差的情况下外层循环最多进行 n-1 次，每一次外层控制的内层循环进行 n-i 次，最坏的时间复杂度为O(n^2)  
&gt;   空间复杂度：O(1)  
&gt;   冒泡排序是一种不稳定的排序算法。
&gt; 
&gt; 
&gt; 


#### 3.2 快速排序


  快速排序是一种应用非常广泛的排序算法，从它的名字就可以看出它的排序效率是比较高的。在1962年Hoare提出了一种划分交换排序，由于它几乎最快的排序算法，所以就被称为“快速排序”。



&gt; 
&gt;   快速排序采用了一种分治的策略，分治法的基本思想是将原问题分解为若干个规模更小的问题但结构与原问题相似的子问题，递归的解这些子问题，然后将这些子问题的解组合称为原问题的解。  
&gt;    基于这样的思想，快速排序的基本思想为：**取待排序元素序列中的某一元素作为基准值（我们假设取最左边的值为基准值），按照该基准值将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后在左右子序列重复该过程，直到所有元素都排列在相应位置上为止。可以看出快速排序的遍历规则与二叉树的前序遍历非常类似的**。
&gt; 
&gt; 
&gt; 


  接下来将从以下几个方面来对快排做一个详细介绍：  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/cb69c6c832bb40d79b2375d885ff3e61.png#pic_center)


##### 3.2.1 hoare版本


**动图演示：**  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515134431451.gif#pic_center#pic_center)



&gt; 
&gt;   基本思想：选择待排序序列最左边的元素为基准值key，左右标记分别指向序列的第一个元素和最后一个元素，先让右标记往左走，当找到比key小的数字停下来，然后再让左标记往右走，当找到比key大的数字停下来，交换左右标记对应的数字，然后继续这样的操作，直到左右标记指向同一个元素（左右标记相遇），然后再交换基准值key和左右标记指向的元素。  
&gt;    这样快排的一轮排序就完成了，可以看到**每当完成一轮排序总会有一个元素落位到它该在的位置**。
&gt; 
&gt; 
&gt; 


**代码实现：**



</code></pre> 
<p>void swap(int* left, int* right)<br> {<!-- --><br> int temp = *left;<br> *left = *right;<br> *right = temp;<br> }<br> int Partion(int* array, int begin, int end)<br> {<!-- --><br> int left = begin;<br> int left = end;<br> int keyi = left;//基准值<br> while (left &lt; right)<br> {<!-- --><br> //右标记向左走，直到找到小于key的元素就停下<br> while (left &lt; right&amp;&amp;array[right] &gt;= array[keyi])<br> {<!-- --><br> –right;<br> }<br> //左标记向右走，直到找到大于key的元素就停下<br> while (left &lt; right&amp;&amp;array[left] &lt;= array[keyi])<br> {<!-- --><br> ++left;<br> }<br> swap(&amp;array[left], &amp;array[right]);<br> }<br> //交换基准值key和左右标记指向的元素<br> //加判断的原因在于key右边的元素都比它小，所以就没有必要进行交换操作<br> if (end != left)<br> {<!-- --><br> swap(&amp;array[left], &amp;array[keyi]);<br> }<br> //返回已经被放好元素的位置，也就是key最终所在的位置<br> return begin;<br> }<br> void quicksort(int* array, int left, int right)<br> {<!-- --><br> //排序的终止条件（左右标记指向同一个元素，也就是待排序序列只有一个元素）<br> if (left &gt;= right)<br> {<!-- --><br> return;<br> }<br> int div = Partion(array, left, right);<br> //排序刚放好位置元素的左半边<br> quicksort(array, left, div - 1);<br> //排序刚放好位置元素的右半边<br> quicksort(array, div + 1, right);<br> }</p> 
<pre><code>
##### 3.2.2 挖坑法


**动图演示：**  
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515183213169.gif#pic_center#pic_center)



&gt; 
&gt;   基本思想：同样选择序列的最左边值为基准值，左右标记分别指向序列的第一个元素和最后一个元素，那个坑位就是key所在的位置，先让右标记向左走，当找到比key小的元素停下，然后将该元素放置到那个坑位，此时就有了一个新坑位，而刚才的坑位就被填补了，然后再让左标记向右走，当找到比key大的元素停下，然后将该元素放置到新坑位，直到左右标记共同指向一个位置，也就是指向了一个坑位，然后再把基准值放到那个坑位就结束了一次排序过程。  
&gt;    和hoare版本一样，**每当完成一轮排序总会有一个元素落位到它该在的位置**。
&gt; 
&gt; 
&gt; 


**代码实现：**



</code></pre> 
<p>int Partion(int* array, int begin, int end)<br> {<!-- --><br> int left = begin, right = end;<br> int key = array[begin];<br> while (left &lt; right)<br> {<!-- --><br> while (left &lt; right &amp;&amp; array[right] &gt;= key)<br> {<!-- --><br> –right;<br> }<br> if (left != right)<br> {<!-- --><br> array[left] = array[right];<br> }<br> while (left &lt; right &amp;&amp; array[left] &lt;= key)<br> {<!-- --><br> ++left;<br> }<br> if (left != right)<br> {<!-- --><br> array[right] = array[left];<br> }<br> }<br> array[left] = key;<br> return left;<br> }<br> void quicksort(int* array, int left, int right)<br> {<!-- --><br> if (left &gt;= right)<br> {<!-- --><br> return;<br> }<br> int div = Partion(array, left, right);<br> quicksort(array, left, div - 1);<br> quicksort(array, div + 1, right);<br> }</p> 
<pre><code>
##### 3.2.3 双指针（前后指针）


**动图演示：**


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515172409754.gif#pic_center#pic_center)



&gt; 
&gt;   基本思想：同样选择序列的最左边值为基准值，cur指向第二个元素，prev指向第一个元素，。cur先向右移动，当遇到比key小的元素停下来，然后再与prev的下一个元素交换。一直持续这样的操作，直到cur将所有元素都遍历完，然后再将prev指向的元素与key交换。这样该序列也就被分为两块。在这过程中可以发现，cur和prev中间的元素都是比key大的元素。
&gt; 
&gt; 
&gt; 


**代码实现：**



</code></pre> 
<p>int Partion(int* array, int begin, int end)<br> {<!-- --><br> int key = array[begin];<br> int cur = begin+ 1, prev = begin;<br> while (cur &lt;= end)<br> {<!-- --><br> if (array[cur] &lt; key &amp;&amp; ++prev != cur)<br> {<!-- --><br> Swap(&amp;array[cur], &amp;array[prev]);<br> }<br> ++cur;<br> }<br> Swap(&amp;array[prev], &amp;array[begin]);<br> return prev;<br> }<br> void quicksort(int* array, int left, int right)<br> {<!-- --><br> if (left &gt;= right)<br> {<!-- --><br> return;<br> }<br> int div = Partion(array, left, right);<br> quicksort(array, left, div - 1);<br> quicksort(array, div + 1, right);<br> }</p> 
<pre><code>
##### 3.2.4 栈实现 （非递归）



&gt; 
&gt;   上面三种快速排序算法都是以递归的方法实现的，下面这个方法借用栈来实现非递归的排序算法。  
&gt;    第一步：将序列的左右标记分别入栈，然后进入循环（判断条件为栈是否为空），再将左右标记出栈；  
&gt;    第二步：利用刚出栈的这两个参数（左右标记）使用排序算法 `Partion(array, left, right)`，以key为基准，将序列分割称为两部分，左边比key小，右边比key大，然后返回key所在的位置；  
&gt;    第三步：现在就有两个待排序的序列，它们之间隔着一个刚落好位置的key，将这两部分序列的左右标记分别入栈，要做到与快排同样的基本思想（前序遍历），我们得先将key的右半部分入栈，再入栈key的左半部分。  
&gt;    最后，当key的左右两边都只有一个元素或没有元素时就停止入栈，那么再进入到循环判断条件时，因为栈空就退出循环，至此非递归的快排就结束了。
&gt; 
&gt; 
&gt; 



</code></pre> 
<p>int Partion(int* array, int begin, int end)<br> {<!-- --><br> int key = array[begin];<br> int cur = begin+ 1, prev = begin;<br> while (cur &lt;= end)<br> {<!-- --><br> if (array[cur] &lt; key &amp;&amp; ++prev != cur)<br> {<!-- --><br> Swap(&amp;array[cur], &amp;array[prev]);<br> }<br> ++cur;<br> }<br> Swap(&amp;array[prev], &amp;array[begin]);<br> return prev;<br> }<br> void QuickSortNor(int* array, int begin, int end)<br> {<!-- --><br> Stack s;<br> StackInit(&amp;s);<br> StackPush(&amp;s, begin);<br> StackPush(&amp;s, end);<br> while (!StackEmpty(&amp;s))<br> {<!-- --><br> int right = StackTop(&amp;s);<br> StackPop(&amp;s);<br> int left = StackTop(&amp;s);<br> StackPop(&amp;s);<br> int keyi = Partion(array, left, right);<br> if (keyi + 1 &lt; right)<br> {<!-- --><br> StackPush(&amp;s, keyi + 1);<br> StackPush(&amp;s, right);<br> }<br> if (left &lt; keyi - 1)<br> {<!-- --><br> StackPush(&amp;s, left);<br> StackPush(&amp;s, keyi - 1);<br> }<br> }<br> StackDestroy(&amp;s);<br> }</p> 
<pre><code>
##### 3.2.5 快排优化（三数取中法+小区间优化）


###### 3.2.5.1 三数取中法



&gt; 
&gt;   为什么要用到三数取中法来进行优化就是因为，万一选取的基准值刚好是该序列的最小值，那么在一趟排序完成之后并没有什么效果，只是那个基准值的位置刚好落位了，但是它右边的元素都没有任何变化，所以说，为了避免这样的情况发生，我们采取三数取中法来进行优化。  
&gt;    三数取中法是怎样操作的呢？选序列的最左、右边和中间的三个值比大小，将那个中间值放在最左边作为基准值，然后再去执行排序算法。
&gt; 
&gt; 
&gt; 


**代码实现**



</code></pre> 
<p>int GetMiddleIndex(int* array, int left,int right)<br> {<!-- --><br> int mid = (left + right) / 2;<br> if (array[left] &lt; array[mid])<br> {<!-- --><br> if (array[mid] &lt; array[right])<br> return mid;<br> if (array[right] &lt; array[left])<br> return left;<br> else<br> return right;<br> }<br> else<br> {<!-- --><br> if (array[left] &lt; array[right])<br> return left;<br> if (array[right] &lt; array[mid])<br> return mid;<br> else<br> return right;<br> }<br> }</p> 
<pre><code>
###### 3.2.5.2 小区间优化



&gt; 
&gt;   想一下，快排的思想就是不断地分割小序列，然后再递归实现，它的每一层的递归次数以2倍的次数进行增长。当元素较多时以递归的方法实现是不错的，但是当序列元素较少时，再使用递归就没有必要了，我们可以选择使用其他的排序方法来实现小序列的排序。
&gt; 
&gt; 
&gt; 



</code></pre> 
<p>void QuickSort(int* array, int left, int right)<br> {<!-- --><br> if (right - left &lt; 16)<br> {<!-- --><br> // [left, right)区间中数据少到一定程度，使用插入排序来优化<br> InsertSort(array + left, right - left);<br> }<br> else<br> {<!-- --><br> int div = Partion(array, left, right);<br> QuickSort(array, left, div);<br> QuickSort(array, div + 1, right);<br> }<br> }</p> 
<pre><code>
**将这两种优化算法应用到双指针排序算法中：**



</code></pre> 
<p>int GetMiddleIndex(int* array, int left,int right)<br> {<!-- --><br> int mid = (left + right) / 2;<br> if (array[left] &lt; array[mid])<br> {<!-- --><br> if (array[mid] &lt; array[right])<br> return mid;<br> if (array[right] &lt; array[left])<br> return left;<br> else<br> return right;<br> }<br> else<br> {<!-- --><br> if (array[left] &lt; array[right])<br> return left;<br> if (array[right] &lt; array[mid])<br> return mid;<br> else<br> return right;<br> }<br> }<br> int Partion(int* array, int begin, int end)<br> {<!-- --><br> int midex = GetMiddleIndex(array, begin, end);<br> if (midex != begin)<br> {<!-- --><br> Swap(&amp;array[midex], &amp;array[begin]);<br> }<br> int key = array[begin];<br> int cur = begin+ 1, prev = begin;<br> while (cur &lt;= end)<br> {<!-- --><br> if (array[cur] &lt; key &amp;&amp; ++prev != cur)<br> {<!-- --><br> Swap(&amp;array[cur], &amp;array[prev]);<br> }<br> ++cur;<br> }<br> Swap(&amp;array[prev], &amp;array[begin]);<br> return prev;<br> }<br> void QuickSort(int* array, int left, int right)<br> {<!-- --><br> if (right - left &lt; 16)<br> {<!-- --><br> // [left, right)区间中数据少到一定程度，使用插入排序来优化<br> InsertSort(array + left, right - left);<br> }<br> else<br> {<!-- --><br> int div = Partion(array, left, right);<br> QuickSort(array, left, div);<br> QuickSort(array, div + 1, right);<br> }<br> }</p> 
<pre><code>
**快速排序总结：**



&gt; 
&gt; 快速排序的时间复杂度为O(nlogn)  
&gt;  在平均情况下，快速排序总共需要分割 logn 次，即需要 logn 个辅助空间，所以空间复杂度为O(logn)  


![img](https://img-blog.csdnimg.cn/img_convert/35905fb87d980a2015d4023e216b1ffc.png)
![img](https://img-blog.csdnimg.cn/img_convert/686cf2fd815e46ba9c3b34e4acf0ca5a.png)

**网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。**

**[需要这份系统化资料的朋友，可以戳这里获取](https://bbs.csdn.net/forums/4f45ff00ff254613a03fab5e56a57acb)**


**一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！**

array[begin]);
	return prev;
}
void QuickSort(int\* array, int left, int right)
{
	if (right - left &lt; 16)
	{
		// [left, right)区间中数据少到一定程度，使用插入排序来优化
		InsertSort(array + left, right - left);
	}
	else
	{
		int div = Partion(array, left, right);
		QuickSort(array, left, div);
		QuickSort(array, div + 1, right);
	}
}

</code></pre> 
<p><strong>快速排序总结：</strong></p> 
<blockquote> 
 <p>快速排序的时间复杂度为O(nlogn)<br> 在平均情况下，快速排序总共需要分割 logn 次，即需要 logn 个辅助空间，所以空间复杂度为O(logn)</p> 
</blockquote> 
<p>[外链图片转存中…(img-m0HWuTxs-1715444123935)]<br> [外链图片转存中…(img-N69OhLPv-1715444123935)]</p> 
<p><strong>网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。</strong></p> 
<p><strong><a href="https://bbs.csdn.net/forums/4f45ff00ff254613a03fab5e56a57acb">需要这份系统化资料的朋友，可以戳这里获取</a></strong></p> 
<p><strong>一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c87e9fa37003881c4a21f10929871afd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Git之Idea操作git</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f66ba3d5fa03189c3f75e7cd52195c20/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据最新计算机视觉项目实战-驾驶员疲劳检测_计算机视觉疲劳检测，大数据开发面试题大全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>