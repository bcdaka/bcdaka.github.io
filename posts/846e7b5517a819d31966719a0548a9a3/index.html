<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【爱上C&#43;&#43;】list用法详解、模拟实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/846e7b5517a819d31966719a0548a9a3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【爱上C&#43;&#43;】list用法详解、模拟实现">
  <meta property="og:description" content="文章目录 一：list介绍以及使用1.list介绍2.基本用法①list构造方式②list迭代器的使用③容量④元素访问⑤插入和删除⑥其他操作image.png 3.list与vector对比 二：list模拟实现1.基本框架2.节点结构体模板3.__list_iterator 结构体模板①模板参数说明②构造函数③迭代器类：拷贝构造、赋值操作、析构函数的说明④&#43;&#43;运算符和--运算符⑤==和!=⑥*运算符⑦-&gt;运算符 4.list结构体模板①默认成员函数为什么不能传引用？ ②迭代器③增删查改④其他操作 5.完整代码展示以及详细注释 一：list介绍以及使用 1.list介绍 文档在这里→官方文档←
list是可以在常数范围内（ 时间复杂度为O(1) ）在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代(双向迭代器)。list的底层是双向链表结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。list与forward_list非常相似：最主要的不同在于forward_list是单链表，只能朝前迭代，已让其更简单高效。与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的执行效率更好。与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要的因素) 2.基本用法 ①list构造方式 list&lt;int&gt; l1; // 构造空的l1 list&lt;int&gt; l2(4, 100); // l2中放4个值为100的元素 list&lt;int&gt; l3(l2.begin(), l2.end()); // 用l2的[begin(), end()）左闭右开的区间构造l3 list&lt;int&gt; l4(l3); // 用l3拷贝构造l4 // 以数组为迭代器区间构造l5 int array[] = { 16,2,77,29 }; list&lt;int&gt; l5(array, array &#43; sizeof(array) / sizeof(int)); // 列表格式初始化C&#43;&#43;11 list&lt;int&gt; l6{ 1,2,3,4,5 }; ②list迭代器的使用 此处，大家可暂时将迭代器理解成一个指针，该指针指向list中的某个节点。
【注意】
begin与end为正向迭代器，对迭代器执行&#43;&#43;操作，迭代器向后移动rbegin(end)与rend(begin)为反向迭代器，对迭代器执行&#43;&#43;操作，迭代器向前移动
int main() { // 创建一个整数列表，并初始化列表 list&lt;int&gt; mylist = {1, 2, 3, 4, 5}; // 使用 begin() 和 end() 迭代器遍历列表 cout &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T12:11:58+08:00">
    <meta property="article:modified_time" content="2024-07-22T12:11:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【爱上C&#43;&#43;】list用法详解、模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#list_2" rel="nofollow">一：list介绍以及使用</a></li><li><ul><li><a href="#1list_4" rel="nofollow">1.list介绍</a></li><li><a href="#2_15" rel="nofollow">2.基本用法</a></li><li><ul><li><a href="#list_17" rel="nofollow">①list构造方式</a></li><li><a href="#list_35" rel="nofollow">②list迭代器的使用</a></li><li><a href="#_68" rel="nofollow">③容量</a></li><li><a href="#_82" rel="nofollow">④元素访问</a></li><li><a href="#_112" rel="nofollow">⑤插入和删除</a></li><li><a href="#_187" rel="nofollow">⑥其他操作</a></li><li><a href="#imagepnghttpsimgblogcsdnimgcnimg_convertfaa9b7d629b7671ac827b91d168d5b86png_249" rel="nofollow">image.png</a></li></ul> 
   </li><li><a href="#3listvector_251" rel="nofollow">3.list与vector对比</a></li></ul> 
  </li><li><a href="#list_266" rel="nofollow">二：list模拟实现</a></li><li><ul><li><a href="#1_268" rel="nofollow">1.基本框架</a></li><li><a href="#2_408" rel="nofollow">2.节点结构体模板</a></li><li><a href="#3__list_iterator__468" rel="nofollow">3.__list_iterator 结构体模板</a></li><li><ul><li><a href="#_486" rel="nofollow">①模板参数说明</a></li><li><a href="#_498" rel="nofollow">②构造函数</a></li><li><a href="#_507" rel="nofollow">③迭代器类：拷贝构造、赋值操作、析构函数的说明</a></li><li><a href="#_532" rel="nofollow">④++运算符和--运算符</a></li><li><a href="#_585" rel="nofollow">⑤==和!=</a></li><li><a href="#_598" rel="nofollow">⑥*运算符</a></li><li><a href="#_612" rel="nofollow">⑦-&gt;运算符</a></li></ul> 
   </li><li><a href="#4list_670" rel="nofollow">4.list结构体模板</a></li><li><ul><li><a href="#_672" rel="nofollow">①默认成员函数</a></li><li><ul><li><a href="#_898" rel="nofollow">为什么不能传引用？</a></li></ul> 
    </li><li><a href="#_934" rel="nofollow">②迭代器</a></li><li><a href="#_963" rel="nofollow">③增删查改</a></li><li><a href="#_1059" rel="nofollow">④其他操作</a></li></ul> 
   </li><li><a href="#5_1149" rel="nofollow">5.完整代码展示以及详细注释</a></li></ul> 
 </li></ul> 
</div> 
<br> 
 
<p></p> 
<h2><a id="list_2"></a>一：list介绍以及使用</h2> 
<p></p> 
<h3><a id="1list_4"></a>1.list介绍</h3> 
<p>文档在这里→<a href="https://cplusplus.com/reference/list/list/" rel="nofollow">官方文档</a>←<br><img src="https://images2.imgbox.com/01/2f/QZehe8bD_o.png" alt="image.png"></p> 
<ol><li>list是可以在常数范围内（ 时间复杂度为O(1) ）在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代(双向迭代器)。</li><li>list的底层是双向链表结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。</li><li>list与forward_list非常相似：最主要的不同在于forward_list是单链表，只能朝前迭代，已让其更简单高效。</li><li>与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的执行效率更好。</li><li>与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要的因素)</li></ol> 
<p><img src="https://images2.imgbox.com/60/f4/iMoqlIi7_o.png" alt="image.png"><img src="https://images2.imgbox.com/a8/02/uFAWSX7d_o.png" alt="image.png"><br> </p> 
<h3><a id="2_15"></a>2.基本用法</h3> 
<p></p> 
<h4><a id="list_17"></a>①list构造方式</h4> 
<p><img src="https://images2.imgbox.com/1e/28/mT4Wdo4o_o.png" alt="image.png"></p> 
<pre><code class="prism language-cpp">    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> l1<span class="token punctuation">;</span>                         <span class="token comment">// 构造空的l1</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">l2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// l2中放4个值为100的元素</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">l3</span><span class="token punctuation">(</span>l2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 用l2的[begin(), end()）左闭右开的区间构造l3</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">l4</span><span class="token punctuation">(</span>l3<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 用l3拷贝构造l4</span>
    
    <span class="token comment">// 以数组为迭代器区间构造l5</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">16</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">77</span><span class="token punctuation">,</span><span class="token number">29</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">l5</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> array <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 列表格式初始化C++11</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> l6<span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p></p> 
<h4><a id="list_35"></a>②list迭代器的使用</h4> 
<p>此处，大家可暂时将迭代器理解成一个指针，该指针指向list中的某个节点。<br>【注意】</p> 
<ol><li>begin与end为正向迭代器，对迭代器执行++操作，迭代器向后移动</li><li>rbegin(end)与rend(begin)为反向迭代器，对迭代器执行++操作，迭代器向前移动<br> <br> <img src="https://images2.imgbox.com/52/62/SfNaAuEB_o.png" alt="image.png"></li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建一个整数列表，并初始化列表</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> mylist <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用 begin() 和 end() 迭代器遍历列表</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"使用 begin() 和 end():"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> mylist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> mylist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 输出当前迭代器指向的元素</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 使用 rbegin() 和 rend() 迭代器反向遍历列表</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"使用 rbegin() 和 rend():"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>reverse_iterator rit <span class="token operator">=</span> mylist<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> rit <span class="token operator">!=</span> mylist<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>rit<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>rit <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 输出当前反向迭代器指向的元素</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/5d/9a/dCbKCEde_o.png" alt="image.png"></p> 
<p></p> 
<h4><a id="_68"></a>③容量</h4> 
<p><img src="https://images2.imgbox.com/bb/34/0NdQ0z1R_o.png" alt="image.png"></p> 
<pre><code class="prism language-cpp">	list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"空"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9e/49/V4179f2v_o.png" alt="image.png"><br> </p> 
<h4><a id="_82"></a>④元素访问</h4> 
<p><img src="https://images2.imgbox.com/5a/0f/4fHB0Mt0_o.png" alt="image.png"></p> 
<pre><code class="prism language-cpp">
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建一个整数列表，并初始化列表</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> mylist <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用 front() 返回列表的第一个节点中值的引用</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"列表的第一个元素: "</span> <span class="token operator">&lt;&lt;</span> mylist<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 使用 back() 返回列表的最后一个节点中值的引用</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"列表的最后一个元素: "</span> <span class="token operator">&lt;&lt;</span> mylist<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 修改第一个和最后一个元素的值</span>
    mylist<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    mylist<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>

    <span class="token comment">// 输出修改后的列表</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"修改后的列表: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> mylist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/16/df/TtSauN9k_o.png" alt="image.png"><br> </p> 
<h4><a id="_112"></a>⑤插入和删除</h4> 
<p><img src="https://images2.imgbox.com/b3/11/8RqSHM8h_o.png" alt="image.png"></p> 
<p><br> <strong>push_back/pop_back/push_front/pop_front</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">PrintList</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> l<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 注意这里调用的是list的 begin() const，返回list的const_iterator对象</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator it <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token comment">// *it = 10; 编译不通过</span>
    <span class="token punctuation">}</span>

    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// push_back/pop_back/push_front/pop_front</span>
<span class="token keyword">void</span> <span class="token function">TestList3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">L</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> array <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在list的尾部插入4，头部插入0</span>
    L<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    L<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 删除list尾部节点和头部节点</span>
    L<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    L<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9f/53/RdyDeUeA_o.png" alt="image.png"></p> 
<p><strong>insert/erase</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestList4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> array1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">L</span><span class="token punctuation">(</span>array1<span class="token punctuation">,</span> array1 <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取链表中第二个节点</span>
    <span class="token keyword">auto</span> pos <span class="token operator">=</span> <span class="token operator">++</span>L<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pos <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 在pos前插入值为4的元素</span>
    L<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在pos前插入5个值为5的元素</span>
    L<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在pos前插入[v.begin(), v.end)区间中的元素</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{<!-- --></span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    L<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 删除pos位置上的元素</span>
    L<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 删除list中[begin, end)区间中的元素，即删除list中的所有元素</span>
    L<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> L<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3b/9b/ZlY90LP5_o.png" alt="image.png"><br> </p> 
<h4><a id="_187"></a>⑥其他操作</h4> 
<p><strong>resize/swap/clear</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建一个包含初始值的列表</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> mylist <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"初始列表: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> mylist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 使用 resize 改变列表的大小</span>
    mylist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将列表缩小到3个元素</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"使用 resize 缩小列表后: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> mylist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    mylist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将列表扩展到5个元素，新元素的值为100</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"使用 resize 扩展列表后: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> mylist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 创建另一个列表并交换内容</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> otherlist <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"另一个列表: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> otherlist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    mylist<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>otherlist<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换两个列表的内容</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"使用 swap 交换后，mylist: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> mylist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"使用 swap 交换后，otherlist: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> otherlist<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 使用 clear 清空列表</span>
    mylist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"使用 clear 清空列表后，mylist 为空，大小为: "</span> <span class="token operator">&lt;&lt;</span> mylist<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p></p> 
<h4><a id="imagepnghttpsimgblogcsdnimgcnimg_convertfaa9b7d629b7671ac827b91d168d5b86png_249"></a><img src="https://images2.imgbox.com/83/19/8dIJzrnz_o.png" alt="image.png"></h4> 
<p></p> 
<h3><a id="3listvector_251"></a>3.list与vector对比</h3> 
<p>vector与list都是STL中非常重要的序列式容器，由于两个容器的底层结构不同，导致其特性以及应用场景不同，其主要不同如下：</p> 
<table><thead><tr><th></th><th>vector</th><th>list</th></tr></thead><tbody><tr><td>底层结构</td><td>动态顺序表，一段连续空间</td><td>带头结点的双向循环链表</td></tr><tr><td>随机访问</td><td>支持随机访问，访问某个元素效率O(1)</td><td>不支持随机访问，访问某个元素效率O(N)</td></tr><tr><td>插入和删除</td><td>任意位置插入和删除效率低，需要搬移元素，时间复杂度为O(N)，插入时有可能需要增容，增容：开辟新空&lt;间，拷贝元素，释放旧空间，导致效率更低</td><td>任意位置插入和删除效率高，不需要搬移元素，时间复杂度为O(1)</td></tr><tr><td>空间利用率</td><td>底层为连续空间，不容易造成内存碎片，空间利用率高，缓存利用率高</td><td>底层节点动态开辟，小节点容易造成内存碎片，空间利用率低，缓存利用率低</td></tr><tr><td>迭代器</td><td>原生态指针</td><td>对原生态指针(节点指针)进行封装</td></tr><tr><td>迭代器失效</td><td>在插入元素时，要给所有的迭代器重新赋值，因为插入元素有可能会导致重新扩容，致使原来迭代器失效，删除时，当前迭代器需要重新赋值否则会失效</td><td>插入元素不会导致迭代器失效，删除元素时，只会导致当前迭代器失效，其他迭代器不受影响</td></tr><tr><td>场景使用</td><td>需要高效存储，支持随机访问，不关心插入删除效率</td><td>大量插入和删除操作，不关心随机访问</td></tr></tbody></table> 
<p></p> 
<h2><a id="list_266"></a>二：list模拟实现</h2> 
<h3><a id="1_268"></a>1.基本框架</h3> 
<p>list模拟实现的代码由三部分组成，内容较多，为了便于理解这里先提前介绍大致框架，后面再对每一部分详细讲解。<br>分为以下几大部分：</p> 
<ul><li>节点结构体模板</li><li>__list_iterator 结构体模板</li><li>list结构体模板（由一个个节点组成）</li><li>测试函数</li></ul> 
<p>1.首先，我们定义了一个节点结构体模板 ListNode，它包含：</p> 
<ul><li>ListNode* 类型的 _next 和 _prev 指针，分别指向前后节点。</li><li>T 类型的 _data，存放节点的数据。</li><li>ListNode 的构造函数初始化这些成员。</li></ul> 
<p>2.然后，我们定义了一个模板结构体 __list_iterator，用于实现链表的迭代器。这个迭代器包含：</p> 
<ul><li>一个指向当前节点的指针 _node。</li><li>构造函数、前置和后置 ++、-- 运算符重载、解引用运算符、相等和不相等比较运算符等操作。</li></ul> 
<p>为了简化代码，__list_iterator 使用了两个 typedef：</p> 
<ul><li>将 ListNode 重命名为 Node。</li><li>将 __list_iterator&lt;T, Ref, Ptr&gt; 重命名为 self。</li></ul> 
<p>3.接下来，我们实现了 list 结构体模板。</p> 
<ul><li>它包含一个带哨兵位的头结点 _head，类型为 Node* 。通过这个头结点以及迭代器指向的各个节点，形成一个带头的双向循环链表。</li><li>在 list 中，我们将 __list_iterator&lt;T, T&amp;, T*&gt; 重命名为 iterator，将 __list_iterator&lt;T, const T&amp;, const T*&gt; 重命名为 const_iterator，一种是普通迭代器，一种是常量迭代器，以便用户更方便地使用迭代器。</li></ul> 
<p>通过这些定义，我们实现了一个功能完整的双向循环链表，并且提供了迭代器接口，使得用户可以方便地遍历和操作链表中的元素。<br>这个结构通过 ListNode 实现了双向节点连接，通过 __list_iterator 实现了链表的遍历和操作接口，并通过 list 结构体模板实现了整体的双向循环链表功能。测试函数用于验证各部分的功能和接口是否正常运行。</p> 
<p></p> 
<hr> 
<p><strong>节点类</strong></p> 
<pre><code class="prism language-cpp">	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token comment">//每个模板类或模板函数的定义都需要用 template&lt;class T&gt; 来声明。这样做的原因是为了告诉编译器这个类或函数是一个模板，且它是依赖于一个类型参数 T</span>
	<span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
	<span class="token punctuation">{<!-- --></span>
        <span class="token comment">//成员函数</span>
        <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//构造函数</span>

		ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span><span class="token comment">/// 指向下一个节点的指针</span>
		ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _prev<span class="token punctuation">;</span><span class="token comment">// 指向上一个节点的指针</span>
		T _data<span class="token punctuation">;</span>		   <span class="token comment">// 节点存储的数据</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>迭代器类</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">__list_iterator</span>
<span class="token punctuation">{<!-- --></span>	
	<span class="token keyword">typedef</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>					<span class="token comment">// 定义节点类型的别名</span>
	<span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Ref<span class="token punctuation">,</span> Ptr<span class="token operator">&gt;</span> self<span class="token punctuation">;</span>  <span class="token comment">// 定义迭代器类型的别名</span>
	<span class="token comment">//__list_iterator 被定义为一个模板结构体，并且引入了三个模板参数：T, Ref, 和 Ptr。</span>
    <span class="token comment">//通过不同的类型实例化 Ref 和 Ptr，我们可以区分出普通迭代器和常量迭代器。</span>
	
	<span class="token comment">//构造函数，接受一个节点指针</span>
	<span class="token function">__list_iterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 前置++运算符重载，使迭代器指向下一个节点。</span>
	<span class="token comment">//++it</span>
	self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//it++</span>
	self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Ref <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Ptr <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Node<span class="token operator">*</span> _node<span class="token punctuation">;</span>					<span class="token comment">// 指向链表节点的指针</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>list类</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">list</span>
<span class="token punctuation">{<!-- --></span> 	
 <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ListNode<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> _list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> iterator<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> _list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> const_iterator<span class="token punctuation">;</span>
	
    <span class="token comment">//默认成员函数</span>
    <span class="token comment">//构造</span>
    <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">list</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">&gt;</span><span class="token comment">//取名为InputIterator说明可以用任意类型的迭代器构造</span>
	<span class="token function">list</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//拷贝构造</span>
    <span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//赋值运算符重载</span>
    list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//析构</span>
    <span class="token operator">~</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//迭代器相关函数</span>
    <span class="token comment">//正向迭代器</span>
    iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    const_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    const_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    
    <span class="token comment">//访问容器相关函数</span>
    T<span class="token operator">&amp;</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    T<span class="token operator">&amp;</span> <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">//插入、删除函数</span>
    iterator <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">push_front</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//其他函数</span>
    size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
        ListNode<span class="token operator">*</span> _head<span class="token punctuation">;</span> <span class="token comment">//指向链表头结点的指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<p></p> 
<h3><a id="2_408"></a>2.节点结构体模板</h3> 
<p>实现一个<code>list</code>实际上是实现一个带头双向循环链表。首先，需要定义一个结点类，每个结点应存储以下信息：数据、前驱指针和后继指针。<br>对于结点类的成员函数，只需实现一个构造函数即可，因为结点类的唯一职责是根据数据构造结点。结点的释放操作由<code>list</code>类的析构函数统一管理，不需要在结点类中单独实现。<br>原因如下：</p> 
<blockquote> 
 <p><strong>结点类的析构函数</strong><br> 结点类不需要单独的析构函数，因为：</p> 
 <ol><li><strong>自动内存管理</strong>：C++的内存管理机制会自动调用析构函数来释放对象的内存。在结点类中，通常不涉及动态内存分配（如使用<code>new</code>创建成员），因此不需要特别的内存释放操作。</li><li><strong>链表类负责内存管理</strong>：链表类（如<code>list</code>）会在其析构函数中遍历所有结点并删除它们，确保所有结点的内存被正确释放。</li></ol> 
</blockquote> 
<p><strong>结点的创建和销毁</strong></p> 
<blockquote> 
 <p>在链表的操作中，结点的创建和销毁是由链表类控制的：</p> 
 <ol><li><strong>创建结点</strong>：在需要添加新结点时，链表类会使用结点类的构造函数创建新结点。</li><li><strong>销毁结点</strong>：在链表类的析构函数或其他删除操作中，会遍历所有结点并删除它们，从而调用每个结点的析构函数。</li></ol> 
</blockquote> 
<pre><code class="prism language-cpp">	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token comment">//每个模板类或模板函数的定义都需要用 template&lt;class T&gt; 来声明。</span>
<span class="token comment">//这样做的原因是为了告诉编译器这个类或函数是一个模板，且它是依赖于一个类型参数 T</span>
	<span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
	<span class="token punctuation">{<!-- --></span>
        <span class="token comment">//成员函数</span>
        <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//构造函数</span>
        <span class="token punctuation">{<!-- --></span>
        <span class="token operator">:</span><span class="token function">_val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
        <span class="token punctuation">,</span><span class="token function">_prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span><span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
<span class="token comment">//使用默认参数 T() 初始化 _data，并将 _next 和 _prev 初始化为 nullptr</span>

		ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span><span class="token comment">/// 指向下一个节点的指针</span>
		ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _prev<span class="token punctuation">;</span><span class="token comment">// 指向上一个节点的指针</span>
		T _data<span class="token punctuation">;</span>		   <span class="token comment">// 节点存储的数据</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>ListNode(const T&amp; x = T()) 必须加上 =T() !!!<br> 默认参数的提供：</p> 
 <ul><li>构造函数中的 = T() 表示如果调用者在创建 ListNode 对象时没有提供参数 x，则会使用 T() 这个默认值来初始化 _data 成员变量。</li><li>灵活性：这种构造函数提供了更大的灵活性。如果调用者提供了参数 x，则会使用提供的值来初始化节点的 _data 成员；如果没有提供参数 x，则会使用 T() 的默认构造函数生成一个默认值来初始化 _data。</li><li>适用性：对于链表节点来说，可能存在需要默认构造的情况，例如默认构造一个空节点或者默认值为特定类型的情况。通过提供默认参数，可以简化在某些场景下节点的创建。</li></ul> 
</blockquote> 
<blockquote> 
 <p>为什么ListNode* _prev; 要加？？？<br> 模板类 ListNode 是一个通用类型，它可以被实例化为不同的数据类型。加上 是为了告诉编译器 _next 是一个指向相同类型的 ListNode 实例的指针。<br> 这里，ListNode 是一个模板类，它可以用任何类型的 T 来实例化。例如，你可以有一个 ListNode 用于整数类型，或者一个 ListNode 用于浮点数类型。<br> ListNode* intNode;<br> ListNode* doubleNode;<br> 在模板类的内部，也需要指定具体类型。例如，当定义 _next 指针时，需要明确它指向的是哪种类型的 ListNode，因此使用 ListNode*。如果不加 ，编译器将不知道 _next 是指向哪个具体实例化类型的 ListNode。比如：</p> 
</blockquote> 
<pre><code class="prism language-cpp">ListNode<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> node<span class="token punctuation">;</span>
node<span class="token punctuation">.</span>_next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ListNode</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确，_next 是指向 ListNode&lt;int&gt; 的指针</span>
ListNode<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> dnode<span class="token punctuation">;</span>
dnode<span class="token punctuation">.</span>_next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ListNode</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确，_next 是指向 ListNode&lt;double&gt; 的指针</span>
</code></pre> 
<blockquote> 
 <p>结构体（struct）？？？<br> 是一种自定义数据类型，用于将多个相关的变量组合在一起。结构体可以包含基本数据类型、指针、引用、其他结构体、类等成员。与类（class）的主要区别在于结构体的默认访问控制是公有的（public），而类的默认访问控制是私有的（private）。<br> 带有构造函数的结构体：结构体可以包含构造函数，用于初始化成员变量。函数名就是结构体名</p> 
</blockquote> 
<p></p> 
<h3><a id="3__list_iterator__468"></a>3.__list_iterator 结构体模板</h3> 
<p>迭代器有两种实现方式，根据容器底层的数据结构进行选择：</p> 
<ol><li><strong>原生指针</strong>：例如，<code>vector</code>和<code>string</code>的底层是连续的物理内存空间。 
  <ul><li><code>vector</code>和<code>string</code>的迭代器实际上是原生指针，因为它们的数据存储在连续的内存空间中。通过指针的自增、自减以及解引用操作，我们可以对相应位置的数据进行操作。</li></ul> </li><li><strong>封装指针</strong>：对于不连续的存储结构，需要将原生指针封装成迭代器类。 
  <ul><li>由于迭代器的使用形式与指针完全相同，因此在自定义迭代器类中必须实现以下功能： 
    <ul><li><strong>解引用</strong>：必须重载<code>operator*()</code>。</li><li><strong>成员访问</strong>：必须重载<code>operator-&gt;()</code>。</li><li><strong>向后移动</strong>：必须重载<code>operator++()</code>和<code>operator++(int)</code>。</li><li><strong>向前移动</strong>（如双向链表）：重载<code>operator--()</code>和<code>operator--(int)</code>。</li><li><strong>比较操作</strong>：需要重载<code>operator==()</code>和<code>operator!=()</code>。</li></ul> </li></ul> </li></ol> 
<p>对于<code>list</code>来说，其各个结点在内存中的位置是随机的，并非连续存储。因此，不能通过简单的指针自增、自减和解引用操作对结点进行操作。<br>迭代器的意义在于，让用户可以不必关心容器的底层实现，通过统一的方式访问容器内的数据。因为<code>list</code>的结点指针不满足迭代器的定义，我们需要对结点指针进行封装，对各种运算符进行重载。<br>总结：<code>list</code>的迭代器实际上就是对结点指针的封装，通过重载各种运算符，使得结点指针的行为看起来和普通指针一样。例如，对结点指针自增后可以指向下一个结点<code>p = p-&gt;next</code>。</p> 
<p></p> 
<h4><a id="_486"></a>①模板参数说明</h4> 
<p><code>template&lt;class T, class Ref, class Ptr&gt;</code><br><code>typedef __list_iterator&lt;T, Ref, Ptr&gt; self; // 定义迭代器类型的别名</code></p> 
<p>__list_iterator 被定义为一个模板结构体，并且引入了三个模板参数：T, Ref, 和 Ptr。通过不同的类型实例化 Ref 和 Ptr，我们可以区分出普通迭代器和常量迭代器。</p> 
<ul><li>对于普通迭代器，Ref 是 T&amp; ，所以 operator*() 返回节点数据的引用，允许修改数据。</li><li>对于常量迭代器，Ref 是 const T&amp; ，所以 operator*() 返回节点数据的常量引用，不允许修改数据。</li><li>对于普通迭代器，Ptr 是 T* ，所以 operator-&gt;() 返回指向节点数据的指针，允许通过指针修改数据。</li><li>对于常量迭代器，Ptr 是 const T* ，所以 operator-&gt;() 返回指向节点数据的常量指针，不允许通过指针修改数据。</li></ul> 
<p><img src="https://images2.imgbox.com/e5/ba/dKUvr58K_o.png" alt="image.png"><br> </p> 
<h4><a id="_498"></a>②构造函数</h4> 
<pre><code class="prism language-cpp"><span class="token comment">//构造函数，接受一个节点指针</span>
<span class="token function">__list_iterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> x<span class="token punctuation">)</span>
	<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>__list_iterator 的构造函数接受一个指向 ListNode 的指针 x，然后将 _node 成员变量初始化为 x。因此，每个 __list_iterator 对象都包含一个指向 ListNode 的指针 _node。<br>另外：构造函数的名字必须与类的名字完全相同，不能使用类型的别名代替构造函数的名字。 上面self(Node* x) 是错的<br> </p> 
<h4><a id="_507"></a>③迭代器类：拷贝构造、赋值操作、析构函数的说明</h4> 
<ol><li><strong>拷贝构造函数、赋值操作符和析构函数的必要性</strong><br>在迭代器类中，拷贝构造函数、赋值操作符和析构函数的实现通常取决于迭代器的成员变量类型。如果迭代器的成员变量是指针（或者其他内置类型），且不需要进行复杂的资源管理，通常可以依赖编译器自动生成的默认版本。</li></ol> 
<ul><li><strong>拷贝构造函数</strong>：拷贝构造函数的作用是创建一个新的迭代器对象，该对象是另一个迭代器对象的副本。在迭代器中，成员变量是指针（内置类型），默认生成的拷贝构造函数将进行浅拷贝（即直接复制指针的值）。这种浅拷贝在大多数情况下足够，因为迭代器通常只是指向某个容器内的结点，不管理结点的生命周期。</li><li><strong>赋值操作符</strong>：赋值操作符用于将一个迭代器对象的值赋给另一个迭代器对象。由于迭代器的成员变量是指针，默认生成的赋值操作符也会进行浅拷贝，这样的行为是合适的。</li><li><strong>析构函数</strong>：析构函数负责清理对象使用的资源。由于迭代器只负责访问和修改链表的结点，而结点的内存管理是由链表（<code>list</code>）负责的，因此迭代器本身不需要释放这些结点的内存。链表的析构函数会处理结点的释放。因此，迭代器的析构函数可以留给编译器自动生成的默认版本。</li></ul> 
<ol start="2"><li><strong>拷贝构造函数的应用示例</strong></li></ol> 
<pre><code class="prism language-cpp">list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里的<code>it</code>是通过拷贝构造函数创建的。<code>lt.begin()</code>返回一个迭代器对象，这个迭代器对象指向链表的第一个结点。<code>it</code>通过拷贝构造函数从<code>lt.begin()</code>初始化。因为迭代器内部包含的只是指针（浅拷贝足够），所以默认的拷贝构造函数是适用的。<br>3. <strong>注意点</strong></p> 
<ul><li><strong>链表的结点与迭代器的关系</strong>：迭代器仅用于访问和修改链表的结点，不负责管理结点的内存。链表的析构函数会负责释放结点的内存。</li><li><code>return *this</code><strong>与</strong><code>return this</code>： 
  <ul><li><code>return *this</code>：返回当前对象的克隆（值），通常用于返回迭代器对象的副本。</li><li><code>return this</code>：返回当前对象的地址（指针），用于返回当前迭代器对象的指针。这在需要直接操作对象地址时使用。</li></ul> </li></ul> 
<ol start="4"><li>**类型别名 **<code>self</code></li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Ref<span class="token punctuation">,</span> Ptr<span class="token operator">&gt;</span> self<span class="token punctuation">;</span>
</code></pre> 
<p>在迭代器类中，我们可能会定义<code>self</code>类型别名，以便在代码中更简洁地引用当前迭代器的类型。<code>self</code>代表了当前迭代器类的自身类型，这样可以使代码更加清晰和易于维护。</p> 
<p></p> 
<h4><a id="_532"></a>④++运算符和–运算符</h4> 
<p><strong>前置++</strong></p> 
<pre><code class="prism language-cpp">		<span class="token comment">// 前置++运算符重载，使迭代器指向下一个节点。</span>
		<span class="token comment">//++it</span>
		self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>为什么返回引用？</strong><br> 这里的前置++运算符重载返回的是一个引用，即 self &amp; 。它的作用是使迭代器向前移动到下一个节点，并返回移动后的迭代器对象自身。这种形式的重载通常在使用时会直接对迭代器进行修改，并返回修改后的对象的引用，以便支持链式操作。<br> 前置++运算符不需要任何参数，只需将迭代器移动到下一个位置并返回自身的引用即可。具体来说，它会将迭代器所指向的节点指针 _node 移动到下一个节点 _next，然后返回当前对象自身的引用 (*this)。</p> 
</blockquote> 
<p><strong>后置++</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">//后置++运算符重载，使迭代器指向下一个节点，并返回之前的迭代器</span>
<span class="token comment">//it++</span>
self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 1. 创建一个名为 tmp 的临时迭代器对象，它通过调用 __list_iterator 的拷贝构造函数，用当前迭代器 *this 进行初始化。</span>
	self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建一个临时迭代器对象，保存当前迭代器的状态</span>
	<span class="token comment">// 2. 将当前迭代器移动到下一个节点</span>
	_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token comment">// 3. 返回之前的迭代器状态</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>后置++为什么有(int)？？？</strong><br> 后置++运算符重载接受一个额外的 int 参数（这里没有实际使用它，只是为了区分前置和后置++），并返回一个值而不是引用。<br> C++中的后置++运算符必须在参数列表中声明一个int类型的参数，以便与前置++运算符进行区分。这种参数实际上并没有用处，只是为了在编译器中区分前置和后置++运算符的不同。没有参数的后置++运算符将会与前置++运算符具有相同的参数列表，这会导致编译器无法正确区分它们，从而导致编译错误。</p> 
</blockquote> 
<p><strong>前置–</strong></p> 
<pre><code class="prism language-cpp">self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>后置–</strong></p> 
<pre><code class="prism language-cpp">		self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h4><a id="_585"></a>⑤==和!=</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token comment">//_node 是指向当前节点的指针，比较 _node 和 s._node 是否相等，如果不相等返回 true，否则返回 false。</span>
	<span class="token keyword">return</span> _node <span class="token operator">!=</span> s<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token comment">//s是另一个迭代器对象,</span>
	<span class="token keyword">return</span> _node <span class="token operator">==</span> s<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h4><a id="_598"></a>⑥*运算符</h4> 
<pre><code class="prism language-cpp">		<span class="token comment">//这个重载函数的目的是允许通过迭代器访问当前节点的数据。</span>
		<span class="token comment">//Ref：表示解引用运算符返回的类型。</span>
		<span class="token comment">//</span>
		Ref <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
<span class="token comment">//是指向当前节点存储数据的成员变量 _data。通过返回 _data 的引用，允许用户通过</span>
<span class="token comment">//迭代器解引用（使用 *it）来访问和修改节点中存储的数据。</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h4><a id="_612"></a>⑦-&gt;运算符</h4> 
<pre><code class="prism language-cpp">		<span class="token comment">//Ptr：表示指针访问运算符返回的类型。</span>
		<span class="token comment">//返回节点数据的地址</span>
		Ptr <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>应用：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_year <span class="token operator">=</span> year<span class="token punctuation">;</span>
		_month <span class="token operator">=</span> month<span class="token punctuation">;</span>
		_day <span class="token operator">=</span> day<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	mylist<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span> lt<span class="token punctuation">;</span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2023</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//cout &lt;&lt; (*it)._year &lt;&lt;" "&lt;&lt;(*it)._month&lt;&lt; " "&lt;&lt; (*it)._day&lt;&lt;endl;</span>
        
		cout <span class="token operator">&lt;&lt;</span> it<span class="token operator">-&gt;</span>_year <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-&gt;</span>_month <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-&gt;</span>_day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		it<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>`(*it)：</li></ul> 
<p><code>it</code> 是一个迭代器，<code>*it</code> 使用解引用运算符 <code>*</code> 来获取迭代器所指向的 <code>Date</code> 对象。<code>(*it)</code> 是一个 <code>Date</code> 对象的引用。</p> 
<ul><li><code>(*it)._year</code><strong>、<code>(*it)._month</code></strong>、<code>(*it)._day</code>：</li></ul> 
<p>通过 <code>(*it)</code> 获取的 <code>Date</code> 对象，可以访问其成员变量 <code>_year</code>、<code>_month</code> 和 <code>_day</code>。这三部分分别获取 <code>Date</code> 对象的年、月和日。</p> 
<p>也可以用-&gt;直接访问成员<br><img src="https://images2.imgbox.com/1b/ef/T4O9t67J_o.png" alt="image.png"><br>C++ 编译器在处理 <code>it-&gt;</code> (<code>相当于it.operator-&gt;()</code>)这个表达式时，会进行以下操作：</p> 
<ol><li><strong>首先</strong>，<code>it-&gt;</code> 调用 <code>operator-&gt;()</code> 方法。这个方法返回一个 <code>Date</code> 对象的指针（<code>Date*</code>）。</li><li><strong>其次</strong>，返回的 <code>Date*</code> 指针用于访问 <code>Date</code> 对象的成员，比如 <code>it-&gt;_year</code>。</li></ol> 
<p>为了使代码更加简洁和可读，C++ 编译器允许我们直接使用 <code>it-&gt;</code> 来访问数据成员，而无需显式地进行两次箭头运算。这个处理方式避免了冗余的箭头操作，使得代码更为直观。<br> </p> 
<h3><a id="4list_670"></a>4.list结构体模板</h3> 
<p></p> 
<h4><a id="_672"></a>①默认成员函数</h4> 
<ul><li><strong>构造函数1. 默认构造函数</strong></li></ul> 
<p>先构造一个头结点，然后让_next和_prev都指向自己就行了<br><img src="https://images2.imgbox.com/c8/79/gHAZnYs0_o.png" alt="image.png"></p> 
<pre><code class="prism language-cpp">    <span class="token comment">//	这个以后会经常用到</span>
    <span class="token keyword">void</span> <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//用于创建一个新的链表节点对象，并将 _head 指针指向这个新创建的节点。</span>
			_head <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token punctuation">;</span>
			_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
			_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//构造函数</span>
		<span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>构造函数2. 用n个相同的值初始化</strong></li></ul> 
<pre><code class="prism language-cpp">		<span class="token function">list</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>构造函数3.迭代器区间初始化</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">//使用迭代器区间初始化</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">&gt;</span><span class="token comment">//取名为InputIterator说明可以用任意类型的迭代器构造</span>
<span class="token function">list</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> last<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复用push_back</span>
        first<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">&gt;</span>
</code></pre> 
<ul><li><strong>目的</strong>: 声明一个模板函数，允许使用任意类型的迭代器来初始化 <code>list</code> 对象。</li><li><strong>解释</strong>: <code>InputIterator</code> 是一个模板参数，表示输入迭代器类型。这样，构造函数可以接受各种支持迭代器接口的类型（如指针、标准库中的迭代器等）。</li></ul> 
<pre><code class="prism language-cpp"><span class="token function">list</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>目的</strong>: 定义一个构造函数，该构造函数接收两个迭代器 <code>first</code> 和 <code>last</code>，表示一个迭代器区间。</li><li><strong>解释</strong>: 这两个迭代器标识了区间的起始位置 <code>first</code> 和结束位置 <code>last</code>。构造函数会从 <code>first</code> 开始，直到 <code>last</code> 之前的位置，依次将区间内的元素插入到 <code>list</code> 中。</li></ul> 
<p>构造函数2. 用n个相同的值初始化 和 构造函数3.迭代器区间初始化 在某些情况下可能会发生冲突</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">test_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    mylist<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">lt</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> e<span class="token operator">:</span>lt<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
            cout<span class="token operator">&lt;&lt;</span>e<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当你写下如下代码：<br><code> mylist::list&lt;int&gt; lt(6,3);</code><br>你希望使用的是构造函数2，即创建一个包含 6个值 3 的 <code>list</code>。但是，由于 <code>6</code> 和 <code>3</code> 也可以被视为两个迭代器，编译器可能会错误地选择构造函数3（迭代器区间初始化），因为两个整数也可以被视为迭代器范围。此时会导致编译错误或者运行时错误。<br> 为了避免这种冲突，可以为用 <code>n</code> 个相同的值初始化的构造函数增加一个额外的参数（比如 <code>int</code> 类型的参数），使其更加明确。修改后的构造函数如下：</p> 
<pre><code class="prism language-cpp"><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>构造函数4.初始化列表初始化</strong></li></ul> 
<p><strong>方法1：迭代器遍历插入</strong><br> 手动遍历初始化列表，通过迭代器逐个插入元素到列表中。实现简单，易于理解，但略显冗长。</p> 
<pre><code class="prism language-cpp"><span class="token function">list</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ilt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token comment">//使用初始化列表的迭代器进行遍历，从头到尾一个一个元素地插入到列表中。</span>
<span class="token comment">//push_back 函数会将元素添加到列表的末尾。</span>
    <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> ilt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>it <span class="token operator">!=</span> ilt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 复用 push_back 函数</span>
        it<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<blockquote> 
 <p><code>initializer_list&lt;T&gt;</code> 是 C++11 引入的一种标准库类型，用于支持初始化列表语法。它使得可以用花括号括起来的逗号分隔列表来初始化对象，如数组、容器或其他类。</p> 
 <p><code>initializer_list&lt;T&gt;</code> 的概念<br> <code>initializer_list&lt;T&gt;</code> 是一个模板类，允许你传递一个类型为 <code>T</code> 的常量数组，并通过迭代器遍历该数组的元素。它主要用于让类或函数能够接受一个花括号包围的元素列表。<br> 使用 <code>initializer_list&lt;T&gt;</code></p> 
</blockquote> 
<p><strong>方法2：范围 for 循环</strong>：<br>使用范围 for 循环遍历初始化列表并插入元素。语法更加简洁，易读性更高。</p> 
<pre><code class="prism language-cpp"><span class="token function">list</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ilt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> ilt<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//使用范围 for 循环遍历初始化列表中的所有元素，</span>
<span class="token comment">//并使用 push_back 函数将每个元素添加到列表的末尾。这种方式比迭代器遍历更加简洁和易读。</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>方法3：现代写法</strong>：<br>利用迭代器初始化的构造函数和 <code>std::swap</code> 进行优化。代码简洁高效，但需要对临时对象和 <code>std::swap</code> 的用法有所了解。</p> 
<pre><code class="prism language-cpp"><span class="token function">list</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ilt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">tmp</span><span class="token punctuation">(</span>ilt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ilt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 复用迭代器初始化的函数，构造出临时对象</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_head<span class="token punctuation">,</span> tmp<span class="token punctuation">.</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换哨兵位节点指针</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>利用已有的迭代器区间初始化的构造函数，创建一个临时 <code>list</code> 对象 <code>tmp</code>。这个临时对象 <code>tmp</code> 会包含初始化列表中的所有元素。 <br> 交换当前对象的哨兵节点和临时对象 <code>tmp</code> 的哨兵节点。通过这种交换，当前对象的 <code>list</code> 就会包含初始化列表中的所有元素，而 <code>tmp</code> 的哨兵节点会变为空列表的哨兵节点。当 <code>tmp</code> 被销毁时，它的哨兵节点将指向空列表，从而避免访问非法内存。</p> 
<ul><li><strong>拷贝构造函数</strong></li></ul> 
<p><strong>传统写法：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">//l1(l2);</span>
<span class="token comment">//拷贝构造(深拷贝)   一个节点一个节点的拷贝</span>
<span class="token function">list</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//深拷贝的关键步骤：</span>
<span class="token comment">//节点复制：</span>
<span class="token comment">//每次调用 push_back(e) 时，都创建一个新的 ListNode 对象，</span>
<span class="token comment">//并将 e 的值复制到新节点的 data 成员中。</span>
</code></pre> 
<p><strong>现代写法：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 拷贝构造 - 现代写法</span>
<span class="token comment">// lt2(lt1)</span>
<span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">tmp</span><span class="token punctuation">(</span>lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 迭代器区间构造</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_head<span class="token punctuation">,</span> tmp<span class="token punctuation">.</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换哨兵位指针</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>解释：<br><code>list&lt;T&gt; tmp(lt.begin(), lt.end());</code> 这行代码使用迭代器区间 <code>[lt.begin(), lt.end())</code> 来构造一个临时的 <code>list</code> 对象 <code>tmp</code>。这个临时对象包含了 <code>lt</code> 中的所有元素。 <br><code>std::swap(_head,tmp._head);</code>这行代码使用 <code>std::swap</code> 函数交换当前对象的哨兵节点 <code>_head</code> 和临时对象 <code>tmp</code> 的哨兵节点 <code>tmp._head</code>。</p> 
<ul><li> <p><code>std::swap</code> 交换两个指针的值，这意味着现在 <code>tmp._head</code> 指向了新创建的哨兵节点，而当前对象的 <code>_head</code> 指向了包含 <code>lt</code> 元素的节点链表。</p> </li><li> <p>这一步是关键，因为这样一来，当前对象就获得了 <code>tmp</code> 中的所有元素，而临时对象 <code>tmp</code> 在出作用域时会被销毁，其原来的哨兵节点会被释放。</p> </li><li> <p><strong>赋值运算符重载函数</strong></p> </li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">//l1=l2</span>
list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">!=</span><span class="token operator">&amp;</span>lt<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span>e <span class="token operator">:</span>lt<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>为什么返回类型是 list &amp;的引用？？？</strong></p> 
 <ul><li>链式调用</li></ul> 
</blockquote> 
<pre><code>返回对当前对象的引用（* this），可以实现链式调用。链式调用允许多个赋值操作连在一起写。例如：
</code></pre> 
<blockquote> 
 <pre><code>  	list&lt;int&gt; lt1;
  	list&lt;int&gt; lt2;
  	list&lt;int&gt; lt3;
  	lt1 = lt2 = lt3;
</code></pre> 
 <p>在上面的代码中，lt2 = lt3 返回的是 lt2 的引用，接着 lt1 = lt2 也可以正常工作。这种方式使得代码更简洁和直观。</p> 
 <ul><li>提高代码效率</li></ul> 
</blockquote> 
<pre><code>返回引用避免了不必要的对象拷贝。在赋值运算符函数中，返回 * this 的引用，而不是返回一个新的对象，可以减少对象拷贝，提升代码的性能和效率。
</code></pre> 
<blockquote> 
 <ul><li>符合 C++ 的惯例</li></ul> 
</blockquote> 
<p>在 C++ 中，赋值运算符通常返回左值引用，以符合语言习惯和标准库的设计。这样做使得自定义类型的行为与内置类型一致，从而提高代码的可读性和可维护性。</p> 
<p>现代写法<br>同样也是用swap</p> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_head<span class="token punctuation">,</span> tmp<span class="token punctuation">.</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> lt<span class="token punctuation">)</span><span class="token comment">//不能用引用</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">swap</span><span class="token punctuation">(</span>lt<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p></p> 
</blockquote> 
<h5><a id="_898"></a>为什么不能传引用？</h5> 
<blockquote> 
 <p>当我们使用传值时，函数参数 <code>lt</code> 会在函数调用时被复制。这个复制操作会创建一个临时对象（拷贝副本），该对象在函数体内可以安全地操作。传值的好处是：</p> 
 <ol><li><strong>异常安全性</strong>：如果在复制对象时发生异常，原对象不会受到影响，因为赋值操作还没有进行。</li><li><strong>自我赋值</strong>：通过传值，我们不需要额外检查自我赋值（如 <code>a = a</code>），因为我们在函数体内操作的是拷贝副本。</li><li><strong>简洁的实现</strong>：传值和使用 <code>swap</code> 技术相结合，使得赋值运算符的实现非常简洁明了。</li></ol> 
</blockquote> 
<p>如果我们传引用，可能会引发一些问题，比如：</p> 
<blockquote> 
 <ul><li><strong>异常安全性</strong>：传引用时，如果在赋值过程中发生异常，原对象的状态可能会变得不一致或部分修改。</li><li><strong>自我赋值检测</strong>：需要额外的代码来检测和处理自我赋值的情况。</li></ul> 
</blockquote> 
<ul><li><strong>析构函数</strong></li></ul> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			iterator it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token comment">//begin() 和 end() 方法是属于包含这些方法的类的成员函数，它们在不传递参数的情况下会被假定为作用于当前对象（即 this 指针指向的对象）。</span>
			<span class="token punctuation">{<!-- --></span>
				it <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//erase 会返回被删除节点的下一个节点</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token comment">//erase 会有迭代器失效问题</span>



		<span class="token comment">//析构函数</span>
		<span class="token comment">//注意析构需要把带哨兵位的头结点也要去掉.和清空不一样</span>
		<span class="token operator">~</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">delete</span> _head<span class="token punctuation">;</span>
			_head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h4><a id="_934"></a>②迭代器</h4> 
<pre><code class="prism language-cpp">		iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//return iterator(_head-&gt;_next);  下面这个也可以，因为可以简单点写，因为隐式类型转换， 迭代器是单参数的构造函数？？？</span>
			<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
		<span class="token comment">//对于带头节点的双向循环链表，_head 节点实际上是链表的“尾部”。</span>
        <span class="token comment">//因为链表的最后一个有效节点的下一个节点是 _head，所以返回 _head 可以表示链表的末尾位置。</span>
		<span class="token punctuation">}</span>
		const_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		const_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>return _head-&gt;_next 和 return iterator(_head-&gt;_next) 在某些情况下可以看起来是一样的，但它们的行为是不同的，具体取决于上下文和类型的隐式转换。<br>/*return _head-&gt;_next 和 return iterator(_head-&gt;_next) 在某些情况下可以看起来是一样的，但它们的行为是不同的，具体取决于上下文和类型的隐式转换。</p> 
<ol><li><code>return _head-&gt;_next</code><br> 假设 _head-&gt;_next 是一个 Node * 类型的指针。如果 iterator 类型的构造函数接受 Node * 类型的参数，并且在返回时能够自动转换，那么 return _head-&gt;_next 可以看起来像是在返回一个 iterator 对象。实际上，如果 iterator 的构造函数接受 Node * ，_head-&gt;_next 会通过这个构造函数隐式地转换为 iterator 类型。<br></li><li><code> return iterator(_head-&gt;_next)</code><br> 这是一个显式的构造函数调用，它直接创建一个 iterator 对象，使用 Node * 参数 _head-&gt;_next 来初始化它。这里明确地调用了 iterator 的构造函数来创建一个新的 iterator 实例。<br> </li></ol> 
<h4><a id="_963"></a>③增删查改</h4> 
<pre><code class="prism language-cpp"><span class="token comment">//获取第一个数据的内容</span>
        T<span class="token operator">&amp;</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回第一个数据的引用</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">{<!-- --></span>
        	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回第一个数据的const引用</span>
        <span class="token punctuation">}</span>
<span class="token comment">//获取最后一个数据的内容</span>
        T<span class="token operator">&amp;</span> <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回尾结点数据的引用</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">{<!-- --></span>
    	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回最后一个有效数据的const引用</span>
        <span class="token punctuation">}</span>

<span class="token comment">//头删</span>
        <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//erase(_head-&gt;_next);</span>
			<span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token comment">//尾删</span>
        <span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//erase(_head-&gt;_prev);</span>
			<span class="token function">erase</span><span class="token punctuation">(</span><span class="token operator">--</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//为何用--end()？？？</span>
			<span class="token comment">//end() 函数：</span>
			<span class="token comment">//	end() 函数返回的是指向链表结尾的迭代器，通常是指向哨兵节点（尾后节点）的迭代器。</span>
			<span class="token comment">//--end() 操作：</span>
			<span class="token comment">//	end() 返回的迭代器通常指向链表的尾后位置，即哨兵节点的位置。--end() 操作将这个迭代器前移一个位置，</span>
            <span class="token comment">//  指向链表中最后一个实际节点的位置。</span>

<span class="token comment">//头插</span>
		<span class="token keyword">void</span> <span class="token function">push_front</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token comment">//尾插</span>
		<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//insert(end(), x);  //复用insert的版本</span>

			<span class="token comment">//画图看就比较清晰了</span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
			Node<span class="token operator">*</span> tail <span class="token operator">=</span> _head<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span> <span class="token comment">//head的前一个节点是尾节点，下一个节点是头结点</span>

			tail<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> tail<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
			_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

<span class="token comment">//在pos位置插入数据</span>
		<span class="token comment">// vector insert会导致迭代器失效</span>
		<span class="token comment">// list会不会？不会</span>
		iterator <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token comment">//返回：  可以简单点写，因为隐式类型转换， 迭代器是单参数的构造函数</span>
			<span class="token comment">//push_back 就可以复用insert了</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
			Node<span class="token operator">*</span> prev <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// head------&gt;prev----&gt;cur---&gt;node1---&gt;node2   向右是next 向左是prev</span>
			<span class="token comment">//                newnode</span>
			prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			cur<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

			<span class="token comment">//return interator(newnode); 也可以 ，为什么？？？</span>
			<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

<span class="token comment">//删除pos位置的数据</span>
		iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
		<span class="token comment">//. 用于对象，而 -&gt; 用于指针。</span>
		<span class="token comment">//pos 是一个迭代器对象，它不是指针。因此我们使用 . 操作符来访问迭代器对象的成员变量 _node。</span>
			Node<span class="token operator">*</span> prev <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			Node<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token punctuation">;</span>
			next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
			<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
			<span class="token keyword">return</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h4><a id="_1059"></a>④其他操作</h4> 
<p><strong>size:获取有效数据的个数</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">//长度</span>
size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//遍历统计</span>
    size_t sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    iterator it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token operator">++</span>sz<span class="token punctuation">;</span>
        <span class="token operator">++</span>it<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sz<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>clear：清空链表内容</strong></p> 
<pre><code class="prism language-cpp">
		<span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 检查链表是否为空，如果为空则直接返回</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//begin() 和 end() 方法是属于包含这些方法的类的成员函数，它们在不传递参数的情况下会被假定为作用于当前对象（即 this 指针指向的对象）。</span>
			iterator it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 调用 erase 方法并将 it 更新为被删除节点的下一个节点</span>
				it <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//erase 会返回被删除节点的下一个节点</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 哨兵节点重新指向自己，确保后续插入操作不会出错</span>
			_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
			_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p><strong>empty:判断链表是否为空</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>swap</strong><br>swap函数用于交换两个list,list容器当中的成员变量只有指向哨兵位结点的指针,我们将这两个容器当中的哨兵位指针交换即可,</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_head<span class="token punctuation">,</span> lt<span class="token punctuation">.</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接交换两个容器的哨兵位即可,此处用的是全局域std命名空间里面的swap函数</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>resize</strong></p> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 新大小大于当前大小，添加新节点</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 新大小小于当前大小，删除多余的节点</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				iterator it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				size_t pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token comment">// 遍历到需要删除的位置</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token operator">++</span>it<span class="token punctuation">;</span>
					<span class="token operator">++</span>pos<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// 从当前位置删除到链表末尾</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					it <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h3><a id="5_1149"></a>5.完整代码展示以及详细注释</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;assert.h&gt;</span></span>
<span class="token comment">//这节 简单讲了一下使用，然后大部分是模拟实现。</span>
<span class="token comment">//1. 有个地方要有合适的 构造函数</span>
<span class="token comment">//2.迭代器如何实现+1 如何自动跳到下一个节点的？</span>



<span class="token comment">//———————————————————————————————————————————————————以下部分为便于理解整体逻辑框架结构而写的</span>
<span class="token comment">//分为以下几大部分：</span>
<span class="token comment">//节点结构体模板、__list_iterator 结构体模板、list结构体模板（由一个个节点组成）、测试函数。</span>
<span class="token comment">//</span>
<span class="token comment">//———————————————————————————————————————————————————以下部分为便于理解整体逻辑框架结构而写的</span>
<span class="token comment">//分为以下几大部分：</span>
<span class="token comment">//	节点结构体模板</span>
<span class="token comment">//	__list_iterator 结构体模板</span>
<span class="token comment">//	list结构体模板（由一个个节点组成）</span>
<span class="token comment">//	测试函数</span>
<span class="token comment">//首先，我们定义了一个节点结构体模板 ListNode，它包含：</span>
<span class="token comment">//</span>
<span class="token comment">//	ListNode* 类型的 _next 和 _prev 指针，分别指向前后节点。</span>
<span class="token comment">//	T 类型的 _data，存放节点的数据。</span>
<span class="token comment">//	ListNode 的构造函数初始化这些成员。</span>
<span class="token comment">//然后，我们定义了一个模板结构体 __list_iterator，用于实现链表的迭代器。这个迭代器包含：</span>
<span class="token comment">//</span>
<span class="token comment">//	一个指向当前节点的指针 _node。</span>
<span class="token comment">//	构造函数、前置和后置 ++、-- 运算符重载、解引用运算符、相等和不相等比较运算符等操作。</span>
<span class="token comment">//为了简化代码，__list_iterator 使用了两个 typedef：</span>
<span class="token comment">//	将 ListNode&lt;T&gt; 重命名为 Node。</span>
<span class="token comment">//	将 __list_iterator&lt;T, Ref, Ptr&gt; 重命名为 self。</span>
<span class="token comment">//接下来，我们实现了 list 结构体模板。它包含一个带哨兵位的头结点 _head，类型为 Node* 。通过这个头结点以及迭代器指向的各个节点，形成一个带头的双向循环链表。</span>
<span class="token comment">//</span>
<span class="token comment">//在 list 中，我们将 __list_iterator&lt;T, T&amp;, T*&gt; 重命名为 iterator，将 __list_iterator&lt;T, const T&amp;, const T*&gt; 重命名为 const_iterator，</span>
<span class="token comment">//一种是普通迭代器，一种是常量迭代器，以便用户更方便地使用迭代器。</span>
<span class="token comment">//</span>
<span class="token comment">//通过这些定义，我们实现了一个功能完整的双向循环链表，并且提供了迭代器接口，使得用户可以方便地遍历和操作链表中的元素。</span>
<span class="token comment">//</span>
<span class="token comment">//这个结构通过 ListNode 实现了双向节点连接，通过 __list_iterator 实现了链表的遍历和操作接口，并通过 list 结构体模板实现了整体的双向循环链表功能。测试函数用于验证各部分的功能和接口是否正常运行。</span>
<span class="token comment">//</span>















<span class="token comment">// 声明一个命名空间 mylist</span>
<span class="token keyword">namespace</span> mylist
<span class="token punctuation">{<!-- --></span>

	<span class="token comment">// 定义一个模板结构体 ListNode，表示链表的节点</span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token comment">//每个模板类或模板函数的定义都需要用 template&lt;class T&gt; 来声明。这样做的原因是为了告诉编译器这个类或函数是一个模板，且它是依赖于一个类型参数 T</span>
	<span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
	<span class="token punctuation">{<!-- --></span>
		
		<span class="token comment">// 构造函数，使用默认参数 T() 初始化 _data，并将 _next 和 _prev 初始化为 nullptr</span>
		<span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token operator">:</span><span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>  <span class="token comment">//记得加上 ,</span>
			<span class="token punctuation">,</span> <span class="token function">_data</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
		ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span><span class="token comment">/// 指向下一个节点的指针</span>
		ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _prev<span class="token punctuation">;</span><span class="token comment">// 指向上一个节点的指针</span>
		T _data<span class="token punctuation">;</span>		   <span class="token comment">// 节点存储的数据</span>

	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//ListNode(const T&amp; x = T())  必须加上 =T()  !!!</span>
		<span class="token comment">//默认参数的提供：</span>
		<span class="token comment">//	构造函数中的 = T() 表示如果调用者在创建 ListNode 对象时没有提供参数 x，则会使用 T() 这个默认值来初始化 _data 成员变量。</span>
		<span class="token comment">//	灵活性：</span>
		<span class="token comment">//	这种构造函数提供了更大的灵活性。如果调用者提供了参数 x，则会使用提供的值来初始化节点的 _data 成员；如果没有提供参数 x，则会使用 T() 的默认构造函数生成一个默认值来初始化 _data。</span>
		<span class="token comment">//	适用性：</span>
		<span class="token comment">//	对于链表节点来说，可能存在需要默认构造的情况，例如默认构造一个空节点或者默认值为特定类型的情况。通过提供默认参数，可以简化在某些场景下节点的创建。</span>


	<span class="token comment">//结构体（struct）？？？</span>
	<span class="token comment">//	是一种自定义数据类型，用于将多个相关的变量组合在一起。结构体可以包含基本数据类型、指针、引用、其他结构体、类等成员。与类（class）的主要区别在于结构体的默认访问控制是公有的（public），</span>
	<span class="token comment">//	而类的默认访问控制是私有的（private）。</span>
	<span class="token comment">//带有构造函数的结构体：</span>
	<span class="token comment">//	结构体可以包含构造函数，用于初始化成员变量。函数名就是结构体名</span>

	<span class="token comment">//为什么ListNode&lt;T&gt;* _prev; 要加&lt;T&gt;???</span>
	<span class="token comment">//	模板类 ListNode 是一个通用类型，它可以被实例化为不同的数据类型。加上 &lt;T&gt; 是为了告诉编译器 _next 是一个指向相同类型的 ListNode 实例的指针。</span>
	<span class="token comment">//	这里，ListNode 是一个模板类，它可以用任何类型的 T 来实例化。例如，你可以有一个 ListNode&lt;int&gt; 用于整数类型，或者一个 ListNode&lt;double&gt; 用于浮点数类型。</span>
	<span class="token comment">//	ListNode&lt;int&gt;* intNode;</span>
	<span class="token comment">//	ListNode&lt;double&gt;* doubleNode;</span>
	<span class="token comment">//在模板类的内部，也需要指定具体类型。例如，当定义 _next 指针时，需要明确它指向的是哪种类型的 ListNode，因此使用 ListNode&lt;T&gt;*。如果不加 &lt;T&gt;，编译器将不知道 _next 是指向哪个具体实例化类型的 ListNode。</span>
	<span class="token comment">//	比如：</span>
	<span class="token comment">//	ListNode&lt;int&gt; node;</span>
	<span class="token comment">//	node._next = new ListNode&lt;int&gt;(5);  // 正确，_next 是指向 ListNode&lt;int&gt; 的指针</span>

	<span class="token comment">//	ListNode&lt;double&gt; dnode;</span>
	<span class="token comment">//	dnode._next = new ListNode&lt;double&gt;(3.14);  // 正确，_next 是指向 ListNode&lt;double&gt; 的指针</span>





	<span class="token comment">//定义一个模板结构体 __list_iterator，用于实现链表的迭代器</span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token operator">&gt;</span>
	<span class="token keyword">struct</span> <span class="token class-name">__list_iterator</span>
	<span class="token punctuation">{<!-- --></span>	
		<span class="token keyword">typedef</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>					<span class="token comment">// 定义节点类型的别名</span>
		<span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Ref<span class="token punctuation">,</span> Ptr<span class="token operator">&gt;</span> self<span class="token punctuation">;</span>  <span class="token comment">// 定义迭代器类型的别名</span>
		<span class="token comment">//__list_iterator 被定义为一个模板结构体，并且引入了三个模板参数：T, Ref, 和 Ptr。通过不同的类型实例化 Ref 和 Ptr，我们可以区分出普通迭代器和常量迭代器。</span>
		
		Node<span class="token operator">*</span> _node<span class="token punctuation">;</span>					 <span class="token comment">// 指向链表节点的指针</span>

		<span class="token comment">//构造函数，接受一个节点指针</span>
		<span class="token function">__list_iterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> x<span class="token punctuation">)</span>
			<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
		<span class="token comment">//__list_iterator 的构造函数接受一个指向 ListNode&lt;T&gt; 的指针 x，然后将 _node 成员变量初始化为 x。因此，每个 __list_iterator&lt;T&gt; 对象都包含一个指向 ListNode&lt;T&gt; 的指针 _node。</span>
		<span class="token comment">//另外：构造函数的名字必须与类的名字完全相同，不能使用类型的别名代替构造函数的名字。 上面self(Node* x)  是错的</span>




		<span class="token comment">// 前置++运算符重载，使迭代器指向下一个节点。</span>
		<span class="token comment">//++it</span>
		self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//为什么返回引用</span>
		<span class="token comment">//这里的前置++运算符重载返回的是一个引用，即 self &amp; 。它的作用是使迭代器向前移动到下一个节点，并返回移动后的迭代器对象自身。这种形式的重载通常在使用时会直接对迭代器进行修改，并返回修改后的对象的引用，以便支持链式操作。</span>

		<span class="token comment">//前置++运算符不需要任何参数，只需将迭代器移动到下一个位置并返回自身的引用即可。具体来说，它会将迭代器所指向的节点指针 _node 移动到下一个节点 _next，然后返回当前对象自身的引用 (*this)。</span>

		<span class="token comment">//后置++运算符重载，使迭代器指向下一个节点，并返回之前的迭代器</span>
		<span class="token comment">//it++</span>
		self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 1. 创建一个名为 tmp 的临时迭代器对象，它通过调用 __list_iterator 的拷贝构造函数，用当前迭代器 *this 进行初始化。</span>
			self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建一个临时迭代器对象，保存当前迭代器的状态</span>
			<span class="token comment">// 2. 将当前迭代器移动到下一个节点</span>
			_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token comment">// 3. 返回之前的迭代器状态</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//后置++为什么有(int)？？？</span>
		<span class="token comment">//后置++运算符重载接受一个额外的 int 参数（这里没有实际使用它，只是为了区分前置和后置++），并返回一个值而不是引用。</span>
		<span class="token comment">//C++中的后置++运算符必须在参数列表中声明一个int类型的参数，以便与前置++运算符进行区分。这种参数实际上并没有用处，只是为了在编译器中区分前置和后置++运算符的不同。没有参数的后置++运算符将会与前置++运算符具有相同的参数列表，这会导致编译器无法正确区分它们，从而导致编译错误。</span>
	
		
		self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//这个重载函数的目的是允许通过迭代器访问当前节点的数据。</span>
		<span class="token comment">//Ref：表示解引用运算符返回的类型。</span>
		<span class="token comment">//</span>
		Ref <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span><span class="token comment">//是指向当前节点存储数据的成员变量 _data。通过返回 _data 的引用，允许用户通过迭代器解引用（使用 *it）来访问和修改节点中存储的数据。</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//有点难理解</span>
		<span class="token comment">//Ptr：表示指针访问运算符返回的类型。</span>
		<span class="token comment">//返回节点数据的地址</span>
		Ptr <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//上面俩的解释：</span>
				<span class="token comment">//对于普通迭代器，Ref 是 T&amp; ，所以 operator*() 返回节点数据的引用，允许修改数据。</span>
				<span class="token comment">//对于常量迭代器，Ref 是 const T&amp; ，所以 operator*() 返回节点数据的常量引用，不允许修改数据。</span>

				<span class="token comment">//对于普通迭代器，Ptr 是 T* ，所以 operator-&gt;() 返回指向节点数据的指针，允许通过指针修改数据。</span>
				<span class="token comment">//对于常量迭代器，Ptr 是 const T* ，所以 operator-&gt;() 返回指向节点数据的常量指针，不允许通过指针修改数据。</span>




		<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token comment">//_node 是指向当前节点的指针，比较 _node 和 s._node 是否相等，如果不相等返回 true，否则返回 false。</span>
			<span class="token keyword">return</span> _node <span class="token operator">!=</span> s<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token comment">//s是另一个迭代器对象,</span>
			<span class="token keyword">return</span> _node <span class="token operator">==</span> s<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>


		<span class="token comment">//迭代器为什么不提供析构函数</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">list</span>
	<span class="token punctuation">{<!-- --></span>
		
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">typedef</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
		<span class="token comment">/*typedef __list_iterator&lt;T&gt; iterator;*/</span>
		<span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> iterator<span class="token punctuation">;</span>                     <span class="token comment">//定义普通迭代器</span>
		<span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> const_iterator<span class="token punctuation">;</span>   <span class="token comment">//定义常量迭代器</span>
		<span class="token comment">//这样，iterator 和 const_iterator 都使用同一个 __list_iterator 结构体模板，只是通过不同的模板参数实例化，分别实现普通迭代器和常量迭代器的功能。</span>
		<span class="token comment">//第一个 三个参数 T,Ref，Ptr分别就是，T,T&amp;,T*.   </span>
		<span class="token comment">//第二个 三个参数 T,Ref，Ptr分别就是  T,const T&amp;,const T*</span>

		<span class="token comment">// 反向迭代器</span>
		<span class="token comment">//typedef ReverseListIterator&lt;iterator&gt; reverse_iterator;</span>
		<span class="token comment">//typedef ReverseListIterator&lt;const_iterator&gt; const_reverse_iterator;</span>


		<span class="token comment">//访问</span>
		iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//return iterator(_head-&gt;_next);  下面这个也可以，因为可以简单点写，因为隐式类型转换， 迭代器是单参数的构造函数？？？</span>
			<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
		<span class="token comment">//对于带头节点的双向循环链表，_head 节点实际上是链表的“尾部”。因为链表的最后一个有效节点的下一个节点是 _head，所以返回 _head 可以表示链表的末尾位置。</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">/*return _head-&gt;_next 和 return iterator(_head-&gt;_next) 在某些情况下可以看起来是一样的，但它们的行为是不同的，具体取决于上下文和类型的隐式转换。

		1. return _head-&gt;_next
		假设 _head-&gt;_next 是一个 Node * 类型的指针。如果 iterator 类型的构造函数接受 Node * 类型的参数，并且在返回时能够自动转换，那么 return _head-&gt;_next 可以看起来像是在返回一个 iterator 对象。实际上，如果 iterator 的构造函数接受 Node * ，_head-&gt;_next 会通过这个构造函数隐式地转换为 iterator 类型。

		2. return iterator(_head-&gt;_next)
		这是一个显式的构造函数调用，它直接创建一个 iterator 对象，使用 Node * 参数 _head-&gt;_next 来初始化它。这里明确地调用了 iterator 的构造函数来创建一个新的 iterator 实例。*/</span>


		const_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		const_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//用于创建一个新的链表节点对象，并将 _head 指针指向这个新创建的节点。</span>
			_head <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token punctuation">;</span>
			_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
			_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//构造函数</span>
		<span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token function">list</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">&gt;</span>
		<span class="token function">list</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> last<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
				first<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token function">list</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ilt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//使用初始化列表的迭代器进行遍历，从头到尾一个一个元素地插入到列表中。</span>
			<span class="token comment">//push_back 函数会将元素添加到列表的末尾。</span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> ilt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> ilt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 复用 push_back 函数</span>
				it<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">list</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ilt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> ilt<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//使用范围 for 循环遍历初始化列表中的所有元素，</span>
			<span class="token comment">//并使用 push_back 函数将每个元素添加到列表的末尾。这种方式比迭代器遍历更加简洁和易读。</span>
		<span class="token punctuation">}</span>

		<span class="token function">list</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ilt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">tmp</span><span class="token punctuation">(</span>ilt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ilt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 复用迭代器初始化的函数，构造出临时对象</span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_head<span class="token punctuation">,</span> tmp<span class="token punctuation">.</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换哨兵位节点指针</span>
		<span class="token punctuation">}</span>







		<span class="token comment">//拷贝构造(深拷贝)   一个节点一个节点的拷贝</span>
		<span class="token function">list</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//深拷贝的关键步骤：</span>
		<span class="token comment">//	节点复制：</span>
		<span class="token comment">//每次调用 push_back(e) 时，都创建一个新的 ListNode 对象，并将 e 的值复制到新节点的 data 成员中。</span>


		<span class="token comment">// 拷贝构造 - 现代写法</span>
		<span class="token comment">// lt2(lt1)</span>
		<span class="token comment">//list(const list&lt;T&gt;&amp; lt) {<!-- --></span>
		<span class="token comment">//	empty_init();</span>
		<span class="token comment">//	list&lt;T&gt; tmp(lt.begin(), lt.end()); // 迭代器区间构造</span>
		<span class="token comment">//	std::swap(_head, tmp._head); // 交换哨兵位指针</span>
		<span class="token comment">//}</span>



		<span class="token comment">// 拷贝构造函数，接受一个常量引用链表对象作为参数</span>
		<span class="token comment">//list(const list&lt;T&gt;&amp; lt)</span>
		<span class="token comment">//{<!-- --></span>
		<span class="token comment">//	// 初始化新链表为空链表</span>
		<span class="token comment">//	empty_init();</span>

		<span class="token comment">//	// 获取给定链表的第一个节点的迭代器</span>
		<span class="token comment">//	const_iterator it = lt.begin();</span>

		<span class="token comment">//	// 遍历给定链表的所有节点</span>
		<span class="token comment">//	while (it != lt.end())</span>
		<span class="token comment">//	{<!-- --></span>
		<span class="token comment">//		// 将节点的数据插入到新链表的末尾</span>
		<span class="token comment">//		//这里的end和lt.end()不一样</span>
		<span class="token comment">//		insert(end(), *it);</span>
		<span class="token comment">//		// 移动到下一个节点</span>
		<span class="token comment">//		++it;</span>
		<span class="token comment">//	}</span>
		<span class="token comment">//}</span>

		<span class="token comment">//list(list&lt;T&gt;&amp; lt) 是一个非常规的构造函数，接受一个非常量引用的链表对象。这样可以在需要对传入的链表进行修改的情况下使用。</span>
		<span class="token comment">//list(const list&lt;T&gt;&amp; lt) 是一个标准的拷贝构造函数，接受一个常量引用的链表对象。这样可以确保不会对传入的链表进行修改。</span>


		<span class="token comment">//赋值运算符（普通写法）</span>
		<span class="token comment">// lt1=lt2</span>
		list <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>lt<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先让lt1清空</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span> <span class="token comment">//再让lt2的数据尾插到lt1中</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
<span class="token comment">//为什么返回类型是 list &lt;T&gt;&amp;的引用？？？</span>
<span class="token comment">//		链式调用</span>
<span class="token comment">//			返回对当前对象的引用（* this），可以实现链式调用。链式调用允许多个赋值操作连在一起写。例如：</span>
<span class="token comment">//			list&lt;int&gt; lt1;</span>
<span class="token comment">//			list&lt;int&gt; lt2;</span>
<span class="token comment">//			list&lt;int&gt; lt3;</span>
<span class="token comment">//			lt1 = lt2 = lt3;</span>
<span class="token comment">//			在上面的代码中，lt2 = lt3 返回的是 lt2 的引用，接着 lt1 = lt2 也可以正常工作。这种方式使得代码更简洁和直观。</span>
<span class="token comment">//		提高代码效率</span>
<span class="token comment">//			返回引用避免了不必要的对象拷贝。在赋值运算符函数中，返回 * this 的引用，而不是返回一个新的对象，可以减少对象拷贝，提升代码的性能和效率。</span>
<span class="token comment">//		符合 C++ 的惯例</span>
<span class="token comment">//			在 C++ 中，赋值运算符通常返回左值引用，以符合语言习惯和标准库的设计。这样做使得自定义类型的行为与内置类型一致，从而提高代码的可读性和可维护性。</span>

		<span class="token comment">//赋值运算符（现代写法）</span>
		<span class="token comment">//list&amp; operator=(list lt)   // （也可以不写模板参数）也可以这样写，但仅限在类里面， 类型的时候就不行</span>

		<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_head<span class="token punctuation">,</span> tmp<span class="token punctuation">.</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> lt<span class="token punctuation">)</span><span class="token comment">//不能用引用</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">swap</span><span class="token punctuation">(</span>lt<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>





		<span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 检查链表是否为空，如果为空则直接返回</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//begin() 和 end() 方法是属于包含这些方法的类的成员函数，它们在不传递参数的情况下会被假定为作用于当前对象（即 this 指针指向的对象）。</span>
			iterator it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 调用 erase 方法并将 it 更新为被删除节点的下一个节点</span>
				it <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//erase 会返回被删除节点的下一个节点</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 哨兵节点重新指向自己，确保后续插入操作不会出错</span>
			_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
			_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		
		
		
		
		<span class="token comment">//erase 会有迭代器失效问题</span>



		<span class="token comment">//析构函数</span>
		<span class="token comment">//注意析构需要把带哨兵位的头结点也要去掉.和清空不一样</span>
		<span class="token operator">~</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">delete</span> _head<span class="token punctuation">;</span>
			_head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>


		<span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//erase(_head-&gt;_next);</span>
			<span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//erase(_head-&gt;_prev);</span>
			<span class="token function">erase</span><span class="token punctuation">(</span><span class="token operator">--</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//为何用--end()？？？</span>
				<span class="token comment">//end() 函数：</span>
				<span class="token comment">//	end() 函数返回的是指向链表结尾的迭代器，通常是指向哨兵节点（尾后节点）的迭代器。</span>
				<span class="token comment">//--end() 操作：</span>
				<span class="token comment">//	end() 返回的迭代器通常指向链表的尾后位置，即哨兵节点的位置。--end() 操作将这个迭代器前移一个位置，指向链表中最后一个实际节点的位置。</span>

		<span class="token keyword">void</span> <span class="token function">push_front</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//insert(end(), x);  //复用insert的版本</span>

			<span class="token comment">//画图看就比较清晰了</span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
			Node<span class="token operator">*</span> tail <span class="token operator">=</span> _head<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span> <span class="token comment">//head的前一个节点是尾节点，下一个节点是头结点</span>

			tail<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> tail<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
			_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>






		<span class="token comment">// vector insert会导致迭代器失效</span>
		<span class="token comment">// list会不会？不会</span>
		iterator <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token comment">//返回：  可以简单点写，因为隐式类型转换， 迭代器是单参数的构造函数</span>
			<span class="token comment">//push_back 就可以复用insert了</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
			Node<span class="token operator">*</span> prev <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// head------&gt;prev----&gt;cur---&gt;node1---&gt;node2   向右是next 向左是prev</span>
			<span class="token comment">//                newnode</span>
			prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			cur<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

			<span class="token comment">//return interator(newnode); 也可以 ，为什么？？？</span>
			<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
		<span class="token comment">//. 用于对象，而 -&gt; 用于指针。</span>
		<span class="token comment">//pos 是一个迭代器对象，它不是指针。因此我们使用 . 操作符来访问迭代器对象的成员变量 _node。</span>
			Node<span class="token operator">*</span> prev <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			Node<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token punctuation">;</span>
			next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
			<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
			<span class="token keyword">return</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//补充</span>
		size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//遍历统计</span>
			size_t sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			iterator it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token operator">++</span>sz<span class="token punctuation">;</span>
				<span class="token operator">++</span>it<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> sz<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 新大小大于当前大小，添加新节点</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 新大小小于当前大小，删除多余的节点</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				iterator it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				size_t pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token comment">// 遍历到需要删除的位置</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token operator">++</span>it<span class="token punctuation">;</span>
					<span class="token operator">++</span>pos<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// 从当前位置删除到链表末尾</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					it <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

	<span class="token keyword">private</span><span class="token operator">:</span>
		Node<span class="token operator">*</span> _head<span class="token punctuation">;</span>
		<span class="token comment">//，__list_iterator 结构体模板内的 typedef 定义了一些别名（alias），这些别名在 list 结构体模板中得以继续使用是因为它们是 __list_iterator 类型的一部分。当 list 使用 __list_iterator 时，这些别名也随之可用</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>



	<span class="token comment">//这种情况下就需要const迭代器，这是很常见的现象。</span>
	<span class="token comment">//const迭代器：自己可以修改所以不是const对象（需要it++）</span>
	<span class="token comment">//指向的内容不能修改</span>
	<span class="token keyword">void</span> <span class="token function">print_list</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
			<span class="token operator">++</span>it<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">test_list1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lt<span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		list<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token operator">*</span>it <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
			<span class="token operator">++</span>it<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


	<span class="token keyword">void</span> <span class="token function">test_list2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lt<span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token comment">//1 2 3 4</span>

		lt<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		lt<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token comment">//2 3 99</span>

		lt<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">test_list3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lt<span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">985</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//插入完后it仍然指向1</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//985 1 2 3 4</span>


		<span class="token operator">++</span>it<span class="token punctuation">;</span>
		<span class="token comment">//it指向2,在2前插入211</span>
		lt<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">211</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//985 1 211 2 3 4</span>
	<span class="token punctuation">}</span>


	<span class="token keyword">void</span> <span class="token function">test_list4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lt<span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">985</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//因为it返回的是新插入的节点的迭代器，所以it指向第一个元素985</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//985 1 2 3 4</span>


		<span class="token operator">++</span>it<span class="token punctuation">;</span>
		<span class="token comment">//it指向1,在1前插入211</span>
		lt<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">211</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// it仍然指向1</span>
		<span class="token comment">//it=lt.insert(it, 211); //it指向211</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//985 1 211 2 3 4</span>
	<span class="token punctuation">}</span>


	<span class="token comment">//讲解拷贝构造</span>
	<span class="token comment">//默认的浅拷贝 会析构两次 出现问题</span>
	<span class="token keyword">void</span> <span class="token function">test_list5</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//list&lt;int&gt; lt;</span>
		<span class="token comment">//lt.push_back(1);</span>
		<span class="token comment">//lt.push_back(2);</span>
		<span class="token comment">//lt.push_back(3);</span>
		<span class="token comment">//lt.push_back(4);</span>
		<span class="token comment">list&lt;int&gt; copy(lt);</span>
		<span class="token comment">//for (auto e : copy)</span>
		<span class="token comment">//{<!-- --></span>
		<span class="token comment">//	cout &lt;&lt; e &lt;&lt; " ";</span>
		<span class="token comment">//}</span>
	<span class="token punctuation">}</span>


	<span class="token keyword">void</span> <span class="token function">test_list6</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>

	<span class="token punctuation">}</span>


<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e6/f9/SrMqni6c_o.png" alt="07c03ae6d77b4b153f6d1ec710be7c14_7a80245f0b5f4021a033b3789a9efdeb.png"><br>📜 [ 声明 ] 由于作者水平有限，本文有错误和不准确之处在所难免，<br> 本人也很想知道这些错误，恳望读者批评指正！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/684c99fa77f71ccaf62f340297b5ef94/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java修仙之路，十万字吐血整理全网最完整Java学习笔记（高级篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/148ba57ebdf4322831aa5ac54b8509db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">map/multimap容器及STL案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>