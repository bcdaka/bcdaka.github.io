<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉树（二）遍历 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8158817cfe273a1b9c120c01843c5cc9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】二叉树（二）遍历">
  <meta property="og:description" content="上篇已经了解对二叉树有了大概了解，本篇学习二叉树的前序、中序、后序及层序遍历的递归与非递归共7种遍历方法，快收藏吧~
目录
1、前序遍历
递归方式：
迭代方式： 2、中序遍历
递归方式：
迭代方式：
3、后序遍历：
递归方式
迭代方式：
4、层序遍历
递归方式
迭代方式： 二叉树的前序、中序、后序及层序遍历的递归与非递归遍历方法
遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结 点均做一次且仅做一次访问。访问结点所做的操作依赖于具体的应用问题(比如：打印节点内容、节点内容加 1)。 遍历是二叉树上最重要的操作之一，是二叉树上进行其它运算之基础。
二叉树的遍历方法有以下四种 ：
先序遍历（根左右） 首先访问根结点，然后递归地遍历左子树，最后遍历右子树。例如对于二叉树：先序遍历的结果为：1-&gt;2-&gt;4-&gt;8-&gt;9-&gt;5-&gt;10-&gt;11-&gt;3-&gt;6-&gt;7。
中序遍历（左根右） 首先遍历左子树，然后访问根结点，最后遍历右子树。例如对于二叉树：中序遍历的结果为：8-&gt;4-&gt;9-&gt;2-&gt;10-&gt;5-&gt;11-&gt;1-&gt;6-&gt;3-&gt;7。
后序遍历（左右根） 首先遍历左子树，然后遍历右子树，最后访问根结点。例如对于二叉树：后序遍历的结果为：8-&gt;9-&gt;4-&gt;10-&gt;11-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1。
层序遍历 自上而下，自左至右逐层访问树的结点的过程就是层序遍历。 它是按广度优先搜索的策略，从根结点出发，依次访问每一层上的节点。这种策略在实际应用中使用较多，如在计算机图形学中用于渲染场景图等。例如对于二叉树：层次遍历的结果为：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;10-&gt;11
下面讲解代码，前序遍历、中序遍历和后序遍历的简单递归方法不附图讲解，主要解释它们的迭代方式及层序遍历
1、前序遍历 递归方式： 定义 preorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要首先将 root 节点的值加入答案，然后递归调用 preorder(root.left) 来遍历 root 节点的左子树，最后递归调用 preorder(root.right) 来遍历 root 节点的右子树即可，递归终止的条件为碰到空节点。
class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); preorder(root, res); return res; } public void preorder(TreeNode root, List&lt;Integer&gt; res) { if (root == null) { return; } res.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-15T17:13:03+08:00">
    <meta property="article:modified_time" content="2024-08-15T17:13:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉树（二）遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上篇已经了解对二叉树有了大概了解，本篇学习二叉树的前序、中序、后序及层序遍历的递归与非递归共7种遍历方法，快收藏吧~</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">1、前序遍历</a></p> 
<p id="%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow">递归方式：</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A%C2%A0" rel="nofollow">迭代方式： </a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">2、中序遍历</a></p> 
<p id="%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow">递归方式：</a></p> 
<p id="%C2%A0%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow"> 迭代方式：</a></p> 
<p id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">3、后序遍历：</a></p> 
<p id="%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F" rel="nofollow">递归方式</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow">迭代方式：</a></p> 
<p id="%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">4、层序遍历</a></p> 
<p id="%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F" rel="nofollow">递归方式</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A%C2%A0" rel="nofollow">迭代方式： </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>二叉树的前序、中序、后序及层序遍历的递归与非递归遍历方法</p> 
<p><strong>遍历</strong><strong>(Traversal)</strong><strong>是指沿着某条搜索路线，依次对树中每个结 </strong><strong>点均做一次且仅做一次访问</strong>。<strong>访问结点所做的操作依赖于具体的应用问题</strong><strong>(</strong><strong>比如：打印节点内容、节点内容加 </strong><strong>1)</strong>。 遍历是二叉树上最重要的操作之一，是二叉树上进行其它运算之基础。</p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/03/5a/ooJv29MC_o.png" width="600"></p> 
<p>二叉树的遍历方法有以下四种 ：</p> 
<blockquote> 
 <ul><li><strong>先序遍历</strong><span style="color:#ad720d;">（根左右）</span></li></ul> 
 <p>        首先访问根结点，然后递归地遍历左子树，最后遍历右子树。例如对于二叉树：先序遍历的结果为：1-&gt;2-&gt;4-&gt;8-&gt;9-&gt;5-&gt;10-&gt;11-&gt;3-&gt;6-&gt;7。</p> 
 <ul><li><strong>中序遍历</strong><span style="color:#ad720d;">（左根右）</span></li></ul> 
 <p>        首先遍历左子树，然后访问根结点，最后遍历右子树。例如对于二叉树：中序遍历的结果为：8-&gt;4-&gt;9-&gt;2-&gt;10-&gt;5-&gt;11-&gt;1-&gt;6-&gt;3-&gt;7。</p> 
 <ul><li><strong>后序遍历</strong><span style="color:#ad720d;">（左右根）</span></li></ul> 
 <p>        首先遍历左子树，然后遍历右子树，最后访问根结点。例如对于二叉树：后序遍历的结果为：8-&gt;9-&gt;4-&gt;10-&gt;11-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1。</p> 
 <ul><li><strong>层序遍历</strong></li></ul> 
 <p>   自上而下，自左至右逐层访问树的结点的过程就是层序遍历。      </p> 
 <p>  它是按广度优先搜索的策略，从根结点出发，依次访问每一层上的节点。这种策略在实际应用中使用较多，如在计算机图形学中用于渲染场景图等。例如对于二叉树：层次遍历的结果为：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;10-&gt;11</p> 
</blockquote> 
<p>下面讲解代码，前序遍历、中序遍历和后序遍历的简单递归方法不附图讲解，主要解释它们的迭代方式及层序遍历</p> 
<hr> 
<h2 id="1%E3%80%81%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">1、前序遍历</h2> 
<h3 id="%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%9A">递归方式：</h3> 
<p>定义 preorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要首先将 root 节点的值加入答案，然后递归调用 preorder(root.left) 来遍历 root 节点的左子树，最后递归调用 preorder(root.right) 来遍历 root 节点的右子树即可，<span style="color:#fe2c24;"><strong>递归终止的条件为碰到空节点。</strong></span></p> 
<pre><code>class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode root, List&lt;Integer&gt; res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorder(root.left, res);
        preorder(root.right, res);
    }
}</code></pre> 
<p><strong>复杂度分析</strong></p> 
<blockquote> 
 <p><strong>时间复杂度：O(n)</strong>，<strong>其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</strong></p> 
 <p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p> 
</blockquote> 
<h3 id="%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A%C2%A0">迭代方式： </h3> 
<p>迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。</p> 
<pre><code>class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        if(root==null) return res;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode p = stack.pop();
            res.add(p.val);
            if(p.right!=null)
            stack.push(p.right);
            if(p.left!=null
            )stack.push(p.left);
        }
        return res;
    }
}</code></pre> 
<p><span style="color:#ad720d;"><strong>注释： 先将root压栈，进入 while 循环，每循环一次栈顶出栈一次并记录该结点，将其左结点右结点压栈，栈为空退出循坏。</strong></span></p> 
<blockquote> 
 <p><strong>时间复杂度：O(n)</strong>，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p> 
 <p>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p> 
</blockquote> 
<hr> 
<h2 id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">2、中序遍历</h2> 
<h3>递归方式：</h3> 
<p>定义 inorder(root) 表示当前遍历到 root 节点的答案，那么按照定义，我们只要递归调用 inorder(root.left) 来遍历 root 节点的左子树，然后将 root 节点的值加入答案，再递归调用inorder(root.right) 来遍历 root 节点的右子树即可，<span style="color:#ad720d;"><strong>递归终止的条件为碰到空节点。</strong></span></p> 
<pre><code>class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List&lt;Integer&gt; res) {
        if (root == null) {
            return;
        }
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
}</code></pre> 
<p><strong>复杂度分析</strong></p> 
<blockquote> 
 <p><strong>时间复杂度：O(n)</strong>，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p> 
 <p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别</p> 
</blockquote> 
<h3 id="%C2%A0%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A"> 迭代方式：</h3> 
<pre><code>class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
}
</code></pre> 
<p><span style="color:#ad720d;"><strong>子循环中root遍历到root左子树最深层次过程中，依次将左结点压栈，左结点为空退出子循环，将栈顶元素出栈， root=root.right重新进入大循环既可遍历该树所有结点。</strong></span></p> 
<blockquote> 
 <p><strong>时间复杂度：O(n)</strong>，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p> 
 <p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。 </p> 
</blockquote> 
<hr> 
<h2 id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A">3、后序遍历</h2> 
<h3 id="%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F">递归方式</h3> 
<p>定义 postorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要递归调用 postorder(root-&gt;left) 来遍历 root 节点的左子树，然后递归调用 postorder(root-&gt;right) 来遍历 root 节点的右子树，最后将 root 节点的值加入答案即可，<span style="color:#fe2c24;"><strong>递归终止的条件为碰到空节点。</strong></span></p> 
<pre><code>class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List&lt;Integer&gt; res) {
        if (root == null) {
            return;
        }
        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
</code></pre> 
<p><strong>复杂度分析</strong></p> 
<blockquote> 
 <p><strong>时间复杂度：O(n)</strong>，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p> 
 <p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p> 
</blockquote> 
<h3 id="%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A">迭代方式：</h3> 
<p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，<strong>区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来</strong>，其余的实现与细节都相同，具体可以参考下面的代码(为了更好的注释，代码放入块引用中)</p> 
<blockquote> 
 <p>class Solution {<!-- --></p> 
 <p>    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {<!-- --></p> 
 <p>        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</p> 
 <p>        if (root == null) {<!-- --></p> 
 <p>            return res;</p> 
 <p>        }</p> 
 <p></p> 
 <p>        Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;();</p> 
 <p>        TreeNode prev = null;</p> 
 <p>        while (root != null || !stack.isEmpty()) {<!-- --></p> 
 <p>            while (root != null) {<!-- --></p> 
 <p>                stack.push(root);</p> 
 <p>                root = root.left;</p> 
 <p>            }</p> 
 <p>            root = stack.peek();<span style="color:#ad720d;">//  取栈顶元素</span></p> 
 <p><span style="color:#ad720d;">//因为是后序遍历，当前结点有无右结点决定它是否打印</span></p> 
 <p><span style="color:#ad720d;">//所以取出栈顶元素，判断有无右结点</span></p> 
 <p></p> 
 <p>         <span style="color:#ad720d;">//而打印当前结点情况分为两种，1、该结点无右结点  2、该结点的右结点已遍历</span></p> 
 <p>      if (root.right == null || root.right == prev) {<!-- --></p> 
 <p>                res.add(root.val);</p> 
 <p>                stack.pop();</p> 
 <p>                prev = root;<span style="color:#ad720d;">//用prev指向root，表示已被遍历</span></p> 
 <p>                root = null;</p> 
 <p>            } else </p> 
 <p>                root = root.right;</p> 
 <p>        }</p> 
 <p>        return res;</p> 
 <p>    }</p> 
 <p>}</p> 
</blockquote> 
<p><img alt="" height="363" src="https://images2.imgbox.com/1e/5b/pkfjOIx6_o.png" width="500"></p> 
<p><span style="color:#ad720d;">如上图情况，若if条件语句不判断 D.right ( K )是否被上次遍历则会陷入K出栈压栈无限循环中</span></p> 
<p><strong>复杂度分析</strong> </p> 
<blockquote> 
 <p><strong>时间复杂度：O(n)</strong>，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p> 
 <p>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p> 
</blockquote> 
<hr> 
<h2 id="%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">4、层序遍历</h2> 
<p>即逐层地，从左到右访问所有节点。</p> 
<h3>递归方式</h3> 
<pre><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        order(root,0);
        return result;
    }
    public void order(TreeNode node,int deep)
    {
        if(node==null)return;
        deep++;
        if(result.size()&lt;deep)
        {
            List&lt;Integer&gt; item=new ArrayList&lt;&gt;();
            result.add(item);
        }
        result.get(deep-1).add(node.val);
        order(node.left,deep);
        order(node.right,deep);
    }
}</code></pre> 
<p>在方法void order(TreeNode node,int deep) ，传相应的结点和二维数组下标，设置节点对应位置</p> 
<p>加图理解： </p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/ee/39/nbLb2JE3_o.png" width="600"></p> 
<blockquote> 
 <p>时间复杂度；O(n) </p> 
</blockquote> 
<h3>迭代方式： </h3> 
<p>代码设计重点：<span style="color:#fe2c24;">出栈既遍历。在结点出栈时，同时将不为空的左右结点入栈。</span><span style="color:#ad720d;">进入子循环前，用size记录栈内元素，进入子循环后，依次将栈顶元素弹出，同时将不为空的左右结点入，size--；</span></p> 
<pre><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();
        if(root==null)
        return res;
        Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty()){
            int size=queue.size();
            List&lt;Integer&gt; list=new ArrayList&lt;&gt;();
            while(size--!=0){
                TreeNode top=queue.poll();
                list.add(top.val);
               if(top.left!=null)
               queue.offer(top.left);
                if(top.right!=null)
                queue.offer(top.right);
            }
            res.add(list);
        }
        return res;
    }
}</code></pre> 
<blockquote> 
 <p>时间复杂度；O(n)</p> 
</blockquote> 
<p>二叉树的遍历结束</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e65ebbab76d89804c7836c7f013b1226/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通过域名和HTTPS上线MSF</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b153f939cf53080ba045218234779c77/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux---DHCP和FTP（原理&#43;实操）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>