<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端安全——最新：lodash原型漏洞从发现到修复全过程 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/af98e074fae6a04745838fe973c22333/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端安全——最新：lodash原型漏洞从发现到修复全过程">
  <meta property="og:description" content="人生的精彩就在于你永远不知道惊喜和意外谁先来，又是一个平平无奇的早晨，我收到了一份意外的惊喜——前端某项目出现lodash依赖原型污染漏洞。咋一听，很新奇。再仔细一看，呕吼，更加好奇了~然后就是了解和修补漏洞之旅。
最后的最后，却发现其实这个漏洞修复起来很简单。但是我的整个过程却是充满曲折和离奇。特此记录一下。
1. 漏洞复现 现在很多系统的前端都是基于vue和react框架的，所以就肯定少不了引入各种依赖了额，而lodash
作为一款非常流行的npm库,每月的下载量超过8000万次。可以说是使用的十分广泛了。所以可以想象，当lodash这个漏洞出现时，标志着有多少项目会存在被攻击的风险。而检测的方法也很简单，在你的前端控制台，输入下面代码。
const payload = &#39;{&#34;constructor&#34;: {&#34;prototype&#34;: {&#34;lodash&#34;: true}}}&#39; _.defaultsDeep({}, JSON.parse(payload)) if({}.lodash === true){ alert(&#34;Bad news :(\nYou&#39;re (still) vulnerable to Prototype Pollution&#34;) } else { alert(&#34;All Good! :)\nYou&#39;re NOT vulnerable (anymore) to Prototype Pollution&#34;) } 如果出现如下弹窗，就说明没有漏洞。lodash版本是最新的，已经把漏洞修复了。如果不是，那么恭喜你，中奖了~继续往下看吧。
2. 漏洞原理解析 通俗来讲：攻击者可以通过 Lodash 的函数覆盖或污染JavaScript 对象的原型（prototype）
例如：通过 **Lodash **库中的函数 defaultsDeep 可以修改 Object.prototype
的属性。JavaScript 在读取对象中的某个属性时，如果查找不到就会去其原型链上查找。试想一下，如果被修改的属性是 toString
方法，例如：
const payload = &#39;{&#34;constructor&#34;: {&#34;prototype&#34;: {&#34;toString&#34;: true}}}&#39; _.defaultsDeep({}, JSON.parse(payload)) payload 又为用户输入的数据，那么，在调用Object.prototype.toString 时就会非常不安全了。
lodash原型污染漏洞出现在Lodash:4.17.12 版本以下，我们可以来看下，依赖源码出现漏洞的地方：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-01T11:12:23+08:00">
    <meta property="article:modified_time" content="2024-07-01T11:12:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端安全——最新：lodash原型漏洞从发现到修复全过程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>人生的精彩就在于你永远不知道惊喜和意外谁先来，又是一个平平无奇的早晨，我收到了一份意外的惊喜——前端某项目出现lodash依赖原型污染漏洞。咋一听，很新奇。再仔细一看，呕吼，更加好奇了~然后就是了解和修补漏洞之旅。</p> 
 <p>最后的最后，却发现其实这个漏洞修复起来很简单。但是我的整个过程却是充满曲折和离奇。特此记录一下。</p> 
</blockquote> 
<h4><a id="1__5"></a>1. 漏洞复现</h4> 
<p>现在很多系统的前端都是基于vue和react框架的，所以就肯定少不了引入各种依赖了额，而lodash<br> 作为一款非常流行的npm库,每月的下载量超过8000万次。可以说是使用的十分广泛了。所以可以想象，当lodash这个漏洞出现时，标志着有多少项目会存在被攻击的风险。而检测的方法也很简单，在你的前端控制台，输入下面代码。</p> 
<pre><code>const payload = '{"constructor": {"prototype": {"lodash": true}}}'
_.defaultsDeep({}, JSON.parse(payload))
if({}.lodash === true){ alert("Bad news :(\nYou're (still) vulnerable to Prototype Pollution") } else { alert("All Good! :)\nYou're NOT vulnerable (anymore) to Prototype Pollution") }
</code></pre> 
<p>如果出现如下弹窗，就说明没有漏洞。lodash版本是最新的，已经把漏洞修复了。如果不是，那么恭喜你，中奖了~继续往下看吧。</p> 
<p><img src="https://images2.imgbox.com/32/33/bJdYQ8x9_o.png" alt=""></p> 
<h4><a id="2__20"></a>2. 漏洞原理解析</h4> 
<blockquote> 
 <p>通俗来讲：攻击者可以通过 <code>Lodash</code> 的函数覆盖或污染JavaScript 对象的原型（prototype）</p> 
</blockquote> 
<p>例如：通过 **<code>Lodash</code> **库中的函数 <code>defaultsDeep</code> 可以修改 <code>Object.prototype</code><br> 的属性。<code>JavaScript</code> 在读取对象中的某个属性时，如果查找不到就会去其原型链上查找。试想一下，如果被修改的属性是 <code>toString</code><br> 方法，例如：</p> 
<pre><code>const payload = '{"constructor": {"prototype": {"toString": true}}}'

_.defaultsDeep({}, JSON.parse(payload)) 
</code></pre> 
<p><strong>payload</strong> 又为用户输入的数据，那么，在调用<code>Object.prototype.toString</code> 时就会非常不安全了。</p> 
<p>lodash原型污染漏洞出现在<strong>Lodash:4.17.12</strong> 版本以下，我们可以来看下，依赖源码出现漏洞的地方：</p> 
<p><img src="https://images2.imgbox.com/12/8a/NO648HEL_o.png" alt=""></p> 
<p>结论： 实现了一个 safeGet 的函数来避免获取原型上的值。但是没有考虑到构造方法<strong>constructor</strong><br> 的情况，因此，在lodash“连夜”发版修复方法：</p> 
<p><img src="https://images2.imgbox.com/98/45/xYK6F3qU_o.png" alt=""></p> 
<h4><a id="3__46"></a>3. 修复漏洞</h4> 
<p>在理解了漏洞如何出现的情况下，下面我们要做的就是修复漏洞了。到这里，有些人可能就明白了，既然原型污染漏洞是由于lodash版本过低导致的，那我直接将package.json中lodash版本库改为最新的<strong>4.17.21</strong><br> 不就行了。别急，下面我们循序渐进，由浅入深的理解并修复这个漏洞。</p> 
<blockquote> 
 <p>tips:以下操作前请做好项目备份</p> 
</blockquote> 
<h5><a id="31__53"></a>3.1 直接版本升级解决</h5> 
<p>假如你的项目很简单，并且package.json也很直观的显示了引入的lodash版本低于4.17.12，那么大概率直接修改版本就解决了。如果修改解决不了，可以试试修改版本号后。</p> 
<p><strong>删除node_modules和package-lock.json,重新npm install一下</strong></p> 
<h5><a id="32_lodash_59"></a>3.2 子依赖lodash问题解决</h5> 
<p>上面的情况是最好的情况，也是最简单的情况，但是实际上，我们遇到的问题可能比这个复杂的多。因为lz发现，本地前端项目package.json根本就没有引入lodash依赖。</p> 
<p><img src="https://images2.imgbox.com/b8/d8/lwGZr29M_o.png" alt=""></p> 
<p>这种情况下，上面那种方法就很明显行不通了，版本都没引入更遑论改版本了，那么，问题来了。既然没有引入lodash.js，那么**_.defaultsDeep**<br> 方法又是哪来的呢。经过我的排查，终于发现，在package-lock.json文件下，显示了引入了多个不同版本的lodash，正如我前面所说，lodash<br> 作为一款非常流行的npm库，提供了很多的方法。所以也是很多第三方库的子依赖。我不引用它，不代表第三方库不引用它。而且从全局搜索来看，引入的地方还挺多。因此也没法一个个改。经过学习了解，发现可以通过<strong>resolutions</strong><br> 指定子依赖版本。</p> 
<p><img src="https://images2.imgbox.com/91/74/hSnmfJx1_o.png" alt=""></p> 
<p>在 npm 中，<code>resolutions</code> 字段通常用于解决依赖版本冲突的问题。当你使用 <code>resolutions</code><br> 字段时，你可以强制指定某个依赖包的版本，以确保项目中使用的依赖包版本符合你的要求。</p> 
<pre><code>{
  "name": "my-project",
  "version": "1.0.0",
   "scripts": {
        "serve": "vue-cli-service serve",
        "build": "vue-cli-service build",
        "preinstall": "npx force-resolutions"
    },
  "dependencies": {
    "element-ui": "^2.15.8",
  },
  "resolutions": {
        "lodash": "4.17.21"
    },
  "overrides": {
        "**/lodash": "4.17.21"
  }, 
}
</code></pre> 
<p>overrides配置为resolutions的替补，要求npm 8以上。scripts下新增一条命令：</p> 
<blockquote> 
 <p>“preinstall”: “npx force-resolutions”</p> 
</blockquote> 
<p>这条命令通常是为了在安装依赖包之前强制执行 <code>force-resolutions</code> 工具，以确保 <code>resolutions</code><br> 字段中指定的依赖版本得到正确安装。正常情况下，npm install的时候就会自动检测并执行了。</p> 
<p>执行完之后，可以通过下面命令查看子依赖是否都已指定版本成功</p> 
<p><strong>npm list lodash</strong></p> 
<p><img src="https://images2.imgbox.com/a3/a6/U8h8ieW4_o.png" alt=""></p> 
<h5><a id="33__110"></a>3.3. 追更溯源解决</h5> 
<p>不出意外的话，上面两种方法都用过之后，应该可能或许大概也许解决这个漏洞了吧，但是凡是总有例外，很明显。lz就是那个万里挑一的人才。我检测发现问题依旧存在，到这里，我的内心是抓狂的，我的身体是拒绝的。明明什么方法都用过了，为什么还会报错！为什么！！</p> 
<p>直到我在控制台查看这个方法的调用源头：</p> 
<p><img src="https://images2.imgbox.com/b5/1c/wIWC2nJD_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/d5/ea/FUsLR3nG_o.png" alt=""></p> 
<p>等等，element-ui什么时候背着我引入了lodash.js,再到package-<br> lock.json一看，它的子依赖中根本没有引入lodash依赖啊。但是在node_modules一查，发现lodash.js文件确实存在，而其中的关键方法<strong>safeGet</strong><br> 方法也确实存在漏洞。好家伙，梦里寻他千百度，蓦然回首竟是官方在犯错。</p> 
<p><img src="https://images2.imgbox.com/03/e4/DRe85Eos_o.png" alt=""></p> 
<p>不信邪的我特意去看了下官方依赖，结果果然不出所料，这个老⑥</p> 
<p><img src="https://images2.imgbox.com/35/2f/LfAG6rrN_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/c2/e7/NNdvHZrq_o.png" alt=""></p> 
<p>关键element-ui这里<strong>2.15.14</strong> 版本还是最新的。想想真恐怖，所以最后的解决方法就是更新下element-<br> ui版本。2.15.8版本没有引入lodash.js。</p> 
<h4><a id="4__135"></a>4. 结束语</h4> 
<p>到这里，漏洞问题基本被找到和解决了。随着前端框架的流行，越来越多的第三方库被爆出了各种漏洞。虽然官方及时发布了版本修复，但是在系统开发迭代过程中，依赖库更新总是滞后的。所以这个问题也给我们提了一个醒。有事没事也可以npm<br> audit和npm audit fix一下也可以。</p> 
<p>最后，码字填坑不易，转载请注明出处！</p> 
<p>接下来我将给各位同学划分一张学习计划表！</p> 
<h2><a id="_144"></a>学习计划</h2> 
<p>那么问题又来了，作为萌新小白，我应该先学什么，再学什么？<br> 既然你都问的这么直白了，我就告诉你，零基础应该从什么开始学起：</p> 
<h3><a id="_149"></a>阶段一：初级网络安全工程师</h3> 
<p>接下来我将给大家安排一个为期1个月的网络安全初级计划，当你学完后，你基本可以从事一份网络安全相关的工作，比如渗透测试、Web渗透、安全服务、安全分析等岗位；其中，如果你等保模块学的好，还可以从事等保工程师。</p> 
<p><font color="red"><strong>综合薪资区间6k~15k</strong></font></p> 
<p>1、网络安全理论知识（2天）<br> ①了解行业相关背景，前景，确定发展方向。<br> ②学习网络安全相关法律法规。<br> ③网络安全运营的概念。<br> ④等保简介、等保规定、流程和规范。（非常重要）</p> 
<p>2、渗透测试基础（1周）<br> ①渗透测试的流程、分类、标准<br> ②信息收集技术：主动/被动信息搜集、Nmap工具、Google Hacking<br> ③漏洞扫描、漏洞利用、原理，利用方法、工具（MSF）、绕过IDS和反病毒侦察<br> ④主机攻防演练：MS17-010、MS08-067、MS10-046、MS12-20等</p> 
<p>3、操作系统基础（1周）<br> ①Windows系统常见功能和命令<br> ②Kali Linux系统常见功能和命令<br> ③操作系统安全（系统入侵排查/系统加固基础）</p> 
<p>4、计算机网络基础（1周）<br> ①计算机网络基础、协议和架构<br> ②网络通信原理、OSI模型、数据转发流程<br> ③常见协议解析（HTTP、TCP/IP、ARP等）<br> ④网络攻击技术与网络安全防御技术<br> ⑤Web漏洞原理与防御：主动/被动攻击、DDOS攻击、CVE漏洞复现</p> 
<p>5、数据库基础操作（2天）<br> ①数据库基础<br> ②SQL语言基础<br> ③数据库安全加固</p> 
<p>6、Web渗透（1周）<br> ①HTML、CSS和JavaScript简介<br> ②OWASP Top10<br> ③Web漏洞扫描工具<br> ④Web渗透工具：Nmap、BurpSuite、SQLMap、其他（菜刀、漏扫等）<br> <img src="https://images2.imgbox.com/dd/6c/Q6ckm1Hy_o.png" alt=""><br> <strong>那么，到此为止，已经耗时1个月左右。你已经成功成为了一名“脚本小子”。那么你还想接着往下探索吗？</strong></p> 
<h3><a id="or_192"></a>阶段二：中级or高级网络安全工程师（看自己能力）</h3> 
<p><font color="red"><strong>综合薪资区间15k~30k</strong></font></p> 
<p>7、脚本编程学习（4周）<br> 在网络安全领域。是否具备编程能力是“脚本小子”和真正网络安全工程师的本质区别。在实际的渗透测试过程中，面对复杂多变的网络环境，当常用工具不能满足实际需求的时候，往往需要对现有工具进行扩展，或者编写符合我们要求的工具、自动化脚本，这个时候就需要具备一定的编程能力。在分秒必争的CTF竞赛中，想要高效地使用自制的脚本工具来实现各种目的，更是需要拥有编程能力。</p> 
<p>零基础入门的同学，我建议选择脚本语言Python/PHP/Go/Java中的一种，对常用库进行编程学习<br> 搭建开发环境和选择IDE，PHP环境推荐Wamp和XAMPP，IDE强烈推荐Sublime；</p> 
<p>Python编程学习，学习内容包含：语法、正则、文件、 网络、多线程等常用库，推荐《Python核心编程》，没必要看完</p> 
<p>用Python编写漏洞的exp,然后写一个简单的网络爬虫</p> 
<p>PHP基本语法学习并书写一个简单的博客系统</p> 
<p>熟悉MVC架构，并试着学习一个PHP框架或者Python框架 (可选)</p> 
<p>了解Bootstrap的布局或者CSS。</p> 
<h3><a id="_212"></a>阶段三：顶级网络安全工程师</h3> 
<p>如果你对网络安全入门感兴趣，那么你需要的话可以点击这里<strong>👉</strong><a href="https://mp.weixin.qq.com/s/BWb9OzaB-gVGVpkm161PMw" rel="nofollow">网络安全重磅福利：入门&amp;进阶全套282G学习资源包免费分享！</a></p> 
<p><img src="https://images2.imgbox.com/19/3a/nxS0cqiP_o.png" alt=""></p> 
<h2><a id="_218"></a>学习资料分享</h2> 
<p>当然，<strong>只给予计划不给予学习资料的行为无异于耍流氓</strong>，这里给大家整理了一份【282G】的网络安全工程师从入门到精通的学习资料包，可点击下方二维码链接领取哦。</p> 
<img src="https://images2.imgbox.com/ed/77/6ZdY8O6k_o.jpg">
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b217668663a302ea5323bb8580a248a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">24 年程序员各岗位薪资待遇汇总（最新）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/29d66d111b62aaa13cd582ef074d72a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">websocket （@ServerEndpoint）基本使用指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>