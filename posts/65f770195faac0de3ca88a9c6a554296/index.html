<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单一职责原则介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/65f770195faac0de3ca88a9c6a554296/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="单一职责原则介绍">
  <meta property="og:description" content="一.概念介绍 单一职责原则(Single Responsibility Principle, SRP)是面向对象设计中的五大基本原则之一,它是指一个类或者模块应该仅有一个引起它变化的原因。
具体来说,单一职责原则有以下几个特点:
职责集中:一个类或模块应该专注于完成一种特定的功能或职责,而不应该承担过多的职责。
职责分离:如果一个类或模块承担了多个职责,那么当其中一个职责发生变化时,就会影响到其他职责,导致代码难以维护。
可测试性:单一职责的类或模块更容易编写单元测试,因为它们的功能更加集中和明确。
可复用性:单一职责的类或模块更容易被其他代码复用,因为它们的功能更加独立和通用。
可读性:单一职责的类或模块更容易被开发人员理解和修改,因为它们的功能更加清晰和简单。
遵循单一职责原则的好处包括:
提高代码的可维护性:当一个类或模块只负责一个职责时,代码的结构更加清晰,修改时不会影响到其他无关的功能。
提高代码的可测试性:单一职责的类或模块更容易编写单元测试,因为它们的功能更加集中和明确。
提高代码的可复用性:单一职责的类或模块更容易被其他代码复用,因为它们的功能更加独立和通用。
提高代码的可读性:单一职责的类或模块更容易被开发人员理解和修改,因为它们的功能更加清晰和简单。
总之,单一职责原则是面向对象设计中非常重要的一个原则,它可以帮助我们编写出更加高质量、可维护和可扩展的代码。在实际开发中,我们应该努力遵循这一原则,尽量将类或模块的职责划分得更加清晰和集中。
二.具体例子 假设我们有一个 Employee 类,它负责管理员工的基本信息,如姓名、工号、部门等。
不遵循单一职责原则的例子:
class Employee { public: Employee(const std::string&amp; name, int id, const std::string&amp; department) : m_name(name), m_id(id), m_department(department) {} void setName(const std::string&amp; name) { m_name = name; } void setId(int id) { m_id = id; } void setDepartment(const std::string&amp; department) { m_department = department; } std::string getName() const { return m_name; } int getId() const { return m_id; } std::string getDepartment() const { return m_department; } void giveRaise(double percentage) { /* 计算并更新工资 */ } void fireEmployee() { /* 执行解雇流程 */ } void printEmployeeInfo() { /* 打印员工信息 */ } private: std::string m_name; int m_id; std::string m_department; }; 在这个例子中,Employee 类承担了太多的职责,包括管理员工基本信息、计算工资、执行解雇流程、打印员工信息等。这违反了单一职责原则,因为当其中一个职责发生变化时,就会影响到其他职责,导致代码难以维护。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-31T23:49:21+08:00">
    <meta property="article:modified_time" content="2024-08-31T23:49:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单一职责原则介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一.概念介绍</h2> 
<p>单一职责原则(Single Responsibility Principle, SRP)是面向对象设计中的五大基本原则之一,它是指一个类或者模块应该仅有一个引起它变化的原因。</p> 
<p>具体来说,单一职责原则有以下几个特点:</p> 
<ol><li> <p><strong>职责集中</strong>:一个类或模块应该专注于完成一种特定的功能或职责,而不应该承担过多的职责。</p> </li><li> <p><strong>职责分离</strong>:如果一个类或模块承担了多个职责,那么当其中一个职责发生变化时,就会影响到其他职责,导致代码难以维护。</p> </li><li> <p><strong>可测试性</strong>:单一职责的类或模块更容易编写单元测试,因为它们的功能更加集中和明确。</p> </li><li> <p><strong>可复用性</strong>:单一职责的类或模块更容易被其他代码复用,因为它们的功能更加独立和通用。</p> </li><li> <p><strong>可读性</strong>:单一职责的类或模块更容易被开发人员理解和修改,因为它们的功能更加清晰和简单。</p> </li></ol> 
<p>遵循单一职责原则的好处包括:</p> 
<ol><li> <p><strong>提高代码的可维护性</strong>:当一个类或模块只负责一个职责时,代码的结构更加清晰,修改时不会影响到其他无关的功能。</p> </li><li> <p><strong>提高代码的可测试性</strong>:单一职责的类或模块更容易编写单元测试,因为它们的功能更加集中和明确。</p> </li><li> <p><strong>提高代码的可复用性</strong>:单一职责的类或模块更容易被其他代码复用,因为它们的功能更加独立和通用。</p> </li><li> <p><strong>提高代码的可读性</strong>:单一职责的类或模块更容易被开发人员理解和修改,因为它们的功能更加清晰和简单。</p> </li></ol> 
<p>总之,单一职责原则是面向对象设计中非常重要的一个原则,它可以帮助我们编写出更加高质量、可维护和可扩展的代码。在实际开发中,我们应该努力遵循这一原则,尽量将类或模块的职责划分得更加清晰和集中。</p> 
<h2><a id="_27"></a>二.具体例子</h2> 
<p>假设我们有一个 Employee 类,它负责管理员工的基本信息,如姓名、工号、部门等。</p> 
<p><strong>不遵循单一职责原则的例子:</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{<!-- --></span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token function">Employee</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> department<span class="token punctuation">)</span>  
        <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_department</span><span class="token punctuation">(</span>department<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  

    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> m_name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>  
    <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> m_id <span class="token operator">=</span> id<span class="token punctuation">;</span> <span class="token punctuation">}</span>  
    <span class="token keyword">void</span> <span class="token function">setDepartment</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> department<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> m_department <span class="token operator">=</span> department<span class="token punctuation">;</span> <span class="token punctuation">}</span>  

    std<span class="token double-colon punctuation">::</span>string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_id<span class="token punctuation">;</span> <span class="token punctuation">}</span>  
    std<span class="token double-colon punctuation">::</span>string <span class="token function">getDepartment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_department<span class="token punctuation">;</span> <span class="token punctuation">}</span>  

    <span class="token keyword">void</span> <span class="token function">giveRaise</span><span class="token punctuation">(</span><span class="token keyword">double</span> percentage<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* 计算并更新工资 */</span> <span class="token punctuation">}</span>  
    <span class="token keyword">void</span> <span class="token function">fireEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* 执行解雇流程 */</span> <span class="token punctuation">}</span>  
    <span class="token keyword">void</span> <span class="token function">printEmployeeInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* 打印员工信息 */</span> <span class="token punctuation">}</span>  

<span class="token keyword">private</span><span class="token operator">:</span>  
    std<span class="token double-colon punctuation">::</span>string m_name<span class="token punctuation">;</span>  
    <span class="token keyword">int</span> m_id<span class="token punctuation">;</span>  
    std<span class="token double-colon punctuation">::</span>string m_department<span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
</code></pre> 
<p>在这个例子中,Employee 类承担了太多的职责,包括管理员工基本信息、计算工资、执行解雇流程、打印员工信息等。这违反了单一职责原则,因为当其中一个职责发生变化时,就会影响到其他职责,导致代码难以维护。</p> 
<p><strong>遵循单一职责原则的例子:</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{<!-- --></span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token function">Employee</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> department<span class="token punctuation">)</span>  
        <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_department</span><span class="token punctuation">(</span>department<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  

    std<span class="token double-colon punctuation">::</span>string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_id<span class="token punctuation">;</span> <span class="token punctuation">}</span>  
    std<span class="token double-colon punctuation">::</span>string <span class="token function">getDepartment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_department<span class="token punctuation">;</span> <span class="token punctuation">}</span>  

<span class="token keyword">private</span><span class="token operator">:</span>  
    std<span class="token double-colon punctuation">::</span>string m_name<span class="token punctuation">;</span>  
    <span class="token keyword">int</span> m_id<span class="token punctuation">;</span>  
    std<span class="token double-colon punctuation">::</span>string m_department<span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  

<span class="token keyword">class</span> <span class="token class-name">EmployeeCompensation</span> <span class="token punctuation">{<!-- --></span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token keyword">void</span> <span class="token function">giveRaise</span><span class="token punctuation">(</span>Employee<span class="token operator">&amp;</span> employee<span class="token punctuation">,</span> <span class="token keyword">double</span> percentage<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token comment">// 计算并更新工资  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  

<span class="token keyword">class</span> <span class="token class-name">EmployeeManagement</span> <span class="token punctuation">{<!-- --></span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token keyword">void</span> <span class="token function">fireEmployee</span><span class="token punctuation">(</span>Employee<span class="token operator">&amp;</span> employee<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token comment">// 执行解雇流程  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  

<span class="token keyword">class</span> <span class="token class-name">EmployeeReporting</span> <span class="token punctuation">{<!-- --></span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token keyword">void</span> <span class="token function">printEmployeeInfo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Employee<span class="token operator">&amp;</span> employee<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token comment">// 打印员工信息  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
</code></pre> 
<p>在这个例子中,我们将 Employee 类的职责划分为三个不同的类:</p> 
<ol><li>Employee 类负责管理员工的基本信息。</li><li>EmployeeCompensation 类负责处理员工的工资相关操作。</li><li>EmployeeManagement 类负责处理员工的解雇流程。</li><li>EmployeeReporting 类负责打印员工信息。</li></ol> 
<p>这样做的好处是:</p> 
<ol><li>每个类都只负责一个明确的职责,代码更加清晰和可维护。</li><li>当某个职责发生变化时,只需要修改相应的类,不会影响到其他无关的功能。</li><li>各个类都可以独立地进行单元测试,提高了代码的可测试性。</li><li>各个类都可以被其他代码复用,提高了代码的可复用性。</li></ol> 
<p>总之,这个例子展示了如何遵循单一职责原则来设计代码,从而提高代码的质量和可维护性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f358d70ecd199022415747a347f8564/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据仓库系列17：元数据管理在数据仓库中的作用是什么?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28ccde1fd5b9e75488c52dc6ea951aeb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;基础入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>