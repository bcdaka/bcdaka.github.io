<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构--栈与队列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/501a05ebcdba5cc7583f436fef6a4a90/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构--栈与队列">
  <meta property="og:description" content="目录
1.栈
1.1栈的概念及结构
1.2栈的实现
2.队列
2.1队列的概念及结构
2.2队列的实现
3.栈和队列经典题目
1.括号匹配问题
2. 用队列实现栈
1.栈 1.1栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。 进行数据插入和删除操作的一端 称为 栈顶 ，另一端称为 栈底 。 栈中的数据元素遵守后进先出 LIFO （ Last In First Out ）的原则。 压栈 ：栈的插入操作叫做进栈 / 压栈 / 入栈， 入数据在栈顶 。 出栈 ：栈的删除操作叫做出栈。 出数据也在栈顶 。 1.2栈的实现 栈的实现一般可以使用 数组或者链表实现 ，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。 #include&#34;Queue.h&#34; //初始化 void QueueInit(Queue* pq) { assert(pq); pq-&gt;phead = NULL; pq-&gt;ptail = NULL; pq-&gt;size = 0; } //销毁 void QueueDestroy(Queue* pq) { assert(pq); QNode* cur = pq-&gt;phead; while (cur) { QNode* next = cur-&gt;next; free(cur); cur = next; } pq-&gt;phead = pq-&gt;ptail = NULL; pq-&gt;size = 0; } // 队尾插入 void QueuePush(Queue* pq, QDataType x) { assert(pq); QNode* newnode = (QNode*)malloc(sizeof(QNode)); if (newnode == NULL) { perror(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-27T00:47:49+08:00">
    <meta property="article:modified_time" content="2024-06-27T00:47:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构--栈与队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E6%A0%88-toc" style="margin-left:0px;"><a href="#1.%E6%A0%88" rel="nofollow">1.栈</a></p> 
<p id="1.1%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.1%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.1栈的概念及结构</a></p> 
<p id="%C2%A01.2%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A01.2%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow"> 1.2栈的实现</a></p> 
<p id="2.%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#2.%E9%98%9F%E5%88%97" rel="nofollow">2.队列</a></p> 
<p id="2.1%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.1%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">2.1队列的概念及结构</a></p> 
<p id="%C2%A02.2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A02.2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow"> 2.2队列的实现</a></p> 
<p id="3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-toc" style="margin-left:0px;"><a href="#3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE" rel="nofollow">3.栈和队列经典题目</a></p> 
<p id="1.%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#1.%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98" rel="nofollow">1.括号匹配问题</a></p> 
<p id="2.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-toc" style="margin-left:40px;"><a href="#2.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88" rel="nofollow">2. 用队列实现栈</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%A0%88">1.栈</h2> 
<h3 id="1.1%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84"><span style="color:#333333;"><strong>1.1</strong></span><span style="color:#333333;"><strong>栈的概念及结构 </strong></span></h3> 
<blockquote> 
 <div> 
  <span style="color:#777777;">栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。</span> 
  <span style="color:#777777;"><strong>进行数据插入和删除操作的一端 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>称为</strong></span> 
  <span style="color:#fe2c24;"><strong>栈顶</strong></span> 
  <span style="color:#777777;"><strong>，另一端称为</strong></span> 
  <span style="color:#fe2c24;"><strong>栈底</strong></span> 
  <span style="color:#777777;"><strong>。</strong></span> 
  <span style="color:#777777;">栈中的数据元素遵守后进先出</span> 
  <span style="color:#777777;">LIFO</span> 
  <span style="color:#777777;">（</span> 
  <span style="color:#777777;">Last In First Out</span> 
  <span style="color:#777777;">）的原则。 </span> 
 </div> 
 <div> 
  <span style="color:#fe2c24;">压栈</span> 
  <span style="color:#777777;">：栈的插入操作叫做进栈</span> 
  <span style="color:#777777;">/</span> 
  <span style="color:#777777;">压栈</span> 
  <span style="color:#777777;">/</span> 
  <span style="color:#777777;">入栈，</span> 
  <span style="color:#777777;"><strong>入数据在栈顶</strong></span> 
  <span style="color:#777777;">。 </span> 
 </div> 
 <div> 
  <span style="color:#fe2c24;">出栈</span> 
  <span style="color:#777777;">：栈的删除操作叫做出栈。</span> 
  <span style="color:#777777;"><strong>出数据也在栈顶</strong></span> 
  <span style="color:#777777;">。</span> 
 </div> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/cd/WXbR2VmT_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/77/d3/oCwk4h4M_o.png"> </p> 
<h3 id="%C2%A01.2%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"> <span style="color:#333333;"><strong>1.2</strong></span><span style="color:#333333;"><strong>栈的实现</strong></span></h3> 
<p></p> 
<div> 
 <span style="color:#777777;">栈的实现一般可以使用</span> 
 <span style="color:#777777;"><strong>数组或者链表实现</strong></span> 
 <span style="color:#777777;">，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。</span> 
</div> 
<div style="text-align:center;"> 
 <span style="color:#777777;"><img alt="" src="https://images2.imgbox.com/7d/54/zfHV9SaB_o.png"></span> 
</div> 
<p> </p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/da/94/VPOP5OXz_o.png"></p> 
<p> </p> 
<pre><code class="hljs">#include"Queue.h"
//初始化
void QueueInit(Queue* pq)
{
	assert(pq);
	pq-&gt;phead = NULL;
	pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
//销毁
void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
// 队尾插入
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode-&gt;next = NULL;
	newnode-&gt;val = x;
	if (pq-&gt;ptail == NULL)
	{
		pq-&gt;phead = pq-&gt;ptail = newnode;
	}
	else
	{
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
	}
	pq-&gt;size++;
}

// 队头删除
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;size != 0);

	//一个节点
	if (pq-&gt;phead-&gt;next == 0)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	//多个节点
	else
	{
		QNode* next = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = next;

	}
	pq-&gt;size--;
}

// 取队头和队尾的数据
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;phead);
	return pq-&gt;phead-&gt;val;
}

QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;ptail);
	return pq-&gt;ptail-&gt;val;
}
int QueueSize(Queue* pq)
{
	assert(pq);
	return pq-&gt;size;
}
//判空
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq-&gt;size == 0;
}</code></pre> 
<h2 id="2.%E9%98%9F%E5%88%97">2.队列</h2> 
<h3 id="2.1%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84"><span style="color:#333333;"><strong>2.1</strong></span><span style="color:#333333;"><strong>队列的概念及结构</strong></span></h3> 
<p></p> 
<blockquote> 
 <div> 
  <span style="color:#0d0016;">队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO(First In First Out) </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">入队列：进行插入操作的一端称为队尾 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">出队列：进行删除操作的一端称为队头</span> 
 </div> 
</blockquote> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/30/cc/243ASR99_o.png"></p> 
<h3 id="%C2%A02.2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"> 2.2队列的实现</h3> 
<div> 
 <span style="color:#777777;">队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低。 </span> 
</div> 
<div style="text-align:center;"> 
 <span style="color:#777777;"><img alt="" src="https://images2.imgbox.com/0a/be/m4nAPuvg_o.png"></span> 
</div> 
<p> </p> 
<pre><code class="hljs">#include"Queue.h"
//初始化
void QueueInit(Queue* pq)
{
	assert(pq);
	pq-&gt;phead = NULL;
	pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
//销毁
void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
// 队尾插入
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode-&gt;next = NULL;
	newnode-&gt;val = x;
	if (pq-&gt;ptail == NULL)
	{
		pq-&gt;phead = pq-&gt;ptail = newnode;
	}
	else
	{
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
	}
	pq-&gt;size++;
}

// 队头删除
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;size != 0);

	//一个节点
	if (pq-&gt;phead-&gt;next == 0)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	//多个节点
	else
	{
		QNode* next = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = next;

	}
	pq-&gt;size--;
}

// 取队头和队尾的数据
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;phead);
	return pq-&gt;phead-&gt;val;
}

QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;ptail);
	return pq-&gt;ptail-&gt;val;
}
int QueueSize(Queue* pq)
{
	assert(pq);
	return pq-&gt;size;
}
//判空
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq-&gt;size == 0;
}</code></pre> 
<h2 id="3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE"><span style="color:#333333;"><strong>3.</strong></span><span style="color:#333333;"><strong>栈和队列经典题目</strong></span></h2> 
<h3 id="1.%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98">1.括号匹配问题</h3> 
<div> 
 <br> 
 <a href="https://leetcode.cn/problems/valid-parentheses/" rel="nofollow" title="20. 有效的括号 - 力扣（LeetCode）"><br> 20. 有效的括号 - 力扣（LeetCode）</a> 
</div> 
<div style="text-align:center;"> 
 <img alt="" src="https://images2.imgbox.com/43/52/Y20HqmQw_o.png"> 
</div> 
<p> 思路：（C语言）</p> 
<blockquote> 
 <p>利用已经实现好的栈</p> 
 <p>每个左括号要跟离自己最近的右括号匹配<br> 左括号，入栈<br> 右括号，取栈顶判断是否匹配</p> 
</blockquote> 
<pre><code class="hljs">/*给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。*/
#include&lt;stdio.h&gt;
#include&lt;stdbool.h&gt;
typedef char STDataType;

typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;
//初始化
void STInit(ST* pst)
{
	assert(pst);
	pst-&gt;a = NULL;
	//top指向栈顶数据的下一个位置
	pst-&gt;top = 0;
	//top指向栈顶数据
	//pst-&gt;top = -1;
	pst-&gt;capacity = 0;
}
//销毁
void STDestroy(ST* pst)
{
	assert(pst);
	free(pst-&gt;a);
	pst-&gt;a = NULL;
	pst-&gt;top = pst-&gt;capacity = 0;
}

//入栈
void STpush(ST* pst, STDataType x)
{
	assert(pst);

	//扩容
	if (pst-&gt;top == pst-&gt;capacity)
	{
		int newcapacity = pst-&gt;capacity == 0 ? 4 : pst-&gt;capacity * 2;//三目操作符，如果pst-&gt;capacity等于0：赋4，不等于：扩容2倍
		STDataType* tmp = (STDataType*)realloc(pst-&gt;a, newcapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		pst-&gt;a = tmp;
		pst-&gt;capacity = newcapacity;
	}
	pst-&gt;a[pst-&gt;top] = x;
	pst-&gt;top++;
}

//出栈
void STPop(ST* pst)
{
	assert(pst);
	assert(pst-&gt;top &gt; 0);
	pst-&gt;top--;//直接覆盖
}

//取栈顶数据
STDataType STTop(ST* pst)
{
	assert(pst);
	assert(pst-&gt;top &gt; 0);

	return pst-&gt;a[pst-&gt;top - 1];
}
//判空
bool STEmpty(ST* pst)
{
	assert(pst);
	return pst-&gt;top == 0;
}

//获取数据个数
int STSize(ST* pst)
{
	assert(pst);
	return pst-&gt;top;
}

//每个左括号要跟离自己最近的右括号匹配
//左括号，入栈
//右括号，取栈顶判断是否匹配
bool isValid(char* s) {
	ST st;
	STInit(&amp;st);
	while (*s)
	{
		//左括号入栈
		if (*s == '(' || *s == '[' || *s == '{')
		{
			STpush(&amp;st, *s);
		}
		else//右括号
		{
			if (STEmpty(&amp;st))//判空
			{
				STDestroy(&amp;st);//空，销毁，返回false
				return false;
			}
			char top = STTop(&amp;st);//取栈顶顶数据
			STPop(&amp;st);//出栈
			//不匹配
			if ((top == '(' &amp;&amp; *s != ')')
				|| (top == '{' &amp;&amp; *s != '}')
				|| (top == '[' &amp;&amp; *s != ']'))
			{
				STDestroy(&amp;st);
				return false;
			}
		}
		++s;
	}
	//栈不为空，说明左括号比右括号多，数量不匹配
	bool ret = STEmpty(&amp;st);
	STDestroy(&amp;st);
	return ret;
}




</code></pre> 
<h3 id="2.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span style="color:#7b7f82;">2. 用队列实现栈</span></h3> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/a2/cc/r3WSgIgI_o.png"></p> 
<blockquote> 
 <p> 利用两个队列<br> 把队尾前面全部数据给到另一个队列，就能取到队尾相当于栈顶的数据</p> 
 <p></p> 
</blockquote> 
<pre><code class="hljs">typedef int QDataType;

typedef struct QueueNode
{
	struct QueueNode* next;
	QDataType val;
}QNode;

typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;

void QueueInit(Queue* pq);
void QueueDestroy(Queue* pq);

// 队尾插入
void QueuePush(Queue* pq, QDataType x);
// 队头删除
void QueuePop(Queue* pq);

// 取队头和队尾的数据
QDataType QueueFront(Queue* pq);
QDataType QueueBack(Queue* pq);

int QueueSize(Queue* pq);
//判空
bool QueueEmpty(Queue* pq);
//初始化
void QueueInit(Queue* pq)
{
	assert(pq);
	pq-&gt;phead = NULL;
	pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
//销毁
void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
// 队尾插入
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode-&gt;next = NULL;
	newnode-&gt;val = x;
	if (pq-&gt;ptail == NULL)
	{
		pq-&gt;phead = pq-&gt;ptail = newnode;
	}
	else
	{
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
	}
	pq-&gt;size++;
}

// 队头删除
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;size != 0);

	//一个节点
	if (pq-&gt;phead-&gt;next == 0)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	//多个节点
	else
	{
		QNode* next = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = next;

	}
	pq-&gt;size--;
}

// 取队头和队尾的数据
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;phead);
	return pq-&gt;phead-&gt;val;
}

QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;ptail);
	return pq-&gt;ptail-&gt;val;
}
int QueueSize(Queue* pq)
{
	assert(pq);
	return pq-&gt;size;
}
//判空
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq-&gt;size == 0;
}
//利用两个队列
//把队尾前面全部数据给到另一个队列，就能取到队尾相当于栈顶的数据

typedef struct {
    Queue q1;
    Queue q2;
} MyStack;

//初始化
MyStack* myStackCreate() {
    MyStack* pst=(MyStack* )malloc(sizeof(MyStack));
    QueueInit(&amp;(pst-&gt;q1));
    QueueInit(&amp;(pst-&gt;q2));
    return pst;
}
//将元素 x 压入栈顶。
void myStackPush(MyStack* obj, int x) {
    //两个队列哪个不为空就插入哪个
    if(!QueueEmpty( &amp;(obj-&gt;q1) ) )
    {
        QueuePush(&amp;(obj-&gt;q1),x);
    }
    else
    {
        QueuePush(&amp;(obj-&gt;q2),x);
    }
}
//移除并返回栈顶元素。
int myStackPop(MyStack* obj) {
    //假设法
    Queue* empty=&amp;(obj-&gt;q1);
    Queue* nonEmpty=&amp;(obj-&gt;q2);
    if(!QueueEmpty(&amp;(obj-&gt;q1)))
    {
        empty=&amp;(obj-&gt;q2);
        nonEmpty=&amp;(obj-&gt;q1);
    }
    //不为空前size-1导走，删除最后一个就是栈顶数据
    while(QueueSize(nonEmpty)&gt;1)
    {
        QueuePush(empty,QueueFront(nonEmpty));
        QueuePop(nonEmpty);
    }
    int top=QueueFront(nonEmpty);
    QueuePop(nonEmpty);
    return top;
}
//返回栈顶元素
int myStackTop(MyStack* obj) {
    if(!QueueEmpty(&amp;(obj-&gt;q1)))
    {
        return QueueBack(&amp;(obj-&gt;q1));//去队尾数据
    }
    else
    {
        return QueueBack(&amp;(obj-&gt;q2));
    }
}
//如果栈是空的，返回 true ；否则，返回 false 。
bool myStackEmpty(MyStack* obj) {
    return QueueEmpty(&amp;(obj-&gt;q1)) &amp;&amp; QueueEmpty(&amp;(obj-&gt;q2));
}
//销毁
void myStackFree(MyStack* obj) {
    QueueDestroy(&amp;(obj-&gt;q1));
    QueueDestroy(&amp;(obj-&gt;q2));
    free(obj);
}
</code></pre> 
<blockquote> 
 <p><strong><span style="color:#7b7f82;">感谢观看</span></strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/83faeb6588631c6b52b8209e3868615b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设计模式原则——接口隔离原则</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09f59adab3f0bae85522fe89a427adba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">速盾：ddos高防ip是什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>