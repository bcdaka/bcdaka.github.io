<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：线性表的链式储存 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/29c3eed759ab170363b71db8383d3a2f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构：线性表的链式储存">
  <meta property="og:description" content="🌈个人主页：Rookie Maker
🔥 系列专栏：数据结构
🏆🏆关注博主，随时获取更多关于IT的优质内容！🏆🏆 😀欢迎来到我的代码世界~
😁 喜欢的小伙伴记得一键三连哦 ૮(˶ᵔ ᵕ ᵔ˶)ა
​
一.线性表的链式储存 链表：线性表的链式储存方式，逻辑结构不一定连续，物理结构不一定连续
描述：由数据域和指针域组成
​
二.单链表 介绍：
由指针域和数据域组成，头指针，头结点，头结点中存储的首元素的地址
可以用头指针命名
1.优缺点 🔥任意位置插入删除，时间复杂度小
🔥没有增容问题，插入一个开辟一个空间
🔥不支持随机访问
2.创建​ //定义链表 typedef int SLTDataType;//数值域 //链表是由节点组成 typedef struct SListNode { SLTDataType data;//int data struct SListNode* next;//它用来存储当前节点的下一个节点的地址 }SLTNode;// 3.打印 void SLTPrint(SLTNode* phead) { SLTNode* pcur = phead;//头指针 while (pcur)//pcur不为空！ { printf(&#34;%d-&gt;&#34;, pcur-&gt;data); pcur = pcur-&gt;next;//依次找到下一个结点 } printf(&#34;NULL\n&#34;); } 4.申请空间 SLTNode* SLTBuyNode(SLTDataType x) { SLTNode* newnode = (SLTNode*)malloc(sizeof(SLTNode)); if (newnode == NULL) { perror(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-26T22:55:31+08:00">
    <meta property="article:modified_time" content="2024-04-26T22:55:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：线性表的链式储存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a id="_0"></a></h2> 
<p> 🌈<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a><a href="https://blog.csdn.net/2301_79712692?type=blog" title="：Rookie Maker">：Rookie Maker</a><br> 🔥 系列专栏：<a href="https://blog.csdn.net/2301_79712692/category_12570334.html" title="数据结构">数据结构</a><br> 🏆🏆关注博主，随时获取更多关于IT的优质内容！🏆🏆  </p> 
<hr> 
<p>😀欢迎来到我的代码世界~<br> 😁 喜欢的小伙伴记得一键三连哦 ૮(˶ᵔ ᵕ ᵔ˶)ა</p> 
<div> 
 <p><img alt="" src="https://images2.imgbox.com/c2/9e/aNfG41I9_o.gif">​</p> 
</div> 
<hr> 
<h2><a id="_12"></a>一.线性表的链式储存</h2> 
<p>链表：线性表的链式储存方式，逻辑结构不一定连续，物理结构不一定连续</p> 
<p>描述：由数据域和指针域组成</p> 
<div> 
 <p>​<img alt="" height="946" src="https://images2.imgbox.com/3c/de/i5sCnGzY_o.png" width="1200"></p> 
</div> 
<p><img alt="" height="970" src="https://images2.imgbox.com/a2/ed/z9t2nR4D_o.png" width="1200"></p> 
<h2> 二.单链表</h2> 
<p>介绍：</p> 
<p>由指针域和数据域组成，头指针，头结点，头结点中存储的首元素的地址</p> 
<blockquote> 
 <p>可以用头指针命名</p> 
</blockquote> 
<h3 style="background-color:transparent;">1.优缺点</h3> 
<p>🔥任意位置插入删除，<a class="link-info" href="https://so.csdn.net/so/search?spm=1001.2101.3001.4498&amp;q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;t=&amp;u=" title="时间复杂度">时间复杂度</a>小<br> 🔥没有增容问题，插入一个开辟一个空间</p> 
<p>🔥不支持随机访问</p> 
<h3 style="background-color:transparent;">2.创建​</h3> 
<div> 
 <pre><code class="language-cs">//定义链表
typedef int SLTDataType;//数值域
//链表是由节点组成
typedef struct SListNode
{
	SLTDataType data;//int data
	struct  SListNode* next;//它用来存储当前节点的下一个节点的地址
}SLTNode;//</code></pre> 
</div> 
<h3 style="background-color:transparent;">3.打印</h3> 
<div> 
 <pre><code class="language-cs">void SLTPrint(SLTNode* phead) {
	SLTNode* pcur = phead;//头指针
	while (pcur)//pcur不为空！
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;//依次找到下一个结点
	}
	printf("NULL\n");
}</code></pre> 
</div> 
<p></p> 
<h3 style="background-color:transparent;">4.申请空间</h3> 
<div> 
 <pre><code class="language-cpp">SLTNode* SLTBuyNode(SLTDataType x) {
	SLTNode* newnode = (SLTNode*)malloc(sizeof(SLTNode));
	if (newnode == NULL) {
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;

	return newnode;
}</code></pre> 
</div> 
<h3 style="background-color:transparent;">4.增加元素</h3> 
<p>尾插：​</p> 
<div> 
 <pre><code class="language-cpp">void SLTPushBack(SLTNode** pphead, SLTDataType x) {
	assert(pphead);

	SLTNode* newnode = SLTBuyNode(x);

	//链表为空，新节点作为phead
	if (*pphead == NULL) {
		*pphead = newnode;
		return;
	}
	//链表不为空，找尾节点
	SLTNode* ptail = *pphead;
	while (ptail-&gt;next)
	{
		ptail = ptail-&gt;next;
	}
	//ptail就是尾节点
	ptail-&gt;next = newnode;
}</code></pre> 
</div> 
<p>头插：</p> 
<div> 
 <pre><code class="language-cs">void SLTPushFront(SLTNode** pphead, SLTDataType x) {
	assert(pphead);
	SLTNode* newnode = SLTBuyNode(x);

	//newnode *pphead
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}</code></pre> 
</div> 
<p>在指定位置插入​</p> 
<div> 
 <pre><code class="language-cs">//在指定位置之前插入数据
void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x) {
	assert(pphead);
	assert(pos);
	//要加上链表不能为空
	assert(*pphead);

	SLTNode* newnode = SLTBuyNode(x);
	//pos刚好是头结点
	if (pos == *pphead) {
		//头插
		SLTPushFront(pphead, x);
		return;
	}

	//pos不是头结点的情况
	SLTNode* prev = *pphead;
	while (prev-&gt;next != pos)
	{
		prev = prev-&gt;next;
	}
	//prev -&gt; newnode -&gt; pos
	prev-&gt;next = newnode;
	newnode-&gt;next = pos;
}</code></pre> 
</div> 
<h3>5.删除元素</h3> 
<p> 尾删​</p> 
<div> 
 <pre><code class="language-cs">void SLTPopBack(SLTNode** pphead) {
	assert(pphead);
	//链表不能为空
	assert(*pphead);
	//链表不为空
	//链表只有一个节点，有多个节点
	if ((*pphead)-&gt;next == NULL) {
		free(*pphead);
		*pphead = NULL;
		return;
	}
	SLTNode* ptail = *pphead;
	SLTNode* prev = NULL;
	while (ptail-&gt;next)
	{
		prev = ptail;
		ptail = ptail-&gt;next;
	}
	prev-&gt;next = NULL;
	//销毁尾结点
	free(ptail);
	ptail = NULL;
}</code></pre> 
</div> 
<p> 头删​</p> 
<div> 
 <pre><code class="language-cs">void SLTPopFront(SLTNode** pphead) {
	assert(pphead);
	//链表不能为空
	assert(*pphead);
	//让第二个节点成为新的头
	//把旧的头结点释放掉
	SLTNode* next = (*pphead)-&gt;next;
	free(*pphead);
	*pphead = next;
}</code></pre> 
</div> 
<p>🔥指定位置删除:注意删除的逻辑​</p> 
<div> 
 <pre><code class="language-cs">//删除pos节点
void SLTErase(SLTNode** pphead, SLTNode* pos) {
	assert(pphead);
	assert(*pphead);
	assert(pos);

	//pos刚好是头结点，没有前驱节点，执行头删
	if (*pphead == pos) {
		//头删
		SLTPopFront(pphead);
		return;
	}

	SLTNode* prev = *pphead;
	while (prev-&gt;next != pos)
	{
		prev = prev-&gt;next;
	}
	//prev pos pos-&gt;next
	prev-&gt;next = pos-&gt;next;
	free(pos);
	pos = NULL;
}
void SLTEraseAfter(SLTNode* pos) {
	assert(pos);
	//pos-&gt;next不能为空
	assert(pos-&gt;next);

	//pos  pos-&gt;next  pos-&gt;next-&gt;next
	SLTNode* del = pos-&gt;next;
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(del);
	del = NULL;
}</code></pre> 
</div> 
<h3><strong>6.修改元素</strong></h3> 
<div> 
 <pre><code class="language-cpp">//给一个数据，找到这个数据所在的节点，并用新数据修改
void SListChangeDate(SLTNode*pphead, SLTDataType x, SLTDataType y)
//不需要改变节点的地址，所以值传递即可 
//x是查找的数据，y是新的数据，用来修改查找的数据                                              
{
	SLTNode*cru = pphead;
	while (cru != NULL)//如果没有节点，根本不会进入循环去找
	{
		if (cru-&gt;data == x)
		{
			cru-&gt;data = y;
			break;//修改完数据后，就跳出循环
		}
		else
		{
			cru = cru-&gt;next;
		}
	}
	if (cru == NULL)//如果循环完单链表，没有找到要修改的那个数据
	{
		printf("要修改的数据不存在，请重新修改数据\n");
	}
	else
	{
		printf("修改成功\n");
	}
}</code></pre> 
</div> 
<h3>7.查找元素</h3> 
<div> 
 <pre><code class="language-cs">SLTNode* SLTFind(SLTNode** pphead, SLTDataType x) {
	assert(pphead);
	//遍历链表 
	SLTNode* pcur = *pphead;
	while (pcur) //pcur != NULL
	{
		if (pcur-&gt;data == x) {
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	//没有找到
	return NULL;
}</code></pre> 
</div> 
<h3>8.销毁链表​</h3> 
<div> 
 <pre><code class="language-cs">void SListDesTroy(SLTNode** pphead) {
	assert(pphead);
	assert(*pphead);

	SLTNode* pcur = *pphead;
	while (pcur)
	{
		SLTNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	*pphead = NULL;
}</code></pre> 
</div> 
<h2>三.双向链表</h2> 
<h3><strong>1.注意</strong></h3> 
<p>🔥带头双向循环链表</p> 
<p>🔥当链表中只要头节点的时候，为空链表</p> 
<p>🔥头节点是不能删除的，指向可以改变</p> 
<p>🔥不需要改变头节点的指向，不需要传二级指针</p> 
<p>🔥二级指针对实参会产生影响 ​</p> 
<h3> 2.创建</h3> 
<div> 
 <pre><code class="language-cs">typedef int LTDataType;
typedef struct ListNode {
	LTDataType data;
	struct ListNode* prev;
	struct ListNode* next;
}LTNode;</code></pre> 
</div> 
<h3>3.打印</h3> 
<div> 
 <pre><code class="language-cs">LTNode* LTInit() {
	LTNode* phead = LTBuyNode(-1);
	return phead;
}</code></pre> 
</div> 
<h3><strong>4.增加元素</strong></h3> 
<p>尾插<strong>（不需要找尾操作</strong><strong>）</strong>​</p> 
<div> 
 <pre><code class="language-cs">//尾插
void LTPushBack(LTNode* phead, LTDataType x) {
	assert(phead);
	LTNode* newnode = LTBuyNode(x);
	//phead phead-&gt;prev(ptail)  newnode
	newnode-&gt;next = phead;
	newnode-&gt;prev = phead-&gt;prev;

	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}</code></pre> 
</div> 
<div> 
 <pre><code class="language-cs">//头插
void LTPushFront(LTNode* phead, LTDataType x) {
	assert(phead);

	LTNode* newnode = LTBuyNode(x);
	//phead newnode phead-&gt;next
	newnode-&gt;next = phead-&gt;next;
	newnode-&gt;prev = phead;

	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}</code></pre> 
</div> 
<p>任意位置插入</p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/09/3e/LRbJ2VTY_o.png" width="864">​</p> 
<div> 
 <pre><code class="language-cs">//在pos位置之后插入数据
void LTInsert(LTNode* pos, LTDataType x) {
	assert(pos);
	LTNode* newnode = LTBuyNode(x);
	//pos newnode pos-&gt;next
	newnode-&gt;next = pos-&gt;next;
	newnode-&gt;prev = pos;

	pos-&gt;next-&gt;prev = newnode;
	pos-&gt;next = newnode;
}
//删除pos位置的数据
void LTErase(LTNode* pos) {
	assert(pos);

	//pos-&gt;prev pos  pos-&gt;next
	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;

	free(pos);
	pos = NULL;
}</code></pre> 
</div> 
<h3><strong>5.删除元素</strong></h3> 
<p><strong>头删</strong>​</p> 
<div> 
 <pre><code class="language-cs">void LTPopFront(LTNode* phead) {
	assert(phead);
	assert(phead-&gt;next != phead);

	LTNode* del = phead-&gt;next;
	LTNode* next = del-&gt;next;

	//phead del next
	next-&gt;prev = phead;
	phead-&gt;next = next;

	free(del);
	del = NULL;
}</code></pre> 
</div> 
<p> 尾删</p> 
<div> 
 <pre><code class="language-cs">void LTPopBack(LTNode* phead) {
	assert(phead);
	//链表为空：只有一个哨兵位节点
	assert(phead-&gt;next != phead);

	LTNode* del = phead-&gt;prev;
	LTNode* prev = del-&gt;prev;

	prev-&gt;next = phead;
	phead-&gt;prev = prev;

	free(del);
	del = NULL;
}</code></pre> 
</div> 
<p> 任意位置删除</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/a8/4a/nqGVynoF_o.png" width="652">​</p> 
<p></p> 
<div> 
 <pre><code class="language-cs">void LTErase(LTNode* pos) {
	assert(pos);

	//pos-&gt;prev pos  pos-&gt;next
	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;

	free(pos);
	pos = NULL;
}</code></pre> 
</div> 
<h3>6.修改元素</h3> 
<div> 
 <pre><code class="language-cs">void DeleteNode(LTNode** pHead, LTNode* toBeDeleted) {
    if (pHead == NULL || toBeDeleted == NULL) {
        return;
    }

    LTNode* head = *pHead;

    // 要删除的节点是头节点
    if (head == toBeDeleted) {
        *pHead = toBeDeleted-&gt;next;
    }
    
    // 调整前驱节点的next指针
    if (toBeDeleted-&gt;prev != NULL) {
        toBeDeleted-&gt;prev-&gt;next = toBeDeleted-&gt;next;
    }
    
    // 调整后继节点的prev指针
    if (toBeDeleted-&gt;next != NULL) {
        toBeDeleted-&gt;next-&gt;prev = toBeDeleted-&gt;prev;
    }
    
    free(toBeDeleted);
}
</code></pre> 
</div> 
<h3>7.查找元素</h3> 
<div> 
 <pre><code class="language-cs">LTNode* LTFind(LTNode* phead, LTDataType x) {
	assert(phead);
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		if (pcur-&gt;data == x) {
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;
}</code></pre> 
</div> 
<h3>8.销毁链表</h3> 
<div> 
 <pre><code class="language-cs">void LTDesTroy(LTNode* phead) {
	//哨兵位不能为空
	assert(phead);

	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		LTNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	//链表中只有一个哨兵位
	free(phead);
	phead = NULL;
}</code></pre> 
</div> 
<p> 🎁🎁🎁今天的分享到这里就结束啦！如果觉得文章还不错的话，可以三连支持一下，您的支持就是我前进的动力！<img alt="" src="https://images2.imgbox.com/a4/01/JMuJRKSq_o.gif">​</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1753e45664c8c3c82504e9f08aa5c922/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hadoop介绍：什么是Hadoop？了解Hadoop的应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f830e05a7636b4def0e39cd24e7552b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">有没有佬知道、streamlit run webui.py的时候出现TypeError: ‘NoneType‘ object is not iterable咋解决哇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>