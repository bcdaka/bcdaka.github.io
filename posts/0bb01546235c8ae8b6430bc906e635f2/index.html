<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMq的五大消息模型及Java代码演示 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0bb01546235c8ae8b6430bc906e635f2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RabbitMq的五大消息模型及Java代码演示">
  <meta property="og:description" content="RabbitMq一共有6种消息模型，分别为：
1.基本模型（Hello World）
2.消息分发（工作队列）模型（Work queues）
3.Fanout订阅模型-消息订阅模式（Publish/Subscribe）
4.Direct订阅模型-路由模式（Routing）
5.Topic订阅模型-匹配模式（Topic）
6.RPC模式（RPC）
而其中的RPC模式，它并不完全属于消息队列（MQ）的定义，而是使用MQ的某些功能来实现RPC的效果。
所以简单的介绍下以下五种消息模型：
一.基本模型（Hello World） 1.这是个非常简单的模型，即一个生产者发送消息到一个队列，一个消费者从该队列中接收并处理消息。
2.主要适用于RabbitMq的测试和日常我们学习的场景，在需要快速搭建轻量级消息队列系统的应用中，简单模式也是个很好的选择。
代码实现：
在RabbitMq的webUI界面去创建，为了方便我直接在RabbitMq管理页面创建一个名为basic1的队列（我们也可以在Java代码中去配置queue,交换机及其绑定，为了方便展示用了管理页面）
用postMan请求，生产者发送消息
package com.org.product.controller; import com.org.product.config.MqProductCallBack; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.MessageDeliveryMode; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; /** * Created with IntelliJ IDEA. * @Author: 你的名字 */ @RestController @RequestMapping(&#34;/product&#34;) @Slf4j public class PushMessageController { @Resource private RabbitTemplate rabbitTemplate; @Resource private MqProductCallBack mqProductCallBack; @GetMapping(&#34;/basic&#34;) public String basic(){ log.info(&#34;-------------消息推送开始--------------&#34;); //创建CorrelationData对象，包含唯一id,id的作用是在回调函数中识别消息，也就是根据id跟踪这条消息 CorrelationData correlationData = new CorrelationData(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-27T15:05:10+08:00">
    <meta property="article:modified_time" content="2024-06-27T15:05:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMq的五大消息模型及Java代码演示</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>RabbitMq一共有6种消息模型，分别为：</p> 
<blockquote> 
 <p><strong>1.基本模型（Hello World）</strong></p> 
 <p><strong>2.消息分发（工作队列）模型（Work queues）</strong></p> 
 <p><strong>3.Fanout订阅模型-消息订阅模式（Publish/Subscribe）</strong></p> 
 <p><strong>4.Direct订阅模型-路由模式（Routing）</strong></p> 
 <p><strong>5.Topic订阅模型-匹配模式（Topic）</strong></p> 
 <p><strong>6.RPC模式（RPC）</strong></p> 
 <p>而其中的RPC模式，它并不完全属于消息队列（MQ）的定义，而是使用MQ的某些功能来实现RPC的效果。</p> 
</blockquote> 
<p>所以简单的介绍下以下五种消息模型：</p> 
<h3>一.<strong>基本模型（Hello World）</strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b7/e0/YkhSfI9P_o.png"></p> 
<blockquote> 
 <p>1.这是个非常简单的模型，即一个生产者发送消息到一个队列，一个消费者从该队列中接收并处理消息。</p> 
 <p>2.主要适用于RabbitMq的测试和日常我们学习的场景，在需要快速搭建轻量级消息队列系统的应用中，简单模式也是个很好的选择。</p> 
</blockquote> 
<p>代码实现：</p> 
<p>在RabbitMq的webUI界面去创建，为了方便我直接在RabbitMq管理页面创建一个名为basic1的队列（我们也可以在Java代码中去配置queue,交换机及其绑定，为了方便展示用了管理页面）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/50/a2/fdkYOL9W_o.png"></p> 
<p>用postMan请求，生产者发送消息</p> 
<pre><code class="language-java">package com.org.product.controller;

import com.org.product.config.MqProductCallBack;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.MessageDeliveryMode;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

/**
 * Created with IntelliJ IDEA.
 * @Author: 你的名字
 */
@RestController
@RequestMapping("/product")
@Slf4j
public class PushMessageController {
    @Resource
    private RabbitTemplate rabbitTemplate;
    @Resource
    private MqProductCallBack mqProductCallBack;


    @GetMapping("/basic")
    public String basic(){
        log.info("-------------消息推送开始--------------");
        //创建CorrelationData对象，包含唯一id,id的作用是在回调函数中识别消息，也就是根据id跟踪这条消息
        CorrelationData correlationData = new CorrelationData("id_" + System.currentTimeMillis());
        //消息确认与返回
        rabbitTemplate.setConfirmCallback(mqProductCallBack);
        rabbitTemplate.setReturnsCallback(mqProductCallBack);
        /**
         *消息发送
         *在简单模式下，由于使用默认的交换机，则要保持路由名称和队列名称一致，才能把消息发送到队列中去；
         *也就是routingKey写队列名称
         */
        rabbitTemplate.convertAndSend("basic1","小飞棍来喽！",
                //Lambda表达式，实现MessagePostProcessor接口
                message -&gt; {
                    //获取消息的属性，设置传输模式DeliveryMode为持久化，会写入磁盘
                    message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                    //返回修改后的消息
                    return message;
                }, correlationData);
        log.info("--------------消息推送结束------------------");
        return "消息发送成功了！！！";
    }
}</code></pre> 
<p>控制台</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/39/f6/Yau5MEan_o.png"></p> 
<p>消费者监听 </p> 
<pre><code class="language-java">package com.org.consumer.listener;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * Created with IntelliJ IDEA.
 *
 * @Author: 你的名字
 * @Description:监听消息
 */
@Component
public class MessageListener {

    @RabbitListener(queues ="basic1")
    public void handleMessage(String message) {
        //处理接收到的消息
        System.out.println("接收到的消息是：" + message);
    }


    //手动ack
//    @RabbitListener(queues = "queue2")
//    public void handleMessage1(String message,Channel channel, @Header(AmqpHeaders.DELIVERY_TAG)Long tag) throws IOException {
//        System.out.println("接收到的消息是：" + message);
//        try {
//            Thread.sleep(2000);
//            //发生异常
//            int i = 1/0;
//            //手动ack
//            channel.basicAck(tag,false);
//        } catch (Exception e) {
//            //手动ack，让消息重回队列，参数三表示是否重回队列
//         channel.basicNack(tag,false,false);
//
//        }
//
//    }
}</code></pre> 
<p>控制台</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ae/5b/UJF3pZv5_o.png"></p> 
<p></p> 
<p></p> 
<h3>二 .<strong>消息分发（工作队列）模型（Work queues）</strong></h3> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/11/68/gXRod5ec_o.png"></strong></p> 
<blockquote> 
 <p>1.工作队列将一些耗时的任务封装为消息，并将其发送到一个中心队列，多个消费者同时从队列中获取任务，每个任务只会被一个消费者获取并处理。</p> 
 <p>2.工作队列模型主要适用于长时间运行的任务场景，例如订单系统，当单个订单的处理时间较长（比如15秒），我们可以将多个订单同时放入消息队列中，让多个消费者同时处理这些订单，从而实现并行处理而不是串行处理；还可以实现需要异步处理任务的场景，如更新数据库等。</p> 
</blockquote> 
<p>代码实现：</p> 
<p>和上边一样我们先创建名为work1的队列</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/93/5d/BqZZnTgw_o.png"></p> 
<p>生产者代码</p> 
<pre><code class="language-java">    @GetMapping("/work")
    public String work(){
        log.info("-------------消息推送开始--------------");
        //发送10条消息测试
        for (int i = 1; i &lt;= 10; i++) {
            //创建CorrelationData对象，包含唯一id,id的作用是在回调函数中识别消息，也就是根据id跟踪这条消息
            CorrelationData correlationData = new CorrelationData("id_" + System.currentTimeMillis());
            //消息确认与返回
            rabbitTemplate.setConfirmCallback(mqProductCallBack);
            rabbitTemplate.setReturnsCallback(mqProductCallBack);
            /**
             *消息发送
             *在工作队列模式下，由于使用默认的交换机，则要保持路由名称和队列名称一致，才能把消息发送到队列中去；
             *也就是routingKey写队列名称
             */
            rabbitTemplate.convertAndSend("work1","小飞棍来喽"+i+"!",
                    //Lambda表达式，实现MessagePostProcessor接口
                    message -&gt; {
                        //获取消息的属性，设置传输模式DeliveryMode为持久化，会写入磁盘
                        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                        //返回修改后的消息
                        return message;
                    }, correlationData);
        }
        log.info("--------------消息推送结束------------------");

        return "消息发送成功了！！！";
    }</code></pre> 
<p>控制台</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f0/5d/GXOrouap_o.png"></p> 
<p> 消费者代码</p> 
<pre><code class="language-java"> @RabbitListener(queues = "work1")
    public void workQueue1(String message){
        System.out.println("消费者--1--接收到的消息是：" + message);
    }

    @RabbitListener(queues = "work1")
    public void workQueue2(String message){
        System.out.println("消费者--2--接收到的消息是：" + message);
    }</code></pre> 
<p>控制台</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9f/d3/nYc0Veuh_o.png"></p> 
<p></p> 
<h3>三. <strong>Fanout订阅模型-消息订阅模式（Publish/Subscribe）</strong></h3> 
<p><img alt="" src="https://images2.imgbox.com/27/a5/3igLXkye_o.png"></p> 
<blockquote> 
 <p>1.Fanout订阅模型和工作队列模式比较，前者用到了fanout交换机，并广播到多个队列，消息生产者将消息发送到交换机（Exchange）,而交换机以广播的形式将消息发送给所有与该交换机绑定的队列，从而实现了消息的广播。</p> 
 <p>2.Fanout交换机：主要用来将消息广播给绑定该交换机的队列，不关心消息的路由键是什么，也就是无论消息路由键是什么，Fanout交换机都将消息发送给绑定的队列，与Direct交换机相比，不需要设置路由键就可以将消息广播到所有队列，与Topic交换机相比，它不支持通配符匹配路由键。</p> 
 <p>3.主要适用于将消息广播给多个消费者，例如：日志记录，实时消息推送等</p> 
</blockquote> 
<p>代码实现：</p> 
<p>（1）首先我们在web界面创建名为fanout_queue1,fanout_queue2队列。</p> 
<p>（2）在创建Fanout类型交换机，名为fanout_exchange。</p> 
<p>（3）绑定队列fanout_queue1,fanout_queue2</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a9/76/q3gcRkne_o.png"></p> 
<p>路由键Routing key 设不设置都可以，我这边就不设置了</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/4b/65xCLgul_o.png"></p> 
<p>生产者代码</p> 
<pre><code class="language-java"> @GetMapping("/fanout")
    public String fanout() {
        for (int i = 1; i &lt;= 4; i++) {
            //创建CorrelationData对象，包含唯一id,id的作用是在回调函数中识别消息，也就是根据id跟踪这条消息
            CorrelationData correlationData = new CorrelationData("id_" + System.currentTimeMillis());
            //消息确认与返回
            rabbitTemplate.setConfirmCallback(mqProductCallBack);
            rabbitTemplate.setReturnsCallback(mqProductCallBack);
            /**
             *消息发送
             *在fanout订阅模式我们可以随意定义路由
             *也就是routingKey写队列名称
             */
            rabbitTemplate.convertAndSend("fanout_exchange", "666", "小飞棍来喽" + i + "!",
                    //Lambda表达式，实现MessagePostProcessor接口
                    message -&gt; {
                        //获取消息的属性，设置传输模式DeliveryMode为持久化，会写入磁盘
                        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                        //返回修改后的消息
                        return message;
                    }, correlationData);
        }
        return "消息发送成功了！！！";
    }</code></pre> 
<p>控制台：4条消息发送成功</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bb/90/cOhCb63o_o.png"></p> 
<p>消费者代码：定义两个分别监听两个队列的消费者</p> 
<pre><code class="language-java"> //fanout订阅模式
    @RabbitListener(queues = "fanout_queue1")
    public void fanout1(String message){
        System.out.println("fanout_queue1--的消息是：" + message);
    }

    @RabbitListener(queues = "fanout_queue2")
    public void fonout2(String message){
        System.out.println("fanout_queue2--的消息是：" + message);
    }</code></pre> 
<p> 控制台：4条消息，分别广播到两个队列</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/3b/ue7UZgov_o.png"></p> 
<h3>四<strong>.Direct订阅模型-路由模式（Routing）</strong></h3> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/89/61/JJ6iaFnz_o.png"></h3> 
<blockquote> 
 <p> 1.Direct订阅模式用到了Direct交换机，不同于Fanout订阅模式，它必须指定路由键，允许消费者只接收与特定路由键匹配的消息，从而实现了有选择性接收，它的匹配方式是精确匹配，即路由键和绑定键必须完全相同，不同则无法将消息正确路由到对应的队列，消息可能会被丢弃或者根据RabbitMq配置进行处理（如返回给生产者或者进入死信队列）。</p> 
 <p>2.Direct订阅模式适用于日志处理，订单系统等，比如我们根据订单号将订单消息路由到特定的处理队列中。</p> 
</blockquote> 
<p>代码实现：</p> 
<p>（1）我们在RabbitMq的web管理页面创建Direct交换机，名为direct_exchange。</p> 
<p>（2）然后创建两个队列，分列为direct_queue1,direct_queue2。（你也可以用之前创建过的）</p> 
<p>（3）交换机direct_exchange和direct_queue1的绑定路由键为direct_key1。</p> 
<p>         交换机direct_exchange与direct_queue2绑定的路由键为direct_key2。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/46/DnjFJ3co_o.png"></p> 
<p>生产者代码：将 "小飞棍来喽A、B、C" 发送到direct_queue2队列，将 "小飞棍来喽A" 发送到direct_queue1队列</p> 
<pre><code class="language-java"> @GetMapping("/direct")
    public String direct() {
        //创建CorrelationData对象，包含唯一id,id的作用是在回调函数中识别消息，也就是根据id跟踪这条消息
        CorrelationData correlationData = new CorrelationData("id_" + System.currentTimeMillis());
        //消息确认与返回
        rabbitTemplate.setConfirmCallback(mqProductCallBack);
        rabbitTemplate.setReturnsCallback(mqProductCallBack);
        /**
         *消息发送
         *在direct订阅模式我们要精准路由
         */
        rabbitTemplate.convertAndSend("direct_exchange", "direct_key2", "小飞棍来喽A", message -&gt; {
            //获取消息的属性，设置传输模式DeliveryMode为持久化，会写入磁盘
            message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
            //返回修改后的消息
            return message;},correlationData);
        rabbitTemplate.convertAndSend("direct_exchange","direct_key2","小飞棍来喽B",message -&gt; {
            //获取消息的属性，设置传输模式DeliveryMode为持久化，会写入磁盘
            message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
            //返回修改后的消息
            return message;},correlationData);
        rabbitTemplate.convertAndSend("direct_exchange","direct_key2","小飞棍来喽C",message -&gt; {
            //获取消息的属性，设置传输模式DeliveryMode为持久化，会写入磁盘
            message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
            //返回修改后的消息
            return message;},correlationData);
        rabbitTemplate.convertAndSend("direct_exchange", "direct_key1", "小飞棍来喽A",message -&gt; {
            //获取消息的属性，设置传输模式DeliveryMode为持久化，会写入磁盘
            message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
            //返回修改后的消息
            return message;},correlationData);
        return "消息发送成功了！！！";
    }</code></pre> 
<p>控制台：4条消息发送成功</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/65/mEpPt9sD_o.png"></p> 
<p>消费者代码：</p> 
<pre><code class="language-java"> //direct订阅模式
    @RabbitListener(queues = "direct_queue1")
    public void direct1(String message){
        System.out.println("direct_queue1--的消息是：" + message);
    }

    @RabbitListener(queues = "direct_queue2")
    public void direct2(String message){
        System.out.println("direct_queue2--的消息是：" + message);
    }</code></pre> 
<p> 控制台：消费者把对应的队列消息消费下来了</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2a/18/jcRMD2Ow_o.png"></p> 
<h3><strong>五.</strong><strong>5.Topic订阅模型-匹配模式（Topic）</strong></h3> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/9d/a6/TttcLzmT_o.png"></strong></p> 
<blockquote> 
 <p> 1.Topic订阅模型相比Direct订阅模型，分组更细致，也更灵活，他允许在路由键上使用通配符,并根据发送消息时携带的路由键进行模糊匹配。需要注意的是用通配符匹配，单词之间要用（.）分隔。</p> 
 <p>2.通配符：<br><span style="color:#0d0016;"><strong>*</strong></span><strong>（星号）匹配一个单词</strong>：例如，我们代码中配置的路由键是superman.A或superman.B或superman.C那么我们绑定的键（Binding Key）为superman.*的队列将会匹配到这个路由键，但是如果是superman.A.D，就不会匹配到</p> 
 <p><strong>#（井号）匹配零个或者多个单词</strong>：例如，路由键是superman.A.D，那么绑定的superman.#的队列会匹配到这个路由键，当然如果是superman.A.D.E等都会匹配到（注意,不建议用#.#它会导致接收到大量的消息）</p> 
 <p>3.Topic订阅模型适用于根据消息内容或者类别来进行灵活分类。例如分布式任务调度，新闻订阅等。</p> 
</blockquote> 
<p>代码实现：</p> 
<p>先在RabbitMq管理页面新建topic_exchange交换机</p> 
<p>然后建立两个队列topic_queue1,topic_queue2</p> 
<p>最后topic_exchange交换机绑定topic_queue1的路由键为topic.*；绑定topic_queue2的路由键为topic.#</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1b/23/Dctdu32k_o.png"></p> 
<p>生产者代码</p> 
<pre><code class="language-java">   @GetMapping("/topic")
    public String topic() {
        //创建CorrelationData对象，包含唯一id,id的作用是在回调函数中识别消息，也就是根据id跟踪这条消息
        CorrelationData correlationData = new CorrelationData("id_" + System.currentTimeMillis());
        //消息确认与返回
        rabbitTemplate.setConfirmCallback(mqProductCallBack);
        rabbitTemplate.setReturnsCallback(mqProductCallBack);
        /**
         * 发送给topic_queue1
         * 因为topic_queue1我们绑定的路由键是topic.*,所以我们routingKey可以写（topic.任何一个单词）
         */
        rabbitTemplate.convertAndSend("topic_exchange", "topic.A", "小飞棍来喽A！", message -&gt; {
            message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
            return message;
        }, correlationData);
        /**
         * 发送给topic_queue2
         * 因为topic_queue2我们绑定的路由键是topic.#,所以我们routingKey可以写（topic.一个或者多个单词）
         */
        rabbitTemplate.convertAndSend("topic_exchange", "topic.B.B.B", "小飞棍来喽B", message -&gt; {
            message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
            return message;
        }, correlationData);
        
        return "消息发送成功了！！！";
    }</code></pre> 
<p>消费者代码</p> 
<pre><code class="language-java">  //topic订阅模式
    @RabbitListener(queues = "topic_queue1")
    public void topic1(String message){
        System.out.println("topic_queue1--的消息是：" + message);
    }

    @RabbitListener(queues = "topic_queue2")
    public void topic2(String message){
        System.out.println("topic_queue2--的消息是：" + message);
    }</code></pre> 
<p>消费者控制台</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/9e/3Ro7P8Ry_o.png"></p> 
<p>由上边的消费结果可以看出，topic_queue1接收到一条消息，topic_queue2接收到两条消息，</p> 
<p>是因为topic.*的路由匹配topic.A,而匹配不到topic.B.B.B,</p> 
<p>而topic.#的路由匹配到了topic.A以及topic.B.B.B</p> 
<blockquote> 
 <p>以上五种模型涵盖了RabbitMQ的主要消息传递方式，从简单的点到点通信到复杂的发布/订阅模式，可以满足不同应用场景的需求。同时，RabbitMQ还提供了消息确认机制、消息持久化、消息优先级和消息过期时间等特性，以保证消息的可靠性、持久性和灵活性，我们可以根据我们业务的需求场景来决定使用哪一种消息模式。</p> 
</blockquote> 
<p>上边的SpringBoot代码工程在上一篇SpringBoot集成RabbitMq</p> 
<p>链接：<a href="https://blog.csdn.net/Aa5107033/article/details/139934879?spm=1001.2014.3001.5501" title="一文搞定springBoot集成RabbitMq-CSDN博客">一文搞定springBoot集成RabbitMq-CSDN博客</a></p> 
<p>欲渡黄河冰塞川，将登太行雪满山~~</p> 
<p>文章有不足之处欢迎各位纠正，希望能和大家一起砥砺前行！！！加油</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3eff5bd7951767e6ad23967177efa838/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">性能测试 —— Jmeter日志查看与分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/314f52101d6b25a4e0a1f97c3bcc0bc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从万里长城防御体系看软件安全体系建设@安全历史03</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>