<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】第五讲：栈和队列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2e87f451bf0ca95cab644503a4d42e68/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】第五讲：栈和队列">
  <meta property="og:description" content="个人主页：深情秋刀鱼@-CSDN博客
数据结构专栏：数据结构与算法
源码获取：数据结构: 上传我写的关于数据结构的代码 (gitee.com)
目录
一、栈
1.栈的定义
2.栈的实现
a.栈结构的定义
b.初始化
c.扩容
d.入栈
e.出栈
f.打印
g.取栈顶元素
h.判空
i.获取栈中的元素个数
j.销毁
二、队列 1.队列的定义
2.队列的实现
a.队列结构的定义
b.初始化
c.创建节点
d.入队
e.出队
f.队中的元素个数
g.队列判空
h.队列打印
i.取队头元素
j.取队尾元素
k.销毁
一、栈 1.栈的定义 栈是一种特殊的线性表，其只允许在固定的一段进行插入和删除元素的操作。进行数据的插入和删除元素的操作的一端被称为栈顶，另一端被称为栈底。栈中的数据元素遵循后进先出LIFO（Last in First out）的原则。
2.栈的实现 栈的实现一般可以用数组和链表实现，一般情况下用数组实现更为合适，因为在数组尾部进行插入和删除操作的代价较小。
a.栈结构的定义 typedef int STDataType; //定义栈结构（数组） typedef struct Stack { STDataType* a; //数组栈 int top;	//栈顶 int capacity; //容量 }Stack; b.初始化 void STInit(Stack* pst) { assert(pst); pst-&gt;a = NULL; pst-&gt;capacity = 0; pst-&gt;top = -1; } c.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-11T11:06:46+08:00">
    <meta property="article:modified_time" content="2024-05-11T11:06:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】第五讲：栈和队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="261" src="https://images2.imgbox.com/f7/f2/ROoBQBXh_o.jpg" width="264"></p> 
<p style="text-align:center;"> <strong><span style="background-color:#ffd900;">个人主页：</span></strong><a href="https://blog.csdn.net/zwznzje?spm=1000.2115.3001.5343" title="深情秋刀鱼@-CSDN博客">深情秋刀鱼@-CSDN博客</a></p> 
<p style="text-align:center;"><strong><span style="background-color:#ffd900;">数据结构专栏：</span></strong><a href="https://blog.csdn.net/zwznzje/category_12627654.html" title="数据结构与算法">数据结构与算法</a></p> 
<p style="text-align:center;"><strong><span style="background-color:#ffd900;">源码获取：</span></strong><a href="https://gitee.com/zwz17337480000/data-structure" rel="nofollow" title="数据结构: 上传我写的关于数据结构的代码 (gitee.com)">数据结构: 上传我写的关于数据结构的代码 (gitee.com)</a></p> 
<p class="img-center"><img alt="" height="74" src="https://images2.imgbox.com/51/b1/y1QbGyl6_o.gif" width="590"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E6%A0%88-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%A0%88" rel="nofollow">一、栈</a></p> 
<p id="1.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.栈的定义</a></p> 
<p id="%C2%A02.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A02.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow"> 2.栈的实现</a></p> 
<p id="%C2%A0a.%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%C2%A0a.%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow"> a.栈结构的定义</a></p> 
<p id="b.%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#b.%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">b.初始化</a></p> 
<p id="c.%E6%89%A9%E5%AE%B9-toc" style="margin-left:80px;"><a href="#c.%E6%89%A9%E5%AE%B9" rel="nofollow">c.扩容</a></p> 
<p id="d.%E5%85%A5%E6%A0%88-toc" style="margin-left:80px;"><a href="#d.%E5%85%A5%E6%A0%88" rel="nofollow">d.入栈</a></p> 
<p id="e.%E5%87%BA%E6%A0%88-toc" style="margin-left:80px;"><a href="#e.%E5%87%BA%E6%A0%88" rel="nofollow">e.出栈</a></p> 
<p id="f.%E6%89%93%E5%8D%B0-toc" style="margin-left:80px;"><a href="#f.%E6%89%93%E5%8D%B0" rel="nofollow">f.打印</a></p> 
<p id="g.%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#g.%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0" rel="nofollow">g.取栈顶元素</a></p> 
<p id="%C2%A0h.%E5%88%A4%E7%A9%BA-toc" style="margin-left:80px;"><a href="#%C2%A0h.%E5%88%A4%E7%A9%BA" rel="nofollow"> h.判空</a></p> 
<p id="i.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#i.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow">i.获取栈中的元素个数</a></p> 
<p id="j.%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#j.%E9%94%80%E6%AF%81" rel="nofollow">j.销毁</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">二、队列 </a></p> 
<p id="1.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.队列的定义</a></p> 
<p id="2.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.队列的实现</a></p> 
<p id="a.%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#a.%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">a.队列结构的定义</a></p> 
<p id="b.%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#b.%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">b.初始化</a></p> 
<p id="c.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#c.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9" rel="nofollow">c.创建节点</a></p> 
<p id="d.%E5%85%A5%E9%98%9F-toc" style="margin-left:80px;"><a href="#d.%E5%85%A5%E9%98%9F" rel="nofollow">d.入队</a></p> 
<p id="e.%E5%87%BA%E9%98%9F-toc" style="margin-left:80px;"><a href="#e.%E5%87%BA%E9%98%9F" rel="nofollow">e.出队</a></p> 
<p id="f.%E9%98%9F%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#f.%E9%98%9F%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow">f.队中的元素个数</a></p> 
<p id="g.%E9%98%9F%E5%88%97%E5%88%A4%E7%A9%BA-toc" style="margin-left:80px;"><a href="#g.%E9%98%9F%E5%88%97%E5%88%A4%E7%A9%BA" rel="nofollow">g.队列判空</a></p> 
<p id="h.%E9%98%9F%E5%88%97%E6%89%93%E5%8D%B0-toc" style="margin-left:80px;"><a href="#h.%E9%98%9F%E5%88%97%E6%89%93%E5%8D%B0" rel="nofollow">h.队列打印</a></p> 
<p id="i.%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#i.%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0" rel="nofollow">i.取队头元素</a></p> 
<p id="%C2%A0j.%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#%C2%A0j.%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0" rel="nofollow"> j.取队尾元素</a></p> 
<p id="%C2%A0k.%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#%C2%A0k.%E9%94%80%E6%AF%81" rel="nofollow"> k.销毁</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%A0%88">一、栈</h2> 
<h3 id="1.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89">1.栈的定义</h3> 
<p>        栈是一种特殊的线性表，其只允许在固定的一段进行插入和删除元素的操作。进行数据的插入和删除元素的操作的一端被称为<strong>栈顶</strong>，另一端被称为<strong>栈底</strong>。栈中的数据元素遵循<strong>后进先出LIFO（Last in First out）</strong>的原则。</p> 
<p class="img-center"><img alt="" height="490" src="https://images2.imgbox.com/5e/74/OAIOu8Rp_o.png" width="976"></p> 
<h3 id="%C2%A02.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"> 2.栈的实现</h3> 
<p>        栈的实现一般可以用数组和链表实现，一般情况下用数组实现更为合适，因为在数组尾部进行插入和删除操作的代价较小。</p> 
<p class="img-center"><img alt="" height="260" src="https://images2.imgbox.com/02/d6/UUljF3dI_o.png" width="1094"></p> 
<h4 id="%C2%A0a.%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"> a.栈结构的定义</h4> 
<blockquote> 
 <pre><code class="language-cpp">typedef int STDataType;

//定义栈结构（数组）
typedef struct Stack
{
	STDataType* a;  //数组栈
	int top;		//栈顶
	int capacity;   //容量
}Stack;
</code></pre> 
</blockquote> 
<h4 id="b.%E5%88%9D%E5%A7%8B%E5%8C%96">b.初始化</h4> 
<blockquote> 
 <pre><code class="language-cpp">void STInit(Stack* pst)
{
	assert(pst);
	pst-&gt;a = NULL;
	pst-&gt;capacity = 0;
	pst-&gt;top = -1;
}</code></pre> 
</blockquote> 
<h4 id="c.%E6%89%A9%E5%AE%B9">c.扩容</h4> 
<blockquote> 
 <pre><code class="language-cpp">void STExpan(Stack* pst)
{
	if (pst-&gt;top + 1 == pst-&gt;capacity)
	{
		int newcapacity = pst-&gt;capacity == 0 ? 4 : pst-&gt;capacity * 2;
		STDataType* tmp = (STDataType*)realloc(pst-&gt;a, newcapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc fail!");
			return;
		}
		pst-&gt;a = tmp;
		pst-&gt;capacity = newcapacity;
	}
}</code></pre> 
 <p>        在对栈中的数组进行扩容时，需要注意其他参数如容量（capacity）的变化，在一开始我们将capacity初始化为0，所以在这里要对capacity进行判空。</p> 
</blockquote> 
<h4 id="d.%E5%85%A5%E6%A0%88">d.入栈</h4> 
<blockquote> 
 <pre><code class="language-cpp">void STPush(Stack* pst, STDataType x)
{
	assert(pst);
	STExpan(pst);
	pst-&gt;top++;
	pst-&gt;a[pst-&gt;top] = x;
}</code></pre> 
</blockquote> 
<h4 id="e.%E5%87%BA%E6%A0%88">e.出栈</h4> 
<blockquote> 
 <pre><code class="language-cpp">void STPop(Stack* pst)
{
	assert(pst &amp;&amp; pst-&gt;top &gt; -1);
	pst-&gt;top--;
}</code></pre> 
</blockquote> 
<h4 id="f.%E6%89%93%E5%8D%B0">f.打印</h4> 
<blockquote> 
 <p></p> 
 <pre><code class="language-cpp">void STPrint(Stack* pst)
{
	while (!STEmpty(pst))
	{
		printf("%d ", STTop(pst));
		STPop(pst);
	}
}</code></pre> 
</blockquote> 
<h4 id="g.%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0">g.取栈顶元素</h4> 
<blockquote> 
 <pre><code class="language-cpp">STDataType STTop(Stack* pst)
{
	assert(pst &amp;&amp; pst-&gt;top &gt; -1);
	return pst-&gt;a[pst-&gt;top];
}
</code></pre> 
</blockquote> 
<h4 id="%C2%A0h.%E5%88%A4%E7%A9%BA"> h.判空</h4> 
<blockquote> 
 <pre><code class="language-cpp">bool STEmpty(Stack* pst)
{
	assert(pst);
	return pst-&gt;top == -1;
}</code></pre> 
</blockquote> 
<h4 id="i.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">i.获取栈中的元素个数</h4> 
<blockquote> 
 <pre><code class="language-cpp">int STSize(Stack* pst)
{
	assert(pst);
	return pst-&gt;top + 1;
}</code></pre> 
</blockquote> 
<h4 id="j.%E9%94%80%E6%AF%81">j.销毁</h4> 
<blockquote> 
 <pre><code class="language-cpp">void STDestroy(Stack* pst)
{
	assert(pst);
	free(pst-&gt;a);
	pst-&gt;a = NULL;
	pst-&gt;capacity = 0;
	pst-&gt;top = 0;
}</code></pre> 
</blockquote> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97%C2%A0">二、队列 </h2> 
<h3 id="1.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89">1.队列的定义</h3> 
<p>        队列是只允许在一端进行插入，另一端进行删除数据操作的线性表。队列中的数据元素遵循<strong>先进先出FIFO（First in First out）</strong>的原则。进行插入操作的一端称为<strong>队尾</strong>，进行删除操作的一端成为<strong>队头</strong>。</p> 
<p class="img-center"><img alt="" height="248" src="https://images2.imgbox.com/64/90/9xio3BkG_o.png" width="959"></p> 
<h3 id="2.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">2.队列的实现</h3> 
<p>         队列可以用数组和链表实现，使用链表的结构更优，因为如果使用数组，在执行出队列的操作时效率会比较低。</p> 
<p class="img-center"><img alt="" height="601" src="https://images2.imgbox.com/75/61/dR87X6bz_o.png" width="933"></p> 
<h4 id="a.%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89">a.队列结构的定义</h4> 
<blockquote> 
 <pre><code class="language-cpp">typedef int QDataType;

//定义队列节点
typedef struct QueueNode
{
	struct QueueNode* next;		//后继指针
	QDataType val;			//数值
}QNode;

//队列指针
typedef struct Queue
{
	QNode* head;			//队头指针
	QNode* tail;			//队尾指针
	int size;				//队列中的元素
}Queue;</code></pre> 
 <p>        为了简化实现函数时参数的传递，我们额外定义一个包含一个头节点和尾节点的结构体，其中头节点和尾节点应分别指向一个链表的头和尾。</p> 
</blockquote> 
<h4>b.初始化</h4> 
<blockquote> 
 <pre><code class="language-cpp">void QueueInit(Queue* pq)
{
	assert(pq);
	pq-&gt;head = NULL;
	pq-&gt;tail = NULL;
	pq-&gt;size = 0;
}</code></pre> 
</blockquote> 
<h4 id="c.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9">c.创建节点</h4> 
<blockquote> 
 <pre><code class="language-cpp">QNode* QueueBuyNode(QDataType x)
{
	QNode* newNode = (QNode*)malloc(sizeof(QNode));
	if (newNode == NULL)
	{
		perror("malloc fail!");
		exit(1);
	}
	newNode-&gt;next = NULL;
	newNode-&gt;val = x;
	return newNode;
}</code></pre> 
</blockquote> 
<h4 id="d.%E5%85%A5%E9%98%9F">d.入队</h4> 
<blockquote> 
 <pre><code class="language-cpp">void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* node = QueueBuyNode(x);
	if (pq-&gt;head == NULL)	// 判空
	{
		pq-&gt;head = pq-&gt;tail = node;
		pq-&gt;size++;
	}
	else
	{
		pq-&gt;tail-&gt;next = node;
		pq-&gt;tail = pq-&gt;tail-&gt;next;
		pq-&gt;size++;
	}
}</code></pre> 
</blockquote> 
<h4 id="e.%E5%87%BA%E9%98%9F">e.出队</h4> 
<blockquote> 
 <pre><code class="language-cpp">void QueuePop(Queue* pq)
{
	assert(pq &amp;&amp; pq-&gt;head);
	QNode* phead = pq-&gt;head;
	pq-&gt;head = pq-&gt;head-&gt;next;
	free(phead);
	phead = NULL;
	if (pq-&gt;head == NULL)				 //队列为空	
		pq-&gt;tail = NULL;
	pq-&gt;size--;
}</code></pre> 
</blockquote> 
<h4 id="f.%E9%98%9F%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">f.队中的元素个数</h4> 
<blockquote> 
 <pre><code class="language-cpp">int QueueSize(Queue* pq)
{
	assert(pq);
	return pq-&gt;size;
}</code></pre> 
</blockquote> 
<h4 id="g.%E9%98%9F%E5%88%97%E5%88%A4%E7%A9%BA">g.队列判空</h4> 
<blockquote> 
 <pre><code class="language-cpp">bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq-&gt;size == 0;
}</code></pre> 
</blockquote> 
<h4 id="h.%E9%98%9F%E5%88%97%E6%89%93%E5%8D%B0">h.队列打印</h4> 
<blockquote> 
 <pre><code class="language-bash">void QueuePrint(Queue* pq)
{
	assert(pq);
	if (pq-&gt;size == NULL)
	{
		printf("NULL\n");
		return;
	}
	QNode* pcur = pq-&gt;head;
	while (pcur)
	{
		printf("%d ", pcur-&gt;val);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}</code></pre> 
</blockquote> 
<h4 id="i.%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0">i.取队头元素</h4> 
<blockquote> 
 <pre><code class="language-cpp">QDataType QueueFront(Queue* pq)
{
	assert(pq &amp;&amp; pq-&gt;head);
	return pq-&gt;head-&gt;val;
}</code></pre> 
</blockquote> 
<h4 id="%C2%A0j.%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0"> j.取队尾元素</h4> 
<blockquote> 
 <pre><code class="language-cpp">QDataType QueueBack(Queue* pq)
{
	assert(pq &amp;&amp; pq-&gt;tail);
	return pq-&gt;tail-&gt;val;
}</code></pre> 
</blockquote> 
<h4 id="%C2%A0k.%E9%94%80%E6%AF%81"> k.销毁</h4> 
<blockquote> 
 <pre><code class="language-cpp">void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* pcur = pq-&gt;head;
	while (pcur)
	{
		QNode* pnext = pcur-&gt;next;
		free(pcur);
		pcur = pcur-&gt;next;
	}
	pq-&gt;head = pq-&gt;tail = NULL;
	pq-&gt;size = 0;
}</code></pre> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ef59e762607509b545ad89294054f395/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sql server修改数据库文件位置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/616ebd4b8377fd9c78ebfced159ba165/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 处理图片的10个库（非常详细）零基础入门到精通，收藏这一篇就够了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>