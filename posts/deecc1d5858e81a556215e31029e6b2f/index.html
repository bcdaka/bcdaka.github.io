<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端 JS 压缩图片的思路（附源码） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/deecc1d5858e81a556215e31029e6b2f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端 JS 压缩图片的思路（附源码）">
  <meta property="og:description" content="前言 相信大家都做过图片上传相关的功能，在图片上传的过程中，不知道大家有没有考虑过文件体积的问题，如果我们直接将原图片上传，可以图片体积比较大，一是上传速度较慢，二是前端进行渲染时速度也比较慢，比较影响客户的体验感。所以在不影响清晰度的情况下，前端可以在上传前对图片的大小体积进行压缩，压缩到一个比较合适的大小进行上传，本文就带大家一起来看看前端 JS 如何实现图片压缩，有需要的小伙伴抓紧收藏一下吧！
原理（必看） 省流：主要使用 canvas的 drawImage 方法先绘制为 canvas 图像，再结合 toDataURL 转化为DataURl 进行存储图片链接。
drawImage简单介绍 Canvas 2D API 中的 CanvasRenderingContext2D.drawImage() 方法提供了多种在画布Canvas）上绘制图像的方式。
用法如下：
CanvasRenderingContext2D.drawImage() - Web API 接口参考 | MDN (mozilla.org)
语法如下：
drawImage(image, dx, dy); drawImage(image, dx, dy, dWidth, dHeight); drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); 我们使用第二种进行绘制，参数含义如下：
image：绘制到上下文的元素。
dx：image 的左上角在目标画布上 X 轴坐标。
dy：image 的左上角在目标画布上 Y 轴坐标。
dWidth：image 在目标画布上绘制的宽度。允许对绘制的 image 进行缩放。如果不说明，在绘制时 image 宽度不会缩放。
dHeight：image 在目标画布上绘制的高度。允许对绘制的 image 进行缩放。如果不说明，在绘制时 image 高度不会缩放。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-03T11:18:07+08:00">
    <meta property="article:modified_time" content="2024-04-03T11:18:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端 JS 压缩图片的思路（附源码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>相信大家都做过图片上传相关的功能，在图片上传的过程中，不知道大家有没有考虑过文件体积的问题，如果我们直接将原图片上传，可以图片体积比较大，一是上传速度较慢，二是前端进行渲染时速度也比较慢，比较影响客户的体验感。所以在不影响清晰度的情况下，前端可以在上传前对图片的大小体积进行压缩，压缩到一个比较合适的大小进行上传，本文就带大家一起来看看前端 JS 如何实现图片压缩，有需要的小伙伴抓紧收藏一下吧！</p> 
<h2>原理（必看）</h2> 
<p><strong>省流：主要使用 </strong>c<strong>anvas的 drawImage 方法先绘制为 canvas 图像，再结合 toDataURL 转化为DataURl 进行存储图片链接。</strong></p> 
<h3><strong><code>drawImage简单介绍</code></strong></h3> 
<blockquote> 
 <p>Canvas 2D API 中的 <strong><code>CanvasRenderingContext2D.drawImage()</code></strong> 方法提供了多种在画布Canvas）上绘制图像的方式。</p> 
</blockquote> 
<p><strong>用法如下：</strong></p> 
<blockquote> 
 <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage" rel="nofollow" title="CanvasRenderingContext2D.drawImage() - Web API 接口参考 | MDN (mozilla.org)">CanvasRenderingContext2D.drawImage() - Web API 接口参考 | MDN (mozilla.org)</a></p> 
</blockquote> 
<p><strong>语法如下：</strong></p> 
<pre><code class="language-javascript">drawImage(image, dx, dy);
drawImage(image, dx, dy, dWidth, dHeight);
drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
</code></pre> 
<p> 我们使用第二种进行绘制，参数含义如下：</p> 
<p><strong>image</strong>：绘制到上下文的元素。</p> 
<p><strong>dx</strong>：<code>image</code> 的左上角在目标画布上 X 轴坐标。</p> 
<p><strong>dy：</strong><code>image</code> 的左上角在目标画布上 Y 轴坐标。</p> 
<p><strong>dWidth：</strong><code>image</code> 在目标画布上绘制的宽度。允许对绘制的 <code>image</code> 进行缩放。如果不说明，在绘制时 <code>image</code> 宽度不会缩放。</p> 
<p><strong>dHeight：</strong><code>image</code> 在目标画布上绘制的高度。允许对绘制的 <code>image</code> 进行缩放。如果不说明，在绘制时 <code>image</code> 高度不会缩放。</p> 
<h4>简单示例</h4> 
<p><strong>注意：</strong>如果随意的修改图像的尺寸，会导致图像失真，我们可以先获取到图像资源的原始尺寸，然后进行等比缩放，意思就是当我们确定设置宽度之后，高度要进行等比调整。公式就是交叉相乘积相等。</p> 
<blockquote> 
 <p>        // 如果宽度设置为 500， 那么高度也应该进行等比缩放<br>         // naturalWidth         =&gt;  500<br>         // naturalHeight        =&gt;  X<br>         // naturalWidth * X     =   naturalHeight * 500</p> 
 <p>       //  计算得出高度<br>         X =   naturalHeight * 500 / naturalWidth</p> 
</blockquote> 
<pre><code class="language-javascript">  var can = document.querySelector('canvas')
  var context = can.getContext('2d')   
  var imgDom = new Image();
    imgDom.src = './img.jpg';
    imgDom.onload = function () {
        // 注意：图像绘制时，必须保证资源已经加载完成
        console.log('图片的原始宽度', imgDom.naturalWidth);
        console.log('图片的原始高度', imgDom.naturalHeight);

        context.drawImage(
            imgDom,
            0, 0,
            500, imgDom.naturalHeight * 500 / imgDom.naturalWidth
        );
    }</code></pre> 
<h3>toDataURL简单介绍</h3> 
<p>我们将图片绘制到 canvas 之后，还需要将 canvas 转化为 Data URl，转化为 DataURl 之后可以显示到我们的屏幕上面，也可以存放到后端服务器，使用 canvas 所提供的 toDataURL 实例方法即可。</p> 
<p><strong>​ 官方解释：HTMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI ​</strong></p> 
<blockquote> 
 <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL" rel="nofollow" title="HTMLCanvasElement.toDataURL() - Web API 接口参考 | MDN (mozilla.org)">HTMLCanvasElement.toDataURL() - Web API 接口参考 | MDN (mozilla.org)</a></p> 
</blockquote> 
<p><strong>语法：canvas.toDataURL(type, encoderOptions);</strong></p> 
<p><strong>type（可选）</strong>：图片格式，默认为 <code>image/png</code></p> 
<p><strong>encoderOptions（可选）</strong>：在指定图片格式为 <code>image/jpeg</code> 或 <code>image/webp</code> 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 <code>0.92</code>。其他参数会被忽略。</p> 
<h4>简单示例 </h4> 
<pre><code class="language-javascript">
       // 获取压缩后的图片数据
      can.width = imgDom.naturalWidth
      can.height = imgDom.naturalHeight

      const compressedData = can.toDataURL('image/jpeg', 0.6) // 可调整质量参数
      console.log('compressedData: ', compressedData)</code></pre> 
<p>转化后 DataURL 结果如下 </p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/97/c3/dVEX1cd0_o.png" width="1200"></p> 
<h2>实现</h2> 
<p>先奉上全部代码，方便大家看，下面进行解释！</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;图片压缩上传&lt;/title&gt;
    &lt;meta charset="UTF-8"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type="file" id="fileInput" accept="image/*"&gt;
    &lt;button onclick="compressAndUpload()"&gt;压缩并上传图片&lt;/button&gt;
    &lt;canvas id="canvas" style="display: none;"&gt;&lt;/canvas&gt;
    &lt;script&gt;
        function compressAndUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                alert('请先选择要上传的图片');
                return;
            }
            const reader = new FileReader();
            reader.onload = function () {
                const img = new Image();
                img.src = reader.result;
                img.onload = function () {
                    const canvas = document.getElementById('canvas');
                    const ctx = canvas.getContext('2d');
                    const maxWidth = 800; // 设置最大宽度为800像素
                    let width = img.width;
                    let height = img.height;

                    // 判断是否需要缩放
                    if (width &gt; maxWidth) {
                        height *= maxWidth / width;
                        width = maxWidth;
                    }
                    // 设置 canvas 的宽高
                    canvas.width = width;
                    canvas.height = height;

                    // 将图片绘制到 canvas 上
                    ctx.drawImage(img, 0, 0, width, height);
                    // 获取压缩后的图片数据
                    const compressedData = canvas.toDataURL('image/jpeg', 0.7); // 可调整质量参数

                    // 创建一个新的压缩后的 File 对象
                    const compressedFile = dataURItoBlob(compressedData, file.type);
                    compressedFile.lastModifiedDate = file.lastModifiedDate;
                    compressedFile.name = file.name;

                    // 上传压缩后的图片文件
                    uploadImage(compressedFile);
                };
            };
            reader.readAsDataURL(file);
        }

        function dataURItoBlob(dataURI, mimeType) {
            const binary = atob(dataURI.split(',')[1]);
            const array = [];
            for (let i = 0; i &lt; binary.length; i++) {
                array.push(binary.charCodeAt(i));
            }
            return new Blob([new Uint8Array(array)], { type: mimeType });
        }

        function uploadImage(compressedFile) {
            const formData = new FormData();
            formData.append('image', compressedFile);

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response =&gt; {
                if (response.ok) {
                    console.log('图片上传成功');
                } else {
                    console.error('图片上传失败');
                }
            })
            .catch(error =&gt; {
                console.error('发生错误:', error);
            });
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>我们看一下压缩前后体积对比，压缩前550290，压缩后31523，缩小了十几倍，这个压缩还是很明显的。</p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/82/11/YNNJcgJy_o.png" width="1020"></p> 
<p> 首先我们看这三行代码</p> 
<p><img alt="" height="120" src="https://images2.imgbox.com/cd/86/PzSXxfPi_o.png" width="735"></p> 
<p>我们先初始化一个 <code>reader</code> 是一个 <code>FileReader</code> 对象的实例 </p> 
<p><code>reader.readAsDataURL(file)，</code>这行代码的作用是将选择的文件读取为 Data URI 格式的字符串。</p> 
<p>当执行 <code>reader.readAsDataURL(file)</code> 时，会发生以下几件事情:</p> 
<blockquote> 
 <ol><li><code>FileReader</code> 对象开始异步读取 <code>file</code> 中的数据。</li><li>一旦读取完成,<code>FileReader</code> 的 <code>onload</code> 事件将被触发。</li><li>读取的结果将存储在 <code>FileReader</code> 对象的 <code>result</code> 属性中,格式为 Data URI 字符串。</li></ol> 
</blockquote> 
<p>看一下 <code>FileReader</code> 对象的 <code>result</code>  的打印结果，为 Data URL格式</p> 
<p><img alt="" height="739" src="https://images2.imgbox.com/e3/2d/7wQBpR1E_o.png" width="1200"></p> 
<p>最终我们将读取出来的 Data URI 字符串赋值给 Image 的 src，也就是下面这行代码，然后等待 img 加载完毕开始对 img 进行压缩，具体怎么压缩上面已经简单演示过。</p> 
<pre><code class="language-javascript">          const img = new Image()
          img.src = reader.result
          img.onload = function () {}</code></pre> 
<p>接下来我们设置了一个最大宽度为800，然后判断当前图片宽度是否大于该值，如果大于进行缩放计算，小于就不进行等比缩放计算。最后将计算出的值使用 drawImage 绘制到 canvas 上面。</p> 
<pre><code class="language-javascript">                    const maxWidth = 800; // 设置最大宽度为800像素
                    let width = img.width;
                    let height = img.height;

                    // 判断是否需要缩放
                    if (width &gt; maxWidth) {
                        height *= maxWidth / width;
                        width = maxWidth;
                    }

                    // 设置 canvas 的宽高
                    canvas.width = width;
                    canvas.height = height;

                    // 将图片绘制到 canvas 上
                    ctx.drawImage(img, 0, 0, width, height);
</code></pre> 
<p>现在我们将 canvas 转化成Data URI 字符串，<code>canvas.toDataURL('image/jpeg', 0.7)，</code>这行代码的作用是将 canvas 上绘制的图像数据导出为 JPEG 格式的 Data URI 字符串，并设置图像质量为 0.7。</p> 
<pre><code class="language-javascript">// 获取压缩后的图片数据
const compressedData = canvas.toDataURL('image/jpeg', 0.7); // 可调整</code></pre> 
<p>我们看一下 compressedData，是一个Data URI 字符串，其实到这里就可以了，我们可以将 Data URI 传到后端进行存储起来，也可以转化为文件格式进行存储，我这里选择使用文件格式进行存储，不需要的可以不使用下面的方式。</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/8b/91/dcrOMHt4_o.png" width="1200"></p> 
<p>接下来就是创建一个新的压缩后的 File 对象</p> 
<pre><code class="language-javascript">
      const compressedFile = dataURItoBlob(compressedData, file.type)
      compressedFile.lastModifiedDate = file.lastModifiedDate
      compressedFile.name = file.name

      function dataURItoBlob(dataURI, mimeType) {
        const binary = atob(dataURI.split(',')[1])
        const array = []
        for (let i = 0; i &lt; binary.length; i++) {
          array.push(binary.charCodeAt(i))
        }
        return new Blob([new Uint8Array(array)], { type: mimeType })
      }</code></pre> 
<p>新的文件对象</p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/d5/52/PvW2rU8q_o.png" width="1200"></p> 
<p>最后直接使用 FormData 进行上传即可，这一块就不说了。</p> 
<h2>总结</h2> 
<p>前端实现图片压缩主要是利用的 canvas 来实现，实现思路为使用 canvas 的 drawImage 方法先绘制为 canvas 图像，再结合 toDataURL 转化为 DataURl 进行存储图片链接以及压缩图像质量。在toDataURL 中可以调整图像质量，需要注意的是我们在压缩图像时要注意等宽高缩放，否则会导致图像出现失真的情况。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b6c782533013dac81f96c6568f82b7ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows 系统下 mysql 数据库的下载与安装（包括升级安装）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/975203b425bd5589d6d2ad0d3f4b05e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Linux】nmcli命令详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>