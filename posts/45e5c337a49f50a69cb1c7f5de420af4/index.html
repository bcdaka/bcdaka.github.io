<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单链表＜数据结构 C版＞ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/45e5c337a49f50a69cb1c7f5de420af4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="单链表＜数据结构 C版＞">
  <meta property="og:description" content="目录
概念
链表的单个结点
链表的打印操作
新结点的申请
尾部插入
头部插入
尾部删除
头部删除
查找
在指定位置之前插入数据
在任意位置之后插入数据
测试运行一下：
删除pos结点
删除pos之后结点
销毁链表
概念 单链表是一种在物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接顺序实现的。
链表的每个结点有两个部分，分别是数据和指向下个结点的指针，每个链表的最后一个结点的下一个结点为NULL（不能对NULL解引用）。
放一张bit课件里的图,我觉得很形象：
链表的单个结点 typedef int SLDataType;//重定义一下在链表内存放的数据类型，方便后期对类型进行统一修改 //链表的单个结点 typedef struct SListNode {//Single List Node :链表结点 SLDataType data;//存放的数据 struct SListNode* next;//指向下一个结点的指针 }SLNode;//重定义名字方便后期使用 链表的打印操作 //链表的打印操作 void SLPrint(SLNode* phead) { assert(phead);//不能传入空指针 SLNode* pcur = phead; //pointer cursor:指针光标，不让头结点丢失(虽然不会改变头结点的指向) while (pcur) {//等同于pcur!=NULL printf(&#34;%d-&gt;&#34;, pcur-&gt;data);//打印此结点的数据 pcur = pcur-&gt;next;//使pcur指向下一个结点 } printf(&#34;NULL\n&#34;); } 新结点的申请 后面会涉及到新结点的插入，申请新结点可以封装成一个函数，避免代码冗余
//新结点的申请 SLNode* SLBuyNode(SLDataType x) { SLNode* node = (SLNode*)malloc(sizeof(SLNode)); if (!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-19T15:54:22+08:00">
    <meta property="article:modified_time" content="2024-07-19T15:54:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单链表＜数据结构 C版＞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5" rel="nofollow">概念</a></p> 
<p id="%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8D%95%E4%B8%AA%E7%BB%93%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8D%95%E4%B8%AA%E7%BB%93%E7%82%B9" rel="nofollow"> 链表的单个结点</a></p> 
<p id="%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0%E6%93%8D%E4%BD%9C" rel="nofollow"> 链表的打印操作</a></p> 
<p id="%E6%96%B0%E7%BB%93%E7%82%B9%E7%9A%84%E7%94%B3%E8%AF%B7-toc" style="margin-left:80px;"><a href="#%E6%96%B0%E7%BB%93%E7%82%B9%E7%9A%84%E7%94%B3%E8%AF%B7" rel="nofollow">新结点的申请</a></p> 
<p id="%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5" rel="nofollow">尾部插入</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5" rel="nofollow">头部插入</a></p> 
<p id="%E5%B0%BE%E9%83%A8%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%E5%B0%BE%E9%83%A8%E5%88%A0%E9%99%A4" rel="nofollow">尾部删除</a></p> 
<p id="%E5%A4%B4%E9%83%A8%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%E5%A4%B4%E9%83%A8%E5%88%A0%E9%99%A4" rel="nofollow">头部删除</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#%E6%9F%A5%E6%89%BE" rel="nofollow">查找</a></p> 
<p id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">在指定位置之前插入数据</a></p> 
<p id="%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">在任意位置之后插入数据</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%8B%EF%BC%9A" rel="nofollow">测试运行一下：</a></p> 
<p id="%C2%A0%E5%88%A0%E9%99%A4pos%E7%BB%93%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%88%A0%E9%99%A4pos%E7%BB%93%E7%82%B9" rel="nofollow"> 删除pos结点</a></p> 
<p id="%C2%A0%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%BB%93%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%BB%93%E7%82%B9" rel="nofollow"> 删除pos之后结点</a></p> 
<p id="%C2%A0%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%C2%A0%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8" rel="nofollow"> 销毁链表</a></p> 
<hr id="hr-toc"> 
<h4 id="%E6%A6%82%E5%BF%B5">概念</h4> 
<p>单链表是一种在物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的<strong>指针链接顺序</strong>实现的。</p> 
<blockquote> 
 <p>链表的每个结点有两个部分，分别是数据和指向下个结点的指针，每个链表的最后一个结点的下一个结点为NULL（不能对NULL解引用）。</p> 
</blockquote> 
<p>放一张bit课件里的图,我觉得很形象：</p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/7c/fe/YXkeoNUz_o.png" width="1200"></p> 
<hr> 
<h4 id="%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8D%95%E4%B8%AA%E7%BB%93%E7%82%B9"> 链表的单个结点</h4> 
<pre><code class="language-cpp">typedef int SLDataType;//重定义一下在链表内存放的数据类型，方便后期对类型进行统一修改

//链表的单个结点
typedef struct SListNode {//Single List Node :链表结点
	SLDataType data;//存放的数据
	struct SListNode* next;//指向下一个结点的指针
}SLNode;//重定义名字方便后期使用</code></pre> 
<hr> 
<h4 id="%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0%E6%93%8D%E4%BD%9C"> 链表的打印操作</h4> 
<pre><code class="language-cpp">//链表的打印操作
void SLPrint(SLNode* phead) {
	assert(phead);//不能传入空指针
	SLNode* pcur = phead;
	//pointer cursor:指针光标，不让头结点丢失(虽然不会改变头结点的指向)
	while (pcur) {//等同于pcur!=NULL
		printf("%d-&gt;", pcur-&gt;data);//打印此结点的数据
		pcur = pcur-&gt;next;//使pcur指向下一个结点
	}
	printf("NULL\n");
}</code></pre> 
<hr> 
<h4 id="%E6%96%B0%E7%BB%93%E7%82%B9%E7%9A%84%E7%94%B3%E8%AF%B7">新结点的申请</h4> 
<p>后面会涉及到新结点的插入，申请新结点可以封装成一个函数，避免代码冗余</p> 
<pre><code class="language-cpp">//新结点的申请
SLNode* SLBuyNode(SLDataType x) {
	SLNode* node = (SLNode*)malloc(sizeof(SLNode));
	if (!node) {//返回值为空,申请失败(一般是空间不足了)，直接退出
		perror("malloc fail");
		exit(1);
	}
	node-&gt;data = x;//将数据赋给data
	node-&gt;next = NULL;//将下一个节点置为NULL;
	return node;
}</code></pre> 
<hr> 
<h4 id="%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5">尾部插入</h4> 
<pre><code class="language-cpp">//尾部插入
void SLPushBack(SLNode** pphead, SLDataType x) {
	//注意在这里我们传参的是二级指针，因为我们需要在函数内部改变头结点的指向
	assert(pphead);//不能传NULL
	//新结点的申请
	SLNode* node=SLBuyNode(x);
	if (*pphead == NULL) {
		*pphead = node;
	}
	else {
		SLNode* pcur = *pphead;
		while (pcur-&gt;next) {//找到next元素为NULL的结点，也就是为链表尾部
			pcur = pcur-&gt;next;
		}
		pcur-&gt;next = node;
	}
	
}</code></pre> 
<p><strong>测试运行一下：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/c8/dd/VD0KMRHm_o.png"></strong></p> 
<h4></h4> 
<hr> 
<h4 id="%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5">头部插入</h4> 
<pre><code class="language-cpp">//头部插入
void SLPushFront(SLNode** pphead, SLDataType x) {
	assert(pphead);
	SLNode* node = SLBuyNode(x);
	//这里需要处理头结点为空的情况吗？不需要，因为没有涉及到解引用其元素
	node-&gt;next = *pphead;
	*pphead = node;
}
</code></pre> 
<p><strong>测试运行一下：</strong><br><img alt="" src="https://images2.imgbox.com/9e/ee/jyyqbzN3_o.png"></p> 
<p></p> 
<hr> 
<h4 id="%E5%B0%BE%E9%83%A8%E5%88%A0%E9%99%A4">尾部删除</h4> 
<pre><code class="language-cpp">//尾部删除
void SLPopBack(SLNode** pphead) {
	assert(*pphead &amp;&amp; pphead);//
	if (!(*pphead)-&gt;next) {//处理只有一个元素的情况
		free(*pphead);
		*pphead = NULL;
	}
	else {
		SLNode* prev = NULL;
		SLNode* pcur = *pphead;
		while (pcur-&gt;next) {//找到尾结点前一个结点
			prev = pcur;
			pcur = pcur-&gt;next;
		}
		free(pcur);//将尾结点释放
		pcur = NULL;
		prev-&gt;next = NULL;//将尾结点的前一个结点的next元素置为NULL
	}
}</code></pre> 
<p><strong>测试运行一下：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/6b/89/maEaPZFQ_o.png"></strong></p> 
<p></p> 
<hr> 
<h4 id="%E5%A4%B4%E9%83%A8%E5%88%A0%E9%99%A4">头部删除</h4> 
<pre><code class="language-cpp">//头部删除
void SLPopFront(SLNode** pphead) {
	assert(*pphead &amp;&amp; pphead);
	SLNode* next = (*pphead)-&gt;next;//保存头结点的下一个结点地址
	free(*pphead);//释放头结点
	*pphead = next;//使头结点指向下一个结点
}</code></pre> 
<p><strong>测试运行一下：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/2e/69/JxnIB4vT_o.png"></strong></p> 
<p></p> 
<h4></h4> 
<hr> 
<h4 id="%E6%9F%A5%E6%89%BE">查找</h4> 
<p>在链表中想要对指定位置进行操作不能使用下标，所以我们必须找到指定位置的地址才能对其进行操作。</p> 
<pre><code class="language-cpp">//查找
SLNode* SLFind(SLNode* phead, SLDataType x) {
	assert(phead);
	SLNode* pcur = phead;
	while (pcur) {
		if (pcur-&gt;data == x) {
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;
}</code></pre> 
<hr> 
<h4 id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">在指定位置之前插入数据</h4> 
<pre><code class="language-cpp">//在指定位置之前插入数据
void SLInsert(SLNode** pphead, SLNode* pos, SLDataType x) {
	assert(pphead &amp;&amp; pos &amp;&amp; *pphead);//pos和pphead不能为空,以及pphead指向空间不能为空
	if (*pphead == pos) {//处理头插的情况
		SLPushFront(pphead,x);
	}
	else {
		SLNode* node = SLBuyNode(x);
		SLNode* pcur = *pphead;
		while (pcur-&gt;next != pos) {//找到pos前一个结点
			pcur = pcur-&gt;next;
		}
		node-&gt;next = pcur-&gt;next;
		pcur-&gt;next = node;
	}
}</code></pre> 
<p><strong>测试运行一下：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/6d/c4/VhshS9FJ_o.png"></strong></p> 
<hr> 
<h4 id="%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">在任意位置之后插入数据</h4> 
<pre><code class="language-cpp">//在任意位置之后插入数据
void SLInsertAfter(SLNode* pos, SLDataType x) {
	assert(pos);//pos不能为空
	SLNode* node = SLBuyNode(x);
	node-&gt;next = pos-&gt;next;
	pos-&gt;next = node;
}</code></pre> 
<h4 id="%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%8B%EF%BC%9A"><strong>测试运行一下：</strong></h4> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/4a/4e/mvuYQxYf_o.png"></strong></p> 
<hr> 
<h4 id="%C2%A0%E5%88%A0%E9%99%A4pos%E7%BB%93%E7%82%B9"> 删除pos结点</h4> 
<pre><code class="language-cpp">//删除pos结点
void SLErase(SLNode** pphead, SLNode* pos) {
	assert(*pphead &amp;&amp; pphead &amp;&amp; pos);
	if (*pphead == pos) {//处理头删的情况
		SLPopFront(pphead);
	}
	else {
		SLNode* pcur = *pphead;
		while (pcur-&gt;next!= pos) {
			pcur = pcur-&gt;next;
		}
		pcur-&gt;next = pos-&gt;next;
		free(pos);
		pos = NULL;
	}
}</code></pre> 
<p> <strong>测试运行一下：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/0b/34/2ctYV9Rl_o.png"></strong></p> 
<hr> 
<h4 id="%C2%A0%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%BB%93%E7%82%B9"> 删除pos之后结点</h4> 
<pre><code class="language-cpp">//删除pos之后结点
void SLEraseAfter(SLNode* pos) {
	assert(pos &amp;&amp; pos-&gt;next);//pos后面的结点也不能为空
	SLNode* next = pos-&gt;next;
	pos-&gt;next = next-&gt;next;
	free(next);
	next = NULL;
}</code></pre> 
<p> <strong>测试运行一下：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/16/eb/t4DJHG3W_o.png"></strong></p> 
<p> </p> 
<hr> 
<h4 id="%C2%A0%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8"><strong> 销毁链表</strong></h4> 
<pre><code class="language-cpp">//销毁链表
void SLDestory(SLNode** pphead) {
	assert(pphead &amp;&amp; *pphead);
	SLNode* pcur = *pphead;
	while (pcur) {
		SLNode* nextnode = pcur-&gt;next;//使用一个变量接受下一个结点地址
		free(pcur);
		pcur = nextnode;
	}
	*pphead = NULL;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c89a6ee96259c48cca8e3a356d26f599/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">重生之“我打数据结构，真的假的？”--2.单链表（完结）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b82ac137420a274b8425dfb72737ad4a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">顺序表＜数据结构 C版＞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>