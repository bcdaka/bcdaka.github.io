<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】Java序列化和反序列化 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/96123719ac32b5a1536b49fcebf3f609/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java】Java序列化和反序列化">
  <meta property="og:description" content="人不走空 🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 # Java中的序列化和反序列化 在Java中，序列化是将对象的状态写入字节流的机制。它主要用于Hibernate、RMI、JPA、EJB和JMS技术中。
反序列化是序列化的逆操作，即将字节流转换为对象。序列化和反序列化过程是平台无关的，这意味着您可以在一个平台上对对象进行序列化，在另一个平台上进行反序列化。
为了序列化对象，我们调用ObjectOutputStream类的writeObject()方法，而为了反序列化，则调用ObjectInputStream类的readObject()方法。
我们必须实现Serializable接口才能序列化对象。
# Java序列化的优点 它主要用于在网络上传输对象的状态（即称为marshalling）。
java.io.Serializable接口 Serializable是一个标记接口（没有数据成员和方法）。它用于“标记”Java类，以便这些类的对象可以获得某种能力。Cloneable和Remote也是标记接口。
Serializable接口必须由需要持久化其对象的类实现。
String类和所有包装类默认实现了java.io.Serializable接口。
让我们看下面给出的例子：
Student.java
import java.io.Serializable; public class Student implements Serializable{ int id; String name; public Student(int id, String name) { this.id = id; this.name = name; } } 在上面的示例中，Student类实现Serializable接口。现在它的对象可以转换为流。主类的实现显示在下一个代码中。
专属福利 👉点击领取：Java资料合集！650G！
ObjectOutputStream类 ObjectOutputStream类用于将基本数据类型和Java对象写入OutputStream。只有支持java.io.Serializable接口的对象才能写入流中。
构造函数
重要方法
MethodDescription 1) public final void writeObject(Object obj) throws IOException {}
它将指定的对象写入 ObjectOutputStream。
2) public void flush() throws IOException {}">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-26T21:41:07+08:00">
    <meta property="article:modified_time" content="2024-06-26T21:41:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】Java序列化和反序列化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/fa/40/NGlVWvge_o.png"> 
  <figcaption> 
   <strong>人不走空</strong> 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p>                                                                      </p> 
<h3 style="text-align:center;">      🌈<strong>个人主页：<strong><a href="https://blog.csdn.net/double222222?type=blog" title="人不走空">人不走空</a></strong></strong><strong>      </strong></h3> 
<h3 style="text-align:center;"><strong>💖系列专栏：<strong><a href="https://blog.csdn.net/double222222/category_12487653.html?spm=1001.2014.3001.5482" title="算法专题">算法专题</a></strong></strong></h3> 
<h3 style="text-align:center;"><strong>⏰诗词歌赋：</strong>斯是陋室，惟吾德馨</h3> 
<p></p> 
<p><img alt="" height="92" src="https://images2.imgbox.com/5f/75/0gKctkJZ_o.gif" width="733"></p> 
<h3><strong># Java中的序列化和反序列化</strong></h3> 
<p></p> 
<p>在Java中，序列化是将对象的状态写入字节流的机制。它主要用于Hibernate、RMI、JPA、EJB和JMS技术中。</p> 
<p></p> 
<p>反序列化是序列化的逆操作，即将字节流转换为对象。序列化和反序列化过程是平台无关的，这意味着您可以在一个平台上对对象进行序列化，在另一个平台上进行反序列化。</p> 
<p></p> 
<p>为了序列化对象，我们调用ObjectOutputStream类的writeObject()方法，而为了反序列化，则调用ObjectInputStream类的readObject()方法。</p> 
<p></p> 
<p>我们必须实现Serializable接口才能序列化对象。</p> 
<p></p> 
<h3><strong># Java序列化的优点</strong></h3> 
<p></p> 
<p>它主要用于在网络上传输对象的状态（即称为marshalling）。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="图片" height="220" src="https://images2.imgbox.com/02/07/3MvcjrzT_o.png" width="246"></p> 
<h3>java.io.Serializable接口</h3> 
<p></p> 
<p>Serializable是一个标记接口（没有数据成员和方法）。它用于“标记”Java类，以便这些类的对象可以获得某种能力。Cloneable和Remote也是标记接口。</p> 
<p></p> 
<p>Serializable接口必须由需要持久化其对象的类实现。</p> 
<p></p> 
<p>String类和所有包装类默认实现了java.io.Serializable接口。</p> 
<p></p> 
<p>让我们看下面给出的例子：</p> 
<p></p> 
<p>Student.java</p> 
<ul><li></ul> 
<pre><code>import java.io.Serializable;  </code><code>public class Student implements Serializable{  </code><code> int id;  </code><code> String name;  </code><code> public Student(int id, String name) {  </code><code>  this.id = id;  </code><code>  this.name = name;  </code><code> }  </code><code>}  </code></pre> 
<p></p> 
<p>在上面的示例中，Student类实现Serializable接口。现在它的对象可以转换为流。主类的实现显示在下一个代码中。</p> 
<p></p> 
<pre></pre> 
<h3><a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247594137&amp;idx=1&amp;sn=0d08b48386b8fec8afaebc16771fb68b&amp;chksm=e8fcec90df8b6586d1ca11b28ab626a0a3821f88613d86b5a74d2c02d7866e731d3ecd4e889f&amp;scene=21#wechat_redirect" rel="nofollow" title="专属福利">专属福利</a></h3> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247594137&amp;idx=1&amp;sn=0d08b48386b8fec8afaebc16771fb68b&amp;chksm=e8fcec90df8b6586d1ca11b28ab626a0a3821f88613d86b5a74d2c02d7866e731d3ecd4e889f&amp;scene=21#wechat_redirect" rel="nofollow" title="👉点击领取：Java资料合集！650G！">👉点击领取：Java资料合集！650G！</a></p> 
<p></p> 
<h3>ObjectOutputStream类</h3> 
<p></p> 
<p>ObjectOutputStream类用于将基本数据类型和Java对象写入OutputStream。只有支持java.io.Serializable接口的对象才能写入流中。</p> 
<p></p> 
<p>构造函数</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="图片" height="108" src="https://images2.imgbox.com/64/df/4k53a2zu_o.png" width="961"></p> 
<p>重要方法</p> 
<table><thead><tr><td>Method</td><td>Description</td></tr></thead><tbody><tr><td> <p>1) public final void writeObject(Object obj) throws IOException {}</p> </td><td> <p>它将指定的对象写入 ObjectOutputStream。</p> </td></tr><tr><td> <p>2) public void flush() throws IOException {}</p> </td><td> <p>它刷新当前输出流。</p> </td></tr><tr><td> <p>3) public void close() throws IOException {}</p> </td><td> <p>它关闭当前输出流。</p> </td></tr></tbody></table> 
<h3></h3> 
<h3>ObjectInputStream类</h3> 
<p></p> 
<p>ObjectInputStream反序列化使用ObjectOutputStream编写的对象和基本数据。</p> 
<p></p> 
<p>构造函数</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="图片" height="106" src="https://images2.imgbox.com/66/f1/qsnHShdA_o.png" width="954"></p> 
<p>重要方法</p> 
<table><thead><tr><td>Method</td><td>Description</td></tr></thead><tbody><tr><td> <p>1) public final Object readObject() throws IOException, ClassNotFoundException{}</p> </td><td> <p>它从输入流中读取一个对象。</p> </td></tr><tr><td> <p>2) public void close() throws IOException {}</p> </td><td> <p>它关闭 ObjectInputStream。.</p> </td></tr></tbody></table> 
<h3></h3> 
<h3><strong># Java序列化的例子</strong></h3> 
<p></p> 
<p>在此示例中，我们将从上面代码的Student类序列化对象。 </p> 
<p></p> 
<p>ObjectOutputStream类的writeObject()方法提供了序列化对象的功能。我们正在将对象的状态保存在名为f.txt的文件中。</p> 
<p></p> 
<p>Persist.java</p> 
<pre></pre> 
<ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul> 
<pre><code>import java.io.*;    </code><code>class Persist{    </code><code> public static void main(String args[]){    </code><code>  try{    </code><code>  //Creating the object    </code><code>  Student s1 =new Student(211,"ravi");    </code><code>  //Creating stream and writing the object    </code><code>  FileOutputStream fout=new FileOutputStream("f.txt");    </code><code>  ObjectOutputStream out=new ObjectOutputStream(fout);    </code><code>  out.writeObject(s1);    </code><code>  out.flush();    </code><code>  //closing the stream    </code><code>  out.close();    </code><code>  System.out.println("success");    </code><code>  }catch(Exception e){System.out.println(e);}    </code><code> }    </code><code>}    </code></pre> 
<p>输出：</p> 
<pre></pre> 
<ul><li></ul> 
<pre><code>success</code></pre> 
<h3></h3> 
<h3><strong># Java反序列化的例子</strong></h3> 
<p></p> 
<p>反序列化是从序列化状态重构对象的过程。它是序列化的逆操作。让我们看一个示例，其中我们从反序列化对象中读取数据。</p> 
<p></p> 
<p>Deserialization是从序列化状态重构对象的过程。它是序列化的逆操作。让我们看一个示例，其中我们从反序列化对象中读取数据。</p> 
<p></p> 
<p>Depersist.java</p> 
<pre></pre> 
<ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul> 
<pre><code>import java.io.*;  </code><code>class Depersist{  </code><code> public static void main(String args[]){  </code><code>  try{  </code><code>  //Creating stream to read the object  </code><code>  ObjectInputStream in=new ObjectInputStream(new FileInputStream("f.txt"));  </code><code>  Student s=(Student)in.readObject();  </code><code>  //printing the data of the serialized object  </code><code>  System.out.println(s.id+" "+s.name);  </code><code>  //closing the stream  </code><code>  in.close();  </code><code>  }catch(Exception e){System.out.println(e);}  </code><code> }  </code><code>}  </code></pre> 
<p>输出：</p> 
<pre></pre> 
<ul><li></ul> 
<pre><code>211 ravi</code></pre> 
<h3></h3> 
<h3><strong># Java继承（IS-A关系）的序列化</strong></h3> 
<p></p> 
<p>如果一个类实现了Serializable接口，则所有它的子类也将可序列化。让我们看下面给出的例子：</p> 
<p></p> 
<p>SerializeISA.java</p> 
<pre></pre> 
<ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul> 
<pre><code>import java.io.Serializable;    </code><code>class Person implements Serializable{    </code><code> int id;    </code><code> String name;    </code><code> Person(int id, String name) {    </code><code>  this.id = id;    </code><code>  this.name = name;    </code><code> }    </code><code>}    </code><code>class Student extends Person{    </code><code> String course;    </code><code> int fee;    </code><code> public Student(int id, String name, String course, int fee) {    </code><code>  super(id,name);    </code><code>  this.course=course;    </code><code>  this.fee=fee;    </code><code> }    </code><code>}    </code><code>public class SerializeISA  </code><code>{    </code><code> public static void main(String args[])  </code><code> {    </code><code>    try{    </code><code>  //Creating the object    </code><code>  Student s1 =new Student(211,"ravi","Engineering",50000);    </code><code>  //Creating stream and writing the object    </code><code>  FileOutputStream fout=new FileOutputStream("f.txt");    </code><code>  ObjectOutputStream out=new ObjectOutputStream(fout);    </code><code>  out.writeObject(s1);    </code><code>  out.flush();    </code><code>  //closing the stream    </code><code>  out.close();    </code><code>  System.out.println("success");    </code><code>  }catch(Exception e){System.out.println(e);}    </code><code>  try{    </code><code>  //Creating stream to read the object    </code><code>  ObjectInputStream in=new ObjectInputStream(new FileInputStream("f.txt"));    </code><code>  Student s=(Student)in.readObject();    </code><code>  //printing the data of the serialized object    </code><code>  System.out.println(s.id+" "+s.name+" "+s.course+" "+s.fee);    </code><code>  //closing the stream    </code><code>  in.close();    </code><code>  }catch(Exception e){System.out.println(e);}    </code><code> }    </code><code>}  </code></pre> 
<p></p> 
<p>输出：</p> 
<pre></pre> 
<ul><li><li></ul> 
<pre><code>success</code><code>211 ravi Engineering 50000</code></pre> 
<p></p> 
<p>SerializeISA类已序列化扩展了Person类的Student类对象，而Person类是可序列化的。父类属性继承到子类，因此如果父类是可序列化的，则子类也将是可序列化的。</p> 
<p></p> 
<h3><strong># Java聚合（HAS-A关系）序列化</strong></h3> 
<p></p> 
<p>如果一个类引用另一个类，则所有引用必须是Serializable，否则将不执行序列化过程。在这种情况下，在运行时会抛出NotSerializableException。</p> 
<p></p> 
<p>Address.java</p> 
<pre></pre> 
<ul><li><li><li><li><li><li><li><li></ul> 
<pre><code>class Address{    </code><code> String addressLine,city,state;    </code><code> public Address(String addressLine, String city, String state) {    </code><code>  this.addressLine=addressLine;    </code><code>  this.city=city;    </code><code>  this.state=state;    </code><code> }    </code><code>}    </code></pre> 
<p></p> 
<p>Student.java</p> 
<pre></pre> 
<ul><li><li><li><li><li><li><li><li><li><li></ul> 
<pre><code>import java.io.Serializable;  </code><code>public class Student implements Serializable{  </code><code> int id;  </code><code> String name;  </code><code> Address address;//HAS-A  </code><code> public Student(int id, String name) {  </code><code>  this.id = id;  </code><code>  this.name = name;  </code><code> }  </code><code>}  </code></pre> 
<p>由于Address不可序列化，因此无法序列化Student类的实例。</p> 
<p></p> 
<p>注意：对象中的所有对象都必须是可序列化的。</p> 
<h3></h3> 
<h3><strong># Java序列化中的静态数据成员</strong></h3> 
<p></p> 
<p>如果一个类中有任何静态数据成员，它将不被序列化，因为静态是类的一部分而不是对象。</p> 
<p></p> 
<p>Employee.java</p> 
<pre></pre> 
<ul><li><li><li><li><li><li><li><li><li></ul> 
<pre><code>class Employee implements Serializable{  </code><code> int id;  </code><code> String name;  </code><code> static String company="SSS IT Pvt Ltd";//it won't be serialized  </code><code> public Student(int id, String name) {  </code><code>  this.id = id;  </code><code>  this.name = name;  </code><code> }  </code><code>}  </code></pre> 
<h3></h3> 
<h3><strong># Java序列化数组或集合</strong></h3> 
<p></p> 
<p>规则：在数组或集合的情况下，数组或集合的所有对象必须是可序列化的。如果任何对象不可序列化，则序列化将失败。</p> 
<p></p> 
<h3>Java中的Externalizable</h3> 
<p></p> 
<p>Externalizable接口提供了以压缩格式将对象状态写入字节流的功能。它不是标记接口。</p> 
<p></p> 
<p>Externalizable接口提供两个方法：</p> 
<p></p> 
<ul><li> <p>public void writeExternal(ObjectOutput out) throws IOException</p> </li><li> <p>public void readExternal(ObjectInput in) throws IOException</p> </li></ul> 
<h3></h3> 
<h3>Java暂时关键字</h3> 
<p></p> 
<p>如果您不想序列化类的任何数据成员，可以将其标记为瞬态。</p> 
<p></p> 
<p>Employee.java</p> 
<pre></pre> 
<ul><li><li><li><li><li><li><li><li></ul> 
<pre><code>class Employee implements Serializable{  </code><code> transient int id;  </code><code> String name;  </code><code> public Student(int id, String name) {  </code><code>  this.id = id;  </code><code>  this.name = name;  </code><code> }  </code><code>}  </code></pre> 
<p>现在，id将不会序列化，因此在序列化之后反序列化对象时，您将不会得到id的值。它始终返回默认值。在这种情况下，它将返回0，因为id的数据类型是整数。</p> 
<p></p> 
<p>访问下一页获取更多详细信息。</p> 
<p></p> 
<h3>SerialVersionUID</h3> 
<p></p> 
<p>运行时序列化过程将序列化类与每个可序列化类关联一个标识符，称为SerialVersionUID。它用于验证序列化对象的发送方和接收方。发送方和接收方必须相同。为验证它，使用SerialVersionUID。发送方和接收方必须具有相同的SerialVersionUID，否则在反序列化对象时将抛出InvalidClassException。我们还可以在Serializable类中声明自己的SerialVersionUID。</p> 
<p></p> 
<p>要这样做，您需要创建一个SerialVersionUID字段并为其分配一个值。它必须是长类型，并且带有静态和最终修饰符。建议在类中明确声明serialVersionUID字段，并将其私有化。例如：</p> 
<pre></pre> 
<ul><li></ul> 
<pre><code>private static final long serialVersionUID=1L;  </code></pre> 
<p>现在，可序列化类将如下所示：</p> 
<p></p> 
<p>Employee.java</p> 
<pre></pre> 
<ul><li><li><li><li><li><li><li><li><li><li></ul> 
<pre><code>import java.io.Serializable;    </code><code>class Employee implements Serializable{    </code><code> private static final long serialVersionUID=1L;    </code><code> int id;    </code><code> String name;    </code><code> public Student(int id, String name) {    </code><code>  this.id = id;    </code><code>  this.name = name;    </code><code> }    </code><code>}    </code></pre> 
<pre></pre> 
<h3></h3> 
<p class="img-center"><img alt="图片" height="55" src="https://images2.imgbox.com/7c/fe/jUaTeg3J_o.png" width="680"></p> 
<h3></h3> 
<p></p> 
<p></p> 
<hr> 
<h2>作者其他作品：</h2> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136338757?spm=1001.2014.3001.5502" rel="nofollow" title="【Java】Spring循环依赖：原因与解决方法">【Java】Spring循环依赖：原因与解决方法</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136336417?spm=1001.2014.3001.5502" rel="nofollow" title="OpenAI Sora来了，视频生成领域的GPT-4时代来了">OpenAI Sora来了，视频生成领域的GPT-4时代来了</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136200396?spm=1001.2014.3001.5502" rel="nofollow" title="[Java·算法·简单] LeetCode 14. 最长公共前缀 详细解读">[Java·算法·简单] LeetCode 14. 最长公共前缀 详细解读</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136318553?spm=1001.2014.3001.5502" rel="nofollow" title="【Java】深入理解Java中的static关键字">【Java】深入理解Java中的static关键字</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136292910?spm=1001.2014.3001.5502" rel="nofollow" title="[Java·算法·简单] LeetCode 28. 找出字a符串中第一个匹配项的下标 详细解读">[Java·算法·简单] LeetCode 28. 找出字a符串中第一个匹配项的下标 详细解读</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136256523?spm=1001.2014.3001.5502" rel="nofollow" title="了解 Java 中的 AtomicInteger 类">了解 Java 中的 AtomicInteger 类</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136275183?spm=1001.2014.3001.5502" rel="nofollow" title="算法题 — 整数转二进制，查找其中1的数量">算法题 — 整数转二进制，查找其中1的数量</a></p> 
<p><a class="link-info" href="https://cyberspace.blog.csdn.net/article/details/136223146?spm=1001.2014.3001.5502" rel="nofollow" title="深入理解MySQL事务特性：保证数据完整性与一致性">深入理解MySQL事务特性：保证数据完整性与一致性</a></p> 
<p><a class="link-info" href="https://cyberspace.blog.csdn.net/article/details/136102269?spm=1001.2014.3001.5502" rel="nofollow" title="Java企业应用软件系统架构演变史">Java企业应用软件系统架构演变史</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86869959913d0e0e2df8351268ca113f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">自动任务、系统工具、文件工具、PDF工具、OCR图文识别、文字处理、电子表格，30&#43;超实用功能，牛的一批！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/105778f9068ed473850ab6d4776aea33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">v0.9.6 开源跨平台个人知识管理工具 TidGi-Desktop</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>