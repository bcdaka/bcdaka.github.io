<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——lesson4带头双向循环链表实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6f40123fb52da7080714f7c8a6bbfc42/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——lesson4带头双向循环链表实现">
  <meta property="og:description" content="前言✨✨ 💥个人主页：大耳朵土土垚-CSDN博客
💥 所属专栏：数据结构学习笔记​​​​​​
💥双链表与单链表的区分：单链表介绍与实现
💥对于malloc函数有疑问的:动态内存函数介绍
感谢大家的观看与支持🌹🌹🌹 有问题可以写在评论区或者私信我哦~
目录
前言✨✨
一、💥💥什么是带头双向循环链表？
二、🥳🥳带头双向循环链表的实现 1 .搭建链表基础
2.从内存中开辟一个节点
3. 创建返回链表的头结点
4.双向链表销毁
5.双向链表打印 6.双向链表尾插 7.双向链表尾删
8.双向链表头插 9.双向链表头删 10.双向链表查找
11.双向链表在pos的前面进行插入 12.双向链表删除pos位置的节点 三、💫💫拓展
四、🎉🎉结言 一、💥💥什么是带头双向循环链表？ 带头双向循环链表（Doubly Circular Linked List with a Head）是一种链表数据结构，它具有以下特点：
1.头节点：带头双向循环链表包含一个头节点，它位于链表的起始位置，并且不存储实际数据。头节点的前驱指针指向尾节点，头节点的后继指针指向第一个实际数据节点。
2.循环连接：尾节点的后继指针指向头节点，而头节点的前驱指针指向尾节点，将链表形成一个循环连接的闭环。这样可以使链表在遍历时可以无限循环，方便实现循环操作。
3.双向连接：每个节点都有一个前驱指针和一个后继指针，使得节点可以向前和向后遍历。前驱指针指向前一个节点，后继指针指向后一个节点。
总结:带头双向循环链表可以支持在链表的任意位置进行插入和删除操作，并且可以实现正向和反向的循环遍历。通过循环连接的特性，链表可以在连续的循环中遍历所有节点，使得链表的操作更加灵活和高效。
如下图所示：
结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了。 二、🥳🥳带头双向循环链表的实现 1 .搭建链表基础 带头双向循环链表需要三个变量，两个存放指向前后节点的指针，另一个存放数据
// 带头&#43;双向&#43;循环链表增删查改实现 typedef int LTDataType; typedef struct ListNode { LTDataType data;//存放数据 struct ListNode* next;//指向下一个节点 struct ListNode* prev;//指向上一个节点 }ListNode; 2.从内存中开辟一个节点 使用malloc函数开辟节点
//从内存中开辟一个节点 ListNode* BuyNode(LTDataType x) { ListNode* buynode = (ListNode*)malloc(sizeof(struct ListNode)); if (buynode == NULL)//开辟失败 { perror(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-29T17:05:18+08:00">
    <meta property="article:modified_time" content="2024-02-29T17:05:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——lesson4带头双向循环链表实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h2 id="%E5%89%8D%E8%A8%80%E2%9C%A8%E2%9C%A8">前言✨✨</h2> 
 <p>💥个人主页：<a href="https://blog.csdn.net/Renswc?spm=1010.2135.3001.5421" title="大耳朵土土垚-CSDN博客">大耳朵土土垚-CSDN博客</a></p> 
 <p>💥 所属专栏：<a href="https://blog.csdn.net/renswc/category_12577739.html" title="数据结构学习笔记​​​​​​">数据结构学习笔记​​​​​​</a></p> 
 <p>💥双链表与单链表的区分：<a href="http://t.csdnimg.cn/8KKvQ" rel="nofollow" title="单链表介绍与实现">单链表介绍与实现</a></p> 
 <p>💥对于malloc函数有疑问的:<a href="http://t.csdnimg.cn/u6Y2S" rel="nofollow" title="动态内存函数介绍">动态内存函数介绍</a></p> 
 <p></p> 
 <p>   感谢大家的观看与支持🌹🌹🌹 </p> 
 <p>   有问题可以写在评论区或者私信我哦~</p> 
</blockquote> 
<p></p> 
<p><img alt="" height="910" src="https://images2.imgbox.com/99/a9/lcpVSud5_o.jpg" width="1080"></p> 
<p></p> 
<p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%E2%9C%A8%E2%9C%A8-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%E2%9C%A8%E2%9C%A8" rel="nofollow">前言✨✨</a></p> 
<p id="%E4%B8%80%E3%80%81%F0%9F%92%A5%F0%9F%92%A5%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%F0%9F%92%A5%F0%9F%92%A5%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%9F" rel="nofollow">一、💥💥什么是带头双向循环链表？</a></p> 
<p id="%E4%BA%8C%E3%80%81%F0%9F%A5%B3%F0%9F%A5%B3%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%F0%9F%A5%B3%F0%9F%A5%B3%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">二、🥳🥳带头双向循环链表的实现 </a></p> 
<p id="1%20.%E6%90%AD%E5%BB%BA%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#1%20.%E6%90%AD%E5%BB%BA%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80" rel="nofollow">1 .搭建链表基础</a></p> 
<p id="2.%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E5%BC%80%E8%BE%9F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E5%BC%80%E8%BE%9F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9" rel="nofollow">2.从内存中开辟一个节点</a></p> 
<p id="3.%C2%A0%E5%88%9B%E5%BB%BA%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9-toc" style="margin-left:40px;"><a href="#3.%C2%A0%E5%88%9B%E5%BB%BA%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9" rel="nofollow">3. 创建返回链表的头结点</a></p> 
<p id="4.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#4.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E9%94%80%E6%AF%81" rel="nofollow">4.双向链表销毁</a></p> 
<p id="5.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%89%93%E5%8D%B0%C2%A0-toc" style="margin-left:40px;"><a href="#5.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%89%93%E5%8D%B0%C2%A0" rel="nofollow">5.双向链表打印 </a></p> 
<p id="6.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8F%92%C2%A0-toc" style="margin-left:40px;"><a href="#6.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8F%92%C2%A0" rel="nofollow">6.双向链表尾插 </a></p> 
<p id="7.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E5%88%A0-toc" style="margin-left:40px;"><a href="#7.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E5%88%A0" rel="nofollow">7.双向链表尾删</a></p> 
<p id="8.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%C2%A0-toc" style="margin-left:40px;"><a href="#8.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%C2%A0" rel="nofollow">8.双向链表头插 </a></p> 
<p id="9.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E5%88%A0%C2%A0-toc" style="margin-left:40px;"><a href="#9.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E5%88%A0%C2%A0" rel="nofollow">9.双向链表头删 </a></p> 
<p id="10.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#10.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE" rel="nofollow">10.双向链表查找</a></p> 
<p id="11.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%9C%A8pos%E7%9A%84%E5%89%8D%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%C2%A0-toc" style="margin-left:40px;"><a href="#11.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%9C%A8pos%E7%9A%84%E5%89%8D%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%C2%A0" rel="nofollow">11.双向链表在pos的前面进行插入 </a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="12.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0-toc" style="margin-left:40px;"><a href="#12.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0" rel="nofollow">12.双向链表删除pos位置的节点 </a></p> 
<p id="%E4%B8%89%E3%80%81%F0%9F%92%AB%F0%9F%92%AB%E6%8B%93%E5%B1%95-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%F0%9F%92%AB%F0%9F%92%AB%E6%8B%93%E5%B1%95" rel="nofollow">三、💫💫拓展</a></p> 
<p id="%E5%9B%9B%E3%80%81%F0%9F%8E%89%F0%9F%8E%89%E7%BB%93%E8%A8%80%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%F0%9F%8E%89%F0%9F%8E%89%E7%BB%93%E8%A8%80%C2%A0" rel="nofollow">四、🎉🎉结言 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<blockquote> 
 <h2 id="%E4%B8%80%E3%80%81%F0%9F%92%A5%F0%9F%92%A5%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%9F">一、💥💥什么是带头双向循环链表？</h2> 
</blockquote> 
<p> </p> 
<blockquote> 
 <p>带头双向循环链表（Doubly Circular Linked List with a Head）是一种链表数据结构，它具有以下特点：</p> 
 <p><span style="background-color:#ff9900;">1.头节点</span>：带头双向循环链表包含一个头节点，它位于链表的起始位置，并且不存储实际数据。头节点的前驱指针指向尾节点，头节点的后继指针指向第一个实际数据节点。</p> 
 <p><span style="background-color:#ff9900;">2.循环连接</span>：尾节点的后继指针指向头节点，而头节点的前驱指针指向尾节点，将链表形成一个循环连接的闭环。这样可以使链表在遍历时可以无限循环，方便实现循环操作。</p> 
 <p><span style="background-color:#ff9900;">3.双向连接</span>：每个节点都有一个前驱指针和一个后继指针，使得节点可以向前和向后遍历。前驱指针指向前一个节点，后继指针指向后一个节点。</p> 
 <p>        总结:带头双向循环链表可以支持在链表的任意位置进行插入和删除操作，并且可以实现正向和反向的循环遍历。通过循环连接的特性，链表可以在连续的循环中遍历所有节点，使得链表的操作更加灵活和高效。</p> 
</blockquote> 
<p></p> 
<p>如下图所示：</p> 
<p> </p> 
<p> <img alt="" height="536" src="https://images2.imgbox.com/0f/f3/9eA33zJt_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>结构最复杂</strong>，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了。 </p> 
</blockquote> 
<p></p> 
<p></p> 
<blockquote> 
 <h2 id="%E4%BA%8C%E3%80%81%F0%9F%A5%B3%F0%9F%A5%B3%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0">二、🥳🥳带头双向循环链表的实现 </h2> 
</blockquote> 
<p></p> 
<h3 id="1%20.%E6%90%AD%E5%BB%BA%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80"><span style="background-color:#a2e043;">1 .搭建链表基础</span></h3> 
<blockquote> 
 <p>带头双向循环链表需要三个变量，两个存放指向前后节点的指针，另一个存放数据</p> 
</blockquote> 
<pre><code>// 带头+双向+循环链表增删查改实现
typedef int LTDataType;
typedef struct ListNode
{
	LTDataType data;//存放数据
	struct ListNode* next;//指向下一个节点
	struct ListNode* prev;//指向上一个节点
}ListNode;</code></pre> 
<p></p> 
<p></p> 
<h3 id="2.%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E5%BC%80%E8%BE%9F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span style="background-color:#ff9900;">2.从内存中开辟一个节点</span></h3> 
<blockquote> 
 <p>使用malloc函数开辟节点</p> 
</blockquote> 
<pre><code class="hljs">//从内存中开辟一个节点
ListNode* BuyNode(LTDataType x)
{
	ListNode* buynode = (ListNode*)malloc(sizeof(struct ListNode));
	if (buynode == NULL)//开辟失败
	{
		perror("malloc fail");
	}
	buynode-&gt;data = x;
	buynode-&gt;next = NULL;
	buynode-&gt;prev = NULL;
	
}</code></pre> 
<p> </p> 
<p></p> 
<h3 id="3.%C2%A0%E5%88%9B%E5%BB%BA%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9"><span style="background-color:#38d8f0;">3. 创建返回链表的头结点</span><br>  </h3> 
<blockquote> 
 <p>开始时头节点两个指针都指向自己</p> 
</blockquote> 
<pre><code class="hljs">//创建返回链表的头结点.
ListNode* ListCreate()
{
	ListNode* head = BuyNode(-1);//这里将头节点数据设为-1，任意数都可以
	head-&gt;next = head;
	head-&gt;prev = head;
	return head;
}</code></pre> 
<p> </p> 
<h3 id="4.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E9%94%80%E6%AF%81"><span style="background-color:#ffd900;">4.双向链表销毁</span></h3> 
<blockquote> 
 <p> malloc开辟空间后要使用free销毁内存空间，防止内存泄漏</p> 
</blockquote> 
<pre><code class="hljs">// 双向链表销毁
void ListDestory(ListNode* pHead)
{
	assert(pHead);
	ListNode* cur = pHead-&gt;next;//头节点最后销毁
	while (cur != pHead)//循环一遍
	{
		ListNode* next = cur-&gt;next;//保存下一个节点，防止丢失
		free(cur);//销毁节点
		cur = next;
	}
	free(pHead);//销毁头节点
}</code></pre> 
<p></p> 
<h3 id="5.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%89%93%E5%8D%B0%C2%A0"><span style="background-color:#4da8ee;">5.双向链表打印 </span></h3> 
<p> </p> 
<pre><code class="hljs">//双向链表打印
void ListPrint(ListNode* pHead)
{
	assert(pHead);
	if (pHead-&gt;next == pHead)//没有节点的情况，也可以不考虑
	{
		printf("pHead&lt;=&gt;pHead");
		return;
	}
	//有节点的情况
	printf("pHead&lt;=&gt;");//先打印pHead
	ListNode* cur = pHead-&gt;next;
	while (cur != pHead)
	{
		printf("%d&lt;=&gt;", cur-&gt;data);
		cur = cur-&gt;next;
	}
	printf("pHead");//因为最后也是指向pHead
}</code></pre> 
<p> </p> 
<p>没有节点情况打印如下： </p> 
<p><img alt="" height="399" src="https://images2.imgbox.com/84/90/Nh0rHWOg_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h3 id="6.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8F%92%C2%A0"><span style="background-color:#ff9900;">6.双向链表尾插 </span></h3> 
<blockquote> 
 <p><img alt="" height="1080" src="https://images2.imgbox.com/c2/03/8yeAgVPw_o.jpg" width="1200"></p> 
</blockquote> 
<p> </p> 
<pre><code class="hljs">// 双向链表尾插
void ListPushBack(ListNode* pHead, LTDataType x)
{
	assert(pHead);
	
	//找尾节点,保存原来的尾
	//尾节点就是pHead-&gt;prev
	ListNode* tail = pHead-&gt;prev;
	//开辟新节点
	ListNode* newnode = BuyNode(x);
	//尾插
	pHead-&gt;prev = newnode;
	newnode-&gt;next = pHead;
	newnode-&gt;prev = tail;
	tail-&gt;next = newnode;

}</code></pre> 
<p> </p> 
<p><span style="background-color:#ff9900;">结果如下：</span></p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/c1/a6/J9CenSuc_o.png" width="1200"> </p> 
<p></p> 
<p></p> 
<h3 id="7.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E5%88%A0"><span style="background-color:#a2e043;">7.双向链表尾删</span></h3> 
<blockquote> 
 <p><img alt="" height="1080" src="https://images2.imgbox.com/8a/1f/XyHYF2RN_o.jpg" width="1200"></p> 
</blockquote> 
<pre><code class="hljs">// 双向链表尾删
void ListPopBack(ListNode* pHead)
{
	assert(pHead);
	//没有节点不能尾删，头节点pHead不算
	if (pHead-&gt;next == pHead)
	{
		printf("没有添加节点\n");
		return;
	}
	//找尾节点，以及尾节点的前一个节点
	ListNode* tail = pHead-&gt;prev;
	ListNode* tailprev = tail-&gt;prev;
	//尾删
	tailprev-&gt;next = pHead;
	pHead-&gt;prev = tailprev;
	free(tail);//释放内存空间
}</code></pre> 
<p></p> 
<p><span style="background-color:#a2e043;"> 结果如下：</span></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/3c/41/lFeMQXgf_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h3 id="8.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%C2%A0"><span style="background-color:#38d8f0;">8.双向链表头插 </span></h3> 
<blockquote> 
 <p><img alt="" height="1079" src="https://images2.imgbox.com/0c/2f/G3rVEjsK_o.jpg" width="1200"></p> 
</blockquote> 
<pre><code class="hljs">// 双向链表头插
void ListPushFront(ListNode* pHead, LTDataType x)
{
	assert(pHead);
	//找头以外的第一个节点
	ListNode* headnext = pHead-&gt;next;
	//创建新节点
	ListNode* newnode = BuyNode(x);
	//头插
	pHead-&gt;next = newnode;
	newnode-&gt;next = headnext;
	newnode-&gt;prev = pHead;
	headnext-&gt;prev = newnode;
}
</code></pre> 
<p> </p> 
<p><span style="background-color:#38d8f0;">结果如下：</span></p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/8d/ca/sV6NyrTF_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h3 id="9.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E5%88%A0%C2%A0"><span style="background-color:#ff9900;">9.双向链表头删 </span></h3> 
<blockquote> 
 <p><img alt="" height="1080" src="https://images2.imgbox.com/e1/b8/MEKsWTgE_o.jpg" width="1200"></p> 
</blockquote> 
<p> </p> 
<pre><code class="hljs">// 双向链表头删
void ListPopFront(ListNode* pHead)
{
	assert(pHead);
	//判断有没有节点，头节点pHead除外
	if (pHead-&gt;next == pHead)
	{
		printf("没有添加节点\n");
		return;
	}
	//有节点
	//找头节点以及头节点的下一个节点
	ListNode* head = pHead-&gt;next;
	ListNode* headnext = head-&gt;next;
	//头删
	pHead-&gt;next = headnext;
	headnext-&gt;prev = pHead;
	free(head);//释放内存空间
}</code></pre> 
<p> </p> 
<p><span style="background-color:#ff9900;"> 结果如下：</span></p> 
<p><img alt="" height="395" src="https://images2.imgbox.com/8b/ea/fkYMZDQZ_o.png" width="1200"> </p> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="10.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE"><span style="background-color:#ffd900;">10.双向链表查找</span></h3> 
<pre><code class="hljs">// 双向链表查找
ListNode* ListFind(ListNode* pHead, LTDataType x)
{
	assert(pHead);
	//判断有无节点
	if (pHead-&gt;next == pHead)
	{
		printf("没有添加节点\n");
		return;
	}
	ListNode* cur = pHead-&gt;next;
	//遍历查找
	while (cur)
	{
		if (cur-&gt;data == x)
		{
			return cur;//找到返回地址
		}
		cur = cur-&gt;next;
	}
}</code></pre> 
<p></p> 
<p><span style="background-color:#ffd900;">结果如下：</span></p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/23/b8/MLSr2mHy_o.png" width="968"></p> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="11.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%9C%A8pos%E7%9A%84%E5%89%8D%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%C2%A0"><span style="background-color:#a2e043;">11.双向链表在pos的前面进行插入 </span></h3> 
<blockquote> 
 <p>在pos位置前面插入原理和头插尾插相似</p> 
</blockquote> 
<pre><code class="hljs">// 双向链表在pos的前面进行插入
void ListInsert(ListNode* pos, LTDataType x)
{
	assert(pos);
	//找到pos前一个节点
	ListNode* posprev = pos-&gt;prev;
	//创建新节点
	ListNode* newnode = BuyNode(x);
	//在pos前插入
	posprev-&gt;next = newnode;
	newnode-&gt;next = pos;
	newnode-&gt;prev = posprev;
	pos-&gt;prev = newnode;
	
}</code></pre> 
<p></p> 
<p></p> 
<p><span style="background-color:#a2e043;">结果如下：</span></p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/84/58/lKGvfxTo_o.png" width="1200"></p> 
<p> </p> 
<h3></h3> 
<h3></h3> 
<h3 id="12.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0"><span style="background-color:#38d8f0;">12.双向链表删除pos位置的节点 </span></h3> 
<blockquote> 
 <p>在pos位置删除原理和头删尾删相似</p> 
</blockquote> 
<pre><code class="hljs">// 双向链表删除pos位置的节点
void ListErase(ListNode* pos)
{
	assert(pos);
	//找到pos前一个节点
	ListNode* posprev = pos-&gt;prev;
	//找打pos后一个节点
	ListNode* posnext = pos-&gt;next;
	//删除pos位置节点
	posprev-&gt;next = posnext;
	posnext-&gt;prev = posprev;
	free(pos);//释放内存空间

}</code></pre> 
<p></p> 
<p><span style="background-color:#38d8f0;">结果如下：</span></p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/0a/5e/hER87aPm_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%F0%9F%92%AB%F0%9F%92%AB%E6%8B%93%E5%B1%95">三、💫💫拓展</h2> 
<blockquote> 
 <p>思考：在pos之前插入与头插尾插是否有关？</p> 
 <p>           在pos位置删除与头删尾删是否相似？</p> 
</blockquote> 
<p> </p> 
<blockquote> 
 <p>我们发现pos位置前插入函数代码似乎可以复用在头插尾插；</p> 
 <p>pos位置删除函数代码似乎可以复用在头删尾删；</p> 
 <p>下面我们一起来实现</p> 
</blockquote> 
<blockquote> 
 <p>1.尾插头插 </p> 
</blockquote> 
<pre><code class="hljs">//尾插
void ListPushBack(ListNode* pHead, LTDataType x)
{
	assert(pHead);
	
	//找尾节点,保存原来的尾
	//尾节点就是pHead-&gt;prev
	//ListNode* tail = pHead-&gt;prev;
	开辟新节点
	//ListNode* newnode = BuyNode(x);
	尾插
	//pHead-&gt;prev = newnode;
	//newnode-&gt;next = pHead;
	//newnode-&gt;prev = tail;
	//tail-&gt;next = newnode;

	ListInsert(pHead, x);

}

//头插
void ListPushFront(ListNode* pHead, LTDataType x)
{
	assert(pHead);
	//找头以外的第一个节点
	//ListNode* headnext = pHead-&gt;next;
	创建新节点
	//ListNode* newnode = BuyNode(x);
	头插
	//pHead-&gt;next = newnode;
	//newnode-&gt;next = headnext;
	//newnode-&gt;prev = pHead;
	//headnext-&gt;prev = newnode;

	ListInsert(pHead-&gt;next, x);

}</code></pre> 
<p></p> 
<p></p> 
<blockquote> 
 <p>2.尾删，头删</p> 
</blockquote> 
<p> </p> 
<pre><code class="hljs">// 双向链表尾删
void ListPopBack(ListNode* pHead)
{
	assert(pHead);
	//没有节点不能尾删，头节点pHead不算
	if (pHead-&gt;next == pHead)
	{
		printf("没有添加节点\n");
		return;
	}
	找尾节点，以及尾节点的前一个节点
	//ListNode* tail = pHead-&gt;prev;
	//ListNode* tailprev = tail-&gt;prev;
	尾删
	//tailprev-&gt;next = pHead;
	//pHead-&gt;prev = tailprev;
	//free(tail);//释放内存空间

	ListErase(pHead-&gt;prev);
}




// 双向链表头删
void ListPopFront(ListNode* pHead)
{
	assert(pHead);
	//判断有没有节点，头节点pHead除外
	if (pHead-&gt;next == pHead)
	{
		printf("没有添加节点\n");
		return;
	}
	有节点
	找头节点以及头节点的下一个节点
	//ListNode* head = pHead-&gt;next;
	//ListNode* headnext = head-&gt;next;
	头删
	//pHead-&gt;next = headnext;
	//headnext-&gt;prev = pHead;
	//free(head);//释放内存空间

	ListErase(pHead-&gt;next);
}
</code></pre> 
<p> </p> 
<p> 运行结果依然不受影响：</p> 
<p><img alt="" height="744" src="https://images2.imgbox.com/05/29/RWBoSWLE_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%F0%9F%8E%89%F0%9F%8E%89%E7%BB%93%E8%A8%80%C2%A0">四、🎉🎉结言 </h2> 
<p></p> 
<blockquote> 
 <p>        我们通过上面的学习发现，相似的代码的重复利用可以大大减少我们写代码的时间与精力，提高我们工作学习的效率；双向链表尽管结构较单链表复杂，但其实现却比单链表简单得多，相信大家对此都深有体会，此外数据结构的题目我们可以通过画图来很好的获得思路与接替步骤，以上就是带头双向循环链表的相关知识啦~完结撒花~🎉🎉🌹🌹🌹</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d7585cafdc47720f413f6ab5dc79e277/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Ubuntu20.04启动MySQL报错（Job for mysql.service failed because the control process exited with error）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3a76bd797b8148d70248d1be94ce391/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Axios设置请求超时时间 timeout</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>