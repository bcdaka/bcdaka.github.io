<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Objective-C之通过协议提供匿名对象 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e890a90497e1ccde30c04567518176c2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Objective-C之通过协议提供匿名对象">
  <meta property="og:description" content="概述 通过协议提供匿名对象的设计模式，遵循了面向对象设计的多项重要原则：
接口隔离原则：通过定义细粒度的协议来避免实现庞大的接口。依赖倒置原则：高层模块依赖于抽象协议，而不是具体实现。里氏替换原则：不同的类实现相同协议，可以互换使用。单一职责原则：将不同职责分离到不同的协议中，使得类的职责单一且明确。 这种设计方式使得代码更加灵活、可维护、可扩展，并且易于测试和复用。
在 Objective-C 中，通过协议提供匿名对象是一种设计模式，通常用于实现接口（协议）的一致性和灵活性。这个设计模式有助于实现松耦合、提高可扩展性和维护性。我们可以从以下几个设计原则来分析和理解这种做法：
1. 接口隔离原则（Interface Segregation Principle） 接口隔离原则是指应将庞大的接口拆分成更小、更具体的接口，使得客户端只需依赖于它们实际需要的接口。在 Objective-C 中，通过协议来定义接口，可以确保类只实现其需要的协议方法。
示例 @protocol Downloadable &lt;NSObject&gt; - (void)download; @end @protocol Uploadable &lt;NSObject&gt; - (void)upload; @end @interface MyClass : NSObject &lt;Downloadable, Uploadable&gt; @end @implementation MyClass - (void)download { // 实现下载逻辑 } - (void)upload { // 实现上传逻辑 } @end 通过这种方式，MyClass 可以选择性地实现 Downloadable 和 Uploadable 协议，而不需要实现庞大的单一接口。
2. 依赖倒置原则（Dependency Inversion Principle） 依赖倒置原则强调高层模块不应该依赖于低层模块，而应该依赖于抽象。在 Objective-C 中，通过协议来定义接口，使得高层模块可以依赖于这些协议，而不是具体的实现类。
示例 @protocol DataProcessor &lt;NSObject&gt; - (void)processData:(NSData *)data; @end @interface DataHandler : NSObject @property (nonatomic, weak) id&lt;DataProcessor&gt; processor; - (void)handleData:(NSData *)data; @end @implementation DataHandler - (void)handleData:(NSData *)data { [self.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-05T09:58:59+08:00">
    <meta property="article:modified_time" content="2024-06-05T09:58:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Objective-C之通过协议提供匿名对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/11/07/CyBE47Zr_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="_1"></a>概述</h4> 
<p>通过协议提供匿名对象的设计模式，遵循了面向对象设计的多项重要原则：</p> 
<ul><li><strong>接口隔离原则</strong>：通过定义细粒度的协议来避免实现庞大的接口。</li><li><strong>依赖倒置原则</strong>：高层模块依赖于抽象协议，而不是具体实现。</li><li><strong>里氏替换原则</strong>：不同的类实现相同协议，可以互换使用。</li><li><strong>单一职责原则</strong>：将不同职责分离到不同的协议中，使得类的职责单一且明确。</li></ul> 
<p>这种设计方式使得代码更加灵活、可维护、可扩展，并且易于测试和复用。</p> 
<hr> 
<p>在 Objective-C 中，通过协议提供匿名对象是一种设计模式，通常用于实现接口（协议）的一致性和灵活性。这个设计模式有助于实现松耦合、提高可扩展性和维护性。我们可以从以下几个设计原则来分析和理解这种做法：</p> 
<h4><a id="1_Interface_Segregation_Principle_15"></a>1. 接口隔离原则（Interface Segregation Principle）</h4> 
<p>接口隔离原则是指应将庞大的接口拆分成更小、更具体的接口，使得客户端只需依赖于它们实际需要的接口。在 Objective-C 中，通过协议来定义接口，可以确保类只实现其需要的协议方法。</p> 
<h5><a id="_19"></a>示例</h5> 
<pre><code class="prism language-objective-c">@protocol Downloadable &lt;NSObject&gt;
- (void)download;
@end

@protocol Uploadable &lt;NSObject&gt;
- (void)upload;
@end

@interface MyClass : NSObject &lt;Downloadable, Uploadable&gt;
@end

@implementation MyClass
- (void)download {
    // 实现下载逻辑
}

- (void)upload {
    // 实现上传逻辑
}
@end
</code></pre> 
<p>通过这种方式，<code>MyClass</code> 可以选择性地实现 <code>Downloadable</code> 和 <code>Uploadable</code> 协议，而不需要实现庞大的单一接口。</p> 
<h4><a id="2_Dependency_Inversion_Principle_46"></a>2. 依赖倒置原则（Dependency Inversion Principle）</h4> 
<p>依赖倒置原则强调高层模块不应该依赖于低层模块，而应该依赖于抽象。在 Objective-C 中，通过协议来定义接口，使得高层模块可以依赖于这些协议，而不是具体的实现类。</p> 
<h5><a id="_50"></a>示例</h5> 
<pre><code class="prism language-objective-c">@protocol DataProcessor &lt;NSObject&gt;
- (void)processData:(NSData *)data;
@end

@interface DataHandler : NSObject
@property (nonatomic, weak) id&lt;DataProcessor&gt; processor;
- (void)handleData:(NSData *)data;
@end

@implementation DataHandler
- (void)handleData:(NSData *)data {
    [self.processor processData:data];
}
@end
</code></pre> 
<p>通过这种方式，<code>DataHandler</code> 依赖于 <code>DataProcessor</code> 协议，而不是具体的实现类，这使得 <code>DataHandler</code> 更加灵活，可以适配不同的 <code>DataProcessor</code> 实现。</p> 
<h4><a id="3_Liskov_Substitution_Principle_71"></a>3. 里氏替换原则（Liskov Substitution Principle）</h4> 
<p>里氏替换原则强调，子类对象必须能够替换其基类对象而不会导致程序错误。在 Objective-C 中，通过协议提供匿名对象，可以确保不同类实现相同的协议，并且可以互换使用。</p> 
<h5><a id="_75"></a>示例</h5> 
<pre><code class="prism language-objective-c">@protocol Animal &lt;NSObject&gt;
- (void)speak;
@end

@interface Dog : NSObject &lt;Animal&gt;
@end

@implementation Dog
- (void)speak {
    NSLog(@"Woof!");
}
@end

@interface Cat : NSObject &lt;Animal&gt;
@end

@implementation Cat
- (void)speak {
    NSLog(@"Meow!");
}
@end

void makeAnimalSpeak(id&lt;Animal&gt; animal) {
    [animal speak];
}

Dog *dog = [Dog new];
Cat *cat = [Cat new];

makeAnimalSpeak(dog); // 输出 "Woof!"
makeAnimalSpeak(cat); // 输出 "Meow!"
</code></pre> 
<p>在这个例子中，<code>Dog</code> 和 <code>Cat</code> 都实现了 <code>Animal</code> 协议，可以互换使用而不影响 <code>makeAnimalSpeak</code> 函数的逻辑。</p> 
<h4><a id="4_Single_Responsibility_Principle_113"></a>4. 单一职责原则（Single Responsibility Principle）</h4> 
<p>单一职责原则指的是一个类应该只有一个引起变化的原因，即一个类只负责一项职责。通过协议提供匿名对象，可以将不同的职责分离到不同的协议中，使得每个类只负责实现特定的协议。</p> 
<h5><a id="_117"></a>示例</h5> 
<pre><code class="prism language-objective-c">@protocol Logger &lt;NSObject&gt;
- (void)logMessage:(NSString *)message;
@end

@interface ConsoleLogger : NSObject &lt;Logger&gt;
@end

@implementation ConsoleLogger
- (void)logMessage:(NSString *)message {
    NSLog(@"%@", message);
}
@end

@interface FileLogger : NSObject &lt;Logger&gt;
@end

@implementation FileLogger
- (void)logMessage:(NSString *)message {
    // 将日志写入文件
}
@end

void performLogging(id&lt;Logger&gt; logger, NSString *message) {
    [logger logMessage:message];
}

ConsoleLogger *consoleLogger = [ConsoleLogger new];
FileLogger *fileLogger = [FileLogger new];

performLogging(consoleLogger, @"This is a console log.");
performLogging(fileLogger, @"This is a file log.");
</code></pre> 
<p>在这个例子中，<code>ConsoleLogger</code> 和 <code>FileLogger</code> 都实现了 <code>Logger</code> 协议，但它们的职责是不同的（一个将日志输出到控制台，另一个将日志输出到文件）。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0738200f1ec3b10f1735d98612ee670b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">推荐开源阅读器：FBReader for Android —— 现代化电子书阅读的首选</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/832c0ee1456838ce62c66b06a63456ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenAI 发布的 GPT-4o是什么，有什么功能？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>