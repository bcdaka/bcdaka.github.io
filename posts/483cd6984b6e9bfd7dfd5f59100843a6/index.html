<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;初阶】第七站：string类的初识(万字详解、细节拉满) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/483cd6984b6e9bfd7dfd5f59100843a6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;初阶】第七站：string类的初识(万字详解、细节拉满)">
  <meta property="og:description" content="前言：
📍本文知识点：string的初识
💨个人博客:Dream_Chaser～-CSDN博客
🚩本专栏：C&#43;&#43;
目录
一、什么是STL
二、STL的六大组件
三、STL的缺陷
四、为什么学习string类？
五、标准库中的string类
1、string类(了解)
2、string类的常用接口说明（最常用的接口）
A. string类对象的常见构造
B.string类的成员函数的使用
1、for&#43;operator [ ]
2、范围for遍历
3、迭代器遍历
反向迭代器
const修饰的迭代器
4.💥取字符串💥
C.string类对象的容量操作
size、length、capacity、clear 、max_size,:
❓来写一道题：387. 字符串中的第一个唯一字符
reserve resize at 下标自增
D.string类对象的修改操作 push_back、append、&#43;=、&#43;：
assgin
insert
erase
replace
swap
c_str
find、rfind、substr
find
rfind
substr
取出协议、域名、资源名：
find_first_of 和 find_first_not_of
一、什么是STL STL(standard template libaray-标准模板库)：是C&#43;&#43;标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个包罗数据结构与算法的软件框架。
二、STL的六大组件 三、STL的缺陷 1. STL库的更新太慢了。这个得严重吐槽，上一版靠谱是C&#43;&#43;98，中间的C&#43;&#43;03基本一些修订。C&#43;&#43;11出来已经相隔了13年，STL才进一步更新。 2. STL现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。 3. STL极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。 4. STL的使用会有代码膨胀的问题，比如使用vector/vector/vector这样会生成多份代码，当然这是模板语法本身导致的。
四、为什么学习string类？ 1、C语言中的字符串
C语言中，字符串是以&#39;\0&#39;结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。
2、面试题 ( 暂不做讲解) 字符串相加 在OJ中，有关字符串的题目基本以string类的形式出现，而且在常规工作中，为了简单、方便、快捷，基本都使用string类，很少有人去使用C库中的字符串操作函数 五、标准库中的string类 1、string类(了解) string类的文档介绍">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-27T16:24:20+08:00">
    <meta property="article:modified_time" content="2024-03-27T16:24:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;初阶】第七站：string类的初识(万字详解、细节拉满)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言：</strong></p> 
<blockquote> 
 <p>📍<strong>本文知识点：string的初识</strong><br> 💨<strong>个人博客:</strong><a href="https://blog.csdn.net/weixin_65186652?type=blog" title="Dream_Chaser～-CSDN博客">Dream_Chaser～-CSDN博客</a></p> 
 <p><strong>🚩本专栏：</strong><a href="https://blog.csdn.net/weixin_65186652/category_12490262.html?spm=1001.2014.3001.5482" title="C++">C++</a></p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/93/05/PbNiv0H0_o.gif"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSTL-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSTL" rel="nofollow">一、什么是STL</a></p> 
<p id="%E4%BA%8C%E3%80%81STL%E7%9A%84%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81STL%E7%9A%84%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6" rel="nofollow">二、STL的六大组件</a></p> 
<p id="%E4%B8%89%E3%80%81STL%E7%9A%84%E7%BC%BA%E9%99%B7-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81STL%E7%9A%84%E7%BC%BA%E9%99%B7" rel="nofollow">三、STL的缺陷</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0string%E7%B1%BB%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0string%E7%B1%BB%EF%BC%9F" rel="nofollow">四、为什么学习string类？</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB" rel="nofollow">五、标准库中的string类</a></p> 
<p id="1%E3%80%81string%E7%B1%BB(%E4%BA%86%E8%A7%A3)-toc" style="margin-left:40px;"><a href="#1%E3%80%81string%E7%B1%BB%28%E4%BA%86%E8%A7%A3%29" rel="nofollow">1、string类(了解)</a></p> 
<p id="2%E3%80%81string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%89-toc" style="margin-left:40px;"><a href="#2%E3%80%81string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%89" rel="nofollow">2、string类的常用接口说明（最常用的接口）</a></p> 
<p id="A.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0-toc" style="margin-left:80px;"><a href="#A.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0" rel="nofollow">A. string类对象的常见构造</a></p> 
<p id="B.string%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#B.string%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">B.string类的成员函数的使用</a></p> 
<p id="1%E3%80%81for%E5%BE%AA%E7%8E%AF%E5%BD%A2%E5%BC%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:120px;"><a href="#1%E3%80%81for%E5%BE%AA%E7%8E%AF%E5%BD%A2%E5%BC%8F%E9%81%8D%E5%8E%86" rel="nofollow">1、for+operator [ ]</a></p> 
<p id="2%E3%80%81%E8%8C%83%E5%9B%B4for%E9%81%8D%E5%8E%86-toc" style="margin-left:120px;"><a href="#2%E3%80%81%E8%8C%83%E5%9B%B4for%E9%81%8D%E5%8E%86" rel="nofollow">2、范围for遍历</a></p> 
<p id="3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86-toc" style="margin-left:120px;"><a href="#3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86" rel="nofollow">3、迭代器遍历</a></p> 
<p id="%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:160px;"><a href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">反向迭代器</a></p> 
<p id="const%E4%BF%AE%E9%A5%B0%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:160px;"><a href="#const%E4%BF%AE%E9%A5%B0%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">const修饰的迭代器</a></p> 
<p id="4.%F0%9F%92%A5%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%F0%9F%92%A5-toc" style="margin-left:120px;"><a href="#4.%F0%9F%92%A5%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%F0%9F%92%A5" rel="nofollow">4.💥取字符串💥</a></p> 
<p id="C.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#C.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C" rel="nofollow">C.string类对象的容量操作</a></p> 
<p id="size%E3%80%81length%E3%80%81capacity%E3%80%81max_size%3A-toc" style="margin-left:120px;"><a href="#size%E3%80%81length%E3%80%81capacity%E3%80%81max_size%3A" rel="nofollow">size、length、capacity、clear 、max_size,:</a></p> 
<p id="%E2%9D%93%E6%9D%A5%E5%86%99%E4%B8%80%E9%81%93%E9%A2%98%EF%BC%9A387.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6-toc" style="margin-left:160px;"><a href="#%E2%9D%93%E6%9D%A5%E5%86%99%E4%B8%80%E9%81%93%E9%A2%98%EF%BC%9A387.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6" rel="nofollow">❓来写一道题：387. 字符串中的第一个唯一字符</a></p> 
<p id="reserve%C2%A0-toc" style="margin-left:120px;"><a href="#reserve%C2%A0" rel="nofollow">reserve </a></p> 
<p id="resize%C2%A0-toc" style="margin-left:120px;"><a href="#resize%C2%A0" rel="nofollow">resize </a></p> 
<p id="%E4%B8%8B%E6%A0%87%E8%87%AA%E5%A2%9E-toc" style="margin-left:120px;"><a href="#%E4%B8%8B%E6%A0%87%E8%87%AA%E5%A2%9E" rel="nofollow">at 下标自增</a></p> 
<p id="D.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%20%C2%A0-toc" style="margin-left:80px;"><a href="#D.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%20%C2%A0" rel="nofollow">D.string类对象的修改操作  </a></p> 
<p id="push_back%E3%80%81append%E3%80%81%2B%3D%E3%80%81%2B%EF%BC%9A-toc" style="margin-left:120px;"><a href="#push_back%E3%80%81append%E3%80%81%2B%3D%E3%80%81%2B%EF%BC%9A" rel="nofollow">push_back、append、+=、+：</a></p> 
<p id="assgin-toc" style="margin-left:120px;"><a href="#assgin" rel="nofollow">assgin</a></p> 
<p id="insert-toc" style="margin-left:120px;"><a href="#insert" rel="nofollow">insert</a></p> 
<p id="erase-toc" style="margin-left:120px;"><a href="#erase" rel="nofollow">erase</a></p> 
<p id="replace-toc" style="margin-left:120px;"><a href="#replace" rel="nofollow">replace</a></p> 
<p id="swap-toc" style="margin-left:120px;"><a href="#swap" rel="nofollow">swap</a></p> 
<p id="c_str-toc" style="margin-left:120px;"><a href="#c_str" rel="nofollow">c_str</a></p> 
<p id="find%E3%80%81rfind%E3%80%81substr-toc" style="margin-left:120px;"><a href="#find%E3%80%81rfind%E3%80%81substr" rel="nofollow">find、rfind、substr</a></p> 
<p id="find-toc" style="margin-left:160px;"><a href="#find" rel="nofollow">find</a></p> 
<p id="rfind-toc" style="margin-left:160px;"><a href="#rfind" rel="nofollow">rfind</a></p> 
<p id="substr-toc" style="margin-left:160px;"><a href="#substr" rel="nofollow">substr</a></p> 
<p id="%E5%8F%96%E5%87%BAurl%E5%8D%8F%E8%AE%AE%E3%80%81%E5%9F%9F%E5%90%8D%E3%80%81uri%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E5%8F%96%E5%87%BAurl%E5%8D%8F%E8%AE%AE%E3%80%81%E5%9F%9F%E5%90%8D%E3%80%81uri%EF%BC%9A" rel="nofollow">取出协议、域名、资源名：</a></p> 
<p id="find_first_of%20%E5%92%8C%20find_first_not_of-toc" style="margin-left:120px;"><a href="#find_first_of%20%E5%92%8C%20find_first_not_of" rel="nofollow">find_first_of 和 find_first_not_of</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSTL" style="margin-left:0px;text-align:left;"><strong><span style="color:#333333;">一、什么是</span></strong><strong><span style="color:#333333;">STL </span></strong></h2> 
<p style="margin-left:0;text-align:left;"><span style="color:#333333;">STL(standard template libaray-</span><span style="color:#333333;">标准模板库</span><span style="color:#333333;">)</span><span style="color:#333333;">：</span><span style="color:#fe2c24;"><strong>是C++</strong><strong>标准库的重要组成部分</strong>，</span>不仅是一个<strong>可复用的组件库</strong>，而且<span style="color:#fe2c24;"><strong>是一个包罗数据结构与算法的软件框架</strong>。</span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h2 id="%E4%BA%8C%E3%80%81STL%E7%9A%84%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6" style="margin-left:0px;text-align:left;"><strong><span style="color:#333333;">二、STL</span></strong><strong><span style="color:#333333;">的六大组件</span></strong></h2> 
<p style="margin-left:0;text-align:left;"><img alt="" height="644" src="https://images2.imgbox.com/89/4a/wcPjMPsA_o.png" width="975"></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h2 id="%E4%B8%89%E3%80%81STL%E7%9A%84%E7%BC%BA%E9%99%B7" style="margin-left:0px;text-align:left;">三、<span style="color:#333333;"><strong>STL</strong></span><span style="color:#333333;"><strong>的缺陷</strong></span></h2> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#777777;">        1. STL库的更新太慢了。这个得严重吐槽，上一版靠谱是</span><span style="color:#777777;">C++98</span><span style="color:#777777;">，中间的</span><span style="color:#777777;">C++03</span><span style="color:#777777;">基本一些修订。</span><span style="color:#777777;">C++11</span><span style="color:#777777;">出来已经相隔了</span><span style="color:#777777;">13</span><span style="color:#777777;">年，</span><span style="color:#777777;">STL</span><span style="color:#777777;">才进一步更新。 </span></strong></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#777777;">        2. STL现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。 </span></strong></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#777777;">        3. STL极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。 </span></strong></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#777777;">        4. STL的使用会有代码膨胀的问题，比如使用</span><span style="color:#777777;">vector/vector/vector</span><span style="color:#777777;">这样会生成多份代码，当然这是模板语法本身导致的。</span></strong></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h2 id="%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0string%E7%B1%BB%EF%BC%9F" style="margin-left:0px;text-align:left;"><span style="color:#333333;"><strong>四、为什么学习</strong></span><span style="color:#333333;"><strong>string</strong></span><span style="color:#333333;"><strong>类？</strong></span></h2> 
<p><span style="color:#333333;"><strong>1、C</strong></span><span style="color:#333333;"><strong>语言中的字符串</strong></span></p> 
<p><span style="color:#777777;">        <strong>C语言中，字符串是以</strong></span><strong><span style="color:#777777;">'\0'</span><span style="color:#777777;">结尾的一些字符的集合，为了操作方便，</span><span style="color:#777777;">C</span><span style="color:#777777;">标准库中提供了一些</span><span style="color:#777777;">str</span><span style="color:#777777;">系列的库函数，但是这些库函数与字符串是分离开的，不太符合</span><span style="color:#777777;">OOP</span><span style="color:#777777;">的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。</span></strong></p> 
<p></p> 
<div> 
 <span style="color:#333333;"><strong>2、面试题</strong></span> 
 <span style="color:#333333;"><strong>(</strong></span> 
 <span style="color:#333333;"><strong>暂不做讲解)</strong></span> 
</div> 
<div></div> 
<div> 
 <a href="https://leetcode.cn/problems/add-strings/" rel="nofollow" title="字符串相加">字符串相加</a> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#494949;">      在OJ中，有关字符串的题目基本以string类的形式出现，而且在常规工作中，为了简单、方便、快捷，基本都使用string类，很少有人去使用C库中的字符串操作函数</span> 
 </div> 
 <div></div> 
 <div></div> 
 <h2 id="%E4%BA%94%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB"><span style="color:#494949;">五、</span><span style="color:#333333;"><strong>标准库中的</strong></span><span style="color:#333333;"><strong>string</strong></span><span style="color:#333333;"><strong>类</strong></span></h2> 
 <h3 id="1%E3%80%81string%E7%B1%BB(%E4%BA%86%E8%A7%A3)"><span style="color:#333333;"><strong>1、string</strong></span><span style="color:#333333;"><strong>类</strong></span><span style="color:#333333;"><strong>(</strong></span><span style="color:#333333;"><strong>了解</strong></span><span style="color:#333333;"><strong>) </strong></span></h3> 
 <p><a href="https://legacy.cplusplus.com/reference/string/string/" rel="nofollow" title="string类的文档介绍">string类的文档介绍</a></p> 
 <p>📌<strong>总结：</strong></p> 
 <blockquote> 
  <p style="margin-left:0px;text-align:left;"><span style="color:#494949;">1. string是表示字符串的字符串类 </span></p> 
  <p style="margin-left:0px;text-align:left;"><span style="color:#494949;">2. 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。</span></p> 
  <p style="margin-left:0px;text-align:left;"><span style="color:#494949;">3. string在底层实际是：</span></p> 
  <p style="margin-left:0px;text-align:left;"><span style="color:#494949;">basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt; string; </span></p> 
  <p style="margin-left:0px;text-align:left;"><span style="color:#494949;">4. 不能操作多字节或者变长字符的序列。</span></p> 
 </blockquote> 
 <div> 
  <span style="color:#1c7331;"><strong>注意：</strong></span> 
 </div> 
 <blockquote> 
  <div> 
   <span style="color:#fe2c24;">在<strong>使用string类时，必须包含#include头文件以及using namespace std</strong>;</span> 
  </div> 
 </blockquote> 
 <div> 
  <div></div> 
  <h3 id="2%E3%80%81string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%89"><span style="color:#333333;"><strong>2、string</strong></span><span style="color:#333333;"><strong>类的常用接口说明（最常用的接口）</strong></span></h3> 
  <h4 id="A.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0"><span style="color:#777777;">A. </span><span style="color:#777777;"><strong>string</strong></span><span style="color:#777777;"><strong>类对象的常见构造 </strong></span></h4> 
  <div></div> 
  <div> 
   <img alt="" height="330" src="https://images2.imgbox.com/88/c2/hJ2w5Hfy_o.png" width="1106"> 
  </div> 
  <div>
    示例： 
  </div> 
  <div> 
   <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

void test_string1()
{
	//空构造函数
	string s1;
	cout &lt;&lt; s1 &lt;&lt; endl; 
	//常量字符串                                            //(优化成直接构造)
	string s2("hello");//等价&lt;--&gt;string s2 = "hello world";//构造+拷贝构造 
	cout &lt;&lt; s2 &lt;&lt; endl;
	//创建一个包含 n 个重复字符 '#' 的字符串
	string s3(5, '#');
	cout &lt;&lt; s3&lt;&lt;endl;
	
	//拷贝构造函数，用以创建一个已存在字符串对象的副本
	string s4("Copy this");
	string s5(s4);  // s5 是 s4 的副本
	cout &lt;&lt; s5&lt;&lt;endl;  // 输出 "Copy this"

	string s6 = s2 + s2;// + 运算符重载，构造，拷贝构造
	cout &lt;&lt; s6 &lt;&lt; endl;
		
	//将现有的字符串 s2 和字面量字符串 "我来了" 进行拼接
	string s7 = s2 + "我来了";//+ 运算符重载，字符串拼接，拷贝构造函数
	cout &lt;&lt; s7 &lt;&lt; endl;
}
int main()
{
	test_string1();
}</code></pre> 
   <p><img alt="" height="588" src="https://images2.imgbox.com/c8/44/Fc3lMllv_o.png" width="771"></p> 
  </div> 
  <div></div> 
  <div></div> 
  <div> 
   <h4 id="B.string%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><strong>B.string类的成员函数的使用</strong></h4> 
  </div> 
  <div> 
   <strong><span style="color:#7b7f82;">上面知道了string类对象如何初始化，那么我们想要遍历string该怎么遍历呢？</span></strong> 
  </div> 
  <div> 
   <span style="color:#494949;"><strong>以下这个表分别对应下文的三种遍历方式：</strong></span> 
  </div> 
  <div> 
   <img alt="" height="413" src="https://images2.imgbox.com/64/45/EXcQwNPK_o.png" width="1067"> 
  </div> 
  <div> 
   <a href="https://gitee.com/ailiangshilove/cpp-class/blob/master/%E8%AF%BE%E4%BB%B6%E4%BB%A3%E7%A0%81/C++%E8%AF%BE%E4%BB%B6V6/string%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%8F%8A%E4%BD%BF%E7%94%A8/TestString.cpp" rel="nofollow" title="string中元素访问及遍历代码演示">string中元素访问及遍历代码演示</a> 
  </div> 
  <div></div> 
  <div></div> 
  <h5 id="1%E3%80%81for%E5%BE%AA%E7%8E%AF%E5%BD%A2%E5%BC%8F%E9%81%8D%E5%8E%86"><span style="color:#494949;"><strong>1、</strong></span>for+operator [ ]</h5> 
  <div> 
   <strong><span style="color:#494949;">[] + 下标访问：读取 / 修改</span></strong> 
  </div> 
  <div></div> 
  <div> 
   <pre><code class="language-cpp">void test_string2()
{
	string s1 = "hello world";

	//for形式遍历
	//遍历string
	for (size_t i = 0; i &lt; s1.size(); i++)
	{
		//读
		cout &lt;&lt; s1[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	//s1里面的每一个字符的对应的十进制都+1，之后原本字符会变成新字符
	for (size_t i = 0; i &lt; s1.size(); i++)
	{
		//写
		s1[i]++;
	}
	cout &lt;&lt; s1 &lt;&lt; endl;
}</code></pre> 
   <p><img alt="" height="480" src="https://images2.imgbox.com/9d/c1/kM62bFhl_o.png" width="779"></p> 
  </div> 
  <div></div> 
  <div></div> 
  <h5 id="2%E3%80%81%E8%8C%83%E5%9B%B4for%E9%81%8D%E5%8E%86"><strong>2、范围for遍历 </strong></h5> 
  <div> 
   <span style="color:#be191c;"><strong>auto：修改+读取</strong></span> 
  </div> 
  <div> 
   <img alt="" height="710" src="https://images2.imgbox.com/cf/06/YqZI9XyT_o.png" width="1200"> 
  </div> 
  <div> 
   <pre><code class="language-cpp">void test_string3()
{
    //编译时编译器替换成迭代器，范围for的底层跟迭代器是完全类似的
	//范围for
	//读
	for (auto ch : s1)
	{
		ch++;
	}
	cout &lt;&lt; endl;	
	//写
	for (auto&amp; ch : s1)
	{
		ch++;
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; s1 &lt;&lt; endl;
}</code></pre> 
   <p><img alt="" height="470" src="https://images2.imgbox.com/58/95/9UqdYCKg_o.png" width="709"></p> 
  </div> 
 </div> 
</div> 
<p></p> 
<h5 id="3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86"><strong>3、迭代器遍历</strong></h5> 
<p><strong>使用迭代器遍历我们需要了解String中的Iterators成员函数:</strong></p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/ae/52/gaq3GJLa_o.png" width="1170"></p> 
<blockquote> 
 <p><strong>begin():返回一个指向字符串的第一个字符的迭代器</strong></p> 
 <p> <img alt="" height="243" src="https://images2.imgbox.com/3d/6a/OYRGpFdP_o.png" width="630"></p> 
 <p><strong>end():返回一个迭代器，该迭代器指向了字符串的最后一个字符的下一个位置( '\0' )</strong></p> 
 <p><img alt="" height="237" src="https://images2.imgbox.com/48/9b/4EXR4ml5_o.png" width="702"></p> 
</blockquote> 
<p></p> 
<p><strong><span style="color:#be191c;">迭代器:像指针一样的东西，有可能是指针，也有可能不是指针，但使用方法是像指针一样的东西</span></strong></p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/72/db/NgojgqNk_o.png" width="1200"></p> 
<pre><code class="language-cpp">void test_string2()
{
	string s1 = "hello world"
	
    //string不能省掉，省掉就报错
	string::iterator it = s1.begin();//返回一个迭代器，指向字符串的第一个字符
	
    //推荐玩法，通用--&gt; !=
    while (it != s1.end())//返回一个指向字符串的最后一个字符的迭代器
	{
		//读
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	it = s1.begin();
	while (it != s1.end())
	{
		//写
		*it = '#';
		++it;
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; s1 &lt;&lt; endl;
}</code></pre> 
<p><img alt="" height="518" src="https://images2.imgbox.com/48/1c/hP75hCY2_o.png" width="779"></p> 
<p></p> 
<p><strong><span style="color:#fe2c24;">💨注意：while循环条件这里可以用</span> &lt; </strong>吗？</p> 
<p class="img-center"><img alt="" height="185" src="https://images2.imgbox.com/14/bf/SyVgYAiG_o.png" width="317"></p> 
<p><strong>可以但是不建议：</strong></p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/63/29/uthqod9j_o.png" width="799"></p> 
<p><strong>(为什么可以，因为string的物理空间是连续的，说明地址是从小到大变化的，当然可以使用&lt; 比较)</strong>      所以说，list、vector这样的连续的物理空间的数据结构，可以使用<strong>数组的方式遍历</strong></p> 
<p><span style="background-color:#ffd900;">关于迭代器：</span></p> 
<p><strong>而string、list、vector的迭代器都是通用的 ，都可以用迭代器遍历的方式遍历元素，包括以后的树形结构、哈希结构，都可以使用迭代器遍历</strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>总结：在C++标准模板库（STL）中，所有标准容器均支持迭代器</strong></span></p> 
</blockquote> 
<p>🎯但是<strong><span style="color:#be191c;">对于list来说</span></strong>，它的<span style="color:#be191c;"><strong>物理空间并不一定是连续的</strong></span>，<span style="color:#7b7f82;"><strong>它是由一个带哨兵位的头节点，外加一个个的小节点构成:</strong></span></p> 
<p><img alt="" height="430" src="https://images2.imgbox.com/50/6e/pCznTEHI_o.png" width="835"></p> 
<p><span style="background-color:#ffd900;">所以list的物理空间不一定是连续的，lit指向的字符串开头的地址不一定小于end指向的地址：</span></p> 
<p><img alt="" height="477" src="https://images2.imgbox.com/e5/16/A0tQFUia_o.png" width="769"></p> 
<p><strong>总结：🚩</strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>所以！=才是通用的。</strong></span></p> 
</blockquote> 
<p><strong>示范代码：</strong></p> 
<pre><code class="language-cpp">void test_string2()
{
	list表示使用STL中的list容器模板类。
	&lt;int&gt; 是模板参数，表明列表中存储的数据类型是整数（int）。
	lt 是声明的list对象名称，即创建了一个可以存放整数的双向链表。

	list&lt;int&gt;lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);

	//迭代器遍历
	list&lt;int&gt;::iterator lit = lt.begin();
	while (lit != lt.end())
	{
		cout &lt;&lt; *lit &lt;&lt; " ";
		++lit;
	}
	cout &lt;&lt; endl;
}</code></pre> 
<p><img alt="" height="256" src="https://images2.imgbox.com/5e/e3/E3XDrLrs_o.png" width="653"></p> 
<p></p> 
<h6 id="%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8">反向迭代器</h6> 
<ul><li><strong><span style="color:#7b7f82;">有正向迭代器，那么有反向迭代器吗？</span></strong></li></ul> 
<blockquote> 
 <p><strong>rebegin()</strong>：<strong>返回一个反向的迭代器，该迭代器指向字符串的最后一个字符</strong></p> 
 <p><img alt="" height="278" src="https://images2.imgbox.com/2b/46/Hwee2gDV_o.png" width="1127"></p> 
 <p><strong>rend()：返回一个反向迭代器，该迭代器指向字符串的第一个字符前面的理论元素(下标为-1)。</strong></p> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/c5/fc/iuvIQsGA_o.png" width="1200"></p> 
</blockquote> 
<p></p> 
<p class="img-center"><img alt="" height="389" src="https://images2.imgbox.com/86/1d/HELlpIPK_o.png" width="580"></p> 
<pre><code>void test_string3()
{
	string s1("hello world");
	
    string::reverse_iterator rit = s1.rbegin();
    //等价 👇
	//auto rit = s1.rbegin();
	while (rit != s1.rend())
	{
		cout &lt;&lt; *rit &lt;&lt; " ";
		++rit;
	}
	cout &lt;&lt; endl;
	 
}</code></pre> 
<p><img alt="" height="336" src="https://images2.imgbox.com/68/70/yJTqUJQn_o.png" width="966"></p> 
<p>我们也可以使用<span style="color:#fe2c24;"><strong>auto来自动判断类型：</strong></span></p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/94/dd/5SEydopF_o.png" width="768"></p> 
<p></p> 
<h6 id="const%E4%BF%AE%E9%A5%B0%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">const修饰的迭代器</h6> 
<p><span style="color:#fe2c24;"><strong>被const修饰的迭代器 -- 只能读，不能写，因为它是给const对象访问的</strong></span></p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/ff/e0/gslWQKiC_o.png" width="622"></p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/81/ac/q1wh9dPx_o.png" width="1109"></p> 
<pre><code class="language-cpp">//const string
void func(const string&amp; s)
{
	//string::const_iterator it = s.begin();
	auto it = s.begin();
	while (it != s.end())
	{
		//不支持写
		//*it = 'a';

		//读
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;

	//string::const_reverse_iterator rit = s.rbegin();
    auto rit = s.rbegin();
	while (rit != s.rend())
	{
		cout &lt;&lt; *rit &lt;&lt; " ";
		++rit;
	}
	cout &lt;&lt; endl;
}
void test_string4()
{
	string s1("apple pie");
	func(s1);
}</code></pre> 
<p>执行：</p> 
<p><img alt="" height="704" src="https://images2.imgbox.com/06/96/fzU2MR4L_o.png" width="1079"></p> 
<p>我们当然也可以使用<strong><span style="color:#ff9900;">auto简化代码</span></strong>：</p> 
<p><img alt="" height="712" src="https://images2.imgbox.com/07/01/rhvppGZ3_o.png" width="1113"></p> 
<p><strong><span style="color:#be191c;">以下均是不能通过的情况：</span></strong></p> 
<blockquote> 
 <p>如果传参的时候写成被const修饰的参数，其他代码不改动，<span style="color:#fe2c24;">那么编译就不会通过了：</span></p> 
 <p><img alt="" height="806" src="https://images2.imgbox.com/1c/46/H9TdD5wc_o.png" width="1200"></p> 
 <p><strong>因为s1传参到s是const对象，const对象要用const迭代器，只读，不能写</strong></p> 
 <p><strong><span style="color:#fe2c24;">红色框</span>是修改之后的结果，<span style="color:#4da8ee;">蓝色框</span>说明该迭代器</strong><span style="background-color:#ffd900;">只能读不能写</span></p> 
 <p><img alt="" height="764" src="https://images2.imgbox.com/f3/87/eYpPGYOt_o.png" width="843"></p> 
</blockquote> 
<p>总计：四种迭代器</p> 
<p class="img-center"><img alt="" height="188" src="https://images2.imgbox.com/b6/4a/aV41wMdS_o.png" width="535"></p> 
<h5 id="4.%F0%9F%92%A5%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%F0%9F%92%A5">4.💥<strong>取字符串</strong>💥</h5> 
<p>假设这时候我要从一个字符串里面取需要的字符串,我们需要用到打<span style="color:#fe2c24;"><strong>红色√(重点)</strong></span></p> 
<p><span style="color:#494949;"><strong>需要注意的</strong></span><span style="color:#fe2c24;"><strong>：</strong>以及横线划着那条成员函数,</span><span style="color:#4da8ee;">蓝色打勾</span></p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/0b/63/InYRp1AD_o.png" width="1168"></p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/0d/25/URRx7xV6_o.png" width="963"></p> 
<p>        但如果我这个字符串很长，那需要我从头到尾去数这个字符串的长度，然后把大小填到参数位那吗？这样的处理方法未免太繁琐。这时候引入了一个参数<span style="color:#1a439c;"><strong>npos</strong></span>：</p> 
<p><img alt="" height="398" src="https://images2.imgbox.com/59/3d/f4kb2VeO_o.png" width="1200"></p> 
<p>比如说以下这个，直接从<strong>主串的第6个字符的后一个字符开始取子串</strong>，不填入参数，默认就帮你把后面的子串都取完，<span style="color:#1c7331;"><strong>以下这两种写法的功能都十分相似</strong></span>：</p> 
<p></p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/20/b3/LdLjZv8v_o.png" width="974"></p> 
<p><span style="color:#be191c;"><strong>另外还有需要注意的知识点是:</strong></span></p> 
<p>赋值运算符重载：</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/87/92/4MSMy5lg_o.png" width="824"></p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/93/cd/fqT2hegs_o.png" width="935"></p> 
<p><strong>举例的代码：</strong></p> 
<pre><code>void test_string4()
{
	string s1("apple pie,taste good");
	string s1("hello world");

	string s2(s1);
	cout &lt;&lt; s2 &lt;&lt; endl;
	cout &lt;&lt; "-------------------------------------" &lt;&lt; endl;

	string s3(s1, 6, 5);
	cout &lt;&lt; s3 &lt;&lt; endl;
	cout &lt;&lt; "-------------------------------------" &lt;&lt; endl;

	string s4(s1, 6, 3);
	cout &lt;&lt; s4 &lt;&lt; endl;
	cout &lt;&lt; "-------------------------------------" &lt;&lt; endl;
	//string s1("apple pie,taste good");
	string s5(s1, 6 );
	cout &lt;&lt; s5 &lt;&lt; endl;
	cout &lt;&lt; "-------------------------------------" &lt;&lt; endl;

	string s6(s1, 6, s1.size() - 6);// s1.size() - 6：子串的长度,从第七个位置的字符开始
	cout &lt;&lt; s6 &lt;&lt; endl;
	cout &lt;&lt; "-------------------------------------" &lt;&lt; endl;

	string s7(10, 'a');
	cout &lt;&lt; s7 &lt;&lt; endl;
	cout &lt;&lt; "-------------------------------------" &lt;&lt; endl;

	string s8(++s7.begin(), --s7.end());
	cout &lt;&lt; s8 &lt;&lt; endl;
	cout &lt;&lt; "-------------------------------------" &lt;&lt; endl;

	s8 = s7;
	s8 = "xxx";
	s8 = 'y';
	cout &lt;&lt; s8 &lt;&lt; endl;
}</code></pre> 
<p></p> 
<h4 id="C.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span style="color:#494949;"><strong>C.string类对象的容量操作</strong></span></h4> 
<p><img alt="" height="496" src="https://images2.imgbox.com/59/69/1W4AJMLH_o.png" width="1091"></p> 
<p style="margin-left:0;text-align:justify;"><a href="https://gitee.com/ailiangshilove/cpp-class/blob/master/%E8%AF%BE%E4%BB%B6%E4%BB%A3%E7%A0%81/C++%E8%AF%BE%E4%BB%B6V6/string%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%8F%8A%E4%BD%BF%E7%94%A8/TestString.cpp" rel="nofollow" title="string容量相关方法使用代码演示">string容量相关方法使用代码演示</a></p> 
<p style="margin-left:0;text-align:justify;">注意</p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#7b7f82;"><strong>1. size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，</strong></span><span style="color:#fe2c24;"><strong>一般情况下基本都是用size()</strong></span><span style="color:#7b7f82;"><strong>。</strong></span></p> 
 <p style="margin-left:0;text-align:justify;"></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#7b7f82;"><strong>2.clear()</strong></span><span style="color:#333333;"><strong><span style="background-color:#ed7976;">只是将string中有效字符清空，不改变底层空间大小</span></strong></span><span style="color:#7b7f82;"><strong>。</strong></span></p> 
 <p style="margin-left:0;text-align:justify;"></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#7b7f82;"><strong>3.resize(size_t n)与 resize(sizet n,char c)都是将字符串中有效字符个数改变到n个，</strong></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#7b7f82;"><strong>不同的是当字符个数增多时:</strong></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#7b7f82;"><strong>resize(n)用0来填充多出的元素空间，</strong></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#7b7f82;"><strong>resize(size tn,char c)用字符c来填充多出的元素空间。</strong></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#7b7f82;"><strong>注意:resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。</strong></span></p> 
 <p style="margin-left:0;text-align:justify;"></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#7b7f82;"><strong>4.reserve(size_tres_arg=0):为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserver不会改变容量大小。</strong></span></p> 
</blockquote> 
<h5 id="size%E3%80%81length%E3%80%81capacity%E3%80%81max_size%3A"><strong>size、length、capacity、clear 、max_size,</strong>:</h5> 
<p>建议使用size:size比length更具有通用性,length<strong>只能计算线性的数据结构</strong>。</p> 
<pre><code>void test_string5()
{
	string s1("hello world");
	cout &lt;&lt; s1.size() &lt;&lt; endl;//返回字符串有效字符长度
	cout &lt;&lt; s1.length() &lt;&lt; endl;//返回字符串有效字符长度
	cout &lt;&lt; s1.capacity() &lt;&lt; endl;//返回空间总大小

	s1.clear();//清空有效字符,注意：不释放空间
	cout &lt;&lt; s1.size() &lt;&lt; endl;//返回字符串有效字符长度
	cout &lt;&lt; s1.capacity() &lt;&lt; endl;//返回字符串有效字符长度
	cout &lt;&lt; s1.max_size() &lt;&lt; endl;//返回容器所能容纳的最大元素数量(这个值一般是固定的)
}</code></pre> 
<p><img alt="" height="408" src="https://images2.imgbox.com/67/7a/tks3tA52_o.png" width="678"></p> 
<p></p> 
<h6 id="%E2%9D%93%E6%9D%A5%E5%86%99%E4%B8%80%E9%81%93%E9%A2%98%EF%BC%9A387.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6">❓来写一道题：<a href="https://leetcode.cn/problems/first-unique-character-in-a-string/" rel="nofollow" title="387. 字符串中的第一个唯一字符">387. 字符串中的第一个唯一字符</a></h6> 
<pre><code>class Solution {
public:
    // 定义一个成员函数firstUniqChar，它接收一个字符串s作为参数，并返回一个整数
    // 这个整数代表字符串s中第一个唯一（只出现一次）字符的索引，如果不存在这样的字符，则返回-1
    int firstUniqChar(string s) {
        // 创建一个大小为26的整型数组countA，用于存储'a'到'z'每个字母出现的次数
        int countA[26] = {0};

        // 首先遍历字符串s中的每个字符
        for(auto ch: s)
        {
            // 把当前字符ch转换为其在小写字母表中的相对位置（例如，'a'的位置是0，'b'的位置是1，依此类推）
            // 通过 ch - 'a' 计算得出
            int index = ch - 'a';
            
            // 把该位置的计数值加1，表示这个字母出现了一次
            countA[index]++;
        }

        // 再次遍历字符串s中的每个字符
        for(int i = 0; i &lt; s.size(); ++i)
        {
            // 获取当前字符s[i]在小写字母表中的相对位置
            int index = s[i] - 'a';

            // 检查此字符在countA数组中的计数值是否为1
            // 如果是1，说明这个字符在字符串s中只出现了1次，是唯一的
            if(countA[index] == 1)
            {
                // 返回当前字符s[i]在字符串s中的索引
                return i;
            }
        }

        // 如果遍历完整个字符串都没有找到只出现一次的字符，则返回-1表示不存在这样的字符
        return -1;
    }
};</code></pre> 
<p><img alt="" height="284" src="https://images2.imgbox.com/c0/cf/4GoVP3qT_o.png" width="840"></p> 
<p></p> 
<h5 id="reserve%C2%A0">reserve </h5> 
<p><img alt="" height="372" src="https://images2.imgbox.com/ec/a9/9IZGu8R8_o.png" width="1157"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">1.<strong>如果 n 大于当前字符串容量（capacity），则该函数会导致容器将其容量增加到 n 个字符（或更大）。               --&gt;       也就是扩到n或者&gt;n</strong></span></p> 
 <p><span style="color:#b95514;"><strong>2.在所有其他情况下，它被视为一个非约束性的缩减字符串容量请求：容器实现可以自由优化，保持字符串的容量大于n。</strong></span></p> 
 <p><span style="color:#494949;"><strong>3.此函数对字符串长度没有影响，也无法更改其内容。</strong></span></p> 
 <p><span style="color:#494949;"><strong>(</strong></span><strong>当n小于对象当前的capacity时，什么也不做</strong><span style="color:#494949;"><strong>)</strong></span></p> 
</blockquote> 
<p><span style="color:#494949;"><strong>n大于当前字符串容量的测试:</strong></span></p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/b9/08/2QQrXMJI_o.png" width="929"></p> 
<p><strong>n小于当前字符串的测试：</strong></p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/f0/0c/GhNzc8p5_o.png" width="774"></p> 
<p><span style="color:#333333;"><strong>windows和Linux的增容规则的测试：</strong></span></p> 
<p><strong>1.windows下的增容规则：</strong></p> 
<p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><span style="color:#ff0000;"><strong>        reserve开空间的对比，未使用reserve</strong></span></span></span>：</p> 
<p style="margin-left:0;"><img alt="" height="377" src="https://images2.imgbox.com/38/08/nSMC2YRw_o.png" width="870"></p> 
<blockquote> 
 <p style="margin-left:0;"><strong>可以看到windows下的增容规则大约是<span style="color:#1c7331;">1.5</span>倍的增容</strong></p> 
</blockquote> 
<p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><span style="color:#ff0000;"><strong>        reserve开空间的对比，使用reserve</strong></span></span></span>：</p> 
<p><img alt="" height="456" src="https://images2.imgbox.com/a9/b3/QvIi0eEd_o.png" width="1200"></p> 
<p><span style="color:#be191c;"><strong>                                                        💥reserve的意义： </strong></span></p> 
<blockquote> 
 <p><strong><span style="color:#be191c;">        reserve价值，确定大概知道要多少空间，提前开好，减少扩容，提高效率</span></strong></p> 
</blockquote> 
<p><strong>2.Linux下的增容规则：</strong></p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/c8/6f/wc2BDkoU_o.png" width="584"></p> 
<blockquote> 
 <p><strong>可以看到Linux下的增容规则是<span style="color:#be191c;">2</span>倍增容</strong></p> 
</blockquote> 
<p>测试代码: </p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
void test_string6()//第二次
{
	string s;
	//s.reserve(100);
	size_t old = s.capacity();
	for (size_t i = 0; i &lt; 100; i++)
	{
		s.push_back('x');
		if (s.capacity() != old)
		{
			cout &lt;&lt; "扩容:" &lt;&lt; s.capacity() &lt;&lt; endl;
			old = s.capacity();
		}
	}
	//s.reserve(10);
	cout &lt;&lt; s.capacity() &lt;&lt; endl;
}</code></pre> 
<p></p> 
<h5 id="resize%C2%A0">resize </h5> 
<p><img alt="" height="355" src="https://images2.imgbox.com/e6/cc/OH776QZI_o.png" width="1119"></p> 
<blockquote> 
 <p>1.如果n小于当前字符串的长度，则将当前值缩短为前n个字符，删除第n个字符之后的字符。</p> 
 <p>2.如果n大于当前字符串长度，则扩展当前内容，在字符串末尾插入任意数量的字符，<span style="color:#fe2c24;"><strong>使长度达到n</strong></span>。如果指定了c，则新元素初始化为c的副本，否则为值初始化的字符(空字符) ---&gt; '\0'。</p> 
</blockquote> 
<p>图解: </p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/27/7c/oUL3LkRU_o.png" width="855"></p> 
<p><span style="color:#494949;"><strong>n大于当前字符串长度测试：</strong></span></p> 
<p><span style="color:#1c7331;"><strong>size &lt; resize &lt; capacity   </strong><strong>                             不使用字符参数：</strong></span></p> 
<p><img alt="" height="423" src="https://images2.imgbox.com/66/5b/PA3aFDOG_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>size &lt; resize &lt; capacity                                  使用字符参数:</strong></span></p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/a4/a2/BuauOFfc_o.png" width="1200"></p> 
<p><span style="color:#1c7892;"><strong>resize &gt; capacity      </strong></span><span style="color:#fe2c24;"><strong>                                     </strong></span><span style="color:#1c7892;"><strong>使用字符参数:</strong></span></p> 
<p><img alt="" height="525" src="https://images2.imgbox.com/1c/f2/7koySE5U_o.png" width="1200"></p> 
<p><span style="color:#333333;"><strong>n小于当前字符串长度测试:</strong></span></p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/c4/d3/XN9mQAof_o.png" width="1200"></p> 
<p><strong>对于空字符串，若给出n的值，则会初始化到第n个字符(下标要 -1 )</strong></p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/ff/35/YHpeE4e7_o.png" width="1200"></p> 
<p><strong>测试代码：</strong></p> 
<pre><code>void test_string7()
{
	string s1("hello world");
	cout &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s1.size()&lt;&lt; endl;
	cout &lt;&lt; s1.capacity() &lt;&lt; endl;

	//s1.resize(13);//将size扩到13，原本size是11，剩下的两个字符补'\0'，加上末尾的'\0'(调试看不见)，3个'\0'
	s1.resize(13,'x');//将size扩到13，不够的话补两个'x'
	s1.resize(20, 'x');//补9个x，因为原本size是11+9个'x'是20字符
	cout &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s1.size() &lt;&lt; endl;
	cout &lt;&lt; s1.capacity() &lt;&lt; endl;

	s1.resize(5);//保留五个字符
	cout &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s1.size() &lt;&lt; endl;
	cout &lt;&lt; s1.capacity() &lt;&lt; endl;

	//对于string来说，可能会使用到resize的场景
	string s2;
	s2.resize(10, '#');
	cout &lt;&lt; s2 &lt;&lt; endl;
	cout &lt;&lt; s2.size() &lt;&lt; endl;
	cout &lt;&lt; s2.capacity() &lt;&lt; endl;
}</code></pre> 
<p></p> 
<h5 id="%E4%B8%8B%E6%A0%87%E8%87%AA%E5%A2%9E">at 下标自增</h5> 
<p>两种：①数组 ②at：</p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/91/90/dKLq48Bo_o.png" width="1140"></p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/87/ca/3EO1ltIY_o.png" width="790"></p> 
<p>代码：</p> 
<pre><code>void test_string7()
{
	string s2;
	s2.resize(10, '#');
	cout &lt;&lt; s2 &lt;&lt; endl;
	cout &lt;&lt; s2.size() &lt;&lt; endl;
	cout &lt;&lt; s2.capacity() &lt;&lt; endl;

	//作用是一样的，都是对s2的第一个字符（下标为0的位置）执行自增操作。
	//因为s2的第一个字符是#，其ASCII码值为35，
	//在执行自增后变为ASCII码值36对应的字符，即$。
	s2[0]++;
	s2.at(0)++;//作用和上面是一样的
	cout &lt;&lt; s2 &lt;&lt; endl;
}
int main()
{
	test_string7();
}</code></pre> 
<p></p> 
<p></p> 
<h4 id="D.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%20%C2%A0"><span style="color:#494949;">D.<strong>string类对象的修改操作 </strong> </span></h4> 
<p><img alt="" height="488" src="https://images2.imgbox.com/f8/0b/1vTZa7dc_o.png" width="1065"></p> 
<p><a href="https://gitee.com/ailiangshilove/cpp-class/blob/master/%E8%AF%BE%E4%BB%B6%E4%BB%A3%E7%A0%81/C++%E8%AF%BE%E4%BB%B6V6/string%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%8F%8A%E4%BD%BF%E7%94%A8/TestString.cpp" rel="nofollow" title="​​​​​​string中插入和查找等使用代码演示">​​​​​​string中插入和查找等使用代码演示</a></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#777777;"><strong>注意</strong>： </span></p> 
<blockquote> 
 <p style="margin-left:0;text-align:left;"><strong><span style="color:#777777;">1. </span><span style="color:#777777;">在</span><span style="color:#777777;">string</span><span style="color:#777777;">尾部追加字符时，</span><span style="color:#777777;">s.push_back(c) / s.append(1, c) / s += 'c'</span><span style="color:#777777;">三种的实现方式</span></strong></p> 
 <p style="margin-left:0;text-align:left;"><strong><span style="color:#777777;">差不多，一般情况下</span><span style="color:#777777;">string</span><span style="color:#777777;">类的</span><span style="color:#fe2c24;">+=操作用的比较多</span><span style="color:#777777;">，</span><span style="color:#fe2c24;">+=操作不仅可以连接单个字符，还可以连接字符串。 </span></strong></p> 
 <p style="margin-left:0;text-align:justify;"><strong><span style="color:#777777;">2. </span><span style="color:#777777;">对</span><span style="color:#777777;">string</span><span style="color:#777777;">操作时，如果能够大概预估到放多少字符，可以先通过</span><span style="color:#be191c;">reserve</span><span style="color:#777777;">把空间预留好。</span></strong></p> 
</blockquote> 
<h5 id="push_back%E3%80%81append%E3%80%81%2B%3D%E3%80%81%2B%EF%BC%9A" style="margin-left:0px;text-align:justify;"><strong><span style="color:#777777;">push_back、append、+=、+：</span></strong></h5> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="516" src="https://images2.imgbox.com/ae/53/N97dOfiT_o.png" width="691"></p> 
<p style="margin-left:0;text-align:justify;">代码：</p> 
<pre><code>void test_string8()
{
	string ss("world");// 创建一个字符串ss，初始化为"world"
	string s;// 创建一个新的字符串s，初始为空
	// 使用push_back方法向字符串s的末尾添加单个字符'#'，不是完整的字符串
	s.push_back('#');//添加字符，不是字符串
	s.append("world");// 使用append方法将字符串"world"追加到字符串s的末尾
	s.append(ss);//再次使用append方法将字符串ss（内容也为"world"）追加到字符串s的末尾
	cout &lt;&lt; s &lt;&lt; endl;
	
	// 使用"+"运算符重载，分别将字符 '#' 和字符串 "hello" 追加到字符串s的末尾
	s += '#';
	s += "hello";
	s += ss;
	cout &lt;&lt; s &lt;&lt; endl;

	// 使用"+"运算符重载创建新的字符串对象ret1和ret2
    // 将字符串ss与字符 '#' 连接起来赋值给ret1
	string ret1 = ss + '#';
	// 将字符串ss与字符串 "hello" 连接起来赋值给ret2
	string ret2 = ss + "hello";
	cout &lt;&lt; ret1 &lt;&lt; endl;
	cout &lt;&lt; ret2 &lt;&lt; endl;
}</code></pre> 
<p style="margin-left:0;text-align:justify;"></p> 
<h5 id="assgin" style="margin-left:0px;text-align:justify;">assgin</h5> 
<p><img alt="" height="376" src="https://images2.imgbox.com/91/41/feuBOvuX_o.png" width="1182"></p> 
<p><img alt="" height="458" src="https://images2.imgbox.com/50/e2/VCJHu3Ow_o.png" width="999"></p> 
<pre><code>void test_string9() {
	// 创建一个初始内容为"xxxxxxx"的字符串str
	string str("xxxxxxx");

	// 创建一个基础字符串base，
	string base = "The quick brown fox jumps over a lazy dog.";

	// 使用assign方法将base的全部内容赋给str，替换str原来的内容
	str.assign(base);
	// 输出赋值后str的内容
	cout &lt;&lt; str &lt;&lt; '\n';

	// 第二种用法：使用assign方法从base的第5个字符开始截取10个字符，并将这10个字符赋给str
	str.assign(base, 5, 10);
	// 输出截取并赋值后str的内容
	cout &lt;&lt; str &lt;&lt; '\n';
}</code></pre> 
<p></p> 
<h5 id="insert">insert</h5> 
<p><img alt="" height="430" src="https://images2.imgbox.com/c7/2a/yD4FAgUn_o.png" width="1136"></p> 
<p><img alt="" height="398" src="https://images2.imgbox.com/36/f7/YPCCMMV5_o.png" width="865"></p> 
<pre><code>void test_string10()
{
//接口设计复杂繁多，需要时查一下文档即可
	
	//下面两种写法都是头插 
	string str("hello world");
	str.insert(0,3,'x');//表示在字符串的起始位置插入
	cout &lt;&lt; str &lt;&lt; endl;
	str.insert(str.begin(), '#');
	cout &lt;&lt; str &lt;&lt; endl;

}</code></pre> 
<p></p> 
<h5 id="erase">erase</h5> 
<p><img alt="" height="299" src="https://images2.imgbox.com/7c/31/v8DxXss1_o.png" width="942"></p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/7e/5d/tmi5uW9H_o.png" width="826"></p> 
<pre><code>void test_string10()
{
	string str1("hello world");
	str1.erase(5);//删至5个字符:hello后面的全删掉
	cout &lt;&lt; str1 &lt;&lt; endl;
	
    string str2("hello world");
	str2.erase(5,2);//从第6个位置开始删掉，并删掉下标为6，7的字符
	cout &lt;&lt; str2 &lt;&lt; endl;</code></pre> 
<p></p> 
<h5 id="replace">replace</h5> 
<p><img alt="" height="500" src="https://images2.imgbox.com/9d/94/lGCtZ9e9_o.png" width="1019"></p> 
<p>对于replace来说，<strong>第一个参数传入pos的位置，第二个参数就是你想要替换的字符个数，第三个参数是你想替换的内容</strong></p> 
<p>从以下的示例可以看出：如果第二个参数给多给少都会影响最终打印：<strong>多了就会替换掉原来的字符串，少了就会挪动数据 </strong></p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/7f/aa/3Q7HvR1f_o.png" width="862"></p> 
<p><strong>代码：</strong></p> 
<pre><code>void test_string10()
{
    string s1("hello world");
	s1.replace(5,1,"%%20");
	cout &lt;&lt; s1 &lt;&lt; endl;
	
	string s2("hello world");
	s2.replace(5, 3,"%%20");
	cout &lt;&lt; s2 &lt;&lt; endl;
	
	string s3("hello world");
	s3.replace(5, 4,"%%20");
	cout &lt;&lt; s3 &lt;&lt; endl;
}</code></pre> 
<p><span style="color:#fe2c24;">🚩总结：</span></p> 
<blockquote> 
 <p><strong>insert/erase/replace能不用就尽量不用，因为他们都涉及挪动数据，效率不高<br> 接口设计复杂繁多，需要时查一下文档即可</strong></p> 
</blockquote> 
<p></p> 
<h5 id="swap">swap</h5> 
<p><span style="background-color:#ffd900;">试着思考一下：我们遇到一个字符串，如何把中间的空格替换为20%？</span></p> 
<p></p> 
<p>解决方法：s3遍历s2,遍历期间s3遇到空格替换成20%，其他位置不变，打印s3：</p> 
<p><img alt="" height="590" src="https://images2.imgbox.com/d6/03/wzo73TGo_o.png" width="1200"></p> 
<p>但是再思考一下，我们能不能让s2的字符串也把空格处替换成20%呢？</p> 
<pre><code>//这两个是深拷贝:
	s2 = s3;
	s2.assign(s3);</code></pre> 
<p><strong>可以看到确实s2的空格被替换了，但是这两种写法，无非就是开空间，拷贝数据过去，有没有代价更低的写法呢？ </strong></p> 
<p><img alt="" height="329" src="https://images2.imgbox.com/6f/73/8xEJWlEj_o.png" width="1122"> <strong>这时候我们用到swap，试想一下，以下那种写法更优势呢？</strong></p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/45/ed/zo7K7O1j_o.png" width="483"></p> 
<p>我们去库里面找找看：</p> 
<p>我们可以看到<span style="color:#fe2c24;"><strong>红色框的swap拷贝的代价挺大的，那么</strong></span><span style="color:#ad720d;"><strong>黄色框呢</strong></span></p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/a8/46/4shBSqu1_o.png" width="835"></p> 
<p></p> 
<p>可以看到，<span style="color:#e6b223;"><strong>黄色框里面的swap是可以交换地址的</strong></span>，<strong>拷贝代价不大</strong>：</p> 
<blockquote> 
 <p><img alt="" height="176" src="https://images2.imgbox.com/e1/26/OXBM5oK6_o.png" width="511"></p> 
 <p><img alt="" height="339" src="https://images2.imgbox.com/35/86/kNdKz4v9_o.png" width="1084"></p> 
 <p><img alt="" height="376" src="https://images2.imgbox.com/43/9f/2DtDgpJw_o.png" width="1144"></p> 
</blockquote> 
<p>但是其实编译器<strong>永远不会调到3次深拷贝的swap</strong>，因为本质上由于库的原因，只会去调这个swap</p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/67/6e/jIrsP9QJ_o.png" width="1200"></p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/7a/93/12IC1nd7_o.png" width="1200"></p> 
<p>所以结果是一样的，也是交换地址。</p> 
<p></p> 
<h5 id="c_str">c_str</h5> 
<blockquote> 
 <p><strong>我们去看看c_str 的说明：</strong></p> 
 <p>        返回指向数组的指针，该数组包含以 null 结尾的字符序列（即 C 字符串），表示字符串对象的当前值。</p> 
 <p><img alt="" height="377" src="https://images2.imgbox.com/43/13/94GZmlXP_o.png" width="1200"></p> 
 <p><img alt="" height="411" src="https://images2.imgbox.com/67/e9/N7Jb8drK_o.png" width="1176"> 举例代码：</p> 
 <pre><code>int main() {
	std::string myString = "Hello, World!";

	// 使用 c_str() 获取指向内部C风格字符串的指针
	const char* cStyleString = myString.c_str();

	// 使用 printf 函数打印C风格字符串，需要 %s 格式说明符
	printf("C-style string: %s\n", cStyleString);

	// 或者也可以用 cout 输出，不过需要注意转换为 std::string 才能直接输出
	std::cout &lt;&lt; "As C++ string (using c_str()): " &lt;&lt; std::string(cStyleString) &lt;&lt; std::endl;

	// 注意：不能通过 c_str() 返回的指针去修改字符串的内容，因为它指向的是常量区域

	return 0;
}</code></pre> 
</blockquote> 
<p>演示总代码：</p> 
<pre><code>void test_string10()
{
	//insert/erase/replace能不用就尽量不用，因为他们都涉及挪动数据，效率不高
	//接口设计复杂繁多，需要时查一下文档即可
	
	//下面两种写法都是头插 
	//string str("hello world");
	//str.insert(0,3,'x');//表示在字符串的起始位置插入
	//cout &lt;&lt; str &lt;&lt; endl;
	//str.insert(str.begin(), '#');
	//cout &lt;&lt; str &lt;&lt; endl;

	//str.erase(5);
	//cout &lt;&lt; str &lt;&lt; endl;
	//string str2("hello world");
	//str2.erase(5,2);
	//cout &lt;&lt; str2 &lt;&lt; endl;

	/*string s1("hello world");
	s1.replace(5,1,"%%20");
	cout &lt;&lt; s1 &lt;&lt; endl;
	
	string s2("hello world");
	s2.replace(5, 3,"%%20");
	cout &lt;&lt; s2 &lt;&lt; endl;
	
	string s3("hello world");
	s3.replace(5, 4,"%%20");
	cout &lt;&lt; s3 &lt;&lt; endl;*/

	//空格替换成20%
	string s2("The quick brown fox jumps a lazy dog.");
	string s3;
	for (auto ch : s2)
	{
		if (ch != ' ')
		{
			s3 += ch;
		}
		else
		{
			s3 += "20%";
		}
	}
	//cout &lt;&lt; s2 &lt;&lt; endl;
	//cout &lt;&lt; s3 &lt;&lt; endl;
	//这两个是深拷贝:
	/*s2 = s3;
	s2.assign(s3);
	cout &lt;&lt; s2 &lt;&lt; endl;
	cout &lt;&lt; s3 &lt;&lt; endl;*/
	
	printf("s2：%p\n", s2.c_str());
	printf("s3：%p\n", s3.c_str());

	swap(s2, s3);//这个要调用三次深拷贝
	//s2.swap(s3);

	printf("s2：%p\n", s2.c_str());
	printf("s3：%p\n", s3.c_str());

	cout &lt;&lt; s2 &lt;&lt; endl;
}
</code></pre> 
<p></p> 
<h5 id="find%E3%80%81rfind%E3%80%81substr"><strong>find、rfind、substr</strong></h5> 
<h6 id="find"><strong>find</strong></h6> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">问题：在这个地方，要求取一个文件后缀怎么搞？</span></strong></p> 
</blockquote> 
<p><strong>在字符串中搜索由其参数指定的序列的第一个匹配项。</strong> </p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/61/ba/MEMvd63W_o.png" width="1200"></p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/25/02/V7x1VLh8_o.png" width="964"></p> 
<blockquote> 
 <p><strong>这里我们需要注意find的返回值：用于在当前字符串中查找子串或字符</strong>，<strong>并返回<span style="color:#fe2c24;">其首次出现的位置索引（从0开始）</span></strong>。<strong>如果未找到指定的子串或字符，则返回 <code>std::string::npos</code>，通常表示不可能的位置，即常量 <code>npos</code> 被定义为一个很大的整数值。</strong></p> 
</blockquote> 
<p><img alt="" height="326" src="https://images2.imgbox.com/91/0d/3MGkUPVs_o.png" width="728"></p> 
<pre><code>    string s1("test.cpp.tar.zip");
	size_t i1 = s1.find('.');
	cout &lt;&lt; i1 &lt;&lt; endl;</code></pre> 
<p></p> 
<h6 id="rfind"><strong>rfind</strong></h6> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">问题：假设一个文件里面，假后缀很多，最后那个才是真后缀，怎么取？</span></strong></p> 
</blockquote> 
<p><img alt="" height="473" src="https://images2.imgbox.com/b3/63/NObUbKdy_o.png" width="1200"><img alt="" height="189" src="https://images2.imgbox.com/e0/63/GlcHI8Po_o.png" width="939"></p> 
<blockquote> 
 <p><strong>这里我们需要注意rfind的返回值：</strong></p> 
 <p><strong>在字符串中搜索由其参数指定的序列的<span style="color:#fe2c24;">最后一次出现的位置</span>。</strong></p> 
 <p><strong>如果没有找到匹配项，函数返回string::npos。</strong></p> 
</blockquote> 
<p><img alt="" height="339" src="https://images2.imgbox.com/b3/5a/y5egnbXo_o.png" width="814"></p> 
<pre><code>void test_string11()
{
	string s1("test.cpp.tar.zip");
	size_t i1 = s1.find('.');
	cout &lt;&lt; i1 &lt;&lt; endl;
	
	size_t i2 = s1.rfind('.');
	cout &lt;&lt; i2 &lt;&lt; endl;
}</code></pre> 
<h6 id="substr"><br><strong>substr</strong></h6> 
<blockquote> 
 <p><strong>返回一个新构造的string对象，其值初始化为该对象的子字符串的副本。</strong></p> 
 <p><strong>（如果第二个位置不传入参数，就是有多少取多少，取到字符串结尾。）</strong></p> 
</blockquote> 
<p><img alt="" height="310" src="https://images2.imgbox.com/d2/3b/egpaOlOj_o.png" width="1200"></p> 
<p><img alt="" height="117" src="https://images2.imgbox.com/7b/2d/IY0ReCNZ_o.png" width="553"></p> 
<blockquote> 
 <p><strong>这个函数是取出子串，有两个参数：pos，len，</strong></p> 
 <p><strong>pos指的是索引</strong><strong>，len是可选的长度</strong><strong>，并且它两都有缺省值</strong></p> 
</blockquote> 
<p><strong><span style="color:#fe2c24;">说明：从主串的下标第4的位置开始取，取到主串的末尾 </span></strong></p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/5c/19/HectalvY_o.png" width="801"></p> 
<pre><code>void test_string11()
{
    string s1("test.cpp");
	size_t i1 = s1.find('.');//返回下标4 
	cout &lt;&lt; i1 &lt;&lt; endl;

	string s2 = s1.substr(i1);//从下标位置是4的地方开始取到字符串结尾
	cout &lt;&lt; s2 &lt;&lt; endl;
}</code></pre> 
<p></p> 
<p>我们想要取出<strong>文件名的后缀就需要用到rfind和substr</strong>这两个函数：</p> 
<blockquote> 
 <p><strong>因为最后面的.才是后缀，所以我们需要找最后一个.字符，所以需要用到rfind这个函数</strong></p> 
</blockquote> 
<p><strong>代码测试：</strong></p> 
<pre><code>void test_string11()
{
	string s1("test.cpp.tar.zip");
	size_t i1 = s1.find('.');
	size_t i2 = s1.rfind('.');

	string s2 = s1.substr(i1);
	cout &lt;&lt; s2 &lt;&lt; endl;

	string s3 = s1.substr(i2);
	cout &lt;&lt; s3 &lt;&lt; endl;
}</code></pre> 
<p><img alt="" height="364" src="https://images2.imgbox.com/11/ca/SV8Wpk1C_o.png" width="894"></p> 
<p></p> 
<h5 id="%E5%8F%96%E5%87%BAurl%E5%8D%8F%E8%AE%AE%E3%80%81%E5%9F%9F%E5%90%8D%E3%80%81uri%EF%BC%9A"><strong>取出协议、域名、资源名：</strong></h5> 
<p><strong>图解：</strong></p> 
<p><img alt="" height="744" src="https://images2.imgbox.com/6d/76/cdA59U8m_o.png" width="1200"></p> 
<p>执行： <img alt="" height="452" src="https://images2.imgbox.com/f7/c9/jsypM1W0_o.png" width="1200"> </p> 
<p></p> 
<pre><code>void test_string11()
{
	string s3("https://legacy.cplusplus.com/reference/string/string/rfind/");
	//string s3("ftp://www.baidu.com/?tn=65081411_1_oem_dg");
	// 协议
	// 域名
	// 资源名

	string sub1, sub2, sub3;
	size_t i1 = s3.find(':');// i1 = 5
	if (i1 != string::npos)
		sub1 = s3.substr(0, i1);// substr不会取到下标为i1(5)的元素
	else
		cout &lt;&lt; "没有找到i1" &lt;&lt; endl;
	cout &lt;&lt; sub1 &lt;&lt; endl;

	size_t i2 = s3.find('/', i1 + 3);// 从下标为8的位置开始找元素'/'
	if (i2 != string::npos)
		sub2 = s3.substr(i1 + 3, i2 - (i1 + 3));//8  28-8=20  取20个
	else
		cout &lt;&lt; "没有找到i2" &lt;&lt; endl;
	cout &lt;&lt; sub2 &lt;&lt; endl;
	
	sub3 = s3.substr(i2 + 1);
	cout &lt;&lt; sub3 &lt;&lt; endl;
}</code></pre> 
<p></p> 
<h5 id="find_first_of%20%E5%92%8C%20find_first_not_of">find_first_of 和 find_first_not_of</h5> 
<p><img alt="" height="453" src="https://images2.imgbox.com/16/2d/DVvI0ka4_o.png" width="1200"></p> 
<pre><code>void test_string12()
{
	/*std::string str("Please, replace the vowels in this sentence by asterisks.");
	std::size_t found = str.find_first_not_of("abc");
	while (found != std::string::npos)
	{
		str[found] = '*';
		found = str.find_first_not_of("abcdefg", found + 1);
	}

	std::cout &lt;&lt; str &lt;&lt; '\n';*/

	std::string str("Please, replace the vowels in this sentence by asterisks.");
	std::size_t found = str.find_first_of("abcd");
	while (found != std::string::npos)
	{
		str[found] = '*';
		found = str.find_first_of("abcd", found + 1);
	}

	std::cout &lt;&lt; str &lt;&lt; '\n';

}
</code></pre> 
<p>        string初识篇告一段落，接下来是string的模拟实现。</p> 
<p></p> 
<blockquote> 
 <p>🔧本文修改次数：1</p> 
 <p>📌修改原因：</p> 
 <p>①完善文章知识点：swap、c_str、find、rfind、substr</p> 
 <p>②完善文章知识点：取出协议、域名、资源名</p> 
 <p>        </p> 
 <p>🧭更新时间：</p> 
 <p>①2024年3月19日</p> 
 <p>②2024年3月27日</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/572f1a1d2b07a4a5855e6d7b636eaf5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高阶数据结构 ＜红黑树＞</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2fca639658358126650d9b1dc2d90df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决Python因卸载不彻底,产生卸载,安装时出现的0x80070643问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>