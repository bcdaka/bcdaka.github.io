<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络八股文 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/18d9d3654a0c152d858325b3747782a8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="计算机网络八股文">
  <meta property="og:description" content="计算机网络体系架构？ OSI结构：理论上的 7应用层：定义了应用进程间通信和交互的规则，常见协议有HTTP、SFTP、DNS、WebSocket6表示层：数据的表示、安全、压缩。确保一个系统的应用层所发消息能被另一个系统的应用层读取。GIF、JEPG5会话层：建立、管理、终止会话，是用户应用程序和网络之间的接口。RPC、SQL4传输层：提供源端和目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供了逻辑通信。TCP、UDP、SSH3网络层：将网络地址翻译成对应的物理地址，实现不同网络之间的路径选择，寻址，路由。ICMP、IGMP、IP等2数据链路层：在物理层提供比特流服务的基础上、建立像零件点之间的数据链路。1物理层：建立、维护、断开物理连接。TCP/IP结构：实际上的 应用 传输 网络 链路层五层结构：为了介绍原理而折中的，在这个基础上层层包装层层拆包 DNS的迭代查询和递归查询？ 递归查询举例：
客户端想要解析 www.example.com 的IP地址，发送请求到本地DNS解析器：
本地解析器查询根DNS服务器。
根DNS服务器返回 .com TLD服务器地址。
本地解析器查询 .com TLD服务器。
.com TLD服务器返回 example.com 的权威DNS服务器地址。
本地解析器查询 example.com 的权威DNS服务器。
权威DNS服务器返回 www.example.com 的IP地址。
本地解析器将IP地址返回给客户端。
迭代查询举例：
客户端想要解析 www.example.com 的IP地址，依次查询各个DNS服务器：
客户端查询本地DNS解析器。
本地解析器查询根DNS服务器。
根DNS服务器返回 .com TLD服务器地址。
本地解析器将 .com TLD服务器地址返回给客户端。
客户端查询 .com TLD服务器。
.com TLD服务器返回 example.com 的权威DNS服务器地址。
客户端查询 example.com 的权威DNS服务器。
权威DNS服务器返回 www.example.com 的IP地址。
客户端获取到IP地址。
结论
递归查询和迭代查询是DNS查询的两种方式，各有优缺点。递归查询对客户端友好，但增加了DNS解析器的负担；迭代查询对解析器负担小，但增加了客户端的复杂性。实际应用中，客户端通常会使用递归查询，通过本地DNS解析器处理大部分的查询过程。
DNS解析过程？ 常见端口： 21：FTP22：SSH53：DNS解析80：HTTP443：HTTPS1080：sockets3306：mysql 常见状态码： 1XX：临时的响应，客户端应继续请求。2XX：请求已成功被服务器接收。3XX：用来重定向。4XX：请求可能出错。5XX：服务器在尝试处理请求时发生了错误。 404：表示客户端（如浏览器）请求的资源在服务器上不存在
GET和POST的区别？ 传参方式不同，一个在URL一个在请求体幂等性GET大部分都被CDN缓存起来了 HTTP报文结构？ 请求报文： 报文首部 请求行请求首部字段通用首部字段实体首部字段 GET /index.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-04T02:15:24+08:00">
    <meta property="article:modified_time" content="2024-07-04T02:15:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络八股文</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>计算机网络体系架构？</h4> 
<ul><li><span style="color:#fe2c24;">OSI结构</span>：理论上的 
  <ul><li>7应用层：定义了<span style="color:#fe2c24;">应用进程间通信和交互的规则</span>，常见协议有HTTP、SFTP、DNS、WebSocket</li><li>6表示层：数据的表示、安全、压缩。<span style="color:#fe2c24;">确保一个系统的应用层所发消息能被另一个系统的应用层读取</span>。GIF、JEPG</li><li>5会话层：建立、管理、终止会话，是<span style="color:#fe2c24;">用户应用程序和网络之间的接口</span>。RPC、SQL</li><li>4传输层：提供<span style="color:#fe2c24;">源端和目的端之间提供可靠的透明数据传输</span>，传输层协议为不同主机上运行的进程提供了逻辑通信。TCP、UDP、SSH</li><li>3网络层：将网络地址翻译成对应的物理地址，实现不同网络之间的路径选择，寻址，路由。ICMP、IGMP、IP等</li><li>2数据链路层：在物理层提供比特流服务的基础上、建立像零件点之间的数据链路。</li><li>1物理层：建立、维护、断开物理连接。</li></ul></li><li><span style="color:#fe2c24;">TCP/IP结构</span>：实际上的 应用 传输 网络 链路层</li><li><span style="color:#fe2c24;">五层结构</span>：为了介绍原理而折中的，在这个基础上层层包装层层拆包</li></ul> 
<h4>DNS的迭代查询和递归查询？</h4> 
<p><span style="color:#333333;">递归查询举例：</span></p> 
<p><span style="color:#333333;">客户端想要解析 <code>www.example.com</code> 的IP地址，发送请求到本地DNS解析器：</span></p> 
<ol><li> <p><span style="color:#333333;">本地解析器查询根DNS服务器。</span></p> </li><li> <p><span style="color:#333333;">根DNS服务器返回 .com TLD服务器地址。</span></p> </li><li> <p><span style="color:#333333;">本地解析器查询 .com TLD服务器。</span></p> </li><li> <p><span style="color:#333333;">.com TLD服务器返回 <code>example.com</code> 的权威DNS服务器地址。</span></p> </li><li> <p><span style="color:#333333;">本地解析器查询 <code>example.com</code> 的权威DNS服务器。</span></p> </li><li> <p><span style="color:#333333;">权威DNS服务器返回 <code>www.example.com</code> 的IP地址。</span></p> </li><li> <p><span style="color:#333333;">本地解析器将IP地址返回给客户端。</span></p> </li></ol> 
<p><span style="color:#333333;">迭代查询举例：</span></p> 
<p><span style="color:#333333;">客户端想要解析 <code>www.example.com</code> 的IP地址，依次查询各个DNS服务器：</span></p> 
<ol><li> <p><span style="color:#333333;">客户端查询本地DNS解析器。</span></p> </li><li> <p><span style="color:#333333;">本地解析器查询根DNS服务器。</span></p> </li><li> <p><span style="color:#333333;">根DNS服务器返回 .com TLD服务器地址。</span></p> </li><li> <p><span style="color:#333333;">本地解析器将 .com TLD服务器地址返回给客户端。</span></p> </li><li> <p><span style="color:#333333;">客户端查询 .com TLD服务器。</span></p> </li><li> <p><span style="color:#333333;">.com TLD服务器返回 <code>example.com</code> 的权威DNS服务器地址。</span></p> </li><li> <p><span style="color:#333333;">客户端查询 <code>example.com</code> 的权威DNS服务器。</span></p> </li><li> <p><span style="color:#333333;">权威DNS服务器返回 <code>www.example.com</code> 的IP地址。</span></p> </li><li> <p><span style="color:#333333;">客户端获取到IP地址。</span></p> </li></ol> 
<p><span style="color:#333333;">结论</span></p> 
<p><span style="color:#333333;">递归查询和迭代查询是DNS查询的两种方式，各有优缺点。递归查询对客户端友好，但增加了DNS解析器的负担；迭代查询对解析器负担小，但增加了客户端的复杂性。实际应用中，客户端通常会使用递归查询，通过本地DNS解析器处理大部分的查询过程。</span></p> 
<h4><span style="color:#333333;">DNS解析过程？</span></h4> 
<p><img alt="" height="719" src="https://images2.imgbox.com/b1/b2/90lpF6VQ_o.png" width="1080"></p> 
<h4>常见端口：</h4> 
<ul><li>21：FTP</li><li>22：SSH</li><li>53：DNS解析</li><li>80：HTTP</li><li>443：HTTPS</li><li>1080：sockets</li><li>3306：mysql</li></ul> 
<h4>常见状态码：</h4> 
<ul><li>1XX：临时的响应，客户端应继续请求。</li><li>2XX：请求已成功被服务器接收。</li><li>3XX：用来重定向。</li><li>4XX：请求可能出错。</li><li>5XX：服务器在尝试处理请求时发生了错误。</li><li><img alt="" height="776" src="https://images2.imgbox.com/f3/01/K1b46PA9_o.png" width="629"></li><li> <p>404：表示客户端（如浏览器）请求的资源在服务器上不存在</p> </li></ul> 
<h4>GET和POST的区别？</h4> 
<ul><li>传参方式不同，一个在URL一个在请求体</li><li>幂等性</li><li>GET大部分都被CDN缓存起来了</li></ul> 
<h4>HTTP报文结构？</h4> 
<ul><li>请求报文： 
  <ul><li>报文首部 
    <ul><li>请求行</li><li>请求首部字段</li><li>通用首部字段</li><li>实体首部字段</li></ul></li><li> <pre><code class="language-html">GET /index.html HTTP/1.1
Host: www.javabetter.cn
Accept: text/html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3
</code></pre> </li><li>报文主体</li></ul></li><li>响应报文 
  <ul><li>报文首部 
    <ul><li>状态行</li><li>响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li></ul></li><li> <pre><code class="language-html">HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84
&lt;html&gt;
  &lt;body&gt;沉默王二很天真&lt;/body&gt;
&lt;/html&gt;
</code></pre> </li><li>报文主体</li></ul></li></ul> 
<h4 id="_14-uri-和-url-有什么区别">URI 和 URL 有什么区别?</h4> 
<ul><li>URI，统一资源标识符(Uniform Resource Identifier， URI)</li><li>URL，统一资源定位符（Uniform Resource Location），它是 URI 的一种子集，主要作用是提供资源的路径。</li></ul> 
<h4>HTTP 1-3的区别？</h4> 
<ul><li>1.0 
  <ul><li>无状态协议</li><li>非持久连接，可设置Connection:keep-alive强制开启长连接</li></ul></li><li>1.1： 
  <ul><li>持久连接</li><li>支持在前一个响应到达之前发送下一个</li></ul></li><li>队头阻塞问题：如果第一个响应阻塞了，那么即使后面的响应准备好了也发不出去</li><li>2.0： 
  <ul><li>采用二进制协议，所以grpc基于2.0的话传递的时候是通过byteArray实现的，以前的是文本</li><li>多路复用，一个TCP连接上进行多个HTTP请求或者相应，多个请求分解成独立的帧，交错发送，<span style="color:#fe2c24;">减轻了</span>HTTP 1.x的队头阻塞问题，还是依赖顺序的</li><li>头部压缩，减少带宽消耗，表示层实现gzip压缩</li></ul></li><li>3.0： 
  <ul><li>3.0 基于 QUIC 协议，Quick UDP Connections</li><li>真正实现了不同的流之间独立传输，2.0仍然需要保证顺序</li><li>在传输过程就完成了TLS三次握手</li><li>如何保证可靠性 
    <ul><li>内置的前向纠错和重传 
      <ul><li>编码：堆原始数据通过特定的编码算法进行编码生成纠错码</li><li>传输：连同纠错码一起发送</li><li>解码：接收到数据后解码并纠正，恢复原始数据</li><li>前向纠错会增加带宽需求，高效的重传才是主要的SACK，快速重传</li></ul></li><li>流量控制和拥塞控制</li></ul></li></ul></li></ul> 
<h4>HTTP长连接相关参数：</h4> 
<ul><li>keep-alive</li><li>keep-alive timeout</li><li>TCP中也有三个参数，闲置多久之后就会间隔一个时间发送侦测包，发生这么多次没有响应就断开连接</li></ul> 
<h4>HTTP和HTTPS</h4> 
<ul><li>在HTTP的基础上加入了SSL（安全套接字）/TLS（传输层安全）协议，确保传输过程是加密的。</li><li>解决了什么问题： 
  <ul><li>安全问题</li><li><img alt="" height="614" src="https://images2.imgbox.com/76/df/m3337H7L_o.png" width="914"></li><li>TLS握手： 
    <ul><li>客户端相服务器发送ClientHello消息，包括支持的TLS版本、随机数等等</li><li>服务器回应ServerHello，选择一个客户端提议的版本，并发送数字证书</li><li>客户端验证证书的合法性，生成一个对话密钥通过公钥加密后发送给服务器</li><li>服务器私钥解密得到对话密钥</li><li>加密通信</li></ul></li><li>涉及到了对称加密和非对称加密 
    <ul><li>握手阶段密钥交换就是非对称</li><li>传输就是对称</li></ul></li></ul></li></ul> 
<h4>TCP的流量控制：</h4> 
<ul><li>三次握手协商窗口大小，单位是字节，最大是(2^16-1)&lt;&lt;14有个窗口扩展选项，大概1G</li><li>会约定每次最多能发多少</li><li>接收方窗口 
  <ul><li><img alt="" height="348" src="https://images2.imgbox.com/1a/69/kRgAWMMi_o.png" width="981"></li></ul></li><li>发送方窗口 
  <ul><li><img alt="" height="437" src="https://images2.imgbox.com/d1/75/PuF6qIwH_o.png" width="1052"></li></ul></li></ul> 
<h4>拥塞控制：</h4> 
<ul><li>避免出现拥堵时，发送方的数据填满整个网络</li><li>发送方维护一个cwnd，发送窗口的值是cwnd和滑动窗口可以接收窗口的min，这里单位是MSS</li><li>慢启动： 
  <ul><li>探测网络拥堵情况，每收到一个ACK，cwnd+1，单位是MSS，呈指数递增</li></ul></li><li>拥塞避免： 
  <ul><li>当cwnd到达慢启动阈值sshresh，进入拥塞避免</li><li>每收到一个ACK，cwnd=cwnd+1/cwnd，每个RTT就是+1</li></ul></li><li>拥塞发生： 
  <ul><li> <h4>如果是RTO超时重传</h4> 
    <ul><li>sshresh=cwnd/2</li><li>cwnd=1</li><li>进去慢启动</li></ul></li><li>如果是快速重传 
    <ul><li>cwnd=cwnd/2</li><li>sshresh=cwnd</li><li>进入快速恢复</li></ul></li></ul></li><li>快速恢复 
  <ul><li>快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。</li><li>cwnd和sshresh已经被更新了</li><li>cwnd=sshresh+3，重传重复的那几个ACK，即丢失的那几个数据包</li><li>再收到重复的cwnd=cwnd+1</li><li>新的的话，cwnd=sshresh，再次进入拥塞避免</li></ul></li></ul> 
<h4>TCP的超时重传机制？</h4> 
<ul><li>RTO，一定时间内没收到ACK，就触发，这个时间有算法</li><li>快速重传，发送的数据有序列号，保证有序<img alt="" height="689" src="https://images2.imgbox.com/cc/90/JCR5hK8m_o.png" width="821"><p><span style="color:#333333;">在上图，发送⽅发出了 1，2，3，4，5 份数据：</span></p> </li><li><span style="color:#333333;">第⼀份 Seq1 先送到了，于是就 Ack 回 2；</span></li><li><span style="color:#333333;">结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</span></li><li><span style="color:#333333;">后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</span></li><li><span style="color:#333333;">发送端收到了三个 <strong>Ack = 2</strong> 的确认，知道了 <strong>Seq2</strong> 还没有收到，就会在定时器过期之前，重传丢失的 <strong>Seq2</strong>。</span></li><li><span style="color:#333333;">最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</span></li><li><span style="color:#333333;">SACK，带确认的，ACK是说从左往右第一个开始没数据的空白</span><img alt="" height="582" src="https://images2.imgbox.com/c9/9f/Tvzu4gLl_o.png" width="965"></li><li>D-SACK：告诉发送方哪些报文重复接收了，比如ACK没有到达，发送方重传了<img alt="" height="609" src="https://images2.imgbox.com/ba/ff/R4Q8Rtta_o.png" width="938"></li><li>ACK（Acknowledgment）号在TCP中代表的是接收方期望从发送方接收到的下一个字节的序列号。</li><li>SACK一个代表在快速重传的时候接收到了哪些</li><li>一个代表了重复接收了哪些，在发送方没有收到ACK的情况重发的情况下</li></ul> 
<h4>TCP和UDP的区别？</h4> 
<ul><li>可靠性：校验和、序列号、ack，RTO，快速等等</li><li>传输形式（前者字节流，后者数据段报文）</li><li>传输效率：UDP不确认，不重传，没有超时，没有序列号，没有流量控制和拥塞控制，但是QUIC实现了</li><li>所需资源</li><li>首部字节20-60，UDP8个</li><li>面向连接</li></ul> 
<h4>IP协议的定义和作用？</h4> 
<ul><li>定义数据包的格式和处理规则</li><li>作用： 
  <ul><li>寻址</li><li>路由</li><li>分片和重组</li></ul></li></ul> 
<h4>ICMP协议的功能？</h4> 
<ul><li>面向无连接的协议，用于传输出错报告控制信息</li><li>包括报告错误、状态信息等</li><li>当遇到IP无法访问，会自动发送ICMP</li></ul> 
<h4>ping的原理？</h4> 
<ul><li><span style="color:#0d0016;">一个网络工具，主要用来测试网络连接的可达性和延迟。</span></li><li> <p><span style="color:#0d0016;">Ping 的过程主要基于 ICMP（Internet Control Message Protocol，互联网控制消息协议）实现，其基本过程包括：</span></p> <p><span style="color:#0d0016;">①、当执行 Ping 命令，如<code>ping javabetter.cn</code>，Ping 首先解析域名获取 IP 地址，然后向目标 IP 发送一个 ICMP Echo Request 消息。</span></p> <p><span style="color:#0d0016;">②、当目标 IP 收到 ICMP Echo Request 消息后，它会生成一个 ICMP Echo Reply 消息并返回，即 Ping 响应消息。</span></p> <p><span style="color:#0d0016;">③、发起 Ping 命令的设备接收到 ICMP Echo Reply 消息后，计算并显示从发送 Echo Request 到</span><span style="color:#fe2c24;">接收到 Echo Reply 的时间（通常称为往返时间 RTT，Round-Trip Time），以及可能的丢包情况。</span></p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b06ffcdacf9e64776acdfeec490f6cdc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows上安装Frida环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6745531f83ca1e91f9c4d4e03f9ddb1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">20240704 每日AI必读资讯</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>