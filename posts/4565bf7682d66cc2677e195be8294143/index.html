<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;初阶学习第五弹——类与对象（下） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4565bf7682d66cc2677e195be8294143/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;初阶学习第五弹——类与对象（下）">
  <meta property="og:description" content="类与对象（上）：C&#43;&#43;初阶学习第三弹——类与对象（上）-CSDN博客
类和对象（中）：C&#43;&#43;初阶学习第四弹——类与对象（中）-CSDN博客
一.赋值运算符重载 目录
一.赋值运算符重载
1.1 运算符重载
1.2 赋值运算符重载
二.构造函数进阶 2.1构造函数体赋值
1.2 初始化列表
1.3 explicit关键字
三.static成员
四.友元
1.1友元函数
1.2 友元类
1.3 内部类
1.1 运算符重载 C&#43;&#43;为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其 返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。
函数名字为：关键字operator后面接需要重载的运算符符号。
函数原型：返回值类型 operator操作符(参数列表)
注意：
1.不能通过连接其他符号来创建新的操作符：比如operator@ 2.重载操作符必须有一个类类型参数
3.用于内置类型的运算符,其含义不能改变，例如：内置的整型&#43;，不 能改变其含义作为类
4.成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this 5. .* :: sizeof ?: . 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。
1.2 赋值运算符重载 1. 赋值运算符重载格式 参数类型：const T&amp;，传递引用可以提高传参效率 2.返回值类型：T&amp;，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值
3.检测是否自己给自己赋值 4.返回*this ：要复合连续赋值的含义
二.构造函数进阶 2.1构造函数体赋值 在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。
class Date { public: Date(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; int main() { Date d1(); return 0; } 虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称为对对象中成员变量 的初始化，构造函数体中的语句只能将其称为赋初值，而不能称作初始化。因为初始化只能初始 化一次，而构造函数体内可以多次赋值。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T22:14:34+08:00">
    <meta property="article:modified_time" content="2024-08-02T22:14:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;初阶学习第五弹——类与对象（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>类与对象（上）：<a href="https://blog.csdn.net/2302_81257639/article/details/140700619?spm=1001.2014.3001.5501" title="C++初阶学习第三弹——类与对象（上）-CSDN博客">C++初阶学习第三弹——类与对象（上）-CSDN博客</a></p> 
<p>类和对象（中）：<a href="https://blog.csdn.net/2302_81257639/article/details/140726725?spm=1001.2014.3001.5501" title="C++初阶学习第四弹——类与对象（中）-CSDN博客">C++初阶学习第四弹——类与对象（中）-CSDN博客</a></p> 
<p> </p> 
<h3 id="%E4%B8%80.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">一.赋值运算符重载</h3> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%E4%B8%80.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">一.赋值运算符重载</a></p> 
<p id="1.1%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#1.1%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">1.1 运算符重载</a></p> 
<p id="1.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#1.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">1.2 赋值运算符重载</a></p> 
<p id="%E4%BA%8C.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%C2%A0" rel="nofollow">二.构造函数进阶 </a></p> 
<p id="2.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC-toc" style="margin-left:80px;"><a href="#2.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC" rel="nofollow">2.1构造函数体赋值</a></p> 
<p id="1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-toc" style="margin-left:80px;"><a href="#1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8" rel="nofollow">1.2 初始化列表</a></p> 
<p id="%C2%A01.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#%C2%A01.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow"> 1.3 explicit关键字</a></p> 
<p id="%E4%B8%89.static%E6%88%90%E5%91%98-toc" style="margin-left:40px;"><a href="#%E4%B8%89.static%E6%88%90%E5%91%98" rel="nofollow">三.static成员</a></p> 
<p id="%E5%9B%9B.%E5%8F%8B%E5%85%83-toc" style="margin-left:40px;"><a href="#%E5%9B%9B.%E5%8F%8B%E5%85%83" rel="nofollow">四.友元</a></p> 
<p id="1.1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0" rel="nofollow">1.1友元函数</a></p> 
<p id="1.2%C2%A0%20%E5%8F%8B%E5%85%83%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.2%C2%A0%20%E5%8F%8B%E5%85%83%E7%B1%BB" rel="nofollow">1.2  友元类</a></p> 
<p id="1.3%C2%A0%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.3%C2%A0%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">1.3 内部类</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="1.1%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">1.1 运算符重载</h4> 
<blockquote> 
 <p>C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其 返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</p> 
</blockquote> 
<p>函数名字为：关键字operator后面接需要重载的运算符符号。</p> 
<p>函数原型：返回值类型 operator操作符(参数列表)</p> 
<blockquote> 
 <p>注意：</p> 
 <p><strong>1.不能通过连接其他符号来创建新的操作符：比如operator@ </strong></p> 
 <p><strong>2.重载操作符必须有一个类类型参数</strong></p> 
 <p><strong>3.用于内置类型的运算符,其含义不能改变，例如：内置的整型+，不 能改变其含义作为类</strong></p> 
 <p><strong>4.成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this </strong></p> 
 <p><strong>5.   .* :: sizeof ?: . 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。</strong></p> 
</blockquote> 
<h4 id="1.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">1.2 赋值运算符重载</h4> 
<blockquote> 
 <p><strong>1. 赋值运算符重载格式 参数类型：const T&amp;，传递引用可以提高传参效率 </strong></p> 
 <p><strong>2.返回值类型：T&amp;，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值</strong></p> 
 <p><strong>3.检测是否自己给自己赋值 </strong></p> 
 <p><strong>4.返回*this ：要复合连续赋值的含义</strong></p> 
</blockquote> 
<h3 id="%E4%BA%8C.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%C2%A0">二.构造函数进阶 </h3> 
<h4 id="2.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC">2.1构造函数体赋值</h4> 
<p>在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。</p> 
<pre><code class="language-cpp">class Date
{
public:
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1();
	return 0;
}</code></pre> 
<p>虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称为对对象中成员变量 的初始化，构造函数体中的语句只能将其称为赋初值，而不能称作初始化。因为初始化只能初始 化一次，而构造函数体内可以多次赋值。</p> 
<h4 id="1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">1.2 初始化列表</h4> 
<blockquote> 
 <p><strong>初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟 一个放在括号中的初始值或表达式。</strong></p> 
</blockquote> 
<pre><code class="language-cpp">class Date
{
public:
	Date(int year, int month, int day)
		:_year(year),
		_month(month),
		_day(day)
	{
 
	}	
private:
	int _year;
	int _month;
	int _day;
};</code></pre> 
<p>不过要注意的是</p> 
<blockquote> 
 <p><strong>1. 每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)</strong></p> 
 <p><strong>2. 类中包含以下成员，必须放在初始化列表位置进行初始化：</strong></p> 
 <p><strong>引用成员变量</strong></p> 
 <p><strong>const成员变量 </strong></p> 
 <p><strong>自定义类型成员(且该类没有默认构造函数时)</strong></p> 
</blockquote> 
<pre><code class="language-cpp">class A
{
public:
	A(int a)
		:_a(a)
	{}
private:
	int _a;
};
class B
{
public:
	B(int a, int ref)
		:_aobj(a)
		, _ref(ref)
		, _n(10)
	{}
private:
	A _aobj; // 没有默认构造函数
	int&amp; _ref; // 引用
	const int _n; // const 
};</code></pre> 
<h4 id="%C2%A01.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97"> 1.3 explicit关键字</h4> 
<p>对于接受单个参数的构造函数，构造函数不仅可以构造与初始化对象，还具有类型转换的作用。</p> 
<blockquote> 
 <p><strong>1、构造函数只有一个参数</strong></p> 
 <p><strong>2、构造函数有多个参数，但是只有一个没有默认值</strong></p> 
</blockquote> 
<pre><code class="language-cpp">class Date
{
public:
	// 1. 单参构造函数，没有使用explicit修饰，具有类型转换作用
	// explicit修饰构造函数，禁止类型转换---explicit去掉之后，代码可以通过编译
	explicit Date(int year)
		:_year(year)
	{}
	/*
	// 2. 虽然有多个参数，但是创建对象时后两个参数可以不传递，没有使用explicit修饰，具有类型转
   换作用
	// explicit修饰构造函数，禁止类型转换
	explicit Date(int year, int month = 1, int day = 1)
	: _year(year)
	, _month(month)
	, _day(day)
	{}
	*/
	Date&amp; operator=(const Date&amp; d)
	{
		if (this != &amp;d)
		{
			_year = d._year;
			_month = d._month;
			_day = d._day;
		}
		return *this;
	}
private:
	int _year;
	int _month;
	int _day;
};
void Test()
{
	Date d1(2022);
	// 用一个整形变量给日期类型对象赋值
	// 实际编译器背后会用2023构造一个无名对象，最后用无名对象给d1对象进行赋值
	d1 = 2023;
	// 将1屏蔽掉，2放开时则编译失败，因为explicit修饰构造函数，禁止了单参构造函数类型转换的作
//	用
}</code></pre> 
<h3 id="%E4%B8%89.static%E6%88%90%E5%91%98"><br> 三.static成员</h3> 
<p><strong>用static修饰的成员变量就是类中的静态成员变量，用static修饰的成员函数就是静态成员函数</strong></p> 
<p><strong>我们需要注意的是静态成员变量一定要在类外进行初始化</strong></p> 
<pre><code class="language-cpp">class A
{
private:
	static int _a;
};
 
//在类外对_a进行初始化
int A::_a = 0;
 
int main()
{
	return 0;
}</code></pre> 
<p><strong>1、静态成员存放在静态区，为所有类成员共享</strong></p> 
<p><strong>2、静态成员必须在类外定义（初始化），类中只是声明</strong></p> 
<p><strong>3、静态成员访问方式：类名：：静态成员或者对象.静态成员</strong></p> 
<h3 id="%E5%9B%9B.%E5%8F%8B%E5%85%83">四.友元</h3> 
<h4 id="1.1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">1.1友元函数</h4> 
<blockquote> 
 <p>友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以 友元不宜多用。 <span style="background-color:#38d8f0;">友元分为：友元函数和友元类</span></p> 
</blockquote> 
<p>问题：现在尝试去重载operator&lt;&lt;，然后发现没办法将operator&lt;&lt;重载成成员函数。<span style="background-color:#38d8f0;">因为cout的输出流对象和隐含的this指针在抢占第一个参数的位置。this指针默认是第一个参数也就是左操作 数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。</span>所以要将operator&lt;&lt;重载成 全局函数。但又会导致类外没办法访问成员，此时就需要友元来解决。</p> 
<pre><code class="language-cpp">class Date
{
public:
Date(int year, int month, int day)
     : _year(year)
     , _month(month)
     , _day(day)
 {}

// d1 &lt;&lt; cout; -&gt; d1.operator&lt;&lt;(&amp;d1, cout); 不符合常规调用
// 因为成员函数第一个参数一定是隐藏的this，所以d1必须放在&lt;&lt;的左侧
ostream&amp; operator&lt;&lt;(ostream&amp; _cout)
 {
     _cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
     return _cout;
 }
private:
int _year;
int _month;
int _day;
};</code></pre> 
<blockquote> 
 <p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。</p> 
</blockquote> 
<pre><code class="language-cpp">class Date
{
	friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);
	friend istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d);
public:
	Date(int year = 1900, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}
 
private:
	int _year;
	int _month;
	int _day;
};
ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)
{
	_cout &lt;&lt; d._year &lt;&lt; "-" &lt;&lt; d._month &lt;&lt; "-" &lt;&lt; d._day;
	return _cout;
}
istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d)
{
	_cin &gt;&gt; d._year;
	_cin &gt;&gt; d._month;
	_cin &gt;&gt; d._day;
	return _cin;
}
int main()
{
	Date d;
	cin &gt;&gt; d;
	cout &lt;&lt; d &lt;&lt; endl;
	return 0;
}</code></pre> 
<p> 友元函数的说明：</p> 
<blockquote> 
 <p><strong>友元函数可访问类的私有和保护成员，但不是类的成员函数 、</strong></p> 
 <p><strong>友元函数不能用const修饰 </strong></p> 
 <p><strong>友元函数可以在类定义的任何地方声明，不受类访问限定符限制 </strong></p> 
 <p><strong>一个函数可以是多个类的友元函数</strong></p> 
 <p><strong>友元函数的调用与普通函数的调用原理相同</strong></p> 
</blockquote> 
<h4 id="1.2%C2%A0%20%E5%8F%8B%E5%85%83%E7%B1%BB">1.2  友元类</h4> 
<blockquote> 
 <p><strong>友元类跟上面的友元函数很想，也是间接访问一个类中私有化成员的一种方法，友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。</strong></p> 
</blockquote> 
<pre><code class="language-cpp">class Time
{
	friend class Date;     //声明Date为友元类
private:
	int _hour;
	int _min;
};
class Date
{
public:
	void test(int hour, int min)
	{
		_t._hour = hour;       //可以在Date类中直接引用Time类私有成员变量
		_t._min = min;
	}
private:
	int _year;
	int _month;
	int _day;
	Time _t;
};</code></pre> 
<h4 id="1.3%C2%A0%E5%86%85%E9%83%A8%E7%B1%BB">1.3 内部类</h4> 
<blockquote> 
 <p><strong>如果一个类定义在另一个类的内部，这个内部类就叫做内部类。内部类是一个独立的类， 它不属于外部类，更不能通过外部类的对象去访问内部类的成员。外部类对内部类没有任何优越 的访问权限。</strong></p> 
</blockquote> 
<p> 总结：</p> 
<blockquote> 
 <p><strong>1、内部类和外部类实际上还是两个完全独立的类，完全可以将它们两个分开写</strong></p> 
 <p><strong>2、内部类是外部类的友元类，可以访问外部类的私有成员，但外部类不是内部类的友元类</strong></p> 
 <p><strong>3、内部类可以直接访问外部类的静态成员，不需要外部类的对象名或者类名</strong></p> 
</blockquote> 
<pre><code class="language-cpp">class A
{
private:
 static int k;
 int h;
public:
 class B // B天生就是A的友元
 {
 public:
 void foo(const A&amp; a)
 {
 cout &lt;&lt; k &lt;&lt; endl;//OK
 cout &lt;&lt; a.h &lt;&lt; endl;//OK
 }
 };
};
int A::k = 1;
int main()
{
    A::B b;
    b.foo(A());
    
    return 0;
}
</code></pre> 
<p> 感谢大佬支持，关于类和对象的知识目前就先讲到这里，如果有疑问或者是不对的地方，请大佬们指出。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70ff578656b7af1618fb737006a918d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA常用设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/007e6894498d66a9b021b87f416c6ff9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">死锁的概念</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>