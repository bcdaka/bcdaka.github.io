<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot统一功能处理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/01485598978658a65702eb1ffa20c78d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="SpringBoot统一功能处理">
  <meta property="og:description" content="目录
一、统一数据返回格式
测试
二、存在问题
解决方案
案例代码修改
三、统一功能的优点
四、统一异常处理
五、案例代码（图书管理系统）
1、login.html
2、book_update.html
3、book_add.html
4、book_list.html
六、总结
上一篇博客使用了拦截器，强制登录案例做了两步：1、通过Session来判断用户是否登录；2、如果未登录，对后端返回数据进行封装，告知前端处理的结果。
但是因为刚开始的图书管理系统的接口返回的不是Result类，我们现在想把后端接口返回的类型都改成Result，那么就可以使用SpringBoot的第二个统一功能处理。
一、统一数据返回格式 统一的数据返回格式使用 @ControllerAdvice 和 实现ResponseBodyAdvice接口 的方式实现，@ControllerAdvice 表示控制器通知类。
添加类 ResponseAdvice，实现 ResponseBodyAdvice 接口，并在类上添加 @ControllerAdvice 注解，代码如下：
@ControllerAdvice public class ResponseAdvice implements ResponseBodyAdvice { @Override public boolean supports(MethodParameter returnType, Class converterType) { return true; } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { return Result.success(body); } } supports() 方法：判断是否要执行 beforeBodyWrite 方法。true 为执行，false为不执行。通过该方法可以选择哪些类或哪些方法的 response 要进行处理，其他的不进行处理。如图：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T17:34:39+08:00">
    <meta property="article:modified_time" content="2024-07-12T17:34:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot统一功能处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F" rel="nofollow">一、统一数据返回格式</a></p> 
<p id="%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%E6%B5%8B%E8%AF%95" rel="nofollow">测试</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98" rel="nofollow">二、存在问题</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">解决方案</a></p> 
<p id="%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9-toc" style="margin-left:40px;"><a href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9" rel="nofollow">案例代码修改</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%BB%9F%E4%B8%80%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BB%9F%E4%B8%80%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow">三、统一功能的优点</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow">四、统一异常处理</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89" rel="nofollow">五、案例代码（图书管理系统）</a></p> 
<p id="1%E3%80%81login.html-toc" style="margin-left:40px;"><a href="#1%E3%80%81login.html" rel="nofollow">1、login.html</a></p> 
<p id="2%E3%80%81book_update.html-toc" style="margin-left:40px;"><a href="#2%E3%80%81book_update.html" rel="nofollow">2、book_update.html</a></p> 
<p id="3%E3%80%81book_add.html-toc" style="margin-left:40px;"><a href="#3%E3%80%81book_add.html" rel="nofollow">3、book_add.html</a></p> 
<p id="4%E3%80%81book_list.html-toc" style="margin-left:40px;"><a href="#4%E3%80%81book_list.html" rel="nofollow">4、book_list.html</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">六、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>        上一篇博客使用了拦截器，强制登录案例做了两步：<span style="background-color:#a2e043;">1、通过Session来判断用户是否登录；2、如果未登录，对后端返回数据进行封装，告知前端处理的结果</span>。</p> 
<p>        但是因为刚开始的图书管理系统的接口返回的不是Result类，我们现在想<span style="color:#956fe7;"><strong>把后端接口返回的类型都改成Result</strong></span>，那么就可以使用SpringBoot的第二个统一功能处理。</p> 
<h2 id="%E4%B8%80%E3%80%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F">一、统一数据返回格式</h2> 
<p>        统一的数据返回格式使用 <span style="color:#956fe7;"><strong>@ControllerAdvice 和 实现ResponseBodyAdvice接口</strong></span> 的方式实现，<strong>@ControllerAdvice 表示控制器通知类</strong>。</p> 
<p>        <span style="color:#fe2c24;"><strong>添加类 ResponseAdvice，实现 ResponseBodyAdvice 接口，并在类上添加 @ControllerAdvice 注解</strong></span>，代码如下：</p> 
<pre><code class="language-java">@ControllerAdvice
public class ResponseAdvice implements ResponseBodyAdvice {
    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
        return Result.success(body);
    }
}</code></pre> 
<p><strong>supports() 方法</strong>：<span style="background-color:#a2e043;">判断是否要执行 beforeBodyWrite 方法。true 为执行，false为不执行</span>。<span style="color:#fe2c24;"><strong>通过该方法可以选择哪些类或哪些方法的 response 要进行处理，其他的不进行处理</strong></span>。如图：</p> 
<p><img alt="" height="308" src="https://images2.imgbox.com/ab/b1/0oWsgnZI_o.png" width="602"></p> 
<p><strong>beforeBodyWrite() 方法</strong>：对 response 方法进行具体操作处理。</p> 
<h3 id="%E6%B5%8B%E8%AF%95">测试</h3> 
<p>        测试接口：<a href="http://127.0.0.1:8080/book/queryBookById?bookId=1" rel="nofollow" title="http://127.0.0.1:8080/book/queryBookById?bookId=1">http://127.0.0.1:8080/book/queryBookById?bookId=1</a></p> 
<p>        添加统一数据返回格式之前：</p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/45/36/Ksc3CaDR_o.png" width="541"></p> 
<p>        添加统一数据返回格式之后：</p> 
<p><img alt="" height="517" src="https://images2.imgbox.com/5c/f3/FpV2C4Bl_o.png" width="549"></p> 
<p>        可以看到，返回的数据从 <span style="color:#fe2c24;"><strong>BookInfo 对象变为 Result 对象</strong></span>，是 SpringBoot 帮我们处理了返回的数据格式。</p> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98">二、存在问题</h2> 
<p>        现在测试 updateBook 接口</p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/a6/f3/a0AxhSBV_o.png" width="586"></p> 
<p>        URL：<a href="http://127.0.0.1:8080/book/updateBook?id=1&amp;count=99" rel="nofollow" title="http://127.0.0.1:8080/book/updateBook?id=1&amp;count=99">http://127.0.0.1:8080/book/updateBook?id=1&amp;count=99</a><br><img alt="" height="433" src="https://images2.imgbox.com/59/ea/SnOwoKcE_o.png" width="484"></p> 
<p>        可以看到，发生了内部错误，再看看数据库的数据，确发生改变了。</p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/f5/6e/C9lFAcSh_o.png" width="1119"></p> 
<p>        <strong>后端报错日志</strong>：<span style="background-color:#a2e043;">不能把 Result类 转换成 String类 </span><img alt="" height="215" src="https://images2.imgbox.com/f4/f1/PV1A5DFL_o.png" width="1200"></p> 
<p>        说明是 SpringBoot 帮我们处理数据返回的格式，原本返回的Result类型转为String类型有问题。</p> 
<p>        现在再多测几种不同的返回类型，看是否会报错，代码如下：</p> 
<pre><code class="language-java">@RequestMapping("/test")
@RestController
public class TestController {
    @RequestMapping("/t1")
    public String t1() {
        return "string";
    }
    @RequestMapping("t2")
    public Integer t2() {
        return 1;
    }
    @RequestMapping("/t3")
    public Boolean t3() {
        return true;
    }
}</code></pre> 
<p>        测试上面几个接口：</p> 
<p>        t1报错了，报错原因和上面的一样。</p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/87/6b/kZ5nOVQU_o.png" width="431"></p> 
<p>        t2、t3 不会报错，如图：</p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/5d/0e/gNRmpJAA_o.png" width="333"><img alt="" height="381" src="https://images2.imgbox.com/d1/f2/pNQWIrxk_o.png" width="334"></p> 
<h3 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</h3> 
<p>        添加一行判断语句，<span style="background-color:#a2e043;">如果返回的数据 body 是 String类型，就使用SpringBoot内置提供的 Jackson 来实现信息的序列化</span>。</p> 
<pre><code class="language-java">@ControllerAdvice
public class ResponseAdvice implements ResponseBodyAdvice {
    @Autowired
    ObjectMapper objectMapper;
    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    @SneakyThrows
    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
        if(body instanceof  String){//如果返回结果为String类型，使用SpringBoot内置提供的Jackson来实现信息的序列化
            return objectMapper.writeValueAsString(Result.success(body));
        }
        return Result.success(body);
    }
}</code></pre> 
<p>        测试：使用更新图书的接口，如图，返回的是Result类型，没有报错了</p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/42/76/cmg8C29F_o.png" width="552"></p> 
<h3 id="%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9">案例代码修改</h3> 
<pre><code class="language-java">@ControllerAdvice
public class ResponseAdvice implements ResponseBodyAdvice {
    @Autowired
    ObjectMapper objectMapper;
    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    @SneakyThrows
    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
        //使返回的结果更加灵活
        if(body instanceof Result) {//如果返回结果为Result类型，则直接返回数据
            return body;
        }
        if(body instanceof  String){//如果返回结果为String类型，使用SpringBoot内置提供的Jackson来实现信息的序列化
            return objectMapper.writeValueAsString(Result.success(body));
        }
        return Result.success(body);
    }
}</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E7%BB%9F%E4%B8%80%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BC%98%E7%82%B9">三、统一功能的优点</h2> 
<p>        <strong>1、</strong><span style="background-color:#38d8f0;">方便前端程序员更好的接受和解析后端数据接口返回的数据</span>。</p> 
<p>        <strong>2、</strong><span style="background-color:#38d8f0;">降低前端程序员和后端程序员的沟通成本，按照某个格式实现就可以了，因为所以接口都是这样返回的</span>。</p> 
<p>        <strong>3、</strong><span style="background-color:#38d8f0;">有利于项目统一数据的维护和修改</span>。</p> 
<p>        <strong>4、</strong><span style="background-color:#38d8f0;">有利于后端技术部门的统一规范和标准规定，不会出现稀奇古怪的返回内容</span>。</p> 
<h2 id="%E5%9B%9B%E3%80%81%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">四、统一异常处理</h2> 
<p>        <strong>统一异常处理使用的：</strong> <span style="color:#956fe7;"><strong>@ControllerAdvice + @ExceptionHandler </strong></span>来实现的，<span style="background-color:#a2e043;">@ControllerAdvice 表示控制器通知类，@ExceptionHandler 使异常处理器，两个结合表示当出现异常的时候执行某个通知，也就是执行某个方法事件</span>。</p> 
<p>        代码如下：</p> 
<pre><code class="language-java">@ResponseBody
@ControllerAdvice
public class ExceptionAdvice {
    @ExceptionHandler
    public Result handlerException(Exception e) {
        return Result.fail(e.getMessage());
    }
}</code></pre> 
<p>        其中返回对象也可以写成 Object，代码如下：</p> 
<pre><code class="language-java">@ResponseBody
@ControllerAdvice
public class ExceptionAdvice {
    @ExceptionHandler
    public Object handlerException(Exception e) {
        return Result.fail(e.getMessage());
    }
}</code></pre> 
<p>        类名，方法名和返回值可以自定义，<span style="color:#fe2c24;"><strong>重要的是注解，接口返回为数据时，需要加 @ResponseBody 注解</strong></span>。</p> 
<p>        以上代码表示，<span style="background-color:#ffd900;">如果代码出现 Exception 异常（包括Exception的子类），就返回一个 Result 的对象，Result 对象的设置参考 Result.fail(e.getMessage())</span>。</p> 
<p>        我们现在修改一下后端代码，把后端删除图书的mapper层xml文件的接口改错，如图：</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/df/68/sEElDUQv_o.png" width="438"></p> 
<p>        现在访问URL：<a href="http://127.0.0.1:8080/book/deleteBook?bookId=14" rel="nofollow" title="http://127.0.0.1:8080/book/deleteBook?bookId=14">http://127.0.0.1:8080/book/deleteBook?bookId=14</a> ，返回的信息如图：</p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/5f/9c/sy4zK8vn_o.png" width="1161"></p> 
<p>        其中 <span style="color:#fe2c24;"><strong>加@ResponseBody 注解非常重要，下面使用 fiddler 抓包看看加和不加的区别</strong></span>：</p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/b3/6d/tTFpbKr4_o.png" width="1200"></p> 
<p>        我们也可以<strong>针对不同的异常，返回不同的结果</strong>，代码如下：</p> 
<pre><code class="language-java">@Slf4j
@ResponseBody
@ControllerAdvice
public class ExceptionAdvice {
    @ExceptionHandler
    public Result handlerException(Exception e) {
        log.error("发生异常: e", e);
        return Result.fail("内部错误");
    }

    @ExceptionHandler
    public Result handlerException(NullPointerException e) {
        log.error("发生异常: e", e);
        return Result.fail("发生空指针异常");
    }
    @ExceptionHandler
    public Result handlerException(ArithmeticException e) {
        log.error("发生异常, e:", e);
        return Result.fail("发生算数异常");
    }
}</code></pre> 
<p>        模拟制造异常，代码如下：</p> 
<pre><code class="language-java">@RequestMapping("/test")
@RestController
public class TestController {
    @RequestMapping("/t1")
    public String t1() {
        return "string";
    }
    @RequestMapping("t2")
    public Integer t2() {
        int a = 10 / 0;//抛出ArithmeticException
        return 1;
    }
    @RequestMapping("/t3")
    public Boolean t3() {
        String a = null;
        System.out.println(a.length());//抛出NullPointerException
        return true;
    }
}</code></pre> 
<p>        当有多个异常通知时，<span style="color:#fe2c24;"><strong>匹配顺序为当前类及其子类向上依次匹配</strong></span>，/test/t2 抛出 ArithmeticException算术异常，/test/t3 抛出NullPointerException 空指针异常。</p> 
<p>        测试上面这上面的算术异常和空指针异常的接口，如图：</p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/31/f0/lNroRwx2_o.png" width="332"><img alt="" height="467" src="https://images2.imgbox.com/8d/b7/EW73IPYp_o.png" width="331"></p> 
<p>        <span style="color:#fe2c24;"><strong>当异常和子类异常不匹配时，就会去找父类异常（优先捕获子类异常，再捕获父类异常）</strong></span>，下面输入一个错的URL，显示信息如下：</p> 
<p>        <img alt="" height="512" src="https://images2.imgbox.com/6b/4c/5IMGS81E_o.png" width="441"></p> 
<hr> 
<h2 id="%E4%BA%94%E3%80%81%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89">五、案例代码（图书管理系统）</h2> 
<p>        因为上面使用了统一功能处理（统一了数据返回的格式：Result；统一了异常的处理），所以<strong><span style="background-color:#38d8f0;">所有接口返回的数据类型都改变了，相对前端的接口也要进行修改</span></strong>，其中图书链表页面已经修改好了（book_list.html）</p> 
<h3 id="1%E3%80%81login.html">1、login.html</h3> 
<p>        稍微修改一下后端的代码，原本错误信息是放进data里的，现在改成放进errMsg里面，代码如下：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {
    @Autowired
    private UserService userService;
    @RequestMapping(value = "/login", produces = "application/json")
    public Result login(String userName, String password, HttpSession session) {
        //1、校验参数
        //2、校验密码是否正确

        //3、返回响应结果
        System.out.println(userName + " " + password);
        if(!StringUtils.hasLength(userName) || !StringUtils.hasLength(password)) {
            return Result.fail("用户名或者密码为空");
        }

        UserInfo userInfo = userService.getUserInfoByName(userName);

        if(userInfo == null) {
            return Result.fail("用户不存在");
        }
        if(!password.equals(userInfo.getPassword())) {
            return Result.fail("密码错误");
        }

        //根据用户名称，去数据库查询用户信息，如果未查询到，说明用户不存在
        //如果查询到用户信息，比对密码是否正确
        //正确的情况
        session.setAttribute(Constant.USER_SESSION_KEY, userInfo);
        return Result.success("");
    }
}</code></pre> 
<p>        用 Postman 测试接口，看返回的数据是什么，再进行修改代码，现在后端返回的数据如图：</p> 
<p><img alt="" height="503" src="https://images2.imgbox.com/1d/68/v1CJHq8s_o.png" width="701"></p> 
<p>        代码如下：</p> 
<pre><code class="language-javascript">    &lt;script&gt;
        function login() {
            var userName = $("#userName").val();
            var password = $("#password").val();
            $.ajax({
                url: "/user/login",
                type: "post",
                data: {
                    userName: $("#userName").val(),
                    password: $("#password").val()
                },
                success: function(result) {
                    if(result.code == "SUCCESS" &amp;&amp; result.data == "") {
                    location.href = "book_list.html?pageNum=1";
                    } else{
                        alert(result.errMsg);
                    }
                }
            });
        }
    &lt;/script&gt;</code></pre> 
<h3 id="2%E3%80%81book_update.html">2、book_update.html</h3> 
<p>        <img alt="" height="83" src="https://images2.imgbox.com/7c/98/TlUmuA11_o.png" width="1105"></p> 
<p>        修改图书要切换到另一个界面，这个界面就要把刚刚所选中的图书，从数据库把所有信息都放到这个界面，如图：</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/28/4a/GLaXrA1n_o.png" width="641"></p> 
<p>        现在修改前端接受的信息，现在后端发来的数据个数如下：</p> 
<p>        <img alt="" height="555" src="https://images2.imgbox.com/f3/28/kyZdzW4r_o.png" width="425"></p> 
<p>        根据上面返回的信息修改前端代码，代码如下：</p> 
<pre><code class="language-javascript">    &lt;script&gt;
        $.ajax({
            url: "/book/queryBookById" + location.search,
            type: "get",
            success: function (result) {
                if (result.code == "SUCCESS" &amp;&amp; result.data != null) {
                    var book = result.data;
                    $("#bookId").val(book.id);
                    $("#bookName").val(book.bookName);
                    $("#bookAuthor").val(book.author);
                    $("#bookStock").val(book.count);
                    $("#bookPrice").val(book.price);
                    $("#bookPublisher").val(book.publish);
                    $("#bookStatus").val(book.status)
                }
            },
            error: function (error) {
                if (error != null &amp;&amp; error.status == 401) {
                    //用户未登录
                    location.href = "login.html";
                }
            }
        });

        function update() {
            $.ajax({
                url: "/book/updateBook",
                type: "post",
                data: $("#updateBook").serialize(),
                success: function (result) {
                    if (result.code == "SUCCESS" &amp;&amp; result == "") {
                        //更新成功
                        location.href = "book_list.html";
                    } else {
                        alert(result);
                    }
                },
                error: function () {
                    if (error != null &amp;&amp; error.status == 401) {
                        //用户未登录
                        location.href = "login.html";
                    }
                }
            })
            // alert("更新成功");
            // location.href = "book_list.html"
        }
    &lt;/script&gt;</code></pre> 
<h3 id="3%E3%80%81book_add.html">3、book_add.html</h3> 
<p>        现在测试一下 /book/addBook 接口，如图：</p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/a5/a0/oryu7Y3n_o.png" width="972"></p> 
<p>        其错误信息放进 data 里面，是不合理的，所以现在修改一下后端代码，代码如下：</p> 
<pre><code class="language-javascript">    &lt;script&gt;
        function add() {
            $.ajax({
                url: "/book/addBook",
                type: "post",
                data: $("#addBook").serialize(),
                success: function (result) {
                    if (result.code == "SUCCESS" &amp;&amp; result.data == "") {
                        //添加成功
                        location.href = "book_list.html";
                    } else {
                        alert(result.data);
                    }
                },
                error: function () {
                    if (error != null &amp;&amp; error.status == 401) {
                        //用户未登录
                        location.href = "login.html";
                    }
                }
            })
        }
    &lt;/script&gt;</code></pre> 
<h3 id="4%E3%80%81book_list.html">4、book_list.html</h3> 
<p>        删除接口的代码如下：</p> 
<pre><code class="language-javascript">            function deleteBook(id) {
                var isDelete = confirm("确认删除?");
                if (isDelete) {
                    //删除图书
                    $.ajax({
                        url: "/book/deleteBook",
                        type: "post",
                        data: {
                            bookId: id
                        },
                        success: function (result) {
                            if (result != null &amp;&amp; result.data == "") {
                                // location.href = "book_list.html" + location.search;
                                location.href = "book_list.html";
                            } else {
                                alert(result.data);
                            }
                        },
                        error: function () {
                            if (error != null &amp;&amp; error.status == 401) {
                                //用户未登录
                                location.href = "login.html";
                            }
                        }
                    });
                    // alert("删除成功");
                }
            }</code></pre> 
<p>        批量删除接口的代码如下：</p> 
<pre><code class="language-javascript">            function batchDelete() {
                var isDelete = confirm("确认批量删除?");
                if (isDelete) {
                    //获取复选框的id
                    var ids = [];
                    $("input:checkbox[name='selectBook']:checked").each(function () {
                        ids.push($(this).val());
                    });
                    console.log(ids);
                    $.ajax({
                        url: "/book/batchDeleteBook?ids=" + ids,
                        type: "post",
                        success: function (result) {
                            if (result != null &amp;&amp; result.data == "") {
                                //删除成功
                                location.href = "book_list.html";
                            } else {
                                alert(result.data);
                            }
                        },
                        error: function () {
                            if (error != null &amp;&amp; error.status == 401) {
                                //用户未登录
                                location.href = "login.html";
                            }
                        }
                    });
                    // alert("批量删除成功");
                }
            }</code></pre> 
<hr> 
<h2 id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93" style="background-color:transparent;">六、总结</h2> 
<p>        gitte源码：<a href="https://gitee.com/cool_tao6/studying-java-ee-advanced/tree/master/spring-interceptor" rel="nofollow" title="https://gitee.com/cool_tao6/studying-java-ee-advanced/tree/master/spring-interceptor">https://gitee.com/cool_tao6/studying-java-ee-advanced/tree/master/spring-interceptor</a></p> 
<p>        统一处理包含了<strong>拦截器、统一数据返回格式、统一异常处理</strong>。</p> 
<p><strong>1、拦截器的实现主要分两部分</strong>：</p> 
<p>        （1）、<span style="background-color:#a2e043;">定义拦截器（实现 <strong>HandlerInterceptor 接口 </strong>+ <strong>@Component注解</strong>）</span>。</p> 
<p>        （2）、<span style="background-color:#a2e043;">配置拦截器（实现 <strong>WebMvcConfigurer 接口 </strong>+ <strong>@Configuration注解</strong>）</span>。其中<span style="color:#fe2c24;"><strong>@Configuration注解包含 @Component注解</strong></span></p> 
<p><strong>2、</strong><span style="background-color:#38d8f0;">统一数据返回格式通过 <strong>@ControllerAdvice + ResponseBodyAdvice接口</strong> 来实现</span>。</p> 
<p><strong>3、</strong><span style="background-color:#38d8f0;">统一异常处理使用 <strong>@ControllerAdvice + @ExceptionHandler</strong> 来实现，并且可以细分不同的异常来处理</span>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/756c91b774e6b4277ae062049cf44ecb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【uniApp】实现列表下拉触底加载更多功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a06c788f0ca5ead3ba1b90c356c07c35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; --＞ 类和对象(二)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>