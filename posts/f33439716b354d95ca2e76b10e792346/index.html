<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中ArrayList（顺序表）的自我实现（如果想知道Java中怎么自我实现ArrayList，那么只看这一篇就足够了！） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f33439716b354d95ca2e76b10e792346/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中ArrayList（顺序表）的自我实现（如果想知道Java中怎么自我实现ArrayList，那么只看这一篇就足够了！）">
  <meta property="og:description" content="前言：在 Java 编程中，ArrayList 是一种非常常用的数据结构，它提供了动态数组的实现方式，可以方便地存储和操作数据。相比于传统的数组，ArrayList 具有更多的灵活性和便利性，可以根据需要动态地调整大小，并提供了一系列丰富的方法来增删改查元素，但是本篇文章主要讲解如何去自我实现Java中ArrayList（顺序表）。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文的大致内容：
目录
1.自我定义ArrayList类
2.自我实现ArrayList中的方法
（1）新增元素,默认在数组最后新增
（2）在 pos 位置新增元素
（3）判定是否包含某个元素
（4）查找某个元素对应的位置
（5）获取 pos 位置的元素
（6）给 pos 位置的元素设为 value
（7）删除第一次出现的关键字key
（8）获取顺序表长度
（9）打印顺序表
3.总结自我实现ArrayList
1.自我定义ArrayList类 在自我实现Java中的ArrayList（顺序表）之前，我们需要先自我定义一个ArrayList类，定义方式如下：
public class MyArrayList{ //创建一个数组 private int[] array; //用于记录数组中的元素格式 private int arrayNumber; //初始化数组原始大小 public static final int CAPACITY = 10; //构造方法 public MyArrayList() { this.array = new int[CAPACITY]; this.arrayNumber = 0; } 这段代码定义了一个名为MyArrayList的类，用于实现顺序表。以下是对代码的分析：
私有属性：
array：一个整型数组，用于存储元素。
arrayNumber：一个整型变量，用于记录数组中元素的个数。
CAPACITY：一个常量，表示数组的初始容量。
构造方法：
MyArrayList()：构造方法初始化了数组array为长度为CAPACITY的整型数组，并将arrayNumber初始化为0。
这样我们就定义好了一个ArrayList类，接下来就是实现Java中ArrayList中的方法了。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-13T12:26:35+08:00">
    <meta property="article:modified_time" content="2024-06-13T12:26:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中ArrayList（顺序表）的自我实现（如果想知道Java中怎么自我实现ArrayList，那么只看这一篇就足够了！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>  <strong>      前言：在 Java 编程中，ArrayList 是一种非常常用的数据结构，它提供了动态数组的实现方式，可以方便地存储和操作数据。相比于传统的数组，ArrayList 具有更多的灵活性和便利性，可以根据需要动态地调整大小，并提供了一系列丰富的方法来增删改查元素，但是本篇文章主要讲解如何去自我实现Java中ArrayList（顺序表）。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/55/3a/d74zEB6b_o.jpg"></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨这里是秋刀鱼不做梦的BLOG</strong></span></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本文的大致内容：</strong></span></p> 
<p style="text-align:center;"><span style="color:#a2e043;"><strong><img alt="" src="https://images2.imgbox.com/76/c2/58pPxTwL_o.png"></strong></span></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E8%87%AA%E6%88%91%E5%AE%9A%E4%B9%89ArrayList%E7%B1%BB-toc" style="margin-left:0px;"><strong><a href="#1.%E8%87%AA%E6%88%91%E5%AE%9A%E4%B9%89ArrayList%E7%B1%BB" rel="nofollow">1.自我定义ArrayList类</a></strong></p> 
<p id="2.%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0ArrayList%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><strong><a href="#2.%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0ArrayList%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">2.自我实现ArrayList中的方法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0%2C%E9%BB%98%E8%AE%A4%E5%9C%A8%E6%95%B0%E7%BB%84%E6%9C%80%E5%90%8E%E6%96%B0%E5%A2%9E-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0%2C%E9%BB%98%E8%AE%A4%E5%9C%A8%E6%95%B0%E7%BB%84%E6%9C%80%E5%90%8E%E6%96%B0%E5%A2%9E" rel="nofollow">        （1）新增元素,默认在数组最后新增</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E5%9C%A8%20pos%20%E4%BD%8D%E7%BD%AE%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E5%9C%A8%20pos%20%E4%BD%8D%E7%BD%AE%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0" rel="nofollow">        （2）在 pos 位置新增元素</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%883%EF%BC%89%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%883%EF%BC%89%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0" rel="nofollow">        （3）判定是否包含某个元素</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow">        （4）查找某个元素对应的位置</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%885%EF%BC%89%E8%8E%B7%E5%8F%96%20pos%20%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%885%EF%BC%89%E8%8E%B7%E5%8F%96%20pos%20%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0" rel="nofollow">        （5）获取 pos 位置的元素</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%886%EF%BC%89%E7%BB%99%20pos%20%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BE%E4%B8%BA%20value-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%886%EF%BC%89%E7%BB%99%20pos%20%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BE%E4%B8%BA%20value" rel="nofollow">        （6）给 pos 位置的元素设为 value</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%887%EF%BC%89%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97key-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%887%EF%BC%89%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97key" rel="nofollow">        （7）删除第一次出现的关键字key</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%888%EF%BC%89%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%95%BF%E5%BA%A6-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%888%EF%BC%89%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%95%BF%E5%BA%A6" rel="nofollow">        （8）获取顺序表长度</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%889%EF%BC%89%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%889%EF%BC%89%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">        （9）打印顺序表</a></strong></p> 
<p id="3.%E6%80%BB%E7%BB%93%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0ArrayList-toc" style="margin-left:0px;"><strong><a href="#3.%E6%80%BB%E7%BB%93%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0ArrayList" rel="nofollow">3.总结自我实现ArrayList</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E8%87%AA%E6%88%91%E5%AE%9A%E4%B9%89ArrayList%E7%B1%BB"><span style="color:#956fe7;">1.自我定义ArrayList类</span></h2> 
<p>        在自我实现Java中的ArrayList（顺序表）之前，我们需要先自我定义一个ArrayList类，定义方式如下：</p> 
<pre><code class="language-java">public class MyArrayList{

    //创建一个数组
    private int[] array;

    //用于记录数组中的元素格式
    private int arrayNumber;

    //初始化数组原始大小
    public static final int CAPACITY = 10;

    //构造方法
    public MyArrayList() {
        this.array = new int[CAPACITY];
        this.arrayNumber = 0;
}</code></pre> 
<p>  <span style="color:#38d8f0;"><strong>      这段代码定义了一个名为MyArrayList的类，用于实现顺序表。以下是对代码的分析：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><span style="color:#ff9900;">私有属性：</span></strong></p> 
   <ul><li> <p><strong><span style="color:#ff9900;"><code>array</code>：一个整型数组，用于存储元素。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>arrayNumber</code>：一个整型变量，用于记录数组中元素的个数。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>CAPACITY</code>：一个常量，表示数组的初始容量。</span></strong></p> </li></ul></li><li> <p><strong><span style="color:#ff9900;">构造方法：</span></strong></p> 
   <ul><li> <p><strong><span style="color:#ff9900;"><code>MyArrayList()</code>：构造方法初始化了数组<code>array</code>为长度为<code>CAPACITY</code>的整型数组，并将<code>arrayNumber</code>初始化为0。</span></strong></p> </li></ul></li></ol> 
</blockquote> 
<p><strong>这样我们就定义好了一个ArrayList类，接下来就是实现Java中ArrayList中的方法了。</strong></p> 
<p></p> 
<h2 id="2.%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0ArrayList%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span style="color:#956fe7;">2.自我实现ArrayList中的方法</span></h2> 
<p>        在自我实现ArrayList中的方法之前，先让我们看一下要实现哪些方法：</p> 
<pre><code class="language-java">// 新增元素,默认在数组最后新增
public void add(int data) { }
 
// 在 pos 位置新增元素
public void add(int pos, int data) { }
 
// 判定是否包含某个元素
public boolean contains(int toFind) { }
 
// 查找某个元素对应的位置
public int indexOf(int toFind) { }
 
// 获取 pos 位置的元素
public int get(int pos) { }
 
// 给 pos 位置的元素设为 value
public void set(int pos, int value) { }
 
//删除第一次出现的关键字key
public void remove(int toRemove) { }
 
// 获取顺序表长度
public int size() { }
 
// 打印顺序表
public void display() { }</code></pre> 
<p><strong>那么接下来让我们一个一个的自我实现：</strong></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0%2C%E9%BB%98%E8%AE%A4%E5%9C%A8%E6%95%B0%E7%BB%84%E6%9C%80%E5%90%8E%E6%96%B0%E5%A2%9E">     <span style="color:#ffd900;">   </span><span style="color:#4da8ee;">（1）新增元素,默认在数组最后新增</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">    public boolean isFull() {
        return this.array.length == this.arrayNumber;
    }

    private void beBig() {
        this.array = Arrays.copyOf(this.array, this.array.length * 2);
    }

    public void add(int data) {
        //判断是否已满
        if (isFull()) {
            //顺序表满了就进行扩容
            beBig();
        }
        //顺序表未满，添加元素
        this.array[this.arrayNumber] = data;
        this.arrayNumber++;
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>  现在我们对这些代码进行分析：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><span style="color:#ff9900;"><code>isFull()</code> 方法用于检查顺序表是否已满。它通过比较数组的长度和数组中元素的个数来确定是否满了。如果数组的长度等于数组中元素的个数（即 <code>array.length == arrayNumber</code>），则表示数组已满，返回 <code>true</code>；否则返回 <code>false</code>。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>beBig()</code> 方法用于扩容数组。它使用 <code>Arrays.copyOf()</code> 方法将原数组扩容为原来的两倍大小。这样做是为了在顺序表满时能够动态扩展数组大小以容纳更多的元素。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>add(int data)</code> 方法用于向顺序表中添加元素。首先，它检查顺序表是否已满，如果满了，则调用 <code>beBig()</code> 方法进行扩容。然后，将新元素添加到数组的下一个位置，并更新数组中元素的个数。</span></strong></p> </li></ol> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E5%9C%A8%20pos%20%E4%BD%8D%E7%BD%AE%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0"><span style="color:#4da8ee;">        （2）在 pos 位置新增元素</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">    public boolean isFull() {
        return this.array.length == this.arrayNumber;
    }

    private void beBig() {
        this.array = Arrays.copyOf(this.array, this.array.length * 2);
    }


    public void add(int pos, int data) throws IndexException {
        //如果索引异常就抛出异常
        if (pos &lt; 0 || pos &gt; this.arrayNumber) {
            throw new IndexException("索引异常！！！");
        } else {
            //判断是否已满
            if (isFull()) {
                对原顺序表进行扩容
                beBig();
            } else {
                for (int i = this.arrayNumber - 1; i &gt;= pos; i--) {
                    this.array[i + 1] = this.array[i];
                }
                this.array[pos] = data;
                this.arrayNumber++;
            }
        }
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>现在让我们逐行分析一下：</strong></span></p> 
<blockquote> 
 <ol><li> <p><span style="color:#ff9900;"><strong><code>public boolean isFull()</code>: 这个方法检查数组是否已满，即数组中的元素数量是否等于数组的长度。如果是，则返回true，否则返回false。</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong><code>private void beBig()</code>: 这个方法用于扩大数组的容量。它使用<code>Arrays.copyOf()</code>方法创建了一个新数组，长度是原数组的两倍，然后将原数组的内容复制到新数组中。</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong><code>public void add(int pos, int data) throws IndexException</code>: 这是一个添加元素的方法，接受两个参数：要添加的位置<code>pos</code>和要添加的数据<code>data</code>。如果位置超出了数组的范围，则抛出<code>IndexException</code>异常。否则，如果数组已满，则先扩大数组的容量，然后执行插入操作；如果数组未满，则将从插入位置开始的元素向后移动一个位置，为新元素腾出位置，并将新元素插入到指定位置。</strong></span></p> </li></ol> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%883%EF%BC%89%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0">    <span style="color:#4da8ee;">    （3）判定是否包含某个元素</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">public boolean contains(int toFind) {
        //循环遍历顺序表查找目标元素
        for (int i = 0; i &lt; this.arrayNumber; i++) {
            if (this.array[i] == toFind) {
                return true;
            }
        }
        return false;
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>现在让我们来逐步分析一下：</strong></span></p> 
<blockquote> 
 <ol><li> <p><span style="color:#ff9900;"><strong>方法签名：<code>public boolean contains(int toFind)</code></strong></span></p> 
   <ul><li> <p><span style="color:#ff9900;"><strong>返回类型：<code>boolean</code>，表示是否包含特定元素。</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong>参数：<code>int toFind</code>，表示要查找的元素值。</strong></span></p> </li></ul></li><li> <p><span style="color:#ff9900;"><strong>循环结构：</strong></span></p> 
   <ul><li> <p><span style="color:#ff9900;"><strong>使用 <code>for</code> 循环遍历整数数组。</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong>循环变量 <code>i</code> 从 0 开始逐渐增加，直到数组长度（<code>this.arrayNumber</code>）。</strong></span></p> </li></ul></li><li> <p><span style="color:#ff9900;"><strong>条件判断：</strong></span></p> 
   <ul><li> <p><span style="color:#ff9900;"><strong>在每次循环中，通过 <code>if</code> 语句检查当前数组元素是否等于要查找的元素 <code>toFind</code>。</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong>如果找到了匹配的元素，返回 <code>true</code>，表示数组中包含了要查找的元素。</strong></span></p> </li></ul></li><li> <p><span style="color:#ff9900;"><strong>返回结果：</strong></span></p> 
   <ul><li> <p><span style="color:#ff9900;"><strong>如果整个循环执行完毕都没有找到匹配的元素，则返回 <code>false</code>，表示数组不包含要查找的元素。</strong></span></p> </li></ul></li></ol> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BD%8D%E7%BD%AE">        <span style="color:#4da8ee;">（4）查找某个元素对应的位置</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">public int indexOf(int toFind) {
        //遍历顺序表查找元素位置
        for (int i = 0; i &lt; this.arrayNumber; i++) {
            if (this.array[i] == toFind) {
                return i;
            }
        }
        return -1;
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>让我逐行解释一下：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><span style="color:#ff9900;"><code>public int indexOf(int toFind) {<!-- --></code>: 这是一个公有方法，用于查找数组中某个特定元素的索引。方法的参数 <code>toFind</code> 是要查找的目标元素。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>for (int i = 0; i &lt; this.arrayNumber; i++) {<!-- --></code>: 这是一个 for 循环，从数组的第一个元素开始逐个检查，直到数组的长度为止。<code>this.arrayNumber</code> 可能是数组的长度，尽管代码中未显示出来，但我们可以假设它是这样的。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>if (this.array[i] == toFind) {<!-- --></code>: 在循环的每一次迭代中，检查数组中当前位置的元素是否等于我们要查找的元素 <code>toFind</code>。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>return i;</code>: 如果找到了匹配的元素，就返回当前元素的索引 <code>i</code>。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>return -1;</code>: 如果整个数组都被遍历了但没有找到匹配的元素，则返回 -1，表示未找到。</span></strong></p> </li></ol> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%885%EF%BC%89%E8%8E%B7%E5%8F%96%20pos%20%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0"><span style="color:#4da8ee;">        （5）获取 pos 位置的元素</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">public boolean isEmpty() {
        return this.arrayNumber == 0;
    }

    public int get(int pos) throws EmptyException, IndexException {
        //判断数组是否为空
        if (isEmpty()) {
            throw new EmptyException("数组为空！！！");
        }
        //判断数组索引是否越界
        if (pos &lt; 0 || pos &gt;= this.arrayNumber) {
            throw new IndexException("索引异常！！！");
        }
        return this.array[pos];
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>现在让我逐行解释一下：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><span style="color:#ff9900;"><code>isEmpty()</code> 方法用于检查数组是否为空。它通过检查 <code>arrayNumber</code> 属性是否为 0 来判断数组是否为空。如果 <code>arrayNumber</code> 为 0，则返回 <code>true</code>，否则返回 <code>false</code>。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>get(int pos)</code> 方法用于获取数组中指定位置的元素。它首先调用 <code>isEmpty()</code> 方法来检查数组是否为空。如果数组为空，则抛出 <code>EmptyException</code> 异常，表示数组为空。然后，它检查所请求的位置是否有效，即是否在数组范围内。如果位置 <code>pos</code> 小于 0 或者大于等于 <code>arrayNumber</code>，则抛出 <code>IndexException</code> 异常，表示索引异常。如果以上两个条件都通过了，它返回数组中位置 <code>pos</code> 的元素值。</span></strong></p> </li></ol> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%886%EF%BC%89%E7%BB%99%20pos%20%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BE%E4%B8%BA%20value"><span style="color:#4da8ee;">        （6）给 pos 位置的元素设为 value</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">public boolean isEmpty() {
        return this.arrayNumber == 0;
    }

    public void set(int pos, int value) throws EmptyException, IndexException {
        //判断数组是否为空
        if (isEmpty()) {
            //抛出异常
            throw new EmptyException("数组为空！！！");
        }
        //判断数组索引是否越界
        if (pos &lt; 0 || pos &gt;= this.arrayNumber) {
            //抛出异常
            throw new IndexException("索引异常！！！");
        }
        this.array[pos] = value;
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>现在让我逐行解释一下：</strong></span></p> 
<blockquote> 
 <ol><li> <p><span style="color:#ff9900;"><strong><code>isEmpty()</code> 方法用于判断数组是否为空。它返回一个布尔值，表示数组中是否没有元素。具体来说，它通过检查数组中存储的元素数量是否为0来确定数组是否为空。</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong><code>set(int pos, int value)</code> 方法用于设置数组中指定位置的元素值。它接受两个参数：位置（pos）和要设置的值（value）。在设置之前，它会先检查数组是否为空，如果为空则抛出 <code>EmptyException</code> 异常；然后检查位置是否合法，如果位置越界则抛出 <code>IndexException</code> 异常；最后，如果一切正常，它会将给定的值设置到指定位置的数组元素中。</strong></span></p> </li></ol> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%887%EF%BC%89%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97key">       <span style="color:#4da8ee;"> （7）删除第一次出现的关键字key</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">public boolean isEmpty() {
        return this.arrayNumber == 0;
    }

    public void remove(int toRemove) throws EmptyException{
        //判断数组是否为空
        if(isEmpty()){
            //抛出异常
            throw new EmptyException("数组为空！！！");
        }
        //遍历查找目标元素
        int index = indexOf(toRemove);
        if(index == -1){
            return;
        }
        for(int i = index;i&lt;this.arrayNumber-1;i++){
            this.array[i] = this.array[i+1];
        }
        this.arrayNumber--;
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>现在让我逐行解释一下：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><span style="color:#ff9900;"><code>isEmpty()</code> 方法：这个方法用于检查数组是否为空。它通过检查 <code>arrayNumber</code> 是否等于 0 来确定数组是否为空。如果 <code>arrayNumber</code> 为 0，则返回 <code>true</code>，表示数组为空，否则返回 <code>false</code>。</span></strong></p> </li><li> <p><strong><span style="color:#ff9900;"><code>remove(int toRemove)</code> 方法：这个方法用于从数组中删除指定的元素 <code>toRemove</code>。首先，它会检查数组是否为空，如果数组为空，则抛出 <code>EmptyException</code> 异常。然后，它会调用 <code>indexOf(toRemove)</code> 方法来查找 <code>toRemove</code> 在数组中的索引位置。如果找不到目标元素，则直接返回，不做任何操作。如果找到了目标元素，则会从该索引位置开始，将后面的元素向前移动一位，覆盖掉要删除的元素。最后，将数组的元素数量 <code>arrayNumber</code> 减一，表示成功删除了一个元素。</span></strong></p> </li></ol> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%888%EF%BC%89%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%95%BF%E5%BA%A6">    <span style="color:#4da8ee;">    （8）获取顺序表长度</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">public int size() {
        return this.arrayNumber;
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>这里不做过多的解释了！！！</strong></span></p> 
<p></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%889%EF%BC%89%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span style="color:#4da8ee;"><strong>        </strong>（9）打印顺序表</span></h3> 
<p><span style="color:#ffd900;"><strong>Java代码：</strong></span></p> 
<pre><code class="language-java">public void display() {
        //循环遍历输出
        for (int i = 0; i &lt; this.arrayNumber; i++) {
            System.out.print(this.array[i] + " ");
        }
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>这里就是最简单的循环遍历数组，将数组中的元素进行输出操作。</strong></span></p> 
<p><strong>        </strong><strong>这样我们就完成了顺序表中所有的方法的自我实现了，当然读者还可以自己为这个自我实现的顺序表添加一下方法。</strong></p> 
<p></p> 
<h2 id="3.%E6%80%BB%E7%BB%93%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0ArrayList"><span style="color:#956fe7;"><strong>3.</strong>总结自我实现ArrayList</span></h2> 
<p><strong>     <span style="color:#a2e043;">   从上边的文章中，我们自我创建了一个ArrayList，并且自我去实现了其中的方法，所以我们对上文进行一些总结，对于自我实现一个类似于ArrayList的数据结构的流程可以概括如下：</span></strong></p> 
<ol><li> <p><strong>确定数据结构</strong>：选择合适的数据结构来存储元素。通常使用数组作为基础数据结构。</p> </li><li> <p><strong>定义类和成员变量</strong>：创建一个类来表示 <code>ArrayList</code>，定义数组作为存储元素的数据结构，并定义一个表示数组当前大小的变量。</p> </li><li> <p><strong>实现构造方法</strong>：编写构造方法初始化数组和其他必要的变量。</p> </li><li> <p><strong>实现添加元素方法</strong>：编写方法来添加新的元素到数组中。需要考虑数组已满时的动态扩容。</p> </li><li> <p><strong>实现获取元素方法</strong>：编写方法通过索引获取数组中的元素。</p> </li><li> <p><strong>实现删除元素方法</strong>：编写方法来删除指定位置的元素。需要考虑删除元素后，保持数组的连续性。</p> </li><li> <p><strong>实现其他操作方法</strong>：根据需要实现其他方法，如获取数组大小、清空数组、判断数组是否为空等。</p> </li><li> <p><strong>异常处理</strong>：考虑可能出现的异常情况，如访问空数组、越界访问等，并进行适当的异常处理。</p> </li></ol> 
<p><span style="color:#fe2c24;"><strong>最后，我们附上自我实现的ArrayList的类的完整代码：</strong></span></p> 
<pre><code class="language-java">public class MyArrayList {
    private int[] array;
    private int arrayNumber;
    public static final int CAPACITY = 10;

    //构造方法
    public MyArrayList() {
        this.array = new int[CAPACITY];
        this.arrayNumber = 0;
    }

    public boolean isFull() {
        return this.array.length == this.arrayNumber;
    }

    private void beBig() {
        this.array = Arrays.copyOf(this.array, this.array.length * 2);
    }

    public void add(int data) {
        //判断是否已满
        if (isFull()) {
            //顺序表满了就进行扩容
            beBig();
        }
        //顺序表未满，添加元素
        this.array[this.arrayNumber] = data;
        this.arrayNumber++;
    }

    public void display() {
        for (int i = 0; i &lt; this.arrayNumber; i++) {
            System.out.print(this.array[i] + " ");
        }
    }

    public void add(int pos, int data) throws IndexException {
        if (pos &lt; 0 || pos &gt; this.arrayNumber) {
            throw new IndexException("索引异常！！！");
        } else {
            if (isFull()) {
                beBig();
            } else {
                for (int i = this.arrayNumber - 1; i &gt;= pos; i--) {
                    this.array[i + 1] = this.array[i];
                }
                this.array[pos] = data;
                this.arrayNumber++;
            }
        }
    }

    public boolean contains(int toFind) {
        for (int i = 0; i &lt; this.arrayNumber; i++) {
            if (this.array[i] == toFind) {
                return true;
            }
        }
        return false;
    }

    public int indexOf(int toFind) {
        for (int i = 0; i &lt; this.arrayNumber; i++) {
            if (this.array[i] == toFind) {
                return i;
            }
        }
        return -1;
    }

    public boolean isEmpty() {
        return this.arrayNumber == 0;
    }

    public int get(int pos) throws EmptyException, IndexException {
        //判断数组是否为空
        if (isEmpty()) {
            throw new EmptyException("数组为空！！！");
        }
        //判断数组索引是否越界
        if (pos &lt; 0 || pos &gt;= this.arrayNumber) {
            throw new IndexException("索引异常！！！");
        }
        return this.array[pos];
    }

    public void set(int pos, int value) throws EmptyException, IndexException {
        //判断数组是否为空
        if (isEmpty()) {
            //抛出异常
            throw new EmptyException("数组为空！！！");
        }
        //判断数组索引是否越界
        if (pos &lt; 0 || pos &gt;= this.arrayNumber) {
            //抛出异常
            throw new IndexException("索引异常！！！");
        }
        this.array[pos] = value;
    }

    public void remove(int toRemove) throws EmptyException {
        //判断数组是否为空
        if (isEmpty()) {
            //抛出异常
            throw new EmptyException("数组为空！！！");
        }
        //遍历查找目标元素
        int index = indexOf(toRemove);
        if (index == -1) {
            return;
        }
        for (int i = index; i &lt; this.arrayNumber - 1; i++) {
            this.array[i] = this.array[i + 1];
        }
        this.arrayNumber--;
    }

    public int size() {
        return this.arrayNumber;
    }
    
}</code></pre> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>关于Java中顺序表的使用-------------------------------------------------------------------------</strong></span><span style="color:#fe2c24;"><strong>-------</strong></span><span style="color:#fe2c24;"><strong>----&gt;</strong></span><a href="https://blog.csdn.net/2302_80198073/article/details/139624004" title="Java数据结构之ArrayList（如果想知道Java中有关ArrayList的知识点，那么只看这一篇就足够了！）-CSDN博客">Java数据结构之ArrayList（如果想知道Java中有关ArrayList的知识点，那么只看这一篇就足够了！）-CSDN博客</a></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本片文章的全部内容了~~~</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c62b2591023ce2c4d909c0d0027a7bd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">相位解缠原理及传统算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0cbb808b368493ef70b78d5eee9549a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">6月ChatGPT商业运营网站程序源码，支持Midjourney绘画，GPT语音对话&#43;DALL-E3文生图&#43;suno-ai音乐生成&#43;TTS语音对话&#43;支持GPTs</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>