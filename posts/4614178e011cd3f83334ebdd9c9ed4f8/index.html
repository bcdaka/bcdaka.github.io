<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python酷库之旅-第三方库Pandas(007) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4614178e011cd3f83334ebdd9c9ed4f8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python酷库之旅-第三方库Pandas(007)">
  <meta property="og:description" content="目录
一、用法精讲
13、pandas.ExcelWriter类
13-1、语法
13-2、参数
13-3、功能
13-3-1、创建和写入Excel文件
13-3-2、自定义工作表
13-3-3、支持多种引擎
13-3-4、样式和格式化
13-3-5、处理已存在的工作表
13-4、返回值
13-5、说明
13-6、用法
13-6-1、数据准备
13-6-2、代码示例
13-6-3、结果输出
14、pandas.read_json函数
14-1、语法
14-2、参数
14-3、功能
14-4、返回值
14-5、说明
14-6、用法
14-6-1、数据准备
14-6-2、代码示例
14-6-3、结果输出 15、pandas.json_normalize函数
15-1、语法
15-2、参数
15-3、功能
15-4、返回值
15-5、说明
15-6、用法
15-6-1、数据准备
15-6-2、代码示例
15-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 13、pandas.ExcelWriter类 13-1、语法 # 13、pandas.ExcelWriter类 ExcelWriter(path: &#39;FilePath | WriteExcelBuffer | ExcelWriter&#39;, engine: &#39;str | None&#39; = None, date_format: &#39;str | None&#39; = None, datetime_format: &#39;str | None&#39; = None, mode: &#39;str&#39; = &#39;w&#39;, storage_options: &#39;StorageOptions | None&#39; = None, if_sheet_exists: &#39;ExcelWriterIfSheetExists | None&#39; = None, engine_kwargs: &#39;dict | None&#39; = None) -&gt; &#39;Self&#39; Class for writing DataFrame objects into excel sheets.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-07T07:45:00+08:00">
    <meta property="article:modified_time" content="2024-07-07T07:45:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python酷库之旅-第三方库Pandas(007)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong><span style="color:#1a439c;">目录</span></strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2-toc" style="margin-left:80px;"><strong><a href="#%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2" rel="nofollow"><span style="color:#1a439c;">一、用法精讲</span></a></strong></p> 
<p id="5%E3%80%81pandas.DataFrame.to_csv%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#5%E3%80%81pandas.DataFrame.to_csv%E5%87%BD%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">13、pandas.ExcelWriter类</span></a></strong></p> 
<p id="5-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#5-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">13-1、语法</span></a></strong></p> 
<p id="5-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:160px;"><strong><a href="#5-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">13-2、参数</span></a></strong></p> 
<p id="5-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:160px;"><strong><a href="#5-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">13-3、功能</span></a></strong></p> 
<p id="13-3-1%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%86%99%E5%85%A5Excel%E6%96%87%E4%BB%B6-toc" style="margin-left:200px;"><strong><a href="#13-3-1%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%86%99%E5%85%A5Excel%E6%96%87%E4%BB%B6" rel="nofollow"><span style="color:#1a439c;">13-3-1、创建和写入Excel文件</span></a></strong></p> 
<p id="13-3-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E8%A1%A8-toc" style="margin-left:200px;"><strong><a href="#13-3-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E8%A1%A8" rel="nofollow"><span style="color:#1a439c;">13-3-2、自定义工作表</span></a></strong></p> 
<p id="13-3-3%E3%80%81%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%BC%95%E6%93%8E-toc" style="margin-left:200px;"><strong><a href="#13-3-3%E3%80%81%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%BC%95%E6%93%8E" rel="nofollow"><span style="color:#1a439c;">13-3-3、支持多种引擎</span></a></strong></p> 
<p id="13-3-4%E3%80%81%E6%A0%B7%E5%BC%8F%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96-toc" style="margin-left:200px;"><strong><a href="#13-3-4%E3%80%81%E6%A0%B7%E5%BC%8F%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96" rel="nofollow"><span style="color:#1a439c;">13-3-4、样式和格式化</span></a></strong></p> 
<p id="13-3-5%E3%80%81%E5%A4%84%E7%90%86%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%A1%A8-toc" style="margin-left:200px;"><strong><a href="#13-3-5%E3%80%81%E5%A4%84%E7%90%86%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%A1%A8" rel="nofollow"><span style="color:#1a439c;">13-3-5、处理已存在的工作表</span></a></strong></p> 
<p id="5-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:160px;"><strong><a href="#5-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">13-4、返回值</span></a></strong></p> 
<p id="5-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:160px;"><strong><a href="#5-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">13-5、说明</span></a></strong></p> 
<p id="5-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#5-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">13-6、用法</span></a></strong></p> 
<p id="10-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:200px;"><strong><a href="#10-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow"><span style="color:#1a439c;">13-6-1、数据准备</span></a></strong></p> 
<p id="5-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:200px;"><strong><a href="#5-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">13-6-2、代码示例</span></a></strong></p> 
<p id="5-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA-toc" style="margin-left:200px;"><strong><a href="#5-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA" rel="nofollow"><span style="color:#1a439c;">13-6-3、结果输出</span></a></strong></p> 
<p id="11%E3%80%81pandas.ExcelFile%E7%B1%BB-toc" style="margin-left:120px;"><strong><a href="#11%E3%80%81pandas.ExcelFile%E7%B1%BB" rel="nofollow"><span style="color:#1a439c;">14、pandas.read_json函数</span></a></strong></p> 
<p id="11-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#11-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">14-1、语法</span></a></strong></p> 
<p id="11-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:160px;"><strong><a href="#11-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">14-2、参数</span></a></strong></p> 
<p id="11-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:160px;"><strong><a href="#11-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">14-3、功能</span></a></strong></p> 
<p id="11-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:160px;"><strong><a href="#11-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">14-4、返回值</span></a></strong></p> 
<p id="11-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:160px;"><strong><a href="#11-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">14-5、说明</span></a></strong></p> 
<p id="11-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#11-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">14-6、用法</span></a></strong></p> 
<p id="11-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:200px;"><strong><a href="#11-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow"><span style="color:#1a439c;">14-6-1、数据准备</span></a></strong></p> 
<p id="11-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:200px;"><strong><a href="#11-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">14-6-2、代码示例</span></a></strong></p> 
<p id="11-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0-toc" style="margin-left:200px;"><strong><a href="#11-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0" rel="nofollow"><span style="color:#1a439c;">14-6-3、结果输出 </span></a></strong></p> 
<p id="12%E3%80%81pandas.ExcelFile.parse%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#12%E3%80%81pandas.ExcelFile.parse%E5%87%BD%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">15、pandas.json_normalize函数</span></a></strong></p> 
<p id="12-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#12-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">15-1、语法</span></a></strong></p> 
<p id="12-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:160px;"><strong><a href="#12-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">15-2、参数</span></a></strong></p> 
<p id="12-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:160px;"><strong><a href="#12-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">15-3、功能</span></a></strong></p> 
<p id="12-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:160px;"><strong><a href="#12-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">15-4、返回值</span></a></strong></p> 
<p id="12-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:160px;"><strong><a href="#12-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">15-5、说明</span></a></strong></p> 
<p id="12-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#12-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">15-6、用法</span></a></strong></p> 
<p id="12-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:200px;"><strong><a href="#12-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow"><span style="color:#1a439c;">15-6-1、数据准备</span></a></strong></p> 
<p id="12-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:200px;"><strong><a href="#12-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">15-6-2、代码示例</span></a></strong></p> 
<p id="12-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0-toc" style="margin-left:200px;"><strong><a href="#12-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0" rel="nofollow"><span style="color:#1a439c;">15-6-3、结果输出 </span></a></strong></p> 
<p id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB-toc" style="margin-left:80px;"><strong><a href="#%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" rel="nofollow"><span style="color:#1a439c;">二、推荐阅读</span></a></strong></p> 
<p id="1%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81" rel="nofollow"><span style="color:#1a439c;">1、Python筑基之旅</span></a></strong></p> 
<p id="2%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#2%E3%80%81" rel="nofollow"><span style="color:#1a439c;">2、Python函数之旅</span></a></strong></p> 
<p id="3%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#3%E3%80%81" rel="nofollow"><span style="color:#1a439c;">3、Python算法之旅</span></a></strong></p> 
<p id="4%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#4%E3%80%81" rel="nofollow"><span style="color:#1a439c;">4、Python魔法之旅</span></a></strong></p> 
<p id="5%E3%80%81%C2%A0-toc" style="margin-left:120px;"><strong><a href="#5%E3%80%81%C2%A0" rel="nofollow"><span style="color:#1a439c;">5、博客个人主页</span></a></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bc/3f/K4c75KBo_o.gif"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2e/b1/9wlDx411_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ce/39/cRWw8xWK_o.gif"></p> 
<h4 id="%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2">一、用法精讲</h4> 
<h5 id="5%E3%80%81pandas.DataFrame.to_csv%E5%87%BD%E6%95%B0">13、<span style="color:#fe2c24;">pandas.ExcelWriter</span>类</h5> 
<h6 id="5-1%E3%80%81%E8%AF%AD%E6%B3%95">13-1、语法</h6> 
<pre><code class="language-python"># 13、pandas.ExcelWriter类
ExcelWriter(path: 'FilePath | WriteExcelBuffer | ExcelWriter', engine: 'str | None' = None, date_format: 'str | None' = None, datetime_format: 'str | None' = None, mode: 'str' = 'w', storage_options: 'StorageOptions | None' = None, if_sheet_exists: 'ExcelWriterIfSheetExists | None' = None, engine_kwargs: 'dict | None' = None) -&gt; 'Self'
   
   Class for writing DataFrame objects into excel sheets.
   
   Default is to use:
   
   * `xlsxwriter &lt;https://pypi.org/project/XlsxWriter/&gt;`__ for xlsx files if xlsxwriter
     is installed otherwise `openpyxl &lt;https://pypi.org/project/openpyxl/&gt;`__
   * `odswriter &lt;https://pypi.org/project/odswriter/&gt;`__ for ods files
   
   See ``DataFrame.to_excel`` for typical usage.
   
   The writer should be used as a context manager. Otherwise, call `close()` to save
   and close any opened file handles.
   
   Parameters
   ----------
   path : str or typing.BinaryIO
       Path to xls or xlsx or ods file.
   engine : str (optional)
       Engine to use for writing. If None, defaults to
       ``io.excel.&lt;extension&gt;.writer``.  NOTE: can only be passed as a keyword
       argument.
   date_format : str, default None
       Format string for dates written into Excel files (e.g. 'YYYY-MM-DD').
   datetime_format : str, default None
       Format string for datetime objects written into Excel files.
       (e.g. 'YYYY-MM-DD HH:MM:SS').
   mode : {'w', 'a'}, default 'w'
       File mode to use (write or append). Append does not work with fsspec URLs.
   storage_options : dict, optional
       Extra options that make sense for a particular storage connection, e.g.
       host, port, username, password, etc. For HTTP(S) URLs the key-value pairs
       are forwarded to ``urllib.request.Request`` as header options. For other
       URLs (e.g. starting with "s3://", and "gcs://") the key-value pairs are
       forwarded to ``fsspec.open``. Please see ``fsspec`` and ``urllib`` for more
       details, and for more examples on storage options refer `here
       &lt;https://pandas.pydata.org/docs/user_guide/io.html?
       highlight=storage_options#reading-writing-remote-files&gt;`_.
   
   if_sheet_exists : {'error', 'new', 'replace', 'overlay'}, default 'error'
       How to behave when trying to write to a sheet that already
       exists (append mode only).
   
       * error: raise a ValueError.
       * new: Create a new sheet, with a name determined by the engine.
       * replace: Delete the contents of the sheet before writing to it.
       * overlay: Write contents to the existing sheet without first removing,
         but possibly over top of, the existing contents.
   
       .. versionadded:: 1.3.0
   
       .. versionchanged:: 1.4.0
   
          Added ``overlay`` option
   
   engine_kwargs : dict, optional
       Keyword arguments to be passed into the engine. These will be passed to
       the following functions of the respective engines:
   
       * xlsxwriter: ``xlsxwriter.Workbook(file, **engine_kwargs)``
       * openpyxl (write mode): ``openpyxl.Workbook(**engine_kwargs)``
       * openpyxl (append mode): ``openpyxl.load_workbook(file, **engine_kwargs)``
       * odswriter: ``odf.opendocument.OpenDocumentSpreadsheet(**engine_kwargs)``
   
       .. versionadded:: 1.3.0
   
   Notes
   -----
   For compatibility with CSV writers, ExcelWriter serializes lists
   and dicts to strings before writing.</code></pre> 
<h6 id="5-2%E3%80%81%E5%8F%82%E6%95%B0">13-2、参数</h6> 
<p><span style="color:#fe2c24;"><strong>13-2-1、path</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串，表示要写入的Excel文件的路径(包括文件名)。</p> 
<p><strong><span style="color:#fe2c24;">13-2-2、engine</span><span style="color:#956fe7;">(可选，默认值为None)</span><span style="color:#fe2c24;">：</span></strong>字符串，表示用于写入Excel文件的引擎。Pandas支持多种引擎，如xlsxwriter、openpyxl、odswriter(仅适用于.ods文件)等，如果未指定，Pandas将根据文件扩展名自动选择。</p> 
<p><span style="color:#fe2c24;"><strong>13-2-3、date_format</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串，表示用于写入Excel文件的日期格式。如果DataFrame中包含日期类型的数据，并且您希望以特定格式保存它们，可以使用此参数。注意，这不会更改DataFrame中的数据，只影响写入Excel文件时的显示格式。</p> 
<p><strong><span style="color:#fe2c24;">13-2-4、datetime_format</span><span style="color:#956fe7;">(可选，默认值为None)</span><span style="color:#fe2c24;">：</span></strong>类似于date_format，但用于日期时间类型的数据。</p> 
<p><strong><span style="color:#fe2c24;">13-2-5、mode</span><span style="color:#956fe7;">(可选，默认值为'w')</span><span style="color:#fe2c24;">：</span></strong>表示文件打开模式。'w'表示写入模式(如果文件已存在，则覆盖)，'a'表示追加模式(注意，Excel文件通常不支持传统意义上的追加，因此该参数在ExcelWriter中可能不太有用，且其行为可能因引擎而异)。</p> 
<p><strong><span style="color:#fe2c24;">13-2-6、storage_options</span><span style="color:#956fe7;">(可选，默认值为None)</span><span style="color:#fe2c24;">：</span></strong>对于需要额外存储选项的存储连接(如HTTP、S3等)，可以传递一个字典作为此参数，这些选项将传递给底层的存储系统。</p> 
<p><strong><span style="color:#fe2c24;">13-2-7、if_sheet_exists</span><span style="color:#956fe7;">(可选，默认值为None)</span><span style="color:#fe2c24;">：</span></strong>当尝试写入已存在的工作表时，此参数控制行为。'error'(默认值，如果未指定)将引发错误；'new' 将创建一个新工作表(以数字为后缀)；'replace' 将替换现有工作表的内容。请注意，并非所有引擎都支持此参数。</p> 
<p><strong><span style="color:#fe2c24;">13-2-8、engine_kwargs</span><span style="color:#956fe7;">(可选，默认值为None)</span><span style="color:#fe2c24;">：</span></strong>一个字典，包含要传递给Excel写入引擎的额外关键字参数，这允许您利用引擎提供的特定功能，如设置工作簿的属性或样式。</p> 
<h6 id="5-3%E3%80%81%E5%8A%9F%E8%83%BD">13-3、功能</h6> 
<h6 id="13-3-1%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%86%99%E5%85%A5Excel%E6%96%87%E4%BB%B6">13-3-1、<strong>创建和写入Excel文件</strong></h6> 
<p>13-3-1-1<code>、</code>pandas.ExcelWriter类允许用户指定Excel文件的路径和名称，并创建该文件(如果文件不存在)或覆盖现有文件(如果文件已存在，并且以写入模式打开)。</p> 
<p>13-3-1-2、用户可以将多个DataFrame对象写入到同一个Excel文件的不同工作表中，或者将单个DataFrame写入到指定的工作表中。</p> 
<h6 id="13-3-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E8%A1%A8">13-3-2、自定义工作表</h6> 
<p>13-3-2-1、在写入DataFrame时，用户可以指定工作表的名称，以及是否包含DataFrame的索引列和列名。</p> 
<p>13-3-2-2、用户还可以控制DataFrame数据在工作表中的起始位置和范围，例如通过指定起始行和列。</p> 
<h6 id="13-3-3%E3%80%81%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%BC%95%E6%93%8E">13-3-3、支持多种引擎</h6> 
<p>        pandas.ExcelWriter支持多种写入引擎，如xlsxwriter、openpyxl和odswriter(对于.ods文件)，这些引擎提供了不同的功能和性能特点，用户可以根据需要选择合适的引擎。</p> 
<h6 id="13-3-4%E3%80%81%E6%A0%B7%E5%BC%8F%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96">13-3-4、<strong>样式和格式化</strong></h6> 
<p>        尽管pandas.ExcelWriter本身主要关注于数据的写入，但用户可以通过与引擎结合使用(如xlsxwriter的样式和格式化功能)，来自定义Excel文件的外观，包括单元格的字体、颜色、边框等。</p> 
<h6 id="13-3-5%E3%80%81%E5%A4%84%E7%90%86%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%A1%A8">13-3-5、处理已存在的工作表</h6> 
<p>        在某些情况下，用户可能需要向已存在的Excel文件中的工作表写入数据。虽然Excel文件本身不支持传统意义上的追加，但用户可以通过读取文件、合并数据、然后重新写入的方式来实现这一需求，if_sheet_exists参数提供了在写入已存在工作表时的行为控制。</p> 
<h6 id="5-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">13-4、返回值</h6> 
<p>13-4-1<code>、</code>pandas.ExcelWriter类本身并不直接返回数据，它的主要作用是提供一个上下文管理器(通过with语句)或一个可调用对象(通过调用save()方法)，用于将DataFrame数据写入到Excel文件中。</p> 
<p>13-4-2、当使用with语句时，pandas.ExcelWriter会在代码块执行完毕后自动关闭文件并释放资源，无需显式调用save()方法。</p> 
<p>13-4-3、如果不使用with语句，则需要在数据写入完成后显式调用save()方法来保存文件并关闭ExcelWriter对象。</p> 
<h6 id="5-5%E3%80%81%E8%AF%B4%E6%98%8E">13-5、说明</h6> 
<p>        无</p> 
<h6 id="5-6%E3%80%81%E7%94%A8%E6%B3%95">13-6、用法</h6> 
<h6 id="10-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">13-6-1、数据准备</h6> 
<pre><code class="language-python">无</code></pre> 
<h6 id="5-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">13-6-2、代码示例</h6> 
<pre><code class="language-python"># 13、pandas.ExcelWriter类
# 13-1、将单个DataFrame写入Excel文件
import pandas as pd
# 创建一个简单的 DataFrame
df = pd.DataFrame({
    'Name': ['John', 'Anna', 'Peter', 'Linda'],
    'Age': [28, 34, 29, 32],
    'City': ['New York', 'Paris', 'Berlin', 'London']
})
# 使用ExcelWriter写入Excel文件
with pd.ExcelWriter('output.xlsx', engine='xlsxwriter') as writer:
    df.to_excel(writer, sheet_name='Sheet1', index=False)
# 注意：这里使用了 with 语句，它会自动处理文件的打开和关闭
# 将excel文件中Sheet1的内容打印出来
xls = pd.ExcelFile('output.xlsx', engine='openpyxl')
# 通过ExcelFile对象读取工作表
df1= pd.read_excel(xls, sheet_name='Sheet1')
print(df)
print()

# 13-2、将多个DataFrame写入同一个Excel文件的不同工作表
import pandas as pd
# 创建两个DataFrame
df1 = pd.DataFrame({
    'Name': ['John', 'Anna'],
    'Age': [28, 34]
})
df2 = pd.DataFrame({
    'City': ['New York', 'Paris', 'Berlin'],
    'Country': ['USA', 'France', 'Germany']
})
# 使用ExcelWriter写入多个工作表
with pd.ExcelWriter('output_multiple_sheets.xlsx', engine='xlsxwriter') as writer:
    df1.to_excel(writer, sheet_name='People', index=False)
    df2.to_excel(writer, sheet_name='Places', index=False)
# 注意：这里也使用了with语句
# 将excel文件中不用工作表的内容打印出来
xls = pd.ExcelFile('output_multiple_sheets.xlsx', engine='openpyxl')
# 通过ExcelFile对象读取工作表
df1 = pd.read_excel(xls, sheet_name='People')
df2 = pd.read_excel(xls, sheet_name='Places')
print(df1)
print()
print(df2)
print()

# 13-3、使用xlsxwriter引擎添加样式
import pandas as pd
# 创建一个DataFrame
df = pd.DataFrame({
    'Data': [10, 20, 30, 20, 15, 30, 45]
})
# 使用ExcelWriter和xlsxwriter引擎，并添加样式
with pd.ExcelWriter('output_with_styles.xlsx', engine='xlsxwriter') as writer:
    # 转换DataFrame到Excel
    df.to_excel(writer, sheet_name='Sheet1', index=False)
    # 获取xlsxwriter的工作簿和工作表对象
    workbook = writer.book
    worksheet = writer.sheets['Sheet1']
    # 创建一个格式，加粗并设置字体颜色
    bold = workbook.add_format({'bold': True, 'font_color': 'red'})
    # 应用格式到第一列
    worksheet.set_column('A:A', None, bold)
# 注意：这里使用了xlsxwriter的功能来添加样式
# 将excel文件中Sheet1的内容打印出来
xls = pd.ExcelFile('output_with_styles.xlsx', engine='openpyxl')
# 通过ExcelFile对象读取工作表
df1= pd.read_excel(xls, sheet_name='Sheet1')
print(df)</code></pre> 
<h6 id="5-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA">13-6-3、结果输出</h6> 
<pre><code class="language-python"># 13、pandas.ExcelWriter类
# 13-1、将单个DataFrame写入Excel文件
#     Name  Age      City
# 0   John   28  New York
# 1   Anna   34     Paris
# 2  Peter   29    Berlin
# 3  Linda   32    London

# 13-2、将多个DataFrame写入同一个Excel文件的不同工作表
#    Name  Age
# 0  John   28
# 1  Anna   34
# 
#        City  Country
# 0  New York      USA
# 1     Paris   France
# 2    Berlin  Germany

# 13-3、使用xlsxwriter引擎添加样式
#    Data
# 0    10
# 1    20
# 2    30
# 3    20
# 4    15
# 5    30
# 6    45</code></pre> 
<h5 id="11%E3%80%81pandas.ExcelFile%E7%B1%BB">14、<span style="color:#fe2c24;">pandas.read_json</span>函数</h5> 
<h6 id="11-1%E3%80%81%E8%AF%AD%E6%B3%95">14-1、语法</h6> 
<pre><code class="language-python"># 14、pandas.read_json函数
pandas.read_json(path_or_buf, *, orient=None, typ='frame', dtype=None, convert_axes=None, convert_dates=True, keep_default_dates=True, precise_float=False, date_unit=None, encoding=None, encoding_errors='strict', lines=False, chunksize=None, compression='infer', nrows=None, storage_options=None, dtype_backend=_NoDefault.no_default, engine='ujson')
Convert a JSON string to pandas object.

Parameters:
path_or_bufa valid JSON str, path object or file-like object
Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: file://localhost/path/to/table.json.

If you want to pass in a path object, pandas accepts any os.PathLike.

By file-like object, we refer to objects with a read() method, such as a file handle (e.g. via builtin open function) or StringIO.

Deprecated since version 2.1.0: Passing json literal strings is deprecated.

orientstr, optional
Indication of expected JSON string format. Compatible JSON strings can be produced by to_json() with a corresponding orient value. The set of possible orients is:

'split' : dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}

'records' : list like [{column -&gt; value}, ... , {column -&gt; value}]

'index' : dict like {index -&gt; {column -&gt; value}}

'columns' : dict like {column -&gt; {index -&gt; value}}

'values' : just the values array

'table' : dict like {'schema': {schema}, 'data': {data}}

The allowed and default values depend on the value of the typ parameter.

when typ == 'series',

allowed orients are {'split','records','index'}

default is 'index'

The Series index must be unique for orient 'index'.

when typ == 'frame',

allowed orients are {'split','records','index', 'columns','values', 'table'}

default is 'columns'

The DataFrame index must be unique for orients 'index' and 'columns'.

The DataFrame columns must be unique for orients 'index', 'columns', and 'records'.

typ{‘frame’, ‘series’}, default ‘frame’
The type of object to recover.

dtypebool or dict, default None
If True, infer dtypes; if a dict of column to dtype, then use those; if False, then don’t infer dtypes at all, applies only to the data.

For all orient values except 'table', default is True.

convert_axesbool, default None
Try to convert the axes to the proper dtypes.

For all orient values except 'table', default is True.

convert_datesbool or list of str, default True
If True then default datelike columns may be converted (depending on keep_default_dates). If False, no dates will be converted. If a list of column names, then those columns will be converted and default datelike columns may also be converted (depending on keep_default_dates).

keep_default_datesbool, default True
If parsing dates (convert_dates is not False), then try to parse the default datelike columns. A column label is datelike if

it ends with '_at',

it ends with '_time',

it begins with 'timestamp',

it is 'modified', or

it is 'date'.

precise_floatbool, default False
Set to enable usage of higher precision (strtod) function when decoding string to double values. Default (False) is to use fast but less precise builtin functionality.

date_unitstr, default None
The timestamp unit to detect if converting dates. The default behaviour is to try and detect the correct precision, but if this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force parsing only seconds, milliseconds, microseconds or nanoseconds respectively.

encodingstr, default is ‘utf-8’
The encoding to use to decode py3 bytes.

encoding_errorsstr, optional, default “strict”
How encoding errors are treated. List of possible values .

New in version 1.3.0.

linesbool, default False
Read the file as a json object per line.

chunksizeint, optional
Return JsonReader object for iteration. See the line-delimited json docs for more information on chunksize. This can only be passed if lines=True. If this is None, the file will be read into memory all at once.

compressionstr or dict, default ‘infer’
For on-the-fly decompression of on-disk data. If ‘infer’ and ‘path_or_buf’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). If using ‘zip’ or ‘tar’, the ZIP file must contain only one data file to be read in. Set to None for no decompression. Can also be a dict with key 'method' set to one of {'zip', 'gzip', 'bz2', 'zstd', 'xz', 'tar'} and other key-value pairs are forwarded to zipfile.ZipFile, gzip.GzipFile, bz2.BZ2File, zstandard.ZstdDecompressor, lzma.LZMAFile or tarfile.TarFile, respectively. As an example, the following could be passed for Zstandard decompression using a custom compression dictionary: compression={'method': 'zstd', 'dict_data': my_compression_dict}.

New in version 1.5.0: Added support for .tar files.

Changed in version 1.4.0: Zstandard support.

nrowsint, optional
The number of lines from the line-delimited jsonfile that has to be read. This can only be passed if lines=True. If this is None, all the rows will be returned.

storage_optionsdict, optional
Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to urllib.request.Request as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to fsspec.open. Please see fsspec and urllib for more details, and for more examples on storage options refer here.

dtype_backend{‘numpy_nullable’, ‘pyarrow’}, default ‘numpy_nullable’
Back-end data type applied to the resultant DataFrame (still experimental). Behaviour is as follows:

"numpy_nullable": returns nullable-dtype-backed DataFrame (default).

"pyarrow": returns pyarrow-backed nullable ArrowDtype DataFrame.

New in version 2.0.

engine{“ujson”, “pyarrow”}, default “ujson”
Parser engine to use. The "pyarrow" engine is only available when lines=True.

New in version 2.0.

Returns:
Series, DataFrame, or pandas.api.typing.JsonReader
A JsonReader is returned when chunksize is not 0 or None. Otherwise, the type returned depends on the value of typ.</code></pre> 
<h6 id="11-2%E3%80%81%E5%8F%82%E6%95%B0">14-2、参数</h6> 
<p><span style="color:#fe2c24;"><strong>14-2-1、path_or_buf</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串、文件对象或类文件对象，表示JSON数据的路径或缓冲区。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-2、orient</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串，用于指示JSON文件中数据的期望格式。</p> 
<p>14-2-2-1、'split'：字典像<code>{index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</code>。</p> 
<p>14-2-2-2、'records'： 列表像<code>[{column -&gt; value}, ... , {column -&gt; value}]</code>。</p> 
<p>14-2-2-3、'index'： 字典像<code>index -&gt; {column -&gt; value}}</code>，其中索引是JSON对象中的键。</p> 
<p>14-2-2-4、'columns'： 字典像<code>{<!-- -->{column -&gt; index} -&gt; value}</code>。</p> 
<p>14-2-2-5、'values'： 仅仅是值数组。</p> 
<p>14-2-2-6、如果没有指定，Pandas会尝试自动推断。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-3、typ</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'frame')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串，{'frame', 'series'}，指定返回对象的类型。默认为 'frame'，即DataFrame；如果设置为'series'，则返回Series。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-4、dtype</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>单个类型或字典，用于强制指定列的数据类型。如果传入的是字典，键是列名，值是数据类型。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-5、convert_axes</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>布尔值，是否将轴(轴标签)转换为DatetimeIndex。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-6、convert_dates</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>布尔值，是否尝试将日期字符串转换为日期对象。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-7、keep_default_dates</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>布尔值，如果解析日期时遇到无法识别的日期，是否使用默认日期值(NaT)。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-8、precise_float</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为False)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>布尔值，是否在解析浮点数时以更精确的方式处理(使用高精度小数库)。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-9、date_unit</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串，用于解析日期字符串的字符串单位，如 's', 'ms', 'us' 等，如果未指定，将尝试自动推断。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-10、encoding</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串，用于文件的编码。如果为None，则使用系统默认编码。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-11、encoding_errors</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'strict')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串，指定如何处理编码错误。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-12、lines</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为False)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>布尔值，如果为True，则假定文件是一个JSON对象的换行分隔的列表。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-13、chunksize</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>整数，返回对象的迭代器，每个迭代器的数据块大小为指定的行数，这对于处理大文件很有用。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-14、compression</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'infer')</strong></span>：{'infer', 'gzip', 'bz2', 'zip', 'xz', None}，用于解压文件的压缩格式。如果设置为'infer'，则自动检测压缩格式。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-15、nrows</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>整数，需要读取的行数(对于JSON行文件)。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-16、storage_options</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字典，用于文件存储的额外选项，如AWS S3访问密钥。</p> 
<p><span style="color:#fe2c24;"><strong>14-2-17、dtype_backend</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>内部使用，通常不需要用户指定。</p> 
<p><strong><span style="color:#fe2c24;">14-2-18、 engine</span><span style="color:#956fe7;">(可选，默认值为'ujson')</span><span style="color:#fe2c24;">：</span></strong>字符串，用于解析JSON的引擎。默认为'ujson'，也可以使用'python'(标准库)。</p> 
<h6 id="11-3%E3%80%81%E5%8A%9F%E8%83%BD">14-3、功能</h6> 
<p>        读取JSON格式的数据，并将其转换成Pandas的DataFrame或Series对象。</p> 
<h6 id="11-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">14-4、返回值</h6> 
<p>14-4-1、当typ='frame'(默认值)时，返回一个Pandas DataFrame对象。DataFrame是一个二维标签数据结构，可以存储具有不同数据类型的表格数据。</p> 
<p>14-4-2、当typ='series'时，返回一个Pandas Series对象。Series是一种一维数组结构，可以存储任何数据类型(整数、字符串、浮点数、Python 对象等)，每个元素都有一个标签(索引)。</p> 
<h6 id="11-5%E3%80%81%E8%AF%B4%E6%98%8E">14-5、说明</h6> 
<p>        该函数对于数据分析、数据清洗和数据处理任务非常有用，因为Pandas提供了丰富的数据操作功能。    </p> 
<h6 id="11-6%E3%80%81%E7%94%A8%E6%B3%95">14-6、用法</h6> 
<h6 id="11-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">14-6-1、数据准备</h6> 
<pre><code class="language-python"># 创建.json文件example.json
# 方法1：直接使用Pandas库创建
import pandas as pd
# 创建一个包含数据的字典列表
data = [
    {"name": "John", "age": 30, "city": "New York"},
    {"name": "Anna", "age": 25, "city": "Paris"}
]
# 将字典列表转换为DataFrame
df = pd.DataFrame(data)
# 将DataFrame保存为JSON文件，指定orient='records'以得到你想要的格式
df.to_json('example.json', orient='records', lines=True, index=False)
# 注意：
# - orient='records' 告诉pandas以记录列表的形式导出JSON，每个记录是一个字典。
# - lines=True 表示将每个记录输出为一行，这有助于在读取大型文件时节省内存。
# - index=False 表示不将DataFrame的索引作为JSON对象的一部分输出。

# 方法2：使用标准库json创建(推荐)
import pandas as pd
import json
# 创建一个包含数据的字典列表
data = [
    {"name": "John", "age": 30, "city": "New York"},
    {"name": "Anna", "age": 25, "city": "Paris"}
]
# 将字典列表转换为DataFrame
df = pd.DataFrame(data)
# 将DataFrame转换为记录列表
records = df.to_dict(orient='records')
# 使用json模块将记录列表写入文件
with open('example.json', 'w') as f:
    json.dump(records, f)
# 现在，'example.json' 包含了一个严格的JSON数组。
</code></pre> 
<h6 id="11-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">14-6-2、代码示例</h6> 
<pre><code class="language-python"># 14、pandas.read_json函数
# 14-1、从JSON字符串读取
import pandas as pd
# JSON 字符串
json_str = '''  
[  
  {"name": "John", "age": 30, "city": "New York"},  
  {"name": "Anna", "age": 25, "city": "Paris"}  
]  
'''
# 从JSON字符串读取数据
df = pd.read_json(json_str, orient='records')
print(df, end='\n\n')

# 14-2、从JSON文件中读取
import pandas as pd
# 从JSON文件读取数据
df = pd.read_json('example.json', orient='records')
print(df, end='\n\n')

# 14-3、读取具有不同orient的JSON
import pandas as pd
# JSON字符串，使用'split'orient
json_str = '''  
{  
  "columns": ["name", "age", "city"],  
  "index": [0, 1],  
  "data": [  
    ["John", 30, "New York"],  
    ["Anna", 25, "Paris"]  
  ]  
}  
'''
# 从JSON字符串读取数据，使用'split'orient
df = pd.read_json(json_str, orient='split')
print(df, end='\n\n')</code></pre> 
<h6 id="11-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0">14-6-3、结果输出 </h6> 
<pre><code class="language-python"># 14、pandas.read_json函数
# 14-1、从JSON字符串读取
#    name  age      city
# 0  John   30  New York
# 1  Anna   25     Paris

# 14-2、从JSON文件中读取
#    name  age      city
# 0  John   30  New York
# 1  Anna   25     Paris

# 14-3、读取具有不同orient的JSON
#    name  age      city
# 0  John   30  New York
# 1  Anna   25     Paris</code></pre> 
<h5 id="12%E3%80%81pandas.ExcelFile.parse%E5%87%BD%E6%95%B0">15、<span style="color:#fe2c24;">pandas.json_normalize</span>函数</h5> 
<h6 id="12-1%E3%80%81%E8%AF%AD%E6%B3%95">15-1、语法</h6> 
<pre><code class="language-python"># 15、pandas.json_normalize函数
pandas.json_normalize(data, record_path=None, meta=None, meta_prefix=None, record_prefix=None, errors='raise', sep='.', max_level=None)
Normalize semi-structured JSON data into a flat table.

Parameters:
data
dict or list of dicts
Unserialized JSON objects.

record_path
str or list of str, default None
Path in each object to list of records. If not passed, data will be assumed to be an array of records.

meta
list of paths (str or list of str), default None
Fields to use as metadata for each record in resulting table.

meta_prefix
str, default None
If True, prefix records with dotted (?) path, e.g. foo.bar.field if meta is [‘foo’, ‘bar’].

record_prefix
str, default None
If True, prefix records with dotted (?) path, e.g. foo.bar.field if path to records is [‘foo’, ‘bar’].

errors
{‘raise’, ‘ignore’}, default ‘raise’
Configures error handling.

‘ignore’ : will ignore KeyError if keys listed in meta are not always present.

‘raise’ : will raise KeyError if keys listed in meta are not always present.

sep
str, default ‘.’
Nested records will generate names separated by sep. e.g., for sep=’.’, {‘foo’: {‘bar’: 0}} -&gt; foo.bar.

max_level
int, default None
Max number of levels(depth of dict) to normalize. if None, normalizes all levels.

Returns:
frame
DataFrame
Normalize semi-structured JSON data into a flat table.
</code></pre> 
<h6 id="12-2%E3%80%81%E5%8F%82%E6%95%B0">15-2、参数</h6> 
<p><span style="color:#fe2c24;"><strong>15-2-1、data</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个字典、一个字典的列表，或者是任何可以转换为JSON格式的Python对象，表示要扁平化的JSON对象或对象列表。</p> 
<p><span style="color:#fe2c24;"><strong>15-2-2、record_path</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定JSON对象中应该被当作记录(即DataFrame的行)的路径。如果指定了record_path，函数将仅从这些路径中提取记录，并尝试将这些记录展平；如果不指定，函数将尝试将整个输入对象展平。</p> 
<p><span style="color:#fe2c24;"><strong>15-2-3、meta</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定JSON对象中应该作为元数据(即不展平，直接添加到DataFrame中的列)的键的列表，这些列将保留其原始JSON值。</p> 
<p><span style="color:#fe2c24;"><strong>15-2-4、meta_prefix</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>为元数据列添加的前缀，这有助于区分元数据列和其他由JSON数据生成的列。</p> 
<p><span style="color:#fe2c24;"><strong>15-2-5、record_prefix</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>为从record_path指定的记录中提取的列添加的前缀，这有助于在结果DataFrame中区分来自不同记录的列。</p> 
<p><span style="color:#fe2c24;"><strong>15-2-6、errors</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'raise')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定在遇到JSON解析错误时的行为。如果设置为'raise'(默认值)，则抛出错误；如果设置为'ignore'，则忽略错误并继续处理。</p> 
<p><strong><span style="color:#fe2c24;">15-2-7、sep</span><span style="color:#956fe7;">(可选，默认值为'.')</span><span style="color:#fe2c24;">：</span></strong>用于连接嵌套字典键的分隔符，在将嵌套键展平为列名时使用。</p> 
<p><span style="color:#fe2c24;"><strong>15-2-8、max_level</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定展平过程中要处理的最大嵌套级别。默认值是None，表示不限制嵌套级别。</p> 
<h6 id="12-3%E3%80%81%E5%8A%9F%E8%83%BD">15-3、功能</h6> 
<p>        用于将半结构化的JSON数据扁平化为表格形式(DataFrame)。</p> 
<h6 id="12-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">15-4、返回值</h6> 
<p>        返回值是一个DataFrame对象。</p> 
<h6 id="12-5%E3%80%81%E8%AF%B4%E6%98%8E">15-5、说明</h6> 
<p>        无</p> 
<h6 id="12-6%E3%80%81%E7%94%A8%E6%B3%95">15-6、用法</h6> 
<h6 id="12-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">15-6-1、数据准备</h6> 
<pre><code class="language-python"># 创建.json文件example.json
# 方法1：直接使用Pandas库创建
import pandas as pd
# 创建一个包含数据的字典列表
data = [
    {
        "id": 1,
        "info": {"name": "Alice", "age": 30},
        "hobbies": ["reading", "cycling"]
    },
    {
        "id": 2,
        "info": {"name": "Bob", "age": 25},
        "hobbies": ["swimming", "coding"]
    }
]

# 将字典列表转换为DataFrame
df = pd.DataFrame(data)
# 将DataFrame保存为JSON文件，指定orient='records'以得到你想要的格式
df.to_json('example.json', orient='records', lines=True, index=False)
# 注意：
# - orient='records' 告诉pandas以记录列表的形式导出JSON，每个记录是一个字典。
# - lines=True 表示将每个记录输出为一行，这有助于在读取大型文件时节省内存。
# - index=False 表示不将DataFrame的索引作为JSON对象的一部分输出。

# 方法2：使用标准库json创建(推荐)
import pandas as pd
import json
# 创建一个包含数据的字典列表
data = [  
    {
        "id": 1,
        "info": {"name": "Alice", "age": 30},
        "hobbies": ["reading", "cycling"]
    },
    {
        "id": 2,
        "info": {"name": "Bob", "age": 25},
        "hobbies": ["swimming", "coding"]
    }
]
# 将字典列表转换为DataFrame
df = pd.DataFrame(data)
# 将DataFrame转换为记录列表
records = df.to_dict(orient='records')
# 使用json模块将记录列表写入文件
with open('example.json', 'w') as f:
    json.dump(records, f)
# 现在，'example.json' 包含了一个严格的JSON数组。</code></pre> 
<h6 id="12-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">15-6-2、代码示例</h6> 
<pre><code class="language-python"># 15、pandas.json_normalize函数
import pandas as pd
# 读取JSON文件，假设文件结构是符合'records'导向的
df = pd.read_json('example.json', orient='records')
# 假设您想要将'id'列作为元数据，可以简单地创建一个新的DataFrame或直接在df上操作
# 如果您想保留原始df，可以创建一个新的DataFrame
df2 = df.drop('id', axis=1)  # 删除'id'列，以便在后续处理中将其视为元数据
df2['meta_id'] = df['id']  # 在df2上添加'meta_id'列，作为元数据
# 或者，如果您不介意修改原始df，可以直接添加前缀
df['meta_id'] = df['id']
df.drop('id', axis=1, inplace=True)  # 注意，这会修改原始df
# 打印结果
print(df2)  # 如果使用了第一个方法（创建新DataFrame）
# 或者
print(df)  # 如果使用了第二个方法（直接在df上操作）</code></pre> 
<h6 id="12-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0">15-6-3、结果输出 </h6> 
<pre><code class="language-python"># 15、pandas.json_normalize函数
#                            info             hobbies  meta_id
# 0  {'name': 'Alice', 'age': 30}  [reading, cycling]        1
# 1    {'name': 'Bob', 'age': 25}  [swimming, coding]        2
#                            info             hobbies  meta_id
# 0  {'name': 'Alice', 'age': 30}  [reading, cycling]        1
# 1    {'name': 'Bob', 'age': 25}  [swimming, coding]        2</code></pre> 
<h4 id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">二、推荐阅读</h4> 
<h5 id="1%E3%80%81">1、<a href="https://myelsa1024.blog.csdn.net/article/details/139241094?spm=1001.2014.3001.5502" rel="nofollow" title="Python筑基之旅">Python筑基之旅</a></h5> 
<h5 id="2%E3%80%81">2、<a href="https://myelsa1024.blog.csdn.net/article/details/138916144?spm=1001.2014.3001.5502" rel="nofollow" title="Python函数之旅">Python函数之旅</a></h5> 
<h5 id="3%E3%80%81">3、<a href="https://blog.csdn.net/ygb_1024/article/details/136889623?spm=1001.2014.3001.5501" title="Python算法之旅">Python算法之旅</a></h5> 
<h5 id="4%E3%80%81">4、<a href="https://myelsa1024.blog.csdn.net/article/details/139555733" rel="nofollow" title="Python魔法之旅">Python魔法之旅</a></h5> 
<h5 id="5%E3%80%81%C2%A0">5、<a href="https://blog.csdn.net/ygb_1024?spm=1010.2135.3001.5421" title="博客个人主页">博客个人主页</a></h5>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b84bed7c213a39b9d8efe2dbbc324a29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常见的Java运行时异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0003276a5eb3c6b89d69002995b0f2de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">041基于SSM&#43;Jsp的高校校园点餐系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>