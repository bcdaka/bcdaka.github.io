<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】单链表的层层实现！! ! - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/47add96275315c212355bc58e88e0d08/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】单链表的层层实现！! !">
  <meta property="og:description" content="关注小庄 顿顿解馋(●’◡’●)
上篇回顾
我们上篇学习了本质为数组的数据结构—顺序表，顺序表支持下标随机访问而且高速缓存命中率高，然而可能造成空间的浪费，同时增加数据时多次移动会造成效率低下，那有什么解决之法呢？这就得引入我们链表这种数据结构
文章目录 一.何为链表🏠 链表概念🏠 链表的分类![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6102a54bc82c4f25abb7816d1d2d0ebc.png) 二.单链表的实现🏠 链表的打印🏠 链表的头插和尾插🏠 链表的尾删和头删🏠 链表指定位置的插入和删除🏠 链表的查找🏠 链表的销毁`注： 这里要保存好下一个结点地址，销毁后就能继续遍历` 三.单链表的分析以及与顺序表的比较🏠 单链表的优缺点🏠 单链表与顺序表的比较 一.何为链表 🏠 链表概念 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表
中的指针链接次序实现的 。
特点：物理结构不一定连续，逻辑结构连续
我们的链表结构类似我们的火车，有头有尾，中间每个结点被有序链接；与火车不同的是，链表的结点可能不是紧挨着的。
类似这样，我们可以得出：
1.每个结点由数据和下一结点地址两部分组成，而每个结点构成了一个链表。
2.每个结点保存的是下一个结点的地址，这样就能找到下一个结点，最后为空就停止
3.每个结点的地址不是连续的，可以体现出链表的物理结构不一定连续
注：我们的结点一般是在堆区开辟的，因为此时你在程序结束前不free就会一直存在这块空间，同时可根据需要灵活申请结点存数据。
这样我们就可以用一个结构体封装每个结点：
typedef int Datatype; typedef struct ListNode { Datatype x; struct ListNode* next; }Node; 注： 这里我们可以用typedef来重命名我们要存储的数据类型，这样对于不同数据的操作我们只要改typedef即可。
🏠 链表的分类 我们根据链表三个特点：1.带头不带头 2.单向还是双向 3.循环还是不循环 组合成了如上的8种链表
本篇博客，我们要实现的是单向不带头不循环链表（单链表），至于什么是带头，双向，循环我们下回双链表再进行讲解
二.单链表的实现 无头&#43;单向&#43;不循环链表的增删差改
🏠 链表的打印 链表数据的打印 这个接口就很好的体现了结点结构保存指针的妙处了~
//链表的打印 void SLTPrint(Node* phead) { asser(phead); Node* cur = phead; while (cur) { printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-08T23:14:02+08:00">
    <meta property="article:modified_time" content="2024-03-08T23:14:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】单链表的层层实现！! !</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><img src="https://images2.imgbox.com/da/03/gLS5geUY_o.png" alt="在这里插入图片描述"><br> 关注小庄 顿顿解馋(●’◡’●)</p> 
</blockquote> 
<blockquote> 
 <p>上篇回顾<br> 我们上篇学习了本质为数组的数据结构—顺序表，顺序表支持下标随机访问而且高速缓存命中率高，然而可能造成空间的浪费，同时增加数据时多次移动会造成效率低下，那有什么解决之法呢？这就得引入我们链表这种数据结构</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_8" rel="nofollow">一.何为链表</a></li><li><ul><li><a href="#__9" rel="nofollow">🏠 链表概念</a></li><li><a href="#_httpsimgblogcsdnimgcndirect6102a54bc82c4f25abb7816d1d2d0ebcpng_38" rel="nofollow">🏠 链表的分类![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6102a54bc82c4f25abb7816d1d2d0ebc.png)</a></li></ul> 
  </li><li><a href="#_44" rel="nofollow">二.单链表的实现</a></li><li><ul><li><a href="#__47" rel="nofollow">🏠 链表的打印</a></li><li><a href="#__66" rel="nofollow">🏠 链表的头插和尾插</a></li><li><a href="#__164" rel="nofollow">🏠 链表的尾删和头删</a></li><li><a href="#__216" rel="nofollow">🏠 链表指定位置的插入和删除</a></li><li><a href="#__271" rel="nofollow">🏠 链表的查找</a></li><li><a href="#__292" rel="nofollow">🏠 链表的销毁</a></li><li><a href="#__310" rel="nofollow">`注： 这里要保存好下一个结点地址，销毁后就能继续遍历`</a></li></ul> 
  </li><li><a href="#_312" rel="nofollow">三.单链表的分析以及与顺序表的比较</a></li><li><ul><li><a href="#__313" rel="nofollow">🏠 单链表的优缺点</a></li><li><a href="#__326" rel="nofollow">🏠 单链表与顺序表的比较</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_8"></a>一.何为链表</h2> 
<h3><a id="__9"></a>🏠 链表概念</h3> 
<blockquote> 
 <p>概念：链表是一种<code>物理存储结构上非连续、非顺序</code>的存储结构，数据元素的逻辑顺序是通过链表<br> 中的<code>指针</code>链接次序实现的 。</p> 
</blockquote> 
<p><code>特点：物理结构不一定连续，逻辑结构连续</code><br> <img src="https://images2.imgbox.com/09/26/smxQ68AD_o.png" alt="在这里插入图片描述"><br> <em>我们的链表结构类似我们的火车，有头有尾，中间每个结点被有序链接；与火车不同的是，链表的结点可能不是紧挨着的。</em></p> 
<p><img src="https://images2.imgbox.com/1d/7e/NWbxJebu_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>类似这样，我们可以得出：<br> 1.每个结点由数据和下一结点地址两部分组成，而每个结点构成了一个链表。<br> 2.每个结点保存的是下一个结点的地址，这样就能找到下一个结点，最后为空就停止<br> 3.每个结点的地址不是连续的，可以体现出链表的物理结构不一定连续</p> 
</blockquote> 
<p><code>注：我们的结点一般是在堆区开辟的，因为此时你在程序结束前不free就会一直存在这块空间，同时可根据需要灵活申请结点存数据。</code></p> 
<p>这样我们就可以用一个结构体封装每个结点：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> Datatype<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	Datatype x<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Node<span class="token punctuation">;</span>
</code></pre> 
<p><code>注： 这里我们可以用typedef来重命名我们要存储的数据类型，这样对于不同数据的操作我们只要改typedef即可。</code></p> 
<h3><a id="_httpsimgblogcsdnimgcndirect6102a54bc82c4f25abb7816d1d2d0ebcpng_38"></a>🏠 链表的分类<img src="https://images2.imgbox.com/b4/a3/zsR0WBCW_o.png" alt="在这里插入图片描述"></h3> 
<blockquote> 
 <p>我们根据链表三个特点：<code>1.带头不带头 2.单向还是双向 3.循环还是不循环</code> 组合成了如上的8种链表<br> 本篇博客，我们要实现的是单向不带头不循环链表（单链表），至于什么是带头，双向，循环我们下回双链表再进行讲解</p> 
</blockquote> 
<hr> 
<h2><a id="_44"></a>二.单链表的实现</h2> 
<p><em>无头+单向+不循环链表的增删差改</em></p> 
<h3><a id="__47"></a>🏠 链表的打印</h3> 
<ul><li>链表数据的打印</li></ul> 
<p><em>这个接口就很好的体现了结点结构保存指针的妙处了~</em></p> 
<pre><code class="prism language-c"><span class="token comment">//链表的打印</span>
<span class="token keyword">void</span> <span class="token function">SLTPrint</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">asser</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Node<span class="token operator">*</span> cur <span class="token operator">=</span> phead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="__66"></a>🏠 链表的头插和尾插</h3> 
<ul><li>链表的尾插</li></ul> 
<p><img src="https://images2.imgbox.com/2a/12/EqZhw4lI_o.png" alt="在这里插入图片描述"><br> <em>对于链表的尾插要注意几个问题：1.申请新结点 2.链表是否为空</em></p> 
<blockquote> 
 <p>解决方法：1.对于链表为空，直接让申请的新节点作为头节点 2.对于不为空的链表，首先要<code>找到尾结点，再进行插入</code> 3.对于申请新节点，我们后续的头插也要使用我们可以<code>封装成一个接口</code>，同时<code>结点在堆区申请，调用完接口就不会释放了。</code></p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//申请新节点</span>
Node<span class="token operator">*</span> <span class="token function">BuyNode</span><span class="token punctuation">(</span>Datatype x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>newnode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">SLTPushBack</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">,</span> Datatype x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//申请新节点</span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">BuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//链表为空</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> <span class="token operator">*</span>pphead<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>pphead <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//链表不为空：1.找尾巴结点2.插入新节点</span>
	Node<span class="token operator">*</span> ptail <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>ptail<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		ptail <span class="token operator">=</span> ptail<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	ptail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><em>思考：这里为什么传二级指针？如果不传二级指针呢？</em></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTNPushBack</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> pphead<span class="token punctuation">,</span> Datatype x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	
	<span class="token comment">//申请新节点</span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">BuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//链表为空</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pphead<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		pphead <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//链表不为空：1.找尾巴结点2.插入</span>
	Node<span class="token operator">*</span> ptail <span class="token operator">=</span> pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>ptail<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		ptail <span class="token operator">=</span> ptail<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	ptail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> n1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token function">SLTNPushBack</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/66/1c/U1eZQ1UQ_o.png" alt="在这里插入图片描述"><br> <em>经过观察传一级指针版本的调用前后，我们发现n1这个指针变量存储的值并没发生改变，究其原因如下图</em><br> <img src="https://images2.imgbox.com/46/7f/vhgQBHMh_o.png" alt="在这里插入图片描述"></p> 
<ul><li>链表的头插<br> ,<img src="https://images2.imgbox.com/7c/3d/x6Kke1in_o.png" alt="在这里插入图片描述"><br> *对于链表的头插要注意的问题：1.申请新节点 2.链表释放为空 *</li></ul> 
<blockquote> 
 <p>解决方法：1.链表为空时，申请的新结点作为头结点 2.链表不为空时，让newnode-&gt;next指向原来头节点,再让newnode成为新的头节点。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPushFront</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">,</span> Datatype x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//申请新节点</span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">BuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//链表为空</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> <span class="token operator">*</span>pphead<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>pphead <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token operator">*</span>pphead <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="__164"></a>🏠 链表的尾删和头删</h3> 
<ul><li>链表的尾删<br> <img src="https://images2.imgbox.com/50/f9/bZB1RsKE_o.png" alt="在这里插入图片描述"><br> <em>对于链表的尾删，我们需要分三种情况！</em></li></ul> 
<blockquote> 
 <p>1.链表为空时此时删不了直接退出<br> 2.链表只有一个结点时，释放头节点，置phead为空<br> 3.链表有多个结点时，我们需要遍历链表找到尾结点的前置结点，先释放尾节点再将前置结点的next置为空<br> <code>注：不能先将前置结点的next置为空，再释放尾结点，此时就找不到尾结点的地址了。</code></p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//链表的尾删和头删</span>
<span class="token keyword">void</span> <span class="token function">SLTPopBack</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断链表不为空</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">free</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">*</span>pphead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	Node<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		pre <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
	pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>链表的头删</li></ul> 
<p><img src="https://images2.imgbox.com/a3/4b/fBBytVrU_o.png" alt="在这里插入图片描述"><br> <em>对于链表的头删，分为两种情况就可以了，因为有了phead很方便~</em></p> 
<blockquote> 
 <p>1.链表为空时，删不了直接断言下<br> 2.链表不为空时，记录头节点的下一个位置，先释放头节点，再更换phead指向的位置</p> 
</blockquote> 
<p><code>注：这里也不能先更新phead再释放头结点</code></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPopFront</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Node<span class="token operator">*</span> pNext <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span>pphead <span class="token operator">=</span> pNext<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="__216"></a>🏠 链表指定位置的插入和删除</h3> 
<p><img src="https://images2.imgbox.com/63/12/7C8SMMMx_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>1.链表为空时，无法插入<br> 2.pos位置结点刚好是头结点，直接头插或头删<br> 3.pos位置结点不是头节点，需要找到pos位置的前置结点，记录位置。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">NodeInpos</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">,</span> Node<span class="token operator">*</span> pos<span class="token punctuation">,</span> Datatype x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//pos不为空 -》 链表一定不能为空</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//建立一个新节点</span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">BuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//pos刚好是头结点的情况</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead <span class="token operator">==</span> pos<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//运用头插</span>
		<span class="token function">NodeinFront</span><span class="token punctuation">(</span>pphead<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//pos刚好不是头结点</span>
	<span class="token comment">//1.先找出pos前面的结点pre  2.newnode-&gt;next = pre-&gt;next 3.pre-&lt;next = newnode</span>
	Node<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> pos<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		pre <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">NodeDelpos</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">,</span> Node<span class="token operator">*</span> pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//pos刚好是第一个结点 执行头删</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead <span class="token operator">==</span> pos<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">NodeDelFront</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//pos不是第一个结点 1.先找到那个pos前面结点pre 2.pre-&gt;next = pos-&gt;next 3.free</span>
	Node<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> pos<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		pre <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	pos <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="__271"></a>🏠 链表的查找</h3> 
<pre><code class="prism language-c">Node<span class="token operator">*</span> <span class="token function">NodeFind</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> phead<span class="token punctuation">,</span> Datatype x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//遍历链表</span>
	Node<span class="token operator">*</span> pcur <span class="token operator">=</span> <span class="token operator">*</span>phead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> pcur<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//找不到则返回NULL</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><em>这里建议用一个临时变量来遍历~</em></p> 
<h3><a id="__292"></a>🏠 链表的销毁</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">NodeDestroy</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//1.创一个临时变量存pcur-&gt;next的地址</span>
	Node<span class="token operator">*</span> pcur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Node<span class="token operator">*</span> next <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pcur <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">*</span>pphead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="__310"></a><code>注： 这里要保存好下一个结点地址，销毁后就能继续遍历</code></h3> 
<h2><a id="_312"></a>三.单链表的分析以及与顺序表的比较</h2> 
<h3><a id="__313"></a>🏠 单链表的优缺点</h3> 
<p><em>通过实现我们的单链表，我们发现单链表有以下优点</em></p> 
<blockquote> 
 <p>1.单链表不存在空间浪费(根据需求灵活在堆上申请新结点)<br> 2.单链表的任意插入和删除效率高<br> （分析: 这里是已经确定插入的位置，对于链表只需改变指针的指向就能实现插入和删除，时间复杂度是<code>O(1)</code>，而数组插入和删除需要遍历数组，时间复杂度是<code>O(N)</code>）</p> 
</blockquote> 
<p><em>单链表也不是万能的，它在一些应用场景也发挥不出来作用</em></p> 
<blockquote> 
 <p>1.不支持随机访问<br> 2.缓存命中率低<br> 3.查找效率低</p> 
</blockquote> 
<p><code>总结：链表适用于频繁任意插入和删除的场景，不适用于随机访问和查找</code></p> 
<h3><a id="__326"></a>🏠 单链表与顺序表的比较</h3> 
<table><thead><tr><th align="center">单链表</th><th align="center">顺序表</th></tr></thead><tbody><tr><td align="center">物理空间不一定连续</td><td align="center">物理空间一定连续</td></tr><tr><td align="center">不支持随机访问</td><td align="center">支持下标随机访问</td></tr><tr><td align="center">插入和删除效率高 O(1)</td><td align="center">插入和删除效率低 O(N)</td></tr><tr><td align="center">缓存命中率低</td><td align="center">缓存命中率高</td></tr><tr><td align="center">无空间的浪费</td><td align="center">可能造成数据丢失和空间浪费</td></tr><tr><td align="center">缓存利用率高</td><td align="center"></td></tr></tbody></table> 
<p><em>综上 我们可以根据场景需求选择不同的结构，灵活运用数据~</em></p> 
<hr> 
<p><em>本次分享到这结束了，下篇我们将讲解双向链表，不妨来个一键三连捏</em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/22fa44798ae481a21ba8b8f4369e724d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Python 实现奇异谱分析SSA（Singular Spectrum Analysis）算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b3405a3424b029c6355535c4f900ba36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何使用Python从0训练自己的AI模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>