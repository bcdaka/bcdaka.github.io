<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构： 单向链表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/92be3f3a58911cedbe2edad7cd07de80/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构： 单向链表">
  <meta property="og:description" content="目录
一、链表的概念及结构
二、单链表的实现
2.1 头文件
2.2 各个功能的实现
2.2.1 内存申请
2.2.2 头插，尾插，头删，尾删
头插
尾插
头删
尾删
2.2.3 查找数据
2.2.4 指定位置前中后的数据增删
指定位置之前插入数据
指定位置之后插入数据
删除指定位置之后数据
删除指定位置数据
2.2.5 打印链表
2.2.6 销毁链表
一、链表的概念及结构 概念：链表是⼀种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
链表的结构跟火车车厢相似，淡季时车次的车厢会相应减少，旺季时车次的车厢会额外增加几节。只需要将火车里的某节车厢去掉或者加上，不会影响其他车厢，每节车厢都是独立存在的，车厢是独立存在的，且每节车厢都有车门，想象⼀下这样的场景，假设每节车厢的车门都是锁上的状 态，需要不同的钥匙才能解锁，每次只能携带⼀把钥匙的情况下如何从车头走到车尾？ 最简单的做法：每节车厢里都放⼀把下⼀节车厢的钥匙。
链表里的“车厢”
与顺序表不同的是，链表里的每节&#34;车厢&#34;都是独立申请下来的空间，我们称之为“节点”， 节点的组成主要有两个部分：当前节点要保存的数据和保存下⼀个节点的地址（指针变量）。 图中指针变量plist保存的是第⼀个节点的地址，我们称plist此时“指向”第⼀个节点，如果我们希望plist“指向”第⼆个节点时，只需要修改plist保存的内容为0x0012FFA0。
链表中每个节点都是独立申请的（即需要插⼊数据时才去申请⼀块节点的空间），我们需要通过指针变量来保存下⼀个节点位置才能从当前节点找到下⼀个节点。
结合结构体知识，我们可以给出每个节点对应的结构体代码： 假设当前保存的节点为整型：
struct SListNode { int data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数 据，也需要保存下⼀个节点的地址（当下⼀个节点为空时保存的地址为空）。
当我们想要从第⼀个节点走到最后⼀个节点时，只需要在前⼀个节点拿上下⼀个节点的地址（下⼀个 节点的钥匙）就可以了。
二、单链表的实现 2.1 头文件 先要创建一个头文件，写入我们需要的函数名以及结构体
typedef int SLTDataType;//方便类型转换 typedef struct SListNode { SLTDataType data; //节点数据 struct SListNode* next; //指针保存下⼀个节点的地址 }SLTNode; void SLTPrint(SLTNode* phead); //头部插入删除数据/尾部插入删除数据 void SLTPushBack(SLTNode** pphead, SLTDataType x); void SLTPushFront(SLTNode** pphead, SLTDataType x); void SLTPopBack(SLTNode** pphead); void SLTPopFront(SLTNode** pphead); //查找数据 SLTNode* SLTFind(SLTNode* phead, SLTDataType x); //在指定位置之前插入数据 void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x); //删除指定位置节点 void SLTErase(SLTNode** pphead, SLTNode* pos); //在指定位置之后插入数据 void SLTInsertAfter(SLTNode* pos, SLTDataType x); //删除指定位置之后的节点 void SLTEraseAfter(SLTNode* pos); //销毁链表 void SListDesTroy(SLTNode** pphead); 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T15:59:38+08:00">
    <meta property="article:modified_time" content="2024-08-02T15:59:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构： 单向链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">一、链表的概念及结构</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">二、单链表的实现</a></p> 
<p id="2.1%20%E5%A4%B4%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2.1%20%E5%A4%B4%E6%96%87%E4%BB%B6" rel="nofollow">2.1 头文件</a></p> 
<p id="2.2%20%E5%90%84%E4%B8%AA%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.2%20%E5%90%84%E4%B8%AA%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2 各个功能的实现</a></p> 
<p id="2.2.1%20%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7-toc" style="margin-left:80px;"><a href="#2.2.1%20%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7" rel="nofollow">2.2.1 内存申请</a></p> 
<p id="%C2%A02.2.2%20%E5%A4%B4%E6%8F%92%EF%BC%8C%E5%B0%BE%E6%8F%92%EF%BC%8C%E5%A4%B4%E5%88%A0%EF%BC%8C%E5%B0%BE%E5%88%A0-toc" style="margin-left:80px;"><a href="#%C2%A02.2.2%20%E5%A4%B4%E6%8F%92%EF%BC%8C%E5%B0%BE%E6%8F%92%EF%BC%8C%E5%A4%B4%E5%88%A0%EF%BC%8C%E5%B0%BE%E5%88%A0" rel="nofollow"> 2.2.2 头插，尾插，头删，尾删</a></p> 
<p id="%E5%A4%B4%E6%8F%92-toc" style="margin-left:120px;"><a href="#%E5%A4%B4%E6%8F%92" rel="nofollow">头插</a></p> 
<p id="%C2%A0%E5%B0%BE%E6%8F%92-toc" style="margin-left:120px;"><a href="#%C2%A0%E5%B0%BE%E6%8F%92" rel="nofollow"> 尾插</a></p> 
<p id="%C2%A0%E5%A4%B4%E5%88%A0-toc" style="margin-left:120px;"><a href="#%C2%A0%E5%A4%B4%E5%88%A0" rel="nofollow"> 头删</a></p> 
<p id="%E5%B0%BE%E5%88%A0-toc" style="margin-left:120px;"><a href="#%E5%B0%BE%E5%88%A0" rel="nofollow">尾删</a></p> 
<p id="%C2%A02.2.3%20%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%C2%A02.2.3%20%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE" rel="nofollow"> 2.2.3 查找数据</a></p> 
<p id="%C2%A02.2.4%20%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%89%8D%E4%B8%AD%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%88%A0-toc" style="margin-left:80px;"><a href="#%C2%A02.2.4%20%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%89%8D%E4%B8%AD%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%88%A0" rel="nofollow"> 2.2.4 指定位置前中后的数据增删</a></p> 
<p id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">指定位置之前插入数据</a></p> 
<p id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">指定位置之后插入数据</a></p> 
<p id="%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%95%B0%E6%8D%AE" rel="nofollow">删除指定位置之后数据</a></p> 
<p id="%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%95%B0%E6%8D%AE" rel="nofollow">删除指定位置数据</a></p> 
<p id="%C2%A02.2.5%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%C2%A02.2.5%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8" rel="nofollow"> 2.2.5 打印链表</a></p> 
<p id="2.2.6%20%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#2.2.6%20%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8" rel="nofollow">2.2.6 销毁链表</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">一、链表的概念及结构</h2> 
<p>    概念：链表是⼀种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p> 
<p><img alt="" height="115" src="https://images2.imgbox.com/23/2e/isZpqvy6_o.png" width="292"></p> 
<p> <img alt="" height="97" src="https://images2.imgbox.com/4f/24/9x4YdlxB_o.png" width="338"></p> 
<p>     链表的结构跟火车车厢相似，淡季时车次的车厢会相应减少，旺季时车次的车厢会额外增加几节。只需要将火车里的某节车厢去掉或者加上，不会影响其他车厢，每节车厢都是独立存在的，车厢是独立存在的，且每节车厢都有车门，想象⼀下这样的场景，假设每节车厢的车门都是锁上的状 态，需要不同的钥匙才能解锁，每次只能携带⼀把钥匙的情况下如何从车头走到车尾？ 最简单的做法：每节车厢里都放⼀把下⼀节车厢的钥匙。</p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/d4/7a/8vyIPr2T_o.png" width="1200">链表里的“车厢”</p> 
<p>    与顺序表不同的是，链表里的每节"车厢"都是独立申请下来的空间，我们称之为“节点”， 节点的组成主要有两个部分：当前节点要保存的数据和保存下⼀个节点的地址（指针变量）。 图中指针变量plist保存的是第⼀个节点的地址，我们称plist此时“指向”第⼀个节点，如果我们希望plist“指向”第⼆个节点时，只需要修改plist保存的内容为0x0012FFA0。</p> 
<p>链表中每个节点都是独立申请的（即需要插⼊数据时才去申请⼀块节点的空间），我们需要通过指针变量来保存下⼀个节点位置才能从当前节点找到下⼀个节点。</p> 
<p>结合结构体知识，我们可以给出每个节点对应的结构体代码： 假设当前保存的节点为整型：</p> 
<pre><code>struct SListNode
{
 int data; //节点数据 
 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 
};</code></pre> 
<p>当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数 据，也需要保存下⼀个节点的地址（当下⼀个节点为空时保存的地址为空）。</p> 
<p>当我们想要从第⼀个节点走到最后⼀个节点时，只需要在前⼀个节点拿上下⼀个节点的地址（下⼀个 节点的钥匙）就可以了。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">二、单链表的实现</h2> 
<h3 id="2.1%20%E5%A4%B4%E6%96%87%E4%BB%B6">2.1 头文件</h3> 
<p>    先要创建一个头文件，写入我们需要的函数名以及结构体</p> 
<pre><code>typedef int SLTDataType;//方便类型转换
typedef struct SListNode
{
 SLTDataType data; //节点数据 
 struct SListNode* next; //指针保存下⼀个节点的地址 
}SLTNode;

void SLTPrint(SLTNode* phead);

//头部插入删除数据/尾部插入删除数据
void SLTPushBack(SLTNode** pphead, SLTDataType x);
void SLTPushFront(SLTNode** pphead, SLTDataType x);
void SLTPopBack(SLTNode** pphead);
void SLTPopFront(SLTNode** pphead);

//查找数据
SLTNode* SLTFind(SLTNode* phead, SLTDataType x);
//在指定位置之前插入数据
void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x);
//删除指定位置节点
void SLTErase(SLTNode** pphead, SLTNode* pos);
//在指定位置之后插入数据
void SLTInsertAfter(SLTNode* pos, SLTDataType x);
//删除指定位置之后的节点
void SLTEraseAfter(SLTNode* pos);
//销毁链表
void SListDesTroy(SLTNode** pphead);</code></pre> 
<h3 id="2.2%20%E5%90%84%E4%B8%AA%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0">2.2 各个功能的实现</h3> 
<h4 id="2.2.1%20%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7">2.2.1 内存申请</h4> 
<p>    单链表是每添加一份数据就申请一次内存空间，虽然这样降低了一点运行效率但是有效的避免了内存空间的浪费。</p> 
<pre><code>SLTNode* capacity(SLTDataType x)
{
	SLTNode* new = (SLTNode*)malloc(sizeof(SLTNode));
	if (new == NULL)
	{
		perror("malloc fail");
		exit(1);
	}
	new-&gt;data = x;
	new-&gt;next = NULL; 
	return new;
}</code></pre> 
<h4 id="%C2%A02.2.2%20%E5%A4%B4%E6%8F%92%EF%BC%8C%E5%B0%BE%E6%8F%92%EF%BC%8C%E5%A4%B4%E5%88%A0%EF%BC%8C%E5%B0%BE%E5%88%A0"> 2.2.2 头插，尾插，头删，尾删</h4> 
<h5 id="%E5%A4%B4%E6%8F%92">头插</h5> 
<pre><code>void SLTPushFront(SLTNode** pphead, SLTDataType x)
{
	SLTNode* new = capacity(x);
	new-&gt;next = *pphead;
	*pphead = new;
}</code></pre> 
<h5 id="%C2%A0%E5%B0%BE%E6%8F%92"> 尾插</h5> 
<pre><code>void SLTPushBack(SLTNode** pphead, SLTDataType x)
{
	SLTNode* new = capacity(x);
	if (*pphead == NULL)
	{
		*pphead = new;
	}
	else
	{
		SLTNode* newnode = *pphead;
		while (newnode-&gt;next)
		{
			newnode = newnode-&gt;next;
		}
		newnode-&gt; next= new;
	}
}</code></pre> 
<h5 id="%C2%A0%E5%A4%B4%E5%88%A0"> 头删</h5> 
<p>    注意free释放指针完，指针一定要有指向（指向空也是可以的），避免造成野指针。</p> 
<pre><code>void SLTPopFront(SLTNode** pphead)
{
	assert(*pphead &amp;&amp; pphead);
	SLTNode* new = (*pphead)-&gt;next;
	free(*pphead);
	*pphead = new;
}</code></pre> 
<h5 id="%E5%B0%BE%E5%88%A0">尾删</h5> 
<pre><code>void SLTPopBack(SLTNode** pphead)
{
	assert(*pphead &amp;&amp; pphead);
	SLTNode* new = *pphead;
	SLTNode* newnode = *pphead;
	if ((*pphead)-&gt;next == NULL)
	{
		free(*pphead);
		*pphead = NULL;
	}
	else
	{
		SLTNode* new = *pphead;
		SLTNode* newnode = *pphead;
		while (new-&gt;next)
		{
			newnode = new;
			new = new-&gt;next;
		}
		free(new);
		new = NULL;
		newnode-&gt;next = NULL;
	}
}</code></pre> 
<h4 id="%C2%A02.2.3%20%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE"> 2.2.3 查找数据</h4> 
<pre><code>SLTNode* SLTFind(SLTNode* phead, SLTDataType x)
{
	while (phead)
	{
		if (phead-&gt;data == x)
		{
			return phead;
		}
		phead = phead-&gt;next;
	}
	printf("没找到");
	return NULL;
}</code></pre> 
<h4 id="%C2%A02.2.4%20%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%89%8D%E4%B8%AD%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%88%A0"> 2.2.4 指定位置前中后的数据增删</h4> 
<h5 id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">指定位置之前插入数据</h5> 
<pre><code>void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x)
{
	if (*pphead == pos)
	{
		SLTPushFront(pphead, x);
	}
	else
	{
		SLTNode* new = capacity(x);
		SLTNode* newnode = *pphead;
		while (newnode-&gt;next != pos)
		{
			newnode = newnode-&gt;next;
		}
		new-&gt;next = pos;
		newnode-&gt;next = new;
	}
}</code></pre> 
<h5 id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">指定位置之后插入数据</h5> 
<pre><code>void SLTInsertAfter(SLTNode* pos, SLTDataType x)
{
	assert(pos);
	SLTNode* new = capacity(x);
	SLTNode* newnode = pos-&gt;next;
	pos-&gt;next = new;
	new-&gt;next = newnode;
}</code></pre> 
<h5 id="%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%95%B0%E6%8D%AE">删除指定位置之后数据</h5> 
<pre><code>void SLTEraseAfter(SLTNode* pos)
{
	assert(pos&amp;&amp;pos-&gt;next);
	SLTNode* new = pos-&gt;next;
	pos-&gt;next = new-&gt;next;
	free(new);
	new = NULL;
}</code></pre> 
<h5 id="%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%95%B0%E6%8D%AE">删除指定位置数据</h5> 
<pre><code>void SLTErase(SLTNode** pphead, SLTNode* pos)
{
	assert(*pphead &amp;&amp; *pphead);
	assert(pos);
	SLTNode* new = pos-&gt;next;
	while ((*pphead)-&gt;next != pos)
	{
		*pphead = (*pphead)-&gt;next;
	}
	(*pphead)-&gt;next = new;
	free(pos);
	pos = NULL;
}</code></pre> 
<h4 id="%C2%A02.2.5%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"> 2.2.5 打印链表</h4> 
<p>    给定链表结构中，实现节点从头到尾的打印。</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/9f/90/Z1zAHXRx_o.png" width="670"></p> 
<pre><code>void SLTPrint(SLTNode* phead)
{
	SLTNode* pcur = phead;
	while (pcur)
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}</code></pre> 
<h4 id="2.2.6%20%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8">2.2.6 销毁链表</h4> 
<pre><code>void SListDesTroy(SLTNode** pphead)
{
	assert(*pphead &amp;&amp; pphead);
	SLTNode* new=*pphead;
	while (new)
	{
		SLTNode* newnode =new-&gt;next;
		free(new);
		new = newnode;
	}
	*pphead= NULL;
}</code></pre> 
<p>    各个功能实现后，不要忘了测试，看看写的代码是否有误。</p> 
<hr> 
<p><a id="_45"></a>    本篇内容就到这里了，希望对各位有帮助，如果有错误欢迎指出。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/db/db/Rs8CQ8Pv_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb282b4a69e61ad8959fe5aa4f6b41df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手搓交换排序、归并排序、计数排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5efb0db9ad7ea56a259161854d411f12/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数仓: 1- 数据仓库基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>