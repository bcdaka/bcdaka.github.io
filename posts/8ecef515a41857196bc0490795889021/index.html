<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【AI】可变形卷积Deformable Conv - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8ecef515a41857196bc0490795889021/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【AI】可变形卷积Deformable Conv">
  <meta property="og:description" content="卷积对大家来说并不陌生了，这里主要描述Deformable Conv。其在论文中也是常见的一个术语，Deformable Convolutional Networks(DCN) 还可以细分成可变形卷积、对候选区域的池化等。
传统卷积操作 将特征图分成一个个与卷积核大小相同的部分，然后进行卷积操作，每部分在特征图上的位置都是固定的。但对形变比较复杂的物体，使用这种卷积的效果就可能不太好。
对于传统卷积，可提升效果的方法有丰富数据集、数据增强、人工设计特征和算法等。但过多的数据又会造成收敛慢或需要更复杂的网络结构。
Deformable Convolutional Networks(DCN) 对于复杂形变场景，可用Deformable Conv可变形卷积来解决。Deformable Conv 在感受野中引入了偏移量(可变形卷积则在传统卷积基础上为每个点引入了一个偏移量，偏移量是由输入特征图与另一个卷积生成的，通常是小数。)，而且这偏移量是可学习的，使得感受野不再是死板的方形，而是与物体的实际形状贴近，无论物体如何形变之后的卷积区域便始终覆盖在物体形状周围，实现移动、缩放尺寸、旋转等。
如图所示，(a)图为传统卷积操作，(b)©(d)均将原先的各点施加一个offset，使感受野形状改变。
由于加入偏移量后的位置非整数，并不对应feature map上实际存在的像素点，因此需要使用插值来得到偏移后的像素值，通常可采用双线性插值。
图中绿色过程为卷积学习偏移的过程，其中offset field的通道大小为2N，表示卷积核分别学习x方向与y方向的偏移量。
在input feature map上普通卷积操作对应卷积采样区域是一个卷积核大小的正方形（绿框），而可变形卷积对应的卷积采样区域为一些蓝框表示的点，这就是可变形卷积与普通卷积的区别。
一个output feature map上的点对应到input feature map上的卷积采样区域大小为KK，按照可变形卷积的操作，这KK区域的每一个卷积采样点都要学习一个偏离量offset，而offset是用坐标表示的，所以一个output要学习2KK个参数。
假设一个output大小为HW，所以一共要学习2KKHW个参数。即上图的offset field(N=KK)，其维度为B2KKHW，其中B代表batch_size；
假设input feature map的维度为BCHW，一个batch内的特征图（一共C个）共用一个offset field，即一个batch内的每张特征图用到的偏移量是一样的；
可变形卷积不改变input feature map的尺寸，所以output feature map也为H x W；
参考公式 传统卷积
其中，p_{n}代表卷积核中每一个点相对于中心点的偏移量,p_{0}是输入特征图上任意一点，x(p_{0}&#43;p_{n})表示输入特征图上p_{0}&#43;p_{n}位置处的元素值
DCN
即输出特征图上每点（对应卷积核中心）加上其对应卷积核每个位置的相对（横、纵）坐标后再加上自学习的（横、纵坐标）偏移量。
双线性插值
将插值点位置的像素值设为其4领域像素点的加权和，领域4个点是离其最近的在特征图上实际存在的像素点，每个点的权重则根据它与插值点横、纵坐标的距离来设置，公式最后一行的max(0, 1-…)就是限制了插值点与领域点不会超过1个像素的距离。
下图表示了如何通过p12,p22,p11,p21的加权来计算出p的像素值pixel">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T14:18:15+08:00">
    <meta property="article:modified_time" content="2024-08-05T14:18:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【AI】可变形卷积Deformable Conv</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>卷积对大家来说并不陌生了，这里主要描述Deformable Conv。其在论文中也是常见的一个术语，Deformable Convolutional Networks(DCN) 还可以细分成可变形卷积、对候选区域的池化等。</p> 
<h2><a id="_2"></a>传统卷积操作</h2> 
<p>将特征图分成一个个与卷积核大小相同的部分，然后进行卷积操作，每部分在特征图上的位置都是固定的。但对形变比较复杂的物体，使用这种卷积的效果就可能不太好。<br> 对于传统卷积，可提升效果的方法有丰富数据集、数据增强、人工设计特征和算法等。但过多的数据又会造成收敛慢或需要更复杂的网络结构。</p> 
<h2><a id="Deformable_Convolutional_NetworksDCN_5"></a>Deformable Convolutional Networks(DCN)</h2> 
<p>对于复杂形变场景，可用Deformable Conv可变形卷积来解决。Deformable Conv 在感受野中引入了偏移量(可变形卷积则在传统卷积基础上为每个点引入了一个偏移量，偏移量是由输入特征图与另一个卷积生成的，通常是小数。)，而且这偏移量是可学习的，使得感受野不再是死板的方形，而是与物体的实际形状贴近，无论物体如何形变之后的卷积区域便始终覆盖在物体形状周围，实现移动、缩放尺寸、旋转等。<br> 如图所示，(a)图为传统卷积操作，(b)©(d)均将原先的各点施加一个offset，使感受野形状改变。<br> <img src="https://images2.imgbox.com/f0/a9/fycOrXII_o.png" alt="在这里插入图片描述" width="500"><br> 由于加入偏移量后的位置非整数，并不对应feature map上实际存在的像素点，因此需要使用插值来得到偏移后的像素值，通常可采用双线性插值。<br> <img src="https://images2.imgbox.com/4a/5e/EP2HJZyh_o.png" alt="在这里插入图片描述" width="300"><br> 图中绿色过程为卷积学习偏移的过程，其中offset field的通道大小为2N，表示卷积核分别学习x方向与y方向的偏移量。<br> 在input feature map上普通卷积操作对应卷积采样区域是一个卷积核大小的正方形（绿框），而可变形卷积对应的卷积采样区域为一些蓝框表示的点，这就是可变形卷积与普通卷积的区别。</p> 
<p>一个output feature map上的点对应到input feature map上的卷积采样区域大小为K<em>K，按照可变形卷积的操作，这K</em>K区域的每一个卷积采样点都要学习一个偏离量offset，而offset是用坐标表示的，所以一个output要学习2<em>K</em>K个参数。<br> 假设一个output大小为H<em>W，所以一共要学习2</em>K<em>K</em>H<em>W个参数。即上图的offset field(N=K</em>K)，其维度为B<em>2</em>K<em>K</em>H<em>W，其中B代表batch_size；<br> 假设input feature map的维度为B</em>C<em>H</em>W，一个batch内的特征图（一共C个）共用一个offset field，即一个batch内的每张特征图用到的偏移量是一样的；<br> 可变形卷积不改变input feature map的尺寸，所以output feature map也为H x W；</p> 
<h2><a id="_19"></a>参考公式</h2> 
<p>传统卷积<img src="https://images2.imgbox.com/5c/77/nPPuVT60_o.png" alt="在这里插入图片描述" width="300"><br> 其中，p_{n}代表卷积核中每一个点相对于中心点的偏移量,p_{0}是输入特征图上任意一点，x(p_{0}+p_{n})表示输入特征图上p_{0}+p_{n}位置处的元素值</p> 
<hr> 
<p>DCN<img src="https://images2.imgbox.com/bd/b1/FH8tbqNU_o.png" alt="在这里插入图片描述" width="300"><br> 即输出特征图上每点（对应卷积核中心）加上其对应卷积核每个位置的相对（横、纵）坐标后再加上自学习的（横、纵坐标）偏移量。</p> 
<hr> 
<p>双线性插值<img src="https://images2.imgbox.com/ef/a2/kEDpWxrr_o.png" alt="在这里插入图片描述" width="300"><br> 将插值点位置的像素值设为其4领域像素点的加权和，领域4个点是离其最近的在特征图上实际存在的像素点，每个点的权重则根据它与插值点横、纵坐标的距离来设置，公式最后一行的max(0, 1-…)就是限制了插值点与领域点不会超过1个像素的距离。<br> 下图表示了如何通过p12,p22,p11,p21的加权来计算出p的像素值pixel<br> <img src="https://images2.imgbox.com/be/c9/PtcZ62wF_o.png" alt="在这里插入图片描述" width="400"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9f0903e8bb0cc7efa8900453b19a3d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中基本数据类型包装类的常量池缓存的值得范围是多少？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7bad6fe1bcbfdc80e3d68b0593b0a6a5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何将PostgreSQL的数据实时迁移到SelectDB？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>