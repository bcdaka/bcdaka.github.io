<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C/排序算法】：快速排序和冒泡排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/69d582fb6ef71275a57ec481bb06b90e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C/排序算法】：快速排序和冒泡排序">
  <meta property="og:description" content="目录 一，快速排序1. 挖坑法2. 快速排序的优化3. Hoare法4. 前后&#34;指针&#34;法 二，快速排序总结：三，冒泡排序 一，快速排序 快速排序是一种比较复杂的排序算法，它总共有4种实现方式，分别是挖坑法，左右&#34;指针&#34;法，前后&#34;指针&#34;法，以及非递归的快速排序 (本文只讲述递归实现，非递归实现以后有专门的文章) ，并且这些算法中也会涉及多种优化措施，比如三数取中，小区间优化，下面都会一一介绍。
由于它效率极高的缘故，快速排序也是日常开发中使用最多的，最重要的排序算法。
1. 挖坑法 1.1 基本思想：
任取待排序元素序列中的某元素(一般选最左边或最右边的元素)作为基准值(也叫做 key 关键字)，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后左右子序列重复该过程，直到所有元素都排列在相应位置上为止。
1.2 一趟排序图解如下：
给定一无序数组，选第一个元素为关键字 key = 6
我们选定关键字 key = 6后，就说明6的位置就可以被覆盖了，所以我们就说左边形成了一个****坑，用pivot 表示。
左边有坑，右边的 end 要从最后一个元素开始找比 key 小的数，找到后放到左边的坑里，所以5放进了坑中
5被拿走之后，右边它原来所在的位置就形成了一个新坑，此时，左边的 begin 要开始找比 key 大的数，找到后放到右边的坑里，所以7放进了坑中
7被拿走后，左边又形成了一个新坑，此时，end 又要开始找比 key 小的数放到左边的坑里，所以4放进了坑中
此时，右边又形成了新坑，begin 要开始找比 key 大的数，找到后放到右边的坑里，所以9放进了坑中
左边又形成了坑，右边 end 开始找，找到了3，放入坑中
最后一次 begin&#43;&#43; 后，begin 和 end 重叠了，并且它们一定相遇在坑中，此时，把 key 放入坑中即可。
上述操作只是第一趟排序，只排好了一个数，此时第一个基准 key = 6已经在它合适的位置上了(排好序后的位置)，后面对左右子序列排序时6不动。并且已经把数组分成了两个子序列，以 key 为基准，左边的元素都比它小，右边的元素都比它大。
1.3 单趟排序的代码实现如下：
注意：第二个和第三个 while 中的 begin &lt; end 不能缺少，要防止在找大和找小的时候 begin 和 end 错开或是在极端情况下(比如已经升序时)end一直减导致越界。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-23T22:33:38+08:00">
    <meta property="article:modified_time" content="2024-06-23T22:33:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C/排序算法】：快速排序和冒泡排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一，快速排序</a></li><li><ul><li><a href="#1__7" rel="nofollow">1. 挖坑法</a></li><li><a href="#2__152" rel="nofollow">2. 快速排序的优化</a></li><li><a href="#3_Hoare_457" rel="nofollow">3. Hoare法</a></li><li><a href="#4__530" rel="nofollow">4. 前后"指针"法</a></li></ul> 
  </li><li><a href="#_622" rel="nofollow">二，快速排序总结：</a></li><li><a href="#_764" rel="nofollow">三，冒泡排序</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一，快速排序</h2> 
<p>快速排序是一种比较复杂的排序算法，它总共有4种实现方式，分别是<strong>挖坑法</strong>，<strong>左右"指针"法</strong>，<strong>前后"指针"法</strong>，以及<strong>非递归的</strong>快速排序 (<strong>本文只讲述递归实现，非递归实现以后有专门的文章</strong>) ，并且这些算法中也会涉及多种优化措施，比如<strong>三数取中</strong>，<strong>小区间优化</strong>，下面都会一一介绍。</p> 
<p>由于它效率极高的缘故，快速排序也是日常开发中使用最多的，最重要的排序算法。</p> 
<h3><a id="1__7"></a>1. 挖坑法</h3> 
<p><strong>1.1 基本思想：</strong></p> 
<p>任取待排序元素序列中的<strong>某元素</strong>(<strong>一般选最左边或最右边的元素</strong>)作为<strong>基准值</strong>(也叫做 <strong>key 关键字</strong>)，按照该排序码将待排序集合<strong>分割成两子序列</strong>，<strong>左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值</strong>，然后左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</p> 
<p><strong>1.2 一趟排序图解如下：</strong></p> 
<p><strong>给定一无序数组，选第一个元素为关键字 key = 6</strong><br> <img src="https://images2.imgbox.com/25/7e/7Wvv7f9R_o.png" alt="在这里插入图片描述"></p> 
<p><strong>我们选定关键字 key = 6后，就说明6的位置就可以被覆盖了，所以我们就说左边形成了一个****坑</strong>，<strong>用pivot 表示</strong>。</p> 
<p><img src="https://images2.imgbox.com/d5/88/Vgs0fe3t_o.png" alt="![!](https://img-blog.csdnimg.cn/direct/3d53fed3d5e64ef4a46eb2d2f4faf554.png"></p> 
<p><strong>左边有坑，右边的 end 要从最后一个元素开始找比 key 小的数</strong>，<strong>找到后放到左边的坑里，所以5放进了坑中</strong></p> 
<p><img src="https://images2.imgbox.com/6b/b9/q4CCmjl5_o.png" alt="在这里插入图片描述"><br> 5被拿走之后，<strong>右边它原来所在的位置就形成了一个新坑</strong>，此时，<strong>左边的 begin 要开始找比 key 大的数</strong>，<strong>找到后放到右边的坑里，所以7放进了坑中</strong><br> <img src="https://images2.imgbox.com/b0/ac/KdICpB0S_o.png" alt="在这里插入图片描述"><br> 7<strong>被拿走后，左边又形成了一个新坑，此时，end 又要开始找比 key 小的数放到左边的坑里，所以4放进了坑中</strong></p> 
<p><img src="https://images2.imgbox.com/d5/eb/w9mHuGTl_o.png" alt="在这里插入图片描述"><br> <strong>此时，右边又形成了新坑，begin 要开始找比 key 大的数，找到后放到右边的坑里，所以9放进了坑中</strong></p> 
<p><img src="https://images2.imgbox.com/69/7c/9JrqnT8S_o.png" alt="在这里插入图片描述"><br> <strong>左边又形成了坑，右边 end 开始找，找到了3，放入坑中</strong></p> 
<p><img src="https://images2.imgbox.com/35/d7/0v1dy99x_o.png" alt="在这里插入图片描述"><br> <strong>最后一次 begin++ 后，begin 和 end 重叠了，并且它们一定相遇在坑中，此时，把 key 放入坑中即可。</strong></p> 
<p><img src="https://images2.imgbox.com/31/ae/Ecuttxri_o.png" alt="在这里插入图片描述"></p> 
<p><strong>上述操作只是第一趟排序，只排好了一个数，此时第一个基准 key = 6已经在它合适的位置上了(排好序后的位置)，后面对左右子序列排序时6不动。并且已经把数组分成了两个子序列，以 key 为基准，左边的元素都比它小，右边的元素都比它大。</strong></p> 
<p><strong>1.3 单趟排序的代码实现如下：</strong></p> 
<p><strong>注意：第二个和第三个 while 中的</strong> <em><strong>begin &lt; end</strong></em> <strong>不能缺少，要防止在找大和找小的时候 begin 和 end 错开或是在极端情况下(比如已经升序时)end一直减导致越界。</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> sz <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>

	<span class="token comment">//这是排一趟，只排好了一个数</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//左边有坑，右边end找比key小的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			end<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//小的放到了左边的坑里，右边end自己形成了新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> end<span class="token punctuation">;</span>

		<span class="token comment">//右边有坑，左边end找比key大的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			begin<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//大的放到右边的坑里，左边begin自己形成新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//最后begin和end相遇了，把key放入该位置</span>
	pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><strong>1.4 整体排序</strong></p> 
<p>要利用<strong>分治递归思想</strong>。第一趟排序把整个数组分割成了左子序列和右子序列，如果左右子序列都有序了，那么整个数组就有序了，所以再递归使用前面的挖坑算法，<strong>再找出关键字，再把左右子序列分割成子序列……</strong> 直到关键字的左右两边只有一个数据不可再递归，或者是关键字的左序列，右序列都是有序，那么整体就有序了。</p> 
<p><strong>如图所示：</strong><br> <img src="https://images2.imgbox.com/f6/03/hel62myD_o.png" alt="在这里插入图片描述"></p> 
<p><strong>1.5 整体排序过程代码实现如下：</strong></p> 
<p><strong>注意：因为是左右子序列，所以要控制一个区间。</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickySort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//当左右子区间不存在，或只有一个元素时，</span>
    <span class="token comment">//就不需要递归了，排序完成</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token keyword">int</span> begin <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> right<span class="token punctuation">;</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>

	<span class="token comment">//这是排一趟，只排好了一个数</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//左边有坑，右边end找比key小的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			end<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//小的放到了左边的坑里，右边end自己形成了新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> end<span class="token punctuation">;</span>

		<span class="token comment">//右边有坑，左边end找比key大的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			begin<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//大的放到右边的坑里，左边begin自己形成新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//最后begin和end相遇了，把key放入该位置</span>
	pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>

	<span class="token comment">//[left] pivot [right]</span>
	<span class="token comment">// [left pivot-1]  pivot [pivot+1 right]</span>
	<span class="token comment">//左子区间和右子区间有序，整体就有序了</span>

	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> pivot<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2__152"></a>2. 快速排序的优化</h3> 
<p><strong>2.1 三数取中</strong></p> 
<p>上文快排的算法思想有一个致命的缺陷：<strong>那就是当数据为有序时，其时间复杂度为O(N*N)。</strong></p> 
<blockquote> 
 <p><strong>原因：这是因为在取关键字 key 的值时，一直都是选最左边(或最右边)的数据。当数组本为升序时，每次关键字的右子序列的值都比它大，再次递归调用时，右子序列的子序列也是如此(降序同理)。</strong></p> 
</blockquote> 
<p><strong>所以这个缺陷的原因就是 key 的取值。</strong><br> 那该如何取 key的值呢？一个比较好的方法是<strong>三数取中</strong>。</p> 
<blockquote> 
 <p><strong>三数取中：并不是指取所有数据中间的那数，而是指在三个数中取那个不大不小的中间数，这个数可能在最左边，也可能在最右边。</strong></p> 
</blockquote> 
<p><strong>通过这种类似随机选数的方法，就能保证一定不是数据中最大或最小的值做 key。</strong></p> 
<p><strong>2.1.1 三数取中的代码的实现：</strong></p> 
<pre><code class="prism language-c"><span class="token comment">//三数取中</span>
<span class="token keyword">int</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//右移有除2的效果</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>   <span class="token comment">//arr[mid] &lt; arr[left]</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>但是挖坑算法中我们习惯拿 begin 作为 key ，为了保持挖坑算法不被改变，我们把 begin 指向的值和通过三数取中选出的数的指向的值进行交换，确保 key 仍是begin指向的值。</strong></p> 
<p><strong>代码实现为：</strong></p> 
<pre><code class="prism language-c">
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">QuickySort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>   
    <span class="token comment">//当左右子区间不存在，或只有一个元素时，</span>
    <span class="token comment">//就不需要递归了，排序完成</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">int</span> begin <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> right<span class="token punctuation">;</span>

    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换一下，保证key还是最左边的数</span>

	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>

	<span class="token comment">//这是排一趟，只排好了一个数</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//左边有坑，右边end找比key小的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			end<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//小的放到了左边的坑里，右边end自己形成了新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> end<span class="token punctuation">;</span>

		<span class="token comment">//右边有坑，左边end找比key大的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			begin<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//大的放到右边的坑里，左边begin自己形成新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//最后begin和end相遇了，把key放入该位置</span>
	pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>

	<span class="token comment">// [left] pivot [right]</span>
	<span class="token comment">// [left pivot-1]  pivot [pivot+1 right]</span>
	<span class="token comment">// 左子区间和右子区间有序，整体就有序了</span>

	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> pivot<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><strong>2.2 小区间优化</strong></p> 
<p>我们知道在函数调用的过程中会在内存中建立栈帧，栈帧的建立也是需要时间和空间的。假设用上述代码排100W个数据，则大致有20层的递归调用，但是在最后几层中就大概调用了80多万次函数，它占用了栈帧的绝大多数空间和时间。</p> 
<p>那么有人就会想，能不能把最后几层的函数递归调用消除呢？</p> 
<p><em><strong>官方给出的一种方法是小区间优化法，用于减少递归调用次数。</strong></em></p> 
<p><strong>就是在排序的过程中当左右子序列中的数据个数大于某个数量时，不进行递归了，而是选用其他排序算法进行排序。这里一般用插入排序。</strong></p> 
<p><strong>2.2.1 小区间优化的代码实现：</strong></p> 
<p><strong>(注意：插入排序的算法这里没有给出，想要了解的请前往我的主页。)</strong></p> 
<pre><code class="prism language-c"><span class="token comment">//小区间优化法:减少递归调用次数</span>

<span class="token comment">//  keyindex - 1 - left 指子序列中的元素个数</span>
<span class="token comment">//  &gt; 10是我们控制的一个界限  </span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>keyindex <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> left <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> keyindex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>  
    <span class="token comment">// arr + left 是指这时的子序列不一定从第一个元素开始</span>
    <span class="token comment">//keyindex - 1 - left + 1 是指元素的个数</span>
	<span class="token function">InsertSort</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> left<span class="token punctuation">,</span> keyindex <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> <span class="token punctuation">(</span>keyindex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> keyindex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">InsertSort</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> keyindex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token punctuation">(</span>keyindex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>但是由于小区间优化所带来的效率提升并不显著，而且它是与我们所控制的那个界限有关，所以平时并没有过于注重这个优化</strong>。</p> 
<p><strong>3.挖坑法的完整排序代码</strong></p> 
<pre><code class="prism language-c">
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//三数取中</span>
<span class="token keyword">int</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//右移有除2的效果</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>   <span class="token comment">//arr[mid] &lt; arr[left]</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//挖坑法</span>
<span class="token keyword">int</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换一下，保证key还是最左边的数</span>

	<span class="token keyword">int</span> begin <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> right<span class="token punctuation">;</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>

	<span class="token comment">//这是排一趟，只排好了一个数</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//左边有坑，右边end找比key小的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			end<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//小的放到了左边的坑里，右边end自己形成了新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> end<span class="token punctuation">;</span>

		<span class="token comment">//右边有坑，左边end找比key大的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			begin<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//大的放到右边的坑里，左边begin自己形成新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//最后begin和end相遇了，把key放入该位置</span>
	pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>

	<span class="token keyword">return</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">void</span> <span class="token function">QuickySort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>   
    <span class="token comment">//当左右子区间不存在，或只有一个元素时，</span>
    <span class="token comment">//就不需要递归了，排序完成</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
    <span class="token keyword">int</span> keyindex <span class="token operator">=</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// [left] keyindex [right]</span>
	<span class="token comment">// [left keyindex -1]  keyindex [keyindex +1 right]</span>
	<span class="token comment">// 左子区间和右子区间有序，整体就有序了</span>

	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> keyindex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> keyindex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//或是</span>
    <span class="token comment">/*if (keyindex - 1 - left &gt; 10)
{
	QuickySort(arr, left, keyindex - 1);
}
else
{  
    // arr + left 是指这时的子序列不一定从第一个元素开始
    //keyindex - 1 - left + 1 是指元素的个数
	InsertSort(arr + left, keyindex - 1 - left + 1);
}

if (right - (keyindex + 1) &gt; 10)
{
	QuickySort(arr, keyindex + 1, right);
}
else
{
	InsertSort(arr + keyindex + 1, right - (keyindex + 1) + 1);

}*/</span>

</code></pre> 
<p>排序结果为：<br> <img src="https://images2.imgbox.com/4a/cb/4Cjuduup_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3.1 时间复杂度与稳定性</strong></p> 
<p><strong>挖坑法的时间复杂度是O(N*logN),是不稳定的排序。</strong></p> 
<h3><a id="3_Hoare_457"></a>3. Hoare法</h3> 
<p><strong>3.1 算法思想：</strong></p> 
<blockquote> 
 <p>与挖坑法类似，一般也要用三数取中法选一个关键字做 key，最终也是把整个数组分割成左右两个子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值。</p> 
</blockquote> 
<p>只是实现的方式不同，左右"指针"法是<strong>分别从数组的最左边和最右边开始找数</strong>，<strong>左边的 begin 找比 key大的数</strong>，<strong>右边的 end 找比 key 小的数</strong>，<strong>找到后把这两个位置上的数交换</strong>，直到分割成左右两个子序列，然后左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</p> 
<p><strong>3.2 单趟排序的图解如下：</strong></p> 
<p><strong>给定一无序数组，选第一个元素为关键字 keyi = 6，这里的keyi是数组的下标</strong><br> <img src="https://images2.imgbox.com/30/87/VMcTEYLw_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d2905a16ec794096b226e39d8bcd8af6.png"></p> 
<p><strong>begin++ 找比 keyi 大的数，end – 找比 keyi 小的数，找到后停下来交换</strong><br> <img src="https://images2.imgbox.com/ab/a4/Bkie8z4M_o.png" alt="在这里插入图片描述"><br> <strong>重复上述操作</strong><br> <img src="https://images2.imgbox.com/57/e4/OFfo43VY_o.png" alt="在这里插入图片描述"><br> <strong>最后当 begin 和 end 相遇时，把相遇位置上的数与关键字 keyi所在位置的数交换：</strong><br> <img src="https://images2.imgbox.com/3f/28/MppM5TVu_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/450119654a7d4a46a921d89f45ad3bb7.png"></p> 
<p><strong>有人可能会想，为什么相遇位置的数据一定比keyi位置的数据小呢？</strong></p> 
<p>答案：<strong>这是右边先走保证的</strong>。</p> 
<p><img src="https://images2.imgbox.com/13/ec/TZ0LN4XO_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/db/b6/B5gSLSFn_o.png" alt="在这里插入图片描述"></p> 
<p><strong>最终排完第一趟后，以 keyi所指向的数6为基准，左边的元素都比它小，右边的元素都比它大。</strong></p> 
<p><strong>递归图解如下</strong>：</p> 
<p><img src="https://images2.imgbox.com/46/df/rXhmKhIN_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3.3 单趟排序的代码实现：</strong></p> 
<p><strong>注意：<br> 1.代码中的三数取中函数与交换函数在上文，此处就直接调用</strong><br> <strong>2.第二个和第三个while中的 begin &lt; end 和 &lt;= 中的等于号二者缺一不可。</strong><br> <img src="https://images2.imgbox.com/0f/6f/z2AE0L9y_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">PartSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换一下，保证key还是最左边的数</span>

	<span class="token keyword">int</span> begin <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> right<span class="token punctuation">;</span>
	<span class="token keyword">int</span> keyi <span class="token operator">=</span> begin<span class="token punctuation">;</span><span class="token comment">//第一个元素的下标</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//找比key小的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			end<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//找比key大的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			begin<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//当begin与end相遇时</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> begin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="4__530"></a>4. 前后"指针"法</h3> 
<p><strong>4.1 算法思想</strong></p> 
<blockquote> 
 <p>与挖坑法类似，一般也要用三数取中法选一个关键字做 key，最终也是把整个数组分割成左右两个子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值。</p> 
</blockquote> 
<p>只是实现方式不同，前后"指针"法是<strong>要定义两个前后变量( cur 和 prev，其中 cur 在前，prev 在后)分别指向数组的前两个元素，前面的 cur 先往前走，prev 后走，cur 找到比key 小的值，每次找到就停下来，prev++，再交换 prev 和 cur 所在位置的值。</strong></p> 
<p>直到分割成左右两个子序列，然后左右子序列重复该过程，直到所有元素都排列在相应位置上为止</p> 
<p><strong>4.2 单趟排序的部分图解如下：</strong></p> 
<p><strong>给定一无序数组，选第一个元素为关键字 keyi = 6，这里的keyi是数组的下标</strong></p> 
<p><img src="https://images2.imgbox.com/26/0f/dfDaOEM3_o.png" alt="在这里插入图片描述"><br> <strong>前几个数 cur 和 prev 重叠，省略图解</strong></p> 
<p><strong>当cur在3的位置上时，prev指向7，此时，交换两数</strong><br> <img src="https://images2.imgbox.com/b5/57/7xvYnWsw_o.png" alt="在这里插入图片描述"><br> <strong>再cur++指向了4，停下，prev++指向了9，此时再交换</strong><br> <img src="https://images2.imgbox.com/73/31/quFp0HOw_o.png" alt="在这里插入图片描述"><br> <strong>………………(重复上述操作)</strong></p> 
<p><strong>当cur超出数组界限时，把此时 prev 所指向的值和 keyi 所指向的关键字交换，最终的结果是：</strong></p> 
<p><img src="https://images2.imgbox.com/02/53/YxJbGzqQ_o.png" alt="在这里插入图片描述"><br> <strong>最终排完第一趟后，以 keyi所指向的数6为基准，左边的元素都比它小，右边的元素都比它大。</strong></p> 
<p><strong>4.3 单趟排序的代码实现如下：</strong></p> 
<pre><code class="prism language-c">
<span class="token comment">//前后指针法</span>
<span class="token keyword">int</span>  <span class="token function">PartSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换一下，保证key还是最左边的数</span>

	<span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> prev <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> cur <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//if (arr[cur] &lt; arr[keyi])</span>
		<span class="token comment">//++prev后如果跟cur相等就不交换</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>prev <span class="token operator">!=</span> cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//prev++;</span>
			<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>4.4 代码的小优化</strong></p> 
<p><strong>通过上面的图解可知，当 cur 和 prev 重叠时，我们也进行了交换，但是这种自己和自己的交换其实是多于的。</strong></p> 
<p><strong>优化代码如下：</strong></p> 
<p><strong>在if判断条件中多了++prev != cur</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span>  <span class="token function">PartSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换一下，保证key还是最左边的数</span>

	<span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> prev <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> cur <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	   <span class="token comment">//++prev != cur是指当cur和prev重合时不用多于的交换</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>prev <span class="token operator">!=</span> cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_622"></a>二，快速排序总结：</h2> 
<ul><li><strong>快速排序的三种思想虽然实现方式不同，但是最终结果都是以key为基准值把整个数组分割成左右两个子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值。</strong></li><li><strong>在我们日常写快速排序算法时，那两种优化方式三数取中，最小区间优化并不是一定要有，可以根据情况自主添加。</strong></li></ul> 
<p><strong>1.比如没有优化的Hoare法的代码实现：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//区间只有一个值或者不存在就结束</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> begin <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> right<span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token comment">//基准位置</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//右边找小</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//左边找大</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>

	<span class="token comment">//[begin,keyi-1] keyi [keyi+1,end]</span>
	<span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>2.比如没有优化的前后"指针"法的代码实现：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickySort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//当左右子区间不存在，或只有一个元素时，</span>
    <span class="token comment">//就不需要递归了，排序完成</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> prev <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> cur <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	   <span class="token comment">//++prev != cur是指当cur和prev重合时不用多于的交换</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>prev <span class="token operator">!=</span> cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	keyi <span class="token operator">=</span> prev<span class="token punctuation">;</span>
	
	<span class="token comment">// [left keyi -1]  keyi [keyi +1 right]</span>

	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> keyi<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> keyi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>3.比如没有优化的挖坑法的代码实现：</strong></p> 
<pre><code class="prism language-c">
<span class="token keyword">void</span> <span class="token function">QuickySort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//当左右子区间不存在，或只有一个元素时，</span>
    <span class="token comment">//就不需要递归了，排序完成</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token keyword">int</span> begin <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> right<span class="token punctuation">;</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>

	<span class="token comment">//这是排一趟，只排好了一个数</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//左边有坑，右边end找比key小的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			end<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//小的放到了左边的坑里，右边end自己形成了新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> end<span class="token punctuation">;</span>

		<span class="token comment">//右边有坑，左边end找比key大的</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			begin<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//大的放到右边的坑里，左边begin自己形成新的坑</span>
		arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//最后begin和end相遇了，把key放入该位置</span>
	pivot <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>

	<span class="token comment">//[left] pivot [right]</span>
	<span class="token comment">// [left pivot-1]  pivot [pivot+1 right]</span>
	<span class="token comment">//左子区间和右子区间有序，整体就有序了</span>

	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> pivot<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickySort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>4.复杂度和稳定性的分析</strong><br> 1.<strong>最坏：有序或接近有序时，时间复杂度为O(N^2)</strong> <strong>数据为随机值时，时间复杂度为O(N*logN)</strong>。<br> 2.<strong>空间复杂度：由于递归要建立栈帧，O(logN)</strong>。<br> 2.<strong>快速排序算法是不稳定的</strong>。</p> 
<h2><a id="_764"></a>三，冒泡排序</h2> 
<p><strong>1.基本思想：</strong></p> 
<p><strong>从序列的一端开始往另一端冒泡，依次比较相邻的两个数的大小。</strong></p> 
<p><strong>设数组长度为N。</strong></p> 
<p>1.<strong>每轮比较相邻的前后两个数据，如果前面数据大于(或者小于)后面的数据，就将这两个个数据交换。</strong></p> 
<p>2.<strong>这样每轮对数组的第0个数据到N-1个数据进行一次遍历后，最大或者最小的一个数据就到数组第N-1个位置。</strong></p> 
<p>3.<strong>第一轮比较到下标为N-1的数据（最后一个），以后每次比较都-1。</strong></p> 
<p><strong>2.图解冒泡排序：</strong><br> <strong>以 [ 8，2，5，9，7 ] 这组数字来做示例：<br> 从左往右依次冒泡，将小的往右移动(排降序)<br> 第一轮冒泡：</strong><br> <img src="https://images2.imgbox.com/5d/6d/pZorr3k1_o.png" alt="在这里插入图片描述"><br> 首先比较第一个数和第二个数的大小，我们发现 2 比 8 要小，那么保持原位，不做改动。位置还是 8，2，5，9，7 。指针往右移动一格，接着比较：</p> 
<p><img src="https://images2.imgbox.com/dd/1e/1W4BiFRi_o.png" alt="在这里插入图片描述"></p> 
<p>比较第二个数和第三个数的大小，发现 2 比 5 要小，所以位置交换，交换后数组更新为：[ 8，5，2，9，7 ]。<br> 指针再往右移动一格，继续比较：</p> 
<p><img src="https://images2.imgbox.com/72/98/k1si6iSA_o.png" alt="在这里插入图片描述"></p> 
<p>比较第三个数和第四个数的大小，发现 2 比 9 要小，所以位置交换，交换后数组更新为：[ 8，5，9，2，7 ]。同样，指针再往右移动，继续比较：</p> 
<p><img src="https://images2.imgbox.com/46/45/VxgKAh3D_o.png" alt="在这里插入图片描述"></p> 
<p>比较第 4 个数和第 5 个数的大小，发现 2 比 7 要小，所以位置交换，交换后数组更新为：[ 8，5，9，7，2 ]。</p> 
<p>下一步，指针再往右移动，发现已经到底了，则本轮冒泡结束，处于最右边的 2 就是已经排好序的数字。</p> 
<p><strong>通过这一轮不断的对比交换，数组中最小的数字移动到了最右边。</strong></p> 
<p><strong>重复上述步骤，得到的最终结果是：</strong></p> 
<p><img src="https://images2.imgbox.com/66/66/kY9n0bzd_o.png" alt="在这里插入图片描述"><br> <strong>3.代码实现冒泡排序如下：</strong></p> 
<pre><code class="prism language-c">
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//一趟排序</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token operator">-</span>j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//前一个比后一个小，就交换</span>
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>4.冒泡排序的小优化：</strong></p> 
<p><strong>假设我们要排降序，如果数组此时就是降序，那么在第一轮比较过后数据并没有发生交换，那就不要再进行多于的后续比较了，直接跳出循环即可。</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//默认是有序的</span>
		<span class="token comment">//一趟排序</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token operator">-</span>j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//前一个比后一个大，就交换</span>
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				
				<span class="token comment">//如果不是有序的就发生了交换，exchange=1</span>
				exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//如果一趟比较过后发现是有序的，就直接跳出循环</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>5.时间复杂度和稳定性的分析</strong></p> 
<blockquote> 
 <p><strong>最好：就是顺序时，时间复杂度为O(N)</strong><br> <strong>乱序时：时间复杂度为O(N*N)</strong></p> 
</blockquote> 
<p><strong>所以冒泡排序的时间复杂度是O(N*N)。<br> 冒泡排序算法是稳定的。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/946827ec1fc4f030767b912b691614bf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C/排序算法】：堆排序和选择排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c670d627a34ca48a19eab196a6298ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(附源码)HTML&#43;JavaScript&#43;Canvas编写2D小游戏</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>