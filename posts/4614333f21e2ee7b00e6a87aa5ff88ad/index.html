<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java 基础】：三大特征之多态 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4614333f21e2ee7b00e6a87aa5ff88ad/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java 基础】：三大特征之多态">
  <meta property="og:description" content="✨ 杏花疏影里，吹笛到天明 🌏 📃个人主页：island1314
🔥个人专栏：java学习
⛺️ 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
🚀引言 在前两篇博客中，我们已经讲完了面向对象程序三大特性之一的封装、继承，
【Java 基础】类和对象（构造&amp;this&amp;封装&amp;static&amp;代码块）-CSDN博客
【Java 基础】三大特征之继承-CSDN博客
下面让我们来看看多态有哪些内容吧
1. 多态概念 💢💢在Java中，多态是面向对象编程中的一个重要概念，它允许不同类型的对象对同一方法进行不同的实现。具体来说，多态性指的是通过父类的引用变量来引用子类的对象，从而实现对不同对象的统一操作。
多态是方法或对象具有多种形态，是面向对象的第三大特征。多态的前提是两个对象（类）存在继承关系，多态是建立在封装和继承基础之上的。 2. 多态实现条件 在Java中，要实现多态性，就必须满足以下条件：
继承关系
存在继承关系的类之间才能够使用多态性。多态性通常通过一个父类用变量引用子类对象来实现。
方法重写
子类必须重写（Override）父类的方法。通过在子类中重新定义和实现父类的方法，可以根据子类的特点行为改变这个方法的行为，如猫和狗吃东西的独特行为。
父类引用指向子类对象
使用父类的引用变量来引用子类对象。这样可以实现对不同类型的对象的统一操作，而具体调用哪个子类的方法会在运行时多态决定
例如，下面的案例是根据猫和狗吃东西动作的不同，而实现的多态：
class Animal { public void eat() { System.out.println(&#34;动物吃东西&#34;); } } class Dog extends Animal { @Override public void eat() { System.out.println(&#34;狗吃狗粮&#34;); } } class Cat extends Animal { @Override public void eat() { System.out.println(&#34;猫吃猫粮&#34;); } } public class Test { public static void main(String[] args) { Animal animal1 = new Dog(); // 父类引用指向子类对象 Animal animal2 = new Cat(); // 父类引用指向子类对象 animal1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-03T13:17:05+08:00">
    <meta property="article:modified_time" content="2024-09-03T13:17:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java 基础】：三大特征之多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="720" src="https://images2.imgbox.com/c0/9e/LxVIS9IY_o.jpg" width="1200"></p> 
<p>✨                                                 <span style="color:#79c6cd;"><strong>杏花疏影里，吹笛到天明</strong></span>       🌏 </p> 
<p>📃个人主页：island1314</p> 
<p>🔥个人专栏：java学习</p> 
<p>⛺️  欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/05/ae/U7AcOMFd_o.gif"></p> 
<hr> 
<h3 id="%F0%9F%9A%80%E5%BC%95%E8%A8%80%C2%A0" style="background-color:transparent;">🚀引言 </h3> 
<p>在前两篇博客中，我们已经讲完了面向对象程序三大特性之一的<strong>封装、继承，</strong></p> 
<p><a href="https://blog.csdn.net/island1314/article/details/141780802?spm=1001.2014.3001.5501" title="【Java 基础】类和对象（构造&amp;this&amp;封装&amp;static&amp;代码块）-CSDN博客">【Java 基础】类和对象（构造&amp;this&amp;封装&amp;static&amp;代码块）-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/island1314/article/details/141804502?spm=1001.2014.3001.5501" title="【Java 基础】三大特征之继承-CSDN博客">【Java 基础】三大特征之继承-CSDN博客</a></p> 
<p><strong>下面让我们来看看多态有哪些内容吧</strong></p> 
<p></p> 
<h3>1.  多态概念</h3> 
<p>💢💢在Java中，多态是<a href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B&amp;spm=1001.2101.3001.7020" title="面向对象编程">面向对象编程</a>中的一个重要概念，它<strong>允许不同类型的对象对同一方法进行不同的实现</strong>。具体来说，<strong>多态性指的是通过父类的引用变量来引用子类的对象，从而实现对不同对象的统一操作</strong>。</p> 
<ul><li><strong>多态</strong>是方法或对象具有<strong>多种形态</strong>，是<strong>面向对象的第三大特征</strong>。</li><li><strong>多态</strong>的<strong>前提</strong>是两个对象（类）存在<strong>继承</strong>关系，多态是建立在封装和继承基础之上的。</li></ul> 
<h3>2. 多态实现条件</h3> 
<p>在Java中，要实现<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E6%80%81%E6%80%A7&amp;spm=1001.2101.3001.7020" title="多态性">多态性</a>，就必须满足以下条件：</p> 
<ol><li> <p>继承关系<br> 存在继承关系的类之间才能够使用多态性。多态性通常通过一个父类用变量引用子类对象来实现。</p> </li><li> <p><a href="https://so.csdn.net/so/search?q=%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99&amp;spm=1001.2101.3001.7020" title="方法重写">方法重写</a><br> 子类必须重写（Override）父类的方法。通过在子类中重新定义和实现父类的方法，可以根据子类的特点行为改变这个方法的行为，如猫和狗吃东西的独特行为。</p> </li><li> <p>父类引用指向子类对象<br> 使用父类的引用变量来引用子类对象。这样可以实现对不同类型的对象的统一操作，而具体调用哪个子类的方法会在运行时多态决定</p> </li></ol> 
<p><strong>例如，下面的案例是根据猫和狗吃东西动作的不同，而实现的多态：</strong></p> 
<pre><code class="language-cpp">class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }
}
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃狗粮");
    }
}
class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃猫粮");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal animal1 = new Dog(); // 父类引用指向子类对象
        Animal animal2 = new Cat(); // 父类引用指向子类对象
        animal1.eat(); // 输出：狗吃狗粮
        animal2.eat(); // 输出：猫吃猫粮
    }
}</code></pre> 
<p>上面代码中涉及的 Override 叫作 重写</p> 
<h3 style="background-color:transparent;">3. 重写</h3> 
<h4><span style="color:#956fe7;">3.1 重写概念</span></h4> 
<p>💢💢<strong>重写(override)：</strong>也称为覆盖。是 子类对父类非静态、非private修饰，非final修饰，非构造方法等的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p> 
<p>想要理解方法重写，需要知道以下概念：</p> 
<ol><li> <p><span style="color:#b95514;"><strong>继承关系</strong></span><br> 重写方法是基于父类和子类之间的继承关系。子类继承了父类的方法，包括方法的名称、参数列表和返回类型。</p> </li><li> <p><span style="color:#b95514;"><strong>方法签名</strong></span><br> 重写的方法与父类的方法具有相同的方法签名，即方法的名称、参数列表和返回类型必须一致（当然，如果返回类型的对象本身的类型则可以不同，但是必须要有继承关系）。方法签名不包括方法体。</p> </li><li> <p><strong><span style="color:#b95514;">@Override注解</span></strong><br> 为了明确表明这是一个重写的方法，可以使用 <code>@Override</code> 注解来标记子类中的方法。该注解会在编译时检查是否满足重写条件，如果不满足会报错。</p> </li><li> <p><span style="color:#b95514;"><strong>动态绑定</strong></span><br> 通过父类引用变量调用被子类重写的方法时，会根据实际引用的对象类型，在运行时动态绑定到相应的子类方法。（下面我们会进行详细讲解）</p> </li></ol> 
<h4><span style="color:#956fe7;"><strong>3.2 方法重写的规则</strong></span></h4> 
<ol><li>子类在重写父类的方法时，一般必须与父类方法原型一致： <strong>返回值类型 方法名 (参数列表) 要完全一致</strong></li><li>被重写的方法返回值类型可以不同，但是必须是具有父子关系的</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类方法被public修饰，则子类中重写该方法就不能声明为 protected。</li><li>父类被static、private修饰的方法、构造方法都不能被重写。</li><li>重写的方法, 可以使用 <strong><span style="color:#ffd900;">@Override</span><span style="color:#f9eda6;"> </span></strong>注解来显式指定. 有了这个注解能帮我们进行一些合法性校验. 例如不小心将方法名字拼写错了， 那么如果此时编译器没有在发现父类中找到该方法, 那么就会<strong>编译报错, 提示无法构成重写</strong></li></ol> 
<p><strong>注：</strong>子类中重写的方法可以调用父类中被重写的方法，使用 <code>super</code> 关键字。</p> 
<p></p> 
<h4 style="background-color:transparent;"><span style="color:#956fe7;"><strong>3.3 重写和重载的区别</strong></span></h4> 
<blockquote> 
 <p></p> 
 <p>首先回顾重载的实现条件：</p> 
 <ol><li>方法名称相同：重载的方法必须具有相同的名称。</li><li>参数列表不同：重载的方法的参数列表必须不同。<strong>参数列表可以通过参数的类型、个数或顺序的不同来区分重载方法</strong>。</li><li>返回类型可以相同也可以不同：<strong>重载的方法可以具有相同的返回类型，也可以具有不同的返回类型</strong>。返回类型不是重载方法的区分标准。</li><li>方法所在的类中：<strong>重载方法必须定义在同一个类中</strong>。</li><li>方法的访问修饰符和异常：重载方法可以具有相同的访问修饰符（如 <code>public</code>、<code>private</code>、<code>protected</code>）和抛出的异常。</li></ol> 
</blockquote> 
<table border="1" cellpadding="1" cellspacing="1" style="width:670px;"><tbody><tr><td style="text-align:center;"><strong>区别点</strong></td><td style="text-align:center;"><strong>重写</strong></td><td style="text-align:center;"><strong>重载</strong></td></tr><tr><td style="text-align:center;">定义位置</td><td style="text-align:center;">定义在父类和子类之间</td><td style="text-align:center;">定义在同一个类中</td></tr><tr><td style="text-align:center;">方法签名</td><td style="text-align:center;">重写方法具有相同的名称和方法签名</td><td style="text-align:center;">重载方法具有相同的名称，但方法签名（参数类型和个数）不同</td></tr><tr><td style="text-align:center;"> <p style="text-align:center;">继承关系</p> </td><td style="text-align:center;">是在子类中对父类方法的重新定义和实现</td><td style="text-align:center;">不涉及继承关系，可以在同一个类中定义</td></tr><tr><td style="text-align:center;">运行时调用</td><td style="text-align:center;">是根据对象的实际类型进行<strong>动态绑定</strong>，<strong>在运行时确定</strong></td><td style="text-align:center;">是根据方法的参数列表的不同进行<strong>静态绑定</strong>，<strong>在编译时确定</strong></td></tr><tr><td style="text-align:center;">目的</td><td style="text-align:center;">用于子类重新定义父类方法的行为，以适应子类的特定需求</td><td style="text-align:center;">用于在同一个类中实现相似功能但具有不同参数的方法</td></tr></tbody></table> 
<h4 style="background-color:transparent;"><span style="color:#956fe7;">3.4 重写的设计原则</span></h4> 
<p>☘️对于已经投入使用的类，尽量不要进行修改。最好的方式是：重新定义一个新的类，来重复利用其中共性的内容，并且添加或者改动新的内容</p> 
<p><strong>🍀静态绑定</strong>：也称为前期绑定(早绑定)，即在编译时，根据用户所传递实参类型就确定了具体调用那个方法。典型代表函数重载。</p> 
<p></p> 
<p><strong>🌿动态绑定</strong>：也称为后期绑定(晚绑定)，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体调用那个类的方法。</p> 
<ul><li>当调用<strong>对象方法</strong>的时候，该方法会和该对象的<strong>运行类型</strong>绑定</li><li>当调用<strong>对象属性</strong>时，<strong>没有动态绑定</strong>机制，即哪里声明，哪里使用。</li><li><strong>代码示例</strong>： <pre><code class="language-cpp">//父类
class Person {
	public void mission() {	
		System.out.println("人要好好活着！");
	}
}

//子类
class Student extends Person {
	@Override
	public void mission() {	
		System.out.println("学生要好好学习！");
	}
}

//演示动态绑定
public class DynamicBinding {
	public static void main(String[] args) {
		//向上转型（自动类型转换）
		//程序在编译阶段只知道 p1 是 Person 类型
		//程序在运行的时候才知道堆中实际的对象是 Student 类型	
		Person p1 = new Student();  
		
		//程序在编译时 p1 被编译器看作 Person 类型
		//因此编译阶段只能调用 Person 类型中定义的方法
		//在编译阶段，p1 引用绑定的是 Person 类型中定义的 mission 方法（静态绑定）
		//程序在运行的时候，堆中的对象实际是一个 Student 类型，而 Student 类已经重写了 mission 方法
		//因此程序在运行阶段对象中绑定的方法是 Student 类中的 mission 方法（动态绑定）
		p1.mission();
	}
}


/* 结果输出
 *   学生要好好学习! 
 * */</code></pre> <p></p> </li></ul> 
<p>🍎🍎总的来说：<strong>重载是在同一个类中根据参数列表的不同定义多个具有相同名称但参数不同的方法，而重写是子类重新定义和实现了从父类继承的方法。</strong>重载方法通过<strong>静态绑定在编译时确定调用</strong>，重写方法通过<strong>动态绑定在运行时确定调用</strong>。重载用于实现相似功能但具有不同参数的方法，重写用于改变父类方法的行为以适应子类的需求。</p> 
<p></p> 
<h3 style="background-color:transparent;">4. 多态的转型</h3> 
<h4>4.1 向上转型</h4> 
<p><span style="color:#b95514;"><strong>（1）本质</strong>：</span>父类的引用指向子类的对象</p> 
<p><span style="color:#b95514;"><strong>（2）特点</strong>：</span></p> 
<blockquote> 
 <ol><li>编译类型看左边，运行类型看右边</li><li>可以调用父类的所有成员（需遵守访问权限）</li><li><strong>不能调用子类的特有成员</strong></li><li>运行效果看子类的具体实现</li></ol> 
</blockquote> 
<p><span style="color:#b95514;"><strong>（3）语法：</strong></span>父类类型 对象名 = new 子类类型()</p> 
<p><span style="color:#b95514;"><strong>（4）样例代码：</strong></span></p> 
<pre><code class="language-cpp">class A1{
    public String name;
    public int age;

    public A1(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void eat(){
        System.out.println(this.name + " 父类");
    }
    public void bark1(){
        System.out.println(this.name + " 不构成重写父类调用");
    }
}

class A2 extends A1 {
    private int num = 1;

    public A2(String name, int age){
        super(name,age);
    }
    public void eat(){ //和父类构成 重写
        System.out.println(this.name + " 子类");
    }
    public void bark2(){
        System.out.println(this.name + " 不构成重写子类调用");
    }
}

public class Test {
    public static void func1(A1 a) {
        a.eat();
        a.bark1();
    }
    public static A1 func2() {
        A1 a = new A2("change",18);
        return a;
    }

    public static void main(String[] args) {
        // 向上转型
        // 1. 直接赋值
        A2 a2 = new A2("change", 18);
        A1 a1 = a2; // 子类 A2 这个引用父类这个引用所指向对象
        // 上下两种相同
        A1 a = new A2("change", 18);
        a.eat(); // 调用的是 子类 中的 eat() 方法
        //a.bark2(); // 错误：无法访问 子类中独有的方法

        // 2，方法的参数，传参的时候进行向上转型
        // 传的是子类时，只能调用子类的方法
        //func1(a);
        func1(a2);

        // 3. 返回值向上转型
        func2();
    }
}

/* 结果输出
*   change 子类
*   change 子类
*   change 不构成重写父类调用
* */</code></pre> 
<p><span style="color:#956fe7;"><strong>【优缺点】</strong></span></p> 
<p>优点：让代码实现更简单灵活。<br> 缺陷：不能调用到子类特有的方法。</p> 
<h4>4.2 向下转型</h4> 
<p><span style="color:#b95514;"><strong>（1）本质</strong>：</span>一个已经向上转型的子类对象，将<strong>父类引用转为子类引用</strong></p> 
<p><span style="color:#b95514;"><strong>（2）特点</strong>：</span></p> 
<blockquote> 
 <ol><li>只能<strong>强制转换父类的引用</strong>，不能强制转换父类的对象</li><li>要求父类的引用<strong>必须指向</strong>的是<strong>当前目标类型的对象</strong></li><li>当向下转型后，<strong>可以调用子类</strong>类型中<strong>所有的成员</strong></li></ol> 
</blockquote> 
<p><span style="color:#b95514;"><strong>（3）语法：</strong></span>子类类型 引用名 = (子类类型) 父类引用;</p> 
<p><span style="color:#b95514;"><strong>（4）样例代码：</strong></span></p> 
<pre><code class="language-cpp">class Animal {
    public void eat() {
        System.out.println("Animal is eating.");
    }
}
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating");
    }
    public void bark() {
        System.out.println("Dog is barking");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("Cat is eating");
    }
    public void bark() {
        System.out.println("Cat is barking");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Dog();  // 向上转型
        animal.eat();  // 调用的是 Dog 类中的 eat() 方法
        // animal.bark();  // 错误：无法访问 Dog 类中独有的方法

        Dog dog = (Dog) animal;  // 向下转型
        dog.bark();  // 调用 Dog 类中的 bark() 方法
    }
}

/* 结果输出
 *   Dog is eating
 *   Dog is barking
 * */</code></pre> 
<p>向下转型用的比较少，而且不安全，万一转换失败，运行时就会抛异常。 比如我们在上面代码进行一些修改：</p> 
<p><img alt="" height="308" src="https://images2.imgbox.com/0e/ac/xvJ5VLsX_o.png" width="1200"></p> 
<p> <strong>解释</strong>：这段代码在运行时出现了 <strong>ClassCastException 类型转换异常</strong>，<strong>原因</strong>是 Dog 类与 Cat 类 <strong>没有继承关系</strong>，因此所创建的是 Dog 类型对象在<strong>运行时不能转换</strong>成 Cat 类型对象。</p> 
<p></p> 
<h4 style="background-color:transparent;">4.3 instanceof 关键字</h4> 
<p>因此Java中为了<strong>避免</strong>上述<strong>类型转换异常</strong>的问题，提高向下转型的安全性，引入了 <strong>instanceof</strong> 比较操作符，用于<strong>判断对象的类型是否为XX类型或XX类型的子类型，</strong>如果该表达式为true，则可以安全转换。 </p> 
<ul><li><strong>格式</strong>：对象 instanceof 类名称</li><li><strong>解释</strong>：这将会得到一个<strong>boolean</strong>值结果，也就是判断前面的对象能不能当作后面类型的实例</li><li><strong>代码示例</strong> ：</li></ul> 
<pre><code class="language-cpp">class Animal {
    public void eat() {
        System.out.println("Animal is eating.");
    }
}
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating");
    }
    public void bark() {
        System.out.println("Dog is barking");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("Cat is eating");
    }
    public void bark() {
        System.out.println("Cat is barking");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Dog();  // 向上转型

        if(animal instanceof Dog){ //判断对象 animal 是否是 Dog 类 的实例
            Dog dog = (Dog) animal;  // 向下转型
            dog.bark();  // 调用 Dog 类中的 bark() 方法
            //上面这两句也可简写为 ((Dog) animal).bark();
        }
        else if(animal instanceof  Cat){ //判断对象 animal 是否是 Cat 类 的实例
            ((Cat)animal).bark();
        }

    }
}</code></pre> 
<h3 style="background-color:transparent;"><strong>5. 多态的优缺点及应用</strong></h3> 
<h4>5.1 多态的优缺点</h4> 
<p><span style="color:#956fe7;"><strong>【使用多态的好处】</strong></span></p> 
<p></p> 
<ol><li><span style="color:#b95514;"><strong>灵活性和可扩展性：</strong></span>多态性使得代码具有更高的灵活性和可扩展性。通过使用父类类型的引用变量，可以以统一的方式处理不同类型的对象，无需针对每个具体的子类编写特定的代码。</li><li><span style="color:#b95514;"><strong>代码复用：</strong></span>多态性可以促进代码的复用。可以将通用的操作定义在父类中，然后由子类继承并重写这些操作。这样一来，多个子类可以共享相同的代码逻辑，减少了重复编写代码的工作量。</li><li> <p><span style="color:#b95514;"><strong>可替换性：</strong></span>多态性允许将一个对象替换为其子类的对象，而不会影响程序的其他部分。这种可替换性使得系统更加灵活和可维护，可以方便地添加新的子类或修改现有的子类，而无需修改使用父类的代码。</p> </li><li> <p><span style="color:#b95514;"><strong>代码扩展性：</strong></span>通过引入新的子类，可以扩展现有的代码功能，而无需修改现有的代码。这种可扩展性使得系统在需求变化时更加容易适应和扩展。</p> </li></ol> 
<p><span style="color:#956fe7;"><strong>【使用多态的缺陷】</strong></span></p> 
<ol><li><span style="color:#b95514;"><strong>运行时性能损失：</strong></span><span style="color:#0d0016;">多态性需要在运行时进行方法的动态绑定，这会带来一定的性能损失。相比于直接调用具体的子类方法，多态性需要在运行时确定要调用的方法，导致额外的开销。</span></li><li><span style="color:#b95514;"><strong>代码可读性下降：</strong></span><span style="color:#0d0016;">多态性使得代码的行为变得更加动态和不确定。在某些情况下，可能需要跟踪代码中使用的对象类型和具体的方法实现，这可能降低代码的可读性和理解性。</span></li><li><span style="color:#b95514;"><strong>限制访问子类特有成员：</strong></span><span style="color:#0d0016;">通过父类类型的引用变量，只能访问父类及其继承的成员，无法直接访问子类特有的成员。如果需要访问子类特有的成员，就需要进行向下转型操作，这增加了代码的复杂性和维护的难度。</span></li></ol> 
<p>虽然多态性具有一些缺点，但在大多数情况下，其优点远远超过缺点，使得代码更具灵活性、可扩展性和可维护性。因此，多态性在Java编程中被广泛应用。</p> 
<h4 style="background-color:transparent;">5.2 多态的应用</h4> 
<p style="background-color:transparent;">🥝<strong><span style="color:#956fe7;">多态数组</span></strong></p> 
<p><strong>多态数组</strong>：数组的<strong>定义</strong>类型为<strong>父类</strong>类型，里面保存的<strong>实际</strong>元素类型为<strong>子类</strong>类型。<br><strong>代码示例</strong>：（<strong>循环调用基类对象，访问不同派生类的方法</strong>）</p> 
<pre><code class="language-cpp">class Animal {
    public void eat() {
        System.out.println("Animal is eating.");
    }
}
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("Cat is eating");
    }
}
public class Test{

    public static void main(String[] args) {
        Animal[] animals = {new Animal(),new Dog(),new Cat()};
        for(Animal a: animals){a.eat();};
    }
}


/* 结果输出
* Animal is eating.
* Dog is eating
* Cat is eating
* */</code></pre> 
<p></p> 
<h3 style="background-color:transparent;">6. 注意事项</h3> 
<p>我们需要避免在构造方法中调用重写的方法，<strong>先来看一段代码：</strong></p> 
<p></p> 
<pre><code class="language-cpp">class B {
    public B() {
        // do nothing
        func();
    }
    public void func() {
        System.out.println("B.func()");
    }
}

class D extends B {
    private int num = 1;
    @Override
    public void func() {
        System.out.println("D.func() " + num);
    }
}

public class Test {
    public static void main(String[] args) {
        D d = new D();
    }
}</code></pre> 
<p></p> 
<p>上面这段代码的运行结果是：<code>D.func 0</code>，其原因如下：</p> 
<blockquote> 
 <ol><li>构造 D 对象的同时, 会调用 B 的构造方法。</li><li>B 的构造方法中调用了 func 方法, 此时会触发动态绑定, 会调用到 D 中的 func 方法。</li><li>此时 D 对象自身还没有构造，因此 num 处在未初始化的状态，其值为 0。 如果具备多态性，num的值则应该是1。</li><li>所以在构造函数内，尽量避免使用实例方法，除了 final 和 private 方法。</li></ol> 
</blockquote> 
<p></p> 
<p>结论: “用尽量简单的方式使对象进入可工作状态”, 尽量不要在构造器中调用方法(如果这个方法被子类重写, 就会触发动态绑定, 但是此时子类对象还没构造完成), 可能会出现一些隐藏的但是又极难发现的问题</p> 
<hr> 
<blockquote> 
 <p>💞 💞 💞<strong>那么本篇到此就结束，希望我的这篇博客可以给你提供有益的参考和启示，感谢大家支持！！！祝大家天天开心</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/89/1c/TRHwKg4R_o.gif"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/498a0a3b6011e5b960254d30d48d6c5d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python程序交易助你发现均线粘合的股票</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af7fa82df60901ac310ff62f076b5eb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">工业网关在汽车智能工厂中的应用-天拓四方</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>