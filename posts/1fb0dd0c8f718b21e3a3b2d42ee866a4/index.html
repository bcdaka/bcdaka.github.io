<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图——图的遍历（DFS与BFS算法详解） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1fb0dd0c8f718b21e3a3b2d42ee866a4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="图——图的遍历（DFS与BFS算法详解）">
  <meta property="og:description" content="前面的文章中我们学习了图的基本概念和存储结构，大家可以通过下面的链接学习：
图的定义和基本术语
图的类型定义和存储结构
这篇文章就来学习一下图的重要章节——图的遍历。
目录
一，图的遍历定义：
二，深度优先搜索(DFS)
连通图的深度优先遍历
邻接矩阵法实现DFS
邻接表法实现DFS
DFS算法效率分析：
非连通图的深度优先遍历
三， 广度优先搜索（BFS）
邻接矩阵法实现BFS
邻接表法实现BFS
BFS算法效率分析：
DFS与BFS算法效率比较
一，图的遍历定义： 从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。
图遍历的实质：找每个顶点的邻接点的过程。
要进行图的遍历，我们需要知道图的特点，从而用合适，高效的方法来实现遍历。
图有哪些特点？
图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 那么，如何避免在遍历时重复访问？
解决思路：
设置辅助数组 visited [n ]，用来标记每个被访问过的顶点。
初始状态为0
被访问，改 visited [i]为1，防止被多次访问。
图常用的遍历有两种：
深度优先搜索（Depth First Search,DFS） 广度优先搜索(Breadth First Search,BFS) 二，深度优先搜索(DFS) 引例：
点亮迷宫中所有的灯，我们会一条道走到头，如果走不动了，再往回退寻找其他没有走过的。
因此我们可以总结DFS的详细归纳：
在访问图中某一起始顶点 v 后，由 v 出发，访问 它的任一邻接顶点 w 1 ； 再从 w 1 出发DFS 邻接 但还 未被访问 过的顶点 w 2 ； 然后再从 w 2 出发，进行类似的访问， … 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。 接着，退回一步， 退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。 如果有， 则访问此顶点，之后再从此顶点出发，进行与前述类似的访问。 如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T23:49:43+08:00">
    <meta property="article:modified_time" content="2024-07-23T23:49:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图——图的遍历（DFS与BFS算法详解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前面的文章中我们学习了图的基本概念和存储结构，大家可以通过下面的链接学习：</p> 
<p><a class="link-info" href="http://t.csdnimg.cn/i5bQY" rel="nofollow" title="图的定义和基本术语">图的定义和基本术语</a></p> 
<p><a class="link-info" href="http://t.csdnimg.cn/9jwkJ" rel="nofollow" title="图的类型定义和存储结构">图的类型定义和存储结构</a></p> 
<p>这篇文章就来学习一下图的重要章节——图的遍历。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">一，图的遍历定义：</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(DFS)-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%28DFS%29" rel="nofollow">二，深度优先搜索(DFS)</a></p> 
<p id="%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86" rel="nofollow">连通图的深度优先遍历</a></p> 
<p id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E5%AE%9E%E7%8E%B0DFS-toc" style="margin-left:40px;"><a href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E5%AE%9E%E7%8E%B0DFS" rel="nofollow">邻接矩阵法实现DFS</a></p> 
<p id="%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95%E5%AE%9E%E7%8E%B0DFS-toc" style="margin-left:40px;"><a href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95%E5%AE%9E%E7%8E%B0DFS" rel="nofollow">邻接表法实现DFS</a></p> 
<p id="DFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#DFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow">DFS算法效率分析：</a></p> 
<p id="%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86" rel="nofollow">非连通图的深度优先遍历</a></p> 
<p id="%E4%B8%89%EF%BC%8C%20%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%89%EF%BC%8C%20%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89" rel="nofollow">三， 广度优先搜索（BFS）</a></p> 
<p id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E5%AE%9E%E7%8E%B0BFS-toc" style="margin-left:40px;"><a href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E5%AE%9E%E7%8E%B0BFS" rel="nofollow">邻接矩阵法实现BFS</a></p> 
<p id="%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95%E5%AE%9E%E7%8E%B0BFS-toc" style="margin-left:40px;"><a href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95%E5%AE%9E%E7%8E%B0BFS" rel="nofollow">邻接表法实现BFS</a></p> 
<p id="%C2%A0BFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0BFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow"> BFS算法效率分析：</a></p> 
<p id="DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83" rel="nofollow">DFS与BFS算法效率比较</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%EF%BC%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E5%AE%9A%E4%B9%89%EF%BC%9A">一，图的遍历定义：</h2> 
<p><span style="color:#262626;">        从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做</span><span style="color:#ff0000;">图的遍历</span><span style="color:#262626;">，它是图的</span><span style="color:#ff0000;">基本运算</span><span style="color:#262626;">。</span></p> 
<p><span style="color:#262626;">图遍历的实质：找每个顶点的邻接点的过程。</span></p> 
<p class="img-center"><img alt="" height="188" src="https://images2.imgbox.com/6d/90/jnBbvqyN_o.png" width="600"></p> 
<p>要进行图的遍历，我们需要知道图的特点，从而用合适，高效的方法来实现遍历。</p> 
<p>图有哪些特点？</p> 
<p><span style="color:#262626;">图中可能存在</span><span style="color:#4f81bd;">回路</span><span style="color:#262626;">，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边</span><span style="color:#ff0000;">又回到了曾经访问过的顶点</span><span style="color:#262626;">。</span> </p> 
<p>那么，如何避免在遍历时重复访问？</p> 
<p><span style="color:#ff3300;">解决思路：</span></p> 
<p><span style="color:#000000;">设置</span><span style="color:#000000;">辅助数组</span> <span style="color:#000000;"><em>visited</em></span><span style="color:#000000;"> [n ]</span><span style="color:#000000;">，用来标记每个被访</span><span style="color:#000000;">问过的顶点。</span></p> 
<p><span style="color:#000000;">        初始状态为0</span></p> 
<p><span style="color:#000000;">        被访问，改 <em>visited</em></span><span style="color:#000000;"> [</span><span style="color:#000000;"><em>i</em></span><span style="color:#000000;">]</span><span style="color:#000000;">为</span><span style="color:#000000;">1</span><span style="color:#000000;">，防止被多次访问。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0d0d0d;">图常用的遍历有两种：</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#ff3300;">深度优先搜索（</span><span style="color:#ff3300;">Depth First Search,DFS</span><span style="color:#ff3300;">）</span><span style="color:#0d0d0d;">    </span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#ff3300;">广度优先搜索</span><span style="color:#ff3300;">(Breadth First Search,BFS)</span><span style="color:#0d0d0d;">    </span></p> 
<h2 id="%E4%BA%8C%EF%BC%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(DFS)" style="margin-left:0in;text-align:left;"><span style="color:#0d0d0d;">二，深度优先搜索(DFS)</span></h2> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0d0d0d;">引例：</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0d0d0d;">点亮迷宫中所有的灯，我们会一条道走到头，如果走不动了，再往回退寻找其他没有走过的。</span></p> 
<p class="img-center"><img alt="" height="390" src="https://images2.imgbox.com/fb/aa/MyQ0yOAI_o.png" width="700"></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0d0016;">因此我们可以总结</span><span style="color:#000000;">DFS的</span><span style="color:#ff3300;">详细归纳：</span></p> 
<div style="margin-left:.39in;text-align:left;"> 
 <span style="color:#000000;">在访问图中某一起始顶点 </span> 
 <span style="color:#0000ff;"><em>v</em></span> 
 <span style="color:#000000;">后，由 </span> 
 <span style="color:#000000;"><em>v </em></span> 
 <span style="color:#000000;">出发，访问</span> 
 <span style="color:#0000ff;">它的任一邻接顶点 </span> 
 <span style="color:#0000ff;"><em>w</em></span> 
 <span style="color:#0000ff;">1</span> 
 <span style="color:#000000;">；</span> 
</div> 
<div style="margin-left:.39in;text-align:left;"> 
 <span style="color:#000000;">再从 </span> 
 <span style="color:#000000;"><em>w</em></span> 
 <span style="color:#000000;">1 </span> 
 <span style="color:#000000;">出发DFS</span> 
 <span style="color:#0000ff;">邻接</span> 
 <span style="color:#000000;">但还</span> 
 <span style="color:#0000ff;">未被访问</span> 
 <span style="color:#000000;">过的顶点 </span> 
 <span style="color:#000000;"><em>w</em></span> 
 <span style="color:#000000;">2</span> 
 <span style="color:#000000;">；</span> 
</div> 
<div style="margin-left:.39in;text-align:left;"> 
 <span style="color:#000000;">然后再从 </span> 
 <span style="color:#000000;"><em>w</em></span> 
 <span style="color:#000000;">2 </span> 
 <span style="color:#000000;">出发，进行类似的访问，</span> 
 <span style="color:#000000;">… </span> 
</div> 
<div style="margin-left:.39in;text-align:left;"> 
 <span style="color:#000000;">如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 </span> 
 <span style="color:#000000;"><em>u </em></span> 
 <span style="color:#000000;">为止。</span> 
</div> 
<div style="margin-left:.39in;text-align:left;">
  接着，退回一步， 
 <span style="color:#0000ff;">退到前一次刚访问过的顶点</span>，看是否还有其它没有被访问的邻接顶点。 
</div> 
<div style="margin-left:.39in;text-align:left;">
            
 <span style="color:#3333cc;">如果有，</span> 
 <span style="color:#000000;">则访问此顶点，之后再从此顶点出发，进行与前述类似的访问。</span>     
</div> 
<div style="margin-left:.39in;text-align:left;"> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#3333cc;">         如果没有，</span><span style="color:#000000;">就</span><span style="color:#0000ff;">再退回一步</span><span style="color:#000000;">进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</span></p> 
</div> 
<h3 id="%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span style="color:#000000;">连通图的深度优先遍历</span></h3> 
<p><span style="color:#000000;">仿树的先序遍历过程</span></p> 
<p class="img-center"><img alt="" height="274" src="https://images2.imgbox.com/8d/2e/nj1JLn3Q_o.png" width="700"></p> 
<p> 先根，再左子树，最后右子树。</p> 
<p>下面是一个练习：</p> 
<p class="img-center"><img alt="" height="341" src="https://images2.imgbox.com/09/46/n5XGETGp_o.png" width="700"></p> 
<p> 它的深度优先搜索结果是：<span style="color:#000000;">2→1→3→5→4→6</span></p> 
<p>那么，在计算机中我们该如何实现DFS的过程？</p> 
<h3 id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E5%AE%9E%E7%8E%B0DFS"><span style="color:#000000;">邻接矩阵法实现DFS</span></h3> 
<p>在上一篇文章中我们学习了图的存储结构的邻接矩阵法，借助一个<span style="color:#000000;">辅助数组</span> <span style="color:#000000;"><em>visited</em></span><span style="color:#000000;"> [n ]来保存邻接矩阵的信息。</span></p> 
<p><img alt="" height="590" src="https://images2.imgbox.com/63/f8/waUFbtlb_o.png" width="1200"></p> 
<p style="margin-left:0in;text-align:left;">在编程时，使用邻接矩阵法DFS的实现可以采用递归算法：</p> 
<pre><code>void DFS(AMGraph G, int v){        	//图G为邻接矩阵类型 
  cout&lt;&lt;v;  visited[v] = true;  		//访问第v个顶点
  for(w = 0; w&lt; G.vexnum; w++)  	//依次检查邻接矩阵v所在的行  
        if((G.arcs[v][w]!=0)&amp;&amp; (!visited[w]))  
            DFS(G, w); 
      //w是v的邻接点，如果w未访问，则递归调用DFS 
} 
</code></pre> 
<p>而下面是完整的c语言使用邻接矩阵法来实现图的深度优先搜索：</p> 
<p>注意：</p> 
<p>这里我使用了C语言的一个库#include &lt;stdbool.h&gt;，来声明我使用了布尔型数据</p> 
<p>大家也可以自己定义布尔类型，true代表1为真，false代表0为假</p> 
<blockquote> 
 <p>typedef int bool;<br> #define true 1<br> #define false 0</p> 
</blockquote> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define MAX_VERTICES 100

// 定义邻接矩阵和访问标记数组
int graph[MAX_VERTICES][MAX_VERTICES];
bool visited[MAX_VERTICES];
int num_vertices;

// 深度优先搜索函数
void dfs(int vertex) {
    // 标记当前节点为已访问
    visited[vertex] = true;
    // 输出当前节点
    printf("%d ", vertex);

    // 遍历当前节点的所有邻接节点
    for (int i = 0; i &lt; num_vertices; i++) {
        // 如果邻接节点存在且未被访问，则递归调用dfs函数
        if (graph[vertex][i] == 1 &amp;&amp; !visited[i]) {
            dfs(i);
        }
    }
}

int main() {
    // 输入顶点数和边数
    printf("请输入顶点数和边数：");
    scanf("%d", &amp;num_vertices);

    // 输入邻接矩阵
    printf("请输入邻接矩阵：");
    for (int i = 0; i &lt; num_vertices; i++) {
        for (int j = 0; j &lt; num_vertices; j++) {
            scanf("%d", &amp;graph[i][j]);
        }
    }

    // 输出深度优先遍历结果
    printf("深度优先遍历结果：");
    // 初始化访问标记数组
    for (int i = 0; i &lt; num_vertices; i++) {
        visited[i] = false;
    }

    // 遍历所有节点，如果节点未被访问，则调用dfs函数
    for (int i = 0; i &lt; num_vertices; i++) {
        if (!visited[i]) {
            dfs(i);
        }
    }

    return 0;
}</code></pre> 
<p>输入实例：</p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/50/1b/G9KYh89b_o.png" width="449"></p> 
<p>输出结果：</p> 
<p> <img alt="" height="41" src="https://images2.imgbox.com/75/40/cGx3tcaQ_o.png" width="463"></p> 
<h3 id="%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95%E5%AE%9E%E7%8E%B0DFS">邻接表法实现DFS</h3> 
<p>我们知道图的存储结构除了邻接矩阵法之外还有邻接表法，那么使用邻接表法能否实现图的深度优先搜索？ </p> 
<p>当然可以，同样要借助辅助数组<span style="color:#000000;"><em>visited</em></span><span style="color:#000000;"> [n ]</span></p> 
<p class="img-center"><img alt="" height="425" src="https://images2.imgbox.com/e4/86/2q1MCBf5_o.png" width="600"></p> 
<p> 使用邻接表法DFS的实现也可以采用递归算法：</p> 
<pre><code>void DFS(ALGraph G, int v){        //图G为邻接表类型 
  cout&lt;&lt;v;  visited[v] = true;          //访问第v个顶点
  p= G.vertices[v].firstarc;             //p指向v的边链表的第一个边结点 
while(p!=NULL){              	      //边结点非空 
  w=p-&gt;adjvex;               	      //表示w是v的邻接点 
  if(!visited[w])  DFS(G, w); 	     //如果w未访问，则递归调用DFS 
  p=p-&gt;nextarc;                	     //p指向下一个边结点 
 } 
} 
</code></pre> 
<p>在实际的编程中，使用邻接表法实现的DFS代码：</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_VERTICES 100

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct Graph {
    int numVertices;
    Node* adjLists[MAX_VERTICES];
} Graph;

// 添加边函数
void addEdge(Graph* graph, int src, int dest) {
    // 创建新节点
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;vertex = dest;
    newNode-&gt;next = graph-&gt;adjLists[src];
    graph-&gt;adjLists[src] = newNode;
}

// 深度优先搜索函数
void DFS(Graph* graph, int vertex, int visited[]) {
    // 标记当前节点为已访问
    visited[vertex] = 1;
    // 输出当前节点
    printf("%d ", vertex);

    // 遍历当前节点的所有邻接节点
    Node* temp = graph-&gt;adjLists[vertex];
    while (temp) {
        int connectedVertex = temp-&gt;vertex;
        // 如果邻接节点未被访问，则递归调用DFS函数
        if (!visited[connectedVertex]) {
            DFS(graph, connectedVertex, visited);
        }
        temp = temp-&gt;next;
    }
}

// 深度优先遍历函数
void DFSTraversal(Graph* graph) {
    // 初始化访问标记数组
    int visited[MAX_VERTICES] = {0};
    for (int i = 0; i &lt; graph-&gt;numVertices; i++) {
        // 如果节点未被访问，则调用DFS函数
        if (!visited[i]) {
            DFS(graph, i, visited);
        }
    }
}

int main() {
    // 创建图
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph-&gt;numVertices = 5;

    // 初始化邻接表
    for (int i = 0; i &lt; graph-&gt;numVertices; i++) {
        graph-&gt;adjLists[i] = NULL;
    }

    // 添加边
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);

    // 输出深度优先遍历结果
    printf("Depth First Traversal: ");
    DFSTraversal(graph);

    return 0;
}</code></pre> 
<p>输出结果：</p> 
<blockquote> 
 <p>Depth First Traversal: 0 2 1 4 3 </p> 
</blockquote> 
<h3 id="DFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%EF%BC%9A">DFS算法效率分析：</h3> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">用</span><span style="color:#000000;">邻接矩阵</span><span style="color:#000000;">来表示图，遍历图中每一个顶点都要</span><span style="color:#0000ff;">从头扫描</span><span style="color:#000000;">该顶点所在行，时间复杂度为</span><span style="color:#ff3300;">O(</span><span style="color:#ff3300;"><em>n</em></span><span style="color:#ff3300;">2</span><span style="color:#ff3300;">)</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">用</span><span style="color:#000000;">邻接表</span><span style="color:#000000;">来表示图，虽然有 </span><span style="color:#0000ff;">2</span><span style="color:#0000ff;"><em>e</em></span> <span style="color:#000000;">个表结点，但只需扫描 </span><span style="color:#0000ff;"><em>e </em></span><span style="color:#000000;">个结点即可完成遍历，加上访问 </span><span style="color:#0000ff;"><em>n</em></span><span style="color:#000000;">个头结点的时间，时间复杂度为</span><span style="color:#ff3300;">O(</span><span style="color:#ff3300;"><em>n</em></span><span style="color:#ff3300;">+</span><span style="color:#ff3300;"><em>e</em></span><span style="color:#ff3300;">)</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">结论：</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">稠密图</span><span style="color:#000000;">适于在邻接矩阵上进行深度遍历；</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">稀疏图</span><span style="color:#000000;">适于在邻接表上进行深度遍历。</span></p> 
<h3 id="%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86" style="margin-left:0in;text-align:left;">非连通图的深度优先遍历</h3> 
<p style="margin-left:0in;text-align:left;">如下图例子，连通分量分开访问，先DFS访问完第一个，再访问第二个。</p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/41/ab/YHfrw1oM_o.png" width="400"></p> 
<h2 id="%E4%B8%89%EF%BC%8C%20%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89">三， 广度优先搜索（BFS）</h2> 
<p>同样是点亮迷宫中的灯案例，广度优先搜索没有一条道走到黑，而是每个道都走，一层一层实现遍历。</p> 
<p class="img-center"><img alt="" height="265" src="https://images2.imgbox.com/96/a5/raqUBpQm_o.png" width="500"></p> 
<p> <span style="color:#ff3300;">简单归纳：</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        在访问了</span><span style="color:#ff3300;">起始点</span><span style="color:#ff3300;">v</span><span style="color:#000000;">之后，依次访问 </span><span style="color:#ff3300;">v</span><span style="color:#ff3300;">的邻接点</span><span style="color:#000000;">；</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        然后再依次访问</span><span style="color:#ff3300;">这些顶点中未被访问过的邻接点</span><span style="color:#000000;">；</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#ff3300;">        直到所有顶点都被访问</span><span style="color:#000000;">过为止。</span></p> 
<div style="margin-left:0in;text-align:left;"> 
 <span style="color:#000000;"> 广度优先搜索是一种</span> 
 <span style="color:#ff0000;">分层</span> 
 <span style="color:#000000;">的搜索过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况。</span> 
</div> 
<div style="margin-left:0in;text-align:left;"> 
 <span style="color:#000000;">  因此，广度优先搜索</span> 
 <span style="color:#ff0000;">不是一个递归</span> 
 <span style="color:#000000;">的过程，其算法也不是递归的。</span> 
</div> 
<div style="margin-left:0in;text-align:left;"></div> 
<p> BFS<span style="color:#ff3300;">基本思想：</span><span style="color:#000000;">——</span><span style="color:#000000;">仿树的层次遍历过程</span></p> 
<p class="img-center"><img alt="" height="259" src="https://images2.imgbox.com/e5/2f/r0e6DD47_o.png" width="700"></p> 
<p>在计算机中，如何实现BFS？</p> 
<p>与DFS相比，<span style="color:#000000;">除辅助数组</span><span style="color:#000000;"><em>visited</em></span><span style="color:#000000;"> [n ]</span><span style="color:#000000;">外，还需再开一辅助队列。</span></p> 
<p class="img-center"><img alt="" height="620" src="https://images2.imgbox.com/12/da/dFULHelI_o.png" width="1000"></p> 
<p>算法思想：</p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">从图中某个顶点</span><span style="color:#000000;"><em>v</em></span><span style="color:#000000;">出发，访问</span><span style="color:#000000;"><em>v</em></span><span style="color:#000000;">，并置</span><span style="color:#000000;">visited[</span><span style="color:#000000;"><em>v</em></span><span style="color:#000000;">]</span><span style="color:#000000;">的值为</span><span style="color:#000000;">true</span><span style="color:#000000;">，然后将</span><span style="color:#000000;"><em>v</em></span><span style="color:#000000;">进队。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">只要队列不空，则重复下述处理。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">           ① 队头顶点<em>u</em></span><span style="color:#000000;">出队。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">           ② 依次检查<em>u</em>的所有邻接点<em>w</em></span><span style="color:#000000;">，如果</span><span style="color:#000000;">visited[</span><span style="color:#000000;"><em>w</em></span><span style="color:#000000;">]</span><span style="color:#000000;">的值为</span><span style="color:#000000;">false</span><span style="color:#000000;">，则访问</span><span style="color:#000000;"><em>w</em></span><span style="color:#000000;">，并置</span><span style="color:#000000;">visited[</span><span style="color:#000000;"><em>w</em></span><span style="color:#000000;">]</span><span style="color:#000000;">的值为</span><span style="color:#000000;">true</span><span style="color:#000000;">，然后将</span><span style="color:#000000;"><em>w</em></span><span style="color:#000000;">进队。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">同样对于BFS可以使用邻接矩阵或邻接表法来实现。</span></p> 
<h3 id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E5%AE%9E%E7%8E%B0BFS" style="margin-left:0in;text-align:left;">邻接矩阵法实现BFS</h3> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_SIZE 100

// 定义队列结构体
typedef struct {
    int data[MAX_SIZE]; // 队列数据
    int front, rear; // 队头和队尾指针
} Queue;

// 初始化队列
void initQueue(Queue *q) {
    q-&gt;front = q-&gt;rear = 0;
}

// 判断队列是否已满
int isFull(Queue *q) {
    return (q-&gt;rear + 1) % MAX_SIZE == q-&gt;front;
}

// 判断队列是否为空
int isEmpty(Queue *q) {
    return q-&gt;front == q-&gt;rear;
}

// 入队
void enqueue(Queue *q, int x) {
    if (isFull(q)) {
        printf("Queue is full!\n");
        exit(1);
    }
    q-&gt;data[q-&gt;rear] = x;
    q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE;
}

// 出队
int dequeue(Queue *q) {
    if (isEmpty(q)) {
        printf("Queue is empty!\n");
        exit(1);
    }
    int x = q-&gt;data[q-&gt;front];
    q-&gt;front = (q-&gt;front + 1) % MAX_SIZE;
    return x;
}

// 广度优先搜索
void BFS(int graph[][MAX_SIZE], int visited[], int start, int n) {
    Queue q;
    initQueue(&amp;q);
    enqueue(&amp;q, start);
    visited[start] = 1;
    printf("%d ", start);

    while (!isEmpty(&amp;q)) {
        int current = dequeue(&amp;q);
        for (int i = 0; i &lt; n; i++) {
            if (graph[current][i] &amp;&amp; !visited[i]) {
                enqueue(&amp;q, i);
                visited[i] = 1;
                printf("%d ", i);
            }
        }
    }
}

int main() {
    int n, e;
    printf("Enter the number of vertices and edges: ");
    scanf("%d %d", &amp;n, &amp;e);

    int graph[MAX_SIZE][MAX_SIZE] = {0};
    int visited[MAX_SIZE] = {0};

    printf("Enter the edges (u v):\n");
    for (int i = 0; i &lt; e; i++) {
        int u, v;
        scanf("%d %d", &amp;u, &amp;v);
        graph[u][v] = 1;
        graph[v][u] = 1; 
    }

    printf("BFS traversal starting from vertex 0:\n");
    BFS(graph, visited, 0, n);

    return 0;
}</code></pre> 
<p> 输入案例</p> 
<p class="img-center"><img alt="" height="244" src="https://images2.imgbox.com/fb/a2/rPDLn1wC_o.png" width="600"></p> 
<p>输出结果</p> 
<p></p> 
<p class="img-center"><img alt="" height="75" src="https://images2.imgbox.com/8c/3f/m9361FBB_o.png" width="600"></p> 
<h3 id="%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95%E5%AE%9E%E7%8E%B0BFS">邻接表法实现BFS</h3> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 定义邻接表结构体
typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

// 定义图结构体
typedef struct Graph {
    int numVertices;
    Node** adjLists;
} Graph;

// 创建新的节点
Node* createNode(int v) {
    Node* newNode = malloc(sizeof(Node));
    newNode-&gt;vertex = v;
    newNode-&gt;next = NULL;
    return newNode;
}

// 添加边到邻接表
void addEdge(Graph* graph, int src, int dest) {
    Node* newNode = createNode(dest);
    newNode-&gt;next = graph-&gt;adjLists[src];
    graph-&gt;adjLists[src] = newNode;

    // 如果是无向图，需要添加反向边
    newNode = createNode(src);
    newNode-&gt;next = graph-&gt;adjLists[dest];
    graph-&gt;adjLists[dest] = newNode;
}

// 初始化图
Graph* createGraph(int vertices) {
    Graph* graph = malloc(sizeof(Graph));
    graph-&gt;numVertices = vertices;
    graph-&gt;adjLists = malloc(vertices * sizeof(Node*));
    for (int i = 0; i &lt; vertices; i++) {
        graph-&gt;adjLists[i] = NULL;
    }
    return graph;
}

// BFS遍历图
void BFS(Graph* graph, int startVertex) {
    int visited[graph-&gt;numVertices];
    for (int i = 0; i &lt; graph-&gt;numVertices; i++) {
        visited[i] = 0;
    }

    // 创建一个队列并初始化起始顶点
    Node* queue = createNode(startVertex);
    visited[startVertex] = 1;

    // 当队列不为空时继续遍历
    while (queue != NULL) {
        // 打印当前顶点
        printf("%d ", queue-&gt;vertex);

        // 获取当前顶点的邻接顶点列表
        Node* temp = graph-&gt;adjLists[queue-&gt;vertex];

        // 遍历邻接顶点列表
        while (temp != NULL) {
            int adjVertex = temp-&gt;vertex;
            if (!visited[adjVertex]) {
                // 将未访问过的邻接顶点加入队列并标记为已访问
                Node* newNode = createNode(adjVertex);
                newNode-&gt;next = queue-&gt;next;
                queue-&gt;next = newNode;
                visited[adjVertex] = 1;
            }
            temp = temp-&gt;next;
        }

        // 弹出队列的第一个元素
        Node* dequeuedNode = queue;
        queue = queue-&gt;next;
        free(dequeuedNode);
    }
}

int main() {
    int vertices = 6;
    Graph* graph = createGraph(vertices);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);
    addEdge(graph, 2, 4);
    addEdge(graph, 3, 5);
    addEdge(graph, 4, 5);

    printf("BFS traversal starting from vertex 0: ");
    BFS(graph, 0);

    return 0;
}
</code></pre> 
<p>输出结果：</p> 
<p><img alt="" height="42" src="https://images2.imgbox.com/20/47/4BjHG1Tt_o.png" width="799"></p> 
<h3 id="%C2%A0BFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%EF%BC%9A"> BFS算法效率分析：</h3> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">如果使用邻接矩阵，则</span><span style="color:#000000;">BFS</span><span style="color:#000000;">对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（ </span><span style="color:#000000;"><em>n </em></span><span style="color:#000000;">个元素），总的时间代价为</span><span style="color:#ff3300;">O(</span><span style="color:#ff3300;"><em>n</em></span><span style="color:#ff3300;">2</span><span style="color:#ff3300;">)</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">用邻接表来表示图，虽然有 </span><span style="color:#000000;">2e </span><span style="color:#000000;">个表结点，但只需扫描 </span><span style="color:#000000;">e </span><span style="color:#000000;">个结点即可完成遍历，加上访问 </span><span style="color:#000000;">n</span><span style="color:#000000;">个头结点的时间，时间复杂度为</span><span style="color:#ff3300;">O(</span><span style="color:#ff3300;">n+e</span><span style="color:#ff3300;">)</span><span style="color:#000000;">。</span></p> 
<h3 id="DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83" style="margin-left:0in;text-align:left;">DFS与BFS算法效率比较</h3> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">空间复杂度相同，都是</span><span style="color:#000000;">O(n)(</span><span style="color:#000000;">借用了堆栈或队列）；</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">时间复杂度只与存储结构</span><span style="color:#ff0000;">（邻接矩阵或邻接表）</span><span style="color:#000000;">有关，而与搜索路径无关。</span></p> 
<p style="margin-left:0in;text-align:left;">最后是一个小练习</p> 
<p class="img-center"><img alt="" height="556" src="https://images2.imgbox.com/bb/22/WuEq1asj_o.png" width="1000"></p> 
<hr> 
<p> 图的遍历到此就结束啦，如果文章对你有用的话请点个赞支持一下吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0da936ab097e90d8aeaedf5523743dc9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">查找——散列表（哈希表）的查找</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e800c2e209f39b0e535a5a407624417/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ipsec VPN设备在边界情况</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>