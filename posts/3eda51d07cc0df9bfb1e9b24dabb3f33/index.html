<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring AOP（下）原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3eda51d07cc0df9bfb1e9b24dabb3f33/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Spring AOP（下）原理">
  <meta property="og:description" content="本文我们来学习 Spring AOP 的原理，也就是 Spring 是如何实现 AOP 的。Spring AOP 是基于动态代理来实现 AOP 的；
1. 代理模式 1.1 代理弄模式的定义 代理模式，也叫委托模式。
定义：为其他对象提供一种代理以控制这个对象的访问。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。
某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。
使用代理前：
使用代理后：
就像生活中的例子，生活中的代理类似与艺人经纪人：广告商找艺人拍广告，需要经过经纪人，由经纪人来和艺人沟通。
1.2 代理模式的主要角色： 1、Subject：业务接口类。可以是抽象类或者接口（不一定有）。
2、RealSubject：业务实现类。具体的业务执行，也就是被代理对象。
3、Proxy：代理类。RealSubject的代理。
比如让xox代言：
Subject：小偶像就是提前定义了小偶像要和合作方做的事情，交给经纪人代理处理；
RealSubject：小偶像。
Proxy：经纪人。
UML类图如下：
代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。根据代理的创建时期，代理模式分为静态代理和动态代理。
静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。
动态代理：在程序运行时，运用反射机制动态创建而成。
2. 静态代理 静态代理：在程序运行前，代理类的 .class文件就已经存在了。（签合约之前，小偶像已经将自己能做到的义务写到了文案里面，就等合约方签字）。
我们通过代码来加深理解。以经纪人为例：
2.1 定义接口 （定义小偶像要接的剧和能参加的活动，也是经纪人需要做的事情）：
public interface Xox { void receiveJuben(); //xox要接受剧本 } 2.2 实现接口 （沈梦瑶要接剧本）： public class ShenMengyao implements Xox{ @Override public void receiveJuben() { System.out.println(&#34;我是沈梦瑶，我要接剧本&#34;); } } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-03T20:26:50+08:00">
    <meta property="article:modified_time" content="2024-09-03T20:26:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring AOP（下）原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        本文我们来学习 Spring AOP 的原理，也就是 Spring 是如何实现 AOP 的。Spring AOP 是基于动态代理来实现 AOP 的；</p> 
<h2>1. 代理模式</h2> 
<h3>1.1 代理弄模式的定义</h3> 
<p>        <span style="color:#fe2c24;">代理模式，也叫委托模式</span>。</p> 
<p>        定义：<span style="background-color:#dad5e9;">为其他对象提供一种代理以控制这个对象的访问</span>。<span style="color:#38d8f0;">它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用</span>。</p> 
<p>       某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。</p> 
<p>        使用代理前：</p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/41/97/oOL6oVH4_o.png" width="394"></p> 
<p>         使用代理后：</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/9d/95/cBEQ7mLD_o.png" width="433"></p> 
<p>        就像生活中的例子，生活中的代理类似与艺人经纪人：广告商找艺人拍广告，需要经过经纪人，由经纪人来和艺人沟通。</p> 
<h3>1.2 代理模式的主要角色：</h3> 
<blockquote> 
 <p>1、Subject：<span style="background-color:#dad5e9;">业务接口类。可以是抽象类或者接口（不一定有）。</span></p> 
 <p>2、RealSubject：<span style="background-color:#dad5e9;">业务实现类。具体的业务执行，也就是被代理对象。</span></p> 
 <p>3、Proxy：<span style="background-color:#dad5e9;">代理类。RealSubject的代理。</span></p> 
</blockquote> 
<blockquote> 
 <p>比如让xox代言：</p> 
 <p>        Subject：小偶像就是提前定义了小偶像要和合作方做的事情，交给经纪人代理处理；</p> 
 <p>        RealSubject：小偶像。</p> 
 <p>        Proxy：经纪人。</p> 
</blockquote> 
<p>        UML类图如下：</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/d3/01/dBXNn8oT_o.png" width="469"></p> 
<p>        代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。<span style="background-color:#dad5e9;">根据代理的创建时期，代理模式分为静态代理和动态代理</span>。</p> 
<p>      <span style="color:#fe2c24;">  静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</span></p> 
<p><span style="color:#fe2c24;">        动态代理：在程序运行时，运用反射机制动态创建而成</span>。</p> 
<h2>2. 静态代理</h2> 
<p>       <span style="background-color:#dad5e9;"> 静态代理：在程序运行前，代理类的 .class文件就已经存在了。</span>（签合约之前，小偶像已经将自己能做到的义务写到了文案里面，就等合约方签字）。</p> 
<p>        我们通过代码来加深理解。以经纪人为例：</p> 
<h3>2.1 定义接口</h3> 
<p>        （定义小偶像要接的剧和能参加的活动，也是经纪人需要做的事情）：</p> 
<pre><code class="language-java">public interface Xox {
    void receiveJuben();
    //xox要接受剧本
}
</code></pre> 
<h3><strong>2.2 实现接口</strong></h3> 
<p><strong>        （沈梦瑶要接剧本）</strong>： </p> 
<pre><code class="language-java">public class ShenMengyao implements Xox{

    @Override
    public void receiveJuben() {
        System.out.println("我是沈梦瑶，我要接剧本");
    }
}
</code></pre> 
<h3>2.<strong>3 代理</strong></h3> 
<p><strong>        （经纪人，帮沈梦瑶接剧本）</strong>：</p> 
<pre><code class="language-java">public class XoxProxy implements Xox{
    private  Xox target;
    public XoxProxy(Xox target){
        this.target = target;
    }
    @Override
    public void receiveJuben() {
        //代理前
        System.out.println("我是经纪人, 开始代理");
        //出租房子
        target.receiveJuben();
        //代理后
        System.out.println("我是经纪人, 结束代理");
    }
}
</code></pre> 
<h3>2.4 <strong>使用</strong></h3> 
<pre><code class="language-java">package com.example.aop;

public class Main {
    public static void main(String[] args) {
        Xox xox = new ShenMengyao();
        //创建代理类
        XoxProxy xoxProxy = new XoxProxy(xox);
        //通过代理类访问⽬标⽅法
        xoxProxy.receiveJuben();
    }
}</code></pre> 
<p>        运行结果：</p> 
<p> <img alt="" height="165" src="https://images2.imgbox.com/a1/55/UETDvaFQ_o.png" width="322"></p> 
<p>         上面这个代理实现方式就是静态代理（仿佛啥也没干）。从上述程序可以看出，<span style="color:#956fe7;">虽然静态代理也完成了对目标对象的代理，但是由于代码都写死了，对目标对象的每个方法的增强都是手动完成的，非常不灵活</span>。所以日常开发几乎看不到静态代理的场景。</p> 
<p>        接下来新增需求：经纪人又新增了其他业务：代理小偶像解约。我们就需要对上述代码进行修改。</p> 
<p><strong>2.5 更新代理内容</strong></p> 
<p><strong>1、接口定义修改：</strong></p> 
<pre><code class="language-java">package com.example.aop;

public interface Xox {
    void receiveJuben();
    //xox要接受剧本
    void Termination();
    //小偶像要解约
}
</code></pre> 
<p><strong>2、接口实现修改</strong>：</p> 
<pre><code class="language-java">package com.example.aop;

public class ShenMengyao implements Xox{

    @Override
    public void receiveJuben() {
        System.out.println("我是沈梦瑶，我要接剧本");
    }

    @Override
    public void Termination() {
        System.out.println("我是沈梦瑶，我要和丝芭解约");
    }
}
</code></pre> 
<p><strong>3、代理类修改</strong>：</p> 
<pre><code class="language-java">package com.example.aop;

public class XoxProxy implements Xox{
    private  Xox target;
    public XoxProxy(Xox target){
        this.target = target;
    }
    @Override
    public void receiveJuben() {
        //代理前
        System.out.println("我是经纪人, 开始代理");
        //出租房子
        target.receiveJuben();
        //代理后
        System.out.println("我是经纪人, 结束代理");
    }

    @Override
    public void Termination() {
        //代理前
        System.out.println("我是经纪人, 开始代理");
        //出租房子
        target.Termination();
        //代理后
        System.out.println("我是经纪人, 结束代理");
    }
}

</code></pre> 
<p><strong>4、使用</strong>：  </p> 
<pre><code class="language-java">package com.example.aop;

public class Main {
    public static void main(String[] args) {
        Xox xox = new ShenMengyao();
        //创建代理类
        XoxProxy xoxProxy = new XoxProxy(xox);
        //通过代理类访问⽬标⽅法
        xoxProxy.receiveJuben();
        System.out.println("-----------");
        xoxProxy.Termination();
    }
}</code></pre> 
<p><img alt="" height="294" src="https://images2.imgbox.com/89/5c/FXIUSvNU_o.png" width="493"> </p> 
<p>        从上述代码可以看出，我们修改xox接口，接需要在后续修改三个代码，这样十分加大了我们的 工作量，即每增加一个接口就需要实现类来完善该接口的方法，我们的代理也需要进行完善相应的代码，为了减少工作量，所以接下来学习动态代理技术；</p> 
<h2>3. 动态代理</h2> 
<p>        相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标对象都单独创建一个代理对象，而是把这个创建代理对象的工作推迟到程序运行时，由JVM来实现。也就是说动<span style="background-color:#dad5e9;">态代理在程序运行时，根据需要动态创建生成</span>。</p> 
<p>        比如经纪人，她不需要提前预测都有哪些业务，而是业务来了我再根据情况创建。</p> 
<p>        先看代码再来理解。Java也对动态代理进行了实现，并给我们提供一些API，常见的实现方式有两种：</p> 
<blockquote> 
 <p>        1、JDK动态代理</p> 
 <p>        2、CGLIB动态代理</p> 
</blockquote> 
<p>        动态代理在我们日常开发中使用的相对较少，但是在框架中几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</p> 
<h3>3.1 JDK动态代理</h3> 
<h4>3.1.1 JDK动态代理实现步骤</h4> 
<blockquote> 
 <p><span style="background-color:#dad5e9;">1、定义一个接口及其实现类（静态代理中的 Xox和 shenmengyao）。</span></p> 
 <p><span style="background-color:#dad5e9;">2、自定义 InvocationHandler 并重写 invoke 方法，在 invoke 方法中我们会调用目标方法（被代理类的方法），并自定义一些处理逻辑。</span></p> 
 <p><span style="background-color:#dad5e9;">3、通过 Proxy.newProxyInstance（ClassLoader, Class&lt;?&gt;[ ]  Interfaces, InvocationHandler  h）方法创建代理对象。</span></p> 
</blockquote> 
<h4>3.1.2 定义JDK动态代理类</h4> 
<p>        创建 JDKInvocationHandler类 实现 InvocationHandler 接口：</p> 
<pre><code class="language-java">package com.example.aop;

import org.springframework.cglib.proxy.InvocationHandler;

import java.lang.reflect.Method;

public class JDKInvocationHandler implements InvocationHandler {
    //目标对象，即被代理的对象
    private Object target;
 
    public JDKInvocationHandler(Object target) {
        this.target = target;
    }
 
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //代理增强内容
        System.out.println("我是经纪人，开始代理");
        //通过反射调用被代理类的方法
        Object result = method.invoke(target, args);
        //代理增强内容
        System.out.println("我是经纪人，结束代理");
        return result;
    }
}</code></pre> 
<p>        创建一个代理对象并使用：</p> 
<pre><code class="language-java">package com.example.aop;

import org.springframework.cglib.proxy.Proxy;

public class Main {
    public static void main(String[] args) {
        /**
         * JDK动态代理
         */

        //创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建
        ShenMengyao shenMengyao = new ShenMengyao();//目标对象
        /**
         * newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)
         * loader：加载我们的被代理类的ClassLoad
         * interfaces：要实现的接口
         * h：代理要做的事情，需要实现 InvocationHandler 这个接口
         */
        Xox proxy = (Xox) Proxy.newProxyInstance(
                shenMengyao.getClass().getClassLoader(),
                new Class[]{Xox.class},
                new JDKInvocationHandler(shenMengyao)
        );
        //通过代理类访问⽬标⽅法
        proxy.receiveJuben();
        System.out.println("-----------");
        proxy.Termination();
    }
}</code></pre> 
<p>         运行程序，结果如下：</p> 
<p><img alt="" height="209" src="https://images2.imgbox.com/40/e3/QghjNlKx_o.png" width="448"></p> 
<p>         假设代理的是类，而不是对象，代码如下：</p> 
<pre><code class="language-java">package com.example.aop;

import org.springframework.cglib.proxy.Proxy;

public class Main {
    public static void main(String[] args) {
        /**
         * JDK动态代理
         */

        ShenMengyao shenMengyao  = new ShenMengyao();
        ShenMengyao proxy = (ShenMengyao) Proxy.newProxyInstance(
                shenMengyao.getClass().getClassLoader(),
                new Class[]{ShenMengyao.class},
                new JDKInvocationHandler(shenMengyao)
        );

        //通过代理类访问⽬标⽅法
        proxy.receiveJuben();
        System.out.println("-----------");
        proxy.Termination();
    }
}</code></pre> 
<p>          运行程序，结果如下：（报错了）</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/26/68/KOSS5GTD_o.png" width="1200"></p> 
<p>3.1.3 代码简单讲解</p> 
<p>        主要是学习API的使用，我们按照 Java API 的规范来使用即可。</p> 
<p><span style="background-color:#dad5e9;">1、InvocationHandler：</span></p> 
<p>      <span style="color:#38d8f0;">  InvocationHandler 接口是 Java 动态代理的关键接口之一，它定义了一个单一方法 invoke()，用于处理被代理对象的方法调用</span>。</p> 
<pre><code class="language-java">    public interface InvocationHandler {
        /**
         * 参数说明
         * proxy：被代理对象
         * method：被代理对象需要实现的⽅法，即其中需要重写的⽅法
         * args：method所对应⽅法的参数
         */
        public Object invoke(Object proxy, Method method, Object[] args)
                throws Throwable;
    }</code></pre> 
<p>        通过实现 InvocationHandler 接口，可以对被代理对象的方法进行功能增强。</p> 
<p><strong><span style="background-color:#dad5e9;">2、Proxy：</span></strong></p> 
<p>        <span style="color:#38d8f0;">Proxy 类中使用频率最高的方法：newProxyInstance()，这个方法主要用来生成一个代理对象</span>。</p> 
<pre><code class="language-java">    public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
            throws IllegalArgumentException
    {
        //...代码省略
    }</code></pre> 
<blockquote> 
 <p>  这个方法一共有 3 个参数：</p> 
 <p>      <span style="background-color:#dad5e9;">  loader：类加载器，用于加载被代理对象。</span></p> 
 <p><span style="background-color:#dad5e9;">        interface：被代理类实现的一些接口（这个参数的定义，也决定了JDK动态代理只能代理实现了接口的一些类）。</span></p> 
 <p><span style="background-color:#dad5e9;">        h：代理要做的事情，实现 InvocationHandler 接口的对象。</span></p> 
</blockquote> 
<h3 style="background-color:transparent;">3.2 CGLIB动态代理</h3> 
<p>        <span style="color:#956fe7;">JDK动态代理有一个最致命的问题，是只能代理实现了接口的类</span>。</p> 
<p>        有些场景下，我们的业务码是直接实现的，并没有接口定义。为了解决这个问题，我们可以用 CGLIB 动态代理机制来解决。</p> 
<p>      <span style="color:#fe2c24;">  CGLIB（Code Generation Library）是一个基于 ASM 的字节码生产库，它允许我们在运行时对字节码进行修改和动态生成</span>。</p> 
<p>      <span style="background-color:#dad5e9;">  CGLIB 通过继承方式实现代理，很多知名的开源框架都使用到了 CGLIB。例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。（其中 Spring 是基于动态代理实现的，动态代理是基于反射实现的）</span></p> 
<h4>3.2.1 CGLIB 动态代理类实现步骤</h4> 
<blockquote> 
 <p>1、定义一个类（被代理类）。</p> 
 <p>2、自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于增强目标方法，和 JDK 动态代理中的 invoke 方法类似。</p> 
 <p>3、通过 Enhancer 类的 create() 创建代理类。</p> 
</blockquote> 
<p>        接下来看实现：</p> 
<h4 style="background-color:transparent;">3.2.2 添加依赖</h4> 
<p>        和 JDK 动态代理不同，CGLIB（Code Generation Library）实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p> 
<pre><code class="language-java">        &lt;dependency&gt;
            &lt;groupId&gt;cglib&lt;/groupId&gt;
            &lt;artifactId&gt;cglib&lt;/artifactId&gt;
            &lt;version&gt;3.3.0&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89MethodInterceptor%EF%BC%88%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89">3.2.3 自定义MethodInterceptor（方法拦截器）</h4> 
<p>        实现 MethodInterceptor 接口:</p> 
<pre><code class="language-java">import org.springframework.cglib.proxy.MethodInterceptor;
import java.lang.reflect.Method;
 
public class CGLibInterceptor implements MethodInterceptor {
    private Object target;
 
    public CGLibInterceptor(Object target) {
        this.target = target;
    }
 
    /**
     * 调用代理对象的方法
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] args, org.springframework.cglib.proxy.MethodProxy proxy) throws Throwable {
        //代理增强内容
        System.out.println("我是中介，开始代理");
        Object result = method.invoke(target, args);
        //代理增强内容
        System.out.println("我是中介，结束代理");
        return result;
    }
}</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8">3.2.4 创建代理类，并使用</h4> 
<p>        代理接口：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        //目标对象
        Xox target = new ShenMengyao();
        Xox proxy  = (Xox) Enhancer.create(target.getClass(), new CGLibInterceptor(target));
        proxy.receiveJuben();
        System.out.println("=============");
        proxy.
    Termination();
    }
    }</code></pre> 
<p>   运行程序，执行结果如下：</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/f6/06/hpr5CWwb_o.png" width="457"></p> 
<p>        代理类：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        //目标对象
        Xox target = new ShenMengyao();
        ShenMengyao proxy  = (ShenMengyao) Enhancer.create(target.getClass(), new CGLibInterceptor(target));
        proxy.receiveJuben();
        System.out.println("=============");
        proxy.Termination();
    }
    }</code></pre> 
<p>结果没有发生变化；</p> 
<h4 id="%EF%BC%885%EF%BC%89%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3">3.2.5 代码简单讲解</h4> 
<p><span style="color:#fe2c24;"><strong>1、MethodInterceptor</strong>：</span></p> 
<p>      <span style="background-color:#dad5e9;">  MethodInterceptor 和 JDK动态代理中的 InvocationHandler 类似，它只定义了一个方法 intercept()，用于增强目标方法</span>。</p> 
<pre><code class="language-java">    public interface MethodInterceptor extends Callback {
        /**
         * 参数说明:
         * o: 被代理的对象
         * method: ⽬标⽅法(被拦截的⽅法, 也就是需要增强的⽅法)
         * objects: ⽅法⼊参
         * methodProxy: ⽤于调⽤原始⽅法
         */
        Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable;
    }</code></pre> 
<p><span style="color:#fe2c24;"><strong>2、Enhancer.create()</strong>：</span></p> 
<pre><code class="language-java">    public static Object create(Class type, Callback callback) {
        //...代码省略
    }</code></pre> 
<blockquote> 
 <p><strong>type</strong>：被代理类的类型（类或接口）</p> 
 <p><strong>callback</strong>：自定义方法拦截器 MethodInterceptor</p> 
</blockquote> 
<h2>4. 常见面试题</h2> 
<blockquote> 
 <p>1、什么是 AOP？<br>         <span style="color:#fe2c24;">AOP是 面向切面编程，也是一种思想，切面指的是某一类特定问题，所以 AOP 也可以理解为 面向切面编程。</span></p> 
</blockquote> 
<blockquote> 
 <p>2、Spring AOP的实现方式有哪些？<br><span style="color:#fe2c24;">（1）基于注解（@Aspect 或 自定义注解）</span></p> 
 <p><span style="color:#fe2c24;">（2）基于 xml</span></p> 
 <p><span style="color:#fe2c24;">（3）基于代理</span></p> 
</blockquote> 
<blockquote> 
 <p>3、Spring AOP 的实现原理？<br>        <span style="color:#fe2c24;"> 基于动态代理实现的，其中的动态代理有两种形式：（1）JDK   （2）CGLIB</span></p> 
</blockquote> 
<p>4、Spring 使用的是哪种代理方式？<br>         Spring 的 proxyTargetClass 默认为：false，其中：实现了接口，使用 JDK 代理；普通类：使用CGLIB代理。</p> 
<p>        Spring Boot 从 2.X 之后，proxyTargetClass 默认为：true，默认使用 CGLIB 代理；</p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/43/91/OE8mKl9T_o.png" width="970"></p> 
<blockquote> 
 <p id="5%E3%80%81JDK%20%E5%92%8C%20CGLIB%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">5、JDK 和 CGLIB 的区别？</p> 
 <p>        使用JDK 动态代理只能代理接口。</p> 
 <p>        使用 CGLIB 动态代理 既可以代理接口，也可以代理类。</p> 
</blockquote> 
<blockquote> 
 <p>6、总结<br>        <span style="background-color:#dad5e9;"> 1、AOP 是一种思想，是对某一类事情的集中处理。Spring 框架实现了AOP，称之为 Spring AOP。</span></p> 
 <p><span style="background-color:#dad5e9;">        2、Spring AOP 场景的实现方式有两种：（1）基于注解@Aspect来实现。（2）基于自定义注解来实现，还有一些更原始的方式，比如基于代理、基于 xml 配置的方式，但目标比较少见。</span></p> 
 <p><span style="background-color:#dad5e9;">        3、Spring AOP 是基于动态代理实现的，有两种方式：（1）基于 JDK 动态代理实现。（2）基于 CGLIB 动态代理实现。运行时使用哪种方式与项目配置的代理对象有关。</span></p> 
</blockquote> 
<p>ps：本文就写到这里了，谢谢观看！！！</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88f3898fb89b0127f711b574130747ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手撕Python之散列类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27b8506e6f3e731e069ff892c1e6dcc8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java-数据结构-链表-LinkedList（二）|ू･ω･` )</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>