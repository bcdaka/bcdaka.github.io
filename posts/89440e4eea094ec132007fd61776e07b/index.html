<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中的备忘录模式 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/89440e4eea094ec132007fd61776e07b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;中的备忘录模式">
  <meta property="og:description" content="目录
备忘录模式（Memento Pattern）
实际应用
文本编辑器的撤销功能
游戏角色状态保存和恢复
图形编辑器的撤销/重做功能
总结
备忘录模式（Memento Pattern） 备忘录模式是一种行为型设计模式，它允许在不破坏封装性的前提下捕获和恢复对象的内部状态。这个模式的主要目的是保存对象的某个状态，以便在适当的时候恢复对象到之前的状态。备忘录模式主要包含三个角色：
1. Originator：负责创建一个备忘录（Memento），用以记录当前的内部状态，并在需要时使用备忘录恢复内部状态。
2. Memento：备忘录，负责存储Originator的内部状态。
3. Caretaker：负责保存备忘录，但不能对备忘录的内容进行操作或检查。
实际应用 文本编辑器的撤销功能 -- 文本编辑器，支持撤销操作。
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; // Memento类，用于存储文本编辑器的状态 class Memento { private: std::string state; public: Memento(const std::string&amp; state) : state(state) {} std::string getState() const { return state; } }; // Originator类，表示文本编辑器 class TextEditor { private: std::string text; public: void write(const std::string&amp; words) { text &#43;= words; } std::string getText() const { return text; } Memento save() const { return Memento(text); } void restore(const Memento&amp; memento) { text = memento.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-12T10:19:28+08:00">
    <meta property="article:modified_time" content="2024-06-12T10:19:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中的备忘录模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88Memento%20Pattern%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88Memento%20Pattern%EF%BC%89" rel="nofollow">备忘录模式（Memento Pattern）</a></p> 
<p id="%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8" rel="nofollow">实际应用</a></p> 
<p id="%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%92%A4%E9%94%80%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%92%A4%E9%94%80%E5%8A%9F%E8%83%BD" rel="nofollow">文本编辑器的撤销功能</a></p> 
<p id="%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D-toc" style="margin-left:80px;"><a href="#%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D" rel="nofollow">游戏角色状态保存和恢复</a></p> 
<p id="%E5%9B%BE%E5%BD%A2%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%92%A4%E9%94%80%2F%E9%87%8D%E5%81%9A%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#%E5%9B%BE%E5%BD%A2%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%92%A4%E9%94%80%2F%E9%87%8D%E5%81%9A%E5%8A%9F%E8%83%BD" rel="nofollow">图形编辑器的撤销/重做功能</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<h3>备忘录模式（Memento Pattern）</h3> 
<p>备忘录模式是一种行为型设计模式，它允许在不破坏封装性的前提下捕获和恢复对象的内部状态。这个模式的主要目的是保存对象的某个状态，以便在适当的时候恢复对象到之前的状态。备忘录模式主要包含三个角色：<br> 1. <strong>Originator</strong>：负责创建一个备忘录（<strong>Memento</strong>），用以记录当前的内部状态，并在需要时使用备忘录恢复内部状态。<br> 2. <strong>Memento</strong>：备忘录，负责存储<strong>Originator</strong>的内部状态。<br> 3. <strong>Caretaker</strong>：负责保存备忘录，但不能对备忘录的内容进行操作或检查。</p> 
<h3 id="%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8">实际应用</h3> 
<h4 id="%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%92%A4%E9%94%80%E5%8A%9F%E8%83%BD">文本编辑器的撤销功能</h4> 
<p>-- 文本编辑器，支持撤销操作。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

// Memento类，用于存储文本编辑器的状态
class Memento {
private:
    std::string state;

public:
    Memento(const std::string&amp; state) : state(state) {}
    std::string getState() const { return state; }
};

// Originator类，表示文本编辑器
class TextEditor {
private:
    std::string text;

public:
    void write(const std::string&amp; words) {
        text += words;
    }

    std::string getText() const {
        return text;
    }

    Memento save() const {
        return Memento(text);
    }

    void restore(const Memento&amp; memento) {
        text = memento.getState();
    }
};

// Caretaker类，用于管理Memento
class Caretaker {
private:
    std::vector&lt;Memento&gt; history;

public:
    void save(const Memento&amp; memento) {
        history.push_back(memento);
    }

    Memento undo() {
        if (!history.empty()) {
            Memento memento = history.back();
            history.pop_back();
            return memento;
        }
        return Memento(""); // 返回空的Memento
    }
};

// 客户端代码
int main() {
    TextEditor editor;
    Caretaker caretaker;

    editor.write("Hello ");
    caretaker.save(editor.save());

    editor.write("World!");
    caretaker.save(editor.save());

    std::cout &lt;&lt; "Current Text: " &lt;&lt; editor.getText() &lt;&lt; std::endl;

    editor.restore(caretaker.undo());
    std::cout &lt;&lt; "After Undo: " &lt;&lt; editor.getText() &lt;&lt; std::endl;

    editor.restore(caretaker.undo());
    std::cout &lt;&lt; "After Undo: " &lt;&lt; editor.getText() &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
<h4 id="%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D">游戏角色状态保存和恢复</h4> 
<p>-- 模拟一个游戏角色的状态保存和恢复功能。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

// Memento类，用于存储游戏角色的状态
class Memento {
private:
    int health;
    int mana;
    int experience;

public:
    Memento(int health, int mana, int experience)
        : health(health), mana(mana), experience(experience) {}

    int getHealth() const { return health; }
    int getMana() const { return mana; }
    int getExperience() const { return experience; }
};

// Originator类，表示游戏角色
class GameCharacter {
private:
    int health;
    int mana;
    int experience;

public:
    GameCharacter(int health, int mana, int experience)
        : health(health), mana(mana), experience(experience) {}

    void setState(int health, int mana, int experience) {
        this-&gt;health = health;
        this-&gt;mana = mana;
        this-&gt;experience = experience;
    }

    void displayState() const {
        std::cout &lt;&lt; "Health: " &lt;&lt; health &lt;&lt; ", Mana: " &lt;&lt; mana
                  &lt;&lt; ", Experience: " &lt;&lt; experience &lt;&lt; std::endl;
    }

    Memento save() const {
        return Memento(health, mana, experience);
    }

    void restore(const Memento&amp; memento) {
        health = memento.getHealth();
        mana = memento.getMana();
        experience = memento.getExperience();
    }
};

// Caretaker类，用于管理Memento
class Caretaker {
private:
    std::vector&lt;Memento&gt; savepoints;

public:
    void save(const Memento&amp; memento) {
        savepoints.push_back(memento);
    }

    Memento load() {
        if (!savepoints.empty()) {
            Memento memento = savepoints.back();
            savepoints.pop_back();
            return memento;
        }
        return Memento(100, 100, 0); // 返回初始状态
    }
};

// 客户端代码
int main() {
    GameCharacter character(100, 50, 0);
    Caretaker caretaker;

    character.displayState();
    caretaker.save(character.save());

    character.setState(80, 40, 10);
    character.displayState();
    caretaker.save(character.save());

    character.setState(50, 30, 20);
    character.displayState();

    character.restore(caretaker.load());
    character.displayState();

    character.restore(caretaker.load());
    character.displayState();

    return 0;
}
</code></pre> 
<h4 id="%E5%9B%BE%E5%BD%A2%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%92%A4%E9%94%80%2F%E9%87%8D%E5%81%9A%E5%8A%9F%E8%83%BD">图形编辑器的撤销/重做功能</h4> 
<p>-- 图形编辑器，支持撤销和重做操作。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stack&gt;

// Memento类，用于存储图形编辑器的状态
class Memento {
private:
    std::vector&lt;std::string&gt; shapes;

public:
    Memento(const std::vector&lt;std::string&gt;&amp; shapes) : shapes(shapes) {}
    std::vector&lt;std::string&gt; getState() const { return shapes; }
};

// Originator类，表示图形编辑器
class GraphicEditor {
private:
    std::vector&lt;std::string&gt; shapes;

public:
    void addShape(const std::string&amp; shape) {
        shapes.push_back(shape);
    }

    void displayShapes() const {
        for (const auto&amp; shape : shapes) {
            std::cout &lt;&lt; shape &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }

    Memento save() const {
        return Memento(shapes);
    }

    void restore(const Memento&amp; memento) {
        shapes = memento.getState();
    }
};

// Caretaker类，用于管理Memento
class Caretaker {
private:
    std::stack&lt;Memento&gt; undoStack;
    std::stack&lt;Memento&gt; redoStack;

public:
    void save(const Memento&amp; memento) {
        undoStack.push(memento);
        while (!redoStack.empty()) {
            redoStack.pop();
        }
    }

    Memento undo() {
        if (!undoStack.empty()) {
            Memento memento = undoStack.top();
            undoStack.pop();
            redoStack.push(memento);
            return memento;
        }
        return Memento(std::vector&lt;std::string&gt;()); // 返回空的Memento
    }

    Memento redo() {
        if (!redoStack.empty()) {
            Memento memento = redoStack.top();
            redoStack.pop();
            undoStack.push(memento);
            return memento;
        }
        return Memento(std::vector&lt;std::string&gt;()); // 返回空的Memento
    }
};

// 客户端代码
int main() {
    GraphicEditor editor;
    Caretaker caretaker;

    editor.addShape("Circle");
    caretaker.save(editor.save());

    editor.addShape("Square");
    caretaker.save(editor.save());

    editor.addShape("Triangle");
    caretaker.save(editor.save());

    std::cout &lt;&lt; "Current Shapes: ";
    editor.displayShapes();

    editor.restore(caretaker.undo());
    std::cout &lt;&lt; "After Undo: ";
    editor.displayShapes();

    editor.restore(caretaker.undo());
    std::cout &lt;&lt; "After Undo: ";
    editor.displayShapes();

    editor.restore(caretaker.redo());
    std::cout &lt;&lt; "After Redo: ";
    editor.displayShapes();

    editor.restore(caretaker.redo());
    std::cout &lt;&lt; "After Redo: ";
    editor.displayShapes();

    return 0;
}
</code></pre> 
<h3 id="%E6%80%BB%E7%BB%93">总结</h3> 
<p>备忘录模式帮助我们在不破坏对象封装性的前提下捕获和恢复对象的内部状态，从而实现撤销和重做操作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b38db9041f87df4c648cb5a1335dfe03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 中的线程本地存储（ThreadLocal）机制详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4fb5036a837719826e608699d8319beb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从源码分析 vllm &#43; Ray 的分布式推理流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>