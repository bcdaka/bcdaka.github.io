<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b0f9eb16cda6e5f766c43050f1bad1c2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例">
  <meta property="og:description" content="文章目录 使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例0. 概要1. 安装 Clang-Tidy2. 配置 `.clang-tidy`3. 检查项详解3.1 静态分析器（Static Analyzer）3.2 现代化（Modernize）3.3 Google 代码风格（Google）3.4 可读性（Readability）3.5 CERT 安全编码标准（CERT）3.6 Bug 检测（Bugprone）3.7 C&#43;&#43; 核心指南（CppCoreGuidelines）3.8 杂项（Miscellaneous） 4. 使用 Clang-Tidy4.1 生成 `compile_commands.json`4.2 运行检测4.3 执行结果4.4 如何屏蔽warnings?4.5 与 CMake 集成CMake 脚本详解脚本细节解析 5. 资源阅读 使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例 关于Cppcheck 的使用请参考： 使用 Cppcheck 进行静态代码分析：完整的 shell 脚本与 CMake 集成实例
关于OCLint的使用请参考： 使用 OCLint进行静态代码分析：一个完整的配置示例
本文重点介绍与CMake 集成，如需shell脚本进行clang-tidy检测请参考: 使用多进程shell脚本进行clang-tidy静态代码分析 和 使用 shell 脚本进行 clang-tidy 静态代码分析
0. 概要 Clang-Tidy 是一款功能强大的静态代码分析工具。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-02T23:29:02+08:00">
    <meta property="article:modified_time" content="2024-07-02T23:29:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_ClangTidy__CMake__2" rel="nofollow">使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例</a></li><li><ul><li><a href="#0__7" rel="nofollow">0. 概要</a></li><li><a href="#1__ClangTidy_24" rel="nofollow">1. 安装 Clang-Tidy</a></li><li><a href="#2__clangtidy_43" rel="nofollow">2. 配置 `.clang-tidy`</a></li><li><a href="#3__144" rel="nofollow">3. 检查项详解</a></li><li><ul><li><a href="#31_Static_Analyzer_146" rel="nofollow">3.1 静态分析器（Static Analyzer）</a></li><li><a href="#32_Modernize_164" rel="nofollow">3.2 现代化（Modernize）</a></li><li><a href="#33_Google_Google_177" rel="nofollow">3.3 Google 代码风格（Google）</a></li><li><a href="#34_Readability_184" rel="nofollow">3.4 可读性（Readability）</a></li><li><a href="#35_CERT_CERT_199" rel="nofollow">3.5 CERT 安全编码标准（CERT）</a></li><li><a href="#36_Bug_Bugprone_205" rel="nofollow">3.6 Bug 检测（Bugprone）</a></li><li><a href="#37_C_CppCoreGuidelines_220" rel="nofollow">3.7 C++ 核心指南（CppCoreGuidelines）</a></li><li><a href="#38_Miscellaneous_227" rel="nofollow">3.8 杂项（Miscellaneous）</a></li></ul> 
   </li><li><a href="#4__ClangTidy_234" rel="nofollow">4. 使用 Clang-Tidy</a></li><li><ul><li><a href="#41__compile_commandsjson_236" rel="nofollow">4.1 生成 `compile_commands.json`</a></li><li><a href="#42__246" rel="nofollow">4.2 运行检测</a></li><li><a href="#43__272" rel="nofollow">4.3 执行结果</a></li><li><a href="#44_warnings_291" rel="nofollow">4.4 如何屏蔽warnings?</a></li><li><a href="#45__CMake__295" rel="nofollow">4.5 与 CMake 集成</a></li><li><ul><li><a href="#CMake__298" rel="nofollow">CMake 脚本详解</a></li><li><a href="#_344" rel="nofollow">脚本细节解析</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5__377" rel="nofollow">5. 资源阅读</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_ClangTidy__CMake__2"></a>使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例</h2> 
<ul><li> <p>关于Cppcheck 的使用请参考： <a href="https://blog.csdn.net/stallion5632/article/details/139544518">使用 Cppcheck 进行静态代码分析：完整的 shell 脚本与 CMake 集成实例</a></p> </li><li> <p>关于OCLint的使用请参考： <a href="https://blog.csdn.net/stallion5632/article/details/139547242">使用 OCLint进行静态代码分析：一个完整的配置示例</a></p> </li><li> <p>本文重点介绍与CMake 集成，如需shell脚本进行clang-tidy检测请参考: <a href="https://blog.csdn.net/stallion5632/article/details/140122323">使用多进程shell脚本进行clang-tidy静态代码分析</a> 和 <a href="https://blog.csdn.net/stallion5632/article/details/140138284">使用 shell 脚本进行 clang-tidy 静态代码分析</a></p> </li></ul> 
<h3><a id="0__7"></a>0. 概要</h3> 
<p>Clang-Tidy 是一款功能强大的静态代码分析工具。<br> 现在clang-tidy实现有100+个check，请查看list列表。根据check不同种类(从check名字的前缀就能知道哪一类)，分为如下几大类：</p> 
<ul><li>boost 检测boost库API使用问题</li><li>cert 检测<a href="https://www.securecoding.cert.org/confluence/display/seccode/SEI+CERT+Coding+Standards" rel="nofollow">CERT</a>的代码规范</li><li>cpp-core-guidelines 检测是否违反cpp-core-guidelines</li><li>google 检测是否违反google code style</li><li>llvm 检测是否违反llvm code style</li><li>readability 检测代码上相关问题，但又不明确属于任何代码规范的</li><li>misc 其它一些零碎的check</li><li>mpi 检测MPI API问题</li><li>modernize 把C++03代码转换成C++11代码，使用C++11新特性</li><li>performance 检测performance相关问题</li><li></ul> 
<p>本文将详细介绍其安装与配置方法，并展示与 CMake 的集成，通过自动化分析帮助读者提升 C++ 代码质量。</p> 
<h3><a id="1__ClangTidy_24"></a>1. 安装 Clang-Tidy</h3> 
<p>Clang-Tidy 是一款基于 LLVM/Clang 框架的强大静态代码分析工具，专门用于检测 C++ 代码中的潜在问题和改进建议。它通过生成和解析抽象语法树（AST）深入理解代码结构和语义，从而提供高精度的检测结果，帮助开发者提升代码质量。</p> 
<p>要安装最新版本的 Clang-Tidy，推荐使用 <code>llvm.sh</code> 脚本，直接apt-get安装后的clang-tidy版本较旧。</p> 
<ul><li> <p>先使用 <code>llvm.sh</code> 脚本：</p> 
  <ul><li>下载并运行 <code>llvm.sh</code> 脚本来安装 LLVM 和 Clang-Tidy：<pre><code class="prism language-sh"><span class="token function">wget</span> https://apt.llvm.org/llvm.sh
<span class="token function">chmod</span> +x llvm.sh
<span class="token function">sudo</span> ./llvm.sh <span class="token number">18</span>  <span class="token comment"># 安装了18版本</span>
</code></pre> </li></ul> </li><li> <p>接着使用 <code>apt-get</code> 安装 Clang-Tidy：<br> <code>sh sudo apt-get install clang-tidy </code></p> </li></ul> 
<h3><a id="2__clangtidy_43"></a>2. 配置 <code>.clang-tidy</code></h3> 
<p>本次配置比较详细，主要是为了减少误报。</p> 
<pre><code class="prism language-.clang-tidy">---
Checks: '-*,
        clang-analyzer-core.*,
        clang-analyzer-cplusplus.*,
        modernize-redundant-void-arg,
        modernize-use-bool-literals,
        modernize-use-equals-default,
        modernize-use-nullptr,
        modernize-use-override,
        google-explicit-constructor,
        google-readability-casting,
        readability-braces-around-statements,
        readability-identifier-naming.ClassCase,
        readability-identifier-naming.StructCase,
        readability-identifier-naming.TypedefCase,
        readability-identifier-naming.EnumCase,
        readability-non-const-parameter,
        cert-dcl21-cpp,
        bugprone-undelegated-constructor,
        bugprone-macro-parentheses,
        bugprone-macro-repeated-side-effects,
        bugprone-forward-declaration-namespace,
        bugprone-bool-pointer-implicit-conversion,
        bugprone-misplaced-widening-cast,
        cppcoreguidelines-narrowing-conversions,
        misc-unconventional-assign-operator,
        misc-unused-parameters'
WarningsAsErrors: ''
HeaderFilterRegex: ''
CheckOptions:
  # 现代化（Modernize）
  - key:             modernize-redundant-void-arg
    value:           'true'  # 检查并移除函数声明中冗余的 void 参数。
  - key:             modernize-use-bool-literals
    value:           'true'  # 建议使用布尔字面量 true 和 false 代替整数值 0 和 1。
  - key:             modernize-use-equals-default
    value:           'true'  # 建议在默认构造函数、复制构造函数和赋值运算符中使用 = default，以简化代码。
  - key:             modernize-use-nullptr
    value:           'true'  # 建议使用 nullptr 代替 NULL 或 0 来表示空指针。
  - key:             modernize-use-override
    value:           'true'  # 建议在覆盖基类虚函数时使用 override 关键字，以增加代码的清晰性和安全性。

  # Google 代码风格（Google）
  - key:             google-explicit-constructor
    value:           'true'  # 检查并建议在单参数构造函数中使用 explicit 关键字，以防止隐式转换。
  - key:             google-readability-casting
    value:           'true'  # 检查并建议使用 C++ 风格的类型转换（如 static_cast、dynamic_cast、const_cast 和 reinterpret_cast）代替 C 风格的类型转换。

  # 可读性（Readability）
  - key:             readability-braces-around-statements
    value:           'true'  # 建议在单行语句周围添加大括号，以提高代码的可读性和一致性。
  - key:             readability-identifier-naming.ClassCase
    value:           'CamelCase'  # 类名应使用 CamelCase 风格，例如 MyClassName。
  - key:             readability-identifier-naming.StructCase
    value:           'CamelCase'  # 结构体名应使用 CamelCase 风格，例如 MyStructName。
  - key:             readability-identifier-naming.TypedefCase
    value:           'CamelCase'  # 类型定义应使用 CamelCase 风格，例如 MyTypeDef。
  - key:             readability-identifier-naming.EnumCase
    value:           'CamelCase'  # 枚举名应使用 CamelCase 风格，例如 MyEnumName。
  - key:             readability-non-const-parameter
    value:           'true'  # 检查并标识非 const 参数，以提高代码的可读性和安全性。

  # CERT 安全编码标准（CERT）
  - key:             cert-dcl21-cpp
    value:           'true'  # 检查并标识在头文件中不应包含无命名空间的 using 声明和指令，以防止命名空间污染。

  # Bug 检测（Bugprone）
  - key:             bugprone-undelegated-constructor
    value:           'true'  # 检查并标识未委托的构造函数，以确保构造函数的正确性。
  - key:             bugprone-macro-parentheses
    value:           'true'  # 检查并建议在宏定义中使用括号，以防止潜在的错误。
  - key:             bugprone-macro-repeated-side-effects
    value:           'true'  # 检查并标识宏中重复的副作用，以防止潜在的错误。
  - key:             bugprone-forward-declaration-namespace
    value:           'true'  # 检查并标识命名空间前向声明的潜在问题。
  - key:             bugprone-bool-pointer-implicit-conversion
    value:           'true'  # 检查并标识布尔指针的隐式转换，以防止潜在的错误。
  - key:             bugprone-misplaced-widening-cast
    value:           'true'  # 检查并标识错误的宽化转换，以防止潜在的错误。

  # C++ 核心指南（CppCoreGuidelines）
  - key:             cppcoreguidelines-narrowing-conversions
    value:           'true'  # 检查并标识可能导致数据丢失的窄化转换。

  # 杂项（Miscellaneous）
  - key:             misc-unconventional-assign-operator
    value:           'true'  # 检查并标识不常见的赋值操作符重载，以确保代码的一致性和可维护性。
  - key:             misc-unused-parameters
    value:           'true'  # 检测未使用的参数。
...


</code></pre> 
<p><code>-*</code>: 禁用所有默认的检查。</p> 
<h3><a id="3__144"></a>3. 检查项详解</h3> 
<h4><a id="31_Static_Analyzer_146"></a>3.1 静态分析器（Static Analyzer）</h4> 
<ol><li><code>clang-analyzer-core.*</code>: 
  <ul><li>用于检测代码中的基本问题，包括内存管理错误、未初始化变量、空指针引用等。这些检查器会深入分析代码逻辑，找出潜在的错误。</li><li><strong>主要功能</strong>： 
    <ul><li>检查未初始化变量使用。</li><li>检查空指针解引用。</li><li>检查内存泄漏。</li><li>检查未处理的返回值。</li><li>检查资源泄漏。</li></ul> </li></ul> </li><li><code>clang-analyzer-cplusplus.*</code>: 
  <ul><li>专注于 C++ 代码中的特定问题。这些检查器可以检测 C++ 特有的错误，如对象的生命周期管理、构造函数和析构函数的使用等。</li><li><strong>主要功能</strong>： 
    <ul><li>检查 C++ 对象的正确构造和析构。</li><li>检查对象的移动和复制语义。</li><li>检查异常安全性。</li><li>检查智能指针的正确使用。</li></ul> </li></ul> </li></ol> 
<h4><a id="32_Modernize_164"></a>3.2 现代化（Modernize）</h4> 
<ol><li><code>modernize-redundant-void-arg</code>: 
  <ul><li>检查并移除函数声明中冗余的 <code>void</code> 参数。使函数签名更简洁。</li></ul> </li><li><code>modernize-use-bool-literals</code>: 
  <ul><li>建议使用布尔字面量 <code>true</code> 和 <code>false</code> 代替整数值 <code>0</code> 和 <code>1</code>。提高代码的可读性和表达性。</li></ul> </li><li><code>modernize-use-equals-default</code>: 
  <ul><li>建议在默认构造函数、复制构造函数和赋值运算符中使用 <code>= default</code>，以简化代码，并确保编译器生成更高效的代码。</li></ul> </li><li><code>modernize-use-nullptr</code>: 
  <ul><li>建议使用 <code>nullptr</code> 代替 <code>NULL</code> 或 <code>0</code> 来表示空指针。避免类型不匹配的风险。</li></ul> </li><li><code>modernize-use-override</code>: 
  <ul><li>建议在覆盖基类虚函数时使用 <code>override</code> 关键字。确保函数覆盖的正确性，避免意外的函数隐藏。</li></ul> </li></ol> 
<h4><a id="33_Google_Google_177"></a>3.3 Google 代码风格（Google）</h4> 
<ol><li><code>google-explicit-constructor</code>: 
  <ul><li>检查并建议在单参数构造函数中使用 <code>explicit</code> 关键字。防止隐式转换带来的意外行为。</li></ul> </li><li><code>google-readability-casting</code>: 
  <ul><li>检查并建议使用 C++ 风格的类型转换（如 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>）代替 C 风格的类型转换。提高类型转换的安全性和可读性。</li></ul> </li></ol> 
<h4><a id="34_Readability_184"></a>3.4 可读性（Readability）</h4> 
<ol><li><code>readability-braces-around-statements</code>: 
  <ul><li>建议在单行语句周围添加大括号。提高代码的可读性和一致性，防止因省略大括号导致的错误。</li></ul> </li><li><code>readability-identifier-naming.ClassCase</code>: 
  <ul><li>类名应使用 CamelCase 风格，例如 <code>MyClassName</code>。提高代码命名的一致性和规范性。</li></ul> </li><li><code>readability-identifier-naming.StructCase</code>: 
  <ul><li>结构体名应使用 CamelCase 风格，例如 <code>MyStructName</code>。统一结构体的命名风格。</li></ul> </li><li><code>readability-identifier-naming.TypedefCase</code>: 
  <ul><li>类型定义应使用 CamelCase 风格，例如 <code>MyTypeDef</code>。规范类型定义的命名方式。</li></ul> </li><li><code>readability-identifier-naming.EnumCase</code>: 
  <ul><li>枚举名应使用 CamelCase 风格，例如 <code>MyEnumName</code>。保持枚举命名的一致性。</li></ul> </li><li><code>readability-non-const-parameter</code>: 
  <ul><li>检查并标识非 <code>const</code> 参数。提高代码的可读性和安全性，防止意外修改参数值。</li></ul> </li></ol> 
<h4><a id="35_CERT_CERT_199"></a>3.5 CERT 安全编码标准（CERT）</h4> 
<ol><li> <p><code>cert-dcl21-cpp:</code></p> 
  <ul><li>检查并标识在头文件中不应包含无命名空间的 <code>using</code> 声明和指令。防止命名空间污染，提高代码的可维护性。</li></ul> </li></ol> 
<h4><a id="36_Bug_Bugprone_205"></a>3.6 Bug 检测（Bugprone）</h4> 
<ol><li><code>bugprone-undelegated-constructor</code>: 
  <ul><li>检查并标识未委托的构造函数。确保构造函数的正确性，避免重复代码。</li></ul> </li><li><code>bugprone-macro-parentheses</code>: 
  <ul><li>检查并建议在宏定义中使用括号。防止宏扩展带来的优先级问题。</li></ul> </li><li><code>bugprone-macro-repeated-side-effects</code>: 
  <ul><li>检查并标识宏中重复的副作用。防止宏多次展开时的副作用问题。</li></ul> </li><li><code>bugprone-forward-declaration-namespace</code>: 
  <ul><li>检查并标识命名空间前向声明的潜在问题。确保命名空间前向声明的正确性。</li></ul> </li><li><code>bugprone-bool-pointer-implicit-conversion</code>: 
  <ul><li>检查并标识布尔指针的隐式转换。防止隐式转换带来的潜在错误。</li></ul> </li><li><code>bugprone-misplaced-widening-cast</code>: 
  <ul><li>检查并标识错误的宽化转换。避免由于类型转换导致的数据丢失或错误。</li></ul> </li></ol> 
<h4><a id="37_C_CppCoreGuidelines_220"></a>3.7 C++ 核心指南（CppCoreGuidelines）</h4> 
<ol><li><code>cppcoreguidelines-narrowing-conversions</code>: 
  <ul><li>检查并标识可能导致数据丢失的窄化转换。确保类型转换的安全性，防止数据丢失。</li></ul> </li><li><code>cppcoreguidelines-pro-type-reinterpret-cast</code>: 
  <ul><li>检查并警告使用 <code>reinterpret_cast</code> 的地方。提高代码的类型安全性，避免使用不安全的类型转换。</li></ul> </li></ol> 
<h4><a id="38_Miscellaneous_227"></a>3.8 杂项（Miscellaneous）</h4> 
<ol><li> <p><code>misc-unconventional-assign-operator:</code></p> 
  <ul><li>检查并标识不常见的赋值操作符重载。确保代码的一致性和可维护性，防止意外的行为。</li></ul> </li><li> <p><code>misc-unused-parameters:</code></p> 
  <ul><li>检测未使用的参数。</li></ul> </li></ol> 
<h3><a id="4__ClangTidy_234"></a>4. 使用 Clang-Tidy</h3> 
<h4><a id="41__compile_commandsjson_236"></a>4.1 生成 <code>compile_commands.json</code></h4> 
<p>使用 CMake 时，可以这样生成包含编译命令的 JSON 文件，该文件包含项目中所有源文件的编译信息。</p> 
<pre><code class="prism language-sh"><span class="token function">mkdir</span> build
<span class="token builtin class-name">cd</span> build
cmake <span class="token parameter variable">-DCMAKE_EXPORT_COMPILE_COMMANDS</span><span class="token operator">=</span>ON <span class="token punctuation">..</span>
</code></pre> 
<h4><a id="42__246"></a>4.2 运行检测</h4> 
<p>有了 <code>compile_commands.json</code>，就可以使用<code>run-clang-tidy</code>或者<code>clang-tidy</code>检测指定源文件：<br> 推荐使用<code> run-clang-tidy</code>， 例如</p> 
<pre><code>run-clang-tidy -p build -config-file=./.clang-tidy
</code></pre> 
<p><code>.clang-tidy </code>配置文件也可以不用手动指定。</p> 
<ul><li> <p><strong>run-clang-tidy 和 clang-tidy 的区别</strong></p> 
  <ul><li> <p><strong>clang-tidy</strong>：单独检测一个源文件，主要用于小规模或单文件测试。</p> </li><li> <p><strong>run-clang-tidy</strong>：可以批量检测多个源文件，非常适用于大规模项目。</p> </li></ul> </li><li> <p>**是否添加 -extra-arg=-std=c++14 **<br> 添加 -extra-arg=-std=c++14 参数可以指定 C++ 标准版本。例如：</p> </li></ul> 
<pre><code class="prism language-sh">clang-tidy <span class="token parameter variable">-p</span> build -config-file<span class="token operator">=</span>./.clang-tidy -extra-arg<span class="token operator">=</span>-std<span class="token operator">=</span>c++14 <span class="token operator">&lt;</span>source_file<span class="token operator">&gt;</span>
</code></pre> 
<h4><a id="43__272"></a>4.3 执行结果</h4> 
<p><strong>有错误时的提示</strong></p> 
<pre><code>.....
clang-tidy-18 -extra-arg=-std=c++11 -p=. --config-file=./.clang-tidy /home/test/clang-tidy/example.cpp
/home/test/Desktop/memory_analysis_v2/example.cpp:33:21: warning: narrowing conversion from 'size_t' (aka 'unsigned long') to signed type 'int' is implementation-defined [cppcoreguidelines-narrowing-conversions]
   33 |       arrayPtr[i] = i;
      |                     ^
830 warnings generated.
.....
</code></pre> 
<p><strong>如果没有错误时的提示</strong></p> 
<pre><code>clang-tidy-18 -extra-arg=-std=c++14 -p=. --config-file=./.clang-tidy /home/test/Desktop/memory_analysis_v2/example.cpp
832 warnings generated.
Suppressed 832 warnings (830 in non-user code, 2 with check filters).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
</code></pre> 
<h4><a id="44_warnings_291"></a>4.4 如何屏蔽warnings?</h4> 
<p>在代码的后面添加<code>// NOLINT</code>即可屏蔽检测。</p> 
<h4><a id="45__CMake__295"></a>4.5 与 CMake 集成</h4> 
<p>通过将 Clang-Tidy 与 CMake 集成，可以在编译阶段自动运行代码分析，早期发现潜在问题。本节将介绍如何在 CMake 构建系统中集成 Clang-Tidy，并解释相关脚本的工作原理。</p> 
<h5><a id="CMake__298"></a>CMake 脚本详解</h5> 
<pre><code class="prism language-cmake">cmake_minimum_required(VERSION 3.10)

# Project name
project(ExampleProject)

# Generate compile_commands.json to enable clang-tidy checks
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# example target
add_executable(example example.cpp)

# Find all .cpp files in the project source directory
file(GLOB_RECURSE ALL_CPP_FILES ${CMAKE_SOURCE_DIR}/*.cpp)

# Clang-tidy custom targets for running and checking results
add_custom_target(run_clang_tidy
    COMMAND clang-tidy -p ${CMAKE_BINARY_DIR} --warnings-as-errors=* ${ALL_CPP_FILES} || ${CMAKE_COMMAND} -E touch ${CMAKE_BINARY_DIR}/clang_tidy_failed
    COMMENT "Running clang-tidy"
    VERBATIM)

add_custom_target(check_clang_tidy
    COMMAND ${CMAKE_COMMAND} -E remove -f ${CMAKE_BINARY_DIR}/clang_tidy_failed
    COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target run_clang_tidy
    COMMENT "Checking clang-tidy results"
    VERBATIM)

# Ensure run_clang_tidy and check_clang_tidy are run before building any target
add_dependencies(example run_clang_tidy)

# Function to add Clang-Tidy pre-build check
function(add_clang_tidy_pre_build target_name)
    add_custom_command(TARGET ${target_name} PRE_BUILD
        COMMAND ${CMAKE_COMMAND} -E echo "Running Clang-Tidy pre-build check for ${target_name}"
        COMMAND ${CMAKE_COMMAND} -E remove -f ${CMAKE_BINARY_DIR}/clang_tidy_failed
        COMMAND /bin/bash -c "if [ -f ${CMAKE_BINARY_DIR}/clang_tidy_failed ]; then echo 'Stopping build due to Clang-tidy errors.'; exit 1; else echo 'No Clang-tidy issues found. Continuing build.'; fi"
        COMMENT "Checking for Clang-tidy issues before building ${target_name}"
        VERBATIM)
endfunction()

# Add Clang-Tidy pre-build check for targets
add_clang_tidy_pre_build(example)
</code></pre> 
<h5><a id="_344"></a>脚本细节解析</h5> 
<ol><li> <p><strong>CMake 基本设置</strong>：</p> 
  <ul><li><code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code>: 生成 <code>compile_commands.json</code> 文件，提供编译数据库，方便 Clang-Tidy 使用。</li></ul> </li><li> <p><strong>目标文件和源文件</strong>：</p> 
  <ul><li><code>file(GLOB_RECURSE ALL_CPP_FILES ${CMAKE_SOURCE_DIR}/*.cpp)</code>: 递归查找项目源目录下的所有 <code>.cpp</code> 文件，并将其存储在 <code>ALL_CPP_FILES</code> 变量中。这一步确保所有的源文件都包含在 Clang-Tidy 的检查范围内。</li></ul> </li><li> <p><strong>定义 Clang-Tidy 自定义目标</strong>：</p> 
  <ul><li><code>add_custom_target(run_clang_tidy ...)</code>: 
    <ul><li><code>COMMAND clang-tidy -p ${CMAKE_BINARY_DIR} --warnings-as-errors=* ${ALL_CPP_FILES} || ${CMAKE_COMMAND} -E touch ${CMAKE_BINARY_DIR}/clang_tidy_failed</code>: 运行 Clang-Tidy，检查所有的 <code>.cpp</code> 文件。若发现任何警告，将其视为错误并生成 <code>clang_tidy_failed</code> 文件。</li><li><code>COMMENT "Running clang-tidy"</code>: 提供执行过程中显示的注释。</li><li><code>VERBATIM</code>: 确保命令字符串的精确性，不对其进行解释或修改。</li></ul> </li><li><code>add_custom_target(check_clang_tidy ...)</code>: 
    <ul><li><code>COMMAND ${CMAKE_COMMAND} -E remove -f ${CMAKE_BINARY_DIR}/clang_tidy_failed</code>: 删除 <code>clang_tidy_failed</code> 文件，以确保每次检查前都是干净的状态。</li><li><code>COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target run_clang_tidy</code>: 构建 <code>run_clang_tidy</code> 目标，实际执行 Clang-Tidy 检查。</li><li><code>COMMENT "Checking clang-tidy results"</code>: 提供执行过程中显示的注释。</li><li><code>VERBATIM</code>: 确保命令字符串的精确性。</li></ul> </li></ul> </li><li> <p><strong>目标依赖关系</strong>：</p> 
  <ul><li><code>add_dependencies(example run_clang_tidy)</code>: 定义 <code>example</code> 目标依赖于 <code>run_clang_tidy</code> 目标。这确保在构建 <code>example</code> 之前，先运行 Clang-Tidy 检查。</li></ul> </li><li> <p><strong>添加预构建检查</strong>：</p> 
  <ul><li><code>function(add_clang_tidy_pre_build target_name)</code>: 定义一个函数，用于为指定的目标添加 Clang-Tidy 预构建检查。 
    <ul><li><code>add_custom_command(TARGET ${target_name} PRE_BUILD ...)</code>: 
      <ul><li><code>COMMAND ${CMAKE_COMMAND} -E echo "Running Clang-Tidy pre-build check for ${target_name}"</code>: 在构建前输出一条消息，表示正在进行 Clang-Tidy 预构建检查。</li><li><code>COMMAND ${CMAKE_COMMAND} -E remove -f ${CMAKE_BINARY_DIR}/clang_tidy_failed</code>: 删除 <code>clang_tidy_failed</code> 文件，确保检查开始前是干净的。</li><li><code>COMMAND /bin/bash -c "if [ -f ${CMAKE_BINARY_DIR}/clang_tidy_failed ]; then echo 'Stopping build due to Clang-tidy errors.'; exit 1; else echo 'No Clang-tidy issues found. Continuing build.'; fi"</code>: 运行一个 Bash 脚本，检查 <code>clang_tidy_failed</code> 文件是否存在。如果存在，则终止构建并输出错误消息；如果不存在，则继续构建。</li><li><code>COMMENT "Checking for Clang-tidy issues before building ${target_name}"</code>: 提供执行过程中显示的注释。</li><li><code>VERBATIM</code>: 确保命令字符串的精确性。</li></ul> </li></ul> </li></ul> </li><li> <p><strong>为目标添加预构建检查</strong>：</p> 
  <ul><li><code>add_clang_tidy_pre_build(example)</code>: 为 <code>example</code> 目标添加 Clang-Tidy 预构建检查，确保在每次构建之前进行代码分析。</li></ul> </li></ol> 
<h3><a id="5__377"></a>5. 资源阅读</h3> 
<ul><li>官方文档：<a href="https://clang.llvm.org/extra/clang-tidy/" rel="nofollow">Clang-Tidy Documentation</a></li><li>社区论坛：<a href="https://forums.llvm.org/" rel="nofollow">LLVM Discussion Forums</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7cd750637ac18f28c1b4e3aeaf2c1598/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">提升办公效率的智能 AI 伙伴 -- ONLYOFFICE</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c37cff045ef91a0e3d9236ffd210f97f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一、安装Redis（win11环境下）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>