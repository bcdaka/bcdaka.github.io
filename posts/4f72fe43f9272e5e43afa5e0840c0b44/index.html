<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>谷粒商城实战笔记-110~114-全文检索-ElasticSearch-查询 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4f72fe43f9272e5e43afa5e0840c0b44/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="谷粒商城实战笔记-110~114-全文检索-ElasticSearch-查询">
  <meta property="og:description" content="文章目录 一，110-全文检索-ElasticSearch-进阶-两种查询方式二，111-全文检索-ElasticSearch-进阶-QueryDSL基本使用&amp;match_all三，112-全文检索-ElasticSearch-进阶-match全文检索四，113-全文检索-ElasticSearch-进阶-match_phrase短语匹配五，114-全文检索-ElasticSearch-进阶-multi_match多字段匹配 一，110-全文检索-ElasticSearch-进阶-两种查询方式 Elasticsearch两种基本的检索方式使用Elasticsearch REST API的说明：
使用REST request URI发送搜索参数：
这种方式是通过GET请求将查询参数附加在URL上。这适用于简单的查询，并且可以很容易地在浏览器中测试。例如，上面的查询示例：
GET bank/_search?q=*&amp;sort=account_number:asc GET 是HTTP方法，用于请求从服务器获取资源。bank 是索引的名称。_search 是一个特殊的端点，用于执行搜索查询。q=* 是查询参数，* 表示搜索所有文档。sort=account_number:asc 指定了排序方式，这里按照account_number字段升序排序。 使用REST request body发送搜索参数：
这种方式是通过POST请求发送一个JSON格式的请求体。它提供了更复杂的查询能力，并且可以包含多个查询参数和选项。例如，上面的查询示例：
POST bank/_search { &#34;query&#34;: { &#34;match_all&#34;: {} }, &#34;sort&#34;: [ { &#34;account_number&#34;: { &#34;order&#34;: &#34;desc&#34; } } ] } POST 是HTTP方法，通常用于向服务器提交要被处理的数据。bank/_search 同样指定了索引和搜索端点。请求体中的 &#34;query&#34;: { &#34;match_all&#34;: {} } 定义了一个查询，match_all 查询将匹配所有文档。&#34;sort&#34; 数组定义了排序规则，这里指定了按照account_number字段降序排序。 两种方式的主要区别在于查询的复杂性和灵活性。使用URI的方式简单直观，适合快速测试和简单的查询。使用请求体的方式则更适合复杂的查询，可以包含更多的选项和参数。
二，111-全文检索-ElasticSearch-进阶-QueryDSL基本使用&amp;match_all GET bank/_search { &#34;query&#34;: { &#34;match_all&#34;: {} }, &#34;sort&#34;: [ { &#34;balance&#34;: { &#34;order&#34;: &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T18:18:48+08:00">
    <meta property="article:modified_time" content="2024-08-02T18:18:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">谷粒商城实战笔记-110~114-全文检索-ElasticSearch-查询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#110ElasticSearch_1" rel="nofollow">一，110-全文检索-ElasticSearch-进阶-两种查询方式</a></li><li><a href="#111ElasticSearchQueryDSLmatch_all_44" rel="nofollow">二，111-全文检索-ElasticSearch-进阶-QueryDSL基本使用&amp;match_all</a></li><li><a href="#112ElasticSearchmatch_92" rel="nofollow">三，112-全文检索-ElasticSearch-进阶-match全文检索</a></li><li><a href="#113ElasticSearchmatch_phrase_135" rel="nofollow">四，113-全文检索-ElasticSearch-进阶-match_phrase短语匹配</a></li><li><a href="#114ElasticSearchmulti_match_171" rel="nofollow">五，114-全文检索-ElasticSearch-进阶-multi_match多字段匹配</a></li></ul> 
</div> 
<p></p> 
<h2><a id="110ElasticSearch_1"></a>一，110-全文检索-ElasticSearch-进阶-两种查询方式</h2> 
<p>Elasticsearch两种基本的检索方式使用Elasticsearch REST API的说明：</p> 
<ol><li> <p><strong>使用REST request URI发送搜索参数</strong>：<br> 这种方式是通过GET请求将查询参数附加在URL上。这适用于简单的查询，并且可以很容易地在浏览器中测试。例如，上面的查询示例：</p> <pre><code>GET bank/_search?q=*&amp;sort=account_number:asc
</code></pre> 
  <ul><li><code>GET</code> 是HTTP方法，用于请求从服务器获取资源。</li><li><code>bank</code> 是索引的名称。</li><li><code>_search</code> 是一个特殊的端点，用于执行搜索查询。</li><li><code>q=*</code> 是查询参数，<code>*</code> 表示搜索所有文档。</li><li><code>sort=account_number:asc</code> 指定了排序方式，这里按照<code>account_number</code>字段升序排序。</li></ul> </li><li> <p><strong>使用REST request body发送搜索参数</strong>：<br> 这种方式是通过POST请求发送一个JSON格式的请求体。它提供了更复杂的查询能力，并且可以包含多个查询参数和选项。例如，上面的查询示例：</p> <pre><code>POST bank/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "account_number": {
        "order": "desc"
      }
    }
  ]
}
</code></pre> 
  <ul><li><code>POST</code> 是HTTP方法，通常用于向服务器提交要被处理的数据。</li><li><code>bank/_search</code> 同样指定了索引和搜索端点。</li><li>请求体中的 <code>"query": { "match_all": {} }</code> 定义了一个查询，<code>match_all</code> 查询将匹配所有文档。</li><li><code>"sort"</code> 数组定义了排序规则，这里指定了按照<code>account_number</code>字段降序排序。</li></ul> </li></ol> 
<p>两种方式的主要区别在于查询的复杂性和灵活性。使用URI的方式简单直观，适合快速测试和简单的查询。使用请求体的方式则更适合复杂的查询，可以包含更多的选项和参数。</p> 
<h2><a id="111ElasticSearchQueryDSLmatch_all_44"></a>二，111-全文检索-ElasticSearch-进阶-QueryDSL基本使用&amp;match_all</h2> 
<pre><code class="prism language-json"><span class="token constant">GET</span> bank<span class="token operator">/</span>_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string-property property">"sort"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token string-property property">"balance"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string-property property">"order"</span><span class="token operator">:</span> <span class="token string">"desc"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string-property property">"from"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
  <span class="token string-property property">"size"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
  <span class="token string-property property">"_source"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"balance"</span><span class="token punctuation">,</span> <span class="token string">"firstname"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol><li> <p><code>GET bank/_search</code>：这是HTTP请求的开始，其中<code>GET</code>是请求方法，<code>bank</code>是索引的名称，<code>_search</code>是执行搜索查询的端点。</p> </li><li> <p><code>"query": {<!-- --></code>：定义查询的开始。</p> </li><li> <p><code>"match_all":()</code>：这是一个查询子句，<code>match_all</code>查询会匹配所有文档。括号<code>()</code>在这里应该是空的，因为<code>match_all</code>查询不需要任何参数。</p> </li><li> <p><code>'sort": [</code>：这个部分看起来像是一个语法错误，因为<code>sort</code>关键字后面紧跟着一个单引号<code>'</code>，这可能是一个复制粘贴错误。正确的应该是<code>"sort": {<!-- --></code>，用于定义排序规则。</p> </li><li> <p><code>"balance":</code>：这是排序规则的一个字段，表示按照<code>balance</code>字段进行排序。</p> </li><li> <p><code>"orden": "desc"</code>：指定排序的顺序，<code>"desc"</code>表示降序排序。</p> </li><li> <p><code>"from": 5,</code>：定义从结果的哪个位置开始返回，这里设置为5，意味着从第6个结果开始返回。</p> </li><li> <p><code>"size": 5,</code>：定义返回结果的数量，这里设置为5，意味着返回5个结果。</p> </li><li> <p><code>_source": ["balance","firstname"]</code>：定义返回的源字段，这里指定返回<code>balance</code>和<code>firstname</code>字段的值。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/ea/6b/XogBUDjv_o.png" alt="在这里插入图片描述"></p> 
<p>这个查询会从<code>bank</code>索引中检索所有文档，按照<code>balance</code>字段降序排序，跳过前5个结果，然后返回接下来的5个结果，并且只返回每个结果的<code>balance</code>和<code>firstname</code>字段。</p> 
<h2><a id="112ElasticSearchmatch_92"></a>三，112-全文检索-ElasticSearch-进阶-match全文检索</h2> 
<p>match query是一种模糊匹配，查询时会将关键词进行分词处理，然后基于倒排索引进行匹配，对于匹配到的结果进行打分，返回结果按照评分进行排序。</p> 
<p>如下查询。</p> 
<pre><code class="prism language-dart">
GET bank<span class="token operator">/</span>_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string-literal"><span class="token string">"query"</span></span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string-literal"><span class="token string">"match"</span></span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string-literal"><span class="token string">"address"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"mill"</span></span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个查询同样是针对Elasticsearch的"bank"索引的一个搜索请求，使用<code>match</code>查询来执行全文搜索。</p> 
<ul><li> <p><code>GET bank/_search</code>: 这表示使用HTTP GET方法发起请求，目的是对"bank"索引进行搜索。</p> </li><li> <p><code>"query"</code>: 这部分定义了搜索的查询条件。</p> </li><li> <p><code>"match"</code>: 这是Elasticsearch中用于执行全文搜索的查询类型，它会在指定的字段上进行搜索。</p> </li><li> <p><code>"address"</code>: 这是要搜索的字段名称，即文档中的"address"字段。</p> </li><li> <p><code>"Mill road"</code>: 这是搜索的关键词，查询会寻找"address"字段中包含"Mill road"这个确切短语的文档。</p> </li></ul> 
<p><strong>匹配查询有两种可能：</strong></p> 
<ol><li> <p><strong>完全匹配</strong>: 文档的"address"字段完全包含"Mill road"这个短语，例如：“123 Mill road”。</p> </li><li> <p><strong>部分匹配</strong>: 搜索关键词"Mill road"会被分词为"mill"和"road"，如果"address"字段包含"Mill"和"road"，就会被匹配到，如"198 Mill Lane"或"263 Aviation Road"。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/fe/5f/KnUbnaTl_o.png" alt="在这里插入图片描述"><br> 查询结果显示，一共有32个文档被匹配，每个结果都有评分，最高评分是8.926605，返回结果默认按照评分降序排序。显然，评分最高的是与搜索关键词匹配度最高的文档。</p> 
<h2><a id="113ElasticSearchmatch_phrase_135"></a>四，113-全文检索-ElasticSearch-进阶-match_phrase短语匹配</h2> 
<p><code>match_phrase</code>和<code>match</code>类似，都是在指定的字段中进行全文搜索，不同的是<code>match_phrase</code>要匹配整个短语中所有的词，<code>match</code>匹配单个词就算命中，<code>match_phrase</code>查询还关注词的顺序和位置，它返回的是那些在指定字段中包含整个短语的文档。</p> 
<p>以下是<code>match_phrase</code>查询的一些关键点：</p> 
<ol><li> <p><strong>短语匹配</strong>: <code>match_phrase</code>会寻找包含整个短语的文档，而不是单独的词。</p> </li><li> <p><strong>词序</strong>: 它匹配的是短语中词的顺序，即短语中的词必须按照指定的顺序出现。</p> </li><li> <p><strong>位置敏感</strong>: 短语中的词之间可以有其他词，但它们必须在短语中指定的顺序内。</p> </li><li> <p><strong>使用场景</strong>: 当你需要搜索包含特定短语的文档时，比如搜索包含完整地址或名称的文档，<code>match_phrase</code>是一个很好的选择。</p> </li><li> <p><strong>性能</strong>: 由于<code>match_phrase</code>查询需要考虑词的顺序和位置，它可能比<code>match</code>查询在性能上要慢一些。</p> </li><li> <p><strong>分析器</strong>: 与<code>match</code>查询一样，<code>match_phrase</code>也受到字段使用的分析器的影响。不同的分析器可能会影响搜索结果。</p> </li><li> <p><strong>语法</strong>: <code>match_phrase</code>查询的语法与<code>match</code>类似，但是它更专注于短语的完整性和顺序。</p> </li></ol> 
<p>这里是一个使用<code>match_phrase</code>查询的示例：</p> 
<pre><code class="prism language-json"><span class="token constant">GET</span> bank<span class="token operator">/</span>_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"match_phrase"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string-property property">"address"</span><span class="token operator">:</span> <span class="token string">"Mill Road"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个示例中，查询会寻找"address"字段中包含"Mill Road"这个确切短语的文档，并且词的顺序和大小写都需要匹配。如果"address"字段包含"Mill Road"，但是顺序或大小写不同，或者两个词中间有其他词，那么这些文档将不会被匹配。</p> 
<h2><a id="114ElasticSearchmulti_match_171"></a>五，114-全文检索-ElasticSearch-进阶-multi_match多字段匹配</h2> 
<p><code>multi_match</code>查询允许在多个字段上执行相同的搜索查询，只要一个字段匹配，这条记录就会被命中。</p> 
<p>下面是一个使用<code>multi_match</code>查询的示例：</p> 
<pre><code class="prism language-json"><span class="token constant">GET</span> bank<span class="token operator">/</span>_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"multi_match"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string-property property">"query"</span><span class="token operator">:</span> <span class="token string">"Albemarle"</span><span class="token punctuation">,</span>
      <span class="token string-property property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"address"</span><span class="token punctuation">,</span> <span class="token string">"firstname"</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个示例中，查询会在<code>address</code>、<code>firstname</code>字段上搜索包含"Albemarle"的文档。如果这些字段中的任何一个包含这个短语，文档就可能被返回在搜索结果中。</p> 
<p>如下，<code>firstname</code>包含<code>Albemarle</code>，<code>address</code>中不包含<code>Albemarle</code>，但文档也会被命中。</p> 
<p><img src="https://images2.imgbox.com/42/49/ZpGDkpdO_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/951ca0b0e723d5a3b88ce1c12ea150d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据挖掘可以挖掘什么类型的模式？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e3a6bad4168c87d0555071ddd2dc52b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【人工智能】Transformers之Pipeline（七）：图像分割（image-segmentation）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>