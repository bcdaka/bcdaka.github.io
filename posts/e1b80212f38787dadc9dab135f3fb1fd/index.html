<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构（栈的实现） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e1b80212f38787dadc9dab135f3fb1fd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构（栈的实现）">
  <meta property="og:description" content="目录
栈的定义
栈的实现
定义栈
初始化栈
栈的销毁
进栈
删除栈
返回栈元素个数
判断栈是否为空
返回栈顶元素
进行打印
代码链接
个人总结
栈的定义 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端 称为栈顶，另一端称为栈底。栈遵循先进后出的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈的实现
对于栈，可以用数组的方式实现，也可以用链表的方式实现，而我选择用数组的方式实现，因为数组的。因为数组在尾上插入数据的 代价比较小。
栈的实现 定义栈 typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; 定义栈，因为要定义多个数据，所以选择结构体 用typedef来为数据类型定义一个新的名称，方便以后修改，其他数据类型；
STDataType* a;表示一个数组指针
int top;表示栈顶
int capacity;表示数组的容量
初始化栈 void STInit(ST* ps) { assert(ps); ps-&gt;a = (STDataType*)malloc(sizeof(STDataType*)*4); if (ps-&gt;a==NULL) { perror(&#34;malloc fail&#34;); return; } ps-&gt;capacity = 4; ps-&gt;top = 0; } 首先进行断言，来确保，我们传进来的不是一个空指针；">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-05T19:42:36+08:00">
    <meta property="article:modified_time" content="2024-07-05T19:42:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构（栈的实现）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">栈的定义</a></p> 
<p id="%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">栈的实现</a></p> 
<p id="%E5%AE%9A%E4%B9%89%E6%A0%88-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E4%B9%89%E6%A0%88" rel="nofollow">定义栈</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88" rel="nofollow">初始化栈</a></p> 
<p id="%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">栈的销毁</a></p> 
<p id="%C2%A0%E8%BF%9B%E6%A0%88-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%BF%9B%E6%A0%88" rel="nofollow"> 进栈</a></p> 
<p id="%C2%A0%E5%88%A0%E9%99%A4%E6%A0%88-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%88%A0%E9%99%A4%E6%A0%88" rel="nofollow"> 删除栈</a></p> 
<p id="%C2%A0%20%E8%BF%94%E5%9B%9E%E6%A0%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%E8%BF%94%E5%9B%9E%E6%A0%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow">  返回栈元素个数</a></p> 
<p id="%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-toc" style="margin-left:80px;"><a href="#%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" rel="nofollow">判断栈是否为空</a></p> 
<p id="%E8%BF%94%E5%9B%9E%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#%E8%BF%94%E5%9B%9E%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0" rel="nofollow">返回栈顶元素</a></p> 
<p id="%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8D%B0-toc" style="margin-left:80px;"><a href="#%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8D%B0" rel="nofollow">进行打印</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E9%93%BE%E6%8E%A5" rel="nofollow">代码链接</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89" style="background-color:transparent;">栈的定义</h2> 
<p> 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端 称为栈顶，另一端称为栈底。栈遵循先进后出的原则。</p> 
<p>压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。</p> 
<p> 出栈：栈的删除操作叫做出栈。出数据也在栈顶。</p> 
<p></p> 
<p><img alt="" height="430" src="https://images2.imgbox.com/33/d4/JwELpIQE_o.png" width="718"></p> 
<p> 栈的实现</p> 
<p>对于栈，可以用数组的方式实现，也可以用链表的方式实现，而我选择用数组的方式实现，因为数组的。因为数组在尾上插入数据的 代价比较小。</p> 
<h3 id="%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0">栈的实现</h3> 
<h4 id="%E5%AE%9A%E4%B9%89%E6%A0%88">定义栈</h4> 
<pre><code class="hljs">typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;</code></pre> 
<p>定义栈，因为要定义多个数据，所以选择结构体 </p> 
<p>用typedef来为数据类型定义一个新的名称，方便以后修改，其他数据类型；</p> 
<p>STDataType* a;表示一个数组指针</p> 
<p>int top;表示栈顶</p> 
<p>int capacity;表示数组的容量</p> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88">初始化栈</h4> 
<pre><code class="hljs">void STInit(ST* ps)
{
	assert(ps);
	ps-&gt;a = (STDataType*)malloc(sizeof(STDataType*)*4);
	if (ps-&gt;a==NULL)
	{
		perror("malloc fail");
		return;
	}
	ps-&gt;capacity = 4;
	ps-&gt;top = 0;
}</code></pre> 
<p> 首先进行断言，来确保，我们传进来的不是一个空指针；</p> 
<p>对数组a进行开辟空间，大小为sizeof(STDataType*)*4，然后在进行强制转换为STDataType*类型</p> 
<p>对是否开辟成功进行判断；</p> 
<p>容量大小为4</p> 
<p>ps-&gt;top = 0;这个表示指向栈底的下一个元素，加入一个元素top++；</p> 
<p>如果用表示栈底用ps-&gt;top = -1，那么加入一个元素 ++top；</p> 
<h4 id="%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81">栈的销毁</h4> 
<pre><code class="hljs">// 栈的销毁
void STDestroy(ST* ps)
{
	assert(ps);
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;capacity = 0;
	ps-&gt;top = 0;

}</code></pre> 
<p>用free释放空间，其他置为0即可；</p> 
<p>注意，如果ps-&gt;top用的-1，那这里也要置为-1；</p> 
<h4 id="%C2%A0%E8%BF%9B%E6%A0%88"> 进栈</h4> 
<pre><code class="hljs">//添加
void STPush(ST* ps, STDataType x)
{
	assert(ps);
	if (ps-&gt;top == ps-&gt;capacity)
	{
		STDataType* tum = realloc((ps-&gt;a), sizeof(STDataType*) * ps-&gt;capacity * 2);
		return;
		if (ps-&gt;a == NULL)
		{
			perror("malloc fail");
			return;
		}
		ps-&gt;a = tum;
		ps-&gt;capacity = ps-&gt;capacity * 2;
		
	}
	ps-&gt;a[ps-&gt;top] = x;
	ps-&gt;top++;

	
}</code></pre> 
<p>  首先要对空间容量进行判断，如果空间满了，要进行扩容</p> 
<p>  然后把 x放在a数组的top的位置</p> 
<p> 然后把top++即可</p> 
<h4 id="%C2%A0%E5%88%A0%E9%99%A4%E6%A0%88"> 删除栈</h4> 
<pre><code class="hljs">//删除栈顶元素
void STPop(ST* ps)
{
	assert(ps);
	// 需要判断栈内是否还有数据
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}</code></pre> 
<p>这里需要多断言一次，防止数组为空，也进行删除，出现越界；</p> 
<h4 id="%C2%A0%20%E8%BF%94%E5%9B%9E%E6%A0%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">  返回栈元素个数</h4> 
<pre><code class="hljs">//查看有多少元素
int STSize(ST* ps)
{
	assert(ps);
	return ps-&gt;top;
}
</code></pre> 
<h4 id="%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">判断栈是否为空</h4> 
<pre><code class="hljs">bool STEmpty(ST* ps)
{
	assert(ps);
	return ps-&gt;top == 0;
}</code></pre> 
<p>这里用bool来返回，若为空返回真，不为空，返回假；</p> 
<h4 id="%E8%BF%94%E5%9B%9E%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0">返回栈顶元素</h4> 
<pre><code class="hljs">//查找栈顶元素
STDataType STTop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	return ps-&gt;a[ps-&gt;top - 1];

}</code></pre> 
<p>这里也要多断言一下，防止为空进行返回，因为我们的top是栈底的下一个元素，所以要进行减一</p> 
<h4 id="%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8D%B0">进行打印</h4> 
<pre><code class="hljs">void STPrint(ST* ps)
{
	assert(ps);
	while (!STEmpty(ps))
	{
		printf("%d", STTop(ps));
		STPop(ps);
	}
	printf("\n");
}</code></pre> 
<p>这里进行，用判断栈是否为空，来为循环条件；</p> 
<p>每一次打印栈顶元素</p> 
<p>在进行出栈；</p> 
<h3 id="%E4%BB%A3%E7%A0%81%E9%93%BE%E6%8E%A5">代码链接</h3> 
<p><a class="link-info" href="https://gitee.com/pineapple-geng-caihong/new-data-structure/tree/master/warehouse" rel="nofollow" title="https://gitee.com/pineapple-geng-caihong/new-data-structure/tree/master/warehouse">https://gitee.com/pineapple-geng-caihong/new-data-structure/tree/master/warehouse</a></p> 
<h3 id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" style="background-color:transparent;">个人总结</h3> 
<p>以上就是我对栈的实现和理解，总体来说栈比较简单</p> 
<p>希望我的博客会对大家有帮助，如果有任何其他建议或想法或者发现错误，我非常乐意听取。并努力改进。</p> 
<p><img alt="" height="395" src="https://images2.imgbox.com/57/c2/hnfcpor6_o.png" width="610"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/17b0b305469cd11bf4b10954223e1c2f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43;之旅第十一弹——顺序表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3a8f1fff96a484b9266d2e1d0408c85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【leetcode】双指针算法题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>