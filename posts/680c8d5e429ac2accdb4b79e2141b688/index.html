<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Django与数据库 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/680c8d5e429ac2accdb4b79e2141b688/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Django与数据库">
  <meta property="og:description" content="目录
创建项目app
路由子表
数据库
创建数据库
什么是ORM
定义数据库表
Django Admin 管理数据
过滤条件
代码直接生成HTML
使用模板
前后端分离架构
对资源的增删改查处理
列出客户
添加客户
临时取消 CSRF 校验
修改客户信息
删除客户
Django中ORM的处理
数据模型的配置
字段设置
字段参数
数据更新的实现
创建项目app Django中的一个app就是项目里面的一个应用的意思，一个项目包含多个app,一个app通常就是一个相对独立的模块，实现相对独立的功能。比如我们可以把系统中的管理员管理的功能放在一个名为mgr的app里面，把销售人员的操作实现在另一个名为sales的app里面。
Django中创建app可以通过执行命令，创建一个app目录，并在里面自动创建app常用的文件。
进入项目根目录，执行以下命令：
python manage.py startapp sales 这样就会创建一个目录名为 sales， 对应 一个名为 sales 的app，里面包含了如下自动生成的文件： migrations __init__.py admin.py apps.py models.py tests.py views.py 路由子表 一个请求对应一个处理函数，项目较大时，请求的url会特别多，我们可以将不同的路由记录按照功能分拆到不同的url路由子表中。
数据库 后端开发基本需要操作数据，包括数据的存储、查询、修改、删除。通常，这些都是通过数据来完成，目前业界最广泛使用的数据库还是：关系型数据库。
关系型数据库系统，常用的开源数据库有mysql和postgresql.
创建数据库 项目中数据库的配置在settings.py中。
DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;, # 数据库类型 &#39;NAME&#39;: &#39;core&#39;, # 所使⽤的数据库的名字 &#39;USER&#39;: &#39;root&#39;, # 数据库服务器的⽤户 &#39;PASSWORD&#39;: &#39;xxxxxx&#39;, # 密码 &#39;HOST&#39;: &#39;127.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T23:04:08+08:00">
    <meta property="article:modified_time" content="2024-08-05T23:04:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Django与数据库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AEapp-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AEapp" rel="nofollow">创建项目app</a></p> 
<p id="%C2%A0%E8%B7%AF%E7%94%B1%E5%AD%90%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%B7%AF%E7%94%B1%E5%AD%90%E8%A1%A8" rel="nofollow"> 路由子表</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">数据库</a></p> 
<p id="%C2%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow"> 创建数据库</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFORM-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFORM" rel="nofollow">什么是ORM</a></p> 
<p id="%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8" rel="nofollow">定义数据库表</a></p> 
<p id="django-admin-toc" style="margin-left:80px;"><a href="#django-admin" rel="nofollow">Django Admin 管理数据</a></p> 
<p id="%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6" rel="nofollow">过滤条件</a></p> 
<p id="html-toc" style="margin-left:80px;"><a href="#html" rel="nofollow">代码直接生成HTML</a></p> 
<p id="%C2%A0%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF" rel="nofollow"> 使用模板</a></p> 
<p id="%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84" rel="nofollow">前后端分离架构</a></p> 
<p id="%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%A4%84%E7%90%86" rel="nofollow">对资源的增删改查处理</a></p> 
<p id="%E5%88%97%E5%87%BA%E5%AE%A2%E6%88%B7-toc" style="margin-left:120px;"><a href="#%E5%88%97%E5%87%BA%E5%AE%A2%E6%88%B7" rel="nofollow">列出客户</a></p> 
<p id="%C2%A0%E6%B7%BB%E5%8A%A0%E5%AE%A2%E6%88%B7-toc" style="margin-left:120px;"><a href="#%C2%A0%E6%B7%BB%E5%8A%A0%E5%AE%A2%E6%88%B7" rel="nofollow"> 添加客户</a></p> 
<p id="%C2%A0%E4%B8%B4%E6%97%B6%E5%8F%96%E6%B6%88%20CSRF%20%E6%A0%A1%E9%AA%8C-toc" style="margin-left:120px;"><a href="#%C2%A0%E4%B8%B4%E6%97%B6%E5%8F%96%E6%B6%88%20CSRF%20%E6%A0%A1%E9%AA%8C" rel="nofollow"> 临时取消 CSRF 校验</a></p> 
<p id="%E4%BF%AE%E6%94%B9%E5%AE%A2%E6%88%B7%E4%BF%A1%E6%81%AF-toc" style="margin-left:120px;"><a href="#%E4%BF%AE%E6%94%B9%E5%AE%A2%E6%88%B7%E4%BF%A1%E6%81%AF" rel="nofollow">修改客户信息</a></p> 
<p id="%C2%A0%E5%88%A0%E9%99%A4%E5%AE%A2%E6%88%B7-toc" style="margin-left:120px;"><a href="#%C2%A0%E5%88%A0%E9%99%A4%E5%AE%A2%E6%88%B7" rel="nofollow"> 删除客户</a></p> 
<p id="Django%E4%B8%ADORM%E7%9A%84%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#Django%E4%B8%ADORM%E7%9A%84%E5%A4%84%E7%90%86" rel="nofollow">Django中ORM的处理</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%85%8D%E7%BD%AE" rel="nofollow">数据模型的配置</a></p> 
<p id="%E5%AD%97%E6%AE%B5%E8%AE%BE%E7%BD%AE-toc" style="margin-left:120px;"><a href="#%E5%AD%97%E6%AE%B5%E8%AE%BE%E7%BD%AE" rel="nofollow">字段设置</a></p> 
<p id="%E5%AD%97%E6%AE%B5%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><a href="#%E5%AD%97%E6%AE%B5%E5%8F%82%E6%95%B0" rel="nofollow">字段参数</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">数据更新的实现</a></p> 
<p>  </p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AEapp" style="background-color:transparent;">创建项目app</h4> 
<p>Django中的一个app就是项目里面的一个应用的意思，一个项目包含多个app,一个app通常就是一个相对独立的模块，实现相对独立的功能。比如我们可以把系统中的管理员管理的功能放在一个名为mgr的app里面，把销售人员的操作实现在另一个名为sales的app里面。</p> 
<p>Django中创建app可以通过执行命令，创建一个app目录，并在里面自动创建app常用的文件。</p> 
<p>进入项目根目录，执行以下命令：</p> 
<pre><code class="language-python">python manage.py startapp sales</code></pre> 
<p>这样就会创建一个目录名为 sales， 对应 一个名为 sales 的app，里面包含了如下自动生成的文件： </p> 
<pre><code class="language-python">migrations
__init__.py
admin.py
apps.py
models.py
tests.py
views.py</code></pre> 
<h4 id="%C2%A0%E8%B7%AF%E7%94%B1%E5%AD%90%E8%A1%A8"> 路由子表</h4> 
<p>一个请求对应一个处理函数，项目较大时，请求的url会特别多，我们可以将不同的路由记录按照功能分拆到不同的url路由子表中。</p> 
<h4 id="%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</h4> 
<p>后端开发基本需要操作数据，包括数据的存储、查询、修改、删除。通常，这些都是通过数据来完成，目前业界最广泛使用的数据库还是：<strong>关系型数据库</strong>。</p> 
<p>关系型数据库系统，常用的开源数据库有mysql和postgresql.</p> 
<h4 id="%C2%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"> 创建数据库</h4> 
<p>项目中数据库的配置在settings.py中。</p> 
<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # 数据库类型
        'NAME': 'core',  # 所使⽤的数据库的名字
        'USER': 'root',  # 数据库服务器的⽤户
        'PASSWORD': 'xxxxxx',  # 密码
        'HOST': '127.0.0.1',  # 主机
        'PORT': '3306',  # 端⼝
    }
}
</code></pre> 
<p>执行以下命令，创建数据库：</p> 
<pre><code class="language-python">python manage.py migrate</code></pre> 
<p> 项目的根目录下面生成一个配置文件中指定的数据库文件：db.sqlite3。</p> 
<p>并且会在其中创建一些表。</p> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AFORM">什么是ORM</h4> 
<p>Django里面，数据库的操作，包括数据的增删改查，基本都是通过Model类型的对象进行的。</p> 
<p>通常，在Django中:</p> 
<ul><li>定义一张数据库表就是定义一个继承自<strong>django.db.models.Model</strong>的类</li><li>定义该表中的字段（列），就是定义该类里面的一些属性</li><li>类的方法就是对该表中数据的处理方法，包括数据的增删改查</li></ul> 
<p>这样，开发者对数据库的访问，从原来的使用底层的sql语句，变成面向对象的开发，通过一系列对象的类定义和方法调用就可以操作数据库。</p> 
<p><strong>这样做：</strong></p> 
<p><strong>首先</strong>极大地简化了我们应用中的数据库开发，因为无需使用sql语句操作数据库了，提高了开发的效率。</p> 
<p><strong>其次</strong>屏蔽了不同的数据库访问的底层细节，开发好代码后，如果要换数据库，几乎不需要改代码，修改几个配置项即可。</p> 
<p>这种通过对象操作数据库的方法被称为ORM(object relational mapping)。</p> 
<p>Django的ORM（对象关系映射）是一个强大的工具，用于在Django应用程序中管理数据库，借助它我们可以使用Python代码而不是编写SQL语句来操作数据库，这是因为Django的ORM提供了一个高级的抽象层，通过定义Python类来表示数据库表，并使用这些类来执行常见的数据库操作，如创建、读取、更新和删除数据。</p> 
<h4 id="%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8">定义数据库表</h4> 
<p>我们再创建一个名为common的应用目录，里面存放我们项目需要的一些公共的表的定义。</p> 
<p>执行以下命令：</p> 
<pre><code class="language-python">python manage.py startapp common</code></pre> 
<p>创建了一个名为common的app.</p> 
<p>打开common/models.py，发现里面是空的，因为我们还没有定义我们的业务所需要的表。</p> 
<p>加入以下内容：</p> 
<pre><code class="language-python">from django.db import models


class Customer(models.Model):
    name = models.CharField(max_length=100)
    phonenumber = models.CharField(max_length=100)
    address = models.CharField(max_length=100)</code></pre> 
<p> 这个Customer类继承自django.db.models.Model，就是用来定义数据库表的，里面的name,phonenumber,address是该表的3个字段。</p> 
<p>CharField对象对应的是varchar类型的数据库字段。定义表中的字段就是定义一些静态属性，这些属性是django.db.models里面的各种Field对象，对应不同类型的字段。</p> 
<p>在settings.py中加入一句代码：</p> 
<pre><code class="language-python">INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'sales',
    # 加入以下代码：
    'common.apps.CommonConfig'
]</code></pre> 
<p> 'common.apps.CommonConfig' 告诉 Django，CommonConfig 是 common/apps.py 文件中定义的一个应用配置的类。</p> 
<pre><code class="language-python">class CommonConfig(AppConfig):
    name = 'common'</code></pre> 
<p>CommonConfig 是 AppConfig的 子类， 就表示这个是应用的配置类。</p> 
<p>这里 name = 'common' ， name 是用来定义 应用的python模块路径的。也就是说 应用 模块路径为 common 。</p> 
<p> Django知道了我们的common应用，可以在项目根目录下执行命令</p> 
<pre><code class="language-python">python manage.py makemigrations common</code></pre> 
<p>得到以下结果：</p> 
<pre><code class="language-python">Migrations for 'common':
  common\migrations\0001_initial.py
    - Create model Customer</code></pre> 
<p>会发现在 common\migrations 目录下面出现了0001_initial.py, 这个脚本就是相应要进行的数据库操作代码。</p> 
<p>随即，执行如下命令：</p> 
<pre><code class="language-python">python manage.py migrate</code></pre> 
<p>查看数据库，发现创建了一张名为 common_customer的表。</p> 
<p>多出来的 id 字段是该表的主键， 是Django自动帮我们添加的。</p> 
<p>这个不需要我们在类中显式的定义。</p> 
<p><strong>注意：</strong></p> 
<p>如果以后我们修改了Models.py 里面的库表的定义，都需要再次运行 python manage.py makemigrations common 和 python manage.py migrate 命令，使数据库同步该修改结果</p> 
<h4 id="django-admin">Django Admin 管理数据</h4> 
<p>Django提供了一个管理员操作界面，可以方便地添加、修改、删除定义的model表数据。</p> 
<p>首先，我们需要创建一个超级管理员账号，进入到项目的根目录，执行以下命令，依次输入要创建的管理员的登录名、email、密码。</p> 
<pre><code class="language-python">python manage.py createsuperuser
Username (leave blank to use '21544'): present
Error: That username is already taken.
Username (leave blank to use '21544'): present-01
Email address: 0123@qq.com
Password: 
Password (again): 
Superuser created successfully.
</code></pre> 
<p>然后需要修改应用里面的管理员配置文件common/admin.py，注册我们定义的model类，这样Django才会知道</p> 
<pre><code class="language-python">from django.contrib import admin

from .models import Customer
admin.site.register(Customer)</code></pre> 
<p> 然后可以访问 <code>http://127.0.0.1/admin/</code> ，输入刚才注册的用户密码登录。</p> 
<p>登录后可以看到如下界面。这里面是目前系统中可以修改的表。</p> 
<p><img alt="" height="477" src="https://images2.imgbox.com/fa/94/bKL49g3o_o.png" width="1200"></p> 
<p>点击ADD，添加用户之后点击SAVE，使用数据库查看工具，就发现数据库中确实有了添加的数据信息：</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/75/45/9fSoXheH_o.png" width="912"> 我们先实现一个函数，来处理sales/customers/访问请求，返回数据库中customer表所有记录。</p> 
<p>Django中对数据库表的操作，建议都是通过其对应Model对象的方法来进行的，而不是SQL语句。</p> 
<p>比如我们要获取customer表所有记录，该表是和我们前面定义的Customer类管理的，我们可以这样获取所有表的记录：</p> 
<p>在文件sales/views.py中，定义一个listcustomers函数，内容如下：</p> 
<pre><code class="language-python"># 导入 Customer 对象定义
from  common.models import  Customer

def listcustomers(request):
    # 返回一个 QuerySet 对象 ，包含所有的表记录
    # 每条表记录都是是一个dict对象，
    # key 是字段名，value 是 字段值
    qs = Customer.objects.values()

    # 定义返回字符串
    retStr = ''
    for customer in  qs:
        for name,value in customer.items():
            retStr += f'{name} : {value} | '

        # &lt;br&gt; 表示换行
        retStr += '&lt;br&gt;'

    return HttpResponse(retStr)</code></pre> 
<p>Customer.objects.values() 会返回一个 QuerySet 对象，这个对象是Django 定义的，在这里它包含所有的Customer 表记录，QuerySet对象可以使用for循环遍历取出里面所有的元素，每个元素对应一条表记录。每条表记录元素都是一个dict对象，其中每个元素的key是表字段名，value是该记录的字段值。上面的代码可以将每条记录的信息存储到字符串中，返回给前端浏览器。</p> 
<p>还需要修改路由表，加上对sales/customers/ url请求的路由。</p> 
<p>在bysms/urls.py主路由文件中，已有以下记录：</p> 
<pre><code class="language-python">    # 凡是 url 以 sales/  开头的，
    # 都根据 sales.urls 里面的 子路由表进行路由
    path('sales/', include('sales.urls')),</code></pre> 
<p> 我们只需修改 <code>sales/urls.py</code> 即可，添加如下记录:</p> 
<pre><code class="language-python">    path('customers/', views.listcustomers),</code></pre> 
<p>然后可以在浏览器输入如下 网址： <code>http://127.0.0.1/sales/customers/</code></p> 
<p>回车后，浏览器显示结果类似如下:</p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/f8/1b/V0Jy0WsI_o.png" width="754"></p> 
<p> 和我们数据库中的记录信息一致:</p> 
<p><img alt="" height="131" src="https://images2.imgbox.com/bd/33/nfo0kUDA_o.png" width="634"></p> 
<h4 id="%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6">过滤条件</h4> 
<p>有的我们需要根据过滤条件查询部分客户信息。</p> 
<p>比如，当用户在浏览器输入 <code>/sales/customers/?phonenumber=13000000001</code> ，要求返回电话号码为 13000000001 客户记录。</p> 
<p>我们可以通过 <code>filter</code> 方法加入过滤条件，修改view里面的代码，如下所示：</p> 
<pre><code class="language-python">def listcustomers(request):
    # 返回一个 QuerySet 对象 ，包含所有的表记录
    qs = Customer.objects.values()

    # 检查url中是否有参数phonenumber
    ph =  request.GET.get('phonenumber',None)

    # 如果有，添加过滤条件
    if ph:
        qs = qs.filter(phonenumber=ph)

    # 定义返回字符串
    retStr = ''
    for customer in  qs:
        for name,value in customer.items():
            retStr += f'{name} : {value} | '
        # &lt;br&gt; 表示换行
        retStr += '&lt;br&gt;'

    return HttpResponse(retStr)</code></pre> 
<p>Django框架在url路由匹配到函数后，调用函数时，会传入一个HttpRequest对象给参数变量request，该对象里面包含了请求的数据信息。</p> 
<p>HTTP的GET请求url里面的参数（术语叫querystring里面的参数），可以通过HttpRequest对象的GET属性获取，这是一个类似dict的对象。</p> 
<p>比如要获取querystring里面的phonenumber参数，就可以像这样：</p> 
<pre><code class="language-python">ph =  request.GET.get('phonenumber',None)</code></pre> 
<p>第二个参数传入None表示，如果没有phonenumber参数在querystring中，就会返回None</p> 
<p>然后调用QuerySet对象的filter方法，就可以把查询过滤条件加上去</p> 
<pre><code class="language-python">qs = qs.filter(phonenumber=ph)</code></pre> 
<p>有了这个过滤条件，Django 会在底层执行数据库查询的SQL语句 加上相应的 where 从句，进行过滤查询。注意，参数名 phonenumber 是和 定义的表 model 的属性名 phonenumber 一致的。</p> 
<p>filter的过滤条件可以有多个，只要继续在后面的参数添加过滤条件即可。</p> 
<h4 id="html">代码直接生成HTML</h4> 
<p>HTML本身其实也是字符串，只是这个字符串里面的内容是符合HTML语言规范的。</p> 
<p>既然它也是字符串，我们可以使用Python直接构建出 HTML 字符串内容。</p> 
<p>修改：</p> 
<pre><code class="language-python"># 先定义好HTML模板
html_template ='''
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;style&gt;
table {
    border-collapse: collapse;
}
th, td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}
&lt;/style&gt;
&lt;/head&gt;
    &lt;body&gt;
        &lt;table&gt;
        &lt;tr&gt;
        &lt;th&gt;id&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;电话号码&lt;/th&gt;
        &lt;th&gt;地址&lt;/th&gt;
        &lt;/tr&gt;

        %s


        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
'''

def listcustomers(request):
    # 返回一个 QuerySet 对象 ，包含所有的表记录
    qs = Customer.objects.values()

    # 检查url中是否有参数phonenumber
    ph =  request.GET.get('phonenumber',None)

    # 如果有，添加过滤条件
    if ph:
        qs = qs.filter(phonenumber=ph)

    # 生成html模板中要插入的html片段内容
    tableContent = ''
    for customer in  qs:
        tableContent += '&lt;tr&gt;'

        for name,value in customer.items():
            tableContent += f'&lt;td&gt;{value}&lt;/td&gt;'

        tableContent += '&lt;/tr&gt;'

    return HttpResponse(html_template%tableContent)</code></pre> 
<p>我们用一个变量 html_template 存储html模板，代码中生成html 里面需要插入的表格记录的内容，这个内容是html片段，也就是 html 表格的每行 。</p> 
<p>最后填入到 html_template 模板里面，就产生了完整的HTML 字符串。</p> 
<p>最后返回该 html 文档 字符串 即可。</p> 
<p>修改后，再次访问 http://127.0.0.1/sales/customers/</p> 
<p>得到如下内容：</p> 
<p> <img alt="" height="245" src="https://images2.imgbox.com/27/4e/ZSr6pw1L_o.png" width="591"></p> 
<h4 id="%C2%A0%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"> 使用模板</h4> 
<p>上面我们是用Python代码直接拼接出html内容。</p> 
<p>但是这种方式处理代码比较麻烦。特别是当html里面有多处内容需要填入时，使用Python代码直接拼接就显得很繁杂，不好维护。</p> 
<p>很多后端框架都提供了一种 模板技术， 可以在html 中嵌入编程语言代码片段， 用模板引擎（就是一个专门处理HTML模板的库）来动态的生成HTML代码。</p> 
<p>我们修改一下代码，使用Django的模板引擎：</p> 
<pre><code class="language-python"># 先定义好HTML模板
html_template ='''
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;style&gt;
table {
    border-collapse: collapse;
}
th, td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}
&lt;/style&gt;
&lt;/head&gt;
    &lt;body&gt;
        &lt;table&gt;
        &lt;tr&gt;
        &lt;th&gt;id&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;电话号码&lt;/th&gt;
        &lt;th&gt;地址&lt;/th&gt;
        &lt;/tr&gt;

        {% for customer in customers %}
            &lt;tr&gt;

            {% for name, value in customer.items %}            
                &lt;td&gt;{<!-- -->{ value }}&lt;/td&gt;            
            {% endfor %}

            &lt;/tr&gt;
        {% endfor %}

        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
'''

from django.template import engines
django_engine = engines['django']
template = django_engine.from_string(html_template)

def listcustomers(request):
    # 返回一个 QuerySet 对象 ，包含所有的表记录
    qs = Customer.objects.values()

    # 检查url中是否有参数phonenumber
    ph =  request.GET.get('phonenumber',None)

    # 如果有，添加过滤条件
    if ph:
        qs = qs.filter(phonenumber=ph)

    # 传入渲染模板需要的参数
    rendered = template.render({'customers':qs})

    return HttpResponse(rendered)</code></pre> 
<p>然后，访问浏览器，可以得到一样的结果。</p> 
<p>对比 Python直接产生 HTML，可以发现使用模板引擎的好处，就是产生HTML的代码更简单方便了。</p> 
<p>因为我们可以直接把要生成的 HTML片段 写在 HTML模板 里面。</p> 
<p>然后，只需要传入渲染模板所需要的参数就可以了，模板引擎会自动化帮我们生成HTML</p> 
<h4 id="%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84">前后端分离架构</h4> 
<p> 界面完全交给前端开发人员去做， 后端开发只需要提供前端界面所需要的数据即可。</p> 
<p>前端和后端之间的交互就完全是业务处理了，需要定义好前端和后端交互数据的接口</p> 
<p>目前通常这样的接口设计最普遍的就是使用REST风格的API接口。</p> 
<p>前端通过API接口从后端获取数据展示在界面上，也通过API接口告诉后端需要更新的数据是什么。</p> 
<p>通常前后端的API接口是由架构师设计的，有时也可以由经验丰富的前端开发者或者后端开发者设计。</p> 
<h4 id="%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%A4%84%E7%90%86">对资源的增删改查处理</h4> 
<p>前面我们已经为 <strong>销售员用户</strong> 专门创建了一个应用 sales 来处理相关的 请求，我们可以 再为 <strong>管理员用户</strong> 专门创建一个应用 mgr 来处理相关的 请求。</p> 
<p>执行以下命令：</p> 
<pre><code class="language-python">python manage.py startapp mgr</code></pre> 
<p>我们可以发现对资源的增删改查 操作， 都是<strong>同一个URL</strong>，都是 <code>/api/mgr/customers</code> 。</p> 
<p>而且我们发现，不同的操作请求，使用不同的 HTTP 请求方法 ，比如 <strong>添加是POST， 查询是 GET， 修改是 PUT， 删除是 DELETE</strong>。</p> 
<p>而且请求的参数中都有 action 参数表明这次请求的操作具体是什么。</p> 
<p><strong>注意：Django 的 url路由功能 不支持 根据 HTTP 请求的方法 和请求体里面的参数 进行路由</strong>。</p> 
<p>就是不能像下面这样，来根据请求 是 post 还是 get 来 路由：</p> 
<pre><code class="language-python">path('customers/', 'app.views.list_customer', method='get'),
path('customers/', 'app.views.add_customer',  method='post'),</code></pre> 
<p>有一种方式是：自己编写一个函数， 来 根据 http请求的类型 和请求体里面的参数 分发（或者说路由）给 不同的函数进行处理。</p> 
<p>我们可以 在 customer.py 中定义如下 dispatcher 函数：</p> 
<pre><code class="language-python">def dispatcher(request):
    # 将请求参数统一放入request 的 params 属性中，方便后续处理

    # GET请求 参数在url中，同过request 对象的 GET属性获取
    if request.method == 'GET':
        request.params = request.GET

    # POST/PUT/DELETE 请求 参数 从 request 对象的 body 属性中获取
    elif request.method in ['POST','PUT','DELETE']:
        # 根据接口，POST/PUT/DELETE 请求的消息体都是 json格式
        request.params = json.loads(request.body)


    # 根据不同的action分派给不同的函数进行处理
    action = request.params['action']
    if action == 'list_customer':
        return listcustomers(request)
    elif action == 'add_customer':
        return addcustomer(request)
    elif action == 'modify_customer':
        return modifycustomer(request)
    elif action == 'del_customer':
        return deletecustomer(request)

    else:
        return JsonResponse({'ret': 1, 'msg': '不支持该类型http请求'})</code></pre> 
<p>该函数 把 请求消息中的参数统一放入到 request请求对象的<strong>params </strong>属性中。</p> 
<p>params 属性 被 做成一个 <strong>dict </strong>类型 ， 方便后面的处理函数来获取消息中的参数。</p> 
<p>然后 dispatch函数再根据 请求的 类型 和 action 参数的值 决定由那个函数具体处理该请求消息。</p> 
<p>比如 action 参数 为 'add_customer' 的 请求 就由 addcustomer 函数 进行处理。</p> 
<p>当然在文件的开头，我们需要 先导入 JsonResponse 和 json 的定义，像下面这样：</p> 
<pre><code class="language-python">from django.http import JsonResponse
import json</code></pre> 
<p>接下来，根据 API 接口 ，我们发现 凡是 API 请求url为 <code>/api/mgr/customers</code> 的，都属于 客户 相关的API， 都应该交由 我们上面定义的dispatch函数进行分派处理。</p> 
<p>那么我们需要在Django的url路由文件中加入对应的路由</p> 
<p>第一步：我们应该在 总路由文件 <code>bysms/urls.py</code> 中定义了如下部分：</p> 
<pre><code class="language-python">    # 凡是 url 以 api/mgr  开头的，
    # 都根据 mgr.urls 里面的 子路由表进行路由
    path('api/mgr/', include('mgr.urls')),</code></pre> 
<p> 第二步： 在 mgr 目录下面添加 urls.py 路由文件， 并 加入如下声明即可， 如下所示：</p> 
<pre><code class="language-python">from django.urls import path

from mgr import customer

urlpatterns = [

    path('customers', customer.dispatcher),
]</code></pre> 
<p>这样，就表示 凡是 API 请求url为 <code>/api/mgr/customers</code> 的，都交由 我们上面定义的dispatch函数进行分派处理 。</p> 
<h5 id="%E5%88%97%E5%87%BA%E5%AE%A2%E6%88%B7">列出客户</h5> 
<p>根据接口文档，列出客户数据接口，后端返回的数据格式如下:</p> 
<pre><code class="language-python">{
    "ret": 0,
    "retlist": [
        {
            "address": "江苏省常州武进市白云街44号",
            "id": 1,
            "name": "武进市 袁腾飞",
            "phonenumber": "13886666666"
        },

        {
            "address": "北京海淀区",
            "id": 4,
            "name": "北京海淀区代理 蔡国庆",
            "phonenumber": "13990123456"
        }
    ]              
}</code></pre> 
<p>这里我们无需 将数据库中获取的数据 转化为 供浏览器展示的HTML。</p> 
<p>在前后端分离的开发架构中，如何展示数据是前端的事情。后端只需要根据接口文档， 返回原始数据即可。</p> 
<p>我们可以使用如下的函数来返回数据库的所有的 客户数据信息</p> 
<pre><code class="language-python">def listcustomers(request):
    # 返回一个 QuerySet 对象 ，包含所有的表记录
    qs = Customer.objects.values()

    # 将 QuerySet 对象 转化为 list 类型
    # 否则不能 被 转化为 JSON 字符串
    retlist = list(qs)

    return JsonResponse({'ret': 0, 'retlist': retlist})</code></pre> 
<p>当然在文件的开头，我们需要 先导入 Customer 定义，像下面这样：</p> 
<pre><code class="language-python"># 导入 Customer 
from common.models import Customer</code></pre> 
<h5 id="%C2%A0%E6%B7%BB%E5%8A%A0%E5%AE%A2%E6%88%B7"> 添加客户</h5> 
<p>根据接口文档，添加客户数据接口，前端提供的客户数据格式如：</p> 
<pre><code class="language-python">{
    "action":"add_customer",
    "data":{
        "name":"武汉市桥西医院",
        "phonenumber":"13345679934",
        "address":"武汉市桥西医院北路"
    }
}</code></pre> 
<p>我们可以使用如下的函数来处理：</p> 
<pre><code class="language-python">def addcustomer(request):

    info    = request.params['data']

    # 从请求消息中 获取要添加客户的信息
    # 并且插入到数据库中
    # 返回值 就是对应插入记录的对象 
    record = Customer.objects.create(name=info['name'] ,
                            phonenumber=info['phonenumber'] ,
                            address=info['address'])


    return JsonResponse({'ret': 0, 'id':record.id})</code></pre> 
<p><code>Customer.objects.create</code> 方法就可以添加一条Customer表里面的记录。 </p> 
<h5 id="%C2%A0%E4%B8%B4%E6%97%B6%E5%8F%96%E6%B6%88%20CSRF%20%E6%A0%A1%E9%AA%8C"> 临时取消 CSRF 校验</h5> 
<p>根据接口文档，添加客户 请求是个Post请求</p> 
<pre><code class="language-python">POST /网站名/api/mgr/signin  HTTP/1.1
Content-Type:   application/x-www-form-urlencoded</code></pre> 
<p>注意，新创建的项目， Django 缺省会启用一个 CSRF （跨站请求伪造） 安全防护机制。</p> 
<p>在这种情况下， 所有的Post、PUT 类型的 请求都必须在HTTP请求头中携带用于校验的数据。</p> 
<p>为了简单起见，我们先临时取消掉CSRF的 校验机制，等以后有需要再打开。</p> 
<p>要临时取消掉CSRF的 校验机制，非常简单，只需要在 项目的配置文件 <code>bysms/settings.py</code> 中 <code>MIDDLEWARE</code> 配置项 里 注释掉 'django.middleware.csrf.CsrfViewMiddleware' 即可。</p> 
<p>如下所示：</p> 
<pre><code class="language-python">MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]</code></pre> 
<h5 id="%E4%BF%AE%E6%94%B9%E5%AE%A2%E6%88%B7%E4%BF%A1%E6%81%AF">修改客户信息</h5> 
<p> 根据接口文档，修改客户数据接口，前端提供的数据格式如下:</p> 
<pre><code class="language-python">{
    "action":"modify_customer",
    "id": 6,
    "newdata":{
        "name":"武汉市桥北医院",
        "phonenumber":"13345678888",
        "address":"武汉市桥北医院北路"
    }
}</code></pre> 
<p>我们可以使用如下的函数来处理:</p> 
<pre><code class="language-python">def modifycustomer(request):

    # 从请求消息中 获取修改客户的信息
    # 找到该客户，并且进行修改操作

    customerid = request.params['id']
    newdata    = request.params['newdata']

    try:
        # 根据 id 从数据库中找到相应的客户记录
        customer = Customer.objects.get(id=customerid)
    except Customer.DoesNotExist:
        return  {
                'ret': 1,
                'msg': f'id 为`{customerid}`的客户不存在'
        }


    if 'name' in  newdata:
        customer.name = newdata['name']
    if 'phonenumber' in  newdata:
        customer.phonenumber = newdata['phonenumber']
    if 'address' in  newdata:
        customer.address = newdata['address']

    # 注意，一定要执行save才能将修改信息保存到数据库
    customer.save()

    return JsonResponse({'ret': 0})</code></pre> 
<h5 id="%C2%A0%E5%88%A0%E9%99%A4%E5%AE%A2%E6%88%B7"> 删除客户</h5> 
<p>根据接口文档，删除客户数据接口，前端只需要提供要删除的客户的ID。</p> 
<p>数据格式如下：</p> 
<pre><code class="language-python">{
    "action":"del_customer",
    "id": 6
}</code></pre> 
<p>我们可以使用如下的函数来处理：</p> 
<pre><code class="language-python">def deletecustomer(request):

    customerid = request.params['id']

    try:
        # 根据 id 从数据库中找到相应的客户记录
        customer = Customer.objects.get(id=customerid)
    except Customer.DoesNotExist:
        return  {
                'ret': 1,
                'msg': f'id 为`{customerid}`的客户不存在'
        }

    # delete 方法就将该记录从数据库中删除了
    customer.delete()

    return JsonResponse({'ret': 0})</code></pre> 
<p></p> 
<h4 id="Django%E4%B8%ADORM%E7%9A%84%E5%A4%84%E7%90%86">Django中ORM的处理</h4> 
<p>模型(Models):核心组件，一个模型类代表了一个数据库表，而类的属性则对应着表的字段</p> 
<p>字段(Fields):模型类的属性通常被称为字段，各种字段类型在定义模型类中的属性和数据库表中的字段</p> 
<p>查询集(QuerySets):数据库查询的方法，允许以链式方式构建复杂的查询，过滤、排序和限制结果集等操作</p> 
<p>关联(Relations):定义模型之间的关联关系，关系使得进行数据查询和操作变得更加容易</p> 
<p>迁移(Migrations):用于管理数据库模式的变化，更改模型定义时，可以使用迁移工具自动更新数据库表结构，而无需手动编写SQL语句</p> 
<h4 id="%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%85%8D%E7%BD%AE">数据模型的配置</h4> 
<h5 id="%E5%AD%97%E6%AE%B5%E8%AE%BE%E7%BD%AE">字段设置</h5> 
<p>AutoField:自增</p> 
<p>IntegerField:整数字段，用于存储整数值</p> 
<p>FloatField:浮点字段，存储小叔数值</p> 
<p>CharField:字符字段，用于存储字符串</p> 
<p>TextField:文本字段，用于存储长文本</p> 
<h5 id="%E5%AD%97%E6%AE%B5%E5%8F%82%E6%95%B0">字段参数</h5> 
<p>max_length:针对字符串或者长文本指定字段的最大长度</p> 
<p>default:指定字段的默认值</p> 
<p>null:设置字段是否允许为null</p> 
<p>db_column:设置列的别名</p> 
<p>on_delete:在外键设置中指定在关联的对象被删除时的处理方式</p> 
<p></p> 
<p><strong>models.py中的代码：</strong></p> 
<pre><code class="language-python">from django.db import models


# Create your models here.
# 学校信息
class School(models.Model):
    id = models.AutoField('记录编号', primary_key=True)  # 主键
    name = models.CharField('学校名称', max_length=32, null=False)
    address = models.CharField('学校地址', max_length=200)

    class Meta:
        db_table = 'father_school'  # 表名


# 校长信息
class Principal(models.Model):
    id = models.AutoField('记录编号', primary_key=True)  # 主键
    name = models.CharField('校长名称', max_length=20, null=False)
    school = models.OneToOneField(School, on_delete=models.CASCADE, db_column="school_id")

    class Meta:
        db_table = 'father_principal'  # 表名


# 院系信息
class Department(models.Model):
    id = models.AutoField('记录编号', primary_key=True)  # 主键
    name = models.CharField('院系名称', max_length=32, null=False)
    school = models.ForeignKey(School, on_delete=models.CASCADE, db_column="school_id")

    class Meta:
        db_table = 'father_department'  # 表名


# 授课教师
class Teacher(models.Model):
    id = models.AutoField('记录编号', primary_key=True)  # 主键
    name = models.CharField('教师名称', max_length=20, null=False)
    Department = models.ForeignKey(Department, on_delete=models.CASCADE, db_column="department_id")

    class Meta:
        db_table = 'father_teacher'  # 表名


# 学生信息
class Student(models.Model):
    id = models.AutoField('记录编号', primary_key=True)  # 主键
    name = models.CharField('学生名称', max_length=20, null=False)
    gender = models.CharField('学生性别', default='男', max_length=2, null=False)
    age = models.IntegerField('学生年龄', default=18, null=False)
    school = models.ForeignKey(School, on_delete=models.CASCADE, db_column="school_id")
    Teacher = models.ManyToManyField(Department, db_column="student_id")

    class Meta:
        db_table = 'father_student'  # 表名
</code></pre> 
<h4 id="%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">数据更新的实现</h4> 
<p>添加信息：</p> 
<p>insert into 表名(列名列表) values(值列表)</p> 
<p>修改信息：</p> 
<p>update 表名 set 列名=值... where 修改条件</p> 
<p>删除信息：</p> 
<p>delete from 表名 where 修改条件</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e41588d84a420f1ed6639abf09391f05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaDS —— AVL树</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6de5346f974bab7a5efd8b82c9578267/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里云&#43;DDNS-GO&#43;宝塔反向代理内网穿透后使用域名无端口访问内网保姆级教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>