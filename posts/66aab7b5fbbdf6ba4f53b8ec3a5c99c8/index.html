<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】：选择排序与快速排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/66aab7b5fbbdf6ba4f53b8ec3a5c99c8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构与算法】：选择排序与快速排序">
  <meta property="og:description" content="🔥个人主页： Quitecoder
🔥专栏：数据结构与算法
我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：腾讯云
欢迎来到排序的第二个部分：选择排序与快速排序！
目录 1.选择排序1.1复杂度分析 2.快速排序的层层实现2.1分区操作2.2相遇位置小于枢轴元素2.3递归实现整个函数2.4复杂度分析2.5 代码优化：三数取中法选key2.6挖坑法实现快排2.7前后指针实现快排 1.选择排序 选择排序是一种简单直观的比较排序算法。该算法的基本思想是在每一轮中选出当前未排序部分的最小（或最大）元素，然后将其放置到未排序序列的起始位置，这个过程一直重复直至整个数组被排序。
选择排序的具体步骤如下：
从数组的当前未排序部分选择最小（或最大）的一个元素将这个最小（或最大）元素与未排序序列的第一个元素交换位置然后从剩余未排序的元素中继续这个过程，将每一次找到的最小（或最大）元素放到未排序序列的开始这个过程一直进行到整个数组的所有元素都被排为有序状态 在这里我们可以遍历一次同时找到最小元素和最大元素，对应放到相应的位置，
基本代码如下：
void SelectSort(int* a, int n) { int begin = 0; int end = n - 1; while (begin &lt; end) { int minn = begin; int maxn = begin; for (int i = begin &#43; 1; i &lt;= end; i&#43;&#43;) { if (a[i] &lt; a[minn]) { minn = i; } if (a[i] &gt; a[maxn]) { maxn = i; } } Swap(&amp;a[begin], &amp;a[minn]); Swap(&amp;a[end], &amp;a[maxn]); begin&#43;&#43;; end--; } } 首先初始化两个索引begin和end，分别代表当前未排序序列的开始和结束位置进入一个循环，条件是begin &lt; end，确保在数组中还有未排序的元素遍历一遍序列，找到最大元素和最小元素的下标将最小元素与序列的始端交换，最大元素与序列的尾端交换更新begin与end Swap函数如下：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-20T00:09:46+08:00">
    <meta property="article:modified_time" content="2024-03-20T00:09:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】：选择排序与快速排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/54/a5/ssOjMYuu_o.png" alt="Alt" width="300" height="170"></p> 
<p>🔥<font color="peru" size="4"><b>个人主页</b></font>： <a href="https://blog.csdn.net/arf_dog?type=blog">Quitecoder</a></p> 
<p>🔥<font color="peru" size="4"><strong>专栏</strong></font>：<a href="https://blog.csdn.net/arf_dog/category_12582256.html?spm=1001.2014.3001.5482">数据结构与算法</a></p> 
<p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1dc1q5dxuto6q" rel="nofollow">腾讯云</a></p> 
<blockquote> 
 <p>欢迎来到排序的第二个部分：选择排序与快速排序！</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4c/80/khHyOD8B_o.gif" alt="Alt" width="400" height="400"></p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li>1.选择排序</li><li><ul><li>1.1复杂度分析</li></ul> 
  </li><li>2.快速排序的层层实现</li><li><ul><li>2.1分区操作</li><li>2.2相遇位置小于枢轴元素</li><li>2.3递归实现整个函数</li><li>2.4复杂度分析</li><li>2.5 代码优化：三数取中法选key</li><li>2.6挖坑法实现快排</li><li>2.7前后指针实现快排</li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_19"></a>1.选择排序</h2> 
<blockquote> 
 <p>选择排序是一种简单直观的比较排序算法。该算法的基本思想是在每一轮中选出当前未排序部分的最小（或最大）元素，然后将其放置到未排序序列的起始位置，这个过程一直重复直至整个数组被排序。</p> 
</blockquote> 
<p>选择排序的具体步骤如下：</p> 
<ol><li>从数组的当前未排序部分选择最小（或最大）的一个元素</li><li>将这个最小（或最大）元素与未排序序列的第一个元素交换位置</li><li>然后从剩余未排序的元素中继续这个过程，将每一次找到的最小（或最大）元素放到未排序序列的开始</li><li>这个过程<strong>一直进行到整个数组的所有元素都被排为有序状态</strong></li></ol> 
<p><img src="https://images2.imgbox.com/0e/d1/hao1Vua2_o.gif" alt="Alt"></p> 
<p>在这里我们可以遍历一次同时找到最小元素和最大元素，对应放到相应的位置，<br> 基本代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> minn <span class="token operator">=</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">int</span> maxn <span class="token operator">=</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>minn<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				minn <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				maxn <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>minn<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		begin<span class="token operator">++</span><span class="token punctuation">;</span>
		end<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol><li>首先初始化两个索引<code>begin</code>和<code>end</code>，分别代表当前未排序序列的<strong>开始和结束位置</strong></li><li>进入一个循环，条件是<code>begin &lt; end</code>，确保在数组中还有未排序的元素</li><li>遍历一遍序列，<strong>找到最大元素和最小元素的下标</strong></li><li>将最小元素与序列的始端交换，最大元素与序列的尾端交换</li><li><strong>更新begin与end</strong></li></ol> 
<p>Swap函数如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
	<span class="token operator">*</span>b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>思考一下，这里我是首先进行最小元素与首位置更换，再进行最大元素与末尾更换，那如果我的最大元素就在首位置呢？</strong></p> 
</blockquote> 
<p>我们进行解释：<br> <img src="https://images2.imgbox.com/68/7d/w9GJcedt_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d47bb63a88954782a583335c0056"><br> 6f71.png)<br> 在这组数组</p> 
<ol><li><strong>我们首先找到0的下标8</strong></li><li><strong>再找到9的下标0</strong></li><li><strong>下标8与begin（0）交换</strong></li><li><strong>下标0与end交换</strong></li></ol> 
<p><img src="https://images2.imgbox.com/22/19/vuUzaCQI_o.png" alt="在这里插入图片描述"></p> 
<p>这里由于最大元素9在起始位置，所以第一次交换后，9的索引不在是0，我们需要更新索引：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> minn <span class="token operator">=</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">int</span> maxn <span class="token operator">=</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>minn<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				minn <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				maxn <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>minn<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>maxn <span class="token operator">==</span> begin<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			maxn <span class="token operator">=</span> minn<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		begin<span class="token operator">++</span><span class="token punctuation">;</span>
		end<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>maxn <span class="token operator">==</span> begin<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			maxn <span class="token operator">=</span> minn<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>改变最大值的索引，再进行交换，这就是选择排序的完整过程</p> 
<h3><a id="11_139"></a>1.1复杂度分析</h3> 
<p><font size="4"><strong>时间复杂度</strong></font></p> 
<p>最好、平均、最坏情况下的时间复杂度都是 O(n^2)<br> 原因在于，不管数组的初始顺序如何，<strong>选择排序都需要比较所有未排序的元素来找到最小（或最大）的元素，并执行这个过程 n-1 次（对于 n 个元素的数组）。每次选择操作需要比较的次数从 n-1 次减少到 1 次，总共的比较次数是 (n-1) + (n-2) + … + 1 = n(n-1)/2，这是一个二次函数，因此时间复杂度为 O(n<sup>2</sup>)</strong></p> 
<p><font size="4"><strong>空间复杂度</strong></font></p> 
<p>选择排序是一种原地排序算法，除了输入数组外，它只需要有限的几个变量（比如，用于存储最小元素下标的变量和循环计数器）。因此，它的空间复杂度为常数空间，<strong>O(1)</strong></p> 
<p><font size="4"><strong>其他特点</strong></font></p> 
<p>选择排序是<strong>不稳定的排序算法</strong>，因为它会因为选择最小（或最大）元素的过程中交换距离较远的元素，从而可能改变相同元素的原始顺序</p> 
<h2><a id="2_153"></a>2.快速排序的层层实现</h2> 
<blockquote> 
 <p>快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：<strong>任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</strong></p> 
</blockquote> 
<p>快速排序是一种高效的排序算法，**采用了分治法（Divide and Conquer）**的策略。它的基本思路可以概括为以下几个步骤：</p> 
<ol><li> <p>选择<mark>枢轴（Pivot）</mark>： 快速排序首先从数组中选择一个元素作为枢轴，枢轴的选择可以有多种方式，比如总是选择第一个元素、最后一个元素、中间的元素，或者采用更复杂的策略如三数中值法</p> </li><li> <p>分区（Partitioning）： 一旦枢轴被选择，数组会被重新排列，<mark>所有比枢轴小的元素移动到枢轴的左边，所有比枢轴大的元素移动到右边</mark>。这个过程结束时，<strong>枢轴元素处于其最终排序后的正确位置</strong>。</p> </li><li> <p>递归排序： 接下来，快速排序算法<strong>递归地将左边和右边的子数组进行排序。递归的基准条件是子数组的大小为0或1，这意味着它们已经被排序了</strong></p> </li></ol> 
<p>我们不妨举个例子</p> 
<p>假设我们有以下数组：</p> 
<pre><code>[3, 6, 8, 10, 1, 2, 4]
</code></pre> 
<p>我们将用快速排序来对这个数组进行排序。为了简单起见，我们选择数组的<strong>第一个元素作为枢轴</strong>。实际应用中可能会使用更复杂的选择方法，如随机选择或三数中值法，以避免最坏情况的性能下降。现在，让我们开始排序：</p> 
<ol><li> <p><strong>初始数组</strong>:</p> <pre><code>[3, 6, 8, 10, 1, 2, 4]
</code></pre> <p><strong>枢轴是 3。</strong></p> </li><li> <p><strong>分区操作</strong>:<br> 将数组中小于3的元素移动到左边，大于3的元素移动到右边。这一步结束后，枢轴3位于其最终位置。</p> <pre><code>[2, 1, 3, 10, 8, 6, 4]
</code></pre> <p>此时，3位于索引2，是其最终位置。</p> </li><li> <p><strong>递归排序左边</strong> <code>[2, 1]</code> 和右边 <code>[10, 8, 6, 4]</code> 的子数组。</p> 
  <ul><li>对于左边的 <code>[2, 1]</code>，选择2作为枢轴。 
    <ul><li><strong>分区操作</strong>后，得到 <code>[1, 2]</code>。</li></ul> </li><li>对于右边的 <code>[10, 8, 6, 4]</code>，选择10作为枢轴。 
    <ul><li>分区操作后，得到 <code>[4, 8, 6, 10]</code>。</li></ul> </li></ul> </li><li> <p>现在，对 <code>[4, 8, 6]</code> 进行快速排序。</p> 
  <ul><li>选择4作为枢轴。</li><li>分区操作后，得到 <code>[4, 8, 6]</code>。</li></ul> </li><li> <p>最后，对 <code>[8, 6]</code> 进行快速排序。</p> 
  <ul><li>选择8作为枢轴。</li><li>分区操作后，得到 <code>[6, 8]</code>。</li></ul> </li></ol> 
<p>合并所有排好序的部分，最终排序结果是：</p> 
<pre><code>[1, 2, 3, 4, 6, 8, 10]
</code></pre> 
<p>每次<strong>分区操作</strong>都确保枢轴元素被放置在其最终位置。通过递归地处理枢轴左侧和右侧的子数组，最终整个数组变得有序</p> 
<h3><a id="21_212"></a>2.1分区操作</h3> 
<p>分区操作是快速排序算法中的核心步骤。它的目标是根据枢轴元素重新排列数组的部分区间，<strong>使得所有比枢轴小的元素都移到它的左边，而所有比枢轴大的元素都移到它的右边。在这个过程中，枢轴元素自身也找到了其在数组中的正确位置</strong>。这个步骤是递归进行排序的前提。下面详细解释这个过程：</p> 
<ol><li> <p>设置指针：<br> 设置两个指针，<strong>left指向数组的开始（或枢轴的下一个元素，取决于枢轴的选择），right指向数组的末尾</strong>。</p> </li><li> <p>指针移动和交换：<br> 向右移动left指针：从left开始向右移动，<strong>直到找到一个大于或等于枢轴值的元素</strong>，向左移动right指针：从right开始向左移动，<strong>直到找到一个小于或等于枢轴值的元素</strong></p> </li><li> <p>检查和交换：如果left指针仍在right指针的左侧（即left &lt; right），则交换left和right指向的元素，并继续移动指针。</p> </li><li> <p>递归的终止条件：<br> 当left指针超过right指针，即left &gt;= right时，分区操作结束。此时，所有比枢轴小的元素都在它的左边，而所有比枢轴大的元素都在它的右边</p> </li></ol> 
<p><strong>单趟排序代码实现如下</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">;</span>
<span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
<span class="token keyword">int</span> key <span class="token operator">=</span> begin<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		right<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		left<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
key <span class="token operator">=</span> left<span class="token punctuation">;</span>
</code></pre> 
<ol><li> <p><strong>初始化指针和枢轴</strong>：</p> 
  <ul><li><code>left</code>初始化为<code>begin</code>，这是当前考虑的数组段的起始位置</li><li><code>right</code>初始化为<code>end</code>，这是当前考虑的数组段的结束位置</li><li><code>key</code>用于记录枢轴的位置，这里选择的是数组段的第一个元素作为枢轴，因此<code>key</code>初始化为<code>begin</code></li></ul> </li><li> <p><strong>分区过程</strong>：</p> 
  <ul><li> <p><strong>外层循环</strong>：<code>while (left &lt; right)</code>确保当左右指针相遇或交错时，循环停止。这意味着分区过程完成。</p> </li><li> <p><strong>右侧扫描</strong>：第一个内层循环<code>while (left &lt; right &amp;&amp; a[right] &gt;= a[key])</code>从右向左移动<code>right</code>指针，寻找第一个小于枢轴值<code>a[key]</code>的元素。</p> </li><li> <p><strong>左侧扫描</strong>：第二个内层循环<code>while (left &lt; right &amp;&amp; a[left] &lt;= a[key])</code>从左向右移动<code>left</code>指针，寻找第一个大于枢轴值<code>a[key]</code>的元素。</p> </li><li> <p><strong>交换</strong>：<code>Swap(&amp;a[right], &amp;a[left])</code>交换左右指针所指向的元素。<strong>这次交换是为了把小于枢轴值的元素移动到枢轴的左侧，大于枢轴值的元素移动到枢轴的右侧</strong></p> </li></ul> </li><li> <p><strong>枢轴归位</strong>：</p> 
  <ul><li>循环结束时，<code>left</code>和<code>right</code>指针相遇。此时，<mark>left指针的位置就是枢轴元素应该所在的最终位置。</mark>（这里下面再做解释）</li><li><code>Swap(&amp;a[left], &amp;a[key])</code>交换枢轴元素与<code>left</code>指针所指的元素。<strong>这步确保了枢轴元素被放置在其正确的位置，即所有左侧元素都不大于它，所有右侧元素都不小于它</strong></li><li>最后，将<code>key</code>更新为<code>left</code>，尽管在这个代码片段中，这个赋值操作对于后续流程并不是必需的，因为<code>key</code>的值在这之后没有再被使用。如果这是分区函数的一部分，<code>key</code>（或者这里应该是<code>left</code>）的新值可能会被用来指示下一步递归操作的分界点。</li></ul> </li></ol> 
<h3><a id="22_267"></a>2.2相遇位置小于枢轴元素</h3> 
<p>这里我们就可以分多种情况进行讨论：</p> 
<ul><li><strong>right遇到left</strong>：注意，代码中我们是先让right移动的，<mark>意味着left所指向的是上一此交换后小于枢轴元素的数</mark>，所以当相遇后，key与left交换，left指向的元素一定小于key指向的元素</li><li><strong>left遇到right</strong>：由于right先动，意味着right已经找到了一个比key小的元素，当left遇到right使，此时right，left指向的元素一定小于key指向的元素。</li></ul> 
<h3><a id="23_274"></a>2.3递归实现整个函数</h3> 
<blockquote> 
 <p><strong>一旦枢轴元素被放置在其正确位置上，数组就被分成了两部分。左边的子数组包含了所有小于枢轴的元素，而右边的子数组包含了所有大于枢轴的元素。这时，独立地对左右两个子数组应用同样的快速排序过程。这就是递归的步骤，因为同一个过程被用来排序较小的数组</strong></p> 
</blockquote> 
<p>递归终止条件：<strong>递归的终止条件是子数组的大小减到0或1</strong>，这时不需要做任何操作：</p> 
<ul><li> <p>大小为0的子数组意味着在分区过程中，<strong>没有元素被划分到某一侧</strong>。例如，如果枢轴是最小（或最大）元素，并且所有其他元素都被划分到了枢轴的另一侧，那么这一侧实际上就没有元素，子数组的长度为0</p> </li><li> <p>大小为1的子数组意味着在分区过程结束后，<strong>某一侧只有一个元素</strong>。由于任何单一元素的集合自然是已排序的（因为没有其他元素可以与之比较大小），这意味着不需要对这样的子数组进行进一步的排序操作</p> </li></ul> 
<p>代码实现如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Quicksort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	key <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token function">Quicksort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> key <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Quicksort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> key <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p>递归的终止条件：<code>if (begin &gt;= end)</code>检查当前的子数组是否已经是不可分割的，即<strong>长度为0或1</strong>。如果满足这个条件，函数就会直接返回，不再继续执行后续的排序操作</p> </li><li> <p>初始化变量：变量left和right被初始化为子数组的起始和结束索引。变量key作为枢轴的索引也被初始化为begin，即子数组的第一个元素</p> </li></ul> 
<h3><a id="24_319"></a>2.4复杂度分析</h3> 
<blockquote> 
 <p><strong>每一层的时间复杂度：每一层的时间复杂度在快速排序中的推导基于对数组的分区操作。对于一个包含(n)个元素的数组，分区操作的时间复杂度是(O(n))。这是因为在分区过程中，每个元素都会被检查一次以确定它们是应该放在枢轴的左边还是右边。</strong></p> 
</blockquote> 
<p>最好情况、平均情况和最坏情况：</p> 
<ol><li> <p><strong>最好情况</strong>：<strong>当每次分区操作都能将数组均等分成两部分</strong>，快速排序的性能接近其理论最优。这种情况下，递归树的深度是 log n ，其中每一层的处理时间总和是( O(n) )）。因此，最好情况下的时间复杂度是( <strong>O(n log n)</strong> )。</p> </li><li> <p><strong>平均情况</strong>：在随机选择的数组中，快速排序的平均时间复杂度也是( O(n \log n) )。虽然每次分区可能不会完全平等，但平均而言，递归树的深度依然保持在( \log n )的数量级，每一层的处理时间总和为( O(n) )</p> </li><li> <p><mark>最坏情况</mark>：最坏情况发生在每次分区操作时，都将数组分成大小极度不平衡的两部分，如一个元素和其余元素，<mark>即在有序的情况下</mark>。这种情况下，递归树的深度增长到( n )，每次分区操作依然需要( O(n) )的时间，因此最坏情况下的时间复杂度是( O(n^2) )</p> </li></ol> 
<p><img src="https://images2.imgbox.com/99/a3/RYjWxDeA_o.png" alt="在这里插入图片描述"></p> 
<p><strong>空间复杂度</strong>：快速排序的空间复杂度主要由递归调用栈的深度决定。在最好情况下，递归树的深度是( log n )，因此空间复杂度是( O(log n) )。在最坏情况下，递归树的深度可以达到( n )，此时空间复杂度为( O(n) )。这是因为每一层递归调用都需要一定的空间，而递归树的深度直接影响调用栈的大小</p> 
<h3><a id="25_key_336"></a>2.5 代码优化：三数取中法选key</h3> 
<p>三数取中法是在实现快速排序时用来提高性能并降低遇到最坏情况概率的一种技术。该方法通过选择一个较为接近中值的枢轴元素来分区数组，<strong>以避免每次都产生不平衡的分区，从而增加算法的效率</strong></p> 
<p>在三数取中法中，我们通常取数组中以下三个值：</p> 
<ol><li><strong>起始值</strong>（通常是数组的第一个元素）</li><li><strong>结束值</strong>（通常是数组的最后一个元素）</li><li><strong>中间值</strong>（数组中间位置的元素，可以通过<code>(begin + end) / 2</code>计算得出）</li></ol> 
<p>然后，比较这三个元素的大小，并选择处于中间大小的元素作为枢轴元素。<strong>这样做的目的是尽量避免选择最小或最大的元素作为枢轴</strong>，因为这会产生不平衡的分区。这个选取枢轴的过程实际上是一个非常简单的大小比较和交换操作</p> 
<p>三数取中法选取<code>key</code>的具体实现可能如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">Getmidi</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> midi <span class="token operator">=</span> <span class="token punctuation">(</span>begin <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>midi<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>midi<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> midi<span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token keyword">return</span> end<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>midi<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> midi<span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> end<span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token keyword">return</span> begin<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Quicksort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> midi <span class="token operator">=</span> <span class="token function">Getmidi</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>midi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&gt;=</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	key <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token function">Quicksort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> key <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Quicksort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> key<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>函数<code>Getmidi</code>尝试从数组的<code>begin</code>、<code>end</code>和<code>midi</code>（中间）位置选取一个"中间值"（不是数值上的中位数，而是在三个数中大小排在中间的数）。然后，<code>Quicksort1</code>函数利用三数取中的方法来选择枢轴元素(<code>key</code>)并执行快速排序过程。</p> 
<p><strong>Getmidi 函数详解</strong>：</p> 
<p><code>Getmidi</code>函数通过比较三个位置（起始位置、中间位置和结束位置）的元素大小来返回中间值的索引。这里的中间值是指这三个元素中不是最大也不是最小的那个。判断条件覆盖了所有可能的大小顺序，来确保正确选取中间值。</p> 
<p><strong>Quicksort1 函数详解</strong>：</p> 
<ol><li> <p><code>Quicksort1</code>首先检查递归调用的终止条件<code>if (begin &gt;= end)</code>。当当前子数组长度为0或1时，函数返回</p> </li><li> <p>接下来，函数调用<code>Getmidi</code>来获取中间值的索引并将该位置的元素与起始位置的元素交换，这样枢轴（pivot）选取<strong>就是三数取中法选出的元素</strong></p> </li><li> <p><code>left</code>和<code>right</code>分别初始化为子数组的起始和结束索引，此时始终将<code>begin</code>位置的元素视为枢轴元素</p> </li><li> <p>剩余部分执行的是典型的快速排序分区操作，此时<code>key</code>是枢轴索引，最后将枢轴位置的元素放到正确位置上</p> </li><li> <p>在分区完成后，枢轴左侧和右侧的子数组通过递归调用<code>Quicksort1</code>函数来进行排序</p> </li></ol> 
<p>在进行这些更改后，<code>Quicksort1</code>函数应该能够正确地使用三数取中法对数组进行排序，通常能够避免最坏情况的(O(n^2))时间复杂度，同时保持期望的平均时间复杂度(O(n log n))<br> <img src="https://images2.imgbox.com/64/55/RS27DnSh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="26_426"></a>2.6挖坑法实现快排</h3> 
<p><strong>挖坑法是实现快速排序的一种方法，它简化了元素交换的步骤，通过"挖坑填数"来完成元素的位置调整。这个方法的基本思想是选定一个枢轴值（pivot），然后将小于枢轴值的元素移动到枢轴的左边，将大于枢轴值的元素移动到枢轴的右边，最终将枢轴值放入正确的位置</strong>。下面是使用挖坑法实现快速排序的示例代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSortHole</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 递归结束条件</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 选取第一个元素作为枢轴</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 从右向左找到第一个小于枢轴的元素，填入左边的坑</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 将找到的较小元素填到左边的坑里，此时右边形成一个新的坑</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>

	
	arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
	<span class="token function">QuickSortHole</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickSortHole</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>先将第一个数据存放在临时变量key中形成一个坑位</strong></p> 
<p>让我们通过一个具体的例子来解释挖坑法如何在快速排序中工作。假设我们有以下数组：</p> 
<pre><code>[6, 1, 2, 7, 9, 3, 4, 5, 10, 8]
</code></pre> 
<p>我们要对这个数组进行快速排序。选择第一个元素作为枢轴值（pivot），这里是<code>6</code>。我们现在开始挖坑法的过程：</p> 
<ol><li> <p><strong>初始化</strong>：枢轴值为<code>6</code>，因此数组的第一个位置成了一个“坑”，我们用这个“坑”来存放接下来找到的符合条件的元素。此时数组状态和指针位置如下：</p> <pre><code>[6*, 1, 2, 7, 9, 3, 4, 5, 10, 8]  // *表示坑位
left                            right
</code></pre> </li><li> <p><strong>从右向左扫描</strong>：找到第一个小于<code>6</code>的元素，这里是<code>5</code>。我们将<code>5</code>放入左边的“坑”中，并将<code>5</code>的位置变成新的“坑”。数组现在看起来是这样：</p> <pre><code>[5, 1, 2, 7, 9, 3, 4, 6*, 10, 8]  // 将5移动到左边的坑位，6的位置成为新的坑位
     left                     right
</code></pre> </li><li> <p><strong>从左向右扫描</strong>：找到第一个大于<code>6</code>的元素，这里是<code>7</code>。我们将<code>7</code>放入右边的“坑”中，并将<code>7</code>的位置变成新的“坑”。数组更新为：</p> <pre><code>[5, 1, 2, 6*, 9, 3, 4, 7, 10, 8]  // 将7移动到右边的坑位，6的位置再次成为新的坑位
        left              right
</code></pre> </li><li> <p><strong>重复这个过程</strong>，直到<code>left</code>和<code>right</code>指针相遇。在这个例子中，当两个指针相遇时，我们发现它们都指向了索引<code>3</code>的位置（现在是一个“坑”），这个位置正是枢轴值<code>6</code>最终应该放置的位置。所以，我们把枢轴值放回这个“坑”里。数组现在是：</p> <pre><code>[5, 1, 2, 6, 9, 3, 4, 7, 10, 8]
</code></pre> </li><li> <p>此时，枢轴值<code>6</code>已经放到了它最终的位置上，所有在它左边的元素都比它小，所有在它右边的元素都比它大。现在，我们对<code>6</code>左边和右边的子数组递归执行相同的排序过程。</p> </li></ol> 
<p><mark>这种方法减少了元素的直接交换，通过移动“坑”位置来调整元素的位置</mark></p> 
<p>当然我们也可以继续使用三数取中法选key对代码再次优化：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSortHole</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> midi <span class="token operator">=</span> <span class="token function">Getmidi</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>midi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span> 
	<span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span> 
	<span class="token function">QuickSortHole</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickSortHole</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="27_530"></a>2.7前后指针实现快排</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">Getmidi</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>  
	<span class="token keyword">int</span> cur <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     
	<span class="token keyword">int</span> pre <span class="token operator">=</span> begin<span class="token punctuation">;</span>        

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> cur <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token operator">++</span>pre<span class="token punctuation">;</span>  
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickSort3</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> pre <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickSort3</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pre <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>设置指针</strong></p> 
<ul><li>设置两个指针<code>cur</code>（当前指针）和<code>pre</code>（前指针）。<code>cur</code>从枢轴元素的下一个位置开始，即<code>begin + 1</code>，而<code>pre</code>从枢轴元素的位置开始，即<code>begin</code>。这样设置是为了准备遍历数组进行分区。</li></ul> 
<p><strong>遍历与交换</strong></p> 
<ul><li>遍历数组从<code>cur</code>到<code>end</code>的所有元素。对于每个元素，比较其与枢轴元素的大小： 
  <ul><li>如果当前<code>cur</code>指向的元素小于枢轴元素，则表示这个元素应该位于枢轴的左侧。</li><li>为了将其移动到正确位置，首先将<code>pre</code>指针向右移动一个位置（即<code>++pre</code>），然后交换<code>pre</code>和<code>cur</code>指向的元素的位置。这一步确保了<code>pre</code>左侧的所有元素（包括<code>pre</code>指向的元素）都不大于枢轴元素。</li></ul> </li></ul> 
<p><strong>枢轴归位</strong></p> 
<ul><li>遍历结束后，<code>pre</code>指向的是最后一个小于枢轴的元素的位置。由于初始时枢轴元素被置于数组的起始位置（即<code>begin</code>），现在需要将枢轴元素与<code>pre</code>指向的元素进行交换。</li><li>这样做的结果是，枢轴元素被放置到了其最终的正确位置上。至此，枢轴元素的左侧都是不大于它的元素，右侧都是不小于它的元素。</li></ul> 
<p>让我们通过一个具体的例子来演示快速排序的分区过程，假设我们有以下数组：</p> 
<pre><code>arr = [3, 6, 8, 10, 1, 2, 1]
</code></pre> 
<p>我们选择数组的第一个元素作为枢轴（pivot），即<code>3</code>。</p> 
<ol><li> <p>枢轴选择<br> 这一步已经完成，枢轴<code>3</code>已经在数组的起始位置。</p> </li><li> <p>设置指针<br> 设置两个指针<code>cur</code>和<code>pre</code>。初始时，<code>cur = begin + 1 = 1</code>，<code>pre = begin = 0</code>。</p> </li><li> <p>遍历与交换<br> 我们开始遍历数组，从索引<code>1</code>到数组的结束，比较每个元素与枢轴<code>3</code>的大小。</p> </li></ol> 
<ul><li><code>cur = 1</code>, <code>arr[cur] = 6</code>，因为<code>6 &gt; 3</code>，<code>pre</code>和<code>cur</code>都不动。</li><li><code>cur = 2</code>, <code>arr[cur] = 8</code>，因为<code>8 &gt; 3</code>，<code>pre</code>和<code>cur</code>都不动。</li><li><code>cur = 3</code>, <code>arr[cur] = 10</code>，同样，<code>10 &gt; 3</code>，<code>pre</code>和<code>cur</code>都不动。</li><li><code>cur = 4</code>, <code>arr[cur] = 1</code>，因为<code>1 &lt; 3</code>，此时<code>pre</code>向右移动一位变为<code>1</code>，然后交换<code>arr[pre]</code>和<code>arr[cur]</code>，即<code>6</code>和<code>1</code>交换位置。现在数组变为<code>[3, 1, 8, 10, 6, 2, 1]</code>。</li><li><code>cur = 5</code>, <code>arr[cur] = 2</code>，因为<code>2 &lt; 3</code>，<code>pre</code>再次向右移动一位变为<code>2</code>，然后交换<code>arr[pre]</code>和<code>arr[cur]</code>，即<code>8</code>和<code>2</code>交换。数组变为<code>[3, 1, 2, 10, 6, 8, 1]</code>。</li><li><code>cur = 6</code>, <code>arr[cur] = 1</code>，同样，<code>1 &lt; 3</code>，<code>pre</code>移动到<code>3</code>，然后<code>10</code>和<code>1</code>交换。数组现在看起来是<code>[3, 1, 2, 1, 6, 8, 10]</code>。</li></ul> 
<ol start="4"><li> <p>枢轴归位<br> 遍历完成后，<code>pre = 3</code>，指向最后一个小于<code>3</code>的元素。现在，我们将枢轴元素<code>3</code>与<code>pre</code>所在位置的元素<code>1</code>交换。交换后的数组是<code>[1, 1, 2, 3, 6, 8, 10]</code>。</p> </li><li> <p>递归分区<br> 现在，枢轴<code>3</code>已经处于其正确的位置，我们对枢轴左侧的<code>[1, 1, 2]</code>和右侧的<code>[6, 8, 10]</code>分别递归执行上述步骤，直到子数组长度为<code>1</code>或者为空，这意味着整个数组已经排序完成。</p> </li></ol> 
<p>本节内容到此结束，感谢大家阅读！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac3ae1619348f99a9979cf0153ee27eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">国产大模型最近挺猛啊！使用Dify构建企业级GPTs；AI阅读不只是「总结全文」；我的Agent自媒体团队；官方AI绘画课完结啦！ | ShowMeAI日报</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/041a8044a3ea29760a587c66a867d749/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 实现字符串String转换成json</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>