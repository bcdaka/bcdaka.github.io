<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;----内存管理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a1c61aa62af001b9232c8af3d0eafc62/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c&#43;&#43;----内存管理">
  <meta property="og:description" content="okk，大家好。我们大家学习了鄙人的前面前面几篇博客，并且还稍微使用了一些c&#43;&#43;的基础知识。并且我们前面都说过，我们前面学习的知识都说过。我们前面的几篇博客都是我们以后使用c&#43;&#43;基础。但是我们大家都知道现在代码都关注什么时间啊，内存啊。我们前面对于c&#43;&#43;的时间，我们可以依据以前c的知识。我们前面说过时间复杂度嘛，就是计算基本算法的次数。这个在哪都可以通用。但是我们c&#43;&#43;的内存管理却稍微有一点不同。比我们c讲的更加细致且深奥。哈哈。可能说的有点夸张了。但是我们已经引出了我们今天要讲的主题。内存管理了。
内存分布 大家应该还记得我们以前c学习的内存的内部吧。当时我们说c内存的时候就说了个栈区，堆区，静态区。然后就是这三个去分别存放临时变量，创建是数据和全局变量。
我们前面刚刚说过我们的c&#43;&#43;内存是要复杂一些。我们c&#43;&#43;的内存分布
大家可以看看上面的图片，我们可以看到我们对于内存的分布多了很多。除了我们在c中就见过的堆，栈，静态区以外。我们还写了一个明显的叫做：内存映射段。这个大家对这个应该很陌生吧。什么叫做内存映射段，起什么作用啊。
mmap是一种内存映射的方法，这一功能可以用在文件的处理上，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。在编程时可以使某个磁盘文件的内容看起来像是内存中的一个数组。如果文件由记录组成，而这些记录又能够用结构体来描述的话，可以通过访问结构数组来更新文件的内容。
实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如图所示：
进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。
内核为系统中的每个进程维护一个单独的任务结构（task_struct）。任务结构中的元素包含或者指向内核运行该进程所需的所有信息(PID、指向用户栈的指针、可执行目标文件的名字、程序计数器等)。Linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问。
反正这里是给大家稍微简绍一下。这个后面大家对知识有更多的了解之后，自然会学习更多的。这里我们就稍微给大家说明一下，大家有个了解：
1.栈 又叫堆栈 -- 非静态局部变量 / 函数参数 / 返回值等等，栈是向下增长的。 2. 内存映射段 是高效的 I/O 映射方式，用于装载一个共享的动态内存库。用户可使用系统接口 创建共享共享内存，做进程间通信。（ Linux 课程如果没学到这块，现在只需要了解一下） 3. 堆 用于程序运行时动态内存分配，堆是可以上增长的。 4. 数据段 -- 存储全局数据和静态数据。 5. 代码段 -- 可执行的代码 / 只读常量 注释：通常来说，我们创建的局部变量和函数中的参数就是放在栈中。而我们之前动态开辟的内存，其实就是开辟在了堆区中。而全局变量以及通过我们 static 设置为静态的数据都会放在数据段。
new 和 delete 大家对我们在c学习的动态内存开辟的几个关键词还记得吧。就是malloc/calloc/realloc/freed
这些知识对本篇博客是没有太多影响，但是如果我们大家如果想温习一下的话大家可以点击下面的链接：C语言----动态内存-CSDN博客。但是我们也说过了这些暂时对我们这篇博客没什么影响。我们今天讲的是这些的升级版。不仅使用方便而且更简洁。那么我们就废话少说先看看如何使用吧：
我们这里先是申请了4个字节就是int嘛。虽然我们并没有初始化。 但是我们可以明显的看到我们这里c&#43;&#43;申请空间比我们在c中申请要简单很多吧，如我们的malloc： (int*)malloc(5*sizeof(int));
我们可以明显的看到如果我还是使用以前的方法的话就有点太牢了。
我们在c&#43;&#43;中使用new很简单。就是前面写出申请空间的类型然后加上*和名字。后就是=加new和空间大小了。。正如我们图片上的第一个例子。我们简单的申请了一个int类型的空间。并且没有初始化。乍一看。我们都知道使用new会比我们使用malloc简单很多。然后就是申请的时候可以初始化。这个也是我们malloc没有的吧。我们图片中的第二个例子就是我们初始化我们如果初始化的话只需要在我们简单申请空间的结尾后加一个（）。然后在里面写出我们要初始化的内容即可。当然了我们上面写了三个例子。第三个例子就是我们的申请多个空间。我们只需要在第一种例子的基础上再最后加[]，然后再里面写出我们申请多少就可以了。但是对于这种多个空间初始化的话就不能像我们第二个例子那样加一个（）那样。要更特殊一些。加的是{}。在里面写我们要初始化内容。
我想大家应该差不多了解了new的使用方法了吧。并且我们知道我们动态内存开辟了的就应该释放吧。我们前面c中的释放是用free。但是我想大家应该也看到上面的图片我们申请的空间都是用的delete。效果与我们前面学的free差不多。都是释放空间的。用法稍有差异。我们前面的free是在后面加个（），括号里面写名字。然后下一行将空间置为null。不然的话可能导致栈溢出的风险。但是我们的delete却好很多。普通的空间我们只需要在其后面加上名字即可，不需要再置为null。但稍微有一点瑕疵就是在释放多数组空间的时候需要在名字前面加一个[]，虽括号中可不写数组个数。只是我们大多时可能忘却。然大家需谨记切莫忘却了。
上面给大家看的都是new和delete的基本使用方法，我相信大家都会很少使用的，更多的时候都是处理自己的事情，我们咧，下面我们是来举一些我们自定义的例子并且引出更多关于new和delete的相关知识：首先我们是来实时对比一下new与malloc申请自定义内存的区别：
我们可以看到我们这里前面写的都是一样的，区别在后面，我们malloc需确定类型后再确定空间大小，方可申请，但new却可直接申请，这便可看出new的方便之处。随之而来的便是我们释放空间。我们可以看到释放空间与前面的手法无异。很简单。并且对于内在类型也是一样的： 这个大家简单看一下如何使用就可以了，也不用很着急的。基本用法就是上面的这些，但是我们还是不能忘记申请了空间需要释放空间这一做法。
最后关于new和delete的一个知识点就是，这两个关键词使用了都会自动调用构造函数和析构函数。这就是与malloc的最大区别。也是创建出new和delete的初衷。 最后就是new/delete 和 malloc/free最大区别是 new/delete对于【自定义类型】除了开空间还会调用构造函数和析构函数。
operator new与operator delete函数 new和delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是 系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-04T20:39:42+08:00">
    <meta property="article:modified_time" content="2024-08-04T20:39:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;----内存管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>      okk，大家好。我们大家学习了鄙人的前面前面几篇博客，并且还稍微使用了一些c++的基础知识。并且我们前面都说过，我们前面学习的知识都说过。我们前面的几篇博客都是我们以后使用c++基础。但是我们大家都知道现在代码都关注什么时间啊，内存啊。我们前面对于c++的时间，我们可以依据以前c的知识。我们前面说过时间复杂度嘛，就是计算基本算法的次数。这个在哪都可以通用。但是我们c++的内存管理却稍微有一点不同。比我们c讲的更加细致且深奥。哈哈。可能说的有点夸张了。但是我们已经引出了我们今天要讲的主题。内存管理了。</p> 
<h3>内存分布</h3> 
<p>       大家应该还记得我们以前c学习的内存的内部吧。当时我们说c内存的时候就说了个栈区，堆区，静态区。然后就是这三个去分别存放临时变量，创建是数据和全局变量。<img alt="" height="400" src="https://images2.imgbox.com/5a/30/vPSsP7W4_o.png" width="880"></p> 
<p>        我们前面刚刚说过我们的c++内存是要复杂一些。我们c++的内存分布<img alt="" height="500" src="https://images2.imgbox.com/27/55/sMloF6n6_o.png" width="691"></p> 
<p>         大家可以看看上面的图片，我们可以看到我们对于内存的分布多了很多。除了我们在c中就见过的堆，栈，静态区以外。我们还写了一个明显的叫做：内存映射段。这个大家对这个应该很陌生吧。什么叫做内存映射段，起什么作用啊。</p> 
<p>mmap是一种内存映射的方法，这一功能可以用在文件的处理上，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。在编程时可以使某个磁盘文件的内容看起来像是内存中的一个数组。如果文件由记录组成，而这些记录又能够用结构体来描述的话，可以通过访问结构数组来更新文件的内容。</p> 
<p>实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如图所示：</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/32/36/W2dfBtea_o.jpg" width="728"></p> 
<p>         </p> 
<p>       进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。</p> 
<p>       内核为系统中的每个进程维护一个单独的任务结构（task_struct）。任务结构中的元素包含或者指向内核运行该进程所需的所有信息(PID、指向用户栈的指针、可执行目标文件的名字、程序计数器等)。Linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问。</p> 
<p>        反正这里是给大家稍微简绍一下。这个后面大家对知识有更多的了解之后，自然会学习更多的。这里我们就稍微给大家说明一下，大家有个了解：</p> 
<div> 
 <span style="color:#777777;">1.<strong>栈</strong></span> 
 <span style="color:#777777;">又叫堆栈</span> 
 <span style="color:#777777;">--</span> 
 <span style="color:#777777;">非静态局部变量</span> 
 <span style="color:#777777;">/</span> 
 <span style="color:#777777;">函数参数</span> 
 <span style="color:#777777;">/</span> 
 <span style="color:#777777;">返回值等等，栈是向下增长的。 </span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;"><strong>内存映射段</strong></span> 
 <span style="color:#777777;">是高效的</span> 
 <span style="color:#777777;">I/O</span> 
 <span style="color:#777777;">映射方式，用于装载一个共享的动态内存库。用户可使用系统接口 </span> 
</div> 
<div> 
 <span style="color:#777777;">创建共享共享内存，做进程间通信。（</span> 
 <span style="color:#777777;">Linux</span> 
 <span style="color:#777777;">课程如果没学到这块，现在只需要了解一下） </span> 
</div> 
<div> 
 <span style="color:#777777;">3. </span> 
 <span style="color:#777777;"><strong>堆</strong></span> 
 <span style="color:#777777;">用于程序运行时动态内存分配，堆是可以上增长的。 </span> 
</div> 
<div> 
 <span style="color:#777777;">4. </span> 
 <span style="color:#777777;"><strong>数据段</strong></span> 
 <span style="color:#777777;">--</span> 
 <span style="color:#777777;">存储全局数据和静态数据。 </span> 
</div> 
<div> 
 <span style="color:#777777;">5. </span> 
 <span style="color:#777777;"><strong>代码段</strong></span> 
 <span style="color:#777777;">--</span> 
 <span style="color:#777777;">可执行的代码</span> 
 <span style="color:#777777;">/</span> 
 <span style="color:#777777;">只读常量</span> 
</div> 
<p><strong>注释：通常来说，我们创建的局部变量和函数中的参数就是放在栈中。而我们之前动态开辟的内存，其实就是开辟在了堆区中。而全局变量以及通过我们 static 设置为静态的数据都会放在数据段。</strong></p> 
<h3 style="background-color:transparent;">new 和 delete</h3> 
<p>       大家对我们在c学习的动态内存开辟的几个关键词还记得吧。就是<strong>malloc</strong>/<span style="color:#333333;"><strong>calloc/realloc/freed</strong></span></p> 
<p>这些知识对本篇博客是没有太多影响，但是如果我们大家如果想温习一下的话大家可以点击下面的链接：<a href="https://blog.csdn.net/2302_80318761/article/details/136933998?spm=1001.2014.3001.5501" title="C语言----动态内存-CSDN博客">C语言----动态内存-CSDN博客</a>。但是我们也说过了这些暂时对我们这篇博客没什么影响。我们今天讲的是这些的升级版。不仅使用方便而且更简洁。那么我们就废话少说先看看如何使用吧：<img alt="" height="305" src="https://images2.imgbox.com/e2/65/NlVXK5rF_o.png" width="1200"></p> 
<p>        我们这里先是申请了4个字节就是int嘛。虽然我们并没有初始化。 但是我们可以明显的看到我们这里c++申请空间比我们在c中申请要简单很多吧，如我们的malloc： (int*)malloc(5*sizeof(int));</p> 
<p>我们可以明显的看到如果我还是使用以前的方法的话就有点太牢了。</p> 
<p>        我们在c++中使用new很简单。就是前面写出申请空间的类型然后加上*和名字。后就是=加new和空间大小了。。正如我们图片上的第一个例子。我们简单的申请了一个int类型的空间。并且没有初始化。乍一看。我们都知道使用new会比我们使用malloc简单很多。然后就是申请的时候可以初始化。这个也是我们malloc没有的吧。我们图片中的第二个例子就是我们初始化我们如果初始化的话只需要在我们简单申请空间的结尾后加一个（）。然后在里面写出我们要初始化的内容即可。当然了我们上面写了三个例子。第三个例子就是我们的申请多个空间。我们只需要在第一种例子的基础上再最后加[]，然后再里面写出我们申请多少就可以了。但是对于这种多个空间初始化的话就不能像我们第二个例子那样加一个（）那样。要更特殊一些。加的是{}。在里面写我们要初始化内容。</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/04/c0/lMhoVczQ_o.png" width="680"></p> 
<p>        我想大家应该差不多了解了new的使用方法了吧。并且我们知道我们动态内存开辟了的就应该释放吧。我们前面c中的释放是用free。但是我想大家应该也看到上面的图片我们申请的空间都是用的delete。效果与我们前面学的free差不多。都是释放空间的。用法稍有差异。我们前面的free是在后面加个（），括号里面写名字。然后下一行将空间置为null。不然的话可能导致栈溢出的风险。但是我们的delete却好很多。普通的空间我们只需要在其后面加上名字即可，不需要再置为null。但稍微有一点瑕疵就是在释放多数组空间的时候需要在名字前面加一个[]，虽括号中可不写数组个数。只是我们大多时可能忘却。然大家需谨记切莫忘却了。</p> 
<p>       上面给大家看的都是new和delete的基本使用方法，我相信大家都会很少使用的，更多的时候都是处理自己的事情，我们咧，下面我们是来举一些我们自定义的例子并且引出更多关于new和delete的相关知识：首先我们是来实时对比一下new与malloc申请自定义内存的区别：<img alt="" height="440" src="https://images2.imgbox.com/81/24/tzyZgXzk_o.png" width="1200"></p> 
<p>        我们可以看到我们这里前面写的都是一样的，区别在后面，我们malloc需确定类型后再确定空间大小，方可申请，但new却可直接申请，这便可看出new的方便之处。随之而来的便是我们释放空间。我们可以看到释放空间与前面的手法无异。很简单。并且对于内在类型也是一样的：<img alt="" height="273" src="https://images2.imgbox.com/e4/c2/VZkFsjfg_o.png" width="1200">        这个大家简单看一下如何使用就可以了，也不用很着急的。基本用法就是上面的这些，但是我们还是不能忘记申请了空间需要释放空间这一做法。</p> 
<p>        最后关于new和delete的一个知识点就是，这两个关键词使用了都会自动调用构造函数和析构函数。这就是与malloc的最大区别。也是创建出new和delete的初衷。<img alt="" height="400" src="https://images2.imgbox.com/78/a0/rJbsoynS_o.png" width="1048">       最后就是<span style="color:#aa5500;">new/delete 和 malloc/free</span><span style="color:#aa5500;">最大区别是 </span><span style="color:#aa5500;">new/delete</span><span style="color:#aa5500;">对于【自定义类型】除了开空间还会调用构造函数和析构函数。</span></p> 
<h3> <span style="color:#333333;"><strong>operator new</strong></span><span style="color:#333333;"><strong>与</strong></span><span style="color:#333333;"><strong>operator delete</strong></span><span style="color:#333333;"><strong>函数</strong></span></h3> 
<p>        <span style="color:#777777;"><strong>new</strong></span><span style="color:#777777;"><strong>和</strong></span><span style="color:#777777;"><strong>delete</strong></span><span style="color:#777777;">是用户进行</span><span style="color:#777777;"><strong>动态内存申请和释放的操作符</strong></span><span style="color:#777777;">，</span><span style="color:#777777;"><strong>operator new </strong></span><span style="color:#777777;"><strong>和</strong></span><span style="color:#777777;"><strong>operator delete</strong></span><span style="color:#777777;">是 系统提供的<strong>全局函数</strong></span><span style="color:#777777;">，</span><span style="color:#777777;"><strong>new</strong></span><span style="color:#777777;"><strong>在底层调用</strong></span><span style="color:#777777;"><strong>operator new</strong></span><span style="color:#777777;">全局函数来申请空间，</span><span style="color:#777777;"><strong>delete</strong></span><span style="color:#777777;"><strong>在底层通过</strong></span><span style="color:#777777;"><strong>operator delete</strong></span><span style="color:#777777;">全局函数来释放空间。</span></p> 
<pre><code class="hljs">/*
operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间
失败，尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否
则抛异常。
*/
void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)
{
// try to allocate size bytes
void *p;
while ((p = malloc(size)) == 0)
if (_callnewh(size) == 0)
{
// report no memory
// 如果申请内存失败了，这里会抛出bad_alloc 类型异常
static const std::bad_alloc nomem;
_RAISE(nomem);
}
return (p);
}
/*
operator delete: 该函数最终是通过free来释放空间的
*/
void operator delete(void *pUserData)
{
_CrtMemBlockHeader * pHead;
RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));
if (pUserData == NULL)
return;
_mlock(_HEAP_LOCK); /* block other threads */
__TRY
/* get a pointer to memory block header */
pHead = pHdr(pUserData);
/* verify block type */
_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));
_free_dbg( pUserData, pHead-&gt;nBlockUse );
__FINALLY
_munlock(_HEAP_LOCK); /* release other threads */
__END_TRY_FINALLY
return;
}
/*
free的实现
*/
#define free(p) _free_dbg(p, _NORMAL_BLOCK)</code></pre> 
<div> 
 <span style="color:#777777;">        通过上述两个全局函数的实现知道，</span> 
 <span style="color:#777777;"><strong>operator new </strong></span> 
 <span style="color:#777777;"><strong>实际也是通过</strong></span> 
 <span style="color:#777777;"><strong>malloc</strong></span> 
 <span style="color:#777777;"><strong>来申请空间</strong></span> 
 <span style="color:#777777;">，如果 </span> 
</div> 
<div> 
 <span style="color:#777777;">malloc</span> 
 <span style="color:#777777;">申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施 </span> 
</div> 
<div> 
 <span style="color:#777777;">就继续申请，否则就抛异常。</span> 
 <span style="color:#777777;"><strong>operator delete </strong></span> 
 <span style="color:#777777;"><strong>最终是通过</strong></span> 
 <span style="color:#777777;"><strong>free</strong></span> 
 <span style="color:#777777;"><strong>来释放空间的。</strong>上面讲的这个知识点是比较重要的。但是就是因为有点重要，并且难懂，所以我暂时也给不了大家太多的见解，但是在后面这个会使用的，如果大家对此感兴趣的话，可以先预习一下。方便后面学习。</span> 
</div> 
<h3><span style="color:#333333;"><strong>new</strong></span><span style="color:#333333;"><strong>和</strong></span><span style="color:#333333;"><strong>delete</strong></span><span style="color:#333333;"><strong>的实现基本原理 </strong></span></h3> 
<p><span style="color:#333333;"><strong>    </strong>   我们前面讲的都是new与delete的用法。但是并未有说过它是如何实现的。有点像我们在c的博客中写过，一些关键词，然后自己实现。自己实现首先就是需要先了解基本的逻辑原理。那么我们这一小节就是来看看<strong>new</strong></span><span style="color:#333333;"><strong>和delete的原理</strong>首先我们先看看内置类型：</span><span style="color:#777777;">如果申请的是内置类型的空间，new</span><span style="color:#777777;">和</span><span style="color:#777777;">malloc</span><span style="color:#777777;">，</span><span style="color:#777777;">delete</span><span style="color:#777777;">和</span><span style="color:#777777;">free</span><span style="color:#777777;">基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，</span><span style="color:#777777;">new[]</span><span style="color:#777777;">和</span><span style="color:#777777;">delete[]</span><span style="color:#777777;">申请的是连续空间，而且</span><span style="color:#777777;">new</span><span style="color:#777777;">在申请空间失败时会抛异常，malloc</span><span style="color:#777777;">会返回</span><span style="color:#777777;">NULL</span><span style="color:#777777;">。对于什么是抛异常这个如果解释起来是比较麻烦并且有点深奥的。还是等到我们后面再解释吧。反正大家可以先了解有这么一个东西就可以了。</span></p> 
<p><span style="color:#777777;">       然后对于自定义类型：<strong>new</strong></span><span style="color:#777777;"><strong>的原理 </strong></span></p> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;">调用</span> 
 <span style="color:#777777;">operator new</span> 
 <span style="color:#777777;">函数申请空间 </span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;">在申请的空间上执行构造函数，完成对象的构造</span> 
</div> 
<div> 
 <div> 
  <span style="color:#777777;"><strong>delete</strong></span> 
  <span style="color:#777777;"><strong>的原理 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;">1. </span> 
  <span style="color:#777777;">在空间上执行析构函数，完成对象中资源的清理工作 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">2. </span> 
  <span style="color:#777777;">调用</span> 
  <span style="color:#777777;">operator delete</span> 
  <span style="color:#777777;">函数释放对象的空间 </span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>new T[N]</strong></span> 
  <span style="color:#777777;"><strong>的原理 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;">1. </span> 
  <span style="color:#777777;">调用</span> 
  <span style="color:#777777;">operator new[]</span> 
  <span style="color:#777777;">函数，在</span> 
  <span style="color:#777777;">operator new[]</span> 
  <span style="color:#777777;">中实际调用</span> 
  <span style="color:#777777;">operator new</span> 
  <span style="color:#777777;">函数完成</span> 
  <span style="color:#777777;">N</span> 
  <span style="color:#777777;">个对象空间的申请 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">2. </span> 
  <span style="color:#777777;">在申请的空间上执行</span> 
  <span style="color:#777777;">N</span> 
  <span style="color:#777777;">次构造函数 </span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>delete[]</strong></span> 
  <span style="color:#777777;"><strong>的原理 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;">1. </span> 
  <span style="color:#777777;">在释放的对象空间上执行</span> 
  <span style="color:#777777;">N</span> 
  <span style="color:#777777;">次析构函数，完成</span> 
  <span style="color:#777777;">N</span> 
  <span style="color:#777777;">个对象中资源的清理 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">2. </span> 
  <span style="color:#777777;">调用</span> 
  <span style="color:#777777;">operator delete[]</span> 
  <span style="color:#777777;">释放空间，实际在</span> 
  <span style="color:#777777;">operator delete[]</span> 
  <span style="color:#777777;">中调用</span> 
  <span style="color:#777777;">operator delete</span> 
  <span style="color:#777777;">来释放空间</span> 
 </div> 
 <div> 
  <span style="color:#777777;">        上面就是我们的new与delete的实现理论，大家可以多看看，这些也方便我们更好的理解与使用new与delete。</span> 
 </div> 
 <h3><span style="color:#333333;"><strong>malloc/free</strong></span><span style="color:#333333;"><strong>和</strong></span><span style="color:#333333;"><strong>new/delete</strong></span><span style="color:#333333;"><strong>的区别 </strong></span></h3> 
 <p>         好了，其实这篇博客到上面的小节一个就结束了的。但是我想给大家再次总结一下c与c++申请空间的区别所以。再加了一个小节方便大家更直观的了解：</p> 
 <div> 
  <span style="color:#777777;">malloc/free</span> 
  <span style="color:#777777;">和</span> 
  <span style="color:#777777;">new/delete</span> 
  <span style="color:#777777;">的共同点是：都是从堆上申请空间，并且需要用户手动释放。</span> 
 </div> 
 <div> 
  <span style="color:#777777;">不同的地方是： </span> 
 </div> 
 <div> 
  <span style="color:#777777;">1. malloc</span> 
  <span style="color:#777777;">和</span> 
  <span style="color:#777777;">free</span> 
  <span style="color:#777777;">是函数，</span> 
  <span style="color:#777777;">new</span> 
  <span style="color:#777777;">和</span> 
  <span style="color:#777777;">delete</span> 
  <span style="color:#777777;">是操作符 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">2. malloc</span> 
  <span style="color:#777777;">申请的空间不会初始化，</span> 
  <span style="color:#777777;">new</span> 
  <span style="color:#777777;">可以初始化 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">3. malloc</span> 
  <span style="color:#777777;">申请空间时，需要手动计算空间大小并传递，</span> 
  <span style="color:#777777;">new</span> 
  <span style="color:#777777;">只需在其后跟上空间的类型即可， </span> 
 </div> 
 <div> 
  <span style="color:#777777;">如果是多个对象，</span> 
  <span style="color:#777777;">[]</span> 
  <span style="color:#777777;">中指定对象个数即可 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">4. malloc</span> 
  <span style="color:#777777;">的返回值为</span> 
  <span style="color:#777777;">void*, </span> 
  <span style="color:#777777;">在使用时必须强转，</span> 
  <span style="color:#777777;">new</span> 
  <span style="color:#777777;">不需要，因为</span> 
  <span style="color:#777777;">new</span> 
  <span style="color:#777777;">后跟的是空间的类型 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">5. malloc</span> 
  <span style="color:#777777;">申请空间失败时，返回的是</span> 
  <span style="color:#777777;">NULL</span> 
  <span style="color:#777777;">，因此使用时必须判空，</span> 
  <span style="color:#777777;">new</span> 
  <span style="color:#777777;">不需要，但是</span> 
  <span style="color:#777777;">new</span> 
  <span style="color:#777777;">需 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">要捕获异常 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">6. </span> 
  <span style="color:#777777;">申请自定义类型对象时，</span> 
  <span style="color:#777777;">malloc/free</span> 
  <span style="color:#777777;">只会开辟空间，不会调用构造函数与析构函数，而</span> 
  <span style="color:#777777;">new </span> 
 </div> 
 <div> 
  <span style="color:#777777;">在申请空间后会调用构造函数完成对象的初始化，</span> 
  <span style="color:#777777;">delete</span> 
  <span style="color:#777777;">在释放空间前会调用析构函数完成 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">空间中资源的清理释放 </span> 
 </div> 
</div> 
<h3>总结</h3> 
<p>      对于c++中释放与申请空间的办法就是上面的这些，基本使用方法也在上面写过了。对operator的使用方法和理解的话，我确实也不是太懂，所以如果大家有理解的话希望大家可以在评论区留言。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5af4e84c9f500ca281626de53a13ee3a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">自定义SQL Server数据访问层：打造专属数据交互之门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0f29a0fdfb09eae4c6ab2f8dd9f4e34/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【AI大模型】Prompt 提示词工程使用详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>