<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入解析Java中锁机制以及底层原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9026288b20d5db28b48f23f084e81796/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深入解析Java中锁机制以及底层原理">
  <meta property="og:description" content="一、概述 1.1 背景 概念：锁是多线程编程中的机制，用于控制对共享资源的访问。可以防止多个线程同时修改或读取共享资源，从而保证线程安全。
作用：锁用于实现线程间的互斥和协调，确保在多线程环境下对共享资源的访问顺序和正确性。
1.2 锁分类 【按锁性质划分】：
乐观锁：认为一个线程获取共享数据的时候，不会存在其他线程修改该共享数据的情况，所以不会上锁。例如：CAS机制、版本号机制等悲观锁：认为一个线程获取共享数据时，一定会存在其他线程修改该共享数据的情况，因此，获取共享数据时都会进行加锁。例如：Synchronized锁、ReentrantLock锁。 【按锁被持有数量划分】：
独占锁：当前锁只有被一个线程持有。例如：ReentrantLock锁；共享锁：当前锁可以被多个线程持有。例如：Semaphore等。 【按公平性划分】：
公平锁：多个线程竞争锁时，需要进行排队，按照先来后到顺序获取锁。例如：ReentrantLock公平锁。非公平锁：多个线程竞争锁时，先进行插队，插入失败再排队。例如：Synchronized锁、ReentrantLock锁 【按可重入性划分】：
可重入锁：允许一个线程多次加锁。例如：Synchronized锁、ReentrantLock锁
。不可重入锁：允许一个线程仅加锁一次。 【按锁范围划分】：
单体锁：仅能锁住当前JVM进程中的共享资源，对其他JVM进程中的共享资源不起作用。例如： Synchronized锁和ReentrantLock锁；分布式锁：借助中间件，对多个JVM进程中的同一共享资源都能锁住。例如：Redis分布式锁。 二、单JVM进程锁 2.1 独占锁 2.1.1 synchronized锁 详情见：深入解析Synchronized锁底层原理
局限性：
是否释放锁，开发者无法自己控制，导致其他线程只能一直阻塞；若获取锁的线程进入休眠或阻塞，除了线程出现异常，否则其他线程将会一直阻塞等待。
因此，在JDK1.5后，加入了Doug Lea大神贡献的java.util.concurrent包，包内提供了Lock类，提供了更加灵活控制锁的功能，弥补了Synchronized的缺陷。 2.1.2 ReentrantLock锁 Lock完全是由Java编写，提供了锁获取和释放的控制权、可中断的获取锁以及超时获取锁等多种高级特性。Lock只是一个接口，常见的实现类有：
1. 重入锁：ReentrantLock; 2. 读锁：ReadLock 3. 写锁：WriteLock 但底层都是通过聚合了一个java 同步器(AbstractQueueSynchronizer, AQS)来完成线程的访问控制的。因此，需要提前了解AQS的底层原理。详情见：深入解析AQS队列同步器的底层原理
ReentrantLock实现了Lock接口，同时底层通过聚合AQS完成并发的功能【注意：此时state只能为0或1】。主要有以下特点：
1. 支持重进入的锁，表示该锁能够支持一个线程对资源的重复加载，同时还支持获取锁的公平和非公平性。 2. 构造方法会接收一个可选的公平参数（默认是非公平锁）。设置为true时，表示公平锁；否则为非公平锁。 3. 可重入性的体现：任意线程获取锁之后，再次获取该锁时，不会被锁所阻塞。因为是可重入的，有一个计数器记录重入次数n, 当n = 0时表明锁完全被释放。 ReentrantLock实现的公平锁和非公平锁的区别：
1. 获取锁的时候是否按照FIFO的顺序来的。公平锁不仅会对state状态进行判断，还会判断当前同步队列中是否有元素，如果存在元素，则插入到同步队列的尾部，真正的先来后到； 2. 非公平锁性能高于公平锁性能。非公平锁可以减少CPU唤醒线程的开销，整体的吞吐率会高点，CPU也不会唤醒所有的线程，减少唤醒线程的数量。具体原因为： 【公平锁获取锁：】会将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序。在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。 】非公平锁获取锁：】当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。 3. 非公平锁会存在线程饥饿的情况。但出现线程饥饿的机率非常低可以忽略不记。这就是默认非公平锁的原因。 2.1.3 局限性 synchronized和ReentrantLock锁，一次仅允许一个线程访问资源，即属于独占性。对于多个线程同时访问共享资源的场景，是无能为力的。不过Java也提供了对应的解决方案：java Semaphore信号量、CountDownLatch以及CyclicBarrier共享锁。
2.2 共享锁 java Semaphore信号量、CountDownLatch以及CyclicBarrier共享锁底层的原理是相通的，都是基于AQS队列同步器来实现的。相比于独占锁，主要区别在于state值设置可由开发者进行控制，这样就可以实现多个线程同时访问共享资源。AQS底层原理见：深入解析AQS队列同步器的底层原理。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-24T23:19:48+08:00">
    <meta property="article:modified_time" content="2024-03-24T23:19:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入解析Java中锁机制以及底层原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一、概述</h2> 
<h3><a id="11__1"></a>1.1 背景</h3> 
<p><code>概念：</code>锁是多线程编程中的机制，用于控制对<code>共享资源的访问</code>。可以防止多个线程同时<code>修改或读取</code>共享资源，从而保证线程安全。<br> <code>作用：</code>锁用于实现线程间的<code>互斥和协调</code>，确保在多线程环境下对共享资源的<code>访问顺序</code>和<code>正确性</code>。</p> 
<h3><a id="12__4"></a>1.2 锁分类</h3> 
<p>【按<code>锁性质</code>划分】：</p> 
<ul><li><code>乐观锁</code>：认为一个线程获取共享数据的时候，不会存在其他线程修改该共享数据的情况，所以<code>不会上锁</code>。例如：<strong>CAS机制</strong>、<strong>版本号机制</strong>等</li><li><code>悲观锁</code>：认为一个线程获取共享数据时，一定会存在其他线程修改该共享数据的情况，因此，获取共享数据时都会<code>进行加锁</code>。例如：<strong>Synchronized锁</strong>、<strong>ReentrantLock锁</strong>。</li></ul> 
<p>【按<code>锁被持有数量</code>划分】：</p> 
<ul><li><code>独占锁</code>：当前锁只有被<code>一个线程</code>持有。例如：<strong>ReentrantLock锁</strong>；</li><li><code>共享锁</code>：当前锁可以被<code>多个线程</code>持有。例如：<strong>Semaphore</strong>等。</li></ul> 
<p>【按<code>公平性</code>划分】：</p> 
<ul><li><code>公平锁</code>：多个线程竞争锁时，需要进行排队，按照<code>先来后到顺序</code>获取锁。例如：<strong>ReentrantLock公平锁</strong>。</li><li><code>非公平锁</code>：多个线程竞争锁时，先进行<code>插队</code>，插入失败再排队。例如：<strong>Synchronized锁</strong>、<strong>ReentrantLock锁</strong></li></ul> 
<p>【按<code>可重入性</code>划分】：</p> 
<ul><li><code>可重入锁</code>：允许一个线程<code>多次加锁</code>。例如：<strong>Synchronized锁</strong>、<strong>ReentrantLock锁</strong><br> 。</li><li><code>不可重入锁</code>：允许一个线程<code>仅加锁一次</code>。</li></ul> 
<p>【按<code>锁范围</code>划分】：</p> 
<ul><li><code>单体锁</code>：仅能锁住<code>当前JVM进程</code>中的共享资源，对其他JVM进程中的共享资源不起作用。例如： <strong>Synchronized锁</strong>和<strong>ReentrantLock锁</strong>；</li><li><code>分布式锁</code>：借助<code>中间件</code>，对<code>多个JVM进程</code>中的同一共享资源都能锁住。例如：<strong>Redis分布式锁</strong>。</li></ul> 
<h3><a id="JVM_25"></a>二、单JVM进程锁</h3> 
<h3><a id="21__26"></a>2.1 独占锁</h3> 
<h4><a id="211_synchronized_27"></a>2.1.1 synchronized锁</h4> 
<p>详情见：<a href="https://blog.csdn.net/weixin_44817884/article/details/136680258">深入解析Synchronized锁底层原理</a><br> <code>局限性：</code></p> 
<ol><li>是否释放锁，开发者无法自己控制，导致其他线程只能一直阻塞；</li><li>若获取锁的线程进入休眠或阻塞，除了线程出现异常，否则其他线程将会一直阻塞等待。<br> 因此，在JDK1.5后，加入了Doug Lea大神贡献的java.util.concurrent包，包内提供了Lock类，提供了更加灵活控制锁的功能，弥补了Synchronized的缺陷。</li></ol> 
<h4><a id="212_ReentrantLock_33"></a>2.1.2 ReentrantLock锁</h4> 
<p>Lock完全是由Java编写，提供了锁获取和释放的控制权、可中断的获取锁以及超时获取锁等多种高级特性。Lock只是一个接口，常见的实现类有：</p> 
<pre><code class="prism language-java"><span class="token number">1.</span> 重入锁：<span class="token class-name">ReentrantLock</span><span class="token punctuation">;</span>
<span class="token number">2.</span> 读锁：<span class="token class-name">ReadLock</span>
<span class="token number">3.</span> 写锁：<span class="token class-name">WriteLock</span>
</code></pre> 
<p>但底层都是通过<code>聚合</code>了一个<code>java 同步器(AbstractQueueSynchronizer, AQS)</code>来完成线程的访问控制的。因此，需要提前了解AQS的底层原理。详情见：<a href="https://blog.csdn.net/weixin_44817884/article/details/136681784">深入解析AQS队列同步器的底层原理</a></p> 
<p>ReentrantLock实现了Lock接口，同时底层通过聚合AQS完成并发的功能【注意：此时state只能为0或1】。主要有以下特点：</p> 
<pre><code class="prism language-java"><span class="token number">1.</span> 支持重进入的锁，表示该锁能够支持一个线程对资源的重复加载，同时还支持获取锁的公平和非公平性。
<span class="token number">2.</span> 构造方法会接收一个可选的公平参数（默认是非公平锁）。设置为<span class="token boolean">true</span>时，表示公平锁；否则为非公平锁。
<span class="token number">3.</span> 可重入性的体现：任意线程获取锁之后，再次获取该锁时，不会被锁所阻塞。因为是可重入的，有一个计数器记录重入次数n<span class="token punctuation">,</span> 当n <span class="token operator">=</span> <span class="token number">0</span>时表明锁完全被释放。
</code></pre> 
<p>ReentrantLock实现的公平锁和非公平锁的区别：</p> 
<pre><code class="prism language-java"><span class="token number">1.</span> 获取锁的时候是否按照<span class="token constant">FIFO</span>的顺序来的。公平锁不仅会对state状态进行判断，还会判断当前同步队列中是否有元素，如果存在元素，则插入到同步队列的尾部，真正的先来后到；
<span class="token number">2.</span> 非公平锁性能高于公平锁性能。非公平锁可以减少<span class="token constant">CPU</span>唤醒线程的开销，整体的吞吐率会高点，<span class="token constant">CPU</span>也不会唤醒所有的线程，减少唤醒线程的数量。具体原因为：
【公平锁获取锁：】会将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序。在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。
】非公平锁获取锁：】当线程获取锁时，会先通过 <span class="token constant">CAS</span> 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。
<span class="token number">3.</span> 非公平锁会存在线程饥饿的情况。但出现线程饥饿的机率非常低可以忽略不记。这就是默认非公平锁的原因。
</code></pre> 
<h4><a id="213__58"></a>2.1.3 局限性</h4> 
<p>synchronized和ReentrantLock锁，一次<code>仅允许一个线程访问资源</code>，即属于<code>独占性</code>。对于多个线程同时访问共享资源的场景，是无能为力的。不过Java也提供了对应的解决方案：<code>java Semaphore信号量、CountDownLatch以及CyclicBarrier共享锁</code>。</p> 
<h3><a id="22__60"></a>2.2 共享锁</h3> 
<p><code>java Semaphore信号量、CountDownLatch以及CyclicBarrier共享锁</code>底层的原理是相通的，都是基于<code>AQS队列同步器</code>来实现的。相比于独占锁，主要区别在于<code>state值设置可由开发者进行控制</code>，这样就可以实现多个线程同时访问共享资源。AQS底层原理见：<a href="https://blog.csdn.net/weixin_44817884/article/details/136681784">深入解析AQS队列同步器的底层原理</a>。</p> 
<h4><a id="221_Semaphore_62"></a>2.2.1 Semaphore</h4> 
<p>Semaphore（信号量）为多线程协作提供了更为强大的控制方法，<code>默认是非公平</code>的。<br> <code>常用场景</code>：<strong>限流</strong>，尤其是公共资源有限的应用场景，例如数据库连接，停车场车位数等。</p> 
<h4><a id="222_CountDownLatch_65"></a>2.2.2 CountDownLatch</h4> 
<p>CountDownLatch称之为闭锁，它可以使一个或一批线程在闭锁上等待，等到其他线程执行完相应操作后，闭锁打开，这些等待的线程才可以继续执行。确切的说，闭锁在<code>内部维护了一个倒计数器</code>。通过该计数器的值来决定闭锁的状态，从而决定是否允许等待的线程继续执行，是<code>批量Join</code>的实现方案。</p> 
<h4><a id="223_CyclicBarrier_67"></a>2.2.3 CyclicBarrier</h4> 
<p>CyclicBarrier通常称为<code>循环屏障</code>。它和CountDownLatch很相似，都可以使线程先等待然后再执行。不过CountDownLatch是使一批线程等待另一批线程执行完后再执行；而CyclicBarrier只是使等待的线程达到一定数目后再让它们继续执行。故而CyclicBarrier内部也有一个计数器,计数器的初始值在创建对象时通过构造参数指定。<br> <code>场景：</code>可循环使用的屏障。即等待一组线程到达一个屏障时被阻塞，直到最后一个线程到达，才会执行。例：五个人一组玩游戏，先到的进行等待，直到凑齐五个人才开始执行任务。</p> 
<h4><a id="224_CyclicBarrierCountDownLatch_70"></a>2.2.4 CyclicBarrier与CountDownLatch的区别：</h4> 
<ol><li>CyclicBarrier的<strong>计数器可以重置</strong>而CountDownLatch不行，这意味着CyclicBarrier实例可以被重复使用而CountDownLatch只能被使用一次；</li><li>CyclicBarrier还有getNumberWaiting()方法获取<strong>阻塞线程数量</strong>；isBroken()方法用来了解阻塞的线程是否被中断。</li><li>CountDownLatch指的是<code>每个线程的主业务逻辑执行完成后，再统一释放锁</code>；而CyclicBarrier指的是<code>等指定数量线程准备</code>好后，再执行主业务逻辑。</li></ol> 
<h3><a id="23__74"></a>2.3 总结</h3> 
<p>不管是独占锁还是共享锁，解决的是共享资源的访问控制问题，无法解决线程见的通信问题。对应的解决方案有：</p> 
<pre><code class="prism language-java"><span class="token number">1.</span> <span class="token class-name">Synchronized</span>锁配合<span class="token class-name">Object</span>的wait和notify等方法来实现线程通信<span class="token punctuation">;</span>
<span class="token number">2.</span> <span class="token class-name">ReentrantLock</span>锁配合<span class="token class-name">Condition</span>实现多个条件下的线程通信。
</code></pre> 
<p><code>Condition的底层实现原理</code>见：<a href="https://blog.csdn.net/weixin_44817884/article/details/136683035">深入解析Condition的底层实现原理</a>。<br> 上述相关的锁的实现，底层都离不开CAS机制和Volatile。因此，有必要了解<code>CAS底层的实现原理</code>，详情见：<a href="https://blog.csdn.net/weixin_44817884/article/details/136683246">深入解析CAS的原理机制</a>。</p> 
<h2><a id="_84"></a>三、分布式锁</h2> 
<p><code>解决的问题：</code>保证一个方法在同一时间内只能被同一个线程执行，在单体应用下，单体锁只能锁住一个JVM进程，其他进程不受影响，显然是无法满足我们的要求的。要考虑非阻塞式分布式锁和阻塞式分布式锁，要根据业务来进行考虑。<br> <code>分布式锁的要求：</code></p> 
<ol><li>保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行；</li><li>是一把<code>可重入锁</code>(防止死锁)；</li><li>是<code>阻塞锁</code>(根据业务考虑阻塞或非阻塞)；</li><li><code>高可用</code>的获取锁和释放锁功能；</li><li>获取锁和释放锁的<code>性能要好</code>。</li></ol> 
<h3><a id="31__92"></a>3.1 数据库分布式锁</h3> 
<p>多个进程多个线程访问共同组件数据库，专门建立一个数据库一张表存放用户自定义锁。</p> 
<h4><a id="311__94"></a>3.1.1 基于数据库表</h4> 
<p>当想要锁住一个方法或资源时，直接将<code>方法或资源信息</code>插入到表中, 同时在数据库层面对方法或资源信息添加唯一性约束，这样当插入成功时,就表示获取到锁；释放锁的时候直接删除信息即可。例如：<br> <strong>锁信息表：</strong></p> 
<pre><code class="prism language-java"><span class="token constant">CREATE</span> <span class="token constant">TABLE</span> `methodLock` <span class="token punctuation">(</span>
  `id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token constant">NOT</span> <span class="token constant">NULL</span> <span class="token constant">AUTO_INCREMENT</span> <span class="token constant">COMMENT</span> <span class="token char">'主键'</span><span class="token punctuation">,</span>
  `method_name` <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token constant">NOT</span> <span class="token constant">NULL</span> <span class="token constant">DEFAULT</span> '' <span class="token constant">COMMENT</span> <span class="token char">'锁定的方法名'</span><span class="token punctuation">,</span>
  `desc` <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token constant">NOT</span> <span class="token constant">NULL</span> <span class="token constant">DEFAULT</span> <span class="token char">'备注信息'</span><span class="token punctuation">,</span>
  `update_time` timestamp <span class="token constant">NOT</span> <span class="token constant">NULL</span> <span class="token constant">DEFAULT</span> <span class="token constant">CURRENT_TIMESTAMP</span> <span class="token constant">ON</span> <span class="token constant">UPDATE</span> <span class="token constant">CURRENT_TIMESTAMP</span> <span class="token constant">COMMENT</span> '保存数据时间，自动生成'<span class="token punctuation">,</span>
  <span class="token class-name">PRIMARY</span> <span class="token constant">KEY</span> <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token constant">UNIQUE</span> <span class="token constant">KEY</span> `uidx_method_name` <span class="token punctuation">(</span>`method_name `<span class="token punctuation">)</span> <span class="token class-name">USING</span> <span class="token constant">BTREE</span>
<span class="token punctuation">)</span> <span class="token constant">ENG</span>
</code></pre> 
<p><strong>加锁：</strong></p> 
<pre><code class="prism language-java">insert into <span class="token function">methodLock</span><span class="token punctuation">(</span>method_name<span class="token punctuation">,</span>desc<span class="token punctuation">)</span> values <span class="token punctuation">(</span>‘method_name’<span class="token punctuation">,</span>‘desc’<span class="token punctuation">)</span>
</code></pre> 
<p><strong>解锁：</strong></p> 
<pre><code class="prism language-java">delete from methodLock where method_name <span class="token operator">=</span>'method_name'
</code></pre> 
<p><code>存在的问题：</code></p> 
<ol><li><code>可用性：</code>强依赖数据库的可用性，一旦数据库宕机，会导致业务系统不可用；</li><li><code>自动释放：</code>由于无法设置失效时间，一旦解锁失败，那么其他线程将无法获取到锁；</li><li><code>阻塞性：</code>插入数据失败的线程会直接报错，返回报错信息，不会等待，因此对某些业务来说是不可接受的；</li><li><code>可重入性：</code>该锁是非重入锁，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了</li></ol> 
<p><code>问题解决方法：</code></p> 
<ul><li>问题1：数据库集群部署，但为了使用分布式锁，多部署一个集群，性价比低，同时高并发情况下，数据库会宕机；</li><li>问题2：后台启动一个定时任务, 定期清理数据表无用的数据。某一时间点占用了大量的数据库连接；</li><li>问题3：设置一个while循环，直到insert成功。性能非常差，产生大量无效insert行为；</li><li>问题4：在数据库表中加个字段，记录当前获得锁的<code>机器的主机信息和线程信息</code>，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul> 
<h4><a id="312__127"></a>3.1.2 基于数据库排他锁</h4> 
<p><strong>具体SQL语句：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span>
注意: 
<span class="token number">1</span>：要配合事务使用<span class="token punctuation">,</span>才会有效使用事务将要加锁的地方包裹住<span class="token punctuation">,</span>等执行完后<span class="token punctuation">,</span>再进行提交。
因为如果<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span>后就提交事务
<span class="token number">2</span>：<span class="token keyword">Innodb</span>只针对根据索引查询来添加行锁<span class="token punctuation">,</span>否则添加表级锁
</code></pre> 
<p><strong>加锁：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span>
</code></pre> 
<p><strong>解锁：</strong></p> 
<pre><code class="prism language-sql">应用层面：自己实现事务的提交
<span class="token keyword">public</span> void <span class="token keyword">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>{
    connection<span class="token punctuation">.</span><span class="token keyword">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
}
</code></pre> 
<p>该中方式解决了基于数据库表的阻塞和无法释放锁的问题：</p> 
<ol><li><code>阻塞性：</code>当select … for update时，会被数据库阻塞住，直到查询数据才会返回；</li><li><code>自动释放锁：</code>若数据库宕机，会自动释放锁</li></ol> 
<p><code>存在的问题：</code></p> 
<ol><li><code>单点故障以及可重入</code>问题；</li><li><code>是否走索引不确定</code>，导致使用的是表锁：MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁；</li><li><code>数据库性能：</code>一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</li></ol> 
<p><strong>注意：</strong> 将作为锁的数据库与业务数据库分开。</p> 
<h3><a id="32__158"></a>3.2 基于缓存实现分布式锁</h3> 
<h4><a id="321_Redis_159"></a>3.2.1 Redis分布式锁</h4> 
<p>使用Redis的setnx实现分布式锁。命令如下：</p> 
<pre><code class="prism language-java">set resource_name my_random_value <span class="token constant">NX</span> <span class="token constant">PX</span> <span class="token number">30000</span>
resource_name<span class="token operator">:</span> 资源名称<span class="token punctuation">,</span>可根据不同业务区分不同的锁<span class="token punctuation">;</span>
my_random_value<span class="token operator">:</span> 随机值<span class="token punctuation">,</span>每个线程的随机值都不同<span class="token punctuation">,</span>用户释放锁时的校验。一般采用<span class="token constant">UUID</span>
<span class="token constant">NX</span>：key不存在时设置成功<span class="token punctuation">,</span>key存在时则设置不成功
<span class="token constant">PX</span>：自动失效时间<span class="token punctuation">,</span>出现异常情况<span class="token punctuation">,</span>锁可以过期失效
</code></pre> 
<p><strong>实现原理：</strong></p> 
<ol><li>利用<strong>NX的原子性</strong>，多个线程并发时，只有一个线程可以设置成功；</li><li>设置成功即可获得锁，可以执行后续的业务处理；</li><li>如果出现异常，过了锁的有效期，锁自动释放；</li><li>释放锁采用delete命令；</li><li>释放锁时校验之前设置的随机值，相同才释放;</li><li>释放锁的<strong>LUA脚本</strong>【先校验后释放】。<code>原因：</code>有A和B两个线程, 若A先获取锁,由于某些原因，A超时了，导致A的锁被释放，此时B获取到了锁，然后执行A释放锁的操作，此时会释放掉B持有的锁。【产生并发问题，所以释放和校验要使用LUA脚本来实现】</li></ol> 
<p><strong>优点：</strong></p> 
<blockquote> 
 <ol><li>可自动释放锁：设置过期时间；</li><li>可靠性高：集群部署</li></ol> 
</blockquote> 
<p><strong>缺点：</strong></p> 
<blockquote> 
 <ol><li>无法缓存层面实现阻塞：只能应用层面实现</li><li>无法实现可重入性</li></ol> 
</blockquote> 
<h4><a id="322_Redisson_185"></a>3.2.2 基于Redisson实现分布式锁</h4> 
<p>在Redis基础上，利用Java对Redis客户端进行封装，并对单体应用下的JDK并发包和JDK集合类等进行扩展，提供分布式下的解决方案。</p> 
<pre><code class="prism language-java"><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="33_Zookeeper_190"></a>3.3 基于Zookeeper分布式锁</h3> 
<h4><a id="331_Zookeeper_191"></a>3.3.1 基于Zookeeper的瞬时节点实现分布式锁</h4> 
<h5><a id="3311__192"></a>3.3.1.1 前言</h5> 
<p>取决于Zookeeper内部的命名空间模型结构。该命名空间模型类似于Linux文件结构，采用树状结构，各个节点被称为znode。每个节点可以存储路径以及与之相关的元数据，还有子节点列表。<br> <img src="https://images2.imgbox.com/97/e2/0aFYhuhQ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3312__195"></a>3.3.1.2 节点类型</h5> 
<p><img src="https://images2.imgbox.com/78/68/rjpqQMKj_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3313__197"></a>3.3.1.3 基于临时顺序节点的分布式锁</h5> 
<p><code>核心思想：</code>临时顺序节点 + Watch(观察器)机制<br> <code>实现原理：</code></p> 
<ol><li>多线程并发创建多个瞬时节点，得到有序的瞬时节点列表；</li><li>选用<code>序号最小</code>的线程获取锁；</li><li>其他线程则利用<code>Watch机制</code>监听自己序号的前一个序号；</li><li>前一个线程执行完成，删除自己序号的节点，利用<code>线程的wait和notify</code>来阻塞和唤醒对象的线程获取锁。</li></ol> 
<p><strong>优点：</strong></p> 
<blockquote> 
 <ol><li><code>锁自动释放</code>：一旦zookeeper宕机或session断开，瞬时节点就会被删除，因此锁就被释放了；</li><li><code>可阻塞：</code>用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。底层使用的是<code>wait和notify机制，因此是阻塞的</code>；<br> 3.<code>可重入：</code>客户端在创建节点的时候，把<code>当前客户端的主机信息和线程信息</code>直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队；</li><li><code>单点被解决：</code>zookeeper通常是集群部署的。<br> 【<strong>补充</strong>】：基于瞬时顺序节点生成的分布式锁，会带有一定的顺序性，即公平锁；也可通过瞬时节点生成分布式锁，这样会生成非公平竞争锁。</li></ol> 
</blockquote> 
<h4><a id="332_ZookeeperCurator_212"></a>3.3.2 基于Zookeeper的Curator客户端实现分布式锁</h4> 
<p>使用Java对Zookeeper客户端进行进一步封装，并提供许多简单便利的功能，比如分布式锁<code>java InterProcessMutex</code>。<br> <strong>缺点：</strong> <code>频繁的创建和删除瞬时节点</code>，ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上，性能有影响。</p> 
<h3><a id="34__216"></a>3.4 分布式锁对比</h3> 
<pre><code class="prism language-java">易于理解程度<span class="token punctuation">(</span>从低到高<span class="token punctuation">)</span>：数据库 <span class="token operator">&gt;</span> 缓存 <span class="token operator">&gt;</span> zookeeper；
实现复杂度<span class="token punctuation">(</span>从低到高<span class="token punctuation">)</span>：zookeeper <span class="token operator">&gt;</span> 缓存 <span class="token operator">&gt;</span> 数据库
性能<span class="token punctuation">(</span>从低到高<span class="token punctuation">)</span><span class="token operator">:</span> 缓存 <span class="token operator">&gt;</span> zookeeper <span class="token operator">&gt;</span> 数据库
可靠性<span class="token punctuation">(</span>从低到高<span class="token punctuation">)</span>：数据库 <span class="token operator">&lt;</span> 缓存 <span class="token operator">&lt;</span> zookeeper
不推荐使用自己编写的分布式锁，推荐使用<span class="token class-name">Redisson</span>和<span class="token class-name">Curator</span>实现的分布式锁
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c723f2578e4fa0ff1e0327f3625571d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构——双向链表（C语言版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/32c7d66c77abbca574d19fece387f554/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常用中间件redis，kafka及其测试方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>