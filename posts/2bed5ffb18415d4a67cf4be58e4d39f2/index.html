<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划：路径和子数组问题（C&#43;&#43;） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2bed5ffb18415d4a67cf4be58e4d39f2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="动态规划：路径和子数组问题（C&#43;&#43;）">
  <meta property="og:description" content="动态规划：路径和子数组问题 路径问题1.不同路径（中等）2.不同路径II（中等）3.下降路径最⼩和（中等）4.地下城游戏（困难） 子数组问题1.最大子数组和（中等）2.环形子数组的最大和（中等）3.乘积最大子数组（中等）4.乘积为正数的最长子数组（中等）5.等差数列划分（中等）6.最长湍流子数组（中等）7.单词拆分（中等）8.环绕字符串中唯⼀的子字符串（中等） 路径问题 1.不同路径（中等） 链接：不同路径
题目描述
做题步骤
状态表示
尝试定义状态表示为到达[m, n]位置的路径数。
状态转移方程
通过上述分析，可知状态转移方程为：
dp[i][j] = dp[i - 1][j] &#43; dp[i][j - 1]。
初始化
填表顺序
保证填当前状态时，所需状态已经计算过，从起点出发，填表顺序为从上往下，每一行从左往右。
返回值
根据状态表示，返回的应该是dp[m][n]，即到达终点的路径数。
代码实现 class Solution { public: int uniquePaths(int m, int n) { //dp[i][j]表示到达该位置的路径 vector&lt;vector&lt;int&gt;&gt; dp(m&#43;1, vector&lt;int&gt;(n&#43;1,0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; i&#43;&#43;) { for(int j = 1; j &lt;= n;j&#43;&#43;) { dp[i][j] = dp[i][j - 1] &#43; dp[i - 1][j]; } } return dp[m][n]; //时间复杂度：O(N) //空间复杂度：O(N^M) } }; //滚动数组优化 // class Solution { // public: // int uniquePaths(int m, int n) // { // vector&lt;int&gt; dp(n &#43; 1); // dp[1] = 1; // for(int i = 1; i &lt;= m; i&#43;&#43;) // { // for(int j = 1; j &lt;= n;j&#43;&#43;) // { // dp[j] &#43;= dp[j-1]; // } // } // return dp[n]; // } // }; 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-05T10:54:57+08:00">
    <meta property="article:modified_time" content="2023-09-05T10:54:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划：路径和子数组问题（C&#43;&#43;）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>动态规划：路径和子数组问题</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">路径问题</a></li><li><ul><li><a href="#1_4" rel="nofollow">1.不同路径（中等）</a></li><li><a href="#2II_83" rel="nofollow">2.不同路径II（中等）</a></li><li><a href="#3_145" rel="nofollow">3.下降路径最⼩和（中等）</a></li><li><a href="#4_213" rel="nofollow">4.地下城游戏（困难）</a></li></ul> 
   </li><li><a href="#_281" rel="nofollow">子数组问题</a></li><li><ul><li><a href="#1_283" rel="nofollow">1.最大子数组和（中等）</a></li><li><a href="#2_340" rel="nofollow">2.环形子数组的最大和（中等）</a></li><li><a href="#3_417" rel="nofollow">3.乘积最大子数组（中等）</a></li><li><a href="#4_494" rel="nofollow">4.乘积为正数的最长子数组（中等）</a></li><li><a href="#5_575" rel="nofollow">5.等差数列划分（中等）</a></li><li><a href="#6_644" rel="nofollow">6.最长湍流子数组（中等）</a></li><li><a href="#7_711" rel="nofollow">7.单词拆分（中等）</a></li><li><a href="#8_786" rel="nofollow">8.环绕字符串中唯⼀的子字符串（中等）</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>路径问题</h3> 
<h4><a id="1_4"></a>1.不同路径（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/unique-paths/" rel="nofollow">不同路径</a></p> 
<ul><li> <p>题目描述<br> <img src="https://images2.imgbox.com/81/7e/aqozB3Q3_o.png" alt="在这里插入图片描述"></p> </li><li> <p>做题步骤</p> </li></ul> 
<ol><li> <p>状态表示<br> 尝试<strong>定义状态表示为到达[m, n]位置的路径数</strong>。<br> <img src="https://images2.imgbox.com/3d/63/F1DlUkdW_o.png" alt="在这里插入图片描述"></p> </li><li> <p>状态转移方程<br> 通过上述分析，可知状态转移方程为：<br><strong>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</strong>。</p> </li><li> <p>初始化<br> <img src="https://images2.imgbox.com/71/cb/NaDhfITs_o.png" alt="在这里插入图片描述"></p> </li><li> <p>填表顺序<br> 保证填当前状态时，所需状态已经计算过，从起点出发，<strong>填表顺序为从上往下，每一行从左往右</strong>。</p> </li><li> <p>返回值<br> 根据状态表示，<strong>返回的应该是dp[m][n]</strong>，即到达终点的路径数。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//dp[i][j]表示到达该位置的路径</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> 
	
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N^M)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//滚动数组优化</span>
<span class="token comment">// class Solution {<!-- --></span>
<span class="token comment">// public:</span>
<span class="token comment">//     int uniquePaths(int m, int n) </span>
<span class="token comment">//     {<!-- --></span>
<span class="token comment">//         vector&lt;int&gt; dp(n + 1);</span>
<span class="token comment">//         dp[1] = 1;</span>

<span class="token comment">//         for(int i = 1; i &lt;= m; i++)</span>
<span class="token comment">//         {<!-- --></span>
<span class="token comment">//             for(int j = 1; j &lt;= n;j++)</span>
<span class="token comment">//             {<!-- --></span>
<span class="token comment">//                 dp[j] += dp[j-1];</span>
<span class="token comment">//             }</span>
<span class="token comment">//         } </span>
<span class="token comment">//         return dp[n];</span>
<span class="token comment">//     }</span>
<span class="token comment">// };</span>
</code></pre> 
<br> 
<h4><a id="2II_83"></a>2.不同路径II（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/unique-paths-ii/" rel="nofollow">不同路径II</a></p> 
<ul><li> <p>题目描述<br> <img src="https://images2.imgbox.com/d9/da/xwfau9aC_o.png" alt="在这里插入图片描述"></p> </li><li> <p>做题步骤</p> </li></ul> 
<ol><li> <p>状态表示<br> 这个题和第一题<strong>唯一不同就是加入了障碍物（1）</strong>，我们只需要进行判断，如果<strong>该位置是障碍物就填0，否则依据转移方程填表</strong>。</p> </li><li> <p>状态转移方程<br> 通过上述分析，可知状态转移方程为：<br><strong>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</strong>。</p> </li><li> <p>初始化<br> 和第一题一样，多开一圈，dp[0][1]或dp[1][0]初始为1。</p> </li><li> <p>填表顺序<br> 和第一题一样，<strong>填表顺序为从上往下，每一行从左往右</strong>。</p> </li><li> <p>返回值<br> 根据状态表示，<strong>返回的应该是dp[m][n]</strong>，即到达终点的路径数。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> obstacleGrid<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> obstacleGrid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//dp[i][j]：到达该位置的路径数</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//dp[1][0] = 1;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//多开了一圈，注意下标映射</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">//vector默认初始0，障碍物对应位置无需处理</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N^2)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="3_145"></a>3.下降路径最⼩和（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/minimum-falling-path-sum/description/" rel="nofollow">下降路径最⼩和</a></p> 
<ul><li> <p>题目描述<br> <img src="https://images2.imgbox.com/c1/29/m1u5Csjl_o.png" alt="在这里插入图片描述"></p> </li><li> <p>做题步骤</p> </li></ul> 
<ol><li> <p>状态表示<br> <img src="https://images2.imgbox.com/07/cd/T8jho51F_o.png" alt="在这里插入图片描述"></p> </li><li> <p>状态转移方程<br> 由前面的分析可知，状态转移方程为：<br> <strong>dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]}) + matrix[i - 1][j - 1](本身的值）</strong></p> </li><li> <p>初始化<br> <strong>先全部初始化为极大值，然后第一行初始化为0</strong>。</p> </li><li> <p>填表顺序<br> <strong>从上往下，每一行从左往右。</strong></p> </li><li> <p>返回值<br> 依据状态表示和题目要求，<strong>返回最后一行的最小值即可</strong>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minFallingPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//dp[i][j]表示到这个位置最小路径和</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//初始化第一行</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
                              <span class="token operator">+</span> matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//再遍历一次找最小</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ret <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>           
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N^2)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="4_213"></a>4.地下城游戏（困难）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/dungeon-game/" rel="nofollow">地下城游戏</a></p> 
<ul><li>题目描述</li></ul> 
<p><img src="https://images2.imgbox.com/d2/ca/NVXGfSia_o.png" alt="在这里插入图片描述"></p> 
<ul><li>做题步骤</li></ul> 
<ol><li>状态表示</li></ol> 
<p><img src="https://images2.imgbox.com/58/7c/tL9qzptO_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li> <p>状态转移方程<br> 由前面的分析可知，状态转移方程为：<br> <strong>dp[i][j] = min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i][j]</strong>(自身出去的消耗）</p> </li><li> <p>初始化<br> <strong>先将所有值初始化为极大值，dp[m][n - 1] = dp[m - 1][n] = 1。</strong></p> </li><li> <p>填表顺序<br> <strong>从下往上，每一行从右向左。</strong></p> </li><li> <p>返回值<br> 由状态表示可知，<strong>返回值为dp[0][0]</strong>（即[0,0]位置到终点需要的最小生命）</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">// 看点位的状态表示</span>
<span class="token comment">//从左上到右下：点位表示到这里需要的最小健康点数，点位并不是只受到左边和上面的影响，也要受后面点位的影响（后面点位可能使自己死亡），这种状态表示肯定不能</span>

<span class="token comment">//从右下到左上：点位表示从这里开始到终点所需要的最小健康点数。</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">calculateMinimumHP</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> dungeon<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//dp[i][j]表示以这个位置为起点到终点所需要的最小健康点数</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> dungeon<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> dungeon<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//初始化</span>
        dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> dungeon<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">//如果dp[i][j]为负数，说明这个位置是奶</span>
                <span class="token comment">//直接奶满了，从这里到终点所要的点数1就足够（小于1就死了）</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N^2)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h3><a id="_281"></a>子数组问题</h3> 
<h4><a id="1_283"></a>1.最大子数组和（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/maximum-subarray/" rel="nofollow">最大子数组和</a></p> 
<ul><li>题目描述</li></ul> 
<p><img src="https://images2.imgbox.com/d9/00/0BKocfRC_o.png" alt="在这里插入图片描述"></p> 
<ul><li>做题步骤</li></ul> 
<ol><li> <p>状态表示<br> 这个题目我们可以定义<strong>状态表示为以i位置为结尾的子数组的最大和</strong>。<br> 因为子数组必须是连续的，所以i位置有两种选择：<br> (1)接在以i - 1位置为结尾的子数组后面，<strong>即dp[i] = dp[i - 1] + 自身点数</strong><br> (2)不接在别人后面(可能dp[i - 1]是负值)，就自己一个，即<strong>dp[i] = 自身点数</strong><br> 从两种选择中选择最大的一种，即<strong>dp[i] = max(dp[i -1] + 自身点数, 自身点数)</strong></p> </li><li> <p>状态转移方程<br> 由前面的分析可知，状态转移方程为：<br> <strong>dp[i] = max(dp[i -1] + 自身点数, 自身点数)</strong></p> </li><li> <p>初始化<br> 无需初始化。</p> </li><li> <p>填表顺序<br> <strong>从左往右</strong>。</p> </li><li> <p>返回值<br> 无法直接确定最大子数组的结尾位置，可以定义变量ret，<strong>一边dp一边更新最大值</strong>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//在原数组上面dp就行</span>
        <span class="token comment">//dp[i]：以i位置为结尾的最大子数组和</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//遍历的过程顺便找最大</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
        <span class="token punctuation">}</span>                
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(1)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="2_340"></a>2.环形子数组的最大和（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/" rel="nofollow">环形子数组的最大和</a></p> 
<ul><li> <p>题目描述<br> <img src="https://images2.imgbox.com/28/8b/d2XasDUP_o.png" alt="在这里插入图片描述"></p> </li><li> <p>做题步骤</p> </li></ul> 
<ol><li> <p>状态表示<br> 这个题目和前一题类似，我们依然可以定义状态表示为<strong>以i位置为结尾的最大子数组和</strong>。<br><br> 对于环形问题，最常见的做法就是分情况讨论，分解问题：<br> (1)<strong>最大子数组不成环</strong>，比如[-1,2,3,-1]，这个情况<strong>做法和前一道题一样</strong>。<br><br> (2)<strong>最大子数组成环</strong>，比如[2,1,-3,-2,1]，<strong>最大子数组成环情况，数组中剩余的连续部分一定是最小子数组</strong>。<br> 子数组是连续的，环形可以理解为左右扩张，所有有利于自己的连续部分一定会被吞并，剩下的一定是最小子数组和。<br> 但数组的总和是不变的，我们<strong>只需要用总和减去最小子数组和即可得到成环情况的最大和</strong>。</p> </li><li> <p>状态转移方程<br> 不成环最大子数组和用f表来记录，最小子数组和用g表来记录<br> 状态转移方程为：<br> <strong>f[i] = max(nums[i], f[i - 1] + nums[i])<br> g[i] = min(nums[i], g[i - 1] + nums[i])</strong></p> </li><li> <p>初始化<br> 为避免填表越界，处理第一个位置，<strong>f[0] = g[0] = nums[0]</strong></p> </li><li> <p>填表顺序<br> 都是<strong>从左往右</strong>。</p> </li><li> <p>返回值<br> 无法直接确定最大(小)子数组的结尾，<strong>所以一边dp一边记录最大(小)值</strong>。<br> (1)f表最大值-&gt;fmax<br> (2)g表最小值-&gt;gmin<br> (3)总和-&gt;sum<br> 还有一种特殊情况就是环形数组长度为0(数组中全是负数)，这个时候最大值为fmax而不是0，所以<strong>返回值为sum == gmin ? fmax : max(fmax, sum - gmin)</strong>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxSubarraySumCircular</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//一种情况是不需要环形，区间就在数组中</span>
         <span class="token comment">//第二种情况是需要环形，数组总大小恒定</span>
        <span class="token comment">//非目标区间是连续并且在数组中的，所以最大 = 总 - 非目标区间</span>
        <span class="token comment">//比如 5 -3 5，第一种得到5，第二种为 7(总) - (-3) = 10</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//f[i]：以i位置为结尾的不成环最大子数组和</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//g[i]：以i位置为结尾的最小子数组和</span>
        <span class="token keyword">auto</span> g <span class="token operator">=</span> f<span class="token punctuation">;</span>
        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> fmax <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> gmin <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            fmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>fmax<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            gmin <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>gmin<span class="token punctuation">,</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//sum和gmin相同说明里面全是负数，这个时候fmax才是最大，不能为0</span>
        <span class="token keyword">return</span> sum <span class="token operator">==</span> gmin <span class="token operator">?</span> fmax <span class="token operator">:</span> <span class="token function">max</span><span class="token punctuation">(</span>fmax<span class="token punctuation">,</span> sum <span class="token operator">-</span> gmin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="3_417"></a>3.乘积最大子数组（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/maximum-product-subarray/description/" rel="nofollow">乘积最大子数组</a></p> 
<ul><li> <p>题目描述<br> <img src="https://images2.imgbox.com/6d/c9/h5msW5LV_o.png" alt="在这里插入图片描述"></p> </li><li> <p>做题步骤</p> </li></ul> 
<blockquote> 
 <p>这个题目子数组长度最小可以为1，其实<strong>所有子数组默认乘了一个1</strong>。</p> 
</blockquote> 
<ol><li> <p>状态表示<br> 依据前面最大子数组和的经验，我们可以定义状态为<strong>以i位置为结尾的最大乘积</strong>。<br><br> 但只有这一个状态表示是不够的，负数的加入对乘积影响是巨大的，比如[1,2,3,-1,-2,1]，前面按最大和的做法来还没问题，但遇到多个负数就会出问题，这里[1,2,3,-1,-2]可以得到最大乘积12，如果按照最大和的做法只能得到6。<br><br> 出现上面情况的原因在于<strong>负数的出现使得原来的最大乘积变成了最小乘积</strong>，但如果保存最小乘积，当<strong>遇到负数时最小乘积就可以变成最大乘积</strong>。<br><br> 综上所述，我们需要同时记录最大和最小乘积，其中最大用f表记录，最小用g表记录。<br> <strong>(1)x = nums[i]（当前位置的值）<br> (2)y = f[i - 1]（前一个位置的最大乘积）<br> (3)z = g[i - 1]（前一个位置的最小乘积）</strong></p> </li><li> <p>状态转移方程<br> 一共就三种情况：<br> (1)x：不接在别人后面，子数组长度为1。<br> (2)x * y：接在前一个位置最大乘积子数组后面，有可能得到最大(小)乘积。<br> (3)y * z：接在前一个位置最小乘积子数组后面，有可能得到最大(小)乘积。<br><br> 由此可知状态转移方程为：<br> <strong>f[i] = max( {x, x * y, x * z} )<br> g[i] = min( {x, x * y, x * z} )</strong></p> </li><li> <p>初始化<br> 当前位置的f、g更新需要前一个位置，<strong>第一个位置的最大(小)乘积就是值本身</strong>，为了避免第一个位置越界，可以<strong>在前面多开一个空间并初始化为1，即f[0] = g[0] = 1</strong>，这样不会影响第一个位置。</p> </li><li> <p>填表顺序<br> <strong>从左往右。</strong></p> </li><li> <p>返回值<br> 无法直接确定最大子数组的结尾位置，<strong>一边dp一边更新最大值</strong>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n  <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//dp[i]：以i为结尾的最大乘积</span>
        <span class="token comment">//f[i]表示最大乘积，g[i]表示最小乘积</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> g <span class="token operator">=</span> f<span class="token punctuation">;</span>
        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//ret变量记录最大乘积</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> x <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//现在</span>
            <span class="token keyword">int</span> y <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//上个位置的最大乘积</span>
            <span class="token keyword">int</span> z <span class="token operator">=</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//上个位置的最小乘积</span>
            <span class="token comment">//如果遇到负数的情况，原本最大乘积可能会变成最小，原本最小可能会变成最大</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">,</span> x <span class="token operator">*</span> y<span class="token punctuation">,</span> x <span class="token operator">*</span> z<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">,</span> x <span class="token operator">*</span> y<span class="token punctuation">,</span> x <span class="token operator">*</span> z<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="4_494"></a>4.乘积为正数的最长子数组（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/description/" rel="nofollow">乘积为正数的最长子数组</a></p> 
<ul><li> <p>题目描述<br> <img src="https://images2.imgbox.com/c4/3f/jh2ANIpf_o.png" alt="在这里插入图片描述"></p> </li><li> <p>做题步骤</p> </li></ul> 
<ol><li> <p>状态表示<br> 这个题目和上一道类似，要考虑负数的加入，因此只有一个状态表示是不够的。<br> (1)f表：以i位置为结尾，乘积为正数的最长子数组长度。<br> (2)g表：以i位置为结尾，乘积为负数的最长子数组长度。</p> </li><li> <p>状态转移方程<br> 设当前位置的值为x<br> (1)x为负数时，接在前一个位置的后面，原本乘积正数的子数组会变成负数，乘积负数的子数组会变成正数。<br> 即f[i] = g[i - 1] + 1 和 g[i] = f[i - 1] + 1,但前一个位置结尾的子数组乘积可能无法出现负数（前面都是正数），即g[i - 1] == 0，这个时候f[i]应该也为0。<br> <strong>故状态转移方程为：<br> f[i] = g[i - 1] == 0 ? 0 : g[i - 1] + 1<br> g[i] = f[i - 1] + 1</strong> <br><br> (2)当x为正数时，接在前一个位置的后面，原本乘积正数的子数组还是正数，乘积负数的子数组还是负数。<br> （也要考虑<strong>前一个位置乘积负数不存在的情况</strong>）<br> <strong>故状态转移方程为：<br> f[i] = f[i - 1] + 1<br> g[i] = g[i - 1] == 0 ? 0 : g[i - 1] + 1</strong></p> </li><li> <p>初始化<br> 当前位置的f、g更新需要前一个位置，<strong>第一个位置为负数，g[i]为1，f[i]为0，值为正数则相反</strong>。为了避免第一个位置越界，可以<strong>在前面多开一个空间并初始化为0，即f[0] = g[0] = 0</strong>，这样不会影响第一个位置。</p> </li><li> <p>填表顺序<br> 保证填当前状态时，所需状态已经计算过，<strong>填表顺序很明显是从左往右</strong></p> </li><li> <p>返回值<br> 无法直接确定乘积为正数的最长子数组结尾位置，定义变量ret，<strong>一边dp一边更新最大值</strong>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">getMaxLen</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//dp[i] 表示这个位置乘积为负数/正数时的最大长度</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正数</span>
        <span class="token keyword">auto</span> g <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token comment">//负数</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//这个数是正数</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token comment">//要考虑前一个位置乘积负数不存在的情况</span>
                g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//负数</span>
            <span class="token punctuation">{<!-- --></span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>           
            <span class="token punctuation">}</span>
            <span class="token comment">//这个数为0，两个状态都不存在，不用处理（本来就是0）</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="5_575"></a>5.等差数列划分（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/arithmetic-slices/" rel="nofollow">等差数列划分</a></p> 
<ul><li>题目描述</li></ul> 
<p><img src="https://images2.imgbox.com/9e/26/Z7JQO51u_o.png" alt="在这里插入图片描述"></p> 
<ul><li>做题步骤</li></ul> 
<ol><li> <p>状态表示<br> 依据前面的经验，我们可以定义<strong>状态表示为以i位置为结尾的等差数组个数</strong>。</p> </li><li> <p>状态转移方程<br> 以[1,2,3,4]为例子进行分析：<br> (1)像1、2这样的位置为结尾数组长度不足3，是一定不能构成等差数组的，即dp[i] = 0。<br> (2)像4这样的位置，先看能不能和前面两个元素构成等差数组（满足nums[i] + nums[i - 2] == 2* nums[i - 1]），如果可以的话那4也一定可以接在以3为结尾的等差数组后面，即dp[i] = dp[i - 1] + 1。<br><br> 综上所述，<strong>状态转移方程为：<br> 可以和前两个数构成等差数组：dp[i] = dp[i - 1] + 1<br> 不能和前两个数构造等差数组：dp[i] = 0</strong></p> </li><li> <p>初始化<br> 无需初始化。</p> </li><li> <p>填表顺序<br> 保证填当前状态时，所需状态已经计算过，<strong>填表顺序很明显是从左往右</strong></p> </li><li> <p>返回值<br> 题目要求返回所有等差子数组，定义变量sum，<strong>一边dp一边累加</strong>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">numberOfArithmeticSlices</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1 2 3 4 5</span>
        <span class="token comment">//3位置1种   4位置除了拼在3位置可能的后面，还可以抢2 3 来组成</span>
        <span class="token comment">//4位置2种   5位置除了拼在4位置可能的后面，还可以抢3 4 来组成</span>
        <span class="token comment">//………………对更长的序列也是如此</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//dp[i]：以i位置为结尾的等差数组个数</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//等差数列的性质：num[i] + nums[i - 2] == 2 * num[i - 1]</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token operator">*</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//不满足等差数组为0，vector默认给0，不用处理</span>
            sum <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="6_644"></a>6.最长湍流子数组（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/longest-turbulent-subarray/" rel="nofollow">最长湍流子数组</a></p> 
<ul><li> <p>题目描述<br> <img src="https://images2.imgbox.com/85/88/UAZFahiN_o.png" alt="在这里插入图片描述"></p> </li><li> <p>做题步骤</p> </li></ul> 
<ol><li> <p>状态表示<br> 依据前面的经验，我们定义<strong>状态表示为以i位置为结尾的最长湍流子数组长度</strong>。<br><br> 但只知道i-1位置的最大长度是无法推导出i位置的最大长度的，因为不知道前一个最长湍流子数组结束是处于上升状态(最后的比较符号为’&lt;‘)还是下降状态(最后的比较符号为’&gt;')<br><br> 因此可以对状态进行细分：<br> （1）<strong>f[i]表示以i位置为结尾并处于<font color="red">上升状态(最后的比较符号为’&lt;')</font>的最长湍流子数组长度</strong><br> （2）<strong>g[i]表示以i位置为结尾并处于<font color="red">下降状态(最后的比较符号为’&gt;')</font>的最长湍流子数组长度</strong></p> </li><li> <p>状态转移方程<br> 因为湍流子数组比较符号必须在每个相邻元素之间翻转，所以状态转移方程与当前的比较符号相关。<br> （1）<strong>arr[i-1] &lt; arr[i]</strong>，现在处于上升状态，需要前置状态处于下降状态的最长湍流子数组长度，即<strong>f[i] = g[i - 1] + 1</strong>。<br> （2）<strong>arr[i-1] &gt; arr[i]</strong>，现在处于下降状态，需要前置状态处于上升状态的最长湍流子数组长度，即<strong>g[i] = f[i - 1] + 1</strong>。<br> （3）<strong>arr[i-1] = arr[i]</strong>，不能和前面组合，只能自己重新开始，即<strong>f[i] = g[i] = 1</strong>。</p> </li><li> <p>初始化<br> 推导当前状态需要前一个状态，像第一个位置不能跟在别人后面，两个状态的长度都为1，f[0] = g[0] = 1。因为arr[i-1] = arr[i]时f[i] = g[i] = 1，所以干脆一开始<strong>全都初始化为1</strong>，就不用单独处理arr[i-1] = arr[i]的情况。</p> </li><li> <p>填表顺序<br> 保证填当前状态时，所需状态已经计算过，<strong>填表顺序很明显是从左往右</strong></p> </li><li> <p>返回值<br> 无法直接确定最长湍流数组的结尾位置以及结尾是处于上升还是下降状态，所以定义变量ret，<strong>一边dp一边更新最大值</strong>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxTurbulenceSize</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//dp[i]表示以i位置为结尾并且处于上升(下降)状态的最长湍流子数组的长度 </span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//f表示处于上升(&lt;)状态</span>
        <span class="token comment">//初始化为1，可以把'=='的情况直接处理了</span>
        <span class="token keyword">auto</span> g <span class="token operator">=</span> f<span class="token punctuation">;</span> <span class="token comment">//g表示处于下降(&gt;)状态</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span> <span class="token punctuation">{<!-- --></span>ret<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="7_711"></a>7.单词拆分（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/word-break/" rel="nofollow">单词拆分</a></p> 
<ul><li>题目描述</li></ul> 
<p><img src="https://images2.imgbox.com/44/92/XnwjRMuE_o.png" alt="在这里插入图片描述"></p> 
<ul><li>做题步骤</li></ul> 
<ol><li> <p>状态表示<br> 依据前面的经验，我们可以定义状态表示为<strong>以i位置为结尾的字符串能否由字典中的单词拼出</strong>。</p> </li><li> <p>状态转移方程<br> 以s = “leetcode”, wordDict = [“leet”, “code”]为例进行分析：<br> （1）先看字符’t’位置（下标3位置），以这个位置为结尾的字符串如果能由字典中的单词拼出，一共有下面几种可能：<br> ①"lee"可以由字典中的单词拼出(即dp[2] = true)，"t"也可以由字典中的单词拼出。<br> ②"le"可以由字典中的单词拼出(即dp[1] = true)，"et"也可以由字典中的单词拼出。<br> ③"l"可以由单词中的单词拼出(即dp[0] = true)，"eet"也可以由字典中的单词拼出。<br> ④再往前就没有了，"leet"可以由字典中的单词拼出。<br><br> 其它位置的分析也和上述一致，<strong>将当前字符串分成[0, j - 1]区间和[j, i]区间，从 0 ~ i 枚举 j ，只要 dp[j - 1] = true并且后面部分的子串 s.substr(j, i - j + 1) 能够在字典中找到，那么 dp[i] = true 。</strong></p> </li><li> <p>初始化<br> 处理④这样的情况，可以<strong>多加一个虚拟节点并初始化true</strong>(dp[0] = true)，可以理解为<strong>空串能在字典中找到</strong>。同时为了方便处理下标的映射关系，我们可以<strong>在字符串s前面加一个占位符(s = ’ ’ + s)</strong>，这样就不用考虑下标的映射了。</p> </li><li> <p>填表顺序<br> 保证填当前状态时，所需状态已经计算过，<strong>填表顺序很明显是从左往右</strong></p> </li><li> <p>返回值<br> 根据状态表示，假设字符串长度为n，<strong>返回的应该是dp[n]</strong></p> </li><li> <p>优化<br> 为了方便查询字符串是否在字典中，可以<strong>把字典的单词存储到哈希表中</strong>。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> wordDict<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 将字典⾥⾯的单词存在哈希表⾥⾯</span>
        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> hash<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> s <span class="token operator">:</span> wordDict<span class="token punctuation">)</span> hash<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 保证后续填表是正确的</span>
        s <span class="token operator">=</span> <span class="token char">' '</span> <span class="token operator">+</span> s<span class="token punctuation">;</span> <span class="token comment">// 使原始字符串的下标统⼀ </span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">//最后⼀个单词的起始位置</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//已经确定为真就可以跳出这一层循环了</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N^2)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="8_786"></a>8.环绕字符串中唯⼀的子字符串（中等）</h4> 
<p>链接：<a href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/" rel="nofollow">环绕字符串中唯⼀的子字符串</a></p> 
<ul><li>题目描述</li></ul> 
<p><img src="https://images2.imgbox.com/3c/28/tsrWR9ED_o.png" alt="在这里插入图片描述"></p> 
<ul><li>做题步骤</li></ul> 
<ol><li> <p>状态表示<br> 依据前面的经验，我们定义状态表示为<strong>以i位置为结尾并且在base中出现的子字符串个数</strong>。</p> </li><li> <p>状态转移方程<br> 这个题目中的base数组是按照abcd……zabcd这样的顺序来的，要注意base成环。<br> 以i位置为结尾并在base中出现的子字符串有下面三种可能：<br> (1)不拼在别人后面，就单独自己一个，该字符串一定会在base中出现。<br> (2)拼在别人后面，并且满足s[i] = s[i - 1] + 1(即满足abcd递增)<br> (3)拼在别人后面，并且满足s[i] == ‘a’ &amp;&amp; s[i - 1] == ‘z’(刚好成环)<br><br> 综上所述，状态转移方程为：<br> ①满足(2)(3)中任意一个，<strong>dp[i] = dp[i - 1] + 1</strong>（这个1是自己,dp[i - 1]是拼在别人后面)<br> ②不满足(2)(3)，<strong>dp[i] = 1</strong></p> </li><li> <p>初始化<br> 每个位置最少也有自己单独一个的情况，所以<strong>全都初始化为1</strong>。</p> </li><li> <p>填表顺序<br> 保证填当前状态时，所需状态已经计算过，<strong>填表顺序很明显是从左往右</strong></p> </li><li> <p>返回值<br> 这个题目最需要注意的就是对dp表数据的处理，因为<strong>dp表中可能有大量重复的数据</strong>，比如"abcdcd"中’d’字符出现了两次，"cd"和"d"这两个字符串在dp表中是多次记录了的，我们需要对dp表数据进行去重。<br><br> 每个字符都对应了固定的ASCLL码，因此可以可以创建⼀个大小为 26 的数组，遍历dp表，对于出现多次的字符，<strong>只需保留以该字符为结尾的最大dp值</strong>。<br><br> <strong>去重完成后再进行累加</strong>就可以得到结果。</p> </li></ol> 
<ul><li>代码实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findSubstringInWraproundString</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//base是abcd……连续的</span>
        <span class="token comment">//s[i]表示现在位置</span>
        <span class="token comment">//所以字串要存在要么s[i] == s[i - 1] + 1</span>
        <span class="token comment">//要么(s[i - 1] == 'z' &amp;&amp; a[i]=='a') </span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//dp[i]：以i位置为结尾并且在base中出现的子字符串数</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'z'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 这个1是自己</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> hash<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//遍历一次，统计对应字符最大的出现次数</span>
        <span class="token comment">//"abcdd"这样的后面那个d的1是无效的，要去掉</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
            hash<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//最后累加</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> hash<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            sum <span class="token operator">+=</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
        <span class="token comment">//时间复杂度：O(N)</span>
        <span class="token comment">//空间复杂度：O(N)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a7b84914af641fee942e72cef0150037/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu系统下多个的python版本，设置默认python和pip</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1334b8dfff875bce0c97d25812df8881/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">中文大语言模型 Llama-2 7B（或13B） 本地化部署 （国内云服务器、GPU单卡16GB、中文模型、WEB页面TextUI、简单入门）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>