<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之队列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5d8c3ba77a3d43f2317fb7e940c4a071/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之队列">
  <meta property="og:description" content="队列 概念 概念：只允许在⼀端进⾏插⼊数据操作，在另⼀端进⾏删除数据操作的特殊线性表，队列具有先进先 出FIFO(First In First Out)
⼊队列：进⾏插⼊操作的⼀端称为队尾
出队列：进⾏删除操作的⼀端称为队头
队列底层结构选型
队列也可以数组和链表的结构实现，使⽤链表的结构实现更优⼀些，因为如果使⽤数组的结构，出队 列在数组头上出数据，效率会⽐较低。
原因如下：
结构 //定义队列节点结构 struct	QueueNode { int data; struct QueueNode*next; } struct Queue { struct QueueNode*phead; struct QueueNode*tail; } 队列的底层是链表，但是这里和单链表不同的是要写两个结构体，因为一个是确认底层的，还有一个是确定队列的结构的，因为队列要有队头和队尾
入队列 需要进行分类讨论：队列不为空和队列为空两种情况
如果队列不为空我们需要尾插一个新元素，然后让ptail指向新元素，如果队列为空，让phead=ptail指向新的元素
代码如下：
// ⼊队列，队尾 void QueuePush(Queue* pq, QDataType x) { assert(pq); //申请新节点 QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode)); if (newnode == NULL) { perror(&#34;malloc fail!&#34;); exit(1); } newnode-&gt;data = x; newnode-&gt;next = NULL; //ptail newnode if (pq-&gt;phead == NULL) { //队列为空 pq-&gt;phead = pq-&gt;ptail = newnode; } else { //队列不为空 pq-&gt;ptail-&gt;next = newnode; pq-&gt;ptail = newnode; } pq-&gt;size&#43;&#43;; } 出队列 和栈出数据非常的相似都需要判断队列是否为空 队列为空，不可出队列；队列不为空，可以出队列">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T21:35:00+08:00">
    <meta property="article:modified_time" content="2024-07-26T21:35:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>队列</h2> 
<h3><a id="_2"></a>概念</h3> 
<p>概念：只允许在⼀端进⾏插⼊数据操作，在另⼀端进⾏删除数据操作的特殊线性表，队列具有<mark>先进先 出</mark>FIFO(First In First Out)</p> 
<p><strong>⼊队列</strong>：进⾏插⼊操作的⼀端称为队尾</p> 
<p><strong>出队列</strong>：进⾏删除操作的⼀端称为队头<br> <img src="https://images2.imgbox.com/ee/51/uwJgXWz6_o.png" alt="在这里插入图片描述"></p> 
<p>队列底层结构选型</p> 
<p>队列也可以数组和链表的结构实现，使⽤链表的结构实现更优⼀些，因为如果使⽤数组的结构，出队 列在数组头上出数据，效率会⽐较低。</p> 
<p>原因如下：<br> <img src="https://images2.imgbox.com/75/b5/gg4v9tar_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_20"></a>结构</h3> 
<pre><code class="prism language-C">//定义队列节点结构
struct	QueueNode
{
    int data;
    struct QueueNode*next;
}
struct Queue
{
    struct QueueNode*phead;
    struct QueueNode*tail;
}
</code></pre> 
<p>队列的底层是<mark>链表</mark>，但是这里和单链表不同的是要写两个结构体，因为一个是确认底层的，还有一个是确定队列的结构的，因为队列要有队头和队尾</p> 
<h3><a id="_38"></a>入队列</h3> 
<p>需要进行分类讨论：队列不为空和队列为空两种情况</p> 
<p><img src="https://images2.imgbox.com/95/cc/TVsTMlqp_o.png" alt="在这里插入图片描述"></p> 
<p>如果队列不为空我们需要尾插一个新元素，然后让ptail指向新元素，如果队列为空，让phead=ptail指向新的元素</p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">// ⼊队列，队尾
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	//申请新节点
	QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode));
	if (newnode == NULL)
	{
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	//ptail newnode
	if (pq-&gt;phead == NULL)
	{
		//队列为空
		pq-&gt;phead = pq-&gt;ptail = newnode;
	}
	else
	{
		//队列不为空
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
	}
	pq-&gt;size++;
}
</code></pre> 
<h3><a id="_79"></a>出队列</h3> 
<p>和栈出数据非常的相似都需要判断队列是否为空 <mark>队列为空，不可出队列；队列不为空，可以出队列</mark></p> 
<p>但是这里也需要注意两种情况</p> 
<ul><li>有多个节点的情况下</li><li>只有一个节点的情况下</li></ul> 
<p><img src="https://images2.imgbox.com/65/98/NQOqbncJ_o.png" alt="在这里插入图片描述"></p> 
<p>当队列不为空的时候采取头删的方式，然后将phead移向下一节点，如果为空，释放phead</p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">//队列判空
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq-&gt;phead &amp;&amp; pq-&gt;ptail == NULL;
}
// 出队列，队头
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));
	//只有一个节点的情况,避免ptail变成野指针
	if (pq-&gt;phead == pq-&gt;ptail)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	else
	{
		//删除队头元素
		QueueNode* next = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = next;
	}
	--pq-&gt;size;
}
</code></pre> 
<h3><a id="_124"></a>求有效元素个数</h3> 
<pre><code class="prism language-C">// ⼊队列，队尾
pq-&gt;size++;
// 出队列，队头
--pq-&gt;size;
</code></pre> 
<p><mark>元素个数，作为下标的话，指向的是最后一个有效元素的下一个位置</mark></p> 
<h3><a id="_135"></a>源码</h3> 
<p>Queue.h</p> 
<pre><code class="prism language-C">#pragma once
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

//定义队列结构
typedef int	QDataType;
typedef struct QueueNode
{
	int data;
	struct QueueNode* next;
}QueueNode;
 typedef struct Queue
{
	QueueNode*phead;
	QueueNode*ptail;
	int size;//保存队列有效数据个数
}Queue;
 //初始化队列
 void QueueInit(Queue* pq);
 // ⼊队列，队尾
 void QueuePush(Queue* pq, QDataType x);
 // 出队列，队头
 void QueuePop(Queue* pq);
 //队列判空
 bool QueueEmpty(Queue* pq);
 //取队头数据
 QDataType QueueFront(Queue* pq);
 //取队尾数据
 QDataType QueueBack(Queue* pq);
 //队列有效元素个数
 int QueueSize(Queue* pq);
 //销毁队列
 void QueueDestroy(Queue* pq);
</code></pre> 
<p>Queue.c</p> 
<pre><code class="prism language-C">#define _CRT_SECURE_NO_WARNINGS 1
#include "Queue.h"
//初始化队列
void QueueInit(Queue* pq)
{
	assert(pq);
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
// ⼊队列，队尾
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	//申请新节点
	QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode));
	if (newnode == NULL)
	{
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	//ptail newnode
	if (pq-&gt;phead == NULL)
	{
		//队列为空
		pq-&gt;phead = pq-&gt;ptail = newnode;
	}
	else
	{
		//队列不为空
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
	}
	pq-&gt;size++;
}
//队列判空
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq-&gt;phead &amp;&amp; pq-&gt;ptail == NULL;
}
// 出队列，队头
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));
	//只有一个节点的情况,避免ptail变成野指针
	if (pq-&gt;phead == pq-&gt;ptail)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	else
	{
		//删除队头元素
		QueueNode* next = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = next;
	}
	--pq-&gt;size;
}
//取队头数据
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));
	return pq-&gt;phead-&gt;data;
}
//取队尾数据
QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));
	return pq-&gt;ptail-&gt;data;
}
//队列有效元素个数
int QueueSize(Queue* pq)
{
	assert(pq);
	/*int size = 0;
	QueueNode* pcur = pq-&gt;phead;
	while (pcur)
	{
		size++;
		pcur = pcur-&gt;next;
	}
	return size;*/
	return pq-&gt;size;
}
//销毁队列
void QueueDestroy(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));
	QueueNode* pcur = pq-&gt;phead;
	while (pcur)
	{
		QueueNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
</code></pre> 
<p>test.c</p> 
<pre><code class="prism language-C">#define _CRT_SECURE_NO_WARNINGS 1
#include "Queue.h"
void QueueTest01()
{
	Queue q;
	QueueInit(&amp;q);
	QueuePush(&amp;q, 1);
	QueuePush(&amp;q, 2);
	QueuePush(&amp;q, 3);
	QueuePush(&amp;q, 4);
	
	//QueuePop(&amp;q);

	//printf("head:%d\n", QueueFront(&amp;q));
	//printf("tail:%d\n", QueueBack(&amp;q));
	printf("size:%d\n", QueueSize(&amp;q));

	QueueDestroy(&amp;q);
}
int main()
{
	QueueTest01();
	return 0;
}
</code></pre> 
<h3><a id="VS_316"></a>栈VS队列</h3> 
<p><img src="https://images2.imgbox.com/94/c1/t3JjNLQh_o.png" alt="在这里插入图片描述"></p> 
<p>栈的结构图</p> 
<p><mark>栈的特性：先进后出（后进先出）</mark></p> 
<p>栈的底层结构是<strong>数组</strong></p> 
<p>逻辑结构：线性的</p> 
<p>物理结构：线性的</p> 
<p><img src="https://images2.imgbox.com/c1/e3/ikJVBKvP_o.png" alt="在这里插入图片描述"></p> 
<p>队列的结构图</p> 
<p>队列的底层结构是<strong>单链表</strong></p> 
<p>逻辑结构：线性的</p> 
<p>物理结构：不一定是线性的</p> 
<h3><a id="_342"></a>算法题：用队列实现栈</h3> 
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p> 
<p>实现 <code>MyStack</code> 类：</p> 
<ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul> 
<p><strong>注意：</strong></p> 
<ul><li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul> 
<p><strong>示例：</strong></p> 
<pre><code>输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul> 
<p>思路：</p> 
<p>首先要想到队列的性质：<mark>先进先出</mark>和栈的性质：<mark>先进后出</mark></p> 
<p>接下来来好好看这道题的思路</p> 
<ul><li>创建两个队列Q1,Q2</li></ul> 
<p><img src="https://images2.imgbox.com/fa/55/KNQshLwW_o.png" alt="在这里插入图片描述"></p> 
<p>我们举个例子：</p> 
<p>拿1，2，3，4这四个数字举例子</p> 
<p><strong>出栈</strong>：<mark>找不为空的队列，将size-1个数据导入到另一个队列中</mark></p> 
<p><strong>入栈</strong>：往不为空队列中插入数据</p> 
<p><strong>取栈顶元素</strong>：找不为空的队列，取队尾元素 （<mark>不出栈</mark>）</p> 
<p>步骤如下：</p> 
<ul><li>插入1，2，3</li><li>出栈一次</li><li>插入4</li><li>全部出栈</li></ul> 
<p><mark>必须保证其中至少一个队列为空</mark></p> 
<p>代码如下：</p> 
<p><img src="https://images2.imgbox.com/65/3d/qUe08DoC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2c/29/SsZv9gb6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/20/af/TGMGAcST_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/de/d4/DtKsh64k_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/76/f6/V5A1jrhI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1c/68/N5LjgvjY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_428"></a>算法题：用栈实现队列</h3> 
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p> 
<p>实现 <code>MyQueue</code> 类：</p> 
<ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul> 
<p><strong>说明：</strong></p> 
<ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul> 
<p>思路：</p> 
<p>创建两个栈 pushST,popST</p> 
<p><img src="https://images2.imgbox.com/46/4a/As1hljqf_o.png" alt="在这里插入图片描述"></p> 
<p><strong>入队</strong>：往pushST中插入数据</p> 
<p><strong>出队</strong>：判断popST是否为空，不为空直接出数据（pop）；为空的话，将pushST中的数据导入到popST中再pop出去</p> 
<p><strong>取队头元素</strong>：跟出队一样，但是这里只取数据不pop出去</p> 
<p>代码如下：<br> <img src="https://images2.imgbox.com/81/d7/8Mz2mKSC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1b/e9/HWbGbt6X_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_497"></a>算法题：设计循环队列（<mark>非常硬核</mark>）</h3> 
<p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p> 
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p> 
<p>你的实现应该支持如下操作：</p> 
<ul><li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li><li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li><li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li><li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li><li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li><li><code>isEmpty()</code>: 检查循环队列是否为空。</li><li><code>isFull()</code>: 检查循环队列是否已满。</li></ul> 
<p><strong>示例：</strong></p> 
<pre><code>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li>所有的值都在 0 至 1000 的范围内；</li><li>操作数将在 1 至 1000 的范围内；</li><li>请不要使用内置的队列库。</li></ul> 
<p><strong>思路</strong>：</p> 
<p>我们知道队列的底层结构是链表，但是也是可以通过数组的形式实现的。</p> 
<p>假设用<strong>链表</strong>来解决问题</p> 
<p><img src="https://images2.imgbox.com/c9/db/K8WN2GQv_o.png" alt="在这里插入图片描述"></p> 
<p>如果数据满了，我们需要删除数据会比较繁琐，要先保留头节点的下一节点，然后phead向后走，最前面置空；链表还存在指针的消耗</p> 
<p>如果用<strong>数组</strong>解决问题</p> 
<p><img src="https://images2.imgbox.com/27/96/U3jveIB1_o.png" alt="在这里插入图片描述"></p> 
<p>因为<mark>插入数据：循环队列满了，就不能插入数据了</mark></p> 
<p>优点在于<strong>空间固定</strong>，更推荐底层结构为数组</p> 
<ul><li>创建两个变量，front表示开头的位置，rear表示最后的位置，但是front==rear 无法判断究竟是空间已经满了还是说空了</li><li><img src="https://images2.imgbox.com/67/56/ftoNOX7T_o.png" alt="在这里插入图片描述"></li></ul> 
<p>多申请出来的一块空间是用来占位置的，来判断是否满了。</p> 
<p>这样子做有什么好处呢？不用去额外申请一个结构体变量去计算有效元素个数，提高程序的效率</p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">//定义循环队列的结构
typedef struct {
    int* arr;//大小不确定，所以要动态开辟
    int front;//头
    int rear;//尾
    int capacity;
} MyCircularQueue;


MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* pst = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    pst-&gt;arr = (int*)malloc(sizeof(int) * (k + 1));
    pst-&gt;front = pst-&gt;rear = 0;
    pst-&gt;capacity = k;
    return pst;
}

bool myCircularQueueIsFull(MyCircularQueue* obj)
{
    return (obj-&gt;rear + 1) % (obj-&gt;capacity + 1) == obj-&gt;front;
}
bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    //队列满了，不能插入数据
    if (myCircularQueueIsFull(obj))
    {
        return false;
    }
    obj-&gt;arr[obj-&gt;rear++] = value;
    obj-&gt;rear %= obj-&gt;capacity + 1;//obj-&gt;rear=obj-&gt;rear%(obj-&gt;capacity+1);
    return true;
}
bool myCircularQueueIsEmpty(MyCircularQueue* obj)
{
    return obj-&gt;rear == obj-&gt;front;
}
bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    //队列不为空
    if (myCircularQueueIsEmpty(obj))
    {
        return false;
    }
    //队列不为空
    obj-&gt;front++;
    obj-&gt;front %= obj-&gt;capacity + 1;
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj))
    {
        return -1;
    }
    return obj-&gt;arr[obj-&gt;front];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj))
    {
        return -1;
    }
    int prev = obj-&gt;rear - 1;//这里创建变量是为了防止rear=0的时候再-1导致越界
    if (obj-&gt;rear == 0)
    {
        prev = obj-&gt;capacity;//此时prev走的相当于是数组大小
    }
    return obj-&gt;arr[prev];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj-&gt;arr);
    free(obj);
    obj = NULL;//和销毁顺序表相似，顺序表底层是数组
}

/**
 * Your MyCircularQueue struct will be instantiated and called as such:
 * MyCircularQueue* obj = myCircularQueueCreate(k);
 * bool param_1 = myCircularQueueEnQueue(obj, value);

 * bool param_2 = myCircularQueueDeQueue(obj);

 * int param_3 = myCircularQueueFront(obj);

 * int param_4 = myCircularQueueRear(obj);

 * bool param_5 = myCircularQueueIsEmpty(obj);

 * bool param_6 = myCircularQueueIsFull(obj);

 * myCircularQueueFree(obj);
*/
</code></pre> 
<p>感谢还能看到这里的你，祝你天天开心，每天有所进步！！！<br> <img src="https://images2.imgbox.com/1e/f8/jTC19PVV_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58c71e1622273409a34e14b80b0ae3e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Blackbox AI-跨时代AI产物，你的私人编程助手</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3afcd3db91ea9bb00e2dedd1d4bf2f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker安装 OpenResty详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>