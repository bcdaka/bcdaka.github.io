<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据库】锁表原因及处理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ee2b6a0d3935e1b504586e13417a223b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据库】锁表原因及处理">
  <meta property="og:description" content="文章目录 什么是数据库锁表？数据库锁表可能会导致什么问题？死锁问题的原因分析如何避免数据库锁表？解决死锁问题的常用策略解决死锁问题mysql锁表处理ORACEL数据库锁表处理SQL Server数据库锁表处理 来源 什么是数据库锁表？ 答：数据库锁表是指在数据库中，为了保证数据的一致性和完整性，可能会对数据进行加锁，以避免并发操作引起的数据冲突。如果锁定的范围过大或时间过长，可能会导致数据库表被锁定，从而影响系统性能。
数据库锁表可能会导致什么问题？ 数据库锁表可能会导致系统性能下降、用户体验不佳、系统崩溃等问题。当数据库表被锁定时，其他用户的查询和操作可能会受到影响，从而导致系统运行缓慢甚至崩溃。
死锁问题的原因分析 事务执行顺序：当多个事务按不同的顺序请求和释放资源时，可能会产生死锁的可能性，这是因为事务的执行顺序无法保证一致性。
例如事务的执行时间过长、事务的锁定范围过大、索引使用不当、SQL语句优化不足等。当出现大量并发操作时，出现竞争资源：当多个事务同时请求和持有相同的资源，如行级锁，表级锁等，可能会导致死锁问题的发生。
如何避免数据库锁表？ 减少事务的时间减少事务的范围合理使用索引优化SQL语句分布式事务 解决死锁问题的常用策略 死锁检测和处理：MySQL提供了死锁检测机制，可以通过设置参数innodb_deadlock_detect来启用，当检测到死锁时，可以选择回滚某些事务以解除死锁。但这种方法不能完全避免死锁的发生，而且会增加系统的开销。加锁顺序：通过约定事务对资源的访问顺序，使得所有事务按相同的顺序请求锁定，可以避免死锁的发生。然而，这种方法需要根据具体的业务需求和数据访问模式来设计，且不适用于复杂的场景。降低事务隔离级别：将事务的隔离级别降低至READ
COMMITTED，可以减少死锁的机会。但这也会导致数据一致性的问题，需要在业务层做相应的处理。超时机制：对于长时间持有锁资源的事务，可以设置超时时间，在超时后自动回滚事务，以避免死锁的发生。这种方法需要谨慎设置超时时间，避免正常事务被错误回滚。优化SQL语句优化表结构和索引分库分表引入缓存等技术 解决死锁问题 mysql锁表处理 查看进程id，然后用kill id杀掉进程
processlist展示了对应的数据库有哪些线程在运行，如果有些语句执行速度慢，可以在里面看到
show processlist; 根据不同的账号权限可以看到所有用户的，当前用户的对应的连接。只有100条
show full processlist: 展示所有的连接数据
SELECT * FROM information_schema.PROCESSLIST； 查询正在执行的进程
SELECT * FROM information_schema.PROCESSLIST where length(info) &gt;0 ; 字段说明
ID 连接标识符，这个ID和show processlist 中ID是一样的，也和Performance Schema 中threads表的PROCESSLIST_ID 栏位是一样的，也和CONNECTION_ID()函数返回的是一样的
USER 连接的用户，其中system user代表系统用户，非用户连接，unauthenticated user代表是用户连接，但是未完成认证，event_scheduler 用户代表的是监控定时任务的用户
HOST 连接的主机名，如果用户是system user，则HOST为空
DB 连接的数据库，如果未选择数据库，则为NULL
COMMAND 线程执行的命令类型
TIME 线程在当前状态持续的时间，以秒为单位
STATE 线程当前的状态，如果该状态持续很久，说明有问题，如果是SHOW PROCESSLIST 命令，则状态为NULL
INFO 线程执行的具体命令，如果执行的是call procedure，这里可能显示的是内容的语句，如select">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-03T11:49:38+08:00">
    <meta property="article:modified_time" content="2024-04-03T11:49:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据库】锁表原因及处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">什么是数据库锁表？</a></li><li><a href="#_4" rel="nofollow">数据库锁表可能会导致什么问题？</a></li><li><a href="#_7" rel="nofollow">死锁问题的原因分析</a></li><li><a href="#_12" rel="nofollow">如何避免数据库锁表？</a></li><li><a href="#_20" rel="nofollow">解决死锁问题的常用策略</a></li><li><a href="#_32" rel="nofollow">解决死锁问题</a></li><li><ul><li><a href="#mysql_34" rel="nofollow">mysql锁表处理</a></li><li><a href="#ORACEL_119" rel="nofollow">ORACEL数据库锁表处理</a></li><li><a href="#SQL_Server_217" rel="nofollow">SQL Server数据库锁表处理</a></li></ul> 
  </li><li><a href="#_262" rel="nofollow">来源</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>什么是数据库锁表？</h2> 
<p>答：数据库锁表是指在数据库中，为了保证数据的一致性和完整性，可能会对数据进行加锁，以避免并发操作引起的数据冲突。如果锁定的范围过大或时间过长，可能会导致数据库表被锁定，从而影响系统性能。</p> 
<h2><a id="_4"></a>数据库锁表可能会导致什么问题？</h2> 
<p>数据库锁表可能会导致系统性能下降、用户体验不佳、系统崩溃等问题。当数据库表被锁定时，其他用户的查询和操作可能会受到影响，从而导致系统运行缓慢甚至崩溃。</p> 
<h2><a id="_7"></a>死锁问题的原因分析</h2> 
<p>事务执行顺序：当多个事务按不同的顺序请求和释放资源时，可能会产生死锁的可能性，这是因为事务的执行顺序无法保证一致性。</p> 
<p>例如事务的执行时间过长、事务的锁定范围过大、索引使用不当、SQL语句优化不足等。当出现大量并发操作时，出现竞争资源：当多个事务同时请求和持有相同的资源，如行级锁，表级锁等，可能会导致死锁问题的发生。</p> 
<h2><a id="_12"></a>如何避免数据库锁表？</h2> 
<ul><li>减少事务的时间</li><li>减少事务的范围</li><li>合理使用索引</li><li>优化SQL语句</li><li>分布式事务</li></ul> 
<h2><a id="_20"></a>解决死锁问题的常用策略</h2> 
<ul><li>死锁检测和处理：MySQL提供了死锁检测机制，可以通过设置参数innodb_deadlock_detect来启用，当检测到死锁时，可以选择回滚某些事务以解除死锁。但这种方法不能完全避免死锁的发生，而且会增加系统的开销。</li><li>加锁顺序：通过约定事务对资源的访问顺序，使得所有事务按相同的顺序请求锁定，可以避免死锁的发生。然而，这种方法需要根据具体的业务需求和数据访问模式来设计，且不适用于复杂的场景。</li><li>降低事务隔离级别：将事务的隔离级别降低至READ<br> COMMITTED，可以减少死锁的机会。但这也会导致数据一致性的问题，需要在业务层做相应的处理。</li><li>超时机制：对于长时间持有锁资源的事务，可以设置超时时间，在超时后自动回滚事务，以避免死锁的发生。这种方法需要谨慎设置超时时间，避免正常事务被错误回滚。</li><li>优化SQL语句</li><li>优化表结构和索引</li><li>分库分表</li><li>引入缓存等技术</li></ul> 
<h2><a id="_32"></a>解决死锁问题</h2> 
<h3><a id="mysql_34"></a>mysql锁表处理</h3> 
<p><strong>查看进程id，然后用kill id杀掉进程</strong><br> processlist展示了对应的数据库有哪些线程在运行，如果有些语句执行速度慢，可以在里面看到</p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> processlist<span class="token punctuation">;</span>
</code></pre> 
<p><strong>根据不同的账号权限可以看到所有用户的，当前用户的对应的连接。只有100条</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> <span class="token keyword">full</span> processlist:
</code></pre> 
<p><strong>展示所有的连接数据</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>PROCESSLIST；
</code></pre> 
<p><strong>查询正在执行的进程</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>PROCESSLIST <span class="token keyword">where</span> length<span class="token punctuation">(</span>info<span class="token punctuation">)</span> <span class="token operator">&gt;</span><span class="token number">0</span> <span class="token punctuation">;</span>
</code></pre> 
<p><strong>字段说明</strong></p> 
<p>ID 连接标识符，这个ID和show processlist 中ID是一样的，也和Performance Schema 中threads表的PROCESSLIST_ID 栏位是一样的，也和CONNECTION_ID()函数返回的是一样的<br> USER 连接的用户，其中system user代表系统用户，非用户连接，unauthenticated user代表是用户连接，但是未完成认证，event_scheduler 用户代表的是监控定时任务的用户<br> HOST 连接的主机名，如果用户是system user，则HOST为空<br> DB 连接的数据库，如果未选择数据库，则为NULL<br> COMMAND 线程执行的命令类型<br> TIME 线程在当前状态持续的时间，以秒为单位<br> STATE 线程当前的状态，如果该状态持续很久，说明有问题，如果是SHOW PROCESSLIST 命令，则状态为NULL<br> INFO 线程执行的具体命令，如果执行的是call procedure，这里可能显示的是内容的语句，如select</p> 
<p><strong>查询是否锁表</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> <span class="token keyword">OPEN</span>  <span class="token keyword">TABLES</span> <span class="token keyword">where</span> In_use <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>字段说明</strong><br> Database 含有该表的数据库。<br> Table 表名称。<br> In_use 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。<br> Name_locked 表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作</p> 
<p><strong>查看被锁住的</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCKS<span class="token punctuation">;</span>
</code></pre> 
<p>innodb_locks提供有关InnoDB 事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的每个锁。</p> 
<p><strong>字段说明</strong><br> lock_id：锁 ID。<br> lock_trx_id：拥有锁的事务 ID。可以和 INNODB_TRX 表 JOIN 得到事务的详细信息。<br> lock_mode：锁的模式。有如下锁类型：行级锁包括：S、X、IS、IX，分别代表：共享锁、排它锁、意向共享锁、意向排它锁。表级锁包括：S_GAP、X_GAP、IS_GAP、IX_GAP 和 AUTO_INC，分别代表共享间隙锁、排它间隙锁、意向共享间隙锁、意向排它间隙锁和自动递增锁。<br> lock_type：锁的类型。RECORD 代表行级锁，TABLE 代表表级锁。<br> lock_table：被锁定的或者包含锁定记录的表的名称。<br> lock_index：当 LOCK_TYPE=’RECORD’ 时，表示索引的名称；否则为 NULL。<br> lock_space：当 LOCK_TYPE=’RECORD’ 时，表示锁定行的表空间 ID；否则为 NULL。<br> lock_page：当 LOCK_TYPE=’RECORD’ 时，表示锁定行的页号；否则为 NULL。<br> lock_rec：当 LOCK_TYPE=’RECORD’ 时，表示一堆页面中锁定行的数量，亦即被锁定的记录号；否则为 NULL。<br> lock_data：当 LOCK_TYPE=’RECORD’ 时，表示锁定行的主键；否则为NULL。</p> 
<p><strong>等待锁定</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCK_WAITS<span class="token punctuation">;</span>
</code></pre> 
<p>innodb_lock_waits包含每个被阻止InnoDB 事务的一个或多个行，指示它已请求的锁以及阻止该请求的任何锁。</p> 
<p><strong>字段说明</strong><br> requesting_trx_id：请求事务的 ID。<br> requested_lock_id：事务所等待的锁定的 ID。可以和 INNODB_LOCKS 表 JOIN。<br> blocking_trx_id：阻塞事务的 ID。<br> blocking_lock_id：某一事务的锁的 ID，该事务阻塞了另一事务的运行。可以和 INNODB_LOCKS 表 JOIN<br> <strong>杀掉锁表进程</strong><br> kill 5601</p> 
<h3><a id="ORACEL_119"></a>ORACEL数据库锁表处理</h3> 
<p><strong>第一步：通过管理员权限用户查询被锁表信息</strong><br> 如果怀疑表被锁了，或者事务未被正常关闭，在Oracle数据库中我们可以通过以下语句进行查询获取相关信息：</p> 
<pre><code class="prism language-sql"> <span class="token keyword">select</span> t2<span class="token punctuation">.</span>username<span class="token punctuation">,</span>    t2<span class="token punctuation">.</span>sid<span class="token punctuation">,</span>    t2<span class="token punctuation">.</span><span class="token keyword">serial</span><span class="token comment">#,    t3.object_name,  t2.OSUSER,  t2.MACHINE,</span>
        t2<span class="token punctuation">.</span>PROGRAM<span class="token punctuation">,</span>  t2<span class="token punctuation">.</span>LOGON_TIME<span class="token punctuation">,</span>  t2<span class="token punctuation">.</span>COMMAND<span class="token punctuation">,</span>   t2<span class="token punctuation">.</span>LOCKWAIT<span class="token punctuation">,</span>
        t2<span class="token punctuation">.</span>SADDR<span class="token punctuation">,</span>   t2<span class="token punctuation">.</span>PADDR<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>TADDR<span class="token punctuation">,</span>   t2<span class="token punctuation">.</span>SQL_ADDRESS<span class="token punctuation">,</span>   t1<span class="token punctuation">.</span>LOCKED_MODE
   <span class="token keyword">from</span> v$locked_object t1<span class="token punctuation">,</span> v$<span class="token keyword">session</span> t2<span class="token punctuation">,</span> dba_objects t3
  <span class="token keyword">where</span> t1<span class="token punctuation">.</span>session_id <span class="token operator">=</span> t2<span class="token punctuation">.</span>sid
    <span class="token operator">and</span> t1<span class="token punctuation">.</span>object_id <span class="token operator">=</span> t3<span class="token punctuation">.</span>object_id
  <span class="token keyword">order</span> <span class="token keyword">by</span> t2<span class="token punctuation">.</span>logon_time<span class="token punctuation">;</span>
</code></pre> 
<p>大家发现，上面这条SQL语句用到了Oracle的两个视图和一个表，分别是<code>v$locked_object</code>、<code>v$session</code>、<code>dba_objects</code></p> 
<p><code>v$locked_object</code>视图中记录了所有session中的所有被锁定的对象信息。 v locked_object 视图中记录了所有session中的所有被锁定的对象信息。<code>v$session</code>视图记录了所有session的相关信息。<br> <code>dba_objects</code>为oracle用户对象及系统对象的集合，通过关联这张表能够获取被锁定对象的详细信息。</p> 
<p>eg：现在我通过scott用户执行DML语句（eg：select * from emp for update;或者update scott.emp set sal = ‘2000’ where empno=‘7788’; ）之后一直不进行提交，然后通过system用户执行上面的查询oracle中被锁表的sql语句，就会找到如下记录：</p> 
<p>说明：</p> 
<pre><code class="prism language-sql">username：oracle用户名
sid：进程号
<span class="token keyword">serial</span><span class="token comment">#：序列号</span>
object_name：表名
osuser：操作系统用户名
machine：机器名
program：操作工具
logon_time：登陆时间
lockwait：表示当前这张表是否正在等待其他用户解锁这张表
locked_mode：锁表模式（下面详细说明）
</code></pre> 
<p>注意：这时候如果通过system用户执行select * from scott.emp for update;语句就无法成功执行。</p> 
<p><strong>第二步：通过拥有管理员权限的用户解除数据库中被锁住的表(SID,SERIAL)</strong><br> 通过第一步查出来的信息找到被锁的表之后执行如下语句解锁该表：</p> 
<pre><code class="prism language-sql"><span class="token keyword">alter</span> system <span class="token keyword">kill</span> <span class="token keyword">session</span> ‘sid<span class="token punctuation">,</span>seial<span class="token comment">#’;</span>
</code></pre> 
<p>注意：sid和seial#就是第一步中查询出来的进程号和序列号。</p> 
<p>eg：解除第一步中表的锁</p> 
<pre><code class="prism language-sql"><span class="token keyword">alter</span> system <span class="token keyword">kill</span> <span class="token keyword">session</span> ‘<span class="token number">10</span><span class="token punctuation">,</span><span class="token number">15</span>’<span class="token punctuation">;</span>
</code></pre> 
<p>现在通过system再次执行DML语句（eg：select * from scott.emp for update;或update scott.emp set sal = ‘2000’ where empno=‘7788’;）就可以了。</p> 
<p><strong>锁的模式</strong><br> v$locked_object中的LOCKED_MODE字段表示锁的模式，oracle中锁的模式有如下几种:</p> 
<pre><code class="prism language-sql"><span class="token number">0</span>：none
<span class="token number">1</span>：<span class="token boolean">null</span> 空
<span class="token number">2</span>：<span class="token keyword">Row</span><span class="token operator">-</span>S 行共享<span class="token punctuation">(</span>RS<span class="token punctuation">)</span>：共享表锁，sub <span class="token keyword">share</span>
<span class="token number">3</span>：<span class="token keyword">Row</span><span class="token operator">-</span>X 行独占<span class="token punctuation">(</span>RX<span class="token punctuation">)</span>：用于行的修改，sub exclusive
<span class="token number">4</span>：<span class="token keyword">Share</span> 共享锁<span class="token punctuation">(</span>S<span class="token punctuation">)</span>：阻止其他DML操作，<span class="token keyword">share</span>
<span class="token number">5</span>：S<span class="token operator">/</span><span class="token keyword">Row</span><span class="token operator">-</span>X 共享行独占<span class="token punctuation">(</span>SRX<span class="token punctuation">)</span>：阻止其他事务操作，<span class="token keyword">share</span><span class="token operator">/</span>sub exclusive
<span class="token number">6</span>：exclusive 独占<span class="token punctuation">(</span>X<span class="token punctuation">)</span>：独立访问使用，exclusive
</code></pre> 
<p>数字越大锁级别越高, 影响的操作越多。</p> 
<p>1级锁有： Select，有时会在v$locked_object出现。<br> 2级锁有： Select for update,Lock For Update,Lock Row Share<br> select for update当对话使用for update子串打开一个游标时，所有返回集中的数据行都将处于行级(Row-X)独占式锁定，其他对象只能查询这些数据行，不能进行update、delete或select for update操作。<br> 3级锁有： Insert, Update, Delete, Lock Row Exclusive<br> 没有commit之前插入同样的一条记录会没有反应, 因为后一个3的锁会一直等待上一个3的锁, 我们必须释放掉上一个才能继续工作。<br> 4级锁有： Create Index, Lock Share<br> locked_mode为2,3,4不影响DML(insert,delete,update,select)操作, 但DDL(alter,drop等)操作会提示ora-00054错误。<br> 00054, 00000, “resource busy and acquire with NOWAIT specified”<br> // *Cause: Resource interested is busy.<br> // *Action: Retry if necessary.<br> 5级锁有： Lock Share Row Exclusive<br> 具体来讲有主外键约束时update / delete … ; 可能会产生4,5的锁。<br> 6级锁有： Alter table, Drop table, Drop Index, Truncate table, Lock Exclusive</p> 
<p><strong>还有一条比较实用的sql：</strong></p> 
<p>查某session 正在执行的sql语句，从而可以快速定位到哪些操作或者代码导致事务一直进行没有结束等.</p> 
<pre><code class="prism language-sql"> <span class="token keyword">SELECT</span> <span class="token comment">/*+ ORDERED */</span> 
  sql_text
   <span class="token keyword">FROM</span> v$sqltext a
  <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>hash_value<span class="token punctuation">,</span> a<span class="token punctuation">.</span>address<span class="token punctuation">)</span> <span class="token operator">IN</span>
        <span class="token punctuation">(</span><span class="token keyword">SELECT</span> DECODE<span class="token punctuation">(</span>sql_hash_value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> prev_hash_value<span class="token punctuation">,</span> sql_hash_value<span class="token punctuation">)</span><span class="token punctuation">,</span>
                DECODE<span class="token punctuation">(</span>sql_hash_value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> prev_sql_addr<span class="token punctuation">,</span> sql_address<span class="token punctuation">)</span>
           <span class="token keyword">FROM</span> v$<span class="token keyword">session</span> b
          <span class="token keyword">WHERE</span> b<span class="token punctuation">.</span>sid <span class="token operator">=</span> <span class="token string">'67'</span><span class="token punctuation">)</span>  <span class="token comment">/* 此处67 为SID*/</span>
  <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> piece <span class="token keyword">ASC</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="SQL_Server_217"></a>SQL Server数据库锁表处理</h3> 
<p><strong>第一步：查询死锁语句</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> dbid<span class="token punctuation">,</span><span class="token operator">*</span> <span class="token keyword">from</span> sys<span class="token punctuation">.</span>sysprocesses
<span class="token keyword">where</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token operator">and</span> spid <span class="token operator">&gt;</span><span class="token number">50</span>
<span class="token operator">and</span> blocked <span class="token operator">&lt;&gt;</span> <span class="token number">0</span>
<span class="token comment">--and spid= 62</span>
</code></pre> 
<p>查询结果如下图所示：<br> <img src="https://images2.imgbox.com/63/b1/hMUGRtwA_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c10d69308de54e4bb772fb23d5f1a31e.png"><br> 以上查询得出:</p> 
<p>受影响的数据库ID 是 5;<br> 受到阻塞的会话有1301、1306、869、109；<br> 阻塞会话是961；</p> 
<p><strong>第二步：查询发生阻塞或死锁的当前数据库</strong><br> 1：通过第一步查询，知道数据库ID 为 DBID=5。</p> 
<p>2：sp_helpdb 或 Select name,dbid from master.sys.sysdatabases 查询数据库名称</p> 
<p><img src="https://images2.imgbox.com/5d/a7/ralWn8ag_o.png" alt="在这里插入图片描述"><br> <strong>第三步：查询发生阻塞或死锁的SQL语句</strong><br> 输出死锁的执行的语句：</p> 
<pre><code class="prism language-sql"><span class="token keyword">dbcc</span> inputbuffer<span class="token punctuation">(</span><span class="token number">961</span><span class="token punctuation">)</span>
</code></pre> 
<p>语句如下：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> o<span class="token punctuation">.</span>tp_Login<span class="token punctuation">,</span>o<span class="token punctuation">.</span>tp_Title<span class="token punctuation">,</span> <span class="token keyword">CONVERT</span><span class="token punctuation">(</span><span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>a<span class="token punctuation">.</span>TimeCreated<span class="token punctuation">,</span><span class="token number">120</span><span class="token punctuation">)</span>  <span class="token keyword">as</span> accessingdate<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> docnum<span class="token punctuation">,</span> <span class="token string">'sps'</span> <span class="token keyword">as</span> <span class="token keyword">type</span>  <span class="token keyword">from</span> UserData u<span class="token punctuation">,</span>AllDocs a<span class="token punctuation">,</span> userinfo o <span class="token punctuation">,</span>webs w <span class="token keyword">where</span> a<span class="token punctuation">.</span>ListId <span class="token operator">=</span> u<span class="token punctuation">.</span>tp_ListId <span class="token operator">and</span> a<span class="token punctuation">.</span>Id <span class="token operator">=</span> u<span class="token punctuation">.</span>tp_docID  <span class="token operator">and</span> w<span class="token punctuation">.</span>Id <span class="token operator">=</span> a<span class="token punctuation">.</span>WebId <span class="token operator">and</span> w<span class="token punctuation">.</span>SiteId <span class="token operator">=</span> a<span class="token punctuation">.</span>SiteId <span class="token operator">and</span> w<span class="token punctuation">.</span>SiteId <span class="token operator">=</span> o<span class="token punctuation">.</span>tp_SiteID <span class="token operator">and</span>
</code></pre> 
<p><strong>第四步：杀死锁</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">kill</span>  <span class="token number">961</span>
</code></pre> 
<p>之后再从第一步进行查询，看是否还存在死锁；</p> 
<p>从第二步、第三步，查询出了出问题的锁死数据库及SQL语句，便于分析彻底解决死锁问题。</p> 
<h2><a id="_262"></a>来源</h2> 
<p><a href="https://baijiahao.baidu.com/s?id=1787619214209852358&amp;wfr=spider&amp;for=pc" rel="nofollow">MySQL事务中遇到死锁问题该如何解决？</a><br> <a href="https://blog.csdn.net/qq_41831448/article/details/128297212">数据库锁表和解锁</a><br> <a href="https://blog.csdn.net/hui1350/article/details/131070429">数据库锁表</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f835aee90d97d7683d1c9c54e952cfc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Web 后台项目，权限如何定义、设置、使用：菜单权限、按钮权限 ts element-ui-Plus</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb23d1f85ae437c9aa9c2618dd5543e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spark&#43;Flink&#43;Kafka环境配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>