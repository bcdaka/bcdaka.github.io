<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】unordered_set和unordered_map的封装（哈希） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/20ece005b236ecbc90dc5f23a4d1596c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】unordered_set和unordered_map的封装（哈希）">
  <meta property="og:description" content="🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
key和pair 仿函数hash
迭代器
operator&#43;&#43;
HashTable.h
my_unordered_map.h
my_unordered_set.h
前言 💬 hello! 各位铁子们大家好哇。
今日更新了unordered_map和unordered_set封装的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
key和pair 前面已经实现了哈希的底层，现用哈希进行封装。
unordered_set和unordered_map的封装和map、set大体思路一样。hash是底层，他并不知道传入的是k还是pair，但是上层的unordered_set和unordered_map知道。所以在hash多传入一个模板参数KeyOfT，这样再在map和set中分别实现取出key的逻辑即可。
仿函数hash 由于hash现在是底层，我们的仿函数不可能直接传给hash底层，所以得在unordered_set和unordered_map上传多一个模板参数，这样取模的仿函数就可以在外面传了。
迭代器 当遍历完一个桶后，准备找下一个桶时，就需要有哈希表，不然就找不到下一个桶，所以iterator需要传第二个参数：哈希表的指针。
operator&#43;&#43; 当当前桶走完了，就要找下一个不为空的桶的第一个节点。循环结束有两种可能，一：所有桶都走完了。二：找到下一个不为空的桶。
HashTable.h #pragma once #include&lt;vector&gt; template&lt;class K&gt; struct HashFunc { size_t operator()(const K&amp; key) { return (size_t)key; //负数、指针都能转 } }; //特化 template&lt;&gt; struct HashFunc&lt;string&gt; { size_t operator()(const string&amp; key) { size_t hash = 0; for (auto ch : key) { hash *= 131; hash &#43;= ch; } return hash; } }; namespace open_address { enum State { EMPTY, EXIST, DELETE }; template&lt;class K, class V&gt; struct HashData { pair&lt;K, V&gt; _kv; State _state = EMPTY; }; template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt; class HashTable { public: HashTable() { _tables.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-19T10:43:59+08:00">
    <meta property="article:modified_time" content="2024-08-19T10:43:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】unordered_set和unordered_map的封装（哈希）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <strong>🌈个人主页：</strong><a href="https://blog.csdn.net/qinjh_?type=blog" title="秦jh_-CSDN博客">秦jh_-CSDN博客</a><br><strong>🔥 系列专栏：</strong><a href="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482" title="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482">https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482</a></p> 
<p> <img alt="9efbcbc3d25747719da38c01b3fa9b4f.gif" src="https://images2.imgbox.com/4e/f9/Tu6dbA3X_o.gif">​ </p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="key%E5%92%8Cpair%C2%A0-toc" style="margin-left:0px;"><a href="#key%E5%92%8Cpair%C2%A0" rel="nofollow">key和pair </a></p> 
<p id="%C2%A0%E4%BB%BF%E5%87%BD%E6%95%B0hash-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BB%BF%E5%87%BD%E6%95%B0hash" rel="nofollow"> 仿函数hash</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">迭代器</a></p> 
<p id="operator%2B%2B-toc" style="margin-left:40px;"><a href="#operator%2B%2B" rel="nofollow">operator++</a></p> 
<p id="HashTable.h-toc" style="margin-left:0px;"><a href="#HashTable.h" rel="nofollow">HashTable.h</a></p> 
<p id="my_unordered_map.h-toc" style="margin-left:0px;"><a href="#my_unordered_map.h" rel="nofollow">my_unordered_map.h</a></p> 
<p id="my_unordered_set.h-toc" style="margin-left:0px;"><a href="#my_unordered_set.h" rel="nofollow">my_unordered_set.h</a></p> 
<hr id="hr-toc"> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>    <strong>💬 hello! 各位铁子们大家好哇。</strong></p> 
 <p><strong>             今日更新了unordered_map和unordered_set封装的相关内容</strong><br>     <strong>🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝</strong></p> 
</blockquote> 
<h2 id="key%E5%92%8Cpair%C2%A0">key和pair </h2> 
<p>前面已经实现了哈希的底层，现用哈希进行封装。</p> 
<p><img alt="" height="838" src="https://images2.imgbox.com/28/07/x39fkjwq_o.png" width="827"><img alt="" height="511" src="https://images2.imgbox.com/9b/8f/vJwrcxt9_o.png" width="977"></p> 
<blockquote> 
 <p>unordered_set和unordered_map的封装和map、set大体思路一样。hash是底层，他并不知道传入的是k还是pair，但是上层的unordered_set和unordered_map知道。所以在hash多传入一个模板参数KeyOfT，这样再在map和set中分别实现取出key的逻辑即可。</p> 
</blockquote> 
<hr> 
<h2 id="%C2%A0%E4%BB%BF%E5%87%BD%E6%95%B0hash"> 仿函数hash</h2> 
<p><img alt="" height="239" src="https://images2.imgbox.com/bc/6d/rMxyS7ja_o.png" width="1035"><img alt="" height="774" src="https://images2.imgbox.com/cc/67/GtYT3Mjs_o.png" width="953"><img alt="" height="541" src="https://images2.imgbox.com/67/b6/I0pGhsll_o.png" width="1020"></p> 
<blockquote> 
 <p> 由于hash现在是底层，我们的仿函数不可能直接传给hash底层，所以得在unordered_set和unordered_map上传多一个模板参数，这样取模的仿函数就可以在外面传了。</p> 
</blockquote> 
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</h2> 
<p><img alt="" height="391" src="https://images2.imgbox.com/05/49/2N2SU4ix_o.png" width="1200"><img alt="" height="827" src="https://images2.imgbox.com/bc/fb/RNrsfebG_o.png" width="1012"></p> 
<blockquote> 
 <p>当遍历完一个桶后，准备找下一个桶时，就需要有哈希表，不然就找不到下一个桶，所以iterator需要传第二个参数：哈希表的指针。</p> 
</blockquote> 
<h3 id="operator%2B%2B">operator++</h3> 
<p><img alt="" height="1128" src="https://images2.imgbox.com/c0/84/mZnuOJjt_o.png" width="915"></p> 
<blockquote> 
 <p>当当前桶走完了，就要找下一个不为空的桶的第一个节点。循环结束有两种可能，一：所有桶都走完了。二：找到下一个不为空的桶。</p> 
</blockquote> 
<h2 id="HashTable.h">HashTable.h</h2> 
<pre><code class="language-cpp">#pragma once 
#include&lt;vector&gt;

template&lt;class K&gt;
struct HashFunc
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key; //负数、指针都能转
	}
};

//特化
template&lt;&gt;
struct HashFunc&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		size_t hash = 0;
		for (auto ch : key)
		{
			hash *= 131;
			hash += ch;
		}
		return hash;
	}
};

namespace open_address
{
	enum State
	{
		EMPTY,
		EXIST,
		DELETE
	};

	template&lt;class K, class V&gt;
	struct HashData
	{
		pair&lt;K, V&gt; _kv;
		State _state = EMPTY;
	};

	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class HashTable
	{
	public:
		HashTable()
		{
			_tables.resize(10);
		}

		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first))  //不允许冗余
				return false;

			//扩容
			if (_n * 10 / _tables.size() &gt;= 7)
			{
				//方法一
				//size_t newsize = _tables.size() * 2;    //用vector的话需要手动映射
				//vector&lt;HashData&lt;K, V&gt;&gt; newtables(newsize);

				旧表重新计算负载到新表
				//for(size_t i=0;i&lt;_tables.size();i++)
				//{ }

				//方法二
				HashTable&lt;K, V, Hash&gt; newHT;
				newHT._tables.resize(_tables.size() * 2);

				//旧表重新计算负载到新表
				for (size_t i = 0; i &lt; _tables.size(); i++)
				{
					if (_tables[i]._state == EXIST)
					{
						newHT.Insert(_tables[i]._kv);//用HashTable对象插入，可以复用Insert，不需要手动映射
					}								 //newHT已经是扩容好的了，就跳过扩容，直接来到探测部分
				}									 //新表插入好后，再跟旧表互换
				_tables.swap(newHT._tables);
			}
			Hash hs;
			size_t hashi = hs(kv.first) % _tables.size();  //不能模capacity,否则会得到比size大的数，而size后面的位置不能用[]得到
			//线性探测
			while (_tables[hashi]._state == EXIST)
			{
				++hashi;
				hashi %= _tables.size(); //如果往后找找不到，就回到前面继续找
			}

			_tables[hashi]._kv = kv;
			_tables[hashi]._state = EXIST;
			++_n;

			return true;
		}

		HashData&lt;K, V&gt;* Find(const K&amp; key)
		{
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			//线性探测
			while (_tables[hashi]._state != EMPTY)
			{
				if (_tables[hashi]._state == EXIST &amp;&amp;
					_tables[hashi]._kv.first == key)
				{
					return &amp;_tables[hashi];
				}
				++hashi;
				hashi %= _tables.size();
			}
			return nullptr;
		}

		bool Erase(const K&amp; key)
		{
			HashData&lt;K, V&gt;* ret = Find(key);
			if (ret == nullptr)
			{
				return false;
			}
			else
			{
				ret-&gt;_state = DELETE;
				--_n;
				return true;
			}
		}

	private:
		vector&lt;HashData&lt;K, V&gt;&gt; _tables;
		size_t _n = 0; //有效数据个数
	};

	void TestHT1()
	{
		int a[] = { 10001,11,55,24,19,12,31 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		cout &lt;&lt; ht.Find(55) &lt;&lt; endl;
		cout &lt;&lt; ht.Find(31) &lt;&lt; endl;

		ht.Erase(55);
		cout &lt;&lt; ht.Find(55) &lt;&lt; endl;
		cout &lt;&lt; ht.Find(31) &lt;&lt; endl;
	}

	void TestHT2()
	{
		int a[] = { 10001,11,55,24,19,12,31 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Insert(make_pair(32, 32));
		ht.Insert(make_pair(32, 32));
	}

	//如果key不支持强转成整形取模，就要自己提供转换成整形的仿函数
	void TestHT3()
	{
		HashTable&lt;string, int&gt; ht;
		ht.Insert(make_pair("sort", 1));
		ht.Insert(make_pair("left", 1));
		ht.Insert(make_pair("insert	", 1));

		//cout &lt;&lt; StringHashFunc()("abcd") &lt;&lt; endl;
		//cout &lt;&lt; StringHashFunc()("aadd") &lt;&lt; endl;

	}
}


namespace hash_bucket
{
	template&lt;class T&gt;
	struct HashNode
	{
		T _data;
		HashNode&lt;T&gt;* _next;

		HashNode(const T&amp; data)
			:_data(data)
			,_next(nullptr)
		{}
	};

	//前置声明
	//HashTable需要用到__HTIterator，__HTIterator也需要用到HashTable
	//所以只能用前置声明
	template&lt;class K, class T, class KeyOfT, class Hash &gt;
	class HashTable;

	//template&lt;class K, class T,class KeyOfT, class Hash &gt;
	//struct __HTIterator
	//{
	//	typedef HashNode&lt;T&gt; Node;
	//	typedef __HTIterator&lt;K, T, KeyOfT, Hash&gt; Self;

	//	Node* _node;
	//	HashTable&lt;K, T, KeyOfT, Hash&gt;* _pht;  //当前桶为空的时候需要找下一个桶，就需要表才能找到下一个桶

	//	__HTIterator(Node* node,HashTable&lt;K,T,KeyOfT,Hash&gt;* pht)
	//		:_node(node)
	//		,_pht(pht)
	//	{}

	//	T&amp; operator*()
	//	{
	//		return _node-&gt;_data;
	//	}

	//	T* operator-&gt;()
	//	{
	//		return &amp;_node-&gt;_data;
	//	}

	//	Self operator++()
	//	{
	//		if (_node-&gt;_next)
	//		{
	//			//当前桶没走完，找当前桶的下一个节点
	//			_node = _node-&gt;_next;
	//		}
	//		else
	//		{
	//			//当前桶走完了，找下一个不为空的桶的第一个节点
	//			KeyOfT kot;
	//			Hash hs;
	//			size_t i = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.size(); 
	//			++i;
	//			for (; i &lt; _pht-&gt;_tables.size(); i++)
	//			{
	//				if (_pht-&gt;_tables[i])
	//					break;
	//			}

	//			if (i == _pht-&gt;_tables.size())
	//			{
	//				//所有桶都走完了，最后一个的下一个用nullptr标记
	//				_node = nullptr;
	//			}
	//			else
	//			{
	//				_node = _pht-&gt;_tables[i];
	//			}
	//		}
	//		return *this;
	//	}

	//	bool operator!=(const Self&amp; s)
	//	{
	//		return _node != s._node;
	//	}
	//};


	template&lt;class K ,class T,class KeyOfT, class Hash &gt;
	class HashTable
	{
		typedef HashNode&lt;T&gt; Node;
	public:
		//__HTIterator需要访问HashTable的私有，所以用友元
		/*template&lt;class K, class T, class KeyOfT, class Hash &gt;
		friend struct __HTIterator;*/

		//内部类
		template&lt;class Ptr, class Ref&gt;
		struct __HTIterator 
		{
			typedef HashNode&lt;T&gt; Node;
			typedef __HTIterator Self;

			Node* _node;
			const HashTable* _pht;  //当前桶为空的时候需要找下一个桶，就需要表才能找到下一个桶

			__HTIterator(Node* node,const HashTable* pht)
				:_node(node)
				,_pht(pht)
			{}

			Ref operator*()
			{
				return _node-&gt;_data;
			}

			Ptr operator-&gt;()
			{
				return &amp;_node-&gt;_data;
			}

			Self operator++()
			{
				if (_node-&gt;_next)
				{
					//当前桶没走完，找当前桶的下一个节点
					_node = _node-&gt;_next;
				}
				else
				{
					//当前桶走完了，找下一个不为空的桶的第一个节点
					KeyOfT kot;
					Hash hs;
					size_t i = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.size(); 
					++i;
					for (; i &lt; _pht-&gt;_tables.size(); i++)
					{
						if (_pht-&gt;_tables[i])
							break;
					}

					if (i == _pht-&gt;_tables.size())
					{
						//所有桶都走完了，最后一个的下一个用nullptr标记
						_node = nullptr;
					}
					else
					{
						_node = _pht-&gt;_tables[i];
					}
				}
				return *this;
			}

			bool operator!=(const Self&amp; s)
			{
				return _node != s._node;
			}
		};

		
		
		typedef __HTIterator&lt;T*,T&amp;&gt; iterator;
		typedef __HTIterator&lt;const T*,const T&amp;&gt; const_iterator;
		

		iterator begin()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				if (cur)
				{	//this -&gt;HashTable*			//begin写在HashTable里面，
					return iterator(cur, this);//this：返回的是哈希表的指针
				}
			}
			return end();
		}

		iterator end()
		{
			return iterator(nullptr, this);
		}

		const_iterator begin()const
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				if (cur)
				{	//this -&gt;const HashTable*			//begin写在HashTable里面，
					return const_iterator(cur, this);//this：返回的是哈希表的指针
				}
			}
			return end();
		}

		const_iterator end()const 
		{
			return const_iterator(nullptr, this);
		}

		HashTable()
		{
			_tables.resize(10, nullptr);
			_n = 0;
		}
		
		~HashTable()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				while (cur)
				{
					Node* next = cur-&gt;_next;
					delete cur;

					cur = next;
				}
				_tables[i] = nullptr;
			}
		}

		pair&lt;iterator,bool&gt; Insert(const T&amp; data)
		{
			KeyOfT kot;
			iterator it = Find(kot(data));
			if (it!= end())
				return make_pair(it,false);

			Hash hs;
			//扩容
			//负载因子为1时扩容
			if (_n == _tables.size())
			{
				//HashTable&lt;K, V&gt; newHT;
				//newHT._tables.resize(_tables.size() * 2);

				旧表重新计算负载到新表
				//for (size_t i = 0; i &lt; _tables.size(); i++)
				//{
				//	Node* cur = _tables[i];
				//	while(cur)
				//	{
				//		newHT.Insert(cur-&gt;_kv);
				//		cur = cur-&gt;_next;
				//	}								 
				//}									
				//_tables.swap(newHT._tables);

				vector&lt;Node*&gt; newTables(_tables.size() * 2, nullptr); 
				for (size_t i = 0; i &lt; _tables.size(); i++) 
				{
					Node* cur = _tables[i];  
					while(cur)
					{ 
						Node* next = cur-&gt;_next;  
						//头插到新表的位置
						size_t hashi = hs(kot(cur-&gt;_data)) % newTables.size(); 
						cur-&gt;_next = newTables[hashi];   
						newTables[hashi] = cur;   

						cur = next; 
					}				 
					_tables[i] = nullptr; 
				}									
				_tables.swap(newTables);  
			}

			size_t hashi = hs(kot(data)) % _tables.size(); 
			Node* newnode = new Node(data); 
			//头插
			newnode-&gt;_next = _tables[hashi]; 
			_tables[hashi] = newnode; 
			++_n; 

			return make_pair(iterator(newnode,this),true);
		}

		iterator Find(const K&amp; key)
		{
			KeyOfT kot;
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (kot(cur-&gt;_data) == key)
				{
					return iterator(cur,this);
				}
				cur = cur-&gt;_next;
			}
			return end();
		}

		bool Erase(const K&amp; key)
		{
			KeyOfT kot; 
			Hash hs;
			size_t hashi = hs(key) % _tables.size(); 
			Node* prev = nullptr;
			Node* cur = _tables[hashi]; 
			while (cur) 
			{
				if (kot(cur-&gt;_data) == key)
				{
					//如果删除的是第一个
					if (prev == nullptr)
					{
						_tables[hashi] = cur-&gt;_next;
					}
					else
					{
						prev-&gt;_next = cur-&gt;_next;
					}

					delete cur;
					return true;
				}
				else
				{
					prev = cur;
					cur = cur-&gt;_next;
				}
			}
			return false;
		}

	private:
		vector&lt;Node*&gt; _tables;  //指针数组
		size_t _n;
		
		//vector&lt;list&lt;pair&lt;K, V&gt;&gt;&gt; _tables;
	};

	/*void TestHT1()
	{
		int a[] = { 10001,11,55,24,19,12,31,4,34,44 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Insert(make_pair(32, 32));
		ht.Insert(make_pair(32, 32));

		ht.Erase(31);
		ht.Erase(11);

	}

	void TestHT2()
	{
		HashTable&lt;string, int&gt; ht; 
		ht.Insert(make_pair("sort", 1));
		ht.Insert(make_pair("left", 1));
		ht.Insert(make_pair("insert	", 1));
	}*/

}</code></pre> 
<h2 id="my_unordered_map.h">my_unordered_map.h</h2> 
<pre><code class="language-cpp">#pragma once


namespace qjh
{
	template&lt;class K,class V, class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_map
	{
		struct MapKeyOfT 
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv) 
			{
				return kv.first; 
			} 
		};

	public:
		typedef typename hash_bucket::HashTable&lt;K, pair&lt;const K,V&gt;, MapKeyOfT, Hash &gt;::iterator iterator; 
		typedef typename hash_bucket::HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT, Hash &gt;::const_iterator const_iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		const_iterator begin() const
		{
			return _ht.begin();
		}

		const_iterator end() const
		{
			return _ht.end();
		}

		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			return ret.first-&gt;second;
		}

		pair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; key)
		{
			return _ht.Insert(key);
		}

	private:
		hash_bucket::HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT,Hash &gt; _ht;
		
	};
	

	void test_unordered_map1()
	{
		string arr[] = { "苹果","西瓜","苹果","西瓜","苹果","苹果","西瓜",
			"苹果","香蕉","苹果","香蕉","苹果","草莓","苹果","草莓" };
		unordered_map&lt;string, int&gt; countmap;
		for (auto&amp; e : arr)
		{
			countmap[e]++;
		}

		unordered_map&lt;string,int&gt;::iterator it = countmap.begin();
		while (it != countmap.end())
		{
			//it-&gt;first += 'x';  //key不能修改
			it-&gt;second += 1;     //value可以修改
			cout &lt;&lt; it-&gt;first &lt;&lt; ":" &lt;&lt; it-&gt;second &lt;&lt; endl;
			++it;
		}
		cout &lt;&lt; endl;

		for (auto&amp; kv : countmap)
		{
			cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
		}
		cout &lt;&lt; endl;
	}
}</code></pre> 
<h2 id="my_unordered_set.h">my_unordered_set.h</h2> 
<pre><code class="language-cpp">#pragma once

#include"HashTable.h"

namespace qjh
{
	template&lt;class K,class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key) 
			{
				return key; 
			}
		};

	public:
		typedef typename hash_bucket::HashTable&lt;K, const K, SetKeyOfT, Hash&gt;::iterator iterator;
		typedef typename hash_bucket::HashTable&lt;K, const K, SetKeyOfT, Hash&gt;::const_iterator const_iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		const_iterator begin() const
		{
			return _ht.begin();
		}

		const_iterator end() const
		{
			return _ht.end();
		}

		pair&lt;iterator, bool&gt; insert(const K&amp; key)
		{
			return _ht.Insert(key);
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}

	private:
		hash_bucket::HashTable&lt;K,const K, SetKeyOfT, Hash&gt; _ht;
	};

	void Func(const unordered_set&lt;int&gt;&amp; s)
	{
		unordered_set&lt;int&gt;::iterator it = s.begin();
		while (it != s.end())
		{
			//*it = 1;
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;
	}

	void test_unordered_set()
	{
		unordered_set&lt;int&gt; s;
		s.insert(31);
		s.insert(11);
		s.insert(5);
		s.insert(15);
		s.insert(25);

		unordered_set&lt;int&gt;::iterator it = s.begin();
		while (it != s.end())
		{
			//*it = 1;
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;

		for (auto e : s)
		{
			cout &lt;&lt; e &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0359d1f50d198e17375cce258bef6cec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【高阶数据结构】图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb4daeaa7b367f602f87b450863ad960/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机毕业设计pyspark&#43;django&#43;scrapy租房推荐系统 租房大屏可视化 租房爬虫 hadoop 58同城租房爬虫 房源推荐系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>