<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ã€C&#43;&#43;ã€‘unordered_setå’Œunordered_mapçš„å°è£…ï¼ˆå“ˆå¸Œï¼‰ - ç¼–ç¨‹å¤§å’–</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/20ece005b236ecbc90dc5f23a4d1596c/">
  <meta property="og:site_name" content="ç¼–ç¨‹å¤§å’–">
  <meta property="og:title" content="ã€C&#43;&#43;ã€‘unordered_setå’Œunordered_mapçš„å°è£…ï¼ˆå“ˆå¸Œï¼‰">
  <meta property="og:description" content="ğŸŒˆä¸ªäººä¸»é¡µï¼šç§¦jh_-CSDNåšå®¢
ğŸ”¥Â ç³»åˆ—ä¸“æ ï¼šhttps://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
â€‹Â ç›®å½•
keyå’ŒpairÂ ä»¿å‡½æ•°hash
è¿­ä»£å™¨
operator&#43;&#43;
HashTable.h
my_unordered_map.h
my_unordered_set.h
å‰è¨€ ğŸ’¬ hello! å„ä½é“å­ä»¬å¤§å®¶å¥½å“‡ã€‚
ä»Šæ—¥æ›´æ–°äº†unordered_mapå’Œunordered_setå°è£…çš„ç›¸å…³å†…å®¹
ğŸ‰ æ¬¢è¿å¤§å®¶å…³æ³¨ğŸ”ç‚¹èµğŸ‘æ”¶è—â­ï¸ç•™è¨€ğŸ“
keyå’ŒpairÂ å‰é¢å·²ç»å®ç°äº†å“ˆå¸Œçš„åº•å±‚ï¼Œç°ç”¨å“ˆå¸Œè¿›è¡Œå°è£…ã€‚
unordered_setå’Œunordered_mapçš„å°è£…å’Œmapã€setå¤§ä½“æ€è·¯ä¸€æ ·ã€‚hashæ˜¯åº•å±‚ï¼Œä»–å¹¶ä¸çŸ¥é“ä¼ å…¥çš„æ˜¯kè¿˜æ˜¯pairï¼Œä½†æ˜¯ä¸Šå±‚çš„unordered_setå’Œunordered_mapçŸ¥é“ã€‚æ‰€ä»¥åœ¨hashå¤šä¼ å…¥ä¸€ä¸ªæ¨¡æ¿å‚æ•°KeyOfTï¼Œè¿™æ ·å†åœ¨mapå’Œsetä¸­åˆ†åˆ«å®ç°å–å‡ºkeyçš„é€»è¾‘å³å¯ã€‚
ä»¿å‡½æ•°hash ç”±äºhashç°åœ¨æ˜¯åº•å±‚ï¼Œæˆ‘ä»¬çš„ä»¿å‡½æ•°ä¸å¯èƒ½ç›´æ¥ä¼ ç»™hashåº•å±‚ï¼Œæ‰€ä»¥å¾—åœ¨unordered_setå’Œunordered_mapä¸Šä¼ å¤šä¸€ä¸ªæ¨¡æ¿å‚æ•°ï¼Œè¿™æ ·å–æ¨¡çš„ä»¿å‡½æ•°å°±å¯ä»¥åœ¨å¤–é¢ä¼ äº†ã€‚
è¿­ä»£å™¨ å½“éå†å®Œä¸€ä¸ªæ¡¶åï¼Œå‡†å¤‡æ‰¾ä¸‹ä¸€ä¸ªæ¡¶æ—¶ï¼Œå°±éœ€è¦æœ‰å“ˆå¸Œè¡¨ï¼Œä¸ç„¶å°±æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªæ¡¶ï¼Œæ‰€ä»¥iteratoréœ€è¦ä¼ ç¬¬äºŒä¸ªå‚æ•°ï¼šå“ˆå¸Œè¡¨çš„æŒ‡é’ˆã€‚
operator&#43;&#43; å½“å½“å‰æ¡¶èµ°å®Œäº†ï¼Œå°±è¦æ‰¾ä¸‹ä¸€ä¸ªä¸ä¸ºç©ºçš„æ¡¶çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¾ªç¯ç»“æŸæœ‰ä¸¤ç§å¯èƒ½ï¼Œä¸€ï¼šæ‰€æœ‰æ¡¶éƒ½èµ°å®Œäº†ã€‚äºŒï¼šæ‰¾åˆ°ä¸‹ä¸€ä¸ªä¸ä¸ºç©ºçš„æ¡¶ã€‚
HashTable.h #pragma once #include&lt;vector&gt; template&lt;class K&gt; struct HashFunc { size_t operator()(const K&amp; key) { return (size_t)key; //è´Ÿæ•°ã€æŒ‡é’ˆéƒ½èƒ½è½¬ } }; //ç‰¹åŒ– template&lt;&gt; struct HashFunc&lt;string&gt; { size_t operator()(const string&amp; key) { size_t hash = 0; for (auto ch : key) { hash *= 131; hash &#43;= ch; } return hash; } }; namespace open_address { enum State { EMPTY, EXIST, DELETE }; template&lt;class K, class V&gt; struct HashData { pair&lt;K, V&gt; _kv; State _state = EMPTY; }; template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt; class HashTable { public: HashTable() { _tables.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-19T10:43:59+08:00">
    <meta property="article:modified_time" content="2024-08-19T10:43:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="ç¼–ç¨‹å¤§å’–" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">ç¼–ç¨‹å¤§å’–</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ã€C&#43;&#43;ã€‘unordered_setå’Œunordered_mapçš„å°è£…ï¼ˆå“ˆå¸Œï¼‰</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Â <strong>ğŸŒˆä¸ªäººä¸»é¡µï¼š</strong><a href="https://blog.csdn.net/qinjh_?type=blog" title="ç§¦jh_-CSDNåšå®¢">ç§¦jh_-CSDNåšå®¢</a><br><strong>ğŸ”¥Â ç³»åˆ—ä¸“æ ï¼š</strong><a href="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482" title="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482">https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482</a></p> 
<p>Â <img alt="9efbcbc3d25747719da38c01b3fa9b4f.gif" src="https://images2.imgbox.com/4e/f9/Tu6dbA3X_o.gif">â€‹Â </p> 
<p></p> 
<p id="main-toc"><strong>ç›®å½•</strong></p> 
<p id="key%E5%92%8Cpair%C2%A0-toc" style="margin-left:0px;"><a href="#key%E5%92%8Cpair%C2%A0" rel="nofollow">keyå’ŒpairÂ </a></p> 
<p id="%C2%A0%E4%BB%BF%E5%87%BD%E6%95%B0hash-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BB%BF%E5%87%BD%E6%95%B0hash" rel="nofollow">Â ä»¿å‡½æ•°hash</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">è¿­ä»£å™¨</a></p> 
<p id="operator%2B%2B-toc" style="margin-left:40px;"><a href="#operator%2B%2B" rel="nofollow">operator++</a></p> 
<p id="HashTable.h-toc" style="margin-left:0px;"><a href="#HashTable.h" rel="nofollow">HashTable.h</a></p> 
<p id="my_unordered_map.h-toc" style="margin-left:0px;"><a href="#my_unordered_map.h" rel="nofollow">my_unordered_map.h</a></p> 
<p id="my_unordered_set.h-toc" style="margin-left:0px;"><a href="#my_unordered_set.h" rel="nofollow">my_unordered_set.h</a></p> 
<hr id="hr-toc"> 
<h2 id="%E5%89%8D%E8%A8%80">å‰è¨€</h2> 
<blockquote> 
 <p>â€‚â€‚â€‚â€‚<strong>ğŸ’¬ hello! å„ä½é“å­ä»¬å¤§å®¶å¥½å“‡ã€‚</strong></p> 
 <p><strong>Â  Â  Â  Â  Â  Â  Â ä»Šæ—¥æ›´æ–°äº†unordered_mapå’Œunordered_setå°è£…çš„ç›¸å…³å†…å®¹</strong><br> â€‚â€‚â€‚â€‚<strong>ğŸ‰ æ¬¢è¿å¤§å®¶å…³æ³¨ğŸ”ç‚¹èµğŸ‘æ”¶è—â­ï¸ç•™è¨€ğŸ“</strong></p> 
</blockquote> 
<h2 id="key%E5%92%8Cpair%C2%A0">keyå’ŒpairÂ </h2> 
<p>å‰é¢å·²ç»å®ç°äº†å“ˆå¸Œçš„åº•å±‚ï¼Œç°ç”¨å“ˆå¸Œè¿›è¡Œå°è£…ã€‚</p> 
<p><img alt="" height="838" src="https://images2.imgbox.com/28/07/x39fkjwq_o.png" width="827"><img alt="" height="511" src="https://images2.imgbox.com/9b/8f/vJwrcxt9_o.png" width="977"></p> 
<blockquote> 
 <p>unordered_setå’Œunordered_mapçš„å°è£…å’Œmapã€setå¤§ä½“æ€è·¯ä¸€æ ·ã€‚hashæ˜¯åº•å±‚ï¼Œä»–å¹¶ä¸çŸ¥é“ä¼ å…¥çš„æ˜¯kè¿˜æ˜¯pairï¼Œä½†æ˜¯ä¸Šå±‚çš„unordered_setå’Œunordered_mapçŸ¥é“ã€‚æ‰€ä»¥åœ¨hashå¤šä¼ å…¥ä¸€ä¸ªæ¨¡æ¿å‚æ•°KeyOfTï¼Œè¿™æ ·å†åœ¨mapå’Œsetä¸­åˆ†åˆ«å®ç°å–å‡ºkeyçš„é€»è¾‘å³å¯ã€‚</p> 
</blockquote> 
<hr> 
<h2 id="%C2%A0%E4%BB%BF%E5%87%BD%E6%95%B0hash">Â ä»¿å‡½æ•°hash</h2> 
<p><img alt="" height="239" src="https://images2.imgbox.com/bc/6d/rMxyS7ja_o.png" width="1035"><img alt="" height="774" src="https://images2.imgbox.com/cc/67/GtYT3Mjs_o.png" width="953"><img alt="" height="541" src="https://images2.imgbox.com/67/b6/I0pGhsll_o.png" width="1020"></p> 
<blockquote> 
 <p>Â ç”±äºhashç°åœ¨æ˜¯åº•å±‚ï¼Œæˆ‘ä»¬çš„ä»¿å‡½æ•°ä¸å¯èƒ½ç›´æ¥ä¼ ç»™hashåº•å±‚ï¼Œæ‰€ä»¥å¾—åœ¨unordered_setå’Œunordered_mapä¸Šä¼ å¤šä¸€ä¸ªæ¨¡æ¿å‚æ•°ï¼Œè¿™æ ·å–æ¨¡çš„ä»¿å‡½æ•°å°±å¯ä»¥åœ¨å¤–é¢ä¼ äº†ã€‚</p> 
</blockquote> 
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8">è¿­ä»£å™¨</h2> 
<p><img alt="" height="391" src="https://images2.imgbox.com/05/49/2N2SU4ix_o.png" width="1200"><img alt="" height="827" src="https://images2.imgbox.com/bc/fb/RNrsfebG_o.png" width="1012"></p> 
<blockquote> 
 <p>å½“éå†å®Œä¸€ä¸ªæ¡¶åï¼Œå‡†å¤‡æ‰¾ä¸‹ä¸€ä¸ªæ¡¶æ—¶ï¼Œå°±éœ€è¦æœ‰å“ˆå¸Œè¡¨ï¼Œä¸ç„¶å°±æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªæ¡¶ï¼Œæ‰€ä»¥iteratoréœ€è¦ä¼ ç¬¬äºŒä¸ªå‚æ•°ï¼šå“ˆå¸Œè¡¨çš„æŒ‡é’ˆã€‚</p> 
</blockquote> 
<h3 id="operator%2B%2B">operator++</h3> 
<p><img alt="" height="1128" src="https://images2.imgbox.com/c0/84/mZnuOJjt_o.png" width="915"></p> 
<blockquote> 
 <p>å½“å½“å‰æ¡¶èµ°å®Œäº†ï¼Œå°±è¦æ‰¾ä¸‹ä¸€ä¸ªä¸ä¸ºç©ºçš„æ¡¶çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¾ªç¯ç»“æŸæœ‰ä¸¤ç§å¯èƒ½ï¼Œä¸€ï¼šæ‰€æœ‰æ¡¶éƒ½èµ°å®Œäº†ã€‚äºŒï¼šæ‰¾åˆ°ä¸‹ä¸€ä¸ªä¸ä¸ºç©ºçš„æ¡¶ã€‚</p> 
</blockquote> 
<h2 id="HashTable.h">HashTable.h</h2> 
<pre><code class="language-cpp">#pragma once 
#include&lt;vector&gt;

template&lt;class K&gt;
struct HashFunc
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key; //è´Ÿæ•°ã€æŒ‡é’ˆéƒ½èƒ½è½¬
	}
};

//ç‰¹åŒ–
template&lt;&gt;
struct HashFunc&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		size_t hash = 0;
		for (auto ch : key)
		{
			hash *= 131;
			hash += ch;
		}
		return hash;
	}
};

namespace open_address
{
	enum State
	{
		EMPTY,
		EXIST,
		DELETE
	};

	template&lt;class K, class V&gt;
	struct HashData
	{
		pair&lt;K, V&gt; _kv;
		State _state = EMPTY;
	};

	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class HashTable
	{
	public:
		HashTable()
		{
			_tables.resize(10);
		}

		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first))  //ä¸å…è®¸å†—ä½™
				return false;

			//æ‰©å®¹
			if (_n * 10 / _tables.size() &gt;= 7)
			{
				//æ–¹æ³•ä¸€
				//size_t newsize = _tables.size() * 2;    //ç”¨vectorçš„è¯éœ€è¦æ‰‹åŠ¨æ˜ å°„
				//vector&lt;HashData&lt;K, V&gt;&gt; newtables(newsize);

				æ—§è¡¨é‡æ–°è®¡ç®—è´Ÿè½½åˆ°æ–°è¡¨
				//for(size_t i=0;i&lt;_tables.size();i++)
				//{ }

				//æ–¹æ³•äºŒ
				HashTable&lt;K, V, Hash&gt; newHT;
				newHT._tables.resize(_tables.size() * 2);

				//æ—§è¡¨é‡æ–°è®¡ç®—è´Ÿè½½åˆ°æ–°è¡¨
				for (size_t i = 0; i &lt; _tables.size(); i++)
				{
					if (_tables[i]._state == EXIST)
					{
						newHT.Insert(_tables[i]._kv);//ç”¨HashTableå¯¹è±¡æ’å…¥ï¼Œå¯ä»¥å¤ç”¨Insertï¼Œä¸éœ€è¦æ‰‹åŠ¨æ˜ å°„
					}								 //newHTå·²ç»æ˜¯æ‰©å®¹å¥½çš„äº†ï¼Œå°±è·³è¿‡æ‰©å®¹ï¼Œç›´æ¥æ¥åˆ°æ¢æµ‹éƒ¨åˆ†
				}									 //æ–°è¡¨æ’å…¥å¥½åï¼Œå†è·Ÿæ—§è¡¨äº’æ¢
				_tables.swap(newHT._tables);
			}
			Hash hs;
			size_t hashi = hs(kv.first) % _tables.size();  //ä¸èƒ½æ¨¡capacity,å¦åˆ™ä¼šå¾—åˆ°æ¯”sizeå¤§çš„æ•°ï¼Œè€Œsizeåé¢çš„ä½ç½®ä¸èƒ½ç”¨[]å¾—åˆ°
			//çº¿æ€§æ¢æµ‹
			while (_tables[hashi]._state == EXIST)
			{
				++hashi;
				hashi %= _tables.size(); //å¦‚æœå¾€åæ‰¾æ‰¾ä¸åˆ°ï¼Œå°±å›åˆ°å‰é¢ç»§ç»­æ‰¾
			}

			_tables[hashi]._kv = kv;
			_tables[hashi]._state = EXIST;
			++_n;

			return true;
		}

		HashData&lt;K, V&gt;* Find(const K&amp; key)
		{
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			//çº¿æ€§æ¢æµ‹
			while (_tables[hashi]._state != EMPTY)
			{
				if (_tables[hashi]._state == EXIST &amp;&amp;
					_tables[hashi]._kv.first == key)
				{
					return &amp;_tables[hashi];
				}
				++hashi;
				hashi %= _tables.size();
			}
			return nullptr;
		}

		bool Erase(const K&amp; key)
		{
			HashData&lt;K, V&gt;* ret = Find(key);
			if (ret == nullptr)
			{
				return false;
			}
			else
			{
				ret-&gt;_state = DELETE;
				--_n;
				return true;
			}
		}

	private:
		vector&lt;HashData&lt;K, V&gt;&gt; _tables;
		size_t _n = 0; //æœ‰æ•ˆæ•°æ®ä¸ªæ•°
	};

	void TestHT1()
	{
		int a[] = { 10001,11,55,24,19,12,31 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		cout &lt;&lt; ht.Find(55) &lt;&lt; endl;
		cout &lt;&lt; ht.Find(31) &lt;&lt; endl;

		ht.Erase(55);
		cout &lt;&lt; ht.Find(55) &lt;&lt; endl;
		cout &lt;&lt; ht.Find(31) &lt;&lt; endl;
	}

	void TestHT2()
	{
		int a[] = { 10001,11,55,24,19,12,31 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Insert(make_pair(32, 32));
		ht.Insert(make_pair(32, 32));
	}

	//å¦‚æœkeyä¸æ”¯æŒå¼ºè½¬æˆæ•´å½¢å–æ¨¡ï¼Œå°±è¦è‡ªå·±æä¾›è½¬æ¢æˆæ•´å½¢çš„ä»¿å‡½æ•°
	void TestHT3()
	{
		HashTable&lt;string, int&gt; ht;
		ht.Insert(make_pair("sort", 1));
		ht.Insert(make_pair("left", 1));
		ht.Insert(make_pair("insert	", 1));

		//cout &lt;&lt; StringHashFunc()("abcd") &lt;&lt; endl;
		//cout &lt;&lt; StringHashFunc()("aadd") &lt;&lt; endl;

	}
}


namespace hash_bucket
{
	template&lt;class T&gt;
	struct HashNode
	{
		T _data;
		HashNode&lt;T&gt;* _next;

		HashNode(const T&amp; data)
			:_data(data)
			,_next(nullptr)
		{}
	};

	//å‰ç½®å£°æ˜
	//HashTableéœ€è¦ç”¨åˆ°__HTIteratorï¼Œ__HTIteratorä¹Ÿéœ€è¦ç”¨åˆ°HashTable
	//æ‰€ä»¥åªèƒ½ç”¨å‰ç½®å£°æ˜
	template&lt;class K, class T, class KeyOfT, class Hash &gt;
	class HashTable;

	//template&lt;class K, class T,class KeyOfT, class Hash &gt;
	//struct __HTIterator
	//{
	//	typedef HashNode&lt;T&gt; Node;
	//	typedef __HTIterator&lt;K, T, KeyOfT, Hash&gt; Self;

	//	Node* _node;
	//	HashTable&lt;K, T, KeyOfT, Hash&gt;* _pht;  //å½“å‰æ¡¶ä¸ºç©ºçš„æ—¶å€™éœ€è¦æ‰¾ä¸‹ä¸€ä¸ªæ¡¶ï¼Œå°±éœ€è¦è¡¨æ‰èƒ½æ‰¾åˆ°ä¸‹ä¸€ä¸ªæ¡¶

	//	__HTIterator(Node* node,HashTable&lt;K,T,KeyOfT,Hash&gt;* pht)
	//		:_node(node)
	//		,_pht(pht)
	//	{}

	//	T&amp; operator*()
	//	{
	//		return _node-&gt;_data;
	//	}

	//	T* operator-&gt;()
	//	{
	//		return &amp;_node-&gt;_data;
	//	}

	//	Self operator++()
	//	{
	//		if (_node-&gt;_next)
	//		{
	//			//å½“å‰æ¡¶æ²¡èµ°å®Œï¼Œæ‰¾å½“å‰æ¡¶çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
	//			_node = _node-&gt;_next;
	//		}
	//		else
	//		{
	//			//å½“å‰æ¡¶èµ°å®Œäº†ï¼Œæ‰¾ä¸‹ä¸€ä¸ªä¸ä¸ºç©ºçš„æ¡¶çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
	//			KeyOfT kot;
	//			Hash hs;
	//			size_t i = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.size(); 
	//			++i;
	//			for (; i &lt; _pht-&gt;_tables.size(); i++)
	//			{
	//				if (_pht-&gt;_tables[i])
	//					break;
	//			}

	//			if (i == _pht-&gt;_tables.size())
	//			{
	//				//æ‰€æœ‰æ¡¶éƒ½èµ°å®Œäº†ï¼Œæœ€åä¸€ä¸ªçš„ä¸‹ä¸€ä¸ªç”¨nullptræ ‡è®°
	//				_node = nullptr;
	//			}
	//			else
	//			{
	//				_node = _pht-&gt;_tables[i];
	//			}
	//		}
	//		return *this;
	//	}

	//	bool operator!=(const Self&amp; s)
	//	{
	//		return _node != s._node;
	//	}
	//};


	template&lt;class K ,class T,class KeyOfT, class Hash &gt;
	class HashTable
	{
		typedef HashNode&lt;T&gt; Node;
	public:
		//__HTIteratoréœ€è¦è®¿é—®HashTableçš„ç§æœ‰ï¼Œæ‰€ä»¥ç”¨å‹å…ƒ
		/*template&lt;class K, class T, class KeyOfT, class Hash &gt;
		friend struct __HTIterator;*/

		//å†…éƒ¨ç±»
		template&lt;class Ptr, class Ref&gt;
		struct __HTIterator 
		{
			typedef HashNode&lt;T&gt; Node;
			typedef __HTIterator Self;

			Node* _node;
			const HashTable* _pht;  //å½“å‰æ¡¶ä¸ºç©ºçš„æ—¶å€™éœ€è¦æ‰¾ä¸‹ä¸€ä¸ªæ¡¶ï¼Œå°±éœ€è¦è¡¨æ‰èƒ½æ‰¾åˆ°ä¸‹ä¸€ä¸ªæ¡¶

			__HTIterator(Node* node,const HashTable* pht)
				:_node(node)
				,_pht(pht)
			{}

			Ref operator*()
			{
				return _node-&gt;_data;
			}

			Ptr operator-&gt;()
			{
				return &amp;_node-&gt;_data;
			}

			Self operator++()
			{
				if (_node-&gt;_next)
				{
					//å½“å‰æ¡¶æ²¡èµ°å®Œï¼Œæ‰¾å½“å‰æ¡¶çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
					_node = _node-&gt;_next;
				}
				else
				{
					//å½“å‰æ¡¶èµ°å®Œäº†ï¼Œæ‰¾ä¸‹ä¸€ä¸ªä¸ä¸ºç©ºçš„æ¡¶çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
					KeyOfT kot;
					Hash hs;
					size_t i = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.size(); 
					++i;
					for (; i &lt; _pht-&gt;_tables.size(); i++)
					{
						if (_pht-&gt;_tables[i])
							break;
					}

					if (i == _pht-&gt;_tables.size())
					{
						//æ‰€æœ‰æ¡¶éƒ½èµ°å®Œäº†ï¼Œæœ€åä¸€ä¸ªçš„ä¸‹ä¸€ä¸ªç”¨nullptræ ‡è®°
						_node = nullptr;
					}
					else
					{
						_node = _pht-&gt;_tables[i];
					}
				}
				return *this;
			}

			bool operator!=(const Self&amp; s)
			{
				return _node != s._node;
			}
		};

		
		
		typedef __HTIterator&lt;T*,T&amp;&gt; iterator;
		typedef __HTIterator&lt;const T*,const T&amp;&gt; const_iterator;
		

		iterator begin()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				if (cur)
				{	//this -&gt;HashTable*			//beginå†™åœ¨HashTableé‡Œé¢ï¼Œ
					return iterator(cur, this);//thisï¼šè¿”å›çš„æ˜¯å“ˆå¸Œè¡¨çš„æŒ‡é’ˆ
				}
			}
			return end();
		}

		iterator end()
		{
			return iterator(nullptr, this);
		}

		const_iterator begin()const
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				if (cur)
				{	//this -&gt;const HashTable*			//beginå†™åœ¨HashTableé‡Œé¢ï¼Œ
					return const_iterator(cur, this);//thisï¼šè¿”å›çš„æ˜¯å“ˆå¸Œè¡¨çš„æŒ‡é’ˆ
				}
			}
			return end();
		}

		const_iterator end()const 
		{
			return const_iterator(nullptr, this);
		}

		HashTable()
		{
			_tables.resize(10, nullptr);
			_n = 0;
		}
		
		~HashTable()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				while (cur)
				{
					Node* next = cur-&gt;_next;
					delete cur;

					cur = next;
				}
				_tables[i] = nullptr;
			}
		}

		pair&lt;iterator,bool&gt; Insert(const T&amp; data)
		{
			KeyOfT kot;
			iterator it = Find(kot(data));
			if (it!= end())
				return make_pair(it,false);

			Hash hs;
			//æ‰©å®¹
			//è´Ÿè½½å› å­ä¸º1æ—¶æ‰©å®¹
			if (_n == _tables.size())
			{
				//HashTable&lt;K, V&gt; newHT;
				//newHT._tables.resize(_tables.size() * 2);

				æ—§è¡¨é‡æ–°è®¡ç®—è´Ÿè½½åˆ°æ–°è¡¨
				//for (size_t i = 0; i &lt; _tables.size(); i++)
				//{
				//	Node* cur = _tables[i];
				//	while(cur)
				//	{
				//		newHT.Insert(cur-&gt;_kv);
				//		cur = cur-&gt;_next;
				//	}								 
				//}									
				//_tables.swap(newHT._tables);

				vector&lt;Node*&gt; newTables(_tables.size() * 2, nullptr); 
				for (size_t i = 0; i &lt; _tables.size(); i++) 
				{
					Node* cur = _tables[i];  
					while(cur)
					{ 
						Node* next = cur-&gt;_next;  
						//å¤´æ’åˆ°æ–°è¡¨çš„ä½ç½®
						size_t hashi = hs(kot(cur-&gt;_data)) % newTables.size(); 
						cur-&gt;_next = newTables[hashi];   
						newTables[hashi] = cur;   

						cur = next; 
					}				 
					_tables[i] = nullptr; 
				}									
				_tables.swap(newTables);  
			}

			size_t hashi = hs(kot(data)) % _tables.size(); 
			Node* newnode = new Node(data); 
			//å¤´æ’
			newnode-&gt;_next = _tables[hashi]; 
			_tables[hashi] = newnode; 
			++_n; 

			return make_pair(iterator(newnode,this),true);
		}

		iterator Find(const K&amp; key)
		{
			KeyOfT kot;
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (kot(cur-&gt;_data) == key)
				{
					return iterator(cur,this);
				}
				cur = cur-&gt;_next;
			}
			return end();
		}

		bool Erase(const K&amp; key)
		{
			KeyOfT kot; 
			Hash hs;
			size_t hashi = hs(key) % _tables.size(); 
			Node* prev = nullptr;
			Node* cur = _tables[hashi]; 
			while (cur) 
			{
				if (kot(cur-&gt;_data) == key)
				{
					//å¦‚æœåˆ é™¤çš„æ˜¯ç¬¬ä¸€ä¸ª
					if (prev == nullptr)
					{
						_tables[hashi] = cur-&gt;_next;
					}
					else
					{
						prev-&gt;_next = cur-&gt;_next;
					}

					delete cur;
					return true;
				}
				else
				{
					prev = cur;
					cur = cur-&gt;_next;
				}
			}
			return false;
		}

	private:
		vector&lt;Node*&gt; _tables;  //æŒ‡é’ˆæ•°ç»„
		size_t _n;
		
		//vector&lt;list&lt;pair&lt;K, V&gt;&gt;&gt; _tables;
	};

	/*void TestHT1()
	{
		int a[] = { 10001,11,55,24,19,12,31,4,34,44 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Insert(make_pair(32, 32));
		ht.Insert(make_pair(32, 32));

		ht.Erase(31);
		ht.Erase(11);

	}

	void TestHT2()
	{
		HashTable&lt;string, int&gt; ht; 
		ht.Insert(make_pair("sort", 1));
		ht.Insert(make_pair("left", 1));
		ht.Insert(make_pair("insert	", 1));
	}*/

}</code></pre> 
<h2 id="my_unordered_map.h">my_unordered_map.h</h2> 
<pre><code class="language-cpp">#pragma once


namespace qjh
{
	template&lt;class K,class V, class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_map
	{
		struct MapKeyOfT 
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv) 
			{
				return kv.first; 
			} 
		};

	public:
		typedef typename hash_bucket::HashTable&lt;K, pair&lt;const K,V&gt;, MapKeyOfT, Hash &gt;::iterator iterator; 
		typedef typename hash_bucket::HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT, Hash &gt;::const_iterator const_iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		const_iterator begin() const
		{
			return _ht.begin();
		}

		const_iterator end() const
		{
			return _ht.end();
		}

		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			return ret.first-&gt;second;
		}

		pair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; key)
		{
			return _ht.Insert(key);
		}

	private:
		hash_bucket::HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT,Hash &gt; _ht;
		
	};
	

	void test_unordered_map1()
	{
		string arr[] = { "è‹¹æœ","è¥¿ç“œ","è‹¹æœ","è¥¿ç“œ","è‹¹æœ","è‹¹æœ","è¥¿ç“œ",
			"è‹¹æœ","é¦™è•‰","è‹¹æœ","é¦™è•‰","è‹¹æœ","è‰è“","è‹¹æœ","è‰è“" };
		unordered_map&lt;string, int&gt; countmap;
		for (auto&amp; e : arr)
		{
			countmap[e]++;
		}

		unordered_map&lt;string,int&gt;::iterator it = countmap.begin();
		while (it != countmap.end())
		{
			//it-&gt;first += 'x';  //keyä¸èƒ½ä¿®æ”¹
			it-&gt;second += 1;     //valueå¯ä»¥ä¿®æ”¹
			cout &lt;&lt; it-&gt;first &lt;&lt; ":" &lt;&lt; it-&gt;second &lt;&lt; endl;
			++it;
		}
		cout &lt;&lt; endl;

		for (auto&amp; kv : countmap)
		{
			cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
		}
		cout &lt;&lt; endl;
	}
}</code></pre> 
<h2 id="my_unordered_set.h">my_unordered_set.h</h2> 
<pre><code class="language-cpp">#pragma once

#include"HashTable.h"

namespace qjh
{
	template&lt;class K,class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key) 
			{
				return key; 
			}
		};

	public:
		typedef typename hash_bucket::HashTable&lt;K, const K, SetKeyOfT, Hash&gt;::iterator iterator;
		typedef typename hash_bucket::HashTable&lt;K, const K, SetKeyOfT, Hash&gt;::const_iterator const_iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		const_iterator begin() const
		{
			return _ht.begin();
		}

		const_iterator end() const
		{
			return _ht.end();
		}

		pair&lt;iterator, bool&gt; insert(const K&amp; key)
		{
			return _ht.Insert(key);
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}

	private:
		hash_bucket::HashTable&lt;K,const K, SetKeyOfT, Hash&gt; _ht;
	};

	void Func(const unordered_set&lt;int&gt;&amp; s)
	{
		unordered_set&lt;int&gt;::iterator it = s.begin();
		while (it != s.end())
		{
			//*it = 1;
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;
	}

	void test_unordered_set()
	{
		unordered_set&lt;int&gt; s;
		s.insert(31);
		s.insert(11);
		s.insert(5);
		s.insert(15);
		s.insert(25);

		unordered_set&lt;int&gt;::iterator it = s.begin();
		while (it != s.end())
		{
			//*it = 1;
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;

		for (auto e : s)
		{
			cout &lt;&lt; e &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0359d1f50d198e17375cce258bef6cec/" rel="prev">
			<span class="pager__subtitle">Â«&thinsp;Previous</span>
			<p class="pager__title">ã€é«˜é˜¶æ•°æ®ç»“æ„ã€‘å›¾</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb4daeaa7b367f602f87b450863ad960/" rel="next">
			<span class="pager__subtitle">Next&thinsp;Â»</span>
			<p class="pager__title">è®¡ç®—æœºæ¯•ä¸šè®¾è®¡pyspark&#43;django&#43;scrapyç§Ÿæˆ¿æ¨èç³»ç»Ÿ ç§Ÿæˆ¿å¤§å±å¯è§†åŒ– ç§Ÿæˆ¿çˆ¬è™« hadoop 58åŒåŸç§Ÿæˆ¿çˆ¬è™« æˆ¿æºæ¨èç³»ç»Ÿ</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 ç¼–ç¨‹å¤§å’–.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>