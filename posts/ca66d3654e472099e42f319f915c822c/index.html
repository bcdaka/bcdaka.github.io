<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ实践——超时消息的处理方法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ca66d3654e472099e42f319f915c822c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RabbitMQ实践——超时消息的处理方法">
  <meta property="og:description" content="大纲 准备工作整个队列的消息都有相同的时效性抛弃超时消息新建带x-message-ttl的队列新建绑定关系实验 超时消息路由到死信队列新建带死信和ttl的队列新建绑定关系实验 消息指定自己的超时时间新建带死信的队列绑定实验 消息自带TTL和队列TTL的关系消息TTL &lt; 队列指定TTL消息TTL &gt; 队列指定TTL总结 代码工程 在项目中，我们往往会遇到消息具有时效性：在一定时间内的消息需要处理，其他消息则不用处理。RabbitMQ提供了两种功能来满足这种需求：
整个队列的消息都有相同的时效性。消息可以指定自己的超时时间。 对于超时的消息，我们可以选择抛弃，或者让其进入死信。本文我们将实验这些场景。
准备工作 我们先新建一个交换器direct.ttl。后续不同场景我们再设定其不同路由。
然后再创建一个死信队列queue.dead.letter
最后新建交换器direct.ttl和队列queue.dead.letter的路由绑定关系
后续我们将根据不同场景新建不同的队列和绑定关系。
整个队列的消息都有相同的时效性 抛弃超时消息 新建带x-message-ttl的队列 如果队列设置了x-message-ttl，则其全部消息的最大ttl就是其值。它的单位是毫秒。下图中，队列消息如果30秒没有处理，就会从队列中移除。
新建绑定关系 我们让交换器中Routing key是to.queue.all.message.ttl的消息路由到上面创建的队列中。
实验 向该交换器发送一条消息
消息出现在队列queue.all.message.ttl中。
半分钟后，该条消息从队列中消失。
超时消息路由到死信队列 不同于上例，只是设置了x-message-ttl，还要设置死信相关参数。本例我们将使用“重写Routing key”的方案，节省一次交换器的创建。
新建带死信和ttl的队列 新建名字是queue.all.msg.ttl.dead.letter的队列。这个队列中的所有消息的最大超时时间（x-message-ttl）是30秒；超时消息会被修改Routing key为to.queue.dead.letter后，使用direct.ttl交换器来路由。
新建绑定关系 将这个队列和之前新建的交换器direct.ttl关联。
实验 可以看到消息在过了30秒后，被从原来的队列queue.all.msg.ttl.dead.letter中移除，然后路由到死信队列queue.dead.letter中。
消息指定自己的超时时间 本例我们只实验相对复杂的场景，即将超时消息路由到死信。
新建带死信的队列 这个队列我们没有设置ttl相关数据，只是设置了死信相关配置：死信消息交由交换器direct.ttl处理，其Routing key被修改成to.queue.dead.letter。
绑定 实验 这次我们不能使用后台来发送消息，而是通过Java代码来发送。
public void sendWithTTL(String exchangeName, String routingKey, String message, int ttl) { String msgId = UUID.randomUUID().toString(); Message msg = MessageBuilder.withBody(message.getBytes()) .setContentType(&#34;text/plain&#34;) .setCorrelationId(msgId) .setMessageId(msgId) .">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-25T23:34:32+08:00">
    <meta property="article:modified_time" content="2024-06-25T23:34:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ实践——超时消息的处理方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>大纲</h4> 
 <ul><li><a href="#_7" rel="nofollow">准备工作</a></li><li><a href="#_16" rel="nofollow">整个队列的消息都有相同的时效性</a></li><li><ul><li><a href="#_17" rel="nofollow">抛弃超时消息</a></li><li><ul><li><a href="#xmessagettl_18" rel="nofollow">新建带x-message-ttl的队列</a></li><li><a href="#_21" rel="nofollow">新建绑定关系</a></li><li><a href="#_24" rel="nofollow">实验</a></li></ul> 
   </li><li><a href="#_31" rel="nofollow">超时消息路由到死信队列</a></li><li><ul><li><a href="#ttl_33" rel="nofollow">新建带死信和ttl的队列</a></li><li><a href="#_36" rel="nofollow">新建绑定关系</a></li><li><a href="#_39" rel="nofollow">实验</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_44" rel="nofollow">消息指定自己的超时时间</a></li><li><ul><li><a href="#_46" rel="nofollow">新建带死信的队列</a></li><li><a href="#_49" rel="nofollow">绑定</a></li><li><a href="#_51" rel="nofollow">实验</a></li></ul> 
  </li><li><a href="#TTLTTL_74" rel="nofollow">消息自带TTL和队列TTL的关系</a></li><li><ul><li><a href="#TTL__TTL_77" rel="nofollow">消息TTL &lt; 队列指定TTL</a></li><li><a href="#TTL__TTL_84" rel="nofollow">消息TTL &gt; 队列指定TTL</a></li><li><a href="#_89" rel="nofollow">总结</a></li></ul> 
  </li><li><a href="#_91" rel="nofollow">代码工程</a></li></ul> 
</div> 
<p></p> 
<p>在项目中，我们往往会遇到消息具有时效性：在一定时间内的消息需要处理，其他消息则不用处理。RabbitMQ提供了两种功能来满足这种需求：</p> 
<ul><li>整个队列的消息都有相同的时效性。</li><li>消息可以指定自己的超时时间。</li></ul> 
<p>对于超时的消息，我们可以选择抛弃，或者让其进入死信。本文我们将实验这些场景。</p> 
<h2><a id="_7"></a>准备工作</h2> 
<p>我们先新建一个交换器direct.ttl。后续不同场景我们再设定其不同路由。<br> <img src="https://images2.imgbox.com/48/03/WYAyNY4j_o.png" alt="在这里插入图片描述"><br> 然后再创建一个死信队列queue.dead.letter<br> <img src="https://images2.imgbox.com/aa/f8/6RqT8Chc_o.png" alt="在这里插入图片描述"><br> 最后新建交换器direct.ttl和队列queue.dead.letter的路由绑定关系<br> <img src="https://images2.imgbox.com/31/85/2iIuns8J_o.png" alt="在这里插入图片描述"></p> 
<p>后续我们将根据不同场景新建不同的队列和绑定关系。</p> 
<h2><a id="_16"></a>整个队列的消息都有相同的时效性</h2> 
<h3><a id="_17"></a>抛弃超时消息</h3> 
<h4><a id="xmessagettl_18"></a>新建带x-message-ttl的队列</h4> 
<p>如果队列设置了x-message-ttl，则其全部消息的最大ttl就是其值。它的单位是毫秒。下图中，队列消息如果30秒没有处理，就会从队列中移除。<br> <img src="https://images2.imgbox.com/1f/1d/zFT48Hwq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_21"></a>新建绑定关系</h4> 
<p>我们让交换器中Routing key是to.queue.all.message.ttl的消息路由到上面创建的队列中。<br> <img src="https://images2.imgbox.com/d8/3b/mIZlfAJZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_24"></a>实验</h4> 
<p>向该交换器发送一条消息<br> <img src="https://images2.imgbox.com/80/ae/pE1ykFj4_o.png" alt="在这里插入图片描述"><br> 消息出现在队列queue.all.message.ttl中。<br> <img src="https://images2.imgbox.com/81/d0/AnL8Vcfi_o.png" alt="在这里插入图片描述"><br> 半分钟后，该条消息从队列中消失。<br> <img src="https://images2.imgbox.com/0c/d6/6J4Llh1Q_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_31"></a>超时消息路由到死信队列</h3> 
<p>不同于上例，只是设置了x-message-ttl，还要设置死信相关参数。本例我们将使用“重写Routing key”的方案，节省一次交换器的创建。</p> 
<h4><a id="ttl_33"></a>新建带死信和ttl的队列</h4> 
<p>新建名字是queue.all.msg.ttl.dead.letter的队列。这个队列中的所有消息的最大超时时间（x-message-ttl）是30秒；超时消息会被修改Routing key为to.queue.dead.letter后，使用direct.ttl交换器来路由。<br> <img src="https://images2.imgbox.com/08/7f/ztdS9LDw_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_36"></a>新建绑定关系</h4> 
<p>将这个队列和之前新建的交换器direct.ttl关联。<br> <img src="https://images2.imgbox.com/a2/59/kapY3wgn_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_39"></a>实验</h4> 
<p><img src="https://images2.imgbox.com/c4/6d/Ns7JvpEu_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/32/0f/GOmjMYNQ_o.png" alt="在这里插入图片描述"><br> 可以看到消息在过了30秒后，被从原来的队列queue.all.msg.ttl.dead.letter中移除，然后路由到死信队列queue.dead.letter中。<br> <img src="https://images2.imgbox.com/a3/7f/wHNs0Ccm_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_44"></a>消息指定自己的超时时间</h2> 
<p>本例我们只实验相对复杂的场景，即将超时消息路由到死信。</p> 
<h3><a id="_46"></a>新建带死信的队列</h3> 
<p>这个队列我们没有设置ttl相关数据，只是设置了死信相关配置：死信消息交由交换器direct.ttl处理，其Routing key被修改成to.queue.dead.letter。<br> <img src="https://images2.imgbox.com/d5/07/oj6iKL2V_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_49"></a>绑定</h3> 
<p><img src="https://images2.imgbox.com/bd/4b/3T8WWUE3_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_51"></a>实验</h3> 
<p>这次我们不能使用后台来发送消息，而是通过Java代码来发送。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendWithTTL</span><span class="token punctuation">(</span><span class="token class-name">String</span> exchangeName<span class="token punctuation">,</span> <span class="token class-name">String</span> routingKey<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">,</span> <span class="token keyword">int</span> ttl<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">String</span> msgId <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/plain"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setCorrelationId</span><span class="token punctuation">(</span>msgId<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setMessageId</span><span class="token punctuation">(</span>msgId<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ttl<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">CorrelationData</span> correlationData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span>msgId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    rabbitTemplateWithoutMandatory<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>发送消息时我们只需要给消息增加setExpiration调用即可。它的单位是毫秒，需要转换为字符串。<br> <img src="https://images2.imgbox.com/f2/a1/dC5qinzK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7c/79/WLJpj1LW_o.png" alt="在这里插入图片描述"><br> 可以看到20秒后，消息从queue.with.dead.letter队列进入queue.dead.letter队列。<br> <img src="https://images2.imgbox.com/ff/de/yuHp3B7X_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3c/59/PTXrPnw2_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="TTLTTL_74"></a>消息自带TTL和队列TTL的关系</h2> 
<p>如果一个自带TTL的消息被路由到一个所有消息都被队列指定TTL的队列上，那么哪个TTL生效呢？<br> 我们用第二个案例的接口，给第一个案例的队列发送一个自带TTL的消息。</p> 
<h3><a id="TTL__TTL_77"></a>消息TTL &lt; 队列指定TTL</h3> 
<p><img src="https://images2.imgbox.com/43/28/yvYUalGb_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/96/25/sYKKilvm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4b/f9/tDajuhRk_o.png" alt="在这里插入图片描述"><br> 可以看到消息在20秒时就进入了死信。</p> 
<h3><a id="TTL__TTL_84"></a>消息TTL &gt; 队列指定TTL</h3> 
<p><img src="https://images2.imgbox.com/19/3b/NzmuelYx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0e/b2/EowpUf80_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1d/45/609aWK9Y_o.png" alt="在这里插入图片描述"><br> 可以看到消息在30秒时就进入了死信。</p> 
<h3><a id="_89"></a>总结</h3> 
<p>如果队列指定TTL，消息也设置了TTL，取最接近当前时间的TTL。即用最短的那一个。</p> 
<h2><a id="_91"></a>代码工程</h2> 
<p><a href="https://github.com/f304646673/RabbitMQDemo">https://github.com/f304646673/RabbitMQDemo</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f13f1ee49d72452aafd46aa70e9f0d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Websocket在实时视频监控行业中的应用，以及如何应用于视频监控平台及其web客户端</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/832596c474759b06bb40d9b09378aed8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NPM 常用命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>