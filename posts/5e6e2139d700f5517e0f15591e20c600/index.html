<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Bean 的生命周期总结 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5e6e2139d700f5517e0f15591e20c600/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Bean 的生命周期总结">
  <meta property="og:description" content="目录
一、Bean生命周期的五个阶段
Bean的初始化
二、@PostConstruct 和 @PreDestroy 各自的效果
三、 实例化和初始化的区别
四、为什么要先设置属性在进⾏初始化呢？
一、Bean生命周期的五个阶段 Java 中的公共类称之为 Bean 或 Java Bean，而 Spring 中的 Bean 指的是将对象的生命周期，交个 Spring IoC 容器来管理的对象。所以 Spring 中的 Bean 对象在使用时，无需通过 new 来创建对象，只需要通过 DI（依赖注入），从 Spring 中取出要使用的对象即可。
Bean作为一个Java对象，具有一定的生命周期。它的生命周期包括以下几个阶段：
实例化：在Java应用程序中，Bean对象是通过new关键字或者反射机制来实例化的。在这个阶段，Bean对象被创建，并分配了内存空间。设置属性(Bean注入和装配)初始化：当Bean对象被创建后，需要进行初始化，包括设置属性值、执行一些初始化操作等。在Spring框架中，Bean的初始化可以通过配置文件中的init-method属性进行指定。使用：在Bean初始化之后，它就可以被应用程序使用了。在使用过程中，Bean可能会调用其他对象的方法，从而导致其他Bean对象被实例化和初始化。销毁：当Bean对象不再被使用时，应该将其销毁并释放占用的内存空间。在Spring框架中，Bean的销毁可以通过配置文件中的destroy-method属性进行指定。 总的来说，Bean对象的生命周期可以通过实例化、初始化、使用和销毁这几个阶段来描述。在Spring框架中，Bean的生命周期还可以通过BeanPostProcessor接口来进行扩展和定制。
为了便于理解 我们引用一个现实中的事件来形容 Bean 的⽣命流程看似繁琐，但咱们可以以⽣活中的场景来理解它，⽐如我们现在需要买⼀栋房⼦，那么我们的流程是这样的：
1. 先买房（实例化，从⽆到有）；
2. 装修（设置属性）；
3. 买家电，如洗⾐机、冰箱、电视、空调等（[各种]初始化）；
4. ⼊住（使⽤ Bean）；
5. 卖出去（Bean 销毁）。 Bean的初始化 执行各种通知(BeanNameAware、BeanFactoryAware)等接口方法初始化的前置方法(PostConstruct)初始化方法初始化的后置方法(PreDestroy) 下面用代码演示整个Bean的生命周期:
我们用构造方式来展示实例化的效果 ,实例化和属性设置是 Java 级别的系统“事件”，其操作过程不可⼈⼯⼲预和修改 所以下面没有演示设置属性
package com.example.bean.test; import org.springframework.beans.factory.BeanNameAware; import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; import javax.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-09T14:07:15+08:00">
    <meta property="article:modified_time" content="2023-09-09T14:07:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Bean 的生命周期总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c2/9f/qBIA6x9O_o.png"> </p> 
<blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E4%B8%80%E3%80%81Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5" rel="nofollow">一、Bean生命周期的五个阶段</a></p> 
 <p id="Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">Bean的初始化</a></p> 
 <p id="-toc" style="margin-left:40px;"></p> 
 <p id="%E4%BA%8C%E3%80%81%40PostConstruct%20%E5%92%8C%20%40PreDestroy%20%E5%90%84%E8%87%AA%E7%9A%84%E6%95%88%E6%9E%9C-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%40PostConstruct%20%E5%92%8C%20%40PreDestroy%20%E5%90%84%E8%87%AA%E7%9A%84%E6%95%88%E6%9E%9C" rel="nofollow">二、@PostConstruct 和 @PreDestroy 各自的效果</a></p> 
 <p id="%E4%B8%89%E3%80%81%C2%A0%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%C2%A0%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">三、 实例化和初始化的区别</a></p> 
 <p id="%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%9C%A8%E8%BF%9B%E2%BE%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%A2%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%9C%A8%E8%BF%9B%E2%BE%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%A2%EF%BC%9F" rel="nofollow">四、为什么要先设置属性在进⾏初始化呢？</a></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5"><a id="pandas_16"></a>一、Bean生命周期的五个阶段</h2> 
<p>Java 中的公共类称之为 Bean 或 Java Bean，而 Spring 中的 Bean 指的是将对象的生命周期，交个 Spring IoC 容器来管理的对象。所以 Spring 中的 Bean 对象在使用时，无需通过 new 来创建对象，只需要通过 DI（依赖注入），从 Spring 中取出要使用的对象即可。</p> 
<blockquote> 
 <p>Bean作为一个Java对象，具有一定的生命周期。它的生命周期包括以下几个阶段：</p> 
 <ol><li>实例化：在Java应用程序中，Bean对象是通过new关键字或者反射机制来实例化的。在这个阶段，Bean对象被创建，并分配了内存空间。</li><li>设置属性(Bean注入和装配)</li><li>初始化：当Bean对象被创建后，需要进行初始化，包括设置属性值、执行一些初始化操作等。在Spring框架中，Bean的初始化可以通过配置文件中的init-method属性进行指定。</li><li>使用：在Bean初始化之后，它就可以被应用程序使用了。在使用过程中，Bean可能会调用其他对象的方法，从而导致其他Bean对象被实例化和初始化。</li><li>销毁：当Bean对象不再被使用时，应该将其销毁并释放占用的内存空间。在Spring框架中，Bean的销毁可以通过配置文件中的destroy-method属性进行指定。</li></ol> 
 <p>总的来说，Bean对象的生命周期可以通过实例化、初始化、使用和销毁这几个阶段来描述。在Spring框架中，Bean的生命周期还可以通过BeanPostProcessor接口来进行扩展和定制。</p> 
</blockquote> 
<p><strong>为了便于理解  我们引用一个现实中的事件来形容  </strong></p> 
<blockquote> 
 <p>Bean 的⽣命流程看似繁琐，但咱们可以以⽣活中的场景来理解它，⽐如我们现在需要买⼀栋房⼦，那么我们的流程是这样的：<br> 1. 先买房（实例化，从⽆到有）；<br> 2. 装修（设置属性）；<br> 3. 买家电，如洗⾐机、冰箱、电视、空调等（[各种]初始化）；<br> 4. ⼊住（使⽤ Bean）；<br> 5. 卖出去（Bean 销毁）。 </p> 
</blockquote> 
<h3 id="Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">Bean的初始化</h3> 
<blockquote> 
 <ol><li>执行各种通知(BeanNameAware、BeanFactoryAware)等接口方法</li><li>初始化的前置方法(PostConstruct)</li><li>初始化方法</li><li>初始化的后置方法(PreDestroy)</li></ol> 
</blockquote> 
<p><img alt="" height="1147" src="https://images2.imgbox.com/94/8c/pBbSc1Ig_o.png" width="1200"></p> 
<h3><a id="1_20"></a></h3> 
<p>下面用代码演示整个Bean的生命周期:<br> 我们用构造方式来展示实例化的效果 ,实例化和属性设置是 Java 级别的系统“事件”，其操作过程不可⼈⼯⼲预和修改  所以下面没有演示设置属性</p> 
<pre><code class="language-java">package com.example.bean.test;

import org.springframework.beans.factory.BeanNameAware;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Component
public class BeanLifeComponent implements BeanNameAware {

    private String name;

    public BeanLifeComponent() {
        System.out.println("实例化方法执行拉");
    }


    public void setBeanName(String s) {
        System.out.println("执行 BeanName 的通知方法");
    }

    @PostConstruct
    public void postConstruct() {
        System.out.println("初始化方法执行");
    }

    public void use() {
        System.out.println("使用 Bean");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("销毁方法执行");
    }
}
</code></pre> 
<p><span style="color:#4da8ee;">因为初始化的前置方法和后置方法是为所有 Bean 服务的，而非为某一个 Bean 服务的，所以这两个方法不能写在某个具体的 Bean 中，否则（这两个方法）不会执行。 所以我们另外创建一个类来实现这两个方法</span></p> 
<pre><code class="language-java">package com.example.bean.test;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.stereotype.Component;

@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (beanName.equals("beanLifeComponent")) {
            System.out.println("初始化前置方法执行");
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (beanName.equals("beanLifeComponent")) {
            System.out.println("初始化后置方法执行");
        }
        return bean;
    }
}
</code></pre> 
<p> 在得到上下文对象这里  因为我们是使用springboot演示的 所以我们使用ConfigurableApplicationContext 来得到上下文对象</p> 
<pre><code class="language-java">package com.example.bean.test;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        // 得到上下文对象，并启动 Spring Boot 项目
        ConfigurableApplicationContext context = 
            SpringApplication.run(DemoApplication.class, args);
        // 获取 Bean
        BeanLifeComponent component = context.getBean(BeanLifeComponent.class);
        // 使用 Bean
        component.use();
        // 停止 Spring Boot 项目
        context.close();
    }
}</code></pre> 
<p><strong>结果如下: </strong></p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/2c/ae/I8QgxlxC_o.png" width="700"></p> 
<h2 id="%E4%BA%8C%E3%80%81%40PostConstruct%20%E5%92%8C%20%40PreDestroy%20%E5%90%84%E8%87%AA%E7%9A%84%E6%95%88%E6%9E%9C">二、@PostConstruct 和 @PreDestroy 各自的效果</h2> 
<blockquote> 
 <ol><li>当Bean被容器初始化之后，会调用@PostConstruct的注解方法。</li><li>当Bean在容器销毁之前，调用被@PreDestroy注解的方法</li></ol> 
</blockquote> 
<p>代码如下:所以，PostConstruct 注释用于在依赖关系注入完成之后需要执行的方法上，以执行任何初始化。此方法必须在将类放入服务之前调用。支持依赖关系注入的所有类都必须支持此注释。即使类没有请求注入任何资源，用PostConstruct 注释的方法也必须被调用。只有一个方法可以用此注释进行注释。</p> 
<pre><code class="language-java">    @PostConstruct
    public void doPostConstruct(){
        System.out.println("执行了 新版本@PostConstruct 前置初始化方法");
    }
    @PreDestroy
    public void doPreDestroy(){
        System.out.println("执行新版本 @PreDestroy 销毁方法");

    }</code></pre> 
<blockquote> 
 <p>PreDestroy 用与在依赖注入完成之前的方法前面执行，遵守准则：</p> 
 <ol><li>该方法不得有任何参数</li><li>该方法的返回类型必须为 void；</li><li>该方法不得抛出已检查异常；</li><li>应用 PostConstruct 的方法可以是 public、protected、package private 或 private；</li><li>该方法不能是 static；该方法可以是 final；</li><li>该方法只会被执行一次</li></ol> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%C2%A0%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB">三、 实例化和初始化的区别</h2> 
<blockquote> 
 <p>实例化和属性设置是 Java 级别的系统“事件”，其操作过程不可⼈⼯⼲预和修改；⽽初始化是给开发者提供的，可以在实例化之后，类加载完成之前进⾏⾃定义“事件”处理。</p> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%9C%A8%E8%BF%9B%E2%BE%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%A2%EF%BC%9F">四、为什么要先设置属性在进⾏初始化呢？</h2> 
<p>仔细观察下面代码:</p> 
<pre><code class="language-java">    @Service
    public class UserService {
        public UserService(){
            System.out.println("调⽤ User Service 构造⽅法");
        }
        public void sayHi(){
            System.out.println("User Service SayHi.");
        }
    } 
    @Controller
    public class UserController {
        @Resource
        private UserService userService;
        @PostConstruct
        public void postConstruct() {
            userService.sayHi();
            System.out.println("执⾏ User Controller 构造⽅法");
        }
    }</code></pre> 
<p>我们可以发现很是为了避免空指针异常。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/66/be/waKLW819_o.png"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/011510b018f590e5d7d73fc90309382c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot&#43;jSerialComm实现Java串口通信 读取串口数据以及发送数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a06181eb25eadec9e15646b6c744ec59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43; • STL • 力扣】详解string相关OJ</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>