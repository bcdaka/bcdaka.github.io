<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划——背包问题（01，完全，多重） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/822fa173ab35c171d9c62d27b152d5d3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="动态规划——背包问题（01，完全，多重）">
  <meta property="og:description" content="一、01背包问题 1.题目描述 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。
01背包问题特点：每个物品只能用一次，只能选择或者不选择
2.动态规划思想 动态规划就是需要解决子问题，再通过状态转移方程拓展至整体最优。即需要满足：问题的最优解中包含的子问题也是最优的。
定义 ：当前背包容量为 j ，考虑前 i 个物品的最佳组合对应的价值。
当考虑背包容量为 j ，前 i 个物品的选择时，有两种想法：
① 不选择第 i 件 物品 则 ② 选择第 i 件 物品，则需要考虑到剩余的背包容量 j - w[ i ] ：
​​​​​​​ 最终状态转移方程：
、
由于状态转移过程都是由原先的状态得到的，因此思想成立。
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; const int N=1010; int f[N][N]; int v[N], w[N]; int n, m; int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i&#43;&#43;) cin&gt;&gt;w[i]&gt;&gt;v[i]; f[0][0]=0; for(int i=1;i&lt;=n;i&#43;&#43;) for(int j=0;j&lt;=m;j&#43;&#43;) { if(j&lt;w[i]) f[i][j]=f[i-1][j]; if(j&gt;=w[i]) f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]&#43;v[i]); } cout&lt;&lt;f[n][m]&lt;&lt;endl; return 0; } 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T20:17:07+08:00">
    <meta property="article:modified_time" content="2024-05-06T20:17:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划——背包问题（01，完全，多重）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、01背包问题</h2> 
<h3>        1.题目描述</h3> 
<blockquote> 
 <p>        有 N 件物品和一个容量是 V 的背包。<strong>每件物品只能使用一次</strong>。第 i 件物品的体积是 vi，价值是 wi。</p> 
 <p>        求解将哪些物品装入背包，可使这些物品的<strong>总体积不超过背包容量，且总价值最大</strong>。输出最大价值。</p> 
</blockquote> 
<p>         01背包问题特点：<strong>每个物品只能用一次，只能选择或者不选择</strong></p> 
<h3>        2.动态规划思想</h3> 
<p>        动态规划就是需要解决子问题，<strong>再通过状态转移方程拓展至整体最优</strong>。即需要满足：<strong>问题的最优解中包含的子问题也是最优的。</strong></p> 
<p><strong>  <strong>     </strong></strong> 定义 <img alt="F[i][j]" class="mathcode" src="https://images2.imgbox.com/31/81/KuT5qHnE_o.png"> ：当前背包容量为 j ，考虑前 i 个物品的最佳组合对应的价值。</p> 
<p>当考虑背包容量为 j ，前 i 个物品的选择时，有两种想法：</p> 
<p>        ① 不选择第 i 件 物品 则 <img alt="F[i][j]=F[i-1][j]" class="mathcode" src="https://images2.imgbox.com/3e/f4/gABFAJIo_o.png"></p> 
<p>        ② 选择第 i 件 物品，则需要考虑到剩余的背包容量 j - w[ i ] ：</p> 
<p>                                ​​​​​​​        <img alt="F[i][j]=F[i-1][j-w[i]]+v[i]" class="mathcode" src="https://images2.imgbox.com/b3/61/3c1DDNIx_o.png"></p> 
<p><strong>最终状态转移方程：</strong></p> 
<p>        <img alt="j&lt;w[i] \, \, \, \, \, \, \, \, F[i][j]=F[i-1][j]" class="mathcode" src="https://images2.imgbox.com/3c/8c/cF5AGNq1_o.png"></p> 
<p>        <img alt="j&gt;=w[i] \, \, \, \, \, \, \, \, \, \, \, \, F[i][j]=max(F[i-1][j],F[i-1][j-w[i]]+v[i])" class="mathcode" src="https://images2.imgbox.com/c0/6b/YirAllC9_o.png">、</p> 
<p>        由于状态转移过程<img alt="F[i][j]" class="mathcode" src="https://images2.imgbox.com/12/95/G71kgehJ_o.png">都是由原先的状态得到的，因此思想成立。</p> 
<pre><code class="hljs">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=1010;
int f[N][N];
int v[N], w[N];
int n, m;
int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i];
	f[0][0]=0;
	for(int i=1;i&lt;=n;i++)
		for(int j=0;j&lt;=m;j++)
		{
			if(j&lt;w[i])  f[i][j]=f[i-1][j];
			if(j&gt;=w[i]) f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]);
		}
	cout&lt;&lt;f[n][m]&lt;&lt;endl;
	return 0;
}
</code></pre> 
<h3>         3. 01背包问题的探索</h3> 
<p>        在上述状态转移方程的过程中可以发现，在每次状态更新后，之前<strong>存储的数据不会再次用到</strong>，从而造成了空间上的浪费，可以<strong>将上述情况的二维数组压缩成一维数组，这时的数组就是动态变化的了</strong>。</p> 
<p>        与二维数组不同的是，在第二次循环过程中，<strong>背包容量的循环量应当从大到小（m-&gt;w[i]）</strong>，<strong>避免同一件物品被反复选择</strong>。 例如：</p> 
<p>        当一件物品的体积为 1  价值为 10，当背包容量的循环量从小到大时， 运行F[1]=10，循环继续进行，F[2]=max(F[2],F[2-1]+10)=20。 即选择该物品两次，与01背包问题仅有一件商品不符，<strong>该方法适用于完全背包问题（同一件商品可以取多次）</strong></p> 
<pre><code class="hljs">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=1010;
int f[N];
int v[N], w[N];
int n, m;
int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i];
	f[0][0]=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=m;j&gt;=w[i];j--)  // 从后往前，避免同一件商品反复选择（01背包）
	{
		f[j]=max(f[j],f[j-w[i]]+v[i]);
	}
	cout&lt;&lt;f[m]&lt;&lt;endl;
	return 0;
}
</code></pre> 
<h2>二、完全背包问题</h2> 
<h3>        题目描述</h3> 
<blockquote> 
 <p>         有 N 件物品和一个容量是 V 的背包。<strong>每件物品数量为无限个</strong>。第 i 件物品的体积是 vi，价值是 wi。</p> 
 <p>        求解将哪些物品装入背包，可使这些物品的<strong>总体积不超过背包容量，且总价值最大</strong>。输出最大价值。</p> 
 <p>        与01背包问题的唯一区别在于：完全背包的物品数量可以取无限个</p> 
</blockquote> 
<p>        在01背包问题的讲述过程中已经明确解释了完全背包问题的解法：<strong>在01背包一维数组的情况下，将背包容量的循环量从小到大遍历，</strong>在数组不断更新的情况下能够让某件物品多次装入。</p> 
<pre><code class="hljs">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=1010;
int f[N];
int v[N], w[N];
int n, m;
int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i];
	f[0][0]=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=w[i];j&lt;=m;j++)  // 从前往后，能够让某件物品多次选择（完全背包问题）
	{
		f[j]=max(f[j],f[j-w[i]]+v[i]);
	}
	cout&lt;&lt;f[m]&lt;&lt;endl;
	return 0;
}
</code></pre> 
<h2>三、多重背包问题  </h2> 
<h3>        1.题目描述</h3> 
<blockquote> 
 <p>        有 N 件物品和一个容量是 V 的背包。第 i 件物品的体积是 vi，价值是 wi，数量是 ki。</p> 
 <p>        求解将哪些物品装入背包，可使这些物品的<strong>总体积不超过背包容量，且总价值最大</strong>。输出最大价值。</p> 
 <p>        与前两种背包问题的联系：01背包和完全背包都是对于某种情况的极端，而<strong>多重背包问题则是介于二者之间，每个物品可以取不同个数的情况。</strong></p> 
</blockquote> 
<p>         根据多重背包与01背包，完全背包的关系，可以得出一个简单的想法：</p> 
<p>   <strong>     ①. 把多重背包问题变成01背包问题：</strong></p> 
<p>        即当某个物品有k个时，可以看作存<strong>在相同的体积，价值的k个不同的物品</strong>，这样就可以存在每个物品取一个或者取几个的情况。</p> 
<p>        或者再利用一层循环 k 枚举该物品取的次数，保证存在取多次的情况。</p> 
<p>        这种想法显然成立，但只适用于数量较少的情况，如果每种物品的数量变大，<strong>存在超时的情况，因此不是最优的解法</strong>。</p> 
<p>       <strong>②.联系完全背包问题</strong></p> 
<p>        <strong>当背包不能装在某种物品的全部数量时，即（V&lt;w[i]*k），则此时一定不能取完，可以看作完全背包问题，此时只需要简单的讨论即可。</strong></p> 
<p>        将多重背包转化成01背包和完全背包的结合只能进行小优化。</p> 
<h3>        2.多重背包问题的优化</h3> 
<p><strong>        ① 二进制优化</strong></p> 
<p>                例如想要取512件物品时，按照转化成01背包问题，需要从第一件枚举512件，而采用二进制的想法，把每次取物品的件数分为1，2，4，8........256.512...2^n，枚举9次就取到512件了，此外每个数都可以用二进制数的组合来表示，例如 10=1+2+4+3   15=1+2+4+8</p> 
<pre><code class="hljs">k=1;cnt=0;
while(k&lt;=s)    //k为枚举个数，s为物品总件数
{
	v[++cnt]=k*a;
	w[cnt]=k*b;
	s-=k;       //总物品数减去合成数
	k*=2;       //k倍增
}
if(s)// s有剩余，将剩余件数合成为新个体
{
	v[++cnt]=s*a;
	w[cnt]=s*b;
}</code></pre> 
<p> 将每种物品的 k 都经过上述过程，构造出两个数组（存储有二进制数的数据）价值数组和重量数组，再通过01背包的思想，即可解决问题。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60dcda8eb3684ec862d36c4aa47ac76e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024年前端最全前端程序员简历模板整理和下载(1)，写得太好了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/286f1997ec260dc58c14254c03c16b4c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AIGC-音频生产十大主流模型技术原理及优缺点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>