<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构 —— 二叉树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bbe48b01e0574b11daf787feb55e631d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构 —— 二叉树">
  <meta property="og:description" content="1.树的概念及结构 1.1树的概念 树是一种非线性的数据结构，它有着多分支，层次性的特点。
由于其形态类似于自然界中倒过来的数，所以我们将这种数据结构称为“树形结构”
注意： 树形结构中，子树之间不能有交集，否它就不是树形结构
1.2 树的相关概念 结点的度：一个结点含有的子树的个数称为该结点的度； 如上图：A的为6 叶结点或终端结点：度为0的结点称为叶结点； 如上图：B、C、H、I...等结点为叶结点 非终端结点或分支结点：度不为0的结点； 如上图：D、E、F、G...等结点为分支结点 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点 兄弟结点：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点 树的度：一棵树中，最大的结点的度称为树的度； 如上图：树的度为6 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推； 树的高度或深度：树中结点的最大层次； 如上图：树的高度为4 堂兄弟结点：双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点 结点的祖先：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先 子孙：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙 森林：由m（m&gt;0）棵互不相交的树的集合称为森林； 1.3树的表示 树的表示我们使用：孩子兄弟表示法
设计一个数的节点，其中包含数据域（存储数据）、指针域（左孩子指针，右兄弟指针）
typedef int DataType; struct Node { struct Node* firstChild1; // 第一个孩子结点 struct Node* pNextBrother; // 指向其下一个兄弟结点 DataType data; // 结点中的数据域 }; 这种数的设计方法，我们可以通过左孩子指针找到 A节点 的第一个孩子(B)，在通过孩子的右兄弟指针把 A节点 的所有孩子都找到
1.4 树在实际中的运用 树在实际中的运用：电脑中的数目录
2.二叉树的概念及结构 2.1二叉树的概念 在实际运用中，二叉树要比树更加实用
二叉树其实就是特殊的一种树，它的每个节点最多有两个子节点，通常被称为左子节点和右子节点
二叉树不存在度大于2的结点 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 2.2现实中的二叉树 2.3特殊的二叉树 满二叉树：二叉树的每一层都是满的（特殊的完全二叉树）完全二叉树：二叉树的最后一层不一定是满的，但是它是连续的 像下面这个二叉树，最后一层并不连续，因此它并非是完全二叉树：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-28T16:35:39+08:00">
    <meta property="article:modified_time" content="2024-06-28T16:35:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构 —— 二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.树的概念及结构</h2> 
<h3>1.1树的概念</h3> 
<p>树是一种非线性的数据结构，它有着多分支，层次性的特点。</p> 
<p>由于其形态类似于自然界中倒过来的数，所以我们将这种数据结构称为“树形结构”</p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/79/1e/dspAYvna_o.png" width="993"></p> 
<p>注意： 树形结构中，子树之间不能有交集，否它就不是树形结构</p> 
<p> <img alt="" height="399" src="https://images2.imgbox.com/ac/92/iH54t8Fz_o.png" width="700"></p> 
<h3>1.2 树的相关概念</h3> 
<p class="img-center"><img alt="" height="343" src="https://images2.imgbox.com/c0/ac/njsojVmQ_o.png" width="604"></p> 
<p></p> 
<ul><li><span style="color:#777777;"><strong>结点的度</strong></span><span style="color:#777777;">：一个结点含有的子树的个数称为该结点的度； 如上图：</span><span style="color:#777777;">A</span><span style="color:#777777;">的为</span><span style="color:#777777;">6 </span></li><li><span style="color:#777777;"><strong>叶结点或终端结点</strong></span><span style="color:#777777;">：度为</span><span style="color:#777777;">0</span><span style="color:#777777;">的结点称为叶结点； 如上图：</span><span style="color:#777777;">B</span><span style="color:#777777;">、</span><span style="color:#777777;">C</span><span style="color:#777777;">、</span><span style="color:#777777;">H</span><span style="color:#777777;">、</span><span style="color:#777777;">I...</span><span style="color:#777777;">等结点为叶结点 </span></li><li><span style="color:#777777;"><strong>非终端结点或分支结点</strong></span><span style="color:#777777;">：度不为</span><span style="color:#777777;">0</span><span style="color:#777777;">的结点； 如上图：</span><span style="color:#777777;">D</span><span style="color:#777777;">、</span><span style="color:#777777;">E</span><span style="color:#777777;">、</span><span style="color:#777777;">F</span><span style="color:#777777;">、</span><span style="color:#777777;">G...</span><span style="color:#777777;">等结点为分支结点 </span></li><li><span style="color:#777777;"><strong>双亲结点或父结点</strong></span><span style="color:#777777;">：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：</span><span style="color:#777777;">A</span><span style="color:#777777;">是</span><span style="color:#777777;">B</span><span style="color:#777777;">的父结点 </span></li><li><span style="color:#777777;"><strong>孩子结点或子结点</strong></span><span style="color:#777777;">：一个结点含有的子树的根结点称为该结点的子结点； 如上图：</span><span style="color:#777777;">B</span><span style="color:#777777;">是</span><span style="color:#777777;">A</span><span style="color:#777777;">的孩子结点 </span></li><li><span style="color:#777777;"><strong>兄弟结点</strong></span><span style="color:#777777;">：具有相同父结点的结点互称为兄弟结点； 如上图：</span><span style="color:#777777;">B</span><span style="color:#777777;">、</span><span style="color:#777777;">C</span><span style="color:#777777;">是兄弟结点 </span></li><li><span style="color:#777777;"><strong>树的度</strong></span><span style="color:#777777;">：一棵树中，最大的结点的度称为树的度； 如上图：树的度为</span><span style="color:#777777;">6 </span></li><li><span style="color:#777777;"><strong>结点的层次</strong></span><span style="color:#777777;">：从根开始定义起，根为第</span><span style="color:#777777;">1</span><span style="color:#777777;">层，根的子结点为第</span><span style="color:#777777;">2</span><span style="color:#777777;">层，以此类推； </span></li><li><span style="color:#777777;"><strong>树的高度或深度</strong></span><span style="color:#777777;">：树中结点的最大层次； 如上图：树的高度为</span><span style="color:#777777;">4 </span></li><li><span style="color:#777777;"><strong>堂兄弟结点</strong></span><span style="color:#777777;">：双亲在同一层的结点互为堂兄弟；如上图：</span><span style="color:#777777;">H</span><span style="color:#777777;">、</span><span style="color:#777777;">I</span><span style="color:#777777;">互为兄弟结点 </span></li><li><span style="color:#777777;"><strong>结点的祖先</strong></span><span style="color:#777777;">：从根到该结点所经分支上的所有结点；如上图：</span><span style="color:#777777;">A</span><span style="color:#777777;">是所有结点的祖先 </span></li><li><span style="color:#777777;"><strong>子孙</strong></span><span style="color:#777777;">：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是</span><span style="color:#777777;">A</span><span style="color:#777777;">的子孙 </span></li><li><span style="color:#777777;"><strong>森林</strong></span><span style="color:#777777;">：由</span><span style="color:#777777;">m</span><span style="color:#777777;">（</span><span style="color:#777777;">m&gt;0</span><span style="color:#777777;">）棵互不相交的树的集合称为森林； </span></li></ul> 
<h3>1.3树的表示 </h3> 
<p>树的表示我们使用：孩子兄弟表示法</p> 
<p>设计一个数的节点，其中包含数据域（存储数据）、指针域（左孩子指针，右兄弟指针）</p> 
<pre><code>typedef int DataType;
struct Node
{
 struct Node* firstChild1; // 第一个孩子结点
 struct Node* pNextBrother; // 指向其下一个兄弟结点
 DataType data; // 结点中的数据域
};</code></pre> 
<p>这种数的设计方法，我们可以通过<strong>左孩子指针</strong>找到 A节点 的第一个孩子(B)，在通过孩子的右兄弟指针把 A节点 的所有孩子都找到</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/6d/98/Ngm3tvF3_o.png" width="1106"></p> 
<h3>1.4 树在实际中的运用</h3> 
<p>树在实际中的运用：电脑中的数目录</p> 
<p><img alt="" height="582" src="https://images2.imgbox.com/3b/6a/ZlLtuFGt_o.png" width="1085"></p> 
<h2>2.二叉树的概念及结构 </h2> 
<h3>2.1二叉树的概念 </h3> 
<p>在实际运用中，二叉树要比树更加实用</p> 
<p>二叉树其实就是特殊的一种树，它的每个节点最多有两个子节点，通常被称为左子节点和右子节点</p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/69/1c/bkOzO4ff_o.png" width="894"></p> 
<ul><li><span style="color:#777777;"> </span><span style="color:#777777;">二叉树不存在度大于</span><span style="color:#777777;">2</span><span style="color:#777777;">的结点 </span></li><li><span style="color:#777777;"> </span><span style="color:#777777;">二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树</span></li></ul> 
<h3>2.2现实中的二叉树</h3> 
<h3><img alt="" height="558" src="https://images2.imgbox.com/90/fb/SsuttUCT_o.png" width="720"></h3> 
<h3 style="background-color:transparent;"> 2.3特殊的二叉树</h3> 
<p> <img alt="" height="308" src="https://images2.imgbox.com/9f/7e/wYj8u4hH_o.png" width="765"></p> 
<ul><li> 满二叉树：二叉树的每一层都是满的（特殊的完全二叉树）</li><li>完全二叉树：二叉树的最后一层不一定是满的，但是它是连续的</li></ul> 
<p>像下面这个二叉树，最后一层并不连续，因此它并非是完全二叉树：</p> 
<p class="img-center"><img alt="" height="335" src="https://images2.imgbox.com/7e/6c/Gq7BLJmX_o.png" width="437"></p> 
<h3>2.4二叉树的性质</h3> 
<p><img alt="" height="390" src="https://images2.imgbox.com/e4/e5/ER8tyvGN_o.png" width="1050"></p> 
<h3>2.5二叉树的存储结构</h3> 
<div> 
 <span style="color:#777777;">二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;"><strong>顺序存储</strong></span> 
</div> 
<div> 
 <div> 
  <span style="color:#777777;">顺序结构存储就是使用</span> 
  <span style="color:#777777;"><strong>数组来存储</strong></span> 
  <span style="color:#777777;">，一般使用数组</span> 
  <span style="color:#777777;"><strong>只适合表示完全二叉树</strong></span> 
  <span style="color:#777777;">，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储</span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树</strong></span> 
 </div> 
 <div></div> 
 <div> 
  <img alt="" height="676" src="https://images2.imgbox.com/13/eb/pSNCU3Q4_o.png" width="790"> 
 </div> 
 <div></div> 
 <div></div> 
 <div> 
  <span style="color:#777777;">2. </span> 
  <span style="color:#777777;"><strong>链式存储</strong></span> 
 </div> 
 <div> 
  <div> 
   <div> 
    <span style="color:#777777;">二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。</span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#777777;">通常的方法是：链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链，目前我们使用二叉链的新式学习</span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#777777;">二叉链式实现的二叉树：</span> 
   </div> 
  </div> 
  <div> 
   <img alt="" height="629" src="https://images2.imgbox.com/9e/5b/tuJhk3uh_o.png" width="947"> 
  </div> 
 </div> 
</div> 
<p></p> 
<h2>3.二叉树的顺序存储结构 </h2> 
<p>顺序存储结构只推荐<span style="color:#ffd900;">完全叉树</span>来进行存储，一般的二叉树容使用顺序结构进行存储，容易造成空间的大量浪费，<span style="color:#777777;"><strong>现实中我们通常把堆</strong></span><span style="color:#777777;"><strong>(</strong></span><span style="color:#777777;"><strong>一种二叉树</strong></span><span style="color:#777777;"><strong>)</strong></span><span style="color:#777777;"><strong>使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统</strong></span><span style="color:#777777;"><strong>虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段</strong></span></p> 
<p>堆在这篇文章中有所介绍 ———— <a class="link-info" href="https://blog.csdn.net/2301_78957570/article/details/139391881" title="数据结构 - 堆">数据结构 - 堆</a></p> 
<h2>4.二叉树的链式结构的实现</h2> 
<p>在进行二叉树链式结构的实现时，我们首先回顾<strong>二叉树是：</strong></p> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;"><strong>空树 </strong></span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;"><strong>非空：根结点，根结点的左子树、根结点的右子树组成的</strong></span> 
</div> 
<div></div> 
<div> 
 <img alt="" height="454" src="https://images2.imgbox.com/34/cc/xx1n2oqQ_o.png" width="894"> 
</div> 
<div></div> 
<p>每一颗二叉树都可以看做是递归形成的因为：</p> 
<p>每一颗二叉树都可以拆分成：根节点 左子树 右子树</p> 
<p>它的左子树可以被拆分成 ：根节点 左子树 右子树</p> 
<p>它的右子树右也可以被拆分成 ：根节点 左子树 右子树</p> 
<p>依次类推直到变成一颗空树，不能被拆分，所以才会说二叉树可以看做是递归形成，二叉树可以被拆分成一个一个的小问题（即一个一个的子树 根节点），直到变成空树不能再被拆分，<span style="color:#777777;">因此后序基本操作中基本都是按照递归概念实现的</span></p> 
<h3>4.1二叉树的前置声明</h3> 
<pre><code>typedef int BTDataType;

typedef struct BinaryTreeNode    //二叉树的单个节点
{
 BTDataType _data;
 struct BinaryTreeNode* _left;   //左孩子
 struct BinaryTreeNode* _right;  //右孩子
}BTNode;</code></pre> 
<h3>4.2二叉树的遍历</h3> 
<h4>4.2.1<span style="color:#777777;"><strong>前序、中序以及后序遍历 </strong></span></h4> 
<p><strong>二叉树的遍历是指按照某种规则访问树中的所有节点，并且每个节点只被访问一次。</strong><span style="color:#777777;">访问结点所做的操作依赖于具体的应用问题。遍历是二叉树上最重要的运算之一，也是二叉树上进行其它运算的基础。</span></p> 
<blockquote> 
 <p><span style="color:#777777;">按照规则，二叉树的遍历有：</span><span style="color:#777777;"><strong>前序</strong></span><span style="color:#777777;"><strong>/</strong></span><span style="color:#777777;"><strong>中序</strong></span><span style="color:#777777;"><strong>/</strong></span><span style="color:#777777;"><strong>后序的递归结构遍历</strong></span><span style="color:#777777;">：</span> </p> 
 <div> 
  <span style="color:#777777;">1. </span> 
  <span style="color:#777777;">前序遍历</span> 
  <span style="color:#777777;">(Preorder Traversal</span> 
  <span style="color:#777777;">)——</span> 
  <span style="color:#777777;">访问顺序：根节点 —&gt;左子树 —&gt;右子树</span> 
 </div> 
 <div> 
  <span style="color:#777777;">2. 中序遍历(Inorder Traversal)——访问顺序：左子树 —&gt;根节点 —&gt;右子树</span> 
 </div> 
 <div> 
  <span style="color:#777777;">3. 后序遍历(Postorder Traversal)——访问顺序：左子树 —&gt;右子树—&gt;根节</span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#777777;"><strong>前序遍历递归图解</strong></span> 
 <span style="color:#777777;">： </span> 
</div> 
<div></div> 
<div style="text-align:center;"> 
 <img alt="" src="https://images2.imgbox.com/25/52/j3fBAjfW_o.gif"> 
</div> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/af/5c/QETSDXC2_o.png"></p> 
<p></p> 
<div> 
 <span style="color:#777777;"><strong>前序遍历结果：</strong></span> 
 <span style="color:#777777;"><strong>1 2 3 4 5 6 </strong></span> 
</div> 
<div> 
 <span style="color:#777777;"><strong>中序遍历结果：</strong></span> 
 <span style="color:#777777;"><strong>3 2 1 5 4 6 </strong></span> 
</div> 
<div> 
 <span style="color:#777777;"><strong>后序遍历结果：</strong></span> 
 <span style="color:#777777;"><strong>3 2 5 6 4 1</strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#ffd900;"><strong>前中后序遍历的方式大抵相同，这里不做过多赘述</strong></span> 
</div> 
<div></div> 
<div> 
 <em><strong>代码实现：</strong></em> 
</div> 
<div> 
 <pre><code>// 二叉树前序遍历 
void BinaryTreePrevOrder(BTNode* root) {

	if (root == NULL)  //当访问的数为NULL树时停止访问
	{
		printf("N ");
		return;
	}

	printf("%d ",root-&gt;_data);//先便利根节点,整形的数据类型

	BinaryTreePrevOrder(root-&gt;_left);//左子树
	BinaryTreePrevOrder(root-&gt;_right);//右子树

}
// 二叉树中序遍历
void BinaryTreeInOrder(BTNode* root) {

	if (root == NULL)
	{
		printf("N ");
		return;
	}

	BinaryTreeInOrder(root-&gt;_left);//左子树
	printf("%d ", root-&gt;_data);//根节点
	BinaryTreeInOrder(root-&gt;_right);//右子树
}

// 二叉树后序遍历
void BinaryTreePostOrder(BTNode* root) {
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	BinaryTreePostOrder(root-&gt;_left);//左子树
	BinaryTreePostOrder(root-&gt;_right);//右子树
	printf("%d ", root-&gt;_data);//根节点
}</code></pre> 
 <p></p> 
</div> 
<p></p> 
<h4>4.2.2层序遍历 </h4> 
<div> 
 <span style="color:#777777;"><strong>层序遍历</strong></span> 
 <span style="color:#777777;">：除了先序遍历、中序遍历、后序遍历外，还可以对二叉树进行层序遍历。设二叉树的根结点所在层数为1</span> 
 <span style="color:#777777;">，层序遍历就是从所在二叉树的根结点出发，首先访问第一层的树根结点，然后从左到右访问第</span> 
 <span style="color:#777777;">2</span> 
 <span style="color:#777777;">层上的结点，接着是第三层的结点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。</span> 
</div> 
<div></div> 
<p class="img-center"><img alt="" height="381" src="https://images2.imgbox.com/56/4e/XtzCHnqO_o.png" width="491"></p> 
<div></div> 
<p></p> 
<p><em><strong> 代码实现：</strong></em></p> 
<p>二叉树的层序遍历并不是通过递归来完成的，而是通过 —— 数据结构中的<strong>队列</strong>来实现的</p> 
<blockquote> 
 <p>遍历的原理是从根节点开始，首先访问根节点，然后将根节点的左右子节点依次入队。接下来，从队列中取出一个节点（队首节点），访问该节点，再将其未被访问的左右子节点入队。重复此过程，直到队列为空，即所有节点都被访问过。</p> 
</blockquote> 
<p>动图理解：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/7b/DyC4g6Ok_o.gif"></p> 
<p></p> 
<pre><code>// 层序遍历
void BinaryTreeLevelOrder(BTNode* root) {
	//创建队列
	Queue qu;
	QueueInit(&amp;qu);
	QueuePush(&amp;qu, root);

	//开始拖家带口，当队列为NULL时，说明已经遍历完成,循环结束
	while (!QueueEmpty(&amp;qu))
	{
		//先访问队头的元素
		BTNode* bt = QueueFront(&amp;qu);//获取队头元素
		printf("%d ", bt-&gt;_data);

		//将树的左右孩子都带入队列中，NULL孩子除外
		if (bt-&gt;_left)
			QueuePush(&amp;qu, bt-&gt;_left);
		if (bt-&gt;_right)
			QueuePush(&amp;qu, bt-&gt;_right);

        //队头数据处队列
		QueuePop(&amp;qu);
	}
    
    //销毁队列
	QueueDestroy(&amp;qu);

}</code></pre> 
<h2>5.二叉树总代码</h2> 
<h3>队列的相关功能：</h3> 
<h4>Queue.h</h4> 
<pre><code>#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef struct BinaryTreeNode* QDataType;   //队列中的元素是树的节点
// 链式结构：表示队列 
typedef struct QListNode
{
	struct QListNode* _next;
	QDataType _data;
}QNode;

// 队列的结构 
typedef struct Queue
{
	QNode* _front;
	QNode* _rear;
	int size;
}Queue;

// 初始化队列 
void QueueInit(Queue* q);
// 队尾入队列 
void QueuePush(Queue* q, QDataType data);
// 队头出队列 
void QueuePop(Queue* q);
// 获取队列头部元素 
QDataType QueueFront(Queue* q);
// 获取队列队尾元素 
QDataType QueueBack(Queue* q);
// 获取队列中有效元素个数 
int QueueSize(Queue* q);
// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
int QueueEmpty(Queue* q);
// 销毁队列 
void QueueDestroy(Queue* q);</code></pre> 
<h4>Queue.c</h4> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include"Queue.h"

// 初始化队列 
void QueueInit(Queue* q) {
	assert(q);

	q-&gt;size = 0;
	q-&gt;_front = NULL;
	q-&gt;_rear = NULL;
}
// 队尾入队列 
void QueuePush(Queue* q, QDataType data) {
	assert(q);

	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("QueuePush()::malloc()");
		return;
	}

	newnode-&gt;_data = data;
	newnode-&gt;_next = NULL;
	
	//队列为NULL
	if (q-&gt;_front == NULL)
	{
		q-&gt;_front = q-&gt;_rear = newnode;
	}
	else
	{
		q-&gt;_rear-&gt;_next = newnode;
		q-&gt;_rear = q-&gt;_rear-&gt;_next;
	}

	q-&gt;size++;
}
// 队头出队列 
void QueuePop(Queue* q) {
	assert(q);
	assert(q-&gt;size != 0);

	//单个节点
	if (q-&gt;_front == q-&gt;_rear)
	{
		free(q-&gt;_front);
		q-&gt;_front = q-&gt;_rear = NULL;
	}
	//多个节点
	else
	{
		QNode* next = q-&gt;_front-&gt;_next;
		free(q-&gt;_front);
		q-&gt;_front = next;
	}

	q-&gt;size--;
}
// 获取队列头部元素 
QDataType QueueFront(Queue* q) {

	assert(q);
	assert(q-&gt;_front);//队头不能为NULL

	return q-&gt;_front-&gt;_data;
}
// 获取队列队尾元素 
QDataType QueueBack(Queue* q) {
	assert(q);
	assert(q-&gt;_rear);//队尾不能为NULL

	return q-&gt;_rear-&gt;_data;
}
// 获取队列中有效元素个数 
int QueueSize(Queue* q) {

	return q-&gt;size;
}
// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
int QueueEmpty(Queue* q) {
	assert(q);

	return q-&gt;size == 0;
}
// 销毁队列 
void QueueDestroy(Queue* q) {
	assert(q);

	QNode* cur = q-&gt;_front;
	while (cur)
	{
		QNode* next = cur-&gt;_next;
		free(cur);
		cur = next;
	}

	q-&gt;_front = q-&gt;_rear = NULL;
	q-&gt;size = 0;

	//这个应该留给用户去释放
	/*free(q);
	q = NULL;*/
}</code></pre> 
<h3>二叉树相关功能：</h3> 
<h4>BinaryTree.h</h4> 
<pre><code>#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include"Queue.h"
typedef char BTDataType;

typedef struct BinaryTreeNode
{
	BTDataType _data;
	struct BinaryTreeNode* _left;
	struct BinaryTreeNode* _right;
}BTNode;


// 二叉树销毁
void BinaryTreeDestory(BTNode** root);

// 二叉树节点个数
int BinaryTreeSize(BTNode* root);

// 二叉树叶子节点个数
int BinaryTreeLeafSize(BTNode* root);

// 二叉树第k层节点个数
int BinaryTreeLevelKSize(BTNode* root, int k);

// 二叉树查找值为x的节点
BTNode* BinaryTreeFind(BTNode* root, BTDataType x);

// 二叉树前序遍历 
void BinaryTreePrevOrder(BTNode* root);

// 二叉树中序遍历
void BinaryTreeInOrder(BTNode* root);

// 二叉树后序遍历
void BinaryTreePostOrder(BTNode* root);

// 层序遍历
void BinaryTreeLevelOrder(BTNode* root);

// 判断二叉树是否是完全二叉树
int BinaryTreeComplete(BTNode* root);

BTNode* CreatBinaryTree();</code></pre> 
<h4>BinaryTree.c</h4> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include"BinaryTree.h"
BTNode* BuyNode(BTDataType x) {

	BTNode* newnode = (BTNode*)malloc(sizeof(BTNode));
	if (newnode == NULL)
	{
		perror("Buynode()::malloc()");
		return newnode;
	}

	newnode-&gt;_data = x;
	newnode-&gt;_left = NULL;
	newnode-&gt;_right = NULL;
	return newnode;
}

// 二叉树前序遍历 
void BinaryTreePrevOrder(BTNode* root) {

	if (root == NULL)  //当访问的数为NULL树时停止访问
	{
		printf("N ");
		return;
	}

	printf("%d ",root-&gt;_data);//先便利根节点,整形的数据类型

	BinaryTreePrevOrder(root-&gt;_left);//左子树
	BinaryTreePrevOrder(root-&gt;_right);//右子树

}
// 二叉树中序遍历
void BinaryTreeInOrder(BTNode* root) {

	if (root == NULL)
	{
		printf("N ");
		return;
	}

	BinaryTreeInOrder(root-&gt;_left);//左子树
	printf("%d ", root-&gt;_data);//根节点
	BinaryTreeInOrder(root-&gt;_right);//右子树
}

// 二叉树后序遍历
void BinaryTreePostOrder(BTNode* root) {
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	BinaryTreePostOrder(root-&gt;_left);//左子树
	BinaryTreePostOrder(root-&gt;_right);//右子树
	printf("%d ", root-&gt;_data);//根节点
}

//求二叉树的高度
int maxDepth(BTNode* root) {

	if (root == NULL)   //如果为空树则返回 0 
	{
		return 0;
	}

	int lefthigh = maxDepth(root-&gt;_left);    //记录树的左子树高度
	int righthigh = maxDepth(root-&gt;_right); //记录树的右子树高度

    //左子树高则返回左子树的高度    右子树高则返回右子树高度
	return lefthigh &gt; righthigh ? lefthigh + 1 : righthigh + 1; 

}

// 二叉树叶子节点个数
int BinaryTreeLeafSize(BTNode* root) {

	if (root == NULL)  //如果为空树则返回 0 
		return 0;

	if (root-&gt;_left == NULL &amp;&amp; root-&gt;_right == NULL)  //如果是叶子节点就返回 1 
		return 1;

    //返回左子树 与 右子树总共的叶子节点
	return BinaryTreeLeafSize(root-&gt;_left) + BinaryTreeLeafSize(root-&gt;_right);
}

// 二叉树第k层节点个数
int BinaryTreeLevelKSize(BTNode* root, int k) {

    //将找第k层问题转化成：层序遍历按照树的层次进行遍历，每次遍历一层，直到遍历到第k层或者遍历完整个树。   

	if (root == NULL)    //如果为空树则返回 0 
		return 0;

	if (root != NULL &amp;&amp; k == 1) //当不为空且k为1时，到达所找层，返回1
		return 1;
	
    //一层一层的往下找
	if (root != NULL &amp;&amp; k &gt; 1)
		return BinaryTreeLevelKSize(root-&gt;_left,k - 1) 
        + BinaryTreeLevelKSize(root-&gt;_right,k - 1);
}

// 二叉树查找值为x的节点
//向这种找值的，一定要记录，把记录的递归返回
BTNode* BinaryTreeFind(BTNode* root, BTDataType x) {

	if (root == NULL)
		return NULL;

	if (root-&gt;_data == x)
		return root;

	BTNode* find1 = NULL;
	BTNode* find2 = NULL;

	
	find1 = BinaryTreeFind(root-&gt;_left, x);  //记录所找的节点

	if (find1)//如果左边找到了就不用去右边找了
		return find1;

	find2 = BinaryTreeFind(root-&gt;_right, x);
		return find2;
}

// 二叉树销毁
void BinaryTreeDestory(BTNode** root) {

	if (*root == NULL)
		return;
	BinaryTreeDestory(&amp;((*root)-&gt;_left));//先销毁左子树
	BinaryTreeDestory(&amp;((*root)-&gt;_right));//在销毁右子树
	free(*root);
	*root = NULL;
}

// 二叉树节点个数
int BinaryTreeSize(BTNode* root) {
	if (root == NULL)
		return 0;

	return BinaryTreeSize(root-&gt;_left)+ BinaryTreeSize(root-&gt;_right) + 1;
}

// 层序遍历
void BinaryTreeLevelOrder(BTNode* root) {
	//创建队列
	Queue qu;
	QueueInit(&amp;qu);
	QueuePush(&amp;qu, root);

	//开始拖家带口，当队列为NULL时，说明已经遍历完成,循环结束
	while (!QueueEmpty(&amp;qu))
	{
		//先访问队头的元素
		BTNode* bt = QueueFront(&amp;qu);//获取队头元素

		printf("%d ", bt-&gt;_data);

		//将树的左右孩子都带入队列中
		if (bt-&gt;_left)
			QueuePush(&amp;qu, bt-&gt;_left);
		if (bt-&gt;_right)
			QueuePush(&amp;qu, bt-&gt;_right);

		QueuePop(&amp;qu);
	}

	QueueDestroy(&amp;qu);


}

// 判断二叉树是否是完全二叉树
int BinaryTreeComplete(BTNode* root) {

	//创建队列
	Queue qu;
	QueueInit(&amp;qu);
	QueuePush(&amp;qu, root);

	//开始拖家带口，当队列为NULL时，说明已经遍历完成,循环结束
	while (!QueueEmpty(&amp;qu))
	{
		//队列中存的数据是，树节点的指针，我们先访问队头的元素
		BTNode* bt = QueueFront(&amp;qu);//获取队头元素

		if (bt == NULL)
		{
			break;
		}


		//将树的左右孩子都带入队列中,NULL也不例外
		QueuePush(&amp;qu, bt-&gt;_left);
		QueuePush(&amp;qu, bt-&gt;_right);

		QueuePop(&amp;qu);
	}

	while (!QueueEmpty(&amp;qu))
	{
		BTNode* bt = QueueFront(&amp;qu);//获取队头元素

		//如果在遇到非空的节点，说明它不是一个完全二叉树返回false
		if (bt)
		{
			return false;
		}

		QueuePop(&amp;qu);
	}

	QueueDestroy(&amp;qu);

	return true;
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3b1c67c389920f37d8e4583dff67820/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">5款提高工作效率的免费工具推荐</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fb97b9e2f449a6a91ea329526eb6cfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java的NIO体系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>