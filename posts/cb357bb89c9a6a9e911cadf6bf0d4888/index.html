<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【机器人学】2-1.六自由度机器人运动学逆解【附MATLAB机器人逆解代码】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cb357bb89c9a6a9e911cadf6bf0d4888/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【机器人学】2-1.六自由度机器人运动学逆解【附MATLAB机器人逆解代码】">
  <meta property="og:description" content="通过上一篇文章​​​​​​六自由度机器人正解已经获得了机器人各连杆间的转换关系。当知道各个连杆的转角1、2、3、4、5、6时可以求出末端执行器的位姿，这个过程称为正向运动学。这篇文章将讨论逆向运动学，即，给定末端执行器的位姿，求解各连杆的转角。在实际生活中逆向运动学更为实用。
现已知末端姿态矩阵和机器人的运动学模型，求解1、2、3、4、5、6。
已知六轴机器人的D-H参数如下所示：
如果不清楚何为改进的DH参数，可以看我的上一篇博客。【机器人学】1-1.六自由度机器人运动学正解 【附MATLAB代码】
关节1关节2关节3关节4关节5关节609000-9090a0042539300d160.700113.39993.60900-9000000000 选用改进型的D-H参数，各矩阵分别如下所示：
设
其中
如果你的机械臂D-H参数结构和我的一致，以上解析解你可以直接使用，如果参数相差不大，可以跟着我的计算思路推导一下你自己的逆解方程，相信你也可以得到正确的结果。
MATLAB仿真验证
function R=AxisAngle_RotMat(Rxyz) theta=(Rxyz(1)^2&#43;Rxyz(2)^2&#43;Rxyz(3)^2)^0.5; if(abs(theta)&lt;1e-8) R=eye(3); return; end r=Rxyz/theta; R=[r(1)^2*(1-cos(theta))&#43;cos(theta) r(1)*r(2)*(1-cos(theta))-r(3)*sin(theta) r(1)*r(3)*(1-cos(theta))&#43;r(2)*sin(theta) r(1)*r(2)*(1-cos(theta))&#43;r(3)*sin(theta) r(2)^2*(1-cos(theta))&#43;cos(theta) r(2)*r(3)*(1-cos(theta))-r(1)*sin(theta) r(1)*r(3)*(1-cos(theta))-r(2)*sin(theta) r(2)*r(3)*(1-cos(theta))&#43;r(1)*sin(theta) r(3)^2*(1-cos(theta))&#43;cos(theta)]; end clc;clear; %带入机器人初始值 d1 = 0.1607; d2 = 0; d3 = 0; d4 = 0.1133; d5 = 0.099; d6 = 0.0936; a1 = 0; a2 = 0; a3 = 0.425; a4 = 0.393; a5 = 0; a6 = 0; %testData1 测试数据 px = 0.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T15:45:33+08:00">
    <meta property="article:modified_time" content="2024-07-15T15:45:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【机器人学】2-1.六自由度机器人运动学逆解【附MATLAB机器人逆解代码】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>        通过上一篇文章<a class="link-info" href="https://blog.csdn.net/y12345655/article/details/139620689?spm=1001.2014.3001.5501" title="​​​​​​六自由度机器人正解">​​​​​​六自由度机器人正解</a>已经获得了机器人各连杆间的转换关系。当知道各个连杆的转角<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/f4/b0/bx0egIvv_o.png">1、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/94/82/GpjPIu6G_o.png">2、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/32/a3/qogScqcc_o.png">3、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/eb/15/XraYW0AD_o.png">4、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/6a/f9/Fw0jNOnJ_o.png">5、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/ad/87/AsfsI3rw_o.png">6时可以求出末端执行器的位姿，这个过程称为正向运动学。这篇文章将讨论逆向运动学，即，给定末端执行器的位姿，求解各连杆的转角。在实际生活中逆向运动学更为实用。</p> 
<p style="margin-left:.0001pt;text-align:justify;">现已知末端姿态矩阵和机器人的运动学模型，求解<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/44/3c/rYHt1b8R_o.png">1、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/fd/ed/06nVycw9_o.png">2、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/de/fc/0WtoTpDd_o.png">3、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/f0/12/KsmBItK2_o.png">4、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/8c/15/ZSeWDQ6m_o.png">5、<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/82/ea/lP0aw1vv_o.png">6。</p> 
<p style="margin-left:.0001pt;text-align:justify;">已知六轴机器人的D-H参数如下所示：</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果不清楚何为改进的DH参数，可以看我的上一篇博客。<a class="link-info" href="https://blog.csdn.net/y12345655/article/details/139620689?spm=1001.2014.3001.5502" title="【机器人学】1-1.六自由度机器人运动学正解 【附MATLAB代码】">【机器人学】1-1.六自由度机器人运动学正解 【附MATLAB代码】</a></p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td></td><td>关节1</td><td>关节2</td><td>关节3</td><td>关节4</td><td>关节5</td><td>关节6</td></tr><tr><td><img alt="\alpha" src="https://images2.imgbox.com/b9/c9/BxM4SkH9_o.png"></td><td>0</td><td>90</td><td>0</td><td>0</td><td>-90</td><td>90</td></tr><tr><td>a</td><td>0</td><td>0</td><td>425</td><td>393</td><td>0</td><td>0</td></tr><tr><td>d</td><td>160.7</td><td>0</td><td>0</td><td>113.3</td><td>99</td><td>93.6</td></tr><tr><td><img alt="\theta" src="https://images2.imgbox.com/89/14/YIw6fR8x_o.png"></td><td>0</td><td>90</td><td>0</td><td>-90</td><td>0</td><td>0</td></tr><tr><td><img alt="\beta" src="https://images2.imgbox.com/26/1f/MRjJjAsZ_o.png"></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:left;">选用改进型的D-H参数，各矩阵分别如下所示：</p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="727" src="https://images2.imgbox.com/89/8b/XlsTbyd8_o.png" width="826"></p> 
<p style="margin-left:.0001pt;text-align:left;">设</p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="180" src="https://images2.imgbox.com/25/af/cbu1LNkf_o.png" width="670"></p> 
<p style="margin-left:.0001pt;text-align:left;">        其中</p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="848" src="https://images2.imgbox.com/6f/7d/FfGFV7lT_o.png" width="760"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="555" src="https://images2.imgbox.com/ab/16/cwxZmrqv_o.png" width="937"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="783" src="https://images2.imgbox.com/0a/11/fVfCNUBV_o.png" width="822"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="571" src="https://images2.imgbox.com/06/cb/ODX5iZRP_o.png" width="885"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="720" src="https://images2.imgbox.com/bf/7d/JEqK4D1C_o.png" width="902"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="723" src="https://images2.imgbox.com/af/ba/eFQDJtsF_o.png" width="918"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="412" src="https://images2.imgbox.com/81/3f/y7JLLokO_o.png" width="904"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="580" src="https://images2.imgbox.com/43/a6/GIVyVLZB_o.png" width="1029"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="111" src="https://images2.imgbox.com/35/e0/SsQwdAl4_o.png" width="869"></p> 
<p style="margin-left:.0001pt;text-align:left;"> <span style="color:#ff9900;">    <strong>   如果你的机械臂D-H参数结构和我的一致，以上解析解你可以直接使用，如果参数相差不大，可以跟着我的计算思路推导一下你自己的逆解方程，相信你也可以得到正确的结果。</strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><strong>        MATLAB仿真验证</strong></strong></p> 
<pre><code class="language-Matlab">function R=AxisAngle_RotMat(Rxyz)
    theta=(Rxyz(1)^2+Rxyz(2)^2+Rxyz(3)^2)^0.5;
    if(abs(theta)&lt;1e-8)
        R=eye(3);
        return;
    end
    r=Rxyz/theta;

    R=[r(1)^2*(1-cos(theta))+cos(theta) r(1)*r(2)*(1-cos(theta))-r(3)*sin(theta) r(1)*r(3)*(1-cos(theta))+r(2)*sin(theta)
       r(1)*r(2)*(1-cos(theta))+r(3)*sin(theta) r(2)^2*(1-cos(theta))+cos(theta) r(2)*r(3)*(1-cos(theta))-r(1)*sin(theta)
       r(1)*r(3)*(1-cos(theta))-r(2)*sin(theta) r(2)*r(3)*(1-cos(theta))+r(1)*sin(theta) r(3)^2*(1-cos(theta))+cos(theta)];
end</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<pre><code class="language-Matlab">clc;clear;
%带入机器人初始值
d1 = 0.1607;
d2 = 0;
d3 = 0;
d4 = 0.1133;
d5 = 0.099;
d6 = 0.0936;

a1 = 0;
a2 = 0;
a3 = 0.425;
a4 = 0.393;
a5 = 0;
a6 = 0;

%testData1  测试数据 
px = 0.129;
py = 0.157;
pz = 0.858;
rx = 38.05;
ry = 42.96;
rz = -179.77;

posture = [rx/180*pi,ry/180*pi,rz/180*pi];
%轴线表示转换为姿态矩阵转
a = AxisAngle_RotMat(posture);
%目标位置姿态矩阵
nx=a(1,1);ox=a(1,2);ax=a(1,3);
ny=a(2,1);oy=a(2,2);ay=a(2,3);
nz=a(3,1);oz=a(3,2);az=a(3,3);

% 求解关节角1
    t1 = (d6*a(1,3)-px);
    t2 = (d6*a(2,3)-py);
    theta1_1 = atan2(t2,t1) - atan2(d4, sqrt(t1^2+t2^2-d4^2)) ;
    theta1_2 = atan2(t2,t1) - atan2(d4, -sqrt(t1^2+t2^2-d4^2)) ;   
    disp([theta1_1 theta1_2]*180/pi);
% 求解关节角5
    theta5_1 = atan2(sqrt((ny*cos(theta1_1)-nx*sin(theta1_1))^2+(oy*cos(theta1_1)-ox*sin(theta1_1))^2), ax*sin(theta1_1)-ay*cos(theta1_1));
    theta5_2 = atan2(-sqrt((ny*cos(theta1_1)-nx*sin(theta1_1))^2+(oy*cos(theta1_1)-ox*sin(theta1_1))^2), ax*sin(theta1_1)-ay*cos(theta1_1));
    theta5_3 = atan2(sqrt((ny*cos(theta1_2)-nx*sin(theta1_2))^2+(oy*cos(theta1_2)-ox*sin(theta1_2))^2), ax*sin(theta1_2)-ay*cos(theta1_2));
    theta5_4 = atan2(-sqrt((ny*cos(theta1_2)-nx*sin(theta1_2))^2+(oy*cos(theta1_2)-ox*sin(theta1_2))^2), ax*sin(theta1_2)-ay*cos(theta1_2));

    disp([theta5_1 theta5_2 theta5_3 theta5_4]*180/pi);

% 求解关节角6
    theta6_1 = atan2((ox*sin(theta1_1)-oy*cos(theta1_1))/sin(theta5_1), -(nx*sin(theta1_1)-ny*cos(theta1_1))/sin(theta5_1));
    theta6_2 = atan2((ox*sin(theta1_1)-oy*cos(theta1_1))/sin(theta5_2), -(nx*sin(theta1_1)-ny*cos(theta1_1))/sin(theta5_2));
    theta6_3 = atan2((ox*sin(theta1_2)-oy*cos(theta1_2))/sin(theta5_3), -(nx*sin(theta1_2)-ny*cos(theta1_2))/sin(theta5_3));
    theta6_4 = atan2((ox*sin(theta1_2)-oy*cos(theta1_2))/sin(theta5_4), -(nx*sin(theta1_2)-ny*cos(theta1_2))/sin(theta5_4));
    disp([theta6_1 theta6_2 theta6_3 theta6_4]*180/pi);
 
% 求解关节角2，3，4
    q234_1 = atan2(az/sin(theta5_1), (ax*cos(theta1_1)+ay*sin(theta1_1))/sin(theta5_1));
    q234_2 = atan2(az/sin(theta5_2), (ax*cos(theta1_1)+ay*sin(theta1_1))/sin(theta5_2));
    q234_3 = atan2(az/sin(theta5_3), (ax*cos(theta1_2)+ay*sin(theta1_2))/sin(theta5_3));
    q234_4 = atan2(az/sin(theta5_4), (ax*cos(theta1_2)+ay*sin(theta1_2))/sin(theta5_4));
    disp([q234_1 q234_2 q234_3 q234_4]*180/pi);
   
    A_1 = d6*sin(theta5_1)*cos(q234_1)-d5*sin(q234_1)-px*cos(theta1_1)-py*sin(theta1_1);
    B_1 = pz-d1-d5*cos(q234_1)-d6*sin(theta5_1)*sin(q234_1);
    A_2 = -px*cos(theta1_1)-py*sin(theta1_1)-d5*sin(q234_2)+d6*sin(theta5_2)*cos(q234_2);
    B_2 = pz-d1-d5*cos(q234_2)-d6*sin(theta5_2)*sin(q234_2);
    A_3 = -px*cos(theta1_2)-py*sin(theta1_2)-d5*sin(q234_3)+d6*sin(theta5_3)*cos(q234_3);
    B_3 = pz-d1-d5*cos(q234_3)-d6*sin(theta5_3)*sin(q234_3);
    A_4 = -px*cos(theta1_2)-py*sin(theta1_2)-d5*sin(q234_4)+d6*sin(theta5_4)*cos(q234_4);
    B_4 = pz-d1-d5*cos(q234_4)-d6*sin(theta5_4)*sin(q234_4);
%     关节2
    theta2_1 = atan2(A_1^2+B_1^2+a3^2-a4^2, sqrt(abs(4*a3^2*(A_1^2+B_1^2)-(A_1^2+B_1^2+a3^2-a4^2)^2)))-atan2(B_1, A_1);
    theta2_2 = atan2(A_1^2+B_1^2+a3^2-a4^2, -sqrt(abs(4*a3^2*(A_1^2+B_1^2)-(A_1^2+B_1^2+a3^2-a4^2)^2)))-atan2(B_1, A_1);
    theta2_3 = atan2(A_2^2+B_2^2+a3^2-a4^2, sqrt(abs(4*a3^2*(A_2^2+B_2^2)-(A_2^2+B_2^2+a3^2-a4^2)^2)))-atan2(B_2, A_2);
    theta2_4 = atan2(A_2^2+B_2^2+a3^2-a4^2, -sqrt(abs(4*a3^2*(A_2^2+B_2^2)-(A_2^2+B_2^2+a3^2-a4^2)^2)))-atan2(B_2, A_2);
    theta2_5 = atan2(A_3^2+B_3^2+a3^2-a4^2, sqrt(abs(4*a3^2*(A_3^2+B_3^2)-(A_3^2+B_3^2+a3^2-a4^2)^2)))-atan2(B_3, A_3);
    theta2_6 = atan2(A_3^2+B_3^2+a3^2-a4^2, -sqrt(abs(4*a3^2*(A_3^2+B_3^2)-(A_3^2+B_3^2+a3^2-a4^2)^2)))-atan2(B_3, A_3);
    theta2_7 = atan2(A_4^2+B_4^2+a3^2-a4^2, sqrt(abs(4*a3^2*(A_4^2+B_4^2)-(A_4^2+B_4^2+a3^2-a4^2)^2)))-atan2(B_4, A_4);
    theta2_8 = atan2(A_4^2+B_4^2+a3^2-a4^2, -sqrt(abs(4*a3^2*(A_4^2+B_4^2)-(A_4^2+B_4^2+a3^2-a4^2)^2)))-atan2(B_4, A_4);
    disp([theta2_1 theta2_2 theta2_3 theta2_4 theta2_5 theta2_6 theta2_7 theta2_8]*180/pi);

    q23_1 = atan2(-px*cos(theta1_1)-py*sin(theta1_1)-d5*sin(q234_1)+d6*sin(theta5_1)*cos(q234_1)-a3*sin(theta2_1),pz-d1-d5*cos(q234_1)-d6*sin(theta5_1)*sin(q234_1)-a3*cos(theta2_1));
    q23_2 = atan2(-px*cos(theta1_1)-py*sin(theta1_1)-d5*sin(q234_1)+d6*sin(theta5_1)*cos(q234_1)-a3*sin(theta2_2),pz-d1-d5*cos(q234_1)-d6*sin(theta5_1)*sin(q234_1)-a3*cos(theta2_2));
    q23_3 = atan2(-px*cos(theta1_1)-py*sin(theta1_1)-d5*sin(q234_2)+d6*sin(theta5_2)*cos(q234_2)-a3*sin(theta2_3),pz-d1-d5*cos(q234_2)-d6*sin(theta5_2)*sin(q234_2)-a3*cos(theta2_3));
    q23_4 = atan2(-px*cos(theta1_1)-py*sin(theta1_1)-d5*sin(q234_2)+d6*sin(theta5_2)*cos(q234_2)-a3*sin(theta2_4),pz-d1-d5*cos(q234_2)-d6*sin(theta5_2)*sin(q234_2)-a3*cos(theta2_4));
    q23_5 = atan2(-px*cos(theta1_2)-py*sin(theta1_2)-d5*sin(q234_3)+d6*sin(theta5_3)*cos(q234_3)-a3*sin(theta2_5),pz-d1-d5*cos(q234_3)-d6*sin(theta5_3)*sin(q234_3)-a3*cos(theta2_5));
    q23_6 = atan2(-px*cos(theta1_2)-py*sin(theta1_2)-d5*sin(q234_3)+d6*sin(theta5_3)*cos(q234_3)-a3*sin(theta2_6),pz-d1-d5*cos(q234_3)-d6*sin(theta5_3)*sin(q234_3)-a3*cos(theta2_6));
    q23_7 = atan2(-px*cos(theta1_2)-py*sin(theta1_2)-d5*sin(q234_4)+d6*sin(theta5_4)*cos(q234_4)-a3*sin(theta2_7),pz-d1-d5*cos(q234_4)-d6*sin(theta5_4)*sin(q234_4)-a3*cos(theta2_7));
    q23_8 = atan2(-px*cos(theta1_2)-py*sin(theta1_2)-d5*sin(q234_4)+d6*sin(theta5_4)*cos(q234_4)-a3*sin(theta2_8),pz-d1-d5*cos(q234_4)-d6*sin(theta5_4)*sin(q234_4)-a3*cos(theta2_8));
 %    关节3
    theta3_1 = q23_1 - theta2_1;
    theta3_2 = q23_2 - theta2_2;
    theta3_3 = q23_3 - theta2_3;
    theta3_4 = q23_4 - theta2_4;
    theta3_5 = q23_5 - theta2_5;
    theta3_6 = q23_6 - theta2_6;
    theta3_7 = q23_7 - theta2_7;
    theta3_8 = q23_8 - theta2_8;
 %    关节4
    theta4_1 = q234_1 - q23_1;
    theta4_2 = q234_1 - q23_2;
    theta4_3 = q234_2 - q23_3;
    theta4_4 = q234_2 - q23_4;
    theta4_5 = q234_3 - q23_5;
    theta4_6 = q234_3 - q23_6;
    theta4_7 = q234_4 - q23_7;
    theta4_8 = q234_4 - q23_8;

theta_STD = [ 
              theta1_1,theta2_1,theta3_1,theta4_1,theta5_1,theta6_1;
 			  theta1_1,theta2_2,theta3_2,theta4_2,theta5_1,theta6_1;
 			  theta1_1,theta2_3,theta3_3,theta4_3,theta5_2,theta6_2;
 			  theta1_1,theta2_4,theta3_4,theta4_4,theta5_2,theta6_2;
              theta1_2,theta2_5,theta3_5,theta4_5,theta5_3,theta6_3;
 			  theta1_2,theta2_6,theta3_6,theta4_6,theta5_3,theta6_3;
 			  theta1_2,theta2_7,theta3_7,theta4_7,theta5_4,theta6_4;
 			  theta1_2,theta2_8,theta3_8,theta4_8,theta5_4,theta6_4;
             ]*180/pi



</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffd900;">由于MATLAB中机器人工具箱对运动学逆解仿真度不够，为此用我自己的模拟机器人测试。没有仿真平台的同学，可以用其他机器人工具箱代替。或其它测试方法。</span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">测试数据1：</p> 
<p style="margin-left:.0001pt;text-align:justify;">图中左边6个参数代表机器人的末端姿态（输入参数），右边6个参数代表6个关节角度（结果）。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="118" src="https://images2.imgbox.com/db/b6/O7z9YzVL_o.png" width="646"></p> 
<p style="margin-left:.0001pt;text-align:justify;">MATLAB计算结果1：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="306" src="https://images2.imgbox.com/39/dd/OoMI5Wtf_o.png" width="640"></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 测试数据2：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="114" src="https://images2.imgbox.com/e5/0d/nD7cXU3Q_o.png" width="652"></p> 
<p style="margin-left:.0001pt;text-align:justify;">MATLAB计算结果2：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="300" src="https://images2.imgbox.com/26/e3/V0ENOP03_o.png" width="649"></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 测试数据3：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="115" src="https://images2.imgbox.com/b3/cb/3y4JjJNC_o.png" width="649"></p> 
<p style="margin-left:.0001pt;text-align:justify;">MATLAB计算结果3：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="307" src="https://images2.imgbox.com/08/75/99DGmR4y_o.png" width="650"></p> 
<p style="margin-left:.0001pt;text-align:justify;">下一章：<a class="link-info" href="https://blog.csdn.net/y12345655/article/details/139699144?spm=1001.2014.3001.5501" title="六自由度机器人的雅克比矩阵">六自由度机器人的雅克比矩阵</a></p> 
<p>        2024-07-15 更新：将求解q2的过程详细化</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/767f936ce25dcbe428502159263270cf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">XML 解析异常问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e80999cef80de29592bc90fb8c1894d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VGMShield：揭秘视频生成模型滥用的检测与追踪技术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>