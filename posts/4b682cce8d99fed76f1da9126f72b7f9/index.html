<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单片机学习笔记——入门51单片机 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4b682cce8d99fed76f1da9126f72b7f9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="单片机学习笔记——入门51单片机">
  <meta property="og:description" content="一、单片机基础介绍 1.何为单片机 单片机，英文Micro Controller Unit，简称MCU 。内部集成了中央处理器CPU、随机存储器ROM、只读存储器RAM、定时器/计算器、中断系统和IO口等一系列电脑的常用硬件功能 单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机，LED等）的控制 。单片机跟计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用。 同时，学习使用单片机是了解计算机原理与结构的最佳选择。
单片机工作的基本时序
我们都知道在学校是通过铃声来控制所有班级的上下课时间，我们都知道单片机执行指令的过程就是从ROM取出一条指令执行来完成它在各个地方的作用，那它什么时候取指令这个是顺序呢？这里引入一个时序的周期，每访问一次ROM的时间，就是一个机器周期的时间。
1个机器周期 = 6个状态周期 = 12个时钟（振荡）周期 时钟周期：即单片机的基本时间单位，若晶体的频率=12MHZ，那时钟周期 = 1/12MHZ，一个时钟周期 = 1/12MHZ = 1/12000 000每秒
机器周期：即12x1/12 000 000 =0.000001s = 1us,访问一次ROM取指令的时间就是1us
2.单片机命名规则 3.单片机内部结构 重点需记：单片机管脚
1.电源：Vcc：正极 Gnd：负极 2.XTAL：单片机时钟引脚，外接晶振
3.RST：复位
4.开发板介绍 开发板原理图 二、单片机的一些基础项目 2-1、点亮一个led灯 #include &lt;REGX52.H&gt; void main() { P2=0x7f;//1111 1110 d1 16 15 //0111 1111 d8 7 16 //1011 1111 d7 11 16 } 通过高低电平控制led亮否
2-2、led闪烁 #include &lt;REGX52.H&gt; #include &lt;INTRINS.H&gt; //延时函数 void Delay500ms()	//@11.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T17:18:27+08:00">
    <meta property="article:modified_time" content="2024-07-25T17:18:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单片机学习笔记——入门51单片机</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、单片机基础介绍</h3> 
<h4><strong>1.何为单片机</strong></h4> 
<p>单片机，英文Micro Controller Unit，简称MCU 。内部集成了<strong>中央处理器CPU、随机存储器ROM、只读存储器RAM、定时器/计算器、中断系统和IO口</strong>等一系列电脑的常用硬件功能 单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机，LED等）的控制 。单片机跟计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用。 同时，学习使用单片机是了解计算机原理与结构的最佳选择。</p> 
<p><strong>单片机工作的基本时序</strong></p> 
<p>我们都知道在学校是通过铃声来控制所有班级的上下课时间，我们都知道单片机执行指令的过程就<strong>是从ROM取出一条指令执行来完成它在各个地方的作用，那它什么时候取指令这个是顺序呢</strong>？这里引入一个时序的周期，<strong>每访问一次ROM的时间，就是一个机器周期的时间</strong>。</p> 
<p><strong>1个机器周期 = 6个状态周期 = 12个时钟（振荡）周期  </strong></p> 
<p>时钟周期：即单片机的基本时间单位，若晶体的频率=12MHZ，那时钟周期 = 1/12MHZ<strong>，一个时钟周期 = 1/12MHZ = 1/12000 000每秒</strong></p> 
<p>机器周期<strong>：即12x1/12 000 000 =0.000001s = 1us,访问一次ROM取指令的时间就是1us</strong></p> 
<h4><strong>2.单片机命名规则</strong></h4> 
<p><img alt="" height="1148" src="https://images2.imgbox.com/b1/ad/xzsAfLRO_o.png" width="1200"></p> 
<h4><strong>3.单片机内部结构</strong></h4> 
<p><img alt="" height="1148" src="https://images2.imgbox.com/56/9f/kKTA2i7U_o.png" width="1200"></p> 
<p><strong>重点需记：单片机管脚</strong></p> 
<p><strong>1.电源：Vcc：正极     Gnd：负极             2.XTAL：单片机时钟引脚，外接晶振</strong></p> 
<p><strong>3.RST：复位</strong></p> 
<p><img alt="" height="1146" src="https://images2.imgbox.com/03/a0/dq2qqKbO_o.png" width="1200"></p> 
<p><img alt="" height="1146" src="https://images2.imgbox.com/ea/df/Tu99CcUT_o.png" width="1200"></p> 
<h4><strong>4.开发板介绍</strong></h4> 
<p><img alt="" height="1183" src="https://images2.imgbox.com/f2/15/1fLHT8wE_o.png" width="1200"></p> 
<h5><strong>开发板原理图</strong></h5> 
<p><img alt="" height="1018" src="https://images2.imgbox.com/73/47/eMsTj0vh_o.png" width="1200"></p> 
<h2>二、单片机的一些基础项目</h2> 
<h3>2-1、点亮一个led灯</h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
void main()
{
	P2=0x7f;//1111 1110  d1   16 15
	        //0111 1111  d8    7 16
	        //1011 1111  d7   11 16
	
	
}</code></pre> 
<p>通过高低电平控制led亮否</p> 
<h3>2-2、led闪烁</h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

//延时函数
void Delay500ms()		//@11.0592MHz
{
	unsigned char i, j, k;

	_nop_();
	i = 4;
	j = 129;
	k = 119;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}

void main()
{
	while(1){
	P2=0xfe;//亮
 Delay500ms();//延时500ms
	P2=0xff;//灭
 Delay500ms();//延时500ms
	}
}</code></pre> 
<p>通过延时函数使led闪烁</p> 
<h3>2-3、流水灯</h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

void Delay500ms()		//@11.0592MHz
{
	unsigned char i, j, k;

	_nop_();
	i = 4;
	j = 129;
	k = 119;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}

void main()
{
	while(1){
	P2=0xfe;//1111 1110
 Delay500ms();
	P2=0xfd;//1111 1101
 Delay500ms();
		P2=0xfb;//1111 1011
 Delay500ms();
		P2=0xf7;//1111 0111
 Delay500ms();
		P2=0xef;//1110 1111
 Delay500ms();
		P2=0xdf;//1101 1111
 Delay500ms();
		P2=0xbf;//1011 1111
 Delay500ms();
		P2=0x7f;//0111 1111
 Delay500ms();
	}
}</code></pre> 
<p>位运算做法：</p> 
<h3>2-4、流水灯plus</h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

//任意延时函数——1ms的延时函数执行x次循环
void Delay1ms(unsigned int xms)		//@11.0592MHz
{
	unsigned char i, j;
  while(xms)
	{
	_nop_();
	i = 2;
	j = 199;
	do
	{
		while (--j);
	} while (--i);

	xms--;}
}

void main()
{
	while(1){
	P2=0xfe;//1111 1110
 Delay1ms(100);
	P2=0xfd;//1111 1101
 Delay1ms(100);
		P2=0xfb;//1111 1011
 Delay1ms(100);
		P2=0xf7;//1111 0111
 Delay1ms(100);
		P2=0xef;//1110 1111
 Delay1ms(100);
		P2=0xdf;//1101 1111
 Delay1ms(100);
		P2=0xbf;//1011 1111
 Delay1ms(100);
		P2=0x7f;//0111 1111
 Delay1ms(100);
	}
}</code></pre> 
<p>通过任意延时函数去简化步骤</p> 
<h3>3-1、通过独立按键控制led闪烁</h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;

void main()
{
	while(1)
	{
		if(P3_1==0)//低电平 按下按键接地为0
		{
			P2_0=0;//d1亮
		}
		else {
			P2_0=1;
		}
	}
}</code></pre> 
<h3>3-2、通过独立按键控制led状态</h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;
void Delay(unsigned int xms)		//@11.0592MHz
{
	unsigned char i, j;
while(xms){
	_nop_();
	i = 2;
	j = 199;
	do
	{
		while (--j);
	} while (--i);
	xms--;
}
}

void main()
{
	while(1)
	{
		if(P3_1==0)
		{
		 Delay(20);//取消前摇
			while(P3_1==0);//判断何时松手
			Delay(20);//取消后摇
			
			P2_0=~P2_0;//按位取反
	}
}
}</code></pre> 
<p>取消按键时的抖动，使单片机稳定判断状态。按一次亮，按一次灭。</p> 
<h3>3-3、通过独立按键控制led完成二进制</h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

void Delay(unsigned int xms)		//@11.0592MHz
{
	unsigned char i, j;
while(xms){
	_nop_();
	i = 2;
	j = 199;
	do
	{
		while (--j);
	} while (--i);
	xms--;
}
}

void main()
{
	unsigned int lednum=0;
	while(1)
	{
		if(P3_1==0)
		{
			Delay(20);
			while(P3_1==0);
			Delay(20);
			
			lednum++;
			P2=~lednum;
	}
}
}</code></pre> 
<p>也可以直接用P2--；代替最后两句，完成二进制运算。</p> 
<h3>3-4、用独立按键控制led灯移位</h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

void Delay(unsigned int xms)		//@11.0592MHz
{
	unsigned char i, j;
while(xms){
	_nop_();
	i = 2;
	j = 199;
	do
	{
		while (--j);
	} while (--i);
	xms--;
}
}

void main()
{
	unsigned int lednum=0;
	P2=~0x01;
	while(1)
	{
		if(P3_1==0)//k1
		{
			Delay(20);
			while(P3_1==0);
			Delay(20);
			
			lednum++;
			if(lednum&gt;=8)
				lednum=0;
			P2=~(0x01&lt;&lt;lednum);
	}
		if(P3_0==0)//k2
		{
			Delay(20);
			while(P3_0==0);
			Delay(20);
			
			
			if(lednum==0)
				lednum=7;
			else lednum--;
			P2=~(0x01&lt;&lt;lednum);
}
}
	}</code></pre> 
<h3>4-1 静态数码管</h3> 
<h4>1.常见数码管</h4> 
<p><img alt="" height="343" src="https://images2.imgbox.com/6b/b5/rdSeE8tr_o.png" width="690"></p> 
<h4>2.控制数码管显示的原理图</h4> 
<p><img alt="" height="317" src="https://images2.imgbox.com/c9/e1/pFi4RDqd_o.png" width="226"><img alt="" height="293" src="https://images2.imgbox.com/bd/9d/FhiPAQhT_o.png" width="690"></p> 
<h4>3.管脚定义（对应字母控制对应位置亮）：上面的为共阴极、下面的为共阳极（可以理解为3,8管脚处为供电，三角形尖尖有一横的是负极，所有共阴极），两个图中的数字为引脚：</h4> 
<p><img alt="" height="447" src="https://images2.imgbox.com/fd/32/PYkyWwba_o.png" width="690"></p> 
<p></p> 
<h4>4.下面为多个数码管，PCB板的4个为一体，同样上面为共阴极、下面为共阳极的原理图：</h4> 
<p><img alt="" height="415" src="https://images2.imgbox.com/1e/71/NSnATjrP_o.png" width="690"></p> 
<h4>5.STC89C52实现数字显示</h4> 
<h5>①原理图是共阴极（上面给0、下给1亮）</h5> 
<p><img alt="" height="343" src="https://images2.imgbox.com/c6/e2/KlZPF7E8_o.png" width="690"></p> 
<h5>②138译码器：输入3（ABC,读的时候是从下读 C B A ）个口，控制输出8个口，输出口连接共阴极的，是0还是1，在这里控制：使能端连接（按下图给1和0就可以用了）</h5> 
<p class="img-center"><img alt="" height="408" src="https://images2.imgbox.com/b2/ed/OBA2Sm9b_o.png" width="381"></p> 
<p>通过CBA给数字0和1二进制转换10进制（得到数字几）就控制Y几，Y0头上“—”是表示低电平有效（即给0）：</p> 
<p class="img-center"><img alt="" height="469" src="https://images2.imgbox.com/42/bf/3Xa5bOE7_o.png" width="690"></p> 
<h5>③双向缓冲，高电平往低电平送数据</h5> 
<p></p> 
<p class="img-center"><img alt="" height="343" src="https://images2.imgbox.com/ed/74/GodXpimO_o.png" width="690"></p> 
<p>CC2电容作用：滤波电容，稳定电源，确定电路稳定性，提高电路工作性能可靠运行；</p> 
<p>RP4：排阻，限流，防止电流过大</p> 
<p></p> 
<h5>④这里的P01......P07,就是用P0口，后面代码就是通过P0口控制灯的</h5> 
<p></p> 
<p class="img-center"><img alt="" height="261" src="https://images2.imgbox.com/28/6c/5XTWU0tB_o.png" width="690"></p> 
<p></p> 
<p>只有Y5为0，其他Y0...Y7都为1；</p> 
<p></p> 
<p class="img-center"><img alt="" height="427" src="https://images2.imgbox.com/49/36/kUGE1NDq_o.png" width="433"></p> 
<p></p> 
<p></p> 
<p>读取顺序都是从下到上</p> 
<p></p> 
<p class="img-center"><img alt="" height="322" src="https://images2.imgbox.com/9d/9d/Bt8f258m_o.png" width="690"></p> 
<h5>⑤代码控制公共端，从下往上写：</h5> 
<p></p> 
<p class="img-center"><img alt="" height="376" src="https://images2.imgbox.com/3a/87/nLlTfEA3_o.png" width="328"></p> 
<p>二进制101转换为1十进制为5，控制Y5，即公共端的LED6；</p> 
<p></p> 
<p class="img-center"><img alt="" height="335" src="https://images2.imgbox.com/ba/22/k6lDz9P6_o.png" width="690"></p> 
<p>要显示下图的数字6</p> 
<p></p> 
<p class="img-center"><img alt="" height="319" src="https://images2.imgbox.com/74/6e/VmENnGFC_o.png" width="690"></p> 
<p>代码实现如下（P2控制共阴极，P0控制显示数字）及结果；</p> 
<p></p> 
<p class="img-center"><img alt="" height="279" src="https://images2.imgbox.com/ba/88/c87FlP4x_o.png" width="279"></p> 
<p></p> 
<p class="img-center"><img alt="" height="429" src="https://images2.imgbox.com/ec/b3/RoGEnrgA_o.png" width="594"></p> 
<h5> ⑥优化操作代码：通过数组，子函数来优化代码</h5> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

unsigned char NixieTable[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00};

void Nixie(unsigned char Location,Number)
{
	switch(Location)
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];
}

void main()
{
	Nixie(7,10);
	while(1);
	}</code></pre> 
<p>要显示的数字对应的值</p> 
<p></p> 
<p class="img-center"><img alt="" height="227" src="https://images2.imgbox.com/47/34/04D3XqrB_o.png" width="690"></p> 
<h3>4-2、动态数码管 </h3> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

unsigned char NixieTable[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00};

void Delay (unsigned int xms)		//@11.0592MHz
{
	unsigned char i, j;
while(xms--){
	_nop_();
	i = 2;
	j = 199;
	do
	{
		while (--j);
	} while (--i);
}
}

void Nixie(unsigned char Location,Number)
{
	switch(Location)
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];
	Delay(1);//保证亮度
  P0=0x00;//清零
}

void main()
{
	while(1){
	Nixie(2,1);
 // Delay(20);
	Nixie(3,2);
 // Delay(20);
	Nixie(4,3);
 //	Delay(20);
	}
}</code></pre> 
<p><img alt="" height="233" src="https://images2.imgbox.com/e7/31/WMcJw9ve_o.png" width="351"></p> 
<p>注释掉上面的延时调用，旁边的管会有些影响，需要<strong>消影，段选、位选影响造成串位，如下代码消除</strong>；</p> 
<p></p> 
<p class="img-center"><img alt="" height="83" src="https://images2.imgbox.com/f7/e0/MpN2qWSc_o.png" width="325"></p> 
<p>了解</p> 
<p></p> 
<p class="img-center"><img alt="" height="441" src="https://images2.imgbox.com/b3/71/VJ63k4bT_o.png" width="690"></p> 
<p></p> 
<h3>5-1、模块化编程 </h3> 
<p><img alt="" height="281" src="https://images2.imgbox.com/74/be/sAvi4GkF_o.png" width="690"></p> 
<h4>1）驱动，先会用，后续有详细内容：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="411" src="https://images2.imgbox.com/ea/21/k24NFPVz_o.png" width="690"></p> 
<h4><strong>2）</strong>模块化，功能函数用点C文件写，点H文件声明函数，在main函数文件引入头文件直接调用：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/06/a7/Dbq2uLqh_o.png" width="690"></p> 
<h4><strong>3）</strong>注意事项</h4> 
<p></p> 
<p class="img-center"><img alt="" height="258" src="https://images2.imgbox.com/f1/5f/K5ngOgm3_o.png" width="690"></p> 
<h4><strong>4）</strong>预编译</h4> 
<p></p> 
<p class="img-center"><img alt="" height="381" src="https://images2.imgbox.com/48/3d/8hu0AnO1_o.png" width="690"></p> 
<h4><strong>5）</strong>延时函数文件</h4> 
<p></p> 
<p class="img-center"><img alt="" height="285" src="https://images2.imgbox.com/0c/07/7DRi8CH4_o.png" width="376"></p> 
<h4><strong>6）</strong>头文件延迟</h4> 
<p></p> 
<p class="img-center"><img alt="" height="141" src="https://images2.imgbox.com/61/46/MwBSC5gH_o.png" width="433"></p> 
<h4><strong>7）</strong>主函数文件程序入口：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="216" src="https://images2.imgbox.com/ec/ee/tnzHgd25_o.png" width="294"></p> 
<h4><strong>8）</strong>数码管模块，用到的头文件要引用：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="409" src="https://images2.imgbox.com/8c/a8/bE2LlesV_o.png" width="493"></p> 
<h4>9）数码管模块头文件</h4> 
<p></p> 
<p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/6a/67/6tKXtID2_o.png" width="514"></p> 
<h4><strong>10）</strong>函数调用</h4> 
<p></p> 
<p class="img-center"><img alt="" height="268" src="https://images2.imgbox.com/ed/bb/KxMIFQLe_o.png" width="305"></p> 
<h4><strong>11）</strong>显示</h4> 
<p></p> 
<p class="img-center"><img alt="" height="401" src="https://images2.imgbox.com/8d/34/JUVMGVUS_o.png" width="589"></p> 
<p></p> 
<h3>5-2 、<strong>LCD1602调试工具-------</strong></h3> 
<p></p> 
<p class="img-center"><img alt="" height="416" src="https://images2.imgbox.com/3a/41/TWWLMMSD_o.png" width="690"></p> 
<h4><strong>1）</strong>调试工具原理图</h4> 
<p></p> 
<p class="img-center"><img alt="" height="282" src="https://images2.imgbox.com/fc/ea/R4VCvEwe_o.png" width="465"></p> 
<h4><strong>2）</strong>模块化代码，下完放到自己工程目录下：</h4> 
<p><img alt="" height="161" src="https://images2.imgbox.com/31/51/aixusYmp_o.png" width="509"></p> 
<p>﻿</p> 
<p></p> 
<h4><strong>3）</strong>将下好的两个文件添加到工程：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/57/27/2voJQ1Hh_o.png" width="389"></p> 
<p></p> 
<p></p> 
<h4>4）文件主要内容如下：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/eb/92/0JhT33Kg_o.png" width="620"></p> 
<h4><strong>5）</strong>main函数调用：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/a6/44/4nNnBDQs_o.png" width="432"></p> 
<h4><strong>6）</strong>显示其他管脚冲突，所有会一起显示：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="439" src="https://images2.imgbox.com/64/56/89n1afdu_o.png" width="672"></p> 
<h4><strong>7）</strong>其他函数的调用及功能，可以设置显示位置和范围：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="313" src="https://images2.imgbox.com/58/d5/6Mnbr9jB_o.png" width="379"></p> 
<h4><strong>8）</strong>需要用到延迟函数：可以直接将前面模块化文件复制到工程目录下，添加进来引用即可；</h4> 
<h4>9）娱乐：小计时器</h4> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "LCD1602.h"
#include "Delay.h"

int Result=0;

void main()
{
	LCD_Init();//初始化
	
	while(1)
		{
		Result++;
			Delay(1000);
			LCD_ShowNum(1,1,Result,3);
		}//计时器
</code></pre> 
<p>﻿</p> 
<h3>6-1.矩阵键盘</h3> 
<h4>1）基础介绍：</h4> 
<p><img alt="" height="401" src="https://images2.imgbox.com/89/89/vQ1wMMlU_o.png" width="690"></p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/93/00/j9BoVYiN_o.png" width="690"></p> 
<p>P14-P17给0就代表扫描，其他给1（没选中），一次只能扫描一行；P10-P13给0表示按下，给1表示没按下；（逐列扫描）</p> 
<p></p> 
<p class="img-center"><img alt="" height="316" src="https://images2.imgbox.com/c1/f9/COcOYX65_o.png" width="690"></p> 
<h4>2.代码实现：</h4> 
<h5>①：创建工程并把“Delay”与“LCD1602”的模块加入此工程中。</h5> 
<h5>②：编写MatrixKey(矩阵）代码</h5> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "Delay.h"

unsigned char MatrixKey()
{
	unsigned char KeyNumber=0;
	
	P1=0xff;      //按列扫描
	P1_3=0;       //控制扫描的列
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=1;}    //while判断何时松手
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=5;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=9;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=13;}
	
	P1=0xff;
	P1_2=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=2;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=6;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=10;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=14;}
	
	P1=0xff;
	P1_1=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=3;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=7;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=11;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=15;}
	
	P1=0xff;
	P1_0=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=4;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=8;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=12;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=16;}
	
	
	return KeyNumber;
}
	</code></pre> 
<h5>③.编写主函数</h5> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "LCD1602.h"
#include "matrixKey.h"

unsigned char KeyNum;

void main()
{
	LCD_Init();   //LCD上电初始化
	LCD_ShowString(1,1,"Helloworld");
	while(1)
	{
		KeyNum=MatrixKey();
		if(KeyNum){
			LCD_ShowNum(2,1,KeyNum,2);
	}
}
	}</code></pre> 
<h5>④.软件使用小技巧</h5> 
<p>快速生成常用格式代码：</p> 
<p></p> 
<p class="img-center"><img alt="" height="391" src="https://images2.imgbox.com/75/2f/ZVy1HxQF_o.png" width="559"></p> 
<p>设置，完成后双击就可以生成了：</p> 
<p></p> 
<p class="img-center"><img alt="" height="417" src="https://images2.imgbox.com/8f/e7/i0byM5TX_o.png" width="522"></p> 
<p></p> 
<h3>6-2.矩阵键盘密码锁</h3> 
<h4>1）：把6-1文件全部cv到6-2工程文件中</h4> 
<h4>2）：代码实现</h4> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "LCD1602.h"
#include "matrixKey.h"

unsigned char KeyNum;
unsigned int Password,count;


void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"Helloworld");
	while(1)
	{
		KeyNum=MatrixKey();
		if(KeyNum){
			if(KeyNum&lt;=10){  				//s1~s10按下密码
				if(count&lt;4){
				Password*=10;
				Password+=KeyNum%10;       //这两句是用来实现四位密码的显示
				count++; 		//计数  防止按下的密码数超过四位	
				}
				LCD_ShowNum(2,1,Password,4);//更新显示
			}
			
			if(KeyNum==11){    //s11设置为确认键
				if(Password==2345){
					LCD_ShowString(1,14,"OK ");
					Password=0;  //密码清零
					count=0;      //计数清零
					LCD_ShowNum(2,1,Password,4);//更新显示
			}
				else {LCD_ShowString(1,14,"ERR");
					Password=0;  //密码清零
					count=0;      //计数清零
					LCD_ShowNum(2,1,Password,4);//更新显示
				}
	}
			
	   if(KeyNum==12){  //定义S12为取消键
			 Password=0;
			 count=0;
			 LCD_ShowNum(2,1,Password,4);
		 }
}
	}
}</code></pre> 
<p></p> 
<h3>7.定时器介绍</h3> 
<h4><strong>1）</strong>介绍，Delay前面CPU是一直在等的，用定时器在Delay时可以去检测按键，提高CPU利用率：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/9d/11/rp2lkolD_o.png" width="690"></p> 
<p></p> 
<p class="img-center"><img alt="" height="225" src="https://images2.imgbox.com/06/74/wgwY59JI_o.png" width="690"></p> 
<p></p> 
<p class="img-center"><img alt="" height="378" src="https://images2.imgbox.com/74/87/FToOA2Q1_o.png" width="687"></p> 
<p></p> 
<p class="img-center"><img alt="" height="385" src="https://images2.imgbox.com/ae/1c/org7VsTy_o.png" width="690"></p> 
<p></p> 
<p class="img-center"><img alt="" height="466" src="https://images2.imgbox.com/0c/17/NhdiHWok_o.png" width="613"></p> 
<p></p> 
<p class="img-center"><img alt="" height="327" src="https://images2.imgbox.com/7f/9d/V69nI0GX_o.png" width="690"></p> 
<p></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/7d/48/LkWYsmxu_o.png" width="690"></p> 
<h4><strong>2）</strong>模式1最常用：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="423" src="https://images2.imgbox.com/17/70/QsEZ2QOV_o.png" width="690"></p> 
<h4><strong>3）</strong>模式：时钟--计数最大65535（计数系统TL0\TH0：每来一个脉冲+1方法计数）-TF0(标志位，到最大了回到0)-中断：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="197" src="https://images2.imgbox.com/3a/fa/qdtCeu39_o.png" width="518"></p> 
<h4><strong>4）</strong>非门与门图形为控制部分（TR0是否启动暂定）</h4> 
<h4><strong>5）</strong>定时器部分：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/b4/74/4SxgsK1a_o.png" width="690"></p> 
<h4><strong>6）</strong>时钟可以由系统提供（上图，晶振），也可以由外部T0P提供（如下图引脚）</h4> 
<p></p> 
<p class="img-center"><img alt="" height="432" src="https://images2.imgbox.com/dc/d1/bKWqaEfC_o.png" width="526"></p> 
<h4><strong>7）</strong>C/T,给1连上面为控制器，给0连接下面为定时器（如下图）：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="40" src="https://images2.imgbox.com/2f/6b/FBHVJU5Y_o.png" width="31"></p> 
<h4><strong>8）</strong>中断系统：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="390" src="https://images2.imgbox.com/d7/02/dVxL3xBX_o.png" width="690"></p> 
<h4><strong>9）</strong>中断资源</h4> 
<p></p> 
<p class="img-center"><img alt="" height="383" src="https://images2.imgbox.com/2c/e0/aQXLFIc2_o.png" width="690"></p> 
<h4><strong>10）定时器和中断系统</strong></h4> 
<p></p> 
<p class="img-center"><img alt="" height="422" src="https://images2.imgbox.com/7b/78/TtQLpxwx_o.png" width="690"></p> 
<h4><strong>11）定时器相关寄存器</strong></h4> 
<p></p> 
<p class="img-center"><img alt="" height="402" src="https://images2.imgbox.com/33/b2/uNoua8pF_o.png" width="690"></p> 
<p></p> 
<p></p> 
<h3>7-1.独立按键控制流水灯的模式</h3> 
<h4>1.TMOD寄存器工作模式，定时器0配置使用（不可位寻址，只能整体赋值）</h4> 
<p></p> 
<p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/29/66/feGFlJhf_o.png" width="687"></p> 
<h4><strong>2.</strong>定时器模式1：门控端给0，就是tr0单独控制：C/T，T这里有一横表示低电平有效，就给0是用T（定时器模式），给1用C（控制器模式），M1,M0工作模式选择</h4> 
<p></p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/0e/4c/4PHEqSC2_o.png" width="602"></p> 
<h4>3.TCON控制寄存器（可位寻址，可以单独每一位赋值）</h4> 
<p></p> 
<p class="img-center"><img alt="" height="406" src="https://images2.imgbox.com/33/2b/UqTG4BBi_o.png" width="658"></p> 
<p>中断溢出标志位：</p> 
<p>TF=0（等于1产生中断）;</p> 
<p>TR0=1（定时器是否开启，给1开始，电机开始工作）；</p> 
<p>IE0、IT0：控制外部中断引脚，可以不配置</p> 
<p></p> 
<h4>4.定时器配置  TH0\TL0</h4> 
<p></p> 
<p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/0b/95/5eQG658h_o.png" width="382"></p> 
<p></p> 
<p>TH0\TL0 分开储存</p> 
<p></p> 
<p class="img-center"><img alt="" height="107" src="https://images2.imgbox.com/3a/4a/OnQTMpPq_o.png" width="366"></p> 
<p>代码优化，TMOD问题（不可位寻址）配置两个的时候，后面的会把前面的覆盖；</p> 
<p>因此，可采用“与或”法设定TMOD</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="59" src="https://images2.imgbox.com/f2/20/XBlUgptU_o.png" width="558"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/ca/86/rutjXV4r_o.png"></p> 
<p></p> 
<h4>5.中断配置T0--&gt;ET0=1--EA=1，PT0=0</h4> 
<p></p> 
<p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/c3/90/FNIzfdOP_o.png" width="522"></p> 
<p></p> 
<h4>6.定时器配置完成，模块化编程</h4> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;

void Timer0_Init(void)		//1ms@11.0592MHz
{
	TMOD &amp;= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0x66;		//设置定时器初值
	TH0 = 0xFC;		//设置定时器初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0=1;    //下面三行为中断的配置
	EA=1;
	PT0=0;
}


</code></pre> 
<p></p> 
<h4> 7.定时器中断函数模板</h4> 
<pre><code class="language-cpp">
void Timer0_Routine() interrupt 1  //中断函数
{
	static unsigned int T0Count; 
	TL0 = 0x66;		//设置定时器初值
	TH0 = 0xFC;		//设置定时器初值
	T0Count++;
	if(T0Count&gt;=1000)   //每隔1s
	{		
         T0Count=0;

	}
}</code></pre> 
<h4>8.独立按键模块</h4> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "Delay.h"



unsigned char Key()
{
	
	unsigned char KeyNumber=0;
	
	if(P3_1==0){Delay(20);while(P3_1==0);Delay(20);KeyNumber=1;}
	if(P3_0==0){Delay(20);while(P3_0==0);Delay(20);KeyNumber=2;}
	if(P3_2==0){Delay(20);while(P3_2==0);Delay(20);KeyNumber=3;}
	if(P3_3==0){Delay(20);while(P3_3==0);Delay(20);KeyNumber=4;}
	
	return KeyNumber;
}</code></pre> 
<h4>9.主函数</h4> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "Timer0.h"
#include "key.h"
#include &lt;INTRINS.H&gt;

unsigned char KeyNumber,LEDmode;
void main()
{
	P2=0xfe;  //与INTRINS.H中的循环左右移函数共同实现流水灯
	Timer0_Init(); //上电初始化
	while(1)
	{
		KeyNumber=Key();
		if(KeyNumber)
		{
			if(KeyNumber==1)
			{
				LEDmode++;
				if(LEDmode&gt;=2) LEDmode=0;
			}
			
		}
		
	}
}


 
void Timer0_Routine() interrupt 1  //中断函数
{
	static unsigned int T0Count; 
	TH0=64535/256;
	TL0=64535%256; 	
	T0Count++;
	if(T0Count&gt;=1000)   //每隔1s
	{
		T0Count=0;
	 if(LEDmode==0) P2=_crol_(P2,1);
	 if(LEDmode==1) P2=_cror_(P2,1);
	}
}</code></pre> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="295" src="https://images2.imgbox.com/50/13/UKVYgPE3_o.png" width="434"></p> 
<p></p> 
<h3>7-2.时钟 </h3> 
<h4>1.把LCD1602液晶显示、延迟、定时器、的代码复制到工程目录下，导入；</h4> 
<h4><strong>2.</strong>主函数包含其他模块头文件并初始化；</h4> 
<p></p> 
<p class="img-center"><img alt="" height="362" src="https://images2.imgbox.com/e1/3a/uHjZXLhl_o.png" width="436"></p> 
<h4><strong>3.</strong>复制定时器中断函数到main函数下：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="247" src="https://images2.imgbox.com/ad/bc/pa78IA44_o.png" width="416"></p> 
<p></p> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/04/f4/uXjHrArU_o.png" width="364"></p> 
<h4><strong>4.</strong>定义变量，秒计数、分、小时并显示：</h4> 
<p></p> 
<p class="img-center"><img alt="" height="366" src="https://images2.imgbox.com/74/12/VKAAtoYE_o.png" width="399"></p> 
<h4>5.代码综合</h4> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "LCD1602.h"
#include "Timer0.h"

unsigned char Sec,Min,Hour;
void main()
{
	LCD_Init();//³õÊ¼»¯
	Timer0_Init();
	LCD_ShowString(1,1,"CLOCK:");
	LCD_ShowString(2,1,"  :  :");
	while(1)
	{
	LCD_ShowNum(2,1,Hour,2);
	LCD_ShowNum(2,4,Min,2);
	LCD_ShowNum(2,7,Sec,2);
	}
}

void Timer0_Routine() interrupt 1  
{
	static unsigned int T0Count; 
	TL0 = 0x66;		
	TH0 = 0xFC;		
	T0Count++;
	if(T0Count&gt;=1000)   
	{
		T0Count=0;
    Sec++;
		if(Sec&gt;=60)
		{
			Sec=0;
			Min++;
			if(Min&gt;=60)
			{
				Min=0;
				Hour++;
				if(Hour&gt;=24)
				{
					Hour=0;}
				}
			}
		}
		
	}</code></pre> 
<p></p> 
<p></p> 
<h3>8-1串口介绍</h3> 
<h4><strong>1）</strong>介绍</h4> 
<p></p> 
<p class="img-center"><img alt="" height="416" src="https://images2.imgbox.com/48/78/AG62b1Ja_o.png" width="690"></p> 
<h4><strong>2）向</strong>单片机发送数据（下面框），返回（上框）</h4> 
<p></p> 
<p class="img-center"><img alt="" height="455" src="https://images2.imgbox.com/c1/8c/wSfpbFXA_o.png" width="638"></p> 
<h4><strong>3）</strong>DB9串口传输数据（注意使用的电压是否一致）使用RS232或RS485电平</h4> 
<p></p> 
<p class="img-center"><img alt="" height="394" src="https://images2.imgbox.com/58/6c/vS38gLCd_o.png" width="690"></p> 
<h4>4）知识点</h4> 
<h5>①硬件电路</h5> 
<p></p> 
<p class="img-center"><img alt="" height="430" src="https://images2.imgbox.com/3d/b9/d0XW34re_o.png" width="687"></p> 
<p>注：最少需要三根线实现双向通信：TXD，RXD，GND。VCC不一定需要，可独立供电。</p> 
<h5>②电平标准 </h5> 
<p> <img alt="" height="251" src="https://images2.imgbox.com/d9/62/wVKUcd1u_o.png" width="690"></p> 
<p> 差分信号优点：传送距离远（1km+）   TTL与RS232（10m）</p> 
<p></p> 
<h5>③常见通信接口比较</h5> 
<p><img alt="" height="368" src="https://images2.imgbox.com/27/b7/kxn5Rimf_o.png" width="690"></p> 
<p> CAN总线：常用于汽车领域，因为使用的是差分信号传输，传输距离远、稳定。</p> 
<p>通信方式的相关术语：</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/1e/2c/v6u9s22N_o.png" width="690"></p> 
<p></p> 
<h5>④51单片机里的UART串口 </h5> 
<p><img alt="" height="307" src="https://images2.imgbox.com/e3/e0/TxMkt3mK_o.png" width="690"></p> 
<p> <img alt="" height="443" src="https://images2.imgbox.com/d3/3b/dcxayclM_o.png" width="690"></p> 
<p></p> 
<p> <img alt="" height="714" src="https://images2.imgbox.com/23/4e/i0D9ny1q_o.png" width="1200"></p> 
<p></p> 
<p>   中间部分用来控制波特率，依靠定时器来约定速率，T1的溢出率通过分频后来控制收发器的采样时间。</p> 
<p>  SBUF：收发数据后，会产生相应的TI（发送中断）/RI（接收中断），继而进入中断函数，进行相应的中断函数内部的操作。</p> 
<p></p> 
<p><img alt="" height="440" src="https://images2.imgbox.com/7b/1b/WMjEkgVG_o.png" width="690"></p> 
<p> 配置ES、EA，PS此时不需要配置，因为只有一个中断，不需要进行优先级判断。</p> 
<p></p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/69/c5/S9KkxlSM_o.png" width="690"></p> 
<p> 配置好SCON和PCON，读SBUF，配置定时器T1，打开EA和ES，即串口可以开始工作。</p> 
<p></p> 
<h3>8-2.实际配置串口 </h3> 
<h4><strong>1）</strong>将延迟函数复制过来并导入工程里面；</h4> 
<h4><strong>2）</strong>配置串口控制寄存器，配置模式1最常用，REN允许接收给1，不允许接收给0（也可以给1外面不给发就行）；</h4> 
<p></p> 
<p class="img-center"><img alt="" height="393" src="https://images2.imgbox.com/f7/ea/YedopKsI_o.png" width="643"></p> 
<p></p> 
<p class="img-center"><img alt="" height="320" src="https://images2.imgbox.com/e7/d4/9GFwJLO0_o.png" width="648"></p> 
<p></p> 
<p class="img-center"><img alt="" height="324" src="https://images2.imgbox.com/48/2b/AOxwRXSj_o.png" width="655"></p> 
<h4><strong>3）TI、RI</strong>发送完置1（硬件只负责），但必须软件复位置0；</h4> 
<p></p> 
<p class="img-center"><img alt="" height="286" src="https://images2.imgbox.com/2f/53/5baJSmBA_o.png" width="631"></p> 
<p></p> 
<p class="img-center"><img alt="" height="412" src="https://images2.imgbox.com/5b/bd/mMnb69kt_o.png" width="621"></p> 
<p> 故SCON=0x40</p> 
<p>PCON</p> 
<h4><strong>4）配置定时器</strong></h4> 
<p></p> 
<p class="img-center"><img alt="" height="223" src="https://images2.imgbox.com/ad/51/B0zb8UHp_o.png" width="456"></p> 
<p>这里定时器1，没有定时器0，所有要把高位修改（不影响高低位配置用“”&amp; |“”这两个方式）</p> 
<p></p> 
<p class="img-center"><img alt="" height="407" src="https://images2.imgbox.com/30/6b/rkfE4pUj_o.png" width="639"></p> 
<p><strong>选择8位自动重载模式</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="473" src="https://images2.imgbox.com/ec/ac/SDgJlqoh_o.png" width="652"></p> 
<p></p> 
<h4>5）可以直接用STC-isp来配置串口 </h4> 
<p><img alt="" height="371" src="https://images2.imgbox.com/99/70/bcb2fAD0_o.png" width="639"></p> 
<p>系统频率根据板子选择，波特率4800，波特率发生器选择8位自动重载，时钟12T</p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/c4/54/BU4vUgyI_o.png" width="443"></p> 
<h4>6）发送数据的函数</h4> 
<p><img alt="" height="164" src="https://images2.imgbox.com/08/84/E71mEhhe_o.png" width="508"></p> 
<h4>7）发送单项数据</h4> 
<p><img alt="" height="171" src="https://images2.imgbox.com/ef/7b/BQh04oBg_o.png" width="305"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f7/4b/6dBvzpG2_o.jpg"></p> 
<p></p> 
<h4>8）模块化</h4> 
<p><img alt="" height="1028" src="https://images2.imgbox.com/25/71/tvPYa4xv_o.png" width="857"></p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/dd/75/P3WFuunP_o.png" width="860"></p> 
<h4>9）数据显示模式 </h4> 
<p><img alt="" height="490" src="https://images2.imgbox.com/2c/f7/xOANzRX0_o.png" width="1200"></p> 
<p><img alt="" height="442" src="https://images2.imgbox.com/10/b6/mm5x95Gv_o.png" width="425"></p> 
<p></p> 
<p></p> 
<h3>8-3.串口实例实现 </h3> 
<h4>1）每一秒发送一个递增的数字</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ea/b2/UqLO2pwE_o.png" width="984"></p> 
<p></p> 
<h4> 2）电脑通过串口控制LED灯，并且返回电脑读入的数据</h4> 
<h5>1.需要打开串口的中断功能</h5> 
<p><img alt="" height="518" src="https://images2.imgbox.com/d0/40/Zn80jx5N_o.png" width="756"></p> 
<p>SCON = 0x50;  EA=1;ES=1; </p> 
<p>注：要分清这里是禁止了定时器1的中断功能，只是让它的溢出率去开启串口收发的功能，中断的产生是由于串口收发数据产生的中断。</p> 
<h5>2.编写串口中断函数</h5> 
<p><img alt="" height="336" src="https://images2.imgbox.com/d9/8f/r9WKDA1X_o.png" width="821"></p> 
<p>串口中断函数模板：</p> 
<pre><code class="language-cpp">void UART_Routine() interrupt 4
{
	 if(RI==1)
	 {
		 
		 RI=0;   //复位清0
	 }
}</code></pre> 
<p></p> 
<h5>3.整体代码</h5> 
<p><img alt="" height="873" src="https://images2.imgbox.com/f1/cd/RLolhMbn_o.png" width="987"></p> 
<p></p> 
<h3>9-1LED点阵屏</h3> 
<h4>1.介绍：</h4> 
<h4><img alt="" height="754" src="https://images2.imgbox.com/c7/d8/rJYalLkp_o.png" width="1200"><br> 2.显示原理<img alt="" height="723" src="https://images2.imgbox.com/cd/04/BZ6gAOuv_o.png" width="1200"></h4> 
<h4>3.相关图</h4> 
<h5>①：led矩阵图——经测试，P0控制列，D控制行</h5> 
<p><img alt="" height="801" src="https://images2.imgbox.com/f8/9d/YUfRUsof_o.png" width="1200"></p> 
<h5>②：开发版引脚对应关系：</h5> 
<p><img alt="" height="727" src="https://images2.imgbox.com/db/fa/BWD5VOAr_o.png" width="1200"></p> 
<h5>③：74HC595 </h5> 
<p><img alt="" height="614" src="https://images2.imgbox.com/9c/e7/lLsFxosI_o.png" width="826"></p> 
<p> 加-,低电平有效</p> 
<p>OE： 使能，output enable，接低电平工作，高电平不工作。</p> 
<p>RCLK：寄存器时钟，register clock</p> 
<p>SRCLR：串行清零端</p> 
<p>SRCLK：串行时钟 </p> 
<p>SER：串行数据</p> 
<p>运行方式：类似队列</p> 
<p><img alt="" height="780" src="https://images2.imgbox.com/6b/2b/0hcqsy4t_o.png" width="1200"></p> 
<p></p> 
<h5>④：总结：使用步骤：进行行列的选择——列由P0口控制，因此给P0赋值就能控制列。行需通过74HC595来间接控制。</h5> 
<h3>9-2.点阵屏的驱动代码 </h3> 
<h4>示例代码1-点阵屏显示图形</h4> 
<h5>1)sfr与sbit，可位寻址与不可位寻址。</h5> 
<p><img alt="" height="705" src="https://images2.imgbox.com/0d/07/0chxHPjT_o.png" width="1200"></p> 
<p></p> 
<h5>2） 进行位声明，方便操作。</h5> 
<p><img alt="" height="432" src="https://images2.imgbox.com/5d/2c/B1wRn2Hf_o.png" width="552"></p> 
<h5>3）编写子函数——控制74HC595把字节数据输出给D的8个引脚。</h5> 
<p><img alt="" height="938" src="https://images2.imgbox.com/8d/8c/Ep6ZkNLu_o.png" width="1200"></p> 
<h5>4） 编写LED矩阵显示的子函数</h5> 
<p><img alt="" height="337" src="https://images2.imgbox.com/b7/e9/cl55PE2a_o.png" width="997"></p> 
<h5>5）  自己设计图形，调用函数输入数据，即可显示；</h5> 
<p></p> 
<h4>示例代码2-点阵屏显示动画</h4> 
<h5>1）把示例1的代码模块化</h5> 
<h5>2）定义要显示的动画的数组，并初步检测是否显示正常</h5> 
<p><img alt="" height="1091" src="https://images2.imgbox.com/9d/93/FyYLf13S_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="859" src="https://images2.imgbox.com/6e/03/BScrfrVI_o.png" width="1047"></p> 
<h5>3）实现动态显示</h5> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/4f/16/FkEYGkdR_o.png" width="1158"></p> 
<p>上述代码实现的是流水式的动画，也可以改变offset去实现逐帧动画。</p> 
<h5>4）定义的Animation是放在RAM中的，有空间限制，浪费RAM空间。所以可以加个code，把它放在flash里，但此时不可在主函数里改变数组内容。</h5> 
<p><img alt="" height="274" src="https://images2.imgbox.com/32/68/FDf80rj6_o.png" width="1048"></p> 
<p></p> 
<h3>10-1 DS1302实时时钟介绍</h3> 
<h4>1.介绍</h4> 
<p>定时器计时的缺点：1.精度不高  2.消耗单片机的CPU  3.断电不能继续计时</p> 
<p>而时钟芯片精度高，且有备用电源，掉电可以用备用电源继续计时。</p> 
<p><img alt="" height="735" src="https://images2.imgbox.com/6f/e1/uvmSUq3Y_o.png" width="1200"></p> 
<h4>2.时钟芯片的引脚定义和应用电路</h4> 
<p>①：两种封装模式：直插封装和贴片封装  ②：分为三部分：电源部分，时钟部分，数据交互部分</p> 
<p><img alt="" height="749" src="https://images2.imgbox.com/74/fb/e3OOP8wV_o.png" width="1200"></p> 
<h4>3. 内部结构框图</h4> 
<p><img alt="" height="725" src="https://images2.imgbox.com/bc/18/C5AUM56V_o.png" width="1200"></p> 
<h4>4.内部寄存器的定义</h4> 
<p>秒，分，时，日，月，年，星期，年，wp（write protect，写保护），涓流充电</p> 
<p><img alt="" height="723" src="https://images2.imgbox.com/b1/42/pDkMRpxZ_o.png" width="1200"></p> 
<p>前两列的为 ：命令字——</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/a5/ae/TPZ8K6pd_o.png" width="1135"></p> 
<h4>5. 时序图</h4> 
<p>前八为指定读还是写，后八位读出或者写入指定的数据。</p> 
<p>上升沿写入，下降沿读出。</p> 
<p><img alt="" height="730" src="https://images2.imgbox.com/b1/09/U7QkeBpq_o.png" width="1200"></p> 
<h4>6.BCD码</h4> 
<p><img alt="" height="722" src="https://images2.imgbox.com/b3/fd/4bV4Xy2X_o.png" width="1200"></p> 
<h3>10-2 实例代码</h3> 
<h4>1.时钟</h4> 
<h5>1）创建工程，cvLCD1602的文件，并开始模块化编写DS1302的模块</h5> 
<p><img alt="" height="304" src="https://images2.imgbox.com/d3/6e/RSDv0aor_o.png" width="892"></p> 
<h5>2） DS1302模块的子函数编写</h5> 
<p><img alt="" height="1170" src="https://images2.imgbox.com/49/99/doMzKt6N_o.png" width="1198"><img alt="" height="649" src="https://images2.imgbox.com/d0/0f/zdQqIC4j_o.png" width="1200"></p> 
<h5>3）初步测试 </h5> 
<p>结果会发现，数字到9后会直接到16……，这是因为寄存器数据是以BCD码存储的，只需将Second改为Second/16*10+Second%16，就可以转化成十进制，正常显示。</p> 
<p><img alt="" height="801" src="https://images2.imgbox.com/6b/8d/p4Q96xOr_o.png" width="1004"></p> 
<p><img alt="" height="722" src="https://images2.imgbox.com/8c/30/FIKzosqH_o.png" width="1200"></p> 
<h5>4） 定义一下各个寄存器的地址，方便操作；再定义一个存储时间的数组；<img alt="" height="396" src="https://images2.imgbox.com/d0/2e/BlikVsga_o.png" width="1074"></h5> 
<h5>5） 编写DS1302的另外两个子函数——①：设定时间 ②：读出时间     并声明为外部可调用的函数和数组；</h5> 
<p><img alt="" height="583" src="https://images2.imgbox.com/d3/79/sFlgW1ng_o.png" width="1200"></p> 
<p><img alt="" height="789" src="https://images2.imgbox.com/35/3b/QULhf0p3_o.png" width="1200"></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/d5/c0/GR9XgS1g_o.png" width="1200"></p> 
<h5>6） 编写主函数，调用函数在LCD显示屏上显示时间<img alt="" height="1000" src="https://images2.imgbox.com/0d/7b/vp3AtRcA_o.png" width="1095"></h5> 
<h4>2.功能化时钟——可以用独立按键设置要显示的时间</h4> 
<h5>1）需要用到的模块</h5> 
<p>DS1302模块，LCD1602模块，独立按键key模块，定时器Timer0模块，延时函数模块；</p> 
<h5>2）编写主函数</h5> 
<p>主要分为四大部分：时钟模式选择，显示时间，设置时间（选择设置的时间位置，调整时间大小，利用定时器中断去实现选择的时间的位置的动态显示），更新显示新的时钟。</p> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "LCD1602.h"
#include "DS1302.h"
#include "Key.h"
#include "Timer0.h"
#include "Delay.h"

unsigned char KeyNum,MODE,TimeSetSelect,TimeFlashFlag;


/**
  * @brief  显示时间
  * @param 无
  * @retval 无
  */
void TimeShow(void)
{
		DS1302_ReadTime();
		LCD_ShowNum(1,1,DS1302_Time[0],2);
		LCD_ShowNum(1,4,DS1302_Time[1],2);
		LCD_ShowNum(1,7,DS1302_Time[2],2);
		LCD_ShowNum(2,1,DS1302_Time[3],2);
		LCD_ShowNum(2,4,DS1302_Time[4],2);
		LCD_ShowNum(2,7,DS1302_Time[5],2);
}

/**
  * @brief  设置时间，按键2选择设置的时间位置，按键3让时间++，按键4让时间--
  * @param  无
  * @retval 无
  */
void TimeSet(void)
{
	if(KeyNum==2)
	{
		TimeSetSelect++;
		TimeSetSelect %= 6;
	}
	if(KeyNum==3)
	{
		DS1302_Time[TimeSetSelect]++;
		if(DS1302_Time[0]&gt;99){DS1302_Time[0]=0;}
		if(DS1302_Time[1]&gt;12){DS1302_Time[1]=1;}
		if(DS1302_Time[1]==1 || DS1302_Time[1]==3 ||DS1302_Time[1]==5 ||DS1302_Time[1]==7 
		|| DS1302_Time[1]==8 || DS1302_Time[1]==10 ||DS1302_Time[1]==12)
		{
			if(DS1302_Time[2]&gt;31){DS1302_Time[2]=1;}
		}else if(DS1302_Time[1]==4 || DS1302_Time[1]==6 ||DS1302_Time[1]==5 ||                     
        DS1302_Time[1]==9 || DS1302_Time[1]==11)
		{
			if(DS1302_Time[2]&gt;30){DS1302_Time[2]=1;}
		}else if(DS1302_Time[1]==2)
		{	if(DS1302_Time[0]%100!=0&amp;&amp;DS1302_Time[0]%4==0||DS1302_Time[0]%100==0&amp;&amp;DS1302_Time[0]%400==0)
			{
				if(DS1302_Time[2]&gt;29){DS1302_Time[2]=1;}
			}else if(DS1302_Time[2]&gt;28){DS1302_Time[2]=1;}
		}
		if(DS1302_Time[3]&gt;23){DS1302_Time[3]=0;}
		if(DS1302_Time[4]&gt;59){DS1302_Time[4]=0;}
		if(DS1302_Time[5]&gt;59){DS1302_Time[5]=0;}
	}
	if(KeyNum==4)
	{
		DS1302_Time[TimeSetSelect]--;
		if(DS1302_Time[0]&lt;0){DS1302_Time[0]=99;}
		if(DS1302_Time[1]&lt;0){DS1302_Time[1]=12;}
		if(DS1302_Time[1]==1 || DS1302_Time[1]==3 ||DS1302_Time[1]==5 || DS1302_Time[1]==7 
			|| DS1302_Time[1]==8 || DS1302_Time[1]==10 ||DS1302_Time[1]==12)
		{
			if(DS1302_Time[2]&lt;1){DS1302_Time[2]=31;}
			if(DS1302_Time[2]&gt;31){DS1302_Time[2]=1;}
		}else if(DS1302_Time[1]==4 || DS1302_Time[1]==6 ||DS1302_Time[1]==5 || DS1302_Time[1]==9 
		||	DS1302_Time[1]==11)
		{
			if(DS1302_Time[2]&lt;1){DS1302_Time[2]=30;}
			if(DS1302_Time[2]&gt;30){DS1302_Time[2]=1;}
		}else if(DS1302_Time[1]==2)
		{
			if(DS1302_Time[0]%100!=0&amp;&amp;DS1302_Time[0]%4==0||DS1302_Time[0]%100==0&amp;&amp;DS1302_Time[0]%400==0)
			{
				if(DS1302_Time[2]&lt;1){DS1302_Time[2]=29;}
				if(DS1302_Time[2]&gt;29){DS1302_Time[2]=1;}
			}else 
	{
		if(DS1302_Time[2]&lt;1){DS1302_Time[2]=28;}
		if(DS1302_Time[2]&gt;28){DS1302_Time[2]=1;}
	}
		}
		if(DS1302_Time[3]&lt;0){DS1302_Time[3]=23;}
		if(DS1302_Time[4]&lt;0){DS1302_Time[4]=59;}
		if(DS1302_Time[5]&lt;0){DS1302_Time[5]=59;}
	}
	//动态显示选择位
	if(TimeSetSelect==0 &amp;&amp; TimeFlashFlag==1 ){LCD_ShowString(1,1,"  ");}
	else {LCD_ShowNum(1,1,DS1302_Time[0],2);}
	if(TimeSetSelect==1 &amp;&amp; TimeFlashFlag==1 ){LCD_ShowString(1,4,"  ");}
	else {LCD_ShowNum(1,4,DS1302_Time[1],2);}
	if(TimeSetSelect==2 &amp;&amp; TimeFlashFlag==1 ){LCD_ShowString(1,7,"  ");}
	else {LCD_ShowNum(1,7,DS1302_Time[2],2);}
	if(TimeSetSelect==3 &amp;&amp; TimeFlashFlag==1 ){LCD_ShowString(2,1,"  ");}
	else {LCD_ShowNum(2,1,DS1302_Time[3],2);}
	if(TimeSetSelect==4 &amp;&amp; TimeFlashFlag==1 ){LCD_ShowString(2,4,"  ");}
	else {LCD_ShowNum(2,4,DS1302_Time[4],2);}
	if(TimeSetSelect==5 &amp;&amp; TimeFlashFlag==1 ){LCD_ShowString(2,7,"  ");}
	else {LCD_ShowNum(2,7,DS1302_Time[5],2);}
}



void main()
{
	Timer0_Init();
	LCD_Init();
	DS1302_Init();
	DS1302_WriteByte(0x8e,0x00);  

	LCD_ShowString(1,1,"  -  -  ");
	LCD_ShowString(2,1,"  :  :  ");
	DS1302_SetTime();
	
	while(1)
	{
		//通过按键1控制时钟的模式，模式0为显示时钟，模式1为设置时间
		KeyNum=key();
		if(KeyNum==1)
		{
			if(MODE==0){MODE=1;TimeSetSelect=0;}
			else if(MODE==1) {MODE=0;DS1302_SetTime();}
		}
		switch(MODE)
		{
			case 0:TimeShow();break;
			case 1:TimeSet();break;
		}
	}
	
}

//利用定时器中断来动态显示选择的时间位置
void Timer0_Routine() interrupt 1  
{
	static unsigned int T0Count; 
	TL0 = 0x66;		
	TH0 = 0xFC;		
	T0Count++;
	if(T0Count&gt;=1000)   
	{
		T0Count=0;
		TimeFlashFlag=!TimeFlashFlag;
	}
}
</code></pre> 
<h3>11.蜂鸣器</h3> 
<h4>1）介绍</h4> 
<p><img alt="" height="742" src="https://images2.imgbox.com/bf/80/Os3enZlj_o.png" width="1200"></p> 
<p> NPN：高电平导通     PNP：低电平导通</p> 
<p><img alt="" height="717" src="https://images2.imgbox.com/cb/dd/sC7PduCr_o.png" width="1200"></p> 
<p><img alt="" height="703" src="https://images2.imgbox.com/46/57/VtgqKQxN_o.png" width="1200"></p> 
<p>由P15的高低电平取反控制BZ的高低电平</p> 
<p><img alt="" height="666" src="https://images2.imgbox.com/80/05/piaPLnFF_o.png" width="1200"></p> 
<h4> 2）乐理知识</h4> 
<h5>①：介绍C1-C2升高8度。往右升高，往左降低：相邻半音黑白，1对应中央C1，i表示升即C2部分，降低8度下面加一个点，降低2个8度，下面加两个点（白键）；相邻两个键为半音#：升高半音，b:降低半音。</h5> 
<p><img alt="" height="717" src="https://images2.imgbox.com/17/6d/VmuKCroG_o.png" width="1200"></p> 
<h5>②：-表示时长，如图中的665-，其中5占两个节拍，</h5> 
<p><img alt="" height="448" src="https://images2.imgbox.com/fd/6c/oEX4Ko4U_o.png" width="1043"></p> 
<h5>③：音符</h5> 
<p> 一般以四分音符为一个基准<img alt="" height="128" src="https://images2.imgbox.com/00/b3/lNsx3ozW_o.png" width="690"></p> 
<h5>④：音符频率对照</h5> 
<p><img alt="" height="726" src="https://images2.imgbox.com/7d/b9/C1bNRTHC_o.png" width="1200"></p> 
<h5>⑤：以a440hz为基准，到另一个a，中间等比12频分，<img alt="" height="683" src="https://images2.imgbox.com/d3/e3/aXJLjjDs_o.png" width="1200"></h5> 
<h5> ⑥：单片机晶振芯片每秒震荡的次数称为时钟频率，震荡一次所需时间称为振荡周期。12个震荡周期是一个机器周期，机器频率=晶振频率/12，计时周期=1/机器周期，即每过一个计时周期，定时器计数+1；</h5> 
<h5>给定时器的TL和TH赋重装载值，使定时器每过所需周期的一半时计数+1（因为需要给震荡信号，故计数周期=原周期的二分之一），从而使蜂鸣器发出对应频率的声音。</h5> 
<p><img alt="" height="483" src="https://images2.imgbox.com/de/2c/K92Aixo5_o.png" width="454"></p> 
<h4>3）实例代码</h4> 
<h5>1.蜂鸣器鸣响</h5> 
<h6>①：蜂鸣器模块函数</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e1/68/qe03t9RB_o.png" width="1082"></p> 
<h6>②：主函数——按下独立按键，在数码管上显示按的第几个键，并且蜂鸣器鸣响。</h6> 
<p> <img alt="" height="934" src="https://images2.imgbox.com/5c/e1/TESM4UKw_o.png" width="1133"></p> 
<h5>2.蜂鸣器演奏音乐—有时间再补</h5> 
<p></p> 
<h3>12.AT24C02，I2C总线</h3> 
<h4>1.存储器介绍</h4> 
<p>RAM：存储速度快，但是掉电丢失   ROM：掉电不丢失，但是速度慢。</p> 
<p><img alt="" height="719" src="https://images2.imgbox.com/fb/dc/pkveMIaB_o.png" width="1200"></p> 
<h4>2.AT24C02介绍</h4> 
<p><img alt="" height="723" src="https://images2.imgbox.com/73/33/SC0UciZ9_o.png" width="1200"></p> 
<p>引脚及应用电路</p> 
<p><img alt="" height="712" src="https://images2.imgbox.com/28/a4/iSJiYDpg_o.png" width="1200"></p> 
<p> <img alt="" height="616" src="https://images2.imgbox.com/4f/84/qBIEnRLv_o.png" width="661"></p> 
<h4>3. I2C总线</h4> 
<p><img alt="" height="728" src="https://images2.imgbox.com/20/dc/XJRfJQ4t_o.png" width="1200"></p> 
<p> <img alt="" height="716" src="https://images2.imgbox.com/f8/06/6AjYcRXZ_o.png" width="1200"></p> 
<p>I2C通信 时序结构：</p> 
<p><img alt="" height="705" src="https://images2.imgbox.com/3c/c4/QN3jFP2Z_o.png" width="1200"></p> 
<p> <img alt="" height="717" src="https://images2.imgbox.com/5e/2e/UtU6vG6W_o.png" width="1200"></p> 
<p> <img alt="" height="719" src="https://images2.imgbox.com/d7/37/gk44tn4R_o.png" width="1200"></p> 
<p> <img alt="" height="706" src="https://images2.imgbox.com/a5/8d/3YGUPOyF_o.png" width="1200"></p> 
<p> <img alt="" height="683" src="https://images2.imgbox.com/7b/87/sJPCLZ91_o.png" width="1200"></p> 
<p> <img alt="" height="693" src="https://images2.imgbox.com/fb/36/L6frr6HO_o.png" width="1200"></p> 
<p> <img alt="" height="665" src="https://images2.imgbox.com/88/75/1ygw7w0c_o.png" width="1200"></p> 
<p><img alt="" height="706" src="https://images2.imgbox.com/d4/28/p9x0wPSS_o.png" width="1200"></p> 
<h4>4.示例程序</h4> 
<h5>1——用独立按键设置想要写入的数据，并读出显示在LCD上，断电不丢失。</h5> 
<h6>①：程序编写整体思路：编写I2C模块，AT24C02模块，main模块</h6> 
<p><img alt="" height="581" src="https://images2.imgbox.com/0a/96/FHZZuXgm_o.png" width="1200"></p> 
<h6>②：编写I2C模块</h6> 
<p>先进行位声明，再分别编写子函数，开始，结束，发送和接受一个字节，发送和接收应答位</p> 
<p><img alt="" height="1115" src="https://images2.imgbox.com/5a/0c/rekmg3TK_o.png" width="1117"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/76/6f/9cxiCgVX_o.png" width="1200"></p> 
<p> <img alt="" height="996" src="https://images2.imgbox.com/61/b8/CPTzc9lW_o.png" width="1200"></p> 
<h6>③：编写AT24C02模块</h6> 
<p>先定义一下AT24C02的地址，写是0xA0,读是0xA1；</p> 
<p>再用I2C里的函数去编写写入一个字节和读出一个字节的函数</p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/b4/7a/kYmJCUkQ_o.png" width="1162"></p> 
<h6>④：编写main模块</h6> 
<p>用独立按键控制想要写入的数据，并读出显示在LCD上，断电不丢失。</p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/29/60/97giaxzj_o.png" width="895"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/12/7c/wOTwrJGG_o.png" width="1055"></p> 
<h5>2——秒表（用定时器扫描数码管）</h5> 
<h6>①：先创建新的工程，包含所需的模块——独立按键，数码管，延迟函数，定时器，AT，I2C</h6> 
<h6>②：改造独立按键模块——用定时器扫描独立按键</h6> 
<p>这样就不用像原来一样在检测时停在while死循环里，影响主函数进程</p> 
<p> <img alt="" height="893" src="https://images2.imgbox.com/90/45/0UNiDU91_o.png" width="1200"></p> 
<p><img alt="" height="713" src="https://images2.imgbox.com/30/f9/0JIw1MvJ_o.png" width="1200"></p> 
<h6>③：改造数码管模块——改造成用定时器扫描数码管</h6> 
<p>先在main模块的中断函数里加上一个计数定时器的T0Count2，这样每隔一段时间就会调用一下NixieLoop函数，而NixieLoop函数会不断扫描并在数码管上显示每一位数字。NixieSetBuf函数会根据输入的位置和数字改变Buf数组里的值，继而让NixieLoop扫描显示对应的值。</p> 
<p> <img alt="" height="599" src="https://images2.imgbox.com/73/df/zjPvBXfm_o.png" width="1000"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d6/38/ztbFNd7P_o.png" width="1186"></p> 
<h6>④： 编写主函数</h6> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "Timer0.h"
#include "key.h"
#include "Delay.h"
#include "Nixie.h"
#include "AT24C02.h"

unsigned char KeyNum;
unsigned char Min,Sec,Minisec;
unsigned char Runflag;

void main()
{
	Timer0_Init();
	
	while(1)
	{
		KeyNum=Key();
		if(KeyNum==1)   //按键1控制开始和停止计时
		{
			Runflag=!Runflag;
		}
		if(KeyNum==2)    //按键2清0
		{
			Min=0;
			Sec=0;
			Minisec=0;
		}
		if(KeyNum==3)  //按键3将数据写入AT
		{
			AT24C02_WriteByte(0,Min);
			Delay(5);
			AT24C02_WriteByte(1,Sec);
			Delay(5);
			AT24C02_WriteByte(2,Minisec);
			Delay(5);
		}
		if(KeyNum==4)   //按键4读出数据
		{
			Min=AT24C02_ReadByte(0);
			Sec=AT24C02_ReadByte(1);
			Minisec=AT24C02_ReadByte(2);
		}
			Nixie_SetBuf(1,Min/10);
			Nixie_SetBuf(2,Min%10);
			Nixie_SetBuf(3,11);
			Nixie_SetBuf(4,Sec/10);
			Nixie_SetBuf(5,Sec%10);
			Nixie_SetBuf(6,11);
			Nixie_SetBuf(7,Minisec/10);
			Nixie_SetBuf(8,Minisec%10);
		
	}
}

//计时中断函数
void Sec_Loop()
{
	if(Runflag)
	{
	Minisec++;
	if(Minisec&gt;=100)
	{
		Minisec=0;
		Sec++;
		if(Sec&gt;=60)
		{
			Sec=0;
			Min++;
			if(Min&gt;=60)
			{
				Min=0;
			}
		}
	}
}
}


void Timer0_Routine() interrupt 1  //ÖÐ¶Ïº¯Êý
{
	static unsigned int T0Count1,T0Count2,T0Count3; 
	TL0 = 0x66;		//ÉèÖÃ¶¨Ê±Æ÷³õÖµ
	TH0 = 0xFC;		//ÉèÖÃ¶¨Ê±Æ÷³õÖµ
	T0Count1++;
	if(T0Count1&gt;=20)  
	{
		T0Count1=0;
		Key_Loop();
	}
	T0Count2++;
	if(T0Count2&gt;=2)   
	{
		T0Count2=0;
		Nixie_Loop();
	}
	T0Count3++;
	if(T0Count3&gt;=10)
	{
		T0Count3=0;
		Sec_Loop();
	}
}</code></pre> 
<h3>13.1 DS18B20——温度传感器</h3> 
<h4>1.介绍</h4> 
<p><img alt="" height="714" src="https://images2.imgbox.com/3b/c8/R8lbf7wa_o.png" width="1200"></p> 
<h4> 2.引脚及应用电路</h4> 
<p><img alt="" height="722" src="https://images2.imgbox.com/42/21/Cbm5aO1O_o.png" width="1200"></p> 
<h4>3.内部结构框图</h4> 
<p>最后一列分别是：温度传感器（内部的模拟温度传感器，能进行数据的转换），存储高报警位的EEPROM，存储低报警位的EEPROM，调节精度，校验码</p> 
<p><img alt="" height="722" src="https://images2.imgbox.com/c6/c3/riVnGZXs_o.png" width="1200"></p> 
<p><img alt="" height="712" src="https://images2.imgbox.com/f8/58/vjFH97Qo_o.png" width="1200"></p> 
<p>前两个字节分别存储数据的低位和高位</p> 
<p></p> 
<p><img alt="" height="729" src="https://images2.imgbox.com/31/3c/U4cVary2_o.png" width="1200"></p> 
<p>总体思路：先发送温度转换的指令，再发送读数据的指令。因此，我们接下来要学习，如何通过单总线来发送数据和接收数据。</p> 
<h4>4.单总线介绍</h4> 
<h5>①：介绍</h5> 
<p><img alt="" height="719" src="https://images2.imgbox.com/ca/59/95KdWo7h_o.png" width="1200"></p> 
<p><img alt="" height="721" src="https://images2.imgbox.com/f9/16/YUc4604S_o.png" width="1200"></p> 
<h5>  ②：时序结构</h5> 
<p><img alt="" height="724" src="https://images2.imgbox.com/f5/e9/hNp2htGp_o.png" width="1200"></p> 
<p> <img alt="" height="708" src="https://images2.imgbox.com/1e/0a/0kzofP6k_o.png" width="1200"></p> 
<p><img alt="" height="712" src="https://images2.imgbox.com/df/54/DcasQ1Oh_o.png" width="1200"></p> 
<p><img alt="" height="710" src="https://images2.imgbox.com/17/2d/BM9iAahK_o.png" width="1200"></p> 
<h4>5.DS18B20操作流程</h4> 
<p> 本节需要的指令SKIP ROM，CONVERT T：让温度转换器进行数据的转换，READ SCRATCHPAD：读暂存器，依次读出每一个字节。<img alt="" height="704" src="https://images2.imgbox.com/be/1d/KjjOFtJT_o.png" width="1200"></p> 
<p> <img alt="" height="696" src="https://images2.imgbox.com/ec/10/7xLRDBBC_o.png" width="1200"></p> 
<p> <img alt="" height="742" src="https://images2.imgbox.com/3d/d3/xoAu4ihC_o.png" width="1200"></p> 
<p>包括符号，整数部分，小数部分，其中负数以补码形式存储</p> 
<p></p> 
<h3>13.2示例代码</h3> 
<h4>1-DS18B20温度读取</h4> 
<h5>①：整体思路——先写OneWire模块（包括初始化，发送一位，读出一位，发送一个字节，接收一个字节），再写DS18B20模块（包括温度转换指令函数，读取数据函数），最后编写main函数。</h5> 
<p><img alt="" height="527" src="https://images2.imgbox.com/73/d0/EO5DlBwc_o.png" width="1200"></p> 
<p></p> 
<h5>②：OneWire模块编写</h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b5/5c/EacR8pzA_o.png" width="1131"></p> 
<p></p> 
<p><img alt="" height="638" src="https://images2.imgbox.com/61/ab/a7OSS0M8_o.png" width="1073"></p> 
<h5 style="background-color:transparent;">③：DS18B20模块编写</h5> 
<p><img alt="" height="929" src="https://images2.imgbox.com/e2/07/fjAIbTRa_o.png" width="1200"></p> 
<h5>④：main函数</h5> 
<p><img alt="" height="1078" src="https://images2.imgbox.com/8f/a9/TVCMgx3g_o.png" width="1200"></p> 
<h4>实例代码2-DS18B20温度报警器</h4> 
<h5>①：要用到的模块：AT24C02，Delay，DS18B20，LCD1602，OneWire，I2C，key，Timer0</h5> 
<h5>②：main函数</h5> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include "DS18B20.h"
#include "key.h"
#include "LCD1602.h"
#include "Delay.h"
#include "AT24C02.h"
#include "Timer0.h"

float T,TShow;
char TLow,THigh;
unsigned char KeyNum;

void main()
{
	DS18B20_ConverT();
	Delay(1000);
	THigh=AT24C02_ReadByte(0);
	TLow=AT24C02_ReadByte(1);
	if(THigh&gt;125 || TLow&lt;-55 || THigh&lt;=TLow)
	{
		THigh=20;
		TLow=15;
	}
	LCD_Init();
	LCD_ShowString(1,1,"T:");
	LCD_ShowString(2,1,"TH:");
	LCD_ShowString(2,9,"TL:");
	LCD_ShowSignedNum(2,4,THigh,3);
	LCD_ShowSignedNum(2,12,TLow,3);
	Timer0_Init();
	while(1)
	{
		KeyNum=Key();
		/*温度读取及显示*/
		DS18B20_ConverT();
		T=DS18B20_ReadT();
		if(T&lt;0)
		{
			LCD_ShowChar(1,3,'-');
			TShow=-T;
		}
		else 
		{
			LCD_ShowChar(1,3,'+');
			TShow=T;
		}
		LCD_ShowNum(1,4,TShow,3);
		LCD_ShowChar(1,7,'.');
		LCD_ShowNum(1,8,(unsigned long)(TShow*100)%100,2);
		
		/*阈值判断及显示*/
		if(KeyNum)
		{
		if(KeyNum==1)
		{
			THigh++;
			if(THigh&gt;125){THigh=125;}
		}
		if(KeyNum==2)
		{
			THigh--;
			if(THigh&lt;=TLow){THigh++;}
		}
		if(KeyNum==3)
		{
			TLow++;
			if(TLow&gt;=THigh){TLow--;}
		}
		if(KeyNum==4)
		{
			TLow--;
			if(TLow&lt;-55){TLow=-55;}
		}
		LCD_ShowSignedNum(2,4,THigh,3);
		LCD_ShowSignedNum(2,12,TLow,3);
		AT24C02_WriteByte(0,THigh);
		Delay(5);
		AT24C02_WriteByte(1,TLow);
		Delay(5);
	}
		if(T&gt;THigh)
		{
			LCD_ShowString(1,13,"OV:H");
		}
		else if(T&lt;TLow)
		{
			LCD_ShowString(1,13,"OV:L");
		}
		else {LCD_ShowString(1,13,"OV: ");}
	}
}


void Timer0_Routine() interrupt 1  //中断函数
{
	static unsigned int T0Count; 
	TL0 = 0x66;		
	TH0 = 0xFC;		
	T0Count++;
	if(T0Count&gt;=20)   
	{
		T0Count=0;
		Key_Loop();
	}
}
</code></pre> 
<p>为防止定时器扫描按键时会打断OneWire的传送与接收</p> 
<p>可以在OneWire里先关闭EA，再打开EA。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b8/38/qVBQE5C6_o.png" width="1103"></p> 
<p></p> 
<h3>14-1 LCD1602液晶显示屏</h3> 
<h4>1.介绍</h4> 
<p><img alt="" height="712" src="https://images2.imgbox.com/da/16/rh56xmQm_o.png" width="1200"></p> 
<h4> 2.引脚及应用电路</h4> 
<p><img alt="" height="709" src="https://images2.imgbox.com/48/9c/NBzWyBVj_o.png" width="1200"></p> 
<h4>   3.内部结构框图</h4> 
<p><img alt="" height="704" src="https://images2.imgbox.com/c3/22/lt9SpPkB_o.png" width="1200"></p> 
<h4> 4.存储器结构</h4> 
<p><img alt="" height="709" src="https://images2.imgbox.com/0a/d7/w9WZcElU_o.png" width="1200"></p> 
<h4> 5.时序结构</h4> 
<p><img alt="" height="717" src="https://images2.imgbox.com/72/ac/5fqptxir_o.png" width="1200"></p> 
<h4> 6.LCD1602指令集</h4> 
<p><img alt="" height="752" src="https://images2.imgbox.com/ca/23/Qjxs2s8g_o.png" width="1200"></p> 
<p> <img alt="" height="499" src="https://images2.imgbox.com/a0/19/p2jtRXxQ_o.png" width="1200"></p> 
<p> </p> 
<h4>7.LCD1602操作流程</h4> 
<p><img alt="" height="659" src="https://images2.imgbox.com/6b/ea/DbMsP3Lx_o.png" width="1200"></p> 
<p> </p> 
<h3>14-2 功能代码编写</h3> 
<p><img alt="" height="1090" src="https://images2.imgbox.com/e4/3b/UJJDiAkI_o.png" width="1200"></p> 
<p><img alt="" height="1038" src="https://images2.imgbox.com/3b/85/9tOxqDqI_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/91/87/ACjx5oOe_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e3/82/zccvmyyw_o.png" width="1200"></p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/9c/2f/Up6MxDFI_o.png" width="1200"></p> 
<p>之后可以在main函数里调用流动的指令，实现流动字幕</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/c6/8e/Xkp1RCRI_o.png" width="879"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75c4cfbdebe4e47d922bc073838af1f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">医院等保解决方案有哪些？用哪些软件可以加强等级保护？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e397e2f9e2862064322af681c1bd459e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git分布式版本控制系统及在码云上创建项目并pull和push</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>