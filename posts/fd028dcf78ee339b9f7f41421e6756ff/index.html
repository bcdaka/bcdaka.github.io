<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;必修：深入探索多态的奥秘 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fd028dcf78ee339b9f7f41421e6756ff/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;必修：深入探索多态的奥秘">
  <meta property="og:description" content="✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：C&#43;&#43;学习
贝蒂的主页：Betty’s blog
前言需知： 本文中的代码及解释都是在vs2022下的x86程序中，涉及的指针都是4bytes。如果要其他平台下，部分代码需要改动。比如：如果是x64程序，则需要考虑指针是8bytes问题等等。
1. 多态的引入 1.1. 多态的概念 通俗来说，多态就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。举一个简单的例子：
当我们去买票时，普通人买票时，是全价买票；学生买票时，是半价买票；军人买票时是优先买票。普通人，学生，军人虽然都属于人这类整体，但是在进行买票这个行为时却会发生不同的状态。这就是一种典型的多态行为。
1.2. 多态的定义 在 C&#43;&#43; 中，多态指的是通过基类的指针或引用，在运行时能够调用派生类中实现的同名函数，从而表现出不同的行为。而构成多态一定要满足两个条件：
必须通过基类的指针或者引用调用虚函数。被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。 下面是一个简单的多态调用：
class Person { public: virtual void BuyTicket() //虚函数 { cout &lt;&lt; &#34;买票-全价&#34; &lt;&lt; endl; } }; class Student : public Person { public: virtual void BuyTicket()//虚函数重写 { cout &lt;&lt; &#34;买票-半价&#34; &lt;&lt; endl; } }; void Func(Person&amp; p)//基类引用调用 { p.BuyTicket(); } int main() { Person ps; Student st; Func(ps); Func(st); return 0; } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-16T23:22:18+08:00">
    <meta property="article:modified_time" content="2024-07-16T23:22:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;必修：深入探索多态的奥秘</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><img src="https://images2.imgbox.com/8e/5f/vINc9ZWV_o.png" alt=""></p> 
 <p>✨✨ 欢迎大家来到贝蒂大讲堂✨✨</p> 
 <p>🎈🎈养成好习惯，先赞后看哦~🎈🎈</p> 
 <p>所属专栏：<a href="http://t.csdnimg.cn/mF5s8" rel="nofollow">C++学习</a><br> 贝蒂的主页：<a href="https://blog.csdn.net/Bettysweetyaaa?type=lately">Betty’s blog</a></p> 
</blockquote> 
<h3><a id="_9"></a>前言需知：</h3> 
<p>本文中的代码及解释都是在<code>vs2022</code>下的<code>x86</code>程序中，涉及的指针都是<code>4bytes</code>。如果要其他平台下，部分代码需要改动。比如：如果是<code>x64</code>程序，则需要考虑指针是<code>8bytes</code>问题等等。</p> 
<h3><a id="1__13"></a>1. 多态的引入</h3> 
<h4><a id="11__15"></a>1.1. 多态的概念</h4> 
<p>通俗来说，多态就是多种形态，具体点就是去完成某个行为，<strong>当不同的对象去完成时会产生出不同的状态</strong>。举一个简单的例子：</p> 
<p>当我们去买票时，普通人买票时，是全价买票；学生买票时，是半价买票；军人买票时是优先买票。普通人，学生，军人虽然都属于人这类整体，但是在进行买票这个行为时却会发生不同的状态。这就是一种典型的多态行为。</p> 
<p><img src="https://images2.imgbox.com/c6/39/PXQVynaB_o.png" alt="img"></p> 
<h4><a id="12__23"></a>1.2. 多态的定义</h4> 
<p>在 C++ 中，<strong>多态</strong>指的是通过<strong>基类的指针</strong>或<strong>引用</strong>，在运行时能够调用派生类中实现的同名函数，从而表现出不同的行为。而构成多态一定要满足两个条件：</p> 
<blockquote> 
 <ol><li>必须通过基类的指针或者引用调用虚函数。</li><li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。</li></ol> 
</blockquote> 
<p>下面是一个简单的多态调用：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//虚函数</span>
	<span class="token punctuation">{<!-- --></span> 
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"买票-全价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//虚函数重写</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"买票-半价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span><span class="token comment">//基类引用调用</span>
<span class="token punctuation">{<!-- --></span> 
	p<span class="token punctuation">.</span><span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Person ps<span class="token punctuation">;</span>
	Student st<span class="token punctuation">;</span>
	<span class="token function">Func</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Func</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/01/b3/IDZkM726_o.png" alt="img"></p> 
<h3><a id="2__65"></a>2. 虚函数</h3> 
<h4><a id="21__67"></a>2.1. 虚函数的定义</h4> 
<p><strong>虚函数</strong>：即被<code>virtual</code>修饰的类成员函数称为虚函数。这里的<code>virtual</code>与虚继承的<code>virtual</code>毫无关系。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> 
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"买票-全价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="22__82"></a>2.2. 虚函数重写</h4> 
<p><strong>虚函数的重写(覆盖)</strong>：派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的<strong>返回值类型</strong>、<strong>函数名字</strong>、<strong>参数列表完全相同</strong>)，称子类的虚函数重写了基类的虚函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//虚函数</span>
	<span class="token punctuation">{<!-- --></span> 
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"买票-全价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//虚函数重写</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"买票-半价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><strong>注意</strong>：在重写基类虚函数时，派生类的虚函数不加virtual关键字，也可以构成重写。</li></ul> 
<h4><a id="23__107"></a>2.3. 虚函数重写的例外</h4> 
<ol><li><strong>协变</strong>：派生类重写基类虚函数时，与基类虚函数<strong>返回值类型不同</strong>。即<strong>基类虚函数返回基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用</strong>。这里的基类对象可以是可以来自自身的继承体系，也可以来源于其他继承体系。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//不同的继承</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> A<span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> 
		<span class="token keyword">return</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> B<span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//协变</span>
	<span class="token punctuation">{<!-- --></span> 
		<span class="token keyword">return</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol><li><strong>析构函数的重写</strong>：我们在前面学习继承时就知道编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成<code>destructor</code>，所以只要基类的析构函数加了<code>virtual</code>关键字，它就一定会形成重写。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//~Person()</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Person()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//构成重写</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Student()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Person<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> Person<span class="token punctuation">;</span>
	Person<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> Student<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p2<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f4/3a/l3CyZGdM_o.png" alt="img"></p> 
<p><strong>注意</strong>：如果不存在析构函数的重写，那么我们在释放子类对象时就可能造成内存泄漏。</p> 
<h4><a id="24__166"></a>2.4. 重载，重写(覆盖)，隐藏(重定义)的对比</h4> 
<p><img src="https://images2.imgbox.com/07/4d/FnslVwgf_o.jpg" alt="img"></p> 
<h3><a id="3__172"></a>3. 抽象类</h3> 
<p>在 C++ 中，抽象类是一种<strong>不能被实例化</strong>的类，它至少包含一个<strong>纯虚函数</strong>。而纯虚函数是一种特殊的虚函数，在类中只有声明，没有定义，其声明的形式为：</p> 
<p>virtual 返回值类型 函数名(参数列表) = 0;</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Car</span><span class="token comment">//抽象类</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//纯虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Benz</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Benz-舒适"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">BMW</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"BMW-操控"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Car<span class="token operator">*</span> pBenz <span class="token operator">=</span> <span class="token keyword">new</span> Benz<span class="token punctuation">;</span>
	pBenz<span class="token operator">-&gt;</span><span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Car<span class="token operator">*</span> pBMW <span class="token operator">=</span> <span class="token keyword">new</span> BMW<span class="token punctuation">;</span>
	pBMW<span class="token operator">-&gt;</span><span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>抽象类一般作为<strong>接口定义</strong>为派生类规定必须实现的方法，提供一个统一的接口规范。并且<strong>实现部分功能</strong>可以包含已实现的成员函数和数据成员，为派生类提供一些通用的功能和数据。</p> 
<h3><a id="4__211"></a>4. 静态多态与动态多态</h3> 
<blockquote> 
 <ol><li><strong>静态多态</strong>：在程序编译期间确定了程序的行为。比如：函数重载。</li><li><strong>动态多态</strong>：是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数。比如：多态。</li></ol> 
</blockquote> 
<h3><a id="5__216"></a>5. 多态的原理</h3> 
<h4><a id="51__218"></a>5.1. 虚函数表</h4> 
<p>首先让我们先看看下面这段代码：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//sizeof(Base)是多少？</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>通过观察测试我们发现<code>b</code>对象是8bytes，除了<code>_b</code>成员，还多一个<code>__vfptr</code>放在对象的前面(<strong>注意有些平台可能会放到对象的最后面，这个跟平台有关)</strong>，对象中的这个指针我们叫做<strong>虚函数表指针</strong>(v代表virtual，f代表function)。它指向的对象就是<strong>虚函数表</strong>，一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，虚函数表也简称<strong>虚表</strong>。</p> 
<p><img src="https://images2.imgbox.com/59/04/vic3PHWJ_o.png" alt="img"></p> 
<p>并且派生类继承了基类的虚函数，存在虚函数那就有虚函数表。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b9/94/VMUw6ScD_o.png" alt="img"></p> 
<p>我们也不难发现这时如果派生类并没有对基类进行重写，派生类与基类的虚函数表相同。</p> 
<h4><a id="52__261"></a>5.2. 虚函数表的特点</h4> 
<p>我们将以以下代码作为研究对象：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Func2()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Func3()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive::Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Func4()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol><li>**如果派生类对基类的虚函数进行重写，派生类的虚函数表会发生改变。**所以虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。重写是语法的叫法，覆盖是原理层的叫法。</li></ol> 
<p><img src="https://images2.imgbox.com/7f/b5/K7rwFdm1_o.png" alt="img"></p> 
<ol><li><strong>虚函数表本质是一个存虚函数指针的指针数组，一般情况这个数组最后面放了一个</strong><code>nullptr</code>。</li><li><strong>派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</strong>(但是不一定会在监视入口显示出来)</li></ol> 
<p>当然我们可以通过一个方法显示打印观察。因为虚函数指针的类型都是<code>void (*) ()</code>，并且最后一般都是以<code>nullptr</code>结尾。所以我们可以写一个打印虚函数表的程序：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>VF_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">printVFTable</span><span class="token punctuation">(</span>VF_PTR <span class="token operator">*</span>table<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"第%d个虚函数表的地址为:%p-&gt;"</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过函数指针调用函数</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Base b<span class="token punctuation">;</span>
	Derive d<span class="token punctuation">;</span>
	<span class="token comment">//需要取_vfptr的前4个字节(当然不同平台实现也有区别)</span>
	<span class="token function">printVFTable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>VF_PTR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">printVFTable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>VF_PTR<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6f/69/WdP69BJy_o.png" alt="img"></p> 
<p>从这里我们就可以看出虚函数<code>Func4</code>地址在VS编译器的监视窗口被隐藏了。</p> 
<h4><a id="53__335"></a>5.3. 多态的原理</h4> 
<p><img src="https://images2.imgbox.com/c6/d2/EXvHUVM4_o.png" alt="img"></p> 
<p>多态的原理简单来说就是<strong>通过对象里的虚函数表指针，去找到其对应的虚函数表，这是子类对象的虚指针就指向子类的虚函数表，父类对象的虚指针就指向父类的虚函数表，这样它们就能调到对应的虚函数</strong>，进而实现多态。</p> 
<p>现在我们再来看实现多态的两个条件：</p> 
<blockquote> 
 <p>第一个条件为什么要有虚函数的重写？</p> 
 <p>因为只有子类对父类的虚函数进行了重写，子类的虚函数表里面才会有自己重写后的地址，这样通过对象找到虚表的时候才能调到不同的函数，进而实现多态。</p> 
 <p>第二个条件为什么必须是父类的指针或引用去调用虚函数呢？</p> 
 <p>因为父类的指针和引用既可以指向子类对象，也可以指向父类对象啊，我们之前学过，它们之间是支持赋值转换的。</p> 
</blockquote> 
<p><strong>问题</strong>：<strong>为什么父类的对象不能实现多态？</strong></p> 
<blockquote> 
 <p>因为子类对象赋值给父类对象时，相应的虚函数表指针并不会拷贝过去，所以无论是通过子类还是父类都只能调用父类的虚函数。并且如果子类向父类赋值时，能将虚函数表指针一起赋值，那么我们在使用父类调用多态时，根本无法判断其调用的是父类还是子类的虚函数。</p> 
</blockquote> 
<h3><a id="6__357"></a>6. 多继承中的虚函数表</h3> 
<p>接下来让我们来探究多继承的虚函数表，我们以下面这段代码为例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base1</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base1::func1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base1::func2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> b1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Base2</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> 
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base2::func1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base2::func2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> b2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Base2</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive::func1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> 
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive::func3"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> d1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="61__403"></a>6.1. 虚函数表的个数</h4> 
<p>派生类继承了两个基类，并且基类都存在虚函数。所以有两个虚函数表。</p> 
<p><img src="https://images2.imgbox.com/84/49/KE0mvhav_o.png" alt="img"></p> 
<h4><a id="62__409"></a>6.2. 子类新增的虚函数存放在哪张续表</h4> 
<p>通过内存我们无法观察子类新增的虚函数<code>func3</code>存放在哪张虚函数表，这时我们可以通过打印观察：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>VF_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">printVFTable</span><span class="token punctuation">(</span>VF_PTR<span class="token operator">*</span> table<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"第%d个虚函数表的地址为:%p-&gt;"</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过函数指针调用函数</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derive d<span class="token punctuation">;</span>
	<span class="token function">printVFTable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>VF_PTR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token comment">//通过切片找到第二张虚函数表的存放位置</span>
	Base2<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
	<span class="token function">printVFTable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>VF_PTR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c6/50/s14PHFkR_o.png" alt="img"></p> 
<p>通过上述图像我们可以看出：<strong>多继承派生类的未重写的虚函数放在第一个继承基类部分的虚函数表中</strong>。</p> 
<h4><a id="63__440"></a>6.3. 同样重写的虚函数，为何在两张表的地址不同？</h4> 
<p><img src="https://images2.imgbox.com/5a/e8/L848cFbE_o.png" alt="img"></p> 
<p>通过上图我们发现，同样是调用子类的<code>func1</code>函数，为何地址会不同呢？我们可以以下代码分析的汇编：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derive d<span class="token punctuation">;</span>
	Base1<span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
	Base2<span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
	ptr1<span class="token operator">-&gt;</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ptr2<span class="token operator">-&gt;</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/12/55/8hEVciIL_o.png" alt="img"></p> 
<p>通过汇编我们发现<code>ptr2</code>调用<code>func1</code>只不过是中间绕了几步，最终调用的地址仍然是与<code>ptr1</code>相同的。那么为什么会这样呢？</p> 
<p><img src="https://images2.imgbox.com/63/77/N74ccZ5w_o.jpg" alt="img"></p> 
<blockquote> 
 <p>因为<code>ptr1</code>与<code>ptr2</code>形成多态调用，调用的是派生类<code>Derive</code>中的<code>func1</code>函数。但是派生类中<code>func1</code>的<code>this</code>指针为<code>Derive*</code>类型，指向的是<code>Derive</code>起始位置。所以要调用派生类中的<code>func1</code>函数，必须都先指向<code>Derive</code>的起始位置。而在继承中先声明的是<code>Base1</code>，所以<code>ptr1</code>恰好指向<code>Derive</code>的起始位置不需要调整，但<code>prt2</code>指向的是<code>Base2</code>所以需要调整。(汇编第三步<code>sub ecx 8</code>，在VS中<code>this</code>指针一般就存在<code>ecx</code>中，8bytes恰好是<code>Base1</code>的大小)</p> 
</blockquote> 
<h3><a id="7__466"></a>7. 菱形虚拟继承的虚函数表</h3> 
<p>我们先来看这么一段代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//必须自己重写func1</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">int</span> _d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里我们必须要在D中重写<code>func1</code>，因为虚继承之后A只有一份，如果BC都覆盖的话，就会有二义性，继承下来的A的虚函数表里面不知道是B重写的还是C重写。</p> 
<p>并且此时的虚函数表只有A这一份。</p> 
<p><img src="https://images2.imgbox.com/f9/fc/TcsTYCzt_o.png" alt="img"></p> 
<p>但是如果在派生类中添加几个虚函数，情况就会发生改变。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//必须自己重写func1</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">int</span> _d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/30/55/fRT3e132_o.png" alt="img"></p> 
<p>这时就有三张虚函数表。并且我们可以通过内存观察一下具体情况：</p> 
<p><img src="https://images2.imgbox.com/7d/07/iwGgfRoe_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/a0/1e/GGFpI9WS_o.png" alt="img"></p> 
<p>我们在学习继承的原理就已经明白第二行存放的是距离公共数据的偏移量，而第一行<code>fc ff ff ff</code>就是十进制的<code>-4</code>，也就是距离虚函数表指针的偏移量。</p> 
<p>通过这么一简单的介绍，我们就发现菱形虚拟的繁琐与复杂。所以在实际运用中，尽量少写菱形继承、菱形虚拟继承。</p> 
<h3><a id="8__569"></a>8. 易错解析</h3> 
<h4><a id="81__571"></a>8.1. 易错一</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> 
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A-&gt;"</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B-&gt;"</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出？？</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>首先派生类B继承了派生类A的<code>test</code>函数，但是<code>test</code>函数中的<code>this指针</code>并不会改变，类型仍是<code>A*</code>，并且<code>func</code>函数也在派生类中完成了重写，所以调用<code>func</code>时形成多态，最终会调用派生类中的<code>func</code>函数。但是答案会是<strong>B-&gt;0</strong>吗？</p> 
<p><img src="https://images2.imgbox.com/5a/e7/uINFnOTZ_o.png" alt="img"></p> 
<p>为什么会出现这种情况呢？我们就得先分辨清楚<strong>接口继承</strong>与<strong>实现继承</strong>。</p> 
<blockquote> 
 <p>普通函数的继承是一种实现继承，派生类继承了基类的成员函数，可以使用该函数，<strong>继承的是函数的实现</strong>。虚函数的继承是一种接口继承，<strong>派生类继承的是基类虚函数的接口</strong>，目的是为了重写，达成多态，继承的是接口所以如果不实现多态，最后不要把函数定义成虚函数。</p> 
</blockquote> 
<p>所以派生类中的<code>func</code>函数接口仍是基类的函数接口，所以<code>val=1</code>。</p> 
<h4><a id="82__613"></a>8.2. 易错二</h4> 
<ol><li><strong>内联函数可以是虚函数吗？</strong></li></ol> 
<blockquote> 
 <p><strong>可以</strong>。虽然说内联函数会在编译时展开，并不会建立函数栈帧，也自然不会形成地址，也就无法形成虚函数表，但是内联说明只是向编译器发送的一个请求，编译器可以选择忽略。</p> 
</blockquote> 
<ol start="2"><li><strong>静态成员可以是虚函数吗？</strong></li></ol> 
<blockquote> 
 <p><strong>不可以</strong>。静态成员函数没有<code>this</code>指针，使用类型::成员函数就可以调用。但是这种方式并不能访问虚函数表，因为访问虚函数表都是多态的情况下通过<strong>对象</strong>调用虚函数的方式访问的，所以静态成员函数的地址不会放进虚函数表。</p> 
</blockquote> 
<ol start="3"><li><strong>构造函数可以是虚函数吗？</strong></li></ol> 
<blockquote> 
 <p><strong>不可以</strong>，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的。而虚函数多态调用需要到虚函数表中招，但是这时虚函数表指针还未初始化。</p> 
</blockquote> 
<ol start="4"><li><strong>析构函数可以是虚函数吗</strong></li></ol> 
<blockquote> 
 <p>**可以，**因为基类与派生类的析构函数都会被编译器统一处理成<code>destructor</code>。为了防止内存泄漏，最好将析构函数定义成虚函数。</p> 
</blockquote> 
<ol start="5"><li><strong>对象访问普通函数快还是虚函数更快？</strong></li></ol> 
<blockquote> 
 <p>首先如果是普通对象，是一样快的。如果是指针对象或者是引用对象，则调用的普通函数快，因为构成多态，运行时调用虚函数需要到虚函数表中去查找 。</p> 
</blockquote> 
<ol start="6"><li><strong>虚函数表是在什么阶段生成的，存在哪的？</strong></li></ol> 
<blockquote> 
 <p>虚函数表是在编译阶段就生成的，一般情况下存在代码段(常量区)的。（编译过程中的汇编阶段会生成符号表，此时就可以确定函数的地址。)</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f6955fc6b967bcae3656a0b509250b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTTP背后的故事：理解现代网络如何工作的关键（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f155bbdefd5fc5e56f220267fcc4e815/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在VScode下配置C/C&#43;&#43;环境(tasks.json、launch.json、c_cpp_properties.json)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>