<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Stable Diffusion文生图技术详解：从零基础到掌握CLIP模型、Unet训练和采样器迭代 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a9f51e6250bbe3c997b129b29b8b9bf7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Stable Diffusion文生图技术详解：从零基础到掌握CLIP模型、Unet训练和采样器迭代">
  <meta property="og:description" content="文章目录 概要Stable Diffusion 底层结构与原理文本编码器（Text Encoder）图片生成器（Image Generator） 那扩散过程发生了什么？stable diffusion 总体架构主要模块分析Unet 网络采样器迭代CLIP 模型 小结 概要 Stable Diffusion 是一种先进的潜在扩散模型（Latent Diffusion Model），它在深度学习和概率建模领域具有开创性意义。它能够根据文本描述生成高质量、细节丰富的图像，并在图像修复、图像绘制、文本到图像转换和图像到图像转换等任务中表现出色。这种模型由 CompVis、Stability AI 和 LAION 的研究人员在 2022 年发布，其技术提出者 StabilityAI 公司在同年完成了 1.01 亿美元的融资，估值现已超过 10 亿美元。
Stable Diffusion 底层结构与原理 稳定扩散（Stable Diffusion）的底层结构与原理涉及到深度学习和概率建模的领域，尤其是生成模型的研究。以下是稳定扩散的一些基本原理：
稳定过程（Stable Process）： 稳定扩散的核心概念之一是稳定过程。稳定过程是一类随机过程，其性质在一定条件下对于加法运算是稳定的。这意味着稳定过程的和仍然遵循相同的分布。在稳定扩散中，这个过程用于逐步生成数据，每一步都是通过添加具有稳定分布的随机变量来改变数据分布。
随机变量的迭代： 稳定扩散的生成过程涉及到对初始噪声进行迭代。初始噪声通常是从简单的分布中生成的，例如标准正态分布。然后，通过多个迭代步骤，每一步都会引入稳定分布的随机变量，逐渐改变数据分布。
生成模型架构： 稳定扩散通常是在生成模型的框架下实现的。生成模型是一类深度学习模型，用于学习数据的分布，并生成具有相似分布的新样本。在稳定扩散中，生成模型的架构可能采用了类似于生成对抗网络（GANs）的结构，其中包括生成器和判别器。
训练过程： 训练稳定扩散模型涉及到通过样本数据来学习模型参数，使得模型能够逐步生成与样本数据相似的数据。这可能包括通过最大似然估计等方法来优化模型参数。
数值方法： 由于稳定扩散涉及到对复杂分布的逐步生成，其中可能包括数值方法来有效地处理和优化生成过程。这可能包括数值稳定性的考虑和一些近似方法。
Stable Diffusion 技术是 Diffusion 模型的改进版本，它通过引入潜在向量空间（Latent Vector Space）来解决传统 Diffusion 模型在速度和效率上的瓶颈。这项技术不仅可以专门用于文本生成图像（Text-to-Image）任务，还可以广泛应用于图像生成图像（Image-to-Image）、特定角色生成、图像超分辨率（Super-Resolution）以及图像上色等多个计算机视觉领域。
下图是一个基本的文生图流程，把中间的 Stable Diffusion 结构看成一个黑盒，那黑盒输入是一个文本串“paradise(天堂)、cosmic(广阔的)、beach(海滩)”，利用这项技术，输出了最右边符合输入要求的生成图片，图中产生了蓝天白云和一望无际的广阔海滩。
Stable Diffusion 核心思想是通过利用文本中包含的图像分布信息，将一张纯噪声的图片逐步去噪，最终生成一张与文本描述相匹配的高质量图像。这一过程的关键在于将人类可读的文本信息转换为机器可理解的数字表示，并使用这些数字表示来指导图像生成的过程。
文本编码器（Text Encoder） 在 Stable Diffusion 系统中，文本编码器（Text Encoder）是第一个关键模块。它的主要任务是将人类输入的文字字符串转换为计算机能够理解的数字表示，即语义向量（Semantic Vector）。文本编码器通常使用预训练的语言模型，如 CLIP（Contrastive Language-Image Pre-training），来理解文本的含义，并将其转换为一系列具有输入文字信息的语义向量。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-07T22:12:51+08:00">
    <meta property="article:modified_time" content="2024-04-07T22:12:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Stable Diffusion文生图技术详解：从零基础到掌握CLIP模型、Unet训练和采样器迭代</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">概要</a></li><li><a href="#Stable_Diffusion__4" rel="nofollow">Stable Diffusion 底层结构与原理</a></li><li><ul><li><a href="#Text_Encoder_25" rel="nofollow">文本编码器（Text Encoder）</a></li><li><a href="#Image_Generator_29" rel="nofollow">图片生成器（Image Generator）</a></li></ul> 
   </li><li><a href="#_44" rel="nofollow">那扩散过程发生了什么？</a></li><li><a href="#stable_diffusion__53" rel="nofollow">stable diffusion 总体架构</a></li><li><a href="#_78" rel="nofollow">主要模块分析</a></li><li><ul><li><a href="#Unet__79" rel="nofollow">Unet 网络</a></li><li><a href="#_132" rel="nofollow">采样器迭代</a></li><li><a href="#CLIP__170" rel="nofollow">CLIP 模型</a></li></ul> 
   </li><li><a href="#_188" rel="nofollow">小结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>概要</h3> 
<p>Stable Diffusion 是一种先进的潜在扩散模型（Latent Diffusion Model），它在深度学习和概率建模领域具有开创性意义。它能够根据文本描述生成高质量、细节丰富的图像，并在图像修复、图像绘制、文本到图像转换和图像到图像转换等任务中表现出色。这种模型由 CompVis、Stability AI 和 LAION 的研究人员在 2022 年发布，其技术提出者 StabilityAI 公司在同年完成了 1.01 亿美元的融资，估值现已超过 10 亿美元。</p> 
<h3><a id="Stable_Diffusion__4"></a>Stable Diffusion 底层结构与原理</h3> 
<p>稳定扩散（Stable Diffusion）的底层结构与原理涉及到深度学习和概率建模的领域，尤其是生成模型的研究。以下是稳定扩散的一些基本原理：</p> 
<p><strong>稳定过程（Stable Process）</strong>： 稳定扩散的核心概念之一是稳定过程。稳定过程是一类随机过程，其性质在一定条件下对于加法运算是稳定的。这意味着稳定过程的和仍然遵循相同的分布。在稳定扩散中，这个过程用于逐步生成数据，每一步都是通过添加具有稳定分布的随机变量来改变数据分布。</p> 
<p><strong>随机变量的迭代</strong>： 稳定扩散的生成过程涉及到对初始噪声进行迭代。初始噪声通常是从简单的分布中生成的，例如标准正态分布。然后，通过多个迭代步骤，每一步都会引入稳定分布的随机变量，逐渐改变数据分布。</p> 
<p><strong>生成模型架构</strong>： 稳定扩散通常是在生成模型的框架下实现的。生成模型是一类深度学习模型，用于学习数据的分布，并生成具有相似分布的新样本。在稳定扩散中，生成模型的架构可能采用了类似于生成对抗网络（GANs）的结构，其中包括生成器和判别器。</p> 
<p><strong>训练过程</strong>： 训练稳定扩散模型涉及到通过样本数据来学习模型参数，使得模型能够逐步生成与样本数据相似的数据。这可能包括通过最大似然估计等方法来优化模型参数。</p> 
<p><strong>数值方法</strong>： 由于稳定扩散涉及到对复杂分布的逐步生成，其中可能包括数值方法来有效地处理和优化生成过程。这可能包括数值稳定性的考虑和一些近似方法。</p> 
<p>Stable Diffusion 技术是 Diffusion 模型的改进版本，它通过引入潜在向量空间（Latent Vector Space）来解决传统 Diffusion 模型在速度和效率上的瓶颈。这项技术不仅可以专门用于文本生成图像（Text-to-Image）任务，还可以广泛应用于图像生成图像（Image-to-Image）、特定角色生成、图像超分辨率（Super-Resolution）以及图像上色等多个计算机视觉领域。</p> 
<p>下图是一个基本的文生图流程，把中间的 Stable Diffusion 结构看成一个黑盒，那黑盒输入是一个文本串“paradise(天堂)、cosmic(广阔的)、beach(海滩)”，利用这项技术，输出了最右边符合输入要求的生成图片，图中产生了蓝天白云和一望无际的广阔海滩。</p> 
<p><img src="https://images2.imgbox.com/10/2f/l47iPEG3_o.png" alt="在这里插入图片描述"><br> Stable Diffusion 核心思想是通过利用文本中包含的图像分布信息，将一张纯噪声的图片逐步去噪，最终生成一张与文本描述相匹配的高质量图像。这一过程的关键在于将人类可读的文本信息转换为机器可理解的数字表示，并使用这些数字表示来指导图像生成的过程。</p> 
<h4><a id="Text_Encoder_25"></a>文本编码器（Text Encoder）</h4> 
<p>在 Stable Diffusion 系统中，文本编码器（Text Encoder）是第一个关键模块。它的主要任务是将人类输入的文字字符串转换为计算机能够理解的数字表示，即语义向量（Semantic Vector）。文本编码器通常使用预训练的语言模型，如 CLIP（Contrastive Language-Image Pre-training），来理解文本的含义，并将其转换为一系列具有输入文字信息的语义向量。</p> 
<h4><a id="Image_Generator_29"></a>图片生成器（Image Generator）</h4> 
<p>图片信息生成器是 stable diffusion 和 diffusion 模型的区别所在，也是性能提升的关键，有两点区别：</p> 
<p>① 图片信息生成器的输入输出均为低维图片向量（不是原始图片），对应上图里的粉色 44 方格。同时文本编码器的语义向量作为图片信息生成器的控制条件，把图片信息生成器输出的低维图片向量进一步输入到后续的图片解码器（黄色）生成图片。（注：原始图片的分辨率为 512512，有RGB 三通道，可以理解有 RGB 三个元素组成，分别对应红绿蓝；低维图片向量会降低到 64*64 维度）</p> 
<p>② Diffusion 模型一般都是直接生成图片，不会有中间生成低维向量的过程，需要更大计算量，在计算速度和资源利用上都比不过 stable diffusion；</p> 
<p>那低维空间向量是如何生成的？是在图片信息生成器里由一个 Unet 网络和一个采样器算法共同完成，在 Unet 网络中一步步执行生成过程，采样器算法控制图片生成速度，下面会在第三部分详细介绍这两个模块。Stable Diffusion 采样推理时，生成迭代大约要重复 30~50 次，低维空间变量在迭代过程中从纯噪声不断变成包含丰富语义信息的向量，图片信息生成器里的循环标志也代表着多次迭代过程。</p> 
<p><strong>图像解码器（Image Decoder）</strong></p> 
<p>图像解码器（Image Decoder）是图片生成器的第二个子模块，它接收潜在空间生成器输出的潜在空间向量作为输入，并使用升维技术将潜在空间向量转换为实际的图像。图像解码器通常使用反卷积（Deconvolution）或转置卷积（Transposed Convolution）等操作来逐渐增加图像的分辨率，最终生成一张高质量的图像。</p> 
<p>通过将文本编码器和图片生成器有机地组合在一起，Stable Diffusion 技术能够根据文本描述生成多样化、高质量的图像，为计算机视觉和自然语言处理等领域的研究和应用提供了新的思路和工具。</p> 
<h3><a id="_44"></a>那扩散过程发生了什么？</h3> 
<p>扩散过程发生在图片信息生成器中，把初始纯噪声隐变量输入到 Unet 网络后结合语义控制向量，重复 30~50 次来不断去除纯噪声隐变量中的噪声，并持续向隐向量中注入语义信息，就可以得到一个具有丰富语义信息的隐空间向量（右下图深粉方格）。采样器负责统筹整个去噪过程，按照设计模式在去噪不同阶段中动态调整 Unet 去噪强度。</p> 
<p>更直观看一下，如下图所示，通过把初始纯噪声向量和最终去噪后的隐向量都输到后面的图片解码器，观察输出图片区别。从下图可以看出，纯噪声向量由于本身没有任何有效信息，解码出来的图片也是纯噪声；而迭代 50 次去噪后的隐向量已经耦合了语义信息，解码出来也是一张包含语义信息的有效图片。<br> <img src="https://images2.imgbox.com/b1/55/RSPwhXvL_o.png" alt="在这里插入图片描述"></p> 
<p>到这里，我们大致介绍了 Stable Diffusion 是什么以及各个模块思路，并且简单介绍了 stable diffusion 的扩散过程。第三部分我们继续分析各个重要组成模块的运行机制，更深入理解 Stable Diffusion 工作原理。</p> 
<h3><a id="stable_diffusion__53"></a>stable diffusion 总体架构</h3> 
<p>以下是从零基础角度介绍Stable Diffusion技术思路，主要聚焦于Stable Diffusion的文生图技术，并详细阐述其三个核心模块：CLIP模型、Unet训练和采样器迭代。</p> 
<p>训练阶段和采样阶段的总体框架如下图所示：<br> <img src="https://images2.imgbox.com/4e/82/ukvLijQ3_o.png" alt="在这里插入图片描述"></p> 
<p><strong>训练阶段</strong></p> 
<p>包含了图里 PART1 CLIP 模型和 PART2 Unet 训练，分成三步：</p> 
<ol><li>用 AutoEncoderKL 自编码器把输入图片从像素空间映射到隐向量空间，把 RGB 图片转换到隐式向量表达。其中，在训练 Unet 时自编码器参数已经训练好和固定的，自编码器把输入图片张量进行降维得到隐向量。</li><li>用 FrozenCLIPEmbedder 文本编码器来编码输入提示词 Prompt，生成向量表示 context，这里需要规定文本最大编码长度和向量嵌入大小。</li><li>对输入图像的隐式向量施加不同强度噪声，再把加噪后隐向量输入到 UNetModel 来输出预估噪声，和真实噪声信息标签作比较来计算 KL 散度 loss，并通过反向传播算法更新 UNetModel 模型参数；引入文本向量 context 后，UNetModel 在训练时把其作为 condition，利用注意力机制来更好地引导图像往文本向量方向生成；</li></ol> 
<p><strong>采样阶段</strong></p> 
<p>包含了图里 PART1 CLIP 模型和 PART3 采样器迭代，分成三步：</p> 
<ol><li>用 FrozenCLIPEmbedder 文本编码器把输入提示词 Prompt 进行编码，生成维度为[B, K, E]的向量表示 context，与训练阶段的第 2 步一致。</li><li>利用随机种子随机产出固定维度的噪声隐空间向量，利用训练好的 UNetModel 模型，结合不同采样器（如 DDPM/DDIM/PLMS）迭代 T 次不断去除噪声，得到具有文本信息的隐向量表征。</li><li>用 AutoEncoderKL 自编码器把上面得到的图像隐向量进行解码，得到被映射到像素空间的生成图像。</li></ol> 
<p>上面对 stable diffusion 总体架构进行了介绍，那接下来进一步分析介绍下每个重要组成模块，分别是 Unet 网络、采样器和 CLIP 模型三个主要模块。</p> 
<h3><a id="_78"></a>主要模块分析</h3> 
<h4><a id="Unet__79"></a>Unet 网络</h4> 
<p>Stable Diffusion 里采用的 UNetModel 模型，采用 Encoder-Decoder 结构来预估噪声，网络结构如下图<br> <img src="https://images2.imgbox.com/93/7c/S9AGRyQa_o.png" alt="在这里插入图片描述"></p> 
<p>模型输入包括 3 个部分，<br> (1) 图像表示，用隐空间向量输入的维度为[B, Z, H/8, W/8]。<br> (2) timesteps 值，维度为[B, ]。<br> (3) 文本向量表示 context，维度为[B, K, E]。</p> 
<p>其中[B, Z, H, W]分别表示[batch_size 图片数，C 隐空间通道数，height 长度，weight 宽度]，K 和 E 分别表示文本最大编码长度 max length 和向量嵌入大小。</p> 
<p>模型使用 DownSample 和 UpSample 进行样本的下上采样，在采样模块之间还有黑色虚线框的 ResBlock 和 SpatialTransformer，分别接收 timesteps 信息和提示词信息（这里只画出一次作为参考）。</p> 
<p>ResBlock 模块的输入有：<br> ① 来自上一个模块的输入和<br> ②timesteps 对应的嵌入向量 timestep_emb（维度为[B, 4*M]，M 为可配置参数）。</p> 
<p>SpatialTransformer 模块的输入有：<br> ① 来自上一个模块的输入<br> ② 提示词 Prompt 文本的嵌入表示 context，以 context 为注意力机制里的 condition，学习提示词 Prompt 和图像的匹配程度。</p> 
<p>最后，UNetModel 不改变输入和输出大小，隐空间向量的输入输出维度均为[B, Z, H/8, W/8]。</p> 
<p><strong>ResBlock 网络</strong></p> 
<p>ResBlock 网络，有两个输入分别是<br> ① 来自上一个模块的输入<br> ②timesteps 对应的嵌入向量 timestep_emb（维度为[B, 4*M]，M 为可配置参数）</p> 
<p>网络结构图如下所示。<br> <img src="https://images2.imgbox.com/bf/45/m7yi7fIQ_o.png" alt="在这里插入图片描述"><br> timestep_embedding 的生成方式，用的是“Attention is All you Need”论文的 Transformer 方法，通过 sin 和 cos 函数再经过两个 Linear 进行变换。</p> 
<p><strong>SpatialTransformer 结构</strong></p> 
<p>SpatialTransformer 这里，包含模块比较多，有两个输入分别是：<br> ① 来自上一个模块的输入和<br> ② 提示词 Prompt 文本的嵌入表示 context 作为 condition<br> 两者使用 cross attention 进行建模。</p> 
<p>其中，SpatialTransformer 里面的注意力模块 CrossAttention 结构，把图像向量作为 Query，文本表示 context 作为 Key&amp;Value，利用 Cross Attention 模块来学习图像和文本对应内容的相关性。</p> 
<p>注意力模块的作用是，当输入提示词来生成图片时，比如输入 “一匹马在吃草”，由于模型已经能捕捉图文相关性以及文本中的重点信息，当看到 “马”时，注意力机制会重点突出图像“马”的生成；当看到“草”时，注意力机制会重点突出图像 “草” 的生成，进而实现和文本匹配的图片生成。<br> <img src="https://images2.imgbox.com/88/53/CPqqYww3_o.png" alt="在这里插入图片描述"><br> <strong>Unet 如何训练？</strong></p> 
<p>Stable Diffusion 里面 Unet 的学习目标是什么？简单来说就是去噪。那在为去噪任务设计训练集时，就可以通过向普通照片添加噪声来得到训练样本。具体来说，对于下面这张照片，用 random 函数生成从强到弱的多个强度噪声，比如下图 0~3 有 4 个强度的噪声。训练时把噪声强度和加噪后图片输入到 Unet，计算预测噪声图和真正噪声图之间的误差损失，通过反向传播更新 unet 参数。</p> 
<p><img src="https://images2.imgbox.com/39/72/H8bszzHr_o.png" alt="图8 去噪训练样本说明"></p> 
<p>训练好 Unet 后，如下图 所示，从加噪图片中推断出噪声后，就可以用加噪图减掉噪声来恢复原图；重复这个过程，第一步预测噪声图后再减去噪声图，用更新后的加噪图进行第二步去噪，最终就能得到一张很清晰的生成图片。由于使用了高斯分布的 KL 散度损失，Unet 生成图片实际上是接近训练集分布的，和训练集有着相同像素规律。也就是说，使用真实场景的写实训练集去训练模型，它的结果就会具有写实风格，尽量符合真实世界规律。<br> <img src="https://images2.imgbox.com/92/97/PVXK5MmJ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_132"></a>采样器迭代</h4> 
<p>这部分介绍下采样阶段中扩散模型如何多次迭代去除噪声，进而得到生成图片的潜在空间表示。提到采样器，要从最基础的采样器 DDPM（Denoising Diffusion Probabilistic Models）进行介绍[4]。DDPM 推导有点复杂，这里就用朴素一点的大白话结合几个关键公式来理清推导思路。</p> 
<p>1、扩散模型的思路是，训练时先在图片上不断加噪来破坏图片，推理时对加噪后的图片去噪来恢复出原始图片。训练过程的 T 次迭代中，可推导出一个重要特性：任意时刻的 Xt 可以由 X0 和 β 表示，任意时刻的 X0 也可以由 Xt 和噪声 z 求得。</p> 
<p><img src="https://images2.imgbox.com/ee/fc/VfvwYGZA_o.png" alt="在这里插入图片描述"></p> 
<p>其中，第一行里 a 和 β 可以描述噪声强度；第二行，X0 为初始的干净图片，增加噪声 z 后生成加噪图片 Xt，后个公式由前个公式变换而来，表示加噪图片减去一定强度噪声，得到图片 X0。</p> 
<p>2、问题变成，如何求逆向阶段的分布，即给定了一张加噪后图片，如何才能求得前一时刻没有被破坏得那么严重的略清晰图片。经过论文里的一顿推导，又得出两个重要结论：</p> 
<p>① 逆向过程也服从高斯分布<br> ② 在知道原始清晰图片时，能通过贝叶斯公式把逆向过程转换成前向过程，进而算出逆向过程分布。</p> 
<p>在公式上体现如下：<br> <img src="https://images2.imgbox.com/39/6d/bYTC4PjY_o.png" alt="在这里插入图片描述"></p> 
<p>其中，第一行指的是给定 X0 情况下，逆向过程也服从高斯分布，并且利用贝叶斯公式把逆向过程转换成前向过程，前向过程是不断加噪的过程，可以被计算；第二行指的是，Xt 和 X0 由于可以相互转换，从公式上看，均值也可以从 Xt 减去不同噪声得到。</p> 
<p>3、算出逆向过程分布后，就可以训练一个模型尽量拟合这个分布，而且模型预估结果也应该服从高斯分布：</p> 
<p><img src="https://images2.imgbox.com/b6/7f/I8vMoz8N_o.png" alt="在这里插入图片描述"></p> 
<p>其中，求均值公式里只包含 Xt 和噪声，由于 Xt 在训练时已知，那只需要得到模型输出的预估噪声，该值可由模型用 Xt 和 t 预估得到。</p> 
<p>4、把逆向过程分布（也就是 Label 值）和模型的预估分布做比较，由于 ①KL 散度可以用来描述两个分布之间的差异和 ② 多元高斯分布的 KL 散度有闭式解，经过一番推导发现损失函数变成计算两个高斯分布的 KL 散度。<br> <img src="https://images2.imgbox.com/65/06/NyQn0xQG_o.png" alt="在这里插入图片描述"><br> 其中，q 分布是逆向过程分布，p 是模型预估分布，训练损失是求两个高斯分布的 KL 散度，即两个分布之间的差距。</p> 
<p>5、DDPM 训练过程和采样过程的伪代码如下图所示。由于 DDPM 的高质量生成依赖于较大的 T（一般为 1000 以上），导致 Diffusion 前向过程特别缓慢，因此后续进一步有了 DDIM、PLMS 和 Euler A 等一些优化版采样器。<br> <img src="https://images2.imgbox.com/8b/23/qgqEgtYM_o.png" alt="在这里插入图片描述"><br> 其中，训练阶段实际上是求真实噪声和模型预估噪声的 MSE 误差，再对 Loss 求导反向传播来训练模型；采样阶段，求得均值和方差后，采用重参数技巧来生成样本。</p> 
<p>扩散模型采样阶段是对加噪后图片去噪来恢复出原始图片<br> ① 任意时刻的图片均可以由原始图片和噪声表示<br> ② 逆向过程的图片参数符合高斯分布，优化目标转化为计算逆向分布和预估分布的 KL 散度差异，并在采样阶段使用重参数技巧来生成图片。</p> 
<h4><a id="CLIP__170"></a>CLIP 模型</h4> 
<p>在前面有提到，提示词 Prompt 文本利用文本模型转换成嵌入表示 context，作为 Unet 网络的 condition 条件。那问题来了，语义信息和图片信息属于两种模态，怎么用 attention 耦合到一起呢？这里介绍下用于提取语义信息的 CLIP 模型。</p> 
<p>语义信息的好坏直接影响到了最终生成图片的多样性和可控性，那像 CLIP 这样的语言模型是如何训练出来的？是如何结合文本串和计算机视觉的呢？首先，要有一个具有文本串和计算机视觉配对的数据集。CLIP 模型所使用的训练集达到了 4 亿张，通过从网络上爬取图片及相应的标签或者注释。</p> 
<p>CLIP 模型结构包含一个图片 encoder 和一个文字 encoder，类似于推荐场景常用到的经典双塔模型。</p> 
<ul><li> <p>训练时，从训练集随机取出一些样本（图片和标签配对的话就是正样本，不匹配的话就是负样本），CLIP 模型的训练目标是预测图文是否匹配；</p> </li><li> <p>取出文字和图片后，用图片 encoder 和文字 encoder 分别转换成两个 embedding 向量，称作图片 embedding 和文字 embedding；</p> </li><li> <p>用余弦相似度来比较两个 embedding 向量相似性，并根据标签和预测结果的匹配程度计算损失函数，用来反向更新两个 encoder 参数。</p> </li><li> <p>在 CLIP 模型完成训练后，输入配对的图片和文字，这两个 encoder 就可以输出相似的 embedding 向量，输入不匹配的图片和文字，两个 encoder 输出向量的余弦相似度就会接近于 0。</p> </li></ul> 
<p>推理时，输入文字可以通过一个 text encoder 转换成 text embedding，也可以把图片用 image encoder 转换成 image embedding，两者就可以相互作用。在生成图片的采样阶段，把文字输入利用 text encoder 转换成嵌入表示 text embedding，作为 Unet 网络的 condition 条件。<br> <img src="https://images2.imgbox.com/fb/6b/KoWatUYO_o.png" alt="图10 CLIP模型结构示意图"></p> 
<h3><a id="_188"></a>小结</h3> 
<p>`<br> AI 绘画各种应用不断涌现，目前有关 Stable Diffusion 的文章主要偏向应用介绍，对于 Stable Diffusion 技术逻辑的介绍还是比较少。这篇文章主要介绍了 Stable Diffusion 技术结构和各个重要组成模块的基本原理，希望能够让大家了解 Stable Diffusion 是如何运行的，才能更好地控制 AI 绘画生成。AI 绘画虽然还面临一些技术挑战，但随着技术不断迭代和发展，相信 AI 能够在更多领域发挥出惊喜生产力。</p> 
<p><a href="https://sanlangcode.com/?p=1747" rel="nofollow">参考文章</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf6034401243d489f1d477ad30e840f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【小红书笔试题汇总】[全网首发]2024-04-07-小红书春招笔试题-三语言题解(CPP/Python/Java)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1da23dc222f1f67db80dc98d563188f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">真实对比kimi、通义千问、文心一言的写代码能力，到底谁强？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>