<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>重生之我们在ES顶端相遇第5章-常用字段类型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/79bdcbd8e191524367e8ddd0ea587bf3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="重生之我们在ES顶端相遇第5章-常用字段类型">
  <meta property="og:description" content="思维导图 前置 在第4章，我们提到了 keyword（一笔带过）。在本章，我们将介绍 ES 的字段类型。全面的带大家了解 ES 各个字段类型的使用场景。
字段类型 ES 支持以下字段类型（仅介绍开发中常用，更多内容请自行阅读 官方文档）。
Keyword 基本介绍 手动设置字段类型为 keyword
PUT /test3 { &#34;mappings&#34;: { &#34;properties&#34;: { &#34;tags&#34;: { &#34;type&#34;: &#34;keyword&#34; } } } } 写入数据
PUT /test3/_doc/1 { &#34;tags&#34;: &#34;hello world&#34; } keyword 其实就是字符串，输入什么，存储就是什么。
适用场景 keyword 适用于 排序、聚合、term(精确查询) 查询场景中。
例如
GET /test3/_search { &#34;query&#34;: { &#34;term&#34;: { &#34;tags&#34;: { &#34;value&#34;: &#34;hello&#34; } } } } 查询优化 有 2 个对查询优化重要的点：
数字类型(int, long)如果不需要使用范围查询，则建议设置为 keywordterm 查询在 keyword 上的搜索速度总是快于数字类型。 Text 基本介绍 与 keyword 相对的则是 text。在第三章，我们介绍了全文搜索 match 的用法。你可能会好奇，为啥默认写入的数据就可以使用全文搜索。因为当输入是无规则字符串时，字段类型就是 text。（别着急，默认的字段类型，一会我们就会详细介绍）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-20T11:25:05+08:00">
    <meta property="article:modified_time" content="2024-07-20T11:25:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">重生之我们在ES顶端相遇第5章-常用字段类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>思维导图</h4> 
<p><img src="https://images2.imgbox.com/ac/2d/MhPB0tvy_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_2"></a>前置</h4> 
<p>在第4章，我们提到了 <code>keyword</code>（一笔带过）。在本章，我们将介绍 ES 的字段类型。全面的带大家了解 ES 各个字段类型的使用场景。</p> 
<h4><a id="_6"></a>字段类型</h4> 
<p>ES 支持以下字段类型（仅介绍开发中常用，更多内容请自行阅读 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.0/mapping-types.html" rel="nofollow">官方文档</a>）。</p> 
<h5><a id="Keyword_10"></a>Keyword</h5> 
<h6><a id="_12"></a>基本介绍</h6> 
<p>手动设置字段类型为 <code>keyword</code></p> 
<pre><code>PUT /test3
{
  "mappings": {
    "properties": {
      "tags": {
        "type": "keyword"
      }
    }
  }
}
</code></pre> 
<p>写入数据</p> 
<pre><code>PUT /test3/_doc/1
{
  "tags": "hello world"
}
</code></pre> 
<p><code>keyword</code> 其实就是字符串，输入什么，存储就是什么。</p> 
<h6><a id="_36"></a>适用场景</h6> 
<p><code>keyword</code> 适用于 排序、聚合、<code>term(精确查询)</code> 查询场景中。<br> 例如</p> 
<pre><code>GET /test3/_search
{
  "query": {
    "term": {
      "tags": {
        "value": "hello"
      }
    }
  }
}
</code></pre> 
<h6><a id="_52"></a>查询优化</h6> 
<p>有 2 个对查询优化重要的点：</p> 
<ol><li>数字类型(int, long)如果不需要使用范围查询，则建议设置为 keyword</li><li>term 查询在 keyword 上的搜索速度总是快于数字类型。</li></ol> 
<h5><a id="Text_59"></a>Text</h5> 
<h6><a id="_61"></a>基本介绍</h6> 
<p>与 keyword 相对的则是 text。在第三章，我们介绍了全文搜索 match 的用法。你可能会好奇，为啥默认写入的数据就可以使用全文搜索。因为当输入是无规则字符串时，字段类型就是 text。（别着急，默认的字段类型，一会我们就会详细介绍）</p> 
<p>手动设置字段类型为 <code>text</code></p> 
<pre><code># 先删除索引
DELETE test3

PUT /test3
{
  "mappings": {
    "properties": {
      "tags": {
        "type": "text"
      }
    }
  }
}
</code></pre> 
<h6><a id="_81"></a>适用场景</h6> 
<p>text 适用场景：全文搜索<br> text 字段会对输入进行分词。<br> 例如</p> 
<pre><code>PUT /test3/_doc/1
{
  "tags": "hello world"
}
</code></pre> 
<p>tags 会被分词存储为 hello、world 2个词。<br> 当然，具体被分词为什么，其实跟我们设置的分词器有关（后续讲解，这里先有个概念）。</p> 
<h6><a id="_95"></a>不适用场景</h6> 
<p>text 不适用场景：排序、聚合、脚本。<br> 如果你在 text 字段上，进行排序、聚合，或者脚本操作，都会收到以下异常。<br> <code>Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [name] in order to load field data by uninverting the inverted index. Note that this can use significant memory.</code></p> 
<p>例如：</p> 
<pre><code>GET /test3/_search
{
  "sort": [
    {
      "tags": {
        "order": "desc"
      }
    }
  ]
}

# 聚合
GET /test3/_search
{
  "size": 0,
  "aggs": {
    "popular_tags": {
      "terms": {
        "field": "tags"
      }
    }
  }
}

# 脚本操作
GET /test3/_search
{
  "query": {
    "script": {
      "script": "doc['tags'].value == 'hello'"
    }
  }
}
</code></pre> 
<h6><a id="illegal_argument_exception__137"></a>illegal_argument_exception 异常解决方式</h6> 
<p>要解决该异常，有2种方法</p> 
<ol><li>使用多字段类型,即在该字段上面再建一个 keyword 类型(强烈建议)</li></ol> 
 
<pre><code>DELETE test3

PUT test3
{
  "mappings": {
    "properties": {
      "tags": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      }
    }
  }
}
</code></pre> 
<p>排序、聚合时，则使用 <code>tags.keyword</code>。需要全文索引时，依然可以使用 <code>tags</code> 字段。</p> 
<pre><code>GET /test3/_search
{
  "sort": [
    {
      "tags.keyword": {
        "order": "desc"
      }
    }
  ]
}
</code></pre> 
<ol start="2"><li>text 字段上启用 <code>fielddata</code>(不建议！不建议！不建议！)</li></ol> 
 
<pre><code>DELETE test3

PUT /test3/_mapping
{
  "properties": {
    "tags": {
      "type": "text",
       "fielddata": true
    }
  }
}
</code></pre> 
<p>PS：在 text 字段上启用 fielddata，会消耗非常大的内存！！！</p> 
<h5><a id="Date_194"></a>Date</h5> 
<p>手动指定字段类型为 <code>date</code></p> 
<pre><code>PUT /test3
{
  "mappings": {
    "properties": {
      "ctime": {
        "type": "date"
      }
    }
  }
}
</code></pre> 
<p>未指定 <code>format</code> 参数时，默认的值为 <code>strict_date_optional_time||epoch_millis</code><br> 该默认值接收以下数据</p> 
<pre><code># 秒时间戳
PUT /test3/_doc/1
{
  "ctime": 1721135125
}
# 毫秒时间戳
PUT /test3/_doc/2
{
  "ctime": 1721135125000
}
# datetime
PUT /test3/_doc/3
{
  "ctime":"2024-07-16T12:10:30Z"
}
# date
PUT /test3/_doc/4
{
  "ctime": "2024-07-15"
}

# 对数据排序
GET test3/_search
{
  "sort": { "ctime": "asc"} 
}
</code></pre> 
<h6><a id="format__239"></a>format 参数</h6> 
<p>我们可以手动指定允许的数据格式。例如</p> 
<pre><code>PUT /test3
{
  "mappings": {
    "properties": {
      "ctime": {
        "type": "date",
        "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis||epoch_second"
      }
    }
  }
}
</code></pre> 
<h6><a id="_255"></a>存储时间仅为秒时间戳</h6> 
<p>如果时间为秒时间戳，可以考虑使用 <code>epoch_second</code></p> 
<pre><code>PUT my-index-000001
{
  "mappings": {
    "properties": {
      "ctime": {
        "type":   "date",
        "format": "strict_date_optional_time||epoch_second"
      }
    }
  }
}

PUT /test3/_doc/1
{
  "ctime": 1721135125
}

# 以下查询，时间会被格式化
GET test3/_search
{
  "fields": [ {"field": "ctime"}]
}
</code></pre> 
<h5><a id="_282"></a>数字类型</h5> 
<p>在复习一下，如果不需要范围查询，建议使用 <code>keyword</code> 存储(后续在进阶篇会讲原理)。</p> 
<h6><a id="scaled_float_286"></a>scaled_float</h6> 
<p>ES 除了支持常见的数字类型。如：<code>long、integer、short、byte、double、float</code><br> 还针对浮点数，有一个优化的类型 <code>scaled_float</code>。<br> 如果我们能够得知我们的浮点数最多有多少个小数点。使用该类型，在空间存储上会比浮点数更好。</p> 
<pre><code>PUT /test3
{
  "mappings": {
    "properties": {
      "sf": {
        "type": "scaled_float",
        "scaling_factor": 100
      }
    }
  }
}
</code></pre> 
<p>上面的意思为：存储时，* 100。即，将浮点数变为整数。</p> 
<h5><a id="Boolean_306"></a>Boolean</h5> 
<pre><code>PUT /test3
{
  "mappings": {
    "properties": {
      "enable": {
        "type": "boolean"
      }
    }
  }
}
</code></pre> 
<ul><li>false, “false”, “” (empty string) 均被认为是 false</li><li>true, “true” 均被认为是 true</li></ul> 
 
<pre><code>POST /test3/_doc
{
  "enable": false
}
POST /test3/_doc
{
  "enable": "false"
}
POST /test3/_doc
{
  "enable": ""
}
POST /test3/_doc
{
  "enable": true
}
POST /test3/_doc
{
  "enable": "true"
}

GET /test3/_search
{
  "query": {
    "term": {
      "enable": {
        "value": false
      }
    }
  }
}
</code></pre> 
<h5><a id="Object_356"></a>Object</h5> 
<p>写入一个 manager 对象</p> 
<pre><code>PUT test3/_doc/1
{ 
  "region": "US",
  "manager": { 
    "age":     30,
    "name": { 
      "first": "John",
      "last":  "Smith"
    }
  }
}
</code></pre> 
<p>在 ES 内部，该文档被索引为一个简单的键值对列表，大致如下</p> 
<pre><code>{
  "region":             "US",
  "manager.age":        30,
  "manager.name.first": "John",
  "manager.name.last":  "Smith"
}
</code></pre> 
<p>例如，我们可以查询 <code>manager.age=30</code> 的文档</p> 
<pre><code>GET /test3/_search
{
  "query": {
    "term": {
      "manager.age": {
        "value": 30
      }
    }
  }
}
</code></pre> 
<p>上述文档的显式映射如下</p> 
<pre><code>PUT /test3
{
  "mappings": {
    "properties": { 
      "region": {
        "type": "keyword"
      },
      "manager": { 
        "properties": {
          "age":  { "type": "integer" },
          "name": { 
            "properties": {
              "first": { "type": "text" },
              "last":  { "type": "text" }
            }
          }
        }
      }
    }
  }
}
</code></pre> 
<h5><a id="Array_418"></a>Array</h5> 
<ol><li>不支持混合数据类型的数组</li></ol> 
 
<pre><code>POST /test3/_doc
{
  "arr": ["12", 12, false]
}
</code></pre> 
<ol start="2"><li>无法查询数组中的每个对象</li></ol> 
 
<pre><code>PUT test3/_doc/1
{
  "group" : "fans",
  "user" : [ 
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}

# 查询 user.first=Alice &amp; user.last=White。你可能会使用以下写法，但实际上并不能正确工作

GET test3/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "Alice" }},
        { "match": { "user.last":  "Smith" }}
      ]
    }
  }
}
</code></pre> 
<p>如果你的索引结构是这么设计的，并且有这样的需求，可能需要考虑下如何做优化了。例如，将表铺平。</p> 
<p>PS：虽然 <code>nested</code> 嵌套类型可以解决该问题，但开发中会尽可能的把数据结构铺平，从而避免使用 <code>nested</code> 嵌套类型。这里不对 <code>nested</code> 过多介绍，因为开发中真的很不推荐使用。</p> 
<ol start="3"><li>开发中仅推荐基本数据类型数组，不推荐对象数组，如果你有第2 点描述的查询需求</li></ol> 
 
<pre><code>PUT test3
{
  "mappings": {
    "properties": {
      "arr": {
        "type": "keyword"
      }
    }
  }
}

PUT test3/_doc/1
{
  "arr": ["1", "2", "3"]
}

GET test3/_search
{
  "query": {
    "term": {
      "arr": {
        "value": "1"
      }
    }
  }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc702420e21817133b287178d2213887/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">web学习笔记（八十二）uniapp</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/150447e5f59b921d460da9f72417b6be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">控制欲过强的Linux小进程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>