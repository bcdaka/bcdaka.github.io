<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线程池的创建以及工作原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a49d416c105e4b200d0b5280c0ba6d78/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="线程池的创建以及工作原理">
  <meta property="og:description" content="先说说线程池的作用
避免创建过多的线程时引发的内存溢出问题。因为创建线程还是比较耗内存的，通常来说创建一个线程会默认分配1M的内存。
线程池的主要优势：
降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
一、如何创建线程池 线程池的创建方法总共有 7 种，但总体来说可分为 2 类：
一类是通过 ThreadPoolExecutor 创建的线程池；
另一个类是通过 Executors 创建的线程池。
线程池的创建方式总共包含以下 7 种（其中 6 种是通过 Executors 创建的，1 种是通过ThreadPoolExecutor 创建的）：
Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池；Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。ThreadPoolExecutor：最原始的创建线程池的方式，它包含了 7 个参数可供设置 ThreadPoolExecutor 参数介绍
ThreadPoolExecutor 最多可以设置 7 个参数，如下代码所示：
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { // 省略... } 7 个参数代表的含义如下：
参数 1：corePoolSize
核心线程数，线程池中始终存活的线程数。
参数 2：maximumPoolSize
最大线程数，线程池中允许的最大线程数，当线程池的任务队列满了之后可以创建的最大线程数。
参数 3：keepAliveTime
最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。
参数 4：unit:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-14T09:14:01+08:00">
    <meta property="article:modified_time" content="2024-08-14T09:14:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线程池的创建以及工作原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>先说说线程池的作用</strong><br> 避免创建过多的线程时引发的内存溢出问题。因为创建线程还是比较耗内存的，通常来说创建一个线程会默认分配1M的内存。</p> 
<p><strong>线程池的主要优势：</strong></p> 
<p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p> 
<h2>一、如何创建线程池</h2> 
<p><strong>线程池的创建方法总共有 7 种，但总体来说可分为 2 类：</strong></p> 
<p><strong>一类是通过 ThreadPoolExecutor 创建的线程池；<br> 另一个类是通过 Executors 创建的线程池。</strong></p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/5d/3a/agCdxl1t_o.png" width="1058"></p> 
<p>线程池的创建方式总共包含以下 7 种（其中 6 种是通过 Executors 创建的，1 种是通过ThreadPoolExecutor 创建的）：</p> 
<ol><li>Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；</li><li>Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；</li><li>Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；</li><li>Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池；</li><li>Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；</li><li>Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</li><li>ThreadPoolExecutor：最原始的创建线程池的方式，它包含了 7 个参数可供设置</li></ol> 
<p><strong>ThreadPoolExecutor 参数介绍</strong></p> 
<p>ThreadPoolExecutor 最多可以设置 7 个参数，如下代码所示：</p> 
<pre><code class="language-java"> public ThreadPoolExecutor(int corePoolSize,
                           int maximumPoolSize,
                           long keepAliveTime,
                           TimeUnit unit,
                           BlockingQueue&lt;Runnable&gt; workQueue,
                           ThreadFactory threadFactory,
                           RejectedExecutionHandler handler) {
     // 省略...
 }</code></pre> 
<p>7 个参数代表的含义如下：</p> 
<p><strong>参数 1：corePoolSize</strong><br> 核心线程数，线程池中始终存活的线程数。</p> 
<p><strong>参数 2：maximumPoolSize</strong><br> 最大线程数，线程池中允许的最大线程数，当线程池的任务队列满了之后可以创建的最大线程数。</p> 
<p><strong>参数 3：keepAliveTime</strong><br> 最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。</p> 
<p><strong>参数 4：unit:</strong><br> 单位是和参数 3 存活时间配合使用的，合在一起用于设定线程的存活时间 ，参数 keepAliveTime 的时间单位有以下 7 种可选：</p> 
<p>TimeUnit.DAYS：天<br> TimeUnit.HOURS：小时<br> TimeUnit.MINUTES：分<br> TimeUnit.SECONDS：秒<br> TimeUnit.MILLISECONDS：毫秒<br> TimeUnit.MICROSECONDS：微妙<br> TimeUnit.NANOSECONDS：纳秒<br><strong>参数 5：workQueue</strong><br> 一个阻塞队列，用来存储线程池等待执行的任务，均为线程安全，它包含以下 7 种类型：</p> 
<p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。<br> LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。<br> SynchronousQueue：一个不存储元素的阻塞队列，即直接提交给线程不保持它们。<br> PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。<br> DelayQueue：一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素。<br> LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。与SynchronousQueue类似，还含有非阻塞方法。<br> LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。<br> 较常用的是 LinkedBlockingQueue 和 Synchronous，线程池的排队策略与 BlockingQueue有关。</p> 
<p><strong>参数 6：threadFactory</strong><br> 线程工厂，主要用来创建线程，默认为正常优先级、非守护线程。</p> 
<p><strong>参数 7：handler</strong><br> 拒绝策略，拒绝处理任务时的策略，系统提供了 4 种可选：</p> 
<p>AbortPolicy：拒绝并抛出异常。<br> CallerRunsPolicy：使用当前调用的线程来执行此任务。<br> DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。<br> DiscardPolicy：忽略并抛弃当前任务。<br> 默认策略为 AbortPolicy。</p> 
<p><strong>拒绝策略是怎么进行的</strong></p> 
<p><strong>1. AbortPolicy（中止策略）</strong></p> 
<ul><li><strong>工作原理</strong>：当任务被拒绝时，它会直接抛出<code>RejectedExecutionException</code>异常。这是线程池默认的拒绝策略。</li><li><strong>适用场景</strong>：适用于那些不允许任务丢失或任务非常关键的场景。但是，必须确保能够妥善处理抛出的异常，否则可能会中断当前执行流程，影响后续任务。</li></ul> 
<p><strong>2. CallerRunsPolicy（调用者运行策略）</strong></p> 
<ul><li><strong>工作原理</strong>：当任务被拒绝时，如果线程池没有关闭，则这个任务会由调用它的线程（即提交任务的线程）来执行。</li><li><strong>适用场景</strong>：适用于并发量不是特别大，且对性能要求不是特别高的场景。但是，如果任务提交速度过快，可能会导致调用线程被阻塞，从而影响性能。</li></ul> 
<p><strong>3. DiscardPolicy（丢弃策略）</strong></p> 
<ul><li><strong>工作原理</strong>：当任务被拒绝时，它会被默默地丢弃，不会有任何异常或错误抛出。</li><li><strong>适用场景</strong>：适用于那些任务可以丢弃、对结果不敏感的场景。但是，使用这种策略需要谨慎，因为它可能会导致重要任务的丢失。</li></ul> 
<p><strong>4. DiscardOldestPolicy（丢弃最旧策略）</strong></p> 
<ul><li><strong>工作原理</strong>：当任务被拒绝时，如果线程池没有关闭，它会丢弃工作队列中等待最久的任务，然后尝试再次提交当前任务。</li><li><strong>适用场景</strong>：适用于那些可以容忍部分任务被丢弃，但希望保留新提交的任务的场景。然而，这种策略可能会破坏任务的顺序性。</li></ul> 
<h2>二、线程池的工作原理</h2> 
<p><img alt="" height="653" src="https://images2.imgbox.com/17/4f/ax2ZN81V_o.png" width="720"></p> 
<p>上图是一张线程池工作的精简图，实际的过程比这个要复杂的多，不过这些应该能够完全覆盖到线程池的整个工作流程了。</p> 
<p>整个过程可以拆分成以下几个部分：</p> 
<h5><a name="t9"></a>1、提交任务</h5> 
<p>当向线程池提交一个新的任务时，线程池有三种处理情况，分别是：创建一个工作线程来执行该任务、将任务加入阻塞队列、拒绝该任务。</p> 
<p>提交任务的过程也可以拆分成以下几个部分：</p> 
<ul><li> <p>当工作线程数小于核心线程数时，直接创建新的核心工作线程</p> </li><li> <p>当工作线程数不小于核心线程数时，就需要尝试将任务添加到阻塞队列中去</p> </li><li> <p>如果能够加入成功，说明队列还没有满，那么需要做以下的二次验证来保证添加进去的任务能够成功被执行</p> </li><li> <p>验证当前线程池的运行状态，如果是非RUNNING状态，则需要将任务从阻塞队列中移除，然后拒绝该任务</p> </li><li> <p>验证当前线程池中的工作线程的个数，如果为0，则需要主动添加一个空工作线程来执行刚刚添加到阻塞队列中的任务</p> </li><li> <p>如果加入失败，则说明队列已经满了，那么这时就需要创建新的“临时”工作线程来执行任务</p> </li><li> <p>如果创建成功，则直接执行该任务</p> </li><li> <p>如果创建失败，则说明工作线程数已经等于最大线程数了，则只能拒绝该任务了</p> </li></ul> 
<p>整个过程可以用下面这张图来表示：</p> 
<p><img alt="" height="715" src="https://images2.imgbox.com/b2/b1/ZRAt7YtX_o.png" width="682"></p> 
<h5><a name="t10"></a>2、创建工作线程</h5> 
<p>创建工作线程需要做一系列的判断，需要确保当前线程池可以创建新的线程之后，才能创建。</p> 
<p>首先，当线程池的状态是 SHUTDOWN 或者 STOP 时，则不能创建新的线程。</p> 
<p>另外，当线程工厂创建线程失败时，也不能创建新的线程。</p> 
<p>还有就是当前工作线程的数量与核心线程数、最大线程数进行比较，如果前者大于后者的话，也不允许创建。</p> 
<p>除此之外，会尝试通过 CAS 来自增工作线程的个数，如果自增成功了，则会创建新的工作线程，即 Worker 对象。</p> 
<p>然后加锁进行二次验证是否能够创建工作线程，最后如果创建成功，则会启动该工作线程。</p> 
<h5><a name="t11"></a>3、启动工作线程</h5> 
<p>当工作线程创建成功后，也就是 Worker 对象已经创建好了，这时就需要启动该工作线程，让线程开始干活了，Worker 对象中关联着一个 Thread，所以要启动工作线程的话，只要通过 worker.thread.start() 来启动该线程即可。</p> 
<p>启动完了之后，就会执行 Worker 对象的 run 方法，因为 Worker 实现了 Runnable 接口，所以本质上 Worker 也是一个线程。</p> 
<p>通过线程 start 开启之后就会调用到 Runnable 的 run 方法，在 worker 对象的 run 方法中，调用了 runWorker(this) 方法，也就是把当前对象传递给了 runWorker 方法，让他来执行。</p> 
<h5><a name="t12"></a>4、获取任务并执行</h5> 
<p>在 runWorker 方法被调用之后，就是执行具体的任务了，首先需要拿到一个可以执行的任务，而 Worker 对象中默认绑定了一个任务，如果该任务不为空的话，那么就是直接执行。</p> 
<p>执行完了之后，就会去阻塞队列中获取任务来执行，而获取任务的过程，需要考虑当前工作线程的个数。</p> 
<ul><li> <p>如果工作线程数大于核心线程数，那么就需要通过 poll 来获取，因为这时需要对闲置的线程进行回收；</p> </li><li> <p>如果工作线程数小于等于核心线程数，那么就可以通过 take 来获取了，因此这时所有的线程都是核心线程，不需要进行回收，前提是没有设置 allowCoreThreadTimeOut</p> </li></ul> 
<h2>三、阻塞队列的工作原理</h2> 
<p>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：</p> 
<p>1.当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</p> 
<p class="img-center"><img alt="" height="304" src="https://images2.imgbox.com/57/74/zKaD8fXZ_o.png" width="311"></p> 
<p><br> 2.当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</p> 
<p class="img-center"><img alt="" height="297" src="https://images2.imgbox.com/8a/82/QZTOJt9t_o.png" width="429"></p> 
<p><br> 阻塞队列的主要方法</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p>方法类型</p> </td><td> <p>抛出异常</p> </td><td> <p>特殊值</p> </td><td> <p>阻塞</p> </td><td> <p>超时</p> </td></tr><tr><td> <p>插入</p> </td><td> <p>add(e)</p> </td><td> <p>offer(e)</p> </td><td> <p>put(e)</p> </td><td> <p>offer(e,time,unit)</p> </td></tr><tr><td> <p>移除</p> </td><td> <p>remove()</p> </td><td> <p>poll()</p> </td><td> <p>take()</p> </td><td> <p>poll(time,unit)</p> </td></tr><tr><td> <p>检查</p> </td><td> <p>element()</p> </td><td> <p>peek()</p> </td><td> <p>不可用</p> </td><td> <p>不可用</p> </td></tr></tbody></table> 
<p>抛出异常：抛出一个异常；</p> 
<p>特殊值：返回一个特殊值（null 或 false,视情况而定）</p> 
<p>则塞：在成功操作之前，一直阻塞线程</p> 
<p>超时：放弃前只在最大的时间内阻塞</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5295c0e0e4e14071a7edea143b5bfc0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">重头开始嵌入式第十九天（Linux系统编程 文件IO）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cacb0e7fdf0983383821311c5f5dd29a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WPF中XAML相对路径表示方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>