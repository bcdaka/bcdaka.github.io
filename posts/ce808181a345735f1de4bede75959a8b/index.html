<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】计数排序 &amp; 排序系列所有源代码 &amp; 复杂度分析（终章） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ce808181a345735f1de4bede75959a8b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】计数排序 & 排序系列所有源代码 & 复杂度分析（终章）">
  <meta property="og:description" content="目录
一，计数排序
1，基本思想
2，思路实现
3，计数排序的特性总结：
二，排序算法复杂度及稳定性分析
三，排序系列所有源代码
Sort.h
Sort.c
Stack.h
Stack.c
一，计数排序 计数排序也叫非比较排序；
1，基本思想 计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用
操作步骤：
1，统计相同元素出现次数
2，根据统计的结果将序列回收到原来的序列中
图解原理：
对这样一个不需要比较的排序就完成了；
2，思路实现 // 计数排序 void CountSort(int* arr, int n) { int i = 0; int max = arr[0], min = arr[0]; //找最大，最小值 for (i = 0; i &lt; n; i&#43;&#43;) { if (arr[i] &gt; max) { max = arr[i]; } if (arr[i] &lt; min) { min = arr[i]; } } //空间大小 int sum = max - min &#43; 1; //开辟空间并且使元素值都为0 int* arr1 = (int*)calloc(sum, sizeof(int)); //给新数组赋值 for (i = 0; i &lt; n; i&#43;&#43;) { arr1[arr[i] - min]&#43;&#43;; } int j = 0; //回收到原来的序列中 for (i = 0; i &lt; sum; i&#43;&#43;) { while (arr1[i]--) { arr[j&#43;&#43;] = i &#43; min; } } } 然后我们运行测试一下：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-09T09:09:21+08:00">
    <meta property="article:modified_time" content="2023-10-09T09:09:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】计数排序 &amp; 排序系列所有源代码 &amp; 复杂度分析（终章）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" rel="nofollow">一，计数排序</a></p> 
<p id="1%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#1%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">1，基本思想</a></p> 
<p id="2%EF%BC%8C%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2%EF%BC%8C%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0" rel="nofollow">2，思路实现</a></p> 
<p id="3%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">3，计数排序的特性总结：</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%EF%BC%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90" rel="nofollow">二，排序算法复杂度及稳定性分析</a></p> 
<p id="%E4%B8%89%EF%BC%8C%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97%E6%89%80%E6%9C%89%E6%BA%90%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E4%B8%89%EF%BC%8C%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97%E6%89%80%E6%9C%89%E6%BA%90%E4%BB%A3%E7%A0%81" rel="nofollow">三，排序系列所有源代码</a></p> 
<p id="Sort.h-toc" style="margin-left:80px;"><a href="#Sort.h" rel="nofollow">Sort.h</a></p> 
<p id="Sort.c-toc" style="margin-left:80px;"><a href="#Sort.c" rel="nofollow">Sort.c</a></p> 
<p id="Stack.h-toc" style="margin-left:80px;"><a href="#Stack.h" rel="nofollow">Stack.h</a></p> 
<p id="Stack.c-toc" style="margin-left:80px;"><a href="#Stack.c" rel="nofollow">Stack.c</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/14/9b/XrUNJe4b_o.png" width="166"></p> 
<p></p> 
<h3 id="%E4%B8%80%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">一，计数排序</h3> 
<blockquote> 
 <p><strong>计数排序也叫非比较排序；</strong></p> 
</blockquote> 
<h4 id="1%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><strong>1，基本思想</strong></h4> 
<p>计数排序又称为<strong>鸽巢原理</strong>，是对<strong>哈希直接定址法</strong>的变形应用</p> 
<p><strong>操作步骤</strong>：</p> 
<p><strong>1</strong>，统计相同元素出现<strong>次数</strong></p> 
<p><strong>2</strong>，根据统计的结果将<strong>序列回收到原来的序列中</strong></p> 
<p><strong>图解原理：</strong></p> 
<p><img alt="" height="945" src="https://images2.imgbox.com/e9/9e/HTTUyhsK_o.png" width="1200"></p> 
<p><strong>对这样一个不需要比较的排序就完成了；</strong></p> 
<p></p> 
<h4 id="2%EF%BC%8C%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0">2，思路实现</h4> 
<pre><code class="language-cpp">// 计数排序
void CountSort(int* arr, int n)
{
	int i = 0;
	int max = arr[0], min = arr[0];
	//找最大，最小值
	for (i = 0; i &lt; n; i++)
	{
		if (arr[i] &gt; max)
		{
			max = arr[i];
		}
		if (arr[i] &lt; min)
		{
			min = arr[i];
		}
	}
	//空间大小
	int sum = max - min + 1;
	//开辟空间并且使元素值都为0
	int* arr1 = (int*)calloc(sum, sizeof(int));
	//给新数组赋值
	for (i = 0; i &lt; n; i++)
	{
		arr1[arr[i] - min]++;
	}
	int j = 0;
	//回收到原来的序列中
	for (i = 0; i &lt; sum; i++)
	{
		while (arr1[i]--)
		{
			arr[j++] = i + min;
		}
	}
}</code></pre> 
<p><strong>然后我们运行测试一下：</strong></p> 
<p><img alt="" height="298" src="https://images2.imgbox.com/64/fa/OoVOiuV5_o.png" width="1200"></p> 
<p>可以看到是有序的，选择排序就<strong> OK</strong> 了；</p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/89/ce/patt29ry_o.png" width="150"></p> 
<h4 id="3%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A">3，计数排序的特性总结：</h4> 
<p>1， 计数排序在<strong>数据范围集中时</strong>，效率很高，但是适<strong>用范围及场景有限</strong></p> 
<p>2.，时间复杂度：<strong>O(N+K)</strong></p> 
<p>3， 空间复杂度：<strong>O(N)</strong></p> 
<p>4, 稳定性：<strong>稳定</strong></p> 
<h3></h3> 
<h3 id="%E4%BA%8C%EF%BC%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90">二，排序算法复杂度及稳定性分析</h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>排序方法</td><td>平均情况</td><td>最好情况</td><td>最坏情况</td><td>辅助空间</td><td>稳定性</td></tr><tr><td>冒泡排序</td><td>O(N^2)</td><td>O(N)</td><td>O(N^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(N^2)    </td><td>O(N^2) </td><td>O(N^2) </td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(N^2) </td><td>O(N)</td><td>O(N^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(NlongN)~O(N^2)</td><td>O(N^1.3)</td><td>O(N^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(NlongN)</td><td>O(NlongN)</td><td>O(NlongN)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(NlongN)</td><td>O(NlongN)</td><td>O(NlongN)</td><td>O(N)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(NlongN)</td><td>O(NlongN)</td><td>O(N^2)</td><td>O(N)</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(N+K)</td><td>O(N+K)</td><td>O(N+K)</td><td>O(K)</td><td>稳定</td></tr></tbody></table> 
<p></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/2f/62/FN8sv8CF_o.png" width="150"></p> 
<h3 id="%E4%B8%89%EF%BC%8C%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97%E6%89%80%E6%9C%89%E6%BA%90%E4%BB%A3%E7%A0%81">三，排序系列所有源代码</h3> 
<h4 id="Sort.h">Sort.h</h4> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
#include"Stack.h"

//打印
void PrintSort(int* arr, int n);

//插入排序
void InsertSort(int* arr, int n);

//希尔排序
void HillSort(int* arr, int n);

//选择排序
void SeleSort(int* arr, int n);

//堆排序
void HeapSort(int* arr, int n);
//向下调整
void DownAdjust(int* arr, int n, int i);

冒泡排序
//void BubblSort(int* arr, int n);

//快速排序
void QuickSort(int* arr, int begin, int end);
//三数取中
int middle(int* arr, int left, int right);
//快慢指针法
int PartSort3(int* arr, int left, int right);
//挖坑法
int PartSort2(int* arr, int left, int right);
//霍尔排序
int PartSort1(int* arr, int left, int right);
//快速排序(非递归)
void QuickNon(int* arr, int begin, int end);

//归并排序
void MergerSort(int* arr, int begin, int end);

//归并排序(非递归)
void MergerSortNon(int* arr, int begin, int end);


// 计数排序
void CountSort(int* arr, int n);
</code></pre> 
<h4 id="Sort.c">Sort.c</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Sort.h"

//打印
void PrintSort(int* arr, int n)
{
	int i = 0;
	for (i = 0; i &lt; n; i++)
	{
		printf("%d ", arr[i]);
	}
}

//交换
void Swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

//插入排序
void InsertSort(int* arr, int n)
{
	int i = 0;
	for (i = 0; i &lt; n-1; i++)
	{
		int end = i;
		int tmp = arr[end + 1];
		while (end &gt;= 0)
		{
			if (arr[end] &gt;= tmp)
			{
				//交换
				Swap(&amp;arr[end], &amp;arr[end+1]);
				end--;
			}
			else
			{
				break;
			}
		}
		arr[end + 1] = tmp;
	}
}

//希尔排序
void HillSort(int* arr, int n)
{
	int gap = n;
	int i = 0;
	while (gap &gt; 1)
	{
		gap = gap / 2;
		for (i = 0; i &lt; n-gap; i++)
		{
			int end = i;
			int tmp = arr[end + gap];
			while (end &gt;= 0)
			{
				if (arr[end] &gt;= tmp)
				{
					//交换
					Swap(&amp;arr[end], &amp;arr[end + gap]);
					end -= gap;
				}
				else
				{
					break;
				}
			}
			arr[end + gap] = tmp;
		}
	}
}

//选择排序
void SeleSort(int* arr, int n)
{
	int begin = 0, end = n - 1;
	while (begin &lt; end)
	{
		int maxi = begin, mini = begin;
		for (int i = begin; i &lt;= end; i++)
		{
			if (arr[i] &gt; arr[maxi])
			{
				maxi = i;
			}
			if (arr[i] &lt; arr[mini])
			{
				mini = i;
			}
		}
		Swap(&amp;arr[begin], &amp;arr[mini]);
		// 如果maxi和begin重叠，修正一下即可
		if (begin == maxi)
		{
			maxi = mini;
		}
		Swap(&amp;arr[end], &amp;arr[maxi]);
		++begin;
		--end;
	}
}

//向下调整
void DownAdjust(int* arr, int n, int i)
{
	int perent = i;
	int child = perent* 2 + 1;
	while (child&lt;n)
	{
		if (child+1&lt;n &amp;&amp; arr[child + 1] &gt; arr[child])
		{
			child++;
		}
		if (arr[perent] &lt; arr[child])
		{
			//交换
			Swap(&amp;arr[perent], &amp;arr[child]);
			perent = child;
			child = perent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

//堆排序
void HeapSort(int* arr, int n)
{
	//建堆
	int i = 0;
	for (i = (n - 1 - 1) / 2; i &gt;= 0; i--)
	{
		//向下调整
		DownAdjust(arr, n, i);
	}
	//交换，删除排序法
	while (n &gt; 1)
	{
		//交换
		Swap(&amp;arr[0], &amp;arr[n - 1]);
		n--;
		//向下调整
		DownAdjust(arr, n, 0);
	}
}

//三数取中
int middle(int* arr, int left, int right)
{
	//int mid = (left +right)/ 2;
	//随机数取中
	int mid = left + (rand() % (right - left));
	if (arr[left] &lt; arr[mid])
	{
		if (arr[mid] &lt; arr[right])
		{
			return mid;
		}
		if (arr[left] &lt; arr[right])
		{
			return right;
		}
		else
		{
			return left;
		}
	}
	//arr[mid]&lt;=arr[left]
	else
	{
		if (arr[mid] &gt; arr[right])
		{
			return mid;
		}
		if (arr[left] &gt; arr[right])
		{
			return right;
		}
		else
		{
			return left;
		}
	}
}

//霍尔排序
int PartSort1(int* arr, int left, int right)
{
	//三数取中
	int ret = middle(arr, left, right);
	Swap(&amp;arr[left], &amp;arr[ret]);
	int keyi = left;
	while (left &lt; right)
	{
		//右边先走
		while (left&lt;right &amp;&amp; arr[right]&gt;=arr[keyi])
		{
			right--;
		}
		//左边后走
		while (left &lt; right &amp;&amp; arr[left] &lt;= arr[keyi])
		{
			left++;
		}
		//交换
		Swap(&amp;arr[left], &amp;arr[right]);
	}
	Swap(&amp;arr[left], &amp;arr[keyi]);
	return left;
}

//挖坑法
int PartSort2(int* arr, int left, int right)
{
	//三数取中
	int ret = middle(arr, left, right);
	Swap(&amp;arr[left], &amp;arr[ret]);
	int key = arr[left];
	int hole = left;
	while (left &lt; right)
	{
		while (left &lt; right &amp;&amp; arr[right] &gt;= key)
		{
			right--;
		}
		arr[hole] = arr[right];
		hole = right;
		while (left &lt; right &amp;&amp; arr[left] &lt;= key)
		{
			left++;
		}
		arr[hole] = arr[left];
		hole = left;
	}
	arr[hole] = key;
	return hole;
}

//前后指针法
int PartSort3(int* arr, int left, int right)
{
	//三数取中
	int ret = middle(arr, left, right);
	Swap(&amp;arr[left], &amp;arr[ret]);
	int keyi = left;
	int slow = left, fast = left+1;
	while (fast&lt;=right)
	{
		if (arr[fast] &lt; arr[keyi] &amp;&amp; ++slow!=fast)
		{
			//交换
			Swap(&amp;arr[fast], &amp;arr[slow]);
		}
		fast++;
	}
	Swap(&amp;arr[slow], &amp;arr[keyi]);
	return slow;
}

//插入排序(改造版)
void InsertSort1(int* arr, int left, int right)
{
	int i = 0;
	for (i = left; i &lt; right; i++)
	{
		int end = i;
		int tmp = arr[end + 1];
		while (end &gt;= 0)
		{
			if (arr[end] &gt;= tmp)
			{
				//交换
				Swap(&amp;arr[end], &amp;arr[end + 1]);
				end--;
			}
			else
			{
				break;
			}
		}
		arr[end + 1] = tmp;
	}
}

//快速排序
void QuickSort(int* arr, int begin, int end)
{
	srand(time(0));
	if (begin &gt;= end)
	{
		return NULL;
	}
	if (end - begin &lt;10)
	{
		InsertSort1(arr,begin,end);
	}
	else
	{
		int keyi = PartSort1(arr, begin, end);
		//排序[begin,keyi) &amp; [keyi+1,end]
		QuickSort(arr, begin, keyi);
		QuickSort(arr, keyi + 1, end);
	}
}

//快速排序(非递归)
void QuickNon(int* arr, int begin, int end)
{
	srand(time(0));
	ST ps;
	//初始化
	STInit(&amp;ps);
	if (begin &gt;= end)
	{
		return;
	}
	//插入
	STPush(&amp;ps, end);
	STPush(&amp;ps, begin);
	//栈不为空就进去
	while (!STEmpty(&amp;ps))
	{
		int left = STInsert(&amp;ps);//栈顶元素
		STPop(&amp;ps);//删除
		int right = STInsert(&amp;ps);
		STPop(&amp;ps);

		int keyi = PartSort1(arr, left, right);
		//排序[left,keyi-1] &amp; [keyi+1,right]
		if (keyi + 1 &lt; right)
		{
			//插入
			STPush(&amp;ps, right);
			STPush(&amp;ps, keyi + 1);
		}
		if (left &lt; keyi - 1)
		{
			//插入
			STPush(&amp;ps, keyi - 1);
			STPush(&amp;ps, left);
		}
	}
	//销毁
	STDestroy(&amp;ps);
}

//归并
void Merger(int* arr, int* tmp,int begin,int end)
{
	int mid = (begin + end) / 2;
	if (begin == end)
	{
		return;
	}
	//排序【begin,mid】&amp; 【mid+1,end】
	Merger(arr, tmp, begin,mid);
	Merger(arr, tmp, mid+1, end);

	int begin1 = begin, end1 = mid;
	int begin2 = mid + 1, end2 = end;
	int i = 0;
	while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
	{
		if (arr[begin1] &lt; arr[begin2])
		{
			tmp[i++] = arr[begin1++];
		}
		else
		{
			tmp[i++] = arr[begin2++];
		}
	}
	while(begin1 &lt;= end1)
	{
		tmp[i++] = arr[begin1++];
	}
	while (begin2 &lt;= end2)
	{
		tmp[i++] = arr[begin2++];
	}
	//进行拷贝
	memcpy(arr + begin, tmp, (end - begin+1)*sizeof(int));
}

//归并排序
void MergerSort(int* arr, int begin, int end)
{
	if (begin &gt;= end)
	{
		return;
	}
	//开辟同等大小数组
	int* tmp = (int*)malloc((end - begin + 1)*sizeof(int));
	//归并
	Merger(arr, tmp, begin, end);
	free(tmp);
	tmp = NULL;
}

//归并排序(非递归)
void MergerSortNon(int* arr, int begin, int end)
{
	if (begin &gt;= end)
	{
		return;
	}
	//开辟同等大小数组
	int* tmp = (int*)malloc((end - begin + 1) * sizeof(int));
	int gap = 1;
	int j = 0;
	while (gap &lt; end)
	{
		for (j = 0; j &lt; end; j += 2 * gap)
		{
			int begin1 = j, end1 = begin1+gap-1;
			int begin2 =end1+1, end2 = begin2+gap-1;
			int i = 0;
			//处理边界问题
			if (end1 &gt;= end)
			{
				break;
			}
			if (end2 &gt;end)
			{
				end2 = end;
			}
			while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
			{
				if (arr[begin1] &lt; arr[begin2])
				{
					tmp[i++] = arr[begin1++];
				}
				else
				{
					tmp[i++] = arr[begin2++];
				}
			}
			while (begin1 &lt;= end1)
			{
				tmp[i++] = arr[begin1++];
			}
			while (begin2 &lt;= end2)
			{
				tmp[i++] = arr[begin2++];
			}
			//进行拷贝
			memcpy(arr + j, tmp, (end2 - j+ 1) * sizeof(int));
		}
		gap *= 2;
	}
	free(tmp);
	tmp = NULL;
}

// 计数排序
void CountSort(int* arr, int n)
{
	int i = 0;
	int max = arr[0], min = arr[0];
	//找最大，最小值
	for (i = 0; i &lt; n; i++)
	{
		if (arr[i] &gt; max)
		{
			max = arr[i];
		}
		if (arr[i] &lt; min)
		{
			min = arr[i];
		}
	}
	//空间大小
	int sum = max - min + 1;
	//开辟空间并且使元素值都为0
	int* arr1 = (int*)calloc(sum, sizeof(int));
	//给新数组赋值
	for (i = 0; i &lt; n; i++)
	{
		arr1[arr[i] - min]++;
	}
	int j = 0;
	//回收到原来的序列中
	for (i = 0; i &lt; sum; i++)
	{
		while (arr1[i]--)
		{
			arr[j++] = i + min;
		}
	}
}</code></pre> 
<h4 id="Stack.h">Stack.h</h4> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int STDataType;
typedef struct StackTop
{
	STDataType* a;
	int top;
	int capacity;
}ST;

//初始化
void STInit(ST* ps);
//销毁
void STDestroy(ST* ps);
//插入
void STPush(ST* ps, STDataType x);
//删除
void STPop(ST* ps);
//返回栈顶
STDataType STInsert(ST* ps);
//数量
int STSize(ST* ps);
//判断是否为空
int STEmpty(ST* ps);
</code></pre> 
<h4 id="Stack.c">Stack.c</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Stack.h"

//初始化
void STInit(ST* ps)
{
	assert(ps);
	ps-&gt;a = NULL;
	ps-&gt;top = ps-&gt;capacity = 0;
}
//销毁
void STDestroy(ST* ps)
{
	assert(ps);
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;top = ps-&gt;capacity = 0;
}
//插入
void STPush(ST* ps, STDataType x)
{
	assert(ps);
	if (ps-&gt;top == ps-&gt;capacity)
	{
		ps-&gt;capacity = ps-&gt;top == 0 ? 4 : ps-&gt;capacity*2;
		ps-&gt;a = (STDataType*)realloc(ps-&gt;a,sizeof(STDataType)*ps-&gt;capacity);
	}
	ps-&gt;a[ps-&gt;top] = x;
	ps-&gt;top++;
}
//删除
void STPop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}
//返回栈顶
STDataType STInsert(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	return ps-&gt;a[ps-&gt;top-1];
}
//数量
int STSize(ST* ps)
{
	assert(ps);
	return ps-&gt;top;
}
//判断是否为空
int STEmpty(ST* ps)
{
	assert(ps);
	if (ps-&gt;top == 0)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}</code></pre> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/de/db/XnFZPTwa_o.png" width="150"></p> 
<p><strong>同志们！排序的知识就到这里了！</strong></p> 
<p><strong>后面博主会陆续更新；</strong></p> 
<p><strong>如有不足之处欢迎来补充交流！</strong></p> 
<p><strong>完结。。</strong></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/e5/05/s3fDgkFP_o.jpg" width="150"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e0bf73e290bb99003b820a8e4715bfb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter运行报错：系统找不到指定的路径</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b90917f2feb9497ff85e8f82dbe311c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL——使用mysqldump备份与恢复数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>