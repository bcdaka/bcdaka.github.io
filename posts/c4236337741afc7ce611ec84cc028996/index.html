<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【玩转python】入门篇day14-函数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c4236337741afc7ce611ec84cc028996/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【玩转python】入门篇day14-函数">
  <meta property="og:description" content="1、函数的定义 函数通过def定义，包括函数名、参数、返回值
# 定义函数 def test(a,b): # a,b表示形式参数 print(a &#43; b)#函数体(具体的功能) return a*b #返回值 # 函数调用 test(12,43) # 12和43表示实际参数,在调用函数时,会替换形式参数a,b 下面这个展示了稍微复杂的函数嵌套，执行test()的时候test函数中顺序先执行test1，输出‘9999’，然后接着执行print(&#34;12345&#34;)，输出‘12345’
def test(): test1() print(&#34;12345&#34;) # test() 在此处调用,会报错,因为代码顺序执行，test1()在这里还没有定义 def test1(): print(&#34;9999&#34;) test() 2、函数中的参数 （1）先看下面例子，引入形参和实参的概念 # 封装一个函数,传入两个数字,输出较大的一个数字 def get_max(num1,num2): # num1和num2是形式参数 if num1 &gt; num2: print(&#39;较大的数字是:&#39;,num1) else: print(&#39;较大的数字是:&#39;,num2) get_max(32,47) # 32和47是实际参数 上述代码中，定义了一个名为get_max的函数，传递两个形参num1，num2，函数体是比较num1和num2，执行代码get_max(32,47),这里的32和47就是实参，我们可以在任何地方调用get_max函数，传递想要的实参，函数体根据传递的参数计算出结果。
调用函数的时候,必须以正确的顺序传参一一对应，比如上面的传惨num1等于32，num2等于47,实参的数量和形参的数量保持一致在函数中,形参的名字和实参的名字可以一样.(本质上是在程序中开辟了不同的内存空间) （2）关键字参数 上面我们说了，实参和形参是数量相等一一对应的，比如上面的函数def get_max(num1,num2)，接收的是num1和num2两个参数，然后调用的时候get_max(12,2)，这样参数一一对应，12传递给num1，2传递给num2，但是能不能不按照顺序呢，答案是可以的，就是利用我们的关键字参数，看代码
get_max(num2 = 2,num1 = 12) 按照代码所示的关键字参数传递方式直接指明了num2 = 2，num1 = 12
（3）默认参数（在定义函数的时候,给形式参数直接赋值） def he(num1,num2 = 23): # num2 = 23表示默认参数 print(&#39;num1和num2两个数字的和是:&#39;,num1 &#43; num2) # 未使用默认参数 # he(10,50) #输出 60 # 使用了默认参数 # he(82) #输出 105 从上面的代码我们可以总结一下，默认参数的意义在于给形参设置一个默认值，你可以调用的时候重新传递覆盖，也可以就用默认值，比如上面的调用he(10,50)，10传递给num1，50覆盖默认值23，计算和输出60，假如我们调用 he(82)，这个时候82传递给num1，num2就用默认值32，计算和输出105，使用默认值有几个地方要注意：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-01T22:30:18+08:00">
    <meta property="article:modified_time" content="2024-08-01T22:30:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【玩转python】入门篇day14-函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="1%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">1、函数的定义</h3> 
<p>函数通过def定义，包括函数名、参数、返回值</p> 
<pre><code class="language-python"># 定义函数
def test(a,b):  # a,b表示形式参数
    print(a + b)#函数体(具体的功能)
    return a*b  #返回值

# 函数调用
test(12,43)  # 12和43表示实际参数,在调用函数时,会替换形式参数a,b
</code></pre> 
<p>下面这个展示了稍微复杂的函数嵌套，执行test()的时候test函数中顺序先执行test1，输出‘9999’，然后接着执行print("12345")，输出‘12345’</p> 
<pre><code class="language-python">
def test():
    test1()
    print("12345")
# test()  在此处调用,会报错,因为代码顺序执行，test1()在这里还没有定义
def test1():
    print("9999")

test()

</code></pre> 
<h3 id="2%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0">2、函数中的参数</h3> 
<h4 id="1%E5%85%88%E7%9C%8B%E4%B8%8B%E9%9D%A2%E4%BE%8B%E5%AD%90%E5%BC%95%E5%85%A5%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E7%9A%84%E6%A6%82%E5%BF%B5">（1）先看下面例子，引入形参和实参的概念</h4> 
<pre><code class="language-python"># 封装一个函数,传入两个数字,输出较大的一个数字
def get_max(num1,num2):  # num1和num2是形式参数
    if num1 &gt; num2:
        print('较大的数字是:',num1)
    else:
        print('较大的数字是:',num2)

get_max(32,47)   # 32和47是实际参数
</code></pre> 
<p>上述代码中，定义了一个名为get_max的函数，传递两个形参num1，num2，函数体是比较num1和num2，执行代码get_max(32,47),这里的32和47就是实参，我们可以在任何地方调用get_max函数，传递想要的实参，函数体根据传递的参数计算出结果。</p> 
<ol><li>调用函数的时候,必须以正确的顺序传参一一对应，比如上面的传惨num1等于32，num2等于47,实参的数量和形参的数量保持一致</li><li>在函数中,形参的名字和实参的名字可以一样.(本质上是在程序中开辟了不同的内存空间)</li></ol> 
<h4 id="2%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">（2）关键字参数</h4> 
<p>上面我们说了，实参和形参是数量相等一一对应的，比如上面的函数def get_max(num1,num2)，接收的是num1和num2两个参数，然后调用的时候get_max(12,2)，这样参数一一对应，12传递给num1，2传递给num2，但是能不能不按照顺序呢，答案是可以的，就是利用我们的关键字参数，看代码</p> 
<pre><code>get_max(num2 = 2,num1 = 12)
</code></pre> 
<p>按照代码所示的关键字参数传递方式直接指明了num2 = 2，num1 = 12</p> 
<h4 id="3%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%9C%A8%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%E7%BB%99%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC">（3）默认参数（在定义函数的时候,给形式参数直接赋值）</h4> 
<pre><code class="language-python">def he(num1,num2 = 23):  # num2 = 23表示默认参数
    print('num1和num2两个数字的和是:',num1 + num2)

# 未使用默认参数
# he(10,50)  #输出 60
# 使用了默认参数
# he(82)  #输出 105
</code></pre> 
<p>从上面的代码我们可以总结一下，默认参数的意义在于给形参设置一个默认值，你可以调用的时候重新传递覆盖，也可以就用默认值，比如上面的调用he(10,50)，10传递给num1，50覆盖默认值23，计算和输出60，假如我们调用 he(82)，这个时候82传递给num1，num2就用默认值32，计算和输出105，使用默认值有几个地方要注意：</p> 
<ol><li> <p>前面我们说形参和实参数量要一致，那为什么这里可以这样调用 he(82)，只是传递一个参数82，其实这个很好理解，因为形参num2设置了默认值，相当于82传递给num1，num2有默认值，所以实参可以不用传</p> </li><li> <p>把默认参数放在参数列表的前面会报错，比如下面代码会报错</p> </li></ol> 
<pre><code class="language-python">def cha(num1 = 23,num2): #这里报错了，默认值参数设置要放在后面
    print('num1和num2两个数字的差是:',num1 - num2)
</code></pre> 
<p>根据第一点的讲解我们也能较好的理解为什么默人参数前置会报错，因为你想假如按照cha(num1 = 23,num2)这样定义函数合法，那么当我们调用he(82)时这个82就会顺序传递到num1上，那num2参数就没有值了，所以这样不合理，反过来就不会存在这个问题</p> 
<h4 id="4%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E6%AF%94%E5%A3%B0%E6%98%8E%E6%97%B6%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%8F%82%E6%95%B0-args-kwargs">（4）不定长参数(可变参数):可以处理比声明时更多的参数. *args **kwargs</h4> 
<ul><li>*args: 用来接收多个位置参数,得到的是元组. 是arguments的简写</li><li>**kwargs: 用来接收多个关键字参数,得到的是一个字典. 是 keyword arguments的简写</li></ul> 
<pre><code class="language-python">def fn(*args):
    print(args)

# fn(12,34)   # (12, 34)
# fn(87,45,67)  # (87, 45, 67)
# fn(82,48,246,52)  # (82, 48, 246, 52)
</code></pre> 
<h5 id="%E6%B3%A8%E6%84%8F-%E5%BD%93-args-%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%82%E6%95%B0%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%B0%86args%E6%94%BE%E5%9C%A8%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%9A%84%E5%90%8E%E9%9D%A2%E9%81%93%E7%90%86%E7%B1%BB%E4%BC%BC%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E9%9C%80%E5%90%8E%E7%BD%AE">注意: 当 <em>args 和普通参数放在一起的时候,需要将</em>args放在参数列表的后面,道理类似默认参数需后置</h5> 
<pre><code class="language-python">def say(name,*args):
    print(name,args)
say('嘉琪',170,100)   # 嘉琪 (170, 100)
</code></pre> 
<pre><code class="language-python"># **kwargs 表示关键字参数,传输的数据格式:key=value
# 注意: **kwargs若和普通参数放在一起,必须将**kwargs放在参数列表的后面,否则会报错.
def say1(**kwargs):
    print(kwargs)
say1(name='张强',age = 22,height=175)  # {'name': '张强', 'age': 22, 'height': 175}

def say2(name,**kwargs):
    print(name,kwargs)
say2('宏海',age = 24,weight = 140)  # 宏海 {'age': 24, 'weight': 140}
</code></pre> 
<h5 id="%E6%80%BB%E7%BB%93">总结</h5> 
<ol><li>*args 和 **kwargs 都能表示不定长参数</li><li>在使用*args和**kwargs时，如果有普通参数，那普通参数必须放在前面，*args和 **kwargs放后面</li><li>*args接收得到的是元组，**kwargs的到的是字典</li></ol> 
<h3 id="3%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">3、匿名函数</h3> 
<h4 id="%E7%89%B9%E7%82%B9">特点</h4> 
<ol><li>lambda只是一个表达式,比普通函数简单</li><li>lambda一般只会书写一行,包含了参数 函数体和返回值 先看普通函数</li></ol> 
<pre><code class="language-python">def fn(n):
    return n**2
res = fn(3)
print(res)  # 9
</code></pre> 
<h5 id="%E4%B8%BA%E4%BA%86%E4%B9%A6%E5%86%99%E7%AE%80%E5%8D%95%E5%BC%95%E5%85%A5%E4%BA%86lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">为了书写简单，引入了lambda表达式</h5> 
<h5 id="%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%8A%E8%BF%B0%E7%9A%84%E5%8A%9F%E8%83%BD">使用匿名函数的方式实现上述的功能:</h5> 
<pre><code class="language-python">result = lambda n:n**2
print(result(3))  # 9
</code></pre> 
<h5 id="%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E4%B9%98%E7%A7%AF">使用匿名函数计算两个数字的乘积:</h5> 
<pre><code class="language-python">fn = lambda n,m:n*m
print(fn2(12,4))  # 48

</code></pre> 
<h5 id="%E5%AE%9E%E7%8E%B0%E5%85%83%E7%BB%84%E7%9B%B8%E4%B9%98">实现元组相乘</h5> 
<pre><code class="language-python">test = lambda *agr:agr*4
print(test(3,4))#(3, 4, 3, 4, 3, 4, 3, 4)
#这里函数是一个不定长的参数，的到的是一个元组
#实参传递3，4，的到的是元组（3，4）
#函数返回值是参数*4
#那的到的就是元组（3，4）*4 = (3, 4, 3, 4, 3, 4, 3, 4)
</code></pre> 
<h3 id="4%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">4、回调函数</h3> 
<h4 id="%E6%A6%82%E5%BF%B5-%E8%8B%A5%E6%8A%8A%E5%87%BD%E6%95%B0%E5%90%8D%E8%B5%8B%E5%80%BC%E7%BB%99%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%8F%98%E9%87%8F%E9%82%A3%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%B0%B1%E5%85%B7%E5%A4%87%E4%BA%86%E5%92%8C%E5%87%BD%E6%95%B0%E4%B8%80%E6%A0%B7%E7%9A%84%E5%8A%9F%E8%83%BD">概念： 若把函数名赋值给了一个新的变量,那这个变量就具备了和函数一样的功能.</h4> 
<p>下面我们直接通过代码来分析，代码也很简单，通过封装一个函数来实现加减乘除的操作</p> 
<h4 id="1%E5%85%88%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E7%9A%84%E5%87%BD%E6%95%B0">（1）先实现加、减、乘、除的函数</h4> 
<pre><code class="language-python"># 和
def add(a,b):
    print(a + b)
# 差
def cha(a,b):
    print(a - b)
# 乘积
def ji(a,b):
    print(a * b)
# 商
def shang(a,b):
    print(a / b)
</code></pre> 
<h4 id="2%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E7%9A%84%E6%93%8D%E4%BD%9C">(2)封装一个函数.实现加减乘除的操作</h4> 
<p>我们要的这个函数要求是传递，a，b两个要计算的实参以及计算方式（加、减、乘、除）的函数，然后的到结果</p> 
<pre><code class="language-python">def common(a,b ,fn):
    fn(a,b)
# 加法
common(12,3,add)    # 15
# 减法
common(12,3,cha)    # 9
# 乘积
common(12,3,ji)     # 36
# 商
common(12,3,shang)  # 4.0
</code></pre> 
<p>代码分析</p> 
<ol><li>我们定义一个common的函数，传递a，b以及计算方式（加、减、乘、除）的函数</li><li>在common函数中 fn是一个方法，当作一个参数传递进来</li><li>当执行 common(12,3,add) 时候，common函数里就执行add（12，3）从而达到根据传递不同的函数实现不同计算的功能</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2cfa8ed95e10d83e9f57333199c27d22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql高级语句的查询语句</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a1acb10464c033cc7196a9b42c5e68d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA切换分支，会影响当前在跑的项目吗？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>