<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;初阶学习】第十三弹——优先级队列及容器适配器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e20b7842b473e0e65f3024a0366b3ba8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;初阶学习】第十三弹——优先级队列及容器适配器">
  <meta property="og:description" content="C语言栈：数据结构——栈(C语言版)-CSDN博客
C语言队列：数据结构——队列（C语言版）-CSDN博客
C&#43;&#43;栈与队列：【C&#43;&#43;初阶学习】第十二弹——stack和queue的介绍和使用-CSDN博客
前言：
在前面，我们已经学习了用C&#43;&#43;如何使用stack和queue，今天，我们来讲解一下它们两个底层实现的一些东西和一些扩展内容
目录
一、优先级队列
基本概念
常用成员函数
创建和使用优先级队列
创建小根堆
二、容器适配器
基本概念
deque容器（了解）
stack和queue的模拟实现
一、优先级队列 前面我们已经学习了队列的知识，队列就是先进先出，那么这里的优先级队列是什么呢？
C&#43;&#43;中的优先级队列是一种基于容器适配器的抽象数据类型，它提供了队列接口，并允许按照元素的优先级进行排序
基本概念 优先级队列是一种特殊的队列，其中元素的出队顺序不是按照先进先出的原则，而是根据元素的优先级来确定。优先级高的元素先出队，优先级低的元素后出队（一般是按照升序，类似于堆的结构）
常用成员函数 以下是优先级队列的一些常用成员函数：
empty()：检查队列是否为空。size()：返回队列中的元素数量。top()：返回队列顶部（优先级最高）的元素，但不从队列中删除它。push()：将一个元素添加到队列中，并重新调整队列以保持排序。pop()：删除队列顶部（优先级最高）的元素。swap()：与另一个优先级队列交换内容 创建和使用优先级队列 以下是如何创建和使用一个优先级队列的示例：
#include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; int main() { // 创建一个存储int类型元素的优先级队列 priority_queue&lt;int&gt; pq; // 向队列中添加元素 pq.push(10); pq.push(30); pq.push(20); pq.push(5); pq.push(1); // 输出队列中的元素，并观察优先级 while (!pq.empty()) { cout &lt;&lt; pq.top() &lt;&lt; &#34; &#34;; pq.pop(); } cout &lt;&lt; endl; return 0; } 运行结果：
通过这个结果我们就可以看出所谓的优先级队列实际上与我们之前所学的堆很像，而且默认的是升序">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-10T21:53:43+08:00">
    <meta property="article:modified_time" content="2024-06-10T21:53:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;初阶学习】第十三弹——优先级队列及容器适配器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><strong> C语言栈：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/137076389?spm=1001.2014.3001.5502" title="数据结构——栈(C语言版)-CSDN博客">数据结构——栈(C语言版)-CSDN博客</a></p> 
<p><strong>C语言队列：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/137056659?spm=1001.2014.3001.5502" title="数据结构——队列（C语言版）-CSDN博客">数据结构——队列（C语言版）-CSDN博客</a></p> 
<p><strong>C++栈与队列：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/139424742?spm=1001.2014.3001.5502" title="【C++初阶学习】第十二弹——stack和queue的介绍和使用-CSDN博客">【C++初阶学习】第十二弹——stack和queue的介绍和使用-CSDN博客</a></p> 
<p><strong>前言：</strong></p> 
<blockquote> 
 <p>在前面，我们已经学习了用C++如何使用stack和queue，今天，我们来讲解一下它们两个底层实现的一些东西和一些扩展内容</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">一、优先级队列</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">基本概念</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">常用成员函数</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">创建和使用优先级队列</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E5%B0%8F%E6%A0%B9%E5%A0%86-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BA%E5%B0%8F%E6%A0%B9%E5%A0%86" rel="nofollow">创建小根堆</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8" rel="nofollow">二、容器适配器</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">基本概念</a></p> 
<p id="deque%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#deque%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" rel="nofollow">deque容器（了解）</a></p> 
<p id="stack%E5%92%8Cqueue%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#stack%E5%92%8Cqueue%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">stack和queue的模拟实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">一、优先级队列</h2> 
<p>前面我们已经学习了队列的知识，队列就是先进先出，那么这里的优先级队列是什么呢？</p> 
<blockquote> 
 <p>C++中的优先级队列是一种基于容器适配器的抽象数据类型，它提供了队列接口，并允许按照元素的优先级进行排序</p> 
</blockquote> 
<h4 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</h4> 
<blockquote> 
 <p>优先级队列是一种特殊的队列，其中元素的出队顺序不是按照先进先出的原则，而是根据元素的优先级来确定。优先级高的元素先出队，优先级低的元素后出队（一般是按照升序，类似于堆的结构）</p> 
</blockquote> 
<h4 id="%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">常用成员函数</h4> 
<p>以下是优先级队列的一些<strong>常用成员函数：</strong></p> 
<blockquote> 
 <ol><li><code><span style="background-color:#ffd900;">empty()</span></code>：检查队列是否为空。</li><li><code><span style="background-color:#ffd900;">size()</span></code>：返回队列中的元素数量。</li><li><code><span style="background-color:#ffd900;">top()</span></code>：返回队列顶部（优先级最高）的元素，但不从队列中删除它。</li><li><code><span style="background-color:#ffd900;">push()</span></code>：将一个元素添加到队列中，并重新调整队列以保持排序。</li><li><code><span style="background-color:#ffd900;">pop()</span></code>：删除队列顶部（优先级最高）的元素。</li><li><code><span style="background-color:#ffd900;">swap()</span></code>：与另一个优先级队列交换内容</li></ol> 
</blockquote> 
<h4 id="%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">创建和使用优先级队列</h4> 
<p>以下是如何创建和使用一个优先级队列的示例：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    // 创建一个存储int类型元素的优先级队列
    priority_queue&lt;int&gt; pq;

    // 向队列中添加元素
    pq.push(10);
    pq.push(30);
    pq.push(20);
    pq.push(5);
    pq.push(1);

    // 输出队列中的元素，并观察优先级
    while (!pq.empty()) {
        cout &lt;&lt; pq.top() &lt;&lt; " ";
        pq.pop();
    }
    cout &lt;&lt; endl;

    return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="233" src="https://images2.imgbox.com/72/cd/A0Dwddk4_o.png" width="718"></p> 
<blockquote> 
 <p>通过这个结果我们就可以看出所谓的优先级队列实际上与我们之前所学的堆很像，而且默认的是升序</p> 
</blockquote> 
<h4 id="%E5%88%9B%E5%BB%BA%E5%B0%8F%E6%A0%B9%E5%A0%86">创建小根堆</h4> 
<p>如果你想要创建一个小根堆（优先级最低的元素在顶部），你可以传递<code><span style="background-color:#ffd900;">std::greater&lt;T&gt;</span></code>作为比较函数：</p> 
<pre><code class="language-cpp">std::priority_queue&lt;int, std::dequeue&lt;int&gt;, std::greater&lt;int&gt;&gt; pq;</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8">二、容器适配器</h2> 
<h4>基本概念</h4> 
<p>在将容器适配器前，我们首先要搞明白一点， 什么是容器？什么是容器适配器？</p> 
<p>在前面我们讲vector、list、string时，我们讲过这些我们在以后讲时是将其作为容器使用，就是说我们用它们来存放数据，哪个用着方便就用哪个，至于说容器适配器其实就是指这个类型可以用多种容器来模拟实现，比如说：</p> 
<blockquote> 
 <div> 
  <strong><span style="color:#777777;">stack</span><span style="color:#777777;">是一种后进先出的特殊线性数据结构，因此只要具有</span><span style="color:#fe2c24;">push_back()</span><span style="color:#777777;">和</span><span style="color:#fe2c24;">pop_back()</span><span style="color:#777777;">操作的线性结构，都可 </span></strong> 
  <strong><span style="color:#777777;">以作为stack</span><span style="color:#777777;">的底层容器，比如</span><span style="color:#777777;">vector</span><span style="color:#777777;">和</span><span style="color:#777777;">list</span><span style="color:#777777;">都可以；</span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#777777;">queue</span><span style="color:#777777;">是先进先出的特殊线性数据结构，只要具有 </span></strong> 
  <strong><span style="color:#fe2c24;">push_back</span><span style="color:#777777;">和</span><span style="color:#fe2c24;">pop_front</span><span style="color:#777777;">操作的线性结构，都可以作为</span><span style="color:#777777;">queue</span><span style="color:#777777;">的底层容器，比如</span><span style="color:#777777;">list</span><span style="color:#777777;">。</span></strong> 
 </div> 
</blockquote> 
<div> 
 <img alt="" height="148" src="https://images2.imgbox.com/b7/dc/KnbUUCRS_o.png" width="691"> 
</div> 
<div> 
 <img alt="" height="142" src="https://images2.imgbox.com/5b/08/MXSrdfom_o.png" width="716"> 
</div> 
<div>
  当然，上面这两个类型在底层设计时，使用的并不是vector和list，而是用deque来实现的，那么这个容器又是什么呢，在前面我们就涉及到过，下面就来讲一下 
</div> 
<h4 id="deque%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">deque容器（了解）</h4> 
<p>deque本质上是一个双向都可以插入删除的队列，更准确的说我们应该拿它与vector和list做对比，下面我们来看一下deque的接口函数</p> 
<p><img alt="" height="636" src="https://images2.imgbox.com/63/49/hthWPpft_o.png" width="1200"></p> 
<p>通过这个图片我们可以看出，其实deque是兼顾vector和list的用法的，有点像是它们两个的集大成者，那么我们为什么不直接学习deque，不去学习vector和list呢？</p> 
<blockquote> 
 <p><strong>这是因为<span style="color:#777777;">deque</span><span style="color:#777777;">有一个致命缺陷：不适合遍历，因为在遍历时，</span><span style="color:#777777;">deque</span><span style="color:#777777;">的迭代器要频繁的去检测其是否移动到 </span></strong><strong><span style="color:#777777;">某段小空间的边界，导致效率低下，但是一般用到这种线性结构存储的都会需要遍历，所以deque在平时就用不到</span></strong></p> 
</blockquote> 
<p><strong><span style="color:#777777;">下面我们可以来看一下deque的底层架构:</span></strong></p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/40/5e/g2Z6jVd3_o.png" width="1200"></p> 
<p>下面我们来看一下deque的应用场景：stack和queue的模拟实现</p> 
<h4 id="stack%E5%92%8Cqueue%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">stack和queue的模拟实现</h4> 
<p>这里不做详细的讲解了，有不懂的可以私信问我</p> 
<p><strong>stack</strong></p> 
<pre><code class="language-cpp">#include&lt;deque&gt;
namespace zda
{
	template&lt;class T, class Con = deque&lt;T&gt;&gt;
	//template&lt;class T, class Con = vector&lt;T&gt;&gt;
	//template&lt;class T, class Con = list&lt;T&gt;&gt;
	class stack
	{
	public:
		stack() {}
		void push(const T&amp; x) { _c.push_back(x); }
		void pop() { _c.pop_back(); }
		T&amp; top() { return _c.back(); }
		const T&amp; top()const { return _c.back(); }
		size_t size()const { return _c.size(); }
		bool empty()const { return _c.empty(); }
	private:
		Con _c;
	};
}</code></pre> 
<p><strong>queue</strong></p> 
<pre><code class="language-cpp">#include&lt;deque&gt;
#include &lt;list&gt;
namespace bite
{
	template&lt;class T, class Con = deque&lt;T&gt;&gt;
	//template&lt;class T, class Con = list&lt;T&gt;&gt;
	class queue
	{
	public:
		queue() {}
		void push(const T&amp; x) { _c.push_back(x); }
		void pop() { _c.pop_front(); }
		T&amp; back() { return _c.back(); }
		const T&amp; back()const { return _c.back(); }
		T&amp; front() { return _c.front(); }
		const T&amp; front()const { return _c.front(); }
		size_t size()const { return _c.size(); }
		bool empty()const { return _c.empty(); }
	private:
		Con _c;
	};
}</code></pre> 
<p>三、总结</p> 
<blockquote> 
 <p>学完我们再回头体会一下，其实优先级队列就是我们之前所学的堆，而容器适配器其实就是一种能够调用容器的特殊数据类型，并没有什么新的知识，今天的内容暂且到此，有不理解的地方可以与我私信交流</p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">感谢各位大佬观看，创作不易，还请各位大佬一键三连！！！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5236d94fae30288fd62b080c0273a4b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python核心数据结构探秘】：元组与字典的完美协奏曲</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95e8bda6eab690d8bc0644c02ddccec4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络安全在个人生活中具体有哪些常见的应用场景？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>