<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DFS：记忆化搜索 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b810b07f54bbd0ba35816b0d7c23d007/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="DFS：记忆化搜索">
  <meta property="og:description" content="​​​​​​​ 一、记忆化搜索vs动态规划 . - 力扣（LeetCode）
class Solution { public: //记忆化搜索 //1、设置一个备忘录，要确保备忘录初始化的结果不能跟我们实际计算的结果相同 //2、添加备忘录，计算的时候，如果备忘录的位置是初始值，进行修改 //3、每次计算的时候，去备忘录瞅一瞅，找到的话，就可以不算了 int memory[31]; int fib(int n) { memset(memory,-1,sizeof(memory));//利用memset进行初始化成-1 return dfs(n); } int dfs(int n) { //递归进入前，去备忘录瞅瞅 if(memory[n]!=-1) return memory[n]; if(n==0||n==1) { memory[n]=n; return memory[n]; } else { memory[n]=dfs(n-1)&#43;dfs(n-2); return memory[n]; } } }; 二、不同路径 class Solution { public: int uniquePaths(int m, int n) { //记忆化搜索 vector&lt;vector&lt;int&gt;&gt; memo(m&#43;1,vector&lt;int&gt;(n&#43;1,-1));//建立一个记忆数组 return dfs(m,n,memo);//dfs去帮我搜索 } int dfs(int i,int j,vector&lt;vector&lt;int&gt;&gt;&amp;memo) { if(memo[i][j]!=-1) return memo[i][j]; if(i==0||j==0) return 0; if(i==1&amp;&amp;j==1) return 1; memo[i][j]=dfs(i-1,j,memo)&#43;dfs(i,j-1,memo); return memo[i][j]; } }; 三、最长的递增子序列 class Solution { public: //记忆化搜索 //不用记忆化搜索的话会超时，因为本身就是一个多叉树 int lengthOfLIS(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; memo(nums.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-08T19:48:52+08:00">
    <meta property="article:modified_time" content="2024-04-08T19:48:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DFS：记忆化搜索</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" height="283" src="https://images2.imgbox.com/6b/6c/yoLxyqz5_o.gif" width="552">​​​​​​​</h2> 
<h2>一、记忆化搜索vs动态规划</h2> 
<p><a href="https://leetcode.cn/problems/fibonacci-number/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e8/20/1Q8bUJHU_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    //记忆化搜索
    //1、设置一个备忘录，要确保备忘录初始化的结果不能跟我们实际计算的结果相同
    //2、添加备忘录，计算的时候，如果备忘录的位置是初始值，进行修改
    //3、每次计算的时候，去备忘录瞅一瞅，找到的话，就可以不算了
    int memory[31];
    int fib(int n) 
    {
      memset(memory,-1,sizeof(memory));//利用memset进行初始化成-1
      return dfs(n);
    }

    int dfs(int n)
    {
        //递归进入前，去备忘录瞅瞅
        if(memory[n]!=-1) return memory[n];
        if(n==0||n==1) 
        {
            memory[n]=n;
            return memory[n];
        }
        else 
        {
            memory[n]=dfs(n-1)+dfs(n-2);
            return memory[n];
        }
    }
};</code></pre> 
<h2>二、不同路径</h2> 
<p><img alt="" height="752" src="https://images2.imgbox.com/dc/83/awDDk535_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int uniquePaths(int m, int n)
    {
        //记忆化搜索
        vector&lt;vector&lt;int&gt;&gt; memo(m+1,vector&lt;int&gt;(n+1,-1));//建立一个记忆数组
        return dfs(m,n,memo);//dfs去帮我搜索
    }

    int dfs(int i,int j,vector&lt;vector&lt;int&gt;&gt;&amp;memo)
    {
       if(memo[i][j]!=-1) return memo[i][j];
       if(i==0||j==0) return 0;
       if(i==1&amp;&amp;j==1) return 1;
       
        memo[i][j]=dfs(i-1,j,memo)+dfs(i,j-1,memo);
        return memo[i][j];
    }
};</code></pre> 
<h2>三、最长的递增子序列</h2> 
<p><img alt="" height="808" src="https://images2.imgbox.com/94/24/MgEYIWQ7_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    //记忆化搜索
    //不用记忆化搜索的话会超时，因为本身就是一个多叉树
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) 
    {
       vector&lt;int&gt; memo(nums.size()+1,-1);
       int ret=1;
       for(int i=0;i&lt;nums.size();++i)
       {
          ret=max(dfs(nums,i,memo),ret);
       } 
       return ret;
    }

    int dfs(vector&lt;int&gt;&amp; nums,int pos,vector&lt;int&gt;&amp;memo)//从pos位置开始，以pos位置做起点，往后搜索出他的最长子序列
    {
    //接下去开始从下一个位置开始找
    if(memo[pos]!=-1) return memo[pos];
    int ret=1;
    for(int i=pos+1;i&lt;nums.size();++i)
      {
        if(nums[i]&gt;nums[pos]) //找到了，就更新ret，然后去以下一个位置为起点接着找
        {
           ret=max(ret,dfs(nums,i,memo)+1);
        }
      }
      memo[pos]=ret;
      return memo[pos];
    }
};</code></pre> 
<h2>四、猜数字大小II</h2> 
<p><img alt="" height="932" src="https://images2.imgbox.com/b9/73/eHSfHOhl_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int getMoneyAmount(int n) 
    {
    vector&lt;vector&lt;int&gt;&gt; memo(n+1,vector&lt;int&gt;(n+1));
      return dfs(1,n,memo);
    }

    int dfs(int left,int right, vector&lt;vector&lt;int&gt;&gt;&amp;memo)
    {
        if(left&gt;=right) return 0;
        if(memo[left][right]) return memo[left][right];//去备忘录瞅瞅 
        int ret=INT_MAX;
        for(int i=left;i&lt;=right;++i)
        {
            int l=dfs(left,i-1,memo);//左边的最小
            int r=dfs(i+1,right,memo);//右边的最小
            ret=min(ret,max(l,r)+i);
        }
        memo[left][right]=ret;
        return memo[left][right];
    }
};</code></pre> 
<h2>五、矩阵的最长递增路径</h2> 
<p><img alt="" height="948" src="https://images2.imgbox.com/51/75/o0JOeyUB_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int dx[4]={0,0,1,-1};
    int dy[4]={1,-1,0,0};
    int m,n;
    //记忆化搜索，不然会超时
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) 
    {
        int ret=1;
        m=matrix.size(),n=matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt; memo(m+1,vector&lt;int&gt;(n+1));
       for(int i=0;i&lt;m;++i)
       for(int j=0;j&lt;n;++j)
         {
           ret=max(ret,dfs(matrix,i,j,memo));//以任意坐标为起点，dfs去帮我们找到最大的路径
         }
         return ret;
    }
    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,int i,int j, vector&lt;vector&lt;int&gt;&gt;&amp;memo)
    {
        if(memo[i][j]!=0) return memo[i][j];
       int ret=1;
       for(int k=0;k&lt;4;++k)
       {
         int x=i+dx[k],y=j+dy[k];
         if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;matrix[x][y]&gt;matrix[i][j]) 
             ret=max(dfs(matrix,x,y,memo)+1,ret);
       }
       memo[i][j]=ret;//填备忘录
       return memo[i][j];
    }
};</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/68/GE5pkBsY_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a84844ac09011403824a628549ea756a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【利器篇】前端40&#43;精选VSCode插件，总有几个你未拥有！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cc18eaab6b1c4f74d5328f236618c582/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.net.ConnectException: Connection refused: connect</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>