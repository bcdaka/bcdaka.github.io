<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【二叉树进阶】--- 二叉搜索树转双向链表 &amp;&amp; 最近公共祖先 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5e16e183246a9ba28c5131d8d2739e04/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【二叉树进阶】--- 二叉搜索树转双向链表 && 最近公共祖先">
  <meta property="og:description" content="Welcome to 9ilk&#39;s Code World (๑•́ ₃ •̀๑) 个人主页: 9ilk (๑•́ ₃ •̀๑) 文章专栏： 数据结构 本篇博客我们继续了解一些二叉树的进阶算法。
🏠 二叉搜索 树转化为双向循环链表 📌 题目内容 将二叉搜索树转化为排序好的双向循环链表
📌 题目解析 双向循环链表所连接的结点是有序的。题目要求原地转换，也就是说不允许新new结点形成新的链表，而是改变搜索树中结点指针指向。搜索树中结点的值都是唯一的，我们无需担心出现重复值结点。 📌 算法原理 ✏️ 思路一： 题目要求链表中的节点是排好序的，因此结合二叉搜索树的性质(二叉搜索树中序遍历出来是有序的)，我们可以按照对二叉树进行中序遍历，然后依次将节点指针存进vector里，最后遍历vector将各个节点的前驱和后继指针给处理好，最后别忘记头节点前驱指向尾节点，尾节点后继指向头节点。
动图演示：
参考代码：
class Solution { public: void InOrder(Node* root,vector&lt;Node*&gt;&amp; treev) //利用中序遍历 因为二叉搜索树中序是排好序的 { if(root == nullptr) return; InOrder(root-&gt;left,treev); treev.push_back(root); //存进数组 InOrder(root-&gt;right,treev); } Node* treeToDoublyList(Node* root) { if(root == nullptr) return root; vector&lt;Node*&gt; treev; InOrder(root,treev); int cur = 1 ; Node* prev = treev[0]; Node* del = treev[1]; while(cur &lt; treev.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-14T21:25:09+08:00">
    <meta property="article:modified_time" content="2024-08-14T21:25:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【二叉树进阶】--- 二叉搜索树转双向链表 &amp;&amp; 最近公共祖先</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"> <span style="color:#a5a5a5;">Welcome to 9ilk's Code World</span></h2> 
<p style="text-align:center;"><span style="color:#a5a5a5;">       <img alt="" src="https://images2.imgbox.com/02/e5/3HNiG33K_o.jpg"></span></p> 
<p></p> 
<h3>(๑•́ ₃ •̀๑) <span style="color:#38d8f0;">个人主页:</span><span style="color:#a5a5a5;">        <a class="link-info" href="https://blog.csdn.net/2301_79448270?type=blog" title="9ilk">9ilk</a></span></h3> 
<h3>(๑•́ ₃ •̀๑) <span style="color:#38d8f0;">文章专栏：     <a class="link-info" href="https://blog.csdn.net/2301_79448270/category_12624613.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a></span></h3> 
<hr> 
<blockquote> 
 <p>本篇博客我们继续了解一些二叉树的进阶算法。</p> 
</blockquote> 
<hr> 
<p></p> 
<h2>🏠 二叉搜索 树转化为双向循环链表</h2> 
<h3 style="background-color:transparent;">📌 题目内容</h3> 
<blockquote> 
 <p><a class="link-info" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" rel="nofollow" title="将二叉搜索树转化为排序好的双向循环链表">将二叉搜索树转化为排序好的双向循环链表</a></p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/43/6a/AXjDJKs7_o.png" width="1008"></p> 
</blockquote> 
<h3 style="background-color:transparent;"> 📌 题目解析</h3> 
<ul><li>双向循环链表所连接的结点是<strong>有序</strong>的。</li><li>题目要求<strong>原地转换</strong>，也就是说不允许新new结点形成新的链表，而是改变搜索树中结点指针指向。</li><li>搜索树中结点的<strong>值都是唯一的</strong>，我们无需担心出现重复值结点。</li></ul> 
<h3>📌 算法原理</h3> 
<h4>✏️ 思路一：</h4> 
<blockquote> 
 <p>  题目要求链表中的节点是排好序的，因此结合二叉搜索树的性质(二叉搜索树中序遍历出来是有序的)，我们可以<strong>按照对二叉树进行中序遍历</strong>，然后依次将节点指针<strong>存进vector</strong>里，最后遍历vector将<strong>各个节点的前驱和后继指针给处理好</strong>，最后别忘记头节点前驱指向尾节点，尾节点后继指向头节点。</p> 
</blockquote> 
<p><strong>动图演示：</strong></p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/e8/87/zQbfrzt9_o.gif" width="1200"></p> 
<p><strong>参考代码：</strong></p> 
<pre><code class="language-cpp">class Solution {
public:
   void InOrder(Node* root,vector&lt;Node*&gt;&amp; treev) //利用中序遍历 因为二叉搜索树中序是排好序的
   {
     if(root == nullptr)
       return;
     InOrder(root-&gt;left,treev);
     treev.push_back(root); //存进数组
     InOrder(root-&gt;right,treev);  
   }

    Node* treeToDoublyList(Node* root) 
    {
        if(root == nullptr)
         return root;
       vector&lt;Node*&gt; treev;
       InOrder(root,treev);
       int cur = 1 ;
       Node* prev = treev[0];
       Node* del = treev[1]; 
       while(cur &lt; treev.size()) //调整好指针指向
       {
             del = treev[cur];
             prev-&gt;right = del;
             del-&gt;left = prev;
             prev = del;
             cur++;
       }
      treev[0]-&gt;left = treev[cur-1];
      treev[cur-1]-&gt;right = treev[0];   
      return treev[0];
    }
};</code></pre> 
<blockquote> 
 <p>分析：这种思路简单，但是空间复杂度达到了O(N)(用vector存节点指针导致)，是否有其他思路能优化到O(1),在遍历的同时修改指针指向呢?</p> 
</blockquote> 
<h4>✏️ 思路二：</h4> 
<p> 我们之前创建一个链表除了先提前new出节点再连接外，其实还有一个方法可以动态创建链表。</p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/90/e7/DHUAnixR_o.gif" width="1200"></p> 
<p>当我们中序遍历二叉搜索树时就可采取类似的做法。不同的是，我们需要记录前驱节点prev，ptail-&gt;next = node,此时的node就是我们中序遍历的当前访问节点，此时ptail需要更新成node(当前访问节点),prev就是上一个按中序被访问节点，所以我们需要在更新ptail之前记录prev，同时更新好前驱和后继指针的指向。</p> 
<p><strong>动画演示：</strong></p> 
<p><img alt="" height="773" src="https://images2.imgbox.com/eb/df/hU3BQUIs_o.gif" width="1122"></p> 
<p>核心步骤：</p> 
<pre><code class="language-cpp">       ptail-&gt;right =root; 
       Node* prev = ptail; //ptail其实就是前驱结点
       ptail = ptail-&gt;right; 
       ptail-&gt;left = prev</code></pre> 
<p>参考代码：</p> 
<pre><code class="language-cpp">  Node* phead = nullptr;
   Node* ptail = nullptr;
   void InOrder(Node* root) //利用中序遍历 因为二叉搜索树中序是排好序的
   {
     if(root == nullptr)
       return;
     InOrder(root-&gt;left);
     if(phead == nullptr) //头结点 也就是搜索树的最左
      phead = ptail = root;
     else 
     {
       ptail-&gt;right =root; 
       Node* prev = ptail; //ptail其实就是前驱结点
       ptail = ptail-&gt;right; 
       ptail-&gt;left = prev;
     }  
     InOrder(root-&gt;right);  

   }

    Node* treeToDoublyList(Node* root) 
    {
        if(root == nullptr)
         return root;
         InOrder(root);
         phead-&gt;left = ptail;
         ptail-&gt;right = phead;
         return phead; 

    }</code></pre> 
<p></p> 
<h2 style="background-color:transparent;">🏠 二叉树的最近公共祖先</h2> 
<h3 style="background-color:transparent;">📌 题目内容</h3> 
<blockquote> 
 <p><a class="link-info" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/" rel="nofollow" title="二叉树的最近公共祖先">二叉树的最近公共祖先</a></p> 
 <p><img alt="" height="615" src="https://images2.imgbox.com/f6/44/ZJTMjaFv_o.png" width="972"></p> 
</blockquote> 
<h3 style="background-color:transparent;">📌 题目解析</h3> 
<ul><li>注意点1：一个节点也可以是它自己的祖先</li><li>注意点2：要找的祖先公共要是最近也就是深度最大。</li></ul> 
<h3>📌 算法原理</h3> 
<h4 style="background-color:transparent;">✏️ 思路一：</h4> 
<blockquote> 
 <p>1.题目要求我们找公共祖先，那我们首要任务是求出节点到根节点路径所经过的节点。</p> 
 <p>2.我们可以求出每个节点的祖先路径分别装进数组里。</p> 
 <p>3.求路径：我们可以设计一个递归函数，它的功能是<strong>判断子树是否存在目标节点，直到找到目标节点为止</strong>。</p> 
 <p>4.找到目标节点之后，我们就可以利用两个<strong>哈希表分别遍历数组，表示他们出现过</strong>。</p> 
 <p>5.最近的公共祖先一定出现在数组的后面部分，我们可以<strong>从后往前遍历祖先路径比较短的数组</strong>，发现两个映射关系都确立的就是我们要找的。</p> 
</blockquote> 
<p><strong>参考代码：</strong></p> 
<pre><code class="language-cpp">bool isLeft(TreeNode* node, TreeNode* del) //看是不是在子树
	{
		if (del == nullptr)
			return false;
		if (del == node) 
			return true;
		return isLeft(node, del-&gt;left) || isLeft(node,del-&gt;right);
	}

	void ancestor(vector&lt;TreeNode*&gt;&amp; v, TreeNode* node, TreeNode* root, unordered_map&lt;TreeNode*, int&gt;&amp; ump) //装路径进数组的函数
	{
		if (root == nullptr)
			return;
		v.push_back(root); //不论是不是都说明这是target node的祖先
		ump[root]++;
		if (root == node)
		{
			return;
		}
		
		if (isLeft(node, root-&gt;left)) //判断在左子树还是右子树
		{
			ancestor(v, node, root-&gt;left, ump);
		}
		else
		{
			ancestor(v, node, root-&gt;right, ump);
		}

	}


	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
	{
		unordered_map&lt;TreeNode*, int&gt; ump;
		unordered_map&lt;TreeNode*, int&gt; umq;
		//分别找出各自的祖先再进行比较深度
		if (p == root || q == root)
			return root;
		vector&lt;TreeNode*&gt; vp;//存的是p的祖先
		vector&lt;TreeNode*&gt; vq;//存的是q的祖先
		vp.push_back(root);
		vq.push_back(root); 
		ump[root]++;
		umq[root]++;
		if (isLeft(p, root-&gt;left))
		{
			ancestor(vp, p, root-&gt;left, ump);//在左子树 递归进去
		}
		else
		{
			ancestor(vp, p, root-&gt;right, ump); //在右子树
		}
		if (isLeft(q, root-&gt;left))
		{
			ancestor(vq, q, root-&gt;left, umq);
		}
		else
		{
			ancestor(vq, q, root-&gt;right, umq);
		}
		//比较最近祖先
		
		vector&lt;TreeNode*&gt; min = vp;
		if (vp.size() &gt; vq.size())
		{
			min = vq;
		}
	  
		TreeNode* near = nullptr;
		for (int i = min.size() - 1 ; i &gt;= 0; --)
		{
			if (ump[min[i]] &amp;&amp; umq[min[i]])
			{
				near = min[i];
                break;
			}
		}

		return near;

	}</code></pre> 
<blockquote> 
 <p>这种思路比较简单，但是时间复杂度较大且调用栈空间较多，是一笔不小的开销。</p> 
</blockquote> 
<h4 style="background-color:transparent;">✏️ 思路二：</h4> 
<p><img alt="" height="357" src="https://images2.imgbox.com/f4/60/S3m2JInI_o.png" width="1200"></p> 
<blockquote> 
 <p>仔细观察，我们发现思路1:仔细观察一下,两个结点,最近公共祖先的特征就是<strong>一个结点在最近公共祖先的左边,一个结点在最近公共祖先的右边</strong>。比如图一6和4的公共祖先有5和3,但是只有最近公共祖先5满足6在左边,4在右边。值得注意的是，对于图二这种情况，<strong>如果最近公共祖先是p和q其中一个，我们直接返回当前的root即可。</strong></p> 
</blockquote> 
<p><strong>因此有：</strong></p> 
<ul><li>我们首先需要一个函数判断结点在哪个子树，这里注意的是，<strong>我们可以假设先这个结点在左子树，如果返回false，则说明结点在右子树了，反之在左子树</strong>。也就是下方第二个参数我们传root-&gt;left即可。</li></ul> 
<pre><code class="language-cpp"> bool isleftOright(TreeNode* node,TreeNode* root)
    {
        if(root == nullptr)
          return false;
        return root == node ||isleftOright(node,root-&gt;left) ||  
               isleftOright(node,root&gt;right);  
    } //非空的话 如果当前节点是要找的直接返回否则在左右子树找 所以用||</code></pre> 
<ul><li><strong>若两个结点分别在一左一右，直接返回当前root即可。</strong></li><li><strong>若两个结点都在左子树或都在右子树，此时我们需要递归进当前子树的左子树或右子树，继续寻找公共祖先。</strong></li><li><strong>在每次确定结点在左子树还是右子树，我们需要处理特殊情况看是否当前结点就是p或q</strong>.</li></ul> 
<p><strong>参考代码：</strong></p> 
<pre><code class="language-cpp">class Solution {
public:
    bool isleftOright(TreeNode* node,TreeNode* root)
    {
        if(root == nullptr)
          return false;
        return root == node ||isleftOright(node,root-&gt;left) ||  isleftOright(node,root-&gt;right);  
    }
    
	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
	{

		if (p == root || q == root)//最近公共祖先为p q其中一个
			return root;
        bool pinleft = isleftOright(p,root-&gt;left);
        bool pinright = !pinleft; //非左即右
        bool qinleft = isleftOright(q,root-&gt;left);
        bool qinright = !qinleft;
        //p q分别在左右子树
        if((pinleft &amp;&amp; qinright) || (qinleft &amp;&amp; pinright))
          return root;
       //p q都在左右子树
        else if(pinleft &amp;&amp; qinleft)
          return lowestCommonAncestor(root-&gt;left,p,q);
         else
          return lowestCommonAncestor(root-&gt;right,p,q); 

	} </code></pre> 
<ol><li>这种思路比思路一调用栈层数少了许多，但也是有一定开销的。</li><li>这种思路最坏情况下时间复杂度是O(N^2).</li></ol> 
<p><img alt="" height="489" src="https://images2.imgbox.com/db/f7/PfqDkIFF_o.png" width="402"></p> 
<h4>✏️ 思路三：</h4> 
<p>  <em> 归根结底，找公共祖先也就是找公共节点，如果我们能求出两个节点的祖先路径，就能转化为链表相交问题了。问题是如何优化求路径呢？</em></p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/bb/8a/KQakR8TO_o.gif" width="1200"></p> 
<blockquote> 
 <p>1. 我们可以按照<span style="color:#2b2f36;">前序遍历的思路，找</span><span style="color:#2b2f36;">x</span><span style="color:#2b2f36;">结点的路径。</span></p> 
 <p><span style="color:#2b2f36;">2.<strong>遇到root</strong></span><strong><span style="color:#2b2f36;">结点先</span><span style="color:#2b2f36;">push</span><span style="color:#2b2f36;">⼊栈，因为</span><span style="color:#2b2f36;">root</span><span style="color:#2b2f36;">就算不是</span><span style="color:#2b2f36;">x</span><span style="color:#2b2f36;">，但是</span><span style="color:#2b2f36;">root</span><span style="color:#2b2f36;">可能是根</span><span style="color:#2b2f36;">-&gt;x</span><span style="color:#2b2f36;">路径中⼀个分支结点，</span><span style="color:#2b2f36;">当这个节点左右子树都没有要找的节点的话，说明上面入栈的</span><span style="color:#2b2f36;">root</span><span style="color:#2b2f36;">不是根</span></strong><span style="color:#2b2f36;"><strong>-&gt;x路径中⼀个分⽀结点，此时就可以pop出栈回退，继续去其他分⽀路径进行查找 </strong>。</span></p> 
 <p>3.链表相交问题我们可以先<strong>用哈希map遍历其中一条路径，再遍历另一条路径时，由于我们前序+栈得到的是从下到上的路径，所以第一次两个哈希表都有映射说明就是交点，也就是最近公共祖先。</strong></p> 
</blockquote> 
<p><strong>参考代码：</strong></p> 
<pre><code class="language-cpp">    bool GetPath(TreeNode*root,TreeNode* p, stack&lt;TreeNode*&gt;&amp; s)//求路径
    {  
        if(root == nullptr)
        return false;
         s.push(root);
        if(root == p)//找到目标节点
         return true;
        if(GetPath(root-&gt;left,p,s)) //左子树找 没有就去右子树
        {  
            return true; 
        }
        if(GetPath(root-&gt;right,p,s))
        {
            return true;
        }
        //左右子树都没有 回退
        s.pop();
        return false;

    } 



	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
	{  
        stack&lt;TreeNode*&gt; sp;
        stack&lt;TreeNode*&gt; sq;

		unordered_map&lt;TreeNode*, int&gt; ump;
		unordered_map&lt;TreeNode*, int&gt; umq;
		if (p == root || q == root)
			return root;
       //求路径
		GetPath(root,p,sp);
		GetPath(root,q,sq);
       while(!sp.empty())
       {
            TreeNode* top = sp.top();
            ump[top]++;
            sp.pop();
       }
       TreeNode* near = nullptr;
       //链表相交 
       while(!sq.empty())
       {
           TreeNode* top = sq.top();
           umq[top]++;
           if(umq[top] &amp;&amp; ump[top]) //两个都有映射
           {
              near = top;
              break;
           }
          sq.pop();
       }
      return near;
	} </code></pre> 
<p></p> 
<hr> 
<p><strong>完(๑¯ω¯๑)</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/994386e8899eb4391102c8cd598a45f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024 年可免费下载的 6 款最佳 iOS 解锁软件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce04f8964c277c557dc74ed37444c8f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】顺序表——赋源码(结尾)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>