<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贪心算法--区间调度问题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fbc0a1cf1a4c9f384da2938bcf9ab28f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="贪心算法--区间调度问题">
  <meta property="og:description" content="贪心算法 引言 贪心算法是一种简单而有效的算法设计技巧，广泛应用于解决各种优化问题。其基本思想是通过每一步的局部最优选择，最终达到全局最优解。贪心算法通常不会回溯之前的决策，而是基于当前状态作出最优决策，因此其执行效率较高。
原理 贪心算法（Greedy Algorithm）是一种通过每一步的局部最优选择，最终达到全局最优解的算法范式。其核心思想可以概括为以下两点：
贪心选择性质：每一步都选择当前情况下看起来最好的选择，即局部最优解。最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。贪心算法通过递归地求解子问题，并利用最优子结构性质，保证每一步的选择都是最优的。 由于贪心算法不回溯之前的决策，仅根据当前状态作出最优决策，这使得其执行效率较高，但也限制了其适用范围。贪心算法通常适用于满足贪心选择性质和最优子结构性质的问题，例如最小生成树、最短路径和任务调度等。
应用场景 贪心算法在许多领域都有广泛的应用，特别是在以下几个方面：
最小生成树： 在图论中，贪心算法经常用于构建最小生成树，例如 Prim 算法和 Kruskal 算法。这些算法通过每次选择权值最小的边来构建最小生成树，从而实现图的最优连通。最短路径问题： 在图论中，Dijkstra 算法和 A* 算法等都是基于贪心策略的最短路径算法。它们通过每次选择当前距离最短的顶点来逐步确定起点到其他顶点的最短路径。任务调度问题： 在任务调度问题中，贪心算法可以用于优化任务的执行顺序，以使得总执行时间最小化。例如，按照任务的截止时间或处理时间进行排序，然后依次执行。背包问题： 在背包问题中，贪心算法可以用于近似求解，例如分数背包问题中的分数贪心算法。这种算法每次选择单位价值最高的物品放入背包中，以尽可能达到背包的容量限制并使总价值最大化。区间调度问题： 在区间调度问题中，贪心算法可以用于确定最大数量的互不重叠的区间。例如，会议安排问题中，每次选择结束时间最早的会议安排，以尽可能安排更多的会议。Huffman 编码： Huffman 编码是一种用于数据压缩的贪心算法。它通过构建一棵最优前缀树来实现对字符的编码，使得出现频率较高的字符拥有较短的编码，从而实现数据的高效压缩。 实现贪心算法 本篇我们主要分享的是区间调度问题相关例题。
452. 用最少数量的箭引爆气球 我们以 [[10,16],[2,8],[1,6],[7,12]] 为例：
原气球的排列为：
题目要求求出引爆所有气球所必须射出的 最小 弓箭数
如果按照原来顺序去判断的话，很难找出有重复的气球，所以我们可以对气球先进行排序（按照左边界或者右边界排序都可以，本题我按照左边界排序来进行讲解）
排序后为：
排序了之后我们就可以从上往下遍历去判断是否重合了。
当下面的气球的左边界小于等于上面气球的右边界时，证明两个气球重合，可以用一支箭引爆。
当然下面一个气球有可能和上面两个气球都重合，如果只和上面一个气球重合而不和上上面气球重合的话，那么还需要额外的一支箭去引爆。为了实现判断，当两支气球重合时，我们可以把右边界缩小为两个气球右边界较小的一个值（因为此时新气球的左边界一定大于等于上面两个气球的左边界，所以不用判断），如果新气球左边界小于上面气球的右边界，那么就不需要额外的箭就能引爆。
遍历完所有的气球，我们便可以统计出需要的箭的数量。
下面为代码实现：
class Solution { public int findMinArrowShots(int[][] points) { if (points.length == 0) return 0; Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));//不使用a[0] - b[0]而使用Integer.compare(a, b)是为了防止整数溢出 int ans = 1; for (int i = 1; i &lt; points.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T18:11:19+08:00">
    <meta property="article:modified_time" content="2024-05-27T18:11:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贪心算法--区间调度问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>贪心算法</h2> 
<h3><a id="_4"></a>引言</h3> 
<p>贪心算法是一种简单而有效的算法设计技巧，广泛应用于解决各种优化问题。其基本思想是通过每一步的局部最优选择，最终达到全局最优解。贪心算法通常不会回溯之前的决策，而是基于当前状态作出最优决策，因此其执行效率较高。</p> 
<h3><a id="_9"></a>原理</h3> 
<p>贪心算法（Greedy Algorithm）是一种通过每一步的局部最优选择，最终达到全局最优解的算法范式。其核心思想可以概括为以下两点：</p> 
<ul><li>贪心选择性质：每一步都选择当前情况下看起来最好的选择，即局部最优解。</li><li>最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。贪心算法通过递归地求解子问题，并利用最优子结构性质，保证每一步的选择都是最优的。</li></ul> 
<p>由于贪心算法不回溯之前的决策，仅根据当前状态作出最优决策，这使得其执行效率较高，但也限制了其适用范围。贪心算法通常适用于满足贪心选择性质和最优子结构性质的问题，例如最小生成树、最短路径和任务调度等。</p> 
<h3><a id="_18"></a>应用场景</h3> 
<p>贪心算法在许多领域都有广泛的应用，特别是在以下几个方面：</p> 
<ol><li><strong>最小生成树：</strong> 在图论中，贪心算法经常用于构建最小生成树，例如 Prim 算法和 Kruskal 算法。这些算法通过每次选择权值最小的边来构建最小生成树，从而实现图的最优连通。</li><li><strong>最短路径问题：</strong> 在图论中，Dijkstra 算法和 A* 算法等都是基于贪心策略的最短路径算法。它们通过每次选择当前距离最短的顶点来逐步确定起点到其他顶点的最短路径。</li><li><strong>任务调度问题：</strong> 在任务调度问题中，贪心算法可以用于优化任务的执行顺序，以使得总执行时间最小化。例如，按照任务的截止时间或处理时间进行排序，然后依次执行。</li><li><strong>背包问题：</strong> 在背包问题中，贪心算法可以用于近似求解，例如分数背包问题中的分数贪心算法。这种算法每次选择单位价值最高的物品放入背包中，以尽可能达到背包的容量限制并使总价值最大化。</li><li><strong>区间调度问题：</strong> 在区间调度问题中，贪心算法可以用于确定最大数量的互不重叠的区间。例如，会议安排问题中，每次选择结束时间最早的会议安排，以尽可能安排更多的会议。</li><li><strong>Huffman 编码：</strong> Huffman 编码是一种用于数据压缩的贪心算法。它通过构建一棵最优前缀树来实现对字符的编码，使得出现频率较高的字符拥有较短的编码，从而实现数据的高效压缩。</li></ol> 
<h3><a id="_29"></a>实现贪心算法</h3> 
<blockquote> 
 <p>本篇我们主要分享的是区间调度问题相关例题。</p> 
</blockquote> 
<h4><a id="452_httpsleetcodecnproblemsminimumnumberofarrowstoburstballoons_33"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/" rel="nofollow">452. 用最少数量的箭引爆气球</a></h4> 
<p><img src="https://images2.imgbox.com/e2/cf/Lwu1Awt3_o.png" alt="image-20240524180422090"></p> 
<p>我们以 <strong>[[10,16],[2,8],[1,6],[7,12]]</strong> 为例：</p> 
<p>原气球的排列为：</p> 
<p><img src="https://images2.imgbox.com/21/cf/blNymIzg_o.png" alt="image-20240524190910742"></p> 
<p>题目要求求出引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</p> 
<p>如果按照原来顺序去判断的话，很难找出有重复的气球，所以我们可以对气球先进行排序（按照左边界或者右边界排序都可以，本题我按照左边界排序来进行讲解）</p> 
<p>排序后为：</p> 
<p><img src="https://images2.imgbox.com/15/5b/calG8Eyf_o.png" alt="image-20240524191023959"></p> 
<p>排序了之后我们就可以从上往下遍历去判断是否重合了。</p> 
<p>当下面的气球的左边界小于等于上面气球的右边界时，证明两个气球重合，可以用一支箭引爆。</p> 
<p>当然下面一个气球有可能和上面两个气球都重合，如果只和上面一个气球重合而不和上上面气球重合的话，那么还需要额外的一支箭去引爆。为了实现判断，当两支气球重合时，我们可以把右边界缩小为两个气球右边界较小的一个值（因为此时新气球的左边界一定大于等于上面两个气球的左边界，所以不用判断），如果新气球左边界小于上面气球的右边界，那么就不需要额外的箭就能引爆。</p> 
<p>遍历完所有的气球，我们便可以统计出需要的箭的数量。</p> 
<p>下面为代码实现：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>points<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不使用a[0] - b[0]而使用Integer.compare(a, b)是为了防止整数溢出</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> points<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> points<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把上一个气球右边界修改为较小值</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                ans<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="435_httpsleetcodecnproblemsnonoverlappingintervals_80"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/" rel="nofollow">435. 无重叠区间</a></h4> 
<p><img src="https://images2.imgbox.com/44/60/bqU23NWt_o.png" alt="image-20240524184413408"></p> 
<p>本题相比于上一题增加了一点难度，下面我是按照我的思路来讲解。</p> 
<p>首先我们依然是要先进行排序（用 <strong>[[1,2],[2,3],[3,4],[1,3]]</strong> 举例）：</p> 
<p><img src="https://images2.imgbox.com/c4/68/EmBU7j1W_o.png" alt="在这里插入图片描述"></p> 
<p>排序后为：<br> <img src="https://images2.imgbox.com/46/39/BW5iid1h_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以直观地看出只要删除1，3便可以实现剩下的区间没有重叠。</p> 
<p>那么具体代码上怎么去实现呢？</p> 
<p>整体思路和上一道题有些类似，当本区间左边界比上一个区间右边界小的时候我们就需要去删除了。删除在代码上只需要将此区间右边界设置为此区间与上一个区间中的较小值就可以了。如果此区间左边界大于等于上一个区间右边界，那么就证明两个区间没有重合，不需要进行操作。</p> 
<p>下面是代码实现：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> intervals<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                ans<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="56_httpsleetcodecnproblemsmergeintervals_122"></a><a href="https://leetcode.cn/problems/merge-intervals/" rel="nofollow">56. 合并区间</a></h4> 
<p><img src="https://images2.imgbox.com/48/bd/bVaiOpT5_o.png" alt="image-20240524192004312"></p> 
<p>本题和上面两道题也比较类似，大致讲一下思路。</p> 
<p>先进行排序，然后用此区间左边界与上一个区间右边界进行比较，如果满足重叠，则进行记录。</p> 
<p>下面用代码来具体看一下：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//如果集合为空或者此区间左边界大于最后录入集合的区间右边界，则直接记录答案就可以了，反之就证明有重叠</span>
                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重叠的区间左边界是不用变的，右边界需要修改成两个区间右边界的较大值，就可以了</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_149"></a>结语</h3> 
<p>在本文中，我们深入探讨了贪心算法的原理、应用场景以及实现方法。贪心算法作为一种简单而强大的算法设计技巧，已经在许多领域得到了广泛的应用，如图论、任务调度、最优化问题等。通过每一步的局部最优选择，贪心算法能够快速地找到问题的最优解，具有较高的执行效率。</p> 
<p>在实际应用中，贪心算法的灵活运用能够为我们带来更多的便利和效益。通过深入理解贪心算法的原理和特点，我们可以更好地利用这一算法工具，为解决实际问题提供有效的解决方案。</p> 
<p>希望本文能够帮助读者更好地理解贪心算法，并在实际应用中取得更好的效果。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/87caa2cddef77b2f30e434a95048fff4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTTPS 的加密流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2fe32355acf040ed922c2b9609ce05c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">检测 CSS 中的 JavaScript 支持</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>